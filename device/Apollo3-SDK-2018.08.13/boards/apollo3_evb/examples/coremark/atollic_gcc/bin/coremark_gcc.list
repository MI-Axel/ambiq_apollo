
coremark_gcc.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000076f4  0000c000  0000c000  0000c000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .stack        00001000  10000000  10000000  00030000  2**2
                  ALLOC
  2 .data         00000040  10001000  000136f4  00021000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00000604  10001040  00013734  00021040  2**3
                  ALLOC
  4 .ARM.attributes 00000037  00000000  00000000  00021040  2**0
                  CONTENTS, READONLY
  5 .debug_info   0002a5c8  00000000  00000000  00021077  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000048a5  00000000  00000000  0004b63f  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    0000e9b4  00000000  00000000  0004fee4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_aranges 000008c0  00000000  00000000  0005e898  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_ranges 00002288  00000000  00000000  0005f158  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   000093e1  00000000  00000000  000613e0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000abb1  00000000  00000000  0006a7c1  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000007c  00000000  00000000  00075372  2**0
                  CONTENTS, READONLY
 13 .debug_frame  00001b34  00000000  00000000  000753f0  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0000c000 <g_am_pfnVectors>:
    c000:	00 10 00 10 b9 f9 00 00 b1 f9 00 00 21 fa 00 00     ............!...
    c010:	21 fa 00 00 21 fa 00 00 21 fa 00 00 00 00 00 00     !...!...!.......
	...
    c02c:	b5 f9 00 00 b5 f9 00 00 00 00 00 00 b5 f9 00 00     ................
    c03c:	d9 cc 00 00 b5 f9 00 00 b5 f9 00 00 b5 f9 00 00     ................
    c04c:	b5 f9 00 00 b5 f9 00 00 b5 f9 00 00 b5 f9 00 00     ................
    c05c:	b5 f9 00 00 b5 f9 00 00 b5 f9 00 00 b5 f9 00 00     ................
    c06c:	b5 f9 00 00 b5 f9 00 00 b5 f9 00 00 b5 f9 00 00     ................
    c07c:	b5 f9 00 00 b5 f9 00 00 b5 f9 00 00 b5 f9 00 00     ................
    c08c:	b5 f9 00 00 b5 f9 00 00 b5 f9 00 00 b5 f9 00 00     ................
    c09c:	b5 f9 00 00 b5 f9 00 00 b5 f9 00 00 b5 f9 00 00     ................
    c0ac:	b5 f9 00 00 b5 f9 00 00 b5 f9 00 00 b5 f9 00 00     ................
    c0bc:	b5 f9 00 00 b5 f9 00 00 b5 f9 00 00 b5 f9 00 00     ................
    c0cc:	b5 f9 00 00                                         ....

0000c0d0 <__Patchable>:
	...

0000c100 <__aeabi_drsub>:
    c100:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
    c104:	e002      	b.n	c10c <__adddf3>
    c106:	bf00      	nop

0000c108 <__aeabi_dsub>:
    c108:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0000c10c <__adddf3>:
    c10c:	b530      	push	{r4, r5, lr}
    c10e:	ea4f 0441 	mov.w	r4, r1, lsl #1
    c112:	ea4f 0543 	mov.w	r5, r3, lsl #1
    c116:	ea94 0f05 	teq	r4, r5
    c11a:	bf08      	it	eq
    c11c:	ea90 0f02 	teqeq	r0, r2
    c120:	bf1f      	itttt	ne
    c122:	ea54 0c00 	orrsne.w	ip, r4, r0
    c126:	ea55 0c02 	orrsne.w	ip, r5, r2
    c12a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
    c12e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    c132:	f000 80e2 	beq.w	c2fa <__adddf3+0x1ee>
    c136:	ea4f 5454 	mov.w	r4, r4, lsr #21
    c13a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
    c13e:	bfb8      	it	lt
    c140:	426d      	neglt	r5, r5
    c142:	dd0c      	ble.n	c15e <__adddf3+0x52>
    c144:	442c      	add	r4, r5
    c146:	ea80 0202 	eor.w	r2, r0, r2
    c14a:	ea81 0303 	eor.w	r3, r1, r3
    c14e:	ea82 0000 	eor.w	r0, r2, r0
    c152:	ea83 0101 	eor.w	r1, r3, r1
    c156:	ea80 0202 	eor.w	r2, r0, r2
    c15a:	ea81 0303 	eor.w	r3, r1, r3
    c15e:	2d36      	cmp	r5, #54	; 0x36
    c160:	bf88      	it	hi
    c162:	bd30      	pophi	{r4, r5, pc}
    c164:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    c168:	ea4f 3101 	mov.w	r1, r1, lsl #12
    c16c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
    c170:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
    c174:	d002      	beq.n	c17c <__adddf3+0x70>
    c176:	4240      	negs	r0, r0
    c178:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    c17c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
    c180:	ea4f 3303 	mov.w	r3, r3, lsl #12
    c184:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
    c188:	d002      	beq.n	c190 <__adddf3+0x84>
    c18a:	4252      	negs	r2, r2
    c18c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    c190:	ea94 0f05 	teq	r4, r5
    c194:	f000 80a7 	beq.w	c2e6 <__adddf3+0x1da>
    c198:	f1a4 0401 	sub.w	r4, r4, #1
    c19c:	f1d5 0e20 	rsbs	lr, r5, #32
    c1a0:	db0d      	blt.n	c1be <__adddf3+0xb2>
    c1a2:	fa02 fc0e 	lsl.w	ip, r2, lr
    c1a6:	fa22 f205 	lsr.w	r2, r2, r5
    c1aa:	1880      	adds	r0, r0, r2
    c1ac:	f141 0100 	adc.w	r1, r1, #0
    c1b0:	fa03 f20e 	lsl.w	r2, r3, lr
    c1b4:	1880      	adds	r0, r0, r2
    c1b6:	fa43 f305 	asr.w	r3, r3, r5
    c1ba:	4159      	adcs	r1, r3
    c1bc:	e00e      	b.n	c1dc <__adddf3+0xd0>
    c1be:	f1a5 0520 	sub.w	r5, r5, #32
    c1c2:	f10e 0e20 	add.w	lr, lr, #32
    c1c6:	2a01      	cmp	r2, #1
    c1c8:	fa03 fc0e 	lsl.w	ip, r3, lr
    c1cc:	bf28      	it	cs
    c1ce:	f04c 0c02 	orrcs.w	ip, ip, #2
    c1d2:	fa43 f305 	asr.w	r3, r3, r5
    c1d6:	18c0      	adds	r0, r0, r3
    c1d8:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
    c1dc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    c1e0:	d507      	bpl.n	c1f2 <__adddf3+0xe6>
    c1e2:	f04f 0e00 	mov.w	lr, #0
    c1e6:	f1dc 0c00 	rsbs	ip, ip, #0
    c1ea:	eb7e 0000 	sbcs.w	r0, lr, r0
    c1ee:	eb6e 0101 	sbc.w	r1, lr, r1
    c1f2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
    c1f6:	d31b      	bcc.n	c230 <__adddf3+0x124>
    c1f8:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
    c1fc:	d30c      	bcc.n	c218 <__adddf3+0x10c>
    c1fe:	0849      	lsrs	r1, r1, #1
    c200:	ea5f 0030 	movs.w	r0, r0, rrx
    c204:	ea4f 0c3c 	mov.w	ip, ip, rrx
    c208:	f104 0401 	add.w	r4, r4, #1
    c20c:	ea4f 5244 	mov.w	r2, r4, lsl #21
    c210:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
    c214:	f080 809a 	bcs.w	c34c <__adddf3+0x240>
    c218:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
    c21c:	bf08      	it	eq
    c21e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    c222:	f150 0000 	adcs.w	r0, r0, #0
    c226:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    c22a:	ea41 0105 	orr.w	r1, r1, r5
    c22e:	bd30      	pop	{r4, r5, pc}
    c230:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
    c234:	4140      	adcs	r0, r0
    c236:	eb41 0101 	adc.w	r1, r1, r1
    c23a:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    c23e:	f1a4 0401 	sub.w	r4, r4, #1
    c242:	d1e9      	bne.n	c218 <__adddf3+0x10c>
    c244:	f091 0f00 	teq	r1, #0
    c248:	bf04      	itt	eq
    c24a:	4601      	moveq	r1, r0
    c24c:	2000      	moveq	r0, #0
    c24e:	fab1 f381 	clz	r3, r1
    c252:	bf08      	it	eq
    c254:	3320      	addeq	r3, #32
    c256:	f1a3 030b 	sub.w	r3, r3, #11
    c25a:	f1b3 0220 	subs.w	r2, r3, #32
    c25e:	da0c      	bge.n	c27a <__adddf3+0x16e>
    c260:	320c      	adds	r2, #12
    c262:	dd08      	ble.n	c276 <__adddf3+0x16a>
    c264:	f102 0c14 	add.w	ip, r2, #20
    c268:	f1c2 020c 	rsb	r2, r2, #12
    c26c:	fa01 f00c 	lsl.w	r0, r1, ip
    c270:	fa21 f102 	lsr.w	r1, r1, r2
    c274:	e00c      	b.n	c290 <__adddf3+0x184>
    c276:	f102 0214 	add.w	r2, r2, #20
    c27a:	bfd8      	it	le
    c27c:	f1c2 0c20 	rsble	ip, r2, #32
    c280:	fa01 f102 	lsl.w	r1, r1, r2
    c284:	fa20 fc0c 	lsr.w	ip, r0, ip
    c288:	bfdc      	itt	le
    c28a:	ea41 010c 	orrle.w	r1, r1, ip
    c28e:	4090      	lslle	r0, r2
    c290:	1ae4      	subs	r4, r4, r3
    c292:	bfa2      	ittt	ge
    c294:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
    c298:	4329      	orrge	r1, r5
    c29a:	bd30      	popge	{r4, r5, pc}
    c29c:	ea6f 0404 	mvn.w	r4, r4
    c2a0:	3c1f      	subs	r4, #31
    c2a2:	da1c      	bge.n	c2de <__adddf3+0x1d2>
    c2a4:	340c      	adds	r4, #12
    c2a6:	dc0e      	bgt.n	c2c6 <__adddf3+0x1ba>
    c2a8:	f104 0414 	add.w	r4, r4, #20
    c2ac:	f1c4 0220 	rsb	r2, r4, #32
    c2b0:	fa20 f004 	lsr.w	r0, r0, r4
    c2b4:	fa01 f302 	lsl.w	r3, r1, r2
    c2b8:	ea40 0003 	orr.w	r0, r0, r3
    c2bc:	fa21 f304 	lsr.w	r3, r1, r4
    c2c0:	ea45 0103 	orr.w	r1, r5, r3
    c2c4:	bd30      	pop	{r4, r5, pc}
    c2c6:	f1c4 040c 	rsb	r4, r4, #12
    c2ca:	f1c4 0220 	rsb	r2, r4, #32
    c2ce:	fa20 f002 	lsr.w	r0, r0, r2
    c2d2:	fa01 f304 	lsl.w	r3, r1, r4
    c2d6:	ea40 0003 	orr.w	r0, r0, r3
    c2da:	4629      	mov	r1, r5
    c2dc:	bd30      	pop	{r4, r5, pc}
    c2de:	fa21 f004 	lsr.w	r0, r1, r4
    c2e2:	4629      	mov	r1, r5
    c2e4:	bd30      	pop	{r4, r5, pc}
    c2e6:	f094 0f00 	teq	r4, #0
    c2ea:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
    c2ee:	bf06      	itte	eq
    c2f0:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
    c2f4:	3401      	addeq	r4, #1
    c2f6:	3d01      	subne	r5, #1
    c2f8:	e74e      	b.n	c198 <__adddf3+0x8c>
    c2fa:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    c2fe:	bf18      	it	ne
    c300:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    c304:	d029      	beq.n	c35a <__adddf3+0x24e>
    c306:	ea94 0f05 	teq	r4, r5
    c30a:	bf08      	it	eq
    c30c:	ea90 0f02 	teqeq	r0, r2
    c310:	d005      	beq.n	c31e <__adddf3+0x212>
    c312:	ea54 0c00 	orrs.w	ip, r4, r0
    c316:	bf04      	itt	eq
    c318:	4619      	moveq	r1, r3
    c31a:	4610      	moveq	r0, r2
    c31c:	bd30      	pop	{r4, r5, pc}
    c31e:	ea91 0f03 	teq	r1, r3
    c322:	bf1e      	ittt	ne
    c324:	2100      	movne	r1, #0
    c326:	2000      	movne	r0, #0
    c328:	bd30      	popne	{r4, r5, pc}
    c32a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
    c32e:	d105      	bne.n	c33c <__adddf3+0x230>
    c330:	0040      	lsls	r0, r0, #1
    c332:	4149      	adcs	r1, r1
    c334:	bf28      	it	cs
    c336:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
    c33a:	bd30      	pop	{r4, r5, pc}
    c33c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
    c340:	bf3c      	itt	cc
    c342:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
    c346:	bd30      	popcc	{r4, r5, pc}
    c348:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    c34c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
    c350:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    c354:	f04f 0000 	mov.w	r0, #0
    c358:	bd30      	pop	{r4, r5, pc}
    c35a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    c35e:	bf1a      	itte	ne
    c360:	4619      	movne	r1, r3
    c362:	4610      	movne	r0, r2
    c364:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
    c368:	bf1c      	itt	ne
    c36a:	460b      	movne	r3, r1
    c36c:	4602      	movne	r2, r0
    c36e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    c372:	bf06      	itte	eq
    c374:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
    c378:	ea91 0f03 	teqeq	r1, r3
    c37c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
    c380:	bd30      	pop	{r4, r5, pc}
    c382:	bf00      	nop

0000c384 <__aeabi_ui2d>:
    c384:	f090 0f00 	teq	r0, #0
    c388:	bf04      	itt	eq
    c38a:	2100      	moveq	r1, #0
    c38c:	4770      	bxeq	lr
    c38e:	b530      	push	{r4, r5, lr}
    c390:	f44f 6480 	mov.w	r4, #1024	; 0x400
    c394:	f104 0432 	add.w	r4, r4, #50	; 0x32
    c398:	f04f 0500 	mov.w	r5, #0
    c39c:	f04f 0100 	mov.w	r1, #0
    c3a0:	e750      	b.n	c244 <__adddf3+0x138>
    c3a2:	bf00      	nop

0000c3a4 <__aeabi_i2d>:
    c3a4:	f090 0f00 	teq	r0, #0
    c3a8:	bf04      	itt	eq
    c3aa:	2100      	moveq	r1, #0
    c3ac:	4770      	bxeq	lr
    c3ae:	b530      	push	{r4, r5, lr}
    c3b0:	f44f 6480 	mov.w	r4, #1024	; 0x400
    c3b4:	f104 0432 	add.w	r4, r4, #50	; 0x32
    c3b8:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
    c3bc:	bf48      	it	mi
    c3be:	4240      	negmi	r0, r0
    c3c0:	f04f 0100 	mov.w	r1, #0
    c3c4:	e73e      	b.n	c244 <__adddf3+0x138>
    c3c6:	bf00      	nop

0000c3c8 <__aeabi_f2d>:
    c3c8:	0042      	lsls	r2, r0, #1
    c3ca:	ea4f 01e2 	mov.w	r1, r2, asr #3
    c3ce:	ea4f 0131 	mov.w	r1, r1, rrx
    c3d2:	ea4f 7002 	mov.w	r0, r2, lsl #28
    c3d6:	bf1f      	itttt	ne
    c3d8:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
    c3dc:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    c3e0:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
    c3e4:	4770      	bxne	lr
    c3e6:	f092 0f00 	teq	r2, #0
    c3ea:	bf14      	ite	ne
    c3ec:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    c3f0:	4770      	bxeq	lr
    c3f2:	b530      	push	{r4, r5, lr}
    c3f4:	f44f 7460 	mov.w	r4, #896	; 0x380
    c3f8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    c3fc:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    c400:	e720      	b.n	c244 <__adddf3+0x138>
    c402:	bf00      	nop

0000c404 <__aeabi_ul2d>:
    c404:	ea50 0201 	orrs.w	r2, r0, r1
    c408:	bf08      	it	eq
    c40a:	4770      	bxeq	lr
    c40c:	b530      	push	{r4, r5, lr}
    c40e:	f04f 0500 	mov.w	r5, #0
    c412:	e00a      	b.n	c42a <__aeabi_l2d+0x16>

0000c414 <__aeabi_l2d>:
    c414:	ea50 0201 	orrs.w	r2, r0, r1
    c418:	bf08      	it	eq
    c41a:	4770      	bxeq	lr
    c41c:	b530      	push	{r4, r5, lr}
    c41e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
    c422:	d502      	bpl.n	c42a <__aeabi_l2d+0x16>
    c424:	4240      	negs	r0, r0
    c426:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    c42a:	f44f 6480 	mov.w	r4, #1024	; 0x400
    c42e:	f104 0432 	add.w	r4, r4, #50	; 0x32
    c432:	ea5f 5c91 	movs.w	ip, r1, lsr #22
    c436:	f43f aedc 	beq.w	c1f2 <__adddf3+0xe6>
    c43a:	f04f 0203 	mov.w	r2, #3
    c43e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    c442:	bf18      	it	ne
    c444:	3203      	addne	r2, #3
    c446:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    c44a:	bf18      	it	ne
    c44c:	3203      	addne	r2, #3
    c44e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
    c452:	f1c2 0320 	rsb	r3, r2, #32
    c456:	fa00 fc03 	lsl.w	ip, r0, r3
    c45a:	fa20 f002 	lsr.w	r0, r0, r2
    c45e:	fa01 fe03 	lsl.w	lr, r1, r3
    c462:	ea40 000e 	orr.w	r0, r0, lr
    c466:	fa21 f102 	lsr.w	r1, r1, r2
    c46a:	4414      	add	r4, r2
    c46c:	e6c1      	b.n	c1f2 <__adddf3+0xe6>
    c46e:	bf00      	nop

0000c470 <__aeabi_dmul>:
    c470:	b570      	push	{r4, r5, r6, lr}
    c472:	f04f 0cff 	mov.w	ip, #255	; 0xff
    c476:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    c47a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    c47e:	bf1d      	ittte	ne
    c480:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    c484:	ea94 0f0c 	teqne	r4, ip
    c488:	ea95 0f0c 	teqne	r5, ip
    c48c:	f000 f8de 	bleq	c64c <__aeabi_dmul+0x1dc>
    c490:	442c      	add	r4, r5
    c492:	ea81 0603 	eor.w	r6, r1, r3
    c496:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
    c49a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
    c49e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
    c4a2:	bf18      	it	ne
    c4a4:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
    c4a8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    c4ac:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    c4b0:	d038      	beq.n	c524 <__aeabi_dmul+0xb4>
    c4b2:	fba0 ce02 	umull	ip, lr, r0, r2
    c4b6:	f04f 0500 	mov.w	r5, #0
    c4ba:	fbe1 e502 	umlal	lr, r5, r1, r2
    c4be:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
    c4c2:	fbe0 e503 	umlal	lr, r5, r0, r3
    c4c6:	f04f 0600 	mov.w	r6, #0
    c4ca:	fbe1 5603 	umlal	r5, r6, r1, r3
    c4ce:	f09c 0f00 	teq	ip, #0
    c4d2:	bf18      	it	ne
    c4d4:	f04e 0e01 	orrne.w	lr, lr, #1
    c4d8:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
    c4dc:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
    c4e0:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
    c4e4:	d204      	bcs.n	c4f0 <__aeabi_dmul+0x80>
    c4e6:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
    c4ea:	416d      	adcs	r5, r5
    c4ec:	eb46 0606 	adc.w	r6, r6, r6
    c4f0:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
    c4f4:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
    c4f8:	ea4f 20c5 	mov.w	r0, r5, lsl #11
    c4fc:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
    c500:	ea4f 2ece 	mov.w	lr, lr, lsl #11
    c504:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    c508:	bf88      	it	hi
    c50a:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    c50e:	d81e      	bhi.n	c54e <__aeabi_dmul+0xde>
    c510:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
    c514:	bf08      	it	eq
    c516:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
    c51a:	f150 0000 	adcs.w	r0, r0, #0
    c51e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    c522:	bd70      	pop	{r4, r5, r6, pc}
    c524:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
    c528:	ea46 0101 	orr.w	r1, r6, r1
    c52c:	ea40 0002 	orr.w	r0, r0, r2
    c530:	ea81 0103 	eor.w	r1, r1, r3
    c534:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
    c538:	bfc2      	ittt	gt
    c53a:	ebd4 050c 	rsbsgt	r5, r4, ip
    c53e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    c542:	bd70      	popgt	{r4, r5, r6, pc}
    c544:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    c548:	f04f 0e00 	mov.w	lr, #0
    c54c:	3c01      	subs	r4, #1
    c54e:	f300 80ab 	bgt.w	c6a8 <__aeabi_dmul+0x238>
    c552:	f114 0f36 	cmn.w	r4, #54	; 0x36
    c556:	bfde      	ittt	le
    c558:	2000      	movle	r0, #0
    c55a:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
    c55e:	bd70      	pople	{r4, r5, r6, pc}
    c560:	f1c4 0400 	rsb	r4, r4, #0
    c564:	3c20      	subs	r4, #32
    c566:	da35      	bge.n	c5d4 <__aeabi_dmul+0x164>
    c568:	340c      	adds	r4, #12
    c56a:	dc1b      	bgt.n	c5a4 <__aeabi_dmul+0x134>
    c56c:	f104 0414 	add.w	r4, r4, #20
    c570:	f1c4 0520 	rsb	r5, r4, #32
    c574:	fa00 f305 	lsl.w	r3, r0, r5
    c578:	fa20 f004 	lsr.w	r0, r0, r4
    c57c:	fa01 f205 	lsl.w	r2, r1, r5
    c580:	ea40 0002 	orr.w	r0, r0, r2
    c584:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
    c588:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    c58c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    c590:	fa21 f604 	lsr.w	r6, r1, r4
    c594:	eb42 0106 	adc.w	r1, r2, r6
    c598:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    c59c:	bf08      	it	eq
    c59e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    c5a2:	bd70      	pop	{r4, r5, r6, pc}
    c5a4:	f1c4 040c 	rsb	r4, r4, #12
    c5a8:	f1c4 0520 	rsb	r5, r4, #32
    c5ac:	fa00 f304 	lsl.w	r3, r0, r4
    c5b0:	fa20 f005 	lsr.w	r0, r0, r5
    c5b4:	fa01 f204 	lsl.w	r2, r1, r4
    c5b8:	ea40 0002 	orr.w	r0, r0, r2
    c5bc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    c5c0:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    c5c4:	f141 0100 	adc.w	r1, r1, #0
    c5c8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    c5cc:	bf08      	it	eq
    c5ce:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    c5d2:	bd70      	pop	{r4, r5, r6, pc}
    c5d4:	f1c4 0520 	rsb	r5, r4, #32
    c5d8:	fa00 f205 	lsl.w	r2, r0, r5
    c5dc:	ea4e 0e02 	orr.w	lr, lr, r2
    c5e0:	fa20 f304 	lsr.w	r3, r0, r4
    c5e4:	fa01 f205 	lsl.w	r2, r1, r5
    c5e8:	ea43 0302 	orr.w	r3, r3, r2
    c5ec:	fa21 f004 	lsr.w	r0, r1, r4
    c5f0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    c5f4:	fa21 f204 	lsr.w	r2, r1, r4
    c5f8:	ea20 0002 	bic.w	r0, r0, r2
    c5fc:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
    c600:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    c604:	bf08      	it	eq
    c606:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    c60a:	bd70      	pop	{r4, r5, r6, pc}
    c60c:	f094 0f00 	teq	r4, #0
    c610:	d10f      	bne.n	c632 <__aeabi_dmul+0x1c2>
    c612:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
    c616:	0040      	lsls	r0, r0, #1
    c618:	eb41 0101 	adc.w	r1, r1, r1
    c61c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    c620:	bf08      	it	eq
    c622:	3c01      	subeq	r4, #1
    c624:	d0f7      	beq.n	c616 <__aeabi_dmul+0x1a6>
    c626:	ea41 0106 	orr.w	r1, r1, r6
    c62a:	f095 0f00 	teq	r5, #0
    c62e:	bf18      	it	ne
    c630:	4770      	bxne	lr
    c632:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
    c636:	0052      	lsls	r2, r2, #1
    c638:	eb43 0303 	adc.w	r3, r3, r3
    c63c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
    c640:	bf08      	it	eq
    c642:	3d01      	subeq	r5, #1
    c644:	d0f7      	beq.n	c636 <__aeabi_dmul+0x1c6>
    c646:	ea43 0306 	orr.w	r3, r3, r6
    c64a:	4770      	bx	lr
    c64c:	ea94 0f0c 	teq	r4, ip
    c650:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    c654:	bf18      	it	ne
    c656:	ea95 0f0c 	teqne	r5, ip
    c65a:	d00c      	beq.n	c676 <__aeabi_dmul+0x206>
    c65c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    c660:	bf18      	it	ne
    c662:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    c666:	d1d1      	bne.n	c60c <__aeabi_dmul+0x19c>
    c668:	ea81 0103 	eor.w	r1, r1, r3
    c66c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    c670:	f04f 0000 	mov.w	r0, #0
    c674:	bd70      	pop	{r4, r5, r6, pc}
    c676:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    c67a:	bf06      	itte	eq
    c67c:	4610      	moveq	r0, r2
    c67e:	4619      	moveq	r1, r3
    c680:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    c684:	d019      	beq.n	c6ba <__aeabi_dmul+0x24a>
    c686:	ea94 0f0c 	teq	r4, ip
    c68a:	d102      	bne.n	c692 <__aeabi_dmul+0x222>
    c68c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
    c690:	d113      	bne.n	c6ba <__aeabi_dmul+0x24a>
    c692:	ea95 0f0c 	teq	r5, ip
    c696:	d105      	bne.n	c6a4 <__aeabi_dmul+0x234>
    c698:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
    c69c:	bf1c      	itt	ne
    c69e:	4610      	movne	r0, r2
    c6a0:	4619      	movne	r1, r3
    c6a2:	d10a      	bne.n	c6ba <__aeabi_dmul+0x24a>
    c6a4:	ea81 0103 	eor.w	r1, r1, r3
    c6a8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    c6ac:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    c6b0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    c6b4:	f04f 0000 	mov.w	r0, #0
    c6b8:	bd70      	pop	{r4, r5, r6, pc}
    c6ba:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    c6be:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
    c6c2:	bd70      	pop	{r4, r5, r6, pc}

0000c6c4 <__aeabi_ddiv>:
    c6c4:	b570      	push	{r4, r5, r6, lr}
    c6c6:	f04f 0cff 	mov.w	ip, #255	; 0xff
    c6ca:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    c6ce:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    c6d2:	bf1d      	ittte	ne
    c6d4:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    c6d8:	ea94 0f0c 	teqne	r4, ip
    c6dc:	ea95 0f0c 	teqne	r5, ip
    c6e0:	f000 f8a7 	bleq	c832 <__aeabi_ddiv+0x16e>
    c6e4:	eba4 0405 	sub.w	r4, r4, r5
    c6e8:	ea81 0e03 	eor.w	lr, r1, r3
    c6ec:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    c6f0:	ea4f 3101 	mov.w	r1, r1, lsl #12
    c6f4:	f000 8088 	beq.w	c808 <__aeabi_ddiv+0x144>
    c6f8:	ea4f 3303 	mov.w	r3, r3, lsl #12
    c6fc:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
    c700:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
    c704:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
    c708:	ea4f 2202 	mov.w	r2, r2, lsl #8
    c70c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
    c710:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
    c714:	ea4f 2600 	mov.w	r6, r0, lsl #8
    c718:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
    c71c:	429d      	cmp	r5, r3
    c71e:	bf08      	it	eq
    c720:	4296      	cmpeq	r6, r2
    c722:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
    c726:	f504 7440 	add.w	r4, r4, #768	; 0x300
    c72a:	d202      	bcs.n	c732 <__aeabi_ddiv+0x6e>
    c72c:	085b      	lsrs	r3, r3, #1
    c72e:	ea4f 0232 	mov.w	r2, r2, rrx
    c732:	1ab6      	subs	r6, r6, r2
    c734:	eb65 0503 	sbc.w	r5, r5, r3
    c738:	085b      	lsrs	r3, r3, #1
    c73a:	ea4f 0232 	mov.w	r2, r2, rrx
    c73e:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
    c742:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
    c746:	ebb6 0e02 	subs.w	lr, r6, r2
    c74a:	eb75 0e03 	sbcs.w	lr, r5, r3
    c74e:	bf22      	ittt	cs
    c750:	1ab6      	subcs	r6, r6, r2
    c752:	4675      	movcs	r5, lr
    c754:	ea40 000c 	orrcs.w	r0, r0, ip
    c758:	085b      	lsrs	r3, r3, #1
    c75a:	ea4f 0232 	mov.w	r2, r2, rrx
    c75e:	ebb6 0e02 	subs.w	lr, r6, r2
    c762:	eb75 0e03 	sbcs.w	lr, r5, r3
    c766:	bf22      	ittt	cs
    c768:	1ab6      	subcs	r6, r6, r2
    c76a:	4675      	movcs	r5, lr
    c76c:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
    c770:	085b      	lsrs	r3, r3, #1
    c772:	ea4f 0232 	mov.w	r2, r2, rrx
    c776:	ebb6 0e02 	subs.w	lr, r6, r2
    c77a:	eb75 0e03 	sbcs.w	lr, r5, r3
    c77e:	bf22      	ittt	cs
    c780:	1ab6      	subcs	r6, r6, r2
    c782:	4675      	movcs	r5, lr
    c784:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
    c788:	085b      	lsrs	r3, r3, #1
    c78a:	ea4f 0232 	mov.w	r2, r2, rrx
    c78e:	ebb6 0e02 	subs.w	lr, r6, r2
    c792:	eb75 0e03 	sbcs.w	lr, r5, r3
    c796:	bf22      	ittt	cs
    c798:	1ab6      	subcs	r6, r6, r2
    c79a:	4675      	movcs	r5, lr
    c79c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
    c7a0:	ea55 0e06 	orrs.w	lr, r5, r6
    c7a4:	d018      	beq.n	c7d8 <__aeabi_ddiv+0x114>
    c7a6:	ea4f 1505 	mov.w	r5, r5, lsl #4
    c7aa:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
    c7ae:	ea4f 1606 	mov.w	r6, r6, lsl #4
    c7b2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    c7b6:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
    c7ba:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    c7be:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
    c7c2:	d1c0      	bne.n	c746 <__aeabi_ddiv+0x82>
    c7c4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    c7c8:	d10b      	bne.n	c7e2 <__aeabi_ddiv+0x11e>
    c7ca:	ea41 0100 	orr.w	r1, r1, r0
    c7ce:	f04f 0000 	mov.w	r0, #0
    c7d2:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
    c7d6:	e7b6      	b.n	c746 <__aeabi_ddiv+0x82>
    c7d8:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    c7dc:	bf04      	itt	eq
    c7de:	4301      	orreq	r1, r0
    c7e0:	2000      	moveq	r0, #0
    c7e2:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    c7e6:	bf88      	it	hi
    c7e8:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    c7ec:	f63f aeaf 	bhi.w	c54e <__aeabi_dmul+0xde>
    c7f0:	ebb5 0c03 	subs.w	ip, r5, r3
    c7f4:	bf04      	itt	eq
    c7f6:	ebb6 0c02 	subseq.w	ip, r6, r2
    c7fa:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    c7fe:	f150 0000 	adcs.w	r0, r0, #0
    c802:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    c806:	bd70      	pop	{r4, r5, r6, pc}
    c808:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
    c80c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
    c810:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
    c814:	bfc2      	ittt	gt
    c816:	ebd4 050c 	rsbsgt	r5, r4, ip
    c81a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    c81e:	bd70      	popgt	{r4, r5, r6, pc}
    c820:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    c824:	f04f 0e00 	mov.w	lr, #0
    c828:	3c01      	subs	r4, #1
    c82a:	e690      	b.n	c54e <__aeabi_dmul+0xde>
    c82c:	ea45 0e06 	orr.w	lr, r5, r6
    c830:	e68d      	b.n	c54e <__aeabi_dmul+0xde>
    c832:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    c836:	ea94 0f0c 	teq	r4, ip
    c83a:	bf08      	it	eq
    c83c:	ea95 0f0c 	teqeq	r5, ip
    c840:	f43f af3b 	beq.w	c6ba <__aeabi_dmul+0x24a>
    c844:	ea94 0f0c 	teq	r4, ip
    c848:	d10a      	bne.n	c860 <__aeabi_ddiv+0x19c>
    c84a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    c84e:	f47f af34 	bne.w	c6ba <__aeabi_dmul+0x24a>
    c852:	ea95 0f0c 	teq	r5, ip
    c856:	f47f af25 	bne.w	c6a4 <__aeabi_dmul+0x234>
    c85a:	4610      	mov	r0, r2
    c85c:	4619      	mov	r1, r3
    c85e:	e72c      	b.n	c6ba <__aeabi_dmul+0x24a>
    c860:	ea95 0f0c 	teq	r5, ip
    c864:	d106      	bne.n	c874 <__aeabi_ddiv+0x1b0>
    c866:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    c86a:	f43f aefd 	beq.w	c668 <__aeabi_dmul+0x1f8>
    c86e:	4610      	mov	r0, r2
    c870:	4619      	mov	r1, r3
    c872:	e722      	b.n	c6ba <__aeabi_dmul+0x24a>
    c874:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    c878:	bf18      	it	ne
    c87a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    c87e:	f47f aec5 	bne.w	c60c <__aeabi_dmul+0x19c>
    c882:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
    c886:	f47f af0d 	bne.w	c6a4 <__aeabi_dmul+0x234>
    c88a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
    c88e:	f47f aeeb 	bne.w	c668 <__aeabi_dmul+0x1f8>
    c892:	e712      	b.n	c6ba <__aeabi_dmul+0x24a>

0000c894 <__gedf2>:
    c894:	f04f 3cff 	mov.w	ip, #4294967295
    c898:	e006      	b.n	c8a8 <__cmpdf2+0x4>
    c89a:	bf00      	nop

0000c89c <__ledf2>:
    c89c:	f04f 0c01 	mov.w	ip, #1
    c8a0:	e002      	b.n	c8a8 <__cmpdf2+0x4>
    c8a2:	bf00      	nop

0000c8a4 <__cmpdf2>:
    c8a4:	f04f 0c01 	mov.w	ip, #1
    c8a8:	f84d cd04 	str.w	ip, [sp, #-4]!
    c8ac:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    c8b0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    c8b4:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    c8b8:	bf18      	it	ne
    c8ba:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
    c8be:	d01b      	beq.n	c8f8 <__cmpdf2+0x54>
    c8c0:	b001      	add	sp, #4
    c8c2:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
    c8c6:	bf0c      	ite	eq
    c8c8:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
    c8cc:	ea91 0f03 	teqne	r1, r3
    c8d0:	bf02      	ittt	eq
    c8d2:	ea90 0f02 	teqeq	r0, r2
    c8d6:	2000      	moveq	r0, #0
    c8d8:	4770      	bxeq	lr
    c8da:	f110 0f00 	cmn.w	r0, #0
    c8de:	ea91 0f03 	teq	r1, r3
    c8e2:	bf58      	it	pl
    c8e4:	4299      	cmppl	r1, r3
    c8e6:	bf08      	it	eq
    c8e8:	4290      	cmpeq	r0, r2
    c8ea:	bf2c      	ite	cs
    c8ec:	17d8      	asrcs	r0, r3, #31
    c8ee:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
    c8f2:	f040 0001 	orr.w	r0, r0, #1
    c8f6:	4770      	bx	lr
    c8f8:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    c8fc:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    c900:	d102      	bne.n	c908 <__cmpdf2+0x64>
    c902:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
    c906:	d107      	bne.n	c918 <__cmpdf2+0x74>
    c908:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    c90c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    c910:	d1d6      	bne.n	c8c0 <__cmpdf2+0x1c>
    c912:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
    c916:	d0d3      	beq.n	c8c0 <__cmpdf2+0x1c>
    c918:	f85d 0b04 	ldr.w	r0, [sp], #4
    c91c:	4770      	bx	lr
    c91e:	bf00      	nop

0000c920 <__aeabi_cdrcmple>:
    c920:	4684      	mov	ip, r0
    c922:	4610      	mov	r0, r2
    c924:	4662      	mov	r2, ip
    c926:	468c      	mov	ip, r1
    c928:	4619      	mov	r1, r3
    c92a:	4663      	mov	r3, ip
    c92c:	e000      	b.n	c930 <__aeabi_cdcmpeq>
    c92e:	bf00      	nop

0000c930 <__aeabi_cdcmpeq>:
    c930:	b501      	push	{r0, lr}
    c932:	f7ff ffb7 	bl	c8a4 <__cmpdf2>
    c936:	2800      	cmp	r0, #0
    c938:	bf48      	it	mi
    c93a:	f110 0f00 	cmnmi.w	r0, #0
    c93e:	bd01      	pop	{r0, pc}

0000c940 <__aeabi_dcmpeq>:
    c940:	f84d ed08 	str.w	lr, [sp, #-8]!
    c944:	f7ff fff4 	bl	c930 <__aeabi_cdcmpeq>
    c948:	bf0c      	ite	eq
    c94a:	2001      	moveq	r0, #1
    c94c:	2000      	movne	r0, #0
    c94e:	f85d fb08 	ldr.w	pc, [sp], #8
    c952:	bf00      	nop

0000c954 <__aeabi_dcmplt>:
    c954:	f84d ed08 	str.w	lr, [sp, #-8]!
    c958:	f7ff ffea 	bl	c930 <__aeabi_cdcmpeq>
    c95c:	bf34      	ite	cc
    c95e:	2001      	movcc	r0, #1
    c960:	2000      	movcs	r0, #0
    c962:	f85d fb08 	ldr.w	pc, [sp], #8
    c966:	bf00      	nop

0000c968 <__aeabi_dcmple>:
    c968:	f84d ed08 	str.w	lr, [sp, #-8]!
    c96c:	f7ff ffe0 	bl	c930 <__aeabi_cdcmpeq>
    c970:	bf94      	ite	ls
    c972:	2001      	movls	r0, #1
    c974:	2000      	movhi	r0, #0
    c976:	f85d fb08 	ldr.w	pc, [sp], #8
    c97a:	bf00      	nop

0000c97c <__aeabi_dcmpge>:
    c97c:	f84d ed08 	str.w	lr, [sp, #-8]!
    c980:	f7ff ffce 	bl	c920 <__aeabi_cdrcmple>
    c984:	bf94      	ite	ls
    c986:	2001      	movls	r0, #1
    c988:	2000      	movhi	r0, #0
    c98a:	f85d fb08 	ldr.w	pc, [sp], #8
    c98e:	bf00      	nop

0000c990 <__aeabi_dcmpgt>:
    c990:	f84d ed08 	str.w	lr, [sp, #-8]!
    c994:	f7ff ffc4 	bl	c920 <__aeabi_cdrcmple>
    c998:	bf34      	ite	cc
    c99a:	2001      	movcc	r0, #1
    c99c:	2000      	movcs	r0, #0
    c99e:	f85d fb08 	ldr.w	pc, [sp], #8
    c9a2:	bf00      	nop

0000c9a4 <__aeabi_d2uiz>:
    c9a4:	004a      	lsls	r2, r1, #1
    c9a6:	d211      	bcs.n	c9cc <__aeabi_d2uiz+0x28>
    c9a8:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
    c9ac:	d211      	bcs.n	c9d2 <__aeabi_d2uiz+0x2e>
    c9ae:	d50d      	bpl.n	c9cc <__aeabi_d2uiz+0x28>
    c9b0:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
    c9b4:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
    c9b8:	d40e      	bmi.n	c9d8 <__aeabi_d2uiz+0x34>
    c9ba:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    c9be:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    c9c2:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
    c9c6:	fa23 f002 	lsr.w	r0, r3, r2
    c9ca:	4770      	bx	lr
    c9cc:	f04f 0000 	mov.w	r0, #0
    c9d0:	4770      	bx	lr
    c9d2:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
    c9d6:	d102      	bne.n	c9de <__aeabi_d2uiz+0x3a>
    c9d8:	f04f 30ff 	mov.w	r0, #4294967295
    c9dc:	4770      	bx	lr
    c9de:	f04f 0000 	mov.w	r0, #0
    c9e2:	4770      	bx	lr

0000c9e4 <__aeabi_d2f>:
    c9e4:	ea4f 0241 	mov.w	r2, r1, lsl #1
    c9e8:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
    c9ec:	bf24      	itt	cs
    c9ee:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
    c9f2:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
    c9f6:	d90d      	bls.n	ca14 <__aeabi_d2f+0x30>
    c9f8:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    c9fc:	ea4f 02c0 	mov.w	r2, r0, lsl #3
    ca00:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
    ca04:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
    ca08:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
    ca0c:	bf08      	it	eq
    ca0e:	f020 0001 	biceq.w	r0, r0, #1
    ca12:	4770      	bx	lr
    ca14:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
    ca18:	d121      	bne.n	ca5e <__aeabi_d2f+0x7a>
    ca1a:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
    ca1e:	bfbc      	itt	lt
    ca20:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
    ca24:	4770      	bxlt	lr
    ca26:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    ca2a:	ea4f 5252 	mov.w	r2, r2, lsr #21
    ca2e:	f1c2 0218 	rsb	r2, r2, #24
    ca32:	f1c2 0c20 	rsb	ip, r2, #32
    ca36:	fa10 f30c 	lsls.w	r3, r0, ip
    ca3a:	fa20 f002 	lsr.w	r0, r0, r2
    ca3e:	bf18      	it	ne
    ca40:	f040 0001 	orrne.w	r0, r0, #1
    ca44:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    ca48:	ea4f 23d3 	mov.w	r3, r3, lsr #11
    ca4c:	fa03 fc0c 	lsl.w	ip, r3, ip
    ca50:	ea40 000c 	orr.w	r0, r0, ip
    ca54:	fa23 f302 	lsr.w	r3, r3, r2
    ca58:	ea4f 0343 	mov.w	r3, r3, lsl #1
    ca5c:	e7cc      	b.n	c9f8 <__aeabi_d2f+0x14>
    ca5e:	ea7f 5362 	mvns.w	r3, r2, asr #21
    ca62:	d107      	bne.n	ca74 <__aeabi_d2f+0x90>
    ca64:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
    ca68:	bf1e      	ittt	ne
    ca6a:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
    ca6e:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
    ca72:	4770      	bxne	lr
    ca74:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
    ca78:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    ca7c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    ca80:	4770      	bx	lr
    ca82:	bf00      	nop

0000ca84 <am_devices_led_array_init>:
void
am_devices_led_array_init(am_devices_led_t *psLEDs, uint32_t ui32NumLEDs)
{
    uint32_t i;

    if ( (psLEDs == NULL)                       ||
    ca84:	2800      	cmp	r0, #0
    ca86:	f000 810a 	beq.w	cc9e <am_devices_led_array_init+0x21a>
    }

    //
    // Loop through the list of LEDs, configuring each one individually.
    //
    for ( i = 0; i < ui32NumLEDs; i++ )
    ca8a:	1e4b      	subs	r3, r1, #1
    ca8c:	2b1e      	cmp	r3, #30
    ca8e:	f200 8106 	bhi.w	cc9e <am_devices_led_array_init+0x21a>
{
    ca92:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    ca96:	4605      	mov	r5, r0
    ca98:	eb00 06c1 	add.w	r6, r0, r1, lsl #3
    ca9c:	eba6 0900 	sub.w	r9, r6, r0
    caa0:	4604      	mov	r4, r0
         (psLED->ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    caa2:	f855 0b04 	ldr.w	r0, [r5], #4
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_TRISTATE);
    caa6:	4f7f      	ldr	r7, [pc, #508]	; (cca4 <am_devices_led_array_init+0x220>)
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_OUTPUT);
    caa8:	f8df 81fc 	ldr.w	r8, [pc, #508]	; cca8 <am_devices_led_array_init+0x224>
    caac:	f1a9 0208 	sub.w	r2, r9, #8
    if ( (psLED == NULL)    ||
    cab0:	2831      	cmp	r0, #49	; 0x31
    cab2:	f3c2 0ac1 	ubfx	sl, r2, #3, #2
    cab6:	d813      	bhi.n	cae0 <am_devices_led_array_init+0x5c>
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLED->ui32Polarity )
    cab8:	6863      	ldr	r3, [r4, #4]
    caba:	079b      	lsls	r3, r3, #30
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_TRISTATE);
    cabc:	bf54      	ite	pl
    cabe:	6839      	ldrpl	r1, [r7, #0]
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_OUTPUT);
    cac0:	f8d8 1000 	ldrmi.w	r1, [r8]
    cac4:	f004 fd10 	bl	114e8 <am_hal_gpio_pinconfig>
        am_hal_gpio_state_write(psLED->ui32GPIONumber, AM_HAL_GPIO_OUTPUT_TRISTATE_DISABLE);
    cac8:	2103      	movs	r1, #3
    caca:	f855 0c04 	ldr.w	r0, [r5, #-4]
    cace:	f004 fe4d 	bl	1176c <am_hal_gpio_state_write>
        am_hal_gpio_state_write(psLED->ui32GPIONumber,
    cad2:	6861      	ldr	r1, [r4, #4]
    cad4:	f855 0c04 	ldr.w	r0, [r5, #-4]
    cad8:	f001 0101 	and.w	r1, r1, #1
    cadc:	f004 fe46 	bl	1176c <am_hal_gpio_state_write>
    cae0:	3408      	adds	r4, #8
    for ( i = 0; i < ui32NumLEDs; i++ )
    cae2:	42b4      	cmp	r4, r6
    cae4:	f105 0508 	add.w	r5, r5, #8
    cae8:	f000 80d7 	beq.w	cc9a <am_devices_led_array_init+0x216>
    caec:	f1ba 0f00 	cmp.w	sl, #0
    caf0:	d059      	beq.n	cba6 <am_devices_led_array_init+0x122>
    caf2:	f1ba 0f01 	cmp.w	sl, #1
    caf6:	d038      	beq.n	cb6a <am_devices_led_array_init+0xe6>
    caf8:	f1ba 0f02 	cmp.w	sl, #2
    cafc:	d01a      	beq.n	cb34 <am_devices_led_array_init+0xb0>
    if ( (psLED == NULL)    ||
    cafe:	b1bc      	cbz	r4, cb30 <am_devices_led_array_init+0xac>
         (psLED->ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    cb00:	f855 0c04 	ldr.w	r0, [r5, #-4]
    if ( (psLED == NULL)    ||
    cb04:	2831      	cmp	r0, #49	; 0x31
    cb06:	d813      	bhi.n	cb30 <am_devices_led_array_init+0xac>
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLED->ui32Polarity )
    cb08:	6862      	ldr	r2, [r4, #4]
    cb0a:	0791      	lsls	r1, r2, #30
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_TRISTATE);
    cb0c:	bf54      	ite	pl
    cb0e:	6839      	ldrpl	r1, [r7, #0]
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_OUTPUT);
    cb10:	f8d8 1000 	ldrmi.w	r1, [r8]
    cb14:	f004 fce8 	bl	114e8 <am_hal_gpio_pinconfig>
        am_hal_gpio_state_write(psLED->ui32GPIONumber, AM_HAL_GPIO_OUTPUT_TRISTATE_DISABLE);
    cb18:	2103      	movs	r1, #3
    cb1a:	f855 0c04 	ldr.w	r0, [r5, #-4]
    cb1e:	f004 fe25 	bl	1176c <am_hal_gpio_state_write>
        am_hal_gpio_state_write(psLED->ui32GPIONumber,
    cb22:	6863      	ldr	r3, [r4, #4]
    cb24:	f855 0c04 	ldr.w	r0, [r5, #-4]
    cb28:	f003 0101 	and.w	r1, r3, #1
    cb2c:	f004 fe1e 	bl	1176c <am_hal_gpio_state_write>
    cb30:	3408      	adds	r4, #8
    cb32:	3508      	adds	r5, #8
    if ( (psLED == NULL)    ||
    cb34:	b1bc      	cbz	r4, cb66 <am_devices_led_array_init+0xe2>
         (psLED->ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    cb36:	f855 0c04 	ldr.w	r0, [r5, #-4]
    if ( (psLED == NULL)    ||
    cb3a:	2831      	cmp	r0, #49	; 0x31
    cb3c:	d813      	bhi.n	cb66 <am_devices_led_array_init+0xe2>
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLED->ui32Polarity )
    cb3e:	6862      	ldr	r2, [r4, #4]
    cb40:	0792      	lsls	r2, r2, #30
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_TRISTATE);
    cb42:	bf54      	ite	pl
    cb44:	6839      	ldrpl	r1, [r7, #0]
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_OUTPUT);
    cb46:	f8d8 1000 	ldrmi.w	r1, [r8]
    cb4a:	f004 fccd 	bl	114e8 <am_hal_gpio_pinconfig>
        am_hal_gpio_state_write(psLED->ui32GPIONumber, AM_HAL_GPIO_OUTPUT_TRISTATE_DISABLE);
    cb4e:	2103      	movs	r1, #3
    cb50:	f855 0c04 	ldr.w	r0, [r5, #-4]
    cb54:	f004 fe0a 	bl	1176c <am_hal_gpio_state_write>
        am_hal_gpio_state_write(psLED->ui32GPIONumber,
    cb58:	6861      	ldr	r1, [r4, #4]
    cb5a:	f855 0c04 	ldr.w	r0, [r5, #-4]
    cb5e:	f001 0101 	and.w	r1, r1, #1
    cb62:	f004 fe03 	bl	1176c <am_hal_gpio_state_write>
    cb66:	3408      	adds	r4, #8
    cb68:	3508      	adds	r5, #8
    if ( (psLED == NULL)    ||
    cb6a:	b1bc      	cbz	r4, cb9c <am_devices_led_array_init+0x118>
         (psLED->ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    cb6c:	f855 0c04 	ldr.w	r0, [r5, #-4]
    if ( (psLED == NULL)    ||
    cb70:	2831      	cmp	r0, #49	; 0x31
    cb72:	d813      	bhi.n	cb9c <am_devices_led_array_init+0x118>
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLED->ui32Polarity )
    cb74:	6863      	ldr	r3, [r4, #4]
    cb76:	079b      	lsls	r3, r3, #30
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_TRISTATE);
    cb78:	bf54      	ite	pl
    cb7a:	6839      	ldrpl	r1, [r7, #0]
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_OUTPUT);
    cb7c:	f8d8 1000 	ldrmi.w	r1, [r8]
    cb80:	f004 fcb2 	bl	114e8 <am_hal_gpio_pinconfig>
        am_hal_gpio_state_write(psLED->ui32GPIONumber, AM_HAL_GPIO_OUTPUT_TRISTATE_DISABLE);
    cb84:	2103      	movs	r1, #3
    cb86:	f855 0c04 	ldr.w	r0, [r5, #-4]
    cb8a:	f004 fdef 	bl	1176c <am_hal_gpio_state_write>
        am_hal_gpio_state_write(psLED->ui32GPIONumber,
    cb8e:	6862      	ldr	r2, [r4, #4]
    cb90:	f855 0c04 	ldr.w	r0, [r5, #-4]
    cb94:	f002 0101 	and.w	r1, r2, #1
    cb98:	f004 fde8 	bl	1176c <am_hal_gpio_state_write>
    cb9c:	3408      	adds	r4, #8
    for ( i = 0; i < ui32NumLEDs; i++ )
    cb9e:	42b4      	cmp	r4, r6
    cba0:	f105 0508 	add.w	r5, r5, #8
    cba4:	d07c      	beq.n	cca0 <am_devices_led_array_init+0x21c>
    if ( (psLED == NULL)    ||
    cba6:	b1bc      	cbz	r4, cbd8 <am_devices_led_array_init+0x154>
         (psLED->ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    cba8:	f855 0c04 	ldr.w	r0, [r5, #-4]
    if ( (psLED == NULL)    ||
    cbac:	2831      	cmp	r0, #49	; 0x31
    cbae:	d813      	bhi.n	cbd8 <am_devices_led_array_init+0x154>
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLED->ui32Polarity )
    cbb0:	6863      	ldr	r3, [r4, #4]
    cbb2:	079a      	lsls	r2, r3, #30
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_OUTPUT);
    cbb4:	bf4c      	ite	mi
    cbb6:	f8d8 1000 	ldrmi.w	r1, [r8]
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_TRISTATE);
    cbba:	6839      	ldrpl	r1, [r7, #0]
    cbbc:	f004 fc94 	bl	114e8 <am_hal_gpio_pinconfig>
        am_hal_gpio_state_write(psLED->ui32GPIONumber, AM_HAL_GPIO_OUTPUT_TRISTATE_DISABLE);
    cbc0:	2103      	movs	r1, #3
    cbc2:	f855 0c04 	ldr.w	r0, [r5, #-4]
    cbc6:	f004 fdd1 	bl	1176c <am_hal_gpio_state_write>
        am_hal_gpio_state_write(psLED->ui32GPIONumber,
    cbca:	6861      	ldr	r1, [r4, #4]
    cbcc:	f855 0c04 	ldr.w	r0, [r5, #-4]
    cbd0:	f001 0101 	and.w	r1, r1, #1
    cbd4:	f004 fdca 	bl	1176c <am_hal_gpio_state_write>
    if ( (psLED == NULL)    ||
    cbd8:	3408      	adds	r4, #8
    cbda:	f105 0508 	add.w	r5, r5, #8
    cbde:	d017      	beq.n	cc10 <am_devices_led_array_init+0x18c>
         (psLED->ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    cbe0:	f855 0c04 	ldr.w	r0, [r5, #-4]
    if ( (psLED == NULL)    ||
    cbe4:	2831      	cmp	r0, #49	; 0x31
    cbe6:	d813      	bhi.n	cc10 <am_devices_led_array_init+0x18c>
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLED->ui32Polarity )
    cbe8:	6862      	ldr	r2, [r4, #4]
    cbea:	0791      	lsls	r1, r2, #30
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_TRISTATE);
    cbec:	bf54      	ite	pl
    cbee:	6839      	ldrpl	r1, [r7, #0]
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_OUTPUT);
    cbf0:	f8d8 1000 	ldrmi.w	r1, [r8]
    cbf4:	f004 fc78 	bl	114e8 <am_hal_gpio_pinconfig>
        am_hal_gpio_state_write(psLED->ui32GPIONumber, AM_HAL_GPIO_OUTPUT_TRISTATE_DISABLE);
    cbf8:	2103      	movs	r1, #3
    cbfa:	f855 0c04 	ldr.w	r0, [r5, #-4]
    cbfe:	f004 fdb5 	bl	1176c <am_hal_gpio_state_write>
        am_hal_gpio_state_write(psLED->ui32GPIONumber,
    cc02:	6863      	ldr	r3, [r4, #4]
    cc04:	f855 0c04 	ldr.w	r0, [r5, #-4]
    cc08:	f003 0101 	and.w	r1, r3, #1
    cc0c:	f004 fdae 	bl	1176c <am_hal_gpio_state_write>
    if ( (psLED == NULL)    ||
    cc10:	f114 0908 	adds.w	r9, r4, #8
    cc14:	f105 0a08 	add.w	sl, r5, #8
    cc18:	d019      	beq.n	cc4e <am_devices_led_array_init+0x1ca>
         (psLED->ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    cc1a:	f85a 0c04 	ldr.w	r0, [sl, #-4]
    if ( (psLED == NULL)    ||
    cc1e:	2831      	cmp	r0, #49	; 0x31
    cc20:	d815      	bhi.n	cc4e <am_devices_led_array_init+0x1ca>
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLED->ui32Polarity )
    cc22:	f8d9 2004 	ldr.w	r2, [r9, #4]
    cc26:	0792      	lsls	r2, r2, #30
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_TRISTATE);
    cc28:	bf54      	ite	pl
    cc2a:	6839      	ldrpl	r1, [r7, #0]
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_OUTPUT);
    cc2c:	f8d8 1000 	ldrmi.w	r1, [r8]
    cc30:	f004 fc5a 	bl	114e8 <am_hal_gpio_pinconfig>
        am_hal_gpio_state_write(psLED->ui32GPIONumber, AM_HAL_GPIO_OUTPUT_TRISTATE_DISABLE);
    cc34:	2103      	movs	r1, #3
    cc36:	f85a 0c04 	ldr.w	r0, [sl, #-4]
    cc3a:	f004 fd97 	bl	1176c <am_hal_gpio_state_write>
        am_hal_gpio_state_write(psLED->ui32GPIONumber,
    cc3e:	f8d9 1004 	ldr.w	r1, [r9, #4]
    cc42:	f85a 0c04 	ldr.w	r0, [sl, #-4]
    cc46:	f001 0101 	and.w	r1, r1, #1
    cc4a:	f004 fd8f 	bl	1176c <am_hal_gpio_state_write>
    if ( (psLED == NULL)    ||
    cc4e:	f114 0910 	adds.w	r9, r4, #16
    cc52:	f105 0a10 	add.w	sl, r5, #16
    cc56:	d019      	beq.n	cc8c <am_devices_led_array_init+0x208>
         (psLED->ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    cc58:	f85a 0c04 	ldr.w	r0, [sl, #-4]
    if ( (psLED == NULL)    ||
    cc5c:	2831      	cmp	r0, #49	; 0x31
    cc5e:	d815      	bhi.n	cc8c <am_devices_led_array_init+0x208>
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLED->ui32Polarity )
    cc60:	f8d9 3004 	ldr.w	r3, [r9, #4]
    cc64:	079b      	lsls	r3, r3, #30
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_TRISTATE);
    cc66:	bf54      	ite	pl
    cc68:	6839      	ldrpl	r1, [r7, #0]
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_OUTPUT);
    cc6a:	f8d8 1000 	ldrmi.w	r1, [r8]
    cc6e:	f004 fc3b 	bl	114e8 <am_hal_gpio_pinconfig>
        am_hal_gpio_state_write(psLED->ui32GPIONumber, AM_HAL_GPIO_OUTPUT_TRISTATE_DISABLE);
    cc72:	2103      	movs	r1, #3
    cc74:	f85a 0c04 	ldr.w	r0, [sl, #-4]
    cc78:	f004 fd78 	bl	1176c <am_hal_gpio_state_write>
        am_hal_gpio_state_write(psLED->ui32GPIONumber,
    cc7c:	f8d9 2004 	ldr.w	r2, [r9, #4]
    cc80:	f85a 0c04 	ldr.w	r0, [sl, #-4]
    cc84:	f002 0101 	and.w	r1, r2, #1
    cc88:	f004 fd70 	bl	1176c <am_hal_gpio_state_write>
    cc8c:	3418      	adds	r4, #24
    for ( i = 0; i < ui32NumLEDs; i++ )
    cc8e:	42b4      	cmp	r4, r6
    cc90:	f105 0518 	add.w	r5, r5, #24
    cc94:	d187      	bne.n	cba6 <am_devices_led_array_init+0x122>
    cc96:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    cc9a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    cc9e:	4770      	bx	lr
    cca0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    cca4:	000132f0 	.word	0x000132f0
    cca8:	000132ec 	.word	0x000132ec

0000ccac <am_devices_led_on>:
//
//*****************************************************************************
void
am_devices_led_on(am_devices_led_t *psLEDs, uint32_t ui32LEDNum)
{
    if ( (psLEDs == NULL)                       ||
    ccac:	b170      	cbz	r0, cccc <am_devices_led_on+0x20>
    ccae:	291e      	cmp	r1, #30
    ccb0:	d80c      	bhi.n	cccc <am_devices_led_on+0x20>
         (ui32LEDNum >= MAX_LEDS)               ||
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    ccb2:	f850 3031 	ldr.w	r3, [r0, r1, lsl #3]
         (ui32LEDNum >= MAX_LEDS)               ||
    ccb6:	2b31      	cmp	r3, #49	; 0x31
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    ccb8:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
         (ui32LEDNum >= MAX_LEDS)               ||
    ccbc:	d806      	bhi.n	cccc <am_devices_led_on+0x20>

#if AM_APOLLO3_GPIO
    //
    // Handle Direct Drive Versus 3-State (with pull-up or no buffer).
    //
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    ccbe:	6848      	ldr	r0, [r1, #4]
    ccc0:	0782      	lsls	r2, r0, #30
    ccc2:	d404      	bmi.n	ccce <am_devices_led_on+0x22>
    else
    {
        //
        // Turn on the output driver for the LED.
        //
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    ccc4:	4618      	mov	r0, r3
    ccc6:	2104      	movs	r1, #4
    ccc8:	f004 bd50 	b.w	1176c <am_hal_gpio_state_write>
    cccc:	4770      	bx	lr
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    ccce:	f000 0101 	and.w	r1, r0, #1
    ccd2:	4618      	mov	r0, r3
    ccd4:	f004 bd4a 	b.w	1176c <am_hal_gpio_state_write>

0000ccd8 <SysTick_Handler>:
{
    //
    // Add enough cycles to account for one full cycle of systick.
    //
#ifdef TIME_64
    g_ui32SysTickWrappedTime++;
    ccd8:	4a02      	ldr	r2, [pc, #8]	; (cce4 <SysTick_Handler+0xc>)
    ccda:	6813      	ldr	r3, [r2, #0]
    ccdc:	3301      	adds	r3, #1
    ccde:	6013      	str	r3, [r2, #0]
    cce0:	4770      	bx	lr
    cce2:	bf00      	nop
    cce4:	10001040 	.word	0x10001040

0000cce8 <core_list_mergesort.constprop.2>:
    Note:
    We have a special header for the list that will always be first,
    but the algorithm could theoretically modify where the list starts.

 */
list_head *core_list_mergesort(list_head *list, list_cmp cmp, core_results *res) {
    cce8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    list_head *p, *q, *e, *tail;
    ee_s32 insize, nmerges, psize, qsize, i;

    insize = 1;
    ccec:	f04f 0c01 	mov.w	ip, #1
        list = NULL;
        tail = NULL;

        nmerges = 0;  /* count number of merges we do in this pass */

        while (p) {
    ccf0:	f04f 0900 	mov.w	r9, #0
    ccf4:	2800      	cmp	r0, #0
    ccf6:	f000 8099 	beq.w	ce2c <core_list_mergesort.constprop.2+0x144>
    ccfa:	f04f 0e00 	mov.w	lr, #0
    ccfe:	4671      	mov	r1, lr
    cd00:	46f0      	mov	r8, lr
            /* step `insize' places along from p */
            q = p;
            psize = 0;
            for (i = 0; i < insize; i++) {
                psize++;
                q = q->next;
    cd02:	6803      	ldr	r3, [r0, #0]
    cd04:	f10c 32ff 	add.w	r2, ip, #4294967295
            nmerges++;  /* there exists a merge to be done */
    cd08:	f108 0801 	add.w	r8, r8, #1
    cd0c:	f002 0507 	and.w	r5, r2, #7
                psize++;
    cd10:	2401      	movs	r4, #1
                if (!q) break;
    cd12:	2b00      	cmp	r3, #0
    cd14:	d03f      	beq.n	cd96 <core_list_mergesort.constprop.2+0xae>
            for (i = 0; i < insize; i++) {
    cd16:	4564      	cmp	r4, ip
    cd18:	d03d      	beq.n	cd96 <core_list_mergesort.constprop.2+0xae>
    cd1a:	b315      	cbz	r5, cd62 <core_list_mergesort.constprop.2+0x7a>
    cd1c:	2d01      	cmp	r5, #1
    cd1e:	d01b      	beq.n	cd58 <core_list_mergesort.constprop.2+0x70>
    cd20:	2d02      	cmp	r5, #2
    cd22:	d016      	beq.n	cd52 <core_list_mergesort.constprop.2+0x6a>
    cd24:	2d03      	cmp	r5, #3
    cd26:	d011      	beq.n	cd4c <core_list_mergesort.constprop.2+0x64>
    cd28:	2d04      	cmp	r5, #4
    cd2a:	d00c      	beq.n	cd46 <core_list_mergesort.constprop.2+0x5e>
    cd2c:	2d05      	cmp	r5, #5
    cd2e:	d007      	beq.n	cd40 <core_list_mergesort.constprop.2+0x58>
    cd30:	2d06      	cmp	r5, #6
    cd32:	d002      	beq.n	cd3a <core_list_mergesort.constprop.2+0x52>
                q = q->next;
    cd34:	681b      	ldr	r3, [r3, #0]
                psize++;
    cd36:	2402      	movs	r4, #2
                if (!q) break;
    cd38:	b36b      	cbz	r3, cd96 <core_list_mergesort.constprop.2+0xae>
                q = q->next;
    cd3a:	681b      	ldr	r3, [r3, #0]
                psize++;
    cd3c:	3401      	adds	r4, #1
                if (!q) break;
    cd3e:	b353      	cbz	r3, cd96 <core_list_mergesort.constprop.2+0xae>
                q = q->next;
    cd40:	681b      	ldr	r3, [r3, #0]
                psize++;
    cd42:	3401      	adds	r4, #1
                if (!q) break;
    cd44:	b33b      	cbz	r3, cd96 <core_list_mergesort.constprop.2+0xae>
                q = q->next;
    cd46:	681b      	ldr	r3, [r3, #0]
                psize++;
    cd48:	3401      	adds	r4, #1
                if (!q) break;
    cd4a:	b323      	cbz	r3, cd96 <core_list_mergesort.constprop.2+0xae>
                q = q->next;
    cd4c:	681b      	ldr	r3, [r3, #0]
                psize++;
    cd4e:	3401      	adds	r4, #1
                if (!q) break;
    cd50:	b30b      	cbz	r3, cd96 <core_list_mergesort.constprop.2+0xae>
                q = q->next;
    cd52:	681b      	ldr	r3, [r3, #0]
                psize++;
    cd54:	3401      	adds	r4, #1
                if (!q) break;
    cd56:	b1f3      	cbz	r3, cd96 <core_list_mergesort.constprop.2+0xae>
                q = q->next;
    cd58:	681b      	ldr	r3, [r3, #0]
                psize++;
    cd5a:	3401      	adds	r4, #1
                if (!q) break;
    cd5c:	b1db      	cbz	r3, cd96 <core_list_mergesort.constprop.2+0xae>
            for (i = 0; i < insize; i++) {
    cd5e:	4564      	cmp	r4, ip
    cd60:	d019      	beq.n	cd96 <core_list_mergesort.constprop.2+0xae>
                q = q->next;
    cd62:	681b      	ldr	r3, [r3, #0]
                psize++;
    cd64:	3401      	adds	r4, #1
    cd66:	4626      	mov	r6, r4
                if (!q) break;
    cd68:	b1ab      	cbz	r3, cd96 <core_list_mergesort.constprop.2+0xae>
                q = q->next;
    cd6a:	681b      	ldr	r3, [r3, #0]
                psize++;
    cd6c:	3401      	adds	r4, #1
                if (!q) break;
    cd6e:	b193      	cbz	r3, cd96 <core_list_mergesort.constprop.2+0xae>
                q = q->next;
    cd70:	681b      	ldr	r3, [r3, #0]
                psize++;
    cd72:	1cb4      	adds	r4, r6, #2
                if (!q) break;
    cd74:	b17b      	cbz	r3, cd96 <core_list_mergesort.constprop.2+0xae>
                q = q->next;
    cd76:	681b      	ldr	r3, [r3, #0]
                psize++;
    cd78:	1cf4      	adds	r4, r6, #3
                if (!q) break;
    cd7a:	b163      	cbz	r3, cd96 <core_list_mergesort.constprop.2+0xae>
                q = q->next;
    cd7c:	681b      	ldr	r3, [r3, #0]
                psize++;
    cd7e:	1d34      	adds	r4, r6, #4
                if (!q) break;
    cd80:	b14b      	cbz	r3, cd96 <core_list_mergesort.constprop.2+0xae>
                q = q->next;
    cd82:	681b      	ldr	r3, [r3, #0]
                psize++;
    cd84:	1d74      	adds	r4, r6, #5
                if (!q) break;
    cd86:	b133      	cbz	r3, cd96 <core_list_mergesort.constprop.2+0xae>
                q = q->next;
    cd88:	681b      	ldr	r3, [r3, #0]
                psize++;
    cd8a:	1db4      	adds	r4, r6, #6
                if (!q) break;
    cd8c:	b11b      	cbz	r3, cd96 <core_list_mergesort.constprop.2+0xae>
                q = q->next;
    cd8e:	681b      	ldr	r3, [r3, #0]
                psize++;
    cd90:	1df4      	adds	r4, r6, #7
                if (!q) break;
    cd92:	2b00      	cmp	r3, #0
    cd94:	d1e3      	bne.n	cd5e <core_list_mergesort.constprop.2+0x76>

                /* add the next element to the merged list */
                if (tail) {
                    tail->next = e;
                } else {
                    list = e;
    cd96:	4665      	mov	r5, ip
            while (psize > 0 || (qsize > 0 && q)) {
    cd98:	b344      	cbz	r4, cdec <core_list_mergesort.constprop.2+0x104>
                } else if (qsize == 0 || !q) {
    cd9a:	b38d      	cbz	r5, ce00 <core_list_mergesort.constprop.2+0x118>
    cd9c:	b383      	cbz	r3, ce00 <core_list_mergesort.constprop.2+0x118>
                } else if (cmp(p->info,q->info,res) <= 0) {
    cd9e:	f8d0 a004 	ldr.w	sl, [r0, #4]
    cda2:	685f      	ldr	r7, [r3, #4]
        a->data16 = (a->data16 & 0xff00) | (0x00ff & (a->data16>>8));
    cda4:	f9ba 2000 	ldrsh.w	r2, [sl]
    return a->idx - b->idx;
    cda8:	f9ba 6002 	ldrsh.w	r6, [sl, #2]
        a->data16 = (a->data16 & 0xff00) | (0x00ff & (a->data16>>8));
    cdac:	f022 0bff 	bic.w	fp, r2, #255	; 0xff
    cdb0:	f3c2 2207 	ubfx	r2, r2, #8, #8
    cdb4:	ea4b 0b02 	orr.w	fp, fp, r2
    cdb8:	f8aa b000 	strh.w	fp, [sl]
        b->data16 = (b->data16 & 0xff00) | (0x00ff & (b->data16>>8));
    cdbc:	f9b7 2000 	ldrsh.w	r2, [r7]
    return a->idx - b->idx;
    cdc0:	f9b7 b002 	ldrsh.w	fp, [r7, #2]
        b->data16 = (b->data16 & 0xff00) | (0x00ff & (b->data16>>8));
    cdc4:	f022 0aff 	bic.w	sl, r2, #255	; 0xff
    return a->idx - b->idx;
    cdc8:	eba6 060b 	sub.w	r6, r6, fp
        b->data16 = (b->data16 & 0xff00) | (0x00ff & (b->data16>>8));
    cdcc:	f3c2 2207 	ubfx	r2, r2, #8, #8
    cdd0:	ea4a 0b02 	orr.w	fp, sl, r2
                } else if (cmp(p->info,q->info,res) <= 0) {
    cdd4:	2e00      	cmp	r6, #0
        b->data16 = (b->data16 & 0xff00) | (0x00ff & (b->data16>>8));
    cdd6:	f8a7 b000 	strh.w	fp, [r7]
                } else if (cmp(p->info,q->info,res) <= 0) {
    cdda:	dd11      	ble.n	ce00 <core_list_mergesort.constprop.2+0x118>
                    e = q; q = q->next; qsize--;
    cddc:	461f      	mov	r7, r3
    cdde:	681b      	ldr	r3, [r3, #0]
    cde0:	3d01      	subs	r5, #1
                if (tail) {
    cde2:	b151      	cbz	r1, cdfa <core_list_mergesort.constprop.2+0x112>
                    tail->next = e;
    cde4:	600f      	str	r7, [r1, #0]
                    list = e;
    cde6:	4639      	mov	r1, r7
            while (psize > 0 || (qsize > 0 && q)) {
    cde8:	2c00      	cmp	r4, #0
    cdea:	d1d6      	bne.n	cd9a <core_list_mergesort.constprop.2+0xb2>
    cdec:	b165      	cbz	r5, ce08 <core_list_mergesort.constprop.2+0x120>
    cdee:	b17b      	cbz	r3, ce10 <core_list_mergesort.constprop.2+0x128>
                    e = q; q = q->next; qsize--;
    cdf0:	461f      	mov	r7, r3
    cdf2:	3d01      	subs	r5, #1
    cdf4:	681b      	ldr	r3, [r3, #0]
                if (tail) {
    cdf6:	2900      	cmp	r1, #0
    cdf8:	d1f4      	bne.n	cde4 <core_list_mergesort.constprop.2+0xfc>
                    list = e;
    cdfa:	46be      	mov	lr, r7
    cdfc:	4639      	mov	r1, r7
    cdfe:	e7f3      	b.n	cde8 <core_list_mergesort.constprop.2+0x100>
                    e = p; p = p->next; psize--;
    ce00:	4607      	mov	r7, r0
    ce02:	3c01      	subs	r4, #1
    ce04:	6800      	ldr	r0, [r0, #0]
    ce06:	e7ec      	b.n	cde2 <core_list_mergesort.constprop.2+0xfa>
        while (p) {
    ce08:	4618      	mov	r0, r3
    ce0a:	2b00      	cmp	r3, #0
    ce0c:	f47f af79 	bne.w	cd02 <core_list_mergesort.constprop.2+0x1a>
        }

        tail->next = NULL;

        /* If we have done only one merge, we're finished. */
        if (nmerges <= 1)   /* allow for nmerges==0, the empty list case */
    ce10:	f1b8 0f01 	cmp.w	r8, #1
        tail->next = NULL;
    ce14:	f8c1 9000 	str.w	r9, [r1]
        if (nmerges <= 1)   /* allow for nmerges==0, the empty list case */
    ce18:	d102      	bne.n	ce20 <core_list_mergesort.constprop.2+0x138>
        insize *= 2;
    }
#if COMPILER_REQUIRES_SORT_RETURN
    return list;
#endif
}
    ce1a:	4670      	mov	r0, lr
    ce1c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        insize *= 2;
    ce20:	4670      	mov	r0, lr
    ce22:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
        while (p) {
    ce26:	2800      	cmp	r0, #0
    ce28:	f47f af67 	bne.w	ccfa <core_list_mergesort.constprop.2+0x12>
        tail->next = NULL;
    ce2c:	6000      	str	r0, [r0, #0]
    ce2e:	deff      	udf	#255	; 0xff

0000ce30 <core_bench_list>:
ee_u16 core_bench_list(core_results *res, ee_s16 finder_idx) {
    ce30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ee_s16 find_num=res->seed3;
    ce34:	f9b0 5004 	ldrsh.w	r5, [r0, #4]
    list_head *list=res->list;
    ce38:	f8d0 b024 	ldr.w	fp, [r0, #36]	; 0x24
ee_u16 core_bench_list(core_results *res, ee_s16 finder_idx) {
    ce3c:	b08d      	sub	sp, #52	; 0x34
    for (i=0; i<find_num; i++) {
    ce3e:	2d00      	cmp	r5, #0
ee_u16 core_bench_list(core_results *res, ee_s16 finder_idx) {
    ce40:	9003      	str	r0, [sp, #12]
    ce42:	468c      	mov	ip, r1
    for (i=0; i<find_num; i++) {
    ce44:	f340 8215 	ble.w	d272 <core_bench_list+0x442>
    ce48:	2000      	movs	r0, #0
    ce4a:	4604      	mov	r4, r0
    ce4c:	4602      	mov	r2, r0
        while (list && (list->info->idx != info->idx))
    ce4e:	4686      	mov	lr, r0
    for (i=0; i<find_num; i++) {
    ce50:	460f      	mov	r7, r1
    ce52:	4681      	mov	r9, r0
    ce54:	46aa      	mov	sl, r5
    ce56:	465b      	mov	r3, fp
    ce58:	4688      	mov	r8, r1
    if (info->idx>=0) {
    ce5a:	2f00      	cmp	r7, #0
        info.data16= (i & 0xff) ;
    ce5c:	fa5f fc80 	uxtb.w	ip, r0
    if (info->idx>=0) {
    ce60:	f2c0 81d5 	blt.w	d20e <core_bench_list+0x3de>
        while (list && (list->info->idx != info->idx))
    ce64:	2b00      	cmp	r3, #0
    ce66:	f000 81e2 	beq.w	d22e <core_bench_list+0x3fe>
    ce6a:	685d      	ldr	r5, [r3, #4]
    ce6c:	f9b5 b002 	ldrsh.w	fp, [r5, #2]
    ce70:	45bb      	cmp	fp, r7
    ce72:	461d      	mov	r5, r3
    ce74:	d105      	bne.n	ce82 <core_bench_list+0x52>
    ce76:	e007      	b.n	ce88 <core_bench_list+0x58>
    ce78:	6869      	ldr	r1, [r5, #4]
    ce7a:	f9b1 6002 	ldrsh.w	r6, [r1, #2]
    ce7e:	42be      	cmp	r6, r7
    ce80:	d002      	beq.n	ce88 <core_bench_list+0x58>
            list=list->next;
    ce82:	682d      	ldr	r5, [r5, #0]
        while (list && (list->info->idx != info->idx))
    ce84:	2d00      	cmp	r5, #0
    ce86:	d1f7      	bne.n	ce78 <core_bench_list+0x48>
    ce88:	2600      	movs	r6, #0
    ce8a:	e001      	b.n	ce90 <core_bench_list+0x60>
    while (list) {
    ce8c:	461e      	mov	r6, r3
    ce8e:	460b      	mov	r3, r1
        tmp=list->next;
    ce90:	6819      	ldr	r1, [r3, #0]
        list->next=next;
    ce92:	601e      	str	r6, [r3, #0]
    while (list) {
    ce94:	2900      	cmp	r1, #0
    ce96:	d1f9      	bne.n	ce8c <core_bench_list+0x5c>
        if (this_find==NULL) {
    ce98:	2d00      	cmp	r5, #0
    ce9a:	f000 81cb 	beq.w	d234 <core_bench_list+0x404>
            if (this_find->info->data16 & 0x1) /* use found value */
    ce9e:	686e      	ldr	r6, [r5, #4]
    cea0:	f9b6 b000 	ldrsh.w	fp, [r6]
            found++;
    cea4:	3401      	adds	r4, #1
            if (this_find->info->data16 & 0x1) /* use found value */
    cea6:	ea5f 76cb 	movs.w	r6, fp, lsl #31
            found++;
    ceaa:	b2a4      	uxth	r4, r4
            if (this_find->info->data16 & 0x1) /* use found value */
    ceac:	d503      	bpl.n	ceb6 <core_bench_list+0x86>
                retval+=(this_find->info->data16 >> 9) & 1;
    ceae:	f3cb 2140 	ubfx	r1, fp, #9, #1
    ceb2:	440a      	add	r2, r1
    ceb4:	b292      	uxth	r2, r2
            if (this_find->next != NULL) {
    ceb6:	6829      	ldr	r1, [r5, #0]
    ceb8:	b121      	cbz	r1, cec4 <core_bench_list+0x94>
                this_find->next = finder->next;
    ceba:	680e      	ldr	r6, [r1, #0]
    cebc:	602e      	str	r6, [r5, #0]
                finder->next=list->next;
    cebe:	681d      	ldr	r5, [r3, #0]
    cec0:	600d      	str	r5, [r1, #0]
                list->next=finder;
    cec2:	6019      	str	r1, [r3, #0]
        if (info.idx>=0)
    cec4:	2f00      	cmp	r7, #0
    cec6:	f100 0001 	add.w	r0, r0, #1
            info.idx++;
    ceca:	bfa8      	it	ge
    cecc:	3701      	addge	r7, #1
    for (i=0; i<find_num; i++) {
    cece:	b201      	sxth	r1, r0
            info.idx++;
    ced0:	bfa8      	it	ge
    ced2:	b23f      	sxthge	r7, r7
    for (i=0; i<find_num; i++) {
    ced4:	458a      	cmp	sl, r1
    ced6:	dcc0      	bgt.n	ce5a <core_bench_list+0x2a>
    ced8:	ebc9 0084 	rsb	r0, r9, r4, lsl #2
    cedc:	4402      	add	r2, r0
    cede:	970a      	str	r7, [sp, #40]	; 0x28
    cee0:	b297      	uxth	r7, r2
    cee2:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
    cee6:	469b      	mov	fp, r3
    cee8:	46c4      	mov	ip, r8
    ceea:	9709      	str	r7, [sp, #36]	; 0x24
    if (finder_idx>0)
    ceec:	f1bc 0f00 	cmp.w	ip, #0
    cef0:	f340 8146 	ble.w	d180 <core_bench_list+0x350>
                retval=core_bench_matrix(&(res->mat),dtype,res->crc);
    cef4:	9c03      	ldr	r4, [sp, #12]
    cef6:	f8cd b014 	str.w	fp, [sp, #20]
    cefa:	2301      	movs	r3, #1
    cefc:	4622      	mov	r2, r4
    cefe:	9306      	str	r3, [sp, #24]
    cf00:	3228      	adds	r2, #40	; 0x28
    cf02:	9b05      	ldr	r3, [sp, #20]
    cf04:	9207      	str	r2, [sp, #28]
    if (finder_idx>0)
    cf06:	46da      	mov	sl, fp
                retval=core_bench_matrix(&(res->mat),dtype,res->crc);
    cf08:	46a3      	mov	fp, r4
        while (p) {
    cf0a:	2b00      	cmp	r3, #0
    cf0c:	f000 81b5 	beq.w	d27a <core_bench_list+0x44a>
    cf10:	2600      	movs	r6, #0
    cf12:	9605      	str	r6, [sp, #20]
    cf14:	4637      	mov	r7, r6
    cf16:	9608      	str	r6, [sp, #32]
            nmerges++;  /* there exists a merge to be done */
    cf18:	9808      	ldr	r0, [sp, #32]
    cf1a:	9d06      	ldr	r5, [sp, #24]
                q = q->next;
    cf1c:	f8da 4000 	ldr.w	r4, [sl]
    cf20:	1e69      	subs	r1, r5, #1
            nmerges++;  /* there exists a merge to be done */
    cf22:	3001      	adds	r0, #1
    cf24:	9008      	str	r0, [sp, #32]
    cf26:	f001 0307 	and.w	r3, r1, #7
                psize++;
    cf2a:	f04f 0c01 	mov.w	ip, #1
                if (!q) break;
    cf2e:	2c00      	cmp	r4, #0
    cf30:	d053      	beq.n	cfda <core_bench_list+0x1aa>
            for (i = 0; i < insize; i++) {
    cf32:	9a06      	ldr	r2, [sp, #24]
    cf34:	4594      	cmp	ip, r2
    cf36:	d050      	beq.n	cfda <core_bench_list+0x1aa>
    cf38:	b36b      	cbz	r3, cf96 <core_bench_list+0x166>
    cf3a:	2b01      	cmp	r3, #1
    cf3c:	d024      	beq.n	cf88 <core_bench_list+0x158>
    cf3e:	2b02      	cmp	r3, #2
    cf40:	d01e      	beq.n	cf80 <core_bench_list+0x150>
    cf42:	2b03      	cmp	r3, #3
    cf44:	d018      	beq.n	cf78 <core_bench_list+0x148>
    cf46:	2b04      	cmp	r3, #4
    cf48:	d012      	beq.n	cf70 <core_bench_list+0x140>
    cf4a:	2b05      	cmp	r3, #5
    cf4c:	d00b      	beq.n	cf66 <core_bench_list+0x136>
    cf4e:	2b06      	cmp	r3, #6
    cf50:	d004      	beq.n	cf5c <core_bench_list+0x12c>
                q = q->next;
    cf52:	6824      	ldr	r4, [r4, #0]
                psize++;
    cf54:	f04f 0c02 	mov.w	ip, #2
                if (!q) break;
    cf58:	2c00      	cmp	r4, #0
    cf5a:	d03e      	beq.n	cfda <core_bench_list+0x1aa>
                q = q->next;
    cf5c:	6824      	ldr	r4, [r4, #0]
                psize++;
    cf5e:	f10c 0c01 	add.w	ip, ip, #1
                if (!q) break;
    cf62:	2c00      	cmp	r4, #0
    cf64:	d039      	beq.n	cfda <core_bench_list+0x1aa>
                q = q->next;
    cf66:	6824      	ldr	r4, [r4, #0]
                psize++;
    cf68:	f10c 0c01 	add.w	ip, ip, #1
                if (!q) break;
    cf6c:	2c00      	cmp	r4, #0
    cf6e:	d034      	beq.n	cfda <core_bench_list+0x1aa>
                q = q->next;
    cf70:	6824      	ldr	r4, [r4, #0]
                psize++;
    cf72:	f10c 0c01 	add.w	ip, ip, #1
                if (!q) break;
    cf76:	b384      	cbz	r4, cfda <core_bench_list+0x1aa>
                q = q->next;
    cf78:	6824      	ldr	r4, [r4, #0]
                psize++;
    cf7a:	f10c 0c01 	add.w	ip, ip, #1
                if (!q) break;
    cf7e:	b364      	cbz	r4, cfda <core_bench_list+0x1aa>
                q = q->next;
    cf80:	6824      	ldr	r4, [r4, #0]
                psize++;
    cf82:	f10c 0c01 	add.w	ip, ip, #1
                if (!q) break;
    cf86:	b344      	cbz	r4, cfda <core_bench_list+0x1aa>
                q = q->next;
    cf88:	6824      	ldr	r4, [r4, #0]
                psize++;
    cf8a:	f10c 0c01 	add.w	ip, ip, #1
                if (!q) break;
    cf8e:	b324      	cbz	r4, cfda <core_bench_list+0x1aa>
            for (i = 0; i < insize; i++) {
    cf90:	9e06      	ldr	r6, [sp, #24]
    cf92:	45b4      	cmp	ip, r6
    cf94:	d021      	beq.n	cfda <core_bench_list+0x1aa>
                q = q->next;
    cf96:	6824      	ldr	r4, [r4, #0]
                psize++;
    cf98:	f10c 0c01 	add.w	ip, ip, #1
    cf9c:	46e6      	mov	lr, ip
                if (!q) break;
    cf9e:	b1e4      	cbz	r4, cfda <core_bench_list+0x1aa>
                q = q->next;
    cfa0:	6824      	ldr	r4, [r4, #0]
                psize++;
    cfa2:	f10c 0c01 	add.w	ip, ip, #1
                if (!q) break;
    cfa6:	b1c4      	cbz	r4, cfda <core_bench_list+0x1aa>
                q = q->next;
    cfa8:	6824      	ldr	r4, [r4, #0]
                psize++;
    cfaa:	f10e 0c02 	add.w	ip, lr, #2
                if (!q) break;
    cfae:	b1a4      	cbz	r4, cfda <core_bench_list+0x1aa>
                q = q->next;
    cfb0:	6824      	ldr	r4, [r4, #0]
                psize++;
    cfb2:	f10e 0c03 	add.w	ip, lr, #3
                if (!q) break;
    cfb6:	b184      	cbz	r4, cfda <core_bench_list+0x1aa>
                q = q->next;
    cfb8:	6824      	ldr	r4, [r4, #0]
                psize++;
    cfba:	f10e 0c04 	add.w	ip, lr, #4
                if (!q) break;
    cfbe:	b164      	cbz	r4, cfda <core_bench_list+0x1aa>
                q = q->next;
    cfc0:	6824      	ldr	r4, [r4, #0]
                psize++;
    cfc2:	f10e 0c05 	add.w	ip, lr, #5
                if (!q) break;
    cfc6:	b144      	cbz	r4, cfda <core_bench_list+0x1aa>
                q = q->next;
    cfc8:	6824      	ldr	r4, [r4, #0]
                psize++;
    cfca:	f10e 0c06 	add.w	ip, lr, #6
                if (!q) break;
    cfce:	b124      	cbz	r4, cfda <core_bench_list+0x1aa>
                q = q->next;
    cfd0:	6824      	ldr	r4, [r4, #0]
                psize++;
    cfd2:	f10e 0c07 	add.w	ip, lr, #7
                if (!q) break;
    cfd6:	2c00      	cmp	r4, #0
    cfd8:	d1da      	bne.n	cf90 <core_bench_list+0x160>
                    list = e;
    cfda:	f8dd 9018 	ldr.w	r9, [sp, #24]
    cfde:	4666      	mov	r6, ip
    cfe0:	464d      	mov	r5, r9
            while (psize > 0 || (qsize > 0 && q)) {
    cfe2:	2e00      	cmp	r6, #0
    cfe4:	d06b      	beq.n	d0be <core_bench_list+0x28e>
                } else if (qsize == 0 || !q) {
    cfe6:	2d00      	cmp	r5, #0
    cfe8:	d075      	beq.n	d0d6 <core_bench_list+0x2a6>
    cfea:	2c00      	cmp	r4, #0
    cfec:	d073      	beq.n	d0d6 <core_bench_list+0x2a6>
                } else if (cmp(p->info,q->info,res) <= 0) {
    cfee:	f8da 9004 	ldr.w	r9, [sl, #4]
    cff2:	6860      	ldr	r0, [r4, #4]
    ee_s16 data=*pdata;
    cff4:	f9b9 8000 	ldrsh.w	r8, [r9]
                } else if (cmp(p->info,q->info,res) <= 0) {
    cff8:	9003      	str	r0, [sp, #12]
    if (optype) /* if cached, use cache */
    cffa:	f018 0f80 	tst.w	r8, #128	; 0x80
    cffe:	d16f      	bne.n	d0e0 <core_bench_list+0x2b0>
        ee_s16 dtype=((data>>3) & 0xf); /* bits 3-6 is specific data for the operation */
    d000:	f3c8 02c3 	ubfx	r2, r8, #3, #4
        switch (flag) {
    d004:	f018 0007 	ands.w	r0, r8, #7
        dtype |= dtype << 4; /* replicate the lower 4 bits to get an 8b value */
    d008:	ea42 1102 	orr.w	r1, r2, r2, lsl #4
        switch (flag) {
    d00c:	d074      	beq.n	d0f8 <core_bench_list+0x2c8>
    d00e:	2801      	cmp	r0, #1
    d010:	d170      	bne.n	d0f4 <core_bench_list+0x2c4>
                retval=core_bench_matrix(&(res->mat),dtype,res->crc);
    d012:	f8bb 2038 	ldrh.w	r2, [fp, #56]	; 0x38
    d016:	9807      	ldr	r0, [sp, #28]
    d018:	f001 fe26 	bl	ec68 <core_bench_matrix>
                if (res->crcmatrix==0)
    d01c:	f8bb 303c 	ldrh.w	r3, [fp, #60]	; 0x3c
                retval=core_bench_matrix(&(res->mat),dtype,res->crc);
    d020:	b202      	sxth	r2, r0
                if (res->crcmatrix==0)
    d022:	b90b      	cbnz	r3, d028 <core_bench_list+0x1f8>
                    res->crcmatrix=retval;
    d024:	f8ab 003c 	strh.w	r0, [fp, #60]	; 0x3c
        res->crc=crcu16(retval,res->crc);
    d028:	f8bb 1038 	ldrh.w	r1, [fp, #56]	; 0x38
    d02c:	9204      	str	r2, [sp, #16]
    d02e:	b290      	uxth	r0, r2
    d030:	f002 fa5a 	bl	f4e8 <crcu16>
        retval &= 0x007f;
    d034:	9904      	ldr	r1, [sp, #16]
        res->crc=crcu16(retval,res->crc);
    d036:	f8ab 0038 	strh.w	r0, [fp, #56]	; 0x38
        *pdata = (data & 0xff00) | 0x0080 | retval; /* cache the result */
    d03a:	f028 02ff 	bic.w	r2, r8, #255	; 0xff
    d03e:	f042 0380 	orr.w	r3, r2, #128	; 0x80
        retval &= 0x007f;
    d042:	f001 087f 	and.w	r8, r1, #127	; 0x7f
        *pdata = (data & 0xff00) | 0x0080 | retval; /* cache the result */
    d046:	ea48 0203 	orr.w	r2, r8, r3
    d04a:	9803      	ldr	r0, [sp, #12]
    d04c:	f8a9 2000 	strh.w	r2, [r9]
    ee_s16 data=*pdata;
    d050:	f9b0 9000 	ldrsh.w	r9, [r0]
    if (optype) /* if cached, use cache */
    d054:	f019 0f80 	tst.w	r9, #128	; 0x80
    d058:	d149      	bne.n	d0ee <core_bench_list+0x2be>
        ee_s16 dtype=((data>>3) & 0xf); /* bits 3-6 is specific data for the operation */
    d05a:	f3c9 03c3 	ubfx	r3, r9, #3, #4
        switch (flag) {
    d05e:	f019 0207 	ands.w	r2, r9, #7
        dtype |= dtype << 4; /* replicate the lower 4 bits to get an 8b value */
    d062:	ea43 1103 	orr.w	r1, r3, r3, lsl #4
        switch (flag) {
    d066:	d065      	beq.n	d134 <core_bench_list+0x304>
    d068:	2a01      	cmp	r2, #1
    d06a:	d161      	bne.n	d130 <core_bench_list+0x300>
                retval=core_bench_matrix(&(res->mat),dtype,res->crc);
    d06c:	f8bb 2038 	ldrh.w	r2, [fp, #56]	; 0x38
    d070:	9807      	ldr	r0, [sp, #28]
    d072:	f001 fdf9 	bl	ec68 <core_bench_matrix>
                if (res->crcmatrix==0)
    d076:	f8bb 103c 	ldrh.w	r1, [fp, #60]	; 0x3c
                retval=core_bench_matrix(&(res->mat),dtype,res->crc);
    d07a:	b202      	sxth	r2, r0
                if (res->crcmatrix==0)
    d07c:	b909      	cbnz	r1, d082 <core_bench_list+0x252>
                    res->crcmatrix=retval;
    d07e:	f8ab 003c 	strh.w	r0, [fp, #60]	; 0x3c
        res->crc=crcu16(retval,res->crc);
    d082:	f8bb 1038 	ldrh.w	r1, [fp, #56]	; 0x38
    d086:	9204      	str	r2, [sp, #16]
    d088:	b290      	uxth	r0, r2
    d08a:	f002 fa2d 	bl	f4e8 <crcu16>
        retval &= 0x007f;
    d08e:	9904      	ldr	r1, [sp, #16]
        res->crc=crcu16(retval,res->crc);
    d090:	f8ab 0038 	strh.w	r0, [fp, #56]	; 0x38
        *pdata = (data & 0xff00) | 0x0080 | retval; /* cache the result */
    d094:	f029 02ff 	bic.w	r2, r9, #255	; 0xff
    d098:	f042 0380 	orr.w	r3, r2, #128	; 0x80
    d09c:	9803      	ldr	r0, [sp, #12]
        retval &= 0x007f;
    d09e:	f001 027f 	and.w	r2, r1, #127	; 0x7f
        *pdata = (data & 0xff00) | 0x0080 | retval; /* cache the result */
    d0a2:	4313      	orrs	r3, r2
    d0a4:	8003      	strh	r3, [r0, #0]
    return val1 - val2;
    d0a6:	eba8 0302 	sub.w	r3, r8, r2
                } else if (cmp(p->info,q->info,res) <= 0) {
    d0aa:	2b00      	cmp	r3, #0
    d0ac:	dd13      	ble.n	d0d6 <core_bench_list+0x2a6>
                    e = q; q = q->next; qsize--;
    d0ae:	4621      	mov	r1, r4
    d0b0:	6824      	ldr	r4, [r4, #0]
    d0b2:	3d01      	subs	r5, #1
                if (tail) {
    d0b4:	b167      	cbz	r7, d0d0 <core_bench_list+0x2a0>
                    tail->next = e;
    d0b6:	6039      	str	r1, [r7, #0]
                    list = e;
    d0b8:	460f      	mov	r7, r1
            while (psize > 0 || (qsize > 0 && q)) {
    d0ba:	2e00      	cmp	r6, #0
    d0bc:	d193      	bne.n	cfe6 <core_bench_list+0x1b6>
    d0be:	2d00      	cmp	r5, #0
    d0c0:	d053      	beq.n	d16a <core_bench_list+0x33a>
    d0c2:	2c00      	cmp	r4, #0
    d0c4:	d055      	beq.n	d172 <core_bench_list+0x342>
                    e = q; q = q->next; qsize--;
    d0c6:	4621      	mov	r1, r4
    d0c8:	3d01      	subs	r5, #1
    d0ca:	6824      	ldr	r4, [r4, #0]
                if (tail) {
    d0cc:	2f00      	cmp	r7, #0
    d0ce:	d1f2      	bne.n	d0b6 <core_bench_list+0x286>
                    list = e;
    d0d0:	9105      	str	r1, [sp, #20]
    d0d2:	460f      	mov	r7, r1
    d0d4:	e7f1      	b.n	d0ba <core_bench_list+0x28a>
                    e = p; p = p->next; psize--;
    d0d6:	4651      	mov	r1, sl
    d0d8:	3e01      	subs	r6, #1
    d0da:	f8da a000 	ldr.w	sl, [sl]
    d0de:	e7e9      	b.n	d0b4 <core_bench_list+0x284>
    ee_s16 data=*pdata;
    d0e0:	f9b0 9000 	ldrsh.w	r9, [r0]
    if (optype) /* if cached, use cache */
    d0e4:	f019 0f80 	tst.w	r9, #128	; 0x80
        return (data & 0x007f);
    d0e8:	f008 087f 	and.w	r8, r8, #127	; 0x7f
    if (optype) /* if cached, use cache */
    d0ec:	d0b5      	beq.n	d05a <core_bench_list+0x22a>
        return (data & 0x007f);
    d0ee:	f009 027f 	and.w	r2, r9, #127	; 0x7f
    d0f2:	e7d8      	b.n	d0a6 <core_bench_list+0x276>
        switch (flag) {
    d0f4:	4642      	mov	r2, r8
    d0f6:	e797      	b.n	d028 <core_bench_list+0x1f8>
                retval=core_bench_state(res->size,res->memblock[3],res->seed1,res->seed2,dtype,res->crc);
    d0f8:	f8db e014 	ldr.w	lr, [fp, #20]
    d0fc:	f8bb c038 	ldrh.w	ip, [fp, #56]	; 0x38
    d100:	f9bb 2000 	ldrsh.w	r2, [fp]
    d104:	f9bb 3002 	ldrsh.w	r3, [fp, #2]
    d108:	f8db 0018 	ldr.w	r0, [fp, #24]
    d10c:	f8cd c004 	str.w	ip, [sp, #4]
    d110:	2922      	cmp	r1, #34	; 0x22
    d112:	bfb8      	it	lt
    d114:	2122      	movlt	r1, #34	; 0x22
    d116:	9100      	str	r1, [sp, #0]
    d118:	4671      	mov	r1, lr
    d11a:	f002 f945 	bl	f3a8 <core_bench_state>
                if (res->crcstate==0)
    d11e:	f8bb 103e 	ldrh.w	r1, [fp, #62]	; 0x3e
                retval=core_bench_state(res->size,res->memblock[3],res->seed1,res->seed2,dtype,res->crc);
    d122:	b202      	sxth	r2, r0
                if (res->crcstate==0)
    d124:	2900      	cmp	r1, #0
    d126:	f47f af7f 	bne.w	d028 <core_bench_list+0x1f8>
                    res->crcstate=retval;
    d12a:	f8ab 003e 	strh.w	r0, [fp, #62]	; 0x3e
    d12e:	e77b      	b.n	d028 <core_bench_list+0x1f8>
        switch (flag) {
    d130:	464a      	mov	r2, r9
    d132:	e7a6      	b.n	d082 <core_bench_list+0x252>
                retval=core_bench_state(res->size,res->memblock[3],res->seed1,res->seed2,dtype,res->crc);
    d134:	f8db e014 	ldr.w	lr, [fp, #20]
    d138:	f8bb c038 	ldrh.w	ip, [fp, #56]	; 0x38
    d13c:	f9bb 3002 	ldrsh.w	r3, [fp, #2]
    d140:	f9bb 2000 	ldrsh.w	r2, [fp]
    d144:	f8db 0018 	ldr.w	r0, [fp, #24]
    d148:	f8cd c004 	str.w	ip, [sp, #4]
    d14c:	2922      	cmp	r1, #34	; 0x22
    d14e:	bfb8      	it	lt
    d150:	2122      	movlt	r1, #34	; 0x22
    d152:	9100      	str	r1, [sp, #0]
    d154:	4671      	mov	r1, lr
    d156:	f002 f927 	bl	f3a8 <core_bench_state>
                if (res->crcstate==0)
    d15a:	f8bb 303e 	ldrh.w	r3, [fp, #62]	; 0x3e
                retval=core_bench_state(res->size,res->memblock[3],res->seed1,res->seed2,dtype,res->crc);
    d15e:	b202      	sxth	r2, r0
                if (res->crcstate==0)
    d160:	2b00      	cmp	r3, #0
    d162:	d18e      	bne.n	d082 <core_bench_list+0x252>
                    res->crcstate=retval;
    d164:	f8ab 003e 	strh.w	r0, [fp, #62]	; 0x3e
    d168:	e78b      	b.n	d082 <core_bench_list+0x252>
        while (p) {
    d16a:	46a2      	mov	sl, r4
    d16c:	2c00      	cmp	r4, #0
    d16e:	f47f aed3 	bne.w	cf18 <core_bench_list+0xe8>
        tail->next = NULL;
    d172:	2500      	movs	r5, #0
    d174:	603d      	str	r5, [r7, #0]
        if (nmerges <= 1)   /* allow for nmerges==0, the empty list case */
    d176:	9f08      	ldr	r7, [sp, #32]
    d178:	2f01      	cmp	r7, #1
    d17a:	d173      	bne.n	d264 <core_bench_list+0x434>
    d17c:	f8dd b014 	ldr.w	fp, [sp, #20]
    remover=core_list_remove(list->next);
    d180:	f8db 6000 	ldr.w	r6, [fp]
    if (info->idx>=0) {
    d184:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    list_head *ret=item->next;
    d186:	6835      	ldr	r5, [r6, #0]
    tmp=item->info;
    d188:	6872      	ldr	r2, [r6, #4]
    item->next=item->next->next;
    d18a:	e895 0003 	ldmia.w	r5, {r0, r1}
    ret->next=NULL;
    d18e:	2400      	movs	r4, #0
    if (info->idx>=0) {
    d190:	42a7      	cmp	r7, r4
    item->info=ret->info;
    d192:	6071      	str	r1, [r6, #4]
    ret->info=tmp;
    d194:	606a      	str	r2, [r5, #4]
    item->next=item->next->next;
    d196:	6030      	str	r0, [r6, #0]
    ret->next=NULL;
    d198:	602c      	str	r4, [r5, #0]
    if (info->idx>=0) {
    d19a:	db57      	blt.n	d24c <core_bench_list+0x41c>
    d19c:	46be      	mov	lr, r7
    d19e:	465c      	mov	r4, fp
        while (list && (list->info->idx != info->idx))
    d1a0:	6863      	ldr	r3, [r4, #4]
    d1a2:	f9b3 6002 	ldrsh.w	r6, [r3, #2]
    d1a6:	4576      	cmp	r6, lr
    d1a8:	d006      	beq.n	d1b8 <core_bench_list+0x388>
            list=list->next;
    d1aa:	6824      	ldr	r4, [r4, #0]
        while (list && (list->info->idx != info->idx))
    d1ac:	2c00      	cmp	r4, #0
    d1ae:	d1f7      	bne.n	d1a0 <core_bench_list+0x370>
        finder=list->next;
    d1b0:	f8db 7000 	ldr.w	r7, [fp]
    d1b4:	463c      	mov	r4, r7
    while (finder) {
    d1b6:	b177      	cbz	r7, d1d6 <core_bench_list+0x3a6>
    d1b8:	9909      	ldr	r1, [sp, #36]	; 0x24
        retval=crc16(list->info->data16,retval);
    d1ba:	f8db 0004 	ldr.w	r0, [fp, #4]
    d1be:	f9b0 0000 	ldrsh.w	r0, [r0]
    d1c2:	f002 fb59 	bl	f878 <crc16>
        finder=finder->next;
    d1c6:	6824      	ldr	r4, [r4, #0]
        retval=crc16(list->info->data16,retval);
    d1c8:	4601      	mov	r1, r0
    while (finder) {
    d1ca:	2c00      	cmp	r4, #0
    d1cc:	d1f5      	bne.n	d1ba <core_bench_list+0x38a>
    d1ce:	686a      	ldr	r2, [r5, #4]
    d1d0:	f8db 7000 	ldr.w	r7, [fp]
    d1d4:	9009      	str	r0, [sp, #36]	; 0x24
    item_removed->info=item_modified->info;
    d1d6:	687b      	ldr	r3, [r7, #4]
    item_removed->next=item_modified->next;
    d1d8:	6839      	ldr	r1, [r7, #0]
    item_removed->info=item_modified->info;
    d1da:	606b      	str	r3, [r5, #4]
    list=core_list_mergesort(list,cmp_idx,NULL);
    d1dc:	4658      	mov	r0, fp
    item_modified->info=tmp;
    d1de:	607a      	str	r2, [r7, #4]
    item_removed->next=item_modified->next;
    d1e0:	6029      	str	r1, [r5, #0]
    item_modified->next=item_removed;
    d1e2:	603d      	str	r5, [r7, #0]
    list=core_list_mergesort(list,cmp_idx,NULL);
    d1e4:	f7ff fd80 	bl	cce8 <core_list_mergesort.constprop.2>
    finder=list->next;
    d1e8:	6805      	ldr	r5, [r0, #0]
    list=core_list_mergesort(list,cmp_idx,NULL);
    d1ea:	4681      	mov	r9, r0
    while (finder) {
    d1ec:	b15d      	cbz	r5, d206 <core_bench_list+0x3d6>
    d1ee:	9909      	ldr	r1, [sp, #36]	; 0x24
        retval=crc16(list->info->data16,retval);
    d1f0:	f8d9 6004 	ldr.w	r6, [r9, #4]
    d1f4:	f9b6 0000 	ldrsh.w	r0, [r6]
    d1f8:	f002 fb3e 	bl	f878 <crc16>
        finder=finder->next;
    d1fc:	682d      	ldr	r5, [r5, #0]
        retval=crc16(list->info->data16,retval);
    d1fe:	4601      	mov	r1, r0
    while (finder) {
    d200:	2d00      	cmp	r5, #0
    d202:	d1f5      	bne.n	d1f0 <core_bench_list+0x3c0>
    d204:	9009      	str	r0, [sp, #36]	; 0x24
}
    d206:	9809      	ldr	r0, [sp, #36]	; 0x24
    d208:	b00d      	add	sp, #52	; 0x34
    d20a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        while (list && ((list->info->data16 & 0xff) != info->data16))
    d20e:	b173      	cbz	r3, d22e <core_bench_list+0x3fe>
    d210:	6859      	ldr	r1, [r3, #4]
    d212:	780e      	ldrb	r6, [r1, #0]
    d214:	45b4      	cmp	ip, r6
    d216:	461d      	mov	r5, r3
    d218:	d105      	bne.n	d226 <core_bench_list+0x3f6>
    d21a:	e635      	b.n	ce88 <core_bench_list+0x58>
    d21c:	6869      	ldr	r1, [r5, #4]
    d21e:	780e      	ldrb	r6, [r1, #0]
    d220:	4566      	cmp	r6, ip
    d222:	f43f ae31 	beq.w	ce88 <core_bench_list+0x58>
            list=list->next;
    d226:	682d      	ldr	r5, [r5, #0]
        while (list && ((list->info->data16 & 0xff) != info->data16))
    d228:	2d00      	cmp	r5, #0
    d22a:	d1f7      	bne.n	d21c <core_bench_list+0x3ec>
    d22c:	e62c      	b.n	ce88 <core_bench_list+0x58>
    d22e:	f8de 6000 	ldr.w	r6, [lr]
    list_head *next=NULL, *tmp;
    d232:	2300      	movs	r3, #0
            retval+=(list->next->info->data16 >> 8) & 1;
    d234:	6871      	ldr	r1, [r6, #4]
    d236:	f991 6001 	ldrsb.w	r6, [r1, #1]
    d23a:	f006 0b01 	and.w	fp, r6, #1
    d23e:	445a      	add	r2, fp
            missed++;
    d240:	f109 0501 	add.w	r5, r9, #1
            retval+=(list->next->info->data16 >> 8) & 1;
    d244:	b292      	uxth	r2, r2
            missed++;
    d246:	fa1f f985 	uxth.w	r9, r5
    d24a:	e63b      	b.n	cec4 <core_bench_list+0x94>
    if (info->idx>=0) {
    d24c:	465c      	mov	r4, fp
    d24e:	990b      	ldr	r1, [sp, #44]	; 0x2c
    d250:	e002      	b.n	d258 <core_bench_list+0x428>
            list=list->next;
    d252:	6824      	ldr	r4, [r4, #0]
        while (list && ((list->info->data16 & 0xff) != info->data16))
    d254:	2c00      	cmp	r4, #0
    d256:	d0ab      	beq.n	d1b0 <core_bench_list+0x380>
    d258:	6860      	ldr	r0, [r4, #4]
    d25a:	f890 8000 	ldrb.w	r8, [r0]
    d25e:	4588      	cmp	r8, r1
    d260:	d1f7      	bne.n	d252 <core_bench_list+0x422>
    d262:	e7a9      	b.n	d1b8 <core_bench_list+0x388>
        insize *= 2;
    d264:	9906      	ldr	r1, [sp, #24]
    d266:	f8dd a014 	ldr.w	sl, [sp, #20]
    d26a:	0048      	lsls	r0, r1, #1
    d26c:	9006      	str	r0, [sp, #24]
    d26e:	4653      	mov	r3, sl
    d270:	e64b      	b.n	cf0a <core_bench_list+0xda>
    for (i=0; i<find_num; i++) {
    d272:	2300      	movs	r3, #0
    info.idx=finder_idx;
    d274:	910a      	str	r1, [sp, #40]	; 0x28
    for (i=0; i<find_num; i++) {
    d276:	9309      	str	r3, [sp, #36]	; 0x24
    d278:	e638      	b.n	ceec <core_bench_list+0xbc>
    d27a:	4698      	mov	r8, r3
        tail->next = NULL;
    d27c:	f8c8 3000 	str.w	r3, [r8]
    d280:	deff      	udf	#255	; 0xff
    d282:	bf00      	nop

0000d284 <core_list_init>:
    ee_u32 size=(blksize/per_item)-2; /* to accomodate systems with 64b pointers, and make sure same code is executed, set max list elements */
    d284:	4bb2      	ldr	r3, [pc, #712]	; (d550 <core_list_init+0x2cc>)
list_head *core_list_init(ee_u32 blksize, list_head *memblock, ee_s16 seed) {
    d286:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ee_u32 size=(blksize/per_item)-2; /* to accomodate systems with 64b pointers, and make sure same code is executed, set max list elements */
    d28a:	fba3 3000 	umull	r3, r0, r3, r0
    d28e:	ea4f 1e10 	mov.w	lr, r0, lsr #4
    d292:	f1ae 0e02 	sub.w	lr, lr, #2
    list_head *memblock_end=memblock+size;
    d296:	eb01 07ce 	add.w	r7, r1, lr, lsl #3
    if ((*memblock+1) >= memblock_end)
    d29a:	f101 0910 	add.w	r9, r1, #16
    list->info->data16=(ee_s16)0x8080;
    d29e:	f248 0480 	movw	r4, #32896	; 0x8080
    list->next=NULL;
    d2a2:	2300      	movs	r3, #0
    if ((*memblock+1) >= memblock_end)
    d2a4:	454f      	cmp	r7, r9
    list->info=datablock;
    d2a6:	e881 0088 	stmia.w	r1, {r3, r7}
list_head *core_list_init(ee_u32 blksize, list_head *memblock, ee_s16 seed) {
    d2aa:	b083      	sub	sp, #12
    list->info->data16=(ee_s16)0x8080;
    d2ac:	f841 403e 	str.w	r4, [r1, lr, lsl #3]
    list_data *datablock_end=datablock+size;
    d2b0:	eb07 088e 	add.w	r8, r7, lr, lsl #2
    datablock++;
    d2b4:	f107 0604 	add.w	r6, r7, #4
    memblock++;
    d2b8:	f101 0408 	add.w	r4, r1, #8
    if ((*memblock+1) >= memblock_end)
    d2bc:	d904      	bls.n	d2c8 <core_list_init+0x44>
    if ((*datablock+1) >= datablock_end)
    d2be:	f107 0508 	add.w	r5, r7, #8
    d2c2:	45a8      	cmp	r8, r5
    d2c4:	f200 8139 	bhi.w	d53a <core_list_init+0x2b6>
    for (i=0; i<size; i++) {
    d2c8:	f1be 0f00 	cmp.w	lr, #0
    d2cc:	f000 80cb 	beq.w	d466 <core_list_init+0x1e2>
    d2d0:	f10e 35ff 	add.w	r5, lr, #4294967295
    if ((*memblock+1) >= memblock_end)
    d2d4:	f104 0b08 	add.w	fp, r4, #8
    d2d8:	f005 0003 	and.w	r0, r5, #3
    d2dc:	455f      	cmp	r7, fp
    d2de:	b295      	uxth	r5, r2
    d2e0:	9501      	str	r5, [sp, #4]
    to->idx=from->idx;
    d2e2:	f647 79ff 	movw	r9, #32767	; 0x7fff
    if ((*memblock+1) >= memblock_end)
    d2e6:	f200 80df 	bhi.w	d4a8 <core_list_init+0x224>
    for (i=0; i<size; i++) {
    d2ea:	2501      	movs	r5, #1
    d2ec:	45ae      	cmp	lr, r5
    d2ee:	f000 80ba 	beq.w	d466 <core_list_init+0x1e2>
    d2f2:	b390      	cbz	r0, d35a <core_list_init+0xd6>
    d2f4:	42a8      	cmp	r0, r5
    d2f6:	d00d      	beq.n	d314 <core_list_init+0x90>
    d2f8:	2802      	cmp	r0, #2
    d2fa:	d005      	beq.n	d308 <core_list_init+0x84>
    if ((*memblock+1) >= memblock_end)
    d2fc:	f104 0c08 	add.w	ip, r4, #8
    d300:	4567      	cmp	r7, ip
    d302:	f200 8102 	bhi.w	d50a <core_list_init+0x286>
    for (i=0; i<size; i++) {
    d306:	3501      	adds	r5, #1
    if ((*memblock+1) >= memblock_end)
    d308:	f104 0c08 	add.w	ip, r4, #8
    d30c:	4567      	cmp	r7, ip
    d30e:	f200 80df 	bhi.w	d4d0 <core_list_init+0x24c>
    for (i=0; i<size; i++) {
    d312:	3501      	adds	r5, #1
    if ((*memblock+1) >= memblock_end)
    d314:	f104 0c08 	add.w	ip, r4, #8
    d318:	4567      	cmp	r7, ip
    d31a:	d91a      	bls.n	d352 <core_list_init+0xce>
    if ((*datablock+1) >= datablock_end)
    d31c:	f106 0a04 	add.w	sl, r6, #4
    d320:	45d0      	cmp	r8, sl
    d322:	d916      	bls.n	d352 <core_list_init+0xce>
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    d324:	9801      	ldr	r0, [sp, #4]
    newitem->next=insert_point->next;
    d326:	6023      	str	r3, [r4, #0]
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    d328:	fa1f fb85 	uxth.w	fp, r5
    d32c:	ea8b 0000 	eor.w	r0, fp, r0
        ee_u16 dat=(datpat<<3) | (i&0x7); /* alternate between algorithms */
    d330:	00c0      	lsls	r0, r0, #3
    d332:	f000 0078 	and.w	r0, r0, #120	; 0x78
    d336:	f00b 0b07 	and.w	fp, fp, #7
    d33a:	ea40 000b 	orr.w	r0, r0, fp
        info.data16=(dat<<8) | dat;     /* fill the data with actual data and upper bits with rebuild value */
    d33e:	ea40 2000 	orr.w	r0, r0, r0, lsl #8
    insert_point->next=newitem;
    d342:	600c      	str	r4, [r1, #0]
    to->idx=from->idx;
    d344:	4623      	mov	r3, r4
    newitem->info=*datablock;
    d346:	6066      	str	r6, [r4, #4]
    to->idx=from->idx;
    d348:	f8a6 9002 	strh.w	r9, [r6, #2]
    to->data16=from->data16;
    d34c:	8030      	strh	r0, [r6, #0]
    to->idx=from->idx;
    d34e:	4664      	mov	r4, ip
    d350:	4656      	mov	r6, sl
    for (i=0; i<size; i++) {
    d352:	3501      	adds	r5, #1
    d354:	45ae      	cmp	lr, r5
    d356:	f000 8086 	beq.w	d466 <core_list_init+0x1e2>
    if ((*memblock+1) >= memblock_end)
    d35a:	f104 0c08 	add.w	ip, r4, #8
    d35e:	4567      	cmp	r7, ip
    d360:	d91a      	bls.n	d398 <core_list_init+0x114>
    if ((*datablock+1) >= datablock_end)
    d362:	f106 0a04 	add.w	sl, r6, #4
    d366:	45d0      	cmp	r8, sl
    d368:	d916      	bls.n	d398 <core_list_init+0x114>
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    d36a:	9801      	ldr	r0, [sp, #4]
    newitem->next=insert_point->next;
    d36c:	6023      	str	r3, [r4, #0]
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    d36e:	fa1f fb85 	uxth.w	fp, r5
    d372:	ea8b 0000 	eor.w	r0, fp, r0
        ee_u16 dat=(datpat<<3) | (i&0x7); /* alternate between algorithms */
    d376:	00c0      	lsls	r0, r0, #3
    d378:	f000 0078 	and.w	r0, r0, #120	; 0x78
    d37c:	f00b 0b07 	and.w	fp, fp, #7
    d380:	ea40 000b 	orr.w	r0, r0, fp
        info.data16=(dat<<8) | dat;     /* fill the data with actual data and upper bits with rebuild value */
    d384:	ea40 2000 	orr.w	r0, r0, r0, lsl #8
    insert_point->next=newitem;
    d388:	600c      	str	r4, [r1, #0]
    to->idx=from->idx;
    d38a:	4623      	mov	r3, r4
    newitem->info=*datablock;
    d38c:	6066      	str	r6, [r4, #4]
    to->idx=from->idx;
    d38e:	f8a6 9002 	strh.w	r9, [r6, #2]
    to->data16=from->data16;
    d392:	8030      	strh	r0, [r6, #0]
    to->idx=from->idx;
    d394:	4664      	mov	r4, ip
    d396:	4656      	mov	r6, sl
    if ((*memblock+1) >= memblock_end)
    d398:	f104 0c08 	add.w	ip, r4, #8
    d39c:	4567      	cmp	r7, ip
    for (i=0; i<size; i++) {
    d39e:	f105 0501 	add.w	r5, r5, #1
    if ((*memblock+1) >= memblock_end)
    d3a2:	d91a      	bls.n	d3da <core_list_init+0x156>
    if ((*datablock+1) >= datablock_end)
    d3a4:	f106 0a04 	add.w	sl, r6, #4
    d3a8:	45d0      	cmp	r8, sl
    d3aa:	d916      	bls.n	d3da <core_list_init+0x156>
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    d3ac:	9801      	ldr	r0, [sp, #4]
    newitem->next=insert_point->next;
    d3ae:	6023      	str	r3, [r4, #0]
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    d3b0:	fa1f fb85 	uxth.w	fp, r5
    d3b4:	ea8b 0000 	eor.w	r0, fp, r0
        ee_u16 dat=(datpat<<3) | (i&0x7); /* alternate between algorithms */
    d3b8:	00c0      	lsls	r0, r0, #3
    d3ba:	f000 0078 	and.w	r0, r0, #120	; 0x78
    d3be:	f00b 0b07 	and.w	fp, fp, #7
    d3c2:	ea40 000b 	orr.w	r0, r0, fp
        info.data16=(dat<<8) | dat;     /* fill the data with actual data and upper bits with rebuild value */
    d3c6:	ea40 2000 	orr.w	r0, r0, r0, lsl #8
    insert_point->next=newitem;
    d3ca:	600c      	str	r4, [r1, #0]
    to->idx=from->idx;
    d3cc:	4623      	mov	r3, r4
    newitem->info=*datablock;
    d3ce:	6066      	str	r6, [r4, #4]
    to->idx=from->idx;
    d3d0:	f8a6 9002 	strh.w	r9, [r6, #2]
    to->data16=from->data16;
    d3d4:	8030      	strh	r0, [r6, #0]
    to->idx=from->idx;
    d3d6:	4664      	mov	r4, ip
    d3d8:	4656      	mov	r6, sl
    if ((*memblock+1) >= memblock_end)
    d3da:	f104 0a08 	add.w	sl, r4, #8
    d3de:	4557      	cmp	r7, sl
    for (i=0; i<size; i++) {
    d3e0:	f105 0001 	add.w	r0, r5, #1
    if ((*memblock+1) >= memblock_end)
    d3e4:	d91a      	bls.n	d41c <core_list_init+0x198>
    if ((*datablock+1) >= datablock_end)
    d3e6:	f106 0b04 	add.w	fp, r6, #4
    d3ea:	45d8      	cmp	r8, fp
    d3ec:	d916      	bls.n	d41c <core_list_init+0x198>
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    d3ee:	fa1f fc80 	uxth.w	ip, r0
    d3f2:	9801      	ldr	r0, [sp, #4]
    newitem->next=insert_point->next;
    d3f4:	6023      	str	r3, [r4, #0]
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    d3f6:	ea8c 0000 	eor.w	r0, ip, r0
        ee_u16 dat=(datpat<<3) | (i&0x7); /* alternate between algorithms */
    d3fa:	00c0      	lsls	r0, r0, #3
    d3fc:	f000 0078 	and.w	r0, r0, #120	; 0x78
    d400:	f00c 0c07 	and.w	ip, ip, #7
    d404:	ea40 000c 	orr.w	r0, r0, ip
        info.data16=(dat<<8) | dat;     /* fill the data with actual data and upper bits with rebuild value */
    d408:	ea40 2000 	orr.w	r0, r0, r0, lsl #8
    insert_point->next=newitem;
    d40c:	600c      	str	r4, [r1, #0]
    to->idx=from->idx;
    d40e:	4623      	mov	r3, r4
    newitem->info=*datablock;
    d410:	6066      	str	r6, [r4, #4]
    to->idx=from->idx;
    d412:	f8a6 9002 	strh.w	r9, [r6, #2]
    to->data16=from->data16;
    d416:	8030      	strh	r0, [r6, #0]
    to->idx=from->idx;
    d418:	4654      	mov	r4, sl
    d41a:	465e      	mov	r6, fp
    if ((*memblock+1) >= memblock_end)
    d41c:	f104 0a08 	add.w	sl, r4, #8
    d420:	4557      	cmp	r7, sl
    for (i=0; i<size; i++) {
    d422:	f105 0002 	add.w	r0, r5, #2
    if ((*memblock+1) >= memblock_end)
    d426:	d91a      	bls.n	d45e <core_list_init+0x1da>
    if ((*datablock+1) >= datablock_end)
    d428:	f106 0b04 	add.w	fp, r6, #4
    d42c:	45d8      	cmp	r8, fp
    d42e:	d916      	bls.n	d45e <core_list_init+0x1da>
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    d430:	fa1f fc80 	uxth.w	ip, r0
    d434:	9801      	ldr	r0, [sp, #4]
    newitem->next=insert_point->next;
    d436:	6023      	str	r3, [r4, #0]
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    d438:	ea8c 0000 	eor.w	r0, ip, r0
        ee_u16 dat=(datpat<<3) | (i&0x7); /* alternate between algorithms */
    d43c:	00c0      	lsls	r0, r0, #3
    d43e:	f000 0078 	and.w	r0, r0, #120	; 0x78
    d442:	f00c 0c07 	and.w	ip, ip, #7
    d446:	ea40 000c 	orr.w	r0, r0, ip
        info.data16=(dat<<8) | dat;     /* fill the data with actual data and upper bits with rebuild value */
    d44a:	ea40 2000 	orr.w	r0, r0, r0, lsl #8
    insert_point->next=newitem;
    d44e:	600c      	str	r4, [r1, #0]
    to->idx=from->idx;
    d450:	4623      	mov	r3, r4
    newitem->info=*datablock;
    d452:	6066      	str	r6, [r4, #4]
    to->idx=from->idx;
    d454:	f8a6 9002 	strh.w	r9, [r6, #2]
    to->data16=from->data16;
    d458:	8030      	strh	r0, [r6, #0]
    to->idx=from->idx;
    d45a:	4654      	mov	r4, sl
    d45c:	465e      	mov	r6, fp
    for (i=0; i<size; i++) {
    d45e:	3503      	adds	r5, #3
    d460:	45ae      	cmp	lr, r5
    d462:	f47f af7a 	bne.w	d35a <core_list_init+0xd6>
        if (i<size/5) /* first 20% of the list in order */
    d466:	4f3a      	ldr	r7, [pc, #232]	; (d550 <core_list_init+0x2cc>)
    d468:	fba7 050e 	umull	r0, r5, r7, lr
    d46c:	ea4f 0e95 	mov.w	lr, r5, lsr #2
    while (finder->next!=NULL) {
    d470:	2602      	movs	r6, #2
    d472:	2501      	movs	r5, #1
    d474:	e00a      	b.n	d48c <core_list_init+0x208>
        if (i<size/5) /* first 20% of the list in order */
    d476:	4575      	cmp	r5, lr
            finder->info->idx=i++;
    d478:	685b      	ldr	r3, [r3, #4]
            finder->info->idx=0x3fff & (((i & 0x07) << 8) | pat); /* make sure the mixed items end up after the ones in sequence */
    d47a:	bf25      	ittet	cs
    d47c:	4338      	orrcs	r0, r7
    d47e:	f3c0 000d 	ubfxcs	r0, r0, #0, #14
            finder->info->idx=i++;
    d482:	805d      	strhcc	r5, [r3, #2]
            finder->info->idx=0x3fff & (((i & 0x07) << 8) | pat); /* make sure the mixed items end up after the ones in sequence */
    d484:	8058      	strhcs	r0, [r3, #2]
    d486:	3601      	adds	r6, #1
    d488:	3501      	adds	r5, #1
    to->idx=from->idx;
    d48a:	4623      	mov	r3, r4
    while (finder->next!=NULL) {
    d48c:	681c      	ldr	r4, [r3, #0]
            finder->info->idx=0x3fff & (((i & 0x07) << 8) | pat); /* make sure the mixed items end up after the ones in sequence */
    d48e:	0230      	lsls	r0, r6, #8
            ee_u16 pat=(ee_u16)(i++ ^ seed); /* get a pseudo random number */
    d490:	ea85 0702 	eor.w	r7, r5, r2
            finder->info->idx=0x3fff & (((i & 0x07) << 8) | pat); /* make sure the mixed items end up after the ones in sequence */
    d494:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
    while (finder->next!=NULL) {
    d498:	2c00      	cmp	r4, #0
    d49a:	d1ec      	bne.n	d476 <core_list_init+0x1f2>
    list = core_list_mergesort(list,cmp_idx,NULL);
    d49c:	4608      	mov	r0, r1
}
    d49e:	b003      	add	sp, #12
    d4a0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    list = core_list_mergesort(list,cmp_idx,NULL);
    d4a4:	f7ff bc20 	b.w	cce8 <core_list_mergesort.constprop.2>
    if ((*datablock+1) >= datablock_end)
    d4a8:	f106 0a04 	add.w	sl, r6, #4
    d4ac:	45d0      	cmp	r8, sl
    d4ae:	f67f af1c 	bls.w	d2ea <core_list_init+0x66>
        ee_u16 dat=(datpat<<3) | (i&0x7); /* alternate between algorithms */
    d4b2:	00ed      	lsls	r5, r5, #3
    d4b4:	f005 0578 	and.w	r5, r5, #120	; 0x78
        info.data16=(dat<<8) | dat;     /* fill the data with actual data and upper bits with rebuild value */
    d4b8:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    newitem->next=insert_point->next;
    d4bc:	6023      	str	r3, [r4, #0]
    insert_point->next=newitem;
    d4be:	600c      	str	r4, [r1, #0]
    to->idx=from->idx;
    d4c0:	4623      	mov	r3, r4
    newitem->info=*datablock;
    d4c2:	6066      	str	r6, [r4, #4]
    to->idx=from->idx;
    d4c4:	f8a6 9002 	strh.w	r9, [r6, #2]
    to->data16=from->data16;
    d4c8:	8035      	strh	r5, [r6, #0]
    to->idx=from->idx;
    d4ca:	465c      	mov	r4, fp
    d4cc:	4656      	mov	r6, sl
    d4ce:	e70c      	b.n	d2ea <core_list_init+0x66>
    if ((*datablock+1) >= datablock_end)
    d4d0:	f106 0a04 	add.w	sl, r6, #4
    d4d4:	45d0      	cmp	r8, sl
    d4d6:	f67f af1c 	bls.w	d312 <core_list_init+0x8e>
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    d4da:	9801      	ldr	r0, [sp, #4]
    newitem->next=insert_point->next;
    d4dc:	6023      	str	r3, [r4, #0]
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    d4de:	fa1f fb85 	uxth.w	fp, r5
    d4e2:	ea8b 0000 	eor.w	r0, fp, r0
        ee_u16 dat=(datpat<<3) | (i&0x7); /* alternate between algorithms */
    d4e6:	00c0      	lsls	r0, r0, #3
    d4e8:	f000 0078 	and.w	r0, r0, #120	; 0x78
    d4ec:	f00b 0b07 	and.w	fp, fp, #7
    d4f0:	ea40 000b 	orr.w	r0, r0, fp
        info.data16=(dat<<8) | dat;     /* fill the data with actual data and upper bits with rebuild value */
    d4f4:	ea40 2000 	orr.w	r0, r0, r0, lsl #8
    insert_point->next=newitem;
    d4f8:	600c      	str	r4, [r1, #0]
    to->idx=from->idx;
    d4fa:	4623      	mov	r3, r4
    newitem->info=*datablock;
    d4fc:	6066      	str	r6, [r4, #4]
    to->idx=from->idx;
    d4fe:	f8a6 9002 	strh.w	r9, [r6, #2]
    to->data16=from->data16;
    d502:	8030      	strh	r0, [r6, #0]
    to->idx=from->idx;
    d504:	4664      	mov	r4, ip
    d506:	4656      	mov	r6, sl
    d508:	e703      	b.n	d312 <core_list_init+0x8e>
    if ((*datablock+1) >= datablock_end)
    d50a:	f106 0b04 	add.w	fp, r6, #4
    d50e:	45d8      	cmp	r8, fp
    d510:	f67f aef9 	bls.w	d306 <core_list_init+0x82>
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    d514:	9801      	ldr	r0, [sp, #4]
    newitem->next=insert_point->next;
    d516:	6023      	str	r3, [r4, #0]
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    d518:	4068      	eors	r0, r5
        ee_u16 dat=(datpat<<3) | (i&0x7); /* alternate between algorithms */
    d51a:	00c0      	lsls	r0, r0, #3
    d51c:	f000 0078 	and.w	r0, r0, #120	; 0x78
    d520:	4328      	orrs	r0, r5
        info.data16=(dat<<8) | dat;     /* fill the data with actual data and upper bits with rebuild value */
    d522:	ea40 2a00 	orr.w	sl, r0, r0, lsl #8
    insert_point->next=newitem;
    d526:	600c      	str	r4, [r1, #0]
    to->idx=from->idx;
    d528:	4623      	mov	r3, r4
    newitem->info=*datablock;
    d52a:	6066      	str	r6, [r4, #4]
    to->idx=from->idx;
    d52c:	f8a6 9002 	strh.w	r9, [r6, #2]
    to->data16=from->data16;
    d530:	f8a6 a000 	strh.w	sl, [r6]
    to->idx=from->idx;
    d534:	4664      	mov	r4, ip
    d536:	465e      	mov	r6, fp
    d538:	e6e5      	b.n	d306 <core_list_init+0x82>
    to->data16=from->data16;
    d53a:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
    newitem->next=insert_point->next;
    d53e:	608b      	str	r3, [r1, #8]
    insert_point->next=newitem;
    d540:	600c      	str	r4, [r1, #0]
    newitem->info=*datablock;
    d542:	60ce      	str	r6, [r1, #12]
    to->data16=from->data16;
    d544:	4623      	mov	r3, r4
    d546:	462e      	mov	r6, r5
    d548:	464c      	mov	r4, r9
    d54a:	6078      	str	r0, [r7, #4]
    d54c:	e6bc      	b.n	d2c8 <core_list_init+0x44>
    d54e:	bf00      	nop
    d550:	cccccccd 	.word	0xcccccccd

0000d554 <iterate>:
    NULL.
*/
static ee_u16 list_known_crc[]   =      {(ee_u16)0xd4b0,(ee_u16)0x3340,(ee_u16)0x6a79,(ee_u16)0xe714,(ee_u16)0xe3c1};
static ee_u16 matrix_known_crc[] =      {(ee_u16)0xbe52,(ee_u16)0x1199,(ee_u16)0x5608,(ee_u16)0x1fd7,(ee_u16)0x0747};
static ee_u16 state_known_crc[]  =      {(ee_u16)0x5e47,(ee_u16)0x39bf,(ee_u16)0xe5a4,(ee_u16)0x8e3a,(ee_u16)0x8d84};
void *iterate(void *pres) {
    d554:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ee_u32 i;
    ee_u16 crc;
    core_results *res=(core_results *)pres;
    ee_u32 iterations=res->iterations;
    d556:	69c7      	ldr	r7, [r0, #28]
    res->crc=0;
    d558:	2300      	movs	r3, #0
    d55a:	6383      	str	r3, [r0, #56]	; 0x38
    d55c:	63c3      	str	r3, [r0, #60]	; 0x3c
    res->crclist=0;
    res->crcmatrix=0;
    res->crcstate=0;

    for (i=0; i<iterations; i++) {
    d55e:	2f00      	cmp	r7, #0
    d560:	d056      	beq.n	d610 <iterate+0xbc>
    d562:	4604      	mov	r4, r0
    d564:	1e7a      	subs	r2, r7, #1
        crc=core_bench_list(res,1);
    d566:	2101      	movs	r1, #1
    d568:	ea02 0601 	and.w	r6, r2, r1
    d56c:	f7ff fc60 	bl	ce30 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d570:	8f21      	ldrh	r1, [r4, #56]	; 0x38
    d572:	f001 ffb9 	bl	f4e8 <crcu16>
        crc=core_bench_list(res,-1);
    d576:	f04f 31ff 	mov.w	r1, #4294967295
        res->crc=crcu16(crc,res->crc);
    d57a:	8720      	strh	r0, [r4, #56]	; 0x38
        crc=core_bench_list(res,-1);
    d57c:	4620      	mov	r0, r4
    d57e:	f7ff fc57 	bl	ce30 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d582:	8f21      	ldrh	r1, [r4, #56]	; 0x38
    d584:	f001 ffb0 	bl	f4e8 <crcu16>
    for (i=0; i<iterations; i++) {
    d588:	2501      	movs	r5, #1
    d58a:	42af      	cmp	r7, r5
        res->crc=crcu16(crc,res->crc);
    d58c:	8720      	strh	r0, [r4, #56]	; 0x38
        if (i==0) res->crclist=res->crc;
    d58e:	8760      	strh	r0, [r4, #58]	; 0x3a
    for (i=0; i<iterations; i++) {
    d590:	d03e      	beq.n	d610 <iterate+0xbc>
    d592:	b19e      	cbz	r6, d5bc <iterate+0x68>
        crc=core_bench_list(res,1);
    d594:	4629      	mov	r1, r5
    d596:	4620      	mov	r0, r4
    d598:	f7ff fc4a 	bl	ce30 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d59c:	8f21      	ldrh	r1, [r4, #56]	; 0x38
    d59e:	f001 ffa3 	bl	f4e8 <crcu16>
        crc=core_bench_list(res,-1);
    d5a2:	f04f 31ff 	mov.w	r1, #4294967295
        res->crc=crcu16(crc,res->crc);
    d5a6:	8720      	strh	r0, [r4, #56]	; 0x38
        crc=core_bench_list(res,-1);
    d5a8:	4620      	mov	r0, r4
    d5aa:	f7ff fc41 	bl	ce30 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d5ae:	8f21      	ldrh	r1, [r4, #56]	; 0x38
    d5b0:	f001 ff9a 	bl	f4e8 <crcu16>
    for (i=0; i<iterations; i++) {
    d5b4:	3501      	adds	r5, #1
    d5b6:	42af      	cmp	r7, r5
        res->crc=crcu16(crc,res->crc);
    d5b8:	8720      	strh	r0, [r4, #56]	; 0x38
    for (i=0; i<iterations; i++) {
    d5ba:	d029      	beq.n	d610 <iterate+0xbc>
        crc=core_bench_list(res,1);
    d5bc:	2101      	movs	r1, #1
    d5be:	4620      	mov	r0, r4
    d5c0:	f7ff fc36 	bl	ce30 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d5c4:	8f21      	ldrh	r1, [r4, #56]	; 0x38
    d5c6:	f001 ff8f 	bl	f4e8 <crcu16>
        crc=core_bench_list(res,-1);
    d5ca:	f04f 31ff 	mov.w	r1, #4294967295
        res->crc=crcu16(crc,res->crc);
    d5ce:	8720      	strh	r0, [r4, #56]	; 0x38
        crc=core_bench_list(res,-1);
    d5d0:	4620      	mov	r0, r4
    d5d2:	f7ff fc2d 	bl	ce30 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d5d6:	8f21      	ldrh	r1, [r4, #56]	; 0x38
    d5d8:	f001 ff86 	bl	f4e8 <crcu16>
        crc=core_bench_list(res,1);
    d5dc:	2101      	movs	r1, #1
        res->crc=crcu16(crc,res->crc);
    d5de:	4684      	mov	ip, r0
    for (i=0; i<iterations; i++) {
    d5e0:	186e      	adds	r6, r5, r1
        crc=core_bench_list(res,1);
    d5e2:	4620      	mov	r0, r4
        res->crc=crcu16(crc,res->crc);
    d5e4:	f8a4 c038 	strh.w	ip, [r4, #56]	; 0x38
        if (i==0) res->crclist=res->crc;
    d5e8:	b1a5      	cbz	r5, d614 <iterate+0xc0>
        crc=core_bench_list(res,1);
    d5ea:	f7ff fc21 	bl	ce30 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d5ee:	8f21      	ldrh	r1, [r4, #56]	; 0x38
    d5f0:	f001 ff7a 	bl	f4e8 <crcu16>
        crc=core_bench_list(res,-1);
    d5f4:	f04f 31ff 	mov.w	r1, #4294967295
        res->crc=crcu16(crc,res->crc);
    d5f8:	8720      	strh	r0, [r4, #56]	; 0x38
        crc=core_bench_list(res,-1);
    d5fa:	4620      	mov	r0, r4
    d5fc:	f7ff fc18 	bl	ce30 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d600:	8f21      	ldrh	r1, [r4, #56]	; 0x38
    d602:	f001 ff71 	bl	f4e8 <crcu16>
    d606:	8720      	strh	r0, [r4, #56]	; 0x38
        if (i==0) res->crclist=res->crc;
    d608:	b13e      	cbz	r6, d61a <iterate+0xc6>
    for (i=0; i<iterations; i++) {
    d60a:	1c75      	adds	r5, r6, #1
    d60c:	42af      	cmp	r7, r5
    d60e:	d1d5      	bne.n	d5bc <iterate+0x68>
    }
    return NULL;
}
    d610:	2000      	movs	r0, #0
    d612:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (i==0) res->crclist=res->crc;
    d614:	f8a4 c03a 	strh.w	ip, [r4, #58]	; 0x3a
    d618:	e7e7      	b.n	d5ea <iterate+0x96>
    d61a:	8760      	strh	r0, [r4, #58]	; 0x3a
    d61c:	e7f5      	b.n	d60a <iterate+0xb6>
    d61e:	bf00      	nop

0000d620 <main>:
    4 - Iterations  : Special, if set to 0, iterations will be automatically determined such that the benchmark will run between 10 to 100 secs

*/

#if MAIN_HAS_NOARGC
MAIN_RETURN_TYPE main(void) {
    d620:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d624:	f6ad 0d44 	subw	sp, sp, #2116	; 0x844
    int argc=0;
    d628:	2300      	movs	r3, #0
    core_results results[MULTITHREAD];
#if (MEM_METHOD==MEM_STACK)
    ee_u8 stack_memblock[TOTAL_DATA_SIZE*MULTITHREAD];
#endif
    /* first call any initializations needed */
    portable_init(&(results[0].port), &argc, argv);
    d62a:	a909      	add	r1, sp, #36	; 0x24
    d62c:	aa0a      	add	r2, sp, #40	; 0x28
    d62e:	f10d 006e 	add.w	r0, sp, #110	; 0x6e
    int argc=0;
    d632:	9309      	str	r3, [sp, #36]	; 0x24
    portable_init(&(results[0].port), &argc, argv);
    d634:	f001 fc98 	bl	ef68 <portable_init>
    /* First some checks to make sure benchmark will run ok */
    if (sizeof(struct list_head_s)>128) {
        ee_printf("list_head structure too big for comparable data!\n");
        return MAIN_RETURN_VAL;
    }
    results[0].seed1=get_seed(1);
    d638:	2001      	movs	r0, #1
    d63a:	f001 ff31 	bl	f4a0 <get_seed_32>
    d63e:	f8ad 002c 	strh.w	r0, [sp, #44]	; 0x2c
    results[0].seed2=get_seed(2);
    d642:	2002      	movs	r0, #2
    d644:	f001 ff2c 	bl	f4a0 <get_seed_32>
    d648:	f8ad 002e 	strh.w	r0, [sp, #46]	; 0x2e
    results[0].seed3=get_seed(3);
    d64c:	2003      	movs	r0, #3
    d64e:	f001 ff27 	bl	f4a0 <get_seed_32>
    d652:	f8ad 0030 	strh.w	r0, [sp, #48]	; 0x30
    results[0].iterations=get_seed_32(4);
    d656:	2004      	movs	r0, #4
    d658:	f001 ff22 	bl	f4a0 <get_seed_32>
    d65c:	9012      	str	r0, [sp, #72]	; 0x48
#if CORE_DEBUG
    results[0].iterations=1;
#endif
    results[0].execs=get_seed_32(5);
    d65e:	2005      	movs	r0, #5
    d660:	f001 ff1e 	bl	f4a0 <get_seed_32>
    if (results[0].execs==0) { /* if not supplied, execute all algorithms */
    d664:	2800      	cmp	r0, #0
    d666:	f000 814a 	beq.w	d8fe <main+0x2de>
    results[0].execs=get_seed_32(5);
    d66a:	9013      	str	r0, [sp, #76]	; 0x4c
        results[0].execs=ALL_ALGORITHMS_MASK;
    }
        /* put in some default values based on one seed only for easy testing */
    if ((results[0].seed1==0) && (results[0].seed2==0) && (results[0].seed3==0)) { /* validation run */
    d66c:	990b      	ldr	r1, [sp, #44]	; 0x2c
    d66e:	2900      	cmp	r1, #0
    d670:	f040 81c3 	bne.w	d9fa <main+0x3da>
    d674:	f9bd 4030 	ldrsh.w	r4, [sp, #48]	; 0x30
    d678:	2c00      	cmp	r4, #0
    d67a:	f000 81c8 	beq.w	da0e <main+0x3ee>
        results[i].size=TOTAL_DATA_SIZE;
        results[i].seed1=results[0].seed1;
        results[i].seed2=results[0].seed2;
        results[i].seed3=results[0].seed3;
        results[i].err=0;
        results[i].execs=results[0].execs;
    d67e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
        results[i].seed1=results[0].seed1;
    d680:	f9bd 202c 	ldrsh.w	r2, [sp, #44]	; 0x2c
        results[i].memblock[0]=stack_memblock+i*TOTAL_DATA_SIZE;
    d684:	a91c      	add	r1, sp, #112	; 0x70
        results[i].err=0;
    d686:	2500      	movs	r5, #0
    d688:	f3c3 0640 	ubfx	r6, r3, #1, #1
    d68c:	f003 0701 	and.w	r7, r3, #1
        results[i].memblock[0]=stack_memblock+i*TOTAL_DATA_SIZE;
    d690:	910d      	str	r1, [sp, #52]	; 0x34
    for (i=0 ; i<MULTITHREAD; i++)
        results[i].size=results[i].size/num_algorithms;
    /* Assign pointers */
    for (i=0; i<NUM_ALGORITHMS; i++) {
        ee_u32 ctx;
        if ((1<<(ee_u32)i) & results[0].execs) {
    d692:	f013 0101 	ands.w	r1, r3, #1
        results[i].err=0;
    d696:	f8ad 506c 	strh.w	r5, [sp, #108]	; 0x6c
        results[i].size=results[i].size/num_algorithms;
    d69a:	443e      	add	r6, r7
            for (ctx=0 ; ctx<MULTITHREAD; ctx++)
                results[ctx].memblock[i+1]=(char *)(results[ctx].memblock[0])+results[0].size*j;
    d69c:	bf18      	it	ne
    d69e:	ad1c      	addne	r5, sp, #112	; 0x70
        results[i].size=results[i].size/num_algorithms;
    d6a0:	f3c3 0880 	ubfx	r8, r3, #2, #1
    d6a4:	f003 0402 	and.w	r4, r3, #2
    d6a8:	4446      	add	r6, r8
    d6aa:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
                results[ctx].memblock[i+1]=(char *)(results[ctx].memblock[0])+results[0].size*j;
    d6ae:	bf18      	it	ne
    d6b0:	950e      	strne	r5, [sp, #56]	; 0x38
        results[i].size=results[i].size/num_algorithms;
    d6b2:	fbb0 f0f6 	udiv	r0, r0, r6
            j++;
    d6b6:	bf18      	it	ne
    d6b8:	2501      	movne	r5, #1
        results[i].size=results[i].size/num_algorithms;
    d6ba:	f003 0604 	and.w	r6, r3, #4
    d6be:	9011      	str	r0, [sp, #68]	; 0x44
        if ((1<<(ee_u32)i) & results[0].execs) {
    d6c0:	bf08      	it	eq
    d6c2:	460d      	moveq	r5, r1
    d6c4:	b134      	cbz	r4, d6d4 <main+0xb4>
                results[ctx].memblock[i+1]=(char *)(results[ctx].memblock[0])+results[0].size*j;
    d6c6:	f10d 0970 	add.w	r9, sp, #112	; 0x70
    d6ca:	fb00 9705 	mla	r7, r0, r5, r9
            j++;
    d6ce:	3501      	adds	r5, #1
                results[ctx].memblock[i+1]=(char *)(results[ctx].memblock[0])+results[0].size*j;
    d6d0:	970f      	str	r7, [sp, #60]	; 0x3c
            j++;
    d6d2:	b2ad      	uxth	r5, r5
        if ((1<<(ee_u32)i) & results[0].execs) {
    d6d4:	b126      	cbz	r6, d6e0 <main+0xc0>
                results[ctx].memblock[i+1]=(char *)(results[ctx].memblock[0])+results[0].size*j;
    d6d6:	f10d 0a70 	add.w	sl, sp, #112	; 0x70
    d6da:	fb00 a605 	mla	r6, r0, r5, sl
    d6de:	9610      	str	r6, [sp, #64]	; 0x40
        }
    }
    /* call inits */
    for (i=0 ; i<MULTITHREAD; i++) {
        if (results[i].execs & ID_LIST) {
    d6e0:	2900      	cmp	r1, #0
    d6e2:	f040 80ec 	bne.w	d8be <main+0x29e>
            results[i].list=core_list_init(results[0].size,results[i].memblock[1],results[i].seed1);
        }
        if (results[i].execs & ID_MATRIX) {
    d6e6:	2c00      	cmp	r4, #0
    d6e8:	f040 80f3 	bne.w	d8d2 <main+0x2b2>
            core_init_matrix(results[0].size, results[i].memblock[2], (ee_s32)results[i].seed1 | (((ee_s32)results[i].seed2) << 16), &(results[i].mat) );
        }
        if (results[i].execs & ID_STATE) {
    d6ec:	075a      	lsls	r2, r3, #29
    d6ee:	f100 80ff 	bmi.w	d8f0 <main+0x2d0>
            core_init_state(results[0].size,results[i].seed1,results[i].memblock[3]);
        }
    }

    /* automatically determine number of iterations if not set */
    if (results[0].iterations==0) {
    d6f2:	9812      	ldr	r0, [sp, #72]	; 0x48
    d6f4:	2800      	cmp	r0, #0
    d6f6:	f040 809f 	bne.w	d838 <main+0x218>
        secs_ret secs_passed=0;
        ee_u32 divisor;
        results[0].iterations=1;
    d6fa:	2201      	movs	r2, #1
        while (secs_passed < (secs_ret)1) {
    d6fc:	4fc8      	ldr	r7, [pc, #800]	; (da20 <main+0x400>)
        results[0].iterations=1;
    d6fe:	9212      	str	r2, [sp, #72]	; 0x48
        while (secs_passed < (secs_ret)1) {
    d700:	f04f 0a00 	mov.w	sl, #0
    res->crc=0;
    d704:	4681      	mov	r9, r0
            results[0].iterations*=10;
    d706:	9912      	ldr	r1, [sp, #72]	; 0x48
    d708:	eb01 0581 	add.w	r5, r1, r1, lsl #2
    d70c:	006e      	lsls	r6, r5, #1
    d70e:	9612      	str	r6, [sp, #72]	; 0x48
            start_time();
    d710:	f001 fbdc 	bl	eecc <start_time>
    ee_u32 iterations=res->iterations;
    d714:	f8dd 8048 	ldr.w	r8, [sp, #72]	; 0x48
    res->crc=0;
    d718:	f8cd 9064 	str.w	r9, [sp, #100]	; 0x64
    d71c:	f8cd 9068 	str.w	r9, [sp, #104]	; 0x68
    for (i=0; i<iterations; i++) {
    d720:	f1b8 0f00 	cmp.w	r8, #0
    d724:	d06b      	beq.n	d7fe <main+0x1de>
        crc=core_bench_list(res,1);
    d726:	2101      	movs	r1, #1
    d728:	f108 34ff 	add.w	r4, r8, #4294967295
    d72c:	a80b      	add	r0, sp, #44	; 0x2c
    d72e:	ea04 0501 	and.w	r5, r4, r1
    d732:	f7ff fb7d 	bl	ce30 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d736:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
    d73a:	f001 fed5 	bl	f4e8 <crcu16>
        crc=core_bench_list(res,-1);
    d73e:	f04f 31ff 	mov.w	r1, #4294967295
        res->crc=crcu16(crc,res->crc);
    d742:	f8ad 0064 	strh.w	r0, [sp, #100]	; 0x64
        crc=core_bench_list(res,-1);
    d746:	a80b      	add	r0, sp, #44	; 0x2c
    d748:	f7ff fb72 	bl	ce30 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d74c:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
    d750:	f001 feca 	bl	f4e8 <crcu16>
    for (i=0; i<iterations; i++) {
    d754:	2401      	movs	r4, #1
    d756:	45a0      	cmp	r8, r4
        res->crc=crcu16(crc,res->crc);
    d758:	f8ad 0064 	strh.w	r0, [sp, #100]	; 0x64
        if (i==0) res->crclist=res->crc;
    d75c:	f8ad 0066 	strh.w	r0, [sp, #102]	; 0x66
    for (i=0; i<iterations; i++) {
    d760:	d04d      	beq.n	d7fe <main+0x1de>
    d762:	b1bd      	cbz	r5, d794 <main+0x174>
        crc=core_bench_list(res,1);
    d764:	4621      	mov	r1, r4
    d766:	a80b      	add	r0, sp, #44	; 0x2c
    d768:	f7ff fb62 	bl	ce30 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d76c:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
    d770:	f001 feba 	bl	f4e8 <crcu16>
        crc=core_bench_list(res,-1);
    d774:	f04f 31ff 	mov.w	r1, #4294967295
        res->crc=crcu16(crc,res->crc);
    d778:	f8ad 0064 	strh.w	r0, [sp, #100]	; 0x64
        crc=core_bench_list(res,-1);
    d77c:	a80b      	add	r0, sp, #44	; 0x2c
    d77e:	f7ff fb57 	bl	ce30 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d782:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
    d786:	f001 feaf 	bl	f4e8 <crcu16>
    for (i=0; i<iterations; i++) {
    d78a:	3401      	adds	r4, #1
    d78c:	45a0      	cmp	r8, r4
        res->crc=crcu16(crc,res->crc);
    d78e:	f8ad 0064 	strh.w	r0, [sp, #100]	; 0x64
    for (i=0; i<iterations; i++) {
    d792:	d034      	beq.n	d7fe <main+0x1de>
        crc=core_bench_list(res,1);
    d794:	2101      	movs	r1, #1
    d796:	a80b      	add	r0, sp, #44	; 0x2c
    d798:	f7ff fb4a 	bl	ce30 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d79c:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
    d7a0:	f001 fea2 	bl	f4e8 <crcu16>
        crc=core_bench_list(res,-1);
    d7a4:	f04f 31ff 	mov.w	r1, #4294967295
        res->crc=crcu16(crc,res->crc);
    d7a8:	f8ad 0064 	strh.w	r0, [sp, #100]	; 0x64
        crc=core_bench_list(res,-1);
    d7ac:	a80b      	add	r0, sp, #44	; 0x2c
    d7ae:	f7ff fb3f 	bl	ce30 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d7b2:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
    d7b6:	f001 fe97 	bl	f4e8 <crcu16>
        crc=core_bench_list(res,1);
    d7ba:	2101      	movs	r1, #1
        res->crc=crcu16(crc,res->crc);
    d7bc:	4683      	mov	fp, r0
    for (i=0; i<iterations; i++) {
    d7be:	1866      	adds	r6, r4, r1
        crc=core_bench_list(res,1);
    d7c0:	a80b      	add	r0, sp, #44	; 0x2c
        res->crc=crcu16(crc,res->crc);
    d7c2:	f8ad b064 	strh.w	fp, [sp, #100]	; 0x64
        if (i==0) res->crclist=res->crc;
    d7c6:	2c00      	cmp	r4, #0
    d7c8:	f000 8295 	beq.w	dcf6 <main+0x6d6>
        crc=core_bench_list(res,1);
    d7cc:	f7ff fb30 	bl	ce30 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d7d0:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
    d7d4:	f001 fe88 	bl	f4e8 <crcu16>
        crc=core_bench_list(res,-1);
    d7d8:	f04f 31ff 	mov.w	r1, #4294967295
        res->crc=crcu16(crc,res->crc);
    d7dc:	f8ad 0064 	strh.w	r0, [sp, #100]	; 0x64
        crc=core_bench_list(res,-1);
    d7e0:	a80b      	add	r0, sp, #44	; 0x2c
    d7e2:	f7ff fb25 	bl	ce30 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d7e6:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
    d7ea:	f001 fe7d 	bl	f4e8 <crcu16>
    d7ee:	f8ad 0064 	strh.w	r0, [sp, #100]	; 0x64
        if (i==0) res->crclist=res->crc;
    d7f2:	2e00      	cmp	r6, #0
    d7f4:	f000 8282 	beq.w	dcfc <main+0x6dc>
    for (i=0; i<iterations; i++) {
    d7f8:	1c74      	adds	r4, r6, #1
    d7fa:	45a0      	cmp	r8, r4
    d7fc:	d1ca      	bne.n	d794 <main+0x174>
            iterate(&results[0]);
            stop_time();
    d7fe:	f001 fb7b 	bl	eef8 <stop_time>
            secs_passed=time_in_secs(get_time());
    d802:	f001 fb97 	bl	ef34 <get_time>
    d806:	f001 fb9f 	bl	ef48 <time_in_secs>
        while (secs_passed < (secs_ret)1) {
    d80a:	4652      	mov	r2, sl
    d80c:	463b      	mov	r3, r7
            secs_passed=time_in_secs(get_time());
    d80e:	4680      	mov	r8, r0
    d810:	460d      	mov	r5, r1
        while (secs_passed < (secs_ret)1) {
    d812:	f7ff f89f 	bl	c954 <__aeabi_dcmplt>
    d816:	2800      	cmp	r0, #0
    d818:	f47f af75 	bne.w	d706 <main+0xe6>
        }
        /* now we know it executes for at least 1 sec, set actual run time at about 10 secs */
        divisor=(ee_u32)secs_passed;
    d81c:	4640      	mov	r0, r8
    d81e:	4629      	mov	r1, r5
    d820:	f7ff f8c0 	bl	c9a4 <__aeabi_d2uiz>
        if (divisor==0) /* some machines cast float to int as 0 since this conversion is not defined by ANSI, but we know at least one second passed */
            divisor=1;
        results[0].iterations*=1+10/divisor;
    d824:	9b12      	ldr	r3, [sp, #72]	; 0x48
            divisor=1;
    d826:	2800      	cmp	r0, #0
    d828:	bf08      	it	eq
    d82a:	2001      	moveq	r0, #1
        results[0].iterations*=1+10/divisor;
    d82c:	270a      	movs	r7, #10
    d82e:	fbb7 f0f0 	udiv	r0, r7, r0
    d832:	fb00 3203 	mla	r2, r0, r3, r3
    d836:	9212      	str	r2, [sp, #72]	; 0x48
    }
    /* perform actual benchmark */
    start_time();
    d838:	f001 fb48 	bl	eecc <start_time>
    }
    for (i=0 ; i<default_num_contexts; i++) {
        core_stop_parallel(&results[i]);
    }
#else
    iterate(&results[0]);
    d83c:	a80b      	add	r0, sp, #44	; 0x2c
    d83e:	f7ff fe89 	bl	d554 <iterate>
#endif
    stop_time();
    d842:	f001 fb59 	bl	eef8 <stop_time>
    total_time=get_time();
    d846:	f001 fb75 	bl	ef34 <get_time>
    /* get a function of the input to report */
    seedcrc=crc16(results[0].seed1,seedcrc);
    d84a:	2100      	movs	r1, #0
    total_time=get_time();
    d84c:	4681      	mov	r9, r0
    seedcrc=crc16(results[0].seed1,seedcrc);
    d84e:	f9bd 002c 	ldrsh.w	r0, [sp, #44]	; 0x2c
    d852:	f002 f811 	bl	f878 <crc16>
    seedcrc=crc16(results[0].seed2,seedcrc);
    d856:	4601      	mov	r1, r0
    d858:	f9bd 002e 	ldrsh.w	r0, [sp, #46]	; 0x2e
    d85c:	f002 f80c 	bl	f878 <crc16>
    seedcrc=crc16(results[0].seed3,seedcrc);
    d860:	4601      	mov	r1, r0
    d862:	f9bd 0030 	ldrsh.w	r0, [sp, #48]	; 0x30
    d866:	f002 f807 	bl	f878 <crc16>
    seedcrc=crc16(results[0].size,seedcrc);
    d86a:	4601      	mov	r1, r0
    d86c:	f9bd 0044 	ldrsh.w	r0, [sp, #68]	; 0x44
    d870:	f002 f802 	bl	f878 <crc16>

    switch (seedcrc) { /* test known output for common seeds */
    d874:	f647 3605 	movw	r6, #31493	; 0x7b05
    d878:	42b0      	cmp	r0, r6
    seedcrc=crc16(results[0].size,seedcrc);
    d87a:	9005      	str	r0, [sp, #20]
    switch (seedcrc) { /* test known output for common seeds */
    d87c:	f000 8223 	beq.w	dcc6 <main+0x6a6>
    d880:	d840      	bhi.n	d904 <main+0x2e4>
    d882:	f641 04f2 	movw	r4, #6386	; 0x18f2
    d886:	42a0      	cmp	r0, r4
    d888:	f000 8209 	beq.w	dc9e <main+0x67e>
    d88c:	f644 65af 	movw	r5, #20143	; 0x4eaf
    d890:	42a8      	cmp	r0, r5
    d892:	f040 80d3 	bne.w	da3c <main+0x41c>
            ee_printf("6k validation run parameters for coremark.\n");
            break;
        case 0x4eaf: /* seed1=0x8, seed2=0x8, seed3=0x8, size 400 per algorithm */
            known_id=2;
            ee_printf("Profile generation run parameters for coremark.\n");
            break;
    d896:	f24e 54a4 	movw	r4, #58788	; 0xe5a4
    d89a:	f245 6508 	movw	r5, #22024	; 0x5608
    d89e:	f646 2679 	movw	r6, #27257	; 0x6a79
            ee_printf("Profile generation run parameters for coremark.\n");
    d8a2:	4860      	ldr	r0, [pc, #384]	; (da24 <main+0x404>)
            break;
    d8a4:	9404      	str	r4, [sp, #16]
    d8a6:	4627      	mov	r7, r4
    d8a8:	9503      	str	r5, [sp, #12]
    d8aa:	462c      	mov	r4, r5
    d8ac:	9602      	str	r6, [sp, #8]
            ee_printf("Profile generation run parameters for coremark.\n");
    d8ae:	f001 fbdb 	bl	f068 <am_sprintf>
            known_id=2;
    d8b2:	2302      	movs	r3, #2
            break;
    d8b4:	46bb      	mov	fp, r7
    d8b6:	46a2      	mov	sl, r4
    d8b8:	4630      	mov	r0, r6
            known_id=2;
    d8ba:	9307      	str	r3, [sp, #28]
            break;
    d8bc:	e040      	b.n	d940 <main+0x320>
            results[i].list=core_list_init(results[0].size,results[i].memblock[1],results[i].seed1);
    d8be:	990e      	ldr	r1, [sp, #56]	; 0x38
    d8c0:	f7ff fce0 	bl	d284 <core_list_init>
    d8c4:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    d8c6:	9014      	str	r0, [sp, #80]	; 0x50
    d8c8:	f003 0402 	and.w	r4, r3, #2
        if (results[i].execs & ID_MATRIX) {
    d8cc:	2c00      	cmp	r4, #0
    d8ce:	f43f af0d 	beq.w	d6ec <main+0xcc>
            core_init_matrix(results[0].size, results[i].memblock[2], (ee_s32)results[i].seed1 | (((ee_s32)results[i].seed2) << 16), &(results[i].mat) );
    d8d2:	f9bd b02e 	ldrsh.w	fp, [sp, #46]	; 0x2e
    d8d6:	f9bd c02c 	ldrsh.w	ip, [sp, #44]	; 0x2c
    d8da:	990f      	ldr	r1, [sp, #60]	; 0x3c
    d8dc:	9811      	ldr	r0, [sp, #68]	; 0x44
    d8de:	ea4c 420b 	orr.w	r2, ip, fp, lsl #16
    d8e2:	ab15      	add	r3, sp, #84	; 0x54
    d8e4:	f001 f9ce 	bl	ec84 <core_init_matrix>
    d8e8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
        if (results[i].execs & ID_STATE) {
    d8ea:	075a      	lsls	r2, r3, #29
    d8ec:	f57f af01 	bpl.w	d6f2 <main+0xd2>
            core_init_state(results[0].size,results[i].seed1,results[i].memblock[3]);
    d8f0:	9a10      	ldr	r2, [sp, #64]	; 0x40
    d8f2:	f9bd 102c 	ldrsh.w	r1, [sp, #44]	; 0x2c
    d8f6:	9811      	ldr	r0, [sp, #68]	; 0x44
    d8f8:	f001 fbf8 	bl	f0ec <core_init_state>
    d8fc:	e6f9      	b.n	d6f2 <main+0xd2>
        results[0].execs=ALL_ALGORITHMS_MASK;
    d8fe:	2007      	movs	r0, #7
    d900:	9013      	str	r0, [sp, #76]	; 0x4c
    d902:	e6b3      	b.n	d66c <main+0x4c>
    switch (seedcrc) { /* test known output for common seeds */
    d904:	9a05      	ldr	r2, [sp, #20]
    d906:	f648 2e02 	movw	lr, #35330	; 0x8a02
    d90a:	4572      	cmp	r2, lr
    d90c:	f000 81b3 	beq.w	dc76 <main+0x656>
    d910:	f64e 1cf5 	movw	ip, #59893	; 0xe9f5
    d914:	4562      	cmp	r2, ip
    d916:	f040 8091 	bne.w	da3c <main+0x41c>
        case 0xe9f5: /* seed1=0, seed2=0, seed3=0x66, size 666 per algorithm */
            known_id=3;
            ee_printf("2K performance run parameters for coremark.\n");
            break;
    d91a:	f648 643a 	movw	r4, #36410	; 0x8e3a
    d91e:	f641 75d7 	movw	r5, #8151	; 0x1fd7
    d922:	f24e 7614 	movw	r6, #59156	; 0xe714
            ee_printf("2K performance run parameters for coremark.\n");
    d926:	4840      	ldr	r0, [pc, #256]	; (da28 <main+0x408>)
            break;
    d928:	9404      	str	r4, [sp, #16]
    d92a:	4627      	mov	r7, r4
    d92c:	9503      	str	r5, [sp, #12]
    d92e:	462c      	mov	r4, r5
    d930:	9602      	str	r6, [sp, #8]
            ee_printf("2K performance run parameters for coremark.\n");
    d932:	f001 fb99 	bl	f068 <am_sprintf>
            known_id=3;
    d936:	2303      	movs	r3, #3
            break;
    d938:	46bb      	mov	fp, r7
    d93a:	46a2      	mov	sl, r4
    d93c:	4630      	mov	r0, r6
            known_id=3;
    d93e:	9307      	str	r3, [sp, #28]
        default:
            total_errors=-1;
            break;
    }
    if (known_id>=0) {
        for (i=0 ; i<default_num_contexts; i++) {
    d940:	f8df 80f4 	ldr.w	r8, [pc, #244]	; da38 <main+0x418>
    d944:	f8d8 6000 	ldr.w	r6, [r8]
    d948:	2e00      	cmp	r6, #0
    d94a:	d07c      	beq.n	da46 <main+0x426>
    d94c:	2600      	movs	r6, #0
    d94e:	f8cd 9018 	str.w	r9, [sp, #24]
    d952:	4634      	mov	r4, r6
    d954:	4681      	mov	r9, r0
    d956:	e016      	b.n	d986 <main+0x366>
                (results[i].crcmatrix!=matrix_known_crc[known_id])) {
                ee_printf("[%u]ERROR! matrix crc 0x%04x - should be 0x%04x\n",i,results[i].crcmatrix,matrix_known_crc[known_id]);
                results[i].err++;
            }
            if ((results[i].execs & ID_STATE) &&
                (results[i].crcstate!=state_known_crc[known_id])) {
    d958:	8fea      	ldrh	r2, [r5, #62]	; 0x3e
            if ((results[i].execs & ID_STATE) &&
    d95a:	455a      	cmp	r2, fp
    d95c:	d04a      	beq.n	d9f4 <main+0x3d4>
                ee_printf("[%u]ERROR! state crc 0x%04x - should be 0x%04x\n",i,results[i].crcstate,state_known_crc[known_id]);
    d95e:	9b04      	ldr	r3, [sp, #16]
    d960:	4832      	ldr	r0, [pc, #200]	; (da2c <main+0x40c>)
    d962:	4621      	mov	r1, r4
    d964:	f001 fb80 	bl	f068 <am_sprintf>
                results[i].err++;
    d968:	f8b5 2040 	ldrh.w	r2, [r5, #64]	; 0x40
    d96c:	3201      	adds	r2, #1
    d96e:	b210      	sxth	r0, r2
    d970:	f8a5 0040 	strh.w	r0, [r5, #64]	; 0x40
        for (i=0 ; i<default_num_contexts; i++) {
    d974:	3401      	adds	r4, #1
    d976:	f8d8 7000 	ldr.w	r7, [r8]
    d97a:	b2a4      	uxth	r4, r4
            }
            total_errors+=results[i].err;
    d97c:	4406      	add	r6, r0
        for (i=0 ; i<default_num_contexts; i++) {
    d97e:	42bc      	cmp	r4, r7
            total_errors+=results[i].err;
    d980:	b236      	sxth	r6, r6
        for (i=0 ; i<default_num_contexts; i++) {
    d982:	f080 8146 	bcs.w	dc12 <main+0x5f2>
            results[i].err=0;
    d986:	0125      	lsls	r5, r4, #4
    d988:	1928      	adds	r0, r5, r4
    d98a:	f10d 0e2c 	add.w	lr, sp, #44	; 0x2c
    d98e:	eb0e 0780 	add.w	r7, lr, r0, lsl #2
    d992:	2100      	movs	r1, #0
            if ((results[i].execs & ID_LIST) &&
    d994:	6a3a      	ldr	r2, [r7, #32]
            results[i].err=0;
    d996:	f8a7 1040 	strh.w	r1, [r7, #64]	; 0x40
            if ((results[i].execs & ID_LIST) &&
    d99a:	07d3      	lsls	r3, r2, #31
    d99c:	d50c      	bpl.n	d9b8 <main+0x398>
                (results[i].crclist!=list_known_crc[known_id])) {
    d99e:	8f7a      	ldrh	r2, [r7, #58]	; 0x3a
            if ((results[i].execs & ID_LIST) &&
    d9a0:	454a      	cmp	r2, r9
    d9a2:	d009      	beq.n	d9b8 <main+0x398>
                ee_printf("[%u]ERROR! list crc 0x%04x - should be 0x%04x\n",i,results[i].crclist,list_known_crc[known_id]);
    d9a4:	9b02      	ldr	r3, [sp, #8]
    d9a6:	4822      	ldr	r0, [pc, #136]	; (da30 <main+0x410>)
    d9a8:	4621      	mov	r1, r4
    d9aa:	f001 fb5d 	bl	f068 <am_sprintf>
                results[i].err++;
    d9ae:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
    d9b2:	3301      	adds	r3, #1
    d9b4:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
            if ((results[i].execs & ID_MATRIX) &&
    d9b8:	1928      	adds	r0, r5, r4
    d9ba:	f10d 0c2c 	add.w	ip, sp, #44	; 0x2c
    d9be:	eb0c 0780 	add.w	r7, ip, r0, lsl #2
    d9c2:	6a3b      	ldr	r3, [r7, #32]
    d9c4:	0798      	lsls	r0, r3, #30
    d9c6:	d50d      	bpl.n	d9e4 <main+0x3c4>
                (results[i].crcmatrix!=matrix_known_crc[known_id])) {
    d9c8:	8fba      	ldrh	r2, [r7, #60]	; 0x3c
            if ((results[i].execs & ID_MATRIX) &&
    d9ca:	4552      	cmp	r2, sl
    d9cc:	d00a      	beq.n	d9e4 <main+0x3c4>
                ee_printf("[%u]ERROR! matrix crc 0x%04x - should be 0x%04x\n",i,results[i].crcmatrix,matrix_known_crc[known_id]);
    d9ce:	9b03      	ldr	r3, [sp, #12]
    d9d0:	4818      	ldr	r0, [pc, #96]	; (da34 <main+0x414>)
    d9d2:	4621      	mov	r1, r4
    d9d4:	f001 fb48 	bl	f068 <am_sprintf>
                results[i].err++;
    d9d8:	f8b7 1040 	ldrh.w	r1, [r7, #64]	; 0x40
    d9dc:	6a3b      	ldr	r3, [r7, #32]
    d9de:	3101      	adds	r1, #1
    d9e0:	f8a7 1040 	strh.w	r1, [r7, #64]	; 0x40
                (results[i].crcstate!=state_known_crc[known_id])) {
    d9e4:	4425      	add	r5, r4
    d9e6:	f10d 0e2c 	add.w	lr, sp, #44	; 0x2c
            if ((results[i].execs & ID_STATE) &&
    d9ea:	f013 0f04 	tst.w	r3, #4
                (results[i].crcstate!=state_known_crc[known_id])) {
    d9ee:	eb0e 0585 	add.w	r5, lr, r5, lsl #2
            if ((results[i].execs & ID_STATE) &&
    d9f2:	d1b1      	bne.n	d958 <main+0x338>
    d9f4:	f9b5 0040 	ldrsh.w	r0, [r5, #64]	; 0x40
    d9f8:	e7bc      	b.n	d974 <main+0x354>
    if ((results[0].seed1==1) && (results[0].seed2==0) && (results[0].seed3==0)) { /* perfromance run */
    d9fa:	2901      	cmp	r1, #1
    d9fc:	f47f ae3f 	bne.w	d67e <main+0x5e>
    da00:	f9bd 2030 	ldrsh.w	r2, [sp, #48]	; 0x30
    da04:	2a00      	cmp	r2, #0
    da06:	f47f ae3a 	bne.w	d67e <main+0x5e>
        results[0].seed1=0x3415;
    da0a:	f243 4415 	movw	r4, #13333	; 0x3415
        results[0].seed3=0x66;
    da0e:	2566      	movs	r5, #102	; 0x66
        results[0].seed1=0x3415;
    da10:	f8ad 402c 	strh.w	r4, [sp, #44]	; 0x2c
        results[0].seed2=0x3415;
    da14:	f8ad 402e 	strh.w	r4, [sp, #46]	; 0x2e
        results[0].seed3=0x66;
    da18:	f8ad 5030 	strh.w	r5, [sp, #48]	; 0x30
    da1c:	e62f      	b.n	d67e <main+0x5e>
    da1e:	bf00      	nop
    da20:	3ff00000 	.word	0x3ff00000
    da24:	00012d70 	.word	0x00012d70
    da28:	00012da4 	.word	0x00012da4
    da2c:	00012e64 	.word	0x00012e64
    da30:	00012e00 	.word	0x00012e00
    da34:	00012e30 	.word	0x00012e30
    da38:	10001000 	.word	0x10001000
    ee_s16 known_id=-1,total_errors=0;
    da3c:	f04f 36ff 	mov.w	r6, #4294967295
    da40:	f8df 8330 	ldr.w	r8, [pc, #816]	; dd74 <main+0x754>
    da44:	9607      	str	r6, [sp, #28]
        }
    }
    total_errors+=check_data_types();
    da46:	f001 ffb1 	bl	f9ac <check_data_types>
    /* and report results */
    ee_printf("CoreMark Size    : %lu\n",(ee_u32)results[0].size);
    da4a:	9911      	ldr	r1, [sp, #68]	; 0x44
    total_errors+=check_data_types();
    da4c:	4406      	add	r6, r0
    ee_printf("CoreMark Size    : %lu\n",(ee_u32)results[0].size);
    da4e:	48ad      	ldr	r0, [pc, #692]	; (dd04 <main+0x6e4>)
    da50:	f001 fb0a 	bl	f068 <am_sprintf>
    ee_printf("Total ticks      : %llu\n",(ee_u64)total_time);
    da54:	464a      	mov	r2, r9
    da56:	2300      	movs	r3, #0
    da58:	48ab      	ldr	r0, [pc, #684]	; (dd08 <main+0x6e8>)
    da5a:	f001 fb05 	bl	f068 <am_sprintf>
#if HAS_FLOAT
    ee_printf("Total time (secs): %f\n",time_in_secs(total_time));
    da5e:	4648      	mov	r0, r9
    da60:	f001 fa72 	bl	ef48 <time_in_secs>
    da64:	4602      	mov	r2, r0
    da66:	460b      	mov	r3, r1
    da68:	48a8      	ldr	r0, [pc, #672]	; (dd0c <main+0x6ec>)
    da6a:	f001 fafd 	bl	f068 <am_sprintf>
    if (time_in_secs(total_time) > 0)
    da6e:	4648      	mov	r0, r9
    da70:	f001 fa6a 	bl	ef48 <time_in_secs>
    da74:	2200      	movs	r2, #0
    da76:	2300      	movs	r3, #0
    total_errors+=check_data_types();
    da78:	b2b6      	uxth	r6, r6
    if (time_in_secs(total_time) > 0)
    da7a:	f7fe ff89 	bl	c990 <__aeabi_dcmpgt>
    da7e:	b1b0      	cbz	r0, daae <main+0x48e>
        ee_printf("Iterations/Sec   : %f\n",default_num_contexts*results[0].iterations/time_in_secs(total_time));
    da80:	9912      	ldr	r1, [sp, #72]	; 0x48
    da82:	f8d8 0000 	ldr.w	r0, [r8]
    da86:	fb00 f001 	mul.w	r0, r0, r1
    da8a:	f7fe fc7b 	bl	c384 <__aeabi_ui2d>
    da8e:	4683      	mov	fp, r0
    da90:	4648      	mov	r0, r9
    da92:	468a      	mov	sl, r1
    da94:	f001 fa58 	bl	ef48 <time_in_secs>
    da98:	4602      	mov	r2, r0
    da9a:	460b      	mov	r3, r1
    da9c:	4658      	mov	r0, fp
    da9e:	4651      	mov	r1, sl
    daa0:	f7fe fe10 	bl	c6c4 <__aeabi_ddiv>
    daa4:	4602      	mov	r2, r0
    daa6:	460b      	mov	r3, r1
    daa8:	4899      	ldr	r0, [pc, #612]	; (dd10 <main+0x6f0>)
    daaa:	f001 fadd 	bl	f068 <am_sprintf>
#else
    ee_printf("Total time (secs): %d\n",time_in_secs(total_time));
    if (time_in_secs(total_time) > 0)
        ee_printf("Iterations/Sec   : %d\n",default_num_contexts*results[0].iterations/time_in_secs(total_time));
#endif
    if (time_in_secs(total_time) < 10) {
    daae:	4648      	mov	r0, r9
    dab0:	f001 fa4a 	bl	ef48 <time_in_secs>
    dab4:	2200      	movs	r2, #0
    dab6:	4b97      	ldr	r3, [pc, #604]	; (dd14 <main+0x6f4>)
    dab8:	f7fe ff4c 	bl	c954 <__aeabi_dcmplt>
    dabc:	2800      	cmp	r0, #0
    dabe:	f040 80ab 	bne.w	dc18 <main+0x5f8>
    total_errors+=check_data_types();
    dac2:	b235      	sxth	r5, r6
        ee_printf("ERROR! Must execute for at least 10 secs for a valid result!\n");
        total_errors++;
    }

    ee_printf("Iterations       : %lu\n",(ee_u32)default_num_contexts*results[0].iterations);
    dac4:	9a12      	ldr	r2, [sp, #72]	; 0x48
    dac6:	f8d8 1000 	ldr.w	r1, [r8]
    daca:	4893      	ldr	r0, [pc, #588]	; (dd18 <main+0x6f8>)
    dacc:	fb01 f102 	mul.w	r1, r1, r2
    dad0:	f001 faca 	bl	f068 <am_sprintf>
    ee_printf("Compiler version : %s\n",COMPILER_VERSION);
    dad4:	4991      	ldr	r1, [pc, #580]	; (dd1c <main+0x6fc>)
    dad6:	4892      	ldr	r0, [pc, #584]	; (dd20 <main+0x700>)
    dad8:	f001 fac6 	bl	f068 <am_sprintf>
//  ee_printf("Compiler flags   : %s\n",COMPILER_FLAGS);
#if (MULTITHREAD>1)
    ee_printf("Parallel %s : %d\n",PARALLEL_METHOD,default_num_contexts);
#endif
    ee_printf("Memory location  : %s\n",MEM_LOCATION);
    dadc:	4991      	ldr	r1, [pc, #580]	; (dd24 <main+0x704>)
    dade:	4892      	ldr	r0, [pc, #584]	; (dd28 <main+0x708>)
    dae0:	f001 fac2 	bl	f068 <am_sprintf>
    /* output for verification */
    ee_printf("seedcrc          : 0x%04x\n",seedcrc);
    dae4:	9905      	ldr	r1, [sp, #20]
    dae6:	4891      	ldr	r0, [pc, #580]	; (dd2c <main+0x70c>)
    dae8:	f001 fabe 	bl	f068 <am_sprintf>
    if (results[0].execs & ID_LIST)
    daec:	9f13      	ldr	r7, [sp, #76]	; 0x4c
    daee:	07f9      	lsls	r1, r7, #31
    daf0:	d516      	bpl.n	db20 <main+0x500>
        for (i=0 ; i<default_num_contexts; i++)
    daf2:	f8d8 4000 	ldr.w	r4, [r8]
    daf6:	b19c      	cbz	r4, db20 <main+0x500>
            ee_printf("[%d]crclist       : 0x%04x\n",i,results[i].crclist);
    daf8:	4e8d      	ldr	r6, [pc, #564]	; (dd30 <main+0x710>)
        for (i=0 ; i<default_num_contexts; i++)
    dafa:	2700      	movs	r7, #0
            ee_printf("[%d]crclist       : 0x%04x\n",i,results[i].crclist);
    dafc:	eb07 1007 	add.w	r0, r7, r7, lsl #4
    db00:	f10d 0c2c 	add.w	ip, sp, #44	; 0x2c
    db04:	eb0c 0e80 	add.w	lr, ip, r0, lsl #2
    db08:	4639      	mov	r1, r7
    db0a:	f8be 203a 	ldrh.w	r2, [lr, #58]	; 0x3a
    db0e:	4630      	mov	r0, r6
    db10:	f001 faaa 	bl	f068 <am_sprintf>
        for (i=0 ; i<default_num_contexts; i++)
    db14:	3701      	adds	r7, #1
    db16:	f8d8 1000 	ldr.w	r1, [r8]
    db1a:	b2bf      	uxth	r7, r7
    db1c:	428f      	cmp	r7, r1
    db1e:	d3ed      	bcc.n	dafc <main+0x4dc>
    if (results[0].execs & ID_MATRIX)
    db20:	9f13      	ldr	r7, [sp, #76]	; 0x4c
    db22:	07ba      	lsls	r2, r7, #30
    db24:	d518      	bpl.n	db58 <main+0x538>
        for (i=0 ; i<default_num_contexts; i++)
    db26:	f8d8 2000 	ldr.w	r2, [r8]
    db2a:	2a00      	cmp	r2, #0
    db2c:	f000 80df 	beq.w	dcee <main+0x6ce>
            ee_printf("[%d]crcmatrix     : 0x%04x\n",i,results[i].crcmatrix);
    db30:	4e80      	ldr	r6, [pc, #512]	; (dd34 <main+0x714>)
        for (i=0 ; i<default_num_contexts; i++)
    db32:	2400      	movs	r4, #0
            ee_printf("[%d]crcmatrix     : 0x%04x\n",i,results[i].crcmatrix);
    db34:	eb04 1b04 	add.w	fp, r4, r4, lsl #4
    db38:	f10d 0a2c 	add.w	sl, sp, #44	; 0x2c
    db3c:	eb0a 038b 	add.w	r3, sl, fp, lsl #2
    db40:	4621      	mov	r1, r4
    db42:	8f9a      	ldrh	r2, [r3, #60]	; 0x3c
    db44:	4630      	mov	r0, r6
    db46:	f001 fa8f 	bl	f068 <am_sprintf>
        for (i=0 ; i<default_num_contexts; i++)
    db4a:	3401      	adds	r4, #1
    db4c:	f8d8 1000 	ldr.w	r1, [r8]
    db50:	b2a4      	uxth	r4, r4
    db52:	428c      	cmp	r4, r1
    db54:	d3ee      	bcc.n	db34 <main+0x514>
    db56:	9f13      	ldr	r7, [sp, #76]	; 0x4c
    if (results[0].execs & ID_STATE)
        for (i=0 ; i<default_num_contexts; i++)
    db58:	f8d8 2000 	ldr.w	r2, [r8]
    if (results[0].execs & ID_STATE)
    db5c:	f017 0f04 	tst.w	r7, #4
    db60:	d014      	beq.n	db8c <main+0x56c>
        for (i=0 ; i<default_num_contexts; i++)
    db62:	b33a      	cbz	r2, dbb4 <main+0x594>
            ee_printf("[%d]crcstate      : 0x%04x\n",i,results[i].crcstate);
    db64:	4e74      	ldr	r6, [pc, #464]	; (dd38 <main+0x718>)
        for (i=0 ; i<default_num_contexts; i++)
    db66:	2400      	movs	r4, #0
            ee_printf("[%d]crcstate      : 0x%04x\n",i,results[i].crcstate);
    db68:	eb04 1004 	add.w	r0, r4, r4, lsl #4
    db6c:	f10d 0c2c 	add.w	ip, sp, #44	; 0x2c
    db70:	eb0c 0e80 	add.w	lr, ip, r0, lsl #2
    db74:	4621      	mov	r1, r4
    db76:	f8be 203e 	ldrh.w	r2, [lr, #62]	; 0x3e
    db7a:	4630      	mov	r0, r6
    db7c:	f001 fa74 	bl	f068 <am_sprintf>
        for (i=0 ; i<default_num_contexts; i++)
    db80:	3401      	adds	r4, #1
    db82:	f8d8 2000 	ldr.w	r2, [r8]
    db86:	b2a4      	uxth	r4, r4
    db88:	4294      	cmp	r4, r2
    db8a:	d3ed      	bcc.n	db68 <main+0x548>
    for (i=0 ; i<default_num_contexts; i++)
    db8c:	b192      	cbz	r2, dbb4 <main+0x594>
        ee_printf("[%d]crcfinal      : 0x%04x\n",i,results[i].crc);
    db8e:	4f6b      	ldr	r7, [pc, #428]	; (dd3c <main+0x71c>)
    for (i=0 ; i<default_num_contexts; i++)
    db90:	2600      	movs	r6, #0
        ee_printf("[%d]crcfinal      : 0x%04x\n",i,results[i].crc);
    db92:	eb06 1b06 	add.w	fp, r6, r6, lsl #4
    db96:	aa0b      	add	r2, sp, #44	; 0x2c
    db98:	eb02 0a8b 	add.w	sl, r2, fp, lsl #2
    db9c:	4631      	mov	r1, r6
    db9e:	f8ba 2038 	ldrh.w	r2, [sl, #56]	; 0x38
    dba2:	4638      	mov	r0, r7
    dba4:	f001 fa60 	bl	f068 <am_sprintf>
    for (i=0 ; i<default_num_contexts; i++)
    dba8:	3601      	adds	r6, #1
    dbaa:	f8d8 3000 	ldr.w	r3, [r8]
    dbae:	b2b6      	uxth	r6, r6
    dbb0:	429e      	cmp	r6, r3
    dbb2:	d3ee      	bcc.n	db92 <main+0x572>
    if (total_errors==0) {
    dbb4:	2d00      	cmp	r5, #0
    dbb6:	d035      	beq.n	dc24 <main+0x604>
            ee_printf("\n");
        }
#endif
    }
    if (total_errors>0)
        ee_printf("Errors detected\n");
    dbb8:	bfcc      	ite	gt
    dbba:	4861      	ldrgt	r0, [pc, #388]	; (dd40 <main+0x720>)
    if (total_errors<0)
        ee_printf("Cannot validate operation for these seed values, please compare with results on a known platform.\n");
    dbbc:	4861      	ldrle	r0, [pc, #388]	; (dd44 <main+0x724>)
    dbbe:	f001 fa53 	bl	f068 <am_sprintf>
        portable_free(results[i].memblock[0]);
#endif


#if AM_PRINT_RESULTS
    float CMResult = default_num_contexts*results[0].iterations/time_in_secs(total_time) / (double)AM_CORECLK_MHZ;
    dbc2:	9b12      	ldr	r3, [sp, #72]	; 0x48
    dbc4:	f8d8 0000 	ldr.w	r0, [r8]
    dbc8:	fb00 f003 	mul.w	r0, r0, r3
    dbcc:	f7fe fbda 	bl	c384 <__aeabi_ui2d>
    dbd0:	4680      	mov	r8, r0
    dbd2:	4648      	mov	r0, r9
    dbd4:	468b      	mov	fp, r1
    dbd6:	f001 f9b7 	bl	ef48 <time_in_secs>
    dbda:	4602      	mov	r2, r0
    dbdc:	460b      	mov	r3, r1
    dbde:	4640      	mov	r0, r8
    dbe0:	4659      	mov	r1, fp
    dbe2:	f7fe fd6f 	bl	c6c4 <__aeabi_ddiv>
    dbe6:	2200      	movs	r2, #0
    dbe8:	4b57      	ldr	r3, [pc, #348]	; (dd48 <main+0x728>)
    dbea:	f7fe fd6b 	bl	c6c4 <__aeabi_ddiv>
    dbee:	f7fe fef9 	bl	c9e4 <__aeabi_d2f>
    ee_printf("CM/MHz=%.3f.\n", CMResult);
    dbf2:	f7fe fbe9 	bl	c3c8 <__aeabi_f2d>
    dbf6:	4602      	mov	r2, r0
    dbf8:	460b      	mov	r3, r1
    dbfa:	4854      	ldr	r0, [pc, #336]	; (dd4c <main+0x72c>)
    dbfc:	f001 fa34 	bl	f068 <am_sprintf>

#endif //AM_PRINT_RESULTS

    /* And last call any target specific code for finalizing */
    portable_fini(&(results[0].port));
    dc00:	f10d 006e 	add.w	r0, sp, #110	; 0x6e
    dc04:	f001 f9f0 	bl	efe8 <portable_fini>

    return MAIN_RETURN_VAL;
}
    dc08:	2000      	movs	r0, #0
    dc0a:	f60d 0d44 	addw	sp, sp, #2116	; 0x844
    dc0e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    dc12:	f8dd 9018 	ldr.w	r9, [sp, #24]
    dc16:	e716      	b.n	da46 <main+0x426>
        ee_printf("ERROR! Must execute for at least 10 secs for a valid result!\n");
    dc18:	484d      	ldr	r0, [pc, #308]	; (dd50 <main+0x730>)
    dc1a:	f001 fa25 	bl	f068 <am_sprintf>
        total_errors++;
    dc1e:	1c73      	adds	r3, r6, #1
    dc20:	b21d      	sxth	r5, r3
    dc22:	e74f      	b.n	dac4 <main+0x4a4>
        ee_printf("Correct operation validated. See readme.txt for run and reporting rules.\n");
    dc24:	484b      	ldr	r0, [pc, #300]	; (dd54 <main+0x734>)
    dc26:	f001 fa1f 	bl	f068 <am_sprintf>
        if (known_id==3) {
    dc2a:	9d07      	ldr	r5, [sp, #28]
    dc2c:	2d03      	cmp	r5, #3
    dc2e:	d1c8      	bne.n	dbc2 <main+0x5a2>
            ee_printf("CoreMark 1.0 : %f / %s %s",default_num_contexts*results[0].iterations/time_in_secs(total_time),COMPILER_VERSION,COMPILER_FLAGS);
    dc30:	9912      	ldr	r1, [sp, #72]	; 0x48
    dc32:	f8d8 0000 	ldr.w	r0, [r8]
    dc36:	4e39      	ldr	r6, [pc, #228]	; (dd1c <main+0x6fc>)
    dc38:	fb00 f001 	mul.w	r0, r0, r1
    dc3c:	f7fe fba2 	bl	c384 <__aeabi_ui2d>
    dc40:	4604      	mov	r4, r0
    dc42:	4648      	mov	r0, r9
    dc44:	460f      	mov	r7, r1
    dc46:	f001 f97f 	bl	ef48 <time_in_secs>
    dc4a:	4602      	mov	r2, r0
    dc4c:	460b      	mov	r3, r1
    dc4e:	4620      	mov	r0, r4
    dc50:	4639      	mov	r1, r7
    dc52:	f7fe fd37 	bl	c6c4 <__aeabi_ddiv>
    dc56:	4a40      	ldr	r2, [pc, #256]	; (dd58 <main+0x738>)
    dc58:	9201      	str	r2, [sp, #4]
    dc5a:	460b      	mov	r3, r1
    dc5c:	4602      	mov	r2, r0
    dc5e:	9600      	str	r6, [sp, #0]
    dc60:	483e      	ldr	r0, [pc, #248]	; (dd5c <main+0x73c>)
    dc62:	f001 fa01 	bl	f068 <am_sprintf>
            ee_printf(" / %s",MEM_LOCATION);
    dc66:	492f      	ldr	r1, [pc, #188]	; (dd24 <main+0x704>)
    dc68:	483d      	ldr	r0, [pc, #244]	; (dd60 <main+0x740>)
    dc6a:	f001 f9fd 	bl	f068 <am_sprintf>
            ee_printf("\n");
    dc6e:	483d      	ldr	r0, [pc, #244]	; (dd64 <main+0x744>)
    dc70:	f001 f9fa 	bl	f068 <am_sprintf>
    dc74:	e7a5      	b.n	dbc2 <main+0x5a2>
            break;
    dc76:	f645 6447 	movw	r4, #24135	; 0x5e47
    dc7a:	f64b 6552 	movw	r5, #48722	; 0xbe52
    dc7e:	f24d 46b0 	movw	r6, #54448	; 0xd4b0
            ee_printf("6k performance run parameters for coremark.\n");
    dc82:	4839      	ldr	r0, [pc, #228]	; (dd68 <main+0x748>)
            break;
    dc84:	9404      	str	r4, [sp, #16]
    dc86:	4627      	mov	r7, r4
    dc88:	9503      	str	r5, [sp, #12]
    dc8a:	462c      	mov	r4, r5
    dc8c:	9602      	str	r6, [sp, #8]
            ee_printf("6k performance run parameters for coremark.\n");
    dc8e:	f001 f9eb 	bl	f068 <am_sprintf>
            known_id=0;
    dc92:	2100      	movs	r1, #0
            break;
    dc94:	46bb      	mov	fp, r7
    dc96:	46a2      	mov	sl, r4
    dc98:	4630      	mov	r0, r6
            known_id=0;
    dc9a:	9107      	str	r1, [sp, #28]
            break;
    dc9c:	e650      	b.n	d940 <main+0x320>
            break;
    dc9e:	f648 5484 	movw	r4, #36228	; 0x8d84
    dca2:	f240 7547 	movw	r5, #1863	; 0x747
    dca6:	f24e 36c1 	movw	r6, #58305	; 0xe3c1
            ee_printf("2K validation run parameters for coremark.\n");
    dcaa:	4830      	ldr	r0, [pc, #192]	; (dd6c <main+0x74c>)
            break;
    dcac:	9404      	str	r4, [sp, #16]
    dcae:	4627      	mov	r7, r4
    dcb0:	9503      	str	r5, [sp, #12]
    dcb2:	462c      	mov	r4, r5
    dcb4:	9602      	str	r6, [sp, #8]
            ee_printf("2K validation run parameters for coremark.\n");
    dcb6:	f001 f9d7 	bl	f068 <am_sprintf>
            known_id=4;
    dcba:	2104      	movs	r1, #4
            break;
    dcbc:	46bb      	mov	fp, r7
    dcbe:	46a2      	mov	sl, r4
    dcc0:	4630      	mov	r0, r6
            known_id=4;
    dcc2:	9107      	str	r1, [sp, #28]
            break;
    dcc4:	e63c      	b.n	d940 <main+0x320>
            break;
    dcc6:	f643 14bf 	movw	r4, #14783	; 0x39bf
    dcca:	f241 1599 	movw	r5, #4505	; 0x1199
    dcce:	f44f 564d 	mov.w	r6, #13120	; 0x3340
            ee_printf("6k validation run parameters for coremark.\n");
    dcd2:	4827      	ldr	r0, [pc, #156]	; (dd70 <main+0x750>)
            break;
    dcd4:	9404      	str	r4, [sp, #16]
    dcd6:	4627      	mov	r7, r4
    dcd8:	9503      	str	r5, [sp, #12]
    dcda:	462c      	mov	r4, r5
    dcdc:	9602      	str	r6, [sp, #8]
            ee_printf("6k validation run parameters for coremark.\n");
    dcde:	f001 f9c3 	bl	f068 <am_sprintf>
            known_id=1;
    dce2:	2301      	movs	r3, #1
            break;
    dce4:	46bb      	mov	fp, r7
    dce6:	46a2      	mov	sl, r4
    dce8:	4630      	mov	r0, r6
            known_id=1;
    dcea:	9307      	str	r3, [sp, #28]
            break;
    dcec:	e628      	b.n	d940 <main+0x320>
    if (results[0].execs & ID_STATE)
    dcee:	077b      	lsls	r3, r7, #29
    dcf0:	f53f af60 	bmi.w	dbb4 <main+0x594>
    dcf4:	e74a      	b.n	db8c <main+0x56c>
        if (i==0) res->crclist=res->crc;
    dcf6:	f8ad b066 	strh.w	fp, [sp, #102]	; 0x66
    dcfa:	e567      	b.n	d7cc <main+0x1ac>
    dcfc:	f8ad 0066 	strh.w	r0, [sp, #102]	; 0x66
    dd00:	e57a      	b.n	d7f8 <main+0x1d8>
    dd02:	bf00      	nop
    dd04:	00012e94 	.word	0x00012e94
    dd08:	00012eac 	.word	0x00012eac
    dd0c:	00012ec8 	.word	0x00012ec8
    dd10:	00012ee0 	.word	0x00012ee0
    dd14:	40240000 	.word	0x40240000
    dd18:	00012f38 	.word	0x00012f38
    dd1c:	00012f50 	.word	0x00012f50
    dd20:	00012f98 	.word	0x00012f98
    dd24:	00012fb0 	.word	0x00012fb0
    dd28:	00012fb8 	.word	0x00012fb8
    dd2c:	00012fd0 	.word	0x00012fd0
    dd30:	00012fec 	.word	0x00012fec
    dd34:	00013008 	.word	0x00013008
    dd38:	00013024 	.word	0x00013024
    dd3c:	00013040 	.word	0x00013040
    dd40:	000130d8 	.word	0x000130d8
    dd44:	000130ec 	.word	0x000130ec
    dd48:	40480000 	.word	0x40480000
    dd4c:	00013150 	.word	0x00013150
    dd50:	00012ef8 	.word	0x00012ef8
    dd54:	0001305c 	.word	0x0001305c
    dd58:	000130c4 	.word	0x000130c4
    dd5c:	000130a8 	.word	0x000130a8
    dd60:	000130d0 	.word	0x000130d0
    dd64:	000131ac 	.word	0x000131ac
    dd68:	00012d14 	.word	0x00012d14
    dd6c:	00012dd4 	.word	0x00012dd4
    dd70:	00012d44 	.word	0x00012d44
    dd74:	10001000 	.word	0x10001000

0000dd78 <matrix_test>:
    4 - Multiply a matrix by a matrix.
    5 - Add a constant value to all elements of a matrix.

    After the last step, matrix A is back to original contents.
*/
ee_s16 matrix_test(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B, MATDAT val) {
    dd78:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    dd7c:	b091      	sub	sp, #68	; 0x44
    dd7e:	9303      	str	r3, [sp, #12]
    dd80:	f9bd a068 	ldrsh.w	sl, [sp, #104]	; 0x68
    dd84:	9109      	str	r1, [sp, #36]	; 0x24
    dd86:	920b      	str	r2, [sp, #44]	; 0x2c
/* Function: matrix_add_const
    Add a constant value to all elements of a matrix.
*/
void matrix_add_const(ee_u32 N, MATDAT *A, MATDAT val) {
    ee_u32 i,j;
    for (i=0; i<N; i++) {
    dd88:	4603      	mov	r3, r0
    dd8a:	9008      	str	r0, [sp, #32]
    dd8c:	2800      	cmp	r0, #0
    dd8e:	f000 8754 	beq.w	ec3a <matrix_test+0xec2>
    dd92:	ea6f 500a 	mvn.w	r0, sl, lsl #20
    dd96:	ea6f 5910 	mvn.w	r9, r0, lsr #20
    dd9a:	f04f 0e00 	mov.w	lr, #0
    dd9e:	fa1f f18a 	uxth.w	r1, sl
    dda2:	005e      	lsls	r6, r3, #1
    dda4:	1e5f      	subs	r7, r3, #1
    dda6:	f8cd a03c 	str.w	sl, [sp, #60]	; 0x3c
    ddaa:	910c      	str	r1, [sp, #48]	; 0x30
    ddac:	4694      	mov	ip, r2
    ddae:	4618      	mov	r0, r3
    ddb0:	970a      	str	r7, [sp, #40]	; 0x28
    ddb2:	f8cd 9034 	str.w	r9, [sp, #52]	; 0x34
    ddb6:	920e      	str	r2, [sp, #56]	; 0x38
    ddb8:	46f3      	mov	fp, lr
    ddba:	46f2      	mov	sl, lr
    ddbc:	9605      	str	r6, [sp, #20]
    ddbe:	4614      	mov	r4, r2
    ddc0:	e0d7      	b.n	df72 <matrix_test+0x1fa>
        for (j=0; j<N; j++) {
            A[i*N+j] += val;
    ddc2:	f8bc 8000 	ldrh.w	r8, [ip]
    for (i=0; i<N; i++) {
    ddc6:	4602      	mov	r2, r0
            A[i*N+j] += val;
    ddc8:	4488      	add	r8, r1
    ddca:	2a01      	cmp	r2, #1
    ddcc:	f8ac 8000 	strh.w	r8, [ip]
    ddd0:	f000 80e6 	beq.w	dfa0 <matrix_test+0x228>
    ddd4:	f8bc 9002 	ldrh.w	r9, [ip, #2]
    ddd8:	2a02      	cmp	r2, #2
    ddda:	4489      	add	r9, r1
    dddc:	f8ac 9002 	strh.w	r9, [ip, #2]
    dde0:	f000 80de 	beq.w	dfa0 <matrix_test+0x228>
    dde4:	f8bc e004 	ldrh.w	lr, [ip, #4]
    dde8:	2a04      	cmp	r2, #4
    ddea:	448e      	add	lr, r1
    ddec:	f8ac e004 	strh.w	lr, [ip, #4]
    ddf0:	f040 80d8 	bne.w	dfa4 <matrix_test+0x22c>
    ddf4:	f8bc 5006 	ldrh.w	r5, [ip, #6]
    ddf8:	440d      	add	r5, r1
    ddfa:	f8ac 5006 	strh.w	r5, [ip, #6]
        for (j=0; j<N; j++) {
    ddfe:	4613      	mov	r3, r2
    de00:	4290      	cmp	r0, r2
    de02:	f000 80af 	beq.w	df64 <matrix_test+0x1ec>
    de06:	1a86      	subs	r6, r0, r2
    de08:	1f37      	subs	r7, r6, #4
    de0a:	9604      	str	r6, [sp, #16]
    de0c:	9e0a      	ldr	r6, [sp, #40]	; 0x28
    de0e:	08bd      	lsrs	r5, r7, #2
    de10:	1c6f      	adds	r7, r5, #1
    de12:	1ab6      	subs	r6, r6, r2
    de14:	9701      	str	r7, [sp, #4]
    de16:	2e02      	cmp	r6, #2
    de18:	ea4f 0787 	mov.w	r7, r7, lsl #2
    de1c:	9702      	str	r7, [sp, #8]
    de1e:	f240 8088 	bls.w	df32 <matrix_test+0x1ba>
    de22:	445a      	add	r2, fp
    de24:	eb04 0642 	add.w	r6, r4, r2, lsl #1
            A[i*N+j] += val;
    de28:	f854 8012 	ldr.w	r8, [r4, r2, lsl #1]
    de2c:	9206      	str	r2, [sp, #24]
    de2e:	eb01 0208 	add.w	r2, r1, r8
    de32:	9207      	str	r2, [sp, #28]
    de34:	6872      	ldr	r2, [r6, #4]
    de36:	2700      	movs	r7, #0
    de38:	eb01 0e02 	add.w	lr, r1, r2
    de3c:	9a07      	ldr	r2, [sp, #28]
    de3e:	46b9      	mov	r9, r7
    de40:	f36e 090f 	bfi	r9, lr, #0, #16
    de44:	f362 070f 	bfi	r7, r2, #0, #16
    de48:	eb01 4818 	add.w	r8, r1, r8, lsr #16
    de4c:	f005 0e01 	and.w	lr, r5, #1
    de50:	9d06      	ldr	r5, [sp, #24]
    de52:	6872      	ldr	r2, [r6, #4]
    de54:	f368 471f 	bfi	r7, r8, #16, #16
    de58:	f844 7015 	str.w	r7, [r4, r5, lsl #1]
    de5c:	9d01      	ldr	r5, [sp, #4]
    de5e:	eb01 4212 	add.w	r2, r1, r2, lsr #16
    de62:	2701      	movs	r7, #1
    de64:	f362 491f 	bfi	r9, r2, #16, #16
    de68:	42bd      	cmp	r5, r7
    de6a:	f106 0208 	add.w	r2, r6, #8
    de6e:	f8c6 9004 	str.w	r9, [r6, #4]
    de72:	d959      	bls.n	df28 <matrix_test+0x1b0>
    de74:	f1be 0f00 	cmp.w	lr, #0
    de78:	d01c      	beq.n	deb4 <matrix_test+0x13c>
    de7a:	6817      	ldr	r7, [r2, #0]
    de7c:	6856      	ldr	r6, [r2, #4]
    de7e:	2500      	movs	r5, #0
    de80:	eb01 0907 	add.w	r9, r1, r7
    de84:	46ae      	mov	lr, r5
    de86:	eb01 0806 	add.w	r8, r1, r6
    de8a:	eb01 4717 	add.w	r7, r1, r7, lsr #16
    de8e:	eb01 4616 	add.w	r6, r1, r6, lsr #16
    de92:	f369 050f 	bfi	r5, r9, #0, #16
    de96:	f368 0e0f 	bfi	lr, r8, #0, #16
    de9a:	f367 451f 	bfi	r5, r7, #16, #16
    de9e:	f366 4e1f 	bfi	lr, r6, #16, #16
    dea2:	e882 4020 	stmia.w	r2, {r5, lr}
    dea6:	9d01      	ldr	r5, [sp, #4]
    dea8:	2702      	movs	r7, #2
    deaa:	42bd      	cmp	r5, r7
    deac:	4616      	mov	r6, r2
    deae:	f102 0208 	add.w	r2, r2, #8
    deb2:	d939      	bls.n	df28 <matrix_test+0x1b0>
    deb4:	9306      	str	r3, [sp, #24]
    deb6:	9007      	str	r0, [sp, #28]
    deb8:	68b5      	ldr	r5, [r6, #8]
    deba:	f106 0e08 	add.w	lr, r6, #8
    debe:	68f6      	ldr	r6, [r6, #12]
    dec0:	2300      	movs	r3, #0
    dec2:	1988      	adds	r0, r1, r6
    dec4:	eb01 0905 	add.w	r9, r1, r5
    dec8:	4698      	mov	r8, r3
    deca:	eb01 4616 	add.w	r6, r1, r6, lsr #16
    dece:	f360 080f 	bfi	r8, r0, #0, #16
    ded2:	f369 030f 	bfi	r3, r9, #0, #16
    ded6:	eb01 4515 	add.w	r5, r1, r5, lsr #16
    deda:	f366 481f 	bfi	r8, r6, #16, #16
    dede:	f365 431f 	bfi	r3, r5, #16, #16
    dee2:	e882 0108 	stmia.w	r2, {r3, r8}
    dee6:	f10e 0608 	add.w	r6, lr, #8
    deea:	f8de e008 	ldr.w	lr, [lr, #8]
    deee:	6870      	ldr	r0, [r6, #4]
    def0:	2300      	movs	r3, #0
    def2:	eb01 090e 	add.w	r9, r1, lr
    def6:	4698      	mov	r8, r3
    def8:	eb01 4e1e 	add.w	lr, r1, lr, lsr #16
    defc:	f369 030f 	bfi	r3, r9, #0, #16
    df00:	f36e 431f 	bfi	r3, lr, #16, #16
    df04:	180d      	adds	r5, r1, r0
    df06:	6093      	str	r3, [r2, #8]
    df08:	9b01      	ldr	r3, [sp, #4]
    df0a:	f365 080f 	bfi	r8, r5, #0, #16
    df0e:	eb01 4010 	add.w	r0, r1, r0, lsr #16
    df12:	3702      	adds	r7, #2
    df14:	f360 481f 	bfi	r8, r0, #16, #16
    df18:	42bb      	cmp	r3, r7
    df1a:	f8c2 800c 	str.w	r8, [r2, #12]
    df1e:	f102 0210 	add.w	r2, r2, #16
    df22:	d8c9      	bhi.n	deb8 <matrix_test+0x140>
    df24:	9b06      	ldr	r3, [sp, #24]
    df26:	9807      	ldr	r0, [sp, #28]
    df28:	9a02      	ldr	r2, [sp, #8]
    df2a:	9e04      	ldr	r6, [sp, #16]
    df2c:	42b2      	cmp	r2, r6
    df2e:	4413      	add	r3, r2
    df30:	d018      	beq.n	df64 <matrix_test+0x1ec>
    df32:	eb03 090b 	add.w	r9, r3, fp
        for (j=0; j<N; j++) {
    df36:	1c5a      	adds	r2, r3, #1
            A[i*N+j] += val;
    df38:	f834 8019 	ldrh.w	r8, [r4, r9, lsl #1]
        for (j=0; j<N; j++) {
    df3c:	4290      	cmp	r0, r2
            A[i*N+j] += val;
    df3e:	4488      	add	r8, r1
    df40:	f824 8019 	strh.w	r8, [r4, r9, lsl #1]
        for (j=0; j<N; j++) {
    df44:	d90e      	bls.n	df64 <matrix_test+0x1ec>
            A[i*N+j] += val;
    df46:	445a      	add	r2, fp
        for (j=0; j<N; j++) {
    df48:	3302      	adds	r3, #2
            A[i*N+j] += val;
    df4a:	f834 5012 	ldrh.w	r5, [r4, r2, lsl #1]
        for (j=0; j<N; j++) {
    df4e:	4298      	cmp	r0, r3
            A[i*N+j] += val;
    df50:	440d      	add	r5, r1
    df52:	f824 5012 	strh.w	r5, [r4, r2, lsl #1]
        for (j=0; j<N; j++) {
    df56:	d905      	bls.n	df64 <matrix_test+0x1ec>
            A[i*N+j] += val;
    df58:	445b      	add	r3, fp
    df5a:	f834 e013 	ldrh.w	lr, [r4, r3, lsl #1]
    df5e:	448e      	add	lr, r1
    df60:	f824 e013 	strh.w	lr, [r4, r3, lsl #1]
    for (i=0; i<N; i++) {
    df64:	f10a 0a01 	add.w	sl, sl, #1
    df68:	9b05      	ldr	r3, [sp, #20]
    df6a:	4550      	cmp	r0, sl
    df6c:	449c      	add	ip, r3
    df6e:	4483      	add	fp, r0
    df70:	d01a      	beq.n	dfa8 <matrix_test+0x230>
    df72:	ea4f 025c 	mov.w	r2, ip, lsr #1
    df76:	4253      	negs	r3, r2
    df78:	f003 0303 	and.w	r3, r3, #3
    df7c:	4283      	cmp	r3, r0
    df7e:	bf28      	it	cs
    df80:	4603      	movcs	r3, r0
    df82:	2804      	cmp	r0, #4
    df84:	f67f af1d 	bls.w	ddc2 <matrix_test+0x4a>
    df88:	461a      	mov	r2, r3
    df8a:	2b00      	cmp	r3, #0
    df8c:	f43f af3b 	beq.w	de06 <matrix_test+0x8e>
            A[i*N+j] += val;
    df90:	f8bc 8000 	ldrh.w	r8, [ip]
    df94:	2a01      	cmp	r2, #1
    df96:	4488      	add	r8, r1
    df98:	f8ac 8000 	strh.w	r8, [ip]
    df9c:	f47f af1a 	bne.w	ddd4 <matrix_test+0x5c>
        for (j=0; j<N; j++) {
    dfa0:	4613      	mov	r3, r2
    dfa2:	e72d      	b.n	de00 <matrix_test+0x88>
    dfa4:	2303      	movs	r3, #3
    dfa6:	e72b      	b.n	de00 <matrix_test+0x88>
    dfa8:	9c08      	ldr	r4, [sp, #32]
    dfaa:	f8dd c034 	ldr.w	ip, [sp, #52]	; 0x34
    dfae:	f8cd a004 	str.w	sl, [sp, #4]
    dfb2:	00a0      	lsls	r0, r4, #2
    for (i=0; i<N; i++) {
    dfb4:	2700      	movs	r7, #0
    dfb6:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
    dfba:	f8dd a03c 	ldr.w	sl, [sp, #60]	; 0x3c
    dfbe:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
    dfc2:	f8cd c010 	str.w	ip, [sp, #16]
    dfc6:	9002      	str	r0, [sp, #8]
    dfc8:	46bc      	mov	ip, r7
    dfca:	4699      	mov	r9, r3
    dfcc:	eb0b 0e09 	add.w	lr, fp, r9
            C[i*N+j]=(MATRES)A[i*N+j] * (MATRES)val;
    dfd0:	f93b 6b02 	ldrsh.w	r6, [fp], #2
    dfd4:	4643      	mov	r3, r8
    dfd6:	fb06 f50a 	mul.w	r5, r6, sl
    dfda:	f1a9 0202 	sub.w	r2, r9, #2
        for (j=0; j<N; j++) {
    dfde:	45f3      	cmp	fp, lr
            C[i*N+j]=(MATRES)A[i*N+j] * (MATRES)val;
    dfe0:	f843 5b04 	str.w	r5, [r3], #4
    dfe4:	f3c2 0142 	ubfx	r1, r2, #1, #3
        for (j=0; j<N; j++) {
    dfe8:	d069      	beq.n	e0be <matrix_test+0x346>
    dfea:	b3b9      	cbz	r1, e05c <matrix_test+0x2e4>
    dfec:	2901      	cmp	r1, #1
    dfee:	d02d      	beq.n	e04c <matrix_test+0x2d4>
    dff0:	2902      	cmp	r1, #2
    dff2:	d025      	beq.n	e040 <matrix_test+0x2c8>
    dff4:	2903      	cmp	r1, #3
    dff6:	d01d      	beq.n	e034 <matrix_test+0x2bc>
    dff8:	2904      	cmp	r1, #4
    dffa:	d015      	beq.n	e028 <matrix_test+0x2b0>
    dffc:	2905      	cmp	r1, #5
    dffe:	d00d      	beq.n	e01c <matrix_test+0x2a4>
    e000:	2906      	cmp	r1, #6
    e002:	d005      	beq.n	e010 <matrix_test+0x298>
            C[i*N+j]=(MATRES)A[i*N+j] * (MATRES)val;
    e004:	f93b 4b02 	ldrsh.w	r4, [fp], #2
    e008:	fb04 f00a 	mul.w	r0, r4, sl
    e00c:	f843 0b04 	str.w	r0, [r3], #4
    e010:	f93b 7b02 	ldrsh.w	r7, [fp], #2
    e014:	fb07 f60a 	mul.w	r6, r7, sl
    e018:	f843 6b04 	str.w	r6, [r3], #4
    e01c:	f93b 5b02 	ldrsh.w	r5, [fp], #2
    e020:	fb05 f20a 	mul.w	r2, r5, sl
    e024:	f843 2b04 	str.w	r2, [r3], #4
    e028:	f93b 1b02 	ldrsh.w	r1, [fp], #2
    e02c:	fb01 f40a 	mul.w	r4, r1, sl
    e030:	f843 4b04 	str.w	r4, [r3], #4
    e034:	f93b 0b02 	ldrsh.w	r0, [fp], #2
    e038:	fb00 f70a 	mul.w	r7, r0, sl
    e03c:	f843 7b04 	str.w	r7, [r3], #4
    e040:	f93b 6b02 	ldrsh.w	r6, [fp], #2
    e044:	fb06 f50a 	mul.w	r5, r6, sl
    e048:	f843 5b04 	str.w	r5, [r3], #4
    e04c:	f93b 2b02 	ldrsh.w	r2, [fp], #2
    e050:	fb02 f10a 	mul.w	r1, r2, sl
        for (j=0; j<N; j++) {
    e054:	45f3      	cmp	fp, lr
            C[i*N+j]=(MATRES)A[i*N+j] * (MATRES)val;
    e056:	f843 1b04 	str.w	r1, [r3], #4
        for (j=0; j<N; j++) {
    e05a:	d030      	beq.n	e0be <matrix_test+0x346>
            C[i*N+j]=(MATRES)A[i*N+j] * (MATRES)val;
    e05c:	465c      	mov	r4, fp
    e05e:	461a      	mov	r2, r3
    e060:	f934 0b02 	ldrsh.w	r0, [r4], #2
    e064:	f9bb 7002 	ldrsh.w	r7, [fp, #2]
    e068:	f9b4 6002 	ldrsh.w	r6, [r4, #2]
    e06c:	f9bb 5006 	ldrsh.w	r5, [fp, #6]
    e070:	f9bb 4008 	ldrsh.w	r4, [fp, #8]
    e074:	fb00 f10a 	mul.w	r1, r0, sl
    e078:	f842 1b04 	str.w	r1, [r2], #4
    e07c:	fb06 f60a 	mul.w	r6, r6, sl
    e080:	fb07 f70a 	mul.w	r7, r7, sl
    e084:	f9bb 000a 	ldrsh.w	r0, [fp, #10]
    e088:	f9bb 100c 	ldrsh.w	r1, [fp, #12]
    e08c:	605f      	str	r7, [r3, #4]
    e08e:	6056      	str	r6, [r2, #4]
    e090:	f9bb 200e 	ldrsh.w	r2, [fp, #14]
    e094:	f10b 0b10 	add.w	fp, fp, #16
    e098:	fb05 f50a 	mul.w	r5, r5, sl
    e09c:	fb04 f40a 	mul.w	r4, r4, sl
    e0a0:	fb00 f00a 	mul.w	r0, r0, sl
    e0a4:	fb01 f10a 	mul.w	r1, r1, sl
    e0a8:	fb02 f60a 	mul.w	r6, r2, sl
        for (j=0; j<N; j++) {
    e0ac:	45f3      	cmp	fp, lr
            C[i*N+j]=(MATRES)A[i*N+j] * (MATRES)val;
    e0ae:	60dd      	str	r5, [r3, #12]
    e0b0:	611c      	str	r4, [r3, #16]
    e0b2:	6158      	str	r0, [r3, #20]
    e0b4:	6199      	str	r1, [r3, #24]
    e0b6:	61de      	str	r6, [r3, #28]
    e0b8:	f103 0320 	add.w	r3, r3, #32
        for (j=0; j<N; j++) {
    e0bc:	d1ce      	bne.n	e05c <matrix_test+0x2e4>
    for (i=0; i<N; i++) {
    e0be:	9f01      	ldr	r7, [sp, #4]
    e0c0:	9b02      	ldr	r3, [sp, #8]
    e0c2:	f10c 0c01 	add.w	ip, ip, #1
    e0c6:	45bc      	cmp	ip, r7
    e0c8:	4498      	add	r8, r3
    e0ca:	f47f af7f 	bne.w	dfcc <matrix_test+0x254>
    e0ce:	f04f 0c00 	mov.w	ip, #0
    e0d2:	464c      	mov	r4, r9
    e0d4:	9e09      	ldr	r6, [sp, #36]	; 0x24
    e0d6:	f8dd 9010 	ldr.w	r9, [sp, #16]
    e0da:	f8dd b020 	ldr.w	fp, [sp, #32]
    e0de:	f8dd a008 	ldr.w	sl, [sp, #8]
    e0e2:	9601      	str	r6, [sp, #4]
    e0e4:	4660      	mov	r0, ip
    e0e6:	4665      	mov	r5, ip
    e0e8:	46e0      	mov	r8, ip
    e0ea:	eb06 0e0a 	add.w	lr, r6, sl
            cur=C[i*N+j];
    e0ee:	f856 3b04 	ldr.w	r3, [r6], #4
                ret+=10;
    e0f2:	b280      	uxth	r0, r0
    e0f4:	f100 010a 	add.w	r1, r0, #10
            tmp+=cur;
    e0f8:	4498      	add	r8, r3
                ret += (cur>prev) ? 1 : 0;
    e0fa:	42ab      	cmp	r3, r5
    e0fc:	bfc8      	it	gt
    e0fe:	3001      	addgt	r0, #1
    e100:	45c8      	cmp	r8, r9
                ret+=10;
    e102:	b20d      	sxth	r5, r1
                ret += (cur>prev) ? 1 : 0;
    e104:	b200      	sxth	r0, r0
    e106:	f1aa 0204 	sub.w	r2, sl, #4
    e10a:	bfc4      	itt	gt
    e10c:	4628      	movgt	r0, r5
    e10e:	f04f 0800 	movgt.w	r8, #0
        for (j=0; j<N; j++) {
    e112:	4576      	cmp	r6, lr
            cur=C[i*N+j];
    e114:	461d      	mov	r5, r3
    e116:	f3c2 0781 	ubfx	r7, r2, #2, #2
        for (j=0; j<N; j++) {
    e11a:	f000 8086 	beq.w	e22a <matrix_test+0x4b2>
    e11e:	2f00      	cmp	r7, #0
    e120:	d038      	beq.n	e194 <matrix_test+0x41c>
    e122:	2f01      	cmp	r7, #1
    e124:	d023      	beq.n	e16e <matrix_test+0x3f6>
    e126:	2f02      	cmp	r7, #2
    e128:	d010      	beq.n	e14c <matrix_test+0x3d4>
            cur=C[i*N+j];
    e12a:	f856 3b04 	ldr.w	r3, [r6], #4
                ret+=10;
    e12e:	b280      	uxth	r0, r0
    e130:	f100 010a 	add.w	r1, r0, #10
            tmp+=cur;
    e134:	4498      	add	r8, r3
                ret += (cur>prev) ? 1 : 0;
    e136:	42ab      	cmp	r3, r5
    e138:	bfc8      	it	gt
    e13a:	3001      	addgt	r0, #1
                ret+=10;
    e13c:	b20d      	sxth	r5, r1
    e13e:	45c8      	cmp	r8, r9
                ret += (cur>prev) ? 1 : 0;
    e140:	b200      	sxth	r0, r0
    e142:	bfc4      	itt	gt
    e144:	f04f 0800 	movgt.w	r8, #0
    e148:	4628      	movgt	r0, r5
            cur=C[i*N+j];
    e14a:	461d      	mov	r5, r3
    e14c:	f856 7b04 	ldr.w	r7, [r6], #4
                ret+=10;
    e150:	b283      	uxth	r3, r0
    e152:	f103 020a 	add.w	r2, r3, #10
            tmp+=cur;
    e156:	44b8      	add	r8, r7
                ret += (cur>prev) ? 1 : 0;
    e158:	42af      	cmp	r7, r5
    e15a:	bfc8      	it	gt
    e15c:	3301      	addgt	r3, #1
                ret+=10;
    e15e:	b211      	sxth	r1, r2
    e160:	45c8      	cmp	r8, r9
                ret += (cur>prev) ? 1 : 0;
    e162:	b218      	sxth	r0, r3
    e164:	bfc4      	itt	gt
    e166:	f04f 0800 	movgt.w	r8, #0
    e16a:	4608      	movgt	r0, r1
            cur=C[i*N+j];
    e16c:	463d      	mov	r5, r7
    e16e:	f856 7b04 	ldr.w	r7, [r6], #4
                ret+=10;
    e172:	b280      	uxth	r0, r0
    e174:	f100 030a 	add.w	r3, r0, #10
            tmp+=cur;
    e178:	44b8      	add	r8, r7
                ret += (cur>prev) ? 1 : 0;
    e17a:	42af      	cmp	r7, r5
    e17c:	bfc8      	it	gt
    e17e:	3001      	addgt	r0, #1
    e180:	45c8      	cmp	r8, r9
                ret+=10;
    e182:	b21d      	sxth	r5, r3
                ret += (cur>prev) ? 1 : 0;
    e184:	b200      	sxth	r0, r0
    e186:	bfc4      	itt	gt
    e188:	f04f 0800 	movgt.w	r8, #0
    e18c:	4628      	movgt	r0, r5
        for (j=0; j<N; j++) {
    e18e:	4576      	cmp	r6, lr
            cur=C[i*N+j];
    e190:	463d      	mov	r5, r7
        for (j=0; j<N; j++) {
    e192:	d04a      	beq.n	e22a <matrix_test+0x4b2>
    e194:	4642      	mov	r2, r8
            cur=C[i*N+j];
    e196:	4631      	mov	r1, r6
                ret+=10;
    e198:	b280      	uxth	r0, r0
            cur=C[i*N+j];
    e19a:	f851 8b04 	ldr.w	r8, [r1], #4
    e19e:	6873      	ldr	r3, [r6, #4]
    e1a0:	684f      	ldr	r7, [r1, #4]
    e1a2:	68f1      	ldr	r1, [r6, #12]
            tmp+=cur;
    e1a4:	4442      	add	r2, r8
                ret += (cur>prev) ? 1 : 0;
    e1a6:	45a8      	cmp	r8, r5
    e1a8:	bfd4      	ite	le
    e1aa:	4605      	movle	r5, r0
    e1ac:	1c45      	addgt	r5, r0, #1
    e1ae:	b22d      	sxth	r5, r5
    e1b0:	454a      	cmp	r2, r9
                ret+=10;
    e1b2:	f100 000a 	add.w	r0, r0, #10
    e1b6:	b200      	sxth	r0, r0
    e1b8:	bfd6      	itet	le
    e1ba:	4628      	movle	r0, r5
    e1bc:	2500      	movgt	r5, #0
    e1be:	4615      	movle	r5, r2
    e1c0:	b282      	uxth	r2, r0
            tmp+=cur;
    e1c2:	441d      	add	r5, r3
                ret+=10;
    e1c4:	f102 000a 	add.w	r0, r2, #10
                ret += (cur>prev) ? 1 : 0;
    e1c8:	4543      	cmp	r3, r8
    e1ca:	bfc8      	it	gt
    e1cc:	3201      	addgt	r2, #1
    e1ce:	b212      	sxth	r2, r2
    e1d0:	454d      	cmp	r5, r9
                ret+=10;
    e1d2:	fa0f f880 	sxth.w	r8, r0
    e1d6:	bfd4      	ite	le
    e1d8:	4690      	movle	r8, r2
    e1da:	2500      	movgt	r5, #0
    e1dc:	fa1f f088 	uxth.w	r0, r8
    e1e0:	f100 080a 	add.w	r8, r0, #10
                ret += (cur>prev) ? 1 : 0;
    e1e4:	429f      	cmp	r7, r3
    e1e6:	bfc8      	it	gt
    e1e8:	3001      	addgt	r0, #1
            tmp+=cur;
    e1ea:	197b      	adds	r3, r7, r5
    e1ec:	454b      	cmp	r3, r9
                ret += (cur>prev) ? 1 : 0;
    e1ee:	b205      	sxth	r5, r0
                ret+=10;
    e1f0:	fa0f f288 	sxth.w	r2, r8
    e1f4:	bfd8      	it	le
    e1f6:	462a      	movle	r2, r5
    e1f8:	fa1f f882 	uxth.w	r8, r2
    e1fc:	bfc8      	it	gt
    e1fe:	2300      	movgt	r3, #0
    e200:	f108 000a 	add.w	r0, r8, #10
            tmp+=cur;
    e204:	440b      	add	r3, r1
                ret += (cur>prev) ? 1 : 0;
    e206:	42b9      	cmp	r1, r7
    e208:	bfc8      	it	gt
    e20a:	f108 0801 	addgt.w	r8, r8, #1
    e20e:	fa0f f288 	sxth.w	r2, r8
    e212:	454b      	cmp	r3, r9
    e214:	f106 0610 	add.w	r6, r6, #16
                ret+=10;
    e218:	b200      	sxth	r0, r0
    e21a:	bfce      	itee	gt
    e21c:	2200      	movgt	r2, #0
    e21e:	4610      	movle	r0, r2
    e220:	461a      	movle	r2, r3
        for (j=0; j<N; j++) {
    e222:	4576      	cmp	r6, lr
            cur=C[i*N+j];
    e224:	460d      	mov	r5, r1
        for (j=0; j<N; j++) {
    e226:	d1b6      	bne.n	e196 <matrix_test+0x41e>
    e228:	4690      	mov	r8, r2
    for (i=0; i<N; i++) {
    e22a:	f10c 0c01 	add.w	ip, ip, #1
    e22e:	45e3      	cmp	fp, ip
    e230:	f47f af5b 	bne.w	e0ea <matrix_test+0x372>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    e234:	2100      	movs	r1, #0
    e236:	f8dd b004 	ldr.w	fp, [sp, #4]
    e23a:	f001 fb1d 	bl	f878 <crc16>
    e23e:	9e09      	ldr	r6, [sp, #36]	; 0x24
    e240:	9f02      	ldr	r7, [sp, #8]
    e242:	9903      	ldr	r1, [sp, #12]
    e244:	f8dd a02c 	ldr.w	sl, [sp, #44]	; 0x2c
    e248:	f8cd 9014 	str.w	r9, [sp, #20]
    e24c:	443e      	add	r6, r7
    e24e:	9004      	str	r0, [sp, #16]
    e250:	9601      	str	r6, [sp, #4]
    e252:	eb01 0804 	add.w	r8, r1, r4
    e256:	4689      	mov	r9, r1
void matrix_mul_vect(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B) {
    ee_u32 i,j;
    for (i=0; i<N; i++) {
        C[i]=0;
        for (j=0; j<N; j++) {
            C[i]+=(MATRES)A[i*N+j] * (MATRES)B[j];
    e258:	46ce      	mov	lr, r9
    e25a:	46d4      	mov	ip, sl
    e25c:	f93e 3b02 	ldrsh.w	r3, [lr], #2
    e260:	f93c 5b02 	ldrsh.w	r5, [ip], #2
    e264:	eba8 0009 	sub.w	r0, r8, r9
    e268:	1e82      	subs	r2, r0, #2
        for (j=0; j<N; j++) {
    e26a:	45f0      	cmp	r8, lr
            C[i]+=(MATRES)A[i*N+j] * (MATRES)B[j];
    e26c:	fb05 f303 	mul.w	r3, r5, r3
    e270:	f3c2 0642 	ubfx	r6, r2, #1, #3
        for (j=0; j<N; j++) {
    e274:	d072      	beq.n	e35c <matrix_test+0x5e4>
    e276:	b3ce      	cbz	r6, e2ec <matrix_test+0x574>
    e278:	2e01      	cmp	r6, #1
    e27a:	d02f      	beq.n	e2dc <matrix_test+0x564>
    e27c:	2e02      	cmp	r6, #2
    e27e:	d027      	beq.n	e2d0 <matrix_test+0x558>
    e280:	2e03      	cmp	r6, #3
    e282:	d01f      	beq.n	e2c4 <matrix_test+0x54c>
    e284:	2e04      	cmp	r6, #4
    e286:	d017      	beq.n	e2b8 <matrix_test+0x540>
    e288:	2e05      	cmp	r6, #5
    e28a:	d00f      	beq.n	e2ac <matrix_test+0x534>
    e28c:	2e06      	cmp	r6, #6
    e28e:	d007      	beq.n	e2a0 <matrix_test+0x528>
            C[i]+=(MATRES)A[i*N+j] * (MATRES)B[j];
    e290:	f93c 7b02 	ldrsh.w	r7, [ip], #2
    e294:	f9b9 1002 	ldrsh.w	r1, [r9, #2]
    e298:	f10e 0e02 	add.w	lr, lr, #2
    e29c:	fb07 3301 	mla	r3, r7, r1, r3
    e2a0:	f93c 5b02 	ldrsh.w	r5, [ip], #2
    e2a4:	f93e 0b02 	ldrsh.w	r0, [lr], #2
    e2a8:	fb05 3300 	mla	r3, r5, r0, r3
    e2ac:	f93c 6b02 	ldrsh.w	r6, [ip], #2
    e2b0:	f93e 2b02 	ldrsh.w	r2, [lr], #2
    e2b4:	fb06 3302 	mla	r3, r6, r2, r3
    e2b8:	f93c 7b02 	ldrsh.w	r7, [ip], #2
    e2bc:	f93e 1b02 	ldrsh.w	r1, [lr], #2
    e2c0:	fb07 3301 	mla	r3, r7, r1, r3
    e2c4:	f93c 5b02 	ldrsh.w	r5, [ip], #2
    e2c8:	f93e 0b02 	ldrsh.w	r0, [lr], #2
    e2cc:	fb05 3300 	mla	r3, r5, r0, r3
    e2d0:	f93c 6b02 	ldrsh.w	r6, [ip], #2
    e2d4:	f93e 2b02 	ldrsh.w	r2, [lr], #2
    e2d8:	fb06 3302 	mla	r3, r6, r2, r3
    e2dc:	f93e 1b02 	ldrsh.w	r1, [lr], #2
    e2e0:	f93c 7b02 	ldrsh.w	r7, [ip], #2
        for (j=0; j<N; j++) {
    e2e4:	45f0      	cmp	r8, lr
            C[i]+=(MATRES)A[i*N+j] * (MATRES)B[j];
    e2e6:	fb07 3301 	mla	r3, r7, r1, r3
        for (j=0; j<N; j++) {
    e2ea:	d037      	beq.n	e35c <matrix_test+0x5e4>
            C[i]+=(MATRES)A[i*N+j] * (MATRES)B[j];
    e2ec:	4666      	mov	r6, ip
    e2ee:	4672      	mov	r2, lr
    e2f0:	f936 7b02 	ldrsh.w	r7, [r6], #2
    e2f4:	f932 0b02 	ldrsh.w	r0, [r2], #2
    e2f8:	f9be 1002 	ldrsh.w	r1, [lr, #2]
    e2fc:	f9bc 5002 	ldrsh.w	r5, [ip, #2]
    e300:	f9b6 6002 	ldrsh.w	r6, [r6, #2]
    e304:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
    e308:	fb07 3300 	mla	r3, r7, r0, r3
    e30c:	fb05 3701 	mla	r7, r5, r1, r3
    e310:	f9be 3006 	ldrsh.w	r3, [lr, #6]
    e314:	f9bc 5006 	ldrsh.w	r5, [ip, #6]
    e318:	f9bc 0008 	ldrsh.w	r0, [ip, #8]
    e31c:	f9be 1008 	ldrsh.w	r1, [lr, #8]
    e320:	fb06 7202 	mla	r2, r6, r2, r7
    e324:	fb05 2703 	mla	r7, r5, r3, r2
    e328:	f9bc 600a 	ldrsh.w	r6, [ip, #10]
    e32c:	f9be 200a 	ldrsh.w	r2, [lr, #10]
    e330:	f9be 300c 	ldrsh.w	r3, [lr, #12]
    e334:	f9bc 500c 	ldrsh.w	r5, [ip, #12]
    e338:	fb00 7101 	mla	r1, r0, r1, r7
    e33c:	fb06 1602 	mla	r6, r6, r2, r1
    e340:	f9be 700e 	ldrsh.w	r7, [lr, #14]
    e344:	f9bc 000e 	ldrsh.w	r0, [ip, #14]
    e348:	f10e 0e10 	add.w	lr, lr, #16
    e34c:	fb05 6203 	mla	r2, r5, r3, r6
        for (j=0; j<N; j++) {
    e350:	45f0      	cmp	r8, lr
    e352:	f10c 0c10 	add.w	ip, ip, #16
            C[i]+=(MATRES)A[i*N+j] * (MATRES)B[j];
    e356:	fb00 2307 	mla	r3, r0, r7, r2
        for (j=0; j<N; j++) {
    e35a:	d1c7      	bne.n	e2ec <matrix_test+0x574>
    e35c:	f84b 3b04 	str.w	r3, [fp], #4
    for (i=0; i<N; i++) {
    e360:	9d01      	ldr	r5, [sp, #4]
    e362:	45ab      	cmp	fp, r5
    e364:	44a2      	add	sl, r4
    e366:	f47f af77 	bne.w	e258 <matrix_test+0x4e0>
    e36a:	f04f 0800 	mov.w	r8, #0
    e36e:	9e09      	ldr	r6, [sp, #36]	; 0x24
    e370:	f8dd 9014 	ldr.w	r9, [sp, #20]
    e374:	f8dd b020 	ldr.w	fp, [sp, #32]
    e378:	f8dd a008 	ldr.w	sl, [sp, #8]
    e37c:	9601      	str	r6, [sp, #4]
    e37e:	4645      	mov	r5, r8
    e380:	4640      	mov	r0, r8
    e382:	46c4      	mov	ip, r8
    e384:	eb06 0e0a 	add.w	lr, r6, sl
            cur=C[i*N+j];
    e388:	f856 7b04 	ldr.w	r7, [r6], #4
                ret+=10;
    e38c:	b283      	uxth	r3, r0
            tmp+=cur;
    e38e:	44bc      	add	ip, r7
                ret+=10;
    e390:	f103 010a 	add.w	r1, r3, #10
    e394:	b20a      	sxth	r2, r1
                ret += (cur>prev) ? 1 : 0;
    e396:	42af      	cmp	r7, r5
    e398:	bfc8      	it	gt
    e39a:	3301      	addgt	r3, #1
    e39c:	45cc      	cmp	ip, r9
    e39e:	b218      	sxth	r0, r3
    e3a0:	bfc8      	it	gt
    e3a2:	f04f 0c00 	movgt.w	ip, #0
    e3a6:	f1aa 0304 	sub.w	r3, sl, #4
    e3aa:	bfc8      	it	gt
    e3ac:	4610      	movgt	r0, r2
        for (j=0; j<N; j++) {
    e3ae:	45b6      	cmp	lr, r6
            cur=C[i*N+j];
    e3b0:	463d      	mov	r5, r7
    e3b2:	f3c3 0781 	ubfx	r7, r3, #2, #2
        for (j=0; j<N; j++) {
    e3b6:	f000 8086 	beq.w	e4c6 <matrix_test+0x74e>
    e3ba:	2f00      	cmp	r7, #0
    e3bc:	d038      	beq.n	e430 <matrix_test+0x6b8>
    e3be:	2f01      	cmp	r7, #1
    e3c0:	d023      	beq.n	e40a <matrix_test+0x692>
    e3c2:	2f02      	cmp	r7, #2
    e3c4:	d010      	beq.n	e3e8 <matrix_test+0x670>
            cur=C[i*N+j];
    e3c6:	f856 1b04 	ldr.w	r1, [r6], #4
                ret+=10;
    e3ca:	b280      	uxth	r0, r0
    e3cc:	f100 020a 	add.w	r2, r0, #10
            tmp+=cur;
    e3d0:	448c      	add	ip, r1
                ret += (cur>prev) ? 1 : 0;
    e3d2:	42a9      	cmp	r1, r5
    e3d4:	bfc8      	it	gt
    e3d6:	3001      	addgt	r0, #1
                ret+=10;
    e3d8:	b215      	sxth	r5, r2
    e3da:	45cc      	cmp	ip, r9
                ret += (cur>prev) ? 1 : 0;
    e3dc:	b200      	sxth	r0, r0
    e3de:	bfc4      	itt	gt
    e3e0:	f04f 0c00 	movgt.w	ip, #0
    e3e4:	4628      	movgt	r0, r5
            cur=C[i*N+j];
    e3e6:	460d      	mov	r5, r1
    e3e8:	f856 3b04 	ldr.w	r3, [r6], #4
                ret+=10;
    e3ec:	b287      	uxth	r7, r0
    e3ee:	f107 010a 	add.w	r1, r7, #10
            tmp+=cur;
    e3f2:	449c      	add	ip, r3
                ret += (cur>prev) ? 1 : 0;
    e3f4:	42ab      	cmp	r3, r5
    e3f6:	bfc8      	it	gt
    e3f8:	3701      	addgt	r7, #1
                ret+=10;
    e3fa:	b20a      	sxth	r2, r1
    e3fc:	45cc      	cmp	ip, r9
                ret += (cur>prev) ? 1 : 0;
    e3fe:	b238      	sxth	r0, r7
    e400:	bfc4      	itt	gt
    e402:	f04f 0c00 	movgt.w	ip, #0
    e406:	4610      	movgt	r0, r2
            cur=C[i*N+j];
    e408:	461d      	mov	r5, r3
    e40a:	f856 3b04 	ldr.w	r3, [r6], #4
                ret+=10;
    e40e:	b280      	uxth	r0, r0
    e410:	f100 070a 	add.w	r7, r0, #10
            tmp+=cur;
    e414:	449c      	add	ip, r3
                ret += (cur>prev) ? 1 : 0;
    e416:	42ab      	cmp	r3, r5
    e418:	bfc8      	it	gt
    e41a:	3001      	addgt	r0, #1
    e41c:	45cc      	cmp	ip, r9
                ret+=10;
    e41e:	b23d      	sxth	r5, r7
                ret += (cur>prev) ? 1 : 0;
    e420:	b200      	sxth	r0, r0
    e422:	bfc4      	itt	gt
    e424:	f04f 0c00 	movgt.w	ip, #0
    e428:	4628      	movgt	r0, r5
        for (j=0; j<N; j++) {
    e42a:	45b6      	cmp	lr, r6
            cur=C[i*N+j];
    e42c:	461d      	mov	r5, r3
        for (j=0; j<N; j++) {
    e42e:	d04a      	beq.n	e4c6 <matrix_test+0x74e>
    e430:	4662      	mov	r2, ip
            cur=C[i*N+j];
    e432:	4631      	mov	r1, r6
                ret+=10;
    e434:	b280      	uxth	r0, r0
            cur=C[i*N+j];
    e436:	f851 cb04 	ldr.w	ip, [r1], #4
    e43a:	6873      	ldr	r3, [r6, #4]
    e43c:	684f      	ldr	r7, [r1, #4]
    e43e:	68f1      	ldr	r1, [r6, #12]
            tmp+=cur;
    e440:	4462      	add	r2, ip
                ret += (cur>prev) ? 1 : 0;
    e442:	45ac      	cmp	ip, r5
    e444:	bfd4      	ite	le
    e446:	4605      	movle	r5, r0
    e448:	1c45      	addgt	r5, r0, #1
    e44a:	b22d      	sxth	r5, r5
    e44c:	454a      	cmp	r2, r9
                ret+=10;
    e44e:	f100 000a 	add.w	r0, r0, #10
    e452:	b200      	sxth	r0, r0
    e454:	bfd6      	itet	le
    e456:	4628      	movle	r0, r5
    e458:	2500      	movgt	r5, #0
    e45a:	4615      	movle	r5, r2
    e45c:	b282      	uxth	r2, r0
            tmp+=cur;
    e45e:	441d      	add	r5, r3
                ret+=10;
    e460:	f102 000a 	add.w	r0, r2, #10
                ret += (cur>prev) ? 1 : 0;
    e464:	4563      	cmp	r3, ip
    e466:	bfc8      	it	gt
    e468:	3201      	addgt	r2, #1
    e46a:	b212      	sxth	r2, r2
    e46c:	454d      	cmp	r5, r9
                ret+=10;
    e46e:	fa0f fc80 	sxth.w	ip, r0
    e472:	bfd4      	ite	le
    e474:	4694      	movle	ip, r2
    e476:	2500      	movgt	r5, #0
    e478:	fa1f f08c 	uxth.w	r0, ip
    e47c:	f100 0c0a 	add.w	ip, r0, #10
                ret += (cur>prev) ? 1 : 0;
    e480:	429f      	cmp	r7, r3
    e482:	bfc8      	it	gt
    e484:	3001      	addgt	r0, #1
            tmp+=cur;
    e486:	197b      	adds	r3, r7, r5
    e488:	454b      	cmp	r3, r9
                ret += (cur>prev) ? 1 : 0;
    e48a:	b205      	sxth	r5, r0
                ret+=10;
    e48c:	fa0f f28c 	sxth.w	r2, ip
    e490:	bfd8      	it	le
    e492:	462a      	movle	r2, r5
    e494:	fa1f fc82 	uxth.w	ip, r2
    e498:	bfc8      	it	gt
    e49a:	2300      	movgt	r3, #0
    e49c:	f10c 000a 	add.w	r0, ip, #10
            tmp+=cur;
    e4a0:	440b      	add	r3, r1
                ret += (cur>prev) ? 1 : 0;
    e4a2:	42b9      	cmp	r1, r7
    e4a4:	bfc8      	it	gt
    e4a6:	f10c 0c01 	addgt.w	ip, ip, #1
    e4aa:	fa0f f28c 	sxth.w	r2, ip
    e4ae:	454b      	cmp	r3, r9
    e4b0:	f106 0610 	add.w	r6, r6, #16
                ret+=10;
    e4b4:	b200      	sxth	r0, r0
    e4b6:	bfce      	itee	gt
    e4b8:	2200      	movgt	r2, #0
    e4ba:	4610      	movle	r0, r2
    e4bc:	461a      	movle	r2, r3
        for (j=0; j<N; j++) {
    e4be:	45b6      	cmp	lr, r6
            cur=C[i*N+j];
    e4c0:	460d      	mov	r5, r1
        for (j=0; j<N; j++) {
    e4c2:	d1b6      	bne.n	e432 <matrix_test+0x6ba>
    e4c4:	4694      	mov	ip, r2
    for (i=0; i<N; i++) {
    e4c6:	f108 0801 	add.w	r8, r8, #1
    e4ca:	45c3      	cmp	fp, r8
    e4cc:	f47f af5a 	bne.w	e384 <matrix_test+0x60c>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    e4d0:	9904      	ldr	r1, [sp, #16]
    e4d2:	f8cd 8014 	str.w	r8, [sp, #20]
    e4d6:	f001 f9cf 	bl	f878 <crc16>
    e4da:	9e03      	ldr	r6, [sp, #12]
    e4dc:	f8dd c02c 	ldr.w	ip, [sp, #44]	; 0x2c
    e4e0:	f8dd a004 	ldr.w	sl, [sp, #4]
    e4e4:	f8cd 901c 	str.w	r9, [sp, #28]
    e4e8:	4426      	add	r6, r4
    e4ea:	2700      	movs	r7, #0
    e4ec:	9006      	str	r0, [sp, #24]
    e4ee:	9704      	str	r7, [sp, #16]
    e4f0:	46b1      	mov	r9, r6
    e4f2:	9f03      	ldr	r7, [sp, #12]
    e4f4:	eb04 0e0c 	add.w	lr, r4, ip
    e4f8:	46d0      	mov	r8, sl
    for (i=0; i<N; i++) {
        for (j=0; j<N; j++) {
            C[i*N+j]=0;
            for(k=0;k<N;k++)
            {
                C[i*N+j]+=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    e4fa:	46e3      	mov	fp, ip
    e4fc:	883b      	ldrh	r3, [r7, #0]
    e4fe:	f93b 1b02 	ldrsh.w	r1, [fp], #2
    e502:	ebae 050c 	sub.w	r5, lr, ip
    e506:	1ea8      	subs	r0, r5, #2
            for(k=0;k<N;k++)
    e508:	45de      	cmp	lr, fp
                C[i*N+j]+=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    e50a:	fb11 f303 	smulbb	r3, r1, r3
    e50e:	f3c0 0242 	ubfx	r2, r0, #1, #3
    e512:	eb07 0604 	add.w	r6, r7, r4
            for(k=0;k<N;k++)
    e516:	d075      	beq.n	e604 <matrix_test+0x88c>
    e518:	b3ba      	cbz	r2, e58a <matrix_test+0x812>
    e51a:	2a01      	cmp	r2, #1
    e51c:	d02d      	beq.n	e57a <matrix_test+0x802>
    e51e:	2a02      	cmp	r2, #2
    e520:	d025      	beq.n	e56e <matrix_test+0x7f6>
    e522:	2a03      	cmp	r2, #3
    e524:	d01d      	beq.n	e562 <matrix_test+0x7ea>
    e526:	2a04      	cmp	r2, #4
    e528:	d015      	beq.n	e556 <matrix_test+0x7de>
    e52a:	2a05      	cmp	r2, #5
    e52c:	d00d      	beq.n	e54a <matrix_test+0x7d2>
    e52e:	2a06      	cmp	r2, #6
    e530:	d005      	beq.n	e53e <matrix_test+0x7c6>
                C[i*N+j]+=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    e532:	8835      	ldrh	r5, [r6, #0]
    e534:	f93b 1b02 	ldrsh.w	r1, [fp], #2
    e538:	4426      	add	r6, r4
    e53a:	fb11 3305 	smlabb	r3, r1, r5, r3
    e53e:	8832      	ldrh	r2, [r6, #0]
    e540:	f93b 0b02 	ldrsh.w	r0, [fp], #2
    e544:	4426      	add	r6, r4
    e546:	fb10 3302 	smlabb	r3, r0, r2, r3
    e54a:	8835      	ldrh	r5, [r6, #0]
    e54c:	f93b 1b02 	ldrsh.w	r1, [fp], #2
    e550:	4426      	add	r6, r4
    e552:	fb11 3305 	smlabb	r3, r1, r5, r3
    e556:	8832      	ldrh	r2, [r6, #0]
    e558:	f93b 0b02 	ldrsh.w	r0, [fp], #2
    e55c:	4426      	add	r6, r4
    e55e:	fb10 3302 	smlabb	r3, r0, r2, r3
    e562:	8835      	ldrh	r5, [r6, #0]
    e564:	f93b 1b02 	ldrsh.w	r1, [fp], #2
    e568:	4426      	add	r6, r4
    e56a:	fb11 3305 	smlabb	r3, r1, r5, r3
    e56e:	8832      	ldrh	r2, [r6, #0]
    e570:	f93b 0b02 	ldrsh.w	r0, [fp], #2
    e574:	4426      	add	r6, r4
    e576:	fb10 3302 	smlabb	r3, r0, r2, r3
    e57a:	f93b 1b02 	ldrsh.w	r1, [fp], #2
    e57e:	8835      	ldrh	r5, [r6, #0]
            for(k=0;k<N;k++)
    e580:	45de      	cmp	lr, fp
    e582:	4426      	add	r6, r4
                C[i*N+j]+=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    e584:	fb11 3305 	smlabb	r3, r1, r5, r3
            for(k=0;k<N;k++)
    e588:	d03c      	beq.n	e604 <matrix_test+0x88c>
    e58a:	9701      	str	r7, [sp, #4]
                C[i*N+j]+=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    e58c:	465f      	mov	r7, fp
    e58e:	f9bb 0002 	ldrsh.w	r0, [fp, #2]
    e592:	f937 5b02 	ldrsh.w	r5, [r7], #2
    e596:	5b31      	ldrh	r1, [r6, r4]
    e598:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
    e59c:	8837      	ldrh	r7, [r6, #0]
    e59e:	fb15 3307 	smlabb	r3, r5, r7, r3
    e5a2:	1935      	adds	r5, r6, r4
    e5a4:	fb10 3701 	smlabb	r7, r0, r1, r3
    e5a8:	f836 6014 	ldrh.w	r6, [r6, r4, lsl #1]
    e5ac:	f9bb 1006 	ldrsh.w	r1, [fp, #6]
    e5b0:	1928      	adds	r0, r5, r4
    e5b2:	f835 5014 	ldrh.w	r5, [r5, r4, lsl #1]
    e5b6:	fb12 7306 	smlabb	r3, r2, r6, r7
    e5ba:	f9bb 6008 	ldrsh.w	r6, [fp, #8]
    e5be:	f830 7014 	ldrh.w	r7, [r0, r4, lsl #1]
    e5c2:	1902      	adds	r2, r0, r4
    e5c4:	fb11 3005 	smlabb	r0, r1, r5, r3
    e5c8:	1911      	adds	r1, r2, r4
    e5ca:	fb16 0307 	smlabb	r3, r6, r7, r0
    e5ce:	f9bb 500a 	ldrsh.w	r5, [fp, #10]
    e5d2:	f832 2014 	ldrh.w	r2, [r2, r4, lsl #1]
    e5d6:	f831 6014 	ldrh.w	r6, [r1, r4, lsl #1]
    e5da:	f9bb 000c 	ldrsh.w	r0, [fp, #12]
    e5de:	190f      	adds	r7, r1, r4
    e5e0:	f10b 0b10 	add.w	fp, fp, #16
    e5e4:	fb15 3102 	smlabb	r1, r5, r2, r3
    e5e8:	f93b 5c02 	ldrsh.w	r5, [fp, #-2]
    e5ec:	f837 2014 	ldrh.w	r2, [r7, r4, lsl #1]
    e5f0:	fb10 1306 	smlabb	r3, r0, r6, r1
            for(k=0;k<N;k++)
    e5f4:	45de      	cmp	lr, fp
    e5f6:	eb07 0644 	add.w	r6, r7, r4, lsl #1
    e5fa:	4426      	add	r6, r4
                C[i*N+j]+=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    e5fc:	fb15 3302 	smlabb	r3, r5, r2, r3
            for(k=0;k<N;k++)
    e600:	d1c4      	bne.n	e58c <matrix_test+0x814>
    e602:	9f01      	ldr	r7, [sp, #4]
    e604:	f848 3b04 	str.w	r3, [r8], #4
    e608:	3702      	adds	r7, #2
        for (j=0; j<N; j++) {
    e60a:	45b9      	cmp	r9, r7
    e60c:	f47f af75 	bne.w	e4fa <matrix_test+0x782>
    for (i=0; i<N; i++) {
    e610:	9e04      	ldr	r6, [sp, #16]
    e612:	9905      	ldr	r1, [sp, #20]
    e614:	9802      	ldr	r0, [sp, #8]
    e616:	3601      	adds	r6, #1
    e618:	42b1      	cmp	r1, r6
    e61a:	9604      	str	r6, [sp, #16]
    e61c:	4482      	add	sl, r0
    e61e:	46f4      	mov	ip, lr
    e620:	f47f af67 	bne.w	e4f2 <matrix_test+0x77a>
    e624:	f04f 0800 	mov.w	r8, #0
    e628:	9e09      	ldr	r6, [sp, #36]	; 0x24
    e62a:	f8dd 901c 	ldr.w	r9, [sp, #28]
    e62e:	f8dd b020 	ldr.w	fp, [sp, #32]
    e632:	f8dd a008 	ldr.w	sl, [sp, #8]
    e636:	9601      	str	r6, [sp, #4]
    e638:	4645      	mov	r5, r8
    e63a:	4640      	mov	r0, r8
    e63c:	46c4      	mov	ip, r8
    e63e:	eb0a 0e06 	add.w	lr, sl, r6
            cur=C[i*N+j];
    e642:	f856 2b04 	ldr.w	r2, [r6], #4
                ret+=10;
    e646:	b283      	uxth	r3, r0
            tmp+=cur;
    e648:	4494      	add	ip, r2
                ret+=10;
    e64a:	f103 070a 	add.w	r7, r3, #10
                ret += (cur>prev) ? 1 : 0;
    e64e:	42aa      	cmp	r2, r5
    e650:	bfc8      	it	gt
    e652:	3301      	addgt	r3, #1
    e654:	45cc      	cmp	ip, r9
                ret+=10;
    e656:	b23d      	sxth	r5, r7
                ret += (cur>prev) ? 1 : 0;
    e658:	b218      	sxth	r0, r3
    e65a:	f1aa 0104 	sub.w	r1, sl, #4
    e65e:	bfc4      	itt	gt
    e660:	4628      	movgt	r0, r5
    e662:	f04f 0c00 	movgt.w	ip, #0
        for (j=0; j<N; j++) {
    e666:	4576      	cmp	r6, lr
            cur=C[i*N+j];
    e668:	4615      	mov	r5, r2
    e66a:	f3c1 0281 	ubfx	r2, r1, #2, #2
        for (j=0; j<N; j++) {
    e66e:	f000 8086 	beq.w	e77e <matrix_test+0xa06>
    e672:	2a00      	cmp	r2, #0
    e674:	d038      	beq.n	e6e8 <matrix_test+0x970>
    e676:	2a01      	cmp	r2, #1
    e678:	d023      	beq.n	e6c2 <matrix_test+0x94a>
    e67a:	2a02      	cmp	r2, #2
    e67c:	d010      	beq.n	e6a0 <matrix_test+0x928>
            cur=C[i*N+j];
    e67e:	f856 3b04 	ldr.w	r3, [r6], #4
                ret+=10;
    e682:	b280      	uxth	r0, r0
    e684:	f100 070a 	add.w	r7, r0, #10
            tmp+=cur;
    e688:	449c      	add	ip, r3
                ret += (cur>prev) ? 1 : 0;
    e68a:	42ab      	cmp	r3, r5
    e68c:	bfc8      	it	gt
    e68e:	3001      	addgt	r0, #1
                ret+=10;
    e690:	b23d      	sxth	r5, r7
    e692:	45cc      	cmp	ip, r9
                ret += (cur>prev) ? 1 : 0;
    e694:	b200      	sxth	r0, r0
    e696:	bfc4      	itt	gt
    e698:	f04f 0c00 	movgt.w	ip, #0
    e69c:	4628      	movgt	r0, r5
            cur=C[i*N+j];
    e69e:	461d      	mov	r5, r3
    e6a0:	f856 1b04 	ldr.w	r1, [r6], #4
                ret+=10;
    e6a4:	b283      	uxth	r3, r0
    e6a6:	f103 020a 	add.w	r2, r3, #10
            tmp+=cur;
    e6aa:	448c      	add	ip, r1
                ret += (cur>prev) ? 1 : 0;
    e6ac:	42a9      	cmp	r1, r5
    e6ae:	bfc8      	it	gt
    e6b0:	3301      	addgt	r3, #1
                ret+=10;
    e6b2:	b217      	sxth	r7, r2
    e6b4:	45cc      	cmp	ip, r9
                ret += (cur>prev) ? 1 : 0;
    e6b6:	b218      	sxth	r0, r3
    e6b8:	bfc4      	itt	gt
    e6ba:	f04f 0c00 	movgt.w	ip, #0
    e6be:	4638      	movgt	r0, r7
            cur=C[i*N+j];
    e6c0:	460d      	mov	r5, r1
    e6c2:	f856 1b04 	ldr.w	r1, [r6], #4
                ret+=10;
    e6c6:	b280      	uxth	r0, r0
    e6c8:	f100 030a 	add.w	r3, r0, #10
            tmp+=cur;
    e6cc:	448c      	add	ip, r1
                ret += (cur>prev) ? 1 : 0;
    e6ce:	42a9      	cmp	r1, r5
    e6d0:	bfc8      	it	gt
    e6d2:	3001      	addgt	r0, #1
    e6d4:	45cc      	cmp	ip, r9
                ret+=10;
    e6d6:	b21d      	sxth	r5, r3
                ret += (cur>prev) ? 1 : 0;
    e6d8:	b200      	sxth	r0, r0
    e6da:	bfc4      	itt	gt
    e6dc:	f04f 0c00 	movgt.w	ip, #0
    e6e0:	4628      	movgt	r0, r5
        for (j=0; j<N; j++) {
    e6e2:	4576      	cmp	r6, lr
            cur=C[i*N+j];
    e6e4:	460d      	mov	r5, r1
        for (j=0; j<N; j++) {
    e6e6:	d04a      	beq.n	e77e <matrix_test+0xa06>
    e6e8:	4662      	mov	r2, ip
            cur=C[i*N+j];
    e6ea:	4637      	mov	r7, r6
                ret+=10;
    e6ec:	b280      	uxth	r0, r0
            cur=C[i*N+j];
    e6ee:	f857 cb04 	ldr.w	ip, [r7], #4
    e6f2:	6873      	ldr	r3, [r6, #4]
    e6f4:	687f      	ldr	r7, [r7, #4]
    e6f6:	68f1      	ldr	r1, [r6, #12]
            tmp+=cur;
    e6f8:	4462      	add	r2, ip
                ret += (cur>prev) ? 1 : 0;
    e6fa:	45ac      	cmp	ip, r5
    e6fc:	bfd4      	ite	le
    e6fe:	4605      	movle	r5, r0
    e700:	1c45      	addgt	r5, r0, #1
    e702:	b22d      	sxth	r5, r5
    e704:	454a      	cmp	r2, r9
                ret+=10;
    e706:	f100 000a 	add.w	r0, r0, #10
    e70a:	b200      	sxth	r0, r0
    e70c:	bfd6      	itet	le
    e70e:	4628      	movle	r0, r5
    e710:	2500      	movgt	r5, #0
    e712:	4615      	movle	r5, r2
    e714:	b282      	uxth	r2, r0
            tmp+=cur;
    e716:	441d      	add	r5, r3
                ret+=10;
    e718:	f102 000a 	add.w	r0, r2, #10
                ret += (cur>prev) ? 1 : 0;
    e71c:	4563      	cmp	r3, ip
    e71e:	bfc8      	it	gt
    e720:	3201      	addgt	r2, #1
    e722:	b212      	sxth	r2, r2
    e724:	454d      	cmp	r5, r9
                ret+=10;
    e726:	fa0f fc80 	sxth.w	ip, r0
    e72a:	bfd4      	ite	le
    e72c:	4694      	movle	ip, r2
    e72e:	2500      	movgt	r5, #0
    e730:	fa1f f08c 	uxth.w	r0, ip
    e734:	f100 0c0a 	add.w	ip, r0, #10
                ret += (cur>prev) ? 1 : 0;
    e738:	429f      	cmp	r7, r3
    e73a:	bfc8      	it	gt
    e73c:	3001      	addgt	r0, #1
            tmp+=cur;
    e73e:	197b      	adds	r3, r7, r5
    e740:	454b      	cmp	r3, r9
                ret += (cur>prev) ? 1 : 0;
    e742:	b205      	sxth	r5, r0
                ret+=10;
    e744:	fa0f f28c 	sxth.w	r2, ip
    e748:	bfd8      	it	le
    e74a:	462a      	movle	r2, r5
    e74c:	fa1f fc82 	uxth.w	ip, r2
    e750:	bfc8      	it	gt
    e752:	2300      	movgt	r3, #0
    e754:	f10c 000a 	add.w	r0, ip, #10
            tmp+=cur;
    e758:	440b      	add	r3, r1
                ret += (cur>prev) ? 1 : 0;
    e75a:	42b9      	cmp	r1, r7
    e75c:	bfc8      	it	gt
    e75e:	f10c 0c01 	addgt.w	ip, ip, #1
    e762:	fa0f f28c 	sxth.w	r2, ip
    e766:	454b      	cmp	r3, r9
    e768:	f106 0610 	add.w	r6, r6, #16
                ret+=10;
    e76c:	b200      	sxth	r0, r0
    e76e:	bfce      	itee	gt
    e770:	2200      	movgt	r2, #0
    e772:	4610      	movle	r0, r2
    e774:	461a      	movle	r2, r3
        for (j=0; j<N; j++) {
    e776:	4576      	cmp	r6, lr
            cur=C[i*N+j];
    e778:	460d      	mov	r5, r1
        for (j=0; j<N; j++) {
    e77a:	d1b6      	bne.n	e6ea <matrix_test+0x972>
    e77c:	4694      	mov	ip, r2
    for (i=0; i<N; i++) {
    e77e:	f108 0801 	add.w	r8, r8, #1
    e782:	45c3      	cmp	fp, r8
    e784:	f47f af5b 	bne.w	e63e <matrix_test+0x8c6>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    e788:	9906      	ldr	r1, [sp, #24]
    e78a:	f8cd 8014 	str.w	r8, [sp, #20]
    e78e:	f001 f873 	bl	f878 <crc16>
    e792:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
    e794:	9f03      	ldr	r7, [sp, #12]
    e796:	f8cd 901c 	str.w	r9, [sp, #28]
    e79a:	2100      	movs	r1, #0
    e79c:	9006      	str	r0, [sp, #24]
    e79e:	eb07 0b04 	add.w	fp, r7, r4
    e7a2:	9104      	str	r1, [sp, #16]
    e7a4:	46b1      	mov	r9, r6
    e7a6:	f8dd 800c 	ldr.w	r8, [sp, #12]
    e7aa:	f8dd a004 	ldr.w	sl, [sp, #4]
    e7ae:	eb04 0c09 	add.w	ip, r4, r9
    for (i=0; i<N; i++) {
        for (j=0; j<N; j++) {
            C[i*N+j]=0;
            for(k=0;k<N;k++)
            {
                MATRES tmp=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    e7b2:	464f      	mov	r7, r9
    e7b4:	f8b8 e000 	ldrh.w	lr, [r8]
    e7b8:	f937 3b02 	ldrsh.w	r3, [r7], #2
    e7bc:	ebac 0509 	sub.w	r5, ip, r9
    e7c0:	fb1e f003 	smulbb	r0, lr, r3
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    e7c4:	f3c0 0683 	ubfx	r6, r0, #2, #4
    e7c8:	f3c0 1346 	ubfx	r3, r0, #5, #7
    e7cc:	1eaa      	subs	r2, r5, #2
            for(k=0;k<N;k++)
    e7ce:	45bc      	cmp	ip, r7
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    e7d0:	fb03 f306 	mul.w	r3, r3, r6
    e7d4:	f3c2 0141 	ubfx	r1, r2, #1, #2
    e7d8:	eb08 0604 	add.w	r6, r8, r4
            for(k=0;k<N;k++)
    e7dc:	d060      	beq.n	e8a0 <matrix_test+0xb28>
    e7de:	b349      	cbz	r1, e834 <matrix_test+0xabc>
    e7e0:	2901      	cmp	r1, #1
    e7e2:	d019      	beq.n	e818 <matrix_test+0xaa0>
    e7e4:	2902      	cmp	r1, #2
    e7e6:	d00b      	beq.n	e800 <matrix_test+0xa88>
                MATRES tmp=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    e7e8:	8830      	ldrh	r0, [r6, #0]
    e7ea:	f937 5b02 	ldrsh.w	r5, [r7], #2
    e7ee:	fb10 fe05 	smulbb	lr, r0, r5
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    e7f2:	f3ce 0183 	ubfx	r1, lr, #2, #4
    e7f6:	f3ce 1246 	ubfx	r2, lr, #5, #7
    e7fa:	4426      	add	r6, r4
    e7fc:	fb02 3301 	mla	r3, r2, r1, r3
                MATRES tmp=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    e800:	8830      	ldrh	r0, [r6, #0]
    e802:	f937 5b02 	ldrsh.w	r5, [r7], #2
    e806:	fb10 fe05 	smulbb	lr, r0, r5
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    e80a:	f3ce 0183 	ubfx	r1, lr, #2, #4
    e80e:	f3ce 1246 	ubfx	r2, lr, #5, #7
    e812:	4426      	add	r6, r4
    e814:	fb02 3301 	mla	r3, r2, r1, r3
                MATRES tmp=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    e818:	f937 5b02 	ldrsh.w	r5, [r7], #2
    e81c:	8830      	ldrh	r0, [r6, #0]
    e81e:	fb10 fe05 	smulbb	lr, r0, r5
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    e822:	f3ce 0183 	ubfx	r1, lr, #2, #4
    e826:	f3ce 1246 	ubfx	r2, lr, #5, #7
            for(k=0;k<N;k++)
    e82a:	45bc      	cmp	ip, r7
    e82c:	4426      	add	r6, r4
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    e82e:	fb02 3301 	mla	r3, r2, r1, r3
            for(k=0;k<N;k++)
    e832:	d035      	beq.n	e8a0 <matrix_test+0xb28>
                MATRES tmp=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    e834:	463d      	mov	r5, r7
    e836:	8830      	ldrh	r0, [r6, #0]
    e838:	f935 2b02 	ldrsh.w	r2, [r5], #2
    e83c:	f9b7 e002 	ldrsh.w	lr, [r7, #2]
    e840:	f9b5 5002 	ldrsh.w	r5, [r5, #2]
    e844:	5b31      	ldrh	r1, [r6, r4]
    e846:	fb10 f002 	smulbb	r0, r0, r2
    e84a:	f836 2014 	ldrh.w	r2, [r6, r4, lsl #1]
    e84e:	fb11 f10e 	smulbb	r1, r1, lr
    e852:	fb12 f205 	smulbb	r2, r2, r5
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    e856:	f3c0 1e46 	ubfx	lr, r0, #5, #7
    e85a:	f3c0 0583 	ubfx	r5, r0, #2, #4
    e85e:	4426      	add	r6, r4
    e860:	fb0e 3305 	mla	r3, lr, r5, r3
    e864:	f3c1 0583 	ubfx	r5, r1, #2, #4
    e868:	f3c1 1146 	ubfx	r1, r1, #5, #7
                MATRES tmp=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    e86c:	f9b7 0006 	ldrsh.w	r0, [r7, #6]
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    e870:	fb01 3505 	mla	r5, r1, r5, r3
                MATRES tmp=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    e874:	f836 3014 	ldrh.w	r3, [r6, r4, lsl #1]
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    e878:	f3c2 0e83 	ubfx	lr, r2, #2, #4
                MATRES tmp=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    e87c:	fb13 f000 	smulbb	r0, r3, r0
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    e880:	f3c2 1246 	ubfx	r2, r2, #5, #7
    e884:	3708      	adds	r7, #8
    e886:	fb02 550e 	mla	r5, r2, lr, r5
    e88a:	eb06 0644 	add.w	r6, r6, r4, lsl #1
    e88e:	f3c0 0283 	ubfx	r2, r0, #2, #4
    e892:	f3c0 1146 	ubfx	r1, r0, #5, #7
            for(k=0;k<N;k++)
    e896:	45bc      	cmp	ip, r7
    e898:	4426      	add	r6, r4
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    e89a:	fb01 5302 	mla	r3, r1, r2, r5
            for(k=0;k<N;k++)
    e89e:	d1c9      	bne.n	e834 <matrix_test+0xabc>
    e8a0:	f108 0802 	add.w	r8, r8, #2
        for (j=0; j<N; j++) {
    e8a4:	45c3      	cmp	fp, r8
    e8a6:	f84a 3b04 	str.w	r3, [sl], #4
    e8aa:	d182      	bne.n	e7b2 <matrix_test+0xa3a>
    for (i=0; i<N; i++) {
    e8ac:	9f04      	ldr	r7, [sp, #16]
    e8ae:	9e01      	ldr	r6, [sp, #4]
    e8b0:	9d02      	ldr	r5, [sp, #8]
    e8b2:	9b05      	ldr	r3, [sp, #20]
    e8b4:	3701      	adds	r7, #1
    e8b6:	442e      	add	r6, r5
    e8b8:	42bb      	cmp	r3, r7
    e8ba:	9704      	str	r7, [sp, #16]
    e8bc:	9601      	str	r6, [sp, #4]
    e8be:	46e1      	mov	r9, ip
    e8c0:	f47f af71 	bne.w	e7a6 <matrix_test+0xa2e>
    e8c4:	f04f 0e00 	mov.w	lr, #0
    e8c8:	f8dd 901c 	ldr.w	r9, [sp, #28]
    e8cc:	9f09      	ldr	r7, [sp, #36]	; 0x24
    e8ce:	f8dd 8020 	ldr.w	r8, [sp, #32]
    e8d2:	4676      	mov	r6, lr
    e8d4:	4670      	mov	r0, lr
    e8d6:	46f2      	mov	sl, lr
    e8d8:	46ac      	mov	ip, r5
            cur=C[i*N+j];
    e8da:	463c      	mov	r4, r7
                ret+=10;
    e8dc:	b280      	uxth	r0, r0
            cur=C[i*N+j];
    e8de:	f854 2b04 	ldr.w	r2, [r4], #4
                ret += (cur>prev) ? 1 : 0;
    e8e2:	4552      	cmp	r2, sl
    e8e4:	bfd4      	ite	le
    e8e6:	4601      	movle	r1, r0
    e8e8:	1c41      	addgt	r1, r0, #1
            tmp+=cur;
    e8ea:	4416      	add	r6, r2
    e8ec:	454e      	cmp	r6, r9
                ret += (cur>prev) ? 1 : 0;
    e8ee:	fa0f fa81 	sxth.w	sl, r1
                ret+=10;
    e8f2:	f100 000a 	add.w	r0, r0, #10
    e8f6:	4467      	add	r7, ip
    e8f8:	b200      	sxth	r0, r0
    e8fa:	f1ac 0504 	sub.w	r5, ip, #4
    e8fe:	bfd4      	ite	le
    e900:	4650      	movle	r0, sl
    e902:	2600      	movgt	r6, #0
        for (j=0; j<N; j++) {
    e904:	42a7      	cmp	r7, r4
            cur=C[i*N+j];
    e906:	4692      	mov	sl, r2
    e908:	f3c5 0381 	ubfx	r3, r5, #2, #2
        for (j=0; j<N; j++) {
    e90c:	f000 808b 	beq.w	ea26 <matrix_test+0xcae>
    e910:	2b00      	cmp	r3, #0
    e912:	d03c      	beq.n	e98e <matrix_test+0xc16>
    e914:	2b01      	cmp	r3, #1
    e916:	d025      	beq.n	e964 <matrix_test+0xbec>
    e918:	2b02      	cmp	r3, #2
    e91a:	d012      	beq.n	e942 <matrix_test+0xbca>
            cur=C[i*N+j];
    e91c:	f854 1b04 	ldr.w	r1, [r4], #4
                ret+=10;
    e920:	fa1f fb80 	uxth.w	fp, r0
    e924:	f10b 000a 	add.w	r0, fp, #10
            tmp+=cur;
    e928:	440e      	add	r6, r1
                ret += (cur>prev) ? 1 : 0;
    e92a:	4291      	cmp	r1, r2
    e92c:	bfc8      	it	gt
    e92e:	f10b 0b01 	addgt.w	fp, fp, #1
                ret+=10;
    e932:	b202      	sxth	r2, r0
    e934:	454e      	cmp	r6, r9
                ret += (cur>prev) ? 1 : 0;
    e936:	fa0f f08b 	sxth.w	r0, fp
    e93a:	bfc4      	itt	gt
    e93c:	2600      	movgt	r6, #0
    e93e:	4610      	movgt	r0, r2
            cur=C[i*N+j];
    e940:	468a      	mov	sl, r1
    e942:	f854 5b04 	ldr.w	r5, [r4], #4
                ret+=10;
    e946:	b283      	uxth	r3, r0
    e948:	f103 010a 	add.w	r1, r3, #10
            tmp+=cur;
    e94c:	442e      	add	r6, r5
                ret += (cur>prev) ? 1 : 0;
    e94e:	4555      	cmp	r5, sl
    e950:	bfc8      	it	gt
    e952:	3301      	addgt	r3, #1
                ret+=10;
    e954:	fa0f fa81 	sxth.w	sl, r1
    e958:	454e      	cmp	r6, r9
                ret += (cur>prev) ? 1 : 0;
    e95a:	b218      	sxth	r0, r3
    e95c:	bfc4      	itt	gt
    e95e:	2600      	movgt	r6, #0
    e960:	4650      	movgt	r0, sl
            cur=C[i*N+j];
    e962:	46aa      	mov	sl, r5
    e964:	f854 5b04 	ldr.w	r5, [r4], #4
                ret+=10;
    e968:	fa1f fb80 	uxth.w	fp, r0
    e96c:	f10b 000a 	add.w	r0, fp, #10
            tmp+=cur;
    e970:	442e      	add	r6, r5
                ret += (cur>prev) ? 1 : 0;
    e972:	4555      	cmp	r5, sl
    e974:	bfc8      	it	gt
    e976:	f10b 0b01 	addgt.w	fp, fp, #1
                ret+=10;
    e97a:	b202      	sxth	r2, r0
    e97c:	454e      	cmp	r6, r9
                ret += (cur>prev) ? 1 : 0;
    e97e:	fa0f f08b 	sxth.w	r0, fp
    e982:	bfc4      	itt	gt
    e984:	2600      	movgt	r6, #0
    e986:	4610      	movgt	r0, r2
        for (j=0; j<N; j++) {
    e988:	42a7      	cmp	r7, r4
            cur=C[i*N+j];
    e98a:	46aa      	mov	sl, r5
        for (j=0; j<N; j++) {
    e98c:	d04b      	beq.n	ea26 <matrix_test+0xcae>
            cur=C[i*N+j];
    e98e:	4621      	mov	r1, r4
                ret+=10;
    e990:	b283      	uxth	r3, r0
            cur=C[i*N+j];
    e992:	f851 5b04 	ldr.w	r5, [r1], #4
    e996:	6860      	ldr	r0, [r4, #4]
    e998:	6849      	ldr	r1, [r1, #4]
    e99a:	68e2      	ldr	r2, [r4, #12]
                ret += (cur>prev) ? 1 : 0;
    e99c:	4555      	cmp	r5, sl
    e99e:	bfd4      	ite	le
    e9a0:	469b      	movle	fp, r3
    e9a2:	f103 0b01 	addgt.w	fp, r3, #1
            tmp+=cur;
    e9a6:	442e      	add	r6, r5
    e9a8:	454e      	cmp	r6, r9
                ret += (cur>prev) ? 1 : 0;
    e9aa:	fa0f fa8b 	sxth.w	sl, fp
                ret+=10;
    e9ae:	f103 030a 	add.w	r3, r3, #10
    e9b2:	b21b      	sxth	r3, r3
    e9b4:	bfd4      	ite	le
    e9b6:	4653      	movle	r3, sl
    e9b8:	2600      	movgt	r6, #0
    e9ba:	fa1f fb83 	uxth.w	fp, r3
            tmp+=cur;
    e9be:	4406      	add	r6, r0
                ret+=10;
    e9c0:	f10b 030a 	add.w	r3, fp, #10
                ret += (cur>prev) ? 1 : 0;
    e9c4:	42a8      	cmp	r0, r5
    e9c6:	bfc8      	it	gt
    e9c8:	f10b 0b01 	addgt.w	fp, fp, #1
    e9cc:	454e      	cmp	r6, r9
                ret+=10;
    e9ce:	b21d      	sxth	r5, r3
                ret += (cur>prev) ? 1 : 0;
    e9d0:	fa0f fa8b 	sxth.w	sl, fp
    e9d4:	bfc4      	itt	gt
    e9d6:	46aa      	movgt	sl, r5
    e9d8:	2600      	movgt	r6, #0
                ret+=10;
    e9da:	fa1f fb8a 	uxth.w	fp, sl
                ret += (cur>prev) ? 1 : 0;
    e9de:	4281      	cmp	r1, r0
    e9e0:	bfd4      	ite	le
    e9e2:	4658      	movle	r0, fp
    e9e4:	f10b 0001 	addgt.w	r0, fp, #1
            tmp+=cur;
    e9e8:	198b      	adds	r3, r1, r6
    e9ea:	454b      	cmp	r3, r9
                ret += (cur>prev) ? 1 : 0;
    e9ec:	fa0f fa80 	sxth.w	sl, r0
                ret+=10;
    e9f0:	f10b 050a 	add.w	r5, fp, #10
    e9f4:	fa0f fb85 	sxth.w	fp, r5
    e9f8:	bfda      	itte	le
    e9fa:	46d3      	movle	fp, sl
    e9fc:	461e      	movle	r6, r3
    e9fe:	2600      	movgt	r6, #0
    ea00:	fa1f f58b 	uxth.w	r5, fp
    ea04:	f105 000a 	add.w	r0, r5, #10
            tmp+=cur;
    ea08:	4416      	add	r6, r2
                ret += (cur>prev) ? 1 : 0;
    ea0a:	428a      	cmp	r2, r1
    ea0c:	bfc8      	it	gt
    ea0e:	3501      	addgt	r5, #1
    ea10:	3410      	adds	r4, #16
    ea12:	454e      	cmp	r6, r9
                ret+=10;
    ea14:	b201      	sxth	r1, r0
    ea16:	bfc8      	it	gt
    ea18:	2600      	movgt	r6, #0
                ret += (cur>prev) ? 1 : 0;
    ea1a:	b228      	sxth	r0, r5
    ea1c:	bfc8      	it	gt
    ea1e:	4608      	movgt	r0, r1
        for (j=0; j<N; j++) {
    ea20:	42a7      	cmp	r7, r4
            cur=C[i*N+j];
    ea22:	4692      	mov	sl, r2
        for (j=0; j<N; j++) {
    ea24:	d1b3      	bne.n	e98e <matrix_test+0xc16>
    for (i=0; i<N; i++) {
    ea26:	f10e 0401 	add.w	r4, lr, #1
    ea2a:	45a0      	cmp	r8, r4
    ea2c:	d001      	beq.n	ea32 <matrix_test+0xcba>
    ea2e:	46a6      	mov	lr, r4
    ea30:	e753      	b.n	e8da <matrix_test+0xb62>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    ea32:	9906      	ldr	r1, [sp, #24]
    ea34:	f8cd e01c 	str.w	lr, [sp, #28]
    ea38:	f000 ff1e 	bl	f878 <crc16>
    ea3c:	9008      	str	r0, [sp, #32]
    ea3e:	980b      	ldr	r0, [sp, #44]	; 0x2c
    ea40:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    matrix_add_const(N,A,-val); /* return matrix to initial value */
    ea42:	f04f 0a00 	mov.w	sl, #0
    ea46:	0066      	lsls	r6, r4, #1
    ea48:	46d1      	mov	r9, sl
    ea4a:	9604      	str	r6, [sp, #16]
    ea4c:	4683      	mov	fp, r0
    ea4e:	e0da      	b.n	ec06 <matrix_test+0xe8e>
            A[i*N+j] += val;
    ea50:	f8bb 5000 	ldrh.w	r5, [fp]
    matrix_add_const(N,A,-val); /* return matrix to initial value */
    ea54:	4621      	mov	r1, r4
            A[i*N+j] += val;
    ea56:	1aae      	subs	r6, r5, r2
    ea58:	2901      	cmp	r1, #1
    ea5a:	f8ab 6000 	strh.w	r6, [fp]
    ea5e:	f000 80ea 	beq.w	ec36 <matrix_test+0xebe>
    ea62:	f8bb 7002 	ldrh.w	r7, [fp, #2]
    ea66:	2902      	cmp	r1, #2
    ea68:	eba7 0302 	sub.w	r3, r7, r2
    ea6c:	f8ab 3002 	strh.w	r3, [fp, #2]
    ea70:	f000 80e1 	beq.w	ec36 <matrix_test+0xebe>
    ea74:	f8bb 5004 	ldrh.w	r5, [fp, #4]
    ea78:	2903      	cmp	r1, #3
    ea7a:	eba5 0602 	sub.w	r6, r5, r2
    ea7e:	f8ab 6004 	strh.w	r6, [fp, #4]
    ea82:	f000 80d8 	beq.w	ec36 <matrix_test+0xebe>
    ea86:	f8bb 7006 	ldrh.w	r7, [fp, #6]
    ea8a:	1abb      	subs	r3, r7, r2
    ea8c:	f8ab 3006 	strh.w	r3, [fp, #6]
        for (j=0; j<N; j++) {
    ea90:	2304      	movs	r3, #4
    ea92:	428c      	cmp	r4, r1
    ea94:	f000 80b0 	beq.w	ebf8 <matrix_test+0xe80>
    ea98:	1a65      	subs	r5, r4, r1
    ea9a:	1f2e      	subs	r6, r5, #4
    ea9c:	9503      	str	r5, [sp, #12]
    ea9e:	08b5      	lsrs	r5, r6, #2
    eaa0:	9e07      	ldr	r6, [sp, #28]
    eaa2:	1c6f      	adds	r7, r5, #1
    eaa4:	1a76      	subs	r6, r6, r1
    eaa6:	9701      	str	r7, [sp, #4]
    eaa8:	2e02      	cmp	r6, #2
    eaaa:	ea4f 0787 	mov.w	r7, r7, lsl #2
    eaae:	9702      	str	r7, [sp, #8]
    eab0:	f240 8087 	bls.w	ebc2 <matrix_test+0xe4a>
    eab4:	4451      	add	r1, sl
    eab6:	eb00 0641 	add.w	r6, r0, r1, lsl #1
            A[i*N+j] += val;
    eaba:	f850 e011 	ldr.w	lr, [r0, r1, lsl #1]
    eabe:	9105      	str	r1, [sp, #20]
    eac0:	ebae 0102 	sub.w	r1, lr, r2
    eac4:	9106      	str	r1, [sp, #24]
    eac6:	6871      	ldr	r1, [r6, #4]
    eac8:	eba1 0802 	sub.w	r8, r1, r2
    eacc:	9906      	ldr	r1, [sp, #24]
    eace:	2700      	movs	r7, #0
    ead0:	46bc      	mov	ip, r7
    ead2:	ebc2 4e1e 	rsb	lr, r2, lr, lsr #16
    ead6:	f361 070f 	bfi	r7, r1, #0, #16
    eada:	f36e 471f 	bfi	r7, lr, #16, #16
    eade:	f005 0e01 	and.w	lr, r5, #1
    eae2:	9d05      	ldr	r5, [sp, #20]
    eae4:	6871      	ldr	r1, [r6, #4]
    eae6:	f840 7015 	str.w	r7, [r0, r5, lsl #1]
    eaea:	9d01      	ldr	r5, [sp, #4]
    eaec:	ebc2 4111 	rsb	r1, r2, r1, lsr #16
    eaf0:	f368 0c0f 	bfi	ip, r8, #0, #16
    eaf4:	2701      	movs	r7, #1
    eaf6:	f361 4c1f 	bfi	ip, r1, #16, #16
    eafa:	42bd      	cmp	r5, r7
    eafc:	f106 0108 	add.w	r1, r6, #8
    eb00:	f8c6 c004 	str.w	ip, [r6, #4]
    eb04:	d958      	bls.n	ebb8 <matrix_test+0xe40>
    eb06:	f1be 0f00 	cmp.w	lr, #0
    eb0a:	d01b      	beq.n	eb44 <matrix_test+0xdcc>
    eb0c:	680f      	ldr	r7, [r1, #0]
    eb0e:	684e      	ldr	r6, [r1, #4]
    eb10:	2500      	movs	r5, #0
    eb12:	eba7 0c02 	sub.w	ip, r7, r2
    eb16:	46ae      	mov	lr, r5
    eb18:	ebc2 4817 	rsb	r8, r2, r7, lsr #16
    eb1c:	1ab7      	subs	r7, r6, r2
    eb1e:	f367 0e0f 	bfi	lr, r7, #0, #16
    eb22:	ebc2 4616 	rsb	r6, r2, r6, lsr #16
    eb26:	f36c 050f 	bfi	r5, ip, #0, #16
    eb2a:	f368 451f 	bfi	r5, r8, #16, #16
    eb2e:	f366 4e1f 	bfi	lr, r6, #16, #16
    eb32:	e881 4020 	stmia.w	r1, {r5, lr}
    eb36:	9d01      	ldr	r5, [sp, #4]
    eb38:	2702      	movs	r7, #2
    eb3a:	42bd      	cmp	r5, r7
    eb3c:	460e      	mov	r6, r1
    eb3e:	f101 0108 	add.w	r1, r1, #8
    eb42:	d939      	bls.n	ebb8 <matrix_test+0xe40>
    eb44:	9405      	str	r4, [sp, #20]
    eb46:	9306      	str	r3, [sp, #24]
    eb48:	68b5      	ldr	r5, [r6, #8]
    eb4a:	f106 0e08 	add.w	lr, r6, #8
    eb4e:	68f6      	ldr	r6, [r6, #12]
    eb50:	2400      	movs	r4, #0
    eb52:	1ab3      	subs	r3, r6, r2
    eb54:	eba5 0802 	sub.w	r8, r5, r2
    eb58:	46a4      	mov	ip, r4
    eb5a:	ebc2 4616 	rsb	r6, r2, r6, lsr #16
    eb5e:	f363 0c0f 	bfi	ip, r3, #0, #16
    eb62:	f368 040f 	bfi	r4, r8, #0, #16
    eb66:	ebc2 4515 	rsb	r5, r2, r5, lsr #16
    eb6a:	f366 4c1f 	bfi	ip, r6, #16, #16
    eb6e:	f365 441f 	bfi	r4, r5, #16, #16
    eb72:	e881 1010 	stmia.w	r1, {r4, ip}
    eb76:	f10e 0608 	add.w	r6, lr, #8
    eb7a:	f8de e008 	ldr.w	lr, [lr, #8]
    eb7e:	6873      	ldr	r3, [r6, #4]
    eb80:	2400      	movs	r4, #0
    eb82:	ebae 0802 	sub.w	r8, lr, r2
    eb86:	46a4      	mov	ip, r4
    eb88:	ebc2 4e1e 	rsb	lr, r2, lr, lsr #16
    eb8c:	f368 040f 	bfi	r4, r8, #0, #16
    eb90:	f36e 441f 	bfi	r4, lr, #16, #16
    eb94:	1a9d      	subs	r5, r3, r2
    eb96:	608c      	str	r4, [r1, #8]
    eb98:	9c01      	ldr	r4, [sp, #4]
    eb9a:	f365 0c0f 	bfi	ip, r5, #0, #16
    eb9e:	ebc2 4313 	rsb	r3, r2, r3, lsr #16
    eba2:	3702      	adds	r7, #2
    eba4:	f363 4c1f 	bfi	ip, r3, #16, #16
    eba8:	42bc      	cmp	r4, r7
    ebaa:	f8c1 c00c 	str.w	ip, [r1, #12]
    ebae:	f101 0110 	add.w	r1, r1, #16
    ebb2:	d8c9      	bhi.n	eb48 <matrix_test+0xdd0>
    ebb4:	9c05      	ldr	r4, [sp, #20]
    ebb6:	9b06      	ldr	r3, [sp, #24]
    ebb8:	9902      	ldr	r1, [sp, #8]
    ebba:	9e03      	ldr	r6, [sp, #12]
    ebbc:	42b1      	cmp	r1, r6
    ebbe:	440b      	add	r3, r1
    ebc0:	d01a      	beq.n	ebf8 <matrix_test+0xe80>
    ebc2:	eb0a 0803 	add.w	r8, sl, r3
        for (j=0; j<N; j++) {
    ebc6:	1c59      	adds	r1, r3, #1
            A[i*N+j] += val;
    ebc8:	f830 5018 	ldrh.w	r5, [r0, r8, lsl #1]
        for (j=0; j<N; j++) {
    ebcc:	428c      	cmp	r4, r1
            A[i*N+j] += val;
    ebce:	eba5 0702 	sub.w	r7, r5, r2
    ebd2:	f820 7018 	strh.w	r7, [r0, r8, lsl #1]
        for (j=0; j<N; j++) {
    ebd6:	d90f      	bls.n	ebf8 <matrix_test+0xe80>
            A[i*N+j] += val;
    ebd8:	4451      	add	r1, sl
        for (j=0; j<N; j++) {
    ebda:	3302      	adds	r3, #2
            A[i*N+j] += val;
    ebdc:	f830 6011 	ldrh.w	r6, [r0, r1, lsl #1]
        for (j=0; j<N; j++) {
    ebe0:	429c      	cmp	r4, r3
            A[i*N+j] += val;
    ebe2:	eba6 0502 	sub.w	r5, r6, r2
    ebe6:	f820 5011 	strh.w	r5, [r0, r1, lsl #1]
        for (j=0; j<N; j++) {
    ebea:	d905      	bls.n	ebf8 <matrix_test+0xe80>
            A[i*N+j] += val;
    ebec:	4453      	add	r3, sl
    ebee:	f830 1013 	ldrh.w	r1, [r0, r3, lsl #1]
    ebf2:	1a8f      	subs	r7, r1, r2
    ebf4:	f820 7013 	strh.w	r7, [r0, r3, lsl #1]
    for (i=0; i<N; i++) {
    ebf8:	f109 0901 	add.w	r9, r9, #1
    ebfc:	9b04      	ldr	r3, [sp, #16]
    ebfe:	45a1      	cmp	r9, r4
    ec00:	449b      	add	fp, r3
    ec02:	44a2      	add	sl, r4
    ec04:	d02a      	beq.n	ec5c <matrix_test+0xee4>
    ec06:	ea4f 075b 	mov.w	r7, fp, lsr #1
    ec0a:	427b      	negs	r3, r7
    ec0c:	f003 0303 	and.w	r3, r3, #3
    ec10:	42a3      	cmp	r3, r4
    ec12:	bf28      	it	cs
    ec14:	4623      	movcs	r3, r4
    ec16:	2c04      	cmp	r4, #4
    ec18:	f67f af1a 	bls.w	ea50 <matrix_test+0xcd8>
    matrix_add_const(N,A,-val); /* return matrix to initial value */
    ec1c:	4619      	mov	r1, r3
    ec1e:	2b00      	cmp	r3, #0
    ec20:	f43f af3a 	beq.w	ea98 <matrix_test+0xd20>
            A[i*N+j] += val;
    ec24:	f8bb 5000 	ldrh.w	r5, [fp]
    ec28:	2901      	cmp	r1, #1
    ec2a:	eba5 0602 	sub.w	r6, r5, r2
    ec2e:	f8ab 6000 	strh.w	r6, [fp]
    ec32:	f47f af16 	bne.w	ea62 <matrix_test+0xcea>
        for (j=0; j<N; j++) {
    ec36:	460b      	mov	r3, r1
    ec38:	e72b      	b.n	ea92 <matrix_test+0xd1a>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    ec3a:	4601      	mov	r1, r0
    ec3c:	4604      	mov	r4, r0
    ec3e:	f000 fe1b 	bl	f878 <crc16>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    ec42:	4601      	mov	r1, r0
    ec44:	4620      	mov	r0, r4
    ec46:	f000 fe17 	bl	f878 <crc16>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    ec4a:	4601      	mov	r1, r0
    ec4c:	4620      	mov	r0, r4
    ec4e:	f000 fe13 	bl	f878 <crc16>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    ec52:	4601      	mov	r1, r0
    ec54:	4620      	mov	r0, r4
    ec56:	f000 fe0f 	bl	f878 <crc16>
    ec5a:	9008      	str	r0, [sp, #32]
    return crc;
    ec5c:	f9bd 0020 	ldrsh.w	r0, [sp, #32]
}
    ec60:	b011      	add	sp, #68	; 0x44
    ec62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ec66:	bf00      	nop

0000ec68 <core_bench_matrix>:
ee_u16 core_bench_matrix(mat_params *p, ee_s16 seed, ee_u16 crc) {
    ec68:	b530      	push	{r4, r5, lr}
    ec6a:	4614      	mov	r4, r2
    crc=crc16(matrix_test(N,C,A,B,val),crc);
    ec6c:	c82d      	ldmia	r0, {r0, r2, r3, r5}
ee_u16 core_bench_matrix(mat_params *p, ee_s16 seed, ee_u16 crc) {
    ec6e:	b083      	sub	sp, #12
    crc=crc16(matrix_test(N,C,A,B,val),crc);
    ec70:	9100      	str	r1, [sp, #0]
    ec72:	4629      	mov	r1, r5
    ec74:	f7ff f880 	bl	dd78 <matrix_test>
    ec78:	4621      	mov	r1, r4
}
    ec7a:	b003      	add	sp, #12
    ec7c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    crc=crc16(matrix_test(N,C,A,B,val),crc);
    ec80:	f000 bdfa 	b.w	f878 <crc16>

0000ec84 <core_init_matrix>:
ee_u32 core_init_matrix(ee_u32 blksize, void *memblk, ee_s32 seed, mat_params *p) {
    ec84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ec88:	b087      	sub	sp, #28
        seed=1;
    ec8a:	2a00      	cmp	r2, #0
    ec8c:	bf08      	it	eq
    ec8e:	2201      	moveq	r2, #1
ee_u32 core_init_matrix(ee_u32 blksize, void *memblk, ee_s32 seed, mat_params *p) {
    ec90:	9305      	str	r3, [sp, #20]
    while (j<blksize) {
    ec92:	2800      	cmp	r0, #0
    ec94:	f000 810c 	beq.w	eeb0 <core_init_matrix+0x22c>
    ec98:	4684      	mov	ip, r0
    ec9a:	2000      	movs	r0, #0
    ec9c:	e000      	b.n	eca0 <core_init_matrix+0x1c>
        i++;
    ec9e:	4630      	mov	r0, r6
    eca0:	1c46      	adds	r6, r0, #1
        j=i*i*2*4;
    eca2:	fb06 f706 	mul.w	r7, r6, r6
    while (j<blksize) {
    eca6:	ebbc 0fc7 	cmp.w	ip, r7, lsl #3
    ecaa:	d8f8      	bhi.n	ec9e <core_init_matrix+0x1a>
    A=(MATDAT *)align_mem(memblk);
    ecac:	f101 38ff 	add.w	r8, r1, #4294967295
    ecb0:	f028 0403 	bic.w	r4, r8, #3
    ecb4:	3404      	adds	r4, #4
    B=A+N*N;
    ecb6:	fb00 f300 	mul.w	r3, r0, r0
    ecba:	0059      	lsls	r1, r3, #1
    ecbc:	4627      	mov	r7, r4
    ecbe:	440f      	add	r7, r1
    A=(MATDAT *)align_mem(memblk);
    ecc0:	9401      	str	r4, [sp, #4]
    B=A+N*N;
    ecc2:	9103      	str	r1, [sp, #12]
    ecc4:	9702      	str	r7, [sp, #8]
    ecc6:	9004      	str	r0, [sp, #16]
    for (i=0; i<N; i++) {
    ecc8:	2800      	cmp	r0, #0
    ecca:	f000 80de 	beq.w	ee8a <core_init_matrix+0x206>
    N=i-1;
    ecce:	2400      	movs	r4, #0
    ecd0:	9400      	str	r4, [sp, #0]
    ecd2:	2601      	movs	r6, #1
            seed = ( ( order * seed ) % 65536 );
    ecd4:	fb06 f202 	mul.w	r2, r6, r2
    ecd8:	f1d2 0900 	rsbs	r9, r2, #0
    ecdc:	fa1f f389 	uxth.w	r3, r9
    ece0:	9f00      	ldr	r7, [sp, #0]
    ece2:	9901      	ldr	r1, [sp, #4]
            val = (seed + order);
    ece4:	fa1f fa86 	uxth.w	sl, r6
            seed = ( ( order * seed ) % 65536 );
    ece8:	b292      	uxth	r2, r2
    ecea:	bf58      	it	pl
    ecec:	425a      	negpl	r2, r3
            val = (seed + order);
    ecee:	eb0a 0502 	add.w	r5, sl, r2
    ecf2:	fb00 f707 	mul.w	r7, r0, r7
    ecf6:	9b02      	ldr	r3, [sp, #8]
    ecf8:	fa1f fe85 	uxth.w	lr, r5
    ecfc:	007c      	lsls	r4, r7, #1
    ecfe:	191d      	adds	r5, r3, r4
        for (j=0; j<N; j++) {
    ed00:	f04f 0b01 	mov.w	fp, #1
            B[i*N+j] = val;
    ed04:	f823 e017 	strh.w	lr, [r3, r7, lsl #1]
            val =  (val + order);
    ed08:	44f2      	add	sl, lr
            A[i*N+j] = val;
    ed0a:	9b01      	ldr	r3, [sp, #4]
    ed0c:	440c      	add	r4, r1
    ed0e:	f100 38ff 	add.w	r8, r0, #4294967295
            val=matrix_clip(val,1);
    ed12:	fa5f fc8a 	uxtb.w	ip, sl
        for (j=0; j<N; j++) {
    ed16:	4583      	cmp	fp, r0
    ed18:	f008 0103 	and.w	r1, r8, #3
            order++;
    ed1c:	445e      	add	r6, fp
            A[i*N+j] = val;
    ed1e:	f823 c017 	strh.w	ip, [r3, r7, lsl #1]
    ed22:	f105 0902 	add.w	r9, r5, #2
    ed26:	f104 0802 	add.w	r8, r4, #2
        for (j=0; j<N; j++) {
    ed2a:	f080 80a7 	bcs.w	ee7c <core_init_matrix+0x1f8>
    ed2e:	2900      	cmp	r1, #0
    ed30:	d045      	beq.n	edbe <core_init_matrix+0x13a>
    ed32:	2901      	cmp	r1, #1
    ed34:	d02c      	beq.n	ed90 <core_init_matrix+0x10c>
    ed36:	2902      	cmp	r1, #2
    ed38:	d016      	beq.n	ed68 <core_init_matrix+0xe4>
            seed = ( ( order * seed ) % 65536 );
    ed3a:	fb06 f202 	mul.w	r2, r6, r2
    ed3e:	4257      	negs	r7, r2
    ed40:	b2b9      	uxth	r1, r7
            val = (seed + order);
    ed42:	b2b3      	uxth	r3, r6
            seed = ( ( order * seed ) % 65536 );
    ed44:	b292      	uxth	r2, r2
    ed46:	bf58      	it	pl
    ed48:	424a      	negpl	r2, r1
            val = (seed + order);
    ed4a:	189f      	adds	r7, r3, r2
    ed4c:	fa1f fb87 	uxth.w	fp, r7
            val =  (val + order);
    ed50:	445b      	add	r3, fp
            val=matrix_clip(val,1);
    ed52:	b2d9      	uxtb	r1, r3
            B[i*N+j] = val;
    ed54:	f8a5 b002 	strh.w	fp, [r5, #2]
    ed58:	f109 0902 	add.w	r9, r9, #2
    ed5c:	f108 0802 	add.w	r8, r8, #2
            order++;
    ed60:	3601      	adds	r6, #1
        for (j=0; j<N; j++) {
    ed62:	f04f 0b02 	mov.w	fp, #2
            A[i*N+j] = val;
    ed66:	8061      	strh	r1, [r4, #2]
            seed = ( ( order * seed ) % 65536 );
    ed68:	fb06 f202 	mul.w	r2, r6, r2
    ed6c:	4254      	negs	r4, r2
    ed6e:	b2a5      	uxth	r5, r4
            val = (seed + order);
    ed70:	b2b3      	uxth	r3, r6
            seed = ( ( order * seed ) % 65536 );
    ed72:	b292      	uxth	r2, r2
    ed74:	bf58      	it	pl
    ed76:	426a      	negpl	r2, r5
            val = (seed + order);
    ed78:	189f      	adds	r7, r3, r2
    ed7a:	fa1f fa87 	uxth.w	sl, r7
            val =  (val + order);
    ed7e:	4453      	add	r3, sl
            val=matrix_clip(val,1);
    ed80:	b2d9      	uxtb	r1, r3
            B[i*N+j] = val;
    ed82:	f829 ab02 	strh.w	sl, [r9], #2
            A[i*N+j] = val;
    ed86:	f828 1b02 	strh.w	r1, [r8], #2
        for (j=0; j<N; j++) {
    ed8a:	f10b 0b01 	add.w	fp, fp, #1
            order++;
    ed8e:	3601      	adds	r6, #1
            seed = ( ( order * seed ) % 65536 );
    ed90:	fb06 f202 	mul.w	r2, r6, r2
    ed94:	4254      	negs	r4, r2
    ed96:	b2a5      	uxth	r5, r4
            val = (seed + order);
    ed98:	b2b3      	uxth	r3, r6
            seed = ( ( order * seed ) % 65536 );
    ed9a:	b292      	uxth	r2, r2
    ed9c:	bf58      	it	pl
    ed9e:	426a      	negpl	r2, r5
            val = (seed + order);
    eda0:	189f      	adds	r7, r3, r2
    eda2:	fa1f fc87 	uxth.w	ip, r7
            val =  (val + order);
    eda6:	4463      	add	r3, ip
        for (j=0; j<N; j++) {
    eda8:	f10b 0b01 	add.w	fp, fp, #1
            val=matrix_clip(val,1);
    edac:	b2d9      	uxtb	r1, r3
        for (j=0; j<N; j++) {
    edae:	4583      	cmp	fp, r0
            B[i*N+j] = val;
    edb0:	f829 cb02 	strh.w	ip, [r9], #2
            order++;
    edb4:	f106 0601 	add.w	r6, r6, #1
            A[i*N+j] = val;
    edb8:	f828 1b02 	strh.w	r1, [r8], #2
        for (j=0; j<N; j++) {
    edbc:	d25e      	bcs.n	ee7c <core_init_matrix+0x1f8>
            seed = ( ( order * seed ) % 65536 );
    edbe:	fb06 f202 	mul.w	r2, r6, r2
    edc2:	4254      	negs	r4, r2
    edc4:	b2a5      	uxth	r5, r4
    edc6:	fa1f fe82 	uxth.w	lr, r2
            order++;
    edca:	f106 0401 	add.w	r4, r6, #1
            seed = ( ( order * seed ) % 65536 );
    edce:	bf58      	it	pl
    edd0:	f1c5 0e00 	rsbpl	lr, r5, #0
    edd4:	fb04 f20e 	mul.w	r2, r4, lr
    edd8:	f1d2 0a00 	rsbs	sl, r2, #0
    eddc:	fa1f f38a 	uxth.w	r3, sl
    ede0:	b291      	uxth	r1, r2
            order++;
    ede2:	f106 0702 	add.w	r7, r6, #2
            seed = ( ( order * seed ) % 65536 );
    ede6:	bf58      	it	pl
    ede8:	4259      	negpl	r1, r3
    edea:	fb07 f501 	mul.w	r5, r7, r1
    edee:	f1d5 0c00 	rsbs	ip, r5, #0
    edf2:	fa1f f28c 	uxth.w	r2, ip
    edf6:	b2ab      	uxth	r3, r5
    edf8:	bf58      	it	pl
    edfa:	4253      	negpl	r3, r2
            order++;
    edfc:	1cf5      	adds	r5, r6, #3
            seed = ( ( order * seed ) % 65536 );
    edfe:	fb05 f203 	mul.w	r2, r5, r3
    ee02:	f1d2 0a00 	rsbs	sl, r2, #0
            val = (seed + order);
    ee06:	fa1f fc86 	uxth.w	ip, r6
            seed = ( ( order * seed ) % 65536 );
    ee0a:	fa1f fa8a 	uxth.w	sl, sl
            val = (seed + order);
    ee0e:	44e6      	add	lr, ip
            seed = ( ( order * seed ) % 65536 );
    ee10:	b292      	uxth	r2, r2
    ee12:	bf58      	it	pl
    ee14:	f1ca 0200 	rsbpl	r2, sl, #0
            B[i*N+j] = val;
    ee18:	46ca      	mov	sl, r9
            val = (seed + order);
    ee1a:	fa1f fe8e 	uxth.w	lr, lr
            B[i*N+j] = val;
    ee1e:	f82a eb02 	strh.w	lr, [sl], #2
            val =  (val + order);
    ee22:	44f4      	add	ip, lr
            A[i*N+j] = val;
    ee24:	46c6      	mov	lr, r8
            val = (seed + order);
    ee26:	b2a4      	uxth	r4, r4
    ee28:	b2bf      	uxth	r7, r7
    ee2a:	b2ad      	uxth	r5, r5
            val=matrix_clip(val,1);
    ee2c:	fa5f fc8c 	uxtb.w	ip, ip
            A[i*N+j] = val;
    ee30:	f82e cb02 	strh.w	ip, [lr], #2
            val = (seed + order);
    ee34:	4421      	add	r1, r4
    ee36:	443b      	add	r3, r7
    ee38:	eb05 0c02 	add.w	ip, r5, r2
    ee3c:	b289      	uxth	r1, r1
    ee3e:	b29b      	uxth	r3, r3
    ee40:	fa1f fc8c 	uxth.w	ip, ip
            val =  (val + order);
    ee44:	440c      	add	r4, r1
    ee46:	441f      	add	r7, r3
    ee48:	4465      	add	r5, ip
        for (j=0; j<N; j++) {
    ee4a:	f10b 0b04 	add.w	fp, fp, #4
            val=matrix_clip(val,1);
    ee4e:	b2e4      	uxtb	r4, r4
    ee50:	b2ff      	uxtb	r7, r7
    ee52:	b2ed      	uxtb	r5, r5
        for (j=0; j<N; j++) {
    ee54:	4583      	cmp	fp, r0
            B[i*N+j] = val;
    ee56:	f8a9 1002 	strh.w	r1, [r9, #2]
            order++;
    ee5a:	f106 0604 	add.w	r6, r6, #4
            A[i*N+j] = val;
    ee5e:	f8a8 4002 	strh.w	r4, [r8, #2]
    ee62:	f109 0908 	add.w	r9, r9, #8
            B[i*N+j] = val;
    ee66:	f8aa 3002 	strh.w	r3, [sl, #2]
    ee6a:	f108 0808 	add.w	r8, r8, #8
            A[i*N+j] = val;
    ee6e:	f8ae 7002 	strh.w	r7, [lr, #2]
            B[i*N+j] = val;
    ee72:	f829 cc02 	strh.w	ip, [r9, #-2]
            A[i*N+j] = val;
    ee76:	f828 5c02 	strh.w	r5, [r8, #-2]
        for (j=0; j<N; j++) {
    ee7a:	d3a0      	bcc.n	edbe <core_init_matrix+0x13a>
    for (i=0; i<N; i++) {
    ee7c:	9900      	ldr	r1, [sp, #0]
    ee7e:	3101      	adds	r1, #1
    ee80:	4281      	cmp	r1, r0
    ee82:	9100      	str	r1, [sp, #0]
    ee84:	f4ff af26 	bcc.w	ecd4 <core_init_matrix+0x50>
    ee88:	9903      	ldr	r1, [sp, #12]
    p->C=(MATRES *)align_mem(B+N*N);
    ee8a:	9e02      	ldr	r6, [sp, #8]
    p->A=A;
    ee8c:	9c01      	ldr	r4, [sp, #4]
    p->N=N;
    ee8e:	9d04      	ldr	r5, [sp, #16]
    p->C=(MATRES *)align_mem(B+N*N);
    ee90:	4431      	add	r1, r6
    ee92:	1e4a      	subs	r2, r1, #1
    ee94:	f022 0303 	bic.w	r3, r2, #3
    ee98:	9a05      	ldr	r2, [sp, #20]
    ee9a:	4690      	mov	r8, r2
    p->B=B;
    ee9c:	46c2      	mov	sl, r8
    p->C=(MATRES *)align_mem(B+N*N);
    ee9e:	3304      	adds	r3, #4
    eea0:	60d3      	str	r3, [r2, #12]
    p->A=A;
    eea2:	6054      	str	r4, [r2, #4]
    p->B=B;
    eea4:	f8ca 6008 	str.w	r6, [sl, #8]
    p->N=N;
    eea8:	6015      	str	r5, [r2, #0]
}
    eeaa:	b007      	add	sp, #28
    eeac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    A=(MATDAT *)align_mem(memblk);
    eeb0:	1e4b      	subs	r3, r1, #1
    eeb2:	f023 0403 	bic.w	r4, r3, #3
    eeb6:	1d20      	adds	r0, r4, #4
    B=A+N*N;
    eeb8:	f04f 31ff 	mov.w	r1, #4294967295
    eebc:	3406      	adds	r4, #6
    eebe:	2502      	movs	r5, #2
    A=(MATDAT *)align_mem(memblk);
    eec0:	9001      	str	r0, [sp, #4]
    B=A+N*N;
    eec2:	9104      	str	r1, [sp, #16]
    eec4:	9402      	str	r4, [sp, #8]
    N=i-1;
    eec6:	4608      	mov	r0, r1
    B=A+N*N;
    eec8:	9503      	str	r5, [sp, #12]
    eeca:	e700      	b.n	ecce <core_init_matrix+0x4a>

0000eecc <start_time>:
    This function will be called right before starting the timed portion of the benchmark.

    Implementation may be capturing a system timer (as implemented in the example code)
    or zeroing some system parameters - e.g. setting the cpu clocks cycles to 0.
*/
void start_time(void) {
    eecc:	b538      	push	{r3, r4, r5, lr}
    am_hal_systick_load(0x00FFFFFF);
    eece:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
    eed2:	f002 fea3 	bl	11c1c <am_hal_systick_load>
    am_hal_systick_int_enable();
    eed6:	f002 fe99 	bl	11c0c <am_hal_systick_int_enable>
    am_hal_systick_start();
    eeda:	f002 fe87 	bl	11bec <am_hal_systick_start>
    start_time_val = 0; // GETMYTIME could be used - but there should be very small change anyways, as we just started
    eede:	4904      	ldr	r1, [pc, #16]	; (eef0 <start_time+0x24>)
    START_PA_DUMP = 0x1;
    eee0:	4b04      	ldr	r3, [pc, #16]	; (eef4 <start_time+0x28>)
    start_time_val = 0; // GETMYTIME could be used - but there should be very small change anyways, as we just started
    eee2:	2400      	movs	r4, #0
    eee4:	2500      	movs	r5, #0
    START_PA_DUMP = 0x1;
    eee6:	2201      	movs	r2, #1
    start_time_val = 0; // GETMYTIME could be used - but there should be very small change anyways, as we just started
    eee8:	e9c1 4500 	strd	r4, r5, [r1]
    START_PA_DUMP = 0x1;
    eeec:	601a      	str	r2, [r3, #0]
    eeee:	bd38      	pop	{r3, r4, r5, pc}
    eef0:	10001058 	.word	0x10001058
    eef4:	4ffff014 	.word	0x4ffff014

0000eef8 <stop_time>:
    This function will be called right after ending the timed portion of the benchmark.

    Implementation may be capturing a system timer (as implemented in the example code)
    or other system parameters - e.g. reading the current value of cpu cycles counter.
*/
void stop_time(void) {
    eef8:	b538      	push	{r3, r4, r5, lr}
    am_hal_systick_stop();
    eefa:	f002 fe7f 	bl	11bfc <am_hal_systick_stop>
    stop_time_val = GETMYTIME;
    eefe:	f002 fe95 	bl	11c2c <am_hal_systick_count>
    ef02:	4b09      	ldr	r3, [pc, #36]	; (ef28 <stop_time+0x30>)
    ef04:	4c09      	ldr	r4, [pc, #36]	; (ef2c <stop_time+0x34>)
    ef06:	681d      	ldr	r5, [r3, #0]
    START_PA_DUMP = 0x0;
    ef08:	4b09      	ldr	r3, [pc, #36]	; (ef30 <stop_time+0x38>)
    stop_time_val = GETMYTIME;
    ef0a:	f1c0 10ff 	rsb	r0, r0, #16711935	; 0xff00ff
    ef0e:	f500 407f 	add.w	r0, r0, #65280	; 0xff00
    ef12:	2100      	movs	r1, #0
    ef14:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    ef18:	fbe2 0105 	umlal	r0, r1, r2, r5
    START_PA_DUMP = 0x0;
    ef1c:	2500      	movs	r5, #0
    stop_time_val = GETMYTIME;
    ef1e:	e9c4 0100 	strd	r0, r1, [r4]
    START_PA_DUMP = 0x0;
    ef22:	601d      	str	r5, [r3, #0]
    ef24:	bd38      	pop	{r3, r4, r5, pc}
    ef26:	bf00      	nop
    ef28:	10001040 	.word	0x10001040
    ef2c:	10001060 	.word	0x10001060
    ef30:	4ffff014 	.word	0x4ffff014

0000ef34 <get_time>:
    This methodology is taken to accomodate any hardware or simulated platform.
    The sample implementation returns millisecs by default,
    and the resolution is controlled by <TIMER_RES_DIVIDER>
*/
CORE_TICKS get_time(void) {
    CORE_TICKS elapsed=(CORE_TICKS)(MYTIMEDIFF(stop_time_val, start_time_val));
    ef34:	4a02      	ldr	r2, [pc, #8]	; (ef40 <get_time+0xc>)
    ef36:	4b03      	ldr	r3, [pc, #12]	; (ef44 <get_time+0x10>)
    ef38:	6810      	ldr	r0, [r2, #0]
    ef3a:	6819      	ldr	r1, [r3, #0]
    return elapsed;
}
    ef3c:	1a40      	subs	r0, r0, r1
    ef3e:	4770      	bx	lr
    ef40:	10001060 	.word	0x10001060
    ef44:	10001058 	.word	0x10001058

0000ef48 <time_in_secs>:
    Convert the value returned by get_time to seconds.

    The <secs_ret> type is used to accomodate systems with no support for floating point.
    Default implementation implemented by the EE_TICKS_PER_SEC macro above.
*/
secs_ret time_in_secs(CORE_TICKS ticks) {
    ef48:	b508      	push	{r3, lr}
    secs_ret retval=((secs_ret)ticks) / (secs_ret)EE_TICKS_PER_SEC;
    ef4a:	f7fd fa1b 	bl	c384 <__aeabi_ui2d>
    ef4e:	a304      	add	r3, pc, #16	; (adr r3, ef60 <time_in_secs+0x18>)
    ef50:	e9d3 2300 	ldrd	r2, r3, [r3]
    ef54:	f7fd fbb6 	bl	c6c4 <__aeabi_ddiv>
    return retval;
}
    ef58:	bd08      	pop	{r3, pc}
    ef5a:	bf00      	nop
    ef5c:	f3af 8000 	nop.w
    ef60:	00000000 	.word	0x00000000
    ef64:	4186e360 	.word	0x4186e360

0000ef68 <portable_init>:
    Target specific initialization code
    Test for some common mistakes.
*/

void portable_init(core_portable *p, int *argc, char *argv[])
{
    ef68:	b530      	push	{r4, r5, lr}
    ef6a:	4d1b      	ldr	r5, [pc, #108]	; (efd8 <portable_init+0x70>)
        ee_printf("ERROR! Please define ee_ptr_int to a type that holds a pointer!\n");
    }
    if (sizeof(ee_u32) != 4) {
        ee_printf("ERROR! Please define ee_u32 to a 32b unsigned type!\n");
    }
    p->portable_id=1;
    ef6c:	2401      	movs	r4, #1
{
    ef6e:	b083      	sub	sp, #12
    p->portable_id=1;
    ef70:	7004      	strb	r4, [r0, #0]
    ef72:	f44f 6280 	mov.w	r2, #1024	; 0x400
    ef76:	4628      	mov	r0, r5
    ef78:	2100      	movs	r1, #0
    ef7a:	f003 fec1 	bl	12d00 <memset>
    // Initialize our printf buffer.
    for(i = 0; i < PRTBUFSIZE; i++)
    {
        am_prtbuf[i] = 0x00;
    }
    am_pcBuf = am_prtbuf;
    ef7e:	4b17      	ldr	r3, [pc, #92]	; (efdc <portable_init+0x74>)
    am_bufcnt = 0;
    ef80:	4a17      	ldr	r2, [pc, #92]	; (efe0 <portable_init+0x78>)
    am_pcBuf = am_prtbuf;
    ef82:	601d      	str	r5, [r3, #0]
    am_bufcnt = 0;
    ef84:	2500      	movs	r5, #0
#endif // AM_PRINT_RESULTS

    //
    // Set the system clock to maximum frequency.
    //
    am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_SYSCLK_MAX, 0);
    ef86:	4629      	mov	r1, r5
    ef88:	4628      	mov	r0, r5
    am_bufcnt = 0;
    ef8a:	6015      	str	r5, [r2, #0]
    am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_SYSCLK_MAX, 0);
    ef8c:	f002 f916 	bl	111bc <am_hal_clkgen_control>

    //
    // Set the default cache configuration
    //
const am_hal_cachectrl_config_t am_hal_cachectrl_benchmark =
    ef90:	4914      	ldr	r1, [pc, #80]	; (efe4 <portable_init+0x7c>)
    ef92:	a802      	add	r0, sp, #8
    ef94:	680b      	ldr	r3, [r1, #0]
    ef96:	f840 3d08 	str.w	r3, [r0, #-8]!
    .bLRU                       = 0,
    .eDescript                  = AM_HAL_CACHECTRL_DESCR_1WAY_128B_512E,
    .eMode                      = AM_HAL_CACHECTRL_CONFIG_MODE_INSTR,
    .eEnableNCregions           = AM_HAL_CACHECTRL_CONFIG_NCREG_NONE,
};
    am_hal_cachectrl_config(&am_hal_cachectrl_benchmark);
    ef9a:	f002 f873 	bl	11084 <am_hal_cachectrl_config>
    am_hal_cachectrl_enable();
    ef9e:	f002 f89b 	bl	110d8 <am_hal_cachectrl_enable>
#ifndef NOFPU
    //
    // Enable the floating point module, and configure the core for lazy
    // stacking.
    //
    am_hal_sysctrl_fpu_enable();
    efa2:	f002 fe0d 	bl	11bc0 <am_hal_sysctrl_fpu_enable>
    am_hal_sysctrl_fpu_stacking_enable(true);
    efa6:	4620      	mov	r0, r4
    efa8:	f002 fe12 	bl	11bd0 <am_hal_sysctrl_fpu_stacking_enable>
#endif
#ifdef AM_PART_APOLLO3
    //
    // Configure the board for low power.
    //
    am_bsp_low_power_init();
    efac:	f001 ffea 	bl	10f84 <am_bsp_low_power_init>

    //
    // Turn off Flash1
    //
    if ( am_hal_pwrctrl_memory_enable(AM_HAL_PWRCTRL_MEM_FLASH_512K) )
    efb0:	200e      	movs	r0, #14
    efb2:	f002 fd69 	bl	11a88 <am_hal_pwrctrl_memory_enable>
    efb6:	b100      	cbz	r0, efba <portable_init+0x52>
    efb8:	e7fe      	b.n	efb8 <portable_init+0x50>
    }

	//
	// Turn off unneeded SRAM
	//
    if ( am_hal_pwrctrl_memory_enable(AM_HAL_PWRCTRL_MEM_SRAM_8K_DTCM) )
    efba:	4620      	mov	r0, r4
    efbc:	f002 fd64 	bl	11a88 <am_hal_pwrctrl_memory_enable>
    efc0:	b100      	cbz	r0, efc4 <portable_init+0x5c>
    efc2:	e7fe      	b.n	efc2 <portable_init+0x5a>
    {
        while(1);
    }

#if AM_CMSIS_REGS
    uint32_t ui32LPMMode = CACHECTRL_FLASHCFG_LPMMODE_STANDBY;
    efc4:	a902      	add	r1, sp, #8
#else // AM_CMSIS_REGS
    uint32_t ui32LPMMode = AM_REG_CACHECTRL_FLASHCFG_LPMMODE_STANDBY;
#endif // AM_CMSIS_REGS
    if ( am_hal_cachectrl_control(AM_HAL_CACHECTRL_CONTROL_LPMMODE_SET, &ui32LPMMode) )
    efc6:	200b      	movs	r0, #11
    uint32_t ui32LPMMode = CACHECTRL_FLASHCFG_LPMMODE_STANDBY;
    efc8:	f841 4d04 	str.w	r4, [r1, #-4]!
    if ( am_hal_cachectrl_control(AM_HAL_CACHECTRL_CONTROL_LPMMODE_SET, &ui32LPMMode) )
    efcc:	f002 f88e 	bl	110ec <am_hal_cachectrl_control>
    efd0:	b100      	cbz	r0, efd4 <portable_init+0x6c>
    efd2:	e7fe      	b.n	efd2 <portable_init+0x6a>
    //
    // To minimize power during the run, disable the UART.
    //
    am_bsp_uart_printf_disable();
#endif
}
    efd4:	b003      	add	sp, #12
    efd6:	bd30      	pop	{r4, r5, pc}
    efd8:	10001174 	.word	0x10001174
    efdc:	10001574 	.word	0x10001574
    efe0:	10001044 	.word	0x10001044
    efe4:	00012d10 	.word	0x00012d10

0000efe8 <portable_fini>:

/* Function : portable_fini
    Target specific final code
*/
void portable_fini(core_portable *p)
{
    efe8:	b538      	push	{r3, r4, r5, lr}
    p->portable_id=0;
    efea:	2500      	movs	r5, #0
    efec:	7005      	strb	r5, [r0, #0]

#if AM_PART_APOLLO3
	//
	// Now that we're done, turn all memory back on.
	//
    am_hal_pwrctrl_memory_enable(AM_HAL_PWRCTRL_MEM_ALL);
    efee:	2011      	movs	r0, #17
    eff0:	f002 fd4a 	bl	11a88 <am_hal_pwrctrl_memory_enable>
    //
    // Now, let's go parse the buffer and print it out!
    //
    pcBuf = am_prtbuf;
    iCnt = 0;
    while ( (*pcBuf != 0x00)  &&  (iCnt<PRTBUFSIZE) )
    eff4:	4c18      	ldr	r4, [pc, #96]	; (f058 <portable_fini+0x70>)
    am_hal_cachectrl_config(&am_hal_cachectrl_defaults);
    eff6:	4819      	ldr	r0, [pc, #100]	; (f05c <portable_fini+0x74>)
    eff8:	f002 f844 	bl	11084 <am_hal_cachectrl_config>
    am_hal_cachectrl_enable();
    effc:	f002 f86c 	bl	110d8 <am_hal_cachectrl_enable>
    am_bsp_uart_printf_enable();
    f000:	f001 fff2 	bl	10fe8 <am_bsp_uart_printf_enable>
    am_util_stdio_terminal_clear();
    f004:	f001 ff94 	bl	10f30 <am_util_stdio_terminal_clear>
    am_util_stdio_printf("\nAmbiq Micro Coremark run finished!\n\n");
    f008:	4815      	ldr	r0, [pc, #84]	; (f060 <portable_fini+0x78>)
    f00a:	f001 ff77 	bl	10efc <am_util_stdio_printf>
    while ( (*pcBuf != 0x00)  &&  (iCnt<PRTBUFSIZE) )
    f00e:	7823      	ldrb	r3, [r4, #0]
    f010:	b19b      	cbz	r3, f03a <portable_fini+0x52>
    {
        am_util_stdio_printf(pcBuf);
    f012:	4620      	mov	r0, r4
    f014:	f001 ff72 	bl	10efc <am_util_stdio_printf>
        while ( *pcBuf != 0x00 )
    f018:	7820      	ldrb	r0, [r4, #0]
    f01a:	b1d0      	cbz	r0, f052 <portable_fini+0x6a>
    f01c:	1b2d      	subs	r5, r5, r4
    f01e:	1c63      	adds	r3, r4, #1
    f020:	781a      	ldrb	r2, [r3, #0]
        {
            pcBuf++;
    f022:	461c      	mov	r4, r3
    f024:	18e9      	adds	r1, r5, r3
    f026:	3301      	adds	r3, #1
        while ( *pcBuf != 0x00 )
    f028:	2a00      	cmp	r2, #0
    f02a:	d1f9      	bne.n	f020 <portable_fini+0x38>
    while ( (*pcBuf != 0x00)  &&  (iCnt<PRTBUFSIZE) )
    f02c:	7860      	ldrb	r0, [r4, #1]
            iCnt++;
        }
        iCnt++;     // Account for the NULL terminator
    f02e:	1c4d      	adds	r5, r1, #1
        pcBuf++;    // Point after the NULL terminator to the next string
    f030:	3401      	adds	r4, #1
    while ( (*pcBuf != 0x00)  &&  (iCnt<PRTBUFSIZE) )
    f032:	b110      	cbz	r0, f03a <portable_fini+0x52>
    f034:	f5b5 6f80 	cmp.w	r5, #1024	; 0x400
    f038:	dbeb      	blt.n	f012 <portable_fini+0x2a>
    }

    //
    // Disable the UART.
    //
    am_bsp_uart_printf_disable();
    f03a:	f002 f803 	bl	11044 <am_bsp_uart_printf_disable>

#ifdef AM_BSP_NUM_LEDS
    //
    // Enable the LEDs.
    //
    am_devices_led_array_init(am_bsp_psLEDs, AM_BSP_NUM_LEDS);
    f03e:	2105      	movs	r1, #5
    f040:	4808      	ldr	r0, [pc, #32]	; (f064 <portable_fini+0x7c>)
    f042:	f7fd fd1f 	bl	ca84 <am_devices_led_array_init>

    //
    // Turn on an LED.
    //
    am_devices_led_on(am_bsp_psLEDs, 0);
    f046:	2100      	movs	r1, #0
    f048:	4806      	ldr	r0, [pc, #24]	; (f064 <portable_fini+0x7c>)
#endif

}
    f04a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    am_devices_led_on(am_bsp_psLEDs, 0);
    f04e:	f7fd be2d 	b.w	ccac <am_devices_led_on>
        while ( *pcBuf != 0x00 )
    f052:	4629      	mov	r1, r5
    f054:	e7ea      	b.n	f02c <portable_fini+0x44>
    f056:	bf00      	nop
    f058:	10001174 	.word	0x10001174
    f05c:	000132e4 	.word	0x000132e4
    f060:	00013188 	.word	0x00013188
    f064:	1000100c 	.word	0x1000100c

0000f068 <am_sprintf>:

#if AM_PRINT_RESULTS
int am_sprintf(char *pcFmt, ...)
{
    f068:	b40f      	push	{r0, r1, r2, r3}
    f06a:	b530      	push	{r4, r5, lr}
    uint32_t ui32NumChars;
    int iRet = 0;

    va_list pArgs;

    if ( am_bufcnt < PRTBUFSIZE )
    f06c:	4c1a      	ldr	r4, [pc, #104]	; (f0d8 <am_sprintf+0x70>)
    f06e:	6823      	ldr	r3, [r4, #0]
    f070:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
{
    f074:	b083      	sub	sp, #12
    if ( am_bufcnt < PRTBUFSIZE )
    f076:	d305      	bcc.n	f084 <am_sprintf+0x1c>
    int iRet = 0;
    f078:	2000      	movs	r0, #0
        }
    } // if (am_bufcnt)

    return iRet;

} // am_sprintf()
    f07a:	b003      	add	sp, #12
    f07c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    f080:	b004      	add	sp, #16
    f082:	4770      	bx	lr
        ui32NumChars = am_util_stdio_vsprintf(am_pcBuf, pcFmt, pArgs);
    f084:	4d15      	ldr	r5, [pc, #84]	; (f0dc <am_sprintf+0x74>)
    f086:	9906      	ldr	r1, [sp, #24]
    f088:	6828      	ldr	r0, [r5, #0]
        va_start(pArgs, pcFmt);
    f08a:	aa07      	add	r2, sp, #28
    f08c:	9201      	str	r2, [sp, #4]
        ui32NumChars = am_util_stdio_vsprintf(am_pcBuf, pcFmt, pArgs);
    f08e:	f000 fe31 	bl	fcf4 <am_util_stdio_vsprintf>
        if ( (am_bufcnt+ui32NumChars) >= PRTBUFSIZE )
    f092:	6821      	ldr	r1, [r4, #0]
    f094:	4401      	add	r1, r0
    f096:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
    f09a:	d20e      	bcs.n	f0ba <am_sprintf+0x52>
            am_bufcnt += ui32NumChars;
    f09c:	6822      	ldr	r2, [r4, #0]
            am_pcBuf++;                 // Skip NULL terminator
    f09e:	682b      	ldr	r3, [r5, #0]
            am_bufcnt += ui32NumChars;
    f0a0:	4402      	add	r2, r0
    f0a2:	6022      	str	r2, [r4, #0]
            am_bufcnt++;                // Include NULL terminator
    f0a4:	6822      	ldr	r2, [r4, #0]
            am_pcBuf++;                 // Skip NULL terminator
    f0a6:	1c41      	adds	r1, r0, #1
            am_bufcnt++;                // Include NULL terminator
    f0a8:	3201      	adds	r2, #1
            am_pcBuf++;                 // Skip NULL terminator
    f0aa:	440b      	add	r3, r1
            am_bufcnt++;                // Include NULL terminator
    f0ac:	6022      	str	r2, [r4, #0]
            am_pcBuf++;                 // Skip NULL terminator
    f0ae:	602b      	str	r3, [r5, #0]
} // am_sprintf()
    f0b0:	b003      	add	sp, #12
    f0b2:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    f0b6:	b004      	add	sp, #16
    f0b8:	4770      	bx	lr
            am_util_stdio_sprintf(&am_prtbuf[PRTBUFSIZE-(40+1)], "BUFFER OVERFLOWED! Increase PRTBUFSIZE\n");
    f0ba:	4909      	ldr	r1, [pc, #36]	; (f0e0 <am_sprintf+0x78>)
    f0bc:	4809      	ldr	r0, [pc, #36]	; (f0e4 <am_sprintf+0x7c>)
    f0be:	f001 ff0f 	bl	10ee0 <am_util_stdio_sprintf>
            am_prtbuf[PRTBUFSIZE-1] = 0x00;     // Double terminate the buffer
    f0c2:	4b09      	ldr	r3, [pc, #36]	; (f0e8 <am_sprintf+0x80>)
    f0c4:	2000      	movs	r0, #0
            am_pcBuf = &am_prtbuf[PRTBUFSIZE];  // Don't allow any further printing
    f0c6:	f503 6180 	add.w	r1, r3, #1024	; 0x400
            am_bufcnt = PRTBUFSIZE;             //  "
    f0ca:	f44f 6280 	mov.w	r2, #1024	; 0x400
            am_pcBuf = &am_prtbuf[PRTBUFSIZE];  // Don't allow any further printing
    f0ce:	6029      	str	r1, [r5, #0]
            am_prtbuf[PRTBUFSIZE-1] = 0x00;     // Double terminate the buffer
    f0d0:	f883 03ff 	strb.w	r0, [r3, #1023]	; 0x3ff
            am_bufcnt = PRTBUFSIZE;             //  "
    f0d4:	6022      	str	r2, [r4, #0]
    f0d6:	e7d0      	b.n	f07a <am_sprintf+0x12>
    f0d8:	10001044 	.word	0x10001044
    f0dc:	10001574 	.word	0x10001574
    f0e0:	00013160 	.word	0x00013160
    f0e4:	1000154b 	.word	0x1000154b
    f0e8:	10001174 	.word	0x10001174

0000f0ec <core_init_state>:
    Actual patterns chosen depend on the seed parameter.

    Note:
    The seed parameter MUST be supplied from a source that cannot be determined at compile time
*/
void core_init_state(ee_u32 size, ee_s16 seed, ee_u8 *p) {
    f0ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ee_u8 *buf=0;
#if CORE_DEBUG
    ee_u8 *start=p;
    ee_printf("State: %d,%d\n",size,seed);
#endif
    size--;
    f0f0:	1e46      	subs	r6, r0, #1
    next=0;
    while ((total+next+1)<size) {
    f0f2:	2e01      	cmp	r6, #1
void core_init_state(ee_u32 size, ee_s16 seed, ee_u8 *p) {
    f0f4:	4684      	mov	ip, r0
    f0f6:	4615      	mov	r5, r2
    while ((total+next+1)<size) {
    f0f8:	d966      	bls.n	f1c8 <core_init_state+0xdc>
    f0fa:	1c4c      	adds	r4, r1, #1
            case 6: /* scientific */
                buf=scipat[(seed>>3) & 0x3];
                next=8;
            break;
            case 7: /* invalid */
                buf=errpat[(seed>>3) & 0x3];
    f0fc:	f8df 90d4 	ldr.w	r9, [pc, #212]	; f1d4 <core_init_state+0xe8>
                buf=scipat[(seed>>3) & 0x3];
    f100:	f8df 80d4 	ldr.w	r8, [pc, #212]	; f1d8 <core_init_state+0xec>
                buf=floatpat[(seed>>3) & 0x3];
    f104:	f8df e0d4 	ldr.w	lr, [pc, #212]	; f1dc <core_init_state+0xf0>
                buf=intpat[(seed>>3) & 0x3];
    f108:	4831      	ldr	r0, [pc, #196]	; (f1d0 <core_init_state+0xe4>)
    f10a:	b2a4      	uxth	r4, r4
    while ((total+next+1)<size) {
    f10c:	2100      	movs	r1, #0
            *(p+total+i)=',';
    f10e:	272c      	movs	r7, #44	; 0x2c
        switch (seed & 0x7) {
    f110:	f004 0307 	and.w	r3, r4, #7
    f114:	f1a3 0b03 	sub.w	fp, r3, #3
        seed++;
    f118:	b222      	sxth	r2, r4
                buf=errpat[(seed>>3) & 0x3];
    f11a:	f3c2 03c1 	ubfx	r3, r2, #3, #2
        switch (seed & 0x7) {
    f11e:	f1bb 0f04 	cmp.w	fp, #4
    f122:	d831      	bhi.n	f188 <core_init_state+0x9c>
    f124:	e8df f00b 	tbb	[pc, fp]
    f128:	39390303 	.word	0x39390303
    f12c:	49          	.byte	0x49
    f12d:	00          	.byte	0x00
    while ((total+next+1)<size) {
    f12e:	f101 0b09 	add.w	fp, r1, #9
    f132:	455e      	cmp	r6, fp
                buf=floatpat[(seed>>3) & 0x3];
    f134:	f85e 3023 	ldr.w	r3, [lr, r3, lsl #2]
    while ((total+next+1)<size) {
    f138:	d935      	bls.n	f1a6 <core_init_state+0xba>
                next=8;
    f13a:	f04f 0a08 	mov.w	sl, #8
                *(p+total+i)=buf[i];
    f13e:	781a      	ldrb	r2, [r3, #0]
    f140:	546a      	strb	r2, [r5, r1]
    f142:	186a      	adds	r2, r5, r1
    f144:	7859      	ldrb	r1, [r3, #1]
    f146:	7051      	strb	r1, [r2, #1]
    f148:	7899      	ldrb	r1, [r3, #2]
    f14a:	7091      	strb	r1, [r2, #2]
    f14c:	78d9      	ldrb	r1, [r3, #3]
    f14e:	70d1      	strb	r1, [r2, #3]
            for(i=0;i<next;i++)
    f150:	f1ba 0f04 	cmp.w	sl, #4
    f154:	d012      	beq.n	f17c <core_init_state+0x90>
                *(p+total+i)=buf[i];
    f156:	7919      	ldrb	r1, [r3, #4]
    f158:	7111      	strb	r1, [r2, #4]
            for(i=0;i<next;i++)
    f15a:	f1ba 0f05 	cmp.w	sl, #5
    f15e:	d00d      	beq.n	f17c <core_init_state+0x90>
                *(p+total+i)=buf[i];
    f160:	7959      	ldrb	r1, [r3, #5]
    f162:	7151      	strb	r1, [r2, #5]
            for(i=0;i<next;i++)
    f164:	f1ba 0f06 	cmp.w	sl, #6
    f168:	d008      	beq.n	f17c <core_init_state+0x90>
                *(p+total+i)=buf[i];
    f16a:	7999      	ldrb	r1, [r3, #6]
    f16c:	7191      	strb	r1, [r2, #6]
            for(i=0;i<next;i++)
    f16e:	f1ba 0f08 	cmp.w	sl, #8
                *(p+total+i)=buf[i];
    f172:	bf06      	itte	eq
    f174:	79db      	ldrbeq	r3, [r3, #7]
    f176:	71d3      	strbeq	r3, [r2, #7]
            for(i=0;i<next;i++)
    f178:	f04f 0a07 	movne.w	sl, #7
    f17c:	3401      	adds	r4, #1
            *(p+total+i)=',';
    f17e:	f802 700a 	strb.w	r7, [r2, sl]
    f182:	b2a4      	uxth	r4, r4
    f184:	4659      	mov	r1, fp
    f186:	e7c3      	b.n	f110 <core_init_state+0x24>
    while ((total+next+1)<size) {
    f188:	f101 0b05 	add.w	fp, r1, #5
    f18c:	455e      	cmp	r6, fp
                buf=intpat[(seed>>3) & 0x3];
    f18e:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    while ((total+next+1)<size) {
    f192:	d908      	bls.n	f1a6 <core_init_state+0xba>
                next=4;
    f194:	f04f 0a04 	mov.w	sl, #4
    f198:	e7d1      	b.n	f13e <core_init_state+0x52>
    while ((total+next+1)<size) {
    f19a:	f101 0b09 	add.w	fp, r1, #9
    f19e:	455e      	cmp	r6, fp
                buf=scipat[(seed>>3) & 0x3];
    f1a0:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
    while ((total+next+1)<size) {
    f1a4:	d8c9      	bhi.n	f13a <core_init_state+0x4e>
            default: /* Never happen, just to make some compilers happy */
            break;
        }
    }
    size++;
    while (total<size) { /* fill the rest with 0 */
    f1a6:	4561      	cmp	r1, ip
    f1a8:	d210      	bcs.n	f1cc <core_init_state+0xe0>
    f1aa:	1868      	adds	r0, r5, r1
    f1ac:	ebac 0201 	sub.w	r2, ip, r1
        total++;
    }
#if CORE_DEBUG
    ee_printf("State Input: %s\n",start);
#endif
}
    f1b0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f1b4:	2100      	movs	r1, #0
    f1b6:	f003 bda3 	b.w	12d00 <memset>
    while ((total+next+1)<size) {
    f1ba:	f101 0b09 	add.w	fp, r1, #9
    f1be:	455e      	cmp	r6, fp
                buf=errpat[(seed>>3) & 0x3];
    f1c0:	f859 3023 	ldr.w	r3, [r9, r3, lsl #2]
    while ((total+next+1)<size) {
    f1c4:	d8b9      	bhi.n	f13a <core_init_state+0x4e>
    f1c6:	e7ee      	b.n	f1a6 <core_init_state+0xba>
    ee_u32 total=0,next=0,i;
    f1c8:	2100      	movs	r1, #0
    f1ca:	e7ee      	b.n	f1aa <core_init_state+0xbe>
    f1cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f1d0:	000131d0 	.word	0x000131d0
    f1d4:	000131b0 	.word	0x000131b0
    f1d8:	000131e0 	.word	0x000131e0
    f1dc:	000131c0 	.word	0x000131c0

0000f1e0 <core_state_transition>:

    The input pointer is updated to point to the end of the token, and the end state is returned (either specific format determined or invalid).
*/

enum CORE_STATE core_state_transition( ee_u8 **instr , ee_u32 *transition_count) {
    ee_u8 *str=*instr;
    f1e0:	6803      	ldr	r3, [r0, #0]
    ee_u8 NEXT_SYMBOL;
    enum CORE_STATE state=CORE_START;
    for( ; *str && state != CORE_INVALID; str++ ) {
    f1e2:	781a      	ldrb	r2, [r3, #0]
    f1e4:	b392      	cbz	r2, f24c <core_state_transition+0x6c>
        NEXT_SYMBOL = *str;
        if (NEXT_SYMBOL==',') /* end of this input */ {
    f1e6:	2a2c      	cmp	r2, #44	; 0x2c
    f1e8:	d02e      	beq.n	f248 <core_state_transition+0x68>
enum CORE_STATE core_state_transition( ee_u8 **instr , ee_u32 *transition_count) {
    f1ea:	b410      	push	{r4}
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    f1ec:	f1a2 0430 	sub.w	r4, r2, #48	; 0x30
    f1f0:	2c09      	cmp	r4, #9
    f1f2:	d90f      	bls.n	f214 <core_state_transition+0x34>
        switch(state) {
        case CORE_START:
            if(ee_isdigit(NEXT_SYMBOL)) {
                state = CORE_INT;
            }
            else if( NEXT_SYMBOL == '+' || NEXT_SYMBOL == '-' ) {
    f1f4:	2a2b      	cmp	r2, #43	; 0x2b
    f1f6:	d02c      	beq.n	f252 <core_state_transition+0x72>
    f1f8:	2a2d      	cmp	r2, #45	; 0x2d
    f1fa:	d02a      	beq.n	f252 <core_state_transition+0x72>
                state = CORE_S1;
            }
            else if( NEXT_SYMBOL == '.' ) {
    f1fc:	2a2e      	cmp	r2, #46	; 0x2e
    f1fe:	f000 80b1 	beq.w	f364 <core_state_transition+0x184>
            }
            else {
                state = CORE_INVALID;
                transition_count[CORE_INVALID]++;
            }
            transition_count[CORE_START]++;
    f202:	e891 0014 	ldmia.w	r1, {r2, r4}
                transition_count[CORE_INVALID]++;
    f206:	3401      	adds	r4, #1
            transition_count[CORE_START]++;
    f208:	3201      	adds	r2, #1
    f20a:	e881 0014 	stmia.w	r1, {r2, r4}
    for( ; *str && state != CORE_INVALID; str++ ) {
    f20e:	3301      	adds	r3, #1
                state = CORE_INVALID;
    f210:	2101      	movs	r1, #1
    f212:	e014      	b.n	f23e <core_state_transition+0x5e>
            transition_count[CORE_START]++;
    f214:	680c      	ldr	r4, [r1, #0]
    f216:	3401      	adds	r4, #1
    f218:	600c      	str	r4, [r1, #0]
    for( ; *str && state != CORE_INVALID; str++ ) {
    f21a:	785a      	ldrb	r2, [r3, #1]
    f21c:	3301      	adds	r3, #1
    f21e:	b372      	cbz	r2, f27e <core_state_transition+0x9e>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    f220:	2a2c      	cmp	r2, #44	; 0x2c
    f222:	f000 8092 	beq.w	f34a <core_state_transition+0x16a>
                state = CORE_INVALID;
                transition_count[CORE_S1]++;
            }
            break;
        case CORE_INT:
            if( NEXT_SYMBOL == '.' ) {
    f226:	2a2e      	cmp	r2, #46	; 0x2e
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    f228:	f1a2 0430 	sub.w	r4, r2, #48	; 0x30
            if( NEXT_SYMBOL == '.' ) {
    f22c:	d031      	beq.n	f292 <core_state_transition+0xb2>
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    f22e:	2c09      	cmp	r4, #9
    f230:	f240 80a0 	bls.w	f374 <core_state_transition+0x194>
                state = CORE_FLOAT;
                transition_count[CORE_INT]++;
            }
            else if(!ee_isdigit(NEXT_SYMBOL)) {
                state = CORE_INVALID;
                transition_count[CORE_INT]++;
    f234:	690a      	ldr	r2, [r1, #16]
    f236:	3201      	adds	r2, #1
    f238:	610a      	str	r2, [r1, #16]
    for( ; *str && state != CORE_INVALID; str++ ) {
    f23a:	3301      	adds	r3, #1
                state = CORE_INVALID;
    f23c:	2101      	movs	r1, #1
            break;
        default:
            break;
        }
    }
    *instr=str;
    f23e:	6003      	str	r3, [r0, #0]
    return state;
}
    f240:	f85d 4b04 	ldr.w	r4, [sp], #4
    f244:	4608      	mov	r0, r1
    f246:	4770      	bx	lr
        if (NEXT_SYMBOL==',') /* end of this input */ {
    f248:	2200      	movs	r2, #0
            str++;
    f24a:	3301      	adds	r3, #1
    *instr=str;
    f24c:	6003      	str	r3, [r0, #0]
}
    f24e:	4610      	mov	r0, r2
    f250:	4770      	bx	lr
            transition_count[CORE_START]++;
    f252:	680c      	ldr	r4, [r1, #0]
    f254:	3401      	adds	r4, #1
    f256:	600c      	str	r4, [r1, #0]
    for( ; *str && state != CORE_INVALID; str++ ) {
    f258:	785a      	ldrb	r2, [r3, #1]
    f25a:	3301      	adds	r3, #1
    f25c:	2a00      	cmp	r2, #0
    f25e:	f000 809c 	beq.w	f39a <core_state_transition+0x1ba>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    f262:	2a2c      	cmp	r2, #44	; 0x2c
    f264:	f000 809b 	beq.w	f39e <core_state_transition+0x1be>
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    f268:	f1a2 0430 	sub.w	r4, r2, #48	; 0x30
    f26c:	2c09      	cmp	r4, #9
    f26e:	d808      	bhi.n	f282 <core_state_transition+0xa2>
                transition_count[CORE_S1]++;
    f270:	688a      	ldr	r2, [r1, #8]
    f272:	3201      	adds	r2, #1
    f274:	608a      	str	r2, [r1, #8]
    for( ; *str && state != CORE_INVALID; str++ ) {
    f276:	785a      	ldrb	r2, [r3, #1]
    f278:	3301      	adds	r3, #1
    f27a:	2a00      	cmp	r2, #0
    f27c:	d1d0      	bne.n	f220 <core_state_transition+0x40>
                state = CORE_INT;
    f27e:	2104      	movs	r1, #4
    f280:	e7dd      	b.n	f23e <core_state_transition+0x5e>
            else if( NEXT_SYMBOL == '.' ) {
    f282:	2a2e      	cmp	r2, #46	; 0x2e
    f284:	d064      	beq.n	f350 <core_state_transition+0x170>
                transition_count[CORE_S1]++;
    f286:	688a      	ldr	r2, [r1, #8]
    f288:	3201      	adds	r2, #1
    f28a:	608a      	str	r2, [r1, #8]
    for( ; *str && state != CORE_INVALID; str++ ) {
    f28c:	3301      	adds	r3, #1
                state = CORE_INVALID;
    f28e:	2101      	movs	r1, #1
    f290:	e7d5      	b.n	f23e <core_state_transition+0x5e>
                transition_count[CORE_INT]++;
    f292:	690c      	ldr	r4, [r1, #16]
    f294:	3401      	adds	r4, #1
    f296:	610c      	str	r4, [r1, #16]
    for( ; *str && state != CORE_INVALID; str++ ) {
    f298:	785a      	ldrb	r2, [r3, #1]
    f29a:	1c5c      	adds	r4, r3, #1
    f29c:	2a00      	cmp	r2, #0
    f29e:	d05e      	beq.n	f35e <core_state_transition+0x17e>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    f2a0:	2a2c      	cmp	r2, #44	; 0x2c
    f2a2:	d075      	beq.n	f390 <core_state_transition+0x1b0>
            if( NEXT_SYMBOL == 'E' || NEXT_SYMBOL == 'e' ) {
    f2a4:	f002 03df 	and.w	r3, r2, #223	; 0xdf
    f2a8:	2b45      	cmp	r3, #69	; 0x45
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    f2aa:	f1a2 0230 	sub.w	r2, r2, #48	; 0x30
            if( NEXT_SYMBOL == 'E' || NEXT_SYMBOL == 'e' ) {
    f2ae:	d009      	beq.n	f2c4 <core_state_transition+0xe4>
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    f2b0:	2a09      	cmp	r2, #9
    f2b2:	d844      	bhi.n	f33e <core_state_transition+0x15e>
    for( ; *str && state != CORE_INVALID; str++ ) {
    f2b4:	7862      	ldrb	r2, [r4, #1]
    f2b6:	1c63      	adds	r3, r4, #1
    f2b8:	2a00      	cmp	r2, #0
    f2ba:	d072      	beq.n	f3a2 <core_state_transition+0x1c2>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    f2bc:	2a2c      	cmp	r2, #44	; 0x2c
    f2be:	d068      	beq.n	f392 <core_state_transition+0x1b2>
    f2c0:	461c      	mov	r4, r3
    f2c2:	e7ef      	b.n	f2a4 <core_state_transition+0xc4>
                transition_count[CORE_FLOAT]++;
    f2c4:	694b      	ldr	r3, [r1, #20]
    f2c6:	3301      	adds	r3, #1
    f2c8:	614b      	str	r3, [r1, #20]
    for( ; *str && state != CORE_INVALID; str++ ) {
    f2ca:	7862      	ldrb	r2, [r4, #1]
    f2cc:	1c63      	adds	r3, r4, #1
    f2ce:	2a00      	cmp	r2, #0
    f2d0:	d05a      	beq.n	f388 <core_state_transition+0x1a8>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    f2d2:	2a2c      	cmp	r2, #44	; 0x2c
    f2d4:	d05a      	beq.n	f38c <core_state_transition+0x1ac>
            if( NEXT_SYMBOL == '+' || NEXT_SYMBOL == '-' ) {
    f2d6:	2a2b      	cmp	r2, #43	; 0x2b
                transition_count[CORE_S2]++;
    f2d8:	68cb      	ldr	r3, [r1, #12]
            if( NEXT_SYMBOL == '+' || NEXT_SYMBOL == '-' ) {
    f2da:	d006      	beq.n	f2ea <core_state_transition+0x10a>
    f2dc:	2a2d      	cmp	r2, #45	; 0x2d
    f2de:	d004      	beq.n	f2ea <core_state_transition+0x10a>
                transition_count[CORE_S2]++;
    f2e0:	1c5a      	adds	r2, r3, #1
    f2e2:	60ca      	str	r2, [r1, #12]
    for( ; *str && state != CORE_INVALID; str++ ) {
    f2e4:	1ca3      	adds	r3, r4, #2
                state = CORE_INVALID;
    f2e6:	2101      	movs	r1, #1
    f2e8:	e7a9      	b.n	f23e <core_state_transition+0x5e>
                transition_count[CORE_S2]++;
    f2ea:	3301      	adds	r3, #1
    f2ec:	60cb      	str	r3, [r1, #12]
    for( ; *str && state != CORE_INVALID; str++ ) {
    f2ee:	78a2      	ldrb	r2, [r4, #2]
    f2f0:	1ca3      	adds	r3, r4, #2
    f2f2:	2a00      	cmp	r2, #0
    f2f4:	d046      	beq.n	f384 <core_state_transition+0x1a4>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    f2f6:	2a2c      	cmp	r2, #44	; 0x2c
    f2f8:	d04d      	beq.n	f396 <core_state_transition+0x1b6>
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    f2fa:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
    f2fe:	2b09      	cmp	r3, #9
    f300:	d811      	bhi.n	f326 <core_state_transition+0x146>
                transition_count[CORE_EXPONENT]++;
    f302:	698b      	ldr	r3, [r1, #24]
    f304:	3301      	adds	r3, #1
    f306:	618b      	str	r3, [r1, #24]
    for( ; *str && state != CORE_INVALID; str++ ) {
    f308:	78e2      	ldrb	r2, [r4, #3]
    f30a:	1ce3      	adds	r3, r4, #3
    f30c:	b14a      	cbz	r2, f322 <core_state_transition+0x142>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    f30e:	2a2c      	cmp	r2, #44	; 0x2c
    f310:	d036      	beq.n	f380 <core_state_transition+0x1a0>
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    f312:	f1a2 0430 	sub.w	r4, r2, #48	; 0x30
    f316:	2c09      	cmp	r4, #9
    f318:	d80b      	bhi.n	f332 <core_state_transition+0x152>
    for( ; *str && state != CORE_INVALID; str++ ) {
    f31a:	f813 2f01 	ldrb.w	r2, [r3, #1]!
    f31e:	2a00      	cmp	r2, #0
    f320:	d1f5      	bne.n	f30e <core_state_transition+0x12e>
                state = CORE_SCIENTIFIC;
    f322:	2107      	movs	r1, #7
    f324:	e78b      	b.n	f23e <core_state_transition+0x5e>
                transition_count[CORE_EXPONENT]++;
    f326:	698a      	ldr	r2, [r1, #24]
    f328:	3201      	adds	r2, #1
    f32a:	618a      	str	r2, [r1, #24]
    for( ; *str && state != CORE_INVALID; str++ ) {
    f32c:	1ce3      	adds	r3, r4, #3
                state = CORE_INVALID;
    f32e:	2101      	movs	r1, #1
    f330:	e785      	b.n	f23e <core_state_transition+0x5e>
                transition_count[CORE_INVALID]++;
    f332:	684a      	ldr	r2, [r1, #4]
    f334:	3201      	adds	r2, #1
    f336:	604a      	str	r2, [r1, #4]
    for( ; *str && state != CORE_INVALID; str++ ) {
    f338:	3301      	adds	r3, #1
                state = CORE_INVALID;
    f33a:	2101      	movs	r1, #1
    f33c:	e77f      	b.n	f23e <core_state_transition+0x5e>
                transition_count[CORE_FLOAT]++;
    f33e:	694b      	ldr	r3, [r1, #20]
    f340:	1c5a      	adds	r2, r3, #1
    f342:	614a      	str	r2, [r1, #20]
    for( ; *str && state != CORE_INVALID; str++ ) {
    f344:	1c63      	adds	r3, r4, #1
                state = CORE_INVALID;
    f346:	2101      	movs	r1, #1
    f348:	e779      	b.n	f23e <core_state_transition+0x5e>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    f34a:	2104      	movs	r1, #4
            str++;
    f34c:	3301      	adds	r3, #1
            break;
    f34e:	e776      	b.n	f23e <core_state_transition+0x5e>
                transition_count[CORE_S1]++;
    f350:	688c      	ldr	r4, [r1, #8]
    f352:	3401      	adds	r4, #1
    f354:	608c      	str	r4, [r1, #8]
    for( ; *str && state != CORE_INVALID; str++ ) {
    f356:	785a      	ldrb	r2, [r3, #1]
    f358:	1c5c      	adds	r4, r3, #1
    f35a:	2a00      	cmp	r2, #0
    f35c:	d1a0      	bne.n	f2a0 <core_state_transition+0xc0>
    f35e:	4623      	mov	r3, r4
                state = CORE_FLOAT;
    f360:	2105      	movs	r1, #5
    f362:	e76c      	b.n	f23e <core_state_transition+0x5e>
            transition_count[CORE_START]++;
    f364:	680a      	ldr	r2, [r1, #0]
    f366:	3201      	adds	r2, #1
    f368:	600a      	str	r2, [r1, #0]
    for( ; *str && state != CORE_INVALID; str++ ) {
    f36a:	785a      	ldrb	r2, [r3, #1]
    f36c:	1c5c      	adds	r4, r3, #1
    f36e:	2a00      	cmp	r2, #0
    f370:	d196      	bne.n	f2a0 <core_state_transition+0xc0>
    f372:	e7f4      	b.n	f35e <core_state_transition+0x17e>
    f374:	f813 2f01 	ldrb.w	r2, [r3, #1]!
    f378:	2a00      	cmp	r2, #0
    f37a:	f47f af51 	bne.w	f220 <core_state_transition+0x40>
    f37e:	e77e      	b.n	f27e <core_state_transition+0x9e>
                state = CORE_SCIENTIFIC;
    f380:	2107      	movs	r1, #7
    f382:	e7e3      	b.n	f34c <core_state_transition+0x16c>
                state = CORE_EXPONENT;
    f384:	2106      	movs	r1, #6
    f386:	e75a      	b.n	f23e <core_state_transition+0x5e>
                state = CORE_S2;
    f388:	2103      	movs	r1, #3
    f38a:	e758      	b.n	f23e <core_state_transition+0x5e>
    f38c:	2103      	movs	r1, #3
    f38e:	e7dd      	b.n	f34c <core_state_transition+0x16c>
    for( ; *str && state != CORE_INVALID; str++ ) {
    f390:	4623      	mov	r3, r4
                state = CORE_FLOAT;
    f392:	2105      	movs	r1, #5
    f394:	e7da      	b.n	f34c <core_state_transition+0x16c>
                state = CORE_EXPONENT;
    f396:	2106      	movs	r1, #6
    f398:	e7d8      	b.n	f34c <core_state_transition+0x16c>
                state = CORE_S1;
    f39a:	2102      	movs	r1, #2
    f39c:	e74f      	b.n	f23e <core_state_transition+0x5e>
    f39e:	2102      	movs	r1, #2
    f3a0:	e7d4      	b.n	f34c <core_state_transition+0x16c>
    for( ; *str && state != CORE_INVALID; str++ ) {
    f3a2:	2105      	movs	r1, #5
    f3a4:	e74b      	b.n	f23e <core_state_transition+0x5e>
    f3a6:	bf00      	nop

0000f3a8 <core_bench_state>:
{
    f3a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    f3ac:	b092      	sub	sp, #72	; 0x48
    f3ae:	460c      	mov	r4, r1
    f3b0:	4682      	mov	sl, r0
    f3b2:	2100      	movs	r1, #0
    f3b4:	4691      	mov	r9, r2
    f3b6:	a80a      	add	r0, sp, #40	; 0x28
    f3b8:	2220      	movs	r2, #32
    f3ba:	4698      	mov	r8, r3
    ee_u8 *p=memblock;
    f3bc:	9401      	str	r4, [sp, #4]
{
    f3be:	f9bd 6068 	ldrsh.w	r6, [sp, #104]	; 0x68
    f3c2:	f8bd 706c 	ldrh.w	r7, [sp, #108]	; 0x6c
    f3c6:	f003 fc9b 	bl	12d00 <memset>
    f3ca:	2220      	movs	r2, #32
    f3cc:	2100      	movs	r1, #0
    f3ce:	a802      	add	r0, sp, #8
    f3d0:	f003 fc96 	bl	12d00 <memset>
    while (*p!=0) {
    f3d4:	7822      	ldrb	r2, [r4, #0]
    f3d6:	2a00      	cmp	r2, #0
    f3d8:	d05a      	beq.n	f490 <core_bench_state+0xe8>
    f3da:	ad01      	add	r5, sp, #4
        enum CORE_STATE fstate=core_state_transition(&p,track_counts);
    f3dc:	a90a      	add	r1, sp, #40	; 0x28
    f3de:	4628      	mov	r0, r5
    f3e0:	f7ff fefe 	bl	f1e0 <core_state_transition>
        final_counts[fstate]++;
    f3e4:	ab12      	add	r3, sp, #72	; 0x48
    f3e6:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    while (*p!=0) {
    f3ea:	9901      	ldr	r1, [sp, #4]
        final_counts[fstate]++;
    f3ec:	f850 3c40 	ldr.w	r3, [r0, #-64]
    while (*p!=0) {
    f3f0:	780a      	ldrb	r2, [r1, #0]
        final_counts[fstate]++;
    f3f2:	3301      	adds	r3, #1
    f3f4:	f840 3c40 	str.w	r3, [r0, #-64]
    while (*p!=0) {
    f3f8:	2a00      	cmp	r2, #0
    f3fa:	d1ef      	bne.n	f3dc <core_bench_state+0x34>
    while (p < (memblock+blksize)) { /* insert some corruption */
    f3fc:	44a2      	add	sl, r4
    f3fe:	4554      	cmp	r4, sl
    p=memblock;
    f400:	9401      	str	r4, [sp, #4]
    f402:	7822      	ldrb	r2, [r4, #0]
    while (p < (memblock+blksize)) { /* insert some corruption */
    f404:	d241      	bcs.n	f48a <core_bench_state+0xe2>
{
    f406:	4620      	mov	r0, r4
    f408:	e000      	b.n	f40c <core_bench_state+0x64>
    f40a:	7802      	ldrb	r2, [r0, #0]
        if (*p!=',')
    f40c:	2a2c      	cmp	r2, #44	; 0x2c
            *p^=(ee_u8)seed1;
    f40e:	ea82 0109 	eor.w	r1, r2, r9
    f412:	bf1c      	itt	ne
    f414:	7001      	strbne	r1, [r0, #0]
    f416:	9801      	ldrne	r0, [sp, #4]
        p+=step;
    f418:	4430      	add	r0, r6
    while (p < (memblock+blksize)) { /* insert some corruption */
    f41a:	4550      	cmp	r0, sl
        p+=step;
    f41c:	9001      	str	r0, [sp, #4]
    while (p < (memblock+blksize)) { /* insert some corruption */
    f41e:	d3f4      	bcc.n	f40a <core_bench_state+0x62>
    while (*p!=0) {
    f420:	7823      	ldrb	r3, [r4, #0]
    p=memblock;
    f422:	9401      	str	r4, [sp, #4]
    while (*p!=0) {
    f424:	2b00      	cmp	r3, #0
    f426:	d039      	beq.n	f49c <core_bench_state+0xf4>
        enum CORE_STATE fstate=core_state_transition(&p,track_counts);
    f428:	a90a      	add	r1, sp, #40	; 0x28
    f42a:	4628      	mov	r0, r5
    f42c:	f7ff fed8 	bl	f1e0 <core_state_transition>
        final_counts[fstate]++;
    f430:	f10d 0c48 	add.w	ip, sp, #72	; 0x48
    f434:	eb0c 0980 	add.w	r9, ip, r0, lsl #2
    while (*p!=0) {
    f438:	9a01      	ldr	r2, [sp, #4]
        final_counts[fstate]++;
    f43a:	f859 0c40 	ldr.w	r0, [r9, #-64]
    while (*p!=0) {
    f43e:	7811      	ldrb	r1, [r2, #0]
        final_counts[fstate]++;
    f440:	3001      	adds	r0, #1
    f442:	f849 0c40 	str.w	r0, [r9, #-64]
    while (*p!=0) {
    f446:	2900      	cmp	r1, #0
    f448:	d1ee      	bne.n	f428 <core_bench_state+0x80>
    while (p < (memblock+blksize)) { /* undo corruption is seed1 and seed2 are equal */
    f44a:	4554      	cmp	r4, sl
        p+=step;
    f44c:	9401      	str	r4, [sp, #4]
    while (p < (memblock+blksize)) { /* undo corruption is seed1 and seed2 are equal */
    f44e:	d20a      	bcs.n	f466 <core_bench_state+0xbe>
        if (*p!=',')
    f450:	7823      	ldrb	r3, [r4, #0]
    f452:	2b2c      	cmp	r3, #44	; 0x2c
            *p^=(ee_u8)seed2;
    f454:	ea83 0208 	eor.w	r2, r3, r8
    f458:	bf1c      	itt	ne
    f45a:	7022      	strbne	r2, [r4, #0]
    f45c:	9c01      	ldrne	r4, [sp, #4]
        p+=step;
    f45e:	4434      	add	r4, r6
    while (p < (memblock+blksize)) { /* undo corruption is seed1 and seed2 are equal */
    f460:	4554      	cmp	r4, sl
        p+=step;
    f462:	9401      	str	r4, [sp, #4]
    while (p < (memblock+blksize)) { /* undo corruption is seed1 and seed2 are equal */
    f464:	d3f4      	bcc.n	f450 <core_bench_state+0xa8>
    f466:	ac09      	add	r4, sp, #36	; 0x24
    f468:	4626      	mov	r6, r4
        crc=crcu32(final_counts[i],crc);
    f46a:	4639      	mov	r1, r7
    f46c:	f855 0f04 	ldr.w	r0, [r5, #4]!
    f470:	f000 f8d4 	bl	f61c <crcu32>
        crc=crcu32(track_counts[i],crc);
    f474:	4601      	mov	r1, r0
    f476:	f854 0f04 	ldr.w	r0, [r4, #4]!
    f47a:	f000 f8cf 	bl	f61c <crcu32>
    for (i=0; i<NUM_CORE_STATES; i++) {
    f47e:	42b5      	cmp	r5, r6
        crc=crcu32(track_counts[i],crc);
    f480:	4607      	mov	r7, r0
    for (i=0; i<NUM_CORE_STATES; i++) {
    f482:	d1f2      	bne.n	f46a <core_bench_state+0xc2>
}
    f484:	b012      	add	sp, #72	; 0x48
    f486:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    while (*p!=0) {
    f48a:	2a00      	cmp	r2, #0
    f48c:	d1cc      	bne.n	f428 <core_bench_state+0x80>
    f48e:	e7ea      	b.n	f466 <core_bench_state+0xbe>
    while (p < (memblock+blksize)) { /* insert some corruption */
    f490:	44a2      	add	sl, r4
    f492:	4554      	cmp	r4, sl
    p=memblock;
    f494:	9401      	str	r4, [sp, #4]
    f496:	ad01      	add	r5, sp, #4
    while (p < (memblock+blksize)) { /* insert some corruption */
    f498:	d3b5      	bcc.n	f406 <core_bench_state+0x5e>
    f49a:	e7e4      	b.n	f466 <core_bench_state+0xbe>
    p=memblock;
    f49c:	9401      	str	r4, [sp, #4]
    f49e:	e7d7      	b.n	f450 <core_bench_state+0xa8>

0000f4a0 <get_seed_32>:
    extern volatile ee_s32 seed3_volatile;
    extern volatile ee_s32 seed4_volatile;
    extern volatile ee_s32 seed5_volatile;
    ee_s32 get_seed_32(int i) {
        ee_s32 retval;
        switch (i) {
    f4a0:	3801      	subs	r0, #1
    f4a2:	2804      	cmp	r0, #4
    f4a4:	d813      	bhi.n	f4ce <get_seed_32+0x2e>
    f4a6:	e8df f000 	tbb	[pc, r0]
    f4aa:	0906      	.short	0x0906
    f4ac:	0f0c      	.short	0x0f0c
    f4ae:	03          	.byte	0x03
    f4af:	00          	.byte	0x00
                break;
            case 4:
                retval=seed4_volatile;
                break;
            case 5:
                retval=seed5_volatile;
    f4b0:	4b08      	ldr	r3, [pc, #32]	; (f4d4 <get_seed_32+0x34>)
    f4b2:	6818      	ldr	r0, [r3, #0]
                break;
    f4b4:	4770      	bx	lr
                retval=seed1_volatile;
    f4b6:	4b08      	ldr	r3, [pc, #32]	; (f4d8 <get_seed_32+0x38>)
    f4b8:	6818      	ldr	r0, [r3, #0]
                break;
    f4ba:	4770      	bx	lr
                retval=seed2_volatile;
    f4bc:	4807      	ldr	r0, [pc, #28]	; (f4dc <get_seed_32+0x3c>)
    f4be:	6800      	ldr	r0, [r0, #0]
                break;
    f4c0:	4770      	bx	lr
                retval=seed3_volatile;
    f4c2:	4a07      	ldr	r2, [pc, #28]	; (f4e0 <get_seed_32+0x40>)
    f4c4:	6810      	ldr	r0, [r2, #0]
                break;
    f4c6:	4770      	bx	lr
                retval=seed4_volatile;
    f4c8:	4906      	ldr	r1, [pc, #24]	; (f4e4 <get_seed_32+0x44>)
    f4ca:	6808      	ldr	r0, [r1, #0]
                break;
    f4cc:	4770      	bx	lr
            default:
                retval=0;
    f4ce:	2000      	movs	r0, #0
                break;
        }
        return retval;
    }
    f4d0:	4770      	bx	lr
    f4d2:	bf00      	nop
    f4d4:	10001050 	.word	0x10001050
    f4d8:	10001048 	.word	0x10001048
    f4dc:	1000104c 	.word	0x1000104c
    f4e0:	10001004 	.word	0x10001004
    f4e4:	10001008 	.word	0x10001008

0000f4e8 <crcu16>:
        }
        else
            carry = 0;
        crc >>= 1;
        if (carry)
           crc |= 0x8000;
    f4e8:	f24a 0201 	movw	r2, #40961	; 0xa001
    f4ec:	084b      	lsrs	r3, r1, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f4ee:	4041      	eors	r1, r0
    f4f0:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    f4f4:	ea83 0102 	eor.w	r1, r3, r2
           crc &= 0x7fff;
    }
    return crc;
}
ee_u16 crcu16(ee_u16 newval, ee_u16 crc) {
    crc=crcu8( (ee_u8) (newval)             ,crc);
    f4f8:	fa5f fc80 	uxtb.w	ip, r0
    f4fc:	bf18      	it	ne
    f4fe:	460b      	movne	r3, r1
ee_u16 crcu16(ee_u16 newval, ee_u16 crc) {
    f500:	b410      	push	{r4}
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f502:	ea83 045c 	eor.w	r4, r3, ip, lsr #1
    f506:	085b      	lsrs	r3, r3, #1
    f508:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f50c:	ea83 0102 	eor.w	r1, r3, r2
    f510:	bf18      	it	ne
    f512:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f514:	ea83 049c 	eor.w	r4, r3, ip, lsr #2
    f518:	085b      	lsrs	r3, r3, #1
    f51a:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f51e:	ea83 0102 	eor.w	r1, r3, r2
    f522:	bf18      	it	ne
    f524:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f526:	ea83 04dc 	eor.w	r4, r3, ip, lsr #3
    f52a:	085b      	lsrs	r3, r3, #1
    f52c:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f530:	ea83 0102 	eor.w	r1, r3, r2
    f534:	bf18      	it	ne
    f536:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f538:	ea83 141c 	eor.w	r4, r3, ip, lsr #4
    f53c:	085b      	lsrs	r3, r3, #1
    f53e:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f542:	ea83 0102 	eor.w	r1, r3, r2
    f546:	bf18      	it	ne
    f548:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f54a:	ea83 145c 	eor.w	r4, r3, ip, lsr #5
    f54e:	085b      	lsrs	r3, r3, #1
    f550:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f554:	ea83 0102 	eor.w	r1, r3, r2
    f558:	bf18      	it	ne
    f55a:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f55c:	ea83 149c 	eor.w	r4, r3, ip, lsr #6
    f560:	085b      	lsrs	r3, r3, #1
    f562:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f566:	ea83 0102 	eor.w	r1, r3, r2
    f56a:	bf18      	it	ne
    f56c:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f56e:	ea83 14dc 	eor.w	r4, r3, ip, lsr #7
    f572:	085b      	lsrs	r3, r3, #1
    f574:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f578:	ea83 0c02 	eor.w	ip, r3, r2
    f57c:	bf18      	it	ne
    f57e:	4663      	movne	r3, ip
    crc=crcu8( (ee_u8) ((newval)>>8)    ,crc);
    f580:	0a00      	lsrs	r0, r0, #8
    f582:	0859      	lsrs	r1, r3, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f584:	4043      	eors	r3, r0
    f586:	f013 0f01 	tst.w	r3, #1
    crc=crcu8( (ee_u8) ((newval)>>8)    ,crc);
    f58a:	fa5f fc80 	uxtb.w	ip, r0
           crc |= 0x8000;
    f58e:	ea81 0302 	eor.w	r3, r1, r2
    f592:	bf08      	it	eq
    f594:	460b      	moveq	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f596:	ea83 045c 	eor.w	r4, r3, ip, lsr #1
    f59a:	0858      	lsrs	r0, r3, #1
    f59c:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f5a0:	ea80 0302 	eor.w	r3, r0, r2
    f5a4:	bf08      	it	eq
    f5a6:	4603      	moveq	r3, r0
    f5a8:	085c      	lsrs	r4, r3, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f5aa:	ea83 019c 	eor.w	r1, r3, ip, lsr #2
    f5ae:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    f5b2:	ea84 0002 	eor.w	r0, r4, r2
    f5b6:	bf18      	it	ne
    f5b8:	4604      	movne	r4, r0
    f5ba:	0863      	lsrs	r3, r4, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f5bc:	ea84 01dc 	eor.w	r1, r4, ip, lsr #3
    f5c0:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    f5c4:	ea83 0402 	eor.w	r4, r3, r2
    f5c8:	bf18      	it	ne
    f5ca:	4623      	movne	r3, r4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f5cc:	ea83 101c 	eor.w	r0, r3, ip, lsr #4
    f5d0:	085b      	lsrs	r3, r3, #1
    f5d2:	f010 0f01 	tst.w	r0, #1
           crc |= 0x8000;
    f5d6:	ea83 0102 	eor.w	r1, r3, r2
    f5da:	bf18      	it	ne
    f5dc:	460b      	movne	r3, r1
    f5de:	0858      	lsrs	r0, r3, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f5e0:	ea83 145c 	eor.w	r4, r3, ip, lsr #5
    f5e4:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f5e8:	ea80 0302 	eor.w	r3, r0, r2
    f5ec:	bf18      	it	ne
    f5ee:	4618      	movne	r0, r3
    f5f0:	0844      	lsrs	r4, r0, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f5f2:	ea80 119c 	eor.w	r1, r0, ip, lsr #6
    f5f6:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    f5fa:	ea84 0002 	eor.w	r0, r4, r2
    f5fe:	bf18      	it	ne
    f600:	4604      	movne	r4, r0
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f602:	ea84 11dc 	eor.w	r1, r4, ip, lsr #7
    f606:	0863      	lsrs	r3, r4, #1
    return crc;
    f608:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    f60c:	ea83 0002 	eor.w	r0, r3, r2
}
    f610:	f85d 4b04 	ldr.w	r4, [sp], #4
    f614:	bf08      	it	eq
    f616:	4618      	moveq	r0, r3
    f618:	4770      	bx	lr
    f61a:	bf00      	nop

0000f61c <crcu32>:
           crc |= 0x8000;
    f61c:	f24a 0201 	movw	r2, #40961	; 0xa001
    f620:	084b      	lsrs	r3, r1, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f622:	4041      	eors	r1, r0
    f624:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    f628:	ea83 0102 	eor.w	r1, r3, r2
    f62c:	bf18      	it	ne
    f62e:	460b      	movne	r3, r1
ee_u16 crcu32(ee_u32 newval, ee_u16 crc) {
    f630:	b430      	push	{r4, r5}
    crc=crcu8( (ee_u8) (newval)             ,crc);
    f632:	b2c5      	uxtb	r5, r0
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f634:	ea83 0455 	eor.w	r4, r3, r5, lsr #1
    f638:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    f63a:	ea83 0c02 	eor.w	ip, r3, r2
    f63e:	f014 0f01 	tst.w	r4, #1
    f642:	bf18      	it	ne
    f644:	4663      	movne	r3, ip
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f646:	ea83 0195 	eor.w	r1, r3, r5, lsr #2
    f64a:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    f64c:	ea83 0402 	eor.w	r4, r3, r2
    f650:	f011 0f01 	tst.w	r1, #1
    f654:	bf18      	it	ne
    f656:	4623      	movne	r3, r4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f658:	ea83 01d5 	eor.w	r1, r3, r5, lsr #3
    f65c:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    f65e:	ea83 0c02 	eor.w	ip, r3, r2
    f662:	f011 0f01 	tst.w	r1, #1
    f666:	bf18      	it	ne
    f668:	4663      	movne	r3, ip
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f66a:	ea83 1415 	eor.w	r4, r3, r5, lsr #4
    f66e:	0859      	lsrs	r1, r3, #1
           crc |= 0x8000;
    f670:	ea81 0302 	eor.w	r3, r1, r2
    f674:	f014 0f01 	tst.w	r4, #1
    f678:	bf18      	it	ne
    f67a:	4619      	movne	r1, r3
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f67c:	ea81 1c55 	eor.w	ip, r1, r5, lsr #5
    f680:	0849      	lsrs	r1, r1, #1
           crc |= 0x8000;
    f682:	ea81 0402 	eor.w	r4, r1, r2
    f686:	f01c 0f01 	tst.w	ip, #1
    f68a:	bf18      	it	ne
    f68c:	4621      	movne	r1, r4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f68e:	ea81 1c95 	eor.w	ip, r1, r5, lsr #6
    f692:	084b      	lsrs	r3, r1, #1
           crc |= 0x8000;
    f694:	ea83 0102 	eor.w	r1, r3, r2
    f698:	f01c 0f01 	tst.w	ip, #1
    f69c:	bf18      	it	ne
    f69e:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f6a0:	ea83 15d5 	eor.w	r5, r3, r5, lsr #7
    f6a4:	f015 0f01 	tst.w	r5, #1
    f6a8:	ea4f 0353 	mov.w	r3, r3, lsr #1
           crc |= 0x8000;
    f6ac:	ea83 0402 	eor.w	r4, r3, r2
    crc=crcu8( (ee_u8) ((newval)>>8)    ,crc);
    f6b0:	f3c0 2107 	ubfx	r1, r0, #8, #8
    f6b4:	bf08      	it	eq
    f6b6:	461c      	moveq	r4, r3
    f6b8:	0863      	lsrs	r3, r4, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f6ba:	404c      	eors	r4, r1
           crc |= 0x8000;
    f6bc:	ea83 0c02 	eor.w	ip, r3, r2
    f6c0:	f014 0f01 	tst.w	r4, #1
    crc=crcu8( (ee_u8) ((newval)>>8)    ,crc);
    f6c4:	b2cd      	uxtb	r5, r1
    f6c6:	bf18      	it	ne
    f6c8:	4663      	movne	r3, ip
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f6ca:	ea83 0455 	eor.w	r4, r3, r5, lsr #1
    f6ce:	0859      	lsrs	r1, r3, #1
           crc |= 0x8000;
    f6d0:	ea81 0302 	eor.w	r3, r1, r2
    f6d4:	f014 0f01 	tst.w	r4, #1
    f6d8:	bf18      	it	ne
    f6da:	4619      	movne	r1, r3
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f6dc:	ea81 0c95 	eor.w	ip, r1, r5, lsr #2
    f6e0:	0849      	lsrs	r1, r1, #1
           crc |= 0x8000;
    f6e2:	ea81 0402 	eor.w	r4, r1, r2
    f6e6:	f01c 0f01 	tst.w	ip, #1
    f6ea:	bf18      	it	ne
    f6ec:	4621      	movne	r1, r4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f6ee:	ea81 0cd5 	eor.w	ip, r1, r5, lsr #3
    f6f2:	084b      	lsrs	r3, r1, #1
           crc |= 0x8000;
    f6f4:	ea83 0102 	eor.w	r1, r3, r2
    f6f8:	f01c 0f01 	tst.w	ip, #1
    f6fc:	bf18      	it	ne
    f6fe:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f700:	ea83 1415 	eor.w	r4, r3, r5, lsr #4
    f704:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    f706:	ea83 0c02 	eor.w	ip, r3, r2
    f70a:	f014 0f01 	tst.w	r4, #1
    f70e:	bf18      	it	ne
    f710:	4663      	movne	r3, ip
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f712:	ea83 1155 	eor.w	r1, r3, r5, lsr #5
    f716:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    f718:	ea83 0402 	eor.w	r4, r3, r2
    f71c:	f011 0f01 	tst.w	r1, #1
    f720:	bf18      	it	ne
    f722:	4623      	movne	r3, r4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f724:	ea83 1195 	eor.w	r1, r3, r5, lsr #6
    f728:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    f72a:	ea83 0c02 	eor.w	ip, r3, r2
    f72e:	f011 0f01 	tst.w	r1, #1
    f732:	bf18      	it	ne
    f734:	4663      	movne	r3, ip
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f736:	ea83 15d5 	eor.w	r5, r3, r5, lsr #7
    f73a:	085c      	lsrs	r4, r3, #1
    f73c:	f015 0f01 	tst.w	r5, #1
           crc |= 0x8000;
    f740:	ea84 0102 	eor.w	r1, r4, r2
    crc=crc16((ee_s16) newval       ,crc);
    crc=crc16((ee_s16) (newval>>16) ,crc);
    f744:	ea4f 4010 	mov.w	r0, r0, lsr #16
    f748:	bf08      	it	eq
    f74a:	4621      	moveq	r1, r4
    f74c:	084b      	lsrs	r3, r1, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f74e:	4041      	eors	r1, r0
           crc |= 0x8000;
    f750:	ea83 0c02 	eor.w	ip, r3, r2
    f754:	f011 0f01 	tst.w	r1, #1
    crc=crcu8( (ee_u8) (newval)             ,crc);
    f758:	b2c5      	uxtb	r5, r0
    f75a:	bf18      	it	ne
    f75c:	4663      	movne	r3, ip
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f75e:	ea83 0455 	eor.w	r4, r3, r5, lsr #1
    f762:	0859      	lsrs	r1, r3, #1
           crc |= 0x8000;
    f764:	ea81 0302 	eor.w	r3, r1, r2
    f768:	f014 0f01 	tst.w	r4, #1
    f76c:	bf18      	it	ne
    f76e:	4619      	movne	r1, r3
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f770:	ea81 0c95 	eor.w	ip, r1, r5, lsr #2
    f774:	0849      	lsrs	r1, r1, #1
           crc |= 0x8000;
    f776:	ea81 0402 	eor.w	r4, r1, r2
    f77a:	f01c 0f01 	tst.w	ip, #1
    f77e:	bf18      	it	ne
    f780:	4621      	movne	r1, r4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f782:	ea81 0cd5 	eor.w	ip, r1, r5, lsr #3
    f786:	084b      	lsrs	r3, r1, #1
           crc |= 0x8000;
    f788:	ea83 0102 	eor.w	r1, r3, r2
    f78c:	f01c 0f01 	tst.w	ip, #1
    f790:	bf18      	it	ne
    f792:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f794:	ea83 1415 	eor.w	r4, r3, r5, lsr #4
    f798:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    f79a:	ea83 0c02 	eor.w	ip, r3, r2
    f79e:	f014 0f01 	tst.w	r4, #1
    f7a2:	bf18      	it	ne
    f7a4:	4663      	movne	r3, ip
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f7a6:	ea83 1155 	eor.w	r1, r3, r5, lsr #5
    f7aa:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    f7ac:	ea83 0402 	eor.w	r4, r3, r2
    f7b0:	f011 0f01 	tst.w	r1, #1
    f7b4:	bf18      	it	ne
    f7b6:	4623      	movne	r3, r4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f7b8:	ea83 1195 	eor.w	r1, r3, r5, lsr #6
    f7bc:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    f7be:	ea83 0c02 	eor.w	ip, r3, r2
    f7c2:	f011 0f01 	tst.w	r1, #1
    f7c6:	bf18      	it	ne
    f7c8:	4663      	movne	r3, ip
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f7ca:	ea83 15d5 	eor.w	r5, r3, r5, lsr #7
    f7ce:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    f7d0:	ea83 0402 	eor.w	r4, r3, r2
    f7d4:	f015 0f01 	tst.w	r5, #1
    crc=crcu8( (ee_u8) ((newval)>>8)    ,crc);
    f7d8:	ea4f 2010 	mov.w	r0, r0, lsr #8
    f7dc:	bf18      	it	ne
    f7de:	4623      	movne	r3, r4
    f7e0:	085d      	lsrs	r5, r3, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f7e2:	4043      	eors	r3, r0
    f7e4:	f013 0f01 	tst.w	r3, #1
           crc |= 0x8000;
    f7e8:	ea85 0102 	eor.w	r1, r5, r2
    crc=crcu8( (ee_u8) ((newval)>>8)    ,crc);
    f7ec:	fa5f fc80 	uxtb.w	ip, r0
    f7f0:	bf14      	ite	ne
    f7f2:	4608      	movne	r0, r1
    f7f4:	4628      	moveq	r0, r5
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f7f6:	ea80 035c 	eor.w	r3, r0, ip, lsr #1
    f7fa:	0844      	lsrs	r4, r0, #1
    f7fc:	f013 0f01 	tst.w	r3, #1
           crc |= 0x8000;
    f800:	ea84 0002 	eor.w	r0, r4, r2
    f804:	bf08      	it	eq
    f806:	4620      	moveq	r0, r4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f808:	ea80 059c 	eor.w	r5, r0, ip, lsr #2
    f80c:	0843      	lsrs	r3, r0, #1
    f80e:	f015 0f01 	tst.w	r5, #1
           crc |= 0x8000;
    f812:	ea83 0102 	eor.w	r1, r3, r2
    f816:	bf08      	it	eq
    f818:	4619      	moveq	r1, r3
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f81a:	ea81 04dc 	eor.w	r4, r1, ip, lsr #3
    f81e:	084d      	lsrs	r5, r1, #1
    f820:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f824:	ea85 0002 	eor.w	r0, r5, r2
    f828:	bf08      	it	eq
    f82a:	4628      	moveq	r0, r5
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f82c:	ea80 131c 	eor.w	r3, r0, ip, lsr #4
    f830:	0841      	lsrs	r1, r0, #1
    f832:	f013 0f01 	tst.w	r3, #1
           crc |= 0x8000;
    f836:	ea81 0402 	eor.w	r4, r1, r2
    f83a:	bf08      	it	eq
    f83c:	460c      	moveq	r4, r1
    f83e:	0860      	lsrs	r0, r4, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f840:	ea84 155c 	eor.w	r5, r4, ip, lsr #5
    f844:	f015 0f01 	tst.w	r5, #1
           crc |= 0x8000;
    f848:	ea80 0302 	eor.w	r3, r0, r2
    f84c:	bf18      	it	ne
    f84e:	4618      	movne	r0, r3
    f850:	0844      	lsrs	r4, r0, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f852:	ea80 119c 	eor.w	r1, r0, ip, lsr #6
           crc |= 0x8000;
    f856:	ea84 0502 	eor.w	r5, r4, r2
    f85a:	f011 0f01 	tst.w	r1, #1
    f85e:	bf18      	it	ne
    f860:	462c      	movne	r4, r5
    f862:	0860      	lsrs	r0, r4, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f864:	ea84 1cdc 	eor.w	ip, r4, ip, lsr #7
    return crc;
    f868:	f01c 0f01 	tst.w	ip, #1
           crc |= 0x8000;
    f86c:	ea82 0200 	eor.w	r2, r2, r0
}
    f870:	bf18      	it	ne
    f872:	4610      	movne	r0, r2
    f874:	bc30      	pop	{r4, r5}
    f876:	4770      	bx	lr

0000f878 <crc16>:
           crc |= 0x8000;
    f878:	f24a 0201 	movw	r2, #40961	; 0xa001
    f87c:	084b      	lsrs	r3, r1, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f87e:	4041      	eors	r1, r0
    f880:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    f884:	ea83 0102 	eor.w	r1, r3, r2
    crc=crcu8( (ee_u8) (newval)             ,crc);
    f888:	fa5f fc80 	uxtb.w	ip, r0
    f88c:	bf18      	it	ne
    f88e:	460b      	movne	r3, r1
ee_u16 crc16(ee_s16 newval, ee_u16 crc) {
    f890:	b410      	push	{r4}
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f892:	ea83 045c 	eor.w	r4, r3, ip, lsr #1
    f896:	085b      	lsrs	r3, r3, #1
    f898:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f89c:	ea83 0102 	eor.w	r1, r3, r2
    f8a0:	bf18      	it	ne
    f8a2:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f8a4:	ea83 049c 	eor.w	r4, r3, ip, lsr #2
    f8a8:	085b      	lsrs	r3, r3, #1
    f8aa:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f8ae:	ea83 0102 	eor.w	r1, r3, r2
    f8b2:	bf18      	it	ne
    f8b4:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f8b6:	ea83 04dc 	eor.w	r4, r3, ip, lsr #3
    f8ba:	085b      	lsrs	r3, r3, #1
    f8bc:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f8c0:	ea83 0102 	eor.w	r1, r3, r2
    f8c4:	bf18      	it	ne
    f8c6:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f8c8:	ea83 141c 	eor.w	r4, r3, ip, lsr #4
    f8cc:	085b      	lsrs	r3, r3, #1
    f8ce:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f8d2:	ea83 0102 	eor.w	r1, r3, r2
    f8d6:	bf18      	it	ne
    f8d8:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f8da:	ea83 145c 	eor.w	r4, r3, ip, lsr #5
    f8de:	085b      	lsrs	r3, r3, #1
    f8e0:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f8e4:	ea83 0102 	eor.w	r1, r3, r2
    f8e8:	bf18      	it	ne
    f8ea:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f8ec:	ea83 149c 	eor.w	r4, r3, ip, lsr #6
    f8f0:	085b      	lsrs	r3, r3, #1
    f8f2:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f8f6:	ea83 0102 	eor.w	r1, r3, r2
    f8fa:	bf18      	it	ne
    f8fc:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f8fe:	ea83 14dc 	eor.w	r4, r3, ip, lsr #7
    f902:	085b      	lsrs	r3, r3, #1
    f904:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f908:	ea83 0c02 	eor.w	ip, r3, r2
    f90c:	bf18      	it	ne
    f90e:	4663      	movne	r3, ip
    crc=crcu8( (ee_u8) ((newval)>>8)    ,crc);
    f910:	f3c0 2007 	ubfx	r0, r0, #8, #8
    f914:	0859      	lsrs	r1, r3, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f916:	4043      	eors	r3, r0
    f918:	f013 0f01 	tst.w	r3, #1
    crc=crcu8( (ee_u8) ((newval)>>8)    ,crc);
    f91c:	fa5f fc80 	uxtb.w	ip, r0
           crc |= 0x8000;
    f920:	ea81 0302 	eor.w	r3, r1, r2
    f924:	bf08      	it	eq
    f926:	460b      	moveq	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f928:	ea83 045c 	eor.w	r4, r3, ip, lsr #1
    f92c:	0858      	lsrs	r0, r3, #1
    f92e:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f932:	ea80 0302 	eor.w	r3, r0, r2
    f936:	bf08      	it	eq
    f938:	4603      	moveq	r3, r0
    f93a:	085c      	lsrs	r4, r3, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f93c:	ea83 019c 	eor.w	r1, r3, ip, lsr #2
    f940:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    f944:	ea84 0002 	eor.w	r0, r4, r2
    f948:	bf18      	it	ne
    f94a:	4604      	movne	r4, r0
    f94c:	0863      	lsrs	r3, r4, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f94e:	ea84 01dc 	eor.w	r1, r4, ip, lsr #3
    f952:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    f956:	ea83 0402 	eor.w	r4, r3, r2
    f95a:	bf18      	it	ne
    f95c:	4623      	movne	r3, r4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f95e:	ea83 101c 	eor.w	r0, r3, ip, lsr #4
    f962:	085b      	lsrs	r3, r3, #1
    f964:	f010 0f01 	tst.w	r0, #1
           crc |= 0x8000;
    f968:	ea83 0102 	eor.w	r1, r3, r2
    f96c:	bf18      	it	ne
    f96e:	460b      	movne	r3, r1
    f970:	0858      	lsrs	r0, r3, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f972:	ea83 145c 	eor.w	r4, r3, ip, lsr #5
    f976:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f97a:	ea80 0302 	eor.w	r3, r0, r2
    f97e:	bf18      	it	ne
    f980:	4618      	movne	r0, r3
    f982:	0844      	lsrs	r4, r0, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f984:	ea80 119c 	eor.w	r1, r0, ip, lsr #6
    f988:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    f98c:	ea84 0002 	eor.w	r0, r4, r2
    f990:	bf18      	it	ne
    f992:	4604      	movne	r4, r0
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f994:	ea84 11dc 	eor.w	r1, r4, ip, lsr #7
    f998:	0863      	lsrs	r3, r4, #1
    return crcu16((ee_u16)newval, crc);
    f99a:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    f99e:	ea83 0002 	eor.w	r0, r3, r2
}
    f9a2:	f85d 4b04 	ldr.w	r4, [sp], #4
    f9a6:	bf08      	it	eq
    f9a8:	4618      	moveq	r0, r3
    f9aa:	4770      	bx	lr

0000f9ac <check_data_types>:
    }
    if (retval>0) {
        ee_printf("ERROR: Please modify the datatypes in core_portme.h!\n");
    }
    return retval;
}
    f9ac:	2000      	movs	r0, #0
    f9ae:	4770      	bx	lr

0000f9b0 <NMI_Handler>:
#if AM_CMSIS_REGS
NMI_Handler(void)
#else // AM_CMSIS_REGS
am_nmi_isr(void)
#endif // AM_CMSIS_REGS
{
    f9b0:	e7fe      	b.n	f9b0 <NMI_Handler>
    f9b2:	bf00      	nop

0000f9b4 <DebugMon_Handler>:
// for examination by a debugger.
//
//*****************************************************************************
void
am_default_isr(void)
{
    f9b4:	e7fe      	b.n	f9b4 <DebugMon_Handler>
    f9b6:	bf00      	nop

0000f9b8 <Reset_Handler>:
    __asm("    ldr    r0, =0xE000ED08\n"
    f9b8:	4811      	ldr	r0, [pc, #68]	; (fa00 <zero_loop+0x12>)
    f9ba:	4912      	ldr	r1, [pc, #72]	; (fa04 <zero_loop+0x16>)
    f9bc:	6001      	str	r1, [r0, #0]
    __asm("    ldr    sp, [r1]");
    f9be:	f8d1 d000 	ldr.w	sp, [r1]
    __asm("ldr  r0, =0xE000ED88\n"
    f9c2:	4811      	ldr	r0, [pc, #68]	; (fa08 <zero_loop+0x1a>)
    f9c4:	6801      	ldr	r1, [r0, #0]
    f9c6:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    f9ca:	6001      	str	r1, [r0, #0]
    f9cc:	f3bf 8f4f 	dsb	sy
    f9d0:	f3bf 8f6f 	isb	sy
    __asm("    ldr     r0, =_init_data\n"
    f9d4:	480d      	ldr	r0, [pc, #52]	; (fa0c <zero_loop+0x1e>)
    f9d6:	490e      	ldr	r1, [pc, #56]	; (fa10 <zero_loop+0x22>)
    f9d8:	4a0e      	ldr	r2, [pc, #56]	; (fa14 <zero_loop+0x26>)

0000f9da <copy_loop>:
    f9da:	f850 3b04 	ldr.w	r3, [r0], #4
    f9de:	f841 3b04 	str.w	r3, [r1], #4
    f9e2:	4291      	cmp	r1, r2
    f9e4:	dbf9      	blt.n	f9da <copy_loop>
    __asm("    ldr     r0, =_sbss\n"
    f9e6:	480c      	ldr	r0, [pc, #48]	; (fa18 <zero_loop+0x2a>)
    f9e8:	490c      	ldr	r1, [pc, #48]	; (fa1c <zero_loop+0x2e>)
    f9ea:	f04f 0200 	mov.w	r2, #0

0000f9ee <zero_loop>:
    f9ee:	4288      	cmp	r0, r1
    f9f0:	bfb8      	it	lt
    f9f2:	f840 2b04 	strlt.w	r2, [r0], #4
    f9f6:	dbfa      	blt.n	f9ee <zero_loop>
    main();
    f9f8:	f7fd fe12 	bl	d620 <main>
    __asm("    bkpt     ");
    f9fc:	be00      	bkpt	0x0000
    f9fe:	0000      	.short	0x0000
    fa00:	e000ed08 	.word	0xe000ed08
    fa04:	0000c000 	.word	0x0000c000
    fa08:	e000ed88 	.word	0xe000ed88
    fa0c:	000136f4 	.word	0x000136f4
    fa10:	10001000 	.word	0x10001000
    fa14:	10001040 	.word	0x10001040
    fa18:	10001040 	.word	0x10001040
    fa1c:	10001644 	.word	0x10001644

0000fa20 <HardFault_Handler>:
}
#elif defined(__GNUC_STDC_INLINE__)
uint32_t __attribute__((naked))
HardFault_Handler(void)
{
    __asm("    push    {r7,lr}");
    fa20:	b580      	push	{r7, lr}
    __asm("    mov     r0, sp");
    fa22:	4668      	mov	r0, sp
    __asm("    adds    r0, #(2*4)");
    fa24:	3008      	adds	r0, #8
    __asm("    bl      am_util_faultisr_collect_data");
    fa26:	f000 f805 	bl	fa34 <am_util_faultisr_collect_data>
    __asm("    pop     {r0,pc}");
    fa2a:	bd01      	pop	{r0, pc}

0000fa2c <getStackedReg>:
}

uint32_t __attribute__((naked))
getStackedReg(uint32_t regnum, uint32_t u32SP)
{
    __asm("    lsls    r0, r0, #2");
    fa2c:	0080      	lsls	r0, r0, #2
    __asm("    adds    r0, r1");
    fa2e:	1840      	adds	r0, r0, r1
    __asm("    ldr     r0, [r0]");
    fa30:	6800      	ldr	r0, [r0, #0]
    __asm("    bx      lr");
    fa32:	4770      	bx	lr

0000fa34 <am_util_faultisr_collect_data>:
// HardFault_Handler() was called.
//
//*****************************************************************************
void
am_util_faultisr_collect_data(uint32_t u32IsrSP)
{
    fa34:	b500      	push	{lr}
    fa36:	b093      	sub	sp, #76	; 0x4c
    volatile am_fault_t sFaultData;
    am_hal_mcuctrl_fault_t sHalFaultData = {0};
    fa38:	2300      	movs	r3, #0
    // a breakpoint at the end of the routine.  If the printing is not used,
    // we'll get a compiler warning; so to avoid that warning, we'll use it
    // in a dummy assignment here.
    //
    sFaultData.u32CFSR = u32Mask;       // Avoid compiler warning
    sFaultData.u32CFSR = AM_REGVAL(AM_REG_SYSCTRL_CFSR_O);
    fa3a:	4a2e      	ldr	r2, [pc, #184]	; (faf4 <am_util_faultisr_collect_data+0xc0>)
    sFaultData.u32CFSR = u32Mask;       // Avoid compiler warning
    fa3c:	9310      	str	r3, [sp, #64]	; 0x40
    am_hal_mcuctrl_fault_t sHalFaultData = {0};
    fa3e:	9301      	str	r3, [sp, #4]
    fa40:	9300      	str	r3, [sp, #0]
    fa42:	9302      	str	r3, [sp, #8]
    fa44:	9303      	str	r3, [sp, #12]
    fa46:	9304      	str	r3, [sp, #16]
    fa48:	9305      	str	r3, [sp, #20]
    sFaultData.u32CFSR = AM_REGVAL(AM_REG_SYSCTRL_CFSR_O);
    fa4a:	6811      	ldr	r1, [r2, #0]
    fa4c:	9110      	str	r1, [sp, #64]	; 0x40
    sFaultData.u8MMSR  = (sFaultData.u32CFSR >> 0)  & 0xff;
    fa4e:	9b10      	ldr	r3, [sp, #64]	; 0x40
    fa50:	b2d9      	uxtb	r1, r3
    fa52:	f88d 1044 	strb.w	r1, [sp, #68]	; 0x44
    sFaultData.u8BFSR  = (sFaultData.u32CFSR >> 8)  & 0xff;
    fa56:	9b10      	ldr	r3, [sp, #64]	; 0x40
    fa58:	f3c3 2107 	ubfx	r1, r3, #8, #8
    fa5c:	f88d 1045 	strb.w	r1, [sp, #69]	; 0x45
    sFaultData.u16UFSR = (sFaultData.u32CFSR >> 16) & 0xffff;
    fa60:	9b10      	ldr	r3, [sp, #64]	; 0x40
    fa62:	0c19      	lsrs	r1, r3, #16
    fa64:	f8ad 1046 	strh.w	r1, [sp, #70]	; 0x46

    //
    // The address of the location that caused the fault.  e.g. if accessing an
    // invalid data location caused the fault, that address will appear here.
    //
    sFaultData.u32BFAR = AM_REGVAL(AM_REG_SYSCTRL_BFAR_O);
    fa68:	6912      	ldr	r2, [r2, #16]
    fa6a:	920f      	str	r2, [sp, #60]	; 0x3c

    //
    // The address of the instruction that caused the fault is the stacked PC
    // if BFSR bit1 is set.
    //
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    fa6c:	f89d 1045 	ldrb.w	r1, [sp, #69]	; 0x45
    fa70:	078a      	lsls	r2, r1, #30
{
    fa72:	4603      	mov	r3, r0
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    fa74:	d437      	bmi.n	fae6 <am_util_faultisr_collect_data+0xb2>
    fa76:	f04f 32ff 	mov.w	r2, #4294967295

    //
    // Get the stacked registers.
    // Note - the address of the instruction that caused the fault is u32PC.
    //
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    fa7a:	4619      	mov	r1, r3
    fa7c:	2000      	movs	r0, #0
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    fa7e:	920e      	str	r2, [sp, #56]	; 0x38
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    fa80:	f7ff ffd4 	bl	fa2c <getStackedReg>
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    fa84:	4619      	mov	r1, r3
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    fa86:	4602      	mov	r2, r0
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    fa88:	2001      	movs	r0, #1
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    fa8a:	9206      	str	r2, [sp, #24]
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    fa8c:	f7ff ffce 	bl	fa2c <getStackedReg>
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    fa90:	4619      	mov	r1, r3
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    fa92:	4602      	mov	r2, r0
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    fa94:	2002      	movs	r0, #2
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    fa96:	9207      	str	r2, [sp, #28]
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    fa98:	f7ff ffc8 	bl	fa2c <getStackedReg>
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    fa9c:	4619      	mov	r1, r3
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    fa9e:	4602      	mov	r2, r0
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    faa0:	2003      	movs	r0, #3
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    faa2:	9208      	str	r2, [sp, #32]
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    faa4:	f7ff ffc2 	bl	fa2c <getStackedReg>
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    faa8:	4619      	mov	r1, r3
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    faaa:	4602      	mov	r2, r0
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    faac:	2004      	movs	r0, #4
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    faae:	9209      	str	r2, [sp, #36]	; 0x24
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    fab0:	f7ff ffbc 	bl	fa2c <getStackedReg>
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    fab4:	4619      	mov	r1, r3
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    fab6:	4602      	mov	r2, r0
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    fab8:	2005      	movs	r0, #5
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    faba:	920a      	str	r2, [sp, #40]	; 0x28
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    fabc:	f7ff ffb6 	bl	fa2c <getStackedReg>
    fac0:	4602      	mov	r2, r0
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    fac2:	4619      	mov	r1, r3
    fac4:	2006      	movs	r0, #6
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    fac6:	920b      	str	r2, [sp, #44]	; 0x2c
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    fac8:	f7ff ffb0 	bl	fa2c <getStackedReg>
    facc:	4602      	mov	r2, r0
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    face:	4619      	mov	r1, r3
    fad0:	2007      	movs	r0, #7
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    fad2:	920c      	str	r2, [sp, #48]	; 0x30
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    fad4:	f7ff ffaa 	bl	fa2c <getStackedReg>

    //
    // Use the HAL MCUCTRL functions to read the fault data.
    //
#ifdef AM_APOLLO3_MCUCTRL
    am_hal_mcuctrl_info_get(AM_HAL_MCUCTRL_INFO_FAULT_STATUS, &sHalFaultData);
    fad8:	4669      	mov	r1, sp
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    fada:	4603      	mov	r3, r0
    am_hal_mcuctrl_info_get(AM_HAL_MCUCTRL_INFO_FAULT_STATUS, &sHalFaultData);
    fadc:	2002      	movs	r0, #2
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    fade:	930d      	str	r3, [sp, #52]	; 0x34
    am_hal_mcuctrl_info_get(AM_HAL_MCUCTRL_INFO_FAULT_STATUS, &sHalFaultData);
    fae0:	f001 fee4 	bl	118ac <am_hal_mcuctrl_info_get>
    fae4:	e7fe      	b.n	fae4 <am_util_faultisr_collect_data+0xb0>
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    fae6:	4601      	mov	r1, r0
    fae8:	2006      	movs	r0, #6
    faea:	f7ff ff9f 	bl	fa2c <getStackedReg>
    faee:	4602      	mov	r2, r0
    faf0:	e7c3      	b.n	fa7a <am_util_faultisr_collect_data+0x46>
    faf2:	bf00      	nop
    faf4:	e000ed28 	.word	0xe000ed28

0000faf8 <uint64_to_str>:
// written).
//
//*****************************************************************************
static int
uint64_to_str(uint64_t ui64Val, char *pcBuf)
{
    faf8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    fafc:	b095      	sub	sp, #84	; 0x54
    fafe:	f10d 0e34 	add.w	lr, sp, #52	; 0x34
    fb02:	4604      	mov	r4, r0
        //
        // Get modulus
        //
        uMod = ui64Val - (u64Tmp * 10);

        tbuf[ix++] = uMod + '0';
    fb04:	2001      	movs	r0, #1
{
    fb06:	460d      	mov	r5, r1
    fb08:	920b      	str	r2, [sp, #44]	; 0x2c
    fb0a:	46f4      	mov	ip, lr
    fb0c:	900a      	str	r0, [sp, #40]	; 0x28
    fb0e:	e00b      	b.n	fb28 <uint64_to_str+0x30>
        tbuf[ix++] = uMod + '0';
    fb10:	f88c 3000 	strb.w	r3, [ip]
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    fb14:	4604      	mov	r4, r0
    fb16:	2500      	movs	r5, #0
        ui64Val = u64Tmp;
    } while ( ui64Val );
    fb18:	2800      	cmp	r0, #0
    fb1a:	f000 8083 	beq.w	fc24 <uint64_to_str+0x12c>
    fb1e:	990a      	ldr	r1, [sp, #40]	; 0x28
    fb20:	3101      	adds	r1, #1
    fb22:	910a      	str	r1, [sp, #40]	; 0x28
    fb24:	f10c 0c01 	add.w	ip, ip, #1
        q32 = (ui32Val>>1) + (ui32Val>>2);
    fb28:	08a3      	lsrs	r3, r4, #2
    fb2a:	eb03 0154 	add.w	r1, r3, r4, lsr #1
        q32 += (q32 >> 4);
    fb2e:	eb01 1211 	add.w	r2, r1, r1, lsr #4
        q32 += (q32 >> 8);
    fb32:	eb02 2612 	add.w	r6, r2, r2, lsr #8
        q32 += (q32 >> 16);
    fb36:	eb06 4716 	add.w	r7, r6, r6, lsr #16
        q32 >>= 3;
    fb3a:	08f8      	lsrs	r0, r7, #3
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    fb3c:	1da3      	adds	r3, r4, #6
        r32 = ui32Val - q32*10;
    fb3e:	eb00 0880 	add.w	r8, r0, r0, lsl #2
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    fb42:	eba3 0148 	sub.w	r1, r3, r8, lsl #1
    fb46:	eb00 1011 	add.w	r0, r0, r1, lsr #4
    if ( ui64Val >> 32 )
    fb4a:	462e      	mov	r6, r5
        uMod = ui64Val - (u64Tmp * 10);
    fb4c:	eb00 0280 	add.w	r2, r0, r0, lsl #2
    if ( ui64Val >> 32 )
    fb50:	2700      	movs	r7, #0
        uMod = ui64Val - (u64Tmp * 10);
    fb52:	eba4 0342 	sub.w	r3, r4, r2, lsl #1
    if ( ui64Val >> 32 )
    fb56:	ea56 0107 	orrs.w	r1, r6, r7
        tbuf[ix++] = uMod + '0';
    fb5a:	f103 0330 	add.w	r3, r3, #48	; 0x30
    if ( ui64Val >> 32 )
    fb5e:	d0d7      	beq.n	fb10 <uint64_to_str+0x18>
        q64 = (ui64Val>>1) + (ui64Val>>2);
    fb60:	08a0      	lsrs	r0, r4, #2
    fb62:	ea40 7385 	orr.w	r3, r0, r5, lsl #30
    fb66:	08ae      	lsrs	r6, r5, #2
    fb68:	9304      	str	r3, [sp, #16]
    fb6a:	9605      	str	r6, [sp, #20]
    fb6c:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    fb70:	086b      	lsrs	r3, r5, #1
    fb72:	ea4f 0234 	mov.w	r2, r4, rrx
    fb76:	1882      	adds	r2, r0, r2
    fb78:	eb41 0303 	adc.w	r3, r1, r3
        q64 += (q64 >> 4);
    fb7c:	0911      	lsrs	r1, r2, #4
    fb7e:	ea41 7003 	orr.w	r0, r1, r3, lsl #28
    fb82:	1812      	adds	r2, r2, r0
    fb84:	ea4f 1613 	mov.w	r6, r3, lsr #4
    fb88:	4173      	adcs	r3, r6
        q64 += (q64 >> 8);
    fb8a:	0a11      	lsrs	r1, r2, #8
    fb8c:	ea41 6003 	orr.w	r0, r1, r3, lsl #24
    fb90:	0a1e      	lsrs	r6, r3, #8
    fb92:	9601      	str	r6, [sp, #4]
    fb94:	9000      	str	r0, [sp, #0]
    fb96:	e9dd 0100 	ldrd	r0, r1, [sp]
    fb9a:	1882      	adds	r2, r0, r2
    fb9c:	4616      	mov	r6, r2
    fb9e:	eb41 0303 	adc.w	r3, r1, r3
        q64 += (q64 >> 16);
    fba2:	0c31      	lsrs	r1, r6, #16
        q64 += (q64 >> 8);
    fba4:	461a      	mov	r2, r3
        q64 += (q64 >> 16);
    fba6:	ea41 4003 	orr.w	r0, r1, r3, lsl #16
    fbaa:	0c1b      	lsrs	r3, r3, #16
    fbac:	9303      	str	r3, [sp, #12]
    fbae:	9002      	str	r0, [sp, #8]
    fbb0:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    fbb4:	eb10 0806 	adds.w	r8, r0, r6
    fbb8:	eb41 0302 	adc.w	r3, r1, r2
        q64 += (q64 >> 32);
    fbbc:	9308      	str	r3, [sp, #32]
    fbbe:	9709      	str	r7, [sp, #36]	; 0x24
    fbc0:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
    fbc4:	eb10 0208 	adds.w	r2, r0, r8
    fbc8:	eb41 0303 	adc.w	r3, r1, r3
        q64 >>= 3;
    fbcc:	08d1      	lsrs	r1, r2, #3
    fbce:	ea41 7643 	orr.w	r6, r1, r3, lsl #29
    fbd2:	08df      	lsrs	r7, r3, #3
        r64 = ui64Val - q64*10;
    fbd4:	00b8      	lsls	r0, r7, #2
    fbd6:	ea4f 0a86 	mov.w	sl, r6, lsl #2
    fbda:	eb1a 0906 	adds.w	r9, sl, r6
    fbde:	ea40 7896 	orr.w	r8, r0, r6, lsr #30
    fbe2:	eb48 0307 	adc.w	r3, r8, r7
    fbe6:	eb19 0209 	adds.w	r2, r9, r9
    fbea:	415b      	adcs	r3, r3
        return q64 + ((r64 + 6) >> 4);
    fbec:	f114 0b06 	adds.w	fp, r4, #6
    fbf0:	f145 0500 	adc.w	r5, r5, #0
    fbf4:	ebbb 0202 	subs.w	r2, fp, r2
    fbf8:	eb65 0303 	sbc.w	r3, r5, r3
    fbfc:	0915      	lsrs	r5, r2, #4
    fbfe:	ea45 7203 	orr.w	r2, r5, r3, lsl #28
    fc02:	091b      	lsrs	r3, r3, #4
    fc04:	9206      	str	r2, [sp, #24]
    fc06:	9307      	str	r3, [sp, #28]
    fc08:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    fc0c:	1996      	adds	r6, r2, r6
    fc0e:	eb43 0507 	adc.w	r5, r3, r7
        uMod = ui64Val - (u64Tmp * 10);
    fc12:	eb06 0786 	add.w	r7, r6, r6, lsl #2
    fc16:	eba4 0447 	sub.w	r4, r4, r7, lsl #1
        tbuf[ix++] = uMod + '0';
    fc1a:	3430      	adds	r4, #48	; 0x30
    fc1c:	f88c 4000 	strb.w	r4, [ip]
    fc20:	4634      	mov	r4, r6
    fc22:	e77c      	b.n	fb1e <uint64_to_str+0x26>
    iNumDig = ix;

    //
    // Now, reverse the buffer when saving to the caller's buffer.
    //
    if ( pcBuf )
    fc24:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
    fc26:	980a      	ldr	r0, [sp, #40]	; 0x28
    fc28:	2e00      	cmp	r6, #0
    fc2a:	d059      	beq.n	fce0 <uint64_to_str+0x1e8>
    fc2c:	eb0e 0a00 	add.w	sl, lr, r0
    fc30:	46d3      	mov	fp, sl
    fc32:	ea6f 0c0e 	mvn.w	ip, lr
    {
        while ( ix-- )
        {
            *pcBuf++ = tbuf[ix];
    fc36:	f81b 7d01 	ldrb.w	r7, [fp, #-1]!
    fc3a:	7037      	strb	r7, [r6, #0]
    fc3c:	44d4      	add	ip, sl
        while ( ix-- )
    fc3e:	45de      	cmp	lr, fp
    fc40:	4632      	mov	r2, r6
    fc42:	f00c 0107 	and.w	r1, ip, #7
    fc46:	bf08      	it	eq
    fc48:	4632      	moveq	r2, r6
    fc4a:	d047      	beq.n	fcdc <uint64_to_str+0x1e4>
    fc4c:	b349      	cbz	r1, fca2 <uint64_to_str+0x1aa>
    fc4e:	2901      	cmp	r1, #1
    fc50:	d021      	beq.n	fc96 <uint64_to_str+0x19e>
    fc52:	2902      	cmp	r1, #2
    fc54:	d01b      	beq.n	fc8e <uint64_to_str+0x196>
    fc56:	2903      	cmp	r1, #3
    fc58:	d015      	beq.n	fc86 <uint64_to_str+0x18e>
    fc5a:	2904      	cmp	r1, #4
    fc5c:	d00f      	beq.n	fc7e <uint64_to_str+0x186>
    fc5e:	2905      	cmp	r1, #5
    fc60:	d009      	beq.n	fc76 <uint64_to_str+0x17e>
    fc62:	2906      	cmp	r1, #6
            *pcBuf++ = tbuf[ix];
    fc64:	bf1c      	itt	ne
    fc66:	f81b 1d01 	ldrbne.w	r1, [fp, #-1]!
    fc6a:	f802 1f01 	strbne.w	r1, [r2, #1]!
    fc6e:	f81b 3d01 	ldrb.w	r3, [fp, #-1]!
    fc72:	f802 3f01 	strb.w	r3, [r2, #1]!
    fc76:	f81b 6d01 	ldrb.w	r6, [fp, #-1]!
    fc7a:	f802 6f01 	strb.w	r6, [r2, #1]!
    fc7e:	f81b 4d01 	ldrb.w	r4, [fp, #-1]!
    fc82:	f802 4f01 	strb.w	r4, [r2, #1]!
    fc86:	f81b 7d01 	ldrb.w	r7, [fp, #-1]!
    fc8a:	f802 7f01 	strb.w	r7, [r2, #1]!
    fc8e:	f81b 5d01 	ldrb.w	r5, [fp, #-1]!
    fc92:	f802 5f01 	strb.w	r5, [r2, #1]!
    fc96:	f81b 8d01 	ldrb.w	r8, [fp, #-1]!
    fc9a:	f802 8f01 	strb.w	r8, [r2, #1]!
        while ( ix-- )
    fc9e:	45de      	cmp	lr, fp
    fca0:	d01b      	beq.n	fcda <uint64_to_str+0x1e2>
            *pcBuf++ = tbuf[ix];
    fca2:	f81b 1c01 	ldrb.w	r1, [fp, #-1]
    fca6:	f81b 3c02 	ldrb.w	r3, [fp, #-2]
    fcaa:	f81b 9c03 	ldrb.w	r9, [fp, #-3]
    fcae:	f81b 7c04 	ldrb.w	r7, [fp, #-4]
    fcb2:	f81b 6c05 	ldrb.w	r6, [fp, #-5]
    fcb6:	f81b 5c06 	ldrb.w	r5, [fp, #-6]
    fcba:	f81b 4c07 	ldrb.w	r4, [fp, #-7]
    fcbe:	f81b ad08 	ldrb.w	sl, [fp, #-8]!
    fcc2:	7051      	strb	r1, [r2, #1]
        while ( ix-- )
    fcc4:	45de      	cmp	lr, fp
            *pcBuf++ = tbuf[ix];
    fcc6:	7093      	strb	r3, [r2, #2]
    fcc8:	f882 9003 	strb.w	r9, [r2, #3]
    fccc:	7117      	strb	r7, [r2, #4]
    fcce:	7156      	strb	r6, [r2, #5]
    fcd0:	7195      	strb	r5, [r2, #6]
    fcd2:	71d4      	strb	r4, [r2, #7]
    fcd4:	f802 af08 	strb.w	sl, [r2, #8]!
        while ( ix-- )
    fcd8:	d1e3      	bne.n	fca2 <uint64_to_str+0x1aa>
    fcda:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
        }

        //
        // Terminate the caller's buffer
        //
        *pcBuf = 0x00;
    fcdc:	2100      	movs	r1, #0
    fcde:	5411      	strb	r1, [r2, r0]
    }

    return iNumDig;
}
    fce0:	b015      	add	sp, #84	; 0x54
    fce2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    fce6:	bf00      	nop

0000fce8 <am_util_stdio_printf_init>:
    g_pfnCharPrint = pfnCharPrint;
    fce8:	4b01      	ldr	r3, [pc, #4]	; (fcf0 <am_util_stdio_printf_init+0x8>)
    fcea:	6018      	str	r0, [r3, #0]
    fcec:	4770      	bx	lr
    fcee:	bf00      	nop
    fcf0:	10001578 	.word	0x10001578

0000fcf4 <am_util_stdio_vsprintf>:
//! @return uint32_t representing the number of characters printed.
//
//******************************************************************************
uint32_t
am_util_stdio_vsprintf(char *pcBuf, const char *pcFmt, va_list pArgs)
{
    fcf4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    fcf8:	4680      	mov	r8, r0
    fcfa:	b0b1      	sub	sp, #196	; 0xc4
    fcfc:	4693      	mov	fp, r2
    char *pcStr;
    uint64_t ui64Val;
    int64_t i64Val;
    uint32_t ui32NumChars, ui32CharCnt = 0;
    fcfe:	f04f 0900 	mov.w	r9, #0
    int iWidth, iVal, iPrecision;
    uint8_t ui8CharSpecifier, ui8PadChar;
    bool bLower, bLongLong, bNeg;
    uint32_t ui32strlen = 0;

    while ( *pcFmt != 0x0 )
    fd02:	780b      	ldrb	r3, [r1, #0]
    fd04:	b183      	cbz	r3, fd28 <am_util_stdio_vsprintf+0x34>
    {
        iPrecision = 6;             // printf() default precision for %f is 6

        if ( *pcFmt != '%' )
    fd06:	2b25      	cmp	r3, #37	; 0x25
    fd08:	d017      	beq.n	fd3a <am_util_stdio_vsprintf+0x46>
        {
            //
            // Accumulate the string portion of the format specification.
            //
            if ( pcBuf )
    fd0a:	f1b8 0f00 	cmp.w	r8, #0
    fd0e:	d005      	beq.n	fd1c <am_util_stdio_vsprintf+0x28>
            {
                // If '\n', convert to '\r\n'
                if ( *pcFmt == '\n'  &&  g_bTxtXlate )
    fd10:	2b0a      	cmp	r3, #10
    fd12:	d038      	beq.n	fd86 <am_util_stdio_vsprintf+0x92>
                {
                    *pcBuf++ = '\r';
                    ++ui32CharCnt;
                }
                *pcBuf++ = *pcFmt;
    fd14:	f888 3000 	strb.w	r3, [r8]
    fd18:	f108 0801 	add.w	r8, r8, #1
            }

            ++pcFmt;
    fd1c:	3101      	adds	r1, #1
    while ( *pcFmt != 0x0 )
    fd1e:	780b      	ldrb	r3, [r1, #0]
            ++ui32CharCnt;
    fd20:	f109 0901 	add.w	r9, r9, #1
    while ( *pcFmt != 0x0 )
    fd24:	2b00      	cmp	r3, #0
    fd26:	d1ee      	bne.n	fd06 <am_util_stdio_vsprintf+0x12>
    } // while ()

    //
    // Terminate the string
    //
    if ( pcBuf )
    fd28:	f1b8 0f00 	cmp.w	r8, #0
    fd2c:	d001      	beq.n	fd32 <am_util_stdio_vsprintf+0x3e>
    {
        *pcBuf = 0x0;
    fd2e:	f888 3000 	strb.w	r3, [r8]
    }

    return (ui32CharCnt);
}
    fd32:	4648      	mov	r0, r9
    fd34:	b031      	add	sp, #196	; 0xc4
    fd36:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ( *pcFmt == '0' )
    fd3a:	784a      	ldrb	r2, [r1, #1]
    fd3c:	2a30      	cmp	r2, #48	; 0x30
    fd3e:	d03b      	beq.n	fdb8 <am_util_stdio_vsprintf+0xc4>
        ++pcFmt;
    fd40:	1c4e      	adds	r6, r1, #1
        ui8PadChar = ' ';
    fd42:	2520      	movs	r5, #32
    if ( *pcStr == '-')
    fd44:	2a2d      	cmp	r2, #45	; 0x2d
    fd46:	d02c      	beq.n	fda2 <am_util_stdio_vsprintf+0xae>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    fd48:	f1a2 0030 	sub.w	r0, r2, #48	; 0x30
    fd4c:	2809      	cmp	r0, #9
    fd4e:	d837      	bhi.n	fdc0 <am_util_stdio_vsprintf+0xcc>
    uint32_t ui32Val = 0, uCnt = 0;
    fd50:	2100      	movs	r1, #0
    bool bNeg = false;
    fd52:	468e      	mov	lr, r1
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    fd54:	4630      	mov	r0, r6
        bNeg = true;
    fd56:	f04f 0c00 	mov.w	ip, #0
        ui32Val *= 10;
    fd5a:	eb0c 078c 	add.w	r7, ip, ip, lsl #2
        ui32Val += (*pcStr - '0');
    fd5e:	eb02 0a47 	add.w	sl, r2, r7, lsl #1
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    fd62:	f810 2f01 	ldrb.w	r2, [r0, #1]!
    fd66:	f1a2 0430 	sub.w	r4, r2, #48	; 0x30
    fd6a:	2c09      	cmp	r4, #9
        ++uCnt;
    fd6c:	f101 0101 	add.w	r1, r1, #1
        ui32Val += (*pcStr - '0');
    fd70:	f1aa 0c30 	sub.w	ip, sl, #48	; 0x30
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    fd74:	d9f1      	bls.n	fd5a <am_util_stdio_vsprintf+0x66>
    fd76:	440e      	add	r6, r1
    return bNeg ? -ui32Val : ui32Val;
    fd78:	f1be 0f00 	cmp.w	lr, #0
    fd7c:	f041 80a1 	bne.w	10ec2 <am_util_stdio_vsprintf+0x11ce>
    fd80:	4664      	mov	r4, ip
    fd82:	7832      	ldrb	r2, [r6, #0]
    fd84:	e01e      	b.n	fdc4 <am_util_stdio_vsprintf+0xd0>
                if ( *pcFmt == '\n'  &&  g_bTxtXlate )
    fd86:	4ebd      	ldr	r6, [pc, #756]	; (1007c <am_util_stdio_vsprintf+0x388>)
    fd88:	7837      	ldrb	r7, [r6, #0]
    fd8a:	2f00      	cmp	r7, #0
    fd8c:	d0c2      	beq.n	fd14 <am_util_stdio_vsprintf+0x20>
                    *pcBuf++ = '\r';
    fd8e:	f04f 0c0d 	mov.w	ip, #13
    fd92:	f888 c000 	strb.w	ip, [r8]
    fd96:	780b      	ldrb	r3, [r1, #0]
                    ++ui32CharCnt;
    fd98:	f109 0901 	add.w	r9, r9, #1
                    *pcBuf++ = '\r';
    fd9c:	f108 0801 	add.w	r8, r8, #1
    fda0:	e7b8      	b.n	fd14 <am_util_stdio_vsprintf+0x20>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    fda2:	7872      	ldrb	r2, [r6, #1]
    fda4:	f1a2 0430 	sub.w	r4, r2, #48	; 0x30
    fda8:	2c09      	cmp	r4, #9
        pcStr++;
    fdaa:	f106 0001 	add.w	r0, r6, #1
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    fdae:	f200 8611 	bhi.w	109d4 <am_util_stdio_vsprintf+0xce0>
        uCnt++;
    fdb2:	2101      	movs	r1, #1
        bNeg = true;
    fdb4:	468e      	mov	lr, r1
    fdb6:	e7ce      	b.n	fd56 <am_util_stdio_vsprintf+0x62>
    fdb8:	788a      	ldrb	r2, [r1, #2]
            ++pcFmt;
    fdba:	1c8e      	adds	r6, r1, #2
            ui8PadChar = '0';
    fdbc:	2530      	movs	r5, #48	; 0x30
    fdbe:	e7c1      	b.n	fd44 <am_util_stdio_vsprintf+0x50>
    fdc0:	7832      	ldrb	r2, [r6, #0]
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    fdc2:	2400      	movs	r4, #0
        if ( ( *pcFmt != 's' )  &&  ( iWidth < 0 ) )
    fdc4:	2a73      	cmp	r2, #115	; 0x73
    fdc6:	f000 8304 	beq.w	103d2 <am_util_stdio_vsprintf+0x6de>
    fdca:	ea84 73e4 	eor.w	r3, r4, r4, asr #31
        if (*pcFmt == '.')
    fdce:	2a2e      	cmp	r2, #46	; 0x2e
    fdd0:	eba3 77e4 	sub.w	r7, r3, r4, asr #31
    fdd4:	f000 82ae 	beq.w	10334 <am_util_stdio_vsprintf+0x640>
        iPrecision = 6;             // printf() default precision for %f is 6
    fdd8:	f04f 0a06 	mov.w	sl, #6
        if ( *pcFmt == 'l' )
    fddc:	2a6c      	cmp	r2, #108	; 0x6c
    fdde:	f000 82a3 	beq.w	10328 <am_util_stdio_vsprintf+0x634>
        switch ( *pcFmt )
    fde2:	f1a2 0046 	sub.w	r0, r2, #70	; 0x46
    fde6:	2832      	cmp	r0, #50	; 0x32
    fde8:	f200 8294 	bhi.w	10314 <am_util_stdio_vsprintf+0x620>
    fdec:	e8df f010 	tbh	[pc, r0, lsl #1]
    fdf0:	02920115 	.word	0x02920115
    fdf4:	02920292 	.word	0x02920292
    fdf8:	02920292 	.word	0x02920292
    fdfc:	02920292 	.word	0x02920292
    fe00:	02920292 	.word	0x02920292
    fe04:	02920292 	.word	0x02920292
    fe08:	02920292 	.word	0x02920292
    fe0c:	02920292 	.word	0x02920292
    fe10:	02920292 	.word	0x02920292
    fe14:	02920033 	.word	0x02920033
    fe18:	02920292 	.word	0x02920292
    fe1c:	02920292 	.word	0x02920292
    fe20:	02920292 	.word	0x02920292
    fe24:	02920292 	.word	0x02920292
    fe28:	01360292 	.word	0x01360292
    fe2c:	0292014a 	.word	0x0292014a
    fe30:	02920115 	.word	0x02920115
    fe34:	014a0292 	.word	0x014a0292
    fe38:	02920292 	.word	0x02920292
    fe3c:	02920292 	.word	0x02920292
    fe40:	02920292 	.word	0x02920292
    fe44:	02920292 	.word	0x02920292
    fe48:	02f00292 	.word	0x02f00292
    fe4c:	01f20292 	.word	0x01f20292
    fe50:	02920292 	.word	0x02920292
    fe54:	01ef      	.short	0x01ef
        bLower = bLongLong = false;
    fe56:	f04f 0c00 	mov.w	ip, #0
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    fe5a:	f8db 2000 	ldr.w	r2, [fp]
    fe5e:	2300      	movs	r3, #0
                                      va_arg(pArgs, uint32_t);
    fe60:	f10b 0b04 	add.w	fp, fp, #4
                if ( iWidth )
    fe64:	2c00      	cmp	r4, #0
    fe66:	d06d      	beq.n	ff44 <am_util_stdio_vsprintf+0x250>
    int iDigits = ui64Val ? 0 : 1;
    fe68:	ea52 0103 	orrs.w	r1, r2, r3
    fe6c:	bf0c      	ite	eq
    fe6e:	f04f 0e01 	moveq.w	lr, #1
    fe72:	f04f 0e00 	movne.w	lr, #0
    while ( ui64Val )
    fe76:	ea52 0103 	orrs.w	r1, r2, r3
    fe7a:	d00b      	beq.n	fe94 <am_util_stdio_vsprintf+0x1a0>
    fe7c:	4610      	mov	r0, r2
    fe7e:	4619      	mov	r1, r3
        ui64Val >>= 4;
    fe80:	090c      	lsrs	r4, r1, #4
    fe82:	0900      	lsrs	r0, r0, #4
    fe84:	ea40 7001 	orr.w	r0, r0, r1, lsl #28
    fe88:	4621      	mov	r1, r4
    while ( ui64Val )
    fe8a:	ea50 0401 	orrs.w	r4, r0, r1
        ++iDigits;
    fe8e:	f10e 0e01 	add.w	lr, lr, #1
    while ( ui64Val )
    fe92:	d1f5      	bne.n	fe80 <am_util_stdio_vsprintf+0x18c>
                    iWidth -= ndigits_in_hex(ui64Val);
    fe94:	eba7 070e 	sub.w	r7, r7, lr
    if ( i32NumChars <= 0 )
    fe98:	2f00      	cmp	r7, #0
    fe9a:	f340 855f 	ble.w	1095c <am_util_stdio_vsprintf+0xc68>
    while ( i32NumChars-- )
    fe9e:	f107 3aff 	add.w	sl, r7, #4294967295
        if ( pcBuf )
    fea2:	f1b8 0f00 	cmp.w	r8, #0
    fea6:	f000 855a 	beq.w	1095e <am_util_stdio_vsprintf+0xc6a>
            *pcBuf++ = cPadChar;
    feaa:	4641      	mov	r1, r8
    feac:	f00a 0707 	and.w	r7, sl, #7
    feb0:	f801 5b01 	strb.w	r5, [r1], #1
    while ( i32NumChars-- )
    feb4:	f10a 30ff 	add.w	r0, sl, #4294967295
    feb8:	eba1 0408 	sub.w	r4, r1, r8
    febc:	f1ba 0f00 	cmp.w	sl, #0
    fec0:	d03d      	beq.n	ff3e <am_util_stdio_vsprintf+0x24a>
    fec2:	b32f      	cbz	r7, ff10 <am_util_stdio_vsprintf+0x21c>
    fec4:	2f01      	cmp	r7, #1
    fec6:	d01c      	beq.n	ff02 <am_util_stdio_vsprintf+0x20e>
    fec8:	2f02      	cmp	r7, #2
    feca:	d017      	beq.n	fefc <am_util_stdio_vsprintf+0x208>
    fecc:	2f03      	cmp	r7, #3
    fece:	d012      	beq.n	fef6 <am_util_stdio_vsprintf+0x202>
    fed0:	2f04      	cmp	r7, #4
    fed2:	d00d      	beq.n	fef0 <am_util_stdio_vsprintf+0x1fc>
    fed4:	2f05      	cmp	r7, #5
    fed6:	d008      	beq.n	feea <am_util_stdio_vsprintf+0x1f6>
    fed8:	2f06      	cmp	r7, #6
            *pcBuf++ = cPadChar;
    feda:	bf1c      	itt	ne
    fedc:	f801 5b01 	strbne.w	r5, [r1], #1
    while ( i32NumChars-- )
    fee0:	f100 30ff 	addne.w	r0, r0, #4294967295
            *pcBuf++ = cPadChar;
    fee4:	f801 5b01 	strb.w	r5, [r1], #1
    while ( i32NumChars-- )
    fee8:	3801      	subs	r0, #1
            *pcBuf++ = cPadChar;
    feea:	f801 5b01 	strb.w	r5, [r1], #1
    while ( i32NumChars-- )
    feee:	3801      	subs	r0, #1
            *pcBuf++ = cPadChar;
    fef0:	f801 5b01 	strb.w	r5, [r1], #1
    while ( i32NumChars-- )
    fef4:	3801      	subs	r0, #1
            *pcBuf++ = cPadChar;
    fef6:	f801 5b01 	strb.w	r5, [r1], #1
    while ( i32NumChars-- )
    fefa:	3801      	subs	r0, #1
            *pcBuf++ = cPadChar;
    fefc:	f801 5b01 	strb.w	r5, [r1], #1
    while ( i32NumChars-- )
    ff00:	3801      	subs	r0, #1
            *pcBuf++ = cPadChar;
    ff02:	f801 5b01 	strb.w	r5, [r1], #1
    while ( i32NumChars-- )
    ff06:	3801      	subs	r0, #1
    ff08:	1c47      	adds	r7, r0, #1
    ff0a:	eba1 0408 	sub.w	r4, r1, r8
    ff0e:	d016      	beq.n	ff3e <am_util_stdio_vsprintf+0x24a>
            *pcBuf++ = cPadChar;
    ff10:	468a      	mov	sl, r1
    while ( i32NumChars-- )
    ff12:	3808      	subs	r0, #8
            *pcBuf++ = cPadChar;
    ff14:	f80a 5b01 	strb.w	r5, [sl], #1
    ff18:	3108      	adds	r1, #8
    ff1a:	f88a 5000 	strb.w	r5, [sl]
    ff1e:	f801 5c06 	strb.w	r5, [r1, #-6]
    ff22:	f801 5c05 	strb.w	r5, [r1, #-5]
    ff26:	f801 5c04 	strb.w	r5, [r1, #-4]
    ff2a:	f801 5c03 	strb.w	r5, [r1, #-3]
    ff2e:	f801 5c02 	strb.w	r5, [r1, #-2]
    while ( i32NumChars-- )
    ff32:	1c47      	adds	r7, r0, #1
    ff34:	eba1 0408 	sub.w	r4, r1, r8
            *pcBuf++ = cPadChar;
    ff38:	f801 5c01 	strb.w	r5, [r1, #-1]
    while ( i32NumChars-- )
    ff3c:	d1e8      	bne.n	ff10 <am_util_stdio_vsprintf+0x21c>
    ff3e:	4627      	mov	r7, r4
                    pcBuf += pcBuf ? iWidth : 0;
    ff40:	44a0      	add	r8, r4
                    ui32CharCnt += iWidth;
    ff42:	44b9      	add	r9, r7
    if ( ui64Val == 0 )
    ff44:	ea52 0103 	orrs.w	r1, r2, r3
    ff48:	f040 821a 	bne.w	10380 <am_util_stdio_vsprintf+0x68c>
        tbuf[ix++] = '0';   // Print a '0'
    ff4c:	f04f 0530 	mov.w	r5, #48	; 0x30
    ff50:	f88d 50ac 	strb.w	r5, [sp, #172]	; 0xac
    if (pcBuf)
    ff54:	2701      	movs	r7, #1
    ff56:	f1b8 0f00 	cmp.w	r8, #0
    ff5a:	f000 8235 	beq.w	103c8 <am_util_stdio_vsprintf+0x6d4>
    ff5e:	4639      	mov	r1, r7
        while (ix--)
    ff60:	2000      	movs	r0, #0
    ff62:	ac2b      	add	r4, sp, #172	; 0xac
    ff64:	1863      	adds	r3, r4, r1
    ff66:	f103 3aff 	add.w	sl, r3, #4294967295
            *pcBuf++ = tbuf[ix];
    ff6a:	f813 cc01 	ldrb.w	ip, [r3, #-1]
    ff6e:	f888 c000 	strb.w	ip, [r8]
    ff72:	1e4d      	subs	r5, r1, #1
        while (ix--)
    ff74:	45a2      	cmp	sl, r4
    ff76:	f005 0107 	and.w	r1, r5, #7
    ff7a:	4643      	mov	r3, r8
    ff7c:	d047      	beq.n	1000e <am_util_stdio_vsprintf+0x31a>
    ff7e:	b359      	cbz	r1, ffd8 <am_util_stdio_vsprintf+0x2e4>
    ff80:	2901      	cmp	r1, #1
    ff82:	d023      	beq.n	ffcc <am_util_stdio_vsprintf+0x2d8>
    ff84:	2902      	cmp	r1, #2
    ff86:	d01d      	beq.n	ffc4 <am_util_stdio_vsprintf+0x2d0>
    ff88:	2903      	cmp	r1, #3
    ff8a:	d017      	beq.n	ffbc <am_util_stdio_vsprintf+0x2c8>
    ff8c:	2904      	cmp	r1, #4
    ff8e:	d011      	beq.n	ffb4 <am_util_stdio_vsprintf+0x2c0>
    ff90:	2905      	cmp	r1, #5
    ff92:	d00b      	beq.n	ffac <am_util_stdio_vsprintf+0x2b8>
    ff94:	2906      	cmp	r1, #6
    ff96:	d005      	beq.n	ffa4 <am_util_stdio_vsprintf+0x2b0>
            *pcBuf++ = tbuf[ix];
    ff98:	f81a 2d01 	ldrb.w	r2, [sl, #-1]!
    ff9c:	f888 2001 	strb.w	r2, [r8, #1]
    ffa0:	f108 0301 	add.w	r3, r8, #1
    ffa4:	f81a 5d01 	ldrb.w	r5, [sl, #-1]!
    ffa8:	f803 5f01 	strb.w	r5, [r3, #1]!
    ffac:	f81a cd01 	ldrb.w	ip, [sl, #-1]!
    ffb0:	f803 cf01 	strb.w	ip, [r3, #1]!
    ffb4:	f81a 1d01 	ldrb.w	r1, [sl, #-1]!
    ffb8:	f803 1f01 	strb.w	r1, [r3, #1]!
    ffbc:	f81a 2d01 	ldrb.w	r2, [sl, #-1]!
    ffc0:	f803 2f01 	strb.w	r2, [r3, #1]!
    ffc4:	f81a 5d01 	ldrb.w	r5, [sl, #-1]!
    ffc8:	f803 5f01 	strb.w	r5, [r3, #1]!
    ffcc:	f81a cd01 	ldrb.w	ip, [sl, #-1]!
    ffd0:	f803 cf01 	strb.w	ip, [r3, #1]!
        while (ix--)
    ffd4:	45a2      	cmp	sl, r4
    ffd6:	d01a      	beq.n	1000e <am_util_stdio_vsprintf+0x31a>
            *pcBuf++ = tbuf[ix];
    ffd8:	f81a 2c01 	ldrb.w	r2, [sl, #-1]
    ffdc:	f81a 5c03 	ldrb.w	r5, [sl, #-3]
    ffe0:	f81a 1c02 	ldrb.w	r1, [sl, #-2]
    ffe4:	705a      	strb	r2, [r3, #1]
    ffe6:	70dd      	strb	r5, [r3, #3]
    ffe8:	f81a 2c04 	ldrb.w	r2, [sl, #-4]
    ffec:	f81a 5c05 	ldrb.w	r5, [sl, #-5]
    fff0:	7099      	strb	r1, [r3, #2]
    fff2:	711a      	strb	r2, [r3, #4]
    fff4:	f81a 1c06 	ldrb.w	r1, [sl, #-6]
    fff8:	715d      	strb	r5, [r3, #5]
    fffa:	f81a 2c07 	ldrb.w	r2, [sl, #-7]
    fffe:	f81a 5d08 	ldrb.w	r5, [sl, #-8]!
   10002:	7199      	strb	r1, [r3, #6]
        while (ix--)
   10004:	45a2      	cmp	sl, r4
            *pcBuf++ = tbuf[ix];
   10006:	71da      	strb	r2, [r3, #7]
   10008:	f803 5f08 	strb.w	r5, [r3, #8]!
        while (ix--)
   1000c:	d1e4      	bne.n	ffd8 <am_util_stdio_vsprintf+0x2e4>
        *pcBuf = 0;
   1000e:	4440      	add	r0, r8
   10010:	2400      	movs	r4, #0
                    pcBuf += iVal;
   10012:	44b8      	add	r8, r7
        *pcBuf = 0;
   10014:	7044      	strb	r4, [r0, #1]
                ui32CharCnt += iVal;
   10016:	44b9      	add	r9, r7
                break;
   10018:	e01e      	b.n	10058 <am_util_stdio_vsprintf+0x364>
                if ( pcBuf )
   1001a:	f1b8 0f00 	cmp.w	r8, #0
   1001e:	d01b      	beq.n	10058 <am_util_stdio_vsprintf+0x364>
                    float fValue = va_arg(pArgs, double);
   10020:	f10b 0307 	add.w	r3, fp, #7
   10024:	f023 0b07 	bic.w	fp, r3, #7
   10028:	e9db 0100 	ldrd	r0, r1, [fp]
   1002c:	f7fc fcda 	bl	c9e4 <__aeabi_d2f>
   10030:	ee07 0a90 	vmov	s15, r0
    if (fValue == 0.0f)
   10034:	eef5 7a40 	vcmp.f32	s15, #0.0
                    *(uint32_t*)pcBuf = 20;
   10038:	2014      	movs	r0, #20
    if (fValue == 0.0f)
   1003a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                    float fValue = va_arg(pArgs, double);
   1003e:	f10b 0b08 	add.w	fp, fp, #8
                    *(uint32_t*)pcBuf = 20;
   10042:	f8c8 0000 	str.w	r0, [r8]
    if (fValue == 0.0f)
   10046:	f040 848d 	bne.w	10964 <am_util_stdio_vsprintf+0xc70>
        *(uint32_t*)pcBuf = 0x00 << 24 | ('0' << 16) | ('.' << 8) | ('0' << 0);
   1004a:	490d      	ldr	r1, [pc, #52]	; (10080 <am_util_stdio_vsprintf+0x38c>)
   1004c:	f8c8 1000 	str.w	r1, [r8]
   10050:	f04f 0a03 	mov.w	sl, #3
                    ui32CharCnt += iVal;
   10054:	44d1      	add	r9, sl
                    pcBuf += iVal;
   10056:	44d0      	add	r8, sl
        ++pcFmt;
   10058:	1c71      	adds	r1, r6, #1
   1005a:	e652      	b.n	fd02 <am_util_stdio_vsprintf+0xe>
                ui8CharSpecifier = va_arg(pArgs, uint32_t);
   1005c:	f10b 0404 	add.w	r4, fp, #4
   10060:	f89b 1000 	ldrb.w	r1, [fp]
                if ( pcBuf )
   10064:	f1b8 0f00 	cmp.w	r8, #0
   10068:	d003      	beq.n	10072 <am_util_stdio_vsprintf+0x37e>
                    *pcBuf++ = ui8CharSpecifier;
   1006a:	f888 1000 	strb.w	r1, [r8]
   1006e:	f108 0801 	add.w	r8, r8, #1
                ++ui32CharCnt;
   10072:	f109 0901 	add.w	r9, r9, #1
                ui8CharSpecifier = va_arg(pArgs, uint32_t);
   10076:	46a3      	mov	fp, r4
                break;
   10078:	e7ee      	b.n	10058 <am_util_stdio_vsprintf+0x364>
   1007a:	bf00      	nop
   1007c:	10001068 	.word	0x10001068
   10080:	00302e30 	.word	0x00302e30
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
   10084:	f8db 0000 	ldr.w	r0, [fp]
                                     va_arg(pArgs, int32_t);
   10088:	f10b 0b04 	add.w	fp, fp, #4
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
   1008c:	17c1      	asrs	r1, r0, #31
                if ( i64Val < 0 )
   1008e:	2800      	cmp	r0, #0
   10090:	f171 0300 	sbcs.w	r3, r1, #0
   10094:	f2c0 83ac 	blt.w	107f0 <am_util_stdio_vsprintf+0xafc>
                    ui64Val = i64Val;
   10098:	e9cd 0118 	strd	r0, r1, [sp, #96]	; 0x60
                if ( iWidth )
   1009c:	2c00      	cmp	r4, #0
   1009e:	f000 83ba 	beq.w	10816 <am_util_stdio_vsprintf+0xb22>
    int iNDigits = ui64Val ? 0 : 1;
   100a2:	ea50 0301 	orrs.w	r3, r0, r1
    return ndigits_in_u64((uint64_t) i64Val);
   100a6:	4602      	mov	r2, r0
    int iNDigits = ui64Val ? 0 : 1;
   100a8:	bf0c      	ite	eq
   100aa:	2401      	moveq	r4, #1
   100ac:	2400      	movne	r4, #0
    while ( ui64Val )
   100ae:	4308      	orrs	r0, r1
    return ndigits_in_u64((uint64_t) i64Val);
   100b0:	460b      	mov	r3, r1
                    bNeg = false;
   100b2:	bf18      	it	ne
   100b4:	2000      	movne	r0, #0
    while ( ui64Val )
   100b6:	f000 86ba 	beq.w	10e2e <am_util_stdio_vsprintf+0x113a>
                    bNeg = false;
   100ba:	901b      	str	r0, [sp, #108]	; 0x6c
   100bc:	9620      	str	r6, [sp, #128]	; 0x80
   100be:	9521      	str	r5, [sp, #132]	; 0x84
   100c0:	9722      	str	r7, [sp, #136]	; 0x88
   100c2:	941a      	str	r4, [sp, #104]	; 0x68
   100c4:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
   100c8:	f8cd 9090 	str.w	r9, [sp, #144]	; 0x90
   100cc:	f8cd 8094 	str.w	r8, [sp, #148]	; 0x94
   100d0:	e009      	b.n	100e6 <am_util_stdio_vsprintf+0x3f2>
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
   100d2:	464a      	mov	r2, r9
   100d4:	2300      	movs	r3, #0
        ++iNDigits;
   100d6:	9d1a      	ldr	r5, [sp, #104]	; 0x68
    while ( ui64Val )
   100d8:	ea52 0103 	orrs.w	r1, r2, r3
        ++iNDigits;
   100dc:	f105 0501 	add.w	r5, r5, #1
   100e0:	951a      	str	r5, [sp, #104]	; 0x68
    while ( ui64Val )
   100e2:	f000 83a5 	beq.w	10830 <am_util_stdio_vsprintf+0xb3c>
        q64 = (ui64Val>>1) + (ui64Val>>2);
   100e6:	0896      	lsrs	r6, r2, #2
   100e8:	ea46 7583 	orr.w	r5, r6, r3, lsl #30
   100ec:	089f      	lsrs	r7, r3, #2
   100ee:	970b      	str	r7, [sp, #44]	; 0x2c
   100f0:	950a      	str	r5, [sp, #40]	; 0x28
   100f2:	e9dd 450a 	ldrd	r4, r5, [sp, #40]	; 0x28
   100f6:	0859      	lsrs	r1, r3, #1
   100f8:	ea4f 0032 	mov.w	r0, r2, rrx
   100fc:	1820      	adds	r0, r4, r0
   100fe:	eb45 0101 	adc.w	r1, r5, r1
        q64 += (q64 >> 4);
   10102:	0904      	lsrs	r4, r0, #4
        q64 = (ui64Val>>1) + (ui64Val>>2);
   10104:	4606      	mov	r6, r0
        q64 += (q64 >> 4);
   10106:	ea44 7501 	orr.w	r5, r4, r1, lsl #28
   1010a:	0908      	lsrs	r0, r1, #4
   1010c:	9005      	str	r0, [sp, #20]
   1010e:	9504      	str	r5, [sp, #16]
   10110:	e9dd 4504 	ldrd	r4, r5, [sp, #16]
   10114:	19a0      	adds	r0, r4, r6
   10116:	eb45 0101 	adc.w	r1, r5, r1
        q64 += (q64 >> 8);
   1011a:	0a04      	lsrs	r4, r0, #8
        q64 += (q64 >> 4);
   1011c:	4606      	mov	r6, r0
        q64 += (q64 >> 8);
   1011e:	ea44 6501 	orr.w	r5, r4, r1, lsl #24
   10122:	0a08      	lsrs	r0, r1, #8
   10124:	9007      	str	r0, [sp, #28]
   10126:	9506      	str	r5, [sp, #24]
   10128:	e9dd 4506 	ldrd	r4, r5, [sp, #24]
   1012c:	19a0      	adds	r0, r4, r6
   1012e:	eb45 0101 	adc.w	r1, r5, r1
        q64 += (q64 >> 16);
   10132:	0c06      	lsrs	r6, r0, #16
   10134:	ea46 4a01 	orr.w	sl, r6, r1, lsl #16
   10138:	eb10 070a 	adds.w	r7, r0, sl
   1013c:	ea4f 4b11 	mov.w	fp, r1, lsr #16
   10140:	eb41 000b 	adc.w	r0, r1, fp
        q64 += (q64 >> 32);
   10144:	2400      	movs	r4, #0
   10146:	900e      	str	r0, [sp, #56]	; 0x38
   10148:	940f      	str	r4, [sp, #60]	; 0x3c
   1014a:	e9dd 890e 	ldrd	r8, r9, [sp, #56]	; 0x38
        q32 = (ui32Val>>1) + (ui32Val>>2);
   1014e:	0895      	lsrs	r5, r2, #2
        q64 += (q64 >> 32);
   10150:	eb18 0807 	adds.w	r8, r8, r7
   10154:	eb49 0100 	adc.w	r1, r9, r0
        q32 = (ui32Val>>1) + (ui32Val>>2);
   10158:	eb05 0c52 	add.w	ip, r5, r2, lsr #1
        q64 += (q64 >> 32);
   1015c:	4646      	mov	r6, r8
        q32 += (q32 >> 4);
   1015e:	eb0c 101c 	add.w	r0, ip, ip, lsr #4
        q64 += (q64 >> 32);
   10162:	460f      	mov	r7, r1
        q32 += (q32 >> 8);
   10164:	eb00 2510 	add.w	r5, r0, r0, lsr #8
        q64 >>= 3;
   10168:	08f4      	lsrs	r4, r6, #3
    if ( ui64Val >> 32 )
   1016a:	9312      	str	r3, [sp, #72]	; 0x48
   1016c:	f8cd 904c 	str.w	r9, [sp, #76]	; 0x4c
        q64 >>= 3;
   10170:	08ff      	lsrs	r7, r7, #3
   10172:	ea44 7641 	orr.w	r6, r4, r1, lsl #29
   10176:	e9dd 8912 	ldrd	r8, r9, [sp, #72]	; 0x48
        q32 += (q32 >> 16);
   1017a:	eb05 4415 	add.w	r4, r5, r5, lsr #16
        r64 = ui64Val - q64*10;
   1017e:	00bd      	lsls	r5, r7, #2
   10180:	ea45 7196 	orr.w	r1, r5, r6, lsr #30
        q32 >>= 3;
   10184:	08e5      	lsrs	r5, r4, #3
        r32 = ui32Val - q32*10;
   10186:	eb05 0485 	add.w	r4, r5, r5, lsl #2
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
   1018a:	f102 0e06 	add.w	lr, r2, #6
   1018e:	ebae 0c44 	sub.w	ip, lr, r4, lsl #1
   10192:	ea58 0409 	orrs.w	r4, r8, r9
        r64 = ui64Val - q64*10;
   10196:	ea4f 0086 	mov.w	r0, r6, lsl #2
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
   1019a:	eb05 191c 	add.w	r9, r5, ip, lsr #4
   1019e:	d098      	beq.n	100d2 <am_util_stdio_vsprintf+0x3de>
        r64 = ui64Val - q64*10;
   101a0:	eb10 0e06 	adds.w	lr, r0, r6
   101a4:	4179      	adcs	r1, r7
   101a6:	eb1e 000e 	adds.w	r0, lr, lr
   101aa:	4149      	adcs	r1, r1
        return q64 + ((r64 + 6) >> 4);
   101ac:	3206      	adds	r2, #6
   101ae:	f143 0300 	adc.w	r3, r3, #0
   101b2:	1a15      	subs	r5, r2, r0
   101b4:	eb63 0401 	sbc.w	r4, r3, r1
   101b8:	0929      	lsrs	r1, r5, #4
   101ba:	0922      	lsrs	r2, r4, #4
   101bc:	ea41 7004 	orr.w	r0, r1, r4, lsl #28
   101c0:	9016      	str	r0, [sp, #88]	; 0x58
   101c2:	9217      	str	r2, [sp, #92]	; 0x5c
   101c4:	e9dd 2316 	ldrd	r2, r3, [sp, #88]	; 0x58
   101c8:	1992      	adds	r2, r2, r6
   101ca:	417b      	adcs	r3, r7
   101cc:	e783      	b.n	100d6 <am_util_stdio_vsprintf+0x3e2>
        switch ( *pcFmt )
   101ce:	f04f 0c01 	mov.w	ip, #1
   101d2:	e642      	b.n	fe5a <am_util_stdio_vsprintf+0x166>
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
   101d4:	f8db 1000 	ldr.w	r1, [fp]
   101d8:	2200      	movs	r2, #0
   101da:	e9cd 1218 	strd	r1, r2, [sp, #96]	; 0x60
                                      va_arg(pArgs, uint32_t);
   101de:	f10b 0b04 	add.w	fp, fp, #4
                if ( iWidth )
   101e2:	2c00      	cmp	r4, #0
   101e4:	f000 8269 	beq.w	106ba <am_util_stdio_vsprintf+0x9c6>
    int iNDigits = ui64Val ? 0 : 1;
   101e8:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
   101ec:	ea50 0301 	orrs.w	r3, r0, r1
    while ( ui64Val )
   101f0:	4602      	mov	r2, r0
   101f2:	460b      	mov	r3, r1
    int iNDigits = ui64Val ? 0 : 1;
   101f4:	bf0c      	ite	eq
   101f6:	2401      	moveq	r4, #1
   101f8:	2400      	movne	r4, #0
    while ( ui64Val )
   101fa:	ea52 0103 	orrs.w	r1, r2, r3
   101fe:	f000 81fe 	beq.w	105fe <am_util_stdio_vsprintf+0x90a>
   10202:	961b      	str	r6, [sp, #108]	; 0x6c
   10204:	9520      	str	r5, [sp, #128]	; 0x80
   10206:	9721      	str	r7, [sp, #132]	; 0x84
   10208:	941a      	str	r4, [sp, #104]	; 0x68
   1020a:	f8cd b088 	str.w	fp, [sp, #136]	; 0x88
   1020e:	f8cd 908c 	str.w	r9, [sp, #140]	; 0x8c
   10212:	f8cd 8090 	str.w	r8, [sp, #144]	; 0x90
   10216:	e009      	b.n	1022c <am_util_stdio_vsprintf+0x538>
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
   10218:	464a      	mov	r2, r9
   1021a:	2300      	movs	r3, #0
        ++iNDigits;
   1021c:	9d1a      	ldr	r5, [sp, #104]	; 0x68
    while ( ui64Val )
   1021e:	ea52 0103 	orrs.w	r1, r2, r3
        ++iNDigits;
   10222:	f105 0501 	add.w	r5, r5, #1
   10226:	951a      	str	r5, [sp, #104]	; 0x68
    while ( ui64Val )
   10228:	f000 81db 	beq.w	105e2 <am_util_stdio_vsprintf+0x8ee>
        q64 = (ui64Val>>1) + (ui64Val>>2);
   1022c:	0895      	lsrs	r5, r2, #2
   1022e:	ea45 7783 	orr.w	r7, r5, r3, lsl #30
   10232:	089c      	lsrs	r4, r3, #2
   10234:	9708      	str	r7, [sp, #32]
   10236:	9409      	str	r4, [sp, #36]	; 0x24
   10238:	e9dd 4508 	ldrd	r4, r5, [sp, #32]
   1023c:	0859      	lsrs	r1, r3, #1
   1023e:	ea4f 0032 	mov.w	r0, r2, rrx
   10242:	1820      	adds	r0, r4, r0
   10244:	eb45 0101 	adc.w	r1, r5, r1
        q64 += (q64 >> 4);
   10248:	0905      	lsrs	r5, r0, #4
        q64 = (ui64Val>>1) + (ui64Val>>2);
   1024a:	4606      	mov	r6, r0
        q64 += (q64 >> 4);
   1024c:	ea45 7401 	orr.w	r4, r5, r1, lsl #28
   10250:	0908      	lsrs	r0, r1, #4
   10252:	9001      	str	r0, [sp, #4]
   10254:	9400      	str	r4, [sp, #0]
   10256:	e9dd 4500 	ldrd	r4, r5, [sp]
   1025a:	19a0      	adds	r0, r4, r6
   1025c:	eb45 0101 	adc.w	r1, r5, r1
        q64 += (q64 >> 8);
   10260:	0a05      	lsrs	r5, r0, #8
        q64 += (q64 >> 4);
   10262:	4606      	mov	r6, r0
        q64 += (q64 >> 8);
   10264:	ea45 6401 	orr.w	r4, r5, r1, lsl #24
   10268:	0a08      	lsrs	r0, r1, #8
   1026a:	9003      	str	r0, [sp, #12]
   1026c:	9402      	str	r4, [sp, #8]
   1026e:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
   10272:	19a0      	adds	r0, r4, r6
   10274:	eb45 0101 	adc.w	r1, r5, r1
        q64 += (q64 >> 16);
   10278:	0c06      	lsrs	r6, r0, #16
   1027a:	ea46 4a01 	orr.w	sl, r6, r1, lsl #16
   1027e:	eb10 070a 	adds.w	r7, r0, sl
   10282:	ea4f 4b11 	mov.w	fp, r1, lsr #16
   10286:	eb41 000b 	adc.w	r0, r1, fp
        q64 += (q64 >> 32);
   1028a:	2400      	movs	r4, #0
   1028c:	900c      	str	r0, [sp, #48]	; 0x30
   1028e:	940d      	str	r4, [sp, #52]	; 0x34
   10290:	e9dd 890c 	ldrd	r8, r9, [sp, #48]	; 0x30
        q32 = (ui32Val>>1) + (ui32Val>>2);
   10294:	0895      	lsrs	r5, r2, #2
        q64 += (q64 >> 32);
   10296:	eb18 0807 	adds.w	r8, r8, r7
   1029a:	eb49 0100 	adc.w	r1, r9, r0
        q32 = (ui32Val>>1) + (ui32Val>>2);
   1029e:	eb05 0c52 	add.w	ip, r5, r2, lsr #1
        q64 += (q64 >> 32);
   102a2:	4646      	mov	r6, r8
        q32 += (q32 >> 4);
   102a4:	eb0c 101c 	add.w	r0, ip, ip, lsr #4
        q64 += (q64 >> 32);
   102a8:	460f      	mov	r7, r1
        q32 += (q32 >> 8);
   102aa:	eb00 2510 	add.w	r5, r0, r0, lsr #8
        q64 >>= 3;
   102ae:	08f4      	lsrs	r4, r6, #3
    if ( ui64Val >> 32 )
   102b0:	9310      	str	r3, [sp, #64]	; 0x40
   102b2:	f8cd 9044 	str.w	r9, [sp, #68]	; 0x44
        q64 >>= 3;
   102b6:	08ff      	lsrs	r7, r7, #3
   102b8:	ea44 7641 	orr.w	r6, r4, r1, lsl #29
   102bc:	e9dd 8910 	ldrd	r8, r9, [sp, #64]	; 0x40
        q32 += (q32 >> 16);
   102c0:	eb05 4415 	add.w	r4, r5, r5, lsr #16
        r64 = ui64Val - q64*10;
   102c4:	00bd      	lsls	r5, r7, #2
   102c6:	ea45 7196 	orr.w	r1, r5, r6, lsr #30
        q32 >>= 3;
   102ca:	08e5      	lsrs	r5, r4, #3
        r32 = ui32Val - q32*10;
   102cc:	eb05 0485 	add.w	r4, r5, r5, lsl #2
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
   102d0:	f102 0e06 	add.w	lr, r2, #6
   102d4:	ebae 0c44 	sub.w	ip, lr, r4, lsl #1
   102d8:	ea58 0409 	orrs.w	r4, r8, r9
        r64 = ui64Val - q64*10;
   102dc:	ea4f 0086 	mov.w	r0, r6, lsl #2
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
   102e0:	eb05 191c 	add.w	r9, r5, ip, lsr #4
   102e4:	d098      	beq.n	10218 <am_util_stdio_vsprintf+0x524>
        r64 = ui64Val - q64*10;
   102e6:	eb10 0e06 	adds.w	lr, r0, r6
   102ea:	4179      	adcs	r1, r7
   102ec:	eb1e 000e 	adds.w	r0, lr, lr
   102f0:	4149      	adcs	r1, r1
        return q64 + ((r64 + 6) >> 4);
   102f2:	3206      	adds	r2, #6
   102f4:	f143 0300 	adc.w	r3, r3, #0
   102f8:	1a15      	subs	r5, r2, r0
   102fa:	eb63 0401 	sbc.w	r4, r3, r1
   102fe:	0929      	lsrs	r1, r5, #4
   10300:	0922      	lsrs	r2, r4, #4
   10302:	ea41 7004 	orr.w	r0, r1, r4, lsl #28
   10306:	9014      	str	r0, [sp, #80]	; 0x50
   10308:	9215      	str	r2, [sp, #84]	; 0x54
   1030a:	e9dd 2314 	ldrd	r2, r3, [sp, #80]	; 0x50
   1030e:	1992      	adds	r2, r2, r6
   10310:	417b      	adcs	r3, r7
   10312:	e783      	b.n	1021c <am_util_stdio_vsprintf+0x528>
                if ( pcBuf )
   10314:	f1b8 0f00 	cmp.w	r8, #0
   10318:	d003      	beq.n	10322 <am_util_stdio_vsprintf+0x62e>
                    *pcBuf++ = *pcFmt;
   1031a:	f888 2000 	strb.w	r2, [r8]
   1031e:	f108 0801 	add.w	r8, r8, #1
                ++ui32CharCnt;
   10322:	f109 0901 	add.w	r9, r9, #1
                break;
   10326:	e697      	b.n	10058 <am_util_stdio_vsprintf+0x364>
            if ( *pcFmt == 'l' )    // "ll" (long long)
   10328:	7872      	ldrb	r2, [r6, #1]
   1032a:	2a6c      	cmp	r2, #108	; 0x6c
   1032c:	f000 81db 	beq.w	106e6 <am_util_stdio_vsprintf+0x9f2>
            pcFmt++;
   10330:	3601      	adds	r6, #1
   10332:	e556      	b.n	fde2 <am_util_stdio_vsprintf+0xee>
    if ( *pcStr == '-')
   10334:	7873      	ldrb	r3, [r6, #1]
   10336:	2b2d      	cmp	r3, #45	; 0x2d
            ++pcFmt;
   10338:	f106 0001 	add.w	r0, r6, #1
    if ( *pcStr == '-')
   1033c:	f000 81c8 	beq.w	106d0 <am_util_stdio_vsprintf+0x9dc>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
   10340:	f1a3 0630 	sub.w	r6, r3, #48	; 0x30
   10344:	2e09      	cmp	r6, #9
   10346:	f200 8349 	bhi.w	109dc <am_util_stdio_vsprintf+0xce8>
    uint32_t ui32Val = 0, uCnt = 0;
   1034a:	2200      	movs	r2, #0
    bool bNeg = false;
   1034c:	4694      	mov	ip, r2
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
   1034e:	4606      	mov	r6, r0
    bool bNeg = false;
   10350:	f04f 0a00 	mov.w	sl, #0
        ui32Val *= 10;
   10354:	eb0a 018a 	add.w	r1, sl, sl, lsl #2
        ui32Val += (*pcStr - '0');
   10358:	eb03 0141 	add.w	r1, r3, r1, lsl #1
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
   1035c:	f816 3f01 	ldrb.w	r3, [r6, #1]!
   10360:	f1a3 0e30 	sub.w	lr, r3, #48	; 0x30
   10364:	f1be 0f09 	cmp.w	lr, #9
        ++uCnt;
   10368:	f102 0201 	add.w	r2, r2, #1
        ui32Val += (*pcStr - '0');
   1036c:	f1a1 0a30 	sub.w	sl, r1, #48	; 0x30
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
   10370:	d9f0      	bls.n	10354 <am_util_stdio_vsprintf+0x660>
    return bNeg ? -ui32Val : ui32Val;
   10372:	f1bc 0f00 	cmp.w	ip, #0
   10376:	f000 8334 	beq.w	109e2 <am_util_stdio_vsprintf+0xcee>
   1037a:	f1c1 0a30 	rsb	sl, r1, #48	; 0x30
   1037e:	e330      	b.n	109e2 <am_util_stdio_vsprintf+0xcee>
   10380:	f1bc 0f00 	cmp.w	ip, #0
   10384:	bf14      	ite	ne
   10386:	2727      	movne	r7, #39	; 0x27
   10388:	2707      	moveq	r7, #7
   1038a:	f10d 04ab 	add.w	r4, sp, #171	; 0xab
    if ( ui64Val == 0 )
   1038e:	2000      	movs	r0, #0
   10390:	e000      	b.n	10394 <am_util_stdio_vsprintf+0x6a0>
        tbuf[ix++] = cCh + '0';
   10392:	4608      	mov	r0, r1
        cCh = ui64Val & 0xf;
   10394:	f002 010f 	and.w	r1, r2, #15
            cCh += bLower ? 0x27 : 0x7;
   10398:	eb01 0e07 	add.w	lr, r1, r7
        tbuf[ix++] = cCh + '0';
   1039c:	2909      	cmp	r1, #9
   1039e:	bf88      	it	hi
   103a0:	4671      	movhi	r1, lr
        ui64Val >>= 4;
   103a2:	0912      	lsrs	r2, r2, #4
   103a4:	ea4f 1e13 	mov.w	lr, r3, lsr #4
   103a8:	ea42 7203 	orr.w	r2, r2, r3, lsl #28
   103ac:	4673      	mov	r3, lr
        tbuf[ix++] = cCh + '0';
   103ae:	3130      	adds	r1, #48	; 0x30
    while ( ui64Val )
   103b0:	ea52 0503 	orrs.w	r5, r2, r3
        tbuf[ix++] = cCh + '0';
   103b4:	f804 1f01 	strb.w	r1, [r4, #1]!
   103b8:	f100 0101 	add.w	r1, r0, #1
    while ( ui64Val )
   103bc:	d1e9      	bne.n	10392 <am_util_stdio_vsprintf+0x69e>
   103be:	460f      	mov	r7, r1
    if (pcBuf)
   103c0:	f1b8 0f00 	cmp.w	r8, #0
   103c4:	f47f adcd 	bne.w	ff62 <am_util_stdio_vsprintf+0x26e>
   103c8:	f04f 0800 	mov.w	r8, #0
                ui32CharCnt += iVal;
   103cc:	44b9      	add	r9, r7
   103ce:	e643      	b.n	10058 <am_util_stdio_vsprintf+0x364>
        switch ( *pcFmt )
   103d0:	463c      	mov	r4, r7
                pcStr = va_arg(pArgs, char *);
   103d2:	f8db 0000 	ldr.w	r0, [fp]
   103d6:	f10b 0b04 	add.w	fp, fp, #4
    if ( !pcBuf )
   103da:	2800      	cmp	r0, #0
   103dc:	f000 8085 	beq.w	104ea <am_util_stdio_vsprintf+0x7f6>
    while ( *pcBuf++ )
   103e0:	7801      	ldrb	r1, [r0, #0]
   103e2:	1c42      	adds	r2, r0, #1
   103e4:	4613      	mov	r3, r2
   103e6:	2900      	cmp	r1, #0
   103e8:	f000 84f3 	beq.w	10dd2 <am_util_stdio_vsprintf+0x10de>
   103ec:	eba3 0e00 	sub.w	lr, r3, r0
   103f0:	f813 7b01 	ldrb.w	r7, [r3], #1
   103f4:	2f00      	cmp	r7, #0
   103f6:	d1f9      	bne.n	103ec <am_util_stdio_vsprintf+0x6f8>
                if ( iWidth > 0 )
   103f8:	2c00      	cmp	r4, #0
   103fa:	4677      	mov	r7, lr
   103fc:	dd01      	ble.n	10402 <am_util_stdio_vsprintf+0x70e>
                    if ( ui32strlen < iWidth )
   103fe:	4574      	cmp	r4, lr
   10400:	d877      	bhi.n	104f2 <am_util_stdio_vsprintf+0x7fe>
                    if ( pcBuf )
   10402:	f1b8 0f00 	cmp.w	r8, #0
   10406:	f000 80e1 	beq.w	105cc <am_util_stdio_vsprintf+0x8d8>
   1040a:	eba9 0a00 	sub.w	sl, r9, r0
                        *pcBuf++ = *pcStr;
   1040e:	f808 1b01 	strb.w	r1, [r8], #1
   10412:	eb0a 0902 	add.w	r9, sl, r2
                while (*pcStr != 0x0)
   10416:	f812 1b01 	ldrb.w	r1, [r2], #1
   1041a:	2900      	cmp	r1, #0
   1041c:	d1f7      	bne.n	1040e <am_util_stdio_vsprintf+0x71a>
                if ( iWidth )
   1041e:	2c00      	cmp	r4, #0
   10420:	f43f ae1a 	beq.w	10058 <am_util_stdio_vsprintf+0x364>
                    iWidth = -iWidth;
   10424:	4263      	negs	r3, r4
                    if ( ui32strlen < iWidth )
   10426:	42bb      	cmp	r3, r7
   10428:	f67f ae16 	bls.w	10058 <am_util_stdio_vsprintf+0x364>
                        iWidth -= ui32strlen;
   1042c:	1bda      	subs	r2, r3, r7
    if ( i32NumChars <= 0 )
   1042e:	2a00      	cmp	r2, #0
   10430:	f340 84c3 	ble.w	10dba <am_util_stdio_vsprintf+0x10c6>
    while ( i32NumChars-- )
   10434:	1e57      	subs	r7, r2, #1
        if ( pcBuf )
   10436:	f1b8 0f00 	cmp.w	r8, #0
   1043a:	f000 84bf 	beq.w	10dbc <am_util_stdio_vsprintf+0x10c8>
            *pcBuf++ = cPadChar;
   1043e:	4643      	mov	r3, r8
   10440:	f007 0407 	and.w	r4, r7, #7
   10444:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   10448:	f107 3cff 	add.w	ip, r7, #4294967295
   1044c:	eba3 0108 	sub.w	r1, r3, r8
   10450:	2f00      	cmp	r7, #0
   10452:	d045      	beq.n	104e0 <am_util_stdio_vsprintf+0x7ec>
   10454:	b364      	cbz	r4, 104b0 <am_util_stdio_vsprintf+0x7bc>
   10456:	2c01      	cmp	r4, #1
   10458:	d021      	beq.n	1049e <am_util_stdio_vsprintf+0x7aa>
   1045a:	2c02      	cmp	r4, #2
   1045c:	d01b      	beq.n	10496 <am_util_stdio_vsprintf+0x7a2>
   1045e:	2c03      	cmp	r4, #3
   10460:	d015      	beq.n	1048e <am_util_stdio_vsprintf+0x79a>
   10462:	2c04      	cmp	r4, #4
   10464:	d00f      	beq.n	10486 <am_util_stdio_vsprintf+0x792>
   10466:	2c05      	cmp	r4, #5
   10468:	d009      	beq.n	1047e <am_util_stdio_vsprintf+0x78a>
   1046a:	2c06      	cmp	r4, #6
            *pcBuf++ = cPadChar;
   1046c:	bf1c      	itt	ne
   1046e:	f803 5b01 	strbne.w	r5, [r3], #1
    while ( i32NumChars-- )
   10472:	f10c 3cff 	addne.w	ip, ip, #4294967295
            *pcBuf++ = cPadChar;
   10476:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   1047a:	f10c 3cff 	add.w	ip, ip, #4294967295
            *pcBuf++ = cPadChar;
   1047e:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   10482:	f10c 3cff 	add.w	ip, ip, #4294967295
            *pcBuf++ = cPadChar;
   10486:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   1048a:	f10c 3cff 	add.w	ip, ip, #4294967295
            *pcBuf++ = cPadChar;
   1048e:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   10492:	f10c 3cff 	add.w	ip, ip, #4294967295
            *pcBuf++ = cPadChar;
   10496:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   1049a:	f10c 3cff 	add.w	ip, ip, #4294967295
            *pcBuf++ = cPadChar;
   1049e:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   104a2:	f10c 3cff 	add.w	ip, ip, #4294967295
   104a6:	f11c 0701 	adds.w	r7, ip, #1
   104aa:	eba3 0108 	sub.w	r1, r3, r8
   104ae:	d017      	beq.n	104e0 <am_util_stdio_vsprintf+0x7ec>
            *pcBuf++ = cPadChar;
   104b0:	4618      	mov	r0, r3
    while ( i32NumChars-- )
   104b2:	f1ac 0c08 	sub.w	ip, ip, #8
            *pcBuf++ = cPadChar;
   104b6:	f800 5b01 	strb.w	r5, [r0], #1
   104ba:	3308      	adds	r3, #8
   104bc:	7005      	strb	r5, [r0, #0]
   104be:	f803 5c06 	strb.w	r5, [r3, #-6]
   104c2:	f803 5c05 	strb.w	r5, [r3, #-5]
   104c6:	f803 5c04 	strb.w	r5, [r3, #-4]
   104ca:	f803 5c03 	strb.w	r5, [r3, #-3]
   104ce:	f803 5c02 	strb.w	r5, [r3, #-2]
    while ( i32NumChars-- )
   104d2:	f11c 0001 	adds.w	r0, ip, #1
   104d6:	eba3 0108 	sub.w	r1, r3, r8
            *pcBuf++ = cPadChar;
   104da:	f803 5c01 	strb.w	r5, [r3, #-1]
    while ( i32NumChars-- )
   104de:	d1e7      	bne.n	104b0 <am_util_stdio_vsprintf+0x7bc>
   104e0:	460d      	mov	r5, r1
   104e2:	460a      	mov	r2, r1
                        pcBuf += pcBuf ? iWidth : 0;
   104e4:	44a8      	add	r8, r5
                        ui32CharCnt += iWidth;
   104e6:	4491      	add	r9, r2
   104e8:	e5b6      	b.n	10058 <am_util_stdio_vsprintf+0x364>
                if ( iWidth > 0 )
   104ea:	2c00      	cmp	r4, #0
   104ec:	f340 8443 	ble.w	10d76 <am_util_stdio_vsprintf+0x1082>
        return ui32RetVal;
   104f0:	4607      	mov	r7, r0
                        iWidth -= ui32strlen;
   104f2:	1be2      	subs	r2, r4, r7
    if ( i32NumChars <= 0 )
   104f4:	2a00      	cmp	r2, #0
   104f6:	f340 8464 	ble.w	10dc2 <am_util_stdio_vsprintf+0x10ce>
    while ( i32NumChars-- )
   104fa:	f102 3eff 	add.w	lr, r2, #4294967295
        if ( pcBuf )
   104fe:	f1b8 0f00 	cmp.w	r8, #0
   10502:	d05c      	beq.n	105be <am_util_stdio_vsprintf+0x8ca>
            *pcBuf++ = cPadChar;
   10504:	4643      	mov	r3, r8
   10506:	f00e 0407 	and.w	r4, lr, #7
   1050a:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   1050e:	f10e 3aff 	add.w	sl, lr, #4294967295
   10512:	eba3 0c08 	sub.w	ip, r3, r8
   10516:	f1be 0f00 	cmp.w	lr, #0
   1051a:	d045      	beq.n	105a8 <am_util_stdio_vsprintf+0x8b4>
   1051c:	b364      	cbz	r4, 10578 <am_util_stdio_vsprintf+0x884>
   1051e:	2c01      	cmp	r4, #1
   10520:	d021      	beq.n	10566 <am_util_stdio_vsprintf+0x872>
   10522:	2c02      	cmp	r4, #2
   10524:	d01b      	beq.n	1055e <am_util_stdio_vsprintf+0x86a>
   10526:	2c03      	cmp	r4, #3
   10528:	d015      	beq.n	10556 <am_util_stdio_vsprintf+0x862>
   1052a:	2c04      	cmp	r4, #4
   1052c:	d00f      	beq.n	1054e <am_util_stdio_vsprintf+0x85a>
   1052e:	2c05      	cmp	r4, #5
   10530:	d009      	beq.n	10546 <am_util_stdio_vsprintf+0x852>
   10532:	2c06      	cmp	r4, #6
            *pcBuf++ = cPadChar;
   10534:	bf1c      	itt	ne
   10536:	f803 5b01 	strbne.w	r5, [r3], #1
    while ( i32NumChars-- )
   1053a:	f10a 3aff 	addne.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
   1053e:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   10542:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
   10546:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   1054a:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
   1054e:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   10552:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
   10556:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   1055a:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
   1055e:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   10562:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
   10566:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   1056a:	f10a 3aff 	add.w	sl, sl, #4294967295
   1056e:	f11a 0401 	adds.w	r4, sl, #1
   10572:	eba3 0c08 	sub.w	ip, r3, r8
   10576:	d017      	beq.n	105a8 <am_util_stdio_vsprintf+0x8b4>
            *pcBuf++ = cPadChar;
   10578:	4619      	mov	r1, r3
    while ( i32NumChars-- )
   1057a:	f1aa 0a08 	sub.w	sl, sl, #8
            *pcBuf++ = cPadChar;
   1057e:	f801 5b01 	strb.w	r5, [r1], #1
   10582:	3308      	adds	r3, #8
   10584:	700d      	strb	r5, [r1, #0]
   10586:	f803 5c06 	strb.w	r5, [r3, #-6]
   1058a:	f803 5c05 	strb.w	r5, [r3, #-5]
   1058e:	f803 5c04 	strb.w	r5, [r3, #-4]
   10592:	f803 5c03 	strb.w	r5, [r3, #-3]
   10596:	f803 5c02 	strb.w	r5, [r3, #-2]
    while ( i32NumChars-- )
   1059a:	f11a 0401 	adds.w	r4, sl, #1
   1059e:	eba3 0c08 	sub.w	ip, r3, r8
            *pcBuf++ = cPadChar;
   105a2:	f803 5c01 	strb.w	r5, [r3, #-1]
    while ( i32NumChars-- )
   105a6:	d1e7      	bne.n	10578 <am_util_stdio_vsprintf+0x884>
   105a8:	4664      	mov	r4, ip
   105aa:	4662      	mov	r2, ip
                while (*pcStr != 0x0)
   105ac:	7801      	ldrb	r1, [r0, #0]
                        pcBuf += pcBuf ? iWidth : 0;
   105ae:	44a0      	add	r8, r4
                        ui32CharCnt += iWidth;
   105b0:	4491      	add	r9, r2
                while (*pcStr != 0x0)
   105b2:	2900      	cmp	r1, #0
   105b4:	f43f ad50 	beq.w	10058 <am_util_stdio_vsprintf+0x364>
                        iWidth = 0;
   105b8:	2400      	movs	r4, #0
   105ba:	1c42      	adds	r2, r0, #1
   105bc:	e721      	b.n	10402 <am_util_stdio_vsprintf+0x70e>
                while (*pcStr != 0x0)
   105be:	7803      	ldrb	r3, [r0, #0]
                        ui32CharCnt += iWidth;
   105c0:	4491      	add	r9, r2
                while (*pcStr != 0x0)
   105c2:	2b00      	cmp	r3, #0
   105c4:	f43f ad48 	beq.w	10058 <am_util_stdio_vsprintf+0x364>
                        iWidth = 0;
   105c8:	2400      	movs	r4, #0
   105ca:	1c42      	adds	r2, r0, #1
   105cc:	4690      	mov	r8, r2
   105ce:	eba9 0000 	sub.w	r0, r9, r0
   105d2:	eb00 0908 	add.w	r9, r0, r8
                while (*pcStr != 0x0)
   105d6:	f818 1b01 	ldrb.w	r1, [r8], #1
   105da:	2900      	cmp	r1, #0
   105dc:	d1f9      	bne.n	105d2 <am_util_stdio_vsprintf+0x8de>
   105de:	4688      	mov	r8, r1
   105e0:	e71d      	b.n	1041e <am_util_stdio_vsprintf+0x72a>
   105e2:	e9cd 6728 	strd	r6, r7, [sp, #160]	; 0xa0
   105e6:	e9cd ab26 	strd	sl, fp, [sp, #152]	; 0x98
   105ea:	9d20      	ldr	r5, [sp, #128]	; 0x80
   105ec:	9c1a      	ldr	r4, [sp, #104]	; 0x68
   105ee:	9e1b      	ldr	r6, [sp, #108]	; 0x6c
   105f0:	9f21      	ldr	r7, [sp, #132]	; 0x84
   105f2:	f8dd b088 	ldr.w	fp, [sp, #136]	; 0x88
   105f6:	f8dd 908c 	ldr.w	r9, [sp, #140]	; 0x8c
   105fa:	f8dd 8090 	ldr.w	r8, [sp, #144]	; 0x90
                    iWidth -= ndigits_in_u64(ui64Val);
   105fe:	1b3c      	subs	r4, r7, r4
    if ( i32NumChars <= 0 )
   10600:	2c00      	cmp	r4, #0
   10602:	f340 81e3 	ble.w	109cc <am_util_stdio_vsprintf+0xcd8>
    while ( i32NumChars-- )
   10606:	1e67      	subs	r7, r4, #1
        if ( pcBuf )
   10608:	f1b8 0f00 	cmp.w	r8, #0
   1060c:	f000 81df 	beq.w	109ce <am_util_stdio_vsprintf+0xcda>
            *pcBuf++ = cPadChar;
   10610:	4643      	mov	r3, r8
   10612:	f007 0007 	and.w	r0, r7, #7
   10616:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   1061a:	f1a4 0a02 	sub.w	sl, r4, #2
   1061e:	eba3 0c08 	sub.w	ip, r3, r8
   10622:	2f00      	cmp	r7, #0
   10624:	d046      	beq.n	106b4 <am_util_stdio_vsprintf+0x9c0>
   10626:	b360      	cbz	r0, 10682 <am_util_stdio_vsprintf+0x98e>
   10628:	2801      	cmp	r0, #1
   1062a:	d021      	beq.n	10670 <am_util_stdio_vsprintf+0x97c>
   1062c:	2802      	cmp	r0, #2
   1062e:	d01b      	beq.n	10668 <am_util_stdio_vsprintf+0x974>
   10630:	2803      	cmp	r0, #3
   10632:	d015      	beq.n	10660 <am_util_stdio_vsprintf+0x96c>
   10634:	2804      	cmp	r0, #4
   10636:	d00f      	beq.n	10658 <am_util_stdio_vsprintf+0x964>
   10638:	2805      	cmp	r0, #5
   1063a:	d009      	beq.n	10650 <am_util_stdio_vsprintf+0x95c>
   1063c:	2806      	cmp	r0, #6
            *pcBuf++ = cPadChar;
   1063e:	bf1c      	itt	ne
   10640:	f803 5b01 	strbne.w	r5, [r3], #1
    while ( i32NumChars-- )
   10644:	f10a 3aff 	addne.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
   10648:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   1064c:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
   10650:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   10654:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
   10658:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   1065c:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
   10660:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   10664:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
   10668:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   1066c:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
   10670:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   10674:	f10a 3aff 	add.w	sl, sl, #4294967295
   10678:	f11a 0001 	adds.w	r0, sl, #1
   1067c:	eba3 0c08 	sub.w	ip, r3, r8
   10680:	d018      	beq.n	106b4 <am_util_stdio_vsprintf+0x9c0>
            *pcBuf++ = cPadChar;
   10682:	469e      	mov	lr, r3
    while ( i32NumChars-- )
   10684:	f1aa 0a08 	sub.w	sl, sl, #8
            *pcBuf++ = cPadChar;
   10688:	f80e 5b01 	strb.w	r5, [lr], #1
   1068c:	3308      	adds	r3, #8
   1068e:	f88e 5000 	strb.w	r5, [lr]
   10692:	f803 5c06 	strb.w	r5, [r3, #-6]
   10696:	f803 5c05 	strb.w	r5, [r3, #-5]
   1069a:	f803 5c04 	strb.w	r5, [r3, #-4]
   1069e:	f803 5c03 	strb.w	r5, [r3, #-3]
   106a2:	f803 5c02 	strb.w	r5, [r3, #-2]
    while ( i32NumChars-- )
   106a6:	f11a 0701 	adds.w	r7, sl, #1
   106aa:	eba3 0c08 	sub.w	ip, r3, r8
            *pcBuf++ = cPadChar;
   106ae:	f803 5c01 	strb.w	r5, [r3, #-1]
    while ( i32NumChars-- )
   106b2:	d1e6      	bne.n	10682 <am_util_stdio_vsprintf+0x98e>
   106b4:	4664      	mov	r4, ip
                    pcBuf += pcBuf ? iWidth : 0;
   106b6:	44e0      	add	r8, ip
                    ui32CharCnt += iWidth;
   106b8:	44a1      	add	r9, r4
                iVal = uint64_to_str(ui64Val, pcBuf);
   106ba:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
   106be:	4642      	mov	r2, r8
   106c0:	f7ff fa1a 	bl	faf8 <uint64_to_str>
                if ( pcBuf )
   106c4:	f1b8 0f00 	cmp.w	r8, #0
   106c8:	d000      	beq.n	106cc <am_util_stdio_vsprintf+0x9d8>
                    pcBuf += iVal;
   106ca:	4480      	add	r8, r0
                ui32CharCnt += iVal;
   106cc:	4481      	add	r9, r0
                break;
   106ce:	e4c3      	b.n	10058 <am_util_stdio_vsprintf+0x364>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
   106d0:	78b3      	ldrb	r3, [r6, #2]
   106d2:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
   106d6:	2909      	cmp	r1, #9
        pcStr++;
   106d8:	f106 0602 	add.w	r6, r6, #2
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
   106dc:	f200 8391 	bhi.w	10e02 <am_util_stdio_vsprintf+0x110e>
        uCnt++;
   106e0:	2201      	movs	r2, #1
        bNeg = true;
   106e2:	4694      	mov	ip, r2
   106e4:	e634      	b.n	10350 <am_util_stdio_vsprintf+0x65c>
        switch ( *pcFmt )
   106e6:	78b2      	ldrb	r2, [r6, #2]
   106e8:	f1a2 0c46 	sub.w	ip, r2, #70	; 0x46
                pcFmt++;
   106ec:	3602      	adds	r6, #2
        switch ( *pcFmt )
   106ee:	f1bc 0f32 	cmp.w	ip, #50	; 0x32
   106f2:	f63f ae0f 	bhi.w	10314 <am_util_stdio_vsprintf+0x620>
   106f6:	a101      	add	r1, pc, #4	; (adr r1, 106fc <am_util_stdio_vsprintf+0xa08>)
   106f8:	f851 f02c 	ldr.w	pc, [r1, ip, lsl #2]
   106fc:	0001001b 	.word	0x0001001b
   10700:	00010315 	.word	0x00010315
   10704:	00010315 	.word	0x00010315
   10708:	00010315 	.word	0x00010315
   1070c:	00010315 	.word	0x00010315
   10710:	00010315 	.word	0x00010315
   10714:	00010315 	.word	0x00010315
   10718:	00010315 	.word	0x00010315
   1071c:	00010315 	.word	0x00010315
   10720:	00010315 	.word	0x00010315
   10724:	00010315 	.word	0x00010315
   10728:	00010315 	.word	0x00010315
   1072c:	00010315 	.word	0x00010315
   10730:	00010315 	.word	0x00010315
   10734:	00010315 	.word	0x00010315
   10738:	00010315 	.word	0x00010315
   1073c:	00010315 	.word	0x00010315
   10740:	00010315 	.word	0x00010315
   10744:	00010ecd 	.word	0x00010ecd
   10748:	00010315 	.word	0x00010315
   1074c:	00010315 	.word	0x00010315
   10750:	00010315 	.word	0x00010315
   10754:	00010315 	.word	0x00010315
   10758:	00010315 	.word	0x00010315
   1075c:	00010315 	.word	0x00010315
   10760:	00010315 	.word	0x00010315
   10764:	00010315 	.word	0x00010315
   10768:	00010315 	.word	0x00010315
   1076c:	00010315 	.word	0x00010315
   10770:	0001005d 	.word	0x0001005d
   10774:	000107df 	.word	0x000107df
   10778:	00010315 	.word	0x00010315
   1077c:	0001001b 	.word	0x0001001b
   10780:	00010315 	.word	0x00010315
   10784:	00010315 	.word	0x00010315
   10788:	000107df 	.word	0x000107df
   1078c:	00010315 	.word	0x00010315
   10790:	00010315 	.word	0x00010315
   10794:	00010315 	.word	0x00010315
   10798:	00010315 	.word	0x00010315
   1079c:	00010315 	.word	0x00010315
   107a0:	00010315 	.word	0x00010315
   107a4:	00010315 	.word	0x00010315
   107a8:	00010315 	.word	0x00010315
   107ac:	00010315 	.word	0x00010315
   107b0:	000103d1 	.word	0x000103d1
   107b4:	00010315 	.word	0x00010315
   107b8:	000107c9 	.word	0x000107c9
   107bc:	00010315 	.word	0x00010315
   107c0:	00010315 	.word	0x00010315
   107c4:	00010d5f 	.word	0x00010d5f
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
   107c8:	f10b 0207 	add.w	r2, fp, #7
   107cc:	f022 0b07 	bic.w	fp, r2, #7
   107d0:	e9db 0100 	ldrd	r0, r1, [fp]
   107d4:	f10b 0b08 	add.w	fp, fp, #8
   107d8:	e9cd 0118 	strd	r0, r1, [sp, #96]	; 0x60
   107dc:	e501      	b.n	101e2 <am_util_stdio_vsprintf+0x4ee>
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
   107de:	f10b 0307 	add.w	r3, fp, #7
   107e2:	f023 0b07 	bic.w	fp, r3, #7
   107e6:	e9db 0100 	ldrd	r0, r1, [fp]
   107ea:	f10b 0b08 	add.w	fp, fp, #8
   107ee:	e44e      	b.n	1008e <am_util_stdio_vsprintf+0x39a>
                    ui64Val = -i64Val;          // Get absolute value
   107f0:	4240      	negs	r0, r0
   107f2:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   107f6:	e9cd 0118 	strd	r0, r1, [sp, #96]	; 0x60
                if ( iWidth )
   107fa:	2c00      	cmp	r4, #0
   107fc:	f040 834e 	bne.w	10e9c <am_util_stdio_vsprintf+0x11a8>
                        if ( pcBuf )
   10800:	f1b8 0f00 	cmp.w	r8, #0
   10804:	f000 82d1 	beq.w	10daa <am_util_stdio_vsprintf+0x10b6>
                            *pcBuf++ = '-';
   10808:	252d      	movs	r5, #45	; 0x2d
   1080a:	f888 5000 	strb.w	r5, [r8]
                        ++ui32CharCnt;
   1080e:	f109 0901 	add.w	r9, r9, #1
                            *pcBuf++ = '-';
   10812:	f108 0801 	add.w	r8, r8, #1
                iVal = uint64_to_str(ui64Val, pcBuf);
   10816:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
   1081a:	4642      	mov	r2, r8
   1081c:	f7ff f96c 	bl	faf8 <uint64_to_str>
                if ( pcBuf )
   10820:	f1b8 0f00 	cmp.w	r8, #0
   10824:	f47f af51 	bne.w	106ca <am_util_stdio_vsprintf+0x9d6>
                    pcBuf += iVal;
   10828:	f04f 0800 	mov.w	r8, #0
                ui32CharCnt += iVal;
   1082c:	4481      	add	r9, r0
   1082e:	e413      	b.n	10058 <am_util_stdio_vsprintf+0x364>
   10830:	e9cd 671e 	strd	r6, r7, [sp, #120]	; 0x78
   10834:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   10836:	9f22      	ldr	r7, [sp, #136]	; 0x88
                    if ( bNeg )
   10838:	9c1b      	ldr	r4, [sp, #108]	; 0x6c
   1083a:	9d21      	ldr	r5, [sp, #132]	; 0x84
   1083c:	9e20      	ldr	r6, [sp, #128]	; 0x80
   1083e:	f8dd 9090 	ldr.w	r9, [sp, #144]	; 0x90
   10842:	f8dd 8094 	ldr.w	r8, [sp, #148]	; 0x94
   10846:	e9cd ab1c 	strd	sl, fp, [sp, #112]	; 0x70
                    iWidth -= ndigits_in_i64(ui64Val);
   1084a:	1aff      	subs	r7, r7, r3
   1084c:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
                    if ( bNeg )
   10850:	b13c      	cbz	r4, 10862 <am_util_stdio_vsprintf+0xb6e>
                        if ( ui8PadChar == '0' )
   10852:	2d30      	cmp	r5, #48	; 0x30
                        --iWidth;
   10854:	f107 31ff 	add.w	r1, r7, #4294967295
                        if ( ui8PadChar == '0' )
   10858:	f000 82c3 	beq.w	10de2 <am_util_stdio_vsprintf+0x10ee>
   1085c:	2001      	movs	r0, #1
                        --iWidth;
   1085e:	460f      	mov	r7, r1
   10860:	901b      	str	r0, [sp, #108]	; 0x6c
    if ( i32NumChars <= 0 )
   10862:	2f00      	cmp	r7, #0
   10864:	f340 82d3 	ble.w	10e0e <am_util_stdio_vsprintf+0x111a>
    while ( i32NumChars-- )
   10868:	1e78      	subs	r0, r7, #1
        if ( pcBuf )
   1086a:	f1b8 0f00 	cmp.w	r8, #0
   1086e:	d067      	beq.n	10940 <am_util_stdio_vsprintf+0xc4c>
   10870:	f010 0107 	ands.w	r1, r0, #7
   10874:	f1a7 0a02 	sub.w	sl, r7, #2
   10878:	4643      	mov	r3, r8
   1087a:	d03a      	beq.n	108f2 <am_util_stdio_vsprintf+0xbfe>
            *pcBuf++ = cPadChar;
   1087c:	4643      	mov	r3, r8
   1087e:	2901      	cmp	r1, #1
   10880:	f1a7 0a03 	sub.w	sl, r7, #3
   10884:	f803 5b01 	strb.w	r5, [r3], #1
   10888:	d033      	beq.n	108f2 <am_util_stdio_vsprintf+0xbfe>
   1088a:	2902      	cmp	r1, #2
   1088c:	d01b      	beq.n	108c6 <am_util_stdio_vsprintf+0xbd2>
   1088e:	2903      	cmp	r1, #3
   10890:	d015      	beq.n	108be <am_util_stdio_vsprintf+0xbca>
   10892:	2904      	cmp	r1, #4
   10894:	d00f      	beq.n	108b6 <am_util_stdio_vsprintf+0xbc2>
   10896:	2905      	cmp	r1, #5
   10898:	d009      	beq.n	108ae <am_util_stdio_vsprintf+0xbba>
   1089a:	2906      	cmp	r1, #6
   1089c:	bf1c      	itt	ne
   1089e:	f803 5b01 	strbne.w	r5, [r3], #1
   108a2:	f1a7 0a04 	subne.w	sl, r7, #4
   108a6:	f803 5b01 	strb.w	r5, [r3], #1
   108aa:	f10a 3aff 	add.w	sl, sl, #4294967295
   108ae:	f803 5b01 	strb.w	r5, [r3], #1
   108b2:	f10a 3aff 	add.w	sl, sl, #4294967295
   108b6:	f803 5b01 	strb.w	r5, [r3], #1
   108ba:	f10a 3aff 	add.w	sl, sl, #4294967295
   108be:	f803 5b01 	strb.w	r5, [r3], #1
   108c2:	f10a 3aff 	add.w	sl, sl, #4294967295
   108c6:	f803 5b01 	strb.w	r5, [r3], #1
   108ca:	f10a 3aff 	add.w	sl, sl, #4294967295
   108ce:	e010      	b.n	108f2 <am_util_stdio_vsprintf+0xbfe>
   108d0:	f88c 5000 	strb.w	r5, [ip]
   108d4:	3308      	adds	r3, #8
   108d6:	f803 5c06 	strb.w	r5, [r3, #-6]
   108da:	f803 5c05 	strb.w	r5, [r3, #-5]
   108de:	f803 5c04 	strb.w	r5, [r3, #-4]
   108e2:	f803 5c03 	strb.w	r5, [r3, #-3]
   108e6:	f803 5c02 	strb.w	r5, [r3, #-2]
   108ea:	f1aa 0a08 	sub.w	sl, sl, #8
   108ee:	f803 5c01 	strb.w	r5, [r3, #-1]
   108f2:	469c      	mov	ip, r3
    while ( i32NumChars-- )
   108f4:	f11a 0401 	adds.w	r4, sl, #1
            *pcBuf++ = cPadChar;
   108f8:	f80c 5b01 	strb.w	r5, [ip], #1
   108fc:	ebac 0e08 	sub.w	lr, ip, r8
    while ( i32NumChars-- )
   10900:	d1e6      	bne.n	108d0 <am_util_stdio_vsprintf+0xbdc>
                    if ( bNeg  &&  (ui8PadChar == ' ') )
   10902:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   10904:	44f0      	add	r8, lr
                    ui32CharCnt += iWidth;
   10906:	44f1      	add	r9, lr
                    if ( bNeg  &&  (ui8PadChar == ' ') )
   10908:	2a00      	cmp	r2, #0
   1090a:	d084      	beq.n	10816 <am_util_stdio_vsprintf+0xb22>
   1090c:	2d20      	cmp	r5, #32
   1090e:	d182      	bne.n	10816 <am_util_stdio_vsprintf+0xb22>
                        if ( pcBuf )
   10910:	f1b8 0f00 	cmp.w	r8, #0
   10914:	f47f af78 	bne.w	10808 <am_util_stdio_vsprintf+0xb14>
                iVal = uint64_to_str(ui64Val, pcBuf);
   10918:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
   1091c:	2200      	movs	r2, #0
   1091e:	f7ff f8eb 	bl	faf8 <uint64_to_str>
                        ++ui32CharCnt;
   10922:	f109 0901 	add.w	r9, r9, #1
                iVal = uint64_to_str(ui64Val, pcBuf);
   10926:	f04f 0800 	mov.w	r8, #0
                ui32CharCnt += iVal;
   1092a:	4481      	add	r9, r0
   1092c:	f7ff bb94 	b.w	10058 <am_util_stdio_vsprintf+0x364>
    if ( i32NumChars <= 0 )
   10930:	2900      	cmp	r1, #0
                            ++ui32CharCnt;
   10932:	f109 0901 	add.w	r9, r9, #1
    if ( i32NumChars <= 0 )
   10936:	f340 82bc 	ble.w	10eb2 <am_util_stdio_vsprintf+0x11be>
    while ( i32NumChars-- )
   1093a:	2201      	movs	r2, #1
   1093c:	1eb8      	subs	r0, r7, #2
   1093e:	921b      	str	r2, [sp, #108]	; 0x6c
   10940:	3001      	adds	r0, #1
                    if ( bNeg  &&  (ui8PadChar == ' ') )
   10942:	9f1b      	ldr	r7, [sp, #108]	; 0x6c
                    ui32CharCnt += iWidth;
   10944:	4481      	add	r9, r0
                    if ( bNeg  &&  (ui8PadChar == ' ') )
   10946:	2f00      	cmp	r7, #0
   10948:	f000 821b 	beq.w	10d82 <am_util_stdio_vsprintf+0x108e>
   1094c:	2d20      	cmp	r5, #32
   1094e:	d0e3      	beq.n	10918 <am_util_stdio_vsprintf+0xc24>
                iVal = uint64_to_str(ui64Val, pcBuf);
   10950:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
   10954:	2200      	movs	r2, #0
   10956:	f7ff f8cf 	bl	faf8 <uint64_to_str>
   1095a:	e765      	b.n	10828 <am_util_stdio_vsprintf+0xb34>
    if ( i32NumChars <= 0 )
   1095c:	2700      	movs	r7, #0
   1095e:	2400      	movs	r4, #0
   10960:	f7ff baee 	b.w	ff40 <am_util_stdio_vsprintf+0x24c>
    iExp2 = ((unFloatValue.I32 >> 23) & 0x000000FF) - 127;
   10964:	ee17 7a90 	vmov	r7, s15
   10968:	f3c7 5ec7 	ubfx	lr, r7, #23, #8
   1096c:	f1ae 017f 	sub.w	r1, lr, #127	; 0x7f
    i32Significand = (unFloatValue.I32 & 0x00FFFFFF) | 0x00800000;
   10970:	f3c7 0216 	ubfx	r2, r7, #0, #23
    if (iExp2 >= 31)
   10974:	291e      	cmp	r1, #30
    i32Significand = (unFloatValue.I32 & 0x00FFFFFF) | 0x00800000;
   10976:	f442 0000 	orr.w	r0, r2, #8388608	; 0x800000
    if (iExp2 >= 31)
   1097a:	f300 8246 	bgt.w	10e0a <am_util_stdio_vsprintf+0x1116>
    else if (iExp2 < -23)
   1097e:	f111 0f17 	cmn.w	r1, #23
   10982:	f2c0 823c 	blt.w	10dfe <am_util_stdio_vsprintf+0x110a>
    else if (iExp2 >= 23)
   10986:	2916      	cmp	r1, #22
   10988:	dd2f      	ble.n	109ea <am_util_stdio_vsprintf+0xcf6>
        i32IntPart = i32Significand << (iExp2 - 23);
   1098a:	f1ae 0296 	sub.w	r2, lr, #150	; 0x96
    if (unFloatValue.I32 < 0)
   1098e:	2f00      	cmp	r7, #0
        i32IntPart = i32Significand << (iExp2 - 23);
   10990:	fa00 f002 	lsl.w	r0, r0, r2
    if (unFloatValue.I32 < 0)
   10994:	f2c0 825c 	blt.w	10e50 <am_util_stdio_vsprintf+0x115c>
    if (i32IntPart == 0)
   10998:	2800      	cmp	r0, #0
   1099a:	f040 824c 	bne.w	10e36 <am_util_stdio_vsprintf+0x1142>
    *pcBuf++ = '.';
   1099e:	252e      	movs	r5, #46	; 0x2e
        *pcBuf++ = '0';
   109a0:	f04f 0430 	mov.w	r4, #48	; 0x30
    *pcBuf++ = '.';
   109a4:	f888 5001 	strb.w	r5, [r8, #1]
        *pcBuf++ = '0';
   109a8:	f888 4000 	strb.w	r4, [r8]
   109ac:	f108 0501 	add.w	r5, r8, #1
        *pcBuf++ = '0';
   109b0:	1caa      	adds	r2, r5, #2
   109b2:	f04f 0430 	mov.w	r4, #48	; 0x30
   109b6:	706c      	strb	r4, [r5, #1]
   109b8:	eba2 0008 	sub.w	r0, r2, r8
    *pcBuf = 0x00;
   109bc:	2500      	movs	r5, #0
                    if ( iVal < 0 )
   109be:	42a8      	cmp	r0, r5
    *pcBuf = 0x00;
   109c0:	7015      	strb	r5, [r2, #0]
                    if ( iVal < 0 )
   109c2:	f2c0 81e7 	blt.w	10d94 <am_util_stdio_vsprintf+0x10a0>
   109c6:	4682      	mov	sl, r0
   109c8:	f7ff bb44 	b.w	10054 <am_util_stdio_vsprintf+0x360>
    if ( i32NumChars <= 0 )
   109cc:	2400      	movs	r4, #0
   109ce:	f04f 0c00 	mov.w	ip, #0
   109d2:	e670      	b.n	106b6 <am_util_stdio_vsprintf+0x9c2>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
   109d4:	4606      	mov	r6, r0
   109d6:	2400      	movs	r4, #0
   109d8:	f7ff b9f4 	b.w	fdc4 <am_util_stdio_vsprintf+0xd0>
   109dc:	f04f 0a00 	mov.w	sl, #0
    uint32_t ui32Val = 0, uCnt = 0;
   109e0:	4652      	mov	r2, sl
            pcFmt += ui32NumChars;
   109e2:	1886      	adds	r6, r0, r2
   109e4:	5c82      	ldrb	r2, [r0, r2]
   109e6:	f7ff b9f9 	b.w	fddc <am_util_stdio_vsprintf+0xe8>
    else if (iExp2 >= 0)
   109ea:	2900      	cmp	r1, #0
   109ec:	f2c0 8214 	blt.w	10e18 <am_util_stdio_vsprintf+0x1124>
        i32FracPart = (i32Significand << (iExp2 + 1)) & 0x00FFFFFF;
   109f0:	f1ae 047e 	sub.w	r4, lr, #126	; 0x7e
   109f4:	fa00 f304 	lsl.w	r3, r0, r4
        i32IntPart = i32Significand >> (23 - iExp2);
   109f8:	f1c1 0117 	rsb	r1, r1, #23
    if (unFloatValue.I32 < 0)
   109fc:	2f00      	cmp	r7, #0
        i32FracPart = (i32Significand << (iExp2 + 1)) & 0x00FFFFFF;
   109fe:	f023 447f 	bic.w	r4, r3, #4278190080	; 0xff000000
        i32IntPart = i32Significand >> (23 - iExp2);
   10a02:	fa40 f001 	asr.w	r0, r0, r1
    if (unFloatValue.I32 < 0)
   10a06:	f2c0 823b 	blt.w	10e80 <am_util_stdio_vsprintf+0x118c>
   10a0a:	4645      	mov	r5, r8
            uint64_to_str(i32IntPart, pcBuf);
   10a0c:	462a      	mov	r2, r5
   10a0e:	17c1      	asrs	r1, r0, #31
   10a10:	f7ff f872 	bl	faf8 <uint64_to_str>
        while (*pcBuf)    // Get to end of new string
   10a14:	7829      	ldrb	r1, [r5, #0]
   10a16:	b119      	cbz	r1, 10a20 <am_util_stdio_vsprintf+0xd2c>
   10a18:	f815 0f01 	ldrb.w	r0, [r5, #1]!
   10a1c:	2800      	cmp	r0, #0
   10a1e:	d1fb      	bne.n	10a18 <am_util_stdio_vsprintf+0xd24>
    *pcBuf++ = '.';
   10a20:	222e      	movs	r2, #46	; 0x2e
   10a22:	702a      	strb	r2, [r5, #0]
    if (i32FracPart == 0)
   10a24:	2c00      	cmp	r4, #0
   10a26:	d0c3      	beq.n	109b0 <am_util_stdio_vsprintf+0xcbc>
    *pcBuf++ = '.';
   10a28:	1c6a      	adds	r2, r5, #1
        iMax = iBufSize - (pcBuf - pcBufInitial) - 1;
   10a2a:	eba2 0008 	sub.w	r0, r2, r8
   10a2e:	f1c0 0c13 	rsb	ip, r0, #19
        iMax = (iMax > iPrecision) ? iPrecision : iMax;
   10a32:	45e2      	cmp	sl, ip
   10a34:	bfa8      	it	ge
   10a36:	46e2      	movge	sl, ip
        for (jx = 0; jx < iMax; jx++)
   10a38:	f1ba 0f00 	cmp.w	sl, #0
   10a3c:	f340 80b2 	ble.w	10ba4 <am_util_stdio_vsprintf+0xeb0>
            i32FracPart *= 10;
   10a40:	eb04 0484 	add.w	r4, r4, r4, lsl #2
   10a44:	0067      	lsls	r7, r4, #1
   10a46:	eb05 000a 	add.w	r0, r5, sl
            *pcBuf++ = (i32FracPart >> 24) + '0';
   10a4a:	1639      	asrs	r1, r7, #24
   10a4c:	3130      	adds	r1, #48	; 0x30
   10a4e:	f10a 3eff 	add.w	lr, sl, #4294967295
        for (jx = 0; jx < iMax; jx++)
   10a52:	4290      	cmp	r0, r2
            *pcBuf++ = (i32FracPart >> 24) + '0';
   10a54:	7069      	strb	r1, [r5, #1]
   10a56:	901a      	str	r0, [sp, #104]	; 0x68
            i32FracPart &= 0x00FFFFFF;
   10a58:	f027 447f 	bic.w	r4, r7, #4278190080	; 0xff000000
   10a5c:	f00e 0507 	and.w	r5, lr, #7
   10a60:	4613      	mov	r3, r2
        for (jx = 0; jx < iMax; jx++)
   10a62:	f000 809c 	beq.w	10b9e <am_util_stdio_vsprintf+0xeaa>
   10a66:	2d00      	cmp	r5, #0
   10a68:	d04d      	beq.n	10b06 <am_util_stdio_vsprintf+0xe12>
   10a6a:	2d01      	cmp	r5, #1
   10a6c:	d03f      	beq.n	10aee <am_util_stdio_vsprintf+0xdfa>
   10a6e:	2d02      	cmp	r5, #2
   10a70:	d034      	beq.n	10adc <am_util_stdio_vsprintf+0xde8>
   10a72:	2d03      	cmp	r5, #3
   10a74:	d029      	beq.n	10aca <am_util_stdio_vsprintf+0xdd6>
   10a76:	2d04      	cmp	r5, #4
   10a78:	d01e      	beq.n	10ab8 <am_util_stdio_vsprintf+0xdc4>
   10a7a:	2d05      	cmp	r5, #5
   10a7c:	d013      	beq.n	10aa6 <am_util_stdio_vsprintf+0xdb2>
   10a7e:	2d06      	cmp	r5, #6
   10a80:	d008      	beq.n	10a94 <am_util_stdio_vsprintf+0xda0>
            i32FracPart *= 10;
   10a82:	eb04 0484 	add.w	r4, r4, r4, lsl #2
   10a86:	0067      	lsls	r7, r4, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
   10a88:	1639      	asrs	r1, r7, #24
   10a8a:	3130      	adds	r1, #48	; 0x30
   10a8c:	f803 1f01 	strb.w	r1, [r3, #1]!
            i32FracPart &= 0x00FFFFFF;
   10a90:	f027 447f 	bic.w	r4, r7, #4278190080	; 0xff000000
            i32FracPart *= 10;
   10a94:	eb04 0084 	add.w	r0, r4, r4, lsl #2
   10a98:	0045      	lsls	r5, r0, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
   10a9a:	162c      	asrs	r4, r5, #24
   10a9c:	3430      	adds	r4, #48	; 0x30
   10a9e:	f803 4f01 	strb.w	r4, [r3, #1]!
            i32FracPart &= 0x00FFFFFF;
   10aa2:	f025 447f 	bic.w	r4, r5, #4278190080	; 0xff000000
            i32FracPart *= 10;
   10aa6:	eb04 0784 	add.w	r7, r4, r4, lsl #2
   10aaa:	0078      	lsls	r0, r7, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
   10aac:	1601      	asrs	r1, r0, #24
   10aae:	3130      	adds	r1, #48	; 0x30
   10ab0:	f803 1f01 	strb.w	r1, [r3, #1]!
            i32FracPart &= 0x00FFFFFF;
   10ab4:	f020 447f 	bic.w	r4, r0, #4278190080	; 0xff000000
            i32FracPart *= 10;
   10ab8:	eb04 0584 	add.w	r5, r4, r4, lsl #2
   10abc:	006c      	lsls	r4, r5, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
   10abe:	1627      	asrs	r7, r4, #24
   10ac0:	3730      	adds	r7, #48	; 0x30
   10ac2:	f803 7f01 	strb.w	r7, [r3, #1]!
            i32FracPart &= 0x00FFFFFF;
   10ac6:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
            i32FracPart *= 10;
   10aca:	eb04 0084 	add.w	r0, r4, r4, lsl #2
   10ace:	0045      	lsls	r5, r0, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
   10ad0:	1629      	asrs	r1, r5, #24
   10ad2:	3130      	adds	r1, #48	; 0x30
   10ad4:	f803 1f01 	strb.w	r1, [r3, #1]!
            i32FracPart &= 0x00FFFFFF;
   10ad8:	f025 447f 	bic.w	r4, r5, #4278190080	; 0xff000000
            i32FracPart *= 10;
   10adc:	eb04 0484 	add.w	r4, r4, r4, lsl #2
   10ae0:	0067      	lsls	r7, r4, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
   10ae2:	1638      	asrs	r0, r7, #24
   10ae4:	3030      	adds	r0, #48	; 0x30
   10ae6:	f803 0f01 	strb.w	r0, [r3, #1]!
            i32FracPart &= 0x00FFFFFF;
   10aea:	f027 447f 	bic.w	r4, r7, #4278190080	; 0xff000000
            i32FracPart *= 10;
   10aee:	eb04 0584 	add.w	r5, r4, r4, lsl #2
   10af2:	006c      	lsls	r4, r5, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
   10af4:	1621      	asrs	r1, r4, #24
   10af6:	3130      	adds	r1, #48	; 0x30
   10af8:	f803 1f01 	strb.w	r1, [r3, #1]!
        for (jx = 0; jx < iMax; jx++)
   10afc:	9f1a      	ldr	r7, [sp, #104]	; 0x68
   10afe:	429f      	cmp	r7, r3
            i32FracPart &= 0x00FFFFFF;
   10b00:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
        for (jx = 0; jx < iMax; jx++)
   10b04:	d04b      	beq.n	10b9e <am_util_stdio_vsprintf+0xeaa>
            i32FracPart *= 10;
   10b06:	eb04 0084 	add.w	r0, r4, r4, lsl #2
   10b0a:	0041      	lsls	r1, r0, #1
            i32FracPart &= 0x00FFFFFF;
   10b0c:	f021 4c7f 	bic.w	ip, r1, #4278190080	; 0xff000000
            i32FracPart *= 10;
   10b10:	eb0c 058c 	add.w	r5, ip, ip, lsl #2
   10b14:	006c      	lsls	r4, r5, #1
            i32FracPart &= 0x00FFFFFF;
   10b16:	f024 4e7f 	bic.w	lr, r4, #4278190080	; 0xff000000
            i32FracPart *= 10;
   10b1a:	eb0e 078e 	add.w	r7, lr, lr, lsl #2
   10b1e:	ea4f 0c47 	mov.w	ip, r7, lsl #1
            i32FracPart &= 0x00FFFFFF;
   10b22:	f02c 407f 	bic.w	r0, ip, #4278190080	; 0xff000000
            i32FracPart *= 10;
   10b26:	eb00 0580 	add.w	r5, r0, r0, lsl #2
   10b2a:	ea4f 0e45 	mov.w	lr, r5, lsl #1
            i32FracPart &= 0x00FFFFFF;
   10b2e:	f02e 477f 	bic.w	r7, lr, #4278190080	; 0xff000000
            i32FracPart *= 10;
   10b32:	eb07 0087 	add.w	r0, r7, r7, lsl #2
   10b36:	0047      	lsls	r7, r0, #1
            i32FracPart &= 0x00FFFFFF;
   10b38:	f027 457f 	bic.w	r5, r7, #4278190080	; 0xff000000
            i32FracPart *= 10;
   10b3c:	eb05 0085 	add.w	r0, r5, r5, lsl #2
   10b40:	0045      	lsls	r5, r0, #1
            i32FracPart &= 0x00FFFFFF;
   10b42:	f025 407f 	bic.w	r0, r5, #4278190080	; 0xff000000
            i32FracPart *= 10;
   10b46:	eb00 0080 	add.w	r0, r0, r0, lsl #2
            *pcBuf++ = (i32FracPart >> 24) + '0';
   10b4a:	1609      	asrs	r1, r1, #24
            i32FracPart *= 10;
   10b4c:	0040      	lsls	r0, r0, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
   10b4e:	3130      	adds	r1, #48	; 0x30
   10b50:	1624      	asrs	r4, r4, #24
   10b52:	3430      	adds	r4, #48	; 0x30
   10b54:	7059      	strb	r1, [r3, #1]
            i32FracPart &= 0x00FFFFFF;
   10b56:	f020 417f 	bic.w	r1, r0, #4278190080	; 0xff000000
            *pcBuf++ = (i32FracPart >> 24) + '0';
   10b5a:	709c      	strb	r4, [r3, #2]
            i32FracPart *= 10;
   10b5c:	eb01 0481 	add.w	r4, r1, r1, lsl #2
   10b60:	0064      	lsls	r4, r4, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
   10b62:	1601      	asrs	r1, r0, #24
   10b64:	ea4f 6c2c 	mov.w	ip, ip, asr #24
   10b68:	1620      	asrs	r0, r4, #24
   10b6a:	ea4f 6e2e 	mov.w	lr, lr, asr #24
   10b6e:	163f      	asrs	r7, r7, #24
   10b70:	162d      	asrs	r5, r5, #24
   10b72:	3730      	adds	r7, #48	; 0x30
   10b74:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
   10b78:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
   10b7c:	3530      	adds	r5, #48	; 0x30
   10b7e:	3130      	adds	r1, #48	; 0x30
   10b80:	3030      	adds	r0, #48	; 0x30
   10b82:	715f      	strb	r7, [r3, #5]
   10b84:	f883 c003 	strb.w	ip, [r3, #3]
   10b88:	f883 e004 	strb.w	lr, [r3, #4]
   10b8c:	719d      	strb	r5, [r3, #6]
   10b8e:	71d9      	strb	r1, [r3, #7]
        for (jx = 0; jx < iMax; jx++)
   10b90:	9f1a      	ldr	r7, [sp, #104]	; 0x68
            *pcBuf++ = (i32FracPart >> 24) + '0';
   10b92:	f803 0f08 	strb.w	r0, [r3, #8]!
        for (jx = 0; jx < iMax; jx++)
   10b96:	429f      	cmp	r7, r3
            i32FracPart &= 0x00FFFFFF;
   10b98:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
        for (jx = 0; jx < iMax; jx++)
   10b9c:	d1b3      	bne.n	10b06 <am_util_stdio_vsprintf+0xe12>
   10b9e:	4452      	add	r2, sl
   10ba0:	eba2 0008 	sub.w	r0, r2, r8
        if ( ((i32FracPart * 10) >> 24) >= 5 )
   10ba4:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   10ba8:	f343 55c7 	sbfx	r5, r3, #23, #8
   10bac:	2d04      	cmp	r5, #4
   10bae:	f77f af05 	ble.w	109bc <am_util_stdio_vsprintf+0xcc8>
            pcBuftmp = pcBuf - 1;
   10bb2:	1e53      	subs	r3, r2, #1
            while ( pcBuftmp >= pcBufInitial )
   10bb4:	4598      	cmp	r8, r3
   10bb6:	f63f af01 	bhi.w	109bc <am_util_stdio_vsprintf+0xcc8>
   10bba:	f108 37ff 	add.w	r7, r8, #4294967295
                if ( *pcBuftmp == '.' )
   10bbe:	f812 1c01 	ldrb.w	r1, [r2, #-1]
   10bc2:	1afc      	subs	r4, r7, r3
   10bc4:	43e5      	mvns	r5, r4
   10bc6:	292e      	cmp	r1, #46	; 0x2e
   10bc8:	f005 0407 	and.w	r4, r5, #7
   10bcc:	d005      	beq.n	10bda <am_util_stdio_vsprintf+0xee6>
                else if ( *pcBuftmp == '9' )
   10bce:	2939      	cmp	r1, #57	; 0x39
   10bd0:	f040 8161 	bne.w	10e96 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   10bd4:	f04f 0130 	mov.w	r1, #48	; 0x30
   10bd8:	7019      	strb	r1, [r3, #0]
                pcBuftmp--;
   10bda:	3b01      	subs	r3, #1
            while ( pcBuftmp >= pcBufInitial )
   10bdc:	42bb      	cmp	r3, r7
   10bde:	f43f aeed 	beq.w	109bc <am_util_stdio_vsprintf+0xcc8>
   10be2:	2c00      	cmp	r4, #0
   10be4:	d054      	beq.n	10c90 <am_util_stdio_vsprintf+0xf9c>
   10be6:	2c01      	cmp	r4, #1
   10be8:	d045      	beq.n	10c76 <am_util_stdio_vsprintf+0xf82>
   10bea:	2c02      	cmp	r4, #2
   10bec:	d039      	beq.n	10c62 <am_util_stdio_vsprintf+0xf6e>
   10bee:	2c03      	cmp	r4, #3
   10bf0:	d02d      	beq.n	10c4e <am_util_stdio_vsprintf+0xf5a>
   10bf2:	2c04      	cmp	r4, #4
   10bf4:	d021      	beq.n	10c3a <am_util_stdio_vsprintf+0xf46>
   10bf6:	2c05      	cmp	r4, #5
   10bf8:	d015      	beq.n	10c26 <am_util_stdio_vsprintf+0xf32>
   10bfa:	2c06      	cmp	r4, #6
   10bfc:	d009      	beq.n	10c12 <am_util_stdio_vsprintf+0xf1e>
                if ( *pcBuftmp == '.' )
   10bfe:	7819      	ldrb	r1, [r3, #0]
   10c00:	292e      	cmp	r1, #46	; 0x2e
   10c02:	d005      	beq.n	10c10 <am_util_stdio_vsprintf+0xf1c>
                else if ( *pcBuftmp == '9' )
   10c04:	2939      	cmp	r1, #57	; 0x39
   10c06:	f040 8146 	bne.w	10e96 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   10c0a:	f04f 0530 	mov.w	r5, #48	; 0x30
   10c0e:	701d      	strb	r5, [r3, #0]
                pcBuftmp--;
   10c10:	3b01      	subs	r3, #1
                if ( *pcBuftmp == '.' )
   10c12:	7819      	ldrb	r1, [r3, #0]
   10c14:	292e      	cmp	r1, #46	; 0x2e
   10c16:	d005      	beq.n	10c24 <am_util_stdio_vsprintf+0xf30>
                else if ( *pcBuftmp == '9' )
   10c18:	2939      	cmp	r1, #57	; 0x39
   10c1a:	f040 813c 	bne.w	10e96 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   10c1e:	f04f 0430 	mov.w	r4, #48	; 0x30
   10c22:	701c      	strb	r4, [r3, #0]
                pcBuftmp--;
   10c24:	3b01      	subs	r3, #1
                if ( *pcBuftmp == '.' )
   10c26:	7819      	ldrb	r1, [r3, #0]
   10c28:	292e      	cmp	r1, #46	; 0x2e
   10c2a:	d005      	beq.n	10c38 <am_util_stdio_vsprintf+0xf44>
                else if ( *pcBuftmp == '9' )
   10c2c:	2939      	cmp	r1, #57	; 0x39
   10c2e:	f040 8132 	bne.w	10e96 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   10c32:	f04f 0130 	mov.w	r1, #48	; 0x30
   10c36:	7019      	strb	r1, [r3, #0]
                pcBuftmp--;
   10c38:	3b01      	subs	r3, #1
                if ( *pcBuftmp == '.' )
   10c3a:	7819      	ldrb	r1, [r3, #0]
   10c3c:	292e      	cmp	r1, #46	; 0x2e
   10c3e:	d005      	beq.n	10c4c <am_util_stdio_vsprintf+0xf58>
                else if ( *pcBuftmp == '9' )
   10c40:	2939      	cmp	r1, #57	; 0x39
   10c42:	f040 8128 	bne.w	10e96 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   10c46:	f04f 0530 	mov.w	r5, #48	; 0x30
   10c4a:	701d      	strb	r5, [r3, #0]
                pcBuftmp--;
   10c4c:	3b01      	subs	r3, #1
                if ( *pcBuftmp == '.' )
   10c4e:	7819      	ldrb	r1, [r3, #0]
   10c50:	292e      	cmp	r1, #46	; 0x2e
   10c52:	d005      	beq.n	10c60 <am_util_stdio_vsprintf+0xf6c>
                else if ( *pcBuftmp == '9' )
   10c54:	2939      	cmp	r1, #57	; 0x39
   10c56:	f040 811e 	bne.w	10e96 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   10c5a:	f04f 0430 	mov.w	r4, #48	; 0x30
   10c5e:	701c      	strb	r4, [r3, #0]
                pcBuftmp--;
   10c60:	3b01      	subs	r3, #1
                if ( *pcBuftmp == '.' )
   10c62:	7819      	ldrb	r1, [r3, #0]
   10c64:	292e      	cmp	r1, #46	; 0x2e
   10c66:	d005      	beq.n	10c74 <am_util_stdio_vsprintf+0xf80>
                else if ( *pcBuftmp == '9' )
   10c68:	2939      	cmp	r1, #57	; 0x39
   10c6a:	f040 8114 	bne.w	10e96 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   10c6e:	f04f 0130 	mov.w	r1, #48	; 0x30
   10c72:	7019      	strb	r1, [r3, #0]
                pcBuftmp--;
   10c74:	3b01      	subs	r3, #1
                if ( *pcBuftmp == '.' )
   10c76:	7819      	ldrb	r1, [r3, #0]
   10c78:	292e      	cmp	r1, #46	; 0x2e
   10c7a:	d005      	beq.n	10c88 <am_util_stdio_vsprintf+0xf94>
                else if ( *pcBuftmp == '9' )
   10c7c:	2939      	cmp	r1, #57	; 0x39
   10c7e:	f040 810a 	bne.w	10e96 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   10c82:	f04f 0530 	mov.w	r5, #48	; 0x30
   10c86:	701d      	strb	r5, [r3, #0]
                pcBuftmp--;
   10c88:	3b01      	subs	r3, #1
            while ( pcBuftmp >= pcBufInitial )
   10c8a:	42bb      	cmp	r3, r7
   10c8c:	f43f ae96 	beq.w	109bc <am_util_stdio_vsprintf+0xcc8>
                if ( *pcBuftmp == '.' )
   10c90:	7819      	ldrb	r1, [r3, #0]
   10c92:	292e      	cmp	r1, #46	; 0x2e
   10c94:	d005      	beq.n	10ca2 <am_util_stdio_vsprintf+0xfae>
                else if ( *pcBuftmp == '9' )
   10c96:	2939      	cmp	r1, #57	; 0x39
   10c98:	f040 80fd 	bne.w	10e96 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   10c9c:	f04f 0430 	mov.w	r4, #48	; 0x30
   10ca0:	701c      	strb	r4, [r3, #0]
                pcBuftmp--;
   10ca2:	3b01      	subs	r3, #1
                if ( *pcBuftmp == '.' )
   10ca4:	7819      	ldrb	r1, [r3, #0]
   10ca6:	292e      	cmp	r1, #46	; 0x2e
                pcBuftmp--;
   10ca8:	469a      	mov	sl, r3
                if ( *pcBuftmp == '.' )
   10caa:	d005      	beq.n	10cb8 <am_util_stdio_vsprintf+0xfc4>
                else if ( *pcBuftmp == '9' )
   10cac:	2939      	cmp	r1, #57	; 0x39
   10cae:	f040 80f2 	bne.w	10e96 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   10cb2:	f04f 0130 	mov.w	r1, #48	; 0x30
   10cb6:	7019      	strb	r1, [r3, #0]
                if ( *pcBuftmp == '.' )
   10cb8:	f81a 1c01 	ldrb.w	r1, [sl, #-1]
   10cbc:	292e      	cmp	r1, #46	; 0x2e
                pcBuftmp--;
   10cbe:	f10a 33ff 	add.w	r3, sl, #4294967295
                if ( *pcBuftmp == '.' )
   10cc2:	d006      	beq.n	10cd2 <am_util_stdio_vsprintf+0xfde>
                else if ( *pcBuftmp == '9' )
   10cc4:	2939      	cmp	r1, #57	; 0x39
   10cc6:	f040 80e6 	bne.w	10e96 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   10cca:	f04f 0c30 	mov.w	ip, #48	; 0x30
   10cce:	f80a cc01 	strb.w	ip, [sl, #-1]
                if ( *pcBuftmp == '.' )
   10cd2:	f81a 1c02 	ldrb.w	r1, [sl, #-2]
   10cd6:	292e      	cmp	r1, #46	; 0x2e
                pcBuftmp--;
   10cd8:	f1aa 0302 	sub.w	r3, sl, #2
                if ( *pcBuftmp == '.' )
   10cdc:	d006      	beq.n	10cec <am_util_stdio_vsprintf+0xff8>
                else if ( *pcBuftmp == '9' )
   10cde:	2939      	cmp	r1, #57	; 0x39
   10ce0:	f040 80d9 	bne.w	10e96 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   10ce4:	f04f 0330 	mov.w	r3, #48	; 0x30
   10ce8:	f80a 3c02 	strb.w	r3, [sl, #-2]
                if ( *pcBuftmp == '.' )
   10cec:	f81a 1c03 	ldrb.w	r1, [sl, #-3]
   10cf0:	292e      	cmp	r1, #46	; 0x2e
                pcBuftmp--;
   10cf2:	f1aa 0303 	sub.w	r3, sl, #3
                if ( *pcBuftmp == '.' )
   10cf6:	d006      	beq.n	10d06 <am_util_stdio_vsprintf+0x1012>
                else if ( *pcBuftmp == '9' )
   10cf8:	2939      	cmp	r1, #57	; 0x39
   10cfa:	f040 80cc 	bne.w	10e96 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   10cfe:	f04f 0530 	mov.w	r5, #48	; 0x30
   10d02:	f80a 5c03 	strb.w	r5, [sl, #-3]
                if ( *pcBuftmp == '.' )
   10d06:	f81a 1c04 	ldrb.w	r1, [sl, #-4]
   10d0a:	292e      	cmp	r1, #46	; 0x2e
                pcBuftmp--;
   10d0c:	f1aa 0304 	sub.w	r3, sl, #4
                if ( *pcBuftmp == '.' )
   10d10:	d006      	beq.n	10d20 <am_util_stdio_vsprintf+0x102c>
                else if ( *pcBuftmp == '9' )
   10d12:	2939      	cmp	r1, #57	; 0x39
   10d14:	f040 80bf 	bne.w	10e96 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   10d18:	f04f 0430 	mov.w	r4, #48	; 0x30
   10d1c:	f80a 4c04 	strb.w	r4, [sl, #-4]
                if ( *pcBuftmp == '.' )
   10d20:	f81a 1c05 	ldrb.w	r1, [sl, #-5]
   10d24:	292e      	cmp	r1, #46	; 0x2e
                pcBuftmp--;
   10d26:	f1aa 0305 	sub.w	r3, sl, #5
                if ( *pcBuftmp == '.' )
   10d2a:	d006      	beq.n	10d3a <am_util_stdio_vsprintf+0x1046>
                else if ( *pcBuftmp == '9' )
   10d2c:	2939      	cmp	r1, #57	; 0x39
   10d2e:	f040 80b2 	bne.w	10e96 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   10d32:	f04f 0130 	mov.w	r1, #48	; 0x30
   10d36:	f80a 1c05 	strb.w	r1, [sl, #-5]
                if ( *pcBuftmp == '.' )
   10d3a:	f81a 1c06 	ldrb.w	r1, [sl, #-6]
   10d3e:	292e      	cmp	r1, #46	; 0x2e
                pcBuftmp--;
   10d40:	f1aa 0306 	sub.w	r3, sl, #6
                if ( *pcBuftmp == '.' )
   10d44:	d006      	beq.n	10d54 <am_util_stdio_vsprintf+0x1060>
                else if ( *pcBuftmp == '9' )
   10d46:	2939      	cmp	r1, #57	; 0x39
   10d48:	f040 80a5 	bne.w	10e96 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   10d4c:	f04f 0c30 	mov.w	ip, #48	; 0x30
   10d50:	f80a cc06 	strb.w	ip, [sl, #-6]
                pcBuftmp--;
   10d54:	f1aa 0307 	sub.w	r3, sl, #7
            while ( pcBuftmp >= pcBufInitial )
   10d58:	42bb      	cmp	r3, r7
   10d5a:	d199      	bne.n	10c90 <am_util_stdio_vsprintf+0xf9c>
   10d5c:	e62e      	b.n	109bc <am_util_stdio_vsprintf+0xcc8>
        switch ( *pcFmt )
   10d5e:	f04f 0c01 	mov.w	ip, #1
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
   10d62:	f10b 0307 	add.w	r3, fp, #7
   10d66:	f023 0a07 	bic.w	sl, r3, #7
   10d6a:	f10a 0b08 	add.w	fp, sl, #8
   10d6e:	e9da 2300 	ldrd	r2, r3, [sl]
   10d72:	f7ff b877 	b.w	fe64 <am_util_stdio_vsprintf+0x170>
                while (*pcStr != 0x0)
   10d76:	7801      	ldrb	r1, [r0, #0]
   10d78:	b369      	cbz	r1, 10dd6 <am_util_stdio_vsprintf+0x10e2>
        return ui32RetVal;
   10d7a:	4607      	mov	r7, r0
   10d7c:	2201      	movs	r2, #1
   10d7e:	f7ff bb40 	b.w	10402 <am_util_stdio_vsprintf+0x70e>
                iVal = uint64_to_str(ui64Val, pcBuf);
   10d82:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
   10d86:	463a      	mov	r2, r7
   10d88:	f7fe feb6 	bl	faf8 <uint64_to_str>
   10d8c:	46b8      	mov	r8, r7
                ui32CharCnt += iVal;
   10d8e:	4481      	add	r9, r0
   10d90:	f7ff b962 	b.w	10058 <am_util_stdio_vsprintf+0x364>
                        if ( iVal == AM_FTOA_ERR_VAL_TOO_SMALL )
   10d94:	1c43      	adds	r3, r0, #1
   10d96:	d032      	beq.n	10dfe <am_util_stdio_vsprintf+0x110a>
                        else if ( iVal == AM_FTOA_ERR_VAL_TOO_LARGE )
   10d98:	3002      	adds	r0, #2
   10d9a:	d036      	beq.n	10e0a <am_util_stdio_vsprintf+0x1116>
                            u32PrntErrVal = (0x00 << 24) | ('?' << 16) |
   10d9c:	4a4d      	ldr	r2, [pc, #308]	; (10ed4 <am_util_stdio_vsprintf+0x11e0>)
                        *(uint32_t*)pcBuf = u32PrntErrVal;
   10d9e:	f8c8 2000 	str.w	r2, [r8]
   10da2:	f04f 0a03 	mov.w	sl, #3
   10da6:	f7ff b955 	b.w	10054 <am_util_stdio_vsprintf+0x360>
                iVal = uint64_to_str(ui64Val, pcBuf);
   10daa:	4642      	mov	r2, r8
   10dac:	f7fe fea4 	bl	faf8 <uint64_to_str>
                        ++ui32CharCnt;
   10db0:	f109 0901 	add.w	r9, r9, #1
                ui32CharCnt += iVal;
   10db4:	4481      	add	r9, r0
   10db6:	f7ff b94f 	b.w	10058 <am_util_stdio_vsprintf+0x364>
    if ( i32NumChars <= 0 )
   10dba:	2200      	movs	r2, #0
   10dbc:	2500      	movs	r5, #0
   10dbe:	f7ff bb91 	b.w	104e4 <am_util_stdio_vsprintf+0x7f0>
   10dc2:	2200      	movs	r2, #0
                        pcBuf += pcBuf ? iWidth : 0;
   10dc4:	f1b8 0f00 	cmp.w	r8, #0
   10dc8:	f43f abf9 	beq.w	105be <am_util_stdio_vsprintf+0x8ca>
   10dcc:	4614      	mov	r4, r2
   10dce:	f7ff bbed 	b.w	105ac <am_util_stdio_vsprintf+0x8b8>
                if ( iWidth > 0 )
   10dd2:	2c00      	cmp	r4, #0
   10dd4:	dc02      	bgt.n	10ddc <am_util_stdio_vsprintf+0x10e8>
        return ui32RetVal;
   10dd6:	460f      	mov	r7, r1
   10dd8:	f7ff bb21 	b.w	1041e <am_util_stdio_vsprintf+0x72a>
                    if ( ui32strlen < iWidth )
   10ddc:	460f      	mov	r7, r1
   10dde:	f7ff bb88 	b.w	104f2 <am_util_stdio_vsprintf+0x7fe>
                            if ( pcBuf )
   10de2:	f1b8 0f00 	cmp.w	r8, #0
   10de6:	f43f ada3 	beq.w	10930 <am_util_stdio_vsprintf+0xc3c>
                            ++ui32CharCnt;
   10dea:	2401      	movs	r4, #1
                                *pcBuf++ = '-';
   10dec:	232d      	movs	r3, #45	; 0x2d
   10dee:	f888 3000 	strb.w	r3, [r8]
                            ++ui32CharCnt;
   10df2:	f109 0901 	add.w	r9, r9, #1
                        --iWidth;
   10df6:	460f      	mov	r7, r1
                            ++ui32CharCnt;
   10df8:	941b      	str	r4, [sp, #108]	; 0x6c
                                *pcBuf++ = '-';
   10dfa:	44a0      	add	r8, r4
   10dfc:	e531      	b.n	10862 <am_util_stdio_vsprintf+0xb6e>
                            u32PrntErrVal = (0x00 << 24) | ('0' << 16) |
   10dfe:	4a36      	ldr	r2, [pc, #216]	; (10ed8 <am_util_stdio_vsprintf+0x11e4>)
   10e00:	e7cd      	b.n	10d9e <am_util_stdio_vsprintf+0x10aa>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
   10e02:	f04f 0a00 	mov.w	sl, #0
        uCnt++;
   10e06:	2201      	movs	r2, #1
   10e08:	e5eb      	b.n	109e2 <am_util_stdio_vsprintf+0xcee>
                            u32PrntErrVal = (0x00 << 24) | ('#' << 16) |
   10e0a:	4a34      	ldr	r2, [pc, #208]	; (10edc <am_util_stdio_vsprintf+0x11e8>)
   10e0c:	e7c7      	b.n	10d9e <am_util_stdio_vsprintf+0x10aa>
                    pcBuf += pcBuf ? iWidth : 0;
   10e0e:	f1b8 0f00 	cmp.w	r8, #0
   10e12:	d13d      	bne.n	10e90 <am_util_stdio_vsprintf+0x119c>
   10e14:	4640      	mov	r0, r8
   10e16:	e594      	b.n	10942 <am_util_stdio_vsprintf+0xc4e>
        i32FracPart = (i32Significand & 0x00FFFFFF) >> -(iExp2 + 1);
   10e18:	43cd      	mvns	r5, r1
    if (unFloatValue.I32 < 0)
   10e1a:	2f00      	cmp	r7, #0
        i32FracPart = (i32Significand & 0x00FFFFFF) >> -(iExp2 + 1);
   10e1c:	fa40 f405 	asr.w	r4, r0, r5
    if (unFloatValue.I32 < 0)
   10e20:	db27      	blt.n	10e72 <am_util_stdio_vsprintf+0x117e>
   10e22:	4643      	mov	r3, r8
        *pcBuf++ = '0';
   10e24:	f04f 0030 	mov.w	r0, #48	; 0x30
   10e28:	7018      	strb	r0, [r3, #0]
   10e2a:	1c5d      	adds	r5, r3, #1
   10e2c:	e5f8      	b.n	10a20 <am_util_stdio_vsprintf+0xd2c>
                    iWidth -= ndigits_in_i64(ui64Val);
   10e2e:	1b3f      	subs	r7, r7, r4
                    bNeg = false;
   10e30:	2400      	movs	r4, #0
   10e32:	941b      	str	r4, [sp, #108]	; 0x6c
   10e34:	e515      	b.n	10862 <am_util_stdio_vsprintf+0xb6e>
    if (i32IntPart == 0)
   10e36:	4643      	mov	r3, r8
    i32FracPart = 0;
   10e38:	2400      	movs	r4, #0
        if (i32IntPart > 0)
   10e3a:	2800      	cmp	r0, #0
   10e3c:	dc37      	bgt.n	10eae <am_util_stdio_vsprintf+0x11ba>
            *pcBuf++ = '-';
   10e3e:	1c5d      	adds	r5, r3, #1
   10e40:	272d      	movs	r7, #45	; 0x2d
            uint64_to_str(-i32IntPart, pcBuf);
   10e42:	4240      	negs	r0, r0
   10e44:	17c1      	asrs	r1, r0, #31
   10e46:	462a      	mov	r2, r5
            *pcBuf++ = '-';
   10e48:	701f      	strb	r7, [r3, #0]
            uint64_to_str(-i32IntPart, pcBuf);
   10e4a:	f7fe fe55 	bl	faf8 <uint64_to_str>
   10e4e:	e5e1      	b.n	10a14 <am_util_stdio_vsprintf+0xd20>
        *pcBuf++ = '-';
   10e50:	f04f 0e2d 	mov.w	lr, #45	; 0x2d
   10e54:	f888 e000 	strb.w	lr, [r8]
   10e58:	f108 0301 	add.w	r3, r8, #1
    if (i32IntPart == 0)
   10e5c:	bb78      	cbnz	r0, 10ebe <am_util_stdio_vsprintf+0x11ca>
    *pcBuf++ = '.';
   10e5e:	272e      	movs	r7, #46	; 0x2e
        *pcBuf++ = '0';
   10e60:	f04f 0030 	mov.w	r0, #48	; 0x30
   10e64:	f888 0001 	strb.w	r0, [r8, #1]
    *pcBuf++ = '.';
   10e68:	f888 7002 	strb.w	r7, [r8, #2]
        *pcBuf++ = '0';
   10e6c:	f108 0502 	add.w	r5, r8, #2
   10e70:	e59e      	b.n	109b0 <am_util_stdio_vsprintf+0xcbc>
        *pcBuf++ = '-';
   10e72:	f04f 0c2d 	mov.w	ip, #45	; 0x2d
   10e76:	f888 c000 	strb.w	ip, [r8]
   10e7a:	f108 0301 	add.w	r3, r8, #1
   10e7e:	e7d1      	b.n	10e24 <am_util_stdio_vsprintf+0x1130>
   10e80:	272d      	movs	r7, #45	; 0x2d
   10e82:	f888 7000 	strb.w	r7, [r8]
   10e86:	f108 0301 	add.w	r3, r8, #1
    if (i32IntPart == 0)
   10e8a:	2800      	cmp	r0, #0
   10e8c:	d0ca      	beq.n	10e24 <am_util_stdio_vsprintf+0x1130>
   10e8e:	e7d4      	b.n	10e3a <am_util_stdio_vsprintf+0x1146>
   10e90:	f04f 0e00 	mov.w	lr, #0
   10e94:	e535      	b.n	10902 <am_util_stdio_vsprintf+0xc0e>
                    *pcBuftmp += 1;
   10e96:	3101      	adds	r1, #1
   10e98:	7019      	strb	r1, [r3, #0]
   10e9a:	e58f      	b.n	109bc <am_util_stdio_vsprintf+0xcc8>
    int iNDigits = ui64Val ? 0 : 1;
   10e9c:	460b      	mov	r3, r1
   10e9e:	4301      	orrs	r1, r0
   10ea0:	4602      	mov	r2, r0
   10ea2:	bf0c      	ite	eq
   10ea4:	2401      	moveq	r4, #1
   10ea6:	2400      	movne	r4, #0
                    bNeg = true;
   10ea8:	2001      	movs	r0, #1
   10eaa:	f7ff b906 	b.w	100ba <am_util_stdio_vsprintf+0x3c6>
        if (i32IntPart > 0)
   10eae:	461d      	mov	r5, r3
   10eb0:	e5ac      	b.n	10a0c <am_util_stdio_vsprintf+0xd18>
                iVal = uint64_to_str(ui64Val, pcBuf);
   10eb2:	4642      	mov	r2, r8
   10eb4:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
   10eb8:	f7fe fe1e 	bl	faf8 <uint64_to_str>
   10ebc:	e4b4      	b.n	10828 <am_util_stdio_vsprintf+0xb34>
    i32FracPart = 0;
   10ebe:	2400      	movs	r4, #0
   10ec0:	e7bb      	b.n	10e3a <am_util_stdio_vsprintf+0x1146>
   10ec2:	f1ca 0430 	rsb	r4, sl, #48	; 0x30
   10ec6:	7832      	ldrb	r2, [r6, #0]
   10ec8:	f7fe bf7c 	b.w	fdc4 <am_util_stdio_vsprintf+0xd0>
        bLower = bLongLong = false;
   10ecc:	f04f 0c00 	mov.w	ip, #0
   10ed0:	e747      	b.n	10d62 <am_util_stdio_vsprintf+0x106e>
   10ed2:	bf00      	nop
   10ed4:	003f2e3f 	.word	0x003f2e3f
   10ed8:	00302e30 	.word	0x00302e30
   10edc:	00232e23 	.word	0x00232e23

00010ee0 <am_util_stdio_sprintf>:
//! @return uint32_t representing the number of characters printed.
//
//******************************************************************************
uint32_t
am_util_stdio_sprintf(char *pcBuf, const char *pcFmt, ...)
{
   10ee0:	b40e      	push	{r1, r2, r3}
   10ee2:	b500      	push	{lr}
   10ee4:	b082      	sub	sp, #8
   10ee6:	aa03      	add	r2, sp, #12
   10ee8:	f852 1b04 	ldr.w	r1, [r2], #4
    uint32_t ui32CharCnt;

    va_list pArgs;
    va_start(pArgs, pcFmt);
   10eec:	9201      	str	r2, [sp, #4]
    ui32CharCnt = am_util_stdio_vsprintf(pcBuf, pcFmt, pArgs);
   10eee:	f7fe ff01 	bl	fcf4 <am_util_stdio_vsprintf>
    va_end(pArgs);

    return ui32CharCnt;
}
   10ef2:	b002      	add	sp, #8
   10ef4:	f85d eb04 	ldr.w	lr, [sp], #4
   10ef8:	b003      	add	sp, #12
   10efa:	4770      	bx	lr

00010efc <am_util_stdio_printf>:
//! @return uint32_t representing the number of characters printed.
//
// *****************************************************************************
uint32_t
am_util_stdio_printf(const char *pcFmt, ...)
{
   10efc:	b40f      	push	{r0, r1, r2, r3}
   10efe:	b530      	push	{r4, r5, lr}
   10f00:	b083      	sub	sp, #12
   10f02:	aa06      	add	r2, sp, #24
    //
    // Convert to the desired string.
    //
    va_list pArgs;
    va_start(pArgs, pcFmt);
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
   10f04:	4c08      	ldr	r4, [pc, #32]	; (10f28 <am_util_stdio_printf+0x2c>)
{
   10f06:	f852 1b04 	ldr.w	r1, [r2], #4
    va_start(pArgs, pcFmt);
   10f0a:	9201      	str	r2, [sp, #4]
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
   10f0c:	4620      	mov	r0, r4
   10f0e:	f7fe fef1 	bl	fcf4 <am_util_stdio_vsprintf>
    va_end(pArgs);

    //
    // This is where we print the buffer to the configured interface.
    //
    g_pfnCharPrint(g_prfbuf);
   10f12:	4b06      	ldr	r3, [pc, #24]	; (10f2c <am_util_stdio_printf+0x30>)
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
   10f14:	4605      	mov	r5, r0
    g_pfnCharPrint(g_prfbuf);
   10f16:	6819      	ldr	r1, [r3, #0]
   10f18:	4620      	mov	r0, r4
   10f1a:	4788      	blx	r1

    //
    // return the number of characters printed.
    //
    return ui32NumChars;
}
   10f1c:	4628      	mov	r0, r5
   10f1e:	b003      	add	sp, #12
   10f20:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   10f24:	b004      	add	sp, #16
   10f26:	4770      	bx	lr
   10f28:	1000106c 	.word	0x1000106c
   10f2c:	10001578 	.word	0x10001578

00010f30 <am_util_stdio_terminal_clear>:
    // left corner.
    // We'll first print a number of spaces, which helps get the ITM in sync
    // with AM Flash, especially after a reset event or a system clock
    // frequency change.
    //
    am_util_stdio_printf("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
   10f30:	4801      	ldr	r0, [pc, #4]	; (10f38 <am_util_stdio_terminal_clear+0x8>)
   10f32:	f7ff bfe3 	b.w	10efc <am_util_stdio_printf>
   10f36:	bf00      	nop
   10f38:	000132a0 	.word	0x000132a0

00010f3c <am_bsp_uart_string_print>:
//! @return None.
//
//*****************************************************************************
void
am_bsp_uart_string_print(char *pcString)
{
   10f3c:	b510      	push	{r4, lr}
   10f3e:	b086      	sub	sp, #24
    uint32_t ui32BytesWritten = 0;

    //
    // Measure the length of the string.
    //
    while (pcString[ui32StrLen] != 0)
   10f40:	7804      	ldrb	r4, [r0, #0]
    uint32_t ui32BytesWritten = 0;
   10f42:	2300      	movs	r3, #0
   10f44:	9300      	str	r3, [sp, #0]
    while (pcString[ui32StrLen] != 0)
   10f46:	b134      	cbz	r4, 10f56 <am_bsp_uart_string_print+0x1a>
   10f48:	461c      	mov	r4, r3
   10f4a:	4601      	mov	r1, r0
   10f4c:	f811 2f01 	ldrb.w	r2, [r1, #1]!
    {
        ui32StrLen++;
   10f50:	3401      	adds	r4, #1
    while (pcString[ui32StrLen] != 0)
   10f52:	2a00      	cmp	r2, #0
   10f54:	d1fa      	bne.n	10f4c <am_bsp_uart_string_print+0x10>
        .ui32NumBytes = ui32StrLen,
        .ui32TimeoutMs = AM_HAL_UART_WAIT_FOREVER,
        .pui32BytesTransferred = &ui32BytesWritten,
    };

    am_hal_uart_transfer(g_sCOMUART, &sUartWrite);
   10f56:	4b0a      	ldr	r3, [pc, #40]	; (10f80 <am_bsp_uart_string_print+0x44>)
    const am_hal_uart_transfer_t sUartWrite =
   10f58:	9002      	str	r0, [sp, #8]
   10f5a:	2200      	movs	r2, #0
    am_hal_uart_transfer(g_sCOMUART, &sUartWrite);
   10f5c:	6818      	ldr	r0, [r3, #0]
    const am_hal_uart_transfer_t sUartWrite =
   10f5e:	9403      	str	r4, [sp, #12]
   10f60:	f04f 33ff 	mov.w	r3, #4294967295
    am_hal_uart_transfer(g_sCOMUART, &sUartWrite);
   10f64:	a901      	add	r1, sp, #4
    const am_hal_uart_transfer_t sUartWrite =
   10f66:	9201      	str	r2, [sp, #4]
   10f68:	9304      	str	r3, [sp, #16]
   10f6a:	f8cd d014 	str.w	sp, [sp, #20]
    am_hal_uart_transfer(g_sCOMUART, &sUartWrite);
   10f6e:	f000 fffb 	bl	11f68 <am_hal_uart_transfer>

    if (ui32BytesWritten != ui32StrLen)
   10f72:	9800      	ldr	r0, [sp, #0]
   10f74:	42a0      	cmp	r0, r4
   10f76:	d000      	beq.n	10f7a <am_bsp_uart_string_print+0x3e>
   10f78:	e7fe      	b.n	10f78 <am_bsp_uart_string_print+0x3c>
        //
        // Couldn't send the whole string!!
        //
        while(1);
    }
} // am_bsp_uart_string_print()
   10f7a:	b006      	add	sp, #24
   10f7c:	bd10      	pop	{r4, pc}
   10f7e:	bf00      	nop
   10f80:	1000116c 	.word	0x1000116c

00010f84 <am_bsp_low_power_init>:
{
   10f84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    am_hal_itm_disable();
   10f86:	f000 fc3d 	bl	11804 <am_hal_itm_disable>
    am_util_stdio_printf_init(0);
   10f8a:	2000      	movs	r0, #0
   10f8c:	f7fe feac 	bl	fce8 <am_util_stdio_printf_init>
    am_hal_gpio_pinconfig(AM_BSP_GPIO_ITM_SWO, g_AM_HAL_GPIO_DISABLE);
   10f90:	4b12      	ldr	r3, [pc, #72]	; (10fdc <am_bsp_low_power_init+0x58>)
   10f92:	4f13      	ldr	r7, [pc, #76]	; (10fe0 <am_bsp_low_power_init+0x5c>)
   10f94:	6819      	ldr	r1, [r3, #0]
   10f96:	2029      	movs	r0, #41	; 0x29
   10f98:	f000 faa6 	bl	114e8 <am_hal_gpio_pinconfig>
    am_hal_pwrctrl_low_power_init();
   10f9c:	f000 fdbc 	bl	11b18 <am_hal_pwrctrl_low_power_init>
    am_hal_rtc_osc_select(AM_HAL_RTC_OSC_LFRC);
   10fa0:	2001      	movs	r0, #1
   10fa2:	f000 fdf7 	bl	11b94 <am_hal_rtc_osc_select>
    am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_XTAL_STOP, 0);
   10fa6:	2100      	movs	r1, #0
   10fa8:	2003      	movs	r0, #3
   10faa:	f000 f907 	bl	111bc <am_hal_clkgen_control>
    am_hal_rtc_osc_disable();
   10fae:	f000 fdfd 	bl	11bac <am_hal_rtc_osc_disable>
   10fb2:	480c      	ldr	r0, [pc, #48]	; (10fe4 <am_bsp_low_power_init+0x60>)
        am_hal_gpio_pinconfig(ui32GPIONumber, g_AM_HAL_GPIO_OUTPUT);
   10fb4:	6806      	ldr	r6, [r0, #0]
    for (ux = 0; ux < AM_BSP_NUM_LEDS; ux++)
   10fb6:	2400      	movs	r4, #0
        ui32GPIONumber = am_bsp_psLEDs[ux].ui32GPIONumber;
   10fb8:	f857 5034 	ldr.w	r5, [r7, r4, lsl #3]
        am_hal_gpio_pinconfig(ui32GPIONumber, g_AM_HAL_GPIO_OUTPUT);
   10fbc:	4631      	mov	r1, r6
   10fbe:	4628      	mov	r0, r5
   10fc0:	f000 fa92 	bl	114e8 <am_hal_gpio_pinconfig>
        am_hal_gpio_state_write(ui32GPIONumber, AM_HAL_GPIO_OUTPUT_TRISTATE_DISABLE);
   10fc4:	2103      	movs	r1, #3
   10fc6:	4628      	mov	r0, r5
   10fc8:	f000 fbd0 	bl	1176c <am_hal_gpio_state_write>
    for (ux = 0; ux < AM_BSP_NUM_LEDS; ux++)
   10fcc:	3401      	adds	r4, #1
        am_hal_gpio_state_write(ui32GPIONumber, AM_HAL_GPIO_OUTPUT_CLEAR);
   10fce:	4628      	mov	r0, r5
   10fd0:	2100      	movs	r1, #0
   10fd2:	f000 fbcb 	bl	1176c <am_hal_gpio_state_write>
    for (ux = 0; ux < AM_BSP_NUM_LEDS; ux++)
   10fd6:	2c05      	cmp	r4, #5
   10fd8:	d1ee      	bne.n	10fb8 <am_bsp_low_power_init+0x34>
} // am_bsp_low_power_init()
   10fda:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   10fdc:	000132e8 	.word	0x000132e8
   10fe0:	1000100c 	.word	0x1000100c
   10fe4:	000132ec 	.word	0x000132ec

00010fe8 <am_bsp_uart_printf_enable>:
// Initialize and configure the UART
//
//*****************************************************************************
void
am_bsp_uart_printf_enable(void)
{
   10fe8:	b510      	push	{r4, lr}
    //
    // Initialize, power up, and configure the communication UART. Use the
    // custom configuration if it was provided. Otherwise, just use the default
    // configuration.
    //
    am_hal_uart_initialize(AM_BSP_UART_PRINT_INST, &g_sCOMUART);
   10fea:	4c10      	ldr	r4, [pc, #64]	; (1102c <am_bsp_uart_printf_enable+0x44>)
    g_ui32PrintInterface = AM_BSP_PRINT_INFC_UART0;
   10fec:	4b10      	ldr	r3, [pc, #64]	; (11030 <am_bsp_uart_printf_enable+0x48>)
    am_hal_uart_initialize(AM_BSP_UART_PRINT_INST, &g_sCOMUART);
   10fee:	4621      	mov	r1, r4
    g_ui32PrintInterface = AM_BSP_PRINT_INFC_UART0;
   10ff0:	2202      	movs	r2, #2
    am_hal_uart_initialize(AM_BSP_UART_PRINT_INST, &g_sCOMUART);
   10ff2:	2000      	movs	r0, #0
    g_ui32PrintInterface = AM_BSP_PRINT_INFC_UART0;
   10ff4:	601a      	str	r2, [r3, #0]
    am_hal_uart_initialize(AM_BSP_UART_PRINT_INST, &g_sCOMUART);
   10ff6:	f000 fe1f 	bl	11c38 <am_hal_uart_initialize>
    am_hal_uart_power_control(g_sCOMUART, AM_HAL_SYSCTRL_WAKE, false);
   10ffa:	2200      	movs	r2, #0
   10ffc:	4611      	mov	r1, r2
   10ffe:	6820      	ldr	r0, [r4, #0]
   11000:	f000 fe56 	bl	11cb0 <am_hal_uart_power_control>
    am_hal_uart_configure(g_sCOMUART, &g_sBspUartConfig);
   11004:	6820      	ldr	r0, [r4, #0]
   11006:	490b      	ldr	r1, [pc, #44]	; (11034 <am_bsp_uart_printf_enable+0x4c>)

    //
    // Enable the UART pins.
    //
    am_hal_gpio_pinconfig(AM_BSP_GPIO_COM_UART_TX, g_AM_BSP_GPIO_COM_UART_TX);
    am_hal_gpio_pinconfig(AM_BSP_GPIO_COM_UART_RX, g_AM_BSP_GPIO_COM_UART_RX);
   11008:	4c0b      	ldr	r4, [pc, #44]	; (11038 <am_bsp_uart_printf_enable+0x50>)
    am_hal_uart_configure(g_sCOMUART, &g_sBspUartConfig);
   1100a:	f000 fec3 	bl	11d94 <am_hal_uart_configure>
    am_hal_gpio_pinconfig(AM_BSP_GPIO_COM_UART_TX, g_AM_BSP_GPIO_COM_UART_TX);
   1100e:	490b      	ldr	r1, [pc, #44]	; (1103c <am_bsp_uart_printf_enable+0x54>)
   11010:	2016      	movs	r0, #22
   11012:	6809      	ldr	r1, [r1, #0]
   11014:	f000 fa68 	bl	114e8 <am_hal_gpio_pinconfig>
    am_hal_gpio_pinconfig(AM_BSP_GPIO_COM_UART_RX, g_AM_BSP_GPIO_COM_UART_RX);
   11018:	6821      	ldr	r1, [r4, #0]
   1101a:	2017      	movs	r0, #23
   1101c:	f000 fa64 	bl	114e8 <am_hal_gpio_pinconfig>

    //
    // Register the BSP print function to the STDIO driver.
    //
    am_util_stdio_printf_init(am_bsp_uart_string_print);
   11020:	4807      	ldr	r0, [pc, #28]	; (11040 <am_bsp_uart_printf_enable+0x58>)
} // am_bsp_uart_printf_enable()
   11022:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    am_util_stdio_printf_init(am_bsp_uart_string_print);
   11026:	f7fe be5f 	b.w	fce8 <am_util_stdio_printf_init>
   1102a:	bf00      	nop
   1102c:	1000116c 	.word	0x1000116c
   11030:	10001170 	.word	0x10001170
   11034:	000132b4 	.word	0x000132b4
   11038:	000132dc 	.word	0x000132dc
   1103c:	000132e0 	.word	0x000132e0
   11040:	00010f3d 	.word	0x00010f3d

00011044 <am_bsp_uart_printf_disable>:
// Disable the UART
//
//*****************************************************************************
void
am_bsp_uart_printf_disable(void)
{
   11044:	b510      	push	{r4, lr}
    //
    // Make sure the UART has finished sending everything it's going to send.
    //
    am_hal_uart_tx_flush(g_sCOMUART);
   11046:	4c0d      	ldr	r4, [pc, #52]	; (1107c <am_bsp_uart_printf_disable+0x38>)
   11048:	6820      	ldr	r0, [r4, #0]
   1104a:	f001 fc11 	bl	12870 <am_hal_uart_tx_flush>

    //
    // Detach the UART from the stdio driver.
    //
    am_util_stdio_printf_init(0);
   1104e:	2000      	movs	r0, #0
   11050:	f7fe fe4a 	bl	fce8 <am_util_stdio_printf_init>

    //
    // Power down the UART, and surrender the handle.
    //
    am_hal_uart_power_control(g_sCOMUART, AM_HAL_SYSCTRL_DEEPSLEEP, false);
   11054:	2200      	movs	r2, #0
   11056:	2102      	movs	r1, #2
   11058:	6820      	ldr	r0, [r4, #0]
   1105a:	f000 fe29 	bl	11cb0 <am_hal_uart_power_control>
    am_hal_uart_deinitialize(g_sCOMUART);
   1105e:	6820      	ldr	r0, [r4, #0]
   11060:	f000 fe12 	bl	11c88 <am_hal_uart_deinitialize>

    //
    // Disable the UART pins.
    //
    am_hal_gpio_pinconfig(AM_BSP_GPIO_COM_UART_TX, g_AM_HAL_GPIO_DISABLE);
   11064:	4b06      	ldr	r3, [pc, #24]	; (11080 <am_bsp_uart_printf_disable+0x3c>)
   11066:	681c      	ldr	r4, [r3, #0]
   11068:	2016      	movs	r0, #22
   1106a:	4621      	mov	r1, r4
   1106c:	f000 fa3c 	bl	114e8 <am_hal_gpio_pinconfig>
    am_hal_gpio_pinconfig(AM_BSP_GPIO_COM_UART_RX, g_AM_HAL_GPIO_DISABLE);
   11070:	4621      	mov	r1, r4
   11072:	2017      	movs	r0, #23

} // am_bsp_uart_printf_disable()
   11074:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    am_hal_gpio_pinconfig(AM_BSP_GPIO_COM_UART_RX, g_AM_HAL_GPIO_DISABLE);
   11078:	f000 ba36 	b.w	114e8 <am_hal_gpio_pinconfig>
   1107c:	1000116c 	.word	0x1000116c
   11080:	000132e8 	.word	0x000132e8

00011084 <am_hal_cachectrl_config>:
//  Configure the cache with given and recommended settings, but do not enable.
//
//*****************************************************************************
uint32_t
am_hal_cachectrl_config(const am_hal_cachectrl_config_t *psConfig)
{
   11084:	b530      	push	{r4, r5, lr}
   11086:	b083      	sub	sp, #12
   11088:	4605      	mov	r5, r0
    // accomplish that is to shut down the ID bits, leaving the cache enabled.
    // Once the instr and data caches have been disabled, we can safely set
    // any new configuration, including disabling the controller.
    //
#if AM_CMSIS_REGS
    AM_CRITICAL_BEGIN
   1108a:	f000 fbb3 	bl	117f4 <am_hal_interrupt_master_disable>
    CACHECTRL->CACHECFG &=
   1108e:	4c11      	ldr	r4, [pc, #68]	; (110d4 <am_hal_cachectrl_config+0x50>)
    AM_CRITICAL_BEGIN
   11090:	9001      	str	r0, [sp, #4]
    CACHECTRL->CACHECFG &=
   11092:	6823      	ldr	r3, [r4, #0]
   11094:	f423 7040 	bic.w	r0, r3, #768	; 0x300
   11098:	6020      	str	r0, [r4, #0]
        ~(CACHECTRL_CACHECFG_DCACHE_ENABLE_Msk  |
          CACHECTRL_CACHECFG_ICACHE_ENABLE_Msk);
    AM_CRITICAL_END
   1109a:	9801      	ldr	r0, [sp, #4]
   1109c:	f000 fbae 	bl	117fc <am_hal_interrupt_master_set>
        _VAL2FLD(CACHECTRL_CACHECFG_ENABLE, 0)                              |
        _VAL2FLD(CACHECTRL_CACHECFG_CACHE_CLKGATE, 1)                       |
        _VAL2FLD(CACHECTRL_CACHECFG_CACHE_LS, 0)                            |
        _VAL2FLD(CACHECTRL_CACHECFG_DATA_CLKGATE, 1)                        |
        _VAL2FLD(CACHECTRL_CACHECFG_ENABLE_MONITOR, 0)                      |
        _VAL2FLD(CACHECTRL_CACHECFG_LRU, psConfig->bLRU)                    |
   110a0:	78eb      	ldrb	r3, [r5, #3]
        _VAL2FLD(CACHECTRL_CACHECFG_CONFIG, psConfig->eDescript)            |
   110a2:	7828      	ldrb	r0, [r5, #0]
        ((psConfig->eEnableNCregions << CACHECTRL_CACHECFG_ENABLE_NC0_Pos) &
   110a4:	78a9      	ldrb	r1, [r5, #2]
            (CACHECTRL_CACHECFG_ENABLE_NC1_Msk      |
             CACHECTRL_CACHECFG_ENABLE_NC0_Msk))                            |
        ((psConfig->eMode << CACHECTRL_CACHECFG_ICACHE_ENABLE_Pos) &
   110a6:	786a      	ldrb	r2, [r5, #1]
        _VAL2FLD(CACHECTRL_CACHECFG_CONFIG, psConfig->eDescript)            |
   110a8:	0100      	lsls	r0, r0, #4
        _VAL2FLD(CACHECTRL_CACHECFG_LRU, psConfig->bLRU)                    |
   110aa:	005d      	lsls	r5, r3, #1
   110ac:	f005 0302 	and.w	r3, r5, #2
        _VAL2FLD(CACHECTRL_CACHECFG_CONFIG, psConfig->eDescript)            |
   110b0:	b2c5      	uxtb	r5, r0
        _VAL2FLD(CACHECTRL_CACHECFG_LRU, psConfig->bLRU)                    |
   110b2:	432b      	orrs	r3, r5
             CACHECTRL_CACHECFG_ENABLE_NC0_Msk))                            |
   110b4:	f443 1080 	orr.w	r0, r3, #1048576	; 0x100000
        ((psConfig->eEnableNCregions << CACHECTRL_CACHECFG_ENABLE_NC0_Pos) &
   110b8:	0089      	lsls	r1, r1, #2
             CACHECTRL_CACHECFG_ENABLE_NC0_Msk))                            |
   110ba:	f440 6380 	orr.w	r3, r0, #1024	; 0x400
        ((psConfig->eEnableNCregions << CACHECTRL_CACHECFG_ENABLE_NC0_Pos) &
   110be:	f001 050c 	and.w	r5, r1, #12
        ((psConfig->eMode << CACHECTRL_CACHECFG_ICACHE_ENABLE_Pos) &
   110c2:	0212      	lsls	r2, r2, #8
   110c4:	f402 7040 	and.w	r0, r2, #768	; 0x300
             CACHECTRL_CACHECFG_ENABLE_NC0_Msk))                            |
   110c8:	432b      	orrs	r3, r5
   110ca:	4303      	orrs	r3, r0

#endif // AM_CMSIS_REGS

    return AM_HAL_STATUS_SUCCESS;

} // am_hal_cachectrl_enable()
   110cc:	2000      	movs	r0, #0
    CACHECTRL->CACHECFG =
   110ce:	6023      	str	r3, [r4, #0]
} // am_hal_cachectrl_enable()
   110d0:	b003      	add	sp, #12
   110d2:	bd30      	pop	{r4, r5, pc}
   110d4:	40018000 	.word	0x40018000

000110d8 <am_hal_cachectrl_enable>:
//*****************************************************************************
uint32_t
am_hal_cachectrl_enable(void)
{
#if AM_CMSIS_REGS
    CACHECTRL->CACHECFG |= _VAL2FLD(CACHECTRL_CACHECFG_ENABLE, 1);
   110d8:	4a03      	ldr	r2, [pc, #12]	; (110e8 <am_hal_cachectrl_enable+0x10>)
   110da:	6813      	ldr	r3, [r2, #0]
   110dc:	f043 0001 	orr.w	r0, r3, #1
   110e0:	6010      	str	r0, [r2, #0]
#else // AM_CMSIS_REGS
    AM_REG(CACHECTRL, CACHECFG) |= AM_REG_CACHECTRL_CACHECFG_ENABLE(1);
#endif // AM_CMSIS_REGS

    return AM_HAL_STATUS_SUCCESS;
} // am_hal_cachectrl_enable()
   110e2:	2000      	movs	r0, #0
   110e4:	4770      	bx	lr
   110e6:	bf00      	nop
   110e8:	40018000 	.word	0x40018000

000110ec <am_hal_cachectrl_control>:
//  Select the cache configuration type.
//
//*****************************************************************************
uint32_t
am_hal_cachectrl_control(am_hal_cachectrl_control_e eControl, void *pArgs)
{
   110ec:	b500      	push	{lr}
    uint32_t ui32Val;
    uint32_t ui32SetMask = 0;

#if AM_CMSIS_REGS
    switch ( eControl )
   110ee:	3801      	subs	r0, #1
{
   110f0:	b087      	sub	sp, #28
    switch ( eControl )
   110f2:	280a      	cmp	r0, #10
   110f4:	d836      	bhi.n	11164 <am_hal_cachectrl_control+0x78>
   110f6:	e8df f000 	tbb	[pc, r0]
   110fa:	3937      	.short	0x3937
   110fc:	100e063f 	.word	0x100e063f
   11100:	25181512 	.word	0x25181512
   11104:	32          	.byte	0x32
   11105:	00          	.byte	0x00
        case AM_HAL_CACHECTRL_CONTROL_FLASH_ALL_SLEEP_ENABLE:
            ui32SetMask = CACHECTRL_CTRL_FLASH0_SLM_ENABLE_Msk      |
                          CACHECTRL_CTRL_FLASH1_SLM_ENABLE_Msk;
            break;
        case AM_HAL_CACHECTRL_CONTROL_FLASH_ALL_SLEEP_DISABLE:
            ui32SetMask = CACHECTRL_CTRL_FLASH0_SLM_DISABLE_Msk     |
   11106:	f44f 7108 	mov.w	r1, #544	; 0x220
    // Important note - setting of an enable and disable simultanously has
    // unpredicable results.
    //
    if ( ui32SetMask )
    {
        CACHECTRL->CTRL = ui32SetMask;
   1110a:	4b2a      	ldr	r3, [pc, #168]	; (111b4 <am_hal_cachectrl_control+0xc8>)
    {
        AM_REG(CACHECTRL, CTRL) = ui32SetMask;
    }
#endif // AM_CMSIS_REGS

    return AM_HAL_STATUS_SUCCESS;
   1110c:	2000      	movs	r0, #0
        CACHECTRL->CTRL = ui32SetMask;
   1110e:	6099      	str	r1, [r3, #8]

} // am_hal_cachectrl_control()
   11110:	b007      	add	sp, #28
   11112:	f85d fb04 	ldr.w	pc, [sp], #4
            ui32SetMask = CACHECTRL_CTRL_FLASH0_SLM_ENABLE_Msk;
   11116:	2140      	movs	r1, #64	; 0x40
            break;
   11118:	e7f7      	b.n	1110a <am_hal_cachectrl_control+0x1e>
            ui32SetMask = CACHECTRL_CTRL_FLASH0_SLM_DISABLE_Msk;
   1111a:	2120      	movs	r1, #32
            break;
   1111c:	e7f5      	b.n	1110a <am_hal_cachectrl_control+0x1e>
            ui32SetMask = CACHECTRL_CTRL_FLASH1_SLM_ENABLE_Msk;
   1111e:	f44f 6180 	mov.w	r1, #1024	; 0x400
            break;
   11122:	e7f2      	b.n	1110a <am_hal_cachectrl_control+0x1e>
            ui32SetMask = CACHECTRL_CTRL_FLASH1_SLM_DISABLE_Msk;
   11124:	f44f 7100 	mov.w	r1, #512	; 0x200
            break;
   11128:	e7ef      	b.n	1110a <am_hal_cachectrl_control+0x1e>
            AM_CRITICAL_BEGIN
   1112a:	f000 fb63 	bl	117f4 <am_hal_interrupt_master_disable>
            CACHECTRL->CACHECFG |= CACHECTRL_CACHECFG_ENABLE_MONITOR_Msk;
   1112e:	4921      	ldr	r1, [pc, #132]	; (111b4 <am_hal_cachectrl_control+0xc8>)
            AM_CRITICAL_BEGIN
   11130:	9003      	str	r0, [sp, #12]
            CACHECTRL->CACHECFG |= CACHECTRL_CACHECFG_ENABLE_MONITOR_Msk;
   11132:	6808      	ldr	r0, [r1, #0]
   11134:	f040 7380 	orr.w	r3, r0, #16777216	; 0x1000000
   11138:	600b      	str	r3, [r1, #0]
            AM_CRITICAL_END
   1113a:	9803      	ldr	r0, [sp, #12]
   1113c:	f000 fb5e 	bl	117fc <am_hal_interrupt_master_set>
    return AM_HAL_STATUS_SUCCESS;
   11140:	2000      	movs	r0, #0
   11142:	e7e5      	b.n	11110 <am_hal_cachectrl_control+0x24>
            AM_CRITICAL_BEGIN
   11144:	f000 fb56 	bl	117f4 <am_hal_interrupt_master_disable>
            CACHECTRL->CACHECFG &= ~CACHECTRL_CACHECFG_ENABLE_MONITOR_Msk;
   11148:	491a      	ldr	r1, [pc, #104]	; (111b4 <am_hal_cachectrl_control+0xc8>)
            AM_CRITICAL_BEGIN
   1114a:	9004      	str	r0, [sp, #16]
            CACHECTRL->CACHECFG &= ~CACHECTRL_CACHECFG_ENABLE_MONITOR_Msk;
   1114c:	680b      	ldr	r3, [r1, #0]
   1114e:	f023 7280 	bic.w	r2, r3, #16777216	; 0x1000000
   11152:	600a      	str	r2, [r1, #0]
            AM_CRITICAL_END
   11154:	9804      	ldr	r0, [sp, #16]
   11156:	f000 fb51 	bl	117fc <am_hal_interrupt_master_set>
    return AM_HAL_STATUS_SUCCESS;
   1115a:	2000      	movs	r0, #0
   1115c:	e7d8      	b.n	11110 <am_hal_cachectrl_control+0x24>
            if ( ui32Val > CACHECTRL_FLASHCFG_LPMMODE_ALWAYS )
   1115e:	680b      	ldr	r3, [r1, #0]
   11160:	2b02      	cmp	r3, #2
   11162:	d90e      	bls.n	11182 <am_hal_cachectrl_control+0x96>
                return AM_HAL_STATUS_INVALID_ARG;
   11164:	2006      	movs	r0, #6
   11166:	e7d3      	b.n	11110 <am_hal_cachectrl_control+0x24>
            ui32SetMask = CACHECTRL_CTRL_INVALIDATE_Msk;
   11168:	2101      	movs	r1, #1
   1116a:	e7ce      	b.n	1110a <am_hal_cachectrl_control+0x1e>
            if ( !_FLD2VAL(CACHECTRL_CACHECFG_ENABLE_MONITOR, CACHECTRL->CACHECFG) )
   1116c:	4a11      	ldr	r2, [pc, #68]	; (111b4 <am_hal_cachectrl_control+0xc8>)
   1116e:	6810      	ldr	r0, [r2, #0]
   11170:	01c3      	lsls	r3, r0, #7
   11172:	d404      	bmi.n	1117e <am_hal_cachectrl_control+0x92>
                return AM_HAL_STATUS_INVALID_OPERATION;
   11174:	2007      	movs	r0, #7
   11176:	e7cb      	b.n	11110 <am_hal_cachectrl_control+0x24>
            ui32SetMask = CACHECTRL_CTRL_FLASH0_SLM_ENABLE_Msk      |
   11178:	f44f 6188 	mov.w	r1, #1088	; 0x440
   1117c:	e7c5      	b.n	1110a <am_hal_cachectrl_control+0x1e>
                ui32SetMask = CACHECTRL_CTRL_RESET_STAT_Msk;
   1117e:	2102      	movs	r1, #2
   11180:	e7c3      	b.n	1110a <am_hal_cachectrl_control+0x1e>
   11182:	9101      	str	r1, [sp, #4]
            AM_CRITICAL_BEGIN
   11184:	f000 fb36 	bl	117f4 <am_hal_interrupt_master_disable>
   11188:	4601      	mov	r1, r0
            ui32Val = am_hal_flash_load_ui32((uint32_t*)&CACHECTRL->FLASHCFG);
   1118a:	480b      	ldr	r0, [pc, #44]	; (111b8 <am_hal_cachectrl_control+0xcc>)
            AM_CRITICAL_BEGIN
   1118c:	9105      	str	r1, [sp, #20]
            ui32Val = am_hal_flash_load_ui32((uint32_t*)&CACHECTRL->FLASHCFG);
   1118e:	f000 f9a1 	bl	114d4 <am_hal_flash_load_ui32>
            ui32Val |= _VAL2FLD(CACHECTRL_FLASHCFG_LPMMODE, *((uint32_t*)pArgs));
   11192:	9a01      	ldr	r2, [sp, #4]
   11194:	6813      	ldr	r3, [r2, #0]
   11196:	031a      	lsls	r2, r3, #12
            ui32Val &= ~CACHECTRL_FLASHCFG_LPMMODE_Msk;
   11198:	f420 5140 	bic.w	r1, r0, #12288	; 0x3000
            ui32Val |= _VAL2FLD(CACHECTRL_FLASHCFG_LPMMODE, *((uint32_t*)pArgs));
   1119c:	f402 5040 	and.w	r0, r2, #12288	; 0x3000
            am_hal_flash_store_ui32((uint32_t*)&CACHECTRL->FLASHCFG, ui32Val);
   111a0:	4301      	orrs	r1, r0
   111a2:	4805      	ldr	r0, [pc, #20]	; (111b8 <am_hal_cachectrl_control+0xcc>)
   111a4:	f000 f99a 	bl	114dc <am_hal_flash_store_ui32>
            AM_CRITICAL_END
   111a8:	9805      	ldr	r0, [sp, #20]
   111aa:	f000 fb27 	bl	117fc <am_hal_interrupt_master_set>
    return AM_HAL_STATUS_SUCCESS;
   111ae:	2000      	movs	r0, #0
            break;
   111b0:	e7ae      	b.n	11110 <am_hal_cachectrl_control+0x24>
   111b2:	bf00      	nop
   111b4:	40018000 	.word	0x40018000
   111b8:	40018004 	.word	0x40018004

000111bc <am_hal_clkgen_control>:
am_hal_clkgen_control(am_hal_clkgen_control_e eControl, void *pArgs)
{
    uint32_t ui32Regval;

#if AM_CMSIS_REGS
    switch ( eControl )
   111bc:	2809      	cmp	r0, #9
   111be:	d852      	bhi.n	11266 <am_hal_clkgen_control+0xaa>
   111c0:	e8df f000 	tbb	[pc, r0]
   111c4:	2b21190d 	.word	0x2b21190d
   111c8:	51513d33 	.word	0x51513d33
   111cc:	0547      	.short	0x0547
            ui32Regval |= _VAL2FLD(CLKGEN_HFADJ_HFADJEN, CLKGEN_HFADJ_HFADJEN_EN);
            CLKGEN->HFADJ = ui32Regval;
            break;

        case AM_HAL_CLKGEN_CONTROL_HFADJ_DISABLE:
            CLKGEN->HFADJ_b.HFADJEN = 0;
   111ce:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000


    //
    // Return success status.
    //
    return AM_HAL_STATUS_SUCCESS;
   111d2:	2000      	movs	r0, #0
            CLKGEN->HFADJ_b.HFADJEN = 0;
   111d4:	6a1a      	ldr	r2, [r3, #32]
   111d6:	f36f 0200 	bfc	r2, #0, #1
   111da:	621a      	str	r2, [r3, #32]
            break;
   111dc:	4770      	bx	lr
            CLKGEN->CLKKEY         = CLKGEN_CLKKEY_CLKKEY_Key;
   111de:	f04f 2c40 	mov.w	ip, #1073758208	; 0x40004000
            CLKGEN->CCTRL          = CLKGEN_CCTRL_CORESEL_HFRC;
   111e2:	2100      	movs	r1, #0
            CLKGEN->CLKKEY         = CLKGEN_CLKKEY_CLKKEY_Key;
   111e4:	2047      	movs	r0, #71	; 0x47
   111e6:	f8cc 0014 	str.w	r0, [ip, #20]
            CLKGEN->CCTRL          = CLKGEN_CCTRL_CORESEL_HFRC;
   111ea:	f8cc 1018 	str.w	r1, [ip, #24]
    return AM_HAL_STATUS_SUCCESS;
   111ee:	4608      	mov	r0, r1
            CLKGEN->CLKKEY         = 0;
   111f0:	f8cc 1014 	str.w	r1, [ip, #20]
            break;
   111f4:	4770      	bx	lr
            CLKGEN->OCTRL         &= ~_VAL2FLD(CLKGEN_OCTRL_STOPXT,
   111f6:	f04f 2140 	mov.w	r1, #1073758208	; 0x40004000
    return AM_HAL_STATUS_SUCCESS;
   111fa:	2000      	movs	r0, #0
            CLKGEN->OCTRL         &= ~_VAL2FLD(CLKGEN_OCTRL_STOPXT,
   111fc:	68ca      	ldr	r2, [r1, #12]
   111fe:	f022 0301 	bic.w	r3, r2, #1
   11202:	60cb      	str	r3, [r1, #12]
            break;
   11204:	4770      	bx	lr
            CLKGEN->OCTRL         &= ~_VAL2FLD(CLKGEN_OCTRL_STOPRC,
   11206:	f04f 2c40 	mov.w	ip, #1073758208	; 0x40004000
    return AM_HAL_STATUS_SUCCESS;
   1120a:	2000      	movs	r0, #0
            CLKGEN->OCTRL         &= ~_VAL2FLD(CLKGEN_OCTRL_STOPRC,
   1120c:	f8dc 200c 	ldr.w	r2, [ip, #12]
   11210:	f022 0302 	bic.w	r3, r2, #2
   11214:	f8cc 300c 	str.w	r3, [ip, #12]
            break;
   11218:	4770      	bx	lr
            CLKGEN->OCTRL         |= _VAL2FLD(CLKGEN_OCTRL_STOPXT,
   1121a:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
    return AM_HAL_STATUS_SUCCESS;
   1121e:	2000      	movs	r0, #0
            CLKGEN->OCTRL         |= _VAL2FLD(CLKGEN_OCTRL_STOPXT,
   11220:	68d3      	ldr	r3, [r2, #12]
   11222:	f043 0101 	orr.w	r1, r3, #1
   11226:	60d1      	str	r1, [r2, #12]
            break;
   11228:	4770      	bx	lr
            CLKGEN->OCTRL         |= _VAL2FLD(CLKGEN_OCTRL_STOPRC,
   1122a:	f04f 2c40 	mov.w	ip, #1073758208	; 0x40004000
    return AM_HAL_STATUS_SUCCESS;
   1122e:	2000      	movs	r0, #0
            CLKGEN->OCTRL         |= _VAL2FLD(CLKGEN_OCTRL_STOPRC,
   11230:	f8dc 300c 	ldr.w	r3, [ip, #12]
   11234:	f043 0102 	orr.w	r1, r3, #2
   11238:	f8cc 100c 	str.w	r1, [ip, #12]
            break;
   1123c:	4770      	bx	lr
            CLKGEN->CLKKEY         = CLKGEN_CLKKEY_CLKKEY_Key;
   1123e:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
            CLKGEN->CLKKEY         = 0;
   11242:	2200      	movs	r2, #0
            CLKGEN->CLKKEY         = CLKGEN_CLKKEY_CLKKEY_Key;
   11244:	2047      	movs	r0, #71	; 0x47
            CLKGEN->CCTRL          = CLKGEN_CCTRL_CORESEL_HFRC_DIV2;
   11246:	2101      	movs	r1, #1
            CLKGEN->CLKKEY         = CLKGEN_CLKKEY_CLKKEY_Key;
   11248:	6158      	str	r0, [r3, #20]
            CLKGEN->CCTRL          = CLKGEN_CCTRL_CORESEL_HFRC_DIV2;
   1124a:	6199      	str	r1, [r3, #24]
    return AM_HAL_STATUS_SUCCESS;
   1124c:	4610      	mov	r0, r2
            CLKGEN->CLKKEY         = 0;
   1124e:	615a      	str	r2, [r3, #20]
            break;
   11250:	4770      	bx	lr
            if ( pArgs == 0 )
   11252:	b151      	cbz	r1, 1126a <am_hal_clkgen_control+0xae>
   11254:	6808      	ldr	r0, [r1, #0]
   11256:	f040 0101 	orr.w	r1, r0, #1
            CLKGEN->HFADJ = ui32Regval;
   1125a:	f04f 2c40 	mov.w	ip, #1073758208	; 0x40004000
    return AM_HAL_STATUS_SUCCESS;
   1125e:	2000      	movs	r0, #0
            CLKGEN->HFADJ = ui32Regval;
   11260:	f8cc 1020 	str.w	r1, [ip, #32]
            break;
   11264:	4770      	bx	lr
            return AM_HAL_STATUS_INVALID_ARG;
   11266:	2006      	movs	r0, #6
} // am_hal_clkgen_control()
   11268:	4770      	bx	lr
   1126a:	4901      	ldr	r1, [pc, #4]	; (11270 <am_hal_clkgen_control+0xb4>)
   1126c:	e7f5      	b.n	1125a <am_hal_clkgen_control+0x9e>
   1126e:	bf00      	nop
   11270:	0025b801 	.word	0x0025b801

00011274 <am_hal_flash_delay>:
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11274:	4b00      	ldr	r3, [pc, #0]	; (11278 <am_hal_flash_delay+0x4>)
   11276:	4718      	bx	r3
   11278:	0800009d 	.word	0x0800009d

0001127c <am_hal_flash_delay_status_check>:
//*****************************************************************************
uint32_t
am_hal_flash_delay_status_check(uint32_t ui32usMaxDelay, uint32_t ui32Address,
                                uint32_t ui32Mask, uint32_t ui32Value,
                                bool bIsEqual)
{
   1127c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   11280:	f89d e020 	ldrb.w	lr, [sp, #32]
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11284:	f8df 8248 	ldr.w	r8, [pc, #584]	; 114d0 <am_hal_flash_delay_status_check+0x254>
{
   11288:	4607      	mov	r7, r0
   1128a:	460c      	mov	r4, r1
   1128c:	4615      	mov	r5, r2
   1128e:	461e      	mov	r6, r3
   11290:	f1be 0f00 	cmp.w	lr, #0
   11294:	f000 808e 	beq.w	113b4 <am_hal_flash_delay_status_check+0x138>
   11298:	f010 0907 	ands.w	r9, r0, #7
   1129c:	d044      	beq.n	11328 <am_hal_flash_delay_status_check+0xac>
        //
        // Check the status
        //
        if ( bIsEqual )
        {
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   1129e:	680b      	ldr	r3, [r1, #0]
   112a0:	4013      	ands	r3, r2
   112a2:	429e      	cmp	r6, r3
   112a4:	f000 8083 	beq.w	113ae <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   112a8:	2001      	movs	r0, #1
   112aa:	47c0      	blx	r8
   112ac:	f1b9 0f01 	cmp.w	r9, #1
   112b0:	f107 37ff 	add.w	r7, r7, #4294967295
   112b4:	d038      	beq.n	11328 <am_hal_flash_delay_status_check+0xac>
   112b6:	f1b9 0f02 	cmp.w	r9, #2
   112ba:	d02e      	beq.n	1131a <am_hal_flash_delay_status_check+0x9e>
   112bc:	f1b9 0f03 	cmp.w	r9, #3
   112c0:	d024      	beq.n	1130c <am_hal_flash_delay_status_check+0x90>
   112c2:	f1b9 0f04 	cmp.w	r9, #4
   112c6:	d01a      	beq.n	112fe <am_hal_flash_delay_status_check+0x82>
   112c8:	f1b9 0f05 	cmp.w	r9, #5
   112cc:	d010      	beq.n	112f0 <am_hal_flash_delay_status_check+0x74>
   112ce:	f1b9 0f06 	cmp.w	r9, #6
   112d2:	d006      	beq.n	112e2 <am_hal_flash_delay_status_check+0x66>
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   112d4:	6820      	ldr	r0, [r4, #0]
   112d6:	4028      	ands	r0, r5
   112d8:	4286      	cmp	r6, r0
   112da:	d068      	beq.n	113ae <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   112dc:	2001      	movs	r0, #1
   112de:	47c0      	blx	r8
   112e0:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   112e2:	6821      	ldr	r1, [r4, #0]
   112e4:	4029      	ands	r1, r5
   112e6:	428e      	cmp	r6, r1
   112e8:	d061      	beq.n	113ae <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   112ea:	2001      	movs	r0, #1
   112ec:	47c0      	blx	r8
   112ee:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   112f0:	6822      	ldr	r2, [r4, #0]
   112f2:	402a      	ands	r2, r5
   112f4:	4296      	cmp	r6, r2
   112f6:	d05a      	beq.n	113ae <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   112f8:	2001      	movs	r0, #1
   112fa:	47c0      	blx	r8
   112fc:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   112fe:	6823      	ldr	r3, [r4, #0]
   11300:	402b      	ands	r3, r5
   11302:	429e      	cmp	r6, r3
   11304:	d053      	beq.n	113ae <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11306:	2001      	movs	r0, #1
   11308:	47c0      	blx	r8
   1130a:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   1130c:	6820      	ldr	r0, [r4, #0]
   1130e:	4028      	ands	r0, r5
   11310:	4286      	cmp	r6, r0
   11312:	d04c      	beq.n	113ae <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11314:	2001      	movs	r0, #1
   11316:	47c0      	blx	r8
   11318:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   1131a:	6821      	ldr	r1, [r4, #0]
   1131c:	4029      	ands	r1, r5
   1131e:	428e      	cmp	r6, r1
   11320:	d045      	beq.n	113ae <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11322:	2001      	movs	r0, #1
   11324:	3f01      	subs	r7, #1
   11326:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   11328:	6822      	ldr	r2, [r4, #0]
   1132a:	402a      	ands	r2, r5
   1132c:	4296      	cmp	r6, r2
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   1132e:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   11332:	d03c      	beq.n	113ae <am_hal_flash_delay_status_check+0x132>
            {
                return AM_HAL_STATUS_SUCCESS;
            }
        }

        if ( ui32usMaxDelay-- )
   11334:	2f00      	cmp	r7, #0
   11336:	f000 80c8 	beq.w	114ca <am_hal_flash_delay_status_check+0x24e>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   1133a:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   1133c:	6823      	ldr	r3, [r4, #0]
   1133e:	402b      	ands	r3, r5
   11340:	429e      	cmp	r6, r3
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11342:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   11346:	d032      	beq.n	113ae <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11348:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   1134a:	6821      	ldr	r1, [r4, #0]
   1134c:	4029      	ands	r1, r5
   1134e:	428e      	cmp	r6, r1
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11350:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   11354:	d02b      	beq.n	113ae <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11356:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   11358:	6822      	ldr	r2, [r4, #0]
   1135a:	402a      	ands	r2, r5
   1135c:	4296      	cmp	r6, r2
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   1135e:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   11362:	d024      	beq.n	113ae <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11364:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   11366:	6823      	ldr	r3, [r4, #0]
   11368:	402b      	ands	r3, r5
   1136a:	429e      	cmp	r6, r3
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   1136c:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   11370:	d01d      	beq.n	113ae <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11372:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   11374:	6821      	ldr	r1, [r4, #0]
   11376:	4029      	ands	r1, r5
   11378:	428e      	cmp	r6, r1
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   1137a:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   1137e:	d016      	beq.n	113ae <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11380:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   11382:	6822      	ldr	r2, [r4, #0]
   11384:	402a      	ands	r2, r5
   11386:	4296      	cmp	r6, r2
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11388:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   1138c:	d00f      	beq.n	113ae <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   1138e:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   11390:	6820      	ldr	r0, [r4, #0]
   11392:	4028      	ands	r0, r5
   11394:	4286      	cmp	r6, r0
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11396:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   1139a:	d008      	beq.n	113ae <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   1139c:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   1139e:	6822      	ldr	r2, [r4, #0]
   113a0:	402a      	ands	r2, r5
   113a2:	4296      	cmp	r6, r2
   113a4:	f1a7 0708 	sub.w	r7, r7, #8
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   113a8:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   113ac:	d1c2      	bne.n	11334 <am_hal_flash_delay_status_check+0xb8>
                return AM_HAL_STATUS_SUCCESS;
   113ae:	2000      	movs	r0, #0
        }
    }

    return AM_HAL_STATUS_TIMEOUT;

} // am_hal_flash_delay_status_check()
   113b0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   113b4:	f010 0907 	ands.w	r9, r0, #7
   113b8:	d043      	beq.n	11442 <am_hal_flash_delay_status_check+0x1c6>
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   113ba:	680b      	ldr	r3, [r1, #0]
   113bc:	4013      	ands	r3, r2
   113be:	429e      	cmp	r6, r3
   113c0:	d1f5      	bne.n	113ae <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   113c2:	2001      	movs	r0, #1
   113c4:	47c0      	blx	r8
   113c6:	f1b9 0f01 	cmp.w	r9, #1
   113ca:	f107 37ff 	add.w	r7, r7, #4294967295
   113ce:	d038      	beq.n	11442 <am_hal_flash_delay_status_check+0x1c6>
   113d0:	f1b9 0f02 	cmp.w	r9, #2
   113d4:	d02e      	beq.n	11434 <am_hal_flash_delay_status_check+0x1b8>
   113d6:	f1b9 0f03 	cmp.w	r9, #3
   113da:	d024      	beq.n	11426 <am_hal_flash_delay_status_check+0x1aa>
   113dc:	f1b9 0f04 	cmp.w	r9, #4
   113e0:	d01a      	beq.n	11418 <am_hal_flash_delay_status_check+0x19c>
   113e2:	f1b9 0f05 	cmp.w	r9, #5
   113e6:	d010      	beq.n	1140a <am_hal_flash_delay_status_check+0x18e>
   113e8:	f1b9 0f06 	cmp.w	r9, #6
   113ec:	d006      	beq.n	113fc <am_hal_flash_delay_status_check+0x180>
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   113ee:	6821      	ldr	r1, [r4, #0]
   113f0:	4029      	ands	r1, r5
   113f2:	428e      	cmp	r6, r1
   113f4:	d1db      	bne.n	113ae <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   113f6:	2001      	movs	r0, #1
   113f8:	47c0      	blx	r8
   113fa:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   113fc:	6822      	ldr	r2, [r4, #0]
   113fe:	402a      	ands	r2, r5
   11400:	4296      	cmp	r6, r2
   11402:	d1d4      	bne.n	113ae <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11404:	2001      	movs	r0, #1
   11406:	47c0      	blx	r8
   11408:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   1140a:	6820      	ldr	r0, [r4, #0]
   1140c:	4028      	ands	r0, r5
   1140e:	4286      	cmp	r6, r0
   11410:	d1cd      	bne.n	113ae <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11412:	2001      	movs	r0, #1
   11414:	47c0      	blx	r8
   11416:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   11418:	6823      	ldr	r3, [r4, #0]
   1141a:	402b      	ands	r3, r5
   1141c:	429e      	cmp	r6, r3
   1141e:	d1c6      	bne.n	113ae <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11420:	2001      	movs	r0, #1
   11422:	47c0      	blx	r8
   11424:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   11426:	6821      	ldr	r1, [r4, #0]
   11428:	4029      	ands	r1, r5
   1142a:	428e      	cmp	r6, r1
   1142c:	d1bf      	bne.n	113ae <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   1142e:	2001      	movs	r0, #1
   11430:	47c0      	blx	r8
   11432:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   11434:	6822      	ldr	r2, [r4, #0]
   11436:	402a      	ands	r2, r5
   11438:	4296      	cmp	r6, r2
   1143a:	d1b8      	bne.n	113ae <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   1143c:	2001      	movs	r0, #1
   1143e:	3f01      	subs	r7, #1
   11440:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   11442:	6823      	ldr	r3, [r4, #0]
   11444:	402b      	ands	r3, r5
   11446:	429e      	cmp	r6, r3
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11448:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   1144c:	d1af      	bne.n	113ae <am_hal_flash_delay_status_check+0x132>
        if ( ui32usMaxDelay-- )
   1144e:	2f00      	cmp	r7, #0
   11450:	d03b      	beq.n	114ca <am_hal_flash_delay_status_check+0x24e>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11452:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   11454:	6821      	ldr	r1, [r4, #0]
   11456:	4029      	ands	r1, r5
   11458:	428e      	cmp	r6, r1
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   1145a:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   1145e:	d1a6      	bne.n	113ae <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11460:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   11462:	6822      	ldr	r2, [r4, #0]
   11464:	402a      	ands	r2, r5
   11466:	4296      	cmp	r6, r2
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11468:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   1146c:	d19f      	bne.n	113ae <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   1146e:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   11470:	6823      	ldr	r3, [r4, #0]
   11472:	402b      	ands	r3, r5
   11474:	429e      	cmp	r6, r3
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11476:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   1147a:	d198      	bne.n	113ae <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   1147c:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   1147e:	6821      	ldr	r1, [r4, #0]
   11480:	4029      	ands	r1, r5
   11482:	428e      	cmp	r6, r1
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11484:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   11488:	d191      	bne.n	113ae <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   1148a:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   1148c:	6822      	ldr	r2, [r4, #0]
   1148e:	402a      	ands	r2, r5
   11490:	4296      	cmp	r6, r2
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11492:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   11496:	d18a      	bne.n	113ae <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11498:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   1149a:	6823      	ldr	r3, [r4, #0]
   1149c:	402b      	ands	r3, r5
   1149e:	429e      	cmp	r6, r3
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   114a0:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   114a4:	d183      	bne.n	113ae <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   114a6:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   114a8:	6820      	ldr	r0, [r4, #0]
   114aa:	4028      	ands	r0, r5
   114ac:	4286      	cmp	r6, r0
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   114ae:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   114b2:	f47f af7c 	bne.w	113ae <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   114b6:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   114b8:	6823      	ldr	r3, [r4, #0]
   114ba:	402b      	ands	r3, r5
   114bc:	429e      	cmp	r6, r3
   114be:	f1a7 0708 	sub.w	r7, r7, #8
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   114c2:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   114c6:	d0c2      	beq.n	1144e <am_hal_flash_delay_status_check+0x1d2>
   114c8:	e771      	b.n	113ae <am_hal_flash_delay_status_check+0x132>
    return AM_HAL_STATUS_TIMEOUT;
   114ca:	2004      	movs	r0, #4
   114cc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   114d0:	0800009d 	.word	0x0800009d

000114d4 <am_hal_flash_load_ui32>:
//
//*****************************************************************************
uint32_t
am_hal_flash_load_ui32(uint32_t *pui32Address)
{
    return g_am_hal_flash.flash_util_read_word(pui32Address);
   114d4:	4b00      	ldr	r3, [pc, #0]	; (114d8 <am_hal_flash_load_ui32+0x4>)
   114d6:	4718      	bx	r3
   114d8:	08000075 	.word	0x08000075

000114dc <am_hal_flash_store_ui32>:
    // Call the simple routine that has been coded in SRAM.
    // First set up a function pointer to the array, being sure to set the
    //  .T bit (Thumb bit, bit0) in the branch address, then use that
    //  function ptr to call the SRAM function.
    //
    uint32_t SRAMCode = (uint32_t)SRAM_write_ui32 | 0x1;
   114dc:	4b01      	ldr	r3, [pc, #4]	; (114e4 <am_hal_flash_store_ui32+0x8>)
   114de:	f043 0201 	orr.w	r2, r3, #1
    uint32_t (*pFunc)(uint32_t*,uint32_t) = (uint32_t (*)(uint32_t*,uint32_t))SRAMCode;
    (*pFunc)(pui32Address, ui32Value);
   114e2:	4710      	bx	r2
   114e4:	10001034 	.word	0x10001034

000114e8 <am_hal_gpio_pinconfig>:
    uint32_t ui32Padreg, ui32AltPadCfg, ui32GPCfg;
    uint32_t ui32Funcsel, ui32PowerSw;
    bool bClearEnable = false;

#ifdef AM_HAL_ENABLE_API_VALIDATION
    if ( ui32Pin > 49 )
   114e8:	2831      	cmp	r0, #49	; 0x31
   114ea:	d901      	bls.n	114f0 <am_hal_gpio_pinconfig+0x8>
    {
        return AM_HAL_STATUS_INVALID_ARG;
   114ec:	2006      	movs	r0, #6
   114ee:	4770      	bx	lr
{
   114f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ui32GPCfg = ui32Padreg = ui32AltPadCfg = 0;

    //
    // Get the requested function and/or power switch.
    //
    ui32Funcsel = bfGpioCfg.uFuncSel;
   114f4:	f001 0307 	and.w	r3, r1, #7
    ui32Padreg |= ui32Funcsel << PADREG_FLD_FNSEL_S;

    //
    // Check for invalid configuration requests.
    //
    if ( bfGpioCfg.ePullup != AM_HAL_GPIO_PIN_PULLUP_NONE )
   114f8:	f011 04e0 	ands.w	r4, r1, #224	; 0xe0
{
   114fc:	b087      	sub	sp, #28
    ui32Padreg |= ui32Funcsel << PADREG_FLD_FNSEL_S;
   114fe:	ea4f 05c3 	mov.w	r5, r3, lsl #3
    if ( bfGpioCfg.ePullup != AM_HAL_GPIO_PIN_PULLUP_NONE )
   11502:	d014      	beq.n	1152e <am_hal_gpio_pinconfig+0x46>
        ui32Padreg |= (0x1 << PADREG_FLD_PULLUP_S);

        //
        // Check for specific pullup or pulldown settings.
        //
        if ( (bfGpioCfg.ePullup >= AM_HAL_GPIO_PIN_PULLUP_1_5K) &&
   11504:	f3c1 1642 	ubfx	r6, r1, #5, #3
   11508:	1db2      	adds	r2, r6, #6
   1150a:	f002 0707 	and.w	r7, r2, #7
   1150e:	2f03      	cmp	r7, #3
        ui32Padreg |= (0x1 << PADREG_FLD_PULLUP_S);
   11510:	f045 0501 	orr.w	r5, r5, #1
        if ( (bfGpioCfg.ePullup >= AM_HAL_GPIO_PIN_PULLUP_1_5K) &&
   11514:	f200 80ab 	bhi.w	1166e <am_hal_gpio_pinconfig+0x186>
             (bfGpioCfg.ePullup <= AM_HAL_GPIO_PIN_PULLUP_24K) )
        {
            ui32Padreg |= ((bfGpioCfg.ePullup - AM_HAL_GPIO_PIN_PULLUP_1_5K) <<
                           PADREG_FLD_76_S);
#ifdef AM_HAL_ENABLE_API_VALIDATION
            if ( !(g_ui8Bit76Capabilities[ui32Pin] & CAP_PUP) )
   11518:	4a85      	ldr	r2, [pc, #532]	; (11730 <am_hal_gpio_pinconfig+0x248>)
   1151a:	5c17      	ldrb	r7, [r2, r0]
   1151c:	07ff      	lsls	r7, r7, #31
   1151e:	d403      	bmi.n	11528 <am_hal_gpio_pinconfig+0x40>
            {
                return AM_HAL_GPIO_ERR_PULLUP;
   11520:	4884      	ldr	r0, [pc, #528]	; (11734 <am_hal_gpio_pinconfig+0x24c>)

    AM_CRITICAL_END

    return AM_HAL_STATUS_SUCCESS;

} // am_hal_gpio_pinconfig()
   11522:	b007      	add	sp, #28
   11524:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            ui32Padreg |= ((bfGpioCfg.ePullup - AM_HAL_GPIO_PIN_PULLUP_1_5K) <<
   11528:	1eb4      	subs	r4, r6, #2
   1152a:	ea45 1584 	orr.w	r5, r5, r4, lsl #6
    ui32PowerSw = bfGpioCfg.ePowerSw;
   1152e:	f3c1 06c1 	ubfx	r6, r1, #3, #2
    if ( ui32PowerSw != AM_HAL_GPIO_PIN_POWERSW_NONE )
   11532:	2e00      	cmp	r6, #0
   11534:	f040 8095 	bne.w	11662 <am_hal_gpio_pinconfig+0x17a>
    ui32Padreg |= (g_ui8Inpen[ui32Pin] & (1 << ui32Funcsel)) ? (1 << PADREG_FLD_INPEN_S) : 0;
   11538:	4a7f      	ldr	r2, [pc, #508]	; (11738 <am_hal_gpio_pinconfig+0x250>)
    if ( g_ui8nCEpins[ui32Pin] == ui32Funcsel )
   1153a:	4f80      	ldr	r7, [pc, #512]	; (1173c <am_hal_gpio_pinconfig+0x254>)
    ui32Padreg |= (g_ui8Inpen[ui32Pin] & (1 << ui32Funcsel)) ? (1 << PADREG_FLD_INPEN_S) : 0;
   1153c:	5c16      	ldrb	r6, [r2, r0]
    if ( g_ui8nCEpins[ui32Pin] == ui32Funcsel )
   1153e:	f817 8000 	ldrb.w	r8, [r7, r0]
    ui32Padreg |= (g_ui8Inpen[ui32Pin] & (1 << ui32Funcsel)) ? (1 << PADREG_FLD_INPEN_S) : 0;
   11542:	411e      	asrs	r6, r3
   11544:	f016 0f01 	tst.w	r6, #1
   11548:	bf0c      	ite	eq
   1154a:	2600      	moveq	r6, #0
   1154c:	2602      	movne	r6, #2
    if ( g_ui8nCEpins[ui32Pin] == ui32Funcsel )
   1154e:	4543      	cmp	r3, r8
    ui32Padreg |= (g_ui8Inpen[ui32Pin] & (1 << ui32Funcsel)) ? (1 << PADREG_FLD_INPEN_S) : 0;
   11550:	ea45 0506 	orr.w	r5, r5, r6
    if ( g_ui8nCEpins[ui32Pin] == ui32Funcsel )
   11554:	f000 8097 	beq.w	11686 <am_hal_gpio_pinconfig+0x19e>
                     (((bfGpioCfg.eIntDir >> 0) & 0x1) << GPIOCFG_FLD_INTD_S)   |
   11558:	f3c1 3341 	ubfx	r3, r1, #13, #2
   1155c:	00df      	lsls	r7, r3, #3
        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
   1155e:	f3c1 2907 	ubfx	r9, r1, #8, #8
                     (((bfGpioCfg.eIntDir >> 0) & 0x1) << GPIOCFG_FLD_INTD_S)   |
   11562:	f007 0408 	and.w	r4, r7, #8
                     (((bfGpioCfg.eIntDir >> 1) & 0x1) << GPIOCFG_FLD_INCFG_S);
   11566:	105a      	asrs	r2, r3, #1
        ui32GPCfg |= (bfGpioCfg.eGPOutcfg << GPIOCFG_FLD_OUTCFG_S)              |
   11568:	f3c1 2681 	ubfx	r6, r1, #10, #2
        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
   1156c:	f009 070c 	and.w	r7, r9, #12
                     (((bfGpioCfg.eIntDir >> 0) & 0x1) << GPIOCFG_FLD_INTD_S)   |
   11570:	ea42 0346 	orr.w	r3, r2, r6, lsl #1
        ui32Padreg |= (bfGpioCfg.eGPInput << PADREG_FLD_INPEN_S);
   11574:	f3c1 3a00 	ubfx	sl, r1, #12, #1
        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
   11578:	2f04      	cmp	r7, #4
                     (((bfGpioCfg.eIntDir >> 0) & 0x1) << GPIOCFG_FLD_INTD_S)   |
   1157a:	ea43 0804 	orr.w	r8, r3, r4
        ui32Padreg |= (bfGpioCfg.eGPInput << PADREG_FLD_INPEN_S);
   1157e:	ea45 054a 	orr.w	r5, r5, sl, lsl #1
        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
   11582:	f000 808d 	beq.w	116a0 <am_hal_gpio_pinconfig+0x1b8>
    ui32B = *((uint32_t*)cfg2);
   11586:	4a6e      	ldr	r2, [pc, #440]	; (11740 <am_hal_gpio_pinconfig+0x258>)
        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
   11588:	6816      	ldr	r6, [r2, #0]
   1158a:	1b8c      	subs	r4, r1, r6
   1158c:	fab4 f384 	clz	r3, r4
   11590:	095f      	lsrs	r7, r3, #5
   11592:	9700      	str	r7, [sp, #0]
        if ( bfGpioCfg.eIntDir == 0 )
   11594:	f019 0f60 	tst.w	r9, #96	; 0x60
            ui32GPCfg |= (bfGpioCfg.eGPRdZero << GPIOCFG_FLD_INCFG_S);
   11598:	bf04      	itt	eq
   1159a:	f3c1 37c0 	ubfxeq	r7, r1, #15, #1
   1159e:	f367 0800 	bfieq	r8, r7, #0, #1
   115a2:	0087      	lsls	r7, r0, #2
    switch ( bfGpioCfg.eDriveStrength )
   115a4:	f3c1 2101 	ubfx	r1, r1, #8, #2
   115a8:	2902      	cmp	r1, #2
   115aa:	ea4f 04c0 	mov.w	r4, r0, lsl #3
   115ae:	d07a      	beq.n	116a6 <am_hal_gpio_pinconfig+0x1be>
   115b0:	d87f      	bhi.n	116b2 <am_hal_gpio_pinconfig+0x1ca>
   115b2:	2901      	cmp	r1, #1
            ui32Padreg    |= (1 << PADREG_FLD_DRVSTR_S);
   115b4:	bf08      	it	eq
   115b6:	f045 0504 	orreq.w	r5, r5, #4
   115ba:	f004 0a18 	and.w	sl, r4, #24
            break;
   115be:	2200      	movs	r2, #0
   115c0:	4604      	mov	r4, r0
   115c2:	9203      	str	r2, [sp, #12]
    ui32GPCfgClearMask  = ~((uint32_t)0xF  << ui32GPCfgShft);
   115c4:	f04f 0b0f 	mov.w	fp, #15
    ui32GPCfgShft       = ((ui32Pin & 0x7) << 2);
   115c8:	f007 021c 	and.w	r2, r7, #28
    ui32GPCfgAddr       = (uint32_t)&GPIO->CFGA       + ((ui32Pin & ~0x7) >> 1);
   115cc:	485d      	ldr	r0, [pc, #372]	; (11744 <am_hal_gpio_pinconfig+0x25c>)
    ui32AltpadAddr      = (uint32_t)&GPIO->ALTPADCFGA + (ui32Pin & ~0x3);
   115ce:	495e      	ldr	r1, [pc, #376]	; (11748 <am_hal_gpio_pinconfig+0x260>)
    ui32GPCfgAddr       = (uint32_t)&GPIO->CFGA       + ((ui32Pin & ~0x7) >> 1);
   115d0:	4f5e      	ldr	r7, [pc, #376]	; (1174c <am_hal_gpio_pinconfig+0x264>)
   115d2:	9702      	str	r7, [sp, #8]
    ui32GPCfgClearMask  = ~((uint32_t)0xF  << ui32GPCfgShft);
   115d4:	fa0b f302 	lsl.w	r3, fp, r2
    ui32PadClearMask    = ~((uint32_t)0xFF << ui32PadShft);
   115d8:	f04f 0cff 	mov.w	ip, #255	; 0xff
   115dc:	fa0c f60a 	lsl.w	r6, ip, sl
    ui32AltpadAddr      = (uint32_t)&GPIO->ALTPADCFGA + (ui32Pin & ~0x3);
   115e0:	9101      	str	r1, [sp, #4]
    ui32GPCfg     <<= ui32GPCfgShft;
   115e2:	fa08 f802 	lsl.w	r8, r8, r2
    ui32GPCfgClearMask  = ~((uint32_t)0xF  << ui32GPCfgShft);
   115e6:	43df      	mvns	r7, r3
    ui32GPCfgAddr       = (uint32_t)&GPIO->CFGA       + ((ui32Pin & ~0x7) >> 1);
   115e8:	ea00 0954 	and.w	r9, r0, r4, lsr #1
    AM_CRITICAL_BEGIN
   115ec:	f000 f902 	bl	117f4 <am_hal_interrupt_master_disable>
   115f0:	9005      	str	r0, [sp, #20]
    if ( bClearEnable )
   115f2:	e89d 0009 	ldmia.w	sp, {r0, r3}
    ui32PadregAddr      = (uint32_t)&GPIO->PADREGA    + (ui32Pin & ~0x3);
   115f6:	f024 0b03 	bic.w	fp, r4, #3
    ui32Padreg    <<= ui32PadShft;
   115fa:	fa05 f50a 	lsl.w	r5, r5, sl
    ui32PadregAddr      = (uint32_t)&GPIO->PADREGA    + (ui32Pin & ~0x3);
   115fe:	f10b 4a80 	add.w	sl, fp, #1073741824	; 0x40000000
    ui32PadClearMask    = ~((uint32_t)0xFF << ui32PadShft);
   11602:	43f6      	mvns	r6, r6
    ui32PadregAddr      = (uint32_t)&GPIO->PADREGA    + (ui32Pin & ~0x3);
   11604:	f50a 3a80 	add.w	sl, sl, #65536	; 0x10000
    if ( bClearEnable )
   11608:	9902      	ldr	r1, [sp, #8]
   1160a:	9a03      	ldr	r2, [sp, #12]
   1160c:	b150      	cbz	r0, 11624 <am_hal_gpio_pinconfig+0x13c>
        am_hal_gpio_output_tristate_disable(ui32Pin);
   1160e:	f004 001f 	and.w	r0, r4, #31
   11612:	ea4f 1e54 	mov.w	lr, r4, lsr #5
   11616:	f04f 0c01 	mov.w	ip, #1
   1161a:	4c4d      	ldr	r4, [pc, #308]	; (11750 <am_hal_gpio_pinconfig+0x268>)
   1161c:	fa0c f000 	lsl.w	r0, ip, r0
   11620:	f844 002e 	str.w	r0, [r4, lr, lsl #2]
    GPIO->PADKEY = GPIO_PADKEY_PADKEY_Key;
   11624:	484b      	ldr	r0, [pc, #300]	; (11754 <am_hal_gpio_pinconfig+0x26c>)
   11626:	2473      	movs	r4, #115	; 0x73
   11628:	6604      	str	r4, [r0, #96]	; 0x60
    AM_REGVAL(ui32PadregAddr)  = (AM_REGVAL(ui32PadregAddr) & ui32PadClearMask)   | ui32Padreg;
   1162a:	f8da 4000 	ldr.w	r4, [sl]
   1162e:	4034      	ands	r4, r6
   11630:	4325      	orrs	r5, r4
   11632:	f8ca 5000 	str.w	r5, [sl]
    AM_REGVAL(ui32GPCfgAddr)   = (AM_REGVAL(ui32GPCfgAddr)  & ui32GPCfgClearMask) | ui32GPCfg;
   11636:	f859 5001 	ldr.w	r5, [r9, r1]
   1163a:	402f      	ands	r7, r5
   1163c:	ea47 0708 	orr.w	r7, r7, r8
   11640:	f849 7001 	str.w	r7, [r9, r1]
    AM_REGVAL(ui32AltpadAddr)  = (AM_REGVAL(ui32AltpadAddr) & ui32PadClearMask)   | ui32AltPadCfg;
   11644:	f85b 1003 	ldr.w	r1, [fp, r3]
   11648:	400e      	ands	r6, r1
   1164a:	4332      	orrs	r2, r6
    GPIO->PADKEY = 0;
   1164c:	2600      	movs	r6, #0
    AM_REGVAL(ui32AltpadAddr)  = (AM_REGVAL(ui32AltpadAddr) & ui32PadClearMask)   | ui32AltPadCfg;
   1164e:	f84b 2003 	str.w	r2, [fp, r3]
    GPIO->PADKEY = 0;
   11652:	6606      	str	r6, [r0, #96]	; 0x60
    AM_CRITICAL_END
   11654:	9805      	ldr	r0, [sp, #20]
   11656:	f000 f8d1 	bl	117fc <am_hal_interrupt_master_set>
    return AM_HAL_STATUS_SUCCESS;
   1165a:	4630      	mov	r0, r6
} // am_hal_gpio_pinconfig()
   1165c:	b007      	add	sp, #28
   1165e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ( (ui32PowerSw == AM_HAL_GPIO_PIN_POWERSW_VDD)  &&
   11662:	2e01      	cmp	r6, #1
   11664:	d015      	beq.n	11692 <am_hal_gpio_pinconfig+0x1aa>
        else if ( (ui32PowerSw == AM_HAL_GPIO_PIN_POWERSW_VSS)  &&
   11666:	2e02      	cmp	r6, #2
   11668:	d030      	beq.n	116cc <am_hal_gpio_pinconfig+0x1e4>
            return AM_HAL_GPIO_ERR_PWRSW;
   1166a:	483b      	ldr	r0, [pc, #236]	; (11758 <am_hal_gpio_pinconfig+0x270>)
   1166c:	e759      	b.n	11522 <am_hal_gpio_pinconfig+0x3a>
        else if ( bfGpioCfg.ePullup == AM_HAL_GPIO_PIN_PULLDOWN )
   1166e:	2cc0      	cmp	r4, #192	; 0xc0
   11670:	d027      	beq.n	116c2 <am_hal_gpio_pinconfig+0x1da>
        else if ( bfGpioCfg.ePullup == AM_HAL_GPIO_PIN_PULLUP_WEAK )
   11672:	2c20      	cmp	r4, #32
   11674:	f47f af5b 	bne.w	1152e <am_hal_gpio_pinconfig+0x46>
            if ( g_ui8Bit76Capabilities[ui32Pin] & (CAP_PUP | CAP_PDN) )
   11678:	4c2d      	ldr	r4, [pc, #180]	; (11730 <am_hal_gpio_pinconfig+0x248>)
   1167a:	5c26      	ldrb	r6, [r4, r0]
   1167c:	f016 0f09 	tst.w	r6, #9
   11680:	f47f af4e 	bne.w	11520 <am_hal_gpio_pinconfig+0x38>
   11684:	e753      	b.n	1152e <am_hal_gpio_pinconfig+0x46>
        if ( bfGpioCfg.uIOMnum > IOMNUM_MAX )
   11686:	f3c1 4202 	ubfx	r2, r1, #16, #3
   1168a:	2a07      	cmp	r2, #7
   1168c:	d125      	bne.n	116da <am_hal_gpio_pinconfig+0x1f2>
            return AM_HAL_GPIO_ERR_INVCE;   // Invalid CE specified
   1168e:	4833      	ldr	r0, [pc, #204]	; (1175c <am_hal_gpio_pinconfig+0x274>)
   11690:	e747      	b.n	11522 <am_hal_gpio_pinconfig+0x3a>
             (g_ui8Bit76Capabilities[ui32Pin] & CAP_VDD) )
   11692:	4c27      	ldr	r4, [pc, #156]	; (11730 <am_hal_gpio_pinconfig+0x248>)
        if ( (ui32PowerSw == AM_HAL_GPIO_PIN_POWERSW_VDD)  &&
   11694:	5c26      	ldrb	r6, [r4, r0]
   11696:	07b4      	lsls	r4, r6, #30
   11698:	d5e7      	bpl.n	1166a <am_hal_gpio_pinconfig+0x182>
            ui32Padreg |= 0x1 << PADREG_FLD_76_S;
   1169a:	f045 0540 	orr.w	r5, r5, #64	; 0x40
   1169e:	e74b      	b.n	11538 <am_hal_gpio_pinconfig+0x50>
            bClearEnable = true;
   116a0:	2701      	movs	r7, #1
   116a2:	9700      	str	r7, [sp, #0]
   116a4:	e776      	b.n	11594 <am_hal_gpio_pinconfig+0xac>
   116a6:	f004 0a18 	and.w	sl, r4, #24
   116aa:	2301      	movs	r3, #1
   116ac:	fa03 f20a 	lsl.w	r2, r3, sl
            break;
   116b0:	e786      	b.n	115c0 <am_hal_gpio_pinconfig+0xd8>
   116b2:	f004 0a18 	and.w	sl, r4, #24
   116b6:	2601      	movs	r6, #1
            ui32Padreg    |= (1 << PADREG_FLD_DRVSTR_S);
   116b8:	f045 0504 	orr.w	r5, r5, #4
   116bc:	fa06 f20a 	lsl.w	r2, r6, sl
            break;
   116c0:	e77e      	b.n	115c0 <am_hal_gpio_pinconfig+0xd8>
            if ( ui32Pin != 20 )
   116c2:	2814      	cmp	r0, #20
   116c4:	f43f af33 	beq.w	1152e <am_hal_gpio_pinconfig+0x46>
                return AM_HAL_GPIO_ERR_PULLDOWN;
   116c8:	4825      	ldr	r0, [pc, #148]	; (11760 <am_hal_gpio_pinconfig+0x278>)
   116ca:	e72a      	b.n	11522 <am_hal_gpio_pinconfig+0x3a>
                  (g_ui8Bit76Capabilities[ui32Pin] & CAP_VSS) )
   116cc:	4a18      	ldr	r2, [pc, #96]	; (11730 <am_hal_gpio_pinconfig+0x248>)
        else if ( (ui32PowerSw == AM_HAL_GPIO_PIN_POWERSW_VSS)  &&
   116ce:	5c17      	ldrb	r7, [r2, r0]
   116d0:	077a      	lsls	r2, r7, #29
   116d2:	d5ca      	bpl.n	1166a <am_hal_gpio_pinconfig+0x182>
            ui32Padreg |= 0x2 << PADREG_FLD_76_S;
   116d4:	f045 0580 	orr.w	r5, r5, #128	; 0x80
   116d8:	e72e      	b.n	11538 <am_hal_gpio_pinconfig+0x50>
            if ( g_ui8NCEtable[ui32Pin][ui32Outcfg] == ui8CEtbl )
   116da:	4c22      	ldr	r4, [pc, #136]	; (11764 <am_hal_gpio_pinconfig+0x27c>)
        ui8CEtbl = (bfGpioCfg.uIOMnum << 4) | bfGpioCfg.uNCE;
   116dc:	f3c1 4cc1 	ubfx	ip, r1, #19, #2
            if ( g_ui8NCEtable[ui32Pin][ui32Outcfg] == ui8CEtbl )
   116e0:	f814 8020 	ldrb.w	r8, [r4, r0, lsl #2]
        ui8CEtbl = (bfGpioCfg.uIOMnum << 4) | bfGpioCfg.uNCE;
   116e4:	ea4c 1602 	orr.w	r6, ip, r2, lsl #4
            if ( g_ui8NCEtable[ui32Pin][ui32Outcfg] == ui8CEtbl )
   116e8:	45b0      	cmp	r8, r6
   116ea:	d010      	beq.n	1170e <am_hal_gpio_pinconfig+0x226>
   116ec:	0087      	lsls	r7, r0, #2
   116ee:	eb04 0907 	add.w	r9, r4, r7
   116f2:	f899 3001 	ldrb.w	r3, [r9, #1]
   116f6:	42b3      	cmp	r3, r6
   116f8:	d015      	beq.n	11726 <am_hal_gpio_pinconfig+0x23e>
   116fa:	f899 2002 	ldrb.w	r2, [r9, #2]
   116fe:	42b2      	cmp	r2, r6
   11700:	d00f      	beq.n	11722 <am_hal_gpio_pinconfig+0x23a>
   11702:	f899 4003 	ldrb.w	r4, [r9, #3]
   11706:	42b4      	cmp	r4, r6
   11708:	d00f      	beq.n	1172a <am_hal_gpio_pinconfig+0x242>
            return AM_HAL_GPIO_ERR_INVCEPIN;
   1170a:	4817      	ldr	r0, [pc, #92]	; (11768 <am_hal_gpio_pinconfig+0x280>)
   1170c:	e709      	b.n	11522 <am_hal_gpio_pinconfig+0x3a>
        for ( ui32Outcfg = 0; ui32Outcfg < 4; ui32Outcfg++ )
   1170e:	2600      	movs	r6, #0
   11710:	0087      	lsls	r7, r0, #2
        ui32GPCfg |= (ui32Outcfg       << GPIOCFG_FLD_OUTCFG_S) |
   11712:	0072      	lsls	r2, r6, #1
                     (bfGpioCfg.eCEpol << GPIOCFG_FLD_INTD_S)   |
   11714:	f3c1 5e40 	ubfx	lr, r1, #21, #1
    bool bClearEnable = false;
   11718:	2300      	movs	r3, #0
                     (bfGpioCfg.eCEpol << GPIOCFG_FLD_INTD_S)   |
   1171a:	ea42 08ce 	orr.w	r8, r2, lr, lsl #3
    bool bClearEnable = false;
   1171e:	9300      	str	r3, [sp, #0]
   11720:	e740      	b.n	115a4 <am_hal_gpio_pinconfig+0xbc>
        for ( ui32Outcfg = 0; ui32Outcfg < 4; ui32Outcfg++ )
   11722:	2602      	movs	r6, #2
   11724:	e7f5      	b.n	11712 <am_hal_gpio_pinconfig+0x22a>
   11726:	2601      	movs	r6, #1
   11728:	e7f3      	b.n	11712 <am_hal_gpio_pinconfig+0x22a>
   1172a:	2603      	movs	r6, #3
   1172c:	e7f1      	b.n	11712 <am_hal_gpio_pinconfig+0x22a>
   1172e:	bf00      	nop
   11730:	000132f4 	.word	0x000132f4
   11734:	08000100 	.word	0x08000100
   11738:	00013328 	.word	0x00013328
   1173c:	00013424 	.word	0x00013424
   11740:	000132e8 	.word	0x000132e8
   11744:	7ffffffc 	.word	0x7ffffffc
   11748:	400100e0 	.word	0x400100e0
   1174c:	40010040 	.word	0x40010040
   11750:	400100b4 	.word	0x400100b4
   11754:	40010000 	.word	0x40010000
   11758:	08000102 	.word	0x08000102
   1175c:	08000103 	.word	0x08000103
   11760:	08000101 	.word	0x08000101
   11764:	0001335c 	.word	0x0001335c
   11768:	08000104 	.word	0x08000104

0001176c <am_hal_gpio_state_write>:
{
    uint32_t ui32Mask, ui32Off;
    uint32_t ui32Return = AM_HAL_STATUS_SUCCESS;

#ifdef AM_HAL_ENABLE_API_VALIDATION
    if ( ui32Pin >= AM_HAL_GPIO_MAX_PADS )
   1176c:	2831      	cmp	r0, #49	; 0x31
   1176e:	d901      	bls.n	11774 <am_hal_gpio_state_write+0x8>
    {
        return AM_HAL_STATUS_OUT_OF_RANGE;
   11770:	2005      	movs	r0, #5
   11772:	4770      	bx	lr
    }

    if ( eWriteType > AM_HAL_GPIO_OUTPUT_TRISTATE_TOGGLE )
   11774:	2905      	cmp	r1, #5
   11776:	d901      	bls.n	1177c <am_hal_gpio_state_write+0x10>
    {
        return AM_HAL_STATUS_INVALID_ARG;
   11778:	2006      	movs	r0, #6
   1177a:	4770      	bx	lr
{
   1177c:	b570      	push	{r4, r5, r6, lr}
    }
#endif // AM_HAL_ENABLE_API_VALIDATION

    ui32Mask = (uint32_t)0x1 << (ui32Pin % 32);
   1177e:	f000 031f 	and.w	r3, r0, #31
{
   11782:	b082      	sub	sp, #8
    ui32Off  = (ui32Pin & 0x20) >> 3;   // 0 or 4
   11784:	08c0      	lsrs	r0, r0, #3
    ui32Mask = (uint32_t)0x1 << (ui32Pin % 32);
   11786:	2201      	movs	r2, #1
   11788:	460d      	mov	r5, r1
    ui32Off  = (ui32Pin & 0x20) >> 3;   // 0 or 4
   1178a:	f000 0404 	and.w	r4, r0, #4
    ui32Mask = (uint32_t)0x1 << (ui32Pin % 32);
   1178e:	fa02 f603 	lsl.w	r6, r2, r3

    AM_CRITICAL_BEGIN;
   11792:	f000 f82f 	bl	117f4 <am_hal_interrupt_master_disable>

#if AM_CMSIS_REGS
    ui32Off /= 4;   // 0 or 1 for ptr arithmetic
    switch ( eWriteType )
   11796:	1e69      	subs	r1, r5, #1
    AM_CRITICAL_BEGIN;
   11798:	9001      	str	r0, [sp, #4]
    switch ( eWriteType )
   1179a:	2904      	cmp	r1, #4
   1179c:	d817      	bhi.n	117ce <am_hal_gpio_state_write+0x62>
   1179e:	e8df f001 	tbb	[pc, r1]
   117a2:	0e13      	.short	0x0e13
   117a4:	030b      	.short	0x030b
   117a6:	19          	.byte	0x19
   117a7:	00          	.byte	0x00
            break;
        case AM_HAL_GPIO_OUTPUT_TOGGLE:             // Toggle the GPIO value.
            AM_REGVAL(&GPIO->WTA + ui32Off) ^= ui32Mask;
            break;
        case AM_HAL_GPIO_OUTPUT_TRISTATE_ENABLE:    // Enable  a tri-state GPIO.
            AM_REGVAL(&GPIO->ENSA + ui32Off) = ui32Mask;
   117a8:	4d0d      	ldr	r5, [pc, #52]	; (117e0 <am_hal_gpio_state_write+0x74>)
   117aa:	5166      	str	r6, [r4, r5]
            ui32Return = AM_HAL_STATUS_INVALID_ARG;
            break;
    }
#endif // AM_CMSIS_REGS

    AM_CRITICAL_END;
   117ac:	9801      	ldr	r0, [sp, #4]
   117ae:	f000 f825 	bl	117fc <am_hal_interrupt_master_set>

    return ui32Return;
   117b2:	2000      	movs	r0, #0
} // am_hal_gpio_state_write()
   117b4:	b002      	add	sp, #8
   117b6:	bd70      	pop	{r4, r5, r6, pc}
            AM_REGVAL(&GPIO->ENCA + ui32Off) = ui32Mask;
   117b8:	4b0a      	ldr	r3, [pc, #40]	; (117e4 <am_hal_gpio_state_write+0x78>)
   117ba:	50e6      	str	r6, [r4, r3]
            break;
   117bc:	e7f6      	b.n	117ac <am_hal_gpio_state_write+0x40>
            AM_REGVAL(&GPIO->WTA + ui32Off) ^= ui32Mask;
   117be:	480a      	ldr	r0, [pc, #40]	; (117e8 <am_hal_gpio_state_write+0x7c>)
   117c0:	5822      	ldr	r2, [r4, r0]
   117c2:	4072      	eors	r2, r6
   117c4:	5022      	str	r2, [r4, r0]
            break;
   117c6:	e7f1      	b.n	117ac <am_hal_gpio_state_write+0x40>
            AM_REGVAL(&GPIO->WTSA + ui32Off) = ui32Mask;
   117c8:	4908      	ldr	r1, [pc, #32]	; (117ec <am_hal_gpio_state_write+0x80>)
   117ca:	5066      	str	r6, [r4, r1]
            break;
   117cc:	e7ee      	b.n	117ac <am_hal_gpio_state_write+0x40>
            AM_REGVAL(&GPIO->WTCA + ui32Off) = ui32Mask;
   117ce:	4d08      	ldr	r5, [pc, #32]	; (117f0 <am_hal_gpio_state_write+0x84>)
   117d0:	5166      	str	r6, [r4, r5]
            break;
   117d2:	e7eb      	b.n	117ac <am_hal_gpio_state_write+0x40>
            AM_REGVAL(&GPIO->ENCA + ui32Off) ^= ui32Mask;
   117d4:	4803      	ldr	r0, [pc, #12]	; (117e4 <am_hal_gpio_state_write+0x78>)
   117d6:	5823      	ldr	r3, [r4, r0]
   117d8:	4073      	eors	r3, r6
   117da:	5023      	str	r3, [r4, r0]
            break;
   117dc:	e7e6      	b.n	117ac <am_hal_gpio_state_write+0x40>
   117de:	bf00      	nop
   117e0:	400100a8 	.word	0x400100a8
   117e4:	400100b4 	.word	0x400100b4
   117e8:	40010088 	.word	0x40010088
   117ec:	40010090 	.word	0x40010090
   117f0:	40010098 	.word	0x40010098

000117f4 <am_hal_interrupt_master_disable>:
//*****************************************************************************
#if defined(__GNUC_STDC_INLINE__)
uint32_t __attribute__((naked))
am_hal_interrupt_master_disable(void)
{
    __asm("    mrs     r0, PRIMASK");
   117f4:	f3ef 8010 	mrs	r0, PRIMASK
    __asm("    cpsid i");
   117f8:	b672      	cpsid	i
    __asm("    bx lr");
   117fa:	4770      	bx	lr

000117fc <am_hal_interrupt_master_set>:
//*****************************************************************************
#if defined(__GNUC_STDC_INLINE__)
void __attribute__((naked))
am_hal_interrupt_master_set(uint32_t ui32InterruptState)
{
    __asm("    msr     PRIMASK, r0");
   117fc:	f380 8810 	msr	PRIMASK, r0
    __asm("    bx lr");
   11800:	4770      	bx	lr
   11802:	bf00      	nop

00011804 <am_hal_itm_disable>:
//! @return None.
//
//*****************************************************************************
void
am_hal_itm_disable(void)
{
   11804:	b510      	push	{r4, lr}

#if AM_CMSIS_REGS
    if ( MCUCTRL->TPIUCTRL == 0 )
   11806:	4b24      	ldr	r3, [pc, #144]	; (11898 <am_hal_itm_disable+0x94>)
   11808:	f8d3 0250 	ldr.w	r0, [r3, #592]	; 0x250
   1180c:	b9b0      	cbnz	r0, 1183c <am_hal_itm_disable+0x38>
    CoreDebug->DEMCR |= _VAL2FLD(CoreDebug_DEMCR_TRCENA, 1);
   1180e:	4923      	ldr	r1, [pc, #140]	; (1189c <am_hal_itm_disable+0x98>)
   11810:	68ca      	ldr	r2, [r1, #12]
   11812:	f042 7480 	orr.w	r4, r2, #16777216	; 0x1000000
   11816:	60cc      	str	r4, [r1, #12]
    while ( !(CoreDebug->DEMCR & _VAL2FLD(CoreDebug_DEMCR_TRCENA, 1)) );
   11818:	68cb      	ldr	r3, [r1, #12]
   1181a:	01da      	lsls	r2, r3, #7
   1181c:	d5fc      	bpl.n	11818 <am_hal_itm_disable+0x14>
    ITM->LAR = ITM_LAR_KEYVAL;
   1181e:	f04f 4c60 	mov.w	ip, #3758096384	; 0xe0000000
   11822:	481f      	ldr	r0, [pc, #124]	; (118a0 <am_hal_itm_disable+0x9c>)
    ITM->TCR =
   11824:	4a1f      	ldr	r2, [pc, #124]	; (118a4 <am_hal_itm_disable+0xa0>)
    ITM->LAR = ITM_LAR_KEYVAL;
   11826:	f8cc 0fb0 	str.w	r0, [ip, #4016]	; 0xfb0
    ITM->TPR = 0x0000000F;
   1182a:	240f      	movs	r4, #15
    ITM->TER = 0xFFFFFFFF;
   1182c:	f04f 31ff 	mov.w	r1, #4294967295
    ITM->TPR = 0x0000000F;
   11830:	f8cc 4e40 	str.w	r4, [ip, #3648]	; 0xe40
    ITM->TER = 0xFFFFFFFF;
   11834:	f8cc 1e00 	str.w	r1, [ip, #3584]	; 0xe00
    ITM->TCR =
   11838:	f8cc 2e80 	str.w	r2, [ip, #3712]	; 0xe80
{
    //
    // Make sure the ITM/TPIU is not busy.
    //
#if AM_CMSIS_REGS
    while (ITM->TCR & _VAL2FLD(ITM_TCR_BUSY, 1));
   1183c:	f04f 4460 	mov.w	r4, #3758096384	; 0xe0000000
   11840:	f8d4 3e80 	ldr.w	r3, [r4, #3712]	; 0xe80
   11844:	021b      	lsls	r3, r3, #8
   11846:	d4fb      	bmi.n	11840 <am_hal_itm_disable+0x3c>
#endif // AM_CMSIS_REGS

    //
    // wait for 50us for the data to flush out
    //
    am_hal_flash_delay(FLASH_CYCLES_US(50));
   11848:	f240 20f7 	movw	r0, #759	; 0x2f7
   1184c:	f7ff fd12 	bl	11274 <am_hal_flash_delay>
    ITM->LAR = ITM_LAR_KEYVAL;
   11850:	4813      	ldr	r0, [pc, #76]	; (118a0 <am_hal_itm_disable+0x9c>)
        while ( ITM->TCR  & (_VAL2FLD(ITM_TCR_ITMENA, 1)  |  _VAL2FLD(ITM_TCR_BUSY, 1)) );
   11852:	4915      	ldr	r1, [pc, #84]	; (118a8 <am_hal_itm_disable+0xa4>)
    ITM->LAR = ITM_LAR_KEYVAL;
   11854:	f8c4 0fb0 	str.w	r0, [r4, #4016]	; 0xfb0
        ITM->TCR &= ~_VAL2FLD(ITM_TCR_ITMENA, 1);
   11858:	f04f 4c60 	mov.w	ip, #3758096384	; 0xe0000000
    ITM->LAR = ITM_LAR_KEYVAL;
   1185c:	2064      	movs	r0, #100	; 0x64
        ITM->TCR &= ~_VAL2FLD(ITM_TCR_ITMENA, 1);
   1185e:	f8dc 2e80 	ldr.w	r2, [ip, #3712]	; 0xe80
   11862:	f022 0401 	bic.w	r4, r2, #1
   11866:	f8cc 4e80 	str.w	r4, [ip, #3712]	; 0xe80
        while ( ITM->TCR  & (_VAL2FLD(ITM_TCR_ITMENA, 1)  |  _VAL2FLD(ITM_TCR_BUSY, 1)) );
   1186a:	f8dc 3e80 	ldr.w	r3, [ip, #3712]	; 0xe80
   1186e:	420b      	tst	r3, r1
   11870:	d1fb      	bne.n	1186a <am_hal_itm_disable+0x66>
    for (int ix = 0; ix < 100; ix++)
   11872:	3801      	subs	r0, #1
   11874:	d1f3      	bne.n	1185e <am_hal_itm_disable+0x5a>
    CoreDebug->DEMCR &= ~_VAL2FLD(CoreDebug_DEMCR_TRCENA, 1);
   11876:	4909      	ldr	r1, [pc, #36]	; (1189c <am_hal_itm_disable+0x98>)
   11878:	68ca      	ldr	r2, [r1, #12]
   1187a:	f022 7480 	bic.w	r4, r2, #16777216	; 0x1000000
   1187e:	60cc      	str	r4, [r1, #12]
    while ( CoreDebug->DEMCR & _VAL2FLD(CoreDebug_DEMCR_TRCENA, 1) );
   11880:	68cb      	ldr	r3, [r1, #12]
   11882:	f013 7080 	ands.w	r0, r3, #16777216	; 0x1000000
   11886:	d1fb      	bne.n	11880 <am_hal_itm_disable+0x7c>
    MCUCTRL->TPIUCTRL =
   11888:	4903      	ldr	r1, [pc, #12]	; (11898 <am_hal_itm_disable+0x94>)
   1188a:	f8c1 0250 	str.w	r0, [r1, #592]	; 0x250
    while (MCUCTRL->TPIUCTRL);
   1188e:	f8d1 2250 	ldr.w	r2, [r1, #592]	; 0x250
   11892:	2a00      	cmp	r2, #0
   11894:	d1fb      	bne.n	1188e <am_hal_itm_disable+0x8a>
}
   11896:	bd10      	pop	{r4, pc}
   11898:	40020000 	.word	0x40020000
   1189c:	e000edf0 	.word	0xe000edf0
   118a0:	c5acce55 	.word	0xc5acce55
   118a4:	00150511 	.word	0x00150511
   118a8:	00800001 	.word	0x00800001

000118ac <am_hal_mcuctrl_info_get>:
am_hal_mcuctrl_info_get(am_hal_mcuctrl_infoget_e eInfoGet, void *pInfo)
{
    am_hal_mcuctrl_feature_t *psFeature;
    uint32_t ui32Feature;

    if ( pInfo == NULL )
   118ac:	b141      	cbz	r1, 118c0 <am_hal_mcuctrl_info_get+0x14>
    {
        return AM_HAL_STATUS_INVALID_ARG;
    }

#if AM_CMSIS_REGS
    switch ( eInfoGet )
   118ae:	2801      	cmp	r0, #1
{
   118b0:	b4f0      	push	{r4, r5, r6, r7}
    switch ( eInfoGet )
   118b2:	d03a      	beq.n	1192a <am_hal_mcuctrl_info_get+0x7e>
   118b4:	d322      	bcc.n	118fc <am_hal_mcuctrl_info_get+0x50>
   118b6:	2802      	cmp	r0, #2
   118b8:	d004      	beq.n	118c4 <am_hal_mcuctrl_info_get+0x18>
        case AM_HAL_MCUCTRL_INFO_FAULT_STATUS:
            mcuctrl_fault_status((am_hal_mcuctrl_fault_t*)pInfo);
            break;

        default:
            return AM_HAL_STATUS_INVALID_ARG;
   118ba:	2006      	movs	r0, #6
    //
    // Return success status.
    //
    return AM_HAL_STATUS_SUCCESS;

} // am_hal_mcuctrl_info_get()
   118bc:	bcf0      	pop	{r4, r5, r6, r7}
   118be:	4770      	bx	lr
        return AM_HAL_STATUS_INVALID_ARG;
   118c0:	2006      	movs	r0, #6
   118c2:	4770      	bx	lr
    ui32FaultStat = MCUCTRL->FAULTSTATUS;
   118c4:	4a41      	ldr	r2, [pc, #260]	; (119cc <am_hal_mcuctrl_info_get+0x120>)
    psFault->ui32ICODE |= MCUCTRL->ICODEFAULTADDR;
   118c6:	684c      	ldr	r4, [r1, #4]
    ui32FaultStat = MCUCTRL->FAULTSTATUS;
   118c8:	f8d2 31cc 	ldr.w	r3, [r2, #460]	; 0x1cc
    psFault->ui32SYS |= MCUCTRL->SYSFAULTADDR;
   118cc:	6948      	ldr	r0, [r1, #20]
    psFault->bICODE = (bool)(ui32FaultStat & MCUCTRL_FAULTSTATUS_ICODEFAULT_Msk);
   118ce:	f003 0601 	and.w	r6, r3, #1
    psFault->bDCODE = (bool)(ui32FaultStat & MCUCTRL_FAULTSTATUS_DCODEFAULT_Msk);
   118d2:	f3c3 0540 	ubfx	r5, r3, #1, #1
    psFault->bSYS   = (bool)(ui32FaultStat & MCUCTRL_FAULTSTATUS_SYSFAULT_Msk);
   118d6:	f3c3 0780 	ubfx	r7, r3, #2, #1
    psFault->bDCODE = (bool)(ui32FaultStat & MCUCTRL_FAULTSTATUS_DCODEFAULT_Msk);
   118da:	720d      	strb	r5, [r1, #8]
    psFault->bSYS   = (bool)(ui32FaultStat & MCUCTRL_FAULTSTATUS_SYSFAULT_Msk);
   118dc:	740f      	strb	r7, [r1, #16]
    psFault->bICODE = (bool)(ui32FaultStat & MCUCTRL_FAULTSTATUS_ICODEFAULT_Msk);
   118de:	700e      	strb	r6, [r1, #0]
    psFault->ui32DCODE = MCUCTRL->DCODEFAULTADDR;
   118e0:	f8d2 31c4 	ldr.w	r3, [r2, #452]	; 0x1c4
   118e4:	60cb      	str	r3, [r1, #12]
    psFault->ui32ICODE |= MCUCTRL->ICODEFAULTADDR;
   118e6:	f8d2 61c0 	ldr.w	r6, [r2, #448]	; 0x1c0
   118ea:	4334      	orrs	r4, r6
   118ec:	604c      	str	r4, [r1, #4]
    psFault->ui32SYS |= MCUCTRL->SYSFAULTADDR;
   118ee:	f8d2 21c8 	ldr.w	r2, [r2, #456]	; 0x1c8
   118f2:	4310      	orrs	r0, r2
   118f4:	6148      	str	r0, [r1, #20]
} // am_hal_mcuctrl_info_get()
   118f6:	bcf0      	pop	{r4, r5, r6, r7}
    return AM_HAL_STATUS_SUCCESS;
   118f8:	2000      	movs	r0, #0
} // am_hal_mcuctrl_info_get()
   118fa:	4770      	bx	lr
            ui32Feature = MCUCTRL->FEATUREENABLE;
   118fc:	4c33      	ldr	r4, [pc, #204]	; (119cc <am_hal_mcuctrl_info_get+0x120>)
   118fe:	69a5      	ldr	r5, [r4, #24]
                _FLD2VAL(MCUCTRL_FEATUREENABLE_BURSTAVAIL, ui32Feature);
   11900:	f3c5 1080 	ubfx	r0, r5, #6, #1
                _FLD2VAL(MCUCTRL_FEATUREENABLE_BLEAVAIL, ui32Feature);
   11904:	f3c5 0780 	ubfx	r7, r5, #2, #1
                _FLD2VAL(MCUCTRL_FEATUREENABLE_BURSTAVAIL, ui32Feature);
   11908:	7008      	strb	r0, [r1, #0]
                _FLD2VAL(MCUCTRL_FEATUREENABLE_BLEAVAIL, ui32Feature);
   1190a:	704f      	strb	r7, [r1, #1]
            ui32Feature = MCUCTRL->BOOTLOADER;
   1190c:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
                _FLD2VAL(MCUCTRL_BOOTLOADER_SECBOOTFEATURE, ui32Feature);
   11910:	f3c3 6681 	ubfx	r6, r3, #26, #2
            psFeature->ui8SecBootFeature =
   11914:	710e      	strb	r6, [r1, #4]
            ui32Feature = MCUCTRL->SKU;
   11916:	6964      	ldr	r4, [r4, #20]
                _FLD2VAL(MCUCTRL_SKU_ALLOWBLE, ui32Feature);
   11918:	f3c4 0240 	ubfx	r2, r4, #1, #1
                _FLD2VAL(MCUCTRL_SKU_ALLOWBURST, ui32Feature);
   1191c:	f004 0501 	and.w	r5, r4, #1
   11920:	70cd      	strb	r5, [r1, #3]
    return AM_HAL_STATUS_SUCCESS;
   11922:	2000      	movs	r0, #0
                _FLD2VAL(MCUCTRL_SKU_ALLOWBLE, ui32Feature);
   11924:	708a      	strb	r2, [r1, #2]
} // am_hal_mcuctrl_info_get()
   11926:	bcf0      	pop	{r4, r5, r6, r7}
   11928:	4770      	bx	lr
    psDevice->ui32ChipPN = MCUCTRL->CHIPPN;
   1192a:	4a28      	ldr	r2, [pc, #160]	; (119cc <am_hal_mcuctrl_info_get+0x120>)
        g_am_hal_mcuctrl_flash_size[
   1192c:	4c28      	ldr	r4, [pc, #160]	; (119d0 <am_hal_mcuctrl_info_get+0x124>)
    psDevice->ui32ChipPN = MCUCTRL->CHIPPN;
   1192e:	6813      	ldr	r3, [r2, #0]
   11930:	600b      	str	r3, [r1, #0]
    psDevice->ui32ChipID0 = MCUCTRL->CHIPID0;
   11932:	6850      	ldr	r0, [r2, #4]
   11934:	6048      	str	r0, [r1, #4]
    psDevice->ui32ChipID1 = MCUCTRL->CHIPID1;
   11936:	6897      	ldr	r7, [r2, #8]
   11938:	608f      	str	r7, [r1, #8]
    psDevice->ui32ChipRev = MCUCTRL->CHIPREV;
   1193a:	68d6      	ldr	r6, [r2, #12]
   1193c:	60ce      	str	r6, [r1, #12]
    psDevice->ui32VendorID = MCUCTRL->VENDORID;
   1193e:	6915      	ldr	r5, [r2, #16]
        g_am_hal_mcuctrl_sram_size[
   11940:	4824      	ldr	r0, [pc, #144]	; (119d4 <am_hal_mcuctrl_info_get+0x128>)
    psDevice->ui32VendorID = MCUCTRL->VENDORID;
   11942:	610d      	str	r5, [r1, #16]
            (psDevice->ui32ChipPN & MCUCTRL_CHIPPN_PARTNUM_FLASHSIZE_M) >>
   11944:	f3c3 5c03 	ubfx	ip, r3, #20, #4
            (psDevice->ui32ChipPN & MCUCTRL_CHIPPN_PARTNUM_SRAMSIZE_M) >>
   11948:	f3c3 4703 	ubfx	r7, r3, #16, #4
    psDevice->ui32SKU = MCUCTRL->SKU;
   1194c:	6956      	ldr	r6, [r2, #20]
    psDevice->ui32SRAMSize =
   1194e:	f850 5027 	ldr.w	r5, [r0, r7, lsl #2]
    psDevice->ui32JedecPN  = JEDEC->PID0_b.PNL8 << 0;
   11952:	4a21      	ldr	r2, [pc, #132]	; (119d8 <am_hal_mcuctrl_info_get+0x12c>)
    psDevice->ui32FlashSize =
   11954:	f854 402c 	ldr.w	r4, [r4, ip, lsl #2]
    psDevice->ui32SKU = MCUCTRL->SKU;
   11958:	614e      	str	r6, [r1, #20]
    psDevice->ui32Qualified = (psDevice->ui32ChipPN >> MCUCTRL_CHIPPN_PARTNUM_QUAL_S) & 0x1;
   1195a:	f003 0301 	and.w	r3, r3, #1
    psDevice->ui32FlashSize =
   1195e:	61cc      	str	r4, [r1, #28]
    psDevice->ui32SRAMSize =
   11960:	620d      	str	r5, [r1, #32]
    psDevice->ui32Qualified = (psDevice->ui32ChipPN >> MCUCTRL_CHIPPN_PARTNUM_QUAL_S) & 0x1;
   11962:	618b      	str	r3, [r1, #24]
    psDevice->ui32JedecPN  = JEDEC->PID0_b.PNL8 << 0;
   11964:	f8d2 70e0 	ldr.w	r7, [r2, #224]	; 0xe0
    psDevice->ui32JedecPN |= JEDEC->PID1_b.PNH4 << 8;
   11968:	f8d2 00e4 	ldr.w	r0, [r2, #228]	; 0xe4
    psDevice->ui32JedecPN  = JEDEC->PID0_b.PNL8 << 0;
   1196c:	b2fe      	uxtb	r6, r7
    psDevice->ui32JedecPN |= JEDEC->PID1_b.PNH4 << 8;
   1196e:	f000 040f 	and.w	r4, r0, #15
   11972:	ea46 2504 	orr.w	r5, r6, r4, lsl #8
   11976:	624d      	str	r5, [r1, #36]	; 0x24
    psDevice->ui32JedecJEPID  = JEDEC->PID1_b.JEPIDL << 0;
   11978:	f8d2 30e4 	ldr.w	r3, [r2, #228]	; 0xe4
    psDevice->ui32JedecJEPID |= JEDEC->PID2_b.JEPIDH << 4;
   1197c:	f8d2 70e8 	ldr.w	r7, [r2, #232]	; 0xe8
    psDevice->ui32JedecJEPID  = JEDEC->PID1_b.JEPIDL << 0;
   11980:	f3c3 1603 	ubfx	r6, r3, #4, #4
    psDevice->ui32JedecJEPID |= JEDEC->PID2_b.JEPIDH << 4;
   11984:	f007 0c0f 	and.w	ip, r7, #15
   11988:	ea46 100c 	orr.w	r0, r6, ip, lsl #4
   1198c:	6288      	str	r0, [r1, #40]	; 0x28
    psDevice->ui32JedecCHIPREV  = JEDEC->PID2_b.CHIPREVH4 << 4;
   1198e:	f8d2 40e8 	ldr.w	r4, [r2, #232]	; 0xe8
    psDevice->ui32JedecCHIPREV |= JEDEC->PID3_b.CHIPREVL4 << 0;
   11992:	f8d2 50ec 	ldr.w	r5, [r2, #236]	; 0xec
    psDevice->ui32JedecCHIPREV  = JEDEC->PID2_b.CHIPREVH4 << 4;
   11996:	f004 03f0 	and.w	r3, r4, #240	; 0xf0
    psDevice->ui32JedecCHIPREV |= JEDEC->PID3_b.CHIPREVL4 << 0;
   1199a:	f3c5 1703 	ubfx	r7, r5, #4, #4
   1199e:	433b      	orrs	r3, r7
   119a0:	62cb      	str	r3, [r1, #44]	; 0x2c
    psDevice->ui32JedecCID  = JEDEC->CID3_b.CID << 24;
   119a2:	f8d2 60fc 	ldr.w	r6, [r2, #252]	; 0xfc
    psDevice->ui32JedecCID |= JEDEC->CID2_b.CID << 16;
   119a6:	f8d2 40f8 	ldr.w	r4, [r2, #248]	; 0xf8
    psDevice->ui32JedecCID |= JEDEC->CID1_b.CID <<  8;
   119aa:	f8d2 00f4 	ldr.w	r0, [r2, #244]	; 0xf4
    psDevice->ui32JedecCID |= JEDEC->CID0_b.CID <<  0;
   119ae:	f8d2 20f0 	ldr.w	r2, [r2, #240]	; 0xf0
    psDevice->ui32JedecCID |= JEDEC->CID2_b.CID << 16;
   119b2:	b2e5      	uxtb	r5, r4
   119b4:	042b      	lsls	r3, r5, #16
   119b6:	ea43 6706 	orr.w	r7, r3, r6, lsl #24
    psDevice->ui32JedecCID |= JEDEC->CID0_b.CID <<  0;
   119ba:	b2d6      	uxtb	r6, r2
   119bc:	4337      	orrs	r7, r6
    psDevice->ui32JedecCID |= JEDEC->CID1_b.CID <<  8;
   119be:	b2c4      	uxtb	r4, r0
    psDevice->ui32JedecCID |= JEDEC->CID0_b.CID <<  0;
   119c0:	ea47 2004 	orr.w	r0, r7, r4, lsl #8
   119c4:	6308      	str	r0, [r1, #48]	; 0x30
    return AM_HAL_STATUS_SUCCESS;
   119c6:	2000      	movs	r0, #0
} // am_hal_mcuctrl_info_get()
   119c8:	bcf0      	pop	{r4, r5, r6, r7}
   119ca:	4770      	bx	lr
   119cc:	40020000 	.word	0x40020000
   119d0:	00013458 	.word	0x00013458
   119d4:	00013498 	.word	0x00013498
   119d8:	f0000f00 	.word	0xf0000f00

000119dc <am_hal_pwrctrl_periph_enable>:
//  Enable power for a peripheral.
//
// ****************************************************************************
uint32_t
am_hal_pwrctrl_periph_enable(am_hal_pwrctrl_periph_e ePeripheral)
{
   119dc:	b570      	push	{r4, r5, r6, lr}
   119de:	b082      	sub	sp, #8
   119e0:	4604      	mov	r4, r0
// #### INTERNAL END ####

    //
    // Enable power control for the given device.
    //
    AM_CRITICAL_BEGIN
   119e2:	f7ff ff07 	bl	117f4 <am_hal_interrupt_master_disable>
    PWRCTRL->DEVPWREN |= am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphEnable;
   119e6:	eb04 0144 	add.w	r1, r4, r4, lsl #1
   119ea:	008c      	lsls	r4, r1, #2
   119ec:	4e0e      	ldr	r6, [pc, #56]	; (11a28 <am_hal_pwrctrl_periph_enable+0x4c>)
   119ee:	4d0f      	ldr	r5, [pc, #60]	; (11a2c <am_hal_pwrctrl_periph_enable+0x50>)
    AM_CRITICAL_BEGIN
   119f0:	9001      	str	r0, [sp, #4]
    PWRCTRL->DEVPWREN |= am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphEnable;
   119f2:	592a      	ldr	r2, [r5, r4]
   119f4:	68b3      	ldr	r3, [r6, #8]
   119f6:	4313      	orrs	r3, r2
   119f8:	60b3      	str	r3, [r6, #8]
    AM_CRITICAL_END
   119fa:	9801      	ldr	r0, [sp, #4]

    for (uint32_t wait_usecs = 0; wait_usecs < AM_HAL_PWRCTRL_MAX_WFE; wait_usecs += 10)
    {
        am_hal_flash_delay(FLASH_CYCLES_US(10));

        if ( (PWRCTRL->DEVPWRSTATUS & am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphStatus) > 0)
   119fc:	442c      	add	r4, r5
    AM_CRITICAL_END
   119fe:	f7ff fefd 	bl	117fc <am_hal_interrupt_master_set>
        am_hal_flash_delay(FLASH_CYCLES_US(10));
   11a02:	2077      	movs	r0, #119	; 0x77
   11a04:	f7ff fc36 	bl	11274 <am_hal_flash_delay>
        if ( (PWRCTRL->DEVPWRSTATUS & am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphStatus) > 0)
   11a08:	69b0      	ldr	r0, [r6, #24]
   11a0a:	6864      	ldr	r4, [r4, #4]
   11a0c:	4220      	tst	r0, r4
   11a0e:	d103      	bne.n	11a18 <am_hal_pwrctrl_periph_enable+0x3c>
        am_hal_flash_delay(FLASH_CYCLES_US(10));
   11a10:	2077      	movs	r0, #119	; 0x77
   11a12:	f7ff fc2f 	bl	11274 <am_hal_flash_delay>
        if ( (PWRCTRL->DEVPWRSTATUS & am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphStatus) > 0)
   11a16:	69b3      	ldr	r3, [r6, #24]
    }

    //
    // Check the device status.
    //
    if ( (PWRCTRL->DEVPWRSTATUS & am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphStatus) > 0 )
   11a18:	4903      	ldr	r1, [pc, #12]	; (11a28 <am_hal_pwrctrl_periph_enable+0x4c>)
   11a1a:	698d      	ldr	r5, [r1, #24]
   11a1c:	4225      	tst	r5, r4
    else
    {
        return AM_HAL_STATUS_FAIL;
    }
#endif // AM_CMSIS_REGS
}
   11a1e:	bf0c      	ite	eq
   11a20:	2001      	moveq	r0, #1
   11a22:	2000      	movne	r0, #0
   11a24:	b002      	add	sp, #8
   11a26:	bd70      	pop	{r4, r5, r6, pc}
   11a28:	40021000 	.word	0x40021000
   11a2c:	00013640 	.word	0x00013640

00011a30 <am_hal_pwrctrl_periph_disable>:
//  Disable power for a peripheral.
//
// ****************************************************************************
uint32_t
am_hal_pwrctrl_periph_disable(am_hal_pwrctrl_periph_e ePeripheral)
{
   11a30:	b570      	push	{r4, r5, r6, lr}
   11a32:	b082      	sub	sp, #8
   11a34:	4604      	mov	r4, r0

    //
    // Disable power domain for the given device.
    //
#if AM_CMSIS_REGS
    AM_CRITICAL_BEGIN
   11a36:	f7ff fedd 	bl	117f4 <am_hal_interrupt_master_disable>
    PWRCTRL->DEVPWREN &= ~am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphEnable;
   11a3a:	eb04 0144 	add.w	r1, r4, r4, lsl #1
   11a3e:	008c      	lsls	r4, r1, #2
   11a40:	4e0f      	ldr	r6, [pc, #60]	; (11a80 <am_hal_pwrctrl_periph_disable+0x50>)
   11a42:	4d10      	ldr	r5, [pc, #64]	; (11a84 <am_hal_pwrctrl_periph_disable+0x54>)
    AM_CRITICAL_BEGIN
   11a44:	9001      	str	r0, [sp, #4]
    PWRCTRL->DEVPWREN &= ~am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphEnable;
   11a46:	68b3      	ldr	r3, [r6, #8]
   11a48:	592a      	ldr	r2, [r5, r4]
   11a4a:	ea23 0002 	bic.w	r0, r3, r2
   11a4e:	60b0      	str	r0, [r6, #8]
    AM_CRITICAL_END
   11a50:	9801      	ldr	r0, [sp, #4]
    for (uint32_t wait_usecs = 0; wait_usecs < AM_HAL_PWRCTRL_MAX_WFE; wait_usecs += 10)
    {
        am_hal_flash_delay(FLASH_CYCLES_US(10));

#if AM_CMSIS_REGS
        if ( (PWRCTRL->DEVPWRSTATUS & am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphStatus) == 0 )
   11a52:	442c      	add	r4, r5
    AM_CRITICAL_END
   11a54:	f7ff fed2 	bl	117fc <am_hal_interrupt_master_set>
        am_hal_flash_delay(FLASH_CYCLES_US(10));
   11a58:	2077      	movs	r0, #119	; 0x77
   11a5a:	f7ff fc0b 	bl	11274 <am_hal_flash_delay>
        if ( (PWRCTRL->DEVPWRSTATUS & am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphStatus) == 0 )
   11a5e:	69b1      	ldr	r1, [r6, #24]
   11a60:	6864      	ldr	r4, [r4, #4]
   11a62:	4221      	tst	r1, r4
   11a64:	d003      	beq.n	11a6e <am_hal_pwrctrl_periph_disable+0x3e>
        am_hal_flash_delay(FLASH_CYCLES_US(10));
   11a66:	2077      	movs	r0, #119	; 0x77
   11a68:	f7ff fc04 	bl	11274 <am_hal_flash_delay>
        if ( (PWRCTRL->DEVPWRSTATUS & am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphStatus) == 0 )
   11a6c:	69b3      	ldr	r3, [r6, #24]

    //
    // Check the device status.
    //
#if AM_CMSIS_REGS
    if ( ( PWRCTRL->DEVPWRSTATUS & am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphStatus) == 0 )
   11a6e:	4d04      	ldr	r5, [pc, #16]	; (11a80 <am_hal_pwrctrl_periph_disable+0x50>)
   11a70:	69ae      	ldr	r6, [r5, #24]
   11a72:	4226      	tst	r6, r4
#endif // AM_CMSIS_REGS
    else
    {
        return AM_HAL_STATUS_FAIL;
    }
}
   11a74:	bf14      	ite	ne
   11a76:	2001      	movne	r0, #1
   11a78:	2000      	moveq	r0, #0
   11a7a:	b002      	add	sp, #8
   11a7c:	bd70      	pop	{r4, r5, r6, pc}
   11a7e:	bf00      	nop
   11a80:	40021000 	.word	0x40021000
   11a84:	00013640 	.word	0x00013640

00011a88 <am_hal_pwrctrl_memory_enable>:
//  Enable a configuration of memory.
//
// ****************************************************************************
uint32_t
am_hal_pwrctrl_memory_enable(am_hal_pwrctrl_mem_e eMemConfig)
{
   11a88:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
#if 0
    uint32_t ui32MemEventMask;
#endif
// #### INTERNAL END ####

    ui32MemEnMask     =  am_hal_pwrctrl_memory_control[eMemConfig].ui32MemoryEnable;
   11a8c:	ea4f 0980 	mov.w	r9, r0, lsl #2
   11a90:	eb09 0300 	add.w	r3, r9, r0
   11a94:	4f1e      	ldr	r7, [pc, #120]	; (11b10 <am_hal_pwrctrl_memory_enable+0x88>)
{
   11a96:	4604      	mov	r4, r0
    ui32MemEnMask     =  am_hal_pwrctrl_memory_control[eMemConfig].ui32MemoryEnable;
   11a98:	0098      	lsls	r0, r3, #2
   11a9a:	183a      	adds	r2, r7, r0
   11a9c:	583d      	ldr	r5, [r7, r0]
#if 0
    ui32MemEventMask  = am_hal_pwrctrl_memory_control[eMemConfig].ui32MemoryEvent;
#endif
// #### INTERNAL END ####
    ui32MemRegionMask = am_hal_pwrctrl_memory_control[eMemConfig].ui32MemoryMask;
    ui32MemStatusMask = am_hal_pwrctrl_memory_control[eMemConfig].ui32StatusMask;
   11a9e:	6916      	ldr	r6, [r2, #16]
    //
    // Note that a deliberate disable step using a disable mask is taken here
    // for 2 reasons: 1) To only affect the specified type of memory, and 2)
    // To avoid inadvertently disabling any memory currently being depended on.
    //
    if ( ui32MemDisMask != 0 )
   11aa0:	43eb      	mvns	r3, r5
   11aa2:	d126      	bne.n	11af2 <am_hal_pwrctrl_memory_enable+0x6a>
// #### INTERNAL END ####

    //
    // Enable the required memory.
    //
    if ( ui32MemEnMask != 0 )
   11aa4:	b965      	cbnz	r5, 11ac0 <am_hal_pwrctrl_memory_enable+0x38>
   11aa6:	444c      	add	r4, r9
   11aa8:	eb07 0c84 	add.w	ip, r7, r4, lsl #2
   11aac:	f8dc 5004 	ldr.w	r5, [ip, #4]

    //
    // Return status based on whether the power control memory status has reached the desired state.
    //
#if AM_CMSIS_REGS
    if ( ( PWRCTRL->MEMPWRSTATUS & ui32MemStatusMask) ==
   11ab0:	4918      	ldr	r1, [pc, #96]	; (11b14 <am_hal_pwrctrl_memory_enable+0x8c>)
   11ab2:	694a      	ldr	r2, [r1, #20]
   11ab4:	4032      	ands	r2, r6
#endif // AM_CMSIS_REGS
    else
    {
        return AM_HAL_STATUS_FAIL;
    }
}
   11ab6:	1b50      	subs	r0, r2, r5
   11ab8:	bf18      	it	ne
   11aba:	2001      	movne	r0, #1
   11abc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        PWRCTRL->MEMPWREN |= ui32MemEnMask;
   11ac0:	f8df 8050 	ldr.w	r8, [pc, #80]	; 11b14 <am_hal_pwrctrl_memory_enable+0x8c>
   11ac4:	f8d8 0010 	ldr.w	r0, [r8, #16]
                  am_hal_pwrctrl_memory_control[eMemConfig].ui32MemoryStatus )
   11ac8:	444c      	add	r4, r9
        PWRCTRL->MEMPWREN |= ui32MemEnMask;
   11aca:	4305      	orrs	r5, r0
   11acc:	f8c8 5010 	str.w	r5, [r8, #16]
                  am_hal_pwrctrl_memory_control[eMemConfig].ui32MemoryStatus )
   11ad0:	eb07 0484 	add.w	r4, r7, r4, lsl #2
            am_hal_flash_delay(FLASH_CYCLES_US(10));
   11ad4:	2077      	movs	r0, #119	; 0x77
   11ad6:	f7ff fbcd 	bl	11274 <am_hal_flash_delay>
            if ( (PWRCTRL->MEMPWRSTATUS & ui32MemStatusMask) ==
   11ada:	f8d8 7014 	ldr.w	r7, [r8, #20]
                  am_hal_pwrctrl_memory_control[eMemConfig].ui32MemoryStatus )
   11ade:	6865      	ldr	r5, [r4, #4]
            if ( (PWRCTRL->MEMPWRSTATUS & ui32MemStatusMask) ==
   11ae0:	4037      	ands	r7, r6
   11ae2:	42af      	cmp	r7, r5
   11ae4:	d0e4      	beq.n	11ab0 <am_hal_pwrctrl_memory_enable+0x28>
            am_hal_flash_delay(FLASH_CYCLES_US(10));
   11ae6:	2077      	movs	r0, #119	; 0x77
   11ae8:	f7ff fbc4 	bl	11274 <am_hal_flash_delay>
            if ( (PWRCTRL->MEMPWRSTATUS & ui32MemStatusMask) ==
   11aec:	f8d8 3014 	ldr.w	r3, [r8, #20]
   11af0:	e7de      	b.n	11ab0 <am_hal_pwrctrl_memory_enable+0x28>
            ~(ui32MemDisMask & ui32MemRegionMask)                                   |
   11af2:	68d0      	ldr	r0, [r2, #12]
        PWRCTRL->MEMPWREN &=
   11af4:	4907      	ldr	r1, [pc, #28]	; (11b14 <am_hal_pwrctrl_memory_enable+0x8c>)
            ~(ui32MemDisMask & ui32MemRegionMask)                                   |
   11af6:	4003      	ands	r3, r0
        PWRCTRL->MEMPWREN &=
   11af8:	690a      	ldr	r2, [r1, #16]
            ~(ui32MemDisMask & ui32MemRegionMask)                                   |
   11afa:	f242 0801 	movw	r8, #8193	; 0x2001
   11afe:	ea68 0303 	orn	r3, r8, r3
        PWRCTRL->MEMPWREN &=
   11b02:	4013      	ands	r3, r2
   11b04:	610b      	str	r3, [r1, #16]
        am_hal_flash_delay(FLASH_CYCLES_US(1));
   11b06:	2001      	movs	r0, #1
   11b08:	f7ff fbb4 	bl	11274 <am_hal_flash_delay>
   11b0c:	e7ca      	b.n	11aa4 <am_hal_pwrctrl_memory_enable+0x1c>
   11b0e:	bf00      	nop
   11b10:	000134d8 	.word	0x000134d8
   11b14:	40021000 	.word	0x40021000

00011b18 <am_hal_pwrctrl_low_power_init>:
//  Initialize system for low power configuration.
//
// ****************************************************************************
uint32_t
am_hal_pwrctrl_low_power_init(void)
{
   11b18:	b530      	push	{r4, r5, lr}

#if AM_CMSIS_REGS
    //
    // Check if the BLE is already enabled.
    //
    if ( PWRCTRL->DEVPWRSTATUS_b.BLEL == 0)
   11b1a:	4c1b      	ldr	r4, [pc, #108]	; (11b88 <am_hal_pwrctrl_low_power_init+0x70>)
   11b1c:	69a3      	ldr	r3, [r4, #24]
   11b1e:	05db      	lsls	r3, r3, #23
{
   11b20:	b083      	sub	sp, #12
    if ( PWRCTRL->DEVPWRSTATUS_b.BLEL == 0)
   11b22:	d502      	bpl.n	11b2a <am_hal_pwrctrl_low_power_init+0x12>
            AM_BFW(MCUCTRL, BLEBUCK2,  BLEBUCKTONLOWTRIM, 0xF);
        }
    }
#endif // AM_CMSIS_REGS

    return AM_HAL_STATUS_SUCCESS;
   11b24:	2000      	movs	r0, #0
}
   11b26:	b003      	add	sp, #12
   11b28:	bd30      	pop	{r4, r5, pc}
        MCUCTRL->FEATUREENABLE = MCUCTRL_FEATUREENABLE_BLEREQ_Msk;
   11b2a:	4d18      	ldr	r5, [pc, #96]	; (11b8c <am_hal_pwrctrl_low_power_init+0x74>)
        ui32Status = am_hal_flash_delay_status_check(10000,
   11b2c:	4918      	ldr	r1, [pc, #96]	; (11b90 <am_hal_pwrctrl_low_power_init+0x78>)
        MCUCTRL->FEATUREENABLE = MCUCTRL_FEATUREENABLE_BLEREQ_Msk;
   11b2e:	2001      	movs	r0, #1
        ui32Status = am_hal_flash_delay_status_check(10000,
   11b30:	2307      	movs	r3, #7
        MCUCTRL->FEATUREENABLE = MCUCTRL_FEATUREENABLE_BLEREQ_Msk;
   11b32:	61a8      	str	r0, [r5, #24]
        ui32Status = am_hal_flash_delay_status_check(10000,
   11b34:	461a      	mov	r2, r3
   11b36:	9000      	str	r0, [sp, #0]
   11b38:	f242 7010 	movw	r0, #10000	; 0x2710
   11b3c:	f7ff fb9e 	bl	1127c <am_hal_flash_delay_status_check>
        if (AM_HAL_STATUS_SUCCESS != ui32Status)
   11b40:	b110      	cbz	r0, 11b48 <am_hal_pwrctrl_low_power_init+0x30>
            return AM_HAL_STATUS_TIMEOUT;
   11b42:	2004      	movs	r0, #4
}
   11b44:	b003      	add	sp, #12
   11b46:	bd30      	pop	{r4, r5, pc}
        PWRCTRL->SUPPLYSRC |= _VAL2FLD(PWRCTRL_SUPPLYSRC_BLEBUCKEN,
   11b48:	6821      	ldr	r1, [r4, #0]
   11b4a:	f041 0201 	orr.w	r2, r1, #1
   11b4e:	6022      	str	r2, [r4, #0]
        PWRCTRL->MISC |= _VAL2FLD(PWRCTRL_MISC_MEMVRLPBLE,
   11b50:	6a63      	ldr	r3, [r4, #36]	; 0x24
   11b52:	f043 0140 	orr.w	r1, r3, #64	; 0x40
   11b56:	6261      	str	r1, [r4, #36]	; 0x24
        if ( APOLLO3_A0 )
   11b58:	68ec      	ldr	r4, [r5, #12]
   11b5a:	b2e2      	uxtb	r2, r4
   11b5c:	2a11      	cmp	r2, #17
   11b5e:	d1e1      	bne.n	11b24 <am_hal_pwrctrl_low_power_init+0xc>
            MCUCTRL->SIMOBUCK4_b.SIMOBUCKCLKDIVSEL = 0x0;
   11b60:	f8d5 335c 	ldr.w	r3, [r5, #860]	; 0x35c
   11b64:	f360 5356 	bfi	r3, r0, #21, #2
   11b68:	f8c5 335c 	str.w	r3, [r5, #860]	; 0x35c
            MCUCTRL->BLEBUCK2_b.BLEBUCKTONHITRIM   = 0xF;
   11b6c:	f8d5 1368 	ldr.w	r1, [r5, #872]	; 0x368
   11b70:	240f      	movs	r4, #15
   11b72:	f364 118b 	bfi	r1, r4, #6, #6
   11b76:	f8c5 1368 	str.w	r1, [r5, #872]	; 0x368
            MCUCTRL->BLEBUCK2_b.BLEBUCKTONLOWTRIM  = 0xF;
   11b7a:	f8d5 2368 	ldr.w	r2, [r5, #872]	; 0x368
   11b7e:	f364 0205 	bfi	r2, r4, #0, #6
   11b82:	f8c5 2368 	str.w	r2, [r5, #872]	; 0x368
   11b86:	e7ce      	b.n	11b26 <am_hal_pwrctrl_low_power_init+0xe>
   11b88:	40021000 	.word	0x40021000
   11b8c:	40020000 	.word	0x40020000
   11b90:	40020018 	.word	0x40020018

00011b94 <am_hal_rtc_osc_select>:
#if AM_CMSIS_REGS
#if 1//USE_CLKGEN
    if ( ui32OSC == AM_HAL_RTC_OSC_LFRC )
    {
        // Set bit to 1 for LFRC
        CLKGEN->OCTRL |= CLKGEN_OCTRL_OSEL_Msk;
   11b94:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
    if ( ui32OSC == AM_HAL_RTC_OSC_LFRC )
   11b98:	2801      	cmp	r0, #1
        CLKGEN->OCTRL |= CLKGEN_OCTRL_OSEL_Msk;
   11b9a:	68d3      	ldr	r3, [r2, #12]
   11b9c:	bf0c      	ite	eq
   11b9e:	f043 0380 	orreq.w	r3, r3, #128	; 0x80
    }
    else
    {
        // Clear bit to 0 for XTAL
        CLKGEN->OCTRL &= ~CLKGEN_OCTRL_OSEL_Msk;
   11ba2:	f023 0380 	bicne.w	r3, r3, #128	; 0x80
   11ba6:	60d3      	str	r3, [r2, #12]
   11ba8:	4770      	bx	lr
   11baa:	bf00      	nop

00011bac <am_hal_rtc_osc_disable>:
    //
#if AM_CMSIS_REGS
#if USE_CLKGEN
    CLKGEN->RTCCTL_b.RSTOP = 1;
#else
    RTC->RTCCTL_b.RSTOP = 1;
   11bac:	4a03      	ldr	r2, [pc, #12]	; (11bbc <am_hal_rtc_osc_disable+0x10>)
   11bae:	f892 3050 	ldrb.w	r3, [r2, #80]	; 0x50
   11bb2:	f043 0010 	orr.w	r0, r3, #16
   11bb6:	f882 0050 	strb.w	r0, [r2, #80]	; 0x50
   11bba:	4770      	bx	lr
   11bbc:	40004200 	.word	0x40004200

00011bc0 <am_hal_sysctrl_fpu_enable>:
    //
    // Enable access to the FPU in both privileged and user modes.
    // NOTE: Write 0s to all reserved fields in this register.
    //
#if AM_CMSIS_REGS
    SCB->CPACR = _VAL2FLD(SCB_CPACR_CP11, 0x3) |
   11bc0:	4b02      	ldr	r3, [pc, #8]	; (11bcc <am_hal_sysctrl_fpu_enable+0xc>)
   11bc2:	f44f 0270 	mov.w	r2, #15728640	; 0xf00000
   11bc6:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
   11bca:	4770      	bx	lr
   11bcc:	e000ed00 	.word	0xe000ed00

00011bd0 <am_hal_sysctrl_fpu_stacking_enable>:
    {
        //
        // Enable automatic saving of FPU registers on exception entry, using lazy
        // context saving.
        //
        FPU->FPCCR |= _VAL2FLD(FPU_FPCCR_ASPEN, 1) |
   11bd0:	4a05      	ldr	r2, [pc, #20]	; (11be8 <am_hal_sysctrl_fpu_stacking_enable+0x18>)
   11bd2:	6853      	ldr	r3, [r2, #4]
    if ( bLazy )
   11bd4:	b918      	cbnz	r0, 11bde <am_hal_sysctrl_fpu_stacking_enable+0xe>
    else
    {
        //
        // Enable automatic saving of FPU registers on exception entry.
        //
        FPU->FPCCR |= _VAL2FLD(FPU_FPCCR_ASPEN, 1);
   11bd6:	f043 4000 	orr.w	r0, r3, #2147483648	; 0x80000000
   11bda:	6050      	str	r0, [r2, #4]
   11bdc:	4770      	bx	lr
        FPU->FPCCR |= _VAL2FLD(FPU_FPCCR_ASPEN, 1) |
   11bde:	f043 4140 	orr.w	r1, r3, #3221225472	; 0xc0000000
   11be2:	6051      	str	r1, [r2, #4]
   11be4:	4770      	bx	lr
   11be6:	bf00      	nop
   11be8:	e000ef30 	.word	0xe000ef30

00011bec <am_hal_systick_start>:
{
    //
    // Start the systick timer.
    //
#if AM_CMSIS_REGS
    SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk;
   11bec:	4a02      	ldr	r2, [pc, #8]	; (11bf8 <am_hal_systick_start+0xc>)
   11bee:	6813      	ldr	r3, [r2, #0]
   11bf0:	f043 0001 	orr.w	r0, r3, #1
   11bf4:	6010      	str	r0, [r2, #0]
   11bf6:	4770      	bx	lr
   11bf8:	e000e010 	.word	0xe000e010

00011bfc <am_hal_systick_stop>:
{
    //
    // Stop the systick timer.
    //
#if AM_CMSIS_REGS
    SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
   11bfc:	4a02      	ldr	r2, [pc, #8]	; (11c08 <am_hal_systick_stop+0xc>)
   11bfe:	6813      	ldr	r3, [r2, #0]
   11c00:	f023 0001 	bic.w	r0, r3, #1
   11c04:	6010      	str	r0, [r2, #0]
   11c06:	4770      	bx	lr
   11c08:	e000e010 	.word	0xe000e010

00011c0c <am_hal_systick_int_enable>:
{
    //
    // Enable the systick timer interrupt.
    //
#if AM_CMSIS_REGS
    SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk;
   11c0c:	4a02      	ldr	r2, [pc, #8]	; (11c18 <am_hal_systick_int_enable+0xc>)
   11c0e:	6813      	ldr	r3, [r2, #0]
   11c10:	f043 0002 	orr.w	r0, r3, #2
   11c14:	6010      	str	r0, [r2, #0]
   11c16:	4770      	bx	lr
   11c18:	e000e010 	.word	0xe000e010

00011c1c <am_hal_systick_load>:
    //      3. Program CSR
    // Write the given value to the reload register.
    // Write the Current Value Register to clear it to 0.
    //
#if AM_CMSIS_REGS
    SysTick->LOAD = ui32LoadVal;
   11c1c:	4b02      	ldr	r3, [pc, #8]	; (11c28 <am_hal_systick_load+0xc>)
    SysTick->VAL = 0;
   11c1e:	2200      	movs	r2, #0
    SysTick->LOAD = ui32LoadVal;
   11c20:	6058      	str	r0, [r3, #4]
    SysTick->VAL = 0;
   11c22:	609a      	str	r2, [r3, #8]
   11c24:	4770      	bx	lr
   11c26:	bf00      	nop
   11c28:	e000e010 	.word	0xe000e010

00011c2c <am_hal_systick_count>:
{
    //
    // Return the current systick timer count value.
    //
#if AM_CMSIS_REGS
    return SysTick->VAL;
   11c2c:	4b01      	ldr	r3, [pc, #4]	; (11c34 <am_hal_systick_count+0x8>)
   11c2e:	6898      	ldr	r0, [r3, #8]
#else // AM_CMSIS_REGS
    return AM_REG(SYSTICK, SYSTCVR);
#endif // AM_CMSIS_REGS
}
   11c30:	4770      	bx	lr
   11c32:	bf00      	nop
   11c34:	e000e010 	.word	0xe000e010

00011c38 <am_hal_uart_initialize>:
am_hal_uart_initialize(uint32_t ui32Module, void **ppHandle)
{
    //
    // Check that the request module is in range.
    //
    if (ui32Module >= AM_REG_UART_NUM_MODULES )
   11c38:	2801      	cmp	r0, #1
   11c3a:	d901      	bls.n	11c40 <am_hal_uart_initialize+0x8>
    {
        return AM_HAL_STATUS_OUT_OF_RANGE;
   11c3c:	2005      	movs	r0, #5
   11c3e:	4770      	bx	lr
    }

    //
    // Check for valid arguements.
    //
    if (!ppHandle)
   11c40:	b169      	cbz	r1, 11c5e <am_hal_uart_initialize+0x26>
{
   11c42:	b5f0      	push	{r4, r5, r6, r7, lr}
    }

    //
    // Check if the handle is unallocated.
    //
    if (g_am_hal_uart_states[ui32Module].prefix.s.bInit)
   11c44:	2264      	movs	r2, #100	; 0x64
   11c46:	4e0e      	ldr	r6, [pc, #56]	; (11c80 <am_hal_uart_initialize+0x48>)
   11c48:	fb02 f200 	mul.w	r2, r2, r0
   11c4c:	18b4      	adds	r4, r6, r2
   11c4e:	4603      	mov	r3, r0
   11c50:	78e0      	ldrb	r0, [r4, #3]
   11c52:	f3c0 0700 	ubfx	r7, r0, #0, #1
   11c56:	b2fd      	uxtb	r5, r7
   11c58:	b11d      	cbz	r5, 11c62 <am_hal_uart_initialize+0x2a>
    {
        return AM_HAL_STATUS_INVALID_OPERATION;
   11c5a:	2007      	movs	r0, #7

    //
    // Return the status.
    //
    return AM_HAL_STATUS_SUCCESS;
} // am_hal_uart_initialize()
   11c5c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return AM_HAL_STATUS_INVALID_ARG;
   11c5e:	2006      	movs	r0, #6
   11c60:	4770      	bx	lr
    g_am_hal_uart_states[ui32Module].prefix.s.bInit = true;
   11c62:	f040 0001 	orr.w	r0, r0, #1
   11c66:	70e0      	strb	r0, [r4, #3]
    g_am_hal_uart_states[ui32Module].prefix.s.magic = AM_HAL_MAGIC_UART;
   11c68:	58b0      	ldr	r0, [r6, r2]
   11c6a:	f8df e018 	ldr.w	lr, [pc, #24]	; 11c84 <am_hal_uart_initialize+0x4c>
   11c6e:	f36e 0017 	bfi	r0, lr, #0, #24
   11c72:	50b0      	str	r0, [r6, r2]
    g_am_hal_uart_states[ui32Module].ui32Module = ui32Module;
   11c74:	6263      	str	r3, [r4, #36]	; 0x24
    g_am_hal_uart_states[ui32Module].sRegState.bValid = false;
   11c76:	7127      	strb	r7, [r4, #4]
    g_am_hal_uart_states[ui32Module].ui32BaudRate = 0;
   11c78:	6625      	str	r5, [r4, #96]	; 0x60
    return AM_HAL_STATUS_SUCCESS;
   11c7a:	4628      	mov	r0, r5
    *ppHandle = (void *)&g_am_hal_uart_states[ui32Module];
   11c7c:	600c      	str	r4, [r1, #0]
    return AM_HAL_STATUS_SUCCESS;
   11c7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11c80:	1000157c 	.word	0x1000157c
   11c84:	00ea9e06 	.word	0x00ea9e06

00011c88 <am_hal_uart_deinitialize>:
    am_hal_uart_state_t *pState = (am_hal_uart_state_t *)pHandle;

    //
    // Check the handle.
    //
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11c88:	b128      	cbz	r0, 11c96 <am_hal_uart_deinitialize+0xe>
   11c8a:	6803      	ldr	r3, [r0, #0]
   11c8c:	4a07      	ldr	r2, [pc, #28]	; (11cac <am_hal_uart_deinitialize+0x24>)
   11c8e:	f023 417e 	bic.w	r1, r3, #4261412864	; 0xfe000000
   11c92:	4291      	cmp	r1, r2
   11c94:	d001      	beq.n	11c9a <am_hal_uart_deinitialize+0x12>
    {
        return AM_HAL_STATUS_INVALID_HANDLE;
   11c96:	2002      	movs	r0, #2

    //
    // Return the status.
    //
    return AM_HAL_STATUS_SUCCESS;
} // am_hal_uart_deinitialize()
   11c98:	4770      	bx	lr
    pState->prefix.s.bInit = false;
   11c9a:	78c2      	ldrb	r2, [r0, #3]
    pState->ui32Module = 0;
   11c9c:	2300      	movs	r3, #0
    pState->prefix.s.bInit = false;
   11c9e:	f36f 0200 	bfc	r2, #0, #1
   11ca2:	70c2      	strb	r2, [r0, #3]
    pState->ui32Module = 0;
   11ca4:	6243      	str	r3, [r0, #36]	; 0x24
    pState->sRegState.bValid = false;
   11ca6:	7103      	strb	r3, [r0, #4]
    return AM_HAL_STATUS_SUCCESS;
   11ca8:	4618      	mov	r0, r3
   11caa:	4770      	bx	lr
   11cac:	01ea9e06 	.word	0x01ea9e06

00011cb0 <am_hal_uart_power_control>:
//*****************************************************************************
uint32_t
am_hal_uart_power_control(void *pHandle,
                          am_hal_sysctrl_power_state_e ePowerState,
                          bool bRetainState)
{
   11cb0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
                                                 ui32Module));

    //
    // Check to make sure this is a valid handle.
    //
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11cb4:	6804      	ldr	r4, [r0, #0]
   11cb6:	4b36      	ldr	r3, [pc, #216]	; (11d90 <am_hal_uart_power_control+0xe0>)
   11cb8:	f024 447e 	bic.w	r4, r4, #4261412864	; 0xfe000000
   11cbc:	429c      	cmp	r4, r3
{
   11cbe:	b084      	sub	sp, #16
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11cc0:	d003      	beq.n	11cca <am_hal_uart_power_control+0x1a>
    {
        return AM_HAL_STATUS_INVALID_HANDLE;
   11cc2:	2002      	movs	r0, #2

    //
    // Return the status.
    //
    return AM_HAL_STATUS_SUCCESS;
} // am_hal_uart_power_control()
   11cc4:	b004      	add	sp, #16
   11cc6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    uint32_t ui32Module = pState->ui32Module;
   11cca:	6a47      	ldr	r7, [r0, #36]	; 0x24
   11ccc:	4605      	mov	r5, r0
    am_hal_pwrctrl_periph_e eUARTPowerModule = ((am_hal_pwrctrl_periph_e)
   11cce:	f107 0008 	add.w	r0, r7, #8
   11cd2:	460e      	mov	r6, r1
   11cd4:	fa5f f880 	uxtb.w	r8, r0
    switch (ePowerState)
   11cd8:	b181      	cbz	r1, 11cfc <am_hal_uart_power_control+0x4c>
   11cda:	2902      	cmp	r1, #2
   11cdc:	d80c      	bhi.n	11cf8 <am_hal_uart_power_control+0x48>
            if (bRetainState)
   11cde:	b992      	cbnz	r2, 11d06 <am_hal_uart_power_control+0x56>
    {
        return AM_HAL_STATUS_INVALID_HANDLE;
    }

#if AM_CMSIS_REGS
    UARTn(ui32Module)->IEC = ui32IntMask;
   11ce0:	f507 2480 	add.w	r4, r7, #262144	; 0x40000
   11ce4:	341c      	adds	r4, #28
   11ce6:	0325      	lsls	r5, r4, #12
   11ce8:	f04f 31ff 	mov.w	r1, #4294967295
   11cec:	6469      	str	r1, [r5, #68]	; 0x44
            am_hal_pwrctrl_periph_disable(eUARTPowerModule);
   11cee:	4640      	mov	r0, r8
   11cf0:	f7ff fe9e 	bl	11a30 <am_hal_pwrctrl_periph_disable>
    return AM_HAL_STATUS_SUCCESS;
   11cf4:	2000      	movs	r0, #0
            break;
   11cf6:	e7e5      	b.n	11cc4 <am_hal_uart_power_control+0x14>
            return AM_HAL_STATUS_INVALID_ARG;
   11cf8:	2006      	movs	r0, #6
   11cfa:	e7e3      	b.n	11cc4 <am_hal_uart_power_control+0x14>
            if (bRetainState && !pState->sRegState.bValid)
   11cfc:	b322      	cbz	r2, 11d48 <am_hal_uart_power_control+0x98>
   11cfe:	792a      	ldrb	r2, [r5, #4]
   11d00:	bb42      	cbnz	r2, 11d54 <am_hal_uart_power_control+0xa4>
                return AM_HAL_STATUS_INVALID_OPERATION;
   11d02:	2007      	movs	r0, #7
   11d04:	e7de      	b.n	11cc4 <am_hal_uart_power_control+0x14>
                AM_CRITICAL_BEGIN
   11d06:	f7ff fd75 	bl	117f4 <am_hal_interrupt_master_disable>
                pState->sRegState.regILPR = UARTn(ui32Module)->ILPR;
   11d0a:	f507 2180 	add.w	r1, r7, #262144	; 0x40000
   11d0e:	311c      	adds	r1, #28
   11d10:	030f      	lsls	r7, r1, #12
                AM_CRITICAL_BEGIN
   11d12:	9003      	str	r0, [sp, #12]
                pState->sRegState.regILPR = UARTn(ui32Module)->ILPR;
   11d14:	6a3a      	ldr	r2, [r7, #32]
   11d16:	60aa      	str	r2, [r5, #8]
                pState->sRegState.regIBRD = UARTn(ui32Module)->IBRD;
   11d18:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   11d1a:	60eb      	str	r3, [r5, #12]
                pState->sRegState.regFBRD = UARTn(ui32Module)->FBRD;
   11d1c:	6abe      	ldr	r6, [r7, #40]	; 0x28
   11d1e:	612e      	str	r6, [r5, #16]
                pState->sRegState.regLCRH = UARTn(ui32Module)->LCRH;
   11d20:	6af8      	ldr	r0, [r7, #44]	; 0x2c
   11d22:	6168      	str	r0, [r5, #20]
                pState->sRegState.regCR   = UARTn(ui32Module)->CR;
   11d24:	6b39      	ldr	r1, [r7, #48]	; 0x30
   11d26:	61a9      	str	r1, [r5, #24]
                pState->sRegState.regIFLS = UARTn(ui32Module)->IFLS;
   11d28:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   11d2a:	61ea      	str	r2, [r5, #28]
                pState->sRegState.regIER  = UARTn(ui32Module)->IER;
   11d2c:	6bbf      	ldr	r7, [r7, #56]	; 0x38
   11d2e:	622f      	str	r7, [r5, #32]
                pState->sRegState.bValid = true;
   11d30:	2301      	movs	r3, #1
                AM_CRITICAL_END
   11d32:	9803      	ldr	r0, [sp, #12]
                pState->sRegState.bValid = true;
   11d34:	712b      	strb	r3, [r5, #4]
                AM_CRITICAL_END
   11d36:	f7ff fd61 	bl	117fc <am_hal_interrupt_master_set>
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11d3a:	682e      	ldr	r6, [r5, #0]
   11d3c:	f026 407e 	bic.w	r0, r6, #4261412864	; 0xfe000000
   11d40:	42a0      	cmp	r0, r4
   11d42:	d1d4      	bne.n	11cee <am_hal_uart_power_control+0x3e>
    uint32_t ui32Module = pState->ui32Module;
   11d44:	6a6f      	ldr	r7, [r5, #36]	; 0x24
   11d46:	e7cb      	b.n	11ce0 <am_hal_uart_power_control+0x30>
            am_hal_pwrctrl_periph_enable(eUARTPowerModule);
   11d48:	4640      	mov	r0, r8
   11d4a:	9201      	str	r2, [sp, #4]
   11d4c:	f7ff fe46 	bl	119dc <am_hal_pwrctrl_periph_enable>
    return AM_HAL_STATUS_SUCCESS;
   11d50:	9801      	ldr	r0, [sp, #4]
   11d52:	e7b7      	b.n	11cc4 <am_hal_uart_power_control+0x14>
            am_hal_pwrctrl_periph_enable(eUARTPowerModule);
   11d54:	4640      	mov	r0, r8
   11d56:	f7ff fe41 	bl	119dc <am_hal_pwrctrl_periph_enable>
                AM_CRITICAL_BEGIN
   11d5a:	f7ff fd4b 	bl	117f4 <am_hal_interrupt_master_disable>
                UARTn(ui32Module)->ILPR = pState->sRegState.regILPR;
   11d5e:	f507 2380 	add.w	r3, r7, #262144	; 0x40000
   11d62:	331c      	adds	r3, #28
   11d64:	031f      	lsls	r7, r3, #12
   11d66:	68ac      	ldr	r4, [r5, #8]
                AM_CRITICAL_BEGIN
   11d68:	9002      	str	r0, [sp, #8]
                UARTn(ui32Module)->ILPR = pState->sRegState.regILPR;
   11d6a:	623c      	str	r4, [r7, #32]
                UARTn(ui32Module)->IBRD = pState->sRegState.regIBRD;
   11d6c:	68e9      	ldr	r1, [r5, #12]
   11d6e:	6279      	str	r1, [r7, #36]	; 0x24
                UARTn(ui32Module)->FBRD = pState->sRegState.regFBRD;
   11d70:	6928      	ldr	r0, [r5, #16]
   11d72:	62b8      	str	r0, [r7, #40]	; 0x28
                UARTn(ui32Module)->LCRH = pState->sRegState.regLCRH;
   11d74:	696a      	ldr	r2, [r5, #20]
   11d76:	62fa      	str	r2, [r7, #44]	; 0x2c
                UARTn(ui32Module)->CR   = pState->sRegState.regCR;
   11d78:	69ab      	ldr	r3, [r5, #24]
   11d7a:	633b      	str	r3, [r7, #48]	; 0x30
                UARTn(ui32Module)->IFLS = pState->sRegState.regIFLS;
   11d7c:	69ec      	ldr	r4, [r5, #28]
   11d7e:	637c      	str	r4, [r7, #52]	; 0x34
                UARTn(ui32Module)->IER  = pState->sRegState.regIER;
   11d80:	6a29      	ldr	r1, [r5, #32]
   11d82:	63b9      	str	r1, [r7, #56]	; 0x38
                AM_CRITICAL_END
   11d84:	9802      	ldr	r0, [sp, #8]
                pState->sRegState.bValid = false;
   11d86:	712e      	strb	r6, [r5, #4]
                AM_CRITICAL_END
   11d88:	f7ff fd38 	bl	117fc <am_hal_interrupt_master_set>
    return AM_HAL_STATUS_SUCCESS;
   11d8c:	4630      	mov	r0, r6
   11d8e:	e799      	b.n	11cc4 <am_hal_uart_power_control+0x14>
   11d90:	01ea9e06 	.word	0x01ea9e06

00011d94 <am_hal_uart_configure>:
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11d94:	6803      	ldr	r3, [r0, #0]
   11d96:	4a69      	ldr	r2, [pc, #420]	; (11f3c <am_hal_uart_configure+0x1a8>)
   11d98:	f023 4c7e 	bic.w	ip, r3, #4261412864	; 0xfe000000
   11d9c:	4594      	cmp	ip, r2
   11d9e:	d001      	beq.n	11da4 <am_hal_uart_configure+0x10>
        return AM_HAL_STATUS_INVALID_HANDLE;
   11da0:	2002      	movs	r0, #2
   11da2:	4770      	bx	lr
{
   11da4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint32_t ui32Module = pState->ui32Module;
   11da8:	6a46      	ldr	r6, [r0, #36]	; 0x24
{
   11daa:	b084      	sub	sp, #16
   11dac:	460d      	mov	r5, r1
   11dae:	4604      	mov	r4, r0
    AM_CRITICAL_BEGIN
   11db0:	f7ff fd20 	bl	117f4 <am_hal_interrupt_master_disable>
    UARTn(ui32Module)->CR |= UART0_CR_CLKEN_Msk;
   11db4:	f506 2180 	add.w	r1, r6, #262144	; 0x40000
   11db8:	311c      	adds	r1, #28
   11dba:	030f      	lsls	r7, r1, #12
    AM_CRITICAL_BEGIN
   11dbc:	9001      	str	r0, [sp, #4]
    UARTn(ui32Module)->CR |= UART0_CR_CLKEN_Msk;
   11dbe:	6b38      	ldr	r0, [r7, #48]	; 0x30
   11dc0:	f040 0208 	orr.w	r2, r0, #8
   11dc4:	633a      	str	r2, [r7, #48]	; 0x30
    UARTn(ui32Module)->CR |= _VAL2FLD(UART0_CR_CLKSEL, UART0_CR_CLKSEL_24MHZ);
   11dc6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   11dc8:	f043 0610 	orr.w	r6, r3, #16
   11dcc:	633e      	str	r6, [r7, #48]	; 0x30
    AM_CRITICAL_END
   11dce:	9801      	ldr	r0, [sp, #4]
   11dd0:	f7ff fd14 	bl	117fc <am_hal_interrupt_master_set>
    AM_CRITICAL_BEGIN
   11dd4:	f7ff fd0e 	bl	117f4 <am_hal_interrupt_master_disable>
   11dd8:	9002      	str	r0, [sp, #8]
    UARTn(ui32Module)->CR &=
   11dda:	6b39      	ldr	r1, [r7, #48]	; 0x30
   11ddc:	f421 7040 	bic.w	r0, r1, #768	; 0x300
   11de0:	f020 0201 	bic.w	r2, r0, #1
   11de4:	633a      	str	r2, [r7, #48]	; 0x30
    AM_CRITICAL_END
   11de6:	9802      	ldr	r0, [sp, #8]
   11de8:	f7ff fd08 	bl	117fc <am_hal_interrupt_master_set>
    switch( UARTn(ui32Module)->CR_b.CLKSEL )
   11dec:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   11dee:	f3c3 1802 	ubfx	r8, r3, #4, #3
   11df2:	f108 36ff 	add.w	r6, r8, #4294967295
   11df6:	2e03      	cmp	r6, #3
   11df8:	d846      	bhi.n	11e88 <am_hal_uart_configure+0xf4>
   11dfa:	e8df f006 	tbb	[pc, r6]
   11dfe:	020e      	.short	0x020e
   11e00:	1114      	.short	0x1114
   11e02:	494f      	ldr	r1, [pc, #316]	; (11f40 <am_hal_uart_configure+0x1ac>)
            ui32UartClkFreq = 12000000;
   11e04:	484f      	ldr	r0, [pc, #316]	; (11f44 <am_hal_uart_configure+0x1b0>)
    ui32BaudClk = BAUDCLK * ui32DesiredBaudrate;
   11e06:	682a      	ldr	r2, [r5, #0]
   11e08:	0116      	lsls	r6, r2, #4
    ui32IntegerDivisor = (uint32_t)(ui32UartClkFreq / ui32BaudClk);
   11e0a:	fbb0 f3f6 	udiv	r3, r0, r6
    if (ui32IntegerDivisor == 0)
   11e0e:	b96b      	cbnz	r3, 11e2c <am_hal_uart_configure+0x98>
        return AM_HAL_UART_STATUS_BAUDRATE_NOT_POSSIBLE;
   11e10:	484d      	ldr	r0, [pc, #308]	; (11f48 <am_hal_uart_configure+0x1b4>)
        *pui32ActualBaud = 0;
   11e12:	6623      	str	r3, [r4, #96]	; 0x60
} // am_hal_uart_configure()
   11e14:	b004      	add	sp, #16
   11e16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    switch( UARTn(ui32Module)->CR_b.CLKSEL )
   11e1a:	494c      	ldr	r1, [pc, #304]	; (11f4c <am_hal_uart_configure+0x1b8>)
            ui32UartClkFreq = 24000000;
   11e1c:	484c      	ldr	r0, [pc, #304]	; (11f50 <am_hal_uart_configure+0x1bc>)
   11e1e:	e7f2      	b.n	11e06 <am_hal_uart_configure+0x72>
   11e20:	494c      	ldr	r1, [pc, #304]	; (11f54 <am_hal_uart_configure+0x1c0>)
            ui32UartClkFreq = 3000000;
   11e22:	484d      	ldr	r0, [pc, #308]	; (11f58 <am_hal_uart_configure+0x1c4>)
   11e24:	e7ef      	b.n	11e06 <am_hal_uart_configure+0x72>
    switch( UARTn(ui32Module)->CR_b.CLKSEL )
   11e26:	494d      	ldr	r1, [pc, #308]	; (11f5c <am_hal_uart_configure+0x1c8>)
            ui32UartClkFreq = 6000000;
   11e28:	484d      	ldr	r0, [pc, #308]	; (11f60 <am_hal_uart_configure+0x1cc>)
   11e2a:	e7ec      	b.n	11e06 <am_hal_uart_configure+0x72>
    ui64IntermediateLong = (ui32UartClkFreq * 64) / ui32BaudClk;
   11e2c:	fbb1 f1f6 	udiv	r1, r1, r6
   11e30:	eba1 1283 	sub.w	r2, r1, r3, lsl #6
    UARTn(ui32Module)->IBRD = ui32IntegerDivisor;
   11e34:	627b      	str	r3, [r7, #36]	; 0x24
    *pui32ActualBaud = (ui32UartClkFreq / ((BAUDCLK * ui32IntegerDivisor) + ui32FractionDivisor));
   11e36:	eb02 1603 	add.w	r6, r2, r3, lsl #4
    UARTn(ui32Module)->IBRD = ui32IntegerDivisor;
   11e3a:	627b      	str	r3, [r7, #36]	; 0x24
    *pui32ActualBaud = (ui32UartClkFreq / ((BAUDCLK * ui32IntegerDivisor) + ui32FractionDivisor));
   11e3c:	fbb0 f0f6 	udiv	r0, r0, r6
    UARTn(ui32Module)->FBRD = ui32FractionDivisor;
   11e40:	62ba      	str	r2, [r7, #40]	; 0x28
    *pui32ActualBaud = (ui32UartClkFreq / ((BAUDCLK * ui32IntegerDivisor) + ui32FractionDivisor));
   11e42:	6620      	str	r0, [r4, #96]	; 0x60
    UARTn(ui32Module)->CR   |= psConfig->ui32FlowControl;
   11e44:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   11e46:	6929      	ldr	r1, [r5, #16]
   11e48:	430b      	orrs	r3, r1
   11e4a:	633b      	str	r3, [r7, #48]	; 0x30
    UARTn(ui32Module)->IFLS  = psConfig->ui32FifoLevels;
   11e4c:	696a      	ldr	r2, [r5, #20]
   11e4e:	637a      	str	r2, [r7, #52]	; 0x34
    UARTn(ui32Module)->LCRH  = (psConfig->ui32DataBits   |
   11e50:	686e      	ldr	r6, [r5, #4]
   11e52:	68a8      	ldr	r0, [r5, #8]
                                psConfig->ui32StopBits   |
   11e54:	68e9      	ldr	r1, [r5, #12]
    UARTn(ui32Module)->LCRH  = (psConfig->ui32DataBits   |
   11e56:	4306      	orrs	r6, r0
                                psConfig->ui32StopBits   |
   11e58:	f046 0310 	orr.w	r3, r6, #16
   11e5c:	430b      	orrs	r3, r1
    UARTn(ui32Module)->LCRH  = (psConfig->ui32DataBits   |
   11e5e:	62fb      	str	r3, [r7, #44]	; 0x2c
    AM_CRITICAL_BEGIN
   11e60:	f7ff fcc8 	bl	117f4 <am_hal_interrupt_master_disable>
   11e64:	9003      	str	r0, [sp, #12]
    UARTn(ui32Module)->CR   |=
   11e66:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   11e68:	f442 7640 	orr.w	r6, r2, #768	; 0x300
   11e6c:	f046 0001 	orr.w	r0, r6, #1
   11e70:	6338      	str	r0, [r7, #48]	; 0x30
    AM_CRITICAL_END
   11e72:	9803      	ldr	r0, [sp, #12]
   11e74:	f7ff fcc2 	bl	117fc <am_hal_interrupt_master_set>
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11e78:	6827      	ldr	r7, [r4, #0]
   11e7a:	4930      	ldr	r1, [pc, #192]	; (11f3c <am_hal_uart_configure+0x1a8>)
   11e7c:	f027 467e 	bic.w	r6, r7, #4261412864	; 0xfe000000
   11e80:	428e      	cmp	r6, r1
   11e82:	d005      	beq.n	11e90 <am_hal_uart_configure+0xfc>
    return AM_HAL_STATUS_SUCCESS;
   11e84:	2000      	movs	r0, #0
   11e86:	e7c5      	b.n	11e14 <am_hal_uart_configure+0x80>
            *pui32ActualBaud = 0;
   11e88:	2600      	movs	r6, #0
   11e8a:	6626      	str	r6, [r4, #96]	; 0x60
            return AM_HAL_UART_STATUS_CLOCK_NOT_CONFIGURED;
   11e8c:	4835      	ldr	r0, [pc, #212]	; (11f64 <am_hal_uart_configure+0x1d0>)
   11e8e:	e7c1      	b.n	11e14 <am_hal_uart_configure+0x80>
    buffer_configure(pHandle,
   11e90:	69a9      	ldr	r1, [r5, #24]
   11e92:	6a2f      	ldr	r7, [r5, #32]
   11e94:	f8d5 8024 	ldr.w	r8, [r5, #36]	; 0x24
    if (pui8TxBuffer && ui32TxBufferSize)
   11e98:	b109      	cbz	r1, 11e9e <am_hal_uart_configure+0x10a>
    buffer_configure(pHandle,
   11e9a:	69eb      	ldr	r3, [r5, #28]
    if (pui8TxBuffer && ui32TxBufferSize)
   11e9c:	b9f3      	cbnz	r3, 11edc <am_hal_uart_configure+0x148>
    UARTn(ui32Module)->IER &= ~ui32IntMask;
   11e9e:	6a65      	ldr	r5, [r4, #36]	; 0x24
   11ea0:	f505 2380 	add.w	r3, r5, #262144	; 0x40000
   11ea4:	331c      	adds	r3, #28
   11ea6:	031e      	lsls	r6, r3, #12
        pState->bEnableTxQueue = false;
   11ea8:	f04f 0e00 	mov.w	lr, #0
   11eac:	f884 e028 	strb.w	lr, [r4, #40]	; 0x28
    UARTn(ui32Module)->IER &= ~ui32IntMask;
   11eb0:	6bb2      	ldr	r2, [r6, #56]	; 0x38
   11eb2:	f022 0020 	bic.w	r0, r2, #32
   11eb6:	63b0      	str	r0, [r6, #56]	; 0x38
    if (pui8RxBuffer && ui32RxBufferSize)
   11eb8:	b117      	cbz	r7, 11ec0 <am_hal_uart_configure+0x12c>
   11eba:	f1b8 0f00 	cmp.w	r8, #0
   11ebe:	d123      	bne.n	11f08 <am_hal_uart_configure+0x174>
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11ec0:	6827      	ldr	r7, [r4, #0]
   11ec2:	491e      	ldr	r1, [pc, #120]	; (11f3c <am_hal_uart_configure+0x1a8>)
   11ec4:	f027 457e 	bic.w	r5, r7, #4261412864	; 0xfe000000
        pState->bEnableRxQueue = false;
   11ec8:	2000      	movs	r0, #0
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11eca:	428d      	cmp	r5, r1
        pState->bEnableRxQueue = false;
   11ecc:	f884 0044 	strb.w	r0, [r4, #68]	; 0x44
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11ed0:	d1d8      	bne.n	11e84 <am_hal_uart_configure+0xf0>
    UARTn(ui32Module)->IER &= ~ui32IntMask;
   11ed2:	6bb4      	ldr	r4, [r6, #56]	; 0x38
   11ed4:	f024 0350 	bic.w	r3, r4, #80	; 0x50
   11ed8:	63b3      	str	r3, [r6, #56]	; 0x38
   11eda:	e79b      	b.n	11e14 <am_hal_uart_configure+0x80>
        pState->bEnableTxQueue = true;
   11edc:	2201      	movs	r2, #1
   11ede:	f884 2028 	strb.w	r2, [r4, #40]	; 0x28
        am_hal_queue_init(&pState->sTxQueue, pui8TxBuffer, 1, ui32TxBufferSize);
   11ee2:	f104 002c 	add.w	r0, r4, #44	; 0x2c
   11ee6:	f000 fcf5 	bl	128d4 <am_hal_queue_init>
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11eea:	6821      	ldr	r1, [r4, #0]
   11eec:	f021 457e 	bic.w	r5, r1, #4261412864	; 0xfe000000
   11ef0:	42b5      	cmp	r5, r6
   11ef2:	d1c7      	bne.n	11e84 <am_hal_uart_configure+0xf0>
    UARTn(ui32Module)->IER |= ui32IntMask;
   11ef4:	6a63      	ldr	r3, [r4, #36]	; 0x24
   11ef6:	f503 2680 	add.w	r6, r3, #262144	; 0x40000
   11efa:	361c      	adds	r6, #28
   11efc:	0336      	lsls	r6, r6, #12
   11efe:	6bb2      	ldr	r2, [r6, #56]	; 0x38
   11f00:	f042 0020 	orr.w	r0, r2, #32
   11f04:	63b0      	str	r0, [r6, #56]	; 0x38
   11f06:	e7d7      	b.n	11eb8 <am_hal_uart_configure+0x124>
        pState->bEnableRxQueue = true;
   11f08:	2201      	movs	r2, #1
   11f0a:	f884 2044 	strb.w	r2, [r4, #68]	; 0x44
        am_hal_queue_init(&pState->sRxQueue, pui8RxBuffer, 1, ui32RxBufferSize);
   11f0e:	f104 0048 	add.w	r0, r4, #72	; 0x48
   11f12:	4643      	mov	r3, r8
   11f14:	4639      	mov	r1, r7
   11f16:	f000 fcdd 	bl	128d4 <am_hal_queue_init>
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11f1a:	6826      	ldr	r6, [r4, #0]
   11f1c:	4a07      	ldr	r2, [pc, #28]	; (11f3c <am_hal_uart_configure+0x1a8>)
   11f1e:	f026 407e 	bic.w	r0, r6, #4261412864	; 0xfe000000
   11f22:	4290      	cmp	r0, r2
   11f24:	d1ae      	bne.n	11e84 <am_hal_uart_configure+0xf0>
    UARTn(ui32Module)->IER |= ui32IntMask;
   11f26:	6a67      	ldr	r7, [r4, #36]	; 0x24
   11f28:	f507 2180 	add.w	r1, r7, #262144	; 0x40000
   11f2c:	311c      	adds	r1, #28
   11f2e:	030d      	lsls	r5, r1, #12
    return AM_HAL_STATUS_SUCCESS;
   11f30:	2000      	movs	r0, #0
    UARTn(ui32Module)->IER |= ui32IntMask;
   11f32:	6bac      	ldr	r4, [r5, #56]	; 0x38
   11f34:	f044 0350 	orr.w	r3, r4, #80	; 0x50
   11f38:	63ab      	str	r3, [r5, #56]	; 0x38
   11f3a:	e76b      	b.n	11e14 <am_hal_uart_configure+0x80>
   11f3c:	01ea9e06 	.word	0x01ea9e06
   11f40:	2dc6c000 	.word	0x2dc6c000
   11f44:	00b71b00 	.word	0x00b71b00
   11f48:	08000003 	.word	0x08000003
   11f4c:	5b8d8000 	.word	0x5b8d8000
   11f50:	016e3600 	.word	0x016e3600
   11f54:	0b71b000 	.word	0x0b71b000
   11f58:	002dc6c0 	.word	0x002dc6c0
   11f5c:	16e36000 	.word	0x16e36000
   11f60:	005b8d80 	.word	0x005b8d80
   11f64:	08000002 	.word	0x08000002

00011f68 <am_hal_uart_transfer>:
{
   11f68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if (pTransfer->ui32Direction == AM_HAL_UART_WRITE)
   11f6c:	680e      	ldr	r6, [r1, #0]
{
   11f6e:	b091      	sub	sp, #68	; 0x44
   11f70:	4680      	mov	r8, r0
    if (pTransfer->ui32Direction == AM_HAL_UART_WRITE)
   11f72:	b14e      	cbz	r6, 11f88 <am_hal_uart_transfer+0x20>
    else if (pTransfer->ui32Direction == AM_HAL_UART_READ)
   11f74:	2e01      	cmp	r6, #1
    return AM_HAL_STATUS_INVALID_OPERATION;
   11f76:	bf18      	it	ne
   11f78:	f04f 0b07 	movne.w	fp, #7
    else if (pTransfer->ui32Direction == AM_HAL_UART_READ)
   11f7c:	f000 80f6 	beq.w	1216c <am_hal_uart_transfer+0x204>
} // am_hal_uart_transfer()
   11f80:	4658      	mov	r0, fp
   11f82:	b011      	add	sp, #68	; 0x44
   11f84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return write_timeout(pHandle,
   11f88:	f8d1 b00c 	ldr.w	fp, [r1, #12]
   11f8c:	684c      	ldr	r4, [r1, #4]
   11f8e:	9401      	str	r4, [sp, #4]
   11f90:	688d      	ldr	r5, [r1, #8]
   11f92:	f8d1 a010 	ldr.w	sl, [r1, #16]
    if (ui32TimeoutMs == 0)
   11f96:	f1bb 0f00 	cmp.w	fp, #0
   11f9a:	f000 8107 	beq.w	121ac <am_hal_uart_transfer+0x244>
    while (ui32RemainingBytes && (ui32TimeSpent < ui32TimeoutMs))
   11f9e:	2d00      	cmp	r5, #0
   11fa0:	f000 8393 	beq.w	126ca <am_hal_uart_transfer+0x762>
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11fa4:	2800      	cmp	r0, #0
   11fa6:	f000 80df 	beq.w	12168 <am_hal_uart_transfer+0x200>
   11faa:	6807      	ldr	r7, [r0, #0]
   11fac:	497e      	ldr	r1, [pc, #504]	; (121a8 <am_hal_uart_transfer+0x240>)
   11fae:	f027 497e 	bic.w	r9, r7, #4261412864	; 0xfe000000
   11fb2:	4589      	cmp	r9, r1
   11fb4:	d00a      	beq.n	11fcc <am_hal_uart_transfer+0x64>
            if (pui32NumBytesWritten)
   11fb6:	f1ba 0f00 	cmp.w	sl, #0
   11fba:	d001      	beq.n	11fc0 <am_hal_uart_transfer+0x58>
                *pui32NumBytesWritten = i;
   11fbc:	f8ca 6000 	str.w	r6, [sl]
   11fc0:	f04f 0b02 	mov.w	fp, #2
} // am_hal_uart_transfer()
   11fc4:	4658      	mov	r0, fp
   11fc6:	b011      	add	sp, #68	; 0x44
   11fc8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        am_hal_queue_item_add(&pState->sTxQueue, pui8Data, ui32BytesTransferred);
   11fcc:	302c      	adds	r0, #44	; 0x2c
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11fce:	4637      	mov	r7, r6
   11fd0:	4621      	mov	r1, r4
        am_hal_queue_item_add(&pState->sTxQueue, pui8Data, ui32BytesTransferred);
   11fd2:	9002      	str	r0, [sp, #8]
    if (pState->bEnableTxQueue)
   11fd4:	f898 2028 	ldrb.w	r2, [r8, #40]	; 0x28
   11fd8:	2a00      	cmp	r2, #0
   11fda:	f040 822c 	bne.w	12436 <am_hal_uart_transfer+0x4ce>
    uint32_t ui32Module = pState->ui32Module;
   11fde:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
    while (i < ui32NumBytes)
   11fe2:	2d00      	cmp	r5, #0
   11fe4:	f000 80a1 	beq.w	1212a <am_hal_uart_transfer+0x1c2>
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11fe8:	f503 2480 	add.w	r4, r3, #262144	; 0x40000
   11fec:	341c      	adds	r4, #28
   11fee:	0322      	lsls	r2, r4, #12
   11ff0:	6990      	ldr	r0, [r2, #24]
   11ff2:	f3c0 1440 	ubfx	r4, r0, #5, #1
   11ff6:	2c00      	cmp	r4, #0
   11ff8:	f040 80a3 	bne.w	12142 <am_hal_uart_transfer+0x1da>
   11ffc:	1e6b      	subs	r3, r5, #1
   11ffe:	f013 0e07 	ands.w	lr, r3, #7
   12002:	f101 3cff 	add.w	ip, r1, #4294967295
   12006:	d048      	beq.n	1209a <am_hal_uart_transfer+0x132>
            UARTn(ui32Module)->DR = pui8Data[i++];
   12008:	780c      	ldrb	r4, [r1, #0]
   1200a:	6014      	str	r4, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   1200c:	6993      	ldr	r3, [r2, #24]
   1200e:	069b      	lsls	r3, r3, #26
   12010:	468c      	mov	ip, r1
            UARTn(ui32Module)->DR = pui8Data[i++];
   12012:	f04f 0401 	mov.w	r4, #1
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12016:	f100 8085 	bmi.w	12124 <am_hal_uart_transfer+0x1bc>
   1201a:	45a6      	cmp	lr, r4
   1201c:	d03d      	beq.n	1209a <am_hal_uart_transfer+0x132>
   1201e:	f1be 0f02 	cmp.w	lr, #2
   12022:	d032      	beq.n	1208a <am_hal_uart_transfer+0x122>
   12024:	f1be 0f03 	cmp.w	lr, #3
   12028:	d027      	beq.n	1207a <am_hal_uart_transfer+0x112>
   1202a:	f1be 0f04 	cmp.w	lr, #4
   1202e:	d01c      	beq.n	1206a <am_hal_uart_transfer+0x102>
   12030:	f1be 0f05 	cmp.w	lr, #5
   12034:	d011      	beq.n	1205a <am_hal_uart_transfer+0xf2>
   12036:	f1be 0f06 	cmp.w	lr, #6
   1203a:	d006      	beq.n	1204a <am_hal_uart_transfer+0xe2>
            UARTn(ui32Module)->DR = pui8Data[i++];
   1203c:	f81c 1f01 	ldrb.w	r1, [ip, #1]!
   12040:	6011      	str	r1, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12042:	6990      	ldr	r0, [r2, #24]
   12044:	0681      	lsls	r1, r0, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   12046:	4424      	add	r4, r4
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12048:	d46c      	bmi.n	12124 <am_hal_uart_transfer+0x1bc>
            UARTn(ui32Module)->DR = pui8Data[i++];
   1204a:	f81c 3f01 	ldrb.w	r3, [ip, #1]!
   1204e:	6013      	str	r3, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12050:	6991      	ldr	r1, [r2, #24]
   12052:	068b      	lsls	r3, r1, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   12054:	f104 0401 	add.w	r4, r4, #1
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12058:	d464      	bmi.n	12124 <am_hal_uart_transfer+0x1bc>
            UARTn(ui32Module)->DR = pui8Data[i++];
   1205a:	f81c 0f01 	ldrb.w	r0, [ip, #1]!
   1205e:	6010      	str	r0, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12060:	6993      	ldr	r3, [r2, #24]
   12062:	0699      	lsls	r1, r3, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   12064:	f104 0401 	add.w	r4, r4, #1
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12068:	d45c      	bmi.n	12124 <am_hal_uart_transfer+0x1bc>
            UARTn(ui32Module)->DR = pui8Data[i++];
   1206a:	f81c 1f01 	ldrb.w	r1, [ip, #1]!
   1206e:	6011      	str	r1, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12070:	6990      	ldr	r0, [r2, #24]
   12072:	0683      	lsls	r3, r0, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   12074:	f104 0401 	add.w	r4, r4, #1
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12078:	d454      	bmi.n	12124 <am_hal_uart_transfer+0x1bc>
            UARTn(ui32Module)->DR = pui8Data[i++];
   1207a:	f81c 3f01 	ldrb.w	r3, [ip, #1]!
   1207e:	6013      	str	r3, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12080:	6991      	ldr	r1, [r2, #24]
   12082:	0689      	lsls	r1, r1, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   12084:	f104 0401 	add.w	r4, r4, #1
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12088:	d44c      	bmi.n	12124 <am_hal_uart_transfer+0x1bc>
            UARTn(ui32Module)->DR = pui8Data[i++];
   1208a:	f81c 0f01 	ldrb.w	r0, [ip, #1]!
   1208e:	6010      	str	r0, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12090:	6993      	ldr	r3, [r2, #24]
   12092:	069b      	lsls	r3, r3, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   12094:	f104 0401 	add.w	r4, r4, #1
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12098:	d444      	bmi.n	12124 <am_hal_uart_transfer+0x1bc>
            UARTn(ui32Module)->DR = pui8Data[i++];
   1209a:	3401      	adds	r4, #1
   1209c:	f89c 1001 	ldrb.w	r1, [ip, #1]
   120a0:	6011      	str	r1, [r2, #0]
    while (i < ui32NumBytes)
   120a2:	42a5      	cmp	r5, r4
            UARTn(ui32Module)->DR = pui8Data[i++];
   120a4:	4620      	mov	r0, r4
   120a6:	f10c 0e01 	add.w	lr, ip, #1
    while (i < ui32NumBytes)
   120aa:	f000 81c2 	beq.w	12432 <am_hal_uart_transfer+0x4ca>
        if ( UARTn(ui32Module)->FR_b.TXFF )
   120ae:	6993      	ldr	r3, [r2, #24]
   120b0:	0699      	lsls	r1, r3, #26
   120b2:	d437      	bmi.n	12124 <am_hal_uart_transfer+0x1bc>
            UARTn(ui32Module)->DR = pui8Data[i++];
   120b4:	f89e 1001 	ldrb.w	r1, [lr, #1]
   120b8:	6011      	str	r1, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   120ba:	6993      	ldr	r3, [r2, #24]
   120bc:	0699      	lsls	r1, r3, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   120be:	f104 0401 	add.w	r4, r4, #1
        if ( UARTn(ui32Module)->FR_b.TXFF )
   120c2:	d42f      	bmi.n	12124 <am_hal_uart_transfer+0x1bc>
            UARTn(ui32Module)->DR = pui8Data[i++];
   120c4:	f89c 4003 	ldrb.w	r4, [ip, #3]
   120c8:	6014      	str	r4, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   120ca:	6991      	ldr	r1, [r2, #24]
   120cc:	0689      	lsls	r1, r1, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   120ce:	f100 0402 	add.w	r4, r0, #2
        if ( UARTn(ui32Module)->FR_b.TXFF )
   120d2:	d427      	bmi.n	12124 <am_hal_uart_transfer+0x1bc>
            UARTn(ui32Module)->DR = pui8Data[i++];
   120d4:	f89c 3004 	ldrb.w	r3, [ip, #4]
   120d8:	6013      	str	r3, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   120da:	6991      	ldr	r1, [r2, #24]
   120dc:	0689      	lsls	r1, r1, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   120de:	f100 0403 	add.w	r4, r0, #3
        if ( UARTn(ui32Module)->FR_b.TXFF )
   120e2:	d41f      	bmi.n	12124 <am_hal_uart_transfer+0x1bc>
            UARTn(ui32Module)->DR = pui8Data[i++];
   120e4:	f89c 4005 	ldrb.w	r4, [ip, #5]
   120e8:	6014      	str	r4, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   120ea:	6993      	ldr	r3, [r2, #24]
   120ec:	0699      	lsls	r1, r3, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   120ee:	f100 0404 	add.w	r4, r0, #4
        if ( UARTn(ui32Module)->FR_b.TXFF )
   120f2:	d417      	bmi.n	12124 <am_hal_uart_transfer+0x1bc>
            UARTn(ui32Module)->DR = pui8Data[i++];
   120f4:	f89c 1006 	ldrb.w	r1, [ip, #6]
   120f8:	6011      	str	r1, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   120fa:	6993      	ldr	r3, [r2, #24]
   120fc:	0699      	lsls	r1, r3, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   120fe:	f100 0405 	add.w	r4, r0, #5
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12102:	d40f      	bmi.n	12124 <am_hal_uart_transfer+0x1bc>
            UARTn(ui32Module)->DR = pui8Data[i++];
   12104:	f89c 4007 	ldrb.w	r4, [ip, #7]
   12108:	6014      	str	r4, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   1210a:	6991      	ldr	r1, [r2, #24]
   1210c:	0689      	lsls	r1, r1, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   1210e:	f100 0406 	add.w	r4, r0, #6
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12112:	d407      	bmi.n	12124 <am_hal_uart_transfer+0x1bc>
            UARTn(ui32Module)->DR = pui8Data[i++];
   12114:	f81c 3f08 	ldrb.w	r3, [ip, #8]!
   12118:	6013      	str	r3, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   1211a:	6991      	ldr	r1, [r2, #24]
   1211c:	068b      	lsls	r3, r1, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   1211e:	f100 0407 	add.w	r4, r0, #7
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12122:	d5ba      	bpl.n	1209a <am_hal_uart_transfer+0x132>
        if (ui32RemainingBytes)
   12124:	1b2d      	subs	r5, r5, r4
        i += ui32BytesWritten;
   12126:	4426      	add	r6, r4
        if (ui32RemainingBytes)
   12128:	d10b      	bne.n	12142 <am_hal_uart_transfer+0x1da>
    if (pui32NumBytesWritten)
   1212a:	f1ba 0f00 	cmp.w	sl, #0
   1212e:	f000 817d 	beq.w	1242c <am_hal_uart_transfer+0x4c4>
    return AM_HAL_STATUS_SUCCESS;
   12132:	f04f 0b00 	mov.w	fp, #0
} // am_hal_uart_transfer()
   12136:	4658      	mov	r0, fp
        *pui32NumBytesWritten = i;
   12138:	f8ca 6000 	str.w	r6, [sl]
} // am_hal_uart_transfer()
   1213c:	b011      	add	sp, #68	; 0x44
   1213e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            am_hal_flash_delay(FLASH_CYCLES_US(1));
   12142:	2001      	movs	r0, #1
   12144:	f7ff f896 	bl	11274 <am_hal_flash_delay>
            if (ui32TimeoutMs != AM_HAL_UART_WAIT_FOREVER)
   12148:	f1bb 3fff 	cmp.w	fp, #4294967295
                ui32TimeSpent++;
   1214c:	bf18      	it	ne
   1214e:	3701      	addne	r7, #1
    while (ui32RemainingBytes && (ui32TimeSpent < ui32TimeoutMs))
   12150:	45bb      	cmp	fp, r7
   12152:	d9ea      	bls.n	1212a <am_hal_uart_transfer+0x1c2>
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   12154:	f8d8 4000 	ldr.w	r4, [r8]
        ui32Status = write_nonblocking(pHandle, &pui8Data[i],
   12158:	9901      	ldr	r1, [sp, #4]
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   1215a:	f024 407e 	bic.w	r0, r4, #4261412864	; 0xfe000000
   1215e:	4548      	cmp	r0, r9
        ui32Status = write_nonblocking(pHandle, &pui8Data[i],
   12160:	4431      	add	r1, r6
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   12162:	f47f af28 	bne.w	11fb6 <am_hal_uart_transfer+0x4e>
   12166:	e735      	b.n	11fd4 <am_hal_uart_transfer+0x6c>
   12168:	4606      	mov	r6, r0
   1216a:	e724      	b.n	11fb6 <am_hal_uart_transfer+0x4e>
        return read_timeout(pHandle,
   1216c:	684b      	ldr	r3, [r1, #4]
   1216e:	f8d1 b00c 	ldr.w	fp, [r1, #12]
   12172:	688c      	ldr	r4, [r1, #8]
   12174:	690f      	ldr	r7, [r1, #16]
   12176:	4699      	mov	r9, r3
    if (ui32TimeoutMs == 0)
   12178:	f1bb 0f00 	cmp.w	fp, #0
   1217c:	f000 80c9 	beq.w	12312 <am_hal_uart_transfer+0x3aa>
    while (ui32RemainingBytes && (ui32TimeSpent < ui32TimeoutMs))
   12180:	2c00      	cmp	r4, #0
   12182:	f000 8150 	beq.w	12426 <am_hal_uart_transfer+0x4be>
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   12186:	b130      	cbz	r0, 12196 <am_hal_uart_transfer+0x22e>
   12188:	6800      	ldr	r0, [r0, #0]
   1218a:	4a07      	ldr	r2, [pc, #28]	; (121a8 <am_hal_uart_transfer+0x240>)
   1218c:	f020 417e 	bic.w	r1, r0, #4261412864	; 0xfe000000
   12190:	4291      	cmp	r1, r2
   12192:	f000 8186 	beq.w	124a2 <am_hal_uart_transfer+0x53a>
   12196:	2500      	movs	r5, #0
        return AM_HAL_STATUS_INVALID_HANDLE;
   12198:	f04f 0b02 	mov.w	fp, #2
            if (pui32NumBytesRead)
   1219c:	2f00      	cmp	r7, #0
   1219e:	f43f aeef 	beq.w	11f80 <am_hal_uart_transfer+0x18>
                *pui32NumBytesRead = i;
   121a2:	603d      	str	r5, [r7, #0]
   121a4:	e6ec      	b.n	11f80 <am_hal_uart_transfer+0x18>
   121a6:	bf00      	nop
   121a8:	01ea9e06 	.word	0x01ea9e06
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   121ac:	2800      	cmp	r0, #0
   121ae:	f43f af07 	beq.w	11fc0 <am_hal_uart_transfer+0x58>
   121b2:	6807      	ldr	r7, [r0, #0]
   121b4:	4cac      	ldr	r4, [pc, #688]	; (12468 <am_hal_uart_transfer+0x500>)
   121b6:	f027 437e 	bic.w	r3, r7, #4261412864	; 0xfe000000
   121ba:	42a3      	cmp	r3, r4
   121bc:	f47f af00 	bne.w	11fc0 <am_hal_uart_transfer+0x58>
    if (pui32NumBytesWritten)
   121c0:	f1ba 0f00 	cmp.w	sl, #0
   121c4:	d001      	beq.n	121ca <am_hal_uart_transfer+0x262>
        *pui32NumBytesWritten = 0;
   121c6:	f8ca b000 	str.w	fp, [sl]
    if (ui32NumBytes == 0)
   121ca:	2d00      	cmp	r5, #0
   121cc:	f000 812e 	beq.w	1242c <am_hal_uart_transfer+0x4c4>
    if (pState->bEnableTxQueue)
   121d0:	f898 4028 	ldrb.w	r4, [r8, #40]	; 0x28
   121d4:	2c00      	cmp	r4, #0
   121d6:	f040 8290 	bne.w	126fa <am_hal_uart_transfer+0x792>
        if ( UARTn(ui32Module)->FR_b.TXFF )
   121da:	f8d8 0024 	ldr.w	r0, [r8, #36]	; 0x24
   121de:	f500 2180 	add.w	r1, r0, #262144	; 0x40000
   121e2:	311c      	adds	r1, #28
   121e4:	030a      	lsls	r2, r1, #12
   121e6:	6996      	ldr	r6, [r2, #24]
   121e8:	f3c6 1740 	ubfx	r7, r6, #5, #1
   121ec:	2f00      	cmp	r7, #0
   121ee:	f040 8089 	bne.w	12304 <am_hal_uart_transfer+0x39c>
   121f2:	f105 38ff 	add.w	r8, r5, #4294967295
   121f6:	9b01      	ldr	r3, [sp, #4]
   121f8:	f018 0007 	ands.w	r0, r8, #7
   121fc:	463c      	mov	r4, r7
   121fe:	f103 31ff 	add.w	r1, r3, #4294967295
   12202:	d042      	beq.n	1228a <am_hal_uart_transfer+0x322>
            UARTn(ui32Module)->DR = pui8Data[i++];
   12204:	781e      	ldrb	r6, [r3, #0]
   12206:	6016      	str	r6, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12208:	6997      	ldr	r7, [r2, #24]
   1220a:	4619      	mov	r1, r3
   1220c:	06bb      	lsls	r3, r7, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   1220e:	f04f 0401 	mov.w	r4, #1
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12212:	d477      	bmi.n	12304 <am_hal_uart_transfer+0x39c>
   12214:	42a0      	cmp	r0, r4
   12216:	d038      	beq.n	1228a <am_hal_uart_transfer+0x322>
   12218:	2802      	cmp	r0, #2
   1221a:	d02e      	beq.n	1227a <am_hal_uart_transfer+0x312>
   1221c:	2803      	cmp	r0, #3
   1221e:	d024      	beq.n	1226a <am_hal_uart_transfer+0x302>
   12220:	2804      	cmp	r0, #4
   12222:	d01a      	beq.n	1225a <am_hal_uart_transfer+0x2f2>
   12224:	2805      	cmp	r0, #5
   12226:	d010      	beq.n	1224a <am_hal_uart_transfer+0x2e2>
   12228:	2806      	cmp	r0, #6
   1222a:	d006      	beq.n	1223a <am_hal_uart_transfer+0x2d2>
            UARTn(ui32Module)->DR = pui8Data[i++];
   1222c:	f811 3f01 	ldrb.w	r3, [r1, #1]!
   12230:	6013      	str	r3, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12232:	6990      	ldr	r0, [r2, #24]
   12234:	0687      	lsls	r7, r0, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   12236:	4424      	add	r4, r4
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12238:	d464      	bmi.n	12304 <am_hal_uart_transfer+0x39c>
            UARTn(ui32Module)->DR = pui8Data[i++];
   1223a:	f811 6f01 	ldrb.w	r6, [r1, #1]!
   1223e:	6016      	str	r6, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12240:	6997      	ldr	r7, [r2, #24]
   12242:	06be      	lsls	r6, r7, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   12244:	f104 0401 	add.w	r4, r4, #1
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12248:	d45c      	bmi.n	12304 <am_hal_uart_transfer+0x39c>
            UARTn(ui32Module)->DR = pui8Data[i++];
   1224a:	f811 3f01 	ldrb.w	r3, [r1, #1]!
   1224e:	6013      	str	r3, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12250:	6990      	ldr	r0, [r2, #24]
   12252:	0680      	lsls	r0, r0, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   12254:	f104 0401 	add.w	r4, r4, #1
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12258:	d454      	bmi.n	12304 <am_hal_uart_transfer+0x39c>
            UARTn(ui32Module)->DR = pui8Data[i++];
   1225a:	f811 6f01 	ldrb.w	r6, [r1, #1]!
   1225e:	6016      	str	r6, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12260:	6997      	ldr	r7, [r2, #24]
   12262:	06bb      	lsls	r3, r7, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   12264:	f104 0401 	add.w	r4, r4, #1
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12268:	d44c      	bmi.n	12304 <am_hal_uart_transfer+0x39c>
            UARTn(ui32Module)->DR = pui8Data[i++];
   1226a:	f811 3f01 	ldrb.w	r3, [r1, #1]!
   1226e:	6013      	str	r3, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12270:	6990      	ldr	r0, [r2, #24]
   12272:	0687      	lsls	r7, r0, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   12274:	f104 0401 	add.w	r4, r4, #1
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12278:	d444      	bmi.n	12304 <am_hal_uart_transfer+0x39c>
            UARTn(ui32Module)->DR = pui8Data[i++];
   1227a:	f811 6f01 	ldrb.w	r6, [r1, #1]!
   1227e:	6016      	str	r6, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12280:	6997      	ldr	r7, [r2, #24]
   12282:	06be      	lsls	r6, r7, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   12284:	f104 0401 	add.w	r4, r4, #1
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12288:	d43c      	bmi.n	12304 <am_hal_uart_transfer+0x39c>
            UARTn(ui32Module)->DR = pui8Data[i++];
   1228a:	3401      	adds	r4, #1
   1228c:	784b      	ldrb	r3, [r1, #1]
   1228e:	6013      	str	r3, [r2, #0]
    while (i < ui32NumBytes)
   12290:	42a5      	cmp	r5, r4
            UARTn(ui32Module)->DR = pui8Data[i++];
   12292:	4623      	mov	r3, r4
   12294:	f101 0001 	add.w	r0, r1, #1
    while (i < ui32NumBytes)
   12298:	d034      	beq.n	12304 <am_hal_uart_transfer+0x39c>
        if ( UARTn(ui32Module)->FR_b.TXFF )
   1229a:	6996      	ldr	r6, [r2, #24]
   1229c:	06b6      	lsls	r6, r6, #26
   1229e:	d431      	bmi.n	12304 <am_hal_uart_transfer+0x39c>
            UARTn(ui32Module)->DR = pui8Data[i++];
   122a0:	7847      	ldrb	r7, [r0, #1]
   122a2:	6017      	str	r7, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   122a4:	6990      	ldr	r0, [r2, #24]
   122a6:	0680      	lsls	r0, r0, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   122a8:	f104 0401 	add.w	r4, r4, #1
        if ( UARTn(ui32Module)->FR_b.TXFF )
   122ac:	d42a      	bmi.n	12304 <am_hal_uart_transfer+0x39c>
            UARTn(ui32Module)->DR = pui8Data[i++];
   122ae:	78cc      	ldrb	r4, [r1, #3]
   122b0:	6014      	str	r4, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   122b2:	6996      	ldr	r6, [r2, #24]
   122b4:	06b7      	lsls	r7, r6, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   122b6:	f103 0402 	add.w	r4, r3, #2
        if ( UARTn(ui32Module)->FR_b.TXFF )
   122ba:	d423      	bmi.n	12304 <am_hal_uart_transfer+0x39c>
            UARTn(ui32Module)->DR = pui8Data[i++];
   122bc:	790f      	ldrb	r7, [r1, #4]
   122be:	6017      	str	r7, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   122c0:	6990      	ldr	r0, [r2, #24]
   122c2:	0686      	lsls	r6, r0, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   122c4:	f103 0403 	add.w	r4, r3, #3
        if ( UARTn(ui32Module)->FR_b.TXFF )
   122c8:	d41c      	bmi.n	12304 <am_hal_uart_transfer+0x39c>
            UARTn(ui32Module)->DR = pui8Data[i++];
   122ca:	794c      	ldrb	r4, [r1, #5]
   122cc:	6014      	str	r4, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   122ce:	6996      	ldr	r6, [r2, #24]
   122d0:	06b0      	lsls	r0, r6, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   122d2:	f103 0404 	add.w	r4, r3, #4
        if ( UARTn(ui32Module)->FR_b.TXFF )
   122d6:	d415      	bmi.n	12304 <am_hal_uart_transfer+0x39c>
            UARTn(ui32Module)->DR = pui8Data[i++];
   122d8:	798f      	ldrb	r7, [r1, #6]
   122da:	6017      	str	r7, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   122dc:	6990      	ldr	r0, [r2, #24]
   122de:	0687      	lsls	r7, r0, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   122e0:	f103 0405 	add.w	r4, r3, #5
        if ( UARTn(ui32Module)->FR_b.TXFF )
   122e4:	d40e      	bmi.n	12304 <am_hal_uart_transfer+0x39c>
            UARTn(ui32Module)->DR = pui8Data[i++];
   122e6:	79cc      	ldrb	r4, [r1, #7]
   122e8:	6014      	str	r4, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   122ea:	6996      	ldr	r6, [r2, #24]
   122ec:	06b6      	lsls	r6, r6, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   122ee:	f103 0406 	add.w	r4, r3, #6
        if ( UARTn(ui32Module)->FR_b.TXFF )
   122f2:	d407      	bmi.n	12304 <am_hal_uart_transfer+0x39c>
            UARTn(ui32Module)->DR = pui8Data[i++];
   122f4:	f811 7f08 	ldrb.w	r7, [r1, #8]!
   122f8:	6017      	str	r7, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   122fa:	6990      	ldr	r0, [r2, #24]
   122fc:	0680      	lsls	r0, r0, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   122fe:	f103 0407 	add.w	r4, r3, #7
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12302:	d5c2      	bpl.n	1228a <am_hal_uart_transfer+0x322>
    if (pui32NumBytesWritten)
   12304:	f1ba 0f00 	cmp.w	sl, #0
   12308:	f000 8090 	beq.w	1242c <am_hal_uart_transfer+0x4c4>
        *pui32NumBytesWritten = ui32BytesTransferred;
   1230c:	f8ca 4000 	str.w	r4, [sl]
   12310:	e636      	b.n	11f80 <am_hal_uart_transfer+0x18>
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   12312:	2800      	cmp	r0, #0
   12314:	f43f ae54 	beq.w	11fc0 <am_hal_uart_transfer+0x58>
   12318:	6805      	ldr	r5, [r0, #0]
   1231a:	4e53      	ldr	r6, [pc, #332]	; (12468 <am_hal_uart_transfer+0x500>)
   1231c:	f025 4c7e 	bic.w	ip, r5, #4261412864	; 0xfe000000
   12320:	45b4      	cmp	ip, r6
   12322:	f47f ae4d 	bne.w	11fc0 <am_hal_uart_transfer+0x58>
    if (pui32NumBytesRead)
   12326:	b10f      	cbz	r7, 1232c <am_hal_uart_transfer+0x3c4>
        *pui32NumBytesRead = 0;
   12328:	f8c7 b000 	str.w	fp, [r7]
    if (ui32NumBytes == 0)
   1232c:	2c00      	cmp	r4, #0
   1232e:	d07d      	beq.n	1242c <am_hal_uart_transfer+0x4c4>
    if (pState->bEnableRxQueue)
   12330:	f898 0044 	ldrb.w	r0, [r8, #68]	; 0x44
   12334:	2800      	cmp	r0, #0
   12336:	f040 8213 	bne.w	12760 <am_hal_uart_transfer+0x7f8>
        if ( UARTn(ui32Module)->FR_b.RXFE )
   1233a:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
   1233e:	f503 2180 	add.w	r1, r3, #262144	; 0x40000
   12342:	311c      	adds	r1, #28
   12344:	0309      	lsls	r1, r1, #12
   12346:	698a      	ldr	r2, [r1, #24]
   12348:	f3c2 1500 	ubfx	r5, r2, #4, #1
   1234c:	2d00      	cmp	r5, #0
   1234e:	f040 8287 	bne.w	12860 <am_hal_uart_transfer+0x8f8>
            ui32ReadData = UARTn(ui32Module)->DR;
   12352:	680b      	ldr	r3, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   12354:	f413 6a70 	ands.w	sl, r3, #3840	; 0xf00
   12358:	f040 81cc 	bne.w	126f4 <am_hal_uart_transfer+0x78c>
   1235c:	1e66      	subs	r6, r4, #1
   1235e:	f016 0203 	ands.w	r2, r6, #3
   12362:	4655      	mov	r5, sl
   12364:	f109 30ff 	add.w	r0, r9, #4294967295
   12368:	d02b      	beq.n	123c2 <am_hal_uart_transfer+0x45a>
                pui8Data[i++] = ui32ReadData & 0xFF;
   1236a:	f889 3000 	strb.w	r3, [r9]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   1236e:	698b      	ldr	r3, [r1, #24]
   12370:	06de      	lsls	r6, r3, #27
   12372:	4648      	mov	r0, r9
                pui8Data[i++] = ui32ReadData & 0xFF;
   12374:	f04f 0501 	mov.w	r5, #1
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12378:	f53f af10 	bmi.w	1219c <am_hal_uart_transfer+0x234>
            ui32ReadData = UARTn(ui32Module)->DR;
   1237c:	680b      	ldr	r3, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   1237e:	f413 6f70 	tst.w	r3, #3840	; 0xf00
   12382:	f040 81b7 	bne.w	126f4 <am_hal_uart_transfer+0x78c>
   12386:	42aa      	cmp	r2, r5
   12388:	d01b      	beq.n	123c2 <am_hal_uart_transfer+0x45a>
   1238a:	2a02      	cmp	r2, #2
   1238c:	d00c      	beq.n	123a8 <am_hal_uart_transfer+0x440>
                pui8Data[i++] = ui32ReadData & 0xFF;
   1238e:	f800 3f01 	strb.w	r3, [r0, #1]!
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12392:	698e      	ldr	r6, [r1, #24]
   12394:	06f2      	lsls	r2, r6, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   12396:	f04f 0502 	mov.w	r5, #2
        if ( UARTn(ui32Module)->FR_b.RXFE )
   1239a:	f53f aeff 	bmi.w	1219c <am_hal_uart_transfer+0x234>
            ui32ReadData = UARTn(ui32Module)->DR;
   1239e:	680b      	ldr	r3, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   123a0:	f413 6f70 	tst.w	r3, #3840	; 0xf00
   123a4:	f040 81a6 	bne.w	126f4 <am_hal_uart_transfer+0x78c>
                pui8Data[i++] = ui32ReadData & 0xFF;
   123a8:	f800 3f01 	strb.w	r3, [r0, #1]!
        if ( UARTn(ui32Module)->FR_b.RXFE )
   123ac:	698a      	ldr	r2, [r1, #24]
   123ae:	06d3      	lsls	r3, r2, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   123b0:	f105 0501 	add.w	r5, r5, #1
        if ( UARTn(ui32Module)->FR_b.RXFE )
   123b4:	f53f aef2 	bmi.w	1219c <am_hal_uart_transfer+0x234>
            ui32ReadData = UARTn(ui32Module)->DR;
   123b8:	680b      	ldr	r3, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   123ba:	f413 6f70 	tst.w	r3, #3840	; 0xf00
   123be:	f040 8199 	bne.w	126f4 <am_hal_uart_transfer+0x78c>
                pui8Data[i++] = ui32ReadData & 0xFF;
   123c2:	3501      	adds	r5, #1
    while (i < ui32NumBytes)
   123c4:	42ac      	cmp	r4, r5
                pui8Data[i++] = ui32ReadData & 0xFF;
   123c6:	7043      	strb	r3, [r0, #1]
   123c8:	f100 0601 	add.w	r6, r0, #1
   123cc:	462b      	mov	r3, r5
    while (i < ui32NumBytes)
   123ce:	f43f aee5 	beq.w	1219c <am_hal_uart_transfer+0x234>
        if ( UARTn(ui32Module)->FR_b.RXFE )
   123d2:	698a      	ldr	r2, [r1, #24]
   123d4:	06d2      	lsls	r2, r2, #27
   123d6:	f53f aee1 	bmi.w	1219c <am_hal_uart_transfer+0x234>
            ui32ReadData = UARTn(ui32Module)->DR;
   123da:	680a      	ldr	r2, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   123dc:	f412 6f70 	tst.w	r2, #3840	; 0xf00
   123e0:	f040 8188 	bne.w	126f4 <am_hal_uart_transfer+0x78c>
                pui8Data[i++] = ui32ReadData & 0xFF;
   123e4:	7072      	strb	r2, [r6, #1]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   123e6:	698e      	ldr	r6, [r1, #24]
   123e8:	06f6      	lsls	r6, r6, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   123ea:	f105 0501 	add.w	r5, r5, #1
        if ( UARTn(ui32Module)->FR_b.RXFE )
   123ee:	f53f aed5 	bmi.w	1219c <am_hal_uart_transfer+0x234>
            ui32ReadData = UARTn(ui32Module)->DR;
   123f2:	680a      	ldr	r2, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   123f4:	f412 6f70 	tst.w	r2, #3840	; 0xf00
   123f8:	f040 817c 	bne.w	126f4 <am_hal_uart_transfer+0x78c>
                pui8Data[i++] = ui32ReadData & 0xFF;
   123fc:	70c2      	strb	r2, [r0, #3]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   123fe:	698e      	ldr	r6, [r1, #24]
   12400:	06f2      	lsls	r2, r6, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   12402:	f103 0502 	add.w	r5, r3, #2
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12406:	f53f aec9 	bmi.w	1219c <am_hal_uart_transfer+0x234>
            ui32ReadData = UARTn(ui32Module)->DR;
   1240a:	680a      	ldr	r2, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   1240c:	f412 6f70 	tst.w	r2, #3840	; 0xf00
   12410:	f040 8170 	bne.w	126f4 <am_hal_uart_transfer+0x78c>
                pui8Data[i++] = ui32ReadData & 0xFF;
   12414:	f800 2f04 	strb.w	r2, [r0, #4]!
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12418:	698e      	ldr	r6, [r1, #24]
   1241a:	06f6      	lsls	r6, r6, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   1241c:	f103 0503 	add.w	r5, r3, #3
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12420:	f53f aebc 	bmi.w	1219c <am_hal_uart_transfer+0x234>
   12424:	e7c8      	b.n	123b8 <am_hal_uart_transfer+0x450>
    while (ui32RemainingBytes && (ui32TimeSpent < ui32TimeoutMs))
   12426:	4625      	mov	r5, r4
    if (pui32NumBytesRead)
   12428:	b107      	cbz	r7, 1242c <am_hal_uart_transfer+0x4c4>
        *pui32NumBytesRead = i;
   1242a:	603d      	str	r5, [r7, #0]
    return AM_HAL_STATUS_SUCCESS;
   1242c:	f04f 0b00 	mov.w	fp, #0
   12430:	e5a6      	b.n	11f80 <am_hal_uart_transfer+0x18>
        i += ui32BytesWritten;
   12432:	442e      	add	r6, r5
   12434:	e679      	b.n	1212a <am_hal_uart_transfer+0x1c2>
        ui32BufferSpace = am_hal_queue_space_left(&pState->sTxQueue);
   12436:	f8d8 0038 	ldr.w	r0, [r8, #56]	; 0x38
   1243a:	f8d8 2034 	ldr.w	r2, [r8, #52]	; 0x34
   1243e:	1a84      	subs	r4, r0, r2
                                 ui32NumBytes : ui32BufferSpace);
   12440:	42ac      	cmp	r4, r5
   12442:	bf28      	it	cs
   12444:	462c      	movcs	r4, r5
        am_hal_queue_item_add(&pState->sTxQueue, pui8Data, ui32BytesTransferred);
   12446:	4622      	mov	r2, r4
   12448:	9802      	ldr	r0, [sp, #8]
   1244a:	f000 fa4f 	bl	128ec <am_hal_queue_item_add>
    uint32_t ui32Module = pState->ui32Module;
   1244e:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
   12452:	9303      	str	r3, [sp, #12]
    AM_CRITICAL_BEGIN
   12454:	f7ff f9ce 	bl	117f4 <am_hal_interrupt_master_disable>
   12458:	9903      	ldr	r1, [sp, #12]
   1245a:	9008      	str	r0, [sp, #32]
   1245c:	f501 2280 	add.w	r2, r1, #262144	; 0x40000
   12460:	321c      	adds	r2, #28
   12462:	0313      	lsls	r3, r2, #12
   12464:	9303      	str	r3, [sp, #12]
   12466:	e010      	b.n	1248a <am_hal_uart_transfer+0x522>
   12468:	01ea9e06 	.word	0x01ea9e06
        if (am_hal_queue_item_get(&pState->sTxQueue, &pui8Data, 1))
   1246c:	f000 fb42 	bl	12af4 <am_hal_queue_item_get>
   12470:	b198      	cbz	r0, 1249a <am_hal_uart_transfer+0x532>
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12472:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
   12476:	f502 2380 	add.w	r3, r2, #262144	; 0x40000
   1247a:	331c      	adds	r3, #28
   1247c:	0318      	lsls	r0, r3, #12
   1247e:	6981      	ldr	r1, [r0, #24]
   12480:	068a      	lsls	r2, r1, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   12482:	bf5c      	itt	pl
   12484:	f89d 201c 	ldrbpl.w	r2, [sp, #28]
   12488:	6002      	strpl	r2, [r0, #0]
    while ( !UARTn(ui32Module)->FR_b.TXFF )
   1248a:	9b03      	ldr	r3, [sp, #12]
        if (am_hal_queue_item_get(&pState->sTxQueue, &pui8Data, 1))
   1248c:	9802      	ldr	r0, [sp, #8]
    while ( !UARTn(ui32Module)->FR_b.TXFF )
   1248e:	699b      	ldr	r3, [r3, #24]
   12490:	069b      	lsls	r3, r3, #26
        if (am_hal_queue_item_get(&pState->sTxQueue, &pui8Data, 1))
   12492:	f04f 0201 	mov.w	r2, #1
   12496:	a907      	add	r1, sp, #28
    while ( !UARTn(ui32Module)->FR_b.TXFF )
   12498:	d5e8      	bpl.n	1246c <am_hal_uart_transfer+0x504>
    AM_CRITICAL_END
   1249a:	9808      	ldr	r0, [sp, #32]
   1249c:	f7ff f9ae 	bl	117fc <am_hal_interrupt_master_set>
   124a0:	e640      	b.n	12124 <am_hal_uart_transfer+0x1bc>
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   124a2:	2600      	movs	r6, #0
   124a4:	469a      	mov	sl, r3
        if (!am_hal_queue_item_add(&pState->sRxQueue, pui8Data,
   124a6:	f108 0348 	add.w	r3, r8, #72	; 0x48
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   124aa:	9101      	str	r1, [sp, #4]
   124ac:	4635      	mov	r5, r6
        if (!am_hal_queue_item_add(&pState->sRxQueue, pui8Data,
   124ae:	9302      	str	r3, [sp, #8]
    if (pState->bEnableRxQueue)
   124b0:	f898 0044 	ldrb.w	r0, [r8, #68]	; 0x44
   124b4:	2800      	cmp	r0, #0
   124b6:	f040 8089 	bne.w	125cc <am_hal_uart_transfer+0x664>
    uint32_t ui32Module = pState->ui32Module;
   124ba:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
    while (i < ui32NumBytes)
   124be:	2c00      	cmp	r4, #0
   124c0:	d0b2      	beq.n	12428 <am_hal_uart_transfer+0x4c0>
        if ( UARTn(ui32Module)->FR_b.RXFE )
   124c2:	f502 2180 	add.w	r1, r2, #262144	; 0x40000
   124c6:	311c      	adds	r1, #28
   124c8:	030a      	lsls	r2, r1, #12
   124ca:	6993      	ldr	r3, [r2, #24]
   124cc:	06d8      	lsls	r0, r3, #27
   124ce:	d466      	bmi.n	1259e <am_hal_uart_transfer+0x636>
            ui32ReadData = UARTn(ui32Module)->DR;
   124d0:	6811      	ldr	r1, [r2, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   124d2:	f411 6370 	ands.w	r3, r1, #3840	; 0xf00
   124d6:	f040 810d 	bne.w	126f4 <am_hal_uart_transfer+0x78c>
   124da:	f104 3eff 	add.w	lr, r4, #4294967295
   124de:	f01e 0e03 	ands.w	lr, lr, #3
   124e2:	f109 30ff 	add.w	r0, r9, #4294967295
   124e6:	d029      	beq.n	1253c <am_hal_uart_transfer+0x5d4>
                pui8Data[i++] = ui32ReadData & 0xFF;
   124e8:	f889 1000 	strb.w	r1, [r9]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   124ec:	6991      	ldr	r1, [r2, #24]
   124ee:	06c9      	lsls	r1, r1, #27
   124f0:	4648      	mov	r0, r9
                pui8Data[i++] = ui32ReadData & 0xFF;
   124f2:	f04f 0301 	mov.w	r3, #1
        if ( UARTn(ui32Module)->FR_b.RXFE )
   124f6:	d44e      	bmi.n	12596 <am_hal_uart_transfer+0x62e>
            ui32ReadData = UARTn(ui32Module)->DR;
   124f8:	6811      	ldr	r1, [r2, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   124fa:	f411 6f70 	tst.w	r1, #3840	; 0xf00
   124fe:	f040 80e0 	bne.w	126c2 <am_hal_uart_transfer+0x75a>
   12502:	459e      	cmp	lr, r3
   12504:	d01a      	beq.n	1253c <am_hal_uart_transfer+0x5d4>
   12506:	f1be 0f02 	cmp.w	lr, #2
   1250a:	d00b      	beq.n	12524 <am_hal_uart_transfer+0x5bc>
                pui8Data[i++] = ui32ReadData & 0xFF;
   1250c:	f800 1f01 	strb.w	r1, [r0, #1]!
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12510:	6991      	ldr	r1, [r2, #24]
   12512:	06c9      	lsls	r1, r1, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   12514:	f04f 0302 	mov.w	r3, #2
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12518:	d43d      	bmi.n	12596 <am_hal_uart_transfer+0x62e>
            ui32ReadData = UARTn(ui32Module)->DR;
   1251a:	6811      	ldr	r1, [r2, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   1251c:	f411 6f70 	tst.w	r1, #3840	; 0xf00
   12520:	f040 80cf 	bne.w	126c2 <am_hal_uart_transfer+0x75a>
                pui8Data[i++] = ui32ReadData & 0xFF;
   12524:	f800 1f01 	strb.w	r1, [r0, #1]!
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12528:	6991      	ldr	r1, [r2, #24]
   1252a:	06c9      	lsls	r1, r1, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   1252c:	f103 0301 	add.w	r3, r3, #1
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12530:	d431      	bmi.n	12596 <am_hal_uart_transfer+0x62e>
            ui32ReadData = UARTn(ui32Module)->DR;
   12532:	6811      	ldr	r1, [r2, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   12534:	f411 6f70 	tst.w	r1, #3840	; 0xf00
   12538:	f040 80c3 	bne.w	126c2 <am_hal_uart_transfer+0x75a>
                pui8Data[i++] = ui32ReadData & 0xFF;
   1253c:	3301      	adds	r3, #1
    while (i < ui32NumBytes)
   1253e:	42a3      	cmp	r3, r4
                pui8Data[i++] = ui32ReadData & 0xFF;
   12540:	7041      	strb	r1, [r0, #1]
   12542:	469e      	mov	lr, r3
   12544:	f100 0c01 	add.w	ip, r0, #1
    while (i < ui32NumBytes)
   12548:	d025      	beq.n	12596 <am_hal_uart_transfer+0x62e>
        if ( UARTn(ui32Module)->FR_b.RXFE )
   1254a:	6991      	ldr	r1, [r2, #24]
   1254c:	06c9      	lsls	r1, r1, #27
   1254e:	d422      	bmi.n	12596 <am_hal_uart_transfer+0x62e>
            ui32ReadData = UARTn(ui32Module)->DR;
   12550:	6811      	ldr	r1, [r2, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   12552:	f411 6f70 	tst.w	r1, #3840	; 0xf00
   12556:	f040 80b4 	bne.w	126c2 <am_hal_uart_transfer+0x75a>
                pui8Data[i++] = ui32ReadData & 0xFF;
   1255a:	f88c 1001 	strb.w	r1, [ip, #1]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   1255e:	6991      	ldr	r1, [r2, #24]
   12560:	06c9      	lsls	r1, r1, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   12562:	f103 0301 	add.w	r3, r3, #1
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12566:	d416      	bmi.n	12596 <am_hal_uart_transfer+0x62e>
            ui32ReadData = UARTn(ui32Module)->DR;
   12568:	6811      	ldr	r1, [r2, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   1256a:	f411 6f70 	tst.w	r1, #3840	; 0xf00
   1256e:	f040 80a8 	bne.w	126c2 <am_hal_uart_transfer+0x75a>
                pui8Data[i++] = ui32ReadData & 0xFF;
   12572:	70c1      	strb	r1, [r0, #3]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12574:	6991      	ldr	r1, [r2, #24]
   12576:	06c9      	lsls	r1, r1, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   12578:	f10e 0302 	add.w	r3, lr, #2
        if ( UARTn(ui32Module)->FR_b.RXFE )
   1257c:	d40b      	bmi.n	12596 <am_hal_uart_transfer+0x62e>
            ui32ReadData = UARTn(ui32Module)->DR;
   1257e:	6811      	ldr	r1, [r2, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   12580:	f411 6f70 	tst.w	r1, #3840	; 0xf00
   12584:	f040 809d 	bne.w	126c2 <am_hal_uart_transfer+0x75a>
                pui8Data[i++] = ui32ReadData & 0xFF;
   12588:	f800 1f04 	strb.w	r1, [r0, #4]!
        if ( UARTn(ui32Module)->FR_b.RXFE )
   1258c:	6991      	ldr	r1, [r2, #24]
   1258e:	06c9      	lsls	r1, r1, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   12590:	f10e 0303 	add.w	r3, lr, #3
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12594:	d5cd      	bpl.n	12532 <am_hal_uart_transfer+0x5ca>
        if (ui32RemainingBytes)
   12596:	1ae4      	subs	r4, r4, r3
        i += ui32BytesRead;
   12598:	441d      	add	r5, r3
        if (ui32RemainingBytes)
   1259a:	f43f af45 	beq.w	12428 <am_hal_uart_transfer+0x4c0>
            am_hal_flash_delay(FLASH_CYCLES_US(1));
   1259e:	2001      	movs	r0, #1
   125a0:	f7fe fe68 	bl	11274 <am_hal_flash_delay>
            if (ui32TimeoutMs != AM_HAL_UART_WAIT_FOREVER)
   125a4:	f1bb 3fff 	cmp.w	fp, #4294967295
                ui32TimeSpent++;
   125a8:	bf18      	it	ne
   125aa:	3601      	addne	r6, #1
    while (ui32RemainingBytes && (ui32TimeSpent < ui32TimeoutMs))
   125ac:	45b3      	cmp	fp, r6
   125ae:	f67f af3b 	bls.w	12428 <am_hal_uart_transfer+0x4c0>
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   125b2:	f8d8 0000 	ldr.w	r0, [r8]
   125b6:	9a01      	ldr	r2, [sp, #4]
   125b8:	f020 417e 	bic.w	r1, r0, #4261412864	; 0xfe000000
   125bc:	4291      	cmp	r1, r2
        ui32Status = read_nonblocking(pHandle, &pui8Data[i],
   125be:	eb0a 0905 	add.w	r9, sl, r5
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   125c2:	f43f af75 	beq.w	124b0 <am_hal_uart_transfer+0x548>
        return AM_HAL_STATUS_INVALID_HANDLE;
   125c6:	f04f 0b02 	mov.w	fp, #2
   125ca:	e5e7      	b.n	1219c <am_hal_uart_transfer+0x234>
    AM_CRITICAL_BEGIN
   125cc:	f7ff f912 	bl	117f4 <am_hal_interrupt_master_disable>
   125d0:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
   125d4:	9007      	str	r0, [sp, #28]
   125d6:	f502 2080 	add.w	r0, r2, #262144	; 0x40000
   125da:	301c      	adds	r0, #28
    uint32_t i = 0;
   125dc:	f8cd a00c 	str.w	sl, [sp, #12]
   125e0:	0303      	lsls	r3, r0, #12
   125e2:	f10d 0c20 	add.w	ip, sp, #32
   125e6:	2200      	movs	r2, #0
   125e8:	46a2      	mov	sl, r4
        if ( UARTn(ui32Module)->FR_b.RXFE )
   125ea:	699c      	ldr	r4, [r3, #24]
   125ec:	06e1      	lsls	r1, r4, #27
   125ee:	d45a      	bmi.n	126a6 <am_hal_uart_transfer+0x73e>
            ui32ReadData = UARTn(ui32Module)->DR;
   125f0:	6818      	ldr	r0, [r3, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   125f2:	f410 6f70 	tst.w	r0, #3840	; 0xf00
   125f6:	d17a      	bne.n	126ee <am_hal_uart_transfer+0x786>
                pui8Data[i++] = ui32ReadData & 0xFF;
   125f8:	46e6      	mov	lr, ip
   125fa:	3201      	adds	r2, #1
   125fc:	f80e 0b01 	strb.w	r0, [lr], #1
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12600:	6999      	ldr	r1, [r3, #24]
   12602:	06cc      	lsls	r4, r1, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   12604:	4610      	mov	r0, r2
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12606:	d44e      	bmi.n	126a6 <am_hal_uart_transfer+0x73e>
            ui32ReadData = UARTn(ui32Module)->DR;
   12608:	681c      	ldr	r4, [r3, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   1260a:	f414 6f70 	tst.w	r4, #3840	; 0xf00
   1260e:	d16e      	bne.n	126ee <am_hal_uart_transfer+0x786>
                pui8Data[i++] = ui32ReadData & 0xFF;
   12610:	f88e 4000 	strb.w	r4, [lr]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12614:	6999      	ldr	r1, [r3, #24]
   12616:	06cc      	lsls	r4, r1, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   12618:	f102 0201 	add.w	r2, r2, #1
        if ( UARTn(ui32Module)->FR_b.RXFE )
   1261c:	d443      	bmi.n	126a6 <am_hal_uart_transfer+0x73e>
            ui32ReadData = UARTn(ui32Module)->DR;
   1261e:	681a      	ldr	r2, [r3, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   12620:	f412 6f70 	tst.w	r2, #3840	; 0xf00
   12624:	d163      	bne.n	126ee <am_hal_uart_transfer+0x786>
                pui8Data[i++] = ui32ReadData & 0xFF;
   12626:	f88e 2001 	strb.w	r2, [lr, #1]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   1262a:	699c      	ldr	r4, [r3, #24]
   1262c:	06e4      	lsls	r4, r4, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   1262e:	f100 0202 	add.w	r2, r0, #2
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12632:	d438      	bmi.n	126a6 <am_hal_uart_transfer+0x73e>
            ui32ReadData = UARTn(ui32Module)->DR;
   12634:	6819      	ldr	r1, [r3, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   12636:	f411 6f70 	tst.w	r1, #3840	; 0xf00
   1263a:	d158      	bne.n	126ee <am_hal_uart_transfer+0x786>
                pui8Data[i++] = ui32ReadData & 0xFF;
   1263c:	f88c 1003 	strb.w	r1, [ip, #3]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12640:	699c      	ldr	r4, [r3, #24]
   12642:	06e4      	lsls	r4, r4, #27
   12644:	f10c 0c04 	add.w	ip, ip, #4
                pui8Data[i++] = ui32ReadData & 0xFF;
   12648:	f100 0203 	add.w	r2, r0, #3
        if ( UARTn(ui32Module)->FR_b.RXFE )
   1264c:	d42b      	bmi.n	126a6 <am_hal_uart_transfer+0x73e>
            ui32ReadData = UARTn(ui32Module)->DR;
   1264e:	681a      	ldr	r2, [r3, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   12650:	f412 6f70 	tst.w	r2, #3840	; 0xf00
   12654:	d14b      	bne.n	126ee <am_hal_uart_transfer+0x786>
                pui8Data[i++] = ui32ReadData & 0xFF;
   12656:	f88c 2000 	strb.w	r2, [ip]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   1265a:	6999      	ldr	r1, [r3, #24]
   1265c:	06cc      	lsls	r4, r1, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   1265e:	f100 0204 	add.w	r2, r0, #4
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12662:	d420      	bmi.n	126a6 <am_hal_uart_transfer+0x73e>
            ui32ReadData = UARTn(ui32Module)->DR;
   12664:	681c      	ldr	r4, [r3, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   12666:	f414 6f70 	tst.w	r4, #3840	; 0xf00
   1266a:	d140      	bne.n	126ee <am_hal_uart_transfer+0x786>
                pui8Data[i++] = ui32ReadData & 0xFF;
   1266c:	f88e 4004 	strb.w	r4, [lr, #4]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12670:	6999      	ldr	r1, [r3, #24]
   12672:	06cc      	lsls	r4, r1, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   12674:	f100 0205 	add.w	r2, r0, #5
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12678:	d415      	bmi.n	126a6 <am_hal_uart_transfer+0x73e>
            ui32ReadData = UARTn(ui32Module)->DR;
   1267a:	681a      	ldr	r2, [r3, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   1267c:	f412 6f70 	tst.w	r2, #3840	; 0xf00
   12680:	d135      	bne.n	126ee <am_hal_uart_transfer+0x786>
                pui8Data[i++] = ui32ReadData & 0xFF;
   12682:	f88e 2005 	strb.w	r2, [lr, #5]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12686:	699c      	ldr	r4, [r3, #24]
   12688:	06e4      	lsls	r4, r4, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   1268a:	f100 0206 	add.w	r2, r0, #6
        if ( UARTn(ui32Module)->FR_b.RXFE )
   1268e:	d40a      	bmi.n	126a6 <am_hal_uart_transfer+0x73e>
            ui32ReadData = UARTn(ui32Module)->DR;
   12690:	6819      	ldr	r1, [r3, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   12692:	f411 6f70 	tst.w	r1, #3840	; 0xf00
   12696:	d12a      	bne.n	126ee <am_hal_uart_transfer+0x786>
                pui8Data[i++] = ui32ReadData & 0xFF;
   12698:	1dc2      	adds	r2, r0, #7
    while (i < ui32NumBytes)
   1269a:	2a20      	cmp	r2, #32
                pui8Data[i++] = ui32ReadData & 0xFF;
   1269c:	f88e 1006 	strb.w	r1, [lr, #6]
   126a0:	f10e 0c07 	add.w	ip, lr, #7
    while (i < ui32NumBytes)
   126a4:	d1a1      	bne.n	125ea <am_hal_uart_transfer+0x682>
        if (!am_hal_queue_item_add(&pState->sRxQueue, pui8Data,
   126a6:	a908      	add	r1, sp, #32
   126a8:	9802      	ldr	r0, [sp, #8]
   126aa:	4654      	mov	r4, sl
   126ac:	f8dd a00c 	ldr.w	sl, [sp, #12]
   126b0:	f000 f91c 	bl	128ec <am_hal_queue_item_add>
   126b4:	b958      	cbnz	r0, 126ce <am_hal_uart_transfer+0x766>
            ui32ErrorStatus = AM_HAL_UART_STATUS_RX_QUEUE_FULL;
   126b6:	f8df b1b4 	ldr.w	fp, [pc, #436]	; 1286c <am_hal_uart_transfer+0x904>
    AM_CRITICAL_END
   126ba:	9807      	ldr	r0, [sp, #28]
   126bc:	f7ff f89e 	bl	117fc <am_hal_interrupt_master_set>
   126c0:	e56c      	b.n	1219c <am_hal_uart_transfer+0x234>
   126c2:	441d      	add	r5, r3
                ui32ErrorStatus =  AM_HAL_UART_STATUS_BUS_ERROR;
   126c4:	f04f 6b00 	mov.w	fp, #134217728	; 0x8000000
   126c8:	e568      	b.n	1219c <am_hal_uart_transfer+0x234>
    while (ui32RemainingBytes && (ui32TimeSpent < ui32TimeoutMs))
   126ca:	462e      	mov	r6, r5
   126cc:	e52d      	b.n	1212a <am_hal_uart_transfer+0x1c2>
    AM_CRITICAL_END
   126ce:	9807      	ldr	r0, [sp, #28]
   126d0:	f7ff f894 	bl	117fc <am_hal_interrupt_master_set>
                                ui32NumBytes : ui32BufferData);
   126d4:	f8d8 3050 	ldr.w	r3, [r8, #80]	; 0x50
        am_hal_queue_item_get(&pState->sRxQueue, pui8Data, ui32BytesTransferred);
   126d8:	9802      	ldr	r0, [sp, #8]
                                ui32NumBytes : ui32BufferData);
   126da:	42a3      	cmp	r3, r4
   126dc:	bf28      	it	cs
   126de:	4623      	movcs	r3, r4
        am_hal_queue_item_get(&pState->sRxQueue, pui8Data, ui32BytesTransferred);
   126e0:	461a      	mov	r2, r3
   126e2:	4649      	mov	r1, r9
   126e4:	9303      	str	r3, [sp, #12]
   126e6:	f000 fa05 	bl	12af4 <am_hal_queue_item_get>
   126ea:	9b03      	ldr	r3, [sp, #12]
   126ec:	e753      	b.n	12596 <am_hal_uart_transfer+0x62e>
                ui32ErrorStatus =  AM_HAL_UART_STATUS_BUS_ERROR;
   126ee:	f04f 6b00 	mov.w	fp, #134217728	; 0x8000000
   126f2:	e7e2      	b.n	126ba <am_hal_uart_transfer+0x752>
   126f4:	f04f 6b00 	mov.w	fp, #134217728	; 0x8000000
   126f8:	e550      	b.n	1219c <am_hal_uart_transfer+0x234>
        ui32BufferSpace = am_hal_queue_space_left(&pState->sTxQueue);
   126fa:	f8d8 1034 	ldr.w	r1, [r8, #52]	; 0x34
   126fe:	f8d8 2038 	ldr.w	r2, [r8, #56]	; 0x38
   12702:	1a52      	subs	r2, r2, r1
                                 ui32NumBytes : ui32BufferSpace);
   12704:	42aa      	cmp	r2, r5
        am_hal_queue_item_add(&pState->sTxQueue, pui8Data, ui32BytesTransferred);
   12706:	f108 092c 	add.w	r9, r8, #44	; 0x2c
                                 ui32NumBytes : ui32BufferSpace);
   1270a:	bf28      	it	cs
   1270c:	462a      	movcs	r2, r5
        am_hal_queue_item_add(&pState->sTxQueue, pui8Data, ui32BytesTransferred);
   1270e:	9901      	ldr	r1, [sp, #4]
   12710:	4648      	mov	r0, r9
                                 ui32NumBytes : ui32BufferSpace);
   12712:	4614      	mov	r4, r2
        am_hal_queue_item_add(&pState->sTxQueue, pui8Data, ui32BytesTransferred);
   12714:	f000 f8ea 	bl	128ec <am_hal_queue_item_add>
    uint32_t ui32Module = pState->ui32Module;
   12718:	f8d8 6024 	ldr.w	r6, [r8, #36]	; 0x24
    AM_CRITICAL_BEGIN
   1271c:	f7ff f86a 	bl	117f4 <am_hal_interrupt_master_disable>
   12720:	f506 2380 	add.w	r3, r6, #262144	; 0x40000
   12724:	331c      	adds	r3, #28
   12726:	031d      	lsls	r5, r3, #12
   12728:	9005      	str	r0, [sp, #20]
   1272a:	e00e      	b.n	1274a <am_hal_uart_transfer+0x7e2>
        if (am_hal_queue_item_get(&pState->sTxQueue, &pui8Data, 1))
   1272c:	f000 f9e2 	bl	12af4 <am_hal_queue_item_get>
   12730:	b190      	cbz	r0, 12758 <am_hal_uart_transfer+0x7f0>
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12732:	f8d8 0024 	ldr.w	r0, [r8, #36]	; 0x24
   12736:	f500 2280 	add.w	r2, r0, #262144	; 0x40000
   1273a:	321c      	adds	r2, #28
   1273c:	0311      	lsls	r1, r2, #12
   1273e:	698e      	ldr	r6, [r1, #24]
   12740:	06b3      	lsls	r3, r6, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   12742:	bf5c      	itt	pl
   12744:	f89d 3020 	ldrbpl.w	r3, [sp, #32]
   12748:	600b      	strpl	r3, [r1, #0]
    while ( !UARTn(ui32Module)->FR_b.TXFF )
   1274a:	69af      	ldr	r7, [r5, #24]
   1274c:	06bf      	lsls	r7, r7, #26
        if (am_hal_queue_item_get(&pState->sTxQueue, &pui8Data, 1))
   1274e:	f04f 0201 	mov.w	r2, #1
   12752:	a908      	add	r1, sp, #32
   12754:	4648      	mov	r0, r9
    while ( !UARTn(ui32Module)->FR_b.TXFF )
   12756:	d5e9      	bpl.n	1272c <am_hal_uart_transfer+0x7c4>
    AM_CRITICAL_END
   12758:	9805      	ldr	r0, [sp, #20]
   1275a:	f7ff f84f 	bl	117fc <am_hal_interrupt_master_set>
   1275e:	e5d1      	b.n	12304 <am_hal_uart_transfer+0x39c>
    AM_CRITICAL_BEGIN
   12760:	f7ff f848 	bl	117f4 <am_hal_interrupt_master_disable>
   12764:	f8d8 1024 	ldr.w	r1, [r8, #36]	; 0x24
   12768:	9006      	str	r0, [sp, #24]
   1276a:	f501 2080 	add.w	r0, r1, #262144	; 0x40000
   1276e:	301c      	adds	r0, #28
   12770:	0301      	lsls	r1, r0, #12
   12772:	ab08      	add	r3, sp, #32
    uint32_t i = 0;
   12774:	2200      	movs	r2, #0
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12776:	698e      	ldr	r6, [r1, #24]
   12778:	06f0      	lsls	r0, r6, #27
   1277a:	d455      	bmi.n	12828 <am_hal_uart_transfer+0x8c0>
            ui32ReadData = UARTn(ui32Module)->DR;
   1277c:	680d      	ldr	r5, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   1277e:	f415 6f70 	tst.w	r5, #3840	; 0xf00
   12782:	d16f      	bne.n	12864 <am_hal_uart_transfer+0x8fc>
                pui8Data[i++] = ui32ReadData & 0xFF;
   12784:	4618      	mov	r0, r3
   12786:	3201      	adds	r2, #1
   12788:	f800 5b01 	strb.w	r5, [r0], #1
        if ( UARTn(ui32Module)->FR_b.RXFE )
   1278c:	698e      	ldr	r6, [r1, #24]
   1278e:	06f6      	lsls	r6, r6, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   12790:	4615      	mov	r5, r2
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12792:	d449      	bmi.n	12828 <am_hal_uart_transfer+0x8c0>
            ui32ReadData = UARTn(ui32Module)->DR;
   12794:	680e      	ldr	r6, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   12796:	f416 6f70 	tst.w	r6, #3840	; 0xf00
   1279a:	d163      	bne.n	12864 <am_hal_uart_transfer+0x8fc>
                pui8Data[i++] = ui32ReadData & 0xFF;
   1279c:	7006      	strb	r6, [r0, #0]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   1279e:	698e      	ldr	r6, [r1, #24]
   127a0:	06f6      	lsls	r6, r6, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   127a2:	f102 0201 	add.w	r2, r2, #1
        if ( UARTn(ui32Module)->FR_b.RXFE )
   127a6:	d43f      	bmi.n	12828 <am_hal_uart_transfer+0x8c0>
            ui32ReadData = UARTn(ui32Module)->DR;
   127a8:	680a      	ldr	r2, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   127aa:	f412 6f70 	tst.w	r2, #3840	; 0xf00
   127ae:	d159      	bne.n	12864 <am_hal_uart_transfer+0x8fc>
                pui8Data[i++] = ui32ReadData & 0xFF;
   127b0:	7042      	strb	r2, [r0, #1]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   127b2:	f8d1 e018 	ldr.w	lr, [r1, #24]
   127b6:	f01e 0f10 	tst.w	lr, #16
                pui8Data[i++] = ui32ReadData & 0xFF;
   127ba:	f105 0202 	add.w	r2, r5, #2
        if ( UARTn(ui32Module)->FR_b.RXFE )
   127be:	d133      	bne.n	12828 <am_hal_uart_transfer+0x8c0>
            ui32ReadData = UARTn(ui32Module)->DR;
   127c0:	680e      	ldr	r6, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   127c2:	f416 6f70 	tst.w	r6, #3840	; 0xf00
   127c6:	d14d      	bne.n	12864 <am_hal_uart_transfer+0x8fc>
                pui8Data[i++] = ui32ReadData & 0xFF;
   127c8:	70de      	strb	r6, [r3, #3]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   127ca:	698e      	ldr	r6, [r1, #24]
   127cc:	06f6      	lsls	r6, r6, #27
   127ce:	f103 0304 	add.w	r3, r3, #4
                pui8Data[i++] = ui32ReadData & 0xFF;
   127d2:	f105 0203 	add.w	r2, r5, #3
        if ( UARTn(ui32Module)->FR_b.RXFE )
   127d6:	d427      	bmi.n	12828 <am_hal_uart_transfer+0x8c0>
            ui32ReadData = UARTn(ui32Module)->DR;
   127d8:	680a      	ldr	r2, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   127da:	f412 6f70 	tst.w	r2, #3840	; 0xf00
   127de:	d141      	bne.n	12864 <am_hal_uart_transfer+0x8fc>
                pui8Data[i++] = ui32ReadData & 0xFF;
   127e0:	701a      	strb	r2, [r3, #0]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   127e2:	698b      	ldr	r3, [r1, #24]
   127e4:	06db      	lsls	r3, r3, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   127e6:	f105 0204 	add.w	r2, r5, #4
        if ( UARTn(ui32Module)->FR_b.RXFE )
   127ea:	d41d      	bmi.n	12828 <am_hal_uart_transfer+0x8c0>
            ui32ReadData = UARTn(ui32Module)->DR;
   127ec:	680e      	ldr	r6, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   127ee:	f416 6f70 	tst.w	r6, #3840	; 0xf00
   127f2:	d137      	bne.n	12864 <am_hal_uart_transfer+0x8fc>
                pui8Data[i++] = ui32ReadData & 0xFF;
   127f4:	7106      	strb	r6, [r0, #4]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   127f6:	698b      	ldr	r3, [r1, #24]
   127f8:	06de      	lsls	r6, r3, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   127fa:	f105 0205 	add.w	r2, r5, #5
        if ( UARTn(ui32Module)->FR_b.RXFE )
   127fe:	d413      	bmi.n	12828 <am_hal_uart_transfer+0x8c0>
            ui32ReadData = UARTn(ui32Module)->DR;
   12800:	680a      	ldr	r2, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   12802:	f412 6f70 	tst.w	r2, #3840	; 0xf00
   12806:	d12d      	bne.n	12864 <am_hal_uart_transfer+0x8fc>
                pui8Data[i++] = ui32ReadData & 0xFF;
   12808:	7142      	strb	r2, [r0, #5]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   1280a:	698e      	ldr	r6, [r1, #24]
   1280c:	06f3      	lsls	r3, r6, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   1280e:	f105 0206 	add.w	r2, r5, #6
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12812:	d409      	bmi.n	12828 <am_hal_uart_transfer+0x8c0>
            ui32ReadData = UARTn(ui32Module)->DR;
   12814:	680b      	ldr	r3, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   12816:	f413 6f70 	tst.w	r3, #3840	; 0xf00
   1281a:	d123      	bne.n	12864 <am_hal_uart_transfer+0x8fc>
                pui8Data[i++] = ui32ReadData & 0xFF;
   1281c:	1dea      	adds	r2, r5, #7
    while (i < ui32NumBytes)
   1281e:	2a20      	cmp	r2, #32
                pui8Data[i++] = ui32ReadData & 0xFF;
   12820:	7183      	strb	r3, [r0, #6]
   12822:	f100 0307 	add.w	r3, r0, #7
    while (i < ui32NumBytes)
   12826:	d1a6      	bne.n	12776 <am_hal_uart_transfer+0x80e>
        if (!am_hal_queue_item_add(&pState->sRxQueue, pui8Data,
   12828:	f108 0a48 	add.w	sl, r8, #72	; 0x48
   1282c:	a908      	add	r1, sp, #32
   1282e:	4650      	mov	r0, sl
   12830:	f000 f85c 	bl	128ec <am_hal_queue_item_add>
   12834:	b930      	cbnz	r0, 12844 <am_hal_uart_transfer+0x8dc>
            ui32ErrorStatus = AM_HAL_UART_STATUS_RX_QUEUE_FULL;
   12836:	f8df b034 	ldr.w	fp, [pc, #52]	; 1286c <am_hal_uart_transfer+0x904>
    AM_CRITICAL_END
   1283a:	9806      	ldr	r0, [sp, #24]
   1283c:	f7fe ffde 	bl	117fc <am_hal_interrupt_master_set>
   12840:	f7ff bb9e 	b.w	11f80 <am_hal_uart_transfer+0x18>
   12844:	9806      	ldr	r0, [sp, #24]
   12846:	f7fe ffd9 	bl	117fc <am_hal_interrupt_master_set>
                                ui32NumBytes : ui32BufferData);
   1284a:	f8d8 5050 	ldr.w	r5, [r8, #80]	; 0x50
   1284e:	42a5      	cmp	r5, r4
   12850:	bf28      	it	cs
   12852:	4625      	movcs	r5, r4
        am_hal_queue_item_get(&pState->sRxQueue, pui8Data, ui32BytesTransferred);
   12854:	4649      	mov	r1, r9
   12856:	4650      	mov	r0, sl
   12858:	462a      	mov	r2, r5
   1285a:	f000 f94b 	bl	12af4 <am_hal_queue_item_get>
   1285e:	e49d      	b.n	1219c <am_hal_uart_transfer+0x234>
    uint32_t i = 0;
   12860:	4605      	mov	r5, r0
   12862:	e49b      	b.n	1219c <am_hal_uart_transfer+0x234>
                ui32ErrorStatus =  AM_HAL_UART_STATUS_BUS_ERROR;
   12864:	f04f 6b00 	mov.w	fp, #134217728	; 0x8000000
   12868:	e7e7      	b.n	1283a <am_hal_uart_transfer+0x8d2>
   1286a:	bf00      	nop
   1286c:	08000001 	.word	0x08000001

00012870 <am_hal_uart_tx_flush>:
    if (pState->bEnableTxQueue)
   12870:	f890 3028 	ldrb.w	r3, [r0, #40]	; 0x28
{
   12874:	b570      	push	{r4, r5, r6, lr}
   12876:	4604      	mov	r4, r0
    uint32_t ui32Module = pState->ui32Module;
   12878:	6a45      	ldr	r5, [r0, #36]	; 0x24
    if (pState->bEnableTxQueue)
   1287a:	b183      	cbz	r3, 1289e <am_hal_uart_tx_flush+0x2e>
        while (am_hal_queue_data_left(&(pState->sTxQueue)))
   1287c:	6b40      	ldr	r0, [r0, #52]	; 0x34
   1287e:	b170      	cbz	r0, 1289e <am_hal_uart_tx_flush+0x2e>
            ONE_BYTE_DELAY(pState);
   12880:	4e13      	ldr	r6, [pc, #76]	; (128d0 <am_hal_uart_tx_flush+0x60>)
   12882:	6e21      	ldr	r1, [r4, #96]	; 0x60
   12884:	fbb6 f2f1 	udiv	r2, r6, r1
   12888:	2a02      	cmp	r2, #2
   1288a:	ea4f 1002 	mov.w	r0, r2, lsl #4
   1288e:	bf8c      	ite	hi
   12890:	3829      	subhi	r0, #41	; 0x29
   12892:	2001      	movls	r0, #1
   12894:	f7fe fcee 	bl	11274 <am_hal_flash_delay>
        while (am_hal_queue_data_left(&(pState->sTxQueue)))
   12898:	6b63      	ldr	r3, [r4, #52]	; 0x34
   1289a:	2b00      	cmp	r3, #0
   1289c:	d1f1      	bne.n	12882 <am_hal_uart_tx_flush+0x12>
    while ( UARTn(ui32Module)->FR_b.BUSY )
   1289e:	f505 2580 	add.w	r5, r5, #262144	; 0x40000
   128a2:	351c      	adds	r5, #28
   128a4:	032d      	lsls	r5, r5, #12
   128a6:	69a8      	ldr	r0, [r5, #24]
   128a8:	0702      	lsls	r2, r0, #28
   128aa:	d50e      	bpl.n	128ca <am_hal_uart_tx_flush+0x5a>
        ONE_BYTE_DELAY(pState);
   128ac:	4e08      	ldr	r6, [pc, #32]	; (128d0 <am_hal_uart_tx_flush+0x60>)
   128ae:	6e21      	ldr	r1, [r4, #96]	; 0x60
   128b0:	fbb6 f2f1 	udiv	r2, r6, r1
   128b4:	2a02      	cmp	r2, #2
   128b6:	ea4f 1002 	mov.w	r0, r2, lsl #4
   128ba:	bf8c      	ite	hi
   128bc:	3829      	subhi	r0, #41	; 0x29
   128be:	2001      	movls	r0, #1
   128c0:	f7fe fcd8 	bl	11274 <am_hal_flash_delay>
    while ( UARTn(ui32Module)->FR_b.BUSY )
   128c4:	69ab      	ldr	r3, [r5, #24]
   128c6:	071b      	lsls	r3, r3, #28
   128c8:	d4f1      	bmi.n	128ae <am_hal_uart_tx_flush+0x3e>
} // am_hal_uart_tx_flush()
   128ca:	2000      	movs	r0, #0
   128cc:	bd70      	pop	{r4, r5, r6, pc}
   128ce:	bf00      	nop
   128d0:	00b71b00 	.word	0x00b71b00

000128d4 <am_hal_queue_init>:
//
//*****************************************************************************
void
am_hal_queue_init(am_hal_queue_t *psQueue, void *pvData, uint32_t ui32ItemSize,
                  uint32_t ui32ArraySize)
{
   128d4:	b410      	push	{r4}
    psQueue->ui32WriteIndex = 0;
   128d6:	2400      	movs	r4, #0
   128d8:	6004      	str	r4, [r0, #0]
    psQueue->ui32ReadIndex = 0;
   128da:	6044      	str	r4, [r0, #4]
    psQueue->ui32Length = 0;
   128dc:	6084      	str	r4, [r0, #8]
    psQueue->ui32Capacity = ui32ArraySize;
   128de:	60c3      	str	r3, [r0, #12]
    psQueue->ui32ItemSize = ui32ItemSize;
   128e0:	6102      	str	r2, [r0, #16]
    psQueue->pui8Data = (uint8_t *) pvData;
   128e2:	6141      	str	r1, [r0, #20]
}
   128e4:	f85d 4b04 	ldr.w	r4, [sp], #4
   128e8:	4770      	bx	lr
   128ea:	bf00      	nop

000128ec <am_hal_queue_item_add>:
//! didn't have enough space.
//
//*****************************************************************************
bool
am_hal_queue_item_add(am_hal_queue_t *psQueue, const void *pvSource, uint32_t ui32NumItems)
{
   128ec:	b5f0      	push	{r4, r5, r6, r7, lr}
   128ee:	4604      	mov	r4, r0
    uint8_t *pui8Source;
    uint32_t ui32Bytes = ui32NumItems * psQueue->ui32ItemSize;
   128f0:	6905      	ldr	r5, [r0, #16]
{
   128f2:	b083      	sub	sp, #12
    uint32_t ui32Bytes = ui32NumItems * psQueue->ui32ItemSize;
   128f4:	fb05 f502 	mul.w	r5, r5, r2
{
   128f8:	460f      	mov	r7, r1
    bool bSuccess = false;

    pui8Source = (uint8_t *) pvSource;

    AM_CRITICAL_BEGIN
   128fa:	f7fe ff7b 	bl	117f4 <am_hal_interrupt_master_disable>

    //
    // Check to make sure that the buffer isn't already full
    //
    if ( am_hal_queue_space_left(psQueue) >= ui32Bytes )
   128fe:	68e3      	ldr	r3, [r4, #12]
   12900:	68a2      	ldr	r2, [r4, #8]
    AM_CRITICAL_BEGIN
   12902:	9001      	str	r0, [sp, #4]
    if ( am_hal_queue_space_left(psQueue) >= ui32Bytes )
   12904:	1a99      	subs	r1, r3, r2
   12906:	428d      	cmp	r5, r1
   12908:	f200 8081 	bhi.w	12a0e <am_hal_queue_item_add+0x122>
    {
        //
        // Loop over the bytes in the source array.
        //
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   1290c:	2d00      	cmp	r5, #0
   1290e:	d075      	beq.n	129fc <am_hal_queue_item_add+0x110>
   12910:	6826      	ldr	r6, [r4, #0]
   12912:	2f00      	cmp	r7, #0
   12914:	d07d      	beq.n	12a12 <am_hal_queue_item_add+0x126>
            // Write the value to the buffer, but only if the source pointer is
            // valid.
            //
            if (pvSource)
            {
                psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
   12916:	4638      	mov	r0, r7
   12918:	6963      	ldr	r3, [r4, #20]
   1291a:	f810 2b01 	ldrb.w	r2, [r0], #1
   1291e:	559a      	strb	r2, [r3, r6]
            }

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   12920:	6821      	ldr	r1, [r4, #0]
   12922:	f8d4 e00c 	ldr.w	lr, [r4, #12]
   12926:	1c4a      	adds	r2, r1, #1
   12928:	197e      	adds	r6, r7, r5
   1292a:	43ff      	mvns	r7, r7
   1292c:	fbb2 fcfe 	udiv	ip, r2, lr
   12930:	4437      	add	r7, r6
   12932:	fb0e 231c 	mls	r3, lr, ip, r2
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12936:	42b0      	cmp	r0, r6
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   12938:	6023      	str	r3, [r4, #0]
   1293a:	f007 0103 	and.w	r1, r7, #3
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   1293e:	d05c      	beq.n	129fa <am_hal_queue_item_add+0x10e>
   12940:	b349      	cbz	r1, 12996 <am_hal_queue_item_add+0xaa>
   12942:	2901      	cmp	r1, #1
   12944:	d019      	beq.n	1297a <am_hal_queue_item_add+0x8e>
   12946:	2902      	cmp	r1, #2
   12948:	d00b      	beq.n	12962 <am_hal_queue_item_add+0x76>
                psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
   1294a:	6962      	ldr	r2, [r4, #20]
   1294c:	f810 7b01 	ldrb.w	r7, [r0], #1
   12950:	54d7      	strb	r7, [r2, r3]
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   12952:	6823      	ldr	r3, [r4, #0]
   12954:	68e1      	ldr	r1, [r4, #12]
   12956:	1c5a      	adds	r2, r3, #1
   12958:	fbb2 f7f1 	udiv	r7, r2, r1
   1295c:	fb01 2317 	mls	r3, r1, r7, r2
   12960:	6023      	str	r3, [r4, #0]
                psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
   12962:	6962      	ldr	r2, [r4, #20]
   12964:	f810 1b01 	ldrb.w	r1, [r0], #1
   12968:	54d1      	strb	r1, [r2, r3]
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   1296a:	6823      	ldr	r3, [r4, #0]
   1296c:	68e7      	ldr	r7, [r4, #12]
   1296e:	1c5a      	adds	r2, r3, #1
   12970:	fbb2 f1f7 	udiv	r1, r2, r7
   12974:	fb07 2311 	mls	r3, r7, r1, r2
   12978:	6023      	str	r3, [r4, #0]
                psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
   1297a:	6967      	ldr	r7, [r4, #20]
   1297c:	f810 2b01 	ldrb.w	r2, [r0], #1
   12980:	54fa      	strb	r2, [r7, r3]
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   12982:	6823      	ldr	r3, [r4, #0]
   12984:	68e1      	ldr	r1, [r4, #12]
   12986:	1c5f      	adds	r7, r3, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12988:	42b0      	cmp	r0, r6
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   1298a:	fbb7 f2f1 	udiv	r2, r7, r1
   1298e:	fb01 7312 	mls	r3, r1, r2, r7
   12992:	6023      	str	r3, [r4, #0]
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12994:	d031      	beq.n	129fa <am_hal_queue_item_add+0x10e>
                psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
   12996:	4686      	mov	lr, r0
   12998:	6967      	ldr	r7, [r4, #20]
   1299a:	f81e 1b01 	ldrb.w	r1, [lr], #1
   1299e:	54f9      	strb	r1, [r7, r3]
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   129a0:	6823      	ldr	r3, [r4, #0]
   129a2:	68e2      	ldr	r2, [r4, #12]
   129a4:	1c5f      	adds	r7, r3, #1
   129a6:	fbb7 f1f2 	udiv	r1, r7, r2
   129aa:	fb02 7311 	mls	r3, r2, r1, r7
   129ae:	6023      	str	r3, [r4, #0]
                psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
   129b0:	6962      	ldr	r2, [r4, #20]
   129b2:	7847      	ldrb	r7, [r0, #1]
   129b4:	54d7      	strb	r7, [r2, r3]
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   129b6:	6823      	ldr	r3, [r4, #0]
   129b8:	68e1      	ldr	r1, [r4, #12]
   129ba:	1c5f      	adds	r7, r3, #1
   129bc:	fbb7 f2f1 	udiv	r2, r7, r1
   129c0:	fb01 7312 	mls	r3, r1, r2, r7
   129c4:	6023      	str	r3, [r4, #0]
                psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
   129c6:	6961      	ldr	r1, [r4, #20]
   129c8:	f89e 7001 	ldrb.w	r7, [lr, #1]
   129cc:	54cf      	strb	r7, [r1, r3]
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   129ce:	6822      	ldr	r2, [r4, #0]
   129d0:	68e7      	ldr	r7, [r4, #12]
                psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
   129d2:	6961      	ldr	r1, [r4, #20]
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   129d4:	3201      	adds	r2, #1
   129d6:	fbb2 fcf7 	udiv	ip, r2, r7
   129da:	fb07 231c 	mls	r3, r7, ip, r2
   129de:	6023      	str	r3, [r4, #0]
                psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
   129e0:	78c7      	ldrb	r7, [r0, #3]
   129e2:	54cf      	strb	r7, [r1, r3]
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   129e4:	6822      	ldr	r2, [r4, #0]
   129e6:	68e1      	ldr	r1, [r4, #12]
   129e8:	1c57      	adds	r7, r2, #1
   129ea:	3004      	adds	r0, #4
   129ec:	fbb7 f2f1 	udiv	r2, r7, r1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   129f0:	42b0      	cmp	r0, r6
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   129f2:	fb01 7312 	mls	r3, r1, r2, r7
   129f6:	6023      	str	r3, [r4, #0]
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   129f8:	d1cd      	bne.n	12996 <am_hal_queue_item_add+0xaa>
   129fa:	68a2      	ldr	r2, [r4, #8]
        }

        //
        // Update the length value appropriately.
        //
        psQueue->ui32Length += ui32Bytes;
   129fc:	442a      	add	r2, r5
   129fe:	60a2      	str	r2, [r4, #8]

        //
        // Report a success.
        //
        bSuccess = true;
   12a00:	2401      	movs	r4, #1
        // failure.
        //
        bSuccess = false;
    }

    AM_CRITICAL_END
   12a02:	9801      	ldr	r0, [sp, #4]
   12a04:	f7fe fefa 	bl	117fc <am_hal_interrupt_master_set>

    return bSuccess;
}
   12a08:	4620      	mov	r0, r4
   12a0a:	b003      	add	sp, #12
   12a0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        bSuccess = false;
   12a0e:	2400      	movs	r4, #0
   12a10:	e7f7      	b.n	12a02 <am_hal_queue_item_add+0x116>
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   12a12:	1c70      	adds	r0, r6, #1
   12a14:	fbb0 fef3 	udiv	lr, r0, r3
   12a18:	fb03 011e 	mls	r1, r3, lr, r0
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12a1c:	2001      	movs	r0, #1
   12a1e:	1e6e      	subs	r6, r5, #1
   12a20:	4285      	cmp	r5, r0
   12a22:	f006 0707 	and.w	r7, r6, #7
   12a26:	d063      	beq.n	12af0 <am_hal_queue_item_add+0x204>
   12a28:	b3bf      	cbz	r7, 12a9a <am_hal_queue_item_add+0x1ae>
   12a2a:	2f01      	cmp	r7, #1
   12a2c:	d02d      	beq.n	12a8a <am_hal_queue_item_add+0x19e>
   12a2e:	2f02      	cmp	r7, #2
   12a30:	d025      	beq.n	12a7e <am_hal_queue_item_add+0x192>
   12a32:	2f03      	cmp	r7, #3
   12a34:	d01d      	beq.n	12a72 <am_hal_queue_item_add+0x186>
   12a36:	2f04      	cmp	r7, #4
   12a38:	d015      	beq.n	12a66 <am_hal_queue_item_add+0x17a>
   12a3a:	2f05      	cmp	r7, #5
   12a3c:	d00d      	beq.n	12a5a <am_hal_queue_item_add+0x16e>
   12a3e:	2f06      	cmp	r7, #6
   12a40:	d005      	beq.n	12a4e <am_hal_queue_item_add+0x162>
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   12a42:	3101      	adds	r1, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12a44:	2002      	movs	r0, #2
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   12a46:	fbb1 fcf3 	udiv	ip, r1, r3
   12a4a:	fb03 111c 	mls	r1, r3, ip, r1
   12a4e:	3101      	adds	r1, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12a50:	3001      	adds	r0, #1
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   12a52:	fbb1 f6f3 	udiv	r6, r1, r3
   12a56:	fb03 1116 	mls	r1, r3, r6, r1
   12a5a:	3101      	adds	r1, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12a5c:	3001      	adds	r0, #1
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   12a5e:	fbb1 f7f3 	udiv	r7, r1, r3
   12a62:	fb03 1117 	mls	r1, r3, r7, r1
   12a66:	3101      	adds	r1, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12a68:	3001      	adds	r0, #1
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   12a6a:	fbb1 fef3 	udiv	lr, r1, r3
   12a6e:	fb03 111e 	mls	r1, r3, lr, r1
   12a72:	3101      	adds	r1, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12a74:	3001      	adds	r0, #1
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   12a76:	fbb1 fcf3 	udiv	ip, r1, r3
   12a7a:	fb03 111c 	mls	r1, r3, ip, r1
   12a7e:	3101      	adds	r1, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12a80:	3001      	adds	r0, #1
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   12a82:	fbb1 f6f3 	udiv	r6, r1, r3
   12a86:	fb03 1116 	mls	r1, r3, r6, r1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12a8a:	3001      	adds	r0, #1
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   12a8c:	3101      	adds	r1, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12a8e:	4285      	cmp	r5, r0
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   12a90:	fbb1 f7f3 	udiv	r7, r1, r3
   12a94:	fb03 1117 	mls	r1, r3, r7, r1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12a98:	d02a      	beq.n	12af0 <am_hal_queue_item_add+0x204>
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   12a9a:	3101      	adds	r1, #1
   12a9c:	fbb1 fef3 	udiv	lr, r1, r3
   12aa0:	fb03 161e 	mls	r6, r3, lr, r1
   12aa4:	1c77      	adds	r7, r6, #1
   12aa6:	fbb7 fcf3 	udiv	ip, r7, r3
   12aaa:	fb03 711c 	mls	r1, r3, ip, r7
   12aae:	1c4e      	adds	r6, r1, #1
   12ab0:	fbb6 f7f3 	udiv	r7, r6, r3
   12ab4:	fb03 6117 	mls	r1, r3, r7, r6
   12ab8:	1c4e      	adds	r6, r1, #1
   12aba:	fbb6 f7f3 	udiv	r7, r6, r3
   12abe:	fb03 6117 	mls	r1, r3, r7, r6
   12ac2:	1c4e      	adds	r6, r1, #1
   12ac4:	fbb6 f7f3 	udiv	r7, r6, r3
   12ac8:	fb03 6117 	mls	r1, r3, r7, r6
   12acc:	1c4e      	adds	r6, r1, #1
   12ace:	fbb6 f7f3 	udiv	r7, r6, r3
   12ad2:	fb03 6117 	mls	r1, r3, r7, r6
   12ad6:	1c4e      	adds	r6, r1, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12ad8:	3008      	adds	r0, #8
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   12ada:	fbb6 f7f3 	udiv	r7, r6, r3
   12ade:	fb03 6117 	mls	r1, r3, r7, r6
   12ae2:	1c4e      	adds	r6, r1, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12ae4:	4285      	cmp	r5, r0
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   12ae6:	fbb6 f7f3 	udiv	r7, r6, r3
   12aea:	fb03 6117 	mls	r1, r3, r7, r6
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12aee:	d1d4      	bne.n	12a9a <am_hal_queue_item_add+0x1ae>
   12af0:	6021      	str	r1, [r4, #0]
   12af2:	e783      	b.n	129fc <am_hal_queue_item_add+0x110>

00012af4 <am_hal_queue_item_get>:
//! queue, or false if the queue didn't have that many items to pull.
//
//*****************************************************************************
bool
am_hal_queue_item_get(am_hal_queue_t *psQueue, void *pvDest, uint32_t ui32NumItems)
{
   12af4:	b5f0      	push	{r4, r5, r6, r7, lr}
   12af6:	4604      	mov	r4, r0
    uint8_t *pui8Dest;
    uint32_t ui32Bytes = ui32NumItems * psQueue->ui32ItemSize;
   12af8:	6905      	ldr	r5, [r0, #16]
{
   12afa:	b083      	sub	sp, #12
    uint32_t ui32Bytes = ui32NumItems * psQueue->ui32ItemSize;
   12afc:	fb05 f502 	mul.w	r5, r5, r2
{
   12b00:	460e      	mov	r6, r1
    bool bSuccess = false;

    pui8Dest = (uint8_t *) pvDest;

    AM_CRITICAL_BEGIN
   12b02:	f7fe fe77 	bl	117f4 <am_hal_interrupt_master_disable>

    //
    // Check to make sure that the buffer isn't empty
    //
    if ( am_hal_queue_data_left(psQueue) >= ui32Bytes )
   12b06:	68a7      	ldr	r7, [r4, #8]
    AM_CRITICAL_BEGIN
   12b08:	9001      	str	r0, [sp, #4]
    if ( am_hal_queue_data_left(psQueue) >= ui32Bytes )
   12b0a:	42bd      	cmp	r5, r7
   12b0c:	f200 8083 	bhi.w	12c16 <am_hal_queue_item_get+0x122>
    {
        //
        // Loop over the bytes in the destination array.
        //
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12b10:	2d00      	cmp	r5, #0
   12b12:	d077      	beq.n	12c04 <am_hal_queue_item_get+0x110>
   12b14:	6863      	ldr	r3, [r4, #4]
   12b16:	2e00      	cmp	r6, #0
   12b18:	d07f      	beq.n	12c1a <am_hal_queue_item_get+0x126>
            // Grab the next value from the buffer, but only if the
            // destination pointer is valid.
            //
            if (pvDest)
            {
                pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
   12b1a:	6962      	ldr	r2, [r4, #20]
   12b1c:	4630      	mov	r0, r6
   12b1e:	5cd1      	ldrb	r1, [r2, r3]
   12b20:	f800 1b01 	strb.w	r1, [r0], #1
            }

            //
            // Advance the read index, wrapping if needed.
            //
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12b24:	6863      	ldr	r3, [r4, #4]
   12b26:	68e7      	ldr	r7, [r4, #12]
   12b28:	1c5a      	adds	r2, r3, #1
   12b2a:	1971      	adds	r1, r6, r5
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12b2c:	4281      	cmp	r1, r0
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12b2e:	fbb2 f6f7 	udiv	r6, r2, r7
   12b32:	fb07 2316 	mls	r3, r7, r6, r2
   12b36:	f105 37ff 	add.w	r7, r5, #4294967295
   12b3a:	6063      	str	r3, [r4, #4]
   12b3c:	f007 0203 	and.w	r2, r7, #3
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12b40:	d05f      	beq.n	12c02 <am_hal_queue_item_get+0x10e>
   12b42:	b362      	cbz	r2, 12b9e <am_hal_queue_item_get+0xaa>
   12b44:	2a01      	cmp	r2, #1
   12b46:	d01b      	beq.n	12b80 <am_hal_queue_item_get+0x8c>
   12b48:	2a02      	cmp	r2, #2
   12b4a:	d00c      	beq.n	12b66 <am_hal_queue_item_get+0x72>
                pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
   12b4c:	6966      	ldr	r6, [r4, #20]
   12b4e:	f816 c003 	ldrb.w	ip, [r6, r3]
   12b52:	f800 cb01 	strb.w	ip, [r0], #1
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12b56:	6863      	ldr	r3, [r4, #4]
   12b58:	68e7      	ldr	r7, [r4, #12]
   12b5a:	1c5a      	adds	r2, r3, #1
   12b5c:	fbb2 f6f7 	udiv	r6, r2, r7
   12b60:	fb07 2316 	mls	r3, r7, r6, r2
   12b64:	6063      	str	r3, [r4, #4]
                pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
   12b66:	6967      	ldr	r7, [r4, #20]
   12b68:	f817 e003 	ldrb.w	lr, [r7, r3]
   12b6c:	f800 eb01 	strb.w	lr, [r0], #1
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12b70:	6863      	ldr	r3, [r4, #4]
   12b72:	68e6      	ldr	r6, [r4, #12]
   12b74:	1c5a      	adds	r2, r3, #1
   12b76:	fbb2 f7f6 	udiv	r7, r2, r6
   12b7a:	fb06 2317 	mls	r3, r6, r7, r2
   12b7e:	6063      	str	r3, [r4, #4]
                pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
   12b80:	6966      	ldr	r6, [r4, #20]
   12b82:	f816 c003 	ldrb.w	ip, [r6, r3]
   12b86:	f800 cb01 	strb.w	ip, [r0], #1
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12b8a:	6863      	ldr	r3, [r4, #4]
   12b8c:	68e7      	ldr	r7, [r4, #12]
   12b8e:	1c5a      	adds	r2, r3, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12b90:	4281      	cmp	r1, r0
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12b92:	fbb2 f6f7 	udiv	r6, r2, r7
   12b96:	fb07 2316 	mls	r3, r7, r6, r2
   12b9a:	6063      	str	r3, [r4, #4]
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12b9c:	d031      	beq.n	12c02 <am_hal_queue_item_get+0x10e>
                pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
   12b9e:	6962      	ldr	r2, [r4, #20]
   12ba0:	4686      	mov	lr, r0
   12ba2:	5cd6      	ldrb	r6, [r2, r3]
   12ba4:	f80e 6b01 	strb.w	r6, [lr], #1
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12ba8:	6863      	ldr	r3, [r4, #4]
   12baa:	68e7      	ldr	r7, [r4, #12]
   12bac:	1c5a      	adds	r2, r3, #1
   12bae:	fbb2 f6f7 	udiv	r6, r2, r7
   12bb2:	fb07 2316 	mls	r3, r7, r6, r2
                pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
   12bb6:	6967      	ldr	r7, [r4, #20]
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12bb8:	6063      	str	r3, [r4, #4]
                pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
   12bba:	5cfa      	ldrb	r2, [r7, r3]
   12bbc:	7042      	strb	r2, [r0, #1]
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12bbe:	6863      	ldr	r3, [r4, #4]
   12bc0:	68e6      	ldr	r6, [r4, #12]
   12bc2:	1c5f      	adds	r7, r3, #1
   12bc4:	fbb7 f2f6 	udiv	r2, r7, r6
   12bc8:	fb06 7312 	mls	r3, r6, r2, r7
                pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
   12bcc:	6966      	ldr	r6, [r4, #20]
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12bce:	6063      	str	r3, [r4, #4]
                pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
   12bd0:	5cf7      	ldrb	r7, [r6, r3]
   12bd2:	f88e 7001 	strb.w	r7, [lr, #1]
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12bd6:	6862      	ldr	r2, [r4, #4]
   12bd8:	68e7      	ldr	r7, [r4, #12]
                pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
   12bda:	6966      	ldr	r6, [r4, #20]
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12bdc:	3201      	adds	r2, #1
   12bde:	fbb2 fcf7 	udiv	ip, r2, r7
   12be2:	fb07 231c 	mls	r3, r7, ip, r2
   12be6:	6063      	str	r3, [r4, #4]
                pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
   12be8:	5cf7      	ldrb	r7, [r6, r3]
   12bea:	70c7      	strb	r7, [r0, #3]
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12bec:	6866      	ldr	r6, [r4, #4]
   12bee:	68e7      	ldr	r7, [r4, #12]
   12bf0:	1c72      	adds	r2, r6, #1
   12bf2:	3004      	adds	r0, #4
   12bf4:	fbb2 f6f7 	udiv	r6, r2, r7
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12bf8:	4281      	cmp	r1, r0
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12bfa:	fb07 2316 	mls	r3, r7, r6, r2
   12bfe:	6063      	str	r3, [r4, #4]
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12c00:	d1cd      	bne.n	12b9e <am_hal_queue_item_get+0xaa>
   12c02:	68a7      	ldr	r7, [r4, #8]
        }

        //
        // Adjust the length value to reflect the change.
        //
        psQueue->ui32Length -= ui32Bytes;
   12c04:	1b7f      	subs	r7, r7, r5
   12c06:	60a7      	str	r7, [r4, #8]

        //
        // Report a success.
        //
        bSuccess = true;
   12c08:	2401      	movs	r4, #1
        // If the buffer didn't have enough data, just return false.
        //
        bSuccess = false;
    }

    AM_CRITICAL_END
   12c0a:	9801      	ldr	r0, [sp, #4]
   12c0c:	f7fe fdf6 	bl	117fc <am_hal_interrupt_master_set>

    return bSuccess;
}
   12c10:	4620      	mov	r0, r4
   12c12:	b003      	add	sp, #12
   12c14:	bdf0      	pop	{r4, r5, r6, r7, pc}
        bSuccess = false;
   12c16:	2400      	movs	r4, #0
   12c18:	e7f7      	b.n	12c0a <am_hal_queue_item_get+0x116>
   12c1a:	68e1      	ldr	r1, [r4, #12]
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12c1c:	1c58      	adds	r0, r3, #1
   12c1e:	fbb0 fef1 	udiv	lr, r0, r1
   12c22:	fb01 031e 	mls	r3, r1, lr, r0
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12c26:	2001      	movs	r0, #1
   12c28:	1e6a      	subs	r2, r5, #1
   12c2a:	4285      	cmp	r5, r0
   12c2c:	f002 0607 	and.w	r6, r2, #7
   12c30:	d063      	beq.n	12cfa <am_hal_queue_item_get+0x206>
   12c32:	b3be      	cbz	r6, 12ca4 <am_hal_queue_item_get+0x1b0>
   12c34:	2e01      	cmp	r6, #1
   12c36:	d02d      	beq.n	12c94 <am_hal_queue_item_get+0x1a0>
   12c38:	2e02      	cmp	r6, #2
   12c3a:	d025      	beq.n	12c88 <am_hal_queue_item_get+0x194>
   12c3c:	2e03      	cmp	r6, #3
   12c3e:	d01d      	beq.n	12c7c <am_hal_queue_item_get+0x188>
   12c40:	2e04      	cmp	r6, #4
   12c42:	d015      	beq.n	12c70 <am_hal_queue_item_get+0x17c>
   12c44:	2e05      	cmp	r6, #5
   12c46:	d00d      	beq.n	12c64 <am_hal_queue_item_get+0x170>
   12c48:	2e06      	cmp	r6, #6
   12c4a:	d005      	beq.n	12c58 <am_hal_queue_item_get+0x164>
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12c4c:	3301      	adds	r3, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12c4e:	2002      	movs	r0, #2
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12c50:	fbb3 f2f1 	udiv	r2, r3, r1
   12c54:	fb01 3312 	mls	r3, r1, r2, r3
   12c58:	3301      	adds	r3, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12c5a:	3001      	adds	r0, #1
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12c5c:	fbb3 fcf1 	udiv	ip, r3, r1
   12c60:	fb01 331c 	mls	r3, r1, ip, r3
   12c64:	3301      	adds	r3, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12c66:	3001      	adds	r0, #1
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12c68:	fbb3 fef1 	udiv	lr, r3, r1
   12c6c:	fb01 331e 	mls	r3, r1, lr, r3
   12c70:	3301      	adds	r3, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12c72:	3001      	adds	r0, #1
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12c74:	fbb3 f6f1 	udiv	r6, r3, r1
   12c78:	fb01 3316 	mls	r3, r1, r6, r3
   12c7c:	3301      	adds	r3, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12c7e:	3001      	adds	r0, #1
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12c80:	fbb3 f2f1 	udiv	r2, r3, r1
   12c84:	fb01 3312 	mls	r3, r1, r2, r3
   12c88:	3301      	adds	r3, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12c8a:	3001      	adds	r0, #1
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12c8c:	fbb3 fcf1 	udiv	ip, r3, r1
   12c90:	fb01 331c 	mls	r3, r1, ip, r3
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12c94:	3001      	adds	r0, #1
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12c96:	3301      	adds	r3, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12c98:	4285      	cmp	r5, r0
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12c9a:	fbb3 fef1 	udiv	lr, r3, r1
   12c9e:	fb01 331e 	mls	r3, r1, lr, r3
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12ca2:	d02a      	beq.n	12cfa <am_hal_queue_item_get+0x206>
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12ca4:	3301      	adds	r3, #1
   12ca6:	fbb3 f6f1 	udiv	r6, r3, r1
   12caa:	fb01 3216 	mls	r2, r1, r6, r3
   12cae:	1c56      	adds	r6, r2, #1
   12cb0:	fbb6 fcf1 	udiv	ip, r6, r1
   12cb4:	fb01 631c 	mls	r3, r1, ip, r6
   12cb8:	1c5a      	adds	r2, r3, #1
   12cba:	fbb2 f6f1 	udiv	r6, r2, r1
   12cbe:	fb01 2316 	mls	r3, r1, r6, r2
   12cc2:	1c5a      	adds	r2, r3, #1
   12cc4:	fbb2 f6f1 	udiv	r6, r2, r1
   12cc8:	fb01 2316 	mls	r3, r1, r6, r2
   12ccc:	1c5a      	adds	r2, r3, #1
   12cce:	fbb2 f6f1 	udiv	r6, r2, r1
   12cd2:	fb01 2316 	mls	r3, r1, r6, r2
   12cd6:	1c5a      	adds	r2, r3, #1
   12cd8:	fbb2 f6f1 	udiv	r6, r2, r1
   12cdc:	fb01 2316 	mls	r3, r1, r6, r2
   12ce0:	1c5a      	adds	r2, r3, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12ce2:	3008      	adds	r0, #8
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12ce4:	fbb2 f6f1 	udiv	r6, r2, r1
   12ce8:	fb01 2316 	mls	r3, r1, r6, r2
   12cec:	1c5a      	adds	r2, r3, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12cee:	4285      	cmp	r5, r0
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12cf0:	fbb2 f6f1 	udiv	r6, r2, r1
   12cf4:	fb01 2316 	mls	r3, r1, r6, r2
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12cf8:	d1d4      	bne.n	12ca4 <am_hal_queue_item_get+0x1b0>
   12cfa:	6063      	str	r3, [r4, #4]
   12cfc:	e782      	b.n	12c04 <am_hal_queue_item_get+0x110>
   12cfe:	bf00      	nop

00012d00 <memset>:
   12d00:	4402      	add	r2, r0
   12d02:	4603      	mov	r3, r0
   12d04:	4293      	cmp	r3, r2
   12d06:	d100      	bne.n	12d0a <memset+0xa>
   12d08:	4770      	bx	lr
   12d0a:	f803 1b01 	strb.w	r1, [r3], #1
   12d0e:	e7f9      	b.n	12d04 <memset+0x4>
   12d10:	00000104 	.word	0x00000104
   12d14:	70206b36 	.word	0x70206b36
   12d18:	6f667265 	.word	0x6f667265
   12d1c:	6e616d72 	.word	0x6e616d72
   12d20:	72206563 	.word	0x72206563
   12d24:	70206e75 	.word	0x70206e75
   12d28:	6d617261 	.word	0x6d617261
   12d2c:	72657465 	.word	0x72657465
   12d30:	6f662073 	.word	0x6f662073
   12d34:	6f632072 	.word	0x6f632072
   12d38:	616d6572 	.word	0x616d6572
   12d3c:	0a2e6b72 	.word	0x0a2e6b72
   12d40:	00000000 	.word	0x00000000
   12d44:	76206b36 	.word	0x76206b36
   12d48:	64696c61 	.word	0x64696c61
   12d4c:	6f697461 	.word	0x6f697461
   12d50:	7572206e 	.word	0x7572206e
   12d54:	6170206e 	.word	0x6170206e
   12d58:	656d6172 	.word	0x656d6172
   12d5c:	73726574 	.word	0x73726574
   12d60:	726f6620 	.word	0x726f6620
   12d64:	726f6320 	.word	0x726f6320
   12d68:	72616d65 	.word	0x72616d65
   12d6c:	000a2e6b 	.word	0x000a2e6b
   12d70:	666f7250 	.word	0x666f7250
   12d74:	20656c69 	.word	0x20656c69
   12d78:	656e6567 	.word	0x656e6567
   12d7c:	69746172 	.word	0x69746172
   12d80:	72206e6f 	.word	0x72206e6f
   12d84:	70206e75 	.word	0x70206e75
   12d88:	6d617261 	.word	0x6d617261
   12d8c:	72657465 	.word	0x72657465
   12d90:	6f662073 	.word	0x6f662073
   12d94:	6f632072 	.word	0x6f632072
   12d98:	616d6572 	.word	0x616d6572
   12d9c:	0a2e6b72 	.word	0x0a2e6b72
   12da0:	00000000 	.word	0x00000000
   12da4:	70204b32 	.word	0x70204b32
   12da8:	6f667265 	.word	0x6f667265
   12dac:	6e616d72 	.word	0x6e616d72
   12db0:	72206563 	.word	0x72206563
   12db4:	70206e75 	.word	0x70206e75
   12db8:	6d617261 	.word	0x6d617261
   12dbc:	72657465 	.word	0x72657465
   12dc0:	6f662073 	.word	0x6f662073
   12dc4:	6f632072 	.word	0x6f632072
   12dc8:	616d6572 	.word	0x616d6572
   12dcc:	0a2e6b72 	.word	0x0a2e6b72
   12dd0:	00000000 	.word	0x00000000
   12dd4:	76204b32 	.word	0x76204b32
   12dd8:	64696c61 	.word	0x64696c61
   12ddc:	6f697461 	.word	0x6f697461
   12de0:	7572206e 	.word	0x7572206e
   12de4:	6170206e 	.word	0x6170206e
   12de8:	656d6172 	.word	0x656d6172
   12dec:	73726574 	.word	0x73726574
   12df0:	726f6620 	.word	0x726f6620
   12df4:	726f6320 	.word	0x726f6320
   12df8:	72616d65 	.word	0x72616d65
   12dfc:	000a2e6b 	.word	0x000a2e6b
   12e00:	5d75255b 	.word	0x5d75255b
   12e04:	4f525245 	.word	0x4f525245
   12e08:	6c202152 	.word	0x6c202152
   12e0c:	20747369 	.word	0x20747369
   12e10:	20637263 	.word	0x20637263
   12e14:	30257830 	.word	0x30257830
   12e18:	2d207834 	.word	0x2d207834
   12e1c:	6f687320 	.word	0x6f687320
   12e20:	20646c75 	.word	0x20646c75
   12e24:	30206562 	.word	0x30206562
   12e28:	34302578 	.word	0x34302578
   12e2c:	00000a78 	.word	0x00000a78
   12e30:	5d75255b 	.word	0x5d75255b
   12e34:	4f525245 	.word	0x4f525245
   12e38:	6d202152 	.word	0x6d202152
   12e3c:	69727461 	.word	0x69727461
   12e40:	72632078 	.word	0x72632078
   12e44:	78302063 	.word	0x78302063
   12e48:	78343025 	.word	0x78343025
   12e4c:	73202d20 	.word	0x73202d20
   12e50:	6c756f68 	.word	0x6c756f68
   12e54:	65622064 	.word	0x65622064
   12e58:	25783020 	.word	0x25783020
   12e5c:	0a783430 	.word	0x0a783430
   12e60:	00000000 	.word	0x00000000
   12e64:	5d75255b 	.word	0x5d75255b
   12e68:	4f525245 	.word	0x4f525245
   12e6c:	73202152 	.word	0x73202152
   12e70:	65746174 	.word	0x65746174
   12e74:	63726320 	.word	0x63726320
   12e78:	25783020 	.word	0x25783020
   12e7c:	20783430 	.word	0x20783430
   12e80:	6873202d 	.word	0x6873202d
   12e84:	646c756f 	.word	0x646c756f
   12e88:	20656220 	.word	0x20656220
   12e8c:	30257830 	.word	0x30257830
   12e90:	000a7834 	.word	0x000a7834
   12e94:	65726f43 	.word	0x65726f43
   12e98:	6b72614d 	.word	0x6b72614d
   12e9c:	7a695320 	.word	0x7a695320
   12ea0:	20202065 	.word	0x20202065
   12ea4:	25203a20 	.word	0x25203a20
   12ea8:	000a756c 	.word	0x000a756c
   12eac:	61746f54 	.word	0x61746f54
   12eb0:	6974206c 	.word	0x6974206c
   12eb4:	20736b63 	.word	0x20736b63
   12eb8:	20202020 	.word	0x20202020
   12ebc:	25203a20 	.word	0x25203a20
   12ec0:	0a756c6c 	.word	0x0a756c6c
   12ec4:	00000000 	.word	0x00000000
   12ec8:	61746f54 	.word	0x61746f54
   12ecc:	6974206c 	.word	0x6974206c
   12ed0:	2820656d 	.word	0x2820656d
   12ed4:	73636573 	.word	0x73636573
   12ed8:	25203a29 	.word	0x25203a29
   12edc:	00000a66 	.word	0x00000a66
   12ee0:	72657449 	.word	0x72657449
   12ee4:	6f697461 	.word	0x6f697461
   12ee8:	532f736e 	.word	0x532f736e
   12eec:	20206365 	.word	0x20206365
   12ef0:	25203a20 	.word	0x25203a20
   12ef4:	00000a66 	.word	0x00000a66
   12ef8:	4f525245 	.word	0x4f525245
   12efc:	4d202152 	.word	0x4d202152
   12f00:	20747375 	.word	0x20747375
   12f04:	63657865 	.word	0x63657865
   12f08:	20657475 	.word	0x20657475
   12f0c:	20726f66 	.word	0x20726f66
   12f10:	6c207461 	.word	0x6c207461
   12f14:	74736165 	.word	0x74736165
   12f18:	20303120 	.word	0x20303120
   12f1c:	73636573 	.word	0x73636573
   12f20:	726f6620 	.word	0x726f6620
   12f24:	76206120 	.word	0x76206120
   12f28:	64696c61 	.word	0x64696c61
   12f2c:	73657220 	.word	0x73657220
   12f30:	21746c75 	.word	0x21746c75
   12f34:	0000000a 	.word	0x0000000a
   12f38:	72657449 	.word	0x72657449
   12f3c:	6f697461 	.word	0x6f697461
   12f40:	2020736e 	.word	0x2020736e
   12f44:	20202020 	.word	0x20202020
   12f48:	25203a20 	.word	0x25203a20
   12f4c:	000a756c 	.word	0x000a756c
   12f50:	20434347 	.word	0x20434347
   12f54:	2e332e36 	.word	0x2e332e36
   12f58:	30322031 	.word	0x30322031
   12f5c:	32303731 	.word	0x32303731
   12f60:	28203531 	.word	0x28203531
   12f64:	656c6572 	.word	0x656c6572
   12f68:	29657361 	.word	0x29657361
   12f6c:	52415b20 	.word	0x52415b20
   12f70:	6d652f4d 	.word	0x6d652f4d
   12f74:	64646562 	.word	0x64646562
   12f78:	362d6465 	.word	0x362d6465
   12f7c:	6172622d 	.word	0x6172622d
   12f80:	2068636e 	.word	0x2068636e
   12f84:	69766572 	.word	0x69766572
   12f88:	6e6f6973 	.word	0x6e6f6973
   12f8c:	35343220 	.word	0x35343220
   12f90:	5d323135 	.word	0x5d323135
   12f94:	00000000 	.word	0x00000000
   12f98:	706d6f43 	.word	0x706d6f43
   12f9c:	72656c69 	.word	0x72656c69
   12fa0:	72657620 	.word	0x72657620
   12fa4:	6e6f6973 	.word	0x6e6f6973
   12fa8:	25203a20 	.word	0x25203a20
   12fac:	00000a73 	.word	0x00000a73
   12fb0:	43415453 	.word	0x43415453
   12fb4:	0000004b 	.word	0x0000004b
   12fb8:	6f6d654d 	.word	0x6f6d654d
   12fbc:	6c207972 	.word	0x6c207972
   12fc0:	7461636f 	.word	0x7461636f
   12fc4:	206e6f69 	.word	0x206e6f69
   12fc8:	25203a20 	.word	0x25203a20
   12fcc:	00000a73 	.word	0x00000a73
   12fd0:	64656573 	.word	0x64656573
   12fd4:	20637263 	.word	0x20637263
   12fd8:	20202020 	.word	0x20202020
   12fdc:	20202020 	.word	0x20202020
   12fe0:	30203a20 	.word	0x30203a20
   12fe4:	34302578 	.word	0x34302578
   12fe8:	00000a78 	.word	0x00000a78
   12fec:	5d64255b 	.word	0x5d64255b
   12ff0:	6c637263 	.word	0x6c637263
   12ff4:	20747369 	.word	0x20747369
   12ff8:	20202020 	.word	0x20202020
   12ffc:	203a2020 	.word	0x203a2020
   13000:	30257830 	.word	0x30257830
   13004:	000a7834 	.word	0x000a7834
   13008:	5d64255b 	.word	0x5d64255b
   1300c:	6d637263 	.word	0x6d637263
   13010:	69727461 	.word	0x69727461
   13014:	20202078 	.word	0x20202078
   13018:	203a2020 	.word	0x203a2020
   1301c:	30257830 	.word	0x30257830
   13020:	000a7834 	.word	0x000a7834
   13024:	5d64255b 	.word	0x5d64255b
   13028:	73637263 	.word	0x73637263
   1302c:	65746174 	.word	0x65746174
   13030:	20202020 	.word	0x20202020
   13034:	203a2020 	.word	0x203a2020
   13038:	30257830 	.word	0x30257830
   1303c:	000a7834 	.word	0x000a7834
   13040:	5d64255b 	.word	0x5d64255b
   13044:	66637263 	.word	0x66637263
   13048:	6c616e69 	.word	0x6c616e69
   1304c:	20202020 	.word	0x20202020
   13050:	203a2020 	.word	0x203a2020
   13054:	30257830 	.word	0x30257830
   13058:	000a7834 	.word	0x000a7834
   1305c:	72726f43 	.word	0x72726f43
   13060:	20746365 	.word	0x20746365
   13064:	7265706f 	.word	0x7265706f
   13068:	6f697461 	.word	0x6f697461
   1306c:	6176206e 	.word	0x6176206e
   13070:	6164696c 	.word	0x6164696c
   13074:	2e646574 	.word	0x2e646574
   13078:	65655320 	.word	0x65655320
   1307c:	61657220 	.word	0x61657220
   13080:	2e656d64 	.word	0x2e656d64
   13084:	20747874 	.word	0x20747874
   13088:	20726f66 	.word	0x20726f66
   1308c:	206e7572 	.word	0x206e7572
   13090:	20646e61 	.word	0x20646e61
   13094:	6f706572 	.word	0x6f706572
   13098:	6e697472 	.word	0x6e697472
   1309c:	75722067 	.word	0x75722067
   130a0:	2e73656c 	.word	0x2e73656c
   130a4:	0000000a 	.word	0x0000000a
   130a8:	65726f43 	.word	0x65726f43
   130ac:	6b72614d 	.word	0x6b72614d
   130b0:	302e3120 	.word	0x302e3120
   130b4:	25203a20 	.word	0x25203a20
   130b8:	202f2066 	.word	0x202f2066
   130bc:	25207325 	.word	0x25207325
   130c0:	00000073 	.word	0x00000073
   130c4:	67616c66 	.word	0x67616c66
   130c8:	2d203a73 	.word	0x2d203a73
   130cc:	0000336f 	.word	0x0000336f
   130d0:	25202f20 	.word	0x25202f20
   130d4:	00000073 	.word	0x00000073
   130d8:	6f727245 	.word	0x6f727245
   130dc:	64207372 	.word	0x64207372
   130e0:	63657465 	.word	0x63657465
   130e4:	0a646574 	.word	0x0a646574
   130e8:	00000000 	.word	0x00000000
   130ec:	6e6e6143 	.word	0x6e6e6143
   130f0:	7620746f 	.word	0x7620746f
   130f4:	64696c61 	.word	0x64696c61
   130f8:	20657461 	.word	0x20657461
   130fc:	7265706f 	.word	0x7265706f
   13100:	6f697461 	.word	0x6f697461
   13104:	6f66206e 	.word	0x6f66206e
   13108:	68742072 	.word	0x68742072
   1310c:	20657365 	.word	0x20657365
   13110:	64656573 	.word	0x64656573
   13114:	6c617620 	.word	0x6c617620
   13118:	2c736575 	.word	0x2c736575
   1311c:	656c7020 	.word	0x656c7020
   13120:	20657361 	.word	0x20657361
   13124:	706d6f63 	.word	0x706d6f63
   13128:	20657261 	.word	0x20657261
   1312c:	68746977 	.word	0x68746977
   13130:	73657220 	.word	0x73657220
   13134:	73746c75 	.word	0x73746c75
   13138:	206e6f20 	.word	0x206e6f20
   1313c:	6e6b2061 	.word	0x6e6b2061
   13140:	206e776f 	.word	0x206e776f
   13144:	74616c70 	.word	0x74616c70
   13148:	6d726f66 	.word	0x6d726f66
   1314c:	00000a2e 	.word	0x00000a2e
   13150:	4d2f4d43 	.word	0x4d2f4d43
   13154:	253d7a48 	.word	0x253d7a48
   13158:	2e66332e 	.word	0x2e66332e
   1315c:	0000000a 	.word	0x0000000a
   13160:	46465542 	.word	0x46465542
   13164:	4f205245 	.word	0x4f205245
   13168:	46524556 	.word	0x46524556
   1316c:	45574f4c 	.word	0x45574f4c
   13170:	49202144 	.word	0x49202144
   13174:	6572636e 	.word	0x6572636e
   13178:	20657361 	.word	0x20657361
   1317c:	42545250 	.word	0x42545250
   13180:	49534655 	.word	0x49534655
   13184:	000a455a 	.word	0x000a455a
   13188:	626d410a 	.word	0x626d410a
   1318c:	4d207169 	.word	0x4d207169
   13190:	6f726369 	.word	0x6f726369
   13194:	726f4320 	.word	0x726f4320
   13198:	72616d65 	.word	0x72616d65
   1319c:	7572206b 	.word	0x7572206b
   131a0:	6966206e 	.word	0x6966206e
   131a4:	6873696e 	.word	0x6873696e
   131a8:	0a216465 	.word	0x0a216465
   131ac:	0000000a 	.word	0x0000000a

000131b0 <errpat>:
   131b0:	000131f0 000131fc 00013208 00013214     .1...1...2...2..

000131c0 <floatpat>:
   131c0:	00013250 0001325c 00013268 00013274     P2..\2..h2..t2..

000131d0 <intpat>:
   131d0:	00013280 00013288 00013290 00013298     .2...2...2...2..

000131e0 <scipat>:
   131e0:	00013220 0001322c 00013238 00013244      2..,2..82..D2..
   131f0:	332e3054 46312d65 00000000 542e542d     T0.3e-1F....-T.T
   13200:	71542b2b 00000000 2e335431 7a346534     ++Tq....1T3.4e4z
   13210:	00000000 302e3433 5e542d65 00000000     ....34.0e-T^....
   13220:	30352e35 332b6530 00000000 32312e2d     5.500e+3....-.12
   13230:	322d6533 00000000 6537382d 3233382b     3e-2....-87e+832
   13240:	00000000 362e302b 32312d65 00000000     ....+0.6e-12....
   13250:	352e3533 30303434 00000000 3332312e     35.54400.....123
   13260:	30303534 00000000 3031312d 3030372e     4500....-110.700
   13270:	00000000 362e302b 30303434 00000000     ....+0.64400....
   13280:	32313035 00000000 34333231 00000000     5012....1234....
   13290:	3437382d 00000000 3232312b 00000000     -874....+122....
   132a0:	0a0a0a0a 0a0a0a0a 0a0a0a0a 0a0a0a0a     ................
   132b0:	00000a0a                                ....

000132b4 <g_sBspUartConfig>:
   132b4:	0001c200 00000060 00000000 00000000     ....`...........
   132c4:	00000000 00000012 00000000 00000000     ................
	...

000132dc <g_AM_BSP_GPIO_COM_UART_RX>:
   132dc:	00000000                                ....

000132e0 <g_AM_BSP_GPIO_COM_UART_TX>:
   132e0:	00000000                                ....

000132e4 <am_hal_cachectrl_defaults>:
   132e4:	00000308                                ....

000132e8 <g_AM_HAL_GPIO_DISABLE>:
   132e8:	00000003                                ....

000132ec <g_AM_HAL_GPIO_OUTPUT>:
   132ec:	00000403                                ....

000132f0 <g_AM_HAL_GPIO_TRISTATE>:
   132f0:	00000c03                                ....

000132f4 <g_ui8Bit76Capabilities>:
   132f4:	02800101 80010180 80800101 80808080     ................
   13304:	80808080 80808008 01800180 80808080     ................
   13314:	80808080 01800402 01010401 80808080     ................
   13324:	00000101                                ....

00013328 <g_ui8Inpen>:
   13328:	e2242323 100723a1 e1004303 3561a151     ##$..#...C..Q.a5
   13338:	4181c525 d160b001 31a13130 1100f101     %..A..`.01.1....
   13348:	01d121b1 300511e5 31301037 40006100     .!.....07.01.a.@
   13358:	00003130                                01..

0001335c <g_ui8NCEtable>:
   1335c:	13524232 60221202 21534333 20504030     2BR..."`3CS!0@P 
   1336c:	11514131 ffffffff ffffffff 60514131     1AQ.........1AQ`
   1337c:	00504030 23534333 60524232 30201000     0@P.3CS#2BR`.. 0
   1338c:	61504030 01514131 42221202 60231303     0@Pa1AQ..."B..#`
   1339c:	50201000 41211101 32221202 60331303     .. P..!A.."2..3`
   133ac:	21514131 22524232 03534333 40201000     1AQ!2BR"3CS... @
   133bc:	51211101 02524232 13534333 10504030     ..!Q2BR.3CS.0@P.
   133cc:	60514131 12524232 03534333 40201000     1AQ`2BR.3CS... @
   133dc:	61211101 52221202 33231303 30201000     ..!a.."R..#3.. 0
   133ec:	61514131 02524232 53331303 ffffffff     1AQa2BR...3S....
   133fc:	ffffffff 61211101 50201000 61211101     ......!a.. P..!a
   1340c:	52221202 13534333 61504030 31211101     .."R3CS.0@Pa..!1
   1341c:	32221202 43231303                       .."2..#C

00013424 <g_ui8nCEpins>:
   13424:	02070707 00080802 01020202 01010101     ................
   13434:	01010101 01010101 01010101 01010101     ................
   13444:	01010101 08010101 01010008 01010101     ................
   13454:	00000101                                ....

00013458 <g_am_hal_mcuctrl_flash_size>:
   13458:	00004000 00008000 00010000 00020000     .@..............
   13468:	00040000 00080000 00100000 00200000     .............. .
	...

00013498 <g_am_hal_mcuctrl_sram_size>:
   13498:	00004000 00008000 00010000 00020000     .@..............
   134a8:	00040000 00080000 00100000 00060000     ................
	...

000134d8 <am_hal_pwrctrl_memory_control>:
	...
   134ec:	00000001 00000001 00000001 00001fff     ................
   134fc:	00001fff 00000003 00000003 00000003     ................
   1350c:	00001fff 00001fff 00000007 00000007     ................
   1351c:	00000007 00001fff 00001fff 0000000f     ................
   1352c:	0000000f 0000000f 00001fff 00001fff     ................
   1353c:	0000001f 0000001f 0000001f 00001fff     ................
   1354c:	00001fff 0000003f 0000003f 0000003f     ....?...?...?...
   1355c:	00001fff 00001fff 0000007f 0000007f     ................
   1356c:	0000007f 00001fff 00001fff 000000ff     ................
   1357c:	000000ff 000000ff 00001fff 00001fff     ................
   1358c:	000001ff 000001ff 000001ff 00001fff     ................
   1359c:	00001fff 000003ff 000003ff 000003ff     ................
   135ac:	00001fff 00001fff 000007ff 000007ff     ................
   135bc:	000007ff 00001fff 00001fff 00000fff     ................
   135cc:	00000fff 00000fff 00001fff 00001fff     ................
   135dc:	00001fff 00001fff 00001fff 00001fff     ................
   135ec:	00001fff 00002000 00002000 00002000     ..... ... ... ..
   135fc:	00006000 00006000 00006000 00006000     .`...`...`...`..
   1360c:	00006000 00006000 00006000 c0000000     .`...`...`......
   1361c:	00018000 c0000000 c0000000 00018000     ................
   1362c:	c0007fff 0001ffff c0007fff c0007fff     ................
   1363c:	0001ffff                                ....

00013640 <am_hal_pwrctrl_peripheral_control>:
	...
   1364c:	00000001 00000004 00000004 00000002     ................
   1365c:	00000008 00000008 00000004 00000008     ................
   1366c:	00000008 00000008 00000008 00000008     ................
   1367c:	00000010 00000010 00000010 00000020     ............ ...
   1368c:	00000010 00000010 00000040 00000010     ........@.......
   1369c:	00000010 00000080 00000004 00000004     ................
   136ac:	00000100 00000004 00000004 00000200     ................
   136bc:	00000020 00000020 00000400 00000004      ... ...........
   136cc:	00000004 00000800 00000040 00000040     ........@...@...
   136dc:	00001000 00000080 00000080 00002000     ............. ..
   136ec:	00000100 00000100                       ........
