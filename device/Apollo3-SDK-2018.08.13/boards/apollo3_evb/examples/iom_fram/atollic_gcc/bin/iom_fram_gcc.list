
iom_fram_gcc.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004f74  0000c000  0000c000  0000c000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .stack        00001000  10000000  10000000  00020000  2**2
                  ALLOC
  2 .data         000000bc  10001000  00010f74  00011000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00003a90  100010bc  00011030  000110bc  2**2
                  ALLOC
  4 .ARM.attributes 00000037  00000000  00000000  000110bc  2**0
                  CONTENTS, READONLY
  5 .debug_info   0002f21e  00000000  00000000  000110f3  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00003c86  00000000  00000000  00040311  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000978  00000000  00000000  00043f97  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_ranges 000018e8  00000000  00000000  0004490f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00007930  00000000  00000000  000461f7  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000d8f4  00000000  00000000  0004db27  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000007c  00000000  00000000  0005b41b  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00001dcc  00000000  00000000  0005b498  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    0000b3f1  00000000  00000000  0005d264  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0000c000 <g_am_pfnVectors>:
    c000:	00 10 00 10 b1 d1 00 00 19 d2 00 00 25 d2 00 00     ............%...
    c010:	25 d2 00 00 25 d2 00 00 25 d2 00 00 00 00 00 00     %...%...%.......
	...
    c02c:	1f d2 00 00 1f d2 00 00 00 00 00 00 1f d2 00 00     ................
    c03c:	1f d2 00 00 1f d2 00 00 1f d2 00 00 1f d2 00 00     ................
    c04c:	1f d2 00 00 1f d2 00 00 1f d2 00 00 a1 cd 00 00     ................
    c05c:	1f d2 00 00 1f d2 00 00 1f d2 00 00 1f d2 00 00     ................
    c06c:	1f d2 00 00 1f d2 00 00 1f d2 00 00 79 cd 00 00     ............y...
    c07c:	1f d2 00 00 1f d2 00 00 1f d2 00 00 1f d2 00 00     ................
    c08c:	1f d2 00 00 1f d2 00 00 1f d2 00 00 1f d2 00 00     ................
    c09c:	1f d2 00 00 1f d2 00 00 1f d2 00 00 1f d2 00 00     ................
    c0ac:	1f d2 00 00 1f d2 00 00 1f d2 00 00 1f d2 00 00     ................
    c0bc:	1f d2 00 00 1f d2 00 00 1f d2 00 00 1f d2 00 00     ................
    c0cc:	1f d2 00 00                                         ....

0000c0d0 <__Patchable>:
	...

0000c100 <__aeabi_d2f>:
    c100:	ea4f 0241 	mov.w	r2, r1, lsl #1
    c104:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
    c108:	bf24      	itt	cs
    c10a:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
    c10e:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
    c112:	d90d      	bls.n	c130 <__aeabi_d2f+0x30>
    c114:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    c118:	ea4f 02c0 	mov.w	r2, r0, lsl #3
    c11c:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
    c120:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
    c124:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
    c128:	bf08      	it	eq
    c12a:	f020 0001 	biceq.w	r0, r0, #1
    c12e:	4770      	bx	lr
    c130:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
    c134:	d121      	bne.n	c17a <__aeabi_d2f+0x7a>
    c136:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
    c13a:	bfbc      	itt	lt
    c13c:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
    c140:	4770      	bxlt	lr
    c142:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    c146:	ea4f 5252 	mov.w	r2, r2, lsr #21
    c14a:	f1c2 0218 	rsb	r2, r2, #24
    c14e:	f1c2 0c20 	rsb	ip, r2, #32
    c152:	fa10 f30c 	lsls.w	r3, r0, ip
    c156:	fa20 f002 	lsr.w	r0, r0, r2
    c15a:	bf18      	it	ne
    c15c:	f040 0001 	orrne.w	r0, r0, #1
    c160:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    c164:	ea4f 23d3 	mov.w	r3, r3, lsr #11
    c168:	fa03 fc0c 	lsl.w	ip, r3, ip
    c16c:	ea40 000c 	orr.w	r0, r0, ip
    c170:	fa23 f302 	lsr.w	r3, r3, r2
    c174:	ea4f 0343 	mov.w	r3, r3, lsl #1
    c178:	e7cc      	b.n	c114 <__aeabi_d2f+0x14>
    c17a:	ea7f 5362 	mvns.w	r3, r2, asr #21
    c17e:	d107      	bne.n	c190 <__aeabi_d2f+0x90>
    c180:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
    c184:	bf1e      	ittt	ne
    c186:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
    c18a:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
    c18e:	4770      	bxne	lr
    c190:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
    c194:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    c198:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    c19c:	4770      	bx	lr
    c19e:	bf00      	nop

0000c1a0 <fireball_init>:
//*****************************************************************************
// fireball_init()
//*****************************************************************************
static uint32_t
fireball_init(uint32_t ui32Board, uint32_t ui32Module)
{
    c1a0:	b580      	push	{r7, lr}
    c1a2:	b082      	sub	sp, #8
    c1a4:	af00      	add	r7, sp, #0
    c1a6:	6078      	str	r0, [r7, #4]
    c1a8:	6039      	str	r1, [r7, #0]
    if ( ui32Board != 1 )
    c1aa:	687b      	ldr	r3, [r7, #4]
    c1ac:	2b01      	cmp	r3, #1
    c1ae:	d001      	beq.n	c1b4 <fireball_init+0x14>
    {
        return 1;
    c1b0:	2301      	movs	r3, #1
    c1b2:	e07a      	b.n	c2aa <fireball_init+0x10a>
    }

    if ( g_pIOM5Handle )
    c1b4:	4b3f      	ldr	r3, [pc, #252]	; (c2b4 <fireball_init+0x114>)
    c1b6:	681b      	ldr	r3, [r3, #0]
    c1b8:	2b00      	cmp	r3, #0
    c1ba:	d001      	beq.n	c1c0 <fireball_init+0x20>
    {
        //
        // Already initialized
        //
        return 0;
    c1bc:	2300      	movs	r3, #0
    c1be:	e074      	b.n	c2aa <fireball_init+0x10a>
    //

    //
    // Set up IOM5 to talk to Fireball.
    //
    if ( am_hal_iom_initialize(ui32Module, &g_pIOM5Handle)                  ||
    c1c0:	493c      	ldr	r1, [pc, #240]	; (c2b4 <fireball_init+0x114>)
    c1c2:	6838      	ldr	r0, [r7, #0]
    c1c4:	f002 ff9e 	bl	f104 <am_hal_iom_initialize>
    c1c8:	4603      	mov	r3, r0
    c1ca:	2b00      	cmp	r3, #0
    c1cc:	d11a      	bne.n	c204 <fireball_init+0x64>
         am_hal_iom_power_ctrl(g_pIOM5Handle, AM_HAL_SYSCTRL_WAKE, false)   ||
    c1ce:	4b39      	ldr	r3, [pc, #228]	; (c2b4 <fireball_init+0x114>)
    c1d0:	681b      	ldr	r3, [r3, #0]
    c1d2:	2200      	movs	r2, #0
    c1d4:	2100      	movs	r1, #0
    c1d6:	4618      	mov	r0, r3
    c1d8:	f003 f96e 	bl	f4b8 <am_hal_iom_power_ctrl>
    c1dc:	4603      	mov	r3, r0
    if ( am_hal_iom_initialize(ui32Module, &g_pIOM5Handle)                  ||
    c1de:	2b00      	cmp	r3, #0
    c1e0:	d110      	bne.n	c204 <fireball_init+0x64>
         am_hal_iom_configure(g_pIOM5Handle,
    c1e2:	4b34      	ldr	r3, [pc, #208]	; (c2b4 <fireball_init+0x114>)
    c1e4:	681b      	ldr	r3, [r3, #0]
    c1e6:	4934      	ldr	r1, [pc, #208]	; (c2b8 <fireball_init+0x118>)
    c1e8:	4618      	mov	r0, r3
    c1ea:	f003 fa1b 	bl	f624 <am_hal_iom_configure>
    c1ee:	4603      	mov	r3, r0
         am_hal_iom_power_ctrl(g_pIOM5Handle, AM_HAL_SYSCTRL_WAKE, false)   ||
    c1f0:	2b00      	cmp	r3, #0
    c1f2:	d107      	bne.n	c204 <fireball_init+0x64>
                              (am_hal_iom_config_t*)&g_FireballIOM5Config)  ||
         am_hal_iom_enable(g_pIOM5Handle))
    c1f4:	4b2f      	ldr	r3, [pc, #188]	; (c2b4 <fireball_init+0x114>)
    c1f6:	681b      	ldr	r3, [r3, #0]
    c1f8:	4618      	mov	r0, r3
    c1fa:	f002 ffab 	bl	f154 <am_hal_iom_enable>
    c1fe:	4603      	mov	r3, r0
                              (am_hal_iom_config_t*)&g_FireballIOM5Config)  ||
    c200:	2b00      	cmp	r3, #0
    c202:	d001      	beq.n	c208 <fireball_init+0x68>
    {
        return 2;
    c204:	2302      	movs	r3, #2
    c206:	e050      	b.n	c2aa <fireball_init+0x10a>
    //
    // Set up the pins, including CE, for Apollo3 IOM5 pins that will
    // communicate with the Apollo IOS SPI device.
    //
#if AM_APOLLO3_GPIO
    am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM5_SCK,    g_AM_BSP_GPIO_IOM5_SCK);
    c208:	4b2c      	ldr	r3, [pc, #176]	; (c2bc <fireball_init+0x11c>)
    c20a:	6819      	ldr	r1, [r3, #0]
    c20c:	2030      	movs	r0, #48	; 0x30
    c20e:	f002 fd39 	bl	ec84 <am_hal_gpio_pinconfig>
    am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM5_MISO,   g_AM_BSP_GPIO_IOM5_MISO);
    c212:	4b2b      	ldr	r3, [pc, #172]	; (c2c0 <fireball_init+0x120>)
    c214:	6819      	ldr	r1, [r3, #0]
    c216:	2031      	movs	r0, #49	; 0x31
    c218:	f002 fd34 	bl	ec84 <am_hal_gpio_pinconfig>
    am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM5_MOSI,   g_AM_BSP_GPIO_IOM5_MOSI);
    c21c:	4b29      	ldr	r3, [pc, #164]	; (c2c4 <fireball_init+0x124>)
    c21e:	6819      	ldr	r1, [r3, #0]
    c220:	202f      	movs	r0, #47	; 0x2f
    c222:	f002 fd2f 	bl	ec84 <am_hal_gpio_pinconfig>
    am_hal_gpio_pinconfig(AM_BSP_GPIO_FIREBALL_CE, g_AM_BSP_GPIO_FIREBALL_CE);
    c226:	4b28      	ldr	r3, [pc, #160]	; (c2c8 <fireball_init+0x128>)
    c228:	6819      	ldr	r1, [r3, #0]
    c22a:	201e      	movs	r0, #30
    c22c:	f002 fd2a 	bl	ec84 <am_hal_gpio_pinconfig>

    //
    // Initialize the write transaction structure.
    // After this, we should only need to set ui32InstrLen and ui32Instr.
    //
    g_sFireballTransaction.uPeerInfo.ui32SpiChipSelect = AM_BSP_FIREBALL_CE_CHNL;
    c230:	4b26      	ldr	r3, [pc, #152]	; (c2cc <fireball_init+0x12c>)
    c232:	2203      	movs	r2, #3
    c234:	601a      	str	r2, [r3, #0]
    g_sFireballTransaction.ui32InstrLen     = 0;
    c236:	4b25      	ldr	r3, [pc, #148]	; (c2cc <fireball_init+0x12c>)
    c238:	2200      	movs	r2, #0
    c23a:	605a      	str	r2, [r3, #4]
    g_sFireballTransaction.ui32Instr        = 0;
    c23c:	4b23      	ldr	r3, [pc, #140]	; (c2cc <fireball_init+0x12c>)
    c23e:	2200      	movs	r2, #0
    c240:	609a      	str	r2, [r3, #8]
    g_sFireballTransaction.ui32NumBytes     = 0;
    c242:	4b22      	ldr	r3, [pc, #136]	; (c2cc <fireball_init+0x12c>)
    c244:	2200      	movs	r2, #0
    c246:	60da      	str	r2, [r3, #12]
    g_sFireballTransaction.eDirection       = AM_HAL_IOM_TX;
    c248:	4b20      	ldr	r3, [pc, #128]	; (c2cc <fireball_init+0x12c>)
    c24a:	2200      	movs	r2, #0
    c24c:	741a      	strb	r2, [r3, #16]
    g_sFireballTransaction.pui32TxBuffer    = 0;
    c24e:	4b1f      	ldr	r3, [pc, #124]	; (c2cc <fireball_init+0x12c>)
    c250:	2200      	movs	r2, #0
    c252:	615a      	str	r2, [r3, #20]
    g_sFireballTransaction.pui32RxBuffer    = 0;
    c254:	4b1d      	ldr	r3, [pc, #116]	; (c2cc <fireball_init+0x12c>)
    c256:	2200      	movs	r2, #0
    c258:	619a      	str	r2, [r3, #24]
    g_sFireballTransaction.bContinue        = false;
    c25a:	4b1c      	ldr	r3, [pc, #112]	; (c2cc <fireball_init+0x12c>)
    c25c:	2200      	movs	r2, #0
    c25e:	771a      	strb	r2, [r3, #28]
    g_sFireballTransaction.ui8RepeatCount   = 0;
    c260:	4b1a      	ldr	r3, [pc, #104]	; (c2cc <fireball_init+0x12c>)
    c262:	2200      	movs	r2, #0
    c264:	775a      	strb	r2, [r3, #29]
    g_sFireballTransaction.ui8Priority      = 0;
    c266:	4b19      	ldr	r3, [pc, #100]	; (c2cc <fireball_init+0x12c>)
    c268:	2200      	movs	r2, #0
    c26a:	779a      	strb	r2, [r3, #30]
    //
    // Initialize the read transaction structure.
    // After this, we should only need to set ui32InstrLen, ui32Instr, and
    // pui32RxBuffer.
    //
    g_sFireballReadIDTransaction.uPeerInfo.ui32SpiChipSelect = AM_BSP_FIREBALL_CE_CHNL;
    c26c:	4b18      	ldr	r3, [pc, #96]	; (c2d0 <fireball_init+0x130>)
    c26e:	2203      	movs	r2, #3
    c270:	601a      	str	r2, [r3, #0]
    g_sFireballReadIDTransaction.ui32InstrLen     = 0;
    c272:	4b17      	ldr	r3, [pc, #92]	; (c2d0 <fireball_init+0x130>)
    c274:	2200      	movs	r2, #0
    c276:	605a      	str	r2, [r3, #4]
    g_sFireballReadIDTransaction.ui32Instr        = 0;
    c278:	4b15      	ldr	r3, [pc, #84]	; (c2d0 <fireball_init+0x130>)
    c27a:	2200      	movs	r2, #0
    c27c:	609a      	str	r2, [r3, #8]
    g_sFireballReadIDTransaction.ui32NumBytes     = 0;
    c27e:	4b14      	ldr	r3, [pc, #80]	; (c2d0 <fireball_init+0x130>)
    c280:	2200      	movs	r2, #0
    c282:	60da      	str	r2, [r3, #12]
    g_sFireballReadIDTransaction.eDirection       = AM_HAL_IOM_RX;
    c284:	4b12      	ldr	r3, [pc, #72]	; (c2d0 <fireball_init+0x130>)
    c286:	2201      	movs	r2, #1
    c288:	741a      	strb	r2, [r3, #16]
    g_sFireballReadIDTransaction.pui32TxBuffer    = 0;
    c28a:	4b11      	ldr	r3, [pc, #68]	; (c2d0 <fireball_init+0x130>)
    c28c:	2200      	movs	r2, #0
    c28e:	615a      	str	r2, [r3, #20]
    g_sFireballReadIDTransaction.pui32RxBuffer    = 0;
    c290:	4b0f      	ldr	r3, [pc, #60]	; (c2d0 <fireball_init+0x130>)
    c292:	2200      	movs	r2, #0
    c294:	619a      	str	r2, [r3, #24]
    g_sFireballReadIDTransaction.bContinue        = false;
    c296:	4b0e      	ldr	r3, [pc, #56]	; (c2d0 <fireball_init+0x130>)
    c298:	2200      	movs	r2, #0
    c29a:	771a      	strb	r2, [r3, #28]
    g_sFireballReadIDTransaction.ui8RepeatCount   = 0;
    c29c:	4b0c      	ldr	r3, [pc, #48]	; (c2d0 <fireball_init+0x130>)
    c29e:	2200      	movs	r2, #0
    c2a0:	775a      	strb	r2, [r3, #29]
    g_sFireballReadIDTransaction.ui8Priority      = 0;
    c2a2:	4b0b      	ldr	r3, [pc, #44]	; (c2d0 <fireball_init+0x130>)
    c2a4:	2200      	movs	r2, #0
    c2a6:	779a      	strb	r2, [r3, #30]

    return 0;
    c2a8:	2300      	movs	r3, #0

} // fireball_init()
    c2aa:	4618      	mov	r0, r3
    c2ac:	3708      	adds	r7, #8
    c2ae:	46bd      	mov	sp, r7
    c2b0:	bd80      	pop	{r7, pc}
    c2b2:	bf00      	nop
    c2b4:	100010bc 	.word	0x100010bc
    c2b8:	00010aa4 	.word	0x00010aa4
    c2bc:	00010b40 	.word	0x00010b40
    c2c0:	00010b38 	.word	0x00010b38
    c2c4:	00010b3c 	.word	0x00010b3c
    c2c8:	00010ab8 	.word	0x00010ab8
    c2cc:	100010c0 	.word	0x100010c0
    c2d0:	10001000 	.word	0x10001000

0000c2d4 <fireball_write_cmd>:
//*****************************************************************************
// fireball_write_cmd()
//*****************************************************************************
static uint32_t
fireball_write_cmd(uint32_t ui32FireballCmd)
{
    c2d4:	b580      	push	{r7, lr}
    c2d6:	b082      	sub	sp, #8
    c2d8:	af00      	add	r7, sp, #0
    c2da:	6078      	str	r0, [r7, #4]
    //
    // On the Apollo slave, bit7 of the offset byte determines write or read.
    // 1=write, 0=read.
    //
    g_sFireballTransaction.ui32InstrLen     = 2;
    c2dc:	4b09      	ldr	r3, [pc, #36]	; (c304 <fireball_write_cmd+0x30>)
    c2de:	2202      	movs	r2, #2
    c2e0:	605a      	str	r2, [r3, #4]
    g_sFireballTransaction.ui32Instr        = (0x80 << 8) |
                                              (ui32FireballCmd & 0xFF);
    c2e2:	687b      	ldr	r3, [r7, #4]
    c2e4:	b2db      	uxtb	r3, r3
    g_sFireballTransaction.ui32Instr        = (0x80 << 8) |
    c2e6:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    c2ea:	4a06      	ldr	r2, [pc, #24]	; (c304 <fireball_write_cmd+0x30>)
    c2ec:	6093      	str	r3, [r2, #8]

    return am_hal_iom_blocking_transfer(g_pIOM5Handle,
    c2ee:	4b06      	ldr	r3, [pc, #24]	; (c308 <fireball_write_cmd+0x34>)
    c2f0:	681b      	ldr	r3, [r3, #0]
    c2f2:	4904      	ldr	r1, [pc, #16]	; (c304 <fireball_write_cmd+0x30>)
    c2f4:	4618      	mov	r0, r3
    c2f6:	f003 fab9 	bl	f86c <am_hal_iom_blocking_transfer>
    c2fa:	4603      	mov	r3, r0
                                        &g_sFireballTransaction);

} // fireball_write_cmd()
    c2fc:	4618      	mov	r0, r3
    c2fe:	3708      	adds	r7, #8
    c300:	46bd      	mov	sp, r7
    c302:	bd80      	pop	{r7, pc}
    c304:	100010c0 	.word	0x100010c0
    c308:	100010bc 	.word	0x100010bc

0000c30c <fireball_id_get>:
//*****************************************************************************
// fireball_id_get()
//*****************************************************************************
static uint32_t
fireball_id_get(uint32_t *pui32ID)
{
    c30c:	b580      	push	{r7, lr}
    c30e:	b082      	sub	sp, #8
    c310:	af00      	add	r7, sp, #0
    c312:	6078      	str	r0, [r7, #4]
    // The ID is at offset 0x40, the SW Rev at 0x42.
    // We'll read all 3 bytes here.
    // On the Apollo slave, bit7 of the offset byte determines write or read.
    // 1=write, 0=read.
    //
    g_sFireballReadIDTransaction.ui32InstrLen     = 1;
    c314:	4b0b      	ldr	r3, [pc, #44]	; (c344 <fireball_id_get+0x38>)
    c316:	2201      	movs	r2, #1
    c318:	605a      	str	r2, [r3, #4]
    g_sFireballReadIDTransaction.ui32Instr        = 0x00 | FIRBBALL_OFFSET_ID;
    c31a:	4b0a      	ldr	r3, [pc, #40]	; (c344 <fireball_id_get+0x38>)
    c31c:	2240      	movs	r2, #64	; 0x40
    c31e:	609a      	str	r2, [r3, #8]
    g_sFireballReadIDTransaction.ui32NumBytes     = 3;
    c320:	4b08      	ldr	r3, [pc, #32]	; (c344 <fireball_id_get+0x38>)
    c322:	2203      	movs	r2, #3
    c324:	60da      	str	r2, [r3, #12]
    g_sFireballReadIDTransaction.pui32RxBuffer    = pui32ID;
    c326:	4a07      	ldr	r2, [pc, #28]	; (c344 <fireball_id_get+0x38>)
    c328:	687b      	ldr	r3, [r7, #4]
    c32a:	6193      	str	r3, [r2, #24]

    return am_hal_iom_blocking_transfer(g_pIOM5Handle,
    c32c:	4b06      	ldr	r3, [pc, #24]	; (c348 <fireball_id_get+0x3c>)
    c32e:	681b      	ldr	r3, [r3, #0]
    c330:	4904      	ldr	r1, [pc, #16]	; (c344 <fireball_id_get+0x38>)
    c332:	4618      	mov	r0, r3
    c334:	f003 fa9a 	bl	f86c <am_hal_iom_blocking_transfer>
    c338:	4603      	mov	r3, r0
                                        &g_sFireballReadIDTransaction);

} // fireball_id_get()
    c33a:	4618      	mov	r0, r3
    c33c:	3708      	adds	r7, #8
    c33e:	46bd      	mov	sp, r7
    c340:	bd80      	pop	{r7, pc}
    c342:	bf00      	nop
    c344:	10001000 	.word	0x10001000
    c348:	100010bc 	.word	0x100010bc

0000c34c <fireball_set>:
//*****************************************************************************
// fireball_set()
//*****************************************************************************
static uint32_t
fireball_set(uint64_t ui64GPIOLowMask, uint64_t ui64GPIOHighMask)
{
    c34c:	b590      	push	{r4, r7, lr}
    c34e:	b087      	sub	sp, #28
    c350:	af00      	add	r7, sp, #0
    c352:	e9c7 0102 	strd	r0, r1, [r7, #8]
    c356:	e9c7 2300 	strd	r2, r3, [r7]
    uint32_t ui32GPIOnum, ui32Ret;

    ui32GPIOnum = 0;
    c35a:	2300      	movs	r3, #0
    c35c:	617b      	str	r3, [r7, #20]
    while ( ui64GPIOLowMask  ||  ui64GPIOHighMask )
    c35e:	e04c      	b.n	c3fa <fireball_set+0xae>
    {
        if ( ui64GPIOLowMask & 0x1 )
    c360:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
    c364:	f04f 0101 	mov.w	r1, #1
    c368:	f04f 0200 	mov.w	r2, #0
    c36c:	ea03 0301 	and.w	r3, r3, r1
    c370:	ea04 0402 	and.w	r4, r4, r2
    c374:	4323      	orrs	r3, r4
    c376:	d010      	beq.n	c39a <fireball_set+0x4e>
        {
            ui32Ret = fireball_write_cmd(FB_CMD(FB_OP_LOW, ui32GPIOnum));
    c378:	697b      	ldr	r3, [r7, #20]
    c37a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    c37e:	4618      	mov	r0, r3
    c380:	f7ff ffa8 	bl	c2d4 <fireball_write_cmd>
    c384:	6138      	str	r0, [r7, #16]
            if ( ui32Ret )
    c386:	693b      	ldr	r3, [r7, #16]
    c388:	2b00      	cmp	r3, #0
    c38a:	d003      	beq.n	c394 <fireball_set+0x48>
            {
                return (1 << 8) | ui32Ret;
    c38c:	693b      	ldr	r3, [r7, #16]
    c38e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    c392:	e03b      	b.n	c40c <fireball_set+0xc0>
            }

            //
            // Give the Fireball Apollo a little time to process the command.
            //
            am_hal_flash_delay(FLASH_CYCLES_US(1));
    c394:	2001      	movs	r0, #1
    c396:	f002 fb45 	bl	ea24 <am_hal_flash_delay>
        }
        ui64GPIOLowMask >>= 1;
    c39a:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
    c39e:	0864      	lsrs	r4, r4, #1
    c3a0:	ea4f 0333 	mov.w	r3, r3, rrx
    c3a4:	e9c7 3402 	strd	r3, r4, [r7, #8]

        if ( ui64GPIOHighMask & 0x1 )
    c3a8:	e897 0018 	ldmia.w	r7, {r3, r4}
    c3ac:	f04f 0101 	mov.w	r1, #1
    c3b0:	f04f 0200 	mov.w	r2, #0
    c3b4:	ea03 0301 	and.w	r3, r3, r1
    c3b8:	ea04 0402 	and.w	r4, r4, r2
    c3bc:	4323      	orrs	r3, r4
    c3be:	d012      	beq.n	c3e6 <fireball_set+0x9a>
        {
            ui32Ret = fireball_write_cmd(FB_CMD(FB_OP_HI, ui32GPIOnum));
    c3c0:	697b      	ldr	r3, [r7, #20]
    c3c2:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    c3c6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    c3ca:	4618      	mov	r0, r3
    c3cc:	f7ff ff82 	bl	c2d4 <fireball_write_cmd>
    c3d0:	6138      	str	r0, [r7, #16]
            if ( ui32Ret )
    c3d2:	693b      	ldr	r3, [r7, #16]
    c3d4:	2b00      	cmp	r3, #0
    c3d6:	d003      	beq.n	c3e0 <fireball_set+0x94>
            {
                return (2 << 8) | ui32Ret;
    c3d8:	693b      	ldr	r3, [r7, #16]
    c3da:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    c3de:	e015      	b.n	c40c <fireball_set+0xc0>
            }

            //
            // Give the Fireball Apollo a little time to process the command.
            //
            am_hal_flash_delay(FLASH_CYCLES_US(1));
    c3e0:	2001      	movs	r0, #1
    c3e2:	f002 fb1f 	bl	ea24 <am_hal_flash_delay>
        }
        ui64GPIOHighMask >>= 1;
    c3e6:	e897 0018 	ldmia.w	r7, {r3, r4}
    c3ea:	0864      	lsrs	r4, r4, #1
    c3ec:	ea4f 0333 	mov.w	r3, r3, rrx
    c3f0:	e887 0018 	stmia.w	r7, {r3, r4}
        ui32GPIOnum++;
    c3f4:	697b      	ldr	r3, [r7, #20]
    c3f6:	3301      	adds	r3, #1
    c3f8:	617b      	str	r3, [r7, #20]
    while ( ui64GPIOLowMask  ||  ui64GPIOHighMask )
    c3fa:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
    c3fe:	4323      	orrs	r3, r4
    c400:	d1ae      	bne.n	c360 <fireball_set+0x14>
    c402:	e897 0018 	ldmia.w	r7, {r3, r4}
    c406:	4323      	orrs	r3, r4
    c408:	d1aa      	bne.n	c360 <fireball_set+0x14>
    }

    return 0;
    c40a:	2300      	movs	r3, #0

} // fireball_set()
    c40c:	4618      	mov	r0, r3
    c40e:	371c      	adds	r7, #28
    c410:	46bd      	mov	sp, r7
    c412:	bd90      	pop	{r4, r7, pc}

0000c414 <device_reset>:
//*****************************************************************************
// device_reset()
//*****************************************************************************
static uint32_t
device_reset(uint32_t ui32GPIO, bool bAssertLow)
{
    c414:	b580      	push	{r7, lr}
    c416:	b084      	sub	sp, #16
    c418:	af00      	add	r7, sp, #0
    c41a:	6078      	str	r0, [r7, #4]
    c41c:	460b      	mov	r3, r1
    c41e:	70fb      	strb	r3, [r7, #3]
    uint32_t ui32Assert, ui32Deassert;

    ui32Assert   = bAssertLow ? FB_OP_LOW : FB_OP_HI;
    c420:	78fb      	ldrb	r3, [r7, #3]
    c422:	f083 0301 	eor.w	r3, r3, #1
    c426:	b2db      	uxtb	r3, r3
    c428:	60fb      	str	r3, [r7, #12]
    ui32Deassert = bAssertLow ? FB_OP_HI  : FB_OP_LOW;
    c42a:	78fb      	ldrb	r3, [r7, #3]
    c42c:	60bb      	str	r3, [r7, #8]

    //
    // Assert the reset signal.
    //
    if ( fireball_write_cmd(FB_CMD(ui32Assert, ui32GPIO)) )
    c42e:	68fb      	ldr	r3, [r7, #12]
    c430:	019b      	lsls	r3, r3, #6
    c432:	b2da      	uxtb	r2, r3
    c434:	687b      	ldr	r3, [r7, #4]
    c436:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    c43a:	4313      	orrs	r3, r2
    c43c:	4618      	mov	r0, r3
    c43e:	f7ff ff49 	bl	c2d4 <fireball_write_cmd>
    c442:	4603      	mov	r3, r0
    c444:	2b00      	cmp	r3, #0
    c446:	d001      	beq.n	c44c <device_reset+0x38>
    {
        return 1;
    c448:	2301      	movs	r3, #1
    c44a:	e013      	b.n	c474 <device_reset+0x60>
    }

    //
    // Reset pulse width.   (1ms)
    //
    am_hal_flash_delay(FLASH_CYCLES_US(1000));
    c44c:	f643 6057 	movw	r0, #15959	; 0x3e57
    c450:	f002 fae8 	bl	ea24 <am_hal_flash_delay>

    //
    // De-assert the reset signal.
    //
    if ( fireball_write_cmd(FB_CMD(ui32Deassert, ui32GPIO)) )
    c454:	68bb      	ldr	r3, [r7, #8]
    c456:	019b      	lsls	r3, r3, #6
    c458:	b2da      	uxtb	r2, r3
    c45a:	687b      	ldr	r3, [r7, #4]
    c45c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    c460:	4313      	orrs	r3, r2
    c462:	4618      	mov	r0, r3
    c464:	f7ff ff36 	bl	c2d4 <fireball_write_cmd>
    c468:	4603      	mov	r3, r0
    c46a:	2b00      	cmp	r3, #0
    c46c:	d001      	beq.n	c472 <device_reset+0x5e>
    {
        return 3;
    c46e:	2303      	movs	r3, #3
    c470:	e000      	b.n	c474 <device_reset+0x60>
    }

    return 0;
    c472:	2300      	movs	r3, #0

} // device_reset()
    c474:	4618      	mov	r0, r3
    c476:	3710      	adds	r7, #16
    c478:	46bd      	mov	sp, r7
    c47a:	bd80      	pop	{r7, pc}

0000c47c <am_devices_fireball_control>:
//
//*****************************************************************************
uint32_t
am_devices_fireball_control(am_devices_fireball_control_e eControl,
                            void *pArgs)
{
    c47c:	b590      	push	{r4, r7, lr}
    c47e:	b08b      	sub	sp, #44	; 0x2c
    c480:	af00      	add	r7, sp, #0
    c482:	4603      	mov	r3, r0
    c484:	6039      	str	r1, [r7, #0]
    c486:	71fb      	strb	r3, [r7, #7]
    uint64_t ui64GPIOLowMask, ui64GPIOHighMask;

    if ( eControl >= AM_DEVICES_FIREBALL_STATE_INVALID )
    c488:	79fb      	ldrb	r3, [r7, #7]
    c48a:	2b13      	cmp	r3, #19
    c48c:	d901      	bls.n	c492 <am_devices_fireball_control+0x16>
    {
        return 1;
    c48e:	2301      	movs	r3, #1
    c490:	e16e      	b.n	c770 <am_devices_fireball_control+0x2f4>
    }

    if ( fireball_init(1, FIREBALL_IOM_MODULE) )
    c492:	2105      	movs	r1, #5
    c494:	2001      	movs	r0, #1
    c496:	f7ff fe83 	bl	c1a0 <fireball_init>
    c49a:	4603      	mov	r3, r0
    c49c:	2b00      	cmp	r3, #0
    c49e:	d001      	beq.n	c4a4 <am_devices_fireball_control+0x28>
    {
        return 2;
    c4a0:	2302      	movs	r3, #2
    c4a2:	e165      	b.n	c770 <am_devices_fireball_control+0x2f4>
    }

    switch ( eControl )
    c4a4:	79fb      	ldrb	r3, [r7, #7]
    c4a6:	3b01      	subs	r3, #1
    c4a8:	2b12      	cmp	r3, #18
    c4aa:	f200 8160 	bhi.w	c76e <am_devices_fireball_control+0x2f2>
    c4ae:	a201      	add	r2, pc, #4	; (adr r2, c4b4 <am_devices_fireball_control+0x38>)
    c4b0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    c4b4:	0000c501 	.word	0x0000c501
    c4b8:	0000c527 	.word	0x0000c527
    c4bc:	0000c707 	.word	0x0000c707
    c4c0:	0000c733 	.word	0x0000c733
    c4c4:	0000c73f 	.word	0x0000c73f
    c4c8:	0000c74b 	.word	0x0000c74b
    c4cc:	0000c757 	.word	0x0000c757
    c4d0:	0000c763 	.word	0x0000c763
    c4d4:	0000c54f 	.word	0x0000c54f
    c4d8:	0000c577 	.word	0x0000c577
    c4dc:	0000c59f 	.word	0x0000c59f
    c4e0:	0000c5c7 	.word	0x0000c5c7
    c4e4:	0000c5ef 	.word	0x0000c5ef
    c4e8:	0000c617 	.word	0x0000c617
    c4ec:	0000c63f 	.word	0x0000c63f
    c4f0:	0000c667 	.word	0x0000c667
    c4f4:	0000c68f 	.word	0x0000c68f
    c4f8:	0000c6b7 	.word	0x0000c6b7
    c4fc:	0000c6df 	.word	0x0000c6df
    {
        uint32_t ui32Ret, ui32Val;

        case AM_DEVICES_FIREBALL_STATE_ID_GET:
            ui32Ret = fireball_id_get(&ui32Val);
    c500:	f107 030c 	add.w	r3, r7, #12
    c504:	4618      	mov	r0, r3
    c506:	f7ff ff01 	bl	c30c <fireball_id_get>
    c50a:	6278      	str	r0, [r7, #36]	; 0x24
            ui32Val = ui32Ret ? 0 : ui32Val & 0xFFFF;
    c50c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    c50e:	2b00      	cmp	r3, #0
    c510:	d102      	bne.n	c518 <am_devices_fireball_control+0x9c>
    c512:	68fb      	ldr	r3, [r7, #12]
    c514:	b29b      	uxth	r3, r3
    c516:	e000      	b.n	c51a <am_devices_fireball_control+0x9e>
    c518:	2300      	movs	r3, #0
    c51a:	60fb      	str	r3, [r7, #12]
            *((uint32_t*)pArgs) = ui32Val;
    c51c:	68fa      	ldr	r2, [r7, #12]
    c51e:	683b      	ldr	r3, [r7, #0]
    c520:	601a      	str	r2, [r3, #0]
            return ui32Ret;
    c522:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    c524:	e124      	b.n	c770 <am_devices_fireball_control+0x2f4>

        case AM_DEVICES_FIREBALL_STATE_VER_GET:
            ui32Ret = fireball_id_get(&ui32Val);
    c526:	f107 030c 	add.w	r3, r7, #12
    c52a:	4618      	mov	r0, r3
    c52c:	f7ff feee 	bl	c30c <fireball_id_get>
    c530:	6278      	str	r0, [r7, #36]	; 0x24
            ui32Val = ui32Ret ? 0 : (ui32Val >> 16) & 0xFF;
    c532:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    c534:	2b00      	cmp	r3, #0
    c536:	d103      	bne.n	c540 <am_devices_fireball_control+0xc4>
    c538:	68fb      	ldr	r3, [r7, #12]
    c53a:	0c1b      	lsrs	r3, r3, #16
    c53c:	b2db      	uxtb	r3, r3
    c53e:	e000      	b.n	c542 <am_devices_fireball_control+0xc6>
    c540:	2300      	movs	r3, #0
    c542:	60fb      	str	r3, [r7, #12]
            *((uint32_t*)pArgs) = ui32Val;
    c544:	68fa      	ldr	r2, [r7, #12]
    c546:	683b      	ldr	r3, [r7, #0]
    c548:	601a      	str	r2, [r3, #0]
            return ui32Ret;
    c54a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    c54c:	e110      	b.n	c770 <am_devices_fireball_control+0x2f4>
        case AM_DEVICES_FIREBALL_STATE_SPI_FLASH:
            //
            // GPIO LOW:  4-7,10,11
            // GPIO HIGH: -
            //
            ui64GPIOLowMask  = ((uint64_t)0xF << 4)  | ((uint64_t)0x3 << 10);
    c54e:	f44f 634f 	mov.w	r3, #3312	; 0xcf0
    c552:	f04f 0400 	mov.w	r4, #0
    c556:	e9c7 3406 	strd	r3, r4, [r7, #24]
            ui64GPIOHighMask = ((uint64_t)0x0 << 0);
    c55a:	f04f 0300 	mov.w	r3, #0
    c55e:	f04f 0400 	mov.w	r4, #0
    c562:	e9c7 3404 	strd	r3, r4, [r7, #16]
            return fireball_set(ui64GPIOLowMask, ui64GPIOHighMask);
    c566:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    c56a:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
    c56e:	f7ff feed 	bl	c34c <fireball_set>
    c572:	4603      	mov	r3, r0
    c574:	e0fc      	b.n	c770 <am_devices_fireball_control+0x2f4>
        case AM_DEVICES_FIREBALL_STATE_SPI_FRAM:
            //
            // GPIO LOW:  4-7,10
            // GPIO HIGH: 11
            //
            ui64GPIOLowMask  = ((uint64_t)0xF << 4)  | ((uint64_t)0x1 << 10);
    c576:	f44f 639e 	mov.w	r3, #1264	; 0x4f0
    c57a:	f04f 0400 	mov.w	r4, #0
    c57e:	e9c7 3406 	strd	r3, r4, [r7, #24]
            ui64GPIOHighMask = ((uint64_t)0x1 << 11);
    c582:	f44f 6300 	mov.w	r3, #2048	; 0x800
    c586:	f04f 0400 	mov.w	r4, #0
    c58a:	e9c7 3404 	strd	r3, r4, [r7, #16]
            return fireball_set(ui64GPIOLowMask, ui64GPIOHighMask);
    c58e:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    c592:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
    c596:	f7ff fed9 	bl	c34c <fireball_set>
    c59a:	4603      	mov	r3, r0
    c59c:	e0e8      	b.n	c770 <am_devices_fireball_control+0x2f4>
        case AM_DEVICES_FIREBALL_STATE_I2C_IOM0:
            //
            // GPIO LOW:  5,12-13
            // GPIO HIGH: 4
            //
            ui64GPIOLowMask  = ((uint64_t)0x1 << 5)  | ((uint64_t)0x3 << 12);
    c59e:	f243 0320 	movw	r3, #12320	; 0x3020
    c5a2:	f04f 0400 	mov.w	r4, #0
    c5a6:	e9c7 3406 	strd	r3, r4, [r7, #24]
            ui64GPIOHighMask = ((uint64_t)0x1 << 4);
    c5aa:	f04f 0310 	mov.w	r3, #16
    c5ae:	f04f 0400 	mov.w	r4, #0
    c5b2:	e9c7 3404 	strd	r3, r4, [r7, #16]
            return fireball_set(ui64GPIOLowMask, ui64GPIOHighMask);
    c5b6:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    c5ba:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
    c5be:	f7ff fec5 	bl	c34c <fireball_set>
    c5c2:	4603      	mov	r3, r0
    c5c4:	e0d4      	b.n	c770 <am_devices_fireball_control+0x2f4>
        case AM_DEVICES_FIREBALL_STATE_I2C_IOM1:
            //
            // GPIO LOW:  5,12
            // GPIO HIGH: 4,13
            //
            ui64GPIOLowMask  = ((uint64_t)0x1 << 5)  | ((uint64_t)0x1 << 12);
    c5c6:	f44f 5381 	mov.w	r3, #4128	; 0x1020
    c5ca:	f04f 0400 	mov.w	r4, #0
    c5ce:	e9c7 3406 	strd	r3, r4, [r7, #24]
            ui64GPIOHighMask = ((uint64_t)0x1 << 4)  | ((uint64_t)0x1 << 13);
    c5d2:	f242 0310 	movw	r3, #8208	; 0x2010
    c5d6:	f04f 0400 	mov.w	r4, #0
    c5da:	e9c7 3404 	strd	r3, r4, [r7, #16]
            return fireball_set(ui64GPIOLowMask, ui64GPIOHighMask);
    c5de:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    c5e2:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
    c5e6:	f7ff feb1 	bl	c34c <fireball_set>
    c5ea:	4603      	mov	r3, r0
    c5ec:	e0c0      	b.n	c770 <am_devices_fireball_control+0x2f4>
        case AM_DEVICES_FIREBALL_STATE_I2C_IOM2:
            //
            // GPIO LOW:  5,13
            // GPIO HIGH: 4,12
            //
            ui64GPIOLowMask  = ((uint64_t)0x1 << 5)  | ((uint64_t)0x1 << 13);
    c5ee:	f242 0320 	movw	r3, #8224	; 0x2020
    c5f2:	f04f 0400 	mov.w	r4, #0
    c5f6:	e9c7 3406 	strd	r3, r4, [r7, #24]
            ui64GPIOHighMask = ((uint64_t)0x1 << 4)  | ((uint64_t)0x1 << 12);
    c5fa:	f241 0310 	movw	r3, #4112	; 0x1010
    c5fe:	f04f 0400 	mov.w	r4, #0
    c602:	e9c7 3404 	strd	r3, r4, [r7, #16]
            return fireball_set(ui64GPIOLowMask, ui64GPIOHighMask);
    c606:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    c60a:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
    c60e:	f7ff fe9d 	bl	c34c <fireball_set>
    c612:	4603      	mov	r3, r0
    c614:	e0ac      	b.n	c770 <am_devices_fireball_control+0x2f4>
        case AM_DEVICES_FIREBALL_STATE_I2C_IOM3:
            //
            // GPIO LOW:  5,14-15
            // GPIO HIGH: 4
            //
            ui64GPIOLowMask  = ((uint64_t)0x1 << 5)  | ((uint64_t)0x3 << 14);
    c616:	f24c 0320 	movw	r3, #49184	; 0xc020
    c61a:	f04f 0400 	mov.w	r4, #0
    c61e:	e9c7 3406 	strd	r3, r4, [r7, #24]
            ui64GPIOHighMask = ((uint64_t)0x1 << 4);
    c622:	f04f 0310 	mov.w	r3, #16
    c626:	f04f 0400 	mov.w	r4, #0
    c62a:	e9c7 3404 	strd	r3, r4, [r7, #16]
            return fireball_set(ui64GPIOLowMask, ui64GPIOHighMask);
    c62e:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    c632:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
    c636:	f7ff fe89 	bl	c34c <fireball_set>
    c63a:	4603      	mov	r3, r0
    c63c:	e098      	b.n	c770 <am_devices_fireball_control+0x2f4>
        case AM_DEVICES_FIREBALL_STATE_I2C_IOM4:
            //
            // GPIO LOW:  5,14
            // GPIO HIGH: 4,15
            //
            ui64GPIOLowMask  = ((uint64_t)0x1 << 5)  | ((uint64_t)0x1 << 14);
    c63e:	f244 0320 	movw	r3, #16416	; 0x4020
    c642:	f04f 0400 	mov.w	r4, #0
    c646:	e9c7 3406 	strd	r3, r4, [r7, #24]
            ui64GPIOHighMask = ((uint64_t)0x1 << 4)  | ((uint64_t)0x1 << 15);
    c64a:	f248 0310 	movw	r3, #32784	; 0x8010
    c64e:	f04f 0400 	mov.w	r4, #0
    c652:	e9c7 3404 	strd	r3, r4, [r7, #16]
            return fireball_set(ui64GPIOLowMask, ui64GPIOHighMask);
    c656:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    c65a:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
    c65e:	f7ff fe75 	bl	c34c <fireball_set>
    c662:	4603      	mov	r3, r0
    c664:	e084      	b.n	c770 <am_devices_fireball_control+0x2f4>
        case AM_DEVICES_FIREBALL_STATE_I2C_IOM5:
            //
            // GPIO LOW:  5,15
            // GPIO HIGH: 4,14
            //
            ui64GPIOLowMask  = ((uint64_t)0x1 << 5)  | ((uint64_t)0x1 << 15);
    c666:	f248 0320 	movw	r3, #32800	; 0x8020
    c66a:	f04f 0400 	mov.w	r4, #0
    c66e:	e9c7 3406 	strd	r3, r4, [r7, #24]
            ui64GPIOHighMask = ((uint64_t)0x1 << 4)  | ((uint64_t)0x1 << 14);
    c672:	f244 0310 	movw	r3, #16400	; 0x4010
    c676:	f04f 0400 	mov.w	r4, #0
    c67a:	e9c7 3404 	strd	r3, r4, [r7, #16]
            return fireball_set(ui64GPIOLowMask, ui64GPIOHighMask);
    c67e:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    c682:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
    c686:	f7ff fe61 	bl	c34c <fireball_set>
    c68a:	4603      	mov	r3, r0
    c68c:	e070      	b.n	c770 <am_devices_fireball_control+0x2f4>
        case AM_DEVICES_FIREBALL_STATE_OCTAL_FLASH_CE0:
            //
            // GPIO LOW:  8-9,35-36
            // GPIO HIGH: 34,37
            //
            ui64GPIOLowMask  = ((uint64_t)0x3 << 8)  | ((uint64_t)0x3 << 35);
    c68e:	f44f 7340 	mov.w	r3, #768	; 0x300
    c692:	f04f 0418 	mov.w	r4, #24
    c696:	e9c7 3406 	strd	r3, r4, [r7, #24]
            ui64GPIOHighMask = ((uint64_t)0x1 << 34) | ((uint64_t)0x1 << 37);
    c69a:	f04f 0300 	mov.w	r3, #0
    c69e:	f04f 0424 	mov.w	r4, #36	; 0x24
    c6a2:	e9c7 3404 	strd	r3, r4, [r7, #16]
            return fireball_set(ui64GPIOLowMask, ui64GPIOHighMask);
    c6a6:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    c6aa:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
    c6ae:	f7ff fe4d 	bl	c34c <fireball_set>
    c6b2:	4603      	mov	r3, r0
    c6b4:	e05c      	b.n	c770 <am_devices_fireball_control+0x2f4>
        case AM_DEVICES_FIREBALL_STATE_OCTAL_FLASH_CE1:
            //
            // GPIO LOW:  8-9,37
            // GPIO HIGH: 36
            //
            ui64GPIOLowMask  = ((uint64_t)0x3 << 8) | ((uint64_t)0x1 << 37);
    c6b6:	f44f 7340 	mov.w	r3, #768	; 0x300
    c6ba:	f04f 0420 	mov.w	r4, #32
    c6be:	e9c7 3406 	strd	r3, r4, [r7, #24]
            ui64GPIOHighMask = ((uint64_t)0x1 << 36);
    c6c2:	f04f 0300 	mov.w	r3, #0
    c6c6:	f04f 0410 	mov.w	r4, #16
    c6ca:	e9c7 3404 	strd	r3, r4, [r7, #16]
            return fireball_set(ui64GPIOLowMask, ui64GPIOHighMask);
    c6ce:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    c6d2:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
    c6d6:	f7ff fe39 	bl	c34c <fireball_set>
    c6da:	4603      	mov	r3, r0
    c6dc:	e048      	b.n	c770 <am_devices_fireball_control+0x2f4>
        case AM_DEVICES_FIREBALL_STATE_TWIN_QUAD_CE0_CE1:
            //
            // GPIO LOW:  8-9,35-37
            // GPIO HIGH: 34
            //
            ui64GPIOLowMask  = ((uint64_t)0x3 << 8) | ((uint64_t)0x7 << 35);
    c6de:	f44f 7340 	mov.w	r3, #768	; 0x300
    c6e2:	f04f 0438 	mov.w	r4, #56	; 0x38
    c6e6:	e9c7 3406 	strd	r3, r4, [r7, #24]
            ui64GPIOHighMask = ((uint64_t)0x1 << 34);
    c6ea:	f04f 0300 	mov.w	r3, #0
    c6ee:	f04f 0404 	mov.w	r4, #4
    c6f2:	e9c7 3404 	strd	r3, r4, [r7, #16]
            return fireball_set(ui64GPIOLowMask, ui64GPIOHighMask);
    c6f6:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    c6fa:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
    c6fe:	f7ff fe25 	bl	c34c <fireball_set>
    c702:	4603      	mov	r3, r0
    c704:	e034      	b.n	c770 <am_devices_fireball_control+0x2f4>
            // BNO055:  42
            // MSPI:    41
            // MKB1:    40
            // MKB2:    39
            //
            device_reset(43, true);
    c706:	2101      	movs	r1, #1
    c708:	202b      	movs	r0, #43	; 0x2b
    c70a:	f7ff fe83 	bl	c414 <device_reset>
            device_reset(42, true);
    c70e:	2101      	movs	r1, #1
    c710:	202a      	movs	r0, #42	; 0x2a
    c712:	f7ff fe7f 	bl	c414 <device_reset>
            device_reset(41, true);
    c716:	2101      	movs	r1, #1
    c718:	2029      	movs	r0, #41	; 0x29
    c71a:	f7ff fe7b 	bl	c414 <device_reset>
            device_reset(40, false);
    c71e:	2100      	movs	r1, #0
    c720:	2028      	movs	r0, #40	; 0x28
    c722:	f7ff fe77 	bl	c414 <device_reset>
            device_reset(39, false);
    c726:	2100      	movs	r1, #0
    c728:	2027      	movs	r0, #39	; 0x27
    c72a:	f7ff fe73 	bl	c414 <device_reset>
            return 0;
    c72e:	2300      	movs	r3, #0
    c730:	e01e      	b.n	c770 <am_devices_fireball_control+0x2f4>

        case AM_DEVICES_FIREBALL_STATE_SX9300_RESET:
            return device_reset(43, true);
    c732:	2101      	movs	r1, #1
    c734:	202b      	movs	r0, #43	; 0x2b
    c736:	f7ff fe6d 	bl	c414 <device_reset>
    c73a:	4603      	mov	r3, r0
    c73c:	e018      	b.n	c770 <am_devices_fireball_control+0x2f4>

        case AM_DEVICES_FIREBALL_STATE_BNO055_RESET:
            return device_reset(42, true);
    c73e:	2101      	movs	r1, #1
    c740:	202a      	movs	r0, #42	; 0x2a
    c742:	f7ff fe67 	bl	c414 <device_reset>
    c746:	4603      	mov	r3, r0
    c748:	e012      	b.n	c770 <am_devices_fireball_control+0x2f4>

        case AM_DEVICES_FIREBALL_STATE_MSPI_RESET:
            return device_reset(41, true);
    c74a:	2101      	movs	r1, #1
    c74c:	2029      	movs	r0, #41	; 0x29
    c74e:	f7ff fe61 	bl	c414 <device_reset>
    c752:	4603      	mov	r3, r0
    c754:	e00c      	b.n	c770 <am_devices_fireball_control+0x2f4>
        case AM_DEVICES_FIREBALL_STATE_MKB1_RESET:
            //
            // The 2 click reset signals actually drive a transistor.
            // Therefore, the signal ends up inverted.
            //
            return device_reset(40, false);
    c756:	2100      	movs	r1, #0
    c758:	2028      	movs	r0, #40	; 0x28
    c75a:	f7ff fe5b 	bl	c414 <device_reset>
    c75e:	4603      	mov	r3, r0
    c760:	e006      	b.n	c770 <am_devices_fireball_control+0x2f4>
        case AM_DEVICES_FIREBALL_STATE_MKB2_RESET:
            //
            // The 2 click reset signals actually drive a transistor.
            // Therefore, the signal ends up inverted.
            //
            return device_reset(39, false);
    c762:	2100      	movs	r1, #0
    c764:	2027      	movs	r0, #39	; 0x27
    c766:	f7ff fe55 	bl	c414 <device_reset>
    c76a:	4603      	mov	r3, r0
    c76c:	e000      	b.n	c770 <am_devices_fireball_control+0x2f4>

        default:
            return 0xdeadbeef;
    c76e:	4b02      	ldr	r3, [pc, #8]	; (c778 <am_devices_fireball_control+0x2fc>)

    } // switch()

} // am_devices_fireball_control()
    c770:	4618      	mov	r0, r3
    c772:	372c      	adds	r7, #44	; 0x2c
    c774:	46bd      	mov	sp, r7
    c776:	bd90      	pop	{r4, r7, pc}
    c778:	deadbeef 	.word	0xdeadbeef

0000c77c <am_device_command_write>:
//
//*****************************************************************************
static uint32_t
am_device_command_write(uint32_t ui32InstrLen, uint32_t ui32Instr,
                        uint32_t *pData, uint32_t ui32NumBytes)
{
    c77c:	b580      	push	{r7, lr}
    c77e:	b08e      	sub	sp, #56	; 0x38
    c780:	af00      	add	r7, sp, #0
    c782:	60f8      	str	r0, [r7, #12]
    c784:	60b9      	str	r1, [r7, #8]
    c786:	607a      	str	r2, [r7, #4]
    c788:	603b      	str	r3, [r7, #0]
    am_hal_iom_transfer_t Transaction;

    //
    // Create the transaction.
    //
    Transaction.ui32InstrLen    = ui32InstrLen;
    c78a:	68fb      	ldr	r3, [r7, #12]
    c78c:	617b      	str	r3, [r7, #20]
    Transaction.ui32Instr       = ui32Instr;
    c78e:	68bb      	ldr	r3, [r7, #8]
    c790:	61bb      	str	r3, [r7, #24]
    Transaction.eDirection      = AM_HAL_IOM_TX;
    c792:	2300      	movs	r3, #0
    c794:	f887 3020 	strb.w	r3, [r7, #32]
    Transaction.ui32NumBytes    = ui32NumBytes;
    c798:	683b      	ldr	r3, [r7, #0]
    c79a:	61fb      	str	r3, [r7, #28]
    Transaction.pui32TxBuffer   = pData;
    c79c:	687b      	ldr	r3, [r7, #4]
    c79e:	627b      	str	r3, [r7, #36]	; 0x24
    Transaction.uPeerInfo.ui32SpiChipSelect = g_MB85RS1MTCS;
    c7a0:	4b0f      	ldr	r3, [pc, #60]	; (c7e0 <am_device_command_write+0x64>)
    c7a2:	681b      	ldr	r3, [r3, #0]
    c7a4:	613b      	str	r3, [r7, #16]
    Transaction.bContinue       = false;
    c7a6:	2300      	movs	r3, #0
    c7a8:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
    Transaction.ui8RepeatCount  = 0;
    c7ac:	2300      	movs	r3, #0
    c7ae:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
    Transaction.ui32PauseCondition = 0;
    c7b2:	2300      	movs	r3, #0
    c7b4:	633b      	str	r3, [r7, #48]	; 0x30
    Transaction.ui32StatusSetClr = 0;
    c7b6:	2300      	movs	r3, #0
    c7b8:	637b      	str	r3, [r7, #52]	; 0x34

    //
    // Execute the transction over IOM.
    //
    if (am_hal_iom_blocking_transfer(g_pMB85RS1MTIOMHandle, &Transaction))
    c7ba:	4b0a      	ldr	r3, [pc, #40]	; (c7e4 <am_device_command_write+0x68>)
    c7bc:	681b      	ldr	r3, [r3, #0]
    c7be:	f107 0210 	add.w	r2, r7, #16
    c7c2:	4611      	mov	r1, r2
    c7c4:	4618      	mov	r0, r3
    c7c6:	f003 f851 	bl	f86c <am_hal_iom_blocking_transfer>
    c7ca:	4603      	mov	r3, r0
    c7cc:	2b00      	cmp	r3, #0
    c7ce:	d001      	beq.n	c7d4 <am_device_command_write+0x58>
    {
        return AM_DEVICES_MB85RS1MT_STATUS_ERROR;
    c7d0:	2301      	movs	r3, #1
    c7d2:	e000      	b.n	c7d6 <am_device_command_write+0x5a>
    }
    return AM_DEVICES_MB85RS1MT_STATUS_SUCCESS;
    c7d4:	2300      	movs	r3, #0
}
    c7d6:	4618      	mov	r0, r3
    c7d8:	3738      	adds	r7, #56	; 0x38
    c7da:	46bd      	mov	sp, r7
    c7dc:	bd80      	pop	{r7, pc}
    c7de:	bf00      	nop
    c7e0:	100010ec 	.word	0x100010ec
    c7e4:	100010e8 	.word	0x100010e8

0000c7e8 <am_device_command_read>:

static uint32_t
am_device_command_read(uint32_t ui32InstrLen, uint32_t ui32Instr,
                       uint32_t *pData, uint32_t ui32NumBytes)
{
    c7e8:	b580      	push	{r7, lr}
    c7ea:	b08e      	sub	sp, #56	; 0x38
    c7ec:	af00      	add	r7, sp, #0
    c7ee:	60f8      	str	r0, [r7, #12]
    c7f0:	60b9      	str	r1, [r7, #8]
    c7f2:	607a      	str	r2, [r7, #4]
    c7f4:	603b      	str	r3, [r7, #0]
    am_hal_iom_transfer_t Transaction;

    //
    // Create the transaction.
    //
    Transaction.ui32InstrLen    = ui32InstrLen;
    c7f6:	68fb      	ldr	r3, [r7, #12]
    c7f8:	617b      	str	r3, [r7, #20]
    Transaction.ui32Instr       = ui32Instr;
    c7fa:	68bb      	ldr	r3, [r7, #8]
    c7fc:	61bb      	str	r3, [r7, #24]
    Transaction.eDirection      = AM_HAL_IOM_RX;
    c7fe:	2301      	movs	r3, #1
    c800:	f887 3020 	strb.w	r3, [r7, #32]
    Transaction.ui32NumBytes    = ui32NumBytes;
    c804:	683b      	ldr	r3, [r7, #0]
    c806:	61fb      	str	r3, [r7, #28]
    Transaction.pui32RxBuffer   = pData;
    c808:	687b      	ldr	r3, [r7, #4]
    c80a:	62bb      	str	r3, [r7, #40]	; 0x28
    Transaction.uPeerInfo.ui32SpiChipSelect = g_MB85RS1MTCS;
    c80c:	4b0f      	ldr	r3, [pc, #60]	; (c84c <am_device_command_read+0x64>)
    c80e:	681b      	ldr	r3, [r3, #0]
    c810:	613b      	str	r3, [r7, #16]
    Transaction.bContinue       = false;
    c812:	2300      	movs	r3, #0
    c814:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
    Transaction.ui8RepeatCount  = 0;
    c818:	2300      	movs	r3, #0
    c81a:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
    Transaction.ui32PauseCondition = 0;
    c81e:	2300      	movs	r3, #0
    c820:	633b      	str	r3, [r7, #48]	; 0x30
    Transaction.ui32StatusSetClr = 0;
    c822:	2300      	movs	r3, #0
    c824:	637b      	str	r3, [r7, #52]	; 0x34

    //
    // Execute the transction over IOM.
    //
    if (am_hal_iom_blocking_transfer(g_pMB85RS1MTIOMHandle, &Transaction))
    c826:	4b0a      	ldr	r3, [pc, #40]	; (c850 <am_device_command_read+0x68>)
    c828:	681b      	ldr	r3, [r3, #0]
    c82a:	f107 0210 	add.w	r2, r7, #16
    c82e:	4611      	mov	r1, r2
    c830:	4618      	mov	r0, r3
    c832:	f003 f81b 	bl	f86c <am_hal_iom_blocking_transfer>
    c836:	4603      	mov	r3, r0
    c838:	2b00      	cmp	r3, #0
    c83a:	d001      	beq.n	c840 <am_device_command_read+0x58>
    {
        return AM_DEVICES_MB85RS1MT_STATUS_ERROR;
    c83c:	2301      	movs	r3, #1
    c83e:	e000      	b.n	c842 <am_device_command_read+0x5a>
    }
    return AM_DEVICES_MB85RS1MT_STATUS_SUCCESS;
    c840:	2300      	movs	r3, #0
}
    c842:	4618      	mov	r0, r3
    c844:	3738      	adds	r7, #56	; 0x38
    c846:	46bd      	mov	sp, r7
    c848:	bd80      	pop	{r7, pc}
    c84a:	bf00      	nop
    c84c:	100010ec 	.word	0x100010ec
    c850:	100010e8 	.word	0x100010e8

0000c854 <am_devices_mb85rs1mt_init>:
//! @return Status.
//
//*****************************************************************************
uint32_t
am_devices_mb85rs1mt_init(uint32_t ui32Module, am_hal_iom_config_t *psIOMSettings, void **ppIomHandle)
{
    c854:	b580      	push	{r7, lr}
    c856:	b084      	sub	sp, #16
    c858:	af00      	add	r7, sp, #0
    c85a:	60f8      	str	r0, [r7, #12]
    c85c:	60b9      	str	r1, [r7, #8]
    c85e:	607a      	str	r2, [r7, #4]
    if ( ui32Module > AM_REG_IOM_NUM_MODULES )
    c860:	68fb      	ldr	r3, [r7, #12]
    c862:	2b06      	cmp	r3, #6
    c864:	d901      	bls.n	c86a <am_devices_mb85rs1mt_init+0x16>
    {
        return AM_DEVICES_MB85RS1MT_STATUS_ERROR;
    c866:	2301      	movs	r3, #1
    c868:	e036      	b.n	c8d8 <am_devices_mb85rs1mt_init+0x84>
    }

    //
    // Configure the IOM pins.
    //
    am_bsp_iom_pins_enable(ui32Module, AM_HAL_IOM_SPI_MODE);
    c86a:	2100      	movs	r1, #0
    c86c:	68f8      	ldr	r0, [r7, #12]
    c86e:	f001 fc57 	bl	e120 <am_bsp_iom_pins_enable>

    //
    // Enable fault detection.
    //
#if AM_APOLLO3_MCUCTRL
    am_hal_mcuctrl_control(AM_HAL_MCUCTRL_CONTROL_FAULT_CAPTURE_ENABLE, 0);
    c872:	2100      	movs	r1, #0
    c874:	2000      	movs	r0, #0
    c876:	f003 fc47 	bl	10108 <am_hal_mcuctrl_control>
    // Enable power to the IOM instance.
    // Configure the IOM for Serial operation during initialization.
    // Enable the IOM.
    // HAL Success return is 0
    //
    if (am_hal_iom_initialize(ui32Module, &g_pMB85RS1MTIOMHandle) ||
    c87a:	4919      	ldr	r1, [pc, #100]	; (c8e0 <am_devices_mb85rs1mt_init+0x8c>)
    c87c:	68f8      	ldr	r0, [r7, #12]
    c87e:	f002 fc41 	bl	f104 <am_hal_iom_initialize>
    c882:	4603      	mov	r3, r0
    c884:	2b00      	cmp	r3, #0
    c886:	d11a      	bne.n	c8be <am_devices_mb85rs1mt_init+0x6a>
        am_hal_iom_power_ctrl(g_pMB85RS1MTIOMHandle, AM_HAL_SYSCTRL_WAKE, false) ||
    c888:	4b15      	ldr	r3, [pc, #84]	; (c8e0 <am_devices_mb85rs1mt_init+0x8c>)
    c88a:	681b      	ldr	r3, [r3, #0]
    c88c:	2200      	movs	r2, #0
    c88e:	2100      	movs	r1, #0
    c890:	4618      	mov	r0, r3
    c892:	f002 fe11 	bl	f4b8 <am_hal_iom_power_ctrl>
    c896:	4603      	mov	r3, r0
    if (am_hal_iom_initialize(ui32Module, &g_pMB85RS1MTIOMHandle) ||
    c898:	2b00      	cmp	r3, #0
    c89a:	d110      	bne.n	c8be <am_devices_mb85rs1mt_init+0x6a>
        am_hal_iom_configure(g_pMB85RS1MTIOMHandle, psIOMSettings) ||
    c89c:	4b10      	ldr	r3, [pc, #64]	; (c8e0 <am_devices_mb85rs1mt_init+0x8c>)
    c89e:	681b      	ldr	r3, [r3, #0]
    c8a0:	68b9      	ldr	r1, [r7, #8]
    c8a2:	4618      	mov	r0, r3
    c8a4:	f002 febe 	bl	f624 <am_hal_iom_configure>
    c8a8:	4603      	mov	r3, r0
        am_hal_iom_power_ctrl(g_pMB85RS1MTIOMHandle, AM_HAL_SYSCTRL_WAKE, false) ||
    c8aa:	2b00      	cmp	r3, #0
    c8ac:	d107      	bne.n	c8be <am_devices_mb85rs1mt_init+0x6a>
        am_hal_iom_enable(g_pMB85RS1MTIOMHandle))
    c8ae:	4b0c      	ldr	r3, [pc, #48]	; (c8e0 <am_devices_mb85rs1mt_init+0x8c>)
    c8b0:	681b      	ldr	r3, [r3, #0]
    c8b2:	4618      	mov	r0, r3
    c8b4:	f002 fc4e 	bl	f154 <am_hal_iom_enable>
    c8b8:	4603      	mov	r3, r0
        am_hal_iom_configure(g_pMB85RS1MTIOMHandle, psIOMSettings) ||
    c8ba:	2b00      	cmp	r3, #0
    c8bc:	d001      	beq.n	c8c2 <am_devices_mb85rs1mt_init+0x6e>
    {
        return AM_DEVICES_MB85RS1MT_STATUS_ERROR;
    c8be:	2301      	movs	r3, #1
    c8c0:	e00a      	b.n	c8d8 <am_devices_mb85rs1mt_init+0x84>
    }
    else
    {
        *ppIomHandle = g_pMB85RS1MTIOMHandle;
    c8c2:	4b07      	ldr	r3, [pc, #28]	; (c8e0 <am_devices_mb85rs1mt_init+0x8c>)
    c8c4:	681a      	ldr	r2, [r3, #0]
    c8c6:	687b      	ldr	r3, [r7, #4]
    c8c8:	601a      	str	r2, [r3, #0]
        g_MB85RS1MTCS = g_CS[ui32Module];
    c8ca:	4a06      	ldr	r2, [pc, #24]	; (c8e4 <am_devices_mb85rs1mt_init+0x90>)
    c8cc:	68fb      	ldr	r3, [r7, #12]
    c8ce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c8d2:	4a05      	ldr	r2, [pc, #20]	; (c8e8 <am_devices_mb85rs1mt_init+0x94>)
    c8d4:	6013      	str	r3, [r2, #0]
        //
        // Return the status.
        //
        return AM_DEVICES_MB85RS1MT_STATUS_SUCCESS;
    c8d6:	2300      	movs	r3, #0
    }
}
    c8d8:	4618      	mov	r0, r3
    c8da:	3710      	adds	r7, #16
    c8dc:	46bd      	mov	sp, r7
    c8de:	bd80      	pop	{r7, pc}
    c8e0:	100010e8 	.word	0x100010e8
    c8e4:	10001028 	.word	0x10001028
    c8e8:	100010ec 	.word	0x100010ec

0000c8ec <am_devices_mb85rs1mt_term>:
//! @return Status.
//
//*****************************************************************************
uint32_t
am_devices_mb85rs1mt_term(uint32_t ui32Module)
{
    c8ec:	b580      	push	{r7, lr}
    c8ee:	b082      	sub	sp, #8
    c8f0:	af00      	add	r7, sp, #0
    c8f2:	6078      	str	r0, [r7, #4]
    if ( ui32Module > AM_REG_IOM_NUM_MODULES )
    c8f4:	687b      	ldr	r3, [r7, #4]
    c8f6:	2b06      	cmp	r3, #6
    c8f8:	d901      	bls.n	c8fe <am_devices_mb85rs1mt_term+0x12>
    {
        return AM_DEVICES_MB85RS1MT_STATUS_ERROR;
    c8fa:	2301      	movs	r3, #1
    c8fc:	e015      	b.n	c92a <am_devices_mb85rs1mt_term+0x3e>
    }

    // Disable the pins
    am_bsp_iom_pins_disable(ui32Module, AM_HAL_IOM_SPI_MODE);
    c8fe:	2100      	movs	r1, #0
    c900:	6878      	ldr	r0, [r7, #4]
    c902:	f001 fd43 	bl	e38c <am_bsp_iom_pins_disable>

    //
    // Disable the IOM.
    //
    am_hal_iom_disable(g_pMB85RS1MTIOMHandle);
    c906:	4b0b      	ldr	r3, [pc, #44]	; (c934 <am_devices_mb85rs1mt_term+0x48>)
    c908:	681b      	ldr	r3, [r3, #0]
    c90a:	4618      	mov	r0, r3
    c90c:	f002 fc78 	bl	f200 <am_hal_iom_disable>

    //
    // Disable power to and uninitialize the IOM instance.
    //
    am_hal_iom_power_ctrl(g_pMB85RS1MTIOMHandle, AM_HAL_SYSCTRL_DEEPSLEEP, false);
    c910:	4b08      	ldr	r3, [pc, #32]	; (c934 <am_devices_mb85rs1mt_term+0x48>)
    c912:	681b      	ldr	r3, [r3, #0]
    c914:	2200      	movs	r2, #0
    c916:	2102      	movs	r1, #2
    c918:	4618      	mov	r0, r3
    c91a:	f002 fdcd 	bl	f4b8 <am_hal_iom_power_ctrl>

    am_hal_iom_uninitialize(g_pMB85RS1MTIOMHandle);
    c91e:	4b05      	ldr	r3, [pc, #20]	; (c934 <am_devices_mb85rs1mt_term+0x48>)
    c920:	681b      	ldr	r3, [r3, #0]
    c922:	4618      	mov	r0, r3
    c924:	f002 fbb8 	bl	f098 <am_hal_iom_uninitialize>

    //
    // Return the status.
    //
    return AM_DEVICES_MB85RS1MT_STATUS_SUCCESS;
    c928:	2300      	movs	r3, #0
}
    c92a:	4618      	mov	r0, r3
    c92c:	3708      	adds	r7, #8
    c92e:	46bd      	mov	sp, r7
    c930:	bd80      	pop	{r7, pc}
    c932:	bf00      	nop
    c934:	100010e8 	.word	0x100010e8

0000c938 <am_devices_mb85rs1mt_read_id>:
//! @return 32-bit status
//
//*****************************************************************************
uint32_t
am_devices_mb85rs1mt_read_id(uint32_t *pDeviceID)
{
    c938:	b580      	push	{r7, lr}
    c93a:	b082      	sub	sp, #8
    c93c:	af00      	add	r7, sp, #0
    c93e:	6078      	str	r0, [r7, #4]
    //
    // Send the command sequence to read the Device ID.
    //
    if (am_device_command_read(1, AM_DEVICES_MB85RS1MT_READ_DEVICE_ID, pDeviceID, 4))
    c940:	2304      	movs	r3, #4
    c942:	687a      	ldr	r2, [r7, #4]
    c944:	219f      	movs	r1, #159	; 0x9f
    c946:	2001      	movs	r0, #1
    c948:	f7ff ff4e 	bl	c7e8 <am_device_command_read>
    c94c:	4603      	mov	r3, r0
    c94e:	2b00      	cmp	r3, #0
    c950:	d001      	beq.n	c956 <am_devices_mb85rs1mt_read_id+0x1e>
    {
        return AM_DEVICES_MB85RS1MT_STATUS_ERROR;
    c952:	2301      	movs	r3, #1
    c954:	e000      	b.n	c958 <am_devices_mb85rs1mt_read_id+0x20>
    }
    return AM_DEVICES_MB85RS1MT_STATUS_SUCCESS;
    c956:	2300      	movs	r3, #0

}
    c958:	4618      	mov	r0, r3
    c95a:	3708      	adds	r7, #8
    c95c:	46bd      	mov	sp, r7
    c95e:	bd80      	pop	{r7, pc}

0000c960 <am_devices_mb85rs1mt_blocking_write>:
//*****************************************************************************
uint32_t
am_devices_mb85rs1mt_blocking_write(uint8_t *pui8TxBuffer,
                                    uint32_t ui32WriteAddress,
                                    uint32_t ui32NumBytes)
{
    c960:	b580      	push	{r7, lr}
    c962:	b090      	sub	sp, #64	; 0x40
    c964:	af00      	add	r7, sp, #0
    c966:	60f8      	str	r0, [r7, #12]
    c968:	60b9      	str	r1, [r7, #8]
    c96a:	607a      	str	r2, [r7, #4]
    uint32_t              Dummy;

    //
    // Send the WRITE ENABLE command to enable writing.
    //
    if (am_device_command_write(1, AM_DEVICES_MB85RS1MT_WRITE_ENABLE, &Dummy, 0))
    c96c:	f107 0214 	add.w	r2, r7, #20
    c970:	2300      	movs	r3, #0
    c972:	2106      	movs	r1, #6
    c974:	2001      	movs	r0, #1
    c976:	f7ff ff01 	bl	c77c <am_device_command_write>
    c97a:	4603      	mov	r3, r0
    c97c:	2b00      	cmp	r3, #0
    c97e:	d001      	beq.n	c984 <am_devices_mb85rs1mt_blocking_write+0x24>
    {
        return AM_DEVICES_MB85RS1MT_STATUS_ERROR;
    c980:	2301      	movs	r3, #1
    c982:	e051      	b.n	ca28 <am_devices_mb85rs1mt_blocking_write+0xc8>
    }

    Transaction.ui8RepeatCount  = 0;
    c984:	2300      	movs	r3, #0
    c986:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
    Transaction.ui32PauseCondition = 0;
    c98a:	2300      	movs	r3, #0
    c98c:	63bb      	str	r3, [r7, #56]	; 0x38
    Transaction.ui32StatusSetClr = 0;
    c98e:	2300      	movs	r3, #0
    c990:	63fb      	str	r3, [r7, #60]	; 0x3c

    //
    // Write the command to the device.
    //
    Transaction.eDirection      = AM_HAL_IOM_TX;
    c992:	2300      	movs	r3, #0
    c994:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
    Transaction.ui32InstrLen    = 1;
    c998:	2301      	movs	r3, #1
    c99a:	61fb      	str	r3, [r7, #28]
    Transaction.ui32Instr       = AM_DEVICES_MB85RS1MT_WRITE;
    c99c:	2302      	movs	r3, #2
    c99e:	623b      	str	r3, [r7, #32]
    Transaction.ui32NumBytes    = 0;
    c9a0:	2300      	movs	r3, #0
    c9a2:	627b      	str	r3, [r7, #36]	; 0x24
    Transaction.pui32TxBuffer   = (uint32_t *)pui8TxBuffer;
    c9a4:	68fb      	ldr	r3, [r7, #12]
    c9a6:	62fb      	str	r3, [r7, #44]	; 0x2c
    Transaction.uPeerInfo.ui32SpiChipSelect = g_MB85RS1MTCS;
    c9a8:	4b21      	ldr	r3, [pc, #132]	; (ca30 <am_devices_mb85rs1mt_blocking_write+0xd0>)
    c9aa:	681b      	ldr	r3, [r3, #0]
    c9ac:	61bb      	str	r3, [r7, #24]
    Transaction.bContinue       = true;
    c9ae:	2301      	movs	r3, #1
    c9b0:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34

    //
    // Start the transaction.
    //
    if (am_hal_iom_blocking_transfer(g_pMB85RS1MTIOMHandle, &Transaction))
    c9b4:	4b1f      	ldr	r3, [pc, #124]	; (ca34 <am_devices_mb85rs1mt_blocking_write+0xd4>)
    c9b6:	681b      	ldr	r3, [r3, #0]
    c9b8:	f107 0218 	add.w	r2, r7, #24
    c9bc:	4611      	mov	r1, r2
    c9be:	4618      	mov	r0, r3
    c9c0:	f002 ff54 	bl	f86c <am_hal_iom_blocking_transfer>
    c9c4:	4603      	mov	r3, r0
    c9c6:	2b00      	cmp	r3, #0
    c9c8:	d001      	beq.n	c9ce <am_devices_mb85rs1mt_blocking_write+0x6e>
    {
        return AM_DEVICES_MB85RS1MT_STATUS_ERROR;
    c9ca:	2301      	movs	r3, #1
    c9cc:	e02c      	b.n	ca28 <am_devices_mb85rs1mt_blocking_write+0xc8>
    }

    //
    // Write the offset (24 bits) to the device.
    //
    Transaction.eDirection      = AM_HAL_IOM_TX;
    c9ce:	2300      	movs	r3, #0
    c9d0:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
    Transaction.ui32InstrLen    = 3;
    c9d4:	2303      	movs	r3, #3
    c9d6:	61fb      	str	r3, [r7, #28]
    Transaction.ui32Instr       = ui32WriteAddress & 0x00FFFFFF;
    c9d8:	68bb      	ldr	r3, [r7, #8]
    c9da:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    c9de:	623b      	str	r3, [r7, #32]
    Transaction.ui32NumBytes    = ui32NumBytes;
    c9e0:	687b      	ldr	r3, [r7, #4]
    c9e2:	627b      	str	r3, [r7, #36]	; 0x24
    Transaction.pui32TxBuffer   = (uint32_t *)pui8TxBuffer;
    c9e4:	68fb      	ldr	r3, [r7, #12]
    c9e6:	62fb      	str	r3, [r7, #44]	; 0x2c
    Transaction.uPeerInfo.ui32SpiChipSelect = g_MB85RS1MTCS;
    c9e8:	4b11      	ldr	r3, [pc, #68]	; (ca30 <am_devices_mb85rs1mt_blocking_write+0xd0>)
    c9ea:	681b      	ldr	r3, [r3, #0]
    c9ec:	61bb      	str	r3, [r7, #24]
    Transaction.bContinue       = false;
    c9ee:	2300      	movs	r3, #0
    c9f0:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34

    //
    // Start the transaction.
    //
    if (am_hal_iom_blocking_transfer(g_pMB85RS1MTIOMHandle, &Transaction))
    c9f4:	4b0f      	ldr	r3, [pc, #60]	; (ca34 <am_devices_mb85rs1mt_blocking_write+0xd4>)
    c9f6:	681b      	ldr	r3, [r3, #0]
    c9f8:	f107 0218 	add.w	r2, r7, #24
    c9fc:	4611      	mov	r1, r2
    c9fe:	4618      	mov	r0, r3
    ca00:	f002 ff34 	bl	f86c <am_hal_iom_blocking_transfer>
    ca04:	4603      	mov	r3, r0
    ca06:	2b00      	cmp	r3, #0
    ca08:	d001      	beq.n	ca0e <am_devices_mb85rs1mt_blocking_write+0xae>
    {
        return AM_DEVICES_MB85RS1MT_STATUS_ERROR;
    ca0a:	2301      	movs	r3, #1
    ca0c:	e00c      	b.n	ca28 <am_devices_mb85rs1mt_blocking_write+0xc8>
    }

    //
    // Send the command to disable writing.
    //
    if (am_device_command_write(1, AM_DEVICES_MB85RS1MT_WRITE_DISABLE, &Dummy, 0))
    ca0e:	f107 0214 	add.w	r2, r7, #20
    ca12:	2300      	movs	r3, #0
    ca14:	2104      	movs	r1, #4
    ca16:	2001      	movs	r0, #1
    ca18:	f7ff feb0 	bl	c77c <am_device_command_write>
    ca1c:	4603      	mov	r3, r0
    ca1e:	2b00      	cmp	r3, #0
    ca20:	d001      	beq.n	ca26 <am_devices_mb85rs1mt_blocking_write+0xc6>
    {
        return AM_DEVICES_MB85RS1MT_STATUS_ERROR;
    ca22:	2301      	movs	r3, #1
    ca24:	e000      	b.n	ca28 <am_devices_mb85rs1mt_blocking_write+0xc8>
    }

    //
    // Return the status.
    //
    return AM_DEVICES_MB85RS1MT_STATUS_SUCCESS;
    ca26:	2300      	movs	r3, #0
}
    ca28:	4618      	mov	r0, r3
    ca2a:	3740      	adds	r7, #64	; 0x40
    ca2c:	46bd      	mov	sp, r7
    ca2e:	bd80      	pop	{r7, pc}
    ca30:	100010ec 	.word	0x100010ec
    ca34:	100010e8 	.word	0x100010e8

0000ca38 <am_devices_mb85rs1mt_nonblocking_write_adv>:
                                           uint32_t ui32NumBytes,
                                           uint32_t ui32PauseCondition,
                                           uint32_t ui32StatusSetClr,
                                           am_hal_iom_callback_t pfnCallback,
                                           void *pCallbackCtxt)
{
    ca38:	b580      	push	{r7, lr}
    ca3a:	b08e      	sub	sp, #56	; 0x38
    ca3c:	af00      	add	r7, sp, #0
    ca3e:	60f8      	str	r0, [r7, #12]
    ca40:	60b9      	str	r1, [r7, #8]
    ca42:	607a      	str	r2, [r7, #4]
    ca44:	603b      	str	r3, [r7, #0]
    am_hal_iom_transfer_t Transaction;

    //
    // Common transaction parameters
    //
    Transaction.ui8Priority     = 1;        // High priority for now.
    ca46:	2301      	movs	r3, #1
    ca48:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
    Transaction.uPeerInfo.ui32SpiChipSelect = g_MB85RS1MTCS;
    ca4c:	4b34      	ldr	r3, [pc, #208]	; (cb20 <am_devices_mb85rs1mt_nonblocking_write_adv+0xe8>)
    ca4e:	681b      	ldr	r3, [r3, #0]
    ca50:	613b      	str	r3, [r7, #16]
    Transaction.ui8RepeatCount  = 0;
    ca52:	2300      	movs	r3, #0
    ca54:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
    Transaction.ui32PauseCondition = ui32PauseCondition;
    ca58:	683b      	ldr	r3, [r7, #0]
    ca5a:	633b      	str	r3, [r7, #48]	; 0x30

    //
    // Set up the IOM transaction to send the WREN device command.
    //
    Transaction.eDirection      = AM_HAL_IOM_TX;
    ca5c:	2300      	movs	r3, #0
    ca5e:	f887 3020 	strb.w	r3, [r7, #32]
    Transaction.ui32InstrLen    = 1;        // Sending 1 offset byte
    ca62:	2301      	movs	r3, #1
    ca64:	617b      	str	r3, [r7, #20]
    Transaction.ui32Instr       = AM_DEVICES_MB85RS1MT_WRITE_ENABLE;
    ca66:	2306      	movs	r3, #6
    ca68:	61bb      	str	r3, [r7, #24]
    Transaction.ui32NumBytes    = 0;        // WREN CMD is sent as the offset
    ca6a:	2300      	movs	r3, #0
    ca6c:	61fb      	str	r3, [r7, #28]
    Transaction.pui32TxBuffer   = (uint32_t *)pui8TxBuffer; // Not used for this CMD
    ca6e:	68fb      	ldr	r3, [r7, #12]
    ca70:	627b      	str	r3, [r7, #36]	; 0x24
    Transaction.bContinue       = false;
    ca72:	2300      	movs	r3, #0
    ca74:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
    Transaction.ui32StatusSetClr = 0;
    ca78:	2300      	movs	r3, #0
    ca7a:	637b      	str	r3, [r7, #52]	; 0x34

    //
    // Start the transaction (no callback).
    //
    if (am_hal_iom_nonblocking_transfer(g_pMB85RS1MTIOMHandle, &Transaction, 0, 0))
    ca7c:	4b29      	ldr	r3, [pc, #164]	; (cb24 <am_devices_mb85rs1mt_nonblocking_write_adv+0xec>)
    ca7e:	6818      	ldr	r0, [r3, #0]
    ca80:	f107 0110 	add.w	r1, r7, #16
    ca84:	2300      	movs	r3, #0
    ca86:	2200      	movs	r2, #0
    ca88:	f003 f9a2 	bl	fdd0 <am_hal_iom_nonblocking_transfer>
    ca8c:	4603      	mov	r3, r0
    ca8e:	2b00      	cmp	r3, #0
    ca90:	d001      	beq.n	ca96 <am_devices_mb85rs1mt_nonblocking_write_adv+0x5e>
    {
        return AM_DEVICES_MB85RS1MT_STATUS_ERROR;
    ca92:	2301      	movs	r3, #1
    ca94:	e040      	b.n	cb18 <am_devices_mb85rs1mt_nonblocking_write_adv+0xe0>

    //
    // Set up the IOM transaction to write the FRAM command to the device.
    // This one needs to keep CE asserted (via continue).
    //
    Transaction.eDirection      = AM_HAL_IOM_TX;
    ca96:	2300      	movs	r3, #0
    ca98:	f887 3020 	strb.w	r3, [r7, #32]
    Transaction.ui32InstrLen    = 1;
    ca9c:	2301      	movs	r3, #1
    ca9e:	617b      	str	r3, [r7, #20]
    Transaction.ui32Instr       = AM_DEVICES_MB85RS1MT_WRITE;
    caa0:	2302      	movs	r3, #2
    caa2:	61bb      	str	r3, [r7, #24]
    Transaction.ui32NumBytes    = 0;
    caa4:	2300      	movs	r3, #0
    caa6:	61fb      	str	r3, [r7, #28]
    Transaction.pui32TxBuffer   = (uint32_t *)pui8TxBuffer;
    caa8:	68fb      	ldr	r3, [r7, #12]
    caaa:	627b      	str	r3, [r7, #36]	; 0x24
    Transaction.ui32PauseCondition = 0;
    caac:	2300      	movs	r3, #0
    caae:	633b      	str	r3, [r7, #48]	; 0x30
    Transaction.ui32StatusSetClr = 0;
    cab0:	2300      	movs	r3, #0
    cab2:	637b      	str	r3, [r7, #52]	; 0x34
    Transaction.bContinue       = true;
    cab4:	2301      	movs	r3, #1
    cab6:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c

    //
    // Start the transaction (no callback).
    //
    if (am_hal_iom_nonblocking_transfer(g_pMB85RS1MTIOMHandle, &Transaction, 0, 0))
    caba:	4b1a      	ldr	r3, [pc, #104]	; (cb24 <am_devices_mb85rs1mt_nonblocking_write_adv+0xec>)
    cabc:	6818      	ldr	r0, [r3, #0]
    cabe:	f107 0110 	add.w	r1, r7, #16
    cac2:	2300      	movs	r3, #0
    cac4:	2200      	movs	r2, #0
    cac6:	f003 f983 	bl	fdd0 <am_hal_iom_nonblocking_transfer>
    caca:	4603      	mov	r3, r0
    cacc:	2b00      	cmp	r3, #0
    cace:	d001      	beq.n	cad4 <am_devices_mb85rs1mt_nonblocking_write_adv+0x9c>
    {
        return AM_DEVICES_MB85RS1MT_STATUS_ERROR;
    cad0:	2301      	movs	r3, #1
    cad2:	e021      	b.n	cb18 <am_devices_mb85rs1mt_nonblocking_write_adv+0xe0>
    }

    //
    // Set up the IOM transaction to write the offset (address) and data.
    //
    Transaction.eDirection      = AM_HAL_IOM_TX;
    cad4:	2300      	movs	r3, #0
    cad6:	f887 3020 	strb.w	r3, [r7, #32]
    Transaction.ui32InstrLen    = 3;
    cada:	2303      	movs	r3, #3
    cadc:	617b      	str	r3, [r7, #20]
    Transaction.ui32Instr       = ui32WriteAddress & 0x00FFFFFF;
    cade:	68bb      	ldr	r3, [r7, #8]
    cae0:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    cae4:	61bb      	str	r3, [r7, #24]
    Transaction.ui32NumBytes    = ui32NumBytes;
    cae6:	687b      	ldr	r3, [r7, #4]
    cae8:	61fb      	str	r3, [r7, #28]
    Transaction.pui32TxBuffer   = (uint32_t *)pui8TxBuffer;
    caea:	68fb      	ldr	r3, [r7, #12]
    caec:	627b      	str	r3, [r7, #36]	; 0x24
    Transaction.bContinue       = false;
    caee:	2300      	movs	r3, #0
    caf0:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
    Transaction.ui32PauseCondition = 0;
    caf4:	2300      	movs	r3, #0
    caf6:	633b      	str	r3, [r7, #48]	; 0x30
    // Now set the post processing condition
    Transaction.ui32StatusSetClr = ui32StatusSetClr;
    caf8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    cafa:	637b      	str	r3, [r7, #52]	; 0x34

    //
    // Start the transaction
    //
    if (am_hal_iom_nonblocking_transfer(g_pMB85RS1MTIOMHandle, &Transaction, pfnCallback, pCallbackCtxt))
    cafc:	4b09      	ldr	r3, [pc, #36]	; (cb24 <am_devices_mb85rs1mt_nonblocking_write_adv+0xec>)
    cafe:	6818      	ldr	r0, [r3, #0]
    cb00:	f107 0110 	add.w	r1, r7, #16
    cb04:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    cb06:	6c7a      	ldr	r2, [r7, #68]	; 0x44
    cb08:	f003 f962 	bl	fdd0 <am_hal_iom_nonblocking_transfer>
    cb0c:	4603      	mov	r3, r0
    cb0e:	2b00      	cmp	r3, #0
    cb10:	d001      	beq.n	cb16 <am_devices_mb85rs1mt_nonblocking_write_adv+0xde>
    {
        return AM_DEVICES_MB85RS1MT_STATUS_ERROR;
    cb12:	2301      	movs	r3, #1
    cb14:	e000      	b.n	cb18 <am_devices_mb85rs1mt_nonblocking_write_adv+0xe0>
    // following the WRITE transaction

    //
    // Return the status.
    //
    return AM_DEVICES_MB85RS1MT_STATUS_SUCCESS;
    cb16:	2300      	movs	r3, #0
}
    cb18:	4618      	mov	r0, r3
    cb1a:	3738      	adds	r7, #56	; 0x38
    cb1c:	46bd      	mov	sp, r7
    cb1e:	bd80      	pop	{r7, pc}
    cb20:	100010ec 	.word	0x100010ec
    cb24:	100010e8 	.word	0x100010e8

0000cb28 <am_devices_mb85rs1mt_nonblocking_write>:
am_devices_mb85rs1mt_nonblocking_write(uint8_t *pui8TxBuffer,
                                       uint32_t ui32WriteAddress,
                                       uint32_t ui32NumBytes,
                                       am_hal_iom_callback_t pfnCallback,
                                       void *pCallbackCtxt)
{
    cb28:	b580      	push	{r7, lr}
    cb2a:	b088      	sub	sp, #32
    cb2c:	af04      	add	r7, sp, #16
    cb2e:	60f8      	str	r0, [r7, #12]
    cb30:	60b9      	str	r1, [r7, #8]
    cb32:	607a      	str	r2, [r7, #4]
    cb34:	603b      	str	r3, [r7, #0]
    //
    // Return the status.
    //
    return AM_DEVICES_MB85RS1MT_STATUS_SUCCESS;
#else
    return (am_devices_mb85rs1mt_nonblocking_write_adv(pui8TxBuffer,
    cb36:	69bb      	ldr	r3, [r7, #24]
    cb38:	9302      	str	r3, [sp, #8]
    cb3a:	683b      	ldr	r3, [r7, #0]
    cb3c:	9301      	str	r3, [sp, #4]
    cb3e:	2300      	movs	r3, #0
    cb40:	9300      	str	r3, [sp, #0]
    cb42:	2300      	movs	r3, #0
    cb44:	687a      	ldr	r2, [r7, #4]
    cb46:	68b9      	ldr	r1, [r7, #8]
    cb48:	68f8      	ldr	r0, [r7, #12]
    cb4a:	f7ff ff75 	bl	ca38 <am_devices_mb85rs1mt_nonblocking_write_adv>
    cb4e:	4603      	mov	r3, r0
                                                   ui32WriteAddress,
                                                   ui32NumBytes,
                                                   0, 0, pfnCallback, pCallbackCtxt));
#endif
}
    cb50:	4618      	mov	r0, r3
    cb52:	3710      	adds	r7, #16
    cb54:	46bd      	mov	sp, r7
    cb56:	bd80      	pop	{r7, pc}

0000cb58 <am_devices_mb85rs1mt_blocking_read>:
//*****************************************************************************
uint32_t
am_devices_mb85rs1mt_blocking_read(uint8_t *pui8RxBuffer,
                                   uint32_t ui32ReadAddress,
                                   uint32_t ui32NumBytes)
{
    cb58:	b580      	push	{r7, lr}
    cb5a:	b08e      	sub	sp, #56	; 0x38
    cb5c:	af00      	add	r7, sp, #0
    cb5e:	60f8      	str	r0, [r7, #12]
    cb60:	60b9      	str	r1, [r7, #8]
    cb62:	607a      	str	r2, [r7, #4]
    am_hal_iom_transfer_t Transaction;

    Transaction.ui8RepeatCount  = 0;
    cb64:	2300      	movs	r3, #0
    cb66:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
    Transaction.ui32PauseCondition       = 0;
    cb6a:	2300      	movs	r3, #0
    cb6c:	633b      	str	r3, [r7, #48]	; 0x30
    Transaction.ui32StatusSetClr = 0;
    cb6e:	2300      	movs	r3, #0
    cb70:	637b      	str	r3, [r7, #52]	; 0x34

    //
    // Write the command to the device.
    //
    Transaction.eDirection      = AM_HAL_IOM_TX;
    cb72:	2300      	movs	r3, #0
    cb74:	f887 3020 	strb.w	r3, [r7, #32]
    Transaction.ui32InstrLen    = 1;
    cb78:	2301      	movs	r3, #1
    cb7a:	617b      	str	r3, [r7, #20]
    Transaction.ui32Instr       = AM_DEVICES_MB85RS1MT_READ;
    cb7c:	2303      	movs	r3, #3
    cb7e:	61bb      	str	r3, [r7, #24]
    Transaction.ui32NumBytes    = 0;
    cb80:	2300      	movs	r3, #0
    cb82:	61fb      	str	r3, [r7, #28]
    Transaction.pui32TxBuffer   = (uint32_t *)pui8RxBuffer;
    cb84:	68fb      	ldr	r3, [r7, #12]
    cb86:	627b      	str	r3, [r7, #36]	; 0x24
    Transaction.uPeerInfo.ui32SpiChipSelect = g_MB85RS1MTCS;
    cb88:	4b1b      	ldr	r3, [pc, #108]	; (cbf8 <am_devices_mb85rs1mt_blocking_read+0xa0>)
    cb8a:	681b      	ldr	r3, [r3, #0]
    cb8c:	613b      	str	r3, [r7, #16]
    Transaction.bContinue       = true;
    cb8e:	2301      	movs	r3, #1
    cb90:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c

    //
    // Start the transaction.
    //
    if (am_hal_iom_blocking_transfer(g_pMB85RS1MTIOMHandle, &Transaction))
    cb94:	4b19      	ldr	r3, [pc, #100]	; (cbfc <am_devices_mb85rs1mt_blocking_read+0xa4>)
    cb96:	681b      	ldr	r3, [r3, #0]
    cb98:	f107 0210 	add.w	r2, r7, #16
    cb9c:	4611      	mov	r1, r2
    cb9e:	4618      	mov	r0, r3
    cba0:	f002 fe64 	bl	f86c <am_hal_iom_blocking_transfer>
    cba4:	4603      	mov	r3, r0
    cba6:	2b00      	cmp	r3, #0
    cba8:	d001      	beq.n	cbae <am_devices_mb85rs1mt_blocking_read+0x56>
    {
        return AM_DEVICES_MB85RS1MT_STATUS_ERROR;
    cbaa:	2301      	movs	r3, #1
    cbac:	e020      	b.n	cbf0 <am_devices_mb85rs1mt_blocking_read+0x98>
    }

    //
    // Set up the IOM transaction to write to the device with offset address.
    //
    Transaction.eDirection      = AM_HAL_IOM_RX;
    cbae:	2301      	movs	r3, #1
    cbb0:	f887 3020 	strb.w	r3, [r7, #32]
    Transaction.ui32InstrLen    = 3;
    cbb4:	2303      	movs	r3, #3
    cbb6:	617b      	str	r3, [r7, #20]
    Transaction.ui32Instr       = ui32ReadAddress & 0x00FFFFFF;
    cbb8:	68bb      	ldr	r3, [r7, #8]
    cbba:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    cbbe:	61bb      	str	r3, [r7, #24]
    Transaction.ui32NumBytes    = ui32NumBytes;
    cbc0:	687b      	ldr	r3, [r7, #4]
    cbc2:	61fb      	str	r3, [r7, #28]
    Transaction.pui32RxBuffer   = (uint32_t *)pui8RxBuffer;
    cbc4:	68fb      	ldr	r3, [r7, #12]
    cbc6:	62bb      	str	r3, [r7, #40]	; 0x28
    Transaction.uPeerInfo.ui32SpiChipSelect = g_MB85RS1MTCS;
    cbc8:	4b0b      	ldr	r3, [pc, #44]	; (cbf8 <am_devices_mb85rs1mt_blocking_read+0xa0>)
    cbca:	681b      	ldr	r3, [r3, #0]
    cbcc:	613b      	str	r3, [r7, #16]
    Transaction.bContinue       = false;
    cbce:	2300      	movs	r3, #0
    cbd0:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c

    //
    // Start the transaction.
    //
    if (am_hal_iom_blocking_transfer(g_pMB85RS1MTIOMHandle, &Transaction))
    cbd4:	4b09      	ldr	r3, [pc, #36]	; (cbfc <am_devices_mb85rs1mt_blocking_read+0xa4>)
    cbd6:	681b      	ldr	r3, [r3, #0]
    cbd8:	f107 0210 	add.w	r2, r7, #16
    cbdc:	4611      	mov	r1, r2
    cbde:	4618      	mov	r0, r3
    cbe0:	f002 fe44 	bl	f86c <am_hal_iom_blocking_transfer>
    cbe4:	4603      	mov	r3, r0
    cbe6:	2b00      	cmp	r3, #0
    cbe8:	d001      	beq.n	cbee <am_devices_mb85rs1mt_blocking_read+0x96>
    {
        return AM_DEVICES_MB85RS1MT_STATUS_ERROR;
    cbea:	2301      	movs	r3, #1
    cbec:	e000      	b.n	cbf0 <am_devices_mb85rs1mt_blocking_read+0x98>
    }

    //
    // Return the status.
    //
    return AM_DEVICES_MB85RS1MT_STATUS_SUCCESS;
    cbee:	2300      	movs	r3, #0
}
    cbf0:	4618      	mov	r0, r3
    cbf2:	3738      	adds	r7, #56	; 0x38
    cbf4:	46bd      	mov	sp, r7
    cbf6:	bd80      	pop	{r7, pc}
    cbf8:	100010ec 	.word	0x100010ec
    cbfc:	100010e8 	.word	0x100010e8

0000cc00 <am_devices_mb85rs1mt_nonblocking_read>:
am_devices_mb85rs1mt_nonblocking_read(uint8_t *pui8RxBuffer,
                                      uint32_t ui32ReadAddress,
                                      uint32_t ui32NumBytes,
                                      am_hal_iom_callback_t pfnCallback,
                                      void *pCallbackCtxt)
{
    cc00:	b580      	push	{r7, lr}
    cc02:	b08e      	sub	sp, #56	; 0x38
    cc04:	af00      	add	r7, sp, #0
    cc06:	60f8      	str	r0, [r7, #12]
    cc08:	60b9      	str	r1, [r7, #8]
    cc0a:	607a      	str	r2, [r7, #4]
    cc0c:	603b      	str	r3, [r7, #0]
    am_hal_iom_transfer_t      Transaction;

    Transaction.ui8RepeatCount  = 0;
    cc0e:	2300      	movs	r3, #0
    cc10:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
    Transaction.ui32PauseCondition = 0;
    cc14:	2300      	movs	r3, #0
    cc16:	633b      	str	r3, [r7, #48]	; 0x30
    Transaction.ui32StatusSetClr = 0;
    cc18:	2300      	movs	r3, #0
    cc1a:	637b      	str	r3, [r7, #52]	; 0x34

    //
    // Set up the IOM transaction to write the FRAM command to the device.
    // This one needs to keep CE asserted (via continue).
    //
    Transaction.eDirection      = AM_HAL_IOM_TX;
    cc1c:	2300      	movs	r3, #0
    cc1e:	f887 3020 	strb.w	r3, [r7, #32]
    Transaction.ui32InstrLen    = 1;
    cc22:	2301      	movs	r3, #1
    cc24:	617b      	str	r3, [r7, #20]
    Transaction.ui32Instr       = AM_DEVICES_MB85RS1MT_READ;
    cc26:	2303      	movs	r3, #3
    cc28:	61bb      	str	r3, [r7, #24]
    Transaction.ui32NumBytes    = 0;
    cc2a:	2300      	movs	r3, #0
    cc2c:	61fb      	str	r3, [r7, #28]
    Transaction.pui32TxBuffer   = (uint32_t *)pui8RxBuffer;
    cc2e:	68fb      	ldr	r3, [r7, #12]
    cc30:	627b      	str	r3, [r7, #36]	; 0x24
    Transaction.uPeerInfo.ui32SpiChipSelect = g_MB85RS1MTCS;
    cc32:	4b1d      	ldr	r3, [pc, #116]	; (cca8 <am_devices_mb85rs1mt_nonblocking_read+0xa8>)
    cc34:	681b      	ldr	r3, [r3, #0]
    cc36:	613b      	str	r3, [r7, #16]
    Transaction.bContinue       = true;
    cc38:	2301      	movs	r3, #1
    cc3a:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c

    //
    // Start the transaction (no callback).
    //
    if (am_hal_iom_nonblocking_transfer(g_pMB85RS1MTIOMHandle, &Transaction, 0, 0))
    cc3e:	4b1b      	ldr	r3, [pc, #108]	; (ccac <am_devices_mb85rs1mt_nonblocking_read+0xac>)
    cc40:	6818      	ldr	r0, [r3, #0]
    cc42:	f107 0110 	add.w	r1, r7, #16
    cc46:	2300      	movs	r3, #0
    cc48:	2200      	movs	r2, #0
    cc4a:	f003 f8c1 	bl	fdd0 <am_hal_iom_nonblocking_transfer>
    cc4e:	4603      	mov	r3, r0
    cc50:	2b00      	cmp	r3, #0
    cc52:	d001      	beq.n	cc58 <am_devices_mb85rs1mt_nonblocking_read+0x58>
    {
        return AM_DEVICES_MB85RS1MT_STATUS_ERROR;
    cc54:	2301      	movs	r3, #1
    cc56:	e023      	b.n	cca0 <am_devices_mb85rs1mt_nonblocking_read+0xa0>
    }

    //
    // Set up the IOM transaction.
    //
    Transaction.ui8Priority     = 1;        // High priority for now.
    cc58:	2301      	movs	r3, #1
    cc5a:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
    Transaction.eDirection      = AM_HAL_IOM_RX;
    cc5e:	2301      	movs	r3, #1
    cc60:	f887 3020 	strb.w	r3, [r7, #32]
    Transaction.ui32InstrLen    = 3;
    cc64:	2303      	movs	r3, #3
    cc66:	617b      	str	r3, [r7, #20]
    Transaction.ui32Instr       = ui32ReadAddress & 0x00FFFFFF;
    cc68:	68bb      	ldr	r3, [r7, #8]
    cc6a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    cc6e:	61bb      	str	r3, [r7, #24]
    Transaction.ui32NumBytes    = ui32NumBytes;
    cc70:	687b      	ldr	r3, [r7, #4]
    cc72:	61fb      	str	r3, [r7, #28]
    Transaction.pui32RxBuffer   = (uint32_t *)pui8RxBuffer;
    cc74:	68fb      	ldr	r3, [r7, #12]
    cc76:	62bb      	str	r3, [r7, #40]	; 0x28
    Transaction.uPeerInfo.ui32SpiChipSelect = g_MB85RS1MTCS;
    cc78:	4b0b      	ldr	r3, [pc, #44]	; (cca8 <am_devices_mb85rs1mt_nonblocking_read+0xa8>)
    cc7a:	681b      	ldr	r3, [r3, #0]
    cc7c:	613b      	str	r3, [r7, #16]
    Transaction.bContinue       = false;
    cc7e:	2300      	movs	r3, #0
    cc80:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c

    //
    // Start the transaction.
    //
    if (am_hal_iom_nonblocking_transfer(g_pMB85RS1MTIOMHandle, &Transaction, pfnCallback, pCallbackCtxt))
    cc84:	4b09      	ldr	r3, [pc, #36]	; (ccac <am_devices_mb85rs1mt_nonblocking_read+0xac>)
    cc86:	6818      	ldr	r0, [r3, #0]
    cc88:	f107 0110 	add.w	r1, r7, #16
    cc8c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    cc8e:	683a      	ldr	r2, [r7, #0]
    cc90:	f003 f89e 	bl	fdd0 <am_hal_iom_nonblocking_transfer>
    cc94:	4603      	mov	r3, r0
    cc96:	2b00      	cmp	r3, #0
    cc98:	d001      	beq.n	cc9e <am_devices_mb85rs1mt_nonblocking_read+0x9e>
    {
        return AM_DEVICES_MB85RS1MT_STATUS_ERROR;
    cc9a:	2301      	movs	r3, #1
    cc9c:	e000      	b.n	cca0 <am_devices_mb85rs1mt_nonblocking_read+0xa0>
    }

    //
    // Return the status.
    //
    return AM_DEVICES_MB85RS1MT_STATUS_SUCCESS;
    cc9e:	2300      	movs	r3, #0
}
    cca0:	4618      	mov	r0, r3
    cca2:	3738      	adds	r7, #56	; 0x38
    cca4:	46bd      	mov	sp, r7
    cca6:	bd80      	pop	{r7, pc}
    cca8:	100010ec 	.word	0x100010ec
    ccac:	100010e8 	.word	0x100010e8

0000ccb0 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
    ccb0:	b480      	push	{r7}
    ccb2:	b083      	sub	sp, #12
    ccb4:	af00      	add	r7, sp, #0
    ccb6:	4603      	mov	r3, r0
    ccb8:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
    ccba:	f997 3007 	ldrsb.w	r3, [r7, #7]
    ccbe:	2b00      	cmp	r3, #0
    ccc0:	db0b      	blt.n	ccda <__NVIC_EnableIRQ+0x2a>
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    ccc2:	4909      	ldr	r1, [pc, #36]	; (cce8 <__NVIC_EnableIRQ+0x38>)
    ccc4:	f997 3007 	ldrsb.w	r3, [r7, #7]
    ccc8:	095b      	lsrs	r3, r3, #5
    ccca:	79fa      	ldrb	r2, [r7, #7]
    cccc:	f002 021f 	and.w	r2, r2, #31
    ccd0:	2001      	movs	r0, #1
    ccd2:	fa00 f202 	lsl.w	r2, r0, r2
    ccd6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
    ccda:	bf00      	nop
    ccdc:	370c      	adds	r7, #12
    ccde:	46bd      	mov	sp, r7
    cce0:	f85d 7b04 	ldr.w	r7, [sp], #4
    cce4:	4770      	bx	lr
    cce6:	bf00      	nop
    cce8:	e000e100 	.word	0xe000e100

0000ccec <__NVIC_DisableIRQ>:
  \details Disables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
    ccec:	b480      	push	{r7}
    ccee:	b083      	sub	sp, #12
    ccf0:	af00      	add	r7, sp, #0
    ccf2:	4603      	mov	r3, r0
    ccf4:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
    ccf6:	f997 3007 	ldrsb.w	r3, [r7, #7]
    ccfa:	2b00      	cmp	r3, #0
    ccfc:	db10      	blt.n	cd20 <__NVIC_DisableIRQ+0x34>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    ccfe:	490b      	ldr	r1, [pc, #44]	; (cd2c <__NVIC_DisableIRQ+0x40>)
    cd00:	f997 3007 	ldrsb.w	r3, [r7, #7]
    cd04:	095b      	lsrs	r3, r3, #5
    cd06:	79fa      	ldrb	r2, [r7, #7]
    cd08:	f002 021f 	and.w	r2, r2, #31
    cd0c:	2001      	movs	r0, #1
    cd0e:	fa00 f202 	lsl.w	r2, r0, r2
    cd12:	3320      	adds	r3, #32
    cd14:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    cd18:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    cd1c:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
  }
}
    cd20:	bf00      	nop
    cd22:	370c      	adds	r7, #12
    cd24:	46bd      	mov	sp, r7
    cd26:	f85d 7b04 	ldr.w	r7, [sp], #4
    cd2a:	4770      	bx	lr
    cd2c:	e000e100 	.word	0xe000e100

0000cd30 <timerA0_init>:
// Function to initialize Timer A0 to interrupt every 1 second.
//
//*****************************************************************************
void
timerA0_init(void)
{
    cd30:	b580      	push	{r7, lr}
    cd32:	b082      	sub	sp, #8
    cd34:	af00      	add	r7, sp, #0
    uint32_t ui32Period;

    //
    // Enable the LFRC.
    //
    am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_LFRC_START, 0);
    cd36:	2100      	movs	r1, #0
    cd38:	2002      	movs	r0, #2
    cd3a:	f001 fc33 	bl	e5a4 <am_hal_clkgen_control>

    //
    // Set up timer A0.
    //
    am_hal_ctimer_clear(0, AM_HAL_CTIMER_TIMERA);
    cd3e:	f64f 71ff 	movw	r1, #65535	; 0xffff
    cd42:	2000      	movs	r0, #0
    cd44:	f001 fdae 	bl	e8a4 <am_hal_ctimer_clear>
    am_hal_ctimer_config(0, &g_sTimer0);
    cd48:	490a      	ldr	r1, [pc, #40]	; (cd74 <timerA0_init+0x44>)
    cd4a:	2000      	movs	r0, #0
    cd4c:	f001 fd76 	bl	e83c <am_hal_ctimer_config>

    //
    // Set up timerA0 to 32Hz from LFRC divided to 1 second period.
    //
    ui32Period = 32;
    cd50:	2320      	movs	r3, #32
    cd52:	607b      	str	r3, [r7, #4]
    am_hal_ctimer_period_set(0, AM_HAL_CTIMER_TIMERA, ui32Period,
    cd54:	687b      	ldr	r3, [r7, #4]
    cd56:	085b      	lsrs	r3, r3, #1
    cd58:	687a      	ldr	r2, [r7, #4]
    cd5a:	f64f 71ff 	movw	r1, #65535	; 0xffff
    cd5e:	2000      	movs	r0, #0
    cd60:	f001 fdb4 	bl	e8cc <am_hal_ctimer_period_set>
                             (ui32Period >> 1));

    //
    // Clear the timer Interrupt
    //
    am_hal_ctimer_int_clear(AM_HAL_CTIMER_INT_TIMERA0);
    cd64:	2001      	movs	r0, #1
    cd66:	f001 fe33 	bl	e9d0 <am_hal_ctimer_int_clear>
}
    cd6a:	bf00      	nop
    cd6c:	3708      	adds	r7, #8
    cd6e:	46bd      	mov	sp, r7
    cd70:	bd80      	pop	{r7, pc}
    cd72:	bf00      	nop
    cd74:	10001074 	.word	0x10001074

0000cd78 <am_ctimer_isr>:
// Timer Interrupt Service Routine (ISR)
//
//*****************************************************************************
void
am_ctimer_isr(void)
{
    cd78:	b580      	push	{r7, lr}
    cd7a:	b082      	sub	sp, #8
    cd7c:	af00      	add	r7, sp, #0
    uint32_t ui32Status;

    ui32Status = am_hal_ctimer_int_status_get(true);
    cd7e:	2001      	movs	r0, #1
    cd80:	f001 fe36 	bl	e9f0 <am_hal_ctimer_int_status_get>
    cd84:	6078      	str	r0, [r7, #4]

    if ( ui32Status )
    cd86:	687b      	ldr	r3, [r7, #4]
    cd88:	2b00      	cmp	r3, #0
    cd8a:	d005      	beq.n	cd98 <am_ctimer_isr+0x20>
    {
        am_hal_ctimer_int_clear(ui32Status);
    cd8c:	6878      	ldr	r0, [r7, #4]
    cd8e:	f001 fe1f 	bl	e9d0 <am_hal_ctimer_int_clear>
        am_hal_ctimer_int_service(ui32Status);
    cd92:	6878      	ldr	r0, [r7, #4]
    cd94:	f001 fc80 	bl	e698 <am_hal_ctimer_int_service>
    }
}
    cd98:	bf00      	nop
    cd9a:	3708      	adds	r7, #8
    cd9c:	46bd      	mov	sp, r7
    cd9e:	bd80      	pop	{r7, pc}

0000cda0 <am_iomaster0_isr>:
//*****************************************************************************
//
//! Take over default ISR. (Queue mode service)
//
void fram_iom_isr(void)
{
    cda0:	b580      	push	{r7, lr}
    cda2:	b082      	sub	sp, #8
    cda4:	af00      	add	r7, sp, #0
    uint32_t ui32Status;

    if (!am_hal_iom_interrupt_status_get(g_pIOMHandle, true, &ui32Status))
    cda6:	4b0f      	ldr	r3, [pc, #60]	; (cde4 <am_iomaster0_isr+0x44>)
    cda8:	681b      	ldr	r3, [r3, #0]
    cdaa:	1d3a      	adds	r2, r7, #4
    cdac:	2101      	movs	r1, #1
    cdae:	4618      	mov	r0, r3
    cdb0:	f002 fa5a 	bl	f268 <am_hal_iom_interrupt_status_get>
    cdb4:	4603      	mov	r3, r0
    cdb6:	2b00      	cmp	r3, #0
    cdb8:	d110      	bne.n	cddc <am_iomaster0_isr+0x3c>
    {
        if ( ui32Status )
    cdba:	687b      	ldr	r3, [r7, #4]
    cdbc:	2b00      	cmp	r3, #0
    cdbe:	d00d      	beq.n	cddc <am_iomaster0_isr+0x3c>
        {
            am_hal_iom_interrupt_clear(g_pIOMHandle, ui32Status);
    cdc0:	4b08      	ldr	r3, [pc, #32]	; (cde4 <am_iomaster0_isr+0x44>)
    cdc2:	681b      	ldr	r3, [r3, #0]
    cdc4:	687a      	ldr	r2, [r7, #4]
    cdc6:	4611      	mov	r1, r2
    cdc8:	4618      	mov	r0, r3
    cdca:	f002 fa6f 	bl	f2ac <am_hal_iom_interrupt_clear>
            am_hal_iom_interrupt_service(g_pIOMHandle, ui32Status);
    cdce:	4b05      	ldr	r3, [pc, #20]	; (cde4 <am_iomaster0_isr+0x44>)
    cdd0:	681b      	ldr	r3, [r3, #0]
    cdd2:	687a      	ldr	r2, [r7, #4]
    cdd4:	4611      	mov	r1, r2
    cdd6:	4618      	mov	r0, r3
    cdd8:	f002 fa7c 	bl	f2d4 <am_hal_iom_interrupt_service>
        }
    }
}
    cddc:	bf00      	nop
    cdde:	3708      	adds	r7, #8
    cde0:	46bd      	mov	sp, r7
    cde2:	bd80      	pop	{r7, pc}
    cde4:	1000143c 	.word	0x1000143c

0000cde8 <init_pattern>:

void
init_pattern(void)
{
    cde8:	b480      	push	{r7}
    cdea:	b083      	sub	sp, #12
    cdec:	af00      	add	r7, sp, #0
    uint32_t i;
    for (i = 0; i < PATTERN_BUF_SIZE; i++)
    cdee:	2300      	movs	r3, #0
    cdf0:	607b      	str	r3, [r7, #4]
    cdf2:	e009      	b.n	ce08 <init_pattern+0x20>
    {
        gPatternBuf.bytes[i] = i & 0xFF;
    cdf4:	687b      	ldr	r3, [r7, #4]
    cdf6:	b2d9      	uxtb	r1, r3
    cdf8:	4a08      	ldr	r2, [pc, #32]	; (ce1c <init_pattern+0x34>)
    cdfa:	687b      	ldr	r3, [r7, #4]
    cdfc:	4413      	add	r3, r2
    cdfe:	460a      	mov	r2, r1
    ce00:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < PATTERN_BUF_SIZE; i++)
    ce02:	687b      	ldr	r3, [r7, #4]
    ce04:	3301      	adds	r3, #1
    ce06:	607b      	str	r3, [r7, #4]
    ce08:	687b      	ldr	r3, [r7, #4]
    ce0a:	2b7f      	cmp	r3, #127	; 0x7f
    ce0c:	d9f2      	bls.n	cdf4 <init_pattern+0xc>
    }
}
    ce0e:	bf00      	nop
    ce10:	370c      	adds	r7, #12
    ce12:	46bd      	mov	sp, r7
    ce14:	f85d 7b04 	ldr.w	r7, [sp], #4
    ce18:	4770      	bx	lr
    ce1a:	bf00      	nop
    ce1c:	100013bc 	.word	0x100013bc

0000ce20 <fram_init>:

int
fram_init(void)
{
    ce20:	b580      	push	{r7, lr}
    ce22:	b084      	sub	sp, #16
    ce24:	af00      	add	r7, sp, #0
    uint32_t ui32Status;
    uint32_t ui32DeviceId;

    // Set up IOM
    // Initialize the Device
    g_sIomCfg.ui32NBTxnBufLength = sizeof(DMATCBBuffer) / 4;
    ce26:	4b44      	ldr	r3, [pc, #272]	; (cf38 <fram_init+0x118>)
    ce28:	f44f 7280 	mov.w	r2, #256	; 0x100
    ce2c:	611a      	str	r2, [r3, #16]
    g_sIomCfg.pNBTxnBuf = &DMATCBBuffer[0];
    ce2e:	4b42      	ldr	r3, [pc, #264]	; (cf38 <fram_init+0x118>)
    ce30:	4a42      	ldr	r2, [pc, #264]	; (cf3c <fram_init+0x11c>)
    ce32:	60da      	str	r2, [r3, #12]

#if 1
    //
    // Get Fireball ID and Rev info.
    //
    ui32Ret = am_devices_fireball_control(AM_DEVICES_FIREBALL_STATE_ID_GET, &ui32ID);
    ce34:	463b      	mov	r3, r7
    ce36:	4619      	mov	r1, r3
    ce38:	2001      	movs	r0, #1
    ce3a:	f7ff fb1f 	bl	c47c <am_devices_fireball_control>
    ce3e:	60f8      	str	r0, [r7, #12]
    if ( ui32Ret != 0 )
    ce40:	68fb      	ldr	r3, [r7, #12]
    ce42:	2b00      	cmp	r3, #0
    ce44:	d007      	beq.n	ce56 <fram_init+0x36>
    {
        am_util_stdio_printf("FAIL: am_devices_fireball_control(%d) returned 0x%X.\n",
    ce46:	68fa      	ldr	r2, [r7, #12]
    ce48:	2101      	movs	r1, #1
    ce4a:	483d      	ldr	r0, [pc, #244]	; (cf40 <fram_init+0x120>)
    ce4c:	f001 f8ee 	bl	e02c <am_util_stdio_printf>
                             AM_DEVICES_FIREBALL_STATE_ID_GET, ui32Ret);
        return -1;
    ce50:	f04f 33ff 	mov.w	r3, #4294967295
    ce54:	e06b      	b.n	cf2e <fram_init+0x10e>
    }
    else if ( ui32ID == FIREBALL_ID )
    ce56:	683b      	ldr	r3, [r7, #0]
    ce58:	f247 7210 	movw	r2, #30480	; 0x7710
    ce5c:	4293      	cmp	r3, r2
    ce5e:	d105      	bne.n	ce6c <fram_init+0x4c>
    {
        am_util_stdio_printf("Fireball found, ID is 0x%X.\n", ui32ID);
    ce60:	683b      	ldr	r3, [r7, #0]
    ce62:	4619      	mov	r1, r3
    ce64:	4837      	ldr	r0, [pc, #220]	; (cf44 <fram_init+0x124>)
    ce66:	f001 f8e1 	bl	e02c <am_util_stdio_printf>
    ce6a:	e004      	b.n	ce76 <fram_init+0x56>
    }
    else
    {
        am_util_stdio_printf("Unknown device returned ID as 0x%X.\n", ui32ID);
    ce6c:	683b      	ldr	r3, [r7, #0]
    ce6e:	4619      	mov	r1, r3
    ce70:	4835      	ldr	r0, [pc, #212]	; (cf48 <fram_init+0x128>)
    ce72:	f001 f8db 	bl	e02c <am_util_stdio_printf>
    }

    ui32Ret = am_devices_fireball_control(AM_DEVICES_FIREBALL_STATE_VER_GET, &ui32ID);
    ce76:	463b      	mov	r3, r7
    ce78:	4619      	mov	r1, r3
    ce7a:	2002      	movs	r0, #2
    ce7c:	f7ff fafe 	bl	c47c <am_devices_fireball_control>
    ce80:	60f8      	str	r0, [r7, #12]
    if ( ui32Ret != 0 )
    ce82:	68fb      	ldr	r3, [r7, #12]
    ce84:	2b00      	cmp	r3, #0
    ce86:	d007      	beq.n	ce98 <fram_init+0x78>
    {
        am_util_stdio_printf("FAIL: am_devices_fireball_control(%d) returned 0x%X.\n",
    ce88:	68fa      	ldr	r2, [r7, #12]
    ce8a:	2102      	movs	r1, #2
    ce8c:	482c      	ldr	r0, [pc, #176]	; (cf40 <fram_init+0x120>)
    ce8e:	f001 f8cd 	bl	e02c <am_util_stdio_printf>
                             AM_DEVICES_FIREBALL_STATE_VER_GET, ui32Ret);
        return -1;
    ce92:	f04f 33ff 	mov.w	r3, #4294967295
    ce96:	e04a      	b.n	cf2e <fram_init+0x10e>
    }
    else
    {
        am_util_stdio_printf("Fireball Version is 0x%X.\n", ui32ID);
    ce98:	683b      	ldr	r3, [r7, #0]
    ce9a:	4619      	mov	r1, r3
    ce9c:	482b      	ldr	r0, [pc, #172]	; (cf4c <fram_init+0x12c>)
    ce9e:	f001 f8c5 	bl	e02c <am_util_stdio_printf>
    }
#endif

    if ( device_func.fram_fireball_control != 0 )
    cea2:	4b2b      	ldr	r3, [pc, #172]	; (cf50 <fram_init+0x130>)
    cea4:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
    cea8:	2b00      	cmp	r3, #0
    ceaa:	d015      	beq.n	ced8 <fram_init+0xb8>
    {
        ui32Ret = am_devices_fireball_control(device_func.fram_fireball_control, 0);
    ceac:	4b28      	ldr	r3, [pc, #160]	; (cf50 <fram_init+0x130>)
    ceae:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
    ceb2:	2100      	movs	r1, #0
    ceb4:	4618      	mov	r0, r3
    ceb6:	f7ff fae1 	bl	c47c <am_devices_fireball_control>
    ceba:	60f8      	str	r0, [r7, #12]
        if ( ui32Ret != 0 )
    cebc:	68fb      	ldr	r3, [r7, #12]
    cebe:	2b00      	cmp	r3, #0
    cec0:	d00a      	beq.n	ced8 <fram_init+0xb8>
        {
            am_util_stdio_printf("FAIL: am_devices_fireball_control(%d) returned 0x%X.\n",
                                 device_func.fram_fireball_control, ui32Ret);
    cec2:	4b23      	ldr	r3, [pc, #140]	; (cf50 <fram_init+0x130>)
    cec4:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
            am_util_stdio_printf("FAIL: am_devices_fireball_control(%d) returned 0x%X.\n",
    cec8:	68fa      	ldr	r2, [r7, #12]
    ceca:	4619      	mov	r1, r3
    cecc:	481c      	ldr	r0, [pc, #112]	; (cf40 <fram_init+0x120>)
    cece:	f001 f8ad 	bl	e02c <am_util_stdio_printf>
            return -1;
    ced2:	f04f 33ff 	mov.w	r3, #4294967295
    ced6:	e02a      	b.n	cf2e <fram_init+0x10e>
        }
    }
#endif // FIREBALL_CARD

    ui32Status = device_func.fram_init(FRAM_IOM_MODULE, &g_sIomCfg, &g_pIOMHandle);
    ced8:	4b1d      	ldr	r3, [pc, #116]	; (cf50 <fram_init+0x130>)
    ceda:	695b      	ldr	r3, [r3, #20]
    cedc:	4a1d      	ldr	r2, [pc, #116]	; (cf54 <fram_init+0x134>)
    cede:	4916      	ldr	r1, [pc, #88]	; (cf38 <fram_init+0x118>)
    cee0:	2000      	movs	r0, #0
    cee2:	4798      	blx	r3
    cee4:	60b8      	str	r0, [r7, #8]
    if (0 == ui32Status)
    cee6:	68bb      	ldr	r3, [r7, #8]
    cee8:	2b00      	cmp	r3, #0
    ceea:	d11e      	bne.n	cf2a <fram_init+0x10a>
    {
        ui32Status = device_func.fram_read_id(&ui32DeviceId);
    ceec:	4b18      	ldr	r3, [pc, #96]	; (cf50 <fram_init+0x130>)
    ceee:	69db      	ldr	r3, [r3, #28]
    cef0:	1d3a      	adds	r2, r7, #4
    cef2:	4610      	mov	r0, r2
    cef4:	4798      	blx	r3
    cef6:	60b8      	str	r0, [r7, #8]

        if ((ui32Status  != 0) || (ui32DeviceId != FRAM_DEVICE_ID))
    cef8:	68bb      	ldr	r3, [r7, #8]
    cefa:	2b00      	cmp	r3, #0
    cefc:	d103      	bne.n	cf06 <fram_init+0xe6>
    cefe:	687b      	ldr	r3, [r7, #4]
    cf00:	4a15      	ldr	r2, [pc, #84]	; (cf58 <fram_init+0x138>)
    cf02:	4293      	cmp	r3, r2
    cf04:	d002      	beq.n	cf0c <fram_init+0xec>
        {
            return -1;
    cf06:	f04f 33ff 	mov.w	r3, #4294967295
    cf0a:	e010      	b.n	cf2e <fram_init+0x10e>
        }
        am_util_stdio_printf("%s Found\n", device_func.devName);
    cf0c:	4910      	ldr	r1, [pc, #64]	; (cf50 <fram_init+0x130>)
    cf0e:	4813      	ldr	r0, [pc, #76]	; (cf5c <fram_init+0x13c>)
    cf10:	f001 f88c 	bl	e02c <am_util_stdio_printf>
        // Set up a pattern data in FRAM memory
        am_util_stdio_printf("Setting up data pattern in FRAM using blocking write\n");
    cf14:	4812      	ldr	r0, [pc, #72]	; (cf60 <fram_init+0x140>)
    cf16:	f001 f889 	bl	e02c <am_util_stdio_printf>
        return device_func.fram_blocking_write(&gPatternBuf.bytes[0], 0, PATTERN_BUF_SIZE);
    cf1a:	4b0d      	ldr	r3, [pc, #52]	; (cf50 <fram_init+0x130>)
    cf1c:	6a1b      	ldr	r3, [r3, #32]
    cf1e:	2280      	movs	r2, #128	; 0x80
    cf20:	2100      	movs	r1, #0
    cf22:	4810      	ldr	r0, [pc, #64]	; (cf64 <fram_init+0x144>)
    cf24:	4798      	blx	r3
    cf26:	4603      	mov	r3, r0
    cf28:	e001      	b.n	cf2e <fram_init+0x10e>
    }
    else
    {
        return -1;
    cf2a:	f04f 33ff 	mov.w	r3, #4294967295
    }
}
    cf2e:	4618      	mov	r0, r3
    cf30:	3710      	adds	r7, #16
    cf32:	46bd      	mov	sp, r7
    cf34:	bd80      	pop	{r7, pc}
    cf36:	bf00      	nop
    cf38:	10001080 	.word	0x10001080
    cf3c:	10001440 	.word	0x10001440
    cf40:	000108a4 	.word	0x000108a4
    cf44:	000108dc 	.word	0x000108dc
    cf48:	000108fc 	.word	0x000108fc
    cf4c:	00010924 	.word	0x00010924
    cf50:	10001040 	.word	0x10001040
    cf54:	1000143c 	.word	0x1000143c
    cf58:	03277f04 	.word	0x03277f04
    cf5c:	00010940 	.word	0x00010940
    cf60:	0001094c 	.word	0x0001094c
    cf64:	100013bc 	.word	0x100013bc

0000cf68 <read_complete>:

void
read_complete(void *pCallbackCtxt, uint32_t transactionStatus)
{
    cf68:	b580      	push	{r7, lr}
    cf6a:	b082      	sub	sp, #8
    cf6c:	af00      	add	r7, sp, #0
    cf6e:	6078      	str	r0, [r7, #4]
    cf70:	6039      	str	r1, [r7, #0]
    if (transactionStatus != AM_HAL_STATUS_SUCCESS)
    cf72:	683b      	ldr	r3, [r7, #0]
    cf74:	2b00      	cmp	r3, #0
    cf76:	d004      	beq.n	cf82 <read_complete+0x1a>
    {
        am_util_stdio_printf("\nFRAM Read Failed 0x%x\n", transactionStatus);
    cf78:	6839      	ldr	r1, [r7, #0]
    cf7a:	4807      	ldr	r0, [pc, #28]	; (cf98 <read_complete+0x30>)
    cf7c:	f001 f856 	bl	e02c <am_util_stdio_printf>
    else
    {
        am_util_stdio_printf(".");
        g_bVerifyReadData = true;
    }
}
    cf80:	e005      	b.n	cf8e <read_complete+0x26>
        am_util_stdio_printf(".");
    cf82:	4806      	ldr	r0, [pc, #24]	; (cf9c <read_complete+0x34>)
    cf84:	f001 f852 	bl	e02c <am_util_stdio_printf>
        g_bVerifyReadData = true;
    cf88:	4b05      	ldr	r3, [pc, #20]	; (cfa0 <read_complete+0x38>)
    cf8a:	2201      	movs	r2, #1
    cf8c:	701a      	strb	r2, [r3, #0]
}
    cf8e:	bf00      	nop
    cf90:	3708      	adds	r7, #8
    cf92:	46bd      	mov	sp, r7
    cf94:	bd80      	pop	{r7, pc}
    cf96:	bf00      	nop
    cf98:	00010984 	.word	0x00010984
    cf9c:	0001099c 	.word	0x0001099c
    cfa0:	100010f1 	.word	0x100010f1

0000cfa4 <initiate_fram_read>:

void
initiate_fram_read(void)
{
    cfa4:	b480      	push	{r7}
    cfa6:	af00      	add	r7, sp, #0
    g_bReadFram = true;
    cfa8:	4b03      	ldr	r3, [pc, #12]	; (cfb8 <initiate_fram_read+0x14>)
    cfaa:	2201      	movs	r2, #1
    cfac:	701a      	strb	r2, [r3, #0]
}
    cfae:	bf00      	nop
    cfb0:	46bd      	mov	sp, r7
    cfb2:	f85d 7b04 	ldr.w	r7, [sp], #4
    cfb6:	4770      	bx	lr
    cfb8:	100010f0 	.word	0x100010f0

0000cfbc <verify_fram_data>:

int
verify_fram_data(void)
{
    cfbc:	b580      	push	{r7, lr}
    cfbe:	b082      	sub	sp, #8
    cfc0:	af00      	add	r7, sp, #0
    uint32_t i;
    g_bVerifyReadData = false;
    cfc2:	4b16      	ldr	r3, [pc, #88]	; (d01c <verify_fram_data+0x60>)
    cfc4:	2200      	movs	r2, #0
    cfc6:	701a      	strb	r2, [r3, #0]
    // Verify Read FRAM data
    for (i = 0; i < PATTERN_BUF_SIZE; i++)
    cfc8:	2300      	movs	r3, #0
    cfca:	607b      	str	r3, [r7, #4]
    cfcc:	e01d      	b.n	d00a <verify_fram_data+0x4e>
    {
        if (gPatternBuf.bytes[i] != gRxBuf.bytes[i])
    cfce:	4a14      	ldr	r2, [pc, #80]	; (d020 <verify_fram_data+0x64>)
    cfd0:	687b      	ldr	r3, [r7, #4]
    cfd2:	4413      	add	r3, r2
    cfd4:	781a      	ldrb	r2, [r3, #0]
    cfd6:	4913      	ldr	r1, [pc, #76]	; (d024 <verify_fram_data+0x68>)
    cfd8:	687b      	ldr	r3, [r7, #4]
    cfda:	440b      	add	r3, r1
    cfdc:	781b      	ldrb	r3, [r3, #0]
    cfde:	429a      	cmp	r2, r3
    cfe0:	d010      	beq.n	d004 <verify_fram_data+0x48>
        {
            am_util_stdio_printf("Receive Data Compare failed at offset %d - Expected = 0x%x, Received = 0x%x\n",
                i, gPatternBuf.bytes[i], gRxBuf.bytes[i]);
    cfe2:	4a0f      	ldr	r2, [pc, #60]	; (d020 <verify_fram_data+0x64>)
    cfe4:	687b      	ldr	r3, [r7, #4]
    cfe6:	4413      	add	r3, r2
    cfe8:	781b      	ldrb	r3, [r3, #0]
            am_util_stdio_printf("Receive Data Compare failed at offset %d - Expected = 0x%x, Received = 0x%x\n",
    cfea:	4619      	mov	r1, r3
                i, gPatternBuf.bytes[i], gRxBuf.bytes[i]);
    cfec:	4a0d      	ldr	r2, [pc, #52]	; (d024 <verify_fram_data+0x68>)
    cfee:	687b      	ldr	r3, [r7, #4]
    cff0:	4413      	add	r3, r2
    cff2:	781b      	ldrb	r3, [r3, #0]
            am_util_stdio_printf("Receive Data Compare failed at offset %d - Expected = 0x%x, Received = 0x%x\n",
    cff4:	460a      	mov	r2, r1
    cff6:	6879      	ldr	r1, [r7, #4]
    cff8:	480b      	ldr	r0, [pc, #44]	; (d028 <verify_fram_data+0x6c>)
    cffa:	f001 f817 	bl	e02c <am_util_stdio_printf>
            return -1;
    cffe:	f04f 33ff 	mov.w	r3, #4294967295
    d002:	e006      	b.n	d012 <verify_fram_data+0x56>
    for (i = 0; i < PATTERN_BUF_SIZE; i++)
    d004:	687b      	ldr	r3, [r7, #4]
    d006:	3301      	adds	r3, #1
    d008:	607b      	str	r3, [r7, #4]
    d00a:	687b      	ldr	r3, [r7, #4]
    d00c:	2b7f      	cmp	r3, #127	; 0x7f
    d00e:	d9de      	bls.n	cfce <verify_fram_data+0x12>
        }
    }
    return 0;
    d010:	2300      	movs	r3, #0
}
    d012:	4618      	mov	r0, r3
    d014:	3708      	adds	r7, #8
    d016:	46bd      	mov	sp, r7
    d018:	bd80      	pop	{r7, pc}
    d01a:	bf00      	nop
    d01c:	100010f1 	.word	0x100010f1
    d020:	100013bc 	.word	0x100013bc
    d024:	1000133c 	.word	0x1000133c
    d028:	000109a0 	.word	0x000109a0

0000d02c <read_fram>:

void
read_fram(void)
{
    d02c:	b590      	push	{r4, r7, lr}
    d02e:	b085      	sub	sp, #20
    d030:	af02      	add	r7, sp, #8
    uint32_t ui32Status;
    // Initiate read of a block of data from FRAM
    ui32Status = device_func.fram_nonblocking_read(&gRxBuf.bytes[0], 0, PATTERN_BUF_SIZE, read_complete, 0);
    d032:	4b0a      	ldr	r3, [pc, #40]	; (d05c <read_fram+0x30>)
    d034:	6adc      	ldr	r4, [r3, #44]	; 0x2c
    d036:	2300      	movs	r3, #0
    d038:	9300      	str	r3, [sp, #0]
    d03a:	4b09      	ldr	r3, [pc, #36]	; (d060 <read_fram+0x34>)
    d03c:	2280      	movs	r2, #128	; 0x80
    d03e:	2100      	movs	r1, #0
    d040:	4808      	ldr	r0, [pc, #32]	; (d064 <read_fram+0x38>)
    d042:	47a0      	blx	r4
    d044:	6078      	str	r0, [r7, #4]
    if (ui32Status == 0)
    d046:	687b      	ldr	r3, [r7, #4]
    d048:	2b00      	cmp	r3, #0
    d04a:	d102      	bne.n	d052 <read_fram+0x26>
    {
        g_bReadFram = false;
    d04c:	4b06      	ldr	r3, [pc, #24]	; (d068 <read_fram+0x3c>)
    d04e:	2200      	movs	r2, #0
    d050:	701a      	strb	r2, [r3, #0]
    }
}
    d052:	bf00      	nop
    d054:	370c      	adds	r7, #12
    d056:	46bd      	mov	sp, r7
    d058:	bd90      	pop	{r4, r7, pc}
    d05a:	bf00      	nop
    d05c:	10001040 	.word	0x10001040
    d060:	0000cf69 	.word	0x0000cf69
    d064:	1000133c 	.word	0x1000133c
    d068:	100010f0 	.word	0x100010f0

0000d06c <fram_term>:

void
fram_term(void)
{
    d06c:	b580      	push	{r7, lr}
    d06e:	af00      	add	r7, sp, #0
    device_func.fram_term(FRAM_IOM_MODULE);
    d070:	4b02      	ldr	r3, [pc, #8]	; (d07c <fram_term+0x10>)
    d072:	699b      	ldr	r3, [r3, #24]
    d074:	2000      	movs	r0, #0
    d076:	4798      	blx	r3
}
    d078:	bf00      	nop
    d07a:	bd80      	pop	{r7, pc}
    d07c:	10001040 	.word	0x10001040

0000d080 <main>:
// Main function.
//
//*****************************************************************************
int
main(void)
{
    d080:	b580      	push	{r7, lr}
    d082:	b084      	sub	sp, #16
    d084:	af00      	add	r7, sp, #0
    int iRet;
    uint32_t numRead = 0;
    d086:	2300      	movs	r3, #0
    d088:	60fb      	str	r3, [r7, #12]
    //
    // Set the clock frequency.
    //
    am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_SYSCLK_MAX, 0);
    d08a:	2100      	movs	r1, #0
    d08c:	2000      	movs	r0, #0
    d08e:	f001 fa89 	bl	e5a4 <am_hal_clkgen_control>

    //
    // Set the default cache configuration
    //
    am_hal_cachectrl_config(&am_hal_cachectrl_defaults);
    d092:	483e      	ldr	r0, [pc, #248]	; (d18c <main+0x10c>)
    d094:	f001 fa52 	bl	e53c <am_hal_cachectrl_config>
    am_hal_cachectrl_enable();
    d098:	f001 fa7a 	bl	e590 <am_hal_cachectrl_enable>

    //
    // Configure the board for low power operation.
    //
    am_bsp_low_power_init();
    d09c:	f000 ffee 	bl	e07c <am_bsp_low_power_init>

    //
    // Enable the ITM print interface.
    //
    am_bsp_itm_printf_enable();
    d0a0:	f001 f81e 	bl	e0e0 <am_bsp_itm_printf_enable>

    //
    // Clear the terminal and print the banner.
    //
    am_util_stdio_terminal_clear();
    d0a4:	f000 ffe0 	bl	e068 <am_util_stdio_terminal_clear>
    am_util_stdio_printf("IOM FRAM Example\n");
    d0a8:	4839      	ldr	r0, [pc, #228]	; (d190 <main+0x110>)
    d0aa:	f000 ffbf 	bl	e02c <am_util_stdio_printf>
#endif

    //
    // TimerA0 init.
    //
    timerA0_init();
    d0ae:	f7ff fe3f 	bl	cd30 <timerA0_init>

    //
    // Enable the timer Interrupt.
    //
    am_hal_ctimer_int_enable(AM_HAL_CTIMER_INT_TIMERA0);
    d0b2:	2001      	movs	r0, #1
    d0b4:	f001 fc64 	bl	e980 <am_hal_ctimer_int_enable>

#if AM_CMSIS_REGS
    //
    // Enable the timer interrupt in the NVIC.
    //
    NVIC_EnableIRQ(CTIMER_IRQn);
    d0b8:	200e      	movs	r0, #14
    d0ba:	f7ff fdf9 	bl	ccb0 <__NVIC_EnableIRQ>

    //
    // Enable the timer interrupt in the NVIC.
    //
    NVIC_EnableIRQ(FRAM_IOM_IRQn);
    d0be:	2006      	movs	r0, #6
    d0c0:	f7ff fdf6 	bl	ccb0 <__NVIC_EnableIRQ>
    // Enable the timer interrupt in the NVIC.
    //
    am_hal_interrupt_enable(FRAM_IOM_INTERRUPT);
#endif // AM_CMSIS_REGS

    am_hal_interrupt_master_enable();
    d0c4:	f001 ff64 	bl	ef90 <am_hal_interrupt_master_enable>

    init_pattern();
    d0c8:	f7ff fe8e 	bl	cde8 <init_pattern>

    //
    // Initialize the FRAM Device
    //
    iRet = fram_init();
    d0cc:	f7ff fea8 	bl	ce20 <fram_init>
    d0d0:	60b8      	str	r0, [r7, #8]
    if (iRet)
    d0d2:	68bb      	ldr	r3, [r7, #8]
    d0d4:	2b00      	cmp	r3, #0
    d0d6:	d003      	beq.n	d0e0 <main+0x60>
    {
        am_util_stdio_printf("Unable to initialize FRAM\n");
    d0d8:	482e      	ldr	r0, [pc, #184]	; (d194 <main+0x114>)
    d0da:	f000 ffa7 	bl	e02c <am_util_stdio_printf>
        while(1);
    d0de:	e7fe      	b.n	d0de <main+0x5e>
    }

    // Set up the periodic FRAM Read
    am_hal_ctimer_int_register(AM_HAL_CTIMER_INT_TIMERA0, initiate_fram_read);
    d0e0:	492d      	ldr	r1, [pc, #180]	; (d198 <main+0x118>)
    d0e2:	2001      	movs	r0, #1
    d0e4:	f001 faf0 	bl	e6c8 <am_hal_ctimer_int_register>

    //
    // Start timer A0
    //
    am_hal_ctimer_start(0, AM_HAL_CTIMER_TIMERA);
    d0e8:	f64f 71ff 	movw	r1, #65535	; 0xffff
    d0ec:	2000      	movs	r0, #0
    d0ee:	f001 fbc1 	bl	e874 <am_hal_ctimer_start>

    am_util_stdio_printf("Periodically Reading data from FRAM using non-blocking read - %d times\n", NUM_INERATIONS);
    d0f2:	2110      	movs	r1, #16
    d0f4:	4829      	ldr	r0, [pc, #164]	; (d19c <main+0x11c>)
    d0f6:	f000 ff99 	bl	e02c <am_util_stdio_printf>
    while(1)
    {
        //
        // Disable interrupt while we decide whether we're going to sleep.
        //
        uint32_t ui32IntStatus = am_hal_interrupt_master_disable();
    d0fa:	f001 ff4d 	bl	ef98 <am_hal_interrupt_master_disable>
    d0fe:	6078      	str	r0, [r7, #4]

        if (!g_bReadFram && !g_bVerifyReadData)
    d100:	4b27      	ldr	r3, [pc, #156]	; (d1a0 <main+0x120>)
    d102:	781b      	ldrb	r3, [r3, #0]
    d104:	b2db      	uxtb	r3, r3
    d106:	f083 0301 	eor.w	r3, r3, #1
    d10a:	b2db      	uxtb	r3, r3
    d10c:	2b00      	cmp	r3, #0
    d10e:	d00e      	beq.n	d12e <main+0xae>
    d110:	4b24      	ldr	r3, [pc, #144]	; (d1a4 <main+0x124>)
    d112:	781b      	ldrb	r3, [r3, #0]
    d114:	b2db      	uxtb	r3, r3
    d116:	f083 0301 	eor.w	r3, r3, #1
    d11a:	b2db      	uxtb	r3, r3
    d11c:	2b00      	cmp	r3, #0
    d11e:	d006      	beq.n	d12e <main+0xae>
        {
            // Wait for Baud rate detection
            am_hal_sysctrl_sleep(true);
    d120:	2001      	movs	r0, #1
    d122:	f003 f95f 	bl	103e4 <am_hal_sysctrl_sleep>
            //
            // Enable interrupts
            //
            am_hal_interrupt_master_set(ui32IntStatus);
    d126:	6878      	ldr	r0, [r7, #4]
    d128:	f001 ff3a 	bl	efa0 <am_hal_interrupt_master_set>
    d12c:	e02b      	b.n	d186 <main+0x106>
        }
        else if (g_bReadFram)
    d12e:	4b1c      	ldr	r3, [pc, #112]	; (d1a0 <main+0x120>)
    d130:	781b      	ldrb	r3, [r3, #0]
    d132:	b2db      	uxtb	r3, r3
    d134:	2b00      	cmp	r3, #0
    d136:	d005      	beq.n	d144 <main+0xc4>
        {
            //
            // Enable interrupts
            //
            am_hal_interrupt_master_set(ui32IntStatus);
    d138:	6878      	ldr	r0, [r7, #4]
    d13a:	f001 ff31 	bl	efa0 <am_hal_interrupt_master_set>
            read_fram();
    d13e:	f7ff ff75 	bl	d02c <read_fram>
    d142:	e7da      	b.n	d0fa <main+0x7a>
        }
        else if (g_bVerifyReadData)
    d144:	4b17      	ldr	r3, [pc, #92]	; (d1a4 <main+0x124>)
    d146:	781b      	ldrb	r3, [r3, #0]
    d148:	b2db      	uxtb	r3, r3
    d14a:	2b00      	cmp	r3, #0
    d14c:	d0d5      	beq.n	d0fa <main+0x7a>
        {
            //
            // Enable interrupts
            //
            am_hal_interrupt_master_set(ui32IntStatus);
    d14e:	6878      	ldr	r0, [r7, #4]
    d150:	f001 ff26 	bl	efa0 <am_hal_interrupt_master_set>
            verify_fram_data();
    d154:	f7ff ff32 	bl	cfbc <verify_fram_data>
            if (++numRead >= NUM_INERATIONS)
    d158:	68fb      	ldr	r3, [r7, #12]
    d15a:	3301      	adds	r3, #1
    d15c:	60fb      	str	r3, [r7, #12]
    d15e:	68fb      	ldr	r3, [r7, #12]
    d160:	2b0f      	cmp	r3, #15
    d162:	d9ca      	bls.n	d0fa <main+0x7a>
            {
                am_util_stdio_printf("\n%d Reads done\n", NUM_INERATIONS);
    d164:	2110      	movs	r1, #16
    d166:	4810      	ldr	r0, [pc, #64]	; (d1a8 <main+0x128>)
    d168:	f000 ff60 	bl	e02c <am_util_stdio_printf>
                break;
    d16c:	bf00      	nop
            }
        }
    }
    // Cleanup
    am_util_stdio_printf("\nEnd of FRAM Example\n");
    d16e:	480f      	ldr	r0, [pc, #60]	; (d1ac <main+0x12c>)
    d170:	f000 ff5c 	bl	e02c <am_util_stdio_printf>
    //
    // Disable the timer Interrupt.
    //
    am_hal_ctimer_int_disable(AM_HAL_CTIMER_INT_TIMERA0);
    d174:	2001      	movs	r0, #1
    d176:	f001 fc17 	bl	e9a8 <am_hal_ctimer_int_disable>

    //
    // disable the interrupts in the NVIC.
    //
#if AM_CMSIS_REGS
    NVIC_DisableIRQ(CTIMER_IRQn);
    d17a:	200e      	movs	r0, #14
    d17c:	f7ff fdb6 	bl	ccec <__NVIC_DisableIRQ>
#else // AM_CMSIS_REGS
    am_hal_interrupt_disable(AM_HAL_INTERRUPT_CTIMER);
#endif // AM_CMSIS_REGS
    fram_term();
    d180:	f7ff ff74 	bl	d06c <fram_term>
    d184:	e000      	b.n	d188 <main+0x108>
    {
    d186:	e7b8      	b.n	d0fa <main+0x7a>
    while(1);
    d188:	e7fe      	b.n	d188 <main+0x108>
    d18a:	bf00      	nop
    d18c:	00010b50 	.word	0x00010b50
    d190:	000109f0 	.word	0x000109f0
    d194:	00010a04 	.word	0x00010a04
    d198:	0000cfa5 	.word	0x0000cfa5
    d19c:	00010a20 	.word	0x00010a20
    d1a0:	100010f0 	.word	0x100010f0
    d1a4:	100010f1 	.word	0x100010f1
    d1a8:	00010a68 	.word	0x00010a68
    d1ac:	00010a78 	.word	0x00010a78

0000d1b0 <Reset_Handler>:
#endif // AM_CMSIS_REGS
{
    //
    // Set the vector table pointer.
    //
    __asm("    ldr    r0, =0xE000ED08\n"
    d1b0:	4811      	ldr	r0, [pc, #68]	; (d1f8 <zero_loop+0x12>)
    d1b2:	4912      	ldr	r1, [pc, #72]	; (d1fc <zero_loop+0x16>)
    d1b4:	6001      	str	r1, [r0, #0]
          "    str    r1, [r0]");

    //
    // Set the stack pointer.
    //
    __asm("    ldr    sp, [r1]");
    d1b6:	f8d1 d000 	ldr.w	sp, [r1]
#ifndef NOFPU
    //
    // Enable the FPU.
    //
    __asm("ldr  r0, =0xE000ED88\n"
    d1ba:	4811      	ldr	r0, [pc, #68]	; (d200 <zero_loop+0x1a>)
    d1bc:	6801      	ldr	r1, [r0, #0]
    d1be:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    d1c2:	6001      	str	r1, [r0, #0]
    d1c4:	f3bf 8f4f 	dsb	sy
    d1c8:	f3bf 8f6f 	isb	sy
          "isb\n");
#endif
    //
    // Copy the data segment initializers from flash to SRAM.
    //
    __asm("    ldr     r0, =_init_data\n"
    d1cc:	480d      	ldr	r0, [pc, #52]	; (d204 <zero_loop+0x1e>)
    d1ce:	490e      	ldr	r1, [pc, #56]	; (d208 <zero_loop+0x22>)
    d1d0:	4a0e      	ldr	r2, [pc, #56]	; (d20c <zero_loop+0x26>)

0000d1d2 <copy_loop>:
    d1d2:	f850 3b04 	ldr.w	r3, [r0], #4
    d1d6:	f841 3b04 	str.w	r3, [r1], #4
    d1da:	4291      	cmp	r1, r2
    d1dc:	dbf9      	blt.n	d1d2 <copy_loop>
          "        cmp     r1, r2\n"
          "        blt     copy_loop\n");
    //
    // Zero fill the bss segment.
    //
    __asm("    ldr     r0, =_sbss\n"
    d1de:	480c      	ldr	r0, [pc, #48]	; (d210 <zero_loop+0x2a>)
    d1e0:	490c      	ldr	r1, [pc, #48]	; (d214 <zero_loop+0x2e>)
    d1e2:	f04f 0200 	mov.w	r2, #0

0000d1e6 <zero_loop>:
    d1e6:	4288      	cmp	r0, r1
    d1e8:	bfb8      	it	lt
    d1ea:	f840 2b04 	strlt.w	r2, [r0], #4
    d1ee:	dbfa      	blt.n	d1e6 <zero_loop>
          "        blt     zero_loop");

    //
    // Call the application's entry point.
    //
    main();
    d1f0:	f7ff ff46 	bl	d080 <main>

    //
    // If main returns then execute a break point instruction
    //
    __asm("    bkpt     ");
    d1f4:	be00      	bkpt	0x0000
}
    d1f6:	bf00      	nop
    d1f8:	e000ed08 	.word	0xe000ed08
    d1fc:	0000c000 	.word	0x0000c000
    d200:	e000ed88 	.word	0xe000ed88
    d204:	00010f74 	.word	0x00010f74
    d208:	10001000 	.word	0x10001000
    d20c:	100010bc 	.word	0x100010bc
    d210:	100010bc 	.word	0x100010bc
    d214:	10004b4c 	.word	0x10004b4c

0000d218 <NMI_Handler>:
#if AM_CMSIS_REGS
NMI_Handler(void)
#else // AM_CMSIS_REGS
am_nmi_isr(void)
#endif // AM_CMSIS_REGS
{
    d218:	b480      	push	{r7}
    d21a:	af00      	add	r7, sp, #0
    //
    // Go into an infinite loop.
    //
    while(1)
    d21c:	e7fe      	b.n	d21c <NMI_Handler+0x4>

0000d21e <DebugMon_Handler>:
// for examination by a debugger.
//
//*****************************************************************************
void
am_default_isr(void)
{
    d21e:	b480      	push	{r7}
    d220:	af00      	add	r7, sp, #0
    //
    // Go into an infinite loop.
    //
    while(1)
    d222:	e7fe      	b.n	d222 <DebugMon_Handler+0x4>

0000d224 <HardFault_Handler>:
}
#elif defined(__GNUC_STDC_INLINE__)
uint32_t __attribute__((naked))
HardFault_Handler(void)
{
    __asm("    push    {r7,lr}");
    d224:	b580      	push	{r7, lr}
    __asm("    mov     r0, sp");
    d226:	4668      	mov	r0, sp
    __asm("    adds    r0, #(2*4)");
    d228:	3008      	adds	r0, #8
    __asm("    bl      am_util_faultisr_collect_data");
    d22a:	f000 f809 	bl	d240 <am_util_faultisr_collect_data>
    __asm("    pop     {r0,pc}");
    d22e:	bd01      	pop	{r0, pc}
}
    d230:	bf00      	nop
    d232:	4618      	mov	r0, r3

0000d234 <getStackedReg>:

uint32_t __attribute__((naked))
getStackedReg(uint32_t regnum, uint32_t u32SP)
{
    __asm("    lsls    r0, r0, #2");
    d234:	0080      	lsls	r0, r0, #2
    __asm("    adds    r0, r1");
    d236:	1840      	adds	r0, r0, r1
    __asm("    ldr     r0, [r0]");
    d238:	6800      	ldr	r0, [r0, #0]
    __asm("    bx      lr");
    d23a:	4770      	bx	lr
}
    d23c:	bf00      	nop
    d23e:	4618      	mov	r0, r3

0000d240 <am_util_faultisr_collect_data>:
// HardFault_Handler() was called.
//
//*****************************************************************************
void
am_util_faultisr_collect_data(uint32_t u32IsrSP)
{
    d240:	b580      	push	{r7, lr}
    d242:	b096      	sub	sp, #88	; 0x58
    d244:	af00      	add	r7, sp, #0
    d246:	6078      	str	r0, [r7, #4]
    volatile am_fault_t sFaultData;
    am_hal_mcuctrl_fault_t sHalFaultData = {0};
    d248:	f107 030c 	add.w	r3, r7, #12
    d24c:	2200      	movs	r2, #0
    d24e:	601a      	str	r2, [r3, #0]
    d250:	605a      	str	r2, [r3, #4]
    d252:	609a      	str	r2, [r3, #8]
    d254:	60da      	str	r2, [r3, #12]
    d256:	611a      	str	r2, [r3, #16]
    d258:	615a      	str	r2, [r3, #20]

    uint32_t u32Mask = 0;
    d25a:	2300      	movs	r3, #0
    d25c:	657b      	str	r3, [r7, #84]	; 0x54
    // u32Mask is used for 2 things: 1) in the print loop, 2) as a spot to set
    // a breakpoint at the end of the routine.  If the printing is not used,
    // we'll get a compiler warning; so to avoid that warning, we'll use it
    // in a dummy assignment here.
    //
    sFaultData.u32CFSR = u32Mask;       // Avoid compiler warning
    d25e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    d260:	64fb      	str	r3, [r7, #76]	; 0x4c
    sFaultData.u32CFSR = AM_REGVAL(AM_REG_SYSCTRL_CFSR_O);
    d262:	4b2e      	ldr	r3, [pc, #184]	; (d31c <am_util_faultisr_collect_data+0xdc>)
    d264:	681b      	ldr	r3, [r3, #0]
    d266:	64fb      	str	r3, [r7, #76]	; 0x4c
    sFaultData.u8MMSR  = (sFaultData.u32CFSR >> 0)  & 0xff;
    d268:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    d26a:	b2db      	uxtb	r3, r3
    d26c:	f887 3050 	strb.w	r3, [r7, #80]	; 0x50
    sFaultData.u8BFSR  = (sFaultData.u32CFSR >> 8)  & 0xff;
    d270:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    d272:	0a1b      	lsrs	r3, r3, #8
    d274:	b2db      	uxtb	r3, r3
    d276:	f887 3051 	strb.w	r3, [r7, #81]	; 0x51
    sFaultData.u16UFSR = (sFaultData.u32CFSR >> 16) & 0xffff;
    d27a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    d27c:	0c1b      	lsrs	r3, r3, #16
    d27e:	b29b      	uxth	r3, r3
    d280:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52

    //
    // The address of the location that caused the fault.  e.g. if accessing an
    // invalid data location caused the fault, that address will appear here.
    //
    sFaultData.u32BFAR = AM_REGVAL(AM_REG_SYSCTRL_BFAR_O);
    d284:	4b26      	ldr	r3, [pc, #152]	; (d320 <am_util_faultisr_collect_data+0xe0>)
    d286:	681b      	ldr	r3, [r3, #0]
    d288:	64bb      	str	r3, [r7, #72]	; 0x48

    //
    // The address of the instruction that caused the fault is the stacked PC
    // if BFSR bit1 is set.
    //
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    d28a:	f897 3051 	ldrb.w	r3, [r7, #81]	; 0x51
    d28e:	b2db      	uxtb	r3, r3
    d290:	f003 0302 	and.w	r3, r3, #2
    d294:	2b00      	cmp	r3, #0
    d296:	d005      	beq.n	d2a4 <am_util_faultisr_collect_data+0x64>
    d298:	6879      	ldr	r1, [r7, #4]
    d29a:	2006      	movs	r0, #6
    d29c:	f7ff ffca 	bl	d234 <getStackedReg>
    d2a0:	4603      	mov	r3, r0
    d2a2:	e001      	b.n	d2a8 <am_util_faultisr_collect_data+0x68>
    d2a4:	f04f 33ff 	mov.w	r3, #4294967295
    d2a8:	647b      	str	r3, [r7, #68]	; 0x44

    //
    // Get the stacked registers.
    // Note - the address of the instruction that caused the fault is u32PC.
    //
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    d2aa:	6879      	ldr	r1, [r7, #4]
    d2ac:	2000      	movs	r0, #0
    d2ae:	f7ff ffc1 	bl	d234 <getStackedReg>
    d2b2:	4603      	mov	r3, r0
    d2b4:	627b      	str	r3, [r7, #36]	; 0x24
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    d2b6:	6879      	ldr	r1, [r7, #4]
    d2b8:	2001      	movs	r0, #1
    d2ba:	f7ff ffbb 	bl	d234 <getStackedReg>
    d2be:	4603      	mov	r3, r0
    d2c0:	62bb      	str	r3, [r7, #40]	; 0x28
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    d2c2:	6879      	ldr	r1, [r7, #4]
    d2c4:	2002      	movs	r0, #2
    d2c6:	f7ff ffb5 	bl	d234 <getStackedReg>
    d2ca:	4603      	mov	r3, r0
    d2cc:	62fb      	str	r3, [r7, #44]	; 0x2c
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    d2ce:	6879      	ldr	r1, [r7, #4]
    d2d0:	2003      	movs	r0, #3
    d2d2:	f7ff ffaf 	bl	d234 <getStackedReg>
    d2d6:	4603      	mov	r3, r0
    d2d8:	633b      	str	r3, [r7, #48]	; 0x30
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    d2da:	6879      	ldr	r1, [r7, #4]
    d2dc:	2004      	movs	r0, #4
    d2de:	f7ff ffa9 	bl	d234 <getStackedReg>
    d2e2:	4603      	mov	r3, r0
    d2e4:	637b      	str	r3, [r7, #52]	; 0x34
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    d2e6:	6879      	ldr	r1, [r7, #4]
    d2e8:	2005      	movs	r0, #5
    d2ea:	f7ff ffa3 	bl	d234 <getStackedReg>
    d2ee:	4603      	mov	r3, r0
    d2f0:	63bb      	str	r3, [r7, #56]	; 0x38
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    d2f2:	6879      	ldr	r1, [r7, #4]
    d2f4:	2006      	movs	r0, #6
    d2f6:	f7ff ff9d 	bl	d234 <getStackedReg>
    d2fa:	4603      	mov	r3, r0
    d2fc:	63fb      	str	r3, [r7, #60]	; 0x3c
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    d2fe:	6879      	ldr	r1, [r7, #4]
    d300:	2007      	movs	r0, #7
    d302:	f7ff ff97 	bl	d234 <getStackedReg>
    d306:	4603      	mov	r3, r0
    d308:	643b      	str	r3, [r7, #64]	; 0x40

    //
    // Use the HAL MCUCTRL functions to read the fault data.
    //
#ifdef AM_APOLLO3_MCUCTRL
    am_hal_mcuctrl_info_get(AM_HAL_MCUCTRL_INFO_FAULT_STATUS, &sHalFaultData);
    d30a:	f107 030c 	add.w	r3, r7, #12
    d30e:	4619      	mov	r1, r3
    d310:	2002      	movs	r0, #2
    d312:	f002 ff25 	bl	10160 <am_hal_mcuctrl_info_get>
    }


#endif

    u32Mask = 0;
    d316:	2300      	movs	r3, #0
    d318:	657b      	str	r3, [r7, #84]	; 0x54
    //
    // Spin in an infinite loop.
    // We need to spin here inside the function so that we have access to
    // local data, i.e. sFaultData.
    //
    while(1)
    d31a:	e7fe      	b.n	d31a <am_util_faultisr_collect_data+0xda>
    d31c:	e000ed28 	.word	0xe000ed28
    d320:	e000ed38 	.word	0xe000ed38

0000d324 <am_util_stdio_printf_init>:
//! @return None.
//
//*****************************************************************************
void
am_util_stdio_printf_init(am_util_stdio_print_char_t pfnCharPrint)
{
    d324:	b480      	push	{r7}
    d326:	b083      	sub	sp, #12
    d328:	af00      	add	r7, sp, #0
    d32a:	6078      	str	r0, [r7, #4]
    g_pfnCharPrint = pfnCharPrint;
    d32c:	4a04      	ldr	r2, [pc, #16]	; (d340 <am_util_stdio_printf_init+0x1c>)
    d32e:	687b      	ldr	r3, [r7, #4]
    d330:	6013      	str	r3, [r2, #0]
}
    d332:	bf00      	nop
    d334:	370c      	adds	r7, #12
    d336:	46bd      	mov	sp, r7
    d338:	f85d 7b04 	ldr.w	r7, [sp], #4
    d33c:	4770      	bx	lr
    d33e:	bf00      	nop
    d340:	10001840 	.word	0x10001840

0000d344 <divu64_10>:
//  Note: Adapted from Ch10 of Hackers Delight (hackersdelight.org).
//
//*****************************************************************************
static uint64_t
divu64_10(uint64_t ui64Val)
{
    d344:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    d348:	b096      	sub	sp, #88	; 0x58
    d34a:	af00      	add	r7, sp, #0
    d34c:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
    uint32_t q32, r32, ui32Val;

    //
    // If a 32-bit value, use the more optimal 32-bit routine.
    //
    if ( ui64Val >> 32 )
    d350:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
    d354:	0025      	movs	r5, r4
    d356:	2600      	movs	r6, #0
    d358:	ea55 0306 	orrs.w	r3, r5, r6
    d35c:	f000 80a0 	beq.w	d4a0 <divu64_10+0x15c>
    {
        q64 = (ui64Val>>1) + (ui64Val>>2);
    d360:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
    d364:	0862      	lsrs	r2, r4, #1
    d366:	ea4f 0133 	mov.w	r1, r3, rrx
    d36a:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
    d36e:	ea4f 0893 	mov.w	r8, r3, lsr #2
    d372:	ea48 7884 	orr.w	r8, r8, r4, lsl #30
    d376:	ea4f 0994 	mov.w	r9, r4, lsr #2
    d37a:	eb11 0308 	adds.w	r3, r1, r8
    d37e:	eb42 0409 	adc.w	r4, r2, r9
    d382:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        q64 += (q64 >> 4);
    d386:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    d38a:	ea4f 1a13 	mov.w	sl, r3, lsr #4
    d38e:	ea4a 7a04 	orr.w	sl, sl, r4, lsl #28
    d392:	ea4f 1b14 	mov.w	fp, r4, lsr #4
    d396:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    d39a:	eb13 030a 	adds.w	r3, r3, sl
    d39e:	eb44 040b 	adc.w	r4, r4, fp
    d3a2:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        q64 += (q64 >> 8);
    d3a6:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    d3aa:	0a1a      	lsrs	r2, r3, #8
    d3ac:	62ba      	str	r2, [r7, #40]	; 0x28
    d3ae:	6aba      	ldr	r2, [r7, #40]	; 0x28
    d3b0:	ea42 6204 	orr.w	r2, r2, r4, lsl #24
    d3b4:	62ba      	str	r2, [r7, #40]	; 0x28
    d3b6:	0a23      	lsrs	r3, r4, #8
    d3b8:	62fb      	str	r3, [r7, #44]	; 0x2c
    d3ba:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    d3be:	e9d7 120a 	ldrd	r1, r2, [r7, #40]	; 0x28
    d3c2:	18c9      	adds	r1, r1, r3
    d3c4:	eb42 0204 	adc.w	r2, r2, r4
    d3c8:	460b      	mov	r3, r1
    d3ca:	4614      	mov	r4, r2
    d3cc:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        q64 += (q64 >> 16);
    d3d0:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    d3d4:	0c1a      	lsrs	r2, r3, #16
    d3d6:	623a      	str	r2, [r7, #32]
    d3d8:	6a3a      	ldr	r2, [r7, #32]
    d3da:	ea42 4204 	orr.w	r2, r2, r4, lsl #16
    d3de:	623a      	str	r2, [r7, #32]
    d3e0:	0c23      	lsrs	r3, r4, #16
    d3e2:	627b      	str	r3, [r7, #36]	; 0x24
    d3e4:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    d3e8:	e9d7 1208 	ldrd	r1, r2, [r7, #32]
    d3ec:	18c9      	adds	r1, r1, r3
    d3ee:	eb42 0204 	adc.w	r2, r2, r4
    d3f2:	460b      	mov	r3, r1
    d3f4:	4614      	mov	r4, r2
    d3f6:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        q64 += (q64 >> 32);
    d3fa:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    d3fe:	0023      	movs	r3, r4
    d400:	603b      	str	r3, [r7, #0]
    d402:	2300      	movs	r3, #0
    d404:	607b      	str	r3, [r7, #4]
    d406:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    d40a:	e897 0006 	ldmia.w	r7, {r1, r2}
    d40e:	18c9      	adds	r1, r1, r3
    d410:	eb42 0204 	adc.w	r2, r2, r4
    d414:	460b      	mov	r3, r1
    d416:	4614      	mov	r4, r2
    d418:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        q64 >>= 3;
    d41c:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    d420:	08da      	lsrs	r2, r3, #3
    d422:	613a      	str	r2, [r7, #16]
    d424:	693a      	ldr	r2, [r7, #16]
    d426:	ea42 7244 	orr.w	r2, r2, r4, lsl #29
    d42a:	613a      	str	r2, [r7, #16]
    d42c:	08e3      	lsrs	r3, r4, #3
    d42e:	617b      	str	r3, [r7, #20]
    d430:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
    d434:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        r64 = ui64Val - q64*10;
    d438:	e9d7 1214 	ldrd	r1, r2, [r7, #80]	; 0x50
    d43c:	460b      	mov	r3, r1
    d43e:	4614      	mov	r4, r2
    d440:	00a0      	lsls	r0, r4, #2
    d442:	60f8      	str	r0, [r7, #12]
    d444:	68f8      	ldr	r0, [r7, #12]
    d446:	ea40 7093 	orr.w	r0, r0, r3, lsr #30
    d44a:	60f8      	str	r0, [r7, #12]
    d44c:	009b      	lsls	r3, r3, #2
    d44e:	60bb      	str	r3, [r7, #8]
    d450:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
    d454:	185b      	adds	r3, r3, r1
    d456:	eb44 0402 	adc.w	r4, r4, r2
    d45a:	18db      	adds	r3, r3, r3
    d45c:	eb44 0404 	adc.w	r4, r4, r4
    d460:	4619      	mov	r1, r3
    d462:	4622      	mov	r2, r4
    d464:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
    d468:	1a5b      	subs	r3, r3, r1
    d46a:	eb64 0402 	sbc.w	r4, r4, r2
    d46e:	e9c7 3412 	strd	r3, r4, [r7, #72]	; 0x48
        return q64 + ((r64 + 6) >> 4);
    d472:	e9d7 3412 	ldrd	r3, r4, [r7, #72]	; 0x48
    d476:	3306      	adds	r3, #6
    d478:	f144 0400 	adc.w	r4, r4, #0
    d47c:	091a      	lsrs	r2, r3, #4
    d47e:	61ba      	str	r2, [r7, #24]
    d480:	69ba      	ldr	r2, [r7, #24]
    d482:	ea42 7204 	orr.w	r2, r2, r4, lsl #28
    d486:	61ba      	str	r2, [r7, #24]
    d488:	0923      	lsrs	r3, r4, #4
    d48a:	61fb      	str	r3, [r7, #28]
    d48c:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    d490:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
    d494:	18c9      	adds	r1, r1, r3
    d496:	eb42 0204 	adc.w	r2, r2, r4
    d49a:	460b      	mov	r3, r1
    d49c:	4614      	mov	r4, r2
    d49e:	e029      	b.n	d4f4 <divu64_10+0x1b0>
    }
    else
    {
        ui32Val = (uint32_t)(ui64Val & 0xffffffff);
    d4a0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    d4a2:	647b      	str	r3, [r7, #68]	; 0x44
        q32 = (ui32Val>>1) + (ui32Val>>2);
    d4a4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    d4a6:	085a      	lsrs	r2, r3, #1
    d4a8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    d4aa:	089b      	lsrs	r3, r3, #2
    d4ac:	4413      	add	r3, r2
    d4ae:	643b      	str	r3, [r7, #64]	; 0x40
        q32 += (q32 >> 4);
    d4b0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    d4b2:	091b      	lsrs	r3, r3, #4
    d4b4:	6c3a      	ldr	r2, [r7, #64]	; 0x40
    d4b6:	4413      	add	r3, r2
    d4b8:	643b      	str	r3, [r7, #64]	; 0x40
        q32 += (q32 >> 8);
    d4ba:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    d4bc:	0a1b      	lsrs	r3, r3, #8
    d4be:	6c3a      	ldr	r2, [r7, #64]	; 0x40
    d4c0:	4413      	add	r3, r2
    d4c2:	643b      	str	r3, [r7, #64]	; 0x40
        q32 += (q32 >> 16);
    d4c4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    d4c6:	0c1b      	lsrs	r3, r3, #16
    d4c8:	6c3a      	ldr	r2, [r7, #64]	; 0x40
    d4ca:	4413      	add	r3, r2
    d4cc:	643b      	str	r3, [r7, #64]	; 0x40
        q32 >>= 3;
    d4ce:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    d4d0:	08db      	lsrs	r3, r3, #3
    d4d2:	643b      	str	r3, [r7, #64]	; 0x40
        r32 = ui32Val - q32*10;
    d4d4:	6c3a      	ldr	r2, [r7, #64]	; 0x40
    d4d6:	4613      	mov	r3, r2
    d4d8:	009b      	lsls	r3, r3, #2
    d4da:	4413      	add	r3, r2
    d4dc:	005b      	lsls	r3, r3, #1
    d4de:	461a      	mov	r2, r3
    d4e0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    d4e2:	1a9b      	subs	r3, r3, r2
    d4e4:	63fb      	str	r3, [r7, #60]	; 0x3c
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    d4e6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    d4e8:	3306      	adds	r3, #6
    d4ea:	091a      	lsrs	r2, r3, #4
    d4ec:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    d4ee:	4413      	add	r3, r2
    d4f0:	f04f 0400 	mov.w	r4, #0
    }
}
    d4f4:	4618      	mov	r0, r3
    d4f6:	4621      	mov	r1, r4
    d4f8:	3758      	adds	r7, #88	; 0x58
    d4fa:	46bd      	mov	sp, r7
    d4fc:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    d500:	4770      	bx	lr

0000d502 <ndigits_in_u64>:
// example: 10000 return 5, 123 returns 3.
//
//*****************************************************************************
static int
ndigits_in_u64(uint64_t ui64Val)
{
    d502:	b590      	push	{r4, r7, lr}
    d504:	b085      	sub	sp, #20
    d506:	af00      	add	r7, sp, #0
    d508:	e9c7 0100 	strd	r0, r1, [r7]
    int iNDigits = ui64Val ? 0 : 1;
    d50c:	683a      	ldr	r2, [r7, #0]
    d50e:	687b      	ldr	r3, [r7, #4]
    d510:	4313      	orrs	r3, r2
    d512:	2b00      	cmp	r3, #0
    d514:	bf0c      	ite	eq
    d516:	2301      	moveq	r3, #1
    d518:	2300      	movne	r3, #0
    d51a:	b2db      	uxtb	r3, r3
    d51c:	60fb      	str	r3, [r7, #12]

    while ( ui64Val )
    d51e:	e008      	b.n	d532 <ndigits_in_u64+0x30>
    {
        //
        // ui32Val /= 10;
        //
        ui64Val = divu64_10(ui64Val);
    d520:	e9d7 0100 	ldrd	r0, r1, [r7]
    d524:	f7ff ff0e 	bl	d344 <divu64_10>
    d528:	e9c7 0100 	strd	r0, r1, [r7]
        ++iNDigits;
    d52c:	68fb      	ldr	r3, [r7, #12]
    d52e:	3301      	adds	r3, #1
    d530:	60fb      	str	r3, [r7, #12]
    while ( ui64Val )
    d532:	e897 0018 	ldmia.w	r7, {r3, r4}
    d536:	4323      	orrs	r3, r4
    d538:	d1f2      	bne.n	d520 <ndigits_in_u64+0x1e>
    }

    return iNDigits;
    d53a:	68fb      	ldr	r3, [r7, #12]
}
    d53c:	4618      	mov	r0, r3
    d53e:	3714      	adds	r7, #20
    d540:	46bd      	mov	sp, r7
    d542:	bd90      	pop	{r4, r7, pc}

0000d544 <ndigits_in_i64>:
// example: -3 returns 1, 3 returns 1, 15 returns 2, -15 returns 2, ...
//
//*****************************************************************************
static int
ndigits_in_i64(int64_t i64Val)
{
    d544:	b590      	push	{r4, r7, lr}
    d546:	b083      	sub	sp, #12
    d548:	af00      	add	r7, sp, #0
    d54a:	e9c7 0100 	strd	r0, r1, [r7]
    if ( i64Val < 0 )
    d54e:	e897 0018 	ldmia.w	r7, {r3, r4}
    d552:	2b00      	cmp	r3, #0
    d554:	f174 0300 	sbcs.w	r3, r4, #0
    d558:	da06      	bge.n	d568 <ndigits_in_i64+0x24>
    {
        //
        // Get absolute value
        //
        i64Val = -i64Val;
    d55a:	e897 0018 	ldmia.w	r7, {r3, r4}
    d55e:	425b      	negs	r3, r3
    d560:	eb64 0444 	sbc.w	r4, r4, r4, lsl #1
    d564:	e887 0018 	stmia.w	r7, {r3, r4}
    }

    return ndigits_in_u64((uint64_t) i64Val);
    d568:	e897 0018 	ldmia.w	r7, {r3, r4}
    d56c:	4618      	mov	r0, r3
    d56e:	4621      	mov	r1, r4
    d570:	f7ff ffc7 	bl	d502 <ndigits_in_u64>
    d574:	4603      	mov	r3, r0
}
    d576:	4618      	mov	r0, r3
    d578:	370c      	adds	r7, #12
    d57a:	46bd      	mov	sp, r7
    d57c:	bd90      	pop	{r4, r7, pc}

0000d57e <ndigits_in_hex>:
// Return the number of hex digits in an uint64_t.
//
//*****************************************************************************
static int
ndigits_in_hex(uint64_t ui64Val)
{
    d57e:	b490      	push	{r4, r7}
    d580:	b084      	sub	sp, #16
    d582:	af00      	add	r7, sp, #0
    d584:	e9c7 0100 	strd	r0, r1, [r7]
    int iDigits = ui64Val ? 0 : 1;
    d588:	6839      	ldr	r1, [r7, #0]
    d58a:	687a      	ldr	r2, [r7, #4]
    d58c:	430a      	orrs	r2, r1
    d58e:	2a00      	cmp	r2, #0
    d590:	bf0c      	ite	eq
    d592:	2201      	moveq	r2, #1
    d594:	2200      	movne	r2, #0
    d596:	b2d2      	uxtb	r2, r2
    d598:	60fa      	str	r2, [r7, #12]

    while ( ui64Val )
    d59a:	e00a      	b.n	d5b2 <ndigits_in_hex+0x34>
    {
        ui64Val >>= 4;
    d59c:	e897 0006 	ldmia.w	r7, {r1, r2}
    d5a0:	090b      	lsrs	r3, r1, #4
    d5a2:	ea43 7302 	orr.w	r3, r3, r2, lsl #28
    d5a6:	0914      	lsrs	r4, r2, #4
    d5a8:	e887 0018 	stmia.w	r7, {r3, r4}
        ++iDigits;
    d5ac:	68fa      	ldr	r2, [r7, #12]
    d5ae:	3201      	adds	r2, #1
    d5b0:	60fa      	str	r2, [r7, #12]
    while ( ui64Val )
    d5b2:	e897 0006 	ldmia.w	r7, {r1, r2}
    d5b6:	430a      	orrs	r2, r1
    d5b8:	d1f0      	bne.n	d59c <ndigits_in_hex+0x1e>
    }

    return iDigits;
    d5ba:	68fb      	ldr	r3, [r7, #12]
}
    d5bc:	4618      	mov	r0, r3
    d5be:	3710      	adds	r7, #16
    d5c0:	46bd      	mov	sp, r7
    d5c2:	bc90      	pop	{r4, r7}
    d5c4:	4770      	bx	lr

0000d5c6 <decstr_to_int>:
// pui32CharCnt.
//
//*****************************************************************************
static uint32_t
decstr_to_int(const char *pcStr, uint32_t *pui32CharCnt)
{
    d5c6:	b480      	push	{r7}
    d5c8:	b087      	sub	sp, #28
    d5ca:	af00      	add	r7, sp, #0
    d5cc:	6078      	str	r0, [r7, #4]
    d5ce:	6039      	str	r1, [r7, #0]
    bool bNeg = false;
    d5d0:	2300      	movs	r3, #0
    d5d2:	75fb      	strb	r3, [r7, #23]
    uint32_t ui32Val = 0, uCnt = 0;
    d5d4:	2300      	movs	r3, #0
    d5d6:	613b      	str	r3, [r7, #16]
    d5d8:	2300      	movs	r3, #0
    d5da:	60fb      	str	r3, [r7, #12]

    if ( *pcStr == '-')
    d5dc:	687b      	ldr	r3, [r7, #4]
    d5de:	781b      	ldrb	r3, [r3, #0]
    d5e0:	2b2d      	cmp	r3, #45	; 0x2d
    d5e2:	d11b      	bne.n	d61c <decstr_to_int+0x56>
    {
        bNeg = true;
    d5e4:	2301      	movs	r3, #1
    d5e6:	75fb      	strb	r3, [r7, #23]
        pcStr++;
    d5e8:	687b      	ldr	r3, [r7, #4]
    d5ea:	3301      	adds	r3, #1
    d5ec:	607b      	str	r3, [r7, #4]
        uCnt++;
    d5ee:	68fb      	ldr	r3, [r7, #12]
    d5f0:	3301      	adds	r3, #1
    d5f2:	60fb      	str	r3, [r7, #12]
    }

    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    d5f4:	e012      	b.n	d61c <decstr_to_int+0x56>
    {
        ++uCnt;
    d5f6:	68fb      	ldr	r3, [r7, #12]
    d5f8:	3301      	adds	r3, #1
    d5fa:	60fb      	str	r3, [r7, #12]

        //
        // Multiply accumulated value by 10.
        //
        ui32Val *= 10;
    d5fc:	693a      	ldr	r2, [r7, #16]
    d5fe:	4613      	mov	r3, r2
    d600:	009b      	lsls	r3, r3, #2
    d602:	4413      	add	r3, r2
    d604:	005b      	lsls	r3, r3, #1
    d606:	613b      	str	r3, [r7, #16]

        //
        // Add in the new low digit.
        //
        ui32Val += (*pcStr - '0');
    d608:	687b      	ldr	r3, [r7, #4]
    d60a:	781b      	ldrb	r3, [r3, #0]
    d60c:	461a      	mov	r2, r3
    d60e:	693b      	ldr	r3, [r7, #16]
    d610:	4413      	add	r3, r2
    d612:	3b30      	subs	r3, #48	; 0x30
    d614:	613b      	str	r3, [r7, #16]
        pcStr++;
    d616:	687b      	ldr	r3, [r7, #4]
    d618:	3301      	adds	r3, #1
    d61a:	607b      	str	r3, [r7, #4]
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    d61c:	687b      	ldr	r3, [r7, #4]
    d61e:	781b      	ldrb	r3, [r3, #0]
    d620:	2b2f      	cmp	r3, #47	; 0x2f
    d622:	d903      	bls.n	d62c <decstr_to_int+0x66>
    d624:	687b      	ldr	r3, [r7, #4]
    d626:	781b      	ldrb	r3, [r3, #0]
    d628:	2b39      	cmp	r3, #57	; 0x39
    d62a:	d9e4      	bls.n	d5f6 <decstr_to_int+0x30>
    }

    if ( pui32CharCnt )
    d62c:	683b      	ldr	r3, [r7, #0]
    d62e:	2b00      	cmp	r3, #0
    d630:	d002      	beq.n	d638 <decstr_to_int+0x72>
    {
        *pui32CharCnt = uCnt;
    d632:	683b      	ldr	r3, [r7, #0]
    d634:	68fa      	ldr	r2, [r7, #12]
    d636:	601a      	str	r2, [r3, #0]
    }

    return bNeg ? -ui32Val : ui32Val;
    d638:	7dfb      	ldrb	r3, [r7, #23]
    d63a:	2b00      	cmp	r3, #0
    d63c:	d002      	beq.n	d644 <decstr_to_int+0x7e>
    d63e:	693b      	ldr	r3, [r7, #16]
    d640:	425b      	negs	r3, r3
    d642:	e000      	b.n	d646 <decstr_to_int+0x80>
    d644:	693b      	ldr	r3, [r7, #16]
}
    d646:	4618      	mov	r0, r3
    d648:	371c      	adds	r7, #28
    d64a:	46bd      	mov	sp, r7
    d64c:	f85d 7b04 	ldr.w	r7, [sp], #4
    d650:	4770      	bx	lr

0000d652 <uint64_to_str>:
// written).
//
//*****************************************************************************
static int
uint64_to_str(uint64_t ui64Val, char *pcBuf)
{
    d652:	b590      	push	{r4, r7, lr}
    d654:	b091      	sub	sp, #68	; 0x44
    d656:	af00      	add	r7, sp, #0
    d658:	e9c7 0102 	strd	r0, r1, [r7, #8]
    d65c:	607a      	str	r2, [r7, #4]
    char tbuf[25];
    int ix = 0, iNumDig = 0;
    d65e:	2300      	movs	r3, #0
    d660:	63fb      	str	r3, [r7, #60]	; 0x3c
    d662:	2300      	movs	r3, #0
    d664:	63bb      	str	r3, [r7, #56]	; 0x38
    do
    {
        //
        // Divide by 10
        //
        u64Tmp = divu64_10(ui64Val);
    d666:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
    d66a:	f7ff fe6b 	bl	d344 <divu64_10>
    d66e:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30

        //
        // Get modulus
        //
        uMod = ui64Val - (u64Tmp * 10);
    d672:	68b9      	ldr	r1, [r7, #8]
    d674:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    d676:	4613      	mov	r3, r2
    d678:	009b      	lsls	r3, r3, #2
    d67a:	4413      	add	r3, r2
    d67c:	005b      	lsls	r3, r3, #1
    d67e:	1acb      	subs	r3, r1, r3
    d680:	62fb      	str	r3, [r7, #44]	; 0x2c

        tbuf[ix++] = uMod + '0';
    d682:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    d684:	1c5a      	adds	r2, r3, #1
    d686:	63fa      	str	r2, [r7, #60]	; 0x3c
    d688:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    d68a:	b2d2      	uxtb	r2, r2
    d68c:	3230      	adds	r2, #48	; 0x30
    d68e:	b2d2      	uxtb	r2, r2
    d690:	f107 0140 	add.w	r1, r7, #64	; 0x40
    d694:	440b      	add	r3, r1
    d696:	f803 2c30 	strb.w	r2, [r3, #-48]
        ui64Val = u64Tmp;
    d69a:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
    d69e:	e9c7 3402 	strd	r3, r4, [r7, #8]
    } while ( ui64Val );
    d6a2:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
    d6a6:	4323      	orrs	r3, r4
    d6a8:	d1dd      	bne.n	d666 <uint64_to_str+0x14>

    //
    // Save the total number of digits
    //
    iNumDig = ix;
    d6aa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    d6ac:	63bb      	str	r3, [r7, #56]	; 0x38

    //
    // Now, reverse the buffer when saving to the caller's buffer.
    //
    if ( pcBuf )
    d6ae:	687b      	ldr	r3, [r7, #4]
    d6b0:	2b00      	cmp	r3, #0
    d6b2:	d011      	beq.n	d6d8 <uint64_to_str+0x86>
    {
        while ( ix-- )
    d6b4:	e008      	b.n	d6c8 <uint64_to_str+0x76>
        {
            *pcBuf++ = tbuf[ix];
    d6b6:	687b      	ldr	r3, [r7, #4]
    d6b8:	1c5a      	adds	r2, r3, #1
    d6ba:	607a      	str	r2, [r7, #4]
    d6bc:	f107 0110 	add.w	r1, r7, #16
    d6c0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    d6c2:	440a      	add	r2, r1
    d6c4:	7812      	ldrb	r2, [r2, #0]
    d6c6:	701a      	strb	r2, [r3, #0]
        while ( ix-- )
    d6c8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    d6ca:	1e5a      	subs	r2, r3, #1
    d6cc:	63fa      	str	r2, [r7, #60]	; 0x3c
    d6ce:	2b00      	cmp	r3, #0
    d6d0:	d1f1      	bne.n	d6b6 <uint64_to_str+0x64>
        }

        //
        // Terminate the caller's buffer
        //
        *pcBuf = 0x00;
    d6d2:	687b      	ldr	r3, [r7, #4]
    d6d4:	2200      	movs	r2, #0
    d6d6:	701a      	strb	r2, [r3, #0]
    }

    return iNumDig;
    d6d8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
}
    d6da:	4618      	mov	r0, r3
    d6dc:	3744      	adds	r7, #68	; 0x44
    d6de:	46bd      	mov	sp, r7
    d6e0:	bd90      	pop	{r4, r7, pc}

0000d6e2 <uint64_to_hexstr>:
// written).
//
//*****************************************************************************
static int
uint64_to_hexstr(uint64_t ui64Val, char *pcBuf, bool bLower)
{
    d6e2:	b4b0      	push	{r4, r5, r7}
    d6e4:	b08d      	sub	sp, #52	; 0x34
    d6e6:	af00      	add	r7, sp, #0
    d6e8:	e9c7 0102 	strd	r0, r1, [r7, #8]
    d6ec:	607a      	str	r2, [r7, #4]
    d6ee:	70fb      	strb	r3, [r7, #3]
    int iNumDig, ix = 0;
    d6f0:	2300      	movs	r3, #0
    d6f2:	62fb      	str	r3, [r7, #44]	; 0x2c
    char cCh, tbuf[20];

    if ( ui64Val == 0 )
    d6f4:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
    d6f8:	4313      	orrs	r3, r2
    d6fa:	d131      	bne.n	d760 <uint64_to_hexstr+0x7e>
    {
        tbuf[ix++] = '0';   // Print a '0'
    d6fc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    d6fe:	1c5a      	adds	r2, r3, #1
    d700:	62fa      	str	r2, [r7, #44]	; 0x2c
    d702:	f107 0230 	add.w	r2, r7, #48	; 0x30
    d706:	4413      	add	r3, r2
    d708:	2230      	movs	r2, #48	; 0x30
    d70a:	f803 2c20 	strb.w	r2, [r3, #-32]
    }

    while ( ui64Val )
    d70e:	e027      	b.n	d760 <uint64_to_hexstr+0x7e>
    {
        cCh = ui64Val & 0xf;
    d710:	7a3b      	ldrb	r3, [r7, #8]
    d712:	f003 030f 	and.w	r3, r3, #15
    d716:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

        //
        // Alpha character
        //
        if ( cCh > 9 )
    d71a:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
    d71e:	2b09      	cmp	r3, #9
    d720:	d90a      	bls.n	d738 <uint64_to_hexstr+0x56>
        {
            cCh += bLower ? 0x27 : 0x7;
    d722:	78fb      	ldrb	r3, [r7, #3]
    d724:	2b00      	cmp	r3, #0
    d726:	d001      	beq.n	d72c <uint64_to_hexstr+0x4a>
    d728:	2227      	movs	r2, #39	; 0x27
    d72a:	e000      	b.n	d72e <uint64_to_hexstr+0x4c>
    d72c:	2207      	movs	r2, #7
    d72e:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
    d732:	4413      	add	r3, r2
    d734:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
        }

        tbuf[ix++] = cCh + '0';
    d738:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    d73a:	1c5a      	adds	r2, r3, #1
    d73c:	62fa      	str	r2, [r7, #44]	; 0x2c
    d73e:	f897 202b 	ldrb.w	r2, [r7, #43]	; 0x2b
    d742:	3230      	adds	r2, #48	; 0x30
    d744:	b2d2      	uxtb	r2, r2
    d746:	f107 0130 	add.w	r1, r7, #48	; 0x30
    d74a:	440b      	add	r3, r1
    d74c:	f803 2c20 	strb.w	r2, [r3, #-32]
        ui64Val >>= 4;
    d750:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
    d754:	0914      	lsrs	r4, r2, #4
    d756:	ea44 7403 	orr.w	r4, r4, r3, lsl #28
    d75a:	091d      	lsrs	r5, r3, #4
    d75c:	e9c7 4502 	strd	r4, r5, [r7, #8]
    while ( ui64Val )
    d760:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
    d764:	4313      	orrs	r3, r2
    d766:	d1d3      	bne.n	d710 <uint64_to_hexstr+0x2e>
    }

    //
    // Save the total number of digits
    //
    iNumDig = ix;
    d768:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    d76a:	627b      	str	r3, [r7, #36]	; 0x24

    //
    // Now, reverse the buffer when saving to the callers buffer.
    //
    if (pcBuf)
    d76c:	687b      	ldr	r3, [r7, #4]
    d76e:	2b00      	cmp	r3, #0
    d770:	d011      	beq.n	d796 <uint64_to_hexstr+0xb4>
    {
        while (ix--)
    d772:	e008      	b.n	d786 <uint64_to_hexstr+0xa4>
        {
            *pcBuf++ = tbuf[ix];
    d774:	687b      	ldr	r3, [r7, #4]
    d776:	1c5a      	adds	r2, r3, #1
    d778:	607a      	str	r2, [r7, #4]
    d77a:	f107 0110 	add.w	r1, r7, #16
    d77e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    d780:	440a      	add	r2, r1
    d782:	7812      	ldrb	r2, [r2, #0]
    d784:	701a      	strb	r2, [r3, #0]
        while (ix--)
    d786:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    d788:	1e5a      	subs	r2, r3, #1
    d78a:	62fa      	str	r2, [r7, #44]	; 0x2c
    d78c:	2b00      	cmp	r3, #0
    d78e:	d1f1      	bne.n	d774 <uint64_to_hexstr+0x92>
        }

        //
        // Terminate the caller's buffer
        //
        *pcBuf = 0;
    d790:	687b      	ldr	r3, [r7, #4]
    d792:	2200      	movs	r2, #0
    d794:	701a      	strb	r2, [r3, #0]
    }

    return iNumDig;
    d796:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
    d798:	4618      	mov	r0, r3
    d79a:	3734      	adds	r7, #52	; 0x34
    d79c:	46bd      	mov	sp, r7
    d79e:	bcb0      	pop	{r4, r5, r7}
    d7a0:	4770      	bx	lr

0000d7a2 <simple_strlen>:
// Return length of the given string.
//
//*****************************************************************************
static uint32_t
simple_strlen(char *pcBuf)
{
    d7a2:	b480      	push	{r7}
    d7a4:	b085      	sub	sp, #20
    d7a6:	af00      	add	r7, sp, #0
    d7a8:	6078      	str	r0, [r7, #4]
    uint32_t ui32RetVal = 0;
    d7aa:	2300      	movs	r3, #0
    d7ac:	60fb      	str	r3, [r7, #12]
    if ( !pcBuf )
    d7ae:	687b      	ldr	r3, [r7, #4]
    d7b0:	2b00      	cmp	r3, #0
    d7b2:	d104      	bne.n	d7be <simple_strlen+0x1c>
    {
        return ui32RetVal;
    d7b4:	68fb      	ldr	r3, [r7, #12]
    d7b6:	e009      	b.n	d7cc <simple_strlen+0x2a>
    }

    while ( *pcBuf++ )
    {
        ui32RetVal++;
    d7b8:	68fb      	ldr	r3, [r7, #12]
    d7ba:	3301      	adds	r3, #1
    d7bc:	60fb      	str	r3, [r7, #12]
    while ( *pcBuf++ )
    d7be:	687b      	ldr	r3, [r7, #4]
    d7c0:	1c5a      	adds	r2, r3, #1
    d7c2:	607a      	str	r2, [r7, #4]
    d7c4:	781b      	ldrb	r3, [r3, #0]
    d7c6:	2b00      	cmp	r3, #0
    d7c8:	d1f6      	bne.n	d7b8 <simple_strlen+0x16>
    }
    return ui32RetVal;
    d7ca:	68fb      	ldr	r3, [r7, #12]
}
    d7cc:	4618      	mov	r0, r3
    d7ce:	3714      	adds	r7, #20
    d7d0:	46bd      	mov	sp, r7
    d7d2:	f85d 7b04 	ldr.w	r7, [sp], #4
    d7d6:	4770      	bx	lr

0000d7d8 <padbuffer>:
// Pad a string buffer with pad characters.
//
//*****************************************************************************
static int32_t
padbuffer(char *pcBuf, uint8_t cPadChar, int32_t i32NumChars)
{
    d7d8:	b480      	push	{r7}
    d7da:	b087      	sub	sp, #28
    d7dc:	af00      	add	r7, sp, #0
    d7de:	60f8      	str	r0, [r7, #12]
    d7e0:	460b      	mov	r3, r1
    d7e2:	607a      	str	r2, [r7, #4]
    d7e4:	72fb      	strb	r3, [r7, #11]
    int32_t i32Cnt = 0;
    d7e6:	2300      	movs	r3, #0
    d7e8:	617b      	str	r3, [r7, #20]

    if ( i32NumChars <= 0 )
    d7ea:	687b      	ldr	r3, [r7, #4]
    d7ec:	2b00      	cmp	r3, #0
    d7ee:	dc0c      	bgt.n	d80a <padbuffer+0x32>
    {
        return i32Cnt;
    d7f0:	697b      	ldr	r3, [r7, #20]
    d7f2:	e010      	b.n	d816 <padbuffer+0x3e>
    }

    while ( i32NumChars-- )
    {
        if ( pcBuf )
    d7f4:	68fb      	ldr	r3, [r7, #12]
    d7f6:	2b00      	cmp	r3, #0
    d7f8:	d004      	beq.n	d804 <padbuffer+0x2c>
        {
            *pcBuf++ = cPadChar;
    d7fa:	68fb      	ldr	r3, [r7, #12]
    d7fc:	1c5a      	adds	r2, r3, #1
    d7fe:	60fa      	str	r2, [r7, #12]
    d800:	7afa      	ldrb	r2, [r7, #11]
    d802:	701a      	strb	r2, [r3, #0]
        }
        i32Cnt++;
    d804:	697b      	ldr	r3, [r7, #20]
    d806:	3301      	adds	r3, #1
    d808:	617b      	str	r3, [r7, #20]
    while ( i32NumChars-- )
    d80a:	687b      	ldr	r3, [r7, #4]
    d80c:	1e5a      	subs	r2, r3, #1
    d80e:	607a      	str	r2, [r7, #4]
    d810:	2b00      	cmp	r3, #0
    d812:	d1ef      	bne.n	d7f4 <padbuffer+0x1c>
    }

    return i32Cnt;
    d814:	697b      	ldr	r3, [r7, #20]
}
    d816:	4618      	mov	r0, r3
    d818:	371c      	adds	r7, #28
    d81a:	46bd      	mov	sp, r7
    d81c:	f85d 7b04 	ldr.w	r7, [sp], #4
    d820:	4770      	bx	lr
	...

0000d824 <ftoa>:
    int32_t I32;
    float F;
} i32fl_t;

static int ftoa(float fValue, char *pcBuf, int iPrecision)
{
    d824:	b590      	push	{r4, r7, lr}
    d826:	b08f      	sub	sp, #60	; 0x3c
    d828:	af00      	add	r7, sp, #0
    d82a:	60f8      	str	r0, [r7, #12]
    d82c:	60b9      	str	r1, [r7, #8]
    d82e:	607a      	str	r2, [r7, #4]
    i32fl_t unFloatValue;
    int iExp2, iBufSize;
    int32_t i32Significand, i32IntPart, i32FracPart;
    char *pcBufInitial, *pcBuftmp;

    iBufSize = *(uint32_t*)pcBuf;
    d830:	68bb      	ldr	r3, [r7, #8]
    d832:	681b      	ldr	r3, [r3, #0]
    d834:	627b      	str	r3, [r7, #36]	; 0x24
    if (iBufSize < 4)
    d836:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d838:	2b03      	cmp	r3, #3
    d83a:	dc02      	bgt.n	d842 <ftoa+0x1e>
    {
        return AM_FTOA_ERR_BUFSIZE;
    d83c:	f06f 0302 	mvn.w	r3, #2
    d840:	e0e7      	b.n	da12 <ftoa+0x1ee>
    }

    if (fValue == 0.0f)
    d842:	edd7 7a03 	vldr	s15, [r7, #12]
    d846:	eef5 7a40 	vcmp.f32	s15, #0.0
    d84a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    d84e:	d104      	bne.n	d85a <ftoa+0x36>
    {
        // "0.0"
        *(uint32_t*)pcBuf = 0x00 << 24 | ('0' << 16) | ('.' << 8) | ('0' << 0);
    d850:	68bb      	ldr	r3, [r7, #8]
    d852:	4a72      	ldr	r2, [pc, #456]	; (da1c <ftoa+0x1f8>)
    d854:	601a      	str	r2, [r3, #0]
        return 3;
    d856:	2303      	movs	r3, #3
    d858:	e0db      	b.n	da12 <ftoa+0x1ee>
    }

    pcBufInitial = pcBuf;
    d85a:	68bb      	ldr	r3, [r7, #8]
    d85c:	623b      	str	r3, [r7, #32]

    unFloatValue.F = fValue;
    d85e:	68fb      	ldr	r3, [r7, #12]
    d860:	613b      	str	r3, [r7, #16]

    iExp2 = ((unFloatValue.I32 >> 23) & 0x000000FF) - 127;
    d862:	693b      	ldr	r3, [r7, #16]
    d864:	15db      	asrs	r3, r3, #23
    d866:	b2db      	uxtb	r3, r3
    d868:	3b7f      	subs	r3, #127	; 0x7f
    d86a:	61fb      	str	r3, [r7, #28]
    i32Significand = (unFloatValue.I32 & 0x00FFFFFF) | 0x00800000;
    d86c:	693b      	ldr	r3, [r7, #16]
    d86e:	f3c3 0316 	ubfx	r3, r3, #0, #23
    d872:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
    d876:	61bb      	str	r3, [r7, #24]
    i32FracPart = 0;
    d878:	2300      	movs	r3, #0
    d87a:	633b      	str	r3, [r7, #48]	; 0x30
    i32IntPart = 0;
    d87c:	2300      	movs	r3, #0
    d87e:	637b      	str	r3, [r7, #52]	; 0x34

    if (iExp2 >= 31)
    d880:	69fb      	ldr	r3, [r7, #28]
    d882:	2b1e      	cmp	r3, #30
    d884:	dd02      	ble.n	d88c <ftoa+0x68>
    {
        return AM_FTOA_ERR_VAL_TOO_LARGE;
    d886:	f06f 0301 	mvn.w	r3, #1
    d88a:	e0c2      	b.n	da12 <ftoa+0x1ee>
    }
    else if (iExp2 < -23)
    d88c:	69fb      	ldr	r3, [r7, #28]
    d88e:	f113 0f17 	cmn.w	r3, #23
    d892:	da02      	bge.n	d89a <ftoa+0x76>
    {
        return AM_FTOA_ERR_VAL_TOO_SMALL;
    d894:	f04f 33ff 	mov.w	r3, #4294967295
    d898:	e0bb      	b.n	da12 <ftoa+0x1ee>
    }
    else if (iExp2 >= 23)
    d89a:	69fb      	ldr	r3, [r7, #28]
    d89c:	2b16      	cmp	r3, #22
    d89e:	dd06      	ble.n	d8ae <ftoa+0x8a>
    {
        i32IntPart = i32Significand << (iExp2 - 23);
    d8a0:	69fb      	ldr	r3, [r7, #28]
    d8a2:	3b17      	subs	r3, #23
    d8a4:	69ba      	ldr	r2, [r7, #24]
    d8a6:	fa02 f303 	lsl.w	r3, r2, r3
    d8aa:	637b      	str	r3, [r7, #52]	; 0x34
    d8ac:	e01a      	b.n	d8e4 <ftoa+0xc0>
    }
    else if (iExp2 >= 0)
    d8ae:	69fb      	ldr	r3, [r7, #28]
    d8b0:	2b00      	cmp	r3, #0
    d8b2:	db0f      	blt.n	d8d4 <ftoa+0xb0>
    {
        i32IntPart = i32Significand >> (23 - iExp2);
    d8b4:	69fb      	ldr	r3, [r7, #28]
    d8b6:	f1c3 0317 	rsb	r3, r3, #23
    d8ba:	69ba      	ldr	r2, [r7, #24]
    d8bc:	fa42 f303 	asr.w	r3, r2, r3
    d8c0:	637b      	str	r3, [r7, #52]	; 0x34
        i32FracPart = (i32Significand << (iExp2 + 1)) & 0x00FFFFFF;
    d8c2:	69fb      	ldr	r3, [r7, #28]
    d8c4:	3301      	adds	r3, #1
    d8c6:	69ba      	ldr	r2, [r7, #24]
    d8c8:	fa02 f303 	lsl.w	r3, r2, r3
    d8cc:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    d8d0:	633b      	str	r3, [r7, #48]	; 0x30
    d8d2:	e007      	b.n	d8e4 <ftoa+0xc0>
    }
    else // if (iExp2 < 0)
    {
        i32FracPart = (i32Significand & 0x00FFFFFF) >> -(iExp2 + 1);
    d8d4:	69bb      	ldr	r3, [r7, #24]
    d8d6:	f023 427f 	bic.w	r2, r3, #4278190080	; 0xff000000
    d8da:	69fb      	ldr	r3, [r7, #28]
    d8dc:	43db      	mvns	r3, r3
    d8de:	fa42 f303 	asr.w	r3, r2, r3
    d8e2:	633b      	str	r3, [r7, #48]	; 0x30
    }

    if (unFloatValue.I32 < 0)
    d8e4:	693b      	ldr	r3, [r7, #16]
    d8e6:	2b00      	cmp	r3, #0
    d8e8:	da04      	bge.n	d8f4 <ftoa+0xd0>
    {
        *pcBuf++ = '-';
    d8ea:	68bb      	ldr	r3, [r7, #8]
    d8ec:	1c5a      	adds	r2, r3, #1
    d8ee:	60ba      	str	r2, [r7, #8]
    d8f0:	222d      	movs	r2, #45	; 0x2d
    d8f2:	701a      	strb	r2, [r3, #0]
    }

    if (i32IntPart == 0)
    d8f4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    d8f6:	2b00      	cmp	r3, #0
    d8f8:	d105      	bne.n	d906 <ftoa+0xe2>
    {
        *pcBuf++ = '0';
    d8fa:	68bb      	ldr	r3, [r7, #8]
    d8fc:	1c5a      	adds	r2, r3, #1
    d8fe:	60ba      	str	r2, [r7, #8]
    d900:	2230      	movs	r2, #48	; 0x30
    d902:	701a      	strb	r2, [r3, #0]
    d904:	e021      	b.n	d94a <ftoa+0x126>
    }
    else
    {
        if (i32IntPart > 0)
    d906:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    d908:	2b00      	cmp	r3, #0
    d90a:	dd08      	ble.n	d91e <ftoa+0xfa>
        {
            uint64_to_str(i32IntPart, pcBuf);
    d90c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    d90e:	ea4f 74e3 	mov.w	r4, r3, asr #31
    d912:	68ba      	ldr	r2, [r7, #8]
    d914:	4618      	mov	r0, r3
    d916:	4621      	mov	r1, r4
    d918:	f7ff fe9b 	bl	d652 <uint64_to_str>
    d91c:	e011      	b.n	d942 <ftoa+0x11e>
        }
        else
        {
            *pcBuf++ = '-';
    d91e:	68bb      	ldr	r3, [r7, #8]
    d920:	1c5a      	adds	r2, r3, #1
    d922:	60ba      	str	r2, [r7, #8]
    d924:	222d      	movs	r2, #45	; 0x2d
    d926:	701a      	strb	r2, [r3, #0]
            uint64_to_str(-i32IntPart, pcBuf);
    d928:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    d92a:	425b      	negs	r3, r3
    d92c:	ea4f 74e3 	mov.w	r4, r3, asr #31
    d930:	68ba      	ldr	r2, [r7, #8]
    d932:	4618      	mov	r0, r3
    d934:	4621      	mov	r1, r4
    d936:	f7ff fe8c 	bl	d652 <uint64_to_str>
        }
        while (*pcBuf)    // Get to end of new string
    d93a:	e002      	b.n	d942 <ftoa+0x11e>
        {
            pcBuf++;
    d93c:	68bb      	ldr	r3, [r7, #8]
    d93e:	3301      	adds	r3, #1
    d940:	60bb      	str	r3, [r7, #8]
        while (*pcBuf)    // Get to end of new string
    d942:	68bb      	ldr	r3, [r7, #8]
    d944:	781b      	ldrb	r3, [r3, #0]
    d946:	2b00      	cmp	r3, #0
    d948:	d1f8      	bne.n	d93c <ftoa+0x118>
    }

    //
    // Now, begin the fractional part
    //
    *pcBuf++ = '.';
    d94a:	68bb      	ldr	r3, [r7, #8]
    d94c:	1c5a      	adds	r2, r3, #1
    d94e:	60ba      	str	r2, [r7, #8]
    d950:	222e      	movs	r2, #46	; 0x2e
    d952:	701a      	strb	r2, [r3, #0]

    if (i32FracPart == 0)
    d954:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    d956:	2b00      	cmp	r3, #0
    d958:	d105      	bne.n	d966 <ftoa+0x142>
    {
        *pcBuf++ = '0';
    d95a:	68bb      	ldr	r3, [r7, #8]
    d95c:	1c5a      	adds	r2, r3, #1
    d95e:	60ba      	str	r2, [r7, #8]
    d960:	2230      	movs	r2, #48	; 0x30
    d962:	701a      	strb	r2, [r3, #0]
    d964:	e04f      	b.n	da06 <ftoa+0x1e2>
    }
    else
    {
        int jx, iMax;

        iMax = iBufSize - (pcBuf - pcBufInitial) - 1;
    d966:	68ba      	ldr	r2, [r7, #8]
    d968:	6a3b      	ldr	r3, [r7, #32]
    d96a:	1ad3      	subs	r3, r2, r3
    d96c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    d96e:	1ad3      	subs	r3, r2, r3
    d970:	3b01      	subs	r3, #1
    d972:	617b      	str	r3, [r7, #20]
        iMax = (iMax > iPrecision) ? iPrecision : iMax;
    d974:	697a      	ldr	r2, [r7, #20]
    d976:	687b      	ldr	r3, [r7, #4]
    d978:	4293      	cmp	r3, r2
    d97a:	bfa8      	it	ge
    d97c:	4613      	movge	r3, r2
    d97e:	617b      	str	r3, [r7, #20]

        for (jx = 0; jx < iMax; jx++)
    d980:	2300      	movs	r3, #0
    d982:	62bb      	str	r3, [r7, #40]	; 0x28
    d984:	e015      	b.n	d9b2 <ftoa+0x18e>
        {
            i32FracPart *= 10;
    d986:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    d988:	4613      	mov	r3, r2
    d98a:	009b      	lsls	r3, r3, #2
    d98c:	4413      	add	r3, r2
    d98e:	005b      	lsls	r3, r3, #1
    d990:	633b      	str	r3, [r7, #48]	; 0x30
            *pcBuf++ = (i32FracPart >> 24) + '0';
    d992:	68bb      	ldr	r3, [r7, #8]
    d994:	1c5a      	adds	r2, r3, #1
    d996:	60ba      	str	r2, [r7, #8]
    d998:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    d99a:	1612      	asrs	r2, r2, #24
    d99c:	b2d2      	uxtb	r2, r2
    d99e:	3230      	adds	r2, #48	; 0x30
    d9a0:	b2d2      	uxtb	r2, r2
    d9a2:	701a      	strb	r2, [r3, #0]
            i32FracPart &= 0x00FFFFFF;
    d9a4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    d9a6:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    d9aa:	633b      	str	r3, [r7, #48]	; 0x30
        for (jx = 0; jx < iMax; jx++)
    d9ac:	6abb      	ldr	r3, [r7, #40]	; 0x28
    d9ae:	3301      	adds	r3, #1
    d9b0:	62bb      	str	r3, [r7, #40]	; 0x28
    d9b2:	6aba      	ldr	r2, [r7, #40]	; 0x28
    d9b4:	697b      	ldr	r3, [r7, #20]
    d9b6:	429a      	cmp	r2, r3
    d9b8:	dbe5      	blt.n	d986 <ftoa+0x162>
        // 1.996        4                   1.9960
        //
        // To determine whether to round up, we'll look at what the next
        // decimal value would have been.
        //
        if ( ((i32FracPart * 10) >> 24) >= 5 )
    d9ba:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    d9bc:	4613      	mov	r3, r2
    d9be:	009b      	lsls	r3, r3, #2
    d9c0:	4413      	add	r3, r2
    d9c2:	005b      	lsls	r3, r3, #1
    d9c4:	161b      	asrs	r3, r3, #24
    d9c6:	2b04      	cmp	r3, #4
    d9c8:	dd1d      	ble.n	da06 <ftoa+0x1e2>
        {
            //
            // Yes, we need to round up.
            // Go back through the string and make adjustments as necessary.
            //
            pcBuftmp = pcBuf - 1;
    d9ca:	68bb      	ldr	r3, [r7, #8]
    d9cc:	3b01      	subs	r3, #1
    d9ce:	62fb      	str	r3, [r7, #44]	; 0x2c
            while ( pcBuftmp >= pcBufInitial )
    d9d0:	e015      	b.n	d9fe <ftoa+0x1da>
            {
                if ( *pcBuftmp == '.' )
    d9d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    d9d4:	781b      	ldrb	r3, [r3, #0]
    d9d6:	2b2e      	cmp	r3, #46	; 0x2e
    d9d8:	d00e      	beq.n	d9f8 <ftoa+0x1d4>
                {
                }
                else if ( *pcBuftmp == '9' )
    d9da:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    d9dc:	781b      	ldrb	r3, [r3, #0]
    d9de:	2b39      	cmp	r3, #57	; 0x39
    d9e0:	d103      	bne.n	d9ea <ftoa+0x1c6>
                {
                    *pcBuftmp = '0';
    d9e2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    d9e4:	2230      	movs	r2, #48	; 0x30
    d9e6:	701a      	strb	r2, [r3, #0]
    d9e8:	e006      	b.n	d9f8 <ftoa+0x1d4>
                }
                else
                {
                    *pcBuftmp += 1;
    d9ea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    d9ec:	781b      	ldrb	r3, [r3, #0]
    d9ee:	3301      	adds	r3, #1
    d9f0:	b2da      	uxtb	r2, r3
    d9f2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    d9f4:	701a      	strb	r2, [r3, #0]
                    break;
    d9f6:	e006      	b.n	da06 <ftoa+0x1e2>
                }
                pcBuftmp--;
    d9f8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    d9fa:	3b01      	subs	r3, #1
    d9fc:	62fb      	str	r3, [r7, #44]	; 0x2c
            while ( pcBuftmp >= pcBufInitial )
    d9fe:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    da00:	6a3b      	ldr	r3, [r7, #32]
    da02:	429a      	cmp	r2, r3
    da04:	d2e5      	bcs.n	d9d2 <ftoa+0x1ae>
    }

    //
    // Terminate the string and we're done
    //
    *pcBuf = 0x00;
    da06:	68bb      	ldr	r3, [r7, #8]
    da08:	2200      	movs	r2, #0
    da0a:	701a      	strb	r2, [r3, #0]

    return (pcBuf - pcBufInitial);
    da0c:	68ba      	ldr	r2, [r7, #8]
    da0e:	6a3b      	ldr	r3, [r7, #32]
    da10:	1ad3      	subs	r3, r2, r3
} // ftoa()
    da12:	4618      	mov	r0, r3
    da14:	373c      	adds	r7, #60	; 0x3c
    da16:	46bd      	mov	sp, r7
    da18:	bd90      	pop	{r4, r7, pc}
    da1a:	bf00      	nop
    da1c:	00302e30 	.word	0x00302e30

0000da20 <am_util_stdio_vsprintf>:
//! @return uint32_t representing the number of characters printed.
//
//******************************************************************************
uint32_t
am_util_stdio_vsprintf(char *pcBuf, const char *pcFmt, va_list pArgs)
{
    da20:	b590      	push	{r4, r7, lr}
    da22:	b095      	sub	sp, #84	; 0x54
    da24:	af00      	add	r7, sp, #0
    da26:	60f8      	str	r0, [r7, #12]
    da28:	60b9      	str	r1, [r7, #8]
    da2a:	607a      	str	r2, [r7, #4]
    char *pcStr;
    uint64_t ui64Val;
    int64_t i64Val;
    uint32_t ui32NumChars, ui32CharCnt = 0;
    da2c:	2300      	movs	r3, #0
    da2e:	63fb      	str	r3, [r7, #60]	; 0x3c
    int iWidth, iVal, iPrecision;
    uint8_t ui8CharSpecifier, ui8PadChar;
    bool bLower, bLongLong, bNeg;
    uint32_t ui32strlen = 0;
    da30:	2300      	movs	r3, #0
    da32:	627b      	str	r3, [r7, #36]	; 0x24

    while ( *pcFmt != 0x0 )
    da34:	e2e3      	b.n	dffe <am_util_stdio_vsprintf+0x5de>
    {
        iPrecision = 6;             // printf() default precision for %f is 6
    da36:	2306      	movs	r3, #6
    da38:	633b      	str	r3, [r7, #48]	; 0x30

        if ( *pcFmt != '%' )
    da3a:	68bb      	ldr	r3, [r7, #8]
    da3c:	781b      	ldrb	r3, [r3, #0]
    da3e:	2b25      	cmp	r3, #37	; 0x25
    da40:	d01f      	beq.n	da82 <am_util_stdio_vsprintf+0x62>
        {
            //
            // Accumulate the string portion of the format specification.
            //
            if ( pcBuf )
    da42:	68fb      	ldr	r3, [r7, #12]
    da44:	2b00      	cmp	r3, #0
    da46:	d015      	beq.n	da74 <am_util_stdio_vsprintf+0x54>
            {
                // If '\n', convert to '\r\n'
                if ( *pcFmt == '\n'  &&  g_bTxtXlate )
    da48:	68bb      	ldr	r3, [r7, #8]
    da4a:	781b      	ldrb	r3, [r3, #0]
    da4c:	2b0a      	cmp	r3, #10
    da4e:	d10b      	bne.n	da68 <am_util_stdio_vsprintf+0x48>
    da50:	4bb1      	ldr	r3, [pc, #708]	; (dd18 <am_util_stdio_vsprintf+0x2f8>)
    da52:	781b      	ldrb	r3, [r3, #0]
    da54:	2b00      	cmp	r3, #0
    da56:	d007      	beq.n	da68 <am_util_stdio_vsprintf+0x48>
                {
                    *pcBuf++ = '\r';
    da58:	68fb      	ldr	r3, [r7, #12]
    da5a:	1c5a      	adds	r2, r3, #1
    da5c:	60fa      	str	r2, [r7, #12]
    da5e:	220d      	movs	r2, #13
    da60:	701a      	strb	r2, [r3, #0]
                    ++ui32CharCnt;
    da62:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    da64:	3301      	adds	r3, #1
    da66:	63fb      	str	r3, [r7, #60]	; 0x3c
                }
                *pcBuf++ = *pcFmt;
    da68:	68fb      	ldr	r3, [r7, #12]
    da6a:	1c5a      	adds	r2, r3, #1
    da6c:	60fa      	str	r2, [r7, #12]
    da6e:	68ba      	ldr	r2, [r7, #8]
    da70:	7812      	ldrb	r2, [r2, #0]
    da72:	701a      	strb	r2, [r3, #0]
            }

            ++pcFmt;
    da74:	68bb      	ldr	r3, [r7, #8]
    da76:	3301      	adds	r3, #1
    da78:	60bb      	str	r3, [r7, #8]
            ++ui32CharCnt;
    da7a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    da7c:	3301      	adds	r3, #1
    da7e:	63fb      	str	r3, [r7, #60]	; 0x3c
            continue;
    da80:	e2bd      	b.n	dffe <am_util_stdio_vsprintf+0x5de>
        }

        //
        // Handle the specifier.
        //
        ++pcFmt;
    da82:	68bb      	ldr	r3, [r7, #8]
    da84:	3301      	adds	r3, #1
    da86:	60bb      	str	r3, [r7, #8]
        bLower = bLongLong = false;
    da88:	2300      	movs	r3, #0
    da8a:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
    da8e:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
    da92:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e

        //
        // Default to space as ui8PadChar
        //
        ui8PadChar = ' ';
    da96:	2320      	movs	r3, #32
    da98:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

        if ( *pcFmt == '0' )
    da9c:	68bb      	ldr	r3, [r7, #8]
    da9e:	781b      	ldrb	r3, [r3, #0]
    daa0:	2b30      	cmp	r3, #48	; 0x30
    daa2:	d105      	bne.n	dab0 <am_util_stdio_vsprintf+0x90>
        {
            ui8PadChar = '0';
    daa4:	2330      	movs	r3, #48	; 0x30
    daa6:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
            ++pcFmt;
    daaa:	68bb      	ldr	r3, [r7, #8]
    daac:	3301      	adds	r3, #1
    daae:	60bb      	str	r3, [r7, #8]
        }

        //
        // Width specifier
        //
        iWidth = decstr_to_int(pcFmt, &ui32NumChars);
    dab0:	f107 0310 	add.w	r3, r7, #16
    dab4:	4619      	mov	r1, r3
    dab6:	68b8      	ldr	r0, [r7, #8]
    dab8:	f7ff fd85 	bl	d5c6 <decstr_to_int>
    dabc:	4603      	mov	r3, r0
    dabe:	63bb      	str	r3, [r7, #56]	; 0x38
        pcFmt += ui32NumChars;
    dac0:	693b      	ldr	r3, [r7, #16]
    dac2:	68ba      	ldr	r2, [r7, #8]
    dac4:	4413      	add	r3, r2
    dac6:	60bb      	str	r3, [r7, #8]

        //
        // For now, only support a negative width specifier for %s
        //
        if ( ( *pcFmt != 's' )  &&  ( iWidth < 0 ) )
    dac8:	68bb      	ldr	r3, [r7, #8]
    daca:	781b      	ldrb	r3, [r3, #0]
    dacc:	2b73      	cmp	r3, #115	; 0x73
    dace:	d005      	beq.n	dadc <am_util_stdio_vsprintf+0xbc>
    dad0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    dad2:	2b00      	cmp	r3, #0
    dad4:	da02      	bge.n	dadc <am_util_stdio_vsprintf+0xbc>
        {
            iWidth = -iWidth;
    dad6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    dad8:	425b      	negs	r3, r3
    dada:	63bb      	str	r3, [r7, #56]	; 0x38
        }

        //
        // Check for precision specifier
        //
        if (*pcFmt == '.')
    dadc:	68bb      	ldr	r3, [r7, #8]
    dade:	781b      	ldrb	r3, [r3, #0]
    dae0:	2b2e      	cmp	r3, #46	; 0x2e
    dae2:	d10e      	bne.n	db02 <am_util_stdio_vsprintf+0xe2>
        {
            ++pcFmt;
    dae4:	68bb      	ldr	r3, [r7, #8]
    dae6:	3301      	adds	r3, #1
    dae8:	60bb      	str	r3, [r7, #8]
            iPrecision = decstr_to_int(pcFmt, &ui32NumChars);
    daea:	f107 0310 	add.w	r3, r7, #16
    daee:	4619      	mov	r1, r3
    daf0:	68b8      	ldr	r0, [r7, #8]
    daf2:	f7ff fd68 	bl	d5c6 <decstr_to_int>
    daf6:	4603      	mov	r3, r0
    daf8:	633b      	str	r3, [r7, #48]	; 0x30
            pcFmt += ui32NumChars;
    dafa:	693b      	ldr	r3, [r7, #16]
    dafc:	68ba      	ldr	r2, [r7, #8]
    dafe:	4413      	add	r3, r2
    db00:	60bb      	str	r3, [r7, #8]
        // 'll', which must be a modifier for either 'd', 'i', 'u', 'x', or 'X'
        // (or even 'o', which is not currently supported). Other sub-specifiers
        // like 'hh','h', etc. are not currently handled.
        // Note - 'l' is used in Coremark, a primary reason it's supported here.
        //
        if ( *pcFmt == 'l' )
    db02:	68bb      	ldr	r3, [r7, #8]
    db04:	781b      	ldrb	r3, [r3, #0]
    db06:	2b6c      	cmp	r3, #108	; 0x6c
    db08:	d10c      	bne.n	db24 <am_util_stdio_vsprintf+0x104>
        {
            pcFmt++;
    db0a:	68bb      	ldr	r3, [r7, #8]
    db0c:	3301      	adds	r3, #1
    db0e:	60bb      	str	r3, [r7, #8]
            if ( *pcFmt == 'l' )    // "ll" (long long)
    db10:	68bb      	ldr	r3, [r7, #8]
    db12:	781b      	ldrb	r3, [r3, #0]
    db14:	2b6c      	cmp	r3, #108	; 0x6c
    db16:	d105      	bne.n	db24 <am_util_stdio_vsprintf+0x104>
            {
                pcFmt++;
    db18:	68bb      	ldr	r3, [r7, #8]
    db1a:	3301      	adds	r3, #1
    db1c:	60bb      	str	r3, [r7, #8]
                bLongLong = true;
    db1e:	2301      	movs	r3, #1
    db20:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
            }
        }

        switch ( *pcFmt )
    db24:	68bb      	ldr	r3, [r7, #8]
    db26:	781b      	ldrb	r3, [r3, #0]
    db28:	3b46      	subs	r3, #70	; 0x46
    db2a:	2b32      	cmp	r3, #50	; 0x32
    db2c:	f200 8254 	bhi.w	dfd8 <am_util_stdio_vsprintf+0x5b8>
    db30:	a201      	add	r2, pc, #4	; (adr r2, db38 <am_util_stdio_vsprintf+0x118>)
    db32:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    db36:	bf00      	nop
    db38:	0000df63 	.word	0x0000df63
    db3c:	0000dfd9 	.word	0x0000dfd9
    db40:	0000dfd9 	.word	0x0000dfd9
    db44:	0000dfd9 	.word	0x0000dfd9
    db48:	0000dfd9 	.word	0x0000dfd9
    db4c:	0000dfd9 	.word	0x0000dfd9
    db50:	0000dfd9 	.word	0x0000dfd9
    db54:	0000dfd9 	.word	0x0000dfd9
    db58:	0000dfd9 	.word	0x0000dfd9
    db5c:	0000dfd9 	.word	0x0000dfd9
    db60:	0000dfd9 	.word	0x0000dfd9
    db64:	0000dfd9 	.word	0x0000dfd9
    db68:	0000dfd9 	.word	0x0000dfd9
    db6c:	0000dfd9 	.word	0x0000dfd9
    db70:	0000dfd9 	.word	0x0000dfd9
    db74:	0000dfd9 	.word	0x0000dfd9
    db78:	0000dfd9 	.word	0x0000dfd9
    db7c:	0000dfd9 	.word	0x0000dfd9
    db80:	0000dcff 	.word	0x0000dcff
    db84:	0000dfd9 	.word	0x0000dfd9
    db88:	0000dfd9 	.word	0x0000dfd9
    db8c:	0000dfd9 	.word	0x0000dfd9
    db90:	0000dfd9 	.word	0x0000dfd9
    db94:	0000dfd9 	.word	0x0000dfd9
    db98:	0000dfd9 	.word	0x0000dfd9
    db9c:	0000dfd9 	.word	0x0000dfd9
    dba0:	0000dfd9 	.word	0x0000dfd9
    dba4:	0000dfd9 	.word	0x0000dfd9
    dba8:	0000dfd9 	.word	0x0000dfd9
    dbac:	0000dc05 	.word	0x0000dc05
    dbb0:	0000de2b 	.word	0x0000de2b
    dbb4:	0000dfd9 	.word	0x0000dfd9
    dbb8:	0000df63 	.word	0x0000df63
    dbbc:	0000dfd9 	.word	0x0000dfd9
    dbc0:	0000dfd9 	.word	0x0000dfd9
    dbc4:	0000de2b 	.word	0x0000de2b
    dbc8:	0000dfd9 	.word	0x0000dfd9
    dbcc:	0000dfd9 	.word	0x0000dfd9
    dbd0:	0000dfd9 	.word	0x0000dfd9
    dbd4:	0000dfd9 	.word	0x0000dfd9
    dbd8:	0000dfd9 	.word	0x0000dfd9
    dbdc:	0000dfd9 	.word	0x0000dfd9
    dbe0:	0000dfd9 	.word	0x0000dfd9
    dbe4:	0000dfd9 	.word	0x0000dfd9
    dbe8:	0000dfd9 	.word	0x0000dfd9
    dbec:	0000dc2b 	.word	0x0000dc2b
    dbf0:	0000dfd9 	.word	0x0000dfd9
    dbf4:	0000dd99 	.word	0x0000dd99
    dbf8:	0000dfd9 	.word	0x0000dfd9
    dbfc:	0000dfd9 	.word	0x0000dfd9
    dc00:	0000dcf9 	.word	0x0000dcf9
        {
            case 'c':
                ui8CharSpecifier = va_arg(pArgs, uint32_t);
    dc04:	687b      	ldr	r3, [r7, #4]
    dc06:	1d1a      	adds	r2, r3, #4
    dc08:	607a      	str	r2, [r7, #4]
    dc0a:	681b      	ldr	r3, [r3, #0]
    dc0c:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

                if ( pcBuf )
    dc10:	68fb      	ldr	r3, [r7, #12]
    dc12:	2b00      	cmp	r3, #0
    dc14:	d005      	beq.n	dc22 <am_util_stdio_vsprintf+0x202>
                {
                    *pcBuf++ = ui8CharSpecifier;
    dc16:	68fb      	ldr	r3, [r7, #12]
    dc18:	1c5a      	adds	r2, r3, #1
    dc1a:	60fa      	str	r2, [r7, #12]
    dc1c:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
    dc20:	701a      	strb	r2, [r3, #0]
                }

                ++ui32CharCnt;
    dc22:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    dc24:	3301      	adds	r3, #1
    dc26:	63fb      	str	r3, [r7, #60]	; 0x3c
                break;
    dc28:	e1e6      	b.n	dff8 <am_util_stdio_vsprintf+0x5d8>

            case 's':
                pcStr = va_arg(pArgs, char *);
    dc2a:	687b      	ldr	r3, [r7, #4]
    dc2c:	1d1a      	adds	r2, r3, #4
    dc2e:	607a      	str	r2, [r7, #4]
    dc30:	681b      	ldr	r3, [r3, #0]
    dc32:	64fb      	str	r3, [r7, #76]	; 0x4c
                //
                // For %s, we support the width specifier. If iWidth is negative
                // the string is left-aligned (padding on the right).  Otherwise
                // the string is padded at the beginning with spaces.
                //
                ui32strlen = simple_strlen(pcStr);
    dc34:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
    dc36:	f7ff fdb4 	bl	d7a2 <simple_strlen>
    dc3a:	6278      	str	r0, [r7, #36]	; 0x24
                if ( iWidth > 0 )
    dc3c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    dc3e:	2b00      	cmp	r3, #0
    dc40:	dd2e      	ble.n	dca0 <am_util_stdio_vsprintf+0x280>
                {
                    // Pad the beginning of the string (right-aligned).
                    if ( ui32strlen < iWidth )
    dc42:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    dc44:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    dc46:	429a      	cmp	r2, r3
    dc48:	d22a      	bcs.n	dca0 <am_util_stdio_vsprintf+0x280>
                    {
                        // String needs some padding.
                        iWidth -= ui32strlen;
    dc4a:	6bba      	ldr	r2, [r7, #56]	; 0x38
    dc4c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    dc4e:	1ad3      	subs	r3, r2, r3
    dc50:	63bb      	str	r3, [r7, #56]	; 0x38
                        iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    dc52:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    dc56:	6bba      	ldr	r2, [r7, #56]	; 0x38
    dc58:	4619      	mov	r1, r3
    dc5a:	68f8      	ldr	r0, [r7, #12]
    dc5c:	f7ff fdbc 	bl	d7d8 <padbuffer>
    dc60:	63b8      	str	r0, [r7, #56]	; 0x38
                        pcBuf += pcBuf ? iWidth : 0;
    dc62:	68fb      	ldr	r3, [r7, #12]
    dc64:	2b00      	cmp	r3, #0
    dc66:	d001      	beq.n	dc6c <am_util_stdio_vsprintf+0x24c>
    dc68:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    dc6a:	e000      	b.n	dc6e <am_util_stdio_vsprintf+0x24e>
    dc6c:	2300      	movs	r3, #0
    dc6e:	68fa      	ldr	r2, [r7, #12]
    dc70:	4413      	add	r3, r2
    dc72:	60fb      	str	r3, [r7, #12]
                        ui32CharCnt += iWidth;
    dc74:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    dc76:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    dc78:	4413      	add	r3, r2
    dc7a:	63fb      	str	r3, [r7, #60]	; 0x3c
                        iWidth = 0;
    dc7c:	2300      	movs	r3, #0
    dc7e:	63bb      	str	r3, [r7, #56]	; 0x38
                    }
                }

                while (*pcStr != 0x0)
    dc80:	e00e      	b.n	dca0 <am_util_stdio_vsprintf+0x280>
                {
                    if ( pcBuf )
    dc82:	68fb      	ldr	r3, [r7, #12]
    dc84:	2b00      	cmp	r3, #0
    dc86:	d005      	beq.n	dc94 <am_util_stdio_vsprintf+0x274>
                    {
                        *pcBuf++ = *pcStr;
    dc88:	68fb      	ldr	r3, [r7, #12]
    dc8a:	1c5a      	adds	r2, r3, #1
    dc8c:	60fa      	str	r2, [r7, #12]
    dc8e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
    dc90:	7812      	ldrb	r2, [r2, #0]
    dc92:	701a      	strb	r2, [r3, #0]
                    }

                    ++pcStr;
    dc94:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    dc96:	3301      	adds	r3, #1
    dc98:	64fb      	str	r3, [r7, #76]	; 0x4c
                    ++ui32CharCnt;
    dc9a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    dc9c:	3301      	adds	r3, #1
    dc9e:	63fb      	str	r3, [r7, #60]	; 0x3c
                while (*pcStr != 0x0)
    dca0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    dca2:	781b      	ldrb	r3, [r3, #0]
    dca4:	2b00      	cmp	r3, #0
    dca6:	d1ec      	bne.n	dc82 <am_util_stdio_vsprintf+0x262>
                }

                if ( iWidth )
    dca8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    dcaa:	2b00      	cmp	r3, #0
    dcac:	f000 81a1 	beq.w	dff2 <am_util_stdio_vsprintf+0x5d2>
                {
                    iWidth = -iWidth;
    dcb0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    dcb2:	425b      	negs	r3, r3
    dcb4:	63bb      	str	r3, [r7, #56]	; 0x38

                    // Pad the end of the string (left-aligned).
                    if ( ui32strlen < iWidth )
    dcb6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    dcb8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    dcba:	429a      	cmp	r2, r3
    dcbc:	f080 8199 	bcs.w	dff2 <am_util_stdio_vsprintf+0x5d2>
                    {
                        // String needs some padding.
                        iWidth -= ui32strlen;
    dcc0:	6bba      	ldr	r2, [r7, #56]	; 0x38
    dcc2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    dcc4:	1ad3      	subs	r3, r2, r3
    dcc6:	63bb      	str	r3, [r7, #56]	; 0x38
                        iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    dcc8:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    dccc:	6bba      	ldr	r2, [r7, #56]	; 0x38
    dcce:	4619      	mov	r1, r3
    dcd0:	68f8      	ldr	r0, [r7, #12]
    dcd2:	f7ff fd81 	bl	d7d8 <padbuffer>
    dcd6:	63b8      	str	r0, [r7, #56]	; 0x38
                        pcBuf += pcBuf ? iWidth : 0;
    dcd8:	68fb      	ldr	r3, [r7, #12]
    dcda:	2b00      	cmp	r3, #0
    dcdc:	d001      	beq.n	dce2 <am_util_stdio_vsprintf+0x2c2>
    dcde:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    dce0:	e000      	b.n	dce4 <am_util_stdio_vsprintf+0x2c4>
    dce2:	2300      	movs	r3, #0
    dce4:	68fa      	ldr	r2, [r7, #12]
    dce6:	4413      	add	r3, r2
    dce8:	60fb      	str	r3, [r7, #12]
                        ui32CharCnt += iWidth;
    dcea:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    dcec:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    dcee:	4413      	add	r3, r2
    dcf0:	63fb      	str	r3, [r7, #60]	; 0x3c
                        iWidth = 0;
    dcf2:	2300      	movs	r3, #0
    dcf4:	63bb      	str	r3, [r7, #56]	; 0x38
                    }
                }
                break;
    dcf6:	e17c      	b.n	dff2 <am_util_stdio_vsprintf+0x5d2>

            case 'x':
                bLower = true;
    dcf8:	2301      	movs	r3, #1
    dcfa:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
            case 'X':
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    dcfe:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
    dd02:	2b00      	cmp	r3, #0
    dd04:	d00a      	beq.n	dd1c <am_util_stdio_vsprintf+0x2fc>
    dd06:	687b      	ldr	r3, [r7, #4]
    dd08:	3307      	adds	r3, #7
    dd0a:	f023 0307 	bic.w	r3, r3, #7
    dd0e:	f103 0208 	add.w	r2, r3, #8
    dd12:	607a      	str	r2, [r7, #4]
    dd14:	cb18      	ldmia	r3, {r3, r4}
    dd16:	e007      	b.n	dd28 <am_util_stdio_vsprintf+0x308>
    dd18:	100011f4 	.word	0x100011f4
                                      va_arg(pArgs, uint32_t);
    dd1c:	687b      	ldr	r3, [r7, #4]
    dd1e:	1d1a      	adds	r2, r3, #4
    dd20:	607a      	str	r2, [r7, #4]
    dd22:	681b      	ldr	r3, [r3, #0]
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    dd24:	f04f 0400 	mov.w	r4, #0
    dd28:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40

                if ( iWidth )
    dd2c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    dd2e:	2b00      	cmp	r3, #0
    dd30:	d01e      	beq.n	dd70 <am_util_stdio_vsprintf+0x350>
                {
                    //
                    // Compute # of leading chars
                    //
                    iWidth -= ndigits_in_hex(ui64Val);
    dd32:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
    dd36:	f7ff fc22 	bl	d57e <ndigits_in_hex>
    dd3a:	4602      	mov	r2, r0
    dd3c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    dd3e:	1a9b      	subs	r3, r3, r2
    dd40:	63bb      	str	r3, [r7, #56]	; 0x38

                    iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    dd42:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    dd46:	6bba      	ldr	r2, [r7, #56]	; 0x38
    dd48:	4619      	mov	r1, r3
    dd4a:	68f8      	ldr	r0, [r7, #12]
    dd4c:	f7ff fd44 	bl	d7d8 <padbuffer>
    dd50:	63b8      	str	r0, [r7, #56]	; 0x38
                    pcBuf += pcBuf ? iWidth : 0;
    dd52:	68fb      	ldr	r3, [r7, #12]
    dd54:	2b00      	cmp	r3, #0
    dd56:	d001      	beq.n	dd5c <am_util_stdio_vsprintf+0x33c>
    dd58:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    dd5a:	e000      	b.n	dd5e <am_util_stdio_vsprintf+0x33e>
    dd5c:	2300      	movs	r3, #0
    dd5e:	68fa      	ldr	r2, [r7, #12]
    dd60:	4413      	add	r3, r2
    dd62:	60fb      	str	r3, [r7, #12]
                    ui32CharCnt += iWidth;
    dd64:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    dd66:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    dd68:	4413      	add	r3, r2
    dd6a:	63fb      	str	r3, [r7, #60]	; 0x3c
                    iWidth = 0;
    dd6c:	2300      	movs	r3, #0
    dd6e:	63bb      	str	r3, [r7, #56]	; 0x38
                }

                iVal = uint64_to_hexstr(ui64Val, pcBuf, bLower);
    dd70:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
    dd74:	68fa      	ldr	r2, [r7, #12]
    dd76:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
    dd7a:	f7ff fcb2 	bl	d6e2 <uint64_to_hexstr>
    dd7e:	6378      	str	r0, [r7, #52]	; 0x34

                if ( pcBuf )
    dd80:	68fb      	ldr	r3, [r7, #12]
    dd82:	2b00      	cmp	r3, #0
    dd84:	d003      	beq.n	dd8e <am_util_stdio_vsprintf+0x36e>
                {
                    pcBuf += iVal;
    dd86:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    dd88:	68fa      	ldr	r2, [r7, #12]
    dd8a:	4413      	add	r3, r2
    dd8c:	60fb      	str	r3, [r7, #12]
                }

                ui32CharCnt += iVal;
    dd8e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    dd90:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    dd92:	4413      	add	r3, r2
    dd94:	63fb      	str	r3, [r7, #60]	; 0x3c
                break;
    dd96:	e12f      	b.n	dff8 <am_util_stdio_vsprintf+0x5d8>

            case 'u':
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    dd98:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
    dd9c:	2b00      	cmp	r3, #0
    dd9e:	d008      	beq.n	ddb2 <am_util_stdio_vsprintf+0x392>
    dda0:	687b      	ldr	r3, [r7, #4]
    dda2:	3307      	adds	r3, #7
    dda4:	f023 0307 	bic.w	r3, r3, #7
    dda8:	f103 0208 	add.w	r2, r3, #8
    ddac:	607a      	str	r2, [r7, #4]
    ddae:	cb18      	ldmia	r3, {r3, r4}
    ddb0:	e005      	b.n	ddbe <am_util_stdio_vsprintf+0x39e>
                                      va_arg(pArgs, uint32_t);
    ddb2:	687b      	ldr	r3, [r7, #4]
    ddb4:	1d1a      	adds	r2, r3, #4
    ddb6:	607a      	str	r2, [r7, #4]
    ddb8:	681b      	ldr	r3, [r3, #0]
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    ddba:	f04f 0400 	mov.w	r4, #0
    ddbe:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40

                if ( iWidth )
    ddc2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    ddc4:	2b00      	cmp	r3, #0
    ddc6:	d01e      	beq.n	de06 <am_util_stdio_vsprintf+0x3e6>
                {
                    //
                    // We need to pad the beginning of the value.
                    // Compute # of leading chars
                    //
                    iWidth -= ndigits_in_u64(ui64Val);
    ddc8:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
    ddcc:	f7ff fb99 	bl	d502 <ndigits_in_u64>
    ddd0:	4602      	mov	r2, r0
    ddd2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    ddd4:	1a9b      	subs	r3, r3, r2
    ddd6:	63bb      	str	r3, [r7, #56]	; 0x38

                    iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    ddd8:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    dddc:	6bba      	ldr	r2, [r7, #56]	; 0x38
    ddde:	4619      	mov	r1, r3
    dde0:	68f8      	ldr	r0, [r7, #12]
    dde2:	f7ff fcf9 	bl	d7d8 <padbuffer>
    dde6:	63b8      	str	r0, [r7, #56]	; 0x38
                    pcBuf += pcBuf ? iWidth : 0;
    dde8:	68fb      	ldr	r3, [r7, #12]
    ddea:	2b00      	cmp	r3, #0
    ddec:	d001      	beq.n	ddf2 <am_util_stdio_vsprintf+0x3d2>
    ddee:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    ddf0:	e000      	b.n	ddf4 <am_util_stdio_vsprintf+0x3d4>
    ddf2:	2300      	movs	r3, #0
    ddf4:	68fa      	ldr	r2, [r7, #12]
    ddf6:	4413      	add	r3, r2
    ddf8:	60fb      	str	r3, [r7, #12]
                    ui32CharCnt += iWidth;
    ddfa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    ddfc:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    ddfe:	4413      	add	r3, r2
    de00:	63fb      	str	r3, [r7, #60]	; 0x3c
                    iWidth = 0;
    de02:	2300      	movs	r3, #0
    de04:	63bb      	str	r3, [r7, #56]	; 0x38
                }

                iVal = uint64_to_str(ui64Val, pcBuf);
    de06:	68fa      	ldr	r2, [r7, #12]
    de08:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
    de0c:	f7ff fc21 	bl	d652 <uint64_to_str>
    de10:	6378      	str	r0, [r7, #52]	; 0x34

                if ( pcBuf )
    de12:	68fb      	ldr	r3, [r7, #12]
    de14:	2b00      	cmp	r3, #0
    de16:	d003      	beq.n	de20 <am_util_stdio_vsprintf+0x400>
                {
                    pcBuf += iVal;
    de18:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    de1a:	68fa      	ldr	r2, [r7, #12]
    de1c:	4413      	add	r3, r2
    de1e:	60fb      	str	r3, [r7, #12]
                }

                ui32CharCnt += iVal;
    de20:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    de22:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    de24:	4413      	add	r3, r2
    de26:	63fb      	str	r3, [r7, #60]	; 0x3c
                break;
    de28:	e0e6      	b.n	dff8 <am_util_stdio_vsprintf+0x5d8>
                // Output for a negative number, for example, -5:
                //   %d:-5
                //  %5d:   -5
                // %05d:-0005
                //
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
    de2a:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
    de2e:	2b00      	cmp	r3, #0
    de30:	d008      	beq.n	de44 <am_util_stdio_vsprintf+0x424>
    de32:	687b      	ldr	r3, [r7, #4]
    de34:	3307      	adds	r3, #7
    de36:	f023 0307 	bic.w	r3, r3, #7
    de3a:	f103 0208 	add.w	r2, r3, #8
    de3e:	607a      	str	r2, [r7, #4]
    de40:	cb18      	ldmia	r3, {r3, r4}
    de42:	e005      	b.n	de50 <am_util_stdio_vsprintf+0x430>
                                     va_arg(pArgs, int32_t);
    de44:	687b      	ldr	r3, [r7, #4]
    de46:	1d1a      	adds	r2, r3, #4
    de48:	607a      	str	r2, [r7, #4]
    de4a:	681b      	ldr	r3, [r3, #0]
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
    de4c:	ea4f 74e3 	mov.w	r4, r3, asr #31
    de50:	e9c7 3406 	strd	r3, r4, [r7, #24]

                //
                // Get absolute value
                //
                if ( i64Val < 0 )
    de54:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
    de58:	2b00      	cmp	r3, #0
    de5a:	f174 0300 	sbcs.w	r3, r4, #0
    de5e:	da0a      	bge.n	de76 <am_util_stdio_vsprintf+0x456>
                {
                    ui64Val = -i64Val;          // Get absolute value
    de60:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
    de64:	425b      	negs	r3, r3
    de66:	eb64 0444 	sbc.w	r4, r4, r4, lsl #1
    de6a:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40
                    bNeg = true;
    de6e:	2301      	movs	r3, #1
    de70:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
    de74:	e006      	b.n	de84 <am_util_stdio_vsprintf+0x464>
                }
                else
                {
                    ui64Val = i64Val;
    de76:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
    de7a:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40
                    bNeg = false;
    de7e:	2300      	movs	r3, #0
    de80:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
                }

                if ( iWidth )
    de84:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    de86:	2b00      	cmp	r3, #0
    de88:	d04a      	beq.n	df20 <am_util_stdio_vsprintf+0x500>
                {
                    //
                    // We need to pad the beginning of the value.
                    // Compute # of leading chars
                    //
                    iWidth -= ndigits_in_i64(ui64Val);
    de8a:	e9d7 3410 	ldrd	r3, r4, [r7, #64]	; 0x40
    de8e:	4618      	mov	r0, r3
    de90:	4621      	mov	r1, r4
    de92:	f7ff fb57 	bl	d544 <ndigits_in_i64>
    de96:	4602      	mov	r2, r0
    de98:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    de9a:	1a9b      	subs	r3, r3, r2
    de9c:	63bb      	str	r3, [r7, #56]	; 0x38

                    if ( bNeg )
    de9e:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    dea2:	2b00      	cmp	r3, #0
    dea4:	d011      	beq.n	deca <am_util_stdio_vsprintf+0x4aa>
                    {
                        --iWidth;
    dea6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    dea8:	3b01      	subs	r3, #1
    deaa:	63bb      	str	r3, [r7, #56]	; 0x38

                        //
                        // Allow for the negative sign
                        //
                        if ( ui8PadChar == '0' )
    deac:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    deb0:	2b30      	cmp	r3, #48	; 0x30
    deb2:	d10a      	bne.n	deca <am_util_stdio_vsprintf+0x4aa>
                        {
                            //
                            // Print the neg sign BEFORE the leading zeros
                            //
                            if ( pcBuf )
    deb4:	68fb      	ldr	r3, [r7, #12]
    deb6:	2b00      	cmp	r3, #0
    deb8:	d004      	beq.n	dec4 <am_util_stdio_vsprintf+0x4a4>
                            {
                                *pcBuf++ = '-';
    deba:	68fb      	ldr	r3, [r7, #12]
    debc:	1c5a      	adds	r2, r3, #1
    debe:	60fa      	str	r2, [r7, #12]
    dec0:	222d      	movs	r2, #45	; 0x2d
    dec2:	701a      	strb	r2, [r3, #0]
                            }

                            ++ui32CharCnt;
    dec4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    dec6:	3301      	adds	r3, #1
    dec8:	63fb      	str	r3, [r7, #60]	; 0x3c
                        }
                    }

                    iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    deca:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    dece:	6bba      	ldr	r2, [r7, #56]	; 0x38
    ded0:	4619      	mov	r1, r3
    ded2:	68f8      	ldr	r0, [r7, #12]
    ded4:	f7ff fc80 	bl	d7d8 <padbuffer>
    ded8:	63b8      	str	r0, [r7, #56]	; 0x38
                    pcBuf += pcBuf ? iWidth : 0;
    deda:	68fb      	ldr	r3, [r7, #12]
    dedc:	2b00      	cmp	r3, #0
    dede:	d001      	beq.n	dee4 <am_util_stdio_vsprintf+0x4c4>
    dee0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    dee2:	e000      	b.n	dee6 <am_util_stdio_vsprintf+0x4c6>
    dee4:	2300      	movs	r3, #0
    dee6:	68fa      	ldr	r2, [r7, #12]
    dee8:	4413      	add	r3, r2
    deea:	60fb      	str	r3, [r7, #12]
                    ui32CharCnt += iWidth;
    deec:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    deee:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    def0:	4413      	add	r3, r2
    def2:	63fb      	str	r3, [r7, #60]	; 0x3c
                    iWidth = 0;
    def4:	2300      	movs	r3, #0
    def6:	63bb      	str	r3, [r7, #56]	; 0x38

                    if ( bNeg  &&  (ui8PadChar == ' ') )
    def8:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    defc:	2b00      	cmp	r3, #0
    defe:	d01e      	beq.n	df3e <am_util_stdio_vsprintf+0x51e>
    df00:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    df04:	2b20      	cmp	r3, #32
    df06:	d11a      	bne.n	df3e <am_util_stdio_vsprintf+0x51e>
                    {
                        //
                        // Print the neg sign AFTER the leading blanks
                        //
                        if ( pcBuf )
    df08:	68fb      	ldr	r3, [r7, #12]
    df0a:	2b00      	cmp	r3, #0
    df0c:	d004      	beq.n	df18 <am_util_stdio_vsprintf+0x4f8>
                        {
                            *pcBuf++ = '-';
    df0e:	68fb      	ldr	r3, [r7, #12]
    df10:	1c5a      	adds	r2, r3, #1
    df12:	60fa      	str	r2, [r7, #12]
    df14:	222d      	movs	r2, #45	; 0x2d
    df16:	701a      	strb	r2, [r3, #0]
                        }

                        ++ui32CharCnt;
    df18:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    df1a:	3301      	adds	r3, #1
    df1c:	63fb      	str	r3, [r7, #60]	; 0x3c
    df1e:	e00e      	b.n	df3e <am_util_stdio_vsprintf+0x51e>
                    }
                }
                else
                {
                    if ( bNeg )
    df20:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    df24:	2b00      	cmp	r3, #0
    df26:	d00a      	beq.n	df3e <am_util_stdio_vsprintf+0x51e>
                    {
                        if ( pcBuf )
    df28:	68fb      	ldr	r3, [r7, #12]
    df2a:	2b00      	cmp	r3, #0
    df2c:	d004      	beq.n	df38 <am_util_stdio_vsprintf+0x518>
                        {
                            *pcBuf++ = '-';
    df2e:	68fb      	ldr	r3, [r7, #12]
    df30:	1c5a      	adds	r2, r3, #1
    df32:	60fa      	str	r2, [r7, #12]
    df34:	222d      	movs	r2, #45	; 0x2d
    df36:	701a      	strb	r2, [r3, #0]
                        }
                        ++ui32CharCnt;
    df38:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    df3a:	3301      	adds	r3, #1
    df3c:	63fb      	str	r3, [r7, #60]	; 0x3c
                    }
                }

                iVal = uint64_to_str(ui64Val, pcBuf);
    df3e:	68fa      	ldr	r2, [r7, #12]
    df40:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
    df44:	f7ff fb85 	bl	d652 <uint64_to_str>
    df48:	6378      	str	r0, [r7, #52]	; 0x34

                if ( pcBuf )
    df4a:	68fb      	ldr	r3, [r7, #12]
    df4c:	2b00      	cmp	r3, #0
    df4e:	d003      	beq.n	df58 <am_util_stdio_vsprintf+0x538>
                {
                    pcBuf += iVal;
    df50:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    df52:	68fa      	ldr	r2, [r7, #12]
    df54:	4413      	add	r3, r2
    df56:	60fb      	str	r3, [r7, #12]
                }

                ui32CharCnt += iVal;
    df58:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    df5a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    df5c:	4413      	add	r3, r2
    df5e:	63fb      	str	r3, [r7, #60]	; 0x3c
                break;
    df60:	e04a      	b.n	dff8 <am_util_stdio_vsprintf+0x5d8>


            case 'f':
            case 'F':
                if ( pcBuf )
    df62:	68fb      	ldr	r3, [r7, #12]
    df64:	2b00      	cmp	r3, #0
    df66:	d046      	beq.n	dff6 <am_util_stdio_vsprintf+0x5d6>
                {
                    float fValue = va_arg(pArgs, double);
    df68:	687b      	ldr	r3, [r7, #4]
    df6a:	3307      	adds	r3, #7
    df6c:	f023 0307 	bic.w	r3, r3, #7
    df70:	f103 0208 	add.w	r2, r3, #8
    df74:	607a      	str	r2, [r7, #4]
    df76:	cb18      	ldmia	r3, {r3, r4}
    df78:	4618      	mov	r0, r3
    df7a:	4621      	mov	r1, r4
    df7c:	f7fe f8c0 	bl	c100 <__aeabi_d2f>
    df80:	4603      	mov	r3, r0
    df82:	617b      	str	r3, [r7, #20]

                    //
                    // pcBuf is an input (size of buffer) and also an output of ftoa()
                    //
                    *(uint32_t*)pcBuf = 20;
    df84:	68fb      	ldr	r3, [r7, #12]
    df86:	2214      	movs	r2, #20
    df88:	601a      	str	r2, [r3, #0]

                    iVal = ftoa(fValue, pcBuf, iPrecision);
    df8a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    df8c:	68f9      	ldr	r1, [r7, #12]
    df8e:	6978      	ldr	r0, [r7, #20]
    df90:	f7ff fc48 	bl	d824 <ftoa>
    df94:	6378      	str	r0, [r7, #52]	; 0x34
                    if ( iVal < 0 )
    df96:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    df98:	2b00      	cmp	r3, #0
    df9a:	da14      	bge.n	dfc6 <am_util_stdio_vsprintf+0x5a6>
                    {
                        uint32_t u32PrntErrVal;
                        if ( iVal == AM_FTOA_ERR_VAL_TOO_SMALL )
    df9c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    df9e:	f1b3 3fff 	cmp.w	r3, #4294967295
    dfa2:	d102      	bne.n	dfaa <am_util_stdio_vsprintf+0x58a>
                        {
                            u32PrntErrVal = (0x00 << 24) | ('0' << 16) |
    dfa4:	4b1e      	ldr	r3, [pc, #120]	; (e020 <am_util_stdio_vsprintf+0x600>)
    dfa6:	62bb      	str	r3, [r7, #40]	; 0x28
    dfa8:	e008      	b.n	dfbc <am_util_stdio_vsprintf+0x59c>
                                            ('.' << 8)   | ('0' << 0);  // "0.0"
                        }
                        else if ( iVal == AM_FTOA_ERR_VAL_TOO_LARGE )
    dfaa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    dfac:	f113 0f02 	cmn.w	r3, #2
    dfb0:	d102      	bne.n	dfb8 <am_util_stdio_vsprintf+0x598>
                        {
                            u32PrntErrVal = (0x00 << 24) | ('#' << 16) |
    dfb2:	4b1c      	ldr	r3, [pc, #112]	; (e024 <am_util_stdio_vsprintf+0x604>)
    dfb4:	62bb      	str	r3, [r7, #40]	; 0x28
    dfb6:	e001      	b.n	dfbc <am_util_stdio_vsprintf+0x59c>
                                            ('.' << 8)   | ('#' << 0);  // "#.#"
                        }
                        else
                        {
                            u32PrntErrVal = (0x00 << 24) | ('?' << 16) |
    dfb8:	4b1b      	ldr	r3, [pc, #108]	; (e028 <am_util_stdio_vsprintf+0x608>)
    dfba:	62bb      	str	r3, [r7, #40]	; 0x28
                                            ('.' << 8)   | ('?' << 0);  // "?.?"
                        }
                        *(uint32_t*)pcBuf = u32PrntErrVal;
    dfbc:	68fb      	ldr	r3, [r7, #12]
    dfbe:	6aba      	ldr	r2, [r7, #40]	; 0x28
    dfc0:	601a      	str	r2, [r3, #0]
                        iVal = 3;
    dfc2:	2303      	movs	r3, #3
    dfc4:	637b      	str	r3, [r7, #52]	; 0x34
                    }
                    ui32CharCnt += iVal;
    dfc6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    dfc8:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    dfca:	4413      	add	r3, r2
    dfcc:	63fb      	str	r3, [r7, #60]	; 0x3c
                    pcBuf += iVal;
    dfce:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    dfd0:	68fa      	ldr	r2, [r7, #12]
    dfd2:	4413      	add	r3, r2
    dfd4:	60fb      	str	r3, [r7, #12]
                }
                break;
    dfd6:	e00e      	b.n	dff6 <am_util_stdio_vsprintf+0x5d6>
            // For non-handled specifiers, we'll just print the character.
            // e.g. this will allow the normal printing of a '%' using
            // "%%".
            //
            default:
                if ( pcBuf )
    dfd8:	68fb      	ldr	r3, [r7, #12]
    dfda:	2b00      	cmp	r3, #0
    dfdc:	d005      	beq.n	dfea <am_util_stdio_vsprintf+0x5ca>
                {
                    *pcBuf++ = *pcFmt;
    dfde:	68fb      	ldr	r3, [r7, #12]
    dfe0:	1c5a      	adds	r2, r3, #1
    dfe2:	60fa      	str	r2, [r7, #12]
    dfe4:	68ba      	ldr	r2, [r7, #8]
    dfe6:	7812      	ldrb	r2, [r2, #0]
    dfe8:	701a      	strb	r2, [r3, #0]
                }

                ++ui32CharCnt;
    dfea:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    dfec:	3301      	adds	r3, #1
    dfee:	63fb      	str	r3, [r7, #60]	; 0x3c
                break;
    dff0:	e002      	b.n	dff8 <am_util_stdio_vsprintf+0x5d8>
                break;
    dff2:	bf00      	nop
    dff4:	e000      	b.n	dff8 <am_util_stdio_vsprintf+0x5d8>
                break;
    dff6:	bf00      	nop
        } // switch()

        //
        // Bump the format specification to the next character
        //
        ++pcFmt;
    dff8:	68bb      	ldr	r3, [r7, #8]
    dffa:	3301      	adds	r3, #1
    dffc:	60bb      	str	r3, [r7, #8]
    while ( *pcFmt != 0x0 )
    dffe:	68bb      	ldr	r3, [r7, #8]
    e000:	781b      	ldrb	r3, [r3, #0]
    e002:	2b00      	cmp	r3, #0
    e004:	f47f ad17 	bne.w	da36 <am_util_stdio_vsprintf+0x16>
    } // while ()

    //
    // Terminate the string
    //
    if ( pcBuf )
    e008:	68fb      	ldr	r3, [r7, #12]
    e00a:	2b00      	cmp	r3, #0
    e00c:	d002      	beq.n	e014 <am_util_stdio_vsprintf+0x5f4>
    {
        *pcBuf = 0x0;
    e00e:	68fb      	ldr	r3, [r7, #12]
    e010:	2200      	movs	r2, #0
    e012:	701a      	strb	r2, [r3, #0]
    }

    return (ui32CharCnt);
    e014:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
}
    e016:	4618      	mov	r0, r3
    e018:	3754      	adds	r7, #84	; 0x54
    e01a:	46bd      	mov	sp, r7
    e01c:	bd90      	pop	{r4, r7, pc}
    e01e:	bf00      	nop
    e020:	00302e30 	.word	0x00302e30
    e024:	00232e23 	.word	0x00232e23
    e028:	003f2e3f 	.word	0x003f2e3f

0000e02c <am_util_stdio_printf>:
//! @return uint32_t representing the number of characters printed.
//
// *****************************************************************************
uint32_t
am_util_stdio_printf(const char *pcFmt, ...)
{
    e02c:	b40f      	push	{r0, r1, r2, r3}
    e02e:	b580      	push	{r7, lr}
    e030:	b082      	sub	sp, #8
    e032:	af00      	add	r7, sp, #0

    //
    // Convert to the desired string.
    //
    va_list pArgs;
    va_start(pArgs, pcFmt);
    e034:	f107 0314 	add.w	r3, r7, #20
    e038:	603b      	str	r3, [r7, #0]
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
    e03a:	683a      	ldr	r2, [r7, #0]
    e03c:	6939      	ldr	r1, [r7, #16]
    e03e:	4808      	ldr	r0, [pc, #32]	; (e060 <am_util_stdio_printf+0x34>)
    e040:	f7ff fcee 	bl	da20 <am_util_stdio_vsprintf>
    e044:	6078      	str	r0, [r7, #4]
    va_end(pArgs);

    //
    // This is where we print the buffer to the configured interface.
    //
    g_pfnCharPrint(g_prfbuf);
    e046:	4b07      	ldr	r3, [pc, #28]	; (e064 <am_util_stdio_printf+0x38>)
    e048:	681b      	ldr	r3, [r3, #0]
    e04a:	4805      	ldr	r0, [pc, #20]	; (e060 <am_util_stdio_printf+0x34>)
    e04c:	4798      	blx	r3

    //
    // return the number of characters printed.
    //
    return ui32NumChars;
    e04e:	687b      	ldr	r3, [r7, #4]
}
    e050:	4618      	mov	r0, r3
    e052:	3708      	adds	r7, #8
    e054:	46bd      	mov	sp, r7
    e056:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    e05a:	b004      	add	sp, #16
    e05c:	4770      	bx	lr
    e05e:	bf00      	nop
    e060:	100010f4 	.word	0x100010f4
    e064:	10001840 	.word	0x10001840

0000e068 <am_util_stdio_terminal_clear>:
//! @return None.
//
//*****************************************************************************
void
am_util_stdio_terminal_clear(void)
{
    e068:	b580      	push	{r7, lr}
    e06a:	af00      	add	r7, sp, #0
    // left corner.
    // We'll first print a number of spaces, which helps get the ITM in sync
    // with AM Flash, especially after a reset event or a system clock
    // frequency change.
    //
    am_util_stdio_printf("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
    e06c:	4802      	ldr	r0, [pc, #8]	; (e078 <am_util_stdio_terminal_clear+0x10>)
    e06e:	f7ff ffdd 	bl	e02c <am_util_stdio_printf>
}
    e072:	bf00      	nop
    e074:	bd80      	pop	{r7, pc}
    e076:	bf00      	nop
    e078:	00010a90 	.word	0x00010a90

0000e07c <am_bsp_low_power_init>:
//! @return None.
//
//*****************************************************************************
void
am_bsp_low_power_init(void)
{
    e07c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
am_bsp_itm_printf_disable(void)
{
    //
    // Disable the ITM/TPIU
    //
    am_hal_itm_disable();
    e07e:	f001 ffd5 	bl	1002c <am_hal_itm_disable>

    //
    // Detach the ITM interface from the STDIO driver.
    //
    am_util_stdio_printf_init(0);
    e082:	2000      	movs	r0, #0
    e084:	f7ff f94e 	bl	d324 <am_util_stdio_printf_init>

    //
    // Disconnect the SWO pin
    //
    am_hal_gpio_pinconfig(AM_BSP_GPIO_ITM_SWO, g_AM_HAL_GPIO_DISABLE);
    e088:	4b12      	ldr	r3, [pc, #72]	; (e0d4 <am_bsp_low_power_init+0x58>)
    e08a:	4f13      	ldr	r7, [pc, #76]	; (e0d8 <am_bsp_low_power_init+0x5c>)
    e08c:	6819      	ldr	r1, [r3, #0]
    e08e:	2029      	movs	r0, #41	; 0x29
    e090:	f000 fdf8 	bl	ec84 <am_hal_gpio_pinconfig>
    am_hal_pwrctrl_low_power_init();
    e094:	f002 f952 	bl	1033c <am_hal_pwrctrl_low_power_init>
    am_hal_rtc_osc_select(AM_HAL_RTC_OSC_LFRC);
    e098:	2001      	movs	r0, #1
    e09a:	f002 f98d 	bl	103b8 <am_hal_rtc_osc_select>
    am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_XTAL_STOP, 0);
    e09e:	2100      	movs	r1, #0
    e0a0:	2003      	movs	r0, #3
    e0a2:	f000 fa7f 	bl	e5a4 <am_hal_clkgen_control>
    am_hal_rtc_osc_disable();
    e0a6:	f002 f993 	bl	103d0 <am_hal_rtc_osc_disable>
    e0aa:	480c      	ldr	r0, [pc, #48]	; (e0dc <am_bsp_low_power_init+0x60>)
        am_hal_gpio_pinconfig(ui32GPIONumber, g_AM_HAL_GPIO_OUTPUT);
    e0ac:	6806      	ldr	r6, [r0, #0]
    for (ux = 0; ux < AM_BSP_NUM_LEDS; ux++)
    e0ae:	2400      	movs	r4, #0
        ui32GPIONumber = am_bsp_psLEDs[ux].ui32GPIONumber;
    e0b0:	f857 5034 	ldr.w	r5, [r7, r4, lsl #3]
        am_hal_gpio_pinconfig(ui32GPIONumber, g_AM_HAL_GPIO_OUTPUT);
    e0b4:	4631      	mov	r1, r6
    e0b6:	4628      	mov	r0, r5
    e0b8:	f000 fde4 	bl	ec84 <am_hal_gpio_pinconfig>
        am_hal_gpio_state_write(ui32GPIONumber, AM_HAL_GPIO_OUTPUT_TRISTATE_DISABLE);
    e0bc:	2103      	movs	r1, #3
    e0be:	4628      	mov	r0, r5
    e0c0:	f000 ff22 	bl	ef08 <am_hal_gpio_state_write>
    for (ux = 0; ux < AM_BSP_NUM_LEDS; ux++)
    e0c4:	3401      	adds	r4, #1
        am_hal_gpio_state_write(ui32GPIONumber, AM_HAL_GPIO_OUTPUT_CLEAR);
    e0c6:	4628      	mov	r0, r5
    e0c8:	2100      	movs	r1, #0
    e0ca:	f000 ff1d 	bl	ef08 <am_hal_gpio_state_write>
    for (ux = 0; ux < AM_BSP_NUM_LEDS; ux++)
    e0ce:	2c05      	cmp	r4, #5
    e0d0:	d1ee      	bne.n	e0b0 <am_bsp_low_power_init+0x34>
} // am_bsp_low_power_init()
    e0d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    e0d4:	00010b94 	.word	0x00010b94
    e0d8:	10001094 	.word	0x10001094
    e0dc:	00010b98 	.word	0x00010b98

0000e0e0 <am_bsp_itm_printf_enable>:
{
    e0e0:	b500      	push	{lr}
    g_ui32PrintInterface = AM_BSP_PRINT_INFC_SWO;
    e0e2:	4b0b      	ldr	r3, [pc, #44]	; (e110 <am_bsp_itm_printf_enable+0x30>)
{
    e0e4:	b087      	sub	sp, #28
    g_ui32PrintInterface = AM_BSP_PRINT_INFC_SWO;
    e0e6:	2201      	movs	r2, #1
    e0e8:	601a      	str	r2, [r3, #0]
    am_hal_itm_enable();
    e0ea:	f001 ff81 	bl	fff0 <am_hal_itm_enable>
    TPIUcfg.ui32SetItmBaud = AM_HAL_TPIU_BAUD_1M;
    e0ee:	a806      	add	r0, sp, #24
    e0f0:	4908      	ldr	r1, [pc, #32]	; (e114 <am_bsp_itm_printf_enable+0x34>)
    e0f2:	f840 1d14 	str.w	r1, [r0, #-20]!
    am_hal_tpiu_enable(&TPIUcfg);
    e0f6:	f002 f999 	bl	1042c <am_hal_tpiu_enable>
    am_hal_gpio_pinconfig(AM_BSP_GPIO_ITM_SWO, g_AM_BSP_GPIO_ITM_SWO);
    e0fa:	4b07      	ldr	r3, [pc, #28]	; (e118 <am_bsp_itm_printf_enable+0x38>)
    e0fc:	2029      	movs	r0, #41	; 0x29
    e0fe:	6819      	ldr	r1, [r3, #0]
    e100:	f000 fdc0 	bl	ec84 <am_hal_gpio_pinconfig>
    am_util_stdio_printf_init(am_hal_itm_print);
    e104:	4805      	ldr	r0, [pc, #20]	; (e11c <am_bsp_itm_printf_enable+0x3c>)
    e106:	f7ff f90d 	bl	d324 <am_util_stdio_printf_init>
} // am_bsp_itm_printf_enable()
    e10a:	b007      	add	sp, #28
    e10c:	f85d fb04 	ldr.w	pc, [sp], #4
    e110:	100011f8 	.word	0x100011f8
    e114:	000f4240 	.word	0x000f4240
    e118:	00010b4c 	.word	0x00010b4c
    e11c:	000100d5 	.word	0x000100d5

0000e120 <am_bsp_iom_pins_enable>:
    uint32_t ui32Combined;

    //
    // Validate parameters
    //
    if ( ui32Module > AM_REG_IOM_NUM_MODULES )
    e120:	2806      	cmp	r0, #6
    e122:	d81d      	bhi.n	e160 <am_bsp_iom_pins_enable+0x40>
        // FPGA supports only IOM0 and 1.
        //
        return;
    }

    ui32Combined = ((ui32Module << 2) | eIOMMode);
    e124:	ea41 0180 	orr.w	r1, r1, r0, lsl #2
{
    e128:	b508      	push	{r3, lr}

    switch ( ui32Combined )
    e12a:	2915      	cmp	r1, #21
    e12c:	d817      	bhi.n	e15e <am_bsp_iom_pins_enable+0x3e>
    e12e:	e8df f011 	tbh	[pc, r1, lsl #1]
    e132:	00ce      	.short	0x00ce
    e134:	001600c2 	.word	0x001600c2
    e138:	00ac0016 	.word	0x00ac0016
    e13c:	001600a0 	.word	0x001600a0
    e140:	008a0016 	.word	0x008a0016
    e144:	0016007e 	.word	0x0016007e
    e148:	00680016 	.word	0x00680016
    e14c:	0016005c 	.word	0x0016005c
    e150:	00460016 	.word	0x00460016
    e154:	0016003a 	.word	0x0016003a
    e158:	00240016 	.word	0x00240016
    e15c:	0018      	.short	0x0018
    e15e:	bd08      	pop	{r3, pc}
    e160:	4770      	bx	lr
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM4_SCL,  g_AM_BSP_GPIO_IOM4_SCL);
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM4_SDA,  g_AM_BSP_GPIO_IOM4_SDA);
            break;

        case ((5 << 2) | AM_HAL_IOM_I2C_MODE):
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM5_SCL,  g_AM_BSP_GPIO_IOM5_SCL);
    e162:	4b66      	ldr	r3, [pc, #408]	; (e2fc <am_bsp_iom_pins_enable+0x1dc>)
    e164:	2030      	movs	r0, #48	; 0x30
    e166:	6819      	ldr	r1, [r3, #0]
    e168:	f000 fd8c 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM5_SDA,  g_AM_BSP_GPIO_IOM5_SDA);
    e16c:	4a64      	ldr	r2, [pc, #400]	; (e300 <am_bsp_iom_pins_enable+0x1e0>)
    e16e:	2031      	movs	r0, #49	; 0x31
    e170:	6811      	ldr	r1, [r2, #0]
#endif // AM_APOLLO3_GPIO

        default:
            break;
    }
} // am_bsp_iom_pins_enable()
    e172:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM5_SDA,  g_AM_BSP_GPIO_IOM5_SDA);
    e176:	f000 bd85 	b.w	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM5_SCK,  g_AM_BSP_GPIO_IOM5_SCK);
    e17a:	4962      	ldr	r1, [pc, #392]	; (e304 <am_bsp_iom_pins_enable+0x1e4>)
    e17c:	2030      	movs	r0, #48	; 0x30
    e17e:	6809      	ldr	r1, [r1, #0]
    e180:	f000 fd80 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM5_MISO, g_AM_BSP_GPIO_IOM5_MISO);
    e184:	4b60      	ldr	r3, [pc, #384]	; (e308 <am_bsp_iom_pins_enable+0x1e8>)
    e186:	2031      	movs	r0, #49	; 0x31
    e188:	6819      	ldr	r1, [r3, #0]
    e18a:	f000 fd7b 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM5_MOSI, g_AM_BSP_GPIO_IOM5_MOSI);
    e18e:	4a5f      	ldr	r2, [pc, #380]	; (e30c <am_bsp_iom_pins_enable+0x1ec>)
    e190:	202f      	movs	r0, #47	; 0x2f
    e192:	6811      	ldr	r1, [r2, #0]
    e194:	f000 fd76 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM5_CS,   g_AM_BSP_GPIO_IOM5_CS);
    e198:	495d      	ldr	r1, [pc, #372]	; (e310 <am_bsp_iom_pins_enable+0x1f0>)
    e19a:	2010      	movs	r0, #16
    e19c:	6809      	ldr	r1, [r1, #0]
} // am_bsp_iom_pins_enable()
    e19e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM5_CS,   g_AM_BSP_GPIO_IOM5_CS);
    e1a2:	f000 bd6f 	b.w	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM4_SCL,  g_AM_BSP_GPIO_IOM4_SCL);
    e1a6:	4b5b      	ldr	r3, [pc, #364]	; (e314 <am_bsp_iom_pins_enable+0x1f4>)
    e1a8:	2027      	movs	r0, #39	; 0x27
    e1aa:	6819      	ldr	r1, [r3, #0]
    e1ac:	f000 fd6a 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM4_SDA,  g_AM_BSP_GPIO_IOM4_SDA);
    e1b0:	4a59      	ldr	r2, [pc, #356]	; (e318 <am_bsp_iom_pins_enable+0x1f8>)
    e1b2:	2028      	movs	r0, #40	; 0x28
    e1b4:	6811      	ldr	r1, [r2, #0]
} // am_bsp_iom_pins_enable()
    e1b6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM4_SDA,  g_AM_BSP_GPIO_IOM4_SDA);
    e1ba:	f000 bd63 	b.w	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM4_SCK,  g_AM_BSP_GPIO_IOM4_SCK);
    e1be:	4957      	ldr	r1, [pc, #348]	; (e31c <am_bsp_iom_pins_enable+0x1fc>)
    e1c0:	2027      	movs	r0, #39	; 0x27
    e1c2:	6809      	ldr	r1, [r1, #0]
    e1c4:	f000 fd5e 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM4_MISO, g_AM_BSP_GPIO_IOM4_MISO);
    e1c8:	4b55      	ldr	r3, [pc, #340]	; (e320 <am_bsp_iom_pins_enable+0x200>)
    e1ca:	2028      	movs	r0, #40	; 0x28
    e1cc:	6819      	ldr	r1, [r3, #0]
    e1ce:	f000 fd59 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM4_MOSI, g_AM_BSP_GPIO_IOM4_MOSI);
    e1d2:	4a54      	ldr	r2, [pc, #336]	; (e324 <am_bsp_iom_pins_enable+0x204>)
    e1d4:	202c      	movs	r0, #44	; 0x2c
    e1d6:	6811      	ldr	r1, [r2, #0]
    e1d8:	f000 fd54 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM4_CS,   g_AM_BSP_GPIO_IOM4_CS);
    e1dc:	4952      	ldr	r1, [pc, #328]	; (e328 <am_bsp_iom_pins_enable+0x208>)
    e1de:	200d      	movs	r0, #13
    e1e0:	6809      	ldr	r1, [r1, #0]
} // am_bsp_iom_pins_enable()
    e1e2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM4_CS,   g_AM_BSP_GPIO_IOM4_CS);
    e1e6:	f000 bd4d 	b.w	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM3_SCL,  g_AM_BSP_GPIO_IOM3_SCL);
    e1ea:	4b50      	ldr	r3, [pc, #320]	; (e32c <am_bsp_iom_pins_enable+0x20c>)
    e1ec:	202a      	movs	r0, #42	; 0x2a
    e1ee:	6819      	ldr	r1, [r3, #0]
    e1f0:	f000 fd48 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM3_SDA,  g_AM_BSP_GPIO_IOM3_SDA);
    e1f4:	4a4e      	ldr	r2, [pc, #312]	; (e330 <am_bsp_iom_pins_enable+0x210>)
    e1f6:	202b      	movs	r0, #43	; 0x2b
    e1f8:	6811      	ldr	r1, [r2, #0]
} // am_bsp_iom_pins_enable()
    e1fa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM3_SDA,  g_AM_BSP_GPIO_IOM3_SDA);
    e1fe:	f000 bd41 	b.w	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM3_SCK,  g_AM_BSP_GPIO_IOM3_SCK);
    e202:	494c      	ldr	r1, [pc, #304]	; (e334 <am_bsp_iom_pins_enable+0x214>)
    e204:	202a      	movs	r0, #42	; 0x2a
    e206:	6809      	ldr	r1, [r1, #0]
    e208:	f000 fd3c 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM3_MISO, g_AM_BSP_GPIO_IOM3_MISO);
    e20c:	4b4a      	ldr	r3, [pc, #296]	; (e338 <am_bsp_iom_pins_enable+0x218>)
    e20e:	202b      	movs	r0, #43	; 0x2b
    e210:	6819      	ldr	r1, [r3, #0]
    e212:	f000 fd37 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM3_MOSI, g_AM_BSP_GPIO_IOM3_MOSI);
    e216:	4a49      	ldr	r2, [pc, #292]	; (e33c <am_bsp_iom_pins_enable+0x21c>)
    e218:	2026      	movs	r0, #38	; 0x26
    e21a:	6811      	ldr	r1, [r2, #0]
    e21c:	f000 fd32 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM3_CS,   g_AM_BSP_GPIO_IOM3_CS);
    e220:	4947      	ldr	r1, [pc, #284]	; (e340 <am_bsp_iom_pins_enable+0x220>)
    e222:	200c      	movs	r0, #12
    e224:	6809      	ldr	r1, [r1, #0]
} // am_bsp_iom_pins_enable()
    e226:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM3_CS,   g_AM_BSP_GPIO_IOM3_CS);
    e22a:	f000 bd2b 	b.w	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM2_SCL,  g_AM_BSP_GPIO_IOM2_SCL);
    e22e:	4b45      	ldr	r3, [pc, #276]	; (e344 <am_bsp_iom_pins_enable+0x224>)
    e230:	201b      	movs	r0, #27
    e232:	6819      	ldr	r1, [r3, #0]
    e234:	f000 fd26 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM2_SDA,  g_AM_BSP_GPIO_IOM2_SDA);
    e238:	4a43      	ldr	r2, [pc, #268]	; (e348 <am_bsp_iom_pins_enable+0x228>)
    e23a:	2019      	movs	r0, #25
    e23c:	6811      	ldr	r1, [r2, #0]
} // am_bsp_iom_pins_enable()
    e23e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM2_SDA,  g_AM_BSP_GPIO_IOM2_SDA);
    e242:	f000 bd1f 	b.w	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM2_SCK,  g_AM_BSP_GPIO_IOM2_SCK);
    e246:	4941      	ldr	r1, [pc, #260]	; (e34c <am_bsp_iom_pins_enable+0x22c>)
    e248:	201b      	movs	r0, #27
    e24a:	6809      	ldr	r1, [r1, #0]
    e24c:	f000 fd1a 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM2_MISO, g_AM_BSP_GPIO_IOM2_MISO);
    e250:	4b3f      	ldr	r3, [pc, #252]	; (e350 <am_bsp_iom_pins_enable+0x230>)
    e252:	2019      	movs	r0, #25
    e254:	6819      	ldr	r1, [r3, #0]
    e256:	f000 fd15 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM2_MOSI, g_AM_BSP_GPIO_IOM2_MOSI);
    e25a:	4a3e      	ldr	r2, [pc, #248]	; (e354 <am_bsp_iom_pins_enable+0x234>)
    e25c:	201c      	movs	r0, #28
    e25e:	6811      	ldr	r1, [r2, #0]
    e260:	f000 fd10 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM2_CS,   g_AM_BSP_GPIO_IOM2_CS);
    e264:	493c      	ldr	r1, [pc, #240]	; (e358 <am_bsp_iom_pins_enable+0x238>)
    e266:	200f      	movs	r0, #15
    e268:	6809      	ldr	r1, [r1, #0]
} // am_bsp_iom_pins_enable()
    e26a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM2_CS,   g_AM_BSP_GPIO_IOM2_CS);
    e26e:	f000 bd09 	b.w	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM1_SCL,  g_AM_BSP_GPIO_IOM1_SCL);
    e272:	4b3a      	ldr	r3, [pc, #232]	; (e35c <am_bsp_iom_pins_enable+0x23c>)
    e274:	2008      	movs	r0, #8
    e276:	6819      	ldr	r1, [r3, #0]
    e278:	f000 fd04 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM1_SDA,  g_AM_BSP_GPIO_IOM1_SDA);
    e27c:	4a38      	ldr	r2, [pc, #224]	; (e360 <am_bsp_iom_pins_enable+0x240>)
    e27e:	2009      	movs	r0, #9
    e280:	6811      	ldr	r1, [r2, #0]
} // am_bsp_iom_pins_enable()
    e282:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM1_SDA,  g_AM_BSP_GPIO_IOM1_SDA);
    e286:	f000 bcfd 	b.w	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM1_SCK,  g_AM_BSP_GPIO_IOM1_SCK);
    e28a:	4936      	ldr	r1, [pc, #216]	; (e364 <am_bsp_iom_pins_enable+0x244>)
    e28c:	2008      	movs	r0, #8
    e28e:	6809      	ldr	r1, [r1, #0]
    e290:	f000 fcf8 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM1_MISO, g_AM_BSP_GPIO_IOM1_MISO);
    e294:	4b34      	ldr	r3, [pc, #208]	; (e368 <am_bsp_iom_pins_enable+0x248>)
    e296:	2009      	movs	r0, #9
    e298:	6819      	ldr	r1, [r3, #0]
    e29a:	f000 fcf3 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM1_MOSI, g_AM_BSP_GPIO_IOM1_MOSI);
    e29e:	4a33      	ldr	r2, [pc, #204]	; (e36c <am_bsp_iom_pins_enable+0x24c>)
    e2a0:	200a      	movs	r0, #10
    e2a2:	6811      	ldr	r1, [r2, #0]
    e2a4:	f000 fcee 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM1_CS,   g_AM_BSP_GPIO_IOM1_CS);
    e2a8:	4931      	ldr	r1, [pc, #196]	; (e370 <am_bsp_iom_pins_enable+0x250>)
    e2aa:	200e      	movs	r0, #14
    e2ac:	6809      	ldr	r1, [r1, #0]
} // am_bsp_iom_pins_enable()
    e2ae:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM1_CS,   g_AM_BSP_GPIO_IOM1_CS);
    e2b2:	f000 bce7 	b.w	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM0_SCL,  g_AM_BSP_GPIO_IOM0_SCL);
    e2b6:	4b2f      	ldr	r3, [pc, #188]	; (e374 <am_bsp_iom_pins_enable+0x254>)
    e2b8:	2005      	movs	r0, #5
    e2ba:	6819      	ldr	r1, [r3, #0]
    e2bc:	f000 fce2 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM0_SDA,  g_AM_BSP_GPIO_IOM0_SDA);
    e2c0:	4a2d      	ldr	r2, [pc, #180]	; (e378 <am_bsp_iom_pins_enable+0x258>)
    e2c2:	2006      	movs	r0, #6
    e2c4:	6811      	ldr	r1, [r2, #0]
} // am_bsp_iom_pins_enable()
    e2c6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM0_SDA,  g_AM_BSP_GPIO_IOM0_SDA);
    e2ca:	f000 bcdb 	b.w	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM0_SCK,  g_AM_BSP_GPIO_IOM0_SCK);
    e2ce:	492b      	ldr	r1, [pc, #172]	; (e37c <am_bsp_iom_pins_enable+0x25c>)
    e2d0:	2005      	movs	r0, #5
    e2d2:	6809      	ldr	r1, [r1, #0]
    e2d4:	f000 fcd6 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM0_MISO, g_AM_BSP_GPIO_IOM0_MISO);
    e2d8:	4b29      	ldr	r3, [pc, #164]	; (e380 <am_bsp_iom_pins_enable+0x260>)
    e2da:	2006      	movs	r0, #6
    e2dc:	6819      	ldr	r1, [r3, #0]
    e2de:	f000 fcd1 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM0_MOSI, g_AM_BSP_GPIO_IOM0_MOSI);
    e2e2:	4a28      	ldr	r2, [pc, #160]	; (e384 <am_bsp_iom_pins_enable+0x264>)
    e2e4:	2007      	movs	r0, #7
    e2e6:	6811      	ldr	r1, [r2, #0]
    e2e8:	f000 fccc 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM0_CS,   g_AM_BSP_GPIO_IOM0_CS);
    e2ec:	4926      	ldr	r1, [pc, #152]	; (e388 <am_bsp_iom_pins_enable+0x268>)
    e2ee:	200b      	movs	r0, #11
    e2f0:	6809      	ldr	r1, [r1, #0]
} // am_bsp_iom_pins_enable()
    e2f2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM0_CS,   g_AM_BSP_GPIO_IOM0_CS);
    e2f6:	f000 bcc5 	b.w	ec84 <am_hal_gpio_pinconfig>
    e2fa:	bf00      	nop
    e2fc:	00010b44 	.word	0x00010b44
    e300:	00010b48 	.word	0x00010b48
    e304:	00010b40 	.word	0x00010b40
    e308:	00010b38 	.word	0x00010b38
    e30c:	00010b3c 	.word	0x00010b3c
    e310:	00010b34 	.word	0x00010b34
    e314:	00010b2c 	.word	0x00010b2c
    e318:	00010b30 	.word	0x00010b30
    e31c:	00010b28 	.word	0x00010b28
    e320:	00010b20 	.word	0x00010b20
    e324:	00010b24 	.word	0x00010b24
    e328:	00010b1c 	.word	0x00010b1c
    e32c:	00010b14 	.word	0x00010b14
    e330:	00010b18 	.word	0x00010b18
    e334:	00010b10 	.word	0x00010b10
    e338:	00010b08 	.word	0x00010b08
    e33c:	00010b0c 	.word	0x00010b0c
    e340:	00010b04 	.word	0x00010b04
    e344:	00010afc 	.word	0x00010afc
    e348:	00010b00 	.word	0x00010b00
    e34c:	00010af8 	.word	0x00010af8
    e350:	00010af0 	.word	0x00010af0
    e354:	00010af4 	.word	0x00010af4
    e358:	00010aec 	.word	0x00010aec
    e35c:	00010ae4 	.word	0x00010ae4
    e360:	00010ae8 	.word	0x00010ae8
    e364:	00010ae0 	.word	0x00010ae0
    e368:	00010ad8 	.word	0x00010ad8
    e36c:	00010adc 	.word	0x00010adc
    e370:	00010ad4 	.word	0x00010ad4
    e374:	00010acc 	.word	0x00010acc
    e378:	00010ad0 	.word	0x00010ad0
    e37c:	00010ac8 	.word	0x00010ac8
    e380:	00010ac0 	.word	0x00010ac0
    e384:	00010ac4 	.word	0x00010ac4
    e388:	00010abc 	.word	0x00010abc

0000e38c <am_bsp_iom_pins_disable>:
    uint32_t ui32Combined;

    //
    // Validate parameters
    //
    if ( ui32Module > AM_REG_IOM_NUM_MODULES )
    e38c:	2806      	cmp	r0, #6
    e38e:	d812      	bhi.n	e3b6 <am_bsp_iom_pins_disable+0x2a>
        // FPGA supports only IOM0 and 1.
        //
        return;
    }

    ui32Combined = ((ui32Module << 2) | eIOMMode);
    e390:	ea41 0180 	orr.w	r1, r1, r0, lsl #2
{
    e394:	b510      	push	{r4, lr}

    switch ( ui32Combined )
    e396:	2915      	cmp	r1, #21
    e398:	d80c      	bhi.n	e3b4 <am_bsp_iom_pins_disable+0x28>
    e39a:	e8df f001 	tbb	[pc, r1]
    e39e:	adb9      	.short	0xadb9
    e3a0:	8d990b0b 	.word	0x8d990b0b
    e3a4:	6d790b0b 	.word	0x6d790b0b
    e3a8:	4d590b0b 	.word	0x4d590b0b
    e3ac:	2d390b0b 	.word	0x2d390b0b
    e3b0:	0d190b0b 	.word	0x0d190b0b
    e3b4:	bd10      	pop	{r4, pc}
    e3b6:	4770      	bx	lr
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM4_SCL,  g_AM_HAL_GPIO_DISABLE);
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM4_SDA,  g_AM_HAL_GPIO_DISABLE);
            break;

        case ((5 << 2) | AM_HAL_IOM_I2C_MODE):
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM5_SCL,  g_AM_HAL_GPIO_DISABLE);
    e3b8:	4b5f      	ldr	r3, [pc, #380]	; (e538 <am_bsp_iom_pins_disable+0x1ac>)
    e3ba:	681c      	ldr	r4, [r3, #0]
    e3bc:	2030      	movs	r0, #48	; 0x30
    e3be:	4621      	mov	r1, r4
    e3c0:	f000 fc60 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM5_SDA,  g_AM_HAL_GPIO_DISABLE);
    e3c4:	4621      	mov	r1, r4
    e3c6:	2031      	movs	r0, #49	; 0x31
            break;
#endif // AM_APOLLO3_GPIO
        default:
            break;
    }
} // am_bsp_iom_pins_disable()
    e3c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM5_SDA,  g_AM_HAL_GPIO_DISABLE);
    e3cc:	f000 bc5a 	b.w	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM5_SCK,  g_AM_HAL_GPIO_DISABLE);
    e3d0:	4859      	ldr	r0, [pc, #356]	; (e538 <am_bsp_iom_pins_disable+0x1ac>)
    e3d2:	6804      	ldr	r4, [r0, #0]
    e3d4:	2030      	movs	r0, #48	; 0x30
    e3d6:	4621      	mov	r1, r4
    e3d8:	f000 fc54 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM5_MISO, g_AM_HAL_GPIO_DISABLE);
    e3dc:	4621      	mov	r1, r4
    e3de:	2031      	movs	r0, #49	; 0x31
    e3e0:	f000 fc50 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM5_MOSI, g_AM_HAL_GPIO_DISABLE);
    e3e4:	4621      	mov	r1, r4
    e3e6:	202f      	movs	r0, #47	; 0x2f
    e3e8:	f000 fc4c 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM5_CS,   g_AM_HAL_GPIO_DISABLE);
    e3ec:	4621      	mov	r1, r4
    e3ee:	2010      	movs	r0, #16
} // am_bsp_iom_pins_disable()
    e3f0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM5_CS,   g_AM_HAL_GPIO_DISABLE);
    e3f4:	f000 bc46 	b.w	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM4_SCL,  g_AM_HAL_GPIO_DISABLE);
    e3f8:	4a4f      	ldr	r2, [pc, #316]	; (e538 <am_bsp_iom_pins_disable+0x1ac>)
    e3fa:	6814      	ldr	r4, [r2, #0]
    e3fc:	2027      	movs	r0, #39	; 0x27
    e3fe:	4621      	mov	r1, r4
    e400:	f000 fc40 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM4_SDA,  g_AM_HAL_GPIO_DISABLE);
    e404:	4621      	mov	r1, r4
    e406:	2028      	movs	r0, #40	; 0x28
} // am_bsp_iom_pins_disable()
    e408:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM4_SDA,  g_AM_HAL_GPIO_DISABLE);
    e40c:	f000 bc3a 	b.w	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM4_SCK,  g_AM_HAL_GPIO_DISABLE);
    e410:	4949      	ldr	r1, [pc, #292]	; (e538 <am_bsp_iom_pins_disable+0x1ac>)
    e412:	680c      	ldr	r4, [r1, #0]
    e414:	2027      	movs	r0, #39	; 0x27
    e416:	4621      	mov	r1, r4
    e418:	f000 fc34 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM4_MISO, g_AM_HAL_GPIO_DISABLE);
    e41c:	4621      	mov	r1, r4
    e41e:	2028      	movs	r0, #40	; 0x28
    e420:	f000 fc30 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM4_MOSI, g_AM_HAL_GPIO_DISABLE);
    e424:	4621      	mov	r1, r4
    e426:	202c      	movs	r0, #44	; 0x2c
    e428:	f000 fc2c 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM4_CS,   g_AM_HAL_GPIO_DISABLE);
    e42c:	4621      	mov	r1, r4
    e42e:	200d      	movs	r0, #13
} // am_bsp_iom_pins_disable()
    e430:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM4_CS,   g_AM_HAL_GPIO_DISABLE);
    e434:	f000 bc26 	b.w	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM3_SCL,  g_AM_HAL_GPIO_DISABLE);
    e438:	4b3f      	ldr	r3, [pc, #252]	; (e538 <am_bsp_iom_pins_disable+0x1ac>)
    e43a:	681c      	ldr	r4, [r3, #0]
    e43c:	202a      	movs	r0, #42	; 0x2a
    e43e:	4621      	mov	r1, r4
    e440:	f000 fc20 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM3_SDA,  g_AM_HAL_GPIO_DISABLE);
    e444:	4621      	mov	r1, r4
    e446:	202b      	movs	r0, #43	; 0x2b
} // am_bsp_iom_pins_disable()
    e448:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM3_SDA,  g_AM_HAL_GPIO_DISABLE);
    e44c:	f000 bc1a 	b.w	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM3_SCK,  g_AM_HAL_GPIO_DISABLE);
    e450:	4839      	ldr	r0, [pc, #228]	; (e538 <am_bsp_iom_pins_disable+0x1ac>)
    e452:	6804      	ldr	r4, [r0, #0]
    e454:	202a      	movs	r0, #42	; 0x2a
    e456:	4621      	mov	r1, r4
    e458:	f000 fc14 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM3_MISO, g_AM_HAL_GPIO_DISABLE);
    e45c:	4621      	mov	r1, r4
    e45e:	202b      	movs	r0, #43	; 0x2b
    e460:	f000 fc10 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM3_MOSI, g_AM_HAL_GPIO_DISABLE);
    e464:	4621      	mov	r1, r4
    e466:	2026      	movs	r0, #38	; 0x26
    e468:	f000 fc0c 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM3_CS,   g_AM_HAL_GPIO_DISABLE);
    e46c:	4621      	mov	r1, r4
    e46e:	200c      	movs	r0, #12
} // am_bsp_iom_pins_disable()
    e470:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM3_CS,   g_AM_HAL_GPIO_DISABLE);
    e474:	f000 bc06 	b.w	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM2_SCL,  g_AM_HAL_GPIO_DISABLE);
    e478:	4a2f      	ldr	r2, [pc, #188]	; (e538 <am_bsp_iom_pins_disable+0x1ac>)
    e47a:	6814      	ldr	r4, [r2, #0]
    e47c:	201b      	movs	r0, #27
    e47e:	4621      	mov	r1, r4
    e480:	f000 fc00 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM2_SDA,  g_AM_HAL_GPIO_DISABLE);
    e484:	4621      	mov	r1, r4
    e486:	2019      	movs	r0, #25
} // am_bsp_iom_pins_disable()
    e488:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM2_SDA,  g_AM_HAL_GPIO_DISABLE);
    e48c:	f000 bbfa 	b.w	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM2_SCK,  g_AM_HAL_GPIO_DISABLE);
    e490:	4929      	ldr	r1, [pc, #164]	; (e538 <am_bsp_iom_pins_disable+0x1ac>)
    e492:	680c      	ldr	r4, [r1, #0]
    e494:	201b      	movs	r0, #27
    e496:	4621      	mov	r1, r4
    e498:	f000 fbf4 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM2_MISO, g_AM_HAL_GPIO_DISABLE);
    e49c:	4621      	mov	r1, r4
    e49e:	2019      	movs	r0, #25
    e4a0:	f000 fbf0 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM2_MOSI, g_AM_HAL_GPIO_DISABLE);
    e4a4:	4621      	mov	r1, r4
    e4a6:	201c      	movs	r0, #28
    e4a8:	f000 fbec 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM2_CS,   g_AM_HAL_GPIO_DISABLE);
    e4ac:	4621      	mov	r1, r4
    e4ae:	200f      	movs	r0, #15
} // am_bsp_iom_pins_disable()
    e4b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM2_CS,   g_AM_HAL_GPIO_DISABLE);
    e4b4:	f000 bbe6 	b.w	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM1_SCL,  g_AM_HAL_GPIO_DISABLE);
    e4b8:	4b1f      	ldr	r3, [pc, #124]	; (e538 <am_bsp_iom_pins_disable+0x1ac>)
    e4ba:	681c      	ldr	r4, [r3, #0]
    e4bc:	2008      	movs	r0, #8
    e4be:	4621      	mov	r1, r4
    e4c0:	f000 fbe0 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM1_SDA,  g_AM_HAL_GPIO_DISABLE);
    e4c4:	4621      	mov	r1, r4
    e4c6:	2009      	movs	r0, #9
} // am_bsp_iom_pins_disable()
    e4c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM1_SDA,  g_AM_HAL_GPIO_DISABLE);
    e4cc:	f000 bbda 	b.w	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM1_SCK,  g_AM_HAL_GPIO_DISABLE);
    e4d0:	4819      	ldr	r0, [pc, #100]	; (e538 <am_bsp_iom_pins_disable+0x1ac>)
    e4d2:	6804      	ldr	r4, [r0, #0]
    e4d4:	2008      	movs	r0, #8
    e4d6:	4621      	mov	r1, r4
    e4d8:	f000 fbd4 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM1_MISO, g_AM_HAL_GPIO_DISABLE);
    e4dc:	4621      	mov	r1, r4
    e4de:	2009      	movs	r0, #9
    e4e0:	f000 fbd0 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM1_MOSI, g_AM_HAL_GPIO_DISABLE);
    e4e4:	4621      	mov	r1, r4
    e4e6:	200a      	movs	r0, #10
    e4e8:	f000 fbcc 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM1_CS,   g_AM_HAL_GPIO_DISABLE);
    e4ec:	4621      	mov	r1, r4
    e4ee:	200e      	movs	r0, #14
} // am_bsp_iom_pins_disable()
    e4f0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM1_CS,   g_AM_HAL_GPIO_DISABLE);
    e4f4:	f000 bbc6 	b.w	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM0_SCL,  g_AM_HAL_GPIO_DISABLE);
    e4f8:	4a0f      	ldr	r2, [pc, #60]	; (e538 <am_bsp_iom_pins_disable+0x1ac>)
    e4fa:	6814      	ldr	r4, [r2, #0]
    e4fc:	2005      	movs	r0, #5
    e4fe:	4621      	mov	r1, r4
    e500:	f000 fbc0 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM0_SDA,  g_AM_HAL_GPIO_DISABLE);
    e504:	4621      	mov	r1, r4
    e506:	2006      	movs	r0, #6
} // am_bsp_iom_pins_disable()
    e508:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM0_SDA,  g_AM_HAL_GPIO_DISABLE);
    e50c:	f000 bbba 	b.w	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM0_SCK,  g_AM_HAL_GPIO_DISABLE);
    e510:	4909      	ldr	r1, [pc, #36]	; (e538 <am_bsp_iom_pins_disable+0x1ac>)
    e512:	680c      	ldr	r4, [r1, #0]
    e514:	2005      	movs	r0, #5
    e516:	4621      	mov	r1, r4
    e518:	f000 fbb4 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM0_MISO, g_AM_HAL_GPIO_DISABLE);
    e51c:	4621      	mov	r1, r4
    e51e:	2006      	movs	r0, #6
    e520:	f000 fbb0 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM0_MOSI, g_AM_HAL_GPIO_DISABLE);
    e524:	4621      	mov	r1, r4
    e526:	2007      	movs	r0, #7
    e528:	f000 fbac 	bl	ec84 <am_hal_gpio_pinconfig>
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM0_CS,   g_AM_HAL_GPIO_DISABLE);
    e52c:	4621      	mov	r1, r4
    e52e:	200b      	movs	r0, #11
} // am_bsp_iom_pins_disable()
    e530:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            am_hal_gpio_pinconfig(AM_BSP_GPIO_IOM0_CS,   g_AM_HAL_GPIO_DISABLE);
    e534:	f000 bba6 	b.w	ec84 <am_hal_gpio_pinconfig>
    e538:	00010b94 	.word	0x00010b94

0000e53c <am_hal_cachectrl_config>:
//  Configure the cache with given and recommended settings, but do not enable.
//
//*****************************************************************************
uint32_t
am_hal_cachectrl_config(const am_hal_cachectrl_config_t *psConfig)
{
    e53c:	b530      	push	{r4, r5, lr}
    e53e:	b083      	sub	sp, #12
    e540:	4605      	mov	r5, r0
    // accomplish that is to shut down the ID bits, leaving the cache enabled.
    // Once the instr and data caches have been disabled, we can safely set
    // any new configuration, including disabling the controller.
    //
#if AM_CMSIS_REGS
    AM_CRITICAL_BEGIN
    e542:	f000 fd29 	bl	ef98 <am_hal_interrupt_master_disable>
    CACHECTRL->CACHECFG &=
    e546:	4c11      	ldr	r4, [pc, #68]	; (e58c <am_hal_cachectrl_config+0x50>)
    AM_CRITICAL_BEGIN
    e548:	9001      	str	r0, [sp, #4]
    CACHECTRL->CACHECFG &=
    e54a:	6823      	ldr	r3, [r4, #0]
    e54c:	f423 7040 	bic.w	r0, r3, #768	; 0x300
    e550:	6020      	str	r0, [r4, #0]
        ~(CACHECTRL_CACHECFG_DCACHE_ENABLE_Msk  |
          CACHECTRL_CACHECFG_ICACHE_ENABLE_Msk);
    AM_CRITICAL_END
    e552:	9801      	ldr	r0, [sp, #4]
    e554:	f000 fd24 	bl	efa0 <am_hal_interrupt_master_set>
        _VAL2FLD(CACHECTRL_CACHECFG_ENABLE, 0)                              |
        _VAL2FLD(CACHECTRL_CACHECFG_CACHE_CLKGATE, 1)                       |
        _VAL2FLD(CACHECTRL_CACHECFG_CACHE_LS, 0)                            |
        _VAL2FLD(CACHECTRL_CACHECFG_DATA_CLKGATE, 1)                        |
        _VAL2FLD(CACHECTRL_CACHECFG_ENABLE_MONITOR, 0)                      |
        _VAL2FLD(CACHECTRL_CACHECFG_LRU, psConfig->bLRU)                    |
    e558:	78eb      	ldrb	r3, [r5, #3]
        _VAL2FLD(CACHECTRL_CACHECFG_CONFIG, psConfig->eDescript)            |
    e55a:	7828      	ldrb	r0, [r5, #0]
        ((psConfig->eEnableNCregions << CACHECTRL_CACHECFG_ENABLE_NC0_Pos) &
    e55c:	78a9      	ldrb	r1, [r5, #2]
            (CACHECTRL_CACHECFG_ENABLE_NC1_Msk      |
             CACHECTRL_CACHECFG_ENABLE_NC0_Msk))                            |
        ((psConfig->eMode << CACHECTRL_CACHECFG_ICACHE_ENABLE_Pos) &
    e55e:	786a      	ldrb	r2, [r5, #1]
        _VAL2FLD(CACHECTRL_CACHECFG_CONFIG, psConfig->eDescript)            |
    e560:	0100      	lsls	r0, r0, #4
        _VAL2FLD(CACHECTRL_CACHECFG_LRU, psConfig->bLRU)                    |
    e562:	005d      	lsls	r5, r3, #1
    e564:	f005 0302 	and.w	r3, r5, #2
        _VAL2FLD(CACHECTRL_CACHECFG_CONFIG, psConfig->eDescript)            |
    e568:	b2c5      	uxtb	r5, r0
        _VAL2FLD(CACHECTRL_CACHECFG_LRU, psConfig->bLRU)                    |
    e56a:	432b      	orrs	r3, r5
             CACHECTRL_CACHECFG_ENABLE_NC0_Msk))                            |
    e56c:	f443 1080 	orr.w	r0, r3, #1048576	; 0x100000
        ((psConfig->eEnableNCregions << CACHECTRL_CACHECFG_ENABLE_NC0_Pos) &
    e570:	0089      	lsls	r1, r1, #2
             CACHECTRL_CACHECFG_ENABLE_NC0_Msk))                            |
    e572:	f440 6380 	orr.w	r3, r0, #1024	; 0x400
        ((psConfig->eEnableNCregions << CACHECTRL_CACHECFG_ENABLE_NC0_Pos) &
    e576:	f001 050c 	and.w	r5, r1, #12
        ((psConfig->eMode << CACHECTRL_CACHECFG_ICACHE_ENABLE_Pos) &
    e57a:	0212      	lsls	r2, r2, #8
    e57c:	f402 7040 	and.w	r0, r2, #768	; 0x300
             CACHECTRL_CACHECFG_ENABLE_NC0_Msk))                            |
    e580:	432b      	orrs	r3, r5
    e582:	4303      	orrs	r3, r0

#endif // AM_CMSIS_REGS

    return AM_HAL_STATUS_SUCCESS;

} // am_hal_cachectrl_enable()
    e584:	2000      	movs	r0, #0
    CACHECTRL->CACHECFG =
    e586:	6023      	str	r3, [r4, #0]
} // am_hal_cachectrl_enable()
    e588:	b003      	add	sp, #12
    e58a:	bd30      	pop	{r4, r5, pc}
    e58c:	40018000 	.word	0x40018000

0000e590 <am_hal_cachectrl_enable>:
//*****************************************************************************
uint32_t
am_hal_cachectrl_enable(void)
{
#if AM_CMSIS_REGS
    CACHECTRL->CACHECFG |= _VAL2FLD(CACHECTRL_CACHECFG_ENABLE, 1);
    e590:	4a03      	ldr	r2, [pc, #12]	; (e5a0 <am_hal_cachectrl_enable+0x10>)
    e592:	6813      	ldr	r3, [r2, #0]
    e594:	f043 0001 	orr.w	r0, r3, #1
    e598:	6010      	str	r0, [r2, #0]
#else // AM_CMSIS_REGS
    AM_REG(CACHECTRL, CACHECFG) |= AM_REG_CACHECTRL_CACHECFG_ENABLE(1);
#endif // AM_CMSIS_REGS

    return AM_HAL_STATUS_SUCCESS;
} // am_hal_cachectrl_enable()
    e59a:	2000      	movs	r0, #0
    e59c:	4770      	bx	lr
    e59e:	bf00      	nop
    e5a0:	40018000 	.word	0x40018000

0000e5a4 <am_hal_clkgen_control>:
am_hal_clkgen_control(am_hal_clkgen_control_e eControl, void *pArgs)
{
    uint32_t ui32Regval;

#if AM_CMSIS_REGS
    switch ( eControl )
    e5a4:	2809      	cmp	r0, #9
    e5a6:	d852      	bhi.n	e64e <am_hal_clkgen_control+0xaa>
    e5a8:	e8df f000 	tbb	[pc, r0]
    e5ac:	2b21190d 	.word	0x2b21190d
    e5b0:	51513d33 	.word	0x51513d33
    e5b4:	0547      	.short	0x0547
            ui32Regval |= _VAL2FLD(CLKGEN_HFADJ_HFADJEN, CLKGEN_HFADJ_HFADJEN_EN);
            CLKGEN->HFADJ = ui32Regval;
            break;

        case AM_HAL_CLKGEN_CONTROL_HFADJ_DISABLE:
            CLKGEN->HFADJ_b.HFADJEN = 0;
    e5b6:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000


    //
    // Return success status.
    //
    return AM_HAL_STATUS_SUCCESS;
    e5ba:	2000      	movs	r0, #0
            CLKGEN->HFADJ_b.HFADJEN = 0;
    e5bc:	6a1a      	ldr	r2, [r3, #32]
    e5be:	f36f 0200 	bfc	r2, #0, #1
    e5c2:	621a      	str	r2, [r3, #32]
            break;
    e5c4:	4770      	bx	lr
            CLKGEN->CLKKEY         = CLKGEN_CLKKEY_CLKKEY_Key;
    e5c6:	f04f 2c40 	mov.w	ip, #1073758208	; 0x40004000
            CLKGEN->CCTRL          = CLKGEN_CCTRL_CORESEL_HFRC;
    e5ca:	2100      	movs	r1, #0
            CLKGEN->CLKKEY         = CLKGEN_CLKKEY_CLKKEY_Key;
    e5cc:	2047      	movs	r0, #71	; 0x47
    e5ce:	f8cc 0014 	str.w	r0, [ip, #20]
            CLKGEN->CCTRL          = CLKGEN_CCTRL_CORESEL_HFRC;
    e5d2:	f8cc 1018 	str.w	r1, [ip, #24]
    return AM_HAL_STATUS_SUCCESS;
    e5d6:	4608      	mov	r0, r1
            CLKGEN->CLKKEY         = 0;
    e5d8:	f8cc 1014 	str.w	r1, [ip, #20]
            break;
    e5dc:	4770      	bx	lr
            CLKGEN->OCTRL         &= ~_VAL2FLD(CLKGEN_OCTRL_STOPXT,
    e5de:	f04f 2140 	mov.w	r1, #1073758208	; 0x40004000
    return AM_HAL_STATUS_SUCCESS;
    e5e2:	2000      	movs	r0, #0
            CLKGEN->OCTRL         &= ~_VAL2FLD(CLKGEN_OCTRL_STOPXT,
    e5e4:	68ca      	ldr	r2, [r1, #12]
    e5e6:	f022 0301 	bic.w	r3, r2, #1
    e5ea:	60cb      	str	r3, [r1, #12]
            break;
    e5ec:	4770      	bx	lr
            CLKGEN->OCTRL         &= ~_VAL2FLD(CLKGEN_OCTRL_STOPRC,
    e5ee:	f04f 2c40 	mov.w	ip, #1073758208	; 0x40004000
    return AM_HAL_STATUS_SUCCESS;
    e5f2:	2000      	movs	r0, #0
            CLKGEN->OCTRL         &= ~_VAL2FLD(CLKGEN_OCTRL_STOPRC,
    e5f4:	f8dc 200c 	ldr.w	r2, [ip, #12]
    e5f8:	f022 0302 	bic.w	r3, r2, #2
    e5fc:	f8cc 300c 	str.w	r3, [ip, #12]
            break;
    e600:	4770      	bx	lr
            CLKGEN->OCTRL         |= _VAL2FLD(CLKGEN_OCTRL_STOPXT,
    e602:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
    return AM_HAL_STATUS_SUCCESS;
    e606:	2000      	movs	r0, #0
            CLKGEN->OCTRL         |= _VAL2FLD(CLKGEN_OCTRL_STOPXT,
    e608:	68d3      	ldr	r3, [r2, #12]
    e60a:	f043 0101 	orr.w	r1, r3, #1
    e60e:	60d1      	str	r1, [r2, #12]
            break;
    e610:	4770      	bx	lr
            CLKGEN->OCTRL         |= _VAL2FLD(CLKGEN_OCTRL_STOPRC,
    e612:	f04f 2c40 	mov.w	ip, #1073758208	; 0x40004000
    return AM_HAL_STATUS_SUCCESS;
    e616:	2000      	movs	r0, #0
            CLKGEN->OCTRL         |= _VAL2FLD(CLKGEN_OCTRL_STOPRC,
    e618:	f8dc 300c 	ldr.w	r3, [ip, #12]
    e61c:	f043 0102 	orr.w	r1, r3, #2
    e620:	f8cc 100c 	str.w	r1, [ip, #12]
            break;
    e624:	4770      	bx	lr
            CLKGEN->CLKKEY         = CLKGEN_CLKKEY_CLKKEY_Key;
    e626:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
            CLKGEN->CLKKEY         = 0;
    e62a:	2200      	movs	r2, #0
            CLKGEN->CLKKEY         = CLKGEN_CLKKEY_CLKKEY_Key;
    e62c:	2047      	movs	r0, #71	; 0x47
            CLKGEN->CCTRL          = CLKGEN_CCTRL_CORESEL_HFRC_DIV2;
    e62e:	2101      	movs	r1, #1
            CLKGEN->CLKKEY         = CLKGEN_CLKKEY_CLKKEY_Key;
    e630:	6158      	str	r0, [r3, #20]
            CLKGEN->CCTRL          = CLKGEN_CCTRL_CORESEL_HFRC_DIV2;
    e632:	6199      	str	r1, [r3, #24]
    return AM_HAL_STATUS_SUCCESS;
    e634:	4610      	mov	r0, r2
            CLKGEN->CLKKEY         = 0;
    e636:	615a      	str	r2, [r3, #20]
            break;
    e638:	4770      	bx	lr
            if ( pArgs == 0 )
    e63a:	b151      	cbz	r1, e652 <am_hal_clkgen_control+0xae>
    e63c:	6808      	ldr	r0, [r1, #0]
    e63e:	f040 0101 	orr.w	r1, r0, #1
            CLKGEN->HFADJ = ui32Regval;
    e642:	f04f 2c40 	mov.w	ip, #1073758208	; 0x40004000
    return AM_HAL_STATUS_SUCCESS;
    e646:	2000      	movs	r0, #0
            CLKGEN->HFADJ = ui32Regval;
    e648:	f8cc 1020 	str.w	r1, [ip, #32]
            break;
    e64c:	4770      	bx	lr
            return AM_HAL_STATUS_INVALID_ARG;
    e64e:	2006      	movs	r0, #6
} // am_hal_clkgen_control()
    e650:	4770      	bx	lr
    e652:	4901      	ldr	r1, [pc, #4]	; (e658 <am_hal_clkgen_control+0xb4>)
    e654:	e7f5      	b.n	e642 <am_hal_clkgen_control+0x9e>
    e656:	bf00      	nop
    e658:	0025b801 	.word	0x0025b801

0000e65c <am_hal_clkgen_status_get>:
uint32_t
am_hal_clkgen_status_get(am_hal_clkgen_status_t *psStatus)
{
    uint32_t ui32Status;

    if ( psStatus == NULL )
    e65c:	b1a8      	cbz	r0, e68a <am_hal_clkgen_status_get+0x2e>
{
    e65e:	b410      	push	{r4}
        return AM_HAL_STATUS_INVALID_ARG;
    }

#if AM_CMSIS_REGS
    psStatus->ui32SysclkFreq =
        CLKGEN->CCTRL_b.CORESEL                     ?
    e660:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
            AM_HAL_CLKGEN_FREQ_MAX_HZ / 2           :
    e664:	490a      	ldr	r1, [pc, #40]	; (e690 <am_hal_clkgen_status_get+0x34>)
        CLKGEN->CCTRL_b.CORESEL                     ?
    e666:	6994      	ldr	r4, [r2, #24]
            AM_HAL_CLKGEN_FREQ_MAX_HZ / 2           :
    e668:	4b0a      	ldr	r3, [pc, #40]	; (e694 <am_hal_clkgen_status_get+0x38>)
    e66a:	f014 0f01 	tst.w	r4, #1
    e66e:	bf08      	it	eq
    e670:	460b      	moveq	r3, r1
    psStatus->ui32SysclkFreq =
    e672:	6003      	str	r3, [r0, #0]
            AM_HAL_CLKGEN_FREQ_MAX_HZ;

    ui32Status = CLKGEN->STATUS;
    e674:	69d3      	ldr	r3, [r2, #28]
        _FLD2VAL(CLKGEN_STATUS_OMODE, ui32Status)   ?
            AM_HAL_CLKGEN_STATUS_RTCOSC_LFRC        :
            AM_HAL_CLKGEN_STATUS_RTCOSC_XTAL;

    psStatus->bXtalFailure =
        _FLD2VAL(CLKGEN_STATUS_OSCF, ui32Status);
    e676:	f3c3 0440 	ubfx	r4, r3, #1, #1
        _FLD2VAL(CLKGEN_STATUS_OMODE, ui32Status)   ?
    e67a:	f003 0201 	and.w	r2, r3, #1
        _FLD2VAL(CLKGEN_STATUS_OSCF, ui32Status);
    e67e:	7204      	strb	r4, [r0, #8]
    psStatus->eRTCOSC =
    e680:	6042      	str	r2, [r0, #4]
        AM_BFX(CLKGEN, STATUS, OSCF, ui32Status);
#endif // AM_CMSIS_REGS

    return AM_HAL_STATUS_SUCCESS;

} // am_hal_clkgen_status_get()
    e682:	f85d 4b04 	ldr.w	r4, [sp], #4
    return AM_HAL_STATUS_SUCCESS;
    e686:	2000      	movs	r0, #0
} // am_hal_clkgen_status_get()
    e688:	4770      	bx	lr
        return AM_HAL_STATUS_INVALID_ARG;
    e68a:	2006      	movs	r0, #6
    e68c:	4770      	bx	lr
    e68e:	bf00      	nop
    e690:	02dc6c00 	.word	0x02dc6c00
    e694:	016e3600 	.word	0x016e3600

0000e698 <am_hal_ctimer_int_service>:
am_hal_ctimer_int_service(uint32_t ui32Status)
{

    am_hal_ctimer_handler_t pfnHandler;

    while ( ui32Status )
    e698:	b198      	cbz	r0, e6c2 <am_hal_ctimer_int_service+0x2a>
{
    e69a:	b570      	push	{r4, r5, r6, lr}
    e69c:	4e09      	ldr	r6, [pc, #36]	; (e6c4 <am_hal_ctimer_int_service+0x2c>)
    e69e:	4604      	mov	r4, r0
#endif

        //
        // Turn off the bit we picked in the working copy
        //
        ui32Status &= ~(0x80000000 >> ui32Clz);
    e6a0:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
        ui32Clz = __builtin_clz(ui32Status);
    e6a4:	fab4 f384 	clz	r3, r4

        //
        // Check the bit handler table to see if there is an interrupt handler
        // registered for this particular bit.
        //
        pfnHandler = am_hal_ctimer_ppfnHandlers[31 - ui32Clz];
    e6a8:	f1c3 021f 	rsb	r2, r3, #31
        ui32Status &= ~(0x80000000 >> ui32Clz);
    e6ac:	fa25 f003 	lsr.w	r0, r5, r3
        pfnHandler = am_hal_ctimer_ppfnHandlers[31 - ui32Clz];
    e6b0:	f856 1022 	ldr.w	r1, [r6, r2, lsl #2]
        ui32Status &= ~(0x80000000 >> ui32Clz);
    e6b4:	ea24 0400 	bic.w	r4, r4, r0
        if ( pfnHandler )
    e6b8:	b101      	cbz	r1, e6bc <am_hal_ctimer_int_service+0x24>
        {
            //
            // If we found an interrupt handler routine, call it now.
            //
            pfnHandler();
    e6ba:	4788      	blx	r1
    while ( ui32Status )
    e6bc:	2c00      	cmp	r4, #0
    e6be:	d1f1      	bne.n	e6a4 <am_hal_ctimer_int_service+0xc>
    e6c0:	bd70      	pop	{r4, r5, r6, pc}
    e6c2:	4770      	bx	lr
    e6c4:	10001844 	.word	0x10001844

0000e6c8 <am_hal_ctimer_int_register>:

    //
    // Check to make sure the interrupt number is valid. (Debug builds only)
    //
#if AM_CMSIS_REGS
    switch (ui32Interrupt)
    e6c8:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
{
    e6cc:	b510      	push	{r4, lr}
    e6ce:	460c      	mov	r4, r1
    switch (ui32Interrupt)
    e6d0:	f000 80aa 	beq.w	e828 <am_hal_ctimer_int_register+0x160>
    e6d4:	d917      	bls.n	e706 <am_hal_ctimer_int_register+0x3e>
    e6d6:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    e6da:	f000 8085 	beq.w	e7e8 <am_hal_ctimer_int_register+0x120>
    e6de:	d921      	bls.n	e724 <am_hal_ctimer_int_register+0x5c>
    e6e0:	f1b0 6f00 	cmp.w	r0, #134217728	; 0x8000000
    e6e4:	f000 80a2 	beq.w	e82c <am_hal_ctimer_int_register+0x164>
    e6e8:	d93a      	bls.n	e760 <am_hal_ctimer_int_register+0x98>
    e6ea:	f1b0 5f00 	cmp.w	r0, #536870912	; 0x20000000
    e6ee:	f000 8093 	beq.w	e818 <am_hal_ctimer_int_register+0x150>
    e6f2:	d97f      	bls.n	e7f4 <am_hal_ctimer_int_register+0x12c>
    e6f4:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
    e6f8:	d064      	beq.n	e7c4 <am_hal_ctimer_int_register+0xfc>
    e6fa:	f1b0 4f00 	cmp.w	r0, #2147483648	; 0x80000000
        case CTIMER_INTEN_CTMRA7C1INT_Msk:
            intIdx = CTIMER_INTEN_CTMRA7C1INT_Pos;
            break;

        case CTIMER_INTEN_CTMRB7C1INT_Msk:
            intIdx = CTIMER_INTEN_CTMRB7C1INT_Pos;
    e6fe:	bf08      	it	eq
    e700:	221f      	moveq	r2, #31
    switch (ui32Interrupt)
    e702:	d03d      	beq.n	e780 <am_hal_ctimer_int_register+0xb8>
    e704:	e035      	b.n	e772 <am_hal_ctimer_int_register+0xaa>
    e706:	2880      	cmp	r0, #128	; 0x80
    e708:	f000 808c 	beq.w	e824 <am_hal_ctimer_int_register+0x15c>
    e70c:	d819      	bhi.n	e742 <am_hal_ctimer_int_register+0x7a>
    e70e:	2808      	cmp	r0, #8
    e710:	d068      	beq.n	e7e4 <am_hal_ctimer_int_register+0x11c>
    e712:	d84f      	bhi.n	e7b4 <am_hal_ctimer_int_register+0xec>
    e714:	2802      	cmp	r0, #2
    e716:	d077      	beq.n	e808 <am_hal_ctimer_int_register+0x140>
    e718:	2804      	cmp	r0, #4
    e71a:	d05d      	beq.n	e7d8 <am_hal_ctimer_int_register+0x110>
    e71c:	2801      	cmp	r0, #1
    e71e:	d128      	bne.n	e772 <am_hal_ctimer_int_register+0xaa>
            intIdx = CTIMER_INTEN_CTMRA0C0INT_Pos;
    e720:	2200      	movs	r2, #0
    e722:	e02d      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
    switch (ui32Interrupt)
    e724:	f5b0 2f00 	cmp.w	r0, #524288	; 0x80000
    e728:	d062      	beq.n	e7f0 <am_hal_ctimer_int_register+0x128>
    e72a:	d82d      	bhi.n	e788 <am_hal_ctimer_int_register+0xc0>
    e72c:	f5b0 3f00 	cmp.w	r0, #131072	; 0x20000
    e730:	d076      	beq.n	e820 <am_hal_ctimer_int_register+0x158>
    e732:	f5b0 2f80 	cmp.w	r0, #262144	; 0x40000
    e736:	d04d      	beq.n	e7d4 <am_hal_ctimer_int_register+0x10c>
    e738:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
    e73c:	d119      	bne.n	e772 <am_hal_ctimer_int_register+0xaa>
            intIdx = CTIMER_INTEN_CTMRA0C1INT_Pos;
    e73e:	2210      	movs	r2, #16
            break;
    e740:	e01e      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
    switch (ui32Interrupt)
    e742:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
    e746:	d051      	beq.n	e7ec <am_hal_ctimer_int_register+0x124>
    e748:	d829      	bhi.n	e79e <am_hal_ctimer_int_register+0xd6>
    e74a:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
    e74e:	d059      	beq.n	e804 <am_hal_ctimer_int_register+0x13c>
    e750:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
    e754:	d03a      	beq.n	e7cc <am_hal_ctimer_int_register+0x104>
    e756:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
    e75a:	d10a      	bne.n	e772 <am_hal_ctimer_int_register+0xaa>
            intIdx = CTIMER_INTEN_CTMRA4C0INT_Pos;
    e75c:	2208      	movs	r2, #8
            break;
    e75e:	e00f      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
    switch (ui32Interrupt)
    e760:	f1b0 7f00 	cmp.w	r0, #33554432	; 0x2000000
    e764:	d056      	beq.n	e814 <am_hal_ctimer_int_register+0x14c>
    e766:	f1b0 6f80 	cmp.w	r0, #67108864	; 0x4000000
    e76a:	d031      	beq.n	e7d0 <am_hal_ctimer_int_register+0x108>
    e76c:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
    e770:	d054      	beq.n	e81c <am_hal_ctimer_int_register+0x154>
            break;

        default:
            am_hal_debug_assert_msg(false, "CTimer interrupt number out of range.");
    e772:	4a2f      	ldr	r2, [pc, #188]	; (e830 <am_hal_ctimer_int_register+0x168>)
    e774:	482f      	ldr	r0, [pc, #188]	; (e834 <am_hal_ctimer_int_register+0x16c>)
    e776:	f240 1193 	movw	r1, #403	; 0x193
    e77a:	f000 f951 	bl	ea20 <am_hal_debug_error>
    uint32_t intIdx = 0;
    e77e:	2200      	movs	r2, #0
        default:
            am_hal_debug_assert_msg(false, "CTimer interrupt number out of range.");
    }
#endif // AM_CMSIS_REGS

    am_hal_ctimer_ppfnHandlers[intIdx] = pfnHandler;
    e780:	4b2d      	ldr	r3, [pc, #180]	; (e838 <am_hal_ctimer_int_register+0x170>)
    e782:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
    e786:	bd10      	pop	{r4, pc}
    switch (ui32Interrupt)
    e788:	f5b0 1f00 	cmp.w	r0, #2097152	; 0x200000
    e78c:	d040      	beq.n	e810 <am_hal_ctimer_int_register+0x148>
    e78e:	f5b0 0f80 	cmp.w	r0, #4194304	; 0x400000
    e792:	d025      	beq.n	e7e0 <am_hal_ctimer_int_register+0x118>
    e794:	f5b0 1f80 	cmp.w	r0, #1048576	; 0x100000
    e798:	d1eb      	bne.n	e772 <am_hal_ctimer_int_register+0xaa>
            intIdx = CTIMER_INTEN_CTMRA2C1INT_Pos;
    e79a:	2214      	movs	r2, #20
            break;
    e79c:	e7f0      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
    switch (ui32Interrupt)
    e79e:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
    e7a2:	d033      	beq.n	e80c <am_hal_ctimer_int_register+0x144>
    e7a4:	f5b0 4f80 	cmp.w	r0, #16384	; 0x4000
    e7a8:	d018      	beq.n	e7dc <am_hal_ctimer_int_register+0x114>
    e7aa:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
    e7ae:	d1e0      	bne.n	e772 <am_hal_ctimer_int_register+0xaa>
            intIdx = CTIMER_INTEN_CTMRA6C0INT_Pos;
    e7b0:	220c      	movs	r2, #12
            break;
    e7b2:	e7e5      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
    switch (ui32Interrupt)
    e7b4:	2820      	cmp	r0, #32
    e7b6:	d023      	beq.n	e800 <am_hal_ctimer_int_register+0x138>
    e7b8:	2840      	cmp	r0, #64	; 0x40
    e7ba:	d005      	beq.n	e7c8 <am_hal_ctimer_int_register+0x100>
    e7bc:	2810      	cmp	r0, #16
    e7be:	d1d8      	bne.n	e772 <am_hal_ctimer_int_register+0xaa>
            intIdx = CTIMER_INTEN_CTMRA2C0INT_Pos;
    e7c0:	2204      	movs	r2, #4
            break;
    e7c2:	e7dd      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
            intIdx = CTIMER_INTEN_CTMRA7C1INT_Pos;
    e7c4:	221e      	movs	r2, #30
            break;
    e7c6:	e7db      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
            intIdx = CTIMER_INTEN_CTMRA3C0INT_Pos;
    e7c8:	2206      	movs	r2, #6
            break;
    e7ca:	e7d9      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
            intIdx = CTIMER_INTEN_CTMRA5C0INT_Pos;
    e7cc:	220a      	movs	r2, #10
            break;
    e7ce:	e7d7      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
            intIdx = CTIMER_INTEN_CTMRA5C1INT_Pos;
    e7d0:	221a      	movs	r2, #26
            break;
    e7d2:	e7d5      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
            intIdx = CTIMER_INTEN_CTMRA1C1INT_Pos;
    e7d4:	2212      	movs	r2, #18
            break;
    e7d6:	e7d3      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
            intIdx = CTIMER_INTEN_CTMRA1C0INT_Pos;
    e7d8:	2202      	movs	r2, #2
            break;
    e7da:	e7d1      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
            intIdx = CTIMER_INTEN_CTMRA7C0INT_Pos;
    e7dc:	220e      	movs	r2, #14
            break;
    e7de:	e7cf      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
            intIdx = CTIMER_INTEN_CTMRA3C1INT_Pos;
    e7e0:	2216      	movs	r2, #22
            break;
    e7e2:	e7cd      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
            intIdx = CTIMER_INTEN_CTMRB1C0INT_Pos;
    e7e4:	2203      	movs	r2, #3
            break;
    e7e6:	e7cb      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
            intIdx = CTIMER_INTEN_CTMRB3C1INT_Pos;
    e7e8:	2217      	movs	r2, #23
            break;
    e7ea:	e7c9      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
            intIdx = CTIMER_INTEN_CTMRB5C0INT_Pos;
    e7ec:	220b      	movs	r2, #11
            break;
    e7ee:	e7c7      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
            intIdx = CTIMER_INTEN_CTMRB1C1INT_Pos;
    e7f0:	2213      	movs	r2, #19
            break;
    e7f2:	e7c5      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
    switch (ui32Interrupt)
    e7f4:	f1b0 5f80 	cmp.w	r0, #268435456	; 0x10000000
            intIdx = CTIMER_INTEN_CTMRA6C1INT_Pos;
    e7f8:	bf08      	it	eq
    e7fa:	221c      	moveq	r2, #28
    switch (ui32Interrupt)
    e7fc:	d0c0      	beq.n	e780 <am_hal_ctimer_int_register+0xb8>
    e7fe:	e7b8      	b.n	e772 <am_hal_ctimer_int_register+0xaa>
            intIdx = CTIMER_INTEN_CTMRB2C0INT_Pos;
    e800:	2205      	movs	r2, #5
            break;
    e802:	e7bd      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
            intIdx = CTIMER_INTEN_CTMRB4C0INT_Pos;
    e804:	2209      	movs	r2, #9
            break;
    e806:	e7bb      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
            intIdx = CTIMER_INTEN_CTMRB0C0INT_Pos;
    e808:	2201      	movs	r2, #1
    e80a:	e7b9      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
            intIdx = CTIMER_INTEN_CTMRB6C0INT_Pos;
    e80c:	220d      	movs	r2, #13
            break;
    e80e:	e7b7      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
            intIdx = CTIMER_INTEN_CTMRB2C1INT_Pos;
    e810:	2215      	movs	r2, #21
            break;
    e812:	e7b5      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
            intIdx = CTIMER_INTEN_CTMRB4C1INT_Pos;
    e814:	2219      	movs	r2, #25
            break;
    e816:	e7b3      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
            intIdx = CTIMER_INTEN_CTMRB6C1INT_Pos;
    e818:	221d      	movs	r2, #29
            break;
    e81a:	e7b1      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
            intIdx = CTIMER_INTEN_CTMRA4C1INT_Pos;
    e81c:	2218      	movs	r2, #24
            break;
    e81e:	e7af      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
            intIdx = CTIMER_INTEN_CTMRB0C1INT_Pos;
    e820:	2211      	movs	r2, #17
            break;
    e822:	e7ad      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
            intIdx = CTIMER_INTEN_CTMRB3C0INT_Pos;
    e824:	2207      	movs	r2, #7
            break;
    e826:	e7ab      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
            intIdx = CTIMER_INTEN_CTMRB7C0INT_Pos;
    e828:	220f      	movs	r2, #15
            break;
    e82a:	e7a9      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
            intIdx = CTIMER_INTEN_CTMRB5C1INT_Pos;
    e82c:	221b      	movs	r2, #27
            break;
    e82e:	e7a7      	b.n	e780 <am_hal_ctimer_int_register+0xb8>
    e830:	00010b54 	.word	0x00010b54
    e834:	00010b7c 	.word	0x00010b7c
    e838:	10001844 	.word	0x10001844

0000e83c <am_hal_ctimer_config>:
//
//*****************************************************************************
void
am_hal_ctimer_config(uint32_t ui32TimerNumber,
                     am_hal_ctimer_config_t *psConfig)
{
    e83c:	b530      	push	{r4, r5, lr}
    e83e:	4604      	mov	r4, r0
                      (psConfig->ui32TimerBConfig << 16) );

    //
    // OR in the Link bit if the timers need to be linked.
    //
    ui32ConfigVal |= psConfig->ui32Link ? AM_HAL_CTIMER_LINK : 0;
    e840:	6808      	ldr	r0, [r1, #0]
    ui32ConfigVal = ( (psConfig->ui32TimerAConfig)  |
    e842:	684b      	ldr	r3, [r1, #4]
                      (psConfig->ui32TimerBConfig << 16) );
    e844:	688a      	ldr	r2, [r1, #8]
    ui32ConfigVal |= psConfig->ui32Link ? AM_HAL_CTIMER_LINK : 0;
    e846:	2800      	cmp	r0, #0
{
    e848:	b083      	sub	sp, #12
    ui32ConfigVal = ( (psConfig->ui32TimerAConfig)  |
    e84a:	ea43 4102 	orr.w	r1, r3, r2, lsl #16
    ui32ConfigVal |= psConfig->ui32Link ? AM_HAL_CTIMER_LINK : 0;
    e84e:	bf14      	ite	ne
    e850:	f04f 4500 	movne.w	r5, #2147483648	; 0x80000000
    e854:	2500      	moveq	r5, #0
    e856:	430d      	orrs	r5, r1

    //
    // Begin critical section while config registers are read and modified.
    //
    AM_CRITICAL_BEGIN
    e858:	f000 fb9e 	bl	ef98 <am_hal_interrupt_master_disable>

    //
    // Find the correct register to write.
    //
#if AM_CMSIS_REGS
    uint32_t *pui32ConfigReg = (uint32_t *)(&CTIMERn(0)->CTRL0 +
    e85c:	0164      	lsls	r4, r4, #5
    e85e:	4a04      	ldr	r2, [pc, #16]	; (e870 <am_hal_ctimer_config+0x34>)
    AM_CRITICAL_BEGIN
    e860:	9001      	str	r0, [sp, #4]
#endif // AM_CMSIS_REGS

    //
    // Write our configuration value.
    //
    AM_REGVAL(pui32ConfigReg) = ui32ConfigVal;
    e862:	50a5      	str	r5, [r4, r2]


    //
    // Done with critical section.
    //
    AM_CRITICAL_END
    e864:	9801      	ldr	r0, [sp, #4]
    e866:	f000 fb9b 	bl	efa0 <am_hal_interrupt_master_set>

} // am_hal_ctimer_config()
    e86a:	b003      	add	sp, #12
    e86c:	bd30      	pop	{r4, r5, pc}
    e86e:	bf00      	nop
    e870:	4000800c 	.word	0x4000800c

0000e874 <am_hal_ctimer_start>:
//! @return None.
//
//*****************************************************************************
void
am_hal_ctimer_start(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment)
{
    e874:	b570      	push	{r4, r5, r6, lr}
    e876:	b082      	sub	sp, #8
    e878:	460c      	mov	r4, r1
    //
    // Find the correct control register.
    //
#if AM_CMSIS_REGS
    volatile uint32_t *pui32ConfigReg = (uint32_t *)(&CTIMERn(0)->CTRL0 +
    e87a:	0146      	lsls	r6, r0, #5
#endif // AM_CMSIS_REGS

    //
    // Begin critical section while config registers are read and modified.
    //
    AM_CRITICAL_BEGIN
    e87c:	f000 fb8c 	bl	ef98 <am_hal_interrupt_master_disable>
    volatile uint32_t *pui32ConfigReg = (uint32_t *)(&CTIMERn(0)->CTRL0 +
    e880:	4d07      	ldr	r5, [pc, #28]	; (e8a0 <am_hal_ctimer_start+0x2c>)
    AM_CRITICAL_BEGIN
    e882:	9001      	str	r0, [sp, #4]

    //
    // Read the current value.
    //
    uint32_t ui32ConfigVal = *pui32ConfigReg;
    e884:	5971      	ldr	r1, [r6, r5]

#if AM_CMSIS_REGS
    //
    // Clear out the "clear" bit.
    //
    ui32ConfigVal &= ~(ui32TimerSegment & (CTIMER_CTRL0_TMRA0CLR_Msk |
    e886:	f004 2308 	and.w	r3, r4, #134219776	; 0x8000800
    e88a:	ea21 0003 	bic.w	r0, r1, r3
                                           CTIMER_CTRL0_TMRB0CLR_Msk));

    //
    // Set the "enable bit"
    //
    ui32ConfigVal |= (ui32TimerSegment & (CTIMER_CTRL0_TMRA0EN_Msk |
    e88e:	f004 1201 	and.w	r2, r4, #65537	; 0x10001
    e892:	4302      	orrs	r2, r0
#endif // AM_CMSIS_REGS

    //
    // Write the value back to the register.
    //
    AM_REGVAL(pui32ConfigReg) = ui32ConfigVal;
    e894:	5172      	str	r2, [r6, r5]

    //
    // Done with critical section.
    //
    AM_CRITICAL_END
    e896:	9801      	ldr	r0, [sp, #4]
    e898:	f000 fb82 	bl	efa0 <am_hal_interrupt_master_set>

} // am_hal_ctimer_start()
    e89c:	b002      	add	sp, #8
    e89e:	bd70      	pop	{r4, r5, r6, pc}
    e8a0:	4000800c 	.word	0x4000800c

0000e8a4 <am_hal_ctimer_clear>:
//! @return None.
//
//*****************************************************************************
void
am_hal_ctimer_clear(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment)
{
    e8a4:	b570      	push	{r4, r5, r6, lr}
    e8a6:	b082      	sub	sp, #8
    e8a8:	460c      	mov	r4, r1

    //
    // Find the correct control register.
    //
#if AM_CMSIS_REGS
    pui32ConfigReg = (uint32_t *)(&CTIMERn(0)->CTRL0 +
    e8aa:	0146      	lsls	r6, r0, #5
                                 (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN
    e8ac:	f000 fb74 	bl	ef98 <am_hal_interrupt_master_disable>
    pui32ConfigReg = (uint32_t *)(&CTIMERn(0)->CTRL0 +
    e8b0:	4d05      	ldr	r5, [pc, #20]	; (e8c8 <am_hal_ctimer_clear+0x24>)
    AM_CRITICAL_BEGIN
    e8b2:	9001      	str	r0, [sp, #4]

    //
    // Set the "clear" bit
    //
    AM_REGVAL(pui32ConfigReg) |= (ui32TimerSegment &
    e8b4:	5971      	ldr	r1, [r6, r5]
    e8b6:	f004 2008 	and.w	r0, r4, #134219776	; 0x8000800
    e8ba:	4308      	orrs	r0, r1
    e8bc:	5170      	str	r0, [r6, r5]
                                   CTIMER_CTRL0_TMRB0CLR_Msk));

    //
    // Done with critical section.
    //
    AM_CRITICAL_END
    e8be:	9801      	ldr	r0, [sp, #4]
    e8c0:	f000 fb6e 	bl	efa0 <am_hal_interrupt_master_set>
    // Done with critical section.
    //
    AM_CRITICAL_END
#endif // AM_CMSIS_REGS

} // am_hal_ctimer_clear()
    e8c4:	b002      	add	sp, #8
    e8c6:	bd70      	pop	{r4, r5, r6, pc}
    e8c8:	4000800c 	.word	0x4000800c

0000e8cc <am_hal_ctimer_period_set>:
//
//*****************************************************************************
void
am_hal_ctimer_period_set(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment,
                         uint32_t ui32Period, uint32_t ui32OnTime)
{
    e8cc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    e8d0:	b082      	sub	sp, #8
    e8d2:	4688      	mov	r8, r1
    e8d4:	461f      	mov	r7, r3
#if AM_CMSIS_REGS
    //
    // Find the correct control register to pull the function select field
    // from.
    //
    pui32ControlReg = (uint32_t *)(&CTIMERn(0)->CTRL0 +
    e8d6:	ea4f 1940 	mov.w	r9, r0, lsl #5
{
    e8da:	4614      	mov	r4, r2
#endif // AM_CMSIS_REGS

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN
    e8dc:	f000 fb5c 	bl	ef98 <am_hal_interrupt_master_disable>
    pui32ControlReg = (uint32_t *)(&CTIMERn(0)->CTRL0 +
    e8e0:	f8df a098 	ldr.w	sl, [pc, #152]	; e97c <am_hal_ctimer_period_set+0xb0>
    AM_CRITICAL_BEGIN
    e8e4:	9001      	str	r0, [sp, #4]
    //
    // Extract the timer mode from the register based on the ui32TimerSegment
    // selected by the user.
    //
    ui32Mode = *pui32ControlReg;
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
    e8e6:	f518 3f80 	cmn.w	r8, #65536	; 0x10000
    pui32CompareRegA = (uint32_t *)(&CTIMERn(0)->CMPRA0 +
    e8ea:	4d21      	ldr	r5, [pc, #132]	; (e970 <am_hal_ctimer_period_set+0xa4>)
    pui32CompareRegB = (uint32_t *)(&CTIMERn(0)->CMPRB0 +
    e8ec:	4e21      	ldr	r6, [pc, #132]	; (e974 <am_hal_ctimer_period_set+0xa8>)
    ui32Mode = *pui32ControlReg;
    e8ee:	f859 300a 	ldr.w	r3, [r9, sl]
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
    e8f2:	d01b      	beq.n	e92c <am_hal_ctimer_period_set+0x60>

    //
    // If the mode is a PWM mode, we'll need to calculate the correct CMPR0 and
    // CMPR1 values here.
    //
    if (ui32Mode == AM_HAL_CTIMER_FN_PWM_ONCE   ||
    e8f4:	f403 70c0 	and.w	r0, r3, #384	; 0x180
    e8f8:	2880      	cmp	r0, #128	; 0x80
    e8fa:	d01c      	beq.n	e936 <am_hal_ctimer_period_set+0x6a>
    //
    // Based on the timer segment argument, write the calculated Compare 0 and
    // Compare 1 values to the correct halves of the correct registers.
    //
#if AM_CMSIS_REGS
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERA )
    e8fc:	f64f 77ff 	movw	r7, #65535	; 0xffff
    e900:	2300      	movs	r3, #0
    e902:	45b8      	cmp	r8, r7
        ui32Comp1 = 0;
    e904:	461a      	mov	r2, r3
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERA )
    e906:	d01d      	beq.n	e944 <am_hal_ctimer_period_set+0x78>
        // For timer A, write the values to the TIMERA compare register.
        //
        *pui32CompareRegA = (_VAL2FLD(CTIMER_CMPRA0_CMPR0A0, ui32Comp0) |
                             _VAL2FLD(CTIMER_CMPRA0_CMPR1A0, ui32Comp1));
    }
    else if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
    e908:	491b      	ldr	r1, [pc, #108]	; (e978 <am_hal_ctimer_period_set+0xac>)
    e90a:	4588      	cmp	r8, r1
    e90c:	d025      	beq.n	e95a <am_hal_ctimer_period_set+0x8e>
        //
        *pui32CompareRegA = (_VAL2FLD(CTIMER_CMPRA0_CMPR0A0, ui32Comp0) |
                             _VAL2FLD(CTIMER_CMPRA0_CMPR1A0, ui32Comp1));

        *pui32CompareRegB = (_VAL2FLD(CTIMER_CMPRA0_CMPR0A0, ui32Comp0 >> 16) |
                             _VAL2FLD(CTIMER_CMPRA0_CMPR1A0, ui32Comp1 >> 16));
    e90e:	400a      	ands	r2, r1
        *pui32CompareRegA = (_VAL2FLD(CTIMER_CMPRA0_CMPR0A0, ui32Comp0) |
    e910:	b2a0      	uxth	r0, r4
    e912:	4303      	orrs	r3, r0
        *pui32CompareRegB = (_VAL2FLD(CTIMER_CMPRA0_CMPR0A0, ui32Comp0 >> 16) |
    e914:	ea42 4414 	orr.w	r4, r2, r4, lsr #16
        *pui32CompareRegA = (_VAL2FLD(CTIMER_CMPRA0_CMPR0A0, ui32Comp0) |
    e918:	f849 3005 	str.w	r3, [r9, r5]
        *pui32CompareRegB = (_VAL2FLD(CTIMER_CMPRA0_CMPR0A0, ui32Comp0 >> 16) |
    e91c:	f849 4006 	str.w	r4, [r9, r6]
#endif // AM_CMSIS_REGS

    //
    // Done with critical section.
    //
    AM_CRITICAL_END
    e920:	9801      	ldr	r0, [sp, #4]
    e922:	f000 fb3d 	bl	efa0 <am_hal_interrupt_master_set>

} // am_hal_ctimer_period_set()
    e926:	b002      	add	sp, #8
    e928:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        ui32Mode = ui32Mode >> 16;
    e92c:	0c19      	lsrs	r1, r3, #16
    if (ui32Mode == AM_HAL_CTIMER_FN_PWM_ONCE   ||
    e92e:	f401 70c0 	and.w	r0, r1, #384	; 0x180
    e932:	2880      	cmp	r0, #128	; 0x80
    e934:	d110      	bne.n	e958 <am_hal_ctimer_period_set+0x8c>
    e936:	0423      	lsls	r3, r4, #16
        ui32Comp1 = ui32Period;
    e938:	4622      	mov	r2, r4
        ui32Comp0 = ui32Period - ui32OnTime;
    e93a:	1be4      	subs	r4, r4, r7
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERA )
    e93c:	f64f 77ff 	movw	r7, #65535	; 0xffff
    e940:	45b8      	cmp	r8, r7
    e942:	d1e1      	bne.n	e908 <am_hal_ctimer_period_set+0x3c>
        *pui32CompareRegA = (_VAL2FLD(CTIMER_CMPRA0_CMPR0A0, ui32Comp0) |
    e944:	b2a6      	uxth	r6, r4
    e946:	4333      	orrs	r3, r6
    e948:	f849 3005 	str.w	r3, [r9, r5]
    AM_CRITICAL_END
    e94c:	9801      	ldr	r0, [sp, #4]
    e94e:	f000 fb27 	bl	efa0 <am_hal_interrupt_master_set>
} // am_hal_ctimer_period_set()
    e952:	b002      	add	sp, #8
    e954:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (ui32Mode == AM_HAL_CTIMER_FN_PWM_ONCE   ||
    e958:	2300      	movs	r3, #0
        *pui32CompareRegB = (_VAL2FLD(CTIMER_CMPRA0_CMPR0A0, ui32Comp0) |
    e95a:	b2a5      	uxth	r5, r4
    e95c:	432b      	orrs	r3, r5
    e95e:	f849 3006 	str.w	r3, [r9, r6]
    AM_CRITICAL_END
    e962:	9801      	ldr	r0, [sp, #4]
    e964:	f000 fb1c 	bl	efa0 <am_hal_interrupt_master_set>
} // am_hal_ctimer_period_set()
    e968:	b002      	add	sp, #8
    e96a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    e96e:	bf00      	nop
    e970:	40008004 	.word	0x40008004
    e974:	40008008 	.word	0x40008008
    e978:	ffff0000 	.word	0xffff0000
    e97c:	4000800c 	.word	0x4000800c

0000e980 <am_hal_ctimer_int_enable>:
//! @return None.
//
//*****************************************************************************
void
am_hal_ctimer_int_enable(uint32_t ui32Interrupt)
{
    e980:	b510      	push	{r4, lr}
    e982:	b082      	sub	sp, #8
    e984:	4604      	mov	r4, r0
    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN
    e986:	f000 fb07 	bl	ef98 <am_hal_interrupt_master_disable>

    //
    // Enable the interrupt at the module level.
    //
#if AM_CMSIS_REGS
    CTIMERn(0)->INTEN |= ui32Interrupt;
    e98a:	4b06      	ldr	r3, [pc, #24]	; (e9a4 <am_hal_ctimer_int_enable+0x24>)
    AM_CRITICAL_BEGIN
    e98c:	9001      	str	r0, [sp, #4]
    CTIMERn(0)->INTEN |= ui32Interrupt;
    e98e:	f8d3 0200 	ldr.w	r0, [r3, #512]	; 0x200
    e992:	4320      	orrs	r0, r4
    e994:	f8c3 0200 	str.w	r0, [r3, #512]	; 0x200
#endif // AM_CMSIS_REGS

    //
    // Done with critical section.
    //
    AM_CRITICAL_END
    e998:	9801      	ldr	r0, [sp, #4]
    e99a:	f000 fb01 	bl	efa0 <am_hal_interrupt_master_set>

} // am_hal_ctimer_int_enable()
    e99e:	b002      	add	sp, #8
    e9a0:	bd10      	pop	{r4, pc}
    e9a2:	bf00      	nop
    e9a4:	40008000 	.word	0x40008000

0000e9a8 <am_hal_ctimer_int_disable>:
//! @return None.
//
//*****************************************************************************
void
am_hal_ctimer_int_disable(uint32_t ui32Interrupt)
{
    e9a8:	b510      	push	{r4, lr}
    e9aa:	b082      	sub	sp, #8
    e9ac:	4604      	mov	r4, r0
    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN
    e9ae:	f000 faf3 	bl	ef98 <am_hal_interrupt_master_disable>

    //
    // Disable the interrupt at the module level.
    //
#if AM_CMSIS_REGS
    CTIMERn(0)->INTEN &= ~ui32Interrupt;
    e9b2:	4b06      	ldr	r3, [pc, #24]	; (e9cc <am_hal_ctimer_int_disable+0x24>)
    AM_CRITICAL_BEGIN
    e9b4:	9001      	str	r0, [sp, #4]
    CTIMERn(0)->INTEN &= ~ui32Interrupt;
    e9b6:	f8d3 0200 	ldr.w	r0, [r3, #512]	; 0x200
    e9ba:	ea20 0104 	bic.w	r1, r0, r4
    e9be:	f8c3 1200 	str.w	r1, [r3, #512]	; 0x200
#endif // AM_CMSIS_REGS

    //
    // Done with critical section.
    //
    AM_CRITICAL_END
    e9c2:	9801      	ldr	r0, [sp, #4]
    e9c4:	f000 faec 	bl	efa0 <am_hal_interrupt_master_set>

} // am_hal_ctimer_int_disable()
    e9c8:	b002      	add	sp, #8
    e9ca:	bd10      	pop	{r4, pc}
    e9cc:	40008000 	.word	0x40008000

0000e9d0 <am_hal_ctimer_int_clear>:
//! @return None.
//
//*****************************************************************************
void
am_hal_ctimer_int_clear(uint32_t ui32Interrupt)
{
    e9d0:	b510      	push	{r4, lr}
    e9d2:	b082      	sub	sp, #8
    e9d4:	4604      	mov	r4, r0
    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN
    e9d6:	f000 fadf 	bl	ef98 <am_hal_interrupt_master_disable>

    //
    // Disable the interrupt at the module level.
    //
#if AM_CMSIS_REGS
    CTIMERn(0)->INTCLR = ui32Interrupt;
    e9da:	4b04      	ldr	r3, [pc, #16]	; (e9ec <am_hal_ctimer_int_clear+0x1c>)
    AM_CRITICAL_BEGIN
    e9dc:	9001      	str	r0, [sp, #4]
    CTIMERn(0)->INTCLR = ui32Interrupt;
    e9de:	f8c3 4208 	str.w	r4, [r3, #520]	; 0x208
#endif // AM_CMSIS_REGS

    //
    // Done with critical section.
    //
    AM_CRITICAL_END
    e9e2:	9801      	ldr	r0, [sp, #4]
    e9e4:	f000 fadc 	bl	efa0 <am_hal_interrupt_master_set>

} // am_hal_ctimer_int_clear()
    e9e8:	b002      	add	sp, #8
    e9ea:	bd10      	pop	{r4, pc}
    e9ec:	40008000 	.word	0x40008000

0000e9f0 <am_hal_ctimer_int_status_get>:
//! @return u32RetVal either the timer interrupt status, or interrupt enabled.
//
//*****************************************************************************
uint32_t
am_hal_ctimer_int_status_get(bool bEnabledOnly)
{
    e9f0:	b510      	push	{r4, lr}
    e9f2:	b082      	sub	sp, #8
    e9f4:	4604      	mov	r4, r0
    uint32_t u32RetVal = 0;

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN
    e9f6:	f000 facf 	bl	ef98 <am_hal_interrupt_master_disable>
    //

#if AM_CMSIS_REGS
    if ( bEnabledOnly )
    {
        u32RetVal  = CTIMERn(0)->INTSTAT;
    e9fa:	4b08      	ldr	r3, [pc, #32]	; (ea1c <am_hal_ctimer_int_status_get+0x2c>)
    AM_CRITICAL_BEGIN
    e9fc:	9001      	str	r0, [sp, #4]
    if ( bEnabledOnly )
    e9fe:	b93c      	cbnz	r4, ea10 <am_hal_ctimer_int_status_get+0x20>
        u32RetVal &= CTIMERn(0)->INTEN;
    }
    else
    {
        u32RetVal = CTIMERn(0)->INTSTAT;
    ea00:	f8d3 4204 	ldr.w	r4, [r3, #516]	; 0x204
#endif // AM_CMSIS_REGS

    //
    // Done with critical section.
    //
    AM_CRITICAL_END
    ea04:	9801      	ldr	r0, [sp, #4]
    ea06:	f000 facb 	bl	efa0 <am_hal_interrupt_master_set>

    return u32RetVal;

} // am_hal_ctimer_int_status_get()
    ea0a:	4620      	mov	r0, r4
    ea0c:	b002      	add	sp, #8
    ea0e:	bd10      	pop	{r4, pc}
        u32RetVal  = CTIMERn(0)->INTSTAT;
    ea10:	f8d3 4204 	ldr.w	r4, [r3, #516]	; 0x204
        u32RetVal &= CTIMERn(0)->INTEN;
    ea14:	f8d3 0200 	ldr.w	r0, [r3, #512]	; 0x200
    ea18:	4004      	ands	r4, r0
    ea1a:	e7f3      	b.n	ea04 <am_hal_ctimer_int_status_get+0x14>
    ea1c:	40008000 	.word	0x40008000

0000ea20 <am_hal_debug_error>:
__weak void
#else
void __attribute__((weak))
#endif
am_hal_debug_error(const char *pcFile, uint32_t ui32Line, const char *pcMessage)
{
    ea20:	e7fe      	b.n	ea20 <am_hal_debug_error>
    ea22:	bf00      	nop

0000ea24 <am_hal_flash_delay>:
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    ea24:	4b00      	ldr	r3, [pc, #0]	; (ea28 <am_hal_flash_delay+0x4>)
    ea26:	4718      	bx	r3
    ea28:	0800009d 	.word	0x0800009d

0000ea2c <am_hal_flash_delay_status_check>:
//*****************************************************************************
uint32_t
am_hal_flash_delay_status_check(uint32_t ui32usMaxDelay, uint32_t ui32Address,
                                uint32_t ui32Mask, uint32_t ui32Value,
                                bool bIsEqual)
{
    ea2c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    ea30:	f89d e020 	ldrb.w	lr, [sp, #32]
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    ea34:	f8df 8248 	ldr.w	r8, [pc, #584]	; ec80 <am_hal_flash_delay_status_check+0x254>
{
    ea38:	4607      	mov	r7, r0
    ea3a:	460c      	mov	r4, r1
    ea3c:	4615      	mov	r5, r2
    ea3e:	461e      	mov	r6, r3
    ea40:	f1be 0f00 	cmp.w	lr, #0
    ea44:	f000 808e 	beq.w	eb64 <am_hal_flash_delay_status_check+0x138>
    ea48:	f010 0907 	ands.w	r9, r0, #7
    ea4c:	d044      	beq.n	ead8 <am_hal_flash_delay_status_check+0xac>
        //
        // Check the status
        //
        if ( bIsEqual )
        {
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    ea4e:	680b      	ldr	r3, [r1, #0]
    ea50:	4013      	ands	r3, r2
    ea52:	429e      	cmp	r6, r3
    ea54:	f000 8083 	beq.w	eb5e <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    ea58:	2001      	movs	r0, #1
    ea5a:	47c0      	blx	r8
    ea5c:	f1b9 0f01 	cmp.w	r9, #1
    ea60:	f107 37ff 	add.w	r7, r7, #4294967295
    ea64:	d038      	beq.n	ead8 <am_hal_flash_delay_status_check+0xac>
    ea66:	f1b9 0f02 	cmp.w	r9, #2
    ea6a:	d02e      	beq.n	eaca <am_hal_flash_delay_status_check+0x9e>
    ea6c:	f1b9 0f03 	cmp.w	r9, #3
    ea70:	d024      	beq.n	eabc <am_hal_flash_delay_status_check+0x90>
    ea72:	f1b9 0f04 	cmp.w	r9, #4
    ea76:	d01a      	beq.n	eaae <am_hal_flash_delay_status_check+0x82>
    ea78:	f1b9 0f05 	cmp.w	r9, #5
    ea7c:	d010      	beq.n	eaa0 <am_hal_flash_delay_status_check+0x74>
    ea7e:	f1b9 0f06 	cmp.w	r9, #6
    ea82:	d006      	beq.n	ea92 <am_hal_flash_delay_status_check+0x66>
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    ea84:	6820      	ldr	r0, [r4, #0]
    ea86:	4028      	ands	r0, r5
    ea88:	4286      	cmp	r6, r0
    ea8a:	d068      	beq.n	eb5e <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    ea8c:	2001      	movs	r0, #1
    ea8e:	47c0      	blx	r8
    ea90:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    ea92:	6821      	ldr	r1, [r4, #0]
    ea94:	4029      	ands	r1, r5
    ea96:	428e      	cmp	r6, r1
    ea98:	d061      	beq.n	eb5e <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    ea9a:	2001      	movs	r0, #1
    ea9c:	47c0      	blx	r8
    ea9e:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    eaa0:	6822      	ldr	r2, [r4, #0]
    eaa2:	402a      	ands	r2, r5
    eaa4:	4296      	cmp	r6, r2
    eaa6:	d05a      	beq.n	eb5e <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    eaa8:	2001      	movs	r0, #1
    eaaa:	47c0      	blx	r8
    eaac:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    eaae:	6823      	ldr	r3, [r4, #0]
    eab0:	402b      	ands	r3, r5
    eab2:	429e      	cmp	r6, r3
    eab4:	d053      	beq.n	eb5e <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    eab6:	2001      	movs	r0, #1
    eab8:	47c0      	blx	r8
    eaba:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    eabc:	6820      	ldr	r0, [r4, #0]
    eabe:	4028      	ands	r0, r5
    eac0:	4286      	cmp	r6, r0
    eac2:	d04c      	beq.n	eb5e <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    eac4:	2001      	movs	r0, #1
    eac6:	47c0      	blx	r8
    eac8:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    eaca:	6821      	ldr	r1, [r4, #0]
    eacc:	4029      	ands	r1, r5
    eace:	428e      	cmp	r6, r1
    ead0:	d045      	beq.n	eb5e <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    ead2:	2001      	movs	r0, #1
    ead4:	3f01      	subs	r7, #1
    ead6:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    ead8:	6822      	ldr	r2, [r4, #0]
    eada:	402a      	ands	r2, r5
    eadc:	4296      	cmp	r6, r2
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    eade:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    eae2:	d03c      	beq.n	eb5e <am_hal_flash_delay_status_check+0x132>
            {
                return AM_HAL_STATUS_SUCCESS;
            }
        }

        if ( ui32usMaxDelay-- )
    eae4:	2f00      	cmp	r7, #0
    eae6:	f000 80c8 	beq.w	ec7a <am_hal_flash_delay_status_check+0x24e>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    eaea:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    eaec:	6823      	ldr	r3, [r4, #0]
    eaee:	402b      	ands	r3, r5
    eaf0:	429e      	cmp	r6, r3
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    eaf2:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    eaf6:	d032      	beq.n	eb5e <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    eaf8:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    eafa:	6821      	ldr	r1, [r4, #0]
    eafc:	4029      	ands	r1, r5
    eafe:	428e      	cmp	r6, r1
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    eb00:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    eb04:	d02b      	beq.n	eb5e <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    eb06:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    eb08:	6822      	ldr	r2, [r4, #0]
    eb0a:	402a      	ands	r2, r5
    eb0c:	4296      	cmp	r6, r2
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    eb0e:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    eb12:	d024      	beq.n	eb5e <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    eb14:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    eb16:	6823      	ldr	r3, [r4, #0]
    eb18:	402b      	ands	r3, r5
    eb1a:	429e      	cmp	r6, r3
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    eb1c:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    eb20:	d01d      	beq.n	eb5e <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    eb22:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    eb24:	6821      	ldr	r1, [r4, #0]
    eb26:	4029      	ands	r1, r5
    eb28:	428e      	cmp	r6, r1
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    eb2a:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    eb2e:	d016      	beq.n	eb5e <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    eb30:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    eb32:	6822      	ldr	r2, [r4, #0]
    eb34:	402a      	ands	r2, r5
    eb36:	4296      	cmp	r6, r2
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    eb38:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    eb3c:	d00f      	beq.n	eb5e <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    eb3e:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    eb40:	6820      	ldr	r0, [r4, #0]
    eb42:	4028      	ands	r0, r5
    eb44:	4286      	cmp	r6, r0
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    eb46:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    eb4a:	d008      	beq.n	eb5e <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    eb4c:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    eb4e:	6822      	ldr	r2, [r4, #0]
    eb50:	402a      	ands	r2, r5
    eb52:	4296      	cmp	r6, r2
    eb54:	f1a7 0708 	sub.w	r7, r7, #8
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    eb58:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    eb5c:	d1c2      	bne.n	eae4 <am_hal_flash_delay_status_check+0xb8>
                return AM_HAL_STATUS_SUCCESS;
    eb5e:	2000      	movs	r0, #0
        }
    }

    return AM_HAL_STATUS_TIMEOUT;

} // am_hal_flash_delay_status_check()
    eb60:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    eb64:	f010 0907 	ands.w	r9, r0, #7
    eb68:	d043      	beq.n	ebf2 <am_hal_flash_delay_status_check+0x1c6>
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
    eb6a:	680b      	ldr	r3, [r1, #0]
    eb6c:	4013      	ands	r3, r2
    eb6e:	429e      	cmp	r6, r3
    eb70:	d1f5      	bne.n	eb5e <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    eb72:	2001      	movs	r0, #1
    eb74:	47c0      	blx	r8
    eb76:	f1b9 0f01 	cmp.w	r9, #1
    eb7a:	f107 37ff 	add.w	r7, r7, #4294967295
    eb7e:	d038      	beq.n	ebf2 <am_hal_flash_delay_status_check+0x1c6>
    eb80:	f1b9 0f02 	cmp.w	r9, #2
    eb84:	d02e      	beq.n	ebe4 <am_hal_flash_delay_status_check+0x1b8>
    eb86:	f1b9 0f03 	cmp.w	r9, #3
    eb8a:	d024      	beq.n	ebd6 <am_hal_flash_delay_status_check+0x1aa>
    eb8c:	f1b9 0f04 	cmp.w	r9, #4
    eb90:	d01a      	beq.n	ebc8 <am_hal_flash_delay_status_check+0x19c>
    eb92:	f1b9 0f05 	cmp.w	r9, #5
    eb96:	d010      	beq.n	ebba <am_hal_flash_delay_status_check+0x18e>
    eb98:	f1b9 0f06 	cmp.w	r9, #6
    eb9c:	d006      	beq.n	ebac <am_hal_flash_delay_status_check+0x180>
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
    eb9e:	6821      	ldr	r1, [r4, #0]
    eba0:	4029      	ands	r1, r5
    eba2:	428e      	cmp	r6, r1
    eba4:	d1db      	bne.n	eb5e <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    eba6:	2001      	movs	r0, #1
    eba8:	47c0      	blx	r8
    ebaa:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
    ebac:	6822      	ldr	r2, [r4, #0]
    ebae:	402a      	ands	r2, r5
    ebb0:	4296      	cmp	r6, r2
    ebb2:	d1d4      	bne.n	eb5e <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    ebb4:	2001      	movs	r0, #1
    ebb6:	47c0      	blx	r8
    ebb8:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
    ebba:	6820      	ldr	r0, [r4, #0]
    ebbc:	4028      	ands	r0, r5
    ebbe:	4286      	cmp	r6, r0
    ebc0:	d1cd      	bne.n	eb5e <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    ebc2:	2001      	movs	r0, #1
    ebc4:	47c0      	blx	r8
    ebc6:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
    ebc8:	6823      	ldr	r3, [r4, #0]
    ebca:	402b      	ands	r3, r5
    ebcc:	429e      	cmp	r6, r3
    ebce:	d1c6      	bne.n	eb5e <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    ebd0:	2001      	movs	r0, #1
    ebd2:	47c0      	blx	r8
    ebd4:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
    ebd6:	6821      	ldr	r1, [r4, #0]
    ebd8:	4029      	ands	r1, r5
    ebda:	428e      	cmp	r6, r1
    ebdc:	d1bf      	bne.n	eb5e <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    ebde:	2001      	movs	r0, #1
    ebe0:	47c0      	blx	r8
    ebe2:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
    ebe4:	6822      	ldr	r2, [r4, #0]
    ebe6:	402a      	ands	r2, r5
    ebe8:	4296      	cmp	r6, r2
    ebea:	d1b8      	bne.n	eb5e <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    ebec:	2001      	movs	r0, #1
    ebee:	3f01      	subs	r7, #1
    ebf0:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
    ebf2:	6823      	ldr	r3, [r4, #0]
    ebf4:	402b      	ands	r3, r5
    ebf6:	429e      	cmp	r6, r3
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    ebf8:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
    ebfc:	d1af      	bne.n	eb5e <am_hal_flash_delay_status_check+0x132>
        if ( ui32usMaxDelay-- )
    ebfe:	2f00      	cmp	r7, #0
    ec00:	d03b      	beq.n	ec7a <am_hal_flash_delay_status_check+0x24e>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    ec02:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
    ec04:	6821      	ldr	r1, [r4, #0]
    ec06:	4029      	ands	r1, r5
    ec08:	428e      	cmp	r6, r1
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    ec0a:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
    ec0e:	d1a6      	bne.n	eb5e <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    ec10:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
    ec12:	6822      	ldr	r2, [r4, #0]
    ec14:	402a      	ands	r2, r5
    ec16:	4296      	cmp	r6, r2
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    ec18:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
    ec1c:	d19f      	bne.n	eb5e <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    ec1e:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
    ec20:	6823      	ldr	r3, [r4, #0]
    ec22:	402b      	ands	r3, r5
    ec24:	429e      	cmp	r6, r3
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    ec26:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
    ec2a:	d198      	bne.n	eb5e <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    ec2c:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
    ec2e:	6821      	ldr	r1, [r4, #0]
    ec30:	4029      	ands	r1, r5
    ec32:	428e      	cmp	r6, r1
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    ec34:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
    ec38:	d191      	bne.n	eb5e <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    ec3a:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
    ec3c:	6822      	ldr	r2, [r4, #0]
    ec3e:	402a      	ands	r2, r5
    ec40:	4296      	cmp	r6, r2
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    ec42:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
    ec46:	d18a      	bne.n	eb5e <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    ec48:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
    ec4a:	6823      	ldr	r3, [r4, #0]
    ec4c:	402b      	ands	r3, r5
    ec4e:	429e      	cmp	r6, r3
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    ec50:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
    ec54:	d183      	bne.n	eb5e <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    ec56:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
    ec58:	6820      	ldr	r0, [r4, #0]
    ec5a:	4028      	ands	r0, r5
    ec5c:	4286      	cmp	r6, r0
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    ec5e:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
    ec62:	f47f af7c 	bne.w	eb5e <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    ec66:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
    ec68:	6823      	ldr	r3, [r4, #0]
    ec6a:	402b      	ands	r3, r5
    ec6c:	429e      	cmp	r6, r3
    ec6e:	f1a7 0708 	sub.w	r7, r7, #8
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    ec72:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
    ec76:	d0c2      	beq.n	ebfe <am_hal_flash_delay_status_check+0x1d2>
    ec78:	e771      	b.n	eb5e <am_hal_flash_delay_status_check+0x132>
    return AM_HAL_STATUS_TIMEOUT;
    ec7a:	2004      	movs	r0, #4
    ec7c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    ec80:	0800009d 	.word	0x0800009d

0000ec84 <am_hal_gpio_pinconfig>:
    uint32_t ui32Padreg, ui32AltPadCfg, ui32GPCfg;
    uint32_t ui32Funcsel, ui32PowerSw;
    bool bClearEnable = false;

#ifdef AM_HAL_ENABLE_API_VALIDATION
    if ( ui32Pin > 49 )
    ec84:	2831      	cmp	r0, #49	; 0x31
    ec86:	d901      	bls.n	ec8c <am_hal_gpio_pinconfig+0x8>
    {
        return AM_HAL_STATUS_INVALID_ARG;
    ec88:	2006      	movs	r0, #6
    ec8a:	4770      	bx	lr
{
    ec8c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ui32GPCfg = ui32Padreg = ui32AltPadCfg = 0;

    //
    // Get the requested function and/or power switch.
    //
    ui32Funcsel = bfGpioCfg.uFuncSel;
    ec90:	f001 0307 	and.w	r3, r1, #7
    ui32Padreg |= ui32Funcsel << PADREG_FLD_FNSEL_S;

    //
    // Check for invalid configuration requests.
    //
    if ( bfGpioCfg.ePullup != AM_HAL_GPIO_PIN_PULLUP_NONE )
    ec94:	f011 04e0 	ands.w	r4, r1, #224	; 0xe0
{
    ec98:	b087      	sub	sp, #28
    ui32Padreg |= ui32Funcsel << PADREG_FLD_FNSEL_S;
    ec9a:	ea4f 05c3 	mov.w	r5, r3, lsl #3
    if ( bfGpioCfg.ePullup != AM_HAL_GPIO_PIN_PULLUP_NONE )
    ec9e:	d014      	beq.n	ecca <am_hal_gpio_pinconfig+0x46>
        ui32Padreg |= (0x1 << PADREG_FLD_PULLUP_S);

        //
        // Check for specific pullup or pulldown settings.
        //
        if ( (bfGpioCfg.ePullup >= AM_HAL_GPIO_PIN_PULLUP_1_5K) &&
    eca0:	f3c1 1642 	ubfx	r6, r1, #5, #3
    eca4:	1db2      	adds	r2, r6, #6
    eca6:	f002 0707 	and.w	r7, r2, #7
    ecaa:	2f03      	cmp	r7, #3
        ui32Padreg |= (0x1 << PADREG_FLD_PULLUP_S);
    ecac:	f045 0501 	orr.w	r5, r5, #1
        if ( (bfGpioCfg.ePullup >= AM_HAL_GPIO_PIN_PULLUP_1_5K) &&
    ecb0:	f200 80ab 	bhi.w	ee0a <am_hal_gpio_pinconfig+0x186>
             (bfGpioCfg.ePullup <= AM_HAL_GPIO_PIN_PULLUP_24K) )
        {
            ui32Padreg |= ((bfGpioCfg.ePullup - AM_HAL_GPIO_PIN_PULLUP_1_5K) <<
                           PADREG_FLD_76_S);
#ifdef AM_HAL_ENABLE_API_VALIDATION
            if ( !(g_ui8Bit76Capabilities[ui32Pin] & CAP_PUP) )
    ecb4:	4a85      	ldr	r2, [pc, #532]	; (eecc <am_hal_gpio_pinconfig+0x248>)
    ecb6:	5c17      	ldrb	r7, [r2, r0]
    ecb8:	07ff      	lsls	r7, r7, #31
    ecba:	d403      	bmi.n	ecc4 <am_hal_gpio_pinconfig+0x40>
            {
                return AM_HAL_GPIO_ERR_PULLUP;
    ecbc:	4884      	ldr	r0, [pc, #528]	; (eed0 <am_hal_gpio_pinconfig+0x24c>)

    AM_CRITICAL_END

    return AM_HAL_STATUS_SUCCESS;

} // am_hal_gpio_pinconfig()
    ecbe:	b007      	add	sp, #28
    ecc0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            ui32Padreg |= ((bfGpioCfg.ePullup - AM_HAL_GPIO_PIN_PULLUP_1_5K) <<
    ecc4:	1eb4      	subs	r4, r6, #2
    ecc6:	ea45 1584 	orr.w	r5, r5, r4, lsl #6
    ui32PowerSw = bfGpioCfg.ePowerSw;
    ecca:	f3c1 06c1 	ubfx	r6, r1, #3, #2
    if ( ui32PowerSw != AM_HAL_GPIO_PIN_POWERSW_NONE )
    ecce:	2e00      	cmp	r6, #0
    ecd0:	f040 8095 	bne.w	edfe <am_hal_gpio_pinconfig+0x17a>
    ui32Padreg |= (g_ui8Inpen[ui32Pin] & (1 << ui32Funcsel)) ? (1 << PADREG_FLD_INPEN_S) : 0;
    ecd4:	4a7f      	ldr	r2, [pc, #508]	; (eed4 <am_hal_gpio_pinconfig+0x250>)
    if ( g_ui8nCEpins[ui32Pin] == ui32Funcsel )
    ecd6:	4f80      	ldr	r7, [pc, #512]	; (eed8 <am_hal_gpio_pinconfig+0x254>)
    ui32Padreg |= (g_ui8Inpen[ui32Pin] & (1 << ui32Funcsel)) ? (1 << PADREG_FLD_INPEN_S) : 0;
    ecd8:	5c16      	ldrb	r6, [r2, r0]
    if ( g_ui8nCEpins[ui32Pin] == ui32Funcsel )
    ecda:	f817 8000 	ldrb.w	r8, [r7, r0]
    ui32Padreg |= (g_ui8Inpen[ui32Pin] & (1 << ui32Funcsel)) ? (1 << PADREG_FLD_INPEN_S) : 0;
    ecde:	411e      	asrs	r6, r3
    ece0:	f016 0f01 	tst.w	r6, #1
    ece4:	bf0c      	ite	eq
    ece6:	2600      	moveq	r6, #0
    ece8:	2602      	movne	r6, #2
    if ( g_ui8nCEpins[ui32Pin] == ui32Funcsel )
    ecea:	4543      	cmp	r3, r8
    ui32Padreg |= (g_ui8Inpen[ui32Pin] & (1 << ui32Funcsel)) ? (1 << PADREG_FLD_INPEN_S) : 0;
    ecec:	ea45 0506 	orr.w	r5, r5, r6
    if ( g_ui8nCEpins[ui32Pin] == ui32Funcsel )
    ecf0:	f000 8097 	beq.w	ee22 <am_hal_gpio_pinconfig+0x19e>
                     (((bfGpioCfg.eIntDir >> 0) & 0x1) << GPIOCFG_FLD_INTD_S)   |
    ecf4:	f3c1 3341 	ubfx	r3, r1, #13, #2
    ecf8:	00df      	lsls	r7, r3, #3
        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
    ecfa:	f3c1 2907 	ubfx	r9, r1, #8, #8
                     (((bfGpioCfg.eIntDir >> 0) & 0x1) << GPIOCFG_FLD_INTD_S)   |
    ecfe:	f007 0408 	and.w	r4, r7, #8
                     (((bfGpioCfg.eIntDir >> 1) & 0x1) << GPIOCFG_FLD_INCFG_S);
    ed02:	105a      	asrs	r2, r3, #1
        ui32GPCfg |= (bfGpioCfg.eGPOutcfg << GPIOCFG_FLD_OUTCFG_S)              |
    ed04:	f3c1 2681 	ubfx	r6, r1, #10, #2
        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
    ed08:	f009 070c 	and.w	r7, r9, #12
                     (((bfGpioCfg.eIntDir >> 0) & 0x1) << GPIOCFG_FLD_INTD_S)   |
    ed0c:	ea42 0346 	orr.w	r3, r2, r6, lsl #1
        ui32Padreg |= (bfGpioCfg.eGPInput << PADREG_FLD_INPEN_S);
    ed10:	f3c1 3a00 	ubfx	sl, r1, #12, #1
        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
    ed14:	2f04      	cmp	r7, #4
                     (((bfGpioCfg.eIntDir >> 0) & 0x1) << GPIOCFG_FLD_INTD_S)   |
    ed16:	ea43 0804 	orr.w	r8, r3, r4
        ui32Padreg |= (bfGpioCfg.eGPInput << PADREG_FLD_INPEN_S);
    ed1a:	ea45 054a 	orr.w	r5, r5, sl, lsl #1
        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
    ed1e:	f000 808d 	beq.w	ee3c <am_hal_gpio_pinconfig+0x1b8>
    ui32B = *((uint32_t*)cfg2);
    ed22:	4a6e      	ldr	r2, [pc, #440]	; (eedc <am_hal_gpio_pinconfig+0x258>)
        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
    ed24:	6816      	ldr	r6, [r2, #0]
    ed26:	1b8c      	subs	r4, r1, r6
    ed28:	fab4 f384 	clz	r3, r4
    ed2c:	095f      	lsrs	r7, r3, #5
    ed2e:	9700      	str	r7, [sp, #0]
        if ( bfGpioCfg.eIntDir == 0 )
    ed30:	f019 0f60 	tst.w	r9, #96	; 0x60
            ui32GPCfg |= (bfGpioCfg.eGPRdZero << GPIOCFG_FLD_INCFG_S);
    ed34:	bf04      	itt	eq
    ed36:	f3c1 37c0 	ubfxeq	r7, r1, #15, #1
    ed3a:	f367 0800 	bfieq	r8, r7, #0, #1
    ed3e:	0087      	lsls	r7, r0, #2
    switch ( bfGpioCfg.eDriveStrength )
    ed40:	f3c1 2101 	ubfx	r1, r1, #8, #2
    ed44:	2902      	cmp	r1, #2
    ed46:	ea4f 04c0 	mov.w	r4, r0, lsl #3
    ed4a:	d07a      	beq.n	ee42 <am_hal_gpio_pinconfig+0x1be>
    ed4c:	d87f      	bhi.n	ee4e <am_hal_gpio_pinconfig+0x1ca>
    ed4e:	2901      	cmp	r1, #1
            ui32Padreg    |= (1 << PADREG_FLD_DRVSTR_S);
    ed50:	bf08      	it	eq
    ed52:	f045 0504 	orreq.w	r5, r5, #4
    ed56:	f004 0a18 	and.w	sl, r4, #24
            break;
    ed5a:	2200      	movs	r2, #0
    ed5c:	4604      	mov	r4, r0
    ed5e:	9203      	str	r2, [sp, #12]
    ui32GPCfgClearMask  = ~((uint32_t)0xF  << ui32GPCfgShft);
    ed60:	f04f 0b0f 	mov.w	fp, #15
    ui32GPCfgShft       = ((ui32Pin & 0x7) << 2);
    ed64:	f007 021c 	and.w	r2, r7, #28
    ui32GPCfgAddr       = (uint32_t)&GPIO->CFGA       + ((ui32Pin & ~0x7) >> 1);
    ed68:	485d      	ldr	r0, [pc, #372]	; (eee0 <am_hal_gpio_pinconfig+0x25c>)
    ui32AltpadAddr      = (uint32_t)&GPIO->ALTPADCFGA + (ui32Pin & ~0x3);
    ed6a:	495e      	ldr	r1, [pc, #376]	; (eee4 <am_hal_gpio_pinconfig+0x260>)
    ui32GPCfgAddr       = (uint32_t)&GPIO->CFGA       + ((ui32Pin & ~0x7) >> 1);
    ed6c:	4f5e      	ldr	r7, [pc, #376]	; (eee8 <am_hal_gpio_pinconfig+0x264>)
    ed6e:	9702      	str	r7, [sp, #8]
    ui32GPCfgClearMask  = ~((uint32_t)0xF  << ui32GPCfgShft);
    ed70:	fa0b f302 	lsl.w	r3, fp, r2
    ui32PadClearMask    = ~((uint32_t)0xFF << ui32PadShft);
    ed74:	f04f 0cff 	mov.w	ip, #255	; 0xff
    ed78:	fa0c f60a 	lsl.w	r6, ip, sl
    ui32AltpadAddr      = (uint32_t)&GPIO->ALTPADCFGA + (ui32Pin & ~0x3);
    ed7c:	9101      	str	r1, [sp, #4]
    ui32GPCfg     <<= ui32GPCfgShft;
    ed7e:	fa08 f802 	lsl.w	r8, r8, r2
    ui32GPCfgClearMask  = ~((uint32_t)0xF  << ui32GPCfgShft);
    ed82:	43df      	mvns	r7, r3
    ui32GPCfgAddr       = (uint32_t)&GPIO->CFGA       + ((ui32Pin & ~0x7) >> 1);
    ed84:	ea00 0954 	and.w	r9, r0, r4, lsr #1
    AM_CRITICAL_BEGIN
    ed88:	f000 f906 	bl	ef98 <am_hal_interrupt_master_disable>
    ed8c:	9005      	str	r0, [sp, #20]
    if ( bClearEnable )
    ed8e:	e89d 0009 	ldmia.w	sp, {r0, r3}
    ui32PadregAddr      = (uint32_t)&GPIO->PADREGA    + (ui32Pin & ~0x3);
    ed92:	f024 0b03 	bic.w	fp, r4, #3
    ui32Padreg    <<= ui32PadShft;
    ed96:	fa05 f50a 	lsl.w	r5, r5, sl
    ui32PadregAddr      = (uint32_t)&GPIO->PADREGA    + (ui32Pin & ~0x3);
    ed9a:	f10b 4a80 	add.w	sl, fp, #1073741824	; 0x40000000
    ui32PadClearMask    = ~((uint32_t)0xFF << ui32PadShft);
    ed9e:	43f6      	mvns	r6, r6
    ui32PadregAddr      = (uint32_t)&GPIO->PADREGA    + (ui32Pin & ~0x3);
    eda0:	f50a 3a80 	add.w	sl, sl, #65536	; 0x10000
    if ( bClearEnable )
    eda4:	9902      	ldr	r1, [sp, #8]
    eda6:	9a03      	ldr	r2, [sp, #12]
    eda8:	b150      	cbz	r0, edc0 <am_hal_gpio_pinconfig+0x13c>
        am_hal_gpio_output_tristate_disable(ui32Pin);
    edaa:	f004 001f 	and.w	r0, r4, #31
    edae:	ea4f 1e54 	mov.w	lr, r4, lsr #5
    edb2:	f04f 0c01 	mov.w	ip, #1
    edb6:	4c4d      	ldr	r4, [pc, #308]	; (eeec <am_hal_gpio_pinconfig+0x268>)
    edb8:	fa0c f000 	lsl.w	r0, ip, r0
    edbc:	f844 002e 	str.w	r0, [r4, lr, lsl #2]
    GPIO->PADKEY = GPIO_PADKEY_PADKEY_Key;
    edc0:	484b      	ldr	r0, [pc, #300]	; (eef0 <am_hal_gpio_pinconfig+0x26c>)
    edc2:	2473      	movs	r4, #115	; 0x73
    edc4:	6604      	str	r4, [r0, #96]	; 0x60
    AM_REGVAL(ui32PadregAddr)  = (AM_REGVAL(ui32PadregAddr) & ui32PadClearMask)   | ui32Padreg;
    edc6:	f8da 4000 	ldr.w	r4, [sl]
    edca:	4034      	ands	r4, r6
    edcc:	4325      	orrs	r5, r4
    edce:	f8ca 5000 	str.w	r5, [sl]
    AM_REGVAL(ui32GPCfgAddr)   = (AM_REGVAL(ui32GPCfgAddr)  & ui32GPCfgClearMask) | ui32GPCfg;
    edd2:	f859 5001 	ldr.w	r5, [r9, r1]
    edd6:	402f      	ands	r7, r5
    edd8:	ea47 0708 	orr.w	r7, r7, r8
    eddc:	f849 7001 	str.w	r7, [r9, r1]
    AM_REGVAL(ui32AltpadAddr)  = (AM_REGVAL(ui32AltpadAddr) & ui32PadClearMask)   | ui32AltPadCfg;
    ede0:	f85b 1003 	ldr.w	r1, [fp, r3]
    ede4:	400e      	ands	r6, r1
    ede6:	4332      	orrs	r2, r6
    GPIO->PADKEY = 0;
    ede8:	2600      	movs	r6, #0
    AM_REGVAL(ui32AltpadAddr)  = (AM_REGVAL(ui32AltpadAddr) & ui32PadClearMask)   | ui32AltPadCfg;
    edea:	f84b 2003 	str.w	r2, [fp, r3]
    GPIO->PADKEY = 0;
    edee:	6606      	str	r6, [r0, #96]	; 0x60
    AM_CRITICAL_END
    edf0:	9805      	ldr	r0, [sp, #20]
    edf2:	f000 f8d5 	bl	efa0 <am_hal_interrupt_master_set>
    return AM_HAL_STATUS_SUCCESS;
    edf6:	4630      	mov	r0, r6
} // am_hal_gpio_pinconfig()
    edf8:	b007      	add	sp, #28
    edfa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ( (ui32PowerSw == AM_HAL_GPIO_PIN_POWERSW_VDD)  &&
    edfe:	2e01      	cmp	r6, #1
    ee00:	d015      	beq.n	ee2e <am_hal_gpio_pinconfig+0x1aa>
        else if ( (ui32PowerSw == AM_HAL_GPIO_PIN_POWERSW_VSS)  &&
    ee02:	2e02      	cmp	r6, #2
    ee04:	d030      	beq.n	ee68 <am_hal_gpio_pinconfig+0x1e4>
            return AM_HAL_GPIO_ERR_PWRSW;
    ee06:	483b      	ldr	r0, [pc, #236]	; (eef4 <am_hal_gpio_pinconfig+0x270>)
    ee08:	e759      	b.n	ecbe <am_hal_gpio_pinconfig+0x3a>
        else if ( bfGpioCfg.ePullup == AM_HAL_GPIO_PIN_PULLDOWN )
    ee0a:	2cc0      	cmp	r4, #192	; 0xc0
    ee0c:	d027      	beq.n	ee5e <am_hal_gpio_pinconfig+0x1da>
        else if ( bfGpioCfg.ePullup == AM_HAL_GPIO_PIN_PULLUP_WEAK )
    ee0e:	2c20      	cmp	r4, #32
    ee10:	f47f af5b 	bne.w	ecca <am_hal_gpio_pinconfig+0x46>
            if ( g_ui8Bit76Capabilities[ui32Pin] & (CAP_PUP | CAP_PDN) )
    ee14:	4c2d      	ldr	r4, [pc, #180]	; (eecc <am_hal_gpio_pinconfig+0x248>)
    ee16:	5c26      	ldrb	r6, [r4, r0]
    ee18:	f016 0f09 	tst.w	r6, #9
    ee1c:	f47f af4e 	bne.w	ecbc <am_hal_gpio_pinconfig+0x38>
    ee20:	e753      	b.n	ecca <am_hal_gpio_pinconfig+0x46>
        if ( bfGpioCfg.uIOMnum > IOMNUM_MAX )
    ee22:	f3c1 4202 	ubfx	r2, r1, #16, #3
    ee26:	2a07      	cmp	r2, #7
    ee28:	d125      	bne.n	ee76 <am_hal_gpio_pinconfig+0x1f2>
            return AM_HAL_GPIO_ERR_INVCE;   // Invalid CE specified
    ee2a:	4833      	ldr	r0, [pc, #204]	; (eef8 <am_hal_gpio_pinconfig+0x274>)
    ee2c:	e747      	b.n	ecbe <am_hal_gpio_pinconfig+0x3a>
             (g_ui8Bit76Capabilities[ui32Pin] & CAP_VDD) )
    ee2e:	4c27      	ldr	r4, [pc, #156]	; (eecc <am_hal_gpio_pinconfig+0x248>)
        if ( (ui32PowerSw == AM_HAL_GPIO_PIN_POWERSW_VDD)  &&
    ee30:	5c26      	ldrb	r6, [r4, r0]
    ee32:	07b4      	lsls	r4, r6, #30
    ee34:	d5e7      	bpl.n	ee06 <am_hal_gpio_pinconfig+0x182>
            ui32Padreg |= 0x1 << PADREG_FLD_76_S;
    ee36:	f045 0540 	orr.w	r5, r5, #64	; 0x40
    ee3a:	e74b      	b.n	ecd4 <am_hal_gpio_pinconfig+0x50>
            bClearEnable = true;
    ee3c:	2701      	movs	r7, #1
    ee3e:	9700      	str	r7, [sp, #0]
    ee40:	e776      	b.n	ed30 <am_hal_gpio_pinconfig+0xac>
    ee42:	f004 0a18 	and.w	sl, r4, #24
    ee46:	2301      	movs	r3, #1
    ee48:	fa03 f20a 	lsl.w	r2, r3, sl
            break;
    ee4c:	e786      	b.n	ed5c <am_hal_gpio_pinconfig+0xd8>
    ee4e:	f004 0a18 	and.w	sl, r4, #24
    ee52:	2601      	movs	r6, #1
            ui32Padreg    |= (1 << PADREG_FLD_DRVSTR_S);
    ee54:	f045 0504 	orr.w	r5, r5, #4
    ee58:	fa06 f20a 	lsl.w	r2, r6, sl
            break;
    ee5c:	e77e      	b.n	ed5c <am_hal_gpio_pinconfig+0xd8>
            if ( ui32Pin != 20 )
    ee5e:	2814      	cmp	r0, #20
    ee60:	f43f af33 	beq.w	ecca <am_hal_gpio_pinconfig+0x46>
                return AM_HAL_GPIO_ERR_PULLDOWN;
    ee64:	4825      	ldr	r0, [pc, #148]	; (eefc <am_hal_gpio_pinconfig+0x278>)
    ee66:	e72a      	b.n	ecbe <am_hal_gpio_pinconfig+0x3a>
                  (g_ui8Bit76Capabilities[ui32Pin] & CAP_VSS) )
    ee68:	4a18      	ldr	r2, [pc, #96]	; (eecc <am_hal_gpio_pinconfig+0x248>)
        else if ( (ui32PowerSw == AM_HAL_GPIO_PIN_POWERSW_VSS)  &&
    ee6a:	5c17      	ldrb	r7, [r2, r0]
    ee6c:	077a      	lsls	r2, r7, #29
    ee6e:	d5ca      	bpl.n	ee06 <am_hal_gpio_pinconfig+0x182>
            ui32Padreg |= 0x2 << PADREG_FLD_76_S;
    ee70:	f045 0580 	orr.w	r5, r5, #128	; 0x80
    ee74:	e72e      	b.n	ecd4 <am_hal_gpio_pinconfig+0x50>
            if ( g_ui8NCEtable[ui32Pin][ui32Outcfg] == ui8CEtbl )
    ee76:	4c22      	ldr	r4, [pc, #136]	; (ef00 <am_hal_gpio_pinconfig+0x27c>)
        ui8CEtbl = (bfGpioCfg.uIOMnum << 4) | bfGpioCfg.uNCE;
    ee78:	f3c1 4cc1 	ubfx	ip, r1, #19, #2
            if ( g_ui8NCEtable[ui32Pin][ui32Outcfg] == ui8CEtbl )
    ee7c:	f814 8020 	ldrb.w	r8, [r4, r0, lsl #2]
        ui8CEtbl = (bfGpioCfg.uIOMnum << 4) | bfGpioCfg.uNCE;
    ee80:	ea4c 1602 	orr.w	r6, ip, r2, lsl #4
            if ( g_ui8NCEtable[ui32Pin][ui32Outcfg] == ui8CEtbl )
    ee84:	45b0      	cmp	r8, r6
    ee86:	d010      	beq.n	eeaa <am_hal_gpio_pinconfig+0x226>
    ee88:	0087      	lsls	r7, r0, #2
    ee8a:	eb04 0907 	add.w	r9, r4, r7
    ee8e:	f899 3001 	ldrb.w	r3, [r9, #1]
    ee92:	42b3      	cmp	r3, r6
    ee94:	d015      	beq.n	eec2 <am_hal_gpio_pinconfig+0x23e>
    ee96:	f899 2002 	ldrb.w	r2, [r9, #2]
    ee9a:	42b2      	cmp	r2, r6
    ee9c:	d00f      	beq.n	eebe <am_hal_gpio_pinconfig+0x23a>
    ee9e:	f899 4003 	ldrb.w	r4, [r9, #3]
    eea2:	42b4      	cmp	r4, r6
    eea4:	d00f      	beq.n	eec6 <am_hal_gpio_pinconfig+0x242>
            return AM_HAL_GPIO_ERR_INVCEPIN;
    eea6:	4817      	ldr	r0, [pc, #92]	; (ef04 <am_hal_gpio_pinconfig+0x280>)
    eea8:	e709      	b.n	ecbe <am_hal_gpio_pinconfig+0x3a>
        for ( ui32Outcfg = 0; ui32Outcfg < 4; ui32Outcfg++ )
    eeaa:	2600      	movs	r6, #0
    eeac:	0087      	lsls	r7, r0, #2
        ui32GPCfg |= (ui32Outcfg       << GPIOCFG_FLD_OUTCFG_S) |
    eeae:	0072      	lsls	r2, r6, #1
                     (bfGpioCfg.eCEpol << GPIOCFG_FLD_INTD_S)   |
    eeb0:	f3c1 5e40 	ubfx	lr, r1, #21, #1
    bool bClearEnable = false;
    eeb4:	2300      	movs	r3, #0
                     (bfGpioCfg.eCEpol << GPIOCFG_FLD_INTD_S)   |
    eeb6:	ea42 08ce 	orr.w	r8, r2, lr, lsl #3
    bool bClearEnable = false;
    eeba:	9300      	str	r3, [sp, #0]
    eebc:	e740      	b.n	ed40 <am_hal_gpio_pinconfig+0xbc>
        for ( ui32Outcfg = 0; ui32Outcfg < 4; ui32Outcfg++ )
    eebe:	2602      	movs	r6, #2
    eec0:	e7f5      	b.n	eeae <am_hal_gpio_pinconfig+0x22a>
    eec2:	2601      	movs	r6, #1
    eec4:	e7f3      	b.n	eeae <am_hal_gpio_pinconfig+0x22a>
    eec6:	2603      	movs	r6, #3
    eec8:	e7f1      	b.n	eeae <am_hal_gpio_pinconfig+0x22a>
    eeca:	bf00      	nop
    eecc:	00010b9c 	.word	0x00010b9c
    eed0:	08000100 	.word	0x08000100
    eed4:	00010bd0 	.word	0x00010bd0
    eed8:	00010ccc 	.word	0x00010ccc
    eedc:	00010b94 	.word	0x00010b94
    eee0:	7ffffffc 	.word	0x7ffffffc
    eee4:	400100e0 	.word	0x400100e0
    eee8:	40010040 	.word	0x40010040
    eeec:	400100b4 	.word	0x400100b4
    eef0:	40010000 	.word	0x40010000
    eef4:	08000102 	.word	0x08000102
    eef8:	08000103 	.word	0x08000103
    eefc:	08000101 	.word	0x08000101
    ef00:	00010c04 	.word	0x00010c04
    ef04:	08000104 	.word	0x08000104

0000ef08 <am_hal_gpio_state_write>:
{
    uint32_t ui32Mask, ui32Off;
    uint32_t ui32Return = AM_HAL_STATUS_SUCCESS;

#ifdef AM_HAL_ENABLE_API_VALIDATION
    if ( ui32Pin >= AM_HAL_GPIO_MAX_PADS )
    ef08:	2831      	cmp	r0, #49	; 0x31
    ef0a:	d901      	bls.n	ef10 <am_hal_gpio_state_write+0x8>
    {
        return AM_HAL_STATUS_OUT_OF_RANGE;
    ef0c:	2005      	movs	r0, #5
    ef0e:	4770      	bx	lr
    }

    if ( eWriteType > AM_HAL_GPIO_OUTPUT_TRISTATE_TOGGLE )
    ef10:	2905      	cmp	r1, #5
    ef12:	d901      	bls.n	ef18 <am_hal_gpio_state_write+0x10>
    {
        return AM_HAL_STATUS_INVALID_ARG;
    ef14:	2006      	movs	r0, #6
    ef16:	4770      	bx	lr
{
    ef18:	b570      	push	{r4, r5, r6, lr}
    }
#endif // AM_HAL_ENABLE_API_VALIDATION

    ui32Mask = (uint32_t)0x1 << (ui32Pin % 32);
    ef1a:	f000 031f 	and.w	r3, r0, #31
{
    ef1e:	b082      	sub	sp, #8
    ui32Off  = (ui32Pin & 0x20) >> 3;   // 0 or 4
    ef20:	08c0      	lsrs	r0, r0, #3
    ui32Mask = (uint32_t)0x1 << (ui32Pin % 32);
    ef22:	2201      	movs	r2, #1
    ef24:	460d      	mov	r5, r1
    ui32Off  = (ui32Pin & 0x20) >> 3;   // 0 or 4
    ef26:	f000 0404 	and.w	r4, r0, #4
    ui32Mask = (uint32_t)0x1 << (ui32Pin % 32);
    ef2a:	fa02 f603 	lsl.w	r6, r2, r3

    AM_CRITICAL_BEGIN;
    ef2e:	f000 f833 	bl	ef98 <am_hal_interrupt_master_disable>

#if AM_CMSIS_REGS
    ui32Off /= 4;   // 0 or 1 for ptr arithmetic
    switch ( eWriteType )
    ef32:	1e69      	subs	r1, r5, #1
    AM_CRITICAL_BEGIN;
    ef34:	9001      	str	r0, [sp, #4]
    switch ( eWriteType )
    ef36:	2904      	cmp	r1, #4
    ef38:	d817      	bhi.n	ef6a <am_hal_gpio_state_write+0x62>
    ef3a:	e8df f001 	tbb	[pc, r1]
    ef3e:	0e13      	.short	0x0e13
    ef40:	030b      	.short	0x030b
    ef42:	19          	.byte	0x19
    ef43:	00          	.byte	0x00
            break;
        case AM_HAL_GPIO_OUTPUT_TOGGLE:             // Toggle the GPIO value.
            AM_REGVAL(&GPIO->WTA + ui32Off) ^= ui32Mask;
            break;
        case AM_HAL_GPIO_OUTPUT_TRISTATE_ENABLE:    // Enable  a tri-state GPIO.
            AM_REGVAL(&GPIO->ENSA + ui32Off) = ui32Mask;
    ef44:	4d0d      	ldr	r5, [pc, #52]	; (ef7c <am_hal_gpio_state_write+0x74>)
    ef46:	5166      	str	r6, [r4, r5]
            ui32Return = AM_HAL_STATUS_INVALID_ARG;
            break;
    }
#endif // AM_CMSIS_REGS

    AM_CRITICAL_END;
    ef48:	9801      	ldr	r0, [sp, #4]
    ef4a:	f000 f829 	bl	efa0 <am_hal_interrupt_master_set>

    return ui32Return;
    ef4e:	2000      	movs	r0, #0
} // am_hal_gpio_state_write()
    ef50:	b002      	add	sp, #8
    ef52:	bd70      	pop	{r4, r5, r6, pc}
            AM_REGVAL(&GPIO->ENCA + ui32Off) = ui32Mask;
    ef54:	4b0a      	ldr	r3, [pc, #40]	; (ef80 <am_hal_gpio_state_write+0x78>)
    ef56:	50e6      	str	r6, [r4, r3]
            break;
    ef58:	e7f6      	b.n	ef48 <am_hal_gpio_state_write+0x40>
            AM_REGVAL(&GPIO->WTA + ui32Off) ^= ui32Mask;
    ef5a:	480a      	ldr	r0, [pc, #40]	; (ef84 <am_hal_gpio_state_write+0x7c>)
    ef5c:	5822      	ldr	r2, [r4, r0]
    ef5e:	4072      	eors	r2, r6
    ef60:	5022      	str	r2, [r4, r0]
            break;
    ef62:	e7f1      	b.n	ef48 <am_hal_gpio_state_write+0x40>
            AM_REGVAL(&GPIO->WTSA + ui32Off) = ui32Mask;
    ef64:	4908      	ldr	r1, [pc, #32]	; (ef88 <am_hal_gpio_state_write+0x80>)
    ef66:	5066      	str	r6, [r4, r1]
            break;
    ef68:	e7ee      	b.n	ef48 <am_hal_gpio_state_write+0x40>
            AM_REGVAL(&GPIO->WTCA + ui32Off) = ui32Mask;
    ef6a:	4d08      	ldr	r5, [pc, #32]	; (ef8c <am_hal_gpio_state_write+0x84>)
    ef6c:	5166      	str	r6, [r4, r5]
            break;
    ef6e:	e7eb      	b.n	ef48 <am_hal_gpio_state_write+0x40>
            AM_REGVAL(&GPIO->ENCA + ui32Off) ^= ui32Mask;
    ef70:	4803      	ldr	r0, [pc, #12]	; (ef80 <am_hal_gpio_state_write+0x78>)
    ef72:	5823      	ldr	r3, [r4, r0]
    ef74:	4073      	eors	r3, r6
    ef76:	5023      	str	r3, [r4, r0]
            break;
    ef78:	e7e6      	b.n	ef48 <am_hal_gpio_state_write+0x40>
    ef7a:	bf00      	nop
    ef7c:	400100a8 	.word	0x400100a8
    ef80:	400100b4 	.word	0x400100b4
    ef84:	40010088 	.word	0x40010088
    ef88:	40010090 	.word	0x40010090
    ef8c:	40010098 	.word	0x40010098

0000ef90 <am_hal_interrupt_master_enable>:
//*****************************************************************************
#if defined(__GNUC_STDC_INLINE__)
uint32_t __attribute__((naked))
am_hal_interrupt_master_enable(void)
{
    __asm("    mrs     r0, PRIMASK");
    ef90:	f3ef 8010 	mrs	r0, PRIMASK
    __asm("    cpsie i");
    ef94:	b662      	cpsie	i
    __asm("    bx lr");
    ef96:	4770      	bx	lr

0000ef98 <am_hal_interrupt_master_disable>:
//*****************************************************************************
#if defined(__GNUC_STDC_INLINE__)
uint32_t __attribute__((naked))
am_hal_interrupt_master_disable(void)
{
    __asm("    mrs     r0, PRIMASK");
    ef98:	f3ef 8010 	mrs	r0, PRIMASK
    __asm("    cpsid i");
    ef9c:	b672      	cpsid	i
    __asm("    bx lr");
    ef9e:	4770      	bx	lr

0000efa0 <am_hal_interrupt_master_set>:
//*****************************************************************************
#if defined(__GNUC_STDC_INLINE__)
void __attribute__((naked))
am_hal_interrupt_master_set(uint32_t ui32InterruptState)
{
    __asm("    msr     PRIMASK, r0");
    efa0:	f380 8810 	msr	PRIMASK, r0
    __asm("    bx lr");
    efa4:	4770      	bx	lr
    efa6:	bf00      	nop

0000efa8 <internal_iom_reset_on_error>:

} // internal_iom_get_int_err()

static void
internal_iom_reset_on_error(am_hal_iom_state_t  *pIOMState, uint32_t ui32IntMask)
{
    efa8:	b570      	push	{r4, r5, r6, lr}
    uint32_t iterationsToWait = 2 * pIOMState->ui32BitTimeTicks; // effectively > 6 clocks
    uint32_t ui32Module = pIOMState->ui32Module;
#if AM_CMSIS_REGS
    uint32_t curIntCfg = IOMn(ui32Module)->INTEN;
    efaa:	6844      	ldr	r4, [r0, #4]
    uint32_t iterationsToWait = 2 * pIOMState->ui32BitTimeTicks; // effectively > 6 clocks
    efac:	f8d0 0830 	ldr.w	r0, [r0, #2096]	; 0x830
    uint32_t curIntCfg = IOMn(ui32Module)->INTEN;
    efb0:	f504 22a0 	add.w	r2, r4, #327680	; 0x50000
    efb4:	3204      	adds	r2, #4
    efb6:	0314      	lsls	r4, r2, #12
    IOMn(ui32Module)->INTEN = 0;
    efb8:	2300      	movs	r3, #0
    uint32_t curIntCfg = IOMn(ui32Module)->INTEN;
    efba:	f8d4 5200 	ldr.w	r5, [r4, #512]	; 0x200
    IOMn(ui32Module)->INTEN = 0;
    efbe:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200

    // Disable interrupts temporarily
    if (ui32IntMask & AM_HAL_IOM_INT_DERR)
    efc2:	050b      	lsls	r3, r1, #20
    efc4:	d52a      	bpl.n	f01c <internal_iom_reset_on_error+0x74>
    {
        if ((IOMn(ui32Module)->DMACFG & IOM0_DMACFG_DMADIR_Msk) == _VAL2FLD(IOM0_DMACFG_DMADIR, IOM0_DMACFG_DMADIR_M2P))
    efc6:	f8d4 6280 	ldr.w	r6, [r4, #640]	; 0x280
    efca:	07b6      	lsls	r6, r6, #30
    efcc:	d450      	bmi.n	f070 <internal_iom_reset_on_error+0xc8>
        }
        else
        {
            // Read
            // Let command finish
            while (IOMn(ui32Module)->STATUS_b.CMDACT)
    efce:	f8d4 22b4 	ldr.w	r2, [r4, #692]	; 0x2b4
    efd2:	0792      	lsls	r2, r2, #30
    efd4:	d508      	bpl.n	efe8 <internal_iom_reset_on_error+0x40>
            {
                while (IOMn(ui32Module)->FIFOPTR_b.FIFO1SIZ >= 4)
    efd6:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
    efda:	f3c3 4607 	ubfx	r6, r3, #16, #8
    efde:	2e03      	cmp	r6, #3
    efe0:	d9f5      	bls.n	efce <internal_iom_reset_on_error+0x26>
                {
                    // Read one 4-byte word from FIFO
                    IOMn(ui32Module)->FIFOPOP;
    efe2:	f8d4 3108 	ldr.w	r3, [r4, #264]	; 0x108
    efe6:	e7f6      	b.n	efd6 <internal_iom_reset_on_error+0x2e>
                    IOMn(ui32Module)->FIFOPOP = 0x11111111;
#endif
                }
            }
            // Now wait for command to finish
            while ((IOMn(ui32Module)->STATUS & (IOM0_STATUS_IDLEST_Msk | IOM0_STATUS_CMDACT_Msk)) != IOM0_STATUS_IDLEST_Msk);
    efe8:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
    efec:	f003 0606 	and.w	r6, r3, #6
    eff0:	2e04      	cmp	r6, #4
    eff2:	d1f9      	bne.n	efe8 <internal_iom_reset_on_error+0x40>
            // Flush any remaining data from FIFO
            while  (IOMn(ui32Module)->FIFOPTR_b.FIFO1SIZ)
    eff4:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
    eff8:	f3c2 4307 	ubfx	r3, r2, #16, #8
    effc:	b173      	cbz	r3, f01c <internal_iom_reset_on_error+0x74>
            {
                while (IOMn(ui32Module)->FIFOPTR_b.FIFO1SIZ >= 4)
    effe:	f8d4 6100 	ldr.w	r6, [r4, #256]	; 0x100
    f002:	f3c6 4207 	ubfx	r2, r6, #16, #8
    f006:	2a03      	cmp	r2, #3
    f008:	d9f4      	bls.n	eff4 <internal_iom_reset_on_error+0x4c>
                {
                    // Read one 4-byte word from FIFO
                    IOMn(ui32Module)->FIFOPOP;
    f00a:	f8d4 3108 	ldr.w	r3, [r4, #264]	; 0x108
    f00e:	e7f6      	b.n	effe <internal_iom_reset_on_error+0x56>
            while ((IOMn(ui32Module)->STATUS & (IOM0_STATUS_IDLEST_Msk | IOM0_STATUS_CMDACT_Msk)) != IOM0_STATUS_IDLEST_Msk);
    f010:	f8d4 22b4 	ldr.w	r2, [r4, #692]	; 0x2b4
    f014:	f002 0606 	and.w	r6, r2, #6
    f018:	2e04      	cmp	r6, #4
    f01a:	d1f9      	bne.n	f010 <internal_iom_reset_on_error+0x68>
#endif
                }
            }
        }
    }
    if (ui32IntMask & AM_HAL_IOM_INT_NAK)
    f01c:	06cb      	lsls	r3, r1, #27
    f01e:	d520      	bpl.n	f062 <internal_iom_reset_on_error+0xba>
    {
        //
        // Wait for Idle
        //
        while ((IOMn(ui32Module)->STATUS & (IOM0_STATUS_IDLEST_Msk | IOM0_STATUS_CMDACT_Msk)) != IOM0_STATUS_IDLEST_Msk);
    f020:	f8d4 12b4 	ldr.w	r1, [r4, #692]	; 0x2b4
    f024:	f001 0306 	and.w	r3, r1, #6
    f028:	2b04      	cmp	r3, #4
    f02a:	d1f9      	bne.n	f020 <internal_iom_reset_on_error+0x78>
        //
        // Reset Submodule & FIFO
        //
        // Disable the submodules
        //
        IOMn(ui32Module)->SUBMODCTRL_b.SMOD1EN = 0;
    f02c:	f894 2214 	ldrb.w	r2, [r4, #532]	; 0x214
    f030:	f36f 1204 	bfc	r2, #4, #1
    f034:	f884 2214 	strb.w	r2, [r4, #532]	; 0x214
        // Reset Fifo
        IOMn(ui32Module)->FIFOCTRL_b.FIFORSTN = 0;
    f038:	f894 6110 	ldrb.w	r6, [r4, #272]	; 0x110
    f03c:	f36f 0641 	bfc	r6, #1, #1

        // Wait for few IO clock cycles
        am_hal_flash_delay(iterationsToWait);
    f040:	0040      	lsls	r0, r0, #1
        IOMn(ui32Module)->FIFOCTRL_b.FIFORSTN = 0;
    f042:	f884 6110 	strb.w	r6, [r4, #272]	; 0x110
        am_hal_flash_delay(iterationsToWait);
    f046:	f7ff fced 	bl	ea24 <am_hal_flash_delay>

        IOMn(ui32Module)->FIFOCTRL_b.FIFORSTN = 1;
    f04a:	f894 0110 	ldrb.w	r0, [r4, #272]	; 0x110
    f04e:	f040 0102 	orr.w	r1, r0, #2
    f052:	f884 1110 	strb.w	r1, [r4, #272]	; 0x110

        // Enable submodule
        IOMn(ui32Module)->SUBMODCTRL_b.SMOD1EN = 1;
    f056:	f894 c214 	ldrb.w	ip, [r4, #532]	; 0x214
    f05a:	f04c 0310 	orr.w	r3, ip, #16
    f05e:	f884 3214 	strb.w	r3, [r4, #532]	; 0x214
    }

    IOMn(ui32Module)->INTCLR = AM_HAL_IOM_INT_ALL;
    f062:	f04f 32ff 	mov.w	r2, #4294967295
    f066:	f8c4 2208 	str.w	r2, [r4, #520]	; 0x208

    // Restore interrupts
    IOMn(ui32Module)->INTEN = curIntCfg;
    f06a:	f8c4 5200 	str.w	r5, [r4, #512]	; 0x200
    f06e:	bd70      	pop	{r4, r5, r6, pc}
            uint32_t numBytesRemaining = IOMn(ui32Module)->DMATOTCOUNT;
    f070:	f8d4 2288 	ldr.w	r2, [r4, #648]	; 0x288
                    IOMn(ui32Module)->FIFOPUSH = dummy;
    f074:	4e07      	ldr	r6, [pc, #28]	; (f094 <internal_iom_reset_on_error+0xec>)
            while (numBytesRemaining)
    f076:	2a00      	cmp	r2, #0
    f078:	d0ca      	beq.n	f010 <internal_iom_reset_on_error+0x68>
                if (IOMn(ui32Module)->FIFOPTR_b.FIFO0REM >= 4)
    f07a:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
    f07e:	f3c3 2307 	ubfx	r3, r3, #8, #8
    f082:	2b03      	cmp	r3, #3
    f084:	d9f9      	bls.n	f07a <internal_iom_reset_on_error+0xd2>
                    if (numBytesRemaining > 4)
    f086:	2a04      	cmp	r2, #4
                    IOMn(ui32Module)->FIFOPUSH = dummy;
    f088:	f8c4 610c 	str.w	r6, [r4, #268]	; 0x10c
                    if (numBytesRemaining > 4)
    f08c:	d9c0      	bls.n	f010 <internal_iom_reset_on_error+0x68>
                        numBytesRemaining -= 4;
    f08e:	3a04      	subs	r2, #4
    f090:	e7f1      	b.n	f076 <internal_iom_reset_on_error+0xce>
    f092:	bf00      	nop
    f094:	deadbeef 	.word	0xdeadbeef

0000f098 <am_hal_iom_uninitialize>:
{
    uint32_t status = AM_HAL_STATUS_SUCCESS;
    am_hal_iom_state_t *pIOMState = (am_hal_iom_state_t*)pHandle;

#ifndef AM_HAL_DISABLE_API_VALIDATION
    if (!AM_HAL_IOM_CHK_HANDLE(pHandle))
    f098:	b128      	cbz	r0, f0a6 <am_hal_iom_uninitialize+0xe>
    f09a:	6803      	ldr	r3, [r0, #0]
    f09c:	4a18      	ldr	r2, [pc, #96]	; (f100 <am_hal_iom_uninitialize+0x68>)
    f09e:	f023 417e 	bic.w	r1, r3, #4261412864	; 0xfe000000
    f0a2:	4291      	cmp	r1, r2
    f0a4:	d001      	beq.n	f0aa <am_hal_iom_uninitialize+0x12>
    {
        return AM_HAL_STATUS_INVALID_HANDLE;
    f0a6:	2002      	movs	r0, #2
    f0a8:	4770      	bx	lr
{
    f0aa:	b510      	push	{r4, lr}
    f0ac:	4604      	mov	r4, r0
    }
#endif

    if (pIOMState->prefix.s.bEnable)
    f0ae:	78c0      	ldrb	r0, [r0, #3]
    f0b0:	0783      	lsls	r3, r0, #30
    f0b2:	d405      	bmi.n	f0c0 <am_hal_iom_uninitialize+0x28>
    {
        am_hal_iom_disable(pHandle);
    }

    pIOMState->prefix.s.bInit = false;
    f0b4:	78e0      	ldrb	r0, [r4, #3]
    f0b6:	f36f 0000 	bfc	r0, #0, #1
    f0ba:	70e0      	strb	r0, [r4, #3]

    //
    // Return the status.
    //
    return status;
    f0bc:	2000      	movs	r0, #0
    f0be:	bd10      	pop	{r4, pc}

    //
    // Disable the submodules
    //
#if AM_CMSIS_REGS
    IOMn(pIOMState->ui32Module)->SUBMODCTRL_b.SMOD0EN = 0;
    f0c0:	6863      	ldr	r3, [r4, #4]
    f0c2:	f503 22a0 	add.w	r2, r3, #327680	; 0x50000
    f0c6:	3204      	adds	r2, #4
    f0c8:	0311      	lsls	r1, r2, #12
    f0ca:	f891 0214 	ldrb.w	r0, [r1, #532]	; 0x214
    f0ce:	f36f 0000 	bfc	r0, #0, #1
    f0d2:	f881 0214 	strb.w	r0, [r1, #532]	; 0x214
    IOMn(pIOMState->ui32Module)->SUBMODCTRL_b.SMOD1EN = 0;
    f0d6:	f891 3214 	ldrb.w	r3, [r1, #532]	; 0x214
    f0da:	f36f 1304 	bfc	r3, #4, #1
    f0de:	f881 3214 	strb.w	r3, [r1, #532]	; 0x214
    if (pIOMState->pCmdQHdl)
    f0e2:	f8d4 0828 	ldr.w	r0, [r4, #2088]	; 0x828
    f0e6:	b128      	cbz	r0, f0f4 <am_hal_iom_uninitialize+0x5c>
        am_hal_cmdq_term(pIOMState->pCmdQHdl, true);
    f0e8:	2101      	movs	r1, #1
    f0ea:	f001 fb6d 	bl	107c8 <am_hal_cmdq_term>
        pIOMState->pCmdQHdl = NULL;
    f0ee:	2200      	movs	r2, #0
    f0f0:	f8c4 2828 	str.w	r2, [r4, #2088]	; 0x828

#if (AM_HAL_IOM_CQ == 1)
    am_hal_IOM_CQReset(pHandle);
#endif

    pIOMState->prefix.s.bEnable = false;
    f0f4:	78e1      	ldrb	r1, [r4, #3]
    f0f6:	f36f 0141 	bfc	r1, #1, #1
    f0fa:	70e1      	strb	r1, [r4, #3]
    f0fc:	e7da      	b.n	f0b4 <am_hal_iom_uninitialize+0x1c>
    f0fe:	bf00      	nop
    f100:	01123456 	.word	0x01123456

0000f104 <am_hal_iom_initialize>:
    if ( ui32Module >= AM_REG_IOM_NUM_MODULES )
    f104:	2805      	cmp	r0, #5
    f106:	d901      	bls.n	f10c <am_hal_iom_initialize+0x8>
        return AM_HAL_STATUS_OUT_OF_RANGE;
    f108:	2005      	movs	r0, #5
} // am_hal_iom_initialize()
    f10a:	4770      	bx	lr
    if (ppHandle == NULL)
    f10c:	b1d9      	cbz	r1, f146 <am_hal_iom_initialize+0x42>
{
    f10e:	b4f0      	push	{r4, r5, r6, r7}
    if (g_IOMhandles[ui32Module].prefix.s.bInit)
    f110:	f640 026c 	movw	r2, #2156	; 0x86c
    f114:	4e0d      	ldr	r6, [pc, #52]	; (f14c <am_hal_iom_initialize+0x48>)
    f116:	fb02 f200 	mul.w	r2, r2, r0
    f11a:	18b5      	adds	r5, r6, r2
    f11c:	78ec      	ldrb	r4, [r5, #3]
    f11e:	f014 0301 	ands.w	r3, r4, #1
    f122:	d003      	beq.n	f12c <am_hal_iom_initialize+0x28>
        return AM_HAL_STATUS_INVALID_OPERATION;
    f124:	2307      	movs	r3, #7
} // am_hal_iom_initialize()
    f126:	4618      	mov	r0, r3
    f128:	bcf0      	pop	{r4, r5, r6, r7}
    f12a:	4770      	bx	lr
    g_IOMhandles[ui32Module].prefix.s.bEnable = false;
    f12c:	f044 0701 	orr.w	r7, r4, #1
    f130:	f363 0741 	bfi	r7, r3, #1, #1
    f134:	70ef      	strb	r7, [r5, #3]
    g_IOMhandles[ui32Module].prefix.s.magic = AM_HAL_MAGIC_IOM;
    f136:	58b4      	ldr	r4, [r6, r2]
    f138:	4f05      	ldr	r7, [pc, #20]	; (f150 <am_hal_iom_initialize+0x4c>)
    f13a:	f367 0417 	bfi	r4, r7, #0, #24
    f13e:	50b4      	str	r4, [r6, r2]
    g_IOMhandles[ui32Module].ui32Module = ui32Module;
    f140:	6068      	str	r0, [r5, #4]
    *ppHandle = (void *)&g_IOMhandles[ui32Module];
    f142:	600d      	str	r5, [r1, #0]
    return AM_HAL_STATUS_SUCCESS;
    f144:	e7ef      	b.n	f126 <am_hal_iom_initialize+0x22>
        return AM_HAL_STATUS_INVALID_ARG;
    f146:	2006      	movs	r0, #6
    f148:	e7df      	b.n	f10a <am_hal_iom_initialize+0x6>
    f14a:	bf00      	nop
    f14c:	100018c4 	.word	0x100018c4
    f150:	00123456 	.word	0x00123456

0000f154 <am_hal_iom_enable>:
    if (!AM_HAL_IOM_CHK_HANDLE(pHandle))
    f154:	b128      	cbz	r0, f162 <am_hal_iom_enable+0xe>
    f156:	6803      	ldr	r3, [r0, #0]
    f158:	4a28      	ldr	r2, [pc, #160]	; (f1fc <am_hal_iom_enable+0xa8>)
    f15a:	f023 417e 	bic.w	r1, r3, #4261412864	; 0xfe000000
    f15e:	4291      	cmp	r1, r2
    f160:	d001      	beq.n	f166 <am_hal_iom_enable+0x12>
        return AM_HAL_STATUS_INVALID_HANDLE;
    f162:	2002      	movs	r0, #2
    f164:	4770      	bx	lr
    if (pIOMState->prefix.s.bEnable)
    f166:	f890 c003 	ldrb.w	ip, [r0, #3]
    f16a:	ea5f 738c 	movs.w	r3, ip, lsl #30
    f16e:	d442      	bmi.n	f1f6 <am_hal_iom_enable+0xa2>
{
    f170:	b530      	push	{r4, r5, lr}
    enable_submodule(pIOMState->ui32Module, ((pIOMState->eInterfaceMode == AM_HAL_IOM_SPI_MODE) ? 0 : 1));
    f172:	6845      	ldr	r5, [r0, #4]
    f174:	7a04      	ldrb	r4, [r0, #8]
    if ( IOMn(ui32Module)->SUBMODCTRL_b.SMOD0TYPE == ui32Type )
    f176:	f505 23a0 	add.w	r3, r5, #327680	; 0x50000
    f17a:	3304      	adds	r3, #4
    f17c:	031b      	lsls	r3, r3, #12
    enable_submodule(pIOMState->ui32Module, ((pIOMState->eInterfaceMode == AM_HAL_IOM_SPI_MODE) ? 0 : 1));
    f17e:	1c21      	adds	r1, r4, #0
    if ( IOMn(ui32Module)->SUBMODCTRL_b.SMOD0TYPE == ui32Type )
    f180:	f8d3 2214 	ldr.w	r2, [r3, #532]	; 0x214
    enable_submodule(pIOMState->ui32Module, ((pIOMState->eInterfaceMode == AM_HAL_IOM_SPI_MODE) ? 0 : 1));
    f184:	bf18      	it	ne
    f186:	2101      	movne	r1, #1
    if ( IOMn(ui32Module)->SUBMODCTRL_b.SMOD0TYPE == ui32Type )
    f188:	f3c2 0442 	ubfx	r4, r2, #1, #3
    f18c:	42a1      	cmp	r1, r4
        IOMn(ui32Module)->SUBMODCTRL =
    f18e:	bf0c      	ite	eq
    f190:	2401      	moveq	r4, #1
        IOMn(ui32Module)->SUBMODCTRL =
    f192:	2410      	movne	r4, #16
    f194:	f8c3 4214 	str.w	r4, [r3, #532]	; 0x214
    f198:	4604      	mov	r4, r0
    if ( pIOMState->pNBTxnBuf )
    f19a:	68c0      	ldr	r0, [r0, #12]
{
    f19c:	b085      	sub	sp, #20
    if ( pIOMState->pNBTxnBuf )
    f19e:	b1f8      	cbz	r0, f1e0 <am_hal_iom_enable+0x8c>
        status = am_hal_iom_CQInit(pIOMState,
    f1a0:	6921      	ldr	r1, [r4, #16]
    cqCfg.pCmdQBuf = pTCB;
    f1a2:	9002      	str	r0, [sp, #8]
        pIOMState->ui32NumPendTransactions = 0;
    f1a4:	2300      	movs	r3, #0
    ui32Status = am_hal_cmdq_init((am_hal_cmdq_if_e)(AM_HAL_CMDQ_IF_IOM0 + ui32Module),
    f1a6:	b2e8      	uxtb	r0, r5
        pIOMState->ui32NumPendTransactions = 0;
    f1a8:	6263      	str	r3, [r4, #36]	; 0x24
    cqCfg.cmdQSize = ui32Length / 2;
    f1aa:	084d      	lsrs	r5, r1, #1
        pIOMState->ui32LastIdxProcessed = 0;
    f1ac:	61e3      	str	r3, [r4, #28]
    pIOMState->pCmdQHdl = NULL;
    f1ae:	f8c4 3828 	str.w	r3, [r4, #2088]	; 0x828
    pIOMState->ui32MaxTransactions = 0;
    f1b2:	6223      	str	r3, [r4, #32]
    cqCfg.priority = AM_HAL_CMDQ_PRIO_HI;
    f1b4:	f04f 0e01 	mov.w	lr, #1
    ui32Status = am_hal_cmdq_init((am_hal_cmdq_if_e)(AM_HAL_CMDQ_IF_IOM0 + ui32Module),
    f1b8:	f604 0228 	addw	r2, r4, #2088	; 0x828
    f1bc:	a901      	add	r1, sp, #4
    cqCfg.cmdQSize = ui32Length / 2;
    f1be:	9501      	str	r5, [sp, #4]
    cqCfg.priority = AM_HAL_CMDQ_PRIO_HI;
    f1c0:	f88d e00c 	strb.w	lr, [sp, #12]
    ui32Status = am_hal_cmdq_init((am_hal_cmdq_if_e)(AM_HAL_CMDQ_IF_IOM0 + ui32Module),
    f1c4:	f001 f984 	bl	104d0 <am_hal_cmdq_init>
        IOMn(pIOMState->ui32Module)->DMATRIGEN = _VAL2FLD(IOM0_DMATRIGEN_DTHREN, 1);
    f1c8:	6862      	ldr	r2, [r4, #4]
    f1ca:	f502 21a0 	add.w	r1, r2, #327680	; 0x50000
    f1ce:	3104      	adds	r1, #4
    f1d0:	030b      	lsls	r3, r1, #12
    if (ui32Status == AM_HAL_STATUS_SUCCESS)
    f1d2:	b960      	cbnz	r0, f1ee <am_hal_iom_enable+0x9a>
        pIOMState->ui32MaxTransactions = AM_HAL_IOM_MAX_PENDING_TRANSACTIONS;
    f1d4:	f44f 7080 	mov.w	r0, #256	; 0x100
        IOMn(pIOMState->ui32Module)->DMATRIGEN = _VAL2FLD(IOM0_DMATRIGEN_DTHREN, 1);
    f1d8:	2502      	movs	r5, #2
        pIOMState->ui32MaxTransactions = AM_HAL_IOM_MAX_PENDING_TRANSACTIONS;
    f1da:	6220      	str	r0, [r4, #32]
        IOMn(pIOMState->ui32Module)->DMATRIGEN = _VAL2FLD(IOM0_DMATRIGEN_DTHREN, 1);
    f1dc:	f8c3 5240 	str.w	r5, [r3, #576]	; 0x240
        pIOMState->prefix.s.bEnable = true;
    f1e0:	78e2      	ldrb	r2, [r4, #3]
    f1e2:	f042 0102 	orr.w	r1, r2, #2
    f1e6:	70e1      	strb	r1, [r4, #3]
    f1e8:	2000      	movs	r0, #0
} // am_hal_iom_enable()
    f1ea:	b005      	add	sp, #20
    f1ec:	bd30      	pop	{r4, r5, pc}
        IOMn(pIOMState->ui32Module)->DMATRIGEN = _VAL2FLD(IOM0_DMATRIGEN_DTHREN, 1);
    f1ee:	2402      	movs	r4, #2
    f1f0:	f8c3 4240 	str.w	r4, [r3, #576]	; 0x240
    f1f4:	e7f9      	b.n	f1ea <am_hal_iom_enable+0x96>
        return AM_HAL_STATUS_SUCCESS;
    f1f6:	2000      	movs	r0, #0
    f1f8:	4770      	bx	lr
    f1fa:	bf00      	nop
    f1fc:	01123456 	.word	0x01123456

0000f200 <am_hal_iom_disable>:
    if (!AM_HAL_IOM_CHK_HANDLE(pHandle))
    f200:	b128      	cbz	r0, f20e <am_hal_iom_disable+0xe>
    f202:	6803      	ldr	r3, [r0, #0]
    f204:	4a17      	ldr	r2, [pc, #92]	; (f264 <am_hal_iom_disable+0x64>)
    f206:	f023 417e 	bic.w	r1, r3, #4261412864	; 0xfe000000
    f20a:	4291      	cmp	r1, r2
    f20c:	d001      	beq.n	f212 <am_hal_iom_disable+0x12>
        return AM_HAL_STATUS_INVALID_HANDLE;
    f20e:	2002      	movs	r0, #2
    f210:	4770      	bx	lr
    if (!pIOMState->prefix.s.bEnable)
    f212:	f890 c003 	ldrb.w	ip, [r0, #3]
    f216:	f01c 0302 	ands.w	r3, ip, #2
    f21a:	d021      	beq.n	f260 <am_hal_iom_disable+0x60>
{
    f21c:	b510      	push	{r4, lr}
    f21e:	4604      	mov	r4, r0
    IOMn(pIOMState->ui32Module)->SUBMODCTRL_b.SMOD0EN = 0;
    f220:	6840      	ldr	r0, [r0, #4]
    f222:	f500 22a0 	add.w	r2, r0, #327680	; 0x50000
    f226:	3204      	adds	r2, #4
    f228:	0311      	lsls	r1, r2, #12
    f22a:	f891 3214 	ldrb.w	r3, [r1, #532]	; 0x214
    f22e:	f36f 0300 	bfc	r3, #0, #1
    f232:	f881 3214 	strb.w	r3, [r1, #532]	; 0x214
    IOMn(pIOMState->ui32Module)->SUBMODCTRL_b.SMOD1EN = 0;
    f236:	f891 0214 	ldrb.w	r0, [r1, #532]	; 0x214
    f23a:	f36f 1004 	bfc	r0, #4, #1
    f23e:	f881 0214 	strb.w	r0, [r1, #532]	; 0x214
    if (pIOMState->pCmdQHdl)
    f242:	f8d4 0828 	ldr.w	r0, [r4, #2088]	; 0x828
    f246:	b128      	cbz	r0, f254 <am_hal_iom_disable+0x54>
        am_hal_cmdq_term(pIOMState->pCmdQHdl, true);
    f248:	2101      	movs	r1, #1
    f24a:	f001 fabd 	bl	107c8 <am_hal_cmdq_term>
        pIOMState->pCmdQHdl = NULL;
    f24e:	2200      	movs	r2, #0
    f250:	f8c4 2828 	str.w	r2, [r4, #2088]	; 0x828
    pIOMState->prefix.s.bEnable = false;
    f254:	78e1      	ldrb	r1, [r4, #3]
    f256:	f36f 0141 	bfc	r1, #1, #1
    f25a:	70e1      	strb	r1, [r4, #3]
    f25c:	2000      	movs	r0, #0
    f25e:	bd10      	pop	{r4, pc}
        return AM_HAL_STATUS_SUCCESS;
    f260:	4618      	mov	r0, r3
    f262:	4770      	bx	lr
    f264:	01123456 	.word	0x01123456

0000f268 <am_hal_iom_interrupt_status_get>:
{
    uint32_t ui32IntStatus;
    uint32_t ui32Module;

#ifndef AM_HAL_DISABLE_API_VALIDATION
    if ( !AM_HAL_IOM_CHK_HANDLE(pHandle) )
    f268:	b150      	cbz	r0, f280 <am_hal_iom_interrupt_status_get+0x18>
{
    f26a:	b410      	push	{r4}
    if ( !AM_HAL_IOM_CHK_HANDLE(pHandle) )
    f26c:	6803      	ldr	r3, [r0, #0]
    f26e:	4c0e      	ldr	r4, [pc, #56]	; (f2a8 <am_hal_iom_interrupt_status_get+0x40>)
    f270:	f023 4c7e 	bic.w	ip, r3, #4261412864	; 0xfe000000
    f274:	45a4      	cmp	ip, r4
    f276:	d005      	beq.n	f284 <am_hal_iom_interrupt_status_get+0x1c>
    {
        return AM_HAL_STATUS_INVALID_HANDLE;
    f278:	2002      	movs	r0, #2
    //
    // Return the status.
    //
    return AM_HAL_STATUS_SUCCESS;

} // am_hal_iom_interrupt_status_get()
    f27a:	f85d 4b04 	ldr.w	r4, [sp], #4
    f27e:	4770      	bx	lr
        return AM_HAL_STATUS_INVALID_HANDLE;
    f280:	2002      	movs	r0, #2
    f282:	4770      	bx	lr
    if ( !pui32IntStatus )
    f284:	b16a      	cbz	r2, f2a2 <am_hal_iom_interrupt_status_get+0x3a>
    ui32IntStatus = IOMn(ui32Module)->INTSTAT;
    f286:	6840      	ldr	r0, [r0, #4]
    f288:	f500 23a0 	add.w	r3, r0, #327680	; 0x50000
    f28c:	3304      	adds	r3, #4
    f28e:	031c      	lsls	r4, r3, #12
    f290:	f8d4 0204 	ldr.w	r0, [r4, #516]	; 0x204
    if ( bEnabledOnly )
    f294:	b111      	cbz	r1, f29c <am_hal_iom_interrupt_status_get+0x34>
        ui32IntStatus &= IOMn(ui32Module)->INTEN;
    f296:	f8d4 1200 	ldr.w	r1, [r4, #512]	; 0x200
    f29a:	4008      	ands	r0, r1
    *pui32IntStatus = ui32IntStatus;
    f29c:	6010      	str	r0, [r2, #0]
    return AM_HAL_STATUS_SUCCESS;
    f29e:	2000      	movs	r0, #0
    f2a0:	e7eb      	b.n	f27a <am_hal_iom_interrupt_status_get+0x12>
        return AM_HAL_STATUS_INVALID_ARG;
    f2a2:	2006      	movs	r0, #6
    f2a4:	e7e9      	b.n	f27a <am_hal_iom_interrupt_status_get+0x12>
    f2a6:	bf00      	nop
    f2a8:	01123456 	.word	0x01123456

0000f2ac <am_hal_iom_interrupt_clear>:
am_hal_iom_interrupt_clear(void *pHandle, uint32_t ui32IntMask)
{
    uint32_t ui32Module;

#ifndef AM_HAL_DISABLE_API_VALIDATION
    if (!AM_HAL_IOM_CHK_HANDLE(pHandle))
    f2ac:	b128      	cbz	r0, f2ba <am_hal_iom_interrupt_clear+0xe>
    f2ae:	6803      	ldr	r3, [r0, #0]
    f2b0:	4a07      	ldr	r2, [pc, #28]	; (f2d0 <am_hal_iom_interrupt_clear+0x24>)
    f2b2:	f023 4c7e 	bic.w	ip, r3, #4261412864	; 0xfe000000
    f2b6:	4594      	cmp	ip, r2
    f2b8:	d001      	beq.n	f2be <am_hal_iom_interrupt_clear+0x12>
    {
        return AM_HAL_STATUS_INVALID_HANDLE;
    f2ba:	2002      	movs	r0, #2
    //
    // Return the status.
    //
    return AM_HAL_STATUS_SUCCESS;

} // am_hal_iom_interrupt_clear()
    f2bc:	4770      	bx	lr
    IOMn(ui32Module)->INTCLR = ui32IntMask;
    f2be:	6840      	ldr	r0, [r0, #4]
    f2c0:	f500 23a0 	add.w	r3, r0, #327680	; 0x50000
    f2c4:	3304      	adds	r3, #4
    f2c6:	031a      	lsls	r2, r3, #12
    return AM_HAL_STATUS_SUCCESS;
    f2c8:	2000      	movs	r0, #0
    IOMn(ui32Module)->INTCLR = ui32IntMask;
    f2ca:	f8c2 1208 	str.w	r1, [r2, #520]	; 0x208
    return AM_HAL_STATUS_SUCCESS;
    f2ce:	4770      	bx	lr
    f2d0:	01123456 	.word	0x01123456

0000f2d4 <am_hal_iom_interrupt_service>:
//
// IOM interrupt service routine
//
//*****************************************************************************
uint32_t am_hal_iom_interrupt_service(void *pHandle, uint32_t ui32IntMask)
{
    f2d4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    f2d8:	b084      	sub	sp, #16
    uint32_t ui32Status = AM_HAL_STATUS_SUCCESS;
    am_hal_iom_state_t *pIOMState = (am_hal_iom_state_t*)pHandle;
    uint32_t index;

#ifndef AM_HAL_DISABLE_API_VALIDATION
    if (!AM_HAL_IOM_CHK_HANDLE(pHandle))
    f2da:	b128      	cbz	r0, f2e8 <am_hal_iom_interrupt_service+0x14>
    f2dc:	6803      	ldr	r3, [r0, #0]
    f2de:	4a73      	ldr	r2, [pc, #460]	; (f4ac <am_hal_iom_interrupt_service+0x1d8>)
    f2e0:	f023 447e 	bic.w	r4, r3, #4261412864	; 0xfe000000
    f2e4:	4294      	cmp	r4, r2
    f2e6:	d004      	beq.n	f2f2 <am_hal_iom_interrupt_service+0x1e>
    {
        return AM_HAL_STATUS_INVALID_HANDLE;
    f2e8:	2502      	movs	r5, #2
    //
    // Return the status.
    //
    return ui32Status;

} // am_hal_iom_interrupt_service()
    f2ea:	4628      	mov	r0, r5
    f2ec:	b004      	add	sp, #16
    f2ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (pIOMState->ui32NumPendTransactions)
    f2f2:	6a45      	ldr	r5, [r0, #36]	; 0x24
    f2f4:	2d00      	cmp	r5, #0
    f2f6:	d0f8      	beq.n	f2ea <am_hal_iom_interrupt_service+0x16>
    f2f8:	4604      	mov	r4, r0
        if (pIOMState->pCmdQHdl && ((ui32Status = am_hal_cmdq_get_status(pIOMState->pCmdQHdl, &status)) == AM_HAL_STATUS_SUCCESS))
    f2fa:	f8d0 0828 	ldr.w	r0, [r0, #2088]	; 0x828
    ui32Module = pIOMState->ui32Module;
    f2fe:	f8d4 8004 	ldr.w	r8, [r4, #4]
    f302:	460f      	mov	r7, r1
        if (pIOMState->pCmdQHdl && ((ui32Status = am_hal_cmdq_get_status(pIOMState->pCmdQHdl, &status)) == AM_HAL_STATUS_SUCCESS))
    f304:	2800      	cmp	r0, #0
    f306:	f000 80c8 	beq.w	f49a <am_hal_iom_interrupt_service+0x1c6>
    f30a:	4669      	mov	r1, sp
    f30c:	f001 fa10 	bl	10730 <am_hal_cmdq_get_status>
    f310:	4605      	mov	r5, r0
    f312:	2800      	cmp	r0, #0
    f314:	f040 80a9 	bne.w	f46a <am_hal_iom_interrupt_service+0x196>
                    pIOMState->pfnCallback[index](pIOMState->pCallbackCtxt[index], AM_HAL_STATUS_SUCCESS);
    f318:	4681      	mov	r9, r0
    f31a:	69e3      	ldr	r3, [r4, #28]
    f31c:	f8dd c000 	ldr.w	ip, [sp]
    f320:	ebac 0003 	sub.w	r0, ip, r3
    f324:	f010 0103 	ands.w	r1, r0, #3
    f328:	d026      	beq.n	f378 <am_hal_iom_interrupt_service+0xa4>
                pIOMState->ui32LastIdxProcessed++;
    f32a:	3301      	adds	r3, #1
                index = pIOMState->ui32LastIdxProcessed & (AM_HAL_IOM_MAX_PENDING_TRANSACTIONS - 1);
    f32c:	b2da      	uxtb	r2, r3
                if ( pIOMState->pfnCallback[index] != NULL )
    f32e:	f102 060a 	add.w	r6, r2, #10
                pIOMState->ui32NumPendTransactions--;
    f332:	6a60      	ldr	r0, [r4, #36]	; 0x24
                if ( pIOMState->pfnCallback[index] != NULL )
    f334:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
                pIOMState->ui32LastIdxProcessed++;
    f338:	61e3      	str	r3, [r4, #28]
                pIOMState->ui32NumPendTransactions--;
    f33a:	3801      	subs	r0, #1
    f33c:	6260      	str	r0, [r4, #36]	; 0x24
                if ( pIOMState->pfnCallback[index] != NULL )
    f33e:	2e00      	cmp	r6, #0
    f340:	d145      	bne.n	f3ce <am_hal_iom_interrupt_service+0xfa>
    f342:	2901      	cmp	r1, #1
    f344:	d018      	beq.n	f378 <am_hal_iom_interrupt_service+0xa4>
    f346:	2902      	cmp	r1, #2
    f348:	d00b      	beq.n	f362 <am_hal_iom_interrupt_service+0x8e>
                pIOMState->ui32LastIdxProcessed++;
    f34a:	3301      	adds	r3, #1
                index = pIOMState->ui32LastIdxProcessed & (AM_HAL_IOM_MAX_PENDING_TRANSACTIONS - 1);
    f34c:	b2da      	uxtb	r2, r3
                if ( pIOMState->pfnCallback[index] != NULL )
    f34e:	f102 060a 	add.w	r6, r2, #10
                pIOMState->ui32NumPendTransactions--;
    f352:	6a61      	ldr	r1, [r4, #36]	; 0x24
                if ( pIOMState->pfnCallback[index] != NULL )
    f354:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
                pIOMState->ui32LastIdxProcessed++;
    f358:	61e3      	str	r3, [r4, #28]
                pIOMState->ui32NumPendTransactions--;
    f35a:	1e48      	subs	r0, r1, #1
    f35c:	6260      	str	r0, [r4, #36]	; 0x24
                if ( pIOMState->pfnCallback[index] != NULL )
    f35e:	2e00      	cmp	r6, #0
    f360:	d135      	bne.n	f3ce <am_hal_iom_interrupt_service+0xfa>
                pIOMState->ui32LastIdxProcessed++;
    f362:	3301      	adds	r3, #1
                index = pIOMState->ui32LastIdxProcessed & (AM_HAL_IOM_MAX_PENDING_TRANSACTIONS - 1);
    f364:	b2da      	uxtb	r2, r3
                if ( pIOMState->pfnCallback[index] != NULL )
    f366:	f102 060a 	add.w	r6, r2, #10
                pIOMState->ui32NumPendTransactions--;
    f36a:	6a61      	ldr	r1, [r4, #36]	; 0x24
                if ( pIOMState->pfnCallback[index] != NULL )
    f36c:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
                pIOMState->ui32LastIdxProcessed++;
    f370:	61e3      	str	r3, [r4, #28]
                pIOMState->ui32NumPendTransactions--;
    f372:	1e48      	subs	r0, r1, #1
    f374:	6260      	str	r0, [r4, #36]	; 0x24
                if ( pIOMState->pfnCallback[index] != NULL )
    f376:	bb56      	cbnz	r6, f3ce <am_hal_iom_interrupt_service+0xfa>
                pIOMState->ui32LastIdxProcessed++;
    f378:	1c59      	adds	r1, r3, #1
                index = pIOMState->ui32LastIdxProcessed & (AM_HAL_IOM_MAX_PENDING_TRANSACTIONS - 1);
    f37a:	b2ca      	uxtb	r2, r1
            while (pIOMState->ui32LastIdxProcessed != status.lastIdxProcessed)
    f37c:	4563      	cmp	r3, ip
                pIOMState->ui32LastIdxProcessed++;
    f37e:	f101 0a01 	add.w	sl, r1, #1
    f382:	f103 0e03 	add.w	lr, r3, #3
                if ( pIOMState->pfnCallback[index] != NULL )
    f386:	f102 060a 	add.w	r6, r2, #10
            while (pIOMState->ui32LastIdxProcessed != status.lastIdxProcessed)
    f38a:	d029      	beq.n	f3e0 <am_hal_iom_interrupt_service+0x10c>
                pIOMState->ui32NumPendTransactions--;
    f38c:	6a60      	ldr	r0, [r4, #36]	; 0x24
                if ( pIOMState->pfnCallback[index] != NULL )
    f38e:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
                pIOMState->ui32LastIdxProcessed++;
    f392:	61e1      	str	r1, [r4, #28]
                pIOMState->ui32NumPendTransactions--;
    f394:	1e41      	subs	r1, r0, #1
                pIOMState->ui32LastIdxProcessed++;
    f396:	3304      	adds	r3, #4
                pIOMState->ui32NumPendTransactions--;
    f398:	6261      	str	r1, [r4, #36]	; 0x24
                if ( pIOMState->pfnCallback[index] != NULL )
    f39a:	b9c6      	cbnz	r6, f3ce <am_hal_iom_interrupt_service+0xfa>
                index = pIOMState->ui32LastIdxProcessed & (AM_HAL_IOM_MAX_PENDING_TRANSACTIONS - 1);
    f39c:	fa5f f28a 	uxtb.w	r2, sl
                if ( pIOMState->pfnCallback[index] != NULL )
    f3a0:	f102 060a 	add.w	r6, r2, #10
                pIOMState->ui32NumPendTransactions--;
    f3a4:	6a60      	ldr	r0, [r4, #36]	; 0x24
                if ( pIOMState->pfnCallback[index] != NULL )
    f3a6:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
                pIOMState->ui32LastIdxProcessed++;
    f3aa:	f8c4 a01c 	str.w	sl, [r4, #28]
                pIOMState->ui32NumPendTransactions--;
    f3ae:	1e41      	subs	r1, r0, #1
    f3b0:	6261      	str	r1, [r4, #36]	; 0x24
                if ( pIOMState->pfnCallback[index] != NULL )
    f3b2:	b966      	cbnz	r6, f3ce <am_hal_iom_interrupt_service+0xfa>
                index = pIOMState->ui32LastIdxProcessed & (AM_HAL_IOM_MAX_PENDING_TRANSACTIONS - 1);
    f3b4:	fa5f f28e 	uxtb.w	r2, lr
                if ( pIOMState->pfnCallback[index] != NULL )
    f3b8:	f102 060a 	add.w	r6, r2, #10
                pIOMState->ui32NumPendTransactions--;
    f3bc:	6a60      	ldr	r0, [r4, #36]	; 0x24
                if ( pIOMState->pfnCallback[index] != NULL )
    f3be:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
                pIOMState->ui32LastIdxProcessed++;
    f3c2:	f8c4 e01c 	str.w	lr, [r4, #28]
                pIOMState->ui32NumPendTransactions--;
    f3c6:	1e41      	subs	r1, r0, #1
    f3c8:	6261      	str	r1, [r4, #36]	; 0x24
                if ( pIOMState->pfnCallback[index] != NULL )
    f3ca:	2e00      	cmp	r6, #0
    f3cc:	d0ca      	beq.n	f364 <am_hal_iom_interrupt_service+0x90>
    f3ce:	eb04 0a82 	add.w	sl, r4, r2, lsl #2
                    pIOMState->pfnCallback[index](pIOMState->pCallbackCtxt[index], AM_HAL_STATUS_SUCCESS);
    f3d2:	2100      	movs	r1, #0
    f3d4:	f8da 0428 	ldr.w	r0, [sl, #1064]	; 0x428
    f3d8:	47b0      	blx	r6
                    pIOMState->pfnCallback[index] = NULL;
    f3da:	f8ca 9028 	str.w	r9, [sl, #40]	; 0x28
    f3de:	e79c      	b.n	f31a <am_hal_iom_interrupt_service+0x46>
            if (ui32IntMask & AM_HAL_IOM_INT_ERR)
    f3e0:	f644 237c 	movw	r3, #19068	; 0x4a7c
    f3e4:	ea17 0903 	ands.w	r9, r7, r3
    f3e8:	d039      	beq.n	f45e <am_hal_iom_interrupt_service+0x18a>
                pIOMState->ui32NumPendTransactions--;
    f3ea:	6a62      	ldr	r2, [r4, #36]	; 0x24
                pIOMState->ui32LastIdxProcessed++;
    f3ec:	61e1      	str	r1, [r4, #28]
                index = pIOMState->ui32LastIdxProcessed & (AM_HAL_IOM_MAX_PENDING_TRANSACTIONS - 1);
    f3ee:	b2ce      	uxtb	r6, r1
                pIOMState->ui32NumPendTransactions--;
    f3f0:	1e53      	subs	r3, r2, #1
    f3f2:	eb04 0686 	add.w	r6, r4, r6, lsl #2
    f3f6:	6263      	str	r3, [r4, #36]	; 0x24
    ui32IntStatus |= IOMn(ui32Module)->INTSTAT;
    f3f8:	f508 2ea0 	add.w	lr, r8, #327680	; 0x50000
                if ( pIOMState->pfnCallback[index] != NULL )
    f3fc:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    ui32IntStatus |= IOMn(ui32Module)->INTSTAT;
    f3fe:	f10e 0004 	add.w	r0, lr, #4
    f402:	ea4f 3a00 	mov.w	sl, r0, lsl #12
                if ( pIOMState->pfnCallback[index] != NULL )
    f406:	b19b      	cbz	r3, f430 <am_hal_iom_interrupt_service+0x15c>
    ui32IntStatus |= IOMn(ui32Module)->INTSTAT;
    f408:	f8da 2204 	ldr.w	r2, [sl, #516]	; 0x204
                    pIOMState->pfnCallback[index](pIOMState->pCallbackCtxt[index], internal_iom_get_int_err(ui32Module, ui32IntMask));
    f40c:	f8d6 0428 	ldr.w	r0, [r6, #1064]	; 0x428
    ui32IntStatus |= IOMn(ui32Module)->INTSTAT;
    f410:	4317      	orrs	r7, r2
    if (ui32IntStatus & AM_HAL_IOM_INT_SWERR)
    f412:	f017 0f6c 	tst.w	r7, #108	; 0x6c
    f416:	d142      	bne.n	f49e <am_hal_iom_interrupt_service+0x1ca>
    else if (ui32IntStatus & AM_HAL_IOM_INT_I2CARBERR)
    f418:	05ba      	lsls	r2, r7, #22
    f41a:	d443      	bmi.n	f4a4 <am_hal_iom_interrupt_service+0x1d0>
    else if (ui32IntStatus & AM_HAL_IOM_INT_NAK)
    f41c:	06fa      	lsls	r2, r7, #27
    f41e:	d443      	bmi.n	f4a8 <am_hal_iom_interrupt_service+0x1d4>
    else if (ui32IntStatus & AM_HAL_IOM_INT_INTERR)
    f420:	f417 4f90 	tst.w	r7, #18432	; 0x4800
    f424:	bf14      	ite	ne
    f426:	2101      	movne	r1, #1
    f428:	2100      	moveq	r1, #0
                    pIOMState->pfnCallback[index] = NULL;
    f42a:	2700      	movs	r7, #0
                    pIOMState->pfnCallback[index](pIOMState->pCallbackCtxt[index], internal_iom_get_int_err(ui32Module, ui32IntMask));
    f42c:	4798      	blx	r3
                    pIOMState->pfnCallback[index] = NULL;
    f42e:	62b7      	str	r7, [r6, #40]	; 0x28
                IOMn(ui32Module)->CQCFG_b.CQEN = 0;
    f430:	f89a 1294 	ldrb.w	r1, [sl, #660]	; 0x294
    f434:	f36f 0100 	bfc	r1, #0, #1
    f438:	f88a 1294 	strb.w	r1, [sl, #660]	; 0x294
                IOMn(ui32Module)->DMACFG_b.DMAEN = 0;
    f43c:	f8ba 6280 	ldrh.w	r6, [sl, #640]	; 0x280
                IOMn(ui32Module)->DMASTAT = 0;
    f440:	2300      	movs	r3, #0
                IOMn(ui32Module)->DMACFG_b.DMAEN = 0;
    f442:	f36f 0600 	bfc	r6, #0, #1
    f446:	f8aa 6280 	strh.w	r6, [sl, #640]	; 0x280
                internal_iom_reset_on_error(pIOMState, ui32IntMask & AM_HAL_IOM_INT_ERR);
    f44a:	4620      	mov	r0, r4
    f44c:	4649      	mov	r1, r9
                IOMn(ui32Module)->DMASTAT = 0;
    f44e:	f8ca 3290 	str.w	r3, [sl, #656]	; 0x290
                internal_iom_reset_on_error(pIOMState, ui32IntMask & AM_HAL_IOM_INT_ERR);
    f452:	f7ff fda9 	bl	efa8 <internal_iom_reset_on_error>
                am_hal_cmdq_error_resume(pIOMState->pCmdQHdl);
    f456:	f8d4 0828 	ldr.w	r0, [r4, #2088]	; 0x828
    f45a:	f001 f9f1 	bl	10840 <am_hal_cmdq_error_resume>
            if (pIOMState->ui32NumPendTransactions == 0)
    f45e:	6a60      	ldr	r0, [r4, #36]	; 0x24
    f460:	b9d8      	cbnz	r0, f49a <am_hal_iom_interrupt_service+0x1c6>
    return am_hal_cmdq_disable(pIOMState->pCmdQHdl);
    f462:	f8d4 0828 	ldr.w	r0, [r4, #2088]	; 0x828
    f466:	f001 f8ab 	bl	105c0 <am_hal_cmdq_disable>
        if (pIOMState->ui32NumPendTransactions == 0)
    f46a:	6a67      	ldr	r7, [r4, #36]	; 0x24
    f46c:	2f00      	cmp	r7, #0
    f46e:	f47f af3c 	bne.w	f2ea <am_hal_iom_interrupt_service+0x16>
            IOMn(ui32Module)->DMACFG_b.DMAEN = 0;
    f472:	f508 28a0 	add.w	r8, r8, #327680	; 0x50000
    f476:	f108 0204 	add.w	r2, r8, #4
    f47a:	ea4f 3c02 	mov.w	ip, r2, lsl #12
            IOMn(ui32Module)->INTCLR = AM_HAL_IOM_INT_ALL;
    f47e:	f04f 31ff 	mov.w	r1, #4294967295
            IOMn(ui32Module)->DMACFG_b.DMAEN = 0;
    f482:	f8bc 6280 	ldrh.w	r6, [ip, #640]	; 0x280
    f486:	f367 0600 	bfi	r6, r7, #0, #1
    f48a:	f8ac 6280 	strh.w	r6, [ip, #640]	; 0x280
            IOMn(ui32Module)->INTCLR = AM_HAL_IOM_INT_ALL;
    f48e:	f8cc 1208 	str.w	r1, [ip, #520]	; 0x208
            IOMn(ui32Module)->INTEN  = pIOMState->ui32UserIntCfg;
    f492:	6964      	ldr	r4, [r4, #20]
    f494:	f8cc 4200 	str.w	r4, [ip, #512]	; 0x200
    f498:	e727      	b.n	f2ea <am_hal_iom_interrupt_service+0x16>
    uint32_t ui32Status = AM_HAL_STATUS_SUCCESS;
    f49a:	2500      	movs	r5, #0
    f49c:	e7e5      	b.n	f46a <am_hal_iom_interrupt_service+0x196>
        ui32Status = AM_HAL_IOM_ERR_INVALID_OPER;
    f49e:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
    f4a2:	e7c2      	b.n	f42a <am_hal_iom_interrupt_service+0x156>
        ui32Status = AM_HAL_IOM_ERR_I2C_ARB;
    f4a4:	4902      	ldr	r1, [pc, #8]	; (f4b0 <am_hal_iom_interrupt_service+0x1dc>)
    f4a6:	e7c0      	b.n	f42a <am_hal_iom_interrupt_service+0x156>
        ui32Status = AM_HAL_IOM_ERR_I2C_NAK;
    f4a8:	4902      	ldr	r1, [pc, #8]	; (f4b4 <am_hal_iom_interrupt_service+0x1e0>)
    f4aa:	e7be      	b.n	f42a <am_hal_iom_interrupt_service+0x156>
    f4ac:	01123456 	.word	0x01123456
    f4b0:	08000001 	.word	0x08000001
    f4b4:	08000002 	.word	0x08000002

0000f4b8 <am_hal_iom_power_ctrl>:
                      bool bRetainState)
{
    am_hal_iom_state_t *pIOMState = (am_hal_iom_state_t*)pHandle;

#ifndef AM_HAL_DISABLE_API_VALIDATION
    if (!AM_HAL_IOM_CHK_HANDLE(pHandle))
    f4b8:	b150      	cbz	r0, f4d0 <am_hal_iom_power_ctrl+0x18>
{
    f4ba:	b510      	push	{r4, lr}
    if (!AM_HAL_IOM_CHK_HANDLE(pHandle))
    f4bc:	6803      	ldr	r3, [r0, #0]
    f4be:	4c58      	ldr	r4, [pc, #352]	; (f620 <am_hal_iom_power_ctrl+0x168>)
    f4c0:	f023 4c7e 	bic.w	ip, r3, #4261412864	; 0xfe000000
    f4c4:	45a4      	cmp	ip, r4
{
    f4c6:	b082      	sub	sp, #8
    if (!AM_HAL_IOM_CHK_HANDLE(pHandle))
    f4c8:	d004      	beq.n	f4d4 <am_hal_iom_power_ctrl+0x1c>
    {
        return AM_HAL_STATUS_INVALID_HANDLE;
    f4ca:	2002      	movs	r0, #2
    //
    // Return the status.
    //
    return AM_HAL_STATUS_SUCCESS;

} // am_hal_iom_power_ctrl()
    f4cc:	b002      	add	sp, #8
    f4ce:	bd10      	pop	{r4, pc}
        return AM_HAL_STATUS_INVALID_HANDLE;
    f4d0:	2002      	movs	r0, #2
    f4d2:	4770      	bx	lr
    f4d4:	4604      	mov	r4, r0
    switch (ePowerState)
    f4d6:	b181      	cbz	r1, f4fa <am_hal_iom_power_ctrl+0x42>
    f4d8:	2902      	cmp	r1, #2
    f4da:	d80c      	bhi.n	f4f6 <am_hal_iom_power_ctrl+0x3e>
            if (((IOMn(pIOMState->ui32Module)->STATUS & (IOM0_STATUS_IDLEST_Msk | IOM0_STATUS_CMDACT_Msk)) != IOM0_STATUS_IDLEST_Msk) ||
    f4dc:	6840      	ldr	r0, [r0, #4]
    f4de:	f500 21a0 	add.w	r1, r0, #327680	; 0x50000
    f4e2:	3104      	adds	r1, #4
    f4e4:	0309      	lsls	r1, r1, #12
    f4e6:	f8d1 32b4 	ldr.w	r3, [r1, #692]	; 0x2b4
    f4ea:	f003 0306 	and.w	r3, r3, #6
    f4ee:	2b04      	cmp	r3, #4
    f4f0:	d055      	beq.n	f59e <am_hal_iom_power_ctrl+0xe6>
                return AM_HAL_STATUS_IN_USE;
    f4f2:	2003      	movs	r0, #3
    f4f4:	e7ea      	b.n	f4cc <am_hal_iom_power_ctrl+0x14>
            return AM_HAL_STATUS_INVALID_ARG;
    f4f6:	2006      	movs	r0, #6
    f4f8:	e7e8      	b.n	f4cc <am_hal_iom_power_ctrl+0x14>
            if (bRetainState && !pIOMState->registerState.bValid)
    f4fa:	b122      	cbz	r2, f506 <am_hal_iom_power_ctrl+0x4e>
    f4fc:	f890 3834 	ldrb.w	r3, [r0, #2100]	; 0x834
    f500:	b94b      	cbnz	r3, f516 <am_hal_iom_power_ctrl+0x5e>
                return AM_HAL_STATUS_INVALID_OPERATION;
    f502:	2007      	movs	r0, #7
    f504:	e7e2      	b.n	f4cc <am_hal_iom_power_ctrl+0x14>
            am_hal_pwrctrl_periph_enable((am_hal_pwrctrl_periph_e)(AM_HAL_PWRCTRL_PERIPH_IOM0 + pIOMState->ui32Module));
    f506:	6844      	ldr	r4, [r0, #4]
    f508:	9201      	str	r2, [sp, #4]
    f50a:	3402      	adds	r4, #2
    f50c:	b2e0      	uxtb	r0, r4
    f50e:	f000 febf 	bl	10290 <am_hal_pwrctrl_periph_enable>
    return AM_HAL_STATUS_SUCCESS;
    f512:	9801      	ldr	r0, [sp, #4]
    f514:	e7da      	b.n	f4cc <am_hal_iom_power_ctrl+0x14>
    f516:	9101      	str	r1, [sp, #4]
            am_hal_pwrctrl_periph_enable((am_hal_pwrctrl_periph_e)(AM_HAL_PWRCTRL_PERIPH_IOM0 + pIOMState->ui32Module));
    f518:	6841      	ldr	r1, [r0, #4]
    f51a:	3102      	adds	r1, #2
    f51c:	b2c8      	uxtb	r0, r1
    f51e:	f000 feb7 	bl	10290 <am_hal_pwrctrl_periph_enable>
                IOMn(pIOMState->ui32Module)->FIFOTHR    = pIOMState->registerState.regFIFOTHR;
    f522:	6860      	ldr	r0, [r4, #4]
    f524:	f8d4 2838 	ldr.w	r2, [r4, #2104]	; 0x838
    return AM_HAL_STATUS_SUCCESS;
    f528:	9901      	ldr	r1, [sp, #4]
                IOMn(pIOMState->ui32Module)->FIFOTHR    = pIOMState->registerState.regFIFOTHR;
    f52a:	f500 23a0 	add.w	r3, r0, #327680	; 0x50000
    f52e:	3304      	adds	r3, #4
    f530:	031b      	lsls	r3, r3, #12
    return AM_HAL_STATUS_SUCCESS;
    f532:	4608      	mov	r0, r1
                IOMn(pIOMState->ui32Module)->FIFOTHR    = pIOMState->registerState.regFIFOTHR;
    f534:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
                IOMn(pIOMState->ui32Module)->CLKCFG     = pIOMState->registerState.regCLKCFG;
    f538:	f8d4 2840 	ldr.w	r2, [r4, #2112]	; 0x840
    f53c:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
                IOMn(pIOMState->ui32Module)->SUBMODCTRL = pIOMState->registerState.regSUBMODCTRL;
    f540:	f8d4 2844 	ldr.w	r2, [r4, #2116]	; 0x844
    f544:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
                IOMn(pIOMState->ui32Module)->CQADDR     = pIOMState->registerState.regCQADDR;
    f548:	f8d4 284c 	ldr.w	r2, [r4, #2124]	; 0x84c
    f54c:	f8c3 2298 	str.w	r2, [r3, #664]	; 0x298
                IOMn(pIOMState->ui32Module)->CQFLAGS    = pIOMState->registerState.regCQFLAGS;
    f550:	f8d4 2850 	ldr.w	r2, [r4, #2128]	; 0x850
    f554:	f8c3 22a0 	str.w	r2, [r3, #672]	; 0x2a0
                IOMn(pIOMState->ui32Module)->CQPAUSEEN  = pIOMState->registerState.regCQPAUSEEN;
    f558:	f8d4 2854 	ldr.w	r2, [r4, #2132]	; 0x854
    f55c:	f8c3 22a8 	str.w	r2, [r3, #680]	; 0x2a8
                IOMn(pIOMState->ui32Module)->CQCURIDX   = pIOMState->registerState.regCQCURIDX;
    f560:	f8d4 2858 	ldr.w	r2, [r4, #2136]	; 0x858
    f564:	f8c3 22ac 	str.w	r2, [r3, #684]	; 0x2ac
                IOMn(pIOMState->ui32Module)->CQENDIDX   = pIOMState->registerState.regCQENDIDX;
    f568:	f8d4 285c 	ldr.w	r2, [r4, #2140]	; 0x85c
    f56c:	f8c3 22b0 	str.w	r2, [r3, #688]	; 0x2b0
                IOMn(pIOMState->ui32Module)->MSPICFG    = pIOMState->registerState.regMSPICFG;
    f570:	f8d4 2860 	ldr.w	r2, [r4, #2144]	; 0x860
    f574:	f8c3 2300 	str.w	r2, [r3, #768]	; 0x300
                IOMn(pIOMState->ui32Module)->MI2CCFG    = pIOMState->registerState.regMI2CCFG;
    f578:	f8d4 2864 	ldr.w	r2, [r4, #2148]	; 0x864
    f57c:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
                IOMn(pIOMState->ui32Module)->INTEN      = pIOMState->registerState.regINTEN;
    f580:	f8d4 2868 	ldr.w	r2, [r4, #2152]	; 0x868
    f584:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
                IOMn(pIOMState->ui32Module)->DMATRIGEN  = pIOMState->registerState.regDMATRIGEN;
    f588:	f8d4 283c 	ldr.w	r2, [r4, #2108]	; 0x83c
    f58c:	f8c3 2240 	str.w	r2, [r3, #576]	; 0x240
                IOMn(pIOMState->ui32Module)->CQCFG      = pIOMState->registerState.regCQCFG;
    f590:	f8d4 2848 	ldr.w	r2, [r4, #2120]	; 0x848
    f594:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294
                pIOMState->registerState.bValid = false;
    f598:	f884 1834 	strb.w	r1, [r4, #2100]	; 0x834
    f59c:	e796      	b.n	f4cc <am_hal_iom_power_ctrl+0x14>
                pIOMState->ui32NumPendTransactions)
    f59e:	6a63      	ldr	r3, [r4, #36]	; 0x24
            if (((IOMn(pIOMState->ui32Module)->STATUS & (IOM0_STATUS_IDLEST_Msk | IOM0_STATUS_CMDACT_Msk)) != IOM0_STATUS_IDLEST_Msk) ||
    f5a0:	2b00      	cmp	r3, #0
    f5a2:	d1a6      	bne.n	f4f2 <am_hal_iom_power_ctrl+0x3a>
            if (bRetainState)
    f5a4:	b3b2      	cbz	r2, f614 <am_hal_iom_power_ctrl+0x15c>
                pIOMState->registerState.regFIFOTHR    = IOMn(pIOMState->ui32Module)->FIFOTHR;
    f5a6:	f8d1 2104 	ldr.w	r2, [r1, #260]	; 0x104
    f5aa:	f8c4 2838 	str.w	r2, [r4, #2104]	; 0x838
                pIOMState->registerState.regCLKCFG     = IOMn(pIOMState->ui32Module)->CLKCFG;
    f5ae:	f8d1 3210 	ldr.w	r3, [r1, #528]	; 0x210
    f5b2:	f8c4 3840 	str.w	r3, [r4, #2112]	; 0x840
                pIOMState->registerState.regSUBMODCTRL = IOMn(pIOMState->ui32Module)->SUBMODCTRL;
    f5b6:	f8d1 2214 	ldr.w	r2, [r1, #532]	; 0x214
    f5ba:	f8c4 2844 	str.w	r2, [r4, #2116]	; 0x844
                pIOMState->registerState.regCQCFG      = IOMn(pIOMState->ui32Module)->CQCFG;
    f5be:	f8d1 3294 	ldr.w	r3, [r1, #660]	; 0x294
    f5c2:	f8c4 3848 	str.w	r3, [r4, #2120]	; 0x848
                pIOMState->registerState.regCQADDR     = IOMn(pIOMState->ui32Module)->CQADDR;
    f5c6:	f8d1 2298 	ldr.w	r2, [r1, #664]	; 0x298
    f5ca:	f8c4 284c 	str.w	r2, [r4, #2124]	; 0x84c
                pIOMState->registerState.regCQFLAGS    = IOMn(pIOMState->ui32Module)->CQFLAGS;
    f5ce:	f8d1 32a0 	ldr.w	r3, [r1, #672]	; 0x2a0
    f5d2:	f8c4 3850 	str.w	r3, [r4, #2128]	; 0x850
                pIOMState->registerState.regCQPAUSEEN  = IOMn(pIOMState->ui32Module)->CQPAUSEEN;
    f5d6:	f8d1 22a8 	ldr.w	r2, [r1, #680]	; 0x2a8
    f5da:	f8c4 2854 	str.w	r2, [r4, #2132]	; 0x854
                pIOMState->registerState.regCQCURIDX   = IOMn(pIOMState->ui32Module)->CQCURIDX;
    f5de:	f8d1 32ac 	ldr.w	r3, [r1, #684]	; 0x2ac
    f5e2:	f8c4 3858 	str.w	r3, [r4, #2136]	; 0x858
                pIOMState->registerState.regCQENDIDX   = IOMn(pIOMState->ui32Module)->CQENDIDX;
    f5e6:	f8d1 22b0 	ldr.w	r2, [r1, #688]	; 0x2b0
    f5ea:	f8c4 285c 	str.w	r2, [r4, #2140]	; 0x85c
                pIOMState->registerState.regMSPICFG    = IOMn(pIOMState->ui32Module)->MSPICFG;
    f5ee:	f8d1 3300 	ldr.w	r3, [r1, #768]	; 0x300
    f5f2:	f8c4 3860 	str.w	r3, [r4, #2144]	; 0x860
                pIOMState->registerState.regMI2CCFG    = IOMn(pIOMState->ui32Module)->MI2CCFG;
    f5f6:	f8d1 2400 	ldr.w	r2, [r1, #1024]	; 0x400
    f5fa:	f8c4 2864 	str.w	r2, [r4, #2148]	; 0x864
                pIOMState->registerState.regINTEN      = IOMn(pIOMState->ui32Module)->INTEN;
    f5fe:	f8d1 3200 	ldr.w	r3, [r1, #512]	; 0x200
    f602:	f8c4 3868 	str.w	r3, [r4, #2152]	; 0x868
                pIOMState->registerState.regDMATRIGEN  = IOMn(pIOMState->ui32Module)->DMATRIGEN;
    f606:	f8d1 1240 	ldr.w	r1, [r1, #576]	; 0x240
    f60a:	f8c4 183c 	str.w	r1, [r4, #2108]	; 0x83c
                pIOMState->registerState.bValid = true;
    f60e:	2201      	movs	r2, #1
    f610:	f884 2834 	strb.w	r2, [r4, #2100]	; 0x834
            am_hal_pwrctrl_periph_disable((am_hal_pwrctrl_periph_e)(AM_HAL_PWRCTRL_PERIPH_IOM0 + pIOMState->ui32Module));
    f614:	3002      	adds	r0, #2
    f616:	b2c0      	uxtb	r0, r0
    f618:	f000 fe64 	bl	102e4 <am_hal_pwrctrl_periph_disable>
    return AM_HAL_STATUS_SUCCESS;
    f61c:	2000      	movs	r0, #0
            break;
    f61e:	e755      	b.n	f4cc <am_hal_iom_power_ctrl+0x14>
    f620:	01123456 	.word	0x01123456

0000f624 <am_hal_iom_configure>:
    am_hal_iom_state_t *pIOMState = (am_hal_iom_state_t*)pHandle;
    uint32_t status = AM_HAL_STATUS_SUCCESS;
    uint32_t ui32Module;

#ifndef AM_HAL_DISABLE_API_VALIDATION
    if (!AM_HAL_IOM_CHK_HANDLE(pHandle))
    f624:	b130      	cbz	r0, f634 <am_hal_iom_configure+0x10>
    f626:	6803      	ldr	r3, [r0, #0]
    f628:	4602      	mov	r2, r0
    f62a:	4882      	ldr	r0, [pc, #520]	; (f834 <am_hal_iom_configure+0x210>)
    f62c:	f023 4c7e 	bic.w	ip, r3, #4261412864	; 0xfe000000
    f630:	4584      	cmp	ip, r0
    f632:	d001      	beq.n	f638 <am_hal_iom_configure+0x14>
    {
        return AM_HAL_STATUS_INVALID_HANDLE;
    f634:	2002      	movs	r0, #2
    f636:	4770      	bx	lr
    }

    //
    // Validate the parameters
    //
    if ( (pHandle == NULL)      ||
    f638:	b111      	cbz	r1, f640 <am_hal_iom_configure+0x1c>
         (psConfig == NULL)     ||
         (pIOMState->ui32Module >= AM_REG_IOM_NUM_MODULES) )
    f63a:	6853      	ldr	r3, [r2, #4]
         (psConfig == NULL)     ||
    f63c:	2b05      	cmp	r3, #5
    f63e:	d901      	bls.n	f644 <am_hal_iom_configure+0x20>
    {
        return AM_HAL_STATUS_INVALID_ARG;
    f640:	2006      	movs	r0, #6
    //
    // Return the status.
    //
    return status;

} // am_hal_iom_configure()
    f642:	4770      	bx	lr
    if (pIOMState->prefix.s.bEnable)
    f644:	78d0      	ldrb	r0, [r2, #3]
    f646:	0780      	lsls	r0, r0, #30
    f648:	d501      	bpl.n	f64e <am_hal_iom_configure+0x2a>
        return AM_HAL_STATUS_INVALID_OPERATION;
    f64a:	2007      	movs	r0, #7
    f64c:	4770      	bx	lr
{
    f64e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    IOMn(ui32Module)->FIFOTHR =
    f652:	f503 24a0 	add.w	r4, r3, #327680	; 0x50000
    f656:	3404      	adds	r4, #4
    pIOMState->eInterfaceMode = psConfig->eInterfaceMode;
    f658:	780d      	ldrb	r5, [r1, #0]
    f65a:	7215      	strb	r5, [r2, #8]
    IOMn(ui32Module)->FIFOTHR =
    f65c:	0323      	lsls	r3, r4, #12
    f65e:	f241 0610 	movw	r6, #4112	; 0x1010
    f662:	f8c3 6104 	str.w	r6, [r3, #260]	; 0x104
    if ( psConfig->eInterfaceMode == AM_HAL_IOM_SPI_MODE )
    f666:	b93d      	cbnz	r5, f678 <am_hal_iom_configure+0x54>
        if ( psConfig->eSpiMode > AM_HAL_IOM_SPI_MODE_3 )
    f668:	f891 c008 	ldrb.w	ip, [r1, #8]
    f66c:	f1bc 0f03 	cmp.w	ip, #3
    f670:	d908      	bls.n	f684 <am_hal_iom_configure+0x60>
                return AM_HAL_STATUS_INVALID_ARG;
    f672:	2006      	movs	r0, #6
    f674:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    else if ( psConfig->eInterfaceMode == AM_HAL_IOM_I2C_MODE )
    f678:	2d01      	cmp	r5, #1
    f67a:	f000 80b3 	beq.w	f7e4 <am_hal_iom_configure+0x1c0>
        return AM_HAL_STATUS_OUT_OF_RANGE;
    f67e:	2005      	movs	r0, #5
    f680:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ui32ClkCfg = iom_get_interface_clock_cfg(psConfig->ui32ClockFreq, (psConfig->eSpiMode & 2) >> 1);
    f684:	f8d1 e004 	ldr.w	lr, [r1, #4]
    f688:	ea4f 076c 	mov.w	r7, ip, asr #1
    if ( ui32FreqHz == 0 )
    f68c:	f1be 0f00 	cmp.w	lr, #0
    f690:	f000 80a6 	beq.w	f7e0 <am_hal_iom_configure+0x1bc>
    i32Div = (ui32HFRCfreqHz / ui32FreqHz) + ((ui32HFRCfreqHz % ui32FreqHz) ? 1 : 0);    // Round up (ceiling)
    f694:	4c68      	ldr	r4, [pc, #416]	; (f838 <am_hal_iom_configure+0x214>)
    f696:	fbb4 f8fe 	udiv	r8, r4, lr
    f69a:	fb0e 4518 	mls	r5, lr, r8, r4
    f69e:	2d00      	cmp	r5, #0
    f6a0:	bf18      	it	ne
    f6a2:	f108 0801 	addne.w	r8, r8, #1
    i32N = 31 - AM_INSTR_CLZ((i32Div & (-i32Div)));
    f6a6:	f1c8 0600 	rsb	r6, r8, #0
    f6aa:	ea06 0008 	and.w	r0, r6, r8
    f6ae:	fab0 f480 	clz	r4, r0
    f6b2:	f1c4 051f 	rsb	r5, r4, #31
    f6b6:	2d06      	cmp	r5, #6
    f6b8:	bfa8      	it	ge
    f6ba:	2506      	movge	r5, #6
                    (ui32FreqHz <= ((ui32HFRCfreqHz / 2) - 1)) ) ) ) ? 1 : 0;
    f6bc:	f5be 6f37 	cmp.w	lr, #2928	; 0xb70
    f6c0:	f240 80a3 	bls.w	f80a <am_hal_iom_configure+0x1e6>
    f6c4:	f5ae 0a74 	sub.w	sl, lr, #15990784	; 0xf40000
    f6c8:	4e5c      	ldr	r6, [pc, #368]	; (f83c <am_hal_iom_configure+0x218>)
    f6ca:	f5aa 5a10 	sub.w	sl, sl, #9216	; 0x2400
    f6ce:	45b2      	cmp	sl, r6
    f6d0:	bf8c      	ite	hi
    f6d2:	f04f 0a00 	movhi.w	sl, #0
    f6d6:	f04f 0a01 	movls.w	sl, #1
    ui32Denom = ( 1 << i32N ) * ( 1 + (ui32Div3 * 2) );
    f6da:	ea4f 004a 	mov.w	r0, sl, lsl #1
    f6de:	3001      	adds	r0, #1
    f6e0:	fa00 f905 	lsl.w	r9, r0, r5
    ui32TotPer = i32Div / ui32Denom;
    f6e4:	fbb8 f4f9 	udiv	r4, r8, r9
    ui32TotPer += (i32Div % ui32Denom) ? 1 : 0;
    f6e8:	fb09 8b14 	mls	fp, r9, r4, r8
    f6ec:	f1bb 0f00 	cmp.w	fp, #0
    f6f0:	bf18      	it	ne
    f6f2:	3401      	addne	r4, #1
    ui32v1 = 31 - AM_INSTR_CLZ(ui32TotPer);     // v1 = log2(TotPer)
    f6f4:	fab4 f684 	clz	r6, r4
    f6f8:	f1c6 091f 	rsb	r9, r6, #31
    ui32Fsel = (ui32v1 > 7) ? ui32v1 + i32N - 7 : i32N;
    f6fc:	f1b9 0f07 	cmp.w	r9, #7
    f700:	f240 8081 	bls.w	f806 <am_hal_iom_configure+0x1e2>
    f704:	3d07      	subs	r5, #7
    f706:	444d      	add	r5, r9
    ui32Fsel++;
    f708:	1c6e      	adds	r6, r5, #1
    if ( ui32Fsel > 7 )
    f70a:	2e07      	cmp	r6, #7
    f70c:	d868      	bhi.n	f7e0 <am_hal_iom_configure+0x1bc>
        ui32TotPer = ui32TotPer>>(ui32v1-7);
    f70e:	f1a9 0907 	sub.w	r9, r9, #7
        ui32TotPer += ((ui32DivEn) % (1 << (ui32v1 - 7))) ? 1 : 0;
    f712:	f04f 0b01 	mov.w	fp, #1
    f716:	fa0b fb09 	lsl.w	fp, fp, r9
    f71a:	f10b 3bff 	add.w	fp, fp, #4294967295
    f71e:	ea0b 0b04 	and.w	fp, fp, r4
        ui32TotPer = ui32TotPer>>(ui32v1-7);
    f722:	fa24 f409 	lsr.w	r4, r4, r9
        ui32TotPer += ((ui32DivEn) % (1 << (ui32v1 - 7))) ? 1 : 0;
    f726:	f1bb 0f00 	cmp.w	fp, #0
    f72a:	bf18      	it	ne
    f72c:	3401      	addne	r4, #1
                  ((1 << (ui32Fsel - 1)) == i32Div) ) ? 0 : 1;
    f72e:	f8df 9138 	ldr.w	r9, [pc, #312]	; f868 <am_hal_iom_configure+0x244>
    f732:	45ce      	cmp	lr, r9
    f734:	d86c      	bhi.n	f810 <am_hal_iom_configure+0x1ec>
    f736:	f04f 0b01 	mov.w	fp, #1
    f73a:	fa0b f905 	lsl.w	r9, fp, r5
    f73e:	ebb9 0908 	subs.w	r9, r9, r8
    f742:	bf18      	it	ne
    f744:	f04f 0901 	movne.w	r9, #1
    if (ui32Phase == 1)
    f748:	2f00      	cmp	r7, #0
    f74a:	d164      	bne.n	f816 <am_hal_iom_configure+0x1f2>
        ui32LowPer = (ui32TotPer - 1) / 2;          // Longer low phase
    f74c:	3c01      	subs	r4, #1
    f74e:	ea4f 0854 	mov.w	r8, r4, lsr #1
    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
    f752:	fb04 fb09 	mul.w	fp, r4, r9
    f756:	40a8      	lsls	r0, r5
    ui32ClkFreq = (ui32HFRCfreqHz) / ui32Denomfinal;                           // Compute the set frequency value
    f758:	4f37      	ldr	r7, [pc, #220]	; (f838 <am_hal_iom_configure+0x214>)
    ui32ClkCfg = _VAL2FLD(IOM0_CLKCFG_FSEL,   ui32Fsel)     |
    f75a:	0235      	lsls	r5, r6, #8
    ui32Denomfinal = ((1 << (ui32Fsel - 1)) * (1 + ui32Div3 * 2) * (1 + ui32DivEn * (ui32TotPer)));
    f75c:	fb0b 0000 	mla	r0, fp, r0, r0
    ui32ClkCfg = _VAL2FLD(IOM0_CLKCFG_FSEL,   ui32Fsel)     |
    f760:	f405 66e0 	and.w	r6, r5, #1792	; 0x700
    f764:	ea46 6404 	orr.w	r4, r6, r4, lsl #24
    ui32ClkFreq = (ui32HFRCfreqHz) / ui32Denomfinal;                           // Compute the set frequency value
    f768:	fbb7 f5f0 	udiv	r5, r7, r0
    ui32ClkFreq +=  (((ui32HFRCfreqHz) % ui32Denomfinal) > (ui32Denomfinal / 2)) ? 1 : 0;
    f76c:	fb00 7715 	mls	r7, r0, r5, r7
    f770:	0840      	lsrs	r0, r0, #1
    ui32ClkCfg = _VAL2FLD(IOM0_CLKCFG_FSEL,   ui32Fsel)     |
    f772:	ea44 2aca 	orr.w	sl, r4, sl, lsl #11
    ui32ClkFreq +=  (((ui32HFRCfreqHz) % ui32Denomfinal) > (ui32Denomfinal / 2)) ? 1 : 0;
    f776:	42b8      	cmp	r0, r7
    f778:	bf2c      	ite	cs
    f77a:	462c      	movcs	r4, r5
    f77c:	1c6c      	addcc	r4, r5, #1
    if ( (ui32ClkFreq % 250000) == 0 )
    f77e:	4d30      	ldr	r5, [pc, #192]	; (f840 <am_hal_iom_configure+0x21c>)
    f780:	fbb4 fbf5 	udiv	fp, r4, r5
                 _VAL2FLD(IOM0_CLKCFG_LOWPER, ui32LowPer)   |
    f784:	ea4f 4808 	mov.w	r8, r8, lsl #16
    f788:	f408 077f 	and.w	r7, r8, #16711680	; 0xff0000
    ui32ClkCfg = _VAL2FLD(IOM0_CLKCFG_FSEL,   ui32Fsel)     |
    f78c:	ea4a 3009 	orr.w	r0, sl, r9, lsl #12
    if ( (ui32ClkFreq % 250000) == 0 )
    f790:	fb05 441b 	mls	r4, r5, fp, r4
    ui32ClkCfg = _VAL2FLD(IOM0_CLKCFG_FSEL,   ui32Fsel)     |
    f794:	4307      	orrs	r7, r0
    if ( (ui32ClkFreq % 250000) == 0 )
    f796:	b94c      	cbnz	r4, f7ac <am_hal_iom_configure+0x188>
    return ui32Value  &&  !(ui32Value & (ui32Value - 1));
    f798:	f1bb 0f00 	cmp.w	fp, #0
    f79c:	d006      	beq.n	f7ac <am_hal_iom_configure+0x188>
    f79e:	f10b 35ff 	add.w	r5, fp, #4294967295
    f7a2:	ea15 0f0b 	tst.w	r5, fp
    f7a6:	d101      	bne.n	f7ac <am_hal_iom_configure+0x188>
    ui32ClkCfg = _VAL2FLD(IOM0_CLKCFG_FSEL,   ui32Fsel)     |
    f7a8:	f446 6700 	orr.w	r7, r6, #2048	; 0x800
    return ( ((uint64_t)ui32ClkFreq) << 32) | (uint64_t)ui32ClkCfg;
    f7ac:	f04f 0900 	mov.w	r9, #0
    f7b0:	ea49 0707 	orr.w	r7, r9, r7
        IOMn(ui32Module)->MSPICFG =
    f7b4:	f8c3 c300 	str.w	ip, [r3, #768]	; 0x300
    ui32ClkCfg |= _VAL2FLD(IOM0_CLKCFG_IOCLKEN, 1);
    f7b8:	f047 0601 	orr.w	r6, r7, #1
    IOMn(ui32Module)->CLKCFG = ui32ClkCfg;
    f7bc:	f8c3 6210 	str.w	r6, [r3, #528]	; 0x210
    pIOMState->pNBTxnBuf = psConfig->pNBTxnBuf;
    f7c0:	68c8      	ldr	r0, [r1, #12]
    pIOMState->ui32NBTxnBufLength = psConfig->ui32NBTxnBufLength;
    f7c2:	690b      	ldr	r3, [r1, #16]
    pIOMState->ui32BitTimeTicks = AM_HAL_CLKGEN_FREQ_MAX_HZ / psConfig->ui32ClockFreq;
    f7c4:	4c1c      	ldr	r4, [pc, #112]	; (f838 <am_hal_iom_configure+0x214>)
    pIOMState->pNBTxnBuf = psConfig->pNBTxnBuf;
    f7c6:	60d0      	str	r0, [r2, #12]
    pIOMState->waitTimeout = 1000;
    f7c8:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    pIOMState->ui32BitTimeTicks = AM_HAL_CLKGEN_FREQ_MAX_HZ / psConfig->ui32ClockFreq;
    f7cc:	fbb4 f5fe 	udiv	r5, r4, lr
    pIOMState->ui32NBTxnBufLength = psConfig->ui32NBTxnBufLength;
    f7d0:	6113      	str	r3, [r2, #16]
    pIOMState->waitTimeout = 1000;
    f7d2:	f8c2 182c 	str.w	r1, [r2, #2092]	; 0x82c
    return status;
    f7d6:	2000      	movs	r0, #0
    pIOMState->ui32BitTimeTicks = AM_HAL_CLKGEN_FREQ_MAX_HZ / psConfig->ui32ClockFreq;
    f7d8:	f8c2 5830 	str.w	r5, [r2, #2096]	; 0x830
    return status;
    f7dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return 0;
    f7e0:	2700      	movs	r7, #0
    f7e2:	e7e7      	b.n	f7b4 <am_hal_iom_configure+0x190>
        switch (psConfig->ui32ClockFreq)
    f7e4:	f8d1 e004 	ldr.w	lr, [r1, #4]
    f7e8:	4f16      	ldr	r7, [pc, #88]	; (f844 <am_hal_iom_configure+0x220>)
    f7ea:	45be      	cmp	lr, r7
    f7ec:	d01d      	beq.n	f82a <am_hal_iom_configure+0x206>
    f7ee:	4816      	ldr	r0, [pc, #88]	; (f848 <am_hal_iom_configure+0x224>)
    f7f0:	4586      	cmp	lr, r0
    f7f2:	d015      	beq.n	f820 <am_hal_iom_configure+0x1fc>
    f7f4:	4c15      	ldr	r4, [pc, #84]	; (f84c <am_hal_iom_configure+0x228>)
    f7f6:	45a6      	cmp	lr, r4
    f7f8:	f47f af3b 	bne.w	f672 <am_hal_iom_configure+0x4e>
                IOMn(ui32Module)->MI2CCFG = _VAL2FLD(IOM0_MI2CCFG_STRDIS, 0)                            |
    f7fc:	4d14      	ldr	r5, [pc, #80]	; (f850 <am_hal_iom_configure+0x22c>)
    f7fe:	f8c3 5400 	str.w	r5, [r3, #1024]	; 0x400
                ui32ClkCfg = _VAL2FLD(IOM0_CLKCFG_TOTPER, 0x77)                     |
    f802:	4f14      	ldr	r7, [pc, #80]	; (f854 <am_hal_iom_configure+0x230>)
                break;
    f804:	e7d8      	b.n	f7b8 <am_hal_iom_configure+0x194>
    ui32Fsel++;
    f806:	1c6e      	adds	r6, r5, #1
    f808:	e791      	b.n	f72e <am_hal_iom_configure+0x10a>
                    (ui32FreqHz <= ((ui32HFRCfreqHz / 2) - 1)) ) ) ) ? 1 : 0;
    f80a:	f04f 0a01 	mov.w	sl, #1
    f80e:	e764      	b.n	f6da <am_hal_iom_configure+0xb6>
                  ((1 << (ui32Fsel - 1)) == i32Div) ) ? 0 : 1;
    f810:	f04f 0900 	mov.w	r9, #0
    f814:	e798      	b.n	f748 <am_hal_iom_configure+0x124>
        ui32LowPer = (ui32TotPer - 2) / 2;          // Longer high phase
    f816:	1ea7      	subs	r7, r4, #2
    f818:	ea4f 0857 	mov.w	r8, r7, lsr #1
    f81c:	3c01      	subs	r4, #1
    f81e:	e798      	b.n	f752 <am_hal_iom_configure+0x12e>
                IOMn(ui32Module)->MI2CCFG = _VAL2FLD(IOM0_MI2CCFG_STRDIS, 0)                            |
    f820:	4e0d      	ldr	r6, [pc, #52]	; (f858 <am_hal_iom_configure+0x234>)
                ui32ClkCfg = _VAL2FLD(IOM0_CLKCFG_TOTPER, 0x06)                     |
    f822:	4f0e      	ldr	r7, [pc, #56]	; (f85c <am_hal_iom_configure+0x238>)
                IOMn(ui32Module)->MI2CCFG = _VAL2FLD(IOM0_MI2CCFG_STRDIS, 0)                            |
    f824:	f8c3 6400 	str.w	r6, [r3, #1024]	; 0x400
                break;
    f828:	e7c6      	b.n	f7b8 <am_hal_iom_configure+0x194>
                IOMn(ui32Module)->MI2CCFG = _VAL2FLD(IOM0_MI2CCFG_STRDIS, 0)                            |
    f82a:	480d      	ldr	r0, [pc, #52]	; (f860 <am_hal_iom_configure+0x23c>)
    f82c:	f8c3 0400 	str.w	r0, [r3, #1024]	; 0x400
                ui32ClkCfg = _VAL2FLD(IOM0_CLKCFG_TOTPER, 0x1D)                     |
    f830:	4f0c      	ldr	r7, [pc, #48]	; (f864 <am_hal_iom_configure+0x240>)
                break;
    f832:	e7c1      	b.n	f7b8 <am_hal_iom_configure+0x194>
    f834:	01123456 	.word	0x01123456
    f838:	02dc6c00 	.word	0x02dc6c00
    f83c:	007a11ff 	.word	0x007a11ff
    f840:	0003d090 	.word	0x0003d090
    f844:	00061a80 	.word	0x00061a80
    f848:	000f4240 	.word	0x000f4240
    f84c:	000186a0 	.word	0x000186a0
    f850:	0003f070 	.word	0x0003f070
    f854:	773b1201 	.word	0x773b1201
    f858:	00213040 	.word	0x00213040
    f85c:	06031301 	.word	0x06031301
    f860:	0003f270 	.word	0x0003f270
    f864:	1d0e1201 	.word	0x1d0e1201
    f868:	00b71aff 	.word	0x00b71aff

0000f86c <am_hal_iom_blocking_transfer>:
//
//*****************************************************************************
uint32_t
am_hal_iom_blocking_transfer(void *pHandle,
                             am_hal_iom_transfer_t *psTransaction)
{
    f86c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f870:	b087      	sub	sp, #28
    uint32_t ui32Status = AM_HAL_STATUS_SUCCESS;
    bool     bCmdCmp = false;
    uint32_t numWait = 0;

#ifndef AM_HAL_DISABLE_API_VALIDATION
    if (!AM_HAL_IOM_CHK_HANDLE(pHandle))
    f872:	b128      	cbz	r0, f880 <am_hal_iom_blocking_transfer+0x14>
    f874:	6803      	ldr	r3, [r0, #0]
    f876:	4a96      	ldr	r2, [pc, #600]	; (fad0 <am_hal_iom_blocking_transfer+0x264>)
    f878:	f023 447e 	bic.w	r4, r3, #4261412864	; 0xfe000000
    f87c:	4294      	cmp	r4, r2
    f87e:	d004      	beq.n	f88a <am_hal_iom_blocking_transfer+0x1e>
    {
        return AM_HAL_STATUS_INVALID_HANDLE;
    f880:	2502      	movs	r5, #2
    //
    // Return the status.
    //
    return ui32Status;

} // am_hal_iom_blocking_transfer()
    f882:	4628      	mov	r0, r5
    f884:	b007      	add	sp, #28
    f886:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (!psTransaction)
    f88a:	b121      	cbz	r1, f896 <am_hal_iom_blocking_transfer+0x2a>
    ui32OffsetCnt = psTransaction->ui32InstrLen;
    f88c:	f8d1 8004 	ldr.w	r8, [r1, #4]
    if ( (ui32OffsetCnt > AM_HAL_IOM_MAX_OFFSETSIZE)                            ||
    f890:	f1b8 0f03 	cmp.w	r8, #3
    f894:	d904      	bls.n	f8a0 <am_hal_iom_blocking_transfer+0x34>
          ((psTransaction->uPeerInfo.ui32SpiChipSelect > AM_HAL_IOM_MAX_CS_SPI) ||
    f896:	2506      	movs	r5, #6
} // am_hal_iom_blocking_transfer()
    f898:	4628      	mov	r0, r5
    f89a:	b007      	add	sp, #28
    f89c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
         (ui32Offset & (0xFFFFFFFF << (ui32OffsetCnt*8)))                       ||
    f8a0:	ea4f 05c8 	mov.w	r5, r8, lsl #3
    f8a4:	f04f 36ff 	mov.w	r6, #4294967295
    ui32Offset = psTransaction->ui32Instr;
    f8a8:	f8d1 a008 	ldr.w	sl, [r1, #8]
         (ui32Offset & (0xFFFFFFFF << (ui32OffsetCnt*8)))                       ||
    f8ac:	40ae      	lsls	r6, r5
    if ( (ui32OffsetCnt > AM_HAL_IOM_MAX_OFFSETSIZE)                            ||
    f8ae:	ea16 0f0a 	tst.w	r6, sl
    f8b2:	d1f0      	bne.n	f896 <am_hal_iom_blocking_transfer+0x2a>
    ui32Bytes = psTransaction->ui32NumBytes;
    f8b4:	68cf      	ldr	r7, [r1, #12]
    f8b6:	9703      	str	r7, [sp, #12]
    ui32Dir = psTransaction->eDirection;
    f8b8:	f891 9010 	ldrb.w	r9, [r1, #16]
         (ui32Offset & (0xFFFFFFFF << (ui32OffsetCnt*8)))                       ||
    f8bc:	2f00      	cmp	r7, #0
    f8be:	f000 818e 	beq.w	fbde <am_hal_iom_blocking_transfer+0x372>
         (ui32Bytes && (ui32Dir != AM_HAL_IOM_TX) && (psTransaction->pui32RxBuffer == NULL)) ||
    f8c2:	f1b9 0f00 	cmp.w	r9, #0
    f8c6:	f000 818f 	beq.w	fbe8 <am_hal_iom_blocking_transfer+0x37c>
    f8ca:	698a      	ldr	r2, [r1, #24]
    f8cc:	2a00      	cmp	r2, #0
    f8ce:	d0e2      	beq.n	f896 <am_hal_iom_blocking_transfer+0x2a>
         (ui32Bytes && (ui32Dir != AM_HAL_IOM_RX) && (psTransaction->pui32TxBuffer == NULL)) ||
    f8d0:	f1b9 0f01 	cmp.w	r9, #1
    f8d4:	f040 8188 	bne.w	fbe8 <am_hal_iom_blocking_transfer+0x37c>
         ((pIOMState->eInterfaceMode == AM_HAL_IOM_I2C_MODE) &&
    f8d8:	7a03      	ldrb	r3, [r0, #8]
         (ui32Bytes && (ui32Dir != AM_HAL_IOM_RX) && (psTransaction->pui32TxBuffer == NULL)) ||
    f8da:	2b01      	cmp	r3, #1
    f8dc:	d00c      	beq.n	f8f8 <am_hal_iom_blocking_transfer+0x8c>
          (psTransaction->ui32NumBytes > AM_HAL_IOM_MAX_TXNSIZE_I2C))           ||
    f8de:	b933      	cbnz	r3, f8ee <am_hal_iom_blocking_transfer+0x82>
         ((pIOMState->eInterfaceMode == AM_HAL_IOM_SPI_MODE) &&
    f8e0:	680d      	ldr	r5, [r1, #0]
    f8e2:	2d03      	cmp	r5, #3
    f8e4:	d8d7      	bhi.n	f896 <am_hal_iom_blocking_transfer+0x2a>
          ((psTransaction->uPeerInfo.ui32SpiChipSelect > AM_HAL_IOM_MAX_CS_SPI) ||
    f8e6:	9e03      	ldr	r6, [sp, #12]
    f8e8:	f5b6 5f80 	cmp.w	r6, #4096	; 0x1000
    f8ec:	d2d3      	bcs.n	f896 <am_hal_iom_blocking_transfer+0x2a>
    if (psTransaction->eDirection > AM_HAL_IOM_RX)
    f8ee:	f1b9 0f01 	cmp.w	r9, #1
    f8f2:	d905      	bls.n	f900 <am_hal_iom_blocking_transfer+0x94>
        return AM_HAL_STATUS_INVALID_OPERATION;
    f8f4:	2507      	movs	r5, #7
    f8f6:	e7c4      	b.n	f882 <am_hal_iom_blocking_transfer+0x16>
         ((pIOMState->eInterfaceMode == AM_HAL_IOM_I2C_MODE) &&
    f8f8:	9f03      	ldr	r7, [sp, #12]
    f8fa:	2fff      	cmp	r7, #255	; 0xff
    f8fc:	d8cb      	bhi.n	f896 <am_hal_iom_blocking_transfer+0x2a>
    f8fe:	e7f6      	b.n	f8ee <am_hal_iom_blocking_transfer+0x82>
    f900:	4604      	mov	r4, r0
    pui32Buffer = (ui32Dir == AM_HAL_IOM_TX) ? psTransaction->pui32TxBuffer : psTransaction->pui32RxBuffer;
    f902:	698d      	ldr	r5, [r1, #24]
    f904:	694f      	ldr	r7, [r1, #20]
    ui32Status = am_hal_flash_delay_status_check(pIOMState->waitTimeout,
    f906:	f8d0 082c 	ldr.w	r0, [r0, #2092]	; 0x82c
    ui32Module = pIOMState->ui32Module;
    f90a:	6866      	ldr	r6, [r4, #4]
    ui32Status = am_hal_flash_delay_status_check(pIOMState->waitTimeout,
    f90c:	2301      	movs	r3, #1
    f90e:	468b      	mov	fp, r1
    ui32Cont = psTransaction->bContinue ? 1 : 0;
    f910:	7f09      	ldrb	r1, [r1, #28]
    f912:	9102      	str	r1, [sp, #8]
    ui32Status = am_hal_flash_delay_status_check(pIOMState->waitTimeout,
    f914:	9300      	str	r3, [sp, #0]
    f916:	f04f 32ff 	mov.w	r2, #4294967295
    f91a:	2300      	movs	r3, #0
    f91c:	f104 0124 	add.w	r1, r4, #36	; 0x24
    pui32Buffer = (ui32Dir == AM_HAL_IOM_TX) ? psTransaction->pui32TxBuffer : psTransaction->pui32RxBuffer;
    f920:	4599      	cmp	r9, r3
    f922:	bf18      	it	ne
    f924:	462f      	movne	r7, r5
    ui32Status = am_hal_flash_delay_status_check(pIOMState->waitTimeout,
    f926:	f7ff f881 	bl	ea2c <am_hal_flash_delay_status_check>
    if ( ui32Status != AM_HAL_STATUS_SUCCESS )
    f92a:	4605      	mov	r5, r0
    f92c:	2800      	cmp	r0, #0
    f92e:	d1a8      	bne.n	f882 <am_hal_iom_blocking_transfer+0x16>
                            (uint32_t)&IOMn(ui32Module)->STATUS,
    f930:	f506 20a0 	add.w	r0, r6, #327680	; 0x50000
    f934:	3004      	adds	r0, #4
    f936:	0306      	lsls	r6, r0, #12
    ui32Status = am_hal_flash_delay_status_check(pIOMState->waitTimeout,
    f938:	2201      	movs	r2, #1
    f93a:	f8d4 082c 	ldr.w	r0, [r4, #2092]	; 0x82c
    f93e:	9200      	str	r2, [sp, #0]
                            (uint32_t)&IOMn(ui32Module)->STATUS,
    f940:	f506 712d 	add.w	r1, r6, #692	; 0x2b4
    ui32Status = am_hal_flash_delay_status_check(pIOMState->waitTimeout,
    f944:	2304      	movs	r3, #4
    f946:	2206      	movs	r2, #6
                            (uint32_t)&IOMn(ui32Module)->STATUS,
    f948:	9104      	str	r1, [sp, #16]
    ui32Status = am_hal_flash_delay_status_check(pIOMState->waitTimeout,
    f94a:	f7ff f86f 	bl	ea2c <am_hal_flash_delay_status_check>
    if ( ui32Status != AM_HAL_STATUS_SUCCESS )
    f94e:	4605      	mov	r5, r0
    f950:	2800      	cmp	r0, #0
    f952:	d196      	bne.n	f882 <am_hal_iom_blocking_transfer+0x16>
    IOMn(ui32Module)->INTCLR = AM_HAL_IOM_INT_ALL;
    f954:	f04f 33ff 	mov.w	r3, #4294967295
    ui32IntConfig = IOMn(ui32Module)->INTEN;
    f958:	f8d6 0200 	ldr.w	r0, [r6, #512]	; 0x200
    IOMn(ui32Module)->INTEN = 0;
    f95c:	f8c6 5200 	str.w	r5, [r6, #512]	; 0x200
    IOMn(ui32Module)->INTCLR = AM_HAL_IOM_INT_ALL;
    f960:	f8c6 3208 	str.w	r3, [r6, #520]	; 0x208
    IOMn(ui32Module)->DEVCFG = psTransaction->uPeerInfo.ui32I2CDevAddr;
    f964:	f8db 3000 	ldr.w	r3, [fp]
    f968:	f8c6 3404 	str.w	r3, [r6, #1028]	; 0x404
    IOMn(ui32Module)->CMDRPT = psTransaction->ui8RepeatCount;
    f96c:	f89b 201d 	ldrb.w	r2, [fp, #29]
    f970:	f8c6 221c 	str.w	r2, [r6, #540]	; 0x21c
              psTransaction->uPeerInfo.ui32SpiChipSelect : 0;
    f974:	7a21      	ldrb	r1, [r4, #8]
    ui32IntConfig = IOMn(ui32Module)->INTEN;
    f976:	9005      	str	r0, [sp, #20]
              psTransaction->uPeerInfo.ui32SpiChipSelect : 0;
    f978:	2900      	cmp	r1, #0
    f97a:	f040 813a 	bne.w	fbf2 <am_hal_iom_blocking_transfer+0x386>
    f97e:	0518      	lsls	r0, r3, #20
    f980:	f400 1140 	and.w	r1, r0, #3145728	; 0x300000
    ui32Cmd |= _VAL2FLD(IOM0_CMD_TSIZE, ui32nBytes);
    f984:	9803      	ldr	r0, [sp, #12]
    f986:	4b53      	ldr	r3, [pc, #332]	; (fad4 <am_hal_iom_blocking_transfer+0x268>)
    f988:	ea03 2300 	and.w	r3, r3, r0, lsl #8
    f98c:	430b      	orrs	r3, r1
    if (ui32Dir == AM_HAL_IOM_RX)
    f98e:	f1b9 0f01 	cmp.w	r9, #1
        ui32Cmd |= _VAL2FLD(IOM0_CMD_CMD, IOM0_CMD_CMD_READ);
    f992:	bf0c      	ite	eq
    f994:	f043 0102 	orreq.w	r1, r3, #2
        ui32Cmd |= _VAL2FLD(IOM0_CMD_CMD, IOM0_CMD_CMD_WRITE);
    f998:	f043 0101 	orrne.w	r1, r3, #1
    ui32Cmd |= _VAL2FLD(IOM0_CMD_OFFSETCNT, ui32OffsetCnt);
    f99c:	ea4f 1048 	mov.w	r0, r8, lsl #5
    f9a0:	9b02      	ldr	r3, [sp, #8]
    f9a2:	f000 0c60 	and.w	ip, r0, #96	; 0x60
    f9a6:	ea4c 10c3 	orr.w	r0, ip, r3, lsl #7
    f9aa:	ea40 630a 	orr.w	r3, r0, sl, lsl #24
    f9ae:	430b      	orrs	r3, r1
    f9b0:	f3ca 210f 	ubfx	r1, sl, #8, #16
    IOMn(ui32Module)->OFFSETHI = (uint16_t)(ui32Offset >> 8);
    f9b4:	f8c6 1220 	str.w	r1, [r6, #544]	; 0x220
    IOMn(ui32Module)->CMD = ui32Cmd;
    f9b8:	f8c6 3218 	str.w	r3, [r6, #536]	; 0x218
    ui32Bytes = (1 + psTransaction->ui8RepeatCount) * psTransaction->ui32NumBytes;
    f9bc:	f8db 000c 	ldr.w	r0, [fp, #12]
    if ( ui32Dir == AM_HAL_IOM_RX )
    f9c0:	f1b9 0f01 	cmp.w	r9, #1
    ui32Bytes = (1 + psTransaction->ui8RepeatCount) * psTransaction->ui32NumBytes;
    f9c4:	fb02 0b00 	mla	fp, r2, r0, r0
    if ( ui32Dir == AM_HAL_IOM_RX )
    f9c8:	f000 8115 	beq.w	fbf6 <am_hal_iom_blocking_transfer+0x38a>
        while (ui32Bytes)
    f9cc:	f1bb 0f00 	cmp.w	fp, #0
    f9d0:	d052      	beq.n	fa78 <am_hal_iom_blocking_transfer+0x20c>
            while ((ui32FifoRem = IOMn(ui32Module)->FIFOPTR_b.FIFO0REM) < 4)
    f9d2:	f8d6 2100 	ldr.w	r2, [r6, #256]	; 0x100
    f9d6:	f3c2 2307 	ubfx	r3, r2, #8, #8
    f9da:	2b03      	cmp	r3, #3
    f9dc:	d87e      	bhi.n	fadc <am_hal_iom_blocking_transfer+0x270>
                bCmdCmp = IOMn(ui32Module)->INTSTAT_b.CMDCMP;
    f9de:	f8d6 3204 	ldr.w	r3, [r6, #516]	; 0x204
                if (bCmdCmp || (numWait++ >= AM_HAL_IOM_MAX_BLOCKING_WAIT))
    f9e2:	07d8      	lsls	r0, r3, #31
    f9e4:	d447      	bmi.n	fa76 <am_hal_iom_blocking_transfer+0x20a>
    f9e6:	f8df a0f0 	ldr.w	sl, [pc, #240]	; fad8 <am_hal_iom_blocking_transfer+0x26c>
                    am_hal_flash_delay( FLASH_CYCLES_US(1) );
    f9ea:	2001      	movs	r0, #1
    f9ec:	f7ff f81a 	bl	ea24 <am_hal_flash_delay>
            while ((ui32FifoRem = IOMn(ui32Module)->FIFOPTR_b.FIFO0REM) < 4)
    f9f0:	f8d6 1100 	ldr.w	r1, [r6, #256]	; 0x100
    f9f4:	f3c1 2307 	ubfx	r3, r1, #8, #8
    f9f8:	2b03      	cmp	r3, #3
    f9fa:	d86f      	bhi.n	fadc <am_hal_iom_blocking_transfer+0x270>
                bCmdCmp = IOMn(ui32Module)->INTSTAT_b.CMDCMP;
    f9fc:	f8d6 0204 	ldr.w	r0, [r6, #516]	; 0x204
                if (bCmdCmp || (numWait++ >= AM_HAL_IOM_MAX_BLOCKING_WAIT))
    fa00:	07c3      	lsls	r3, r0, #31
    fa02:	d438      	bmi.n	fa76 <am_hal_iom_blocking_transfer+0x20a>
                    am_hal_flash_delay( FLASH_CYCLES_US(1) );
    fa04:	2001      	movs	r0, #1
    fa06:	f7ff f80d 	bl	ea24 <am_hal_flash_delay>
            while ((ui32FifoRem = IOMn(ui32Module)->FIFOPTR_b.FIFO0REM) < 4)
    fa0a:	f8d6 2100 	ldr.w	r2, [r6, #256]	; 0x100
    fa0e:	f3c2 2307 	ubfx	r3, r2, #8, #8
    fa12:	2b03      	cmp	r3, #3
    fa14:	f10a 3aff 	add.w	sl, sl, #4294967295
    fa18:	d860      	bhi.n	fadc <am_hal_iom_blocking_transfer+0x270>
                bCmdCmp = IOMn(ui32Module)->INTSTAT_b.CMDCMP;
    fa1a:	f8d6 3204 	ldr.w	r3, [r6, #516]	; 0x204
                if (bCmdCmp || (numWait++ >= AM_HAL_IOM_MAX_BLOCKING_WAIT))
    fa1e:	07d8      	lsls	r0, r3, #31
    fa20:	d429      	bmi.n	fa76 <am_hal_iom_blocking_transfer+0x20a>
                    am_hal_flash_delay( FLASH_CYCLES_US(1) );
    fa22:	2001      	movs	r0, #1
    fa24:	f7fe fffe 	bl	ea24 <am_hal_flash_delay>
            while ((ui32FifoRem = IOMn(ui32Module)->FIFOPTR_b.FIFO0REM) < 4)
    fa28:	f8d6 1100 	ldr.w	r1, [r6, #256]	; 0x100
    fa2c:	f3c1 2307 	ubfx	r3, r1, #8, #8
    fa30:	2b03      	cmp	r3, #3
    fa32:	d853      	bhi.n	fadc <am_hal_iom_blocking_transfer+0x270>
                bCmdCmp = IOMn(ui32Module)->INTSTAT_b.CMDCMP;
    fa34:	f8d6 0204 	ldr.w	r0, [r6, #516]	; 0x204
                if (bCmdCmp || (numWait++ >= AM_HAL_IOM_MAX_BLOCKING_WAIT))
    fa38:	07c1      	lsls	r1, r0, #31
    fa3a:	d41c      	bmi.n	fa76 <am_hal_iom_blocking_transfer+0x20a>
                    am_hal_flash_delay( FLASH_CYCLES_US(1) );
    fa3c:	2001      	movs	r0, #1
    fa3e:	f7fe fff1 	bl	ea24 <am_hal_flash_delay>
            while ((ui32FifoRem = IOMn(ui32Module)->FIFOPTR_b.FIFO0REM) < 4)
    fa42:	f8d6 2100 	ldr.w	r2, [r6, #256]	; 0x100
    fa46:	f3c2 2307 	ubfx	r3, r2, #8, #8
    fa4a:	2b03      	cmp	r3, #3
    fa4c:	d846      	bhi.n	fadc <am_hal_iom_blocking_transfer+0x270>
                bCmdCmp = IOMn(ui32Module)->INTSTAT_b.CMDCMP;
    fa4e:	f8d6 3204 	ldr.w	r3, [r6, #516]	; 0x204
                if (bCmdCmp || (numWait++ >= AM_HAL_IOM_MAX_BLOCKING_WAIT))
    fa52:	07da      	lsls	r2, r3, #31
    fa54:	d40f      	bmi.n	fa76 <am_hal_iom_blocking_transfer+0x20a>
                    am_hal_flash_delay( FLASH_CYCLES_US(1) );
    fa56:	2001      	movs	r0, #1
    fa58:	f7fe ffe4 	bl	ea24 <am_hal_flash_delay>
            while ((ui32FifoRem = IOMn(ui32Module)->FIFOPTR_b.FIFO0REM) < 4)
    fa5c:	f8d6 1100 	ldr.w	r1, [r6, #256]	; 0x100
    fa60:	f3c1 2307 	ubfx	r3, r1, #8, #8
    fa64:	2b03      	cmp	r3, #3
    fa66:	d839      	bhi.n	fadc <am_hal_iom_blocking_transfer+0x270>
                bCmdCmp = IOMn(ui32Module)->INTSTAT_b.CMDCMP;
    fa68:	f8d6 3204 	ldr.w	r3, [r6, #516]	; 0x204
                if (bCmdCmp || (numWait++ >= AM_HAL_IOM_MAX_BLOCKING_WAIT))
    fa6c:	07db      	lsls	r3, r3, #31
    fa6e:	d402      	bmi.n	fa76 <am_hal_iom_blocking_transfer+0x20a>
    fa70:	f1ba 0a04 	subs.w	sl, sl, #4
    fa74:	d1b9      	bne.n	f9ea <am_hal_iom_blocking_transfer+0x17e>
    fa76:	465d      	mov	r5, fp
    ui32Status = am_hal_flash_delay_status_check(AM_HAL_IOM_MAX_BLOCKING_WAIT,
    fa78:	2701      	movs	r7, #1
    fa7a:	2206      	movs	r2, #6
    fa7c:	9904      	ldr	r1, [sp, #16]
    fa7e:	9700      	str	r7, [sp, #0]
    fa80:	2304      	movs	r3, #4
    fa82:	4815      	ldr	r0, [pc, #84]	; (fad8 <am_hal_iom_blocking_transfer+0x26c>)
    fa84:	f7fe ffd2 	bl	ea2c <am_hal_flash_delay_status_check>
    if ( ui32Status == AM_HAL_STATUS_SUCCESS )
    fa88:	4602      	mov	r2, r0
    fa8a:	b978      	cbnz	r0, faac <am_hal_iom_blocking_transfer+0x240>
    ui32IntStatus |= IOMn(ui32Module)->INTSTAT;
    fa8c:	f8d6 0204 	ldr.w	r0, [r6, #516]	; 0x204
    if (ui32IntStatus & AM_HAL_IOM_INT_SWERR)
    fa90:	f010 0f6c 	tst.w	r0, #108	; 0x6c
    fa94:	f040 818f 	bne.w	fdb6 <am_hal_iom_blocking_transfer+0x54a>
    else if (ui32IntStatus & AM_HAL_IOM_INT_I2CARBERR)
    fa98:	0581      	lsls	r1, r0, #22
    fa9a:	f100 818f 	bmi.w	fdbc <am_hal_iom_blocking_transfer+0x550>
    else if (ui32IntStatus & AM_HAL_IOM_INT_NAK)
    fa9e:	06c2      	lsls	r2, r0, #27
    faa0:	f100 818e 	bmi.w	fdc0 <am_hal_iom_blocking_transfer+0x554>
    else if (ui32IntStatus & AM_HAL_IOM_INT_INTERR)
    faa4:	f410 4f90 	tst.w	r0, #18432	; 0x4800
    faa8:	d00e      	beq.n	fac8 <am_hal_iom_blocking_transfer+0x25c>
        ui32Status = AM_HAL_STATUS_FAIL;
    faaa:	463a      	mov	r2, r7
        internal_iom_reset_on_error(pIOMState, IOMn(ui32Module)->INTSTAT);
    faac:	f8d6 1204 	ldr.w	r1, [r6, #516]	; 0x204
    fab0:	4620      	mov	r0, r4
    fab2:	4615      	mov	r5, r2
    fab4:	f7ff fa78 	bl	efa8 <internal_iom_reset_on_error>
    IOMn(ui32Module)->INTCLR = AM_HAL_IOM_INT_ALL;
    fab8:	f04f 34ff 	mov.w	r4, #4294967295
    IOMn(ui32Module)->INTEN = ui32IntConfig;
    fabc:	9905      	ldr	r1, [sp, #20]
    IOMn(ui32Module)->INTCLR = AM_HAL_IOM_INT_ALL;
    fabe:	f8c6 4208 	str.w	r4, [r6, #520]	; 0x208
    IOMn(ui32Module)->INTEN = ui32IntConfig;
    fac2:	f8c6 1200 	str.w	r1, [r6, #512]	; 0x200
    return ui32Status;
    fac6:	e6dc      	b.n	f882 <am_hal_iom_blocking_transfer+0x16>
            if (ui32Bytes)
    fac8:	2d00      	cmp	r5, #0
    faca:	d0f5      	beq.n	fab8 <am_hal_iom_blocking_transfer+0x24c>
    facc:	e7ed      	b.n	faaa <am_hal_iom_blocking_transfer+0x23e>
    face:	bf00      	nop
    fad0:	01123456 	.word	0x01123456
    fad4:	000fff00 	.word	0x000fff00
    fad8:	0007a120 	.word	0x0007a120
                IOMn(ui32Module)->FIFOPUSH = *pui32Buffer++;
    fadc:	6838      	ldr	r0, [r7, #0]
    fade:	f8c6 010c 	str.w	r0, [r6, #268]	; 0x10c
                if (ui32Bytes >= 4)
    fae2:	f1bb 0f03 	cmp.w	fp, #3
    fae6:	d9c7      	bls.n	fa78 <am_hal_iom_blocking_transfer+0x20c>
                ui32FifoRem -= 4;
    fae8:	1f19      	subs	r1, r3, #4
            while ((ui32FifoRem >= 4) && ui32Bytes)
    faea:	2903      	cmp	r1, #3
                IOMn(ui32Module)->FIFOPUSH = *pui32Buffer++;
    faec:	f107 0704 	add.w	r7, r7, #4
                    ui32Bytes -= 4;
    faf0:	f1ab 0204 	sub.w	r2, fp, #4
            while ((ui32FifoRem >= 4) && ui32Bytes)
    faf4:	d96e      	bls.n	fbd4 <am_hal_iom_blocking_transfer+0x368>
    faf6:	f3c2 0081 	ubfx	r0, r2, #2, #2
    fafa:	eba3 030b 	sub.w	r3, r3, fp
    fafe:	4639      	mov	r1, r7
    fb00:	b338      	cbz	r0, fb52 <am_hal_iom_blocking_transfer+0x2e6>
                IOMn(ui32Module)->FIFOPUSH = *pui32Buffer++;
    fb02:	4639      	mov	r1, r7
                if (ui32Bytes >= 4)
    fb04:	2a03      	cmp	r2, #3
                IOMn(ui32Module)->FIFOPUSH = *pui32Buffer++;
    fb06:	f851 7b04 	ldr.w	r7, [r1], #4
    fb0a:	f8c6 710c 	str.w	r7, [r6, #268]	; 0x10c
                if (ui32Bytes >= 4)
    fb0e:	d9b3      	bls.n	fa78 <am_hal_iom_blocking_transfer+0x20c>
                    ui32Bytes -= 4;
    fb10:	3a04      	subs	r2, #4
            while ((ui32FifoRem >= 4) && ui32Bytes)
    fb12:	eb02 0e03 	add.w	lr, r2, r3
    fb16:	f1be 0f03 	cmp.w	lr, #3
                IOMn(ui32Module)->FIFOPUSH = *pui32Buffer++;
    fb1a:	460f      	mov	r7, r1
            while ((ui32FifoRem >= 4) && ui32Bytes)
    fb1c:	d95a      	bls.n	fbd4 <am_hal_iom_blocking_transfer+0x368>
    fb1e:	2801      	cmp	r0, #1
    fb20:	d017      	beq.n	fb52 <am_hal_iom_blocking_transfer+0x2e6>
    fb22:	2802      	cmp	r0, #2
    fb24:	d00a      	beq.n	fb3c <am_hal_iom_blocking_transfer+0x2d0>
                IOMn(ui32Module)->FIFOPUSH = *pui32Buffer++;
    fb26:	f851 0b04 	ldr.w	r0, [r1], #4
    fb2a:	f8c6 010c 	str.w	r0, [r6, #268]	; 0x10c
                if (ui32Bytes >= 4)
    fb2e:	2a03      	cmp	r2, #3
    fb30:	d9a2      	bls.n	fa78 <am_hal_iom_blocking_transfer+0x20c>
                    ui32Bytes -= 4;
    fb32:	3a04      	subs	r2, #4
            while ((ui32FifoRem >= 4) && ui32Bytes)
    fb34:	18d0      	adds	r0, r2, r3
    fb36:	2803      	cmp	r0, #3
                IOMn(ui32Module)->FIFOPUSH = *pui32Buffer++;
    fb38:	460f      	mov	r7, r1
            while ((ui32FifoRem >= 4) && ui32Bytes)
    fb3a:	d94b      	bls.n	fbd4 <am_hal_iom_blocking_transfer+0x368>
                IOMn(ui32Module)->FIFOPUSH = *pui32Buffer++;
    fb3c:	f851 7b04 	ldr.w	r7, [r1], #4
    fb40:	f8c6 710c 	str.w	r7, [r6, #268]	; 0x10c
                if (ui32Bytes >= 4)
    fb44:	2a03      	cmp	r2, #3
    fb46:	d997      	bls.n	fa78 <am_hal_iom_blocking_transfer+0x20c>
                    ui32Bytes -= 4;
    fb48:	3a04      	subs	r2, #4
            while ((ui32FifoRem >= 4) && ui32Bytes)
    fb4a:	18d0      	adds	r0, r2, r3
    fb4c:	2803      	cmp	r0, #3
                IOMn(ui32Module)->FIFOPUSH = *pui32Buffer++;
    fb4e:	460f      	mov	r7, r1
            while ((ui32FifoRem >= 4) && ui32Bytes)
    fb50:	d940      	bls.n	fbd4 <am_hal_iom_blocking_transfer+0x368>
                IOMn(ui32Module)->FIFOPUSH = *pui32Buffer++;
    fb52:	4689      	mov	r9, r1
            while ((ui32FifoRem >= 4) && ui32Bytes)
    fb54:	2a00      	cmp	r2, #0
    fb56:	d08f      	beq.n	fa78 <am_hal_iom_blocking_transfer+0x20c>
                IOMn(ui32Module)->FIFOPUSH = *pui32Buffer++;
    fb58:	f859 7b04 	ldr.w	r7, [r9], #4
    fb5c:	f8c6 710c 	str.w	r7, [r6, #268]	; 0x10c
                if (ui32Bytes >= 4)
    fb60:	2a03      	cmp	r2, #3
                    ui32Bytes -= 4;
    fb62:	f1a2 0204 	sub.w	r2, r2, #4
            while ((ui32FifoRem >= 4) && ui32Bytes)
    fb66:	eb02 0003 	add.w	r0, r2, r3
                    ui32Bytes -= 4;
    fb6a:	4693      	mov	fp, r2
                IOMn(ui32Module)->FIFOPUSH = *pui32Buffer++;
    fb6c:	464f      	mov	r7, r9
    fb6e:	f109 0c04 	add.w	ip, r9, #4
                if (ui32Bytes >= 4)
    fb72:	d981      	bls.n	fa78 <am_hal_iom_blocking_transfer+0x20c>
            while ((ui32FifoRem >= 4) && ui32Bytes)
    fb74:	2803      	cmp	r0, #3
    fb76:	f101 080c 	add.w	r8, r1, #12
    fb7a:	d92b      	bls.n	fbd4 <am_hal_iom_blocking_transfer+0x368>
                IOMn(ui32Module)->FIFOPUSH = *pui32Buffer++;
    fb7c:	f8d9 7000 	ldr.w	r7, [r9]
    fb80:	f8c6 710c 	str.w	r7, [r6, #268]	; 0x10c
                if (ui32Bytes >= 4)
    fb84:	2a03      	cmp	r2, #3
                    ui32Bytes -= 4;
    fb86:	f1a2 0204 	sub.w	r2, r2, #4
            while ((ui32FifoRem >= 4) && ui32Bytes)
    fb8a:	eb02 0003 	add.w	r0, r2, r3
                IOMn(ui32Module)->FIFOPUSH = *pui32Buffer++;
    fb8e:	4667      	mov	r7, ip
                if (ui32Bytes >= 4)
    fb90:	f67f af72 	bls.w	fa78 <am_hal_iom_blocking_transfer+0x20c>
            while ((ui32FifoRem >= 4) && ui32Bytes)
    fb94:	2803      	cmp	r0, #3
    fb96:	f101 0110 	add.w	r1, r1, #16
    fb9a:	d91b      	bls.n	fbd4 <am_hal_iom_blocking_transfer+0x368>
                IOMn(ui32Module)->FIFOPUSH = *pui32Buffer++;
    fb9c:	f8dc 7000 	ldr.w	r7, [ip]
    fba0:	f8c6 710c 	str.w	r7, [r6, #268]	; 0x10c
                if (ui32Bytes >= 4)
    fba4:	2a03      	cmp	r2, #3
                    ui32Bytes -= 4;
    fba6:	f1ab 0208 	sub.w	r2, fp, #8
            while ((ui32FifoRem >= 4) && ui32Bytes)
    fbaa:	eb02 0003 	add.w	r0, r2, r3
                IOMn(ui32Module)->FIFOPUSH = *pui32Buffer++;
    fbae:	4647      	mov	r7, r8
                if (ui32Bytes >= 4)
    fbb0:	f67f af62 	bls.w	fa78 <am_hal_iom_blocking_transfer+0x20c>
            while ((ui32FifoRem >= 4) && ui32Bytes)
    fbb4:	2803      	cmp	r0, #3
    fbb6:	d90d      	bls.n	fbd4 <am_hal_iom_blocking_transfer+0x368>
                IOMn(ui32Module)->FIFOPUSH = *pui32Buffer++;
    fbb8:	f8d8 7000 	ldr.w	r7, [r8]
    fbbc:	f8c6 710c 	str.w	r7, [r6, #268]	; 0x10c
                if (ui32Bytes >= 4)
    fbc0:	2a03      	cmp	r2, #3
                    ui32Bytes -= 4;
    fbc2:	f1ab 020c 	sub.w	r2, fp, #12
            while ((ui32FifoRem >= 4) && ui32Bytes)
    fbc6:	eb02 0003 	add.w	r0, r2, r3
                IOMn(ui32Module)->FIFOPUSH = *pui32Buffer++;
    fbca:	460f      	mov	r7, r1
                if (ui32Bytes >= 4)
    fbcc:	f67f af54 	bls.w	fa78 <am_hal_iom_blocking_transfer+0x20c>
            while ((ui32FifoRem >= 4) && ui32Bytes)
    fbd0:	2803      	cmp	r0, #3
    fbd2:	d8be      	bhi.n	fb52 <am_hal_iom_blocking_transfer+0x2e6>
                    ui32Bytes -= 4;
    fbd4:	4693      	mov	fp, r2
        while (ui32Bytes)
    fbd6:	2a00      	cmp	r2, #0
    fbd8:	f47f aefb 	bne.w	f9d2 <am_hal_iom_blocking_transfer+0x166>
    fbdc:	e74c      	b.n	fa78 <am_hal_iom_blocking_transfer+0x20c>
         ((pIOMState->eInterfaceMode == AM_HAL_IOM_I2C_MODE) &&
    fbde:	7a03      	ldrb	r3, [r0, #8]
         (ui32Bytes && (ui32Dir != AM_HAL_IOM_RX) && (psTransaction->pui32TxBuffer == NULL)) ||
    fbe0:	2b01      	cmp	r3, #1
    fbe2:	f47f ae7c 	bne.w	f8de <am_hal_iom_blocking_transfer+0x72>
    fbe6:	e682      	b.n	f8ee <am_hal_iom_blocking_transfer+0x82>
    fbe8:	694c      	ldr	r4, [r1, #20]
    fbea:	2c00      	cmp	r4, #0
    fbec:	f47f ae74 	bne.w	f8d8 <am_hal_iom_blocking_transfer+0x6c>
    fbf0:	e651      	b.n	f896 <am_hal_iom_blocking_transfer+0x2a>
    fbf2:	4629      	mov	r1, r5
    fbf4:	e6c6      	b.n	f984 <am_hal_iom_blocking_transfer+0x118>
        while ( ui32Bytes )
    fbf6:	2200      	movs	r2, #0
    fbf8:	f1bb 0f00 	cmp.w	fp, #0
    fbfc:	f43f af3c 	beq.w	fa78 <am_hal_iom_blocking_transfer+0x20c>
            while ((ui32FifoSiz = IOMn(ui32Module)->FIFOPTR_b.FIFO1SIZ) < 4)
    fc00:	f8d6 1100 	ldr.w	r1, [r6, #256]	; 0x100
    fc04:	f3c1 4307 	ubfx	r3, r1, #16, #8
    fc08:	2b03      	cmp	r3, #3
    fc0a:	d84b      	bhi.n	fca4 <am_hal_iom_blocking_transfer+0x438>
    fc0c:	f8df 91bc 	ldr.w	r9, [pc, #444]	; fdcc <am_hal_iom_blocking_transfer+0x560>
                    if (bCmdCmp && (ui32Bytes > ui32FifoSiz))
    fc10:	b112      	cbz	r2, fc18 <am_hal_iom_blocking_transfer+0x3ac>
    fc12:	459b      	cmp	fp, r3
    fc14:	f63f af2f 	bhi.w	fa76 <am_hal_iom_blocking_transfer+0x20a>
                    am_hal_flash_delay( FLASH_CYCLES_US(1) );
    fc18:	2001      	movs	r0, #1
    fc1a:	f7fe ff03 	bl	ea24 <am_hal_flash_delay>
                bCmdCmp = IOMn(ui32Module)->INTSTAT_b.CMDCMP;
    fc1e:	f8d6 2204 	ldr.w	r2, [r6, #516]	; 0x204
            while ((ui32FifoSiz = IOMn(ui32Module)->FIFOPTR_b.FIFO1SIZ) < 4)
    fc22:	f8d6 0100 	ldr.w	r0, [r6, #256]	; 0x100
    fc26:	f3c0 4307 	ubfx	r3, r0, #16, #8
    fc2a:	2b03      	cmp	r3, #3
                bCmdCmp = IOMn(ui32Module)->INTSTAT_b.CMDCMP;
    fc2c:	f002 0201 	and.w	r2, r2, #1
            while ((ui32FifoSiz = IOMn(ui32Module)->FIFOPTR_b.FIFO1SIZ) < 4)
    fc30:	d838      	bhi.n	fca4 <am_hal_iom_blocking_transfer+0x438>
    fc32:	f109 39ff 	add.w	r9, r9, #4294967295
                    if (bCmdCmp && (ui32Bytes > ui32FifoSiz))
    fc36:	b112      	cbz	r2, fc3e <am_hal_iom_blocking_transfer+0x3d2>
    fc38:	459b      	cmp	fp, r3
    fc3a:	f63f af1c 	bhi.w	fa76 <am_hal_iom_blocking_transfer+0x20a>
                    am_hal_flash_delay( FLASH_CYCLES_US(1) );
    fc3e:	2001      	movs	r0, #1
    fc40:	f7fe fef0 	bl	ea24 <am_hal_flash_delay>
                bCmdCmp = IOMn(ui32Module)->INTSTAT_b.CMDCMP;
    fc44:	f8d6 1204 	ldr.w	r1, [r6, #516]	; 0x204
            while ((ui32FifoSiz = IOMn(ui32Module)->FIFOPTR_b.FIFO1SIZ) < 4)
    fc48:	f8d6 3100 	ldr.w	r3, [r6, #256]	; 0x100
    fc4c:	f3c3 4307 	ubfx	r3, r3, #16, #8
    fc50:	2b03      	cmp	r3, #3
                bCmdCmp = IOMn(ui32Module)->INTSTAT_b.CMDCMP;
    fc52:	f001 0201 	and.w	r2, r1, #1
            while ((ui32FifoSiz = IOMn(ui32Module)->FIFOPTR_b.FIFO1SIZ) < 4)
    fc56:	d825      	bhi.n	fca4 <am_hal_iom_blocking_transfer+0x438>
                    if (bCmdCmp && (ui32Bytes > ui32FifoSiz))
    fc58:	b112      	cbz	r2, fc60 <am_hal_iom_blocking_transfer+0x3f4>
    fc5a:	459b      	cmp	fp, r3
    fc5c:	f63f af0b 	bhi.w	fa76 <am_hal_iom_blocking_transfer+0x20a>
                    am_hal_flash_delay( FLASH_CYCLES_US(1) );
    fc60:	2001      	movs	r0, #1
    fc62:	f7fe fedf 	bl	ea24 <am_hal_flash_delay>
                bCmdCmp = IOMn(ui32Module)->INTSTAT_b.CMDCMP;
    fc66:	f8d6 2204 	ldr.w	r2, [r6, #516]	; 0x204
            while ((ui32FifoSiz = IOMn(ui32Module)->FIFOPTR_b.FIFO1SIZ) < 4)
    fc6a:	f8d6 0100 	ldr.w	r0, [r6, #256]	; 0x100
    fc6e:	f3c0 4307 	ubfx	r3, r0, #16, #8
    fc72:	2b03      	cmp	r3, #3
                bCmdCmp = IOMn(ui32Module)->INTSTAT_b.CMDCMP;
    fc74:	f002 0201 	and.w	r2, r2, #1
            while ((ui32FifoSiz = IOMn(ui32Module)->FIFOPTR_b.FIFO1SIZ) < 4)
    fc78:	d814      	bhi.n	fca4 <am_hal_iom_blocking_transfer+0x438>
                    if (bCmdCmp && (ui32Bytes > ui32FifoSiz))
    fc7a:	b112      	cbz	r2, fc82 <am_hal_iom_blocking_transfer+0x416>
    fc7c:	459b      	cmp	fp, r3
    fc7e:	f63f aefa 	bhi.w	fa76 <am_hal_iom_blocking_transfer+0x20a>
                    am_hal_flash_delay( FLASH_CYCLES_US(1) );
    fc82:	2001      	movs	r0, #1
    fc84:	f7fe fece 	bl	ea24 <am_hal_flash_delay>
                bCmdCmp = IOMn(ui32Module)->INTSTAT_b.CMDCMP;
    fc88:	f8d6 1204 	ldr.w	r1, [r6, #516]	; 0x204
            while ((ui32FifoSiz = IOMn(ui32Module)->FIFOPTR_b.FIFO1SIZ) < 4)
    fc8c:	f8d6 3100 	ldr.w	r3, [r6, #256]	; 0x100
    fc90:	f3c3 4307 	ubfx	r3, r3, #16, #8
    fc94:	2b03      	cmp	r3, #3
                bCmdCmp = IOMn(ui32Module)->INTSTAT_b.CMDCMP;
    fc96:	f001 0201 	and.w	r2, r1, #1
            while ((ui32FifoSiz = IOMn(ui32Module)->FIFOPTR_b.FIFO1SIZ) < 4)
    fc9a:	d803      	bhi.n	fca4 <am_hal_iom_blocking_transfer+0x438>
                if (numWait++ < AM_HAL_IOM_MAX_BLOCKING_WAIT)
    fc9c:	f1b9 0903 	subs.w	r9, r9, #3
    fca0:	d1b6      	bne.n	fc10 <am_hal_iom_blocking_transfer+0x3a4>
    fca2:	e6e8      	b.n	fa76 <am_hal_iom_blocking_transfer+0x20a>
                if (ui32Bytes >= 4)
    fca4:	f1bb 0f03 	cmp.w	fp, #3
                ui32Read = IOMn(ui32Module)->FIFOPOP;
    fca8:	f8d6 1108 	ldr.w	r1, [r6, #264]	; 0x108
                if (ui32Bytes >= 4)
    fcac:	d974      	bls.n	fd98 <am_hal_iom_blocking_transfer+0x52c>
                ui32FifoSiz -= 4;
    fcae:	f1a3 0e04 	sub.w	lr, r3, #4
                    *pui32Buffer++ = ui32Read;
    fcb2:	6039      	str	r1, [r7, #0]
            while ((ui32FifoSiz >= 4) && ui32Bytes)
    fcb4:	4671      	mov	r1, lr
    fcb6:	2903      	cmp	r1, #3
                    *pui32Buffer++ = ui32Read;
    fcb8:	f107 0704 	add.w	r7, r7, #4
                    ui32Bytes -= 4;
    fcbc:	f1ab 0004 	sub.w	r0, fp, #4
            while ((ui32FifoSiz >= 4) && ui32Bytes)
    fcc0:	d965      	bls.n	fd8e <am_hal_iom_blocking_transfer+0x522>
    fcc2:	f3c0 0881 	ubfx	r8, r0, #2, #2
    fcc6:	eba3 0b0b 	sub.w	fp, r3, fp
    fcca:	f1b8 0f00 	cmp.w	r8, #0
    fcce:	d026      	beq.n	fd1e <am_hal_iom_blocking_transfer+0x4b2>
                if (ui32Bytes >= 4)
    fcd0:	2803      	cmp	r0, #3
                ui32Read = IOMn(ui32Module)->FIFOPOP;
    fcd2:	f8d6 1108 	ldr.w	r1, [r6, #264]	; 0x108
                if (ui32Bytes >= 4)
    fcd6:	d960      	bls.n	fd9a <am_hal_iom_blocking_transfer+0x52e>
                    ui32Bytes -= 4;
    fcd8:	3804      	subs	r0, #4
            while ((ui32FifoSiz >= 4) && ui32Bytes)
    fcda:	eb00 030b 	add.w	r3, r0, fp
    fcde:	2b03      	cmp	r3, #3
                    *pui32Buffer++ = ui32Read;
    fce0:	f847 1b04 	str.w	r1, [r7], #4
            while ((ui32FifoSiz >= 4) && ui32Bytes)
    fce4:	d953      	bls.n	fd8e <am_hal_iom_blocking_transfer+0x522>
    fce6:	f1b8 0f01 	cmp.w	r8, #1
    fcea:	d018      	beq.n	fd1e <am_hal_iom_blocking_transfer+0x4b2>
    fcec:	f1b8 0f02 	cmp.w	r8, #2
    fcf0:	d00a      	beq.n	fd08 <am_hal_iom_blocking_transfer+0x49c>
                if (ui32Bytes >= 4)
    fcf2:	2803      	cmp	r0, #3
                ui32Read = IOMn(ui32Module)->FIFOPOP;
    fcf4:	f8d6 1108 	ldr.w	r1, [r6, #264]	; 0x108
                if (ui32Bytes >= 4)
    fcf8:	d94f      	bls.n	fd9a <am_hal_iom_blocking_transfer+0x52e>
                    ui32Bytes -= 4;
    fcfa:	3804      	subs	r0, #4
            while ((ui32FifoSiz >= 4) && ui32Bytes)
    fcfc:	eb00 030b 	add.w	r3, r0, fp
    fd00:	2b03      	cmp	r3, #3
                    *pui32Buffer++ = ui32Read;
    fd02:	f847 1b04 	str.w	r1, [r7], #4
            while ((ui32FifoSiz >= 4) && ui32Bytes)
    fd06:	d942      	bls.n	fd8e <am_hal_iom_blocking_transfer+0x522>
                if (ui32Bytes >= 4)
    fd08:	2803      	cmp	r0, #3
                ui32Read = IOMn(ui32Module)->FIFOPOP;
    fd0a:	f8d6 1108 	ldr.w	r1, [r6, #264]	; 0x108
                if (ui32Bytes >= 4)
    fd0e:	d944      	bls.n	fd9a <am_hal_iom_blocking_transfer+0x52e>
                    ui32Bytes -= 4;
    fd10:	3804      	subs	r0, #4
            while ((ui32FifoSiz >= 4) && ui32Bytes)
    fd12:	eb00 030b 	add.w	r3, r0, fp
    fd16:	2b03      	cmp	r3, #3
                    *pui32Buffer++ = ui32Read;
    fd18:	f847 1b04 	str.w	r1, [r7], #4
            while ((ui32FifoSiz >= 4) && ui32Bytes)
    fd1c:	d937      	bls.n	fd8e <am_hal_iom_blocking_transfer+0x522>
    fd1e:	2800      	cmp	r0, #0
    fd20:	f43f aeaa 	beq.w	fa78 <am_hal_iom_blocking_transfer+0x20c>
                if (ui32Bytes >= 4)
    fd24:	2803      	cmp	r0, #3
                ui32Read = IOMn(ui32Module)->FIFOPOP;
    fd26:	f8d6 1108 	ldr.w	r1, [r6, #264]	; 0x108
                if (ui32Bytes >= 4)
    fd2a:	d936      	bls.n	fd9a <am_hal_iom_blocking_transfer+0x52e>
                    ui32Bytes -= 4;
    fd2c:	3804      	subs	r0, #4
                    *pui32Buffer++ = ui32Read;
    fd2e:	3704      	adds	r7, #4
            while ((ui32FifoSiz >= 4) && ui32Bytes)
    fd30:	eb00 030b 	add.w	r3, r0, fp
    fd34:	2b03      	cmp	r3, #3
                    *pui32Buffer++ = ui32Read;
    fd36:	f847 1c04 	str.w	r1, [r7, #-4]
    fd3a:	46bc      	mov	ip, r7
                    ui32Bytes -= 4;
    fd3c:	4682      	mov	sl, r0
            while ((ui32FifoSiz >= 4) && ui32Bytes)
    fd3e:	d926      	bls.n	fd8e <am_hal_iom_blocking_transfer+0x522>
                if (ui32Bytes >= 4)
    fd40:	2803      	cmp	r0, #3
                ui32Read = IOMn(ui32Module)->FIFOPOP;
    fd42:	f8d6 1108 	ldr.w	r1, [r6, #264]	; 0x108
                if (ui32Bytes >= 4)
    fd46:	d928      	bls.n	fd9a <am_hal_iom_blocking_transfer+0x52e>
                    ui32Bytes -= 4;
    fd48:	3804      	subs	r0, #4
            while ((ui32FifoSiz >= 4) && ui32Bytes)
    fd4a:	eb00 030b 	add.w	r3, r0, fp
    fd4e:	2b03      	cmp	r3, #3
                    *pui32Buffer++ = ui32Read;
    fd50:	f847 1b04 	str.w	r1, [r7], #4
            while ((ui32FifoSiz >= 4) && ui32Bytes)
    fd54:	d91b      	bls.n	fd8e <am_hal_iom_blocking_transfer+0x522>
                if (ui32Bytes >= 4)
    fd56:	2803      	cmp	r0, #3
                ui32Read = IOMn(ui32Module)->FIFOPOP;
    fd58:	f8d6 1108 	ldr.w	r1, [r6, #264]	; 0x108
                if (ui32Bytes >= 4)
    fd5c:	d91d      	bls.n	fd9a <am_hal_iom_blocking_transfer+0x52e>
                    ui32Bytes -= 4;
    fd5e:	f1aa 0008 	sub.w	r0, sl, #8
                    *pui32Buffer++ = ui32Read;
    fd62:	f10c 0708 	add.w	r7, ip, #8
            while ((ui32FifoSiz >= 4) && ui32Bytes)
    fd66:	eb00 030b 	add.w	r3, r0, fp
    fd6a:	2b03      	cmp	r3, #3
                    *pui32Buffer++ = ui32Read;
    fd6c:	f847 1c04 	str.w	r1, [r7, #-4]
            while ((ui32FifoSiz >= 4) && ui32Bytes)
    fd70:	d90d      	bls.n	fd8e <am_hal_iom_blocking_transfer+0x522>
                if (ui32Bytes >= 4)
    fd72:	2803      	cmp	r0, #3
                ui32Read = IOMn(ui32Module)->FIFOPOP;
    fd74:	f8d6 1108 	ldr.w	r1, [r6, #264]	; 0x108
                if (ui32Bytes >= 4)
    fd78:	d90f      	bls.n	fd9a <am_hal_iom_blocking_transfer+0x52e>
                    ui32Bytes -= 4;
    fd7a:	f1aa 000c 	sub.w	r0, sl, #12
                    *pui32Buffer++ = ui32Read;
    fd7e:	f10c 070c 	add.w	r7, ip, #12
            while ((ui32FifoSiz >= 4) && ui32Bytes)
    fd82:	eb00 030b 	add.w	r3, r0, fp
    fd86:	2b03      	cmp	r3, #3
                    *pui32Buffer++ = ui32Read;
    fd88:	f847 1c04 	str.w	r1, [r7, #-4]
            while ((ui32FifoSiz >= 4) && ui32Bytes)
    fd8c:	d8c7      	bhi.n	fd1e <am_hal_iom_blocking_transfer+0x4b2>
                    ui32Bytes -= 4;
    fd8e:	4683      	mov	fp, r0
        while ( ui32Bytes )
    fd90:	2800      	cmp	r0, #0
    fd92:	f47f af35 	bne.w	fc00 <am_hal_iom_blocking_transfer+0x394>
    fd96:	e66f      	b.n	fa78 <am_hal_iom_blocking_transfer+0x20c>
                if (ui32Bytes >= 4)
    fd98:	4658      	mov	r0, fp
                    } while (--ui32Bytes);
    fd9a:	2801      	cmp	r0, #1
                        *pui8Buffer++ = ui32Read & 0xFF;
    fd9c:	7039      	strb	r1, [r7, #0]
                        ui32Read >>= 8;
    fd9e:	ea4f 2211 	mov.w	r2, r1, lsr #8
                    } while (--ui32Bytes);
    fda2:	f43f ae69 	beq.w	fa78 <am_hal_iom_blocking_transfer+0x20c>
    fda6:	2802      	cmp	r0, #2
                        *pui8Buffer++ = ui32Read & 0xFF;
    fda8:	707a      	strb	r2, [r7, #1]
                        ui32Read >>= 8;
    fdaa:	ea4f 4311 	mov.w	r3, r1, lsr #16
                    } while (--ui32Bytes);
    fdae:	f43f ae63 	beq.w	fa78 <am_hal_iom_blocking_transfer+0x20c>
                        *pui8Buffer++ = ui32Read & 0xFF;
    fdb2:	70bb      	strb	r3, [r7, #2]
    fdb4:	e660      	b.n	fa78 <am_hal_iom_blocking_transfer+0x20c>
        ui32Status = AM_HAL_IOM_ERR_INVALID_OPER;
    fdb6:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
    fdba:	e677      	b.n	faac <am_hal_iom_blocking_transfer+0x240>
        ui32Status = AM_HAL_IOM_ERR_I2C_ARB;
    fdbc:	4a01      	ldr	r2, [pc, #4]	; (fdc4 <am_hal_iom_blocking_transfer+0x558>)
    fdbe:	e675      	b.n	faac <am_hal_iom_blocking_transfer+0x240>
        ui32Status = AM_HAL_IOM_ERR_I2C_NAK;
    fdc0:	4a01      	ldr	r2, [pc, #4]	; (fdc8 <am_hal_iom_blocking_transfer+0x55c>)
    fdc2:	e673      	b.n	faac <am_hal_iom_blocking_transfer+0x240>
    fdc4:	08000001 	.word	0x08000001
    fdc8:	08000002 	.word	0x08000002
    fdcc:	0007a120 	.word	0x0007a120

0000fdd0 <am_hal_iom_nonblocking_transfer>:
uint32_t
am_hal_iom_nonblocking_transfer(void *pHandle,
                                am_hal_iom_transfer_t *psTransaction,
                                am_hal_iom_callback_t pfnCallback,
                                void *pCallbackCtxt)
{
    fdd0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    fdd4:	b087      	sub	sp, #28
    uint32_t ui32Module;
    uint32_t ui32Status = AM_HAL_STATUS_SUCCESS;
    uint32_t ui32NumPend;

#ifndef AM_HAL_DISABLE_API_VALIDATION
    if (!AM_HAL_IOM_CHK_HANDLE(pHandle))
    fdd6:	b128      	cbz	r0, fde4 <am_hal_iom_nonblocking_transfer+0x14>
    fdd8:	6805      	ldr	r5, [r0, #0]
    fdda:	4c83      	ldr	r4, [pc, #524]	; (ffe8 <am_hal_iom_nonblocking_transfer+0x218>)
    fddc:	f025 4e7e 	bic.w	lr, r5, #4261412864	; 0xfe000000
    fde0:	45a6      	cmp	lr, r4
    fde2:	d004      	beq.n	fdee <am_hal_iom_nonblocking_transfer+0x1e>
    {
        return AM_HAL_STATUS_INVALID_HANDLE;
    fde4:	2502      	movs	r5, #2
    //
    // Return the status.
    //
    return ui32Status;

} // am_hal_iom_nonblocking_transfer()
    fde6:	4628      	mov	r0, r5
    fde8:	b007      	add	sp, #28
    fdea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (!psTransaction)
    fdee:	b111      	cbz	r1, fdf6 <am_hal_iom_nonblocking_transfer+0x26>
    ui32OffsetCnt = psTransaction->ui32InstrLen;
    fdf0:	684e      	ldr	r6, [r1, #4]
    if ( (ui32OffsetCnt > AM_HAL_IOM_MAX_OFFSETSIZE)                            ||
    fdf2:	2e03      	cmp	r6, #3
    fdf4:	d904      	bls.n	fe00 <am_hal_iom_nonblocking_transfer+0x30>
          ((psTransaction->uPeerInfo.ui32SpiChipSelect > AM_HAL_IOM_MAX_CS_SPI) ||
    fdf6:	2506      	movs	r5, #6
} // am_hal_iom_nonblocking_transfer()
    fdf8:	4628      	mov	r0, r5
    fdfa:	b007      	add	sp, #28
    fdfc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
         (ui32Offset & (0xFFFFFFFF << (ui32OffsetCnt*8)))                       ||
    fe00:	00f7      	lsls	r7, r6, #3
    fe02:	f04f 34ff 	mov.w	r4, #4294967295
    fe06:	688d      	ldr	r5, [r1, #8]
    fe08:	fa04 f607 	lsl.w	r6, r4, r7
    if ( (ui32OffsetCnt > AM_HAL_IOM_MAX_OFFSETSIZE)                            ||
    fe0c:	ea16 0805 	ands.w	r8, r6, r5
    fe10:	d1f1      	bne.n	fdf6 <am_hal_iom_nonblocking_transfer+0x26>
    ui32Bytes = psTransaction->ui32NumBytes;
    fe12:	68cf      	ldr	r7, [r1, #12]
    ui32Dir = psTransaction->eDirection;
    fe14:	7c0c      	ldrb	r4, [r1, #16]
         (ui32Offset & (0xFFFFFFFF << (ui32OffsetCnt*8)))                       ||
    fe16:	b377      	cbz	r7, fe76 <am_hal_iom_nonblocking_transfer+0xa6>
         (ui32Bytes && (ui32Dir != AM_HAL_IOM_TX) && (psTransaction->pui32RxBuffer == NULL)) ||
    fe18:	b38c      	cbz	r4, fe7e <am_hal_iom_nonblocking_transfer+0xae>
    fe1a:	698e      	ldr	r6, [r1, #24]
    fe1c:	2e00      	cmp	r6, #0
    fe1e:	d0ea      	beq.n	fdf6 <am_hal_iom_nonblocking_transfer+0x26>
         (ui32Bytes && (ui32Dir != AM_HAL_IOM_RX) && (psTransaction->pui32TxBuffer == NULL)) ||
    fe20:	2c01      	cmp	r4, #1
    fe22:	d12c      	bne.n	fe7e <am_hal_iom_nonblocking_transfer+0xae>
         ((pIOMState->eInterfaceMode == AM_HAL_IOM_I2C_MODE) &&
    fe24:	7a05      	ldrb	r5, [r0, #8]
         (ui32Bytes && (ui32Dir != AM_HAL_IOM_RX) && (psTransaction->pui32TxBuffer == NULL)) ||
    fe26:	2d01      	cmp	r5, #1
    fe28:	d00a      	beq.n	fe40 <am_hal_iom_nonblocking_transfer+0x70>
          (psTransaction->ui32NumBytes > AM_HAL_IOM_MAX_TXNSIZE_I2C))           ||
    fe2a:	b92d      	cbnz	r5, fe38 <am_hal_iom_nonblocking_transfer+0x68>
         ((pIOMState->eInterfaceMode == AM_HAL_IOM_SPI_MODE) &&
    fe2c:	680e      	ldr	r6, [r1, #0]
    fe2e:	2e03      	cmp	r6, #3
    fe30:	d8e1      	bhi.n	fdf6 <am_hal_iom_nonblocking_transfer+0x26>
          ((psTransaction->uPeerInfo.ui32SpiChipSelect > AM_HAL_IOM_MAX_CS_SPI) ||
    fe32:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
    fe36:	d2de      	bcs.n	fdf6 <am_hal_iom_nonblocking_transfer+0x26>
    if (psTransaction->eDirection > AM_HAL_IOM_RX)
    fe38:	2c01      	cmp	r4, #1
    fe3a:	d904      	bls.n	fe46 <am_hal_iom_nonblocking_transfer+0x76>
        return AM_HAL_STATUS_INVALID_OPERATION;
    fe3c:	2507      	movs	r5, #7
    fe3e:	e7d2      	b.n	fde6 <am_hal_iom_nonblocking_transfer+0x16>
         ((pIOMState->eInterfaceMode == AM_HAL_IOM_I2C_MODE) &&
    fe40:	2fff      	cmp	r7, #255	; 0xff
    fe42:	d8d8      	bhi.n	fdf6 <am_hal_iom_nonblocking_transfer+0x26>
    fe44:	e7f8      	b.n	fe38 <am_hal_iom_nonblocking_transfer+0x68>
    if (!pIOMState->pCmdQHdl)
    fe46:	f8d0 e828 	ldr.w	lr, [r0, #2088]	; 0x828
    fe4a:	f1be 0f00 	cmp.w	lr, #0
    fe4e:	d0f5      	beq.n	fe3c <am_hal_iom_nonblocking_transfer+0x6c>
    if ((pIOMState->ui32NumPendTransactions == AM_HAL_IOM_MAX_PENDING_TRANSACTIONS) ||
    fe50:	6a47      	ldr	r7, [r0, #36]	; 0x24
    fe52:	f5b7 7f80 	cmp.w	r7, #256	; 0x100
    fe56:	d00c      	beq.n	fe72 <am_hal_iom_nonblocking_transfer+0xa2>
    fe58:	4604      	mov	r4, r0
    fe5a:	9300      	str	r3, [sp, #0]
    fe5c:	4616      	mov	r6, r2
    fe5e:	460d      	mov	r5, r1
        (am_hal_cmdq_alloc_block(pIOMState->pCmdQHdl, sizeof(am_hal_iom_txn_cmdlist_t) / 8, &pCQBlock, &index)))
    fe60:	4670      	mov	r0, lr
    fe62:	ab05      	add	r3, sp, #20
    fe64:	aa04      	add	r2, sp, #16
    fe66:	210b      	movs	r1, #11
    ui32Module = pIOMState->ui32Module;
    fe68:	f8d4 9004 	ldr.w	r9, [r4, #4]
        (am_hal_cmdq_alloc_block(pIOMState->pCmdQHdl, sizeof(am_hal_iom_txn_cmdlist_t) / 8, &pCQBlock, &index)))
    fe6c:	f000 fbc4 	bl	105f8 <am_hal_cmdq_alloc_block>
    if ((pIOMState->ui32NumPendTransactions == AM_HAL_IOM_MAX_PENDING_TRANSACTIONS) ||
    fe70:	b148      	cbz	r0, fe86 <am_hal_iom_nonblocking_transfer+0xb6>
        return AM_HAL_STATUS_OUT_OF_RANGE;
    fe72:	2505      	movs	r5, #5
    fe74:	e7b7      	b.n	fde6 <am_hal_iom_nonblocking_transfer+0x16>
         ((pIOMState->eInterfaceMode == AM_HAL_IOM_I2C_MODE) &&
    fe76:	7a05      	ldrb	r5, [r0, #8]
         (ui32Bytes && (ui32Dir != AM_HAL_IOM_RX) && (psTransaction->pui32TxBuffer == NULL)) ||
    fe78:	2d01      	cmp	r5, #1
    fe7a:	d1d6      	bne.n	fe2a <am_hal_iom_nonblocking_transfer+0x5a>
    fe7c:	e7dc      	b.n	fe38 <am_hal_iom_nonblocking_transfer+0x68>
    fe7e:	694d      	ldr	r5, [r1, #20]
    fe80:	2d00      	cmp	r5, #0
    fe82:	d1cf      	bne.n	fe24 <am_hal_iom_nonblocking_transfer+0x54>
    fe84:	e7b7      	b.n	fdf6 <am_hal_iom_nonblocking_transfer+0x26>
    pCQEntry->ui32OFFSETHIAddr  = (uint32_t)&IOMn(ui32Module)->OFFSETHI;
    fe86:	6862      	ldr	r2, [r4, #4]
    pCQEntry->ui32OFFSETHIVal   = (uint16_t)(psTransaction->ui32Instr >> 8);
    fe88:	f8d5 e008 	ldr.w	lr, [r5, #8]
    uint32_t                ui32Dir = psTransaction->eDirection;
    fe8c:	7c29      	ldrb	r1, [r5, #16]
    pCQEntry = (am_hal_iom_txn_cmdlist_t *)pCQBlock;
    fe8e:	9b04      	ldr	r3, [sp, #16]
    uint32_t                ui32Dir = psTransaction->eDirection;
    fe90:	9101      	str	r1, [sp, #4]
    pCQEntry->ui32OFFSETHIAddr  = (uint32_t)&IOMn(ui32Module)->OFFSETHI;
    fe92:	f502 27a0 	add.w	r7, r2, #327680	; 0x50000
    fe96:	3704      	adds	r7, #4
    fe98:	033a      	lsls	r2, r7, #12
    fe9a:	f502 7b08 	add.w	fp, r2, #544	; 0x220
    pCQEntry->ui32OFFSETHIVal   = (uint16_t)(psTransaction->ui32Instr >> 8);
    fe9e:	f3ce 2a0f 	ubfx	sl, lr, #8, #16
    pCQEntry->ui32DEVCFGAddr    = (uint32_t)&IOMn(ui32Module)->DEVCFG;
    fea2:	f202 4104 	addw	r1, r2, #1028	; 0x404
    pCQEntry->ui32DMATOTCOUNTVal  = (1 + psTransaction->ui8RepeatCount) * psTransaction->ui32NumBytes;
    fea6:	f8d5 c00c 	ldr.w	ip, [r5, #12]
    pCQEntry->ui32OFFSETHIVal   = (uint16_t)(psTransaction->ui32Instr >> 8);
    feaa:	f8c3 a00c 	str.w	sl, [r3, #12]
    pCQEntry->ui32DEVCFGAddr    = (uint32_t)&IOMn(ui32Module)->DEVCFG;
    feae:	6119      	str	r1, [r3, #16]
    pCQEntry->ui32OFFSETHIAddr  = (uint32_t)&IOMn(ui32Module)->OFFSETHI;
    feb0:	f8c3 b008 	str.w	fp, [r3, #8]
    pCQEntry->ui32DEVCFGVal     = _VAL2FLD(IOM0_DEVCFG_DEVADDR, psTransaction->uPeerInfo.ui32I2CDevAddr);
    feb4:	f8d5 b000 	ldr.w	fp, [r5]
    pCQEntry->ui32DMACFGdis1Val    = 0x0;
    feb8:	61d8      	str	r0, [r3, #28]
    pCQEntry->ui32DMACFGdis1Addr   = (uint32_t)&IOMn(ui32Module)->DMACFG;
    feba:	f502 7720 	add.w	r7, r2, #640	; 0x280
    pCQEntry->ui32DEVCFGVal     = _VAL2FLD(IOM0_DEVCFG_DEVADDR, psTransaction->uPeerInfo.ui32I2CDevAddr);
    febe:	f3cb 0a09 	ubfx	sl, fp, #0, #10
    pCQEntry->ui32DMATOTCOUNTAddr = (uint32_t)&IOMn(ui32Module)->DMATOTCOUNT;
    fec2:	f502 7122 	add.w	r1, r2, #648	; 0x288
    pCQEntry->ui32DEVCFGVal     = _VAL2FLD(IOM0_DEVCFG_DEVADDR, psTransaction->uPeerInfo.ui32I2CDevAddr);
    fec6:	f8c3 a014 	str.w	sl, [r3, #20]
    pCQEntry->ui32DMACFGdis1Addr   = (uint32_t)&IOMn(ui32Module)->DMACFG;
    feca:	619f      	str	r7, [r3, #24]
    pCQEntry->ui32DMATOTCOUNTAddr = (uint32_t)&IOMn(ui32Module)->DMATOTCOUNT;
    fecc:	6219      	str	r1, [r3, #32]
    pCQEntry->ui32DMATOTCOUNTVal  = (1 + psTransaction->ui8RepeatCount) * psTransaction->ui32NumBytes;
    fece:	7f69      	ldrb	r1, [r5, #29]
    fed0:	9103      	str	r1, [sp, #12]
    fed2:	fb01 ca0c 	mla	sl, r1, ip, ip
    ui32SRAMAddress = (ui32Dir == AM_HAL_IOM_TX) ? (uint32_t)psTransaction->pui32TxBuffer : (uint32_t)psTransaction->pui32RxBuffer;
    fed6:	9901      	ldr	r1, [sp, #4]
    pCQEntry->ui32DMACFGdis1Addr   = (uint32_t)&IOMn(ui32Module)->DMACFG;
    fed8:	9702      	str	r7, [sp, #8]
    pCQEntry->ui32DMATARGADDRAddr = (uint32_t)&IOMn(ui32Module)->DMATARGADDR;
    feda:	f502 7723 	add.w	r7, r2, #652	; 0x28c
    pCQEntry->ui32DMATOTCOUNTVal  = (1 + psTransaction->ui8RepeatCount) * psTransaction->ui32NumBytes;
    fede:	f8c3 a024 	str.w	sl, [r3, #36]	; 0x24
    pCQEntry->ui32DMATARGADDRAddr = (uint32_t)&IOMn(ui32Module)->DMATARGADDR;
    fee2:	629f      	str	r7, [r3, #40]	; 0x28
    ui32SRAMAddress = (ui32Dir == AM_HAL_IOM_TX) ? (uint32_t)psTransaction->pui32TxBuffer : (uint32_t)psTransaction->pui32RxBuffer;
    fee4:	2900      	cmp	r1, #0
    fee6:	d177      	bne.n	ffd8 <am_hal_iom_nonblocking_transfer+0x208>
        _VAL2FLD(IOM0_DMACFG_DMAPRI, psTransaction->ui8Priority)     |
    fee8:	7fa8      	ldrb	r0, [r5, #30]
    ui32SRAMAddress = (ui32Dir == AM_HAL_IOM_TX) ? (uint32_t)psTransaction->pui32TxBuffer : (uint32_t)psTransaction->pui32RxBuffer;
    feea:	f8d5 a014 	ldr.w	sl, [r5, #20]
        _VAL2FLD(IOM0_DMACFG_DMAPRI, psTransaction->ui8Priority)     |
    feee:	0207      	lsls	r7, r0, #8
    fef0:	f407 7180 	and.w	r1, r7, #256	; 0x100
        _VAL2FLD(IOM0_DMACFG_DMADIR, ui32Dir == AM_HAL_IOM_TX ? 1 : 0);
    fef4:	2002      	movs	r0, #2
    fef6:	9f02      	ldr	r7, [sp, #8]
    fef8:	631f      	str	r7, [r3, #48]	; 0x30
    fefa:	f8c3 a02c 	str.w	sl, [r3, #44]	; 0x2c
        _VAL2FLD(IOM0_DMACFG_DMAPRI, psTransaction->ui8Priority)     |
    fefe:	4301      	orrs	r1, r0
    if (psTransaction->ui32NumBytes)
    ff00:	f1bc 0f00 	cmp.w	ip, #0
    ff04:	d001      	beq.n	ff0a <am_hal_iom_nonblocking_transfer+0x13a>
        pCQEntry->ui32DMACFGVal |= IOM0_DMACFG_DMAEN_Msk;
    ff06:	f041 0101 	orr.w	r1, r1, #1
              psTransaction->uPeerInfo.ui32SpiChipSelect : 0;
    ff0a:	7a20      	ldrb	r0, [r4, #8]
    pCQEntry->ui32CMDRPTVal = psTransaction->ui8RepeatCount;
    ff0c:	9f03      	ldr	r7, [sp, #12]
    ff0e:	63df      	str	r7, [r3, #60]	; 0x3c
              psTransaction->uPeerInfo.ui32SpiChipSelect : 0;
    ff10:	2800      	cmp	r0, #0
    ff12:	bf14      	ite	ne
    ff14:	4647      	movne	r7, r8
    ff16:	465f      	moveq	r7, fp
    ui32Cmd |= _VAL2FLD(IOM0_CMD_TSIZE, ui32nBytes);
    ff18:	f8df 80d0 	ldr.w	r8, [pc, #208]	; ffec <am_hal_iom_nonblocking_transfer+0x21c>
    ui32Cmd = build_cmd(ui32Cmd,                            // ChipSelect
    ff1c:	f895 b01c 	ldrb.w	fp, [r5, #28]
        pCQEntry->ui32DMACFGVal |= IOM0_DMACFG_DMAEN_Msk;
    ff20:	6359      	str	r1, [r3, #52]	; 0x34
    ui32Cmd = build_cmd(ui32Cmd,                            // ChipSelect
    ff22:	6869      	ldr	r1, [r5, #4]
    ui32Cmd |= _VAL2FLD(IOM0_CMD_CMDSEL, ui32CS);
    ff24:	053d      	lsls	r5, r7, #20
    ff26:	f405 1040 	and.w	r0, r5, #3145728	; 0x300000
    ui32Cmd |= _VAL2FLD(IOM0_CMD_TSIZE, ui32nBytes);
    ff2a:	ea08 270c 	and.w	r7, r8, ip, lsl #8
    ff2e:	ea40 0507 	orr.w	r5, r0, r7
    ui32Cmd |= _VAL2FLD(IOM0_CMD_OFFSETCNT, ui32OffsetCnt);
    ff32:	0149      	lsls	r1, r1, #5
    if (ui32Dir == AM_HAL_IOM_RX)
    ff34:	9801      	ldr	r0, [sp, #4]
    ui32Cmd |= _VAL2FLD(IOM0_CMD_OFFSETCNT, ui32OffsetCnt);
    ff36:	f001 0760 	and.w	r7, r1, #96	; 0x60
    if (ui32Dir == AM_HAL_IOM_RX)
    ff3a:	2801      	cmp	r0, #1
    ui32Cmd |= _VAL2FLD(IOM0_CMD_OFFSETCNT, ui32OffsetCnt);
    ff3c:	ea47 1acb 	orr.w	sl, r7, fp, lsl #7
    pIOMState->pfnCallback[index & (AM_HAL_IOM_MAX_PENDING_TRANSACTIONS - 1)] = pfnCallback;
    ff40:	f89d 0014 	ldrb.w	r0, [sp, #20]
        ui32Cmd |= _VAL2FLD(IOM0_CMD_CMD, IOM0_CMD_CMD_READ);
    ff44:	bf0c      	ite	eq
    ff46:	f045 0502 	orreq.w	r5, r5, #2
        ui32Cmd |= _VAL2FLD(IOM0_CMD_CMD, IOM0_CMD_CMD_WRITE);
    ff4a:	f045 0501 	orrne.w	r5, r5, #1
    ui32Cmd |= _VAL2FLD(IOM0_CMD_OFFSETCNT, ui32OffsetCnt);
    ff4e:	ea4a 610e 	orr.w	r1, sl, lr, lsl #24
    pCQEntry->ui32CMDRPTAddr = (uint32_t)&IOMn(ui32Module)->CMDRPT;
    ff52:	f502 7c07 	add.w	ip, r2, #540	; 0x21c
    ff56:	eb04 0e80 	add.w	lr, r4, r0, lsl #2
    ui32Cmd |= _VAL2FLD(IOM0_CMD_OFFSETCNT, ui32OffsetCnt);
    ff5a:	4329      	orrs	r1, r5
    pCQEntry->ui32CMDAddr  = (uint32_t)&IOMn(ui32Module)->CMD;
    ff5c:	f502 7206 	add.w	r2, r2, #536	; 0x218
    pCQEntry->ui32CMDRPTAddr = (uint32_t)&IOMn(ui32Module)->CMDRPT;
    ff60:	f8c3 c038 	str.w	ip, [r3, #56]	; 0x38
    pCQEntry->ui32CMDVal   = ui32Cmd;
    ff64:	6459      	str	r1, [r3, #68]	; 0x44
    pCQEntry->ui32CMDAddr  = (uint32_t)&IOMn(ui32Module)->CMD;
    ff66:	641a      	str	r2, [r3, #64]	; 0x40
    pIOMState->pCallbackCtxt[index & (AM_HAL_IOM_MAX_PENDING_TRANSACTIONS - 1)] = pCallbackCtxt;
    ff68:	9b00      	ldr	r3, [sp, #0]
    pIOMState->pfnCallback[index & (AM_HAL_IOM_MAX_PENDING_TRANSACTIONS - 1)] = pfnCallback;
    ff6a:	f8ce 6028 	str.w	r6, [lr, #40]	; 0x28
    pIOMState->pCallbackCtxt[index & (AM_HAL_IOM_MAX_PENDING_TRANSACTIONS - 1)] = pCallbackCtxt;
    ff6e:	f8ce 3428 	str.w	r3, [lr, #1064]	; 0x428
        ui32Critical = am_hal_interrupt_master_disable();
    ff72:	f7ff f811 	bl	ef98 <am_hal_interrupt_master_disable>
        ui32Status = am_hal_cmdq_post_block(pIOMState->pCmdQHdl, pfnCallback);
    ff76:	1c31      	adds	r1, r6, #0
        ui32Critical = am_hal_interrupt_master_disable();
    ff78:	4680      	mov	r8, r0
        ui32Status = am_hal_cmdq_post_block(pIOMState->pCmdQHdl, pfnCallback);
    ff7a:	bf18      	it	ne
    ff7c:	2101      	movne	r1, #1
    ff7e:	f8d4 0828 	ldr.w	r0, [r4, #2088]	; 0x828
    ff82:	f000 fbb1 	bl	106e8 <am_hal_cmdq_post_block>
        if (ui32Status == AM_HAL_STATUS_SUCCESS)
    ff86:	4605      	mov	r5, r0
    ff88:	b9f0      	cbnz	r0, ffc8 <am_hal_iom_nonblocking_transfer+0x1f8>
            ui32NumPend = pIOMState->ui32NumPendTransactions++;
    ff8a:	6a66      	ldr	r6, [r4, #36]	; 0x24
    ff8c:	1c77      	adds	r7, r6, #1
            am_hal_interrupt_master_set(ui32Critical);
    ff8e:	4640      	mov	r0, r8
            ui32NumPend = pIOMState->ui32NumPendTransactions++;
    ff90:	6267      	str	r7, [r4, #36]	; 0x24
            am_hal_interrupt_master_set(ui32Critical);
    ff92:	f7ff f805 	bl	efa0 <am_hal_interrupt_master_set>
            if (0 == ui32NumPend)
    ff96:	2e00      	cmp	r6, #0
    ff98:	f47f af25 	bne.w	fde6 <am_hal_iom_nonblocking_transfer+0x16>
                pIOMState->ui32UserIntCfg = IOMn(ui32Module)->INTEN;
    ff9c:	f509 20a0 	add.w	r0, r9, #327680	; 0x50000
    ffa0:	3004      	adds	r0, #4
    ffa2:	0303      	lsls	r3, r0, #12
                IOMn(ui32Module)->INTCLR = AM_HAL_IOM_INT_ALL;
    ffa4:	f04f 31ff 	mov.w	r1, #4294967295
                pIOMState->ui32UserIntCfg = IOMn(ui32Module)->INTEN;
    ffa8:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    ffac:	6162      	str	r2, [r4, #20]
                IOMn(ui32Module)->INTEN =
    ffae:	f646 267c 	movw	r6, #27260	; 0x6a7c
                IOMn(ui32Module)->INTEN = 0;
    ffb2:	f8c3 5200 	str.w	r5, [r3, #512]	; 0x200
                IOMn(ui32Module)->INTCLR = AM_HAL_IOM_INT_ALL;
    ffb6:	f8c3 1208 	str.w	r1, [r3, #520]	; 0x208
                IOMn(ui32Module)->INTEN =
    ffba:	f8c3 6200 	str.w	r6, [r3, #512]	; 0x200
    return am_hal_cmdq_enable(pIOMState->pCmdQHdl);
    ffbe:	f8d4 0828 	ldr.w	r0, [r4, #2088]	; 0x828
    ffc2:	f000 fadf 	bl	10584 <am_hal_cmdq_enable>
    ffc6:	e70e      	b.n	fde6 <am_hal_iom_nonblocking_transfer+0x16>
            am_hal_interrupt_master_set(ui32Critical);
    ffc8:	4640      	mov	r0, r8
    ffca:	f7fe ffe9 	bl	efa0 <am_hal_interrupt_master_set>
            am_hal_cmdq_release_block(pIOMState->pCmdQHdl);
    ffce:	f8d4 0828 	ldr.w	r0, [r4, #2088]	; 0x828
    ffd2:	f000 fb71 	bl	106b8 <am_hal_cmdq_release_block>
    ffd6:	e706      	b.n	fde6 <am_hal_iom_nonblocking_transfer+0x16>
        _VAL2FLD(IOM0_DMACFG_DMAPRI, psTransaction->ui8Priority)     |
    ffd8:	7faf      	ldrb	r7, [r5, #30]
    ui32SRAMAddress = (ui32Dir == AM_HAL_IOM_TX) ? (uint32_t)psTransaction->pui32TxBuffer : (uint32_t)psTransaction->pui32RxBuffer;
    ffda:	f8d5 a018 	ldr.w	sl, [r5, #24]
        _VAL2FLD(IOM0_DMACFG_DMAPRI, psTransaction->ui8Priority)     |
    ffde:	0239      	lsls	r1, r7, #8
    ffe0:	f401 7180 	and.w	r1, r1, #256	; 0x100
    ffe4:	e787      	b.n	fef6 <am_hal_iom_nonblocking_transfer+0x126>
    ffe6:	bf00      	nop
    ffe8:	01123456 	.word	0x01123456
    ffec:	000fff00 	.word	0x000fff00

0000fff0 <am_hal_itm_enable>:
#if AM_CMSIS_REGS
    //
    // To be able to access ITM registers, set the Trace Enable bit
    // in the Debug Exception and Monitor Control Register (DEMCR).
    //
    CoreDebug->DEMCR |= _VAL2FLD(CoreDebug_DEMCR_TRCENA, 1);
    fff0:	4a0b      	ldr	r2, [pc, #44]	; (10020 <am_hal_itm_enable+0x30>)
    fff2:	68d3      	ldr	r3, [r2, #12]
    fff4:	f043 7080 	orr.w	r0, r3, #16777216	; 0x1000000
    fff8:	60d0      	str	r0, [r2, #12]
    while ( !(CoreDebug->DEMCR & _VAL2FLD(CoreDebug_DEMCR_TRCENA, 1)) );
    fffa:	68d1      	ldr	r1, [r2, #12]
    fffc:	01cb      	lsls	r3, r1, #7
    fffe:	d5fc      	bpl.n	fffa <am_hal_itm_enable+0xa>

    //
    // Write the key to the ITM Lock Access register to unlock the ITM_TCR.
    //
    ITM->LAR = ITM_LAR_KEYVAL;
   10000:	f04f 4c60 	mov.w	ip, #3758096384	; 0xe0000000
   10004:	4b07      	ldr	r3, [pc, #28]	; (10024 <am_hal_itm_enable+0x34>)
    ITM->TER = 0xFFFFFFFF;

    //
    // Write to the ITM control and status register.
    //
    ITM->TCR =
   10006:	4a08      	ldr	r2, [pc, #32]	; (10028 <am_hal_itm_enable+0x38>)
    ITM->LAR = ITM_LAR_KEYVAL;
   10008:	f8cc 3fb0 	str.w	r3, [ip, #4016]	; 0xfb0
    ITM->TPR = 0x0000000F;
   1000c:	200f      	movs	r0, #15
    ITM->TER = 0xFFFFFFFF;
   1000e:	f04f 31ff 	mov.w	r1, #4294967295
    ITM->TPR = 0x0000000F;
   10012:	f8cc 0e40 	str.w	r0, [ip, #3648]	; 0xe40
    ITM->TER = 0xFFFFFFFF;
   10016:	f8cc 1e00 	str.w	r1, [ip, #3584]	; 0xe00
    ITM->TCR =
   1001a:	f8cc 2e80 	str.w	r2, [ip, #3712]	; 0xe80
   1001e:	4770      	bx	lr
   10020:	e000edf0 	.word	0xe000edf0
   10024:	c5acce55 	.word	0xc5acce55
   10028:	00150511 	.word	0x00150511

0001002c <am_hal_itm_disable>:
//! @return None.
//
//*****************************************************************************
void
am_hal_itm_disable(void)
{
   1002c:	b510      	push	{r4, lr}

#if AM_CMSIS_REGS
    if ( MCUCTRL->TPIUCTRL == 0 )
   1002e:	4b24      	ldr	r3, [pc, #144]	; (100c0 <am_hal_itm_disable+0x94>)
   10030:	f8d3 0250 	ldr.w	r0, [r3, #592]	; 0x250
   10034:	b9b0      	cbnz	r0, 10064 <am_hal_itm_disable+0x38>
    CoreDebug->DEMCR |= _VAL2FLD(CoreDebug_DEMCR_TRCENA, 1);
   10036:	4923      	ldr	r1, [pc, #140]	; (100c4 <am_hal_itm_disable+0x98>)
   10038:	68ca      	ldr	r2, [r1, #12]
   1003a:	f042 7480 	orr.w	r4, r2, #16777216	; 0x1000000
   1003e:	60cc      	str	r4, [r1, #12]
    while ( !(CoreDebug->DEMCR & _VAL2FLD(CoreDebug_DEMCR_TRCENA, 1)) );
   10040:	68cb      	ldr	r3, [r1, #12]
   10042:	01da      	lsls	r2, r3, #7
   10044:	d5fc      	bpl.n	10040 <am_hal_itm_disable+0x14>
    ITM->LAR = ITM_LAR_KEYVAL;
   10046:	f04f 4c60 	mov.w	ip, #3758096384	; 0xe0000000
   1004a:	481f      	ldr	r0, [pc, #124]	; (100c8 <am_hal_itm_disable+0x9c>)
    ITM->TCR =
   1004c:	4a1f      	ldr	r2, [pc, #124]	; (100cc <am_hal_itm_disable+0xa0>)
    ITM->LAR = ITM_LAR_KEYVAL;
   1004e:	f8cc 0fb0 	str.w	r0, [ip, #4016]	; 0xfb0
    ITM->TPR = 0x0000000F;
   10052:	240f      	movs	r4, #15
    ITM->TER = 0xFFFFFFFF;
   10054:	f04f 31ff 	mov.w	r1, #4294967295
    ITM->TPR = 0x0000000F;
   10058:	f8cc 4e40 	str.w	r4, [ip, #3648]	; 0xe40
    ITM->TER = 0xFFFFFFFF;
   1005c:	f8cc 1e00 	str.w	r1, [ip, #3584]	; 0xe00
    ITM->TCR =
   10060:	f8cc 2e80 	str.w	r2, [ip, #3712]	; 0xe80
{
    //
    // Make sure the ITM/TPIU is not busy.
    //
#if AM_CMSIS_REGS
    while (ITM->TCR & _VAL2FLD(ITM_TCR_BUSY, 1));
   10064:	f04f 4460 	mov.w	r4, #3758096384	; 0xe0000000
   10068:	f8d4 3e80 	ldr.w	r3, [r4, #3712]	; 0xe80
   1006c:	021b      	lsls	r3, r3, #8
   1006e:	d4fb      	bmi.n	10068 <am_hal_itm_disable+0x3c>
#endif // AM_CMSIS_REGS

    //
    // wait for 50us for the data to flush out
    //
    am_hal_flash_delay(FLASH_CYCLES_US(50));
   10070:	f240 20f7 	movw	r0, #759	; 0x2f7
   10074:	f7fe fcd6 	bl	ea24 <am_hal_flash_delay>
    ITM->LAR = ITM_LAR_KEYVAL;
   10078:	4813      	ldr	r0, [pc, #76]	; (100c8 <am_hal_itm_disable+0x9c>)
        while ( ITM->TCR  & (_VAL2FLD(ITM_TCR_ITMENA, 1)  |  _VAL2FLD(ITM_TCR_BUSY, 1)) );
   1007a:	4915      	ldr	r1, [pc, #84]	; (100d0 <am_hal_itm_disable+0xa4>)
    ITM->LAR = ITM_LAR_KEYVAL;
   1007c:	f8c4 0fb0 	str.w	r0, [r4, #4016]	; 0xfb0
        ITM->TCR &= ~_VAL2FLD(ITM_TCR_ITMENA, 1);
   10080:	f04f 4c60 	mov.w	ip, #3758096384	; 0xe0000000
    ITM->LAR = ITM_LAR_KEYVAL;
   10084:	2064      	movs	r0, #100	; 0x64
        ITM->TCR &= ~_VAL2FLD(ITM_TCR_ITMENA, 1);
   10086:	f8dc 2e80 	ldr.w	r2, [ip, #3712]	; 0xe80
   1008a:	f022 0401 	bic.w	r4, r2, #1
   1008e:	f8cc 4e80 	str.w	r4, [ip, #3712]	; 0xe80
        while ( ITM->TCR  & (_VAL2FLD(ITM_TCR_ITMENA, 1)  |  _VAL2FLD(ITM_TCR_BUSY, 1)) );
   10092:	f8dc 3e80 	ldr.w	r3, [ip, #3712]	; 0xe80
   10096:	420b      	tst	r3, r1
   10098:	d1fb      	bne.n	10092 <am_hal_itm_disable+0x66>
    for (int ix = 0; ix < 100; ix++)
   1009a:	3801      	subs	r0, #1
   1009c:	d1f3      	bne.n	10086 <am_hal_itm_disable+0x5a>
    CoreDebug->DEMCR &= ~_VAL2FLD(CoreDebug_DEMCR_TRCENA, 1);
   1009e:	4909      	ldr	r1, [pc, #36]	; (100c4 <am_hal_itm_disable+0x98>)
   100a0:	68ca      	ldr	r2, [r1, #12]
   100a2:	f022 7480 	bic.w	r4, r2, #16777216	; 0x1000000
   100a6:	60cc      	str	r4, [r1, #12]
    while ( CoreDebug->DEMCR & _VAL2FLD(CoreDebug_DEMCR_TRCENA, 1) );
   100a8:	68cb      	ldr	r3, [r1, #12]
   100aa:	f013 7080 	ands.w	r0, r3, #16777216	; 0x1000000
   100ae:	d1fb      	bne.n	100a8 <am_hal_itm_disable+0x7c>
    MCUCTRL->TPIUCTRL =
   100b0:	4903      	ldr	r1, [pc, #12]	; (100c0 <am_hal_itm_disable+0x94>)
   100b2:	f8c1 0250 	str.w	r0, [r1, #592]	; 0x250
    while (MCUCTRL->TPIUCTRL);
   100b6:	f8d1 2250 	ldr.w	r2, [r1, #592]	; 0x250
   100ba:	2a00      	cmp	r2, #0
   100bc:	d1fb      	bne.n	100b6 <am_hal_itm_disable+0x8a>
}
   100be:	bd10      	pop	{r4, pc}
   100c0:	40020000 	.word	0x40020000
   100c4:	e000edf0 	.word	0xe000edf0
   100c8:	c5acce55 	.word	0xc5acce55
   100cc:	00150511 	.word	0x00150511
   100d0:	00800001 	.word	0x00800001

000100d4 <am_hal_itm_print>:
    uint32_t ui32Length = 0;

    //
    // Determine the length of the string.
    //
    while (*(pcString + ui32Length))
   100d4:	7803      	ldrb	r3, [r0, #0]
   100d6:	b1b3      	cbz	r3, 10106 <am_hal_itm_print+0x32>
{
   100d8:	b410      	push	{r4}
   100da:	4602      	mov	r2, r0
    while (*(pcString + ui32Length))
   100dc:	2400      	movs	r4, #0
   100de:	f812 1f01 	ldrb.w	r1, [r2, #1]!
    {
        ui32Length++;
   100e2:	3401      	adds	r4, #1
    while (*(pcString + ui32Length))
   100e4:	2900      	cmp	r1, #0
   100e6:	d1fa      	bne.n	100de <am_hal_itm_print+0xa>
   100e8:	1901      	adds	r1, r0, r4
    while (!AM_REGVAL(ui32StimAddr));
   100ea:	f04f 4c60 	mov.w	ip, #3758096384	; 0xe0000000
    while (ui32Length)
    {
            //
            // Print string out the ITM.
            //
            am_hal_itm_stimulus_reg_byte_write(0, (uint8_t)*pcString++);
   100ee:	f810 2b01 	ldrb.w	r2, [r0], #1
    while (!AM_REGVAL(ui32StimAddr));
   100f2:	f8dc 3000 	ldr.w	r3, [ip]
   100f6:	2b00      	cmp	r3, #0
   100f8:	d0fb      	beq.n	100f2 <am_hal_itm_print+0x1e>
    while (ui32Length)
   100fa:	4288      	cmp	r0, r1
    *((volatile uint8_t *) ui32StimAddr) = ui8Value;
   100fc:	f88c 2000 	strb.w	r2, [ip]
    while (ui32Length)
   10100:	d1f5      	bne.n	100ee <am_hal_itm_print+0x1a>
            //
            // Subtract from length.
            //
            ui32Length--;
    }
}
   10102:	f85d 4b04 	ldr.w	r4, [sp], #4
   10106:	4770      	bx	lr

00010108 <am_hal_mcuctrl_control>:
// ****************************************************************************
uint32_t
am_hal_mcuctrl_control(am_hal_mcuctrl_control_e eControl, void *pArgs)
{
#if AM_CMSIS_REGS
    switch ( eControl )
   10108:	2803      	cmp	r0, #3
   1010a:	d824      	bhi.n	10156 <am_hal_mcuctrl_control+0x4e>
   1010c:	e8df f000 	tbb	[pc, r0]
   10110:	0202111a 	.word	0x0202111a
        case AM_HAL_MCUCTRL_CONTROL_EXTCLK32K_DISABLE:
            //
            // Configure the bits in XTALCTRL that disable external 32KHz
            // clock, thus re-configuring for the crystal.
            //
            MCUCTRL->XTALCTRL &=
   10114:	4b11      	ldr	r3, [pc, #68]	; (1015c <am_hal_mcuctrl_control+0x54>)
   10116:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
   1011a:	f022 001f 	bic.w	r0, r2, #31
   1011e:	f8c3 0120 	str.w	r0, [r3, #288]	; 0x120
                  MCUCTRL_XTALCTRL_PDNBCOREXTAL_Msk                 |
                  MCUCTRL_XTALCTRL_BYPCMPRXTAL_Msk                  |
                  MCUCTRL_XTALCTRL_FDBKDSBLXTAL_Msk                 |
                  MCUCTRL_XTALCTRL_XTALSWE_Msk);

            MCUCTRL->XTALCTRL |=
   10122:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
   10126:	f041 0201 	orr.w	r2, r1, #1
   1012a:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
#endif // AM_CMSIS_REGS

    //
    // Return success status.
    //
    return AM_HAL_STATUS_SUCCESS;
   1012e:	2000      	movs	r0, #0
            break;
   10130:	4770      	bx	lr
            MCUCTRL->FAULTCAPTUREEN_b.FAULTCAPTUREEN = 0;
   10132:	480a      	ldr	r0, [pc, #40]	; (1015c <am_hal_mcuctrl_control+0x54>)
   10134:	f890 c1d0 	ldrb.w	ip, [r0, #464]	; 0x1d0
   10138:	f36f 0c00 	bfc	ip, #0, #1
   1013c:	f880 c1d0 	strb.w	ip, [r0, #464]	; 0x1d0
    return AM_HAL_STATUS_SUCCESS;
   10140:	2000      	movs	r0, #0
            break;
   10142:	4770      	bx	lr
            MCUCTRL->FAULTCAPTUREEN_b.FAULTCAPTUREEN = 1;
   10144:	4905      	ldr	r1, [pc, #20]	; (1015c <am_hal_mcuctrl_control+0x54>)
   10146:	f891 31d0 	ldrb.w	r3, [r1, #464]	; 0x1d0
   1014a:	f043 0201 	orr.w	r2, r3, #1
   1014e:	f881 21d0 	strb.w	r2, [r1, #464]	; 0x1d0
    return AM_HAL_STATUS_SUCCESS;
   10152:	2000      	movs	r0, #0
            break;
   10154:	4770      	bx	lr
            return AM_HAL_STATUS_INVALID_ARG;
   10156:	2006      	movs	r0, #6

} // am_hal_mcuctrl_control()
   10158:	4770      	bx	lr
   1015a:	bf00      	nop
   1015c:	40020000 	.word	0x40020000

00010160 <am_hal_mcuctrl_info_get>:
am_hal_mcuctrl_info_get(am_hal_mcuctrl_infoget_e eInfoGet, void *pInfo)
{
    am_hal_mcuctrl_feature_t *psFeature;
    uint32_t ui32Feature;

    if ( pInfo == NULL )
   10160:	b141      	cbz	r1, 10174 <am_hal_mcuctrl_info_get+0x14>
    {
        return AM_HAL_STATUS_INVALID_ARG;
    }

#if AM_CMSIS_REGS
    switch ( eInfoGet )
   10162:	2801      	cmp	r0, #1
{
   10164:	b4f0      	push	{r4, r5, r6, r7}
    switch ( eInfoGet )
   10166:	d03a      	beq.n	101de <am_hal_mcuctrl_info_get+0x7e>
   10168:	d322      	bcc.n	101b0 <am_hal_mcuctrl_info_get+0x50>
   1016a:	2802      	cmp	r0, #2
   1016c:	d004      	beq.n	10178 <am_hal_mcuctrl_info_get+0x18>
        case AM_HAL_MCUCTRL_INFO_FAULT_STATUS:
            mcuctrl_fault_status((am_hal_mcuctrl_fault_t*)pInfo);
            break;

        default:
            return AM_HAL_STATUS_INVALID_ARG;
   1016e:	2006      	movs	r0, #6
    //
    // Return success status.
    //
    return AM_HAL_STATUS_SUCCESS;

} // am_hal_mcuctrl_info_get()
   10170:	bcf0      	pop	{r4, r5, r6, r7}
   10172:	4770      	bx	lr
        return AM_HAL_STATUS_INVALID_ARG;
   10174:	2006      	movs	r0, #6
   10176:	4770      	bx	lr
    ui32FaultStat = MCUCTRL->FAULTSTATUS;
   10178:	4a41      	ldr	r2, [pc, #260]	; (10280 <am_hal_mcuctrl_info_get+0x120>)
    psFault->ui32ICODE |= MCUCTRL->ICODEFAULTADDR;
   1017a:	684c      	ldr	r4, [r1, #4]
    ui32FaultStat = MCUCTRL->FAULTSTATUS;
   1017c:	f8d2 31cc 	ldr.w	r3, [r2, #460]	; 0x1cc
    psFault->ui32SYS |= MCUCTRL->SYSFAULTADDR;
   10180:	6948      	ldr	r0, [r1, #20]
    psFault->bICODE = (bool)(ui32FaultStat & MCUCTRL_FAULTSTATUS_ICODEFAULT_Msk);
   10182:	f003 0601 	and.w	r6, r3, #1
    psFault->bDCODE = (bool)(ui32FaultStat & MCUCTRL_FAULTSTATUS_DCODEFAULT_Msk);
   10186:	f3c3 0540 	ubfx	r5, r3, #1, #1
    psFault->bSYS   = (bool)(ui32FaultStat & MCUCTRL_FAULTSTATUS_SYSFAULT_Msk);
   1018a:	f3c3 0780 	ubfx	r7, r3, #2, #1
    psFault->bDCODE = (bool)(ui32FaultStat & MCUCTRL_FAULTSTATUS_DCODEFAULT_Msk);
   1018e:	720d      	strb	r5, [r1, #8]
    psFault->bSYS   = (bool)(ui32FaultStat & MCUCTRL_FAULTSTATUS_SYSFAULT_Msk);
   10190:	740f      	strb	r7, [r1, #16]
    psFault->bICODE = (bool)(ui32FaultStat & MCUCTRL_FAULTSTATUS_ICODEFAULT_Msk);
   10192:	700e      	strb	r6, [r1, #0]
    psFault->ui32DCODE = MCUCTRL->DCODEFAULTADDR;
   10194:	f8d2 31c4 	ldr.w	r3, [r2, #452]	; 0x1c4
   10198:	60cb      	str	r3, [r1, #12]
    psFault->ui32ICODE |= MCUCTRL->ICODEFAULTADDR;
   1019a:	f8d2 61c0 	ldr.w	r6, [r2, #448]	; 0x1c0
   1019e:	4334      	orrs	r4, r6
   101a0:	604c      	str	r4, [r1, #4]
    psFault->ui32SYS |= MCUCTRL->SYSFAULTADDR;
   101a2:	f8d2 21c8 	ldr.w	r2, [r2, #456]	; 0x1c8
   101a6:	4310      	orrs	r0, r2
   101a8:	6148      	str	r0, [r1, #20]
} // am_hal_mcuctrl_info_get()
   101aa:	bcf0      	pop	{r4, r5, r6, r7}
    return AM_HAL_STATUS_SUCCESS;
   101ac:	2000      	movs	r0, #0
} // am_hal_mcuctrl_info_get()
   101ae:	4770      	bx	lr
            ui32Feature = MCUCTRL->FEATUREENABLE;
   101b0:	4c33      	ldr	r4, [pc, #204]	; (10280 <am_hal_mcuctrl_info_get+0x120>)
   101b2:	69a5      	ldr	r5, [r4, #24]
                _FLD2VAL(MCUCTRL_FEATUREENABLE_BURSTAVAIL, ui32Feature);
   101b4:	f3c5 1080 	ubfx	r0, r5, #6, #1
                _FLD2VAL(MCUCTRL_FEATUREENABLE_BLEAVAIL, ui32Feature);
   101b8:	f3c5 0780 	ubfx	r7, r5, #2, #1
                _FLD2VAL(MCUCTRL_FEATUREENABLE_BURSTAVAIL, ui32Feature);
   101bc:	7008      	strb	r0, [r1, #0]
                _FLD2VAL(MCUCTRL_FEATUREENABLE_BLEAVAIL, ui32Feature);
   101be:	704f      	strb	r7, [r1, #1]
            ui32Feature = MCUCTRL->BOOTLOADER;
   101c0:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
                _FLD2VAL(MCUCTRL_BOOTLOADER_SECBOOTFEATURE, ui32Feature);
   101c4:	f3c3 6681 	ubfx	r6, r3, #26, #2
            psFeature->ui8SecBootFeature =
   101c8:	710e      	strb	r6, [r1, #4]
            ui32Feature = MCUCTRL->SKU;
   101ca:	6964      	ldr	r4, [r4, #20]
                _FLD2VAL(MCUCTRL_SKU_ALLOWBLE, ui32Feature);
   101cc:	f3c4 0240 	ubfx	r2, r4, #1, #1
                _FLD2VAL(MCUCTRL_SKU_ALLOWBURST, ui32Feature);
   101d0:	f004 0501 	and.w	r5, r4, #1
   101d4:	70cd      	strb	r5, [r1, #3]
    return AM_HAL_STATUS_SUCCESS;
   101d6:	2000      	movs	r0, #0
                _FLD2VAL(MCUCTRL_SKU_ALLOWBLE, ui32Feature);
   101d8:	708a      	strb	r2, [r1, #2]
} // am_hal_mcuctrl_info_get()
   101da:	bcf0      	pop	{r4, r5, r6, r7}
   101dc:	4770      	bx	lr
    psDevice->ui32ChipPN = MCUCTRL->CHIPPN;
   101de:	4a28      	ldr	r2, [pc, #160]	; (10280 <am_hal_mcuctrl_info_get+0x120>)
        g_am_hal_mcuctrl_flash_size[
   101e0:	4c28      	ldr	r4, [pc, #160]	; (10284 <am_hal_mcuctrl_info_get+0x124>)
    psDevice->ui32ChipPN = MCUCTRL->CHIPPN;
   101e2:	6813      	ldr	r3, [r2, #0]
   101e4:	600b      	str	r3, [r1, #0]
    psDevice->ui32ChipID0 = MCUCTRL->CHIPID0;
   101e6:	6850      	ldr	r0, [r2, #4]
   101e8:	6048      	str	r0, [r1, #4]
    psDevice->ui32ChipID1 = MCUCTRL->CHIPID1;
   101ea:	6897      	ldr	r7, [r2, #8]
   101ec:	608f      	str	r7, [r1, #8]
    psDevice->ui32ChipRev = MCUCTRL->CHIPREV;
   101ee:	68d6      	ldr	r6, [r2, #12]
   101f0:	60ce      	str	r6, [r1, #12]
    psDevice->ui32VendorID = MCUCTRL->VENDORID;
   101f2:	6915      	ldr	r5, [r2, #16]
        g_am_hal_mcuctrl_sram_size[
   101f4:	4824      	ldr	r0, [pc, #144]	; (10288 <am_hal_mcuctrl_info_get+0x128>)
    psDevice->ui32VendorID = MCUCTRL->VENDORID;
   101f6:	610d      	str	r5, [r1, #16]
            (psDevice->ui32ChipPN & MCUCTRL_CHIPPN_PARTNUM_FLASHSIZE_M) >>
   101f8:	f3c3 5c03 	ubfx	ip, r3, #20, #4
            (psDevice->ui32ChipPN & MCUCTRL_CHIPPN_PARTNUM_SRAMSIZE_M) >>
   101fc:	f3c3 4703 	ubfx	r7, r3, #16, #4
    psDevice->ui32SKU = MCUCTRL->SKU;
   10200:	6956      	ldr	r6, [r2, #20]
    psDevice->ui32SRAMSize =
   10202:	f850 5027 	ldr.w	r5, [r0, r7, lsl #2]
    psDevice->ui32JedecPN  = JEDEC->PID0_b.PNL8 << 0;
   10206:	4a21      	ldr	r2, [pc, #132]	; (1028c <am_hal_mcuctrl_info_get+0x12c>)
    psDevice->ui32FlashSize =
   10208:	f854 402c 	ldr.w	r4, [r4, ip, lsl #2]
    psDevice->ui32SKU = MCUCTRL->SKU;
   1020c:	614e      	str	r6, [r1, #20]
    psDevice->ui32Qualified = (psDevice->ui32ChipPN >> MCUCTRL_CHIPPN_PARTNUM_QUAL_S) & 0x1;
   1020e:	f003 0301 	and.w	r3, r3, #1
    psDevice->ui32FlashSize =
   10212:	61cc      	str	r4, [r1, #28]
    psDevice->ui32SRAMSize =
   10214:	620d      	str	r5, [r1, #32]
    psDevice->ui32Qualified = (psDevice->ui32ChipPN >> MCUCTRL_CHIPPN_PARTNUM_QUAL_S) & 0x1;
   10216:	618b      	str	r3, [r1, #24]
    psDevice->ui32JedecPN  = JEDEC->PID0_b.PNL8 << 0;
   10218:	f8d2 70e0 	ldr.w	r7, [r2, #224]	; 0xe0
    psDevice->ui32JedecPN |= JEDEC->PID1_b.PNH4 << 8;
   1021c:	f8d2 00e4 	ldr.w	r0, [r2, #228]	; 0xe4
    psDevice->ui32JedecPN  = JEDEC->PID0_b.PNL8 << 0;
   10220:	b2fe      	uxtb	r6, r7
    psDevice->ui32JedecPN |= JEDEC->PID1_b.PNH4 << 8;
   10222:	f000 040f 	and.w	r4, r0, #15
   10226:	ea46 2504 	orr.w	r5, r6, r4, lsl #8
   1022a:	624d      	str	r5, [r1, #36]	; 0x24
    psDevice->ui32JedecJEPID  = JEDEC->PID1_b.JEPIDL << 0;
   1022c:	f8d2 30e4 	ldr.w	r3, [r2, #228]	; 0xe4
    psDevice->ui32JedecJEPID |= JEDEC->PID2_b.JEPIDH << 4;
   10230:	f8d2 70e8 	ldr.w	r7, [r2, #232]	; 0xe8
    psDevice->ui32JedecJEPID  = JEDEC->PID1_b.JEPIDL << 0;
   10234:	f3c3 1603 	ubfx	r6, r3, #4, #4
    psDevice->ui32JedecJEPID |= JEDEC->PID2_b.JEPIDH << 4;
   10238:	f007 0c0f 	and.w	ip, r7, #15
   1023c:	ea46 100c 	orr.w	r0, r6, ip, lsl #4
   10240:	6288      	str	r0, [r1, #40]	; 0x28
    psDevice->ui32JedecCHIPREV  = JEDEC->PID2_b.CHIPREVH4 << 4;
   10242:	f8d2 40e8 	ldr.w	r4, [r2, #232]	; 0xe8
    psDevice->ui32JedecCHIPREV |= JEDEC->PID3_b.CHIPREVL4 << 0;
   10246:	f8d2 50ec 	ldr.w	r5, [r2, #236]	; 0xec
    psDevice->ui32JedecCHIPREV  = JEDEC->PID2_b.CHIPREVH4 << 4;
   1024a:	f004 03f0 	and.w	r3, r4, #240	; 0xf0
    psDevice->ui32JedecCHIPREV |= JEDEC->PID3_b.CHIPREVL4 << 0;
   1024e:	f3c5 1703 	ubfx	r7, r5, #4, #4
   10252:	433b      	orrs	r3, r7
   10254:	62cb      	str	r3, [r1, #44]	; 0x2c
    psDevice->ui32JedecCID  = JEDEC->CID3_b.CID << 24;
   10256:	f8d2 60fc 	ldr.w	r6, [r2, #252]	; 0xfc
    psDevice->ui32JedecCID |= JEDEC->CID2_b.CID << 16;
   1025a:	f8d2 40f8 	ldr.w	r4, [r2, #248]	; 0xf8
    psDevice->ui32JedecCID |= JEDEC->CID1_b.CID <<  8;
   1025e:	f8d2 00f4 	ldr.w	r0, [r2, #244]	; 0xf4
    psDevice->ui32JedecCID |= JEDEC->CID0_b.CID <<  0;
   10262:	f8d2 20f0 	ldr.w	r2, [r2, #240]	; 0xf0
    psDevice->ui32JedecCID |= JEDEC->CID2_b.CID << 16;
   10266:	b2e5      	uxtb	r5, r4
   10268:	042b      	lsls	r3, r5, #16
   1026a:	ea43 6706 	orr.w	r7, r3, r6, lsl #24
    psDevice->ui32JedecCID |= JEDEC->CID0_b.CID <<  0;
   1026e:	b2d6      	uxtb	r6, r2
   10270:	4337      	orrs	r7, r6
    psDevice->ui32JedecCID |= JEDEC->CID1_b.CID <<  8;
   10272:	b2c4      	uxtb	r4, r0
    psDevice->ui32JedecCID |= JEDEC->CID0_b.CID <<  0;
   10274:	ea47 2004 	orr.w	r0, r7, r4, lsl #8
   10278:	6308      	str	r0, [r1, #48]	; 0x30
    return AM_HAL_STATUS_SUCCESS;
   1027a:	2000      	movs	r0, #0
} // am_hal_mcuctrl_info_get()
   1027c:	bcf0      	pop	{r4, r5, r6, r7}
   1027e:	4770      	bx	lr
   10280:	40020000 	.word	0x40020000
   10284:	00010d00 	.word	0x00010d00
   10288:	00010d40 	.word	0x00010d40
   1028c:	f0000f00 	.word	0xf0000f00

00010290 <am_hal_pwrctrl_periph_enable>:
//  Enable power for a peripheral.
//
// ****************************************************************************
uint32_t
am_hal_pwrctrl_periph_enable(am_hal_pwrctrl_periph_e ePeripheral)
{
   10290:	b570      	push	{r4, r5, r6, lr}
   10292:	b082      	sub	sp, #8
   10294:	4604      	mov	r4, r0
// #### INTERNAL END ####

    //
    // Enable power control for the given device.
    //
    AM_CRITICAL_BEGIN
   10296:	f7fe fe7f 	bl	ef98 <am_hal_interrupt_master_disable>
    PWRCTRL->DEVPWREN |= am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphEnable;
   1029a:	eb04 0144 	add.w	r1, r4, r4, lsl #1
   1029e:	008c      	lsls	r4, r1, #2
   102a0:	4e0e      	ldr	r6, [pc, #56]	; (102dc <am_hal_pwrctrl_periph_enable+0x4c>)
   102a2:	4d0f      	ldr	r5, [pc, #60]	; (102e0 <am_hal_pwrctrl_periph_enable+0x50>)
    AM_CRITICAL_BEGIN
   102a4:	9001      	str	r0, [sp, #4]
    PWRCTRL->DEVPWREN |= am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphEnable;
   102a6:	592a      	ldr	r2, [r5, r4]
   102a8:	68b3      	ldr	r3, [r6, #8]
   102aa:	4313      	orrs	r3, r2
   102ac:	60b3      	str	r3, [r6, #8]
    AM_CRITICAL_END
   102ae:	9801      	ldr	r0, [sp, #4]

    for (uint32_t wait_usecs = 0; wait_usecs < AM_HAL_PWRCTRL_MAX_WFE; wait_usecs += 10)
    {
        am_hal_flash_delay(FLASH_CYCLES_US(10));

        if ( (PWRCTRL->DEVPWRSTATUS & am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphStatus) > 0)
   102b0:	442c      	add	r4, r5
    AM_CRITICAL_END
   102b2:	f7fe fe75 	bl	efa0 <am_hal_interrupt_master_set>
        am_hal_flash_delay(FLASH_CYCLES_US(10));
   102b6:	2077      	movs	r0, #119	; 0x77
   102b8:	f7fe fbb4 	bl	ea24 <am_hal_flash_delay>
        if ( (PWRCTRL->DEVPWRSTATUS & am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphStatus) > 0)
   102bc:	69b0      	ldr	r0, [r6, #24]
   102be:	6864      	ldr	r4, [r4, #4]
   102c0:	4220      	tst	r0, r4
   102c2:	d103      	bne.n	102cc <am_hal_pwrctrl_periph_enable+0x3c>
        am_hal_flash_delay(FLASH_CYCLES_US(10));
   102c4:	2077      	movs	r0, #119	; 0x77
   102c6:	f7fe fbad 	bl	ea24 <am_hal_flash_delay>
        if ( (PWRCTRL->DEVPWRSTATUS & am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphStatus) > 0)
   102ca:	69b3      	ldr	r3, [r6, #24]
    }

    //
    // Check the device status.
    //
    if ( (PWRCTRL->DEVPWRSTATUS & am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphStatus) > 0 )
   102cc:	4903      	ldr	r1, [pc, #12]	; (102dc <am_hal_pwrctrl_periph_enable+0x4c>)
   102ce:	698d      	ldr	r5, [r1, #24]
   102d0:	4225      	tst	r5, r4
    else
    {
        return AM_HAL_STATUS_FAIL;
    }
#endif // AM_CMSIS_REGS
}
   102d2:	bf0c      	ite	eq
   102d4:	2001      	moveq	r0, #1
   102d6:	2000      	movne	r0, #0
   102d8:	b002      	add	sp, #8
   102da:	bd70      	pop	{r4, r5, r6, pc}
   102dc:	40021000 	.word	0x40021000
   102e0:	00010d80 	.word	0x00010d80

000102e4 <am_hal_pwrctrl_periph_disable>:
//  Disable power for a peripheral.
//
// ****************************************************************************
uint32_t
am_hal_pwrctrl_periph_disable(am_hal_pwrctrl_periph_e ePeripheral)
{
   102e4:	b570      	push	{r4, r5, r6, lr}
   102e6:	b082      	sub	sp, #8
   102e8:	4604      	mov	r4, r0

    //
    // Disable power domain for the given device.
    //
#if AM_CMSIS_REGS
    AM_CRITICAL_BEGIN
   102ea:	f7fe fe55 	bl	ef98 <am_hal_interrupt_master_disable>
    PWRCTRL->DEVPWREN &= ~am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphEnable;
   102ee:	eb04 0144 	add.w	r1, r4, r4, lsl #1
   102f2:	008c      	lsls	r4, r1, #2
   102f4:	4e0f      	ldr	r6, [pc, #60]	; (10334 <am_hal_pwrctrl_periph_disable+0x50>)
   102f6:	4d10      	ldr	r5, [pc, #64]	; (10338 <am_hal_pwrctrl_periph_disable+0x54>)
    AM_CRITICAL_BEGIN
   102f8:	9001      	str	r0, [sp, #4]
    PWRCTRL->DEVPWREN &= ~am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphEnable;
   102fa:	68b3      	ldr	r3, [r6, #8]
   102fc:	592a      	ldr	r2, [r5, r4]
   102fe:	ea23 0002 	bic.w	r0, r3, r2
   10302:	60b0      	str	r0, [r6, #8]
    AM_CRITICAL_END
   10304:	9801      	ldr	r0, [sp, #4]
    for (uint32_t wait_usecs = 0; wait_usecs < AM_HAL_PWRCTRL_MAX_WFE; wait_usecs += 10)
    {
        am_hal_flash_delay(FLASH_CYCLES_US(10));

#if AM_CMSIS_REGS
        if ( (PWRCTRL->DEVPWRSTATUS & am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphStatus) == 0 )
   10306:	442c      	add	r4, r5
    AM_CRITICAL_END
   10308:	f7fe fe4a 	bl	efa0 <am_hal_interrupt_master_set>
        am_hal_flash_delay(FLASH_CYCLES_US(10));
   1030c:	2077      	movs	r0, #119	; 0x77
   1030e:	f7fe fb89 	bl	ea24 <am_hal_flash_delay>
        if ( (PWRCTRL->DEVPWRSTATUS & am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphStatus) == 0 )
   10312:	69b1      	ldr	r1, [r6, #24]
   10314:	6864      	ldr	r4, [r4, #4]
   10316:	4221      	tst	r1, r4
   10318:	d003      	beq.n	10322 <am_hal_pwrctrl_periph_disable+0x3e>
        am_hal_flash_delay(FLASH_CYCLES_US(10));
   1031a:	2077      	movs	r0, #119	; 0x77
   1031c:	f7fe fb82 	bl	ea24 <am_hal_flash_delay>
        if ( (PWRCTRL->DEVPWRSTATUS & am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphStatus) == 0 )
   10320:	69b3      	ldr	r3, [r6, #24]

    //
    // Check the device status.
    //
#if AM_CMSIS_REGS
    if ( ( PWRCTRL->DEVPWRSTATUS & am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphStatus) == 0 )
   10322:	4d04      	ldr	r5, [pc, #16]	; (10334 <am_hal_pwrctrl_periph_disable+0x50>)
   10324:	69ae      	ldr	r6, [r5, #24]
   10326:	4226      	tst	r6, r4
#endif // AM_CMSIS_REGS
    else
    {
        return AM_HAL_STATUS_FAIL;
    }
}
   10328:	bf14      	ite	ne
   1032a:	2001      	movne	r0, #1
   1032c:	2000      	moveq	r0, #0
   1032e:	b002      	add	sp, #8
   10330:	bd70      	pop	{r4, r5, r6, pc}
   10332:	bf00      	nop
   10334:	40021000 	.word	0x40021000
   10338:	00010d80 	.word	0x00010d80

0001033c <am_hal_pwrctrl_low_power_init>:
//  Initialize system for low power configuration.
//
// ****************************************************************************
uint32_t
am_hal_pwrctrl_low_power_init(void)
{
   1033c:	b530      	push	{r4, r5, lr}

#if AM_CMSIS_REGS
    //
    // Check if the BLE is already enabled.
    //
    if ( PWRCTRL->DEVPWRSTATUS_b.BLEL == 0)
   1033e:	4c1b      	ldr	r4, [pc, #108]	; (103ac <am_hal_pwrctrl_low_power_init+0x70>)
   10340:	69a3      	ldr	r3, [r4, #24]
   10342:	05db      	lsls	r3, r3, #23
{
   10344:	b083      	sub	sp, #12
    if ( PWRCTRL->DEVPWRSTATUS_b.BLEL == 0)
   10346:	d502      	bpl.n	1034e <am_hal_pwrctrl_low_power_init+0x12>
            AM_BFW(MCUCTRL, BLEBUCK2,  BLEBUCKTONLOWTRIM, 0xF);
        }
    }
#endif // AM_CMSIS_REGS

    return AM_HAL_STATUS_SUCCESS;
   10348:	2000      	movs	r0, #0
}
   1034a:	b003      	add	sp, #12
   1034c:	bd30      	pop	{r4, r5, pc}
        MCUCTRL->FEATUREENABLE = MCUCTRL_FEATUREENABLE_BLEREQ_Msk;
   1034e:	4d18      	ldr	r5, [pc, #96]	; (103b0 <am_hal_pwrctrl_low_power_init+0x74>)
        ui32Status = am_hal_flash_delay_status_check(10000,
   10350:	4918      	ldr	r1, [pc, #96]	; (103b4 <am_hal_pwrctrl_low_power_init+0x78>)
        MCUCTRL->FEATUREENABLE = MCUCTRL_FEATUREENABLE_BLEREQ_Msk;
   10352:	2001      	movs	r0, #1
        ui32Status = am_hal_flash_delay_status_check(10000,
   10354:	2307      	movs	r3, #7
        MCUCTRL->FEATUREENABLE = MCUCTRL_FEATUREENABLE_BLEREQ_Msk;
   10356:	61a8      	str	r0, [r5, #24]
        ui32Status = am_hal_flash_delay_status_check(10000,
   10358:	461a      	mov	r2, r3
   1035a:	9000      	str	r0, [sp, #0]
   1035c:	f242 7010 	movw	r0, #10000	; 0x2710
   10360:	f7fe fb64 	bl	ea2c <am_hal_flash_delay_status_check>
        if (AM_HAL_STATUS_SUCCESS != ui32Status)
   10364:	b110      	cbz	r0, 1036c <am_hal_pwrctrl_low_power_init+0x30>
            return AM_HAL_STATUS_TIMEOUT;
   10366:	2004      	movs	r0, #4
}
   10368:	b003      	add	sp, #12
   1036a:	bd30      	pop	{r4, r5, pc}
        PWRCTRL->SUPPLYSRC |= _VAL2FLD(PWRCTRL_SUPPLYSRC_BLEBUCKEN,
   1036c:	6821      	ldr	r1, [r4, #0]
   1036e:	f041 0201 	orr.w	r2, r1, #1
   10372:	6022      	str	r2, [r4, #0]
        PWRCTRL->MISC |= _VAL2FLD(PWRCTRL_MISC_MEMVRLPBLE,
   10374:	6a63      	ldr	r3, [r4, #36]	; 0x24
   10376:	f043 0140 	orr.w	r1, r3, #64	; 0x40
   1037a:	6261      	str	r1, [r4, #36]	; 0x24
        if ( APOLLO3_A0 )
   1037c:	68ec      	ldr	r4, [r5, #12]
   1037e:	b2e2      	uxtb	r2, r4
   10380:	2a11      	cmp	r2, #17
   10382:	d1e1      	bne.n	10348 <am_hal_pwrctrl_low_power_init+0xc>
            MCUCTRL->SIMOBUCK4_b.SIMOBUCKCLKDIVSEL = 0x0;
   10384:	f8d5 335c 	ldr.w	r3, [r5, #860]	; 0x35c
   10388:	f360 5356 	bfi	r3, r0, #21, #2
   1038c:	f8c5 335c 	str.w	r3, [r5, #860]	; 0x35c
            MCUCTRL->BLEBUCK2_b.BLEBUCKTONHITRIM   = 0xF;
   10390:	f8d5 1368 	ldr.w	r1, [r5, #872]	; 0x368
   10394:	240f      	movs	r4, #15
   10396:	f364 118b 	bfi	r1, r4, #6, #6
   1039a:	f8c5 1368 	str.w	r1, [r5, #872]	; 0x368
            MCUCTRL->BLEBUCK2_b.BLEBUCKTONLOWTRIM  = 0xF;
   1039e:	f8d5 2368 	ldr.w	r2, [r5, #872]	; 0x368
   103a2:	f364 0205 	bfi	r2, r4, #0, #6
   103a6:	f8c5 2368 	str.w	r2, [r5, #872]	; 0x368
   103aa:	e7ce      	b.n	1034a <am_hal_pwrctrl_low_power_init+0xe>
   103ac:	40021000 	.word	0x40021000
   103b0:	40020000 	.word	0x40020000
   103b4:	40020018 	.word	0x40020018

000103b8 <am_hal_rtc_osc_select>:
#if AM_CMSIS_REGS
#if 1//USE_CLKGEN
    if ( ui32OSC == AM_HAL_RTC_OSC_LFRC )
    {
        // Set bit to 1 for LFRC
        CLKGEN->OCTRL |= CLKGEN_OCTRL_OSEL_Msk;
   103b8:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
    if ( ui32OSC == AM_HAL_RTC_OSC_LFRC )
   103bc:	2801      	cmp	r0, #1
        CLKGEN->OCTRL |= CLKGEN_OCTRL_OSEL_Msk;
   103be:	68d3      	ldr	r3, [r2, #12]
   103c0:	bf0c      	ite	eq
   103c2:	f043 0380 	orreq.w	r3, r3, #128	; 0x80
    }
    else
    {
        // Clear bit to 0 for XTAL
        CLKGEN->OCTRL &= ~CLKGEN_OCTRL_OSEL_Msk;
   103c6:	f023 0380 	bicne.w	r3, r3, #128	; 0x80
   103ca:	60d3      	str	r3, [r2, #12]
   103cc:	4770      	bx	lr
   103ce:	bf00      	nop

000103d0 <am_hal_rtc_osc_disable>:
    //
#if AM_CMSIS_REGS
#if USE_CLKGEN
    CLKGEN->RTCCTL_b.RSTOP = 1;
#else
    RTC->RTCCTL_b.RSTOP = 1;
   103d0:	4a03      	ldr	r2, [pc, #12]	; (103e0 <am_hal_rtc_osc_disable+0x10>)
   103d2:	f892 3050 	ldrb.w	r3, [r2, #80]	; 0x50
   103d6:	f043 0010 	orr.w	r0, r3, #16
   103da:	f882 0050 	strb.w	r0, [r2, #80]	; 0x50
   103de:	4770      	bx	lr
   103e0:	40004200 	.word	0x40004200

000103e4 <am_hal_sysctrl_sleep>:
//! @return None.
//
//*****************************************************************************
void
am_hal_sysctrl_sleep(bool bSleepDeep)
{
   103e4:	b510      	push	{r4, lr}
   103e6:	b082      	sub	sp, #8
   103e8:	4604      	mov	r4, r0
    //
    // Disable interrupts and save the previous interrupt state.
    //
    AM_CRITICAL_BEGIN
   103ea:	f7fe fdd5 	bl	ef98 <am_hal_interrupt_master_disable>
   103ee:	9001      	str	r0, [sp, #4]
#if AM_CMSIS_REGS
    //
    // If the user selected DEEPSLEEP and the TPIU is off, attempt to enter
    // DEEP SLEEP.
    //
    if ( (bSleepDeep == AM_HAL_SYSCTRL_SLEEP_DEEP)    &&
   103f0:	b124      	cbz	r4, 103fc <am_hal_sysctrl_sleep+0x18>
         (MCUCTRL->TPIUCTRL_b.ENABLE == MCUCTRL_TPIUCTRL_ENABLE_DIS) )
   103f2:	4b0c      	ldr	r3, [pc, #48]	; (10424 <am_hal_sysctrl_sleep+0x40>)
   103f4:	f8d3 0250 	ldr.w	r0, [r3, #592]	; 0x250
    if ( (bSleepDeep == AM_HAL_SYSCTRL_SLEEP_DEEP)    &&
   103f8:	07c3      	lsls	r3, r0, #31
   103fa:	d50a      	bpl.n	10412 <am_hal_sysctrl_sleep+0x2e>
    else
    {
        //
        // Prepare the core for normal sleep (write 0 to the DEEPSLEEP bit).
        //
        SCB->SCR &= ~_VAL2FLD(SCB_SCR_SLEEPDEEP, 1);
   103fc:	4a0a      	ldr	r2, [pc, #40]	; (10428 <am_hal_sysctrl_sleep+0x44>)
   103fe:	6911      	ldr	r1, [r2, #16]
   10400:	f021 0404 	bic.w	r4, r1, #4
   10404:	6114      	str	r4, [r2, #16]

        //
        // Go to sleep.
        //
        __WFI();
   10406:	bf30      	wfi
#endif // AM_CMSIS_REGS

    //
    // Restore the interrupt state.
    //
    AM_CRITICAL_END
   10408:	9801      	ldr	r0, [sp, #4]
   1040a:	f7fe fdc9 	bl	efa0 <am_hal_interrupt_master_set>
}
   1040e:	b002      	add	sp, #8
   10410:	bd10      	pop	{r4, pc}
        SCB->SCR = _VAL2FLD(SCB_SCR_SLEEPDEEP, 1);
   10412:	4b05      	ldr	r3, [pc, #20]	; (10428 <am_hal_sysctrl_sleep+0x44>)
   10414:	2004      	movs	r0, #4
   10416:	6118      	str	r0, [r3, #16]
        __WFI();
   10418:	bf30      	wfi
    AM_CRITICAL_END
   1041a:	9801      	ldr	r0, [sp, #4]
   1041c:	f7fe fdc0 	bl	efa0 <am_hal_interrupt_master_set>
}
   10420:	b002      	add	sp, #8
   10422:	bd10      	pop	{r4, pc}
   10424:	40020000 	.word	0x40020000
   10428:	e000ed00 	.word	0xe000ed00

0001042c <am_hal_tpiu_enable>:
//! @return None.
//
//*****************************************************************************
void
am_hal_tpiu_enable(am_hal_tpiu_config_t *psConfig)
{
   1042c:	b510      	push	{r4, lr}

#if AM_CMSIS_REGS
    //
    // TPIU formatter & flush control register.
    //
    TPI->FFCR = 0;
   1042e:	4a24      	ldr	r2, [pc, #144]	; (104c0 <am_hal_tpiu_enable+0x94>)
    ui32ITMbitrate = psConfig->ui32SetItmBaud;
   10430:	6803      	ldr	r3, [r0, #0]
    TPI->FFCR = 0;
   10432:	2100      	movs	r1, #0
{
   10434:	b084      	sub	sp, #16
    TPI->FFCR = 0;
   10436:	f8c2 1304 	str.w	r1, [r2, #772]	; 0x304
    // TPIU formatter & flush control register.
    //
    AM_REG(TPIU, FFCR) = 0;
#endif // AM_CMSIS_REGS

    if ( ui32ITMbitrate )
   1043a:	b33b      	cbz	r3, 1048c <am_hal_tpiu_enable+0x60>
    {
        //
        // Set the Current Parallel Port Size (note - only 1 bit can be set).
        //
#if AM_CMSIS_REGS
        TPI->CSPSR = TPI_CSPSR_CWIDTH_1BIT;
   1043c:	2001      	movs	r0, #1
#endif // AM_CMSIS_REGS

        //
        // Use some default assumptions to set the ITM frequency.
        //
        if ( (ui32ITMbitrate < AM_HAL_TPIU_BAUD_57600 )  ||
   1043e:	4921      	ldr	r1, [pc, #132]	; (104c4 <am_hal_tpiu_enable+0x98>)
             (ui32ITMbitrate > AM_HAL_TPIU_BAUD_2M ) )
        {
            ui32ITMbitrate = AM_HAL_TPIU_BAUD_DEFAULT;
   10440:	4c21      	ldr	r4, [pc, #132]	; (104c8 <am_hal_tpiu_enable+0x9c>)
        TPI->CSPSR = TPI_CSPSR_CWIDTH_1BIT;
   10442:	6050      	str	r0, [r2, #4]
        if ( (ui32ITMbitrate < AM_HAL_TPIU_BAUD_57600 )  ||
   10444:	f5a3 4c61 	sub.w	ip, r3, #57600	; 0xe100
        }

        //
        // Get the current HFRC frequency.
        //
        am_hal_clkgen_status_get(&sClkGenStatus);
   10448:	a801      	add	r0, sp, #4
            ui32ITMbitrate = AM_HAL_TPIU_BAUD_DEFAULT;
   1044a:	458c      	cmp	ip, r1
   1044c:	bf98      	it	ls
   1044e:	461c      	movls	r4, r3
        am_hal_clkgen_status_get(&sClkGenStatus);
   10450:	f7fe f904 	bl	e65c <am_hal_clkgen_status_get>
        ui32HFRC = sClkGenStatus.ui32SysclkFreq;
   10454:	9b01      	ldr	r3, [sp, #4]

        //
        // Compute the SWO scaler value.
        //
        if ( ui32HFRC != 0xFFFFFFFF )
   10456:	1c5a      	adds	r2, r3, #1
   10458:	d02f      	beq.n	104ba <am_hal_tpiu_enable+0x8e>
        {
            ui32SWOscaler = ((ui32HFRC / 8) / ui32ITMbitrate) - 1;
   1045a:	08da      	lsrs	r2, r3, #3
   1045c:	fbb2 fef4 	udiv	lr, r2, r4
   10460:	f10e 31ff 	add.w	r1, lr, #4294967295
   10464:	b288      	uxth	r0, r1

#if AM_CMSIS_REGS
        //
        // Set the scaler value.
        //
        TPI->ACPR = _VAL2FLD(TPI_ACPR_SWOSCALER, ui32SWOscaler);
   10466:	4a16      	ldr	r2, [pc, #88]	; (104c0 <am_hal_tpiu_enable+0x94>)

        //
        // Enable the TPIU clock source in MCU control.
        // Set TPIU clock for HFRC/8 (6MHz) operation.
        //
        MCUCTRL->TPIUCTRL =
   10468:	4918      	ldr	r1, [pc, #96]	; (104cc <am_hal_tpiu_enable+0xa0>)
        TPI->ACPR = _VAL2FLD(TPI_ACPR_SWOSCALER, ui32SWOscaler);
   1046a:	6110      	str	r0, [r2, #16]
        MCUCTRL->TPIUCTRL =
   1046c:	f240 2301 	movw	r3, #513	; 0x201
        TPI->SPPR = _VAL2FLD( TPI_SPPR_TXMODE, TPI_SPPR_TXMODE_UART);
   10470:	2402      	movs	r4, #2
        TPI->ITCTRL = _VAL2FLD(TPI_ITCTRL_Mode, TPI_ITCTRL_Mode_NORMAL);
   10472:	2000      	movs	r0, #0
        TPI->SPPR = _VAL2FLD( TPI_SPPR_TXMODE, TPI_SPPR_TXMODE_UART);
   10474:	f8c2 40f0 	str.w	r4, [r2, #240]	; 0xf0
        TPI->ITCTRL = _VAL2FLD(TPI_ITCTRL_Mode, TPI_ITCTRL_Mode_NORMAL);
   10478:	f8c2 0f00 	str.w	r0, [r2, #3840]	; 0xf00
        MCUCTRL->TPIUCTRL =
   1047c:	f8c1 3250 	str.w	r3, [r1, #592]	; 0x250
    }

    //
    // Wait for 50us for the data to flush out.
    //
    am_hal_flash_delay(FLASH_CYCLES_US(50));
   10480:	f240 20f7 	movw	r0, #759	; 0x2f7
   10484:	f7fe face 	bl	ea24 <am_hal_flash_delay>
}
   10488:	b004      	add	sp, #16
   1048a:	bd10      	pop	{r4, pc}
        TPI->ACPR = psConfig->ui32ClockPrescaler;
   1048c:	6904      	ldr	r4, [r0, #16]
   1048e:	6114      	str	r4, [r2, #16]
        TPI->SPPR = psConfig->ui32PinProtocol;
   10490:	6883      	ldr	r3, [r0, #8]
   10492:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
        TPI->CSPSR = (1 << (psConfig->ui32ParallelPortSize - 1));
   10496:	68c1      	ldr	r1, [r0, #12]
        MCUCTRL->TPIUCTRL |= psConfig->ui32TraceClkIn;
   10498:	4c0c      	ldr	r4, [pc, #48]	; (104cc <am_hal_tpiu_enable+0xa0>)
        TPI->CSPSR = (1 << (psConfig->ui32ParallelPortSize - 1));
   1049a:	3901      	subs	r1, #1
   1049c:	2301      	movs	r3, #1
   1049e:	408b      	lsls	r3, r1
   104a0:	6053      	str	r3, [r2, #4]
        MCUCTRL->TPIUCTRL |= psConfig->ui32TraceClkIn;
   104a2:	6840      	ldr	r0, [r0, #4]
   104a4:	f8d4 2250 	ldr.w	r2, [r4, #592]	; 0x250
   104a8:	4302      	orrs	r2, r0
   104aa:	f8c4 2250 	str.w	r2, [r4, #592]	; 0x250
    am_hal_flash_delay(FLASH_CYCLES_US(50));
   104ae:	f240 20f7 	movw	r0, #759	; 0x2f7
   104b2:	f7fe fab7 	bl	ea24 <am_hal_flash_delay>
}
   104b6:	b004      	add	sp, #16
   104b8:	bd10      	pop	{r4, pc}
   104ba:	2005      	movs	r0, #5
   104bc:	e7d3      	b.n	10466 <am_hal_tpiu_enable+0x3a>
   104be:	bf00      	nop
   104c0:	e0040000 	.word	0xe0040000
   104c4:	001da380 	.word	0x001da380
   104c8:	000f4240 	.word	0x000f4240
   104cc:	40020000 	.word	0x40020000

000104d0 <am_hal_cmdq_init>:
//*****************************************************************************
uint32_t am_hal_cmdq_init(am_hal_cmdq_if_e hwIf, am_hal_cmdq_cfg_t *pCfg, void **ppHandle)
{
    am_hal_cmdq_t *pCmdQ;
#ifndef AM_HAL_DISABLE_API_VALIDATION
    if (hwIf >= AM_HAL_CMDQ_IF_MAX)
   104d0:	2807      	cmp	r0, #7
   104d2:	d901      	bls.n	104d8 <am_hal_cmdq_init+0x8>
    {
        return AM_HAL_STATUS_OUT_OF_RANGE;
   104d4:	2005      	movs	r0, #5
   104d6:	4770      	bx	lr
    }
    if (!pCfg || !pCfg->pCmdQBuf || !ppHandle || (pCfg->cmdQSize < 2))
   104d8:	b1c1      	cbz	r1, 1050c <am_hal_cmdq_init+0x3c>
{
   104da:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if (!pCfg || !pCfg->pCmdQBuf || !ppHandle || (pCfg->cmdQSize < 2))
   104de:	684c      	ldr	r4, [r1, #4]
   104e0:	b18c      	cbz	r4, 10506 <am_hal_cmdq_init+0x36>
   104e2:	b182      	cbz	r2, 10506 <am_hal_cmdq_init+0x36>
   104e4:	680e      	ldr	r6, [r1, #0]
   104e6:	2e01      	cmp	r6, #1
   104e8:	d90d      	bls.n	10506 <am_hal_cmdq_init+0x36>
    {
        return AM_HAL_STATUS_INVALID_ARG;
    }
    if (gAmHalCmdq[hwIf].prefix.s.bInit)
   104ea:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   104ee:	f8df e08c 	ldr.w	lr, [pc, #140]	; 1057c <am_hal_cmdq_init+0xac>
   104f2:	00c3      	lsls	r3, r0, #3
   104f4:	eb0e 0503 	add.w	r5, lr, r3
   104f8:	78ef      	ldrb	r7, [r5, #3]
   104fa:	f017 0001 	ands.w	r0, r7, #1
   104fe:	d007      	beq.n	10510 <am_hal_cmdq_init+0x40>
    {
        return AM_HAL_STATUS_INVALID_OPERATION;
   10500:	2007      	movs	r0, #7
    AM_REGVAL(pCmdQ->pReg->regCQCfg) =
        (((pCfg->priority) << AM_REG_IOM_CQCFG_CQPRI_S) & AM_REG_IOM_CQCFG_CQPRI_M);
#endif // AM_CMSIS_REGS
    *ppHandle = pCmdQ;
    return AM_HAL_STATUS_SUCCESS;
}
   10502:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return AM_HAL_STATUS_INVALID_ARG;
   10506:	2006      	movs	r0, #6
   10508:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1050c:	2006      	movs	r0, #6
   1050e:	4770      	bx	lr
    pCmdQ->prefix.s.bEnable = false;
   10510:	f047 0701 	orr.w	r7, r7, #1
    pCmdQ->cmdQSize = pCfg->cmdQSize * sizeof(am_hal_cmdq_entry_t);
   10514:	00f6      	lsls	r6, r6, #3
    pCmdQ->prefix.s.bEnable = false;
   10516:	f360 0741 	bfi	r7, r0, #1, #1
   1051a:	70ef      	strb	r7, [r5, #3]
    pCmdQ->cmdQBufEnd = (uint32_t)pCfg->pCmdQBuf + pCfg->cmdQSize * sizeof(am_hal_cmdq_entry_t);
   1051c:	eb06 0c04 	add.w	ip, r6, r4
    pCmdQ->pReg = &gAmHalCmdQReg[hwIf];
   10520:	4f15      	ldr	r7, [pc, #84]	; (10578 <am_hal_cmdq_init+0xa8>)
    pCmdQ->cmdQSize = pCfg->cmdQSize * sizeof(am_hal_cmdq_entry_t);
   10522:	61ae      	str	r6, [r5, #24]
    pCmdQ->cmdQTail = pCmdQ->cmdQNextTail = pCmdQ->cmdQHead = pCmdQ->cmdQBufStart = (uint32_t)pCfg->pCmdQBuf;
   10524:	606c      	str	r4, [r5, #4]
   10526:	60ec      	str	r4, [r5, #12]
   10528:	616c      	str	r4, [r5, #20]
   1052a:	612c      	str	r4, [r5, #16]
    pCmdQ->cmdQBufEnd = (uint32_t)pCfg->pCmdQBuf + pCfg->cmdQSize * sizeof(am_hal_cmdq_entry_t);
   1052c:	f8c5 c008 	str.w	ip, [r5, #8]
    pCmdQ->curIdx = 0;
   10530:	61e8      	str	r0, [r5, #28]
    pCmdQ->endIdx = 0;
   10532:	6228      	str	r0, [r5, #32]
    pCmdQ->prefix.s.magic = AM_HAL_MAGIC_CMDQ;
   10534:	f85e c003 	ldr.w	ip, [lr, r3]
   10538:	f8df 8044 	ldr.w	r8, [pc, #68]	; 10580 <am_hal_cmdq_init+0xb0>
    pCmdQ->pReg = &gAmHalCmdQReg[hwIf];
   1053c:	18fe      	adds	r6, r7, r3
    pCmdQ->prefix.s.magic = AM_HAL_MAGIC_CMDQ;
   1053e:	f368 0c17 	bfi	ip, r8, #0, #24
    AM_REGVAL(pCmdQ->pReg->regCQAddr) = (uint32_t)pCfg->pCmdQBuf;
   10542:	6877      	ldr	r7, [r6, #4]
    pCmdQ->prefix.s.magic = AM_HAL_MAGIC_CMDQ;
   10544:	f84e c003 	str.w	ip, [lr, r3]
    pCmdQ->pReg = &gAmHalCmdQReg[hwIf];
   10548:	626e      	str	r6, [r5, #36]	; 0x24
    AM_REGVAL(pCmdQ->pReg->regCQAddr) = (uint32_t)pCfg->pCmdQBuf;
   1054a:	603c      	str	r4, [r7, #0]
    AM_REGVAL(pCmdQ->pReg->regCurIdx) = 0;
   1054c:	6a6c      	ldr	r4, [r5, #36]	; 0x24
    AM_REGVAL(pCmdQ->pReg->regCQCfg) = _VAL2FLD(IOM0_CQCFG_CQPRI, pCfg->priority);
   1054e:	7a0b      	ldrb	r3, [r1, #8]
    AM_REGVAL(pCmdQ->pReg->regCurIdx) = 0;
   10550:	68a1      	ldr	r1, [r4, #8]
   10552:	6008      	str	r0, [r1, #0]
    AM_REGVAL(pCmdQ->pReg->regEndIdx) = 0;
   10554:	6a6e      	ldr	r6, [r5, #36]	; 0x24
   10556:	68f7      	ldr	r7, [r6, #12]
   10558:	6038      	str	r0, [r7, #0]
    AM_REGVAL(pCmdQ->pReg->regCQPause) |= pCmdQ->pReg->bitMaskCQPauseIdx;
   1055a:	6a69      	ldr	r1, [r5, #36]	; 0x24
   1055c:	690c      	ldr	r4, [r1, #16]
   1055e:	694e      	ldr	r6, [r1, #20]
   10560:	6827      	ldr	r7, [r4, #0]
   10562:	4337      	orrs	r7, r6
   10564:	6027      	str	r7, [r4, #0]
    AM_REGVAL(pCmdQ->pReg->regCQCfg) = _VAL2FLD(IOM0_CQCFG_CQPRI, pCfg->priority);
   10566:	6a69      	ldr	r1, [r5, #36]	; 0x24
   10568:	005b      	lsls	r3, r3, #1
   1056a:	680c      	ldr	r4, [r1, #0]
   1056c:	f003 0602 	and.w	r6, r3, #2
   10570:	6026      	str	r6, [r4, #0]
    *ppHandle = pCmdQ;
   10572:	6015      	str	r5, [r2, #0]
    return AM_HAL_STATUS_SUCCESS;
   10574:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   10578:	00010e34 	.word	0x00010e34
   1057c:	100011fc 	.word	0x100011fc
   10580:	00cdcdcd 	.word	0x00cdcdcd

00010584 <am_hal_cmdq_enable>:
//*****************************************************************************
uint32_t am_hal_cmdq_enable(void *pHandle)
{
    am_hal_cmdq_t *pCmdQ = (am_hal_cmdq_t *)pHandle;
#ifndef AM_HAL_DISABLE_API_VALIDATION
    if (!AM_HAL_CMDQ_CHK_HANDLE(pHandle))
   10584:	4603      	mov	r3, r0
   10586:	b128      	cbz	r0, 10594 <am_hal_cmdq_enable+0x10>
   10588:	6802      	ldr	r2, [r0, #0]
   1058a:	490c      	ldr	r1, [pc, #48]	; (105bc <am_hal_cmdq_enable+0x38>)
   1058c:	f022 407e 	bic.w	r0, r2, #4261412864	; 0xfe000000
   10590:	4288      	cmp	r0, r1
   10592:	d001      	beq.n	10598 <am_hal_cmdq_enable+0x14>
    {
        return AM_HAL_STATUS_INVALID_HANDLE;
   10594:	2002      	movs	r0, #2
   10596:	4770      	bx	lr
    }

    if (pCmdQ->prefix.s.bEnable)
   10598:	78da      	ldrb	r2, [r3, #3]
   1059a:	f012 0002 	ands.w	r0, r2, #2
   1059e:	d10a      	bne.n	105b6 <am_hal_cmdq_enable+0x32>
    {
        return AM_HAL_STATUS_SUCCESS;
    }
#endif
#if AM_CMSIS_REGS
    AM_REGVAL(pCmdQ->pReg->regCQCfg) |= _VAL2FLD(IOM0_CQCFG_CQEN, IOM0_CQCFG_CQEN_EN);
   105a0:	6a59      	ldr	r1, [r3, #36]	; 0x24
   105a2:	6809      	ldr	r1, [r1, #0]
   105a4:	680a      	ldr	r2, [r1, #0]
   105a6:	f042 0201 	orr.w	r2, r2, #1
   105aa:	600a      	str	r2, [r1, #0]
#else // AM_CMSIS_REGS
    AM_REGVAL(pCmdQ->pReg->regCQCfg) |= AM_REG_IOM_CQCFG_CQEN_EN;
#endif // AM_CMSIS_REGS
    pCmdQ->prefix.s.bEnable = true;
   105ac:	78d9      	ldrb	r1, [r3, #3]
   105ae:	f041 0202 	orr.w	r2, r1, #2
   105b2:	70da      	strb	r2, [r3, #3]
    return AM_HAL_STATUS_SUCCESS;
   105b4:	4770      	bx	lr
        return AM_HAL_STATUS_SUCCESS;
   105b6:	2000      	movs	r0, #0
}
   105b8:	4770      	bx	lr
   105ba:	bf00      	nop
   105bc:	01cdcdcd 	.word	0x01cdcdcd

000105c0 <am_hal_cmdq_disable>:
//*****************************************************************************
uint32_t am_hal_cmdq_disable(void *pHandle)
{
    am_hal_cmdq_t *pCmdQ = (am_hal_cmdq_t *)pHandle;
#ifndef AM_HAL_DISABLE_API_VALIDATION
    if (!AM_HAL_CMDQ_CHK_HANDLE(pHandle))
   105c0:	b128      	cbz	r0, 105ce <am_hal_cmdq_disable+0xe>
   105c2:	6803      	ldr	r3, [r0, #0]
   105c4:	4a0b      	ldr	r2, [pc, #44]	; (105f4 <am_hal_cmdq_disable+0x34>)
   105c6:	f023 417e 	bic.w	r1, r3, #4261412864	; 0xfe000000
   105ca:	4291      	cmp	r1, r2
   105cc:	d001      	beq.n	105d2 <am_hal_cmdq_disable+0x12>
    {
        return AM_HAL_STATUS_INVALID_HANDLE;
   105ce:	2002      	movs	r0, #2
   105d0:	4770      	bx	lr
    }

    if (!pCmdQ->prefix.s.bEnable)
   105d2:	f890 c003 	ldrb.w	ip, [r0, #3]
   105d6:	f01c 0302 	ands.w	r3, ip, #2
   105da:	d009      	beq.n	105f0 <am_hal_cmdq_disable+0x30>
    {
        return AM_HAL_STATUS_SUCCESS;
    }
#endif
#if AM_CMSIS_REGS
    AM_REGVAL(pCmdQ->pReg->regCQCfg) &= ~_VAL2FLD(IOM0_CQCFG_CQEN, IOM0_CQCFG_CQEN_EN);
   105dc:	6a43      	ldr	r3, [r0, #36]	; 0x24
   105de:	681a      	ldr	r2, [r3, #0]
   105e0:	6811      	ldr	r1, [r2, #0]
   105e2:	f021 0301 	bic.w	r3, r1, #1
   105e6:	6013      	str	r3, [r2, #0]
#else // AM_CMSIS_REGS
    AM_REGVAL(pCmdQ->pReg->regCQCfg) &= ~AM_REG_IOM_CQCFG_CQEN_EN;
#endif // AM_CMSIS_REGS
    pCmdQ->prefix.s.bEnable = false;
   105e8:	78c2      	ldrb	r2, [r0, #3]
   105ea:	f36f 0241 	bfc	r2, #1, #1
   105ee:	70c2      	strb	r2, [r0, #3]
    return AM_HAL_STATUS_SUCCESS;
   105f0:	2000      	movs	r0, #0
   105f2:	4770      	bx	lr
   105f4:	01cdcdcd 	.word	0x01cdcdcd

000105f8 <am_hal_cmdq_alloc_block>:
{
    am_hal_cmdq_t *pCmdQ = (am_hal_cmdq_t *)pHandle;
    am_hal_cmdq_entry_t *pCmdQEntry;
    uint32_t blockAddr;
#ifndef AM_HAL_DISABLE_API_VALIDATION
    if (!AM_HAL_CMDQ_CHK_HANDLE(pHandle))
   105f8:	b150      	cbz	r0, 10610 <am_hal_cmdq_alloc_block+0x18>
{
   105fa:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (!AM_HAL_CMDQ_CHK_HANDLE(pHandle))
   105fc:	6804      	ldr	r4, [r0, #0]
   105fe:	4d2d      	ldr	r5, [pc, #180]	; (106b4 <am_hal_cmdq_alloc_block+0xbc>)
   10600:	f024 467e 	bic.w	r6, r4, #4261412864	; 0xfe000000
   10604:	42ae      	cmp	r6, r5
{
   10606:	b083      	sub	sp, #12
    if (!AM_HAL_CMDQ_CHK_HANDLE(pHandle))
   10608:	d004      	beq.n	10614 <am_hal_cmdq_alloc_block+0x1c>
    {
        return AM_HAL_STATUS_INVALID_HANDLE;
   1060a:	2002      	movs	r0, #2
    }
    *ppBlock = (am_hal_cmdq_entry_t *)blockAddr;
    *pIdx = ++pCmdQ->endIdx;
    pCmdQ->cmdQNextTail = blockAddr + numCmd * sizeof(am_hal_cmdq_entry_t);
    return AM_HAL_STATUS_SUCCESS;
}
   1060c:	b003      	add	sp, #12
   1060e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return AM_HAL_STATUS_INVALID_HANDLE;
   10610:	2002      	movs	r0, #2
   10612:	4770      	bx	lr
    if (!ppBlock || !pIdx)
   10614:	b33a      	cbz	r2, 10666 <am_hal_cmdq_alloc_block+0x6e>
   10616:	b333      	cbz	r3, 10666 <am_hal_cmdq_alloc_block+0x6e>
    if (pCmdQ->cmdQTail != pCmdQ->cmdQNextTail)
   10618:	6907      	ldr	r7, [r0, #16]
   1061a:	6944      	ldr	r4, [r0, #20]
   1061c:	42a7      	cmp	r7, r4
        return AM_HAL_STATUS_INVALID_OPERATION;
   1061e:	bf18      	it	ne
   10620:	2007      	movne	r0, #7
    if (pCmdQ->cmdQTail != pCmdQ->cmdQNextTail)
   10622:	d1f3      	bne.n	1060c <am_hal_cmdq_alloc_block+0x14>
   10624:	4604      	mov	r4, r0
   10626:	461e      	mov	r6, r3
   10628:	4615      	mov	r5, r2
   1062a:	460f      	mov	r7, r1
    AM_CRITICAL_BEGIN
   1062c:	f7fe fcb4 	bl	ef98 <am_hal_interrupt_master_disable>
    hwCurIdx = AM_REGVAL(pCmdQ->pReg->regCurIdx) & AM_HAL_CMDQ_HW_IDX_MAX;
   10630:	6a61      	ldr	r1, [r4, #36]	; 0x24
    AM_CRITICAL_BEGIN
   10632:	9001      	str	r0, [sp, #4]
    hwCurIdx = AM_REGVAL(pCmdQ->pReg->regCurIdx) & AM_HAL_CMDQ_HW_IDX_MAX;
   10634:	688b      	ldr	r3, [r1, #8]
    pCmdQ->curIdx = (pCmdQ->endIdx & ~AM_HAL_CMDQ_HW_IDX_MAX) | hwCurIdx;
   10636:	6a20      	ldr	r0, [r4, #32]
    hwCurIdx = AM_REGVAL(pCmdQ->pReg->regCurIdx) & AM_HAL_CMDQ_HW_IDX_MAX;
   10638:	681a      	ldr	r2, [r3, #0]
    pCmdQ->cmdQHead = AM_REGVAL(pCmdQ->pReg->regCQAddr);
   1063a:	6849      	ldr	r1, [r1, #4]
    hwCurIdx = AM_REGVAL(pCmdQ->pReg->regCurIdx) & AM_HAL_CMDQ_HW_IDX_MAX;
   1063c:	b2d2      	uxtb	r2, r2
    pCmdQ->curIdx = (pCmdQ->endIdx & ~AM_HAL_CMDQ_HW_IDX_MAX) | hwCurIdx;
   1063e:	f020 03ff 	bic.w	r3, r0, #255	; 0xff
   10642:	4313      	orrs	r3, r2
    if (pCmdQ->endIdx < pCmdQ->curIdx)
   10644:	4298      	cmp	r0, r3
        pCmdQ->curIdx -= (AM_HAL_CMDQ_HW_IDX_MAX + 1);
   10646:	bf38      	it	cc
   10648:	f5a3 7380 	subcc.w	r3, r3, #256	; 0x100
   1064c:	61e3      	str	r3, [r4, #28]
    pCmdQ->cmdQHead = AM_REGVAL(pCmdQ->pReg->regCQAddr);
   1064e:	680b      	ldr	r3, [r1, #0]
   10650:	60e3      	str	r3, [r4, #12]
    AM_CRITICAL_END
   10652:	9801      	ldr	r0, [sp, #4]
   10654:	f7fe fca4 	bl	efa0 <am_hal_interrupt_master_set>
    if ((pCmdQ->endIdx - pCmdQ->curIdx) >= (AM_HAL_CMDQ_HW_IDX_MAX - 1))
   10658:	6a22      	ldr	r2, [r4, #32]
   1065a:	69e0      	ldr	r0, [r4, #28]
   1065c:	1a11      	subs	r1, r2, r0
   1065e:	29fd      	cmp	r1, #253	; 0xfd
   10660:	d903      	bls.n	1066a <am_hal_cmdq_alloc_block+0x72>
        return AM_HAL_STATUS_OUT_OF_RANGE;
   10662:	2005      	movs	r0, #5
   10664:	e7d2      	b.n	1060c <am_hal_cmdq_alloc_block+0x14>
        return AM_HAL_STATUS_INVALID_ARG;
   10666:	2006      	movs	r0, #6
   10668:	e7d0      	b.n	1060c <am_hal_cmdq_alloc_block+0x14>
    if (pCmdQ->cmdQTail >= pCmdQ->cmdQHead)
   1066a:	6923      	ldr	r3, [r4, #16]
   1066c:	f8d4 e00c 	ldr.w	lr, [r4, #12]
   10670:	4573      	cmp	r3, lr
   10672:	d319      	bcc.n	106a8 <am_hal_cmdq_alloc_block+0xb0>
        if ((pCmdQ->cmdQTail + (numCmd + 2)*sizeof(am_hal_cmdq_entry_t)) <= pCmdQ->cmdQBufEnd)
   10674:	1cb9      	adds	r1, r7, #2
   10676:	00c9      	lsls	r1, r1, #3
   10678:	68a0      	ldr	r0, [r4, #8]
   1067a:	eb03 0c01 	add.w	ip, r3, r1
   1067e:	4584      	cmp	ip, r0
   10680:	d909      	bls.n	10696 <am_hal_cmdq_alloc_block+0x9e>
            if ((pCmdQ->cmdQBufStart + (numCmd + 1) * sizeof(am_hal_cmdq_entry_t)) < pCmdQ->cmdQHead)
   10682:	6860      	ldr	r0, [r4, #4]
   10684:	3908      	subs	r1, #8
   10686:	4401      	add	r1, r0
   10688:	458e      	cmp	lr, r1
   1068a:	d9ea      	bls.n	10662 <am_hal_cmdq_alloc_block+0x6a>
                pCmdQEntry->address = (uint32_t)pCmdQ->pReg->regCQAddr;
   1068c:	6a61      	ldr	r1, [r4, #36]	; 0x24
   1068e:	6849      	ldr	r1, [r1, #4]
   10690:	6019      	str	r1, [r3, #0]
                pCmdQEntry->value = pCmdQ->cmdQBufStart;
   10692:	6058      	str	r0, [r3, #4]
                blockAddr = pCmdQ->cmdQBufStart;
   10694:	4603      	mov	r3, r0
    *pIdx = ++pCmdQ->endIdx;
   10696:	3201      	adds	r2, #1
    pCmdQ->cmdQNextTail = blockAddr + numCmd * sizeof(am_hal_cmdq_entry_t);
   10698:	eb03 07c7 	add.w	r7, r3, r7, lsl #3
    *ppBlock = (am_hal_cmdq_entry_t *)blockAddr;
   1069c:	602b      	str	r3, [r5, #0]
    return AM_HAL_STATUS_SUCCESS;
   1069e:	2000      	movs	r0, #0
    *pIdx = ++pCmdQ->endIdx;
   106a0:	6222      	str	r2, [r4, #32]
   106a2:	6032      	str	r2, [r6, #0]
    pCmdQ->cmdQNextTail = blockAddr + numCmd * sizeof(am_hal_cmdq_entry_t);
   106a4:	6167      	str	r7, [r4, #20]
    return AM_HAL_STATUS_SUCCESS;
   106a6:	e7b1      	b.n	1060c <am_hal_cmdq_alloc_block+0x14>
        if ((pCmdQ->cmdQTail + (numCmd + 1) * sizeof(am_hal_cmdq_entry_t)) < pCmdQ->cmdQHead)
   106a8:	1c78      	adds	r0, r7, #1
   106aa:	eb03 0cc0 	add.w	ip, r3, r0, lsl #3
   106ae:	45e6      	cmp	lr, ip
   106b0:	d9d7      	bls.n	10662 <am_hal_cmdq_alloc_block+0x6a>
   106b2:	e7f0      	b.n	10696 <am_hal_cmdq_alloc_block+0x9e>
   106b4:	01cdcdcd 	.word	0x01cdcdcd

000106b8 <am_hal_cmdq_release_block>:
//*****************************************************************************
uint32_t am_hal_cmdq_release_block(void *pHandle)
{
    am_hal_cmdq_t *pCmdQ = (am_hal_cmdq_t *)pHandle;
#ifndef AM_HAL_DISABLE_API_VALIDATION
    if (!AM_HAL_CMDQ_CHK_HANDLE(pHandle))
   106b8:	b128      	cbz	r0, 106c6 <am_hal_cmdq_release_block+0xe>
   106ba:	6803      	ldr	r3, [r0, #0]
   106bc:	4a09      	ldr	r2, [pc, #36]	; (106e4 <am_hal_cmdq_release_block+0x2c>)
   106be:	f023 417e 	bic.w	r1, r3, #4261412864	; 0xfe000000
   106c2:	4291      	cmp	r1, r2
   106c4:	d001      	beq.n	106ca <am_hal_cmdq_release_block+0x12>
    {
        return AM_HAL_STATUS_INVALID_HANDLE;
   106c6:	2002      	movs	r0, #2
   106c8:	4770      	bx	lr
    }
    if (pCmdQ->cmdQTail == pCmdQ->cmdQNextTail)
   106ca:	6903      	ldr	r3, [r0, #16]
   106cc:	6942      	ldr	r2, [r0, #20]
   106ce:	4293      	cmp	r3, r2
   106d0:	d005      	beq.n	106de <am_hal_cmdq_release_block+0x26>
        return AM_HAL_STATUS_INVALID_OPERATION;
    }
#endif
    // Free up the block
    pCmdQ->cmdQNextTail = pCmdQ->cmdQTail;
    pCmdQ->endIdx--;
   106d2:	6a01      	ldr	r1, [r0, #32]
    pCmdQ->cmdQNextTail = pCmdQ->cmdQTail;
   106d4:	6143      	str	r3, [r0, #20]
    pCmdQ->endIdx--;
   106d6:	1e4b      	subs	r3, r1, #1
   106d8:	6203      	str	r3, [r0, #32]

    return AM_HAL_STATUS_SUCCESS;
   106da:	2000      	movs	r0, #0
   106dc:	4770      	bx	lr
        return AM_HAL_STATUS_INVALID_OPERATION;
   106de:	2007      	movs	r0, #7
}
   106e0:	4770      	bx	lr
   106e2:	bf00      	nop
   106e4:	01cdcdcd 	.word	0x01cdcdcd

000106e8 <am_hal_cmdq_post_block>:
uint32_t am_hal_cmdq_post_block(void *pHandle, bool bInt)
{
    am_hal_cmdq_t *pCmdQ = (am_hal_cmdq_t *)pHandle;
    am_hal_cmdq_entry_t *pCmdQEntry;
#ifndef AM_HAL_DISABLE_API_VALIDATION
    if (!AM_HAL_CMDQ_CHK_HANDLE(pHandle))
   106e8:	b130      	cbz	r0, 106f8 <am_hal_cmdq_post_block+0x10>
   106ea:	6802      	ldr	r2, [r0, #0]
   106ec:	4603      	mov	r3, r0
   106ee:	480f      	ldr	r0, [pc, #60]	; (1072c <am_hal_cmdq_post_block+0x44>)
   106f0:	f022 4c7e 	bic.w	ip, r2, #4261412864	; 0xfe000000
   106f4:	4584      	cmp	ip, r0
   106f6:	d001      	beq.n	106fc <am_hal_cmdq_post_block+0x14>
    {
        return AM_HAL_STATUS_INVALID_HANDLE;
   106f8:	2002      	movs	r0, #2
   106fa:	4770      	bx	lr
    }
    if (pCmdQ->cmdQTail == pCmdQ->cmdQNextTail)
   106fc:	695a      	ldr	r2, [r3, #20]
   106fe:	6918      	ldr	r0, [r3, #16]
   10700:	4290      	cmp	r0, r2
   10702:	d010      	beq.n	10726 <am_hal_cmdq_post_block+0x3e>
{
   10704:	b470      	push	{r4, r5, r6}
    }
#endif
    // CmdQ entries have already been populated. Just need to inform hardware of the new endIdx
    // Fill up the index update entry
    pCmdQEntry = (am_hal_cmdq_entry_t *)pCmdQ->cmdQNextTail;
    pCmdQEntry->address = ((uint32_t)pCmdQ->pReg->regCurIdx) | (bInt ? 1 : 0);
   10706:	6a5d      	ldr	r5, [r3, #36]	; 0x24
    pCmdQEntry->value = pCmdQ->endIdx;
   10708:	6a18      	ldr	r0, [r3, #32]
    pCmdQEntry->address = ((uint32_t)pCmdQ->pReg->regCurIdx) | (bInt ? 1 : 0);
   1070a:	68ac      	ldr	r4, [r5, #8]
    // cmdQNextTail should now point to the first entry after the allocated block
    pCmdQ->cmdQTail = pCmdQ->cmdQNextTail = (uint32_t)(pCmdQEntry + 1);
    AM_REGVAL(pCmdQ->pReg->regEndIdx) = pCmdQ->endIdx & AM_HAL_CMDQ_HW_IDX_MAX;
   1070c:	68ee      	ldr	r6, [r5, #12]
    pCmdQEntry->value = pCmdQ->endIdx;
   1070e:	6050      	str	r0, [r2, #4]
    pCmdQ->cmdQTail = pCmdQ->cmdQNextTail = (uint32_t)(pCmdQEntry + 1);
   10710:	f102 0508 	add.w	r5, r2, #8
    pCmdQEntry->address = ((uint32_t)pCmdQ->pReg->regCurIdx) | (bInt ? 1 : 0);
   10714:	4321      	orrs	r1, r4
    AM_REGVAL(pCmdQ->pReg->regEndIdx) = pCmdQ->endIdx & AM_HAL_CMDQ_HW_IDX_MAX;
   10716:	b2c4      	uxtb	r4, r0
    pCmdQEntry->address = ((uint32_t)pCmdQ->pReg->regCurIdx) | (bInt ? 1 : 0);
   10718:	6011      	str	r1, [r2, #0]
    return AM_HAL_STATUS_SUCCESS;
   1071a:	2000      	movs	r0, #0
    pCmdQ->cmdQTail = pCmdQ->cmdQNextTail = (uint32_t)(pCmdQEntry + 1);
   1071c:	615d      	str	r5, [r3, #20]
   1071e:	611d      	str	r5, [r3, #16]
    AM_REGVAL(pCmdQ->pReg->regEndIdx) = pCmdQ->endIdx & AM_HAL_CMDQ_HW_IDX_MAX;
   10720:	6034      	str	r4, [r6, #0]
}
   10722:	bc70      	pop	{r4, r5, r6}
   10724:	4770      	bx	lr
        return AM_HAL_STATUS_INVALID_OPERATION;
   10726:	2007      	movs	r0, #7
   10728:	4770      	bx	lr
   1072a:	bf00      	nop
   1072c:	01cdcdcd 	.word	0x01cdcdcd

00010730 <am_hal_cmdq_get_status>:
uint32_t am_hal_cmdq_get_status(void *pHandle, am_hal_cmdq_status_t *pStatus)
{
    am_hal_cmdq_t *pCmdQ = (am_hal_cmdq_t *)pHandle;
    uint32_t status;
#ifndef AM_HAL_DISABLE_API_VALIDATION
    if (!AM_HAL_CMDQ_CHK_HANDLE(pHandle))
   10730:	b128      	cbz	r0, 1073e <am_hal_cmdq_get_status+0xe>
   10732:	6803      	ldr	r3, [r0, #0]
   10734:	4a23      	ldr	r2, [pc, #140]	; (107c4 <am_hal_cmdq_get_status+0x94>)
   10736:	f023 4c7e 	bic.w	ip, r3, #4261412864	; 0xfe000000
   1073a:	4594      	cmp	ip, r2
   1073c:	d001      	beq.n	10742 <am_hal_cmdq_get_status+0x12>
    {
        return AM_HAL_STATUS_INVALID_HANDLE;
   1073e:	2002      	movs	r0, #2
   10740:	4770      	bx	lr
    }
    if (!pStatus)
   10742:	2900      	cmp	r1, #0
   10744:	d03c      	beq.n	107c0 <am_hal_cmdq_get_status+0x90>
{
   10746:	b570      	push	{r4, r5, r6, lr}
   10748:	4604      	mov	r4, r0
   1074a:	b082      	sub	sp, #8
   1074c:	460d      	mov	r5, r1
    AM_CRITICAL_BEGIN
   1074e:	f7fe fc23 	bl	ef98 <am_hal_interrupt_master_disable>
    hwCurIdx = AM_REGVAL(pCmdQ->pReg->regCurIdx) & AM_HAL_CMDQ_HW_IDX_MAX;
   10752:	6a61      	ldr	r1, [r4, #36]	; 0x24
    AM_CRITICAL_BEGIN
   10754:	9001      	str	r0, [sp, #4]
    hwCurIdx = AM_REGVAL(pCmdQ->pReg->regCurIdx) & AM_HAL_CMDQ_HW_IDX_MAX;
   10756:	688e      	ldr	r6, [r1, #8]
    pCmdQ->curIdx = (pCmdQ->endIdx & ~AM_HAL_CMDQ_HW_IDX_MAX) | hwCurIdx;
   10758:	6a20      	ldr	r0, [r4, #32]
    hwCurIdx = AM_REGVAL(pCmdQ->pReg->regCurIdx) & AM_HAL_CMDQ_HW_IDX_MAX;
   1075a:	6832      	ldr	r2, [r6, #0]
    pCmdQ->cmdQHead = AM_REGVAL(pCmdQ->pReg->regCQAddr);
   1075c:	6849      	ldr	r1, [r1, #4]
    hwCurIdx = AM_REGVAL(pCmdQ->pReg->regCurIdx) & AM_HAL_CMDQ_HW_IDX_MAX;
   1075e:	b2d6      	uxtb	r6, r2
    pCmdQ->curIdx = (pCmdQ->endIdx & ~AM_HAL_CMDQ_HW_IDX_MAX) | hwCurIdx;
   10760:	f020 03ff 	bic.w	r3, r0, #255	; 0xff
   10764:	4333      	orrs	r3, r6
    if (pCmdQ->endIdx < pCmdQ->curIdx)
   10766:	4298      	cmp	r0, r3
        pCmdQ->curIdx -= (AM_HAL_CMDQ_HW_IDX_MAX + 1);
   10768:	bf38      	it	cc
   1076a:	f5a3 7380 	subcc.w	r3, r3, #256	; 0x100
   1076e:	61e3      	str	r3, [r4, #28]
    pCmdQ->cmdQHead = AM_REGVAL(pCmdQ->pReg->regCQAddr);
   10770:	680a      	ldr	r2, [r1, #0]
   10772:	60e2      	str	r2, [r4, #12]
    AM_CRITICAL_END
   10774:	9801      	ldr	r0, [sp, #4]
   10776:	f7fe fc13 	bl	efa0 <am_hal_interrupt_master_set>
#endif
    update_indices(pCmdQ);
    pStatus->lastIdxProcessed = pCmdQ->curIdx;
    pStatus->lastIdxAllocated = pCmdQ->endIdx;
    pStatus->lastIdxPosted = pCmdQ->endIdx - ((pCmdQ->cmdQNextTail == pCmdQ->cmdQTail) ? 0 : 1);
    status = AM_REGVAL(pCmdQ->pReg->regCQStat);
   1077a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    pStatus->lastIdxAllocated = pCmdQ->endIdx;
   1077c:	6a21      	ldr	r1, [r4, #32]
    pStatus->lastIdxPosted = pCmdQ->endIdx - ((pCmdQ->cmdQNextTail == pCmdQ->cmdQTail) ? 0 : 1);
   1077e:	6926      	ldr	r6, [r4, #16]
   10780:	6962      	ldr	r2, [r4, #20]
    status = AM_REGVAL(pCmdQ->pReg->regCQStat);
   10782:	6998      	ldr	r0, [r3, #24]
    pStatus->lastIdxProcessed = pCmdQ->curIdx;
   10784:	69e4      	ldr	r4, [r4, #28]
   10786:	602c      	str	r4, [r5, #0]
    pStatus->lastIdxPosted = pCmdQ->endIdx - ((pCmdQ->cmdQNextTail == pCmdQ->cmdQTail) ? 0 : 1);
   10788:	42b2      	cmp	r2, r6
   1078a:	bf0c      	ite	eq
   1078c:	460a      	moveq	r2, r1
   1078e:	1e4a      	subne	r2, r1, #1
    pStatus->lastIdxAllocated = pCmdQ->endIdx;
   10790:	60a9      	str	r1, [r5, #8]
    pStatus->lastIdxPosted = pCmdQ->endIdx - ((pCmdQ->cmdQNextTail == pCmdQ->cmdQTail) ? 0 : 1);
   10792:	606a      	str	r2, [r5, #4]
    status = AM_REGVAL(pCmdQ->pReg->regCQStat);
   10794:	6806      	ldr	r6, [r0, #0]
    pStatus->bTIP = status & pCmdQ->pReg->bitMaskCQStatTIP;
   10796:	69dc      	ldr	r4, [r3, #28]
    pStatus->bPaused = status & pCmdQ->pReg->bitMaskCQStatPaused;
   10798:	6a59      	ldr	r1, [r3, #36]	; 0x24
    pStatus->bErr = status & pCmdQ->pReg->bitMaskCQStatErr;
   1079a:	6a1b      	ldr	r3, [r3, #32]
    pStatus->bTIP = status & pCmdQ->pReg->bitMaskCQStatTIP;
   1079c:	4226      	tst	r6, r4
   1079e:	bf14      	ite	ne
   107a0:	2401      	movne	r4, #1
   107a2:	2400      	moveq	r4, #0
    pStatus->bPaused = status & pCmdQ->pReg->bitMaskCQStatPaused;
   107a4:	420e      	tst	r6, r1
   107a6:	bf14      	ite	ne
   107a8:	2101      	movne	r1, #1
   107aa:	2100      	moveq	r1, #0
    pStatus->bErr = status & pCmdQ->pReg->bitMaskCQStatErr;
   107ac:	421e      	tst	r6, r3
   107ae:	bf14      	ite	ne
   107b0:	2301      	movne	r3, #1
   107b2:	2300      	moveq	r3, #0

    return AM_HAL_STATUS_SUCCESS;
   107b4:	2000      	movs	r0, #0
    pStatus->bTIP = status & pCmdQ->pReg->bitMaskCQStatTIP;
   107b6:	732c      	strb	r4, [r5, #12]
    pStatus->bPaused = status & pCmdQ->pReg->bitMaskCQStatPaused;
   107b8:	7369      	strb	r1, [r5, #13]
    pStatus->bErr = status & pCmdQ->pReg->bitMaskCQStatErr;
   107ba:	73ab      	strb	r3, [r5, #14]
}
   107bc:	b002      	add	sp, #8
   107be:	bd70      	pop	{r4, r5, r6, pc}
        return AM_HAL_STATUS_INVALID_ARG;
   107c0:	2006      	movs	r0, #6
   107c2:	4770      	bx	lr
   107c4:	01cdcdcd 	.word	0x01cdcdcd

000107c8 <am_hal_cmdq_term>:
//*****************************************************************************
uint32_t am_hal_cmdq_term(void *pHandle, bool bForce)
{
    am_hal_cmdq_t *pCmdQ = (am_hal_cmdq_t *)pHandle;
#ifndef AM_HAL_DISABLE_API_VALIDATION
    if (!AM_HAL_CMDQ_CHK_HANDLE(pHandle))
   107c8:	b128      	cbz	r0, 107d6 <am_hal_cmdq_term+0xe>
   107ca:	6803      	ldr	r3, [r0, #0]
   107cc:	4a1b      	ldr	r2, [pc, #108]	; (1083c <am_hal_cmdq_term+0x74>)
   107ce:	f023 4c7e 	bic.w	ip, r3, #4261412864	; 0xfe000000
   107d2:	4594      	cmp	ip, r2
   107d4:	d001      	beq.n	107da <am_hal_cmdq_term+0x12>
    {
        return AM_HAL_STATUS_INVALID_HANDLE;
   107d6:	2002      	movs	r0, #2
   107d8:	4770      	bx	lr
{
   107da:	b530      	push	{r4, r5, lr}
   107dc:	4604      	mov	r4, r0
   107de:	b083      	sub	sp, #12
   107e0:	460d      	mov	r5, r1
    AM_CRITICAL_BEGIN
   107e2:	f7fe fbd9 	bl	ef98 <am_hal_interrupt_master_disable>
    hwCurIdx = AM_REGVAL(pCmdQ->pReg->regCurIdx) & AM_HAL_CMDQ_HW_IDX_MAX;
   107e6:	6a61      	ldr	r1, [r4, #36]	; 0x24
    AM_CRITICAL_BEGIN
   107e8:	9001      	str	r0, [sp, #4]
    hwCurIdx = AM_REGVAL(pCmdQ->pReg->regCurIdx) & AM_HAL_CMDQ_HW_IDX_MAX;
   107ea:	688b      	ldr	r3, [r1, #8]
    pCmdQ->curIdx = (pCmdQ->endIdx & ~AM_HAL_CMDQ_HW_IDX_MAX) | hwCurIdx;
   107ec:	6a20      	ldr	r0, [r4, #32]
    hwCurIdx = AM_REGVAL(pCmdQ->pReg->regCurIdx) & AM_HAL_CMDQ_HW_IDX_MAX;
   107ee:	681a      	ldr	r2, [r3, #0]
    pCmdQ->cmdQHead = AM_REGVAL(pCmdQ->pReg->regCQAddr);
   107f0:	6849      	ldr	r1, [r1, #4]
    pCmdQ->curIdx = (pCmdQ->endIdx & ~AM_HAL_CMDQ_HW_IDX_MAX) | hwCurIdx;
   107f2:	f020 03ff 	bic.w	r3, r0, #255	; 0xff
    hwCurIdx = AM_REGVAL(pCmdQ->pReg->regCurIdx) & AM_HAL_CMDQ_HW_IDX_MAX;
   107f6:	b2d2      	uxtb	r2, r2
    pCmdQ->curIdx = (pCmdQ->endIdx & ~AM_HAL_CMDQ_HW_IDX_MAX) | hwCurIdx;
   107f8:	4313      	orrs	r3, r2
    if (pCmdQ->endIdx < pCmdQ->curIdx)
   107fa:	4298      	cmp	r0, r3
        pCmdQ->curIdx -= (AM_HAL_CMDQ_HW_IDX_MAX + 1);
   107fc:	bf38      	it	cc
   107fe:	f5a3 7380 	subcc.w	r3, r3, #256	; 0x100
   10802:	61e3      	str	r3, [r4, #28]
    pCmdQ->cmdQHead = AM_REGVAL(pCmdQ->pReg->regCQAddr);
   10804:	680b      	ldr	r3, [r1, #0]
   10806:	60e3      	str	r3, [r4, #12]
    AM_CRITICAL_END
   10808:	9801      	ldr	r0, [sp, #4]
   1080a:	f7fe fbc9 	bl	efa0 <am_hal_interrupt_master_set>
    }
#endif
    update_indices(pCmdQ);
    if (!bForce && (pCmdQ->curIdx != pCmdQ->endIdx))
   1080e:	b92d      	cbnz	r5, 1081c <am_hal_cmdq_term+0x54>
   10810:	69e5      	ldr	r5, [r4, #28]
   10812:	6a20      	ldr	r0, [r4, #32]
   10814:	4285      	cmp	r5, r0
   10816:	d001      	beq.n	1081c <am_hal_cmdq_term+0x54>
    {
        return AM_HAL_STATUS_IN_USE;
   10818:	2003      	movs	r0, #3
   1081a:	e00d      	b.n	10838 <am_hal_cmdq_term+0x70>
    }
    pCmdQ->prefix.s.bInit = false;
   1081c:	78e2      	ldrb	r2, [r4, #3]
    // Disable Command Queue
#if AM_CMSIS_REGS
    AM_REGVAL(pCmdQ->pReg->regCQCfg) = _VAL2FLD(IOM0_CQCFG_CQEN, IOM0_CQCFG_CQEN_DIS);
   1081e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    pCmdQ->prefix.s.bInit = false;
   10820:	f36f 0200 	bfc	r2, #0, #1
   10824:	70e2      	strb	r2, [r4, #3]
    AM_REGVAL(pCmdQ->pReg->regCQCfg) = _VAL2FLD(IOM0_CQCFG_CQEN, IOM0_CQCFG_CQEN_DIS);
   10826:	681c      	ldr	r4, [r3, #0]
#else // AM_CMSIS_REGS
    AM_REGVAL(pCmdQ->pReg->regCQCfg) = AM_REG_IOM_CQCFG_CQEN_DIS;
#endif // AM_CMSIS_REGS
    AM_REGVAL(pCmdQ->pReg->regCQPause) &= ~pCmdQ->pReg->bitMaskCQPauseIdx;
   10828:	691d      	ldr	r5, [r3, #16]
    AM_REGVAL(pCmdQ->pReg->regCQCfg) = _VAL2FLD(IOM0_CQCFG_CQEN, IOM0_CQCFG_CQEN_DIS);
   1082a:	2000      	movs	r0, #0
   1082c:	6020      	str	r0, [r4, #0]
    AM_REGVAL(pCmdQ->pReg->regCQPause) &= ~pCmdQ->pReg->bitMaskCQPauseIdx;
   1082e:	6959      	ldr	r1, [r3, #20]
   10830:	682a      	ldr	r2, [r5, #0]
   10832:	ea22 0301 	bic.w	r3, r2, r1
   10836:	602b      	str	r3, [r5, #0]
    return AM_HAL_STATUS_SUCCESS;
}
   10838:	b003      	add	sp, #12
   1083a:	bd30      	pop	{r4, r5, pc}
   1083c:	01cdcdcd 	.word	0x01cdcdcd

00010840 <am_hal_cmdq_error_resume>:
uint32_t am_hal_cmdq_error_resume(void *pHandle)
{
    am_hal_cmdq_t *pCmdQ = (am_hal_cmdq_t *)pHandle;
    am_hal_cmdq_entry_t *pCQAddr;
#ifndef AM_HAL_DISABLE_API_VALIDATION
    if (!AM_HAL_CMDQ_CHK_HANDLE(pHandle))
   10840:	b128      	cbz	r0, 1084e <am_hal_cmdq_error_resume+0xe>
   10842:	6803      	ldr	r3, [r0, #0]
   10844:	4a16      	ldr	r2, [pc, #88]	; (108a0 <am_hal_cmdq_error_resume+0x60>)
   10846:	f023 417e 	bic.w	r1, r3, #4261412864	; 0xfe000000
   1084a:	4291      	cmp	r1, r2
   1084c:	d001      	beq.n	10852 <am_hal_cmdq_error_resume+0x12>
    {
        return AM_HAL_STATUS_INVALID_HANDLE;
   1084e:	2002      	movs	r0, #2
   10850:	4770      	bx	lr
    }

    if (!pCmdQ->prefix.s.bEnable)
   10852:	f890 c003 	ldrb.w	ip, [r0, #3]
   10856:	f01c 0302 	ands.w	r3, ip, #2
   1085a:	d01c      	beq.n	10896 <am_hal_cmdq_error_resume+0x56>
        return AM_HAL_STATUS_SUCCESS;
    }
#endif
    // First Disable the Command Queue
#if AM_CMSIS_REGS
    AM_REGVAL(pCmdQ->pReg->regCQCfg) &= ~_VAL2FLD(IOM0_CQCFG_CQEN, IOM0_CQCFG_CQEN_EN);
   1085c:	6a42      	ldr	r2, [r0, #36]	; 0x24
{
   1085e:	b430      	push	{r4, r5}
#endif // AM_CMSIS_REGS

    // Need to identify end of block for the transaction where hardware is stuck
    // Move the CQADDR to the last entry in the block which will update the curIdx
    // and then move on.
    pCQAddr = (am_hal_cmdq_entry_t *)AM_REGVAL(pCmdQ->pReg->regCQAddr);
   10860:	e892 0030 	ldmia.w	r2, {r4, r5}
    AM_REGVAL(pCmdQ->pReg->regCQCfg) &= ~_VAL2FLD(IOM0_CQCFG_CQEN, IOM0_CQCFG_CQEN_EN);
   10864:	6823      	ldr	r3, [r4, #0]
   10866:	6891      	ldr	r1, [r2, #8]
   10868:	f023 0201 	bic.w	r2, r3, #1
   1086c:	6022      	str	r2, [r4, #0]
    pCQAddr = (am_hal_cmdq_entry_t *)AM_REGVAL(pCmdQ->pReg->regCQAddr);
   1086e:	682b      	ldr	r3, [r5, #0]
#if AM_CMSIS_REGS
    while ((pCQAddr->address & ~0x1) != (uint32_t)(pCmdQ->pReg->regCurIdx))
   10870:	e003      	b.n	1087a <am_hal_cmdq_error_resume+0x3a>
    {
        if ( (uint32_t) ++pCQAddr >= pCmdQ->cmdQBufEnd )
   10872:	6882      	ldr	r2, [r0, #8]
   10874:	3308      	adds	r3, #8
   10876:	4293      	cmp	r3, r2
   10878:	d20f      	bcs.n	1089a <am_hal_cmdq_error_resume+0x5a>
    while ((pCQAddr->address & ~0x1) != (uint32_t)(pCmdQ->pReg->regCurIdx))
   1087a:	681a      	ldr	r2, [r3, #0]
   1087c:	f022 0c01 	bic.w	ip, r2, #1
   10880:	458c      	cmp	ip, r1
   10882:	d1f6      	bne.n	10872 <am_hal_cmdq_error_resume+0x32>
        }
    }

    // The pCQAddr now points to the address of the command which will update the curIdx
    // Disable update interrupt, as we would have already handled this error
    *(&pCQAddr->address) = (uint32_t)pCmdQ->pReg->regCurIdx;
   10884:	6019      	str	r1, [r3, #0]
    AM_REGVAL(pCmdQ->pReg->regCQAddr) = (uint32_t)pCQAddr;
   10886:	602b      	str	r3, [r5, #0]
    // Re-enable the Command Queue
    AM_REGVAL(pCmdQ->pReg->regCQCfg) |= _VAL2FLD(IOM0_CQCFG_CQEN, IOM0_CQCFG_CQEN_EN);
   10888:	6820      	ldr	r0, [r4, #0]
   1088a:	f040 0501 	orr.w	r5, r0, #1
   1088e:	6025      	str	r5, [r4, #0]
    AM_REGVAL(pCmdQ->pReg->regCQAddr) = (uint32_t)pCQAddr;
    // Re-enable the Command Queue
    AM_REGVAL(pCmdQ->pReg->regCQCfg) |= AM_REG_IOM_CQCFG_CQEN_EN;
#endif // AM_CMSIS_REGS

    return AM_HAL_STATUS_SUCCESS;
   10890:	2000      	movs	r0, #0
}
   10892:	bc30      	pop	{r4, r5}
   10894:	4770      	bx	lr
        return AM_HAL_STATUS_SUCCESS;
   10896:	4618      	mov	r0, r3
   10898:	4770      	bx	lr
            return AM_HAL_STATUS_FAIL;
   1089a:	2001      	movs	r0, #1
   1089c:	e7f9      	b.n	10892 <am_hal_cmdq_error_resume+0x52>
   1089e:	bf00      	nop
   108a0:	01cdcdcd 	.word	0x01cdcdcd
   108a4:	4c494146 	.word	0x4c494146
   108a8:	6d61203a 	.word	0x6d61203a
   108ac:	7665645f 	.word	0x7665645f
   108b0:	73656369 	.word	0x73656369
   108b4:	7269665f 	.word	0x7269665f
   108b8:	6c616265 	.word	0x6c616265
   108bc:	6f635f6c 	.word	0x6f635f6c
   108c0:	6f72746e 	.word	0x6f72746e
   108c4:	6425286c 	.word	0x6425286c
   108c8:	65722029 	.word	0x65722029
   108cc:	6e727574 	.word	0x6e727574
   108d0:	30206465 	.word	0x30206465
   108d4:	2e582578 	.word	0x2e582578
   108d8:	0000000a 	.word	0x0000000a
   108dc:	65726946 	.word	0x65726946
   108e0:	6c6c6162 	.word	0x6c6c6162
   108e4:	756f6620 	.word	0x756f6620
   108e8:	202c646e 	.word	0x202c646e
   108ec:	69204449 	.word	0x69204449
   108f0:	78302073 	.word	0x78302073
   108f4:	0a2e5825 	.word	0x0a2e5825
   108f8:	00000000 	.word	0x00000000
   108fc:	6e6b6e55 	.word	0x6e6b6e55
   10900:	206e776f 	.word	0x206e776f
   10904:	69766564 	.word	0x69766564
   10908:	72206563 	.word	0x72206563
   1090c:	72757465 	.word	0x72757465
   10910:	2064656e 	.word	0x2064656e
   10914:	61204449 	.word	0x61204449
   10918:	78302073 	.word	0x78302073
   1091c:	0a2e5825 	.word	0x0a2e5825
   10920:	00000000 	.word	0x00000000
   10924:	65726946 	.word	0x65726946
   10928:	6c6c6162 	.word	0x6c6c6162
   1092c:	72655620 	.word	0x72655620
   10930:	6e6f6973 	.word	0x6e6f6973
   10934:	20736920 	.word	0x20736920
   10938:	58257830 	.word	0x58257830
   1093c:	00000a2e 	.word	0x00000a2e
   10940:	46207325 	.word	0x46207325
   10944:	646e756f 	.word	0x646e756f
   10948:	0000000a 	.word	0x0000000a
   1094c:	74746553 	.word	0x74746553
   10950:	20676e69 	.word	0x20676e69
   10954:	64207075 	.word	0x64207075
   10958:	20617461 	.word	0x20617461
   1095c:	74746170 	.word	0x74746170
   10960:	206e7265 	.word	0x206e7265
   10964:	46206e69 	.word	0x46206e69
   10968:	204d4152 	.word	0x204d4152
   1096c:	6e697375 	.word	0x6e697375
   10970:	6c622067 	.word	0x6c622067
   10974:	696b636f 	.word	0x696b636f
   10978:	7720676e 	.word	0x7720676e
   1097c:	65746972 	.word	0x65746972
   10980:	0000000a 	.word	0x0000000a
   10984:	4152460a 	.word	0x4152460a
   10988:	6552204d 	.word	0x6552204d
   1098c:	46206461 	.word	0x46206461
   10990:	656c6961 	.word	0x656c6961
   10994:	78302064 	.word	0x78302064
   10998:	000a7825 	.word	0x000a7825
   1099c:	0000002e 	.word	0x0000002e
   109a0:	65636552 	.word	0x65636552
   109a4:	20657669 	.word	0x20657669
   109a8:	61746144 	.word	0x61746144
   109ac:	6d6f4320 	.word	0x6d6f4320
   109b0:	65726170 	.word	0x65726170
   109b4:	69616620 	.word	0x69616620
   109b8:	2064656c 	.word	0x2064656c
   109bc:	6f207461 	.word	0x6f207461
   109c0:	65736666 	.word	0x65736666
   109c4:	64252074 	.word	0x64252074
   109c8:	45202d20 	.word	0x45202d20
   109cc:	63657078 	.word	0x63657078
   109d0:	20646574 	.word	0x20646574
   109d4:	7830203d 	.word	0x7830203d
   109d8:	202c7825 	.word	0x202c7825
   109dc:	65636552 	.word	0x65636552
   109e0:	64657669 	.word	0x64657669
   109e4:	30203d20 	.word	0x30203d20
   109e8:	0a782578 	.word	0x0a782578
   109ec:	00000000 	.word	0x00000000
   109f0:	204d4f49 	.word	0x204d4f49
   109f4:	4d415246 	.word	0x4d415246
   109f8:	61784520 	.word	0x61784520
   109fc:	656c706d 	.word	0x656c706d
   10a00:	0000000a 	.word	0x0000000a
   10a04:	62616e55 	.word	0x62616e55
   10a08:	7420656c 	.word	0x7420656c
   10a0c:	6e69206f 	.word	0x6e69206f
   10a10:	61697469 	.word	0x61697469
   10a14:	657a696c 	.word	0x657a696c
   10a18:	41524620 	.word	0x41524620
   10a1c:	00000a4d 	.word	0x00000a4d
   10a20:	69726550 	.word	0x69726550
   10a24:	6369646f 	.word	0x6369646f
   10a28:	796c6c61 	.word	0x796c6c61
   10a2c:	61655220 	.word	0x61655220
   10a30:	676e6964 	.word	0x676e6964
   10a34:	74616420 	.word	0x74616420
   10a38:	72662061 	.word	0x72662061
   10a3c:	46206d6f 	.word	0x46206d6f
   10a40:	204d4152 	.word	0x204d4152
   10a44:	6e697375 	.word	0x6e697375
   10a48:	6f6e2067 	.word	0x6f6e2067
   10a4c:	6c622d6e 	.word	0x6c622d6e
   10a50:	696b636f 	.word	0x696b636f
   10a54:	7220676e 	.word	0x7220676e
   10a58:	20646165 	.word	0x20646165
   10a5c:	6425202d 	.word	0x6425202d
   10a60:	6d697420 	.word	0x6d697420
   10a64:	000a7365 	.word	0x000a7365
   10a68:	2064250a 	.word	0x2064250a
   10a6c:	64616552 	.word	0x64616552
   10a70:	6f642073 	.word	0x6f642073
   10a74:	000a656e 	.word	0x000a656e
   10a78:	646e450a 	.word	0x646e450a
   10a7c:	20666f20 	.word	0x20666f20
   10a80:	4d415246 	.word	0x4d415246
   10a84:	61784520 	.word	0x61784520
   10a88:	656c706d 	.word	0x656c706d
   10a8c:	0000000a 	.word	0x0000000a
   10a90:	0a0a0a0a 	.word	0x0a0a0a0a
   10a94:	0a0a0a0a 	.word	0x0a0a0a0a
   10a98:	0a0a0a0a 	.word	0x0a0a0a0a
   10a9c:	0a0a0a0a 	.word	0x0a0a0a0a
   10aa0:	00000a0a 	.word	0x00000a0a

00010aa4 <g_FireballIOM5Config>:
   10aa4:	00000000 000f4240 00000000 00000000     ....@B..........
   10ab4:	00000000                                ....

00010ab8 <g_AM_BSP_GPIO_FIREBALL_CE>:
   10ab8:	001d0701                                ....

00010abc <g_AM_BSP_GPIO_IOM0_CS>:
   10abc:	00000701                                ....

00010ac0 <g_AM_BSP_GPIO_IOM0_MISO>:
   10ac0:	00000001                                ....

00010ac4 <g_AM_BSP_GPIO_IOM0_MOSI>:
   10ac4:	00000301                                ....

00010ac8 <g_AM_BSP_GPIO_IOM0_SCK>:
   10ac8:	00000301                                ....

00010acc <g_AM_BSP_GPIO_IOM0_SCL>:
   10acc:	00000b40                                @...

00010ad0 <g_AM_BSP_GPIO_IOM0_SDA>:
   10ad0:	00000b40                                @...

00010ad4 <g_AM_BSP_GPIO_IOM1_CS>:
   10ad4:	00110701                                ....

00010ad8 <g_AM_BSP_GPIO_IOM1_MISO>:
   10ad8:	00010001                                ....

00010adc <g_AM_BSP_GPIO_IOM1_MOSI>:
   10adc:	00010301                                ....

00010ae0 <g_AM_BSP_GPIO_IOM1_SCK>:
   10ae0:	00010301                                ....

00010ae4 <g_AM_BSP_GPIO_IOM1_SCL>:
   10ae4:	00010b40                                @...

00010ae8 <g_AM_BSP_GPIO_IOM1_SDA>:
   10ae8:	00010b40                                @...

00010aec <g_AM_BSP_GPIO_IOM2_CS>:
   10aec:	001a0701                                ....

00010af0 <g_AM_BSP_GPIO_IOM2_MISO>:
   10af0:	00020005                                ....

00010af4 <g_AM_BSP_GPIO_IOM2_MOSI>:
   10af4:	00020305                                ....

00010af8 <g_AM_BSP_GPIO_IOM2_SCK>:
   10af8:	00020305                                ....

00010afc <g_AM_BSP_GPIO_IOM2_SCL>:
   10afc:	00020b44                                D...

00010b00 <g_AM_BSP_GPIO_IOM2_SDA>:
   10b00:	00020b44                                D...

00010b04 <g_AM_BSP_GPIO_IOM3_CS>:
   10b04:	00030701                                ....

00010b08 <g_AM_BSP_GPIO_IOM3_MISO>:
   10b08:	00030005                                ....

00010b0c <g_AM_BSP_GPIO_IOM3_MOSI>:
   10b0c:	00030305                                ....

00010b10 <g_AM_BSP_GPIO_IOM3_SCK>:
   10b10:	00030305                                ....

00010b14 <g_AM_BSP_GPIO_IOM3_SCL>:
   10b14:	00030b44                                D...

00010b18 <g_AM_BSP_GPIO_IOM3_SDA>:
   10b18:	00030b44                                D...

00010b1c <g_AM_BSP_GPIO_IOM4_CS>:
   10b1c:	000c0701                                ....

00010b20 <g_AM_BSP_GPIO_IOM4_MISO>:
   10b20:	00040005                                ....

00010b24 <g_AM_BSP_GPIO_IOM4_MOSI>:
   10b24:	00040305                                ....

00010b28 <g_AM_BSP_GPIO_IOM4_SCK>:
   10b28:	00040305                                ....

00010b2c <g_AM_BSP_GPIO_IOM4_SCL>:
   10b2c:	00040b44                                D...

00010b30 <g_AM_BSP_GPIO_IOM4_SDA>:
   10b30:	00040b44                                D...

00010b34 <g_AM_BSP_GPIO_IOM5_CS>:
   10b34:	00050701                                ....

00010b38 <g_AM_BSP_GPIO_IOM5_MISO>:
   10b38:	00050005                                ....

00010b3c <g_AM_BSP_GPIO_IOM5_MOSI>:
   10b3c:	00050305                                ....

00010b40 <g_AM_BSP_GPIO_IOM5_SCK>:
   10b40:	00050305                                ....

00010b44 <g_AM_BSP_GPIO_IOM5_SCL>:
   10b44:	00050b44                                D...

00010b48 <g_AM_BSP_GPIO_IOM5_SDA>:
   10b48:	00050b44                                D...

00010b4c <g_AM_BSP_GPIO_ITM_SWO>:
   10b4c:	00000002                                ....

00010b50 <am_hal_cachectrl_defaults>:
   10b50:	00000308 6d695443 69207265 7265746e     ....CTimer inter
   10b60:	74707572 6d756e20 20726562 2074756f     rupt number out 
   10b70:	7220666f 65676e61 0000002e 2e5c2e2e     of range......\.
   10b80:	6d615c2e 6c61685f 6974635f 2e72656d     .\am_hal_ctimer.
   10b90:	00000063                                c...

00010b94 <g_AM_HAL_GPIO_DISABLE>:
   10b94:	00000003                                ....

00010b98 <g_AM_HAL_GPIO_OUTPUT>:
   10b98:	00000403                                ....

00010b9c <g_ui8Bit76Capabilities>:
   10b9c:	02800101 80010180 80800101 80808080     ................
   10bac:	80808080 80808008 01800180 80808080     ................
   10bbc:	80808080 01800402 01010401 80808080     ................
   10bcc:	00000101                                ....

00010bd0 <g_ui8Inpen>:
   10bd0:	e2242323 100723a1 e1004303 3561a151     ##$..#...C..Q.a5
   10be0:	4181c525 d160b001 31a13130 1100f101     %..A..`.01.1....
   10bf0:	01d121b1 300511e5 31301037 40006100     .!.....07.01.a.@
   10c00:	00003130                                01..

00010c04 <g_ui8NCEtable>:
   10c04:	13524232 60221202 21534333 20504030     2BR..."`3CS!0@P 
   10c14:	11514131 ffffffff ffffffff 60514131     1AQ.........1AQ`
   10c24:	00504030 23534333 60524232 30201000     0@P.3CS#2BR`.. 0
   10c34:	61504030 01514131 42221202 60231303     0@Pa1AQ..."B..#`
   10c44:	50201000 41211101 32221202 60331303     .. P..!A.."2..3`
   10c54:	21514131 22524232 03534333 40201000     1AQ!2BR"3CS... @
   10c64:	51211101 02524232 13534333 10504030     ..!Q2BR.3CS.0@P.
   10c74:	60514131 12524232 03534333 40201000     1AQ`2BR.3CS... @
   10c84:	61211101 52221202 33231303 30201000     ..!a.."R..#3.. 0
   10c94:	61514131 02524232 53331303 ffffffff     1AQa2BR...3S....
   10ca4:	ffffffff 61211101 50201000 61211101     ......!a.. P..!a
   10cb4:	52221202 13534333 61504030 31211101     .."R3CS.0@Pa..!1
   10cc4:	32221202 43231303                       .."2..#C

00010ccc <g_ui8nCEpins>:
   10ccc:	02070707 00080802 01020202 01010101     ................
   10cdc:	01010101 01010101 01010101 01010101     ................
   10cec:	01010101 08010101 01010008 01010101     ................
   10cfc:	00000101                                ....

00010d00 <g_am_hal_mcuctrl_flash_size>:
   10d00:	00004000 00008000 00010000 00020000     .@..............
   10d10:	00040000 00080000 00100000 00200000     .............. .
	...

00010d40 <g_am_hal_mcuctrl_sram_size>:
   10d40:	00004000 00008000 00010000 00020000     .@..............
   10d50:	00040000 00080000 00100000 00060000     ................
	...

00010d80 <am_hal_pwrctrl_peripheral_control>:
	...
   10d8c:	00000001 00000004 00000004 00000002     ................
   10d9c:	00000008 00000008 00000004 00000008     ................
   10dac:	00000008 00000008 00000008 00000008     ................
   10dbc:	00000010 00000010 00000010 00000020     ............ ...
   10dcc:	00000010 00000010 00000040 00000010     ........@.......
   10ddc:	00000010 00000080 00000004 00000004     ................
   10dec:	00000100 00000004 00000004 00000200     ................
   10dfc:	00000020 00000020 00000400 00000004      ... ...........
   10e0c:	00000004 00000800 00000040 00000040     ........@...@...
   10e1c:	00001000 00000080 00000080 00002000     ............. ..
   10e2c:	00000100 00000100                       ........

00010e34 <gAmHalCmdQReg>:
   10e34:	50004294 50004298 500042ac 500042b0     .B.P.B.P.B.P.B.P
   10e44:	500042a8 00008000 5000429c 00000001     .B.P.....B.P....
   10e54:	00000004 00000002 50005294 50005298     .........R.P.R.P
   10e64:	500052ac 500052b0 500052a8 00008000     .R.P.R.P.R.P....
   10e74:	5000529c 00000001 00000004 00000002     .R.P............
   10e84:	50006294 50006298 500062ac 500062b0     .b.P.b.P.b.P.b.P
   10e94:	500062a8 00008000 5000629c 00000001     .b.P.....b.P....
   10ea4:	00000004 00000002 50007294 50007298     .........r.P.r.P
   10eb4:	500072ac 500072b0 500072a8 00008000     .r.P.r.P.r.P....
   10ec4:	5000729c 00000001 00000004 00000002     .r.P............
   10ed4:	50008294 50008298 500082ac 500082b0     ...P...P...P...P
   10ee4:	500082a8 00008000 5000829c 00000001     ...P.......P....
   10ef4:	00000004 00000002 50009294 50009298     ...........P...P
   10f04:	500092ac 500092b0 500092a8 00008000     ...P...P...P....
   10f14:	5000929c 00000001 00000004 00000002     ...P............
   10f24:	500142a0 500142a8 500142c0 500142c4     .B.P.B.P.B.P.B.P
   10f34:	500142b8 00004000 500142ac 00000001     .B.P.@...B.P....
   10f44:	00000004 00000008 5000c248 5000c24c     ........H..PL..P
   10f54:	5000c260 5000c264 5000c25c 00008000     `..Pd..P\..P....
   10f64:	5000c250 00000001 00000004 00000002     P..P............
