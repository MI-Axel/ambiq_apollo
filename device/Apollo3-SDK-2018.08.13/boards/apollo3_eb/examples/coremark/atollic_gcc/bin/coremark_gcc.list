
coremark_gcc.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000073d0  0000c000  0000c000  0000c000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .stack        00001000  10000000  10000000  00030000  2**2
                  ALLOC
  2 .data         00000018  10001000  000133d0  00021000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00000604  10001018  000133e8  00021018  2**3
                  ALLOC
  4 .ARM.attributes 00000037  00000000  00000000  00021018  2**0
                  CONTENTS, READONLY
  5 .debug_info   00028e60  00000000  00000000  0002104f  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000045b0  00000000  00000000  00049eaf  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000868  00000000  00000000  0004e45f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_ranges 000020f8  00000000  00000000  0004ecc7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00008a68  00000000  00000000  00050dbf  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000aa1b  00000000  00000000  00059827  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000007c  00000000  00000000  00064242  2**0
                  CONTENTS, READONLY
 12 .debug_frame  000019c4  00000000  00000000  000642c0  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    0000e24a  00000000  00000000  00065c84  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0000c000 <g_am_pfnVectors>:
    c000:	00 10 00 10 55 f7 00 00 4d f7 00 00 bd f7 00 00     ....U...M.......
    c010:	bd f7 00 00 bd f7 00 00 bd f7 00 00 00 00 00 00     ................
	...
    c02c:	51 f7 00 00 51 f7 00 00 00 00 00 00 51 f7 00 00     Q...Q.......Q...
    c03c:	85 ca 00 00 51 f7 00 00 51 f7 00 00 51 f7 00 00     ....Q...Q...Q...
    c04c:	51 f7 00 00 51 f7 00 00 51 f7 00 00 51 f7 00 00     Q...Q...Q...Q...
    c05c:	51 f7 00 00 51 f7 00 00 51 f7 00 00 51 f7 00 00     Q...Q...Q...Q...
    c06c:	51 f7 00 00 51 f7 00 00 51 f7 00 00 51 f7 00 00     Q...Q...Q...Q...
    c07c:	51 f7 00 00 51 f7 00 00 51 f7 00 00 51 f7 00 00     Q...Q...Q...Q...
    c08c:	51 f7 00 00 51 f7 00 00 51 f7 00 00 51 f7 00 00     Q...Q...Q...Q...
    c09c:	51 f7 00 00 51 f7 00 00 51 f7 00 00 51 f7 00 00     Q...Q...Q...Q...
    c0ac:	51 f7 00 00 51 f7 00 00 51 f7 00 00 51 f7 00 00     Q...Q...Q...Q...
    c0bc:	51 f7 00 00 51 f7 00 00 51 f7 00 00 51 f7 00 00     Q...Q...Q...Q...
    c0cc:	51 f7 00 00                                         Q...

0000c0d0 <__Patchable>:
	...

0000c100 <__aeabi_drsub>:
    c100:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
    c104:	e002      	b.n	c10c <__adddf3>
    c106:	bf00      	nop

0000c108 <__aeabi_dsub>:
    c108:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0000c10c <__adddf3>:
    c10c:	b530      	push	{r4, r5, lr}
    c10e:	ea4f 0441 	mov.w	r4, r1, lsl #1
    c112:	ea4f 0543 	mov.w	r5, r3, lsl #1
    c116:	ea94 0f05 	teq	r4, r5
    c11a:	bf08      	it	eq
    c11c:	ea90 0f02 	teqeq	r0, r2
    c120:	bf1f      	itttt	ne
    c122:	ea54 0c00 	orrsne.w	ip, r4, r0
    c126:	ea55 0c02 	orrsne.w	ip, r5, r2
    c12a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
    c12e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    c132:	f000 80e2 	beq.w	c2fa <__adddf3+0x1ee>
    c136:	ea4f 5454 	mov.w	r4, r4, lsr #21
    c13a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
    c13e:	bfb8      	it	lt
    c140:	426d      	neglt	r5, r5
    c142:	dd0c      	ble.n	c15e <__adddf3+0x52>
    c144:	442c      	add	r4, r5
    c146:	ea80 0202 	eor.w	r2, r0, r2
    c14a:	ea81 0303 	eor.w	r3, r1, r3
    c14e:	ea82 0000 	eor.w	r0, r2, r0
    c152:	ea83 0101 	eor.w	r1, r3, r1
    c156:	ea80 0202 	eor.w	r2, r0, r2
    c15a:	ea81 0303 	eor.w	r3, r1, r3
    c15e:	2d36      	cmp	r5, #54	; 0x36
    c160:	bf88      	it	hi
    c162:	bd30      	pophi	{r4, r5, pc}
    c164:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    c168:	ea4f 3101 	mov.w	r1, r1, lsl #12
    c16c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
    c170:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
    c174:	d002      	beq.n	c17c <__adddf3+0x70>
    c176:	4240      	negs	r0, r0
    c178:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    c17c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
    c180:	ea4f 3303 	mov.w	r3, r3, lsl #12
    c184:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
    c188:	d002      	beq.n	c190 <__adddf3+0x84>
    c18a:	4252      	negs	r2, r2
    c18c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    c190:	ea94 0f05 	teq	r4, r5
    c194:	f000 80a7 	beq.w	c2e6 <__adddf3+0x1da>
    c198:	f1a4 0401 	sub.w	r4, r4, #1
    c19c:	f1d5 0e20 	rsbs	lr, r5, #32
    c1a0:	db0d      	blt.n	c1be <__adddf3+0xb2>
    c1a2:	fa02 fc0e 	lsl.w	ip, r2, lr
    c1a6:	fa22 f205 	lsr.w	r2, r2, r5
    c1aa:	1880      	adds	r0, r0, r2
    c1ac:	f141 0100 	adc.w	r1, r1, #0
    c1b0:	fa03 f20e 	lsl.w	r2, r3, lr
    c1b4:	1880      	adds	r0, r0, r2
    c1b6:	fa43 f305 	asr.w	r3, r3, r5
    c1ba:	4159      	adcs	r1, r3
    c1bc:	e00e      	b.n	c1dc <__adddf3+0xd0>
    c1be:	f1a5 0520 	sub.w	r5, r5, #32
    c1c2:	f10e 0e20 	add.w	lr, lr, #32
    c1c6:	2a01      	cmp	r2, #1
    c1c8:	fa03 fc0e 	lsl.w	ip, r3, lr
    c1cc:	bf28      	it	cs
    c1ce:	f04c 0c02 	orrcs.w	ip, ip, #2
    c1d2:	fa43 f305 	asr.w	r3, r3, r5
    c1d6:	18c0      	adds	r0, r0, r3
    c1d8:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
    c1dc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    c1e0:	d507      	bpl.n	c1f2 <__adddf3+0xe6>
    c1e2:	f04f 0e00 	mov.w	lr, #0
    c1e6:	f1dc 0c00 	rsbs	ip, ip, #0
    c1ea:	eb7e 0000 	sbcs.w	r0, lr, r0
    c1ee:	eb6e 0101 	sbc.w	r1, lr, r1
    c1f2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
    c1f6:	d31b      	bcc.n	c230 <__adddf3+0x124>
    c1f8:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
    c1fc:	d30c      	bcc.n	c218 <__adddf3+0x10c>
    c1fe:	0849      	lsrs	r1, r1, #1
    c200:	ea5f 0030 	movs.w	r0, r0, rrx
    c204:	ea4f 0c3c 	mov.w	ip, ip, rrx
    c208:	f104 0401 	add.w	r4, r4, #1
    c20c:	ea4f 5244 	mov.w	r2, r4, lsl #21
    c210:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
    c214:	f080 809a 	bcs.w	c34c <__adddf3+0x240>
    c218:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
    c21c:	bf08      	it	eq
    c21e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    c222:	f150 0000 	adcs.w	r0, r0, #0
    c226:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    c22a:	ea41 0105 	orr.w	r1, r1, r5
    c22e:	bd30      	pop	{r4, r5, pc}
    c230:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
    c234:	4140      	adcs	r0, r0
    c236:	eb41 0101 	adc.w	r1, r1, r1
    c23a:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    c23e:	f1a4 0401 	sub.w	r4, r4, #1
    c242:	d1e9      	bne.n	c218 <__adddf3+0x10c>
    c244:	f091 0f00 	teq	r1, #0
    c248:	bf04      	itt	eq
    c24a:	4601      	moveq	r1, r0
    c24c:	2000      	moveq	r0, #0
    c24e:	fab1 f381 	clz	r3, r1
    c252:	bf08      	it	eq
    c254:	3320      	addeq	r3, #32
    c256:	f1a3 030b 	sub.w	r3, r3, #11
    c25a:	f1b3 0220 	subs.w	r2, r3, #32
    c25e:	da0c      	bge.n	c27a <__adddf3+0x16e>
    c260:	320c      	adds	r2, #12
    c262:	dd08      	ble.n	c276 <__adddf3+0x16a>
    c264:	f102 0c14 	add.w	ip, r2, #20
    c268:	f1c2 020c 	rsb	r2, r2, #12
    c26c:	fa01 f00c 	lsl.w	r0, r1, ip
    c270:	fa21 f102 	lsr.w	r1, r1, r2
    c274:	e00c      	b.n	c290 <__adddf3+0x184>
    c276:	f102 0214 	add.w	r2, r2, #20
    c27a:	bfd8      	it	le
    c27c:	f1c2 0c20 	rsble	ip, r2, #32
    c280:	fa01 f102 	lsl.w	r1, r1, r2
    c284:	fa20 fc0c 	lsr.w	ip, r0, ip
    c288:	bfdc      	itt	le
    c28a:	ea41 010c 	orrle.w	r1, r1, ip
    c28e:	4090      	lslle	r0, r2
    c290:	1ae4      	subs	r4, r4, r3
    c292:	bfa2      	ittt	ge
    c294:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
    c298:	4329      	orrge	r1, r5
    c29a:	bd30      	popge	{r4, r5, pc}
    c29c:	ea6f 0404 	mvn.w	r4, r4
    c2a0:	3c1f      	subs	r4, #31
    c2a2:	da1c      	bge.n	c2de <__adddf3+0x1d2>
    c2a4:	340c      	adds	r4, #12
    c2a6:	dc0e      	bgt.n	c2c6 <__adddf3+0x1ba>
    c2a8:	f104 0414 	add.w	r4, r4, #20
    c2ac:	f1c4 0220 	rsb	r2, r4, #32
    c2b0:	fa20 f004 	lsr.w	r0, r0, r4
    c2b4:	fa01 f302 	lsl.w	r3, r1, r2
    c2b8:	ea40 0003 	orr.w	r0, r0, r3
    c2bc:	fa21 f304 	lsr.w	r3, r1, r4
    c2c0:	ea45 0103 	orr.w	r1, r5, r3
    c2c4:	bd30      	pop	{r4, r5, pc}
    c2c6:	f1c4 040c 	rsb	r4, r4, #12
    c2ca:	f1c4 0220 	rsb	r2, r4, #32
    c2ce:	fa20 f002 	lsr.w	r0, r0, r2
    c2d2:	fa01 f304 	lsl.w	r3, r1, r4
    c2d6:	ea40 0003 	orr.w	r0, r0, r3
    c2da:	4629      	mov	r1, r5
    c2dc:	bd30      	pop	{r4, r5, pc}
    c2de:	fa21 f004 	lsr.w	r0, r1, r4
    c2e2:	4629      	mov	r1, r5
    c2e4:	bd30      	pop	{r4, r5, pc}
    c2e6:	f094 0f00 	teq	r4, #0
    c2ea:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
    c2ee:	bf06      	itte	eq
    c2f0:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
    c2f4:	3401      	addeq	r4, #1
    c2f6:	3d01      	subne	r5, #1
    c2f8:	e74e      	b.n	c198 <__adddf3+0x8c>
    c2fa:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    c2fe:	bf18      	it	ne
    c300:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    c304:	d029      	beq.n	c35a <__adddf3+0x24e>
    c306:	ea94 0f05 	teq	r4, r5
    c30a:	bf08      	it	eq
    c30c:	ea90 0f02 	teqeq	r0, r2
    c310:	d005      	beq.n	c31e <__adddf3+0x212>
    c312:	ea54 0c00 	orrs.w	ip, r4, r0
    c316:	bf04      	itt	eq
    c318:	4619      	moveq	r1, r3
    c31a:	4610      	moveq	r0, r2
    c31c:	bd30      	pop	{r4, r5, pc}
    c31e:	ea91 0f03 	teq	r1, r3
    c322:	bf1e      	ittt	ne
    c324:	2100      	movne	r1, #0
    c326:	2000      	movne	r0, #0
    c328:	bd30      	popne	{r4, r5, pc}
    c32a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
    c32e:	d105      	bne.n	c33c <__adddf3+0x230>
    c330:	0040      	lsls	r0, r0, #1
    c332:	4149      	adcs	r1, r1
    c334:	bf28      	it	cs
    c336:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
    c33a:	bd30      	pop	{r4, r5, pc}
    c33c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
    c340:	bf3c      	itt	cc
    c342:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
    c346:	bd30      	popcc	{r4, r5, pc}
    c348:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    c34c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
    c350:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    c354:	f04f 0000 	mov.w	r0, #0
    c358:	bd30      	pop	{r4, r5, pc}
    c35a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    c35e:	bf1a      	itte	ne
    c360:	4619      	movne	r1, r3
    c362:	4610      	movne	r0, r2
    c364:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
    c368:	bf1c      	itt	ne
    c36a:	460b      	movne	r3, r1
    c36c:	4602      	movne	r2, r0
    c36e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    c372:	bf06      	itte	eq
    c374:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
    c378:	ea91 0f03 	teqeq	r1, r3
    c37c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
    c380:	bd30      	pop	{r4, r5, pc}
    c382:	bf00      	nop

0000c384 <__aeabi_ui2d>:
    c384:	f090 0f00 	teq	r0, #0
    c388:	bf04      	itt	eq
    c38a:	2100      	moveq	r1, #0
    c38c:	4770      	bxeq	lr
    c38e:	b530      	push	{r4, r5, lr}
    c390:	f44f 6480 	mov.w	r4, #1024	; 0x400
    c394:	f104 0432 	add.w	r4, r4, #50	; 0x32
    c398:	f04f 0500 	mov.w	r5, #0
    c39c:	f04f 0100 	mov.w	r1, #0
    c3a0:	e750      	b.n	c244 <__adddf3+0x138>
    c3a2:	bf00      	nop

0000c3a4 <__aeabi_i2d>:
    c3a4:	f090 0f00 	teq	r0, #0
    c3a8:	bf04      	itt	eq
    c3aa:	2100      	moveq	r1, #0
    c3ac:	4770      	bxeq	lr
    c3ae:	b530      	push	{r4, r5, lr}
    c3b0:	f44f 6480 	mov.w	r4, #1024	; 0x400
    c3b4:	f104 0432 	add.w	r4, r4, #50	; 0x32
    c3b8:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
    c3bc:	bf48      	it	mi
    c3be:	4240      	negmi	r0, r0
    c3c0:	f04f 0100 	mov.w	r1, #0
    c3c4:	e73e      	b.n	c244 <__adddf3+0x138>
    c3c6:	bf00      	nop

0000c3c8 <__aeabi_f2d>:
    c3c8:	0042      	lsls	r2, r0, #1
    c3ca:	ea4f 01e2 	mov.w	r1, r2, asr #3
    c3ce:	ea4f 0131 	mov.w	r1, r1, rrx
    c3d2:	ea4f 7002 	mov.w	r0, r2, lsl #28
    c3d6:	bf1f      	itttt	ne
    c3d8:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
    c3dc:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    c3e0:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
    c3e4:	4770      	bxne	lr
    c3e6:	f092 0f00 	teq	r2, #0
    c3ea:	bf14      	ite	ne
    c3ec:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    c3f0:	4770      	bxeq	lr
    c3f2:	b530      	push	{r4, r5, lr}
    c3f4:	f44f 7460 	mov.w	r4, #896	; 0x380
    c3f8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    c3fc:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    c400:	e720      	b.n	c244 <__adddf3+0x138>
    c402:	bf00      	nop

0000c404 <__aeabi_ul2d>:
    c404:	ea50 0201 	orrs.w	r2, r0, r1
    c408:	bf08      	it	eq
    c40a:	4770      	bxeq	lr
    c40c:	b530      	push	{r4, r5, lr}
    c40e:	f04f 0500 	mov.w	r5, #0
    c412:	e00a      	b.n	c42a <__aeabi_l2d+0x16>

0000c414 <__aeabi_l2d>:
    c414:	ea50 0201 	orrs.w	r2, r0, r1
    c418:	bf08      	it	eq
    c41a:	4770      	bxeq	lr
    c41c:	b530      	push	{r4, r5, lr}
    c41e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
    c422:	d502      	bpl.n	c42a <__aeabi_l2d+0x16>
    c424:	4240      	negs	r0, r0
    c426:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    c42a:	f44f 6480 	mov.w	r4, #1024	; 0x400
    c42e:	f104 0432 	add.w	r4, r4, #50	; 0x32
    c432:	ea5f 5c91 	movs.w	ip, r1, lsr #22
    c436:	f43f aedc 	beq.w	c1f2 <__adddf3+0xe6>
    c43a:	f04f 0203 	mov.w	r2, #3
    c43e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    c442:	bf18      	it	ne
    c444:	3203      	addne	r2, #3
    c446:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    c44a:	bf18      	it	ne
    c44c:	3203      	addne	r2, #3
    c44e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
    c452:	f1c2 0320 	rsb	r3, r2, #32
    c456:	fa00 fc03 	lsl.w	ip, r0, r3
    c45a:	fa20 f002 	lsr.w	r0, r0, r2
    c45e:	fa01 fe03 	lsl.w	lr, r1, r3
    c462:	ea40 000e 	orr.w	r0, r0, lr
    c466:	fa21 f102 	lsr.w	r1, r1, r2
    c46a:	4414      	add	r4, r2
    c46c:	e6c1      	b.n	c1f2 <__adddf3+0xe6>
    c46e:	bf00      	nop

0000c470 <__aeabi_dmul>:
    c470:	b570      	push	{r4, r5, r6, lr}
    c472:	f04f 0cff 	mov.w	ip, #255	; 0xff
    c476:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    c47a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    c47e:	bf1d      	ittte	ne
    c480:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    c484:	ea94 0f0c 	teqne	r4, ip
    c488:	ea95 0f0c 	teqne	r5, ip
    c48c:	f000 f8de 	bleq	c64c <__aeabi_dmul+0x1dc>
    c490:	442c      	add	r4, r5
    c492:	ea81 0603 	eor.w	r6, r1, r3
    c496:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
    c49a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
    c49e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
    c4a2:	bf18      	it	ne
    c4a4:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
    c4a8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    c4ac:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    c4b0:	d038      	beq.n	c524 <__aeabi_dmul+0xb4>
    c4b2:	fba0 ce02 	umull	ip, lr, r0, r2
    c4b6:	f04f 0500 	mov.w	r5, #0
    c4ba:	fbe1 e502 	umlal	lr, r5, r1, r2
    c4be:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
    c4c2:	fbe0 e503 	umlal	lr, r5, r0, r3
    c4c6:	f04f 0600 	mov.w	r6, #0
    c4ca:	fbe1 5603 	umlal	r5, r6, r1, r3
    c4ce:	f09c 0f00 	teq	ip, #0
    c4d2:	bf18      	it	ne
    c4d4:	f04e 0e01 	orrne.w	lr, lr, #1
    c4d8:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
    c4dc:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
    c4e0:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
    c4e4:	d204      	bcs.n	c4f0 <__aeabi_dmul+0x80>
    c4e6:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
    c4ea:	416d      	adcs	r5, r5
    c4ec:	eb46 0606 	adc.w	r6, r6, r6
    c4f0:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
    c4f4:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
    c4f8:	ea4f 20c5 	mov.w	r0, r5, lsl #11
    c4fc:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
    c500:	ea4f 2ece 	mov.w	lr, lr, lsl #11
    c504:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    c508:	bf88      	it	hi
    c50a:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    c50e:	d81e      	bhi.n	c54e <__aeabi_dmul+0xde>
    c510:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
    c514:	bf08      	it	eq
    c516:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
    c51a:	f150 0000 	adcs.w	r0, r0, #0
    c51e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    c522:	bd70      	pop	{r4, r5, r6, pc}
    c524:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
    c528:	ea46 0101 	orr.w	r1, r6, r1
    c52c:	ea40 0002 	orr.w	r0, r0, r2
    c530:	ea81 0103 	eor.w	r1, r1, r3
    c534:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
    c538:	bfc2      	ittt	gt
    c53a:	ebd4 050c 	rsbsgt	r5, r4, ip
    c53e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    c542:	bd70      	popgt	{r4, r5, r6, pc}
    c544:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    c548:	f04f 0e00 	mov.w	lr, #0
    c54c:	3c01      	subs	r4, #1
    c54e:	f300 80ab 	bgt.w	c6a8 <__aeabi_dmul+0x238>
    c552:	f114 0f36 	cmn.w	r4, #54	; 0x36
    c556:	bfde      	ittt	le
    c558:	2000      	movle	r0, #0
    c55a:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
    c55e:	bd70      	pople	{r4, r5, r6, pc}
    c560:	f1c4 0400 	rsb	r4, r4, #0
    c564:	3c20      	subs	r4, #32
    c566:	da35      	bge.n	c5d4 <__aeabi_dmul+0x164>
    c568:	340c      	adds	r4, #12
    c56a:	dc1b      	bgt.n	c5a4 <__aeabi_dmul+0x134>
    c56c:	f104 0414 	add.w	r4, r4, #20
    c570:	f1c4 0520 	rsb	r5, r4, #32
    c574:	fa00 f305 	lsl.w	r3, r0, r5
    c578:	fa20 f004 	lsr.w	r0, r0, r4
    c57c:	fa01 f205 	lsl.w	r2, r1, r5
    c580:	ea40 0002 	orr.w	r0, r0, r2
    c584:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
    c588:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    c58c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    c590:	fa21 f604 	lsr.w	r6, r1, r4
    c594:	eb42 0106 	adc.w	r1, r2, r6
    c598:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    c59c:	bf08      	it	eq
    c59e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    c5a2:	bd70      	pop	{r4, r5, r6, pc}
    c5a4:	f1c4 040c 	rsb	r4, r4, #12
    c5a8:	f1c4 0520 	rsb	r5, r4, #32
    c5ac:	fa00 f304 	lsl.w	r3, r0, r4
    c5b0:	fa20 f005 	lsr.w	r0, r0, r5
    c5b4:	fa01 f204 	lsl.w	r2, r1, r4
    c5b8:	ea40 0002 	orr.w	r0, r0, r2
    c5bc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    c5c0:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    c5c4:	f141 0100 	adc.w	r1, r1, #0
    c5c8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    c5cc:	bf08      	it	eq
    c5ce:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    c5d2:	bd70      	pop	{r4, r5, r6, pc}
    c5d4:	f1c4 0520 	rsb	r5, r4, #32
    c5d8:	fa00 f205 	lsl.w	r2, r0, r5
    c5dc:	ea4e 0e02 	orr.w	lr, lr, r2
    c5e0:	fa20 f304 	lsr.w	r3, r0, r4
    c5e4:	fa01 f205 	lsl.w	r2, r1, r5
    c5e8:	ea43 0302 	orr.w	r3, r3, r2
    c5ec:	fa21 f004 	lsr.w	r0, r1, r4
    c5f0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    c5f4:	fa21 f204 	lsr.w	r2, r1, r4
    c5f8:	ea20 0002 	bic.w	r0, r0, r2
    c5fc:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
    c600:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    c604:	bf08      	it	eq
    c606:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    c60a:	bd70      	pop	{r4, r5, r6, pc}
    c60c:	f094 0f00 	teq	r4, #0
    c610:	d10f      	bne.n	c632 <__aeabi_dmul+0x1c2>
    c612:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
    c616:	0040      	lsls	r0, r0, #1
    c618:	eb41 0101 	adc.w	r1, r1, r1
    c61c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    c620:	bf08      	it	eq
    c622:	3c01      	subeq	r4, #1
    c624:	d0f7      	beq.n	c616 <__aeabi_dmul+0x1a6>
    c626:	ea41 0106 	orr.w	r1, r1, r6
    c62a:	f095 0f00 	teq	r5, #0
    c62e:	bf18      	it	ne
    c630:	4770      	bxne	lr
    c632:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
    c636:	0052      	lsls	r2, r2, #1
    c638:	eb43 0303 	adc.w	r3, r3, r3
    c63c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
    c640:	bf08      	it	eq
    c642:	3d01      	subeq	r5, #1
    c644:	d0f7      	beq.n	c636 <__aeabi_dmul+0x1c6>
    c646:	ea43 0306 	orr.w	r3, r3, r6
    c64a:	4770      	bx	lr
    c64c:	ea94 0f0c 	teq	r4, ip
    c650:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    c654:	bf18      	it	ne
    c656:	ea95 0f0c 	teqne	r5, ip
    c65a:	d00c      	beq.n	c676 <__aeabi_dmul+0x206>
    c65c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    c660:	bf18      	it	ne
    c662:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    c666:	d1d1      	bne.n	c60c <__aeabi_dmul+0x19c>
    c668:	ea81 0103 	eor.w	r1, r1, r3
    c66c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    c670:	f04f 0000 	mov.w	r0, #0
    c674:	bd70      	pop	{r4, r5, r6, pc}
    c676:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    c67a:	bf06      	itte	eq
    c67c:	4610      	moveq	r0, r2
    c67e:	4619      	moveq	r1, r3
    c680:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    c684:	d019      	beq.n	c6ba <__aeabi_dmul+0x24a>
    c686:	ea94 0f0c 	teq	r4, ip
    c68a:	d102      	bne.n	c692 <__aeabi_dmul+0x222>
    c68c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
    c690:	d113      	bne.n	c6ba <__aeabi_dmul+0x24a>
    c692:	ea95 0f0c 	teq	r5, ip
    c696:	d105      	bne.n	c6a4 <__aeabi_dmul+0x234>
    c698:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
    c69c:	bf1c      	itt	ne
    c69e:	4610      	movne	r0, r2
    c6a0:	4619      	movne	r1, r3
    c6a2:	d10a      	bne.n	c6ba <__aeabi_dmul+0x24a>
    c6a4:	ea81 0103 	eor.w	r1, r1, r3
    c6a8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    c6ac:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    c6b0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    c6b4:	f04f 0000 	mov.w	r0, #0
    c6b8:	bd70      	pop	{r4, r5, r6, pc}
    c6ba:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    c6be:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
    c6c2:	bd70      	pop	{r4, r5, r6, pc}

0000c6c4 <__aeabi_ddiv>:
    c6c4:	b570      	push	{r4, r5, r6, lr}
    c6c6:	f04f 0cff 	mov.w	ip, #255	; 0xff
    c6ca:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    c6ce:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    c6d2:	bf1d      	ittte	ne
    c6d4:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    c6d8:	ea94 0f0c 	teqne	r4, ip
    c6dc:	ea95 0f0c 	teqne	r5, ip
    c6e0:	f000 f8a7 	bleq	c832 <__aeabi_ddiv+0x16e>
    c6e4:	eba4 0405 	sub.w	r4, r4, r5
    c6e8:	ea81 0e03 	eor.w	lr, r1, r3
    c6ec:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    c6f0:	ea4f 3101 	mov.w	r1, r1, lsl #12
    c6f4:	f000 8088 	beq.w	c808 <__aeabi_ddiv+0x144>
    c6f8:	ea4f 3303 	mov.w	r3, r3, lsl #12
    c6fc:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
    c700:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
    c704:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
    c708:	ea4f 2202 	mov.w	r2, r2, lsl #8
    c70c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
    c710:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
    c714:	ea4f 2600 	mov.w	r6, r0, lsl #8
    c718:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
    c71c:	429d      	cmp	r5, r3
    c71e:	bf08      	it	eq
    c720:	4296      	cmpeq	r6, r2
    c722:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
    c726:	f504 7440 	add.w	r4, r4, #768	; 0x300
    c72a:	d202      	bcs.n	c732 <__aeabi_ddiv+0x6e>
    c72c:	085b      	lsrs	r3, r3, #1
    c72e:	ea4f 0232 	mov.w	r2, r2, rrx
    c732:	1ab6      	subs	r6, r6, r2
    c734:	eb65 0503 	sbc.w	r5, r5, r3
    c738:	085b      	lsrs	r3, r3, #1
    c73a:	ea4f 0232 	mov.w	r2, r2, rrx
    c73e:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
    c742:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
    c746:	ebb6 0e02 	subs.w	lr, r6, r2
    c74a:	eb75 0e03 	sbcs.w	lr, r5, r3
    c74e:	bf22      	ittt	cs
    c750:	1ab6      	subcs	r6, r6, r2
    c752:	4675      	movcs	r5, lr
    c754:	ea40 000c 	orrcs.w	r0, r0, ip
    c758:	085b      	lsrs	r3, r3, #1
    c75a:	ea4f 0232 	mov.w	r2, r2, rrx
    c75e:	ebb6 0e02 	subs.w	lr, r6, r2
    c762:	eb75 0e03 	sbcs.w	lr, r5, r3
    c766:	bf22      	ittt	cs
    c768:	1ab6      	subcs	r6, r6, r2
    c76a:	4675      	movcs	r5, lr
    c76c:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
    c770:	085b      	lsrs	r3, r3, #1
    c772:	ea4f 0232 	mov.w	r2, r2, rrx
    c776:	ebb6 0e02 	subs.w	lr, r6, r2
    c77a:	eb75 0e03 	sbcs.w	lr, r5, r3
    c77e:	bf22      	ittt	cs
    c780:	1ab6      	subcs	r6, r6, r2
    c782:	4675      	movcs	r5, lr
    c784:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
    c788:	085b      	lsrs	r3, r3, #1
    c78a:	ea4f 0232 	mov.w	r2, r2, rrx
    c78e:	ebb6 0e02 	subs.w	lr, r6, r2
    c792:	eb75 0e03 	sbcs.w	lr, r5, r3
    c796:	bf22      	ittt	cs
    c798:	1ab6      	subcs	r6, r6, r2
    c79a:	4675      	movcs	r5, lr
    c79c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
    c7a0:	ea55 0e06 	orrs.w	lr, r5, r6
    c7a4:	d018      	beq.n	c7d8 <__aeabi_ddiv+0x114>
    c7a6:	ea4f 1505 	mov.w	r5, r5, lsl #4
    c7aa:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
    c7ae:	ea4f 1606 	mov.w	r6, r6, lsl #4
    c7b2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    c7b6:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
    c7ba:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    c7be:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
    c7c2:	d1c0      	bne.n	c746 <__aeabi_ddiv+0x82>
    c7c4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    c7c8:	d10b      	bne.n	c7e2 <__aeabi_ddiv+0x11e>
    c7ca:	ea41 0100 	orr.w	r1, r1, r0
    c7ce:	f04f 0000 	mov.w	r0, #0
    c7d2:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
    c7d6:	e7b6      	b.n	c746 <__aeabi_ddiv+0x82>
    c7d8:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    c7dc:	bf04      	itt	eq
    c7de:	4301      	orreq	r1, r0
    c7e0:	2000      	moveq	r0, #0
    c7e2:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    c7e6:	bf88      	it	hi
    c7e8:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    c7ec:	f63f aeaf 	bhi.w	c54e <__aeabi_dmul+0xde>
    c7f0:	ebb5 0c03 	subs.w	ip, r5, r3
    c7f4:	bf04      	itt	eq
    c7f6:	ebb6 0c02 	subseq.w	ip, r6, r2
    c7fa:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    c7fe:	f150 0000 	adcs.w	r0, r0, #0
    c802:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    c806:	bd70      	pop	{r4, r5, r6, pc}
    c808:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
    c80c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
    c810:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
    c814:	bfc2      	ittt	gt
    c816:	ebd4 050c 	rsbsgt	r5, r4, ip
    c81a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    c81e:	bd70      	popgt	{r4, r5, r6, pc}
    c820:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    c824:	f04f 0e00 	mov.w	lr, #0
    c828:	3c01      	subs	r4, #1
    c82a:	e690      	b.n	c54e <__aeabi_dmul+0xde>
    c82c:	ea45 0e06 	orr.w	lr, r5, r6
    c830:	e68d      	b.n	c54e <__aeabi_dmul+0xde>
    c832:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    c836:	ea94 0f0c 	teq	r4, ip
    c83a:	bf08      	it	eq
    c83c:	ea95 0f0c 	teqeq	r5, ip
    c840:	f43f af3b 	beq.w	c6ba <__aeabi_dmul+0x24a>
    c844:	ea94 0f0c 	teq	r4, ip
    c848:	d10a      	bne.n	c860 <__aeabi_ddiv+0x19c>
    c84a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    c84e:	f47f af34 	bne.w	c6ba <__aeabi_dmul+0x24a>
    c852:	ea95 0f0c 	teq	r5, ip
    c856:	f47f af25 	bne.w	c6a4 <__aeabi_dmul+0x234>
    c85a:	4610      	mov	r0, r2
    c85c:	4619      	mov	r1, r3
    c85e:	e72c      	b.n	c6ba <__aeabi_dmul+0x24a>
    c860:	ea95 0f0c 	teq	r5, ip
    c864:	d106      	bne.n	c874 <__aeabi_ddiv+0x1b0>
    c866:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    c86a:	f43f aefd 	beq.w	c668 <__aeabi_dmul+0x1f8>
    c86e:	4610      	mov	r0, r2
    c870:	4619      	mov	r1, r3
    c872:	e722      	b.n	c6ba <__aeabi_dmul+0x24a>
    c874:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    c878:	bf18      	it	ne
    c87a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    c87e:	f47f aec5 	bne.w	c60c <__aeabi_dmul+0x19c>
    c882:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
    c886:	f47f af0d 	bne.w	c6a4 <__aeabi_dmul+0x234>
    c88a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
    c88e:	f47f aeeb 	bne.w	c668 <__aeabi_dmul+0x1f8>
    c892:	e712      	b.n	c6ba <__aeabi_dmul+0x24a>

0000c894 <__gedf2>:
    c894:	f04f 3cff 	mov.w	ip, #4294967295
    c898:	e006      	b.n	c8a8 <__cmpdf2+0x4>
    c89a:	bf00      	nop

0000c89c <__ledf2>:
    c89c:	f04f 0c01 	mov.w	ip, #1
    c8a0:	e002      	b.n	c8a8 <__cmpdf2+0x4>
    c8a2:	bf00      	nop

0000c8a4 <__cmpdf2>:
    c8a4:	f04f 0c01 	mov.w	ip, #1
    c8a8:	f84d cd04 	str.w	ip, [sp, #-4]!
    c8ac:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    c8b0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    c8b4:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    c8b8:	bf18      	it	ne
    c8ba:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
    c8be:	d01b      	beq.n	c8f8 <__cmpdf2+0x54>
    c8c0:	b001      	add	sp, #4
    c8c2:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
    c8c6:	bf0c      	ite	eq
    c8c8:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
    c8cc:	ea91 0f03 	teqne	r1, r3
    c8d0:	bf02      	ittt	eq
    c8d2:	ea90 0f02 	teqeq	r0, r2
    c8d6:	2000      	moveq	r0, #0
    c8d8:	4770      	bxeq	lr
    c8da:	f110 0f00 	cmn.w	r0, #0
    c8de:	ea91 0f03 	teq	r1, r3
    c8e2:	bf58      	it	pl
    c8e4:	4299      	cmppl	r1, r3
    c8e6:	bf08      	it	eq
    c8e8:	4290      	cmpeq	r0, r2
    c8ea:	bf2c      	ite	cs
    c8ec:	17d8      	asrcs	r0, r3, #31
    c8ee:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
    c8f2:	f040 0001 	orr.w	r0, r0, #1
    c8f6:	4770      	bx	lr
    c8f8:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    c8fc:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    c900:	d102      	bne.n	c908 <__cmpdf2+0x64>
    c902:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
    c906:	d107      	bne.n	c918 <__cmpdf2+0x74>
    c908:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    c90c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    c910:	d1d6      	bne.n	c8c0 <__cmpdf2+0x1c>
    c912:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
    c916:	d0d3      	beq.n	c8c0 <__cmpdf2+0x1c>
    c918:	f85d 0b04 	ldr.w	r0, [sp], #4
    c91c:	4770      	bx	lr
    c91e:	bf00      	nop

0000c920 <__aeabi_cdrcmple>:
    c920:	4684      	mov	ip, r0
    c922:	4610      	mov	r0, r2
    c924:	4662      	mov	r2, ip
    c926:	468c      	mov	ip, r1
    c928:	4619      	mov	r1, r3
    c92a:	4663      	mov	r3, ip
    c92c:	e000      	b.n	c930 <__aeabi_cdcmpeq>
    c92e:	bf00      	nop

0000c930 <__aeabi_cdcmpeq>:
    c930:	b501      	push	{r0, lr}
    c932:	f7ff ffb7 	bl	c8a4 <__cmpdf2>
    c936:	2800      	cmp	r0, #0
    c938:	bf48      	it	mi
    c93a:	f110 0f00 	cmnmi.w	r0, #0
    c93e:	bd01      	pop	{r0, pc}

0000c940 <__aeabi_dcmpeq>:
    c940:	f84d ed08 	str.w	lr, [sp, #-8]!
    c944:	f7ff fff4 	bl	c930 <__aeabi_cdcmpeq>
    c948:	bf0c      	ite	eq
    c94a:	2001      	moveq	r0, #1
    c94c:	2000      	movne	r0, #0
    c94e:	f85d fb08 	ldr.w	pc, [sp], #8
    c952:	bf00      	nop

0000c954 <__aeabi_dcmplt>:
    c954:	f84d ed08 	str.w	lr, [sp, #-8]!
    c958:	f7ff ffea 	bl	c930 <__aeabi_cdcmpeq>
    c95c:	bf34      	ite	cc
    c95e:	2001      	movcc	r0, #1
    c960:	2000      	movcs	r0, #0
    c962:	f85d fb08 	ldr.w	pc, [sp], #8
    c966:	bf00      	nop

0000c968 <__aeabi_dcmple>:
    c968:	f84d ed08 	str.w	lr, [sp, #-8]!
    c96c:	f7ff ffe0 	bl	c930 <__aeabi_cdcmpeq>
    c970:	bf94      	ite	ls
    c972:	2001      	movls	r0, #1
    c974:	2000      	movhi	r0, #0
    c976:	f85d fb08 	ldr.w	pc, [sp], #8
    c97a:	bf00      	nop

0000c97c <__aeabi_dcmpge>:
    c97c:	f84d ed08 	str.w	lr, [sp, #-8]!
    c980:	f7ff ffce 	bl	c920 <__aeabi_cdrcmple>
    c984:	bf94      	ite	ls
    c986:	2001      	movls	r0, #1
    c988:	2000      	movhi	r0, #0
    c98a:	f85d fb08 	ldr.w	pc, [sp], #8
    c98e:	bf00      	nop

0000c990 <__aeabi_dcmpgt>:
    c990:	f84d ed08 	str.w	lr, [sp, #-8]!
    c994:	f7ff ffc4 	bl	c920 <__aeabi_cdrcmple>
    c998:	bf34      	ite	cc
    c99a:	2001      	movcc	r0, #1
    c99c:	2000      	movcs	r0, #0
    c99e:	f85d fb08 	ldr.w	pc, [sp], #8
    c9a2:	bf00      	nop

0000c9a4 <__aeabi_d2uiz>:
    c9a4:	004a      	lsls	r2, r1, #1
    c9a6:	d211      	bcs.n	c9cc <__aeabi_d2uiz+0x28>
    c9a8:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
    c9ac:	d211      	bcs.n	c9d2 <__aeabi_d2uiz+0x2e>
    c9ae:	d50d      	bpl.n	c9cc <__aeabi_d2uiz+0x28>
    c9b0:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
    c9b4:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
    c9b8:	d40e      	bmi.n	c9d8 <__aeabi_d2uiz+0x34>
    c9ba:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    c9be:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    c9c2:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
    c9c6:	fa23 f002 	lsr.w	r0, r3, r2
    c9ca:	4770      	bx	lr
    c9cc:	f04f 0000 	mov.w	r0, #0
    c9d0:	4770      	bx	lr
    c9d2:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
    c9d6:	d102      	bne.n	c9de <__aeabi_d2uiz+0x3a>
    c9d8:	f04f 30ff 	mov.w	r0, #4294967295
    c9dc:	4770      	bx	lr
    c9de:	f04f 0000 	mov.w	r0, #0
    c9e2:	4770      	bx	lr

0000c9e4 <__aeabi_d2f>:
    c9e4:	ea4f 0241 	mov.w	r2, r1, lsl #1
    c9e8:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
    c9ec:	bf24      	itt	cs
    c9ee:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
    c9f2:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
    c9f6:	d90d      	bls.n	ca14 <__aeabi_d2f+0x30>
    c9f8:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    c9fc:	ea4f 02c0 	mov.w	r2, r0, lsl #3
    ca00:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
    ca04:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
    ca08:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
    ca0c:	bf08      	it	eq
    ca0e:	f020 0001 	biceq.w	r0, r0, #1
    ca12:	4770      	bx	lr
    ca14:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
    ca18:	d121      	bne.n	ca5e <__aeabi_d2f+0x7a>
    ca1a:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
    ca1e:	bfbc      	itt	lt
    ca20:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
    ca24:	4770      	bxlt	lr
    ca26:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    ca2a:	ea4f 5252 	mov.w	r2, r2, lsr #21
    ca2e:	f1c2 0218 	rsb	r2, r2, #24
    ca32:	f1c2 0c20 	rsb	ip, r2, #32
    ca36:	fa10 f30c 	lsls.w	r3, r0, ip
    ca3a:	fa20 f002 	lsr.w	r0, r0, r2
    ca3e:	bf18      	it	ne
    ca40:	f040 0001 	orrne.w	r0, r0, #1
    ca44:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    ca48:	ea4f 23d3 	mov.w	r3, r3, lsr #11
    ca4c:	fa03 fc0c 	lsl.w	ip, r3, ip
    ca50:	ea40 000c 	orr.w	r0, r0, ip
    ca54:	fa23 f302 	lsr.w	r3, r3, r2
    ca58:	ea4f 0343 	mov.w	r3, r3, lsl #1
    ca5c:	e7cc      	b.n	c9f8 <__aeabi_d2f+0x14>
    ca5e:	ea7f 5362 	mvns.w	r3, r2, asr #21
    ca62:	d107      	bne.n	ca74 <__aeabi_d2f+0x90>
    ca64:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
    ca68:	bf1e      	ittt	ne
    ca6a:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
    ca6e:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
    ca72:	4770      	bxne	lr
    ca74:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
    ca78:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    ca7c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    ca80:	4770      	bx	lr
    ca82:	bf00      	nop

0000ca84 <SysTick_Handler>:
{
    //
    // Add enough cycles to account for one full cycle of systick.
    //
#ifdef TIME_64
    g_ui32SysTickWrappedTime++;
    ca84:	4a02      	ldr	r2, [pc, #8]	; (ca90 <SysTick_Handler+0xc>)
    ca86:	6813      	ldr	r3, [r2, #0]
    ca88:	3301      	adds	r3, #1
    ca8a:	6013      	str	r3, [r2, #0]
    ca8c:	4770      	bx	lr
    ca8e:	bf00      	nop
    ca90:	10001018 	.word	0x10001018

0000ca94 <core_list_mergesort.constprop.2>:
    Note:
    We have a special header for the list that will always be first,
    but the algorithm could theoretically modify where the list starts.

 */
list_head *core_list_mergesort(list_head *list, list_cmp cmp, core_results *res) {
    ca94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    list_head *p, *q, *e, *tail;
    ee_s32 insize, nmerges, psize, qsize, i;

    insize = 1;
    ca98:	f04f 0c01 	mov.w	ip, #1
        list = NULL;
        tail = NULL;

        nmerges = 0;  /* count number of merges we do in this pass */

        while (p) {
    ca9c:	f04f 0900 	mov.w	r9, #0
    caa0:	2800      	cmp	r0, #0
    caa2:	f000 8099 	beq.w	cbd8 <core_list_mergesort.constprop.2+0x144>
    caa6:	f04f 0e00 	mov.w	lr, #0
    caaa:	4671      	mov	r1, lr
    caac:	46f0      	mov	r8, lr
            /* step `insize' places along from p */
            q = p;
            psize = 0;
            for (i = 0; i < insize; i++) {
                psize++;
                q = q->next;
    caae:	6803      	ldr	r3, [r0, #0]
    cab0:	f10c 32ff 	add.w	r2, ip, #4294967295
            nmerges++;  /* there exists a merge to be done */
    cab4:	f108 0801 	add.w	r8, r8, #1
    cab8:	f002 0507 	and.w	r5, r2, #7
                psize++;
    cabc:	2401      	movs	r4, #1
                if (!q) break;
    cabe:	2b00      	cmp	r3, #0
    cac0:	d03f      	beq.n	cb42 <core_list_mergesort.constprop.2+0xae>
            for (i = 0; i < insize; i++) {
    cac2:	4564      	cmp	r4, ip
    cac4:	d03d      	beq.n	cb42 <core_list_mergesort.constprop.2+0xae>
    cac6:	b315      	cbz	r5, cb0e <core_list_mergesort.constprop.2+0x7a>
    cac8:	2d01      	cmp	r5, #1
    caca:	d01b      	beq.n	cb04 <core_list_mergesort.constprop.2+0x70>
    cacc:	2d02      	cmp	r5, #2
    cace:	d016      	beq.n	cafe <core_list_mergesort.constprop.2+0x6a>
    cad0:	2d03      	cmp	r5, #3
    cad2:	d011      	beq.n	caf8 <core_list_mergesort.constprop.2+0x64>
    cad4:	2d04      	cmp	r5, #4
    cad6:	d00c      	beq.n	caf2 <core_list_mergesort.constprop.2+0x5e>
    cad8:	2d05      	cmp	r5, #5
    cada:	d007      	beq.n	caec <core_list_mergesort.constprop.2+0x58>
    cadc:	2d06      	cmp	r5, #6
    cade:	d002      	beq.n	cae6 <core_list_mergesort.constprop.2+0x52>
                q = q->next;
    cae0:	681b      	ldr	r3, [r3, #0]
                psize++;
    cae2:	2402      	movs	r4, #2
                if (!q) break;
    cae4:	b36b      	cbz	r3, cb42 <core_list_mergesort.constprop.2+0xae>
                q = q->next;
    cae6:	681b      	ldr	r3, [r3, #0]
                psize++;
    cae8:	3401      	adds	r4, #1
                if (!q) break;
    caea:	b353      	cbz	r3, cb42 <core_list_mergesort.constprop.2+0xae>
                q = q->next;
    caec:	681b      	ldr	r3, [r3, #0]
                psize++;
    caee:	3401      	adds	r4, #1
                if (!q) break;
    caf0:	b33b      	cbz	r3, cb42 <core_list_mergesort.constprop.2+0xae>
                q = q->next;
    caf2:	681b      	ldr	r3, [r3, #0]
                psize++;
    caf4:	3401      	adds	r4, #1
                if (!q) break;
    caf6:	b323      	cbz	r3, cb42 <core_list_mergesort.constprop.2+0xae>
                q = q->next;
    caf8:	681b      	ldr	r3, [r3, #0]
                psize++;
    cafa:	3401      	adds	r4, #1
                if (!q) break;
    cafc:	b30b      	cbz	r3, cb42 <core_list_mergesort.constprop.2+0xae>
                q = q->next;
    cafe:	681b      	ldr	r3, [r3, #0]
                psize++;
    cb00:	3401      	adds	r4, #1
                if (!q) break;
    cb02:	b1f3      	cbz	r3, cb42 <core_list_mergesort.constprop.2+0xae>
                q = q->next;
    cb04:	681b      	ldr	r3, [r3, #0]
                psize++;
    cb06:	3401      	adds	r4, #1
                if (!q) break;
    cb08:	b1db      	cbz	r3, cb42 <core_list_mergesort.constprop.2+0xae>
            for (i = 0; i < insize; i++) {
    cb0a:	4564      	cmp	r4, ip
    cb0c:	d019      	beq.n	cb42 <core_list_mergesort.constprop.2+0xae>
                q = q->next;
    cb0e:	681b      	ldr	r3, [r3, #0]
                psize++;
    cb10:	3401      	adds	r4, #1
    cb12:	4626      	mov	r6, r4
                if (!q) break;
    cb14:	b1ab      	cbz	r3, cb42 <core_list_mergesort.constprop.2+0xae>
                q = q->next;
    cb16:	681b      	ldr	r3, [r3, #0]
                psize++;
    cb18:	3401      	adds	r4, #1
                if (!q) break;
    cb1a:	b193      	cbz	r3, cb42 <core_list_mergesort.constprop.2+0xae>
                q = q->next;
    cb1c:	681b      	ldr	r3, [r3, #0]
                psize++;
    cb1e:	1cb4      	adds	r4, r6, #2
                if (!q) break;
    cb20:	b17b      	cbz	r3, cb42 <core_list_mergesort.constprop.2+0xae>
                q = q->next;
    cb22:	681b      	ldr	r3, [r3, #0]
                psize++;
    cb24:	1cf4      	adds	r4, r6, #3
                if (!q) break;
    cb26:	b163      	cbz	r3, cb42 <core_list_mergesort.constprop.2+0xae>
                q = q->next;
    cb28:	681b      	ldr	r3, [r3, #0]
                psize++;
    cb2a:	1d34      	adds	r4, r6, #4
                if (!q) break;
    cb2c:	b14b      	cbz	r3, cb42 <core_list_mergesort.constprop.2+0xae>
                q = q->next;
    cb2e:	681b      	ldr	r3, [r3, #0]
                psize++;
    cb30:	1d74      	adds	r4, r6, #5
                if (!q) break;
    cb32:	b133      	cbz	r3, cb42 <core_list_mergesort.constprop.2+0xae>
                q = q->next;
    cb34:	681b      	ldr	r3, [r3, #0]
                psize++;
    cb36:	1db4      	adds	r4, r6, #6
                if (!q) break;
    cb38:	b11b      	cbz	r3, cb42 <core_list_mergesort.constprop.2+0xae>
                q = q->next;
    cb3a:	681b      	ldr	r3, [r3, #0]
                psize++;
    cb3c:	1df4      	adds	r4, r6, #7
                if (!q) break;
    cb3e:	2b00      	cmp	r3, #0
    cb40:	d1e3      	bne.n	cb0a <core_list_mergesort.constprop.2+0x76>

                /* add the next element to the merged list */
                if (tail) {
                    tail->next = e;
                } else {
                    list = e;
    cb42:	4665      	mov	r5, ip
            while (psize > 0 || (qsize > 0 && q)) {
    cb44:	b344      	cbz	r4, cb98 <core_list_mergesort.constprop.2+0x104>
                } else if (qsize == 0 || !q) {
    cb46:	b38d      	cbz	r5, cbac <core_list_mergesort.constprop.2+0x118>
    cb48:	b383      	cbz	r3, cbac <core_list_mergesort.constprop.2+0x118>
                } else if (cmp(p->info,q->info,res) <= 0) {
    cb4a:	f8d0 a004 	ldr.w	sl, [r0, #4]
    cb4e:	685f      	ldr	r7, [r3, #4]
        a->data16 = (a->data16 & 0xff00) | (0x00ff & (a->data16>>8));
    cb50:	f9ba 2000 	ldrsh.w	r2, [sl]
    return a->idx - b->idx;
    cb54:	f9ba 6002 	ldrsh.w	r6, [sl, #2]
        a->data16 = (a->data16 & 0xff00) | (0x00ff & (a->data16>>8));
    cb58:	f022 0bff 	bic.w	fp, r2, #255	; 0xff
    cb5c:	f3c2 2207 	ubfx	r2, r2, #8, #8
    cb60:	ea4b 0b02 	orr.w	fp, fp, r2
    cb64:	f8aa b000 	strh.w	fp, [sl]
        b->data16 = (b->data16 & 0xff00) | (0x00ff & (b->data16>>8));
    cb68:	f9b7 2000 	ldrsh.w	r2, [r7]
    return a->idx - b->idx;
    cb6c:	f9b7 b002 	ldrsh.w	fp, [r7, #2]
        b->data16 = (b->data16 & 0xff00) | (0x00ff & (b->data16>>8));
    cb70:	f022 0aff 	bic.w	sl, r2, #255	; 0xff
    return a->idx - b->idx;
    cb74:	eba6 060b 	sub.w	r6, r6, fp
        b->data16 = (b->data16 & 0xff00) | (0x00ff & (b->data16>>8));
    cb78:	f3c2 2207 	ubfx	r2, r2, #8, #8
    cb7c:	ea4a 0b02 	orr.w	fp, sl, r2
                } else if (cmp(p->info,q->info,res) <= 0) {
    cb80:	2e00      	cmp	r6, #0
        b->data16 = (b->data16 & 0xff00) | (0x00ff & (b->data16>>8));
    cb82:	f8a7 b000 	strh.w	fp, [r7]
                } else if (cmp(p->info,q->info,res) <= 0) {
    cb86:	dd11      	ble.n	cbac <core_list_mergesort.constprop.2+0x118>
                    e = q; q = q->next; qsize--;
    cb88:	461f      	mov	r7, r3
    cb8a:	681b      	ldr	r3, [r3, #0]
    cb8c:	3d01      	subs	r5, #1
                if (tail) {
    cb8e:	b151      	cbz	r1, cba6 <core_list_mergesort.constprop.2+0x112>
                    tail->next = e;
    cb90:	600f      	str	r7, [r1, #0]
                    list = e;
    cb92:	4639      	mov	r1, r7
            while (psize > 0 || (qsize > 0 && q)) {
    cb94:	2c00      	cmp	r4, #0
    cb96:	d1d6      	bne.n	cb46 <core_list_mergesort.constprop.2+0xb2>
    cb98:	b165      	cbz	r5, cbb4 <core_list_mergesort.constprop.2+0x120>
    cb9a:	b17b      	cbz	r3, cbbc <core_list_mergesort.constprop.2+0x128>
                    e = q; q = q->next; qsize--;
    cb9c:	461f      	mov	r7, r3
    cb9e:	3d01      	subs	r5, #1
    cba0:	681b      	ldr	r3, [r3, #0]
                if (tail) {
    cba2:	2900      	cmp	r1, #0
    cba4:	d1f4      	bne.n	cb90 <core_list_mergesort.constprop.2+0xfc>
                    list = e;
    cba6:	46be      	mov	lr, r7
    cba8:	4639      	mov	r1, r7
    cbaa:	e7f3      	b.n	cb94 <core_list_mergesort.constprop.2+0x100>
                    e = p; p = p->next; psize--;
    cbac:	4607      	mov	r7, r0
    cbae:	3c01      	subs	r4, #1
    cbb0:	6800      	ldr	r0, [r0, #0]
    cbb2:	e7ec      	b.n	cb8e <core_list_mergesort.constprop.2+0xfa>
        while (p) {
    cbb4:	4618      	mov	r0, r3
    cbb6:	2b00      	cmp	r3, #0
    cbb8:	f47f af79 	bne.w	caae <core_list_mergesort.constprop.2+0x1a>
        }

        tail->next = NULL;

        /* If we have done only one merge, we're finished. */
        if (nmerges <= 1)   /* allow for nmerges==0, the empty list case */
    cbbc:	f1b8 0f01 	cmp.w	r8, #1
        tail->next = NULL;
    cbc0:	f8c1 9000 	str.w	r9, [r1]
        if (nmerges <= 1)   /* allow for nmerges==0, the empty list case */
    cbc4:	d102      	bne.n	cbcc <core_list_mergesort.constprop.2+0x138>
        insize *= 2;
    }
#if COMPILER_REQUIRES_SORT_RETURN
    return list;
#endif
}
    cbc6:	4670      	mov	r0, lr
    cbc8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        insize *= 2;
    cbcc:	4670      	mov	r0, lr
    cbce:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
        while (p) {
    cbd2:	2800      	cmp	r0, #0
    cbd4:	f47f af67 	bne.w	caa6 <core_list_mergesort.constprop.2+0x12>
        tail->next = NULL;
    cbd8:	6000      	str	r0, [r0, #0]
    cbda:	deff      	udf	#255	; 0xff

0000cbdc <core_bench_list>:
ee_u16 core_bench_list(core_results *res, ee_s16 finder_idx) {
    cbdc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ee_s16 find_num=res->seed3;
    cbe0:	f9b0 5004 	ldrsh.w	r5, [r0, #4]
    list_head *list=res->list;
    cbe4:	f8d0 b024 	ldr.w	fp, [r0, #36]	; 0x24
ee_u16 core_bench_list(core_results *res, ee_s16 finder_idx) {
    cbe8:	b08d      	sub	sp, #52	; 0x34
    for (i=0; i<find_num; i++) {
    cbea:	2d00      	cmp	r5, #0
ee_u16 core_bench_list(core_results *res, ee_s16 finder_idx) {
    cbec:	9003      	str	r0, [sp, #12]
    cbee:	468c      	mov	ip, r1
    for (i=0; i<find_num; i++) {
    cbf0:	f340 8215 	ble.w	d01e <core_bench_list+0x442>
    cbf4:	2000      	movs	r0, #0
    cbf6:	4604      	mov	r4, r0
    cbf8:	4602      	mov	r2, r0
        while (list && (list->info->idx != info->idx))
    cbfa:	4686      	mov	lr, r0
    for (i=0; i<find_num; i++) {
    cbfc:	460f      	mov	r7, r1
    cbfe:	4681      	mov	r9, r0
    cc00:	46aa      	mov	sl, r5
    cc02:	465b      	mov	r3, fp
    cc04:	4688      	mov	r8, r1
    if (info->idx>=0) {
    cc06:	2f00      	cmp	r7, #0
        info.data16= (i & 0xff) ;
    cc08:	fa5f fc80 	uxtb.w	ip, r0
    if (info->idx>=0) {
    cc0c:	f2c0 81d5 	blt.w	cfba <core_bench_list+0x3de>
        while (list && (list->info->idx != info->idx))
    cc10:	2b00      	cmp	r3, #0
    cc12:	f000 81e2 	beq.w	cfda <core_bench_list+0x3fe>
    cc16:	685d      	ldr	r5, [r3, #4]
    cc18:	f9b5 b002 	ldrsh.w	fp, [r5, #2]
    cc1c:	45bb      	cmp	fp, r7
    cc1e:	461d      	mov	r5, r3
    cc20:	d105      	bne.n	cc2e <core_bench_list+0x52>
    cc22:	e007      	b.n	cc34 <core_bench_list+0x58>
    cc24:	6869      	ldr	r1, [r5, #4]
    cc26:	f9b1 6002 	ldrsh.w	r6, [r1, #2]
    cc2a:	42be      	cmp	r6, r7
    cc2c:	d002      	beq.n	cc34 <core_bench_list+0x58>
            list=list->next;
    cc2e:	682d      	ldr	r5, [r5, #0]
        while (list && (list->info->idx != info->idx))
    cc30:	2d00      	cmp	r5, #0
    cc32:	d1f7      	bne.n	cc24 <core_bench_list+0x48>
    cc34:	2600      	movs	r6, #0
    cc36:	e001      	b.n	cc3c <core_bench_list+0x60>
    while (list) {
    cc38:	461e      	mov	r6, r3
    cc3a:	460b      	mov	r3, r1
        tmp=list->next;
    cc3c:	6819      	ldr	r1, [r3, #0]
        list->next=next;
    cc3e:	601e      	str	r6, [r3, #0]
    while (list) {
    cc40:	2900      	cmp	r1, #0
    cc42:	d1f9      	bne.n	cc38 <core_bench_list+0x5c>
        if (this_find==NULL) {
    cc44:	2d00      	cmp	r5, #0
    cc46:	f000 81cb 	beq.w	cfe0 <core_bench_list+0x404>
            if (this_find->info->data16 & 0x1) /* use found value */
    cc4a:	686e      	ldr	r6, [r5, #4]
    cc4c:	f9b6 b000 	ldrsh.w	fp, [r6]
            found++;
    cc50:	3401      	adds	r4, #1
            if (this_find->info->data16 & 0x1) /* use found value */
    cc52:	ea5f 76cb 	movs.w	r6, fp, lsl #31
            found++;
    cc56:	b2a4      	uxth	r4, r4
            if (this_find->info->data16 & 0x1) /* use found value */
    cc58:	d503      	bpl.n	cc62 <core_bench_list+0x86>
                retval+=(this_find->info->data16 >> 9) & 1;
    cc5a:	f3cb 2140 	ubfx	r1, fp, #9, #1
    cc5e:	440a      	add	r2, r1
    cc60:	b292      	uxth	r2, r2
            if (this_find->next != NULL) {
    cc62:	6829      	ldr	r1, [r5, #0]
    cc64:	b121      	cbz	r1, cc70 <core_bench_list+0x94>
                this_find->next = finder->next;
    cc66:	680e      	ldr	r6, [r1, #0]
    cc68:	602e      	str	r6, [r5, #0]
                finder->next=list->next;
    cc6a:	681d      	ldr	r5, [r3, #0]
    cc6c:	600d      	str	r5, [r1, #0]
                list->next=finder;
    cc6e:	6019      	str	r1, [r3, #0]
        if (info.idx>=0)
    cc70:	2f00      	cmp	r7, #0
    cc72:	f100 0001 	add.w	r0, r0, #1
            info.idx++;
    cc76:	bfa8      	it	ge
    cc78:	3701      	addge	r7, #1
    for (i=0; i<find_num; i++) {
    cc7a:	b201      	sxth	r1, r0
            info.idx++;
    cc7c:	bfa8      	it	ge
    cc7e:	b23f      	sxthge	r7, r7
    for (i=0; i<find_num; i++) {
    cc80:	458a      	cmp	sl, r1
    cc82:	dcc0      	bgt.n	cc06 <core_bench_list+0x2a>
    cc84:	ebc9 0084 	rsb	r0, r9, r4, lsl #2
    cc88:	4402      	add	r2, r0
    cc8a:	970a      	str	r7, [sp, #40]	; 0x28
    cc8c:	b297      	uxth	r7, r2
    cc8e:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
    cc92:	469b      	mov	fp, r3
    cc94:	46c4      	mov	ip, r8
    cc96:	9709      	str	r7, [sp, #36]	; 0x24
    if (finder_idx>0)
    cc98:	f1bc 0f00 	cmp.w	ip, #0
    cc9c:	f340 8146 	ble.w	cf2c <core_bench_list+0x350>
                retval=core_bench_matrix(&(res->mat),dtype,res->crc);
    cca0:	9c03      	ldr	r4, [sp, #12]
    cca2:	f8cd b014 	str.w	fp, [sp, #20]
    cca6:	2301      	movs	r3, #1
    cca8:	4622      	mov	r2, r4
    ccaa:	9306      	str	r3, [sp, #24]
    ccac:	3228      	adds	r2, #40	; 0x28
    ccae:	9b05      	ldr	r3, [sp, #20]
    ccb0:	9207      	str	r2, [sp, #28]
    if (finder_idx>0)
    ccb2:	46da      	mov	sl, fp
                retval=core_bench_matrix(&(res->mat),dtype,res->crc);
    ccb4:	46a3      	mov	fp, r4
        while (p) {
    ccb6:	2b00      	cmp	r3, #0
    ccb8:	f000 81b5 	beq.w	d026 <core_bench_list+0x44a>
    ccbc:	2600      	movs	r6, #0
    ccbe:	9605      	str	r6, [sp, #20]
    ccc0:	4637      	mov	r7, r6
    ccc2:	9608      	str	r6, [sp, #32]
            nmerges++;  /* there exists a merge to be done */
    ccc4:	9808      	ldr	r0, [sp, #32]
    ccc6:	9d06      	ldr	r5, [sp, #24]
                q = q->next;
    ccc8:	f8da 4000 	ldr.w	r4, [sl]
    cccc:	1e69      	subs	r1, r5, #1
            nmerges++;  /* there exists a merge to be done */
    ccce:	3001      	adds	r0, #1
    ccd0:	9008      	str	r0, [sp, #32]
    ccd2:	f001 0307 	and.w	r3, r1, #7
                psize++;
    ccd6:	f04f 0c01 	mov.w	ip, #1
                if (!q) break;
    ccda:	2c00      	cmp	r4, #0
    ccdc:	d053      	beq.n	cd86 <core_bench_list+0x1aa>
            for (i = 0; i < insize; i++) {
    ccde:	9a06      	ldr	r2, [sp, #24]
    cce0:	4594      	cmp	ip, r2
    cce2:	d050      	beq.n	cd86 <core_bench_list+0x1aa>
    cce4:	b36b      	cbz	r3, cd42 <core_bench_list+0x166>
    cce6:	2b01      	cmp	r3, #1
    cce8:	d024      	beq.n	cd34 <core_bench_list+0x158>
    ccea:	2b02      	cmp	r3, #2
    ccec:	d01e      	beq.n	cd2c <core_bench_list+0x150>
    ccee:	2b03      	cmp	r3, #3
    ccf0:	d018      	beq.n	cd24 <core_bench_list+0x148>
    ccf2:	2b04      	cmp	r3, #4
    ccf4:	d012      	beq.n	cd1c <core_bench_list+0x140>
    ccf6:	2b05      	cmp	r3, #5
    ccf8:	d00b      	beq.n	cd12 <core_bench_list+0x136>
    ccfa:	2b06      	cmp	r3, #6
    ccfc:	d004      	beq.n	cd08 <core_bench_list+0x12c>
                q = q->next;
    ccfe:	6824      	ldr	r4, [r4, #0]
                psize++;
    cd00:	f04f 0c02 	mov.w	ip, #2
                if (!q) break;
    cd04:	2c00      	cmp	r4, #0
    cd06:	d03e      	beq.n	cd86 <core_bench_list+0x1aa>
                q = q->next;
    cd08:	6824      	ldr	r4, [r4, #0]
                psize++;
    cd0a:	f10c 0c01 	add.w	ip, ip, #1
                if (!q) break;
    cd0e:	2c00      	cmp	r4, #0
    cd10:	d039      	beq.n	cd86 <core_bench_list+0x1aa>
                q = q->next;
    cd12:	6824      	ldr	r4, [r4, #0]
                psize++;
    cd14:	f10c 0c01 	add.w	ip, ip, #1
                if (!q) break;
    cd18:	2c00      	cmp	r4, #0
    cd1a:	d034      	beq.n	cd86 <core_bench_list+0x1aa>
                q = q->next;
    cd1c:	6824      	ldr	r4, [r4, #0]
                psize++;
    cd1e:	f10c 0c01 	add.w	ip, ip, #1
                if (!q) break;
    cd22:	b384      	cbz	r4, cd86 <core_bench_list+0x1aa>
                q = q->next;
    cd24:	6824      	ldr	r4, [r4, #0]
                psize++;
    cd26:	f10c 0c01 	add.w	ip, ip, #1
                if (!q) break;
    cd2a:	b364      	cbz	r4, cd86 <core_bench_list+0x1aa>
                q = q->next;
    cd2c:	6824      	ldr	r4, [r4, #0]
                psize++;
    cd2e:	f10c 0c01 	add.w	ip, ip, #1
                if (!q) break;
    cd32:	b344      	cbz	r4, cd86 <core_bench_list+0x1aa>
                q = q->next;
    cd34:	6824      	ldr	r4, [r4, #0]
                psize++;
    cd36:	f10c 0c01 	add.w	ip, ip, #1
                if (!q) break;
    cd3a:	b324      	cbz	r4, cd86 <core_bench_list+0x1aa>
            for (i = 0; i < insize; i++) {
    cd3c:	9e06      	ldr	r6, [sp, #24]
    cd3e:	45b4      	cmp	ip, r6
    cd40:	d021      	beq.n	cd86 <core_bench_list+0x1aa>
                q = q->next;
    cd42:	6824      	ldr	r4, [r4, #0]
                psize++;
    cd44:	f10c 0c01 	add.w	ip, ip, #1
    cd48:	46e6      	mov	lr, ip
                if (!q) break;
    cd4a:	b1e4      	cbz	r4, cd86 <core_bench_list+0x1aa>
                q = q->next;
    cd4c:	6824      	ldr	r4, [r4, #0]
                psize++;
    cd4e:	f10c 0c01 	add.w	ip, ip, #1
                if (!q) break;
    cd52:	b1c4      	cbz	r4, cd86 <core_bench_list+0x1aa>
                q = q->next;
    cd54:	6824      	ldr	r4, [r4, #0]
                psize++;
    cd56:	f10e 0c02 	add.w	ip, lr, #2
                if (!q) break;
    cd5a:	b1a4      	cbz	r4, cd86 <core_bench_list+0x1aa>
                q = q->next;
    cd5c:	6824      	ldr	r4, [r4, #0]
                psize++;
    cd5e:	f10e 0c03 	add.w	ip, lr, #3
                if (!q) break;
    cd62:	b184      	cbz	r4, cd86 <core_bench_list+0x1aa>
                q = q->next;
    cd64:	6824      	ldr	r4, [r4, #0]
                psize++;
    cd66:	f10e 0c04 	add.w	ip, lr, #4
                if (!q) break;
    cd6a:	b164      	cbz	r4, cd86 <core_bench_list+0x1aa>
                q = q->next;
    cd6c:	6824      	ldr	r4, [r4, #0]
                psize++;
    cd6e:	f10e 0c05 	add.w	ip, lr, #5
                if (!q) break;
    cd72:	b144      	cbz	r4, cd86 <core_bench_list+0x1aa>
                q = q->next;
    cd74:	6824      	ldr	r4, [r4, #0]
                psize++;
    cd76:	f10e 0c06 	add.w	ip, lr, #6
                if (!q) break;
    cd7a:	b124      	cbz	r4, cd86 <core_bench_list+0x1aa>
                q = q->next;
    cd7c:	6824      	ldr	r4, [r4, #0]
                psize++;
    cd7e:	f10e 0c07 	add.w	ip, lr, #7
                if (!q) break;
    cd82:	2c00      	cmp	r4, #0
    cd84:	d1da      	bne.n	cd3c <core_bench_list+0x160>
                    list = e;
    cd86:	f8dd 9018 	ldr.w	r9, [sp, #24]
    cd8a:	4666      	mov	r6, ip
    cd8c:	464d      	mov	r5, r9
            while (psize > 0 || (qsize > 0 && q)) {
    cd8e:	2e00      	cmp	r6, #0
    cd90:	d06b      	beq.n	ce6a <core_bench_list+0x28e>
                } else if (qsize == 0 || !q) {
    cd92:	2d00      	cmp	r5, #0
    cd94:	d075      	beq.n	ce82 <core_bench_list+0x2a6>
    cd96:	2c00      	cmp	r4, #0
    cd98:	d073      	beq.n	ce82 <core_bench_list+0x2a6>
                } else if (cmp(p->info,q->info,res) <= 0) {
    cd9a:	f8da 9004 	ldr.w	r9, [sl, #4]
    cd9e:	6860      	ldr	r0, [r4, #4]
    ee_s16 data=*pdata;
    cda0:	f9b9 8000 	ldrsh.w	r8, [r9]
                } else if (cmp(p->info,q->info,res) <= 0) {
    cda4:	9003      	str	r0, [sp, #12]
    if (optype) /* if cached, use cache */
    cda6:	f018 0f80 	tst.w	r8, #128	; 0x80
    cdaa:	d16f      	bne.n	ce8c <core_bench_list+0x2b0>
        ee_s16 dtype=((data>>3) & 0xf); /* bits 3-6 is specific data for the operation */
    cdac:	f3c8 02c3 	ubfx	r2, r8, #3, #4
        switch (flag) {
    cdb0:	f018 0007 	ands.w	r0, r8, #7
        dtype |= dtype << 4; /* replicate the lower 4 bits to get an 8b value */
    cdb4:	ea42 1102 	orr.w	r1, r2, r2, lsl #4
        switch (flag) {
    cdb8:	d074      	beq.n	cea4 <core_bench_list+0x2c8>
    cdba:	2801      	cmp	r0, #1
    cdbc:	d170      	bne.n	cea0 <core_bench_list+0x2c4>
                retval=core_bench_matrix(&(res->mat),dtype,res->crc);
    cdbe:	f8bb 2038 	ldrh.w	r2, [fp, #56]	; 0x38
    cdc2:	9807      	ldr	r0, [sp, #28]
    cdc4:	f001 fe26 	bl	ea14 <core_bench_matrix>
                if (res->crcmatrix==0)
    cdc8:	f8bb 303c 	ldrh.w	r3, [fp, #60]	; 0x3c
                retval=core_bench_matrix(&(res->mat),dtype,res->crc);
    cdcc:	b202      	sxth	r2, r0
                if (res->crcmatrix==0)
    cdce:	b90b      	cbnz	r3, cdd4 <core_bench_list+0x1f8>
                    res->crcmatrix=retval;
    cdd0:	f8ab 003c 	strh.w	r0, [fp, #60]	; 0x3c
        res->crc=crcu16(retval,res->crc);
    cdd4:	f8bb 1038 	ldrh.w	r1, [fp, #56]	; 0x38
    cdd8:	9204      	str	r2, [sp, #16]
    cdda:	b290      	uxth	r0, r2
    cddc:	f002 fa52 	bl	f284 <crcu16>
        retval &= 0x007f;
    cde0:	9904      	ldr	r1, [sp, #16]
        res->crc=crcu16(retval,res->crc);
    cde2:	f8ab 0038 	strh.w	r0, [fp, #56]	; 0x38
        *pdata = (data & 0xff00) | 0x0080 | retval; /* cache the result */
    cde6:	f028 02ff 	bic.w	r2, r8, #255	; 0xff
    cdea:	f042 0380 	orr.w	r3, r2, #128	; 0x80
        retval &= 0x007f;
    cdee:	f001 087f 	and.w	r8, r1, #127	; 0x7f
        *pdata = (data & 0xff00) | 0x0080 | retval; /* cache the result */
    cdf2:	ea48 0203 	orr.w	r2, r8, r3
    cdf6:	9803      	ldr	r0, [sp, #12]
    cdf8:	f8a9 2000 	strh.w	r2, [r9]
    ee_s16 data=*pdata;
    cdfc:	f9b0 9000 	ldrsh.w	r9, [r0]
    if (optype) /* if cached, use cache */
    ce00:	f019 0f80 	tst.w	r9, #128	; 0x80
    ce04:	d149      	bne.n	ce9a <core_bench_list+0x2be>
        ee_s16 dtype=((data>>3) & 0xf); /* bits 3-6 is specific data for the operation */
    ce06:	f3c9 03c3 	ubfx	r3, r9, #3, #4
        switch (flag) {
    ce0a:	f019 0207 	ands.w	r2, r9, #7
        dtype |= dtype << 4; /* replicate the lower 4 bits to get an 8b value */
    ce0e:	ea43 1103 	orr.w	r1, r3, r3, lsl #4
        switch (flag) {
    ce12:	d065      	beq.n	cee0 <core_bench_list+0x304>
    ce14:	2a01      	cmp	r2, #1
    ce16:	d161      	bne.n	cedc <core_bench_list+0x300>
                retval=core_bench_matrix(&(res->mat),dtype,res->crc);
    ce18:	f8bb 2038 	ldrh.w	r2, [fp, #56]	; 0x38
    ce1c:	9807      	ldr	r0, [sp, #28]
    ce1e:	f001 fdf9 	bl	ea14 <core_bench_matrix>
                if (res->crcmatrix==0)
    ce22:	f8bb 103c 	ldrh.w	r1, [fp, #60]	; 0x3c
                retval=core_bench_matrix(&(res->mat),dtype,res->crc);
    ce26:	b202      	sxth	r2, r0
                if (res->crcmatrix==0)
    ce28:	b909      	cbnz	r1, ce2e <core_bench_list+0x252>
                    res->crcmatrix=retval;
    ce2a:	f8ab 003c 	strh.w	r0, [fp, #60]	; 0x3c
        res->crc=crcu16(retval,res->crc);
    ce2e:	f8bb 1038 	ldrh.w	r1, [fp, #56]	; 0x38
    ce32:	9204      	str	r2, [sp, #16]
    ce34:	b290      	uxth	r0, r2
    ce36:	f002 fa25 	bl	f284 <crcu16>
        retval &= 0x007f;
    ce3a:	9904      	ldr	r1, [sp, #16]
        res->crc=crcu16(retval,res->crc);
    ce3c:	f8ab 0038 	strh.w	r0, [fp, #56]	; 0x38
        *pdata = (data & 0xff00) | 0x0080 | retval; /* cache the result */
    ce40:	f029 02ff 	bic.w	r2, r9, #255	; 0xff
    ce44:	f042 0380 	orr.w	r3, r2, #128	; 0x80
    ce48:	9803      	ldr	r0, [sp, #12]
        retval &= 0x007f;
    ce4a:	f001 027f 	and.w	r2, r1, #127	; 0x7f
        *pdata = (data & 0xff00) | 0x0080 | retval; /* cache the result */
    ce4e:	4313      	orrs	r3, r2
    ce50:	8003      	strh	r3, [r0, #0]
    return val1 - val2;
    ce52:	eba8 0302 	sub.w	r3, r8, r2
                } else if (cmp(p->info,q->info,res) <= 0) {
    ce56:	2b00      	cmp	r3, #0
    ce58:	dd13      	ble.n	ce82 <core_bench_list+0x2a6>
                    e = q; q = q->next; qsize--;
    ce5a:	4621      	mov	r1, r4
    ce5c:	6824      	ldr	r4, [r4, #0]
    ce5e:	3d01      	subs	r5, #1
                if (tail) {
    ce60:	b167      	cbz	r7, ce7c <core_bench_list+0x2a0>
                    tail->next = e;
    ce62:	6039      	str	r1, [r7, #0]
                    list = e;
    ce64:	460f      	mov	r7, r1
            while (psize > 0 || (qsize > 0 && q)) {
    ce66:	2e00      	cmp	r6, #0
    ce68:	d193      	bne.n	cd92 <core_bench_list+0x1b6>
    ce6a:	2d00      	cmp	r5, #0
    ce6c:	d053      	beq.n	cf16 <core_bench_list+0x33a>
    ce6e:	2c00      	cmp	r4, #0
    ce70:	d055      	beq.n	cf1e <core_bench_list+0x342>
                    e = q; q = q->next; qsize--;
    ce72:	4621      	mov	r1, r4
    ce74:	3d01      	subs	r5, #1
    ce76:	6824      	ldr	r4, [r4, #0]
                if (tail) {
    ce78:	2f00      	cmp	r7, #0
    ce7a:	d1f2      	bne.n	ce62 <core_bench_list+0x286>
                    list = e;
    ce7c:	9105      	str	r1, [sp, #20]
    ce7e:	460f      	mov	r7, r1
    ce80:	e7f1      	b.n	ce66 <core_bench_list+0x28a>
                    e = p; p = p->next; psize--;
    ce82:	4651      	mov	r1, sl
    ce84:	3e01      	subs	r6, #1
    ce86:	f8da a000 	ldr.w	sl, [sl]
    ce8a:	e7e9      	b.n	ce60 <core_bench_list+0x284>
    ee_s16 data=*pdata;
    ce8c:	f9b0 9000 	ldrsh.w	r9, [r0]
    if (optype) /* if cached, use cache */
    ce90:	f019 0f80 	tst.w	r9, #128	; 0x80
        return (data & 0x007f);
    ce94:	f008 087f 	and.w	r8, r8, #127	; 0x7f
    if (optype) /* if cached, use cache */
    ce98:	d0b5      	beq.n	ce06 <core_bench_list+0x22a>
        return (data & 0x007f);
    ce9a:	f009 027f 	and.w	r2, r9, #127	; 0x7f
    ce9e:	e7d8      	b.n	ce52 <core_bench_list+0x276>
        switch (flag) {
    cea0:	4642      	mov	r2, r8
    cea2:	e797      	b.n	cdd4 <core_bench_list+0x1f8>
                retval=core_bench_state(res->size,res->memblock[3],res->seed1,res->seed2,dtype,res->crc);
    cea4:	f8db e014 	ldr.w	lr, [fp, #20]
    cea8:	f8bb c038 	ldrh.w	ip, [fp, #56]	; 0x38
    ceac:	f9bb 2000 	ldrsh.w	r2, [fp]
    ceb0:	f9bb 3002 	ldrsh.w	r3, [fp, #2]
    ceb4:	f8db 0018 	ldr.w	r0, [fp, #24]
    ceb8:	f8cd c004 	str.w	ip, [sp, #4]
    cebc:	2922      	cmp	r1, #34	; 0x22
    cebe:	bfb8      	it	lt
    cec0:	2122      	movlt	r1, #34	; 0x22
    cec2:	9100      	str	r1, [sp, #0]
    cec4:	4671      	mov	r1, lr
    cec6:	f002 f93d 	bl	f144 <core_bench_state>
                if (res->crcstate==0)
    ceca:	f8bb 103e 	ldrh.w	r1, [fp, #62]	; 0x3e
                retval=core_bench_state(res->size,res->memblock[3],res->seed1,res->seed2,dtype,res->crc);
    cece:	b202      	sxth	r2, r0
                if (res->crcstate==0)
    ced0:	2900      	cmp	r1, #0
    ced2:	f47f af7f 	bne.w	cdd4 <core_bench_list+0x1f8>
                    res->crcstate=retval;
    ced6:	f8ab 003e 	strh.w	r0, [fp, #62]	; 0x3e
    ceda:	e77b      	b.n	cdd4 <core_bench_list+0x1f8>
        switch (flag) {
    cedc:	464a      	mov	r2, r9
    cede:	e7a6      	b.n	ce2e <core_bench_list+0x252>
                retval=core_bench_state(res->size,res->memblock[3],res->seed1,res->seed2,dtype,res->crc);
    cee0:	f8db e014 	ldr.w	lr, [fp, #20]
    cee4:	f8bb c038 	ldrh.w	ip, [fp, #56]	; 0x38
    cee8:	f9bb 3002 	ldrsh.w	r3, [fp, #2]
    ceec:	f9bb 2000 	ldrsh.w	r2, [fp]
    cef0:	f8db 0018 	ldr.w	r0, [fp, #24]
    cef4:	f8cd c004 	str.w	ip, [sp, #4]
    cef8:	2922      	cmp	r1, #34	; 0x22
    cefa:	bfb8      	it	lt
    cefc:	2122      	movlt	r1, #34	; 0x22
    cefe:	9100      	str	r1, [sp, #0]
    cf00:	4671      	mov	r1, lr
    cf02:	f002 f91f 	bl	f144 <core_bench_state>
                if (res->crcstate==0)
    cf06:	f8bb 303e 	ldrh.w	r3, [fp, #62]	; 0x3e
                retval=core_bench_state(res->size,res->memblock[3],res->seed1,res->seed2,dtype,res->crc);
    cf0a:	b202      	sxth	r2, r0
                if (res->crcstate==0)
    cf0c:	2b00      	cmp	r3, #0
    cf0e:	d18e      	bne.n	ce2e <core_bench_list+0x252>
                    res->crcstate=retval;
    cf10:	f8ab 003e 	strh.w	r0, [fp, #62]	; 0x3e
    cf14:	e78b      	b.n	ce2e <core_bench_list+0x252>
        while (p) {
    cf16:	46a2      	mov	sl, r4
    cf18:	2c00      	cmp	r4, #0
    cf1a:	f47f aed3 	bne.w	ccc4 <core_bench_list+0xe8>
        tail->next = NULL;
    cf1e:	2500      	movs	r5, #0
    cf20:	603d      	str	r5, [r7, #0]
        if (nmerges <= 1)   /* allow for nmerges==0, the empty list case */
    cf22:	9f08      	ldr	r7, [sp, #32]
    cf24:	2f01      	cmp	r7, #1
    cf26:	d173      	bne.n	d010 <core_bench_list+0x434>
    cf28:	f8dd b014 	ldr.w	fp, [sp, #20]
    remover=core_list_remove(list->next);
    cf2c:	f8db 6000 	ldr.w	r6, [fp]
    if (info->idx>=0) {
    cf30:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    list_head *ret=item->next;
    cf32:	6835      	ldr	r5, [r6, #0]
    tmp=item->info;
    cf34:	6872      	ldr	r2, [r6, #4]
    item->next=item->next->next;
    cf36:	e895 0003 	ldmia.w	r5, {r0, r1}
    ret->next=NULL;
    cf3a:	2400      	movs	r4, #0
    if (info->idx>=0) {
    cf3c:	42a7      	cmp	r7, r4
    item->info=ret->info;
    cf3e:	6071      	str	r1, [r6, #4]
    ret->info=tmp;
    cf40:	606a      	str	r2, [r5, #4]
    item->next=item->next->next;
    cf42:	6030      	str	r0, [r6, #0]
    ret->next=NULL;
    cf44:	602c      	str	r4, [r5, #0]
    if (info->idx>=0) {
    cf46:	db57      	blt.n	cff8 <core_bench_list+0x41c>
    cf48:	46be      	mov	lr, r7
    cf4a:	465c      	mov	r4, fp
        while (list && (list->info->idx != info->idx))
    cf4c:	6863      	ldr	r3, [r4, #4]
    cf4e:	f9b3 6002 	ldrsh.w	r6, [r3, #2]
    cf52:	4576      	cmp	r6, lr
    cf54:	d006      	beq.n	cf64 <core_bench_list+0x388>
            list=list->next;
    cf56:	6824      	ldr	r4, [r4, #0]
        while (list && (list->info->idx != info->idx))
    cf58:	2c00      	cmp	r4, #0
    cf5a:	d1f7      	bne.n	cf4c <core_bench_list+0x370>
        finder=list->next;
    cf5c:	f8db 7000 	ldr.w	r7, [fp]
    cf60:	463c      	mov	r4, r7
    while (finder) {
    cf62:	b177      	cbz	r7, cf82 <core_bench_list+0x3a6>
    cf64:	9909      	ldr	r1, [sp, #36]	; 0x24
        retval=crc16(list->info->data16,retval);
    cf66:	f8db 0004 	ldr.w	r0, [fp, #4]
    cf6a:	f9b0 0000 	ldrsh.w	r0, [r0]
    cf6e:	f002 fb51 	bl	f614 <crc16>
        finder=finder->next;
    cf72:	6824      	ldr	r4, [r4, #0]
        retval=crc16(list->info->data16,retval);
    cf74:	4601      	mov	r1, r0
    while (finder) {
    cf76:	2c00      	cmp	r4, #0
    cf78:	d1f5      	bne.n	cf66 <core_bench_list+0x38a>
    cf7a:	686a      	ldr	r2, [r5, #4]
    cf7c:	f8db 7000 	ldr.w	r7, [fp]
    cf80:	9009      	str	r0, [sp, #36]	; 0x24
    item_removed->info=item_modified->info;
    cf82:	687b      	ldr	r3, [r7, #4]
    item_removed->next=item_modified->next;
    cf84:	6839      	ldr	r1, [r7, #0]
    item_removed->info=item_modified->info;
    cf86:	606b      	str	r3, [r5, #4]
    list=core_list_mergesort(list,cmp_idx,NULL);
    cf88:	4658      	mov	r0, fp
    item_modified->info=tmp;
    cf8a:	607a      	str	r2, [r7, #4]
    item_removed->next=item_modified->next;
    cf8c:	6029      	str	r1, [r5, #0]
    item_modified->next=item_removed;
    cf8e:	603d      	str	r5, [r7, #0]
    list=core_list_mergesort(list,cmp_idx,NULL);
    cf90:	f7ff fd80 	bl	ca94 <core_list_mergesort.constprop.2>
    finder=list->next;
    cf94:	6805      	ldr	r5, [r0, #0]
    list=core_list_mergesort(list,cmp_idx,NULL);
    cf96:	4681      	mov	r9, r0
    while (finder) {
    cf98:	b15d      	cbz	r5, cfb2 <core_bench_list+0x3d6>
    cf9a:	9909      	ldr	r1, [sp, #36]	; 0x24
        retval=crc16(list->info->data16,retval);
    cf9c:	f8d9 6004 	ldr.w	r6, [r9, #4]
    cfa0:	f9b6 0000 	ldrsh.w	r0, [r6]
    cfa4:	f002 fb36 	bl	f614 <crc16>
        finder=finder->next;
    cfa8:	682d      	ldr	r5, [r5, #0]
        retval=crc16(list->info->data16,retval);
    cfaa:	4601      	mov	r1, r0
    while (finder) {
    cfac:	2d00      	cmp	r5, #0
    cfae:	d1f5      	bne.n	cf9c <core_bench_list+0x3c0>
    cfb0:	9009      	str	r0, [sp, #36]	; 0x24
}
    cfb2:	9809      	ldr	r0, [sp, #36]	; 0x24
    cfb4:	b00d      	add	sp, #52	; 0x34
    cfb6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        while (list && ((list->info->data16 & 0xff) != info->data16))
    cfba:	b173      	cbz	r3, cfda <core_bench_list+0x3fe>
    cfbc:	6859      	ldr	r1, [r3, #4]
    cfbe:	780e      	ldrb	r6, [r1, #0]
    cfc0:	45b4      	cmp	ip, r6
    cfc2:	461d      	mov	r5, r3
    cfc4:	d105      	bne.n	cfd2 <core_bench_list+0x3f6>
    cfc6:	e635      	b.n	cc34 <core_bench_list+0x58>
    cfc8:	6869      	ldr	r1, [r5, #4]
    cfca:	780e      	ldrb	r6, [r1, #0]
    cfcc:	4566      	cmp	r6, ip
    cfce:	f43f ae31 	beq.w	cc34 <core_bench_list+0x58>
            list=list->next;
    cfd2:	682d      	ldr	r5, [r5, #0]
        while (list && ((list->info->data16 & 0xff) != info->data16))
    cfd4:	2d00      	cmp	r5, #0
    cfd6:	d1f7      	bne.n	cfc8 <core_bench_list+0x3ec>
    cfd8:	e62c      	b.n	cc34 <core_bench_list+0x58>
    cfda:	f8de 6000 	ldr.w	r6, [lr]
    list_head *next=NULL, *tmp;
    cfde:	2300      	movs	r3, #0
            retval+=(list->next->info->data16 >> 8) & 1;
    cfe0:	6871      	ldr	r1, [r6, #4]
    cfe2:	f991 6001 	ldrsb.w	r6, [r1, #1]
    cfe6:	f006 0b01 	and.w	fp, r6, #1
    cfea:	445a      	add	r2, fp
            missed++;
    cfec:	f109 0501 	add.w	r5, r9, #1
            retval+=(list->next->info->data16 >> 8) & 1;
    cff0:	b292      	uxth	r2, r2
            missed++;
    cff2:	fa1f f985 	uxth.w	r9, r5
    cff6:	e63b      	b.n	cc70 <core_bench_list+0x94>
    if (info->idx>=0) {
    cff8:	465c      	mov	r4, fp
    cffa:	990b      	ldr	r1, [sp, #44]	; 0x2c
    cffc:	e002      	b.n	d004 <core_bench_list+0x428>
            list=list->next;
    cffe:	6824      	ldr	r4, [r4, #0]
        while (list && ((list->info->data16 & 0xff) != info->data16))
    d000:	2c00      	cmp	r4, #0
    d002:	d0ab      	beq.n	cf5c <core_bench_list+0x380>
    d004:	6860      	ldr	r0, [r4, #4]
    d006:	f890 8000 	ldrb.w	r8, [r0]
    d00a:	4588      	cmp	r8, r1
    d00c:	d1f7      	bne.n	cffe <core_bench_list+0x422>
    d00e:	e7a9      	b.n	cf64 <core_bench_list+0x388>
        insize *= 2;
    d010:	9906      	ldr	r1, [sp, #24]
    d012:	f8dd a014 	ldr.w	sl, [sp, #20]
    d016:	0048      	lsls	r0, r1, #1
    d018:	9006      	str	r0, [sp, #24]
    d01a:	4653      	mov	r3, sl
    d01c:	e64b      	b.n	ccb6 <core_bench_list+0xda>
    for (i=0; i<find_num; i++) {
    d01e:	2300      	movs	r3, #0
    info.idx=finder_idx;
    d020:	910a      	str	r1, [sp, #40]	; 0x28
    for (i=0; i<find_num; i++) {
    d022:	9309      	str	r3, [sp, #36]	; 0x24
    d024:	e638      	b.n	cc98 <core_bench_list+0xbc>
    d026:	4698      	mov	r8, r3
        tail->next = NULL;
    d028:	f8c8 3000 	str.w	r3, [r8]
    d02c:	deff      	udf	#255	; 0xff
    d02e:	bf00      	nop

0000d030 <core_list_init>:
    ee_u32 size=(blksize/per_item)-2; /* to accomodate systems with 64b pointers, and make sure same code is executed, set max list elements */
    d030:	4bb2      	ldr	r3, [pc, #712]	; (d2fc <core_list_init+0x2cc>)
list_head *core_list_init(ee_u32 blksize, list_head *memblock, ee_s16 seed) {
    d032:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ee_u32 size=(blksize/per_item)-2; /* to accomodate systems with 64b pointers, and make sure same code is executed, set max list elements */
    d036:	fba3 3000 	umull	r3, r0, r3, r0
    d03a:	ea4f 1e10 	mov.w	lr, r0, lsr #4
    d03e:	f1ae 0e02 	sub.w	lr, lr, #2
    list_head *memblock_end=memblock+size;
    d042:	eb01 07ce 	add.w	r7, r1, lr, lsl #3
    if ((*memblock+1) >= memblock_end)
    d046:	f101 0910 	add.w	r9, r1, #16
    list->info->data16=(ee_s16)0x8080;
    d04a:	f248 0480 	movw	r4, #32896	; 0x8080
    list->next=NULL;
    d04e:	2300      	movs	r3, #0
    if ((*memblock+1) >= memblock_end)
    d050:	454f      	cmp	r7, r9
    list->info=datablock;
    d052:	e881 0088 	stmia.w	r1, {r3, r7}
list_head *core_list_init(ee_u32 blksize, list_head *memblock, ee_s16 seed) {
    d056:	b083      	sub	sp, #12
    list->info->data16=(ee_s16)0x8080;
    d058:	f841 403e 	str.w	r4, [r1, lr, lsl #3]
    list_data *datablock_end=datablock+size;
    d05c:	eb07 088e 	add.w	r8, r7, lr, lsl #2
    datablock++;
    d060:	f107 0604 	add.w	r6, r7, #4
    memblock++;
    d064:	f101 0408 	add.w	r4, r1, #8
    if ((*memblock+1) >= memblock_end)
    d068:	d904      	bls.n	d074 <core_list_init+0x44>
    if ((*datablock+1) >= datablock_end)
    d06a:	f107 0508 	add.w	r5, r7, #8
    d06e:	45a8      	cmp	r8, r5
    d070:	f200 8139 	bhi.w	d2e6 <core_list_init+0x2b6>
    for (i=0; i<size; i++) {
    d074:	f1be 0f00 	cmp.w	lr, #0
    d078:	f000 80cb 	beq.w	d212 <core_list_init+0x1e2>
    d07c:	f10e 35ff 	add.w	r5, lr, #4294967295
    if ((*memblock+1) >= memblock_end)
    d080:	f104 0b08 	add.w	fp, r4, #8
    d084:	f005 0003 	and.w	r0, r5, #3
    d088:	455f      	cmp	r7, fp
    d08a:	b295      	uxth	r5, r2
    d08c:	9501      	str	r5, [sp, #4]
    to->idx=from->idx;
    d08e:	f647 79ff 	movw	r9, #32767	; 0x7fff
    if ((*memblock+1) >= memblock_end)
    d092:	f200 80df 	bhi.w	d254 <core_list_init+0x224>
    for (i=0; i<size; i++) {
    d096:	2501      	movs	r5, #1
    d098:	45ae      	cmp	lr, r5
    d09a:	f000 80ba 	beq.w	d212 <core_list_init+0x1e2>
    d09e:	b390      	cbz	r0, d106 <core_list_init+0xd6>
    d0a0:	42a8      	cmp	r0, r5
    d0a2:	d00d      	beq.n	d0c0 <core_list_init+0x90>
    d0a4:	2802      	cmp	r0, #2
    d0a6:	d005      	beq.n	d0b4 <core_list_init+0x84>
    if ((*memblock+1) >= memblock_end)
    d0a8:	f104 0c08 	add.w	ip, r4, #8
    d0ac:	4567      	cmp	r7, ip
    d0ae:	f200 8102 	bhi.w	d2b6 <core_list_init+0x286>
    for (i=0; i<size; i++) {
    d0b2:	3501      	adds	r5, #1
    if ((*memblock+1) >= memblock_end)
    d0b4:	f104 0c08 	add.w	ip, r4, #8
    d0b8:	4567      	cmp	r7, ip
    d0ba:	f200 80df 	bhi.w	d27c <core_list_init+0x24c>
    for (i=0; i<size; i++) {
    d0be:	3501      	adds	r5, #1
    if ((*memblock+1) >= memblock_end)
    d0c0:	f104 0c08 	add.w	ip, r4, #8
    d0c4:	4567      	cmp	r7, ip
    d0c6:	d91a      	bls.n	d0fe <core_list_init+0xce>
    if ((*datablock+1) >= datablock_end)
    d0c8:	f106 0a04 	add.w	sl, r6, #4
    d0cc:	45d0      	cmp	r8, sl
    d0ce:	d916      	bls.n	d0fe <core_list_init+0xce>
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    d0d0:	9801      	ldr	r0, [sp, #4]
    newitem->next=insert_point->next;
    d0d2:	6023      	str	r3, [r4, #0]
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    d0d4:	fa1f fb85 	uxth.w	fp, r5
    d0d8:	ea8b 0000 	eor.w	r0, fp, r0
        ee_u16 dat=(datpat<<3) | (i&0x7); /* alternate between algorithms */
    d0dc:	00c0      	lsls	r0, r0, #3
    d0de:	f000 0078 	and.w	r0, r0, #120	; 0x78
    d0e2:	f00b 0b07 	and.w	fp, fp, #7
    d0e6:	ea40 000b 	orr.w	r0, r0, fp
        info.data16=(dat<<8) | dat;     /* fill the data with actual data and upper bits with rebuild value */
    d0ea:	ea40 2000 	orr.w	r0, r0, r0, lsl #8
    insert_point->next=newitem;
    d0ee:	600c      	str	r4, [r1, #0]
    to->idx=from->idx;
    d0f0:	4623      	mov	r3, r4
    newitem->info=*datablock;
    d0f2:	6066      	str	r6, [r4, #4]
    to->idx=from->idx;
    d0f4:	f8a6 9002 	strh.w	r9, [r6, #2]
    to->data16=from->data16;
    d0f8:	8030      	strh	r0, [r6, #0]
    to->idx=from->idx;
    d0fa:	4664      	mov	r4, ip
    d0fc:	4656      	mov	r6, sl
    for (i=0; i<size; i++) {
    d0fe:	3501      	adds	r5, #1
    d100:	45ae      	cmp	lr, r5
    d102:	f000 8086 	beq.w	d212 <core_list_init+0x1e2>
    if ((*memblock+1) >= memblock_end)
    d106:	f104 0c08 	add.w	ip, r4, #8
    d10a:	4567      	cmp	r7, ip
    d10c:	d91a      	bls.n	d144 <core_list_init+0x114>
    if ((*datablock+1) >= datablock_end)
    d10e:	f106 0a04 	add.w	sl, r6, #4
    d112:	45d0      	cmp	r8, sl
    d114:	d916      	bls.n	d144 <core_list_init+0x114>
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    d116:	9801      	ldr	r0, [sp, #4]
    newitem->next=insert_point->next;
    d118:	6023      	str	r3, [r4, #0]
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    d11a:	fa1f fb85 	uxth.w	fp, r5
    d11e:	ea8b 0000 	eor.w	r0, fp, r0
        ee_u16 dat=(datpat<<3) | (i&0x7); /* alternate between algorithms */
    d122:	00c0      	lsls	r0, r0, #3
    d124:	f000 0078 	and.w	r0, r0, #120	; 0x78
    d128:	f00b 0b07 	and.w	fp, fp, #7
    d12c:	ea40 000b 	orr.w	r0, r0, fp
        info.data16=(dat<<8) | dat;     /* fill the data with actual data and upper bits with rebuild value */
    d130:	ea40 2000 	orr.w	r0, r0, r0, lsl #8
    insert_point->next=newitem;
    d134:	600c      	str	r4, [r1, #0]
    to->idx=from->idx;
    d136:	4623      	mov	r3, r4
    newitem->info=*datablock;
    d138:	6066      	str	r6, [r4, #4]
    to->idx=from->idx;
    d13a:	f8a6 9002 	strh.w	r9, [r6, #2]
    to->data16=from->data16;
    d13e:	8030      	strh	r0, [r6, #0]
    to->idx=from->idx;
    d140:	4664      	mov	r4, ip
    d142:	4656      	mov	r6, sl
    if ((*memblock+1) >= memblock_end)
    d144:	f104 0c08 	add.w	ip, r4, #8
    d148:	4567      	cmp	r7, ip
    for (i=0; i<size; i++) {
    d14a:	f105 0501 	add.w	r5, r5, #1
    if ((*memblock+1) >= memblock_end)
    d14e:	d91a      	bls.n	d186 <core_list_init+0x156>
    if ((*datablock+1) >= datablock_end)
    d150:	f106 0a04 	add.w	sl, r6, #4
    d154:	45d0      	cmp	r8, sl
    d156:	d916      	bls.n	d186 <core_list_init+0x156>
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    d158:	9801      	ldr	r0, [sp, #4]
    newitem->next=insert_point->next;
    d15a:	6023      	str	r3, [r4, #0]
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    d15c:	fa1f fb85 	uxth.w	fp, r5
    d160:	ea8b 0000 	eor.w	r0, fp, r0
        ee_u16 dat=(datpat<<3) | (i&0x7); /* alternate between algorithms */
    d164:	00c0      	lsls	r0, r0, #3
    d166:	f000 0078 	and.w	r0, r0, #120	; 0x78
    d16a:	f00b 0b07 	and.w	fp, fp, #7
    d16e:	ea40 000b 	orr.w	r0, r0, fp
        info.data16=(dat<<8) | dat;     /* fill the data with actual data and upper bits with rebuild value */
    d172:	ea40 2000 	orr.w	r0, r0, r0, lsl #8
    insert_point->next=newitem;
    d176:	600c      	str	r4, [r1, #0]
    to->idx=from->idx;
    d178:	4623      	mov	r3, r4
    newitem->info=*datablock;
    d17a:	6066      	str	r6, [r4, #4]
    to->idx=from->idx;
    d17c:	f8a6 9002 	strh.w	r9, [r6, #2]
    to->data16=from->data16;
    d180:	8030      	strh	r0, [r6, #0]
    to->idx=from->idx;
    d182:	4664      	mov	r4, ip
    d184:	4656      	mov	r6, sl
    if ((*memblock+1) >= memblock_end)
    d186:	f104 0a08 	add.w	sl, r4, #8
    d18a:	4557      	cmp	r7, sl
    for (i=0; i<size; i++) {
    d18c:	f105 0001 	add.w	r0, r5, #1
    if ((*memblock+1) >= memblock_end)
    d190:	d91a      	bls.n	d1c8 <core_list_init+0x198>
    if ((*datablock+1) >= datablock_end)
    d192:	f106 0b04 	add.w	fp, r6, #4
    d196:	45d8      	cmp	r8, fp
    d198:	d916      	bls.n	d1c8 <core_list_init+0x198>
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    d19a:	fa1f fc80 	uxth.w	ip, r0
    d19e:	9801      	ldr	r0, [sp, #4]
    newitem->next=insert_point->next;
    d1a0:	6023      	str	r3, [r4, #0]
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    d1a2:	ea8c 0000 	eor.w	r0, ip, r0
        ee_u16 dat=(datpat<<3) | (i&0x7); /* alternate between algorithms */
    d1a6:	00c0      	lsls	r0, r0, #3
    d1a8:	f000 0078 	and.w	r0, r0, #120	; 0x78
    d1ac:	f00c 0c07 	and.w	ip, ip, #7
    d1b0:	ea40 000c 	orr.w	r0, r0, ip
        info.data16=(dat<<8) | dat;     /* fill the data with actual data and upper bits with rebuild value */
    d1b4:	ea40 2000 	orr.w	r0, r0, r0, lsl #8
    insert_point->next=newitem;
    d1b8:	600c      	str	r4, [r1, #0]
    to->idx=from->idx;
    d1ba:	4623      	mov	r3, r4
    newitem->info=*datablock;
    d1bc:	6066      	str	r6, [r4, #4]
    to->idx=from->idx;
    d1be:	f8a6 9002 	strh.w	r9, [r6, #2]
    to->data16=from->data16;
    d1c2:	8030      	strh	r0, [r6, #0]
    to->idx=from->idx;
    d1c4:	4654      	mov	r4, sl
    d1c6:	465e      	mov	r6, fp
    if ((*memblock+1) >= memblock_end)
    d1c8:	f104 0a08 	add.w	sl, r4, #8
    d1cc:	4557      	cmp	r7, sl
    for (i=0; i<size; i++) {
    d1ce:	f105 0002 	add.w	r0, r5, #2
    if ((*memblock+1) >= memblock_end)
    d1d2:	d91a      	bls.n	d20a <core_list_init+0x1da>
    if ((*datablock+1) >= datablock_end)
    d1d4:	f106 0b04 	add.w	fp, r6, #4
    d1d8:	45d8      	cmp	r8, fp
    d1da:	d916      	bls.n	d20a <core_list_init+0x1da>
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    d1dc:	fa1f fc80 	uxth.w	ip, r0
    d1e0:	9801      	ldr	r0, [sp, #4]
    newitem->next=insert_point->next;
    d1e2:	6023      	str	r3, [r4, #0]
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    d1e4:	ea8c 0000 	eor.w	r0, ip, r0
        ee_u16 dat=(datpat<<3) | (i&0x7); /* alternate between algorithms */
    d1e8:	00c0      	lsls	r0, r0, #3
    d1ea:	f000 0078 	and.w	r0, r0, #120	; 0x78
    d1ee:	f00c 0c07 	and.w	ip, ip, #7
    d1f2:	ea40 000c 	orr.w	r0, r0, ip
        info.data16=(dat<<8) | dat;     /* fill the data with actual data and upper bits with rebuild value */
    d1f6:	ea40 2000 	orr.w	r0, r0, r0, lsl #8
    insert_point->next=newitem;
    d1fa:	600c      	str	r4, [r1, #0]
    to->idx=from->idx;
    d1fc:	4623      	mov	r3, r4
    newitem->info=*datablock;
    d1fe:	6066      	str	r6, [r4, #4]
    to->idx=from->idx;
    d200:	f8a6 9002 	strh.w	r9, [r6, #2]
    to->data16=from->data16;
    d204:	8030      	strh	r0, [r6, #0]
    to->idx=from->idx;
    d206:	4654      	mov	r4, sl
    d208:	465e      	mov	r6, fp
    for (i=0; i<size; i++) {
    d20a:	3503      	adds	r5, #3
    d20c:	45ae      	cmp	lr, r5
    d20e:	f47f af7a 	bne.w	d106 <core_list_init+0xd6>
        if (i<size/5) /* first 20% of the list in order */
    d212:	4f3a      	ldr	r7, [pc, #232]	; (d2fc <core_list_init+0x2cc>)
    d214:	fba7 050e 	umull	r0, r5, r7, lr
    d218:	ea4f 0e95 	mov.w	lr, r5, lsr #2
    while (finder->next!=NULL) {
    d21c:	2602      	movs	r6, #2
    d21e:	2501      	movs	r5, #1
    d220:	e00a      	b.n	d238 <core_list_init+0x208>
        if (i<size/5) /* first 20% of the list in order */
    d222:	4575      	cmp	r5, lr
            finder->info->idx=i++;
    d224:	685b      	ldr	r3, [r3, #4]
            finder->info->idx=0x3fff & (((i & 0x07) << 8) | pat); /* make sure the mixed items end up after the ones in sequence */
    d226:	bf25      	ittet	cs
    d228:	4338      	orrcs	r0, r7
    d22a:	f3c0 000d 	ubfxcs	r0, r0, #0, #14
            finder->info->idx=i++;
    d22e:	805d      	strhcc	r5, [r3, #2]
            finder->info->idx=0x3fff & (((i & 0x07) << 8) | pat); /* make sure the mixed items end up after the ones in sequence */
    d230:	8058      	strhcs	r0, [r3, #2]
    d232:	3601      	adds	r6, #1
    d234:	3501      	adds	r5, #1
    to->idx=from->idx;
    d236:	4623      	mov	r3, r4
    while (finder->next!=NULL) {
    d238:	681c      	ldr	r4, [r3, #0]
            finder->info->idx=0x3fff & (((i & 0x07) << 8) | pat); /* make sure the mixed items end up after the ones in sequence */
    d23a:	0230      	lsls	r0, r6, #8
            ee_u16 pat=(ee_u16)(i++ ^ seed); /* get a pseudo random number */
    d23c:	ea85 0702 	eor.w	r7, r5, r2
            finder->info->idx=0x3fff & (((i & 0x07) << 8) | pat); /* make sure the mixed items end up after the ones in sequence */
    d240:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
    while (finder->next!=NULL) {
    d244:	2c00      	cmp	r4, #0
    d246:	d1ec      	bne.n	d222 <core_list_init+0x1f2>
    list = core_list_mergesort(list,cmp_idx,NULL);
    d248:	4608      	mov	r0, r1
}
    d24a:	b003      	add	sp, #12
    d24c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    list = core_list_mergesort(list,cmp_idx,NULL);
    d250:	f7ff bc20 	b.w	ca94 <core_list_mergesort.constprop.2>
    if ((*datablock+1) >= datablock_end)
    d254:	f106 0a04 	add.w	sl, r6, #4
    d258:	45d0      	cmp	r8, sl
    d25a:	f67f af1c 	bls.w	d096 <core_list_init+0x66>
        ee_u16 dat=(datpat<<3) | (i&0x7); /* alternate between algorithms */
    d25e:	00ed      	lsls	r5, r5, #3
    d260:	f005 0578 	and.w	r5, r5, #120	; 0x78
        info.data16=(dat<<8) | dat;     /* fill the data with actual data and upper bits with rebuild value */
    d264:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    newitem->next=insert_point->next;
    d268:	6023      	str	r3, [r4, #0]
    insert_point->next=newitem;
    d26a:	600c      	str	r4, [r1, #0]
    to->idx=from->idx;
    d26c:	4623      	mov	r3, r4
    newitem->info=*datablock;
    d26e:	6066      	str	r6, [r4, #4]
    to->idx=from->idx;
    d270:	f8a6 9002 	strh.w	r9, [r6, #2]
    to->data16=from->data16;
    d274:	8035      	strh	r5, [r6, #0]
    to->idx=from->idx;
    d276:	465c      	mov	r4, fp
    d278:	4656      	mov	r6, sl
    d27a:	e70c      	b.n	d096 <core_list_init+0x66>
    if ((*datablock+1) >= datablock_end)
    d27c:	f106 0a04 	add.w	sl, r6, #4
    d280:	45d0      	cmp	r8, sl
    d282:	f67f af1c 	bls.w	d0be <core_list_init+0x8e>
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    d286:	9801      	ldr	r0, [sp, #4]
    newitem->next=insert_point->next;
    d288:	6023      	str	r3, [r4, #0]
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    d28a:	fa1f fb85 	uxth.w	fp, r5
    d28e:	ea8b 0000 	eor.w	r0, fp, r0
        ee_u16 dat=(datpat<<3) | (i&0x7); /* alternate between algorithms */
    d292:	00c0      	lsls	r0, r0, #3
    d294:	f000 0078 	and.w	r0, r0, #120	; 0x78
    d298:	f00b 0b07 	and.w	fp, fp, #7
    d29c:	ea40 000b 	orr.w	r0, r0, fp
        info.data16=(dat<<8) | dat;     /* fill the data with actual data and upper bits with rebuild value */
    d2a0:	ea40 2000 	orr.w	r0, r0, r0, lsl #8
    insert_point->next=newitem;
    d2a4:	600c      	str	r4, [r1, #0]
    to->idx=from->idx;
    d2a6:	4623      	mov	r3, r4
    newitem->info=*datablock;
    d2a8:	6066      	str	r6, [r4, #4]
    to->idx=from->idx;
    d2aa:	f8a6 9002 	strh.w	r9, [r6, #2]
    to->data16=from->data16;
    d2ae:	8030      	strh	r0, [r6, #0]
    to->idx=from->idx;
    d2b0:	4664      	mov	r4, ip
    d2b2:	4656      	mov	r6, sl
    d2b4:	e703      	b.n	d0be <core_list_init+0x8e>
    if ((*datablock+1) >= datablock_end)
    d2b6:	f106 0b04 	add.w	fp, r6, #4
    d2ba:	45d8      	cmp	r8, fp
    d2bc:	f67f aef9 	bls.w	d0b2 <core_list_init+0x82>
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    d2c0:	9801      	ldr	r0, [sp, #4]
    newitem->next=insert_point->next;
    d2c2:	6023      	str	r3, [r4, #0]
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    d2c4:	4068      	eors	r0, r5
        ee_u16 dat=(datpat<<3) | (i&0x7); /* alternate between algorithms */
    d2c6:	00c0      	lsls	r0, r0, #3
    d2c8:	f000 0078 	and.w	r0, r0, #120	; 0x78
    d2cc:	4328      	orrs	r0, r5
        info.data16=(dat<<8) | dat;     /* fill the data with actual data and upper bits with rebuild value */
    d2ce:	ea40 2a00 	orr.w	sl, r0, r0, lsl #8
    insert_point->next=newitem;
    d2d2:	600c      	str	r4, [r1, #0]
    to->idx=from->idx;
    d2d4:	4623      	mov	r3, r4
    newitem->info=*datablock;
    d2d6:	6066      	str	r6, [r4, #4]
    to->idx=from->idx;
    d2d8:	f8a6 9002 	strh.w	r9, [r6, #2]
    to->data16=from->data16;
    d2dc:	f8a6 a000 	strh.w	sl, [r6]
    to->idx=from->idx;
    d2e0:	4664      	mov	r4, ip
    d2e2:	465e      	mov	r6, fp
    d2e4:	e6e5      	b.n	d0b2 <core_list_init+0x82>
    to->data16=from->data16;
    d2e6:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
    newitem->next=insert_point->next;
    d2ea:	608b      	str	r3, [r1, #8]
    insert_point->next=newitem;
    d2ec:	600c      	str	r4, [r1, #0]
    newitem->info=*datablock;
    d2ee:	60ce      	str	r6, [r1, #12]
    to->data16=from->data16;
    d2f0:	4623      	mov	r3, r4
    d2f2:	462e      	mov	r6, r5
    d2f4:	464c      	mov	r4, r9
    d2f6:	6078      	str	r0, [r7, #4]
    d2f8:	e6bc      	b.n	d074 <core_list_init+0x44>
    d2fa:	bf00      	nop
    d2fc:	cccccccd 	.word	0xcccccccd

0000d300 <iterate>:
    NULL.
*/
static ee_u16 list_known_crc[]   =      {(ee_u16)0xd4b0,(ee_u16)0x3340,(ee_u16)0x6a79,(ee_u16)0xe714,(ee_u16)0xe3c1};
static ee_u16 matrix_known_crc[] =      {(ee_u16)0xbe52,(ee_u16)0x1199,(ee_u16)0x5608,(ee_u16)0x1fd7,(ee_u16)0x0747};
static ee_u16 state_known_crc[]  =      {(ee_u16)0x5e47,(ee_u16)0x39bf,(ee_u16)0xe5a4,(ee_u16)0x8e3a,(ee_u16)0x8d84};
void *iterate(void *pres) {
    d300:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ee_u32 i;
    ee_u16 crc;
    core_results *res=(core_results *)pres;
    ee_u32 iterations=res->iterations;
    d302:	69c7      	ldr	r7, [r0, #28]
    res->crc=0;
    d304:	2300      	movs	r3, #0
    d306:	6383      	str	r3, [r0, #56]	; 0x38
    d308:	63c3      	str	r3, [r0, #60]	; 0x3c
    res->crclist=0;
    res->crcmatrix=0;
    res->crcstate=0;

    for (i=0; i<iterations; i++) {
    d30a:	2f00      	cmp	r7, #0
    d30c:	d056      	beq.n	d3bc <iterate+0xbc>
    d30e:	4604      	mov	r4, r0
    d310:	1e7a      	subs	r2, r7, #1
        crc=core_bench_list(res,1);
    d312:	2101      	movs	r1, #1
    d314:	ea02 0601 	and.w	r6, r2, r1
    d318:	f7ff fc60 	bl	cbdc <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d31c:	8f21      	ldrh	r1, [r4, #56]	; 0x38
    d31e:	f001 ffb1 	bl	f284 <crcu16>
        crc=core_bench_list(res,-1);
    d322:	f04f 31ff 	mov.w	r1, #4294967295
        res->crc=crcu16(crc,res->crc);
    d326:	8720      	strh	r0, [r4, #56]	; 0x38
        crc=core_bench_list(res,-1);
    d328:	4620      	mov	r0, r4
    d32a:	f7ff fc57 	bl	cbdc <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d32e:	8f21      	ldrh	r1, [r4, #56]	; 0x38
    d330:	f001 ffa8 	bl	f284 <crcu16>
    for (i=0; i<iterations; i++) {
    d334:	2501      	movs	r5, #1
    d336:	42af      	cmp	r7, r5
        res->crc=crcu16(crc,res->crc);
    d338:	8720      	strh	r0, [r4, #56]	; 0x38
        if (i==0) res->crclist=res->crc;
    d33a:	8760      	strh	r0, [r4, #58]	; 0x3a
    for (i=0; i<iterations; i++) {
    d33c:	d03e      	beq.n	d3bc <iterate+0xbc>
    d33e:	b19e      	cbz	r6, d368 <iterate+0x68>
        crc=core_bench_list(res,1);
    d340:	4629      	mov	r1, r5
    d342:	4620      	mov	r0, r4
    d344:	f7ff fc4a 	bl	cbdc <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d348:	8f21      	ldrh	r1, [r4, #56]	; 0x38
    d34a:	f001 ff9b 	bl	f284 <crcu16>
        crc=core_bench_list(res,-1);
    d34e:	f04f 31ff 	mov.w	r1, #4294967295
        res->crc=crcu16(crc,res->crc);
    d352:	8720      	strh	r0, [r4, #56]	; 0x38
        crc=core_bench_list(res,-1);
    d354:	4620      	mov	r0, r4
    d356:	f7ff fc41 	bl	cbdc <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d35a:	8f21      	ldrh	r1, [r4, #56]	; 0x38
    d35c:	f001 ff92 	bl	f284 <crcu16>
    for (i=0; i<iterations; i++) {
    d360:	3501      	adds	r5, #1
    d362:	42af      	cmp	r7, r5
        res->crc=crcu16(crc,res->crc);
    d364:	8720      	strh	r0, [r4, #56]	; 0x38
    for (i=0; i<iterations; i++) {
    d366:	d029      	beq.n	d3bc <iterate+0xbc>
        crc=core_bench_list(res,1);
    d368:	2101      	movs	r1, #1
    d36a:	4620      	mov	r0, r4
    d36c:	f7ff fc36 	bl	cbdc <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d370:	8f21      	ldrh	r1, [r4, #56]	; 0x38
    d372:	f001 ff87 	bl	f284 <crcu16>
        crc=core_bench_list(res,-1);
    d376:	f04f 31ff 	mov.w	r1, #4294967295
        res->crc=crcu16(crc,res->crc);
    d37a:	8720      	strh	r0, [r4, #56]	; 0x38
        crc=core_bench_list(res,-1);
    d37c:	4620      	mov	r0, r4
    d37e:	f7ff fc2d 	bl	cbdc <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d382:	8f21      	ldrh	r1, [r4, #56]	; 0x38
    d384:	f001 ff7e 	bl	f284 <crcu16>
        crc=core_bench_list(res,1);
    d388:	2101      	movs	r1, #1
        res->crc=crcu16(crc,res->crc);
    d38a:	4684      	mov	ip, r0
    for (i=0; i<iterations; i++) {
    d38c:	186e      	adds	r6, r5, r1
        crc=core_bench_list(res,1);
    d38e:	4620      	mov	r0, r4
        res->crc=crcu16(crc,res->crc);
    d390:	f8a4 c038 	strh.w	ip, [r4, #56]	; 0x38
        if (i==0) res->crclist=res->crc;
    d394:	b1a5      	cbz	r5, d3c0 <iterate+0xc0>
        crc=core_bench_list(res,1);
    d396:	f7ff fc21 	bl	cbdc <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d39a:	8f21      	ldrh	r1, [r4, #56]	; 0x38
    d39c:	f001 ff72 	bl	f284 <crcu16>
        crc=core_bench_list(res,-1);
    d3a0:	f04f 31ff 	mov.w	r1, #4294967295
        res->crc=crcu16(crc,res->crc);
    d3a4:	8720      	strh	r0, [r4, #56]	; 0x38
        crc=core_bench_list(res,-1);
    d3a6:	4620      	mov	r0, r4
    d3a8:	f7ff fc18 	bl	cbdc <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d3ac:	8f21      	ldrh	r1, [r4, #56]	; 0x38
    d3ae:	f001 ff69 	bl	f284 <crcu16>
    d3b2:	8720      	strh	r0, [r4, #56]	; 0x38
        if (i==0) res->crclist=res->crc;
    d3b4:	b13e      	cbz	r6, d3c6 <iterate+0xc6>
    for (i=0; i<iterations; i++) {
    d3b6:	1c75      	adds	r5, r6, #1
    d3b8:	42af      	cmp	r7, r5
    d3ba:	d1d5      	bne.n	d368 <iterate+0x68>
    }
    return NULL;
}
    d3bc:	2000      	movs	r0, #0
    d3be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (i==0) res->crclist=res->crc;
    d3c0:	f8a4 c03a 	strh.w	ip, [r4, #58]	; 0x3a
    d3c4:	e7e7      	b.n	d396 <iterate+0x96>
    d3c6:	8760      	strh	r0, [r4, #58]	; 0x3a
    d3c8:	e7f5      	b.n	d3b6 <iterate+0xb6>
    d3ca:	bf00      	nop

0000d3cc <main>:
    4 - Iterations  : Special, if set to 0, iterations will be automatically determined such that the benchmark will run between 10 to 100 secs

*/

#if MAIN_HAS_NOARGC
MAIN_RETURN_TYPE main(void) {
    d3cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d3d0:	f6ad 0d44 	subw	sp, sp, #2116	; 0x844
    int argc=0;
    d3d4:	2300      	movs	r3, #0
    core_results results[MULTITHREAD];
#if (MEM_METHOD==MEM_STACK)
    ee_u8 stack_memblock[TOTAL_DATA_SIZE*MULTITHREAD];
#endif
    /* first call any initializations needed */
    portable_init(&(results[0].port), &argc, argv);
    d3d6:	a909      	add	r1, sp, #36	; 0x24
    d3d8:	aa0a      	add	r2, sp, #40	; 0x28
    d3da:	f10d 006e 	add.w	r0, sp, #110	; 0x6e
    int argc=0;
    d3de:	9309      	str	r3, [sp, #36]	; 0x24
    portable_init(&(results[0].port), &argc, argv);
    d3e0:	f001 fc9a 	bl	ed18 <portable_init>
    /* First some checks to make sure benchmark will run ok */
    if (sizeof(struct list_head_s)>128) {
        ee_printf("list_head structure too big for comparable data!\n");
        return MAIN_RETURN_VAL;
    }
    results[0].seed1=get_seed(1);
    d3e4:	2001      	movs	r0, #1
    d3e6:	f001 ff29 	bl	f23c <get_seed_32>
    d3ea:	f8ad 002c 	strh.w	r0, [sp, #44]	; 0x2c
    results[0].seed2=get_seed(2);
    d3ee:	2002      	movs	r0, #2
    d3f0:	f001 ff24 	bl	f23c <get_seed_32>
    d3f4:	f8ad 002e 	strh.w	r0, [sp, #46]	; 0x2e
    results[0].seed3=get_seed(3);
    d3f8:	2003      	movs	r0, #3
    d3fa:	f001 ff1f 	bl	f23c <get_seed_32>
    d3fe:	f8ad 0030 	strh.w	r0, [sp, #48]	; 0x30
    results[0].iterations=get_seed_32(4);
    d402:	2004      	movs	r0, #4
    d404:	f001 ff1a 	bl	f23c <get_seed_32>
    d408:	9012      	str	r0, [sp, #72]	; 0x48
#if CORE_DEBUG
    results[0].iterations=1;
#endif
    results[0].execs=get_seed_32(5);
    d40a:	2005      	movs	r0, #5
    d40c:	f001 ff16 	bl	f23c <get_seed_32>
    if (results[0].execs==0) { /* if not supplied, execute all algorithms */
    d410:	2800      	cmp	r0, #0
    d412:	f000 814a 	beq.w	d6aa <main+0x2de>
    results[0].execs=get_seed_32(5);
    d416:	9013      	str	r0, [sp, #76]	; 0x4c
        results[0].execs=ALL_ALGORITHMS_MASK;
    }
        /* put in some default values based on one seed only for easy testing */
    if ((results[0].seed1==0) && (results[0].seed2==0) && (results[0].seed3==0)) { /* validation run */
    d418:	990b      	ldr	r1, [sp, #44]	; 0x2c
    d41a:	2900      	cmp	r1, #0
    d41c:	f040 81c3 	bne.w	d7a6 <main+0x3da>
    d420:	f9bd 4030 	ldrsh.w	r4, [sp, #48]	; 0x30
    d424:	2c00      	cmp	r4, #0
    d426:	f000 81c8 	beq.w	d7ba <main+0x3ee>
        results[i].size=TOTAL_DATA_SIZE;
        results[i].seed1=results[0].seed1;
        results[i].seed2=results[0].seed2;
        results[i].seed3=results[0].seed3;
        results[i].err=0;
        results[i].execs=results[0].execs;
    d42a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
        results[i].seed1=results[0].seed1;
    d42c:	f9bd 202c 	ldrsh.w	r2, [sp, #44]	; 0x2c
        results[i].memblock[0]=stack_memblock+i*TOTAL_DATA_SIZE;
    d430:	a91c      	add	r1, sp, #112	; 0x70
        results[i].err=0;
    d432:	2500      	movs	r5, #0
    d434:	f3c3 0640 	ubfx	r6, r3, #1, #1
    d438:	f003 0701 	and.w	r7, r3, #1
        results[i].memblock[0]=stack_memblock+i*TOTAL_DATA_SIZE;
    d43c:	910d      	str	r1, [sp, #52]	; 0x34
    for (i=0 ; i<MULTITHREAD; i++)
        results[i].size=results[i].size/num_algorithms;
    /* Assign pointers */
    for (i=0; i<NUM_ALGORITHMS; i++) {
        ee_u32 ctx;
        if ((1<<(ee_u32)i) & results[0].execs) {
    d43e:	f013 0101 	ands.w	r1, r3, #1
        results[i].err=0;
    d442:	f8ad 506c 	strh.w	r5, [sp, #108]	; 0x6c
        results[i].size=results[i].size/num_algorithms;
    d446:	443e      	add	r6, r7
            for (ctx=0 ; ctx<MULTITHREAD; ctx++)
                results[ctx].memblock[i+1]=(char *)(results[ctx].memblock[0])+results[0].size*j;
    d448:	bf18      	it	ne
    d44a:	ad1c      	addne	r5, sp, #112	; 0x70
        results[i].size=results[i].size/num_algorithms;
    d44c:	f3c3 0880 	ubfx	r8, r3, #2, #1
    d450:	f003 0402 	and.w	r4, r3, #2
    d454:	4446      	add	r6, r8
    d456:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
                results[ctx].memblock[i+1]=(char *)(results[ctx].memblock[0])+results[0].size*j;
    d45a:	bf18      	it	ne
    d45c:	950e      	strne	r5, [sp, #56]	; 0x38
        results[i].size=results[i].size/num_algorithms;
    d45e:	fbb0 f0f6 	udiv	r0, r0, r6
            j++;
    d462:	bf18      	it	ne
    d464:	2501      	movne	r5, #1
        results[i].size=results[i].size/num_algorithms;
    d466:	f003 0604 	and.w	r6, r3, #4
    d46a:	9011      	str	r0, [sp, #68]	; 0x44
        if ((1<<(ee_u32)i) & results[0].execs) {
    d46c:	bf08      	it	eq
    d46e:	460d      	moveq	r5, r1
    d470:	b134      	cbz	r4, d480 <main+0xb4>
                results[ctx].memblock[i+1]=(char *)(results[ctx].memblock[0])+results[0].size*j;
    d472:	f10d 0970 	add.w	r9, sp, #112	; 0x70
    d476:	fb00 9705 	mla	r7, r0, r5, r9
            j++;
    d47a:	3501      	adds	r5, #1
                results[ctx].memblock[i+1]=(char *)(results[ctx].memblock[0])+results[0].size*j;
    d47c:	970f      	str	r7, [sp, #60]	; 0x3c
            j++;
    d47e:	b2ad      	uxth	r5, r5
        if ((1<<(ee_u32)i) & results[0].execs) {
    d480:	b126      	cbz	r6, d48c <main+0xc0>
                results[ctx].memblock[i+1]=(char *)(results[ctx].memblock[0])+results[0].size*j;
    d482:	f10d 0a70 	add.w	sl, sp, #112	; 0x70
    d486:	fb00 a605 	mla	r6, r0, r5, sl
    d48a:	9610      	str	r6, [sp, #64]	; 0x40
        }
    }
    /* call inits */
    for (i=0 ; i<MULTITHREAD; i++) {
        if (results[i].execs & ID_LIST) {
    d48c:	2900      	cmp	r1, #0
    d48e:	f040 80ec 	bne.w	d66a <main+0x29e>
            results[i].list=core_list_init(results[0].size,results[i].memblock[1],results[i].seed1);
        }
        if (results[i].execs & ID_MATRIX) {
    d492:	2c00      	cmp	r4, #0
    d494:	f040 80f3 	bne.w	d67e <main+0x2b2>
            core_init_matrix(results[0].size, results[i].memblock[2], (ee_s32)results[i].seed1 | (((ee_s32)results[i].seed2) << 16), &(results[i].mat) );
        }
        if (results[i].execs & ID_STATE) {
    d498:	075a      	lsls	r2, r3, #29
    d49a:	f100 80ff 	bmi.w	d69c <main+0x2d0>
            core_init_state(results[0].size,results[i].seed1,results[i].memblock[3]);
        }
    }

    /* automatically determine number of iterations if not set */
    if (results[0].iterations==0) {
    d49e:	9812      	ldr	r0, [sp, #72]	; 0x48
    d4a0:	2800      	cmp	r0, #0
    d4a2:	f040 809f 	bne.w	d5e4 <main+0x218>
        secs_ret secs_passed=0;
        ee_u32 divisor;
        results[0].iterations=1;
    d4a6:	2201      	movs	r2, #1
        while (secs_passed < (secs_ret)1) {
    d4a8:	4fc8      	ldr	r7, [pc, #800]	; (d7cc <main+0x400>)
        results[0].iterations=1;
    d4aa:	9212      	str	r2, [sp, #72]	; 0x48
        while (secs_passed < (secs_ret)1) {
    d4ac:	f04f 0a00 	mov.w	sl, #0
    res->crc=0;
    d4b0:	4681      	mov	r9, r0
            results[0].iterations*=10;
    d4b2:	9912      	ldr	r1, [sp, #72]	; 0x48
    d4b4:	eb01 0581 	add.w	r5, r1, r1, lsl #2
    d4b8:	006e      	lsls	r6, r5, #1
    d4ba:	9612      	str	r6, [sp, #72]	; 0x48
            start_time();
    d4bc:	f001 fbdc 	bl	ec78 <start_time>
    ee_u32 iterations=res->iterations;
    d4c0:	f8dd 8048 	ldr.w	r8, [sp, #72]	; 0x48
    res->crc=0;
    d4c4:	f8cd 9064 	str.w	r9, [sp, #100]	; 0x64
    d4c8:	f8cd 9068 	str.w	r9, [sp, #104]	; 0x68
    for (i=0; i<iterations; i++) {
    d4cc:	f1b8 0f00 	cmp.w	r8, #0
    d4d0:	d06b      	beq.n	d5aa <main+0x1de>
        crc=core_bench_list(res,1);
    d4d2:	2101      	movs	r1, #1
    d4d4:	f108 34ff 	add.w	r4, r8, #4294967295
    d4d8:	a80b      	add	r0, sp, #44	; 0x2c
    d4da:	ea04 0501 	and.w	r5, r4, r1
    d4de:	f7ff fb7d 	bl	cbdc <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d4e2:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
    d4e6:	f001 fecd 	bl	f284 <crcu16>
        crc=core_bench_list(res,-1);
    d4ea:	f04f 31ff 	mov.w	r1, #4294967295
        res->crc=crcu16(crc,res->crc);
    d4ee:	f8ad 0064 	strh.w	r0, [sp, #100]	; 0x64
        crc=core_bench_list(res,-1);
    d4f2:	a80b      	add	r0, sp, #44	; 0x2c
    d4f4:	f7ff fb72 	bl	cbdc <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d4f8:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
    d4fc:	f001 fec2 	bl	f284 <crcu16>
    for (i=0; i<iterations; i++) {
    d500:	2401      	movs	r4, #1
    d502:	45a0      	cmp	r8, r4
        res->crc=crcu16(crc,res->crc);
    d504:	f8ad 0064 	strh.w	r0, [sp, #100]	; 0x64
        if (i==0) res->crclist=res->crc;
    d508:	f8ad 0066 	strh.w	r0, [sp, #102]	; 0x66
    for (i=0; i<iterations; i++) {
    d50c:	d04d      	beq.n	d5aa <main+0x1de>
    d50e:	b1bd      	cbz	r5, d540 <main+0x174>
        crc=core_bench_list(res,1);
    d510:	4621      	mov	r1, r4
    d512:	a80b      	add	r0, sp, #44	; 0x2c
    d514:	f7ff fb62 	bl	cbdc <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d518:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
    d51c:	f001 feb2 	bl	f284 <crcu16>
        crc=core_bench_list(res,-1);
    d520:	f04f 31ff 	mov.w	r1, #4294967295
        res->crc=crcu16(crc,res->crc);
    d524:	f8ad 0064 	strh.w	r0, [sp, #100]	; 0x64
        crc=core_bench_list(res,-1);
    d528:	a80b      	add	r0, sp, #44	; 0x2c
    d52a:	f7ff fb57 	bl	cbdc <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d52e:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
    d532:	f001 fea7 	bl	f284 <crcu16>
    for (i=0; i<iterations; i++) {
    d536:	3401      	adds	r4, #1
    d538:	45a0      	cmp	r8, r4
        res->crc=crcu16(crc,res->crc);
    d53a:	f8ad 0064 	strh.w	r0, [sp, #100]	; 0x64
    for (i=0; i<iterations; i++) {
    d53e:	d034      	beq.n	d5aa <main+0x1de>
        crc=core_bench_list(res,1);
    d540:	2101      	movs	r1, #1
    d542:	a80b      	add	r0, sp, #44	; 0x2c
    d544:	f7ff fb4a 	bl	cbdc <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d548:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
    d54c:	f001 fe9a 	bl	f284 <crcu16>
        crc=core_bench_list(res,-1);
    d550:	f04f 31ff 	mov.w	r1, #4294967295
        res->crc=crcu16(crc,res->crc);
    d554:	f8ad 0064 	strh.w	r0, [sp, #100]	; 0x64
        crc=core_bench_list(res,-1);
    d558:	a80b      	add	r0, sp, #44	; 0x2c
    d55a:	f7ff fb3f 	bl	cbdc <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d55e:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
    d562:	f001 fe8f 	bl	f284 <crcu16>
        crc=core_bench_list(res,1);
    d566:	2101      	movs	r1, #1
        res->crc=crcu16(crc,res->crc);
    d568:	4683      	mov	fp, r0
    for (i=0; i<iterations; i++) {
    d56a:	1866      	adds	r6, r4, r1
        crc=core_bench_list(res,1);
    d56c:	a80b      	add	r0, sp, #44	; 0x2c
        res->crc=crcu16(crc,res->crc);
    d56e:	f8ad b064 	strh.w	fp, [sp, #100]	; 0x64
        if (i==0) res->crclist=res->crc;
    d572:	2c00      	cmp	r4, #0
    d574:	f000 8295 	beq.w	daa2 <main+0x6d6>
        crc=core_bench_list(res,1);
    d578:	f7ff fb30 	bl	cbdc <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d57c:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
    d580:	f001 fe80 	bl	f284 <crcu16>
        crc=core_bench_list(res,-1);
    d584:	f04f 31ff 	mov.w	r1, #4294967295
        res->crc=crcu16(crc,res->crc);
    d588:	f8ad 0064 	strh.w	r0, [sp, #100]	; 0x64
        crc=core_bench_list(res,-1);
    d58c:	a80b      	add	r0, sp, #44	; 0x2c
    d58e:	f7ff fb25 	bl	cbdc <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d592:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
    d596:	f001 fe75 	bl	f284 <crcu16>
    d59a:	f8ad 0064 	strh.w	r0, [sp, #100]	; 0x64
        if (i==0) res->crclist=res->crc;
    d59e:	2e00      	cmp	r6, #0
    d5a0:	f000 8282 	beq.w	daa8 <main+0x6dc>
    for (i=0; i<iterations; i++) {
    d5a4:	1c74      	adds	r4, r6, #1
    d5a6:	45a0      	cmp	r8, r4
    d5a8:	d1ca      	bne.n	d540 <main+0x174>
            iterate(&results[0]);
            stop_time();
    d5aa:	f001 fb7b 	bl	eca4 <stop_time>
            secs_passed=time_in_secs(get_time());
    d5ae:	f001 fb97 	bl	ece0 <get_time>
    d5b2:	f001 fba1 	bl	ecf8 <time_in_secs>
        while (secs_passed < (secs_ret)1) {
    d5b6:	4652      	mov	r2, sl
    d5b8:	463b      	mov	r3, r7
            secs_passed=time_in_secs(get_time());
    d5ba:	4680      	mov	r8, r0
    d5bc:	460d      	mov	r5, r1
        while (secs_passed < (secs_ret)1) {
    d5be:	f7ff f9c9 	bl	c954 <__aeabi_dcmplt>
    d5c2:	2800      	cmp	r0, #0
    d5c4:	f47f af75 	bne.w	d4b2 <main+0xe6>
        }
        /* now we know it executes for at least 1 sec, set actual run time at about 10 secs */
        divisor=(ee_u32)secs_passed;
    d5c8:	4640      	mov	r0, r8
    d5ca:	4629      	mov	r1, r5
    d5cc:	f7ff f9ea 	bl	c9a4 <__aeabi_d2uiz>
        if (divisor==0) /* some machines cast float to int as 0 since this conversion is not defined by ANSI, but we know at least one second passed */
            divisor=1;
        results[0].iterations*=1+10/divisor;
    d5d0:	9b12      	ldr	r3, [sp, #72]	; 0x48
            divisor=1;
    d5d2:	2800      	cmp	r0, #0
    d5d4:	bf08      	it	eq
    d5d6:	2001      	moveq	r0, #1
        results[0].iterations*=1+10/divisor;
    d5d8:	270a      	movs	r7, #10
    d5da:	fbb7 f0f0 	udiv	r0, r7, r0
    d5de:	fb00 3203 	mla	r2, r0, r3, r3
    d5e2:	9212      	str	r2, [sp, #72]	; 0x48
    }
    /* perform actual benchmark */
    start_time();
    d5e4:	f001 fb48 	bl	ec78 <start_time>
    }
    for (i=0 ; i<default_num_contexts; i++) {
        core_stop_parallel(&results[i]);
    }
#else
    iterate(&results[0]);
    d5e8:	a80b      	add	r0, sp, #44	; 0x2c
    d5ea:	f7ff fe89 	bl	d300 <iterate>
#endif
    stop_time();
    d5ee:	f001 fb59 	bl	eca4 <stop_time>
    total_time=get_time();
    d5f2:	f001 fb75 	bl	ece0 <get_time>
    /* get a function of the input to report */
    seedcrc=crc16(results[0].seed1,seedcrc);
    d5f6:	2100      	movs	r1, #0
    total_time=get_time();
    d5f8:	4681      	mov	r9, r0
    seedcrc=crc16(results[0].seed1,seedcrc);
    d5fa:	f9bd 002c 	ldrsh.w	r0, [sp, #44]	; 0x2c
    d5fe:	f002 f809 	bl	f614 <crc16>
    seedcrc=crc16(results[0].seed2,seedcrc);
    d602:	4601      	mov	r1, r0
    d604:	f9bd 002e 	ldrsh.w	r0, [sp, #46]	; 0x2e
    d608:	f002 f804 	bl	f614 <crc16>
    seedcrc=crc16(results[0].seed3,seedcrc);
    d60c:	4601      	mov	r1, r0
    d60e:	f9bd 0030 	ldrsh.w	r0, [sp, #48]	; 0x30
    d612:	f001 ffff 	bl	f614 <crc16>
    seedcrc=crc16(results[0].size,seedcrc);
    d616:	4601      	mov	r1, r0
    d618:	f9bd 0044 	ldrsh.w	r0, [sp, #68]	; 0x44
    d61c:	f001 fffa 	bl	f614 <crc16>

    switch (seedcrc) { /* test known output for common seeds */
    d620:	f647 3605 	movw	r6, #31493	; 0x7b05
    d624:	42b0      	cmp	r0, r6
    seedcrc=crc16(results[0].size,seedcrc);
    d626:	9005      	str	r0, [sp, #20]
    switch (seedcrc) { /* test known output for common seeds */
    d628:	f000 8223 	beq.w	da72 <main+0x6a6>
    d62c:	d840      	bhi.n	d6b0 <main+0x2e4>
    d62e:	f641 04f2 	movw	r4, #6386	; 0x18f2
    d632:	42a0      	cmp	r0, r4
    d634:	f000 8209 	beq.w	da4a <main+0x67e>
    d638:	f644 65af 	movw	r5, #20143	; 0x4eaf
    d63c:	42a8      	cmp	r0, r5
    d63e:	f040 80d3 	bne.w	d7e8 <main+0x41c>
            ee_printf("6k validation run parameters for coremark.\n");
            break;
        case 0x4eaf: /* seed1=0x8, seed2=0x8, seed3=0x8, size 400 per algorithm */
            known_id=2;
            ee_printf("Profile generation run parameters for coremark.\n");
            break;
    d642:	f24e 54a4 	movw	r4, #58788	; 0xe5a4
    d646:	f245 6508 	movw	r5, #22024	; 0x5608
    d64a:	f646 2679 	movw	r6, #27257	; 0x6a79
            ee_printf("Profile generation run parameters for coremark.\n");
    d64e:	4860      	ldr	r0, [pc, #384]	; (d7d0 <main+0x404>)
            break;
    d650:	9404      	str	r4, [sp, #16]
    d652:	4627      	mov	r7, r4
    d654:	9503      	str	r5, [sp, #12]
    d656:	462c      	mov	r4, r5
    d658:	9602      	str	r6, [sp, #8]
            ee_printf("Profile generation run parameters for coremark.\n");
    d65a:	f001 fbd3 	bl	ee04 <am_sprintf>
            known_id=2;
    d65e:	2302      	movs	r3, #2
            break;
    d660:	46bb      	mov	fp, r7
    d662:	46a2      	mov	sl, r4
    d664:	4630      	mov	r0, r6
            known_id=2;
    d666:	9307      	str	r3, [sp, #28]
            break;
    d668:	e040      	b.n	d6ec <main+0x320>
            results[i].list=core_list_init(results[0].size,results[i].memblock[1],results[i].seed1);
    d66a:	990e      	ldr	r1, [sp, #56]	; 0x38
    d66c:	f7ff fce0 	bl	d030 <core_list_init>
    d670:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    d672:	9014      	str	r0, [sp, #80]	; 0x50
    d674:	f003 0402 	and.w	r4, r3, #2
        if (results[i].execs & ID_MATRIX) {
    d678:	2c00      	cmp	r4, #0
    d67a:	f43f af0d 	beq.w	d498 <main+0xcc>
            core_init_matrix(results[0].size, results[i].memblock[2], (ee_s32)results[i].seed1 | (((ee_s32)results[i].seed2) << 16), &(results[i].mat) );
    d67e:	f9bd b02e 	ldrsh.w	fp, [sp, #46]	; 0x2e
    d682:	f9bd c02c 	ldrsh.w	ip, [sp, #44]	; 0x2c
    d686:	990f      	ldr	r1, [sp, #60]	; 0x3c
    d688:	9811      	ldr	r0, [sp, #68]	; 0x44
    d68a:	ea4c 420b 	orr.w	r2, ip, fp, lsl #16
    d68e:	ab15      	add	r3, sp, #84	; 0x54
    d690:	f001 f9ce 	bl	ea30 <core_init_matrix>
    d694:	9b13      	ldr	r3, [sp, #76]	; 0x4c
        if (results[i].execs & ID_STATE) {
    d696:	075a      	lsls	r2, r3, #29
    d698:	f57f af01 	bpl.w	d49e <main+0xd2>
            core_init_state(results[0].size,results[i].seed1,results[i].memblock[3]);
    d69c:	9a10      	ldr	r2, [sp, #64]	; 0x40
    d69e:	f9bd 102c 	ldrsh.w	r1, [sp, #44]	; 0x2c
    d6a2:	9811      	ldr	r0, [sp, #68]	; 0x44
    d6a4:	f001 fbf0 	bl	ee88 <core_init_state>
    d6a8:	e6f9      	b.n	d49e <main+0xd2>
        results[0].execs=ALL_ALGORITHMS_MASK;
    d6aa:	2007      	movs	r0, #7
    d6ac:	9013      	str	r0, [sp, #76]	; 0x4c
    d6ae:	e6b3      	b.n	d418 <main+0x4c>
    switch (seedcrc) { /* test known output for common seeds */
    d6b0:	9a05      	ldr	r2, [sp, #20]
    d6b2:	f648 2e02 	movw	lr, #35330	; 0x8a02
    d6b6:	4572      	cmp	r2, lr
    d6b8:	f000 81b3 	beq.w	da22 <main+0x656>
    d6bc:	f64e 1cf5 	movw	ip, #59893	; 0xe9f5
    d6c0:	4562      	cmp	r2, ip
    d6c2:	f040 8091 	bne.w	d7e8 <main+0x41c>
        case 0xe9f5: /* seed1=0, seed2=0, seed3=0x66, size 666 per algorithm */
            known_id=3;
            ee_printf("2K performance run parameters for coremark.\n");
            break;
    d6c6:	f648 643a 	movw	r4, #36410	; 0x8e3a
    d6ca:	f641 75d7 	movw	r5, #8151	; 0x1fd7
    d6ce:	f24e 7614 	movw	r6, #59156	; 0xe714
            ee_printf("2K performance run parameters for coremark.\n");
    d6d2:	4840      	ldr	r0, [pc, #256]	; (d7d4 <main+0x408>)
            break;
    d6d4:	9404      	str	r4, [sp, #16]
    d6d6:	4627      	mov	r7, r4
    d6d8:	9503      	str	r5, [sp, #12]
    d6da:	462c      	mov	r4, r5
    d6dc:	9602      	str	r6, [sp, #8]
            ee_printf("2K performance run parameters for coremark.\n");
    d6de:	f001 fb91 	bl	ee04 <am_sprintf>
            known_id=3;
    d6e2:	2303      	movs	r3, #3
            break;
    d6e4:	46bb      	mov	fp, r7
    d6e6:	46a2      	mov	sl, r4
    d6e8:	4630      	mov	r0, r6
            known_id=3;
    d6ea:	9307      	str	r3, [sp, #28]
        default:
            total_errors=-1;
            break;
    }
    if (known_id>=0) {
        for (i=0 ; i<default_num_contexts; i++) {
    d6ec:	f8df 80f4 	ldr.w	r8, [pc, #244]	; d7e4 <main+0x418>
    d6f0:	f8d8 6000 	ldr.w	r6, [r8]
    d6f4:	2e00      	cmp	r6, #0
    d6f6:	d07c      	beq.n	d7f2 <main+0x426>
    d6f8:	2600      	movs	r6, #0
    d6fa:	f8cd 9018 	str.w	r9, [sp, #24]
    d6fe:	4634      	mov	r4, r6
    d700:	4681      	mov	r9, r0
    d702:	e016      	b.n	d732 <main+0x366>
                (results[i].crcmatrix!=matrix_known_crc[known_id])) {
                ee_printf("[%u]ERROR! matrix crc 0x%04x - should be 0x%04x\n",i,results[i].crcmatrix,matrix_known_crc[known_id]);
                results[i].err++;
            }
            if ((results[i].execs & ID_STATE) &&
                (results[i].crcstate!=state_known_crc[known_id])) {
    d704:	8fea      	ldrh	r2, [r5, #62]	; 0x3e
            if ((results[i].execs & ID_STATE) &&
    d706:	455a      	cmp	r2, fp
    d708:	d04a      	beq.n	d7a0 <main+0x3d4>
                ee_printf("[%u]ERROR! state crc 0x%04x - should be 0x%04x\n",i,results[i].crcstate,state_known_crc[known_id]);
    d70a:	9b04      	ldr	r3, [sp, #16]
    d70c:	4832      	ldr	r0, [pc, #200]	; (d7d8 <main+0x40c>)
    d70e:	4621      	mov	r1, r4
    d710:	f001 fb78 	bl	ee04 <am_sprintf>
                results[i].err++;
    d714:	f8b5 2040 	ldrh.w	r2, [r5, #64]	; 0x40
    d718:	3201      	adds	r2, #1
    d71a:	b210      	sxth	r0, r2
    d71c:	f8a5 0040 	strh.w	r0, [r5, #64]	; 0x40
        for (i=0 ; i<default_num_contexts; i++) {
    d720:	3401      	adds	r4, #1
    d722:	f8d8 7000 	ldr.w	r7, [r8]
    d726:	b2a4      	uxth	r4, r4
            }
            total_errors+=results[i].err;
    d728:	4406      	add	r6, r0
        for (i=0 ; i<default_num_contexts; i++) {
    d72a:	42bc      	cmp	r4, r7
            total_errors+=results[i].err;
    d72c:	b236      	sxth	r6, r6
        for (i=0 ; i<default_num_contexts; i++) {
    d72e:	f080 8146 	bcs.w	d9be <main+0x5f2>
            results[i].err=0;
    d732:	0125      	lsls	r5, r4, #4
    d734:	1928      	adds	r0, r5, r4
    d736:	f10d 0e2c 	add.w	lr, sp, #44	; 0x2c
    d73a:	eb0e 0780 	add.w	r7, lr, r0, lsl #2
    d73e:	2100      	movs	r1, #0
            if ((results[i].execs & ID_LIST) &&
    d740:	6a3a      	ldr	r2, [r7, #32]
            results[i].err=0;
    d742:	f8a7 1040 	strh.w	r1, [r7, #64]	; 0x40
            if ((results[i].execs & ID_LIST) &&
    d746:	07d3      	lsls	r3, r2, #31
    d748:	d50c      	bpl.n	d764 <main+0x398>
                (results[i].crclist!=list_known_crc[known_id])) {
    d74a:	8f7a      	ldrh	r2, [r7, #58]	; 0x3a
            if ((results[i].execs & ID_LIST) &&
    d74c:	454a      	cmp	r2, r9
    d74e:	d009      	beq.n	d764 <main+0x398>
                ee_printf("[%u]ERROR! list crc 0x%04x - should be 0x%04x\n",i,results[i].crclist,list_known_crc[known_id]);
    d750:	9b02      	ldr	r3, [sp, #8]
    d752:	4822      	ldr	r0, [pc, #136]	; (d7dc <main+0x410>)
    d754:	4621      	mov	r1, r4
    d756:	f001 fb55 	bl	ee04 <am_sprintf>
                results[i].err++;
    d75a:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
    d75e:	3301      	adds	r3, #1
    d760:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
            if ((results[i].execs & ID_MATRIX) &&
    d764:	1928      	adds	r0, r5, r4
    d766:	f10d 0c2c 	add.w	ip, sp, #44	; 0x2c
    d76a:	eb0c 0780 	add.w	r7, ip, r0, lsl #2
    d76e:	6a3b      	ldr	r3, [r7, #32]
    d770:	0798      	lsls	r0, r3, #30
    d772:	d50d      	bpl.n	d790 <main+0x3c4>
                (results[i].crcmatrix!=matrix_known_crc[known_id])) {
    d774:	8fba      	ldrh	r2, [r7, #60]	; 0x3c
            if ((results[i].execs & ID_MATRIX) &&
    d776:	4552      	cmp	r2, sl
    d778:	d00a      	beq.n	d790 <main+0x3c4>
                ee_printf("[%u]ERROR! matrix crc 0x%04x - should be 0x%04x\n",i,results[i].crcmatrix,matrix_known_crc[known_id]);
    d77a:	9b03      	ldr	r3, [sp, #12]
    d77c:	4818      	ldr	r0, [pc, #96]	; (d7e0 <main+0x414>)
    d77e:	4621      	mov	r1, r4
    d780:	f001 fb40 	bl	ee04 <am_sprintf>
                results[i].err++;
    d784:	f8b7 1040 	ldrh.w	r1, [r7, #64]	; 0x40
    d788:	6a3b      	ldr	r3, [r7, #32]
    d78a:	3101      	adds	r1, #1
    d78c:	f8a7 1040 	strh.w	r1, [r7, #64]	; 0x40
                (results[i].crcstate!=state_known_crc[known_id])) {
    d790:	4425      	add	r5, r4
    d792:	f10d 0e2c 	add.w	lr, sp, #44	; 0x2c
            if ((results[i].execs & ID_STATE) &&
    d796:	f013 0f04 	tst.w	r3, #4
                (results[i].crcstate!=state_known_crc[known_id])) {
    d79a:	eb0e 0585 	add.w	r5, lr, r5, lsl #2
            if ((results[i].execs & ID_STATE) &&
    d79e:	d1b1      	bne.n	d704 <main+0x338>
    d7a0:	f9b5 0040 	ldrsh.w	r0, [r5, #64]	; 0x40
    d7a4:	e7bc      	b.n	d720 <main+0x354>
    if ((results[0].seed1==1) && (results[0].seed2==0) && (results[0].seed3==0)) { /* perfromance run */
    d7a6:	2901      	cmp	r1, #1
    d7a8:	f47f ae3f 	bne.w	d42a <main+0x5e>
    d7ac:	f9bd 2030 	ldrsh.w	r2, [sp, #48]	; 0x30
    d7b0:	2a00      	cmp	r2, #0
    d7b2:	f47f ae3a 	bne.w	d42a <main+0x5e>
        results[0].seed1=0x3415;
    d7b6:	f243 4415 	movw	r4, #13333	; 0x3415
        results[0].seed3=0x66;
    d7ba:	2566      	movs	r5, #102	; 0x66
        results[0].seed1=0x3415;
    d7bc:	f8ad 402c 	strh.w	r4, [sp, #44]	; 0x2c
        results[0].seed2=0x3415;
    d7c0:	f8ad 402e 	strh.w	r4, [sp, #46]	; 0x2e
        results[0].seed3=0x66;
    d7c4:	f8ad 5030 	strh.w	r5, [sp, #48]	; 0x30
    d7c8:	e62f      	b.n	d42a <main+0x5e>
    d7ca:	bf00      	nop
    d7cc:	3ff00000 	.word	0x3ff00000
    d7d0:	00012a54 	.word	0x00012a54
    d7d4:	00012a88 	.word	0x00012a88
    d7d8:	00012b48 	.word	0x00012b48
    d7dc:	00012ae4 	.word	0x00012ae4
    d7e0:	00012b14 	.word	0x00012b14
    d7e4:	10001000 	.word	0x10001000
    ee_s16 known_id=-1,total_errors=0;
    d7e8:	f04f 36ff 	mov.w	r6, #4294967295
    d7ec:	f8df 8330 	ldr.w	r8, [pc, #816]	; db20 <main+0x754>
    d7f0:	9607      	str	r6, [sp, #28]
        }
    }
    total_errors+=check_data_types();
    d7f2:	f001 ffa9 	bl	f748 <check_data_types>
    /* and report results */
    ee_printf("CoreMark Size    : %lu\n",(ee_u32)results[0].size);
    d7f6:	9911      	ldr	r1, [sp, #68]	; 0x44
    total_errors+=check_data_types();
    d7f8:	4406      	add	r6, r0
    ee_printf("CoreMark Size    : %lu\n",(ee_u32)results[0].size);
    d7fa:	48ad      	ldr	r0, [pc, #692]	; (dab0 <main+0x6e4>)
    d7fc:	f001 fb02 	bl	ee04 <am_sprintf>
    ee_printf("Total ticks      : %llu\n",(ee_u64)total_time);
    d800:	464a      	mov	r2, r9
    d802:	2300      	movs	r3, #0
    d804:	48ab      	ldr	r0, [pc, #684]	; (dab4 <main+0x6e8>)
    d806:	f001 fafd 	bl	ee04 <am_sprintf>
#if HAS_FLOAT
    ee_printf("Total time (secs): %f\n",time_in_secs(total_time));
    d80a:	4648      	mov	r0, r9
    d80c:	f001 fa74 	bl	ecf8 <time_in_secs>
    d810:	4602      	mov	r2, r0
    d812:	460b      	mov	r3, r1
    d814:	48a8      	ldr	r0, [pc, #672]	; (dab8 <main+0x6ec>)
    d816:	f001 faf5 	bl	ee04 <am_sprintf>
    if (time_in_secs(total_time) > 0)
    d81a:	4648      	mov	r0, r9
    d81c:	f001 fa6c 	bl	ecf8 <time_in_secs>
    d820:	2200      	movs	r2, #0
    d822:	2300      	movs	r3, #0
    total_errors+=check_data_types();
    d824:	b2b6      	uxth	r6, r6
    if (time_in_secs(total_time) > 0)
    d826:	f7ff f8b3 	bl	c990 <__aeabi_dcmpgt>
    d82a:	b1b0      	cbz	r0, d85a <main+0x48e>
        ee_printf("Iterations/Sec   : %f\n",default_num_contexts*results[0].iterations/time_in_secs(total_time));
    d82c:	9912      	ldr	r1, [sp, #72]	; 0x48
    d82e:	f8d8 0000 	ldr.w	r0, [r8]
    d832:	fb00 f001 	mul.w	r0, r0, r1
    d836:	f7fe fda5 	bl	c384 <__aeabi_ui2d>
    d83a:	4683      	mov	fp, r0
    d83c:	4648      	mov	r0, r9
    d83e:	468a      	mov	sl, r1
    d840:	f001 fa5a 	bl	ecf8 <time_in_secs>
    d844:	4602      	mov	r2, r0
    d846:	460b      	mov	r3, r1
    d848:	4658      	mov	r0, fp
    d84a:	4651      	mov	r1, sl
    d84c:	f7fe ff3a 	bl	c6c4 <__aeabi_ddiv>
    d850:	4602      	mov	r2, r0
    d852:	460b      	mov	r3, r1
    d854:	4899      	ldr	r0, [pc, #612]	; (dabc <main+0x6f0>)
    d856:	f001 fad5 	bl	ee04 <am_sprintf>
#else
    ee_printf("Total time (secs): %d\n",time_in_secs(total_time));
    if (time_in_secs(total_time) > 0)
        ee_printf("Iterations/Sec   : %d\n",default_num_contexts*results[0].iterations/time_in_secs(total_time));
#endif
    if (time_in_secs(total_time) < 10) {
    d85a:	4648      	mov	r0, r9
    d85c:	f001 fa4c 	bl	ecf8 <time_in_secs>
    d860:	2200      	movs	r2, #0
    d862:	4b97      	ldr	r3, [pc, #604]	; (dac0 <main+0x6f4>)
    d864:	f7ff f876 	bl	c954 <__aeabi_dcmplt>
    d868:	2800      	cmp	r0, #0
    d86a:	f040 80ab 	bne.w	d9c4 <main+0x5f8>
    total_errors+=check_data_types();
    d86e:	b235      	sxth	r5, r6
        ee_printf("ERROR! Must execute for at least 10 secs for a valid result!\n");
        total_errors++;
    }

    ee_printf("Iterations       : %lu\n",(ee_u32)default_num_contexts*results[0].iterations);
    d870:	9a12      	ldr	r2, [sp, #72]	; 0x48
    d872:	f8d8 1000 	ldr.w	r1, [r8]
    d876:	4893      	ldr	r0, [pc, #588]	; (dac4 <main+0x6f8>)
    d878:	fb01 f102 	mul.w	r1, r1, r2
    d87c:	f001 fac2 	bl	ee04 <am_sprintf>
    ee_printf("Compiler version : %s\n",COMPILER_VERSION);
    d880:	4991      	ldr	r1, [pc, #580]	; (dac8 <main+0x6fc>)
    d882:	4892      	ldr	r0, [pc, #584]	; (dacc <main+0x700>)
    d884:	f001 fabe 	bl	ee04 <am_sprintf>
//  ee_printf("Compiler flags   : %s\n",COMPILER_FLAGS);
#if (MULTITHREAD>1)
    ee_printf("Parallel %s : %d\n",PARALLEL_METHOD,default_num_contexts);
#endif
    ee_printf("Memory location  : %s\n",MEM_LOCATION);
    d888:	4991      	ldr	r1, [pc, #580]	; (dad0 <main+0x704>)
    d88a:	4892      	ldr	r0, [pc, #584]	; (dad4 <main+0x708>)
    d88c:	f001 faba 	bl	ee04 <am_sprintf>
    /* output for verification */
    ee_printf("seedcrc          : 0x%04x\n",seedcrc);
    d890:	9905      	ldr	r1, [sp, #20]
    d892:	4891      	ldr	r0, [pc, #580]	; (dad8 <main+0x70c>)
    d894:	f001 fab6 	bl	ee04 <am_sprintf>
    if (results[0].execs & ID_LIST)
    d898:	9f13      	ldr	r7, [sp, #76]	; 0x4c
    d89a:	07f9      	lsls	r1, r7, #31
    d89c:	d516      	bpl.n	d8cc <main+0x500>
        for (i=0 ; i<default_num_contexts; i++)
    d89e:	f8d8 4000 	ldr.w	r4, [r8]
    d8a2:	b19c      	cbz	r4, d8cc <main+0x500>
            ee_printf("[%d]crclist       : 0x%04x\n",i,results[i].crclist);
    d8a4:	4e8d      	ldr	r6, [pc, #564]	; (dadc <main+0x710>)
        for (i=0 ; i<default_num_contexts; i++)
    d8a6:	2700      	movs	r7, #0
            ee_printf("[%d]crclist       : 0x%04x\n",i,results[i].crclist);
    d8a8:	eb07 1007 	add.w	r0, r7, r7, lsl #4
    d8ac:	f10d 0c2c 	add.w	ip, sp, #44	; 0x2c
    d8b0:	eb0c 0e80 	add.w	lr, ip, r0, lsl #2
    d8b4:	4639      	mov	r1, r7
    d8b6:	f8be 203a 	ldrh.w	r2, [lr, #58]	; 0x3a
    d8ba:	4630      	mov	r0, r6
    d8bc:	f001 faa2 	bl	ee04 <am_sprintf>
        for (i=0 ; i<default_num_contexts; i++)
    d8c0:	3701      	adds	r7, #1
    d8c2:	f8d8 1000 	ldr.w	r1, [r8]
    d8c6:	b2bf      	uxth	r7, r7
    d8c8:	428f      	cmp	r7, r1
    d8ca:	d3ed      	bcc.n	d8a8 <main+0x4dc>
    if (results[0].execs & ID_MATRIX)
    d8cc:	9f13      	ldr	r7, [sp, #76]	; 0x4c
    d8ce:	07ba      	lsls	r2, r7, #30
    d8d0:	d518      	bpl.n	d904 <main+0x538>
        for (i=0 ; i<default_num_contexts; i++)
    d8d2:	f8d8 2000 	ldr.w	r2, [r8]
    d8d6:	2a00      	cmp	r2, #0
    d8d8:	f000 80df 	beq.w	da9a <main+0x6ce>
            ee_printf("[%d]crcmatrix     : 0x%04x\n",i,results[i].crcmatrix);
    d8dc:	4e80      	ldr	r6, [pc, #512]	; (dae0 <main+0x714>)
        for (i=0 ; i<default_num_contexts; i++)
    d8de:	2400      	movs	r4, #0
            ee_printf("[%d]crcmatrix     : 0x%04x\n",i,results[i].crcmatrix);
    d8e0:	eb04 1b04 	add.w	fp, r4, r4, lsl #4
    d8e4:	f10d 0a2c 	add.w	sl, sp, #44	; 0x2c
    d8e8:	eb0a 038b 	add.w	r3, sl, fp, lsl #2
    d8ec:	4621      	mov	r1, r4
    d8ee:	8f9a      	ldrh	r2, [r3, #60]	; 0x3c
    d8f0:	4630      	mov	r0, r6
    d8f2:	f001 fa87 	bl	ee04 <am_sprintf>
        for (i=0 ; i<default_num_contexts; i++)
    d8f6:	3401      	adds	r4, #1
    d8f8:	f8d8 1000 	ldr.w	r1, [r8]
    d8fc:	b2a4      	uxth	r4, r4
    d8fe:	428c      	cmp	r4, r1
    d900:	d3ee      	bcc.n	d8e0 <main+0x514>
    d902:	9f13      	ldr	r7, [sp, #76]	; 0x4c
    if (results[0].execs & ID_STATE)
        for (i=0 ; i<default_num_contexts; i++)
    d904:	f8d8 2000 	ldr.w	r2, [r8]
    if (results[0].execs & ID_STATE)
    d908:	f017 0f04 	tst.w	r7, #4
    d90c:	d014      	beq.n	d938 <main+0x56c>
        for (i=0 ; i<default_num_contexts; i++)
    d90e:	b33a      	cbz	r2, d960 <main+0x594>
            ee_printf("[%d]crcstate      : 0x%04x\n",i,results[i].crcstate);
    d910:	4e74      	ldr	r6, [pc, #464]	; (dae4 <main+0x718>)
        for (i=0 ; i<default_num_contexts; i++)
    d912:	2400      	movs	r4, #0
            ee_printf("[%d]crcstate      : 0x%04x\n",i,results[i].crcstate);
    d914:	eb04 1004 	add.w	r0, r4, r4, lsl #4
    d918:	f10d 0c2c 	add.w	ip, sp, #44	; 0x2c
    d91c:	eb0c 0e80 	add.w	lr, ip, r0, lsl #2
    d920:	4621      	mov	r1, r4
    d922:	f8be 203e 	ldrh.w	r2, [lr, #62]	; 0x3e
    d926:	4630      	mov	r0, r6
    d928:	f001 fa6c 	bl	ee04 <am_sprintf>
        for (i=0 ; i<default_num_contexts; i++)
    d92c:	3401      	adds	r4, #1
    d92e:	f8d8 2000 	ldr.w	r2, [r8]
    d932:	b2a4      	uxth	r4, r4
    d934:	4294      	cmp	r4, r2
    d936:	d3ed      	bcc.n	d914 <main+0x548>
    for (i=0 ; i<default_num_contexts; i++)
    d938:	b192      	cbz	r2, d960 <main+0x594>
        ee_printf("[%d]crcfinal      : 0x%04x\n",i,results[i].crc);
    d93a:	4f6b      	ldr	r7, [pc, #428]	; (dae8 <main+0x71c>)
    for (i=0 ; i<default_num_contexts; i++)
    d93c:	2600      	movs	r6, #0
        ee_printf("[%d]crcfinal      : 0x%04x\n",i,results[i].crc);
    d93e:	eb06 1b06 	add.w	fp, r6, r6, lsl #4
    d942:	aa0b      	add	r2, sp, #44	; 0x2c
    d944:	eb02 0a8b 	add.w	sl, r2, fp, lsl #2
    d948:	4631      	mov	r1, r6
    d94a:	f8ba 2038 	ldrh.w	r2, [sl, #56]	; 0x38
    d94e:	4638      	mov	r0, r7
    d950:	f001 fa58 	bl	ee04 <am_sprintf>
    for (i=0 ; i<default_num_contexts; i++)
    d954:	3601      	adds	r6, #1
    d956:	f8d8 3000 	ldr.w	r3, [r8]
    d95a:	b2b6      	uxth	r6, r6
    d95c:	429e      	cmp	r6, r3
    d95e:	d3ee      	bcc.n	d93e <main+0x572>
    if (total_errors==0) {
    d960:	2d00      	cmp	r5, #0
    d962:	d035      	beq.n	d9d0 <main+0x604>
            ee_printf("\n");
        }
#endif
    }
    if (total_errors>0)
        ee_printf("Errors detected\n");
    d964:	bfcc      	ite	gt
    d966:	4861      	ldrgt	r0, [pc, #388]	; (daec <main+0x720>)
    if (total_errors<0)
        ee_printf("Cannot validate operation for these seed values, please compare with results on a known platform.\n");
    d968:	4861      	ldrle	r0, [pc, #388]	; (daf0 <main+0x724>)
    d96a:	f001 fa4b 	bl	ee04 <am_sprintf>
        portable_free(results[i].memblock[0]);
#endif


#if AM_PRINT_RESULTS
    float CMResult = default_num_contexts*results[0].iterations/time_in_secs(total_time) / (double)AM_CORECLK_MHZ;
    d96e:	9b12      	ldr	r3, [sp, #72]	; 0x48
    d970:	f8d8 0000 	ldr.w	r0, [r8]
    d974:	fb00 f003 	mul.w	r0, r0, r3
    d978:	f7fe fd04 	bl	c384 <__aeabi_ui2d>
    d97c:	4680      	mov	r8, r0
    d97e:	4648      	mov	r0, r9
    d980:	468b      	mov	fp, r1
    d982:	f001 f9b9 	bl	ecf8 <time_in_secs>
    d986:	4602      	mov	r2, r0
    d988:	460b      	mov	r3, r1
    d98a:	4640      	mov	r0, r8
    d98c:	4659      	mov	r1, fp
    d98e:	f7fe fe99 	bl	c6c4 <__aeabi_ddiv>
    d992:	2200      	movs	r2, #0
    d994:	4b57      	ldr	r3, [pc, #348]	; (daf4 <main+0x728>)
    d996:	f7fe fe95 	bl	c6c4 <__aeabi_ddiv>
    d99a:	f7ff f823 	bl	c9e4 <__aeabi_d2f>
    ee_printf("CM/MHz=%.3f.\n", CMResult);
    d99e:	f7fe fd13 	bl	c3c8 <__aeabi_f2d>
    d9a2:	4602      	mov	r2, r0
    d9a4:	460b      	mov	r3, r1
    d9a6:	4854      	ldr	r0, [pc, #336]	; (daf8 <main+0x72c>)
    d9a8:	f001 fa2c 	bl	ee04 <am_sprintf>

#endif //AM_PRINT_RESULTS

    /* And last call any target specific code for finalizing */
    portable_fini(&(results[0].port));
    d9ac:	f10d 006e 	add.w	r0, sp, #110	; 0x6e
    d9b0:	f001 f9f2 	bl	ed98 <portable_fini>

    return MAIN_RETURN_VAL;
}
    d9b4:	2000      	movs	r0, #0
    d9b6:	f60d 0d44 	addw	sp, sp, #2116	; 0x844
    d9ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d9be:	f8dd 9018 	ldr.w	r9, [sp, #24]
    d9c2:	e716      	b.n	d7f2 <main+0x426>
        ee_printf("ERROR! Must execute for at least 10 secs for a valid result!\n");
    d9c4:	484d      	ldr	r0, [pc, #308]	; (dafc <main+0x730>)
    d9c6:	f001 fa1d 	bl	ee04 <am_sprintf>
        total_errors++;
    d9ca:	1c73      	adds	r3, r6, #1
    d9cc:	b21d      	sxth	r5, r3
    d9ce:	e74f      	b.n	d870 <main+0x4a4>
        ee_printf("Correct operation validated. See readme.txt for run and reporting rules.\n");
    d9d0:	484b      	ldr	r0, [pc, #300]	; (db00 <main+0x734>)
    d9d2:	f001 fa17 	bl	ee04 <am_sprintf>
        if (known_id==3) {
    d9d6:	9d07      	ldr	r5, [sp, #28]
    d9d8:	2d03      	cmp	r5, #3
    d9da:	d1c8      	bne.n	d96e <main+0x5a2>
            ee_printf("CoreMark 1.0 : %f / %s %s",default_num_contexts*results[0].iterations/time_in_secs(total_time),COMPILER_VERSION,COMPILER_FLAGS);
    d9dc:	9912      	ldr	r1, [sp, #72]	; 0x48
    d9de:	f8d8 0000 	ldr.w	r0, [r8]
    d9e2:	4e39      	ldr	r6, [pc, #228]	; (dac8 <main+0x6fc>)
    d9e4:	fb00 f001 	mul.w	r0, r0, r1
    d9e8:	f7fe fccc 	bl	c384 <__aeabi_ui2d>
    d9ec:	4604      	mov	r4, r0
    d9ee:	4648      	mov	r0, r9
    d9f0:	460f      	mov	r7, r1
    d9f2:	f001 f981 	bl	ecf8 <time_in_secs>
    d9f6:	4602      	mov	r2, r0
    d9f8:	460b      	mov	r3, r1
    d9fa:	4620      	mov	r0, r4
    d9fc:	4639      	mov	r1, r7
    d9fe:	f7fe fe61 	bl	c6c4 <__aeabi_ddiv>
    da02:	4a40      	ldr	r2, [pc, #256]	; (db04 <main+0x738>)
    da04:	9201      	str	r2, [sp, #4]
    da06:	460b      	mov	r3, r1
    da08:	4602      	mov	r2, r0
    da0a:	9600      	str	r6, [sp, #0]
    da0c:	483e      	ldr	r0, [pc, #248]	; (db08 <main+0x73c>)
    da0e:	f001 f9f9 	bl	ee04 <am_sprintf>
            ee_printf(" / %s",MEM_LOCATION);
    da12:	492f      	ldr	r1, [pc, #188]	; (dad0 <main+0x704>)
    da14:	483d      	ldr	r0, [pc, #244]	; (db0c <main+0x740>)
    da16:	f001 f9f5 	bl	ee04 <am_sprintf>
            ee_printf("\n");
    da1a:	483d      	ldr	r0, [pc, #244]	; (db10 <main+0x744>)
    da1c:	f001 f9f2 	bl	ee04 <am_sprintf>
    da20:	e7a5      	b.n	d96e <main+0x5a2>
            break;
    da22:	f645 6447 	movw	r4, #24135	; 0x5e47
    da26:	f64b 6552 	movw	r5, #48722	; 0xbe52
    da2a:	f24d 46b0 	movw	r6, #54448	; 0xd4b0
            ee_printf("6k performance run parameters for coremark.\n");
    da2e:	4839      	ldr	r0, [pc, #228]	; (db14 <main+0x748>)
            break;
    da30:	9404      	str	r4, [sp, #16]
    da32:	4627      	mov	r7, r4
    da34:	9503      	str	r5, [sp, #12]
    da36:	462c      	mov	r4, r5
    da38:	9602      	str	r6, [sp, #8]
            ee_printf("6k performance run parameters for coremark.\n");
    da3a:	f001 f9e3 	bl	ee04 <am_sprintf>
            known_id=0;
    da3e:	2100      	movs	r1, #0
            break;
    da40:	46bb      	mov	fp, r7
    da42:	46a2      	mov	sl, r4
    da44:	4630      	mov	r0, r6
            known_id=0;
    da46:	9107      	str	r1, [sp, #28]
            break;
    da48:	e650      	b.n	d6ec <main+0x320>
            break;
    da4a:	f648 5484 	movw	r4, #36228	; 0x8d84
    da4e:	f240 7547 	movw	r5, #1863	; 0x747
    da52:	f24e 36c1 	movw	r6, #58305	; 0xe3c1
            ee_printf("2K validation run parameters for coremark.\n");
    da56:	4830      	ldr	r0, [pc, #192]	; (db18 <main+0x74c>)
            break;
    da58:	9404      	str	r4, [sp, #16]
    da5a:	4627      	mov	r7, r4
    da5c:	9503      	str	r5, [sp, #12]
    da5e:	462c      	mov	r4, r5
    da60:	9602      	str	r6, [sp, #8]
            ee_printf("2K validation run parameters for coremark.\n");
    da62:	f001 f9cf 	bl	ee04 <am_sprintf>
            known_id=4;
    da66:	2104      	movs	r1, #4
            break;
    da68:	46bb      	mov	fp, r7
    da6a:	46a2      	mov	sl, r4
    da6c:	4630      	mov	r0, r6
            known_id=4;
    da6e:	9107      	str	r1, [sp, #28]
            break;
    da70:	e63c      	b.n	d6ec <main+0x320>
            break;
    da72:	f643 14bf 	movw	r4, #14783	; 0x39bf
    da76:	f241 1599 	movw	r5, #4505	; 0x1199
    da7a:	f44f 564d 	mov.w	r6, #13120	; 0x3340
            ee_printf("6k validation run parameters for coremark.\n");
    da7e:	4827      	ldr	r0, [pc, #156]	; (db1c <main+0x750>)
            break;
    da80:	9404      	str	r4, [sp, #16]
    da82:	4627      	mov	r7, r4
    da84:	9503      	str	r5, [sp, #12]
    da86:	462c      	mov	r4, r5
    da88:	9602      	str	r6, [sp, #8]
            ee_printf("6k validation run parameters for coremark.\n");
    da8a:	f001 f9bb 	bl	ee04 <am_sprintf>
            known_id=1;
    da8e:	2301      	movs	r3, #1
            break;
    da90:	46bb      	mov	fp, r7
    da92:	46a2      	mov	sl, r4
    da94:	4630      	mov	r0, r6
            known_id=1;
    da96:	9307      	str	r3, [sp, #28]
            break;
    da98:	e628      	b.n	d6ec <main+0x320>
    if (results[0].execs & ID_STATE)
    da9a:	077b      	lsls	r3, r7, #29
    da9c:	f53f af60 	bmi.w	d960 <main+0x594>
    daa0:	e74a      	b.n	d938 <main+0x56c>
        if (i==0) res->crclist=res->crc;
    daa2:	f8ad b066 	strh.w	fp, [sp, #102]	; 0x66
    daa6:	e567      	b.n	d578 <main+0x1ac>
    daa8:	f8ad 0066 	strh.w	r0, [sp, #102]	; 0x66
    daac:	e57a      	b.n	d5a4 <main+0x1d8>
    daae:	bf00      	nop
    dab0:	00012b78 	.word	0x00012b78
    dab4:	00012b90 	.word	0x00012b90
    dab8:	00012bac 	.word	0x00012bac
    dabc:	00012bc4 	.word	0x00012bc4
    dac0:	40240000 	.word	0x40240000
    dac4:	00012c1c 	.word	0x00012c1c
    dac8:	00012c34 	.word	0x00012c34
    dacc:	00012c7c 	.word	0x00012c7c
    dad0:	00012c94 	.word	0x00012c94
    dad4:	00012c9c 	.word	0x00012c9c
    dad8:	00012cb4 	.word	0x00012cb4
    dadc:	00012cd0 	.word	0x00012cd0
    dae0:	00012cec 	.word	0x00012cec
    dae4:	00012d08 	.word	0x00012d08
    dae8:	00012d24 	.word	0x00012d24
    daec:	00012dbc 	.word	0x00012dbc
    daf0:	00012dd0 	.word	0x00012dd0
    daf4:	40480000 	.word	0x40480000
    daf8:	00012e34 	.word	0x00012e34
    dafc:	00012bdc 	.word	0x00012bdc
    db00:	00012d40 	.word	0x00012d40
    db04:	00012da8 	.word	0x00012da8
    db08:	00012d8c 	.word	0x00012d8c
    db0c:	00012db4 	.word	0x00012db4
    db10:	00012e90 	.word	0x00012e90
    db14:	000129f8 	.word	0x000129f8
    db18:	00012ab8 	.word	0x00012ab8
    db1c:	00012a28 	.word	0x00012a28
    db20:	10001000 	.word	0x10001000

0000db24 <matrix_test>:
    4 - Multiply a matrix by a matrix.
    5 - Add a constant value to all elements of a matrix.

    After the last step, matrix A is back to original contents.
*/
ee_s16 matrix_test(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B, MATDAT val) {
    db24:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    db28:	b091      	sub	sp, #68	; 0x44
    db2a:	9303      	str	r3, [sp, #12]
    db2c:	f9bd a068 	ldrsh.w	sl, [sp, #104]	; 0x68
    db30:	9109      	str	r1, [sp, #36]	; 0x24
    db32:	920b      	str	r2, [sp, #44]	; 0x2c
/* Function: matrix_add_const
    Add a constant value to all elements of a matrix.
*/
void matrix_add_const(ee_u32 N, MATDAT *A, MATDAT val) {
    ee_u32 i,j;
    for (i=0; i<N; i++) {
    db34:	4603      	mov	r3, r0
    db36:	9008      	str	r0, [sp, #32]
    db38:	2800      	cmp	r0, #0
    db3a:	f000 8754 	beq.w	e9e6 <matrix_test+0xec2>
    db3e:	ea6f 500a 	mvn.w	r0, sl, lsl #20
    db42:	ea6f 5910 	mvn.w	r9, r0, lsr #20
    db46:	f04f 0e00 	mov.w	lr, #0
    db4a:	fa1f f18a 	uxth.w	r1, sl
    db4e:	005e      	lsls	r6, r3, #1
    db50:	1e5f      	subs	r7, r3, #1
    db52:	f8cd a03c 	str.w	sl, [sp, #60]	; 0x3c
    db56:	910c      	str	r1, [sp, #48]	; 0x30
    db58:	4694      	mov	ip, r2
    db5a:	4618      	mov	r0, r3
    db5c:	970a      	str	r7, [sp, #40]	; 0x28
    db5e:	f8cd 9034 	str.w	r9, [sp, #52]	; 0x34
    db62:	920e      	str	r2, [sp, #56]	; 0x38
    db64:	46f3      	mov	fp, lr
    db66:	46f2      	mov	sl, lr
    db68:	9605      	str	r6, [sp, #20]
    db6a:	4614      	mov	r4, r2
    db6c:	e0d7      	b.n	dd1e <matrix_test+0x1fa>
        for (j=0; j<N; j++) {
            A[i*N+j] += val;
    db6e:	f8bc 8000 	ldrh.w	r8, [ip]
    for (i=0; i<N; i++) {
    db72:	4602      	mov	r2, r0
            A[i*N+j] += val;
    db74:	4488      	add	r8, r1
    db76:	2a01      	cmp	r2, #1
    db78:	f8ac 8000 	strh.w	r8, [ip]
    db7c:	f000 80e6 	beq.w	dd4c <matrix_test+0x228>
    db80:	f8bc 9002 	ldrh.w	r9, [ip, #2]
    db84:	2a02      	cmp	r2, #2
    db86:	4489      	add	r9, r1
    db88:	f8ac 9002 	strh.w	r9, [ip, #2]
    db8c:	f000 80de 	beq.w	dd4c <matrix_test+0x228>
    db90:	f8bc e004 	ldrh.w	lr, [ip, #4]
    db94:	2a04      	cmp	r2, #4
    db96:	448e      	add	lr, r1
    db98:	f8ac e004 	strh.w	lr, [ip, #4]
    db9c:	f040 80d8 	bne.w	dd50 <matrix_test+0x22c>
    dba0:	f8bc 5006 	ldrh.w	r5, [ip, #6]
    dba4:	440d      	add	r5, r1
    dba6:	f8ac 5006 	strh.w	r5, [ip, #6]
        for (j=0; j<N; j++) {
    dbaa:	4613      	mov	r3, r2
    dbac:	4290      	cmp	r0, r2
    dbae:	f000 80af 	beq.w	dd10 <matrix_test+0x1ec>
    dbb2:	1a86      	subs	r6, r0, r2
    dbb4:	1f37      	subs	r7, r6, #4
    dbb6:	9604      	str	r6, [sp, #16]
    dbb8:	9e0a      	ldr	r6, [sp, #40]	; 0x28
    dbba:	08bd      	lsrs	r5, r7, #2
    dbbc:	1c6f      	adds	r7, r5, #1
    dbbe:	1ab6      	subs	r6, r6, r2
    dbc0:	9701      	str	r7, [sp, #4]
    dbc2:	2e02      	cmp	r6, #2
    dbc4:	ea4f 0787 	mov.w	r7, r7, lsl #2
    dbc8:	9702      	str	r7, [sp, #8]
    dbca:	f240 8088 	bls.w	dcde <matrix_test+0x1ba>
    dbce:	445a      	add	r2, fp
    dbd0:	eb04 0642 	add.w	r6, r4, r2, lsl #1
            A[i*N+j] += val;
    dbd4:	f854 8012 	ldr.w	r8, [r4, r2, lsl #1]
    dbd8:	9206      	str	r2, [sp, #24]
    dbda:	eb01 0208 	add.w	r2, r1, r8
    dbde:	9207      	str	r2, [sp, #28]
    dbe0:	6872      	ldr	r2, [r6, #4]
    dbe2:	2700      	movs	r7, #0
    dbe4:	eb01 0e02 	add.w	lr, r1, r2
    dbe8:	9a07      	ldr	r2, [sp, #28]
    dbea:	46b9      	mov	r9, r7
    dbec:	f36e 090f 	bfi	r9, lr, #0, #16
    dbf0:	f362 070f 	bfi	r7, r2, #0, #16
    dbf4:	eb01 4818 	add.w	r8, r1, r8, lsr #16
    dbf8:	f005 0e01 	and.w	lr, r5, #1
    dbfc:	9d06      	ldr	r5, [sp, #24]
    dbfe:	6872      	ldr	r2, [r6, #4]
    dc00:	f368 471f 	bfi	r7, r8, #16, #16
    dc04:	f844 7015 	str.w	r7, [r4, r5, lsl #1]
    dc08:	9d01      	ldr	r5, [sp, #4]
    dc0a:	eb01 4212 	add.w	r2, r1, r2, lsr #16
    dc0e:	2701      	movs	r7, #1
    dc10:	f362 491f 	bfi	r9, r2, #16, #16
    dc14:	42bd      	cmp	r5, r7
    dc16:	f106 0208 	add.w	r2, r6, #8
    dc1a:	f8c6 9004 	str.w	r9, [r6, #4]
    dc1e:	d959      	bls.n	dcd4 <matrix_test+0x1b0>
    dc20:	f1be 0f00 	cmp.w	lr, #0
    dc24:	d01c      	beq.n	dc60 <matrix_test+0x13c>
    dc26:	6817      	ldr	r7, [r2, #0]
    dc28:	6856      	ldr	r6, [r2, #4]
    dc2a:	2500      	movs	r5, #0
    dc2c:	eb01 0907 	add.w	r9, r1, r7
    dc30:	46ae      	mov	lr, r5
    dc32:	eb01 0806 	add.w	r8, r1, r6
    dc36:	eb01 4717 	add.w	r7, r1, r7, lsr #16
    dc3a:	eb01 4616 	add.w	r6, r1, r6, lsr #16
    dc3e:	f369 050f 	bfi	r5, r9, #0, #16
    dc42:	f368 0e0f 	bfi	lr, r8, #0, #16
    dc46:	f367 451f 	bfi	r5, r7, #16, #16
    dc4a:	f366 4e1f 	bfi	lr, r6, #16, #16
    dc4e:	e882 4020 	stmia.w	r2, {r5, lr}
    dc52:	9d01      	ldr	r5, [sp, #4]
    dc54:	2702      	movs	r7, #2
    dc56:	42bd      	cmp	r5, r7
    dc58:	4616      	mov	r6, r2
    dc5a:	f102 0208 	add.w	r2, r2, #8
    dc5e:	d939      	bls.n	dcd4 <matrix_test+0x1b0>
    dc60:	9306      	str	r3, [sp, #24]
    dc62:	9007      	str	r0, [sp, #28]
    dc64:	68b5      	ldr	r5, [r6, #8]
    dc66:	f106 0e08 	add.w	lr, r6, #8
    dc6a:	68f6      	ldr	r6, [r6, #12]
    dc6c:	2300      	movs	r3, #0
    dc6e:	1988      	adds	r0, r1, r6
    dc70:	eb01 0905 	add.w	r9, r1, r5
    dc74:	4698      	mov	r8, r3
    dc76:	eb01 4616 	add.w	r6, r1, r6, lsr #16
    dc7a:	f360 080f 	bfi	r8, r0, #0, #16
    dc7e:	f369 030f 	bfi	r3, r9, #0, #16
    dc82:	eb01 4515 	add.w	r5, r1, r5, lsr #16
    dc86:	f366 481f 	bfi	r8, r6, #16, #16
    dc8a:	f365 431f 	bfi	r3, r5, #16, #16
    dc8e:	e882 0108 	stmia.w	r2, {r3, r8}
    dc92:	f10e 0608 	add.w	r6, lr, #8
    dc96:	f8de e008 	ldr.w	lr, [lr, #8]
    dc9a:	6870      	ldr	r0, [r6, #4]
    dc9c:	2300      	movs	r3, #0
    dc9e:	eb01 090e 	add.w	r9, r1, lr
    dca2:	4698      	mov	r8, r3
    dca4:	eb01 4e1e 	add.w	lr, r1, lr, lsr #16
    dca8:	f369 030f 	bfi	r3, r9, #0, #16
    dcac:	f36e 431f 	bfi	r3, lr, #16, #16
    dcb0:	180d      	adds	r5, r1, r0
    dcb2:	6093      	str	r3, [r2, #8]
    dcb4:	9b01      	ldr	r3, [sp, #4]
    dcb6:	f365 080f 	bfi	r8, r5, #0, #16
    dcba:	eb01 4010 	add.w	r0, r1, r0, lsr #16
    dcbe:	3702      	adds	r7, #2
    dcc0:	f360 481f 	bfi	r8, r0, #16, #16
    dcc4:	42bb      	cmp	r3, r7
    dcc6:	f8c2 800c 	str.w	r8, [r2, #12]
    dcca:	f102 0210 	add.w	r2, r2, #16
    dcce:	d8c9      	bhi.n	dc64 <matrix_test+0x140>
    dcd0:	9b06      	ldr	r3, [sp, #24]
    dcd2:	9807      	ldr	r0, [sp, #28]
    dcd4:	9a02      	ldr	r2, [sp, #8]
    dcd6:	9e04      	ldr	r6, [sp, #16]
    dcd8:	42b2      	cmp	r2, r6
    dcda:	4413      	add	r3, r2
    dcdc:	d018      	beq.n	dd10 <matrix_test+0x1ec>
    dcde:	eb03 090b 	add.w	r9, r3, fp
        for (j=0; j<N; j++) {
    dce2:	1c5a      	adds	r2, r3, #1
            A[i*N+j] += val;
    dce4:	f834 8019 	ldrh.w	r8, [r4, r9, lsl #1]
        for (j=0; j<N; j++) {
    dce8:	4290      	cmp	r0, r2
            A[i*N+j] += val;
    dcea:	4488      	add	r8, r1
    dcec:	f824 8019 	strh.w	r8, [r4, r9, lsl #1]
        for (j=0; j<N; j++) {
    dcf0:	d90e      	bls.n	dd10 <matrix_test+0x1ec>
            A[i*N+j] += val;
    dcf2:	445a      	add	r2, fp
        for (j=0; j<N; j++) {
    dcf4:	3302      	adds	r3, #2
            A[i*N+j] += val;
    dcf6:	f834 5012 	ldrh.w	r5, [r4, r2, lsl #1]
        for (j=0; j<N; j++) {
    dcfa:	4298      	cmp	r0, r3
            A[i*N+j] += val;
    dcfc:	440d      	add	r5, r1
    dcfe:	f824 5012 	strh.w	r5, [r4, r2, lsl #1]
        for (j=0; j<N; j++) {
    dd02:	d905      	bls.n	dd10 <matrix_test+0x1ec>
            A[i*N+j] += val;
    dd04:	445b      	add	r3, fp
    dd06:	f834 e013 	ldrh.w	lr, [r4, r3, lsl #1]
    dd0a:	448e      	add	lr, r1
    dd0c:	f824 e013 	strh.w	lr, [r4, r3, lsl #1]
    for (i=0; i<N; i++) {
    dd10:	f10a 0a01 	add.w	sl, sl, #1
    dd14:	9b05      	ldr	r3, [sp, #20]
    dd16:	4550      	cmp	r0, sl
    dd18:	449c      	add	ip, r3
    dd1a:	4483      	add	fp, r0
    dd1c:	d01a      	beq.n	dd54 <matrix_test+0x230>
    dd1e:	ea4f 025c 	mov.w	r2, ip, lsr #1
    dd22:	4253      	negs	r3, r2
    dd24:	f003 0303 	and.w	r3, r3, #3
    dd28:	4283      	cmp	r3, r0
    dd2a:	bf28      	it	cs
    dd2c:	4603      	movcs	r3, r0
    dd2e:	2804      	cmp	r0, #4
    dd30:	f67f af1d 	bls.w	db6e <matrix_test+0x4a>
    dd34:	461a      	mov	r2, r3
    dd36:	2b00      	cmp	r3, #0
    dd38:	f43f af3b 	beq.w	dbb2 <matrix_test+0x8e>
            A[i*N+j] += val;
    dd3c:	f8bc 8000 	ldrh.w	r8, [ip]
    dd40:	2a01      	cmp	r2, #1
    dd42:	4488      	add	r8, r1
    dd44:	f8ac 8000 	strh.w	r8, [ip]
    dd48:	f47f af1a 	bne.w	db80 <matrix_test+0x5c>
        for (j=0; j<N; j++) {
    dd4c:	4613      	mov	r3, r2
    dd4e:	e72d      	b.n	dbac <matrix_test+0x88>
    dd50:	2303      	movs	r3, #3
    dd52:	e72b      	b.n	dbac <matrix_test+0x88>
    dd54:	9c08      	ldr	r4, [sp, #32]
    dd56:	f8dd c034 	ldr.w	ip, [sp, #52]	; 0x34
    dd5a:	f8cd a004 	str.w	sl, [sp, #4]
    dd5e:	00a0      	lsls	r0, r4, #2
    for (i=0; i<N; i++) {
    dd60:	2700      	movs	r7, #0
    dd62:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
    dd66:	f8dd a03c 	ldr.w	sl, [sp, #60]	; 0x3c
    dd6a:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
    dd6e:	f8cd c010 	str.w	ip, [sp, #16]
    dd72:	9002      	str	r0, [sp, #8]
    dd74:	46bc      	mov	ip, r7
    dd76:	4699      	mov	r9, r3
    dd78:	eb0b 0e09 	add.w	lr, fp, r9
            C[i*N+j]=(MATRES)A[i*N+j] * (MATRES)val;
    dd7c:	f93b 6b02 	ldrsh.w	r6, [fp], #2
    dd80:	4643      	mov	r3, r8
    dd82:	fb06 f50a 	mul.w	r5, r6, sl
    dd86:	f1a9 0202 	sub.w	r2, r9, #2
        for (j=0; j<N; j++) {
    dd8a:	45f3      	cmp	fp, lr
            C[i*N+j]=(MATRES)A[i*N+j] * (MATRES)val;
    dd8c:	f843 5b04 	str.w	r5, [r3], #4
    dd90:	f3c2 0142 	ubfx	r1, r2, #1, #3
        for (j=0; j<N; j++) {
    dd94:	d069      	beq.n	de6a <matrix_test+0x346>
    dd96:	b3b9      	cbz	r1, de08 <matrix_test+0x2e4>
    dd98:	2901      	cmp	r1, #1
    dd9a:	d02d      	beq.n	ddf8 <matrix_test+0x2d4>
    dd9c:	2902      	cmp	r1, #2
    dd9e:	d025      	beq.n	ddec <matrix_test+0x2c8>
    dda0:	2903      	cmp	r1, #3
    dda2:	d01d      	beq.n	dde0 <matrix_test+0x2bc>
    dda4:	2904      	cmp	r1, #4
    dda6:	d015      	beq.n	ddd4 <matrix_test+0x2b0>
    dda8:	2905      	cmp	r1, #5
    ddaa:	d00d      	beq.n	ddc8 <matrix_test+0x2a4>
    ddac:	2906      	cmp	r1, #6
    ddae:	d005      	beq.n	ddbc <matrix_test+0x298>
            C[i*N+j]=(MATRES)A[i*N+j] * (MATRES)val;
    ddb0:	f93b 4b02 	ldrsh.w	r4, [fp], #2
    ddb4:	fb04 f00a 	mul.w	r0, r4, sl
    ddb8:	f843 0b04 	str.w	r0, [r3], #4
    ddbc:	f93b 7b02 	ldrsh.w	r7, [fp], #2
    ddc0:	fb07 f60a 	mul.w	r6, r7, sl
    ddc4:	f843 6b04 	str.w	r6, [r3], #4
    ddc8:	f93b 5b02 	ldrsh.w	r5, [fp], #2
    ddcc:	fb05 f20a 	mul.w	r2, r5, sl
    ddd0:	f843 2b04 	str.w	r2, [r3], #4
    ddd4:	f93b 1b02 	ldrsh.w	r1, [fp], #2
    ddd8:	fb01 f40a 	mul.w	r4, r1, sl
    dddc:	f843 4b04 	str.w	r4, [r3], #4
    dde0:	f93b 0b02 	ldrsh.w	r0, [fp], #2
    dde4:	fb00 f70a 	mul.w	r7, r0, sl
    dde8:	f843 7b04 	str.w	r7, [r3], #4
    ddec:	f93b 6b02 	ldrsh.w	r6, [fp], #2
    ddf0:	fb06 f50a 	mul.w	r5, r6, sl
    ddf4:	f843 5b04 	str.w	r5, [r3], #4
    ddf8:	f93b 2b02 	ldrsh.w	r2, [fp], #2
    ddfc:	fb02 f10a 	mul.w	r1, r2, sl
        for (j=0; j<N; j++) {
    de00:	45f3      	cmp	fp, lr
            C[i*N+j]=(MATRES)A[i*N+j] * (MATRES)val;
    de02:	f843 1b04 	str.w	r1, [r3], #4
        for (j=0; j<N; j++) {
    de06:	d030      	beq.n	de6a <matrix_test+0x346>
            C[i*N+j]=(MATRES)A[i*N+j] * (MATRES)val;
    de08:	465c      	mov	r4, fp
    de0a:	461a      	mov	r2, r3
    de0c:	f934 0b02 	ldrsh.w	r0, [r4], #2
    de10:	f9bb 7002 	ldrsh.w	r7, [fp, #2]
    de14:	f9b4 6002 	ldrsh.w	r6, [r4, #2]
    de18:	f9bb 5006 	ldrsh.w	r5, [fp, #6]
    de1c:	f9bb 4008 	ldrsh.w	r4, [fp, #8]
    de20:	fb00 f10a 	mul.w	r1, r0, sl
    de24:	f842 1b04 	str.w	r1, [r2], #4
    de28:	fb06 f60a 	mul.w	r6, r6, sl
    de2c:	fb07 f70a 	mul.w	r7, r7, sl
    de30:	f9bb 000a 	ldrsh.w	r0, [fp, #10]
    de34:	f9bb 100c 	ldrsh.w	r1, [fp, #12]
    de38:	605f      	str	r7, [r3, #4]
    de3a:	6056      	str	r6, [r2, #4]
    de3c:	f9bb 200e 	ldrsh.w	r2, [fp, #14]
    de40:	f10b 0b10 	add.w	fp, fp, #16
    de44:	fb05 f50a 	mul.w	r5, r5, sl
    de48:	fb04 f40a 	mul.w	r4, r4, sl
    de4c:	fb00 f00a 	mul.w	r0, r0, sl
    de50:	fb01 f10a 	mul.w	r1, r1, sl
    de54:	fb02 f60a 	mul.w	r6, r2, sl
        for (j=0; j<N; j++) {
    de58:	45f3      	cmp	fp, lr
            C[i*N+j]=(MATRES)A[i*N+j] * (MATRES)val;
    de5a:	60dd      	str	r5, [r3, #12]
    de5c:	611c      	str	r4, [r3, #16]
    de5e:	6158      	str	r0, [r3, #20]
    de60:	6199      	str	r1, [r3, #24]
    de62:	61de      	str	r6, [r3, #28]
    de64:	f103 0320 	add.w	r3, r3, #32
        for (j=0; j<N; j++) {
    de68:	d1ce      	bne.n	de08 <matrix_test+0x2e4>
    for (i=0; i<N; i++) {
    de6a:	9f01      	ldr	r7, [sp, #4]
    de6c:	9b02      	ldr	r3, [sp, #8]
    de6e:	f10c 0c01 	add.w	ip, ip, #1
    de72:	45bc      	cmp	ip, r7
    de74:	4498      	add	r8, r3
    de76:	f47f af7f 	bne.w	dd78 <matrix_test+0x254>
    de7a:	f04f 0c00 	mov.w	ip, #0
    de7e:	464c      	mov	r4, r9
    de80:	9e09      	ldr	r6, [sp, #36]	; 0x24
    de82:	f8dd 9010 	ldr.w	r9, [sp, #16]
    de86:	f8dd b020 	ldr.w	fp, [sp, #32]
    de8a:	f8dd a008 	ldr.w	sl, [sp, #8]
    de8e:	9601      	str	r6, [sp, #4]
    de90:	4660      	mov	r0, ip
    de92:	4665      	mov	r5, ip
    de94:	46e0      	mov	r8, ip
    de96:	eb06 0e0a 	add.w	lr, r6, sl
            cur=C[i*N+j];
    de9a:	f856 3b04 	ldr.w	r3, [r6], #4
                ret+=10;
    de9e:	b280      	uxth	r0, r0
    dea0:	f100 010a 	add.w	r1, r0, #10
            tmp+=cur;
    dea4:	4498      	add	r8, r3
                ret += (cur>prev) ? 1 : 0;
    dea6:	42ab      	cmp	r3, r5
    dea8:	bfc8      	it	gt
    deaa:	3001      	addgt	r0, #1
    deac:	45c8      	cmp	r8, r9
                ret+=10;
    deae:	b20d      	sxth	r5, r1
                ret += (cur>prev) ? 1 : 0;
    deb0:	b200      	sxth	r0, r0
    deb2:	f1aa 0204 	sub.w	r2, sl, #4
    deb6:	bfc4      	itt	gt
    deb8:	4628      	movgt	r0, r5
    deba:	f04f 0800 	movgt.w	r8, #0
        for (j=0; j<N; j++) {
    debe:	4576      	cmp	r6, lr
            cur=C[i*N+j];
    dec0:	461d      	mov	r5, r3
    dec2:	f3c2 0781 	ubfx	r7, r2, #2, #2
        for (j=0; j<N; j++) {
    dec6:	f000 8086 	beq.w	dfd6 <matrix_test+0x4b2>
    deca:	2f00      	cmp	r7, #0
    decc:	d038      	beq.n	df40 <matrix_test+0x41c>
    dece:	2f01      	cmp	r7, #1
    ded0:	d023      	beq.n	df1a <matrix_test+0x3f6>
    ded2:	2f02      	cmp	r7, #2
    ded4:	d010      	beq.n	def8 <matrix_test+0x3d4>
            cur=C[i*N+j];
    ded6:	f856 3b04 	ldr.w	r3, [r6], #4
                ret+=10;
    deda:	b280      	uxth	r0, r0
    dedc:	f100 010a 	add.w	r1, r0, #10
            tmp+=cur;
    dee0:	4498      	add	r8, r3
                ret += (cur>prev) ? 1 : 0;
    dee2:	42ab      	cmp	r3, r5
    dee4:	bfc8      	it	gt
    dee6:	3001      	addgt	r0, #1
                ret+=10;
    dee8:	b20d      	sxth	r5, r1
    deea:	45c8      	cmp	r8, r9
                ret += (cur>prev) ? 1 : 0;
    deec:	b200      	sxth	r0, r0
    deee:	bfc4      	itt	gt
    def0:	f04f 0800 	movgt.w	r8, #0
    def4:	4628      	movgt	r0, r5
            cur=C[i*N+j];
    def6:	461d      	mov	r5, r3
    def8:	f856 7b04 	ldr.w	r7, [r6], #4
                ret+=10;
    defc:	b283      	uxth	r3, r0
    defe:	f103 020a 	add.w	r2, r3, #10
            tmp+=cur;
    df02:	44b8      	add	r8, r7
                ret += (cur>prev) ? 1 : 0;
    df04:	42af      	cmp	r7, r5
    df06:	bfc8      	it	gt
    df08:	3301      	addgt	r3, #1
                ret+=10;
    df0a:	b211      	sxth	r1, r2
    df0c:	45c8      	cmp	r8, r9
                ret += (cur>prev) ? 1 : 0;
    df0e:	b218      	sxth	r0, r3
    df10:	bfc4      	itt	gt
    df12:	f04f 0800 	movgt.w	r8, #0
    df16:	4608      	movgt	r0, r1
            cur=C[i*N+j];
    df18:	463d      	mov	r5, r7
    df1a:	f856 7b04 	ldr.w	r7, [r6], #4
                ret+=10;
    df1e:	b280      	uxth	r0, r0
    df20:	f100 030a 	add.w	r3, r0, #10
            tmp+=cur;
    df24:	44b8      	add	r8, r7
                ret += (cur>prev) ? 1 : 0;
    df26:	42af      	cmp	r7, r5
    df28:	bfc8      	it	gt
    df2a:	3001      	addgt	r0, #1
    df2c:	45c8      	cmp	r8, r9
                ret+=10;
    df2e:	b21d      	sxth	r5, r3
                ret += (cur>prev) ? 1 : 0;
    df30:	b200      	sxth	r0, r0
    df32:	bfc4      	itt	gt
    df34:	f04f 0800 	movgt.w	r8, #0
    df38:	4628      	movgt	r0, r5
        for (j=0; j<N; j++) {
    df3a:	4576      	cmp	r6, lr
            cur=C[i*N+j];
    df3c:	463d      	mov	r5, r7
        for (j=0; j<N; j++) {
    df3e:	d04a      	beq.n	dfd6 <matrix_test+0x4b2>
    df40:	4642      	mov	r2, r8
            cur=C[i*N+j];
    df42:	4631      	mov	r1, r6
                ret+=10;
    df44:	b280      	uxth	r0, r0
            cur=C[i*N+j];
    df46:	f851 8b04 	ldr.w	r8, [r1], #4
    df4a:	6873      	ldr	r3, [r6, #4]
    df4c:	684f      	ldr	r7, [r1, #4]
    df4e:	68f1      	ldr	r1, [r6, #12]
            tmp+=cur;
    df50:	4442      	add	r2, r8
                ret += (cur>prev) ? 1 : 0;
    df52:	45a8      	cmp	r8, r5
    df54:	bfd4      	ite	le
    df56:	4605      	movle	r5, r0
    df58:	1c45      	addgt	r5, r0, #1
    df5a:	b22d      	sxth	r5, r5
    df5c:	454a      	cmp	r2, r9
                ret+=10;
    df5e:	f100 000a 	add.w	r0, r0, #10
    df62:	b200      	sxth	r0, r0
    df64:	bfd6      	itet	le
    df66:	4628      	movle	r0, r5
    df68:	2500      	movgt	r5, #0
    df6a:	4615      	movle	r5, r2
    df6c:	b282      	uxth	r2, r0
            tmp+=cur;
    df6e:	441d      	add	r5, r3
                ret+=10;
    df70:	f102 000a 	add.w	r0, r2, #10
                ret += (cur>prev) ? 1 : 0;
    df74:	4543      	cmp	r3, r8
    df76:	bfc8      	it	gt
    df78:	3201      	addgt	r2, #1
    df7a:	b212      	sxth	r2, r2
    df7c:	454d      	cmp	r5, r9
                ret+=10;
    df7e:	fa0f f880 	sxth.w	r8, r0
    df82:	bfd4      	ite	le
    df84:	4690      	movle	r8, r2
    df86:	2500      	movgt	r5, #0
    df88:	fa1f f088 	uxth.w	r0, r8
    df8c:	f100 080a 	add.w	r8, r0, #10
                ret += (cur>prev) ? 1 : 0;
    df90:	429f      	cmp	r7, r3
    df92:	bfc8      	it	gt
    df94:	3001      	addgt	r0, #1
            tmp+=cur;
    df96:	197b      	adds	r3, r7, r5
    df98:	454b      	cmp	r3, r9
                ret += (cur>prev) ? 1 : 0;
    df9a:	b205      	sxth	r5, r0
                ret+=10;
    df9c:	fa0f f288 	sxth.w	r2, r8
    dfa0:	bfd8      	it	le
    dfa2:	462a      	movle	r2, r5
    dfa4:	fa1f f882 	uxth.w	r8, r2
    dfa8:	bfc8      	it	gt
    dfaa:	2300      	movgt	r3, #0
    dfac:	f108 000a 	add.w	r0, r8, #10
            tmp+=cur;
    dfb0:	440b      	add	r3, r1
                ret += (cur>prev) ? 1 : 0;
    dfb2:	42b9      	cmp	r1, r7
    dfb4:	bfc8      	it	gt
    dfb6:	f108 0801 	addgt.w	r8, r8, #1
    dfba:	fa0f f288 	sxth.w	r2, r8
    dfbe:	454b      	cmp	r3, r9
    dfc0:	f106 0610 	add.w	r6, r6, #16
                ret+=10;
    dfc4:	b200      	sxth	r0, r0
    dfc6:	bfce      	itee	gt
    dfc8:	2200      	movgt	r2, #0
    dfca:	4610      	movle	r0, r2
    dfcc:	461a      	movle	r2, r3
        for (j=0; j<N; j++) {
    dfce:	4576      	cmp	r6, lr
            cur=C[i*N+j];
    dfd0:	460d      	mov	r5, r1
        for (j=0; j<N; j++) {
    dfd2:	d1b6      	bne.n	df42 <matrix_test+0x41e>
    dfd4:	4690      	mov	r8, r2
    for (i=0; i<N; i++) {
    dfd6:	f10c 0c01 	add.w	ip, ip, #1
    dfda:	45e3      	cmp	fp, ip
    dfdc:	f47f af5b 	bne.w	de96 <matrix_test+0x372>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    dfe0:	2100      	movs	r1, #0
    dfe2:	f8dd b004 	ldr.w	fp, [sp, #4]
    dfe6:	f001 fb15 	bl	f614 <crc16>
    dfea:	9e09      	ldr	r6, [sp, #36]	; 0x24
    dfec:	9f02      	ldr	r7, [sp, #8]
    dfee:	9903      	ldr	r1, [sp, #12]
    dff0:	f8dd a02c 	ldr.w	sl, [sp, #44]	; 0x2c
    dff4:	f8cd 9014 	str.w	r9, [sp, #20]
    dff8:	443e      	add	r6, r7
    dffa:	9004      	str	r0, [sp, #16]
    dffc:	9601      	str	r6, [sp, #4]
    dffe:	eb01 0804 	add.w	r8, r1, r4
    e002:	4689      	mov	r9, r1
void matrix_mul_vect(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B) {
    ee_u32 i,j;
    for (i=0; i<N; i++) {
        C[i]=0;
        for (j=0; j<N; j++) {
            C[i]+=(MATRES)A[i*N+j] * (MATRES)B[j];
    e004:	46ce      	mov	lr, r9
    e006:	46d4      	mov	ip, sl
    e008:	f93e 3b02 	ldrsh.w	r3, [lr], #2
    e00c:	f93c 5b02 	ldrsh.w	r5, [ip], #2
    e010:	eba8 0009 	sub.w	r0, r8, r9
    e014:	1e82      	subs	r2, r0, #2
        for (j=0; j<N; j++) {
    e016:	45f0      	cmp	r8, lr
            C[i]+=(MATRES)A[i*N+j] * (MATRES)B[j];
    e018:	fb05 f303 	mul.w	r3, r5, r3
    e01c:	f3c2 0642 	ubfx	r6, r2, #1, #3
        for (j=0; j<N; j++) {
    e020:	d072      	beq.n	e108 <matrix_test+0x5e4>
    e022:	b3ce      	cbz	r6, e098 <matrix_test+0x574>
    e024:	2e01      	cmp	r6, #1
    e026:	d02f      	beq.n	e088 <matrix_test+0x564>
    e028:	2e02      	cmp	r6, #2
    e02a:	d027      	beq.n	e07c <matrix_test+0x558>
    e02c:	2e03      	cmp	r6, #3
    e02e:	d01f      	beq.n	e070 <matrix_test+0x54c>
    e030:	2e04      	cmp	r6, #4
    e032:	d017      	beq.n	e064 <matrix_test+0x540>
    e034:	2e05      	cmp	r6, #5
    e036:	d00f      	beq.n	e058 <matrix_test+0x534>
    e038:	2e06      	cmp	r6, #6
    e03a:	d007      	beq.n	e04c <matrix_test+0x528>
            C[i]+=(MATRES)A[i*N+j] * (MATRES)B[j];
    e03c:	f93c 7b02 	ldrsh.w	r7, [ip], #2
    e040:	f9b9 1002 	ldrsh.w	r1, [r9, #2]
    e044:	f10e 0e02 	add.w	lr, lr, #2
    e048:	fb07 3301 	mla	r3, r7, r1, r3
    e04c:	f93c 5b02 	ldrsh.w	r5, [ip], #2
    e050:	f93e 0b02 	ldrsh.w	r0, [lr], #2
    e054:	fb05 3300 	mla	r3, r5, r0, r3
    e058:	f93c 6b02 	ldrsh.w	r6, [ip], #2
    e05c:	f93e 2b02 	ldrsh.w	r2, [lr], #2
    e060:	fb06 3302 	mla	r3, r6, r2, r3
    e064:	f93c 7b02 	ldrsh.w	r7, [ip], #2
    e068:	f93e 1b02 	ldrsh.w	r1, [lr], #2
    e06c:	fb07 3301 	mla	r3, r7, r1, r3
    e070:	f93c 5b02 	ldrsh.w	r5, [ip], #2
    e074:	f93e 0b02 	ldrsh.w	r0, [lr], #2
    e078:	fb05 3300 	mla	r3, r5, r0, r3
    e07c:	f93c 6b02 	ldrsh.w	r6, [ip], #2
    e080:	f93e 2b02 	ldrsh.w	r2, [lr], #2
    e084:	fb06 3302 	mla	r3, r6, r2, r3
    e088:	f93e 1b02 	ldrsh.w	r1, [lr], #2
    e08c:	f93c 7b02 	ldrsh.w	r7, [ip], #2
        for (j=0; j<N; j++) {
    e090:	45f0      	cmp	r8, lr
            C[i]+=(MATRES)A[i*N+j] * (MATRES)B[j];
    e092:	fb07 3301 	mla	r3, r7, r1, r3
        for (j=0; j<N; j++) {
    e096:	d037      	beq.n	e108 <matrix_test+0x5e4>
            C[i]+=(MATRES)A[i*N+j] * (MATRES)B[j];
    e098:	4666      	mov	r6, ip
    e09a:	4672      	mov	r2, lr
    e09c:	f936 7b02 	ldrsh.w	r7, [r6], #2
    e0a0:	f932 0b02 	ldrsh.w	r0, [r2], #2
    e0a4:	f9be 1002 	ldrsh.w	r1, [lr, #2]
    e0a8:	f9bc 5002 	ldrsh.w	r5, [ip, #2]
    e0ac:	f9b6 6002 	ldrsh.w	r6, [r6, #2]
    e0b0:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
    e0b4:	fb07 3300 	mla	r3, r7, r0, r3
    e0b8:	fb05 3701 	mla	r7, r5, r1, r3
    e0bc:	f9be 3006 	ldrsh.w	r3, [lr, #6]
    e0c0:	f9bc 5006 	ldrsh.w	r5, [ip, #6]
    e0c4:	f9bc 0008 	ldrsh.w	r0, [ip, #8]
    e0c8:	f9be 1008 	ldrsh.w	r1, [lr, #8]
    e0cc:	fb06 7202 	mla	r2, r6, r2, r7
    e0d0:	fb05 2703 	mla	r7, r5, r3, r2
    e0d4:	f9bc 600a 	ldrsh.w	r6, [ip, #10]
    e0d8:	f9be 200a 	ldrsh.w	r2, [lr, #10]
    e0dc:	f9be 300c 	ldrsh.w	r3, [lr, #12]
    e0e0:	f9bc 500c 	ldrsh.w	r5, [ip, #12]
    e0e4:	fb00 7101 	mla	r1, r0, r1, r7
    e0e8:	fb06 1602 	mla	r6, r6, r2, r1
    e0ec:	f9be 700e 	ldrsh.w	r7, [lr, #14]
    e0f0:	f9bc 000e 	ldrsh.w	r0, [ip, #14]
    e0f4:	f10e 0e10 	add.w	lr, lr, #16
    e0f8:	fb05 6203 	mla	r2, r5, r3, r6
        for (j=0; j<N; j++) {
    e0fc:	45f0      	cmp	r8, lr
    e0fe:	f10c 0c10 	add.w	ip, ip, #16
            C[i]+=(MATRES)A[i*N+j] * (MATRES)B[j];
    e102:	fb00 2307 	mla	r3, r0, r7, r2
        for (j=0; j<N; j++) {
    e106:	d1c7      	bne.n	e098 <matrix_test+0x574>
    e108:	f84b 3b04 	str.w	r3, [fp], #4
    for (i=0; i<N; i++) {
    e10c:	9d01      	ldr	r5, [sp, #4]
    e10e:	45ab      	cmp	fp, r5
    e110:	44a2      	add	sl, r4
    e112:	f47f af77 	bne.w	e004 <matrix_test+0x4e0>
    e116:	f04f 0800 	mov.w	r8, #0
    e11a:	9e09      	ldr	r6, [sp, #36]	; 0x24
    e11c:	f8dd 9014 	ldr.w	r9, [sp, #20]
    e120:	f8dd b020 	ldr.w	fp, [sp, #32]
    e124:	f8dd a008 	ldr.w	sl, [sp, #8]
    e128:	9601      	str	r6, [sp, #4]
    e12a:	4645      	mov	r5, r8
    e12c:	4640      	mov	r0, r8
    e12e:	46c4      	mov	ip, r8
    e130:	eb06 0e0a 	add.w	lr, r6, sl
            cur=C[i*N+j];
    e134:	f856 7b04 	ldr.w	r7, [r6], #4
                ret+=10;
    e138:	b283      	uxth	r3, r0
            tmp+=cur;
    e13a:	44bc      	add	ip, r7
                ret+=10;
    e13c:	f103 010a 	add.w	r1, r3, #10
    e140:	b20a      	sxth	r2, r1
                ret += (cur>prev) ? 1 : 0;
    e142:	42af      	cmp	r7, r5
    e144:	bfc8      	it	gt
    e146:	3301      	addgt	r3, #1
    e148:	45cc      	cmp	ip, r9
    e14a:	b218      	sxth	r0, r3
    e14c:	bfc8      	it	gt
    e14e:	f04f 0c00 	movgt.w	ip, #0
    e152:	f1aa 0304 	sub.w	r3, sl, #4
    e156:	bfc8      	it	gt
    e158:	4610      	movgt	r0, r2
        for (j=0; j<N; j++) {
    e15a:	45b6      	cmp	lr, r6
            cur=C[i*N+j];
    e15c:	463d      	mov	r5, r7
    e15e:	f3c3 0781 	ubfx	r7, r3, #2, #2
        for (j=0; j<N; j++) {
    e162:	f000 8086 	beq.w	e272 <matrix_test+0x74e>
    e166:	2f00      	cmp	r7, #0
    e168:	d038      	beq.n	e1dc <matrix_test+0x6b8>
    e16a:	2f01      	cmp	r7, #1
    e16c:	d023      	beq.n	e1b6 <matrix_test+0x692>
    e16e:	2f02      	cmp	r7, #2
    e170:	d010      	beq.n	e194 <matrix_test+0x670>
            cur=C[i*N+j];
    e172:	f856 1b04 	ldr.w	r1, [r6], #4
                ret+=10;
    e176:	b280      	uxth	r0, r0
    e178:	f100 020a 	add.w	r2, r0, #10
            tmp+=cur;
    e17c:	448c      	add	ip, r1
                ret += (cur>prev) ? 1 : 0;
    e17e:	42a9      	cmp	r1, r5
    e180:	bfc8      	it	gt
    e182:	3001      	addgt	r0, #1
                ret+=10;
    e184:	b215      	sxth	r5, r2
    e186:	45cc      	cmp	ip, r9
                ret += (cur>prev) ? 1 : 0;
    e188:	b200      	sxth	r0, r0
    e18a:	bfc4      	itt	gt
    e18c:	f04f 0c00 	movgt.w	ip, #0
    e190:	4628      	movgt	r0, r5
            cur=C[i*N+j];
    e192:	460d      	mov	r5, r1
    e194:	f856 3b04 	ldr.w	r3, [r6], #4
                ret+=10;
    e198:	b287      	uxth	r7, r0
    e19a:	f107 010a 	add.w	r1, r7, #10
            tmp+=cur;
    e19e:	449c      	add	ip, r3
                ret += (cur>prev) ? 1 : 0;
    e1a0:	42ab      	cmp	r3, r5
    e1a2:	bfc8      	it	gt
    e1a4:	3701      	addgt	r7, #1
                ret+=10;
    e1a6:	b20a      	sxth	r2, r1
    e1a8:	45cc      	cmp	ip, r9
                ret += (cur>prev) ? 1 : 0;
    e1aa:	b238      	sxth	r0, r7
    e1ac:	bfc4      	itt	gt
    e1ae:	f04f 0c00 	movgt.w	ip, #0
    e1b2:	4610      	movgt	r0, r2
            cur=C[i*N+j];
    e1b4:	461d      	mov	r5, r3
    e1b6:	f856 3b04 	ldr.w	r3, [r6], #4
                ret+=10;
    e1ba:	b280      	uxth	r0, r0
    e1bc:	f100 070a 	add.w	r7, r0, #10
            tmp+=cur;
    e1c0:	449c      	add	ip, r3
                ret += (cur>prev) ? 1 : 0;
    e1c2:	42ab      	cmp	r3, r5
    e1c4:	bfc8      	it	gt
    e1c6:	3001      	addgt	r0, #1
    e1c8:	45cc      	cmp	ip, r9
                ret+=10;
    e1ca:	b23d      	sxth	r5, r7
                ret += (cur>prev) ? 1 : 0;
    e1cc:	b200      	sxth	r0, r0
    e1ce:	bfc4      	itt	gt
    e1d0:	f04f 0c00 	movgt.w	ip, #0
    e1d4:	4628      	movgt	r0, r5
        for (j=0; j<N; j++) {
    e1d6:	45b6      	cmp	lr, r6
            cur=C[i*N+j];
    e1d8:	461d      	mov	r5, r3
        for (j=0; j<N; j++) {
    e1da:	d04a      	beq.n	e272 <matrix_test+0x74e>
    e1dc:	4662      	mov	r2, ip
            cur=C[i*N+j];
    e1de:	4631      	mov	r1, r6
                ret+=10;
    e1e0:	b280      	uxth	r0, r0
            cur=C[i*N+j];
    e1e2:	f851 cb04 	ldr.w	ip, [r1], #4
    e1e6:	6873      	ldr	r3, [r6, #4]
    e1e8:	684f      	ldr	r7, [r1, #4]
    e1ea:	68f1      	ldr	r1, [r6, #12]
            tmp+=cur;
    e1ec:	4462      	add	r2, ip
                ret += (cur>prev) ? 1 : 0;
    e1ee:	45ac      	cmp	ip, r5
    e1f0:	bfd4      	ite	le
    e1f2:	4605      	movle	r5, r0
    e1f4:	1c45      	addgt	r5, r0, #1
    e1f6:	b22d      	sxth	r5, r5
    e1f8:	454a      	cmp	r2, r9
                ret+=10;
    e1fa:	f100 000a 	add.w	r0, r0, #10
    e1fe:	b200      	sxth	r0, r0
    e200:	bfd6      	itet	le
    e202:	4628      	movle	r0, r5
    e204:	2500      	movgt	r5, #0
    e206:	4615      	movle	r5, r2
    e208:	b282      	uxth	r2, r0
            tmp+=cur;
    e20a:	441d      	add	r5, r3
                ret+=10;
    e20c:	f102 000a 	add.w	r0, r2, #10
                ret += (cur>prev) ? 1 : 0;
    e210:	4563      	cmp	r3, ip
    e212:	bfc8      	it	gt
    e214:	3201      	addgt	r2, #1
    e216:	b212      	sxth	r2, r2
    e218:	454d      	cmp	r5, r9
                ret+=10;
    e21a:	fa0f fc80 	sxth.w	ip, r0
    e21e:	bfd4      	ite	le
    e220:	4694      	movle	ip, r2
    e222:	2500      	movgt	r5, #0
    e224:	fa1f f08c 	uxth.w	r0, ip
    e228:	f100 0c0a 	add.w	ip, r0, #10
                ret += (cur>prev) ? 1 : 0;
    e22c:	429f      	cmp	r7, r3
    e22e:	bfc8      	it	gt
    e230:	3001      	addgt	r0, #1
            tmp+=cur;
    e232:	197b      	adds	r3, r7, r5
    e234:	454b      	cmp	r3, r9
                ret += (cur>prev) ? 1 : 0;
    e236:	b205      	sxth	r5, r0
                ret+=10;
    e238:	fa0f f28c 	sxth.w	r2, ip
    e23c:	bfd8      	it	le
    e23e:	462a      	movle	r2, r5
    e240:	fa1f fc82 	uxth.w	ip, r2
    e244:	bfc8      	it	gt
    e246:	2300      	movgt	r3, #0
    e248:	f10c 000a 	add.w	r0, ip, #10
            tmp+=cur;
    e24c:	440b      	add	r3, r1
                ret += (cur>prev) ? 1 : 0;
    e24e:	42b9      	cmp	r1, r7
    e250:	bfc8      	it	gt
    e252:	f10c 0c01 	addgt.w	ip, ip, #1
    e256:	fa0f f28c 	sxth.w	r2, ip
    e25a:	454b      	cmp	r3, r9
    e25c:	f106 0610 	add.w	r6, r6, #16
                ret+=10;
    e260:	b200      	sxth	r0, r0
    e262:	bfce      	itee	gt
    e264:	2200      	movgt	r2, #0
    e266:	4610      	movle	r0, r2
    e268:	461a      	movle	r2, r3
        for (j=0; j<N; j++) {
    e26a:	45b6      	cmp	lr, r6
            cur=C[i*N+j];
    e26c:	460d      	mov	r5, r1
        for (j=0; j<N; j++) {
    e26e:	d1b6      	bne.n	e1de <matrix_test+0x6ba>
    e270:	4694      	mov	ip, r2
    for (i=0; i<N; i++) {
    e272:	f108 0801 	add.w	r8, r8, #1
    e276:	45c3      	cmp	fp, r8
    e278:	f47f af5a 	bne.w	e130 <matrix_test+0x60c>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    e27c:	9904      	ldr	r1, [sp, #16]
    e27e:	f8cd 8014 	str.w	r8, [sp, #20]
    e282:	f001 f9c7 	bl	f614 <crc16>
    e286:	9e03      	ldr	r6, [sp, #12]
    e288:	f8dd c02c 	ldr.w	ip, [sp, #44]	; 0x2c
    e28c:	f8dd a004 	ldr.w	sl, [sp, #4]
    e290:	f8cd 901c 	str.w	r9, [sp, #28]
    e294:	4426      	add	r6, r4
    e296:	2700      	movs	r7, #0
    e298:	9006      	str	r0, [sp, #24]
    e29a:	9704      	str	r7, [sp, #16]
    e29c:	46b1      	mov	r9, r6
    e29e:	9f03      	ldr	r7, [sp, #12]
    e2a0:	eb04 0e0c 	add.w	lr, r4, ip
    e2a4:	46d0      	mov	r8, sl
    for (i=0; i<N; i++) {
        for (j=0; j<N; j++) {
            C[i*N+j]=0;
            for(k=0;k<N;k++)
            {
                C[i*N+j]+=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    e2a6:	46e3      	mov	fp, ip
    e2a8:	883b      	ldrh	r3, [r7, #0]
    e2aa:	f93b 1b02 	ldrsh.w	r1, [fp], #2
    e2ae:	ebae 050c 	sub.w	r5, lr, ip
    e2b2:	1ea8      	subs	r0, r5, #2
            for(k=0;k<N;k++)
    e2b4:	45de      	cmp	lr, fp
                C[i*N+j]+=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    e2b6:	fb11 f303 	smulbb	r3, r1, r3
    e2ba:	f3c0 0242 	ubfx	r2, r0, #1, #3
    e2be:	eb07 0604 	add.w	r6, r7, r4
            for(k=0;k<N;k++)
    e2c2:	d075      	beq.n	e3b0 <matrix_test+0x88c>
    e2c4:	b3ba      	cbz	r2, e336 <matrix_test+0x812>
    e2c6:	2a01      	cmp	r2, #1
    e2c8:	d02d      	beq.n	e326 <matrix_test+0x802>
    e2ca:	2a02      	cmp	r2, #2
    e2cc:	d025      	beq.n	e31a <matrix_test+0x7f6>
    e2ce:	2a03      	cmp	r2, #3
    e2d0:	d01d      	beq.n	e30e <matrix_test+0x7ea>
    e2d2:	2a04      	cmp	r2, #4
    e2d4:	d015      	beq.n	e302 <matrix_test+0x7de>
    e2d6:	2a05      	cmp	r2, #5
    e2d8:	d00d      	beq.n	e2f6 <matrix_test+0x7d2>
    e2da:	2a06      	cmp	r2, #6
    e2dc:	d005      	beq.n	e2ea <matrix_test+0x7c6>
                C[i*N+j]+=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    e2de:	8835      	ldrh	r5, [r6, #0]
    e2e0:	f93b 1b02 	ldrsh.w	r1, [fp], #2
    e2e4:	4426      	add	r6, r4
    e2e6:	fb11 3305 	smlabb	r3, r1, r5, r3
    e2ea:	8832      	ldrh	r2, [r6, #0]
    e2ec:	f93b 0b02 	ldrsh.w	r0, [fp], #2
    e2f0:	4426      	add	r6, r4
    e2f2:	fb10 3302 	smlabb	r3, r0, r2, r3
    e2f6:	8835      	ldrh	r5, [r6, #0]
    e2f8:	f93b 1b02 	ldrsh.w	r1, [fp], #2
    e2fc:	4426      	add	r6, r4
    e2fe:	fb11 3305 	smlabb	r3, r1, r5, r3
    e302:	8832      	ldrh	r2, [r6, #0]
    e304:	f93b 0b02 	ldrsh.w	r0, [fp], #2
    e308:	4426      	add	r6, r4
    e30a:	fb10 3302 	smlabb	r3, r0, r2, r3
    e30e:	8835      	ldrh	r5, [r6, #0]
    e310:	f93b 1b02 	ldrsh.w	r1, [fp], #2
    e314:	4426      	add	r6, r4
    e316:	fb11 3305 	smlabb	r3, r1, r5, r3
    e31a:	8832      	ldrh	r2, [r6, #0]
    e31c:	f93b 0b02 	ldrsh.w	r0, [fp], #2
    e320:	4426      	add	r6, r4
    e322:	fb10 3302 	smlabb	r3, r0, r2, r3
    e326:	f93b 1b02 	ldrsh.w	r1, [fp], #2
    e32a:	8835      	ldrh	r5, [r6, #0]
            for(k=0;k<N;k++)
    e32c:	45de      	cmp	lr, fp
    e32e:	4426      	add	r6, r4
                C[i*N+j]+=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    e330:	fb11 3305 	smlabb	r3, r1, r5, r3
            for(k=0;k<N;k++)
    e334:	d03c      	beq.n	e3b0 <matrix_test+0x88c>
    e336:	9701      	str	r7, [sp, #4]
                C[i*N+j]+=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    e338:	465f      	mov	r7, fp
    e33a:	f9bb 0002 	ldrsh.w	r0, [fp, #2]
    e33e:	f937 5b02 	ldrsh.w	r5, [r7], #2
    e342:	5b31      	ldrh	r1, [r6, r4]
    e344:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
    e348:	8837      	ldrh	r7, [r6, #0]
    e34a:	fb15 3307 	smlabb	r3, r5, r7, r3
    e34e:	1935      	adds	r5, r6, r4
    e350:	fb10 3701 	smlabb	r7, r0, r1, r3
    e354:	f836 6014 	ldrh.w	r6, [r6, r4, lsl #1]
    e358:	f9bb 1006 	ldrsh.w	r1, [fp, #6]
    e35c:	1928      	adds	r0, r5, r4
    e35e:	f835 5014 	ldrh.w	r5, [r5, r4, lsl #1]
    e362:	fb12 7306 	smlabb	r3, r2, r6, r7
    e366:	f9bb 6008 	ldrsh.w	r6, [fp, #8]
    e36a:	f830 7014 	ldrh.w	r7, [r0, r4, lsl #1]
    e36e:	1902      	adds	r2, r0, r4
    e370:	fb11 3005 	smlabb	r0, r1, r5, r3
    e374:	1911      	adds	r1, r2, r4
    e376:	fb16 0307 	smlabb	r3, r6, r7, r0
    e37a:	f9bb 500a 	ldrsh.w	r5, [fp, #10]
    e37e:	f832 2014 	ldrh.w	r2, [r2, r4, lsl #1]
    e382:	f831 6014 	ldrh.w	r6, [r1, r4, lsl #1]
    e386:	f9bb 000c 	ldrsh.w	r0, [fp, #12]
    e38a:	190f      	adds	r7, r1, r4
    e38c:	f10b 0b10 	add.w	fp, fp, #16
    e390:	fb15 3102 	smlabb	r1, r5, r2, r3
    e394:	f93b 5c02 	ldrsh.w	r5, [fp, #-2]
    e398:	f837 2014 	ldrh.w	r2, [r7, r4, lsl #1]
    e39c:	fb10 1306 	smlabb	r3, r0, r6, r1
            for(k=0;k<N;k++)
    e3a0:	45de      	cmp	lr, fp
    e3a2:	eb07 0644 	add.w	r6, r7, r4, lsl #1
    e3a6:	4426      	add	r6, r4
                C[i*N+j]+=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    e3a8:	fb15 3302 	smlabb	r3, r5, r2, r3
            for(k=0;k<N;k++)
    e3ac:	d1c4      	bne.n	e338 <matrix_test+0x814>
    e3ae:	9f01      	ldr	r7, [sp, #4]
    e3b0:	f848 3b04 	str.w	r3, [r8], #4
    e3b4:	3702      	adds	r7, #2
        for (j=0; j<N; j++) {
    e3b6:	45b9      	cmp	r9, r7
    e3b8:	f47f af75 	bne.w	e2a6 <matrix_test+0x782>
    for (i=0; i<N; i++) {
    e3bc:	9e04      	ldr	r6, [sp, #16]
    e3be:	9905      	ldr	r1, [sp, #20]
    e3c0:	9802      	ldr	r0, [sp, #8]
    e3c2:	3601      	adds	r6, #1
    e3c4:	42b1      	cmp	r1, r6
    e3c6:	9604      	str	r6, [sp, #16]
    e3c8:	4482      	add	sl, r0
    e3ca:	46f4      	mov	ip, lr
    e3cc:	f47f af67 	bne.w	e29e <matrix_test+0x77a>
    e3d0:	f04f 0800 	mov.w	r8, #0
    e3d4:	9e09      	ldr	r6, [sp, #36]	; 0x24
    e3d6:	f8dd 901c 	ldr.w	r9, [sp, #28]
    e3da:	f8dd b020 	ldr.w	fp, [sp, #32]
    e3de:	f8dd a008 	ldr.w	sl, [sp, #8]
    e3e2:	9601      	str	r6, [sp, #4]
    e3e4:	4645      	mov	r5, r8
    e3e6:	4640      	mov	r0, r8
    e3e8:	46c4      	mov	ip, r8
    e3ea:	eb0a 0e06 	add.w	lr, sl, r6
            cur=C[i*N+j];
    e3ee:	f856 2b04 	ldr.w	r2, [r6], #4
                ret+=10;
    e3f2:	b283      	uxth	r3, r0
            tmp+=cur;
    e3f4:	4494      	add	ip, r2
                ret+=10;
    e3f6:	f103 070a 	add.w	r7, r3, #10
                ret += (cur>prev) ? 1 : 0;
    e3fa:	42aa      	cmp	r2, r5
    e3fc:	bfc8      	it	gt
    e3fe:	3301      	addgt	r3, #1
    e400:	45cc      	cmp	ip, r9
                ret+=10;
    e402:	b23d      	sxth	r5, r7
                ret += (cur>prev) ? 1 : 0;
    e404:	b218      	sxth	r0, r3
    e406:	f1aa 0104 	sub.w	r1, sl, #4
    e40a:	bfc4      	itt	gt
    e40c:	4628      	movgt	r0, r5
    e40e:	f04f 0c00 	movgt.w	ip, #0
        for (j=0; j<N; j++) {
    e412:	4576      	cmp	r6, lr
            cur=C[i*N+j];
    e414:	4615      	mov	r5, r2
    e416:	f3c1 0281 	ubfx	r2, r1, #2, #2
        for (j=0; j<N; j++) {
    e41a:	f000 8086 	beq.w	e52a <matrix_test+0xa06>
    e41e:	2a00      	cmp	r2, #0
    e420:	d038      	beq.n	e494 <matrix_test+0x970>
    e422:	2a01      	cmp	r2, #1
    e424:	d023      	beq.n	e46e <matrix_test+0x94a>
    e426:	2a02      	cmp	r2, #2
    e428:	d010      	beq.n	e44c <matrix_test+0x928>
            cur=C[i*N+j];
    e42a:	f856 3b04 	ldr.w	r3, [r6], #4
                ret+=10;
    e42e:	b280      	uxth	r0, r0
    e430:	f100 070a 	add.w	r7, r0, #10
            tmp+=cur;
    e434:	449c      	add	ip, r3
                ret += (cur>prev) ? 1 : 0;
    e436:	42ab      	cmp	r3, r5
    e438:	bfc8      	it	gt
    e43a:	3001      	addgt	r0, #1
                ret+=10;
    e43c:	b23d      	sxth	r5, r7
    e43e:	45cc      	cmp	ip, r9
                ret += (cur>prev) ? 1 : 0;
    e440:	b200      	sxth	r0, r0
    e442:	bfc4      	itt	gt
    e444:	f04f 0c00 	movgt.w	ip, #0
    e448:	4628      	movgt	r0, r5
            cur=C[i*N+j];
    e44a:	461d      	mov	r5, r3
    e44c:	f856 1b04 	ldr.w	r1, [r6], #4
                ret+=10;
    e450:	b283      	uxth	r3, r0
    e452:	f103 020a 	add.w	r2, r3, #10
            tmp+=cur;
    e456:	448c      	add	ip, r1
                ret += (cur>prev) ? 1 : 0;
    e458:	42a9      	cmp	r1, r5
    e45a:	bfc8      	it	gt
    e45c:	3301      	addgt	r3, #1
                ret+=10;
    e45e:	b217      	sxth	r7, r2
    e460:	45cc      	cmp	ip, r9
                ret += (cur>prev) ? 1 : 0;
    e462:	b218      	sxth	r0, r3
    e464:	bfc4      	itt	gt
    e466:	f04f 0c00 	movgt.w	ip, #0
    e46a:	4638      	movgt	r0, r7
            cur=C[i*N+j];
    e46c:	460d      	mov	r5, r1
    e46e:	f856 1b04 	ldr.w	r1, [r6], #4
                ret+=10;
    e472:	b280      	uxth	r0, r0
    e474:	f100 030a 	add.w	r3, r0, #10
            tmp+=cur;
    e478:	448c      	add	ip, r1
                ret += (cur>prev) ? 1 : 0;
    e47a:	42a9      	cmp	r1, r5
    e47c:	bfc8      	it	gt
    e47e:	3001      	addgt	r0, #1
    e480:	45cc      	cmp	ip, r9
                ret+=10;
    e482:	b21d      	sxth	r5, r3
                ret += (cur>prev) ? 1 : 0;
    e484:	b200      	sxth	r0, r0
    e486:	bfc4      	itt	gt
    e488:	f04f 0c00 	movgt.w	ip, #0
    e48c:	4628      	movgt	r0, r5
        for (j=0; j<N; j++) {
    e48e:	4576      	cmp	r6, lr
            cur=C[i*N+j];
    e490:	460d      	mov	r5, r1
        for (j=0; j<N; j++) {
    e492:	d04a      	beq.n	e52a <matrix_test+0xa06>
    e494:	4662      	mov	r2, ip
            cur=C[i*N+j];
    e496:	4637      	mov	r7, r6
                ret+=10;
    e498:	b280      	uxth	r0, r0
            cur=C[i*N+j];
    e49a:	f857 cb04 	ldr.w	ip, [r7], #4
    e49e:	6873      	ldr	r3, [r6, #4]
    e4a0:	687f      	ldr	r7, [r7, #4]
    e4a2:	68f1      	ldr	r1, [r6, #12]
            tmp+=cur;
    e4a4:	4462      	add	r2, ip
                ret += (cur>prev) ? 1 : 0;
    e4a6:	45ac      	cmp	ip, r5
    e4a8:	bfd4      	ite	le
    e4aa:	4605      	movle	r5, r0
    e4ac:	1c45      	addgt	r5, r0, #1
    e4ae:	b22d      	sxth	r5, r5
    e4b0:	454a      	cmp	r2, r9
                ret+=10;
    e4b2:	f100 000a 	add.w	r0, r0, #10
    e4b6:	b200      	sxth	r0, r0
    e4b8:	bfd6      	itet	le
    e4ba:	4628      	movle	r0, r5
    e4bc:	2500      	movgt	r5, #0
    e4be:	4615      	movle	r5, r2
    e4c0:	b282      	uxth	r2, r0
            tmp+=cur;
    e4c2:	441d      	add	r5, r3
                ret+=10;
    e4c4:	f102 000a 	add.w	r0, r2, #10
                ret += (cur>prev) ? 1 : 0;
    e4c8:	4563      	cmp	r3, ip
    e4ca:	bfc8      	it	gt
    e4cc:	3201      	addgt	r2, #1
    e4ce:	b212      	sxth	r2, r2
    e4d0:	454d      	cmp	r5, r9
                ret+=10;
    e4d2:	fa0f fc80 	sxth.w	ip, r0
    e4d6:	bfd4      	ite	le
    e4d8:	4694      	movle	ip, r2
    e4da:	2500      	movgt	r5, #0
    e4dc:	fa1f f08c 	uxth.w	r0, ip
    e4e0:	f100 0c0a 	add.w	ip, r0, #10
                ret += (cur>prev) ? 1 : 0;
    e4e4:	429f      	cmp	r7, r3
    e4e6:	bfc8      	it	gt
    e4e8:	3001      	addgt	r0, #1
            tmp+=cur;
    e4ea:	197b      	adds	r3, r7, r5
    e4ec:	454b      	cmp	r3, r9
                ret += (cur>prev) ? 1 : 0;
    e4ee:	b205      	sxth	r5, r0
                ret+=10;
    e4f0:	fa0f f28c 	sxth.w	r2, ip
    e4f4:	bfd8      	it	le
    e4f6:	462a      	movle	r2, r5
    e4f8:	fa1f fc82 	uxth.w	ip, r2
    e4fc:	bfc8      	it	gt
    e4fe:	2300      	movgt	r3, #0
    e500:	f10c 000a 	add.w	r0, ip, #10
            tmp+=cur;
    e504:	440b      	add	r3, r1
                ret += (cur>prev) ? 1 : 0;
    e506:	42b9      	cmp	r1, r7
    e508:	bfc8      	it	gt
    e50a:	f10c 0c01 	addgt.w	ip, ip, #1
    e50e:	fa0f f28c 	sxth.w	r2, ip
    e512:	454b      	cmp	r3, r9
    e514:	f106 0610 	add.w	r6, r6, #16
                ret+=10;
    e518:	b200      	sxth	r0, r0
    e51a:	bfce      	itee	gt
    e51c:	2200      	movgt	r2, #0
    e51e:	4610      	movle	r0, r2
    e520:	461a      	movle	r2, r3
        for (j=0; j<N; j++) {
    e522:	4576      	cmp	r6, lr
            cur=C[i*N+j];
    e524:	460d      	mov	r5, r1
        for (j=0; j<N; j++) {
    e526:	d1b6      	bne.n	e496 <matrix_test+0x972>
    e528:	4694      	mov	ip, r2
    for (i=0; i<N; i++) {
    e52a:	f108 0801 	add.w	r8, r8, #1
    e52e:	45c3      	cmp	fp, r8
    e530:	f47f af5b 	bne.w	e3ea <matrix_test+0x8c6>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    e534:	9906      	ldr	r1, [sp, #24]
    e536:	f8cd 8014 	str.w	r8, [sp, #20]
    e53a:	f001 f86b 	bl	f614 <crc16>
    e53e:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
    e540:	9f03      	ldr	r7, [sp, #12]
    e542:	f8cd 901c 	str.w	r9, [sp, #28]
    e546:	2100      	movs	r1, #0
    e548:	9006      	str	r0, [sp, #24]
    e54a:	eb07 0b04 	add.w	fp, r7, r4
    e54e:	9104      	str	r1, [sp, #16]
    e550:	46b1      	mov	r9, r6
    e552:	f8dd 800c 	ldr.w	r8, [sp, #12]
    e556:	f8dd a004 	ldr.w	sl, [sp, #4]
    e55a:	eb04 0c09 	add.w	ip, r4, r9
    for (i=0; i<N; i++) {
        for (j=0; j<N; j++) {
            C[i*N+j]=0;
            for(k=0;k<N;k++)
            {
                MATRES tmp=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    e55e:	464f      	mov	r7, r9
    e560:	f8b8 e000 	ldrh.w	lr, [r8]
    e564:	f937 3b02 	ldrsh.w	r3, [r7], #2
    e568:	ebac 0509 	sub.w	r5, ip, r9
    e56c:	fb1e f003 	smulbb	r0, lr, r3
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    e570:	f3c0 0683 	ubfx	r6, r0, #2, #4
    e574:	f3c0 1346 	ubfx	r3, r0, #5, #7
    e578:	1eaa      	subs	r2, r5, #2
            for(k=0;k<N;k++)
    e57a:	45bc      	cmp	ip, r7
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    e57c:	fb03 f306 	mul.w	r3, r3, r6
    e580:	f3c2 0141 	ubfx	r1, r2, #1, #2
    e584:	eb08 0604 	add.w	r6, r8, r4
            for(k=0;k<N;k++)
    e588:	d060      	beq.n	e64c <matrix_test+0xb28>
    e58a:	b349      	cbz	r1, e5e0 <matrix_test+0xabc>
    e58c:	2901      	cmp	r1, #1
    e58e:	d019      	beq.n	e5c4 <matrix_test+0xaa0>
    e590:	2902      	cmp	r1, #2
    e592:	d00b      	beq.n	e5ac <matrix_test+0xa88>
                MATRES tmp=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    e594:	8830      	ldrh	r0, [r6, #0]
    e596:	f937 5b02 	ldrsh.w	r5, [r7], #2
    e59a:	fb10 fe05 	smulbb	lr, r0, r5
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    e59e:	f3ce 0183 	ubfx	r1, lr, #2, #4
    e5a2:	f3ce 1246 	ubfx	r2, lr, #5, #7
    e5a6:	4426      	add	r6, r4
    e5a8:	fb02 3301 	mla	r3, r2, r1, r3
                MATRES tmp=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    e5ac:	8830      	ldrh	r0, [r6, #0]
    e5ae:	f937 5b02 	ldrsh.w	r5, [r7], #2
    e5b2:	fb10 fe05 	smulbb	lr, r0, r5
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    e5b6:	f3ce 0183 	ubfx	r1, lr, #2, #4
    e5ba:	f3ce 1246 	ubfx	r2, lr, #5, #7
    e5be:	4426      	add	r6, r4
    e5c0:	fb02 3301 	mla	r3, r2, r1, r3
                MATRES tmp=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    e5c4:	f937 5b02 	ldrsh.w	r5, [r7], #2
    e5c8:	8830      	ldrh	r0, [r6, #0]
    e5ca:	fb10 fe05 	smulbb	lr, r0, r5
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    e5ce:	f3ce 0183 	ubfx	r1, lr, #2, #4
    e5d2:	f3ce 1246 	ubfx	r2, lr, #5, #7
            for(k=0;k<N;k++)
    e5d6:	45bc      	cmp	ip, r7
    e5d8:	4426      	add	r6, r4
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    e5da:	fb02 3301 	mla	r3, r2, r1, r3
            for(k=0;k<N;k++)
    e5de:	d035      	beq.n	e64c <matrix_test+0xb28>
                MATRES tmp=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    e5e0:	463d      	mov	r5, r7
    e5e2:	8830      	ldrh	r0, [r6, #0]
    e5e4:	f935 2b02 	ldrsh.w	r2, [r5], #2
    e5e8:	f9b7 e002 	ldrsh.w	lr, [r7, #2]
    e5ec:	f9b5 5002 	ldrsh.w	r5, [r5, #2]
    e5f0:	5b31      	ldrh	r1, [r6, r4]
    e5f2:	fb10 f002 	smulbb	r0, r0, r2
    e5f6:	f836 2014 	ldrh.w	r2, [r6, r4, lsl #1]
    e5fa:	fb11 f10e 	smulbb	r1, r1, lr
    e5fe:	fb12 f205 	smulbb	r2, r2, r5
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    e602:	f3c0 1e46 	ubfx	lr, r0, #5, #7
    e606:	f3c0 0583 	ubfx	r5, r0, #2, #4
    e60a:	4426      	add	r6, r4
    e60c:	fb0e 3305 	mla	r3, lr, r5, r3
    e610:	f3c1 0583 	ubfx	r5, r1, #2, #4
    e614:	f3c1 1146 	ubfx	r1, r1, #5, #7
                MATRES tmp=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    e618:	f9b7 0006 	ldrsh.w	r0, [r7, #6]
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    e61c:	fb01 3505 	mla	r5, r1, r5, r3
                MATRES tmp=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    e620:	f836 3014 	ldrh.w	r3, [r6, r4, lsl #1]
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    e624:	f3c2 0e83 	ubfx	lr, r2, #2, #4
                MATRES tmp=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    e628:	fb13 f000 	smulbb	r0, r3, r0
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    e62c:	f3c2 1246 	ubfx	r2, r2, #5, #7
    e630:	3708      	adds	r7, #8
    e632:	fb02 550e 	mla	r5, r2, lr, r5
    e636:	eb06 0644 	add.w	r6, r6, r4, lsl #1
    e63a:	f3c0 0283 	ubfx	r2, r0, #2, #4
    e63e:	f3c0 1146 	ubfx	r1, r0, #5, #7
            for(k=0;k<N;k++)
    e642:	45bc      	cmp	ip, r7
    e644:	4426      	add	r6, r4
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    e646:	fb01 5302 	mla	r3, r1, r2, r5
            for(k=0;k<N;k++)
    e64a:	d1c9      	bne.n	e5e0 <matrix_test+0xabc>
    e64c:	f108 0802 	add.w	r8, r8, #2
        for (j=0; j<N; j++) {
    e650:	45c3      	cmp	fp, r8
    e652:	f84a 3b04 	str.w	r3, [sl], #4
    e656:	d182      	bne.n	e55e <matrix_test+0xa3a>
    for (i=0; i<N; i++) {
    e658:	9f04      	ldr	r7, [sp, #16]
    e65a:	9e01      	ldr	r6, [sp, #4]
    e65c:	9d02      	ldr	r5, [sp, #8]
    e65e:	9b05      	ldr	r3, [sp, #20]
    e660:	3701      	adds	r7, #1
    e662:	442e      	add	r6, r5
    e664:	42bb      	cmp	r3, r7
    e666:	9704      	str	r7, [sp, #16]
    e668:	9601      	str	r6, [sp, #4]
    e66a:	46e1      	mov	r9, ip
    e66c:	f47f af71 	bne.w	e552 <matrix_test+0xa2e>
    e670:	f04f 0e00 	mov.w	lr, #0
    e674:	f8dd 901c 	ldr.w	r9, [sp, #28]
    e678:	9f09      	ldr	r7, [sp, #36]	; 0x24
    e67a:	f8dd 8020 	ldr.w	r8, [sp, #32]
    e67e:	4676      	mov	r6, lr
    e680:	4670      	mov	r0, lr
    e682:	46f2      	mov	sl, lr
    e684:	46ac      	mov	ip, r5
            cur=C[i*N+j];
    e686:	463c      	mov	r4, r7
                ret+=10;
    e688:	b280      	uxth	r0, r0
            cur=C[i*N+j];
    e68a:	f854 2b04 	ldr.w	r2, [r4], #4
                ret += (cur>prev) ? 1 : 0;
    e68e:	4552      	cmp	r2, sl
    e690:	bfd4      	ite	le
    e692:	4601      	movle	r1, r0
    e694:	1c41      	addgt	r1, r0, #1
            tmp+=cur;
    e696:	4416      	add	r6, r2
    e698:	454e      	cmp	r6, r9
                ret += (cur>prev) ? 1 : 0;
    e69a:	fa0f fa81 	sxth.w	sl, r1
                ret+=10;
    e69e:	f100 000a 	add.w	r0, r0, #10
    e6a2:	4467      	add	r7, ip
    e6a4:	b200      	sxth	r0, r0
    e6a6:	f1ac 0504 	sub.w	r5, ip, #4
    e6aa:	bfd4      	ite	le
    e6ac:	4650      	movle	r0, sl
    e6ae:	2600      	movgt	r6, #0
        for (j=0; j<N; j++) {
    e6b0:	42a7      	cmp	r7, r4
            cur=C[i*N+j];
    e6b2:	4692      	mov	sl, r2
    e6b4:	f3c5 0381 	ubfx	r3, r5, #2, #2
        for (j=0; j<N; j++) {
    e6b8:	f000 808b 	beq.w	e7d2 <matrix_test+0xcae>
    e6bc:	2b00      	cmp	r3, #0
    e6be:	d03c      	beq.n	e73a <matrix_test+0xc16>
    e6c0:	2b01      	cmp	r3, #1
    e6c2:	d025      	beq.n	e710 <matrix_test+0xbec>
    e6c4:	2b02      	cmp	r3, #2
    e6c6:	d012      	beq.n	e6ee <matrix_test+0xbca>
            cur=C[i*N+j];
    e6c8:	f854 1b04 	ldr.w	r1, [r4], #4
                ret+=10;
    e6cc:	fa1f fb80 	uxth.w	fp, r0
    e6d0:	f10b 000a 	add.w	r0, fp, #10
            tmp+=cur;
    e6d4:	440e      	add	r6, r1
                ret += (cur>prev) ? 1 : 0;
    e6d6:	4291      	cmp	r1, r2
    e6d8:	bfc8      	it	gt
    e6da:	f10b 0b01 	addgt.w	fp, fp, #1
                ret+=10;
    e6de:	b202      	sxth	r2, r0
    e6e0:	454e      	cmp	r6, r9
                ret += (cur>prev) ? 1 : 0;
    e6e2:	fa0f f08b 	sxth.w	r0, fp
    e6e6:	bfc4      	itt	gt
    e6e8:	2600      	movgt	r6, #0
    e6ea:	4610      	movgt	r0, r2
            cur=C[i*N+j];
    e6ec:	468a      	mov	sl, r1
    e6ee:	f854 5b04 	ldr.w	r5, [r4], #4
                ret+=10;
    e6f2:	b283      	uxth	r3, r0
    e6f4:	f103 010a 	add.w	r1, r3, #10
            tmp+=cur;
    e6f8:	442e      	add	r6, r5
                ret += (cur>prev) ? 1 : 0;
    e6fa:	4555      	cmp	r5, sl
    e6fc:	bfc8      	it	gt
    e6fe:	3301      	addgt	r3, #1
                ret+=10;
    e700:	fa0f fa81 	sxth.w	sl, r1
    e704:	454e      	cmp	r6, r9
                ret += (cur>prev) ? 1 : 0;
    e706:	b218      	sxth	r0, r3
    e708:	bfc4      	itt	gt
    e70a:	2600      	movgt	r6, #0
    e70c:	4650      	movgt	r0, sl
            cur=C[i*N+j];
    e70e:	46aa      	mov	sl, r5
    e710:	f854 5b04 	ldr.w	r5, [r4], #4
                ret+=10;
    e714:	fa1f fb80 	uxth.w	fp, r0
    e718:	f10b 000a 	add.w	r0, fp, #10
            tmp+=cur;
    e71c:	442e      	add	r6, r5
                ret += (cur>prev) ? 1 : 0;
    e71e:	4555      	cmp	r5, sl
    e720:	bfc8      	it	gt
    e722:	f10b 0b01 	addgt.w	fp, fp, #1
                ret+=10;
    e726:	b202      	sxth	r2, r0
    e728:	454e      	cmp	r6, r9
                ret += (cur>prev) ? 1 : 0;
    e72a:	fa0f f08b 	sxth.w	r0, fp
    e72e:	bfc4      	itt	gt
    e730:	2600      	movgt	r6, #0
    e732:	4610      	movgt	r0, r2
        for (j=0; j<N; j++) {
    e734:	42a7      	cmp	r7, r4
            cur=C[i*N+j];
    e736:	46aa      	mov	sl, r5
        for (j=0; j<N; j++) {
    e738:	d04b      	beq.n	e7d2 <matrix_test+0xcae>
            cur=C[i*N+j];
    e73a:	4621      	mov	r1, r4
                ret+=10;
    e73c:	b283      	uxth	r3, r0
            cur=C[i*N+j];
    e73e:	f851 5b04 	ldr.w	r5, [r1], #4
    e742:	6860      	ldr	r0, [r4, #4]
    e744:	6849      	ldr	r1, [r1, #4]
    e746:	68e2      	ldr	r2, [r4, #12]
                ret += (cur>prev) ? 1 : 0;
    e748:	4555      	cmp	r5, sl
    e74a:	bfd4      	ite	le
    e74c:	469b      	movle	fp, r3
    e74e:	f103 0b01 	addgt.w	fp, r3, #1
            tmp+=cur;
    e752:	442e      	add	r6, r5
    e754:	454e      	cmp	r6, r9
                ret += (cur>prev) ? 1 : 0;
    e756:	fa0f fa8b 	sxth.w	sl, fp
                ret+=10;
    e75a:	f103 030a 	add.w	r3, r3, #10
    e75e:	b21b      	sxth	r3, r3
    e760:	bfd4      	ite	le
    e762:	4653      	movle	r3, sl
    e764:	2600      	movgt	r6, #0
    e766:	fa1f fb83 	uxth.w	fp, r3
            tmp+=cur;
    e76a:	4406      	add	r6, r0
                ret+=10;
    e76c:	f10b 030a 	add.w	r3, fp, #10
                ret += (cur>prev) ? 1 : 0;
    e770:	42a8      	cmp	r0, r5
    e772:	bfc8      	it	gt
    e774:	f10b 0b01 	addgt.w	fp, fp, #1
    e778:	454e      	cmp	r6, r9
                ret+=10;
    e77a:	b21d      	sxth	r5, r3
                ret += (cur>prev) ? 1 : 0;
    e77c:	fa0f fa8b 	sxth.w	sl, fp
    e780:	bfc4      	itt	gt
    e782:	46aa      	movgt	sl, r5
    e784:	2600      	movgt	r6, #0
                ret+=10;
    e786:	fa1f fb8a 	uxth.w	fp, sl
                ret += (cur>prev) ? 1 : 0;
    e78a:	4281      	cmp	r1, r0
    e78c:	bfd4      	ite	le
    e78e:	4658      	movle	r0, fp
    e790:	f10b 0001 	addgt.w	r0, fp, #1
            tmp+=cur;
    e794:	198b      	adds	r3, r1, r6
    e796:	454b      	cmp	r3, r9
                ret += (cur>prev) ? 1 : 0;
    e798:	fa0f fa80 	sxth.w	sl, r0
                ret+=10;
    e79c:	f10b 050a 	add.w	r5, fp, #10
    e7a0:	fa0f fb85 	sxth.w	fp, r5
    e7a4:	bfda      	itte	le
    e7a6:	46d3      	movle	fp, sl
    e7a8:	461e      	movle	r6, r3
    e7aa:	2600      	movgt	r6, #0
    e7ac:	fa1f f58b 	uxth.w	r5, fp
    e7b0:	f105 000a 	add.w	r0, r5, #10
            tmp+=cur;
    e7b4:	4416      	add	r6, r2
                ret += (cur>prev) ? 1 : 0;
    e7b6:	428a      	cmp	r2, r1
    e7b8:	bfc8      	it	gt
    e7ba:	3501      	addgt	r5, #1
    e7bc:	3410      	adds	r4, #16
    e7be:	454e      	cmp	r6, r9
                ret+=10;
    e7c0:	b201      	sxth	r1, r0
    e7c2:	bfc8      	it	gt
    e7c4:	2600      	movgt	r6, #0
                ret += (cur>prev) ? 1 : 0;
    e7c6:	b228      	sxth	r0, r5
    e7c8:	bfc8      	it	gt
    e7ca:	4608      	movgt	r0, r1
        for (j=0; j<N; j++) {
    e7cc:	42a7      	cmp	r7, r4
            cur=C[i*N+j];
    e7ce:	4692      	mov	sl, r2
        for (j=0; j<N; j++) {
    e7d0:	d1b3      	bne.n	e73a <matrix_test+0xc16>
    for (i=0; i<N; i++) {
    e7d2:	f10e 0401 	add.w	r4, lr, #1
    e7d6:	45a0      	cmp	r8, r4
    e7d8:	d001      	beq.n	e7de <matrix_test+0xcba>
    e7da:	46a6      	mov	lr, r4
    e7dc:	e753      	b.n	e686 <matrix_test+0xb62>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    e7de:	9906      	ldr	r1, [sp, #24]
    e7e0:	f8cd e01c 	str.w	lr, [sp, #28]
    e7e4:	f000 ff16 	bl	f614 <crc16>
    e7e8:	9008      	str	r0, [sp, #32]
    e7ea:	980b      	ldr	r0, [sp, #44]	; 0x2c
    e7ec:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    matrix_add_const(N,A,-val); /* return matrix to initial value */
    e7ee:	f04f 0a00 	mov.w	sl, #0
    e7f2:	0066      	lsls	r6, r4, #1
    e7f4:	46d1      	mov	r9, sl
    e7f6:	9604      	str	r6, [sp, #16]
    e7f8:	4683      	mov	fp, r0
    e7fa:	e0da      	b.n	e9b2 <matrix_test+0xe8e>
            A[i*N+j] += val;
    e7fc:	f8bb 5000 	ldrh.w	r5, [fp]
    matrix_add_const(N,A,-val); /* return matrix to initial value */
    e800:	4621      	mov	r1, r4
            A[i*N+j] += val;
    e802:	1aae      	subs	r6, r5, r2
    e804:	2901      	cmp	r1, #1
    e806:	f8ab 6000 	strh.w	r6, [fp]
    e80a:	f000 80ea 	beq.w	e9e2 <matrix_test+0xebe>
    e80e:	f8bb 7002 	ldrh.w	r7, [fp, #2]
    e812:	2902      	cmp	r1, #2
    e814:	eba7 0302 	sub.w	r3, r7, r2
    e818:	f8ab 3002 	strh.w	r3, [fp, #2]
    e81c:	f000 80e1 	beq.w	e9e2 <matrix_test+0xebe>
    e820:	f8bb 5004 	ldrh.w	r5, [fp, #4]
    e824:	2903      	cmp	r1, #3
    e826:	eba5 0602 	sub.w	r6, r5, r2
    e82a:	f8ab 6004 	strh.w	r6, [fp, #4]
    e82e:	f000 80d8 	beq.w	e9e2 <matrix_test+0xebe>
    e832:	f8bb 7006 	ldrh.w	r7, [fp, #6]
    e836:	1abb      	subs	r3, r7, r2
    e838:	f8ab 3006 	strh.w	r3, [fp, #6]
        for (j=0; j<N; j++) {
    e83c:	2304      	movs	r3, #4
    e83e:	428c      	cmp	r4, r1
    e840:	f000 80b0 	beq.w	e9a4 <matrix_test+0xe80>
    e844:	1a65      	subs	r5, r4, r1
    e846:	1f2e      	subs	r6, r5, #4
    e848:	9503      	str	r5, [sp, #12]
    e84a:	08b5      	lsrs	r5, r6, #2
    e84c:	9e07      	ldr	r6, [sp, #28]
    e84e:	1c6f      	adds	r7, r5, #1
    e850:	1a76      	subs	r6, r6, r1
    e852:	9701      	str	r7, [sp, #4]
    e854:	2e02      	cmp	r6, #2
    e856:	ea4f 0787 	mov.w	r7, r7, lsl #2
    e85a:	9702      	str	r7, [sp, #8]
    e85c:	f240 8087 	bls.w	e96e <matrix_test+0xe4a>
    e860:	4451      	add	r1, sl
    e862:	eb00 0641 	add.w	r6, r0, r1, lsl #1
            A[i*N+j] += val;
    e866:	f850 e011 	ldr.w	lr, [r0, r1, lsl #1]
    e86a:	9105      	str	r1, [sp, #20]
    e86c:	ebae 0102 	sub.w	r1, lr, r2
    e870:	9106      	str	r1, [sp, #24]
    e872:	6871      	ldr	r1, [r6, #4]
    e874:	eba1 0802 	sub.w	r8, r1, r2
    e878:	9906      	ldr	r1, [sp, #24]
    e87a:	2700      	movs	r7, #0
    e87c:	46bc      	mov	ip, r7
    e87e:	ebc2 4e1e 	rsb	lr, r2, lr, lsr #16
    e882:	f361 070f 	bfi	r7, r1, #0, #16
    e886:	f36e 471f 	bfi	r7, lr, #16, #16
    e88a:	f005 0e01 	and.w	lr, r5, #1
    e88e:	9d05      	ldr	r5, [sp, #20]
    e890:	6871      	ldr	r1, [r6, #4]
    e892:	f840 7015 	str.w	r7, [r0, r5, lsl #1]
    e896:	9d01      	ldr	r5, [sp, #4]
    e898:	ebc2 4111 	rsb	r1, r2, r1, lsr #16
    e89c:	f368 0c0f 	bfi	ip, r8, #0, #16
    e8a0:	2701      	movs	r7, #1
    e8a2:	f361 4c1f 	bfi	ip, r1, #16, #16
    e8a6:	42bd      	cmp	r5, r7
    e8a8:	f106 0108 	add.w	r1, r6, #8
    e8ac:	f8c6 c004 	str.w	ip, [r6, #4]
    e8b0:	d958      	bls.n	e964 <matrix_test+0xe40>
    e8b2:	f1be 0f00 	cmp.w	lr, #0
    e8b6:	d01b      	beq.n	e8f0 <matrix_test+0xdcc>
    e8b8:	680f      	ldr	r7, [r1, #0]
    e8ba:	684e      	ldr	r6, [r1, #4]
    e8bc:	2500      	movs	r5, #0
    e8be:	eba7 0c02 	sub.w	ip, r7, r2
    e8c2:	46ae      	mov	lr, r5
    e8c4:	ebc2 4817 	rsb	r8, r2, r7, lsr #16
    e8c8:	1ab7      	subs	r7, r6, r2
    e8ca:	f367 0e0f 	bfi	lr, r7, #0, #16
    e8ce:	ebc2 4616 	rsb	r6, r2, r6, lsr #16
    e8d2:	f36c 050f 	bfi	r5, ip, #0, #16
    e8d6:	f368 451f 	bfi	r5, r8, #16, #16
    e8da:	f366 4e1f 	bfi	lr, r6, #16, #16
    e8de:	e881 4020 	stmia.w	r1, {r5, lr}
    e8e2:	9d01      	ldr	r5, [sp, #4]
    e8e4:	2702      	movs	r7, #2
    e8e6:	42bd      	cmp	r5, r7
    e8e8:	460e      	mov	r6, r1
    e8ea:	f101 0108 	add.w	r1, r1, #8
    e8ee:	d939      	bls.n	e964 <matrix_test+0xe40>
    e8f0:	9405      	str	r4, [sp, #20]
    e8f2:	9306      	str	r3, [sp, #24]
    e8f4:	68b5      	ldr	r5, [r6, #8]
    e8f6:	f106 0e08 	add.w	lr, r6, #8
    e8fa:	68f6      	ldr	r6, [r6, #12]
    e8fc:	2400      	movs	r4, #0
    e8fe:	1ab3      	subs	r3, r6, r2
    e900:	eba5 0802 	sub.w	r8, r5, r2
    e904:	46a4      	mov	ip, r4
    e906:	ebc2 4616 	rsb	r6, r2, r6, lsr #16
    e90a:	f363 0c0f 	bfi	ip, r3, #0, #16
    e90e:	f368 040f 	bfi	r4, r8, #0, #16
    e912:	ebc2 4515 	rsb	r5, r2, r5, lsr #16
    e916:	f366 4c1f 	bfi	ip, r6, #16, #16
    e91a:	f365 441f 	bfi	r4, r5, #16, #16
    e91e:	e881 1010 	stmia.w	r1, {r4, ip}
    e922:	f10e 0608 	add.w	r6, lr, #8
    e926:	f8de e008 	ldr.w	lr, [lr, #8]
    e92a:	6873      	ldr	r3, [r6, #4]
    e92c:	2400      	movs	r4, #0
    e92e:	ebae 0802 	sub.w	r8, lr, r2
    e932:	46a4      	mov	ip, r4
    e934:	ebc2 4e1e 	rsb	lr, r2, lr, lsr #16
    e938:	f368 040f 	bfi	r4, r8, #0, #16
    e93c:	f36e 441f 	bfi	r4, lr, #16, #16
    e940:	1a9d      	subs	r5, r3, r2
    e942:	608c      	str	r4, [r1, #8]
    e944:	9c01      	ldr	r4, [sp, #4]
    e946:	f365 0c0f 	bfi	ip, r5, #0, #16
    e94a:	ebc2 4313 	rsb	r3, r2, r3, lsr #16
    e94e:	3702      	adds	r7, #2
    e950:	f363 4c1f 	bfi	ip, r3, #16, #16
    e954:	42bc      	cmp	r4, r7
    e956:	f8c1 c00c 	str.w	ip, [r1, #12]
    e95a:	f101 0110 	add.w	r1, r1, #16
    e95e:	d8c9      	bhi.n	e8f4 <matrix_test+0xdd0>
    e960:	9c05      	ldr	r4, [sp, #20]
    e962:	9b06      	ldr	r3, [sp, #24]
    e964:	9902      	ldr	r1, [sp, #8]
    e966:	9e03      	ldr	r6, [sp, #12]
    e968:	42b1      	cmp	r1, r6
    e96a:	440b      	add	r3, r1
    e96c:	d01a      	beq.n	e9a4 <matrix_test+0xe80>
    e96e:	eb0a 0803 	add.w	r8, sl, r3
        for (j=0; j<N; j++) {
    e972:	1c59      	adds	r1, r3, #1
            A[i*N+j] += val;
    e974:	f830 5018 	ldrh.w	r5, [r0, r8, lsl #1]
        for (j=0; j<N; j++) {
    e978:	428c      	cmp	r4, r1
            A[i*N+j] += val;
    e97a:	eba5 0702 	sub.w	r7, r5, r2
    e97e:	f820 7018 	strh.w	r7, [r0, r8, lsl #1]
        for (j=0; j<N; j++) {
    e982:	d90f      	bls.n	e9a4 <matrix_test+0xe80>
            A[i*N+j] += val;
    e984:	4451      	add	r1, sl
        for (j=0; j<N; j++) {
    e986:	3302      	adds	r3, #2
            A[i*N+j] += val;
    e988:	f830 6011 	ldrh.w	r6, [r0, r1, lsl #1]
        for (j=0; j<N; j++) {
    e98c:	429c      	cmp	r4, r3
            A[i*N+j] += val;
    e98e:	eba6 0502 	sub.w	r5, r6, r2
    e992:	f820 5011 	strh.w	r5, [r0, r1, lsl #1]
        for (j=0; j<N; j++) {
    e996:	d905      	bls.n	e9a4 <matrix_test+0xe80>
            A[i*N+j] += val;
    e998:	4453      	add	r3, sl
    e99a:	f830 1013 	ldrh.w	r1, [r0, r3, lsl #1]
    e99e:	1a8f      	subs	r7, r1, r2
    e9a0:	f820 7013 	strh.w	r7, [r0, r3, lsl #1]
    for (i=0; i<N; i++) {
    e9a4:	f109 0901 	add.w	r9, r9, #1
    e9a8:	9b04      	ldr	r3, [sp, #16]
    e9aa:	45a1      	cmp	r9, r4
    e9ac:	449b      	add	fp, r3
    e9ae:	44a2      	add	sl, r4
    e9b0:	d02a      	beq.n	ea08 <matrix_test+0xee4>
    e9b2:	ea4f 075b 	mov.w	r7, fp, lsr #1
    e9b6:	427b      	negs	r3, r7
    e9b8:	f003 0303 	and.w	r3, r3, #3
    e9bc:	42a3      	cmp	r3, r4
    e9be:	bf28      	it	cs
    e9c0:	4623      	movcs	r3, r4
    e9c2:	2c04      	cmp	r4, #4
    e9c4:	f67f af1a 	bls.w	e7fc <matrix_test+0xcd8>
    matrix_add_const(N,A,-val); /* return matrix to initial value */
    e9c8:	4619      	mov	r1, r3
    e9ca:	2b00      	cmp	r3, #0
    e9cc:	f43f af3a 	beq.w	e844 <matrix_test+0xd20>
            A[i*N+j] += val;
    e9d0:	f8bb 5000 	ldrh.w	r5, [fp]
    e9d4:	2901      	cmp	r1, #1
    e9d6:	eba5 0602 	sub.w	r6, r5, r2
    e9da:	f8ab 6000 	strh.w	r6, [fp]
    e9de:	f47f af16 	bne.w	e80e <matrix_test+0xcea>
        for (j=0; j<N; j++) {
    e9e2:	460b      	mov	r3, r1
    e9e4:	e72b      	b.n	e83e <matrix_test+0xd1a>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    e9e6:	4601      	mov	r1, r0
    e9e8:	4604      	mov	r4, r0
    e9ea:	f000 fe13 	bl	f614 <crc16>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    e9ee:	4601      	mov	r1, r0
    e9f0:	4620      	mov	r0, r4
    e9f2:	f000 fe0f 	bl	f614 <crc16>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    e9f6:	4601      	mov	r1, r0
    e9f8:	4620      	mov	r0, r4
    e9fa:	f000 fe0b 	bl	f614 <crc16>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    e9fe:	4601      	mov	r1, r0
    ea00:	4620      	mov	r0, r4
    ea02:	f000 fe07 	bl	f614 <crc16>
    ea06:	9008      	str	r0, [sp, #32]
    return crc;
    ea08:	f9bd 0020 	ldrsh.w	r0, [sp, #32]
}
    ea0c:	b011      	add	sp, #68	; 0x44
    ea0e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ea12:	bf00      	nop

0000ea14 <core_bench_matrix>:
ee_u16 core_bench_matrix(mat_params *p, ee_s16 seed, ee_u16 crc) {
    ea14:	b530      	push	{r4, r5, lr}
    ea16:	4614      	mov	r4, r2
    crc=crc16(matrix_test(N,C,A,B,val),crc);
    ea18:	c82d      	ldmia	r0, {r0, r2, r3, r5}
ee_u16 core_bench_matrix(mat_params *p, ee_s16 seed, ee_u16 crc) {
    ea1a:	b083      	sub	sp, #12
    crc=crc16(matrix_test(N,C,A,B,val),crc);
    ea1c:	9100      	str	r1, [sp, #0]
    ea1e:	4629      	mov	r1, r5
    ea20:	f7ff f880 	bl	db24 <matrix_test>
    ea24:	4621      	mov	r1, r4
}
    ea26:	b003      	add	sp, #12
    ea28:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    crc=crc16(matrix_test(N,C,A,B,val),crc);
    ea2c:	f000 bdf2 	b.w	f614 <crc16>

0000ea30 <core_init_matrix>:
ee_u32 core_init_matrix(ee_u32 blksize, void *memblk, ee_s32 seed, mat_params *p) {
    ea30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ea34:	b087      	sub	sp, #28
        seed=1;
    ea36:	2a00      	cmp	r2, #0
    ea38:	bf08      	it	eq
    ea3a:	2201      	moveq	r2, #1
ee_u32 core_init_matrix(ee_u32 blksize, void *memblk, ee_s32 seed, mat_params *p) {
    ea3c:	9305      	str	r3, [sp, #20]
    while (j<blksize) {
    ea3e:	2800      	cmp	r0, #0
    ea40:	f000 810c 	beq.w	ec5c <core_init_matrix+0x22c>
    ea44:	4684      	mov	ip, r0
    ea46:	2000      	movs	r0, #0
    ea48:	e000      	b.n	ea4c <core_init_matrix+0x1c>
        i++;
    ea4a:	4630      	mov	r0, r6
    ea4c:	1c46      	adds	r6, r0, #1
        j=i*i*2*4;
    ea4e:	fb06 f706 	mul.w	r7, r6, r6
    while (j<blksize) {
    ea52:	ebbc 0fc7 	cmp.w	ip, r7, lsl #3
    ea56:	d8f8      	bhi.n	ea4a <core_init_matrix+0x1a>
    A=(MATDAT *)align_mem(memblk);
    ea58:	f101 38ff 	add.w	r8, r1, #4294967295
    ea5c:	f028 0403 	bic.w	r4, r8, #3
    ea60:	3404      	adds	r4, #4
    B=A+N*N;
    ea62:	fb00 f300 	mul.w	r3, r0, r0
    ea66:	0059      	lsls	r1, r3, #1
    ea68:	4627      	mov	r7, r4
    ea6a:	440f      	add	r7, r1
    A=(MATDAT *)align_mem(memblk);
    ea6c:	9401      	str	r4, [sp, #4]
    B=A+N*N;
    ea6e:	9103      	str	r1, [sp, #12]
    ea70:	9702      	str	r7, [sp, #8]
    ea72:	9004      	str	r0, [sp, #16]
    for (i=0; i<N; i++) {
    ea74:	2800      	cmp	r0, #0
    ea76:	f000 80de 	beq.w	ec36 <core_init_matrix+0x206>
    N=i-1;
    ea7a:	2400      	movs	r4, #0
    ea7c:	9400      	str	r4, [sp, #0]
    ea7e:	2601      	movs	r6, #1
            seed = ( ( order * seed ) % 65536 );
    ea80:	fb06 f202 	mul.w	r2, r6, r2
    ea84:	f1d2 0900 	rsbs	r9, r2, #0
    ea88:	fa1f f389 	uxth.w	r3, r9
    ea8c:	9f00      	ldr	r7, [sp, #0]
    ea8e:	9901      	ldr	r1, [sp, #4]
            val = (seed + order);
    ea90:	fa1f fa86 	uxth.w	sl, r6
            seed = ( ( order * seed ) % 65536 );
    ea94:	b292      	uxth	r2, r2
    ea96:	bf58      	it	pl
    ea98:	425a      	negpl	r2, r3
            val = (seed + order);
    ea9a:	eb0a 0502 	add.w	r5, sl, r2
    ea9e:	fb00 f707 	mul.w	r7, r0, r7
    eaa2:	9b02      	ldr	r3, [sp, #8]
    eaa4:	fa1f fe85 	uxth.w	lr, r5
    eaa8:	007c      	lsls	r4, r7, #1
    eaaa:	191d      	adds	r5, r3, r4
        for (j=0; j<N; j++) {
    eaac:	f04f 0b01 	mov.w	fp, #1
            B[i*N+j] = val;
    eab0:	f823 e017 	strh.w	lr, [r3, r7, lsl #1]
            val =  (val + order);
    eab4:	44f2      	add	sl, lr
            A[i*N+j] = val;
    eab6:	9b01      	ldr	r3, [sp, #4]
    eab8:	440c      	add	r4, r1
    eaba:	f100 38ff 	add.w	r8, r0, #4294967295
            val=matrix_clip(val,1);
    eabe:	fa5f fc8a 	uxtb.w	ip, sl
        for (j=0; j<N; j++) {
    eac2:	4583      	cmp	fp, r0
    eac4:	f008 0103 	and.w	r1, r8, #3
            order++;
    eac8:	445e      	add	r6, fp
            A[i*N+j] = val;
    eaca:	f823 c017 	strh.w	ip, [r3, r7, lsl #1]
    eace:	f105 0902 	add.w	r9, r5, #2
    ead2:	f104 0802 	add.w	r8, r4, #2
        for (j=0; j<N; j++) {
    ead6:	f080 80a7 	bcs.w	ec28 <core_init_matrix+0x1f8>
    eada:	2900      	cmp	r1, #0
    eadc:	d045      	beq.n	eb6a <core_init_matrix+0x13a>
    eade:	2901      	cmp	r1, #1
    eae0:	d02c      	beq.n	eb3c <core_init_matrix+0x10c>
    eae2:	2902      	cmp	r1, #2
    eae4:	d016      	beq.n	eb14 <core_init_matrix+0xe4>
            seed = ( ( order * seed ) % 65536 );
    eae6:	fb06 f202 	mul.w	r2, r6, r2
    eaea:	4257      	negs	r7, r2
    eaec:	b2b9      	uxth	r1, r7
            val = (seed + order);
    eaee:	b2b3      	uxth	r3, r6
            seed = ( ( order * seed ) % 65536 );
    eaf0:	b292      	uxth	r2, r2
    eaf2:	bf58      	it	pl
    eaf4:	424a      	negpl	r2, r1
            val = (seed + order);
    eaf6:	189f      	adds	r7, r3, r2
    eaf8:	fa1f fb87 	uxth.w	fp, r7
            val =  (val + order);
    eafc:	445b      	add	r3, fp
            val=matrix_clip(val,1);
    eafe:	b2d9      	uxtb	r1, r3
            B[i*N+j] = val;
    eb00:	f8a5 b002 	strh.w	fp, [r5, #2]
    eb04:	f109 0902 	add.w	r9, r9, #2
    eb08:	f108 0802 	add.w	r8, r8, #2
            order++;
    eb0c:	3601      	adds	r6, #1
        for (j=0; j<N; j++) {
    eb0e:	f04f 0b02 	mov.w	fp, #2
            A[i*N+j] = val;
    eb12:	8061      	strh	r1, [r4, #2]
            seed = ( ( order * seed ) % 65536 );
    eb14:	fb06 f202 	mul.w	r2, r6, r2
    eb18:	4254      	negs	r4, r2
    eb1a:	b2a5      	uxth	r5, r4
            val = (seed + order);
    eb1c:	b2b3      	uxth	r3, r6
            seed = ( ( order * seed ) % 65536 );
    eb1e:	b292      	uxth	r2, r2
    eb20:	bf58      	it	pl
    eb22:	426a      	negpl	r2, r5
            val = (seed + order);
    eb24:	189f      	adds	r7, r3, r2
    eb26:	fa1f fa87 	uxth.w	sl, r7
            val =  (val + order);
    eb2a:	4453      	add	r3, sl
            val=matrix_clip(val,1);
    eb2c:	b2d9      	uxtb	r1, r3
            B[i*N+j] = val;
    eb2e:	f829 ab02 	strh.w	sl, [r9], #2
            A[i*N+j] = val;
    eb32:	f828 1b02 	strh.w	r1, [r8], #2
        for (j=0; j<N; j++) {
    eb36:	f10b 0b01 	add.w	fp, fp, #1
            order++;
    eb3a:	3601      	adds	r6, #1
            seed = ( ( order * seed ) % 65536 );
    eb3c:	fb06 f202 	mul.w	r2, r6, r2
    eb40:	4254      	negs	r4, r2
    eb42:	b2a5      	uxth	r5, r4
            val = (seed + order);
    eb44:	b2b3      	uxth	r3, r6
            seed = ( ( order * seed ) % 65536 );
    eb46:	b292      	uxth	r2, r2
    eb48:	bf58      	it	pl
    eb4a:	426a      	negpl	r2, r5
            val = (seed + order);
    eb4c:	189f      	adds	r7, r3, r2
    eb4e:	fa1f fc87 	uxth.w	ip, r7
            val =  (val + order);
    eb52:	4463      	add	r3, ip
        for (j=0; j<N; j++) {
    eb54:	f10b 0b01 	add.w	fp, fp, #1
            val=matrix_clip(val,1);
    eb58:	b2d9      	uxtb	r1, r3
        for (j=0; j<N; j++) {
    eb5a:	4583      	cmp	fp, r0
            B[i*N+j] = val;
    eb5c:	f829 cb02 	strh.w	ip, [r9], #2
            order++;
    eb60:	f106 0601 	add.w	r6, r6, #1
            A[i*N+j] = val;
    eb64:	f828 1b02 	strh.w	r1, [r8], #2
        for (j=0; j<N; j++) {
    eb68:	d25e      	bcs.n	ec28 <core_init_matrix+0x1f8>
            seed = ( ( order * seed ) % 65536 );
    eb6a:	fb06 f202 	mul.w	r2, r6, r2
    eb6e:	4254      	negs	r4, r2
    eb70:	b2a5      	uxth	r5, r4
    eb72:	fa1f fe82 	uxth.w	lr, r2
            order++;
    eb76:	f106 0401 	add.w	r4, r6, #1
            seed = ( ( order * seed ) % 65536 );
    eb7a:	bf58      	it	pl
    eb7c:	f1c5 0e00 	rsbpl	lr, r5, #0
    eb80:	fb04 f20e 	mul.w	r2, r4, lr
    eb84:	f1d2 0a00 	rsbs	sl, r2, #0
    eb88:	fa1f f38a 	uxth.w	r3, sl
    eb8c:	b291      	uxth	r1, r2
            order++;
    eb8e:	f106 0702 	add.w	r7, r6, #2
            seed = ( ( order * seed ) % 65536 );
    eb92:	bf58      	it	pl
    eb94:	4259      	negpl	r1, r3
    eb96:	fb07 f501 	mul.w	r5, r7, r1
    eb9a:	f1d5 0c00 	rsbs	ip, r5, #0
    eb9e:	fa1f f28c 	uxth.w	r2, ip
    eba2:	b2ab      	uxth	r3, r5
    eba4:	bf58      	it	pl
    eba6:	4253      	negpl	r3, r2
            order++;
    eba8:	1cf5      	adds	r5, r6, #3
            seed = ( ( order * seed ) % 65536 );
    ebaa:	fb05 f203 	mul.w	r2, r5, r3
    ebae:	f1d2 0a00 	rsbs	sl, r2, #0
            val = (seed + order);
    ebb2:	fa1f fc86 	uxth.w	ip, r6
            seed = ( ( order * seed ) % 65536 );
    ebb6:	fa1f fa8a 	uxth.w	sl, sl
            val = (seed + order);
    ebba:	44e6      	add	lr, ip
            seed = ( ( order * seed ) % 65536 );
    ebbc:	b292      	uxth	r2, r2
    ebbe:	bf58      	it	pl
    ebc0:	f1ca 0200 	rsbpl	r2, sl, #0
            B[i*N+j] = val;
    ebc4:	46ca      	mov	sl, r9
            val = (seed + order);
    ebc6:	fa1f fe8e 	uxth.w	lr, lr
            B[i*N+j] = val;
    ebca:	f82a eb02 	strh.w	lr, [sl], #2
            val =  (val + order);
    ebce:	44f4      	add	ip, lr
            A[i*N+j] = val;
    ebd0:	46c6      	mov	lr, r8
            val = (seed + order);
    ebd2:	b2a4      	uxth	r4, r4
    ebd4:	b2bf      	uxth	r7, r7
    ebd6:	b2ad      	uxth	r5, r5
            val=matrix_clip(val,1);
    ebd8:	fa5f fc8c 	uxtb.w	ip, ip
            A[i*N+j] = val;
    ebdc:	f82e cb02 	strh.w	ip, [lr], #2
            val = (seed + order);
    ebe0:	4421      	add	r1, r4
    ebe2:	443b      	add	r3, r7
    ebe4:	eb05 0c02 	add.w	ip, r5, r2
    ebe8:	b289      	uxth	r1, r1
    ebea:	b29b      	uxth	r3, r3
    ebec:	fa1f fc8c 	uxth.w	ip, ip
            val =  (val + order);
    ebf0:	440c      	add	r4, r1
    ebf2:	441f      	add	r7, r3
    ebf4:	4465      	add	r5, ip
        for (j=0; j<N; j++) {
    ebf6:	f10b 0b04 	add.w	fp, fp, #4
            val=matrix_clip(val,1);
    ebfa:	b2e4      	uxtb	r4, r4
    ebfc:	b2ff      	uxtb	r7, r7
    ebfe:	b2ed      	uxtb	r5, r5
        for (j=0; j<N; j++) {
    ec00:	4583      	cmp	fp, r0
            B[i*N+j] = val;
    ec02:	f8a9 1002 	strh.w	r1, [r9, #2]
            order++;
    ec06:	f106 0604 	add.w	r6, r6, #4
            A[i*N+j] = val;
    ec0a:	f8a8 4002 	strh.w	r4, [r8, #2]
    ec0e:	f109 0908 	add.w	r9, r9, #8
            B[i*N+j] = val;
    ec12:	f8aa 3002 	strh.w	r3, [sl, #2]
    ec16:	f108 0808 	add.w	r8, r8, #8
            A[i*N+j] = val;
    ec1a:	f8ae 7002 	strh.w	r7, [lr, #2]
            B[i*N+j] = val;
    ec1e:	f829 cc02 	strh.w	ip, [r9, #-2]
            A[i*N+j] = val;
    ec22:	f828 5c02 	strh.w	r5, [r8, #-2]
        for (j=0; j<N; j++) {
    ec26:	d3a0      	bcc.n	eb6a <core_init_matrix+0x13a>
    for (i=0; i<N; i++) {
    ec28:	9900      	ldr	r1, [sp, #0]
    ec2a:	3101      	adds	r1, #1
    ec2c:	4281      	cmp	r1, r0
    ec2e:	9100      	str	r1, [sp, #0]
    ec30:	f4ff af26 	bcc.w	ea80 <core_init_matrix+0x50>
    ec34:	9903      	ldr	r1, [sp, #12]
    p->C=(MATRES *)align_mem(B+N*N);
    ec36:	9e02      	ldr	r6, [sp, #8]
    p->A=A;
    ec38:	9c01      	ldr	r4, [sp, #4]
    p->N=N;
    ec3a:	9d04      	ldr	r5, [sp, #16]
    p->C=(MATRES *)align_mem(B+N*N);
    ec3c:	4431      	add	r1, r6
    ec3e:	1e4a      	subs	r2, r1, #1
    ec40:	f022 0303 	bic.w	r3, r2, #3
    ec44:	9a05      	ldr	r2, [sp, #20]
    ec46:	4690      	mov	r8, r2
    p->B=B;
    ec48:	46c2      	mov	sl, r8
    p->C=(MATRES *)align_mem(B+N*N);
    ec4a:	3304      	adds	r3, #4
    ec4c:	60d3      	str	r3, [r2, #12]
    p->A=A;
    ec4e:	6054      	str	r4, [r2, #4]
    p->B=B;
    ec50:	f8ca 6008 	str.w	r6, [sl, #8]
    p->N=N;
    ec54:	6015      	str	r5, [r2, #0]
}
    ec56:	b007      	add	sp, #28
    ec58:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    A=(MATDAT *)align_mem(memblk);
    ec5c:	1e4b      	subs	r3, r1, #1
    ec5e:	f023 0403 	bic.w	r4, r3, #3
    ec62:	1d20      	adds	r0, r4, #4
    B=A+N*N;
    ec64:	f04f 31ff 	mov.w	r1, #4294967295
    ec68:	3406      	adds	r4, #6
    ec6a:	2502      	movs	r5, #2
    A=(MATDAT *)align_mem(memblk);
    ec6c:	9001      	str	r0, [sp, #4]
    B=A+N*N;
    ec6e:	9104      	str	r1, [sp, #16]
    ec70:	9402      	str	r4, [sp, #8]
    N=i-1;
    ec72:	4608      	mov	r0, r1
    B=A+N*N;
    ec74:	9503      	str	r5, [sp, #12]
    ec76:	e700      	b.n	ea7a <core_init_matrix+0x4a>

0000ec78 <start_time>:
    This function will be called right before starting the timed portion of the benchmark.

    Implementation may be capturing a system timer (as implemented in the example code)
    or zeroing some system parameters - e.g. setting the cpu clocks cycles to 0.
*/
void start_time(void) {
    ec78:	b538      	push	{r3, r4, r5, lr}
    am_hal_systick_load(0x00FFFFFF);
    ec7a:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
    ec7e:	f002 fe3f 	bl	11900 <am_hal_systick_load>
    am_hal_systick_int_enable();
    ec82:	f002 fe35 	bl	118f0 <am_hal_systick_int_enable>
    am_hal_systick_start();
    ec86:	f002 fe23 	bl	118d0 <am_hal_systick_start>
    start_time_val = 0; // GETMYTIME could be used - but there should be very small change anyways, as we just started
    ec8a:	4904      	ldr	r1, [pc, #16]	; (ec9c <start_time+0x24>)
    START_PA_DUMP = 0x1;
    ec8c:	4b04      	ldr	r3, [pc, #16]	; (eca0 <start_time+0x28>)
    start_time_val = 0; // GETMYTIME could be used - but there should be very small change anyways, as we just started
    ec8e:	2400      	movs	r4, #0
    ec90:	2500      	movs	r5, #0
    START_PA_DUMP = 0x1;
    ec92:	2201      	movs	r2, #1
    start_time_val = 0; // GETMYTIME could be used - but there should be very small change anyways, as we just started
    ec94:	e9c1 4500 	strd	r4, r5, [r1]
    START_PA_DUMP = 0x1;
    ec98:	601a      	str	r2, [r3, #0]
    ec9a:	bd38      	pop	{r3, r4, r5, pc}
    ec9c:	10001030 	.word	0x10001030
    eca0:	4ffff014 	.word	0x4ffff014

0000eca4 <stop_time>:
    This function will be called right after ending the timed portion of the benchmark.

    Implementation may be capturing a system timer (as implemented in the example code)
    or other system parameters - e.g. reading the current value of cpu cycles counter.
*/
void stop_time(void) {
    eca4:	b538      	push	{r3, r4, r5, lr}
    am_hal_systick_stop();
    eca6:	f002 fe1b 	bl	118e0 <am_hal_systick_stop>
    stop_time_val = GETMYTIME;
    ecaa:	f002 fe31 	bl	11910 <am_hal_systick_count>
    ecae:	4b09      	ldr	r3, [pc, #36]	; (ecd4 <stop_time+0x30>)
    ecb0:	4c09      	ldr	r4, [pc, #36]	; (ecd8 <stop_time+0x34>)
    ecb2:	681d      	ldr	r5, [r3, #0]
    START_PA_DUMP = 0x0;
    ecb4:	4b09      	ldr	r3, [pc, #36]	; (ecdc <stop_time+0x38>)
    stop_time_val = GETMYTIME;
    ecb6:	f1c0 10ff 	rsb	r0, r0, #16711935	; 0xff00ff
    ecba:	f500 407f 	add.w	r0, r0, #65280	; 0xff00
    ecbe:	2100      	movs	r1, #0
    ecc0:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    ecc4:	fbe2 0105 	umlal	r0, r1, r2, r5
    START_PA_DUMP = 0x0;
    ecc8:	2500      	movs	r5, #0
    stop_time_val = GETMYTIME;
    ecca:	e9c4 0100 	strd	r0, r1, [r4]
    START_PA_DUMP = 0x0;
    ecce:	601d      	str	r5, [r3, #0]
    ecd0:	bd38      	pop	{r3, r4, r5, pc}
    ecd2:	bf00      	nop
    ecd4:	10001018 	.word	0x10001018
    ecd8:	10001038 	.word	0x10001038
    ecdc:	4ffff014 	.word	0x4ffff014

0000ece0 <get_time>:
    This methodology is taken to accomodate any hardware or simulated platform.
    The sample implementation returns millisecs by default,
    and the resolution is controlled by <TIMER_RES_DIVIDER>
*/
CORE_TICKS get_time(void) {
    CORE_TICKS elapsed=(CORE_TICKS)(MYTIMEDIFF(stop_time_val, start_time_val));
    ece0:	4a02      	ldr	r2, [pc, #8]	; (ecec <get_time+0xc>)
    ece2:	4b03      	ldr	r3, [pc, #12]	; (ecf0 <get_time+0x10>)
    ece4:	6810      	ldr	r0, [r2, #0]
    ece6:	6819      	ldr	r1, [r3, #0]
    return elapsed;
}
    ece8:	1a40      	subs	r0, r0, r1
    ecea:	4770      	bx	lr
    ecec:	10001038 	.word	0x10001038
    ecf0:	10001030 	.word	0x10001030
    ecf4:	00000000 	.word	0x00000000

0000ecf8 <time_in_secs>:
    Convert the value returned by get_time to seconds.

    The <secs_ret> type is used to accomodate systems with no support for floating point.
    Default implementation implemented by the EE_TICKS_PER_SEC macro above.
*/
secs_ret time_in_secs(CORE_TICKS ticks) {
    ecf8:	b508      	push	{r3, lr}
    secs_ret retval=((secs_ret)ticks) / (secs_ret)EE_TICKS_PER_SEC;
    ecfa:	f7fd fb43 	bl	c384 <__aeabi_ui2d>
    ecfe:	a304      	add	r3, pc, #16	; (adr r3, ed10 <time_in_secs+0x18>)
    ed00:	e9d3 2300 	ldrd	r2, r3, [r3]
    ed04:	f7fd fcde 	bl	c6c4 <__aeabi_ddiv>
    return retval;
}
    ed08:	bd08      	pop	{r3, pc}
    ed0a:	bf00      	nop
    ed0c:	f3af 8000 	nop.w
    ed10:	00000000 	.word	0x00000000
    ed14:	4186e360 	.word	0x4186e360

0000ed18 <portable_init>:
    Target specific initialization code
    Test for some common mistakes.
*/

void portable_init(core_portable *p, int *argc, char *argv[])
{
    ed18:	b530      	push	{r4, r5, lr}
    ed1a:	4d1b      	ldr	r5, [pc, #108]	; (ed88 <portable_init+0x70>)
        ee_printf("ERROR! Please define ee_ptr_int to a type that holds a pointer!\n");
    }
    if (sizeof(ee_u32) != 4) {
        ee_printf("ERROR! Please define ee_u32 to a 32b unsigned type!\n");
    }
    p->portable_id=1;
    ed1c:	2401      	movs	r4, #1
{
    ed1e:	b083      	sub	sp, #12
    p->portable_id=1;
    ed20:	7004      	strb	r4, [r0, #0]
    ed22:	f44f 6280 	mov.w	r2, #1024	; 0x400
    ed26:	4628      	mov	r0, r5
    ed28:	2100      	movs	r1, #0
    ed2a:	f003 fe5b 	bl	129e4 <memset>
    // Initialize our printf buffer.
    for(i = 0; i < PRTBUFSIZE; i++)
    {
        am_prtbuf[i] = 0x00;
    }
    am_pcBuf = am_prtbuf;
    ed2e:	4b17      	ldr	r3, [pc, #92]	; (ed8c <portable_init+0x74>)
    am_bufcnt = 0;
    ed30:	4a17      	ldr	r2, [pc, #92]	; (ed90 <portable_init+0x78>)
    am_pcBuf = am_prtbuf;
    ed32:	601d      	str	r5, [r3, #0]
    am_bufcnt = 0;
    ed34:	2500      	movs	r5, #0
#endif // AM_PRINT_RESULTS

    //
    // Set the system clock to maximum frequency.
    //
    am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_SYSCLK_MAX, 0);
    ed36:	4629      	mov	r1, r5
    ed38:	4628      	mov	r0, r5
    am_bufcnt = 0;
    ed3a:	6015      	str	r5, [r2, #0]
    am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_SYSCLK_MAX, 0);
    ed3c:	f002 f8f4 	bl	10f28 <am_hal_clkgen_control>

    //
    // Set the default cache configuration
    //
const am_hal_cachectrl_config_t am_hal_cachectrl_benchmark =
    ed40:	4914      	ldr	r1, [pc, #80]	; (ed94 <portable_init+0x7c>)
    ed42:	a802      	add	r0, sp, #8
    ed44:	680b      	ldr	r3, [r1, #0]
    ed46:	f840 3d08 	str.w	r3, [r0, #-8]!
    .bLRU                       = 0,
    .eDescript                  = AM_HAL_CACHECTRL_DESCR_1WAY_128B_512E,
    .eMode                      = AM_HAL_CACHECTRL_CONFIG_MODE_INSTR,
    .eEnableNCregions           = AM_HAL_CACHECTRL_CONFIG_NCREG_NONE,
};
    am_hal_cachectrl_config(&am_hal_cachectrl_benchmark);
    ed4a:	f002 f851 	bl	10df0 <am_hal_cachectrl_config>
    am_hal_cachectrl_enable();
    ed4e:	f002 f879 	bl	10e44 <am_hal_cachectrl_enable>
#ifndef NOFPU
    //
    // Enable the floating point module, and configure the core for lazy
    // stacking.
    //
    am_hal_sysctrl_fpu_enable();
    ed52:	f002 fda7 	bl	118a4 <am_hal_sysctrl_fpu_enable>
    am_hal_sysctrl_fpu_stacking_enable(true);
    ed56:	4620      	mov	r0, r4
    ed58:	f002 fdac 	bl	118b4 <am_hal_sysctrl_fpu_stacking_enable>
#endif
#ifdef AM_PART_APOLLO3
    //
    // Configure the board for low power.
    //
    am_bsp_low_power_init();
    ed5c:	f001 ffe0 	bl	10d20 <am_bsp_low_power_init>

    //
    // Turn off Flash1
    //
    if ( am_hal_pwrctrl_memory_enable(AM_HAL_PWRCTRL_MEM_FLASH_512K) )
    ed60:	200e      	movs	r0, #14
    ed62:	f002 fd03 	bl	1176c <am_hal_pwrctrl_memory_enable>
    ed66:	b100      	cbz	r0, ed6a <portable_init+0x52>
    ed68:	e7fe      	b.n	ed68 <portable_init+0x50>
    }

	//
	// Turn off unneeded SRAM
	//
    if ( am_hal_pwrctrl_memory_enable(AM_HAL_PWRCTRL_MEM_SRAM_8K_DTCM) )
    ed6a:	4620      	mov	r0, r4
    ed6c:	f002 fcfe 	bl	1176c <am_hal_pwrctrl_memory_enable>
    ed70:	b100      	cbz	r0, ed74 <portable_init+0x5c>
    ed72:	e7fe      	b.n	ed72 <portable_init+0x5a>
    {
        while(1);
    }

#if AM_CMSIS_REGS
    uint32_t ui32LPMMode = CACHECTRL_FLASHCFG_LPMMODE_STANDBY;
    ed74:	a902      	add	r1, sp, #8
#else // AM_CMSIS_REGS
    uint32_t ui32LPMMode = AM_REG_CACHECTRL_FLASHCFG_LPMMODE_STANDBY;
#endif // AM_CMSIS_REGS
    if ( am_hal_cachectrl_control(AM_HAL_CACHECTRL_CONTROL_LPMMODE_SET, &ui32LPMMode) )
    ed76:	200b      	movs	r0, #11
    uint32_t ui32LPMMode = CACHECTRL_FLASHCFG_LPMMODE_STANDBY;
    ed78:	f841 4d04 	str.w	r4, [r1, #-4]!
    if ( am_hal_cachectrl_control(AM_HAL_CACHECTRL_CONTROL_LPMMODE_SET, &ui32LPMMode) )
    ed7c:	f002 f86c 	bl	10e58 <am_hal_cachectrl_control>
    ed80:	b100      	cbz	r0, ed84 <portable_init+0x6c>
    ed82:	e7fe      	b.n	ed82 <portable_init+0x6a>
    //
    // To minimize power during the run, disable the UART.
    //
    am_bsp_uart_printf_disable();
#endif
}
    ed84:	b003      	add	sp, #12
    ed86:	bd30      	pop	{r4, r5, pc}
    ed88:	1000114c 	.word	0x1000114c
    ed8c:	1000154c 	.word	0x1000154c
    ed90:	1000101c 	.word	0x1000101c
    ed94:	000129f4 	.word	0x000129f4

0000ed98 <portable_fini>:

/* Function : portable_fini
    Target specific final code
*/
void portable_fini(core_portable *p)
{
    ed98:	b538      	push	{r3, r4, r5, lr}
    p->portable_id=0;
    ed9a:	2500      	movs	r5, #0
    ed9c:	7005      	strb	r5, [r0, #0]

#if AM_PART_APOLLO3
	//
	// Now that we're done, turn all memory back on.
	//
    am_hal_pwrctrl_memory_enable(AM_HAL_PWRCTRL_MEM_ALL);
    ed9e:	2011      	movs	r0, #17
    eda0:	f002 fce4 	bl	1176c <am_hal_pwrctrl_memory_enable>
    //
    // Now, let's go parse the buffer and print it out!
    //
    pcBuf = am_prtbuf;
    iCnt = 0;
    while ( (*pcBuf != 0x00)  &&  (iCnt<PRTBUFSIZE) )
    eda4:	4c14      	ldr	r4, [pc, #80]	; (edf8 <portable_fini+0x60>)
    am_hal_cachectrl_config(&am_hal_cachectrl_defaults);
    eda6:	4815      	ldr	r0, [pc, #84]	; (edfc <portable_fini+0x64>)
    eda8:	f002 f822 	bl	10df0 <am_hal_cachectrl_config>
    am_hal_cachectrl_enable();
    edac:	f002 f84a 	bl	10e44 <am_hal_cachectrl_enable>
    am_bsp_uart_printf_enable();
    edb0:	f001 ffd0 	bl	10d54 <am_bsp_uart_printf_enable>
    am_util_stdio_terminal_clear();
    edb4:	f001 ff8a 	bl	10ccc <am_util_stdio_terminal_clear>
    am_util_stdio_printf("\nAmbiq Micro Coremark run finished!\n\n");
    edb8:	4811      	ldr	r0, [pc, #68]	; (ee00 <portable_fini+0x68>)
    edba:	f001 ff6d 	bl	10c98 <am_util_stdio_printf>
    while ( (*pcBuf != 0x00)  &&  (iCnt<PRTBUFSIZE) )
    edbe:	7823      	ldrb	r3, [r4, #0]
    edc0:	b19b      	cbz	r3, edea <portable_fini+0x52>
    {
        am_util_stdio_printf(pcBuf);
    edc2:	4620      	mov	r0, r4
    edc4:	f001 ff68 	bl	10c98 <am_util_stdio_printf>
        while ( *pcBuf != 0x00 )
    edc8:	7820      	ldrb	r0, [r4, #0]
    edca:	b190      	cbz	r0, edf2 <portable_fini+0x5a>
    edcc:	1b2d      	subs	r5, r5, r4
    edce:	1c63      	adds	r3, r4, #1
    edd0:	781a      	ldrb	r2, [r3, #0]
        {
            pcBuf++;
    edd2:	461c      	mov	r4, r3
    edd4:	18e9      	adds	r1, r5, r3
    edd6:	3301      	adds	r3, #1
        while ( *pcBuf != 0x00 )
    edd8:	2a00      	cmp	r2, #0
    edda:	d1f9      	bne.n	edd0 <portable_fini+0x38>
    while ( (*pcBuf != 0x00)  &&  (iCnt<PRTBUFSIZE) )
    eddc:	7860      	ldrb	r0, [r4, #1]
            iCnt++;
        }
        iCnt++;     // Account for the NULL terminator
    edde:	1c4d      	adds	r5, r1, #1
        pcBuf++;    // Point after the NULL terminator to the next string
    ede0:	3401      	adds	r4, #1
    while ( (*pcBuf != 0x00)  &&  (iCnt<PRTBUFSIZE) )
    ede2:	b110      	cbz	r0, edea <portable_fini+0x52>
    ede4:	f5b5 6f80 	cmp.w	r5, #1024	; 0x400
    ede8:	dbeb      	blt.n	edc2 <portable_fini+0x2a>
    // Turn on an LED.
    //
    am_devices_led_on(am_bsp_psLEDs, 0);
#endif

}
    edea:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    am_bsp_uart_printf_disable();
    edee:	f001 bfdf 	b.w	10db0 <am_bsp_uart_printf_disable>
        while ( *pcBuf != 0x00 )
    edf2:	4629      	mov	r1, r5
    edf4:	e7f2      	b.n	eddc <portable_fini+0x44>
    edf6:	bf00      	nop
    edf8:	1000114c 	.word	0x1000114c
    edfc:	00012fc8 	.word	0x00012fc8
    ee00:	00012e6c 	.word	0x00012e6c

0000ee04 <am_sprintf>:

#if AM_PRINT_RESULTS
int am_sprintf(char *pcFmt, ...)
{
    ee04:	b40f      	push	{r0, r1, r2, r3}
    ee06:	b530      	push	{r4, r5, lr}
    uint32_t ui32NumChars;
    int iRet = 0;

    va_list pArgs;

    if ( am_bufcnt < PRTBUFSIZE )
    ee08:	4c1a      	ldr	r4, [pc, #104]	; (ee74 <am_sprintf+0x70>)
    ee0a:	6823      	ldr	r3, [r4, #0]
    ee0c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
{
    ee10:	b083      	sub	sp, #12
    if ( am_bufcnt < PRTBUFSIZE )
    ee12:	d305      	bcc.n	ee20 <am_sprintf+0x1c>
    int iRet = 0;
    ee14:	2000      	movs	r0, #0
        }
    } // if (am_bufcnt)

    return iRet;

} // am_sprintf()
    ee16:	b003      	add	sp, #12
    ee18:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    ee1c:	b004      	add	sp, #16
    ee1e:	4770      	bx	lr
        ui32NumChars = am_util_stdio_vsprintf(am_pcBuf, pcFmt, pArgs);
    ee20:	4d15      	ldr	r5, [pc, #84]	; (ee78 <am_sprintf+0x74>)
    ee22:	9906      	ldr	r1, [sp, #24]
    ee24:	6828      	ldr	r0, [r5, #0]
        va_start(pArgs, pcFmt);
    ee26:	aa07      	add	r2, sp, #28
    ee28:	9201      	str	r2, [sp, #4]
        ui32NumChars = am_util_stdio_vsprintf(am_pcBuf, pcFmt, pArgs);
    ee2a:	f000 fe31 	bl	fa90 <am_util_stdio_vsprintf>
        if ( (am_bufcnt+ui32NumChars) >= PRTBUFSIZE )
    ee2e:	6821      	ldr	r1, [r4, #0]
    ee30:	4401      	add	r1, r0
    ee32:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
    ee36:	d20e      	bcs.n	ee56 <am_sprintf+0x52>
            am_bufcnt += ui32NumChars;
    ee38:	6822      	ldr	r2, [r4, #0]
            am_pcBuf++;                 // Skip NULL terminator
    ee3a:	682b      	ldr	r3, [r5, #0]
            am_bufcnt += ui32NumChars;
    ee3c:	4402      	add	r2, r0
    ee3e:	6022      	str	r2, [r4, #0]
            am_bufcnt++;                // Include NULL terminator
    ee40:	6822      	ldr	r2, [r4, #0]
            am_pcBuf++;                 // Skip NULL terminator
    ee42:	1c41      	adds	r1, r0, #1
            am_bufcnt++;                // Include NULL terminator
    ee44:	3201      	adds	r2, #1
            am_pcBuf++;                 // Skip NULL terminator
    ee46:	440b      	add	r3, r1
            am_bufcnt++;                // Include NULL terminator
    ee48:	6022      	str	r2, [r4, #0]
            am_pcBuf++;                 // Skip NULL terminator
    ee4a:	602b      	str	r3, [r5, #0]
} // am_sprintf()
    ee4c:	b003      	add	sp, #12
    ee4e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    ee52:	b004      	add	sp, #16
    ee54:	4770      	bx	lr
            am_util_stdio_sprintf(&am_prtbuf[PRTBUFSIZE-(40+1)], "BUFFER OVERFLOWED! Increase PRTBUFSIZE\n");
    ee56:	4909      	ldr	r1, [pc, #36]	; (ee7c <am_sprintf+0x78>)
    ee58:	4809      	ldr	r0, [pc, #36]	; (ee80 <am_sprintf+0x7c>)
    ee5a:	f001 ff0f 	bl	10c7c <am_util_stdio_sprintf>
            am_prtbuf[PRTBUFSIZE-1] = 0x00;     // Double terminate the buffer
    ee5e:	4b09      	ldr	r3, [pc, #36]	; (ee84 <am_sprintf+0x80>)
    ee60:	2000      	movs	r0, #0
            am_pcBuf = &am_prtbuf[PRTBUFSIZE];  // Don't allow any further printing
    ee62:	f503 6180 	add.w	r1, r3, #1024	; 0x400
            am_bufcnt = PRTBUFSIZE;             //  "
    ee66:	f44f 6280 	mov.w	r2, #1024	; 0x400
            am_pcBuf = &am_prtbuf[PRTBUFSIZE];  // Don't allow any further printing
    ee6a:	6029      	str	r1, [r5, #0]
            am_prtbuf[PRTBUFSIZE-1] = 0x00;     // Double terminate the buffer
    ee6c:	f883 03ff 	strb.w	r0, [r3, #1023]	; 0x3ff
            am_bufcnt = PRTBUFSIZE;             //  "
    ee70:	6022      	str	r2, [r4, #0]
    ee72:	e7d0      	b.n	ee16 <am_sprintf+0x12>
    ee74:	1000101c 	.word	0x1000101c
    ee78:	1000154c 	.word	0x1000154c
    ee7c:	00012e44 	.word	0x00012e44
    ee80:	10001523 	.word	0x10001523
    ee84:	1000114c 	.word	0x1000114c

0000ee88 <core_init_state>:
    Actual patterns chosen depend on the seed parameter.

    Note:
    The seed parameter MUST be supplied from a source that cannot be determined at compile time
*/
void core_init_state(ee_u32 size, ee_s16 seed, ee_u8 *p) {
    ee88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ee_u8 *buf=0;
#if CORE_DEBUG
    ee_u8 *start=p;
    ee_printf("State: %d,%d\n",size,seed);
#endif
    size--;
    ee8c:	1e46      	subs	r6, r0, #1
    next=0;
    while ((total+next+1)<size) {
    ee8e:	2e01      	cmp	r6, #1
void core_init_state(ee_u32 size, ee_s16 seed, ee_u8 *p) {
    ee90:	4684      	mov	ip, r0
    ee92:	4615      	mov	r5, r2
    while ((total+next+1)<size) {
    ee94:	d966      	bls.n	ef64 <core_init_state+0xdc>
    ee96:	1c4c      	adds	r4, r1, #1
            case 6: /* scientific */
                buf=scipat[(seed>>3) & 0x3];
                next=8;
            break;
            case 7: /* invalid */
                buf=errpat[(seed>>3) & 0x3];
    ee98:	f8df 90d4 	ldr.w	r9, [pc, #212]	; ef70 <core_init_state+0xe8>
                buf=scipat[(seed>>3) & 0x3];
    ee9c:	f8df 80d4 	ldr.w	r8, [pc, #212]	; ef74 <core_init_state+0xec>
                buf=floatpat[(seed>>3) & 0x3];
    eea0:	f8df e0d4 	ldr.w	lr, [pc, #212]	; ef78 <core_init_state+0xf0>
                buf=intpat[(seed>>3) & 0x3];
    eea4:	4831      	ldr	r0, [pc, #196]	; (ef6c <core_init_state+0xe4>)
    eea6:	b2a4      	uxth	r4, r4
    while ((total+next+1)<size) {
    eea8:	2100      	movs	r1, #0
            *(p+total+i)=',';
    eeaa:	272c      	movs	r7, #44	; 0x2c
        switch (seed & 0x7) {
    eeac:	f004 0307 	and.w	r3, r4, #7
    eeb0:	f1a3 0b03 	sub.w	fp, r3, #3
        seed++;
    eeb4:	b222      	sxth	r2, r4
                buf=errpat[(seed>>3) & 0x3];
    eeb6:	f3c2 03c1 	ubfx	r3, r2, #3, #2
        switch (seed & 0x7) {
    eeba:	f1bb 0f04 	cmp.w	fp, #4
    eebe:	d831      	bhi.n	ef24 <core_init_state+0x9c>
    eec0:	e8df f00b 	tbb	[pc, fp]
    eec4:	39390303 	.word	0x39390303
    eec8:	49          	.byte	0x49
    eec9:	00          	.byte	0x00
    while ((total+next+1)<size) {
    eeca:	f101 0b09 	add.w	fp, r1, #9
    eece:	455e      	cmp	r6, fp
                buf=floatpat[(seed>>3) & 0x3];
    eed0:	f85e 3023 	ldr.w	r3, [lr, r3, lsl #2]
    while ((total+next+1)<size) {
    eed4:	d935      	bls.n	ef42 <core_init_state+0xba>
                next=8;
    eed6:	f04f 0a08 	mov.w	sl, #8
                *(p+total+i)=buf[i];
    eeda:	781a      	ldrb	r2, [r3, #0]
    eedc:	546a      	strb	r2, [r5, r1]
    eede:	186a      	adds	r2, r5, r1
    eee0:	7859      	ldrb	r1, [r3, #1]
    eee2:	7051      	strb	r1, [r2, #1]
    eee4:	7899      	ldrb	r1, [r3, #2]
    eee6:	7091      	strb	r1, [r2, #2]
    eee8:	78d9      	ldrb	r1, [r3, #3]
    eeea:	70d1      	strb	r1, [r2, #3]
            for(i=0;i<next;i++)
    eeec:	f1ba 0f04 	cmp.w	sl, #4
    eef0:	d012      	beq.n	ef18 <core_init_state+0x90>
                *(p+total+i)=buf[i];
    eef2:	7919      	ldrb	r1, [r3, #4]
    eef4:	7111      	strb	r1, [r2, #4]
            for(i=0;i<next;i++)
    eef6:	f1ba 0f05 	cmp.w	sl, #5
    eefa:	d00d      	beq.n	ef18 <core_init_state+0x90>
                *(p+total+i)=buf[i];
    eefc:	7959      	ldrb	r1, [r3, #5]
    eefe:	7151      	strb	r1, [r2, #5]
            for(i=0;i<next;i++)
    ef00:	f1ba 0f06 	cmp.w	sl, #6
    ef04:	d008      	beq.n	ef18 <core_init_state+0x90>
                *(p+total+i)=buf[i];
    ef06:	7999      	ldrb	r1, [r3, #6]
    ef08:	7191      	strb	r1, [r2, #6]
            for(i=0;i<next;i++)
    ef0a:	f1ba 0f08 	cmp.w	sl, #8
                *(p+total+i)=buf[i];
    ef0e:	bf06      	itte	eq
    ef10:	79db      	ldrbeq	r3, [r3, #7]
    ef12:	71d3      	strbeq	r3, [r2, #7]
            for(i=0;i<next;i++)
    ef14:	f04f 0a07 	movne.w	sl, #7
    ef18:	3401      	adds	r4, #1
            *(p+total+i)=',';
    ef1a:	f802 700a 	strb.w	r7, [r2, sl]
    ef1e:	b2a4      	uxth	r4, r4
    ef20:	4659      	mov	r1, fp
    ef22:	e7c3      	b.n	eeac <core_init_state+0x24>
    while ((total+next+1)<size) {
    ef24:	f101 0b05 	add.w	fp, r1, #5
    ef28:	455e      	cmp	r6, fp
                buf=intpat[(seed>>3) & 0x3];
    ef2a:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    while ((total+next+1)<size) {
    ef2e:	d908      	bls.n	ef42 <core_init_state+0xba>
                next=4;
    ef30:	f04f 0a04 	mov.w	sl, #4
    ef34:	e7d1      	b.n	eeda <core_init_state+0x52>
    while ((total+next+1)<size) {
    ef36:	f101 0b09 	add.w	fp, r1, #9
    ef3a:	455e      	cmp	r6, fp
                buf=scipat[(seed>>3) & 0x3];
    ef3c:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
    while ((total+next+1)<size) {
    ef40:	d8c9      	bhi.n	eed6 <core_init_state+0x4e>
            default: /* Never happen, just to make some compilers happy */
            break;
        }
    }
    size++;
    while (total<size) { /* fill the rest with 0 */
    ef42:	4561      	cmp	r1, ip
    ef44:	d210      	bcs.n	ef68 <core_init_state+0xe0>
    ef46:	1868      	adds	r0, r5, r1
    ef48:	ebac 0201 	sub.w	r2, ip, r1
        total++;
    }
#if CORE_DEBUG
    ee_printf("State Input: %s\n",start);
#endif
}
    ef4c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ef50:	2100      	movs	r1, #0
    ef52:	f003 bd47 	b.w	129e4 <memset>
    while ((total+next+1)<size) {
    ef56:	f101 0b09 	add.w	fp, r1, #9
    ef5a:	455e      	cmp	r6, fp
                buf=errpat[(seed>>3) & 0x3];
    ef5c:	f859 3023 	ldr.w	r3, [r9, r3, lsl #2]
    while ((total+next+1)<size) {
    ef60:	d8b9      	bhi.n	eed6 <core_init_state+0x4e>
    ef62:	e7ee      	b.n	ef42 <core_init_state+0xba>
    ee_u32 total=0,next=0,i;
    ef64:	2100      	movs	r1, #0
    ef66:	e7ee      	b.n	ef46 <core_init_state+0xbe>
    ef68:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ef6c:	00012eb4 	.word	0x00012eb4
    ef70:	00012e94 	.word	0x00012e94
    ef74:	00012ec4 	.word	0x00012ec4
    ef78:	00012ea4 	.word	0x00012ea4

0000ef7c <core_state_transition>:

    The input pointer is updated to point to the end of the token, and the end state is returned (either specific format determined or invalid).
*/

enum CORE_STATE core_state_transition( ee_u8 **instr , ee_u32 *transition_count) {
    ee_u8 *str=*instr;
    ef7c:	6803      	ldr	r3, [r0, #0]
    ee_u8 NEXT_SYMBOL;
    enum CORE_STATE state=CORE_START;
    for( ; *str && state != CORE_INVALID; str++ ) {
    ef7e:	781a      	ldrb	r2, [r3, #0]
    ef80:	b392      	cbz	r2, efe8 <core_state_transition+0x6c>
        NEXT_SYMBOL = *str;
        if (NEXT_SYMBOL==',') /* end of this input */ {
    ef82:	2a2c      	cmp	r2, #44	; 0x2c
    ef84:	d02e      	beq.n	efe4 <core_state_transition+0x68>
enum CORE_STATE core_state_transition( ee_u8 **instr , ee_u32 *transition_count) {
    ef86:	b410      	push	{r4}
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    ef88:	f1a2 0430 	sub.w	r4, r2, #48	; 0x30
    ef8c:	2c09      	cmp	r4, #9
    ef8e:	d90f      	bls.n	efb0 <core_state_transition+0x34>
        switch(state) {
        case CORE_START:
            if(ee_isdigit(NEXT_SYMBOL)) {
                state = CORE_INT;
            }
            else if( NEXT_SYMBOL == '+' || NEXT_SYMBOL == '-' ) {
    ef90:	2a2b      	cmp	r2, #43	; 0x2b
    ef92:	d02c      	beq.n	efee <core_state_transition+0x72>
    ef94:	2a2d      	cmp	r2, #45	; 0x2d
    ef96:	d02a      	beq.n	efee <core_state_transition+0x72>
                state = CORE_S1;
            }
            else if( NEXT_SYMBOL == '.' ) {
    ef98:	2a2e      	cmp	r2, #46	; 0x2e
    ef9a:	f000 80b1 	beq.w	f100 <core_state_transition+0x184>
            }
            else {
                state = CORE_INVALID;
                transition_count[CORE_INVALID]++;
            }
            transition_count[CORE_START]++;
    ef9e:	e891 0014 	ldmia.w	r1, {r2, r4}
                transition_count[CORE_INVALID]++;
    efa2:	3401      	adds	r4, #1
            transition_count[CORE_START]++;
    efa4:	3201      	adds	r2, #1
    efa6:	e881 0014 	stmia.w	r1, {r2, r4}
    for( ; *str && state != CORE_INVALID; str++ ) {
    efaa:	3301      	adds	r3, #1
                state = CORE_INVALID;
    efac:	2101      	movs	r1, #1
    efae:	e014      	b.n	efda <core_state_transition+0x5e>
            transition_count[CORE_START]++;
    efb0:	680c      	ldr	r4, [r1, #0]
    efb2:	3401      	adds	r4, #1
    efb4:	600c      	str	r4, [r1, #0]
    for( ; *str && state != CORE_INVALID; str++ ) {
    efb6:	785a      	ldrb	r2, [r3, #1]
    efb8:	3301      	adds	r3, #1
    efba:	b372      	cbz	r2, f01a <core_state_transition+0x9e>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    efbc:	2a2c      	cmp	r2, #44	; 0x2c
    efbe:	f000 8092 	beq.w	f0e6 <core_state_transition+0x16a>
                state = CORE_INVALID;
                transition_count[CORE_S1]++;
            }
            break;
        case CORE_INT:
            if( NEXT_SYMBOL == '.' ) {
    efc2:	2a2e      	cmp	r2, #46	; 0x2e
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    efc4:	f1a2 0430 	sub.w	r4, r2, #48	; 0x30
            if( NEXT_SYMBOL == '.' ) {
    efc8:	d031      	beq.n	f02e <core_state_transition+0xb2>
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    efca:	2c09      	cmp	r4, #9
    efcc:	f240 80a0 	bls.w	f110 <core_state_transition+0x194>
                state = CORE_FLOAT;
                transition_count[CORE_INT]++;
            }
            else if(!ee_isdigit(NEXT_SYMBOL)) {
                state = CORE_INVALID;
                transition_count[CORE_INT]++;
    efd0:	690a      	ldr	r2, [r1, #16]
    efd2:	3201      	adds	r2, #1
    efd4:	610a      	str	r2, [r1, #16]
    for( ; *str && state != CORE_INVALID; str++ ) {
    efd6:	3301      	adds	r3, #1
                state = CORE_INVALID;
    efd8:	2101      	movs	r1, #1
            break;
        default:
            break;
        }
    }
    *instr=str;
    efda:	6003      	str	r3, [r0, #0]
    return state;
}
    efdc:	f85d 4b04 	ldr.w	r4, [sp], #4
    efe0:	4608      	mov	r0, r1
    efe2:	4770      	bx	lr
        if (NEXT_SYMBOL==',') /* end of this input */ {
    efe4:	2200      	movs	r2, #0
            str++;
    efe6:	3301      	adds	r3, #1
    *instr=str;
    efe8:	6003      	str	r3, [r0, #0]
}
    efea:	4610      	mov	r0, r2
    efec:	4770      	bx	lr
            transition_count[CORE_START]++;
    efee:	680c      	ldr	r4, [r1, #0]
    eff0:	3401      	adds	r4, #1
    eff2:	600c      	str	r4, [r1, #0]
    for( ; *str && state != CORE_INVALID; str++ ) {
    eff4:	785a      	ldrb	r2, [r3, #1]
    eff6:	3301      	adds	r3, #1
    eff8:	2a00      	cmp	r2, #0
    effa:	f000 809c 	beq.w	f136 <core_state_transition+0x1ba>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    effe:	2a2c      	cmp	r2, #44	; 0x2c
    f000:	f000 809b 	beq.w	f13a <core_state_transition+0x1be>
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    f004:	f1a2 0430 	sub.w	r4, r2, #48	; 0x30
    f008:	2c09      	cmp	r4, #9
    f00a:	d808      	bhi.n	f01e <core_state_transition+0xa2>
                transition_count[CORE_S1]++;
    f00c:	688a      	ldr	r2, [r1, #8]
    f00e:	3201      	adds	r2, #1
    f010:	608a      	str	r2, [r1, #8]
    for( ; *str && state != CORE_INVALID; str++ ) {
    f012:	785a      	ldrb	r2, [r3, #1]
    f014:	3301      	adds	r3, #1
    f016:	2a00      	cmp	r2, #0
    f018:	d1d0      	bne.n	efbc <core_state_transition+0x40>
                state = CORE_INT;
    f01a:	2104      	movs	r1, #4
    f01c:	e7dd      	b.n	efda <core_state_transition+0x5e>
            else if( NEXT_SYMBOL == '.' ) {
    f01e:	2a2e      	cmp	r2, #46	; 0x2e
    f020:	d064      	beq.n	f0ec <core_state_transition+0x170>
                transition_count[CORE_S1]++;
    f022:	688a      	ldr	r2, [r1, #8]
    f024:	3201      	adds	r2, #1
    f026:	608a      	str	r2, [r1, #8]
    for( ; *str && state != CORE_INVALID; str++ ) {
    f028:	3301      	adds	r3, #1
                state = CORE_INVALID;
    f02a:	2101      	movs	r1, #1
    f02c:	e7d5      	b.n	efda <core_state_transition+0x5e>
                transition_count[CORE_INT]++;
    f02e:	690c      	ldr	r4, [r1, #16]
    f030:	3401      	adds	r4, #1
    f032:	610c      	str	r4, [r1, #16]
    for( ; *str && state != CORE_INVALID; str++ ) {
    f034:	785a      	ldrb	r2, [r3, #1]
    f036:	1c5c      	adds	r4, r3, #1
    f038:	2a00      	cmp	r2, #0
    f03a:	d05e      	beq.n	f0fa <core_state_transition+0x17e>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    f03c:	2a2c      	cmp	r2, #44	; 0x2c
    f03e:	d075      	beq.n	f12c <core_state_transition+0x1b0>
            if( NEXT_SYMBOL == 'E' || NEXT_SYMBOL == 'e' ) {
    f040:	f002 03df 	and.w	r3, r2, #223	; 0xdf
    f044:	2b45      	cmp	r3, #69	; 0x45
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    f046:	f1a2 0230 	sub.w	r2, r2, #48	; 0x30
            if( NEXT_SYMBOL == 'E' || NEXT_SYMBOL == 'e' ) {
    f04a:	d009      	beq.n	f060 <core_state_transition+0xe4>
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    f04c:	2a09      	cmp	r2, #9
    f04e:	d844      	bhi.n	f0da <core_state_transition+0x15e>
    for( ; *str && state != CORE_INVALID; str++ ) {
    f050:	7862      	ldrb	r2, [r4, #1]
    f052:	1c63      	adds	r3, r4, #1
    f054:	2a00      	cmp	r2, #0
    f056:	d072      	beq.n	f13e <core_state_transition+0x1c2>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    f058:	2a2c      	cmp	r2, #44	; 0x2c
    f05a:	d068      	beq.n	f12e <core_state_transition+0x1b2>
    f05c:	461c      	mov	r4, r3
    f05e:	e7ef      	b.n	f040 <core_state_transition+0xc4>
                transition_count[CORE_FLOAT]++;
    f060:	694b      	ldr	r3, [r1, #20]
    f062:	3301      	adds	r3, #1
    f064:	614b      	str	r3, [r1, #20]
    for( ; *str && state != CORE_INVALID; str++ ) {
    f066:	7862      	ldrb	r2, [r4, #1]
    f068:	1c63      	adds	r3, r4, #1
    f06a:	2a00      	cmp	r2, #0
    f06c:	d05a      	beq.n	f124 <core_state_transition+0x1a8>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    f06e:	2a2c      	cmp	r2, #44	; 0x2c
    f070:	d05a      	beq.n	f128 <core_state_transition+0x1ac>
            if( NEXT_SYMBOL == '+' || NEXT_SYMBOL == '-' ) {
    f072:	2a2b      	cmp	r2, #43	; 0x2b
                transition_count[CORE_S2]++;
    f074:	68cb      	ldr	r3, [r1, #12]
            if( NEXT_SYMBOL == '+' || NEXT_SYMBOL == '-' ) {
    f076:	d006      	beq.n	f086 <core_state_transition+0x10a>
    f078:	2a2d      	cmp	r2, #45	; 0x2d
    f07a:	d004      	beq.n	f086 <core_state_transition+0x10a>
                transition_count[CORE_S2]++;
    f07c:	1c5a      	adds	r2, r3, #1
    f07e:	60ca      	str	r2, [r1, #12]
    for( ; *str && state != CORE_INVALID; str++ ) {
    f080:	1ca3      	adds	r3, r4, #2
                state = CORE_INVALID;
    f082:	2101      	movs	r1, #1
    f084:	e7a9      	b.n	efda <core_state_transition+0x5e>
                transition_count[CORE_S2]++;
    f086:	3301      	adds	r3, #1
    f088:	60cb      	str	r3, [r1, #12]
    for( ; *str && state != CORE_INVALID; str++ ) {
    f08a:	78a2      	ldrb	r2, [r4, #2]
    f08c:	1ca3      	adds	r3, r4, #2
    f08e:	2a00      	cmp	r2, #0
    f090:	d046      	beq.n	f120 <core_state_transition+0x1a4>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    f092:	2a2c      	cmp	r2, #44	; 0x2c
    f094:	d04d      	beq.n	f132 <core_state_transition+0x1b6>
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    f096:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
    f09a:	2b09      	cmp	r3, #9
    f09c:	d811      	bhi.n	f0c2 <core_state_transition+0x146>
                transition_count[CORE_EXPONENT]++;
    f09e:	698b      	ldr	r3, [r1, #24]
    f0a0:	3301      	adds	r3, #1
    f0a2:	618b      	str	r3, [r1, #24]
    for( ; *str && state != CORE_INVALID; str++ ) {
    f0a4:	78e2      	ldrb	r2, [r4, #3]
    f0a6:	1ce3      	adds	r3, r4, #3
    f0a8:	b14a      	cbz	r2, f0be <core_state_transition+0x142>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    f0aa:	2a2c      	cmp	r2, #44	; 0x2c
    f0ac:	d036      	beq.n	f11c <core_state_transition+0x1a0>
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    f0ae:	f1a2 0430 	sub.w	r4, r2, #48	; 0x30
    f0b2:	2c09      	cmp	r4, #9
    f0b4:	d80b      	bhi.n	f0ce <core_state_transition+0x152>
    for( ; *str && state != CORE_INVALID; str++ ) {
    f0b6:	f813 2f01 	ldrb.w	r2, [r3, #1]!
    f0ba:	2a00      	cmp	r2, #0
    f0bc:	d1f5      	bne.n	f0aa <core_state_transition+0x12e>
                state = CORE_SCIENTIFIC;
    f0be:	2107      	movs	r1, #7
    f0c0:	e78b      	b.n	efda <core_state_transition+0x5e>
                transition_count[CORE_EXPONENT]++;
    f0c2:	698a      	ldr	r2, [r1, #24]
    f0c4:	3201      	adds	r2, #1
    f0c6:	618a      	str	r2, [r1, #24]
    for( ; *str && state != CORE_INVALID; str++ ) {
    f0c8:	1ce3      	adds	r3, r4, #3
                state = CORE_INVALID;
    f0ca:	2101      	movs	r1, #1
    f0cc:	e785      	b.n	efda <core_state_transition+0x5e>
                transition_count[CORE_INVALID]++;
    f0ce:	684a      	ldr	r2, [r1, #4]
    f0d0:	3201      	adds	r2, #1
    f0d2:	604a      	str	r2, [r1, #4]
    for( ; *str && state != CORE_INVALID; str++ ) {
    f0d4:	3301      	adds	r3, #1
                state = CORE_INVALID;
    f0d6:	2101      	movs	r1, #1
    f0d8:	e77f      	b.n	efda <core_state_transition+0x5e>
                transition_count[CORE_FLOAT]++;
    f0da:	694b      	ldr	r3, [r1, #20]
    f0dc:	1c5a      	adds	r2, r3, #1
    f0de:	614a      	str	r2, [r1, #20]
    for( ; *str && state != CORE_INVALID; str++ ) {
    f0e0:	1c63      	adds	r3, r4, #1
                state = CORE_INVALID;
    f0e2:	2101      	movs	r1, #1
    f0e4:	e779      	b.n	efda <core_state_transition+0x5e>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    f0e6:	2104      	movs	r1, #4
            str++;
    f0e8:	3301      	adds	r3, #1
            break;
    f0ea:	e776      	b.n	efda <core_state_transition+0x5e>
                transition_count[CORE_S1]++;
    f0ec:	688c      	ldr	r4, [r1, #8]
    f0ee:	3401      	adds	r4, #1
    f0f0:	608c      	str	r4, [r1, #8]
    for( ; *str && state != CORE_INVALID; str++ ) {
    f0f2:	785a      	ldrb	r2, [r3, #1]
    f0f4:	1c5c      	adds	r4, r3, #1
    f0f6:	2a00      	cmp	r2, #0
    f0f8:	d1a0      	bne.n	f03c <core_state_transition+0xc0>
    f0fa:	4623      	mov	r3, r4
                state = CORE_FLOAT;
    f0fc:	2105      	movs	r1, #5
    f0fe:	e76c      	b.n	efda <core_state_transition+0x5e>
            transition_count[CORE_START]++;
    f100:	680a      	ldr	r2, [r1, #0]
    f102:	3201      	adds	r2, #1
    f104:	600a      	str	r2, [r1, #0]
    for( ; *str && state != CORE_INVALID; str++ ) {
    f106:	785a      	ldrb	r2, [r3, #1]
    f108:	1c5c      	adds	r4, r3, #1
    f10a:	2a00      	cmp	r2, #0
    f10c:	d196      	bne.n	f03c <core_state_transition+0xc0>
    f10e:	e7f4      	b.n	f0fa <core_state_transition+0x17e>
    f110:	f813 2f01 	ldrb.w	r2, [r3, #1]!
    f114:	2a00      	cmp	r2, #0
    f116:	f47f af51 	bne.w	efbc <core_state_transition+0x40>
    f11a:	e77e      	b.n	f01a <core_state_transition+0x9e>
                state = CORE_SCIENTIFIC;
    f11c:	2107      	movs	r1, #7
    f11e:	e7e3      	b.n	f0e8 <core_state_transition+0x16c>
                state = CORE_EXPONENT;
    f120:	2106      	movs	r1, #6
    f122:	e75a      	b.n	efda <core_state_transition+0x5e>
                state = CORE_S2;
    f124:	2103      	movs	r1, #3
    f126:	e758      	b.n	efda <core_state_transition+0x5e>
    f128:	2103      	movs	r1, #3
    f12a:	e7dd      	b.n	f0e8 <core_state_transition+0x16c>
    for( ; *str && state != CORE_INVALID; str++ ) {
    f12c:	4623      	mov	r3, r4
                state = CORE_FLOAT;
    f12e:	2105      	movs	r1, #5
    f130:	e7da      	b.n	f0e8 <core_state_transition+0x16c>
                state = CORE_EXPONENT;
    f132:	2106      	movs	r1, #6
    f134:	e7d8      	b.n	f0e8 <core_state_transition+0x16c>
                state = CORE_S1;
    f136:	2102      	movs	r1, #2
    f138:	e74f      	b.n	efda <core_state_transition+0x5e>
    f13a:	2102      	movs	r1, #2
    f13c:	e7d4      	b.n	f0e8 <core_state_transition+0x16c>
    for( ; *str && state != CORE_INVALID; str++ ) {
    f13e:	2105      	movs	r1, #5
    f140:	e74b      	b.n	efda <core_state_transition+0x5e>
    f142:	bf00      	nop

0000f144 <core_bench_state>:
{
    f144:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    f148:	b092      	sub	sp, #72	; 0x48
    f14a:	460c      	mov	r4, r1
    f14c:	4682      	mov	sl, r0
    f14e:	2100      	movs	r1, #0
    f150:	4691      	mov	r9, r2
    f152:	a80a      	add	r0, sp, #40	; 0x28
    f154:	2220      	movs	r2, #32
    f156:	4698      	mov	r8, r3
    ee_u8 *p=memblock;
    f158:	9401      	str	r4, [sp, #4]
{
    f15a:	f9bd 6068 	ldrsh.w	r6, [sp, #104]	; 0x68
    f15e:	f8bd 706c 	ldrh.w	r7, [sp, #108]	; 0x6c
    f162:	f003 fc3f 	bl	129e4 <memset>
    f166:	2220      	movs	r2, #32
    f168:	2100      	movs	r1, #0
    f16a:	a802      	add	r0, sp, #8
    f16c:	f003 fc3a 	bl	129e4 <memset>
    while (*p!=0) {
    f170:	7822      	ldrb	r2, [r4, #0]
    f172:	2a00      	cmp	r2, #0
    f174:	d05a      	beq.n	f22c <core_bench_state+0xe8>
    f176:	ad01      	add	r5, sp, #4
        enum CORE_STATE fstate=core_state_transition(&p,track_counts);
    f178:	a90a      	add	r1, sp, #40	; 0x28
    f17a:	4628      	mov	r0, r5
    f17c:	f7ff fefe 	bl	ef7c <core_state_transition>
        final_counts[fstate]++;
    f180:	ab12      	add	r3, sp, #72	; 0x48
    f182:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    while (*p!=0) {
    f186:	9901      	ldr	r1, [sp, #4]
        final_counts[fstate]++;
    f188:	f850 3c40 	ldr.w	r3, [r0, #-64]
    while (*p!=0) {
    f18c:	780a      	ldrb	r2, [r1, #0]
        final_counts[fstate]++;
    f18e:	3301      	adds	r3, #1
    f190:	f840 3c40 	str.w	r3, [r0, #-64]
    while (*p!=0) {
    f194:	2a00      	cmp	r2, #0
    f196:	d1ef      	bne.n	f178 <core_bench_state+0x34>
    while (p < (memblock+blksize)) { /* insert some corruption */
    f198:	44a2      	add	sl, r4
    f19a:	4554      	cmp	r4, sl
    p=memblock;
    f19c:	9401      	str	r4, [sp, #4]
    f19e:	7822      	ldrb	r2, [r4, #0]
    while (p < (memblock+blksize)) { /* insert some corruption */
    f1a0:	d241      	bcs.n	f226 <core_bench_state+0xe2>
{
    f1a2:	4620      	mov	r0, r4
    f1a4:	e000      	b.n	f1a8 <core_bench_state+0x64>
    f1a6:	7802      	ldrb	r2, [r0, #0]
        if (*p!=',')
    f1a8:	2a2c      	cmp	r2, #44	; 0x2c
            *p^=(ee_u8)seed1;
    f1aa:	ea82 0109 	eor.w	r1, r2, r9
    f1ae:	bf1c      	itt	ne
    f1b0:	7001      	strbne	r1, [r0, #0]
    f1b2:	9801      	ldrne	r0, [sp, #4]
        p+=step;
    f1b4:	4430      	add	r0, r6
    while (p < (memblock+blksize)) { /* insert some corruption */
    f1b6:	4550      	cmp	r0, sl
        p+=step;
    f1b8:	9001      	str	r0, [sp, #4]
    while (p < (memblock+blksize)) { /* insert some corruption */
    f1ba:	d3f4      	bcc.n	f1a6 <core_bench_state+0x62>
    while (*p!=0) {
    f1bc:	7823      	ldrb	r3, [r4, #0]
    p=memblock;
    f1be:	9401      	str	r4, [sp, #4]
    while (*p!=0) {
    f1c0:	2b00      	cmp	r3, #0
    f1c2:	d039      	beq.n	f238 <core_bench_state+0xf4>
        enum CORE_STATE fstate=core_state_transition(&p,track_counts);
    f1c4:	a90a      	add	r1, sp, #40	; 0x28
    f1c6:	4628      	mov	r0, r5
    f1c8:	f7ff fed8 	bl	ef7c <core_state_transition>
        final_counts[fstate]++;
    f1cc:	f10d 0c48 	add.w	ip, sp, #72	; 0x48
    f1d0:	eb0c 0980 	add.w	r9, ip, r0, lsl #2
    while (*p!=0) {
    f1d4:	9a01      	ldr	r2, [sp, #4]
        final_counts[fstate]++;
    f1d6:	f859 0c40 	ldr.w	r0, [r9, #-64]
    while (*p!=0) {
    f1da:	7811      	ldrb	r1, [r2, #0]
        final_counts[fstate]++;
    f1dc:	3001      	adds	r0, #1
    f1de:	f849 0c40 	str.w	r0, [r9, #-64]
    while (*p!=0) {
    f1e2:	2900      	cmp	r1, #0
    f1e4:	d1ee      	bne.n	f1c4 <core_bench_state+0x80>
    while (p < (memblock+blksize)) { /* undo corruption is seed1 and seed2 are equal */
    f1e6:	4554      	cmp	r4, sl
        p+=step;
    f1e8:	9401      	str	r4, [sp, #4]
    while (p < (memblock+blksize)) { /* undo corruption is seed1 and seed2 are equal */
    f1ea:	d20a      	bcs.n	f202 <core_bench_state+0xbe>
        if (*p!=',')
    f1ec:	7823      	ldrb	r3, [r4, #0]
    f1ee:	2b2c      	cmp	r3, #44	; 0x2c
            *p^=(ee_u8)seed2;
    f1f0:	ea83 0208 	eor.w	r2, r3, r8
    f1f4:	bf1c      	itt	ne
    f1f6:	7022      	strbne	r2, [r4, #0]
    f1f8:	9c01      	ldrne	r4, [sp, #4]
        p+=step;
    f1fa:	4434      	add	r4, r6
    while (p < (memblock+blksize)) { /* undo corruption is seed1 and seed2 are equal */
    f1fc:	4554      	cmp	r4, sl
        p+=step;
    f1fe:	9401      	str	r4, [sp, #4]
    while (p < (memblock+blksize)) { /* undo corruption is seed1 and seed2 are equal */
    f200:	d3f4      	bcc.n	f1ec <core_bench_state+0xa8>
    f202:	ac09      	add	r4, sp, #36	; 0x24
    f204:	4626      	mov	r6, r4
        crc=crcu32(final_counts[i],crc);
    f206:	4639      	mov	r1, r7
    f208:	f855 0f04 	ldr.w	r0, [r5, #4]!
    f20c:	f000 f8d4 	bl	f3b8 <crcu32>
        crc=crcu32(track_counts[i],crc);
    f210:	4601      	mov	r1, r0
    f212:	f854 0f04 	ldr.w	r0, [r4, #4]!
    f216:	f000 f8cf 	bl	f3b8 <crcu32>
    for (i=0; i<NUM_CORE_STATES; i++) {
    f21a:	42b5      	cmp	r5, r6
        crc=crcu32(track_counts[i],crc);
    f21c:	4607      	mov	r7, r0
    for (i=0; i<NUM_CORE_STATES; i++) {
    f21e:	d1f2      	bne.n	f206 <core_bench_state+0xc2>
}
    f220:	b012      	add	sp, #72	; 0x48
    f222:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    while (*p!=0) {
    f226:	2a00      	cmp	r2, #0
    f228:	d1cc      	bne.n	f1c4 <core_bench_state+0x80>
    f22a:	e7ea      	b.n	f202 <core_bench_state+0xbe>
    while (p < (memblock+blksize)) { /* insert some corruption */
    f22c:	44a2      	add	sl, r4
    f22e:	4554      	cmp	r4, sl
    p=memblock;
    f230:	9401      	str	r4, [sp, #4]
    f232:	ad01      	add	r5, sp, #4
    while (p < (memblock+blksize)) { /* insert some corruption */
    f234:	d3b5      	bcc.n	f1a2 <core_bench_state+0x5e>
    f236:	e7e4      	b.n	f202 <core_bench_state+0xbe>
    p=memblock;
    f238:	9401      	str	r4, [sp, #4]
    f23a:	e7d7      	b.n	f1ec <core_bench_state+0xa8>

0000f23c <get_seed_32>:
    extern volatile ee_s32 seed3_volatile;
    extern volatile ee_s32 seed4_volatile;
    extern volatile ee_s32 seed5_volatile;
    ee_s32 get_seed_32(int i) {
        ee_s32 retval;
        switch (i) {
    f23c:	3801      	subs	r0, #1
    f23e:	2804      	cmp	r0, #4
    f240:	d813      	bhi.n	f26a <get_seed_32+0x2e>
    f242:	e8df f000 	tbb	[pc, r0]
    f246:	0906      	.short	0x0906
    f248:	0f0c      	.short	0x0f0c
    f24a:	03          	.byte	0x03
    f24b:	00          	.byte	0x00
                break;
            case 4:
                retval=seed4_volatile;
                break;
            case 5:
                retval=seed5_volatile;
    f24c:	4b08      	ldr	r3, [pc, #32]	; (f270 <get_seed_32+0x34>)
    f24e:	6818      	ldr	r0, [r3, #0]
                break;
    f250:	4770      	bx	lr
                retval=seed1_volatile;
    f252:	4b08      	ldr	r3, [pc, #32]	; (f274 <get_seed_32+0x38>)
    f254:	6818      	ldr	r0, [r3, #0]
                break;
    f256:	4770      	bx	lr
                retval=seed2_volatile;
    f258:	4807      	ldr	r0, [pc, #28]	; (f278 <get_seed_32+0x3c>)
    f25a:	6800      	ldr	r0, [r0, #0]
                break;
    f25c:	4770      	bx	lr
                retval=seed3_volatile;
    f25e:	4a07      	ldr	r2, [pc, #28]	; (f27c <get_seed_32+0x40>)
    f260:	6810      	ldr	r0, [r2, #0]
                break;
    f262:	4770      	bx	lr
                retval=seed4_volatile;
    f264:	4906      	ldr	r1, [pc, #24]	; (f280 <get_seed_32+0x44>)
    f266:	6808      	ldr	r0, [r1, #0]
                break;
    f268:	4770      	bx	lr
            default:
                retval=0;
    f26a:	2000      	movs	r0, #0
                break;
        }
        return retval;
    }
    f26c:	4770      	bx	lr
    f26e:	bf00      	nop
    f270:	10001028 	.word	0x10001028
    f274:	10001020 	.word	0x10001020
    f278:	10001024 	.word	0x10001024
    f27c:	10001004 	.word	0x10001004
    f280:	10001008 	.word	0x10001008

0000f284 <crcu16>:
        }
        else
            carry = 0;
        crc >>= 1;
        if (carry)
           crc |= 0x8000;
    f284:	f24a 0201 	movw	r2, #40961	; 0xa001
    f288:	084b      	lsrs	r3, r1, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f28a:	4041      	eors	r1, r0
    f28c:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    f290:	ea83 0102 	eor.w	r1, r3, r2
           crc &= 0x7fff;
    }
    return crc;
}
ee_u16 crcu16(ee_u16 newval, ee_u16 crc) {
    crc=crcu8( (ee_u8) (newval)             ,crc);
    f294:	fa5f fc80 	uxtb.w	ip, r0
    f298:	bf18      	it	ne
    f29a:	460b      	movne	r3, r1
ee_u16 crcu16(ee_u16 newval, ee_u16 crc) {
    f29c:	b410      	push	{r4}
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f29e:	ea83 045c 	eor.w	r4, r3, ip, lsr #1
    f2a2:	085b      	lsrs	r3, r3, #1
    f2a4:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f2a8:	ea83 0102 	eor.w	r1, r3, r2
    f2ac:	bf18      	it	ne
    f2ae:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f2b0:	ea83 049c 	eor.w	r4, r3, ip, lsr #2
    f2b4:	085b      	lsrs	r3, r3, #1
    f2b6:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f2ba:	ea83 0102 	eor.w	r1, r3, r2
    f2be:	bf18      	it	ne
    f2c0:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f2c2:	ea83 04dc 	eor.w	r4, r3, ip, lsr #3
    f2c6:	085b      	lsrs	r3, r3, #1
    f2c8:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f2cc:	ea83 0102 	eor.w	r1, r3, r2
    f2d0:	bf18      	it	ne
    f2d2:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f2d4:	ea83 141c 	eor.w	r4, r3, ip, lsr #4
    f2d8:	085b      	lsrs	r3, r3, #1
    f2da:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f2de:	ea83 0102 	eor.w	r1, r3, r2
    f2e2:	bf18      	it	ne
    f2e4:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f2e6:	ea83 145c 	eor.w	r4, r3, ip, lsr #5
    f2ea:	085b      	lsrs	r3, r3, #1
    f2ec:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f2f0:	ea83 0102 	eor.w	r1, r3, r2
    f2f4:	bf18      	it	ne
    f2f6:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f2f8:	ea83 149c 	eor.w	r4, r3, ip, lsr #6
    f2fc:	085b      	lsrs	r3, r3, #1
    f2fe:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f302:	ea83 0102 	eor.w	r1, r3, r2
    f306:	bf18      	it	ne
    f308:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f30a:	ea83 14dc 	eor.w	r4, r3, ip, lsr #7
    f30e:	085b      	lsrs	r3, r3, #1
    f310:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f314:	ea83 0c02 	eor.w	ip, r3, r2
    f318:	bf18      	it	ne
    f31a:	4663      	movne	r3, ip
    crc=crcu8( (ee_u8) ((newval)>>8)    ,crc);
    f31c:	0a00      	lsrs	r0, r0, #8
    f31e:	0859      	lsrs	r1, r3, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f320:	4043      	eors	r3, r0
    f322:	f013 0f01 	tst.w	r3, #1
    crc=crcu8( (ee_u8) ((newval)>>8)    ,crc);
    f326:	fa5f fc80 	uxtb.w	ip, r0
           crc |= 0x8000;
    f32a:	ea81 0302 	eor.w	r3, r1, r2
    f32e:	bf08      	it	eq
    f330:	460b      	moveq	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f332:	ea83 045c 	eor.w	r4, r3, ip, lsr #1
    f336:	0858      	lsrs	r0, r3, #1
    f338:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f33c:	ea80 0302 	eor.w	r3, r0, r2
    f340:	bf08      	it	eq
    f342:	4603      	moveq	r3, r0
    f344:	085c      	lsrs	r4, r3, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f346:	ea83 019c 	eor.w	r1, r3, ip, lsr #2
    f34a:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    f34e:	ea84 0002 	eor.w	r0, r4, r2
    f352:	bf18      	it	ne
    f354:	4604      	movne	r4, r0
    f356:	0863      	lsrs	r3, r4, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f358:	ea84 01dc 	eor.w	r1, r4, ip, lsr #3
    f35c:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    f360:	ea83 0402 	eor.w	r4, r3, r2
    f364:	bf18      	it	ne
    f366:	4623      	movne	r3, r4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f368:	ea83 101c 	eor.w	r0, r3, ip, lsr #4
    f36c:	085b      	lsrs	r3, r3, #1
    f36e:	f010 0f01 	tst.w	r0, #1
           crc |= 0x8000;
    f372:	ea83 0102 	eor.w	r1, r3, r2
    f376:	bf18      	it	ne
    f378:	460b      	movne	r3, r1
    f37a:	0858      	lsrs	r0, r3, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f37c:	ea83 145c 	eor.w	r4, r3, ip, lsr #5
    f380:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f384:	ea80 0302 	eor.w	r3, r0, r2
    f388:	bf18      	it	ne
    f38a:	4618      	movne	r0, r3
    f38c:	0844      	lsrs	r4, r0, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f38e:	ea80 119c 	eor.w	r1, r0, ip, lsr #6
    f392:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    f396:	ea84 0002 	eor.w	r0, r4, r2
    f39a:	bf18      	it	ne
    f39c:	4604      	movne	r4, r0
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f39e:	ea84 11dc 	eor.w	r1, r4, ip, lsr #7
    f3a2:	0863      	lsrs	r3, r4, #1
    return crc;
    f3a4:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    f3a8:	ea83 0002 	eor.w	r0, r3, r2
}
    f3ac:	f85d 4b04 	ldr.w	r4, [sp], #4
    f3b0:	bf08      	it	eq
    f3b2:	4618      	moveq	r0, r3
    f3b4:	4770      	bx	lr
    f3b6:	bf00      	nop

0000f3b8 <crcu32>:
           crc |= 0x8000;
    f3b8:	f24a 0201 	movw	r2, #40961	; 0xa001
    f3bc:	084b      	lsrs	r3, r1, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f3be:	4041      	eors	r1, r0
    f3c0:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    f3c4:	ea83 0102 	eor.w	r1, r3, r2
    f3c8:	bf18      	it	ne
    f3ca:	460b      	movne	r3, r1
ee_u16 crcu32(ee_u32 newval, ee_u16 crc) {
    f3cc:	b430      	push	{r4, r5}
    crc=crcu8( (ee_u8) (newval)             ,crc);
    f3ce:	b2c5      	uxtb	r5, r0
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f3d0:	ea83 0455 	eor.w	r4, r3, r5, lsr #1
    f3d4:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    f3d6:	ea83 0c02 	eor.w	ip, r3, r2
    f3da:	f014 0f01 	tst.w	r4, #1
    f3de:	bf18      	it	ne
    f3e0:	4663      	movne	r3, ip
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f3e2:	ea83 0195 	eor.w	r1, r3, r5, lsr #2
    f3e6:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    f3e8:	ea83 0402 	eor.w	r4, r3, r2
    f3ec:	f011 0f01 	tst.w	r1, #1
    f3f0:	bf18      	it	ne
    f3f2:	4623      	movne	r3, r4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f3f4:	ea83 01d5 	eor.w	r1, r3, r5, lsr #3
    f3f8:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    f3fa:	ea83 0c02 	eor.w	ip, r3, r2
    f3fe:	f011 0f01 	tst.w	r1, #1
    f402:	bf18      	it	ne
    f404:	4663      	movne	r3, ip
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f406:	ea83 1415 	eor.w	r4, r3, r5, lsr #4
    f40a:	0859      	lsrs	r1, r3, #1
           crc |= 0x8000;
    f40c:	ea81 0302 	eor.w	r3, r1, r2
    f410:	f014 0f01 	tst.w	r4, #1
    f414:	bf18      	it	ne
    f416:	4619      	movne	r1, r3
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f418:	ea81 1c55 	eor.w	ip, r1, r5, lsr #5
    f41c:	0849      	lsrs	r1, r1, #1
           crc |= 0x8000;
    f41e:	ea81 0402 	eor.w	r4, r1, r2
    f422:	f01c 0f01 	tst.w	ip, #1
    f426:	bf18      	it	ne
    f428:	4621      	movne	r1, r4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f42a:	ea81 1c95 	eor.w	ip, r1, r5, lsr #6
    f42e:	084b      	lsrs	r3, r1, #1
           crc |= 0x8000;
    f430:	ea83 0102 	eor.w	r1, r3, r2
    f434:	f01c 0f01 	tst.w	ip, #1
    f438:	bf18      	it	ne
    f43a:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f43c:	ea83 15d5 	eor.w	r5, r3, r5, lsr #7
    f440:	f015 0f01 	tst.w	r5, #1
    f444:	ea4f 0353 	mov.w	r3, r3, lsr #1
           crc |= 0x8000;
    f448:	ea83 0402 	eor.w	r4, r3, r2
    crc=crcu8( (ee_u8) ((newval)>>8)    ,crc);
    f44c:	f3c0 2107 	ubfx	r1, r0, #8, #8
    f450:	bf08      	it	eq
    f452:	461c      	moveq	r4, r3
    f454:	0863      	lsrs	r3, r4, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f456:	404c      	eors	r4, r1
           crc |= 0x8000;
    f458:	ea83 0c02 	eor.w	ip, r3, r2
    f45c:	f014 0f01 	tst.w	r4, #1
    crc=crcu8( (ee_u8) ((newval)>>8)    ,crc);
    f460:	b2cd      	uxtb	r5, r1
    f462:	bf18      	it	ne
    f464:	4663      	movne	r3, ip
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f466:	ea83 0455 	eor.w	r4, r3, r5, lsr #1
    f46a:	0859      	lsrs	r1, r3, #1
           crc |= 0x8000;
    f46c:	ea81 0302 	eor.w	r3, r1, r2
    f470:	f014 0f01 	tst.w	r4, #1
    f474:	bf18      	it	ne
    f476:	4619      	movne	r1, r3
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f478:	ea81 0c95 	eor.w	ip, r1, r5, lsr #2
    f47c:	0849      	lsrs	r1, r1, #1
           crc |= 0x8000;
    f47e:	ea81 0402 	eor.w	r4, r1, r2
    f482:	f01c 0f01 	tst.w	ip, #1
    f486:	bf18      	it	ne
    f488:	4621      	movne	r1, r4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f48a:	ea81 0cd5 	eor.w	ip, r1, r5, lsr #3
    f48e:	084b      	lsrs	r3, r1, #1
           crc |= 0x8000;
    f490:	ea83 0102 	eor.w	r1, r3, r2
    f494:	f01c 0f01 	tst.w	ip, #1
    f498:	bf18      	it	ne
    f49a:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f49c:	ea83 1415 	eor.w	r4, r3, r5, lsr #4
    f4a0:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    f4a2:	ea83 0c02 	eor.w	ip, r3, r2
    f4a6:	f014 0f01 	tst.w	r4, #1
    f4aa:	bf18      	it	ne
    f4ac:	4663      	movne	r3, ip
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f4ae:	ea83 1155 	eor.w	r1, r3, r5, lsr #5
    f4b2:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    f4b4:	ea83 0402 	eor.w	r4, r3, r2
    f4b8:	f011 0f01 	tst.w	r1, #1
    f4bc:	bf18      	it	ne
    f4be:	4623      	movne	r3, r4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f4c0:	ea83 1195 	eor.w	r1, r3, r5, lsr #6
    f4c4:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    f4c6:	ea83 0c02 	eor.w	ip, r3, r2
    f4ca:	f011 0f01 	tst.w	r1, #1
    f4ce:	bf18      	it	ne
    f4d0:	4663      	movne	r3, ip
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f4d2:	ea83 15d5 	eor.w	r5, r3, r5, lsr #7
    f4d6:	085c      	lsrs	r4, r3, #1
    f4d8:	f015 0f01 	tst.w	r5, #1
           crc |= 0x8000;
    f4dc:	ea84 0102 	eor.w	r1, r4, r2
    crc=crc16((ee_s16) newval       ,crc);
    crc=crc16((ee_s16) (newval>>16) ,crc);
    f4e0:	ea4f 4010 	mov.w	r0, r0, lsr #16
    f4e4:	bf08      	it	eq
    f4e6:	4621      	moveq	r1, r4
    f4e8:	084b      	lsrs	r3, r1, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f4ea:	4041      	eors	r1, r0
           crc |= 0x8000;
    f4ec:	ea83 0c02 	eor.w	ip, r3, r2
    f4f0:	f011 0f01 	tst.w	r1, #1
    crc=crcu8( (ee_u8) (newval)             ,crc);
    f4f4:	b2c5      	uxtb	r5, r0
    f4f6:	bf18      	it	ne
    f4f8:	4663      	movne	r3, ip
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f4fa:	ea83 0455 	eor.w	r4, r3, r5, lsr #1
    f4fe:	0859      	lsrs	r1, r3, #1
           crc |= 0x8000;
    f500:	ea81 0302 	eor.w	r3, r1, r2
    f504:	f014 0f01 	tst.w	r4, #1
    f508:	bf18      	it	ne
    f50a:	4619      	movne	r1, r3
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f50c:	ea81 0c95 	eor.w	ip, r1, r5, lsr #2
    f510:	0849      	lsrs	r1, r1, #1
           crc |= 0x8000;
    f512:	ea81 0402 	eor.w	r4, r1, r2
    f516:	f01c 0f01 	tst.w	ip, #1
    f51a:	bf18      	it	ne
    f51c:	4621      	movne	r1, r4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f51e:	ea81 0cd5 	eor.w	ip, r1, r5, lsr #3
    f522:	084b      	lsrs	r3, r1, #1
           crc |= 0x8000;
    f524:	ea83 0102 	eor.w	r1, r3, r2
    f528:	f01c 0f01 	tst.w	ip, #1
    f52c:	bf18      	it	ne
    f52e:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f530:	ea83 1415 	eor.w	r4, r3, r5, lsr #4
    f534:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    f536:	ea83 0c02 	eor.w	ip, r3, r2
    f53a:	f014 0f01 	tst.w	r4, #1
    f53e:	bf18      	it	ne
    f540:	4663      	movne	r3, ip
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f542:	ea83 1155 	eor.w	r1, r3, r5, lsr #5
    f546:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    f548:	ea83 0402 	eor.w	r4, r3, r2
    f54c:	f011 0f01 	tst.w	r1, #1
    f550:	bf18      	it	ne
    f552:	4623      	movne	r3, r4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f554:	ea83 1195 	eor.w	r1, r3, r5, lsr #6
    f558:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    f55a:	ea83 0c02 	eor.w	ip, r3, r2
    f55e:	f011 0f01 	tst.w	r1, #1
    f562:	bf18      	it	ne
    f564:	4663      	movne	r3, ip
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f566:	ea83 15d5 	eor.w	r5, r3, r5, lsr #7
    f56a:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    f56c:	ea83 0402 	eor.w	r4, r3, r2
    f570:	f015 0f01 	tst.w	r5, #1
    crc=crcu8( (ee_u8) ((newval)>>8)    ,crc);
    f574:	ea4f 2010 	mov.w	r0, r0, lsr #8
    f578:	bf18      	it	ne
    f57a:	4623      	movne	r3, r4
    f57c:	085d      	lsrs	r5, r3, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f57e:	4043      	eors	r3, r0
    f580:	f013 0f01 	tst.w	r3, #1
           crc |= 0x8000;
    f584:	ea85 0102 	eor.w	r1, r5, r2
    crc=crcu8( (ee_u8) ((newval)>>8)    ,crc);
    f588:	fa5f fc80 	uxtb.w	ip, r0
    f58c:	bf14      	ite	ne
    f58e:	4608      	movne	r0, r1
    f590:	4628      	moveq	r0, r5
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f592:	ea80 035c 	eor.w	r3, r0, ip, lsr #1
    f596:	0844      	lsrs	r4, r0, #1
    f598:	f013 0f01 	tst.w	r3, #1
           crc |= 0x8000;
    f59c:	ea84 0002 	eor.w	r0, r4, r2
    f5a0:	bf08      	it	eq
    f5a2:	4620      	moveq	r0, r4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f5a4:	ea80 059c 	eor.w	r5, r0, ip, lsr #2
    f5a8:	0843      	lsrs	r3, r0, #1
    f5aa:	f015 0f01 	tst.w	r5, #1
           crc |= 0x8000;
    f5ae:	ea83 0102 	eor.w	r1, r3, r2
    f5b2:	bf08      	it	eq
    f5b4:	4619      	moveq	r1, r3
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f5b6:	ea81 04dc 	eor.w	r4, r1, ip, lsr #3
    f5ba:	084d      	lsrs	r5, r1, #1
    f5bc:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f5c0:	ea85 0002 	eor.w	r0, r5, r2
    f5c4:	bf08      	it	eq
    f5c6:	4628      	moveq	r0, r5
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f5c8:	ea80 131c 	eor.w	r3, r0, ip, lsr #4
    f5cc:	0841      	lsrs	r1, r0, #1
    f5ce:	f013 0f01 	tst.w	r3, #1
           crc |= 0x8000;
    f5d2:	ea81 0402 	eor.w	r4, r1, r2
    f5d6:	bf08      	it	eq
    f5d8:	460c      	moveq	r4, r1
    f5da:	0860      	lsrs	r0, r4, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f5dc:	ea84 155c 	eor.w	r5, r4, ip, lsr #5
    f5e0:	f015 0f01 	tst.w	r5, #1
           crc |= 0x8000;
    f5e4:	ea80 0302 	eor.w	r3, r0, r2
    f5e8:	bf18      	it	ne
    f5ea:	4618      	movne	r0, r3
    f5ec:	0844      	lsrs	r4, r0, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f5ee:	ea80 119c 	eor.w	r1, r0, ip, lsr #6
           crc |= 0x8000;
    f5f2:	ea84 0502 	eor.w	r5, r4, r2
    f5f6:	f011 0f01 	tst.w	r1, #1
    f5fa:	bf18      	it	ne
    f5fc:	462c      	movne	r4, r5
    f5fe:	0860      	lsrs	r0, r4, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f600:	ea84 1cdc 	eor.w	ip, r4, ip, lsr #7
    return crc;
    f604:	f01c 0f01 	tst.w	ip, #1
           crc |= 0x8000;
    f608:	ea82 0200 	eor.w	r2, r2, r0
}
    f60c:	bf18      	it	ne
    f60e:	4610      	movne	r0, r2
    f610:	bc30      	pop	{r4, r5}
    f612:	4770      	bx	lr

0000f614 <crc16>:
           crc |= 0x8000;
    f614:	f24a 0201 	movw	r2, #40961	; 0xa001
    f618:	084b      	lsrs	r3, r1, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f61a:	4041      	eors	r1, r0
    f61c:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    f620:	ea83 0102 	eor.w	r1, r3, r2
    crc=crcu8( (ee_u8) (newval)             ,crc);
    f624:	fa5f fc80 	uxtb.w	ip, r0
    f628:	bf18      	it	ne
    f62a:	460b      	movne	r3, r1
ee_u16 crc16(ee_s16 newval, ee_u16 crc) {
    f62c:	b410      	push	{r4}
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f62e:	ea83 045c 	eor.w	r4, r3, ip, lsr #1
    f632:	085b      	lsrs	r3, r3, #1
    f634:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f638:	ea83 0102 	eor.w	r1, r3, r2
    f63c:	bf18      	it	ne
    f63e:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f640:	ea83 049c 	eor.w	r4, r3, ip, lsr #2
    f644:	085b      	lsrs	r3, r3, #1
    f646:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f64a:	ea83 0102 	eor.w	r1, r3, r2
    f64e:	bf18      	it	ne
    f650:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f652:	ea83 04dc 	eor.w	r4, r3, ip, lsr #3
    f656:	085b      	lsrs	r3, r3, #1
    f658:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f65c:	ea83 0102 	eor.w	r1, r3, r2
    f660:	bf18      	it	ne
    f662:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f664:	ea83 141c 	eor.w	r4, r3, ip, lsr #4
    f668:	085b      	lsrs	r3, r3, #1
    f66a:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f66e:	ea83 0102 	eor.w	r1, r3, r2
    f672:	bf18      	it	ne
    f674:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f676:	ea83 145c 	eor.w	r4, r3, ip, lsr #5
    f67a:	085b      	lsrs	r3, r3, #1
    f67c:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f680:	ea83 0102 	eor.w	r1, r3, r2
    f684:	bf18      	it	ne
    f686:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f688:	ea83 149c 	eor.w	r4, r3, ip, lsr #6
    f68c:	085b      	lsrs	r3, r3, #1
    f68e:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f692:	ea83 0102 	eor.w	r1, r3, r2
    f696:	bf18      	it	ne
    f698:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f69a:	ea83 14dc 	eor.w	r4, r3, ip, lsr #7
    f69e:	085b      	lsrs	r3, r3, #1
    f6a0:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f6a4:	ea83 0c02 	eor.w	ip, r3, r2
    f6a8:	bf18      	it	ne
    f6aa:	4663      	movne	r3, ip
    crc=crcu8( (ee_u8) ((newval)>>8)    ,crc);
    f6ac:	f3c0 2007 	ubfx	r0, r0, #8, #8
    f6b0:	0859      	lsrs	r1, r3, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f6b2:	4043      	eors	r3, r0
    f6b4:	f013 0f01 	tst.w	r3, #1
    crc=crcu8( (ee_u8) ((newval)>>8)    ,crc);
    f6b8:	fa5f fc80 	uxtb.w	ip, r0
           crc |= 0x8000;
    f6bc:	ea81 0302 	eor.w	r3, r1, r2
    f6c0:	bf08      	it	eq
    f6c2:	460b      	moveq	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f6c4:	ea83 045c 	eor.w	r4, r3, ip, lsr #1
    f6c8:	0858      	lsrs	r0, r3, #1
    f6ca:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f6ce:	ea80 0302 	eor.w	r3, r0, r2
    f6d2:	bf08      	it	eq
    f6d4:	4603      	moveq	r3, r0
    f6d6:	085c      	lsrs	r4, r3, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f6d8:	ea83 019c 	eor.w	r1, r3, ip, lsr #2
    f6dc:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    f6e0:	ea84 0002 	eor.w	r0, r4, r2
    f6e4:	bf18      	it	ne
    f6e6:	4604      	movne	r4, r0
    f6e8:	0863      	lsrs	r3, r4, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f6ea:	ea84 01dc 	eor.w	r1, r4, ip, lsr #3
    f6ee:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    f6f2:	ea83 0402 	eor.w	r4, r3, r2
    f6f6:	bf18      	it	ne
    f6f8:	4623      	movne	r3, r4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f6fa:	ea83 101c 	eor.w	r0, r3, ip, lsr #4
    f6fe:	085b      	lsrs	r3, r3, #1
    f700:	f010 0f01 	tst.w	r0, #1
           crc |= 0x8000;
    f704:	ea83 0102 	eor.w	r1, r3, r2
    f708:	bf18      	it	ne
    f70a:	460b      	movne	r3, r1
    f70c:	0858      	lsrs	r0, r3, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f70e:	ea83 145c 	eor.w	r4, r3, ip, lsr #5
    f712:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    f716:	ea80 0302 	eor.w	r3, r0, r2
    f71a:	bf18      	it	ne
    f71c:	4618      	movne	r0, r3
    f71e:	0844      	lsrs	r4, r0, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f720:	ea80 119c 	eor.w	r1, r0, ip, lsr #6
    f724:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    f728:	ea84 0002 	eor.w	r0, r4, r2
    f72c:	bf18      	it	ne
    f72e:	4604      	movne	r4, r0
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    f730:	ea84 11dc 	eor.w	r1, r4, ip, lsr #7
    f734:	0863      	lsrs	r3, r4, #1
    return crcu16((ee_u16)newval, crc);
    f736:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    f73a:	ea83 0002 	eor.w	r0, r3, r2
}
    f73e:	f85d 4b04 	ldr.w	r4, [sp], #4
    f742:	bf08      	it	eq
    f744:	4618      	moveq	r0, r3
    f746:	4770      	bx	lr

0000f748 <check_data_types>:
    }
    if (retval>0) {
        ee_printf("ERROR: Please modify the datatypes in core_portme.h!\n");
    }
    return retval;
}
    f748:	2000      	movs	r0, #0
    f74a:	4770      	bx	lr

0000f74c <NMI_Handler>:
#if AM_CMSIS_REGS
NMI_Handler(void)
#else // AM_CMSIS_REGS
am_nmi_isr(void)
#endif // AM_CMSIS_REGS
{
    f74c:	e7fe      	b.n	f74c <NMI_Handler>
    f74e:	bf00      	nop

0000f750 <DebugMon_Handler>:
// for examination by a debugger.
//
//*****************************************************************************
void
am_default_isr(void)
{
    f750:	e7fe      	b.n	f750 <DebugMon_Handler>
    f752:	bf00      	nop

0000f754 <Reset_Handler>:
    __asm("    ldr    r0, =0xE000ED08\n"
    f754:	4811      	ldr	r0, [pc, #68]	; (f79c <zero_loop+0x12>)
    f756:	4912      	ldr	r1, [pc, #72]	; (f7a0 <zero_loop+0x16>)
    f758:	6001      	str	r1, [r0, #0]
    __asm("    ldr    sp, [r1]");
    f75a:	f8d1 d000 	ldr.w	sp, [r1]
    __asm("ldr  r0, =0xE000ED88\n"
    f75e:	4811      	ldr	r0, [pc, #68]	; (f7a4 <zero_loop+0x1a>)
    f760:	6801      	ldr	r1, [r0, #0]
    f762:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    f766:	6001      	str	r1, [r0, #0]
    f768:	f3bf 8f4f 	dsb	sy
    f76c:	f3bf 8f6f 	isb	sy
    __asm("    ldr     r0, =_init_data\n"
    f770:	480d      	ldr	r0, [pc, #52]	; (f7a8 <zero_loop+0x1e>)
    f772:	490e      	ldr	r1, [pc, #56]	; (f7ac <zero_loop+0x22>)
    f774:	4a0e      	ldr	r2, [pc, #56]	; (f7b0 <zero_loop+0x26>)

0000f776 <copy_loop>:
    f776:	f850 3b04 	ldr.w	r3, [r0], #4
    f77a:	f841 3b04 	str.w	r3, [r1], #4
    f77e:	4291      	cmp	r1, r2
    f780:	dbf9      	blt.n	f776 <copy_loop>
    __asm("    ldr     r0, =_sbss\n"
    f782:	480c      	ldr	r0, [pc, #48]	; (f7b4 <zero_loop+0x2a>)
    f784:	490c      	ldr	r1, [pc, #48]	; (f7b8 <zero_loop+0x2e>)
    f786:	f04f 0200 	mov.w	r2, #0

0000f78a <zero_loop>:
    f78a:	4288      	cmp	r0, r1
    f78c:	bfb8      	it	lt
    f78e:	f840 2b04 	strlt.w	r2, [r0], #4
    f792:	dbfa      	blt.n	f78a <zero_loop>
    main();
    f794:	f7fd fe1a 	bl	d3cc <main>
    __asm("    bkpt     ");
    f798:	be00      	bkpt	0x0000
    f79a:	0000      	.short	0x0000
    f79c:	e000ed08 	.word	0xe000ed08
    f7a0:	0000c000 	.word	0x0000c000
    f7a4:	e000ed88 	.word	0xe000ed88
    f7a8:	000133d0 	.word	0x000133d0
    f7ac:	10001000 	.word	0x10001000
    f7b0:	10001018 	.word	0x10001018
    f7b4:	10001018 	.word	0x10001018
    f7b8:	1000161c 	.word	0x1000161c

0000f7bc <HardFault_Handler>:
}
#elif defined(__GNUC_STDC_INLINE__)
uint32_t __attribute__((naked))
HardFault_Handler(void)
{
    __asm("    push    {r7,lr}");
    f7bc:	b580      	push	{r7, lr}
    __asm("    mov     r0, sp");
    f7be:	4668      	mov	r0, sp
    __asm("    adds    r0, #(2*4)");
    f7c0:	3008      	adds	r0, #8
    __asm("    bl      am_util_faultisr_collect_data");
    f7c2:	f000 f805 	bl	f7d0 <am_util_faultisr_collect_data>
    __asm("    pop     {r0,pc}");
    f7c6:	bd01      	pop	{r0, pc}

0000f7c8 <getStackedReg>:
}

uint32_t __attribute__((naked))
getStackedReg(uint32_t regnum, uint32_t u32SP)
{
    __asm("    lsls    r0, r0, #2");
    f7c8:	0080      	lsls	r0, r0, #2
    __asm("    adds    r0, r1");
    f7ca:	1840      	adds	r0, r0, r1
    __asm("    ldr     r0, [r0]");
    f7cc:	6800      	ldr	r0, [r0, #0]
    __asm("    bx      lr");
    f7ce:	4770      	bx	lr

0000f7d0 <am_util_faultisr_collect_data>:
// HardFault_Handler() was called.
//
//*****************************************************************************
void
am_util_faultisr_collect_data(uint32_t u32IsrSP)
{
    f7d0:	b500      	push	{lr}
    f7d2:	b093      	sub	sp, #76	; 0x4c
    volatile am_fault_t sFaultData;
    am_hal_mcuctrl_fault_t sHalFaultData = {0};
    f7d4:	2300      	movs	r3, #0
    // a breakpoint at the end of the routine.  If the printing is not used,
    // we'll get a compiler warning; so to avoid that warning, we'll use it
    // in a dummy assignment here.
    //
    sFaultData.u32CFSR = u32Mask;       // Avoid compiler warning
    sFaultData.u32CFSR = AM_REGVAL(AM_REG_SYSCTRL_CFSR_O);
    f7d6:	4a2e      	ldr	r2, [pc, #184]	; (f890 <am_util_faultisr_collect_data+0xc0>)
    sFaultData.u32CFSR = u32Mask;       // Avoid compiler warning
    f7d8:	9310      	str	r3, [sp, #64]	; 0x40
    am_hal_mcuctrl_fault_t sHalFaultData = {0};
    f7da:	9301      	str	r3, [sp, #4]
    f7dc:	9300      	str	r3, [sp, #0]
    f7de:	9302      	str	r3, [sp, #8]
    f7e0:	9303      	str	r3, [sp, #12]
    f7e2:	9304      	str	r3, [sp, #16]
    f7e4:	9305      	str	r3, [sp, #20]
    sFaultData.u32CFSR = AM_REGVAL(AM_REG_SYSCTRL_CFSR_O);
    f7e6:	6811      	ldr	r1, [r2, #0]
    f7e8:	9110      	str	r1, [sp, #64]	; 0x40
    sFaultData.u8MMSR  = (sFaultData.u32CFSR >> 0)  & 0xff;
    f7ea:	9b10      	ldr	r3, [sp, #64]	; 0x40
    f7ec:	b2d9      	uxtb	r1, r3
    f7ee:	f88d 1044 	strb.w	r1, [sp, #68]	; 0x44
    sFaultData.u8BFSR  = (sFaultData.u32CFSR >> 8)  & 0xff;
    f7f2:	9b10      	ldr	r3, [sp, #64]	; 0x40
    f7f4:	f3c3 2107 	ubfx	r1, r3, #8, #8
    f7f8:	f88d 1045 	strb.w	r1, [sp, #69]	; 0x45
    sFaultData.u16UFSR = (sFaultData.u32CFSR >> 16) & 0xffff;
    f7fc:	9b10      	ldr	r3, [sp, #64]	; 0x40
    f7fe:	0c19      	lsrs	r1, r3, #16
    f800:	f8ad 1046 	strh.w	r1, [sp, #70]	; 0x46

    //
    // The address of the location that caused the fault.  e.g. if accessing an
    // invalid data location caused the fault, that address will appear here.
    //
    sFaultData.u32BFAR = AM_REGVAL(AM_REG_SYSCTRL_BFAR_O);
    f804:	6912      	ldr	r2, [r2, #16]
    f806:	920f      	str	r2, [sp, #60]	; 0x3c

    //
    // The address of the instruction that caused the fault is the stacked PC
    // if BFSR bit1 is set.
    //
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    f808:	f89d 1045 	ldrb.w	r1, [sp, #69]	; 0x45
    f80c:	078a      	lsls	r2, r1, #30
{
    f80e:	4603      	mov	r3, r0
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    f810:	d437      	bmi.n	f882 <am_util_faultisr_collect_data+0xb2>
    f812:	f04f 32ff 	mov.w	r2, #4294967295

    //
    // Get the stacked registers.
    // Note - the address of the instruction that caused the fault is u32PC.
    //
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    f816:	4619      	mov	r1, r3
    f818:	2000      	movs	r0, #0
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    f81a:	920e      	str	r2, [sp, #56]	; 0x38
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    f81c:	f7ff ffd4 	bl	f7c8 <getStackedReg>
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    f820:	4619      	mov	r1, r3
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    f822:	4602      	mov	r2, r0
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    f824:	2001      	movs	r0, #1
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    f826:	9206      	str	r2, [sp, #24]
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    f828:	f7ff ffce 	bl	f7c8 <getStackedReg>
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    f82c:	4619      	mov	r1, r3
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    f82e:	4602      	mov	r2, r0
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    f830:	2002      	movs	r0, #2
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    f832:	9207      	str	r2, [sp, #28]
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    f834:	f7ff ffc8 	bl	f7c8 <getStackedReg>
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    f838:	4619      	mov	r1, r3
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    f83a:	4602      	mov	r2, r0
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    f83c:	2003      	movs	r0, #3
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    f83e:	9208      	str	r2, [sp, #32]
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    f840:	f7ff ffc2 	bl	f7c8 <getStackedReg>
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    f844:	4619      	mov	r1, r3
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    f846:	4602      	mov	r2, r0
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    f848:	2004      	movs	r0, #4
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    f84a:	9209      	str	r2, [sp, #36]	; 0x24
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    f84c:	f7ff ffbc 	bl	f7c8 <getStackedReg>
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    f850:	4619      	mov	r1, r3
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    f852:	4602      	mov	r2, r0
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    f854:	2005      	movs	r0, #5
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    f856:	920a      	str	r2, [sp, #40]	; 0x28
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    f858:	f7ff ffb6 	bl	f7c8 <getStackedReg>
    f85c:	4602      	mov	r2, r0
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    f85e:	4619      	mov	r1, r3
    f860:	2006      	movs	r0, #6
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    f862:	920b      	str	r2, [sp, #44]	; 0x2c
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    f864:	f7ff ffb0 	bl	f7c8 <getStackedReg>
    f868:	4602      	mov	r2, r0
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    f86a:	4619      	mov	r1, r3
    f86c:	2007      	movs	r0, #7
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    f86e:	920c      	str	r2, [sp, #48]	; 0x30
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    f870:	f7ff ffaa 	bl	f7c8 <getStackedReg>

    //
    // Use the HAL MCUCTRL functions to read the fault data.
    //
#ifdef AM_APOLLO3_MCUCTRL
    am_hal_mcuctrl_info_get(AM_HAL_MCUCTRL_INFO_FAULT_STATUS, &sHalFaultData);
    f874:	4669      	mov	r1, sp
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    f876:	4603      	mov	r3, r0
    am_hal_mcuctrl_info_get(AM_HAL_MCUCTRL_INFO_FAULT_STATUS, &sHalFaultData);
    f878:	2002      	movs	r0, #2
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    f87a:	930d      	str	r3, [sp, #52]	; 0x34
    am_hal_mcuctrl_info_get(AM_HAL_MCUCTRL_INFO_FAULT_STATUS, &sHalFaultData);
    f87c:	f001 fe88 	bl	11590 <am_hal_mcuctrl_info_get>
    f880:	e7fe      	b.n	f880 <am_util_faultisr_collect_data+0xb0>
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    f882:	4601      	mov	r1, r0
    f884:	2006      	movs	r0, #6
    f886:	f7ff ff9f 	bl	f7c8 <getStackedReg>
    f88a:	4602      	mov	r2, r0
    f88c:	e7c3      	b.n	f816 <am_util_faultisr_collect_data+0x46>
    f88e:	bf00      	nop
    f890:	e000ed28 	.word	0xe000ed28

0000f894 <uint64_to_str>:
// written).
//
//*****************************************************************************
static int
uint64_to_str(uint64_t ui64Val, char *pcBuf)
{
    f894:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f898:	b095      	sub	sp, #84	; 0x54
    f89a:	f10d 0e34 	add.w	lr, sp, #52	; 0x34
    f89e:	4604      	mov	r4, r0
        //
        // Get modulus
        //
        uMod = ui64Val - (u64Tmp * 10);

        tbuf[ix++] = uMod + '0';
    f8a0:	2001      	movs	r0, #1
{
    f8a2:	460d      	mov	r5, r1
    f8a4:	920b      	str	r2, [sp, #44]	; 0x2c
    f8a6:	46f4      	mov	ip, lr
    f8a8:	900a      	str	r0, [sp, #40]	; 0x28
    f8aa:	e00b      	b.n	f8c4 <uint64_to_str+0x30>
        tbuf[ix++] = uMod + '0';
    f8ac:	f88c 3000 	strb.w	r3, [ip]
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    f8b0:	4604      	mov	r4, r0
    f8b2:	2500      	movs	r5, #0
        ui64Val = u64Tmp;
    } while ( ui64Val );
    f8b4:	2800      	cmp	r0, #0
    f8b6:	f000 8083 	beq.w	f9c0 <uint64_to_str+0x12c>
    f8ba:	990a      	ldr	r1, [sp, #40]	; 0x28
    f8bc:	3101      	adds	r1, #1
    f8be:	910a      	str	r1, [sp, #40]	; 0x28
    f8c0:	f10c 0c01 	add.w	ip, ip, #1
        q32 = (ui32Val>>1) + (ui32Val>>2);
    f8c4:	08a3      	lsrs	r3, r4, #2
    f8c6:	eb03 0154 	add.w	r1, r3, r4, lsr #1
        q32 += (q32 >> 4);
    f8ca:	eb01 1211 	add.w	r2, r1, r1, lsr #4
        q32 += (q32 >> 8);
    f8ce:	eb02 2612 	add.w	r6, r2, r2, lsr #8
        q32 += (q32 >> 16);
    f8d2:	eb06 4716 	add.w	r7, r6, r6, lsr #16
        q32 >>= 3;
    f8d6:	08f8      	lsrs	r0, r7, #3
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    f8d8:	1da3      	adds	r3, r4, #6
        r32 = ui32Val - q32*10;
    f8da:	eb00 0880 	add.w	r8, r0, r0, lsl #2
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    f8de:	eba3 0148 	sub.w	r1, r3, r8, lsl #1
    f8e2:	eb00 1011 	add.w	r0, r0, r1, lsr #4
    if ( ui64Val >> 32 )
    f8e6:	462e      	mov	r6, r5
        uMod = ui64Val - (u64Tmp * 10);
    f8e8:	eb00 0280 	add.w	r2, r0, r0, lsl #2
    if ( ui64Val >> 32 )
    f8ec:	2700      	movs	r7, #0
        uMod = ui64Val - (u64Tmp * 10);
    f8ee:	eba4 0342 	sub.w	r3, r4, r2, lsl #1
    if ( ui64Val >> 32 )
    f8f2:	ea56 0107 	orrs.w	r1, r6, r7
        tbuf[ix++] = uMod + '0';
    f8f6:	f103 0330 	add.w	r3, r3, #48	; 0x30
    if ( ui64Val >> 32 )
    f8fa:	d0d7      	beq.n	f8ac <uint64_to_str+0x18>
        q64 = (ui64Val>>1) + (ui64Val>>2);
    f8fc:	08a0      	lsrs	r0, r4, #2
    f8fe:	ea40 7385 	orr.w	r3, r0, r5, lsl #30
    f902:	08ae      	lsrs	r6, r5, #2
    f904:	9304      	str	r3, [sp, #16]
    f906:	9605      	str	r6, [sp, #20]
    f908:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    f90c:	086b      	lsrs	r3, r5, #1
    f90e:	ea4f 0234 	mov.w	r2, r4, rrx
    f912:	1882      	adds	r2, r0, r2
    f914:	eb41 0303 	adc.w	r3, r1, r3
        q64 += (q64 >> 4);
    f918:	0911      	lsrs	r1, r2, #4
    f91a:	ea41 7003 	orr.w	r0, r1, r3, lsl #28
    f91e:	1812      	adds	r2, r2, r0
    f920:	ea4f 1613 	mov.w	r6, r3, lsr #4
    f924:	4173      	adcs	r3, r6
        q64 += (q64 >> 8);
    f926:	0a11      	lsrs	r1, r2, #8
    f928:	ea41 6003 	orr.w	r0, r1, r3, lsl #24
    f92c:	0a1e      	lsrs	r6, r3, #8
    f92e:	9601      	str	r6, [sp, #4]
    f930:	9000      	str	r0, [sp, #0]
    f932:	e9dd 0100 	ldrd	r0, r1, [sp]
    f936:	1882      	adds	r2, r0, r2
    f938:	4616      	mov	r6, r2
    f93a:	eb41 0303 	adc.w	r3, r1, r3
        q64 += (q64 >> 16);
    f93e:	0c31      	lsrs	r1, r6, #16
        q64 += (q64 >> 8);
    f940:	461a      	mov	r2, r3
        q64 += (q64 >> 16);
    f942:	ea41 4003 	orr.w	r0, r1, r3, lsl #16
    f946:	0c1b      	lsrs	r3, r3, #16
    f948:	9303      	str	r3, [sp, #12]
    f94a:	9002      	str	r0, [sp, #8]
    f94c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    f950:	eb10 0806 	adds.w	r8, r0, r6
    f954:	eb41 0302 	adc.w	r3, r1, r2
        q64 += (q64 >> 32);
    f958:	9308      	str	r3, [sp, #32]
    f95a:	9709      	str	r7, [sp, #36]	; 0x24
    f95c:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
    f960:	eb10 0208 	adds.w	r2, r0, r8
    f964:	eb41 0303 	adc.w	r3, r1, r3
        q64 >>= 3;
    f968:	08d1      	lsrs	r1, r2, #3
    f96a:	ea41 7643 	orr.w	r6, r1, r3, lsl #29
    f96e:	08df      	lsrs	r7, r3, #3
        r64 = ui64Val - q64*10;
    f970:	00b8      	lsls	r0, r7, #2
    f972:	ea4f 0a86 	mov.w	sl, r6, lsl #2
    f976:	eb1a 0906 	adds.w	r9, sl, r6
    f97a:	ea40 7896 	orr.w	r8, r0, r6, lsr #30
    f97e:	eb48 0307 	adc.w	r3, r8, r7
    f982:	eb19 0209 	adds.w	r2, r9, r9
    f986:	415b      	adcs	r3, r3
        return q64 + ((r64 + 6) >> 4);
    f988:	f114 0b06 	adds.w	fp, r4, #6
    f98c:	f145 0500 	adc.w	r5, r5, #0
    f990:	ebbb 0202 	subs.w	r2, fp, r2
    f994:	eb65 0303 	sbc.w	r3, r5, r3
    f998:	0915      	lsrs	r5, r2, #4
    f99a:	ea45 7203 	orr.w	r2, r5, r3, lsl #28
    f99e:	091b      	lsrs	r3, r3, #4
    f9a0:	9206      	str	r2, [sp, #24]
    f9a2:	9307      	str	r3, [sp, #28]
    f9a4:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    f9a8:	1996      	adds	r6, r2, r6
    f9aa:	eb43 0507 	adc.w	r5, r3, r7
        uMod = ui64Val - (u64Tmp * 10);
    f9ae:	eb06 0786 	add.w	r7, r6, r6, lsl #2
    f9b2:	eba4 0447 	sub.w	r4, r4, r7, lsl #1
        tbuf[ix++] = uMod + '0';
    f9b6:	3430      	adds	r4, #48	; 0x30
    f9b8:	f88c 4000 	strb.w	r4, [ip]
    f9bc:	4634      	mov	r4, r6
    f9be:	e77c      	b.n	f8ba <uint64_to_str+0x26>
    iNumDig = ix;

    //
    // Now, reverse the buffer when saving to the caller's buffer.
    //
    if ( pcBuf )
    f9c0:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
    f9c2:	980a      	ldr	r0, [sp, #40]	; 0x28
    f9c4:	2e00      	cmp	r6, #0
    f9c6:	d059      	beq.n	fa7c <uint64_to_str+0x1e8>
    f9c8:	eb0e 0a00 	add.w	sl, lr, r0
    f9cc:	46d3      	mov	fp, sl
    f9ce:	ea6f 0c0e 	mvn.w	ip, lr
    {
        while ( ix-- )
        {
            *pcBuf++ = tbuf[ix];
    f9d2:	f81b 7d01 	ldrb.w	r7, [fp, #-1]!
    f9d6:	7037      	strb	r7, [r6, #0]
    f9d8:	44d4      	add	ip, sl
        while ( ix-- )
    f9da:	45de      	cmp	lr, fp
    f9dc:	4632      	mov	r2, r6
    f9de:	f00c 0107 	and.w	r1, ip, #7
    f9e2:	bf08      	it	eq
    f9e4:	4632      	moveq	r2, r6
    f9e6:	d047      	beq.n	fa78 <uint64_to_str+0x1e4>
    f9e8:	b349      	cbz	r1, fa3e <uint64_to_str+0x1aa>
    f9ea:	2901      	cmp	r1, #1
    f9ec:	d021      	beq.n	fa32 <uint64_to_str+0x19e>
    f9ee:	2902      	cmp	r1, #2
    f9f0:	d01b      	beq.n	fa2a <uint64_to_str+0x196>
    f9f2:	2903      	cmp	r1, #3
    f9f4:	d015      	beq.n	fa22 <uint64_to_str+0x18e>
    f9f6:	2904      	cmp	r1, #4
    f9f8:	d00f      	beq.n	fa1a <uint64_to_str+0x186>
    f9fa:	2905      	cmp	r1, #5
    f9fc:	d009      	beq.n	fa12 <uint64_to_str+0x17e>
    f9fe:	2906      	cmp	r1, #6
            *pcBuf++ = tbuf[ix];
    fa00:	bf1c      	itt	ne
    fa02:	f81b 1d01 	ldrbne.w	r1, [fp, #-1]!
    fa06:	f802 1f01 	strbne.w	r1, [r2, #1]!
    fa0a:	f81b 3d01 	ldrb.w	r3, [fp, #-1]!
    fa0e:	f802 3f01 	strb.w	r3, [r2, #1]!
    fa12:	f81b 6d01 	ldrb.w	r6, [fp, #-1]!
    fa16:	f802 6f01 	strb.w	r6, [r2, #1]!
    fa1a:	f81b 4d01 	ldrb.w	r4, [fp, #-1]!
    fa1e:	f802 4f01 	strb.w	r4, [r2, #1]!
    fa22:	f81b 7d01 	ldrb.w	r7, [fp, #-1]!
    fa26:	f802 7f01 	strb.w	r7, [r2, #1]!
    fa2a:	f81b 5d01 	ldrb.w	r5, [fp, #-1]!
    fa2e:	f802 5f01 	strb.w	r5, [r2, #1]!
    fa32:	f81b 8d01 	ldrb.w	r8, [fp, #-1]!
    fa36:	f802 8f01 	strb.w	r8, [r2, #1]!
        while ( ix-- )
    fa3a:	45de      	cmp	lr, fp
    fa3c:	d01b      	beq.n	fa76 <uint64_to_str+0x1e2>
            *pcBuf++ = tbuf[ix];
    fa3e:	f81b 1c01 	ldrb.w	r1, [fp, #-1]
    fa42:	f81b 3c02 	ldrb.w	r3, [fp, #-2]
    fa46:	f81b 9c03 	ldrb.w	r9, [fp, #-3]
    fa4a:	f81b 7c04 	ldrb.w	r7, [fp, #-4]
    fa4e:	f81b 6c05 	ldrb.w	r6, [fp, #-5]
    fa52:	f81b 5c06 	ldrb.w	r5, [fp, #-6]
    fa56:	f81b 4c07 	ldrb.w	r4, [fp, #-7]
    fa5a:	f81b ad08 	ldrb.w	sl, [fp, #-8]!
    fa5e:	7051      	strb	r1, [r2, #1]
        while ( ix-- )
    fa60:	45de      	cmp	lr, fp
            *pcBuf++ = tbuf[ix];
    fa62:	7093      	strb	r3, [r2, #2]
    fa64:	f882 9003 	strb.w	r9, [r2, #3]
    fa68:	7117      	strb	r7, [r2, #4]
    fa6a:	7156      	strb	r6, [r2, #5]
    fa6c:	7195      	strb	r5, [r2, #6]
    fa6e:	71d4      	strb	r4, [r2, #7]
    fa70:	f802 af08 	strb.w	sl, [r2, #8]!
        while ( ix-- )
    fa74:	d1e3      	bne.n	fa3e <uint64_to_str+0x1aa>
    fa76:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
        }

        //
        // Terminate the caller's buffer
        //
        *pcBuf = 0x00;
    fa78:	2100      	movs	r1, #0
    fa7a:	5411      	strb	r1, [r2, r0]
    }

    return iNumDig;
}
    fa7c:	b015      	add	sp, #84	; 0x54
    fa7e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    fa82:	bf00      	nop

0000fa84 <am_util_stdio_printf_init>:
    g_pfnCharPrint = pfnCharPrint;
    fa84:	4b01      	ldr	r3, [pc, #4]	; (fa8c <am_util_stdio_printf_init+0x8>)
    fa86:	6018      	str	r0, [r3, #0]
    fa88:	4770      	bx	lr
    fa8a:	bf00      	nop
    fa8c:	10001550 	.word	0x10001550

0000fa90 <am_util_stdio_vsprintf>:
//! @return uint32_t representing the number of characters printed.
//
//******************************************************************************
uint32_t
am_util_stdio_vsprintf(char *pcBuf, const char *pcFmt, va_list pArgs)
{
    fa90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    fa94:	4680      	mov	r8, r0
    fa96:	b0b1      	sub	sp, #196	; 0xc4
    fa98:	4693      	mov	fp, r2
    char *pcStr;
    uint64_t ui64Val;
    int64_t i64Val;
    uint32_t ui32NumChars, ui32CharCnt = 0;
    fa9a:	f04f 0900 	mov.w	r9, #0
    int iWidth, iVal, iPrecision;
    uint8_t ui8CharSpecifier, ui8PadChar;
    bool bLower, bLongLong, bNeg;
    uint32_t ui32strlen = 0;

    while ( *pcFmt != 0x0 )
    fa9e:	780b      	ldrb	r3, [r1, #0]
    faa0:	b183      	cbz	r3, fac4 <am_util_stdio_vsprintf+0x34>
    {
        iPrecision = 6;             // printf() default precision for %f is 6

        if ( *pcFmt != '%' )
    faa2:	2b25      	cmp	r3, #37	; 0x25
    faa4:	d017      	beq.n	fad6 <am_util_stdio_vsprintf+0x46>
        {
            //
            // Accumulate the string portion of the format specification.
            //
            if ( pcBuf )
    faa6:	f1b8 0f00 	cmp.w	r8, #0
    faaa:	d005      	beq.n	fab8 <am_util_stdio_vsprintf+0x28>
            {
                // If '\n', convert to '\r\n'
                if ( *pcFmt == '\n'  &&  g_bTxtXlate )
    faac:	2b0a      	cmp	r3, #10
    faae:	d038      	beq.n	fb22 <am_util_stdio_vsprintf+0x92>
                {
                    *pcBuf++ = '\r';
                    ++ui32CharCnt;
                }
                *pcBuf++ = *pcFmt;
    fab0:	f888 3000 	strb.w	r3, [r8]
    fab4:	f108 0801 	add.w	r8, r8, #1
            }

            ++pcFmt;
    fab8:	3101      	adds	r1, #1
    while ( *pcFmt != 0x0 )
    faba:	780b      	ldrb	r3, [r1, #0]
            ++ui32CharCnt;
    fabc:	f109 0901 	add.w	r9, r9, #1
    while ( *pcFmt != 0x0 )
    fac0:	2b00      	cmp	r3, #0
    fac2:	d1ee      	bne.n	faa2 <am_util_stdio_vsprintf+0x12>
    } // while ()

    //
    // Terminate the string
    //
    if ( pcBuf )
    fac4:	f1b8 0f00 	cmp.w	r8, #0
    fac8:	d001      	beq.n	face <am_util_stdio_vsprintf+0x3e>
    {
        *pcBuf = 0x0;
    faca:	f888 3000 	strb.w	r3, [r8]
    }

    return (ui32CharCnt);
}
    face:	4648      	mov	r0, r9
    fad0:	b031      	add	sp, #196	; 0xc4
    fad2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ( *pcFmt == '0' )
    fad6:	784a      	ldrb	r2, [r1, #1]
    fad8:	2a30      	cmp	r2, #48	; 0x30
    fada:	d03b      	beq.n	fb54 <am_util_stdio_vsprintf+0xc4>
        ++pcFmt;
    fadc:	1c4e      	adds	r6, r1, #1
        ui8PadChar = ' ';
    fade:	2520      	movs	r5, #32
    if ( *pcStr == '-')
    fae0:	2a2d      	cmp	r2, #45	; 0x2d
    fae2:	d02c      	beq.n	fb3e <am_util_stdio_vsprintf+0xae>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    fae4:	f1a2 0030 	sub.w	r0, r2, #48	; 0x30
    fae8:	2809      	cmp	r0, #9
    faea:	d837      	bhi.n	fb5c <am_util_stdio_vsprintf+0xcc>
    uint32_t ui32Val = 0, uCnt = 0;
    faec:	2100      	movs	r1, #0
    bool bNeg = false;
    faee:	468e      	mov	lr, r1
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    faf0:	4630      	mov	r0, r6
        bNeg = true;
    faf2:	f04f 0c00 	mov.w	ip, #0
        ui32Val *= 10;
    faf6:	eb0c 078c 	add.w	r7, ip, ip, lsl #2
        ui32Val += (*pcStr - '0');
    fafa:	eb02 0a47 	add.w	sl, r2, r7, lsl #1
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    fafe:	f810 2f01 	ldrb.w	r2, [r0, #1]!
    fb02:	f1a2 0430 	sub.w	r4, r2, #48	; 0x30
    fb06:	2c09      	cmp	r4, #9
        ++uCnt;
    fb08:	f101 0101 	add.w	r1, r1, #1
        ui32Val += (*pcStr - '0');
    fb0c:	f1aa 0c30 	sub.w	ip, sl, #48	; 0x30
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    fb10:	d9f1      	bls.n	faf6 <am_util_stdio_vsprintf+0x66>
    fb12:	440e      	add	r6, r1
    return bNeg ? -ui32Val : ui32Val;
    fb14:	f1be 0f00 	cmp.w	lr, #0
    fb18:	f041 80a1 	bne.w	10c5e <am_util_stdio_vsprintf+0x11ce>
    fb1c:	4664      	mov	r4, ip
    fb1e:	7832      	ldrb	r2, [r6, #0]
    fb20:	e01e      	b.n	fb60 <am_util_stdio_vsprintf+0xd0>
                if ( *pcFmt == '\n'  &&  g_bTxtXlate )
    fb22:	4ebd      	ldr	r6, [pc, #756]	; (fe18 <am_util_stdio_vsprintf+0x388>)
    fb24:	7837      	ldrb	r7, [r6, #0]
    fb26:	2f00      	cmp	r7, #0
    fb28:	d0c2      	beq.n	fab0 <am_util_stdio_vsprintf+0x20>
                    *pcBuf++ = '\r';
    fb2a:	f04f 0c0d 	mov.w	ip, #13
    fb2e:	f888 c000 	strb.w	ip, [r8]
    fb32:	780b      	ldrb	r3, [r1, #0]
                    ++ui32CharCnt;
    fb34:	f109 0901 	add.w	r9, r9, #1
                    *pcBuf++ = '\r';
    fb38:	f108 0801 	add.w	r8, r8, #1
    fb3c:	e7b8      	b.n	fab0 <am_util_stdio_vsprintf+0x20>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    fb3e:	7872      	ldrb	r2, [r6, #1]
    fb40:	f1a2 0430 	sub.w	r4, r2, #48	; 0x30
    fb44:	2c09      	cmp	r4, #9
        pcStr++;
    fb46:	f106 0001 	add.w	r0, r6, #1
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    fb4a:	f200 8611 	bhi.w	10770 <am_util_stdio_vsprintf+0xce0>
        uCnt++;
    fb4e:	2101      	movs	r1, #1
        bNeg = true;
    fb50:	468e      	mov	lr, r1
    fb52:	e7ce      	b.n	faf2 <am_util_stdio_vsprintf+0x62>
    fb54:	788a      	ldrb	r2, [r1, #2]
            ++pcFmt;
    fb56:	1c8e      	adds	r6, r1, #2
            ui8PadChar = '0';
    fb58:	2530      	movs	r5, #48	; 0x30
    fb5a:	e7c1      	b.n	fae0 <am_util_stdio_vsprintf+0x50>
    fb5c:	7832      	ldrb	r2, [r6, #0]
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    fb5e:	2400      	movs	r4, #0
        if ( ( *pcFmt != 's' )  &&  ( iWidth < 0 ) )
    fb60:	2a73      	cmp	r2, #115	; 0x73
    fb62:	f000 8304 	beq.w	1016e <am_util_stdio_vsprintf+0x6de>
    fb66:	ea84 73e4 	eor.w	r3, r4, r4, asr #31
        if (*pcFmt == '.')
    fb6a:	2a2e      	cmp	r2, #46	; 0x2e
    fb6c:	eba3 77e4 	sub.w	r7, r3, r4, asr #31
    fb70:	f000 82ae 	beq.w	100d0 <am_util_stdio_vsprintf+0x640>
        iPrecision = 6;             // printf() default precision for %f is 6
    fb74:	f04f 0a06 	mov.w	sl, #6
        if ( *pcFmt == 'l' )
    fb78:	2a6c      	cmp	r2, #108	; 0x6c
    fb7a:	f000 82a3 	beq.w	100c4 <am_util_stdio_vsprintf+0x634>
        switch ( *pcFmt )
    fb7e:	f1a2 0046 	sub.w	r0, r2, #70	; 0x46
    fb82:	2832      	cmp	r0, #50	; 0x32
    fb84:	f200 8294 	bhi.w	100b0 <am_util_stdio_vsprintf+0x620>
    fb88:	e8df f010 	tbh	[pc, r0, lsl #1]
    fb8c:	02920115 	.word	0x02920115
    fb90:	02920292 	.word	0x02920292
    fb94:	02920292 	.word	0x02920292
    fb98:	02920292 	.word	0x02920292
    fb9c:	02920292 	.word	0x02920292
    fba0:	02920292 	.word	0x02920292
    fba4:	02920292 	.word	0x02920292
    fba8:	02920292 	.word	0x02920292
    fbac:	02920292 	.word	0x02920292
    fbb0:	02920033 	.word	0x02920033
    fbb4:	02920292 	.word	0x02920292
    fbb8:	02920292 	.word	0x02920292
    fbbc:	02920292 	.word	0x02920292
    fbc0:	02920292 	.word	0x02920292
    fbc4:	01360292 	.word	0x01360292
    fbc8:	0292014a 	.word	0x0292014a
    fbcc:	02920115 	.word	0x02920115
    fbd0:	014a0292 	.word	0x014a0292
    fbd4:	02920292 	.word	0x02920292
    fbd8:	02920292 	.word	0x02920292
    fbdc:	02920292 	.word	0x02920292
    fbe0:	02920292 	.word	0x02920292
    fbe4:	02f00292 	.word	0x02f00292
    fbe8:	01f20292 	.word	0x01f20292
    fbec:	02920292 	.word	0x02920292
    fbf0:	01ef      	.short	0x01ef
        bLower = bLongLong = false;
    fbf2:	f04f 0c00 	mov.w	ip, #0
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    fbf6:	f8db 2000 	ldr.w	r2, [fp]
    fbfa:	2300      	movs	r3, #0
                                      va_arg(pArgs, uint32_t);
    fbfc:	f10b 0b04 	add.w	fp, fp, #4
                if ( iWidth )
    fc00:	2c00      	cmp	r4, #0
    fc02:	d06d      	beq.n	fce0 <am_util_stdio_vsprintf+0x250>
    int iDigits = ui64Val ? 0 : 1;
    fc04:	ea52 0103 	orrs.w	r1, r2, r3
    fc08:	bf0c      	ite	eq
    fc0a:	f04f 0e01 	moveq.w	lr, #1
    fc0e:	f04f 0e00 	movne.w	lr, #0
    while ( ui64Val )
    fc12:	ea52 0103 	orrs.w	r1, r2, r3
    fc16:	d00b      	beq.n	fc30 <am_util_stdio_vsprintf+0x1a0>
    fc18:	4610      	mov	r0, r2
    fc1a:	4619      	mov	r1, r3
        ui64Val >>= 4;
    fc1c:	090c      	lsrs	r4, r1, #4
    fc1e:	0900      	lsrs	r0, r0, #4
    fc20:	ea40 7001 	orr.w	r0, r0, r1, lsl #28
    fc24:	4621      	mov	r1, r4
    while ( ui64Val )
    fc26:	ea50 0401 	orrs.w	r4, r0, r1
        ++iDigits;
    fc2a:	f10e 0e01 	add.w	lr, lr, #1
    while ( ui64Val )
    fc2e:	d1f5      	bne.n	fc1c <am_util_stdio_vsprintf+0x18c>
                    iWidth -= ndigits_in_hex(ui64Val);
    fc30:	eba7 070e 	sub.w	r7, r7, lr
    if ( i32NumChars <= 0 )
    fc34:	2f00      	cmp	r7, #0
    fc36:	f340 855f 	ble.w	106f8 <am_util_stdio_vsprintf+0xc68>
    while ( i32NumChars-- )
    fc3a:	f107 3aff 	add.w	sl, r7, #4294967295
        if ( pcBuf )
    fc3e:	f1b8 0f00 	cmp.w	r8, #0
    fc42:	f000 855a 	beq.w	106fa <am_util_stdio_vsprintf+0xc6a>
            *pcBuf++ = cPadChar;
    fc46:	4641      	mov	r1, r8
    fc48:	f00a 0707 	and.w	r7, sl, #7
    fc4c:	f801 5b01 	strb.w	r5, [r1], #1
    while ( i32NumChars-- )
    fc50:	f10a 30ff 	add.w	r0, sl, #4294967295
    fc54:	eba1 0408 	sub.w	r4, r1, r8
    fc58:	f1ba 0f00 	cmp.w	sl, #0
    fc5c:	d03d      	beq.n	fcda <am_util_stdio_vsprintf+0x24a>
    fc5e:	b32f      	cbz	r7, fcac <am_util_stdio_vsprintf+0x21c>
    fc60:	2f01      	cmp	r7, #1
    fc62:	d01c      	beq.n	fc9e <am_util_stdio_vsprintf+0x20e>
    fc64:	2f02      	cmp	r7, #2
    fc66:	d017      	beq.n	fc98 <am_util_stdio_vsprintf+0x208>
    fc68:	2f03      	cmp	r7, #3
    fc6a:	d012      	beq.n	fc92 <am_util_stdio_vsprintf+0x202>
    fc6c:	2f04      	cmp	r7, #4
    fc6e:	d00d      	beq.n	fc8c <am_util_stdio_vsprintf+0x1fc>
    fc70:	2f05      	cmp	r7, #5
    fc72:	d008      	beq.n	fc86 <am_util_stdio_vsprintf+0x1f6>
    fc74:	2f06      	cmp	r7, #6
            *pcBuf++ = cPadChar;
    fc76:	bf1c      	itt	ne
    fc78:	f801 5b01 	strbne.w	r5, [r1], #1
    while ( i32NumChars-- )
    fc7c:	f100 30ff 	addne.w	r0, r0, #4294967295
            *pcBuf++ = cPadChar;
    fc80:	f801 5b01 	strb.w	r5, [r1], #1
    while ( i32NumChars-- )
    fc84:	3801      	subs	r0, #1
            *pcBuf++ = cPadChar;
    fc86:	f801 5b01 	strb.w	r5, [r1], #1
    while ( i32NumChars-- )
    fc8a:	3801      	subs	r0, #1
            *pcBuf++ = cPadChar;
    fc8c:	f801 5b01 	strb.w	r5, [r1], #1
    while ( i32NumChars-- )
    fc90:	3801      	subs	r0, #1
            *pcBuf++ = cPadChar;
    fc92:	f801 5b01 	strb.w	r5, [r1], #1
    while ( i32NumChars-- )
    fc96:	3801      	subs	r0, #1
            *pcBuf++ = cPadChar;
    fc98:	f801 5b01 	strb.w	r5, [r1], #1
    while ( i32NumChars-- )
    fc9c:	3801      	subs	r0, #1
            *pcBuf++ = cPadChar;
    fc9e:	f801 5b01 	strb.w	r5, [r1], #1
    while ( i32NumChars-- )
    fca2:	3801      	subs	r0, #1
    fca4:	1c47      	adds	r7, r0, #1
    fca6:	eba1 0408 	sub.w	r4, r1, r8
    fcaa:	d016      	beq.n	fcda <am_util_stdio_vsprintf+0x24a>
            *pcBuf++ = cPadChar;
    fcac:	468a      	mov	sl, r1
    while ( i32NumChars-- )
    fcae:	3808      	subs	r0, #8
            *pcBuf++ = cPadChar;
    fcb0:	f80a 5b01 	strb.w	r5, [sl], #1
    fcb4:	3108      	adds	r1, #8
    fcb6:	f88a 5000 	strb.w	r5, [sl]
    fcba:	f801 5c06 	strb.w	r5, [r1, #-6]
    fcbe:	f801 5c05 	strb.w	r5, [r1, #-5]
    fcc2:	f801 5c04 	strb.w	r5, [r1, #-4]
    fcc6:	f801 5c03 	strb.w	r5, [r1, #-3]
    fcca:	f801 5c02 	strb.w	r5, [r1, #-2]
    while ( i32NumChars-- )
    fcce:	1c47      	adds	r7, r0, #1
    fcd0:	eba1 0408 	sub.w	r4, r1, r8
            *pcBuf++ = cPadChar;
    fcd4:	f801 5c01 	strb.w	r5, [r1, #-1]
    while ( i32NumChars-- )
    fcd8:	d1e8      	bne.n	fcac <am_util_stdio_vsprintf+0x21c>
    fcda:	4627      	mov	r7, r4
                    pcBuf += pcBuf ? iWidth : 0;
    fcdc:	44a0      	add	r8, r4
                    ui32CharCnt += iWidth;
    fcde:	44b9      	add	r9, r7
    if ( ui64Val == 0 )
    fce0:	ea52 0103 	orrs.w	r1, r2, r3
    fce4:	f040 821a 	bne.w	1011c <am_util_stdio_vsprintf+0x68c>
        tbuf[ix++] = '0';   // Print a '0'
    fce8:	f04f 0530 	mov.w	r5, #48	; 0x30
    fcec:	f88d 50ac 	strb.w	r5, [sp, #172]	; 0xac
    if (pcBuf)
    fcf0:	2701      	movs	r7, #1
    fcf2:	f1b8 0f00 	cmp.w	r8, #0
    fcf6:	f000 8235 	beq.w	10164 <am_util_stdio_vsprintf+0x6d4>
    fcfa:	4639      	mov	r1, r7
        while (ix--)
    fcfc:	2000      	movs	r0, #0
    fcfe:	ac2b      	add	r4, sp, #172	; 0xac
    fd00:	1863      	adds	r3, r4, r1
    fd02:	f103 3aff 	add.w	sl, r3, #4294967295
            *pcBuf++ = tbuf[ix];
    fd06:	f813 cc01 	ldrb.w	ip, [r3, #-1]
    fd0a:	f888 c000 	strb.w	ip, [r8]
    fd0e:	1e4d      	subs	r5, r1, #1
        while (ix--)
    fd10:	45a2      	cmp	sl, r4
    fd12:	f005 0107 	and.w	r1, r5, #7
    fd16:	4643      	mov	r3, r8
    fd18:	d047      	beq.n	fdaa <am_util_stdio_vsprintf+0x31a>
    fd1a:	b359      	cbz	r1, fd74 <am_util_stdio_vsprintf+0x2e4>
    fd1c:	2901      	cmp	r1, #1
    fd1e:	d023      	beq.n	fd68 <am_util_stdio_vsprintf+0x2d8>
    fd20:	2902      	cmp	r1, #2
    fd22:	d01d      	beq.n	fd60 <am_util_stdio_vsprintf+0x2d0>
    fd24:	2903      	cmp	r1, #3
    fd26:	d017      	beq.n	fd58 <am_util_stdio_vsprintf+0x2c8>
    fd28:	2904      	cmp	r1, #4
    fd2a:	d011      	beq.n	fd50 <am_util_stdio_vsprintf+0x2c0>
    fd2c:	2905      	cmp	r1, #5
    fd2e:	d00b      	beq.n	fd48 <am_util_stdio_vsprintf+0x2b8>
    fd30:	2906      	cmp	r1, #6
    fd32:	d005      	beq.n	fd40 <am_util_stdio_vsprintf+0x2b0>
            *pcBuf++ = tbuf[ix];
    fd34:	f81a 2d01 	ldrb.w	r2, [sl, #-1]!
    fd38:	f888 2001 	strb.w	r2, [r8, #1]
    fd3c:	f108 0301 	add.w	r3, r8, #1
    fd40:	f81a 5d01 	ldrb.w	r5, [sl, #-1]!
    fd44:	f803 5f01 	strb.w	r5, [r3, #1]!
    fd48:	f81a cd01 	ldrb.w	ip, [sl, #-1]!
    fd4c:	f803 cf01 	strb.w	ip, [r3, #1]!
    fd50:	f81a 1d01 	ldrb.w	r1, [sl, #-1]!
    fd54:	f803 1f01 	strb.w	r1, [r3, #1]!
    fd58:	f81a 2d01 	ldrb.w	r2, [sl, #-1]!
    fd5c:	f803 2f01 	strb.w	r2, [r3, #1]!
    fd60:	f81a 5d01 	ldrb.w	r5, [sl, #-1]!
    fd64:	f803 5f01 	strb.w	r5, [r3, #1]!
    fd68:	f81a cd01 	ldrb.w	ip, [sl, #-1]!
    fd6c:	f803 cf01 	strb.w	ip, [r3, #1]!
        while (ix--)
    fd70:	45a2      	cmp	sl, r4
    fd72:	d01a      	beq.n	fdaa <am_util_stdio_vsprintf+0x31a>
            *pcBuf++ = tbuf[ix];
    fd74:	f81a 2c01 	ldrb.w	r2, [sl, #-1]
    fd78:	f81a 5c03 	ldrb.w	r5, [sl, #-3]
    fd7c:	f81a 1c02 	ldrb.w	r1, [sl, #-2]
    fd80:	705a      	strb	r2, [r3, #1]
    fd82:	70dd      	strb	r5, [r3, #3]
    fd84:	f81a 2c04 	ldrb.w	r2, [sl, #-4]
    fd88:	f81a 5c05 	ldrb.w	r5, [sl, #-5]
    fd8c:	7099      	strb	r1, [r3, #2]
    fd8e:	711a      	strb	r2, [r3, #4]
    fd90:	f81a 1c06 	ldrb.w	r1, [sl, #-6]
    fd94:	715d      	strb	r5, [r3, #5]
    fd96:	f81a 2c07 	ldrb.w	r2, [sl, #-7]
    fd9a:	f81a 5d08 	ldrb.w	r5, [sl, #-8]!
    fd9e:	7199      	strb	r1, [r3, #6]
        while (ix--)
    fda0:	45a2      	cmp	sl, r4
            *pcBuf++ = tbuf[ix];
    fda2:	71da      	strb	r2, [r3, #7]
    fda4:	f803 5f08 	strb.w	r5, [r3, #8]!
        while (ix--)
    fda8:	d1e4      	bne.n	fd74 <am_util_stdio_vsprintf+0x2e4>
        *pcBuf = 0;
    fdaa:	4440      	add	r0, r8
    fdac:	2400      	movs	r4, #0
                    pcBuf += iVal;
    fdae:	44b8      	add	r8, r7
        *pcBuf = 0;
    fdb0:	7044      	strb	r4, [r0, #1]
                ui32CharCnt += iVal;
    fdb2:	44b9      	add	r9, r7
                break;
    fdb4:	e01e      	b.n	fdf4 <am_util_stdio_vsprintf+0x364>
                if ( pcBuf )
    fdb6:	f1b8 0f00 	cmp.w	r8, #0
    fdba:	d01b      	beq.n	fdf4 <am_util_stdio_vsprintf+0x364>
                    float fValue = va_arg(pArgs, double);
    fdbc:	f10b 0307 	add.w	r3, fp, #7
    fdc0:	f023 0b07 	bic.w	fp, r3, #7
    fdc4:	e9db 0100 	ldrd	r0, r1, [fp]
    fdc8:	f7fc fe0c 	bl	c9e4 <__aeabi_d2f>
    fdcc:	ee07 0a90 	vmov	s15, r0
    if (fValue == 0.0f)
    fdd0:	eef5 7a40 	vcmp.f32	s15, #0.0
                    *(uint32_t*)pcBuf = 20;
    fdd4:	2014      	movs	r0, #20
    if (fValue == 0.0f)
    fdd6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                    float fValue = va_arg(pArgs, double);
    fdda:	f10b 0b08 	add.w	fp, fp, #8
                    *(uint32_t*)pcBuf = 20;
    fdde:	f8c8 0000 	str.w	r0, [r8]
    if (fValue == 0.0f)
    fde2:	f040 848d 	bne.w	10700 <am_util_stdio_vsprintf+0xc70>
        *(uint32_t*)pcBuf = 0x00 << 24 | ('0' << 16) | ('.' << 8) | ('0' << 0);
    fde6:	490d      	ldr	r1, [pc, #52]	; (fe1c <am_util_stdio_vsprintf+0x38c>)
    fde8:	f8c8 1000 	str.w	r1, [r8]
    fdec:	f04f 0a03 	mov.w	sl, #3
                    ui32CharCnt += iVal;
    fdf0:	44d1      	add	r9, sl
                    pcBuf += iVal;
    fdf2:	44d0      	add	r8, sl
        ++pcFmt;
    fdf4:	1c71      	adds	r1, r6, #1
    fdf6:	e652      	b.n	fa9e <am_util_stdio_vsprintf+0xe>
                ui8CharSpecifier = va_arg(pArgs, uint32_t);
    fdf8:	f10b 0404 	add.w	r4, fp, #4
    fdfc:	f89b 1000 	ldrb.w	r1, [fp]
                if ( pcBuf )
    fe00:	f1b8 0f00 	cmp.w	r8, #0
    fe04:	d003      	beq.n	fe0e <am_util_stdio_vsprintf+0x37e>
                    *pcBuf++ = ui8CharSpecifier;
    fe06:	f888 1000 	strb.w	r1, [r8]
    fe0a:	f108 0801 	add.w	r8, r8, #1
                ++ui32CharCnt;
    fe0e:	f109 0901 	add.w	r9, r9, #1
                ui8CharSpecifier = va_arg(pArgs, uint32_t);
    fe12:	46a3      	mov	fp, r4
                break;
    fe14:	e7ee      	b.n	fdf4 <am_util_stdio_vsprintf+0x364>
    fe16:	bf00      	nop
    fe18:	10001040 	.word	0x10001040
    fe1c:	00302e30 	.word	0x00302e30
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
    fe20:	f8db 0000 	ldr.w	r0, [fp]
                                     va_arg(pArgs, int32_t);
    fe24:	f10b 0b04 	add.w	fp, fp, #4
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
    fe28:	17c1      	asrs	r1, r0, #31
                if ( i64Val < 0 )
    fe2a:	2800      	cmp	r0, #0
    fe2c:	f171 0300 	sbcs.w	r3, r1, #0
    fe30:	f2c0 83ac 	blt.w	1058c <am_util_stdio_vsprintf+0xafc>
                    ui64Val = i64Val;
    fe34:	e9cd 0118 	strd	r0, r1, [sp, #96]	; 0x60
                if ( iWidth )
    fe38:	2c00      	cmp	r4, #0
    fe3a:	f000 83ba 	beq.w	105b2 <am_util_stdio_vsprintf+0xb22>
    int iNDigits = ui64Val ? 0 : 1;
    fe3e:	ea50 0301 	orrs.w	r3, r0, r1
    return ndigits_in_u64((uint64_t) i64Val);
    fe42:	4602      	mov	r2, r0
    int iNDigits = ui64Val ? 0 : 1;
    fe44:	bf0c      	ite	eq
    fe46:	2401      	moveq	r4, #1
    fe48:	2400      	movne	r4, #0
    while ( ui64Val )
    fe4a:	4308      	orrs	r0, r1
    return ndigits_in_u64((uint64_t) i64Val);
    fe4c:	460b      	mov	r3, r1
                    bNeg = false;
    fe4e:	bf18      	it	ne
    fe50:	2000      	movne	r0, #0
    while ( ui64Val )
    fe52:	f000 86ba 	beq.w	10bca <am_util_stdio_vsprintf+0x113a>
                    bNeg = false;
    fe56:	901b      	str	r0, [sp, #108]	; 0x6c
    fe58:	9620      	str	r6, [sp, #128]	; 0x80
    fe5a:	9521      	str	r5, [sp, #132]	; 0x84
    fe5c:	9722      	str	r7, [sp, #136]	; 0x88
    fe5e:	941a      	str	r4, [sp, #104]	; 0x68
    fe60:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
    fe64:	f8cd 9090 	str.w	r9, [sp, #144]	; 0x90
    fe68:	f8cd 8094 	str.w	r8, [sp, #148]	; 0x94
    fe6c:	e009      	b.n	fe82 <am_util_stdio_vsprintf+0x3f2>
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    fe6e:	464a      	mov	r2, r9
    fe70:	2300      	movs	r3, #0
        ++iNDigits;
    fe72:	9d1a      	ldr	r5, [sp, #104]	; 0x68
    while ( ui64Val )
    fe74:	ea52 0103 	orrs.w	r1, r2, r3
        ++iNDigits;
    fe78:	f105 0501 	add.w	r5, r5, #1
    fe7c:	951a      	str	r5, [sp, #104]	; 0x68
    while ( ui64Val )
    fe7e:	f000 83a5 	beq.w	105cc <am_util_stdio_vsprintf+0xb3c>
        q64 = (ui64Val>>1) + (ui64Val>>2);
    fe82:	0896      	lsrs	r6, r2, #2
    fe84:	ea46 7583 	orr.w	r5, r6, r3, lsl #30
    fe88:	089f      	lsrs	r7, r3, #2
    fe8a:	970b      	str	r7, [sp, #44]	; 0x2c
    fe8c:	950a      	str	r5, [sp, #40]	; 0x28
    fe8e:	e9dd 450a 	ldrd	r4, r5, [sp, #40]	; 0x28
    fe92:	0859      	lsrs	r1, r3, #1
    fe94:	ea4f 0032 	mov.w	r0, r2, rrx
    fe98:	1820      	adds	r0, r4, r0
    fe9a:	eb45 0101 	adc.w	r1, r5, r1
        q64 += (q64 >> 4);
    fe9e:	0904      	lsrs	r4, r0, #4
        q64 = (ui64Val>>1) + (ui64Val>>2);
    fea0:	4606      	mov	r6, r0
        q64 += (q64 >> 4);
    fea2:	ea44 7501 	orr.w	r5, r4, r1, lsl #28
    fea6:	0908      	lsrs	r0, r1, #4
    fea8:	9005      	str	r0, [sp, #20]
    feaa:	9504      	str	r5, [sp, #16]
    feac:	e9dd 4504 	ldrd	r4, r5, [sp, #16]
    feb0:	19a0      	adds	r0, r4, r6
    feb2:	eb45 0101 	adc.w	r1, r5, r1
        q64 += (q64 >> 8);
    feb6:	0a04      	lsrs	r4, r0, #8
        q64 += (q64 >> 4);
    feb8:	4606      	mov	r6, r0
        q64 += (q64 >> 8);
    feba:	ea44 6501 	orr.w	r5, r4, r1, lsl #24
    febe:	0a08      	lsrs	r0, r1, #8
    fec0:	9007      	str	r0, [sp, #28]
    fec2:	9506      	str	r5, [sp, #24]
    fec4:	e9dd 4506 	ldrd	r4, r5, [sp, #24]
    fec8:	19a0      	adds	r0, r4, r6
    feca:	eb45 0101 	adc.w	r1, r5, r1
        q64 += (q64 >> 16);
    fece:	0c06      	lsrs	r6, r0, #16
    fed0:	ea46 4a01 	orr.w	sl, r6, r1, lsl #16
    fed4:	eb10 070a 	adds.w	r7, r0, sl
    fed8:	ea4f 4b11 	mov.w	fp, r1, lsr #16
    fedc:	eb41 000b 	adc.w	r0, r1, fp
        q64 += (q64 >> 32);
    fee0:	2400      	movs	r4, #0
    fee2:	900e      	str	r0, [sp, #56]	; 0x38
    fee4:	940f      	str	r4, [sp, #60]	; 0x3c
    fee6:	e9dd 890e 	ldrd	r8, r9, [sp, #56]	; 0x38
        q32 = (ui32Val>>1) + (ui32Val>>2);
    feea:	0895      	lsrs	r5, r2, #2
        q64 += (q64 >> 32);
    feec:	eb18 0807 	adds.w	r8, r8, r7
    fef0:	eb49 0100 	adc.w	r1, r9, r0
        q32 = (ui32Val>>1) + (ui32Val>>2);
    fef4:	eb05 0c52 	add.w	ip, r5, r2, lsr #1
        q64 += (q64 >> 32);
    fef8:	4646      	mov	r6, r8
        q32 += (q32 >> 4);
    fefa:	eb0c 101c 	add.w	r0, ip, ip, lsr #4
        q64 += (q64 >> 32);
    fefe:	460f      	mov	r7, r1
        q32 += (q32 >> 8);
    ff00:	eb00 2510 	add.w	r5, r0, r0, lsr #8
        q64 >>= 3;
    ff04:	08f4      	lsrs	r4, r6, #3
    if ( ui64Val >> 32 )
    ff06:	9312      	str	r3, [sp, #72]	; 0x48
    ff08:	f8cd 904c 	str.w	r9, [sp, #76]	; 0x4c
        q64 >>= 3;
    ff0c:	08ff      	lsrs	r7, r7, #3
    ff0e:	ea44 7641 	orr.w	r6, r4, r1, lsl #29
    ff12:	e9dd 8912 	ldrd	r8, r9, [sp, #72]	; 0x48
        q32 += (q32 >> 16);
    ff16:	eb05 4415 	add.w	r4, r5, r5, lsr #16
        r64 = ui64Val - q64*10;
    ff1a:	00bd      	lsls	r5, r7, #2
    ff1c:	ea45 7196 	orr.w	r1, r5, r6, lsr #30
        q32 >>= 3;
    ff20:	08e5      	lsrs	r5, r4, #3
        r32 = ui32Val - q32*10;
    ff22:	eb05 0485 	add.w	r4, r5, r5, lsl #2
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    ff26:	f102 0e06 	add.w	lr, r2, #6
    ff2a:	ebae 0c44 	sub.w	ip, lr, r4, lsl #1
    ff2e:	ea58 0409 	orrs.w	r4, r8, r9
        r64 = ui64Val - q64*10;
    ff32:	ea4f 0086 	mov.w	r0, r6, lsl #2
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    ff36:	eb05 191c 	add.w	r9, r5, ip, lsr #4
    ff3a:	d098      	beq.n	fe6e <am_util_stdio_vsprintf+0x3de>
        r64 = ui64Val - q64*10;
    ff3c:	eb10 0e06 	adds.w	lr, r0, r6
    ff40:	4179      	adcs	r1, r7
    ff42:	eb1e 000e 	adds.w	r0, lr, lr
    ff46:	4149      	adcs	r1, r1
        return q64 + ((r64 + 6) >> 4);
    ff48:	3206      	adds	r2, #6
    ff4a:	f143 0300 	adc.w	r3, r3, #0
    ff4e:	1a15      	subs	r5, r2, r0
    ff50:	eb63 0401 	sbc.w	r4, r3, r1
    ff54:	0929      	lsrs	r1, r5, #4
    ff56:	0922      	lsrs	r2, r4, #4
    ff58:	ea41 7004 	orr.w	r0, r1, r4, lsl #28
    ff5c:	9016      	str	r0, [sp, #88]	; 0x58
    ff5e:	9217      	str	r2, [sp, #92]	; 0x5c
    ff60:	e9dd 2316 	ldrd	r2, r3, [sp, #88]	; 0x58
    ff64:	1992      	adds	r2, r2, r6
    ff66:	417b      	adcs	r3, r7
    ff68:	e783      	b.n	fe72 <am_util_stdio_vsprintf+0x3e2>
        switch ( *pcFmt )
    ff6a:	f04f 0c01 	mov.w	ip, #1
    ff6e:	e642      	b.n	fbf6 <am_util_stdio_vsprintf+0x166>
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    ff70:	f8db 1000 	ldr.w	r1, [fp]
    ff74:	2200      	movs	r2, #0
    ff76:	e9cd 1218 	strd	r1, r2, [sp, #96]	; 0x60
                                      va_arg(pArgs, uint32_t);
    ff7a:	f10b 0b04 	add.w	fp, fp, #4
                if ( iWidth )
    ff7e:	2c00      	cmp	r4, #0
    ff80:	f000 8269 	beq.w	10456 <am_util_stdio_vsprintf+0x9c6>
    int iNDigits = ui64Val ? 0 : 1;
    ff84:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
    ff88:	ea50 0301 	orrs.w	r3, r0, r1
    while ( ui64Val )
    ff8c:	4602      	mov	r2, r0
    ff8e:	460b      	mov	r3, r1
    int iNDigits = ui64Val ? 0 : 1;
    ff90:	bf0c      	ite	eq
    ff92:	2401      	moveq	r4, #1
    ff94:	2400      	movne	r4, #0
    while ( ui64Val )
    ff96:	ea52 0103 	orrs.w	r1, r2, r3
    ff9a:	f000 81fe 	beq.w	1039a <am_util_stdio_vsprintf+0x90a>
    ff9e:	961b      	str	r6, [sp, #108]	; 0x6c
    ffa0:	9520      	str	r5, [sp, #128]	; 0x80
    ffa2:	9721      	str	r7, [sp, #132]	; 0x84
    ffa4:	941a      	str	r4, [sp, #104]	; 0x68
    ffa6:	f8cd b088 	str.w	fp, [sp, #136]	; 0x88
    ffaa:	f8cd 908c 	str.w	r9, [sp, #140]	; 0x8c
    ffae:	f8cd 8090 	str.w	r8, [sp, #144]	; 0x90
    ffb2:	e009      	b.n	ffc8 <am_util_stdio_vsprintf+0x538>
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    ffb4:	464a      	mov	r2, r9
    ffb6:	2300      	movs	r3, #0
        ++iNDigits;
    ffb8:	9d1a      	ldr	r5, [sp, #104]	; 0x68
    while ( ui64Val )
    ffba:	ea52 0103 	orrs.w	r1, r2, r3
        ++iNDigits;
    ffbe:	f105 0501 	add.w	r5, r5, #1
    ffc2:	951a      	str	r5, [sp, #104]	; 0x68
    while ( ui64Val )
    ffc4:	f000 81db 	beq.w	1037e <am_util_stdio_vsprintf+0x8ee>
        q64 = (ui64Val>>1) + (ui64Val>>2);
    ffc8:	0895      	lsrs	r5, r2, #2
    ffca:	ea45 7783 	orr.w	r7, r5, r3, lsl #30
    ffce:	089c      	lsrs	r4, r3, #2
    ffd0:	9708      	str	r7, [sp, #32]
    ffd2:	9409      	str	r4, [sp, #36]	; 0x24
    ffd4:	e9dd 4508 	ldrd	r4, r5, [sp, #32]
    ffd8:	0859      	lsrs	r1, r3, #1
    ffda:	ea4f 0032 	mov.w	r0, r2, rrx
    ffde:	1820      	adds	r0, r4, r0
    ffe0:	eb45 0101 	adc.w	r1, r5, r1
        q64 += (q64 >> 4);
    ffe4:	0905      	lsrs	r5, r0, #4
        q64 = (ui64Val>>1) + (ui64Val>>2);
    ffe6:	4606      	mov	r6, r0
        q64 += (q64 >> 4);
    ffe8:	ea45 7401 	orr.w	r4, r5, r1, lsl #28
    ffec:	0908      	lsrs	r0, r1, #4
    ffee:	9001      	str	r0, [sp, #4]
    fff0:	9400      	str	r4, [sp, #0]
    fff2:	e9dd 4500 	ldrd	r4, r5, [sp]
    fff6:	19a0      	adds	r0, r4, r6
    fff8:	eb45 0101 	adc.w	r1, r5, r1
        q64 += (q64 >> 8);
    fffc:	0a05      	lsrs	r5, r0, #8
        q64 += (q64 >> 4);
    fffe:	4606      	mov	r6, r0
        q64 += (q64 >> 8);
   10000:	ea45 6401 	orr.w	r4, r5, r1, lsl #24
   10004:	0a08      	lsrs	r0, r1, #8
   10006:	9003      	str	r0, [sp, #12]
   10008:	9402      	str	r4, [sp, #8]
   1000a:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
   1000e:	19a0      	adds	r0, r4, r6
   10010:	eb45 0101 	adc.w	r1, r5, r1
        q64 += (q64 >> 16);
   10014:	0c06      	lsrs	r6, r0, #16
   10016:	ea46 4a01 	orr.w	sl, r6, r1, lsl #16
   1001a:	eb10 070a 	adds.w	r7, r0, sl
   1001e:	ea4f 4b11 	mov.w	fp, r1, lsr #16
   10022:	eb41 000b 	adc.w	r0, r1, fp
        q64 += (q64 >> 32);
   10026:	2400      	movs	r4, #0
   10028:	900c      	str	r0, [sp, #48]	; 0x30
   1002a:	940d      	str	r4, [sp, #52]	; 0x34
   1002c:	e9dd 890c 	ldrd	r8, r9, [sp, #48]	; 0x30
        q32 = (ui32Val>>1) + (ui32Val>>2);
   10030:	0895      	lsrs	r5, r2, #2
        q64 += (q64 >> 32);
   10032:	eb18 0807 	adds.w	r8, r8, r7
   10036:	eb49 0100 	adc.w	r1, r9, r0
        q32 = (ui32Val>>1) + (ui32Val>>2);
   1003a:	eb05 0c52 	add.w	ip, r5, r2, lsr #1
        q64 += (q64 >> 32);
   1003e:	4646      	mov	r6, r8
        q32 += (q32 >> 4);
   10040:	eb0c 101c 	add.w	r0, ip, ip, lsr #4
        q64 += (q64 >> 32);
   10044:	460f      	mov	r7, r1
        q32 += (q32 >> 8);
   10046:	eb00 2510 	add.w	r5, r0, r0, lsr #8
        q64 >>= 3;
   1004a:	08f4      	lsrs	r4, r6, #3
    if ( ui64Val >> 32 )
   1004c:	9310      	str	r3, [sp, #64]	; 0x40
   1004e:	f8cd 9044 	str.w	r9, [sp, #68]	; 0x44
        q64 >>= 3;
   10052:	08ff      	lsrs	r7, r7, #3
   10054:	ea44 7641 	orr.w	r6, r4, r1, lsl #29
   10058:	e9dd 8910 	ldrd	r8, r9, [sp, #64]	; 0x40
        q32 += (q32 >> 16);
   1005c:	eb05 4415 	add.w	r4, r5, r5, lsr #16
        r64 = ui64Val - q64*10;
   10060:	00bd      	lsls	r5, r7, #2
   10062:	ea45 7196 	orr.w	r1, r5, r6, lsr #30
        q32 >>= 3;
   10066:	08e5      	lsrs	r5, r4, #3
        r32 = ui32Val - q32*10;
   10068:	eb05 0485 	add.w	r4, r5, r5, lsl #2
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
   1006c:	f102 0e06 	add.w	lr, r2, #6
   10070:	ebae 0c44 	sub.w	ip, lr, r4, lsl #1
   10074:	ea58 0409 	orrs.w	r4, r8, r9
        r64 = ui64Val - q64*10;
   10078:	ea4f 0086 	mov.w	r0, r6, lsl #2
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
   1007c:	eb05 191c 	add.w	r9, r5, ip, lsr #4
   10080:	d098      	beq.n	ffb4 <am_util_stdio_vsprintf+0x524>
        r64 = ui64Val - q64*10;
   10082:	eb10 0e06 	adds.w	lr, r0, r6
   10086:	4179      	adcs	r1, r7
   10088:	eb1e 000e 	adds.w	r0, lr, lr
   1008c:	4149      	adcs	r1, r1
        return q64 + ((r64 + 6) >> 4);
   1008e:	3206      	adds	r2, #6
   10090:	f143 0300 	adc.w	r3, r3, #0
   10094:	1a15      	subs	r5, r2, r0
   10096:	eb63 0401 	sbc.w	r4, r3, r1
   1009a:	0929      	lsrs	r1, r5, #4
   1009c:	0922      	lsrs	r2, r4, #4
   1009e:	ea41 7004 	orr.w	r0, r1, r4, lsl #28
   100a2:	9014      	str	r0, [sp, #80]	; 0x50
   100a4:	9215      	str	r2, [sp, #84]	; 0x54
   100a6:	e9dd 2314 	ldrd	r2, r3, [sp, #80]	; 0x50
   100aa:	1992      	adds	r2, r2, r6
   100ac:	417b      	adcs	r3, r7
   100ae:	e783      	b.n	ffb8 <am_util_stdio_vsprintf+0x528>
                if ( pcBuf )
   100b0:	f1b8 0f00 	cmp.w	r8, #0
   100b4:	d003      	beq.n	100be <am_util_stdio_vsprintf+0x62e>
                    *pcBuf++ = *pcFmt;
   100b6:	f888 2000 	strb.w	r2, [r8]
   100ba:	f108 0801 	add.w	r8, r8, #1
                ++ui32CharCnt;
   100be:	f109 0901 	add.w	r9, r9, #1
                break;
   100c2:	e697      	b.n	fdf4 <am_util_stdio_vsprintf+0x364>
            if ( *pcFmt == 'l' )    // "ll" (long long)
   100c4:	7872      	ldrb	r2, [r6, #1]
   100c6:	2a6c      	cmp	r2, #108	; 0x6c
   100c8:	f000 81db 	beq.w	10482 <am_util_stdio_vsprintf+0x9f2>
            pcFmt++;
   100cc:	3601      	adds	r6, #1
   100ce:	e556      	b.n	fb7e <am_util_stdio_vsprintf+0xee>
    if ( *pcStr == '-')
   100d0:	7873      	ldrb	r3, [r6, #1]
   100d2:	2b2d      	cmp	r3, #45	; 0x2d
            ++pcFmt;
   100d4:	f106 0001 	add.w	r0, r6, #1
    if ( *pcStr == '-')
   100d8:	f000 81c8 	beq.w	1046c <am_util_stdio_vsprintf+0x9dc>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
   100dc:	f1a3 0630 	sub.w	r6, r3, #48	; 0x30
   100e0:	2e09      	cmp	r6, #9
   100e2:	f200 8349 	bhi.w	10778 <am_util_stdio_vsprintf+0xce8>
    uint32_t ui32Val = 0, uCnt = 0;
   100e6:	2200      	movs	r2, #0
    bool bNeg = false;
   100e8:	4694      	mov	ip, r2
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
   100ea:	4606      	mov	r6, r0
    bool bNeg = false;
   100ec:	f04f 0a00 	mov.w	sl, #0
        ui32Val *= 10;
   100f0:	eb0a 018a 	add.w	r1, sl, sl, lsl #2
        ui32Val += (*pcStr - '0');
   100f4:	eb03 0141 	add.w	r1, r3, r1, lsl #1
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
   100f8:	f816 3f01 	ldrb.w	r3, [r6, #1]!
   100fc:	f1a3 0e30 	sub.w	lr, r3, #48	; 0x30
   10100:	f1be 0f09 	cmp.w	lr, #9
        ++uCnt;
   10104:	f102 0201 	add.w	r2, r2, #1
        ui32Val += (*pcStr - '0');
   10108:	f1a1 0a30 	sub.w	sl, r1, #48	; 0x30
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
   1010c:	d9f0      	bls.n	100f0 <am_util_stdio_vsprintf+0x660>
    return bNeg ? -ui32Val : ui32Val;
   1010e:	f1bc 0f00 	cmp.w	ip, #0
   10112:	f000 8334 	beq.w	1077e <am_util_stdio_vsprintf+0xcee>
   10116:	f1c1 0a30 	rsb	sl, r1, #48	; 0x30
   1011a:	e330      	b.n	1077e <am_util_stdio_vsprintf+0xcee>
   1011c:	f1bc 0f00 	cmp.w	ip, #0
   10120:	bf14      	ite	ne
   10122:	2727      	movne	r7, #39	; 0x27
   10124:	2707      	moveq	r7, #7
   10126:	f10d 04ab 	add.w	r4, sp, #171	; 0xab
    if ( ui64Val == 0 )
   1012a:	2000      	movs	r0, #0
   1012c:	e000      	b.n	10130 <am_util_stdio_vsprintf+0x6a0>
        tbuf[ix++] = cCh + '0';
   1012e:	4608      	mov	r0, r1
        cCh = ui64Val & 0xf;
   10130:	f002 010f 	and.w	r1, r2, #15
            cCh += bLower ? 0x27 : 0x7;
   10134:	eb01 0e07 	add.w	lr, r1, r7
        tbuf[ix++] = cCh + '0';
   10138:	2909      	cmp	r1, #9
   1013a:	bf88      	it	hi
   1013c:	4671      	movhi	r1, lr
        ui64Val >>= 4;
   1013e:	0912      	lsrs	r2, r2, #4
   10140:	ea4f 1e13 	mov.w	lr, r3, lsr #4
   10144:	ea42 7203 	orr.w	r2, r2, r3, lsl #28
   10148:	4673      	mov	r3, lr
        tbuf[ix++] = cCh + '0';
   1014a:	3130      	adds	r1, #48	; 0x30
    while ( ui64Val )
   1014c:	ea52 0503 	orrs.w	r5, r2, r3
        tbuf[ix++] = cCh + '0';
   10150:	f804 1f01 	strb.w	r1, [r4, #1]!
   10154:	f100 0101 	add.w	r1, r0, #1
    while ( ui64Val )
   10158:	d1e9      	bne.n	1012e <am_util_stdio_vsprintf+0x69e>
   1015a:	460f      	mov	r7, r1
    if (pcBuf)
   1015c:	f1b8 0f00 	cmp.w	r8, #0
   10160:	f47f adcd 	bne.w	fcfe <am_util_stdio_vsprintf+0x26e>
   10164:	f04f 0800 	mov.w	r8, #0
                ui32CharCnt += iVal;
   10168:	44b9      	add	r9, r7
   1016a:	e643      	b.n	fdf4 <am_util_stdio_vsprintf+0x364>
        switch ( *pcFmt )
   1016c:	463c      	mov	r4, r7
                pcStr = va_arg(pArgs, char *);
   1016e:	f8db 0000 	ldr.w	r0, [fp]
   10172:	f10b 0b04 	add.w	fp, fp, #4
    if ( !pcBuf )
   10176:	2800      	cmp	r0, #0
   10178:	f000 8085 	beq.w	10286 <am_util_stdio_vsprintf+0x7f6>
    while ( *pcBuf++ )
   1017c:	7801      	ldrb	r1, [r0, #0]
   1017e:	1c42      	adds	r2, r0, #1
   10180:	4613      	mov	r3, r2
   10182:	2900      	cmp	r1, #0
   10184:	f000 84f3 	beq.w	10b6e <am_util_stdio_vsprintf+0x10de>
   10188:	eba3 0e00 	sub.w	lr, r3, r0
   1018c:	f813 7b01 	ldrb.w	r7, [r3], #1
   10190:	2f00      	cmp	r7, #0
   10192:	d1f9      	bne.n	10188 <am_util_stdio_vsprintf+0x6f8>
                if ( iWidth > 0 )
   10194:	2c00      	cmp	r4, #0
   10196:	4677      	mov	r7, lr
   10198:	dd01      	ble.n	1019e <am_util_stdio_vsprintf+0x70e>
                    if ( ui32strlen < iWidth )
   1019a:	4574      	cmp	r4, lr
   1019c:	d877      	bhi.n	1028e <am_util_stdio_vsprintf+0x7fe>
                    if ( pcBuf )
   1019e:	f1b8 0f00 	cmp.w	r8, #0
   101a2:	f000 80e1 	beq.w	10368 <am_util_stdio_vsprintf+0x8d8>
   101a6:	eba9 0a00 	sub.w	sl, r9, r0
                        *pcBuf++ = *pcStr;
   101aa:	f808 1b01 	strb.w	r1, [r8], #1
   101ae:	eb0a 0902 	add.w	r9, sl, r2
                while (*pcStr != 0x0)
   101b2:	f812 1b01 	ldrb.w	r1, [r2], #1
   101b6:	2900      	cmp	r1, #0
   101b8:	d1f7      	bne.n	101aa <am_util_stdio_vsprintf+0x71a>
                if ( iWidth )
   101ba:	2c00      	cmp	r4, #0
   101bc:	f43f ae1a 	beq.w	fdf4 <am_util_stdio_vsprintf+0x364>
                    iWidth = -iWidth;
   101c0:	4263      	negs	r3, r4
                    if ( ui32strlen < iWidth )
   101c2:	42bb      	cmp	r3, r7
   101c4:	f67f ae16 	bls.w	fdf4 <am_util_stdio_vsprintf+0x364>
                        iWidth -= ui32strlen;
   101c8:	1bda      	subs	r2, r3, r7
    if ( i32NumChars <= 0 )
   101ca:	2a00      	cmp	r2, #0
   101cc:	f340 84c3 	ble.w	10b56 <am_util_stdio_vsprintf+0x10c6>
    while ( i32NumChars-- )
   101d0:	1e57      	subs	r7, r2, #1
        if ( pcBuf )
   101d2:	f1b8 0f00 	cmp.w	r8, #0
   101d6:	f000 84bf 	beq.w	10b58 <am_util_stdio_vsprintf+0x10c8>
            *pcBuf++ = cPadChar;
   101da:	4643      	mov	r3, r8
   101dc:	f007 0407 	and.w	r4, r7, #7
   101e0:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   101e4:	f107 3cff 	add.w	ip, r7, #4294967295
   101e8:	eba3 0108 	sub.w	r1, r3, r8
   101ec:	2f00      	cmp	r7, #0
   101ee:	d045      	beq.n	1027c <am_util_stdio_vsprintf+0x7ec>
   101f0:	b364      	cbz	r4, 1024c <am_util_stdio_vsprintf+0x7bc>
   101f2:	2c01      	cmp	r4, #1
   101f4:	d021      	beq.n	1023a <am_util_stdio_vsprintf+0x7aa>
   101f6:	2c02      	cmp	r4, #2
   101f8:	d01b      	beq.n	10232 <am_util_stdio_vsprintf+0x7a2>
   101fa:	2c03      	cmp	r4, #3
   101fc:	d015      	beq.n	1022a <am_util_stdio_vsprintf+0x79a>
   101fe:	2c04      	cmp	r4, #4
   10200:	d00f      	beq.n	10222 <am_util_stdio_vsprintf+0x792>
   10202:	2c05      	cmp	r4, #5
   10204:	d009      	beq.n	1021a <am_util_stdio_vsprintf+0x78a>
   10206:	2c06      	cmp	r4, #6
            *pcBuf++ = cPadChar;
   10208:	bf1c      	itt	ne
   1020a:	f803 5b01 	strbne.w	r5, [r3], #1
    while ( i32NumChars-- )
   1020e:	f10c 3cff 	addne.w	ip, ip, #4294967295
            *pcBuf++ = cPadChar;
   10212:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   10216:	f10c 3cff 	add.w	ip, ip, #4294967295
            *pcBuf++ = cPadChar;
   1021a:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   1021e:	f10c 3cff 	add.w	ip, ip, #4294967295
            *pcBuf++ = cPadChar;
   10222:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   10226:	f10c 3cff 	add.w	ip, ip, #4294967295
            *pcBuf++ = cPadChar;
   1022a:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   1022e:	f10c 3cff 	add.w	ip, ip, #4294967295
            *pcBuf++ = cPadChar;
   10232:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   10236:	f10c 3cff 	add.w	ip, ip, #4294967295
            *pcBuf++ = cPadChar;
   1023a:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   1023e:	f10c 3cff 	add.w	ip, ip, #4294967295
   10242:	f11c 0701 	adds.w	r7, ip, #1
   10246:	eba3 0108 	sub.w	r1, r3, r8
   1024a:	d017      	beq.n	1027c <am_util_stdio_vsprintf+0x7ec>
            *pcBuf++ = cPadChar;
   1024c:	4618      	mov	r0, r3
    while ( i32NumChars-- )
   1024e:	f1ac 0c08 	sub.w	ip, ip, #8
            *pcBuf++ = cPadChar;
   10252:	f800 5b01 	strb.w	r5, [r0], #1
   10256:	3308      	adds	r3, #8
   10258:	7005      	strb	r5, [r0, #0]
   1025a:	f803 5c06 	strb.w	r5, [r3, #-6]
   1025e:	f803 5c05 	strb.w	r5, [r3, #-5]
   10262:	f803 5c04 	strb.w	r5, [r3, #-4]
   10266:	f803 5c03 	strb.w	r5, [r3, #-3]
   1026a:	f803 5c02 	strb.w	r5, [r3, #-2]
    while ( i32NumChars-- )
   1026e:	f11c 0001 	adds.w	r0, ip, #1
   10272:	eba3 0108 	sub.w	r1, r3, r8
            *pcBuf++ = cPadChar;
   10276:	f803 5c01 	strb.w	r5, [r3, #-1]
    while ( i32NumChars-- )
   1027a:	d1e7      	bne.n	1024c <am_util_stdio_vsprintf+0x7bc>
   1027c:	460d      	mov	r5, r1
   1027e:	460a      	mov	r2, r1
                        pcBuf += pcBuf ? iWidth : 0;
   10280:	44a8      	add	r8, r5
                        ui32CharCnt += iWidth;
   10282:	4491      	add	r9, r2
   10284:	e5b6      	b.n	fdf4 <am_util_stdio_vsprintf+0x364>
                if ( iWidth > 0 )
   10286:	2c00      	cmp	r4, #0
   10288:	f340 8443 	ble.w	10b12 <am_util_stdio_vsprintf+0x1082>
        return ui32RetVal;
   1028c:	4607      	mov	r7, r0
                        iWidth -= ui32strlen;
   1028e:	1be2      	subs	r2, r4, r7
    if ( i32NumChars <= 0 )
   10290:	2a00      	cmp	r2, #0
   10292:	f340 8464 	ble.w	10b5e <am_util_stdio_vsprintf+0x10ce>
    while ( i32NumChars-- )
   10296:	f102 3eff 	add.w	lr, r2, #4294967295
        if ( pcBuf )
   1029a:	f1b8 0f00 	cmp.w	r8, #0
   1029e:	d05c      	beq.n	1035a <am_util_stdio_vsprintf+0x8ca>
            *pcBuf++ = cPadChar;
   102a0:	4643      	mov	r3, r8
   102a2:	f00e 0407 	and.w	r4, lr, #7
   102a6:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   102aa:	f10e 3aff 	add.w	sl, lr, #4294967295
   102ae:	eba3 0c08 	sub.w	ip, r3, r8
   102b2:	f1be 0f00 	cmp.w	lr, #0
   102b6:	d045      	beq.n	10344 <am_util_stdio_vsprintf+0x8b4>
   102b8:	b364      	cbz	r4, 10314 <am_util_stdio_vsprintf+0x884>
   102ba:	2c01      	cmp	r4, #1
   102bc:	d021      	beq.n	10302 <am_util_stdio_vsprintf+0x872>
   102be:	2c02      	cmp	r4, #2
   102c0:	d01b      	beq.n	102fa <am_util_stdio_vsprintf+0x86a>
   102c2:	2c03      	cmp	r4, #3
   102c4:	d015      	beq.n	102f2 <am_util_stdio_vsprintf+0x862>
   102c6:	2c04      	cmp	r4, #4
   102c8:	d00f      	beq.n	102ea <am_util_stdio_vsprintf+0x85a>
   102ca:	2c05      	cmp	r4, #5
   102cc:	d009      	beq.n	102e2 <am_util_stdio_vsprintf+0x852>
   102ce:	2c06      	cmp	r4, #6
            *pcBuf++ = cPadChar;
   102d0:	bf1c      	itt	ne
   102d2:	f803 5b01 	strbne.w	r5, [r3], #1
    while ( i32NumChars-- )
   102d6:	f10a 3aff 	addne.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
   102da:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   102de:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
   102e2:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   102e6:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
   102ea:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   102ee:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
   102f2:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   102f6:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
   102fa:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   102fe:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
   10302:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   10306:	f10a 3aff 	add.w	sl, sl, #4294967295
   1030a:	f11a 0401 	adds.w	r4, sl, #1
   1030e:	eba3 0c08 	sub.w	ip, r3, r8
   10312:	d017      	beq.n	10344 <am_util_stdio_vsprintf+0x8b4>
            *pcBuf++ = cPadChar;
   10314:	4619      	mov	r1, r3
    while ( i32NumChars-- )
   10316:	f1aa 0a08 	sub.w	sl, sl, #8
            *pcBuf++ = cPadChar;
   1031a:	f801 5b01 	strb.w	r5, [r1], #1
   1031e:	3308      	adds	r3, #8
   10320:	700d      	strb	r5, [r1, #0]
   10322:	f803 5c06 	strb.w	r5, [r3, #-6]
   10326:	f803 5c05 	strb.w	r5, [r3, #-5]
   1032a:	f803 5c04 	strb.w	r5, [r3, #-4]
   1032e:	f803 5c03 	strb.w	r5, [r3, #-3]
   10332:	f803 5c02 	strb.w	r5, [r3, #-2]
    while ( i32NumChars-- )
   10336:	f11a 0401 	adds.w	r4, sl, #1
   1033a:	eba3 0c08 	sub.w	ip, r3, r8
            *pcBuf++ = cPadChar;
   1033e:	f803 5c01 	strb.w	r5, [r3, #-1]
    while ( i32NumChars-- )
   10342:	d1e7      	bne.n	10314 <am_util_stdio_vsprintf+0x884>
   10344:	4664      	mov	r4, ip
   10346:	4662      	mov	r2, ip
                while (*pcStr != 0x0)
   10348:	7801      	ldrb	r1, [r0, #0]
                        pcBuf += pcBuf ? iWidth : 0;
   1034a:	44a0      	add	r8, r4
                        ui32CharCnt += iWidth;
   1034c:	4491      	add	r9, r2
                while (*pcStr != 0x0)
   1034e:	2900      	cmp	r1, #0
   10350:	f43f ad50 	beq.w	fdf4 <am_util_stdio_vsprintf+0x364>
                        iWidth = 0;
   10354:	2400      	movs	r4, #0
   10356:	1c42      	adds	r2, r0, #1
   10358:	e721      	b.n	1019e <am_util_stdio_vsprintf+0x70e>
                while (*pcStr != 0x0)
   1035a:	7803      	ldrb	r3, [r0, #0]
                        ui32CharCnt += iWidth;
   1035c:	4491      	add	r9, r2
                while (*pcStr != 0x0)
   1035e:	2b00      	cmp	r3, #0
   10360:	f43f ad48 	beq.w	fdf4 <am_util_stdio_vsprintf+0x364>
                        iWidth = 0;
   10364:	2400      	movs	r4, #0
   10366:	1c42      	adds	r2, r0, #1
   10368:	4690      	mov	r8, r2
   1036a:	eba9 0000 	sub.w	r0, r9, r0
   1036e:	eb00 0908 	add.w	r9, r0, r8
                while (*pcStr != 0x0)
   10372:	f818 1b01 	ldrb.w	r1, [r8], #1
   10376:	2900      	cmp	r1, #0
   10378:	d1f9      	bne.n	1036e <am_util_stdio_vsprintf+0x8de>
   1037a:	4688      	mov	r8, r1
   1037c:	e71d      	b.n	101ba <am_util_stdio_vsprintf+0x72a>
   1037e:	e9cd 6728 	strd	r6, r7, [sp, #160]	; 0xa0
   10382:	e9cd ab26 	strd	sl, fp, [sp, #152]	; 0x98
   10386:	9d20      	ldr	r5, [sp, #128]	; 0x80
   10388:	9c1a      	ldr	r4, [sp, #104]	; 0x68
   1038a:	9e1b      	ldr	r6, [sp, #108]	; 0x6c
   1038c:	9f21      	ldr	r7, [sp, #132]	; 0x84
   1038e:	f8dd b088 	ldr.w	fp, [sp, #136]	; 0x88
   10392:	f8dd 908c 	ldr.w	r9, [sp, #140]	; 0x8c
   10396:	f8dd 8090 	ldr.w	r8, [sp, #144]	; 0x90
                    iWidth -= ndigits_in_u64(ui64Val);
   1039a:	1b3c      	subs	r4, r7, r4
    if ( i32NumChars <= 0 )
   1039c:	2c00      	cmp	r4, #0
   1039e:	f340 81e3 	ble.w	10768 <am_util_stdio_vsprintf+0xcd8>
    while ( i32NumChars-- )
   103a2:	1e67      	subs	r7, r4, #1
        if ( pcBuf )
   103a4:	f1b8 0f00 	cmp.w	r8, #0
   103a8:	f000 81df 	beq.w	1076a <am_util_stdio_vsprintf+0xcda>
            *pcBuf++ = cPadChar;
   103ac:	4643      	mov	r3, r8
   103ae:	f007 0007 	and.w	r0, r7, #7
   103b2:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   103b6:	f1a4 0a02 	sub.w	sl, r4, #2
   103ba:	eba3 0c08 	sub.w	ip, r3, r8
   103be:	2f00      	cmp	r7, #0
   103c0:	d046      	beq.n	10450 <am_util_stdio_vsprintf+0x9c0>
   103c2:	b360      	cbz	r0, 1041e <am_util_stdio_vsprintf+0x98e>
   103c4:	2801      	cmp	r0, #1
   103c6:	d021      	beq.n	1040c <am_util_stdio_vsprintf+0x97c>
   103c8:	2802      	cmp	r0, #2
   103ca:	d01b      	beq.n	10404 <am_util_stdio_vsprintf+0x974>
   103cc:	2803      	cmp	r0, #3
   103ce:	d015      	beq.n	103fc <am_util_stdio_vsprintf+0x96c>
   103d0:	2804      	cmp	r0, #4
   103d2:	d00f      	beq.n	103f4 <am_util_stdio_vsprintf+0x964>
   103d4:	2805      	cmp	r0, #5
   103d6:	d009      	beq.n	103ec <am_util_stdio_vsprintf+0x95c>
   103d8:	2806      	cmp	r0, #6
            *pcBuf++ = cPadChar;
   103da:	bf1c      	itt	ne
   103dc:	f803 5b01 	strbne.w	r5, [r3], #1
    while ( i32NumChars-- )
   103e0:	f10a 3aff 	addne.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
   103e4:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   103e8:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
   103ec:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   103f0:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
   103f4:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   103f8:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
   103fc:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   10400:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
   10404:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   10408:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
   1040c:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
   10410:	f10a 3aff 	add.w	sl, sl, #4294967295
   10414:	f11a 0001 	adds.w	r0, sl, #1
   10418:	eba3 0c08 	sub.w	ip, r3, r8
   1041c:	d018      	beq.n	10450 <am_util_stdio_vsprintf+0x9c0>
            *pcBuf++ = cPadChar;
   1041e:	469e      	mov	lr, r3
    while ( i32NumChars-- )
   10420:	f1aa 0a08 	sub.w	sl, sl, #8
            *pcBuf++ = cPadChar;
   10424:	f80e 5b01 	strb.w	r5, [lr], #1
   10428:	3308      	adds	r3, #8
   1042a:	f88e 5000 	strb.w	r5, [lr]
   1042e:	f803 5c06 	strb.w	r5, [r3, #-6]
   10432:	f803 5c05 	strb.w	r5, [r3, #-5]
   10436:	f803 5c04 	strb.w	r5, [r3, #-4]
   1043a:	f803 5c03 	strb.w	r5, [r3, #-3]
   1043e:	f803 5c02 	strb.w	r5, [r3, #-2]
    while ( i32NumChars-- )
   10442:	f11a 0701 	adds.w	r7, sl, #1
   10446:	eba3 0c08 	sub.w	ip, r3, r8
            *pcBuf++ = cPadChar;
   1044a:	f803 5c01 	strb.w	r5, [r3, #-1]
    while ( i32NumChars-- )
   1044e:	d1e6      	bne.n	1041e <am_util_stdio_vsprintf+0x98e>
   10450:	4664      	mov	r4, ip
                    pcBuf += pcBuf ? iWidth : 0;
   10452:	44e0      	add	r8, ip
                    ui32CharCnt += iWidth;
   10454:	44a1      	add	r9, r4
                iVal = uint64_to_str(ui64Val, pcBuf);
   10456:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
   1045a:	4642      	mov	r2, r8
   1045c:	f7ff fa1a 	bl	f894 <uint64_to_str>
                if ( pcBuf )
   10460:	f1b8 0f00 	cmp.w	r8, #0
   10464:	d000      	beq.n	10468 <am_util_stdio_vsprintf+0x9d8>
                    pcBuf += iVal;
   10466:	4480      	add	r8, r0
                ui32CharCnt += iVal;
   10468:	4481      	add	r9, r0
                break;
   1046a:	e4c3      	b.n	fdf4 <am_util_stdio_vsprintf+0x364>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
   1046c:	78b3      	ldrb	r3, [r6, #2]
   1046e:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
   10472:	2909      	cmp	r1, #9
        pcStr++;
   10474:	f106 0602 	add.w	r6, r6, #2
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
   10478:	f200 8391 	bhi.w	10b9e <am_util_stdio_vsprintf+0x110e>
        uCnt++;
   1047c:	2201      	movs	r2, #1
        bNeg = true;
   1047e:	4694      	mov	ip, r2
   10480:	e634      	b.n	100ec <am_util_stdio_vsprintf+0x65c>
        switch ( *pcFmt )
   10482:	78b2      	ldrb	r2, [r6, #2]
   10484:	f1a2 0c46 	sub.w	ip, r2, #70	; 0x46
                pcFmt++;
   10488:	3602      	adds	r6, #2
        switch ( *pcFmt )
   1048a:	f1bc 0f32 	cmp.w	ip, #50	; 0x32
   1048e:	f63f ae0f 	bhi.w	100b0 <am_util_stdio_vsprintf+0x620>
   10492:	a101      	add	r1, pc, #4	; (adr r1, 10498 <am_util_stdio_vsprintf+0xa08>)
   10494:	f851 f02c 	ldr.w	pc, [r1, ip, lsl #2]
   10498:	0000fdb7 	.word	0x0000fdb7
   1049c:	000100b1 	.word	0x000100b1
   104a0:	000100b1 	.word	0x000100b1
   104a4:	000100b1 	.word	0x000100b1
   104a8:	000100b1 	.word	0x000100b1
   104ac:	000100b1 	.word	0x000100b1
   104b0:	000100b1 	.word	0x000100b1
   104b4:	000100b1 	.word	0x000100b1
   104b8:	000100b1 	.word	0x000100b1
   104bc:	000100b1 	.word	0x000100b1
   104c0:	000100b1 	.word	0x000100b1
   104c4:	000100b1 	.word	0x000100b1
   104c8:	000100b1 	.word	0x000100b1
   104cc:	000100b1 	.word	0x000100b1
   104d0:	000100b1 	.word	0x000100b1
   104d4:	000100b1 	.word	0x000100b1
   104d8:	000100b1 	.word	0x000100b1
   104dc:	000100b1 	.word	0x000100b1
   104e0:	00010c69 	.word	0x00010c69
   104e4:	000100b1 	.word	0x000100b1
   104e8:	000100b1 	.word	0x000100b1
   104ec:	000100b1 	.word	0x000100b1
   104f0:	000100b1 	.word	0x000100b1
   104f4:	000100b1 	.word	0x000100b1
   104f8:	000100b1 	.word	0x000100b1
   104fc:	000100b1 	.word	0x000100b1
   10500:	000100b1 	.word	0x000100b1
   10504:	000100b1 	.word	0x000100b1
   10508:	000100b1 	.word	0x000100b1
   1050c:	0000fdf9 	.word	0x0000fdf9
   10510:	0001057b 	.word	0x0001057b
   10514:	000100b1 	.word	0x000100b1
   10518:	0000fdb7 	.word	0x0000fdb7
   1051c:	000100b1 	.word	0x000100b1
   10520:	000100b1 	.word	0x000100b1
   10524:	0001057b 	.word	0x0001057b
   10528:	000100b1 	.word	0x000100b1
   1052c:	000100b1 	.word	0x000100b1
   10530:	000100b1 	.word	0x000100b1
   10534:	000100b1 	.word	0x000100b1
   10538:	000100b1 	.word	0x000100b1
   1053c:	000100b1 	.word	0x000100b1
   10540:	000100b1 	.word	0x000100b1
   10544:	000100b1 	.word	0x000100b1
   10548:	000100b1 	.word	0x000100b1
   1054c:	0001016d 	.word	0x0001016d
   10550:	000100b1 	.word	0x000100b1
   10554:	00010565 	.word	0x00010565
   10558:	000100b1 	.word	0x000100b1
   1055c:	000100b1 	.word	0x000100b1
   10560:	00010afb 	.word	0x00010afb
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
   10564:	f10b 0207 	add.w	r2, fp, #7
   10568:	f022 0b07 	bic.w	fp, r2, #7
   1056c:	e9db 0100 	ldrd	r0, r1, [fp]
   10570:	f10b 0b08 	add.w	fp, fp, #8
   10574:	e9cd 0118 	strd	r0, r1, [sp, #96]	; 0x60
   10578:	e501      	b.n	ff7e <am_util_stdio_vsprintf+0x4ee>
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
   1057a:	f10b 0307 	add.w	r3, fp, #7
   1057e:	f023 0b07 	bic.w	fp, r3, #7
   10582:	e9db 0100 	ldrd	r0, r1, [fp]
   10586:	f10b 0b08 	add.w	fp, fp, #8
   1058a:	e44e      	b.n	fe2a <am_util_stdio_vsprintf+0x39a>
                    ui64Val = -i64Val;          // Get absolute value
   1058c:	4240      	negs	r0, r0
   1058e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   10592:	e9cd 0118 	strd	r0, r1, [sp, #96]	; 0x60
                if ( iWidth )
   10596:	2c00      	cmp	r4, #0
   10598:	f040 834e 	bne.w	10c38 <am_util_stdio_vsprintf+0x11a8>
                        if ( pcBuf )
   1059c:	f1b8 0f00 	cmp.w	r8, #0
   105a0:	f000 82d1 	beq.w	10b46 <am_util_stdio_vsprintf+0x10b6>
                            *pcBuf++ = '-';
   105a4:	252d      	movs	r5, #45	; 0x2d
   105a6:	f888 5000 	strb.w	r5, [r8]
                        ++ui32CharCnt;
   105aa:	f109 0901 	add.w	r9, r9, #1
                            *pcBuf++ = '-';
   105ae:	f108 0801 	add.w	r8, r8, #1
                iVal = uint64_to_str(ui64Val, pcBuf);
   105b2:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
   105b6:	4642      	mov	r2, r8
   105b8:	f7ff f96c 	bl	f894 <uint64_to_str>
                if ( pcBuf )
   105bc:	f1b8 0f00 	cmp.w	r8, #0
   105c0:	f47f af51 	bne.w	10466 <am_util_stdio_vsprintf+0x9d6>
                    pcBuf += iVal;
   105c4:	f04f 0800 	mov.w	r8, #0
                ui32CharCnt += iVal;
   105c8:	4481      	add	r9, r0
   105ca:	e413      	b.n	fdf4 <am_util_stdio_vsprintf+0x364>
   105cc:	e9cd 671e 	strd	r6, r7, [sp, #120]	; 0x78
   105d0:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   105d2:	9f22      	ldr	r7, [sp, #136]	; 0x88
                    if ( bNeg )
   105d4:	9c1b      	ldr	r4, [sp, #108]	; 0x6c
   105d6:	9d21      	ldr	r5, [sp, #132]	; 0x84
   105d8:	9e20      	ldr	r6, [sp, #128]	; 0x80
   105da:	f8dd 9090 	ldr.w	r9, [sp, #144]	; 0x90
   105de:	f8dd 8094 	ldr.w	r8, [sp, #148]	; 0x94
   105e2:	e9cd ab1c 	strd	sl, fp, [sp, #112]	; 0x70
                    iWidth -= ndigits_in_i64(ui64Val);
   105e6:	1aff      	subs	r7, r7, r3
   105e8:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
                    if ( bNeg )
   105ec:	b13c      	cbz	r4, 105fe <am_util_stdio_vsprintf+0xb6e>
                        if ( ui8PadChar == '0' )
   105ee:	2d30      	cmp	r5, #48	; 0x30
                        --iWidth;
   105f0:	f107 31ff 	add.w	r1, r7, #4294967295
                        if ( ui8PadChar == '0' )
   105f4:	f000 82c3 	beq.w	10b7e <am_util_stdio_vsprintf+0x10ee>
   105f8:	2001      	movs	r0, #1
                        --iWidth;
   105fa:	460f      	mov	r7, r1
   105fc:	901b      	str	r0, [sp, #108]	; 0x6c
    if ( i32NumChars <= 0 )
   105fe:	2f00      	cmp	r7, #0
   10600:	f340 82d3 	ble.w	10baa <am_util_stdio_vsprintf+0x111a>
    while ( i32NumChars-- )
   10604:	1e78      	subs	r0, r7, #1
        if ( pcBuf )
   10606:	f1b8 0f00 	cmp.w	r8, #0
   1060a:	d067      	beq.n	106dc <am_util_stdio_vsprintf+0xc4c>
   1060c:	f010 0107 	ands.w	r1, r0, #7
   10610:	f1a7 0a02 	sub.w	sl, r7, #2
   10614:	4643      	mov	r3, r8
   10616:	d03a      	beq.n	1068e <am_util_stdio_vsprintf+0xbfe>
            *pcBuf++ = cPadChar;
   10618:	4643      	mov	r3, r8
   1061a:	2901      	cmp	r1, #1
   1061c:	f1a7 0a03 	sub.w	sl, r7, #3
   10620:	f803 5b01 	strb.w	r5, [r3], #1
   10624:	d033      	beq.n	1068e <am_util_stdio_vsprintf+0xbfe>
   10626:	2902      	cmp	r1, #2
   10628:	d01b      	beq.n	10662 <am_util_stdio_vsprintf+0xbd2>
   1062a:	2903      	cmp	r1, #3
   1062c:	d015      	beq.n	1065a <am_util_stdio_vsprintf+0xbca>
   1062e:	2904      	cmp	r1, #4
   10630:	d00f      	beq.n	10652 <am_util_stdio_vsprintf+0xbc2>
   10632:	2905      	cmp	r1, #5
   10634:	d009      	beq.n	1064a <am_util_stdio_vsprintf+0xbba>
   10636:	2906      	cmp	r1, #6
   10638:	bf1c      	itt	ne
   1063a:	f803 5b01 	strbne.w	r5, [r3], #1
   1063e:	f1a7 0a04 	subne.w	sl, r7, #4
   10642:	f803 5b01 	strb.w	r5, [r3], #1
   10646:	f10a 3aff 	add.w	sl, sl, #4294967295
   1064a:	f803 5b01 	strb.w	r5, [r3], #1
   1064e:	f10a 3aff 	add.w	sl, sl, #4294967295
   10652:	f803 5b01 	strb.w	r5, [r3], #1
   10656:	f10a 3aff 	add.w	sl, sl, #4294967295
   1065a:	f803 5b01 	strb.w	r5, [r3], #1
   1065e:	f10a 3aff 	add.w	sl, sl, #4294967295
   10662:	f803 5b01 	strb.w	r5, [r3], #1
   10666:	f10a 3aff 	add.w	sl, sl, #4294967295
   1066a:	e010      	b.n	1068e <am_util_stdio_vsprintf+0xbfe>
   1066c:	f88c 5000 	strb.w	r5, [ip]
   10670:	3308      	adds	r3, #8
   10672:	f803 5c06 	strb.w	r5, [r3, #-6]
   10676:	f803 5c05 	strb.w	r5, [r3, #-5]
   1067a:	f803 5c04 	strb.w	r5, [r3, #-4]
   1067e:	f803 5c03 	strb.w	r5, [r3, #-3]
   10682:	f803 5c02 	strb.w	r5, [r3, #-2]
   10686:	f1aa 0a08 	sub.w	sl, sl, #8
   1068a:	f803 5c01 	strb.w	r5, [r3, #-1]
   1068e:	469c      	mov	ip, r3
    while ( i32NumChars-- )
   10690:	f11a 0401 	adds.w	r4, sl, #1
            *pcBuf++ = cPadChar;
   10694:	f80c 5b01 	strb.w	r5, [ip], #1
   10698:	ebac 0e08 	sub.w	lr, ip, r8
    while ( i32NumChars-- )
   1069c:	d1e6      	bne.n	1066c <am_util_stdio_vsprintf+0xbdc>
                    if ( bNeg  &&  (ui8PadChar == ' ') )
   1069e:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   106a0:	44f0      	add	r8, lr
                    ui32CharCnt += iWidth;
   106a2:	44f1      	add	r9, lr
                    if ( bNeg  &&  (ui8PadChar == ' ') )
   106a4:	2a00      	cmp	r2, #0
   106a6:	d084      	beq.n	105b2 <am_util_stdio_vsprintf+0xb22>
   106a8:	2d20      	cmp	r5, #32
   106aa:	d182      	bne.n	105b2 <am_util_stdio_vsprintf+0xb22>
                        if ( pcBuf )
   106ac:	f1b8 0f00 	cmp.w	r8, #0
   106b0:	f47f af78 	bne.w	105a4 <am_util_stdio_vsprintf+0xb14>
                iVal = uint64_to_str(ui64Val, pcBuf);
   106b4:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
   106b8:	2200      	movs	r2, #0
   106ba:	f7ff f8eb 	bl	f894 <uint64_to_str>
                        ++ui32CharCnt;
   106be:	f109 0901 	add.w	r9, r9, #1
                iVal = uint64_to_str(ui64Val, pcBuf);
   106c2:	f04f 0800 	mov.w	r8, #0
                ui32CharCnt += iVal;
   106c6:	4481      	add	r9, r0
   106c8:	f7ff bb94 	b.w	fdf4 <am_util_stdio_vsprintf+0x364>
    if ( i32NumChars <= 0 )
   106cc:	2900      	cmp	r1, #0
                            ++ui32CharCnt;
   106ce:	f109 0901 	add.w	r9, r9, #1
    if ( i32NumChars <= 0 )
   106d2:	f340 82bc 	ble.w	10c4e <am_util_stdio_vsprintf+0x11be>
    while ( i32NumChars-- )
   106d6:	2201      	movs	r2, #1
   106d8:	1eb8      	subs	r0, r7, #2
   106da:	921b      	str	r2, [sp, #108]	; 0x6c
   106dc:	3001      	adds	r0, #1
                    if ( bNeg  &&  (ui8PadChar == ' ') )
   106de:	9f1b      	ldr	r7, [sp, #108]	; 0x6c
                    ui32CharCnt += iWidth;
   106e0:	4481      	add	r9, r0
                    if ( bNeg  &&  (ui8PadChar == ' ') )
   106e2:	2f00      	cmp	r7, #0
   106e4:	f000 821b 	beq.w	10b1e <am_util_stdio_vsprintf+0x108e>
   106e8:	2d20      	cmp	r5, #32
   106ea:	d0e3      	beq.n	106b4 <am_util_stdio_vsprintf+0xc24>
                iVal = uint64_to_str(ui64Val, pcBuf);
   106ec:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
   106f0:	2200      	movs	r2, #0
   106f2:	f7ff f8cf 	bl	f894 <uint64_to_str>
   106f6:	e765      	b.n	105c4 <am_util_stdio_vsprintf+0xb34>
    if ( i32NumChars <= 0 )
   106f8:	2700      	movs	r7, #0
   106fa:	2400      	movs	r4, #0
   106fc:	f7ff baee 	b.w	fcdc <am_util_stdio_vsprintf+0x24c>
    iExp2 = ((unFloatValue.I32 >> 23) & 0x000000FF) - 127;
   10700:	ee17 7a90 	vmov	r7, s15
   10704:	f3c7 5ec7 	ubfx	lr, r7, #23, #8
   10708:	f1ae 017f 	sub.w	r1, lr, #127	; 0x7f
    i32Significand = (unFloatValue.I32 & 0x00FFFFFF) | 0x00800000;
   1070c:	f3c7 0216 	ubfx	r2, r7, #0, #23
    if (iExp2 >= 31)
   10710:	291e      	cmp	r1, #30
    i32Significand = (unFloatValue.I32 & 0x00FFFFFF) | 0x00800000;
   10712:	f442 0000 	orr.w	r0, r2, #8388608	; 0x800000
    if (iExp2 >= 31)
   10716:	f300 8246 	bgt.w	10ba6 <am_util_stdio_vsprintf+0x1116>
    else if (iExp2 < -23)
   1071a:	f111 0f17 	cmn.w	r1, #23
   1071e:	f2c0 823c 	blt.w	10b9a <am_util_stdio_vsprintf+0x110a>
    else if (iExp2 >= 23)
   10722:	2916      	cmp	r1, #22
   10724:	dd2f      	ble.n	10786 <am_util_stdio_vsprintf+0xcf6>
        i32IntPart = i32Significand << (iExp2 - 23);
   10726:	f1ae 0296 	sub.w	r2, lr, #150	; 0x96
    if (unFloatValue.I32 < 0)
   1072a:	2f00      	cmp	r7, #0
        i32IntPart = i32Significand << (iExp2 - 23);
   1072c:	fa00 f002 	lsl.w	r0, r0, r2
    if (unFloatValue.I32 < 0)
   10730:	f2c0 825c 	blt.w	10bec <am_util_stdio_vsprintf+0x115c>
    if (i32IntPart == 0)
   10734:	2800      	cmp	r0, #0
   10736:	f040 824c 	bne.w	10bd2 <am_util_stdio_vsprintf+0x1142>
    *pcBuf++ = '.';
   1073a:	252e      	movs	r5, #46	; 0x2e
        *pcBuf++ = '0';
   1073c:	f04f 0430 	mov.w	r4, #48	; 0x30
    *pcBuf++ = '.';
   10740:	f888 5001 	strb.w	r5, [r8, #1]
        *pcBuf++ = '0';
   10744:	f888 4000 	strb.w	r4, [r8]
   10748:	f108 0501 	add.w	r5, r8, #1
        *pcBuf++ = '0';
   1074c:	1caa      	adds	r2, r5, #2
   1074e:	f04f 0430 	mov.w	r4, #48	; 0x30
   10752:	706c      	strb	r4, [r5, #1]
   10754:	eba2 0008 	sub.w	r0, r2, r8
    *pcBuf = 0x00;
   10758:	2500      	movs	r5, #0
                    if ( iVal < 0 )
   1075a:	42a8      	cmp	r0, r5
    *pcBuf = 0x00;
   1075c:	7015      	strb	r5, [r2, #0]
                    if ( iVal < 0 )
   1075e:	f2c0 81e7 	blt.w	10b30 <am_util_stdio_vsprintf+0x10a0>
   10762:	4682      	mov	sl, r0
   10764:	f7ff bb44 	b.w	fdf0 <am_util_stdio_vsprintf+0x360>
    if ( i32NumChars <= 0 )
   10768:	2400      	movs	r4, #0
   1076a:	f04f 0c00 	mov.w	ip, #0
   1076e:	e670      	b.n	10452 <am_util_stdio_vsprintf+0x9c2>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
   10770:	4606      	mov	r6, r0
   10772:	2400      	movs	r4, #0
   10774:	f7ff b9f4 	b.w	fb60 <am_util_stdio_vsprintf+0xd0>
   10778:	f04f 0a00 	mov.w	sl, #0
    uint32_t ui32Val = 0, uCnt = 0;
   1077c:	4652      	mov	r2, sl
            pcFmt += ui32NumChars;
   1077e:	1886      	adds	r6, r0, r2
   10780:	5c82      	ldrb	r2, [r0, r2]
   10782:	f7ff b9f9 	b.w	fb78 <am_util_stdio_vsprintf+0xe8>
    else if (iExp2 >= 0)
   10786:	2900      	cmp	r1, #0
   10788:	f2c0 8214 	blt.w	10bb4 <am_util_stdio_vsprintf+0x1124>
        i32FracPart = (i32Significand << (iExp2 + 1)) & 0x00FFFFFF;
   1078c:	f1ae 047e 	sub.w	r4, lr, #126	; 0x7e
   10790:	fa00 f304 	lsl.w	r3, r0, r4
        i32IntPart = i32Significand >> (23 - iExp2);
   10794:	f1c1 0117 	rsb	r1, r1, #23
    if (unFloatValue.I32 < 0)
   10798:	2f00      	cmp	r7, #0
        i32FracPart = (i32Significand << (iExp2 + 1)) & 0x00FFFFFF;
   1079a:	f023 447f 	bic.w	r4, r3, #4278190080	; 0xff000000
        i32IntPart = i32Significand >> (23 - iExp2);
   1079e:	fa40 f001 	asr.w	r0, r0, r1
    if (unFloatValue.I32 < 0)
   107a2:	f2c0 823b 	blt.w	10c1c <am_util_stdio_vsprintf+0x118c>
   107a6:	4645      	mov	r5, r8
            uint64_to_str(i32IntPart, pcBuf);
   107a8:	462a      	mov	r2, r5
   107aa:	17c1      	asrs	r1, r0, #31
   107ac:	f7ff f872 	bl	f894 <uint64_to_str>
        while (*pcBuf)    // Get to end of new string
   107b0:	7829      	ldrb	r1, [r5, #0]
   107b2:	b119      	cbz	r1, 107bc <am_util_stdio_vsprintf+0xd2c>
   107b4:	f815 0f01 	ldrb.w	r0, [r5, #1]!
   107b8:	2800      	cmp	r0, #0
   107ba:	d1fb      	bne.n	107b4 <am_util_stdio_vsprintf+0xd24>
    *pcBuf++ = '.';
   107bc:	222e      	movs	r2, #46	; 0x2e
   107be:	702a      	strb	r2, [r5, #0]
    if (i32FracPart == 0)
   107c0:	2c00      	cmp	r4, #0
   107c2:	d0c3      	beq.n	1074c <am_util_stdio_vsprintf+0xcbc>
    *pcBuf++ = '.';
   107c4:	1c6a      	adds	r2, r5, #1
        iMax = iBufSize - (pcBuf - pcBufInitial) - 1;
   107c6:	eba2 0008 	sub.w	r0, r2, r8
   107ca:	f1c0 0c13 	rsb	ip, r0, #19
        iMax = (iMax > iPrecision) ? iPrecision : iMax;
   107ce:	45e2      	cmp	sl, ip
   107d0:	bfa8      	it	ge
   107d2:	46e2      	movge	sl, ip
        for (jx = 0; jx < iMax; jx++)
   107d4:	f1ba 0f00 	cmp.w	sl, #0
   107d8:	f340 80b2 	ble.w	10940 <am_util_stdio_vsprintf+0xeb0>
            i32FracPart *= 10;
   107dc:	eb04 0484 	add.w	r4, r4, r4, lsl #2
   107e0:	0067      	lsls	r7, r4, #1
   107e2:	eb05 000a 	add.w	r0, r5, sl
            *pcBuf++ = (i32FracPart >> 24) + '0';
   107e6:	1639      	asrs	r1, r7, #24
   107e8:	3130      	adds	r1, #48	; 0x30
   107ea:	f10a 3eff 	add.w	lr, sl, #4294967295
        for (jx = 0; jx < iMax; jx++)
   107ee:	4290      	cmp	r0, r2
            *pcBuf++ = (i32FracPart >> 24) + '0';
   107f0:	7069      	strb	r1, [r5, #1]
   107f2:	901a      	str	r0, [sp, #104]	; 0x68
            i32FracPart &= 0x00FFFFFF;
   107f4:	f027 447f 	bic.w	r4, r7, #4278190080	; 0xff000000
   107f8:	f00e 0507 	and.w	r5, lr, #7
   107fc:	4613      	mov	r3, r2
        for (jx = 0; jx < iMax; jx++)
   107fe:	f000 809c 	beq.w	1093a <am_util_stdio_vsprintf+0xeaa>
   10802:	2d00      	cmp	r5, #0
   10804:	d04d      	beq.n	108a2 <am_util_stdio_vsprintf+0xe12>
   10806:	2d01      	cmp	r5, #1
   10808:	d03f      	beq.n	1088a <am_util_stdio_vsprintf+0xdfa>
   1080a:	2d02      	cmp	r5, #2
   1080c:	d034      	beq.n	10878 <am_util_stdio_vsprintf+0xde8>
   1080e:	2d03      	cmp	r5, #3
   10810:	d029      	beq.n	10866 <am_util_stdio_vsprintf+0xdd6>
   10812:	2d04      	cmp	r5, #4
   10814:	d01e      	beq.n	10854 <am_util_stdio_vsprintf+0xdc4>
   10816:	2d05      	cmp	r5, #5
   10818:	d013      	beq.n	10842 <am_util_stdio_vsprintf+0xdb2>
   1081a:	2d06      	cmp	r5, #6
   1081c:	d008      	beq.n	10830 <am_util_stdio_vsprintf+0xda0>
            i32FracPart *= 10;
   1081e:	eb04 0484 	add.w	r4, r4, r4, lsl #2
   10822:	0067      	lsls	r7, r4, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
   10824:	1639      	asrs	r1, r7, #24
   10826:	3130      	adds	r1, #48	; 0x30
   10828:	f803 1f01 	strb.w	r1, [r3, #1]!
            i32FracPart &= 0x00FFFFFF;
   1082c:	f027 447f 	bic.w	r4, r7, #4278190080	; 0xff000000
            i32FracPart *= 10;
   10830:	eb04 0084 	add.w	r0, r4, r4, lsl #2
   10834:	0045      	lsls	r5, r0, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
   10836:	162c      	asrs	r4, r5, #24
   10838:	3430      	adds	r4, #48	; 0x30
   1083a:	f803 4f01 	strb.w	r4, [r3, #1]!
            i32FracPart &= 0x00FFFFFF;
   1083e:	f025 447f 	bic.w	r4, r5, #4278190080	; 0xff000000
            i32FracPart *= 10;
   10842:	eb04 0784 	add.w	r7, r4, r4, lsl #2
   10846:	0078      	lsls	r0, r7, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
   10848:	1601      	asrs	r1, r0, #24
   1084a:	3130      	adds	r1, #48	; 0x30
   1084c:	f803 1f01 	strb.w	r1, [r3, #1]!
            i32FracPart &= 0x00FFFFFF;
   10850:	f020 447f 	bic.w	r4, r0, #4278190080	; 0xff000000
            i32FracPart *= 10;
   10854:	eb04 0584 	add.w	r5, r4, r4, lsl #2
   10858:	006c      	lsls	r4, r5, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
   1085a:	1627      	asrs	r7, r4, #24
   1085c:	3730      	adds	r7, #48	; 0x30
   1085e:	f803 7f01 	strb.w	r7, [r3, #1]!
            i32FracPart &= 0x00FFFFFF;
   10862:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
            i32FracPart *= 10;
   10866:	eb04 0084 	add.w	r0, r4, r4, lsl #2
   1086a:	0045      	lsls	r5, r0, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
   1086c:	1629      	asrs	r1, r5, #24
   1086e:	3130      	adds	r1, #48	; 0x30
   10870:	f803 1f01 	strb.w	r1, [r3, #1]!
            i32FracPart &= 0x00FFFFFF;
   10874:	f025 447f 	bic.w	r4, r5, #4278190080	; 0xff000000
            i32FracPart *= 10;
   10878:	eb04 0484 	add.w	r4, r4, r4, lsl #2
   1087c:	0067      	lsls	r7, r4, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
   1087e:	1638      	asrs	r0, r7, #24
   10880:	3030      	adds	r0, #48	; 0x30
   10882:	f803 0f01 	strb.w	r0, [r3, #1]!
            i32FracPart &= 0x00FFFFFF;
   10886:	f027 447f 	bic.w	r4, r7, #4278190080	; 0xff000000
            i32FracPart *= 10;
   1088a:	eb04 0584 	add.w	r5, r4, r4, lsl #2
   1088e:	006c      	lsls	r4, r5, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
   10890:	1621      	asrs	r1, r4, #24
   10892:	3130      	adds	r1, #48	; 0x30
   10894:	f803 1f01 	strb.w	r1, [r3, #1]!
        for (jx = 0; jx < iMax; jx++)
   10898:	9f1a      	ldr	r7, [sp, #104]	; 0x68
   1089a:	429f      	cmp	r7, r3
            i32FracPart &= 0x00FFFFFF;
   1089c:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
        for (jx = 0; jx < iMax; jx++)
   108a0:	d04b      	beq.n	1093a <am_util_stdio_vsprintf+0xeaa>
            i32FracPart *= 10;
   108a2:	eb04 0084 	add.w	r0, r4, r4, lsl #2
   108a6:	0041      	lsls	r1, r0, #1
            i32FracPart &= 0x00FFFFFF;
   108a8:	f021 4c7f 	bic.w	ip, r1, #4278190080	; 0xff000000
            i32FracPart *= 10;
   108ac:	eb0c 058c 	add.w	r5, ip, ip, lsl #2
   108b0:	006c      	lsls	r4, r5, #1
            i32FracPart &= 0x00FFFFFF;
   108b2:	f024 4e7f 	bic.w	lr, r4, #4278190080	; 0xff000000
            i32FracPart *= 10;
   108b6:	eb0e 078e 	add.w	r7, lr, lr, lsl #2
   108ba:	ea4f 0c47 	mov.w	ip, r7, lsl #1
            i32FracPart &= 0x00FFFFFF;
   108be:	f02c 407f 	bic.w	r0, ip, #4278190080	; 0xff000000
            i32FracPart *= 10;
   108c2:	eb00 0580 	add.w	r5, r0, r0, lsl #2
   108c6:	ea4f 0e45 	mov.w	lr, r5, lsl #1
            i32FracPart &= 0x00FFFFFF;
   108ca:	f02e 477f 	bic.w	r7, lr, #4278190080	; 0xff000000
            i32FracPart *= 10;
   108ce:	eb07 0087 	add.w	r0, r7, r7, lsl #2
   108d2:	0047      	lsls	r7, r0, #1
            i32FracPart &= 0x00FFFFFF;
   108d4:	f027 457f 	bic.w	r5, r7, #4278190080	; 0xff000000
            i32FracPart *= 10;
   108d8:	eb05 0085 	add.w	r0, r5, r5, lsl #2
   108dc:	0045      	lsls	r5, r0, #1
            i32FracPart &= 0x00FFFFFF;
   108de:	f025 407f 	bic.w	r0, r5, #4278190080	; 0xff000000
            i32FracPart *= 10;
   108e2:	eb00 0080 	add.w	r0, r0, r0, lsl #2
            *pcBuf++ = (i32FracPart >> 24) + '0';
   108e6:	1609      	asrs	r1, r1, #24
            i32FracPart *= 10;
   108e8:	0040      	lsls	r0, r0, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
   108ea:	3130      	adds	r1, #48	; 0x30
   108ec:	1624      	asrs	r4, r4, #24
   108ee:	3430      	adds	r4, #48	; 0x30
   108f0:	7059      	strb	r1, [r3, #1]
            i32FracPart &= 0x00FFFFFF;
   108f2:	f020 417f 	bic.w	r1, r0, #4278190080	; 0xff000000
            *pcBuf++ = (i32FracPart >> 24) + '0';
   108f6:	709c      	strb	r4, [r3, #2]
            i32FracPart *= 10;
   108f8:	eb01 0481 	add.w	r4, r1, r1, lsl #2
   108fc:	0064      	lsls	r4, r4, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
   108fe:	1601      	asrs	r1, r0, #24
   10900:	ea4f 6c2c 	mov.w	ip, ip, asr #24
   10904:	1620      	asrs	r0, r4, #24
   10906:	ea4f 6e2e 	mov.w	lr, lr, asr #24
   1090a:	163f      	asrs	r7, r7, #24
   1090c:	162d      	asrs	r5, r5, #24
   1090e:	3730      	adds	r7, #48	; 0x30
   10910:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
   10914:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
   10918:	3530      	adds	r5, #48	; 0x30
   1091a:	3130      	adds	r1, #48	; 0x30
   1091c:	3030      	adds	r0, #48	; 0x30
   1091e:	715f      	strb	r7, [r3, #5]
   10920:	f883 c003 	strb.w	ip, [r3, #3]
   10924:	f883 e004 	strb.w	lr, [r3, #4]
   10928:	719d      	strb	r5, [r3, #6]
   1092a:	71d9      	strb	r1, [r3, #7]
        for (jx = 0; jx < iMax; jx++)
   1092c:	9f1a      	ldr	r7, [sp, #104]	; 0x68
            *pcBuf++ = (i32FracPart >> 24) + '0';
   1092e:	f803 0f08 	strb.w	r0, [r3, #8]!
        for (jx = 0; jx < iMax; jx++)
   10932:	429f      	cmp	r7, r3
            i32FracPart &= 0x00FFFFFF;
   10934:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
        for (jx = 0; jx < iMax; jx++)
   10938:	d1b3      	bne.n	108a2 <am_util_stdio_vsprintf+0xe12>
   1093a:	4452      	add	r2, sl
   1093c:	eba2 0008 	sub.w	r0, r2, r8
        if ( ((i32FracPart * 10) >> 24) >= 5 )
   10940:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   10944:	f343 55c7 	sbfx	r5, r3, #23, #8
   10948:	2d04      	cmp	r5, #4
   1094a:	f77f af05 	ble.w	10758 <am_util_stdio_vsprintf+0xcc8>
            pcBuftmp = pcBuf - 1;
   1094e:	1e53      	subs	r3, r2, #1
            while ( pcBuftmp >= pcBufInitial )
   10950:	4598      	cmp	r8, r3
   10952:	f63f af01 	bhi.w	10758 <am_util_stdio_vsprintf+0xcc8>
   10956:	f108 37ff 	add.w	r7, r8, #4294967295
                if ( *pcBuftmp == '.' )
   1095a:	f812 1c01 	ldrb.w	r1, [r2, #-1]
   1095e:	1afc      	subs	r4, r7, r3
   10960:	43e5      	mvns	r5, r4
   10962:	292e      	cmp	r1, #46	; 0x2e
   10964:	f005 0407 	and.w	r4, r5, #7
   10968:	d005      	beq.n	10976 <am_util_stdio_vsprintf+0xee6>
                else if ( *pcBuftmp == '9' )
   1096a:	2939      	cmp	r1, #57	; 0x39
   1096c:	f040 8161 	bne.w	10c32 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   10970:	f04f 0130 	mov.w	r1, #48	; 0x30
   10974:	7019      	strb	r1, [r3, #0]
                pcBuftmp--;
   10976:	3b01      	subs	r3, #1
            while ( pcBuftmp >= pcBufInitial )
   10978:	42bb      	cmp	r3, r7
   1097a:	f43f aeed 	beq.w	10758 <am_util_stdio_vsprintf+0xcc8>
   1097e:	2c00      	cmp	r4, #0
   10980:	d054      	beq.n	10a2c <am_util_stdio_vsprintf+0xf9c>
   10982:	2c01      	cmp	r4, #1
   10984:	d045      	beq.n	10a12 <am_util_stdio_vsprintf+0xf82>
   10986:	2c02      	cmp	r4, #2
   10988:	d039      	beq.n	109fe <am_util_stdio_vsprintf+0xf6e>
   1098a:	2c03      	cmp	r4, #3
   1098c:	d02d      	beq.n	109ea <am_util_stdio_vsprintf+0xf5a>
   1098e:	2c04      	cmp	r4, #4
   10990:	d021      	beq.n	109d6 <am_util_stdio_vsprintf+0xf46>
   10992:	2c05      	cmp	r4, #5
   10994:	d015      	beq.n	109c2 <am_util_stdio_vsprintf+0xf32>
   10996:	2c06      	cmp	r4, #6
   10998:	d009      	beq.n	109ae <am_util_stdio_vsprintf+0xf1e>
                if ( *pcBuftmp == '.' )
   1099a:	7819      	ldrb	r1, [r3, #0]
   1099c:	292e      	cmp	r1, #46	; 0x2e
   1099e:	d005      	beq.n	109ac <am_util_stdio_vsprintf+0xf1c>
                else if ( *pcBuftmp == '9' )
   109a0:	2939      	cmp	r1, #57	; 0x39
   109a2:	f040 8146 	bne.w	10c32 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   109a6:	f04f 0530 	mov.w	r5, #48	; 0x30
   109aa:	701d      	strb	r5, [r3, #0]
                pcBuftmp--;
   109ac:	3b01      	subs	r3, #1
                if ( *pcBuftmp == '.' )
   109ae:	7819      	ldrb	r1, [r3, #0]
   109b0:	292e      	cmp	r1, #46	; 0x2e
   109b2:	d005      	beq.n	109c0 <am_util_stdio_vsprintf+0xf30>
                else if ( *pcBuftmp == '9' )
   109b4:	2939      	cmp	r1, #57	; 0x39
   109b6:	f040 813c 	bne.w	10c32 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   109ba:	f04f 0430 	mov.w	r4, #48	; 0x30
   109be:	701c      	strb	r4, [r3, #0]
                pcBuftmp--;
   109c0:	3b01      	subs	r3, #1
                if ( *pcBuftmp == '.' )
   109c2:	7819      	ldrb	r1, [r3, #0]
   109c4:	292e      	cmp	r1, #46	; 0x2e
   109c6:	d005      	beq.n	109d4 <am_util_stdio_vsprintf+0xf44>
                else if ( *pcBuftmp == '9' )
   109c8:	2939      	cmp	r1, #57	; 0x39
   109ca:	f040 8132 	bne.w	10c32 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   109ce:	f04f 0130 	mov.w	r1, #48	; 0x30
   109d2:	7019      	strb	r1, [r3, #0]
                pcBuftmp--;
   109d4:	3b01      	subs	r3, #1
                if ( *pcBuftmp == '.' )
   109d6:	7819      	ldrb	r1, [r3, #0]
   109d8:	292e      	cmp	r1, #46	; 0x2e
   109da:	d005      	beq.n	109e8 <am_util_stdio_vsprintf+0xf58>
                else if ( *pcBuftmp == '9' )
   109dc:	2939      	cmp	r1, #57	; 0x39
   109de:	f040 8128 	bne.w	10c32 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   109e2:	f04f 0530 	mov.w	r5, #48	; 0x30
   109e6:	701d      	strb	r5, [r3, #0]
                pcBuftmp--;
   109e8:	3b01      	subs	r3, #1
                if ( *pcBuftmp == '.' )
   109ea:	7819      	ldrb	r1, [r3, #0]
   109ec:	292e      	cmp	r1, #46	; 0x2e
   109ee:	d005      	beq.n	109fc <am_util_stdio_vsprintf+0xf6c>
                else if ( *pcBuftmp == '9' )
   109f0:	2939      	cmp	r1, #57	; 0x39
   109f2:	f040 811e 	bne.w	10c32 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   109f6:	f04f 0430 	mov.w	r4, #48	; 0x30
   109fa:	701c      	strb	r4, [r3, #0]
                pcBuftmp--;
   109fc:	3b01      	subs	r3, #1
                if ( *pcBuftmp == '.' )
   109fe:	7819      	ldrb	r1, [r3, #0]
   10a00:	292e      	cmp	r1, #46	; 0x2e
   10a02:	d005      	beq.n	10a10 <am_util_stdio_vsprintf+0xf80>
                else if ( *pcBuftmp == '9' )
   10a04:	2939      	cmp	r1, #57	; 0x39
   10a06:	f040 8114 	bne.w	10c32 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   10a0a:	f04f 0130 	mov.w	r1, #48	; 0x30
   10a0e:	7019      	strb	r1, [r3, #0]
                pcBuftmp--;
   10a10:	3b01      	subs	r3, #1
                if ( *pcBuftmp == '.' )
   10a12:	7819      	ldrb	r1, [r3, #0]
   10a14:	292e      	cmp	r1, #46	; 0x2e
   10a16:	d005      	beq.n	10a24 <am_util_stdio_vsprintf+0xf94>
                else if ( *pcBuftmp == '9' )
   10a18:	2939      	cmp	r1, #57	; 0x39
   10a1a:	f040 810a 	bne.w	10c32 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   10a1e:	f04f 0530 	mov.w	r5, #48	; 0x30
   10a22:	701d      	strb	r5, [r3, #0]
                pcBuftmp--;
   10a24:	3b01      	subs	r3, #1
            while ( pcBuftmp >= pcBufInitial )
   10a26:	42bb      	cmp	r3, r7
   10a28:	f43f ae96 	beq.w	10758 <am_util_stdio_vsprintf+0xcc8>
                if ( *pcBuftmp == '.' )
   10a2c:	7819      	ldrb	r1, [r3, #0]
   10a2e:	292e      	cmp	r1, #46	; 0x2e
   10a30:	d005      	beq.n	10a3e <am_util_stdio_vsprintf+0xfae>
                else if ( *pcBuftmp == '9' )
   10a32:	2939      	cmp	r1, #57	; 0x39
   10a34:	f040 80fd 	bne.w	10c32 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   10a38:	f04f 0430 	mov.w	r4, #48	; 0x30
   10a3c:	701c      	strb	r4, [r3, #0]
                pcBuftmp--;
   10a3e:	3b01      	subs	r3, #1
                if ( *pcBuftmp == '.' )
   10a40:	7819      	ldrb	r1, [r3, #0]
   10a42:	292e      	cmp	r1, #46	; 0x2e
                pcBuftmp--;
   10a44:	469a      	mov	sl, r3
                if ( *pcBuftmp == '.' )
   10a46:	d005      	beq.n	10a54 <am_util_stdio_vsprintf+0xfc4>
                else if ( *pcBuftmp == '9' )
   10a48:	2939      	cmp	r1, #57	; 0x39
   10a4a:	f040 80f2 	bne.w	10c32 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   10a4e:	f04f 0130 	mov.w	r1, #48	; 0x30
   10a52:	7019      	strb	r1, [r3, #0]
                if ( *pcBuftmp == '.' )
   10a54:	f81a 1c01 	ldrb.w	r1, [sl, #-1]
   10a58:	292e      	cmp	r1, #46	; 0x2e
                pcBuftmp--;
   10a5a:	f10a 33ff 	add.w	r3, sl, #4294967295
                if ( *pcBuftmp == '.' )
   10a5e:	d006      	beq.n	10a6e <am_util_stdio_vsprintf+0xfde>
                else if ( *pcBuftmp == '9' )
   10a60:	2939      	cmp	r1, #57	; 0x39
   10a62:	f040 80e6 	bne.w	10c32 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   10a66:	f04f 0c30 	mov.w	ip, #48	; 0x30
   10a6a:	f80a cc01 	strb.w	ip, [sl, #-1]
                if ( *pcBuftmp == '.' )
   10a6e:	f81a 1c02 	ldrb.w	r1, [sl, #-2]
   10a72:	292e      	cmp	r1, #46	; 0x2e
                pcBuftmp--;
   10a74:	f1aa 0302 	sub.w	r3, sl, #2
                if ( *pcBuftmp == '.' )
   10a78:	d006      	beq.n	10a88 <am_util_stdio_vsprintf+0xff8>
                else if ( *pcBuftmp == '9' )
   10a7a:	2939      	cmp	r1, #57	; 0x39
   10a7c:	f040 80d9 	bne.w	10c32 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   10a80:	f04f 0330 	mov.w	r3, #48	; 0x30
   10a84:	f80a 3c02 	strb.w	r3, [sl, #-2]
                if ( *pcBuftmp == '.' )
   10a88:	f81a 1c03 	ldrb.w	r1, [sl, #-3]
   10a8c:	292e      	cmp	r1, #46	; 0x2e
                pcBuftmp--;
   10a8e:	f1aa 0303 	sub.w	r3, sl, #3
                if ( *pcBuftmp == '.' )
   10a92:	d006      	beq.n	10aa2 <am_util_stdio_vsprintf+0x1012>
                else if ( *pcBuftmp == '9' )
   10a94:	2939      	cmp	r1, #57	; 0x39
   10a96:	f040 80cc 	bne.w	10c32 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   10a9a:	f04f 0530 	mov.w	r5, #48	; 0x30
   10a9e:	f80a 5c03 	strb.w	r5, [sl, #-3]
                if ( *pcBuftmp == '.' )
   10aa2:	f81a 1c04 	ldrb.w	r1, [sl, #-4]
   10aa6:	292e      	cmp	r1, #46	; 0x2e
                pcBuftmp--;
   10aa8:	f1aa 0304 	sub.w	r3, sl, #4
                if ( *pcBuftmp == '.' )
   10aac:	d006      	beq.n	10abc <am_util_stdio_vsprintf+0x102c>
                else if ( *pcBuftmp == '9' )
   10aae:	2939      	cmp	r1, #57	; 0x39
   10ab0:	f040 80bf 	bne.w	10c32 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   10ab4:	f04f 0430 	mov.w	r4, #48	; 0x30
   10ab8:	f80a 4c04 	strb.w	r4, [sl, #-4]
                if ( *pcBuftmp == '.' )
   10abc:	f81a 1c05 	ldrb.w	r1, [sl, #-5]
   10ac0:	292e      	cmp	r1, #46	; 0x2e
                pcBuftmp--;
   10ac2:	f1aa 0305 	sub.w	r3, sl, #5
                if ( *pcBuftmp == '.' )
   10ac6:	d006      	beq.n	10ad6 <am_util_stdio_vsprintf+0x1046>
                else if ( *pcBuftmp == '9' )
   10ac8:	2939      	cmp	r1, #57	; 0x39
   10aca:	f040 80b2 	bne.w	10c32 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   10ace:	f04f 0130 	mov.w	r1, #48	; 0x30
   10ad2:	f80a 1c05 	strb.w	r1, [sl, #-5]
                if ( *pcBuftmp == '.' )
   10ad6:	f81a 1c06 	ldrb.w	r1, [sl, #-6]
   10ada:	292e      	cmp	r1, #46	; 0x2e
                pcBuftmp--;
   10adc:	f1aa 0306 	sub.w	r3, sl, #6
                if ( *pcBuftmp == '.' )
   10ae0:	d006      	beq.n	10af0 <am_util_stdio_vsprintf+0x1060>
                else if ( *pcBuftmp == '9' )
   10ae2:	2939      	cmp	r1, #57	; 0x39
   10ae4:	f040 80a5 	bne.w	10c32 <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
   10ae8:	f04f 0c30 	mov.w	ip, #48	; 0x30
   10aec:	f80a cc06 	strb.w	ip, [sl, #-6]
                pcBuftmp--;
   10af0:	f1aa 0307 	sub.w	r3, sl, #7
            while ( pcBuftmp >= pcBufInitial )
   10af4:	42bb      	cmp	r3, r7
   10af6:	d199      	bne.n	10a2c <am_util_stdio_vsprintf+0xf9c>
   10af8:	e62e      	b.n	10758 <am_util_stdio_vsprintf+0xcc8>
        switch ( *pcFmt )
   10afa:	f04f 0c01 	mov.w	ip, #1
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
   10afe:	f10b 0307 	add.w	r3, fp, #7
   10b02:	f023 0a07 	bic.w	sl, r3, #7
   10b06:	f10a 0b08 	add.w	fp, sl, #8
   10b0a:	e9da 2300 	ldrd	r2, r3, [sl]
   10b0e:	f7ff b877 	b.w	fc00 <am_util_stdio_vsprintf+0x170>
                while (*pcStr != 0x0)
   10b12:	7801      	ldrb	r1, [r0, #0]
   10b14:	b369      	cbz	r1, 10b72 <am_util_stdio_vsprintf+0x10e2>
        return ui32RetVal;
   10b16:	4607      	mov	r7, r0
   10b18:	2201      	movs	r2, #1
   10b1a:	f7ff bb40 	b.w	1019e <am_util_stdio_vsprintf+0x70e>
                iVal = uint64_to_str(ui64Val, pcBuf);
   10b1e:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
   10b22:	463a      	mov	r2, r7
   10b24:	f7fe feb6 	bl	f894 <uint64_to_str>
   10b28:	46b8      	mov	r8, r7
                ui32CharCnt += iVal;
   10b2a:	4481      	add	r9, r0
   10b2c:	f7ff b962 	b.w	fdf4 <am_util_stdio_vsprintf+0x364>
                        if ( iVal == AM_FTOA_ERR_VAL_TOO_SMALL )
   10b30:	1c43      	adds	r3, r0, #1
   10b32:	d032      	beq.n	10b9a <am_util_stdio_vsprintf+0x110a>
                        else if ( iVal == AM_FTOA_ERR_VAL_TOO_LARGE )
   10b34:	3002      	adds	r0, #2
   10b36:	d036      	beq.n	10ba6 <am_util_stdio_vsprintf+0x1116>
                            u32PrntErrVal = (0x00 << 24) | ('?' << 16) |
   10b38:	4a4d      	ldr	r2, [pc, #308]	; (10c70 <am_util_stdio_vsprintf+0x11e0>)
                        *(uint32_t*)pcBuf = u32PrntErrVal;
   10b3a:	f8c8 2000 	str.w	r2, [r8]
   10b3e:	f04f 0a03 	mov.w	sl, #3
   10b42:	f7ff b955 	b.w	fdf0 <am_util_stdio_vsprintf+0x360>
                iVal = uint64_to_str(ui64Val, pcBuf);
   10b46:	4642      	mov	r2, r8
   10b48:	f7fe fea4 	bl	f894 <uint64_to_str>
                        ++ui32CharCnt;
   10b4c:	f109 0901 	add.w	r9, r9, #1
                ui32CharCnt += iVal;
   10b50:	4481      	add	r9, r0
   10b52:	f7ff b94f 	b.w	fdf4 <am_util_stdio_vsprintf+0x364>
    if ( i32NumChars <= 0 )
   10b56:	2200      	movs	r2, #0
   10b58:	2500      	movs	r5, #0
   10b5a:	f7ff bb91 	b.w	10280 <am_util_stdio_vsprintf+0x7f0>
   10b5e:	2200      	movs	r2, #0
                        pcBuf += pcBuf ? iWidth : 0;
   10b60:	f1b8 0f00 	cmp.w	r8, #0
   10b64:	f43f abf9 	beq.w	1035a <am_util_stdio_vsprintf+0x8ca>
   10b68:	4614      	mov	r4, r2
   10b6a:	f7ff bbed 	b.w	10348 <am_util_stdio_vsprintf+0x8b8>
                if ( iWidth > 0 )
   10b6e:	2c00      	cmp	r4, #0
   10b70:	dc02      	bgt.n	10b78 <am_util_stdio_vsprintf+0x10e8>
        return ui32RetVal;
   10b72:	460f      	mov	r7, r1
   10b74:	f7ff bb21 	b.w	101ba <am_util_stdio_vsprintf+0x72a>
                    if ( ui32strlen < iWidth )
   10b78:	460f      	mov	r7, r1
   10b7a:	f7ff bb88 	b.w	1028e <am_util_stdio_vsprintf+0x7fe>
                            if ( pcBuf )
   10b7e:	f1b8 0f00 	cmp.w	r8, #0
   10b82:	f43f ada3 	beq.w	106cc <am_util_stdio_vsprintf+0xc3c>
                            ++ui32CharCnt;
   10b86:	2401      	movs	r4, #1
                                *pcBuf++ = '-';
   10b88:	232d      	movs	r3, #45	; 0x2d
   10b8a:	f888 3000 	strb.w	r3, [r8]
                            ++ui32CharCnt;
   10b8e:	f109 0901 	add.w	r9, r9, #1
                        --iWidth;
   10b92:	460f      	mov	r7, r1
                            ++ui32CharCnt;
   10b94:	941b      	str	r4, [sp, #108]	; 0x6c
                                *pcBuf++ = '-';
   10b96:	44a0      	add	r8, r4
   10b98:	e531      	b.n	105fe <am_util_stdio_vsprintf+0xb6e>
                            u32PrntErrVal = (0x00 << 24) | ('0' << 16) |
   10b9a:	4a36      	ldr	r2, [pc, #216]	; (10c74 <am_util_stdio_vsprintf+0x11e4>)
   10b9c:	e7cd      	b.n	10b3a <am_util_stdio_vsprintf+0x10aa>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
   10b9e:	f04f 0a00 	mov.w	sl, #0
        uCnt++;
   10ba2:	2201      	movs	r2, #1
   10ba4:	e5eb      	b.n	1077e <am_util_stdio_vsprintf+0xcee>
                            u32PrntErrVal = (0x00 << 24) | ('#' << 16) |
   10ba6:	4a34      	ldr	r2, [pc, #208]	; (10c78 <am_util_stdio_vsprintf+0x11e8>)
   10ba8:	e7c7      	b.n	10b3a <am_util_stdio_vsprintf+0x10aa>
                    pcBuf += pcBuf ? iWidth : 0;
   10baa:	f1b8 0f00 	cmp.w	r8, #0
   10bae:	d13d      	bne.n	10c2c <am_util_stdio_vsprintf+0x119c>
   10bb0:	4640      	mov	r0, r8
   10bb2:	e594      	b.n	106de <am_util_stdio_vsprintf+0xc4e>
        i32FracPart = (i32Significand & 0x00FFFFFF) >> -(iExp2 + 1);
   10bb4:	43cd      	mvns	r5, r1
    if (unFloatValue.I32 < 0)
   10bb6:	2f00      	cmp	r7, #0
        i32FracPart = (i32Significand & 0x00FFFFFF) >> -(iExp2 + 1);
   10bb8:	fa40 f405 	asr.w	r4, r0, r5
    if (unFloatValue.I32 < 0)
   10bbc:	db27      	blt.n	10c0e <am_util_stdio_vsprintf+0x117e>
   10bbe:	4643      	mov	r3, r8
        *pcBuf++ = '0';
   10bc0:	f04f 0030 	mov.w	r0, #48	; 0x30
   10bc4:	7018      	strb	r0, [r3, #0]
   10bc6:	1c5d      	adds	r5, r3, #1
   10bc8:	e5f8      	b.n	107bc <am_util_stdio_vsprintf+0xd2c>
                    iWidth -= ndigits_in_i64(ui64Val);
   10bca:	1b3f      	subs	r7, r7, r4
                    bNeg = false;
   10bcc:	2400      	movs	r4, #0
   10bce:	941b      	str	r4, [sp, #108]	; 0x6c
   10bd0:	e515      	b.n	105fe <am_util_stdio_vsprintf+0xb6e>
    if (i32IntPart == 0)
   10bd2:	4643      	mov	r3, r8
    i32FracPart = 0;
   10bd4:	2400      	movs	r4, #0
        if (i32IntPart > 0)
   10bd6:	2800      	cmp	r0, #0
   10bd8:	dc37      	bgt.n	10c4a <am_util_stdio_vsprintf+0x11ba>
            *pcBuf++ = '-';
   10bda:	1c5d      	adds	r5, r3, #1
   10bdc:	272d      	movs	r7, #45	; 0x2d
            uint64_to_str(-i32IntPart, pcBuf);
   10bde:	4240      	negs	r0, r0
   10be0:	17c1      	asrs	r1, r0, #31
   10be2:	462a      	mov	r2, r5
            *pcBuf++ = '-';
   10be4:	701f      	strb	r7, [r3, #0]
            uint64_to_str(-i32IntPart, pcBuf);
   10be6:	f7fe fe55 	bl	f894 <uint64_to_str>
   10bea:	e5e1      	b.n	107b0 <am_util_stdio_vsprintf+0xd20>
        *pcBuf++ = '-';
   10bec:	f04f 0e2d 	mov.w	lr, #45	; 0x2d
   10bf0:	f888 e000 	strb.w	lr, [r8]
   10bf4:	f108 0301 	add.w	r3, r8, #1
    if (i32IntPart == 0)
   10bf8:	bb78      	cbnz	r0, 10c5a <am_util_stdio_vsprintf+0x11ca>
    *pcBuf++ = '.';
   10bfa:	272e      	movs	r7, #46	; 0x2e
        *pcBuf++ = '0';
   10bfc:	f04f 0030 	mov.w	r0, #48	; 0x30
   10c00:	f888 0001 	strb.w	r0, [r8, #1]
    *pcBuf++ = '.';
   10c04:	f888 7002 	strb.w	r7, [r8, #2]
        *pcBuf++ = '0';
   10c08:	f108 0502 	add.w	r5, r8, #2
   10c0c:	e59e      	b.n	1074c <am_util_stdio_vsprintf+0xcbc>
        *pcBuf++ = '-';
   10c0e:	f04f 0c2d 	mov.w	ip, #45	; 0x2d
   10c12:	f888 c000 	strb.w	ip, [r8]
   10c16:	f108 0301 	add.w	r3, r8, #1
   10c1a:	e7d1      	b.n	10bc0 <am_util_stdio_vsprintf+0x1130>
   10c1c:	272d      	movs	r7, #45	; 0x2d
   10c1e:	f888 7000 	strb.w	r7, [r8]
   10c22:	f108 0301 	add.w	r3, r8, #1
    if (i32IntPart == 0)
   10c26:	2800      	cmp	r0, #0
   10c28:	d0ca      	beq.n	10bc0 <am_util_stdio_vsprintf+0x1130>
   10c2a:	e7d4      	b.n	10bd6 <am_util_stdio_vsprintf+0x1146>
   10c2c:	f04f 0e00 	mov.w	lr, #0
   10c30:	e535      	b.n	1069e <am_util_stdio_vsprintf+0xc0e>
                    *pcBuftmp += 1;
   10c32:	3101      	adds	r1, #1
   10c34:	7019      	strb	r1, [r3, #0]
   10c36:	e58f      	b.n	10758 <am_util_stdio_vsprintf+0xcc8>
    int iNDigits = ui64Val ? 0 : 1;
   10c38:	460b      	mov	r3, r1
   10c3a:	4301      	orrs	r1, r0
   10c3c:	4602      	mov	r2, r0
   10c3e:	bf0c      	ite	eq
   10c40:	2401      	moveq	r4, #1
   10c42:	2400      	movne	r4, #0
                    bNeg = true;
   10c44:	2001      	movs	r0, #1
   10c46:	f7ff b906 	b.w	fe56 <am_util_stdio_vsprintf+0x3c6>
        if (i32IntPart > 0)
   10c4a:	461d      	mov	r5, r3
   10c4c:	e5ac      	b.n	107a8 <am_util_stdio_vsprintf+0xd18>
                iVal = uint64_to_str(ui64Val, pcBuf);
   10c4e:	4642      	mov	r2, r8
   10c50:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
   10c54:	f7fe fe1e 	bl	f894 <uint64_to_str>
   10c58:	e4b4      	b.n	105c4 <am_util_stdio_vsprintf+0xb34>
    i32FracPart = 0;
   10c5a:	2400      	movs	r4, #0
   10c5c:	e7bb      	b.n	10bd6 <am_util_stdio_vsprintf+0x1146>
   10c5e:	f1ca 0430 	rsb	r4, sl, #48	; 0x30
   10c62:	7832      	ldrb	r2, [r6, #0]
   10c64:	f7fe bf7c 	b.w	fb60 <am_util_stdio_vsprintf+0xd0>
        bLower = bLongLong = false;
   10c68:	f04f 0c00 	mov.w	ip, #0
   10c6c:	e747      	b.n	10afe <am_util_stdio_vsprintf+0x106e>
   10c6e:	bf00      	nop
   10c70:	003f2e3f 	.word	0x003f2e3f
   10c74:	00302e30 	.word	0x00302e30
   10c78:	00232e23 	.word	0x00232e23

00010c7c <am_util_stdio_sprintf>:
//! @return uint32_t representing the number of characters printed.
//
//******************************************************************************
uint32_t
am_util_stdio_sprintf(char *pcBuf, const char *pcFmt, ...)
{
   10c7c:	b40e      	push	{r1, r2, r3}
   10c7e:	b500      	push	{lr}
   10c80:	b082      	sub	sp, #8
   10c82:	aa03      	add	r2, sp, #12
   10c84:	f852 1b04 	ldr.w	r1, [r2], #4
    uint32_t ui32CharCnt;

    va_list pArgs;
    va_start(pArgs, pcFmt);
   10c88:	9201      	str	r2, [sp, #4]
    ui32CharCnt = am_util_stdio_vsprintf(pcBuf, pcFmt, pArgs);
   10c8a:	f7fe ff01 	bl	fa90 <am_util_stdio_vsprintf>
    va_end(pArgs);

    return ui32CharCnt;
}
   10c8e:	b002      	add	sp, #8
   10c90:	f85d eb04 	ldr.w	lr, [sp], #4
   10c94:	b003      	add	sp, #12
   10c96:	4770      	bx	lr

00010c98 <am_util_stdio_printf>:
//! @return uint32_t representing the number of characters printed.
//
// *****************************************************************************
uint32_t
am_util_stdio_printf(const char *pcFmt, ...)
{
   10c98:	b40f      	push	{r0, r1, r2, r3}
   10c9a:	b530      	push	{r4, r5, lr}
   10c9c:	b083      	sub	sp, #12
   10c9e:	aa06      	add	r2, sp, #24
    //
    // Convert to the desired string.
    //
    va_list pArgs;
    va_start(pArgs, pcFmt);
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
   10ca0:	4c08      	ldr	r4, [pc, #32]	; (10cc4 <am_util_stdio_printf+0x2c>)
{
   10ca2:	f852 1b04 	ldr.w	r1, [r2], #4
    va_start(pArgs, pcFmt);
   10ca6:	9201      	str	r2, [sp, #4]
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
   10ca8:	4620      	mov	r0, r4
   10caa:	f7fe fef1 	bl	fa90 <am_util_stdio_vsprintf>
    va_end(pArgs);

    //
    // This is where we print the buffer to the configured interface.
    //
    g_pfnCharPrint(g_prfbuf);
   10cae:	4b06      	ldr	r3, [pc, #24]	; (10cc8 <am_util_stdio_printf+0x30>)
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
   10cb0:	4605      	mov	r5, r0
    g_pfnCharPrint(g_prfbuf);
   10cb2:	6819      	ldr	r1, [r3, #0]
   10cb4:	4620      	mov	r0, r4
   10cb6:	4788      	blx	r1

    //
    // return the number of characters printed.
    //
    return ui32NumChars;
}
   10cb8:	4628      	mov	r0, r5
   10cba:	b003      	add	sp, #12
   10cbc:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   10cc0:	b004      	add	sp, #16
   10cc2:	4770      	bx	lr
   10cc4:	10001044 	.word	0x10001044
   10cc8:	10001550 	.word	0x10001550

00010ccc <am_util_stdio_terminal_clear>:
    // left corner.
    // We'll first print a number of spaces, which helps get the ITM in sync
    // with AM Flash, especially after a reset event or a system clock
    // frequency change.
    //
    am_util_stdio_printf("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
   10ccc:	4801      	ldr	r0, [pc, #4]	; (10cd4 <am_util_stdio_terminal_clear+0x8>)
   10cce:	f7ff bfe3 	b.w	10c98 <am_util_stdio_printf>
   10cd2:	bf00      	nop
   10cd4:	00012f84 	.word	0x00012f84

00010cd8 <am_bsp_uart_string_print>:
//! @return None.
//
//*****************************************************************************
void
am_bsp_uart_string_print(char *pcString)
{
   10cd8:	b510      	push	{r4, lr}
   10cda:	b086      	sub	sp, #24
    uint32_t ui32BytesWritten = 0;

    //
    // Measure the length of the string.
    //
    while (pcString[ui32StrLen] != 0)
   10cdc:	7804      	ldrb	r4, [r0, #0]
    uint32_t ui32BytesWritten = 0;
   10cde:	2300      	movs	r3, #0
   10ce0:	9300      	str	r3, [sp, #0]
    while (pcString[ui32StrLen] != 0)
   10ce2:	b134      	cbz	r4, 10cf2 <am_bsp_uart_string_print+0x1a>
   10ce4:	461c      	mov	r4, r3
   10ce6:	4601      	mov	r1, r0
   10ce8:	f811 2f01 	ldrb.w	r2, [r1, #1]!
    {
        ui32StrLen++;
   10cec:	3401      	adds	r4, #1
    while (pcString[ui32StrLen] != 0)
   10cee:	2a00      	cmp	r2, #0
   10cf0:	d1fa      	bne.n	10ce8 <am_bsp_uart_string_print+0x10>
        .ui32NumBytes = ui32StrLen,
        .ui32TimeoutMs = AM_HAL_UART_WAIT_FOREVER,
        .pui32BytesTransferred = &ui32BytesWritten,
    };

    am_hal_uart_transfer(g_sCOMUART, &sUartWrite);
   10cf2:	4b0a      	ldr	r3, [pc, #40]	; (10d1c <am_bsp_uart_string_print+0x44>)
    const am_hal_uart_transfer_t sUartWrite =
   10cf4:	9002      	str	r0, [sp, #8]
   10cf6:	2200      	movs	r2, #0
    am_hal_uart_transfer(g_sCOMUART, &sUartWrite);
   10cf8:	6818      	ldr	r0, [r3, #0]
    const am_hal_uart_transfer_t sUartWrite =
   10cfa:	9403      	str	r4, [sp, #12]
   10cfc:	f04f 33ff 	mov.w	r3, #4294967295
    am_hal_uart_transfer(g_sCOMUART, &sUartWrite);
   10d00:	a901      	add	r1, sp, #4
    const am_hal_uart_transfer_t sUartWrite =
   10d02:	9201      	str	r2, [sp, #4]
   10d04:	9304      	str	r3, [sp, #16]
   10d06:	f8cd d014 	str.w	sp, [sp, #20]
    am_hal_uart_transfer(g_sCOMUART, &sUartWrite);
   10d0a:	f000 ff9f 	bl	11c4c <am_hal_uart_transfer>

    if (ui32BytesWritten != ui32StrLen)
   10d0e:	9800      	ldr	r0, [sp, #0]
   10d10:	42a0      	cmp	r0, r4
   10d12:	d000      	beq.n	10d16 <am_bsp_uart_string_print+0x3e>
   10d14:	e7fe      	b.n	10d14 <am_bsp_uart_string_print+0x3c>
        //
        // Couldn't send the whole string!!
        //
        while(1);
    }
} // am_bsp_uart_string_print()
   10d16:	b006      	add	sp, #24
   10d18:	bd10      	pop	{r4, pc}
   10d1a:	bf00      	nop
   10d1c:	10001144 	.word	0x10001144

00010d20 <am_bsp_low_power_init>:
{
   10d20:	b508      	push	{r3, lr}
    am_hal_itm_disable();
   10d22:	f000 fbe1 	bl	114e8 <am_hal_itm_disable>
    am_util_stdio_printf_init(0);
   10d26:	2000      	movs	r0, #0
   10d28:	f7fe feac 	bl	fa84 <am_util_stdio_printf_init>
    am_hal_gpio_pinconfig(AM_BSP_GPIO_ITM_SWO, g_AM_HAL_GPIO_DISABLE);
   10d2c:	4b08      	ldr	r3, [pc, #32]	; (10d50 <am_bsp_low_power_init+0x30>)
   10d2e:	2029      	movs	r0, #41	; 0x29
   10d30:	6819      	ldr	r1, [r3, #0]
   10d32:	f000 fa8f 	bl	11254 <am_hal_gpio_pinconfig>
    am_hal_pwrctrl_low_power_init();
   10d36:	f000 fd61 	bl	117fc <am_hal_pwrctrl_low_power_init>
    am_hal_rtc_osc_select(AM_HAL_RTC_OSC_LFRC);
   10d3a:	2001      	movs	r0, #1
   10d3c:	f000 fd9c 	bl	11878 <am_hal_rtc_osc_select>
    am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_XTAL_STOP, 0);
   10d40:	2100      	movs	r1, #0
   10d42:	2003      	movs	r0, #3
   10d44:	f000 f8f0 	bl	10f28 <am_hal_clkgen_control>
} // am_bsp_low_power_init()
   10d48:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    am_hal_rtc_osc_disable();
   10d4c:	f000 bda0 	b.w	11890 <am_hal_rtc_osc_disable>
   10d50:	00012fcc 	.word	0x00012fcc

00010d54 <am_bsp_uart_printf_enable>:
// Initialize and configure the UART
//
//*****************************************************************************
void
am_bsp_uart_printf_enable(void)
{
   10d54:	b510      	push	{r4, lr}
    //
    // Initialize, power up, and configure the communication UART. Use the
    // custom configuration if it was provided. Otherwise, just use the default
    // configuration.
    //
    am_hal_uart_initialize(AM_BSP_UART_PRINT_INST, &g_sCOMUART);
   10d56:	4c10      	ldr	r4, [pc, #64]	; (10d98 <am_bsp_uart_printf_enable+0x44>)
    g_ui32PrintInterface = AM_BSP_PRINT_INFC_UART0;
   10d58:	4b10      	ldr	r3, [pc, #64]	; (10d9c <am_bsp_uart_printf_enable+0x48>)
    am_hal_uart_initialize(AM_BSP_UART_PRINT_INST, &g_sCOMUART);
   10d5a:	4621      	mov	r1, r4
    g_ui32PrintInterface = AM_BSP_PRINT_INFC_UART0;
   10d5c:	2202      	movs	r2, #2
    am_hal_uart_initialize(AM_BSP_UART_PRINT_INST, &g_sCOMUART);
   10d5e:	2000      	movs	r0, #0
    g_ui32PrintInterface = AM_BSP_PRINT_INFC_UART0;
   10d60:	601a      	str	r2, [r3, #0]
    am_hal_uart_initialize(AM_BSP_UART_PRINT_INST, &g_sCOMUART);
   10d62:	f000 fddb 	bl	1191c <am_hal_uart_initialize>
    am_hal_uart_power_control(g_sCOMUART, AM_HAL_SYSCTRL_WAKE, false);
   10d66:	2200      	movs	r2, #0
   10d68:	4611      	mov	r1, r2
   10d6a:	6820      	ldr	r0, [r4, #0]
   10d6c:	f000 fe12 	bl	11994 <am_hal_uart_power_control>
    am_hal_uart_configure(g_sCOMUART, &g_sBspUartConfig);
   10d70:	6820      	ldr	r0, [r4, #0]
   10d72:	490b      	ldr	r1, [pc, #44]	; (10da0 <am_bsp_uart_printf_enable+0x4c>)

    //
    // Enable the UART pins.
    //
    am_hal_gpio_pinconfig(AM_BSP_GPIO_COM_UART_TX, g_AM_BSP_GPIO_COM_UART_TX);
    am_hal_gpio_pinconfig(AM_BSP_GPIO_COM_UART_RX, g_AM_BSP_GPIO_COM_UART_RX);
   10d74:	4c0b      	ldr	r4, [pc, #44]	; (10da4 <am_bsp_uart_printf_enable+0x50>)
    am_hal_uart_configure(g_sCOMUART, &g_sBspUartConfig);
   10d76:	f000 fe7f 	bl	11a78 <am_hal_uart_configure>
    am_hal_gpio_pinconfig(AM_BSP_GPIO_COM_UART_TX, g_AM_BSP_GPIO_COM_UART_TX);
   10d7a:	490b      	ldr	r1, [pc, #44]	; (10da8 <am_bsp_uart_printf_enable+0x54>)
   10d7c:	2027      	movs	r0, #39	; 0x27
   10d7e:	6809      	ldr	r1, [r1, #0]
   10d80:	f000 fa68 	bl	11254 <am_hal_gpio_pinconfig>
    am_hal_gpio_pinconfig(AM_BSP_GPIO_COM_UART_RX, g_AM_BSP_GPIO_COM_UART_RX);
   10d84:	6821      	ldr	r1, [r4, #0]
   10d86:	2028      	movs	r0, #40	; 0x28
   10d88:	f000 fa64 	bl	11254 <am_hal_gpio_pinconfig>

    //
    // Register the BSP print function to the STDIO driver.
    //
    am_util_stdio_printf_init(am_bsp_uart_string_print);
   10d8c:	4807      	ldr	r0, [pc, #28]	; (10dac <am_bsp_uart_printf_enable+0x58>)
} // am_bsp_uart_printf_enable()
   10d8e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    am_util_stdio_printf_init(am_bsp_uart_string_print);
   10d92:	f7fe be77 	b.w	fa84 <am_util_stdio_printf_init>
   10d96:	bf00      	nop
   10d98:	10001144 	.word	0x10001144
   10d9c:	10001148 	.word	0x10001148
   10da0:	00012f98 	.word	0x00012f98
   10da4:	00012fc0 	.word	0x00012fc0
   10da8:	00012fc4 	.word	0x00012fc4
   10dac:	00010cd9 	.word	0x00010cd9

00010db0 <am_bsp_uart_printf_disable>:
// Disable the UART
//
//*****************************************************************************
void
am_bsp_uart_printf_disable(void)
{
   10db0:	b510      	push	{r4, lr}
    //
    // Make sure the UART has finished sending everything it's going to send.
    //
    am_hal_uart_tx_flush(g_sCOMUART);
   10db2:	4c0d      	ldr	r4, [pc, #52]	; (10de8 <am_bsp_uart_printf_disable+0x38>)
   10db4:	6820      	ldr	r0, [r4, #0]
   10db6:	f001 fbcd 	bl	12554 <am_hal_uart_tx_flush>

    //
    // Detach the UART from the stdio driver.
    //
    am_util_stdio_printf_init(0);
   10dba:	2000      	movs	r0, #0
   10dbc:	f7fe fe62 	bl	fa84 <am_util_stdio_printf_init>

    //
    // Power down the UART, and surrender the handle.
    //
    am_hal_uart_power_control(g_sCOMUART, AM_HAL_SYSCTRL_DEEPSLEEP, false);
   10dc0:	2200      	movs	r2, #0
   10dc2:	2102      	movs	r1, #2
   10dc4:	6820      	ldr	r0, [r4, #0]
   10dc6:	f000 fde5 	bl	11994 <am_hal_uart_power_control>
    am_hal_uart_deinitialize(g_sCOMUART);
   10dca:	6820      	ldr	r0, [r4, #0]
   10dcc:	f000 fdce 	bl	1196c <am_hal_uart_deinitialize>

    //
    // Disable the UART pins.
    //
    am_hal_gpio_pinconfig(AM_BSP_GPIO_COM_UART_TX, g_AM_HAL_GPIO_DISABLE);
   10dd0:	4b06      	ldr	r3, [pc, #24]	; (10dec <am_bsp_uart_printf_disable+0x3c>)
   10dd2:	681c      	ldr	r4, [r3, #0]
   10dd4:	2027      	movs	r0, #39	; 0x27
   10dd6:	4621      	mov	r1, r4
   10dd8:	f000 fa3c 	bl	11254 <am_hal_gpio_pinconfig>
    am_hal_gpio_pinconfig(AM_BSP_GPIO_COM_UART_RX, g_AM_HAL_GPIO_DISABLE);
   10ddc:	4621      	mov	r1, r4
   10dde:	2028      	movs	r0, #40	; 0x28

} // am_bsp_uart_printf_disable()
   10de0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    am_hal_gpio_pinconfig(AM_BSP_GPIO_COM_UART_RX, g_AM_HAL_GPIO_DISABLE);
   10de4:	f000 ba36 	b.w	11254 <am_hal_gpio_pinconfig>
   10de8:	10001144 	.word	0x10001144
   10dec:	00012fcc 	.word	0x00012fcc

00010df0 <am_hal_cachectrl_config>:
//  Configure the cache with given and recommended settings, but do not enable.
//
//*****************************************************************************
uint32_t
am_hal_cachectrl_config(const am_hal_cachectrl_config_t *psConfig)
{
   10df0:	b530      	push	{r4, r5, lr}
   10df2:	b083      	sub	sp, #12
   10df4:	4605      	mov	r5, r0
    // accomplish that is to shut down the ID bits, leaving the cache enabled.
    // Once the instr and data caches have been disabled, we can safely set
    // any new configuration, including disabling the controller.
    //
#if AM_CMSIS_REGS
    AM_CRITICAL_BEGIN
   10df6:	f000 fb6f 	bl	114d8 <am_hal_interrupt_master_disable>
    CACHECTRL->CACHECFG &=
   10dfa:	4c11      	ldr	r4, [pc, #68]	; (10e40 <am_hal_cachectrl_config+0x50>)
    AM_CRITICAL_BEGIN
   10dfc:	9001      	str	r0, [sp, #4]
    CACHECTRL->CACHECFG &=
   10dfe:	6823      	ldr	r3, [r4, #0]
   10e00:	f423 7040 	bic.w	r0, r3, #768	; 0x300
   10e04:	6020      	str	r0, [r4, #0]
        ~(CACHECTRL_CACHECFG_DCACHE_ENABLE_Msk  |
          CACHECTRL_CACHECFG_ICACHE_ENABLE_Msk);
    AM_CRITICAL_END
   10e06:	9801      	ldr	r0, [sp, #4]
   10e08:	f000 fb6a 	bl	114e0 <am_hal_interrupt_master_set>
        _VAL2FLD(CACHECTRL_CACHECFG_ENABLE, 0)                              |
        _VAL2FLD(CACHECTRL_CACHECFG_CACHE_CLKGATE, 1)                       |
        _VAL2FLD(CACHECTRL_CACHECFG_CACHE_LS, 0)                            |
        _VAL2FLD(CACHECTRL_CACHECFG_DATA_CLKGATE, 1)                        |
        _VAL2FLD(CACHECTRL_CACHECFG_ENABLE_MONITOR, 0)                      |
        _VAL2FLD(CACHECTRL_CACHECFG_LRU, psConfig->bLRU)                    |
   10e0c:	78eb      	ldrb	r3, [r5, #3]
        _VAL2FLD(CACHECTRL_CACHECFG_CONFIG, psConfig->eDescript)            |
   10e0e:	7828      	ldrb	r0, [r5, #0]
        ((psConfig->eEnableNCregions << CACHECTRL_CACHECFG_ENABLE_NC0_Pos) &
   10e10:	78a9      	ldrb	r1, [r5, #2]
            (CACHECTRL_CACHECFG_ENABLE_NC1_Msk      |
             CACHECTRL_CACHECFG_ENABLE_NC0_Msk))                            |
        ((psConfig->eMode << CACHECTRL_CACHECFG_ICACHE_ENABLE_Pos) &
   10e12:	786a      	ldrb	r2, [r5, #1]
        _VAL2FLD(CACHECTRL_CACHECFG_CONFIG, psConfig->eDescript)            |
   10e14:	0100      	lsls	r0, r0, #4
        _VAL2FLD(CACHECTRL_CACHECFG_LRU, psConfig->bLRU)                    |
   10e16:	005d      	lsls	r5, r3, #1
   10e18:	f005 0302 	and.w	r3, r5, #2
        _VAL2FLD(CACHECTRL_CACHECFG_CONFIG, psConfig->eDescript)            |
   10e1c:	b2c5      	uxtb	r5, r0
        _VAL2FLD(CACHECTRL_CACHECFG_LRU, psConfig->bLRU)                    |
   10e1e:	432b      	orrs	r3, r5
             CACHECTRL_CACHECFG_ENABLE_NC0_Msk))                            |
   10e20:	f443 1080 	orr.w	r0, r3, #1048576	; 0x100000
        ((psConfig->eEnableNCregions << CACHECTRL_CACHECFG_ENABLE_NC0_Pos) &
   10e24:	0089      	lsls	r1, r1, #2
             CACHECTRL_CACHECFG_ENABLE_NC0_Msk))                            |
   10e26:	f440 6380 	orr.w	r3, r0, #1024	; 0x400
        ((psConfig->eEnableNCregions << CACHECTRL_CACHECFG_ENABLE_NC0_Pos) &
   10e2a:	f001 050c 	and.w	r5, r1, #12
        ((psConfig->eMode << CACHECTRL_CACHECFG_ICACHE_ENABLE_Pos) &
   10e2e:	0212      	lsls	r2, r2, #8
   10e30:	f402 7040 	and.w	r0, r2, #768	; 0x300
             CACHECTRL_CACHECFG_ENABLE_NC0_Msk))                            |
   10e34:	432b      	orrs	r3, r5
   10e36:	4303      	orrs	r3, r0

#endif // AM_CMSIS_REGS

    return AM_HAL_STATUS_SUCCESS;

} // am_hal_cachectrl_enable()
   10e38:	2000      	movs	r0, #0
    CACHECTRL->CACHECFG =
   10e3a:	6023      	str	r3, [r4, #0]
} // am_hal_cachectrl_enable()
   10e3c:	b003      	add	sp, #12
   10e3e:	bd30      	pop	{r4, r5, pc}
   10e40:	40018000 	.word	0x40018000

00010e44 <am_hal_cachectrl_enable>:
//*****************************************************************************
uint32_t
am_hal_cachectrl_enable(void)
{
#if AM_CMSIS_REGS
    CACHECTRL->CACHECFG |= _VAL2FLD(CACHECTRL_CACHECFG_ENABLE, 1);
   10e44:	4a03      	ldr	r2, [pc, #12]	; (10e54 <am_hal_cachectrl_enable+0x10>)
   10e46:	6813      	ldr	r3, [r2, #0]
   10e48:	f043 0001 	orr.w	r0, r3, #1
   10e4c:	6010      	str	r0, [r2, #0]
#else // AM_CMSIS_REGS
    AM_REG(CACHECTRL, CACHECFG) |= AM_REG_CACHECTRL_CACHECFG_ENABLE(1);
#endif // AM_CMSIS_REGS

    return AM_HAL_STATUS_SUCCESS;
} // am_hal_cachectrl_enable()
   10e4e:	2000      	movs	r0, #0
   10e50:	4770      	bx	lr
   10e52:	bf00      	nop
   10e54:	40018000 	.word	0x40018000

00010e58 <am_hal_cachectrl_control>:
//  Select the cache configuration type.
//
//*****************************************************************************
uint32_t
am_hal_cachectrl_control(am_hal_cachectrl_control_e eControl, void *pArgs)
{
   10e58:	b500      	push	{lr}
    uint32_t ui32Val;
    uint32_t ui32SetMask = 0;

#if AM_CMSIS_REGS
    switch ( eControl )
   10e5a:	3801      	subs	r0, #1
{
   10e5c:	b087      	sub	sp, #28
    switch ( eControl )
   10e5e:	280a      	cmp	r0, #10
   10e60:	d836      	bhi.n	10ed0 <am_hal_cachectrl_control+0x78>
   10e62:	e8df f000 	tbb	[pc, r0]
   10e66:	3937      	.short	0x3937
   10e68:	100e063f 	.word	0x100e063f
   10e6c:	25181512 	.word	0x25181512
   10e70:	32          	.byte	0x32
   10e71:	00          	.byte	0x00
        case AM_HAL_CACHECTRL_CONTROL_FLASH_ALL_SLEEP_ENABLE:
            ui32SetMask = CACHECTRL_CTRL_FLASH0_SLM_ENABLE_Msk      |
                          CACHECTRL_CTRL_FLASH1_SLM_ENABLE_Msk;
            break;
        case AM_HAL_CACHECTRL_CONTROL_FLASH_ALL_SLEEP_DISABLE:
            ui32SetMask = CACHECTRL_CTRL_FLASH0_SLM_DISABLE_Msk     |
   10e72:	f44f 7108 	mov.w	r1, #544	; 0x220
    // Important note - setting of an enable and disable simultanously has
    // unpredicable results.
    //
    if ( ui32SetMask )
    {
        CACHECTRL->CTRL = ui32SetMask;
   10e76:	4b2a      	ldr	r3, [pc, #168]	; (10f20 <am_hal_cachectrl_control+0xc8>)
    {
        AM_REG(CACHECTRL, CTRL) = ui32SetMask;
    }
#endif // AM_CMSIS_REGS

    return AM_HAL_STATUS_SUCCESS;
   10e78:	2000      	movs	r0, #0
        CACHECTRL->CTRL = ui32SetMask;
   10e7a:	6099      	str	r1, [r3, #8]

} // am_hal_cachectrl_control()
   10e7c:	b007      	add	sp, #28
   10e7e:	f85d fb04 	ldr.w	pc, [sp], #4
            ui32SetMask = CACHECTRL_CTRL_FLASH0_SLM_ENABLE_Msk;
   10e82:	2140      	movs	r1, #64	; 0x40
            break;
   10e84:	e7f7      	b.n	10e76 <am_hal_cachectrl_control+0x1e>
            ui32SetMask = CACHECTRL_CTRL_FLASH0_SLM_DISABLE_Msk;
   10e86:	2120      	movs	r1, #32
            break;
   10e88:	e7f5      	b.n	10e76 <am_hal_cachectrl_control+0x1e>
            ui32SetMask = CACHECTRL_CTRL_FLASH1_SLM_ENABLE_Msk;
   10e8a:	f44f 6180 	mov.w	r1, #1024	; 0x400
            break;
   10e8e:	e7f2      	b.n	10e76 <am_hal_cachectrl_control+0x1e>
            ui32SetMask = CACHECTRL_CTRL_FLASH1_SLM_DISABLE_Msk;
   10e90:	f44f 7100 	mov.w	r1, #512	; 0x200
            break;
   10e94:	e7ef      	b.n	10e76 <am_hal_cachectrl_control+0x1e>
            AM_CRITICAL_BEGIN
   10e96:	f000 fb1f 	bl	114d8 <am_hal_interrupt_master_disable>
            CACHECTRL->CACHECFG |= CACHECTRL_CACHECFG_ENABLE_MONITOR_Msk;
   10e9a:	4921      	ldr	r1, [pc, #132]	; (10f20 <am_hal_cachectrl_control+0xc8>)
            AM_CRITICAL_BEGIN
   10e9c:	9003      	str	r0, [sp, #12]
            CACHECTRL->CACHECFG |= CACHECTRL_CACHECFG_ENABLE_MONITOR_Msk;
   10e9e:	6808      	ldr	r0, [r1, #0]
   10ea0:	f040 7380 	orr.w	r3, r0, #16777216	; 0x1000000
   10ea4:	600b      	str	r3, [r1, #0]
            AM_CRITICAL_END
   10ea6:	9803      	ldr	r0, [sp, #12]
   10ea8:	f000 fb1a 	bl	114e0 <am_hal_interrupt_master_set>
    return AM_HAL_STATUS_SUCCESS;
   10eac:	2000      	movs	r0, #0
   10eae:	e7e5      	b.n	10e7c <am_hal_cachectrl_control+0x24>
            AM_CRITICAL_BEGIN
   10eb0:	f000 fb12 	bl	114d8 <am_hal_interrupt_master_disable>
            CACHECTRL->CACHECFG &= ~CACHECTRL_CACHECFG_ENABLE_MONITOR_Msk;
   10eb4:	491a      	ldr	r1, [pc, #104]	; (10f20 <am_hal_cachectrl_control+0xc8>)
            AM_CRITICAL_BEGIN
   10eb6:	9004      	str	r0, [sp, #16]
            CACHECTRL->CACHECFG &= ~CACHECTRL_CACHECFG_ENABLE_MONITOR_Msk;
   10eb8:	680b      	ldr	r3, [r1, #0]
   10eba:	f023 7280 	bic.w	r2, r3, #16777216	; 0x1000000
   10ebe:	600a      	str	r2, [r1, #0]
            AM_CRITICAL_END
   10ec0:	9804      	ldr	r0, [sp, #16]
   10ec2:	f000 fb0d 	bl	114e0 <am_hal_interrupt_master_set>
    return AM_HAL_STATUS_SUCCESS;
   10ec6:	2000      	movs	r0, #0
   10ec8:	e7d8      	b.n	10e7c <am_hal_cachectrl_control+0x24>
            if ( ui32Val > CACHECTRL_FLASHCFG_LPMMODE_ALWAYS )
   10eca:	680b      	ldr	r3, [r1, #0]
   10ecc:	2b02      	cmp	r3, #2
   10ece:	d90e      	bls.n	10eee <am_hal_cachectrl_control+0x96>
                return AM_HAL_STATUS_INVALID_ARG;
   10ed0:	2006      	movs	r0, #6
   10ed2:	e7d3      	b.n	10e7c <am_hal_cachectrl_control+0x24>
            ui32SetMask = CACHECTRL_CTRL_INVALIDATE_Msk;
   10ed4:	2101      	movs	r1, #1
   10ed6:	e7ce      	b.n	10e76 <am_hal_cachectrl_control+0x1e>
            if ( !_FLD2VAL(CACHECTRL_CACHECFG_ENABLE_MONITOR, CACHECTRL->CACHECFG) )
   10ed8:	4a11      	ldr	r2, [pc, #68]	; (10f20 <am_hal_cachectrl_control+0xc8>)
   10eda:	6810      	ldr	r0, [r2, #0]
   10edc:	01c3      	lsls	r3, r0, #7
   10ede:	d404      	bmi.n	10eea <am_hal_cachectrl_control+0x92>
                return AM_HAL_STATUS_INVALID_OPERATION;
   10ee0:	2007      	movs	r0, #7
   10ee2:	e7cb      	b.n	10e7c <am_hal_cachectrl_control+0x24>
            ui32SetMask = CACHECTRL_CTRL_FLASH0_SLM_ENABLE_Msk      |
   10ee4:	f44f 6188 	mov.w	r1, #1088	; 0x440
   10ee8:	e7c5      	b.n	10e76 <am_hal_cachectrl_control+0x1e>
                ui32SetMask = CACHECTRL_CTRL_RESET_STAT_Msk;
   10eea:	2102      	movs	r1, #2
   10eec:	e7c3      	b.n	10e76 <am_hal_cachectrl_control+0x1e>
   10eee:	9101      	str	r1, [sp, #4]
            AM_CRITICAL_BEGIN
   10ef0:	f000 faf2 	bl	114d8 <am_hal_interrupt_master_disable>
   10ef4:	4601      	mov	r1, r0
            ui32Val = am_hal_flash_load_ui32((uint32_t*)&CACHECTRL->FLASHCFG);
   10ef6:	480b      	ldr	r0, [pc, #44]	; (10f24 <am_hal_cachectrl_control+0xcc>)
            AM_CRITICAL_BEGIN
   10ef8:	9105      	str	r1, [sp, #20]
            ui32Val = am_hal_flash_load_ui32((uint32_t*)&CACHECTRL->FLASHCFG);
   10efa:	f000 f9a1 	bl	11240 <am_hal_flash_load_ui32>
            ui32Val |= _VAL2FLD(CACHECTRL_FLASHCFG_LPMMODE, *((uint32_t*)pArgs));
   10efe:	9a01      	ldr	r2, [sp, #4]
   10f00:	6813      	ldr	r3, [r2, #0]
   10f02:	031a      	lsls	r2, r3, #12
            ui32Val &= ~CACHECTRL_FLASHCFG_LPMMODE_Msk;
   10f04:	f420 5140 	bic.w	r1, r0, #12288	; 0x3000
            ui32Val |= _VAL2FLD(CACHECTRL_FLASHCFG_LPMMODE, *((uint32_t*)pArgs));
   10f08:	f402 5040 	and.w	r0, r2, #12288	; 0x3000
            am_hal_flash_store_ui32((uint32_t*)&CACHECTRL->FLASHCFG, ui32Val);
   10f0c:	4301      	orrs	r1, r0
   10f0e:	4805      	ldr	r0, [pc, #20]	; (10f24 <am_hal_cachectrl_control+0xcc>)
   10f10:	f000 f99a 	bl	11248 <am_hal_flash_store_ui32>
            AM_CRITICAL_END
   10f14:	9805      	ldr	r0, [sp, #20]
   10f16:	f000 fae3 	bl	114e0 <am_hal_interrupt_master_set>
    return AM_HAL_STATUS_SUCCESS;
   10f1a:	2000      	movs	r0, #0
            break;
   10f1c:	e7ae      	b.n	10e7c <am_hal_cachectrl_control+0x24>
   10f1e:	bf00      	nop
   10f20:	40018000 	.word	0x40018000
   10f24:	40018004 	.word	0x40018004

00010f28 <am_hal_clkgen_control>:
am_hal_clkgen_control(am_hal_clkgen_control_e eControl, void *pArgs)
{
    uint32_t ui32Regval;

#if AM_CMSIS_REGS
    switch ( eControl )
   10f28:	2809      	cmp	r0, #9
   10f2a:	d852      	bhi.n	10fd2 <am_hal_clkgen_control+0xaa>
   10f2c:	e8df f000 	tbb	[pc, r0]
   10f30:	2b21190d 	.word	0x2b21190d
   10f34:	51513d33 	.word	0x51513d33
   10f38:	0547      	.short	0x0547
            ui32Regval |= _VAL2FLD(CLKGEN_HFADJ_HFADJEN, CLKGEN_HFADJ_HFADJEN_EN);
            CLKGEN->HFADJ = ui32Regval;
            break;

        case AM_HAL_CLKGEN_CONTROL_HFADJ_DISABLE:
            CLKGEN->HFADJ_b.HFADJEN = 0;
   10f3a:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000


    //
    // Return success status.
    //
    return AM_HAL_STATUS_SUCCESS;
   10f3e:	2000      	movs	r0, #0
            CLKGEN->HFADJ_b.HFADJEN = 0;
   10f40:	6a1a      	ldr	r2, [r3, #32]
   10f42:	f36f 0200 	bfc	r2, #0, #1
   10f46:	621a      	str	r2, [r3, #32]
            break;
   10f48:	4770      	bx	lr
            CLKGEN->CLKKEY         = CLKGEN_CLKKEY_CLKKEY_Key;
   10f4a:	f04f 2c40 	mov.w	ip, #1073758208	; 0x40004000
            CLKGEN->CCTRL          = CLKGEN_CCTRL_CORESEL_HFRC;
   10f4e:	2100      	movs	r1, #0
            CLKGEN->CLKKEY         = CLKGEN_CLKKEY_CLKKEY_Key;
   10f50:	2047      	movs	r0, #71	; 0x47
   10f52:	f8cc 0014 	str.w	r0, [ip, #20]
            CLKGEN->CCTRL          = CLKGEN_CCTRL_CORESEL_HFRC;
   10f56:	f8cc 1018 	str.w	r1, [ip, #24]
    return AM_HAL_STATUS_SUCCESS;
   10f5a:	4608      	mov	r0, r1
            CLKGEN->CLKKEY         = 0;
   10f5c:	f8cc 1014 	str.w	r1, [ip, #20]
            break;
   10f60:	4770      	bx	lr
            CLKGEN->OCTRL         &= ~_VAL2FLD(CLKGEN_OCTRL_STOPXT,
   10f62:	f04f 2140 	mov.w	r1, #1073758208	; 0x40004000
    return AM_HAL_STATUS_SUCCESS;
   10f66:	2000      	movs	r0, #0
            CLKGEN->OCTRL         &= ~_VAL2FLD(CLKGEN_OCTRL_STOPXT,
   10f68:	68ca      	ldr	r2, [r1, #12]
   10f6a:	f022 0301 	bic.w	r3, r2, #1
   10f6e:	60cb      	str	r3, [r1, #12]
            break;
   10f70:	4770      	bx	lr
            CLKGEN->OCTRL         &= ~_VAL2FLD(CLKGEN_OCTRL_STOPRC,
   10f72:	f04f 2c40 	mov.w	ip, #1073758208	; 0x40004000
    return AM_HAL_STATUS_SUCCESS;
   10f76:	2000      	movs	r0, #0
            CLKGEN->OCTRL         &= ~_VAL2FLD(CLKGEN_OCTRL_STOPRC,
   10f78:	f8dc 200c 	ldr.w	r2, [ip, #12]
   10f7c:	f022 0302 	bic.w	r3, r2, #2
   10f80:	f8cc 300c 	str.w	r3, [ip, #12]
            break;
   10f84:	4770      	bx	lr
            CLKGEN->OCTRL         |= _VAL2FLD(CLKGEN_OCTRL_STOPXT,
   10f86:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
    return AM_HAL_STATUS_SUCCESS;
   10f8a:	2000      	movs	r0, #0
            CLKGEN->OCTRL         |= _VAL2FLD(CLKGEN_OCTRL_STOPXT,
   10f8c:	68d3      	ldr	r3, [r2, #12]
   10f8e:	f043 0101 	orr.w	r1, r3, #1
   10f92:	60d1      	str	r1, [r2, #12]
            break;
   10f94:	4770      	bx	lr
            CLKGEN->OCTRL         |= _VAL2FLD(CLKGEN_OCTRL_STOPRC,
   10f96:	f04f 2c40 	mov.w	ip, #1073758208	; 0x40004000
    return AM_HAL_STATUS_SUCCESS;
   10f9a:	2000      	movs	r0, #0
            CLKGEN->OCTRL         |= _VAL2FLD(CLKGEN_OCTRL_STOPRC,
   10f9c:	f8dc 300c 	ldr.w	r3, [ip, #12]
   10fa0:	f043 0102 	orr.w	r1, r3, #2
   10fa4:	f8cc 100c 	str.w	r1, [ip, #12]
            break;
   10fa8:	4770      	bx	lr
            CLKGEN->CLKKEY         = CLKGEN_CLKKEY_CLKKEY_Key;
   10faa:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
            CLKGEN->CLKKEY         = 0;
   10fae:	2200      	movs	r2, #0
            CLKGEN->CLKKEY         = CLKGEN_CLKKEY_CLKKEY_Key;
   10fb0:	2047      	movs	r0, #71	; 0x47
            CLKGEN->CCTRL          = CLKGEN_CCTRL_CORESEL_HFRC_DIV2;
   10fb2:	2101      	movs	r1, #1
            CLKGEN->CLKKEY         = CLKGEN_CLKKEY_CLKKEY_Key;
   10fb4:	6158      	str	r0, [r3, #20]
            CLKGEN->CCTRL          = CLKGEN_CCTRL_CORESEL_HFRC_DIV2;
   10fb6:	6199      	str	r1, [r3, #24]
    return AM_HAL_STATUS_SUCCESS;
   10fb8:	4610      	mov	r0, r2
            CLKGEN->CLKKEY         = 0;
   10fba:	615a      	str	r2, [r3, #20]
            break;
   10fbc:	4770      	bx	lr
            if ( pArgs == 0 )
   10fbe:	b151      	cbz	r1, 10fd6 <am_hal_clkgen_control+0xae>
   10fc0:	6808      	ldr	r0, [r1, #0]
   10fc2:	f040 0101 	orr.w	r1, r0, #1
            CLKGEN->HFADJ = ui32Regval;
   10fc6:	f04f 2c40 	mov.w	ip, #1073758208	; 0x40004000
    return AM_HAL_STATUS_SUCCESS;
   10fca:	2000      	movs	r0, #0
            CLKGEN->HFADJ = ui32Regval;
   10fcc:	f8cc 1020 	str.w	r1, [ip, #32]
            break;
   10fd0:	4770      	bx	lr
            return AM_HAL_STATUS_INVALID_ARG;
   10fd2:	2006      	movs	r0, #6
} // am_hal_clkgen_control()
   10fd4:	4770      	bx	lr
   10fd6:	4901      	ldr	r1, [pc, #4]	; (10fdc <am_hal_clkgen_control+0xb4>)
   10fd8:	e7f5      	b.n	10fc6 <am_hal_clkgen_control+0x9e>
   10fda:	bf00      	nop
   10fdc:	0025b801 	.word	0x0025b801

00010fe0 <am_hal_flash_delay>:
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   10fe0:	4b00      	ldr	r3, [pc, #0]	; (10fe4 <am_hal_flash_delay+0x4>)
   10fe2:	4718      	bx	r3
   10fe4:	0800009d 	.word	0x0800009d

00010fe8 <am_hal_flash_delay_status_check>:
//*****************************************************************************
uint32_t
am_hal_flash_delay_status_check(uint32_t ui32usMaxDelay, uint32_t ui32Address,
                                uint32_t ui32Mask, uint32_t ui32Value,
                                bool bIsEqual)
{
   10fe8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   10fec:	f89d e020 	ldrb.w	lr, [sp, #32]
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   10ff0:	f8df 8248 	ldr.w	r8, [pc, #584]	; 1123c <am_hal_flash_delay_status_check+0x254>
{
   10ff4:	4607      	mov	r7, r0
   10ff6:	460c      	mov	r4, r1
   10ff8:	4615      	mov	r5, r2
   10ffa:	461e      	mov	r6, r3
   10ffc:	f1be 0f00 	cmp.w	lr, #0
   11000:	f000 808e 	beq.w	11120 <am_hal_flash_delay_status_check+0x138>
   11004:	f010 0907 	ands.w	r9, r0, #7
   11008:	d044      	beq.n	11094 <am_hal_flash_delay_status_check+0xac>
        //
        // Check the status
        //
        if ( bIsEqual )
        {
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   1100a:	680b      	ldr	r3, [r1, #0]
   1100c:	4013      	ands	r3, r2
   1100e:	429e      	cmp	r6, r3
   11010:	f000 8083 	beq.w	1111a <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11014:	2001      	movs	r0, #1
   11016:	47c0      	blx	r8
   11018:	f1b9 0f01 	cmp.w	r9, #1
   1101c:	f107 37ff 	add.w	r7, r7, #4294967295
   11020:	d038      	beq.n	11094 <am_hal_flash_delay_status_check+0xac>
   11022:	f1b9 0f02 	cmp.w	r9, #2
   11026:	d02e      	beq.n	11086 <am_hal_flash_delay_status_check+0x9e>
   11028:	f1b9 0f03 	cmp.w	r9, #3
   1102c:	d024      	beq.n	11078 <am_hal_flash_delay_status_check+0x90>
   1102e:	f1b9 0f04 	cmp.w	r9, #4
   11032:	d01a      	beq.n	1106a <am_hal_flash_delay_status_check+0x82>
   11034:	f1b9 0f05 	cmp.w	r9, #5
   11038:	d010      	beq.n	1105c <am_hal_flash_delay_status_check+0x74>
   1103a:	f1b9 0f06 	cmp.w	r9, #6
   1103e:	d006      	beq.n	1104e <am_hal_flash_delay_status_check+0x66>
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   11040:	6820      	ldr	r0, [r4, #0]
   11042:	4028      	ands	r0, r5
   11044:	4286      	cmp	r6, r0
   11046:	d068      	beq.n	1111a <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11048:	2001      	movs	r0, #1
   1104a:	47c0      	blx	r8
   1104c:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   1104e:	6821      	ldr	r1, [r4, #0]
   11050:	4029      	ands	r1, r5
   11052:	428e      	cmp	r6, r1
   11054:	d061      	beq.n	1111a <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11056:	2001      	movs	r0, #1
   11058:	47c0      	blx	r8
   1105a:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   1105c:	6822      	ldr	r2, [r4, #0]
   1105e:	402a      	ands	r2, r5
   11060:	4296      	cmp	r6, r2
   11062:	d05a      	beq.n	1111a <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11064:	2001      	movs	r0, #1
   11066:	47c0      	blx	r8
   11068:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   1106a:	6823      	ldr	r3, [r4, #0]
   1106c:	402b      	ands	r3, r5
   1106e:	429e      	cmp	r6, r3
   11070:	d053      	beq.n	1111a <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11072:	2001      	movs	r0, #1
   11074:	47c0      	blx	r8
   11076:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   11078:	6820      	ldr	r0, [r4, #0]
   1107a:	4028      	ands	r0, r5
   1107c:	4286      	cmp	r6, r0
   1107e:	d04c      	beq.n	1111a <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11080:	2001      	movs	r0, #1
   11082:	47c0      	blx	r8
   11084:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   11086:	6821      	ldr	r1, [r4, #0]
   11088:	4029      	ands	r1, r5
   1108a:	428e      	cmp	r6, r1
   1108c:	d045      	beq.n	1111a <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   1108e:	2001      	movs	r0, #1
   11090:	3f01      	subs	r7, #1
   11092:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   11094:	6822      	ldr	r2, [r4, #0]
   11096:	402a      	ands	r2, r5
   11098:	4296      	cmp	r6, r2
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   1109a:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   1109e:	d03c      	beq.n	1111a <am_hal_flash_delay_status_check+0x132>
            {
                return AM_HAL_STATUS_SUCCESS;
            }
        }

        if ( ui32usMaxDelay-- )
   110a0:	2f00      	cmp	r7, #0
   110a2:	f000 80c8 	beq.w	11236 <am_hal_flash_delay_status_check+0x24e>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   110a6:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   110a8:	6823      	ldr	r3, [r4, #0]
   110aa:	402b      	ands	r3, r5
   110ac:	429e      	cmp	r6, r3
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   110ae:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   110b2:	d032      	beq.n	1111a <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   110b4:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   110b6:	6821      	ldr	r1, [r4, #0]
   110b8:	4029      	ands	r1, r5
   110ba:	428e      	cmp	r6, r1
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   110bc:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   110c0:	d02b      	beq.n	1111a <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   110c2:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   110c4:	6822      	ldr	r2, [r4, #0]
   110c6:	402a      	ands	r2, r5
   110c8:	4296      	cmp	r6, r2
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   110ca:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   110ce:	d024      	beq.n	1111a <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   110d0:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   110d2:	6823      	ldr	r3, [r4, #0]
   110d4:	402b      	ands	r3, r5
   110d6:	429e      	cmp	r6, r3
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   110d8:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   110dc:	d01d      	beq.n	1111a <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   110de:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   110e0:	6821      	ldr	r1, [r4, #0]
   110e2:	4029      	ands	r1, r5
   110e4:	428e      	cmp	r6, r1
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   110e6:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   110ea:	d016      	beq.n	1111a <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   110ec:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   110ee:	6822      	ldr	r2, [r4, #0]
   110f0:	402a      	ands	r2, r5
   110f2:	4296      	cmp	r6, r2
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   110f4:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   110f8:	d00f      	beq.n	1111a <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   110fa:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   110fc:	6820      	ldr	r0, [r4, #0]
   110fe:	4028      	ands	r0, r5
   11100:	4286      	cmp	r6, r0
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11102:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   11106:	d008      	beq.n	1111a <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11108:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   1110a:	6822      	ldr	r2, [r4, #0]
   1110c:	402a      	ands	r2, r5
   1110e:	4296      	cmp	r6, r2
   11110:	f1a7 0708 	sub.w	r7, r7, #8
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11114:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
   11118:	d1c2      	bne.n	110a0 <am_hal_flash_delay_status_check+0xb8>
                return AM_HAL_STATUS_SUCCESS;
   1111a:	2000      	movs	r0, #0
        }
    }

    return AM_HAL_STATUS_TIMEOUT;

} // am_hal_flash_delay_status_check()
   1111c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   11120:	f010 0907 	ands.w	r9, r0, #7
   11124:	d043      	beq.n	111ae <am_hal_flash_delay_status_check+0x1c6>
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   11126:	680b      	ldr	r3, [r1, #0]
   11128:	4013      	ands	r3, r2
   1112a:	429e      	cmp	r6, r3
   1112c:	d1f5      	bne.n	1111a <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   1112e:	2001      	movs	r0, #1
   11130:	47c0      	blx	r8
   11132:	f1b9 0f01 	cmp.w	r9, #1
   11136:	f107 37ff 	add.w	r7, r7, #4294967295
   1113a:	d038      	beq.n	111ae <am_hal_flash_delay_status_check+0x1c6>
   1113c:	f1b9 0f02 	cmp.w	r9, #2
   11140:	d02e      	beq.n	111a0 <am_hal_flash_delay_status_check+0x1b8>
   11142:	f1b9 0f03 	cmp.w	r9, #3
   11146:	d024      	beq.n	11192 <am_hal_flash_delay_status_check+0x1aa>
   11148:	f1b9 0f04 	cmp.w	r9, #4
   1114c:	d01a      	beq.n	11184 <am_hal_flash_delay_status_check+0x19c>
   1114e:	f1b9 0f05 	cmp.w	r9, #5
   11152:	d010      	beq.n	11176 <am_hal_flash_delay_status_check+0x18e>
   11154:	f1b9 0f06 	cmp.w	r9, #6
   11158:	d006      	beq.n	11168 <am_hal_flash_delay_status_check+0x180>
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   1115a:	6821      	ldr	r1, [r4, #0]
   1115c:	4029      	ands	r1, r5
   1115e:	428e      	cmp	r6, r1
   11160:	d1db      	bne.n	1111a <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11162:	2001      	movs	r0, #1
   11164:	47c0      	blx	r8
   11166:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   11168:	6822      	ldr	r2, [r4, #0]
   1116a:	402a      	ands	r2, r5
   1116c:	4296      	cmp	r6, r2
   1116e:	d1d4      	bne.n	1111a <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11170:	2001      	movs	r0, #1
   11172:	47c0      	blx	r8
   11174:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   11176:	6820      	ldr	r0, [r4, #0]
   11178:	4028      	ands	r0, r5
   1117a:	4286      	cmp	r6, r0
   1117c:	d1cd      	bne.n	1111a <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   1117e:	2001      	movs	r0, #1
   11180:	47c0      	blx	r8
   11182:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   11184:	6823      	ldr	r3, [r4, #0]
   11186:	402b      	ands	r3, r5
   11188:	429e      	cmp	r6, r3
   1118a:	d1c6      	bne.n	1111a <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   1118c:	2001      	movs	r0, #1
   1118e:	47c0      	blx	r8
   11190:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   11192:	6821      	ldr	r1, [r4, #0]
   11194:	4029      	ands	r1, r5
   11196:	428e      	cmp	r6, r1
   11198:	d1bf      	bne.n	1111a <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   1119a:	2001      	movs	r0, #1
   1119c:	47c0      	blx	r8
   1119e:	3f01      	subs	r7, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   111a0:	6822      	ldr	r2, [r4, #0]
   111a2:	402a      	ands	r2, r5
   111a4:	4296      	cmp	r6, r2
   111a6:	d1b8      	bne.n	1111a <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   111a8:	2001      	movs	r0, #1
   111aa:	3f01      	subs	r7, #1
   111ac:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   111ae:	6823      	ldr	r3, [r4, #0]
   111b0:	402b      	ands	r3, r5
   111b2:	429e      	cmp	r6, r3
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   111b4:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   111b8:	d1af      	bne.n	1111a <am_hal_flash_delay_status_check+0x132>
        if ( ui32usMaxDelay-- )
   111ba:	2f00      	cmp	r7, #0
   111bc:	d03b      	beq.n	11236 <am_hal_flash_delay_status_check+0x24e>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   111be:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   111c0:	6821      	ldr	r1, [r4, #0]
   111c2:	4029      	ands	r1, r5
   111c4:	428e      	cmp	r6, r1
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   111c6:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   111ca:	d1a6      	bne.n	1111a <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   111cc:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   111ce:	6822      	ldr	r2, [r4, #0]
   111d0:	402a      	ands	r2, r5
   111d2:	4296      	cmp	r6, r2
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   111d4:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   111d8:	d19f      	bne.n	1111a <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   111da:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   111dc:	6823      	ldr	r3, [r4, #0]
   111de:	402b      	ands	r3, r5
   111e0:	429e      	cmp	r6, r3
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   111e2:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   111e6:	d198      	bne.n	1111a <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   111e8:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   111ea:	6821      	ldr	r1, [r4, #0]
   111ec:	4029      	ands	r1, r5
   111ee:	428e      	cmp	r6, r1
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   111f0:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   111f4:	d191      	bne.n	1111a <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   111f6:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   111f8:	6822      	ldr	r2, [r4, #0]
   111fa:	402a      	ands	r2, r5
   111fc:	4296      	cmp	r6, r2
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   111fe:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   11202:	d18a      	bne.n	1111a <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11204:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   11206:	6823      	ldr	r3, [r4, #0]
   11208:	402b      	ands	r3, r5
   1120a:	429e      	cmp	r6, r3
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   1120c:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   11210:	d183      	bne.n	1111a <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11212:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   11214:	6820      	ldr	r0, [r4, #0]
   11216:	4028      	ands	r0, r5
   11218:	4286      	cmp	r6, r0
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   1121a:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   1121e:	f47f af7c 	bne.w	1111a <am_hal_flash_delay_status_check+0x132>
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   11222:	47c0      	blx	r8
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   11224:	6823      	ldr	r3, [r4, #0]
   11226:	402b      	ands	r3, r5
   11228:	429e      	cmp	r6, r3
   1122a:	f1a7 0708 	sub.w	r7, r7, #8
    g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
   1122e:	f04f 0001 	mov.w	r0, #1
            if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
   11232:	d0c2      	beq.n	111ba <am_hal_flash_delay_status_check+0x1d2>
   11234:	e771      	b.n	1111a <am_hal_flash_delay_status_check+0x132>
    return AM_HAL_STATUS_TIMEOUT;
   11236:	2004      	movs	r0, #4
   11238:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1123c:	0800009d 	.word	0x0800009d

00011240 <am_hal_flash_load_ui32>:
//
//*****************************************************************************
uint32_t
am_hal_flash_load_ui32(uint32_t *pui32Address)
{
    return g_am_hal_flash.flash_util_read_word(pui32Address);
   11240:	4b00      	ldr	r3, [pc, #0]	; (11244 <am_hal_flash_load_ui32+0x4>)
   11242:	4718      	bx	r3
   11244:	08000075 	.word	0x08000075

00011248 <am_hal_flash_store_ui32>:
    // Call the simple routine that has been coded in SRAM.
    // First set up a function pointer to the array, being sure to set the
    //  .T bit (Thumb bit, bit0) in the branch address, then use that
    //  function ptr to call the SRAM function.
    //
    uint32_t SRAMCode = (uint32_t)SRAM_write_ui32 | 0x1;
   11248:	4b01      	ldr	r3, [pc, #4]	; (11250 <am_hal_flash_store_ui32+0x8>)
   1124a:	f043 0201 	orr.w	r2, r3, #1
    uint32_t (*pFunc)(uint32_t*,uint32_t) = (uint32_t (*)(uint32_t*,uint32_t))SRAMCode;
    (*pFunc)(pui32Address, ui32Value);
   1124e:	4710      	bx	r2
   11250:	1000100c 	.word	0x1000100c

00011254 <am_hal_gpio_pinconfig>:
    uint32_t ui32Padreg, ui32AltPadCfg, ui32GPCfg;
    uint32_t ui32Funcsel, ui32PowerSw;
    bool bClearEnable = false;

#ifdef AM_HAL_ENABLE_API_VALIDATION
    if ( ui32Pin > 49 )
   11254:	2831      	cmp	r0, #49	; 0x31
   11256:	d901      	bls.n	1125c <am_hal_gpio_pinconfig+0x8>
    {
        return AM_HAL_STATUS_INVALID_ARG;
   11258:	2006      	movs	r0, #6
   1125a:	4770      	bx	lr
{
   1125c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ui32GPCfg = ui32Padreg = ui32AltPadCfg = 0;

    //
    // Get the requested function and/or power switch.
    //
    ui32Funcsel = bfGpioCfg.uFuncSel;
   11260:	f001 0307 	and.w	r3, r1, #7
    ui32Padreg |= ui32Funcsel << PADREG_FLD_FNSEL_S;

    //
    // Check for invalid configuration requests.
    //
    if ( bfGpioCfg.ePullup != AM_HAL_GPIO_PIN_PULLUP_NONE )
   11264:	f011 04e0 	ands.w	r4, r1, #224	; 0xe0
{
   11268:	b087      	sub	sp, #28
    ui32Padreg |= ui32Funcsel << PADREG_FLD_FNSEL_S;
   1126a:	ea4f 05c3 	mov.w	r5, r3, lsl #3
    if ( bfGpioCfg.ePullup != AM_HAL_GPIO_PIN_PULLUP_NONE )
   1126e:	d014      	beq.n	1129a <am_hal_gpio_pinconfig+0x46>
        ui32Padreg |= (0x1 << PADREG_FLD_PULLUP_S);

        //
        // Check for specific pullup or pulldown settings.
        //
        if ( (bfGpioCfg.ePullup >= AM_HAL_GPIO_PIN_PULLUP_1_5K) &&
   11270:	f3c1 1642 	ubfx	r6, r1, #5, #3
   11274:	1db2      	adds	r2, r6, #6
   11276:	f002 0707 	and.w	r7, r2, #7
   1127a:	2f03      	cmp	r7, #3
        ui32Padreg |= (0x1 << PADREG_FLD_PULLUP_S);
   1127c:	f045 0501 	orr.w	r5, r5, #1
        if ( (bfGpioCfg.ePullup >= AM_HAL_GPIO_PIN_PULLUP_1_5K) &&
   11280:	f200 80ab 	bhi.w	113da <am_hal_gpio_pinconfig+0x186>
             (bfGpioCfg.ePullup <= AM_HAL_GPIO_PIN_PULLUP_24K) )
        {
            ui32Padreg |= ((bfGpioCfg.ePullup - AM_HAL_GPIO_PIN_PULLUP_1_5K) <<
                           PADREG_FLD_76_S);
#ifdef AM_HAL_ENABLE_API_VALIDATION
            if ( !(g_ui8Bit76Capabilities[ui32Pin] & CAP_PUP) )
   11284:	4a85      	ldr	r2, [pc, #532]	; (1149c <am_hal_gpio_pinconfig+0x248>)
   11286:	5c17      	ldrb	r7, [r2, r0]
   11288:	07ff      	lsls	r7, r7, #31
   1128a:	d403      	bmi.n	11294 <am_hal_gpio_pinconfig+0x40>
            {
                return AM_HAL_GPIO_ERR_PULLUP;
   1128c:	4884      	ldr	r0, [pc, #528]	; (114a0 <am_hal_gpio_pinconfig+0x24c>)

    AM_CRITICAL_END

    return AM_HAL_STATUS_SUCCESS;

} // am_hal_gpio_pinconfig()
   1128e:	b007      	add	sp, #28
   11290:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            ui32Padreg |= ((bfGpioCfg.ePullup - AM_HAL_GPIO_PIN_PULLUP_1_5K) <<
   11294:	1eb4      	subs	r4, r6, #2
   11296:	ea45 1584 	orr.w	r5, r5, r4, lsl #6
    ui32PowerSw = bfGpioCfg.ePowerSw;
   1129a:	f3c1 06c1 	ubfx	r6, r1, #3, #2
    if ( ui32PowerSw != AM_HAL_GPIO_PIN_POWERSW_NONE )
   1129e:	2e00      	cmp	r6, #0
   112a0:	f040 8095 	bne.w	113ce <am_hal_gpio_pinconfig+0x17a>
    ui32Padreg |= (g_ui8Inpen[ui32Pin] & (1 << ui32Funcsel)) ? (1 << PADREG_FLD_INPEN_S) : 0;
   112a4:	4a7f      	ldr	r2, [pc, #508]	; (114a4 <am_hal_gpio_pinconfig+0x250>)
    if ( g_ui8nCEpins[ui32Pin] == ui32Funcsel )
   112a6:	4f80      	ldr	r7, [pc, #512]	; (114a8 <am_hal_gpio_pinconfig+0x254>)
    ui32Padreg |= (g_ui8Inpen[ui32Pin] & (1 << ui32Funcsel)) ? (1 << PADREG_FLD_INPEN_S) : 0;
   112a8:	5c16      	ldrb	r6, [r2, r0]
    if ( g_ui8nCEpins[ui32Pin] == ui32Funcsel )
   112aa:	f817 8000 	ldrb.w	r8, [r7, r0]
    ui32Padreg |= (g_ui8Inpen[ui32Pin] & (1 << ui32Funcsel)) ? (1 << PADREG_FLD_INPEN_S) : 0;
   112ae:	411e      	asrs	r6, r3
   112b0:	f016 0f01 	tst.w	r6, #1
   112b4:	bf0c      	ite	eq
   112b6:	2600      	moveq	r6, #0
   112b8:	2602      	movne	r6, #2
    if ( g_ui8nCEpins[ui32Pin] == ui32Funcsel )
   112ba:	4543      	cmp	r3, r8
    ui32Padreg |= (g_ui8Inpen[ui32Pin] & (1 << ui32Funcsel)) ? (1 << PADREG_FLD_INPEN_S) : 0;
   112bc:	ea45 0506 	orr.w	r5, r5, r6
    if ( g_ui8nCEpins[ui32Pin] == ui32Funcsel )
   112c0:	f000 8097 	beq.w	113f2 <am_hal_gpio_pinconfig+0x19e>
                     (((bfGpioCfg.eIntDir >> 0) & 0x1) << GPIOCFG_FLD_INTD_S)   |
   112c4:	f3c1 3341 	ubfx	r3, r1, #13, #2
   112c8:	00df      	lsls	r7, r3, #3
        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
   112ca:	f3c1 2907 	ubfx	r9, r1, #8, #8
                     (((bfGpioCfg.eIntDir >> 0) & 0x1) << GPIOCFG_FLD_INTD_S)   |
   112ce:	f007 0408 	and.w	r4, r7, #8
                     (((bfGpioCfg.eIntDir >> 1) & 0x1) << GPIOCFG_FLD_INCFG_S);
   112d2:	105a      	asrs	r2, r3, #1
        ui32GPCfg |= (bfGpioCfg.eGPOutcfg << GPIOCFG_FLD_OUTCFG_S)              |
   112d4:	f3c1 2681 	ubfx	r6, r1, #10, #2
        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
   112d8:	f009 070c 	and.w	r7, r9, #12
                     (((bfGpioCfg.eIntDir >> 0) & 0x1) << GPIOCFG_FLD_INTD_S)   |
   112dc:	ea42 0346 	orr.w	r3, r2, r6, lsl #1
        ui32Padreg |= (bfGpioCfg.eGPInput << PADREG_FLD_INPEN_S);
   112e0:	f3c1 3a00 	ubfx	sl, r1, #12, #1
        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
   112e4:	2f04      	cmp	r7, #4
                     (((bfGpioCfg.eIntDir >> 0) & 0x1) << GPIOCFG_FLD_INTD_S)   |
   112e6:	ea43 0804 	orr.w	r8, r3, r4
        ui32Padreg |= (bfGpioCfg.eGPInput << PADREG_FLD_INPEN_S);
   112ea:	ea45 054a 	orr.w	r5, r5, sl, lsl #1
        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
   112ee:	f000 808d 	beq.w	1140c <am_hal_gpio_pinconfig+0x1b8>
    ui32B = *((uint32_t*)cfg2);
   112f2:	4a6e      	ldr	r2, [pc, #440]	; (114ac <am_hal_gpio_pinconfig+0x258>)
        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
   112f4:	6816      	ldr	r6, [r2, #0]
   112f6:	1b8c      	subs	r4, r1, r6
   112f8:	fab4 f384 	clz	r3, r4
   112fc:	095f      	lsrs	r7, r3, #5
   112fe:	9700      	str	r7, [sp, #0]
        if ( bfGpioCfg.eIntDir == 0 )
   11300:	f019 0f60 	tst.w	r9, #96	; 0x60
            ui32GPCfg |= (bfGpioCfg.eGPRdZero << GPIOCFG_FLD_INCFG_S);
   11304:	bf04      	itt	eq
   11306:	f3c1 37c0 	ubfxeq	r7, r1, #15, #1
   1130a:	f367 0800 	bfieq	r8, r7, #0, #1
   1130e:	0087      	lsls	r7, r0, #2
    switch ( bfGpioCfg.eDriveStrength )
   11310:	f3c1 2101 	ubfx	r1, r1, #8, #2
   11314:	2902      	cmp	r1, #2
   11316:	ea4f 04c0 	mov.w	r4, r0, lsl #3
   1131a:	d07a      	beq.n	11412 <am_hal_gpio_pinconfig+0x1be>
   1131c:	d87f      	bhi.n	1141e <am_hal_gpio_pinconfig+0x1ca>
   1131e:	2901      	cmp	r1, #1
            ui32Padreg    |= (1 << PADREG_FLD_DRVSTR_S);
   11320:	bf08      	it	eq
   11322:	f045 0504 	orreq.w	r5, r5, #4
   11326:	f004 0a18 	and.w	sl, r4, #24
            break;
   1132a:	2200      	movs	r2, #0
   1132c:	4604      	mov	r4, r0
   1132e:	9203      	str	r2, [sp, #12]
    ui32GPCfgClearMask  = ~((uint32_t)0xF  << ui32GPCfgShft);
   11330:	f04f 0b0f 	mov.w	fp, #15
    ui32GPCfgShft       = ((ui32Pin & 0x7) << 2);
   11334:	f007 021c 	and.w	r2, r7, #28
    ui32GPCfgAddr       = (uint32_t)&GPIO->CFGA       + ((ui32Pin & ~0x7) >> 1);
   11338:	485d      	ldr	r0, [pc, #372]	; (114b0 <am_hal_gpio_pinconfig+0x25c>)
    ui32AltpadAddr      = (uint32_t)&GPIO->ALTPADCFGA + (ui32Pin & ~0x3);
   1133a:	495e      	ldr	r1, [pc, #376]	; (114b4 <am_hal_gpio_pinconfig+0x260>)
    ui32GPCfgAddr       = (uint32_t)&GPIO->CFGA       + ((ui32Pin & ~0x7) >> 1);
   1133c:	4f5e      	ldr	r7, [pc, #376]	; (114b8 <am_hal_gpio_pinconfig+0x264>)
   1133e:	9702      	str	r7, [sp, #8]
    ui32GPCfgClearMask  = ~((uint32_t)0xF  << ui32GPCfgShft);
   11340:	fa0b f302 	lsl.w	r3, fp, r2
    ui32PadClearMask    = ~((uint32_t)0xFF << ui32PadShft);
   11344:	f04f 0cff 	mov.w	ip, #255	; 0xff
   11348:	fa0c f60a 	lsl.w	r6, ip, sl
    ui32AltpadAddr      = (uint32_t)&GPIO->ALTPADCFGA + (ui32Pin & ~0x3);
   1134c:	9101      	str	r1, [sp, #4]
    ui32GPCfg     <<= ui32GPCfgShft;
   1134e:	fa08 f802 	lsl.w	r8, r8, r2
    ui32GPCfgClearMask  = ~((uint32_t)0xF  << ui32GPCfgShft);
   11352:	43df      	mvns	r7, r3
    ui32GPCfgAddr       = (uint32_t)&GPIO->CFGA       + ((ui32Pin & ~0x7) >> 1);
   11354:	ea00 0954 	and.w	r9, r0, r4, lsr #1
    AM_CRITICAL_BEGIN
   11358:	f000 f8be 	bl	114d8 <am_hal_interrupt_master_disable>
   1135c:	9005      	str	r0, [sp, #20]
    if ( bClearEnable )
   1135e:	e89d 0009 	ldmia.w	sp, {r0, r3}
    ui32PadregAddr      = (uint32_t)&GPIO->PADREGA    + (ui32Pin & ~0x3);
   11362:	f024 0b03 	bic.w	fp, r4, #3
    ui32Padreg    <<= ui32PadShft;
   11366:	fa05 f50a 	lsl.w	r5, r5, sl
    ui32PadregAddr      = (uint32_t)&GPIO->PADREGA    + (ui32Pin & ~0x3);
   1136a:	f10b 4a80 	add.w	sl, fp, #1073741824	; 0x40000000
    ui32PadClearMask    = ~((uint32_t)0xFF << ui32PadShft);
   1136e:	43f6      	mvns	r6, r6
    ui32PadregAddr      = (uint32_t)&GPIO->PADREGA    + (ui32Pin & ~0x3);
   11370:	f50a 3a80 	add.w	sl, sl, #65536	; 0x10000
    if ( bClearEnable )
   11374:	9902      	ldr	r1, [sp, #8]
   11376:	9a03      	ldr	r2, [sp, #12]
   11378:	b150      	cbz	r0, 11390 <am_hal_gpio_pinconfig+0x13c>
        am_hal_gpio_output_tristate_disable(ui32Pin);
   1137a:	f004 001f 	and.w	r0, r4, #31
   1137e:	ea4f 1e54 	mov.w	lr, r4, lsr #5
   11382:	f04f 0c01 	mov.w	ip, #1
   11386:	4c4d      	ldr	r4, [pc, #308]	; (114bc <am_hal_gpio_pinconfig+0x268>)
   11388:	fa0c f000 	lsl.w	r0, ip, r0
   1138c:	f844 002e 	str.w	r0, [r4, lr, lsl #2]
    GPIO->PADKEY = GPIO_PADKEY_PADKEY_Key;
   11390:	484b      	ldr	r0, [pc, #300]	; (114c0 <am_hal_gpio_pinconfig+0x26c>)
   11392:	2473      	movs	r4, #115	; 0x73
   11394:	6604      	str	r4, [r0, #96]	; 0x60
    AM_REGVAL(ui32PadregAddr)  = (AM_REGVAL(ui32PadregAddr) & ui32PadClearMask)   | ui32Padreg;
   11396:	f8da 4000 	ldr.w	r4, [sl]
   1139a:	4034      	ands	r4, r6
   1139c:	4325      	orrs	r5, r4
   1139e:	f8ca 5000 	str.w	r5, [sl]
    AM_REGVAL(ui32GPCfgAddr)   = (AM_REGVAL(ui32GPCfgAddr)  & ui32GPCfgClearMask) | ui32GPCfg;
   113a2:	f859 5001 	ldr.w	r5, [r9, r1]
   113a6:	402f      	ands	r7, r5
   113a8:	ea47 0708 	orr.w	r7, r7, r8
   113ac:	f849 7001 	str.w	r7, [r9, r1]
    AM_REGVAL(ui32AltpadAddr)  = (AM_REGVAL(ui32AltpadAddr) & ui32PadClearMask)   | ui32AltPadCfg;
   113b0:	f85b 1003 	ldr.w	r1, [fp, r3]
   113b4:	400e      	ands	r6, r1
   113b6:	4332      	orrs	r2, r6
    GPIO->PADKEY = 0;
   113b8:	2600      	movs	r6, #0
    AM_REGVAL(ui32AltpadAddr)  = (AM_REGVAL(ui32AltpadAddr) & ui32PadClearMask)   | ui32AltPadCfg;
   113ba:	f84b 2003 	str.w	r2, [fp, r3]
    GPIO->PADKEY = 0;
   113be:	6606      	str	r6, [r0, #96]	; 0x60
    AM_CRITICAL_END
   113c0:	9805      	ldr	r0, [sp, #20]
   113c2:	f000 f88d 	bl	114e0 <am_hal_interrupt_master_set>
    return AM_HAL_STATUS_SUCCESS;
   113c6:	4630      	mov	r0, r6
} // am_hal_gpio_pinconfig()
   113c8:	b007      	add	sp, #28
   113ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ( (ui32PowerSw == AM_HAL_GPIO_PIN_POWERSW_VDD)  &&
   113ce:	2e01      	cmp	r6, #1
   113d0:	d015      	beq.n	113fe <am_hal_gpio_pinconfig+0x1aa>
        else if ( (ui32PowerSw == AM_HAL_GPIO_PIN_POWERSW_VSS)  &&
   113d2:	2e02      	cmp	r6, #2
   113d4:	d030      	beq.n	11438 <am_hal_gpio_pinconfig+0x1e4>
            return AM_HAL_GPIO_ERR_PWRSW;
   113d6:	483b      	ldr	r0, [pc, #236]	; (114c4 <am_hal_gpio_pinconfig+0x270>)
   113d8:	e759      	b.n	1128e <am_hal_gpio_pinconfig+0x3a>
        else if ( bfGpioCfg.ePullup == AM_HAL_GPIO_PIN_PULLDOWN )
   113da:	2cc0      	cmp	r4, #192	; 0xc0
   113dc:	d027      	beq.n	1142e <am_hal_gpio_pinconfig+0x1da>
        else if ( bfGpioCfg.ePullup == AM_HAL_GPIO_PIN_PULLUP_WEAK )
   113de:	2c20      	cmp	r4, #32
   113e0:	f47f af5b 	bne.w	1129a <am_hal_gpio_pinconfig+0x46>
            if ( g_ui8Bit76Capabilities[ui32Pin] & (CAP_PUP | CAP_PDN) )
   113e4:	4c2d      	ldr	r4, [pc, #180]	; (1149c <am_hal_gpio_pinconfig+0x248>)
   113e6:	5c26      	ldrb	r6, [r4, r0]
   113e8:	f016 0f09 	tst.w	r6, #9
   113ec:	f47f af4e 	bne.w	1128c <am_hal_gpio_pinconfig+0x38>
   113f0:	e753      	b.n	1129a <am_hal_gpio_pinconfig+0x46>
        if ( bfGpioCfg.uIOMnum > IOMNUM_MAX )
   113f2:	f3c1 4202 	ubfx	r2, r1, #16, #3
   113f6:	2a07      	cmp	r2, #7
   113f8:	d125      	bne.n	11446 <am_hal_gpio_pinconfig+0x1f2>
            return AM_HAL_GPIO_ERR_INVCE;   // Invalid CE specified
   113fa:	4833      	ldr	r0, [pc, #204]	; (114c8 <am_hal_gpio_pinconfig+0x274>)
   113fc:	e747      	b.n	1128e <am_hal_gpio_pinconfig+0x3a>
             (g_ui8Bit76Capabilities[ui32Pin] & CAP_VDD) )
   113fe:	4c27      	ldr	r4, [pc, #156]	; (1149c <am_hal_gpio_pinconfig+0x248>)
        if ( (ui32PowerSw == AM_HAL_GPIO_PIN_POWERSW_VDD)  &&
   11400:	5c26      	ldrb	r6, [r4, r0]
   11402:	07b4      	lsls	r4, r6, #30
   11404:	d5e7      	bpl.n	113d6 <am_hal_gpio_pinconfig+0x182>
            ui32Padreg |= 0x1 << PADREG_FLD_76_S;
   11406:	f045 0540 	orr.w	r5, r5, #64	; 0x40
   1140a:	e74b      	b.n	112a4 <am_hal_gpio_pinconfig+0x50>
            bClearEnable = true;
   1140c:	2701      	movs	r7, #1
   1140e:	9700      	str	r7, [sp, #0]
   11410:	e776      	b.n	11300 <am_hal_gpio_pinconfig+0xac>
   11412:	f004 0a18 	and.w	sl, r4, #24
   11416:	2301      	movs	r3, #1
   11418:	fa03 f20a 	lsl.w	r2, r3, sl
            break;
   1141c:	e786      	b.n	1132c <am_hal_gpio_pinconfig+0xd8>
   1141e:	f004 0a18 	and.w	sl, r4, #24
   11422:	2601      	movs	r6, #1
            ui32Padreg    |= (1 << PADREG_FLD_DRVSTR_S);
   11424:	f045 0504 	orr.w	r5, r5, #4
   11428:	fa06 f20a 	lsl.w	r2, r6, sl
            break;
   1142c:	e77e      	b.n	1132c <am_hal_gpio_pinconfig+0xd8>
            if ( ui32Pin != 20 )
   1142e:	2814      	cmp	r0, #20
   11430:	f43f af33 	beq.w	1129a <am_hal_gpio_pinconfig+0x46>
                return AM_HAL_GPIO_ERR_PULLDOWN;
   11434:	4825      	ldr	r0, [pc, #148]	; (114cc <am_hal_gpio_pinconfig+0x278>)
   11436:	e72a      	b.n	1128e <am_hal_gpio_pinconfig+0x3a>
                  (g_ui8Bit76Capabilities[ui32Pin] & CAP_VSS) )
   11438:	4a18      	ldr	r2, [pc, #96]	; (1149c <am_hal_gpio_pinconfig+0x248>)
        else if ( (ui32PowerSw == AM_HAL_GPIO_PIN_POWERSW_VSS)  &&
   1143a:	5c17      	ldrb	r7, [r2, r0]
   1143c:	077a      	lsls	r2, r7, #29
   1143e:	d5ca      	bpl.n	113d6 <am_hal_gpio_pinconfig+0x182>
            ui32Padreg |= 0x2 << PADREG_FLD_76_S;
   11440:	f045 0580 	orr.w	r5, r5, #128	; 0x80
   11444:	e72e      	b.n	112a4 <am_hal_gpio_pinconfig+0x50>
            if ( g_ui8NCEtable[ui32Pin][ui32Outcfg] == ui8CEtbl )
   11446:	4c22      	ldr	r4, [pc, #136]	; (114d0 <am_hal_gpio_pinconfig+0x27c>)
        ui8CEtbl = (bfGpioCfg.uIOMnum << 4) | bfGpioCfg.uNCE;
   11448:	f3c1 4cc1 	ubfx	ip, r1, #19, #2
            if ( g_ui8NCEtable[ui32Pin][ui32Outcfg] == ui8CEtbl )
   1144c:	f814 8020 	ldrb.w	r8, [r4, r0, lsl #2]
        ui8CEtbl = (bfGpioCfg.uIOMnum << 4) | bfGpioCfg.uNCE;
   11450:	ea4c 1602 	orr.w	r6, ip, r2, lsl #4
            if ( g_ui8NCEtable[ui32Pin][ui32Outcfg] == ui8CEtbl )
   11454:	45b0      	cmp	r8, r6
   11456:	d010      	beq.n	1147a <am_hal_gpio_pinconfig+0x226>
   11458:	0087      	lsls	r7, r0, #2
   1145a:	eb04 0907 	add.w	r9, r4, r7
   1145e:	f899 3001 	ldrb.w	r3, [r9, #1]
   11462:	42b3      	cmp	r3, r6
   11464:	d015      	beq.n	11492 <am_hal_gpio_pinconfig+0x23e>
   11466:	f899 2002 	ldrb.w	r2, [r9, #2]
   1146a:	42b2      	cmp	r2, r6
   1146c:	d00f      	beq.n	1148e <am_hal_gpio_pinconfig+0x23a>
   1146e:	f899 4003 	ldrb.w	r4, [r9, #3]
   11472:	42b4      	cmp	r4, r6
   11474:	d00f      	beq.n	11496 <am_hal_gpio_pinconfig+0x242>
            return AM_HAL_GPIO_ERR_INVCEPIN;
   11476:	4817      	ldr	r0, [pc, #92]	; (114d4 <am_hal_gpio_pinconfig+0x280>)
   11478:	e709      	b.n	1128e <am_hal_gpio_pinconfig+0x3a>
        for ( ui32Outcfg = 0; ui32Outcfg < 4; ui32Outcfg++ )
   1147a:	2600      	movs	r6, #0
   1147c:	0087      	lsls	r7, r0, #2
        ui32GPCfg |= (ui32Outcfg       << GPIOCFG_FLD_OUTCFG_S) |
   1147e:	0072      	lsls	r2, r6, #1
                     (bfGpioCfg.eCEpol << GPIOCFG_FLD_INTD_S)   |
   11480:	f3c1 5e40 	ubfx	lr, r1, #21, #1
    bool bClearEnable = false;
   11484:	2300      	movs	r3, #0
                     (bfGpioCfg.eCEpol << GPIOCFG_FLD_INTD_S)   |
   11486:	ea42 08ce 	orr.w	r8, r2, lr, lsl #3
    bool bClearEnable = false;
   1148a:	9300      	str	r3, [sp, #0]
   1148c:	e740      	b.n	11310 <am_hal_gpio_pinconfig+0xbc>
        for ( ui32Outcfg = 0; ui32Outcfg < 4; ui32Outcfg++ )
   1148e:	2602      	movs	r6, #2
   11490:	e7f5      	b.n	1147e <am_hal_gpio_pinconfig+0x22a>
   11492:	2601      	movs	r6, #1
   11494:	e7f3      	b.n	1147e <am_hal_gpio_pinconfig+0x22a>
   11496:	2603      	movs	r6, #3
   11498:	e7f1      	b.n	1147e <am_hal_gpio_pinconfig+0x22a>
   1149a:	bf00      	nop
   1149c:	00012fd0 	.word	0x00012fd0
   114a0:	08000100 	.word	0x08000100
   114a4:	00013004 	.word	0x00013004
   114a8:	00013100 	.word	0x00013100
   114ac:	00012fcc 	.word	0x00012fcc
   114b0:	7ffffffc 	.word	0x7ffffffc
   114b4:	400100e0 	.word	0x400100e0
   114b8:	40010040 	.word	0x40010040
   114bc:	400100b4 	.word	0x400100b4
   114c0:	40010000 	.word	0x40010000
   114c4:	08000102 	.word	0x08000102
   114c8:	08000103 	.word	0x08000103
   114cc:	08000101 	.word	0x08000101
   114d0:	00013038 	.word	0x00013038
   114d4:	08000104 	.word	0x08000104

000114d8 <am_hal_interrupt_master_disable>:
//*****************************************************************************
#if defined(__GNUC_STDC_INLINE__)
uint32_t __attribute__((naked))
am_hal_interrupt_master_disable(void)
{
    __asm("    mrs     r0, PRIMASK");
   114d8:	f3ef 8010 	mrs	r0, PRIMASK
    __asm("    cpsid i");
   114dc:	b672      	cpsid	i
    __asm("    bx lr");
   114de:	4770      	bx	lr

000114e0 <am_hal_interrupt_master_set>:
//*****************************************************************************
#if defined(__GNUC_STDC_INLINE__)
void __attribute__((naked))
am_hal_interrupt_master_set(uint32_t ui32InterruptState)
{
    __asm("    msr     PRIMASK, r0");
   114e0:	f380 8810 	msr	PRIMASK, r0
    __asm("    bx lr");
   114e4:	4770      	bx	lr
   114e6:	bf00      	nop

000114e8 <am_hal_itm_disable>:
//! @return None.
//
//*****************************************************************************
void
am_hal_itm_disable(void)
{
   114e8:	b510      	push	{r4, lr}

#if AM_CMSIS_REGS
    if ( MCUCTRL->TPIUCTRL == 0 )
   114ea:	4b24      	ldr	r3, [pc, #144]	; (1157c <am_hal_itm_disable+0x94>)
   114ec:	f8d3 0250 	ldr.w	r0, [r3, #592]	; 0x250
   114f0:	b9b0      	cbnz	r0, 11520 <am_hal_itm_disable+0x38>
    CoreDebug->DEMCR |= _VAL2FLD(CoreDebug_DEMCR_TRCENA, 1);
   114f2:	4923      	ldr	r1, [pc, #140]	; (11580 <am_hal_itm_disable+0x98>)
   114f4:	68ca      	ldr	r2, [r1, #12]
   114f6:	f042 7480 	orr.w	r4, r2, #16777216	; 0x1000000
   114fa:	60cc      	str	r4, [r1, #12]
    while ( !(CoreDebug->DEMCR & _VAL2FLD(CoreDebug_DEMCR_TRCENA, 1)) );
   114fc:	68cb      	ldr	r3, [r1, #12]
   114fe:	01da      	lsls	r2, r3, #7
   11500:	d5fc      	bpl.n	114fc <am_hal_itm_disable+0x14>
    ITM->LAR = ITM_LAR_KEYVAL;
   11502:	f04f 4c60 	mov.w	ip, #3758096384	; 0xe0000000
   11506:	481f      	ldr	r0, [pc, #124]	; (11584 <am_hal_itm_disable+0x9c>)
    ITM->TCR =
   11508:	4a1f      	ldr	r2, [pc, #124]	; (11588 <am_hal_itm_disable+0xa0>)
    ITM->LAR = ITM_LAR_KEYVAL;
   1150a:	f8cc 0fb0 	str.w	r0, [ip, #4016]	; 0xfb0
    ITM->TPR = 0x0000000F;
   1150e:	240f      	movs	r4, #15
    ITM->TER = 0xFFFFFFFF;
   11510:	f04f 31ff 	mov.w	r1, #4294967295
    ITM->TPR = 0x0000000F;
   11514:	f8cc 4e40 	str.w	r4, [ip, #3648]	; 0xe40
    ITM->TER = 0xFFFFFFFF;
   11518:	f8cc 1e00 	str.w	r1, [ip, #3584]	; 0xe00
    ITM->TCR =
   1151c:	f8cc 2e80 	str.w	r2, [ip, #3712]	; 0xe80
{
    //
    // Make sure the ITM/TPIU is not busy.
    //
#if AM_CMSIS_REGS
    while (ITM->TCR & _VAL2FLD(ITM_TCR_BUSY, 1));
   11520:	f04f 4460 	mov.w	r4, #3758096384	; 0xe0000000
   11524:	f8d4 3e80 	ldr.w	r3, [r4, #3712]	; 0xe80
   11528:	021b      	lsls	r3, r3, #8
   1152a:	d4fb      	bmi.n	11524 <am_hal_itm_disable+0x3c>
#endif // AM_CMSIS_REGS

    //
    // wait for 50us for the data to flush out
    //
    am_hal_flash_delay(FLASH_CYCLES_US(50));
   1152c:	f240 20f7 	movw	r0, #759	; 0x2f7
   11530:	f7ff fd56 	bl	10fe0 <am_hal_flash_delay>
    ITM->LAR = ITM_LAR_KEYVAL;
   11534:	4813      	ldr	r0, [pc, #76]	; (11584 <am_hal_itm_disable+0x9c>)
        while ( ITM->TCR  & (_VAL2FLD(ITM_TCR_ITMENA, 1)  |  _VAL2FLD(ITM_TCR_BUSY, 1)) );
   11536:	4915      	ldr	r1, [pc, #84]	; (1158c <am_hal_itm_disable+0xa4>)
    ITM->LAR = ITM_LAR_KEYVAL;
   11538:	f8c4 0fb0 	str.w	r0, [r4, #4016]	; 0xfb0
        ITM->TCR &= ~_VAL2FLD(ITM_TCR_ITMENA, 1);
   1153c:	f04f 4c60 	mov.w	ip, #3758096384	; 0xe0000000
    ITM->LAR = ITM_LAR_KEYVAL;
   11540:	2064      	movs	r0, #100	; 0x64
        ITM->TCR &= ~_VAL2FLD(ITM_TCR_ITMENA, 1);
   11542:	f8dc 2e80 	ldr.w	r2, [ip, #3712]	; 0xe80
   11546:	f022 0401 	bic.w	r4, r2, #1
   1154a:	f8cc 4e80 	str.w	r4, [ip, #3712]	; 0xe80
        while ( ITM->TCR  & (_VAL2FLD(ITM_TCR_ITMENA, 1)  |  _VAL2FLD(ITM_TCR_BUSY, 1)) );
   1154e:	f8dc 3e80 	ldr.w	r3, [ip, #3712]	; 0xe80
   11552:	420b      	tst	r3, r1
   11554:	d1fb      	bne.n	1154e <am_hal_itm_disable+0x66>
    for (int ix = 0; ix < 100; ix++)
   11556:	3801      	subs	r0, #1
   11558:	d1f3      	bne.n	11542 <am_hal_itm_disable+0x5a>
    CoreDebug->DEMCR &= ~_VAL2FLD(CoreDebug_DEMCR_TRCENA, 1);
   1155a:	4909      	ldr	r1, [pc, #36]	; (11580 <am_hal_itm_disable+0x98>)
   1155c:	68ca      	ldr	r2, [r1, #12]
   1155e:	f022 7480 	bic.w	r4, r2, #16777216	; 0x1000000
   11562:	60cc      	str	r4, [r1, #12]
    while ( CoreDebug->DEMCR & _VAL2FLD(CoreDebug_DEMCR_TRCENA, 1) );
   11564:	68cb      	ldr	r3, [r1, #12]
   11566:	f013 7080 	ands.w	r0, r3, #16777216	; 0x1000000
   1156a:	d1fb      	bne.n	11564 <am_hal_itm_disable+0x7c>
    MCUCTRL->TPIUCTRL =
   1156c:	4903      	ldr	r1, [pc, #12]	; (1157c <am_hal_itm_disable+0x94>)
   1156e:	f8c1 0250 	str.w	r0, [r1, #592]	; 0x250
    while (MCUCTRL->TPIUCTRL);
   11572:	f8d1 2250 	ldr.w	r2, [r1, #592]	; 0x250
   11576:	2a00      	cmp	r2, #0
   11578:	d1fb      	bne.n	11572 <am_hal_itm_disable+0x8a>
}
   1157a:	bd10      	pop	{r4, pc}
   1157c:	40020000 	.word	0x40020000
   11580:	e000edf0 	.word	0xe000edf0
   11584:	c5acce55 	.word	0xc5acce55
   11588:	00150511 	.word	0x00150511
   1158c:	00800001 	.word	0x00800001

00011590 <am_hal_mcuctrl_info_get>:
am_hal_mcuctrl_info_get(am_hal_mcuctrl_infoget_e eInfoGet, void *pInfo)
{
    am_hal_mcuctrl_feature_t *psFeature;
    uint32_t ui32Feature;

    if ( pInfo == NULL )
   11590:	b141      	cbz	r1, 115a4 <am_hal_mcuctrl_info_get+0x14>
    {
        return AM_HAL_STATUS_INVALID_ARG;
    }

#if AM_CMSIS_REGS
    switch ( eInfoGet )
   11592:	2801      	cmp	r0, #1
{
   11594:	b4f0      	push	{r4, r5, r6, r7}
    switch ( eInfoGet )
   11596:	d03a      	beq.n	1160e <am_hal_mcuctrl_info_get+0x7e>
   11598:	d322      	bcc.n	115e0 <am_hal_mcuctrl_info_get+0x50>
   1159a:	2802      	cmp	r0, #2
   1159c:	d004      	beq.n	115a8 <am_hal_mcuctrl_info_get+0x18>
        case AM_HAL_MCUCTRL_INFO_FAULT_STATUS:
            mcuctrl_fault_status((am_hal_mcuctrl_fault_t*)pInfo);
            break;

        default:
            return AM_HAL_STATUS_INVALID_ARG;
   1159e:	2006      	movs	r0, #6
    //
    // Return success status.
    //
    return AM_HAL_STATUS_SUCCESS;

} // am_hal_mcuctrl_info_get()
   115a0:	bcf0      	pop	{r4, r5, r6, r7}
   115a2:	4770      	bx	lr
        return AM_HAL_STATUS_INVALID_ARG;
   115a4:	2006      	movs	r0, #6
   115a6:	4770      	bx	lr
    ui32FaultStat = MCUCTRL->FAULTSTATUS;
   115a8:	4a41      	ldr	r2, [pc, #260]	; (116b0 <am_hal_mcuctrl_info_get+0x120>)
    psFault->ui32ICODE |= MCUCTRL->ICODEFAULTADDR;
   115aa:	684c      	ldr	r4, [r1, #4]
    ui32FaultStat = MCUCTRL->FAULTSTATUS;
   115ac:	f8d2 31cc 	ldr.w	r3, [r2, #460]	; 0x1cc
    psFault->ui32SYS |= MCUCTRL->SYSFAULTADDR;
   115b0:	6948      	ldr	r0, [r1, #20]
    psFault->bICODE = (bool)(ui32FaultStat & MCUCTRL_FAULTSTATUS_ICODEFAULT_Msk);
   115b2:	f003 0601 	and.w	r6, r3, #1
    psFault->bDCODE = (bool)(ui32FaultStat & MCUCTRL_FAULTSTATUS_DCODEFAULT_Msk);
   115b6:	f3c3 0540 	ubfx	r5, r3, #1, #1
    psFault->bSYS   = (bool)(ui32FaultStat & MCUCTRL_FAULTSTATUS_SYSFAULT_Msk);
   115ba:	f3c3 0780 	ubfx	r7, r3, #2, #1
    psFault->bDCODE = (bool)(ui32FaultStat & MCUCTRL_FAULTSTATUS_DCODEFAULT_Msk);
   115be:	720d      	strb	r5, [r1, #8]
    psFault->bSYS   = (bool)(ui32FaultStat & MCUCTRL_FAULTSTATUS_SYSFAULT_Msk);
   115c0:	740f      	strb	r7, [r1, #16]
    psFault->bICODE = (bool)(ui32FaultStat & MCUCTRL_FAULTSTATUS_ICODEFAULT_Msk);
   115c2:	700e      	strb	r6, [r1, #0]
    psFault->ui32DCODE = MCUCTRL->DCODEFAULTADDR;
   115c4:	f8d2 31c4 	ldr.w	r3, [r2, #452]	; 0x1c4
   115c8:	60cb      	str	r3, [r1, #12]
    psFault->ui32ICODE |= MCUCTRL->ICODEFAULTADDR;
   115ca:	f8d2 61c0 	ldr.w	r6, [r2, #448]	; 0x1c0
   115ce:	4334      	orrs	r4, r6
   115d0:	604c      	str	r4, [r1, #4]
    psFault->ui32SYS |= MCUCTRL->SYSFAULTADDR;
   115d2:	f8d2 21c8 	ldr.w	r2, [r2, #456]	; 0x1c8
   115d6:	4310      	orrs	r0, r2
   115d8:	6148      	str	r0, [r1, #20]
} // am_hal_mcuctrl_info_get()
   115da:	bcf0      	pop	{r4, r5, r6, r7}
    return AM_HAL_STATUS_SUCCESS;
   115dc:	2000      	movs	r0, #0
} // am_hal_mcuctrl_info_get()
   115de:	4770      	bx	lr
            ui32Feature = MCUCTRL->FEATUREENABLE;
   115e0:	4c33      	ldr	r4, [pc, #204]	; (116b0 <am_hal_mcuctrl_info_get+0x120>)
   115e2:	69a5      	ldr	r5, [r4, #24]
                _FLD2VAL(MCUCTRL_FEATUREENABLE_BURSTAVAIL, ui32Feature);
   115e4:	f3c5 1080 	ubfx	r0, r5, #6, #1
                _FLD2VAL(MCUCTRL_FEATUREENABLE_BLEAVAIL, ui32Feature);
   115e8:	f3c5 0780 	ubfx	r7, r5, #2, #1
                _FLD2VAL(MCUCTRL_FEATUREENABLE_BURSTAVAIL, ui32Feature);
   115ec:	7008      	strb	r0, [r1, #0]
                _FLD2VAL(MCUCTRL_FEATUREENABLE_BLEAVAIL, ui32Feature);
   115ee:	704f      	strb	r7, [r1, #1]
            ui32Feature = MCUCTRL->BOOTLOADER;
   115f0:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
                _FLD2VAL(MCUCTRL_BOOTLOADER_SECBOOTFEATURE, ui32Feature);
   115f4:	f3c3 6681 	ubfx	r6, r3, #26, #2
            psFeature->ui8SecBootFeature =
   115f8:	710e      	strb	r6, [r1, #4]
            ui32Feature = MCUCTRL->SKU;
   115fa:	6964      	ldr	r4, [r4, #20]
                _FLD2VAL(MCUCTRL_SKU_ALLOWBLE, ui32Feature);
   115fc:	f3c4 0240 	ubfx	r2, r4, #1, #1
                _FLD2VAL(MCUCTRL_SKU_ALLOWBURST, ui32Feature);
   11600:	f004 0501 	and.w	r5, r4, #1
   11604:	70cd      	strb	r5, [r1, #3]
    return AM_HAL_STATUS_SUCCESS;
   11606:	2000      	movs	r0, #0
                _FLD2VAL(MCUCTRL_SKU_ALLOWBLE, ui32Feature);
   11608:	708a      	strb	r2, [r1, #2]
} // am_hal_mcuctrl_info_get()
   1160a:	bcf0      	pop	{r4, r5, r6, r7}
   1160c:	4770      	bx	lr
    psDevice->ui32ChipPN = MCUCTRL->CHIPPN;
   1160e:	4a28      	ldr	r2, [pc, #160]	; (116b0 <am_hal_mcuctrl_info_get+0x120>)
        g_am_hal_mcuctrl_flash_size[
   11610:	4c28      	ldr	r4, [pc, #160]	; (116b4 <am_hal_mcuctrl_info_get+0x124>)
    psDevice->ui32ChipPN = MCUCTRL->CHIPPN;
   11612:	6813      	ldr	r3, [r2, #0]
   11614:	600b      	str	r3, [r1, #0]
    psDevice->ui32ChipID0 = MCUCTRL->CHIPID0;
   11616:	6850      	ldr	r0, [r2, #4]
   11618:	6048      	str	r0, [r1, #4]
    psDevice->ui32ChipID1 = MCUCTRL->CHIPID1;
   1161a:	6897      	ldr	r7, [r2, #8]
   1161c:	608f      	str	r7, [r1, #8]
    psDevice->ui32ChipRev = MCUCTRL->CHIPREV;
   1161e:	68d6      	ldr	r6, [r2, #12]
   11620:	60ce      	str	r6, [r1, #12]
    psDevice->ui32VendorID = MCUCTRL->VENDORID;
   11622:	6915      	ldr	r5, [r2, #16]
        g_am_hal_mcuctrl_sram_size[
   11624:	4824      	ldr	r0, [pc, #144]	; (116b8 <am_hal_mcuctrl_info_get+0x128>)
    psDevice->ui32VendorID = MCUCTRL->VENDORID;
   11626:	610d      	str	r5, [r1, #16]
            (psDevice->ui32ChipPN & MCUCTRL_CHIPPN_PARTNUM_FLASHSIZE_M) >>
   11628:	f3c3 5c03 	ubfx	ip, r3, #20, #4
            (psDevice->ui32ChipPN & MCUCTRL_CHIPPN_PARTNUM_SRAMSIZE_M) >>
   1162c:	f3c3 4703 	ubfx	r7, r3, #16, #4
    psDevice->ui32SKU = MCUCTRL->SKU;
   11630:	6956      	ldr	r6, [r2, #20]
    psDevice->ui32SRAMSize =
   11632:	f850 5027 	ldr.w	r5, [r0, r7, lsl #2]
    psDevice->ui32JedecPN  = JEDEC->PID0_b.PNL8 << 0;
   11636:	4a21      	ldr	r2, [pc, #132]	; (116bc <am_hal_mcuctrl_info_get+0x12c>)
    psDevice->ui32FlashSize =
   11638:	f854 402c 	ldr.w	r4, [r4, ip, lsl #2]
    psDevice->ui32SKU = MCUCTRL->SKU;
   1163c:	614e      	str	r6, [r1, #20]
    psDevice->ui32Qualified = (psDevice->ui32ChipPN >> MCUCTRL_CHIPPN_PARTNUM_QUAL_S) & 0x1;
   1163e:	f003 0301 	and.w	r3, r3, #1
    psDevice->ui32FlashSize =
   11642:	61cc      	str	r4, [r1, #28]
    psDevice->ui32SRAMSize =
   11644:	620d      	str	r5, [r1, #32]
    psDevice->ui32Qualified = (psDevice->ui32ChipPN >> MCUCTRL_CHIPPN_PARTNUM_QUAL_S) & 0x1;
   11646:	618b      	str	r3, [r1, #24]
    psDevice->ui32JedecPN  = JEDEC->PID0_b.PNL8 << 0;
   11648:	f8d2 70e0 	ldr.w	r7, [r2, #224]	; 0xe0
    psDevice->ui32JedecPN |= JEDEC->PID1_b.PNH4 << 8;
   1164c:	f8d2 00e4 	ldr.w	r0, [r2, #228]	; 0xe4
    psDevice->ui32JedecPN  = JEDEC->PID0_b.PNL8 << 0;
   11650:	b2fe      	uxtb	r6, r7
    psDevice->ui32JedecPN |= JEDEC->PID1_b.PNH4 << 8;
   11652:	f000 040f 	and.w	r4, r0, #15
   11656:	ea46 2504 	orr.w	r5, r6, r4, lsl #8
   1165a:	624d      	str	r5, [r1, #36]	; 0x24
    psDevice->ui32JedecJEPID  = JEDEC->PID1_b.JEPIDL << 0;
   1165c:	f8d2 30e4 	ldr.w	r3, [r2, #228]	; 0xe4
    psDevice->ui32JedecJEPID |= JEDEC->PID2_b.JEPIDH << 4;
   11660:	f8d2 70e8 	ldr.w	r7, [r2, #232]	; 0xe8
    psDevice->ui32JedecJEPID  = JEDEC->PID1_b.JEPIDL << 0;
   11664:	f3c3 1603 	ubfx	r6, r3, #4, #4
    psDevice->ui32JedecJEPID |= JEDEC->PID2_b.JEPIDH << 4;
   11668:	f007 0c0f 	and.w	ip, r7, #15
   1166c:	ea46 100c 	orr.w	r0, r6, ip, lsl #4
   11670:	6288      	str	r0, [r1, #40]	; 0x28
    psDevice->ui32JedecCHIPREV  = JEDEC->PID2_b.CHIPREVH4 << 4;
   11672:	f8d2 40e8 	ldr.w	r4, [r2, #232]	; 0xe8
    psDevice->ui32JedecCHIPREV |= JEDEC->PID3_b.CHIPREVL4 << 0;
   11676:	f8d2 50ec 	ldr.w	r5, [r2, #236]	; 0xec
    psDevice->ui32JedecCHIPREV  = JEDEC->PID2_b.CHIPREVH4 << 4;
   1167a:	f004 03f0 	and.w	r3, r4, #240	; 0xf0
    psDevice->ui32JedecCHIPREV |= JEDEC->PID3_b.CHIPREVL4 << 0;
   1167e:	f3c5 1703 	ubfx	r7, r5, #4, #4
   11682:	433b      	orrs	r3, r7
   11684:	62cb      	str	r3, [r1, #44]	; 0x2c
    psDevice->ui32JedecCID  = JEDEC->CID3_b.CID << 24;
   11686:	f8d2 60fc 	ldr.w	r6, [r2, #252]	; 0xfc
    psDevice->ui32JedecCID |= JEDEC->CID2_b.CID << 16;
   1168a:	f8d2 40f8 	ldr.w	r4, [r2, #248]	; 0xf8
    psDevice->ui32JedecCID |= JEDEC->CID1_b.CID <<  8;
   1168e:	f8d2 00f4 	ldr.w	r0, [r2, #244]	; 0xf4
    psDevice->ui32JedecCID |= JEDEC->CID0_b.CID <<  0;
   11692:	f8d2 20f0 	ldr.w	r2, [r2, #240]	; 0xf0
    psDevice->ui32JedecCID |= JEDEC->CID2_b.CID << 16;
   11696:	b2e5      	uxtb	r5, r4
   11698:	042b      	lsls	r3, r5, #16
   1169a:	ea43 6706 	orr.w	r7, r3, r6, lsl #24
    psDevice->ui32JedecCID |= JEDEC->CID0_b.CID <<  0;
   1169e:	b2d6      	uxtb	r6, r2
   116a0:	4337      	orrs	r7, r6
    psDevice->ui32JedecCID |= JEDEC->CID1_b.CID <<  8;
   116a2:	b2c4      	uxtb	r4, r0
    psDevice->ui32JedecCID |= JEDEC->CID0_b.CID <<  0;
   116a4:	ea47 2004 	orr.w	r0, r7, r4, lsl #8
   116a8:	6308      	str	r0, [r1, #48]	; 0x30
    return AM_HAL_STATUS_SUCCESS;
   116aa:	2000      	movs	r0, #0
} // am_hal_mcuctrl_info_get()
   116ac:	bcf0      	pop	{r4, r5, r6, r7}
   116ae:	4770      	bx	lr
   116b0:	40020000 	.word	0x40020000
   116b4:	00013134 	.word	0x00013134
   116b8:	00013174 	.word	0x00013174
   116bc:	f0000f00 	.word	0xf0000f00

000116c0 <am_hal_pwrctrl_periph_enable>:
//  Enable power for a peripheral.
//
// ****************************************************************************
uint32_t
am_hal_pwrctrl_periph_enable(am_hal_pwrctrl_periph_e ePeripheral)
{
   116c0:	b570      	push	{r4, r5, r6, lr}
   116c2:	b082      	sub	sp, #8
   116c4:	4604      	mov	r4, r0
// #### INTERNAL END ####

    //
    // Enable power control for the given device.
    //
    AM_CRITICAL_BEGIN
   116c6:	f7ff ff07 	bl	114d8 <am_hal_interrupt_master_disable>
    PWRCTRL->DEVPWREN |= am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphEnable;
   116ca:	eb04 0144 	add.w	r1, r4, r4, lsl #1
   116ce:	008c      	lsls	r4, r1, #2
   116d0:	4e0e      	ldr	r6, [pc, #56]	; (1170c <am_hal_pwrctrl_periph_enable+0x4c>)
   116d2:	4d0f      	ldr	r5, [pc, #60]	; (11710 <am_hal_pwrctrl_periph_enable+0x50>)
    AM_CRITICAL_BEGIN
   116d4:	9001      	str	r0, [sp, #4]
    PWRCTRL->DEVPWREN |= am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphEnable;
   116d6:	592a      	ldr	r2, [r5, r4]
   116d8:	68b3      	ldr	r3, [r6, #8]
   116da:	4313      	orrs	r3, r2
   116dc:	60b3      	str	r3, [r6, #8]
    AM_CRITICAL_END
   116de:	9801      	ldr	r0, [sp, #4]

    for (uint32_t wait_usecs = 0; wait_usecs < AM_HAL_PWRCTRL_MAX_WFE; wait_usecs += 10)
    {
        am_hal_flash_delay(FLASH_CYCLES_US(10));

        if ( (PWRCTRL->DEVPWRSTATUS & am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphStatus) > 0)
   116e0:	442c      	add	r4, r5
    AM_CRITICAL_END
   116e2:	f7ff fefd 	bl	114e0 <am_hal_interrupt_master_set>
        am_hal_flash_delay(FLASH_CYCLES_US(10));
   116e6:	2077      	movs	r0, #119	; 0x77
   116e8:	f7ff fc7a 	bl	10fe0 <am_hal_flash_delay>
        if ( (PWRCTRL->DEVPWRSTATUS & am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphStatus) > 0)
   116ec:	69b0      	ldr	r0, [r6, #24]
   116ee:	6864      	ldr	r4, [r4, #4]
   116f0:	4220      	tst	r0, r4
   116f2:	d103      	bne.n	116fc <am_hal_pwrctrl_periph_enable+0x3c>
        am_hal_flash_delay(FLASH_CYCLES_US(10));
   116f4:	2077      	movs	r0, #119	; 0x77
   116f6:	f7ff fc73 	bl	10fe0 <am_hal_flash_delay>
        if ( (PWRCTRL->DEVPWRSTATUS & am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphStatus) > 0)
   116fa:	69b3      	ldr	r3, [r6, #24]
    }

    //
    // Check the device status.
    //
    if ( (PWRCTRL->DEVPWRSTATUS & am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphStatus) > 0 )
   116fc:	4903      	ldr	r1, [pc, #12]	; (1170c <am_hal_pwrctrl_periph_enable+0x4c>)
   116fe:	698d      	ldr	r5, [r1, #24]
   11700:	4225      	tst	r5, r4
    else
    {
        return AM_HAL_STATUS_FAIL;
    }
#endif // AM_CMSIS_REGS
}
   11702:	bf0c      	ite	eq
   11704:	2001      	moveq	r0, #1
   11706:	2000      	movne	r0, #0
   11708:	b002      	add	sp, #8
   1170a:	bd70      	pop	{r4, r5, r6, pc}
   1170c:	40021000 	.word	0x40021000
   11710:	0001331c 	.word	0x0001331c

00011714 <am_hal_pwrctrl_periph_disable>:
//  Disable power for a peripheral.
//
// ****************************************************************************
uint32_t
am_hal_pwrctrl_periph_disable(am_hal_pwrctrl_periph_e ePeripheral)
{
   11714:	b570      	push	{r4, r5, r6, lr}
   11716:	b082      	sub	sp, #8
   11718:	4604      	mov	r4, r0

    //
    // Disable power domain for the given device.
    //
#if AM_CMSIS_REGS
    AM_CRITICAL_BEGIN
   1171a:	f7ff fedd 	bl	114d8 <am_hal_interrupt_master_disable>
    PWRCTRL->DEVPWREN &= ~am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphEnable;
   1171e:	eb04 0144 	add.w	r1, r4, r4, lsl #1
   11722:	008c      	lsls	r4, r1, #2
   11724:	4e0f      	ldr	r6, [pc, #60]	; (11764 <am_hal_pwrctrl_periph_disable+0x50>)
   11726:	4d10      	ldr	r5, [pc, #64]	; (11768 <am_hal_pwrctrl_periph_disable+0x54>)
    AM_CRITICAL_BEGIN
   11728:	9001      	str	r0, [sp, #4]
    PWRCTRL->DEVPWREN &= ~am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphEnable;
   1172a:	68b3      	ldr	r3, [r6, #8]
   1172c:	592a      	ldr	r2, [r5, r4]
   1172e:	ea23 0002 	bic.w	r0, r3, r2
   11732:	60b0      	str	r0, [r6, #8]
    AM_CRITICAL_END
   11734:	9801      	ldr	r0, [sp, #4]
    for (uint32_t wait_usecs = 0; wait_usecs < AM_HAL_PWRCTRL_MAX_WFE; wait_usecs += 10)
    {
        am_hal_flash_delay(FLASH_CYCLES_US(10));

#if AM_CMSIS_REGS
        if ( (PWRCTRL->DEVPWRSTATUS & am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphStatus) == 0 )
   11736:	442c      	add	r4, r5
    AM_CRITICAL_END
   11738:	f7ff fed2 	bl	114e0 <am_hal_interrupt_master_set>
        am_hal_flash_delay(FLASH_CYCLES_US(10));
   1173c:	2077      	movs	r0, #119	; 0x77
   1173e:	f7ff fc4f 	bl	10fe0 <am_hal_flash_delay>
        if ( (PWRCTRL->DEVPWRSTATUS & am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphStatus) == 0 )
   11742:	69b1      	ldr	r1, [r6, #24]
   11744:	6864      	ldr	r4, [r4, #4]
   11746:	4221      	tst	r1, r4
   11748:	d003      	beq.n	11752 <am_hal_pwrctrl_periph_disable+0x3e>
        am_hal_flash_delay(FLASH_CYCLES_US(10));
   1174a:	2077      	movs	r0, #119	; 0x77
   1174c:	f7ff fc48 	bl	10fe0 <am_hal_flash_delay>
        if ( (PWRCTRL->DEVPWRSTATUS & am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphStatus) == 0 )
   11750:	69b3      	ldr	r3, [r6, #24]

    //
    // Check the device status.
    //
#if AM_CMSIS_REGS
    if ( ( PWRCTRL->DEVPWRSTATUS & am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphStatus) == 0 )
   11752:	4d04      	ldr	r5, [pc, #16]	; (11764 <am_hal_pwrctrl_periph_disable+0x50>)
   11754:	69ae      	ldr	r6, [r5, #24]
   11756:	4226      	tst	r6, r4
#endif // AM_CMSIS_REGS
    else
    {
        return AM_HAL_STATUS_FAIL;
    }
}
   11758:	bf14      	ite	ne
   1175a:	2001      	movne	r0, #1
   1175c:	2000      	moveq	r0, #0
   1175e:	b002      	add	sp, #8
   11760:	bd70      	pop	{r4, r5, r6, pc}
   11762:	bf00      	nop
   11764:	40021000 	.word	0x40021000
   11768:	0001331c 	.word	0x0001331c

0001176c <am_hal_pwrctrl_memory_enable>:
//  Enable a configuration of memory.
//
// ****************************************************************************
uint32_t
am_hal_pwrctrl_memory_enable(am_hal_pwrctrl_mem_e eMemConfig)
{
   1176c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
#if 0
    uint32_t ui32MemEventMask;
#endif
// #### INTERNAL END ####

    ui32MemEnMask     =  am_hal_pwrctrl_memory_control[eMemConfig].ui32MemoryEnable;
   11770:	ea4f 0980 	mov.w	r9, r0, lsl #2
   11774:	eb09 0300 	add.w	r3, r9, r0
   11778:	4f1e      	ldr	r7, [pc, #120]	; (117f4 <am_hal_pwrctrl_memory_enable+0x88>)
{
   1177a:	4604      	mov	r4, r0
    ui32MemEnMask     =  am_hal_pwrctrl_memory_control[eMemConfig].ui32MemoryEnable;
   1177c:	0098      	lsls	r0, r3, #2
   1177e:	183a      	adds	r2, r7, r0
   11780:	583d      	ldr	r5, [r7, r0]
#if 0
    ui32MemEventMask  = am_hal_pwrctrl_memory_control[eMemConfig].ui32MemoryEvent;
#endif
// #### INTERNAL END ####
    ui32MemRegionMask = am_hal_pwrctrl_memory_control[eMemConfig].ui32MemoryMask;
    ui32MemStatusMask = am_hal_pwrctrl_memory_control[eMemConfig].ui32StatusMask;
   11782:	6916      	ldr	r6, [r2, #16]
    //
    // Note that a deliberate disable step using a disable mask is taken here
    // for 2 reasons: 1) To only affect the specified type of memory, and 2)
    // To avoid inadvertently disabling any memory currently being depended on.
    //
    if ( ui32MemDisMask != 0 )
   11784:	43eb      	mvns	r3, r5
   11786:	d126      	bne.n	117d6 <am_hal_pwrctrl_memory_enable+0x6a>
// #### INTERNAL END ####

    //
    // Enable the required memory.
    //
    if ( ui32MemEnMask != 0 )
   11788:	b965      	cbnz	r5, 117a4 <am_hal_pwrctrl_memory_enable+0x38>
   1178a:	444c      	add	r4, r9
   1178c:	eb07 0c84 	add.w	ip, r7, r4, lsl #2
   11790:	f8dc 5004 	ldr.w	r5, [ip, #4]

    //
    // Return status based on whether the power control memory status has reached the desired state.
    //
#if AM_CMSIS_REGS
    if ( ( PWRCTRL->MEMPWRSTATUS & ui32MemStatusMask) ==
   11794:	4918      	ldr	r1, [pc, #96]	; (117f8 <am_hal_pwrctrl_memory_enable+0x8c>)
   11796:	694a      	ldr	r2, [r1, #20]
   11798:	4032      	ands	r2, r6
#endif // AM_CMSIS_REGS
    else
    {
        return AM_HAL_STATUS_FAIL;
    }
}
   1179a:	1b50      	subs	r0, r2, r5
   1179c:	bf18      	it	ne
   1179e:	2001      	movne	r0, #1
   117a0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        PWRCTRL->MEMPWREN |= ui32MemEnMask;
   117a4:	f8df 8050 	ldr.w	r8, [pc, #80]	; 117f8 <am_hal_pwrctrl_memory_enable+0x8c>
   117a8:	f8d8 0010 	ldr.w	r0, [r8, #16]
                  am_hal_pwrctrl_memory_control[eMemConfig].ui32MemoryStatus )
   117ac:	444c      	add	r4, r9
        PWRCTRL->MEMPWREN |= ui32MemEnMask;
   117ae:	4305      	orrs	r5, r0
   117b0:	f8c8 5010 	str.w	r5, [r8, #16]
                  am_hal_pwrctrl_memory_control[eMemConfig].ui32MemoryStatus )
   117b4:	eb07 0484 	add.w	r4, r7, r4, lsl #2
            am_hal_flash_delay(FLASH_CYCLES_US(10));
   117b8:	2077      	movs	r0, #119	; 0x77
   117ba:	f7ff fc11 	bl	10fe0 <am_hal_flash_delay>
            if ( (PWRCTRL->MEMPWRSTATUS & ui32MemStatusMask) ==
   117be:	f8d8 7014 	ldr.w	r7, [r8, #20]
                  am_hal_pwrctrl_memory_control[eMemConfig].ui32MemoryStatus )
   117c2:	6865      	ldr	r5, [r4, #4]
            if ( (PWRCTRL->MEMPWRSTATUS & ui32MemStatusMask) ==
   117c4:	4037      	ands	r7, r6
   117c6:	42af      	cmp	r7, r5
   117c8:	d0e4      	beq.n	11794 <am_hal_pwrctrl_memory_enable+0x28>
            am_hal_flash_delay(FLASH_CYCLES_US(10));
   117ca:	2077      	movs	r0, #119	; 0x77
   117cc:	f7ff fc08 	bl	10fe0 <am_hal_flash_delay>
            if ( (PWRCTRL->MEMPWRSTATUS & ui32MemStatusMask) ==
   117d0:	f8d8 3014 	ldr.w	r3, [r8, #20]
   117d4:	e7de      	b.n	11794 <am_hal_pwrctrl_memory_enable+0x28>
            ~(ui32MemDisMask & ui32MemRegionMask)                                   |
   117d6:	68d0      	ldr	r0, [r2, #12]
        PWRCTRL->MEMPWREN &=
   117d8:	4907      	ldr	r1, [pc, #28]	; (117f8 <am_hal_pwrctrl_memory_enable+0x8c>)
            ~(ui32MemDisMask & ui32MemRegionMask)                                   |
   117da:	4003      	ands	r3, r0
        PWRCTRL->MEMPWREN &=
   117dc:	690a      	ldr	r2, [r1, #16]
            ~(ui32MemDisMask & ui32MemRegionMask)                                   |
   117de:	f242 0801 	movw	r8, #8193	; 0x2001
   117e2:	ea68 0303 	orn	r3, r8, r3
        PWRCTRL->MEMPWREN &=
   117e6:	4013      	ands	r3, r2
   117e8:	610b      	str	r3, [r1, #16]
        am_hal_flash_delay(FLASH_CYCLES_US(1));
   117ea:	2001      	movs	r0, #1
   117ec:	f7ff fbf8 	bl	10fe0 <am_hal_flash_delay>
   117f0:	e7ca      	b.n	11788 <am_hal_pwrctrl_memory_enable+0x1c>
   117f2:	bf00      	nop
   117f4:	000131b4 	.word	0x000131b4
   117f8:	40021000 	.word	0x40021000

000117fc <am_hal_pwrctrl_low_power_init>:
//  Initialize system for low power configuration.
//
// ****************************************************************************
uint32_t
am_hal_pwrctrl_low_power_init(void)
{
   117fc:	b530      	push	{r4, r5, lr}

#if AM_CMSIS_REGS
    //
    // Check if the BLE is already enabled.
    //
    if ( PWRCTRL->DEVPWRSTATUS_b.BLEL == 0)
   117fe:	4c1b      	ldr	r4, [pc, #108]	; (1186c <am_hal_pwrctrl_low_power_init+0x70>)
   11800:	69a3      	ldr	r3, [r4, #24]
   11802:	05db      	lsls	r3, r3, #23
{
   11804:	b083      	sub	sp, #12
    if ( PWRCTRL->DEVPWRSTATUS_b.BLEL == 0)
   11806:	d502      	bpl.n	1180e <am_hal_pwrctrl_low_power_init+0x12>
            AM_BFW(MCUCTRL, BLEBUCK2,  BLEBUCKTONLOWTRIM, 0xF);
        }
    }
#endif // AM_CMSIS_REGS

    return AM_HAL_STATUS_SUCCESS;
   11808:	2000      	movs	r0, #0
}
   1180a:	b003      	add	sp, #12
   1180c:	bd30      	pop	{r4, r5, pc}
        MCUCTRL->FEATUREENABLE = MCUCTRL_FEATUREENABLE_BLEREQ_Msk;
   1180e:	4d18      	ldr	r5, [pc, #96]	; (11870 <am_hal_pwrctrl_low_power_init+0x74>)
        ui32Status = am_hal_flash_delay_status_check(10000,
   11810:	4918      	ldr	r1, [pc, #96]	; (11874 <am_hal_pwrctrl_low_power_init+0x78>)
        MCUCTRL->FEATUREENABLE = MCUCTRL_FEATUREENABLE_BLEREQ_Msk;
   11812:	2001      	movs	r0, #1
        ui32Status = am_hal_flash_delay_status_check(10000,
   11814:	2307      	movs	r3, #7
        MCUCTRL->FEATUREENABLE = MCUCTRL_FEATUREENABLE_BLEREQ_Msk;
   11816:	61a8      	str	r0, [r5, #24]
        ui32Status = am_hal_flash_delay_status_check(10000,
   11818:	461a      	mov	r2, r3
   1181a:	9000      	str	r0, [sp, #0]
   1181c:	f242 7010 	movw	r0, #10000	; 0x2710
   11820:	f7ff fbe2 	bl	10fe8 <am_hal_flash_delay_status_check>
        if (AM_HAL_STATUS_SUCCESS != ui32Status)
   11824:	b110      	cbz	r0, 1182c <am_hal_pwrctrl_low_power_init+0x30>
            return AM_HAL_STATUS_TIMEOUT;
   11826:	2004      	movs	r0, #4
}
   11828:	b003      	add	sp, #12
   1182a:	bd30      	pop	{r4, r5, pc}
        PWRCTRL->SUPPLYSRC |= _VAL2FLD(PWRCTRL_SUPPLYSRC_BLEBUCKEN,
   1182c:	6821      	ldr	r1, [r4, #0]
   1182e:	f041 0201 	orr.w	r2, r1, #1
   11832:	6022      	str	r2, [r4, #0]
        PWRCTRL->MISC |= _VAL2FLD(PWRCTRL_MISC_MEMVRLPBLE,
   11834:	6a63      	ldr	r3, [r4, #36]	; 0x24
   11836:	f043 0140 	orr.w	r1, r3, #64	; 0x40
   1183a:	6261      	str	r1, [r4, #36]	; 0x24
        if ( APOLLO3_A0 )
   1183c:	68ec      	ldr	r4, [r5, #12]
   1183e:	b2e2      	uxtb	r2, r4
   11840:	2a11      	cmp	r2, #17
   11842:	d1e1      	bne.n	11808 <am_hal_pwrctrl_low_power_init+0xc>
            MCUCTRL->SIMOBUCK4_b.SIMOBUCKCLKDIVSEL = 0x0;
   11844:	f8d5 335c 	ldr.w	r3, [r5, #860]	; 0x35c
   11848:	f360 5356 	bfi	r3, r0, #21, #2
   1184c:	f8c5 335c 	str.w	r3, [r5, #860]	; 0x35c
            MCUCTRL->BLEBUCK2_b.BLEBUCKTONHITRIM   = 0xF;
   11850:	f8d5 1368 	ldr.w	r1, [r5, #872]	; 0x368
   11854:	240f      	movs	r4, #15
   11856:	f364 118b 	bfi	r1, r4, #6, #6
   1185a:	f8c5 1368 	str.w	r1, [r5, #872]	; 0x368
            MCUCTRL->BLEBUCK2_b.BLEBUCKTONLOWTRIM  = 0xF;
   1185e:	f8d5 2368 	ldr.w	r2, [r5, #872]	; 0x368
   11862:	f364 0205 	bfi	r2, r4, #0, #6
   11866:	f8c5 2368 	str.w	r2, [r5, #872]	; 0x368
   1186a:	e7ce      	b.n	1180a <am_hal_pwrctrl_low_power_init+0xe>
   1186c:	40021000 	.word	0x40021000
   11870:	40020000 	.word	0x40020000
   11874:	40020018 	.word	0x40020018

00011878 <am_hal_rtc_osc_select>:
#if AM_CMSIS_REGS
#if 1//USE_CLKGEN
    if ( ui32OSC == AM_HAL_RTC_OSC_LFRC )
    {
        // Set bit to 1 for LFRC
        CLKGEN->OCTRL |= CLKGEN_OCTRL_OSEL_Msk;
   11878:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
    if ( ui32OSC == AM_HAL_RTC_OSC_LFRC )
   1187c:	2801      	cmp	r0, #1
        CLKGEN->OCTRL |= CLKGEN_OCTRL_OSEL_Msk;
   1187e:	68d3      	ldr	r3, [r2, #12]
   11880:	bf0c      	ite	eq
   11882:	f043 0380 	orreq.w	r3, r3, #128	; 0x80
    }
    else
    {
        // Clear bit to 0 for XTAL
        CLKGEN->OCTRL &= ~CLKGEN_OCTRL_OSEL_Msk;
   11886:	f023 0380 	bicne.w	r3, r3, #128	; 0x80
   1188a:	60d3      	str	r3, [r2, #12]
   1188c:	4770      	bx	lr
   1188e:	bf00      	nop

00011890 <am_hal_rtc_osc_disable>:
    //
#if AM_CMSIS_REGS
#if USE_CLKGEN
    CLKGEN->RTCCTL_b.RSTOP = 1;
#else
    RTC->RTCCTL_b.RSTOP = 1;
   11890:	4a03      	ldr	r2, [pc, #12]	; (118a0 <am_hal_rtc_osc_disable+0x10>)
   11892:	f892 3050 	ldrb.w	r3, [r2, #80]	; 0x50
   11896:	f043 0010 	orr.w	r0, r3, #16
   1189a:	f882 0050 	strb.w	r0, [r2, #80]	; 0x50
   1189e:	4770      	bx	lr
   118a0:	40004200 	.word	0x40004200

000118a4 <am_hal_sysctrl_fpu_enable>:
    //
    // Enable access to the FPU in both privileged and user modes.
    // NOTE: Write 0s to all reserved fields in this register.
    //
#if AM_CMSIS_REGS
    SCB->CPACR = _VAL2FLD(SCB_CPACR_CP11, 0x3) |
   118a4:	4b02      	ldr	r3, [pc, #8]	; (118b0 <am_hal_sysctrl_fpu_enable+0xc>)
   118a6:	f44f 0270 	mov.w	r2, #15728640	; 0xf00000
   118aa:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
   118ae:	4770      	bx	lr
   118b0:	e000ed00 	.word	0xe000ed00

000118b4 <am_hal_sysctrl_fpu_stacking_enable>:
    {
        //
        // Enable automatic saving of FPU registers on exception entry, using lazy
        // context saving.
        //
        FPU->FPCCR |= _VAL2FLD(FPU_FPCCR_ASPEN, 1) |
   118b4:	4a05      	ldr	r2, [pc, #20]	; (118cc <am_hal_sysctrl_fpu_stacking_enable+0x18>)
   118b6:	6853      	ldr	r3, [r2, #4]
    if ( bLazy )
   118b8:	b918      	cbnz	r0, 118c2 <am_hal_sysctrl_fpu_stacking_enable+0xe>
    else
    {
        //
        // Enable automatic saving of FPU registers on exception entry.
        //
        FPU->FPCCR |= _VAL2FLD(FPU_FPCCR_ASPEN, 1);
   118ba:	f043 4000 	orr.w	r0, r3, #2147483648	; 0x80000000
   118be:	6050      	str	r0, [r2, #4]
   118c0:	4770      	bx	lr
        FPU->FPCCR |= _VAL2FLD(FPU_FPCCR_ASPEN, 1) |
   118c2:	f043 4140 	orr.w	r1, r3, #3221225472	; 0xc0000000
   118c6:	6051      	str	r1, [r2, #4]
   118c8:	4770      	bx	lr
   118ca:	bf00      	nop
   118cc:	e000ef30 	.word	0xe000ef30

000118d0 <am_hal_systick_start>:
{
    //
    // Start the systick timer.
    //
#if AM_CMSIS_REGS
    SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk;
   118d0:	4a02      	ldr	r2, [pc, #8]	; (118dc <am_hal_systick_start+0xc>)
   118d2:	6813      	ldr	r3, [r2, #0]
   118d4:	f043 0001 	orr.w	r0, r3, #1
   118d8:	6010      	str	r0, [r2, #0]
   118da:	4770      	bx	lr
   118dc:	e000e010 	.word	0xe000e010

000118e0 <am_hal_systick_stop>:
{
    //
    // Stop the systick timer.
    //
#if AM_CMSIS_REGS
    SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
   118e0:	4a02      	ldr	r2, [pc, #8]	; (118ec <am_hal_systick_stop+0xc>)
   118e2:	6813      	ldr	r3, [r2, #0]
   118e4:	f023 0001 	bic.w	r0, r3, #1
   118e8:	6010      	str	r0, [r2, #0]
   118ea:	4770      	bx	lr
   118ec:	e000e010 	.word	0xe000e010

000118f0 <am_hal_systick_int_enable>:
{
    //
    // Enable the systick timer interrupt.
    //
#if AM_CMSIS_REGS
    SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk;
   118f0:	4a02      	ldr	r2, [pc, #8]	; (118fc <am_hal_systick_int_enable+0xc>)
   118f2:	6813      	ldr	r3, [r2, #0]
   118f4:	f043 0002 	orr.w	r0, r3, #2
   118f8:	6010      	str	r0, [r2, #0]
   118fa:	4770      	bx	lr
   118fc:	e000e010 	.word	0xe000e010

00011900 <am_hal_systick_load>:
    //      3. Program CSR
    // Write the given value to the reload register.
    // Write the Current Value Register to clear it to 0.
    //
#if AM_CMSIS_REGS
    SysTick->LOAD = ui32LoadVal;
   11900:	4b02      	ldr	r3, [pc, #8]	; (1190c <am_hal_systick_load+0xc>)
    SysTick->VAL = 0;
   11902:	2200      	movs	r2, #0
    SysTick->LOAD = ui32LoadVal;
   11904:	6058      	str	r0, [r3, #4]
    SysTick->VAL = 0;
   11906:	609a      	str	r2, [r3, #8]
   11908:	4770      	bx	lr
   1190a:	bf00      	nop
   1190c:	e000e010 	.word	0xe000e010

00011910 <am_hal_systick_count>:
{
    //
    // Return the current systick timer count value.
    //
#if AM_CMSIS_REGS
    return SysTick->VAL;
   11910:	4b01      	ldr	r3, [pc, #4]	; (11918 <am_hal_systick_count+0x8>)
   11912:	6898      	ldr	r0, [r3, #8]
#else // AM_CMSIS_REGS
    return AM_REG(SYSTICK, SYSTCVR);
#endif // AM_CMSIS_REGS
}
   11914:	4770      	bx	lr
   11916:	bf00      	nop
   11918:	e000e010 	.word	0xe000e010

0001191c <am_hal_uart_initialize>:
am_hal_uart_initialize(uint32_t ui32Module, void **ppHandle)
{
    //
    // Check that the request module is in range.
    //
    if (ui32Module >= AM_REG_UART_NUM_MODULES )
   1191c:	2801      	cmp	r0, #1
   1191e:	d901      	bls.n	11924 <am_hal_uart_initialize+0x8>
    {
        return AM_HAL_STATUS_OUT_OF_RANGE;
   11920:	2005      	movs	r0, #5
   11922:	4770      	bx	lr
    }

    //
    // Check for valid arguements.
    //
    if (!ppHandle)
   11924:	b169      	cbz	r1, 11942 <am_hal_uart_initialize+0x26>
{
   11926:	b5f0      	push	{r4, r5, r6, r7, lr}
    }

    //
    // Check if the handle is unallocated.
    //
    if (g_am_hal_uart_states[ui32Module].prefix.s.bInit)
   11928:	2264      	movs	r2, #100	; 0x64
   1192a:	4e0e      	ldr	r6, [pc, #56]	; (11964 <am_hal_uart_initialize+0x48>)
   1192c:	fb02 f200 	mul.w	r2, r2, r0
   11930:	18b4      	adds	r4, r6, r2
   11932:	4603      	mov	r3, r0
   11934:	78e0      	ldrb	r0, [r4, #3]
   11936:	f3c0 0700 	ubfx	r7, r0, #0, #1
   1193a:	b2fd      	uxtb	r5, r7
   1193c:	b11d      	cbz	r5, 11946 <am_hal_uart_initialize+0x2a>
    {
        return AM_HAL_STATUS_INVALID_OPERATION;
   1193e:	2007      	movs	r0, #7

    //
    // Return the status.
    //
    return AM_HAL_STATUS_SUCCESS;
} // am_hal_uart_initialize()
   11940:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return AM_HAL_STATUS_INVALID_ARG;
   11942:	2006      	movs	r0, #6
   11944:	4770      	bx	lr
    g_am_hal_uart_states[ui32Module].prefix.s.bInit = true;
   11946:	f040 0001 	orr.w	r0, r0, #1
   1194a:	70e0      	strb	r0, [r4, #3]
    g_am_hal_uart_states[ui32Module].prefix.s.magic = AM_HAL_MAGIC_UART;
   1194c:	58b0      	ldr	r0, [r6, r2]
   1194e:	f8df e018 	ldr.w	lr, [pc, #24]	; 11968 <am_hal_uart_initialize+0x4c>
   11952:	f36e 0017 	bfi	r0, lr, #0, #24
   11956:	50b0      	str	r0, [r6, r2]
    g_am_hal_uart_states[ui32Module].ui32Module = ui32Module;
   11958:	6263      	str	r3, [r4, #36]	; 0x24
    g_am_hal_uart_states[ui32Module].sRegState.bValid = false;
   1195a:	7127      	strb	r7, [r4, #4]
    g_am_hal_uart_states[ui32Module].ui32BaudRate = 0;
   1195c:	6625      	str	r5, [r4, #96]	; 0x60
    return AM_HAL_STATUS_SUCCESS;
   1195e:	4628      	mov	r0, r5
    *ppHandle = (void *)&g_am_hal_uart_states[ui32Module];
   11960:	600c      	str	r4, [r1, #0]
    return AM_HAL_STATUS_SUCCESS;
   11962:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11964:	10001554 	.word	0x10001554
   11968:	00ea9e06 	.word	0x00ea9e06

0001196c <am_hal_uart_deinitialize>:
    am_hal_uart_state_t *pState = (am_hal_uart_state_t *)pHandle;

    //
    // Check the handle.
    //
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   1196c:	b128      	cbz	r0, 1197a <am_hal_uart_deinitialize+0xe>
   1196e:	6803      	ldr	r3, [r0, #0]
   11970:	4a07      	ldr	r2, [pc, #28]	; (11990 <am_hal_uart_deinitialize+0x24>)
   11972:	f023 417e 	bic.w	r1, r3, #4261412864	; 0xfe000000
   11976:	4291      	cmp	r1, r2
   11978:	d001      	beq.n	1197e <am_hal_uart_deinitialize+0x12>
    {
        return AM_HAL_STATUS_INVALID_HANDLE;
   1197a:	2002      	movs	r0, #2

    //
    // Return the status.
    //
    return AM_HAL_STATUS_SUCCESS;
} // am_hal_uart_deinitialize()
   1197c:	4770      	bx	lr
    pState->prefix.s.bInit = false;
   1197e:	78c2      	ldrb	r2, [r0, #3]
    pState->ui32Module = 0;
   11980:	2300      	movs	r3, #0
    pState->prefix.s.bInit = false;
   11982:	f36f 0200 	bfc	r2, #0, #1
   11986:	70c2      	strb	r2, [r0, #3]
    pState->ui32Module = 0;
   11988:	6243      	str	r3, [r0, #36]	; 0x24
    pState->sRegState.bValid = false;
   1198a:	7103      	strb	r3, [r0, #4]
    return AM_HAL_STATUS_SUCCESS;
   1198c:	4618      	mov	r0, r3
   1198e:	4770      	bx	lr
   11990:	01ea9e06 	.word	0x01ea9e06

00011994 <am_hal_uart_power_control>:
//*****************************************************************************
uint32_t
am_hal_uart_power_control(void *pHandle,
                          am_hal_sysctrl_power_state_e ePowerState,
                          bool bRetainState)
{
   11994:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
                                                 ui32Module));

    //
    // Check to make sure this is a valid handle.
    //
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11998:	6804      	ldr	r4, [r0, #0]
   1199a:	4b36      	ldr	r3, [pc, #216]	; (11a74 <am_hal_uart_power_control+0xe0>)
   1199c:	f024 447e 	bic.w	r4, r4, #4261412864	; 0xfe000000
   119a0:	429c      	cmp	r4, r3
{
   119a2:	b084      	sub	sp, #16
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   119a4:	d003      	beq.n	119ae <am_hal_uart_power_control+0x1a>
    {
        return AM_HAL_STATUS_INVALID_HANDLE;
   119a6:	2002      	movs	r0, #2

    //
    // Return the status.
    //
    return AM_HAL_STATUS_SUCCESS;
} // am_hal_uart_power_control()
   119a8:	b004      	add	sp, #16
   119aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    uint32_t ui32Module = pState->ui32Module;
   119ae:	6a47      	ldr	r7, [r0, #36]	; 0x24
   119b0:	4605      	mov	r5, r0
    am_hal_pwrctrl_periph_e eUARTPowerModule = ((am_hal_pwrctrl_periph_e)
   119b2:	f107 0008 	add.w	r0, r7, #8
   119b6:	460e      	mov	r6, r1
   119b8:	fa5f f880 	uxtb.w	r8, r0
    switch (ePowerState)
   119bc:	b181      	cbz	r1, 119e0 <am_hal_uart_power_control+0x4c>
   119be:	2902      	cmp	r1, #2
   119c0:	d80c      	bhi.n	119dc <am_hal_uart_power_control+0x48>
            if (bRetainState)
   119c2:	b992      	cbnz	r2, 119ea <am_hal_uart_power_control+0x56>
    {
        return AM_HAL_STATUS_INVALID_HANDLE;
    }

#if AM_CMSIS_REGS
    UARTn(ui32Module)->IEC = ui32IntMask;
   119c4:	f507 2480 	add.w	r4, r7, #262144	; 0x40000
   119c8:	341c      	adds	r4, #28
   119ca:	0325      	lsls	r5, r4, #12
   119cc:	f04f 31ff 	mov.w	r1, #4294967295
   119d0:	6469      	str	r1, [r5, #68]	; 0x44
            am_hal_pwrctrl_periph_disable(eUARTPowerModule);
   119d2:	4640      	mov	r0, r8
   119d4:	f7ff fe9e 	bl	11714 <am_hal_pwrctrl_periph_disable>
    return AM_HAL_STATUS_SUCCESS;
   119d8:	2000      	movs	r0, #0
            break;
   119da:	e7e5      	b.n	119a8 <am_hal_uart_power_control+0x14>
            return AM_HAL_STATUS_INVALID_ARG;
   119dc:	2006      	movs	r0, #6
   119de:	e7e3      	b.n	119a8 <am_hal_uart_power_control+0x14>
            if (bRetainState && !pState->sRegState.bValid)
   119e0:	b322      	cbz	r2, 11a2c <am_hal_uart_power_control+0x98>
   119e2:	792a      	ldrb	r2, [r5, #4]
   119e4:	bb42      	cbnz	r2, 11a38 <am_hal_uart_power_control+0xa4>
                return AM_HAL_STATUS_INVALID_OPERATION;
   119e6:	2007      	movs	r0, #7
   119e8:	e7de      	b.n	119a8 <am_hal_uart_power_control+0x14>
                AM_CRITICAL_BEGIN
   119ea:	f7ff fd75 	bl	114d8 <am_hal_interrupt_master_disable>
                pState->sRegState.regILPR = UARTn(ui32Module)->ILPR;
   119ee:	f507 2180 	add.w	r1, r7, #262144	; 0x40000
   119f2:	311c      	adds	r1, #28
   119f4:	030f      	lsls	r7, r1, #12
                AM_CRITICAL_BEGIN
   119f6:	9003      	str	r0, [sp, #12]
                pState->sRegState.regILPR = UARTn(ui32Module)->ILPR;
   119f8:	6a3a      	ldr	r2, [r7, #32]
   119fa:	60aa      	str	r2, [r5, #8]
                pState->sRegState.regIBRD = UARTn(ui32Module)->IBRD;
   119fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   119fe:	60eb      	str	r3, [r5, #12]
                pState->sRegState.regFBRD = UARTn(ui32Module)->FBRD;
   11a00:	6abe      	ldr	r6, [r7, #40]	; 0x28
   11a02:	612e      	str	r6, [r5, #16]
                pState->sRegState.regLCRH = UARTn(ui32Module)->LCRH;
   11a04:	6af8      	ldr	r0, [r7, #44]	; 0x2c
   11a06:	6168      	str	r0, [r5, #20]
                pState->sRegState.regCR   = UARTn(ui32Module)->CR;
   11a08:	6b39      	ldr	r1, [r7, #48]	; 0x30
   11a0a:	61a9      	str	r1, [r5, #24]
                pState->sRegState.regIFLS = UARTn(ui32Module)->IFLS;
   11a0c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   11a0e:	61ea      	str	r2, [r5, #28]
                pState->sRegState.regIER  = UARTn(ui32Module)->IER;
   11a10:	6bbf      	ldr	r7, [r7, #56]	; 0x38
   11a12:	622f      	str	r7, [r5, #32]
                pState->sRegState.bValid = true;
   11a14:	2301      	movs	r3, #1
                AM_CRITICAL_END
   11a16:	9803      	ldr	r0, [sp, #12]
                pState->sRegState.bValid = true;
   11a18:	712b      	strb	r3, [r5, #4]
                AM_CRITICAL_END
   11a1a:	f7ff fd61 	bl	114e0 <am_hal_interrupt_master_set>
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11a1e:	682e      	ldr	r6, [r5, #0]
   11a20:	f026 407e 	bic.w	r0, r6, #4261412864	; 0xfe000000
   11a24:	42a0      	cmp	r0, r4
   11a26:	d1d4      	bne.n	119d2 <am_hal_uart_power_control+0x3e>
    uint32_t ui32Module = pState->ui32Module;
   11a28:	6a6f      	ldr	r7, [r5, #36]	; 0x24
   11a2a:	e7cb      	b.n	119c4 <am_hal_uart_power_control+0x30>
            am_hal_pwrctrl_periph_enable(eUARTPowerModule);
   11a2c:	4640      	mov	r0, r8
   11a2e:	9201      	str	r2, [sp, #4]
   11a30:	f7ff fe46 	bl	116c0 <am_hal_pwrctrl_periph_enable>
    return AM_HAL_STATUS_SUCCESS;
   11a34:	9801      	ldr	r0, [sp, #4]
   11a36:	e7b7      	b.n	119a8 <am_hal_uart_power_control+0x14>
            am_hal_pwrctrl_periph_enable(eUARTPowerModule);
   11a38:	4640      	mov	r0, r8
   11a3a:	f7ff fe41 	bl	116c0 <am_hal_pwrctrl_periph_enable>
                AM_CRITICAL_BEGIN
   11a3e:	f7ff fd4b 	bl	114d8 <am_hal_interrupt_master_disable>
                UARTn(ui32Module)->ILPR = pState->sRegState.regILPR;
   11a42:	f507 2380 	add.w	r3, r7, #262144	; 0x40000
   11a46:	331c      	adds	r3, #28
   11a48:	031f      	lsls	r7, r3, #12
   11a4a:	68ac      	ldr	r4, [r5, #8]
                AM_CRITICAL_BEGIN
   11a4c:	9002      	str	r0, [sp, #8]
                UARTn(ui32Module)->ILPR = pState->sRegState.regILPR;
   11a4e:	623c      	str	r4, [r7, #32]
                UARTn(ui32Module)->IBRD = pState->sRegState.regIBRD;
   11a50:	68e9      	ldr	r1, [r5, #12]
   11a52:	6279      	str	r1, [r7, #36]	; 0x24
                UARTn(ui32Module)->FBRD = pState->sRegState.regFBRD;
   11a54:	6928      	ldr	r0, [r5, #16]
   11a56:	62b8      	str	r0, [r7, #40]	; 0x28
                UARTn(ui32Module)->LCRH = pState->sRegState.regLCRH;
   11a58:	696a      	ldr	r2, [r5, #20]
   11a5a:	62fa      	str	r2, [r7, #44]	; 0x2c
                UARTn(ui32Module)->CR   = pState->sRegState.regCR;
   11a5c:	69ab      	ldr	r3, [r5, #24]
   11a5e:	633b      	str	r3, [r7, #48]	; 0x30
                UARTn(ui32Module)->IFLS = pState->sRegState.regIFLS;
   11a60:	69ec      	ldr	r4, [r5, #28]
   11a62:	637c      	str	r4, [r7, #52]	; 0x34
                UARTn(ui32Module)->IER  = pState->sRegState.regIER;
   11a64:	6a29      	ldr	r1, [r5, #32]
   11a66:	63b9      	str	r1, [r7, #56]	; 0x38
                AM_CRITICAL_END
   11a68:	9802      	ldr	r0, [sp, #8]
                pState->sRegState.bValid = false;
   11a6a:	712e      	strb	r6, [r5, #4]
                AM_CRITICAL_END
   11a6c:	f7ff fd38 	bl	114e0 <am_hal_interrupt_master_set>
    return AM_HAL_STATUS_SUCCESS;
   11a70:	4630      	mov	r0, r6
   11a72:	e799      	b.n	119a8 <am_hal_uart_power_control+0x14>
   11a74:	01ea9e06 	.word	0x01ea9e06

00011a78 <am_hal_uart_configure>:
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11a78:	6803      	ldr	r3, [r0, #0]
   11a7a:	4a69      	ldr	r2, [pc, #420]	; (11c20 <am_hal_uart_configure+0x1a8>)
   11a7c:	f023 4c7e 	bic.w	ip, r3, #4261412864	; 0xfe000000
   11a80:	4594      	cmp	ip, r2
   11a82:	d001      	beq.n	11a88 <am_hal_uart_configure+0x10>
        return AM_HAL_STATUS_INVALID_HANDLE;
   11a84:	2002      	movs	r0, #2
   11a86:	4770      	bx	lr
{
   11a88:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint32_t ui32Module = pState->ui32Module;
   11a8c:	6a46      	ldr	r6, [r0, #36]	; 0x24
{
   11a8e:	b084      	sub	sp, #16
   11a90:	460d      	mov	r5, r1
   11a92:	4604      	mov	r4, r0
    AM_CRITICAL_BEGIN
   11a94:	f7ff fd20 	bl	114d8 <am_hal_interrupt_master_disable>
    UARTn(ui32Module)->CR |= UART0_CR_CLKEN_Msk;
   11a98:	f506 2180 	add.w	r1, r6, #262144	; 0x40000
   11a9c:	311c      	adds	r1, #28
   11a9e:	030f      	lsls	r7, r1, #12
    AM_CRITICAL_BEGIN
   11aa0:	9001      	str	r0, [sp, #4]
    UARTn(ui32Module)->CR |= UART0_CR_CLKEN_Msk;
   11aa2:	6b38      	ldr	r0, [r7, #48]	; 0x30
   11aa4:	f040 0208 	orr.w	r2, r0, #8
   11aa8:	633a      	str	r2, [r7, #48]	; 0x30
    UARTn(ui32Module)->CR |= _VAL2FLD(UART0_CR_CLKSEL, UART0_CR_CLKSEL_24MHZ);
   11aaa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   11aac:	f043 0610 	orr.w	r6, r3, #16
   11ab0:	633e      	str	r6, [r7, #48]	; 0x30
    AM_CRITICAL_END
   11ab2:	9801      	ldr	r0, [sp, #4]
   11ab4:	f7ff fd14 	bl	114e0 <am_hal_interrupt_master_set>
    AM_CRITICAL_BEGIN
   11ab8:	f7ff fd0e 	bl	114d8 <am_hal_interrupt_master_disable>
   11abc:	9002      	str	r0, [sp, #8]
    UARTn(ui32Module)->CR &=
   11abe:	6b39      	ldr	r1, [r7, #48]	; 0x30
   11ac0:	f421 7040 	bic.w	r0, r1, #768	; 0x300
   11ac4:	f020 0201 	bic.w	r2, r0, #1
   11ac8:	633a      	str	r2, [r7, #48]	; 0x30
    AM_CRITICAL_END
   11aca:	9802      	ldr	r0, [sp, #8]
   11acc:	f7ff fd08 	bl	114e0 <am_hal_interrupt_master_set>
    switch( UARTn(ui32Module)->CR_b.CLKSEL )
   11ad0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   11ad2:	f3c3 1802 	ubfx	r8, r3, #4, #3
   11ad6:	f108 36ff 	add.w	r6, r8, #4294967295
   11ada:	2e03      	cmp	r6, #3
   11adc:	d846      	bhi.n	11b6c <am_hal_uart_configure+0xf4>
   11ade:	e8df f006 	tbb	[pc, r6]
   11ae2:	020e      	.short	0x020e
   11ae4:	1114      	.short	0x1114
   11ae6:	494f      	ldr	r1, [pc, #316]	; (11c24 <am_hal_uart_configure+0x1ac>)
            ui32UartClkFreq = 12000000;
   11ae8:	484f      	ldr	r0, [pc, #316]	; (11c28 <am_hal_uart_configure+0x1b0>)
    ui32BaudClk = BAUDCLK * ui32DesiredBaudrate;
   11aea:	682a      	ldr	r2, [r5, #0]
   11aec:	0116      	lsls	r6, r2, #4
    ui32IntegerDivisor = (uint32_t)(ui32UartClkFreq / ui32BaudClk);
   11aee:	fbb0 f3f6 	udiv	r3, r0, r6
    if (ui32IntegerDivisor == 0)
   11af2:	b96b      	cbnz	r3, 11b10 <am_hal_uart_configure+0x98>
        return AM_HAL_UART_STATUS_BAUDRATE_NOT_POSSIBLE;
   11af4:	484d      	ldr	r0, [pc, #308]	; (11c2c <am_hal_uart_configure+0x1b4>)
        *pui32ActualBaud = 0;
   11af6:	6623      	str	r3, [r4, #96]	; 0x60
} // am_hal_uart_configure()
   11af8:	b004      	add	sp, #16
   11afa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    switch( UARTn(ui32Module)->CR_b.CLKSEL )
   11afe:	494c      	ldr	r1, [pc, #304]	; (11c30 <am_hal_uart_configure+0x1b8>)
            ui32UartClkFreq = 24000000;
   11b00:	484c      	ldr	r0, [pc, #304]	; (11c34 <am_hal_uart_configure+0x1bc>)
   11b02:	e7f2      	b.n	11aea <am_hal_uart_configure+0x72>
   11b04:	494c      	ldr	r1, [pc, #304]	; (11c38 <am_hal_uart_configure+0x1c0>)
            ui32UartClkFreq = 3000000;
   11b06:	484d      	ldr	r0, [pc, #308]	; (11c3c <am_hal_uart_configure+0x1c4>)
   11b08:	e7ef      	b.n	11aea <am_hal_uart_configure+0x72>
    switch( UARTn(ui32Module)->CR_b.CLKSEL )
   11b0a:	494d      	ldr	r1, [pc, #308]	; (11c40 <am_hal_uart_configure+0x1c8>)
            ui32UartClkFreq = 6000000;
   11b0c:	484d      	ldr	r0, [pc, #308]	; (11c44 <am_hal_uart_configure+0x1cc>)
   11b0e:	e7ec      	b.n	11aea <am_hal_uart_configure+0x72>
    ui64IntermediateLong = (ui32UartClkFreq * 64) / ui32BaudClk;
   11b10:	fbb1 f1f6 	udiv	r1, r1, r6
   11b14:	eba1 1283 	sub.w	r2, r1, r3, lsl #6
    UARTn(ui32Module)->IBRD = ui32IntegerDivisor;
   11b18:	627b      	str	r3, [r7, #36]	; 0x24
    *pui32ActualBaud = (ui32UartClkFreq / ((BAUDCLK * ui32IntegerDivisor) + ui32FractionDivisor));
   11b1a:	eb02 1603 	add.w	r6, r2, r3, lsl #4
    UARTn(ui32Module)->IBRD = ui32IntegerDivisor;
   11b1e:	627b      	str	r3, [r7, #36]	; 0x24
    *pui32ActualBaud = (ui32UartClkFreq / ((BAUDCLK * ui32IntegerDivisor) + ui32FractionDivisor));
   11b20:	fbb0 f0f6 	udiv	r0, r0, r6
    UARTn(ui32Module)->FBRD = ui32FractionDivisor;
   11b24:	62ba      	str	r2, [r7, #40]	; 0x28
    *pui32ActualBaud = (ui32UartClkFreq / ((BAUDCLK * ui32IntegerDivisor) + ui32FractionDivisor));
   11b26:	6620      	str	r0, [r4, #96]	; 0x60
    UARTn(ui32Module)->CR   |= psConfig->ui32FlowControl;
   11b28:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   11b2a:	6929      	ldr	r1, [r5, #16]
   11b2c:	430b      	orrs	r3, r1
   11b2e:	633b      	str	r3, [r7, #48]	; 0x30
    UARTn(ui32Module)->IFLS  = psConfig->ui32FifoLevels;
   11b30:	696a      	ldr	r2, [r5, #20]
   11b32:	637a      	str	r2, [r7, #52]	; 0x34
    UARTn(ui32Module)->LCRH  = (psConfig->ui32DataBits   |
   11b34:	686e      	ldr	r6, [r5, #4]
   11b36:	68a8      	ldr	r0, [r5, #8]
                                psConfig->ui32StopBits   |
   11b38:	68e9      	ldr	r1, [r5, #12]
    UARTn(ui32Module)->LCRH  = (psConfig->ui32DataBits   |
   11b3a:	4306      	orrs	r6, r0
                                psConfig->ui32StopBits   |
   11b3c:	f046 0310 	orr.w	r3, r6, #16
   11b40:	430b      	orrs	r3, r1
    UARTn(ui32Module)->LCRH  = (psConfig->ui32DataBits   |
   11b42:	62fb      	str	r3, [r7, #44]	; 0x2c
    AM_CRITICAL_BEGIN
   11b44:	f7ff fcc8 	bl	114d8 <am_hal_interrupt_master_disable>
   11b48:	9003      	str	r0, [sp, #12]
    UARTn(ui32Module)->CR   |=
   11b4a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   11b4c:	f442 7640 	orr.w	r6, r2, #768	; 0x300
   11b50:	f046 0001 	orr.w	r0, r6, #1
   11b54:	6338      	str	r0, [r7, #48]	; 0x30
    AM_CRITICAL_END
   11b56:	9803      	ldr	r0, [sp, #12]
   11b58:	f7ff fcc2 	bl	114e0 <am_hal_interrupt_master_set>
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11b5c:	6827      	ldr	r7, [r4, #0]
   11b5e:	4930      	ldr	r1, [pc, #192]	; (11c20 <am_hal_uart_configure+0x1a8>)
   11b60:	f027 467e 	bic.w	r6, r7, #4261412864	; 0xfe000000
   11b64:	428e      	cmp	r6, r1
   11b66:	d005      	beq.n	11b74 <am_hal_uart_configure+0xfc>
    return AM_HAL_STATUS_SUCCESS;
   11b68:	2000      	movs	r0, #0
   11b6a:	e7c5      	b.n	11af8 <am_hal_uart_configure+0x80>
            *pui32ActualBaud = 0;
   11b6c:	2600      	movs	r6, #0
   11b6e:	6626      	str	r6, [r4, #96]	; 0x60
            return AM_HAL_UART_STATUS_CLOCK_NOT_CONFIGURED;
   11b70:	4835      	ldr	r0, [pc, #212]	; (11c48 <am_hal_uart_configure+0x1d0>)
   11b72:	e7c1      	b.n	11af8 <am_hal_uart_configure+0x80>
    buffer_configure(pHandle,
   11b74:	69a9      	ldr	r1, [r5, #24]
   11b76:	6a2f      	ldr	r7, [r5, #32]
   11b78:	f8d5 8024 	ldr.w	r8, [r5, #36]	; 0x24
    if (pui8TxBuffer && ui32TxBufferSize)
   11b7c:	b109      	cbz	r1, 11b82 <am_hal_uart_configure+0x10a>
    buffer_configure(pHandle,
   11b7e:	69eb      	ldr	r3, [r5, #28]
    if (pui8TxBuffer && ui32TxBufferSize)
   11b80:	b9f3      	cbnz	r3, 11bc0 <am_hal_uart_configure+0x148>
    UARTn(ui32Module)->IER &= ~ui32IntMask;
   11b82:	6a65      	ldr	r5, [r4, #36]	; 0x24
   11b84:	f505 2380 	add.w	r3, r5, #262144	; 0x40000
   11b88:	331c      	adds	r3, #28
   11b8a:	031e      	lsls	r6, r3, #12
        pState->bEnableTxQueue = false;
   11b8c:	f04f 0e00 	mov.w	lr, #0
   11b90:	f884 e028 	strb.w	lr, [r4, #40]	; 0x28
    UARTn(ui32Module)->IER &= ~ui32IntMask;
   11b94:	6bb2      	ldr	r2, [r6, #56]	; 0x38
   11b96:	f022 0020 	bic.w	r0, r2, #32
   11b9a:	63b0      	str	r0, [r6, #56]	; 0x38
    if (pui8RxBuffer && ui32RxBufferSize)
   11b9c:	b117      	cbz	r7, 11ba4 <am_hal_uart_configure+0x12c>
   11b9e:	f1b8 0f00 	cmp.w	r8, #0
   11ba2:	d123      	bne.n	11bec <am_hal_uart_configure+0x174>
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11ba4:	6827      	ldr	r7, [r4, #0]
   11ba6:	491e      	ldr	r1, [pc, #120]	; (11c20 <am_hal_uart_configure+0x1a8>)
   11ba8:	f027 457e 	bic.w	r5, r7, #4261412864	; 0xfe000000
        pState->bEnableRxQueue = false;
   11bac:	2000      	movs	r0, #0
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11bae:	428d      	cmp	r5, r1
        pState->bEnableRxQueue = false;
   11bb0:	f884 0044 	strb.w	r0, [r4, #68]	; 0x44
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11bb4:	d1d8      	bne.n	11b68 <am_hal_uart_configure+0xf0>
    UARTn(ui32Module)->IER &= ~ui32IntMask;
   11bb6:	6bb4      	ldr	r4, [r6, #56]	; 0x38
   11bb8:	f024 0350 	bic.w	r3, r4, #80	; 0x50
   11bbc:	63b3      	str	r3, [r6, #56]	; 0x38
   11bbe:	e79b      	b.n	11af8 <am_hal_uart_configure+0x80>
        pState->bEnableTxQueue = true;
   11bc0:	2201      	movs	r2, #1
   11bc2:	f884 2028 	strb.w	r2, [r4, #40]	; 0x28
        am_hal_queue_init(&pState->sTxQueue, pui8TxBuffer, 1, ui32TxBufferSize);
   11bc6:	f104 002c 	add.w	r0, r4, #44	; 0x2c
   11bca:	f000 fcf5 	bl	125b8 <am_hal_queue_init>
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11bce:	6821      	ldr	r1, [r4, #0]
   11bd0:	f021 457e 	bic.w	r5, r1, #4261412864	; 0xfe000000
   11bd4:	42b5      	cmp	r5, r6
   11bd6:	d1c7      	bne.n	11b68 <am_hal_uart_configure+0xf0>
    UARTn(ui32Module)->IER |= ui32IntMask;
   11bd8:	6a63      	ldr	r3, [r4, #36]	; 0x24
   11bda:	f503 2680 	add.w	r6, r3, #262144	; 0x40000
   11bde:	361c      	adds	r6, #28
   11be0:	0336      	lsls	r6, r6, #12
   11be2:	6bb2      	ldr	r2, [r6, #56]	; 0x38
   11be4:	f042 0020 	orr.w	r0, r2, #32
   11be8:	63b0      	str	r0, [r6, #56]	; 0x38
   11bea:	e7d7      	b.n	11b9c <am_hal_uart_configure+0x124>
        pState->bEnableRxQueue = true;
   11bec:	2201      	movs	r2, #1
   11bee:	f884 2044 	strb.w	r2, [r4, #68]	; 0x44
        am_hal_queue_init(&pState->sRxQueue, pui8RxBuffer, 1, ui32RxBufferSize);
   11bf2:	f104 0048 	add.w	r0, r4, #72	; 0x48
   11bf6:	4643      	mov	r3, r8
   11bf8:	4639      	mov	r1, r7
   11bfa:	f000 fcdd 	bl	125b8 <am_hal_queue_init>
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11bfe:	6826      	ldr	r6, [r4, #0]
   11c00:	4a07      	ldr	r2, [pc, #28]	; (11c20 <am_hal_uart_configure+0x1a8>)
   11c02:	f026 407e 	bic.w	r0, r6, #4261412864	; 0xfe000000
   11c06:	4290      	cmp	r0, r2
   11c08:	d1ae      	bne.n	11b68 <am_hal_uart_configure+0xf0>
    UARTn(ui32Module)->IER |= ui32IntMask;
   11c0a:	6a67      	ldr	r7, [r4, #36]	; 0x24
   11c0c:	f507 2180 	add.w	r1, r7, #262144	; 0x40000
   11c10:	311c      	adds	r1, #28
   11c12:	030d      	lsls	r5, r1, #12
    return AM_HAL_STATUS_SUCCESS;
   11c14:	2000      	movs	r0, #0
    UARTn(ui32Module)->IER |= ui32IntMask;
   11c16:	6bac      	ldr	r4, [r5, #56]	; 0x38
   11c18:	f044 0350 	orr.w	r3, r4, #80	; 0x50
   11c1c:	63ab      	str	r3, [r5, #56]	; 0x38
   11c1e:	e76b      	b.n	11af8 <am_hal_uart_configure+0x80>
   11c20:	01ea9e06 	.word	0x01ea9e06
   11c24:	2dc6c000 	.word	0x2dc6c000
   11c28:	00b71b00 	.word	0x00b71b00
   11c2c:	08000003 	.word	0x08000003
   11c30:	5b8d8000 	.word	0x5b8d8000
   11c34:	016e3600 	.word	0x016e3600
   11c38:	0b71b000 	.word	0x0b71b000
   11c3c:	002dc6c0 	.word	0x002dc6c0
   11c40:	16e36000 	.word	0x16e36000
   11c44:	005b8d80 	.word	0x005b8d80
   11c48:	08000002 	.word	0x08000002

00011c4c <am_hal_uart_transfer>:
{
   11c4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if (pTransfer->ui32Direction == AM_HAL_UART_WRITE)
   11c50:	680e      	ldr	r6, [r1, #0]
{
   11c52:	b091      	sub	sp, #68	; 0x44
   11c54:	4680      	mov	r8, r0
    if (pTransfer->ui32Direction == AM_HAL_UART_WRITE)
   11c56:	b14e      	cbz	r6, 11c6c <am_hal_uart_transfer+0x20>
    else if (pTransfer->ui32Direction == AM_HAL_UART_READ)
   11c58:	2e01      	cmp	r6, #1
    return AM_HAL_STATUS_INVALID_OPERATION;
   11c5a:	bf18      	it	ne
   11c5c:	f04f 0b07 	movne.w	fp, #7
    else if (pTransfer->ui32Direction == AM_HAL_UART_READ)
   11c60:	f000 80f6 	beq.w	11e50 <am_hal_uart_transfer+0x204>
} // am_hal_uart_transfer()
   11c64:	4658      	mov	r0, fp
   11c66:	b011      	add	sp, #68	; 0x44
   11c68:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return write_timeout(pHandle,
   11c6c:	f8d1 b00c 	ldr.w	fp, [r1, #12]
   11c70:	684c      	ldr	r4, [r1, #4]
   11c72:	9401      	str	r4, [sp, #4]
   11c74:	688d      	ldr	r5, [r1, #8]
   11c76:	f8d1 a010 	ldr.w	sl, [r1, #16]
    if (ui32TimeoutMs == 0)
   11c7a:	f1bb 0f00 	cmp.w	fp, #0
   11c7e:	f000 8107 	beq.w	11e90 <am_hal_uart_transfer+0x244>
    while (ui32RemainingBytes && (ui32TimeSpent < ui32TimeoutMs))
   11c82:	2d00      	cmp	r5, #0
   11c84:	f000 8393 	beq.w	123ae <am_hal_uart_transfer+0x762>
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11c88:	2800      	cmp	r0, #0
   11c8a:	f000 80df 	beq.w	11e4c <am_hal_uart_transfer+0x200>
   11c8e:	6807      	ldr	r7, [r0, #0]
   11c90:	497e      	ldr	r1, [pc, #504]	; (11e8c <am_hal_uart_transfer+0x240>)
   11c92:	f027 497e 	bic.w	r9, r7, #4261412864	; 0xfe000000
   11c96:	4589      	cmp	r9, r1
   11c98:	d00a      	beq.n	11cb0 <am_hal_uart_transfer+0x64>
            if (pui32NumBytesWritten)
   11c9a:	f1ba 0f00 	cmp.w	sl, #0
   11c9e:	d001      	beq.n	11ca4 <am_hal_uart_transfer+0x58>
                *pui32NumBytesWritten = i;
   11ca0:	f8ca 6000 	str.w	r6, [sl]
   11ca4:	f04f 0b02 	mov.w	fp, #2
} // am_hal_uart_transfer()
   11ca8:	4658      	mov	r0, fp
   11caa:	b011      	add	sp, #68	; 0x44
   11cac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        am_hal_queue_item_add(&pState->sTxQueue, pui8Data, ui32BytesTransferred);
   11cb0:	302c      	adds	r0, #44	; 0x2c
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11cb2:	4637      	mov	r7, r6
   11cb4:	4621      	mov	r1, r4
        am_hal_queue_item_add(&pState->sTxQueue, pui8Data, ui32BytesTransferred);
   11cb6:	9002      	str	r0, [sp, #8]
    if (pState->bEnableTxQueue)
   11cb8:	f898 2028 	ldrb.w	r2, [r8, #40]	; 0x28
   11cbc:	2a00      	cmp	r2, #0
   11cbe:	f040 822c 	bne.w	1211a <am_hal_uart_transfer+0x4ce>
    uint32_t ui32Module = pState->ui32Module;
   11cc2:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
    while (i < ui32NumBytes)
   11cc6:	2d00      	cmp	r5, #0
   11cc8:	f000 80a1 	beq.w	11e0e <am_hal_uart_transfer+0x1c2>
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11ccc:	f503 2480 	add.w	r4, r3, #262144	; 0x40000
   11cd0:	341c      	adds	r4, #28
   11cd2:	0322      	lsls	r2, r4, #12
   11cd4:	6990      	ldr	r0, [r2, #24]
   11cd6:	f3c0 1440 	ubfx	r4, r0, #5, #1
   11cda:	2c00      	cmp	r4, #0
   11cdc:	f040 80a3 	bne.w	11e26 <am_hal_uart_transfer+0x1da>
   11ce0:	1e6b      	subs	r3, r5, #1
   11ce2:	f013 0e07 	ands.w	lr, r3, #7
   11ce6:	f101 3cff 	add.w	ip, r1, #4294967295
   11cea:	d048      	beq.n	11d7e <am_hal_uart_transfer+0x132>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11cec:	780c      	ldrb	r4, [r1, #0]
   11cee:	6014      	str	r4, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11cf0:	6993      	ldr	r3, [r2, #24]
   11cf2:	069b      	lsls	r3, r3, #26
   11cf4:	468c      	mov	ip, r1
            UARTn(ui32Module)->DR = pui8Data[i++];
   11cf6:	f04f 0401 	mov.w	r4, #1
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11cfa:	f100 8085 	bmi.w	11e08 <am_hal_uart_transfer+0x1bc>
   11cfe:	45a6      	cmp	lr, r4
   11d00:	d03d      	beq.n	11d7e <am_hal_uart_transfer+0x132>
   11d02:	f1be 0f02 	cmp.w	lr, #2
   11d06:	d032      	beq.n	11d6e <am_hal_uart_transfer+0x122>
   11d08:	f1be 0f03 	cmp.w	lr, #3
   11d0c:	d027      	beq.n	11d5e <am_hal_uart_transfer+0x112>
   11d0e:	f1be 0f04 	cmp.w	lr, #4
   11d12:	d01c      	beq.n	11d4e <am_hal_uart_transfer+0x102>
   11d14:	f1be 0f05 	cmp.w	lr, #5
   11d18:	d011      	beq.n	11d3e <am_hal_uart_transfer+0xf2>
   11d1a:	f1be 0f06 	cmp.w	lr, #6
   11d1e:	d006      	beq.n	11d2e <am_hal_uart_transfer+0xe2>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11d20:	f81c 1f01 	ldrb.w	r1, [ip, #1]!
   11d24:	6011      	str	r1, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11d26:	6990      	ldr	r0, [r2, #24]
   11d28:	0681      	lsls	r1, r0, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   11d2a:	4424      	add	r4, r4
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11d2c:	d46c      	bmi.n	11e08 <am_hal_uart_transfer+0x1bc>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11d2e:	f81c 3f01 	ldrb.w	r3, [ip, #1]!
   11d32:	6013      	str	r3, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11d34:	6991      	ldr	r1, [r2, #24]
   11d36:	068b      	lsls	r3, r1, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   11d38:	f104 0401 	add.w	r4, r4, #1
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11d3c:	d464      	bmi.n	11e08 <am_hal_uart_transfer+0x1bc>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11d3e:	f81c 0f01 	ldrb.w	r0, [ip, #1]!
   11d42:	6010      	str	r0, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11d44:	6993      	ldr	r3, [r2, #24]
   11d46:	0699      	lsls	r1, r3, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   11d48:	f104 0401 	add.w	r4, r4, #1
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11d4c:	d45c      	bmi.n	11e08 <am_hal_uart_transfer+0x1bc>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11d4e:	f81c 1f01 	ldrb.w	r1, [ip, #1]!
   11d52:	6011      	str	r1, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11d54:	6990      	ldr	r0, [r2, #24]
   11d56:	0683      	lsls	r3, r0, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   11d58:	f104 0401 	add.w	r4, r4, #1
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11d5c:	d454      	bmi.n	11e08 <am_hal_uart_transfer+0x1bc>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11d5e:	f81c 3f01 	ldrb.w	r3, [ip, #1]!
   11d62:	6013      	str	r3, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11d64:	6991      	ldr	r1, [r2, #24]
   11d66:	0689      	lsls	r1, r1, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   11d68:	f104 0401 	add.w	r4, r4, #1
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11d6c:	d44c      	bmi.n	11e08 <am_hal_uart_transfer+0x1bc>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11d6e:	f81c 0f01 	ldrb.w	r0, [ip, #1]!
   11d72:	6010      	str	r0, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11d74:	6993      	ldr	r3, [r2, #24]
   11d76:	069b      	lsls	r3, r3, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   11d78:	f104 0401 	add.w	r4, r4, #1
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11d7c:	d444      	bmi.n	11e08 <am_hal_uart_transfer+0x1bc>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11d7e:	3401      	adds	r4, #1
   11d80:	f89c 1001 	ldrb.w	r1, [ip, #1]
   11d84:	6011      	str	r1, [r2, #0]
    while (i < ui32NumBytes)
   11d86:	42a5      	cmp	r5, r4
            UARTn(ui32Module)->DR = pui8Data[i++];
   11d88:	4620      	mov	r0, r4
   11d8a:	f10c 0e01 	add.w	lr, ip, #1
    while (i < ui32NumBytes)
   11d8e:	f000 81c2 	beq.w	12116 <am_hal_uart_transfer+0x4ca>
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11d92:	6993      	ldr	r3, [r2, #24]
   11d94:	0699      	lsls	r1, r3, #26
   11d96:	d437      	bmi.n	11e08 <am_hal_uart_transfer+0x1bc>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11d98:	f89e 1001 	ldrb.w	r1, [lr, #1]
   11d9c:	6011      	str	r1, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11d9e:	6993      	ldr	r3, [r2, #24]
   11da0:	0699      	lsls	r1, r3, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   11da2:	f104 0401 	add.w	r4, r4, #1
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11da6:	d42f      	bmi.n	11e08 <am_hal_uart_transfer+0x1bc>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11da8:	f89c 4003 	ldrb.w	r4, [ip, #3]
   11dac:	6014      	str	r4, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11dae:	6991      	ldr	r1, [r2, #24]
   11db0:	0689      	lsls	r1, r1, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   11db2:	f100 0402 	add.w	r4, r0, #2
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11db6:	d427      	bmi.n	11e08 <am_hal_uart_transfer+0x1bc>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11db8:	f89c 3004 	ldrb.w	r3, [ip, #4]
   11dbc:	6013      	str	r3, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11dbe:	6991      	ldr	r1, [r2, #24]
   11dc0:	0689      	lsls	r1, r1, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   11dc2:	f100 0403 	add.w	r4, r0, #3
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11dc6:	d41f      	bmi.n	11e08 <am_hal_uart_transfer+0x1bc>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11dc8:	f89c 4005 	ldrb.w	r4, [ip, #5]
   11dcc:	6014      	str	r4, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11dce:	6993      	ldr	r3, [r2, #24]
   11dd0:	0699      	lsls	r1, r3, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   11dd2:	f100 0404 	add.w	r4, r0, #4
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11dd6:	d417      	bmi.n	11e08 <am_hal_uart_transfer+0x1bc>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11dd8:	f89c 1006 	ldrb.w	r1, [ip, #6]
   11ddc:	6011      	str	r1, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11dde:	6993      	ldr	r3, [r2, #24]
   11de0:	0699      	lsls	r1, r3, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   11de2:	f100 0405 	add.w	r4, r0, #5
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11de6:	d40f      	bmi.n	11e08 <am_hal_uart_transfer+0x1bc>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11de8:	f89c 4007 	ldrb.w	r4, [ip, #7]
   11dec:	6014      	str	r4, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11dee:	6991      	ldr	r1, [r2, #24]
   11df0:	0689      	lsls	r1, r1, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   11df2:	f100 0406 	add.w	r4, r0, #6
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11df6:	d407      	bmi.n	11e08 <am_hal_uart_transfer+0x1bc>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11df8:	f81c 3f08 	ldrb.w	r3, [ip, #8]!
   11dfc:	6013      	str	r3, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11dfe:	6991      	ldr	r1, [r2, #24]
   11e00:	068b      	lsls	r3, r1, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   11e02:	f100 0407 	add.w	r4, r0, #7
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11e06:	d5ba      	bpl.n	11d7e <am_hal_uart_transfer+0x132>
        if (ui32RemainingBytes)
   11e08:	1b2d      	subs	r5, r5, r4
        i += ui32BytesWritten;
   11e0a:	4426      	add	r6, r4
        if (ui32RemainingBytes)
   11e0c:	d10b      	bne.n	11e26 <am_hal_uart_transfer+0x1da>
    if (pui32NumBytesWritten)
   11e0e:	f1ba 0f00 	cmp.w	sl, #0
   11e12:	f000 817d 	beq.w	12110 <am_hal_uart_transfer+0x4c4>
    return AM_HAL_STATUS_SUCCESS;
   11e16:	f04f 0b00 	mov.w	fp, #0
} // am_hal_uart_transfer()
   11e1a:	4658      	mov	r0, fp
        *pui32NumBytesWritten = i;
   11e1c:	f8ca 6000 	str.w	r6, [sl]
} // am_hal_uart_transfer()
   11e20:	b011      	add	sp, #68	; 0x44
   11e22:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            am_hal_flash_delay(FLASH_CYCLES_US(1));
   11e26:	2001      	movs	r0, #1
   11e28:	f7ff f8da 	bl	10fe0 <am_hal_flash_delay>
            if (ui32TimeoutMs != AM_HAL_UART_WAIT_FOREVER)
   11e2c:	f1bb 3fff 	cmp.w	fp, #4294967295
                ui32TimeSpent++;
   11e30:	bf18      	it	ne
   11e32:	3701      	addne	r7, #1
    while (ui32RemainingBytes && (ui32TimeSpent < ui32TimeoutMs))
   11e34:	45bb      	cmp	fp, r7
   11e36:	d9ea      	bls.n	11e0e <am_hal_uart_transfer+0x1c2>
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11e38:	f8d8 4000 	ldr.w	r4, [r8]
        ui32Status = write_nonblocking(pHandle, &pui8Data[i],
   11e3c:	9901      	ldr	r1, [sp, #4]
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11e3e:	f024 407e 	bic.w	r0, r4, #4261412864	; 0xfe000000
   11e42:	4548      	cmp	r0, r9
        ui32Status = write_nonblocking(pHandle, &pui8Data[i],
   11e44:	4431      	add	r1, r6
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11e46:	f47f af28 	bne.w	11c9a <am_hal_uart_transfer+0x4e>
   11e4a:	e735      	b.n	11cb8 <am_hal_uart_transfer+0x6c>
   11e4c:	4606      	mov	r6, r0
   11e4e:	e724      	b.n	11c9a <am_hal_uart_transfer+0x4e>
        return read_timeout(pHandle,
   11e50:	684b      	ldr	r3, [r1, #4]
   11e52:	f8d1 b00c 	ldr.w	fp, [r1, #12]
   11e56:	688c      	ldr	r4, [r1, #8]
   11e58:	690f      	ldr	r7, [r1, #16]
   11e5a:	4699      	mov	r9, r3
    if (ui32TimeoutMs == 0)
   11e5c:	f1bb 0f00 	cmp.w	fp, #0
   11e60:	f000 80c9 	beq.w	11ff6 <am_hal_uart_transfer+0x3aa>
    while (ui32RemainingBytes && (ui32TimeSpent < ui32TimeoutMs))
   11e64:	2c00      	cmp	r4, #0
   11e66:	f000 8150 	beq.w	1210a <am_hal_uart_transfer+0x4be>
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11e6a:	b130      	cbz	r0, 11e7a <am_hal_uart_transfer+0x22e>
   11e6c:	6800      	ldr	r0, [r0, #0]
   11e6e:	4a07      	ldr	r2, [pc, #28]	; (11e8c <am_hal_uart_transfer+0x240>)
   11e70:	f020 417e 	bic.w	r1, r0, #4261412864	; 0xfe000000
   11e74:	4291      	cmp	r1, r2
   11e76:	f000 8186 	beq.w	12186 <am_hal_uart_transfer+0x53a>
   11e7a:	2500      	movs	r5, #0
        return AM_HAL_STATUS_INVALID_HANDLE;
   11e7c:	f04f 0b02 	mov.w	fp, #2
            if (pui32NumBytesRead)
   11e80:	2f00      	cmp	r7, #0
   11e82:	f43f aeef 	beq.w	11c64 <am_hal_uart_transfer+0x18>
                *pui32NumBytesRead = i;
   11e86:	603d      	str	r5, [r7, #0]
   11e88:	e6ec      	b.n	11c64 <am_hal_uart_transfer+0x18>
   11e8a:	bf00      	nop
   11e8c:	01ea9e06 	.word	0x01ea9e06
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11e90:	2800      	cmp	r0, #0
   11e92:	f43f af07 	beq.w	11ca4 <am_hal_uart_transfer+0x58>
   11e96:	6807      	ldr	r7, [r0, #0]
   11e98:	4cac      	ldr	r4, [pc, #688]	; (1214c <am_hal_uart_transfer+0x500>)
   11e9a:	f027 437e 	bic.w	r3, r7, #4261412864	; 0xfe000000
   11e9e:	42a3      	cmp	r3, r4
   11ea0:	f47f af00 	bne.w	11ca4 <am_hal_uart_transfer+0x58>
    if (pui32NumBytesWritten)
   11ea4:	f1ba 0f00 	cmp.w	sl, #0
   11ea8:	d001      	beq.n	11eae <am_hal_uart_transfer+0x262>
        *pui32NumBytesWritten = 0;
   11eaa:	f8ca b000 	str.w	fp, [sl]
    if (ui32NumBytes == 0)
   11eae:	2d00      	cmp	r5, #0
   11eb0:	f000 812e 	beq.w	12110 <am_hal_uart_transfer+0x4c4>
    if (pState->bEnableTxQueue)
   11eb4:	f898 4028 	ldrb.w	r4, [r8, #40]	; 0x28
   11eb8:	2c00      	cmp	r4, #0
   11eba:	f040 8290 	bne.w	123de <am_hal_uart_transfer+0x792>
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11ebe:	f8d8 0024 	ldr.w	r0, [r8, #36]	; 0x24
   11ec2:	f500 2180 	add.w	r1, r0, #262144	; 0x40000
   11ec6:	311c      	adds	r1, #28
   11ec8:	030a      	lsls	r2, r1, #12
   11eca:	6996      	ldr	r6, [r2, #24]
   11ecc:	f3c6 1740 	ubfx	r7, r6, #5, #1
   11ed0:	2f00      	cmp	r7, #0
   11ed2:	f040 8089 	bne.w	11fe8 <am_hal_uart_transfer+0x39c>
   11ed6:	f105 38ff 	add.w	r8, r5, #4294967295
   11eda:	9b01      	ldr	r3, [sp, #4]
   11edc:	f018 0007 	ands.w	r0, r8, #7
   11ee0:	463c      	mov	r4, r7
   11ee2:	f103 31ff 	add.w	r1, r3, #4294967295
   11ee6:	d042      	beq.n	11f6e <am_hal_uart_transfer+0x322>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11ee8:	781e      	ldrb	r6, [r3, #0]
   11eea:	6016      	str	r6, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11eec:	6997      	ldr	r7, [r2, #24]
   11eee:	4619      	mov	r1, r3
   11ef0:	06bb      	lsls	r3, r7, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   11ef2:	f04f 0401 	mov.w	r4, #1
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11ef6:	d477      	bmi.n	11fe8 <am_hal_uart_transfer+0x39c>
   11ef8:	42a0      	cmp	r0, r4
   11efa:	d038      	beq.n	11f6e <am_hal_uart_transfer+0x322>
   11efc:	2802      	cmp	r0, #2
   11efe:	d02e      	beq.n	11f5e <am_hal_uart_transfer+0x312>
   11f00:	2803      	cmp	r0, #3
   11f02:	d024      	beq.n	11f4e <am_hal_uart_transfer+0x302>
   11f04:	2804      	cmp	r0, #4
   11f06:	d01a      	beq.n	11f3e <am_hal_uart_transfer+0x2f2>
   11f08:	2805      	cmp	r0, #5
   11f0a:	d010      	beq.n	11f2e <am_hal_uart_transfer+0x2e2>
   11f0c:	2806      	cmp	r0, #6
   11f0e:	d006      	beq.n	11f1e <am_hal_uart_transfer+0x2d2>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11f10:	f811 3f01 	ldrb.w	r3, [r1, #1]!
   11f14:	6013      	str	r3, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11f16:	6990      	ldr	r0, [r2, #24]
   11f18:	0687      	lsls	r7, r0, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   11f1a:	4424      	add	r4, r4
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11f1c:	d464      	bmi.n	11fe8 <am_hal_uart_transfer+0x39c>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11f1e:	f811 6f01 	ldrb.w	r6, [r1, #1]!
   11f22:	6016      	str	r6, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11f24:	6997      	ldr	r7, [r2, #24]
   11f26:	06be      	lsls	r6, r7, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   11f28:	f104 0401 	add.w	r4, r4, #1
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11f2c:	d45c      	bmi.n	11fe8 <am_hal_uart_transfer+0x39c>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11f2e:	f811 3f01 	ldrb.w	r3, [r1, #1]!
   11f32:	6013      	str	r3, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11f34:	6990      	ldr	r0, [r2, #24]
   11f36:	0680      	lsls	r0, r0, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   11f38:	f104 0401 	add.w	r4, r4, #1
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11f3c:	d454      	bmi.n	11fe8 <am_hal_uart_transfer+0x39c>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11f3e:	f811 6f01 	ldrb.w	r6, [r1, #1]!
   11f42:	6016      	str	r6, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11f44:	6997      	ldr	r7, [r2, #24]
   11f46:	06bb      	lsls	r3, r7, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   11f48:	f104 0401 	add.w	r4, r4, #1
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11f4c:	d44c      	bmi.n	11fe8 <am_hal_uart_transfer+0x39c>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11f4e:	f811 3f01 	ldrb.w	r3, [r1, #1]!
   11f52:	6013      	str	r3, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11f54:	6990      	ldr	r0, [r2, #24]
   11f56:	0687      	lsls	r7, r0, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   11f58:	f104 0401 	add.w	r4, r4, #1
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11f5c:	d444      	bmi.n	11fe8 <am_hal_uart_transfer+0x39c>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11f5e:	f811 6f01 	ldrb.w	r6, [r1, #1]!
   11f62:	6016      	str	r6, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11f64:	6997      	ldr	r7, [r2, #24]
   11f66:	06be      	lsls	r6, r7, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   11f68:	f104 0401 	add.w	r4, r4, #1
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11f6c:	d43c      	bmi.n	11fe8 <am_hal_uart_transfer+0x39c>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11f6e:	3401      	adds	r4, #1
   11f70:	784b      	ldrb	r3, [r1, #1]
   11f72:	6013      	str	r3, [r2, #0]
    while (i < ui32NumBytes)
   11f74:	42a5      	cmp	r5, r4
            UARTn(ui32Module)->DR = pui8Data[i++];
   11f76:	4623      	mov	r3, r4
   11f78:	f101 0001 	add.w	r0, r1, #1
    while (i < ui32NumBytes)
   11f7c:	d034      	beq.n	11fe8 <am_hal_uart_transfer+0x39c>
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11f7e:	6996      	ldr	r6, [r2, #24]
   11f80:	06b6      	lsls	r6, r6, #26
   11f82:	d431      	bmi.n	11fe8 <am_hal_uart_transfer+0x39c>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11f84:	7847      	ldrb	r7, [r0, #1]
   11f86:	6017      	str	r7, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11f88:	6990      	ldr	r0, [r2, #24]
   11f8a:	0680      	lsls	r0, r0, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   11f8c:	f104 0401 	add.w	r4, r4, #1
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11f90:	d42a      	bmi.n	11fe8 <am_hal_uart_transfer+0x39c>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11f92:	78cc      	ldrb	r4, [r1, #3]
   11f94:	6014      	str	r4, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11f96:	6996      	ldr	r6, [r2, #24]
   11f98:	06b7      	lsls	r7, r6, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   11f9a:	f103 0402 	add.w	r4, r3, #2
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11f9e:	d423      	bmi.n	11fe8 <am_hal_uart_transfer+0x39c>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11fa0:	790f      	ldrb	r7, [r1, #4]
   11fa2:	6017      	str	r7, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11fa4:	6990      	ldr	r0, [r2, #24]
   11fa6:	0686      	lsls	r6, r0, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   11fa8:	f103 0403 	add.w	r4, r3, #3
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11fac:	d41c      	bmi.n	11fe8 <am_hal_uart_transfer+0x39c>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11fae:	794c      	ldrb	r4, [r1, #5]
   11fb0:	6014      	str	r4, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11fb2:	6996      	ldr	r6, [r2, #24]
   11fb4:	06b0      	lsls	r0, r6, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   11fb6:	f103 0404 	add.w	r4, r3, #4
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11fba:	d415      	bmi.n	11fe8 <am_hal_uart_transfer+0x39c>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11fbc:	798f      	ldrb	r7, [r1, #6]
   11fbe:	6017      	str	r7, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11fc0:	6990      	ldr	r0, [r2, #24]
   11fc2:	0687      	lsls	r7, r0, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   11fc4:	f103 0405 	add.w	r4, r3, #5
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11fc8:	d40e      	bmi.n	11fe8 <am_hal_uart_transfer+0x39c>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11fca:	79cc      	ldrb	r4, [r1, #7]
   11fcc:	6014      	str	r4, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11fce:	6996      	ldr	r6, [r2, #24]
   11fd0:	06b6      	lsls	r6, r6, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   11fd2:	f103 0406 	add.w	r4, r3, #6
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11fd6:	d407      	bmi.n	11fe8 <am_hal_uart_transfer+0x39c>
            UARTn(ui32Module)->DR = pui8Data[i++];
   11fd8:	f811 7f08 	ldrb.w	r7, [r1, #8]!
   11fdc:	6017      	str	r7, [r2, #0]
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11fde:	6990      	ldr	r0, [r2, #24]
   11fe0:	0680      	lsls	r0, r0, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   11fe2:	f103 0407 	add.w	r4, r3, #7
        if ( UARTn(ui32Module)->FR_b.TXFF )
   11fe6:	d5c2      	bpl.n	11f6e <am_hal_uart_transfer+0x322>
    if (pui32NumBytesWritten)
   11fe8:	f1ba 0f00 	cmp.w	sl, #0
   11fec:	f000 8090 	beq.w	12110 <am_hal_uart_transfer+0x4c4>
        *pui32NumBytesWritten = ui32BytesTransferred;
   11ff0:	f8ca 4000 	str.w	r4, [sl]
   11ff4:	e636      	b.n	11c64 <am_hal_uart_transfer+0x18>
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   11ff6:	2800      	cmp	r0, #0
   11ff8:	f43f ae54 	beq.w	11ca4 <am_hal_uart_transfer+0x58>
   11ffc:	6805      	ldr	r5, [r0, #0]
   11ffe:	4e53      	ldr	r6, [pc, #332]	; (1214c <am_hal_uart_transfer+0x500>)
   12000:	f025 4c7e 	bic.w	ip, r5, #4261412864	; 0xfe000000
   12004:	45b4      	cmp	ip, r6
   12006:	f47f ae4d 	bne.w	11ca4 <am_hal_uart_transfer+0x58>
    if (pui32NumBytesRead)
   1200a:	b10f      	cbz	r7, 12010 <am_hal_uart_transfer+0x3c4>
        *pui32NumBytesRead = 0;
   1200c:	f8c7 b000 	str.w	fp, [r7]
    if (ui32NumBytes == 0)
   12010:	2c00      	cmp	r4, #0
   12012:	d07d      	beq.n	12110 <am_hal_uart_transfer+0x4c4>
    if (pState->bEnableRxQueue)
   12014:	f898 0044 	ldrb.w	r0, [r8, #68]	; 0x44
   12018:	2800      	cmp	r0, #0
   1201a:	f040 8213 	bne.w	12444 <am_hal_uart_transfer+0x7f8>
        if ( UARTn(ui32Module)->FR_b.RXFE )
   1201e:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
   12022:	f503 2180 	add.w	r1, r3, #262144	; 0x40000
   12026:	311c      	adds	r1, #28
   12028:	0309      	lsls	r1, r1, #12
   1202a:	698a      	ldr	r2, [r1, #24]
   1202c:	f3c2 1500 	ubfx	r5, r2, #4, #1
   12030:	2d00      	cmp	r5, #0
   12032:	f040 8287 	bne.w	12544 <am_hal_uart_transfer+0x8f8>
            ui32ReadData = UARTn(ui32Module)->DR;
   12036:	680b      	ldr	r3, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   12038:	f413 6a70 	ands.w	sl, r3, #3840	; 0xf00
   1203c:	f040 81cc 	bne.w	123d8 <am_hal_uart_transfer+0x78c>
   12040:	1e66      	subs	r6, r4, #1
   12042:	f016 0203 	ands.w	r2, r6, #3
   12046:	4655      	mov	r5, sl
   12048:	f109 30ff 	add.w	r0, r9, #4294967295
   1204c:	d02b      	beq.n	120a6 <am_hal_uart_transfer+0x45a>
                pui8Data[i++] = ui32ReadData & 0xFF;
   1204e:	f889 3000 	strb.w	r3, [r9]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12052:	698b      	ldr	r3, [r1, #24]
   12054:	06de      	lsls	r6, r3, #27
   12056:	4648      	mov	r0, r9
                pui8Data[i++] = ui32ReadData & 0xFF;
   12058:	f04f 0501 	mov.w	r5, #1
        if ( UARTn(ui32Module)->FR_b.RXFE )
   1205c:	f53f af10 	bmi.w	11e80 <am_hal_uart_transfer+0x234>
            ui32ReadData = UARTn(ui32Module)->DR;
   12060:	680b      	ldr	r3, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   12062:	f413 6f70 	tst.w	r3, #3840	; 0xf00
   12066:	f040 81b7 	bne.w	123d8 <am_hal_uart_transfer+0x78c>
   1206a:	42aa      	cmp	r2, r5
   1206c:	d01b      	beq.n	120a6 <am_hal_uart_transfer+0x45a>
   1206e:	2a02      	cmp	r2, #2
   12070:	d00c      	beq.n	1208c <am_hal_uart_transfer+0x440>
                pui8Data[i++] = ui32ReadData & 0xFF;
   12072:	f800 3f01 	strb.w	r3, [r0, #1]!
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12076:	698e      	ldr	r6, [r1, #24]
   12078:	06f2      	lsls	r2, r6, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   1207a:	f04f 0502 	mov.w	r5, #2
        if ( UARTn(ui32Module)->FR_b.RXFE )
   1207e:	f53f aeff 	bmi.w	11e80 <am_hal_uart_transfer+0x234>
            ui32ReadData = UARTn(ui32Module)->DR;
   12082:	680b      	ldr	r3, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   12084:	f413 6f70 	tst.w	r3, #3840	; 0xf00
   12088:	f040 81a6 	bne.w	123d8 <am_hal_uart_transfer+0x78c>
                pui8Data[i++] = ui32ReadData & 0xFF;
   1208c:	f800 3f01 	strb.w	r3, [r0, #1]!
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12090:	698a      	ldr	r2, [r1, #24]
   12092:	06d3      	lsls	r3, r2, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   12094:	f105 0501 	add.w	r5, r5, #1
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12098:	f53f aef2 	bmi.w	11e80 <am_hal_uart_transfer+0x234>
            ui32ReadData = UARTn(ui32Module)->DR;
   1209c:	680b      	ldr	r3, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   1209e:	f413 6f70 	tst.w	r3, #3840	; 0xf00
   120a2:	f040 8199 	bne.w	123d8 <am_hal_uart_transfer+0x78c>
                pui8Data[i++] = ui32ReadData & 0xFF;
   120a6:	3501      	adds	r5, #1
    while (i < ui32NumBytes)
   120a8:	42ac      	cmp	r4, r5
                pui8Data[i++] = ui32ReadData & 0xFF;
   120aa:	7043      	strb	r3, [r0, #1]
   120ac:	f100 0601 	add.w	r6, r0, #1
   120b0:	462b      	mov	r3, r5
    while (i < ui32NumBytes)
   120b2:	f43f aee5 	beq.w	11e80 <am_hal_uart_transfer+0x234>
        if ( UARTn(ui32Module)->FR_b.RXFE )
   120b6:	698a      	ldr	r2, [r1, #24]
   120b8:	06d2      	lsls	r2, r2, #27
   120ba:	f53f aee1 	bmi.w	11e80 <am_hal_uart_transfer+0x234>
            ui32ReadData = UARTn(ui32Module)->DR;
   120be:	680a      	ldr	r2, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   120c0:	f412 6f70 	tst.w	r2, #3840	; 0xf00
   120c4:	f040 8188 	bne.w	123d8 <am_hal_uart_transfer+0x78c>
                pui8Data[i++] = ui32ReadData & 0xFF;
   120c8:	7072      	strb	r2, [r6, #1]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   120ca:	698e      	ldr	r6, [r1, #24]
   120cc:	06f6      	lsls	r6, r6, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   120ce:	f105 0501 	add.w	r5, r5, #1
        if ( UARTn(ui32Module)->FR_b.RXFE )
   120d2:	f53f aed5 	bmi.w	11e80 <am_hal_uart_transfer+0x234>
            ui32ReadData = UARTn(ui32Module)->DR;
   120d6:	680a      	ldr	r2, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   120d8:	f412 6f70 	tst.w	r2, #3840	; 0xf00
   120dc:	f040 817c 	bne.w	123d8 <am_hal_uart_transfer+0x78c>
                pui8Data[i++] = ui32ReadData & 0xFF;
   120e0:	70c2      	strb	r2, [r0, #3]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   120e2:	698e      	ldr	r6, [r1, #24]
   120e4:	06f2      	lsls	r2, r6, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   120e6:	f103 0502 	add.w	r5, r3, #2
        if ( UARTn(ui32Module)->FR_b.RXFE )
   120ea:	f53f aec9 	bmi.w	11e80 <am_hal_uart_transfer+0x234>
            ui32ReadData = UARTn(ui32Module)->DR;
   120ee:	680a      	ldr	r2, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   120f0:	f412 6f70 	tst.w	r2, #3840	; 0xf00
   120f4:	f040 8170 	bne.w	123d8 <am_hal_uart_transfer+0x78c>
                pui8Data[i++] = ui32ReadData & 0xFF;
   120f8:	f800 2f04 	strb.w	r2, [r0, #4]!
        if ( UARTn(ui32Module)->FR_b.RXFE )
   120fc:	698e      	ldr	r6, [r1, #24]
   120fe:	06f6      	lsls	r6, r6, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   12100:	f103 0503 	add.w	r5, r3, #3
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12104:	f53f aebc 	bmi.w	11e80 <am_hal_uart_transfer+0x234>
   12108:	e7c8      	b.n	1209c <am_hal_uart_transfer+0x450>
    while (ui32RemainingBytes && (ui32TimeSpent < ui32TimeoutMs))
   1210a:	4625      	mov	r5, r4
    if (pui32NumBytesRead)
   1210c:	b107      	cbz	r7, 12110 <am_hal_uart_transfer+0x4c4>
        *pui32NumBytesRead = i;
   1210e:	603d      	str	r5, [r7, #0]
    return AM_HAL_STATUS_SUCCESS;
   12110:	f04f 0b00 	mov.w	fp, #0
   12114:	e5a6      	b.n	11c64 <am_hal_uart_transfer+0x18>
        i += ui32BytesWritten;
   12116:	442e      	add	r6, r5
   12118:	e679      	b.n	11e0e <am_hal_uart_transfer+0x1c2>
        ui32BufferSpace = am_hal_queue_space_left(&pState->sTxQueue);
   1211a:	f8d8 0038 	ldr.w	r0, [r8, #56]	; 0x38
   1211e:	f8d8 2034 	ldr.w	r2, [r8, #52]	; 0x34
   12122:	1a84      	subs	r4, r0, r2
                                 ui32NumBytes : ui32BufferSpace);
   12124:	42ac      	cmp	r4, r5
   12126:	bf28      	it	cs
   12128:	462c      	movcs	r4, r5
        am_hal_queue_item_add(&pState->sTxQueue, pui8Data, ui32BytesTransferred);
   1212a:	4622      	mov	r2, r4
   1212c:	9802      	ldr	r0, [sp, #8]
   1212e:	f000 fa4f 	bl	125d0 <am_hal_queue_item_add>
    uint32_t ui32Module = pState->ui32Module;
   12132:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
   12136:	9303      	str	r3, [sp, #12]
    AM_CRITICAL_BEGIN
   12138:	f7ff f9ce 	bl	114d8 <am_hal_interrupt_master_disable>
   1213c:	9903      	ldr	r1, [sp, #12]
   1213e:	9008      	str	r0, [sp, #32]
   12140:	f501 2280 	add.w	r2, r1, #262144	; 0x40000
   12144:	321c      	adds	r2, #28
   12146:	0313      	lsls	r3, r2, #12
   12148:	9303      	str	r3, [sp, #12]
   1214a:	e010      	b.n	1216e <am_hal_uart_transfer+0x522>
   1214c:	01ea9e06 	.word	0x01ea9e06
        if (am_hal_queue_item_get(&pState->sTxQueue, &pui8Data, 1))
   12150:	f000 fb42 	bl	127d8 <am_hal_queue_item_get>
   12154:	b198      	cbz	r0, 1217e <am_hal_uart_transfer+0x532>
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12156:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
   1215a:	f502 2380 	add.w	r3, r2, #262144	; 0x40000
   1215e:	331c      	adds	r3, #28
   12160:	0318      	lsls	r0, r3, #12
   12162:	6981      	ldr	r1, [r0, #24]
   12164:	068a      	lsls	r2, r1, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   12166:	bf5c      	itt	pl
   12168:	f89d 201c 	ldrbpl.w	r2, [sp, #28]
   1216c:	6002      	strpl	r2, [r0, #0]
    while ( !UARTn(ui32Module)->FR_b.TXFF )
   1216e:	9b03      	ldr	r3, [sp, #12]
        if (am_hal_queue_item_get(&pState->sTxQueue, &pui8Data, 1))
   12170:	9802      	ldr	r0, [sp, #8]
    while ( !UARTn(ui32Module)->FR_b.TXFF )
   12172:	699b      	ldr	r3, [r3, #24]
   12174:	069b      	lsls	r3, r3, #26
        if (am_hal_queue_item_get(&pState->sTxQueue, &pui8Data, 1))
   12176:	f04f 0201 	mov.w	r2, #1
   1217a:	a907      	add	r1, sp, #28
    while ( !UARTn(ui32Module)->FR_b.TXFF )
   1217c:	d5e8      	bpl.n	12150 <am_hal_uart_transfer+0x504>
    AM_CRITICAL_END
   1217e:	9808      	ldr	r0, [sp, #32]
   12180:	f7ff f9ae 	bl	114e0 <am_hal_interrupt_master_set>
   12184:	e640      	b.n	11e08 <am_hal_uart_transfer+0x1bc>
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   12186:	2600      	movs	r6, #0
   12188:	469a      	mov	sl, r3
        if (!am_hal_queue_item_add(&pState->sRxQueue, pui8Data,
   1218a:	f108 0348 	add.w	r3, r8, #72	; 0x48
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   1218e:	9101      	str	r1, [sp, #4]
   12190:	4635      	mov	r5, r6
        if (!am_hal_queue_item_add(&pState->sRxQueue, pui8Data,
   12192:	9302      	str	r3, [sp, #8]
    if (pState->bEnableRxQueue)
   12194:	f898 0044 	ldrb.w	r0, [r8, #68]	; 0x44
   12198:	2800      	cmp	r0, #0
   1219a:	f040 8089 	bne.w	122b0 <am_hal_uart_transfer+0x664>
    uint32_t ui32Module = pState->ui32Module;
   1219e:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
    while (i < ui32NumBytes)
   121a2:	2c00      	cmp	r4, #0
   121a4:	d0b2      	beq.n	1210c <am_hal_uart_transfer+0x4c0>
        if ( UARTn(ui32Module)->FR_b.RXFE )
   121a6:	f502 2180 	add.w	r1, r2, #262144	; 0x40000
   121aa:	311c      	adds	r1, #28
   121ac:	030a      	lsls	r2, r1, #12
   121ae:	6993      	ldr	r3, [r2, #24]
   121b0:	06d8      	lsls	r0, r3, #27
   121b2:	d466      	bmi.n	12282 <am_hal_uart_transfer+0x636>
            ui32ReadData = UARTn(ui32Module)->DR;
   121b4:	6811      	ldr	r1, [r2, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   121b6:	f411 6370 	ands.w	r3, r1, #3840	; 0xf00
   121ba:	f040 810d 	bne.w	123d8 <am_hal_uart_transfer+0x78c>
   121be:	f104 3eff 	add.w	lr, r4, #4294967295
   121c2:	f01e 0e03 	ands.w	lr, lr, #3
   121c6:	f109 30ff 	add.w	r0, r9, #4294967295
   121ca:	d029      	beq.n	12220 <am_hal_uart_transfer+0x5d4>
                pui8Data[i++] = ui32ReadData & 0xFF;
   121cc:	f889 1000 	strb.w	r1, [r9]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   121d0:	6991      	ldr	r1, [r2, #24]
   121d2:	06c9      	lsls	r1, r1, #27
   121d4:	4648      	mov	r0, r9
                pui8Data[i++] = ui32ReadData & 0xFF;
   121d6:	f04f 0301 	mov.w	r3, #1
        if ( UARTn(ui32Module)->FR_b.RXFE )
   121da:	d44e      	bmi.n	1227a <am_hal_uart_transfer+0x62e>
            ui32ReadData = UARTn(ui32Module)->DR;
   121dc:	6811      	ldr	r1, [r2, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   121de:	f411 6f70 	tst.w	r1, #3840	; 0xf00
   121e2:	f040 80e0 	bne.w	123a6 <am_hal_uart_transfer+0x75a>
   121e6:	459e      	cmp	lr, r3
   121e8:	d01a      	beq.n	12220 <am_hal_uart_transfer+0x5d4>
   121ea:	f1be 0f02 	cmp.w	lr, #2
   121ee:	d00b      	beq.n	12208 <am_hal_uart_transfer+0x5bc>
                pui8Data[i++] = ui32ReadData & 0xFF;
   121f0:	f800 1f01 	strb.w	r1, [r0, #1]!
        if ( UARTn(ui32Module)->FR_b.RXFE )
   121f4:	6991      	ldr	r1, [r2, #24]
   121f6:	06c9      	lsls	r1, r1, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   121f8:	f04f 0302 	mov.w	r3, #2
        if ( UARTn(ui32Module)->FR_b.RXFE )
   121fc:	d43d      	bmi.n	1227a <am_hal_uart_transfer+0x62e>
            ui32ReadData = UARTn(ui32Module)->DR;
   121fe:	6811      	ldr	r1, [r2, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   12200:	f411 6f70 	tst.w	r1, #3840	; 0xf00
   12204:	f040 80cf 	bne.w	123a6 <am_hal_uart_transfer+0x75a>
                pui8Data[i++] = ui32ReadData & 0xFF;
   12208:	f800 1f01 	strb.w	r1, [r0, #1]!
        if ( UARTn(ui32Module)->FR_b.RXFE )
   1220c:	6991      	ldr	r1, [r2, #24]
   1220e:	06c9      	lsls	r1, r1, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   12210:	f103 0301 	add.w	r3, r3, #1
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12214:	d431      	bmi.n	1227a <am_hal_uart_transfer+0x62e>
            ui32ReadData = UARTn(ui32Module)->DR;
   12216:	6811      	ldr	r1, [r2, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   12218:	f411 6f70 	tst.w	r1, #3840	; 0xf00
   1221c:	f040 80c3 	bne.w	123a6 <am_hal_uart_transfer+0x75a>
                pui8Data[i++] = ui32ReadData & 0xFF;
   12220:	3301      	adds	r3, #1
    while (i < ui32NumBytes)
   12222:	42a3      	cmp	r3, r4
                pui8Data[i++] = ui32ReadData & 0xFF;
   12224:	7041      	strb	r1, [r0, #1]
   12226:	469e      	mov	lr, r3
   12228:	f100 0c01 	add.w	ip, r0, #1
    while (i < ui32NumBytes)
   1222c:	d025      	beq.n	1227a <am_hal_uart_transfer+0x62e>
        if ( UARTn(ui32Module)->FR_b.RXFE )
   1222e:	6991      	ldr	r1, [r2, #24]
   12230:	06c9      	lsls	r1, r1, #27
   12232:	d422      	bmi.n	1227a <am_hal_uart_transfer+0x62e>
            ui32ReadData = UARTn(ui32Module)->DR;
   12234:	6811      	ldr	r1, [r2, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   12236:	f411 6f70 	tst.w	r1, #3840	; 0xf00
   1223a:	f040 80b4 	bne.w	123a6 <am_hal_uart_transfer+0x75a>
                pui8Data[i++] = ui32ReadData & 0xFF;
   1223e:	f88c 1001 	strb.w	r1, [ip, #1]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12242:	6991      	ldr	r1, [r2, #24]
   12244:	06c9      	lsls	r1, r1, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   12246:	f103 0301 	add.w	r3, r3, #1
        if ( UARTn(ui32Module)->FR_b.RXFE )
   1224a:	d416      	bmi.n	1227a <am_hal_uart_transfer+0x62e>
            ui32ReadData = UARTn(ui32Module)->DR;
   1224c:	6811      	ldr	r1, [r2, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   1224e:	f411 6f70 	tst.w	r1, #3840	; 0xf00
   12252:	f040 80a8 	bne.w	123a6 <am_hal_uart_transfer+0x75a>
                pui8Data[i++] = ui32ReadData & 0xFF;
   12256:	70c1      	strb	r1, [r0, #3]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12258:	6991      	ldr	r1, [r2, #24]
   1225a:	06c9      	lsls	r1, r1, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   1225c:	f10e 0302 	add.w	r3, lr, #2
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12260:	d40b      	bmi.n	1227a <am_hal_uart_transfer+0x62e>
            ui32ReadData = UARTn(ui32Module)->DR;
   12262:	6811      	ldr	r1, [r2, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   12264:	f411 6f70 	tst.w	r1, #3840	; 0xf00
   12268:	f040 809d 	bne.w	123a6 <am_hal_uart_transfer+0x75a>
                pui8Data[i++] = ui32ReadData & 0xFF;
   1226c:	f800 1f04 	strb.w	r1, [r0, #4]!
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12270:	6991      	ldr	r1, [r2, #24]
   12272:	06c9      	lsls	r1, r1, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   12274:	f10e 0303 	add.w	r3, lr, #3
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12278:	d5cd      	bpl.n	12216 <am_hal_uart_transfer+0x5ca>
        if (ui32RemainingBytes)
   1227a:	1ae4      	subs	r4, r4, r3
        i += ui32BytesRead;
   1227c:	441d      	add	r5, r3
        if (ui32RemainingBytes)
   1227e:	f43f af45 	beq.w	1210c <am_hal_uart_transfer+0x4c0>
            am_hal_flash_delay(FLASH_CYCLES_US(1));
   12282:	2001      	movs	r0, #1
   12284:	f7fe feac 	bl	10fe0 <am_hal_flash_delay>
            if (ui32TimeoutMs != AM_HAL_UART_WAIT_FOREVER)
   12288:	f1bb 3fff 	cmp.w	fp, #4294967295
                ui32TimeSpent++;
   1228c:	bf18      	it	ne
   1228e:	3601      	addne	r6, #1
    while (ui32RemainingBytes && (ui32TimeSpent < ui32TimeoutMs))
   12290:	45b3      	cmp	fp, r6
   12292:	f67f af3b 	bls.w	1210c <am_hal_uart_transfer+0x4c0>
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   12296:	f8d8 0000 	ldr.w	r0, [r8]
   1229a:	9a01      	ldr	r2, [sp, #4]
   1229c:	f020 417e 	bic.w	r1, r0, #4261412864	; 0xfe000000
   122a0:	4291      	cmp	r1, r2
        ui32Status = read_nonblocking(pHandle, &pui8Data[i],
   122a2:	eb0a 0905 	add.w	r9, sl, r5
    if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   122a6:	f43f af75 	beq.w	12194 <am_hal_uart_transfer+0x548>
        return AM_HAL_STATUS_INVALID_HANDLE;
   122aa:	f04f 0b02 	mov.w	fp, #2
   122ae:	e5e7      	b.n	11e80 <am_hal_uart_transfer+0x234>
    AM_CRITICAL_BEGIN
   122b0:	f7ff f912 	bl	114d8 <am_hal_interrupt_master_disable>
   122b4:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
   122b8:	9007      	str	r0, [sp, #28]
   122ba:	f502 2080 	add.w	r0, r2, #262144	; 0x40000
   122be:	301c      	adds	r0, #28
    uint32_t i = 0;
   122c0:	f8cd a00c 	str.w	sl, [sp, #12]
   122c4:	0303      	lsls	r3, r0, #12
   122c6:	f10d 0c20 	add.w	ip, sp, #32
   122ca:	2200      	movs	r2, #0
   122cc:	46a2      	mov	sl, r4
        if ( UARTn(ui32Module)->FR_b.RXFE )
   122ce:	699c      	ldr	r4, [r3, #24]
   122d0:	06e1      	lsls	r1, r4, #27
   122d2:	d45a      	bmi.n	1238a <am_hal_uart_transfer+0x73e>
            ui32ReadData = UARTn(ui32Module)->DR;
   122d4:	6818      	ldr	r0, [r3, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   122d6:	f410 6f70 	tst.w	r0, #3840	; 0xf00
   122da:	d17a      	bne.n	123d2 <am_hal_uart_transfer+0x786>
                pui8Data[i++] = ui32ReadData & 0xFF;
   122dc:	46e6      	mov	lr, ip
   122de:	3201      	adds	r2, #1
   122e0:	f80e 0b01 	strb.w	r0, [lr], #1
        if ( UARTn(ui32Module)->FR_b.RXFE )
   122e4:	6999      	ldr	r1, [r3, #24]
   122e6:	06cc      	lsls	r4, r1, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   122e8:	4610      	mov	r0, r2
        if ( UARTn(ui32Module)->FR_b.RXFE )
   122ea:	d44e      	bmi.n	1238a <am_hal_uart_transfer+0x73e>
            ui32ReadData = UARTn(ui32Module)->DR;
   122ec:	681c      	ldr	r4, [r3, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   122ee:	f414 6f70 	tst.w	r4, #3840	; 0xf00
   122f2:	d16e      	bne.n	123d2 <am_hal_uart_transfer+0x786>
                pui8Data[i++] = ui32ReadData & 0xFF;
   122f4:	f88e 4000 	strb.w	r4, [lr]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   122f8:	6999      	ldr	r1, [r3, #24]
   122fa:	06cc      	lsls	r4, r1, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   122fc:	f102 0201 	add.w	r2, r2, #1
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12300:	d443      	bmi.n	1238a <am_hal_uart_transfer+0x73e>
            ui32ReadData = UARTn(ui32Module)->DR;
   12302:	681a      	ldr	r2, [r3, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   12304:	f412 6f70 	tst.w	r2, #3840	; 0xf00
   12308:	d163      	bne.n	123d2 <am_hal_uart_transfer+0x786>
                pui8Data[i++] = ui32ReadData & 0xFF;
   1230a:	f88e 2001 	strb.w	r2, [lr, #1]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   1230e:	699c      	ldr	r4, [r3, #24]
   12310:	06e4      	lsls	r4, r4, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   12312:	f100 0202 	add.w	r2, r0, #2
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12316:	d438      	bmi.n	1238a <am_hal_uart_transfer+0x73e>
            ui32ReadData = UARTn(ui32Module)->DR;
   12318:	6819      	ldr	r1, [r3, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   1231a:	f411 6f70 	tst.w	r1, #3840	; 0xf00
   1231e:	d158      	bne.n	123d2 <am_hal_uart_transfer+0x786>
                pui8Data[i++] = ui32ReadData & 0xFF;
   12320:	f88c 1003 	strb.w	r1, [ip, #3]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12324:	699c      	ldr	r4, [r3, #24]
   12326:	06e4      	lsls	r4, r4, #27
   12328:	f10c 0c04 	add.w	ip, ip, #4
                pui8Data[i++] = ui32ReadData & 0xFF;
   1232c:	f100 0203 	add.w	r2, r0, #3
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12330:	d42b      	bmi.n	1238a <am_hal_uart_transfer+0x73e>
            ui32ReadData = UARTn(ui32Module)->DR;
   12332:	681a      	ldr	r2, [r3, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   12334:	f412 6f70 	tst.w	r2, #3840	; 0xf00
   12338:	d14b      	bne.n	123d2 <am_hal_uart_transfer+0x786>
                pui8Data[i++] = ui32ReadData & 0xFF;
   1233a:	f88c 2000 	strb.w	r2, [ip]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   1233e:	6999      	ldr	r1, [r3, #24]
   12340:	06cc      	lsls	r4, r1, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   12342:	f100 0204 	add.w	r2, r0, #4
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12346:	d420      	bmi.n	1238a <am_hal_uart_transfer+0x73e>
            ui32ReadData = UARTn(ui32Module)->DR;
   12348:	681c      	ldr	r4, [r3, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   1234a:	f414 6f70 	tst.w	r4, #3840	; 0xf00
   1234e:	d140      	bne.n	123d2 <am_hal_uart_transfer+0x786>
                pui8Data[i++] = ui32ReadData & 0xFF;
   12350:	f88e 4004 	strb.w	r4, [lr, #4]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12354:	6999      	ldr	r1, [r3, #24]
   12356:	06cc      	lsls	r4, r1, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   12358:	f100 0205 	add.w	r2, r0, #5
        if ( UARTn(ui32Module)->FR_b.RXFE )
   1235c:	d415      	bmi.n	1238a <am_hal_uart_transfer+0x73e>
            ui32ReadData = UARTn(ui32Module)->DR;
   1235e:	681a      	ldr	r2, [r3, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   12360:	f412 6f70 	tst.w	r2, #3840	; 0xf00
   12364:	d135      	bne.n	123d2 <am_hal_uart_transfer+0x786>
                pui8Data[i++] = ui32ReadData & 0xFF;
   12366:	f88e 2005 	strb.w	r2, [lr, #5]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   1236a:	699c      	ldr	r4, [r3, #24]
   1236c:	06e4      	lsls	r4, r4, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   1236e:	f100 0206 	add.w	r2, r0, #6
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12372:	d40a      	bmi.n	1238a <am_hal_uart_transfer+0x73e>
            ui32ReadData = UARTn(ui32Module)->DR;
   12374:	6819      	ldr	r1, [r3, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   12376:	f411 6f70 	tst.w	r1, #3840	; 0xf00
   1237a:	d12a      	bne.n	123d2 <am_hal_uart_transfer+0x786>
                pui8Data[i++] = ui32ReadData & 0xFF;
   1237c:	1dc2      	adds	r2, r0, #7
    while (i < ui32NumBytes)
   1237e:	2a20      	cmp	r2, #32
                pui8Data[i++] = ui32ReadData & 0xFF;
   12380:	f88e 1006 	strb.w	r1, [lr, #6]
   12384:	f10e 0c07 	add.w	ip, lr, #7
    while (i < ui32NumBytes)
   12388:	d1a1      	bne.n	122ce <am_hal_uart_transfer+0x682>
        if (!am_hal_queue_item_add(&pState->sRxQueue, pui8Data,
   1238a:	a908      	add	r1, sp, #32
   1238c:	9802      	ldr	r0, [sp, #8]
   1238e:	4654      	mov	r4, sl
   12390:	f8dd a00c 	ldr.w	sl, [sp, #12]
   12394:	f000 f91c 	bl	125d0 <am_hal_queue_item_add>
   12398:	b958      	cbnz	r0, 123b2 <am_hal_uart_transfer+0x766>
            ui32ErrorStatus = AM_HAL_UART_STATUS_RX_QUEUE_FULL;
   1239a:	f8df b1b4 	ldr.w	fp, [pc, #436]	; 12550 <am_hal_uart_transfer+0x904>
    AM_CRITICAL_END
   1239e:	9807      	ldr	r0, [sp, #28]
   123a0:	f7ff f89e 	bl	114e0 <am_hal_interrupt_master_set>
   123a4:	e56c      	b.n	11e80 <am_hal_uart_transfer+0x234>
   123a6:	441d      	add	r5, r3
                ui32ErrorStatus =  AM_HAL_UART_STATUS_BUS_ERROR;
   123a8:	f04f 6b00 	mov.w	fp, #134217728	; 0x8000000
   123ac:	e568      	b.n	11e80 <am_hal_uart_transfer+0x234>
    while (ui32RemainingBytes && (ui32TimeSpent < ui32TimeoutMs))
   123ae:	462e      	mov	r6, r5
   123b0:	e52d      	b.n	11e0e <am_hal_uart_transfer+0x1c2>
    AM_CRITICAL_END
   123b2:	9807      	ldr	r0, [sp, #28]
   123b4:	f7ff f894 	bl	114e0 <am_hal_interrupt_master_set>
                                ui32NumBytes : ui32BufferData);
   123b8:	f8d8 3050 	ldr.w	r3, [r8, #80]	; 0x50
        am_hal_queue_item_get(&pState->sRxQueue, pui8Data, ui32BytesTransferred);
   123bc:	9802      	ldr	r0, [sp, #8]
                                ui32NumBytes : ui32BufferData);
   123be:	42a3      	cmp	r3, r4
   123c0:	bf28      	it	cs
   123c2:	4623      	movcs	r3, r4
        am_hal_queue_item_get(&pState->sRxQueue, pui8Data, ui32BytesTransferred);
   123c4:	461a      	mov	r2, r3
   123c6:	4649      	mov	r1, r9
   123c8:	9303      	str	r3, [sp, #12]
   123ca:	f000 fa05 	bl	127d8 <am_hal_queue_item_get>
   123ce:	9b03      	ldr	r3, [sp, #12]
   123d0:	e753      	b.n	1227a <am_hal_uart_transfer+0x62e>
                ui32ErrorStatus =  AM_HAL_UART_STATUS_BUS_ERROR;
   123d2:	f04f 6b00 	mov.w	fp, #134217728	; 0x8000000
   123d6:	e7e2      	b.n	1239e <am_hal_uart_transfer+0x752>
   123d8:	f04f 6b00 	mov.w	fp, #134217728	; 0x8000000
   123dc:	e550      	b.n	11e80 <am_hal_uart_transfer+0x234>
        ui32BufferSpace = am_hal_queue_space_left(&pState->sTxQueue);
   123de:	f8d8 1034 	ldr.w	r1, [r8, #52]	; 0x34
   123e2:	f8d8 2038 	ldr.w	r2, [r8, #56]	; 0x38
   123e6:	1a52      	subs	r2, r2, r1
                                 ui32NumBytes : ui32BufferSpace);
   123e8:	42aa      	cmp	r2, r5
        am_hal_queue_item_add(&pState->sTxQueue, pui8Data, ui32BytesTransferred);
   123ea:	f108 092c 	add.w	r9, r8, #44	; 0x2c
                                 ui32NumBytes : ui32BufferSpace);
   123ee:	bf28      	it	cs
   123f0:	462a      	movcs	r2, r5
        am_hal_queue_item_add(&pState->sTxQueue, pui8Data, ui32BytesTransferred);
   123f2:	9901      	ldr	r1, [sp, #4]
   123f4:	4648      	mov	r0, r9
                                 ui32NumBytes : ui32BufferSpace);
   123f6:	4614      	mov	r4, r2
        am_hal_queue_item_add(&pState->sTxQueue, pui8Data, ui32BytesTransferred);
   123f8:	f000 f8ea 	bl	125d0 <am_hal_queue_item_add>
    uint32_t ui32Module = pState->ui32Module;
   123fc:	f8d8 6024 	ldr.w	r6, [r8, #36]	; 0x24
    AM_CRITICAL_BEGIN
   12400:	f7ff f86a 	bl	114d8 <am_hal_interrupt_master_disable>
   12404:	f506 2380 	add.w	r3, r6, #262144	; 0x40000
   12408:	331c      	adds	r3, #28
   1240a:	031d      	lsls	r5, r3, #12
   1240c:	9005      	str	r0, [sp, #20]
   1240e:	e00e      	b.n	1242e <am_hal_uart_transfer+0x7e2>
        if (am_hal_queue_item_get(&pState->sTxQueue, &pui8Data, 1))
   12410:	f000 f9e2 	bl	127d8 <am_hal_queue_item_get>
   12414:	b190      	cbz	r0, 1243c <am_hal_uart_transfer+0x7f0>
        if ( UARTn(ui32Module)->FR_b.TXFF )
   12416:	f8d8 0024 	ldr.w	r0, [r8, #36]	; 0x24
   1241a:	f500 2280 	add.w	r2, r0, #262144	; 0x40000
   1241e:	321c      	adds	r2, #28
   12420:	0311      	lsls	r1, r2, #12
   12422:	698e      	ldr	r6, [r1, #24]
   12424:	06b3      	lsls	r3, r6, #26
            UARTn(ui32Module)->DR = pui8Data[i++];
   12426:	bf5c      	itt	pl
   12428:	f89d 3020 	ldrbpl.w	r3, [sp, #32]
   1242c:	600b      	strpl	r3, [r1, #0]
    while ( !UARTn(ui32Module)->FR_b.TXFF )
   1242e:	69af      	ldr	r7, [r5, #24]
   12430:	06bf      	lsls	r7, r7, #26
        if (am_hal_queue_item_get(&pState->sTxQueue, &pui8Data, 1))
   12432:	f04f 0201 	mov.w	r2, #1
   12436:	a908      	add	r1, sp, #32
   12438:	4648      	mov	r0, r9
    while ( !UARTn(ui32Module)->FR_b.TXFF )
   1243a:	d5e9      	bpl.n	12410 <am_hal_uart_transfer+0x7c4>
    AM_CRITICAL_END
   1243c:	9805      	ldr	r0, [sp, #20]
   1243e:	f7ff f84f 	bl	114e0 <am_hal_interrupt_master_set>
   12442:	e5d1      	b.n	11fe8 <am_hal_uart_transfer+0x39c>
    AM_CRITICAL_BEGIN
   12444:	f7ff f848 	bl	114d8 <am_hal_interrupt_master_disable>
   12448:	f8d8 1024 	ldr.w	r1, [r8, #36]	; 0x24
   1244c:	9006      	str	r0, [sp, #24]
   1244e:	f501 2080 	add.w	r0, r1, #262144	; 0x40000
   12452:	301c      	adds	r0, #28
   12454:	0301      	lsls	r1, r0, #12
   12456:	ab08      	add	r3, sp, #32
    uint32_t i = 0;
   12458:	2200      	movs	r2, #0
        if ( UARTn(ui32Module)->FR_b.RXFE )
   1245a:	698e      	ldr	r6, [r1, #24]
   1245c:	06f0      	lsls	r0, r6, #27
   1245e:	d455      	bmi.n	1250c <am_hal_uart_transfer+0x8c0>
            ui32ReadData = UARTn(ui32Module)->DR;
   12460:	680d      	ldr	r5, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   12462:	f415 6f70 	tst.w	r5, #3840	; 0xf00
   12466:	d16f      	bne.n	12548 <am_hal_uart_transfer+0x8fc>
                pui8Data[i++] = ui32ReadData & 0xFF;
   12468:	4618      	mov	r0, r3
   1246a:	3201      	adds	r2, #1
   1246c:	f800 5b01 	strb.w	r5, [r0], #1
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12470:	698e      	ldr	r6, [r1, #24]
   12472:	06f6      	lsls	r6, r6, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   12474:	4615      	mov	r5, r2
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12476:	d449      	bmi.n	1250c <am_hal_uart_transfer+0x8c0>
            ui32ReadData = UARTn(ui32Module)->DR;
   12478:	680e      	ldr	r6, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   1247a:	f416 6f70 	tst.w	r6, #3840	; 0xf00
   1247e:	d163      	bne.n	12548 <am_hal_uart_transfer+0x8fc>
                pui8Data[i++] = ui32ReadData & 0xFF;
   12480:	7006      	strb	r6, [r0, #0]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12482:	698e      	ldr	r6, [r1, #24]
   12484:	06f6      	lsls	r6, r6, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   12486:	f102 0201 	add.w	r2, r2, #1
        if ( UARTn(ui32Module)->FR_b.RXFE )
   1248a:	d43f      	bmi.n	1250c <am_hal_uart_transfer+0x8c0>
            ui32ReadData = UARTn(ui32Module)->DR;
   1248c:	680a      	ldr	r2, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   1248e:	f412 6f70 	tst.w	r2, #3840	; 0xf00
   12492:	d159      	bne.n	12548 <am_hal_uart_transfer+0x8fc>
                pui8Data[i++] = ui32ReadData & 0xFF;
   12494:	7042      	strb	r2, [r0, #1]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   12496:	f8d1 e018 	ldr.w	lr, [r1, #24]
   1249a:	f01e 0f10 	tst.w	lr, #16
                pui8Data[i++] = ui32ReadData & 0xFF;
   1249e:	f105 0202 	add.w	r2, r5, #2
        if ( UARTn(ui32Module)->FR_b.RXFE )
   124a2:	d133      	bne.n	1250c <am_hal_uart_transfer+0x8c0>
            ui32ReadData = UARTn(ui32Module)->DR;
   124a4:	680e      	ldr	r6, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   124a6:	f416 6f70 	tst.w	r6, #3840	; 0xf00
   124aa:	d14d      	bne.n	12548 <am_hal_uart_transfer+0x8fc>
                pui8Data[i++] = ui32ReadData & 0xFF;
   124ac:	70de      	strb	r6, [r3, #3]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   124ae:	698e      	ldr	r6, [r1, #24]
   124b0:	06f6      	lsls	r6, r6, #27
   124b2:	f103 0304 	add.w	r3, r3, #4
                pui8Data[i++] = ui32ReadData & 0xFF;
   124b6:	f105 0203 	add.w	r2, r5, #3
        if ( UARTn(ui32Module)->FR_b.RXFE )
   124ba:	d427      	bmi.n	1250c <am_hal_uart_transfer+0x8c0>
            ui32ReadData = UARTn(ui32Module)->DR;
   124bc:	680a      	ldr	r2, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   124be:	f412 6f70 	tst.w	r2, #3840	; 0xf00
   124c2:	d141      	bne.n	12548 <am_hal_uart_transfer+0x8fc>
                pui8Data[i++] = ui32ReadData & 0xFF;
   124c4:	701a      	strb	r2, [r3, #0]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   124c6:	698b      	ldr	r3, [r1, #24]
   124c8:	06db      	lsls	r3, r3, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   124ca:	f105 0204 	add.w	r2, r5, #4
        if ( UARTn(ui32Module)->FR_b.RXFE )
   124ce:	d41d      	bmi.n	1250c <am_hal_uart_transfer+0x8c0>
            ui32ReadData = UARTn(ui32Module)->DR;
   124d0:	680e      	ldr	r6, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   124d2:	f416 6f70 	tst.w	r6, #3840	; 0xf00
   124d6:	d137      	bne.n	12548 <am_hal_uart_transfer+0x8fc>
                pui8Data[i++] = ui32ReadData & 0xFF;
   124d8:	7106      	strb	r6, [r0, #4]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   124da:	698b      	ldr	r3, [r1, #24]
   124dc:	06de      	lsls	r6, r3, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   124de:	f105 0205 	add.w	r2, r5, #5
        if ( UARTn(ui32Module)->FR_b.RXFE )
   124e2:	d413      	bmi.n	1250c <am_hal_uart_transfer+0x8c0>
            ui32ReadData = UARTn(ui32Module)->DR;
   124e4:	680a      	ldr	r2, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   124e6:	f412 6f70 	tst.w	r2, #3840	; 0xf00
   124ea:	d12d      	bne.n	12548 <am_hal_uart_transfer+0x8fc>
                pui8Data[i++] = ui32ReadData & 0xFF;
   124ec:	7142      	strb	r2, [r0, #5]
        if ( UARTn(ui32Module)->FR_b.RXFE )
   124ee:	698e      	ldr	r6, [r1, #24]
   124f0:	06f3      	lsls	r3, r6, #27
                pui8Data[i++] = ui32ReadData & 0xFF;
   124f2:	f105 0206 	add.w	r2, r5, #6
        if ( UARTn(ui32Module)->FR_b.RXFE )
   124f6:	d409      	bmi.n	1250c <am_hal_uart_transfer+0x8c0>
            ui32ReadData = UARTn(ui32Module)->DR;
   124f8:	680b      	ldr	r3, [r1, #0]
            if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
   124fa:	f413 6f70 	tst.w	r3, #3840	; 0xf00
   124fe:	d123      	bne.n	12548 <am_hal_uart_transfer+0x8fc>
                pui8Data[i++] = ui32ReadData & 0xFF;
   12500:	1dea      	adds	r2, r5, #7
    while (i < ui32NumBytes)
   12502:	2a20      	cmp	r2, #32
                pui8Data[i++] = ui32ReadData & 0xFF;
   12504:	7183      	strb	r3, [r0, #6]
   12506:	f100 0307 	add.w	r3, r0, #7
    while (i < ui32NumBytes)
   1250a:	d1a6      	bne.n	1245a <am_hal_uart_transfer+0x80e>
        if (!am_hal_queue_item_add(&pState->sRxQueue, pui8Data,
   1250c:	f108 0a48 	add.w	sl, r8, #72	; 0x48
   12510:	a908      	add	r1, sp, #32
   12512:	4650      	mov	r0, sl
   12514:	f000 f85c 	bl	125d0 <am_hal_queue_item_add>
   12518:	b930      	cbnz	r0, 12528 <am_hal_uart_transfer+0x8dc>
            ui32ErrorStatus = AM_HAL_UART_STATUS_RX_QUEUE_FULL;
   1251a:	f8df b034 	ldr.w	fp, [pc, #52]	; 12550 <am_hal_uart_transfer+0x904>
    AM_CRITICAL_END
   1251e:	9806      	ldr	r0, [sp, #24]
   12520:	f7fe ffde 	bl	114e0 <am_hal_interrupt_master_set>
   12524:	f7ff bb9e 	b.w	11c64 <am_hal_uart_transfer+0x18>
   12528:	9806      	ldr	r0, [sp, #24]
   1252a:	f7fe ffd9 	bl	114e0 <am_hal_interrupt_master_set>
                                ui32NumBytes : ui32BufferData);
   1252e:	f8d8 5050 	ldr.w	r5, [r8, #80]	; 0x50
   12532:	42a5      	cmp	r5, r4
   12534:	bf28      	it	cs
   12536:	4625      	movcs	r5, r4
        am_hal_queue_item_get(&pState->sRxQueue, pui8Data, ui32BytesTransferred);
   12538:	4649      	mov	r1, r9
   1253a:	4650      	mov	r0, sl
   1253c:	462a      	mov	r2, r5
   1253e:	f000 f94b 	bl	127d8 <am_hal_queue_item_get>
   12542:	e49d      	b.n	11e80 <am_hal_uart_transfer+0x234>
    uint32_t i = 0;
   12544:	4605      	mov	r5, r0
   12546:	e49b      	b.n	11e80 <am_hal_uart_transfer+0x234>
                ui32ErrorStatus =  AM_HAL_UART_STATUS_BUS_ERROR;
   12548:	f04f 6b00 	mov.w	fp, #134217728	; 0x8000000
   1254c:	e7e7      	b.n	1251e <am_hal_uart_transfer+0x8d2>
   1254e:	bf00      	nop
   12550:	08000001 	.word	0x08000001

00012554 <am_hal_uart_tx_flush>:
    if (pState->bEnableTxQueue)
   12554:	f890 3028 	ldrb.w	r3, [r0, #40]	; 0x28
{
   12558:	b570      	push	{r4, r5, r6, lr}
   1255a:	4604      	mov	r4, r0
    uint32_t ui32Module = pState->ui32Module;
   1255c:	6a45      	ldr	r5, [r0, #36]	; 0x24
    if (pState->bEnableTxQueue)
   1255e:	b183      	cbz	r3, 12582 <am_hal_uart_tx_flush+0x2e>
        while (am_hal_queue_data_left(&(pState->sTxQueue)))
   12560:	6b40      	ldr	r0, [r0, #52]	; 0x34
   12562:	b170      	cbz	r0, 12582 <am_hal_uart_tx_flush+0x2e>
            ONE_BYTE_DELAY(pState);
   12564:	4e13      	ldr	r6, [pc, #76]	; (125b4 <am_hal_uart_tx_flush+0x60>)
   12566:	6e21      	ldr	r1, [r4, #96]	; 0x60
   12568:	fbb6 f2f1 	udiv	r2, r6, r1
   1256c:	2a02      	cmp	r2, #2
   1256e:	ea4f 1002 	mov.w	r0, r2, lsl #4
   12572:	bf8c      	ite	hi
   12574:	3829      	subhi	r0, #41	; 0x29
   12576:	2001      	movls	r0, #1
   12578:	f7fe fd32 	bl	10fe0 <am_hal_flash_delay>
        while (am_hal_queue_data_left(&(pState->sTxQueue)))
   1257c:	6b63      	ldr	r3, [r4, #52]	; 0x34
   1257e:	2b00      	cmp	r3, #0
   12580:	d1f1      	bne.n	12566 <am_hal_uart_tx_flush+0x12>
    while ( UARTn(ui32Module)->FR_b.BUSY )
   12582:	f505 2580 	add.w	r5, r5, #262144	; 0x40000
   12586:	351c      	adds	r5, #28
   12588:	032d      	lsls	r5, r5, #12
   1258a:	69a8      	ldr	r0, [r5, #24]
   1258c:	0702      	lsls	r2, r0, #28
   1258e:	d50e      	bpl.n	125ae <am_hal_uart_tx_flush+0x5a>
        ONE_BYTE_DELAY(pState);
   12590:	4e08      	ldr	r6, [pc, #32]	; (125b4 <am_hal_uart_tx_flush+0x60>)
   12592:	6e21      	ldr	r1, [r4, #96]	; 0x60
   12594:	fbb6 f2f1 	udiv	r2, r6, r1
   12598:	2a02      	cmp	r2, #2
   1259a:	ea4f 1002 	mov.w	r0, r2, lsl #4
   1259e:	bf8c      	ite	hi
   125a0:	3829      	subhi	r0, #41	; 0x29
   125a2:	2001      	movls	r0, #1
   125a4:	f7fe fd1c 	bl	10fe0 <am_hal_flash_delay>
    while ( UARTn(ui32Module)->FR_b.BUSY )
   125a8:	69ab      	ldr	r3, [r5, #24]
   125aa:	071b      	lsls	r3, r3, #28
   125ac:	d4f1      	bmi.n	12592 <am_hal_uart_tx_flush+0x3e>
} // am_hal_uart_tx_flush()
   125ae:	2000      	movs	r0, #0
   125b0:	bd70      	pop	{r4, r5, r6, pc}
   125b2:	bf00      	nop
   125b4:	00b71b00 	.word	0x00b71b00

000125b8 <am_hal_queue_init>:
//
//*****************************************************************************
void
am_hal_queue_init(am_hal_queue_t *psQueue, void *pvData, uint32_t ui32ItemSize,
                  uint32_t ui32ArraySize)
{
   125b8:	b410      	push	{r4}
    psQueue->ui32WriteIndex = 0;
   125ba:	2400      	movs	r4, #0
   125bc:	6004      	str	r4, [r0, #0]
    psQueue->ui32ReadIndex = 0;
   125be:	6044      	str	r4, [r0, #4]
    psQueue->ui32Length = 0;
   125c0:	6084      	str	r4, [r0, #8]
    psQueue->ui32Capacity = ui32ArraySize;
   125c2:	60c3      	str	r3, [r0, #12]
    psQueue->ui32ItemSize = ui32ItemSize;
   125c4:	6102      	str	r2, [r0, #16]
    psQueue->pui8Data = (uint8_t *) pvData;
   125c6:	6141      	str	r1, [r0, #20]
}
   125c8:	f85d 4b04 	ldr.w	r4, [sp], #4
   125cc:	4770      	bx	lr
   125ce:	bf00      	nop

000125d0 <am_hal_queue_item_add>:
//! didn't have enough space.
//
//*****************************************************************************
bool
am_hal_queue_item_add(am_hal_queue_t *psQueue, const void *pvSource, uint32_t ui32NumItems)
{
   125d0:	b5f0      	push	{r4, r5, r6, r7, lr}
   125d2:	4604      	mov	r4, r0
    uint8_t *pui8Source;
    uint32_t ui32Bytes = ui32NumItems * psQueue->ui32ItemSize;
   125d4:	6905      	ldr	r5, [r0, #16]
{
   125d6:	b083      	sub	sp, #12
    uint32_t ui32Bytes = ui32NumItems * psQueue->ui32ItemSize;
   125d8:	fb05 f502 	mul.w	r5, r5, r2
{
   125dc:	460f      	mov	r7, r1
    bool bSuccess = false;

    pui8Source = (uint8_t *) pvSource;

    AM_CRITICAL_BEGIN
   125de:	f7fe ff7b 	bl	114d8 <am_hal_interrupt_master_disable>

    //
    // Check to make sure that the buffer isn't already full
    //
    if ( am_hal_queue_space_left(psQueue) >= ui32Bytes )
   125e2:	68e3      	ldr	r3, [r4, #12]
   125e4:	68a2      	ldr	r2, [r4, #8]
    AM_CRITICAL_BEGIN
   125e6:	9001      	str	r0, [sp, #4]
    if ( am_hal_queue_space_left(psQueue) >= ui32Bytes )
   125e8:	1a99      	subs	r1, r3, r2
   125ea:	428d      	cmp	r5, r1
   125ec:	f200 8081 	bhi.w	126f2 <am_hal_queue_item_add+0x122>
    {
        //
        // Loop over the bytes in the source array.
        //
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   125f0:	2d00      	cmp	r5, #0
   125f2:	d075      	beq.n	126e0 <am_hal_queue_item_add+0x110>
   125f4:	6826      	ldr	r6, [r4, #0]
   125f6:	2f00      	cmp	r7, #0
   125f8:	d07d      	beq.n	126f6 <am_hal_queue_item_add+0x126>
            // Write the value to the buffer, but only if the source pointer is
            // valid.
            //
            if (pvSource)
            {
                psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
   125fa:	4638      	mov	r0, r7
   125fc:	6963      	ldr	r3, [r4, #20]
   125fe:	f810 2b01 	ldrb.w	r2, [r0], #1
   12602:	559a      	strb	r2, [r3, r6]
            }

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   12604:	6821      	ldr	r1, [r4, #0]
   12606:	f8d4 e00c 	ldr.w	lr, [r4, #12]
   1260a:	1c4a      	adds	r2, r1, #1
   1260c:	197e      	adds	r6, r7, r5
   1260e:	43ff      	mvns	r7, r7
   12610:	fbb2 fcfe 	udiv	ip, r2, lr
   12614:	4437      	add	r7, r6
   12616:	fb0e 231c 	mls	r3, lr, ip, r2
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   1261a:	42b0      	cmp	r0, r6
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   1261c:	6023      	str	r3, [r4, #0]
   1261e:	f007 0103 	and.w	r1, r7, #3
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12622:	d05c      	beq.n	126de <am_hal_queue_item_add+0x10e>
   12624:	b349      	cbz	r1, 1267a <am_hal_queue_item_add+0xaa>
   12626:	2901      	cmp	r1, #1
   12628:	d019      	beq.n	1265e <am_hal_queue_item_add+0x8e>
   1262a:	2902      	cmp	r1, #2
   1262c:	d00b      	beq.n	12646 <am_hal_queue_item_add+0x76>
                psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
   1262e:	6962      	ldr	r2, [r4, #20]
   12630:	f810 7b01 	ldrb.w	r7, [r0], #1
   12634:	54d7      	strb	r7, [r2, r3]
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   12636:	6823      	ldr	r3, [r4, #0]
   12638:	68e1      	ldr	r1, [r4, #12]
   1263a:	1c5a      	adds	r2, r3, #1
   1263c:	fbb2 f7f1 	udiv	r7, r2, r1
   12640:	fb01 2317 	mls	r3, r1, r7, r2
   12644:	6023      	str	r3, [r4, #0]
                psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
   12646:	6962      	ldr	r2, [r4, #20]
   12648:	f810 1b01 	ldrb.w	r1, [r0], #1
   1264c:	54d1      	strb	r1, [r2, r3]
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   1264e:	6823      	ldr	r3, [r4, #0]
   12650:	68e7      	ldr	r7, [r4, #12]
   12652:	1c5a      	adds	r2, r3, #1
   12654:	fbb2 f1f7 	udiv	r1, r2, r7
   12658:	fb07 2311 	mls	r3, r7, r1, r2
   1265c:	6023      	str	r3, [r4, #0]
                psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
   1265e:	6967      	ldr	r7, [r4, #20]
   12660:	f810 2b01 	ldrb.w	r2, [r0], #1
   12664:	54fa      	strb	r2, [r7, r3]
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   12666:	6823      	ldr	r3, [r4, #0]
   12668:	68e1      	ldr	r1, [r4, #12]
   1266a:	1c5f      	adds	r7, r3, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   1266c:	42b0      	cmp	r0, r6
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   1266e:	fbb7 f2f1 	udiv	r2, r7, r1
   12672:	fb01 7312 	mls	r3, r1, r2, r7
   12676:	6023      	str	r3, [r4, #0]
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12678:	d031      	beq.n	126de <am_hal_queue_item_add+0x10e>
                psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
   1267a:	4686      	mov	lr, r0
   1267c:	6967      	ldr	r7, [r4, #20]
   1267e:	f81e 1b01 	ldrb.w	r1, [lr], #1
   12682:	54f9      	strb	r1, [r7, r3]
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   12684:	6823      	ldr	r3, [r4, #0]
   12686:	68e2      	ldr	r2, [r4, #12]
   12688:	1c5f      	adds	r7, r3, #1
   1268a:	fbb7 f1f2 	udiv	r1, r7, r2
   1268e:	fb02 7311 	mls	r3, r2, r1, r7
   12692:	6023      	str	r3, [r4, #0]
                psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
   12694:	6962      	ldr	r2, [r4, #20]
   12696:	7847      	ldrb	r7, [r0, #1]
   12698:	54d7      	strb	r7, [r2, r3]
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   1269a:	6823      	ldr	r3, [r4, #0]
   1269c:	68e1      	ldr	r1, [r4, #12]
   1269e:	1c5f      	adds	r7, r3, #1
   126a0:	fbb7 f2f1 	udiv	r2, r7, r1
   126a4:	fb01 7312 	mls	r3, r1, r2, r7
   126a8:	6023      	str	r3, [r4, #0]
                psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
   126aa:	6961      	ldr	r1, [r4, #20]
   126ac:	f89e 7001 	ldrb.w	r7, [lr, #1]
   126b0:	54cf      	strb	r7, [r1, r3]
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   126b2:	6822      	ldr	r2, [r4, #0]
   126b4:	68e7      	ldr	r7, [r4, #12]
                psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
   126b6:	6961      	ldr	r1, [r4, #20]
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   126b8:	3201      	adds	r2, #1
   126ba:	fbb2 fcf7 	udiv	ip, r2, r7
   126be:	fb07 231c 	mls	r3, r7, ip, r2
   126c2:	6023      	str	r3, [r4, #0]
                psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
   126c4:	78c7      	ldrb	r7, [r0, #3]
   126c6:	54cf      	strb	r7, [r1, r3]
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   126c8:	6822      	ldr	r2, [r4, #0]
   126ca:	68e1      	ldr	r1, [r4, #12]
   126cc:	1c57      	adds	r7, r2, #1
   126ce:	3004      	adds	r0, #4
   126d0:	fbb7 f2f1 	udiv	r2, r7, r1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   126d4:	42b0      	cmp	r0, r6
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   126d6:	fb01 7312 	mls	r3, r1, r2, r7
   126da:	6023      	str	r3, [r4, #0]
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   126dc:	d1cd      	bne.n	1267a <am_hal_queue_item_add+0xaa>
   126de:	68a2      	ldr	r2, [r4, #8]
        }

        //
        // Update the length value appropriately.
        //
        psQueue->ui32Length += ui32Bytes;
   126e0:	442a      	add	r2, r5
   126e2:	60a2      	str	r2, [r4, #8]

        //
        // Report a success.
        //
        bSuccess = true;
   126e4:	2401      	movs	r4, #1
        // failure.
        //
        bSuccess = false;
    }

    AM_CRITICAL_END
   126e6:	9801      	ldr	r0, [sp, #4]
   126e8:	f7fe fefa 	bl	114e0 <am_hal_interrupt_master_set>

    return bSuccess;
}
   126ec:	4620      	mov	r0, r4
   126ee:	b003      	add	sp, #12
   126f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
        bSuccess = false;
   126f2:	2400      	movs	r4, #0
   126f4:	e7f7      	b.n	126e6 <am_hal_queue_item_add+0x116>
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   126f6:	1c70      	adds	r0, r6, #1
   126f8:	fbb0 fef3 	udiv	lr, r0, r3
   126fc:	fb03 011e 	mls	r1, r3, lr, r0
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12700:	2001      	movs	r0, #1
   12702:	1e6e      	subs	r6, r5, #1
   12704:	4285      	cmp	r5, r0
   12706:	f006 0707 	and.w	r7, r6, #7
   1270a:	d063      	beq.n	127d4 <am_hal_queue_item_add+0x204>
   1270c:	b3bf      	cbz	r7, 1277e <am_hal_queue_item_add+0x1ae>
   1270e:	2f01      	cmp	r7, #1
   12710:	d02d      	beq.n	1276e <am_hal_queue_item_add+0x19e>
   12712:	2f02      	cmp	r7, #2
   12714:	d025      	beq.n	12762 <am_hal_queue_item_add+0x192>
   12716:	2f03      	cmp	r7, #3
   12718:	d01d      	beq.n	12756 <am_hal_queue_item_add+0x186>
   1271a:	2f04      	cmp	r7, #4
   1271c:	d015      	beq.n	1274a <am_hal_queue_item_add+0x17a>
   1271e:	2f05      	cmp	r7, #5
   12720:	d00d      	beq.n	1273e <am_hal_queue_item_add+0x16e>
   12722:	2f06      	cmp	r7, #6
   12724:	d005      	beq.n	12732 <am_hal_queue_item_add+0x162>
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   12726:	3101      	adds	r1, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12728:	2002      	movs	r0, #2
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   1272a:	fbb1 fcf3 	udiv	ip, r1, r3
   1272e:	fb03 111c 	mls	r1, r3, ip, r1
   12732:	3101      	adds	r1, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12734:	3001      	adds	r0, #1
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   12736:	fbb1 f6f3 	udiv	r6, r1, r3
   1273a:	fb03 1116 	mls	r1, r3, r6, r1
   1273e:	3101      	adds	r1, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12740:	3001      	adds	r0, #1
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   12742:	fbb1 f7f3 	udiv	r7, r1, r3
   12746:	fb03 1117 	mls	r1, r3, r7, r1
   1274a:	3101      	adds	r1, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   1274c:	3001      	adds	r0, #1
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   1274e:	fbb1 fef3 	udiv	lr, r1, r3
   12752:	fb03 111e 	mls	r1, r3, lr, r1
   12756:	3101      	adds	r1, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12758:	3001      	adds	r0, #1
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   1275a:	fbb1 fcf3 	udiv	ip, r1, r3
   1275e:	fb03 111c 	mls	r1, r3, ip, r1
   12762:	3101      	adds	r1, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12764:	3001      	adds	r0, #1
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   12766:	fbb1 f6f3 	udiv	r6, r1, r3
   1276a:	fb03 1116 	mls	r1, r3, r6, r1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   1276e:	3001      	adds	r0, #1
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   12770:	3101      	adds	r1, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12772:	4285      	cmp	r5, r0
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   12774:	fbb1 f7f3 	udiv	r7, r1, r3
   12778:	fb03 1117 	mls	r1, r3, r7, r1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   1277c:	d02a      	beq.n	127d4 <am_hal_queue_item_add+0x204>
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   1277e:	3101      	adds	r1, #1
   12780:	fbb1 fef3 	udiv	lr, r1, r3
   12784:	fb03 161e 	mls	r6, r3, lr, r1
   12788:	1c77      	adds	r7, r6, #1
   1278a:	fbb7 fcf3 	udiv	ip, r7, r3
   1278e:	fb03 711c 	mls	r1, r3, ip, r7
   12792:	1c4e      	adds	r6, r1, #1
   12794:	fbb6 f7f3 	udiv	r7, r6, r3
   12798:	fb03 6117 	mls	r1, r3, r7, r6
   1279c:	1c4e      	adds	r6, r1, #1
   1279e:	fbb6 f7f3 	udiv	r7, r6, r3
   127a2:	fb03 6117 	mls	r1, r3, r7, r6
   127a6:	1c4e      	adds	r6, r1, #1
   127a8:	fbb6 f7f3 	udiv	r7, r6, r3
   127ac:	fb03 6117 	mls	r1, r3, r7, r6
   127b0:	1c4e      	adds	r6, r1, #1
   127b2:	fbb6 f7f3 	udiv	r7, r6, r3
   127b6:	fb03 6117 	mls	r1, r3, r7, r6
   127ba:	1c4e      	adds	r6, r1, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   127bc:	3008      	adds	r0, #8
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   127be:	fbb6 f7f3 	udiv	r7, r6, r3
   127c2:	fb03 6117 	mls	r1, r3, r7, r6
   127c6:	1c4e      	adds	r6, r1, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   127c8:	4285      	cmp	r5, r0
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
   127ca:	fbb6 f7f3 	udiv	r7, r6, r3
   127ce:	fb03 6117 	mls	r1, r3, r7, r6
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   127d2:	d1d4      	bne.n	1277e <am_hal_queue_item_add+0x1ae>
   127d4:	6021      	str	r1, [r4, #0]
   127d6:	e783      	b.n	126e0 <am_hal_queue_item_add+0x110>

000127d8 <am_hal_queue_item_get>:
//! queue, or false if the queue didn't have that many items to pull.
//
//*****************************************************************************
bool
am_hal_queue_item_get(am_hal_queue_t *psQueue, void *pvDest, uint32_t ui32NumItems)
{
   127d8:	b5f0      	push	{r4, r5, r6, r7, lr}
   127da:	4604      	mov	r4, r0
    uint8_t *pui8Dest;
    uint32_t ui32Bytes = ui32NumItems * psQueue->ui32ItemSize;
   127dc:	6905      	ldr	r5, [r0, #16]
{
   127de:	b083      	sub	sp, #12
    uint32_t ui32Bytes = ui32NumItems * psQueue->ui32ItemSize;
   127e0:	fb05 f502 	mul.w	r5, r5, r2
{
   127e4:	460e      	mov	r6, r1
    bool bSuccess = false;

    pui8Dest = (uint8_t *) pvDest;

    AM_CRITICAL_BEGIN
   127e6:	f7fe fe77 	bl	114d8 <am_hal_interrupt_master_disable>

    //
    // Check to make sure that the buffer isn't empty
    //
    if ( am_hal_queue_data_left(psQueue) >= ui32Bytes )
   127ea:	68a7      	ldr	r7, [r4, #8]
    AM_CRITICAL_BEGIN
   127ec:	9001      	str	r0, [sp, #4]
    if ( am_hal_queue_data_left(psQueue) >= ui32Bytes )
   127ee:	42bd      	cmp	r5, r7
   127f0:	f200 8083 	bhi.w	128fa <am_hal_queue_item_get+0x122>
    {
        //
        // Loop over the bytes in the destination array.
        //
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   127f4:	2d00      	cmp	r5, #0
   127f6:	d077      	beq.n	128e8 <am_hal_queue_item_get+0x110>
   127f8:	6863      	ldr	r3, [r4, #4]
   127fa:	2e00      	cmp	r6, #0
   127fc:	d07f      	beq.n	128fe <am_hal_queue_item_get+0x126>
            // Grab the next value from the buffer, but only if the
            // destination pointer is valid.
            //
            if (pvDest)
            {
                pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
   127fe:	6962      	ldr	r2, [r4, #20]
   12800:	4630      	mov	r0, r6
   12802:	5cd1      	ldrb	r1, [r2, r3]
   12804:	f800 1b01 	strb.w	r1, [r0], #1
            }

            //
            // Advance the read index, wrapping if needed.
            //
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12808:	6863      	ldr	r3, [r4, #4]
   1280a:	68e7      	ldr	r7, [r4, #12]
   1280c:	1c5a      	adds	r2, r3, #1
   1280e:	1971      	adds	r1, r6, r5
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12810:	4281      	cmp	r1, r0
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12812:	fbb2 f6f7 	udiv	r6, r2, r7
   12816:	fb07 2316 	mls	r3, r7, r6, r2
   1281a:	f105 37ff 	add.w	r7, r5, #4294967295
   1281e:	6063      	str	r3, [r4, #4]
   12820:	f007 0203 	and.w	r2, r7, #3
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12824:	d05f      	beq.n	128e6 <am_hal_queue_item_get+0x10e>
   12826:	b362      	cbz	r2, 12882 <am_hal_queue_item_get+0xaa>
   12828:	2a01      	cmp	r2, #1
   1282a:	d01b      	beq.n	12864 <am_hal_queue_item_get+0x8c>
   1282c:	2a02      	cmp	r2, #2
   1282e:	d00c      	beq.n	1284a <am_hal_queue_item_get+0x72>
                pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
   12830:	6966      	ldr	r6, [r4, #20]
   12832:	f816 c003 	ldrb.w	ip, [r6, r3]
   12836:	f800 cb01 	strb.w	ip, [r0], #1
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   1283a:	6863      	ldr	r3, [r4, #4]
   1283c:	68e7      	ldr	r7, [r4, #12]
   1283e:	1c5a      	adds	r2, r3, #1
   12840:	fbb2 f6f7 	udiv	r6, r2, r7
   12844:	fb07 2316 	mls	r3, r7, r6, r2
   12848:	6063      	str	r3, [r4, #4]
                pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
   1284a:	6967      	ldr	r7, [r4, #20]
   1284c:	f817 e003 	ldrb.w	lr, [r7, r3]
   12850:	f800 eb01 	strb.w	lr, [r0], #1
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12854:	6863      	ldr	r3, [r4, #4]
   12856:	68e6      	ldr	r6, [r4, #12]
   12858:	1c5a      	adds	r2, r3, #1
   1285a:	fbb2 f7f6 	udiv	r7, r2, r6
   1285e:	fb06 2317 	mls	r3, r6, r7, r2
   12862:	6063      	str	r3, [r4, #4]
                pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
   12864:	6966      	ldr	r6, [r4, #20]
   12866:	f816 c003 	ldrb.w	ip, [r6, r3]
   1286a:	f800 cb01 	strb.w	ip, [r0], #1
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   1286e:	6863      	ldr	r3, [r4, #4]
   12870:	68e7      	ldr	r7, [r4, #12]
   12872:	1c5a      	adds	r2, r3, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12874:	4281      	cmp	r1, r0
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12876:	fbb2 f6f7 	udiv	r6, r2, r7
   1287a:	fb07 2316 	mls	r3, r7, r6, r2
   1287e:	6063      	str	r3, [r4, #4]
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12880:	d031      	beq.n	128e6 <am_hal_queue_item_get+0x10e>
                pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
   12882:	6962      	ldr	r2, [r4, #20]
   12884:	4686      	mov	lr, r0
   12886:	5cd6      	ldrb	r6, [r2, r3]
   12888:	f80e 6b01 	strb.w	r6, [lr], #1
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   1288c:	6863      	ldr	r3, [r4, #4]
   1288e:	68e7      	ldr	r7, [r4, #12]
   12890:	1c5a      	adds	r2, r3, #1
   12892:	fbb2 f6f7 	udiv	r6, r2, r7
   12896:	fb07 2316 	mls	r3, r7, r6, r2
                pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
   1289a:	6967      	ldr	r7, [r4, #20]
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   1289c:	6063      	str	r3, [r4, #4]
                pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
   1289e:	5cfa      	ldrb	r2, [r7, r3]
   128a0:	7042      	strb	r2, [r0, #1]
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   128a2:	6863      	ldr	r3, [r4, #4]
   128a4:	68e6      	ldr	r6, [r4, #12]
   128a6:	1c5f      	adds	r7, r3, #1
   128a8:	fbb7 f2f6 	udiv	r2, r7, r6
   128ac:	fb06 7312 	mls	r3, r6, r2, r7
                pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
   128b0:	6966      	ldr	r6, [r4, #20]
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   128b2:	6063      	str	r3, [r4, #4]
                pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
   128b4:	5cf7      	ldrb	r7, [r6, r3]
   128b6:	f88e 7001 	strb.w	r7, [lr, #1]
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   128ba:	6862      	ldr	r2, [r4, #4]
   128bc:	68e7      	ldr	r7, [r4, #12]
                pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
   128be:	6966      	ldr	r6, [r4, #20]
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   128c0:	3201      	adds	r2, #1
   128c2:	fbb2 fcf7 	udiv	ip, r2, r7
   128c6:	fb07 231c 	mls	r3, r7, ip, r2
   128ca:	6063      	str	r3, [r4, #4]
                pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
   128cc:	5cf7      	ldrb	r7, [r6, r3]
   128ce:	70c7      	strb	r7, [r0, #3]
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   128d0:	6866      	ldr	r6, [r4, #4]
   128d2:	68e7      	ldr	r7, [r4, #12]
   128d4:	1c72      	adds	r2, r6, #1
   128d6:	3004      	adds	r0, #4
   128d8:	fbb2 f6f7 	udiv	r6, r2, r7
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   128dc:	4281      	cmp	r1, r0
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   128de:	fb07 2316 	mls	r3, r7, r6, r2
   128e2:	6063      	str	r3, [r4, #4]
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   128e4:	d1cd      	bne.n	12882 <am_hal_queue_item_get+0xaa>
   128e6:	68a7      	ldr	r7, [r4, #8]
        }

        //
        // Adjust the length value to reflect the change.
        //
        psQueue->ui32Length -= ui32Bytes;
   128e8:	1b7f      	subs	r7, r7, r5
   128ea:	60a7      	str	r7, [r4, #8]

        //
        // Report a success.
        //
        bSuccess = true;
   128ec:	2401      	movs	r4, #1
        // If the buffer didn't have enough data, just return false.
        //
        bSuccess = false;
    }

    AM_CRITICAL_END
   128ee:	9801      	ldr	r0, [sp, #4]
   128f0:	f7fe fdf6 	bl	114e0 <am_hal_interrupt_master_set>

    return bSuccess;
}
   128f4:	4620      	mov	r0, r4
   128f6:	b003      	add	sp, #12
   128f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
        bSuccess = false;
   128fa:	2400      	movs	r4, #0
   128fc:	e7f7      	b.n	128ee <am_hal_queue_item_get+0x116>
   128fe:	68e1      	ldr	r1, [r4, #12]
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12900:	1c58      	adds	r0, r3, #1
   12902:	fbb0 fef1 	udiv	lr, r0, r1
   12906:	fb01 031e 	mls	r3, r1, lr, r0
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   1290a:	2001      	movs	r0, #1
   1290c:	1e6a      	subs	r2, r5, #1
   1290e:	4285      	cmp	r5, r0
   12910:	f002 0607 	and.w	r6, r2, #7
   12914:	d063      	beq.n	129de <am_hal_queue_item_get+0x206>
   12916:	b3be      	cbz	r6, 12988 <am_hal_queue_item_get+0x1b0>
   12918:	2e01      	cmp	r6, #1
   1291a:	d02d      	beq.n	12978 <am_hal_queue_item_get+0x1a0>
   1291c:	2e02      	cmp	r6, #2
   1291e:	d025      	beq.n	1296c <am_hal_queue_item_get+0x194>
   12920:	2e03      	cmp	r6, #3
   12922:	d01d      	beq.n	12960 <am_hal_queue_item_get+0x188>
   12924:	2e04      	cmp	r6, #4
   12926:	d015      	beq.n	12954 <am_hal_queue_item_get+0x17c>
   12928:	2e05      	cmp	r6, #5
   1292a:	d00d      	beq.n	12948 <am_hal_queue_item_get+0x170>
   1292c:	2e06      	cmp	r6, #6
   1292e:	d005      	beq.n	1293c <am_hal_queue_item_get+0x164>
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12930:	3301      	adds	r3, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12932:	2002      	movs	r0, #2
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12934:	fbb3 f2f1 	udiv	r2, r3, r1
   12938:	fb01 3312 	mls	r3, r1, r2, r3
   1293c:	3301      	adds	r3, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   1293e:	3001      	adds	r0, #1
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12940:	fbb3 fcf1 	udiv	ip, r3, r1
   12944:	fb01 331c 	mls	r3, r1, ip, r3
   12948:	3301      	adds	r3, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   1294a:	3001      	adds	r0, #1
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   1294c:	fbb3 fef1 	udiv	lr, r3, r1
   12950:	fb01 331e 	mls	r3, r1, lr, r3
   12954:	3301      	adds	r3, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12956:	3001      	adds	r0, #1
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12958:	fbb3 f6f1 	udiv	r6, r3, r1
   1295c:	fb01 3316 	mls	r3, r1, r6, r3
   12960:	3301      	adds	r3, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12962:	3001      	adds	r0, #1
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12964:	fbb3 f2f1 	udiv	r2, r3, r1
   12968:	fb01 3312 	mls	r3, r1, r2, r3
   1296c:	3301      	adds	r3, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   1296e:	3001      	adds	r0, #1
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12970:	fbb3 fcf1 	udiv	ip, r3, r1
   12974:	fb01 331c 	mls	r3, r1, ip, r3
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12978:	3001      	adds	r0, #1
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   1297a:	3301      	adds	r3, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   1297c:	4285      	cmp	r5, r0
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   1297e:	fbb3 fef1 	udiv	lr, r3, r1
   12982:	fb01 331e 	mls	r3, r1, lr, r3
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   12986:	d02a      	beq.n	129de <am_hal_queue_item_get+0x206>
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   12988:	3301      	adds	r3, #1
   1298a:	fbb3 f6f1 	udiv	r6, r3, r1
   1298e:	fb01 3216 	mls	r2, r1, r6, r3
   12992:	1c56      	adds	r6, r2, #1
   12994:	fbb6 fcf1 	udiv	ip, r6, r1
   12998:	fb01 631c 	mls	r3, r1, ip, r6
   1299c:	1c5a      	adds	r2, r3, #1
   1299e:	fbb2 f6f1 	udiv	r6, r2, r1
   129a2:	fb01 2316 	mls	r3, r1, r6, r2
   129a6:	1c5a      	adds	r2, r3, #1
   129a8:	fbb2 f6f1 	udiv	r6, r2, r1
   129ac:	fb01 2316 	mls	r3, r1, r6, r2
   129b0:	1c5a      	adds	r2, r3, #1
   129b2:	fbb2 f6f1 	udiv	r6, r2, r1
   129b6:	fb01 2316 	mls	r3, r1, r6, r2
   129ba:	1c5a      	adds	r2, r3, #1
   129bc:	fbb2 f6f1 	udiv	r6, r2, r1
   129c0:	fb01 2316 	mls	r3, r1, r6, r2
   129c4:	1c5a      	adds	r2, r3, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   129c6:	3008      	adds	r0, #8
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   129c8:	fbb2 f6f1 	udiv	r6, r2, r1
   129cc:	fb01 2316 	mls	r3, r1, r6, r2
   129d0:	1c5a      	adds	r2, r3, #1
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   129d2:	4285      	cmp	r5, r0
            psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
   129d4:	fbb2 f6f1 	udiv	r6, r2, r1
   129d8:	fb01 2316 	mls	r3, r1, r6, r2
        for ( uint32_t i = 0; i < ui32Bytes; i++ )
   129dc:	d1d4      	bne.n	12988 <am_hal_queue_item_get+0x1b0>
   129de:	6063      	str	r3, [r4, #4]
   129e0:	e782      	b.n	128e8 <am_hal_queue_item_get+0x110>
   129e2:	bf00      	nop

000129e4 <memset>:
   129e4:	4402      	add	r2, r0
   129e6:	4603      	mov	r3, r0
   129e8:	4293      	cmp	r3, r2
   129ea:	d100      	bne.n	129ee <memset+0xa>
   129ec:	4770      	bx	lr
   129ee:	f803 1b01 	strb.w	r1, [r3], #1
   129f2:	e7f9      	b.n	129e8 <memset+0x4>
   129f4:	00000104 	.word	0x00000104
   129f8:	70206b36 	.word	0x70206b36
   129fc:	6f667265 	.word	0x6f667265
   12a00:	6e616d72 	.word	0x6e616d72
   12a04:	72206563 	.word	0x72206563
   12a08:	70206e75 	.word	0x70206e75
   12a0c:	6d617261 	.word	0x6d617261
   12a10:	72657465 	.word	0x72657465
   12a14:	6f662073 	.word	0x6f662073
   12a18:	6f632072 	.word	0x6f632072
   12a1c:	616d6572 	.word	0x616d6572
   12a20:	0a2e6b72 	.word	0x0a2e6b72
   12a24:	00000000 	.word	0x00000000
   12a28:	76206b36 	.word	0x76206b36
   12a2c:	64696c61 	.word	0x64696c61
   12a30:	6f697461 	.word	0x6f697461
   12a34:	7572206e 	.word	0x7572206e
   12a38:	6170206e 	.word	0x6170206e
   12a3c:	656d6172 	.word	0x656d6172
   12a40:	73726574 	.word	0x73726574
   12a44:	726f6620 	.word	0x726f6620
   12a48:	726f6320 	.word	0x726f6320
   12a4c:	72616d65 	.word	0x72616d65
   12a50:	000a2e6b 	.word	0x000a2e6b
   12a54:	666f7250 	.word	0x666f7250
   12a58:	20656c69 	.word	0x20656c69
   12a5c:	656e6567 	.word	0x656e6567
   12a60:	69746172 	.word	0x69746172
   12a64:	72206e6f 	.word	0x72206e6f
   12a68:	70206e75 	.word	0x70206e75
   12a6c:	6d617261 	.word	0x6d617261
   12a70:	72657465 	.word	0x72657465
   12a74:	6f662073 	.word	0x6f662073
   12a78:	6f632072 	.word	0x6f632072
   12a7c:	616d6572 	.word	0x616d6572
   12a80:	0a2e6b72 	.word	0x0a2e6b72
   12a84:	00000000 	.word	0x00000000
   12a88:	70204b32 	.word	0x70204b32
   12a8c:	6f667265 	.word	0x6f667265
   12a90:	6e616d72 	.word	0x6e616d72
   12a94:	72206563 	.word	0x72206563
   12a98:	70206e75 	.word	0x70206e75
   12a9c:	6d617261 	.word	0x6d617261
   12aa0:	72657465 	.word	0x72657465
   12aa4:	6f662073 	.word	0x6f662073
   12aa8:	6f632072 	.word	0x6f632072
   12aac:	616d6572 	.word	0x616d6572
   12ab0:	0a2e6b72 	.word	0x0a2e6b72
   12ab4:	00000000 	.word	0x00000000
   12ab8:	76204b32 	.word	0x76204b32
   12abc:	64696c61 	.word	0x64696c61
   12ac0:	6f697461 	.word	0x6f697461
   12ac4:	7572206e 	.word	0x7572206e
   12ac8:	6170206e 	.word	0x6170206e
   12acc:	656d6172 	.word	0x656d6172
   12ad0:	73726574 	.word	0x73726574
   12ad4:	726f6620 	.word	0x726f6620
   12ad8:	726f6320 	.word	0x726f6320
   12adc:	72616d65 	.word	0x72616d65
   12ae0:	000a2e6b 	.word	0x000a2e6b
   12ae4:	5d75255b 	.word	0x5d75255b
   12ae8:	4f525245 	.word	0x4f525245
   12aec:	6c202152 	.word	0x6c202152
   12af0:	20747369 	.word	0x20747369
   12af4:	20637263 	.word	0x20637263
   12af8:	30257830 	.word	0x30257830
   12afc:	2d207834 	.word	0x2d207834
   12b00:	6f687320 	.word	0x6f687320
   12b04:	20646c75 	.word	0x20646c75
   12b08:	30206562 	.word	0x30206562
   12b0c:	34302578 	.word	0x34302578
   12b10:	00000a78 	.word	0x00000a78
   12b14:	5d75255b 	.word	0x5d75255b
   12b18:	4f525245 	.word	0x4f525245
   12b1c:	6d202152 	.word	0x6d202152
   12b20:	69727461 	.word	0x69727461
   12b24:	72632078 	.word	0x72632078
   12b28:	78302063 	.word	0x78302063
   12b2c:	78343025 	.word	0x78343025
   12b30:	73202d20 	.word	0x73202d20
   12b34:	6c756f68 	.word	0x6c756f68
   12b38:	65622064 	.word	0x65622064
   12b3c:	25783020 	.word	0x25783020
   12b40:	0a783430 	.word	0x0a783430
   12b44:	00000000 	.word	0x00000000
   12b48:	5d75255b 	.word	0x5d75255b
   12b4c:	4f525245 	.word	0x4f525245
   12b50:	73202152 	.word	0x73202152
   12b54:	65746174 	.word	0x65746174
   12b58:	63726320 	.word	0x63726320
   12b5c:	25783020 	.word	0x25783020
   12b60:	20783430 	.word	0x20783430
   12b64:	6873202d 	.word	0x6873202d
   12b68:	646c756f 	.word	0x646c756f
   12b6c:	20656220 	.word	0x20656220
   12b70:	30257830 	.word	0x30257830
   12b74:	000a7834 	.word	0x000a7834
   12b78:	65726f43 	.word	0x65726f43
   12b7c:	6b72614d 	.word	0x6b72614d
   12b80:	7a695320 	.word	0x7a695320
   12b84:	20202065 	.word	0x20202065
   12b88:	25203a20 	.word	0x25203a20
   12b8c:	000a756c 	.word	0x000a756c
   12b90:	61746f54 	.word	0x61746f54
   12b94:	6974206c 	.word	0x6974206c
   12b98:	20736b63 	.word	0x20736b63
   12b9c:	20202020 	.word	0x20202020
   12ba0:	25203a20 	.word	0x25203a20
   12ba4:	0a756c6c 	.word	0x0a756c6c
   12ba8:	00000000 	.word	0x00000000
   12bac:	61746f54 	.word	0x61746f54
   12bb0:	6974206c 	.word	0x6974206c
   12bb4:	2820656d 	.word	0x2820656d
   12bb8:	73636573 	.word	0x73636573
   12bbc:	25203a29 	.word	0x25203a29
   12bc0:	00000a66 	.word	0x00000a66
   12bc4:	72657449 	.word	0x72657449
   12bc8:	6f697461 	.word	0x6f697461
   12bcc:	532f736e 	.word	0x532f736e
   12bd0:	20206365 	.word	0x20206365
   12bd4:	25203a20 	.word	0x25203a20
   12bd8:	00000a66 	.word	0x00000a66
   12bdc:	4f525245 	.word	0x4f525245
   12be0:	4d202152 	.word	0x4d202152
   12be4:	20747375 	.word	0x20747375
   12be8:	63657865 	.word	0x63657865
   12bec:	20657475 	.word	0x20657475
   12bf0:	20726f66 	.word	0x20726f66
   12bf4:	6c207461 	.word	0x6c207461
   12bf8:	74736165 	.word	0x74736165
   12bfc:	20303120 	.word	0x20303120
   12c00:	73636573 	.word	0x73636573
   12c04:	726f6620 	.word	0x726f6620
   12c08:	76206120 	.word	0x76206120
   12c0c:	64696c61 	.word	0x64696c61
   12c10:	73657220 	.word	0x73657220
   12c14:	21746c75 	.word	0x21746c75
   12c18:	0000000a 	.word	0x0000000a
   12c1c:	72657449 	.word	0x72657449
   12c20:	6f697461 	.word	0x6f697461
   12c24:	2020736e 	.word	0x2020736e
   12c28:	20202020 	.word	0x20202020
   12c2c:	25203a20 	.word	0x25203a20
   12c30:	000a756c 	.word	0x000a756c
   12c34:	20434347 	.word	0x20434347
   12c38:	2e332e36 	.word	0x2e332e36
   12c3c:	30322031 	.word	0x30322031
   12c40:	32303731 	.word	0x32303731
   12c44:	28203531 	.word	0x28203531
   12c48:	656c6572 	.word	0x656c6572
   12c4c:	29657361 	.word	0x29657361
   12c50:	52415b20 	.word	0x52415b20
   12c54:	6d652f4d 	.word	0x6d652f4d
   12c58:	64646562 	.word	0x64646562
   12c5c:	362d6465 	.word	0x362d6465
   12c60:	6172622d 	.word	0x6172622d
   12c64:	2068636e 	.word	0x2068636e
   12c68:	69766572 	.word	0x69766572
   12c6c:	6e6f6973 	.word	0x6e6f6973
   12c70:	35343220 	.word	0x35343220
   12c74:	5d323135 	.word	0x5d323135
   12c78:	00000000 	.word	0x00000000
   12c7c:	706d6f43 	.word	0x706d6f43
   12c80:	72656c69 	.word	0x72656c69
   12c84:	72657620 	.word	0x72657620
   12c88:	6e6f6973 	.word	0x6e6f6973
   12c8c:	25203a20 	.word	0x25203a20
   12c90:	00000a73 	.word	0x00000a73
   12c94:	43415453 	.word	0x43415453
   12c98:	0000004b 	.word	0x0000004b
   12c9c:	6f6d654d 	.word	0x6f6d654d
   12ca0:	6c207972 	.word	0x6c207972
   12ca4:	7461636f 	.word	0x7461636f
   12ca8:	206e6f69 	.word	0x206e6f69
   12cac:	25203a20 	.word	0x25203a20
   12cb0:	00000a73 	.word	0x00000a73
   12cb4:	64656573 	.word	0x64656573
   12cb8:	20637263 	.word	0x20637263
   12cbc:	20202020 	.word	0x20202020
   12cc0:	20202020 	.word	0x20202020
   12cc4:	30203a20 	.word	0x30203a20
   12cc8:	34302578 	.word	0x34302578
   12ccc:	00000a78 	.word	0x00000a78
   12cd0:	5d64255b 	.word	0x5d64255b
   12cd4:	6c637263 	.word	0x6c637263
   12cd8:	20747369 	.word	0x20747369
   12cdc:	20202020 	.word	0x20202020
   12ce0:	203a2020 	.word	0x203a2020
   12ce4:	30257830 	.word	0x30257830
   12ce8:	000a7834 	.word	0x000a7834
   12cec:	5d64255b 	.word	0x5d64255b
   12cf0:	6d637263 	.word	0x6d637263
   12cf4:	69727461 	.word	0x69727461
   12cf8:	20202078 	.word	0x20202078
   12cfc:	203a2020 	.word	0x203a2020
   12d00:	30257830 	.word	0x30257830
   12d04:	000a7834 	.word	0x000a7834
   12d08:	5d64255b 	.word	0x5d64255b
   12d0c:	73637263 	.word	0x73637263
   12d10:	65746174 	.word	0x65746174
   12d14:	20202020 	.word	0x20202020
   12d18:	203a2020 	.word	0x203a2020
   12d1c:	30257830 	.word	0x30257830
   12d20:	000a7834 	.word	0x000a7834
   12d24:	5d64255b 	.word	0x5d64255b
   12d28:	66637263 	.word	0x66637263
   12d2c:	6c616e69 	.word	0x6c616e69
   12d30:	20202020 	.word	0x20202020
   12d34:	203a2020 	.word	0x203a2020
   12d38:	30257830 	.word	0x30257830
   12d3c:	000a7834 	.word	0x000a7834
   12d40:	72726f43 	.word	0x72726f43
   12d44:	20746365 	.word	0x20746365
   12d48:	7265706f 	.word	0x7265706f
   12d4c:	6f697461 	.word	0x6f697461
   12d50:	6176206e 	.word	0x6176206e
   12d54:	6164696c 	.word	0x6164696c
   12d58:	2e646574 	.word	0x2e646574
   12d5c:	65655320 	.word	0x65655320
   12d60:	61657220 	.word	0x61657220
   12d64:	2e656d64 	.word	0x2e656d64
   12d68:	20747874 	.word	0x20747874
   12d6c:	20726f66 	.word	0x20726f66
   12d70:	206e7572 	.word	0x206e7572
   12d74:	20646e61 	.word	0x20646e61
   12d78:	6f706572 	.word	0x6f706572
   12d7c:	6e697472 	.word	0x6e697472
   12d80:	75722067 	.word	0x75722067
   12d84:	2e73656c 	.word	0x2e73656c
   12d88:	0000000a 	.word	0x0000000a
   12d8c:	65726f43 	.word	0x65726f43
   12d90:	6b72614d 	.word	0x6b72614d
   12d94:	302e3120 	.word	0x302e3120
   12d98:	25203a20 	.word	0x25203a20
   12d9c:	202f2066 	.word	0x202f2066
   12da0:	25207325 	.word	0x25207325
   12da4:	00000073 	.word	0x00000073
   12da8:	67616c66 	.word	0x67616c66
   12dac:	2d203a73 	.word	0x2d203a73
   12db0:	0000336f 	.word	0x0000336f
   12db4:	25202f20 	.word	0x25202f20
   12db8:	00000073 	.word	0x00000073
   12dbc:	6f727245 	.word	0x6f727245
   12dc0:	64207372 	.word	0x64207372
   12dc4:	63657465 	.word	0x63657465
   12dc8:	0a646574 	.word	0x0a646574
   12dcc:	00000000 	.word	0x00000000
   12dd0:	6e6e6143 	.word	0x6e6e6143
   12dd4:	7620746f 	.word	0x7620746f
   12dd8:	64696c61 	.word	0x64696c61
   12ddc:	20657461 	.word	0x20657461
   12de0:	7265706f 	.word	0x7265706f
   12de4:	6f697461 	.word	0x6f697461
   12de8:	6f66206e 	.word	0x6f66206e
   12dec:	68742072 	.word	0x68742072
   12df0:	20657365 	.word	0x20657365
   12df4:	64656573 	.word	0x64656573
   12df8:	6c617620 	.word	0x6c617620
   12dfc:	2c736575 	.word	0x2c736575
   12e00:	656c7020 	.word	0x656c7020
   12e04:	20657361 	.word	0x20657361
   12e08:	706d6f63 	.word	0x706d6f63
   12e0c:	20657261 	.word	0x20657261
   12e10:	68746977 	.word	0x68746977
   12e14:	73657220 	.word	0x73657220
   12e18:	73746c75 	.word	0x73746c75
   12e1c:	206e6f20 	.word	0x206e6f20
   12e20:	6e6b2061 	.word	0x6e6b2061
   12e24:	206e776f 	.word	0x206e776f
   12e28:	74616c70 	.word	0x74616c70
   12e2c:	6d726f66 	.word	0x6d726f66
   12e30:	00000a2e 	.word	0x00000a2e
   12e34:	4d2f4d43 	.word	0x4d2f4d43
   12e38:	253d7a48 	.word	0x253d7a48
   12e3c:	2e66332e 	.word	0x2e66332e
   12e40:	0000000a 	.word	0x0000000a
   12e44:	46465542 	.word	0x46465542
   12e48:	4f205245 	.word	0x4f205245
   12e4c:	46524556 	.word	0x46524556
   12e50:	45574f4c 	.word	0x45574f4c
   12e54:	49202144 	.word	0x49202144
   12e58:	6572636e 	.word	0x6572636e
   12e5c:	20657361 	.word	0x20657361
   12e60:	42545250 	.word	0x42545250
   12e64:	49534655 	.word	0x49534655
   12e68:	000a455a 	.word	0x000a455a
   12e6c:	626d410a 	.word	0x626d410a
   12e70:	4d207169 	.word	0x4d207169
   12e74:	6f726369 	.word	0x6f726369
   12e78:	726f4320 	.word	0x726f4320
   12e7c:	72616d65 	.word	0x72616d65
   12e80:	7572206b 	.word	0x7572206b
   12e84:	6966206e 	.word	0x6966206e
   12e88:	6873696e 	.word	0x6873696e
   12e8c:	0a216465 	.word	0x0a216465
   12e90:	0000000a 	.word	0x0000000a

00012e94 <errpat>:
   12e94:	00012ed4 00012ee0 00012eec 00012ef8     ................

00012ea4 <floatpat>:
   12ea4:	00012f34 00012f40 00012f4c 00012f58     4/..@/..L/..X/..

00012eb4 <intpat>:
   12eb4:	00012f64 00012f6c 00012f74 00012f7c     d/..l/..t/..|/..

00012ec4 <scipat>:
   12ec4:	00012f04 00012f10 00012f1c 00012f28     ./.../.../..(/..
   12ed4:	332e3054 46312d65 00000000 542e542d     T0.3e-1F....-T.T
   12ee4:	71542b2b 00000000 2e335431 7a346534     ++Tq....1T3.4e4z
   12ef4:	00000000 302e3433 5e542d65 00000000     ....34.0e-T^....
   12f04:	30352e35 332b6530 00000000 32312e2d     5.500e+3....-.12
   12f14:	322d6533 00000000 6537382d 3233382b     3e-2....-87e+832
   12f24:	00000000 362e302b 32312d65 00000000     ....+0.6e-12....
   12f34:	352e3533 30303434 00000000 3332312e     35.54400.....123
   12f44:	30303534 00000000 3031312d 3030372e     4500....-110.700
   12f54:	00000000 362e302b 30303434 00000000     ....+0.64400....
   12f64:	32313035 00000000 34333231 00000000     5012....1234....
   12f74:	3437382d 00000000 3232312b 00000000     -874....+122....
   12f84:	0a0a0a0a 0a0a0a0a 0a0a0a0a 0a0a0a0a     ................
   12f94:	00000a0a                                ....

00012f98 <g_sBspUartConfig>:
   12f98:	0001c200 00000060 00000000 00000000     ....`...........
   12fa8:	00000000 00000012 00000000 00000000     ................
	...

00012fc0 <g_AM_BSP_GPIO_COM_UART_RX>:
   12fc0:	00000000                                ....

00012fc4 <g_AM_BSP_GPIO_COM_UART_TX>:
   12fc4:	00000000                                ....

00012fc8 <am_hal_cachectrl_defaults>:
   12fc8:	00000308                                ....

00012fcc <g_AM_HAL_GPIO_DISABLE>:
   12fcc:	00000003                                ....

00012fd0 <g_ui8Bit76Capabilities>:
   12fd0:	02800101 80010180 80800101 80808080     ................
   12fe0:	80808080 80808008 01800180 80808080     ................
   12ff0:	80808080 01800402 01010401 80808080     ................
   13000:	00000101                                ....

00013004 <g_ui8Inpen>:
   13004:	e2242323 100723a1 e1004303 3561a151     ##$..#...C..Q.a5
   13014:	4181c525 d160b001 31a13130 1100f101     %..A..`.01.1....
   13024:	01d121b1 300511e5 31301037 40006100     .!.....07.01.a.@
   13034:	00003130                                01..

00013038 <g_ui8NCEtable>:
   13038:	13524232 60221202 21534333 20504030     2BR..."`3CS!0@P 
   13048:	11514131 ffffffff ffffffff 60514131     1AQ.........1AQ`
   13058:	00504030 23534333 60524232 30201000     0@P.3CS#2BR`.. 0
   13068:	61504030 01514131 42221202 60231303     0@Pa1AQ..."B..#`
   13078:	50201000 41211101 32221202 60331303     .. P..!A.."2..3`
   13088:	21514131 22524232 03534333 40201000     1AQ!2BR"3CS... @
   13098:	51211101 02524232 13534333 10504030     ..!Q2BR.3CS.0@P.
   130a8:	60514131 12524232 03534333 40201000     1AQ`2BR.3CS... @
   130b8:	61211101 52221202 33231303 30201000     ..!a.."R..#3.. 0
   130c8:	61514131 02524232 53331303 ffffffff     1AQa2BR...3S....
   130d8:	ffffffff 61211101 50201000 61211101     ......!a.. P..!a
   130e8:	52221202 13534333 61504030 31211101     .."R3CS.0@Pa..!1
   130f8:	32221202 43231303                       .."2..#C

00013100 <g_ui8nCEpins>:
   13100:	02070707 00080802 01020202 01010101     ................
   13110:	01010101 01010101 01010101 01010101     ................
   13120:	01010101 08010101 01010008 01010101     ................
   13130:	00000101                                ....

00013134 <g_am_hal_mcuctrl_flash_size>:
   13134:	00004000 00008000 00010000 00020000     .@..............
   13144:	00040000 00080000 00100000 00200000     .............. .
	...

00013174 <g_am_hal_mcuctrl_sram_size>:
   13174:	00004000 00008000 00010000 00020000     .@..............
   13184:	00040000 00080000 00100000 00060000     ................
	...

000131b4 <am_hal_pwrctrl_memory_control>:
	...
   131c8:	00000001 00000001 00000001 00001fff     ................
   131d8:	00001fff 00000003 00000003 00000003     ................
   131e8:	00001fff 00001fff 00000007 00000007     ................
   131f8:	00000007 00001fff 00001fff 0000000f     ................
   13208:	0000000f 0000000f 00001fff 00001fff     ................
   13218:	0000001f 0000001f 0000001f 00001fff     ................
   13228:	00001fff 0000003f 0000003f 0000003f     ....?...?...?...
   13238:	00001fff 00001fff 0000007f 0000007f     ................
   13248:	0000007f 00001fff 00001fff 000000ff     ................
   13258:	000000ff 000000ff 00001fff 00001fff     ................
   13268:	000001ff 000001ff 000001ff 00001fff     ................
   13278:	00001fff 000003ff 000003ff 000003ff     ................
   13288:	00001fff 00001fff 000007ff 000007ff     ................
   13298:	000007ff 00001fff 00001fff 00000fff     ................
   132a8:	00000fff 00000fff 00001fff 00001fff     ................
   132b8:	00001fff 00001fff 00001fff 00001fff     ................
   132c8:	00001fff 00002000 00002000 00002000     ..... ... ... ..
   132d8:	00006000 00006000 00006000 00006000     .`...`...`...`..
   132e8:	00006000 00006000 00006000 c0000000     .`...`...`......
   132f8:	00018000 c0000000 c0000000 00018000     ................
   13308:	c0007fff 0001ffff c0007fff c0007fff     ................
   13318:	0001ffff                                ....

0001331c <am_hal_pwrctrl_peripheral_control>:
	...
   13328:	00000001 00000004 00000004 00000002     ................
   13338:	00000008 00000008 00000004 00000008     ................
   13348:	00000008 00000008 00000008 00000008     ................
   13358:	00000010 00000010 00000010 00000020     ............ ...
   13368:	00000010 00000010 00000040 00000010     ........@.......
   13378:	00000010 00000080 00000004 00000004     ................
   13388:	00000100 00000004 00000004 00000200     ................
   13398:	00000020 00000020 00000400 00000004      ... ...........
   133a8:	00000004 00000800 00000040 00000040     ........@...@...
   133b8:	00001000 00000080 00000080 00002000     ............. ..
   133c8:	00000100 00000100                       ........
