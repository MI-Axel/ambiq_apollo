Name:
=====
 adc_lpmode0


Description:
============
 Example that takes samples with the ADC at high-speed.


This example shows the CTIMER-A3 triggering repeated samples of an external
input at 1.2Msps in LPMODE0.  The example uses the CTIMER-A3 to trigger
ADC sampling.  Each data point is 128 sample average and is read from the
ADC FIFO into an SRAM circular buffer.



******************************************************************************


Name:
=====
 adc_lpmode1


Description:
============
 Example that periodically takes samples with the ADC.


This example shows the CTIMER-A3 triggering repeated samples of the
temperature sensor in low-power mode 1.

SWO is configured in 1M baud, 8-n-1 mode.


******************************************************************************


Name:
=====
 adc_lpmode2


Description:
============
 Example that takes samples with the ADC at 1Hz and powers off the

ADC between samples.  CTIMER-A1 is used to drive the process.

SWO is configured in 1M baud, 8-n-1 mode.


******************************************************************************


Name:
=====
 adc_vbatt


Description:
============
 ADC VBATT voltage divider, BATT load, and temperature reading example.


This example initializes the ADC, and a timer. Two times per second it
reads the VBATT voltage divider and temperature sensor and prints them.
It monitors button 0 and if pressed, it turns on the BATT LOAD resistor.
One should monitor MCU current to see when the load is on or off.

Printing takes place over the ITM at 1M Baud.


******************************************************************************


Name:
=====
 bc_boot_demo


Description:
============
 Example that displays the timer count on the LEDs.


This example is a copy of the "binary counter" demo compiled and linked to
run at flash address 0x8000 instead of 0x0000. This is useful for users who
would like to run their applications with a permanent bootloader program in
the first page of flash.

Please see the linker configuration files for an example of how this offset
can be built into the compilation process.

SWO is configured in 1M baud, 8-n-1 mode.


******************************************************************************


Name:
=====
 binary_counter


Description:
============
 Example that displays the timer count on the LEDs.


This example increments a variable on every timer interrupt. The global
variable is used to set the state of the LEDs. The example sleeps otherwise.

SWO is configured in 1M baud, 8-n-1 mode.


******************************************************************************


Name:
=====
 buckzx_demo


Description:
============
 Demonstrate operation of the buck zero-cross implementation.


See Errata ERR019 for additional details on this issue.

Heavily based on deepsleep_wake, this example demonstrates the
operation of the buck zero-cross implementation.

The example uses 5 GPIOs in total for the demonstration as follows:
GPIO 3: Shows the CTIMER A buck pulse.
GPIO 4: Shows The CTIMER B buck pulse.
GPIO 5: Demarcates the sleep cycle; high while sleeping,
low when awake.
GPIO 6: Demarcates am_ctimer_isr(), high when the ISR is
entered, low on exit. Basically envelopes each of
the buck pulses.
GPIO 7: Toggling pattern of approximately 1us width during
the time the bucks are being restored.

To run the buckzx_demo example:
- Connect an analyzer to GPIOs 3-7 on the apollo2_evb board with
a trigger (high-to-low) on GPIO5.
- Flash the example binary and reset.
- As on deepsleep_wake, the Apollo2 will incur an RTC interrupt
once every second. It will stay awake for one second, then it
will deep sleep for one second.
- The sleep time is indicated by GPIO 5 being high. The awake
time is indicated by GPIO 5 being low.
- Zooming in on the GPIO5 low-going pulse shows the buck handling
in action.
- GPIO 3 & 4 will each pulse once during the wake time. These
pulses show the core and memory bucks.
Note that the 2 signals occur differently depending on the
CTIMER used.  CTIMERs 0 and 1 will see core buck on GPIO4
(CTimer B) and mem buck on GPIO3 (CTimer A).  CTIMERs 2 and 3
are vice-versa.
- GPIO 6 pulses each time the CTIMER fires.  Therefore, there
should be as many GPIO6 pulses as 3 & 4 combined.
- GPIO 7 simply demonstrates MCU usage while the bucks are resumed.
- Modify BUCK_TIMER (0 - 3) to change the timer that is actually
used for the operation.


******************************************************************************


Name:
=====
 clkout


Description:
============
 Enables a clock source to clkout and then tracks it on an LED array.


This example enables the LFRC to a clkout pin then uses GPIO polling to
track its rising edge and toggle an LED at 1 hertz.


******************************************************************************


Name:
=====
 deepsleep


Description:
============
 Example demonstrating how to enter deepsleep.


This example configures the device to go into a deep sleep mode. Once in
sleep mode the device has no ability to wake up. This example is merely to
provide the opportunity to measure deepsleep current without interrupts
interfering with the measurement.

The example begins by printing out a banner annoucement message through
the UART, which is then completely disabled for the remainder of execution.

Text is output to the UART at 115,200 BAUD, 8 bit, no parity.
Please note that text end-of-line is a newline (LF) character only.
Therefore, the UART terminal must be set to simulate a CR/LF.


******************************************************************************


Name:
=====
 deepsleep_wake


Description:
============
 Example that goes to deepsleep and wakes from either the RTC or GPIO.


This example configures the device to go into a deep sleep mode. Once in
deep sleep the device has the ability to wake from button 0 or
the RTC configured to interrupt every second. If the MCU woke from a button
press, it will toggle LED0. If the MCU woke from the RTC, it will toggle
LED1.

The example begins by printing out a banner annoucement message through
the UART, which is then completely disabled for the remainder of execution.

Text is output to the UART at 115,200 BAUD, 8 bit, no parity.
Please note that text end-of-line is a newline (LF) character only.
Therefore, the UART terminal must be set to simulate a CR/LF.


******************************************************************************


Name:
=====
 flash_write


Description:
============
 Flash write example.


This example shows how to modify the internal Flash using HAL flash helper
functions.

This example works on instance 1 of the Flash, i.e. the portion of the
Flash above 256KB/512KB.



******************************************************************************


Name:
=====
 flash_write_apollo2


Description:
============
 Flash write example specifically for Apollo 2.


This example shows how to modify the internal Flash using HAL flash helper
functions.

This example works on instance 1 of the Flash, i.e. the portion of the
Flash above 512KB. It is intended to execute from instance 0.



******************************************************************************


Name:
=====
 freertos_lowpower


Description:
============
 Example of the app running under FreeRTOS.


This example implements LED task within the FreeRTOS framework. It monitors
three On-board buttons, and toggles respective on-board LEDs in response.
To save power, this application is compiled without print
statements by default. To enable them, add the following project-level
macro definitions.

AM_DEBUG_PRINTF

If enabled, debug messages will be sent over ITM.


******************************************************************************


Name:
=====
 hello_fault


Description:
============
 A simple example that causes a hard-fault.


This example demonstrates the extended hard fault handler which can
assist the user in decoding a fault condition. The handler pulls the
registers that the Cortex M4 automatically loads onto the stack and
combines them with various other fault information into a single
data structure saved locally.  It can optionally print out the fault
data structure (assuming the stdio printf has previously been enabled
and is still enabled at the time of the fault).


******************************************************************************


Name:
=====
 hello_world


Description:
============
 A simple "Hello World" example.


This example prints a "Hello World" message with some device info
over SWO at 1M baud. To see the output of this program, run AMFlash,
and configure the console for SWO. The example sleeps after it is done
printing.


******************************************************************************


Name:
=====
 hello_world_uart


Description:
============
 A simple "Hello World" example using the UART peripheral.


This example prints a "Hello World" message with some device info
over UART at 115200 baud. To see the output of this program, run AMFlash,
and configure the console for UART. The example sleeps after it is done
printing.


******************************************************************************


Name:
=====
 i2c_boot_host


Description:
============
 An example to drive the IO Slave on a second board.


This example acts as the boot host for spi_boot and multi_boot on Apollo
and Apollo2 MCUs. It will deliver a predefined firmware image to a boot
slave over an I2C protocol. The purpose of this demo is to show how a host
processor might store, load, and update the firmware on an Apollo or
Apollo2 device that is connected as a slave.

Please see the multi_boot README.txt for more details on how to run the
examples.

PIN fly lead connections assumed by multi_boot:
HOST                                    SLAVE (multi_boot target)
--------                                --------
GPIO[2]  GPIO Interrupt (slave to host) GPIO[4]  GPIO interrupt
GPIO[4]  OVERRIDE pin   (host to slave) GPIO[18] Override pin or n/c
GPIO[5]  IOM0 SPI CLK/I2C SCL           GPIO[0]  IOS SPI SCK/I2C SCL
GPIO[6]  IOM0 SPI MISO/I2C SDA          GPIO[1]  IOS SPI MISO/I2C SDA
GPIO[7]  IOM0 SPI MOSI                  GPIO[2]  IOS SPI MOSI
GPIO[11] IOM0 SPI nCE                   GPIO[3]  IOS SPI nCE
GPIO[17] Slave reset (host to slave)    Reset Pin or n/c
GND                                     GND
Reset and Override pin connections from Host are optional
Keeping Button1 pressed on target has same effect as host driving override


******************************************************************************


Name:
=====
 i2c_loopback


Description:
============
 Example of I2C operation using IOM #0 talking to the IOS over I2C


SWO is configured in 1M baud, 8-n-1 mode.
PIN Fly Lead Assumptions for the I/O Master (IOM):
IOM0
GPIO[5] == IOM4 I2C SCL
GPIO[6] == IOM4 I2C SDA

IOS
PIN Fly Lead Assumptions for the I/O Slave (IOS):
GPIO[0] == IOS I2C SCL
GPIO[1] == IOS I2C SDA

Connect IOM4 I2C pins to corresponding IOS I2C pins



******************************************************************************


Name:
=====
 ios_fifo


Description:
============
 Example slave used for demonstrating the use of the IOS FIFO.


This slave component runs on one EVB and is used in conjunction with
the companion host example, ios_fifo_host, which runs on a second EVB.

The ios_fifo example has no print output.
The host example does use the ITM SWO to let the user know progress and
status of the demonstration.

This example implements the slave part of a protocol for data exchange with
an Apollo IO Master (IOM).  The host sends one byte commands on SPI/I2C by
writing to offset 0x80.

The command is issued by the host to Start/Stop Data accumulation, and also
to acknowledge read-complete of a block of data.

On the IOS side, once it is asked to start accumulating data (using START
command), two CTimer based events emulate sensors sending data to IOS.
When IOS has some data for host, it implements a state machine,
synchronizing with the host.

The IOS interrupts the host to indicate data availability. The host then
reads the available data (as indicated by FIFOCTR) by READing using IOS FIFO
(at address 0x7F).  The IOS keeps accumulating any new data coming in the
background.

Host sends an acknowledgement to IOS once it has finished reading a block
of data initiated by IOS (partitally or complete). IOS interrupts the host
again if and when it has more data for the host to read, and the cycle
repeats - till host indicates that it is no longer interested in receiving
data by sending STOP command.

In order to run this example, a host device (e.g. a second EVB) must be set
up to run the host example, ios_fifo_host.  The two boards can be connected
using fly leads between the two boards as follows.

Pin connections for the I/O Master board to the I/O Slave board.

HOST (ios_fifo_host)                    SLAVE (ios_fifo)
--------------------                    ----------------
GPIO[10] GPIO Interrupt (slave to host) GPIO[4]  GPIO interrupt
GPIO[5]  IOM0 SPI CLK/I2C SCL           GPIO[0]  IOS SPI SCK/I2C SCL
GPIO[6]  IOM0 SPI MISO/I2C SDA          GPIO[1]  IOS SPI MISO/I2C SDA
GPIO[7]  IOM0 SPI MOSI                  GPIO[2]  IOS SPI MOSI
GPIO[11] IOM0 SPI nCE                   GPIO[3]  IOS SPI nCE
GND                                     GND


******************************************************************************


Name:
=====
 ios_fifo_host


Description:
============
 Example host used for demonstrating the use of the IOS FIFO.


This host component runs on one EVB and is used in conjunction with
the companion slave example, ios_fifo, which runs on a second EVB.

The host example uses the ITM SWO to let the user know progress and
status of the demonstration.  The SWO is configured at 1M baud.
The ios_fifo example has no print output.

This example implements the host part of a protocol for data exchange with
an Apollo IO Slave (IOS).  The host sends one byte commands on SPI/I2C by
writing to offset 0x80.

The command is issued by the host to Start/Stop Data accumulation, and also
to acknowledge read-complete of a block of data.

On the IOS side, once it is asked to start accumulating data (using START
command), two CTimer based events emulate sensors sending data to IOS.
When IOS has some data for host, it implements a state machine,
synchronizing with the host.

The IOS interrupts the host to indicate data availability. The host then
reads the available data (as indicated by FIFOCTR) by READing using IOS FIFO
(at address 0x7F).  The IOS keeps accumulating any new data coming in the
background.

Host sends an acknowledgement to IOS once it has finished reading a block
of data initiated by IOS (partitally or complete). IOS interrupts the host
again if and when it has more data for the host to read, and the cycle
repeats - till host indicates that it is no longer interested in receiving
data by sending STOP command.

In order to run this example, a slave device (e.g. a second EVB) must be set
up to run the companion example, ios_fifo.  The two boards can be connected
using fly leads between the two boards as follows.

Pin connections for the I/O Master board to the I/O Slave board.

HOST (ios_fifo_host)                    SLAVE (ios_fifo)
--------------------                    ----------------
GPIO[10] GPIO Interrupt (slave to host) GPIO[4]  GPIO interrupt
GPIO[5]  IOM0 SPI CLK/I2C SCL           GPIO[0]  IOS SPI SCK/I2C SCL
GPIO[6]  IOM0 SPI MISO/I2C SDA          GPIO[1]  IOS SPI MISO/I2C SDA
GPIO[7]  IOM0 SPI MOSI                  GPIO[2]  IOS SPI MOSI
GPIO[11] IOM0 SPI nCE                   GPIO[3]  IOS SPI nCE
GND                                     GND


******************************************************************************


Name:
=====
 itm_printf


Description:
============
 Example that uses the ITM interface for printf.


This example walks through the ASCII table (starting at character 033('!')
and ending on 126('~')) and prints the character to the ARM ITM. This output
can be decoded by running a terminal emulator (e.g. SEGGER J-Link SWO Viewer) 
and configuring the console for SWO at 1M Baud. This example works by 
configuring a timer and printing a new character after ever interrupt and 
sleeps in between timer interrupts.


******************************************************************************


Name:
=====
 multi_boot


Description:
============
 Bootloader program accepting multiple host protocols.


Multiboot is a bootloader program that supports flash programming over UART,
SPI, and I2C. The correct protocol is selected automatically at boot time.
The messaging is expected to follow little-endian format, which is native to
the Cortex M4 used in Apollo and Apollo2.

If a valid image is already present on the target device, Multiboot will run
that image.  Otherwise it will wait for a new image to be downloaded from
the host.  A new image download can be forced on the target by using the
"override" capability via one of the pins.

Running this example requires 2 EVBs - one EVB to run multi_boot, the second
to run a host example such as spi_boot_host or i2c_boot_host. The two EVBs
are generally fly wired together as shown below.

The most straightforward method of running the demonstration is to use two
EVBs of the same type (i.e. 2 Apollo EVBs or 2 Apollo2 EVBs) as both the
host and the target.  Then the pins on the two EVBs are connected as shown
in the chart including the optional reset and override pins.  With these
connections, the host controls everything and no user intervention is
required other than the press the reset button on the host to initiate the
process.

The host downloads an executable (target) image to the slave that will run
on the target.  By default that image is binary_counter, which is obvious
to see running on the slave.

In the default scenario (two boards of the same type), the image downloaded
by the host is compatible with the host board type, so it will run without
modification on the target.  In the case of the host device being different
from the target, the image downloaded from the host must be modified to be
compatible with the target (requires rebuilding the host example).

The EVB Button1 (usually labelled BTN2 on the EVB silkscreen) is the manual
override which can be used to force downloading of a new image even if a
valid image already exists on the target. The host examples use the same
"override" pin signal when downloading a new image.

PIN fly lead connections assumed by multi_boot:
HOST                                    SLAVE (multi_boot target)
--------                                --------
GPIO[2]  GPIO Interrupt (slave to host) GPIO[4]  GPIO interrupt
GPIO[4]  OVERRIDE pin   (host to slave) GPIO[18] Override pin or n/c
GPIO[5]  IOM0 SPI CLK/I2C SCL           GPIO[0]  IOS SPI SCK/I2C SCL
GPIO[6]  IOM0 SPI MISO/I2C SDA          GPIO[1]  IOS SPI MISO/I2C SDA
GPIO[7]  IOM0 SPI MOSI                  GPIO[2]  IOS SPI MOSI
GPIO[11] IOM0 SPI nCE                   GPIO[3]  IOS SPI nCE
GPIO[17] Slave reset (host to slave)    Reset Pin (NRST) or n/c
GND                                     GND
Reset and Override pin connections from Host are optional
Keeping Button1 pressed on target has same effect as host driving override


******************************************************************************


Name:
=====
 multi_boot


Description:
============
 Bootloader program accepting multiple host protocols.


This is a bootloader program that supports flash programming over UART,
SPI, and I2C. The correct protocol is selected automatically at boot time.
The messaging is expected to follow little-endian format, which is native to
Apollo1/2.
This version of bootloader also supports security features -
Image confidentiality, Authentication, and key revocation is supported
using a simple CRC-CBC based encryption mechanism.

Default override pin corresponds to Button1. So, even if a valid image is
present in flash, bootloader can be forced to wait for new image from host.

PIN fly lead connections assumed by multi_boot:
HOST                                    SLAVE (multi_boot target)
--------                                --------
GPIO[2]  GPIO Interrupt (slave to host) GPIO[4]  GPIO interrupt
GPIO[4]  OVERRIDE pin   (host to slave) GPIO[18] Override pin or n/c
GPIO[5]  IOM0 SPI CLK/I2C SCL           GPIO[0]  IOS SPI SCK/I2C SCL
GPIO[6]  IOM0 SPI MISO/I2C SDA          GPIO[1]  IOS SPI MISO/I2C SDA
GPIO[7]  IOM0 SPI MOSI                  GPIO[2]  IOS SPI MOSI
GPIO[11] IOM0 SPI nCE                   GPIO[3]  IOS SPI nCE
GPIO[17] Slave reset (host to slave)    Reset Pin or n/c
Reset and Override pin connections from Host are optional
Keeping Button1 pressed on target has same effect as host driving override


******************************************************************************


Name:
=====
 prime


Description:
============
 Example that displays the timer count on the LEDs.


This example consists of a non-optimized, brute-force routine for computing
the number of prime numbers between 1 and a given value, N. The routine
uses modulo operations to determine whether a value is prime or not. While
obviously not optimal, it is very useful for exercising the core.

For this example, N is 100000, for which the answer is 9592.

For Apollo3 at 48MHz, the time to compute the answer for Keil and IAR:
IAR v8.11.1:        1:43.
Keil ARMCC 4060528: 1:55.

Apollo2 at 48MHz takes less than 2 1/4 minutes to determine that answer
when compiled with IAR v8.11.

The goal of this example is to measure current consumption while the core
is working to compute the answer. Power and energy can then be derived
knowing the current and run time.

The example prints an initial banner to the UART port.  After each prime
loop, it enables the UART long enough to print the answer, disables the
UART and starts the computation again.

Text is output to the UART at 115,200 BAUD, 8 bit, no parity.
Please note that text end-of-line is a newline (LF) character only.
Therefore, the UART terminal must be set to simulate a CR/LF.

Note: For minimum power, disable the printing by setting PRINT_UART to 0.

The prime_number() routine is open source and is used here under the
GNU LESSER GENERAL PUBLIC LICENSE Version 3, 29 June 2007.  Details,
documentation, and the full license for this routine can be found in
the third_party/prime_mpi/ directory of the SDK.



******************************************************************************


Name:
=====
 pwm_gen


Description:
============
 Breathing LED example.


This example shows one way to vary the brightness of an LED using timers in
PWM mode.


******************************************************************************


Name:
=====
 reset_states


Description:
============
 Example of various reset options in Apollo.


This example shows a simple configuration of the watchdog. It will print
a banner message, configure the watchdog for both interrupt and reset
generation, and immediately start the watchdog timer.
The watchdog ISR provided will 'pet' the watchdog four times, printing
a notification message from the ISR each time.
On the fifth interrupt, the watchdog will not be pet, so the 'reset'
action will eventually be allowed to occur.
On the sixth timeout event, the WDT should issue a system reset, and the
program should start over from the beginning.

The program will repeat the following sequence on the console:
(POI Reset) 5 Interrupts - (WDT Reset) 3 Interrupts - (POR Reset) 3 Interrupts


******************************************************************************


Name:
=====
 rtc_print


Description:
============
 Example using the internal RTC.


This example demonstrates how to interface with the RTC and prints the
time over SWO.

The example works by configuring a timer interrupt which will periodically
wake the core from deep sleep. After every interrupt, it prints the current
RTC time.



******************************************************************************


Name:
=====
 spi_boot_host


Description:
============
 An example to drive the IO Slave on a second board.


This example acts as the boot host for spi_boot and multi_boot on Apollo
and Apollo2 MCUs. It will deliver a predefined firmware image to a boot
slave over a SPI protocol. The purpose of this demo is to show how a host
processor might store, load, and update the firmware on an Apollo or
Apollo2 device that is connected as a slave.

Please see the multi_boot README.txt for more details on how to run the
examples.

PIN fly lead connections assumed by multi_boot:
HOST                                    SLAVE (multi_boot target)
--------                                --------
GPIO[2]  GPIO Interrupt (slave to host) GPIO[4]  GPIO interrupt
GPIO[4]  OVERRIDE pin   (host to slave) GPIO[18] Override pin or n/c
GPIO[5]  IOM0 SPI CLK/I2C SCL           GPIO[0]  IOS SPI SCK/I2C SCL
GPIO[6]  IOM0 SPI MISO/I2C SDA          GPIO[1]  IOS SPI MISO/I2C SDA
GPIO[7]  IOM0 SPI MOSI                  GPIO[2]  IOS SPI MOSI
GPIO[11] IOM0 SPI nCE                   GPIO[3]  IOS SPI nCE
GPIO[17] Slave reset (host to slave)    Reset Pin or n/c
GND                                     GND
Reset and Override pin connections from Host are optional
Keeping Button1 pressed on target has same effect as host driving override


******************************************************************************


Name:
=====
 stimer


Description:
============
 Example using a stimer with interrupts.


This example demonstrates how to setup the stimer for counting and
interrupts. It toggles LED 0 every interrupt, which is set for 1 sec.


******************************************************************************


Name:
=====
 uart_printf


Description:
============
 Example that uses the UART interface for printf.


This example demonstrates the use of SW Buffer for UART.
It listens to the UART, and loops back the received data on the Tx
6
The UART is set at 115,200 BAUD, 8 bit, no parity.

Finally, a banner, transmit, and receive status information is
printed to the ITM/SWO.


******************************************************************************


Name:
=====
 uart_printf


Description:
============
 Example that uses the UART interface for printf.


This example walks through the ASCII table (starting at character 033('!')
and ending on 126('~')) and prints the character to the UART. This output
can be decoded by running AM Flash and configuring the console for UART at
115200 Baud. This example works by configuring a timer and printing a new
character after ever interrupt and sleeps in between timer interrupts.


******************************************************************************


Name:
=====
 watchdog


Description:
============
 Example of a basic configuration of the watchdog.


This example shows a simple configuration of the watchdog. It will print
a banner message, configure the watchdog for both interrupt and reset
generation, and immediately start the watchdog timer.
The watchdog ISR provided will 'pet' the watchdog four times, printing
a notification message from the ISR each time.
On the fifth interrupt, the watchdog will not be pet, so the 'reset'
action will eventually be allowed to occur.
On the sixth timeout event, the WDT should issue a system reset, and the
program should start over from the beginning.


******************************************************************************


