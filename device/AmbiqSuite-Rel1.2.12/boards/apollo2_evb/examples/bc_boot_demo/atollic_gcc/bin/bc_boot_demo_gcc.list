
bc_boot_demo_gcc.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000022bc  00008000  00008000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .stack        00001000  10000000  10000000  00020000  2**2
                  ALLOC
  2 .data         00000034  10001000  0000a2bc  00011000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          0000011c  10001034  0000a2f0  00011034  2**2
                  ALLOC
  4 .ARM.attributes 00000037  00000000  00000000  00011034  2**0
                  CONTENTS, READONLY
  5 .debug_info   0000bfee  00000000  00000000  0001106b  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00002914  00000000  00000000  0001d059  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000838  00000000  00000000  0001f96d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_ranges 000012c0  00000000  00000000  000201a5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00004da8  00000000  00000000  00021465  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002dda  00000000  00000000  0002620d  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000007c  00000000  00000000  00028fe7  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00001748  00000000  00000000  00029064  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    000036d9  00000000  00000000  0002a7ac  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00008000 <g_am_pfnVectors>:
    8000:	00 10 00 10 01 88 00 00 69 88 00 00 75 88 00 00     ........i...u...
    8010:	75 88 00 00 75 88 00 00 75 88 00 00 00 00 00 00     u...u...u.......
	...
    802c:	6f 88 00 00 6f 88 00 00 00 00 00 00 6f 88 00 00     o...o.......o...
    803c:	6f 88 00 00 6f 88 00 00 6f 88 00 00 6f 88 00 00     o...o...o...o...
    804c:	6f 88 00 00 6f 88 00 00 6f 88 00 00 6f 88 00 00     o...o...o...o...
    805c:	6f 88 00 00 6f 88 00 00 6f 88 00 00 6f 88 00 00     o...o...o...o...
    806c:	6f 88 00 00 6f 88 00 00 01 87 00 00 6f 88 00 00     o...o.......o...
    807c:	6f 88 00 00 6f 88 00 00 6f 88 00 00 6f 88 00 00     o...o...o...o...
    808c:	6f 88 00 00 6f 88 00 00 6f 88 00 00 6f 88 00 00     o...o...o...o...
    809c:	6f 88 00 00 6f 88 00 00 6f 88 00 00 6f 88 00 00     o...o...o...o...
    80ac:	6f 88 00 00 6f 88 00 00 6f 88 00 00 6f 88 00 00     o...o...o...o...
    80bc:	6f 88 00 00                                         o...

000080c0 <__aeabi_d2f>:
    80c0:	ea4f 0241 	mov.w	r2, r1, lsl #1
    80c4:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
    80c8:	bf24      	itt	cs
    80ca:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
    80ce:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
    80d2:	d90d      	bls.n	80f0 <__aeabi_d2f+0x30>
    80d4:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    80d8:	ea4f 02c0 	mov.w	r2, r0, lsl #3
    80dc:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
    80e0:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
    80e4:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
    80e8:	bf08      	it	eq
    80ea:	f020 0001 	biceq.w	r0, r0, #1
    80ee:	4770      	bx	lr
    80f0:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
    80f4:	d121      	bne.n	813a <__aeabi_d2f+0x7a>
    80f6:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
    80fa:	bfbc      	itt	lt
    80fc:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
    8100:	4770      	bxlt	lr
    8102:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    8106:	ea4f 5252 	mov.w	r2, r2, lsr #21
    810a:	f1c2 0218 	rsb	r2, r2, #24
    810e:	f1c2 0c20 	rsb	ip, r2, #32
    8112:	fa10 f30c 	lsls.w	r3, r0, ip
    8116:	fa20 f002 	lsr.w	r0, r0, r2
    811a:	bf18      	it	ne
    811c:	f040 0001 	orrne.w	r0, r0, #1
    8120:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    8124:	ea4f 23d3 	mov.w	r3, r3, lsr #11
    8128:	fa03 fc0c 	lsl.w	ip, r3, ip
    812c:	ea40 000c 	orr.w	r0, r0, ip
    8130:	fa23 f302 	lsr.w	r3, r3, r2
    8134:	ea4f 0343 	mov.w	r3, r3, lsl #1
    8138:	e7cc      	b.n	80d4 <__aeabi_d2f+0x14>
    813a:	ea7f 5362 	mvns.w	r3, r2, asr #21
    813e:	d107      	bne.n	8150 <__aeabi_d2f+0x90>
    8140:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
    8144:	bf1e      	ittt	ne
    8146:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
    814a:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
    814e:	4770      	bxne	lr
    8150:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
    8154:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    8158:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    815c:	4770      	bx	lr
    815e:	bf00      	nop

00008160 <am_devices_led_init>:
//! @return None.
//
//*****************************************************************************
void
am_devices_led_init(am_devices_led_t *psLED)
{
    8160:	b590      	push	{r4, r7, lr}
    8162:	b085      	sub	sp, #20
    8164:	af00      	add	r7, sp, #0
    8166:	6078      	str	r0, [r7, #4]
    if ( (psLED == NULL)    ||
    8168:	687b      	ldr	r3, [r7, #4]
    816a:	2b00      	cmp	r3, #0
    816c:	f000 8162 	beq.w	8434 <am_devices_led_init+0x2d4>
         (psLED->ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    8170:	687b      	ldr	r3, [r7, #4]
    8172:	681b      	ldr	r3, [r3, #0]
    if ( (psLED == NULL)    ||
    8174:	2b31      	cmp	r3, #49	; 0x31
    8176:	f200 815d 	bhi.w	8434 <am_devices_led_init+0x2d4>
    }
#else
    //
    // Handle Direct Drive Versus 3-State (with pull-up or no buffer).
    //
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLED->ui32Polarity )
    817a:	687b      	ldr	r3, [r7, #4]
    817c:	685b      	ldr	r3, [r3, #4]
    817e:	f003 0302 	and.w	r3, r3, #2
    8182:	2b00      	cmp	r3, #0
    8184:	f000 80ab 	beq.w	82de <am_devices_led_init+0x17e>
    {
        //
        // Configure the pin as a push-pull GPIO output.
        //
        am_hal_gpio_pin_config(psLED->ui32GPIONumber, AM_HAL_GPIO_OUTPUT);
    8188:	687b      	ldr	r3, [r7, #4]
    818a:	681b      	ldr	r3, [r3, #0]
    818c:	2b31      	cmp	r3, #49	; 0x31
    818e:	d86e      	bhi.n	826e <am_devices_led_init+0x10e>
    8190:	f001 fd38 	bl	9c04 <am_hal_interrupt_master_disable>
    8194:	4603      	mov	r3, r0
    8196:	60fb      	str	r3, [r7, #12]
    8198:	4ba8      	ldr	r3, [pc, #672]	; (843c <am_devices_led_init+0x2dc>)
    819a:	2273      	movs	r2, #115	; 0x73
    819c:	601a      	str	r2, [r3, #0]
    819e:	687b      	ldr	r3, [r7, #4]
    81a0:	681b      	ldr	r3, [r3, #0]
    81a2:	085b      	lsrs	r3, r3, #1
    81a4:	f003 027c 	and.w	r2, r3, #124	; 0x7c
    81a8:	4ba5      	ldr	r3, [pc, #660]	; (8440 <am_devices_led_init+0x2e0>)
    81aa:	4413      	add	r3, r2
    81ac:	461c      	mov	r4, r3
    81ae:	687b      	ldr	r3, [r7, #4]
    81b0:	681b      	ldr	r3, [r3, #0]
    81b2:	009b      	lsls	r3, r3, #2
    81b4:	f003 031c 	and.w	r3, r3, #28
    81b8:	2202      	movs	r2, #2
    81ba:	409a      	lsls	r2, r3
    81bc:	687b      	ldr	r3, [r7, #4]
    81be:	681b      	ldr	r3, [r3, #0]
    81c0:	085b      	lsrs	r3, r3, #1
    81c2:	f003 017c 	and.w	r1, r3, #124	; 0x7c
    81c6:	4b9e      	ldr	r3, [pc, #632]	; (8440 <am_devices_led_init+0x2e0>)
    81c8:	440b      	add	r3, r1
    81ca:	6819      	ldr	r1, [r3, #0]
    81cc:	687b      	ldr	r3, [r7, #4]
    81ce:	681b      	ldr	r3, [r3, #0]
    81d0:	009b      	lsls	r3, r3, #2
    81d2:	f003 031c 	and.w	r3, r3, #28
    81d6:	2007      	movs	r0, #7
    81d8:	fa00 f303 	lsl.w	r3, r0, r3
    81dc:	43db      	mvns	r3, r3
    81de:	400b      	ands	r3, r1
    81e0:	4313      	orrs	r3, r2
    81e2:	6023      	str	r3, [r4, #0]
    81e4:	687b      	ldr	r3, [r7, #4]
    81e6:	681b      	ldr	r3, [r3, #0]
    81e8:	f003 03fc 	and.w	r3, r3, #252	; 0xfc
    81ec:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    81f0:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
    81f4:	461c      	mov	r4, r3
    81f6:	687b      	ldr	r3, [r7, #4]
    81f8:	681b      	ldr	r3, [r3, #0]
    81fa:	00db      	lsls	r3, r3, #3
    81fc:	f003 0318 	and.w	r3, r3, #24
    8200:	2218      	movs	r2, #24
    8202:	409a      	lsls	r2, r3
    8204:	687b      	ldr	r3, [r7, #4]
    8206:	681b      	ldr	r3, [r3, #0]
    8208:	f003 03fc 	and.w	r3, r3, #252	; 0xfc
    820c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    8210:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
    8214:	6819      	ldr	r1, [r3, #0]
    8216:	687b      	ldr	r3, [r7, #4]
    8218:	681b      	ldr	r3, [r3, #0]
    821a:	00db      	lsls	r3, r3, #3
    821c:	f003 0318 	and.w	r3, r3, #24
    8220:	20ff      	movs	r0, #255	; 0xff
    8222:	fa00 f303 	lsl.w	r3, r0, r3
    8226:	43db      	mvns	r3, r3
    8228:	400b      	ands	r3, r1
    822a:	4313      	orrs	r3, r2
    822c:	6023      	str	r3, [r4, #0]
    822e:	687b      	ldr	r3, [r7, #4]
    8230:	681b      	ldr	r3, [r3, #0]
    8232:	f003 02fc 	and.w	r2, r3, #252	; 0xfc
    8236:	4b83      	ldr	r3, [pc, #524]	; (8444 <am_devices_led_init+0x2e4>)
    8238:	4413      	add	r3, r2
    823a:	4618      	mov	r0, r3
    823c:	687b      	ldr	r3, [r7, #4]
    823e:	681b      	ldr	r3, [r3, #0]
    8240:	f003 02fc 	and.w	r2, r3, #252	; 0xfc
    8244:	4b7f      	ldr	r3, [pc, #508]	; (8444 <am_devices_led_init+0x2e4>)
    8246:	4413      	add	r3, r2
    8248:	681a      	ldr	r2, [r3, #0]
    824a:	687b      	ldr	r3, [r7, #4]
    824c:	681b      	ldr	r3, [r3, #0]
    824e:	00db      	lsls	r3, r3, #3
    8250:	f003 0318 	and.w	r3, r3, #24
    8254:	21ff      	movs	r1, #255	; 0xff
    8256:	fa01 f303 	lsl.w	r3, r1, r3
    825a:	43db      	mvns	r3, r3
    825c:	4013      	ands	r3, r2
    825e:	6003      	str	r3, [r0, #0]
    8260:	4b76      	ldr	r3, [pc, #472]	; (843c <am_devices_led_init+0x2dc>)
    8262:	2200      	movs	r2, #0
    8264:	601a      	str	r2, [r3, #0]
    8266:	68fb      	ldr	r3, [r7, #12]
    8268:	4618      	mov	r0, r3
    826a:	f001 fccf 	bl	9c0c <am_hal_interrupt_master_set>

        //
        // Disable the output driver, and set the output value to the LEDs "ON"
        // state.
        //
        am_hal_gpio_out_enable_bit_clear(psLED->ui32GPIONumber);
    826e:	687b      	ldr	r3, [r7, #4]
    8270:	681b      	ldr	r3, [r3, #0]
    8272:	08db      	lsrs	r3, r3, #3
    8274:	f003 0204 	and.w	r2, r3, #4
    8278:	4b73      	ldr	r3, [pc, #460]	; (8448 <am_devices_led_init+0x2e8>)
    827a:	4413      	add	r3, r2
    827c:	4619      	mov	r1, r3
    827e:	687b      	ldr	r3, [r7, #4]
    8280:	681b      	ldr	r3, [r3, #0]
    8282:	f003 031f 	and.w	r3, r3, #31
    8286:	2201      	movs	r2, #1
    8288:	fa02 f303 	lsl.w	r3, r2, r3
    828c:	600b      	str	r3, [r1, #0]
        am_hal_gpio_out_bit_replace(psLED->ui32GPIONumber,
    828e:	687b      	ldr	r3, [r7, #4]
    8290:	685b      	ldr	r3, [r3, #4]
    8292:	f003 0301 	and.w	r3, r3, #1
    8296:	2b00      	cmp	r3, #0
    8298:	d010      	beq.n	82bc <am_devices_led_init+0x15c>
    829a:	687b      	ldr	r3, [r7, #4]
    829c:	681b      	ldr	r3, [r3, #0]
    829e:	08db      	lsrs	r3, r3, #3
    82a0:	f003 0204 	and.w	r2, r3, #4
    82a4:	4b69      	ldr	r3, [pc, #420]	; (844c <am_devices_led_init+0x2ec>)
    82a6:	4413      	add	r3, r2
    82a8:	4619      	mov	r1, r3
    82aa:	687b      	ldr	r3, [r7, #4]
    82ac:	681b      	ldr	r3, [r3, #0]
    82ae:	f003 031f 	and.w	r3, r3, #31
    82b2:	2201      	movs	r2, #1
    82b4:	fa02 f303 	lsl.w	r3, r2, r3
    82b8:	600b      	str	r3, [r1, #0]
    82ba:	e0bc      	b.n	8436 <am_devices_led_init+0x2d6>
    82bc:	687b      	ldr	r3, [r7, #4]
    82be:	681b      	ldr	r3, [r3, #0]
    82c0:	08db      	lsrs	r3, r3, #3
    82c2:	f003 0204 	and.w	r2, r3, #4
    82c6:	4b62      	ldr	r3, [pc, #392]	; (8450 <am_devices_led_init+0x2f0>)
    82c8:	4413      	add	r3, r2
    82ca:	4619      	mov	r1, r3
    82cc:	687b      	ldr	r3, [r7, #4]
    82ce:	681b      	ldr	r3, [r3, #0]
    82d0:	f003 031f 	and.w	r3, r3, #31
    82d4:	2201      	movs	r2, #1
    82d6:	fa02 f303 	lsl.w	r3, r2, r3
    82da:	600b      	str	r3, [r1, #0]
    82dc:	e0ab      	b.n	8436 <am_devices_led_init+0x2d6>
    else
    {
        //
        // Configure the pin as a tri-state GPIO.
        //
        am_hal_gpio_pin_config(psLED->ui32GPIONumber, AM_HAL_GPIO_3STATE);
    82de:	687b      	ldr	r3, [r7, #4]
    82e0:	681b      	ldr	r3, [r3, #0]
    82e2:	2b31      	cmp	r3, #49	; 0x31
    82e4:	d86e      	bhi.n	83c4 <am_devices_led_init+0x264>
    82e6:	f001 fc8d 	bl	9c04 <am_hal_interrupt_master_disable>
    82ea:	4603      	mov	r3, r0
    82ec:	60bb      	str	r3, [r7, #8]
    82ee:	4b53      	ldr	r3, [pc, #332]	; (843c <am_devices_led_init+0x2dc>)
    82f0:	2273      	movs	r2, #115	; 0x73
    82f2:	601a      	str	r2, [r3, #0]
    82f4:	687b      	ldr	r3, [r7, #4]
    82f6:	681b      	ldr	r3, [r3, #0]
    82f8:	085b      	lsrs	r3, r3, #1
    82fa:	f003 027c 	and.w	r2, r3, #124	; 0x7c
    82fe:	4b50      	ldr	r3, [pc, #320]	; (8440 <am_devices_led_init+0x2e0>)
    8300:	4413      	add	r3, r2
    8302:	461c      	mov	r4, r3
    8304:	687b      	ldr	r3, [r7, #4]
    8306:	681b      	ldr	r3, [r3, #0]
    8308:	009b      	lsls	r3, r3, #2
    830a:	f003 031c 	and.w	r3, r3, #28
    830e:	2206      	movs	r2, #6
    8310:	409a      	lsls	r2, r3
    8312:	687b      	ldr	r3, [r7, #4]
    8314:	681b      	ldr	r3, [r3, #0]
    8316:	085b      	lsrs	r3, r3, #1
    8318:	f003 017c 	and.w	r1, r3, #124	; 0x7c
    831c:	4b48      	ldr	r3, [pc, #288]	; (8440 <am_devices_led_init+0x2e0>)
    831e:	440b      	add	r3, r1
    8320:	6819      	ldr	r1, [r3, #0]
    8322:	687b      	ldr	r3, [r7, #4]
    8324:	681b      	ldr	r3, [r3, #0]
    8326:	009b      	lsls	r3, r3, #2
    8328:	f003 031c 	and.w	r3, r3, #28
    832c:	2007      	movs	r0, #7
    832e:	fa00 f303 	lsl.w	r3, r0, r3
    8332:	43db      	mvns	r3, r3
    8334:	400b      	ands	r3, r1
    8336:	4313      	orrs	r3, r2
    8338:	6023      	str	r3, [r4, #0]
    833a:	687b      	ldr	r3, [r7, #4]
    833c:	681b      	ldr	r3, [r3, #0]
    833e:	f003 03fc 	and.w	r3, r3, #252	; 0xfc
    8342:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    8346:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
    834a:	461c      	mov	r4, r3
    834c:	687b      	ldr	r3, [r7, #4]
    834e:	681b      	ldr	r3, [r3, #0]
    8350:	00db      	lsls	r3, r3, #3
    8352:	f003 0318 	and.w	r3, r3, #24
    8356:	2218      	movs	r2, #24
    8358:	409a      	lsls	r2, r3
    835a:	687b      	ldr	r3, [r7, #4]
    835c:	681b      	ldr	r3, [r3, #0]
    835e:	f003 03fc 	and.w	r3, r3, #252	; 0xfc
    8362:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    8366:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
    836a:	6819      	ldr	r1, [r3, #0]
    836c:	687b      	ldr	r3, [r7, #4]
    836e:	681b      	ldr	r3, [r3, #0]
    8370:	00db      	lsls	r3, r3, #3
    8372:	f003 0318 	and.w	r3, r3, #24
    8376:	20ff      	movs	r0, #255	; 0xff
    8378:	fa00 f303 	lsl.w	r3, r0, r3
    837c:	43db      	mvns	r3, r3
    837e:	400b      	ands	r3, r1
    8380:	4313      	orrs	r3, r2
    8382:	6023      	str	r3, [r4, #0]
    8384:	687b      	ldr	r3, [r7, #4]
    8386:	681b      	ldr	r3, [r3, #0]
    8388:	f003 02fc 	and.w	r2, r3, #252	; 0xfc
    838c:	4b2d      	ldr	r3, [pc, #180]	; (8444 <am_devices_led_init+0x2e4>)
    838e:	4413      	add	r3, r2
    8390:	4618      	mov	r0, r3
    8392:	687b      	ldr	r3, [r7, #4]
    8394:	681b      	ldr	r3, [r3, #0]
    8396:	f003 02fc 	and.w	r2, r3, #252	; 0xfc
    839a:	4b2a      	ldr	r3, [pc, #168]	; (8444 <am_devices_led_init+0x2e4>)
    839c:	4413      	add	r3, r2
    839e:	681a      	ldr	r2, [r3, #0]
    83a0:	687b      	ldr	r3, [r7, #4]
    83a2:	681b      	ldr	r3, [r3, #0]
    83a4:	00db      	lsls	r3, r3, #3
    83a6:	f003 0318 	and.w	r3, r3, #24
    83aa:	21ff      	movs	r1, #255	; 0xff
    83ac:	fa01 f303 	lsl.w	r3, r1, r3
    83b0:	43db      	mvns	r3, r3
    83b2:	4013      	ands	r3, r2
    83b4:	6003      	str	r3, [r0, #0]
    83b6:	4b21      	ldr	r3, [pc, #132]	; (843c <am_devices_led_init+0x2dc>)
    83b8:	2200      	movs	r2, #0
    83ba:	601a      	str	r2, [r3, #0]
    83bc:	68bb      	ldr	r3, [r7, #8]
    83be:	4618      	mov	r0, r3
    83c0:	f001 fc24 	bl	9c0c <am_hal_interrupt_master_set>

        //
        // Disable the output driver, and set the output value to the LEDs "ON"
        // state.
        //
        am_hal_gpio_out_enable_bit_clear(psLED->ui32GPIONumber);
    83c4:	687b      	ldr	r3, [r7, #4]
    83c6:	681b      	ldr	r3, [r3, #0]
    83c8:	08db      	lsrs	r3, r3, #3
    83ca:	f003 0204 	and.w	r2, r3, #4
    83ce:	4b1e      	ldr	r3, [pc, #120]	; (8448 <am_devices_led_init+0x2e8>)
    83d0:	4413      	add	r3, r2
    83d2:	4619      	mov	r1, r3
    83d4:	687b      	ldr	r3, [r7, #4]
    83d6:	681b      	ldr	r3, [r3, #0]
    83d8:	f003 031f 	and.w	r3, r3, #31
    83dc:	2201      	movs	r2, #1
    83de:	fa02 f303 	lsl.w	r3, r2, r3
    83e2:	600b      	str	r3, [r1, #0]
        am_hal_gpio_out_bit_replace(psLED->ui32GPIONumber,
    83e4:	687b      	ldr	r3, [r7, #4]
    83e6:	685b      	ldr	r3, [r3, #4]
    83e8:	f003 0301 	and.w	r3, r3, #1
    83ec:	2b00      	cmp	r3, #0
    83ee:	d010      	beq.n	8412 <am_devices_led_init+0x2b2>
    83f0:	687b      	ldr	r3, [r7, #4]
    83f2:	681b      	ldr	r3, [r3, #0]
    83f4:	08db      	lsrs	r3, r3, #3
    83f6:	f003 0204 	and.w	r2, r3, #4
    83fa:	4b14      	ldr	r3, [pc, #80]	; (844c <am_devices_led_init+0x2ec>)
    83fc:	4413      	add	r3, r2
    83fe:	4619      	mov	r1, r3
    8400:	687b      	ldr	r3, [r7, #4]
    8402:	681b      	ldr	r3, [r3, #0]
    8404:	f003 031f 	and.w	r3, r3, #31
    8408:	2201      	movs	r2, #1
    840a:	fa02 f303 	lsl.w	r3, r2, r3
    840e:	600b      	str	r3, [r1, #0]
    8410:	e011      	b.n	8436 <am_devices_led_init+0x2d6>
    8412:	687b      	ldr	r3, [r7, #4]
    8414:	681b      	ldr	r3, [r3, #0]
    8416:	08db      	lsrs	r3, r3, #3
    8418:	f003 0204 	and.w	r2, r3, #4
    841c:	4b0c      	ldr	r3, [pc, #48]	; (8450 <am_devices_led_init+0x2f0>)
    841e:	4413      	add	r3, r2
    8420:	4619      	mov	r1, r3
    8422:	687b      	ldr	r3, [r7, #4]
    8424:	681b      	ldr	r3, [r3, #0]
    8426:	f003 031f 	and.w	r3, r3, #31
    842a:	2201      	movs	r2, #1
    842c:	fa02 f303 	lsl.w	r3, r2, r3
    8430:	600b      	str	r3, [r1, #0]
    8432:	e000      	b.n	8436 <am_devices_led_init+0x2d6>
        return;
    8434:	bf00      	nop
                                    psLED->ui32Polarity &
                                    AM_DEVICES_LED_POL_POLARITY_M );
    }
#endif
}
    8436:	3714      	adds	r7, #20
    8438:	46bd      	mov	sp, r7
    843a:	bd90      	pop	{r4, r7, pc}
    843c:	40010060 	.word	0x40010060
    8440:	40010040 	.word	0x40010040
    8444:	400100e0 	.word	0x400100e0
    8448:	400100b4 	.word	0x400100b4
    844c:	40010090 	.word	0x40010090
    8450:	40010098 	.word	0x40010098

00008454 <am_devices_led_array_init>:
//! @return None.
//
//*****************************************************************************
void
am_devices_led_array_init(am_devices_led_t *psLEDs, uint32_t ui32NumLEDs)
{
    8454:	b580      	push	{r7, lr}
    8456:	b084      	sub	sp, #16
    8458:	af00      	add	r7, sp, #0
    845a:	6078      	str	r0, [r7, #4]
    845c:	6039      	str	r1, [r7, #0]
    uint32_t i;

    if ( (psLEDs == NULL)                       ||
    845e:	687b      	ldr	r3, [r7, #4]
    8460:	2b00      	cmp	r3, #0
    8462:	d014      	beq.n	848e <am_devices_led_array_init+0x3a>
    8464:	683b      	ldr	r3, [r7, #0]
    8466:	2b1f      	cmp	r3, #31
    8468:	d811      	bhi.n	848e <am_devices_led_array_init+0x3a>
    }

    //
    // Loop through the list of LEDs, configuring each one individually.
    //
    for ( i = 0; i < ui32NumLEDs; i++ )
    846a:	2300      	movs	r3, #0
    846c:	60fb      	str	r3, [r7, #12]
    846e:	e009      	b.n	8484 <am_devices_led_array_init+0x30>
    {
        am_devices_led_init(psLEDs + i);
    8470:	68fb      	ldr	r3, [r7, #12]
    8472:	00db      	lsls	r3, r3, #3
    8474:	687a      	ldr	r2, [r7, #4]
    8476:	4413      	add	r3, r2
    8478:	4618      	mov	r0, r3
    847a:	f7ff fe71 	bl	8160 <am_devices_led_init>
    for ( i = 0; i < ui32NumLEDs; i++ )
    847e:	68fb      	ldr	r3, [r7, #12]
    8480:	3301      	adds	r3, #1
    8482:	60fb      	str	r3, [r7, #12]
    8484:	68fa      	ldr	r2, [r7, #12]
    8486:	683b      	ldr	r3, [r7, #0]
    8488:	429a      	cmp	r2, r3
    848a:	d3f1      	bcc.n	8470 <am_devices_led_array_init+0x1c>
    848c:	e000      	b.n	8490 <am_devices_led_array_init+0x3c>
        return;
    848e:	bf00      	nop
    }
}
    8490:	3710      	adds	r7, #16
    8492:	46bd      	mov	sp, r7
    8494:	bd80      	pop	{r7, pc}
	...

00008498 <am_devices_led_on>:
//! @return None.
//
//*****************************************************************************
void
am_devices_led_on(am_devices_led_t *psLEDs, uint32_t ui32LEDNum)
{
    8498:	b480      	push	{r7}
    849a:	b083      	sub	sp, #12
    849c:	af00      	add	r7, sp, #0
    849e:	6078      	str	r0, [r7, #4]
    84a0:	6039      	str	r1, [r7, #0]
    if ( (psLEDs == NULL)                       ||
    84a2:	687b      	ldr	r3, [r7, #4]
    84a4:	2b00      	cmp	r3, #0
    84a6:	d060      	beq.n	856a <am_devices_led_on+0xd2>
    84a8:	683b      	ldr	r3, [r7, #0]
    84aa:	2b1e      	cmp	r3, #30
    84ac:	d85d      	bhi.n	856a <am_devices_led_on+0xd2>
         (ui32LEDNum >= MAX_LEDS)               ||
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    84ae:	683b      	ldr	r3, [r7, #0]
    84b0:	00db      	lsls	r3, r3, #3
    84b2:	687a      	ldr	r2, [r7, #4]
    84b4:	4413      	add	r3, r2
    84b6:	681b      	ldr	r3, [r3, #0]
         (ui32LEDNum >= MAX_LEDS)               ||
    84b8:	2b31      	cmp	r3, #49	; 0x31
    84ba:	d856      	bhi.n	856a <am_devices_led_on+0xd2>
    }
#else // AM_APOLLO3_GPIO
    //
    // Handle Direct Drive Versus 3-State (with pull-up or no buffer).
    //
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    84bc:	683b      	ldr	r3, [r7, #0]
    84be:	00db      	lsls	r3, r3, #3
    84c0:	687a      	ldr	r2, [r7, #4]
    84c2:	4413      	add	r3, r2
    84c4:	685b      	ldr	r3, [r3, #4]
    84c6:	f003 0302 	and.w	r3, r3, #2
    84ca:	2b00      	cmp	r3, #0
    84cc:	d036      	beq.n	853c <am_devices_led_on+0xa4>
    {
        //
        // Set the output to the correct state for the LED.
        //
        am_hal_gpio_out_bit_replace(psLEDs[ui32LEDNum].ui32GPIONumber,
    84ce:	683b      	ldr	r3, [r7, #0]
    84d0:	00db      	lsls	r3, r3, #3
    84d2:	687a      	ldr	r2, [r7, #4]
    84d4:	4413      	add	r3, r2
    84d6:	685b      	ldr	r3, [r3, #4]
    84d8:	f003 0301 	and.w	r3, r3, #1
    84dc:	2b00      	cmp	r3, #0
    84de:	d016      	beq.n	850e <am_devices_led_on+0x76>
    84e0:	683b      	ldr	r3, [r7, #0]
    84e2:	00db      	lsls	r3, r3, #3
    84e4:	687a      	ldr	r2, [r7, #4]
    84e6:	4413      	add	r3, r2
    84e8:	681b      	ldr	r3, [r3, #0]
    84ea:	08db      	lsrs	r3, r3, #3
    84ec:	f003 0204 	and.w	r2, r3, #4
    84f0:	4b21      	ldr	r3, [pc, #132]	; (8578 <am_devices_led_on+0xe0>)
    84f2:	4413      	add	r3, r2
    84f4:	4619      	mov	r1, r3
    84f6:	683b      	ldr	r3, [r7, #0]
    84f8:	00db      	lsls	r3, r3, #3
    84fa:	687a      	ldr	r2, [r7, #4]
    84fc:	4413      	add	r3, r2
    84fe:	681b      	ldr	r3, [r3, #0]
    8500:	f003 031f 	and.w	r3, r3, #31
    8504:	2201      	movs	r2, #1
    8506:	fa02 f303 	lsl.w	r3, r2, r3
    850a:	600b      	str	r3, [r1, #0]
    850c:	e02e      	b.n	856c <am_devices_led_on+0xd4>
    850e:	683b      	ldr	r3, [r7, #0]
    8510:	00db      	lsls	r3, r3, #3
    8512:	687a      	ldr	r2, [r7, #4]
    8514:	4413      	add	r3, r2
    8516:	681b      	ldr	r3, [r3, #0]
    8518:	08db      	lsrs	r3, r3, #3
    851a:	f003 0204 	and.w	r2, r3, #4
    851e:	4b17      	ldr	r3, [pc, #92]	; (857c <am_devices_led_on+0xe4>)
    8520:	4413      	add	r3, r2
    8522:	4619      	mov	r1, r3
    8524:	683b      	ldr	r3, [r7, #0]
    8526:	00db      	lsls	r3, r3, #3
    8528:	687a      	ldr	r2, [r7, #4]
    852a:	4413      	add	r3, r2
    852c:	681b      	ldr	r3, [r3, #0]
    852e:	f003 031f 	and.w	r3, r3, #31
    8532:	2201      	movs	r2, #1
    8534:	fa02 f303 	lsl.w	r3, r2, r3
    8538:	600b      	str	r3, [r1, #0]
    853a:	e017      	b.n	856c <am_devices_led_on+0xd4>
    else
    {
        //
        // Turn on the output driver for the LED.
        //
        am_hal_gpio_out_enable_bit_set(psLEDs[ui32LEDNum].ui32GPIONumber);
    853c:	683b      	ldr	r3, [r7, #0]
    853e:	00db      	lsls	r3, r3, #3
    8540:	687a      	ldr	r2, [r7, #4]
    8542:	4413      	add	r3, r2
    8544:	681b      	ldr	r3, [r3, #0]
    8546:	08db      	lsrs	r3, r3, #3
    8548:	f003 0204 	and.w	r2, r3, #4
    854c:	4b0c      	ldr	r3, [pc, #48]	; (8580 <am_devices_led_on+0xe8>)
    854e:	4413      	add	r3, r2
    8550:	4619      	mov	r1, r3
    8552:	683b      	ldr	r3, [r7, #0]
    8554:	00db      	lsls	r3, r3, #3
    8556:	687a      	ldr	r2, [r7, #4]
    8558:	4413      	add	r3, r2
    855a:	681b      	ldr	r3, [r3, #0]
    855c:	f003 031f 	and.w	r3, r3, #31
    8560:	2201      	movs	r2, #1
    8562:	fa02 f303 	lsl.w	r3, r2, r3
    8566:	600b      	str	r3, [r1, #0]
    8568:	e000      	b.n	856c <am_devices_led_on+0xd4>
        return;
    856a:	bf00      	nop
    }
#endif //AM_APOLLO3_GPIO
}
    856c:	370c      	adds	r7, #12
    856e:	46bd      	mov	sp, r7
    8570:	f85d 7b04 	ldr.w	r7, [sp], #4
    8574:	4770      	bx	lr
    8576:	bf00      	nop
    8578:	40010090 	.word	0x40010090
    857c:	40010098 	.word	0x40010098
    8580:	400100a8 	.word	0x400100a8

00008584 <am_devices_led_off>:
//! @return None.
//
//*****************************************************************************
void
am_devices_led_off(am_devices_led_t *psLEDs, uint32_t ui32LEDNum)
{
    8584:	b480      	push	{r7}
    8586:	b083      	sub	sp, #12
    8588:	af00      	add	r7, sp, #0
    858a:	6078      	str	r0, [r7, #4]
    858c:	6039      	str	r1, [r7, #0]
    if ( (psLEDs == NULL)                       ||
    858e:	687b      	ldr	r3, [r7, #4]
    8590:	2b00      	cmp	r3, #0
    8592:	d060      	beq.n	8656 <am_devices_led_off+0xd2>
    8594:	683b      	ldr	r3, [r7, #0]
    8596:	2b1e      	cmp	r3, #30
    8598:	d85d      	bhi.n	8656 <am_devices_led_off+0xd2>
         (ui32LEDNum >= MAX_LEDS)               ||
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    859a:	683b      	ldr	r3, [r7, #0]
    859c:	00db      	lsls	r3, r3, #3
    859e:	687a      	ldr	r2, [r7, #4]
    85a0:	4413      	add	r3, r2
    85a2:	681b      	ldr	r3, [r3, #0]
         (ui32LEDNum >= MAX_LEDS)               ||
    85a4:	2b31      	cmp	r3, #49	; 0x31
    85a6:	d856      	bhi.n	8656 <am_devices_led_off+0xd2>
    }
#else
    //
    // Handle Direct Drive Versus 3-State (with pull-up or no buffer).
    //
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    85a8:	683b      	ldr	r3, [r7, #0]
    85aa:	00db      	lsls	r3, r3, #3
    85ac:	687a      	ldr	r2, [r7, #4]
    85ae:	4413      	add	r3, r2
    85b0:	685b      	ldr	r3, [r3, #4]
    85b2:	f003 0302 	and.w	r3, r3, #2
    85b6:	2b00      	cmp	r3, #0
    85b8:	d036      	beq.n	8628 <am_devices_led_off+0xa4>
    {
        //
        // Set the output to the correct state for the LED.
        //
        am_hal_gpio_out_bit_replace(psLEDs[ui32LEDNum].ui32GPIONumber,
    85ba:	683b      	ldr	r3, [r7, #0]
    85bc:	00db      	lsls	r3, r3, #3
    85be:	687a      	ldr	r2, [r7, #4]
    85c0:	4413      	add	r3, r2
    85c2:	685b      	ldr	r3, [r3, #4]
    85c4:	f003 0301 	and.w	r3, r3, #1
    85c8:	2b00      	cmp	r3, #0
    85ca:	d116      	bne.n	85fa <am_devices_led_off+0x76>
    85cc:	683b      	ldr	r3, [r7, #0]
    85ce:	00db      	lsls	r3, r3, #3
    85d0:	687a      	ldr	r2, [r7, #4]
    85d2:	4413      	add	r3, r2
    85d4:	681b      	ldr	r3, [r3, #0]
    85d6:	08db      	lsrs	r3, r3, #3
    85d8:	f003 0204 	and.w	r2, r3, #4
    85dc:	4b21      	ldr	r3, [pc, #132]	; (8664 <am_devices_led_off+0xe0>)
    85de:	4413      	add	r3, r2
    85e0:	4619      	mov	r1, r3
    85e2:	683b      	ldr	r3, [r7, #0]
    85e4:	00db      	lsls	r3, r3, #3
    85e6:	687a      	ldr	r2, [r7, #4]
    85e8:	4413      	add	r3, r2
    85ea:	681b      	ldr	r3, [r3, #0]
    85ec:	f003 031f 	and.w	r3, r3, #31
    85f0:	2201      	movs	r2, #1
    85f2:	fa02 f303 	lsl.w	r3, r2, r3
    85f6:	600b      	str	r3, [r1, #0]
    85f8:	e02e      	b.n	8658 <am_devices_led_off+0xd4>
    85fa:	683b      	ldr	r3, [r7, #0]
    85fc:	00db      	lsls	r3, r3, #3
    85fe:	687a      	ldr	r2, [r7, #4]
    8600:	4413      	add	r3, r2
    8602:	681b      	ldr	r3, [r3, #0]
    8604:	08db      	lsrs	r3, r3, #3
    8606:	f003 0204 	and.w	r2, r3, #4
    860a:	4b17      	ldr	r3, [pc, #92]	; (8668 <am_devices_led_off+0xe4>)
    860c:	4413      	add	r3, r2
    860e:	4619      	mov	r1, r3
    8610:	683b      	ldr	r3, [r7, #0]
    8612:	00db      	lsls	r3, r3, #3
    8614:	687a      	ldr	r2, [r7, #4]
    8616:	4413      	add	r3, r2
    8618:	681b      	ldr	r3, [r3, #0]
    861a:	f003 031f 	and.w	r3, r3, #31
    861e:	2201      	movs	r2, #1
    8620:	fa02 f303 	lsl.w	r3, r2, r3
    8624:	600b      	str	r3, [r1, #0]
    8626:	e017      	b.n	8658 <am_devices_led_off+0xd4>
    else
    {
        //
        // Turn off the output driver for the LED.
        //
        am_hal_gpio_out_enable_bit_clear(psLEDs[ui32LEDNum].ui32GPIONumber);
    8628:	683b      	ldr	r3, [r7, #0]
    862a:	00db      	lsls	r3, r3, #3
    862c:	687a      	ldr	r2, [r7, #4]
    862e:	4413      	add	r3, r2
    8630:	681b      	ldr	r3, [r3, #0]
    8632:	08db      	lsrs	r3, r3, #3
    8634:	f003 0204 	and.w	r2, r3, #4
    8638:	4b0c      	ldr	r3, [pc, #48]	; (866c <am_devices_led_off+0xe8>)
    863a:	4413      	add	r3, r2
    863c:	4619      	mov	r1, r3
    863e:	683b      	ldr	r3, [r7, #0]
    8640:	00db      	lsls	r3, r3, #3
    8642:	687a      	ldr	r2, [r7, #4]
    8644:	4413      	add	r3, r2
    8646:	681b      	ldr	r3, [r3, #0]
    8648:	f003 031f 	and.w	r3, r3, #31
    864c:	2201      	movs	r2, #1
    864e:	fa02 f303 	lsl.w	r3, r2, r3
    8652:	600b      	str	r3, [r1, #0]
    8654:	e000      	b.n	8658 <am_devices_led_off+0xd4>
        return;
    8656:	bf00      	nop
    }
#endif
}
    8658:	370c      	adds	r7, #12
    865a:	46bd      	mov	sp, r7
    865c:	f85d 7b04 	ldr.w	r7, [sp], #4
    8660:	4770      	bx	lr
    8662:	bf00      	nop
    8664:	40010090 	.word	0x40010090
    8668:	40010098 	.word	0x40010098
    866c:	400100b4 	.word	0x400100b4

00008670 <am_devices_led_array_out>:
//
//*****************************************************************************
void
am_devices_led_array_out(am_devices_led_t *psLEDs, uint32_t ui32NumLEDs,
                         uint32_t ui32Value)
{
    8670:	b580      	push	{r7, lr}
    8672:	b086      	sub	sp, #24
    8674:	af00      	add	r7, sp, #0
    8676:	60f8      	str	r0, [r7, #12]
    8678:	60b9      	str	r1, [r7, #8]
    867a:	607a      	str	r2, [r7, #4]
    uint32_t i;

    for ( i = 0; i < ui32NumLEDs; i++ )
    867c:	2300      	movs	r3, #0
    867e:	617b      	str	r3, [r7, #20]
    8680:	e014      	b.n	86ac <am_devices_led_array_out+0x3c>
    {
        if ( ui32Value & (1 << i) )
    8682:	2201      	movs	r2, #1
    8684:	697b      	ldr	r3, [r7, #20]
    8686:	fa02 f303 	lsl.w	r3, r2, r3
    868a:	461a      	mov	r2, r3
    868c:	687b      	ldr	r3, [r7, #4]
    868e:	4013      	ands	r3, r2
    8690:	2b00      	cmp	r3, #0
    8692:	d004      	beq.n	869e <am_devices_led_array_out+0x2e>
        {
            am_devices_led_on(psLEDs, i);
    8694:	6979      	ldr	r1, [r7, #20]
    8696:	68f8      	ldr	r0, [r7, #12]
    8698:	f7ff fefe 	bl	8498 <am_devices_led_on>
    869c:	e003      	b.n	86a6 <am_devices_led_array_out+0x36>
        }
        else
        {
            am_devices_led_off(psLEDs, i);
    869e:	6979      	ldr	r1, [r7, #20]
    86a0:	68f8      	ldr	r0, [r7, #12]
    86a2:	f7ff ff6f 	bl	8584 <am_devices_led_off>
    for ( i = 0; i < ui32NumLEDs; i++ )
    86a6:	697b      	ldr	r3, [r7, #20]
    86a8:	3301      	adds	r3, #1
    86aa:	617b      	str	r3, [r7, #20]
    86ac:	697a      	ldr	r2, [r7, #20]
    86ae:	68bb      	ldr	r3, [r7, #8]
    86b0:	429a      	cmp	r2, r3
    86b2:	d3e6      	bcc.n	8682 <am_devices_led_array_out+0x12>
        }
    }
}
    86b4:	bf00      	nop
    86b6:	3718      	adds	r7, #24
    86b8:	46bd      	mov	sp, r7
    86ba:	bd80      	pop	{r7, pc}

000086bc <timerA0_init>:
// Function to initialize Timer A0 to interrupt every 1/4 second.
//
//*****************************************************************************
void
timerA0_init(void)
{
    86bc:	b580      	push	{r7, lr}
    86be:	b082      	sub	sp, #8
    86c0:	af00      	add	r7, sp, #0
    uint32_t ui32Period;

    //
    // Enable the LFRC.
    //
    am_hal_clkgen_osc_start(AM_HAL_CLKGEN_OSC_LFRC);
    86c2:	2002      	movs	r0, #2
    86c4:	f001 f948 	bl	9958 <am_hal_clkgen_osc_start>

    //
    // Set up timer A0.
    //
    am_hal_ctimer_clear(0, AM_HAL_CTIMER_TIMERA);
    86c8:	f64f 71ff 	movw	r1, #65535	; 0xffff
    86cc:	2000      	movs	r0, #0
    86ce:	f001 f9e1 	bl	9a94 <am_hal_ctimer_clear>
    am_hal_ctimer_config(0, &g_sTimer0);
    86d2:	490a      	ldr	r1, [pc, #40]	; (86fc <timerA0_init+0x40>)
    86d4:	2000      	movs	r0, #0
    86d6:	f001 f953 	bl	9980 <am_hal_ctimer_config>

    //
    // Set up timerA0 to 32Hz from LFRC divided to 1 second period.
    //
    ui32Period = 8;
    86da:	2308      	movs	r3, #8
    86dc:	607b      	str	r3, [r7, #4]
    am_hal_ctimer_period_set(0, AM_HAL_CTIMER_TIMERA, ui32Period,
    86de:	687b      	ldr	r3, [r7, #4]
    86e0:	085b      	lsrs	r3, r3, #1
    86e2:	687a      	ldr	r2, [r7, #4]
    86e4:	f64f 71ff 	movw	r1, #65535	; 0xffff
    86e8:	2000      	movs	r0, #0
    86ea:	f001 f9e7 	bl	9abc <am_hal_ctimer_period_set>
                             (ui32Period >> 1));

    //
    // Clear the timer Interrupt
    //
    am_hal_ctimer_int_clear(AM_HAL_CTIMER_INT_TIMERA0);
    86ee:	2001      	movs	r0, #1
    86f0:	f001 fa50 	bl	9b94 <am_hal_ctimer_int_clear>
}
    86f4:	bf00      	nop
    86f6:	3708      	adds	r7, #8
    86f8:	46bd      	mov	sp, r7
    86fa:	bd80      	pop	{r7, pc}
    86fc:	10001000 	.word	0x10001000

00008700 <am_ctimer_isr>:
// Timer Interrupt Service Routine (ISR)
//
//*****************************************************************************
void
am_ctimer_isr(void)
{
    8700:	b580      	push	{r7, lr}
    8702:	af00      	add	r7, sp, #0
    //
    // Clear TimerA0 Interrupt (write to clear).
    //
    am_hal_ctimer_int_clear(AM_HAL_CTIMER_INT_TIMERA0);
    8704:	2001      	movs	r0, #1
    8706:	f001 fa45 	bl	9b94 <am_hal_ctimer_int_clear>

    //
    // Increment count and set limit based on the number of LEDs available.
    //
    if (++g_ui32TimerCount >= (1 << AM_BSP_NUM_LEDS))
    870a:	4b06      	ldr	r3, [pc, #24]	; (8724 <am_ctimer_isr+0x24>)
    870c:	681b      	ldr	r3, [r3, #0]
    870e:	3301      	adds	r3, #1
    8710:	4a04      	ldr	r2, [pc, #16]	; (8724 <am_ctimer_isr+0x24>)
    8712:	6013      	str	r3, [r2, #0]
    8714:	2b1f      	cmp	r3, #31
    8716:	d902      	bls.n	871e <am_ctimer_isr+0x1e>
    {
        //
        // Reset the global.
        //
        g_ui32TimerCount = 0;
    8718:	4b02      	ldr	r3, [pc, #8]	; (8724 <am_ctimer_isr+0x24>)
    871a:	2200      	movs	r2, #0
    871c:	601a      	str	r2, [r3, #0]
    }
}
    871e:	bf00      	nop
    8720:	bd80      	pop	{r7, pc}
    8722:	bf00      	nop
    8724:	10001034 	.word	0x10001034

00008728 <main>:
// Main function.
//
//*****************************************************************************
int
main(void)
{
    8728:	b580      	push	{r7, lr}
    872a:	b082      	sub	sp, #8
    872c:	af00      	add	r7, sp, #0
    //
    // Set the clock frequency.
    //
    am_hal_clkgen_sysclk_select(AM_HAL_CLKGEN_SYSCLK_MAX);
    872e:	2000      	movs	r0, #0
    8730:	f001 f8ea 	bl	9908 <am_hal_clkgen_sysclk_select>

    //
    // Set the default cache configuration
    //
    am_hal_cachectrl_enable(&am_hal_cachectrl_defaults);
    8734:	4829      	ldr	r0, [pc, #164]	; (87dc <main+0xb4>)
    8736:	f001 f851 	bl	97dc <am_hal_cachectrl_enable>

    //
    // Configure the board for low power operation.
    //
    am_bsp_low_power_init();
    873a:	f000 ffc7 	bl	96cc <am_bsp_low_power_init>

    //
    // Initialize the printf interface for ITM/SWO output.
    //
    am_util_stdio_printf_init((am_util_stdio_print_char_t) am_bsp_itm_string_print);
    873e:	4828      	ldr	r0, [pc, #160]	; (87e0 <main+0xb8>)
    8740:	f000 f918 	bl	8974 <am_util_stdio_printf_init>

    //
    // Initialize the SWO GPIO pin
    //
    am_bsp_pin_enable(ITM_SWO);
    8744:	f001 fa5e 	bl	9c04 <am_hal_interrupt_master_disable>
    8748:	4603      	mov	r3, r0
    874a:	607b      	str	r3, [r7, #4]
    874c:	4b25      	ldr	r3, [pc, #148]	; (87e4 <main+0xbc>)
    874e:	2273      	movs	r2, #115	; 0x73
    8750:	601a      	str	r2, [r3, #0]
    8752:	4a25      	ldr	r2, [pc, #148]	; (87e8 <main+0xc0>)
    8754:	4b24      	ldr	r3, [pc, #144]	; (87e8 <main+0xc0>)
    8756:	681b      	ldr	r3, [r3, #0]
    8758:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    875c:	6013      	str	r3, [r2, #0]
    875e:	4a23      	ldr	r2, [pc, #140]	; (87ec <main+0xc4>)
    8760:	4b22      	ldr	r3, [pc, #136]	; (87ec <main+0xc4>)
    8762:	681b      	ldr	r3, [r3, #0]
    8764:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
    8768:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    876c:	6013      	str	r3, [r2, #0]
    876e:	4a20      	ldr	r2, [pc, #128]	; (87f0 <main+0xc8>)
    8770:	4b1f      	ldr	r3, [pc, #124]	; (87f0 <main+0xc8>)
    8772:	681b      	ldr	r3, [r3, #0]
    8774:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
    8778:	6013      	str	r3, [r2, #0]
    877a:	4b1a      	ldr	r3, [pc, #104]	; (87e4 <main+0xbc>)
    877c:	2200      	movs	r2, #0
    877e:	601a      	str	r2, [r3, #0]
    8780:	687b      	ldr	r3, [r7, #4]
    8782:	4618      	mov	r0, r3
    8784:	f001 fa42 	bl	9c0c <am_hal_interrupt_master_set>
    am_devices_led_array_init(am_bsp_psLEDs, AM_BSP_NUM_LEDS);
    8788:	2105      	movs	r1, #5
    878a:	481a      	ldr	r0, [pc, #104]	; (87f4 <main+0xcc>)
    878c:	f7ff fe62 	bl	8454 <am_devices_led_array_init>

    //
    // Enable the ITM.
    //
    am_hal_itm_enable();
    8790:	f001 fa40 	bl	9c14 <am_hal_itm_enable>

    //
    // Enable debug printf messages using ITM on SWO pin
    //
    am_bsp_debug_printf_enable();
    8794:	f000 ffac 	bl	96f0 <am_bsp_debug_printf_enable>

    //
    // Clear the terminal and print the banner.
    //
    am_util_stdio_terminal_clear();
    8798:	f000 ff8e 	bl	96b8 <am_util_stdio_terminal_clear>
    am_util_stdio_printf("Binary Counter Example\n");
    879c:	4816      	ldr	r0, [pc, #88]	; (87f8 <main+0xd0>)
    879e:	f000 ff6d 	bl	967c <am_util_stdio_printf>

    //
    // TimerA0 init.
    //
    timerA0_init();
    87a2:	f7ff ff8b 	bl	86bc <timerA0_init>

    //
    // Enable the timer Interrupt.
    //
    am_hal_ctimer_int_enable(AM_HAL_CTIMER_INT_TIMERA0);
    87a6:	2001      	movs	r0, #1
    87a8:	f001 f9e2 	bl	9b70 <am_hal_ctimer_int_enable>

    //
    // Enable the timer interrupt in the NVIC.
    //
    am_hal_interrupt_enable(AM_HAL_INTERRUPT_CTIMER);
    87ac:	201d      	movs	r0, #29
    87ae:	f001 f9fd 	bl	9bac <am_hal_interrupt_enable>
    am_hal_interrupt_master_enable();
    87b2:	f001 fa23 	bl	9bfc <am_hal_interrupt_master_enable>

    //
    // Start timer A0
    //
    am_hal_ctimer_start(0, AM_HAL_CTIMER_TIMERA);
    87b6:	f64f 71ff 	movw	r1, #65535	; 0xffff
    87ba:	2000      	movs	r0, #0
    87bc:	f001 f952 	bl	9a64 <am_hal_ctimer_start>

    //
    // We are done printing. Disable debug printf messages on ITM.
    //
    am_bsp_debug_printf_disable();
    87c0:	f000 ffd6 	bl	9770 <am_bsp_debug_printf_disable>
    while (1)
    {
        //
        // Go to Deep Sleep.
        //
        am_hal_sysctrl_sleep(AM_HAL_SYSCTRL_SLEEP_DEEP);
    87c4:	2001      	movs	r0, #1
    87c6:	f001 fc33 	bl	a030 <am_hal_sysctrl_sleep>

        //
        // Set the LEDs.
        //
        am_devices_led_array_out(am_bsp_psLEDs, AM_BSP_NUM_LEDS,
    87ca:	4b0c      	ldr	r3, [pc, #48]	; (87fc <main+0xd4>)
    87cc:	681b      	ldr	r3, [r3, #0]
    87ce:	461a      	mov	r2, r3
    87d0:	2105      	movs	r1, #5
    87d2:	4808      	ldr	r0, [pc, #32]	; (87f4 <main+0xcc>)
    87d4:	f7ff ff4c 	bl	8670 <am_devices_led_array_out>
        am_hal_sysctrl_sleep(AM_HAL_SYSCTRL_SLEEP_DEEP);
    87d8:	e7f4      	b.n	87c4 <main+0x9c>
    87da:	bf00      	nop
    87dc:	0000a260 	.word	0x0000a260
    87e0:	000097d9 	.word	0x000097d9
    87e4:	40010060 	.word	0x40010060
    87e8:	40010054 	.word	0x40010054
    87ec:	40010028 	.word	0x40010028
    87f0:	40010108 	.word	0x40010108
    87f4:	1000100c 	.word	0x1000100c
    87f8:	0000a234 	.word	0x0000a234
    87fc:	10001034 	.word	0x10001034

00008800 <am_reset_isr>:
am_reset_isr(void)
{
    //
    // Set the vector table pointer.
    //
    __asm("    ldr    r0, =0xE000ED08\n"
    8800:	4811      	ldr	r0, [pc, #68]	; (8848 <zero_loop+0x12>)
    8802:	4912      	ldr	r1, [pc, #72]	; (884c <zero_loop+0x16>)
    8804:	6001      	str	r1, [r0, #0]
          "    str    r1, [r0]");

    //
    // Set the stack pointer.
    //
    __asm("    ldr    sp, [r1]");
    8806:	f8d1 d000 	ldr.w	sp, [r1]
#ifndef NOFPU
    //
    // Enable the FPU.
    //
    __asm("ldr  r0, =0xE000ED88\n"
    880a:	4811      	ldr	r0, [pc, #68]	; (8850 <zero_loop+0x1a>)
    880c:	6801      	ldr	r1, [r0, #0]
    880e:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    8812:	6001      	str	r1, [r0, #0]
    8814:	f3bf 8f4f 	dsb	sy
    8818:	f3bf 8f6f 	isb	sy
          "isb\n");
#endif
    //
    // Copy the data segment initializers from flash to SRAM.
    //
    __asm("    ldr     r0, =_init_data\n"
    881c:	480d      	ldr	r0, [pc, #52]	; (8854 <zero_loop+0x1e>)
    881e:	490e      	ldr	r1, [pc, #56]	; (8858 <zero_loop+0x22>)
    8820:	4a0e      	ldr	r2, [pc, #56]	; (885c <zero_loop+0x26>)

00008822 <copy_loop>:
    8822:	f850 3b04 	ldr.w	r3, [r0], #4
    8826:	f841 3b04 	str.w	r3, [r1], #4
    882a:	4291      	cmp	r1, r2
    882c:	dbf9      	blt.n	8822 <copy_loop>
          "        cmp     r1, r2\n"
          "        blt     copy_loop\n");
    //
    // Zero fill the bss segment.
    //
    __asm("    ldr     r0, =_sbss\n"
    882e:	480c      	ldr	r0, [pc, #48]	; (8860 <zero_loop+0x2a>)
    8830:	490c      	ldr	r1, [pc, #48]	; (8864 <zero_loop+0x2e>)
    8832:	f04f 0200 	mov.w	r2, #0

00008836 <zero_loop>:
    8836:	4288      	cmp	r0, r1
    8838:	bfb8      	it	lt
    883a:	f840 2b04 	strlt.w	r2, [r0], #4
    883e:	dbfa      	blt.n	8836 <zero_loop>
          "        blt     zero_loop");

    //
    // Call the application's entry point.
    //
    main();
    8840:	f7ff ff72 	bl	8728 <main>

    //
    // If main returns then execute a break point instruction
    //
    __asm("    bkpt     ");
    8844:	be00      	bkpt	0x0000
}
    8846:	bf00      	nop
    8848:	e000ed08 	.word	0xe000ed08
    884c:	00008000 	.word	0x00008000
    8850:	e000ed88 	.word	0xe000ed88
    8854:	0000a2bc 	.word	0x0000a2bc
    8858:	10001000 	.word	0x10001000
    885c:	10001034 	.word	0x10001034
    8860:	10001034 	.word	0x10001034
    8864:	10001150 	.word	0x10001150

00008868 <am_nmi_isr>:
// by a debugger.
//
//*****************************************************************************
void
am_nmi_isr(void)
{
    8868:	b480      	push	{r7}
    886a:	af00      	add	r7, sp, #0
    //
    // Go into an infinite loop.
    //
    while(1)
    886c:	e7fe      	b.n	886c <am_nmi_isr+0x4>

0000886e <am_adc_isr>:
// for examination by a debugger.
//
//*****************************************************************************
void
am_default_isr(void)
{
    886e:	b480      	push	{r7}
    8870:	af00      	add	r7, sp, #0
    //
    // Go into an infinite loop.
    //
    while(1)
    8872:	e7fe      	b.n	8872 <am_adc_isr+0x4>

00008874 <am_fault_isr>:
}
#elif defined(__GNUC_STDC_INLINE__)
uint32_t __attribute__((naked))
am_fault_isr(void)
{
    __asm("    push    {r7,lr}");
    8874:	b580      	push	{r7, lr}
    __asm("    mov     r0, sp");
    8876:	4668      	mov	r0, sp
    __asm("    adds    r0, #(2*4)");
    8878:	3008      	adds	r0, #8
    __asm("    bl      am_util_faultisr_collect_data");
    887a:	f000 f809 	bl	8890 <am_util_faultisr_collect_data>
    __asm("    pop     {r0,pc}");
    887e:	bd01      	pop	{r0, pc}
}
    8880:	bf00      	nop
    8882:	4618      	mov	r0, r3

00008884 <getStackedReg>:

uint32_t __attribute__((naked))
getStackedReg(uint32_t regnum, uint32_t u32SP)
{
    __asm("    lsls    r0, r0, #2");
    8884:	0080      	lsls	r0, r0, #2
    __asm("    adds    r0, r1");
    8886:	1840      	adds	r0, r0, r1
    __asm("    ldr     r0, [r0]");
    8888:	6800      	ldr	r0, [r0, #0]
    __asm("    bx      lr");
    888a:	4770      	bx	lr
}
    888c:	bf00      	nop
    888e:	4618      	mov	r0, r3

00008890 <am_util_faultisr_collect_data>:
// am_fault_isr() was called.
//
//*****************************************************************************
void
am_util_faultisr_collect_data(uint32_t u32IsrSP)
{
    8890:	b580      	push	{r7, lr}
    8892:	b096      	sub	sp, #88	; 0x58
    8894:	af00      	add	r7, sp, #0
    8896:	6078      	str	r0, [r7, #4]
    volatile am_fault_t sFaultData;
    am_hal_mcuctrl_fault_t sHalFaultData = {0};
    8898:	f107 030c 	add.w	r3, r7, #12
    889c:	2200      	movs	r2, #0
    889e:	601a      	str	r2, [r3, #0]
    88a0:	605a      	str	r2, [r3, #4]
    88a2:	609a      	str	r2, [r3, #8]
    88a4:	60da      	str	r2, [r3, #12]
    88a6:	611a      	str	r2, [r3, #16]
    88a8:	615a      	str	r2, [r3, #20]

    uint32_t u32Mask = 0;
    88aa:	2300      	movs	r3, #0
    88ac:	657b      	str	r3, [r7, #84]	; 0x54
    // u32Mask is used for 2 things: 1) in the print loop, 2) as a spot to set
    // a breakpoint at the end of the routine.  If the printing is not used,
    // we'll get a compiler warning; so to avoid that warning, we'll use it
    // in a dummy assignment here.
    //
    sFaultData.u32CFSR = u32Mask;       // Avoid compiler warning
    88ae:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    88b0:	64fb      	str	r3, [r7, #76]	; 0x4c
    sFaultData.u32CFSR = AM_REGVAL(AM_REG_SYSCTRL_CFSR_O);
    88b2:	4b2e      	ldr	r3, [pc, #184]	; (896c <am_util_faultisr_collect_data+0xdc>)
    88b4:	681b      	ldr	r3, [r3, #0]
    88b6:	64fb      	str	r3, [r7, #76]	; 0x4c
    sFaultData.u8MMSR  = (sFaultData.u32CFSR >> 0)  & 0xff;
    88b8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    88ba:	b2db      	uxtb	r3, r3
    88bc:	f887 3050 	strb.w	r3, [r7, #80]	; 0x50
    sFaultData.u8BFSR  = (sFaultData.u32CFSR >> 8)  & 0xff;
    88c0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    88c2:	0a1b      	lsrs	r3, r3, #8
    88c4:	b2db      	uxtb	r3, r3
    88c6:	f887 3051 	strb.w	r3, [r7, #81]	; 0x51
    sFaultData.u16UFSR = (sFaultData.u32CFSR >> 16) & 0xffff;
    88ca:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    88cc:	0c1b      	lsrs	r3, r3, #16
    88ce:	b29b      	uxth	r3, r3
    88d0:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52

    //
    // The address of the location that caused the fault.  e.g. if accessing an
    // invalid data location caused the fault, that address will appear here.
    //
    sFaultData.u32BFAR = AM_REGVAL(AM_REG_SYSCTRL_BFAR_O);
    88d4:	4b26      	ldr	r3, [pc, #152]	; (8970 <am_util_faultisr_collect_data+0xe0>)
    88d6:	681b      	ldr	r3, [r3, #0]
    88d8:	64bb      	str	r3, [r7, #72]	; 0x48

    //
    // The address of the instruction that caused the fault is the stacked PC
    // if BFSR bit1 is set.
    //
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    88da:	f897 3051 	ldrb.w	r3, [r7, #81]	; 0x51
    88de:	b2db      	uxtb	r3, r3
    88e0:	f003 0302 	and.w	r3, r3, #2
    88e4:	2b00      	cmp	r3, #0
    88e6:	d005      	beq.n	88f4 <am_util_faultisr_collect_data+0x64>
    88e8:	6879      	ldr	r1, [r7, #4]
    88ea:	2006      	movs	r0, #6
    88ec:	f7ff ffca 	bl	8884 <getStackedReg>
    88f0:	4603      	mov	r3, r0
    88f2:	e001      	b.n	88f8 <am_util_faultisr_collect_data+0x68>
    88f4:	f04f 33ff 	mov.w	r3, #4294967295
    88f8:	647b      	str	r3, [r7, #68]	; 0x44

    //
    // Get the stacked registers.
    // Note - the address of the instruction that caused the fault is u32PC.
    //
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    88fa:	6879      	ldr	r1, [r7, #4]
    88fc:	2000      	movs	r0, #0
    88fe:	f7ff ffc1 	bl	8884 <getStackedReg>
    8902:	4603      	mov	r3, r0
    8904:	627b      	str	r3, [r7, #36]	; 0x24
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    8906:	6879      	ldr	r1, [r7, #4]
    8908:	2001      	movs	r0, #1
    890a:	f7ff ffbb 	bl	8884 <getStackedReg>
    890e:	4603      	mov	r3, r0
    8910:	62bb      	str	r3, [r7, #40]	; 0x28
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    8912:	6879      	ldr	r1, [r7, #4]
    8914:	2002      	movs	r0, #2
    8916:	f7ff ffb5 	bl	8884 <getStackedReg>
    891a:	4603      	mov	r3, r0
    891c:	62fb      	str	r3, [r7, #44]	; 0x2c
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    891e:	6879      	ldr	r1, [r7, #4]
    8920:	2003      	movs	r0, #3
    8922:	f7ff ffaf 	bl	8884 <getStackedReg>
    8926:	4603      	mov	r3, r0
    8928:	633b      	str	r3, [r7, #48]	; 0x30
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    892a:	6879      	ldr	r1, [r7, #4]
    892c:	2004      	movs	r0, #4
    892e:	f7ff ffa9 	bl	8884 <getStackedReg>
    8932:	4603      	mov	r3, r0
    8934:	637b      	str	r3, [r7, #52]	; 0x34
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    8936:	6879      	ldr	r1, [r7, #4]
    8938:	2005      	movs	r0, #5
    893a:	f7ff ffa3 	bl	8884 <getStackedReg>
    893e:	4603      	mov	r3, r0
    8940:	63bb      	str	r3, [r7, #56]	; 0x38
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    8942:	6879      	ldr	r1, [r7, #4]
    8944:	2006      	movs	r0, #6
    8946:	f7ff ff9d 	bl	8884 <getStackedReg>
    894a:	4603      	mov	r3, r0
    894c:	63fb      	str	r3, [r7, #60]	; 0x3c
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    894e:	6879      	ldr	r1, [r7, #4]
    8950:	2007      	movs	r0, #7
    8952:	f7ff ff97 	bl	8884 <getStackedReg>
    8956:	4603      	mov	r3, r0
    8958:	643b      	str	r3, [r7, #64]	; 0x40
    // Use the HAL MCUCTRL functions to read the fault data.
    //
#ifdef AM_APOLLO3_MCUCTRL
    am_hal_mcuctrl_info_get(AM_HAL_MCUCTRL_INFO_FAULT_STATUS, &sHalFaultData);
#else
    am_hal_mcuctrl_fault_status(&sHalFaultData);
    895a:	f107 030c 	add.w	r3, r7, #12
    895e:	4618      	mov	r0, r3
    8960:	f001 f9a8 	bl	9cb4 <am_hal_mcuctrl_fault_status>
    }


#endif

    u32Mask = 0;
    8964:	2300      	movs	r3, #0
    8966:	657b      	str	r3, [r7, #84]	; 0x54
    //
    // Spin in an infinite loop.
    // We need to spin here inside the function so that we have access to
    // local data, i.e. sFaultData.
    //
    while(1)
    8968:	e7fe      	b.n	8968 <am_util_faultisr_collect_data+0xd8>
    896a:	bf00      	nop
    896c:	e000ed28 	.word	0xe000ed28
    8970:	e000ed38 	.word	0xe000ed38

00008974 <am_util_stdio_printf_init>:
//! @return None.
//
//*****************************************************************************
void
am_util_stdio_printf_init(am_util_stdio_print_char_t pfnCharPrint)
{
    8974:	b480      	push	{r7}
    8976:	b083      	sub	sp, #12
    8978:	af00      	add	r7, sp, #0
    897a:	6078      	str	r0, [r7, #4]
    g_pfnCharPrint = pfnCharPrint;
    897c:	4a04      	ldr	r2, [pc, #16]	; (8990 <am_util_stdio_printf_init+0x1c>)
    897e:	687b      	ldr	r3, [r7, #4]
    8980:	6013      	str	r3, [r2, #0]
}
    8982:	bf00      	nop
    8984:	370c      	adds	r7, #12
    8986:	46bd      	mov	sp, r7
    8988:	f85d 7b04 	ldr.w	r7, [sp], #4
    898c:	4770      	bx	lr
    898e:	bf00      	nop
    8990:	1000114c 	.word	0x1000114c

00008994 <divu64_10>:
//  Note: Adapted from Ch10 of Hackers Delight (hackersdelight.org).
//
//*****************************************************************************
static uint64_t
divu64_10(uint64_t ui64Val)
{
    8994:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    8998:	b096      	sub	sp, #88	; 0x58
    899a:	af00      	add	r7, sp, #0
    899c:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
    uint32_t q32, r32, ui32Val;

    //
    // If a 32-bit value, use the more optimal 32-bit routine.
    //
    if ( ui64Val >> 32 )
    89a0:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
    89a4:	0025      	movs	r5, r4
    89a6:	2600      	movs	r6, #0
    89a8:	ea55 0306 	orrs.w	r3, r5, r6
    89ac:	f000 80a0 	beq.w	8af0 <divu64_10+0x15c>
    {
        q64 = (ui64Val>>1) + (ui64Val>>2);
    89b0:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
    89b4:	0862      	lsrs	r2, r4, #1
    89b6:	ea4f 0133 	mov.w	r1, r3, rrx
    89ba:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
    89be:	ea4f 0893 	mov.w	r8, r3, lsr #2
    89c2:	ea48 7884 	orr.w	r8, r8, r4, lsl #30
    89c6:	ea4f 0994 	mov.w	r9, r4, lsr #2
    89ca:	eb11 0308 	adds.w	r3, r1, r8
    89ce:	eb42 0409 	adc.w	r4, r2, r9
    89d2:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        q64 += (q64 >> 4);
    89d6:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    89da:	ea4f 1a13 	mov.w	sl, r3, lsr #4
    89de:	ea4a 7a04 	orr.w	sl, sl, r4, lsl #28
    89e2:	ea4f 1b14 	mov.w	fp, r4, lsr #4
    89e6:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    89ea:	eb13 030a 	adds.w	r3, r3, sl
    89ee:	eb44 040b 	adc.w	r4, r4, fp
    89f2:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        q64 += (q64 >> 8);
    89f6:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    89fa:	0a1a      	lsrs	r2, r3, #8
    89fc:	62ba      	str	r2, [r7, #40]	; 0x28
    89fe:	6aba      	ldr	r2, [r7, #40]	; 0x28
    8a00:	ea42 6204 	orr.w	r2, r2, r4, lsl #24
    8a04:	62ba      	str	r2, [r7, #40]	; 0x28
    8a06:	0a23      	lsrs	r3, r4, #8
    8a08:	62fb      	str	r3, [r7, #44]	; 0x2c
    8a0a:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    8a0e:	e9d7 120a 	ldrd	r1, r2, [r7, #40]	; 0x28
    8a12:	18c9      	adds	r1, r1, r3
    8a14:	eb42 0204 	adc.w	r2, r2, r4
    8a18:	460b      	mov	r3, r1
    8a1a:	4614      	mov	r4, r2
    8a1c:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        q64 += (q64 >> 16);
    8a20:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    8a24:	0c1a      	lsrs	r2, r3, #16
    8a26:	623a      	str	r2, [r7, #32]
    8a28:	6a3a      	ldr	r2, [r7, #32]
    8a2a:	ea42 4204 	orr.w	r2, r2, r4, lsl #16
    8a2e:	623a      	str	r2, [r7, #32]
    8a30:	0c23      	lsrs	r3, r4, #16
    8a32:	627b      	str	r3, [r7, #36]	; 0x24
    8a34:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    8a38:	e9d7 1208 	ldrd	r1, r2, [r7, #32]
    8a3c:	18c9      	adds	r1, r1, r3
    8a3e:	eb42 0204 	adc.w	r2, r2, r4
    8a42:	460b      	mov	r3, r1
    8a44:	4614      	mov	r4, r2
    8a46:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        q64 += (q64 >> 32);
    8a4a:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    8a4e:	0023      	movs	r3, r4
    8a50:	603b      	str	r3, [r7, #0]
    8a52:	2300      	movs	r3, #0
    8a54:	607b      	str	r3, [r7, #4]
    8a56:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    8a5a:	e897 0006 	ldmia.w	r7, {r1, r2}
    8a5e:	18c9      	adds	r1, r1, r3
    8a60:	eb42 0204 	adc.w	r2, r2, r4
    8a64:	460b      	mov	r3, r1
    8a66:	4614      	mov	r4, r2
    8a68:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        q64 >>= 3;
    8a6c:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    8a70:	08da      	lsrs	r2, r3, #3
    8a72:	613a      	str	r2, [r7, #16]
    8a74:	693a      	ldr	r2, [r7, #16]
    8a76:	ea42 7244 	orr.w	r2, r2, r4, lsl #29
    8a7a:	613a      	str	r2, [r7, #16]
    8a7c:	08e3      	lsrs	r3, r4, #3
    8a7e:	617b      	str	r3, [r7, #20]
    8a80:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
    8a84:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        r64 = ui64Val - q64*10;
    8a88:	e9d7 1214 	ldrd	r1, r2, [r7, #80]	; 0x50
    8a8c:	460b      	mov	r3, r1
    8a8e:	4614      	mov	r4, r2
    8a90:	00a0      	lsls	r0, r4, #2
    8a92:	60f8      	str	r0, [r7, #12]
    8a94:	68f8      	ldr	r0, [r7, #12]
    8a96:	ea40 7093 	orr.w	r0, r0, r3, lsr #30
    8a9a:	60f8      	str	r0, [r7, #12]
    8a9c:	009b      	lsls	r3, r3, #2
    8a9e:	60bb      	str	r3, [r7, #8]
    8aa0:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
    8aa4:	185b      	adds	r3, r3, r1
    8aa6:	eb44 0402 	adc.w	r4, r4, r2
    8aaa:	18db      	adds	r3, r3, r3
    8aac:	eb44 0404 	adc.w	r4, r4, r4
    8ab0:	4619      	mov	r1, r3
    8ab2:	4622      	mov	r2, r4
    8ab4:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
    8ab8:	1a5b      	subs	r3, r3, r1
    8aba:	eb64 0402 	sbc.w	r4, r4, r2
    8abe:	e9c7 3412 	strd	r3, r4, [r7, #72]	; 0x48
        return q64 + ((r64 + 6) >> 4);
    8ac2:	e9d7 3412 	ldrd	r3, r4, [r7, #72]	; 0x48
    8ac6:	3306      	adds	r3, #6
    8ac8:	f144 0400 	adc.w	r4, r4, #0
    8acc:	091a      	lsrs	r2, r3, #4
    8ace:	61ba      	str	r2, [r7, #24]
    8ad0:	69ba      	ldr	r2, [r7, #24]
    8ad2:	ea42 7204 	orr.w	r2, r2, r4, lsl #28
    8ad6:	61ba      	str	r2, [r7, #24]
    8ad8:	0923      	lsrs	r3, r4, #4
    8ada:	61fb      	str	r3, [r7, #28]
    8adc:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    8ae0:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
    8ae4:	18c9      	adds	r1, r1, r3
    8ae6:	eb42 0204 	adc.w	r2, r2, r4
    8aea:	460b      	mov	r3, r1
    8aec:	4614      	mov	r4, r2
    8aee:	e029      	b.n	8b44 <divu64_10+0x1b0>
    }
    else
    {
        ui32Val = (uint32_t)(ui64Val & 0xffffffff);
    8af0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    8af2:	647b      	str	r3, [r7, #68]	; 0x44
        q32 = (ui32Val>>1) + (ui32Val>>2);
    8af4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    8af6:	085a      	lsrs	r2, r3, #1
    8af8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    8afa:	089b      	lsrs	r3, r3, #2
    8afc:	4413      	add	r3, r2
    8afe:	643b      	str	r3, [r7, #64]	; 0x40
        q32 += (q32 >> 4);
    8b00:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    8b02:	091b      	lsrs	r3, r3, #4
    8b04:	6c3a      	ldr	r2, [r7, #64]	; 0x40
    8b06:	4413      	add	r3, r2
    8b08:	643b      	str	r3, [r7, #64]	; 0x40
        q32 += (q32 >> 8);
    8b0a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    8b0c:	0a1b      	lsrs	r3, r3, #8
    8b0e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
    8b10:	4413      	add	r3, r2
    8b12:	643b      	str	r3, [r7, #64]	; 0x40
        q32 += (q32 >> 16);
    8b14:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    8b16:	0c1b      	lsrs	r3, r3, #16
    8b18:	6c3a      	ldr	r2, [r7, #64]	; 0x40
    8b1a:	4413      	add	r3, r2
    8b1c:	643b      	str	r3, [r7, #64]	; 0x40
        q32 >>= 3;
    8b1e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    8b20:	08db      	lsrs	r3, r3, #3
    8b22:	643b      	str	r3, [r7, #64]	; 0x40
        r32 = ui32Val - q32*10;
    8b24:	6c3a      	ldr	r2, [r7, #64]	; 0x40
    8b26:	4613      	mov	r3, r2
    8b28:	009b      	lsls	r3, r3, #2
    8b2a:	4413      	add	r3, r2
    8b2c:	005b      	lsls	r3, r3, #1
    8b2e:	461a      	mov	r2, r3
    8b30:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    8b32:	1a9b      	subs	r3, r3, r2
    8b34:	63fb      	str	r3, [r7, #60]	; 0x3c
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    8b36:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    8b38:	3306      	adds	r3, #6
    8b3a:	091a      	lsrs	r2, r3, #4
    8b3c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    8b3e:	4413      	add	r3, r2
    8b40:	f04f 0400 	mov.w	r4, #0
    }
}
    8b44:	4618      	mov	r0, r3
    8b46:	4621      	mov	r1, r4
    8b48:	3758      	adds	r7, #88	; 0x58
    8b4a:	46bd      	mov	sp, r7
    8b4c:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    8b50:	4770      	bx	lr

00008b52 <ndigits_in_u64>:
// example: 10000 return 5, 123 returns 3.
//
//*****************************************************************************
static int
ndigits_in_u64(uint64_t ui64Val)
{
    8b52:	b590      	push	{r4, r7, lr}
    8b54:	b085      	sub	sp, #20
    8b56:	af00      	add	r7, sp, #0
    8b58:	e9c7 0100 	strd	r0, r1, [r7]
    int iNDigits = ui64Val ? 0 : 1;
    8b5c:	683a      	ldr	r2, [r7, #0]
    8b5e:	687b      	ldr	r3, [r7, #4]
    8b60:	4313      	orrs	r3, r2
    8b62:	2b00      	cmp	r3, #0
    8b64:	bf0c      	ite	eq
    8b66:	2301      	moveq	r3, #1
    8b68:	2300      	movne	r3, #0
    8b6a:	b2db      	uxtb	r3, r3
    8b6c:	60fb      	str	r3, [r7, #12]

    while ( ui64Val )
    8b6e:	e008      	b.n	8b82 <ndigits_in_u64+0x30>
    {
        //
        // ui32Val /= 10;
        //
        ui64Val = divu64_10(ui64Val);
    8b70:	e9d7 0100 	ldrd	r0, r1, [r7]
    8b74:	f7ff ff0e 	bl	8994 <divu64_10>
    8b78:	e9c7 0100 	strd	r0, r1, [r7]
        ++iNDigits;
    8b7c:	68fb      	ldr	r3, [r7, #12]
    8b7e:	3301      	adds	r3, #1
    8b80:	60fb      	str	r3, [r7, #12]
    while ( ui64Val )
    8b82:	e897 0018 	ldmia.w	r7, {r3, r4}
    8b86:	4323      	orrs	r3, r4
    8b88:	d1f2      	bne.n	8b70 <ndigits_in_u64+0x1e>
    }

    return iNDigits;
    8b8a:	68fb      	ldr	r3, [r7, #12]
}
    8b8c:	4618      	mov	r0, r3
    8b8e:	3714      	adds	r7, #20
    8b90:	46bd      	mov	sp, r7
    8b92:	bd90      	pop	{r4, r7, pc}

00008b94 <ndigits_in_i64>:
// example: -3 returns 1, 3 returns 1, 15 returns 2, -15 returns 2, ...
//
//*****************************************************************************
static int
ndigits_in_i64(int64_t i64Val)
{
    8b94:	b590      	push	{r4, r7, lr}
    8b96:	b083      	sub	sp, #12
    8b98:	af00      	add	r7, sp, #0
    8b9a:	e9c7 0100 	strd	r0, r1, [r7]
    if ( i64Val < 0 )
    8b9e:	e897 0018 	ldmia.w	r7, {r3, r4}
    8ba2:	2b00      	cmp	r3, #0
    8ba4:	f174 0300 	sbcs.w	r3, r4, #0
    8ba8:	da06      	bge.n	8bb8 <ndigits_in_i64+0x24>
    {
        //
        // Get absolute value
        //
        i64Val = -i64Val;
    8baa:	e897 0018 	ldmia.w	r7, {r3, r4}
    8bae:	425b      	negs	r3, r3
    8bb0:	eb64 0444 	sbc.w	r4, r4, r4, lsl #1
    8bb4:	e887 0018 	stmia.w	r7, {r3, r4}
    }

    return ndigits_in_u64((uint64_t) i64Val);
    8bb8:	e897 0018 	ldmia.w	r7, {r3, r4}
    8bbc:	4618      	mov	r0, r3
    8bbe:	4621      	mov	r1, r4
    8bc0:	f7ff ffc7 	bl	8b52 <ndigits_in_u64>
    8bc4:	4603      	mov	r3, r0
}
    8bc6:	4618      	mov	r0, r3
    8bc8:	370c      	adds	r7, #12
    8bca:	46bd      	mov	sp, r7
    8bcc:	bd90      	pop	{r4, r7, pc}

00008bce <ndigits_in_hex>:
// Return the number of hex digits in an uint64_t.
//
//*****************************************************************************
static int
ndigits_in_hex(uint64_t ui64Val)
{
    8bce:	b490      	push	{r4, r7}
    8bd0:	b084      	sub	sp, #16
    8bd2:	af00      	add	r7, sp, #0
    8bd4:	e9c7 0100 	strd	r0, r1, [r7]
    int iDigits = ui64Val ? 0 : 1;
    8bd8:	6839      	ldr	r1, [r7, #0]
    8bda:	687a      	ldr	r2, [r7, #4]
    8bdc:	430a      	orrs	r2, r1
    8bde:	2a00      	cmp	r2, #0
    8be0:	bf0c      	ite	eq
    8be2:	2201      	moveq	r2, #1
    8be4:	2200      	movne	r2, #0
    8be6:	b2d2      	uxtb	r2, r2
    8be8:	60fa      	str	r2, [r7, #12]

    while ( ui64Val )
    8bea:	e00a      	b.n	8c02 <ndigits_in_hex+0x34>
    {
        ui64Val >>= 4;
    8bec:	e897 0006 	ldmia.w	r7, {r1, r2}
    8bf0:	090b      	lsrs	r3, r1, #4
    8bf2:	ea43 7302 	orr.w	r3, r3, r2, lsl #28
    8bf6:	0914      	lsrs	r4, r2, #4
    8bf8:	e887 0018 	stmia.w	r7, {r3, r4}
        ++iDigits;
    8bfc:	68fa      	ldr	r2, [r7, #12]
    8bfe:	3201      	adds	r2, #1
    8c00:	60fa      	str	r2, [r7, #12]
    while ( ui64Val )
    8c02:	e897 0006 	ldmia.w	r7, {r1, r2}
    8c06:	430a      	orrs	r2, r1
    8c08:	d1f0      	bne.n	8bec <ndigits_in_hex+0x1e>
    }

    return iDigits;
    8c0a:	68fb      	ldr	r3, [r7, #12]
}
    8c0c:	4618      	mov	r0, r3
    8c0e:	3710      	adds	r7, #16
    8c10:	46bd      	mov	sp, r7
    8c12:	bc90      	pop	{r4, r7}
    8c14:	4770      	bx	lr

00008c16 <decstr_to_int>:
// pui32CharCnt.
//
//*****************************************************************************
static uint32_t
decstr_to_int(const char *pcStr, uint32_t *pui32CharCnt)
{
    8c16:	b480      	push	{r7}
    8c18:	b087      	sub	sp, #28
    8c1a:	af00      	add	r7, sp, #0
    8c1c:	6078      	str	r0, [r7, #4]
    8c1e:	6039      	str	r1, [r7, #0]
    bool bNeg = false;
    8c20:	2300      	movs	r3, #0
    8c22:	75fb      	strb	r3, [r7, #23]
    uint32_t ui32Val = 0, uCnt = 0;
    8c24:	2300      	movs	r3, #0
    8c26:	613b      	str	r3, [r7, #16]
    8c28:	2300      	movs	r3, #0
    8c2a:	60fb      	str	r3, [r7, #12]

    if ( *pcStr == '-')
    8c2c:	687b      	ldr	r3, [r7, #4]
    8c2e:	781b      	ldrb	r3, [r3, #0]
    8c30:	2b2d      	cmp	r3, #45	; 0x2d
    8c32:	d11b      	bne.n	8c6c <decstr_to_int+0x56>
    {
        bNeg = true;
    8c34:	2301      	movs	r3, #1
    8c36:	75fb      	strb	r3, [r7, #23]
        pcStr++;
    8c38:	687b      	ldr	r3, [r7, #4]
    8c3a:	3301      	adds	r3, #1
    8c3c:	607b      	str	r3, [r7, #4]
        uCnt++;
    8c3e:	68fb      	ldr	r3, [r7, #12]
    8c40:	3301      	adds	r3, #1
    8c42:	60fb      	str	r3, [r7, #12]
    }

    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    8c44:	e012      	b.n	8c6c <decstr_to_int+0x56>
    {
        ++uCnt;
    8c46:	68fb      	ldr	r3, [r7, #12]
    8c48:	3301      	adds	r3, #1
    8c4a:	60fb      	str	r3, [r7, #12]

        //
        // Multiply accumulated value by 10.
        //
        ui32Val *= 10;
    8c4c:	693a      	ldr	r2, [r7, #16]
    8c4e:	4613      	mov	r3, r2
    8c50:	009b      	lsls	r3, r3, #2
    8c52:	4413      	add	r3, r2
    8c54:	005b      	lsls	r3, r3, #1
    8c56:	613b      	str	r3, [r7, #16]

        //
        // Add in the new low digit.
        //
        ui32Val += (*pcStr - '0');
    8c58:	687b      	ldr	r3, [r7, #4]
    8c5a:	781b      	ldrb	r3, [r3, #0]
    8c5c:	461a      	mov	r2, r3
    8c5e:	693b      	ldr	r3, [r7, #16]
    8c60:	4413      	add	r3, r2
    8c62:	3b30      	subs	r3, #48	; 0x30
    8c64:	613b      	str	r3, [r7, #16]
        pcStr++;
    8c66:	687b      	ldr	r3, [r7, #4]
    8c68:	3301      	adds	r3, #1
    8c6a:	607b      	str	r3, [r7, #4]
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    8c6c:	687b      	ldr	r3, [r7, #4]
    8c6e:	781b      	ldrb	r3, [r3, #0]
    8c70:	2b2f      	cmp	r3, #47	; 0x2f
    8c72:	d903      	bls.n	8c7c <decstr_to_int+0x66>
    8c74:	687b      	ldr	r3, [r7, #4]
    8c76:	781b      	ldrb	r3, [r3, #0]
    8c78:	2b39      	cmp	r3, #57	; 0x39
    8c7a:	d9e4      	bls.n	8c46 <decstr_to_int+0x30>
    }

    if ( pui32CharCnt )
    8c7c:	683b      	ldr	r3, [r7, #0]
    8c7e:	2b00      	cmp	r3, #0
    8c80:	d002      	beq.n	8c88 <decstr_to_int+0x72>
    {
        *pui32CharCnt = uCnt;
    8c82:	683b      	ldr	r3, [r7, #0]
    8c84:	68fa      	ldr	r2, [r7, #12]
    8c86:	601a      	str	r2, [r3, #0]
    }

    return bNeg ? -ui32Val : ui32Val;
    8c88:	7dfb      	ldrb	r3, [r7, #23]
    8c8a:	2b00      	cmp	r3, #0
    8c8c:	d002      	beq.n	8c94 <decstr_to_int+0x7e>
    8c8e:	693b      	ldr	r3, [r7, #16]
    8c90:	425b      	negs	r3, r3
    8c92:	e000      	b.n	8c96 <decstr_to_int+0x80>
    8c94:	693b      	ldr	r3, [r7, #16]
}
    8c96:	4618      	mov	r0, r3
    8c98:	371c      	adds	r7, #28
    8c9a:	46bd      	mov	sp, r7
    8c9c:	f85d 7b04 	ldr.w	r7, [sp], #4
    8ca0:	4770      	bx	lr

00008ca2 <uint64_to_str>:
// written).
//
//*****************************************************************************
static int
uint64_to_str(uint64_t ui64Val, char *pcBuf)
{
    8ca2:	b590      	push	{r4, r7, lr}
    8ca4:	b091      	sub	sp, #68	; 0x44
    8ca6:	af00      	add	r7, sp, #0
    8ca8:	e9c7 0102 	strd	r0, r1, [r7, #8]
    8cac:	607a      	str	r2, [r7, #4]
    char tbuf[25];
    int ix = 0, iNumDig = 0;
    8cae:	2300      	movs	r3, #0
    8cb0:	63fb      	str	r3, [r7, #60]	; 0x3c
    8cb2:	2300      	movs	r3, #0
    8cb4:	63bb      	str	r3, [r7, #56]	; 0x38
    do
    {
        //
        // Divide by 10
        //
        u64Tmp = divu64_10(ui64Val);
    8cb6:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
    8cba:	f7ff fe6b 	bl	8994 <divu64_10>
    8cbe:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30

        //
        // Get modulus
        //
        uMod = ui64Val - (u64Tmp * 10);
    8cc2:	68b9      	ldr	r1, [r7, #8]
    8cc4:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    8cc6:	4613      	mov	r3, r2
    8cc8:	009b      	lsls	r3, r3, #2
    8cca:	4413      	add	r3, r2
    8ccc:	005b      	lsls	r3, r3, #1
    8cce:	1acb      	subs	r3, r1, r3
    8cd0:	62fb      	str	r3, [r7, #44]	; 0x2c

        tbuf[ix++] = uMod + '0';
    8cd2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    8cd4:	1c5a      	adds	r2, r3, #1
    8cd6:	63fa      	str	r2, [r7, #60]	; 0x3c
    8cd8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    8cda:	b2d2      	uxtb	r2, r2
    8cdc:	3230      	adds	r2, #48	; 0x30
    8cde:	b2d2      	uxtb	r2, r2
    8ce0:	f107 0140 	add.w	r1, r7, #64	; 0x40
    8ce4:	440b      	add	r3, r1
    8ce6:	f803 2c30 	strb.w	r2, [r3, #-48]
        ui64Val = u64Tmp;
    8cea:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
    8cee:	e9c7 3402 	strd	r3, r4, [r7, #8]
    } while ( ui64Val );
    8cf2:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
    8cf6:	4323      	orrs	r3, r4
    8cf8:	d1dd      	bne.n	8cb6 <uint64_to_str+0x14>

    //
    // Save the total number of digits
    //
    iNumDig = ix;
    8cfa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    8cfc:	63bb      	str	r3, [r7, #56]	; 0x38

    //
    // Now, reverse the buffer when saving to the caller's buffer.
    //
    if ( pcBuf )
    8cfe:	687b      	ldr	r3, [r7, #4]
    8d00:	2b00      	cmp	r3, #0
    8d02:	d011      	beq.n	8d28 <uint64_to_str+0x86>
    {
        while ( ix-- )
    8d04:	e008      	b.n	8d18 <uint64_to_str+0x76>
        {
            *pcBuf++ = tbuf[ix];
    8d06:	687b      	ldr	r3, [r7, #4]
    8d08:	1c5a      	adds	r2, r3, #1
    8d0a:	607a      	str	r2, [r7, #4]
    8d0c:	f107 0110 	add.w	r1, r7, #16
    8d10:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    8d12:	440a      	add	r2, r1
    8d14:	7812      	ldrb	r2, [r2, #0]
    8d16:	701a      	strb	r2, [r3, #0]
        while ( ix-- )
    8d18:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    8d1a:	1e5a      	subs	r2, r3, #1
    8d1c:	63fa      	str	r2, [r7, #60]	; 0x3c
    8d1e:	2b00      	cmp	r3, #0
    8d20:	d1f1      	bne.n	8d06 <uint64_to_str+0x64>
        }

        //
        // Terminate the caller's buffer
        //
        *pcBuf = 0x00;
    8d22:	687b      	ldr	r3, [r7, #4]
    8d24:	2200      	movs	r2, #0
    8d26:	701a      	strb	r2, [r3, #0]
    }

    return iNumDig;
    8d28:	6bbb      	ldr	r3, [r7, #56]	; 0x38
}
    8d2a:	4618      	mov	r0, r3
    8d2c:	3744      	adds	r7, #68	; 0x44
    8d2e:	46bd      	mov	sp, r7
    8d30:	bd90      	pop	{r4, r7, pc}

00008d32 <uint64_to_hexstr>:
// written).
//
//*****************************************************************************
static int
uint64_to_hexstr(uint64_t ui64Val, char *pcBuf, bool bLower)
{
    8d32:	b4b0      	push	{r4, r5, r7}
    8d34:	b08d      	sub	sp, #52	; 0x34
    8d36:	af00      	add	r7, sp, #0
    8d38:	e9c7 0102 	strd	r0, r1, [r7, #8]
    8d3c:	607a      	str	r2, [r7, #4]
    8d3e:	70fb      	strb	r3, [r7, #3]
    int iNumDig, ix = 0;
    8d40:	2300      	movs	r3, #0
    8d42:	62fb      	str	r3, [r7, #44]	; 0x2c
    char cCh, tbuf[20];

    if ( ui64Val == 0 )
    8d44:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
    8d48:	4313      	orrs	r3, r2
    8d4a:	d131      	bne.n	8db0 <uint64_to_hexstr+0x7e>
    {
        tbuf[ix++] = '0';   // Print a '0'
    8d4c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8d4e:	1c5a      	adds	r2, r3, #1
    8d50:	62fa      	str	r2, [r7, #44]	; 0x2c
    8d52:	f107 0230 	add.w	r2, r7, #48	; 0x30
    8d56:	4413      	add	r3, r2
    8d58:	2230      	movs	r2, #48	; 0x30
    8d5a:	f803 2c20 	strb.w	r2, [r3, #-32]
    }

    while ( ui64Val )
    8d5e:	e027      	b.n	8db0 <uint64_to_hexstr+0x7e>
    {
        cCh = ui64Val & 0xf;
    8d60:	7a3b      	ldrb	r3, [r7, #8]
    8d62:	f003 030f 	and.w	r3, r3, #15
    8d66:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

        //
        // Alpha character
        //
        if ( cCh > 9 )
    8d6a:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
    8d6e:	2b09      	cmp	r3, #9
    8d70:	d90a      	bls.n	8d88 <uint64_to_hexstr+0x56>
        {
            cCh += bLower ? 0x27 : 0x7;
    8d72:	78fb      	ldrb	r3, [r7, #3]
    8d74:	2b00      	cmp	r3, #0
    8d76:	d001      	beq.n	8d7c <uint64_to_hexstr+0x4a>
    8d78:	2227      	movs	r2, #39	; 0x27
    8d7a:	e000      	b.n	8d7e <uint64_to_hexstr+0x4c>
    8d7c:	2207      	movs	r2, #7
    8d7e:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
    8d82:	4413      	add	r3, r2
    8d84:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
        }

        tbuf[ix++] = cCh + '0';
    8d88:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8d8a:	1c5a      	adds	r2, r3, #1
    8d8c:	62fa      	str	r2, [r7, #44]	; 0x2c
    8d8e:	f897 202b 	ldrb.w	r2, [r7, #43]	; 0x2b
    8d92:	3230      	adds	r2, #48	; 0x30
    8d94:	b2d2      	uxtb	r2, r2
    8d96:	f107 0130 	add.w	r1, r7, #48	; 0x30
    8d9a:	440b      	add	r3, r1
    8d9c:	f803 2c20 	strb.w	r2, [r3, #-32]
        ui64Val >>= 4;
    8da0:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
    8da4:	0914      	lsrs	r4, r2, #4
    8da6:	ea44 7403 	orr.w	r4, r4, r3, lsl #28
    8daa:	091d      	lsrs	r5, r3, #4
    8dac:	e9c7 4502 	strd	r4, r5, [r7, #8]
    while ( ui64Val )
    8db0:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
    8db4:	4313      	orrs	r3, r2
    8db6:	d1d3      	bne.n	8d60 <uint64_to_hexstr+0x2e>
    }

    //
    // Save the total number of digits
    //
    iNumDig = ix;
    8db8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8dba:	627b      	str	r3, [r7, #36]	; 0x24

    //
    // Now, reverse the buffer when saving to the callers buffer.
    //
    if (pcBuf)
    8dbc:	687b      	ldr	r3, [r7, #4]
    8dbe:	2b00      	cmp	r3, #0
    8dc0:	d011      	beq.n	8de6 <uint64_to_hexstr+0xb4>
    {
        while (ix--)
    8dc2:	e008      	b.n	8dd6 <uint64_to_hexstr+0xa4>
        {
            *pcBuf++ = tbuf[ix];
    8dc4:	687b      	ldr	r3, [r7, #4]
    8dc6:	1c5a      	adds	r2, r3, #1
    8dc8:	607a      	str	r2, [r7, #4]
    8dca:	f107 0110 	add.w	r1, r7, #16
    8dce:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    8dd0:	440a      	add	r2, r1
    8dd2:	7812      	ldrb	r2, [r2, #0]
    8dd4:	701a      	strb	r2, [r3, #0]
        while (ix--)
    8dd6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8dd8:	1e5a      	subs	r2, r3, #1
    8dda:	62fa      	str	r2, [r7, #44]	; 0x2c
    8ddc:	2b00      	cmp	r3, #0
    8dde:	d1f1      	bne.n	8dc4 <uint64_to_hexstr+0x92>
        }

        //
        // Terminate the caller's buffer
        //
        *pcBuf = 0;
    8de0:	687b      	ldr	r3, [r7, #4]
    8de2:	2200      	movs	r2, #0
    8de4:	701a      	strb	r2, [r3, #0]
    }

    return iNumDig;
    8de6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
    8de8:	4618      	mov	r0, r3
    8dea:	3734      	adds	r7, #52	; 0x34
    8dec:	46bd      	mov	sp, r7
    8dee:	bcb0      	pop	{r4, r5, r7}
    8df0:	4770      	bx	lr

00008df2 <simple_strlen>:
// Return length of the given string.
//
//*****************************************************************************
static uint32_t
simple_strlen(char *pcBuf)
{
    8df2:	b480      	push	{r7}
    8df4:	b085      	sub	sp, #20
    8df6:	af00      	add	r7, sp, #0
    8df8:	6078      	str	r0, [r7, #4]
    uint32_t ui32RetVal = 0;
    8dfa:	2300      	movs	r3, #0
    8dfc:	60fb      	str	r3, [r7, #12]
    if ( !pcBuf )
    8dfe:	687b      	ldr	r3, [r7, #4]
    8e00:	2b00      	cmp	r3, #0
    8e02:	d104      	bne.n	8e0e <simple_strlen+0x1c>
    {
        return ui32RetVal;
    8e04:	68fb      	ldr	r3, [r7, #12]
    8e06:	e009      	b.n	8e1c <simple_strlen+0x2a>
    }

    while ( *pcBuf++ )
    {
        ui32RetVal++;
    8e08:	68fb      	ldr	r3, [r7, #12]
    8e0a:	3301      	adds	r3, #1
    8e0c:	60fb      	str	r3, [r7, #12]
    while ( *pcBuf++ )
    8e0e:	687b      	ldr	r3, [r7, #4]
    8e10:	1c5a      	adds	r2, r3, #1
    8e12:	607a      	str	r2, [r7, #4]
    8e14:	781b      	ldrb	r3, [r3, #0]
    8e16:	2b00      	cmp	r3, #0
    8e18:	d1f6      	bne.n	8e08 <simple_strlen+0x16>
    }
    return ui32RetVal;
    8e1a:	68fb      	ldr	r3, [r7, #12]
}
    8e1c:	4618      	mov	r0, r3
    8e1e:	3714      	adds	r7, #20
    8e20:	46bd      	mov	sp, r7
    8e22:	f85d 7b04 	ldr.w	r7, [sp], #4
    8e26:	4770      	bx	lr

00008e28 <padbuffer>:
// Pad a string buffer with pad characters.
//
//*****************************************************************************
static int32_t
padbuffer(char *pcBuf, uint8_t cPadChar, int32_t i32NumChars)
{
    8e28:	b480      	push	{r7}
    8e2a:	b087      	sub	sp, #28
    8e2c:	af00      	add	r7, sp, #0
    8e2e:	60f8      	str	r0, [r7, #12]
    8e30:	460b      	mov	r3, r1
    8e32:	607a      	str	r2, [r7, #4]
    8e34:	72fb      	strb	r3, [r7, #11]
    int32_t i32Cnt = 0;
    8e36:	2300      	movs	r3, #0
    8e38:	617b      	str	r3, [r7, #20]

    if ( i32NumChars <= 0 )
    8e3a:	687b      	ldr	r3, [r7, #4]
    8e3c:	2b00      	cmp	r3, #0
    8e3e:	dc0c      	bgt.n	8e5a <padbuffer+0x32>
    {
        return i32Cnt;
    8e40:	697b      	ldr	r3, [r7, #20]
    8e42:	e010      	b.n	8e66 <padbuffer+0x3e>
    }

    while ( i32NumChars-- )
    {
        if ( pcBuf )
    8e44:	68fb      	ldr	r3, [r7, #12]
    8e46:	2b00      	cmp	r3, #0
    8e48:	d004      	beq.n	8e54 <padbuffer+0x2c>
        {
            *pcBuf++ = cPadChar;
    8e4a:	68fb      	ldr	r3, [r7, #12]
    8e4c:	1c5a      	adds	r2, r3, #1
    8e4e:	60fa      	str	r2, [r7, #12]
    8e50:	7afa      	ldrb	r2, [r7, #11]
    8e52:	701a      	strb	r2, [r3, #0]
        }
        i32Cnt++;
    8e54:	697b      	ldr	r3, [r7, #20]
    8e56:	3301      	adds	r3, #1
    8e58:	617b      	str	r3, [r7, #20]
    while ( i32NumChars-- )
    8e5a:	687b      	ldr	r3, [r7, #4]
    8e5c:	1e5a      	subs	r2, r3, #1
    8e5e:	607a      	str	r2, [r7, #4]
    8e60:	2b00      	cmp	r3, #0
    8e62:	d1ef      	bne.n	8e44 <padbuffer+0x1c>
    }

    return i32Cnt;
    8e64:	697b      	ldr	r3, [r7, #20]
}
    8e66:	4618      	mov	r0, r3
    8e68:	371c      	adds	r7, #28
    8e6a:	46bd      	mov	sp, r7
    8e6c:	f85d 7b04 	ldr.w	r7, [sp], #4
    8e70:	4770      	bx	lr
	...

00008e74 <ftoa>:
    int32_t I32;
    float F;
} i32fl_t;

static int ftoa(float fValue, char *pcBuf, int iPrecision)
{
    8e74:	b590      	push	{r4, r7, lr}
    8e76:	b08f      	sub	sp, #60	; 0x3c
    8e78:	af00      	add	r7, sp, #0
    8e7a:	60f8      	str	r0, [r7, #12]
    8e7c:	60b9      	str	r1, [r7, #8]
    8e7e:	607a      	str	r2, [r7, #4]
    i32fl_t unFloatValue;
    int iExp2, iBufSize;
    int32_t i32Significand, i32IntPart, i32FracPart;
    char *pcBufInitial, *pcBuftmp;

    iBufSize = *(uint32_t*)pcBuf;
    8e80:	68bb      	ldr	r3, [r7, #8]
    8e82:	681b      	ldr	r3, [r3, #0]
    8e84:	627b      	str	r3, [r7, #36]	; 0x24
    if (iBufSize < 4)
    8e86:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    8e88:	2b03      	cmp	r3, #3
    8e8a:	dc02      	bgt.n	8e92 <ftoa+0x1e>
    {
        return AM_FTOA_ERR_BUFSIZE;
    8e8c:	f06f 0302 	mvn.w	r3, #2
    8e90:	e0e7      	b.n	9062 <ftoa+0x1ee>
    }

    if (fValue == 0.0f)
    8e92:	edd7 7a03 	vldr	s15, [r7, #12]
    8e96:	eef5 7a40 	vcmp.f32	s15, #0.0
    8e9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8e9e:	d104      	bne.n	8eaa <ftoa+0x36>
    {
        // "0.0"
        *(uint32_t*)pcBuf = 0x00 << 24 | ('0' << 16) | ('.' << 8) | ('0' << 0);
    8ea0:	68bb      	ldr	r3, [r7, #8]
    8ea2:	4a72      	ldr	r2, [pc, #456]	; (906c <ftoa+0x1f8>)
    8ea4:	601a      	str	r2, [r3, #0]
        return 3;
    8ea6:	2303      	movs	r3, #3
    8ea8:	e0db      	b.n	9062 <ftoa+0x1ee>
    }

    pcBufInitial = pcBuf;
    8eaa:	68bb      	ldr	r3, [r7, #8]
    8eac:	623b      	str	r3, [r7, #32]

    unFloatValue.F = fValue;
    8eae:	68fb      	ldr	r3, [r7, #12]
    8eb0:	613b      	str	r3, [r7, #16]

    iExp2 = ((unFloatValue.I32 >> 23) & 0x000000FF) - 127;
    8eb2:	693b      	ldr	r3, [r7, #16]
    8eb4:	15db      	asrs	r3, r3, #23
    8eb6:	b2db      	uxtb	r3, r3
    8eb8:	3b7f      	subs	r3, #127	; 0x7f
    8eba:	61fb      	str	r3, [r7, #28]
    i32Significand = (unFloatValue.I32 & 0x00FFFFFF) | 0x00800000;
    8ebc:	693b      	ldr	r3, [r7, #16]
    8ebe:	f3c3 0316 	ubfx	r3, r3, #0, #23
    8ec2:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
    8ec6:	61bb      	str	r3, [r7, #24]
    i32FracPart = 0;
    8ec8:	2300      	movs	r3, #0
    8eca:	633b      	str	r3, [r7, #48]	; 0x30
    i32IntPart = 0;
    8ecc:	2300      	movs	r3, #0
    8ece:	637b      	str	r3, [r7, #52]	; 0x34

    if (iExp2 >= 31)
    8ed0:	69fb      	ldr	r3, [r7, #28]
    8ed2:	2b1e      	cmp	r3, #30
    8ed4:	dd02      	ble.n	8edc <ftoa+0x68>
    {
        return AM_FTOA_ERR_VAL_TOO_LARGE;
    8ed6:	f06f 0301 	mvn.w	r3, #1
    8eda:	e0c2      	b.n	9062 <ftoa+0x1ee>
    }
    else if (iExp2 < -23)
    8edc:	69fb      	ldr	r3, [r7, #28]
    8ede:	f113 0f17 	cmn.w	r3, #23
    8ee2:	da02      	bge.n	8eea <ftoa+0x76>
    {
        return AM_FTOA_ERR_VAL_TOO_SMALL;
    8ee4:	f04f 33ff 	mov.w	r3, #4294967295
    8ee8:	e0bb      	b.n	9062 <ftoa+0x1ee>
    }
    else if (iExp2 >= 23)
    8eea:	69fb      	ldr	r3, [r7, #28]
    8eec:	2b16      	cmp	r3, #22
    8eee:	dd06      	ble.n	8efe <ftoa+0x8a>
    {
        i32IntPart = i32Significand << (iExp2 - 23);
    8ef0:	69fb      	ldr	r3, [r7, #28]
    8ef2:	3b17      	subs	r3, #23
    8ef4:	69ba      	ldr	r2, [r7, #24]
    8ef6:	fa02 f303 	lsl.w	r3, r2, r3
    8efa:	637b      	str	r3, [r7, #52]	; 0x34
    8efc:	e01a      	b.n	8f34 <ftoa+0xc0>
    }
    else if (iExp2 >= 0)
    8efe:	69fb      	ldr	r3, [r7, #28]
    8f00:	2b00      	cmp	r3, #0
    8f02:	db0f      	blt.n	8f24 <ftoa+0xb0>
    {
        i32IntPart = i32Significand >> (23 - iExp2);
    8f04:	69fb      	ldr	r3, [r7, #28]
    8f06:	f1c3 0317 	rsb	r3, r3, #23
    8f0a:	69ba      	ldr	r2, [r7, #24]
    8f0c:	fa42 f303 	asr.w	r3, r2, r3
    8f10:	637b      	str	r3, [r7, #52]	; 0x34
        i32FracPart = (i32Significand << (iExp2 + 1)) & 0x00FFFFFF;
    8f12:	69fb      	ldr	r3, [r7, #28]
    8f14:	3301      	adds	r3, #1
    8f16:	69ba      	ldr	r2, [r7, #24]
    8f18:	fa02 f303 	lsl.w	r3, r2, r3
    8f1c:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    8f20:	633b      	str	r3, [r7, #48]	; 0x30
    8f22:	e007      	b.n	8f34 <ftoa+0xc0>
    }
    else // if (iExp2 < 0)
    {
        i32FracPart = (i32Significand & 0x00FFFFFF) >> -(iExp2 + 1);
    8f24:	69bb      	ldr	r3, [r7, #24]
    8f26:	f023 427f 	bic.w	r2, r3, #4278190080	; 0xff000000
    8f2a:	69fb      	ldr	r3, [r7, #28]
    8f2c:	43db      	mvns	r3, r3
    8f2e:	fa42 f303 	asr.w	r3, r2, r3
    8f32:	633b      	str	r3, [r7, #48]	; 0x30
    }

    if (unFloatValue.I32 < 0)
    8f34:	693b      	ldr	r3, [r7, #16]
    8f36:	2b00      	cmp	r3, #0
    8f38:	da04      	bge.n	8f44 <ftoa+0xd0>
    {
        *pcBuf++ = '-';
    8f3a:	68bb      	ldr	r3, [r7, #8]
    8f3c:	1c5a      	adds	r2, r3, #1
    8f3e:	60ba      	str	r2, [r7, #8]
    8f40:	222d      	movs	r2, #45	; 0x2d
    8f42:	701a      	strb	r2, [r3, #0]
    }

    if (i32IntPart == 0)
    8f44:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    8f46:	2b00      	cmp	r3, #0
    8f48:	d105      	bne.n	8f56 <ftoa+0xe2>
    {
        *pcBuf++ = '0';
    8f4a:	68bb      	ldr	r3, [r7, #8]
    8f4c:	1c5a      	adds	r2, r3, #1
    8f4e:	60ba      	str	r2, [r7, #8]
    8f50:	2230      	movs	r2, #48	; 0x30
    8f52:	701a      	strb	r2, [r3, #0]
    8f54:	e021      	b.n	8f9a <ftoa+0x126>
    }
    else
    {
        if (i32IntPart > 0)
    8f56:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    8f58:	2b00      	cmp	r3, #0
    8f5a:	dd08      	ble.n	8f6e <ftoa+0xfa>
        {
            uint64_to_str(i32IntPart, pcBuf);
    8f5c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    8f5e:	ea4f 74e3 	mov.w	r4, r3, asr #31
    8f62:	68ba      	ldr	r2, [r7, #8]
    8f64:	4618      	mov	r0, r3
    8f66:	4621      	mov	r1, r4
    8f68:	f7ff fe9b 	bl	8ca2 <uint64_to_str>
    8f6c:	e011      	b.n	8f92 <ftoa+0x11e>
        }
        else
        {
            *pcBuf++ = '-';
    8f6e:	68bb      	ldr	r3, [r7, #8]
    8f70:	1c5a      	adds	r2, r3, #1
    8f72:	60ba      	str	r2, [r7, #8]
    8f74:	222d      	movs	r2, #45	; 0x2d
    8f76:	701a      	strb	r2, [r3, #0]
            uint64_to_str(-i32IntPart, pcBuf);
    8f78:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    8f7a:	425b      	negs	r3, r3
    8f7c:	ea4f 74e3 	mov.w	r4, r3, asr #31
    8f80:	68ba      	ldr	r2, [r7, #8]
    8f82:	4618      	mov	r0, r3
    8f84:	4621      	mov	r1, r4
    8f86:	f7ff fe8c 	bl	8ca2 <uint64_to_str>
        }
        while (*pcBuf)    // Get to end of new string
    8f8a:	e002      	b.n	8f92 <ftoa+0x11e>
        {
            pcBuf++;
    8f8c:	68bb      	ldr	r3, [r7, #8]
    8f8e:	3301      	adds	r3, #1
    8f90:	60bb      	str	r3, [r7, #8]
        while (*pcBuf)    // Get to end of new string
    8f92:	68bb      	ldr	r3, [r7, #8]
    8f94:	781b      	ldrb	r3, [r3, #0]
    8f96:	2b00      	cmp	r3, #0
    8f98:	d1f8      	bne.n	8f8c <ftoa+0x118>
    }

    //
    // Now, begin the fractional part
    //
    *pcBuf++ = '.';
    8f9a:	68bb      	ldr	r3, [r7, #8]
    8f9c:	1c5a      	adds	r2, r3, #1
    8f9e:	60ba      	str	r2, [r7, #8]
    8fa0:	222e      	movs	r2, #46	; 0x2e
    8fa2:	701a      	strb	r2, [r3, #0]

    if (i32FracPart == 0)
    8fa4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    8fa6:	2b00      	cmp	r3, #0
    8fa8:	d105      	bne.n	8fb6 <ftoa+0x142>
    {
        *pcBuf++ = '0';
    8faa:	68bb      	ldr	r3, [r7, #8]
    8fac:	1c5a      	adds	r2, r3, #1
    8fae:	60ba      	str	r2, [r7, #8]
    8fb0:	2230      	movs	r2, #48	; 0x30
    8fb2:	701a      	strb	r2, [r3, #0]
    8fb4:	e04f      	b.n	9056 <ftoa+0x1e2>
    }
    else
    {
        int jx, iMax;

        iMax = iBufSize - (pcBuf - pcBufInitial) - 1;
    8fb6:	68ba      	ldr	r2, [r7, #8]
    8fb8:	6a3b      	ldr	r3, [r7, #32]
    8fba:	1ad3      	subs	r3, r2, r3
    8fbc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    8fbe:	1ad3      	subs	r3, r2, r3
    8fc0:	3b01      	subs	r3, #1
    8fc2:	617b      	str	r3, [r7, #20]
        iMax = (iMax > iPrecision) ? iPrecision : iMax;
    8fc4:	697a      	ldr	r2, [r7, #20]
    8fc6:	687b      	ldr	r3, [r7, #4]
    8fc8:	4293      	cmp	r3, r2
    8fca:	bfa8      	it	ge
    8fcc:	4613      	movge	r3, r2
    8fce:	617b      	str	r3, [r7, #20]

        for (jx = 0; jx < iMax; jx++)
    8fd0:	2300      	movs	r3, #0
    8fd2:	62bb      	str	r3, [r7, #40]	; 0x28
    8fd4:	e015      	b.n	9002 <ftoa+0x18e>
        {
            i32FracPart *= 10;
    8fd6:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    8fd8:	4613      	mov	r3, r2
    8fda:	009b      	lsls	r3, r3, #2
    8fdc:	4413      	add	r3, r2
    8fde:	005b      	lsls	r3, r3, #1
    8fe0:	633b      	str	r3, [r7, #48]	; 0x30
            *pcBuf++ = (i32FracPart >> 24) + '0';
    8fe2:	68bb      	ldr	r3, [r7, #8]
    8fe4:	1c5a      	adds	r2, r3, #1
    8fe6:	60ba      	str	r2, [r7, #8]
    8fe8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    8fea:	1612      	asrs	r2, r2, #24
    8fec:	b2d2      	uxtb	r2, r2
    8fee:	3230      	adds	r2, #48	; 0x30
    8ff0:	b2d2      	uxtb	r2, r2
    8ff2:	701a      	strb	r2, [r3, #0]
            i32FracPart &= 0x00FFFFFF;
    8ff4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    8ff6:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    8ffa:	633b      	str	r3, [r7, #48]	; 0x30
        for (jx = 0; jx < iMax; jx++)
    8ffc:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8ffe:	3301      	adds	r3, #1
    9000:	62bb      	str	r3, [r7, #40]	; 0x28
    9002:	6aba      	ldr	r2, [r7, #40]	; 0x28
    9004:	697b      	ldr	r3, [r7, #20]
    9006:	429a      	cmp	r2, r3
    9008:	dbe5      	blt.n	8fd6 <ftoa+0x162>
        // 1.996        4                   1.9960
        //
        // To determine whether to round up, we'll look at what the next
        // decimal value would have been.
        //
        if ( ((i32FracPart * 10) >> 24) >= 5 )
    900a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    900c:	4613      	mov	r3, r2
    900e:	009b      	lsls	r3, r3, #2
    9010:	4413      	add	r3, r2
    9012:	005b      	lsls	r3, r3, #1
    9014:	161b      	asrs	r3, r3, #24
    9016:	2b04      	cmp	r3, #4
    9018:	dd1d      	ble.n	9056 <ftoa+0x1e2>
        {
            //
            // Yes, we need to round up.
            // Go back through the string and make adjustments as necessary.
            //
            pcBuftmp = pcBuf - 1;
    901a:	68bb      	ldr	r3, [r7, #8]
    901c:	3b01      	subs	r3, #1
    901e:	62fb      	str	r3, [r7, #44]	; 0x2c
            while ( pcBuftmp >= pcBufInitial )
    9020:	e015      	b.n	904e <ftoa+0x1da>
            {
                if ( *pcBuftmp == '.' )
    9022:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    9024:	781b      	ldrb	r3, [r3, #0]
    9026:	2b2e      	cmp	r3, #46	; 0x2e
    9028:	d00e      	beq.n	9048 <ftoa+0x1d4>
                {
                }
                else if ( *pcBuftmp == '9' )
    902a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    902c:	781b      	ldrb	r3, [r3, #0]
    902e:	2b39      	cmp	r3, #57	; 0x39
    9030:	d103      	bne.n	903a <ftoa+0x1c6>
                {
                    *pcBuftmp = '0';
    9032:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    9034:	2230      	movs	r2, #48	; 0x30
    9036:	701a      	strb	r2, [r3, #0]
    9038:	e006      	b.n	9048 <ftoa+0x1d4>
                }
                else
                {
                    *pcBuftmp += 1;
    903a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    903c:	781b      	ldrb	r3, [r3, #0]
    903e:	3301      	adds	r3, #1
    9040:	b2da      	uxtb	r2, r3
    9042:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    9044:	701a      	strb	r2, [r3, #0]
                    break;
    9046:	e006      	b.n	9056 <ftoa+0x1e2>
                }
                pcBuftmp--;
    9048:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    904a:	3b01      	subs	r3, #1
    904c:	62fb      	str	r3, [r7, #44]	; 0x2c
            while ( pcBuftmp >= pcBufInitial )
    904e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    9050:	6a3b      	ldr	r3, [r7, #32]
    9052:	429a      	cmp	r2, r3
    9054:	d2e5      	bcs.n	9022 <ftoa+0x1ae>
    }

    //
    // Terminate the string and we're done
    //
    *pcBuf = 0x00;
    9056:	68bb      	ldr	r3, [r7, #8]
    9058:	2200      	movs	r2, #0
    905a:	701a      	strb	r2, [r3, #0]

    return (pcBuf - pcBufInitial);
    905c:	68ba      	ldr	r2, [r7, #8]
    905e:	6a3b      	ldr	r3, [r7, #32]
    9060:	1ad3      	subs	r3, r2, r3
} // ftoa()
    9062:	4618      	mov	r0, r3
    9064:	373c      	adds	r7, #60	; 0x3c
    9066:	46bd      	mov	sp, r7
    9068:	bd90      	pop	{r4, r7, pc}
    906a:	bf00      	nop
    906c:	00302e30 	.word	0x00302e30

00009070 <am_util_stdio_vsprintf>:
//! @return uint32_t representing the number of characters printed.
//
//******************************************************************************
uint32_t
am_util_stdio_vsprintf(char *pcBuf, const char *pcFmt, va_list pArgs)
{
    9070:	b590      	push	{r4, r7, lr}
    9072:	b095      	sub	sp, #84	; 0x54
    9074:	af00      	add	r7, sp, #0
    9076:	60f8      	str	r0, [r7, #12]
    9078:	60b9      	str	r1, [r7, #8]
    907a:	607a      	str	r2, [r7, #4]
    char *pcStr;
    uint64_t ui64Val;
    int64_t i64Val;
    uint32_t ui32NumChars, ui32CharCnt = 0;
    907c:	2300      	movs	r3, #0
    907e:	63fb      	str	r3, [r7, #60]	; 0x3c
    int iWidth, iVal, iPrecision;
    uint8_t ui8CharSpecifier, ui8PadChar;
    bool bLower, bLongLong, bNeg;
    uint32_t ui32strlen = 0;
    9080:	2300      	movs	r3, #0
    9082:	627b      	str	r3, [r7, #36]	; 0x24

    while ( *pcFmt != 0x0 )
    9084:	e2e3      	b.n	964e <am_util_stdio_vsprintf+0x5de>
    {
        iPrecision = 6;             // printf() default precision for %f is 6
    9086:	2306      	movs	r3, #6
    9088:	633b      	str	r3, [r7, #48]	; 0x30

        if ( *pcFmt != '%' )
    908a:	68bb      	ldr	r3, [r7, #8]
    908c:	781b      	ldrb	r3, [r3, #0]
    908e:	2b25      	cmp	r3, #37	; 0x25
    9090:	d01f      	beq.n	90d2 <am_util_stdio_vsprintf+0x62>
        {
            //
            // Accumulate the string portion of the format specification.
            //
            if ( pcBuf )
    9092:	68fb      	ldr	r3, [r7, #12]
    9094:	2b00      	cmp	r3, #0
    9096:	d015      	beq.n	90c4 <am_util_stdio_vsprintf+0x54>
            {
                // If '\n', convert to '\r\n'
                if ( *pcFmt == '\n'  &&  g_bTxtXlate )
    9098:	68bb      	ldr	r3, [r7, #8]
    909a:	781b      	ldrb	r3, [r3, #0]
    909c:	2b0a      	cmp	r3, #10
    909e:	d10b      	bne.n	90b8 <am_util_stdio_vsprintf+0x48>
    90a0:	4bb1      	ldr	r3, [pc, #708]	; (9368 <am_util_stdio_vsprintf+0x2f8>)
    90a2:	781b      	ldrb	r3, [r3, #0]
    90a4:	2b00      	cmp	r3, #0
    90a6:	d007      	beq.n	90b8 <am_util_stdio_vsprintf+0x48>
                {
                    *pcBuf++ = '\r';
    90a8:	68fb      	ldr	r3, [r7, #12]
    90aa:	1c5a      	adds	r2, r3, #1
    90ac:	60fa      	str	r2, [r7, #12]
    90ae:	220d      	movs	r2, #13
    90b0:	701a      	strb	r2, [r3, #0]
                    ++ui32CharCnt;
    90b2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    90b4:	3301      	adds	r3, #1
    90b6:	63fb      	str	r3, [r7, #60]	; 0x3c
                }
                *pcBuf++ = *pcFmt;
    90b8:	68fb      	ldr	r3, [r7, #12]
    90ba:	1c5a      	adds	r2, r3, #1
    90bc:	60fa      	str	r2, [r7, #12]
    90be:	68ba      	ldr	r2, [r7, #8]
    90c0:	7812      	ldrb	r2, [r2, #0]
    90c2:	701a      	strb	r2, [r3, #0]
            }

            ++pcFmt;
    90c4:	68bb      	ldr	r3, [r7, #8]
    90c6:	3301      	adds	r3, #1
    90c8:	60bb      	str	r3, [r7, #8]
            ++ui32CharCnt;
    90ca:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    90cc:	3301      	adds	r3, #1
    90ce:	63fb      	str	r3, [r7, #60]	; 0x3c
            continue;
    90d0:	e2bd      	b.n	964e <am_util_stdio_vsprintf+0x5de>
        }

        //
        // Handle the specifier.
        //
        ++pcFmt;
    90d2:	68bb      	ldr	r3, [r7, #8]
    90d4:	3301      	adds	r3, #1
    90d6:	60bb      	str	r3, [r7, #8]
        bLower = bLongLong = false;
    90d8:	2300      	movs	r3, #0
    90da:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
    90de:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
    90e2:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e

        //
        // Default to space as ui8PadChar
        //
        ui8PadChar = ' ';
    90e6:	2320      	movs	r3, #32
    90e8:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

        if ( *pcFmt == '0' )
    90ec:	68bb      	ldr	r3, [r7, #8]
    90ee:	781b      	ldrb	r3, [r3, #0]
    90f0:	2b30      	cmp	r3, #48	; 0x30
    90f2:	d105      	bne.n	9100 <am_util_stdio_vsprintf+0x90>
        {
            ui8PadChar = '0';
    90f4:	2330      	movs	r3, #48	; 0x30
    90f6:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
            ++pcFmt;
    90fa:	68bb      	ldr	r3, [r7, #8]
    90fc:	3301      	adds	r3, #1
    90fe:	60bb      	str	r3, [r7, #8]
        }

        //
        // Width specifier
        //
        iWidth = decstr_to_int(pcFmt, &ui32NumChars);
    9100:	f107 0310 	add.w	r3, r7, #16
    9104:	4619      	mov	r1, r3
    9106:	68b8      	ldr	r0, [r7, #8]
    9108:	f7ff fd85 	bl	8c16 <decstr_to_int>
    910c:	4603      	mov	r3, r0
    910e:	63bb      	str	r3, [r7, #56]	; 0x38
        pcFmt += ui32NumChars;
    9110:	693b      	ldr	r3, [r7, #16]
    9112:	68ba      	ldr	r2, [r7, #8]
    9114:	4413      	add	r3, r2
    9116:	60bb      	str	r3, [r7, #8]

        //
        // For now, only support a negative width specifier for %s
        //
        if ( ( *pcFmt != 's' )  &&  ( iWidth < 0 ) )
    9118:	68bb      	ldr	r3, [r7, #8]
    911a:	781b      	ldrb	r3, [r3, #0]
    911c:	2b73      	cmp	r3, #115	; 0x73
    911e:	d005      	beq.n	912c <am_util_stdio_vsprintf+0xbc>
    9120:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    9122:	2b00      	cmp	r3, #0
    9124:	da02      	bge.n	912c <am_util_stdio_vsprintf+0xbc>
        {
            iWidth = -iWidth;
    9126:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    9128:	425b      	negs	r3, r3
    912a:	63bb      	str	r3, [r7, #56]	; 0x38
        }

        //
        // Check for precision specifier
        //
        if (*pcFmt == '.')
    912c:	68bb      	ldr	r3, [r7, #8]
    912e:	781b      	ldrb	r3, [r3, #0]
    9130:	2b2e      	cmp	r3, #46	; 0x2e
    9132:	d10e      	bne.n	9152 <am_util_stdio_vsprintf+0xe2>
        {
            ++pcFmt;
    9134:	68bb      	ldr	r3, [r7, #8]
    9136:	3301      	adds	r3, #1
    9138:	60bb      	str	r3, [r7, #8]
            iPrecision = decstr_to_int(pcFmt, &ui32NumChars);
    913a:	f107 0310 	add.w	r3, r7, #16
    913e:	4619      	mov	r1, r3
    9140:	68b8      	ldr	r0, [r7, #8]
    9142:	f7ff fd68 	bl	8c16 <decstr_to_int>
    9146:	4603      	mov	r3, r0
    9148:	633b      	str	r3, [r7, #48]	; 0x30
            pcFmt += ui32NumChars;
    914a:	693b      	ldr	r3, [r7, #16]
    914c:	68ba      	ldr	r2, [r7, #8]
    914e:	4413      	add	r3, r2
    9150:	60bb      	str	r3, [r7, #8]
        // 'll', which must be a modifier for either 'd', 'i', 'u', 'x', or 'X'
        // (or even 'o', which is not currently supported). Other sub-specifiers
        // like 'hh','h', etc. are not currently handled.
        // Note - 'l' is used in Coremark, a primary reason it's supported here.
        //
        if ( *pcFmt == 'l' )
    9152:	68bb      	ldr	r3, [r7, #8]
    9154:	781b      	ldrb	r3, [r3, #0]
    9156:	2b6c      	cmp	r3, #108	; 0x6c
    9158:	d10c      	bne.n	9174 <am_util_stdio_vsprintf+0x104>
        {
            pcFmt++;
    915a:	68bb      	ldr	r3, [r7, #8]
    915c:	3301      	adds	r3, #1
    915e:	60bb      	str	r3, [r7, #8]
            if ( *pcFmt == 'l' )    // "ll" (long long)
    9160:	68bb      	ldr	r3, [r7, #8]
    9162:	781b      	ldrb	r3, [r3, #0]
    9164:	2b6c      	cmp	r3, #108	; 0x6c
    9166:	d105      	bne.n	9174 <am_util_stdio_vsprintf+0x104>
            {
                pcFmt++;
    9168:	68bb      	ldr	r3, [r7, #8]
    916a:	3301      	adds	r3, #1
    916c:	60bb      	str	r3, [r7, #8]
                bLongLong = true;
    916e:	2301      	movs	r3, #1
    9170:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
            }
        }

        switch ( *pcFmt )
    9174:	68bb      	ldr	r3, [r7, #8]
    9176:	781b      	ldrb	r3, [r3, #0]
    9178:	3b46      	subs	r3, #70	; 0x46
    917a:	2b32      	cmp	r3, #50	; 0x32
    917c:	f200 8254 	bhi.w	9628 <am_util_stdio_vsprintf+0x5b8>
    9180:	a201      	add	r2, pc, #4	; (adr r2, 9188 <am_util_stdio_vsprintf+0x118>)
    9182:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    9186:	bf00      	nop
    9188:	000095b3 	.word	0x000095b3
    918c:	00009629 	.word	0x00009629
    9190:	00009629 	.word	0x00009629
    9194:	00009629 	.word	0x00009629
    9198:	00009629 	.word	0x00009629
    919c:	00009629 	.word	0x00009629
    91a0:	00009629 	.word	0x00009629
    91a4:	00009629 	.word	0x00009629
    91a8:	00009629 	.word	0x00009629
    91ac:	00009629 	.word	0x00009629
    91b0:	00009629 	.word	0x00009629
    91b4:	00009629 	.word	0x00009629
    91b8:	00009629 	.word	0x00009629
    91bc:	00009629 	.word	0x00009629
    91c0:	00009629 	.word	0x00009629
    91c4:	00009629 	.word	0x00009629
    91c8:	00009629 	.word	0x00009629
    91cc:	00009629 	.word	0x00009629
    91d0:	0000934f 	.word	0x0000934f
    91d4:	00009629 	.word	0x00009629
    91d8:	00009629 	.word	0x00009629
    91dc:	00009629 	.word	0x00009629
    91e0:	00009629 	.word	0x00009629
    91e4:	00009629 	.word	0x00009629
    91e8:	00009629 	.word	0x00009629
    91ec:	00009629 	.word	0x00009629
    91f0:	00009629 	.word	0x00009629
    91f4:	00009629 	.word	0x00009629
    91f8:	00009629 	.word	0x00009629
    91fc:	00009255 	.word	0x00009255
    9200:	0000947b 	.word	0x0000947b
    9204:	00009629 	.word	0x00009629
    9208:	000095b3 	.word	0x000095b3
    920c:	00009629 	.word	0x00009629
    9210:	00009629 	.word	0x00009629
    9214:	0000947b 	.word	0x0000947b
    9218:	00009629 	.word	0x00009629
    921c:	00009629 	.word	0x00009629
    9220:	00009629 	.word	0x00009629
    9224:	00009629 	.word	0x00009629
    9228:	00009629 	.word	0x00009629
    922c:	00009629 	.word	0x00009629
    9230:	00009629 	.word	0x00009629
    9234:	00009629 	.word	0x00009629
    9238:	00009629 	.word	0x00009629
    923c:	0000927b 	.word	0x0000927b
    9240:	00009629 	.word	0x00009629
    9244:	000093e9 	.word	0x000093e9
    9248:	00009629 	.word	0x00009629
    924c:	00009629 	.word	0x00009629
    9250:	00009349 	.word	0x00009349
        {
            case 'c':
                ui8CharSpecifier = va_arg(pArgs, uint32_t);
    9254:	687b      	ldr	r3, [r7, #4]
    9256:	1d1a      	adds	r2, r3, #4
    9258:	607a      	str	r2, [r7, #4]
    925a:	681b      	ldr	r3, [r3, #0]
    925c:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

                if ( pcBuf )
    9260:	68fb      	ldr	r3, [r7, #12]
    9262:	2b00      	cmp	r3, #0
    9264:	d005      	beq.n	9272 <am_util_stdio_vsprintf+0x202>
                {
                    *pcBuf++ = ui8CharSpecifier;
    9266:	68fb      	ldr	r3, [r7, #12]
    9268:	1c5a      	adds	r2, r3, #1
    926a:	60fa      	str	r2, [r7, #12]
    926c:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
    9270:	701a      	strb	r2, [r3, #0]
                }

                ++ui32CharCnt;
    9272:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    9274:	3301      	adds	r3, #1
    9276:	63fb      	str	r3, [r7, #60]	; 0x3c
                break;
    9278:	e1e6      	b.n	9648 <am_util_stdio_vsprintf+0x5d8>

            case 's':
                pcStr = va_arg(pArgs, char *);
    927a:	687b      	ldr	r3, [r7, #4]
    927c:	1d1a      	adds	r2, r3, #4
    927e:	607a      	str	r2, [r7, #4]
    9280:	681b      	ldr	r3, [r3, #0]
    9282:	64fb      	str	r3, [r7, #76]	; 0x4c
                //
                // For %s, we support the width specifier. If iWidth is negative
                // the string is left-aligned (padding on the right).  Otherwise
                // the string is padded at the beginning with spaces.
                //
                ui32strlen = simple_strlen(pcStr);
    9284:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
    9286:	f7ff fdb4 	bl	8df2 <simple_strlen>
    928a:	6278      	str	r0, [r7, #36]	; 0x24
                if ( iWidth > 0 )
    928c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    928e:	2b00      	cmp	r3, #0
    9290:	dd2e      	ble.n	92f0 <am_util_stdio_vsprintf+0x280>
                {
                    // Pad the beginning of the string (right-aligned).
                    if ( ui32strlen < iWidth )
    9292:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    9294:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    9296:	429a      	cmp	r2, r3
    9298:	d22a      	bcs.n	92f0 <am_util_stdio_vsprintf+0x280>
                    {
                        // String needs some padding.
                        iWidth -= ui32strlen;
    929a:	6bba      	ldr	r2, [r7, #56]	; 0x38
    929c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    929e:	1ad3      	subs	r3, r2, r3
    92a0:	63bb      	str	r3, [r7, #56]	; 0x38
                        iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    92a2:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    92a6:	6bba      	ldr	r2, [r7, #56]	; 0x38
    92a8:	4619      	mov	r1, r3
    92aa:	68f8      	ldr	r0, [r7, #12]
    92ac:	f7ff fdbc 	bl	8e28 <padbuffer>
    92b0:	63b8      	str	r0, [r7, #56]	; 0x38
                        pcBuf += pcBuf ? iWidth : 0;
    92b2:	68fb      	ldr	r3, [r7, #12]
    92b4:	2b00      	cmp	r3, #0
    92b6:	d001      	beq.n	92bc <am_util_stdio_vsprintf+0x24c>
    92b8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    92ba:	e000      	b.n	92be <am_util_stdio_vsprintf+0x24e>
    92bc:	2300      	movs	r3, #0
    92be:	68fa      	ldr	r2, [r7, #12]
    92c0:	4413      	add	r3, r2
    92c2:	60fb      	str	r3, [r7, #12]
                        ui32CharCnt += iWidth;
    92c4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    92c6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    92c8:	4413      	add	r3, r2
    92ca:	63fb      	str	r3, [r7, #60]	; 0x3c
                        iWidth = 0;
    92cc:	2300      	movs	r3, #0
    92ce:	63bb      	str	r3, [r7, #56]	; 0x38
                    }
                }

                while (*pcStr != 0x0)
    92d0:	e00e      	b.n	92f0 <am_util_stdio_vsprintf+0x280>
                {
                    if ( pcBuf )
    92d2:	68fb      	ldr	r3, [r7, #12]
    92d4:	2b00      	cmp	r3, #0
    92d6:	d005      	beq.n	92e4 <am_util_stdio_vsprintf+0x274>
                    {
                        *pcBuf++ = *pcStr;
    92d8:	68fb      	ldr	r3, [r7, #12]
    92da:	1c5a      	adds	r2, r3, #1
    92dc:	60fa      	str	r2, [r7, #12]
    92de:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
    92e0:	7812      	ldrb	r2, [r2, #0]
    92e2:	701a      	strb	r2, [r3, #0]
                    }

                    ++pcStr;
    92e4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    92e6:	3301      	adds	r3, #1
    92e8:	64fb      	str	r3, [r7, #76]	; 0x4c
                    ++ui32CharCnt;
    92ea:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    92ec:	3301      	adds	r3, #1
    92ee:	63fb      	str	r3, [r7, #60]	; 0x3c
                while (*pcStr != 0x0)
    92f0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    92f2:	781b      	ldrb	r3, [r3, #0]
    92f4:	2b00      	cmp	r3, #0
    92f6:	d1ec      	bne.n	92d2 <am_util_stdio_vsprintf+0x262>
                }

                if ( iWidth )
    92f8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    92fa:	2b00      	cmp	r3, #0
    92fc:	f000 81a1 	beq.w	9642 <am_util_stdio_vsprintf+0x5d2>
                {
                    iWidth = -iWidth;
    9300:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    9302:	425b      	negs	r3, r3
    9304:	63bb      	str	r3, [r7, #56]	; 0x38

                    // Pad the end of the string (left-aligned).
                    if ( ui32strlen < iWidth )
    9306:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    9308:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    930a:	429a      	cmp	r2, r3
    930c:	f080 8199 	bcs.w	9642 <am_util_stdio_vsprintf+0x5d2>
                    {
                        // String needs some padding.
                        iWidth -= ui32strlen;
    9310:	6bba      	ldr	r2, [r7, #56]	; 0x38
    9312:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    9314:	1ad3      	subs	r3, r2, r3
    9316:	63bb      	str	r3, [r7, #56]	; 0x38
                        iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    9318:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    931c:	6bba      	ldr	r2, [r7, #56]	; 0x38
    931e:	4619      	mov	r1, r3
    9320:	68f8      	ldr	r0, [r7, #12]
    9322:	f7ff fd81 	bl	8e28 <padbuffer>
    9326:	63b8      	str	r0, [r7, #56]	; 0x38
                        pcBuf += pcBuf ? iWidth : 0;
    9328:	68fb      	ldr	r3, [r7, #12]
    932a:	2b00      	cmp	r3, #0
    932c:	d001      	beq.n	9332 <am_util_stdio_vsprintf+0x2c2>
    932e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    9330:	e000      	b.n	9334 <am_util_stdio_vsprintf+0x2c4>
    9332:	2300      	movs	r3, #0
    9334:	68fa      	ldr	r2, [r7, #12]
    9336:	4413      	add	r3, r2
    9338:	60fb      	str	r3, [r7, #12]
                        ui32CharCnt += iWidth;
    933a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    933c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    933e:	4413      	add	r3, r2
    9340:	63fb      	str	r3, [r7, #60]	; 0x3c
                        iWidth = 0;
    9342:	2300      	movs	r3, #0
    9344:	63bb      	str	r3, [r7, #56]	; 0x38
                    }
                }
                break;
    9346:	e17c      	b.n	9642 <am_util_stdio_vsprintf+0x5d2>

            case 'x':
                bLower = true;
    9348:	2301      	movs	r3, #1
    934a:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
            case 'X':
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    934e:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
    9352:	2b00      	cmp	r3, #0
    9354:	d00a      	beq.n	936c <am_util_stdio_vsprintf+0x2fc>
    9356:	687b      	ldr	r3, [r7, #4]
    9358:	3307      	adds	r3, #7
    935a:	f023 0307 	bic.w	r3, r3, #7
    935e:	f103 0208 	add.w	r2, r3, #8
    9362:	607a      	str	r2, [r7, #4]
    9364:	cb18      	ldmia	r3, {r3, r4}
    9366:	e007      	b.n	9378 <am_util_stdio_vsprintf+0x308>
    9368:	10001138 	.word	0x10001138
                                      va_arg(pArgs, uint32_t);
    936c:	687b      	ldr	r3, [r7, #4]
    936e:	1d1a      	adds	r2, r3, #4
    9370:	607a      	str	r2, [r7, #4]
    9372:	681b      	ldr	r3, [r3, #0]
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    9374:	f04f 0400 	mov.w	r4, #0
    9378:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40

                if ( iWidth )
    937c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    937e:	2b00      	cmp	r3, #0
    9380:	d01e      	beq.n	93c0 <am_util_stdio_vsprintf+0x350>
                {
                    //
                    // Compute # of leading chars
                    //
                    iWidth -= ndigits_in_hex(ui64Val);
    9382:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
    9386:	f7ff fc22 	bl	8bce <ndigits_in_hex>
    938a:	4602      	mov	r2, r0
    938c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    938e:	1a9b      	subs	r3, r3, r2
    9390:	63bb      	str	r3, [r7, #56]	; 0x38

                    iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    9392:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    9396:	6bba      	ldr	r2, [r7, #56]	; 0x38
    9398:	4619      	mov	r1, r3
    939a:	68f8      	ldr	r0, [r7, #12]
    939c:	f7ff fd44 	bl	8e28 <padbuffer>
    93a0:	63b8      	str	r0, [r7, #56]	; 0x38
                    pcBuf += pcBuf ? iWidth : 0;
    93a2:	68fb      	ldr	r3, [r7, #12]
    93a4:	2b00      	cmp	r3, #0
    93a6:	d001      	beq.n	93ac <am_util_stdio_vsprintf+0x33c>
    93a8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    93aa:	e000      	b.n	93ae <am_util_stdio_vsprintf+0x33e>
    93ac:	2300      	movs	r3, #0
    93ae:	68fa      	ldr	r2, [r7, #12]
    93b0:	4413      	add	r3, r2
    93b2:	60fb      	str	r3, [r7, #12]
                    ui32CharCnt += iWidth;
    93b4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    93b6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    93b8:	4413      	add	r3, r2
    93ba:	63fb      	str	r3, [r7, #60]	; 0x3c
                    iWidth = 0;
    93bc:	2300      	movs	r3, #0
    93be:	63bb      	str	r3, [r7, #56]	; 0x38
                }

                iVal = uint64_to_hexstr(ui64Val, pcBuf, bLower);
    93c0:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
    93c4:	68fa      	ldr	r2, [r7, #12]
    93c6:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
    93ca:	f7ff fcb2 	bl	8d32 <uint64_to_hexstr>
    93ce:	6378      	str	r0, [r7, #52]	; 0x34

                if ( pcBuf )
    93d0:	68fb      	ldr	r3, [r7, #12]
    93d2:	2b00      	cmp	r3, #0
    93d4:	d003      	beq.n	93de <am_util_stdio_vsprintf+0x36e>
                {
                    pcBuf += iVal;
    93d6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    93d8:	68fa      	ldr	r2, [r7, #12]
    93da:	4413      	add	r3, r2
    93dc:	60fb      	str	r3, [r7, #12]
                }

                ui32CharCnt += iVal;
    93de:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    93e0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    93e2:	4413      	add	r3, r2
    93e4:	63fb      	str	r3, [r7, #60]	; 0x3c
                break;
    93e6:	e12f      	b.n	9648 <am_util_stdio_vsprintf+0x5d8>

            case 'u':
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    93e8:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
    93ec:	2b00      	cmp	r3, #0
    93ee:	d008      	beq.n	9402 <am_util_stdio_vsprintf+0x392>
    93f0:	687b      	ldr	r3, [r7, #4]
    93f2:	3307      	adds	r3, #7
    93f4:	f023 0307 	bic.w	r3, r3, #7
    93f8:	f103 0208 	add.w	r2, r3, #8
    93fc:	607a      	str	r2, [r7, #4]
    93fe:	cb18      	ldmia	r3, {r3, r4}
    9400:	e005      	b.n	940e <am_util_stdio_vsprintf+0x39e>
                                      va_arg(pArgs, uint32_t);
    9402:	687b      	ldr	r3, [r7, #4]
    9404:	1d1a      	adds	r2, r3, #4
    9406:	607a      	str	r2, [r7, #4]
    9408:	681b      	ldr	r3, [r3, #0]
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    940a:	f04f 0400 	mov.w	r4, #0
    940e:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40

                if ( iWidth )
    9412:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    9414:	2b00      	cmp	r3, #0
    9416:	d01e      	beq.n	9456 <am_util_stdio_vsprintf+0x3e6>
                {
                    //
                    // We need to pad the beginning of the value.
                    // Compute # of leading chars
                    //
                    iWidth -= ndigits_in_u64(ui64Val);
    9418:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
    941c:	f7ff fb99 	bl	8b52 <ndigits_in_u64>
    9420:	4602      	mov	r2, r0
    9422:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    9424:	1a9b      	subs	r3, r3, r2
    9426:	63bb      	str	r3, [r7, #56]	; 0x38

                    iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    9428:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    942c:	6bba      	ldr	r2, [r7, #56]	; 0x38
    942e:	4619      	mov	r1, r3
    9430:	68f8      	ldr	r0, [r7, #12]
    9432:	f7ff fcf9 	bl	8e28 <padbuffer>
    9436:	63b8      	str	r0, [r7, #56]	; 0x38
                    pcBuf += pcBuf ? iWidth : 0;
    9438:	68fb      	ldr	r3, [r7, #12]
    943a:	2b00      	cmp	r3, #0
    943c:	d001      	beq.n	9442 <am_util_stdio_vsprintf+0x3d2>
    943e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    9440:	e000      	b.n	9444 <am_util_stdio_vsprintf+0x3d4>
    9442:	2300      	movs	r3, #0
    9444:	68fa      	ldr	r2, [r7, #12]
    9446:	4413      	add	r3, r2
    9448:	60fb      	str	r3, [r7, #12]
                    ui32CharCnt += iWidth;
    944a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    944c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    944e:	4413      	add	r3, r2
    9450:	63fb      	str	r3, [r7, #60]	; 0x3c
                    iWidth = 0;
    9452:	2300      	movs	r3, #0
    9454:	63bb      	str	r3, [r7, #56]	; 0x38
                }

                iVal = uint64_to_str(ui64Val, pcBuf);
    9456:	68fa      	ldr	r2, [r7, #12]
    9458:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
    945c:	f7ff fc21 	bl	8ca2 <uint64_to_str>
    9460:	6378      	str	r0, [r7, #52]	; 0x34

                if ( pcBuf )
    9462:	68fb      	ldr	r3, [r7, #12]
    9464:	2b00      	cmp	r3, #0
    9466:	d003      	beq.n	9470 <am_util_stdio_vsprintf+0x400>
                {
                    pcBuf += iVal;
    9468:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    946a:	68fa      	ldr	r2, [r7, #12]
    946c:	4413      	add	r3, r2
    946e:	60fb      	str	r3, [r7, #12]
                }

                ui32CharCnt += iVal;
    9470:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    9472:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    9474:	4413      	add	r3, r2
    9476:	63fb      	str	r3, [r7, #60]	; 0x3c
                break;
    9478:	e0e6      	b.n	9648 <am_util_stdio_vsprintf+0x5d8>
                // Output for a negative number, for example, -5:
                //   %d:-5
                //  %5d:   -5
                // %05d:-0005
                //
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
    947a:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
    947e:	2b00      	cmp	r3, #0
    9480:	d008      	beq.n	9494 <am_util_stdio_vsprintf+0x424>
    9482:	687b      	ldr	r3, [r7, #4]
    9484:	3307      	adds	r3, #7
    9486:	f023 0307 	bic.w	r3, r3, #7
    948a:	f103 0208 	add.w	r2, r3, #8
    948e:	607a      	str	r2, [r7, #4]
    9490:	cb18      	ldmia	r3, {r3, r4}
    9492:	e005      	b.n	94a0 <am_util_stdio_vsprintf+0x430>
                                     va_arg(pArgs, int32_t);
    9494:	687b      	ldr	r3, [r7, #4]
    9496:	1d1a      	adds	r2, r3, #4
    9498:	607a      	str	r2, [r7, #4]
    949a:	681b      	ldr	r3, [r3, #0]
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
    949c:	ea4f 74e3 	mov.w	r4, r3, asr #31
    94a0:	e9c7 3406 	strd	r3, r4, [r7, #24]

                //
                // Get absolute value
                //
                if ( i64Val < 0 )
    94a4:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
    94a8:	2b00      	cmp	r3, #0
    94aa:	f174 0300 	sbcs.w	r3, r4, #0
    94ae:	da0a      	bge.n	94c6 <am_util_stdio_vsprintf+0x456>
                {
                    ui64Val = -i64Val;          // Get absolute value
    94b0:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
    94b4:	425b      	negs	r3, r3
    94b6:	eb64 0444 	sbc.w	r4, r4, r4, lsl #1
    94ba:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40
                    bNeg = true;
    94be:	2301      	movs	r3, #1
    94c0:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
    94c4:	e006      	b.n	94d4 <am_util_stdio_vsprintf+0x464>
                }
                else
                {
                    ui64Val = i64Val;
    94c6:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
    94ca:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40
                    bNeg = false;
    94ce:	2300      	movs	r3, #0
    94d0:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
                }

                if ( iWidth )
    94d4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    94d6:	2b00      	cmp	r3, #0
    94d8:	d04a      	beq.n	9570 <am_util_stdio_vsprintf+0x500>
                {
                    //
                    // We need to pad the beginning of the value.
                    // Compute # of leading chars
                    //
                    iWidth -= ndigits_in_i64(ui64Val);
    94da:	e9d7 3410 	ldrd	r3, r4, [r7, #64]	; 0x40
    94de:	4618      	mov	r0, r3
    94e0:	4621      	mov	r1, r4
    94e2:	f7ff fb57 	bl	8b94 <ndigits_in_i64>
    94e6:	4602      	mov	r2, r0
    94e8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    94ea:	1a9b      	subs	r3, r3, r2
    94ec:	63bb      	str	r3, [r7, #56]	; 0x38

                    if ( bNeg )
    94ee:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    94f2:	2b00      	cmp	r3, #0
    94f4:	d011      	beq.n	951a <am_util_stdio_vsprintf+0x4aa>
                    {
                        --iWidth;
    94f6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    94f8:	3b01      	subs	r3, #1
    94fa:	63bb      	str	r3, [r7, #56]	; 0x38

                        //
                        // Allow for the negative sign
                        //
                        if ( ui8PadChar == '0' )
    94fc:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    9500:	2b30      	cmp	r3, #48	; 0x30
    9502:	d10a      	bne.n	951a <am_util_stdio_vsprintf+0x4aa>
                        {
                            //
                            // Print the neg sign BEFORE the leading zeros
                            //
                            if ( pcBuf )
    9504:	68fb      	ldr	r3, [r7, #12]
    9506:	2b00      	cmp	r3, #0
    9508:	d004      	beq.n	9514 <am_util_stdio_vsprintf+0x4a4>
                            {
                                *pcBuf++ = '-';
    950a:	68fb      	ldr	r3, [r7, #12]
    950c:	1c5a      	adds	r2, r3, #1
    950e:	60fa      	str	r2, [r7, #12]
    9510:	222d      	movs	r2, #45	; 0x2d
    9512:	701a      	strb	r2, [r3, #0]
                            }

                            ++ui32CharCnt;
    9514:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    9516:	3301      	adds	r3, #1
    9518:	63fb      	str	r3, [r7, #60]	; 0x3c
                        }
                    }

                    iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    951a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    951e:	6bba      	ldr	r2, [r7, #56]	; 0x38
    9520:	4619      	mov	r1, r3
    9522:	68f8      	ldr	r0, [r7, #12]
    9524:	f7ff fc80 	bl	8e28 <padbuffer>
    9528:	63b8      	str	r0, [r7, #56]	; 0x38
                    pcBuf += pcBuf ? iWidth : 0;
    952a:	68fb      	ldr	r3, [r7, #12]
    952c:	2b00      	cmp	r3, #0
    952e:	d001      	beq.n	9534 <am_util_stdio_vsprintf+0x4c4>
    9530:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    9532:	e000      	b.n	9536 <am_util_stdio_vsprintf+0x4c6>
    9534:	2300      	movs	r3, #0
    9536:	68fa      	ldr	r2, [r7, #12]
    9538:	4413      	add	r3, r2
    953a:	60fb      	str	r3, [r7, #12]
                    ui32CharCnt += iWidth;
    953c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    953e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    9540:	4413      	add	r3, r2
    9542:	63fb      	str	r3, [r7, #60]	; 0x3c
                    iWidth = 0;
    9544:	2300      	movs	r3, #0
    9546:	63bb      	str	r3, [r7, #56]	; 0x38

                    if ( bNeg  &&  (ui8PadChar == ' ') )
    9548:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    954c:	2b00      	cmp	r3, #0
    954e:	d01e      	beq.n	958e <am_util_stdio_vsprintf+0x51e>
    9550:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    9554:	2b20      	cmp	r3, #32
    9556:	d11a      	bne.n	958e <am_util_stdio_vsprintf+0x51e>
                    {
                        //
                        // Print the neg sign AFTER the leading blanks
                        //
                        if ( pcBuf )
    9558:	68fb      	ldr	r3, [r7, #12]
    955a:	2b00      	cmp	r3, #0
    955c:	d004      	beq.n	9568 <am_util_stdio_vsprintf+0x4f8>
                        {
                            *pcBuf++ = '-';
    955e:	68fb      	ldr	r3, [r7, #12]
    9560:	1c5a      	adds	r2, r3, #1
    9562:	60fa      	str	r2, [r7, #12]
    9564:	222d      	movs	r2, #45	; 0x2d
    9566:	701a      	strb	r2, [r3, #0]
                        }

                        ++ui32CharCnt;
    9568:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    956a:	3301      	adds	r3, #1
    956c:	63fb      	str	r3, [r7, #60]	; 0x3c
    956e:	e00e      	b.n	958e <am_util_stdio_vsprintf+0x51e>
                    }
                }
                else
                {
                    if ( bNeg )
    9570:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    9574:	2b00      	cmp	r3, #0
    9576:	d00a      	beq.n	958e <am_util_stdio_vsprintf+0x51e>
                    {
                        if ( pcBuf )
    9578:	68fb      	ldr	r3, [r7, #12]
    957a:	2b00      	cmp	r3, #0
    957c:	d004      	beq.n	9588 <am_util_stdio_vsprintf+0x518>
                        {
                            *pcBuf++ = '-';
    957e:	68fb      	ldr	r3, [r7, #12]
    9580:	1c5a      	adds	r2, r3, #1
    9582:	60fa      	str	r2, [r7, #12]
    9584:	222d      	movs	r2, #45	; 0x2d
    9586:	701a      	strb	r2, [r3, #0]
                        }
                        ++ui32CharCnt;
    9588:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    958a:	3301      	adds	r3, #1
    958c:	63fb      	str	r3, [r7, #60]	; 0x3c
                    }
                }

                iVal = uint64_to_str(ui64Val, pcBuf);
    958e:	68fa      	ldr	r2, [r7, #12]
    9590:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
    9594:	f7ff fb85 	bl	8ca2 <uint64_to_str>
    9598:	6378      	str	r0, [r7, #52]	; 0x34

                if ( pcBuf )
    959a:	68fb      	ldr	r3, [r7, #12]
    959c:	2b00      	cmp	r3, #0
    959e:	d003      	beq.n	95a8 <am_util_stdio_vsprintf+0x538>
                {
                    pcBuf += iVal;
    95a0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    95a2:	68fa      	ldr	r2, [r7, #12]
    95a4:	4413      	add	r3, r2
    95a6:	60fb      	str	r3, [r7, #12]
                }

                ui32CharCnt += iVal;
    95a8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    95aa:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    95ac:	4413      	add	r3, r2
    95ae:	63fb      	str	r3, [r7, #60]	; 0x3c
                break;
    95b0:	e04a      	b.n	9648 <am_util_stdio_vsprintf+0x5d8>


            case 'f':
            case 'F':
                if ( pcBuf )
    95b2:	68fb      	ldr	r3, [r7, #12]
    95b4:	2b00      	cmp	r3, #0
    95b6:	d046      	beq.n	9646 <am_util_stdio_vsprintf+0x5d6>
                {
                    float fValue = va_arg(pArgs, double);
    95b8:	687b      	ldr	r3, [r7, #4]
    95ba:	3307      	adds	r3, #7
    95bc:	f023 0307 	bic.w	r3, r3, #7
    95c0:	f103 0208 	add.w	r2, r3, #8
    95c4:	607a      	str	r2, [r7, #4]
    95c6:	cb18      	ldmia	r3, {r3, r4}
    95c8:	4618      	mov	r0, r3
    95ca:	4621      	mov	r1, r4
    95cc:	f7fe fd78 	bl	80c0 <__aeabi_d2f>
    95d0:	4603      	mov	r3, r0
    95d2:	617b      	str	r3, [r7, #20]

                    //
                    // pcBuf is an input (size of buffer) and also an output of ftoa()
                    //
                    *(uint32_t*)pcBuf = 20;
    95d4:	68fb      	ldr	r3, [r7, #12]
    95d6:	2214      	movs	r2, #20
    95d8:	601a      	str	r2, [r3, #0]

                    iVal = ftoa(fValue, pcBuf, iPrecision);
    95da:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    95dc:	68f9      	ldr	r1, [r7, #12]
    95de:	6978      	ldr	r0, [r7, #20]
    95e0:	f7ff fc48 	bl	8e74 <ftoa>
    95e4:	6378      	str	r0, [r7, #52]	; 0x34
                    if ( iVal < 0 )
    95e6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    95e8:	2b00      	cmp	r3, #0
    95ea:	da14      	bge.n	9616 <am_util_stdio_vsprintf+0x5a6>
                    {
                        uint32_t u32PrntErrVal;
                        if ( iVal == AM_FTOA_ERR_VAL_TOO_SMALL )
    95ec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    95ee:	f1b3 3fff 	cmp.w	r3, #4294967295
    95f2:	d102      	bne.n	95fa <am_util_stdio_vsprintf+0x58a>
                        {
                            u32PrntErrVal = (0x00 << 24) | ('0' << 16) |
    95f4:	4b1e      	ldr	r3, [pc, #120]	; (9670 <am_util_stdio_vsprintf+0x600>)
    95f6:	62bb      	str	r3, [r7, #40]	; 0x28
    95f8:	e008      	b.n	960c <am_util_stdio_vsprintf+0x59c>
                                            ('.' << 8)   | ('0' << 0);  // "0.0"
                        }
                        else if ( iVal == AM_FTOA_ERR_VAL_TOO_LARGE )
    95fa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    95fc:	f113 0f02 	cmn.w	r3, #2
    9600:	d102      	bne.n	9608 <am_util_stdio_vsprintf+0x598>
                        {
                            u32PrntErrVal = (0x00 << 24) | ('#' << 16) |
    9602:	4b1c      	ldr	r3, [pc, #112]	; (9674 <am_util_stdio_vsprintf+0x604>)
    9604:	62bb      	str	r3, [r7, #40]	; 0x28
    9606:	e001      	b.n	960c <am_util_stdio_vsprintf+0x59c>
                                            ('.' << 8)   | ('#' << 0);  // "#.#"
                        }
                        else
                        {
                            u32PrntErrVal = (0x00 << 24) | ('?' << 16) |
    9608:	4b1b      	ldr	r3, [pc, #108]	; (9678 <am_util_stdio_vsprintf+0x608>)
    960a:	62bb      	str	r3, [r7, #40]	; 0x28
                                            ('.' << 8)   | ('?' << 0);  // "?.?"
                        }
                        *(uint32_t*)pcBuf = u32PrntErrVal;
    960c:	68fb      	ldr	r3, [r7, #12]
    960e:	6aba      	ldr	r2, [r7, #40]	; 0x28
    9610:	601a      	str	r2, [r3, #0]
                        iVal = 3;
    9612:	2303      	movs	r3, #3
    9614:	637b      	str	r3, [r7, #52]	; 0x34
                    }
                    ui32CharCnt += iVal;
    9616:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    9618:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    961a:	4413      	add	r3, r2
    961c:	63fb      	str	r3, [r7, #60]	; 0x3c
                    pcBuf += iVal;
    961e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    9620:	68fa      	ldr	r2, [r7, #12]
    9622:	4413      	add	r3, r2
    9624:	60fb      	str	r3, [r7, #12]
                }
                break;
    9626:	e00e      	b.n	9646 <am_util_stdio_vsprintf+0x5d6>
            // For non-handled specifiers, we'll just print the character.
            // e.g. this will allow the normal printing of a '%' using
            // "%%".
            //
            default:
                if ( pcBuf )
    9628:	68fb      	ldr	r3, [r7, #12]
    962a:	2b00      	cmp	r3, #0
    962c:	d005      	beq.n	963a <am_util_stdio_vsprintf+0x5ca>
                {
                    *pcBuf++ = *pcFmt;
    962e:	68fb      	ldr	r3, [r7, #12]
    9630:	1c5a      	adds	r2, r3, #1
    9632:	60fa      	str	r2, [r7, #12]
    9634:	68ba      	ldr	r2, [r7, #8]
    9636:	7812      	ldrb	r2, [r2, #0]
    9638:	701a      	strb	r2, [r3, #0]
                }

                ++ui32CharCnt;
    963a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    963c:	3301      	adds	r3, #1
    963e:	63fb      	str	r3, [r7, #60]	; 0x3c
                break;
    9640:	e002      	b.n	9648 <am_util_stdio_vsprintf+0x5d8>
                break;
    9642:	bf00      	nop
    9644:	e000      	b.n	9648 <am_util_stdio_vsprintf+0x5d8>
                break;
    9646:	bf00      	nop
        } // switch()

        //
        // Bump the format specification to the next character
        //
        ++pcFmt;
    9648:	68bb      	ldr	r3, [r7, #8]
    964a:	3301      	adds	r3, #1
    964c:	60bb      	str	r3, [r7, #8]
    while ( *pcFmt != 0x0 )
    964e:	68bb      	ldr	r3, [r7, #8]
    9650:	781b      	ldrb	r3, [r3, #0]
    9652:	2b00      	cmp	r3, #0
    9654:	f47f ad17 	bne.w	9086 <am_util_stdio_vsprintf+0x16>
    } // while ()

    //
    // Terminate the string
    //
    if ( pcBuf )
    9658:	68fb      	ldr	r3, [r7, #12]
    965a:	2b00      	cmp	r3, #0
    965c:	d002      	beq.n	9664 <am_util_stdio_vsprintf+0x5f4>
    {
        *pcBuf = 0x0;
    965e:	68fb      	ldr	r3, [r7, #12]
    9660:	2200      	movs	r2, #0
    9662:	701a      	strb	r2, [r3, #0]
    }

    return (ui32CharCnt);
    9664:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
}
    9666:	4618      	mov	r0, r3
    9668:	3754      	adds	r7, #84	; 0x54
    966a:	46bd      	mov	sp, r7
    966c:	bd90      	pop	{r4, r7, pc}
    966e:	bf00      	nop
    9670:	00302e30 	.word	0x00302e30
    9674:	00232e23 	.word	0x00232e23
    9678:	003f2e3f 	.word	0x003f2e3f

0000967c <am_util_stdio_printf>:
//! @return uint32_t representing the number of characters printed.
//
// *****************************************************************************
uint32_t
am_util_stdio_printf(const char *pcFmt, ...)
{
    967c:	b40f      	push	{r0, r1, r2, r3}
    967e:	b580      	push	{r7, lr}
    9680:	b082      	sub	sp, #8
    9682:	af00      	add	r7, sp, #0

    //
    // Convert to the desired string.
    //
    va_list pArgs;
    va_start(pArgs, pcFmt);
    9684:	f107 0314 	add.w	r3, r7, #20
    9688:	603b      	str	r3, [r7, #0]
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
    968a:	683a      	ldr	r2, [r7, #0]
    968c:	6939      	ldr	r1, [r7, #16]
    968e:	4808      	ldr	r0, [pc, #32]	; (96b0 <am_util_stdio_printf+0x34>)
    9690:	f7ff fcee 	bl	9070 <am_util_stdio_vsprintf>
    9694:	6078      	str	r0, [r7, #4]
    va_end(pArgs);

    //
    // This is where we print the buffer to the configured interface.
    //
    g_pfnCharPrint(g_prfbuf);
    9696:	4b07      	ldr	r3, [pc, #28]	; (96b4 <am_util_stdio_printf+0x38>)
    9698:	681b      	ldr	r3, [r3, #0]
    969a:	4805      	ldr	r0, [pc, #20]	; (96b0 <am_util_stdio_printf+0x34>)
    969c:	4798      	blx	r3

    //
    // return the number of characters printed.
    //
    return ui32NumChars;
    969e:	687b      	ldr	r3, [r7, #4]
}
    96a0:	4618      	mov	r0, r3
    96a2:	3708      	adds	r7, #8
    96a4:	46bd      	mov	sp, r7
    96a6:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    96aa:	b004      	add	sp, #16
    96ac:	4770      	bx	lr
    96ae:	bf00      	nop
    96b0:	10001038 	.word	0x10001038
    96b4:	1000114c 	.word	0x1000114c

000096b8 <am_util_stdio_terminal_clear>:
//! @return None.
//
//*****************************************************************************
void
am_util_stdio_terminal_clear(void)
{
    96b8:	b580      	push	{r7, lr}
    96ba:	af00      	add	r7, sp, #0
    // left corner.
    // We'll first print a number of spaces, which helps get the ITM in sync
    // with AM Flash, especially after a reset event or a system clock
    // frequency change.
    //
    am_util_stdio_printf("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
    96bc:	4802      	ldr	r0, [pc, #8]	; (96c8 <am_util_stdio_terminal_clear+0x10>)
    96be:	f7ff ffdd 	bl	967c <am_util_stdio_printf>
}
    96c2:	bf00      	nop
    96c4:	bd80      	pop	{r7, pc}
    96c6:	bf00      	nop
    96c8:	0000a24c 	.word	0x0000a24c

000096cc <am_bsp_low_power_init>:
//! @return None.
//
//*****************************************************************************
void
am_bsp_low_power_init(void)
{
    96cc:	b508      	push	{r3, lr}
    //
    // Enable internal buck converters.
    //
    am_hal_pwrctrl_bucks_init();
    96ce:	f000 fc1b 	bl	9f08 <am_hal_pwrctrl_bucks_init>

    //
    // Initialize for low power in the power control block
    //
    am_hal_pwrctrl_low_power_init();
    96d2:	f000 fc87 	bl	9fe4 <am_hal_pwrctrl_low_power_init>

    //
    // Turn off the voltage comparator as this is enabled on reset.
    //
    am_hal_vcomp_disable();
    96d6:	f000 fda7 	bl	a228 <am_hal_vcomp_disable>

    //
    // Run the RTC off the LFRC.
    //
    am_hal_rtc_osc_select(AM_HAL_RTC_OSC_LFRC);
    96da:	2001      	movs	r0, #1
    96dc:	f000 fc92 	bl	a004 <am_hal_rtc_osc_select>

    //
    // Stop the XT and LFRC.
    //
    am_hal_clkgen_osc_stop(AM_HAL_CLKGEN_OSC_XT);
    96e0:	2001      	movs	r0, #1
    96e2:	f000 f943 	bl	996c <am_hal_clkgen_osc_stop>

    //
    // Disable the RTC.
    //
    am_hal_rtc_osc_disable();
}
    96e6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    am_hal_rtc_osc_disable();
    96ea:	f000 bc99 	b.w	a020 <am_hal_rtc_osc_disable>
    96ee:	bf00      	nop

000096f0 <am_bsp_debug_printf_enable>:
//! @return None.
//
//*****************************************************************************
void
am_bsp_debug_printf_enable(void)
{
    96f0:	b530      	push	{r4, r5, lr}
    am_hal_tpiu_config_t TPIUcfg;

    if ( g_ui32HALflags & AM_HAL_FLAGS_ITMSKIPENABLEDISABLE_M )
    96f2:	4b17      	ldr	r3, [pc, #92]	; (9750 <am_bsp_debug_printf_enable+0x60>)
    96f4:	681c      	ldr	r4, [r3, #0]
    96f6:	f014 0401 	ands.w	r4, r4, #1
{
    96fa:	b087      	sub	sp, #28
    if ( g_ui32HALflags & AM_HAL_FLAGS_ITMSKIPENABLEDISABLE_M )
    96fc:	d001      	beq.n	9702 <am_bsp_debug_printf_enable+0x12>
    // Enable the ITM and TPIU
    //
    TPIUcfg.ui32SetItmBaud = AM_HAL_TPIU_BAUD_1M;
    am_hal_tpiu_enable(&TPIUcfg);
    am_bsp_pin_enable(ITM_SWO);
}
    96fe:	b007      	add	sp, #28
    9700:	bd30      	pop	{r4, r5, pc}
    AM_REGVAL(AM_REG_ITM_TCR_O) =
    9702:	4a14      	ldr	r2, [pc, #80]	; (9754 <am_bsp_debug_printf_enable+0x64>)
    9704:	4914      	ldr	r1, [pc, #80]	; (9758 <am_bsp_debug_printf_enable+0x68>)
    TPIUcfg.ui32SetItmBaud = AM_HAL_TPIU_BAUD_1M;
    9706:	4d15      	ldr	r5, [pc, #84]	; (975c <am_bsp_debug_printf_enable+0x6c>)
    AM_REGVAL(AM_REG_ITM_TCR_O) =
    9708:	6011      	str	r1, [r2, #0]
    TPIUcfg.ui32SetItmBaud = AM_HAL_TPIU_BAUD_1M;
    970a:	a806      	add	r0, sp, #24
    970c:	f840 5d14 	str.w	r5, [r0, #-20]!
    am_hal_tpiu_enable(&TPIUcfg);
    9710:	f000 fd2c 	bl	a16c <am_hal_tpiu_enable>
    am_bsp_pin_enable(ITM_SWO);
    9714:	f000 fa76 	bl	9c04 <am_hal_interrupt_master_disable>
    9718:	4a11      	ldr	r2, [pc, #68]	; (9760 <am_bsp_debug_printf_enable+0x70>)
    971a:	9000      	str	r0, [sp, #0]
    971c:	4d11      	ldr	r5, [pc, #68]	; (9764 <am_bsp_debug_printf_enable+0x74>)
    971e:	4912      	ldr	r1, [pc, #72]	; (9768 <am_bsp_debug_printf_enable+0x78>)
    9720:	2073      	movs	r0, #115	; 0x73
    9722:	6010      	str	r0, [r2, #0]
    9724:	682b      	ldr	r3, [r5, #0]
    9726:	4811      	ldr	r0, [pc, #68]	; (976c <am_bsp_debug_printf_enable+0x7c>)
    9728:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    972c:	602b      	str	r3, [r5, #0]
    972e:	6805      	ldr	r5, [r0, #0]
    9730:	f425 4c7f 	bic.w	ip, r5, #65280	; 0xff00
    9734:	f44c 5380 	orr.w	r3, ip, #4096	; 0x1000
    9738:	6003      	str	r3, [r0, #0]
    973a:	6808      	ldr	r0, [r1, #0]
    973c:	f420 457f 	bic.w	r5, r0, #65280	; 0xff00
    9740:	600d      	str	r5, [r1, #0]
    9742:	6014      	str	r4, [r2, #0]
    9744:	9800      	ldr	r0, [sp, #0]
    9746:	f000 fa61 	bl	9c0c <am_hal_interrupt_master_set>
}
    974a:	b007      	add	sp, #28
    974c:	bd30      	pop	{r4, r5, pc}
    974e:	bf00      	nop
    9750:	1000113c 	.word	0x1000113c
    9754:	e0000e80 	.word	0xe0000e80
    9758:	00150511 	.word	0x00150511
    975c:	000f4240 	.word	0x000f4240
    9760:	40010060 	.word	0x40010060
    9764:	40010054 	.word	0x40010054
    9768:	40010108 	.word	0x40010108
    976c:	40010028 	.word	0x40010028

00009770 <am_bsp_debug_printf_disable>:
//! @return None.
//
//*****************************************************************************
void
am_bsp_debug_printf_disable(void)
{
    9770:	b530      	push	{r4, r5, lr}
    if ( g_ui32HALflags & AM_HAL_FLAGS_ITMSKIPENABLEDISABLE_M )
    9772:	4b14      	ldr	r3, [pc, #80]	; (97c4 <am_bsp_debug_printf_disable+0x54>)
    9774:	681c      	ldr	r4, [r3, #0]
    9776:	f014 0401 	ands.w	r4, r4, #1
{
    977a:	b083      	sub	sp, #12
    if ( g_ui32HALflags & AM_HAL_FLAGS_ITMSKIPENABLEDISABLE_M )
    977c:	d120      	bne.n	97c0 <am_bsp_debug_printf_disable+0x50>
    }

    //
    // Disable the TPIU
    //
    am_hal_itm_not_busy();
    977e:	f000 fa75 	bl	9c6c <am_hal_itm_not_busy>
    am_hal_gpio_pin_config(AM_BSP_GPIO_ITM_SWO, AM_HAL_GPIO_OUTPUT);
    9782:	f000 fa3f 	bl	9c04 <am_hal_interrupt_master_disable>
    9786:	4a10      	ldr	r2, [pc, #64]	; (97c8 <am_bsp_debug_printf_disable+0x58>)
    9788:	9001      	str	r0, [sp, #4]
    978a:	4d10      	ldr	r5, [pc, #64]	; (97cc <am_bsp_debug_printf_disable+0x5c>)
    978c:	4910      	ldr	r1, [pc, #64]	; (97d0 <am_bsp_debug_printf_disable+0x60>)
    978e:	2073      	movs	r0, #115	; 0x73
    9790:	6010      	str	r0, [r2, #0]
    9792:	682b      	ldr	r3, [r5, #0]
    9794:	480f      	ldr	r0, [pc, #60]	; (97d4 <am_bsp_debug_printf_disable+0x64>)
    9796:	f023 0c70 	bic.w	ip, r3, #112	; 0x70
    979a:	f04c 0320 	orr.w	r3, ip, #32
    979e:	602b      	str	r3, [r5, #0]
    97a0:	6805      	ldr	r5, [r0, #0]
    97a2:	f425 4c7f 	bic.w	ip, r5, #65280	; 0xff00
    97a6:	f44c 53c0 	orr.w	r3, ip, #6144	; 0x1800
    97aa:	6003      	str	r3, [r0, #0]
    97ac:	6808      	ldr	r0, [r1, #0]
    97ae:	f420 457f 	bic.w	r5, r0, #65280	; 0xff00
    97b2:	600d      	str	r5, [r1, #0]
    97b4:	6014      	str	r4, [r2, #0]
    97b6:	9801      	ldr	r0, [sp, #4]
    97b8:	f000 fa28 	bl	9c0c <am_hal_interrupt_master_set>
    am_hal_tpiu_disable();
    97bc:	f000 fd2e 	bl	a21c <am_hal_tpiu_disable>
}
    97c0:	b003      	add	sp, #12
    97c2:	bd30      	pop	{r4, r5, pc}
    97c4:	1000113c 	.word	0x1000113c
    97c8:	40010060 	.word	0x40010060
    97cc:	40010054 	.word	0x40010054
    97d0:	40010108 	.word	0x40010108
    97d4:	40010028 	.word	0x40010028

000097d8 <am_bsp_itm_string_print>:
//
//*****************************************************************************
void
am_bsp_itm_string_print(char *pcString)
{
    am_hal_itm_print(pcString);
    97d8:	f000 ba52 	b.w	9c80 <am_hal_itm_print>

000097dc <am_hal_cachectrl_enable>:
//! @return None.
//
//*****************************************************************************
void
am_hal_cachectrl_enable(const am_hal_cachectrl_config_t *psConfig)
{
    97dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    97de:	4605      	mov	r5, r0
                       AM_REG_CACHECTRL_CACHECFG_ENABLE_MONITOR(psConfig->ui32EnableCacheMonitoring) );

    //
    // Make sure the cache is enabled in the power control block.
    //
    am_hal_pwrctrl_memory_enable(AM_HAL_PWRCTRL_MEMEN_CACHE);
    97e0:	f04f 4020 	mov.w	r0, #2684354560	; 0xa0000000
                       AM_REG_CACHECTRL_CACHECFG_ENABLE_NC0( (psConfig->ui32EnableNCregions & 0x1) >> 0 )   |
    97e4:	78ab      	ldrb	r3, [r5, #2]
                       AM_REG_CACHECTRL_CACHECFG_LRU( psConfig->ui32LRU )                                   |
    97e6:	786c      	ldrb	r4, [r5, #1]
    ui32ConfigValue = (AM_REG_CACHECTRL_CACHECFG_ENABLE( 1 )                                                |
    97e8:	78ef      	ldrb	r7, [r5, #3]
                       AM_REG_CACHECTRL_CACHECFG_SERIAL(psConfig->ui32SerialCacheMode)                      |
    97ea:	792e      	ldrb	r6, [r5, #4]
                       AM_REG_CACHECTRL_CACHECFG_CACHE_CLKGATE( psConfig->ui32EnableCacheClockGating )      |
    97ec:	79a9      	ldrb	r1, [r5, #6]
                       AM_REG_CACHECTRL_CACHECFG_ENABLE_NC0( (psConfig->ui32EnableNCregions & 0x1) >> 0 )   |
    97ee:	009a      	lsls	r2, r3, #2
                       AM_REG_CACHECTRL_CACHECFG_LRU( psConfig->ui32LRU )                                   |
    97f0:	0064      	lsls	r4, r4, #1
                       AM_REG_CACHECTRL_CACHECFG_ENABLE_NC0( (psConfig->ui32EnableNCregions & 0x1) >> 0 )   |
    97f2:	f002 0204 	and.w	r2, r2, #4
                       AM_REG_CACHECTRL_CACHECFG_LRU( psConfig->ui32LRU )                                   |
    97f6:	f004 0402 	and.w	r4, r4, #2
    ui32ConfigValue = (AM_REG_CACHECTRL_CACHECFG_ENABLE( 1 )                                                |
    97fa:	4314      	orrs	r4, r2
    97fc:	f047 0701 	orr.w	r7, r7, #1
                       AM_REG_CACHECTRL_CACHECFG_CACHE_LS(psConfig->ui32EnableLightSleep )                  |
    9800:	79ea      	ldrb	r2, [r5, #7]
                       AM_REG_CACHECTRL_CACHECFG_SERIAL(psConfig->ui32SerialCacheMode)                      |
    9802:	01f6      	lsls	r6, r6, #7
    ui32ConfigValue = (AM_REG_CACHECTRL_CACHECFG_ENABLE( 1 )                                                |
    9804:	433c      	orrs	r4, r7
                       AM_REG_CACHECTRL_CACHECFG_SERIAL(psConfig->ui32SerialCacheMode)                      |
    9806:	b2f6      	uxtb	r6, r6
                       AM_REG_CACHECTRL_CACHECFG_DLY( psConfig->ui32Dly )                                   |
    9808:	7a2f      	ldrb	r7, [r5, #8]
                       AM_REG_CACHECTRL_CACHECFG_CACHE_CLKGATE( psConfig->ui32EnableCacheClockGating )      |
    980a:	0289      	lsls	r1, r1, #10
    ui32ConfigValue = (AM_REG_CACHECTRL_CACHECFG_ENABLE( 1 )                                                |
    980c:	4334      	orrs	r4, r6
                       AM_REG_CACHECTRL_CACHECFG_CACHE_CLKGATE( psConfig->ui32EnableCacheClockGating )      |
    980e:	f401 6180 	and.w	r1, r1, #1024	; 0x400
                       AM_REG_CACHECTRL_CACHECFG_SMDLY( psConfig->ui32SMDly )                               |
    9812:	7a6e      	ldrb	r6, [r5, #9]
                       AM_REG_CACHECTRL_CACHECFG_CACHE_LS(psConfig->ui32EnableLightSleep )                  |
    9814:	02d2      	lsls	r2, r2, #11
    ui32ConfigValue = (AM_REG_CACHECTRL_CACHECFG_ENABLE( 1 )                                                |
    9816:	430c      	orrs	r4, r1
                       AM_REG_CACHECTRL_CACHECFG_CACHE_LS(psConfig->ui32EnableLightSleep )                  |
    9818:	f402 6200 	and.w	r2, r2, #2048	; 0x800
                       AM_REG_CACHECTRL_CACHECFG_DATA_CLKGATE(psConfig->ui32EnableDataClockGating)          |
    981c:	7aa9      	ldrb	r1, [r5, #10]
                       AM_REG_CACHECTRL_CACHECFG_DLY( psConfig->ui32Dly )                                   |
    981e:	033f      	lsls	r7, r7, #12
    ui32ConfigValue = (AM_REG_CACHECTRL_CACHECFG_ENABLE( 1 )                                                |
    9820:	4314      	orrs	r4, r2
                       AM_REG_CACHECTRL_CACHECFG_DLY( psConfig->ui32Dly )                                   |
    9822:	b2bf      	uxth	r7, r7
                       AM_REG_CACHECTRL_CACHECFG_SMDLY( psConfig->ui32SMDly )                               |
    9824:	0436      	lsls	r6, r6, #16
                       AM_REG_CACHECTRL_CACHECFG_ENABLE_MONITOR(psConfig->ui32EnableCacheMonitoring) );
    9826:	7aea      	ldrb	r2, [r5, #11]
    ui32ConfigValue = (AM_REG_CACHECTRL_CACHECFG_ENABLE( 1 )                                                |
    9828:	433c      	orrs	r4, r7
                       AM_REG_CACHECTRL_CACHECFG_DATA_CLKGATE(psConfig->ui32EnableDataClockGating)          |
    982a:	0509      	lsls	r1, r1, #20
                       AM_REG_CACHECTRL_CACHECFG_SMDLY( psConfig->ui32SMDly )                               |
    982c:	f406 2770 	and.w	r7, r6, #983040	; 0xf0000
                       AM_REG_CACHECTRL_CACHECFG_ENABLE_MONITOR(psConfig->ui32EnableCacheMonitoring) );
    9830:	0612      	lsls	r2, r2, #24
    ui32ConfigValue = (AM_REG_CACHECTRL_CACHECFG_ENABLE( 1 )                                                |
    9832:	433c      	orrs	r4, r7
                       AM_REG_CACHECTRL_CACHECFG_DATA_CLKGATE(psConfig->ui32EnableDataClockGating)          |
    9834:	f401 1680 	and.w	r6, r1, #1048576	; 0x100000
                       AM_REG_CACHECTRL_CACHECFG_ENABLE_NC1( (psConfig->ui32EnableNCregions & 0x2) >> 1 )   |
    9838:	009b      	lsls	r3, r3, #2
                       AM_REG_CACHECTRL_CACHECFG_ENABLE_MONITOR(psConfig->ui32EnableCacheMonitoring) );
    983a:	f002 7780 	and.w	r7, r2, #16777216	; 0x1000000
    ui32ConfigValue = (AM_REG_CACHECTRL_CACHECFG_ENABLE( 1 )                                                |
    983e:	4334      	orrs	r4, r6
                       AM_REG_CACHECTRL_CACHECFG_ENABLE_NC1( (psConfig->ui32EnableNCregions & 0x2) >> 1 )   |
    9840:	f003 0108 	and.w	r1, r3, #8
    ui32ConfigValue = (AM_REG_CACHECTRL_CACHECFG_ENABLE( 1 )                                                |
    9844:	433c      	orrs	r4, r7
    9846:	430c      	orrs	r4, r1
    am_hal_pwrctrl_memory_enable(AM_HAL_PWRCTRL_MEMEN_CACHE);
    9848:	f000 fa58 	bl	9cfc <am_hal_pwrctrl_memory_enable>

    //
    // Set the initial cache settings.
    //
    AM_REG(CACHECTRL, CACHECFG) = ui32ConfigValue;
    984c:	482c      	ldr	r0, [pc, #176]	; (9900 <am_hal_cachectrl_enable+0x124>)
    //
    // Wait for the cache ready signal.
    //
    for (ui32Timeout = 0; ui32Timeout < 50; ui32Timeout++)
    {
        if (AM_BFM(CACHECTRL, CACHECTRL, CACHE_READY))
    984e:	4b2d      	ldr	r3, [pc, #180]	; (9904 <am_hal_cachectrl_enable+0x128>)
    AM_REG(CACHECTRL, CACHECFG) = ui32ConfigValue;
    9850:	6004      	str	r4, [r0, #0]
    9852:	2232      	movs	r2, #50	; 0x32
        if (AM_BFM(CACHECTRL, CACHECTRL, CACHE_READY))
    9854:	681e      	ldr	r6, [r3, #0]
    9856:	0777      	lsls	r7, r6, #29
    9858:	d41e      	bmi.n	9898 <am_hal_cachectrl_enable+0xbc>
    985a:	681f      	ldr	r7, [r3, #0]
    985c:	077e      	lsls	r6, r7, #29
    985e:	f102 32ff 	add.w	r2, r2, #4294967295
    9862:	d419      	bmi.n	9898 <am_hal_cachectrl_enable+0xbc>
    9864:	6819      	ldr	r1, [r3, #0]
    9866:	074f      	lsls	r7, r1, #29
    9868:	d416      	bmi.n	9898 <am_hal_cachectrl_enable+0xbc>
    986a:	6818      	ldr	r0, [r3, #0]
    986c:	0746      	lsls	r6, r0, #29
    986e:	d413      	bmi.n	9898 <am_hal_cachectrl_enable+0xbc>
    9870:	681e      	ldr	r6, [r3, #0]
    9872:	0770      	lsls	r0, r6, #29
    9874:	d410      	bmi.n	9898 <am_hal_cachectrl_enable+0xbc>
    9876:	681f      	ldr	r7, [r3, #0]
    9878:	0779      	lsls	r1, r7, #29
    987a:	d40d      	bmi.n	9898 <am_hal_cachectrl_enable+0xbc>
    987c:	6819      	ldr	r1, [r3, #0]
    987e:	074f      	lsls	r7, r1, #29
    9880:	d40a      	bmi.n	9898 <am_hal_cachectrl_enable+0xbc>
    9882:	6818      	ldr	r0, [r3, #0]
    9884:	0746      	lsls	r6, r0, #29
    9886:	d407      	bmi.n	9898 <am_hal_cachectrl_enable+0xbc>
    9888:	681e      	ldr	r6, [r3, #0]
    988a:	0770      	lsls	r0, r6, #29
    988c:	d404      	bmi.n	9898 <am_hal_cachectrl_enable+0xbc>
    988e:	681f      	ldr	r7, [r3, #0]
    9890:	0779      	lsls	r1, r7, #29
    9892:	d401      	bmi.n	9898 <am_hal_cachectrl_enable+0xbc>
    for (ui32Timeout = 0; ui32Timeout < 50; ui32Timeout++)
    9894:	3a09      	subs	r2, #9
    9896:	d1dd      	bne.n	9854 <am_hal_cachectrl_enable+0x78>
    }

    //
    // Manually invalidate the cache (workaround for the issue described above.)
    //
    AM_BFW(CACHECTRL, CACHECTRL, INVALIDATE, 1);
    9898:	4b1a      	ldr	r3, [pc, #104]	; (9904 <am_hal_cachectrl_enable+0x128>)
    989a:	681a      	ldr	r2, [r3, #0]
    989c:	f042 0101 	orr.w	r1, r2, #1
    98a0:	6019      	str	r1, [r3, #0]
    98a2:	2232      	movs	r2, #50	; 0x32
    //
    // Wait for the cache ready signal again.
    //
    for (ui32Timeout = 0; ui32Timeout < 50; ui32Timeout++)
    {
        if (AM_BFM(CACHECTRL, CACHECTRL, CACHE_READY))
    98a4:	6818      	ldr	r0, [r3, #0]
    98a6:	0740      	lsls	r0, r0, #29
    98a8:	d41e      	bmi.n	98e8 <am_hal_cachectrl_enable+0x10c>
    98aa:	681e      	ldr	r6, [r3, #0]
    98ac:	0771      	lsls	r1, r6, #29
    98ae:	f102 32ff 	add.w	r2, r2, #4294967295
    98b2:	d419      	bmi.n	98e8 <am_hal_cachectrl_enable+0x10c>
    98b4:	681f      	ldr	r7, [r3, #0]
    98b6:	077f      	lsls	r7, r7, #29
    98b8:	d416      	bmi.n	98e8 <am_hal_cachectrl_enable+0x10c>
    98ba:	6819      	ldr	r1, [r3, #0]
    98bc:	074e      	lsls	r6, r1, #29
    98be:	d413      	bmi.n	98e8 <am_hal_cachectrl_enable+0x10c>
    98c0:	6818      	ldr	r0, [r3, #0]
    98c2:	0740      	lsls	r0, r0, #29
    98c4:	d410      	bmi.n	98e8 <am_hal_cachectrl_enable+0x10c>
    98c6:	681e      	ldr	r6, [r3, #0]
    98c8:	0771      	lsls	r1, r6, #29
    98ca:	d40d      	bmi.n	98e8 <am_hal_cachectrl_enable+0x10c>
    98cc:	681f      	ldr	r7, [r3, #0]
    98ce:	077f      	lsls	r7, r7, #29
    98d0:	d40a      	bmi.n	98e8 <am_hal_cachectrl_enable+0x10c>
    98d2:	6819      	ldr	r1, [r3, #0]
    98d4:	074e      	lsls	r6, r1, #29
    98d6:	d407      	bmi.n	98e8 <am_hal_cachectrl_enable+0x10c>
    98d8:	6818      	ldr	r0, [r3, #0]
    98da:	0740      	lsls	r0, r0, #29
    98dc:	d404      	bmi.n	98e8 <am_hal_cachectrl_enable+0x10c>
    98de:	681e      	ldr	r6, [r3, #0]
    98e0:	0771      	lsls	r1, r6, #29
    98e2:	d401      	bmi.n	98e8 <am_hal_cachectrl_enable+0x10c>
    for (ui32Timeout = 0; ui32Timeout < 50; ui32Timeout++)
    98e4:	3a09      	subs	r2, #9
    98e6:	d1dd      	bne.n	98a4 <am_hal_cachectrl_enable+0xc8>

    //
    // Now that the cache is running, and correctly marked invalid, we can OR in
    // the ICACHE and DCACHE settings.
    //
    ui32ConfigValue |= (AM_REG_CACHECTRL_CACHECFG_ICACHE_ENABLE( (psConfig->ui32FlashCachingEnables & 0x1) >> 0 )   |
    98e8:	796d      	ldrb	r5, [r5, #5]
                        AM_REG_CACHECTRL_CACHECFG_DCACHE_ENABLE( (psConfig->ui32FlashCachingEnables & 0x2) >> 1 ) );

    //
    // Write the final configuration settings to the CACHECTRL register.
    //
    AM_REG(CACHECTRL, CACHECFG) = ui32ConfigValue;
    98ea:	4f05      	ldr	r7, [pc, #20]	; (9900 <am_hal_cachectrl_enable+0x124>)
                        AM_REG_CACHECTRL_CACHECFG_DCACHE_ENABLE( (psConfig->ui32FlashCachingEnables & 0x2) >> 1 ) );
    98ec:	022b      	lsls	r3, r5, #8
    98ee:	f403 7100 	and.w	r1, r3, #512	; 0x200
    ui32ConfigValue |= (AM_REG_CACHECTRL_CACHECFG_ICACHE_ENABLE( (psConfig->ui32FlashCachingEnables & 0x1) >> 0 )   |
    98f2:	f403 7280 	and.w	r2, r3, #256	; 0x100
    98f6:	4311      	orrs	r1, r2
    98f8:	430c      	orrs	r4, r1
    AM_REG(CACHECTRL, CACHECFG) = ui32ConfigValue;
    98fa:	603c      	str	r4, [r7, #0]
    98fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    98fe:	bf00      	nop
    9900:	40018000 	.word	0x40018000
    9904:	40018008 	.word	0x40018008

00009908 <am_hal_clkgen_sysclk_select>:
//! @return None.
//
//*****************************************************************************
void
am_hal_clkgen_sysclk_select(uint32_t ui32ClockSetting)
{
    9908:	b510      	push	{r4, lr}
    am_hal_debug_assert_msg(ui32ClockSetting == AM_HAL_CLKGEN_SYSCLK_48MHZ,
    990a:	4604      	mov	r4, r0
    990c:	b120      	cbz	r0, 9918 <am_hal_clkgen_sysclk_select+0x10>
    990e:	4a06      	ldr	r2, [pc, #24]	; (9928 <am_hal_clkgen_sysclk_select+0x20>)
    9910:	4806      	ldr	r0, [pc, #24]	; (992c <am_hal_clkgen_sysclk_select+0x24>)
    9912:	2153      	movs	r1, #83	; 0x53
    9914:	f000 f944 	bl	9ba0 <am_hal_debug_error>
        "am_hal_clkgen_sysclk_select(): invalid clock setting.");

    //
    // Unlock the clock control register.
    //
    AM_REG(CLKGEN, CLKKEY) = AM_REG_CLKGEN_CLKKEY_KEYVAL;
    9918:	4b05      	ldr	r3, [pc, #20]	; (9930 <am_hal_clkgen_sysclk_select+0x28>)

    //
    // Set the HFRC divisor to the required operating value.
    //
    AM_REG(CLKGEN, CCTRL) = ui32ClockSetting;
    991a:	4906      	ldr	r1, [pc, #24]	; (9934 <am_hal_clkgen_sysclk_select+0x2c>)
    AM_REG(CLKGEN, CLKKEY) = AM_REG_CLKGEN_CLKKEY_KEYVAL;
    991c:	2047      	movs	r0, #71	; 0x47

    //
    // Lock the clock configuration registers.
    //
    AM_REG(CLKGEN, CLKKEY) = 0;
    991e:	2200      	movs	r2, #0
    AM_REG(CLKGEN, CLKKEY) = AM_REG_CLKGEN_CLKKEY_KEYVAL;
    9920:	6018      	str	r0, [r3, #0]
    AM_REG(CLKGEN, CCTRL) = ui32ClockSetting;
    9922:	600c      	str	r4, [r1, #0]
    AM_REG(CLKGEN, CLKKEY) = 0;
    9924:	601a      	str	r2, [r3, #0]
    9926:	bd10      	pop	{r4, pc}
    9928:	0000a26c 	.word	0x0000a26c
    992c:	0000a2a4 	.word	0x0000a2a4
    9930:	40004014 	.word	0x40004014
    9934:	40004018 	.word	0x40004018

00009938 <am_hal_clkgen_sysclk_get>:
    uint32_t ui32ClockSetting;

    //
    // Read the value of the clock divider.
    //
    ui32ClockSetting = AM_REG(CLKGEN, CCTRL) & AM_REG_CLKGEN_CCTRL_CORESEL_M;
    9938:	4b04      	ldr	r3, [pc, #16]	; (994c <am_hal_clkgen_sysclk_get+0x14>)

    switch ( ui32ClockSetting )
    {
        case AM_REG_CLKGEN_CCTRL_CORESEL_HFRC:
            return 48000000;
    993a:	4905      	ldr	r1, [pc, #20]	; (9950 <am_hal_clkgen_sysclk_get+0x18>)
    ui32ClockSetting = AM_REG(CLKGEN, CCTRL) & AM_REG_CLKGEN_CCTRL_CORESEL_M;
    993c:	681a      	ldr	r2, [r3, #0]
            return 48000000;
    993e:	4805      	ldr	r0, [pc, #20]	; (9954 <am_hal_clkgen_sysclk_get+0x1c>)
    switch ( ui32ClockSetting )
    9940:	f012 0f01 	tst.w	r2, #1
        case AM_REG_CLKGEN_CCTRL_CORESEL_HFRC_DIV2:
            return 24000000;
        default:
            return 0xFFFFFFFF;
    }
}
    9944:	bf08      	it	eq
    9946:	4608      	moveq	r0, r1
    9948:	4770      	bx	lr
    994a:	bf00      	nop
    994c:	40004018 	.word	0x40004018
    9950:	02dc6c00 	.word	0x02dc6c00
    9954:	016e3600 	.word	0x016e3600

00009958 <am_hal_clkgen_osc_start>:
//
//*****************************************************************************
void
am_hal_clkgen_osc_start(uint32_t ui32OscFlags)
{
    if ( ui32OscFlags & (AM_HAL_CLKGEN_OSC_LFRC | AM_HAL_CLKGEN_OSC_XT) )
    9958:	0783      	lsls	r3, r0, #30
    995a:	d004      	beq.n	9966 <am_hal_clkgen_osc_start+0xe>
    {
        //
        // Start the oscillator(s).
        // Note that these bits are cleared in order to enable the oscillator.
        //
        AM_REG(CLKGEN, OCTRL) &= ~ui32OscFlags;
    995c:	4a02      	ldr	r2, [pc, #8]	; (9968 <am_hal_clkgen_osc_start+0x10>)
    995e:	6813      	ldr	r3, [r2, #0]
    9960:	ea23 0000 	bic.w	r0, r3, r0
    9964:	6010      	str	r0, [r2, #0]
    9966:	4770      	bx	lr
    9968:	4000400c 	.word	0x4000400c

0000996c <am_hal_clkgen_osc_stop>:
//
//*****************************************************************************
void
am_hal_clkgen_osc_stop(uint32_t ui32OscFlags)
{
    if ( ui32OscFlags & (AM_HAL_CLKGEN_OSC_LFRC | AM_HAL_CLKGEN_OSC_XT) )
    996c:	0783      	lsls	r3, r0, #30
    996e:	d003      	beq.n	9978 <am_hal_clkgen_osc_stop+0xc>
    {
        //
        // Stop the oscillator(s).
        // Note that these bits are set in order to stop the oscillator.
        //
        AM_REG(CLKGEN, OCTRL) |= ui32OscFlags;
    9970:	4b02      	ldr	r3, [pc, #8]	; (997c <am_hal_clkgen_osc_stop+0x10>)
    9972:	681a      	ldr	r2, [r3, #0]
    9974:	4310      	orrs	r0, r2
    9976:	6018      	str	r0, [r3, #0]
    9978:	4770      	bx	lr
    997a:	bf00      	nop
    997c:	4000400c 	.word	0x4000400c

00009980 <am_hal_ctimer_config>:
//
//*****************************************************************************
void
am_hal_ctimer_config(uint32_t ui32TimerNumber,
                     am_hal_ctimer_config_t *psConfig)
{
    9980:	b530      	push	{r4, r5, lr}
    9982:	4604      	mov	r4, r0
                      (psConfig->ui32TimerBConfig << 16) );

    //
    // OR in the Link bit if the timers need to be linked.
    //
    ui32ConfigVal |= psConfig->ui32Link ? AM_HAL_CTIMER_LINK : 0;
    9984:	6808      	ldr	r0, [r1, #0]
                      (psConfig->ui32TimerBConfig << 16) );
    9986:	688a      	ldr	r2, [r1, #8]
    ui32ConfigVal = ( (psConfig->ui32TimerAConfig)  |
    9988:	684b      	ldr	r3, [r1, #4]
    ui32ConfigVal |= psConfig->ui32Link ? AM_HAL_CTIMER_LINK : 0;
    998a:	2800      	cmp	r0, #0
    ui32ConfigVal = ( (psConfig->ui32TimerAConfig)  |
    998c:	ea43 4102 	orr.w	r1, r3, r2, lsl #16
    ui32ConfigVal |= psConfig->ui32Link ? AM_HAL_CTIMER_LINK : 0;
    9990:	bf14      	ite	ne
    9992:	f04f 4500 	movne.w	r5, #2147483648	; 0x80000000
    9996:	2500      	moveq	r5, #0
{
    9998:	b083      	sub	sp, #12
    ui32ConfigVal |= psConfig->ui32Link ? AM_HAL_CTIMER_LINK : 0;
    999a:	430d      	orrs	r5, r1

    //
    // Begin critical section while config registers are read and modified.
    //
    AM_CRITICAL_BEGIN_ASM
    999c:	f000 f932 	bl	9c04 <am_hal_interrupt_master_disable>

    //
    // Find the correct register to write.
    //
    pui32ConfigReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
                                  (ui32TimerNumber * TIMER_OFFSET));
    99a0:	0124      	lsls	r4, r4, #4
    pui32ConfigReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
    99a2:	4a2a      	ldr	r2, [pc, #168]	; (9a4c <am_hal_ctimer_config+0xcc>)
    AM_CRITICAL_BEGIN_ASM
    99a4:	9001      	str	r0, [sp, #4]
    ui32TimerASrc = AM_BFR(CTIMER, STCFG, CLKSEL);
    99a6:	482a      	ldr	r0, [pc, #168]	; (9a50 <am_hal_ctimer_config+0xd0>)

    //
    // Write our configuration value.
    //
    AM_REGVAL(pui32ConfigReg) = ui32ConfigVal;
    99a8:	50a5      	str	r5, [r4, r2]
    ui32TimerASrc = AM_BFR(CTIMER, STCFG, CLKSEL);
    99aa:	6805      	ldr	r5, [r0, #0]
    99ac:	f005 0c0f 	and.w	ip, r5, #15
    if ( (ui32TimerASrc == AM_REG_CTIMER_STCFG_CLKSEL_HFRC_DIV16)   ||
    99b0:	f10c 33ff 	add.w	r3, ip, #4294967295
    99b4:	2b01      	cmp	r3, #1
    99b6:	d93f      	bls.n	9a38 <am_hal_ctimer_config+0xb8>
    ui32TimerASrc = AM_BFX(CTIMER, CTRL0, TMRA0CLK, *pui32ConfigReg) -
    99b8:	6811      	ldr	r1, [r2, #0]
    99ba:	f3c1 0e44 	ubfx	lr, r1, #1, #5
    99be:	f10e 34ff 	add.w	r4, lr, #4294967295
    ui32TimerBSrc = AM_BFX(CTIMER, CTRL0, TMRB0CLK, *pui32ConfigReg) -
    99c2:	f3c1 4244 	ubfx	r2, r1, #17, #5
    if ( (ui32TimerASrc <= (AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4K) -
    99c6:	2c04      	cmp	r4, #4
    ui32TimerBSrc = AM_BFX(CTIMER, CTRL0, TMRB0CLK, *pui32ConfigReg) -
    99c8:	f102 30ff 	add.w	r0, r2, #4294967295
    if ( (ui32TimerASrc <= (AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4K) -
    99cc:	d934      	bls.n	9a38 <am_hal_ctimer_config+0xb8>
                            AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4)))  ||
    99ce:	2804      	cmp	r0, #4
    99d0:	d932      	bls.n	9a38 <am_hal_ctimer_config+0xb8>
    ui32TimerASrc = AM_BFX(CTIMER, CTRL0, TMRA0CLK, *pui32ConfigReg) -
    99d2:	4d20      	ldr	r5, [pc, #128]	; (9a54 <am_hal_ctimer_config+0xd4>)
    99d4:	682b      	ldr	r3, [r5, #0]
    99d6:	f3c3 0c44 	ubfx	ip, r3, #1, #5
    99da:	f10c 31ff 	add.w	r1, ip, #4294967295
    ui32TimerBSrc = AM_BFX(CTIMER, CTRL0, TMRB0CLK, *pui32ConfigReg) -
    99de:	f3c3 4e44 	ubfx	lr, r3, #17, #5
    if ( (ui32TimerASrc <= (AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4K) -
    99e2:	2904      	cmp	r1, #4
    ui32TimerBSrc = AM_BFX(CTIMER, CTRL0, TMRB0CLK, *pui32ConfigReg) -
    99e4:	f10e 34ff 	add.w	r4, lr, #4294967295
    if ( (ui32TimerASrc <= (AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4K) -
    99e8:	d926      	bls.n	9a38 <am_hal_ctimer_config+0xb8>
                            AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4)))  ||
    99ea:	2c04      	cmp	r4, #4
    99ec:	d924      	bls.n	9a38 <am_hal_ctimer_config+0xb8>
    ui32TimerASrc = AM_BFX(CTIMER, CTRL0, TMRA0CLK, *pui32ConfigReg) -
    99ee:	4a1a      	ldr	r2, [pc, #104]	; (9a58 <am_hal_ctimer_config+0xd8>)
    99f0:	6810      	ldr	r0, [r2, #0]
    99f2:	f3c0 0544 	ubfx	r5, r0, #1, #5
    99f6:	1e69      	subs	r1, r5, #1
    ui32TimerBSrc = AM_BFX(CTIMER, CTRL0, TMRB0CLK, *pui32ConfigReg) -
    99f8:	f3c0 4344 	ubfx	r3, r0, #17, #5
    if ( (ui32TimerASrc <= (AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4K) -
    99fc:	2904      	cmp	r1, #4
    ui32TimerBSrc = AM_BFX(CTIMER, CTRL0, TMRB0CLK, *pui32ConfigReg) -
    99fe:	f103 34ff 	add.w	r4, r3, #4294967295
    if ( (ui32TimerASrc <= (AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4K) -
    9a02:	d919      	bls.n	9a38 <am_hal_ctimer_config+0xb8>
                            AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4)))  ||
    9a04:	2c04      	cmp	r4, #4
    9a06:	d917      	bls.n	9a38 <am_hal_ctimer_config+0xb8>
    ui32TimerASrc = AM_BFX(CTIMER, CTRL0, TMRA0CLK, *pui32ConfigReg) -
    9a08:	4a14      	ldr	r2, [pc, #80]	; (9a5c <am_hal_ctimer_config+0xdc>)
    9a0a:	6810      	ldr	r0, [r2, #0]
    9a0c:	f3c0 0c44 	ubfx	ip, r0, #1, #5
    9a10:	f10c 35ff 	add.w	r5, ip, #4294967295
    ui32TimerBSrc = AM_BFX(CTIMER, CTRL0, TMRB0CLK, *pui32ConfigReg) -
    9a14:	f3c0 4e44 	ubfx	lr, r0, #17, #5
    if ( (ui32TimerASrc <= (AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4K) -
    9a18:	2d04      	cmp	r5, #4
    ui32TimerBSrc = AM_BFX(CTIMER, CTRL0, TMRB0CLK, *pui32ConfigReg) -
    9a1a:	f10e 31ff 	add.w	r1, lr, #4294967295
    if ( (ui32TimerASrc <= (AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4K) -
    9a1e:	d90b      	bls.n	9a38 <am_hal_ctimer_config+0xb8>
                            AM_ENUMX(CTIMER, CTRL0, TMRA0CLK, HFRC_DIV4)))  ||
    9a20:	2904      	cmp	r1, #4
    9a22:	d909      	bls.n	9a38 <am_hal_ctimer_config+0xb8>
    {
        AM_BFW(PWRCTRL, MISCOPT, DIS_LDOLPMODE_TIMERS, 0);
    }
    else
    {
        AM_BFW(PWRCTRL, MISCOPT, DIS_LDOLPMODE_TIMERS, 1);
    9a24:	4c0e      	ldr	r4, [pc, #56]	; (9a60 <am_hal_ctimer_config+0xe0>)
    9a26:	6823      	ldr	r3, [r4, #0]
    9a28:	f043 0204 	orr.w	r2, r3, #4
    9a2c:	6022      	str	r2, [r4, #0]
    }

    //
    // Done with critical section.
    //
    AM_CRITICAL_END_ASM
    9a2e:	9801      	ldr	r0, [sp, #4]
    9a30:	f000 f8ec 	bl	9c0c <am_hal_interrupt_master_set>

} // am_hal_ctimer_config()
    9a34:	b003      	add	sp, #12
    9a36:	bd30      	pop	{r4, r5, pc}
        AM_BFW(PWRCTRL, MISCOPT, DIS_LDOLPMODE_TIMERS, 0);
    9a38:	4809      	ldr	r0, [pc, #36]	; (9a60 <am_hal_ctimer_config+0xe0>)
    9a3a:	6805      	ldr	r5, [r0, #0]
    9a3c:	f025 0104 	bic.w	r1, r5, #4
    9a40:	6001      	str	r1, [r0, #0]
    AM_CRITICAL_END_ASM
    9a42:	9801      	ldr	r0, [sp, #4]
    9a44:	f000 f8e2 	bl	9c0c <am_hal_interrupt_master_set>
} // am_hal_ctimer_config()
    9a48:	b003      	add	sp, #12
    9a4a:	bd30      	pop	{r4, r5, pc}
    9a4c:	4000800c 	.word	0x4000800c
    9a50:	40008100 	.word	0x40008100
    9a54:	4000801c 	.word	0x4000801c
    9a58:	4000802c 	.word	0x4000802c
    9a5c:	4000803c 	.word	0x4000803c
    9a60:	40021020 	.word	0x40021020

00009a64 <am_hal_ctimer_start>:
//! @return None.
//
//*****************************************************************************
void
am_hal_ctimer_start(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment)
{
    9a64:	b570      	push	{r4, r5, r6, lr}
    9a66:	b082      	sub	sp, #8
    9a68:	460c      	mov	r4, r1

    //
    // Find the correct control register.
    //
    pui32ConfigReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
                                  (ui32TimerNumber * TIMER_OFFSET));
    9a6a:	0106      	lsls	r6, r0, #4

    //
    // Begin critical section while config registers are read and modified.
    //
    AM_CRITICAL_BEGIN_ASM
    9a6c:	f000 f8ca 	bl	9c04 <am_hal_interrupt_master_disable>
    pui32ConfigReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
    9a70:	4d07      	ldr	r5, [pc, #28]	; (9a90 <am_hal_ctimer_start+0x2c>)
    AM_CRITICAL_BEGIN_ASM
    9a72:	9001      	str	r0, [sp, #4]

    //
    // Read the current value.
    //
    ui32ConfigVal = *pui32ConfigReg;
    9a74:	5971      	ldr	r1, [r6, r5]

    //
    // Clear out the "clear" bit.
    //
    ui32ConfigVal &= ~(ui32TimerSegment & (AM_REG_CTIMER_CTRL0_TMRA0CLR_M |
    9a76:	f004 2308 	and.w	r3, r4, #134219776	; 0x8000800
    9a7a:	ea21 0003 	bic.w	r0, r1, r3
                                           AM_REG_CTIMER_CTRL0_TMRB0CLR_M));

    //
    // Set the "enable bit"
    //
    ui32ConfigVal |= (ui32TimerSegment & (AM_REG_CTIMER_CTRL0_TMRA0EN_M |
    9a7e:	f004 1201 	and.w	r2, r4, #65537	; 0x10001
    9a82:	4302      	orrs	r2, r0
                                          AM_REG_CTIMER_CTRL0_TMRB0EN_M));

    //
    // Write the value back to the register.
    //
    AM_REGVAL(pui32ConfigReg) = ui32ConfigVal;
    9a84:	5172      	str	r2, [r6, r5]

    //
    // Done with critical section.
    //
    AM_CRITICAL_END_ASM
    9a86:	9801      	ldr	r0, [sp, #4]
    9a88:	f000 f8c0 	bl	9c0c <am_hal_interrupt_master_set>
} // am_hal_ctimer_start()
    9a8c:	b002      	add	sp, #8
    9a8e:	bd70      	pop	{r4, r5, r6, pc}
    9a90:	4000800c 	.word	0x4000800c

00009a94 <am_hal_ctimer_clear>:
//! @return None.
//
//*****************************************************************************
void
am_hal_ctimer_clear(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment)
{
    9a94:	b570      	push	{r4, r5, r6, lr}
    9a96:	b082      	sub	sp, #8
    9a98:	460c      	mov	r4, r1

    //
    // Find the correct control register.
    //
    pui32ConfigReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
                                  (ui32TimerNumber * TIMER_OFFSET));
    9a9a:	0106      	lsls	r6, r0, #4

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    9a9c:	f000 f8b2 	bl	9c04 <am_hal_interrupt_master_disable>
    pui32ConfigReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
    9aa0:	4d05      	ldr	r5, [pc, #20]	; (9ab8 <am_hal_ctimer_clear+0x24>)
    AM_CRITICAL_BEGIN_ASM
    9aa2:	9001      	str	r0, [sp, #4]

    //
    // Set the "clear" bit
    //
    AM_REGVAL(pui32ConfigReg) |= (ui32TimerSegment &
    9aa4:	5971      	ldr	r1, [r6, r5]
    9aa6:	f004 2008 	and.w	r0, r4, #134219776	; 0x8000800
    9aaa:	4308      	orrs	r0, r1
    9aac:	5170      	str	r0, [r6, r5]
                                   AM_REG_CTIMER_CTRL0_TMRB0CLR_M));

    //
    // Done with critical section.
    //
    AM_CRITICAL_END_ASM
    9aae:	9801      	ldr	r0, [sp, #4]
    9ab0:	f000 f8ac 	bl	9c0c <am_hal_interrupt_master_set>
} // am_hal_ctimer_clear()
    9ab4:	b002      	add	sp, #8
    9ab6:	bd70      	pop	{r4, r5, r6, pc}
    9ab8:	4000800c 	.word	0x4000800c

00009abc <am_hal_ctimer_period_set>:
//
//*****************************************************************************
void
am_hal_ctimer_period_set(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment,
                         uint32_t ui32Period, uint32_t ui32OnTime)
{
    9abc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    9ac0:	b082      	sub	sp, #8
    9ac2:	4688      	mov	r8, r1
    9ac4:	461f      	mov	r7, r3
    //
    // Find the correct control register to pull the function select field
    // from.
    //
    pui32ControlReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
                                   (ui32TimerNumber * TIMER_OFFSET));
    9ac6:	ea4f 1900 	mov.w	r9, r0, lsl #4
{
    9aca:	4614      	mov	r4, r2
                                    (ui32TimerNumber * TIMER_OFFSET));

    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    9acc:	f000 f89a 	bl	9c04 <am_hal_interrupt_master_disable>
    pui32ControlReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
    9ad0:	f8df a098 	ldr.w	sl, [pc, #152]	; 9b6c <am_hal_ctimer_period_set+0xb0>
    AM_CRITICAL_BEGIN_ASM
    9ad4:	9001      	str	r0, [sp, #4]
    //
    // Extract the timer mode from the register based on the ui32TimerSegment
    // selected by the user.
    //
    ui32Mode = *pui32ControlReg;
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
    9ad6:	f518 3f80 	cmn.w	r8, #65536	; 0x10000
                                    AM_REG_CTIMER_CMPRA0_O +
    9ada:	4d21      	ldr	r5, [pc, #132]	; (9b60 <am_hal_ctimer_period_set+0xa4>)
                                    AM_REG_CTIMER_CMPRB0_O +
    9adc:	4e21      	ldr	r6, [pc, #132]	; (9b64 <am_hal_ctimer_period_set+0xa8>)
    ui32Mode = *pui32ControlReg;
    9ade:	f859 300a 	ldr.w	r3, [r9, sl]
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
    9ae2:	d01b      	beq.n	9b1c <am_hal_ctimer_period_set+0x60>

    //
    // If the mode is a PWM mode, we'll need to calculate the correct CMPR0 and
    // CMPR1 values here.
    //
    if (ui32Mode == AM_HAL_CTIMER_FN_PWM_ONCE   ||
    9ae4:	f403 70c0 	and.w	r0, r3, #384	; 0x180
    9ae8:	2880      	cmp	r0, #128	; 0x80
    9aea:	d01c      	beq.n	9b26 <am_hal_ctimer_period_set+0x6a>

    //
    // Based on the timer segment argument, write the calculated Compare 0 and
    // Compare 1 values to the correct halves of the correct registers.
    //
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERA )
    9aec:	f64f 77ff 	movw	r7, #65535	; 0xffff
    9af0:	2300      	movs	r3, #0
    9af2:	45b8      	cmp	r8, r7
        ui32Comp1 = 0;
    9af4:	461a      	mov	r2, r3
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERA )
    9af6:	d01d      	beq.n	9b34 <am_hal_ctimer_period_set+0x78>
        // For timer A, write the values to the TIMERA compare register.
        //
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
                             AM_REG_CTIMER_CMPRA0_CMPR1A0(ui32Comp1));
    }
    else if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
    9af8:	491b      	ldr	r1, [pc, #108]	; (9b68 <am_hal_ctimer_period_set+0xac>)
    9afa:	4588      	cmp	r8, r1
    9afc:	d025      	beq.n	9b4a <am_hal_ctimer_period_set+0x8e>
        //
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
                             AM_REG_CTIMER_CMPRA0_CMPR1A0(ui32Comp1));

        *pui32CompareRegB = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0 >> 16) |
                             AM_REG_CTIMER_CMPRA0_CMPR1A0(ui32Comp1 >> 16));
    9afe:	400a      	ands	r2, r1
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
    9b00:	b2a0      	uxth	r0, r4
    9b02:	4303      	orrs	r3, r0
        *pui32CompareRegB = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0 >> 16) |
    9b04:	ea42 4414 	orr.w	r4, r2, r4, lsr #16
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
    9b08:	f849 3005 	str.w	r3, [r9, r5]
        *pui32CompareRegB = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0 >> 16) |
    9b0c:	f849 4006 	str.w	r4, [r9, r6]
    }

    //
    // Done with critical section.
    //
    AM_CRITICAL_END_ASM
    9b10:	9801      	ldr	r0, [sp, #4]
    9b12:	f000 f87b 	bl	9c0c <am_hal_interrupt_master_set>
} // am_hal_ctimer_period_set()
    9b16:	b002      	add	sp, #8
    9b18:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        ui32Mode = ui32Mode >> 16;
    9b1c:	0c19      	lsrs	r1, r3, #16
    if (ui32Mode == AM_HAL_CTIMER_FN_PWM_ONCE   ||
    9b1e:	f401 70c0 	and.w	r0, r1, #384	; 0x180
    9b22:	2880      	cmp	r0, #128	; 0x80
    9b24:	d110      	bne.n	9b48 <am_hal_ctimer_period_set+0x8c>
    9b26:	0423      	lsls	r3, r4, #16
        ui32Comp1 = ui32Period;
    9b28:	4622      	mov	r2, r4
        ui32Comp0 = ui32Period - ui32OnTime;
    9b2a:	1be4      	subs	r4, r4, r7
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERA )
    9b2c:	f64f 77ff 	movw	r7, #65535	; 0xffff
    9b30:	45b8      	cmp	r8, r7
    9b32:	d1e1      	bne.n	9af8 <am_hal_ctimer_period_set+0x3c>
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
    9b34:	b2a6      	uxth	r6, r4
    9b36:	4333      	orrs	r3, r6
    9b38:	f849 3005 	str.w	r3, [r9, r5]
    AM_CRITICAL_END_ASM
    9b3c:	9801      	ldr	r0, [sp, #4]
    9b3e:	f000 f865 	bl	9c0c <am_hal_interrupt_master_set>
} // am_hal_ctimer_period_set()
    9b42:	b002      	add	sp, #8
    9b44:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (ui32Mode == AM_HAL_CTIMER_FN_PWM_ONCE   ||
    9b48:	2300      	movs	r3, #0
        *pui32CompareRegB = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
    9b4a:	b2a5      	uxth	r5, r4
    9b4c:	432b      	orrs	r3, r5
    9b4e:	f849 3006 	str.w	r3, [r9, r6]
    AM_CRITICAL_END_ASM
    9b52:	9801      	ldr	r0, [sp, #4]
    9b54:	f000 f85a 	bl	9c0c <am_hal_interrupt_master_set>
} // am_hal_ctimer_period_set()
    9b58:	b002      	add	sp, #8
    9b5a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    9b5e:	bf00      	nop
    9b60:	40008004 	.word	0x40008004
    9b64:	40008008 	.word	0x40008008
    9b68:	ffff0000 	.word	0xffff0000
    9b6c:	4000800c 	.word	0x4000800c

00009b70 <am_hal_ctimer_int_enable>:
//! @return None.
//
//*****************************************************************************
void
am_hal_ctimer_int_enable(uint32_t ui32Interrupt)
{
    9b70:	b510      	push	{r4, lr}
    9b72:	b082      	sub	sp, #8
    9b74:	4604      	mov	r4, r0
    //
    // Begin critical section.
    //
    AM_CRITICAL_BEGIN_ASM
    9b76:	f000 f845 	bl	9c04 <am_hal_interrupt_master_disable>

    //
    // Enable the interrupt at the module level.
    //
    AM_REGn(CTIMER, 0, INTEN) |= ui32Interrupt;
    9b7a:	4b05      	ldr	r3, [pc, #20]	; (9b90 <am_hal_ctimer_int_enable+0x20>)
    AM_CRITICAL_BEGIN_ASM
    9b7c:	9001      	str	r0, [sp, #4]
    AM_REGn(CTIMER, 0, INTEN) |= ui32Interrupt;
    9b7e:	6818      	ldr	r0, [r3, #0]
    9b80:	4320      	orrs	r0, r4
    9b82:	6018      	str	r0, [r3, #0]

    //
    // Done with critical section.
    //
    AM_CRITICAL_END_ASM
    9b84:	9801      	ldr	r0, [sp, #4]
    9b86:	f000 f841 	bl	9c0c <am_hal_interrupt_master_set>
} // am_hal_ctimer_int_enable()
    9b8a:	b002      	add	sp, #8
    9b8c:	bd10      	pop	{r4, pc}
    9b8e:	bf00      	nop
    9b90:	40008200 	.word	0x40008200

00009b94 <am_hal_ctimer_int_clear>:
am_hal_ctimer_int_clear(uint32_t ui32Interrupt)
{
    //
    // Disable the interrupt at the module level.
    //
    AM_REGn(CTIMER, 0, INTCLR) = ui32Interrupt;
    9b94:	4b01      	ldr	r3, [pc, #4]	; (9b9c <am_hal_ctimer_int_clear+0x8>)
    9b96:	6018      	str	r0, [r3, #0]
    9b98:	4770      	bx	lr
    9b9a:	bf00      	nop
    9b9c:	40008208 	.word	0x40008208

00009ba0 <am_hal_debug_error>:
__weak void
#else
void __attribute__((weak))
#endif
am_hal_debug_error(const char *pcFile, uint32_t ui32Line, const char *pcMessage)
{
    9ba0:	e7fe      	b.n	9ba0 <am_hal_debug_error>
    9ba2:	bf00      	nop

00009ba4 <am_hal_flash_delay>:
//
//*****************************************************************************
void
am_hal_flash_delay(uint32_t ui32Iterations)
{
    g_am_hal_flash.delay_cycles(ui32Iterations);
    9ba4:	4b00      	ldr	r3, [pc, #0]	; (9ba8 <am_hal_flash_delay+0x4>)
    9ba6:	4718      	bx	r3
    9ba8:	0800009d 	.word	0x0800009d

00009bac <am_hal_interrupt_enable>:
am_hal_interrupt_enable(uint32_t ui32Interrupt)
{
    //
    // Check to see what type of interrupt this is.
    //
    if ( ui32Interrupt > 15 )
    9bac:	280f      	cmp	r0, #15
    9bae:	d80b      	bhi.n	9bc8 <am_hal_interrupt_enable+0x1c>
    {
        //
        // If this is an ARM internal interrupt number, route it to the
        // appropriate enable register.
        //
        switch(ui32Interrupt)
    9bb0:	2805      	cmp	r0, #5
    9bb2:	d013      	beq.n	9bdc <am_hal_interrupt_enable+0x30>
    9bb4:	2806      	cmp	r0, #6
    9bb6:	d017      	beq.n	9be8 <am_hal_interrupt_enable+0x3c>
    9bb8:	2804      	cmp	r0, #4
    9bba:	d104      	bne.n	9bc6 <am_hal_interrupt_enable+0x1a>
            case AM_HAL_INTERRUPT_USAGEFAULT:
                AM_BFW(SYSCTRL, SHCSR, USAGEFAULTENA, 1);
            break;

            case AM_HAL_INTERRUPT_MPUFAULT:
                AM_BFW(SYSCTRL, SHCSR, MEMFAULTENA, 1);
    9bbc:	4a0d      	ldr	r2, [pc, #52]	; (9bf4 <am_hal_interrupt_enable+0x48>)
    9bbe:	6813      	ldr	r3, [r2, #0]
    9bc0:	f443 3080 	orr.w	r0, r3, #65536	; 0x10000
    9bc4:	6010      	str	r0, [r2, #0]
    9bc6:	4770      	bx	lr
        AM_REG(NVIC, ISER0) = 0x1 << ((ui32Interrupt - 16) & 0x1F);
    9bc8:	f1a0 0310 	sub.w	r3, r0, #16
    9bcc:	f003 0c1f 	and.w	ip, r3, #31
    9bd0:	2001      	movs	r0, #1
    9bd2:	4909      	ldr	r1, [pc, #36]	; (9bf8 <am_hal_interrupt_enable+0x4c>)
    9bd4:	fa00 f20c 	lsl.w	r2, r0, ip
    9bd8:	600a      	str	r2, [r1, #0]
    9bda:	4770      	bx	lr
                AM_BFW(SYSCTRL, SHCSR, BUSFAULTENA, 1);
    9bdc:	4805      	ldr	r0, [pc, #20]	; (9bf4 <am_hal_interrupt_enable+0x48>)
    9bde:	6801      	ldr	r1, [r0, #0]
    9be0:	f441 3200 	orr.w	r2, r1, #131072	; 0x20000
    9be4:	6002      	str	r2, [r0, #0]
            break;
    9be6:	4770      	bx	lr
                AM_BFW(SYSCTRL, SHCSR, USAGEFAULTENA, 1);
    9be8:	4902      	ldr	r1, [pc, #8]	; (9bf4 <am_hal_interrupt_enable+0x48>)
    9bea:	680a      	ldr	r2, [r1, #0]
    9bec:	f442 2380 	orr.w	r3, r2, #262144	; 0x40000
    9bf0:	600b      	str	r3, [r1, #0]
            break;
    9bf2:	4770      	bx	lr
    9bf4:	e000ed24 	.word	0xe000ed24
    9bf8:	e000e100 	.word	0xe000e100

00009bfc <am_hal_interrupt_master_enable>:
}
#elif defined(__GNUC_STDC_INLINE__)
uint32_t __attribute__((naked))
am_hal_interrupt_master_enable(void)
{
    __asm("    mrs     r0, PRIMASK");
    9bfc:	f3ef 8010 	mrs	r0, PRIMASK
    __asm("    cpsie i");
    9c00:	b662      	cpsie	i
    __asm("    bx lr");
    9c02:	4770      	bx	lr

00009c04 <am_hal_interrupt_master_disable>:
}
#elif defined(__GNUC_STDC_INLINE__)
uint32_t __attribute__((naked))
am_hal_interrupt_master_disable(void)
{
    __asm("    mrs     r0, PRIMASK");
    9c04:	f3ef 8010 	mrs	r0, PRIMASK
    __asm("    cpsid i");
    9c08:	b672      	cpsid	i
    __asm("    bx lr");
    9c0a:	4770      	bx	lr

00009c0c <am_hal_interrupt_master_set>:
//*****************************************************************************
#if defined(__GNUC_STDC_INLINE__)
void __attribute__((naked))
am_hal_interrupt_master_set(uint32_t ui32InterruptState)
{
    __asm("    msr     PRIMASK, r0");
    9c0c:	f380 8810 	msr	PRIMASK, r0
    __asm("    bx lr");
    9c10:	4770      	bx	lr
    9c12:	bf00      	nop

00009c14 <am_hal_itm_enable>:
//
//*****************************************************************************
void
am_hal_itm_enable(void)
{
    if (g_ui32HALflags & AM_HAL_FLAGS_ITMSKIPENABLEDISABLE_M)
    9c14:	4b0d      	ldr	r3, [pc, #52]	; (9c4c <am_hal_itm_enable+0x38>)
    9c16:	6818      	ldr	r0, [r3, #0]
    9c18:	07c2      	lsls	r2, r0, #31
    9c1a:	d416      	bmi.n	9c4a <am_hal_itm_enable+0x36>

    //
    // To be able to access ITM registers, set the Trace Enable bit
    // in the Debug Exception and Monitor Control Register (DEMCR).
    //
    AM_REG(SYSCTRL, DEMCR) |= AM_REG_SYSCTRL_DEMCR_TRCENA(1);
    9c1c:	4a0c      	ldr	r2, [pc, #48]	; (9c50 <am_hal_itm_enable+0x3c>)
    9c1e:	6811      	ldr	r1, [r2, #0]
{
    9c20:	b430      	push	{r4, r5}
    AM_REG(SYSCTRL, DEMCR) |= AM_REG_SYSCTRL_DEMCR_TRCENA(1);
    9c22:	f041 7480 	orr.w	r4, r1, #16777216	; 0x1000000
    9c26:	6014      	str	r4, [r2, #0]
    while ( !(AM_REG(SYSCTRL, DEMCR) & AM_REG_SYSCTRL_DEMCR_TRCENA(1)) );
    9c28:	6815      	ldr	r5, [r2, #0]
    9c2a:	01eb      	lsls	r3, r5, #7
    9c2c:	d5fc      	bpl.n	9c28 <am_hal_itm_enable+0x14>

    //
    // Write the key to the ITM Lock Access register to unlock the ITM_TCR.
    //
    AM_REGVAL(AM_REG_ITM_LOCKAREG_O) = AM_REG_ITM_LOCKAREG_KEYVAL;
    9c2e:	4809      	ldr	r0, [pc, #36]	; (9c54 <am_hal_itm_enable+0x40>)

    //
    // Set the enable bits in the ITM trace enable register, and the ITM
    // control registers to enable trace data output.
    //
    AM_REGVAL(AM_REG_ITM_TPR_O) = 0x0000000f;
    9c30:	4c09      	ldr	r4, [pc, #36]	; (9c58 <am_hal_itm_enable+0x44>)
    AM_REGVAL(AM_REG_ITM_LOCKAREG_O) = AM_REG_ITM_LOCKAREG_KEYVAL;
    9c32:	4d0a      	ldr	r5, [pc, #40]	; (9c5c <am_hal_itm_enable+0x48>)
    9c34:	6005      	str	r5, [r0, #0]
    AM_REGVAL(AM_REG_ITM_TPR_O) = 0x0000000f;
    9c36:	250f      	movs	r5, #15
    9c38:	6025      	str	r5, [r4, #0]
        AM_WRITE_SM(AM_REG_ITM_TCR_DWT_ENABLE, 0)     |
        AM_WRITE_SM(AM_REG_ITM_TCR_SYNC_ENABLE, 0)    |
        AM_WRITE_SM(AM_REG_ITM_TCR_TS_ENABLE, 0)      |
        AM_WRITE_SM(AM_REG_ITM_TCR_ITM_ENABLE, 1);

}
    9c3a:	bc30      	pop	{r4, r5}
    AM_REGVAL(AM_REG_ITM_TER_O) = 0xffffffff;
    9c3c:	4908      	ldr	r1, [pc, #32]	; (9c60 <am_hal_itm_enable+0x4c>)
    AM_REGVAL(AM_REG_ITM_TCR_O) =
    9c3e:	4b09      	ldr	r3, [pc, #36]	; (9c64 <am_hal_itm_enable+0x50>)
    9c40:	4a09      	ldr	r2, [pc, #36]	; (9c68 <am_hal_itm_enable+0x54>)
    AM_REGVAL(AM_REG_ITM_TER_O) = 0xffffffff;
    9c42:	f04f 30ff 	mov.w	r0, #4294967295
    9c46:	6008      	str	r0, [r1, #0]
    AM_REGVAL(AM_REG_ITM_TCR_O) =
    9c48:	601a      	str	r2, [r3, #0]
}
    9c4a:	4770      	bx	lr
    9c4c:	1000113c 	.word	0x1000113c
    9c50:	e000edfc 	.word	0xe000edfc
    9c54:	e0000fb0 	.word	0xe0000fb0
    9c58:	e0000e40 	.word	0xe0000e40
    9c5c:	c5acce55 	.word	0xc5acce55
    9c60:	e0000e00 	.word	0xe0000e00
    9c64:	e0000e80 	.word	0xe0000e80
    9c68:	00150511 	.word	0x00150511

00009c6c <am_hal_itm_not_busy>:
am_hal_itm_not_busy(void)
{
    //
    // Make sure the ITM/TPIU is not busy.
    //
    while (AM_REG(ITM, TCR) & AM_REG_ITM_TCR_BUSY(1));
    9c6c:	4a03      	ldr	r2, [pc, #12]	; (9c7c <am_hal_itm_not_busy+0x10>)
    9c6e:	6813      	ldr	r3, [r2, #0]
    9c70:	021b      	lsls	r3, r3, #8
    9c72:	d4fc      	bmi.n	9c6e <am_hal_itm_not_busy+0x2>

    //
    // wait for 50us for the data to flush out
    //
    am_hal_flash_delay(FLASH_CYCLES_US(50));
    9c74:	f44f 7047 	mov.w	r0, #796	; 0x31c
    9c78:	f7ff bf94 	b.w	9ba4 <am_hal_flash_delay>
    9c7c:	e0000e80 	.word	0xe0000e80

00009c80 <am_hal_itm_print>:
    uint32_t ui32Length = 0;

    //
    // Determine the length of the string.
    //
    while (*(pcString + ui32Length))
    9c80:	7803      	ldrb	r3, [r0, #0]
    9c82:	b1b3      	cbz	r3, 9cb2 <am_hal_itm_print+0x32>
{
    9c84:	b410      	push	{r4}
    9c86:	4602      	mov	r2, r0
    while (*(pcString + ui32Length))
    9c88:	2400      	movs	r4, #0
    9c8a:	f812 1f01 	ldrb.w	r1, [r2, #1]!
    {
        ui32Length++;
    9c8e:	3401      	adds	r4, #1
    while (*(pcString + ui32Length))
    9c90:	2900      	cmp	r1, #0
    9c92:	d1fa      	bne.n	9c8a <am_hal_itm_print+0xa>
    9c94:	1901      	adds	r1, r0, r4
    while (!AM_REGVAL(ui32StimAddr));
    9c96:	f04f 4c60 	mov.w	ip, #3758096384	; 0xe0000000
    while (ui32Length)
    {
            //
            // Print string out the ITM.
            //
            am_hal_itm_stimulus_reg_byte_write(0, (uint8_t)*pcString++);
    9c9a:	f810 2b01 	ldrb.w	r2, [r0], #1
    while (!AM_REGVAL(ui32StimAddr));
    9c9e:	f8dc 3000 	ldr.w	r3, [ip]
    9ca2:	2b00      	cmp	r3, #0
    9ca4:	d0fb      	beq.n	9c9e <am_hal_itm_print+0x1e>
    while (ui32Length)
    9ca6:	4288      	cmp	r0, r1
    *((volatile uint8_t *) ui32StimAddr) = ui8Value;
    9ca8:	f88c 2000 	strb.w	r2, [ip]
    while (ui32Length)
    9cac:	d1f5      	bne.n	9c9a <am_hal_itm_print+0x1a>
            //
            // Subtract from length.
            //
            ui32Length--;
    }
}
    9cae:	f85d 4b04 	ldr.w	r4, [sp], #4
    9cb2:	4770      	bx	lr

00009cb4 <am_hal_mcuctrl_fault_status>:
    psFault->bSYS = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_SYS_M);

    //
    // Read the DCODE fault capture address register.
    //
    psFault->ui32DCODE = AM_REG(MCUCTRL, DCODEFAULTADDR);
    9cb4:	490d      	ldr	r1, [pc, #52]	; (9cec <am_hal_mcuctrl_fault_status+0x38>)
    ui32FaultStat = AM_REG(MCUCTRL, FAULTSTATUS);
    9cb6:	4b0e      	ldr	r3, [pc, #56]	; (9cf0 <am_hal_mcuctrl_fault_status+0x3c>)

    //
    // Read the ICODE fault capture address register.
    //
    psFault->ui32ICODE |= AM_REG(MCUCTRL, ICODEFAULTADDR);
    9cb8:	4a0e      	ldr	r2, [pc, #56]	; (9cf4 <am_hal_mcuctrl_fault_status+0x40>)
    ui32FaultStat = AM_REG(MCUCTRL, FAULTSTATUS);
    9cba:	681b      	ldr	r3, [r3, #0]
{
    9cbc:	b470      	push	{r4, r5, r6}
    psFault->ui32DCODE = AM_REG(MCUCTRL, DCODEFAULTADDR);
    9cbe:	680d      	ldr	r5, [r1, #0]
    9cc0:	60c5      	str	r5, [r0, #12]
    psFault->ui32ICODE |= AM_REG(MCUCTRL, ICODEFAULTADDR);
    9cc2:	6815      	ldr	r5, [r2, #0]
    9cc4:	6841      	ldr	r1, [r0, #4]

    //
    // Read the ICODE fault capture address register.
    //
    psFault->ui32SYS |= AM_REG(MCUCTRL, SYSFAULTADDR);
    9cc6:	4c0c      	ldr	r4, [pc, #48]	; (9cf8 <am_hal_mcuctrl_fault_status+0x44>)
    9cc8:	6942      	ldr	r2, [r0, #20]
    psFault->ui32ICODE |= AM_REG(MCUCTRL, ICODEFAULTADDR);
    9cca:	4329      	orrs	r1, r5
    9ccc:	6041      	str	r1, [r0, #4]
    psFault->ui32SYS |= AM_REG(MCUCTRL, SYSFAULTADDR);
    9cce:	6824      	ldr	r4, [r4, #0]
    psFault->bICODE = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_ICODE_M);
    9cd0:	f003 0601 	and.w	r6, r3, #1
    psFault->ui32SYS |= AM_REG(MCUCTRL, SYSFAULTADDR);
    9cd4:	4322      	orrs	r2, r4
    psFault->bICODE = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_ICODE_M);
    9cd6:	7006      	strb	r6, [r0, #0]
    psFault->bDCODE = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_DCODE_M);
    9cd8:	f3c3 0640 	ubfx	r6, r3, #1, #1
    psFault->bSYS = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_SYS_M);
    9cdc:	f3c3 0380 	ubfx	r3, r3, #2, #1
    psFault->bDCODE = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_DCODE_M);
    9ce0:	7206      	strb	r6, [r0, #8]
    psFault->bSYS = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_SYS_M);
    9ce2:	7403      	strb	r3, [r0, #16]
    psFault->ui32SYS |= AM_REG(MCUCTRL, SYSFAULTADDR);
    9ce4:	6142      	str	r2, [r0, #20]
}
    9ce6:	bc70      	pop	{r4, r5, r6}
    9ce8:	4770      	bx	lr
    9cea:	bf00      	nop
    9cec:	400201c4 	.word	0x400201c4
    9cf0:	400201cc 	.word	0x400201cc
    9cf4:	400201c0 	.word	0x400201c0
    9cf8:	400201c8 	.word	0x400201c8

00009cfc <am_hal_pwrctrl_memory_enable>:
{
    uint32_t ui32MemEnMask, ui32MemDisMask;
    uint32_t ui32PwrStatEnMask, ui32PwrStatDisMask;
    int32_t i32TOcnt;

    if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_FLASH512K )
    9cfc:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
{
    9d00:	b430      	push	{r4, r5}
    if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_FLASH512K )
    9d02:	d03a      	beq.n	9d7a <am_hal_pwrctrl_memory_enable+0x7e>
        ui32MemEnMask  = AM_REG_PWRCTRL_MEMEN_FLASH0_EN;
        ui32MemDisMask = AM_REG_PWRCTRL_MEMEN_FLASH1_EN;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM0_M;
        ui32PwrStatDisMask = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM1_M;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_FLASH1M )
    9d04:	f5b0 5fc0 	cmp.w	r0, #6144	; 0x1800
    9d08:	f000 809d 	beq.w	9e46 <am_hal_pwrctrl_memory_enable+0x14a>
        ui32MemDisMask = 0;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM0_M  |
                             AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM1_M;
        ui32PwrStatDisMask = 0;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM8K )
    9d0c:	2801      	cmp	r0, #1
    9d0e:	f000 809d 	beq.w	9e4c <am_hal_pwrctrl_memory_enable+0x150>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM8K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_8K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_8K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM16K )
    9d12:	2803      	cmp	r0, #3
    9d14:	f000 80a6 	beq.w	9e64 <am_hal_pwrctrl_memory_enable+0x168>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM16K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_16K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_16K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM24K )
    9d18:	2807      	cmp	r0, #7
    9d1a:	f000 809c 	beq.w	9e56 <am_hal_pwrctrl_memory_enable+0x15a>
                           AM_REG_PWRCTRL_MEMEN_SRAMEN_GROUP0_SRAM2);
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_24K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_24K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM32K )
    9d1e:	280f      	cmp	r0, #15
    9d20:	f000 80a5 	beq.w	9e6e <am_hal_pwrctrl_memory_enable+0x172>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM32K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_32K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_32K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM64K )
    9d24:	281f      	cmp	r0, #31
    9d26:	f000 80b0 	beq.w	9e8a <am_hal_pwrctrl_memory_enable+0x18e>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM64K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_64K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_64K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM96K )
    9d2a:	283f      	cmp	r0, #63	; 0x3f
    9d2c:	f000 80b4 	beq.w	9e98 <am_hal_pwrctrl_memory_enable+0x19c>
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM96K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_96K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_96K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM128K )
    9d30:	287f      	cmp	r0, #127	; 0x7f
    9d32:	f000 80b8 	beq.w	9ea6 <am_hal_pwrctrl_memory_enable+0x1aa>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM128K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_128K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_128K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM160K )
    9d36:	28ff      	cmp	r0, #255	; 0xff
    9d38:	f000 80a0 	beq.w	9e7c <am_hal_pwrctrl_memory_enable+0x180>
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM160K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_160K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_160K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM192K )
    9d3c:	f240 13ff 	movw	r3, #511	; 0x1ff
    9d40:	4298      	cmp	r0, r3
    9d42:	f000 80b7 	beq.w	9eb4 <am_hal_pwrctrl_memory_enable+0x1b8>
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM192K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_192K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_192K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM224K )
    9d46:	f240 31ff 	movw	r1, #1023	; 0x3ff
    9d4a:	4288      	cmp	r0, r1
    9d4c:	f000 80b8 	beq.w	9ec0 <am_hal_pwrctrl_memory_enable+0x1c4>
                         ~AM_HAL_PWRCTRL_MEMEN_SRAM224K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_224K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_224K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_SRAM256K )
    9d50:	f240 72ff 	movw	r2, #2047	; 0x7ff
    9d54:	4290      	cmp	r0, r2
    9d56:	d00e      	beq.n	9d76 <am_hal_pwrctrl_memory_enable+0x7a>
                         ~AM_REG_PWRCTRL_MEMEN_SRAMEN_SRAM256K;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_256K;
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
                             ~AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_256K;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_CACHE )
    9d58:	f1b0 4f20 	cmp.w	r0, #2684354560	; 0xa0000000
    9d5c:	f000 80b6 	beq.w	9ecc <am_hal_pwrctrl_memory_enable+0x1d0>
        ui32MemDisMask = 0;
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB2_M    |
                             AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB0_M;
        ui32PwrStatDisMask = 0;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_CACHE_DIS )
    9d60:	f06f 4420 	mvn.w	r4, #2684354560	; 0xa0000000
    9d64:	42a0      	cmp	r0, r4
    9d66:	f000 80b4 	beq.w	9ed2 <am_hal_pwrctrl_memory_enable+0x1d6>
                          AM_REG_PWRCTRL_MEMEN_CACHEB2_EN;
        ui32PwrStatEnMask  = 0;
        ui32PwrStatDisMask = AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB2_M    |
                             AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB0_M;
    }
    else if ( ui32MemEn == AM_HAL_PWRCTRL_MEMEN_ALL )
    9d6a:	f104 4580 	add.w	r5, r4, #1073741824	; 0x40000000
    9d6e:	f505 5c00 	add.w	ip, r5, #8192	; 0x2000
    9d72:	4560      	cmp	r0, ip
    9d74:	d132      	bne.n	9ddc <am_hal_pwrctrl_memory_enable+0xe0>
    {
        ui32MemEnMask  = AM_HAL_PWRCTRL_MEMEN_ALL;
        ui32MemDisMask = 0;
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL;
    9d76:	495b      	ldr	r1, [pc, #364]	; (9ee4 <am_hal_pwrctrl_memory_enable+0x1e8>)
    9d78:	e066      	b.n	9e48 <am_hal_pwrctrl_memory_enable+0x14c>
    9d7a:	f46f 5280 	mvn.w	r2, #4096	; 0x1000
        ui32PwrStatDisMask = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM1_M;
    9d7e:	2340      	movs	r3, #64	; 0x40
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM0_M;
    9d80:	2120      	movs	r1, #32
    // for 2 reasons: 1) To only affect the specified type of memory, and 2)
    // To avoid inadvertently disabling any memory currently being depended on.
    //
    if ( ui32MemDisMask != 0 )
    {
        AM_REG(PWRCTRL, MEMEN) &= ~ui32MemDisMask;
    9d82:	4c59      	ldr	r4, [pc, #356]	; (9ee8 <am_hal_pwrctrl_memory_enable+0x1ec>)
    9d84:	6825      	ldr	r5, [r4, #0]
    9d86:	402a      	ands	r2, r5
    9d88:	6022      	str	r2, [r4, #0]
    //
    // Enable the required memory.
    //
    if ( ui32MemEnMask != 0 )
    {
        AM_REG(PWRCTRL, MEMEN) |= ui32MemEnMask;
    9d8a:	4a57      	ldr	r2, [pc, #348]	; (9ee8 <am_hal_pwrctrl_memory_enable+0x1ec>)
    9d8c:	6814      	ldr	r4, [r2, #0]
    9d8e:	4320      	orrs	r0, r4
    9d90:	6010      	str	r0, [r2, #0]
    //
    // Wait for the power to be turned on.
    // Apollo2 note - these loops typically end up taking 1 iteration.
    //
    i32TOcnt = 200;
    if ( ui32PwrStatDisMask )
    9d92:	2b00      	cmp	r3, #0
    9d94:	d029      	beq.n	9dea <am_hal_pwrctrl_memory_enable+0xee>
    {
        while ( --i32TOcnt              &&
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    9d96:	4d55      	ldr	r5, [pc, #340]	; (9eec <am_hal_pwrctrl_memory_enable+0x1f0>)
    9d98:	6828      	ldr	r0, [r5, #0]
        while ( --i32TOcnt              &&
    9d9a:	4218      	tst	r0, r3
    9d9c:	bf18      	it	ne
    9d9e:	20c6      	movne	r0, #198	; 0xc6
    9da0:	d01f      	beq.n	9de2 <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    9da2:	682a      	ldr	r2, [r5, #0]
        while ( --i32TOcnt              &&
    9da4:	421a      	tst	r2, r3
    9da6:	d01c      	beq.n	9de2 <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    9da8:	682c      	ldr	r4, [r5, #0]
        while ( --i32TOcnt              &&
    9daa:	421c      	tst	r4, r3
    9dac:	d019      	beq.n	9de2 <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    9dae:	682a      	ldr	r2, [r5, #0]
        while ( --i32TOcnt              &&
    9db0:	421a      	tst	r2, r3
    9db2:	d016      	beq.n	9de2 <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    9db4:	682c      	ldr	r4, [r5, #0]
        while ( --i32TOcnt              &&
    9db6:	421c      	tst	r4, r3
    9db8:	d013      	beq.n	9de2 <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    9dba:	682a      	ldr	r2, [r5, #0]
        while ( --i32TOcnt              &&
    9dbc:	421a      	tst	r2, r3
    9dbe:	d010      	beq.n	9de2 <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    9dc0:	682c      	ldr	r4, [r5, #0]
        while ( --i32TOcnt              &&
    9dc2:	421c      	tst	r4, r3
    9dc4:	d00d      	beq.n	9de2 <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    9dc6:	682a      	ldr	r2, [r5, #0]
        while ( --i32TOcnt              &&
    9dc8:	421a      	tst	r2, r3
    9dca:	d00a      	beq.n	9de2 <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    9dcc:	682c      	ldr	r4, [r5, #0]
        while ( --i32TOcnt              &&
    9dce:	421c      	tst	r4, r3
    9dd0:	d007      	beq.n	9de2 <am_hal_pwrctrl_memory_enable+0xe6>
                ( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatDisMask ) );
    9dd2:	682a      	ldr	r2, [r5, #0]
        while ( --i32TOcnt              &&
    9dd4:	421a      	tst	r2, r3
    9dd6:	d004      	beq.n	9de2 <am_hal_pwrctrl_memory_enable+0xe6>
    9dd8:	3809      	subs	r0, #9
    9dda:	d1e2      	bne.n	9da2 <am_hal_pwrctrl_memory_enable+0xa6>
        return false;
    9ddc:	2000      	movs	r0, #0
    {
        return false;
    }

    return true;
}
    9dde:	bc30      	pop	{r4, r5}
    9de0:	4770      	bx	lr
    if ( ui32PwrStatEnMask )
    9de2:	b911      	cbnz	r1, 9dea <am_hal_pwrctrl_memory_enable+0xee>
    return true;
    9de4:	2001      	movs	r0, #1
}
    9de6:	bc30      	pop	{r4, r5}
    9de8:	4770      	bx	lr
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    9dea:	4b40      	ldr	r3, [pc, #256]	; (9eec <am_hal_pwrctrl_memory_enable+0x1f0>)
    9dec:	681d      	ldr	r5, [r3, #0]
        while ( --i32TOcnt              &&
    9dee:	ea31 0405 	bics.w	r4, r1, r5
    9df2:	bf18      	it	ne
    9df4:	24c6      	movne	r4, #198	; 0xc6
    9df6:	d0f5      	beq.n	9de4 <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    9df8:	6818      	ldr	r0, [r3, #0]
        while ( --i32TOcnt              &&
    9dfa:	ea31 0000 	bics.w	r0, r1, r0
    9dfe:	d0f1      	beq.n	9de4 <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    9e00:	681a      	ldr	r2, [r3, #0]
        while ( --i32TOcnt              &&
    9e02:	ea31 0002 	bics.w	r0, r1, r2
    9e06:	d0ed      	beq.n	9de4 <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    9e08:	681d      	ldr	r5, [r3, #0]
        while ( --i32TOcnt              &&
    9e0a:	ea31 0005 	bics.w	r0, r1, r5
    9e0e:	d0e9      	beq.n	9de4 <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    9e10:	6818      	ldr	r0, [r3, #0]
        while ( --i32TOcnt              &&
    9e12:	ea31 0000 	bics.w	r0, r1, r0
    9e16:	d0e5      	beq.n	9de4 <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    9e18:	681a      	ldr	r2, [r3, #0]
        while ( --i32TOcnt              &&
    9e1a:	ea31 0002 	bics.w	r0, r1, r2
    9e1e:	d0e1      	beq.n	9de4 <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    9e20:	681d      	ldr	r5, [r3, #0]
        while ( --i32TOcnt              &&
    9e22:	ea31 0005 	bics.w	r0, r1, r5
    9e26:	d0dd      	beq.n	9de4 <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    9e28:	6818      	ldr	r0, [r3, #0]
        while ( --i32TOcnt              &&
    9e2a:	ea31 0000 	bics.w	r0, r1, r0
    9e2e:	d0d9      	beq.n	9de4 <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    9e30:	681a      	ldr	r2, [r3, #0]
        while ( --i32TOcnt              &&
    9e32:	ea31 0002 	bics.w	r0, r1, r2
    9e36:	d0d5      	beq.n	9de4 <am_hal_pwrctrl_memory_enable+0xe8>
            (( AM_REG(PWRCTRL, PWRONSTATUS) & ui32PwrStatEnMask )
    9e38:	681d      	ldr	r5, [r3, #0]
        while ( --i32TOcnt              &&
    9e3a:	ea31 0005 	bics.w	r0, r1, r5
    9e3e:	d0d1      	beq.n	9de4 <am_hal_pwrctrl_memory_enable+0xe8>
    9e40:	3c09      	subs	r4, #9
    9e42:	d1d9      	bne.n	9df8 <am_hal_pwrctrl_memory_enable+0xfc>
    9e44:	e7ca      	b.n	9ddc <am_hal_pwrctrl_memory_enable+0xe0>
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_FLAM0_M  |
    9e46:	2160      	movs	r1, #96	; 0x60
{
    9e48:	2300      	movs	r3, #0
    9e4a:	e79e      	b.n	9d8a <am_hal_pwrctrl_memory_enable+0x8e>
    9e4c:	4a28      	ldr	r2, [pc, #160]	; (9ef0 <am_hal_pwrctrl_memory_enable+0x1f4>)
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    9e4e:	4b29      	ldr	r3, [pc, #164]	; (9ef4 <am_hal_pwrctrl_memory_enable+0x1f8>)
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_8K;
    9e50:	f44f 7180 	mov.w	r1, #256	; 0x100
    9e54:	e795      	b.n	9d82 <am_hal_pwrctrl_memory_enable+0x86>
    9e56:	f46f 62ff 	mvn.w	r2, #2040	; 0x7f8
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    9e5a:	f44f 23ff 	mov.w	r3, #522240	; 0x7f800
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_24K;
    9e5e:	f44f 61e0 	mov.w	r1, #1792	; 0x700
    9e62:	e78e      	b.n	9d82 <am_hal_pwrctrl_memory_enable+0x86>
    9e64:	4a24      	ldr	r2, [pc, #144]	; (9ef8 <am_hal_pwrctrl_memory_enable+0x1fc>)
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    9e66:	4b25      	ldr	r3, [pc, #148]	; (9efc <am_hal_pwrctrl_memory_enable+0x200>)
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_16K;
    9e68:	f44f 7140 	mov.w	r1, #768	; 0x300
    9e6c:	e789      	b.n	9d82 <am_hal_pwrctrl_memory_enable+0x86>
    9e6e:	f46f 62fe 	mvn.w	r2, #2032	; 0x7f0
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    9e72:	f44f 23fe 	mov.w	r3, #520192	; 0x7f000
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_32K;
    9e76:	f44f 6170 	mov.w	r1, #3840	; 0xf00
    9e7a:	e782      	b.n	9d82 <am_hal_pwrctrl_memory_enable+0x86>
    9e7c:	f46f 62e0 	mvn.w	r2, #1792	; 0x700
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    9e80:	f44f 23e0 	mov.w	r3, #458752	; 0x70000
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_160K;
    9e84:	f44f 417f 	mov.w	r1, #65280	; 0xff00
    9e88:	e77b      	b.n	9d82 <am_hal_pwrctrl_memory_enable+0x86>
    9e8a:	f46f 62fc 	mvn.w	r2, #2016	; 0x7e0
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    9e8e:	f44f 23fc 	mov.w	r3, #516096	; 0x7e000
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_64K;
    9e92:	f44f 51f8 	mov.w	r1, #7936	; 0x1f00
    9e96:	e774      	b.n	9d82 <am_hal_pwrctrl_memory_enable+0x86>
    9e98:	f46f 62f8 	mvn.w	r2, #1984	; 0x7c0
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    9e9c:	f44f 23f8 	mov.w	r3, #507904	; 0x7c000
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_96K;
    9ea0:	f44f 517c 	mov.w	r1, #16128	; 0x3f00
    9ea4:	e76d      	b.n	9d82 <am_hal_pwrctrl_memory_enable+0x86>
    9ea6:	f46f 62f0 	mvn.w	r2, #1920	; 0x780
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    9eaa:	f44f 23f0 	mov.w	r3, #491520	; 0x78000
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_128K;
    9eae:	f44f 41fe 	mov.w	r1, #32512	; 0x7f00
    9eb2:	e766      	b.n	9d82 <am_hal_pwrctrl_memory_enable+0x86>
    9eb4:	f46f 62c0 	mvn.w	r2, #1536	; 0x600
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    9eb8:	f44f 23c0 	mov.w	r3, #393216	; 0x60000
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_192K;
    9ebc:	4910      	ldr	r1, [pc, #64]	; (9f00 <am_hal_pwrctrl_memory_enable+0x204>)
    9ebe:	e760      	b.n	9d82 <am_hal_pwrctrl_memory_enable+0x86>
        ui32PwrStatEnMask  = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_224K;
    9ec0:	4910      	ldr	r1, [pc, #64]	; (9f04 <am_hal_pwrctrl_memory_enable+0x208>)
    9ec2:	f46f 6280 	mvn.w	r2, #1024	; 0x400
        ui32PwrStatDisMask = AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_ALL    &
    9ec6:	f44f 2380 	mov.w	r3, #262144	; 0x40000
    9eca:	e75a      	b.n	9d82 <am_hal_pwrctrl_memory_enable+0x86>
        ui32PwrStatEnMask  = AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB2_M    |
    9ecc:	f44f 1120 	mov.w	r1, #2621440	; 0x280000
    9ed0:	e7ba      	b.n	9e48 <am_hal_pwrctrl_memory_enable+0x14c>
        AM_REG(PWRCTRL, MEMEN) &= ~ui32MemDisMask;
    9ed2:	4805      	ldr	r0, [pc, #20]	; (9ee8 <am_hal_pwrctrl_memory_enable+0x1ec>)
    9ed4:	6803      	ldr	r3, [r0, #0]
    9ed6:	f023 4120 	bic.w	r1, r3, #2684354560	; 0xa0000000
    9eda:	6001      	str	r1, [r0, #0]
        ui32PwrStatDisMask = AM_REG_PWRCTRL_PWRONSTATUS_PD_CACHEB2_M    |
    9edc:	f44f 1320 	mov.w	r3, #2621440	; 0x280000
        ui32PwrStatEnMask  = 0;
    9ee0:	2100      	movs	r1, #0
    9ee2:	e758      	b.n	9d96 <am_hal_pwrctrl_memory_enable+0x9a>
    9ee4:	0007ff00 	.word	0x0007ff00
    9ee8:	40021010 	.word	0x40021010
    9eec:	40021014 	.word	0x40021014
    9ef0:	fffff801 	.word	0xfffff801
    9ef4:	0007fe00 	.word	0x0007fe00
    9ef8:	fffff803 	.word	0xfffff803
    9efc:	0007fc00 	.word	0x0007fc00
    9f00:	0001ff00 	.word	0x0001ff00
    9f04:	0003ff00 	.word	0x0003ff00

00009f08 <am_hal_pwrctrl_bucks_init>:
am_hal_pwrctrl_bucks_enable(void)
{
    //
    // Check to see if the bucks are already on. If so, we can just return.
    //
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON)   &&
    9f08:	4b0f      	ldr	r3, [pc, #60]	; (9f48 <am_hal_pwrctrl_bucks_init+0x40>)
    9f0a:	681a      	ldr	r2, [r3, #0]
    9f0c:	0792      	lsls	r2, r2, #30
    9f0e:	d502      	bpl.n	9f16 <am_hal_pwrctrl_bucks_init+0xe>
         AM_BFR(PWRCTRL, POWERSTATUS, MEMBUCKON) )
    9f10:	6818      	ldr	r0, [r3, #0]
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON)   &&
    9f12:	07c3      	lsls	r3, r0, #31
    9f14:	d40e      	bmi.n	9f34 <am_hal_pwrctrl_bucks_init+0x2c>
    }

    //
    // Enable BUCK power up
    //
    AM_BFW(PWRCTRL, SUPPLYSRC, COREBUCKEN, 1);
    9f16:	4b0d      	ldr	r3, [pc, #52]	; (9f4c <am_hal_pwrctrl_bucks_init+0x44>)
    AM_BFW(PWRCTRL, SUPPLYSRC, MEMBUCKEN, 1);

    //
    // Make sure bucks are ready.
    //
    while ( ( AM_REG(PWRCTRL, POWERSTATUS)                      &
    9f18:	4a0b      	ldr	r2, [pc, #44]	; (9f48 <am_hal_pwrctrl_bucks_init+0x40>)
    AM_BFW(PWRCTRL, SUPPLYSRC, COREBUCKEN, 1);
    9f1a:	6819      	ldr	r1, [r3, #0]
    9f1c:	f041 0002 	orr.w	r0, r1, #2
    9f20:	6018      	str	r0, [r3, #0]
    AM_BFW(PWRCTRL, SUPPLYSRC, MEMBUCKEN, 1);
    9f22:	6819      	ldr	r1, [r3, #0]
    9f24:	f041 0001 	orr.w	r0, r1, #1
    9f28:	6018      	str	r0, [r3, #0]
    while ( ( AM_REG(PWRCTRL, POWERSTATUS)                      &
    9f2a:	6813      	ldr	r3, [r2, #0]
    9f2c:	f003 0103 	and.w	r1, r3, #3
    9f30:	2903      	cmp	r1, #3
    9f32:	d1fa      	bne.n	9f2a <am_hal_pwrctrl_bucks_init+0x22>
    while ( ( AM_REG(PWRCTRL, POWERSTATUS) &
    9f34:	4a04      	ldr	r2, [pc, #16]	; (9f48 <am_hal_pwrctrl_bucks_init+0x40>)
    9f36:	6810      	ldr	r0, [r2, #0]
    9f38:	f000 0303 	and.w	r3, r0, #3
    9f3c:	2b03      	cmp	r3, #3
    9f3e:	d1fa      	bne.n	9f36 <am_hal_pwrctrl_bucks_init+0x2e>
    am_hal_flash_delay(200 / 3);
    9f40:	2042      	movs	r0, #66	; 0x42
    9f42:	f7ff be2f 	b.w	9ba4 <am_hal_flash_delay>
    9f46:	bf00      	nop
    9f48:	40021004 	.word	0x40021004
    9f4c:	40021000 	.word	0x40021000

00009f50 <am_hal_pwrctrl_bucks_enable>:
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON)   &&
    9f50:	4b0b      	ldr	r3, [pc, #44]	; (9f80 <am_hal_pwrctrl_bucks_enable+0x30>)
    9f52:	681a      	ldr	r2, [r3, #0]
    9f54:	0792      	lsls	r2, r2, #30
    9f56:	d502      	bpl.n	9f5e <am_hal_pwrctrl_bucks_enable+0xe>
         AM_BFR(PWRCTRL, POWERSTATUS, MEMBUCKON) )
    9f58:	6818      	ldr	r0, [r3, #0]
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON)   &&
    9f5a:	07c3      	lsls	r3, r0, #31
    9f5c:	d40e      	bmi.n	9f7c <am_hal_pwrctrl_bucks_enable+0x2c>
    AM_BFW(PWRCTRL, SUPPLYSRC, COREBUCKEN, 1);
    9f5e:	4b09      	ldr	r3, [pc, #36]	; (9f84 <am_hal_pwrctrl_bucks_enable+0x34>)
    while ( ( AM_REG(PWRCTRL, POWERSTATUS)                      &
    9f60:	4a07      	ldr	r2, [pc, #28]	; (9f80 <am_hal_pwrctrl_bucks_enable+0x30>)
    AM_BFW(PWRCTRL, SUPPLYSRC, COREBUCKEN, 1);
    9f62:	6819      	ldr	r1, [r3, #0]
    9f64:	f041 0002 	orr.w	r0, r1, #2
    9f68:	6018      	str	r0, [r3, #0]
    AM_BFW(PWRCTRL, SUPPLYSRC, MEMBUCKEN, 1);
    9f6a:	6819      	ldr	r1, [r3, #0]
    9f6c:	f041 0001 	orr.w	r0, r1, #1
    9f70:	6018      	str	r0, [r3, #0]
    while ( ( AM_REG(PWRCTRL, POWERSTATUS)                      &
    9f72:	6813      	ldr	r3, [r2, #0]
    9f74:	f003 0103 	and.w	r1, r3, #3
    9f78:	2903      	cmp	r1, #3
    9f7a:	d1fa      	bne.n	9f72 <am_hal_pwrctrl_bucks_enable+0x22>
    9f7c:	4770      	bx	lr
    9f7e:	bf00      	nop
    9f80:	40021004 	.word	0x40021004
    9f84:	40021000 	.word	0x40021000

00009f88 <am_hal_pwrctrl_bucks_disable>:
am_hal_pwrctrl_bucks_disable(void)
{
    //
    // Check to see if the bucks are already off. If so, we can just return.
    //
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON) == 0  &&
    9f88:	4b12      	ldr	r3, [pc, #72]	; (9fd4 <am_hal_pwrctrl_bucks_disable+0x4c>)
    9f8a:	681a      	ldr	r2, [r3, #0]
    9f8c:	0792      	lsls	r2, r2, #30
    9f8e:	d402      	bmi.n	9f96 <am_hal_pwrctrl_bucks_disable+0xe>
         AM_BFR(PWRCTRL, POWERSTATUS, MEMBUCKON) == 0)
    9f90:	6818      	ldr	r0, [r3, #0]
    if ( AM_BFR(PWRCTRL, POWERSTATUS, COREBUCKON) == 0  &&
    9f92:	07c3      	lsls	r3, r0, #31
    9f94:	d51c      	bpl.n	9fd0 <am_hal_pwrctrl_bucks_disable+0x48>
    return AM_BFM(MCUCTRL, CHIPREV, REVMAJ) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B ?
    9f96:	4910      	ldr	r1, [pc, #64]	; (9fd8 <am_hal_pwrctrl_bucks_disable+0x50>)
    9f98:	680b      	ldr	r3, [r1, #0]
    9f9a:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
    }

    //
    // Handle the special case if only the ADC is powered.
    //
    if ( isRev_ADC()  &&
    9f9e:	2a20      	cmp	r2, #32
    9fa0:	d00b      	beq.n	9fba <am_hal_pwrctrl_bucks_disable+0x32>
    else
    {
        //
        // Power them down
        //
        AM_BFW(PWRCTRL, SUPPLYSRC, COREBUCKEN, 0);
    9fa2:	4b0e      	ldr	r3, [pc, #56]	; (9fdc <am_hal_pwrctrl_bucks_disable+0x54>)
    9fa4:	681a      	ldr	r2, [r3, #0]
    9fa6:	f022 0002 	bic.w	r0, r2, #2
    9faa:	6018      	str	r0, [r3, #0]
        AM_BFW(PWRCTRL, SUPPLYSRC, MEMBUCKEN, 0);
    9fac:	6819      	ldr	r1, [r3, #0]
    9fae:	f021 0201 	bic.w	r2, r1, #1
    9fb2:	601a      	str	r2, [r3, #0]
    }

    //
    // Wait until BUCKs are disabled.
    //
    am_hal_flash_delay(AM_HAL_PWRCTRL_BUCKDIS_DELAYCYCLES / 3);
    9fb4:	200a      	movs	r0, #10
    9fb6:	f7ff bdf5 	b.w	9ba4 <am_hal_flash_delay>
         (AM_REG(PWRCTRL, DEVICEEN) == AM_REG_PWRCTRL_DEVICEEN_PWRADC_EN) )
    9fba:	4809      	ldr	r0, [pc, #36]	; (9fe0 <am_hal_pwrctrl_bucks_disable+0x58>)
    9fbc:	6801      	ldr	r1, [r0, #0]
    if ( isRev_ADC()  &&
    9fbe:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
    9fc2:	d1ee      	bne.n	9fa2 <am_hal_pwrctrl_bucks_disable+0x1a>
            AM_REG(PWRCTRL, SUPPLYSRC) &=
    9fc4:	4805      	ldr	r0, [pc, #20]	; (9fdc <am_hal_pwrctrl_bucks_disable+0x54>)
    9fc6:	6803      	ldr	r3, [r0, #0]
    9fc8:	f003 0105 	and.w	r1, r3, #5
    9fcc:	6001      	str	r1, [r0, #0]
    9fce:	e7f1      	b.n	9fb4 <am_hal_pwrctrl_bucks_disable+0x2c>
    9fd0:	4770      	bx	lr
    9fd2:	bf00      	nop
    9fd4:	40021004 	.word	0x40021004
    9fd8:	4002000c 	.word	0x4002000c
    9fdc:	40021000 	.word	0x40021000
    9fe0:	40021008 	.word	0x40021008

00009fe4 <am_hal_pwrctrl_low_power_init>:
am_hal_pwrctrl_low_power_init(void)
{
    //
    // For lowest power, we enable clock gating for all SRAM configuration.
    //
    AM_REG(PWRCTRL, SRAMCTRL) |=
    9fe4:	4905      	ldr	r1, [pc, #20]	; (9ffc <am_hal_pwrctrl_low_power_init+0x18>)
        AM_REG_PWRCTRL_SRAMCTRL_SRAM_LIGHT_SLEEP_DIS;

    //
    // For lowest deep sleep power, make sure we stay in BUCK mode.
    //
    AM_REG(PWRCTRL, SUPPLYSRC) &=
    9fe6:	4a06      	ldr	r2, [pc, #24]	; (a000 <am_hal_pwrctrl_low_power_init+0x1c>)
    AM_REG(PWRCTRL, SRAMCTRL) |=
    9fe8:	680b      	ldr	r3, [r1, #0]
    9fea:	f043 0006 	orr.w	r0, r3, #6
    9fee:	6008      	str	r0, [r1, #0]
    AM_REG(PWRCTRL, SUPPLYSRC) &=
    9ff0:	6811      	ldr	r1, [r2, #0]
    9ff2:	f021 0304 	bic.w	r3, r1, #4
    9ff6:	6013      	str	r3, [r2, #0]
    9ff8:	4770      	bx	lr
    9ffa:	bf00      	nop
    9ffc:	40021018 	.word	0x40021018
    a000:	40021000 	.word	0x40021000

0000a004 <am_hal_rtc_osc_select>:
    // Set XT if flag is set.
    // Otherwise configure for LFRC.
    //
    if (ui32OSC)
    {
        AM_REG(CLKGEN, OCTRL) |= AM_REG_CLKGEN_OCTRL_OSEL_M;
    a004:	4a05      	ldr	r2, [pc, #20]	; (a01c <am_hal_rtc_osc_select+0x18>)
    a006:	6813      	ldr	r3, [r2, #0]
    if (ui32OSC)
    a008:	b918      	cbnz	r0, a012 <am_hal_rtc_osc_select+0xe>
    }
    else
    {
        AM_REG(CLKGEN, OCTRL) &= ~AM_REG_CLKGEN_OCTRL_OSEL_M;
    a00a:	f023 0080 	bic.w	r0, r3, #128	; 0x80
    a00e:	6010      	str	r0, [r2, #0]
    a010:	4770      	bx	lr
        AM_REG(CLKGEN, OCTRL) |= AM_REG_CLKGEN_OCTRL_OSEL_M;
    a012:	f043 0180 	orr.w	r1, r3, #128	; 0x80
    a016:	6011      	str	r1, [r2, #0]
    a018:	4770      	bx	lr
    a01a:	bf00      	nop
    a01c:	4000400c 	.word	0x4000400c

0000a020 <am_hal_rtc_osc_disable>:
am_hal_rtc_osc_disable(void)
{
    //
    // Stop the RTC Oscillator.
    //
    AM_REG(RTC, RTCCTL) |= AM_REG_RTC_RTCCTL_RSTOP(1);
    a020:	4a02      	ldr	r2, [pc, #8]	; (a02c <am_hal_rtc_osc_disable+0xc>)
    a022:	6813      	ldr	r3, [r2, #0]
    a024:	f043 0010 	orr.w	r0, r3, #16
    a028:	6010      	str	r0, [r2, #0]
    a02a:	4770      	bx	lr
    a02c:	40004050 	.word	0x40004050

0000a030 <am_hal_sysctrl_sleep>:
//! @return None.
//
//*****************************************************************************
void
am_hal_sysctrl_sleep(bool bSleepDeep)
{
    a030:	b5f0      	push	{r4, r5, r6, r7, lr}
    a032:	b083      	sub	sp, #12
    a034:	4604      	mov	r4, r0
    volatile uint32_t ui32BuckTimer;

    //
    // Disable interrupts and save the previous interrupt state.
    //
    ui32Critical = am_hal_interrupt_master_disable();
    a036:	f7ff fde5 	bl	9c04 <am_hal_interrupt_master_disable>
    a03a:	4605      	mov	r5, r0

    //
    // If the user selected DEEPSLEEP and the TPIU is off, attempt to enter
    // DEEP SLEEP.
    //
    if ((bSleepDeep == AM_HAL_SYSCTRL_SLEEP_DEEP) &&
    a03c:	b124      	cbz	r4, a048 <am_hal_sysctrl_sleep+0x18>
        (AM_BFM(MCUCTRL, TPIUCTRL, ENABLE) == AM_REG_MCUCTRL_TPIUCTRL_ENABLE_DIS))
    a03e:	4b42      	ldr	r3, [pc, #264]	; (a148 <am_hal_sysctrl_sleep+0x118>)
    a040:	6818      	ldr	r0, [r3, #0]
    if ((bSleepDeep == AM_HAL_SYSCTRL_SLEEP_DEEP) &&
    a042:	f010 0c01 	ands.w	ip, r0, #1
    a046:	d00a      	beq.n	a05e <am_hal_sysctrl_sleep+0x2e>
    else
    {
        //
        // Prepare the core for normal sleep (write 0 to the DEEPSLEEP bit).
        //
        AM_BFW(SYSCTRL, SCR, SLEEPDEEP, 0);
    a048:	4a40      	ldr	r2, [pc, #256]	; (a14c <am_hal_sysctrl_sleep+0x11c>)
    a04a:	6811      	ldr	r1, [r2, #0]
    a04c:	f021 0604 	bic.w	r6, r1, #4
    a050:	6016      	str	r6, [r2, #0]

        //
        // Go to sleep.
        //
        AM_ASM_WFI;
    a052:	bf30      	wfi
    }

    //
    // Restore the interrupt state.
    //
    am_hal_interrupt_master_set(ui32Critical);
    a054:	4628      	mov	r0, r5
    a056:	f7ff fdd9 	bl	9c0c <am_hal_interrupt_master_set>
}
    a05a:	b003      	add	sp, #12
    a05c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        AM_BFW(SYSCTRL, SCR, SLEEPDEEP, 1);
    a05e:	4c3b      	ldr	r4, [pc, #236]	; (a14c <am_hal_sysctrl_sleep+0x11c>)
    g_buckZX_chk = AM_BFM(MCUCTRL, CHIPREV, REVMAJ) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B ?
    a060:	4b3b      	ldr	r3, [pc, #236]	; (a150 <am_hal_sysctrl_sleep+0x120>)
        AM_BFW(SYSCTRL, SCR, SLEEPDEEP, 1);
    a062:	6820      	ldr	r0, [r4, #0]
    g_buckZX_chk |= ( g_ui32BuckTimer - 1 ) <= BUCK_TIMER_MAX ?
    a064:	4e3b      	ldr	r6, [pc, #236]	; (a154 <am_hal_sysctrl_sleep+0x124>)
    ui32SupplySrc = AM_REG(PWRCTRL, DEVICEEN);
    a066:	4f3c      	ldr	r7, [pc, #240]	; (a158 <am_hal_sysctrl_sleep+0x128>)
    ui32SupplySrc = AM_REG(PWRCTRL, SUPPLYSRC);
    a068:	f8df e0fc 	ldr.w	lr, [pc, #252]	; a168 <am_hal_sysctrl_sleep+0x138>
        AM_BFW(SYSCTRL, SCR, SLEEPDEEP, 1);
    a06c:	f040 0204 	orr.w	r2, r0, #4
    a070:	6022      	str	r2, [r4, #0]
    g_buckZX_chk = AM_BFM(MCUCTRL, CHIPREV, REVMAJ) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B ?
    a072:	681c      	ldr	r4, [r3, #0]
    g_buckZX_chk |= ( g_ui32BuckTimer - 1 ) <= BUCK_TIMER_MAX ?
    a074:	6833      	ldr	r3, [r6, #0]
    ui32SupplySrc = AM_REG(PWRCTRL, SUPPLYSRC);
    a076:	f8de 2000 	ldr.w	r2, [lr]
    ui32SupplySrc = AM_REG(PWRCTRL, DEVICEEN);
    a07a:	6839      	ldr	r1, [r7, #0]
    g_buckZX_chk = AM_BFM(MCUCTRL, CHIPREV, REVMAJ) == AM_REG_MCUCTRL_CHIPREV_REVMAJ_B ?
    a07c:	f004 07f0 	and.w	r7, r4, #240	; 0xf0
                   CHKBUCKZX_REV : 0x0;
    a080:	2f20      	cmp	r7, #32
    g_buckZX_chk |= ( g_ui32BuckTimer - 1 ) <= BUCK_TIMER_MAX ?
    a082:	f103 30ff 	add.w	r0, r3, #4294967295
                   CHKBUCKZX_REV : 0x0;
    a086:	bf14      	ite	ne
    a088:	2700      	movne	r7, #0
    a08a:	2702      	moveq	r7, #2
                    CHKBUCKZX_TIMER : 0x0;
    a08c:	2803      	cmp	r0, #3
    a08e:	bf98      	it	ls
    a090:	f04f 0c04 	movls.w	ip, #4
                     CHKBUCKZX_BUCKS : 0x0;
    a094:	f012 0403 	ands.w	r4, r2, #3
    a098:	bf18      	it	ne
    a09a:	2401      	movne	r4, #1
    g_buckZX_chk |= ( ui32SupplySrc &
    a09c:	f240 53ff 	movw	r3, #1535	; 0x5ff
    g_buckZX_chk |= (ui32SupplySrc &
    a0a0:	433c      	orrs	r4, r7
                0x0 : CHKBUCKZX_DEVEN;
    a0a2:	ea11 0703 	ands.w	r7, r1, r3
    g_buckZX_chk |= (ui32SupplySrc &
    a0a6:	ea44 040c 	orr.w	r4, r4, ip
                0x0 : CHKBUCKZX_DEVEN;
    a0aa:	d103      	bne.n	a0b4 <am_hal_sysctrl_sleep+0x84>
    g_buckZX_chk |= ( ui32SupplySrc &
    a0ac:	f044 0408 	orr.w	r4, r4, #8
        if ( bBuckZX_chk )
    a0b0:	2c0f      	cmp	r4, #15
    a0b2:	d00a      	beq.n	a0ca <am_hal_sysctrl_sleep+0x9a>
        AM_ASM_WFI;
    a0b4:	bf30      	wfi
        if ( bBuckZX_chk )
    a0b6:	2c0f      	cmp	r4, #15
    a0b8:	d01a      	beq.n	a0f0 <am_hal_sysctrl_sleep+0xc0>
            g_bBuckRestoreComplete = true;
    a0ba:	4e28      	ldr	r6, [pc, #160]	; (a15c <am_hal_sysctrl_sleep+0x12c>)
    a0bc:	2001      	movs	r0, #1
    a0be:	7030      	strb	r0, [r6, #0]
    am_hal_interrupt_master_set(ui32Critical);
    a0c0:	4628      	mov	r0, r5
    a0c2:	f7ff fda3 	bl	9c0c <am_hal_interrupt_master_set>
}
    a0c6:	b003      	add	sp, #12
    a0c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
            ui32BuckTimer = g_ui32BuckTimer - 1;
    a0ca:	6832      	ldr	r2, [r6, #0]
    a0cc:	1e51      	subs	r1, r2, #1
    a0ce:	9100      	str	r1, [sp, #0]
            am_hal_ctimer_clear(ui32BuckTimer, AM_HAL_CTIMER_BOTH);
    a0d0:	9800      	ldr	r0, [sp, #0]
    a0d2:	f04f 31ff 	mov.w	r1, #4294967295
    a0d6:	f7ff fcdd 	bl	9a94 <am_hal_ctimer_clear>
            am_hal_ctimer_period_set(ui32BuckTimer,
    a0da:	9800      	ldr	r0, [sp, #0]
    a0dc:	463b      	mov	r3, r7
    a0de:	f04f 1201 	mov.w	r2, #65537	; 0x10001
    a0e2:	f04f 31ff 	mov.w	r1, #4294967295
    a0e6:	f7ff fce9 	bl	9abc <am_hal_ctimer_period_set>
            am_hal_pwrctrl_bucks_disable();
    a0ea:	f7ff ff4d 	bl	9f88 <am_hal_pwrctrl_bucks_disable>
    a0ee:	e7e1      	b.n	a0b4 <am_hal_sysctrl_sleep+0x84>
    AM_CRITICAL_BEGIN_ASM
    a0f0:	f7ff fd88 	bl	9c04 <am_hal_interrupt_master_disable>
    ui32SaveCore = AM_BFR(MCUCTRL, BUCK3, COREBUCKZXTRIM);
    a0f4:	4b1a      	ldr	r3, [pc, #104]	; (a160 <am_hal_sysctrl_sleep+0x130>)
    AM_CRITICAL_BEGIN_ASM
    a0f6:	9001      	str	r0, [sp, #4]
    ui32SaveCore = AM_BFR(MCUCTRL, BUCK3, COREBUCKZXTRIM);
    a0f8:	681a      	ldr	r2, [r3, #0]
    ui32SaveMem  = AM_BFR(MCUCTRL, BUCK3, MEMBUCKZXTRIM);
    a0fa:	681a      	ldr	r2, [r3, #0]
            AM_BFW(MCUCTRL, BUCK3, COREBUCKZXTRIM, ui32NewCore);
    a0fc:	681f      	ldr	r7, [r3, #0]
    a0fe:	f027 043c 	bic.w	r4, r7, #60	; 0x3c
    a102:	f044 021c 	orr.w	r2, r4, #28
    a106:	601a      	str	r2, [r3, #0]
            AM_BFW(MCUCTRL, BUCK3, MEMBUCKZXTRIM,  ui32NewMem);
    a108:	6819      	ldr	r1, [r3, #0]
            g_bBuckRestoreComplete = false;
    a10a:	4c14      	ldr	r4, [pc, #80]	; (a15c <am_hal_sysctrl_sleep+0x12c>)
            AM_BFW(MCUCTRL, BUCK3, MEMBUCKZXTRIM,  ui32NewMem);
    a10c:	f421 30f0 	bic.w	r0, r1, #122880	; 0x1e000
    a110:	f440 4760 	orr.w	r7, r0, #57344	; 0xe000
    a114:	601f      	str	r7, [r3, #0]
    AM_CRITICAL_END_ASM
    a116:	9801      	ldr	r0, [sp, #4]
    a118:	f7ff fd78 	bl	9c0c <am_hal_interrupt_master_set>
            am_hal_flash_delay( FLASH_CYCLES_US(2) );
    a11c:	201c      	movs	r0, #28
    a11e:	f7ff fd41 	bl	9ba4 <am_hal_flash_delay>
            am_hal_pwrctrl_bucks_enable();
    a122:	f7ff ff15 	bl	9f50 <am_hal_pwrctrl_bucks_enable>
            ui32BuckTimer = g_ui32BuckTimer - 1;
    a126:	6836      	ldr	r6, [r6, #0]
            g_ui32BuckInputs = 0;
    a128:	490e      	ldr	r1, [pc, #56]	; (a164 <am_hal_sysctrl_sleep+0x134>)
            g_bBuckRestoreComplete = false;
    a12a:	2200      	movs	r2, #0
            ui32BuckTimer = g_ui32BuckTimer - 1;
    a12c:	1e73      	subs	r3, r6, #1
            am_hal_flash_delay( FLASH_CYCLES_US(5) );
    a12e:	204c      	movs	r0, #76	; 0x4c
            ui32BuckTimer = g_ui32BuckTimer - 1;
    a130:	9300      	str	r3, [sp, #0]
            g_bBuckRestoreComplete = false;
    a132:	7022      	strb	r2, [r4, #0]
            g_ui32BuckInputs = 0;
    a134:	600a      	str	r2, [r1, #0]
            am_hal_flash_delay( FLASH_CYCLES_US(5) );
    a136:	f7ff fd35 	bl	9ba4 <am_hal_flash_delay>
            am_hal_ctimer_start(ui32BuckTimer, AM_HAL_CTIMER_BOTH);
    a13a:	9800      	ldr	r0, [sp, #0]
    a13c:	f04f 31ff 	mov.w	r1, #4294967295
    a140:	f7ff fc90 	bl	9a64 <am_hal_ctimer_start>
    a144:	e786      	b.n	a054 <am_hal_sysctrl_sleep+0x24>
    a146:	bf00      	nop
    a148:	40020250 	.word	0x40020250
    a14c:	e000ed10 	.word	0xe000ed10
    a150:	4002000c 	.word	0x4002000c
    a154:	10001148 	.word	0x10001148
    a158:	40021008 	.word	0x40021008
    a15c:	10001140 	.word	0x10001140
    a160:	40020068 	.word	0x40020068
    a164:	10001144 	.word	0x10001144
    a168:	40021000 	.word	0x40021000

0000a16c <am_hal_tpiu_enable>:
//! @return None.
//
//*****************************************************************************
void
am_hal_tpiu_enable(am_hal_tpiu_config_t *psConfig)
{
    a16c:	b538      	push	{r3, r4, r5, lr}
    ui32ITMbitrate = psConfig->ui32SetItmBaud;

    //
    // TPIU formatter & flush control register.
    //
    AM_REG(TPIU, FFCR) = 0;
    a16e:	4a23      	ldr	r2, [pc, #140]	; (a1fc <am_hal_tpiu_enable+0x90>)
    ui32ITMbitrate = psConfig->ui32SetItmBaud;
    a170:	6803      	ldr	r3, [r0, #0]
    AM_REG(TPIU, FFCR) = 0;
    a172:	2100      	movs	r1, #0
    a174:	6011      	str	r1, [r2, #0]

    if ( ui32ITMbitrate )
    a176:	b33b      	cbz	r3, a1c8 <am_hal_tpiu_enable+0x5c>
    {
        //
        // Set the Current Parallel Port Size (note - only 1 bit can be set).
        //
        AM_REG(TPIU, CSPSR) = AM_REG_TPIU_CSPSR_CWIDTH_1BIT;
    a178:	f5a2 7c40 	sub.w	ip, r2, #768	; 0x300
    a17c:	2101      	movs	r1, #1

        //
        // Use some default assumptions to set the ITM frequency.
        //
        if ( (ui32ITMbitrate < AM_HAL_TPIU_BAUD_57600 )  ||
    a17e:	4c20      	ldr	r4, [pc, #128]	; (a200 <am_hal_tpiu_enable+0x94>)
             (ui32ITMbitrate > AM_HAL_TPIU_BAUD_2M ) )
        {
            ui32ITMbitrate = AM_HAL_TPIU_BAUD_DEFAULT;
    a180:	4d20      	ldr	r5, [pc, #128]	; (a204 <am_hal_tpiu_enable+0x98>)
        AM_REG(TPIU, CSPSR) = AM_REG_TPIU_CSPSR_CWIDTH_1BIT;
    a182:	f8cc 1000 	str.w	r1, [ip]
        if ( (ui32ITMbitrate < AM_HAL_TPIU_BAUD_57600 )  ||
    a186:	f5a3 4e61 	sub.w	lr, r3, #57600	; 0xe100
            ui32ITMbitrate = AM_HAL_TPIU_BAUD_DEFAULT;
    a18a:	45a6      	cmp	lr, r4
    a18c:	bf94      	ite	ls
    a18e:	461c      	movls	r4, r3
    a190:	462c      	movhi	r4, r5
        }

        //
        // Get the current HFRC frequency.
        //
        ui32HFRC = am_hal_clkgen_sysclk_get();
    a192:	f7ff fbd1 	bl	9938 <am_hal_clkgen_sysclk_get>

        //
        // Compute the SWO scaler value.
        //
        if ( ui32HFRC != 0xFFFFFFFF )
    a196:	1c43      	adds	r3, r0, #1
    a198:	d02d      	beq.n	a1f6 <am_hal_tpiu_enable+0x8a>
        {
            ui32SWOscaler = ((ui32HFRC / 8) / ui32ITMbitrate) - 1;
    a19a:	08c2      	lsrs	r2, r0, #3
    a19c:	fbb2 f3f4 	udiv	r3, r2, r4
    a1a0:	1e5d      	subs	r5, r3, #1
    a1a2:	b2a8      	uxth	r0, r5
        }

        //
        // Set the scaler value.
        //
        AM_REG(TPIU, ACPR) = AM_REG_TPIU_ACPR_SWOSCALER(ui32SWOscaler);
    a1a4:	4a18      	ldr	r2, [pc, #96]	; (a208 <am_hal_tpiu_enable+0x9c>)

        //
        // Set for UART mode
        //
        AM_REG(TPIU, SPPR) = AM_REG_TPIU_SPPR_TXMODE_UART;
    a1a6:	4c19      	ldr	r4, [pc, #100]	; (a20c <am_hal_tpiu_enable+0xa0>)

        //
        // Enable the TPIU clock source in MCU control.
        // Set TPIU clock for HFRC/8 (6 or 3 MHz) operation.
        //
        AM_REGn(MCUCTRL, 0, TPIUCTRL) =
    a1a8:	4b19      	ldr	r3, [pc, #100]	; (a210 <am_hal_tpiu_enable+0xa4>)
        AM_REG(TPIU, ITCTRL) = AM_REG_TPIU_ITCTRL_MODE_NORMAL;
    a1aa:	491a      	ldr	r1, [pc, #104]	; (a214 <am_hal_tpiu_enable+0xa8>)
        AM_REG(TPIU, ACPR) = AM_REG_TPIU_ACPR_SWOSCALER(ui32SWOscaler);
    a1ac:	6010      	str	r0, [r2, #0]
        AM_REG(TPIU, SPPR) = AM_REG_TPIU_SPPR_TXMODE_UART;
    a1ae:	2502      	movs	r5, #2
        AM_REG(TPIU, ITCTRL) = AM_REG_TPIU_ITCTRL_MODE_NORMAL;
    a1b0:	2000      	movs	r0, #0
        AM_REGn(MCUCTRL, 0, TPIUCTRL) =
    a1b2:	f240 2201 	movw	r2, #513	; 0x201
        AM_REG(TPIU, SPPR) = AM_REG_TPIU_SPPR_TXMODE_UART;
    a1b6:	6025      	str	r5, [r4, #0]
        AM_REG(TPIU, ITCTRL) = AM_REG_TPIU_ITCTRL_MODE_NORMAL;
    a1b8:	6008      	str	r0, [r1, #0]
        AM_REGn(MCUCTRL, 0, TPIUCTRL) =
    a1ba:	601a      	str	r2, [r3, #0]
    }

    //
    // Wait for 50us for the data to flush out.
    //
    am_hal_flash_delay(FLASH_CYCLES_US(50));
    a1bc:	f44f 7047 	mov.w	r0, #796	; 0x31c
}
    a1c0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    am_hal_flash_delay(FLASH_CYCLES_US(50));
    a1c4:	f7ff bcee 	b.w	9ba4 <am_hal_flash_delay>
        AM_REG(TPIU, ACPR) = psConfig->ui32ClockPrescaler;
    a1c8:	4c0f      	ldr	r4, [pc, #60]	; (a208 <am_hal_tpiu_enable+0x9c>)
    a1ca:	6905      	ldr	r5, [r0, #16]
    a1cc:	6025      	str	r5, [r4, #0]
        AM_REG(TPIU, SPPR) = psConfig->ui32PinProtocol;
    a1ce:	6882      	ldr	r2, [r0, #8]
    a1d0:	f8c4 20e0 	str.w	r2, [r4, #224]	; 0xe0
        AM_REG(TPIU, CSPSR) = (1 << (psConfig->ui32ParallelPortSize - 1));
    a1d4:	68c3      	ldr	r3, [r0, #12]
    a1d6:	4c10      	ldr	r4, [pc, #64]	; (a218 <am_hal_tpiu_enable+0xac>)
        AM_REG(MCUCTRL, TPIUCTRL) |= psConfig->ui32TraceClkIn;
    a1d8:	490d      	ldr	r1, [pc, #52]	; (a210 <am_hal_tpiu_enable+0xa4>)
        AM_REG(TPIU, CSPSR) = (1 << (psConfig->ui32ParallelPortSize - 1));
    a1da:	1e5d      	subs	r5, r3, #1
    a1dc:	2201      	movs	r2, #1
    a1de:	40aa      	lsls	r2, r5
    a1e0:	6022      	str	r2, [r4, #0]
        AM_REG(MCUCTRL, TPIUCTRL) |= psConfig->ui32TraceClkIn;
    a1e2:	6840      	ldr	r0, [r0, #4]
    a1e4:	680b      	ldr	r3, [r1, #0]
    a1e6:	4303      	orrs	r3, r0
    a1e8:	600b      	str	r3, [r1, #0]
    am_hal_flash_delay(FLASH_CYCLES_US(50));
    a1ea:	f44f 7047 	mov.w	r0, #796	; 0x31c
}
    a1ee:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    am_hal_flash_delay(FLASH_CYCLES_US(50));
    a1f2:	f7ff bcd7 	b.w	9ba4 <am_hal_flash_delay>
    a1f6:	2005      	movs	r0, #5
    a1f8:	e7d4      	b.n	a1a4 <am_hal_tpiu_enable+0x38>
    a1fa:	bf00      	nop
    a1fc:	e0040304 	.word	0xe0040304
    a200:	001da380 	.word	0x001da380
    a204:	000f4240 	.word	0x000f4240
    a208:	e0040010 	.word	0xe0040010
    a20c:	e00400f0 	.word	0xe00400f0
    a210:	40020250 	.word	0x40020250
    a214:	e0040f00 	.word	0xe0040f00
    a218:	e0040004 	.word	0xe0040004

0000a21c <am_hal_tpiu_disable>:
am_hal_tpiu_disable(void)
{
    //
    // Disable the TPIU clock source in MCU control.
    //
    AM_REG(MCUCTRL, TPIUCTRL) = AM_REG_MCUCTRL_TPIUCTRL_CLKSEL_0MHz |
    a21c:	4b01      	ldr	r3, [pc, #4]	; (a224 <am_hal_tpiu_disable+0x8>)
    a21e:	2200      	movs	r2, #0
    a220:	601a      	str	r2, [r3, #0]
    a222:	4770      	bx	lr
    a224:	40020250 	.word	0x40020250

0000a228 <am_hal_vcomp_disable>:
//
//*****************************************************************************
void
am_hal_vcomp_disable(void)
{
    AM_REG(VCOMP, PWDKEY) = AM_REG_VCOMP_PWDKEY_KEYVAL;
    a228:	4b01      	ldr	r3, [pc, #4]	; (a230 <am_hal_vcomp_disable+0x8>)
    a22a:	2237      	movs	r2, #55	; 0x37
    a22c:	601a      	str	r2, [r3, #0]
    a22e:	4770      	bx	lr
    a230:	4000c008 	.word	0x4000c008
    a234:	616e6942 	.word	0x616e6942
    a238:	43207972 	.word	0x43207972
    a23c:	746e756f 	.word	0x746e756f
    a240:	45207265 	.word	0x45207265
    a244:	706d6178 	.word	0x706d6178
    a248:	000a656c 	.word	0x000a656c
    a24c:	0a0a0a0a 	.word	0x0a0a0a0a
    a250:	0a0a0a0a 	.word	0x0a0a0a0a
    a254:	0a0a0a0a 	.word	0x0a0a0a0a
    a258:	0a0a0a0a 	.word	0x0a0a0a0a
    a25c:	00000a0a 	.word	0x00000a0a

0000a260 <am_hal_cachectrl_defaults>:
    a260:	50000001 00010300 00010101 685f6d61     ...P........am_h
    a270:	635f6c61 65676b6c 79735f6e 6b6c6373     al_clkgen_sysclk
    a280:	6c65735f 28746365 69203a29 6c61766e     _select(): inval
    a290:	63206469 6b636f6c 74657320 676e6974     id clock setting
    a2a0:	0000002e 2e5c2e2e 6d615c2e 6c61685f     ......\..\am_hal
    a2b0:	6b6c635f 2e6e6567 00000063              _clkgen.c...
