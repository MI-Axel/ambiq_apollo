
bc_boot_demo_gcc.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001b6c  00008000  00008000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .stack        00001000  10000000  10000000  00020000  2**2
                  ALLOC
  2 .data         00000034  10001000  00009b6c  00011000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00000110  10001034  00009ba0  00011034  2**2
                  ALLOC
  4 .ARM.attributes 00000037  00000000  00000000  00011034  2**0
                  CONTENTS, READONLY
  5 .debug_info   000058c4  00000000  00000000  0001106b  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001cad  00000000  00000000  0001692f  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 000006c0  00000000  00000000  000185dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_ranges 00000950  00000000  00000000  00018c9c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000367e  00000000  00000000  000195ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000216e  00000000  00000000  0001cc6a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000007c  00000000  00000000  0001edd8  2**0
                  CONTENTS, READONLY
 12 .debug_frame  000010c8  00000000  00000000  0001ee54  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00001a32  00000000  00000000  0001ff1c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00008000 <g_am_pfnVectors>:
    8000:	00 10 00 10 65 87 00 00 cd 87 00 00 d9 87 00 00     ....e...........
    8010:	d9 87 00 00 d9 87 00 00 d9 87 00 00 00 00 00 00     ................
	...
    802c:	d3 87 00 00 d3 87 00 00 00 00 00 00 d3 87 00 00     ................
    803c:	d3 87 00 00 d3 87 00 00 d3 87 00 00 d3 87 00 00     ................
    804c:	d3 87 00 00 d3 87 00 00 d3 87 00 00 d3 87 00 00     ................
    805c:	d3 87 00 00 d3 87 00 00 d3 87 00 00 91 86 00 00     ................
    806c:	d3 87 00 00 d3 87 00 00 d3 87 00 00 d3 87 00 00     ................
    807c:	d3 87 00 00                                         ....

00008080 <__aeabi_d2f>:
    8080:	ea4f 0241 	mov.w	r2, r1, lsl #1
    8084:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
    8088:	bf24      	itt	cs
    808a:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
    808e:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
    8092:	d90d      	bls.n	80b0 <__aeabi_d2f+0x30>
    8094:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    8098:	ea4f 02c0 	mov.w	r2, r0, lsl #3
    809c:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
    80a0:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
    80a4:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
    80a8:	bf08      	it	eq
    80aa:	f020 0001 	biceq.w	r0, r0, #1
    80ae:	4770      	bx	lr
    80b0:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
    80b4:	d121      	bne.n	80fa <__aeabi_d2f+0x7a>
    80b6:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
    80ba:	bfbc      	itt	lt
    80bc:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
    80c0:	4770      	bxlt	lr
    80c2:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    80c6:	ea4f 5252 	mov.w	r2, r2, lsr #21
    80ca:	f1c2 0218 	rsb	r2, r2, #24
    80ce:	f1c2 0c20 	rsb	ip, r2, #32
    80d2:	fa10 f30c 	lsls.w	r3, r0, ip
    80d6:	fa20 f002 	lsr.w	r0, r0, r2
    80da:	bf18      	it	ne
    80dc:	f040 0001 	orrne.w	r0, r0, #1
    80e0:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    80e4:	ea4f 23d3 	mov.w	r3, r3, lsr #11
    80e8:	fa03 fc0c 	lsl.w	ip, r3, ip
    80ec:	ea40 000c 	orr.w	r0, r0, ip
    80f0:	fa23 f302 	lsr.w	r3, r3, r2
    80f4:	ea4f 0343 	mov.w	r3, r3, lsl #1
    80f8:	e7cc      	b.n	8094 <__aeabi_d2f+0x14>
    80fa:	ea7f 5362 	mvns.w	r3, r2, asr #21
    80fe:	d107      	bne.n	8110 <__aeabi_d2f+0x90>
    8100:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
    8104:	bf1e      	ittt	ne
    8106:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
    810a:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
    810e:	4770      	bxne	lr
    8110:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
    8114:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    8118:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    811c:	4770      	bx	lr
    811e:	bf00      	nop

00008120 <am_devices_led_init>:
//! @return None.
//
//*****************************************************************************
void
am_devices_led_init(am_devices_led_t *psLED)
{
    8120:	b490      	push	{r4, r7}
    8122:	b082      	sub	sp, #8
    8124:	af00      	add	r7, sp, #0
    8126:	6078      	str	r0, [r7, #4]
    if ( (psLED == NULL)    ||
    8128:	687b      	ldr	r3, [r7, #4]
    812a:	2b00      	cmp	r3, #0
    812c:	f000 8138 	beq.w	83a0 <am_devices_led_init+0x280>
         (psLED->ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    8130:	687b      	ldr	r3, [r7, #4]
    8132:	681b      	ldr	r3, [r3, #0]
    if ( (psLED == NULL)    ||
    8134:	2b31      	cmp	r3, #49	; 0x31
    8136:	f200 8133 	bhi.w	83a0 <am_devices_led_init+0x280>
    }
#else
    //
    // Handle Direct Drive Versus 3-State (with pull-up or no buffer).
    //
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLED->ui32Polarity )
    813a:	687b      	ldr	r3, [r7, #4]
    813c:	685b      	ldr	r3, [r3, #4]
    813e:	f003 0302 	and.w	r3, r3, #2
    8142:	2b00      	cmp	r3, #0
    8144:	f000 8096 	beq.w	8274 <am_devices_led_init+0x154>
    {
        //
        // Configure the pin as a push-pull GPIO output.
        //
        am_hal_gpio_pin_config(psLED->ui32GPIONumber, AM_HAL_GPIO_OUTPUT);
    8148:	687b      	ldr	r3, [r7, #4]
    814a:	681b      	ldr	r3, [r3, #0]
    814c:	2b00      	cmp	r3, #0
    814e:	db4e      	blt.n	81ee <am_devices_led_init+0xce>
    8150:	4b96      	ldr	r3, [pc, #600]	; (83ac <am_devices_led_init+0x28c>)
    8152:	2273      	movs	r2, #115	; 0x73
    8154:	601a      	str	r2, [r3, #0]
    8156:	687b      	ldr	r3, [r7, #4]
    8158:	681b      	ldr	r3, [r3, #0]
    815a:	085b      	lsrs	r3, r3, #1
    815c:	f003 027c 	and.w	r2, r3, #124	; 0x7c
    8160:	4b93      	ldr	r3, [pc, #588]	; (83b0 <am_devices_led_init+0x290>)
    8162:	4413      	add	r3, r2
    8164:	461c      	mov	r4, r3
    8166:	687b      	ldr	r3, [r7, #4]
    8168:	681b      	ldr	r3, [r3, #0]
    816a:	009b      	lsls	r3, r3, #2
    816c:	f003 031c 	and.w	r3, r3, #28
    8170:	2202      	movs	r2, #2
    8172:	409a      	lsls	r2, r3
    8174:	687b      	ldr	r3, [r7, #4]
    8176:	681b      	ldr	r3, [r3, #0]
    8178:	085b      	lsrs	r3, r3, #1
    817a:	f003 017c 	and.w	r1, r3, #124	; 0x7c
    817e:	4b8c      	ldr	r3, [pc, #560]	; (83b0 <am_devices_led_init+0x290>)
    8180:	440b      	add	r3, r1
    8182:	6819      	ldr	r1, [r3, #0]
    8184:	687b      	ldr	r3, [r7, #4]
    8186:	681b      	ldr	r3, [r3, #0]
    8188:	009b      	lsls	r3, r3, #2
    818a:	f003 031c 	and.w	r3, r3, #28
    818e:	2007      	movs	r0, #7
    8190:	fa00 f303 	lsl.w	r3, r0, r3
    8194:	43db      	mvns	r3, r3
    8196:	400b      	ands	r3, r1
    8198:	4313      	orrs	r3, r2
    819a:	6023      	str	r3, [r4, #0]
    819c:	687b      	ldr	r3, [r7, #4]
    819e:	681b      	ldr	r3, [r3, #0]
    81a0:	f003 03fc 	and.w	r3, r3, #252	; 0xfc
    81a4:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    81a8:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
    81ac:	461c      	mov	r4, r3
    81ae:	687b      	ldr	r3, [r7, #4]
    81b0:	681b      	ldr	r3, [r3, #0]
    81b2:	00db      	lsls	r3, r3, #3
    81b4:	f003 0318 	and.w	r3, r3, #24
    81b8:	2218      	movs	r2, #24
    81ba:	409a      	lsls	r2, r3
    81bc:	687b      	ldr	r3, [r7, #4]
    81be:	681b      	ldr	r3, [r3, #0]
    81c0:	f003 03fc 	and.w	r3, r3, #252	; 0xfc
    81c4:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    81c8:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
    81cc:	6819      	ldr	r1, [r3, #0]
    81ce:	687b      	ldr	r3, [r7, #4]
    81d0:	681b      	ldr	r3, [r3, #0]
    81d2:	00db      	lsls	r3, r3, #3
    81d4:	f003 0318 	and.w	r3, r3, #24
    81d8:	20ff      	movs	r0, #255	; 0xff
    81da:	fa00 f303 	lsl.w	r3, r0, r3
    81de:	43db      	mvns	r3, r3
    81e0:	400b      	ands	r3, r1
    81e2:	4313      	orrs	r3, r2
    81e4:	6023      	str	r3, [r4, #0]
    81e6:	4b71      	ldr	r3, [pc, #452]	; (83ac <am_devices_led_init+0x28c>)
    81e8:	2200      	movs	r2, #0
    81ea:	601a      	str	r2, [r3, #0]
    81ec:	e000      	b.n	81f0 <am_devices_led_init+0xd0>
    81ee:	bf00      	nop

        //
        // Disable the output driver, and set the output value to the LEDs "ON"
        // state.
        //
        am_hal_gpio_out_enable_bit_clear(psLED->ui32GPIONumber);
    81f0:	687b      	ldr	r3, [r7, #4]
    81f2:	681b      	ldr	r3, [r3, #0]
    81f4:	08db      	lsrs	r3, r3, #3
    81f6:	f003 0204 	and.w	r2, r3, #4
    81fa:	4b6e      	ldr	r3, [pc, #440]	; (83b4 <am_devices_led_init+0x294>)
    81fc:	4413      	add	r3, r2
    81fe:	4619      	mov	r1, r3
    8200:	687b      	ldr	r3, [r7, #4]
    8202:	681b      	ldr	r3, [r3, #0]
    8204:	f003 031f 	and.w	r3, r3, #31
    8208:	2201      	movs	r2, #1
    820a:	fa02 f303 	lsl.w	r3, r2, r3
    820e:	600b      	str	r3, [r1, #0]
        am_hal_gpio_out_bit_replace(psLED->ui32GPIONumber,
    8210:	687b      	ldr	r3, [r7, #4]
    8212:	681b      	ldr	r3, [r3, #0]
    8214:	08db      	lsrs	r3, r3, #3
    8216:	f003 0204 	and.w	r2, r3, #4
    821a:	4b67      	ldr	r3, [pc, #412]	; (83b8 <am_devices_led_init+0x298>)
    821c:	4413      	add	r3, r2
    821e:	4618      	mov	r0, r3
    8220:	687b      	ldr	r3, [r7, #4]
    8222:	685b      	ldr	r3, [r3, #4]
    8224:	f003 0301 	and.w	r3, r3, #1
    8228:	2b00      	cmp	r3, #0
    822a:	d010      	beq.n	824e <am_devices_led_init+0x12e>
    822c:	687b      	ldr	r3, [r7, #4]
    822e:	681b      	ldr	r3, [r3, #0]
    8230:	08db      	lsrs	r3, r3, #3
    8232:	f003 0204 	and.w	r2, r3, #4
    8236:	4b60      	ldr	r3, [pc, #384]	; (83b8 <am_devices_led_init+0x298>)
    8238:	4413      	add	r3, r2
    823a:	681a      	ldr	r2, [r3, #0]
    823c:	687b      	ldr	r3, [r7, #4]
    823e:	681b      	ldr	r3, [r3, #0]
    8240:	f003 031f 	and.w	r3, r3, #31
    8244:	2101      	movs	r1, #1
    8246:	fa01 f303 	lsl.w	r3, r1, r3
    824a:	4313      	orrs	r3, r2
    824c:	e010      	b.n	8270 <am_devices_led_init+0x150>
    824e:	687b      	ldr	r3, [r7, #4]
    8250:	681b      	ldr	r3, [r3, #0]
    8252:	08db      	lsrs	r3, r3, #3
    8254:	f003 0204 	and.w	r2, r3, #4
    8258:	4b57      	ldr	r3, [pc, #348]	; (83b8 <am_devices_led_init+0x298>)
    825a:	4413      	add	r3, r2
    825c:	681a      	ldr	r2, [r3, #0]
    825e:	687b      	ldr	r3, [r7, #4]
    8260:	681b      	ldr	r3, [r3, #0]
    8262:	f003 031f 	and.w	r3, r3, #31
    8266:	2101      	movs	r1, #1
    8268:	fa01 f303 	lsl.w	r3, r1, r3
    826c:	43db      	mvns	r3, r3
    826e:	4013      	ands	r3, r2
    8270:	6003      	str	r3, [r0, #0]
    8272:	e096      	b.n	83a2 <am_devices_led_init+0x282>
    else
    {
        //
        // Configure the pin as a tri-state GPIO.
        //
        am_hal_gpio_pin_config(psLED->ui32GPIONumber, AM_HAL_GPIO_3STATE);
    8274:	687b      	ldr	r3, [r7, #4]
    8276:	681b      	ldr	r3, [r3, #0]
    8278:	2b00      	cmp	r3, #0
    827a:	db4e      	blt.n	831a <am_devices_led_init+0x1fa>
    827c:	4b4b      	ldr	r3, [pc, #300]	; (83ac <am_devices_led_init+0x28c>)
    827e:	2273      	movs	r2, #115	; 0x73
    8280:	601a      	str	r2, [r3, #0]
    8282:	687b      	ldr	r3, [r7, #4]
    8284:	681b      	ldr	r3, [r3, #0]
    8286:	085b      	lsrs	r3, r3, #1
    8288:	f003 027c 	and.w	r2, r3, #124	; 0x7c
    828c:	4b48      	ldr	r3, [pc, #288]	; (83b0 <am_devices_led_init+0x290>)
    828e:	4413      	add	r3, r2
    8290:	461c      	mov	r4, r3
    8292:	687b      	ldr	r3, [r7, #4]
    8294:	681b      	ldr	r3, [r3, #0]
    8296:	009b      	lsls	r3, r3, #2
    8298:	f003 031c 	and.w	r3, r3, #28
    829c:	2206      	movs	r2, #6
    829e:	409a      	lsls	r2, r3
    82a0:	687b      	ldr	r3, [r7, #4]
    82a2:	681b      	ldr	r3, [r3, #0]
    82a4:	085b      	lsrs	r3, r3, #1
    82a6:	f003 017c 	and.w	r1, r3, #124	; 0x7c
    82aa:	4b41      	ldr	r3, [pc, #260]	; (83b0 <am_devices_led_init+0x290>)
    82ac:	440b      	add	r3, r1
    82ae:	6819      	ldr	r1, [r3, #0]
    82b0:	687b      	ldr	r3, [r7, #4]
    82b2:	681b      	ldr	r3, [r3, #0]
    82b4:	009b      	lsls	r3, r3, #2
    82b6:	f003 031c 	and.w	r3, r3, #28
    82ba:	2007      	movs	r0, #7
    82bc:	fa00 f303 	lsl.w	r3, r0, r3
    82c0:	43db      	mvns	r3, r3
    82c2:	400b      	ands	r3, r1
    82c4:	4313      	orrs	r3, r2
    82c6:	6023      	str	r3, [r4, #0]
    82c8:	687b      	ldr	r3, [r7, #4]
    82ca:	681b      	ldr	r3, [r3, #0]
    82cc:	f003 03fc 	and.w	r3, r3, #252	; 0xfc
    82d0:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    82d4:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
    82d8:	461c      	mov	r4, r3
    82da:	687b      	ldr	r3, [r7, #4]
    82dc:	681b      	ldr	r3, [r3, #0]
    82de:	00db      	lsls	r3, r3, #3
    82e0:	f003 0318 	and.w	r3, r3, #24
    82e4:	2218      	movs	r2, #24
    82e6:	409a      	lsls	r2, r3
    82e8:	687b      	ldr	r3, [r7, #4]
    82ea:	681b      	ldr	r3, [r3, #0]
    82ec:	f003 03fc 	and.w	r3, r3, #252	; 0xfc
    82f0:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    82f4:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
    82f8:	6819      	ldr	r1, [r3, #0]
    82fa:	687b      	ldr	r3, [r7, #4]
    82fc:	681b      	ldr	r3, [r3, #0]
    82fe:	00db      	lsls	r3, r3, #3
    8300:	f003 0318 	and.w	r3, r3, #24
    8304:	20ff      	movs	r0, #255	; 0xff
    8306:	fa00 f303 	lsl.w	r3, r0, r3
    830a:	43db      	mvns	r3, r3
    830c:	400b      	ands	r3, r1
    830e:	4313      	orrs	r3, r2
    8310:	6023      	str	r3, [r4, #0]
    8312:	4b26      	ldr	r3, [pc, #152]	; (83ac <am_devices_led_init+0x28c>)
    8314:	2200      	movs	r2, #0
    8316:	601a      	str	r2, [r3, #0]
    8318:	e000      	b.n	831c <am_devices_led_init+0x1fc>
    831a:	bf00      	nop

        //
        // Disable the output driver, and set the output value to the LEDs "ON"
        // state.
        //
        am_hal_gpio_out_enable_bit_clear(psLED->ui32GPIONumber);
    831c:	687b      	ldr	r3, [r7, #4]
    831e:	681b      	ldr	r3, [r3, #0]
    8320:	08db      	lsrs	r3, r3, #3
    8322:	f003 0204 	and.w	r2, r3, #4
    8326:	4b23      	ldr	r3, [pc, #140]	; (83b4 <am_devices_led_init+0x294>)
    8328:	4413      	add	r3, r2
    832a:	4619      	mov	r1, r3
    832c:	687b      	ldr	r3, [r7, #4]
    832e:	681b      	ldr	r3, [r3, #0]
    8330:	f003 031f 	and.w	r3, r3, #31
    8334:	2201      	movs	r2, #1
    8336:	fa02 f303 	lsl.w	r3, r2, r3
    833a:	600b      	str	r3, [r1, #0]
        am_hal_gpio_out_bit_replace(psLED->ui32GPIONumber,
    833c:	687b      	ldr	r3, [r7, #4]
    833e:	681b      	ldr	r3, [r3, #0]
    8340:	08db      	lsrs	r3, r3, #3
    8342:	f003 0204 	and.w	r2, r3, #4
    8346:	4b1c      	ldr	r3, [pc, #112]	; (83b8 <am_devices_led_init+0x298>)
    8348:	4413      	add	r3, r2
    834a:	4618      	mov	r0, r3
    834c:	687b      	ldr	r3, [r7, #4]
    834e:	685b      	ldr	r3, [r3, #4]
    8350:	f003 0301 	and.w	r3, r3, #1
    8354:	2b00      	cmp	r3, #0
    8356:	d010      	beq.n	837a <am_devices_led_init+0x25a>
    8358:	687b      	ldr	r3, [r7, #4]
    835a:	681b      	ldr	r3, [r3, #0]
    835c:	08db      	lsrs	r3, r3, #3
    835e:	f003 0204 	and.w	r2, r3, #4
    8362:	4b15      	ldr	r3, [pc, #84]	; (83b8 <am_devices_led_init+0x298>)
    8364:	4413      	add	r3, r2
    8366:	681a      	ldr	r2, [r3, #0]
    8368:	687b      	ldr	r3, [r7, #4]
    836a:	681b      	ldr	r3, [r3, #0]
    836c:	f003 031f 	and.w	r3, r3, #31
    8370:	2101      	movs	r1, #1
    8372:	fa01 f303 	lsl.w	r3, r1, r3
    8376:	4313      	orrs	r3, r2
    8378:	e010      	b.n	839c <am_devices_led_init+0x27c>
    837a:	687b      	ldr	r3, [r7, #4]
    837c:	681b      	ldr	r3, [r3, #0]
    837e:	08db      	lsrs	r3, r3, #3
    8380:	f003 0204 	and.w	r2, r3, #4
    8384:	4b0c      	ldr	r3, [pc, #48]	; (83b8 <am_devices_led_init+0x298>)
    8386:	4413      	add	r3, r2
    8388:	681a      	ldr	r2, [r3, #0]
    838a:	687b      	ldr	r3, [r7, #4]
    838c:	681b      	ldr	r3, [r3, #0]
    838e:	f003 031f 	and.w	r3, r3, #31
    8392:	2101      	movs	r1, #1
    8394:	fa01 f303 	lsl.w	r3, r1, r3
    8398:	43db      	mvns	r3, r3
    839a:	4013      	ands	r3, r2
    839c:	6003      	str	r3, [r0, #0]
    839e:	e000      	b.n	83a2 <am_devices_led_init+0x282>
        return;
    83a0:	bf00      	nop
                                    psLED->ui32Polarity &
                                    AM_DEVICES_LED_POL_POLARITY_M );
    }
#endif
}
    83a2:	3708      	adds	r7, #8
    83a4:	46bd      	mov	sp, r7
    83a6:	bc90      	pop	{r4, r7}
    83a8:	4770      	bx	lr
    83aa:	bf00      	nop
    83ac:	40010060 	.word	0x40010060
    83b0:	40010040 	.word	0x40010040
    83b4:	400100b4 	.word	0x400100b4
    83b8:	40010088 	.word	0x40010088

000083bc <am_devices_led_array_init>:
//! @return None.
//
//*****************************************************************************
void
am_devices_led_array_init(am_devices_led_t *psLEDs, uint32_t ui32NumLEDs)
{
    83bc:	b580      	push	{r7, lr}
    83be:	b084      	sub	sp, #16
    83c0:	af00      	add	r7, sp, #0
    83c2:	6078      	str	r0, [r7, #4]
    83c4:	6039      	str	r1, [r7, #0]
    uint32_t i;

    if ( (psLEDs == NULL)                       ||
    83c6:	687b      	ldr	r3, [r7, #4]
    83c8:	2b00      	cmp	r3, #0
    83ca:	d014      	beq.n	83f6 <am_devices_led_array_init+0x3a>
    83cc:	683b      	ldr	r3, [r7, #0]
    83ce:	2b1f      	cmp	r3, #31
    83d0:	d811      	bhi.n	83f6 <am_devices_led_array_init+0x3a>
    }

    //
    // Loop through the list of LEDs, configuring each one individually.
    //
    for ( i = 0; i < ui32NumLEDs; i++ )
    83d2:	2300      	movs	r3, #0
    83d4:	60fb      	str	r3, [r7, #12]
    83d6:	e009      	b.n	83ec <am_devices_led_array_init+0x30>
    {
        am_devices_led_init(psLEDs + i);
    83d8:	68fb      	ldr	r3, [r7, #12]
    83da:	00db      	lsls	r3, r3, #3
    83dc:	687a      	ldr	r2, [r7, #4]
    83de:	4413      	add	r3, r2
    83e0:	4618      	mov	r0, r3
    83e2:	f7ff fe9d 	bl	8120 <am_devices_led_init>
    for ( i = 0; i < ui32NumLEDs; i++ )
    83e6:	68fb      	ldr	r3, [r7, #12]
    83e8:	3301      	adds	r3, #1
    83ea:	60fb      	str	r3, [r7, #12]
    83ec:	68fa      	ldr	r2, [r7, #12]
    83ee:	683b      	ldr	r3, [r7, #0]
    83f0:	429a      	cmp	r2, r3
    83f2:	d3f1      	bcc.n	83d8 <am_devices_led_array_init+0x1c>
    83f4:	e000      	b.n	83f8 <am_devices_led_array_init+0x3c>
        return;
    83f6:	bf00      	nop
    }
}
    83f8:	3710      	adds	r7, #16
    83fa:	46bd      	mov	sp, r7
    83fc:	bd80      	pop	{r7, pc}
	...

00008400 <am_devices_led_on>:
//! @return None.
//
//*****************************************************************************
void
am_devices_led_on(am_devices_led_t *psLEDs, uint32_t ui32LEDNum)
{
    8400:	b480      	push	{r7}
    8402:	b083      	sub	sp, #12
    8404:	af00      	add	r7, sp, #0
    8406:	6078      	str	r0, [r7, #4]
    8408:	6039      	str	r1, [r7, #0]
    if ( (psLEDs == NULL)                       ||
    840a:	687b      	ldr	r3, [r7, #4]
    840c:	2b00      	cmp	r3, #0
    840e:	d06d      	beq.n	84ec <am_devices_led_on+0xec>
    8410:	683b      	ldr	r3, [r7, #0]
    8412:	2b1e      	cmp	r3, #30
    8414:	d86a      	bhi.n	84ec <am_devices_led_on+0xec>
         (ui32LEDNum >= MAX_LEDS)               ||
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    8416:	683b      	ldr	r3, [r7, #0]
    8418:	00db      	lsls	r3, r3, #3
    841a:	687a      	ldr	r2, [r7, #4]
    841c:	4413      	add	r3, r2
    841e:	681b      	ldr	r3, [r3, #0]
         (ui32LEDNum >= MAX_LEDS)               ||
    8420:	2b31      	cmp	r3, #49	; 0x31
    8422:	d863      	bhi.n	84ec <am_devices_led_on+0xec>
    }
#else // AM_APOLLO3_GPIO
    //
    // Handle Direct Drive Versus 3-State (with pull-up or no buffer).
    //
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    8424:	683b      	ldr	r3, [r7, #0]
    8426:	00db      	lsls	r3, r3, #3
    8428:	687a      	ldr	r2, [r7, #4]
    842a:	4413      	add	r3, r2
    842c:	685b      	ldr	r3, [r3, #4]
    842e:	f003 0302 	and.w	r3, r3, #2
    8432:	2b00      	cmp	r3, #0
    8434:	d043      	beq.n	84be <am_devices_led_on+0xbe>
    {
        //
        // Set the output to the correct state for the LED.
        //
        am_hal_gpio_out_bit_replace(psLEDs[ui32LEDNum].ui32GPIONumber,
    8436:	683b      	ldr	r3, [r7, #0]
    8438:	00db      	lsls	r3, r3, #3
    843a:	687a      	ldr	r2, [r7, #4]
    843c:	4413      	add	r3, r2
    843e:	681b      	ldr	r3, [r3, #0]
    8440:	08db      	lsrs	r3, r3, #3
    8442:	f003 0204 	and.w	r2, r3, #4
    8446:	4b2c      	ldr	r3, [pc, #176]	; (84f8 <am_devices_led_on+0xf8>)
    8448:	4413      	add	r3, r2
    844a:	4618      	mov	r0, r3
    844c:	683b      	ldr	r3, [r7, #0]
    844e:	00db      	lsls	r3, r3, #3
    8450:	687a      	ldr	r2, [r7, #4]
    8452:	4413      	add	r3, r2
    8454:	685b      	ldr	r3, [r3, #4]
    8456:	f003 0301 	and.w	r3, r3, #1
    845a:	2b00      	cmp	r3, #0
    845c:	d016      	beq.n	848c <am_devices_led_on+0x8c>
    845e:	683b      	ldr	r3, [r7, #0]
    8460:	00db      	lsls	r3, r3, #3
    8462:	687a      	ldr	r2, [r7, #4]
    8464:	4413      	add	r3, r2
    8466:	681b      	ldr	r3, [r3, #0]
    8468:	08db      	lsrs	r3, r3, #3
    846a:	f003 0204 	and.w	r2, r3, #4
    846e:	4b22      	ldr	r3, [pc, #136]	; (84f8 <am_devices_led_on+0xf8>)
    8470:	4413      	add	r3, r2
    8472:	681a      	ldr	r2, [r3, #0]
    8474:	683b      	ldr	r3, [r7, #0]
    8476:	00db      	lsls	r3, r3, #3
    8478:	6879      	ldr	r1, [r7, #4]
    847a:	440b      	add	r3, r1
    847c:	681b      	ldr	r3, [r3, #0]
    847e:	f003 031f 	and.w	r3, r3, #31
    8482:	2101      	movs	r1, #1
    8484:	fa01 f303 	lsl.w	r3, r1, r3
    8488:	4313      	orrs	r3, r2
    848a:	e016      	b.n	84ba <am_devices_led_on+0xba>
    848c:	683b      	ldr	r3, [r7, #0]
    848e:	00db      	lsls	r3, r3, #3
    8490:	687a      	ldr	r2, [r7, #4]
    8492:	4413      	add	r3, r2
    8494:	681b      	ldr	r3, [r3, #0]
    8496:	08db      	lsrs	r3, r3, #3
    8498:	f003 0204 	and.w	r2, r3, #4
    849c:	4b16      	ldr	r3, [pc, #88]	; (84f8 <am_devices_led_on+0xf8>)
    849e:	4413      	add	r3, r2
    84a0:	681a      	ldr	r2, [r3, #0]
    84a2:	683b      	ldr	r3, [r7, #0]
    84a4:	00db      	lsls	r3, r3, #3
    84a6:	6879      	ldr	r1, [r7, #4]
    84a8:	440b      	add	r3, r1
    84aa:	681b      	ldr	r3, [r3, #0]
    84ac:	f003 031f 	and.w	r3, r3, #31
    84b0:	2101      	movs	r1, #1
    84b2:	fa01 f303 	lsl.w	r3, r1, r3
    84b6:	43db      	mvns	r3, r3
    84b8:	4013      	ands	r3, r2
    84ba:	6003      	str	r3, [r0, #0]
    84bc:	e017      	b.n	84ee <am_devices_led_on+0xee>
    else
    {
        //
        // Turn on the output driver for the LED.
        //
        am_hal_gpio_out_enable_bit_set(psLEDs[ui32LEDNum].ui32GPIONumber);
    84be:	683b      	ldr	r3, [r7, #0]
    84c0:	00db      	lsls	r3, r3, #3
    84c2:	687a      	ldr	r2, [r7, #4]
    84c4:	4413      	add	r3, r2
    84c6:	681b      	ldr	r3, [r3, #0]
    84c8:	08db      	lsrs	r3, r3, #3
    84ca:	f003 0204 	and.w	r2, r3, #4
    84ce:	4b0b      	ldr	r3, [pc, #44]	; (84fc <am_devices_led_on+0xfc>)
    84d0:	4413      	add	r3, r2
    84d2:	4619      	mov	r1, r3
    84d4:	683b      	ldr	r3, [r7, #0]
    84d6:	00db      	lsls	r3, r3, #3
    84d8:	687a      	ldr	r2, [r7, #4]
    84da:	4413      	add	r3, r2
    84dc:	681b      	ldr	r3, [r3, #0]
    84de:	f003 031f 	and.w	r3, r3, #31
    84e2:	2201      	movs	r2, #1
    84e4:	fa02 f303 	lsl.w	r3, r2, r3
    84e8:	600b      	str	r3, [r1, #0]
    84ea:	e000      	b.n	84ee <am_devices_led_on+0xee>
        return;
    84ec:	bf00      	nop
    }
#endif //AM_APOLLO3_GPIO
}
    84ee:	370c      	adds	r7, #12
    84f0:	46bd      	mov	sp, r7
    84f2:	f85d 7b04 	ldr.w	r7, [sp], #4
    84f6:	4770      	bx	lr
    84f8:	40010088 	.word	0x40010088
    84fc:	400100a8 	.word	0x400100a8

00008500 <am_devices_led_off>:
//! @return None.
//
//*****************************************************************************
void
am_devices_led_off(am_devices_led_t *psLEDs, uint32_t ui32LEDNum)
{
    8500:	b480      	push	{r7}
    8502:	b083      	sub	sp, #12
    8504:	af00      	add	r7, sp, #0
    8506:	6078      	str	r0, [r7, #4]
    8508:	6039      	str	r1, [r7, #0]
    if ( (psLEDs == NULL)                       ||
    850a:	687b      	ldr	r3, [r7, #4]
    850c:	2b00      	cmp	r3, #0
    850e:	d06d      	beq.n	85ec <am_devices_led_off+0xec>
    8510:	683b      	ldr	r3, [r7, #0]
    8512:	2b1e      	cmp	r3, #30
    8514:	d86a      	bhi.n	85ec <am_devices_led_off+0xec>
         (ui32LEDNum >= MAX_LEDS)               ||
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    8516:	683b      	ldr	r3, [r7, #0]
    8518:	00db      	lsls	r3, r3, #3
    851a:	687a      	ldr	r2, [r7, #4]
    851c:	4413      	add	r3, r2
    851e:	681b      	ldr	r3, [r3, #0]
         (ui32LEDNum >= MAX_LEDS)               ||
    8520:	2b31      	cmp	r3, #49	; 0x31
    8522:	d863      	bhi.n	85ec <am_devices_led_off+0xec>
    }
#else
    //
    // Handle Direct Drive Versus 3-State (with pull-up or no buffer).
    //
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    8524:	683b      	ldr	r3, [r7, #0]
    8526:	00db      	lsls	r3, r3, #3
    8528:	687a      	ldr	r2, [r7, #4]
    852a:	4413      	add	r3, r2
    852c:	685b      	ldr	r3, [r3, #4]
    852e:	f003 0302 	and.w	r3, r3, #2
    8532:	2b00      	cmp	r3, #0
    8534:	d043      	beq.n	85be <am_devices_led_off+0xbe>
    {
        //
        // Set the output to the correct state for the LED.
        //
        am_hal_gpio_out_bit_replace(psLEDs[ui32LEDNum].ui32GPIONumber,
    8536:	683b      	ldr	r3, [r7, #0]
    8538:	00db      	lsls	r3, r3, #3
    853a:	687a      	ldr	r2, [r7, #4]
    853c:	4413      	add	r3, r2
    853e:	681b      	ldr	r3, [r3, #0]
    8540:	08db      	lsrs	r3, r3, #3
    8542:	f003 0204 	and.w	r2, r3, #4
    8546:	4b2c      	ldr	r3, [pc, #176]	; (85f8 <am_devices_led_off+0xf8>)
    8548:	4413      	add	r3, r2
    854a:	4618      	mov	r0, r3
    854c:	683b      	ldr	r3, [r7, #0]
    854e:	00db      	lsls	r3, r3, #3
    8550:	687a      	ldr	r2, [r7, #4]
    8552:	4413      	add	r3, r2
    8554:	685b      	ldr	r3, [r3, #4]
    8556:	f003 0301 	and.w	r3, r3, #1
    855a:	2b00      	cmp	r3, #0
    855c:	d116      	bne.n	858c <am_devices_led_off+0x8c>
    855e:	683b      	ldr	r3, [r7, #0]
    8560:	00db      	lsls	r3, r3, #3
    8562:	687a      	ldr	r2, [r7, #4]
    8564:	4413      	add	r3, r2
    8566:	681b      	ldr	r3, [r3, #0]
    8568:	08db      	lsrs	r3, r3, #3
    856a:	f003 0204 	and.w	r2, r3, #4
    856e:	4b22      	ldr	r3, [pc, #136]	; (85f8 <am_devices_led_off+0xf8>)
    8570:	4413      	add	r3, r2
    8572:	681a      	ldr	r2, [r3, #0]
    8574:	683b      	ldr	r3, [r7, #0]
    8576:	00db      	lsls	r3, r3, #3
    8578:	6879      	ldr	r1, [r7, #4]
    857a:	440b      	add	r3, r1
    857c:	681b      	ldr	r3, [r3, #0]
    857e:	f003 031f 	and.w	r3, r3, #31
    8582:	2101      	movs	r1, #1
    8584:	fa01 f303 	lsl.w	r3, r1, r3
    8588:	4313      	orrs	r3, r2
    858a:	e016      	b.n	85ba <am_devices_led_off+0xba>
    858c:	683b      	ldr	r3, [r7, #0]
    858e:	00db      	lsls	r3, r3, #3
    8590:	687a      	ldr	r2, [r7, #4]
    8592:	4413      	add	r3, r2
    8594:	681b      	ldr	r3, [r3, #0]
    8596:	08db      	lsrs	r3, r3, #3
    8598:	f003 0204 	and.w	r2, r3, #4
    859c:	4b16      	ldr	r3, [pc, #88]	; (85f8 <am_devices_led_off+0xf8>)
    859e:	4413      	add	r3, r2
    85a0:	681a      	ldr	r2, [r3, #0]
    85a2:	683b      	ldr	r3, [r7, #0]
    85a4:	00db      	lsls	r3, r3, #3
    85a6:	6879      	ldr	r1, [r7, #4]
    85a8:	440b      	add	r3, r1
    85aa:	681b      	ldr	r3, [r3, #0]
    85ac:	f003 031f 	and.w	r3, r3, #31
    85b0:	2101      	movs	r1, #1
    85b2:	fa01 f303 	lsl.w	r3, r1, r3
    85b6:	43db      	mvns	r3, r3
    85b8:	4013      	ands	r3, r2
    85ba:	6003      	str	r3, [r0, #0]
    85bc:	e017      	b.n	85ee <am_devices_led_off+0xee>
    else
    {
        //
        // Turn off the output driver for the LED.
        //
        am_hal_gpio_out_enable_bit_clear(psLEDs[ui32LEDNum].ui32GPIONumber);
    85be:	683b      	ldr	r3, [r7, #0]
    85c0:	00db      	lsls	r3, r3, #3
    85c2:	687a      	ldr	r2, [r7, #4]
    85c4:	4413      	add	r3, r2
    85c6:	681b      	ldr	r3, [r3, #0]
    85c8:	08db      	lsrs	r3, r3, #3
    85ca:	f003 0204 	and.w	r2, r3, #4
    85ce:	4b0b      	ldr	r3, [pc, #44]	; (85fc <am_devices_led_off+0xfc>)
    85d0:	4413      	add	r3, r2
    85d2:	4619      	mov	r1, r3
    85d4:	683b      	ldr	r3, [r7, #0]
    85d6:	00db      	lsls	r3, r3, #3
    85d8:	687a      	ldr	r2, [r7, #4]
    85da:	4413      	add	r3, r2
    85dc:	681b      	ldr	r3, [r3, #0]
    85de:	f003 031f 	and.w	r3, r3, #31
    85e2:	2201      	movs	r2, #1
    85e4:	fa02 f303 	lsl.w	r3, r2, r3
    85e8:	600b      	str	r3, [r1, #0]
    85ea:	e000      	b.n	85ee <am_devices_led_off+0xee>
        return;
    85ec:	bf00      	nop
    }
#endif
}
    85ee:	370c      	adds	r7, #12
    85f0:	46bd      	mov	sp, r7
    85f2:	f85d 7b04 	ldr.w	r7, [sp], #4
    85f6:	4770      	bx	lr
    85f8:	40010088 	.word	0x40010088
    85fc:	400100b4 	.word	0x400100b4

00008600 <am_devices_led_array_out>:
//
//*****************************************************************************
void
am_devices_led_array_out(am_devices_led_t *psLEDs, uint32_t ui32NumLEDs,
                         uint32_t ui32Value)
{
    8600:	b580      	push	{r7, lr}
    8602:	b086      	sub	sp, #24
    8604:	af00      	add	r7, sp, #0
    8606:	60f8      	str	r0, [r7, #12]
    8608:	60b9      	str	r1, [r7, #8]
    860a:	607a      	str	r2, [r7, #4]
    uint32_t i;

    for ( i = 0; i < ui32NumLEDs; i++ )
    860c:	2300      	movs	r3, #0
    860e:	617b      	str	r3, [r7, #20]
    8610:	e014      	b.n	863c <am_devices_led_array_out+0x3c>
    {
        if ( ui32Value & (1 << i) )
    8612:	2201      	movs	r2, #1
    8614:	697b      	ldr	r3, [r7, #20]
    8616:	fa02 f303 	lsl.w	r3, r2, r3
    861a:	461a      	mov	r2, r3
    861c:	687b      	ldr	r3, [r7, #4]
    861e:	4013      	ands	r3, r2
    8620:	2b00      	cmp	r3, #0
    8622:	d004      	beq.n	862e <am_devices_led_array_out+0x2e>
        {
            am_devices_led_on(psLEDs, i);
    8624:	6979      	ldr	r1, [r7, #20]
    8626:	68f8      	ldr	r0, [r7, #12]
    8628:	f7ff feea 	bl	8400 <am_devices_led_on>
    862c:	e003      	b.n	8636 <am_devices_led_array_out+0x36>
        }
        else
        {
            am_devices_led_off(psLEDs, i);
    862e:	6979      	ldr	r1, [r7, #20]
    8630:	68f8      	ldr	r0, [r7, #12]
    8632:	f7ff ff65 	bl	8500 <am_devices_led_off>
    for ( i = 0; i < ui32NumLEDs; i++ )
    8636:	697b      	ldr	r3, [r7, #20]
    8638:	3301      	adds	r3, #1
    863a:	617b      	str	r3, [r7, #20]
    863c:	697a      	ldr	r2, [r7, #20]
    863e:	68bb      	ldr	r3, [r7, #8]
    8640:	429a      	cmp	r2, r3
    8642:	d3e6      	bcc.n	8612 <am_devices_led_array_out+0x12>
        }
    }
}
    8644:	bf00      	nop
    8646:	3718      	adds	r7, #24
    8648:	46bd      	mov	sp, r7
    864a:	bd80      	pop	{r7, pc}

0000864c <timerA0_init>:
// Function to initialize Timer A0 to interrupt every 1/4 second.
//
//*****************************************************************************
void
timerA0_init(void)
{
    864c:	b580      	push	{r7, lr}
    864e:	b082      	sub	sp, #8
    8650:	af00      	add	r7, sp, #0
    uint32_t ui32Period;

    //
    // Enable the LFRC.
    //
    am_hal_clkgen_osc_start(AM_HAL_CLKGEN_OSC_LFRC);
    8652:	2002      	movs	r0, #2
    8654:	f001 f870 	bl	9738 <am_hal_clkgen_osc_start>

    //
    // Set up timer A0.
    //
    am_hal_ctimer_clear(0, AM_HAL_CTIMER_TIMERA);
    8658:	f64f 71ff 	movw	r1, #65535	; 0xffff
    865c:	2000      	movs	r0, #0
    865e:	f001 f8a7 	bl	97b0 <am_hal_ctimer_clear>
    am_hal_ctimer_config(0, &g_sTimer0);
    8662:	490a      	ldr	r1, [pc, #40]	; (868c <timerA0_init+0x40>)
    8664:	2000      	movs	r0, #0
    8666:	f001 f87b 	bl	9760 <am_hal_ctimer_config>

    //
    // Set up timerA0 to 32Hz from LFRC divided to 1 second period.
    //
    ui32Period = 8;
    866a:	2308      	movs	r3, #8
    866c:	607b      	str	r3, [r7, #4]
    am_hal_ctimer_period_set(0, AM_HAL_CTIMER_TIMERA, ui32Period,
    866e:	687b      	ldr	r3, [r7, #4]
    8670:	085b      	lsrs	r3, r3, #1
    8672:	687a      	ldr	r2, [r7, #4]
    8674:	f64f 71ff 	movw	r1, #65535	; 0xffff
    8678:	2000      	movs	r0, #0
    867a:	f001 f8a3 	bl	97c4 <am_hal_ctimer_period_set>
                             (ui32Period >> 1));

    //
    // Clear the timer Interrupt
    //
    am_hal_ctimer_int_clear(AM_HAL_CTIMER_INT_TIMERA0);
    867e:	2001      	movs	r0, #1
    8680:	f001 f8e6 	bl	9850 <am_hal_ctimer_int_clear>
}
    8684:	bf00      	nop
    8686:	3708      	adds	r7, #8
    8688:	46bd      	mov	sp, r7
    868a:	bd80      	pop	{r7, pc}
    868c:	10001000 	.word	0x10001000

00008690 <am_ctimer_isr>:
// Timer Interrupt Service Routine (ISR)
//
//*****************************************************************************
void
am_ctimer_isr(void)
{
    8690:	b580      	push	{r7, lr}
    8692:	af00      	add	r7, sp, #0
    //
    // Clear TimerA0 Interrupt (write to clear).
    //
    am_hal_ctimer_int_clear(AM_HAL_CTIMER_INT_TIMERA0);
    8694:	2001      	movs	r0, #1
    8696:	f001 f8db 	bl	9850 <am_hal_ctimer_int_clear>

    //
    // Increment count and set limit based on the number of LEDs available.
    //
    if (++g_ui32TimerCount >= (1 << AM_BSP_NUM_LEDS))
    869a:	4b06      	ldr	r3, [pc, #24]	; (86b4 <am_ctimer_isr+0x24>)
    869c:	681b      	ldr	r3, [r3, #0]
    869e:	3301      	adds	r3, #1
    86a0:	4a04      	ldr	r2, [pc, #16]	; (86b4 <am_ctimer_isr+0x24>)
    86a2:	6013      	str	r3, [r2, #0]
    86a4:	2b1f      	cmp	r3, #31
    86a6:	d902      	bls.n	86ae <am_ctimer_isr+0x1e>
    {
        //
        // Reset the global.
        //
        g_ui32TimerCount = 0;
    86a8:	4b02      	ldr	r3, [pc, #8]	; (86b4 <am_ctimer_isr+0x24>)
    86aa:	2200      	movs	r2, #0
    86ac:	601a      	str	r2, [r3, #0]
    }
}
    86ae:	bf00      	nop
    86b0:	bd80      	pop	{r7, pc}
    86b2:	bf00      	nop
    86b4:	10001034 	.word	0x10001034

000086b8 <main>:
// Main function.
//
//*****************************************************************************
int
main(void)
{
    86b8:	b580      	push	{r7, lr}
    86ba:	af00      	add	r7, sp, #0
    //
    // Set the clock frequency.
    //
    am_hal_clkgen_sysclk_select(AM_HAL_CLKGEN_SYSCLK_MAX);
    86bc:	2000      	movs	r0, #0
    86be:	f001 f81f 	bl	9700 <am_hal_clkgen_sysclk_select>
    am_hal_cachectrl_enable(&am_hal_cachectrl_defaults);

    //
    // Configure the board for low power operation.
    //
    am_bsp_low_power_init();
    86c2:	f000 ffb5 	bl	9630 <am_bsp_low_power_init>

    //
    // Initialize the printf interface for ITM/SWO output.
    //
    am_util_stdio_printf_init((am_util_stdio_print_char_t) am_bsp_itm_string_print);
    86c6:	4820      	ldr	r0, [pc, #128]	; (8748 <main+0x90>)
    86c8:	f000 f906 	bl	88d8 <am_util_stdio_printf_init>

    //
    // Initialize the SWO GPIO pin
    //
    am_bsp_pin_enable(ITM_SWO);
    86cc:	4b1f      	ldr	r3, [pc, #124]	; (874c <main+0x94>)
    86ce:	2273      	movs	r2, #115	; 0x73
    86d0:	601a      	str	r2, [r3, #0]
    86d2:	4a1f      	ldr	r2, [pc, #124]	; (8750 <main+0x98>)
    86d4:	4b1e      	ldr	r3, [pc, #120]	; (8750 <main+0x98>)
    86d6:	681b      	ldr	r3, [r3, #0]
    86d8:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    86dc:	6013      	str	r3, [r2, #0]
    86de:	4a1d      	ldr	r2, [pc, #116]	; (8754 <main+0x9c>)
    86e0:	4b1c      	ldr	r3, [pc, #112]	; (8754 <main+0x9c>)
    86e2:	681b      	ldr	r3, [r3, #0]
    86e4:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
    86e8:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    86ec:	6013      	str	r3, [r2, #0]
    86ee:	4b17      	ldr	r3, [pc, #92]	; (874c <main+0x94>)
    86f0:	2200      	movs	r2, #0
    86f2:	601a      	str	r2, [r3, #0]
    am_devices_led_array_init(am_bsp_psLEDs, AM_BSP_NUM_LEDS);
    86f4:	2105      	movs	r1, #5
    86f6:	4818      	ldr	r0, [pc, #96]	; (8758 <main+0xa0>)
    86f8:	f7ff fe60 	bl	83bc <am_devices_led_array_init>

    //
    // Enable the ITM.
    //
    am_hal_itm_enable();
    86fc:	f001 f8de 	bl	98bc <am_hal_itm_enable>

    //
    // Enable debug printf messages using ITM on SWO pin
    //
    am_bsp_debug_printf_enable();
    8700:	f000 ffa8 	bl	9654 <am_bsp_debug_printf_enable>

    //
    // Clear the terminal and print the banner.
    //
    am_util_stdio_terminal_clear();
    8704:	f000 ff8a 	bl	961c <am_util_stdio_terminal_clear>
    am_util_stdio_printf("Binary Counter Example\n");
    8708:	4814      	ldr	r0, [pc, #80]	; (875c <main+0xa4>)
    870a:	f000 ff69 	bl	95e0 <am_util_stdio_printf>

    //
    // TimerA0 init.
    //
    timerA0_init();
    870e:	f7ff ff9d 	bl	864c <timerA0_init>

    //
    // Enable the timer Interrupt.
    //
    am_hal_ctimer_int_enable(AM_HAL_CTIMER_INT_TIMERA0);
    8712:	2001      	movs	r0, #1
    8714:	f001 f894 	bl	9840 <am_hal_ctimer_int_enable>

    //
    // Enable the timer interrupt in the NVIC.
    //
    am_hal_interrupt_enable(AM_HAL_INTERRUPT_CTIMER);
    8718:	201a      	movs	r0, #26
    871a:	f001 f8a3 	bl	9864 <am_hal_interrupt_enable>
    am_hal_interrupt_master_enable();
    871e:	f001 f8c9 	bl	98b4 <am_hal_interrupt_master_enable>

    //
    // Start timer A0
    //
    am_hal_ctimer_start(0, AM_HAL_CTIMER_TIMERA);
    8722:	f64f 71ff 	movw	r1, #65535	; 0xffff
    8726:	2000      	movs	r0, #0
    8728:	f001 f830 	bl	978c <am_hal_ctimer_start>

    //
    // We are done printing. Disable debug printf messages on ITM.
    //
    am_bsp_debug_printf_disable();
    872c:	f000 ffbe 	bl	96ac <am_bsp_debug_printf_disable>
    while (1)
    {
        //
        // Go to Deep Sleep.
        //
        am_hal_sysctrl_sleep(AM_HAL_SYSCTRL_SLEEP_DEEP);
    8730:	2001      	movs	r0, #1
    8732:	f001 f977 	bl	9a24 <am_hal_sysctrl_sleep>

        //
        // Set the LEDs.
        //
        am_devices_led_array_out(am_bsp_psLEDs, AM_BSP_NUM_LEDS,
    8736:	4b0a      	ldr	r3, [pc, #40]	; (8760 <main+0xa8>)
    8738:	681b      	ldr	r3, [r3, #0]
    873a:	461a      	mov	r2, r3
    873c:	2105      	movs	r1, #5
    873e:	4806      	ldr	r0, [pc, #24]	; (8758 <main+0xa0>)
    8740:	f7ff ff5e 	bl	8600 <am_devices_led_array_out>
        am_hal_sysctrl_sleep(AM_HAL_SYSCTRL_SLEEP_DEEP);
    8744:	e7f4      	b.n	8730 <main+0x78>
    8746:	bf00      	nop
    8748:	000096fd 	.word	0x000096fd
    874c:	40010060 	.word	0x40010060
    8750:	40010054 	.word	0x40010054
    8754:	40010028 	.word	0x40010028
    8758:	1000100c 	.word	0x1000100c
    875c:	00009b20 	.word	0x00009b20
    8760:	10001034 	.word	0x10001034

00008764 <am_reset_isr>:
am_reset_isr(void)
{
    //
    // Set the vector table pointer.
    //
    __asm("    ldr    r0, =0xE000ED08\n"
    8764:	4811      	ldr	r0, [pc, #68]	; (87ac <zero_loop+0x12>)
    8766:	4912      	ldr	r1, [pc, #72]	; (87b0 <zero_loop+0x16>)
    8768:	6001      	str	r1, [r0, #0]
          "    str    r1, [r0]");

    //
    // Set the stack pointer.
    //
    __asm("    ldr    sp, [r1]");
    876a:	f8d1 d000 	ldr.w	sp, [r1]
#ifndef NOFPU
    //
    // Enable the FPU.
    //
    __asm("ldr  r0, =0xE000ED88\n"
    876e:	4811      	ldr	r0, [pc, #68]	; (87b4 <zero_loop+0x1a>)
    8770:	6801      	ldr	r1, [r0, #0]
    8772:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    8776:	6001      	str	r1, [r0, #0]
    8778:	f3bf 8f4f 	dsb	sy
    877c:	f3bf 8f6f 	isb	sy
          "isb\n");
#endif
    //
    // Copy the data segment initializers from flash to SRAM.
    //
    __asm("    ldr     r0, =_init_data\n"
    8780:	480d      	ldr	r0, [pc, #52]	; (87b8 <zero_loop+0x1e>)
    8782:	490e      	ldr	r1, [pc, #56]	; (87bc <zero_loop+0x22>)
    8784:	4a0e      	ldr	r2, [pc, #56]	; (87c0 <zero_loop+0x26>)

00008786 <copy_loop>:
    8786:	f850 3b04 	ldr.w	r3, [r0], #4
    878a:	f841 3b04 	str.w	r3, [r1], #4
    878e:	4291      	cmp	r1, r2
    8790:	dbf9      	blt.n	8786 <copy_loop>
          "        cmp     r1, r2\n"
          "        blt     copy_loop\n");
    //
    // Zero fill the bss segment.
    //
    __asm("    ldr     r0, =_sbss\n"
    8792:	480c      	ldr	r0, [pc, #48]	; (87c4 <zero_loop+0x2a>)
    8794:	490c      	ldr	r1, [pc, #48]	; (87c8 <zero_loop+0x2e>)
    8796:	f04f 0200 	mov.w	r2, #0

0000879a <zero_loop>:
    879a:	4288      	cmp	r0, r1
    879c:	bfb8      	it	lt
    879e:	f840 2b04 	strlt.w	r2, [r0], #4
    87a2:	dbfa      	blt.n	879a <zero_loop>
          "        blt     zero_loop");

    //
    // Call the application's entry point.
    //
    main();
    87a4:	f7ff ff88 	bl	86b8 <main>

    //
    // If main returns then execute a break point instruction
    //
    __asm("    bkpt     ");
    87a8:	be00      	bkpt	0x0000
}
    87aa:	bf00      	nop
    87ac:	e000ed08 	.word	0xe000ed08
    87b0:	00008000 	.word	0x00008000
    87b4:	e000ed88 	.word	0xe000ed88
    87b8:	00009b6c 	.word	0x00009b6c
    87bc:	10001000 	.word	0x10001000
    87c0:	10001034 	.word	0x10001034
    87c4:	10001034 	.word	0x10001034
    87c8:	10001144 	.word	0x10001144

000087cc <am_nmi_isr>:
// by a debugger.
//
//*****************************************************************************
void
am_nmi_isr(void)
{
    87cc:	b480      	push	{r7}
    87ce:	af00      	add	r7, sp, #0
    //
    // Go into an infinite loop.
    //
    while(1)
    87d0:	e7fe      	b.n	87d0 <am_nmi_isr+0x4>

000087d2 <am_adc_isr>:
// for examination by a debugger.
//
//*****************************************************************************
void
am_default_isr(void)
{
    87d2:	b480      	push	{r7}
    87d4:	af00      	add	r7, sp, #0
    //
    // Go into an infinite loop.
    //
    while(1)
    87d6:	e7fe      	b.n	87d6 <am_adc_isr+0x4>

000087d8 <am_fault_isr>:
}
#elif defined(__GNUC_STDC_INLINE__)
uint32_t __attribute__((naked))
am_fault_isr(void)
{
    __asm("    push    {r7,lr}");
    87d8:	b580      	push	{r7, lr}
    __asm("    mov     r0, sp");
    87da:	4668      	mov	r0, sp
    __asm("    adds    r0, #(2*4)");
    87dc:	3008      	adds	r0, #8
    __asm("    bl      am_util_faultisr_collect_data");
    87de:	f000 f809 	bl	87f4 <am_util_faultisr_collect_data>
    __asm("    pop     {r0,pc}");
    87e2:	bd01      	pop	{r0, pc}
}
    87e4:	bf00      	nop
    87e6:	4618      	mov	r0, r3

000087e8 <getStackedReg>:

uint32_t __attribute__((naked))
getStackedReg(uint32_t regnum, uint32_t u32SP)
{
    __asm("    lsls    r0, r0, #2");
    87e8:	0080      	lsls	r0, r0, #2
    __asm("    adds    r0, r1");
    87ea:	1840      	adds	r0, r0, r1
    __asm("    ldr     r0, [r0]");
    87ec:	6800      	ldr	r0, [r0, #0]
    __asm("    bx      lr");
    87ee:	4770      	bx	lr
}
    87f0:	bf00      	nop
    87f2:	4618      	mov	r0, r3

000087f4 <am_util_faultisr_collect_data>:
// am_fault_isr() was called.
//
//*****************************************************************************
void
am_util_faultisr_collect_data(uint32_t u32IsrSP)
{
    87f4:	b580      	push	{r7, lr}
    87f6:	b096      	sub	sp, #88	; 0x58
    87f8:	af00      	add	r7, sp, #0
    87fa:	6078      	str	r0, [r7, #4]
    volatile am_fault_t sFaultData;
    am_hal_mcuctrl_fault_t sHalFaultData = {0};
    87fc:	f107 030c 	add.w	r3, r7, #12
    8800:	2200      	movs	r2, #0
    8802:	601a      	str	r2, [r3, #0]
    8804:	605a      	str	r2, [r3, #4]
    8806:	609a      	str	r2, [r3, #8]
    8808:	60da      	str	r2, [r3, #12]
    880a:	611a      	str	r2, [r3, #16]
    880c:	615a      	str	r2, [r3, #20]

    uint32_t u32Mask = 0;
    880e:	2300      	movs	r3, #0
    8810:	657b      	str	r3, [r7, #84]	; 0x54
    // u32Mask is used for 2 things: 1) in the print loop, 2) as a spot to set
    // a breakpoint at the end of the routine.  If the printing is not used,
    // we'll get a compiler warning; so to avoid that warning, we'll use it
    // in a dummy assignment here.
    //
    sFaultData.u32CFSR = u32Mask;       // Avoid compiler warning
    8812:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    8814:	64fb      	str	r3, [r7, #76]	; 0x4c
    sFaultData.u32CFSR = AM_REGVAL(AM_REG_SYSCTRL_CFSR_O);
    8816:	4b2e      	ldr	r3, [pc, #184]	; (88d0 <am_util_faultisr_collect_data+0xdc>)
    8818:	681b      	ldr	r3, [r3, #0]
    881a:	64fb      	str	r3, [r7, #76]	; 0x4c
    sFaultData.u8MMSR  = (sFaultData.u32CFSR >> 0)  & 0xff;
    881c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    881e:	b2db      	uxtb	r3, r3
    8820:	f887 3050 	strb.w	r3, [r7, #80]	; 0x50
    sFaultData.u8BFSR  = (sFaultData.u32CFSR >> 8)  & 0xff;
    8824:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    8826:	0a1b      	lsrs	r3, r3, #8
    8828:	b2db      	uxtb	r3, r3
    882a:	f887 3051 	strb.w	r3, [r7, #81]	; 0x51
    sFaultData.u16UFSR = (sFaultData.u32CFSR >> 16) & 0xffff;
    882e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    8830:	0c1b      	lsrs	r3, r3, #16
    8832:	b29b      	uxth	r3, r3
    8834:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52

    //
    // The address of the location that caused the fault.  e.g. if accessing an
    // invalid data location caused the fault, that address will appear here.
    //
    sFaultData.u32BFAR = AM_REGVAL(AM_REG_SYSCTRL_BFAR_O);
    8838:	4b26      	ldr	r3, [pc, #152]	; (88d4 <am_util_faultisr_collect_data+0xe0>)
    883a:	681b      	ldr	r3, [r3, #0]
    883c:	64bb      	str	r3, [r7, #72]	; 0x48

    //
    // The address of the instruction that caused the fault is the stacked PC
    // if BFSR bit1 is set.
    //
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    883e:	f897 3051 	ldrb.w	r3, [r7, #81]	; 0x51
    8842:	b2db      	uxtb	r3, r3
    8844:	f003 0302 	and.w	r3, r3, #2
    8848:	2b00      	cmp	r3, #0
    884a:	d005      	beq.n	8858 <am_util_faultisr_collect_data+0x64>
    884c:	6879      	ldr	r1, [r7, #4]
    884e:	2006      	movs	r0, #6
    8850:	f7ff ffca 	bl	87e8 <getStackedReg>
    8854:	4603      	mov	r3, r0
    8856:	e001      	b.n	885c <am_util_faultisr_collect_data+0x68>
    8858:	f04f 33ff 	mov.w	r3, #4294967295
    885c:	647b      	str	r3, [r7, #68]	; 0x44

    //
    // Get the stacked registers.
    // Note - the address of the instruction that caused the fault is u32PC.
    //
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    885e:	6879      	ldr	r1, [r7, #4]
    8860:	2000      	movs	r0, #0
    8862:	f7ff ffc1 	bl	87e8 <getStackedReg>
    8866:	4603      	mov	r3, r0
    8868:	627b      	str	r3, [r7, #36]	; 0x24
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    886a:	6879      	ldr	r1, [r7, #4]
    886c:	2001      	movs	r0, #1
    886e:	f7ff ffbb 	bl	87e8 <getStackedReg>
    8872:	4603      	mov	r3, r0
    8874:	62bb      	str	r3, [r7, #40]	; 0x28
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    8876:	6879      	ldr	r1, [r7, #4]
    8878:	2002      	movs	r0, #2
    887a:	f7ff ffb5 	bl	87e8 <getStackedReg>
    887e:	4603      	mov	r3, r0
    8880:	62fb      	str	r3, [r7, #44]	; 0x2c
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    8882:	6879      	ldr	r1, [r7, #4]
    8884:	2003      	movs	r0, #3
    8886:	f7ff ffaf 	bl	87e8 <getStackedReg>
    888a:	4603      	mov	r3, r0
    888c:	633b      	str	r3, [r7, #48]	; 0x30
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    888e:	6879      	ldr	r1, [r7, #4]
    8890:	2004      	movs	r0, #4
    8892:	f7ff ffa9 	bl	87e8 <getStackedReg>
    8896:	4603      	mov	r3, r0
    8898:	637b      	str	r3, [r7, #52]	; 0x34
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    889a:	6879      	ldr	r1, [r7, #4]
    889c:	2005      	movs	r0, #5
    889e:	f7ff ffa3 	bl	87e8 <getStackedReg>
    88a2:	4603      	mov	r3, r0
    88a4:	63bb      	str	r3, [r7, #56]	; 0x38
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    88a6:	6879      	ldr	r1, [r7, #4]
    88a8:	2006      	movs	r0, #6
    88aa:	f7ff ff9d 	bl	87e8 <getStackedReg>
    88ae:	4603      	mov	r3, r0
    88b0:	63fb      	str	r3, [r7, #60]	; 0x3c
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    88b2:	6879      	ldr	r1, [r7, #4]
    88b4:	2007      	movs	r0, #7
    88b6:	f7ff ff97 	bl	87e8 <getStackedReg>
    88ba:	4603      	mov	r3, r0
    88bc:	643b      	str	r3, [r7, #64]	; 0x40
    // Use the HAL MCUCTRL functions to read the fault data.
    //
#ifdef AM_APOLLO3_MCUCTRL
    am_hal_mcuctrl_info_get(AM_HAL_MCUCTRL_INFO_FAULT_STATUS, &sHalFaultData);
#else
    am_hal_mcuctrl_fault_status(&sHalFaultData);
    88be:	f107 030c 	add.w	r3, r7, #12
    88c2:	4618      	mov	r0, r3
    88c4:	f001 f856 	bl	9974 <am_hal_mcuctrl_fault_status>
    }


#endif

    u32Mask = 0;
    88c8:	2300      	movs	r3, #0
    88ca:	657b      	str	r3, [r7, #84]	; 0x54
    //
    // Spin in an infinite loop.
    // We need to spin here inside the function so that we have access to
    // local data, i.e. sFaultData.
    //
    while(1)
    88cc:	e7fe      	b.n	88cc <am_util_faultisr_collect_data+0xd8>
    88ce:	bf00      	nop
    88d0:	e000ed28 	.word	0xe000ed28
    88d4:	e000ed38 	.word	0xe000ed38

000088d8 <am_util_stdio_printf_init>:
//! @return None.
//
//*****************************************************************************
void
am_util_stdio_printf_init(am_util_stdio_print_char_t pfnCharPrint)
{
    88d8:	b480      	push	{r7}
    88da:	b083      	sub	sp, #12
    88dc:	af00      	add	r7, sp, #0
    88de:	6078      	str	r0, [r7, #4]
    g_pfnCharPrint = pfnCharPrint;
    88e0:	4a04      	ldr	r2, [pc, #16]	; (88f4 <am_util_stdio_printf_init+0x1c>)
    88e2:	687b      	ldr	r3, [r7, #4]
    88e4:	6013      	str	r3, [r2, #0]
}
    88e6:	bf00      	nop
    88e8:	370c      	adds	r7, #12
    88ea:	46bd      	mov	sp, r7
    88ec:	f85d 7b04 	ldr.w	r7, [sp], #4
    88f0:	4770      	bx	lr
    88f2:	bf00      	nop
    88f4:	10001140 	.word	0x10001140

000088f8 <divu64_10>:
//  Note: Adapted from Ch10 of Hackers Delight (hackersdelight.org).
//
//*****************************************************************************
static uint64_t
divu64_10(uint64_t ui64Val)
{
    88f8:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    88fc:	b096      	sub	sp, #88	; 0x58
    88fe:	af00      	add	r7, sp, #0
    8900:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
    uint32_t q32, r32, ui32Val;

    //
    // If a 32-bit value, use the more optimal 32-bit routine.
    //
    if ( ui64Val >> 32 )
    8904:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
    8908:	0025      	movs	r5, r4
    890a:	2600      	movs	r6, #0
    890c:	ea55 0306 	orrs.w	r3, r5, r6
    8910:	f000 80a0 	beq.w	8a54 <divu64_10+0x15c>
    {
        q64 = (ui64Val>>1) + (ui64Val>>2);
    8914:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
    8918:	0862      	lsrs	r2, r4, #1
    891a:	ea4f 0133 	mov.w	r1, r3, rrx
    891e:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
    8922:	ea4f 0893 	mov.w	r8, r3, lsr #2
    8926:	ea48 7884 	orr.w	r8, r8, r4, lsl #30
    892a:	ea4f 0994 	mov.w	r9, r4, lsr #2
    892e:	eb11 0308 	adds.w	r3, r1, r8
    8932:	eb42 0409 	adc.w	r4, r2, r9
    8936:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        q64 += (q64 >> 4);
    893a:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    893e:	ea4f 1a13 	mov.w	sl, r3, lsr #4
    8942:	ea4a 7a04 	orr.w	sl, sl, r4, lsl #28
    8946:	ea4f 1b14 	mov.w	fp, r4, lsr #4
    894a:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    894e:	eb13 030a 	adds.w	r3, r3, sl
    8952:	eb44 040b 	adc.w	r4, r4, fp
    8956:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        q64 += (q64 >> 8);
    895a:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    895e:	0a1a      	lsrs	r2, r3, #8
    8960:	62ba      	str	r2, [r7, #40]	; 0x28
    8962:	6aba      	ldr	r2, [r7, #40]	; 0x28
    8964:	ea42 6204 	orr.w	r2, r2, r4, lsl #24
    8968:	62ba      	str	r2, [r7, #40]	; 0x28
    896a:	0a23      	lsrs	r3, r4, #8
    896c:	62fb      	str	r3, [r7, #44]	; 0x2c
    896e:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    8972:	e9d7 120a 	ldrd	r1, r2, [r7, #40]	; 0x28
    8976:	18c9      	adds	r1, r1, r3
    8978:	eb42 0204 	adc.w	r2, r2, r4
    897c:	460b      	mov	r3, r1
    897e:	4614      	mov	r4, r2
    8980:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        q64 += (q64 >> 16);
    8984:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    8988:	0c1a      	lsrs	r2, r3, #16
    898a:	623a      	str	r2, [r7, #32]
    898c:	6a3a      	ldr	r2, [r7, #32]
    898e:	ea42 4204 	orr.w	r2, r2, r4, lsl #16
    8992:	623a      	str	r2, [r7, #32]
    8994:	0c23      	lsrs	r3, r4, #16
    8996:	627b      	str	r3, [r7, #36]	; 0x24
    8998:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    899c:	e9d7 1208 	ldrd	r1, r2, [r7, #32]
    89a0:	18c9      	adds	r1, r1, r3
    89a2:	eb42 0204 	adc.w	r2, r2, r4
    89a6:	460b      	mov	r3, r1
    89a8:	4614      	mov	r4, r2
    89aa:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        q64 += (q64 >> 32);
    89ae:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    89b2:	0023      	movs	r3, r4
    89b4:	603b      	str	r3, [r7, #0]
    89b6:	2300      	movs	r3, #0
    89b8:	607b      	str	r3, [r7, #4]
    89ba:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    89be:	e897 0006 	ldmia.w	r7, {r1, r2}
    89c2:	18c9      	adds	r1, r1, r3
    89c4:	eb42 0204 	adc.w	r2, r2, r4
    89c8:	460b      	mov	r3, r1
    89ca:	4614      	mov	r4, r2
    89cc:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        q64 >>= 3;
    89d0:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    89d4:	08da      	lsrs	r2, r3, #3
    89d6:	613a      	str	r2, [r7, #16]
    89d8:	693a      	ldr	r2, [r7, #16]
    89da:	ea42 7244 	orr.w	r2, r2, r4, lsl #29
    89de:	613a      	str	r2, [r7, #16]
    89e0:	08e3      	lsrs	r3, r4, #3
    89e2:	617b      	str	r3, [r7, #20]
    89e4:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
    89e8:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
        r64 = ui64Val - q64*10;
    89ec:	e9d7 1214 	ldrd	r1, r2, [r7, #80]	; 0x50
    89f0:	460b      	mov	r3, r1
    89f2:	4614      	mov	r4, r2
    89f4:	00a0      	lsls	r0, r4, #2
    89f6:	60f8      	str	r0, [r7, #12]
    89f8:	68f8      	ldr	r0, [r7, #12]
    89fa:	ea40 7093 	orr.w	r0, r0, r3, lsr #30
    89fe:	60f8      	str	r0, [r7, #12]
    8a00:	009b      	lsls	r3, r3, #2
    8a02:	60bb      	str	r3, [r7, #8]
    8a04:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
    8a08:	185b      	adds	r3, r3, r1
    8a0a:	eb44 0402 	adc.w	r4, r4, r2
    8a0e:	18db      	adds	r3, r3, r3
    8a10:	eb44 0404 	adc.w	r4, r4, r4
    8a14:	4619      	mov	r1, r3
    8a16:	4622      	mov	r2, r4
    8a18:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
    8a1c:	1a5b      	subs	r3, r3, r1
    8a1e:	eb64 0402 	sbc.w	r4, r4, r2
    8a22:	e9c7 3412 	strd	r3, r4, [r7, #72]	; 0x48
        return q64 + ((r64 + 6) >> 4);
    8a26:	e9d7 3412 	ldrd	r3, r4, [r7, #72]	; 0x48
    8a2a:	3306      	adds	r3, #6
    8a2c:	f144 0400 	adc.w	r4, r4, #0
    8a30:	091a      	lsrs	r2, r3, #4
    8a32:	61ba      	str	r2, [r7, #24]
    8a34:	69ba      	ldr	r2, [r7, #24]
    8a36:	ea42 7204 	orr.w	r2, r2, r4, lsl #28
    8a3a:	61ba      	str	r2, [r7, #24]
    8a3c:	0923      	lsrs	r3, r4, #4
    8a3e:	61fb      	str	r3, [r7, #28]
    8a40:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
    8a44:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
    8a48:	18c9      	adds	r1, r1, r3
    8a4a:	eb42 0204 	adc.w	r2, r2, r4
    8a4e:	460b      	mov	r3, r1
    8a50:	4614      	mov	r4, r2
    8a52:	e029      	b.n	8aa8 <divu64_10+0x1b0>
    }
    else
    {
        ui32Val = (uint32_t)(ui64Val & 0xffffffff);
    8a54:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    8a56:	647b      	str	r3, [r7, #68]	; 0x44
        q32 = (ui32Val>>1) + (ui32Val>>2);
    8a58:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    8a5a:	085a      	lsrs	r2, r3, #1
    8a5c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    8a5e:	089b      	lsrs	r3, r3, #2
    8a60:	4413      	add	r3, r2
    8a62:	643b      	str	r3, [r7, #64]	; 0x40
        q32 += (q32 >> 4);
    8a64:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    8a66:	091b      	lsrs	r3, r3, #4
    8a68:	6c3a      	ldr	r2, [r7, #64]	; 0x40
    8a6a:	4413      	add	r3, r2
    8a6c:	643b      	str	r3, [r7, #64]	; 0x40
        q32 += (q32 >> 8);
    8a6e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    8a70:	0a1b      	lsrs	r3, r3, #8
    8a72:	6c3a      	ldr	r2, [r7, #64]	; 0x40
    8a74:	4413      	add	r3, r2
    8a76:	643b      	str	r3, [r7, #64]	; 0x40
        q32 += (q32 >> 16);
    8a78:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    8a7a:	0c1b      	lsrs	r3, r3, #16
    8a7c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
    8a7e:	4413      	add	r3, r2
    8a80:	643b      	str	r3, [r7, #64]	; 0x40
        q32 >>= 3;
    8a82:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    8a84:	08db      	lsrs	r3, r3, #3
    8a86:	643b      	str	r3, [r7, #64]	; 0x40
        r32 = ui32Val - q32*10;
    8a88:	6c3a      	ldr	r2, [r7, #64]	; 0x40
    8a8a:	4613      	mov	r3, r2
    8a8c:	009b      	lsls	r3, r3, #2
    8a8e:	4413      	add	r3, r2
    8a90:	005b      	lsls	r3, r3, #1
    8a92:	461a      	mov	r2, r3
    8a94:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    8a96:	1a9b      	subs	r3, r3, r2
    8a98:	63fb      	str	r3, [r7, #60]	; 0x3c
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    8a9a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    8a9c:	3306      	adds	r3, #6
    8a9e:	091a      	lsrs	r2, r3, #4
    8aa0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    8aa2:	4413      	add	r3, r2
    8aa4:	f04f 0400 	mov.w	r4, #0
    }
}
    8aa8:	4618      	mov	r0, r3
    8aaa:	4621      	mov	r1, r4
    8aac:	3758      	adds	r7, #88	; 0x58
    8aae:	46bd      	mov	sp, r7
    8ab0:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    8ab4:	4770      	bx	lr

00008ab6 <ndigits_in_u64>:
// example: 10000 return 5, 123 returns 3.
//
//*****************************************************************************
static int
ndigits_in_u64(uint64_t ui64Val)
{
    8ab6:	b590      	push	{r4, r7, lr}
    8ab8:	b085      	sub	sp, #20
    8aba:	af00      	add	r7, sp, #0
    8abc:	e9c7 0100 	strd	r0, r1, [r7]
    int iNDigits = ui64Val ? 0 : 1;
    8ac0:	683a      	ldr	r2, [r7, #0]
    8ac2:	687b      	ldr	r3, [r7, #4]
    8ac4:	4313      	orrs	r3, r2
    8ac6:	2b00      	cmp	r3, #0
    8ac8:	bf0c      	ite	eq
    8aca:	2301      	moveq	r3, #1
    8acc:	2300      	movne	r3, #0
    8ace:	b2db      	uxtb	r3, r3
    8ad0:	60fb      	str	r3, [r7, #12]

    while ( ui64Val )
    8ad2:	e008      	b.n	8ae6 <ndigits_in_u64+0x30>
    {
        //
        // ui32Val /= 10;
        //
        ui64Val = divu64_10(ui64Val);
    8ad4:	e9d7 0100 	ldrd	r0, r1, [r7]
    8ad8:	f7ff ff0e 	bl	88f8 <divu64_10>
    8adc:	e9c7 0100 	strd	r0, r1, [r7]
        ++iNDigits;
    8ae0:	68fb      	ldr	r3, [r7, #12]
    8ae2:	3301      	adds	r3, #1
    8ae4:	60fb      	str	r3, [r7, #12]
    while ( ui64Val )
    8ae6:	e897 0018 	ldmia.w	r7, {r3, r4}
    8aea:	4323      	orrs	r3, r4
    8aec:	d1f2      	bne.n	8ad4 <ndigits_in_u64+0x1e>
    }

    return iNDigits;
    8aee:	68fb      	ldr	r3, [r7, #12]
}
    8af0:	4618      	mov	r0, r3
    8af2:	3714      	adds	r7, #20
    8af4:	46bd      	mov	sp, r7
    8af6:	bd90      	pop	{r4, r7, pc}

00008af8 <ndigits_in_i64>:
// example: -3 returns 1, 3 returns 1, 15 returns 2, -15 returns 2, ...
//
//*****************************************************************************
static int
ndigits_in_i64(int64_t i64Val)
{
    8af8:	b590      	push	{r4, r7, lr}
    8afa:	b083      	sub	sp, #12
    8afc:	af00      	add	r7, sp, #0
    8afe:	e9c7 0100 	strd	r0, r1, [r7]
    if ( i64Val < 0 )
    8b02:	e897 0018 	ldmia.w	r7, {r3, r4}
    8b06:	2b00      	cmp	r3, #0
    8b08:	f174 0300 	sbcs.w	r3, r4, #0
    8b0c:	da06      	bge.n	8b1c <ndigits_in_i64+0x24>
    {
        //
        // Get absolute value
        //
        i64Val = -i64Val;
    8b0e:	e897 0018 	ldmia.w	r7, {r3, r4}
    8b12:	425b      	negs	r3, r3
    8b14:	eb64 0444 	sbc.w	r4, r4, r4, lsl #1
    8b18:	e887 0018 	stmia.w	r7, {r3, r4}
    }

    return ndigits_in_u64((uint64_t) i64Val);
    8b1c:	e897 0018 	ldmia.w	r7, {r3, r4}
    8b20:	4618      	mov	r0, r3
    8b22:	4621      	mov	r1, r4
    8b24:	f7ff ffc7 	bl	8ab6 <ndigits_in_u64>
    8b28:	4603      	mov	r3, r0
}
    8b2a:	4618      	mov	r0, r3
    8b2c:	370c      	adds	r7, #12
    8b2e:	46bd      	mov	sp, r7
    8b30:	bd90      	pop	{r4, r7, pc}

00008b32 <ndigits_in_hex>:
// Return the number of hex digits in an uint64_t.
//
//*****************************************************************************
static int
ndigits_in_hex(uint64_t ui64Val)
{
    8b32:	b490      	push	{r4, r7}
    8b34:	b084      	sub	sp, #16
    8b36:	af00      	add	r7, sp, #0
    8b38:	e9c7 0100 	strd	r0, r1, [r7]
    int iDigits = ui64Val ? 0 : 1;
    8b3c:	6839      	ldr	r1, [r7, #0]
    8b3e:	687a      	ldr	r2, [r7, #4]
    8b40:	430a      	orrs	r2, r1
    8b42:	2a00      	cmp	r2, #0
    8b44:	bf0c      	ite	eq
    8b46:	2201      	moveq	r2, #1
    8b48:	2200      	movne	r2, #0
    8b4a:	b2d2      	uxtb	r2, r2
    8b4c:	60fa      	str	r2, [r7, #12]

    while ( ui64Val )
    8b4e:	e00a      	b.n	8b66 <ndigits_in_hex+0x34>
    {
        ui64Val >>= 4;
    8b50:	e897 0006 	ldmia.w	r7, {r1, r2}
    8b54:	090b      	lsrs	r3, r1, #4
    8b56:	ea43 7302 	orr.w	r3, r3, r2, lsl #28
    8b5a:	0914      	lsrs	r4, r2, #4
    8b5c:	e887 0018 	stmia.w	r7, {r3, r4}
        ++iDigits;
    8b60:	68fa      	ldr	r2, [r7, #12]
    8b62:	3201      	adds	r2, #1
    8b64:	60fa      	str	r2, [r7, #12]
    while ( ui64Val )
    8b66:	e897 0006 	ldmia.w	r7, {r1, r2}
    8b6a:	430a      	orrs	r2, r1
    8b6c:	d1f0      	bne.n	8b50 <ndigits_in_hex+0x1e>
    }

    return iDigits;
    8b6e:	68fb      	ldr	r3, [r7, #12]
}
    8b70:	4618      	mov	r0, r3
    8b72:	3710      	adds	r7, #16
    8b74:	46bd      	mov	sp, r7
    8b76:	bc90      	pop	{r4, r7}
    8b78:	4770      	bx	lr

00008b7a <decstr_to_int>:
// pui32CharCnt.
//
//*****************************************************************************
static uint32_t
decstr_to_int(const char *pcStr, uint32_t *pui32CharCnt)
{
    8b7a:	b480      	push	{r7}
    8b7c:	b087      	sub	sp, #28
    8b7e:	af00      	add	r7, sp, #0
    8b80:	6078      	str	r0, [r7, #4]
    8b82:	6039      	str	r1, [r7, #0]
    bool bNeg = false;
    8b84:	2300      	movs	r3, #0
    8b86:	75fb      	strb	r3, [r7, #23]
    uint32_t ui32Val = 0, uCnt = 0;
    8b88:	2300      	movs	r3, #0
    8b8a:	613b      	str	r3, [r7, #16]
    8b8c:	2300      	movs	r3, #0
    8b8e:	60fb      	str	r3, [r7, #12]

    if ( *pcStr == '-')
    8b90:	687b      	ldr	r3, [r7, #4]
    8b92:	781b      	ldrb	r3, [r3, #0]
    8b94:	2b2d      	cmp	r3, #45	; 0x2d
    8b96:	d11b      	bne.n	8bd0 <decstr_to_int+0x56>
    {
        bNeg = true;
    8b98:	2301      	movs	r3, #1
    8b9a:	75fb      	strb	r3, [r7, #23]
        pcStr++;
    8b9c:	687b      	ldr	r3, [r7, #4]
    8b9e:	3301      	adds	r3, #1
    8ba0:	607b      	str	r3, [r7, #4]
        uCnt++;
    8ba2:	68fb      	ldr	r3, [r7, #12]
    8ba4:	3301      	adds	r3, #1
    8ba6:	60fb      	str	r3, [r7, #12]
    }

    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    8ba8:	e012      	b.n	8bd0 <decstr_to_int+0x56>
    {
        ++uCnt;
    8baa:	68fb      	ldr	r3, [r7, #12]
    8bac:	3301      	adds	r3, #1
    8bae:	60fb      	str	r3, [r7, #12]

        //
        // Multiply accumulated value by 10.
        //
        ui32Val *= 10;
    8bb0:	693a      	ldr	r2, [r7, #16]
    8bb2:	4613      	mov	r3, r2
    8bb4:	009b      	lsls	r3, r3, #2
    8bb6:	4413      	add	r3, r2
    8bb8:	005b      	lsls	r3, r3, #1
    8bba:	613b      	str	r3, [r7, #16]

        //
        // Add in the new low digit.
        //
        ui32Val += (*pcStr - '0');
    8bbc:	687b      	ldr	r3, [r7, #4]
    8bbe:	781b      	ldrb	r3, [r3, #0]
    8bc0:	461a      	mov	r2, r3
    8bc2:	693b      	ldr	r3, [r7, #16]
    8bc4:	4413      	add	r3, r2
    8bc6:	3b30      	subs	r3, #48	; 0x30
    8bc8:	613b      	str	r3, [r7, #16]
        pcStr++;
    8bca:	687b      	ldr	r3, [r7, #4]
    8bcc:	3301      	adds	r3, #1
    8bce:	607b      	str	r3, [r7, #4]
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    8bd0:	687b      	ldr	r3, [r7, #4]
    8bd2:	781b      	ldrb	r3, [r3, #0]
    8bd4:	2b2f      	cmp	r3, #47	; 0x2f
    8bd6:	d903      	bls.n	8be0 <decstr_to_int+0x66>
    8bd8:	687b      	ldr	r3, [r7, #4]
    8bda:	781b      	ldrb	r3, [r3, #0]
    8bdc:	2b39      	cmp	r3, #57	; 0x39
    8bde:	d9e4      	bls.n	8baa <decstr_to_int+0x30>
    }

    if ( pui32CharCnt )
    8be0:	683b      	ldr	r3, [r7, #0]
    8be2:	2b00      	cmp	r3, #0
    8be4:	d002      	beq.n	8bec <decstr_to_int+0x72>
    {
        *pui32CharCnt = uCnt;
    8be6:	683b      	ldr	r3, [r7, #0]
    8be8:	68fa      	ldr	r2, [r7, #12]
    8bea:	601a      	str	r2, [r3, #0]
    }

    return bNeg ? -ui32Val : ui32Val;
    8bec:	7dfb      	ldrb	r3, [r7, #23]
    8bee:	2b00      	cmp	r3, #0
    8bf0:	d002      	beq.n	8bf8 <decstr_to_int+0x7e>
    8bf2:	693b      	ldr	r3, [r7, #16]
    8bf4:	425b      	negs	r3, r3
    8bf6:	e000      	b.n	8bfa <decstr_to_int+0x80>
    8bf8:	693b      	ldr	r3, [r7, #16]
}
    8bfa:	4618      	mov	r0, r3
    8bfc:	371c      	adds	r7, #28
    8bfe:	46bd      	mov	sp, r7
    8c00:	f85d 7b04 	ldr.w	r7, [sp], #4
    8c04:	4770      	bx	lr

00008c06 <uint64_to_str>:
// written).
//
//*****************************************************************************
static int
uint64_to_str(uint64_t ui64Val, char *pcBuf)
{
    8c06:	b590      	push	{r4, r7, lr}
    8c08:	b091      	sub	sp, #68	; 0x44
    8c0a:	af00      	add	r7, sp, #0
    8c0c:	e9c7 0102 	strd	r0, r1, [r7, #8]
    8c10:	607a      	str	r2, [r7, #4]
    char tbuf[25];
    int ix = 0, iNumDig = 0;
    8c12:	2300      	movs	r3, #0
    8c14:	63fb      	str	r3, [r7, #60]	; 0x3c
    8c16:	2300      	movs	r3, #0
    8c18:	63bb      	str	r3, [r7, #56]	; 0x38
    do
    {
        //
        // Divide by 10
        //
        u64Tmp = divu64_10(ui64Val);
    8c1a:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
    8c1e:	f7ff fe6b 	bl	88f8 <divu64_10>
    8c22:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30

        //
        // Get modulus
        //
        uMod = ui64Val - (u64Tmp * 10);
    8c26:	68b9      	ldr	r1, [r7, #8]
    8c28:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    8c2a:	4613      	mov	r3, r2
    8c2c:	009b      	lsls	r3, r3, #2
    8c2e:	4413      	add	r3, r2
    8c30:	005b      	lsls	r3, r3, #1
    8c32:	1acb      	subs	r3, r1, r3
    8c34:	62fb      	str	r3, [r7, #44]	; 0x2c

        tbuf[ix++] = uMod + '0';
    8c36:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    8c38:	1c5a      	adds	r2, r3, #1
    8c3a:	63fa      	str	r2, [r7, #60]	; 0x3c
    8c3c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    8c3e:	b2d2      	uxtb	r2, r2
    8c40:	3230      	adds	r2, #48	; 0x30
    8c42:	b2d2      	uxtb	r2, r2
    8c44:	f107 0140 	add.w	r1, r7, #64	; 0x40
    8c48:	440b      	add	r3, r1
    8c4a:	f803 2c30 	strb.w	r2, [r3, #-48]
        ui64Val = u64Tmp;
    8c4e:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
    8c52:	e9c7 3402 	strd	r3, r4, [r7, #8]
    } while ( ui64Val );
    8c56:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
    8c5a:	4323      	orrs	r3, r4
    8c5c:	d1dd      	bne.n	8c1a <uint64_to_str+0x14>

    //
    // Save the total number of digits
    //
    iNumDig = ix;
    8c5e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    8c60:	63bb      	str	r3, [r7, #56]	; 0x38

    //
    // Now, reverse the buffer when saving to the caller's buffer.
    //
    if ( pcBuf )
    8c62:	687b      	ldr	r3, [r7, #4]
    8c64:	2b00      	cmp	r3, #0
    8c66:	d011      	beq.n	8c8c <uint64_to_str+0x86>
    {
        while ( ix-- )
    8c68:	e008      	b.n	8c7c <uint64_to_str+0x76>
        {
            *pcBuf++ = tbuf[ix];
    8c6a:	687b      	ldr	r3, [r7, #4]
    8c6c:	1c5a      	adds	r2, r3, #1
    8c6e:	607a      	str	r2, [r7, #4]
    8c70:	f107 0110 	add.w	r1, r7, #16
    8c74:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    8c76:	440a      	add	r2, r1
    8c78:	7812      	ldrb	r2, [r2, #0]
    8c7a:	701a      	strb	r2, [r3, #0]
        while ( ix-- )
    8c7c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    8c7e:	1e5a      	subs	r2, r3, #1
    8c80:	63fa      	str	r2, [r7, #60]	; 0x3c
    8c82:	2b00      	cmp	r3, #0
    8c84:	d1f1      	bne.n	8c6a <uint64_to_str+0x64>
        }

        //
        // Terminate the caller's buffer
        //
        *pcBuf = 0x00;
    8c86:	687b      	ldr	r3, [r7, #4]
    8c88:	2200      	movs	r2, #0
    8c8a:	701a      	strb	r2, [r3, #0]
    }

    return iNumDig;
    8c8c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
}
    8c8e:	4618      	mov	r0, r3
    8c90:	3744      	adds	r7, #68	; 0x44
    8c92:	46bd      	mov	sp, r7
    8c94:	bd90      	pop	{r4, r7, pc}

00008c96 <uint64_to_hexstr>:
// written).
//
//*****************************************************************************
static int
uint64_to_hexstr(uint64_t ui64Val, char *pcBuf, bool bLower)
{
    8c96:	b4b0      	push	{r4, r5, r7}
    8c98:	b08d      	sub	sp, #52	; 0x34
    8c9a:	af00      	add	r7, sp, #0
    8c9c:	e9c7 0102 	strd	r0, r1, [r7, #8]
    8ca0:	607a      	str	r2, [r7, #4]
    8ca2:	70fb      	strb	r3, [r7, #3]
    int iNumDig, ix = 0;
    8ca4:	2300      	movs	r3, #0
    8ca6:	62fb      	str	r3, [r7, #44]	; 0x2c
    char cCh, tbuf[20];

    if ( ui64Val == 0 )
    8ca8:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
    8cac:	4313      	orrs	r3, r2
    8cae:	d131      	bne.n	8d14 <uint64_to_hexstr+0x7e>
    {
        tbuf[ix++] = '0';   // Print a '0'
    8cb0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8cb2:	1c5a      	adds	r2, r3, #1
    8cb4:	62fa      	str	r2, [r7, #44]	; 0x2c
    8cb6:	f107 0230 	add.w	r2, r7, #48	; 0x30
    8cba:	4413      	add	r3, r2
    8cbc:	2230      	movs	r2, #48	; 0x30
    8cbe:	f803 2c20 	strb.w	r2, [r3, #-32]
    }

    while ( ui64Val )
    8cc2:	e027      	b.n	8d14 <uint64_to_hexstr+0x7e>
    {
        cCh = ui64Val & 0xf;
    8cc4:	7a3b      	ldrb	r3, [r7, #8]
    8cc6:	f003 030f 	and.w	r3, r3, #15
    8cca:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

        //
        // Alpha character
        //
        if ( cCh > 9 )
    8cce:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
    8cd2:	2b09      	cmp	r3, #9
    8cd4:	d90a      	bls.n	8cec <uint64_to_hexstr+0x56>
        {
            cCh += bLower ? 0x27 : 0x7;
    8cd6:	78fb      	ldrb	r3, [r7, #3]
    8cd8:	2b00      	cmp	r3, #0
    8cda:	d001      	beq.n	8ce0 <uint64_to_hexstr+0x4a>
    8cdc:	2227      	movs	r2, #39	; 0x27
    8cde:	e000      	b.n	8ce2 <uint64_to_hexstr+0x4c>
    8ce0:	2207      	movs	r2, #7
    8ce2:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
    8ce6:	4413      	add	r3, r2
    8ce8:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
        }

        tbuf[ix++] = cCh + '0';
    8cec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8cee:	1c5a      	adds	r2, r3, #1
    8cf0:	62fa      	str	r2, [r7, #44]	; 0x2c
    8cf2:	f897 202b 	ldrb.w	r2, [r7, #43]	; 0x2b
    8cf6:	3230      	adds	r2, #48	; 0x30
    8cf8:	b2d2      	uxtb	r2, r2
    8cfa:	f107 0130 	add.w	r1, r7, #48	; 0x30
    8cfe:	440b      	add	r3, r1
    8d00:	f803 2c20 	strb.w	r2, [r3, #-32]
        ui64Val >>= 4;
    8d04:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
    8d08:	0914      	lsrs	r4, r2, #4
    8d0a:	ea44 7403 	orr.w	r4, r4, r3, lsl #28
    8d0e:	091d      	lsrs	r5, r3, #4
    8d10:	e9c7 4502 	strd	r4, r5, [r7, #8]
    while ( ui64Val )
    8d14:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
    8d18:	4313      	orrs	r3, r2
    8d1a:	d1d3      	bne.n	8cc4 <uint64_to_hexstr+0x2e>
    }

    //
    // Save the total number of digits
    //
    iNumDig = ix;
    8d1c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8d1e:	627b      	str	r3, [r7, #36]	; 0x24

    //
    // Now, reverse the buffer when saving to the callers buffer.
    //
    if (pcBuf)
    8d20:	687b      	ldr	r3, [r7, #4]
    8d22:	2b00      	cmp	r3, #0
    8d24:	d011      	beq.n	8d4a <uint64_to_hexstr+0xb4>
    {
        while (ix--)
    8d26:	e008      	b.n	8d3a <uint64_to_hexstr+0xa4>
        {
            *pcBuf++ = tbuf[ix];
    8d28:	687b      	ldr	r3, [r7, #4]
    8d2a:	1c5a      	adds	r2, r3, #1
    8d2c:	607a      	str	r2, [r7, #4]
    8d2e:	f107 0110 	add.w	r1, r7, #16
    8d32:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    8d34:	440a      	add	r2, r1
    8d36:	7812      	ldrb	r2, [r2, #0]
    8d38:	701a      	strb	r2, [r3, #0]
        while (ix--)
    8d3a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8d3c:	1e5a      	subs	r2, r3, #1
    8d3e:	62fa      	str	r2, [r7, #44]	; 0x2c
    8d40:	2b00      	cmp	r3, #0
    8d42:	d1f1      	bne.n	8d28 <uint64_to_hexstr+0x92>
        }

        //
        // Terminate the caller's buffer
        //
        *pcBuf = 0;
    8d44:	687b      	ldr	r3, [r7, #4]
    8d46:	2200      	movs	r2, #0
    8d48:	701a      	strb	r2, [r3, #0]
    }

    return iNumDig;
    8d4a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
    8d4c:	4618      	mov	r0, r3
    8d4e:	3734      	adds	r7, #52	; 0x34
    8d50:	46bd      	mov	sp, r7
    8d52:	bcb0      	pop	{r4, r5, r7}
    8d54:	4770      	bx	lr

00008d56 <simple_strlen>:
// Return length of the given string.
//
//*****************************************************************************
static uint32_t
simple_strlen(char *pcBuf)
{
    8d56:	b480      	push	{r7}
    8d58:	b085      	sub	sp, #20
    8d5a:	af00      	add	r7, sp, #0
    8d5c:	6078      	str	r0, [r7, #4]
    uint32_t ui32RetVal = 0;
    8d5e:	2300      	movs	r3, #0
    8d60:	60fb      	str	r3, [r7, #12]
    if ( !pcBuf )
    8d62:	687b      	ldr	r3, [r7, #4]
    8d64:	2b00      	cmp	r3, #0
    8d66:	d104      	bne.n	8d72 <simple_strlen+0x1c>
    {
        return ui32RetVal;
    8d68:	68fb      	ldr	r3, [r7, #12]
    8d6a:	e009      	b.n	8d80 <simple_strlen+0x2a>
    }

    while ( *pcBuf++ )
    {
        ui32RetVal++;
    8d6c:	68fb      	ldr	r3, [r7, #12]
    8d6e:	3301      	adds	r3, #1
    8d70:	60fb      	str	r3, [r7, #12]
    while ( *pcBuf++ )
    8d72:	687b      	ldr	r3, [r7, #4]
    8d74:	1c5a      	adds	r2, r3, #1
    8d76:	607a      	str	r2, [r7, #4]
    8d78:	781b      	ldrb	r3, [r3, #0]
    8d7a:	2b00      	cmp	r3, #0
    8d7c:	d1f6      	bne.n	8d6c <simple_strlen+0x16>
    }
    return ui32RetVal;
    8d7e:	68fb      	ldr	r3, [r7, #12]
}
    8d80:	4618      	mov	r0, r3
    8d82:	3714      	adds	r7, #20
    8d84:	46bd      	mov	sp, r7
    8d86:	f85d 7b04 	ldr.w	r7, [sp], #4
    8d8a:	4770      	bx	lr

00008d8c <padbuffer>:
// Pad a string buffer with pad characters.
//
//*****************************************************************************
static int32_t
padbuffer(char *pcBuf, uint8_t cPadChar, int32_t i32NumChars)
{
    8d8c:	b480      	push	{r7}
    8d8e:	b087      	sub	sp, #28
    8d90:	af00      	add	r7, sp, #0
    8d92:	60f8      	str	r0, [r7, #12]
    8d94:	460b      	mov	r3, r1
    8d96:	607a      	str	r2, [r7, #4]
    8d98:	72fb      	strb	r3, [r7, #11]
    int32_t i32Cnt = 0;
    8d9a:	2300      	movs	r3, #0
    8d9c:	617b      	str	r3, [r7, #20]

    if ( i32NumChars <= 0 )
    8d9e:	687b      	ldr	r3, [r7, #4]
    8da0:	2b00      	cmp	r3, #0
    8da2:	dc0c      	bgt.n	8dbe <padbuffer+0x32>
    {
        return i32Cnt;
    8da4:	697b      	ldr	r3, [r7, #20]
    8da6:	e010      	b.n	8dca <padbuffer+0x3e>
    }

    while ( i32NumChars-- )
    {
        if ( pcBuf )
    8da8:	68fb      	ldr	r3, [r7, #12]
    8daa:	2b00      	cmp	r3, #0
    8dac:	d004      	beq.n	8db8 <padbuffer+0x2c>
        {
            *pcBuf++ = cPadChar;
    8dae:	68fb      	ldr	r3, [r7, #12]
    8db0:	1c5a      	adds	r2, r3, #1
    8db2:	60fa      	str	r2, [r7, #12]
    8db4:	7afa      	ldrb	r2, [r7, #11]
    8db6:	701a      	strb	r2, [r3, #0]
        }
        i32Cnt++;
    8db8:	697b      	ldr	r3, [r7, #20]
    8dba:	3301      	adds	r3, #1
    8dbc:	617b      	str	r3, [r7, #20]
    while ( i32NumChars-- )
    8dbe:	687b      	ldr	r3, [r7, #4]
    8dc0:	1e5a      	subs	r2, r3, #1
    8dc2:	607a      	str	r2, [r7, #4]
    8dc4:	2b00      	cmp	r3, #0
    8dc6:	d1ef      	bne.n	8da8 <padbuffer+0x1c>
    }

    return i32Cnt;
    8dc8:	697b      	ldr	r3, [r7, #20]
}
    8dca:	4618      	mov	r0, r3
    8dcc:	371c      	adds	r7, #28
    8dce:	46bd      	mov	sp, r7
    8dd0:	f85d 7b04 	ldr.w	r7, [sp], #4
    8dd4:	4770      	bx	lr
	...

00008dd8 <ftoa>:
    int32_t I32;
    float F;
} i32fl_t;

static int ftoa(float fValue, char *pcBuf, int iPrecision)
{
    8dd8:	b590      	push	{r4, r7, lr}
    8dda:	b08f      	sub	sp, #60	; 0x3c
    8ddc:	af00      	add	r7, sp, #0
    8dde:	60f8      	str	r0, [r7, #12]
    8de0:	60b9      	str	r1, [r7, #8]
    8de2:	607a      	str	r2, [r7, #4]
    i32fl_t unFloatValue;
    int iExp2, iBufSize;
    int32_t i32Significand, i32IntPart, i32FracPart;
    char *pcBufInitial, *pcBuftmp;

    iBufSize = *(uint32_t*)pcBuf;
    8de4:	68bb      	ldr	r3, [r7, #8]
    8de6:	681b      	ldr	r3, [r3, #0]
    8de8:	627b      	str	r3, [r7, #36]	; 0x24
    if (iBufSize < 4)
    8dea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    8dec:	2b03      	cmp	r3, #3
    8dee:	dc02      	bgt.n	8df6 <ftoa+0x1e>
    {
        return AM_FTOA_ERR_BUFSIZE;
    8df0:	f06f 0302 	mvn.w	r3, #2
    8df4:	e0e7      	b.n	8fc6 <ftoa+0x1ee>
    }

    if (fValue == 0.0f)
    8df6:	edd7 7a03 	vldr	s15, [r7, #12]
    8dfa:	eef5 7a40 	vcmp.f32	s15, #0.0
    8dfe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8e02:	d104      	bne.n	8e0e <ftoa+0x36>
    {
        // "0.0"
        *(uint32_t*)pcBuf = 0x00 << 24 | ('0' << 16) | ('.' << 8) | ('0' << 0);
    8e04:	68bb      	ldr	r3, [r7, #8]
    8e06:	4a72      	ldr	r2, [pc, #456]	; (8fd0 <ftoa+0x1f8>)
    8e08:	601a      	str	r2, [r3, #0]
        return 3;
    8e0a:	2303      	movs	r3, #3
    8e0c:	e0db      	b.n	8fc6 <ftoa+0x1ee>
    }

    pcBufInitial = pcBuf;
    8e0e:	68bb      	ldr	r3, [r7, #8]
    8e10:	623b      	str	r3, [r7, #32]

    unFloatValue.F = fValue;
    8e12:	68fb      	ldr	r3, [r7, #12]
    8e14:	613b      	str	r3, [r7, #16]

    iExp2 = ((unFloatValue.I32 >> 23) & 0x000000FF) - 127;
    8e16:	693b      	ldr	r3, [r7, #16]
    8e18:	15db      	asrs	r3, r3, #23
    8e1a:	b2db      	uxtb	r3, r3
    8e1c:	3b7f      	subs	r3, #127	; 0x7f
    8e1e:	61fb      	str	r3, [r7, #28]
    i32Significand = (unFloatValue.I32 & 0x00FFFFFF) | 0x00800000;
    8e20:	693b      	ldr	r3, [r7, #16]
    8e22:	f3c3 0316 	ubfx	r3, r3, #0, #23
    8e26:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
    8e2a:	61bb      	str	r3, [r7, #24]
    i32FracPart = 0;
    8e2c:	2300      	movs	r3, #0
    8e2e:	633b      	str	r3, [r7, #48]	; 0x30
    i32IntPart = 0;
    8e30:	2300      	movs	r3, #0
    8e32:	637b      	str	r3, [r7, #52]	; 0x34

    if (iExp2 >= 31)
    8e34:	69fb      	ldr	r3, [r7, #28]
    8e36:	2b1e      	cmp	r3, #30
    8e38:	dd02      	ble.n	8e40 <ftoa+0x68>
    {
        return AM_FTOA_ERR_VAL_TOO_LARGE;
    8e3a:	f06f 0301 	mvn.w	r3, #1
    8e3e:	e0c2      	b.n	8fc6 <ftoa+0x1ee>
    }
    else if (iExp2 < -23)
    8e40:	69fb      	ldr	r3, [r7, #28]
    8e42:	f113 0f17 	cmn.w	r3, #23
    8e46:	da02      	bge.n	8e4e <ftoa+0x76>
    {
        return AM_FTOA_ERR_VAL_TOO_SMALL;
    8e48:	f04f 33ff 	mov.w	r3, #4294967295
    8e4c:	e0bb      	b.n	8fc6 <ftoa+0x1ee>
    }
    else if (iExp2 >= 23)
    8e4e:	69fb      	ldr	r3, [r7, #28]
    8e50:	2b16      	cmp	r3, #22
    8e52:	dd06      	ble.n	8e62 <ftoa+0x8a>
    {
        i32IntPart = i32Significand << (iExp2 - 23);
    8e54:	69fb      	ldr	r3, [r7, #28]
    8e56:	3b17      	subs	r3, #23
    8e58:	69ba      	ldr	r2, [r7, #24]
    8e5a:	fa02 f303 	lsl.w	r3, r2, r3
    8e5e:	637b      	str	r3, [r7, #52]	; 0x34
    8e60:	e01a      	b.n	8e98 <ftoa+0xc0>
    }
    else if (iExp2 >= 0)
    8e62:	69fb      	ldr	r3, [r7, #28]
    8e64:	2b00      	cmp	r3, #0
    8e66:	db0f      	blt.n	8e88 <ftoa+0xb0>
    {
        i32IntPart = i32Significand >> (23 - iExp2);
    8e68:	69fb      	ldr	r3, [r7, #28]
    8e6a:	f1c3 0317 	rsb	r3, r3, #23
    8e6e:	69ba      	ldr	r2, [r7, #24]
    8e70:	fa42 f303 	asr.w	r3, r2, r3
    8e74:	637b      	str	r3, [r7, #52]	; 0x34
        i32FracPart = (i32Significand << (iExp2 + 1)) & 0x00FFFFFF;
    8e76:	69fb      	ldr	r3, [r7, #28]
    8e78:	3301      	adds	r3, #1
    8e7a:	69ba      	ldr	r2, [r7, #24]
    8e7c:	fa02 f303 	lsl.w	r3, r2, r3
    8e80:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    8e84:	633b      	str	r3, [r7, #48]	; 0x30
    8e86:	e007      	b.n	8e98 <ftoa+0xc0>
    }
    else // if (iExp2 < 0)
    {
        i32FracPart = (i32Significand & 0x00FFFFFF) >> -(iExp2 + 1);
    8e88:	69bb      	ldr	r3, [r7, #24]
    8e8a:	f023 427f 	bic.w	r2, r3, #4278190080	; 0xff000000
    8e8e:	69fb      	ldr	r3, [r7, #28]
    8e90:	43db      	mvns	r3, r3
    8e92:	fa42 f303 	asr.w	r3, r2, r3
    8e96:	633b      	str	r3, [r7, #48]	; 0x30
    }

    if (unFloatValue.I32 < 0)
    8e98:	693b      	ldr	r3, [r7, #16]
    8e9a:	2b00      	cmp	r3, #0
    8e9c:	da04      	bge.n	8ea8 <ftoa+0xd0>
    {
        *pcBuf++ = '-';
    8e9e:	68bb      	ldr	r3, [r7, #8]
    8ea0:	1c5a      	adds	r2, r3, #1
    8ea2:	60ba      	str	r2, [r7, #8]
    8ea4:	222d      	movs	r2, #45	; 0x2d
    8ea6:	701a      	strb	r2, [r3, #0]
    }

    if (i32IntPart == 0)
    8ea8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    8eaa:	2b00      	cmp	r3, #0
    8eac:	d105      	bne.n	8eba <ftoa+0xe2>
    {
        *pcBuf++ = '0';
    8eae:	68bb      	ldr	r3, [r7, #8]
    8eb0:	1c5a      	adds	r2, r3, #1
    8eb2:	60ba      	str	r2, [r7, #8]
    8eb4:	2230      	movs	r2, #48	; 0x30
    8eb6:	701a      	strb	r2, [r3, #0]
    8eb8:	e021      	b.n	8efe <ftoa+0x126>
    }
    else
    {
        if (i32IntPart > 0)
    8eba:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    8ebc:	2b00      	cmp	r3, #0
    8ebe:	dd08      	ble.n	8ed2 <ftoa+0xfa>
        {
            uint64_to_str(i32IntPart, pcBuf);
    8ec0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    8ec2:	ea4f 74e3 	mov.w	r4, r3, asr #31
    8ec6:	68ba      	ldr	r2, [r7, #8]
    8ec8:	4618      	mov	r0, r3
    8eca:	4621      	mov	r1, r4
    8ecc:	f7ff fe9b 	bl	8c06 <uint64_to_str>
    8ed0:	e011      	b.n	8ef6 <ftoa+0x11e>
        }
        else
        {
            *pcBuf++ = '-';
    8ed2:	68bb      	ldr	r3, [r7, #8]
    8ed4:	1c5a      	adds	r2, r3, #1
    8ed6:	60ba      	str	r2, [r7, #8]
    8ed8:	222d      	movs	r2, #45	; 0x2d
    8eda:	701a      	strb	r2, [r3, #0]
            uint64_to_str(-i32IntPart, pcBuf);
    8edc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    8ede:	425b      	negs	r3, r3
    8ee0:	ea4f 74e3 	mov.w	r4, r3, asr #31
    8ee4:	68ba      	ldr	r2, [r7, #8]
    8ee6:	4618      	mov	r0, r3
    8ee8:	4621      	mov	r1, r4
    8eea:	f7ff fe8c 	bl	8c06 <uint64_to_str>
        }
        while (*pcBuf)    // Get to end of new string
    8eee:	e002      	b.n	8ef6 <ftoa+0x11e>
        {
            pcBuf++;
    8ef0:	68bb      	ldr	r3, [r7, #8]
    8ef2:	3301      	adds	r3, #1
    8ef4:	60bb      	str	r3, [r7, #8]
        while (*pcBuf)    // Get to end of new string
    8ef6:	68bb      	ldr	r3, [r7, #8]
    8ef8:	781b      	ldrb	r3, [r3, #0]
    8efa:	2b00      	cmp	r3, #0
    8efc:	d1f8      	bne.n	8ef0 <ftoa+0x118>
    }

    //
    // Now, begin the fractional part
    //
    *pcBuf++ = '.';
    8efe:	68bb      	ldr	r3, [r7, #8]
    8f00:	1c5a      	adds	r2, r3, #1
    8f02:	60ba      	str	r2, [r7, #8]
    8f04:	222e      	movs	r2, #46	; 0x2e
    8f06:	701a      	strb	r2, [r3, #0]

    if (i32FracPart == 0)
    8f08:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    8f0a:	2b00      	cmp	r3, #0
    8f0c:	d105      	bne.n	8f1a <ftoa+0x142>
    {
        *pcBuf++ = '0';
    8f0e:	68bb      	ldr	r3, [r7, #8]
    8f10:	1c5a      	adds	r2, r3, #1
    8f12:	60ba      	str	r2, [r7, #8]
    8f14:	2230      	movs	r2, #48	; 0x30
    8f16:	701a      	strb	r2, [r3, #0]
    8f18:	e04f      	b.n	8fba <ftoa+0x1e2>
    }
    else
    {
        int jx, iMax;

        iMax = iBufSize - (pcBuf - pcBufInitial) - 1;
    8f1a:	68ba      	ldr	r2, [r7, #8]
    8f1c:	6a3b      	ldr	r3, [r7, #32]
    8f1e:	1ad3      	subs	r3, r2, r3
    8f20:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    8f22:	1ad3      	subs	r3, r2, r3
    8f24:	3b01      	subs	r3, #1
    8f26:	617b      	str	r3, [r7, #20]
        iMax = (iMax > iPrecision) ? iPrecision : iMax;
    8f28:	697a      	ldr	r2, [r7, #20]
    8f2a:	687b      	ldr	r3, [r7, #4]
    8f2c:	4293      	cmp	r3, r2
    8f2e:	bfa8      	it	ge
    8f30:	4613      	movge	r3, r2
    8f32:	617b      	str	r3, [r7, #20]

        for (jx = 0; jx < iMax; jx++)
    8f34:	2300      	movs	r3, #0
    8f36:	62bb      	str	r3, [r7, #40]	; 0x28
    8f38:	e015      	b.n	8f66 <ftoa+0x18e>
        {
            i32FracPart *= 10;
    8f3a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    8f3c:	4613      	mov	r3, r2
    8f3e:	009b      	lsls	r3, r3, #2
    8f40:	4413      	add	r3, r2
    8f42:	005b      	lsls	r3, r3, #1
    8f44:	633b      	str	r3, [r7, #48]	; 0x30
            *pcBuf++ = (i32FracPart >> 24) + '0';
    8f46:	68bb      	ldr	r3, [r7, #8]
    8f48:	1c5a      	adds	r2, r3, #1
    8f4a:	60ba      	str	r2, [r7, #8]
    8f4c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    8f4e:	1612      	asrs	r2, r2, #24
    8f50:	b2d2      	uxtb	r2, r2
    8f52:	3230      	adds	r2, #48	; 0x30
    8f54:	b2d2      	uxtb	r2, r2
    8f56:	701a      	strb	r2, [r3, #0]
            i32FracPart &= 0x00FFFFFF;
    8f58:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    8f5a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    8f5e:	633b      	str	r3, [r7, #48]	; 0x30
        for (jx = 0; jx < iMax; jx++)
    8f60:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8f62:	3301      	adds	r3, #1
    8f64:	62bb      	str	r3, [r7, #40]	; 0x28
    8f66:	6aba      	ldr	r2, [r7, #40]	; 0x28
    8f68:	697b      	ldr	r3, [r7, #20]
    8f6a:	429a      	cmp	r2, r3
    8f6c:	dbe5      	blt.n	8f3a <ftoa+0x162>
        // 1.996        4                   1.9960
        //
        // To determine whether to round up, we'll look at what the next
        // decimal value would have been.
        //
        if ( ((i32FracPart * 10) >> 24) >= 5 )
    8f6e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    8f70:	4613      	mov	r3, r2
    8f72:	009b      	lsls	r3, r3, #2
    8f74:	4413      	add	r3, r2
    8f76:	005b      	lsls	r3, r3, #1
    8f78:	161b      	asrs	r3, r3, #24
    8f7a:	2b04      	cmp	r3, #4
    8f7c:	dd1d      	ble.n	8fba <ftoa+0x1e2>
        {
            //
            // Yes, we need to round up.
            // Go back through the string and make adjustments as necessary.
            //
            pcBuftmp = pcBuf - 1;
    8f7e:	68bb      	ldr	r3, [r7, #8]
    8f80:	3b01      	subs	r3, #1
    8f82:	62fb      	str	r3, [r7, #44]	; 0x2c
            while ( pcBuftmp >= pcBufInitial )
    8f84:	e015      	b.n	8fb2 <ftoa+0x1da>
            {
                if ( *pcBuftmp == '.' )
    8f86:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8f88:	781b      	ldrb	r3, [r3, #0]
    8f8a:	2b2e      	cmp	r3, #46	; 0x2e
    8f8c:	d00e      	beq.n	8fac <ftoa+0x1d4>
                {
                }
                else if ( *pcBuftmp == '9' )
    8f8e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8f90:	781b      	ldrb	r3, [r3, #0]
    8f92:	2b39      	cmp	r3, #57	; 0x39
    8f94:	d103      	bne.n	8f9e <ftoa+0x1c6>
                {
                    *pcBuftmp = '0';
    8f96:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8f98:	2230      	movs	r2, #48	; 0x30
    8f9a:	701a      	strb	r2, [r3, #0]
    8f9c:	e006      	b.n	8fac <ftoa+0x1d4>
                }
                else
                {
                    *pcBuftmp += 1;
    8f9e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8fa0:	781b      	ldrb	r3, [r3, #0]
    8fa2:	3301      	adds	r3, #1
    8fa4:	b2da      	uxtb	r2, r3
    8fa6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8fa8:	701a      	strb	r2, [r3, #0]
                    break;
    8faa:	e006      	b.n	8fba <ftoa+0x1e2>
                }
                pcBuftmp--;
    8fac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    8fae:	3b01      	subs	r3, #1
    8fb0:	62fb      	str	r3, [r7, #44]	; 0x2c
            while ( pcBuftmp >= pcBufInitial )
    8fb2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    8fb4:	6a3b      	ldr	r3, [r7, #32]
    8fb6:	429a      	cmp	r2, r3
    8fb8:	d2e5      	bcs.n	8f86 <ftoa+0x1ae>
    }

    //
    // Terminate the string and we're done
    //
    *pcBuf = 0x00;
    8fba:	68bb      	ldr	r3, [r7, #8]
    8fbc:	2200      	movs	r2, #0
    8fbe:	701a      	strb	r2, [r3, #0]

    return (pcBuf - pcBufInitial);
    8fc0:	68ba      	ldr	r2, [r7, #8]
    8fc2:	6a3b      	ldr	r3, [r7, #32]
    8fc4:	1ad3      	subs	r3, r2, r3
} // ftoa()
    8fc6:	4618      	mov	r0, r3
    8fc8:	373c      	adds	r7, #60	; 0x3c
    8fca:	46bd      	mov	sp, r7
    8fcc:	bd90      	pop	{r4, r7, pc}
    8fce:	bf00      	nop
    8fd0:	00302e30 	.word	0x00302e30

00008fd4 <am_util_stdio_vsprintf>:
//! @return uint32_t representing the number of characters printed.
//
//******************************************************************************
uint32_t
am_util_stdio_vsprintf(char *pcBuf, const char *pcFmt, va_list pArgs)
{
    8fd4:	b590      	push	{r4, r7, lr}
    8fd6:	b095      	sub	sp, #84	; 0x54
    8fd8:	af00      	add	r7, sp, #0
    8fda:	60f8      	str	r0, [r7, #12]
    8fdc:	60b9      	str	r1, [r7, #8]
    8fde:	607a      	str	r2, [r7, #4]
    char *pcStr;
    uint64_t ui64Val;
    int64_t i64Val;
    uint32_t ui32NumChars, ui32CharCnt = 0;
    8fe0:	2300      	movs	r3, #0
    8fe2:	63fb      	str	r3, [r7, #60]	; 0x3c
    int iWidth, iVal, iPrecision;
    uint8_t ui8CharSpecifier, ui8PadChar;
    bool bLower, bLongLong, bNeg;
    uint32_t ui32strlen = 0;
    8fe4:	2300      	movs	r3, #0
    8fe6:	627b      	str	r3, [r7, #36]	; 0x24

    while ( *pcFmt != 0x0 )
    8fe8:	e2e3      	b.n	95b2 <am_util_stdio_vsprintf+0x5de>
    {
        iPrecision = 6;             // printf() default precision for %f is 6
    8fea:	2306      	movs	r3, #6
    8fec:	633b      	str	r3, [r7, #48]	; 0x30

        if ( *pcFmt != '%' )
    8fee:	68bb      	ldr	r3, [r7, #8]
    8ff0:	781b      	ldrb	r3, [r3, #0]
    8ff2:	2b25      	cmp	r3, #37	; 0x25
    8ff4:	d01f      	beq.n	9036 <am_util_stdio_vsprintf+0x62>
        {
            //
            // Accumulate the string portion of the format specification.
            //
            if ( pcBuf )
    8ff6:	68fb      	ldr	r3, [r7, #12]
    8ff8:	2b00      	cmp	r3, #0
    8ffa:	d015      	beq.n	9028 <am_util_stdio_vsprintf+0x54>
            {
                // If '\n', convert to '\r\n'
                if ( *pcFmt == '\n'  &&  g_bTxtXlate )
    8ffc:	68bb      	ldr	r3, [r7, #8]
    8ffe:	781b      	ldrb	r3, [r3, #0]
    9000:	2b0a      	cmp	r3, #10
    9002:	d10b      	bne.n	901c <am_util_stdio_vsprintf+0x48>
    9004:	4bb1      	ldr	r3, [pc, #708]	; (92cc <am_util_stdio_vsprintf+0x2f8>)
    9006:	781b      	ldrb	r3, [r3, #0]
    9008:	2b00      	cmp	r3, #0
    900a:	d007      	beq.n	901c <am_util_stdio_vsprintf+0x48>
                {
                    *pcBuf++ = '\r';
    900c:	68fb      	ldr	r3, [r7, #12]
    900e:	1c5a      	adds	r2, r3, #1
    9010:	60fa      	str	r2, [r7, #12]
    9012:	220d      	movs	r2, #13
    9014:	701a      	strb	r2, [r3, #0]
                    ++ui32CharCnt;
    9016:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    9018:	3301      	adds	r3, #1
    901a:	63fb      	str	r3, [r7, #60]	; 0x3c
                }
                *pcBuf++ = *pcFmt;
    901c:	68fb      	ldr	r3, [r7, #12]
    901e:	1c5a      	adds	r2, r3, #1
    9020:	60fa      	str	r2, [r7, #12]
    9022:	68ba      	ldr	r2, [r7, #8]
    9024:	7812      	ldrb	r2, [r2, #0]
    9026:	701a      	strb	r2, [r3, #0]
            }

            ++pcFmt;
    9028:	68bb      	ldr	r3, [r7, #8]
    902a:	3301      	adds	r3, #1
    902c:	60bb      	str	r3, [r7, #8]
            ++ui32CharCnt;
    902e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    9030:	3301      	adds	r3, #1
    9032:	63fb      	str	r3, [r7, #60]	; 0x3c
            continue;
    9034:	e2bd      	b.n	95b2 <am_util_stdio_vsprintf+0x5de>
        }

        //
        // Handle the specifier.
        //
        ++pcFmt;
    9036:	68bb      	ldr	r3, [r7, #8]
    9038:	3301      	adds	r3, #1
    903a:	60bb      	str	r3, [r7, #8]
        bLower = bLongLong = false;
    903c:	2300      	movs	r3, #0
    903e:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
    9042:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
    9046:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e

        //
        // Default to space as ui8PadChar
        //
        ui8PadChar = ' ';
    904a:	2320      	movs	r3, #32
    904c:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

        if ( *pcFmt == '0' )
    9050:	68bb      	ldr	r3, [r7, #8]
    9052:	781b      	ldrb	r3, [r3, #0]
    9054:	2b30      	cmp	r3, #48	; 0x30
    9056:	d105      	bne.n	9064 <am_util_stdio_vsprintf+0x90>
        {
            ui8PadChar = '0';
    9058:	2330      	movs	r3, #48	; 0x30
    905a:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
            ++pcFmt;
    905e:	68bb      	ldr	r3, [r7, #8]
    9060:	3301      	adds	r3, #1
    9062:	60bb      	str	r3, [r7, #8]
        }

        //
        // Width specifier
        //
        iWidth = decstr_to_int(pcFmt, &ui32NumChars);
    9064:	f107 0310 	add.w	r3, r7, #16
    9068:	4619      	mov	r1, r3
    906a:	68b8      	ldr	r0, [r7, #8]
    906c:	f7ff fd85 	bl	8b7a <decstr_to_int>
    9070:	4603      	mov	r3, r0
    9072:	63bb      	str	r3, [r7, #56]	; 0x38
        pcFmt += ui32NumChars;
    9074:	693b      	ldr	r3, [r7, #16]
    9076:	68ba      	ldr	r2, [r7, #8]
    9078:	4413      	add	r3, r2
    907a:	60bb      	str	r3, [r7, #8]

        //
        // For now, only support a negative width specifier for %s
        //
        if ( ( *pcFmt != 's' )  &&  ( iWidth < 0 ) )
    907c:	68bb      	ldr	r3, [r7, #8]
    907e:	781b      	ldrb	r3, [r3, #0]
    9080:	2b73      	cmp	r3, #115	; 0x73
    9082:	d005      	beq.n	9090 <am_util_stdio_vsprintf+0xbc>
    9084:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    9086:	2b00      	cmp	r3, #0
    9088:	da02      	bge.n	9090 <am_util_stdio_vsprintf+0xbc>
        {
            iWidth = -iWidth;
    908a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    908c:	425b      	negs	r3, r3
    908e:	63bb      	str	r3, [r7, #56]	; 0x38
        }

        //
        // Check for precision specifier
        //
        if (*pcFmt == '.')
    9090:	68bb      	ldr	r3, [r7, #8]
    9092:	781b      	ldrb	r3, [r3, #0]
    9094:	2b2e      	cmp	r3, #46	; 0x2e
    9096:	d10e      	bne.n	90b6 <am_util_stdio_vsprintf+0xe2>
        {
            ++pcFmt;
    9098:	68bb      	ldr	r3, [r7, #8]
    909a:	3301      	adds	r3, #1
    909c:	60bb      	str	r3, [r7, #8]
            iPrecision = decstr_to_int(pcFmt, &ui32NumChars);
    909e:	f107 0310 	add.w	r3, r7, #16
    90a2:	4619      	mov	r1, r3
    90a4:	68b8      	ldr	r0, [r7, #8]
    90a6:	f7ff fd68 	bl	8b7a <decstr_to_int>
    90aa:	4603      	mov	r3, r0
    90ac:	633b      	str	r3, [r7, #48]	; 0x30
            pcFmt += ui32NumChars;
    90ae:	693b      	ldr	r3, [r7, #16]
    90b0:	68ba      	ldr	r2, [r7, #8]
    90b2:	4413      	add	r3, r2
    90b4:	60bb      	str	r3, [r7, #8]
        // 'll', which must be a modifier for either 'd', 'i', 'u', 'x', or 'X'
        // (or even 'o', which is not currently supported). Other sub-specifiers
        // like 'hh','h', etc. are not currently handled.
        // Note - 'l' is used in Coremark, a primary reason it's supported here.
        //
        if ( *pcFmt == 'l' )
    90b6:	68bb      	ldr	r3, [r7, #8]
    90b8:	781b      	ldrb	r3, [r3, #0]
    90ba:	2b6c      	cmp	r3, #108	; 0x6c
    90bc:	d10c      	bne.n	90d8 <am_util_stdio_vsprintf+0x104>
        {
            pcFmt++;
    90be:	68bb      	ldr	r3, [r7, #8]
    90c0:	3301      	adds	r3, #1
    90c2:	60bb      	str	r3, [r7, #8]
            if ( *pcFmt == 'l' )    // "ll" (long long)
    90c4:	68bb      	ldr	r3, [r7, #8]
    90c6:	781b      	ldrb	r3, [r3, #0]
    90c8:	2b6c      	cmp	r3, #108	; 0x6c
    90ca:	d105      	bne.n	90d8 <am_util_stdio_vsprintf+0x104>
            {
                pcFmt++;
    90cc:	68bb      	ldr	r3, [r7, #8]
    90ce:	3301      	adds	r3, #1
    90d0:	60bb      	str	r3, [r7, #8]
                bLongLong = true;
    90d2:	2301      	movs	r3, #1
    90d4:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
            }
        }

        switch ( *pcFmt )
    90d8:	68bb      	ldr	r3, [r7, #8]
    90da:	781b      	ldrb	r3, [r3, #0]
    90dc:	3b46      	subs	r3, #70	; 0x46
    90de:	2b32      	cmp	r3, #50	; 0x32
    90e0:	f200 8254 	bhi.w	958c <am_util_stdio_vsprintf+0x5b8>
    90e4:	a201      	add	r2, pc, #4	; (adr r2, 90ec <am_util_stdio_vsprintf+0x118>)
    90e6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    90ea:	bf00      	nop
    90ec:	00009517 	.word	0x00009517
    90f0:	0000958d 	.word	0x0000958d
    90f4:	0000958d 	.word	0x0000958d
    90f8:	0000958d 	.word	0x0000958d
    90fc:	0000958d 	.word	0x0000958d
    9100:	0000958d 	.word	0x0000958d
    9104:	0000958d 	.word	0x0000958d
    9108:	0000958d 	.word	0x0000958d
    910c:	0000958d 	.word	0x0000958d
    9110:	0000958d 	.word	0x0000958d
    9114:	0000958d 	.word	0x0000958d
    9118:	0000958d 	.word	0x0000958d
    911c:	0000958d 	.word	0x0000958d
    9120:	0000958d 	.word	0x0000958d
    9124:	0000958d 	.word	0x0000958d
    9128:	0000958d 	.word	0x0000958d
    912c:	0000958d 	.word	0x0000958d
    9130:	0000958d 	.word	0x0000958d
    9134:	000092b3 	.word	0x000092b3
    9138:	0000958d 	.word	0x0000958d
    913c:	0000958d 	.word	0x0000958d
    9140:	0000958d 	.word	0x0000958d
    9144:	0000958d 	.word	0x0000958d
    9148:	0000958d 	.word	0x0000958d
    914c:	0000958d 	.word	0x0000958d
    9150:	0000958d 	.word	0x0000958d
    9154:	0000958d 	.word	0x0000958d
    9158:	0000958d 	.word	0x0000958d
    915c:	0000958d 	.word	0x0000958d
    9160:	000091b9 	.word	0x000091b9
    9164:	000093df 	.word	0x000093df
    9168:	0000958d 	.word	0x0000958d
    916c:	00009517 	.word	0x00009517
    9170:	0000958d 	.word	0x0000958d
    9174:	0000958d 	.word	0x0000958d
    9178:	000093df 	.word	0x000093df
    917c:	0000958d 	.word	0x0000958d
    9180:	0000958d 	.word	0x0000958d
    9184:	0000958d 	.word	0x0000958d
    9188:	0000958d 	.word	0x0000958d
    918c:	0000958d 	.word	0x0000958d
    9190:	0000958d 	.word	0x0000958d
    9194:	0000958d 	.word	0x0000958d
    9198:	0000958d 	.word	0x0000958d
    919c:	0000958d 	.word	0x0000958d
    91a0:	000091df 	.word	0x000091df
    91a4:	0000958d 	.word	0x0000958d
    91a8:	0000934d 	.word	0x0000934d
    91ac:	0000958d 	.word	0x0000958d
    91b0:	0000958d 	.word	0x0000958d
    91b4:	000092ad 	.word	0x000092ad
        {
            case 'c':
                ui8CharSpecifier = va_arg(pArgs, uint32_t);
    91b8:	687b      	ldr	r3, [r7, #4]
    91ba:	1d1a      	adds	r2, r3, #4
    91bc:	607a      	str	r2, [r7, #4]
    91be:	681b      	ldr	r3, [r3, #0]
    91c0:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

                if ( pcBuf )
    91c4:	68fb      	ldr	r3, [r7, #12]
    91c6:	2b00      	cmp	r3, #0
    91c8:	d005      	beq.n	91d6 <am_util_stdio_vsprintf+0x202>
                {
                    *pcBuf++ = ui8CharSpecifier;
    91ca:	68fb      	ldr	r3, [r7, #12]
    91cc:	1c5a      	adds	r2, r3, #1
    91ce:	60fa      	str	r2, [r7, #12]
    91d0:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
    91d4:	701a      	strb	r2, [r3, #0]
                }

                ++ui32CharCnt;
    91d6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    91d8:	3301      	adds	r3, #1
    91da:	63fb      	str	r3, [r7, #60]	; 0x3c
                break;
    91dc:	e1e6      	b.n	95ac <am_util_stdio_vsprintf+0x5d8>

            case 's':
                pcStr = va_arg(pArgs, char *);
    91de:	687b      	ldr	r3, [r7, #4]
    91e0:	1d1a      	adds	r2, r3, #4
    91e2:	607a      	str	r2, [r7, #4]
    91e4:	681b      	ldr	r3, [r3, #0]
    91e6:	64fb      	str	r3, [r7, #76]	; 0x4c
                //
                // For %s, we support the width specifier. If iWidth is negative
                // the string is left-aligned (padding on the right).  Otherwise
                // the string is padded at the beginning with spaces.
                //
                ui32strlen = simple_strlen(pcStr);
    91e8:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
    91ea:	f7ff fdb4 	bl	8d56 <simple_strlen>
    91ee:	6278      	str	r0, [r7, #36]	; 0x24
                if ( iWidth > 0 )
    91f0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    91f2:	2b00      	cmp	r3, #0
    91f4:	dd2e      	ble.n	9254 <am_util_stdio_vsprintf+0x280>
                {
                    // Pad the beginning of the string (right-aligned).
                    if ( ui32strlen < iWidth )
    91f6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    91f8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    91fa:	429a      	cmp	r2, r3
    91fc:	d22a      	bcs.n	9254 <am_util_stdio_vsprintf+0x280>
                    {
                        // String needs some padding.
                        iWidth -= ui32strlen;
    91fe:	6bba      	ldr	r2, [r7, #56]	; 0x38
    9200:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    9202:	1ad3      	subs	r3, r2, r3
    9204:	63bb      	str	r3, [r7, #56]	; 0x38
                        iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    9206:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    920a:	6bba      	ldr	r2, [r7, #56]	; 0x38
    920c:	4619      	mov	r1, r3
    920e:	68f8      	ldr	r0, [r7, #12]
    9210:	f7ff fdbc 	bl	8d8c <padbuffer>
    9214:	63b8      	str	r0, [r7, #56]	; 0x38
                        pcBuf += pcBuf ? iWidth : 0;
    9216:	68fb      	ldr	r3, [r7, #12]
    9218:	2b00      	cmp	r3, #0
    921a:	d001      	beq.n	9220 <am_util_stdio_vsprintf+0x24c>
    921c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    921e:	e000      	b.n	9222 <am_util_stdio_vsprintf+0x24e>
    9220:	2300      	movs	r3, #0
    9222:	68fa      	ldr	r2, [r7, #12]
    9224:	4413      	add	r3, r2
    9226:	60fb      	str	r3, [r7, #12]
                        ui32CharCnt += iWidth;
    9228:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    922a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    922c:	4413      	add	r3, r2
    922e:	63fb      	str	r3, [r7, #60]	; 0x3c
                        iWidth = 0;
    9230:	2300      	movs	r3, #0
    9232:	63bb      	str	r3, [r7, #56]	; 0x38
                    }
                }

                while (*pcStr != 0x0)
    9234:	e00e      	b.n	9254 <am_util_stdio_vsprintf+0x280>
                {
                    if ( pcBuf )
    9236:	68fb      	ldr	r3, [r7, #12]
    9238:	2b00      	cmp	r3, #0
    923a:	d005      	beq.n	9248 <am_util_stdio_vsprintf+0x274>
                    {
                        *pcBuf++ = *pcStr;
    923c:	68fb      	ldr	r3, [r7, #12]
    923e:	1c5a      	adds	r2, r3, #1
    9240:	60fa      	str	r2, [r7, #12]
    9242:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
    9244:	7812      	ldrb	r2, [r2, #0]
    9246:	701a      	strb	r2, [r3, #0]
                    }

                    ++pcStr;
    9248:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    924a:	3301      	adds	r3, #1
    924c:	64fb      	str	r3, [r7, #76]	; 0x4c
                    ++ui32CharCnt;
    924e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    9250:	3301      	adds	r3, #1
    9252:	63fb      	str	r3, [r7, #60]	; 0x3c
                while (*pcStr != 0x0)
    9254:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    9256:	781b      	ldrb	r3, [r3, #0]
    9258:	2b00      	cmp	r3, #0
    925a:	d1ec      	bne.n	9236 <am_util_stdio_vsprintf+0x262>
                }

                if ( iWidth )
    925c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    925e:	2b00      	cmp	r3, #0
    9260:	f000 81a1 	beq.w	95a6 <am_util_stdio_vsprintf+0x5d2>
                {
                    iWidth = -iWidth;
    9264:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    9266:	425b      	negs	r3, r3
    9268:	63bb      	str	r3, [r7, #56]	; 0x38

                    // Pad the end of the string (left-aligned).
                    if ( ui32strlen < iWidth )
    926a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    926c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    926e:	429a      	cmp	r2, r3
    9270:	f080 8199 	bcs.w	95a6 <am_util_stdio_vsprintf+0x5d2>
                    {
                        // String needs some padding.
                        iWidth -= ui32strlen;
    9274:	6bba      	ldr	r2, [r7, #56]	; 0x38
    9276:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    9278:	1ad3      	subs	r3, r2, r3
    927a:	63bb      	str	r3, [r7, #56]	; 0x38
                        iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    927c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    9280:	6bba      	ldr	r2, [r7, #56]	; 0x38
    9282:	4619      	mov	r1, r3
    9284:	68f8      	ldr	r0, [r7, #12]
    9286:	f7ff fd81 	bl	8d8c <padbuffer>
    928a:	63b8      	str	r0, [r7, #56]	; 0x38
                        pcBuf += pcBuf ? iWidth : 0;
    928c:	68fb      	ldr	r3, [r7, #12]
    928e:	2b00      	cmp	r3, #0
    9290:	d001      	beq.n	9296 <am_util_stdio_vsprintf+0x2c2>
    9292:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    9294:	e000      	b.n	9298 <am_util_stdio_vsprintf+0x2c4>
    9296:	2300      	movs	r3, #0
    9298:	68fa      	ldr	r2, [r7, #12]
    929a:	4413      	add	r3, r2
    929c:	60fb      	str	r3, [r7, #12]
                        ui32CharCnt += iWidth;
    929e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    92a0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    92a2:	4413      	add	r3, r2
    92a4:	63fb      	str	r3, [r7, #60]	; 0x3c
                        iWidth = 0;
    92a6:	2300      	movs	r3, #0
    92a8:	63bb      	str	r3, [r7, #56]	; 0x38
                    }
                }
                break;
    92aa:	e17c      	b.n	95a6 <am_util_stdio_vsprintf+0x5d2>

            case 'x':
                bLower = true;
    92ac:	2301      	movs	r3, #1
    92ae:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
            case 'X':
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    92b2:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
    92b6:	2b00      	cmp	r3, #0
    92b8:	d00a      	beq.n	92d0 <am_util_stdio_vsprintf+0x2fc>
    92ba:	687b      	ldr	r3, [r7, #4]
    92bc:	3307      	adds	r3, #7
    92be:	f023 0307 	bic.w	r3, r3, #7
    92c2:	f103 0208 	add.w	r2, r3, #8
    92c6:	607a      	str	r2, [r7, #4]
    92c8:	cb18      	ldmia	r3, {r3, r4}
    92ca:	e007      	b.n	92dc <am_util_stdio_vsprintf+0x308>
    92cc:	10001138 	.word	0x10001138
                                      va_arg(pArgs, uint32_t);
    92d0:	687b      	ldr	r3, [r7, #4]
    92d2:	1d1a      	adds	r2, r3, #4
    92d4:	607a      	str	r2, [r7, #4]
    92d6:	681b      	ldr	r3, [r3, #0]
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    92d8:	f04f 0400 	mov.w	r4, #0
    92dc:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40

                if ( iWidth )
    92e0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    92e2:	2b00      	cmp	r3, #0
    92e4:	d01e      	beq.n	9324 <am_util_stdio_vsprintf+0x350>
                {
                    //
                    // Compute # of leading chars
                    //
                    iWidth -= ndigits_in_hex(ui64Val);
    92e6:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
    92ea:	f7ff fc22 	bl	8b32 <ndigits_in_hex>
    92ee:	4602      	mov	r2, r0
    92f0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    92f2:	1a9b      	subs	r3, r3, r2
    92f4:	63bb      	str	r3, [r7, #56]	; 0x38

                    iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    92f6:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    92fa:	6bba      	ldr	r2, [r7, #56]	; 0x38
    92fc:	4619      	mov	r1, r3
    92fe:	68f8      	ldr	r0, [r7, #12]
    9300:	f7ff fd44 	bl	8d8c <padbuffer>
    9304:	63b8      	str	r0, [r7, #56]	; 0x38
                    pcBuf += pcBuf ? iWidth : 0;
    9306:	68fb      	ldr	r3, [r7, #12]
    9308:	2b00      	cmp	r3, #0
    930a:	d001      	beq.n	9310 <am_util_stdio_vsprintf+0x33c>
    930c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    930e:	e000      	b.n	9312 <am_util_stdio_vsprintf+0x33e>
    9310:	2300      	movs	r3, #0
    9312:	68fa      	ldr	r2, [r7, #12]
    9314:	4413      	add	r3, r2
    9316:	60fb      	str	r3, [r7, #12]
                    ui32CharCnt += iWidth;
    9318:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    931a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    931c:	4413      	add	r3, r2
    931e:	63fb      	str	r3, [r7, #60]	; 0x3c
                    iWidth = 0;
    9320:	2300      	movs	r3, #0
    9322:	63bb      	str	r3, [r7, #56]	; 0x38
                }

                iVal = uint64_to_hexstr(ui64Val, pcBuf, bLower);
    9324:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
    9328:	68fa      	ldr	r2, [r7, #12]
    932a:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
    932e:	f7ff fcb2 	bl	8c96 <uint64_to_hexstr>
    9332:	6378      	str	r0, [r7, #52]	; 0x34

                if ( pcBuf )
    9334:	68fb      	ldr	r3, [r7, #12]
    9336:	2b00      	cmp	r3, #0
    9338:	d003      	beq.n	9342 <am_util_stdio_vsprintf+0x36e>
                {
                    pcBuf += iVal;
    933a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    933c:	68fa      	ldr	r2, [r7, #12]
    933e:	4413      	add	r3, r2
    9340:	60fb      	str	r3, [r7, #12]
                }

                ui32CharCnt += iVal;
    9342:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    9344:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    9346:	4413      	add	r3, r2
    9348:	63fb      	str	r3, [r7, #60]	; 0x3c
                break;
    934a:	e12f      	b.n	95ac <am_util_stdio_vsprintf+0x5d8>

            case 'u':
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    934c:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
    9350:	2b00      	cmp	r3, #0
    9352:	d008      	beq.n	9366 <am_util_stdio_vsprintf+0x392>
    9354:	687b      	ldr	r3, [r7, #4]
    9356:	3307      	adds	r3, #7
    9358:	f023 0307 	bic.w	r3, r3, #7
    935c:	f103 0208 	add.w	r2, r3, #8
    9360:	607a      	str	r2, [r7, #4]
    9362:	cb18      	ldmia	r3, {r3, r4}
    9364:	e005      	b.n	9372 <am_util_stdio_vsprintf+0x39e>
                                      va_arg(pArgs, uint32_t);
    9366:	687b      	ldr	r3, [r7, #4]
    9368:	1d1a      	adds	r2, r3, #4
    936a:	607a      	str	r2, [r7, #4]
    936c:	681b      	ldr	r3, [r3, #0]
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    936e:	f04f 0400 	mov.w	r4, #0
    9372:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40

                if ( iWidth )
    9376:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    9378:	2b00      	cmp	r3, #0
    937a:	d01e      	beq.n	93ba <am_util_stdio_vsprintf+0x3e6>
                {
                    //
                    // We need to pad the beginning of the value.
                    // Compute # of leading chars
                    //
                    iWidth -= ndigits_in_u64(ui64Val);
    937c:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
    9380:	f7ff fb99 	bl	8ab6 <ndigits_in_u64>
    9384:	4602      	mov	r2, r0
    9386:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    9388:	1a9b      	subs	r3, r3, r2
    938a:	63bb      	str	r3, [r7, #56]	; 0x38

                    iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    938c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    9390:	6bba      	ldr	r2, [r7, #56]	; 0x38
    9392:	4619      	mov	r1, r3
    9394:	68f8      	ldr	r0, [r7, #12]
    9396:	f7ff fcf9 	bl	8d8c <padbuffer>
    939a:	63b8      	str	r0, [r7, #56]	; 0x38
                    pcBuf += pcBuf ? iWidth : 0;
    939c:	68fb      	ldr	r3, [r7, #12]
    939e:	2b00      	cmp	r3, #0
    93a0:	d001      	beq.n	93a6 <am_util_stdio_vsprintf+0x3d2>
    93a2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    93a4:	e000      	b.n	93a8 <am_util_stdio_vsprintf+0x3d4>
    93a6:	2300      	movs	r3, #0
    93a8:	68fa      	ldr	r2, [r7, #12]
    93aa:	4413      	add	r3, r2
    93ac:	60fb      	str	r3, [r7, #12]
                    ui32CharCnt += iWidth;
    93ae:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    93b0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    93b2:	4413      	add	r3, r2
    93b4:	63fb      	str	r3, [r7, #60]	; 0x3c
                    iWidth = 0;
    93b6:	2300      	movs	r3, #0
    93b8:	63bb      	str	r3, [r7, #56]	; 0x38
                }

                iVal = uint64_to_str(ui64Val, pcBuf);
    93ba:	68fa      	ldr	r2, [r7, #12]
    93bc:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
    93c0:	f7ff fc21 	bl	8c06 <uint64_to_str>
    93c4:	6378      	str	r0, [r7, #52]	; 0x34

                if ( pcBuf )
    93c6:	68fb      	ldr	r3, [r7, #12]
    93c8:	2b00      	cmp	r3, #0
    93ca:	d003      	beq.n	93d4 <am_util_stdio_vsprintf+0x400>
                {
                    pcBuf += iVal;
    93cc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    93ce:	68fa      	ldr	r2, [r7, #12]
    93d0:	4413      	add	r3, r2
    93d2:	60fb      	str	r3, [r7, #12]
                }

                ui32CharCnt += iVal;
    93d4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    93d6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    93d8:	4413      	add	r3, r2
    93da:	63fb      	str	r3, [r7, #60]	; 0x3c
                break;
    93dc:	e0e6      	b.n	95ac <am_util_stdio_vsprintf+0x5d8>
                // Output for a negative number, for example, -5:
                //   %d:-5
                //  %5d:   -5
                // %05d:-0005
                //
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
    93de:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
    93e2:	2b00      	cmp	r3, #0
    93e4:	d008      	beq.n	93f8 <am_util_stdio_vsprintf+0x424>
    93e6:	687b      	ldr	r3, [r7, #4]
    93e8:	3307      	adds	r3, #7
    93ea:	f023 0307 	bic.w	r3, r3, #7
    93ee:	f103 0208 	add.w	r2, r3, #8
    93f2:	607a      	str	r2, [r7, #4]
    93f4:	cb18      	ldmia	r3, {r3, r4}
    93f6:	e005      	b.n	9404 <am_util_stdio_vsprintf+0x430>
                                     va_arg(pArgs, int32_t);
    93f8:	687b      	ldr	r3, [r7, #4]
    93fa:	1d1a      	adds	r2, r3, #4
    93fc:	607a      	str	r2, [r7, #4]
    93fe:	681b      	ldr	r3, [r3, #0]
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
    9400:	ea4f 74e3 	mov.w	r4, r3, asr #31
    9404:	e9c7 3406 	strd	r3, r4, [r7, #24]

                //
                // Get absolute value
                //
                if ( i64Val < 0 )
    9408:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
    940c:	2b00      	cmp	r3, #0
    940e:	f174 0300 	sbcs.w	r3, r4, #0
    9412:	da0a      	bge.n	942a <am_util_stdio_vsprintf+0x456>
                {
                    ui64Val = -i64Val;          // Get absolute value
    9414:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
    9418:	425b      	negs	r3, r3
    941a:	eb64 0444 	sbc.w	r4, r4, r4, lsl #1
    941e:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40
                    bNeg = true;
    9422:	2301      	movs	r3, #1
    9424:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
    9428:	e006      	b.n	9438 <am_util_stdio_vsprintf+0x464>
                }
                else
                {
                    ui64Val = i64Val;
    942a:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
    942e:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40
                    bNeg = false;
    9432:	2300      	movs	r3, #0
    9434:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
                }

                if ( iWidth )
    9438:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    943a:	2b00      	cmp	r3, #0
    943c:	d04a      	beq.n	94d4 <am_util_stdio_vsprintf+0x500>
                {
                    //
                    // We need to pad the beginning of the value.
                    // Compute # of leading chars
                    //
                    iWidth -= ndigits_in_i64(ui64Val);
    943e:	e9d7 3410 	ldrd	r3, r4, [r7, #64]	; 0x40
    9442:	4618      	mov	r0, r3
    9444:	4621      	mov	r1, r4
    9446:	f7ff fb57 	bl	8af8 <ndigits_in_i64>
    944a:	4602      	mov	r2, r0
    944c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    944e:	1a9b      	subs	r3, r3, r2
    9450:	63bb      	str	r3, [r7, #56]	; 0x38

                    if ( bNeg )
    9452:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    9456:	2b00      	cmp	r3, #0
    9458:	d011      	beq.n	947e <am_util_stdio_vsprintf+0x4aa>
                    {
                        --iWidth;
    945a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    945c:	3b01      	subs	r3, #1
    945e:	63bb      	str	r3, [r7, #56]	; 0x38

                        //
                        // Allow for the negative sign
                        //
                        if ( ui8PadChar == '0' )
    9460:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    9464:	2b30      	cmp	r3, #48	; 0x30
    9466:	d10a      	bne.n	947e <am_util_stdio_vsprintf+0x4aa>
                        {
                            //
                            // Print the neg sign BEFORE the leading zeros
                            //
                            if ( pcBuf )
    9468:	68fb      	ldr	r3, [r7, #12]
    946a:	2b00      	cmp	r3, #0
    946c:	d004      	beq.n	9478 <am_util_stdio_vsprintf+0x4a4>
                            {
                                *pcBuf++ = '-';
    946e:	68fb      	ldr	r3, [r7, #12]
    9470:	1c5a      	adds	r2, r3, #1
    9472:	60fa      	str	r2, [r7, #12]
    9474:	222d      	movs	r2, #45	; 0x2d
    9476:	701a      	strb	r2, [r3, #0]
                            }

                            ++ui32CharCnt;
    9478:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    947a:	3301      	adds	r3, #1
    947c:	63fb      	str	r3, [r7, #60]	; 0x3c
                        }
                    }

                    iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    947e:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    9482:	6bba      	ldr	r2, [r7, #56]	; 0x38
    9484:	4619      	mov	r1, r3
    9486:	68f8      	ldr	r0, [r7, #12]
    9488:	f7ff fc80 	bl	8d8c <padbuffer>
    948c:	63b8      	str	r0, [r7, #56]	; 0x38
                    pcBuf += pcBuf ? iWidth : 0;
    948e:	68fb      	ldr	r3, [r7, #12]
    9490:	2b00      	cmp	r3, #0
    9492:	d001      	beq.n	9498 <am_util_stdio_vsprintf+0x4c4>
    9494:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    9496:	e000      	b.n	949a <am_util_stdio_vsprintf+0x4c6>
    9498:	2300      	movs	r3, #0
    949a:	68fa      	ldr	r2, [r7, #12]
    949c:	4413      	add	r3, r2
    949e:	60fb      	str	r3, [r7, #12]
                    ui32CharCnt += iWidth;
    94a0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    94a2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    94a4:	4413      	add	r3, r2
    94a6:	63fb      	str	r3, [r7, #60]	; 0x3c
                    iWidth = 0;
    94a8:	2300      	movs	r3, #0
    94aa:	63bb      	str	r3, [r7, #56]	; 0x38

                    if ( bNeg  &&  (ui8PadChar == ' ') )
    94ac:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    94b0:	2b00      	cmp	r3, #0
    94b2:	d01e      	beq.n	94f2 <am_util_stdio_vsprintf+0x51e>
    94b4:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    94b8:	2b20      	cmp	r3, #32
    94ba:	d11a      	bne.n	94f2 <am_util_stdio_vsprintf+0x51e>
                    {
                        //
                        // Print the neg sign AFTER the leading blanks
                        //
                        if ( pcBuf )
    94bc:	68fb      	ldr	r3, [r7, #12]
    94be:	2b00      	cmp	r3, #0
    94c0:	d004      	beq.n	94cc <am_util_stdio_vsprintf+0x4f8>
                        {
                            *pcBuf++ = '-';
    94c2:	68fb      	ldr	r3, [r7, #12]
    94c4:	1c5a      	adds	r2, r3, #1
    94c6:	60fa      	str	r2, [r7, #12]
    94c8:	222d      	movs	r2, #45	; 0x2d
    94ca:	701a      	strb	r2, [r3, #0]
                        }

                        ++ui32CharCnt;
    94cc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    94ce:	3301      	adds	r3, #1
    94d0:	63fb      	str	r3, [r7, #60]	; 0x3c
    94d2:	e00e      	b.n	94f2 <am_util_stdio_vsprintf+0x51e>
                    }
                }
                else
                {
                    if ( bNeg )
    94d4:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    94d8:	2b00      	cmp	r3, #0
    94da:	d00a      	beq.n	94f2 <am_util_stdio_vsprintf+0x51e>
                    {
                        if ( pcBuf )
    94dc:	68fb      	ldr	r3, [r7, #12]
    94de:	2b00      	cmp	r3, #0
    94e0:	d004      	beq.n	94ec <am_util_stdio_vsprintf+0x518>
                        {
                            *pcBuf++ = '-';
    94e2:	68fb      	ldr	r3, [r7, #12]
    94e4:	1c5a      	adds	r2, r3, #1
    94e6:	60fa      	str	r2, [r7, #12]
    94e8:	222d      	movs	r2, #45	; 0x2d
    94ea:	701a      	strb	r2, [r3, #0]
                        }
                        ++ui32CharCnt;
    94ec:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    94ee:	3301      	adds	r3, #1
    94f0:	63fb      	str	r3, [r7, #60]	; 0x3c
                    }
                }

                iVal = uint64_to_str(ui64Val, pcBuf);
    94f2:	68fa      	ldr	r2, [r7, #12]
    94f4:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
    94f8:	f7ff fb85 	bl	8c06 <uint64_to_str>
    94fc:	6378      	str	r0, [r7, #52]	; 0x34

                if ( pcBuf )
    94fe:	68fb      	ldr	r3, [r7, #12]
    9500:	2b00      	cmp	r3, #0
    9502:	d003      	beq.n	950c <am_util_stdio_vsprintf+0x538>
                {
                    pcBuf += iVal;
    9504:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    9506:	68fa      	ldr	r2, [r7, #12]
    9508:	4413      	add	r3, r2
    950a:	60fb      	str	r3, [r7, #12]
                }

                ui32CharCnt += iVal;
    950c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    950e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    9510:	4413      	add	r3, r2
    9512:	63fb      	str	r3, [r7, #60]	; 0x3c
                break;
    9514:	e04a      	b.n	95ac <am_util_stdio_vsprintf+0x5d8>


            case 'f':
            case 'F':
                if ( pcBuf )
    9516:	68fb      	ldr	r3, [r7, #12]
    9518:	2b00      	cmp	r3, #0
    951a:	d046      	beq.n	95aa <am_util_stdio_vsprintf+0x5d6>
                {
                    float fValue = va_arg(pArgs, double);
    951c:	687b      	ldr	r3, [r7, #4]
    951e:	3307      	adds	r3, #7
    9520:	f023 0307 	bic.w	r3, r3, #7
    9524:	f103 0208 	add.w	r2, r3, #8
    9528:	607a      	str	r2, [r7, #4]
    952a:	cb18      	ldmia	r3, {r3, r4}
    952c:	4618      	mov	r0, r3
    952e:	4621      	mov	r1, r4
    9530:	f7fe fda6 	bl	8080 <__aeabi_d2f>
    9534:	4603      	mov	r3, r0
    9536:	617b      	str	r3, [r7, #20]

                    //
                    // pcBuf is an input (size of buffer) and also an output of ftoa()
                    //
                    *(uint32_t*)pcBuf = 20;
    9538:	68fb      	ldr	r3, [r7, #12]
    953a:	2214      	movs	r2, #20
    953c:	601a      	str	r2, [r3, #0]

                    iVal = ftoa(fValue, pcBuf, iPrecision);
    953e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    9540:	68f9      	ldr	r1, [r7, #12]
    9542:	6978      	ldr	r0, [r7, #20]
    9544:	f7ff fc48 	bl	8dd8 <ftoa>
    9548:	6378      	str	r0, [r7, #52]	; 0x34
                    if ( iVal < 0 )
    954a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    954c:	2b00      	cmp	r3, #0
    954e:	da14      	bge.n	957a <am_util_stdio_vsprintf+0x5a6>
                    {
                        uint32_t u32PrntErrVal;
                        if ( iVal == AM_FTOA_ERR_VAL_TOO_SMALL )
    9550:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    9552:	f1b3 3fff 	cmp.w	r3, #4294967295
    9556:	d102      	bne.n	955e <am_util_stdio_vsprintf+0x58a>
                        {
                            u32PrntErrVal = (0x00 << 24) | ('0' << 16) |
    9558:	4b1e      	ldr	r3, [pc, #120]	; (95d4 <am_util_stdio_vsprintf+0x600>)
    955a:	62bb      	str	r3, [r7, #40]	; 0x28
    955c:	e008      	b.n	9570 <am_util_stdio_vsprintf+0x59c>
                                            ('.' << 8)   | ('0' << 0);  // "0.0"
                        }
                        else if ( iVal == AM_FTOA_ERR_VAL_TOO_LARGE )
    955e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    9560:	f113 0f02 	cmn.w	r3, #2
    9564:	d102      	bne.n	956c <am_util_stdio_vsprintf+0x598>
                        {
                            u32PrntErrVal = (0x00 << 24) | ('#' << 16) |
    9566:	4b1c      	ldr	r3, [pc, #112]	; (95d8 <am_util_stdio_vsprintf+0x604>)
    9568:	62bb      	str	r3, [r7, #40]	; 0x28
    956a:	e001      	b.n	9570 <am_util_stdio_vsprintf+0x59c>
                                            ('.' << 8)   | ('#' << 0);  // "#.#"
                        }
                        else
                        {
                            u32PrntErrVal = (0x00 << 24) | ('?' << 16) |
    956c:	4b1b      	ldr	r3, [pc, #108]	; (95dc <am_util_stdio_vsprintf+0x608>)
    956e:	62bb      	str	r3, [r7, #40]	; 0x28
                                            ('.' << 8)   | ('?' << 0);  // "?.?"
                        }
                        *(uint32_t*)pcBuf = u32PrntErrVal;
    9570:	68fb      	ldr	r3, [r7, #12]
    9572:	6aba      	ldr	r2, [r7, #40]	; 0x28
    9574:	601a      	str	r2, [r3, #0]
                        iVal = 3;
    9576:	2303      	movs	r3, #3
    9578:	637b      	str	r3, [r7, #52]	; 0x34
                    }
                    ui32CharCnt += iVal;
    957a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    957c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    957e:	4413      	add	r3, r2
    9580:	63fb      	str	r3, [r7, #60]	; 0x3c
                    pcBuf += iVal;
    9582:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    9584:	68fa      	ldr	r2, [r7, #12]
    9586:	4413      	add	r3, r2
    9588:	60fb      	str	r3, [r7, #12]
                }
                break;
    958a:	e00e      	b.n	95aa <am_util_stdio_vsprintf+0x5d6>
            // For non-handled specifiers, we'll just print the character.
            // e.g. this will allow the normal printing of a '%' using
            // "%%".
            //
            default:
                if ( pcBuf )
    958c:	68fb      	ldr	r3, [r7, #12]
    958e:	2b00      	cmp	r3, #0
    9590:	d005      	beq.n	959e <am_util_stdio_vsprintf+0x5ca>
                {
                    *pcBuf++ = *pcFmt;
    9592:	68fb      	ldr	r3, [r7, #12]
    9594:	1c5a      	adds	r2, r3, #1
    9596:	60fa      	str	r2, [r7, #12]
    9598:	68ba      	ldr	r2, [r7, #8]
    959a:	7812      	ldrb	r2, [r2, #0]
    959c:	701a      	strb	r2, [r3, #0]
                }

                ++ui32CharCnt;
    959e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    95a0:	3301      	adds	r3, #1
    95a2:	63fb      	str	r3, [r7, #60]	; 0x3c
                break;
    95a4:	e002      	b.n	95ac <am_util_stdio_vsprintf+0x5d8>
                break;
    95a6:	bf00      	nop
    95a8:	e000      	b.n	95ac <am_util_stdio_vsprintf+0x5d8>
                break;
    95aa:	bf00      	nop
        } // switch()

        //
        // Bump the format specification to the next character
        //
        ++pcFmt;
    95ac:	68bb      	ldr	r3, [r7, #8]
    95ae:	3301      	adds	r3, #1
    95b0:	60bb      	str	r3, [r7, #8]
    while ( *pcFmt != 0x0 )
    95b2:	68bb      	ldr	r3, [r7, #8]
    95b4:	781b      	ldrb	r3, [r3, #0]
    95b6:	2b00      	cmp	r3, #0
    95b8:	f47f ad17 	bne.w	8fea <am_util_stdio_vsprintf+0x16>
    } // while ()

    //
    // Terminate the string
    //
    if ( pcBuf )
    95bc:	68fb      	ldr	r3, [r7, #12]
    95be:	2b00      	cmp	r3, #0
    95c0:	d002      	beq.n	95c8 <am_util_stdio_vsprintf+0x5f4>
    {
        *pcBuf = 0x0;
    95c2:	68fb      	ldr	r3, [r7, #12]
    95c4:	2200      	movs	r2, #0
    95c6:	701a      	strb	r2, [r3, #0]
    }

    return (ui32CharCnt);
    95c8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
}
    95ca:	4618      	mov	r0, r3
    95cc:	3754      	adds	r7, #84	; 0x54
    95ce:	46bd      	mov	sp, r7
    95d0:	bd90      	pop	{r4, r7, pc}
    95d2:	bf00      	nop
    95d4:	00302e30 	.word	0x00302e30
    95d8:	00232e23 	.word	0x00232e23
    95dc:	003f2e3f 	.word	0x003f2e3f

000095e0 <am_util_stdio_printf>:
//! @return uint32_t representing the number of characters printed.
//
// *****************************************************************************
uint32_t
am_util_stdio_printf(const char *pcFmt, ...)
{
    95e0:	b40f      	push	{r0, r1, r2, r3}
    95e2:	b580      	push	{r7, lr}
    95e4:	b082      	sub	sp, #8
    95e6:	af00      	add	r7, sp, #0

    //
    // Convert to the desired string.
    //
    va_list pArgs;
    va_start(pArgs, pcFmt);
    95e8:	f107 0314 	add.w	r3, r7, #20
    95ec:	603b      	str	r3, [r7, #0]
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
    95ee:	683a      	ldr	r2, [r7, #0]
    95f0:	6939      	ldr	r1, [r7, #16]
    95f2:	4808      	ldr	r0, [pc, #32]	; (9614 <am_util_stdio_printf+0x34>)
    95f4:	f7ff fcee 	bl	8fd4 <am_util_stdio_vsprintf>
    95f8:	6078      	str	r0, [r7, #4]
    va_end(pArgs);

    //
    // This is where we print the buffer to the configured interface.
    //
    g_pfnCharPrint(g_prfbuf);
    95fa:	4b07      	ldr	r3, [pc, #28]	; (9618 <am_util_stdio_printf+0x38>)
    95fc:	681b      	ldr	r3, [r3, #0]
    95fe:	4805      	ldr	r0, [pc, #20]	; (9614 <am_util_stdio_printf+0x34>)
    9600:	4798      	blx	r3

    //
    // return the number of characters printed.
    //
    return ui32NumChars;
    9602:	687b      	ldr	r3, [r7, #4]
}
    9604:	4618      	mov	r0, r3
    9606:	3708      	adds	r7, #8
    9608:	46bd      	mov	sp, r7
    960a:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    960e:	b004      	add	sp, #16
    9610:	4770      	bx	lr
    9612:	bf00      	nop
    9614:	10001038 	.word	0x10001038
    9618:	10001140 	.word	0x10001140

0000961c <am_util_stdio_terminal_clear>:
//! @return None.
//
//*****************************************************************************
void
am_util_stdio_terminal_clear(void)
{
    961c:	b580      	push	{r7, lr}
    961e:	af00      	add	r7, sp, #0
    // left corner.
    // We'll first print a number of spaces, which helps get the ITM in sync
    // with AM Flash, especially after a reset event or a system clock
    // frequency change.
    //
    am_util_stdio_printf("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
    9620:	4802      	ldr	r0, [pc, #8]	; (962c <am_util_stdio_terminal_clear+0x10>)
    9622:	f7ff ffdd 	bl	95e0 <am_util_stdio_printf>
}
    9626:	bf00      	nop
    9628:	bd80      	pop	{r7, pc}
    962a:	bf00      	nop
    962c:	00009b38 	.word	0x00009b38

00009630 <am_bsp_low_power_init>:
//! @return None.
//
//*****************************************************************************
void
am_bsp_low_power_init(void)
{
    9630:	b508      	push	{r3, lr}
    //
    // Enable internal buck converters.
    //
    am_hal_mcuctrl_bucks_enable();
    9632:	f000 f9cb 	bl	99cc <am_hal_mcuctrl_bucks_enable>

    //
    // Turn off the voltage comparator as this is enabled on reset.
    //
    am_hal_vcomp_disable();
    9636:	f000 fa6d 	bl	9b14 <am_hal_vcomp_disable>

    //
    // Run the RTC off the LFRC.
    //
    am_hal_rtc_osc_select(AM_HAL_RTC_OSC_LFRC);
    963a:	2001      	movs	r0, #1
    963c:	f000 f9dc 	bl	99f8 <am_hal_rtc_osc_select>

    //
    // Stop the XTAL.
    //
    am_hal_clkgen_osc_stop(AM_HAL_CLKGEN_OSC_XT);
    9640:	2001      	movs	r0, #1
    9642:	f000 f883 	bl	974c <am_hal_clkgen_osc_stop>

    //
    // Disable the RTC.
    //
    am_hal_rtc_osc_disable();
    9646:	f000 f9e5 	bl	9a14 <am_hal_rtc_osc_disable>

    //
    // Disable the bandgap.
    //
    am_hal_mcuctrl_bandgap_disable();
}
    964a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    am_hal_mcuctrl_bandgap_disable();
    964e:	f000 b9b5 	b.w	99bc <am_hal_mcuctrl_bandgap_disable>
    9652:	bf00      	nop

00009654 <am_bsp_debug_printf_enable>:
//! @return None.
//
//*****************************************************************************
void
am_bsp_debug_printf_enable(void)
{
    9654:	b510      	push	{r4, lr}
    am_hal_tpiu_config_t TPIUcfg;

    if (g_ui32HALflags & AM_HAL_FLAGS_ITMSKIPENABLEDISABLE_M)
    9656:	4b10      	ldr	r3, [pc, #64]	; (9698 <am_bsp_debug_printf_enable+0x44>)
    9658:	681c      	ldr	r4, [r3, #0]
    965a:	f014 0401 	ands.w	r4, r4, #1
{
    965e:	b086      	sub	sp, #24
    if (g_ui32HALflags & AM_HAL_FLAGS_ITMSKIPENABLEDISABLE_M)
    9660:	d001      	beq.n	9666 <am_bsp_debug_printf_enable+0x12>
    // Enable the ITM and TPIU
    //
    TPIUcfg.ui32SetItmBaud = AM_HAL_TPIU_BAUD_1M;
    am_hal_tpiu_enable(&TPIUcfg);
    am_bsp_pin_enable(ITM_SWO);
}
    9662:	b006      	add	sp, #24
    9664:	bd10      	pop	{r4, pc}
    TPIUcfg.ui32SetItmBaud = AM_HAL_TPIU_BAUD_1M;
    9666:	a806      	add	r0, sp, #24
    9668:	490c      	ldr	r1, [pc, #48]	; (969c <am_bsp_debug_printf_enable+0x48>)
    966a:	f840 1d14 	str.w	r1, [r0, #-20]!
    am_hal_tpiu_enable(&TPIUcfg);
    966e:	f000 f9ef 	bl	9a50 <am_hal_tpiu_enable>
    am_bsp_pin_enable(ITM_SWO);
    9672:	4a0b      	ldr	r2, [pc, #44]	; (96a0 <am_bsp_debug_printf_enable+0x4c>)
    9674:	480b      	ldr	r0, [pc, #44]	; (96a4 <am_bsp_debug_printf_enable+0x50>)
    9676:	490c      	ldr	r1, [pc, #48]	; (96a8 <am_bsp_debug_printf_enable+0x54>)
    9678:	2373      	movs	r3, #115	; 0x73
    967a:	6013      	str	r3, [r2, #0]
    967c:	6803      	ldr	r3, [r0, #0]
    967e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    9682:	6003      	str	r3, [r0, #0]
    9684:	6808      	ldr	r0, [r1, #0]
    9686:	f420 4c7f 	bic.w	ip, r0, #65280	; 0xff00
    968a:	f44c 5380 	orr.w	r3, ip, #4096	; 0x1000
    968e:	600b      	str	r3, [r1, #0]
    9690:	6014      	str	r4, [r2, #0]
}
    9692:	b006      	add	sp, #24
    9694:	bd10      	pop	{r4, pc}
    9696:	bf00      	nop
    9698:	1000113c 	.word	0x1000113c
    969c:	000f4240 	.word	0x000f4240
    96a0:	40010060 	.word	0x40010060
    96a4:	40010054 	.word	0x40010054
    96a8:	40010028 	.word	0x40010028

000096ac <am_bsp_debug_printf_disable>:
//
//*****************************************************************************
void
am_bsp_debug_printf_disable(void)
{
    if (g_ui32HALflags & AM_HAL_FLAGS_ITMSKIPENABLEDISABLE_M)
    96ac:	4b0f      	ldr	r3, [pc, #60]	; (96ec <am_bsp_debug_printf_disable+0x40>)
{
    96ae:	b510      	push	{r4, lr}
    if (g_ui32HALflags & AM_HAL_FLAGS_ITMSKIPENABLEDISABLE_M)
    96b0:	681c      	ldr	r4, [r3, #0]
    96b2:	f014 0401 	ands.w	r4, r4, #1
    96b6:	d000      	beq.n	96ba <am_bsp_debug_printf_disable+0xe>
    96b8:	bd10      	pop	{r4, pc}
    {
        return;
    }
    am_hal_itm_not_busy();
    96ba:	f000 f92b 	bl	9914 <am_hal_itm_not_busy>
    am_hal_gpio_pin_config(AM_BSP_GPIO_ITM_SWO, AM_HAL_GPIO_OUTPUT);
    96be:	4a0c      	ldr	r2, [pc, #48]	; (96f0 <am_bsp_debug_printf_disable+0x44>)
    96c0:	480c      	ldr	r0, [pc, #48]	; (96f4 <am_bsp_debug_printf_disable+0x48>)
    96c2:	490d      	ldr	r1, [pc, #52]	; (96f8 <am_bsp_debug_printf_disable+0x4c>)
    96c4:	2373      	movs	r3, #115	; 0x73
    96c6:	6013      	str	r3, [r2, #0]
    96c8:	6803      	ldr	r3, [r0, #0]
    96ca:	f023 0c70 	bic.w	ip, r3, #112	; 0x70
    96ce:	f04c 0320 	orr.w	r3, ip, #32
    96d2:	6003      	str	r3, [r0, #0]
    96d4:	6808      	ldr	r0, [r1, #0]
    96d6:	f420 4c7f 	bic.w	ip, r0, #65280	; 0xff00
    96da:	f44c 53c0 	orr.w	r3, ip, #6144	; 0x1800
    96de:	600b      	str	r3, [r1, #0]
    96e0:	6014      	str	r4, [r2, #0]
    am_hal_tpiu_disable();
}
    96e2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    am_hal_tpiu_disable();
    96e6:	f000 ba0f 	b.w	9b08 <am_hal_tpiu_disable>
    96ea:	bf00      	nop
    96ec:	1000113c 	.word	0x1000113c
    96f0:	40010060 	.word	0x40010060
    96f4:	40010054 	.word	0x40010054
    96f8:	40010028 	.word	0x40010028

000096fc <am_bsp_itm_string_print>:
//
//*****************************************************************************
void
am_bsp_itm_string_print(char *pcString)
{
    am_hal_itm_print(pcString);
    96fc:	f000 b920 	b.w	9940 <am_hal_itm_print>

00009700 <am_hal_clkgen_sysclk_select>:
am_hal_clkgen_sysclk_select(uint32_t ui32ClockSetting)
{
    //
    // Unlock the clock control register.
    //
    AM_REG(CLKGEN, CLKKEY) = AM_REG_CLKGEN_CLKKEY_KEYVAL;
    9700:	4b05      	ldr	r3, [pc, #20]	; (9718 <am_hal_clkgen_sysclk_select+0x18>)

    //
    // Set the HFRC divisor to the user-selected value.
    //
    AM_REG(CLKGEN, CCTRL) = ui32ClockSetting;
    9702:	4906      	ldr	r1, [pc, #24]	; (971c <am_hal_clkgen_sysclk_select+0x1c>)
{
    9704:	b410      	push	{r4}

    //
    // Lock the clock configuration registers.
    //
    AM_REG(CLKGEN, CLKKEY) = 0;
    9706:	2200      	movs	r2, #0
    AM_REG(CLKGEN, CLKKEY) = AM_REG_CLKGEN_CLKKEY_KEYVAL;
    9708:	2447      	movs	r4, #71	; 0x47
    970a:	601c      	str	r4, [r3, #0]
    AM_REG(CLKGEN, CCTRL) = ui32ClockSetting;
    970c:	6008      	str	r0, [r1, #0]
}
    970e:	f85d 4b04 	ldr.w	r4, [sp], #4
    AM_REG(CLKGEN, CLKKEY) = 0;
    9712:	601a      	str	r2, [r3, #0]
}
    9714:	4770      	bx	lr
    9716:	bf00      	nop
    9718:	40004014 	.word	0x40004014
    971c:	40004018 	.word	0x40004018

00009720 <am_hal_clkgen_sysclk_get>:
    uint32_t ui32ClockSetting;

    //
    // Read the value of the clock divider.
    //
    ui32ClockSetting = AM_BFR(CLKGEN, CCTRL, CORESEL);
    9720:	4b03      	ldr	r3, [pc, #12]	; (9730 <am_hal_clkgen_sysclk_get+0x10>)
    9722:	4a04      	ldr	r2, [pc, #16]	; (9734 <am_hal_clkgen_sysclk_get+0x14>)
    9724:	6818      	ldr	r0, [r3, #0]
    9726:	f000 0107 	and.w	r1, r0, #7
        case AM_HAL_CLKGEN_SYSCLK_3MHZ:
            return 3000000;
        default:
            return 0xFFFFFFFF;
    }
}
    972a:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
    972e:	4770      	bx	lr
    9730:	40004018 	.word	0x40004018
    9734:	00009b4c 	.word	0x00009b4c

00009738 <am_hal_clkgen_osc_start>:
//
//*****************************************************************************
void
am_hal_clkgen_osc_start(uint32_t ui32OscFlags)
{
    if ( ui32OscFlags & (AM_HAL_CLKGEN_OSC_LFRC | AM_HAL_CLKGEN_OSC_XT) )
    9738:	0783      	lsls	r3, r0, #30
    973a:	d004      	beq.n	9746 <am_hal_clkgen_osc_start+0xe>
    {
        //
        // Start the oscillator(s).
        // Note that these bits are cleared in order to enable the oscillator.
        //
        AM_REG(CLKGEN, OCTRL) &= ~ui32OscFlags;
    973c:	4a02      	ldr	r2, [pc, #8]	; (9748 <am_hal_clkgen_osc_start+0x10>)
    973e:	6813      	ldr	r3, [r2, #0]
    9740:	ea23 0000 	bic.w	r0, r3, r0
    9744:	6010      	str	r0, [r2, #0]
    9746:	4770      	bx	lr
    9748:	4000400c 	.word	0x4000400c

0000974c <am_hal_clkgen_osc_stop>:
//
//*****************************************************************************
void
am_hal_clkgen_osc_stop(uint32_t ui32OscFlags)
{
    if ( ui32OscFlags & (AM_HAL_CLKGEN_OSC_LFRC | AM_HAL_CLKGEN_OSC_XT) )
    974c:	0783      	lsls	r3, r0, #30
    974e:	d003      	beq.n	9758 <am_hal_clkgen_osc_stop+0xc>
    {
        //
        // Stop the oscillator(s).
        // Note that these bits are set in order to stop the oscillator.
        //
        AM_REG(CLKGEN, OCTRL) |= ui32OscFlags;
    9750:	4b02      	ldr	r3, [pc, #8]	; (975c <am_hal_clkgen_osc_stop+0x10>)
    9752:	681a      	ldr	r2, [r3, #0]
    9754:	4310      	orrs	r0, r2
    9756:	6018      	str	r0, [r3, #0]
    9758:	4770      	bx	lr
    975a:	bf00      	nop
    975c:	4000400c 	.word	0x4000400c

00009760 <am_hal_ctimer_config>:
                     (psConfig->ui32TimerBConfig << 16));

    //
    // OR in the Link bit if the timers need to be linked.
    //
    ui32ConfigVal |= psConfig->ui32Link ? AM_HAL_CTIMER_LINK : 0;
    9760:	680b      	ldr	r3, [r1, #0]
    ui32ConfigVal = (psConfig->ui32TimerAConfig |
    9762:	684a      	ldr	r2, [r1, #4]
{
    9764:	b410      	push	{r4}
                     (psConfig->ui32TimerBConfig << 16));
    9766:	688c      	ldr	r4, [r1, #8]

    //
    // Find the correct register to write.
    //
    pui32ConfigReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
    9768:	4907      	ldr	r1, [pc, #28]	; (9788 <am_hal_ctimer_config+0x28>)
    ui32ConfigVal |= psConfig->ui32Link ? AM_HAL_CTIMER_LINK : 0;
    976a:	2b00      	cmp	r3, #0
    ui32ConfigVal = (psConfig->ui32TimerAConfig |
    976c:	ea42 4404 	orr.w	r4, r2, r4, lsl #16
                                  (ui32TimerNumber * TIMER_OFFSET));
    9770:	ea4f 1000 	mov.w	r0, r0, lsl #4
    ui32ConfigVal |= psConfig->ui32Link ? AM_HAL_CTIMER_LINK : 0;
    9774:	bf14      	ite	ne
    9776:	f04f 4300 	movne.w	r3, #2147483648	; 0x80000000
    977a:	2300      	moveq	r3, #0
    977c:	4323      	orrs	r3, r4

    //
    // Write our configuration value.
    //
    AM_REGVAL(pui32ConfigReg) = ui32ConfigVal;
    977e:	5043      	str	r3, [r0, r1]
}
    9780:	f85d 4b04 	ldr.w	r4, [sp], #4
    9784:	4770      	bx	lr
    9786:	bf00      	nop
    9788:	4000800c 	.word	0x4000800c

0000978c <am_hal_ctimer_start>:

    //
    // Find the correct control register.
    //
    pui32ConfigReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
                                  (ui32TimerNumber * TIMER_OFFSET));
    978c:	0100      	lsls	r0, r0, #4
    pui32ConfigReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
    978e:	4a07      	ldr	r2, [pc, #28]	; (97ac <am_hal_ctimer_start+0x20>)

    //
    // Read the current value.
    //
    ui32ConfigVal = *pui32ConfigReg;
    9790:	5883      	ldr	r3, [r0, r2]
{
    9792:	b410      	push	{r4}

    //
    // Clear out the "clear" bit.
    //
    ui32ConfigVal &= ~(ui32TimerSegment & (AM_REG_CTIMER_CTRL0_TMRA0CLR_M |
    9794:	f001 2408 	and.w	r4, r1, #134219776	; 0x8000800
    9798:	ea23 0304 	bic.w	r3, r3, r4
                                           AM_REG_CTIMER_CTRL0_TMRB0CLR_M));

    //
    // Set the "enable bit"
    //
    ui32ConfigVal |= (ui32TimerSegment & (AM_REG_CTIMER_CTRL0_TMRA0EN_M |
    979c:	f001 1101 	and.w	r1, r1, #65537	; 0x10001
    97a0:	4319      	orrs	r1, r3
                                          AM_REG_CTIMER_CTRL0_TMRB0EN_M));

    //
    // Write the value back to the register.
    //
    AM_REGVAL(pui32ConfigReg) = ui32ConfigVal;
    97a2:	5081      	str	r1, [r0, r2]
}
    97a4:	f85d 4b04 	ldr.w	r4, [sp], #4
    97a8:	4770      	bx	lr
    97aa:	bf00      	nop
    97ac:	4000800c 	.word	0x4000800c

000097b0 <am_hal_ctimer_clear>:

    //
    // Find the correct control register.
    //
    pui32ConfigReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
                                  (ui32TimerNumber * TIMER_OFFSET));
    97b0:	0100      	lsls	r0, r0, #4
    pui32ConfigReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
    97b2:	4b03      	ldr	r3, [pc, #12]	; (97c0 <am_hal_ctimer_clear+0x10>)

    //
    // Set the "clear" bit
    //
    AM_REGVAL(pui32ConfigReg) |= (ui32TimerSegment &
    97b4:	58c2      	ldr	r2, [r0, r3]
    97b6:	f001 2108 	and.w	r1, r1, #134219776	; 0x8000800
    97ba:	4311      	orrs	r1, r2
    97bc:	50c1      	str	r1, [r0, r3]
    97be:	4770      	bx	lr
    97c0:	4000800c 	.word	0x4000800c

000097c4 <am_hal_ctimer_period_set>:
//
//*****************************************************************************
void
am_hal_ctimer_period_set(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment,
                         uint32_t ui32Period, uint32_t ui32OnTime)
{
    97c4:	b5f0      	push	{r4, r5, r6, r7, lr}
    //
    // Find the correct control register to pull the function select field
    // from.
    //
    pui32ControlReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
                                   (ui32TimerNumber * TIMER_OFFSET));
    97c6:	0100      	lsls	r0, r0, #4
    pui32ControlReg = (uint32_t *)(AM_REG_CTIMERn(0) + AM_REG_CTIMER_CTRL0_O +
    97c8:	4c19      	ldr	r4, [pc, #100]	; (9830 <am_hal_ctimer_period_set+0x6c>)
    //
    // Extract the timer mode from the register based on the ui32TimerSegment
    // selected by the user.
    //
    ui32Mode = *pui32ControlReg;
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
    97ca:	f511 3f80 	cmn.w	r1, #65536	; 0x10000
    ui32Mode = *pui32ControlReg;
    97ce:	5905      	ldr	r5, [r0, r4]
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
    97d0:	d018      	beq.n	9804 <am_hal_ctimer_period_set+0x40>

    //
    // If the mode is a PWM mode, we'll need to calculate the correct CMPR0 and
    // CMPR1 values here.
    //
    if (ui32Mode == AM_HAL_CTIMER_FN_PWM_ONCE   ||
    97d2:	f405 76c0 	and.w	r6, r5, #384	; 0x180
    97d6:	2e80      	cmp	r6, #128	; 0x80
    97d8:	d019      	beq.n	980e <am_hal_ctimer_period_set+0x4a>
    97da:	2500      	movs	r5, #0
        ui32Comp1 = ui32Period;
    }
    else
    {
        ui32Comp0 = ui32Period;
        ui32Comp1 = 0;
    97dc:	462c      	mov	r4, r5
    pui32CompareRegA = (uint32_t *)(AM_REG_CTIMERn(0) +
                                    AM_REG_CTIMER_CMPRA0_O +
                                    (ui32TimerNumber * TIMER_OFFSET));

    pui32CompareRegB = (uint32_t *)(AM_REG_CTIMERn(0) +
                                    AM_REG_CTIMER_CMPRB0_O +
    97de:	4e15      	ldr	r6, [pc, #84]	; (9834 <am_hal_ctimer_period_set+0x70>)
                                    AM_REG_CTIMER_CMPRA0_O +
    97e0:	4f15      	ldr	r7, [pc, #84]	; (9838 <am_hal_ctimer_period_set+0x74>)

    //
    // Based on the timer segment argument, write the calculated Compare 0 and
    // Compare 1 values to the correct halves of the correct registers.
    //
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERA )
    97e2:	f64f 73ff 	movw	r3, #65535	; 0xffff
    97e6:	4299      	cmp	r1, r3
                                    AM_REG_CTIMER_CMPRB0_O +
    97e8:	eb00 0e06 	add.w	lr, r0, r6
    if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERA )
    97ec:	d01c      	beq.n	9828 <am_hal_ctimer_period_set+0x64>
        // For timer A, write the values to the TIMERA compare register.
        //
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
                             AM_REG_CTIMER_CMPRA0_CMPR1A0(ui32Comp1));
    }
    else if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
    97ee:	4b13      	ldr	r3, [pc, #76]	; (983c <am_hal_ctimer_period_set+0x78>)
    97f0:	4299      	cmp	r1, r3
    97f2:	d014      	beq.n	981e <am_hal_ctimer_period_set+0x5a>
        //
        // For the linked case, write the lower halves of the values to the
        // TIMERA compare register, and the upper halves to the TIMERB compare
        // register.
        //
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
    97f4:	b291      	uxth	r1, r2
                             AM_REG_CTIMER_CMPRA0_CMPR1A0(ui32Comp1));

        *pui32CompareRegB = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0 >> 16) |
                             AM_REG_CTIMER_CMPRA0_CMPR1A0(ui32Comp1 >> 16));
    97f6:	401c      	ands	r4, r3
        *pui32CompareRegB = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0 >> 16) |
    97f8:	ea44 4212 	orr.w	r2, r4, r2, lsr #16
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
    97fc:	430d      	orrs	r5, r1
    97fe:	51c5      	str	r5, [r0, r7]
        *pui32CompareRegB = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0 >> 16) |
    9800:	5182      	str	r2, [r0, r6]
    }
}
    9802:	bdf0      	pop	{r4, r5, r6, r7, pc}
        ui32Mode = ui32Mode >> 16;
    9804:	0c2f      	lsrs	r7, r5, #16
    if (ui32Mode == AM_HAL_CTIMER_FN_PWM_ONCE   ||
    9806:	f407 75c0 	and.w	r5, r7, #384	; 0x180
    980a:	2d80      	cmp	r5, #128	; 0x80
    980c:	d103      	bne.n	9816 <am_hal_ctimer_period_set+0x52>
    980e:	0415      	lsls	r5, r2, #16
        ui32Comp1 = ui32Period;
    9810:	4614      	mov	r4, r2
        ui32Comp0 = ui32Period - ui32OnTime;
    9812:	1ad2      	subs	r2, r2, r3
        ui32Comp1 = ui32Period;
    9814:	e7e3      	b.n	97de <am_hal_ctimer_period_set+0x1a>
                                    AM_REG_CTIMER_CMPRB0_O +
    9816:	f8df e01c 	ldr.w	lr, [pc, #28]	; 9834 <am_hal_ctimer_period_set+0x70>
    pui32CompareRegB = (uint32_t *)(AM_REG_CTIMERn(0) +
    981a:	2500      	movs	r5, #0
                                    AM_REG_CTIMER_CMPRB0_O +
    981c:	4486      	add	lr, r0
        *pui32CompareRegB = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
    981e:	b290      	uxth	r0, r2
    9820:	4305      	orrs	r5, r0
    9822:	f8ce 5000 	str.w	r5, [lr]
    9826:	bdf0      	pop	{r4, r5, r6, r7, pc}
        *pui32CompareRegA = (AM_REG_CTIMER_CMPRA0_CMPR0A0(ui32Comp0) |
    9828:	b294      	uxth	r4, r2
    982a:	4325      	orrs	r5, r4
    982c:	51c5      	str	r5, [r0, r7]
    982e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9830:	4000800c 	.word	0x4000800c
    9834:	40008008 	.word	0x40008008
    9838:	40008004 	.word	0x40008004
    983c:	ffff0000 	.word	0xffff0000

00009840 <am_hal_ctimer_int_enable>:
am_hal_ctimer_int_enable(uint32_t ui32Interrupt)
{
    //
    // Enable the interrupt at the module level.
    //
    AM_REGn(CTIMER, 0, INTEN) |= ui32Interrupt;
    9840:	4a02      	ldr	r2, [pc, #8]	; (984c <am_hal_ctimer_int_enable+0xc>)
    9842:	6813      	ldr	r3, [r2, #0]
    9844:	4318      	orrs	r0, r3
    9846:	6010      	str	r0, [r2, #0]
    9848:	4770      	bx	lr
    984a:	bf00      	nop
    984c:	40008200 	.word	0x40008200

00009850 <am_hal_ctimer_int_clear>:
am_hal_ctimer_int_clear(uint32_t ui32Interrupt)
{
    //
    // Disable the interrupt at the module level.
    //
    AM_REGn(CTIMER, 0, INTCLR) = ui32Interrupt;
    9850:	4b01      	ldr	r3, [pc, #4]	; (9858 <am_hal_ctimer_int_clear+0x8>)
    9852:	6018      	str	r0, [r3, #0]
    9854:	4770      	bx	lr
    9856:	bf00      	nop
    9858:	40008208 	.word	0x40008208

0000985c <am_hal_flash_delay>:
}
#elif defined(__GNUC_STDC_INLINE__)
void __attribute__((naked))
am_hal_flash_delay(uint32_t ui32Iterations)
{
    __asm("    subs    r0, #1\n"
    985c:	3801      	subs	r0, #1
    985e:	f47f affd 	bne.w	985c <am_hal_flash_delay>
    9862:	4770      	bx	lr

00009864 <am_hal_interrupt_enable>:
am_hal_interrupt_enable(uint32_t ui32Interrupt)
{
    //
    // Check to see what type of interrupt this is.
    //
    if ( ui32Interrupt > 15 )
    9864:	280f      	cmp	r0, #15
    9866:	d80b      	bhi.n	9880 <am_hal_interrupt_enable+0x1c>
    {
        //
        // If this is an ARM internal interrupt number, route it to the
        // appropriate enable register.
        //
        switch(ui32Interrupt)
    9868:	2805      	cmp	r0, #5
    986a:	d013      	beq.n	9894 <am_hal_interrupt_enable+0x30>
    986c:	2806      	cmp	r0, #6
    986e:	d017      	beq.n	98a0 <am_hal_interrupt_enable+0x3c>
    9870:	2804      	cmp	r0, #4
    9872:	d104      	bne.n	987e <am_hal_interrupt_enable+0x1a>
            case AM_HAL_INTERRUPT_USAGEFAULT:
                AM_BFW(SYSCTRL, SHCSR, USAGEFAULTENA, 1);
            break;

            case AM_HAL_INTERRUPT_MPUFAULT:
                AM_BFW(SYSCTRL, SHCSR, MEMFAULTENA, 1);
    9874:	4a0d      	ldr	r2, [pc, #52]	; (98ac <am_hal_interrupt_enable+0x48>)
    9876:	6813      	ldr	r3, [r2, #0]
    9878:	f443 3080 	orr.w	r0, r3, #65536	; 0x10000
    987c:	6010      	str	r0, [r2, #0]
    987e:	4770      	bx	lr
        AM_REG(NVIC, ISER0) = 0x1 << ((ui32Interrupt - 16) & 0x1F);
    9880:	f1a0 0310 	sub.w	r3, r0, #16
    9884:	f003 0c1f 	and.w	ip, r3, #31
    9888:	2001      	movs	r0, #1
    988a:	4909      	ldr	r1, [pc, #36]	; (98b0 <am_hal_interrupt_enable+0x4c>)
    988c:	fa00 f20c 	lsl.w	r2, r0, ip
    9890:	600a      	str	r2, [r1, #0]
    9892:	4770      	bx	lr
                AM_BFW(SYSCTRL, SHCSR, BUSFAULTENA, 1);
    9894:	4805      	ldr	r0, [pc, #20]	; (98ac <am_hal_interrupt_enable+0x48>)
    9896:	6801      	ldr	r1, [r0, #0]
    9898:	f441 3200 	orr.w	r2, r1, #131072	; 0x20000
    989c:	6002      	str	r2, [r0, #0]
            break;
    989e:	4770      	bx	lr
                AM_BFW(SYSCTRL, SHCSR, USAGEFAULTENA, 1);
    98a0:	4902      	ldr	r1, [pc, #8]	; (98ac <am_hal_interrupt_enable+0x48>)
    98a2:	680a      	ldr	r2, [r1, #0]
    98a4:	f442 2380 	orr.w	r3, r2, #262144	; 0x40000
    98a8:	600b      	str	r3, [r1, #0]
            break;
    98aa:	4770      	bx	lr
    98ac:	e000ed24 	.word	0xe000ed24
    98b0:	e000e100 	.word	0xe000e100

000098b4 <am_hal_interrupt_master_enable>:
}
#elif defined(__GNUC_STDC_INLINE__)
uint32_t __attribute__((naked))
am_hal_interrupt_master_enable(void)
{
    __asm("    mrs     r0, PRIMASK");
    98b4:	f3ef 8010 	mrs	r0, PRIMASK
    __asm("    cpsie i");
    98b8:	b662      	cpsie	i
    __asm("    bx lr");
    98ba:	4770      	bx	lr

000098bc <am_hal_itm_enable>:
//
//*****************************************************************************
void
am_hal_itm_enable(void)
{
    if (g_ui32HALflags & AM_HAL_FLAGS_ITMSKIPENABLEDISABLE_M)
    98bc:	4b0d      	ldr	r3, [pc, #52]	; (98f4 <am_hal_itm_enable+0x38>)
    98be:	6818      	ldr	r0, [r3, #0]
    98c0:	07c2      	lsls	r2, r0, #31
    98c2:	d416      	bmi.n	98f2 <am_hal_itm_enable+0x36>

    //
    // To be able to access ITM registers, set the Trace Enable bit
    // in the Debug Exception and Monitor Control Register (DEMCR).
    //
    AM_REG(SYSCTRL, DEMCR) |= AM_REG_SYSCTRL_DEMCR_TRCENA(1);
    98c4:	4a0c      	ldr	r2, [pc, #48]	; (98f8 <am_hal_itm_enable+0x3c>)
    98c6:	6811      	ldr	r1, [r2, #0]
{
    98c8:	b430      	push	{r4, r5}
    AM_REG(SYSCTRL, DEMCR) |= AM_REG_SYSCTRL_DEMCR_TRCENA(1);
    98ca:	f041 7480 	orr.w	r4, r1, #16777216	; 0x1000000
    98ce:	6014      	str	r4, [r2, #0]
    while ( !(AM_REG(SYSCTRL, DEMCR) & AM_REG_SYSCTRL_DEMCR_TRCENA(1)) );
    98d0:	6815      	ldr	r5, [r2, #0]
    98d2:	01eb      	lsls	r3, r5, #7
    98d4:	d5fc      	bpl.n	98d0 <am_hal_itm_enable+0x14>

    //
    // Write the key to the ITM Lock Access register to unlock the ITM_TCR.
    //
    AM_REGVAL(AM_REG_ITM_LOCKAREG_O) = AM_REG_ITM_LOCKAREG_KEYVAL;
    98d6:	4809      	ldr	r0, [pc, #36]	; (98fc <am_hal_itm_enable+0x40>)

    //
    // Set the enable bits in the ITM trace enable register, and the ITM
    // control registers to enable trace data output.
    //
    AM_REGVAL(AM_REG_ITM_TPR_O) = 0x0000000f;
    98d8:	4c09      	ldr	r4, [pc, #36]	; (9900 <am_hal_itm_enable+0x44>)
    AM_REGVAL(AM_REG_ITM_LOCKAREG_O) = AM_REG_ITM_LOCKAREG_KEYVAL;
    98da:	4d0a      	ldr	r5, [pc, #40]	; (9904 <am_hal_itm_enable+0x48>)
    98dc:	6005      	str	r5, [r0, #0]
    AM_REGVAL(AM_REG_ITM_TPR_O) = 0x0000000f;
    98de:	250f      	movs	r5, #15
    98e0:	6025      	str	r5, [r4, #0]
        AM_WRITE_SM(AM_REG_ITM_TCR_DWT_ENABLE, 0)     |
        AM_WRITE_SM(AM_REG_ITM_TCR_SYNC_ENABLE, 0)    |
        AM_WRITE_SM(AM_REG_ITM_TCR_TS_ENABLE, 0)      |
        AM_WRITE_SM(AM_REG_ITM_TCR_ITM_ENABLE, 1);

}
    98e2:	bc30      	pop	{r4, r5}
    AM_REGVAL(AM_REG_ITM_TER_O) = 0xffffffff;
    98e4:	4908      	ldr	r1, [pc, #32]	; (9908 <am_hal_itm_enable+0x4c>)
    AM_REGVAL(AM_REG_ITM_TCR_O) =
    98e6:	4b09      	ldr	r3, [pc, #36]	; (990c <am_hal_itm_enable+0x50>)
    98e8:	4a09      	ldr	r2, [pc, #36]	; (9910 <am_hal_itm_enable+0x54>)
    AM_REGVAL(AM_REG_ITM_TER_O) = 0xffffffff;
    98ea:	f04f 30ff 	mov.w	r0, #4294967295
    98ee:	6008      	str	r0, [r1, #0]
    AM_REGVAL(AM_REG_ITM_TCR_O) =
    98f0:	601a      	str	r2, [r3, #0]
}
    98f2:	4770      	bx	lr
    98f4:	1000113c 	.word	0x1000113c
    98f8:	e000edfc 	.word	0xe000edfc
    98fc:	e0000fb0 	.word	0xe0000fb0
    9900:	e0000e40 	.word	0xe0000e40
    9904:	c5acce55 	.word	0xc5acce55
    9908:	e0000e00 	.word	0xe0000e00
    990c:	e0000e80 	.word	0xe0000e80
    9910:	00150511 	.word	0x00150511

00009914 <am_hal_itm_not_busy>:
//! @return None.
//
//*****************************************************************************
void
am_hal_itm_not_busy(void)
{
    9914:	b508      	push	{r3, lr}
    //
    // Make sure the ITM/TPIU is not busy.
    //
    while (AM_REG(ITM, TCR) & AM_REG_ITM_TCR_BUSY(1));
    9916:	4a08      	ldr	r2, [pc, #32]	; (9938 <am_hal_itm_not_busy+0x24>)
    9918:	6813      	ldr	r3, [r2, #0]
    991a:	021b      	lsls	r3, r3, #8
    991c:	d4fc      	bmi.n	9918 <am_hal_itm_not_busy+0x4>

    // wait for 50us for the data to flush out
    am_hal_flash_delay(FLASH_CYCLES_US(50));
    991e:	f7ff feff 	bl	9720 <am_hal_clkgen_sysclk_get>
    9922:	4906      	ldr	r1, [pc, #24]	; (993c <am_hal_itm_not_busy+0x28>)
    9924:	fba1 3000 	umull	r3, r0, r1, r0
    9928:	0c80      	lsrs	r0, r0, #18
    992a:	2232      	movs	r2, #50	; 0x32
    992c:	fb02 f000 	mul.w	r0, r2, r0
}
    9930:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    am_hal_flash_delay(FLASH_CYCLES_US(50));
    9934:	f7ff bf92 	b.w	985c <am_hal_flash_delay>
    9938:	e0000e80 	.word	0xe0000e80
    993c:	165e9f81 	.word	0x165e9f81

00009940 <am_hal_itm_print>:
    uint32_t ui32Idx;

    //
    // Determine the length of the string.
    //
    while (*(pcString + ui32Length))
    9940:	7803      	ldrb	r3, [r0, #0]
    9942:	b1b3      	cbz	r3, 9972 <am_hal_itm_print+0x32>
{
    9944:	b410      	push	{r4}
    9946:	4602      	mov	r2, r0
    while (*(pcString + ui32Length))
    9948:	2400      	movs	r4, #0
    994a:	f812 1f01 	ldrb.w	r1, [r2, #1]!
    {
        ui32Length++;
    994e:	3401      	adds	r4, #1
    while (*(pcString + ui32Length))
    9950:	2900      	cmp	r1, #0
    9952:	d1fa      	bne.n	994a <am_hal_itm_print+0xa>
    9954:	1901      	adds	r1, r0, r4
    while (!AM_REGVAL(ui32StimAddr));
    9956:	f04f 4c60 	mov.w	ip, #3758096384	; 0xe0000000
        else
        {
            //
            // Print string out the ITM.
            //
            am_hal_itm_stimulus_reg_byte_write(0, (uint8_t)*pcString++);
    995a:	f810 2b01 	ldrb.w	r2, [r0], #1
    while (!AM_REGVAL(ui32StimAddr));
    995e:	f8dc 3000 	ldr.w	r3, [ip]
    9962:	2b00      	cmp	r3, #0
    9964:	d0fb      	beq.n	995e <am_hal_itm_print+0x1e>
    while (ui32Length)
    9966:	4288      	cmp	r0, r1
    *((volatile uint8_t *) ui32StimAddr) = ui8Value;
    9968:	f88c 2000 	strb.w	r2, [ip]
    while (ui32Length)
    996c:	d1f5      	bne.n	995a <am_hal_itm_print+0x1a>
            // Subtract from length.
            //
            ui32Length--;
        }
    }
}
    996e:	f85d 4b04 	ldr.w	r4, [sp], #4
    9972:	4770      	bx	lr

00009974 <am_hal_mcuctrl_fault_status>:
    psFault->bSYS = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_SYS_M);

    //
    // Read the DCODE fault capture address register.
    //
    psFault->ui32DCODE = AM_REG(MCUCTRL, DCODEFAULTADDR);
    9974:	490d      	ldr	r1, [pc, #52]	; (99ac <am_hal_mcuctrl_fault_status+0x38>)
    ui32FaultStat = AM_REG(MCUCTRL, FAULTSTATUS);
    9976:	4b0e      	ldr	r3, [pc, #56]	; (99b0 <am_hal_mcuctrl_fault_status+0x3c>)

    //
    // Read the ICODE fault capture address register.
    //
    psFault->ui32ICODE |= AM_REG(MCUCTRL, ICODEFAULTADDR);
    9978:	4a0e      	ldr	r2, [pc, #56]	; (99b4 <am_hal_mcuctrl_fault_status+0x40>)
    ui32FaultStat = AM_REG(MCUCTRL, FAULTSTATUS);
    997a:	681b      	ldr	r3, [r3, #0]
{
    997c:	b470      	push	{r4, r5, r6}
    psFault->ui32DCODE = AM_REG(MCUCTRL, DCODEFAULTADDR);
    997e:	680d      	ldr	r5, [r1, #0]
    9980:	60c5      	str	r5, [r0, #12]
    psFault->ui32ICODE |= AM_REG(MCUCTRL, ICODEFAULTADDR);
    9982:	6815      	ldr	r5, [r2, #0]
    9984:	6841      	ldr	r1, [r0, #4]

    //
    // Read the ICODE fault capture address register.
    //
    psFault->ui32SYS |= AM_REG(MCUCTRL, SYSFAULTADDR);
    9986:	4c0c      	ldr	r4, [pc, #48]	; (99b8 <am_hal_mcuctrl_fault_status+0x44>)
    9988:	6942      	ldr	r2, [r0, #20]
    psFault->ui32ICODE |= AM_REG(MCUCTRL, ICODEFAULTADDR);
    998a:	4329      	orrs	r1, r5
    998c:	6041      	str	r1, [r0, #4]
    psFault->ui32SYS |= AM_REG(MCUCTRL, SYSFAULTADDR);
    998e:	6824      	ldr	r4, [r4, #0]
    psFault->bICODE = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_ICODE_M);
    9990:	f003 0601 	and.w	r6, r3, #1
    psFault->ui32SYS |= AM_REG(MCUCTRL, SYSFAULTADDR);
    9994:	4322      	orrs	r2, r4
    psFault->bICODE = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_ICODE_M);
    9996:	7006      	strb	r6, [r0, #0]
    psFault->bDCODE = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_DCODE_M);
    9998:	f3c3 0640 	ubfx	r6, r3, #1, #1
    psFault->bSYS = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_SYS_M);
    999c:	f3c3 0380 	ubfx	r3, r3, #2, #1
    psFault->bDCODE = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_DCODE_M);
    99a0:	7206      	strb	r6, [r0, #8]
    psFault->bSYS = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_SYS_M);
    99a2:	7403      	strb	r3, [r0, #16]
    psFault->ui32SYS |= AM_REG(MCUCTRL, SYSFAULTADDR);
    99a4:	6142      	str	r2, [r0, #20]
}
    99a6:	bc70      	pop	{r4, r5, r6}
    99a8:	4770      	bx	lr
    99aa:	bf00      	nop
    99ac:	400201c4 	.word	0x400201c4
    99b0:	400201cc 	.word	0x400201cc
    99b4:	400201c0 	.word	0x400201c0
    99b8:	400201c8 	.word	0x400201c8

000099bc <am_hal_mcuctrl_bandgap_disable>:
am_hal_mcuctrl_bandgap_disable(void)
{
    //
    // Disable the Bandgap in the MCUCTRL.
    //
    AM_REG(MCUCTRL, BANDGAPEN) = ~AM_REG_MCUCTRL_BANDGAPEN_BGPEN_M;
    99bc:	4b02      	ldr	r3, [pc, #8]	; (99c8 <am_hal_mcuctrl_bandgap_disable+0xc>)
    99be:	f06f 0201 	mvn.w	r2, #1
    99c2:	601a      	str	r2, [r3, #0]
    99c4:	4770      	bx	lr
    99c6:	bf00      	nop
    99c8:	400200fc 	.word	0x400200fc

000099cc <am_hal_mcuctrl_bucks_enable>:
am_hal_mcuctrl_bucks_enable(void)
{
    //
    // Enable the core buck converter in the MCUCTRL.
    //
    AM_BFW(MCUCTRL, SUPPLYSRC, COREBUCKEN, 1);
    99cc:	4b08      	ldr	r3, [pc, #32]	; (99f0 <am_hal_mcuctrl_bucks_enable+0x24>)
    AM_BFW(MCUCTRL, SUPPLYSRC, MEMBUCKEN, 1);

    //
    // Poll until core buck is enabled.
    //
    while( !AM_BFR(MCUCTRL, SUPPLYSTATUS, COREBUCKON) );
    99ce:	4a09      	ldr	r2, [pc, #36]	; (99f4 <am_hal_mcuctrl_bucks_enable+0x28>)
    AM_BFW(MCUCTRL, SUPPLYSRC, COREBUCKEN, 1);
    99d0:	6819      	ldr	r1, [r3, #0]
    99d2:	f041 0002 	orr.w	r0, r1, #2
    99d6:	6018      	str	r0, [r3, #0]
    AM_BFW(MCUCTRL, SUPPLYSRC, MEMBUCKEN, 1);
    99d8:	6819      	ldr	r1, [r3, #0]
    99da:	f041 0001 	orr.w	r0, r1, #1
    99de:	6018      	str	r0, [r3, #0]
    while( !AM_BFR(MCUCTRL, SUPPLYSTATUS, COREBUCKON) );
    99e0:	6813      	ldr	r3, [r2, #0]
    99e2:	0799      	lsls	r1, r3, #30
    99e4:	d5fc      	bpl.n	99e0 <am_hal_mcuctrl_bucks_enable+0x14>

    //
    // Poll until SRAM buck is enabled.
    //
    while( !AM_BFR(MCUCTRL, SUPPLYSTATUS, MEMBUCKON) );
    99e6:	4a03      	ldr	r2, [pc, #12]	; (99f4 <am_hal_mcuctrl_bucks_enable+0x28>)
    99e8:	6811      	ldr	r1, [r2, #0]
    99ea:	07cb      	lsls	r3, r1, #31
    99ec:	d5fc      	bpl.n	99e8 <am_hal_mcuctrl_bucks_enable+0x1c>
}
    99ee:	4770      	bx	lr
    99f0:	40020010 	.word	0x40020010
    99f4:	40020014 	.word	0x40020014

000099f8 <am_hal_rtc_osc_select>:
    // Set XT if flag is set.
    // Otherwise configure for LFRC.
    //
    if (ui32OSC)
    {
        AM_REG(CLKGEN, OCTRL) |= AM_REG_CLKGEN_OCTRL_OSEL_M;
    99f8:	4a05      	ldr	r2, [pc, #20]	; (9a10 <am_hal_rtc_osc_select+0x18>)
    99fa:	6813      	ldr	r3, [r2, #0]
    if (ui32OSC)
    99fc:	b918      	cbnz	r0, 9a06 <am_hal_rtc_osc_select+0xe>
    }
    else
    {
        AM_REG(CLKGEN, OCTRL) &= ~AM_REG_CLKGEN_OCTRL_OSEL_M;
    99fe:	f023 0080 	bic.w	r0, r3, #128	; 0x80
    9a02:	6010      	str	r0, [r2, #0]
    9a04:	4770      	bx	lr
        AM_REG(CLKGEN, OCTRL) |= AM_REG_CLKGEN_OCTRL_OSEL_M;
    9a06:	f043 0180 	orr.w	r1, r3, #128	; 0x80
    9a0a:	6011      	str	r1, [r2, #0]
    9a0c:	4770      	bx	lr
    9a0e:	bf00      	nop
    9a10:	4000400c 	.word	0x4000400c

00009a14 <am_hal_rtc_osc_disable>:
am_hal_rtc_osc_disable(void)
{
    //
    // Stop the RTC Oscillator.
    //
    AM_BFW(RTC, RTCCTL, RSTOP, 1);
    9a14:	4a02      	ldr	r2, [pc, #8]	; (9a20 <am_hal_rtc_osc_disable+0xc>)
    9a16:	6813      	ldr	r3, [r2, #0]
    9a18:	f043 0010 	orr.w	r0, r3, #16
    9a1c:	6010      	str	r0, [r2, #0]
    9a1e:	4770      	bx	lr
    9a20:	40004050 	.word	0x40004050

00009a24 <am_hal_sysctrl_sleep>:
        (AM_BFM(MCUCTRL, TPIUCTRL, ENABLE) == AM_REG_MCUCTRL_TPIUCTRL_ENABLE_DIS))
    {
        //
        // Prepare the core for deepsleep (write 1 to the DEEPSLEEP bit).
        //
        AM_BFW(SYSCTRL, SCR, SLEEPDEEP, 1);
    9a24:	4a08      	ldr	r2, [pc, #32]	; (9a48 <am_hal_sysctrl_sleep+0x24>)
    if ((bSleepDeep == AM_HAL_SYSCTRL_SLEEP_DEEP) &&
    9a26:	b118      	cbz	r0, 9a30 <am_hal_sysctrl_sleep+0xc>
        (AM_BFM(MCUCTRL, TPIUCTRL, ENABLE) == AM_REG_MCUCTRL_TPIUCTRL_ENABLE_DIS))
    9a28:	4b08      	ldr	r3, [pc, #32]	; (9a4c <am_hal_sysctrl_sleep+0x28>)
    9a2a:	6818      	ldr	r0, [r3, #0]
    if ((bSleepDeep == AM_HAL_SYSCTRL_SLEEP_DEEP) &&
    9a2c:	07c3      	lsls	r3, r0, #31
    9a2e:	d505      	bpl.n	9a3c <am_hal_sysctrl_sleep+0x18>
    }
    else
    {
        AM_BFW(SYSCTRL, SCR, SLEEPDEEP, 0);
    9a30:	6811      	ldr	r1, [r2, #0]
    9a32:	f021 0304 	bic.w	r3, r1, #4
    9a36:	6013      	str	r3, [r2, #0]
    }

    //
    // Go to sleep.
    //
    AM_ASM_WFI;
    9a38:	bf30      	wfi
    9a3a:	4770      	bx	lr
        AM_BFW(SYSCTRL, SCR, SLEEPDEEP, 1);
    9a3c:	6810      	ldr	r0, [r2, #0]
    9a3e:	f040 0104 	orr.w	r1, r0, #4
    9a42:	6011      	str	r1, [r2, #0]
    AM_ASM_WFI;
    9a44:	bf30      	wfi
    9a46:	4770      	bx	lr
    9a48:	e000ed10 	.word	0xe000ed10
    9a4c:	40020250 	.word	0x40020250

00009a50 <am_hal_tpiu_enable>:
//! @return None.
//
//*****************************************************************************
void
am_hal_tpiu_enable(am_hal_tpiu_config_t *psConfig)
{
    9a50:	b538      	push	{r3, r4, r5, lr}
    ui32ITMbitrate = psConfig->ui32SetItmBaud;

    //
    // TPIU formatter & flush control register.
    //
    AM_REG(TPIU, FFCR) = 0;
    9a52:	4a24      	ldr	r2, [pc, #144]	; (9ae4 <am_hal_tpiu_enable+0x94>)
    ui32ITMbitrate = psConfig->ui32SetItmBaud;
    9a54:	6803      	ldr	r3, [r0, #0]
    AM_REG(TPIU, FFCR) = 0;
    9a56:	2100      	movs	r1, #0
    9a58:	6011      	str	r1, [r2, #0]

    if ( ui32ITMbitrate )
    9a5a:	b313      	cbz	r3, 9aa2 <am_hal_tpiu_enable+0x52>
    {
        //
        // Set the Current Parallel Port Size (note - only 1 bit can be set).
        //
        AM_REG(TPIU, CSPSR) = AM_REG_TPIU_CSPSR_CWIDTH_1BIT;
    9a5c:	f5a2 7c40 	sub.w	ip, r2, #768	; 0x300
    9a60:	2101      	movs	r1, #1

        //
        // Use some default assumptions to set the ITM frequency.
        //
        if ( (ui32ITMbitrate < AM_HAL_TPIU_BAUD_57600 )  ||
    9a62:	4c21      	ldr	r4, [pc, #132]	; (9ae8 <am_hal_tpiu_enable+0x98>)
             (ui32ITMbitrate > AM_HAL_TPIU_BAUD_2M ) )
        {
            ui32ITMbitrate = AM_HAL_TPIU_BAUD_DEFAULT;
    9a64:	4d21      	ldr	r5, [pc, #132]	; (9aec <am_hal_tpiu_enable+0x9c>)
        AM_REG(TPIU, CSPSR) = AM_REG_TPIU_CSPSR_CWIDTH_1BIT;
    9a66:	f8cc 1000 	str.w	r1, [ip]
        if ( (ui32ITMbitrate < AM_HAL_TPIU_BAUD_57600 )  ||
    9a6a:	f5a3 4e61 	sub.w	lr, r3, #57600	; 0xe100
            ui32ITMbitrate = AM_HAL_TPIU_BAUD_DEFAULT;
    9a6e:	45a6      	cmp	lr, r4
    9a70:	bf94      	ite	ls
    9a72:	461c      	movls	r4, r3
    9a74:	462c      	movhi	r4, r5
        }

        //
        // Get the current HFRC frequency.
        //
        ui32HFRC = am_hal_clkgen_sysclk_get();
    9a76:	f7ff fe53 	bl	9720 <am_hal_clkgen_sysclk_get>

        //
        // Compute the SWO scaler value.
        //
        if ( ui32HFRC != 0xFFFFFFFF )
    9a7a:	1c43      	adds	r3, r0, #1
    9a7c:	d02f      	beq.n	9ade <am_hal_tpiu_enable+0x8e>
        {
            ui32SWOscaler = ((ui32HFRC / 8) / ui32ITMbitrate) - 1;
    9a7e:	08c2      	lsrs	r2, r0, #3
    9a80:	fbb2 f3f4 	udiv	r3, r2, r4
    9a84:	1e5d      	subs	r5, r3, #1
    9a86:	b2a8      	uxth	r0, r5
        }

        //
        // Set the scaler value.
        //
        AM_REG(TPIU, ACPR) = AM_REG_TPIU_ACPR_SWOSCALER(ui32SWOscaler);
    9a88:	4a19      	ldr	r2, [pc, #100]	; (9af0 <am_hal_tpiu_enable+0xa0>)

        //
        // Set for UART mode
        //
        AM_REG(TPIU, SPPR) = AM_REG_TPIU_SPPR_TXMODE_UART;
    9a8a:	4c1a      	ldr	r4, [pc, #104]	; (9af4 <am_hal_tpiu_enable+0xa4>)

        //
        // Make sure we are not in test mode (important for proper deep sleep
        // operation).
        //
        AM_REG(TPIU, ITCTRL) = AM_REG_TPIU_ITCTRL_MODE_NORMAL;
    9a8c:	491a      	ldr	r1, [pc, #104]	; (9af8 <am_hal_tpiu_enable+0xa8>)

        //
        // Enable the TPIU clock source in MCU control.
        // Set TPIU clock for HFRC/8 (3 MHz) operation.
        //
        AM_REGn(MCUCTRL, 0, TPIUCTRL) = AM_REG_MCUCTRL_TPIUCTRL_CLKSEL_3MHZ |
    9a8e:	4b1b      	ldr	r3, [pc, #108]	; (9afc <am_hal_tpiu_enable+0xac>)
        AM_REG(TPIU, ACPR) = AM_REG_TPIU_ACPR_SWOSCALER(ui32SWOscaler);
    9a90:	6010      	str	r0, [r2, #0]
        AM_REG(TPIU, SPPR) = AM_REG_TPIU_SPPR_TXMODE_UART;
    9a92:	2502      	movs	r5, #2
        AM_REG(TPIU, ITCTRL) = AM_REG_TPIU_ITCTRL_MODE_NORMAL;
    9a94:	2000      	movs	r0, #0
        AM_REGn(MCUCTRL, 0, TPIUCTRL) = AM_REG_MCUCTRL_TPIUCTRL_CLKSEL_3MHZ |
    9a96:	f240 2201 	movw	r2, #513	; 0x201
        AM_REG(TPIU, SPPR) = AM_REG_TPIU_SPPR_TXMODE_UART;
    9a9a:	6025      	str	r5, [r4, #0]
        AM_REG(TPIU, ITCTRL) = AM_REG_TPIU_ITCTRL_MODE_NORMAL;
    9a9c:	6008      	str	r0, [r1, #0]
        AM_REGn(MCUCTRL, 0, TPIUCTRL) = AM_REG_MCUCTRL_TPIUCTRL_CLKSEL_3MHZ |
    9a9e:	601a      	str	r2, [r3, #0]
    9aa0:	e010      	b.n	9ac4 <am_hal_tpiu_enable+0x74>
        //

        //
        // Set the Asynchronous Clock Prescaler Register.
        //
        AM_REG(TPIU, ACPR) = psConfig->ui32ClockPrescaler;
    9aa2:	4c13      	ldr	r4, [pc, #76]	; (9af0 <am_hal_tpiu_enable+0xa0>)
    9aa4:	6905      	ldr	r5, [r0, #16]
    9aa6:	6025      	str	r5, [r4, #0]

        //
        // Set the Selected Pin Protocol Register.
        //  e.g. AM_REG_TPIU_SPPR_TXMODE_UART
        //
        AM_REG(TPIU, SPPR) = psConfig->ui32PinProtocol;
    9aa8:	6882      	ldr	r2, [r0, #8]
    9aaa:	f8c4 20e0 	str.w	r2, [r4, #224]	; 0xe0
        //
        // Set the Current Parallel Port Size (note - only 1 bit can be set).
        // This may be redundant if the user has selected a serial protocol,
        // but we'll set it anyway.
        //
        AM_REG(TPIU, CSPSR) = (1 << (psConfig->ui32ParallelPortSize - 1));
    9aae:	68c3      	ldr	r3, [r0, #12]
    9ab0:	4c13      	ldr	r4, [pc, #76]	; (9b00 <am_hal_tpiu_enable+0xb0>)

        //
        // Set the clock freq in the MCUCTRL register.
        //
        AM_REG(MCUCTRL, TPIUCTRL) |= psConfig->ui32TraceClkIn;
    9ab2:	4912      	ldr	r1, [pc, #72]	; (9afc <am_hal_tpiu_enable+0xac>)
        AM_REG(TPIU, CSPSR) = (1 << (psConfig->ui32ParallelPortSize - 1));
    9ab4:	1e5d      	subs	r5, r3, #1
    9ab6:	2201      	movs	r2, #1
    9ab8:	40aa      	lsls	r2, r5
    9aba:	6022      	str	r2, [r4, #0]
        AM_REG(MCUCTRL, TPIUCTRL) |= psConfig->ui32TraceClkIn;
    9abc:	6840      	ldr	r0, [r0, #4]
    9abe:	680b      	ldr	r3, [r1, #0]
    9ac0:	4303      	orrs	r3, r0
    9ac2:	600b      	str	r3, [r1, #0]
    }

    // wait for 50us for the data to flush out
    am_hal_flash_delay(FLASH_CYCLES_US(50));
    9ac4:	f7ff fe2c 	bl	9720 <am_hal_clkgen_sysclk_get>
    9ac8:	4c0e      	ldr	r4, [pc, #56]	; (9b04 <am_hal_tpiu_enable+0xb4>)
    9aca:	fba4 3100 	umull	r3, r1, r4, r0
    9ace:	0c88      	lsrs	r0, r1, #18
    9ad0:	2332      	movs	r3, #50	; 0x32
    9ad2:	fb03 f000 	mul.w	r0, r3, r0
}
    9ad6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    am_hal_flash_delay(FLASH_CYCLES_US(50));
    9ada:	f7ff bebf 	b.w	985c <am_hal_flash_delay>
    9ade:	2002      	movs	r0, #2
    9ae0:	e7d2      	b.n	9a88 <am_hal_tpiu_enable+0x38>
    9ae2:	bf00      	nop
    9ae4:	e0040304 	.word	0xe0040304
    9ae8:	001da380 	.word	0x001da380
    9aec:	000f4240 	.word	0x000f4240
    9af0:	e0040010 	.word	0xe0040010
    9af4:	e00400f0 	.word	0xe00400f0
    9af8:	e0040f00 	.word	0xe0040f00
    9afc:	40020250 	.word	0x40020250
    9b00:	e0040004 	.word	0xe0040004
    9b04:	165e9f81 	.word	0x165e9f81

00009b08 <am_hal_tpiu_disable>:
am_hal_tpiu_disable(void)
{
    //
    // Disable the TPIU clock source in MCU control.
    //
    AM_REG(MCUCTRL, TPIUCTRL) = AM_REG_MCUCTRL_TPIUCTRL_CLKSEL_0MHz |
    9b08:	4b01      	ldr	r3, [pc, #4]	; (9b10 <am_hal_tpiu_disable+0x8>)
    9b0a:	2200      	movs	r2, #0
    9b0c:	601a      	str	r2, [r3, #0]
    9b0e:	4770      	bx	lr
    9b10:	40020250 	.word	0x40020250

00009b14 <am_hal_vcomp_disable>:
//
//*****************************************************************************
void
am_hal_vcomp_disable(void)
{
    AM_REG(VCOMP, PWDKEY) = AM_REG_VCOMP_PWDKEY_KEYVAL;
    9b14:	4b01      	ldr	r3, [pc, #4]	; (9b1c <am_hal_vcomp_disable+0x8>)
    9b16:	2237      	movs	r2, #55	; 0x37
    9b18:	601a      	str	r2, [r3, #0]
    9b1a:	4770      	bx	lr
    9b1c:	4000c008 	.word	0x4000c008
    9b20:	616e6942 	.word	0x616e6942
    9b24:	43207972 	.word	0x43207972
    9b28:	746e756f 	.word	0x746e756f
    9b2c:	45207265 	.word	0x45207265
    9b30:	706d6178 	.word	0x706d6178
    9b34:	000a656c 	.word	0x000a656c
    9b38:	0a0a0a0a 	.word	0x0a0a0a0a
    9b3c:	0a0a0a0a 	.word	0x0a0a0a0a
    9b40:	0a0a0a0a 	.word	0x0a0a0a0a
    9b44:	0a0a0a0a 	.word	0x0a0a0a0a
    9b48:	00000a0a 	.word	0x00000a0a

00009b4c <CSWTCH.4>:
    9b4c:	016e3600 00b71b00 007a1200 005b8d80     .6n.......z...[.
    9b5c:	00493e00 003d0900 003450db 002dc6c0     .>I...=..P4...-.
