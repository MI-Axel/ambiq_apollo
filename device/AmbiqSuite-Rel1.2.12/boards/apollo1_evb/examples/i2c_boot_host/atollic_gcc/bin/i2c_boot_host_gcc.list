
i2c_boot_host_gcc.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004564  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .stack        00001000  10000000  10000000  00030000  2**2
                  ALLOC
  2 .data         0000000c  10001000  00004564  00021000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00000380  1000100c  00004570  0002100c  2**2
                  ALLOC
  4 .ARM.attributes 00000037  00000000  00000000  0002100c  2**0
                  CONTENTS, READONLY
  5 .debug_info   0000adfb  00000000  00000000  00021043  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001c31  00000000  00000000  0002be3e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 000006c8  00000000  00000000  0002da6f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_ranges 00001380  00000000  00000000  0002e137  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000445a  00000000  00000000  0002f4b7  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002323  00000000  00000000  00033911  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000007c  00000000  00000000  00035c34  2**0
                  CONTENTS, READONLY
 12 .debug_frame  000012b8  00000000  00000000  00035cb0  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00008cd4  00000000  00000000  00036f68  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <g_am_pfnVectors>:
       0:	00 10 00 10 b1 04 00 00 19 05 00 00 1f 05 00 00     ................
      10:	1f 05 00 00 1f 05 00 00 1f 05 00 00 00 00 00 00     ................
	...
      2c:	25 05 00 00 25 05 00 00 00 00 00 00 25 05 00 00     %...%.......%...
      3c:	25 05 00 00 25 05 00 00 25 05 00 00 25 05 00 00     %...%...%...%...
      4c:	25 05 00 00 25 05 00 00 25 05 00 00 25 05 00 00     %...%...%...%...
      5c:	25 05 00 00 25 05 00 00 21 01 00 00 25 05 00 00     %...%...!...%...
      6c:	25 05 00 00 25 05 00 00 25 05 00 00 25 05 00 00     %...%...%...%...
      7c:	25 05 00 00                                         %...

00000080 <configure_pins>:
// Configure GPIOs for this example
//
//*****************************************************************************
void
configure_pins(void)
{
      80:	b480      	push	{r7}
      82:	af00      	add	r7, sp, #0
    //
    // Configure I/O Master 0 as I2C
    //
    am_hal_gpio_pin_config(5, AM_HAL_PIN_5_M0SCL | AM_HAL_GPIO_PULLUP);
      84:	4b22      	ldr	r3, [pc, #136]	; (110 <configure_pins+0x90>)
      86:	2273      	movs	r2, #115	; 0x73
      88:	601a      	str	r2, [r3, #0]
      8a:	4a22      	ldr	r2, [pc, #136]	; (114 <configure_pins+0x94>)
      8c:	4b21      	ldr	r3, [pc, #132]	; (114 <configure_pins+0x94>)
      8e:	681b      	ldr	r3, [r3, #0]
      90:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
      94:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
      98:	6013      	str	r3, [r2, #0]
      9a:	4a1f      	ldr	r2, [pc, #124]	; (118 <configure_pins+0x98>)
      9c:	4b1e      	ldr	r3, [pc, #120]	; (118 <configure_pins+0x98>)
      9e:	681b      	ldr	r3, [r3, #0]
      a0:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
      a4:	f443 7340 	orr.w	r3, r3, #768	; 0x300
      a8:	6013      	str	r3, [r2, #0]
      aa:	4b19      	ldr	r3, [pc, #100]	; (110 <configure_pins+0x90>)
      ac:	2200      	movs	r2, #0
      ae:	601a      	str	r2, [r3, #0]
    am_hal_gpio_pin_config(6, AM_HAL_PIN_6_M0SDA | AM_HAL_GPIO_PULLUP);
      b0:	4b17      	ldr	r3, [pc, #92]	; (110 <configure_pins+0x90>)
      b2:	2273      	movs	r2, #115	; 0x73
      b4:	601a      	str	r2, [r3, #0]
      b6:	4a17      	ldr	r2, [pc, #92]	; (114 <configure_pins+0x94>)
      b8:	4b16      	ldr	r3, [pc, #88]	; (114 <configure_pins+0x94>)
      ba:	681b      	ldr	r3, [r3, #0]
      bc:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
      c0:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
      c4:	6013      	str	r3, [r2, #0]
      c6:	4a14      	ldr	r2, [pc, #80]	; (118 <configure_pins+0x98>)
      c8:	4b13      	ldr	r3, [pc, #76]	; (118 <configure_pins+0x98>)
      ca:	681b      	ldr	r3, [r3, #0]
      cc:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
      d0:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
      d4:	6013      	str	r3, [r2, #0]
      d6:	4b0e      	ldr	r3, [pc, #56]	; (110 <configure_pins+0x90>)
      d8:	2200      	movs	r2, #0
      da:	601a      	str	r2, [r3, #0]

    //
    // Configure the I/O Slave interrupt pin
    //
    am_hal_gpio_pin_config(BOOTLOADER_HANDSHAKE_PIN, AM_HAL_PIN_INPUT | AM_HAL_GPIO_PULLUP);
      dc:	4b0c      	ldr	r3, [pc, #48]	; (110 <configure_pins+0x90>)
      de:	2273      	movs	r2, #115	; 0x73
      e0:	601a      	str	r2, [r3, #0]
      e2:	4a0c      	ldr	r2, [pc, #48]	; (114 <configure_pins+0x94>)
      e4:	4b0b      	ldr	r3, [pc, #44]	; (114 <configure_pins+0x94>)
      e6:	681b      	ldr	r3, [r3, #0]
      e8:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
      ec:	6013      	str	r3, [r2, #0]
      ee:	4a0b      	ldr	r2, [pc, #44]	; (11c <configure_pins+0x9c>)
      f0:	4b0a      	ldr	r3, [pc, #40]	; (11c <configure_pins+0x9c>)
      f2:	681b      	ldr	r3, [r3, #0]
      f4:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
      f8:	f443 13d8 	orr.w	r3, r3, #1769472	; 0x1b0000
      fc:	6013      	str	r3, [r2, #0]
      fe:	4b04      	ldr	r3, [pc, #16]	; (110 <configure_pins+0x90>)
     100:	2200      	movs	r2, #0
     102:	601a      	str	r2, [r3, #0]
}
     104:	bf00      	nop
     106:	46bd      	mov	sp, r7
     108:	f85d 7b04 	ldr.w	r7, [sp], #4
     10c:	4770      	bx	lr
     10e:	bf00      	nop
     110:	40010060 	.word	0x40010060
     114:	40010040 	.word	0x40010040
     118:	40010004 	.word	0x40010004
     11c:	40010000 	.word	0x40010000

00000120 <am_gpio_isr>:
// Interrupt handler for the GPIO pins.
//
//*****************************************************************************
void
am_gpio_isr(void)
{
     120:	b580      	push	{r7, lr}
     122:	b082      	sub	sp, #8
     124:	af00      	add	r7, sp, #0
    uint64_t ui64Status;

    //
    // Read and clear the GPIO interrupt status.
    //
    ui64Status = am_hal_gpio_int_status_get(false);
     126:	2000      	movs	r0, #0
     128:	f000 fb26 	bl	778 <am_hal_gpio_int_status_get>
     12c:	e9c7 0100 	strd	r0, r1, [r7]
    am_hal_gpio_int_clear(ui64Status);
     130:	e9d7 0100 	ldrd	r0, r1, [r7]
     134:	f000 fb16 	bl	764 <am_hal_gpio_int_clear>
}
     138:	bf00      	nop
     13a:	3708      	adds	r7, #8
     13c:	46bd      	mov	sp, r7
     13e:	bd80      	pop	{r7, pc}

00000140 <start_boot_mode>:
// Reset the slave device and force it into boot mode.
//
//*****************************************************************************
void
start_boot_mode(void)
{
     140:	b580      	push	{r7, lr}
     142:	af00      	add	r7, sp, #0
    //
    // Drive RESET low.
    //
    am_hal_gpio_out_bit_clear(DRIVE_SLAVE_RESET_PIN);
     144:	4b21      	ldr	r3, [pc, #132]	; (1cc <start_boot_mode+0x8c>)
     146:	f44f 3200 	mov.w	r2, #131072	; 0x20000
     14a:	601a      	str	r2, [r3, #0]
    am_hal_gpio_pin_config(DRIVE_SLAVE_RESET_PIN, AM_HAL_PIN_OUTPUT);
     14c:	4b20      	ldr	r3, [pc, #128]	; (1d0 <start_boot_mode+0x90>)
     14e:	2273      	movs	r2, #115	; 0x73
     150:	601a      	str	r2, [r3, #0]
     152:	4a20      	ldr	r2, [pc, #128]	; (1d4 <start_boot_mode+0x94>)
     154:	4b1f      	ldr	r3, [pc, #124]	; (1d4 <start_boot_mode+0x94>)
     156:	681b      	ldr	r3, [r3, #0]
     158:	f023 0370 	bic.w	r3, r3, #112	; 0x70
     15c:	f043 0320 	orr.w	r3, r3, #32
     160:	6013      	str	r3, [r2, #0]
     162:	4a1d      	ldr	r2, [pc, #116]	; (1d8 <start_boot_mode+0x98>)
     164:	4b1c      	ldr	r3, [pc, #112]	; (1d8 <start_boot_mode+0x98>)
     166:	681b      	ldr	r3, [r3, #0]
     168:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
     16c:	f443 53c0 	orr.w	r3, r3, #6144	; 0x1800
     170:	6013      	str	r3, [r2, #0]
     172:	4b17      	ldr	r3, [pc, #92]	; (1d0 <start_boot_mode+0x90>)
     174:	2200      	movs	r2, #0
     176:	601a      	str	r2, [r3, #0]

    //
    // Drive the override pin low to force the slave into boot mode.
    //
    am_hal_gpio_out_bit_clear(DRIVE_SLAVE_OVERRIDE_PIN);
     178:	4b14      	ldr	r3, [pc, #80]	; (1cc <start_boot_mode+0x8c>)
     17a:	2210      	movs	r2, #16
     17c:	601a      	str	r2, [r3, #0]
    am_hal_gpio_pin_config(DRIVE_SLAVE_OVERRIDE_PIN, AM_HAL_PIN_OUTPUT);
     17e:	4b14      	ldr	r3, [pc, #80]	; (1d0 <start_boot_mode+0x90>)
     180:	2273      	movs	r2, #115	; 0x73
     182:	601a      	str	r2, [r3, #0]
     184:	4a15      	ldr	r2, [pc, #84]	; (1dc <start_boot_mode+0x9c>)
     186:	4b15      	ldr	r3, [pc, #84]	; (1dc <start_boot_mode+0x9c>)
     188:	681b      	ldr	r3, [r3, #0]
     18a:	f423 23e0 	bic.w	r3, r3, #458752	; 0x70000
     18e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
     192:	6013      	str	r3, [r2, #0]
     194:	4a12      	ldr	r2, [pc, #72]	; (1e0 <start_boot_mode+0xa0>)
     196:	4b12      	ldr	r3, [pc, #72]	; (1e0 <start_boot_mode+0xa0>)
     198:	681b      	ldr	r3, [r3, #0]
     19a:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
     19e:	f043 0318 	orr.w	r3, r3, #24
     1a2:	6013      	str	r3, [r2, #0]
     1a4:	4b0a      	ldr	r3, [pc, #40]	; (1d0 <start_boot_mode+0x90>)
     1a6:	2200      	movs	r2, #0
     1a8:	601a      	str	r2, [r3, #0]

    //
    // Short delay.
    //
    am_util_delay_us(5);
     1aa:	2005      	movs	r0, #5
     1ac:	f000 f9be 	bl	52c <am_util_delay_us>

    //
    // Release RESET.
    //
    am_hal_gpio_out_bit_set(DRIVE_SLAVE_RESET_PIN);
     1b0:	4b0c      	ldr	r3, [pc, #48]	; (1e4 <start_boot_mode+0xa4>)
     1b2:	f44f 3200 	mov.w	r2, #131072	; 0x20000
     1b6:	601a      	str	r2, [r3, #0]

    //
    // Wait for the slave to Set the handshake pin
    //
    while ( !am_hal_gpio_input_bit_read(BOOTLOADER_HANDSHAKE_PIN) );
     1b8:	bf00      	nop
     1ba:	4b0b      	ldr	r3, [pc, #44]	; (1e8 <start_boot_mode+0xa8>)
     1bc:	681b      	ldr	r3, [r3, #0]
     1be:	f003 0304 	and.w	r3, r3, #4
     1c2:	2b00      	cmp	r3, #0
     1c4:	d0f9      	beq.n	1ba <start_boot_mode+0x7a>
}
     1c6:	bf00      	nop
     1c8:	bd80      	pop	{r7, pc}
     1ca:	bf00      	nop
     1cc:	40010098 	.word	0x40010098
     1d0:	40010060 	.word	0x40010060
     1d4:	40010048 	.word	0x40010048
     1d8:	40010010 	.word	0x40010010
     1dc:	40010040 	.word	0x40010040
     1e0:	40010004 	.word	0x40010004
     1e4:	40010090 	.word	0x40010090
     1e8:	40010080 	.word	0x40010080

000001ec <start_new_image>:
// Send the commands to start a new boot download.
//
//*****************************************************************************
void
start_new_image(void)
{
     1ec:	b580      	push	{r7, lr}
     1ee:	b082      	sub	sp, #8
     1f0:	af02      	add	r7, sp, #8
    //
    // Wait for the slave to send the ready signal
    //
    while ( am_hal_gpio_input_bit_read(BOOTLOADER_HANDSHAKE_PIN) );
     1f2:	bf00      	nop
     1f4:	4b25      	ldr	r3, [pc, #148]	; (28c <start_new_image+0xa0>)
     1f6:	681b      	ldr	r3, [r3, #0]
     1f8:	f003 0304 	and.w	r3, r3, #4
     1fc:	2b00      	cmp	r3, #0
     1fe:	d1f9      	bne.n	1f4 <start_new_image+0x8>
    //
    // Make sure the override pin is high so the slave will reboot into
    // application mode when our boot procedure is complete.
    //
    am_hal_gpio_out_bit_set(DRIVE_SLAVE_OVERRIDE_PIN);
     200:	4b23      	ldr	r3, [pc, #140]	; (290 <start_new_image+0xa4>)
     202:	2210      	movs	r2, #16
     204:	601a      	str	r2, [r3, #0]
    // Clear any interrupts that may have happened while Slave is coming up
    am_hal_iom_int_clear(0, 0xFFFFFFFF);
     206:	f04f 31ff 	mov.w	r1, #4294967295
     20a:	2000      	movs	r0, #0
     20c:	f001 fa46 	bl	169c <am_hal_iom_int_clear>
    am_hal_iom_i2c_read(0, SLAVE_ADDRESS, g_psRxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x0));
     210:	2300      	movs	r3, #0
     212:	9300      	str	r3, [sp, #0]
     214:	2304      	movs	r3, #4
     216:	4a1f      	ldr	r2, [pc, #124]	; (294 <start_new_image+0xa8>)
     218:	2110      	movs	r1, #16
     21a:	2000      	movs	r0, #0
     21c:	f001 f988 	bl	1530 <am_hal_iom_i2c_read>

    //
    // ACK the ready signal to have slave pull the interrupt line high.
    //
    g_psTxBuffer.words[0] = AM_BOOTLOADER_ACK_CMD;
     220:	4b1d      	ldr	r3, [pc, #116]	; (298 <start_new_image+0xac>)
     222:	2200      	movs	r2, #0
     224:	601a      	str	r2, [r3, #0]
    am_hal_iom_i2c_write(0, SLAVE_ADDRESS, g_psTxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x80));
     226:	f44f 4300 	mov.w	r3, #32768	; 0x8000
     22a:	9300      	str	r3, [sp, #0]
     22c:	2304      	movs	r3, #4
     22e:	4a1a      	ldr	r2, [pc, #104]	; (298 <start_new_image+0xac>)
     230:	2110      	movs	r1, #16
     232:	2000      	movs	r0, #0
     234:	f001 f8c8 	bl	13c8 <am_hal_iom_i2c_write>
    //
    // Wait for the slave to read the ACK
    //
    while ( !am_hal_gpio_input_bit_read(BOOTLOADER_HANDSHAKE_PIN) );
     238:	bf00      	nop
     23a:	4b14      	ldr	r3, [pc, #80]	; (28c <start_new_image+0xa0>)
     23c:	681b      	ldr	r3, [r3, #0]
     23e:	f003 0304 	and.w	r3, r3, #4
     242:	2b00      	cmp	r3, #0
     244:	d0f9      	beq.n	23a <start_new_image+0x4e>

    //
    // Write the image parameters to the I2C FIFO
    //
    g_psTxBuffer.words[0] = IMAGE_LINK_ADDRESS;
     246:	4b14      	ldr	r3, [pc, #80]	; (298 <start_new_image+0xac>)
     248:	f44f 4200 	mov.w	r2, #32768	; 0x8000
     24c:	601a      	str	r2, [r3, #0]
    g_psTxBuffer.words[1] = IMAGE_SIZE;
     24e:	4b12      	ldr	r3, [pc, #72]	; (298 <start_new_image+0xac>)
     250:	f641 3238 	movw	r2, #6968	; 0x1b38
     254:	605a      	str	r2, [r3, #4]
    g_psTxBuffer.words[2] = IMAGE_CRC;
     256:	4b10      	ldr	r3, [pc, #64]	; (298 <start_new_image+0xac>)
     258:	4a10      	ldr	r2, [pc, #64]	; (29c <start_new_image+0xb0>)
     25a:	609a      	str	r2, [r3, #8]

    //
    // Send the image parameters to the slave.
    //
    am_hal_iom_i2c_write(0, SLAVE_ADDRESS, g_psTxBuffer.words, 12, AM_HAL_IOM_OFFSET(0x84));
     25c:	f44f 4304 	mov.w	r3, #33792	; 0x8400
     260:	9300      	str	r3, [sp, #0]
     262:	230c      	movs	r3, #12
     264:	4a0c      	ldr	r2, [pc, #48]	; (298 <start_new_image+0xac>)
     266:	2110      	movs	r1, #16
     268:	2000      	movs	r0, #0
     26a:	f001 f8ad 	bl	13c8 <am_hal_iom_i2c_write>

    //
    // Finish out the image start routine with the "New Image" packet.
    //
    g_psTxBuffer.words[0] = AM_BOOTLOADER_NEW_IMAGE;
     26e:	4b0a      	ldr	r3, [pc, #40]	; (298 <start_new_image+0xac>)
     270:	2202      	movs	r2, #2
     272:	601a      	str	r2, [r3, #0]
    am_hal_iom_i2c_write(0, SLAVE_ADDRESS, g_psTxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x80));
     274:	f44f 4300 	mov.w	r3, #32768	; 0x8000
     278:	9300      	str	r3, [sp, #0]
     27a:	2304      	movs	r3, #4
     27c:	4a06      	ldr	r2, [pc, #24]	; (298 <start_new_image+0xac>)
     27e:	2110      	movs	r1, #16
     280:	2000      	movs	r0, #0
     282:	f001 f8a1 	bl	13c8 <am_hal_iom_i2c_write>
}
     286:	bf00      	nop
     288:	46bd      	mov	sp, r7
     28a:	bd80      	pop	{r7, pc}
     28c:	40010080 	.word	0x40010080
     290:	40010090 	.word	0x40010090
     294:	10001234 	.word	0x10001234
     298:	10001044 	.word	0x10001044
     29c:	f4a03140 	.word	0xf4a03140

000002a0 <override_pin_set>:
// Set override pin.
//
//*****************************************************************************
void
override_pin_set(uint32_t ui32OverridePin, uint32_t ui32OverridePolarity)
{
     2a0:	b580      	push	{r7, lr}
     2a2:	b084      	sub	sp, #16
     2a4:	af02      	add	r7, sp, #8
     2a6:	6078      	str	r0, [r7, #4]
     2a8:	6039      	str	r1, [r7, #0]
    //
    // Wait for the slave to send the ready signal
    //
    while ( am_hal_gpio_input_bit_read(BOOTLOADER_HANDSHAKE_PIN) );
     2aa:	bf00      	nop
     2ac:	4b1f      	ldr	r3, [pc, #124]	; (32c <override_pin_set+0x8c>)
     2ae:	681b      	ldr	r3, [r3, #0]
     2b0:	f003 0304 	and.w	r3, r3, #4
     2b4:	2b00      	cmp	r3, #0
     2b6:	d1f9      	bne.n	2ac <override_pin_set+0xc>
    am_hal_iom_i2c_read(0, SLAVE_ADDRESS, g_psRxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x0));
     2b8:	2300      	movs	r3, #0
     2ba:	9300      	str	r3, [sp, #0]
     2bc:	2304      	movs	r3, #4
     2be:	4a1c      	ldr	r2, [pc, #112]	; (330 <override_pin_set+0x90>)
     2c0:	2110      	movs	r1, #16
     2c2:	2000      	movs	r0, #0
     2c4:	f001 f934 	bl	1530 <am_hal_iom_i2c_read>

    //
    // ACK the ready signal to have slave pull the interrupt line high.
    //
    g_psTxBuffer.words[0] = AM_BOOTLOADER_ACK_CMD;
     2c8:	4b1a      	ldr	r3, [pc, #104]	; (334 <override_pin_set+0x94>)
     2ca:	2200      	movs	r2, #0
     2cc:	601a      	str	r2, [r3, #0]
    am_hal_iom_i2c_write(0, SLAVE_ADDRESS, g_psTxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x80));
     2ce:	f44f 4300 	mov.w	r3, #32768	; 0x8000
     2d2:	9300      	str	r3, [sp, #0]
     2d4:	2304      	movs	r3, #4
     2d6:	4a17      	ldr	r2, [pc, #92]	; (334 <override_pin_set+0x94>)
     2d8:	2110      	movs	r1, #16
     2da:	2000      	movs	r0, #0
     2dc:	f001 f874 	bl	13c8 <am_hal_iom_i2c_write>
    //
    // Wait for the slave to read the ACK
    //
    while ( !am_hal_gpio_input_bit_read(BOOTLOADER_HANDSHAKE_PIN) );
     2e0:	bf00      	nop
     2e2:	4b12      	ldr	r3, [pc, #72]	; (32c <override_pin_set+0x8c>)
     2e4:	681b      	ldr	r3, [r3, #0]
     2e6:	f003 0304 	and.w	r3, r3, #4
     2ea:	2b00      	cmp	r3, #0
     2ec:	d0f9      	beq.n	2e2 <override_pin_set+0x42>

    //
    // Write the image parameters to the I2C FIFO
    //
    g_psTxBuffer.words[0] = ui32OverridePin;
     2ee:	4a11      	ldr	r2, [pc, #68]	; (334 <override_pin_set+0x94>)
     2f0:	687b      	ldr	r3, [r7, #4]
     2f2:	6013      	str	r3, [r2, #0]
    g_psTxBuffer.words[1] = ui32OverridePolarity;
     2f4:	4a0f      	ldr	r2, [pc, #60]	; (334 <override_pin_set+0x94>)
     2f6:	683b      	ldr	r3, [r7, #0]
     2f8:	6053      	str	r3, [r2, #4]

    //
    // Send the image parameters to the slave.
    //
    am_hal_iom_i2c_write(0, SLAVE_ADDRESS, g_psTxBuffer.words, 8, AM_HAL_IOM_OFFSET(0x84));
     2fa:	f44f 4304 	mov.w	r3, #33792	; 0x8400
     2fe:	9300      	str	r3, [sp, #0]
     300:	2308      	movs	r3, #8
     302:	4a0c      	ldr	r2, [pc, #48]	; (334 <override_pin_set+0x94>)
     304:	2110      	movs	r1, #16
     306:	2000      	movs	r0, #0
     308:	f001 f85e 	bl	13c8 <am_hal_iom_i2c_write>

    //
    // Finish out the image start routine with the "New Image" packet.
    //
    g_psTxBuffer.words[0] = AM_BOOTLOADER_SET_OVERRIDE_CMD;
     30c:	4b09      	ldr	r3, [pc, #36]	; (334 <override_pin_set+0x94>)
     30e:	2205      	movs	r2, #5
     310:	601a      	str	r2, [r3, #0]
    am_hal_iom_i2c_write(0, SLAVE_ADDRESS, g_psTxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x80));
     312:	f44f 4300 	mov.w	r3, #32768	; 0x8000
     316:	9300      	str	r3, [sp, #0]
     318:	2304      	movs	r3, #4
     31a:	4a06      	ldr	r2, [pc, #24]	; (334 <override_pin_set+0x94>)
     31c:	2110      	movs	r1, #16
     31e:	2000      	movs	r0, #0
     320:	f001 f852 	bl	13c8 <am_hal_iom_i2c_write>
}
     324:	bf00      	nop
     326:	3708      	adds	r7, #8
     328:	46bd      	mov	sp, r7
     32a:	bd80      	pop	{r7, pc}
     32c:	40010080 	.word	0x40010080
     330:	10001234 	.word	0x10001234
     334:	10001044 	.word	0x10001044

00000338 <transfer_image>:
// Send the actual firmware image over to the boot slave.
//
//*****************************************************************************
void
transfer_image(void)
{
     338:	b580      	push	{r7, lr}
     33a:	b086      	sub	sp, #24
     33c:	af02      	add	r7, sp, #8
    uint32_t i;

    //
    // Send the firmware image across.
    //
    ui32BytesRemaining = IMAGE_SIZE;
     33e:	f641 3338 	movw	r3, #6968	; 0x1b38
     342:	60fb      	str	r3, [r7, #12]
    ui32Offset = 0;
     344:	2300      	movs	r3, #0
     346:	60bb      	str	r3, [r7, #8]

    while ( ui32BytesRemaining )
     348:	e05b      	b.n	402 <transfer_image+0xca>
    {
        //
        // Wait for another ready signal.
        //
        while ( am_hal_gpio_input_bit_read(BOOTLOADER_HANDSHAKE_PIN) );
     34a:	bf00      	nop
     34c:	4b30      	ldr	r3, [pc, #192]	; (410 <transfer_image+0xd8>)
     34e:	681b      	ldr	r3, [r3, #0]
     350:	f003 0304 	and.w	r3, r3, #4
     354:	2b00      	cmp	r3, #0
     356:	d1f9      	bne.n	34c <transfer_image+0x14>
        am_hal_iom_i2c_read(0, SLAVE_ADDRESS, g_psRxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x0));
     358:	2300      	movs	r3, #0
     35a:	9300      	str	r3, [sp, #0]
     35c:	2304      	movs	r3, #4
     35e:	4a2d      	ldr	r2, [pc, #180]	; (414 <transfer_image+0xdc>)
     360:	2110      	movs	r1, #16
     362:	2000      	movs	r0, #0
     364:	f001 f8e4 	bl	1530 <am_hal_iom_i2c_read>
        //
        // ACK the ready signal to have slave pull the interrupt line high.
        //
        g_psTxBuffer.words[0] = AM_BOOTLOADER_ACK_CMD;
     368:	4b2b      	ldr	r3, [pc, #172]	; (418 <transfer_image+0xe0>)
     36a:	2200      	movs	r2, #0
     36c:	601a      	str	r2, [r3, #0]
        am_hal_iom_i2c_write(0, SLAVE_ADDRESS, g_psTxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x80));
     36e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
     372:	9300      	str	r3, [sp, #0]
     374:	2304      	movs	r3, #4
     376:	4a28      	ldr	r2, [pc, #160]	; (418 <transfer_image+0xe0>)
     378:	2110      	movs	r1, #16
     37a:	2000      	movs	r0, #0
     37c:	f001 f824 	bl	13c8 <am_hal_iom_i2c_write>
        //
        // Wait for the slave to read the ACK
        //
        while ( !am_hal_gpio_input_bit_read(BOOTLOADER_HANDSHAKE_PIN) );
     380:	bf00      	nop
     382:	4b23      	ldr	r3, [pc, #140]	; (410 <transfer_image+0xd8>)
     384:	681b      	ldr	r3, [r3, #0]
     386:	f003 0304 	and.w	r3, r3, #4
     38a:	2b00      	cmp	r3, #0
     38c:	d0f9      	beq.n	382 <transfer_image+0x4a>

        //
        // We can't transfer more than a few bytes at a time. Limit the
        // transaction to 112 bytes max.
        //
        ui32TransferSize = ui32BytesRemaining > 112 ? 112 : ui32BytesRemaining;
     38e:	68fb      	ldr	r3, [r7, #12]
     390:	2b70      	cmp	r3, #112	; 0x70
     392:	bf28      	it	cs
     394:	2370      	movcs	r3, #112	; 0x70
     396:	603b      	str	r3, [r7, #0]

        //
        // Start the packet with the packet length.
        //
        g_psTxBuffer.words[0] = ui32TransferSize;
     398:	4a1f      	ldr	r2, [pc, #124]	; (418 <transfer_image+0xe0>)
     39a:	683b      	ldr	r3, [r7, #0]
     39c:	6013      	str	r3, [r2, #0]

        //
        // Fill in the packet contents.
        //
        for ( i = 0; i < ui32TransferSize; i++ )
     39e:	2300      	movs	r3, #0
     3a0:	607b      	str	r3, [r7, #4]
     3a2:	e00b      	b.n	3bc <transfer_image+0x84>
        {
            g_psTxBuffer.bytes[4 + i] = IMAGE_ARRAY[ui32Offset + i];
     3a4:	687b      	ldr	r3, [r7, #4]
     3a6:	3304      	adds	r3, #4
     3a8:	68b9      	ldr	r1, [r7, #8]
     3aa:	687a      	ldr	r2, [r7, #4]
     3ac:	440a      	add	r2, r1
     3ae:	491b      	ldr	r1, [pc, #108]	; (41c <transfer_image+0xe4>)
     3b0:	5c89      	ldrb	r1, [r1, r2]
     3b2:	4a19      	ldr	r2, [pc, #100]	; (418 <transfer_image+0xe0>)
     3b4:	54d1      	strb	r1, [r2, r3]
        for ( i = 0; i < ui32TransferSize; i++ )
     3b6:	687b      	ldr	r3, [r7, #4]
     3b8:	3301      	adds	r3, #1
     3ba:	607b      	str	r3, [r7, #4]
     3bc:	687a      	ldr	r2, [r7, #4]
     3be:	683b      	ldr	r3, [r7, #0]
     3c0:	429a      	cmp	r2, r3
     3c2:	d3ef      	bcc.n	3a4 <transfer_image+0x6c>
        }

        //
        // Send the data over to the slave.
        //
        am_hal_iom_i2c_write(0, SLAVE_ADDRESS, g_psTxBuffer.words, ui32TransferSize + 4,
     3c4:	683b      	ldr	r3, [r7, #0]
     3c6:	1d1a      	adds	r2, r3, #4
     3c8:	f44f 4304 	mov.w	r3, #33792	; 0x8400
     3cc:	9300      	str	r3, [sp, #0]
     3ce:	4613      	mov	r3, r2
     3d0:	4a11      	ldr	r2, [pc, #68]	; (418 <transfer_image+0xe0>)
     3d2:	2110      	movs	r1, #16
     3d4:	2000      	movs	r0, #0
     3d6:	f000 fff7 	bl	13c8 <am_hal_iom_i2c_write>
                             AM_HAL_IOM_OFFSET(0x84));

        //
        // Finish with the "New Packet" boot command.
        //
        g_psTxBuffer.words[0] = AM_BOOTLOADER_NEW_PACKET;
     3da:	4b0f      	ldr	r3, [pc, #60]	; (418 <transfer_image+0xe0>)
     3dc:	2203      	movs	r2, #3
     3de:	601a      	str	r2, [r3, #0]
        am_hal_iom_i2c_write(0, SLAVE_ADDRESS, g_psTxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x80));
     3e0:	f44f 4300 	mov.w	r3, #32768	; 0x8000
     3e4:	9300      	str	r3, [sp, #0]
     3e6:	2304      	movs	r3, #4
     3e8:	4a0b      	ldr	r2, [pc, #44]	; (418 <transfer_image+0xe0>)
     3ea:	2110      	movs	r1, #16
     3ec:	2000      	movs	r0, #0
     3ee:	f000 ffeb 	bl	13c8 <am_hal_iom_i2c_write>

        //
        // Update the loop variables.
        //
        ui32BytesRemaining -= ui32TransferSize;
     3f2:	68fa      	ldr	r2, [r7, #12]
     3f4:	683b      	ldr	r3, [r7, #0]
     3f6:	1ad3      	subs	r3, r2, r3
     3f8:	60fb      	str	r3, [r7, #12]
        ui32Offset += ui32TransferSize;
     3fa:	68ba      	ldr	r2, [r7, #8]
     3fc:	683b      	ldr	r3, [r7, #0]
     3fe:	4413      	add	r3, r2
     400:	60bb      	str	r3, [r7, #8]
    while ( ui32BytesRemaining )
     402:	68fb      	ldr	r3, [r7, #12]
     404:	2b00      	cmp	r3, #0
     406:	d1a0      	bne.n	34a <transfer_image+0x12>
    }
}
     408:	bf00      	nop
     40a:	3710      	adds	r7, #16
     40c:	46bd      	mov	sp, r7
     40e:	bd80      	pop	{r7, pc}
     410:	40010080 	.word	0x40010080
     414:	10001234 	.word	0x10001234
     418:	10001044 	.word	0x10001044
     41c:	00002814 	.word	0x00002814

00000420 <main>:
// Main function.
//
//*****************************************************************************
int
main(void)
{
     420:	b580      	push	{r7, lr}
     422:	b082      	sub	sp, #8
     424:	af02      	add	r7, sp, #8
    //
    // Set the clock frequency.
    //
    am_hal_clkgen_sysclk_select(AM_HAL_CLKGEN_SYSCLK_MAX);
     426:	2000      	movs	r0, #0
     428:	f000 f8fa 	bl	620 <am_hal_clkgen_sysclk_select>
    am_hal_cachectrl_enable(&am_hal_cachectrl_defaults);

    //
    // Configure the board for low power operation.
    //
    am_bsp_low_power_init();
     42c:	f000 f8e6 	bl	5fc <am_bsp_low_power_init>

    //
    // Setup the pins for IO Master Example.
    //
    configure_pins();
     430:	f7ff fe26 	bl	80 <configure_pins>
    // Initialize IOM 0 in I2C mode at 100KHz
    //
#ifndef AM_PART_APOLLO
    am_hal_iom_pwrctrl_enable(0);
#endif
    am_hal_iom_config(0, &g_sIOMConfig);
     434:	4919      	ldr	r1, [pc, #100]	; (49c <main+0x7c>)
     436:	2000      	movs	r0, #0
     438:	f000 ff68 	bl	130c <am_hal_iom_config>
    //
    // Turn on the IOM for this operation.
    //
    am_bsp_iom_enable(0);
     43c:	2000      	movs	r0, #0
     43e:	f000 f88f 	bl	560 <am_bsp_iom_enable>

    //
    // Force the slave into boot mode.
    //
    start_boot_mode();
     442:	f7ff fe7d 	bl	140 <start_boot_mode>

    //
    // Wait for the 'READY' from the boot slave, and then send the packet
    // information.
    //
    start_new_image();
     446:	f7ff fed1 	bl	1ec <start_new_image>

    //
    // Change the override pin to correspond to a button on the Apollo EVK
    //
    override_pin_set(TARGET_BOARD_OVERRIDE_PIN, 0);
     44a:	2100      	movs	r1, #0
     44c:	2012      	movs	r0, #18
     44e:	f7ff ff27 	bl	2a0 <override_pin_set>

    //
    // Wait for another 'READY', and send the actual image across.
    //
    transfer_image();
     452:	f7ff ff71 	bl	338 <transfer_image>
    //
    // At this point, the slave should send back a either 'CRC OK' or some sort
    // of error. If the CRC was good, we should tell the slave to reset itself
    // and run the new image.
    //
    while ( am_hal_gpio_input_bit_read(BOOTLOADER_HANDSHAKE_PIN) );
     456:	bf00      	nop
     458:	4b11      	ldr	r3, [pc, #68]	; (4a0 <main+0x80>)
     45a:	681b      	ldr	r3, [r3, #0]
     45c:	f003 0304 	and.w	r3, r3, #4
     460:	2b00      	cmp	r3, #0
     462:	d1f9      	bne.n	458 <main+0x38>
    am_hal_iom_i2c_read(0, SLAVE_ADDRESS, g_psRxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x0));
     464:	2300      	movs	r3, #0
     466:	9300      	str	r3, [sp, #0]
     468:	2304      	movs	r3, #4
     46a:	4a0e      	ldr	r2, [pc, #56]	; (4a4 <main+0x84>)
     46c:	2110      	movs	r1, #16
     46e:	2000      	movs	r0, #0
     470:	f001 f85e 	bl	1530 <am_hal_iom_i2c_read>

    if ( g_psRxBuffer.words[0] == AM_BOOTLOADER_IMAGE_COMPLETE )
     474:	4b0b      	ldr	r3, [pc, #44]	; (4a4 <main+0x84>)
     476:	681b      	ldr	r3, [r3, #0]
     478:	2b03      	cmp	r3, #3
     47a:	d10e      	bne.n	49a <main+0x7a>
    {
        //
        // Make sure the override pin is high so the slave will reboot into
        // application mode when our boot procedure is complete.
        //
        am_hal_gpio_out_bit_set(DRIVE_SLAVE_OVERRIDE_PIN);
     47c:	4b0a      	ldr	r3, [pc, #40]	; (4a8 <main+0x88>)
     47e:	2210      	movs	r2, #16
     480:	601a      	str	r2, [r3, #0]
        //
        // If the CRC is correct, send a RESET command.
        //
        g_psTxBuffer.words[0] = AM_BOOTLOADER_RESET;
     482:	4b0a      	ldr	r3, [pc, #40]	; (4ac <main+0x8c>)
     484:	2204      	movs	r2, #4
     486:	601a      	str	r2, [r3, #0]
        am_hal_iom_i2c_write(0, SLAVE_ADDRESS, g_psTxBuffer.words, 4, AM_HAL_IOM_OFFSET(0x80));
     488:	f44f 4300 	mov.w	r3, #32768	; 0x8000
     48c:	9300      	str	r3, [sp, #0]
     48e:	2304      	movs	r3, #4
     490:	4a06      	ldr	r2, [pc, #24]	; (4ac <main+0x8c>)
     492:	2110      	movs	r1, #16
     494:	2000      	movs	r0, #0
     496:	f000 ff97 	bl	13c8 <am_hal_iom_i2c_write>
    }

    //
    // Loop forever.
    //
    while (1)
     49a:	e7fe      	b.n	49a <main+0x7a>
     49c:	0000434c 	.word	0x0000434c
     4a0:	40010080 	.word	0x40010080
     4a4:	10001234 	.word	0x10001234
     4a8:	40010090 	.word	0x40010090
     4ac:	10001044 	.word	0x10001044

000004b0 <am_reset_isr>:
am_reset_isr(void)
{
    //
    // Set the vector table pointer.
    //
    __asm("    ldr    r0, =0xE000ED08\n"
     4b0:	4811      	ldr	r0, [pc, #68]	; (4f8 <zero_loop+0x12>)
     4b2:	4912      	ldr	r1, [pc, #72]	; (4fc <zero_loop+0x16>)
     4b4:	6001      	str	r1, [r0, #0]
          "    str    r1, [r0]");

    //
    // Set the stack pointer.
    //
    __asm("    ldr    sp, [r1]");
     4b6:	f8d1 d000 	ldr.w	sp, [r1]
#ifndef NOFPU
    //
    // Enable the FPU.
    //
    __asm("ldr  r0, =0xE000ED88\n"
     4ba:	4811      	ldr	r0, [pc, #68]	; (500 <zero_loop+0x1a>)
     4bc:	6801      	ldr	r1, [r0, #0]
     4be:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
     4c2:	6001      	str	r1, [r0, #0]
     4c4:	f3bf 8f4f 	dsb	sy
     4c8:	f3bf 8f6f 	isb	sy
          "isb\n");
#endif
    //
    // Copy the data segment initializers from flash to SRAM.
    //
    __asm("    ldr     r0, =_init_data\n"
     4cc:	480d      	ldr	r0, [pc, #52]	; (504 <zero_loop+0x1e>)
     4ce:	490e      	ldr	r1, [pc, #56]	; (508 <zero_loop+0x22>)
     4d0:	4a0e      	ldr	r2, [pc, #56]	; (50c <zero_loop+0x26>)

000004d2 <copy_loop>:
     4d2:	f850 3b04 	ldr.w	r3, [r0], #4
     4d6:	f841 3b04 	str.w	r3, [r1], #4
     4da:	4291      	cmp	r1, r2
     4dc:	dbf9      	blt.n	4d2 <copy_loop>
          "        cmp     r1, r2\n"
          "        blt     copy_loop\n");
    //
    // Zero fill the bss segment.
    //
    __asm("    ldr     r0, =_sbss\n"
     4de:	480c      	ldr	r0, [pc, #48]	; (510 <zero_loop+0x2a>)
     4e0:	490c      	ldr	r1, [pc, #48]	; (514 <zero_loop+0x2e>)
     4e2:	f04f 0200 	mov.w	r2, #0

000004e6 <zero_loop>:
     4e6:	4288      	cmp	r0, r1
     4e8:	bfb8      	it	lt
     4ea:	f840 2b04 	strlt.w	r2, [r0], #4
     4ee:	dbfa      	blt.n	4e6 <zero_loop>
          "        blt     zero_loop");

    //
    // Call the application's entry point.
    //
    main();
     4f0:	f7ff ff96 	bl	420 <main>

    //
    // If main returns then execute a break point instruction
    //
    __asm("    bkpt     ");
     4f4:	be00      	bkpt	0x0000
}
     4f6:	bf00      	nop
     4f8:	e000ed08 	.word	0xe000ed08
     4fc:	00000000 	.word	0x00000000
     500:	e000ed88 	.word	0xe000ed88
     504:	00004564 	.word	0x00004564
     508:	10001000 	.word	0x10001000
     50c:	1000100c 	.word	0x1000100c
     510:	1000100c 	.word	0x1000100c
     514:	1000138c 	.word	0x1000138c

00000518 <am_nmi_isr>:
// by a debugger.
//
//*****************************************************************************
void
am_nmi_isr(void)
{
     518:	b480      	push	{r7}
     51a:	af00      	add	r7, sp, #0
    //
    // Go into an infinite loop.
    //
    while(1)
     51c:	e7fe      	b.n	51c <am_nmi_isr+0x4>

0000051e <am_busfault_isr>:
// for examination by a debugger.
//
//*****************************************************************************
void
am_fault_isr(void)
{
     51e:	b480      	push	{r7}
     520:	af00      	add	r7, sp, #0
    //
    // Go into an infinite loop.
    //
    while(1)
     522:	e7fe      	b.n	522 <am_busfault_isr+0x4>

00000524 <am_adc_isr>:
// for examination by a debugger.
//
//*****************************************************************************
void
am_default_isr(void)
{
     524:	b480      	push	{r7}
     526:	af00      	add	r7, sp, #0
    //
    // Go into an infinite loop.
    //
    while(1)
     528:	e7fe      	b.n	528 <am_adc_isr+0x4>
	...

0000052c <am_util_delay_us>:
//! @returns None
//
//*****************************************************************************
void
am_util_delay_us(uint32_t ui32MicroSeconds)
{
     52c:	b580      	push	{r7, lr}
     52e:	b084      	sub	sp, #16
     530:	af00      	add	r7, sp, #0
     532:	6078      	str	r0, [r7, #4]
#if AM_APOLLO3_CLKGEN
    am_hal_clkgen_status_t sClkgenStatus;
    am_hal_clkgen_status_get(&sClkgenStatus);
    ui32HFRC = sClkgenStatus.ui32SysclkFreq;
#else
    ui32HFRC = am_hal_clkgen_sysclk_get();
     534:	f000 f884 	bl	640 <am_hal_clkgen_sysclk_get>
     538:	60f8      	str	r0, [r7, #12]
#endif
    ui32Loops = ui32MicroSeconds * (ui32HFRC / 3000000);
     53a:	68fb      	ldr	r3, [r7, #12]
     53c:	4a07      	ldr	r2, [pc, #28]	; (55c <am_util_delay_us+0x30>)
     53e:	fba2 2303 	umull	r2, r3, r2, r3
     542:	0c9b      	lsrs	r3, r3, #18
     544:	687a      	ldr	r2, [r7, #4]
     546:	fb02 f303 	mul.w	r3, r2, r3
     54a:	60bb      	str	r3, [r7, #8]

    //
    // Call the BOOTROM cycle delay function
    //
    am_hal_flash_delay(ui32Loops);
     54c:	68b8      	ldr	r0, [r7, #8]
     54e:	f000 f88d 	bl	66c <am_hal_flash_delay>
}
     552:	bf00      	nop
     554:	3710      	adds	r7, #16
     556:	46bd      	mov	sp, r7
     558:	bd80      	pop	{r7, pc}
     55a:	bf00      	nop
     55c:	165e9f81 	.word	0x165e9f81

00000560 <am_bsp_iom_enable>:
//! @return None.
//
//*****************************************************************************
void
am_bsp_iom_enable(uint32_t ui32Module)
{
     560:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     562:	4604      	mov	r4, r0
    am_hal_iom_enable(ui32Module);
     564:	f000 fe88 	bl	1278 <am_hal_iom_enable>

    // Check that the MISO pin is defined in BSP and we are in SPI mode.
    if ( (AM_BSP_GPIO_UNDEF != g_SPIpins[ui32Module][0] ) &&
     568:	4920      	ldr	r1, [pc, #128]	; (5ec <am_bsp_iom_enable+0x8c>)
     56a:	4a21      	ldr	r2, [pc, #132]	; (5f0 <am_bsp_iom_enable+0x90>)
     56c:	f851 3034 	ldr.w	r3, [r1, r4, lsl #3]
     570:	4293      	cmp	r3, r2
     572:	d039      	beq.n	5e8 <am_bsp_iom_enable+0x88>
         (1 == AM_BFRn(IOMSTR, ui32Module, CFG, IFCSEL) ) )
     574:	f504 20a0 	add.w	r0, r4, #327680	; 0x50000
     578:	3004      	adds	r0, #4
     57a:	0305      	lsls	r5, r0, #12
     57c:	f8d5 611c 	ldr.w	r6, [r5, #284]	; 0x11c
    if ( (AM_BSP_GPIO_UNDEF != g_SPIpins[ui32Module][0] ) &&
     580:	07f2      	lsls	r2, r6, #31
     582:	d531      	bpl.n	5e8 <am_bsp_iom_enable+0x88>
    {
        am_hal_gpio_pin_config(g_SPIpins[ui32Module][0],
     584:	2b00      	cmp	r3, #0
     586:	db2f      	blt.n	5e8 <am_bsp_iom_enable+0x88>
     588:	eb01 0cc4 	add.w	ip, r1, r4, lsl #3
     58c:	4d19      	ldr	r5, [pc, #100]	; (5f4 <am_bsp_iom_enable+0x94>)
     58e:	4f1a      	ldr	r7, [pc, #104]	; (5f8 <am_bsp_iom_enable+0x98>)
     590:	f8dc 1004 	ldr.w	r1, [ip, #4]
     594:	085c      	lsrs	r4, r3, #1
     596:	f004 0c7c 	and.w	ip, r4, #124	; 0x7c
     59a:	2273      	movs	r2, #115	; 0x73
     59c:	602a      	str	r2, [r5, #0]
     59e:	0098      	lsls	r0, r3, #2
     5a0:	f85c 6007 	ldr.w	r6, [ip, r7]
     5a4:	f000 041c 	and.w	r4, r0, #28
     5a8:	2207      	movs	r2, #7
     5aa:	f3c1 2002 	ubfx	r0, r1, #8, #3
     5ae:	fa02 fe04 	lsl.w	lr, r2, r4
     5b2:	40a0      	lsls	r0, r4
     5b4:	f003 02fc 	and.w	r2, r3, #252	; 0xfc
     5b8:	ea26 040e 	bic.w	r4, r6, lr
     5bc:	4320      	orrs	r0, r4
     5be:	f102 4680 	add.w	r6, r2, #1073741824	; 0x40000000
     5c2:	f84c 0007 	str.w	r0, [ip, r7]
     5c6:	f506 3780 	add.w	r7, r6, #65536	; 0x10000
     5ca:	00db      	lsls	r3, r3, #3
     5cc:	f003 0218 	and.w	r2, r3, #24
     5d0:	6838      	ldr	r0, [r7, #0]
     5d2:	24ff      	movs	r4, #255	; 0xff
     5d4:	4094      	lsls	r4, r2
     5d6:	b2c9      	uxtb	r1, r1
     5d8:	fa01 f602 	lsl.w	r6, r1, r2
     5dc:	ea20 0304 	bic.w	r3, r0, r4
     5e0:	431e      	orrs	r6, r3
     5e2:	2200      	movs	r2, #0
     5e4:	603e      	str	r6, [r7, #0]
     5e6:	602a      	str	r2, [r5, #0]
     5e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     5ea:	bf00      	nop
     5ec:	00004358 	.word	0x00004358
     5f0:	deadbeef 	.word	0xdeadbeef
     5f4:	40010060 	.word	0x40010060
     5f8:	40010040 	.word	0x40010040

000005fc <am_bsp_low_power_init>:
//! @return None.
//
//*****************************************************************************
void
am_bsp_low_power_init(void)
{
     5fc:	b508      	push	{r3, lr}
    //
    // Enable internal buck converters.
    //
    am_hal_mcuctrl_bucks_enable();
     5fe:	f001 f85f 	bl	16c0 <am_hal_mcuctrl_bucks_enable>

    //
    // Turn off the voltage comparator as this is enabled on reset.
    //
    am_hal_vcomp_disable();
     602:	f001 f92f 	bl	1864 <am_hal_vcomp_disable>

    //
    // Run the RTC off the LFRC.
    //
    am_hal_rtc_osc_select(AM_HAL_RTC_OSC_LFRC);
     606:	2001      	movs	r0, #1
     608:	f001 f900 	bl	180c <am_hal_rtc_osc_select>

    //
    // Stop the XTAL.
    //
    am_hal_clkgen_osc_stop(AM_HAL_CLKGEN_OSC_XT);
     60c:	2001      	movs	r0, #1
     60e:	f000 f823 	bl	658 <am_hal_clkgen_osc_stop>

    //
    // Disable the RTC.
    //
    am_hal_rtc_osc_disable();
     612:	f001 f909 	bl	1828 <am_hal_rtc_osc_disable>

    //
    // Disable the bandgap.
    //
    am_hal_mcuctrl_bandgap_disable();
}
     616:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    am_hal_mcuctrl_bandgap_disable();
     61a:	f001 b849 	b.w	16b0 <am_hal_mcuctrl_bandgap_disable>
     61e:	bf00      	nop

00000620 <am_hal_clkgen_sysclk_select>:
am_hal_clkgen_sysclk_select(uint32_t ui32ClockSetting)
{
    //
    // Unlock the clock control register.
    //
    AM_REG(CLKGEN, CLKKEY) = AM_REG_CLKGEN_CLKKEY_KEYVAL;
     620:	4b05      	ldr	r3, [pc, #20]	; (638 <am_hal_clkgen_sysclk_select+0x18>)

    //
    // Set the HFRC divisor to the user-selected value.
    //
    AM_REG(CLKGEN, CCTRL) = ui32ClockSetting;
     622:	4906      	ldr	r1, [pc, #24]	; (63c <am_hal_clkgen_sysclk_select+0x1c>)
{
     624:	b410      	push	{r4}

    //
    // Lock the clock configuration registers.
    //
    AM_REG(CLKGEN, CLKKEY) = 0;
     626:	2200      	movs	r2, #0
    AM_REG(CLKGEN, CLKKEY) = AM_REG_CLKGEN_CLKKEY_KEYVAL;
     628:	2447      	movs	r4, #71	; 0x47
     62a:	601c      	str	r4, [r3, #0]
    AM_REG(CLKGEN, CCTRL) = ui32ClockSetting;
     62c:	6008      	str	r0, [r1, #0]
}
     62e:	f85d 4b04 	ldr.w	r4, [sp], #4
    AM_REG(CLKGEN, CLKKEY) = 0;
     632:	601a      	str	r2, [r3, #0]
}
     634:	4770      	bx	lr
     636:	bf00      	nop
     638:	40004014 	.word	0x40004014
     63c:	40004018 	.word	0x40004018

00000640 <am_hal_clkgen_sysclk_get>:
    uint32_t ui32ClockSetting;

    //
    // Read the value of the clock divider.
    //
    ui32ClockSetting = AM_BFR(CLKGEN, CCTRL, CORESEL);
     640:	4b03      	ldr	r3, [pc, #12]	; (650 <am_hal_clkgen_sysclk_get+0x10>)
     642:	4a04      	ldr	r2, [pc, #16]	; (654 <am_hal_clkgen_sysclk_get+0x14>)
     644:	6818      	ldr	r0, [r3, #0]
     646:	f000 0107 	and.w	r1, r0, #7
        case AM_HAL_CLKGEN_SYSCLK_3MHZ:
            return 3000000;
        default:
            return 0xFFFFFFFF;
    }
}
     64a:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
     64e:	4770      	bx	lr
     650:	40004018 	.word	0x40004018
     654:	00004368 	.word	0x00004368

00000658 <am_hal_clkgen_osc_stop>:
//
//*****************************************************************************
void
am_hal_clkgen_osc_stop(uint32_t ui32OscFlags)
{
    if ( ui32OscFlags & (AM_HAL_CLKGEN_OSC_LFRC | AM_HAL_CLKGEN_OSC_XT) )
     658:	0783      	lsls	r3, r0, #30
     65a:	d003      	beq.n	664 <am_hal_clkgen_osc_stop+0xc>
    {
        //
        // Stop the oscillator(s).
        // Note that these bits are set in order to stop the oscillator.
        //
        AM_REG(CLKGEN, OCTRL) |= ui32OscFlags;
     65c:	4b02      	ldr	r3, [pc, #8]	; (668 <am_hal_clkgen_osc_stop+0x10>)
     65e:	681a      	ldr	r2, [r3, #0]
     660:	4310      	orrs	r0, r2
     662:	6018      	str	r0, [r3, #0]
     664:	4770      	bx	lr
     666:	bf00      	nop
     668:	4000400c 	.word	0x4000400c

0000066c <am_hal_flash_delay>:
}
#elif defined(__GNUC_STDC_INLINE__)
void __attribute__((naked))
am_hal_flash_delay(uint32_t ui32Iterations)
{
    __asm("    subs    r0, #1\n"
     66c:	3801      	subs	r0, #1
     66e:	f47f affd 	bne.w	66c <am_hal_flash_delay>
     672:	4770      	bx	lr

00000674 <am_hal_flash_delay_status_change>:
//*****************************************************************************
uint32_t
am_hal_flash_delay_status_change(uint32_t ui32usMaxDelay, uint32_t ui32Address,
                                 uint32_t ui32Mask, uint32_t ui32Value)
{
    while ( ui32usMaxDelay-- )
     674:	2800      	cmp	r0, #0
     676:	d070      	beq.n	75a <am_hal_flash_delay_status_change+0xe6>
{
     678:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
     67c:	1e47      	subs	r7, r0, #1
    {
        //
        // Check the status
        //
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     67e:	6808      	ldr	r0, [r1, #0]
     680:	4010      	ands	r0, r2
     682:	4283      	cmp	r3, r0
     684:	d063      	beq.n	74e <am_hal_flash_delay_status_change+0xda>
     686:	f017 0903 	ands.w	r9, r7, #3
     68a:	461c      	mov	r4, r3
     68c:	4615      	mov	r5, r2
     68e:	460e      	mov	r6, r1
        }

        //
        // Call the BOOTROM cycle function to delay for about 1 microsecond.
        //
        am_hal_flash_delay( FLASH_CYCLES_US(1) );
     690:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 760 <am_hal_flash_delay_status_change+0xec>
     694:	d02c      	beq.n	6f0 <am_hal_flash_delay_status_change+0x7c>
     696:	f7ff ffd3 	bl	640 <am_hal_clkgen_sysclk_get>
     69a:	fba8 3100 	umull	r3, r1, r8, r0
     69e:	0c88      	lsrs	r0, r1, #18
     6a0:	f7ff ffe4 	bl	66c <am_hal_flash_delay>
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     6a4:	6833      	ldr	r3, [r6, #0]
     6a6:	402b      	ands	r3, r5
     6a8:	42a3      	cmp	r3, r4
    while ( ui32usMaxDelay-- )
     6aa:	f107 37ff 	add.w	r7, r7, #4294967295
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     6ae:	d04e      	beq.n	74e <am_hal_flash_delay_status_change+0xda>
     6b0:	f1b9 0f01 	cmp.w	r9, #1
     6b4:	d01c      	beq.n	6f0 <am_hal_flash_delay_status_change+0x7c>
     6b6:	f1b9 0f02 	cmp.w	r9, #2
     6ba:	d00c      	beq.n	6d6 <am_hal_flash_delay_status_change+0x62>
        am_hal_flash_delay( FLASH_CYCLES_US(1) );
     6bc:	f7ff ffc0 	bl	640 <am_hal_clkgen_sysclk_get>
     6c0:	fba8 3200 	umull	r3, r2, r8, r0
     6c4:	0c90      	lsrs	r0, r2, #18
     6c6:	f7ff ffd1 	bl	66c <am_hal_flash_delay>
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     6ca:	6830      	ldr	r0, [r6, #0]
     6cc:	4028      	ands	r0, r5
     6ce:	42a0      	cmp	r0, r4
    while ( ui32usMaxDelay-- )
     6d0:	f107 37ff 	add.w	r7, r7, #4294967295
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     6d4:	d03b      	beq.n	74e <am_hal_flash_delay_status_change+0xda>
        am_hal_flash_delay( FLASH_CYCLES_US(1) );
     6d6:	f7ff ffb3 	bl	640 <am_hal_clkgen_sysclk_get>
     6da:	fba8 3100 	umull	r3, r1, r8, r0
     6de:	0c88      	lsrs	r0, r1, #18
     6e0:	f7ff ffc4 	bl	66c <am_hal_flash_delay>
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     6e4:	6833      	ldr	r3, [r6, #0]
     6e6:	402b      	ands	r3, r5
     6e8:	42a3      	cmp	r3, r4
    while ( ui32usMaxDelay-- )
     6ea:	f107 37ff 	add.w	r7, r7, #4294967295
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     6ee:	d02e      	beq.n	74e <am_hal_flash_delay_status_change+0xda>
        am_hal_flash_delay( FLASH_CYCLES_US(1) );
     6f0:	f7ff ffa6 	bl	640 <am_hal_clkgen_sysclk_get>
     6f4:	fba8 3200 	umull	r3, r2, r8, r0
     6f8:	0c90      	lsrs	r0, r2, #18
     6fa:	f7ff ffb7 	bl	66c <am_hal_flash_delay>
    while ( ui32usMaxDelay-- )
     6fe:	b34f      	cbz	r7, 754 <am_hal_flash_delay_status_change+0xe0>
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     700:	6830      	ldr	r0, [r6, #0]
     702:	4028      	ands	r0, r5
     704:	42a0      	cmp	r0, r4
    while ( ui32usMaxDelay-- )
     706:	f1a7 0704 	sub.w	r7, r7, #4
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     70a:	d020      	beq.n	74e <am_hal_flash_delay_status_change+0xda>
        am_hal_flash_delay( FLASH_CYCLES_US(1) );
     70c:	f7ff ff98 	bl	640 <am_hal_clkgen_sysclk_get>
     710:	fba8 3100 	umull	r3, r1, r8, r0
     714:	0c88      	lsrs	r0, r1, #18
     716:	f7ff ffa9 	bl	66c <am_hal_flash_delay>
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     71a:	6833      	ldr	r3, [r6, #0]
     71c:	402b      	ands	r3, r5
     71e:	42a3      	cmp	r3, r4
     720:	d015      	beq.n	74e <am_hal_flash_delay_status_change+0xda>
        am_hal_flash_delay( FLASH_CYCLES_US(1) );
     722:	f7ff ff8d 	bl	640 <am_hal_clkgen_sysclk_get>
     726:	fba8 3200 	umull	r3, r2, r8, r0
     72a:	0c90      	lsrs	r0, r2, #18
     72c:	f7ff ff9e 	bl	66c <am_hal_flash_delay>
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     730:	6830      	ldr	r0, [r6, #0]
     732:	4028      	ands	r0, r5
     734:	42a0      	cmp	r0, r4
     736:	d00a      	beq.n	74e <am_hal_flash_delay_status_change+0xda>
        am_hal_flash_delay( FLASH_CYCLES_US(1) );
     738:	f7ff ff82 	bl	640 <am_hal_clkgen_sysclk_get>
     73c:	fba8 3100 	umull	r3, r1, r8, r0
     740:	0c88      	lsrs	r0, r1, #18
     742:	f7ff ff93 	bl	66c <am_hal_flash_delay>
        if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
     746:	6833      	ldr	r3, [r6, #0]
     748:	402b      	ands	r3, r5
     74a:	42a3      	cmp	r3, r4
     74c:	d1d0      	bne.n	6f0 <am_hal_flash_delay_status_change+0x7c>
            return 1;
     74e:	2001      	movs	r0, #1
     750:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    }

    return 0;
     754:	2000      	movs	r0, #0
     756:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
     75a:	2000      	movs	r0, #0
} // am_hal_flash_delay_status_change()
     75c:	4770      	bx	lr
     75e:	bf00      	nop
     760:	165e9f81 	.word	0x165e9f81

00000764 <am_hal_gpio_int_clear>:
am_hal_gpio_int_clear(uint64_t ui64Interrupt)
{
    //
    // Clear the interrupts.
    //
    AM_REG(GPIO, INT1CLR) = (ui64Interrupt >> 32);
     764:	4a02      	ldr	r2, [pc, #8]	; (770 <am_hal_gpio_int_clear+0xc>)
    AM_REG(GPIO, INT0CLR) = (ui64Interrupt & 0xFFFFFFFF);
     766:	4b03      	ldr	r3, [pc, #12]	; (774 <am_hal_gpio_int_clear+0x10>)
    AM_REG(GPIO, INT1CLR) = (ui64Interrupt >> 32);
     768:	6011      	str	r1, [r2, #0]
    AM_REG(GPIO, INT0CLR) = (ui64Interrupt & 0xFFFFFFFF);
     76a:	6018      	str	r0, [r3, #0]
     76c:	4770      	bx	lr
     76e:	bf00      	nop
     770:	40010218 	.word	0x40010218
     774:	40010208 	.word	0x40010208

00000778 <am_hal_gpio_int_status_get>:
//! @return None
//
//*****************************************************************************
uint64_t
am_hal_gpio_int_status_get(bool bEnabledOnly)
{
     778:	b470      	push	{r4, r5, r6}
    uint64_t u64RetVal, u64Mask;
    //
    // Combine upper or lower GPIO words into one 64 bit return value.
    //
    if (bEnabledOnly)
     77a:	b930      	cbnz	r0, 78a <am_hal_gpio_int_status_get+0x12>
        u64Mask   |= ((uint64_t) AM_REGn(GPIO, 0, INT0STAT)) << 0;
        return u64RetVal & u64Mask;
    }
    else
    {
        u64RetVal  = ((uint64_t) AM_REGn(GPIO, 0, INT1STAT)) << 32;
     77c:	4a0b      	ldr	r2, [pc, #44]	; (7ac <am_hal_gpio_int_status_get+0x34>)
        u64RetVal |= ((uint64_t) AM_REGn(GPIO, 0, INT0STAT)) << 0;
     77e:	4b0c      	ldr	r3, [pc, #48]	; (7b0 <am_hal_gpio_int_status_get+0x38>)
        u64RetVal  = ((uint64_t) AM_REGn(GPIO, 0, INT1STAT)) << 32;
     780:	6811      	ldr	r1, [r2, #0]
        u64RetVal |= ((uint64_t) AM_REGn(GPIO, 0, INT0STAT)) << 0;
     782:	681c      	ldr	r4, [r3, #0]
     784:	4320      	orrs	r0, r4
        return u64RetVal;
    }
}
     786:	bc70      	pop	{r4, r5, r6}
     788:	4770      	bx	lr
        u64RetVal  = ((uint64_t) AM_REGn(GPIO, 0, INT1EN)) << 32;
     78a:	4d0a      	ldr	r5, [pc, #40]	; (7b4 <am_hal_gpio_int_status_get+0x3c>)
        u64RetVal |= ((uint64_t) AM_REGn(GPIO, 0, INT0EN)) << 0;
     78c:	4e0a      	ldr	r6, [pc, #40]	; (7b8 <am_hal_gpio_int_status_get+0x40>)
        u64Mask    = ((uint64_t) AM_REGn(GPIO, 0, INT1STAT)) << 32;
     78e:	4c07      	ldr	r4, [pc, #28]	; (7ac <am_hal_gpio_int_status_get+0x34>)
        u64Mask   |= ((uint64_t) AM_REGn(GPIO, 0, INT0STAT)) << 0;
     790:	4a07      	ldr	r2, [pc, #28]	; (7b0 <am_hal_gpio_int_status_get+0x38>)
        u64RetVal  = ((uint64_t) AM_REGn(GPIO, 0, INT1EN)) << 32;
     792:	6829      	ldr	r1, [r5, #0]
        u64RetVal |= ((uint64_t) AM_REGn(GPIO, 0, INT0EN)) << 0;
     794:	6835      	ldr	r5, [r6, #0]
        u64Mask    = ((uint64_t) AM_REGn(GPIO, 0, INT1STAT)) << 32;
     796:	6823      	ldr	r3, [r4, #0]
        u64Mask   |= ((uint64_t) AM_REGn(GPIO, 0, INT0STAT)) << 0;
     798:	6816      	ldr	r6, [r2, #0]
        u64RetVal  = ((uint64_t) AM_REGn(GPIO, 0, INT1EN)) << 32;
     79a:	2000      	movs	r0, #0
        u64Mask    = ((uint64_t) AM_REGn(GPIO, 0, INT1STAT)) << 32;
     79c:	4602      	mov	r2, r0
        u64Mask   |= ((uint64_t) AM_REGn(GPIO, 0, INT0STAT)) << 0;
     79e:	4332      	orrs	r2, r6
        u64RetVal |= ((uint64_t) AM_REGn(GPIO, 0, INT0EN)) << 0;
     7a0:	4328      	orrs	r0, r5
        return u64RetVal & u64Mask;
     7a2:	4010      	ands	r0, r2
     7a4:	4019      	ands	r1, r3
}
     7a6:	bc70      	pop	{r4, r5, r6}
     7a8:	4770      	bx	lr
     7aa:	bf00      	nop
     7ac:	40010214 	.word	0x40010214
     7b0:	40010204 	.word	0x40010204
     7b4:	40010210 	.word	0x40010210
     7b8:	40010200 	.word	0x40010200

000007bc <am_hal_interrupt_master_disable>:
}
#elif defined(__GNUC_STDC_INLINE__)
uint32_t __attribute__((naked))
am_hal_interrupt_master_disable(void)
{
    __asm("    mrs     r0, PRIMASK");
     7bc:	f3ef 8010 	mrs	r0, PRIMASK
    __asm("    cpsid i");
     7c0:	b672      	cpsid	i
    __asm("    bx lr");
     7c2:	4770      	bx	lr

000007c4 <am_hal_interrupt_master_set>:
//*****************************************************************************
#if defined(__GNUC_STDC_INLINE__)
void __attribute__((naked))
am_hal_interrupt_master_set(uint32_t ui32InterruptState)
{
    __asm("    msr     PRIMASK, r0");
     7c4:	f380 8810 	msr	PRIMASK, r0
    __asm("    bx lr");
     7c8:	4770      	bx	lr
     7ca:	bf00      	nop

000007cc <am_hal_iom_sleeping_queue_flush>:
    uint32_t ui32Critical;

    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
     7cc:	2801      	cmp	r0, #1
     7ce:	d900      	bls.n	7d2 <am_hal_iom_sleeping_queue_flush+0x6>
     7d0:	4770      	bx	lr
{
     7d2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     7d4:	4f0c      	ldr	r7, [pc, #48]	; (808 <am_hal_iom_sleeping_queue_flush+0x3c>)
     7d6:	4e0d      	ldr	r6, [pc, #52]	; (80c <am_hal_iom_sleeping_queue_flush+0x40>)

        //
        // Check the queue and the IOM itself.
        //
        if ( (g_bIomBusy[ui32Module] == false) &&
            am_hal_queue_empty(&g_psIOMQueue[ui32Module]) )
     7d8:	eb00 0340 	add.w	r3, r0, r0, lsl #1
     7dc:	4604      	mov	r4, r0
     7de:	eb07 07c3 	add.w	r7, r7, r3, lsl #3
        ui32Critical = am_hal_interrupt_master_disable();
     7e2:	f7ff ffeb 	bl	7bc <am_hal_interrupt_master_disable>
        if ( (g_bIomBusy[ui32Module] == false) &&
     7e6:	5d31      	ldrb	r1, [r6, r4]
        ui32Critical = am_hal_interrupt_master_disable();
     7e8:	4605      	mov	r5, r0
        if ( (g_bIomBusy[ui32Module] == false) &&
     7ea:	b929      	cbnz	r1, 7f8 <am_hal_iom_sleeping_queue_flush+0x2c>
     7ec:	68ba      	ldr	r2, [r7, #8]
     7ee:	b91a      	cbnz	r2, 7f8 <am_hal_iom_sleeping_queue_flush+0x2c>
        //
        // End the critical section.
        //
        am_hal_interrupt_master_set(ui32Critical);
    }
}
     7f0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        am_hal_interrupt_master_set(ui32Critical);
     7f4:	f7ff bfe6 	b.w	7c4 <am_hal_interrupt_master_set>
            am_hal_sysctrl_sleep(AM_HAL_SYSCTRL_SLEEP_NORMAL);
     7f8:	2000      	movs	r0, #0
     7fa:	f001 f81d 	bl	1838 <am_hal_sysctrl_sleep>
        am_hal_interrupt_master_set(ui32Critical);
     7fe:	4628      	mov	r0, r5
     800:	f7ff ffe0 	bl	7c4 <am_hal_interrupt_master_set>
     804:	e7ed      	b.n	7e2 <am_hal_iom_sleeping_queue_flush+0x16>
     806:	bf00      	nop
     808:	1000135c 	.word	0x1000135c
     80c:	1000100c 	.word	0x1000100c

00000810 <am_hal_iom_i2c_read_nb.part.10>:
am_hal_iom_i2c_read_nb(uint32_t ui32Module, uint32_t ui32BusAddress,
     810:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     814:	b082      	sub	sp, #8
     816:	4604      	mov	r4, r0
     818:	4689      	mov	r9, r1
     81a:	4617      	mov	r7, r2
     81c:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
     820:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
    am_hal_debug_assert_msg(ui32NumBytes > 0,
     822:	461d      	mov	r5, r3
     824:	2b00      	cmp	r3, #0
     826:	d056      	beq.n	8d6 <am_hal_iom_i2c_read_nb.part.10+0xc6>
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
     828:	2802      	cmp	r0, #2
     82a:	d05c      	beq.n	8e6 <am_hal_iom_i2c_read_nb.part.10+0xd6>
    am_hal_debug_assert_msg(ui32NumBytes < 256, "I2C transfer too big.");
     82c:	2bff      	cmp	r3, #255	; 0xff
     82e:	d81a      	bhi.n	866 <am_hal_iom_i2c_read_nb.part.10+0x56>
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
     830:	2c01      	cmp	r4, #1
     832:	d920      	bls.n	876 <am_hal_iom_i2c_read_nb.part.10+0x66>
    AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
     834:	f504 23a0 	add.w	r3, r4, #327680	; 0x50000
    g_bIomBusy[ui32Module] = true;
     838:	4a43      	ldr	r2, [pc, #268]	; (948 <am_hal_iom_i2c_read_nb.part.10+0x138>)
    g_psIOMBuffers[ui32Module].ui32State = BUFFER_RECEIVING;
     83a:	4944      	ldr	r1, [pc, #272]	; (94c <am_hal_iom_i2c_read_nb.part.10+0x13c>)
    g_bIomBusy[ui32Module] = true;
     83c:	2001      	movs	r0, #1
    AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
     83e:	3304      	adds	r3, #4
    g_bIomBusy[ui32Module] = true;
     840:	5510      	strb	r0, [r2, r4]
    AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
     842:	031b      	lsls	r3, r3, #12
    g_psIOMBuffers[ui32Module].ui32State = BUFFER_RECEIVING;
     844:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
     848:	f8d3 2208 	ldr.w	r2, [r3, #520]	; 0x208
    g_psIOMBuffers[ui32Module].ui32State = BUFFER_RECEIVING;
     84c:	00a4      	lsls	r4, r4, #2
    AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
     84e:	4302      	orrs	r2, r0
     850:	f8c3 2208 	str.w	r2, [r3, #520]	; 0x208
    g_psIOMBuffers[ui32Module].ui32State = BUFFER_RECEIVING;
     854:	2002      	movs	r0, #2
     856:	190b      	adds	r3, r1, r4
     858:	5108      	str	r0, [r1, r4]
    g_psIOMBuffers[ui32Module].pui32Data = pui32Data;
     85a:	605f      	str	r7, [r3, #4]
    g_psIOMBuffers[ui32Module].ui32BytesLeft = ui32NumBytes;
     85c:	609d      	str	r5, [r3, #8]
    g_psIOMBuffers[ui32Module].pfnCallback = pfnCallback;
     85e:	611e      	str	r6, [r3, #16]
}
     860:	b002      	add	sp, #8
     862:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    am_hal_debug_assert_msg(ui32NumBytes < 256, "I2C transfer too big.");
     866:	4a3a      	ldr	r2, [pc, #232]	; (950 <am_hal_iom_i2c_read_nb.part.10+0x140>)
     868:	483a      	ldr	r0, [pc, #232]	; (954 <am_hal_iom_i2c_read_nb.part.10+0x144>)
     86a:	f240 710a 	movw	r1, #1802	; 0x70a
     86e:	f000 ffff 	bl	1870 <am_hal_debug_error>
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
     872:	2c01      	cmp	r4, #1
     874:	d8de      	bhi.n	834 <am_hal_iom_i2c_read_nb.part.10+0x24>
     876:	4b34      	ldr	r3, [pc, #208]	; (948 <am_hal_iom_i2c_read_nb.part.10+0x138>)
    while ( g_bIomBusy[ui32Module] );
     878:	5d1a      	ldrb	r2, [r3, r4]
     87a:	2a00      	cmp	r2, #0
     87c:	d1fc      	bne.n	878 <am_hal_iom_i2c_read_nb.part.10+0x68>
    AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
     87e:	f504 2aa0 	add.w	sl, r4, #327680	; 0x50000
     882:	f10a 0004 	add.w	r0, sl, #4
    g_bIomBusy[ui32Module] = true;
     886:	2101      	movs	r1, #1
     888:	5519      	strb	r1, [r3, r4]
    AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
     88a:	ea4f 3a00 	mov.w	sl, r0, lsl #12
    g_psIOMBuffers[ui32Module].ui32State = BUFFER_RECEIVING;
     88e:	eb04 0484 	add.w	r4, r4, r4, lsl #2
     892:	482e      	ldr	r0, [pc, #184]	; (94c <am_hal_iom_i2c_read_nb.part.10+0x13c>)
    AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
     894:	f8da 2208 	ldr.w	r2, [sl, #520]	; 0x208
    g_psIOMBuffers[ui32Module].ui32State = BUFFER_RECEIVING;
     898:	00a1      	lsls	r1, r4, #2
     89a:	1843      	adds	r3, r0, r1
    AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
     89c:	f042 0401 	orr.w	r4, r2, #1
    g_psIOMBuffers[ui32Module].ui32State = BUFFER_RECEIVING;
     8a0:	2202      	movs	r2, #2
    AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
     8a2:	f8ca 4208 	str.w	r4, [sl, #520]	; 0x208
    g_psIOMBuffers[ui32Module].ui32State = BUFFER_RECEIVING;
     8a6:	5042      	str	r2, [r0, r1]
    g_psIOMBuffers[ui32Module].pui32Data = pui32Data;
     8a8:	605f      	str	r7, [r3, #4]
    g_psIOMBuffers[ui32Module].ui32BytesLeft = ui32NumBytes;
     8aa:	609d      	str	r5, [r3, #8]
    g_psIOMBuffers[ui32Module].pfnCallback = pfnCallback;
     8ac:	611e      	str	r6, [r3, #16]
    am_hal_debug_assert_msg(ui32NumBytes > 0,
     8ae:	2d00      	cmp	r5, #0
     8b0:	d043      	beq.n	93a <am_hal_iom_i2c_read_nb.part.10+0x12a>
    ui32Command |= ((ui32BusAddress << 16) & 0x03FF0000);
     8b2:	4f29      	ldr	r7, [pc, #164]	; (958 <am_hal_iom_i2c_read_nb.part.10+0x148>)
    ui32Command |= (ui32Options & 0x5C00FF00);
     8b4:	f028 4623 	bic.w	r6, r8, #2734686208	; 0xa3000000
     8b8:	f006 20ff 	and.w	r0, r6, #4278255360	; 0xff00ff00
    ui32Command |= ((ui32BusAddress << 16) & 0x03FF0000);
     8bc:	ea07 4109 	and.w	r1, r7, r9, lsl #16
    ui32Command |= (ui32Options & 0x5C00FF00);
     8c0:	ea41 0c00 	orr.w	ip, r1, r0
     8c4:	f04c 4300 	orr.w	r3, ip, #2147483648	; 0x80000000
    ui32Command |= (ui32NumBytes & 0xFF);
     8c8:	b2ed      	uxtb	r5, r5
    ui32Command |= (ui32Options & 0x5C00FF00);
     8ca:	431d      	orrs	r5, r3
    AM_REGn(IOMSTR, ui32Module, CMD) = ui32Command;
     8cc:	f8ca 5110 	str.w	r5, [sl, #272]	; 0x110
}
     8d0:	b002      	add	sp, #8
     8d2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    am_hal_debug_assert_msg(ui32NumBytes > 0,
     8d6:	4a21      	ldr	r2, [pc, #132]	; (95c <am_hal_iom_i2c_read_nb.part.10+0x14c>)
     8d8:	481e      	ldr	r0, [pc, #120]	; (954 <am_hal_iom_i2c_read_nb.part.10+0x144>)
     8da:	f44f 61dc 	mov.w	r1, #1760	; 0x6e0
     8de:	f000 ffc7 	bl	1870 <am_hal_debug_error>
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
     8e2:	2c02      	cmp	r4, #2
     8e4:	d1a4      	bne.n	830 <am_hal_iom_i2c_read_nb.part.10+0x20>
        if ( ui32Options & AM_HAL_IOM_RAW )
     8e6:	f018 4f80 	tst.w	r8, #1073741824	; 0x40000000
     8ea:	d015      	beq.n	918 <am_hal_iom_i2c_read_nb.part.10+0x108>
            am_hal_i2c_bit_bang_receive((ui32BusAddress << 1) | 1, ui32NumBytes,
     8ec:	ea4f 0e49 	mov.w	lr, r9, lsl #1
     8f0:	f3c8 7100 	ubfx	r1, r8, #28, #1
     8f4:	f04e 0901 	orr.w	r9, lr, #1
     8f8:	2300      	movs	r3, #0
     8fa:	9101      	str	r1, [sp, #4]
     8fc:	fa5f f089 	uxtb.w	r0, r9
     900:	463a      	mov	r2, r7
     902:	4629      	mov	r1, r5
     904:	9300      	str	r3, [sp, #0]
     906:	f000 ffb5 	bl	1874 <am_hal_i2c_bit_bang_receive>
        if ( pfnCallback )
     90a:	2e00      	cmp	r6, #0
     90c:	d0a8      	beq.n	860 <am_hal_iom_i2c_read_nb.part.10+0x50>
            pfnCallback();
     90e:	46b4      	mov	ip, r6
}
     910:	b002      	add	sp, #8
     912:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
            pfnCallback();
     916:	4760      	bx	ip
            am_hal_i2c_bit_bang_receive((ui32BusAddress << 1) | 1, ui32NumBytes,
     918:	ea4f 0149 	mov.w	r1, r9, lsl #1
     91c:	f041 0201 	orr.w	r2, r1, #1
     920:	f3c8 7300 	ubfx	r3, r8, #28, #1
     924:	2401      	movs	r4, #1
     926:	9301      	str	r3, [sp, #4]
     928:	b2d0      	uxtb	r0, r2
     92a:	4629      	mov	r1, r5
     92c:	463a      	mov	r2, r7
     92e:	f3c8 2307 	ubfx	r3, r8, #8, #8
     932:	9400      	str	r4, [sp, #0]
     934:	f000 ff9e 	bl	1874 <am_hal_i2c_bit_bang_receive>
     938:	e7e7      	b.n	90a <am_hal_iom_i2c_read_nb.part.10+0xfa>
    am_hal_debug_assert_msg(ui32NumBytes > 0,
     93a:	4a08      	ldr	r2, [pc, #32]	; (95c <am_hal_iom_i2c_read_nb.part.10+0x14c>)
     93c:	4805      	ldr	r0, [pc, #20]	; (954 <am_hal_iom_i2c_read_nb.part.10+0x144>)
     93e:	f240 714d 	movw	r1, #1869	; 0x74d
     942:	f000 ff95 	bl	1870 <am_hal_debug_error>
     946:	e7b4      	b.n	8b2 <am_hal_iom_i2c_read_nb.part.10+0xa2>
     948:	1000100c 	.word	0x1000100c
     94c:	10001334 	.word	0x10001334
     950:	0000443c 	.word	0x0000443c
     954:	00004428 	.word	0x00004428
     958:	03ff0000 	.word	0x03ff0000
     95c:	00004404 	.word	0x00004404

00000960 <am_hal_iom_i2c_write_nq.part.7>:
am_hal_iom_i2c_write_nq(uint32_t ui32Module, uint32_t ui32BusAddress,
     960:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     964:	4606      	mov	r6, r0
     966:	b085      	sub	sp, #20
     968:	468b      	mov	fp, r1
     96a:	4617      	mov	r7, r2
    am_hal_debug_assert_msg(ui32NumBytes > 0,
     96c:	2b00      	cmp	r3, #0
     96e:	f000 8154 	beq.w	c1a <am_hal_iom_i2c_write_nq.part.7+0x2ba>
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
     972:	2802      	cmp	r0, #2
     974:	f000 815c 	beq.w	c30 <am_hal_iom_i2c_write_nq.part.7+0x2d0>
    am_hal_debug_assert_msg(ui32NumBytes < 256, "I2C transfer too big.");
     978:	2bff      	cmp	r3, #255	; 0xff
     97a:	f200 80bc 	bhi.w	af6 <am_hal_iom_i2c_write_nq.part.7+0x196>
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
     97e:	2e01      	cmp	r6, #1
     980:	f240 80c4 	bls.w	b0c <am_hal_iom_i2c_write_nq.part.7+0x1ac>
    ui32IntConfig = AM_REGn(IOMSTR, ui32Module, INTEN);
     984:	f506 24a0 	add.w	r4, r6, #327680	; 0x50000
     988:	3404      	adds	r4, #4
     98a:	0324      	lsls	r4, r4, #12
    AM_REGn(IOMSTR, ui32Module, INTEN) = 0;
     98c:	2500      	movs	r5, #0
    ui32IntConfig = AM_REGn(IOMSTR, ui32Module, INTEN);
     98e:	f8d4 8200 	ldr.w	r8, [r4, #512]	; 0x200
    AM_REGn(IOMSTR, ui32Module, INTEN) = 0;
     992:	f8c4 5200 	str.w	r5, [r4, #512]	; 0x200
    AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
     996:	f8d4 2208 	ldr.w	r2, [r4, #520]	; 0x208
    ui32TransferSize = (ui32NumBytes <= AM_HAL_IOM_MAX_FIFO_SIZE ? ui32NumBytes :
     99a:	2b40      	cmp	r3, #64	; 0x40
    AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
     99c:	f042 0101 	orr.w	r1, r2, #1
    ui32TransferSize = (ui32NumBytes <= AM_HAL_IOM_MAX_FIFO_SIZE ? ui32NumBytes :
     9a0:	461d      	mov	r5, r3
    AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
     9a2:	f8c4 1208 	str.w	r1, [r4, #520]	; 0x208
    ui32IntConfig = AM_REGn(IOMSTR, ui32Module, INTEN);
     9a6:	f504 7900 	add.w	r9, r4, #512	; 0x200
    AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
     9aa:	f504 7a02 	add.w	sl, r4, #520	; 0x208
    ui32TransferSize = (ui32NumBytes <= AM_HAL_IOM_MAX_FIFO_SIZE ? ui32NumBytes :
     9ae:	bf28      	it	cs
     9b0:	2540      	movcs	r5, #64	; 0x40
    pui32Data += ui32TransferSize >> 2;
     9b2:	f025 0e03 	bic.w	lr, r5, #3
    while ( ui32NumBytes && !AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP) )
     9b6:	1b5b      	subs	r3, r3, r5
    pui32Data += ui32TransferSize >> 2;
     9b8:	4477      	add	r7, lr
     9ba:	bf08      	it	eq
     9bc:	f504 7b01 	addeq.w	fp, r4, #516	; 0x204
    while ( ui32NumBytes && !AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP) )
     9c0:	d07e      	beq.n	ac0 <am_hal_iom_i2c_write_nq.part.7+0x160>
     9c2:	f8d4 0204 	ldr.w	r0, [r4, #516]	; 0x204
     9c6:	07c1      	lsls	r1, r0, #31
     9c8:	f504 7b01 	add.w	fp, r4, #516	; 0x204
     9cc:	d478      	bmi.n	ac0 <am_hal_iom_i2c_write_nq.part.7+0x160>
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
     9ce:	46d4      	mov	ip, sl
     9d0:	46c2      	mov	sl, r8
     9d2:	4698      	mov	r8, r3
     9d4:	4663      	mov	r3, ip
     9d6:	e003      	b.n	9e0 <am_hal_iom_i2c_write_nq.part.7+0x80>
    while ( ui32NumBytes && !AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP) )
     9d8:	f8db 2000 	ldr.w	r2, [fp]
     9dc:	07d2      	lsls	r2, r2, #31
     9de:	d46d      	bmi.n	abc <am_hal_iom_i2c_write_nq.part.7+0x15c>
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
     9e0:	2e01      	cmp	r6, #1
     9e2:	d8f9      	bhi.n	9d8 <am_hal_iom_i2c_write_nq.part.7+0x78>
    return (AM_HAL_IOM_MAX_FIFO_SIZE - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
     9e4:	f8d4 5100 	ldr.w	r5, [r4, #256]	; 0x100
     9e8:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
     9ec:	f005 017f 	and.w	r1, r5, #127	; 0x7f
     9f0:	f1c1 0040 	rsb	r0, r1, #64	; 0x40
        ui32SpaceInFifo =  am_hal_iom_fifo_empty_slots(ui32Module);
     9f4:	f000 05fc 	and.w	r5, r0, #252	; 0xfc
    return (AM_HAL_IOM_MAX_FIFO_SIZE - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
     9f8:	f002 0e7f 	and.w	lr, r2, #127	; 0x7f
     9fc:	4545      	cmp	r5, r8
     9fe:	f1ce 0c40 	rsb	ip, lr, #64	; 0x40
     a02:	bf28      	it	cs
     a04:	4645      	movcs	r5, r8
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
     a06:	f00c 02fc 	and.w	r2, ip, #252	; 0xfc
     a0a:	4295      	cmp	r5, r2
     a0c:	f200 8126 	bhi.w	c5c <am_hal_iom_i2c_write_nq.part.7+0x2fc>
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
     a10:	2d00      	cmp	r5, #0
     a12:	d0e1      	beq.n	9d8 <am_hal_iom_i2c_write_nq.part.7+0x78>
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
     a14:	463a      	mov	r2, r7
     a16:	43f9      	mvns	r1, r7
     a18:	f852 0b04 	ldr.w	r0, [r2], #4
     a1c:	6020      	str	r0, [r4, #0]
     a1e:	4439      	add	r1, r7
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
     a20:	1bd0      	subs	r0, r2, r7
     a22:	4429      	add	r1, r5
     a24:	42a8      	cmp	r0, r5
     a26:	f3c1 0182 	ubfx	r1, r1, #2, #3
     a2a:	d241      	bcs.n	ab0 <am_hal_iom_i2c_write_nq.part.7+0x150>
     a2c:	b319      	cbz	r1, a76 <am_hal_iom_i2c_write_nq.part.7+0x116>
     a2e:	2901      	cmp	r1, #1
     a30:	d01b      	beq.n	a6a <am_hal_iom_i2c_write_nq.part.7+0x10a>
     a32:	2902      	cmp	r1, #2
     a34:	d016      	beq.n	a64 <am_hal_iom_i2c_write_nq.part.7+0x104>
     a36:	2903      	cmp	r1, #3
     a38:	d011      	beq.n	a5e <am_hal_iom_i2c_write_nq.part.7+0xfe>
     a3a:	2904      	cmp	r1, #4
     a3c:	d00c      	beq.n	a58 <am_hal_iom_i2c_write_nq.part.7+0xf8>
     a3e:	2905      	cmp	r1, #5
     a40:	d007      	beq.n	a52 <am_hal_iom_i2c_write_nq.part.7+0xf2>
     a42:	2906      	cmp	r1, #6
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
     a44:	bf1c      	itt	ne
     a46:	f852 1b04 	ldrne.w	r1, [r2], #4
     a4a:	6021      	strne	r1, [r4, #0]
     a4c:	f852 0b04 	ldr.w	r0, [r2], #4
     a50:	6020      	str	r0, [r4, #0]
     a52:	f852 1b04 	ldr.w	r1, [r2], #4
     a56:	6021      	str	r1, [r4, #0]
     a58:	f852 0b04 	ldr.w	r0, [r2], #4
     a5c:	6020      	str	r0, [r4, #0]
     a5e:	f852 1b04 	ldr.w	r1, [r2], #4
     a62:	6021      	str	r1, [r4, #0]
     a64:	f852 0b04 	ldr.w	r0, [r2], #4
     a68:	6020      	str	r0, [r4, #0]
     a6a:	f852 1b04 	ldr.w	r1, [r2], #4
     a6e:	6021      	str	r1, [r4, #0]
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
     a70:	1bd0      	subs	r0, r2, r7
     a72:	42a8      	cmp	r0, r5
     a74:	d21c      	bcs.n	ab0 <am_hal_iom_i2c_write_nq.part.7+0x150>
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
     a76:	4696      	mov	lr, r2
     a78:	3220      	adds	r2, #32
     a7a:	f85e 1b04 	ldr.w	r1, [lr], #4
     a7e:	6021      	str	r1, [r4, #0]
     a80:	f852 0c1c 	ldr.w	r0, [r2, #-28]
     a84:	6020      	str	r0, [r4, #0]
     a86:	f8de 1004 	ldr.w	r1, [lr, #4]
     a8a:	6021      	str	r1, [r4, #0]
     a8c:	f852 0c14 	ldr.w	r0, [r2, #-20]
     a90:	6020      	str	r0, [r4, #0]
     a92:	f852 1c10 	ldr.w	r1, [r2, #-16]
     a96:	6021      	str	r1, [r4, #0]
     a98:	f852 0c0c 	ldr.w	r0, [r2, #-12]
     a9c:	6020      	str	r0, [r4, #0]
     a9e:	f852 1c08 	ldr.w	r1, [r2, #-8]
     aa2:	6021      	str	r1, [r4, #0]
     aa4:	f852 0c04 	ldr.w	r0, [r2, #-4]
     aa8:	6020      	str	r0, [r4, #0]
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
     aaa:	1bd1      	subs	r1, r2, r7
     aac:	42a9      	cmp	r1, r5
     aae:	d3e2      	bcc.n	a76 <am_hal_iom_i2c_write_nq.part.7+0x116>
        pui32Data += ui32TransferSize >> 2;
     ab0:	f025 0c03 	bic.w	ip, r5, #3
    while ( ui32NumBytes && !AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP) )
     ab4:	ebb8 0805 	subs.w	r8, r8, r5
        pui32Data += ui32TransferSize >> 2;
     ab8:	4467      	add	r7, ip
    while ( ui32NumBytes && !AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP) )
     aba:	d18d      	bne.n	9d8 <am_hal_iom_i2c_write_nq.part.7+0x78>
     abc:	46d0      	mov	r8, sl
     abe:	469a      	mov	sl, r3
    ui32Status = am_hal_flash_delay_status_change(ui32StatusTimeout[ui32Module],
     ac0:	4f7e      	ldr	r7, [pc, #504]	; (cbc <am_hal_iom_i2c_write_nq.part.7+0x35c>)
     ac2:	2301      	movs	r3, #1
     ac4:	f857 0026 	ldr.w	r0, [r7, r6, lsl #2]
     ac8:	4659      	mov	r1, fp
     aca:	461a      	mov	r2, r3
     acc:	f7ff fdd2 	bl	674 <am_hal_flash_delay_status_change>
    AM_REGn(IOMSTR, ui32Module, INTCLR) = (ui32IntConfig | AM_REG_IOMSTR_INTSTAT_CMDCMP_M);
     ad0:	f048 0601 	orr.w	r6, r8, #1
    am_hal_debug_assert_msg(ui32Status == 1, "IOM CMDCMP was not seen");
     ad4:	2801      	cmp	r0, #1
    AM_REGn(IOMSTR, ui32Module, INTCLR) = (ui32IntConfig | AM_REG_IOMSTR_INTSTAT_CMDCMP_M);
     ad6:	f8ca 6000 	str.w	r6, [sl]
    ui32Status = am_hal_flash_delay_status_change(ui32StatusTimeout[ui32Module],
     ada:	4604      	mov	r4, r0
    AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
     adc:	f8c9 8000 	str.w	r8, [r9]
    am_hal_debug_assert_msg(ui32Status == 1, "IOM CMDCMP was not seen");
     ae0:	d005      	beq.n	aee <am_hal_iom_i2c_write_nq.part.7+0x18e>
     ae2:	4a77      	ldr	r2, [pc, #476]	; (cc0 <am_hal_iom_i2c_write_nq.part.7+0x360>)
     ae4:	4877      	ldr	r0, [pc, #476]	; (cc4 <am_hal_iom_i2c_write_nq.part.7+0x364>)
     ae6:	f44f 6197 	mov.w	r1, #1208	; 0x4b8
     aea:	f000 fec1 	bl	1870 <am_hal_debug_error>
}
     aee:	4620      	mov	r0, r4
     af0:	b005      	add	sp, #20
     af2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    am_hal_debug_assert_msg(ui32NumBytes < 256, "I2C transfer too big.");
     af6:	4a74      	ldr	r2, [pc, #464]	; (cc8 <am_hal_iom_i2c_write_nq.part.7+0x368>)
     af8:	4872      	ldr	r0, [pc, #456]	; (cc4 <am_hal_iom_i2c_write_nq.part.7+0x364>)
     afa:	9303      	str	r3, [sp, #12]
     afc:	f240 415d 	movw	r1, #1117	; 0x45d
     b00:	f000 feb6 	bl	1870 <am_hal_debug_error>
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
     b04:	2e01      	cmp	r6, #1
    am_hal_debug_assert_msg(ui32NumBytes < 256, "I2C transfer too big.");
     b06:	9b03      	ldr	r3, [sp, #12]
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
     b08:	f63f af3c 	bhi.w	984 <am_hal_iom_i2c_write_nq.part.7+0x24>
     b0c:	486f      	ldr	r0, [pc, #444]	; (ccc <am_hal_iom_i2c_write_nq.part.7+0x36c>)
    while ( g_bIomBusy[ui32Module] );
     b0e:	5d82      	ldrb	r2, [r0, r6]
     b10:	f002 01ff 	and.w	r1, r2, #255	; 0xff
     b14:	2a00      	cmp	r2, #0
     b16:	d1fa      	bne.n	b0e <am_hal_iom_i2c_write_nq.part.7+0x1ae>
    ui32IntConfig = AM_REGn(IOMSTR, ui32Module, INTEN);
     b18:	f506 24a0 	add.w	r4, r6, #327680	; 0x50000
     b1c:	3404      	adds	r4, #4
     b1e:	0324      	lsls	r4, r4, #12
    ui32TransferSize = (ui32NumBytes <= AM_HAL_IOM_MAX_FIFO_SIZE ? ui32NumBytes :
     b20:	2b40      	cmp	r3, #64	; 0x40
    ui32IntConfig = AM_REGn(IOMSTR, ui32Module, INTEN);
     b22:	f8d4 8200 	ldr.w	r8, [r4, #512]	; 0x200
    AM_REGn(IOMSTR, ui32Module, INTEN) = 0;
     b26:	f8c4 1200 	str.w	r1, [r4, #512]	; 0x200
    AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
     b2a:	f8d4 0208 	ldr.w	r0, [r4, #520]	; 0x208
     b2e:	f040 0201 	orr.w	r2, r0, #1
     b32:	f8c4 2208 	str.w	r2, [r4, #520]	; 0x208
    return (AM_HAL_IOM_MAX_FIFO_SIZE - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
     b36:	f8d4 1100 	ldr.w	r1, [r4, #256]	; 0x100
     b3a:	f001 007f 	and.w	r0, r1, #127	; 0x7f
     b3e:	f1c0 0940 	rsb	r9, r0, #64	; 0x40
    ui32TransferSize = (ui32NumBytes <= AM_HAL_IOM_MAX_FIFO_SIZE ? ui32NumBytes :
     b42:	461d      	mov	r5, r3
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
     b44:	f009 0cfc 	and.w	ip, r9, #252	; 0xfc
    ui32TransferSize = (ui32NumBytes <= AM_HAL_IOM_MAX_FIFO_SIZE ? ui32NumBytes :
     b48:	bf28      	it	cs
     b4a:	2540      	movcs	r5, #64	; 0x40
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
     b4c:	45ac      	cmp	ip, r5
    ui32IntConfig = AM_REGn(IOMSTR, ui32Module, INTEN);
     b4e:	f504 7900 	add.w	r9, r4, #512	; 0x200
    AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
     b52:	f504 7a02 	add.w	sl, r4, #520	; 0x208
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
     b56:	f0c0 80a7 	bcc.w	ca8 <am_hal_iom_i2c_write_nq.part.7+0x348>
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
     b5a:	2d00      	cmp	r5, #0
     b5c:	d04d      	beq.n	bfa <am_hal_iom_i2c_write_nq.part.7+0x29a>
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
     b5e:	463a      	mov	r2, r7
     b60:	43f9      	mvns	r1, r7
     b62:	f852 0b04 	ldr.w	r0, [r2], #4
     b66:	6020      	str	r0, [r4, #0]
     b68:	4439      	add	r1, r7
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
     b6a:	1bd0      	subs	r0, r2, r7
     b6c:	4429      	add	r1, r5
     b6e:	42a8      	cmp	r0, r5
     b70:	f3c1 0182 	ubfx	r1, r1, #2, #3
     b74:	d241      	bcs.n	bfa <am_hal_iom_i2c_write_nq.part.7+0x29a>
     b76:	b319      	cbz	r1, bc0 <am_hal_iom_i2c_write_nq.part.7+0x260>
     b78:	2901      	cmp	r1, #1
     b7a:	d01b      	beq.n	bb4 <am_hal_iom_i2c_write_nq.part.7+0x254>
     b7c:	2902      	cmp	r1, #2
     b7e:	d016      	beq.n	bae <am_hal_iom_i2c_write_nq.part.7+0x24e>
     b80:	2903      	cmp	r1, #3
     b82:	d011      	beq.n	ba8 <am_hal_iom_i2c_write_nq.part.7+0x248>
     b84:	2904      	cmp	r1, #4
     b86:	d00c      	beq.n	ba2 <am_hal_iom_i2c_write_nq.part.7+0x242>
     b88:	2905      	cmp	r1, #5
     b8a:	d007      	beq.n	b9c <am_hal_iom_i2c_write_nq.part.7+0x23c>
     b8c:	2906      	cmp	r1, #6
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
     b8e:	bf1c      	itt	ne
     b90:	f852 1b04 	ldrne.w	r1, [r2], #4
     b94:	6021      	strne	r1, [r4, #0]
     b96:	f852 0b04 	ldr.w	r0, [r2], #4
     b9a:	6020      	str	r0, [r4, #0]
     b9c:	f852 1b04 	ldr.w	r1, [r2], #4
     ba0:	6021      	str	r1, [r4, #0]
     ba2:	f852 0b04 	ldr.w	r0, [r2], #4
     ba6:	6020      	str	r0, [r4, #0]
     ba8:	f852 1b04 	ldr.w	r1, [r2], #4
     bac:	6021      	str	r1, [r4, #0]
     bae:	f852 0b04 	ldr.w	r0, [r2], #4
     bb2:	6020      	str	r0, [r4, #0]
     bb4:	f852 1b04 	ldr.w	r1, [r2], #4
     bb8:	6021      	str	r1, [r4, #0]
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
     bba:	1bd0      	subs	r0, r2, r7
     bbc:	42a8      	cmp	r0, r5
     bbe:	d21c      	bcs.n	bfa <am_hal_iom_i2c_write_nq.part.7+0x29a>
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
     bc0:	4696      	mov	lr, r2
     bc2:	3220      	adds	r2, #32
     bc4:	f85e 1b04 	ldr.w	r1, [lr], #4
     bc8:	6021      	str	r1, [r4, #0]
     bca:	f852 0c1c 	ldr.w	r0, [r2, #-28]
     bce:	6020      	str	r0, [r4, #0]
     bd0:	f8de 1004 	ldr.w	r1, [lr, #4]
     bd4:	6021      	str	r1, [r4, #0]
     bd6:	f852 0c14 	ldr.w	r0, [r2, #-20]
     bda:	6020      	str	r0, [r4, #0]
     bdc:	f852 1c10 	ldr.w	r1, [r2, #-16]
     be0:	6021      	str	r1, [r4, #0]
     be2:	f852 0c0c 	ldr.w	r0, [r2, #-12]
     be6:	6020      	str	r0, [r4, #0]
     be8:	f852 1c08 	ldr.w	r1, [r2, #-8]
     bec:	6021      	str	r1, [r4, #0]
     bee:	f852 0c04 	ldr.w	r0, [r2, #-4]
     bf2:	6020      	str	r0, [r4, #0]
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
     bf4:	1bd1      	subs	r1, r2, r7
     bf6:	42a9      	cmp	r1, r5
     bf8:	d3e2      	bcc.n	bc0 <am_hal_iom_i2c_write_nq.part.7+0x260>
    am_hal_debug_assert_msg(ui32NumBytes > 0,
     bfa:	2b00      	cmp	r3, #0
     bfc:	d04b      	beq.n	c96 <am_hal_iom_i2c_write_nq.part.7+0x336>
    ui32Command |= (ui32Options & 0x5C00FF00);
     bfe:	980e      	ldr	r0, [sp, #56]	; 0x38
    ui32Command |= ((ui32BusAddress << 16) & 0x03FF0000);
     c00:	4a33      	ldr	r2, [pc, #204]	; (cd0 <am_hal_iom_i2c_write_nq.part.7+0x370>)
    ui32Command |= (ui32Options & 0x5C00FF00);
     c02:	f020 4c23 	bic.w	ip, r0, #2734686208	; 0xa3000000
    ui32Command |= ((ui32BusAddress << 16) & 0x03FF0000);
     c06:	ea02 420b 	and.w	r2, r2, fp, lsl #16
    ui32Command |= (ui32Options & 0x5C00FF00);
     c0a:	f00c 21ff 	and.w	r1, ip, #4278255360	; 0xff00ff00
     c0e:	430a      	orrs	r2, r1
    ui32Command |= (ui32NumBytes & 0xFF);
     c10:	b2d8      	uxtb	r0, r3
    ui32Command |= (ui32Options & 0x5C00FF00);
     c12:	4302      	orrs	r2, r0
    AM_REGn(IOMSTR, ui32Module, CMD) = ui32Command;
     c14:	f8c4 2110 	str.w	r2, [r4, #272]	; 0x110
     c18:	e6cb      	b.n	9b2 <am_hal_iom_i2c_write_nq.part.7+0x52>
    am_hal_debug_assert_msg(ui32NumBytes > 0,
     c1a:	4a2e      	ldr	r2, [pc, #184]	; (cd4 <am_hal_iom_i2c_write_nq.part.7+0x374>)
     c1c:	4829      	ldr	r0, [pc, #164]	; (cc4 <am_hal_iom_i2c_write_nq.part.7+0x364>)
     c1e:	9303      	str	r3, [sp, #12]
     c20:	f240 413d 	movw	r1, #1085	; 0x43d
     c24:	f000 fe24 	bl	1870 <am_hal_debug_error>
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
     c28:	2e02      	cmp	r6, #2
     c2a:	9b03      	ldr	r3, [sp, #12]
     c2c:	f47f aea7 	bne.w	97e <am_hal_iom_i2c_write_nq.part.7+0x1e>
        if ( ui32Options & AM_HAL_IOM_RAW )
     c30:	9d0e      	ldr	r5, [sp, #56]	; 0x38
     c32:	f015 4480 	ands.w	r4, r5, #1073741824	; 0x40000000
     c36:	d01a      	beq.n	c6e <am_hal_iom_i2c_write_nq.part.7+0x30e>
            am_hal_i2c_bit_bang_send(ui32BusAddress << 1, ui32NumBytes,
     c38:	2400      	movs	r4, #0
     c3a:	ea4f 094b 	mov.w	r9, fp, lsl #1
     c3e:	f3c5 7500 	ubfx	r5, r5, #28, #1
     c42:	4619      	mov	r1, r3
     c44:	f009 00fe 	and.w	r0, r9, #254	; 0xfe
     c48:	463a      	mov	r2, r7
     c4a:	e88d 0030 	stmia.w	sp, {r4, r5}
     c4e:	4623      	mov	r3, r4
     c50:	f001 fa62 	bl	2118 <am_hal_i2c_bit_bang_send>
}
     c54:	4620      	mov	r0, r4
     c56:	b005      	add	sp, #20
     c58:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
     c5c:	4a1e      	ldr	r2, [pc, #120]	; (cd8 <am_hal_iom_i2c_write_nq.part.7+0x378>)
     c5e:	4819      	ldr	r0, [pc, #100]	; (cc4 <am_hal_iom_i2c_write_nq.part.7+0x364>)
     c60:	9303      	str	r3, [sp, #12]
     c62:	f240 71d6 	movw	r1, #2006	; 0x7d6
     c66:	f000 fe03 	bl	1870 <am_hal_debug_error>
     c6a:	9b03      	ldr	r3, [sp, #12]
     c6c:	e6d2      	b.n	a14 <am_hal_iom_i2c_write_nq.part.7+0xb4>
            am_hal_i2c_bit_bang_send(ui32BusAddress << 1, ui32NumBytes,
     c6e:	4619      	mov	r1, r3
     c70:	9b0e      	ldr	r3, [sp, #56]	; 0x38
     c72:	f3c5 7600 	ubfx	r6, r5, #28, #1
     c76:	ea4f 0b4b 	mov.w	fp, fp, lsl #1
     c7a:	2501      	movs	r5, #1
     c7c:	f00b 00fe 	and.w	r0, fp, #254	; 0xfe
     c80:	463a      	mov	r2, r7
     c82:	e88d 0060 	stmia.w	sp, {r5, r6}
     c86:	f3c3 2307 	ubfx	r3, r3, #8, #8
     c8a:	f001 fa45 	bl	2118 <am_hal_i2c_bit_bang_send>
}
     c8e:	4620      	mov	r0, r4
     c90:	b005      	add	sp, #20
     c92:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    am_hal_debug_assert_msg(ui32NumBytes > 0,
     c96:	4a0f      	ldr	r2, [pc, #60]	; (cd4 <am_hal_iom_i2c_write_nq.part.7+0x374>)
     c98:	480a      	ldr	r0, [pc, #40]	; (cc4 <am_hal_iom_i2c_write_nq.part.7+0x364>)
     c9a:	9303      	str	r3, [sp, #12]
     c9c:	f240 714d 	movw	r1, #1869	; 0x74d
     ca0:	f000 fde6 	bl	1870 <am_hal_debug_error>
     ca4:	9b03      	ldr	r3, [sp, #12]
     ca6:	e7aa      	b.n	bfe <am_hal_iom_i2c_write_nq.part.7+0x29e>
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
     ca8:	4a0b      	ldr	r2, [pc, #44]	; (cd8 <am_hal_iom_i2c_write_nq.part.7+0x378>)
     caa:	4806      	ldr	r0, [pc, #24]	; (cc4 <am_hal_iom_i2c_write_nq.part.7+0x364>)
     cac:	9303      	str	r3, [sp, #12]
     cae:	f240 71d6 	movw	r1, #2006	; 0x7d6
     cb2:	f000 fddd 	bl	1870 <am_hal_debug_error>
     cb6:	9b03      	ldr	r3, [sp, #12]
     cb8:	e751      	b.n	b5e <am_hal_iom_i2c_write_nq.part.7+0x1fe>
     cba:	bf00      	nop
     cbc:	10001004 	.word	0x10001004
     cc0:	0000448c 	.word	0x0000448c
     cc4:	00004428 	.word	0x00004428
     cc8:	0000443c 	.word	0x0000443c
     ccc:	1000100c 	.word	0x1000100c
     cd0:	03ff0000 	.word	0x03ff0000
     cd4:	00004404 	.word	0x00004404
     cd8:	00004530 	.word	0x00004530

00000cdc <am_hal_iom_i2c_write_nb.part.9>:
am_hal_iom_i2c_write_nb(uint32_t ui32Module, uint32_t ui32BusAddress,
     cdc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     ce0:	b083      	sub	sp, #12
     ce2:	4604      	mov	r4, r0
     ce4:	4689      	mov	r9, r1
     ce6:	4617      	mov	r7, r2
     ce8:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
     cec:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
    am_hal_debug_assert_msg(ui32NumBytes > 0,
     cf0:	461d      	mov	r5, r3
     cf2:	2b00      	cmp	r3, #0
     cf4:	f000 80b1 	beq.w	e5a <am_hal_iom_i2c_write_nb.part.9+0x17e>
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
     cf8:	2802      	cmp	r0, #2
     cfa:	f000 80b7 	beq.w	e6c <am_hal_iom_i2c_write_nb.part.9+0x190>
    am_hal_debug_assert_msg(ui32NumBytes < 256, "I2C transfer too big.");
     cfe:	2bff      	cmp	r3, #255	; 0xff
     d00:	d810      	bhi.n	d24 <am_hal_iom_i2c_write_nb.part.9+0x48>
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
     d02:	2c01      	cmp	r4, #1
     d04:	d916      	bls.n	d34 <am_hal_iom_i2c_write_nb.part.9+0x58>
    AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
     d06:	f504 26a0 	add.w	r6, r4, #327680	; 0x50000
    g_bIomBusy[ui32Module] = true;
     d0a:	4f74      	ldr	r7, [pc, #464]	; (edc <am_hal_iom_i2c_write_nb.part.9+0x200>)
     d0c:	2001      	movs	r0, #1
    AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
     d0e:	3604      	adds	r6, #4
     d10:	0333      	lsls	r3, r6, #12
    g_bIomBusy[ui32Module] = true;
     d12:	5538      	strb	r0, [r7, r4]
    AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
     d14:	f8d3 4208 	ldr.w	r4, [r3, #520]	; 0x208
     d18:	4304      	orrs	r4, r0
     d1a:	f8c3 4208 	str.w	r4, [r3, #520]	; 0x208
}
     d1e:	b003      	add	sp, #12
     d20:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    am_hal_debug_assert_msg(ui32NumBytes < 256, "I2C transfer too big.");
     d24:	4a6e      	ldr	r2, [pc, #440]	; (ee0 <am_hal_iom_i2c_write_nb.part.9+0x204>)
     d26:	486f      	ldr	r0, [pc, #444]	; (ee4 <am_hal_iom_i2c_write_nb.part.9+0x208>)
     d28:	f240 6182 	movw	r1, #1666	; 0x682
     d2c:	f000 fda0 	bl	1870 <am_hal_debug_error>
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
     d30:	2c01      	cmp	r4, #1
     d32:	d8e8      	bhi.n	d06 <am_hal_iom_i2c_write_nb.part.9+0x2a>
     d34:	4b69      	ldr	r3, [pc, #420]	; (edc <am_hal_iom_i2c_write_nb.part.9+0x200>)
    while ( g_bIomBusy[ui32Module] );
     d36:	5d1a      	ldrb	r2, [r3, r4]
     d38:	2a00      	cmp	r2, #0
     d3a:	d1fc      	bne.n	d36 <am_hal_iom_i2c_write_nb.part.9+0x5a>
    AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
     d3c:	f504 26a0 	add.w	r6, r4, #327680	; 0x50000
    g_bIomBusy[ui32Module] = true;
     d40:	2001      	movs	r0, #1
    AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
     d42:	3604      	adds	r6, #4
    g_bIomBusy[ui32Module] = true;
     d44:	5518      	strb	r0, [r3, r4]
    AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
     d46:	0336      	lsls	r6, r6, #12
    ui32TransferSize = (ui32NumBytes <= AM_HAL_IOM_MAX_FIFO_SIZE ? ui32NumBytes :
     d48:	2d40      	cmp	r5, #64	; 0x40
    AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
     d4a:	f8d6 1208 	ldr.w	r1, [r6, #520]	; 0x208
     d4e:	ea41 0100 	orr.w	r1, r1, r0
     d52:	f8c6 1208 	str.w	r1, [r6, #520]	; 0x208
    return (AM_HAL_IOM_MAX_FIFO_SIZE - AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ)) & (~0x3);
     d56:	f8d6 3100 	ldr.w	r3, [r6, #256]	; 0x100
     d5a:	f003 027f 	and.w	r2, r3, #127	; 0x7f
     d5e:	f1c2 0040 	rsb	r0, r2, #64	; 0x40
    ui32TransferSize = (ui32NumBytes <= AM_HAL_IOM_MAX_FIFO_SIZE ? ui32NumBytes :
     d62:	46ab      	mov	fp, r5
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
     d64:	f000 01fc 	and.w	r1, r0, #252	; 0xfc
    ui32TransferSize = (ui32NumBytes <= AM_HAL_IOM_MAX_FIFO_SIZE ? ui32NumBytes :
     d68:	bf28      	it	cs
     d6a:	f04f 0b40 	movcs.w	fp, #64	; 0x40
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
     d6e:	458b      	cmp	fp, r1
     d70:	f200 80a5 	bhi.w	ebe <am_hal_iom_i2c_write_nb.part.9+0x1e2>
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
     d74:	f1bb 0f00 	cmp.w	fp, #0
     d78:	d0d1      	beq.n	d1e <am_hal_iom_i2c_write_nb.part.9+0x42>
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
     d7a:	463b      	mov	r3, r7
     d7c:	43fa      	mvns	r2, r7
     d7e:	f853 0b04 	ldr.w	r0, [r3], #4
     d82:	6030      	str	r0, [r6, #0]
     d84:	443a      	add	r2, r7
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
     d86:	1bd9      	subs	r1, r3, r7
     d88:	445a      	add	r2, fp
     d8a:	458b      	cmp	fp, r1
     d8c:	f3c2 0282 	ubfx	r2, r2, #2, #3
     d90:	d941      	bls.n	e16 <am_hal_iom_i2c_write_nb.part.9+0x13a>
     d92:	b31a      	cbz	r2, ddc <am_hal_iom_i2c_write_nb.part.9+0x100>
     d94:	2a01      	cmp	r2, #1
     d96:	d01b      	beq.n	dd0 <am_hal_iom_i2c_write_nb.part.9+0xf4>
     d98:	2a02      	cmp	r2, #2
     d9a:	d016      	beq.n	dca <am_hal_iom_i2c_write_nb.part.9+0xee>
     d9c:	2a03      	cmp	r2, #3
     d9e:	d011      	beq.n	dc4 <am_hal_iom_i2c_write_nb.part.9+0xe8>
     da0:	2a04      	cmp	r2, #4
     da2:	d00c      	beq.n	dbe <am_hal_iom_i2c_write_nb.part.9+0xe2>
     da4:	2a05      	cmp	r2, #5
     da6:	d007      	beq.n	db8 <am_hal_iom_i2c_write_nb.part.9+0xdc>
     da8:	2a06      	cmp	r2, #6
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
     daa:	bf1c      	itt	ne
     dac:	f853 2b04 	ldrne.w	r2, [r3], #4
     db0:	6032      	strne	r2, [r6, #0]
     db2:	f853 0b04 	ldr.w	r0, [r3], #4
     db6:	6030      	str	r0, [r6, #0]
     db8:	f853 1b04 	ldr.w	r1, [r3], #4
     dbc:	6031      	str	r1, [r6, #0]
     dbe:	f853 2b04 	ldr.w	r2, [r3], #4
     dc2:	6032      	str	r2, [r6, #0]
     dc4:	f853 0b04 	ldr.w	r0, [r3], #4
     dc8:	6030      	str	r0, [r6, #0]
     dca:	f853 1b04 	ldr.w	r1, [r3], #4
     dce:	6031      	str	r1, [r6, #0]
     dd0:	f853 2b04 	ldr.w	r2, [r3], #4
     dd4:	6032      	str	r2, [r6, #0]
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
     dd6:	1bd8      	subs	r0, r3, r7
     dd8:	4583      	cmp	fp, r0
     dda:	d91c      	bls.n	e16 <am_hal_iom_i2c_write_nb.part.9+0x13a>
        AM_REGn(IOMSTR, ui32Module, FIFO) = pui32Data[ui32Index];
     ddc:	469c      	mov	ip, r3
     dde:	3320      	adds	r3, #32
     de0:	f85c 1b04 	ldr.w	r1, [ip], #4
     de4:	6031      	str	r1, [r6, #0]
     de6:	f853 2c1c 	ldr.w	r2, [r3, #-28]
     dea:	6032      	str	r2, [r6, #0]
     dec:	f8dc 0004 	ldr.w	r0, [ip, #4]
     df0:	6030      	str	r0, [r6, #0]
     df2:	f853 1c14 	ldr.w	r1, [r3, #-20]
     df6:	6031      	str	r1, [r6, #0]
     df8:	f853 2c10 	ldr.w	r2, [r3, #-16]
     dfc:	6032      	str	r2, [r6, #0]
     dfe:	f853 0c0c 	ldr.w	r0, [r3, #-12]
     e02:	6030      	str	r0, [r6, #0]
     e04:	f853 1c08 	ldr.w	r1, [r3, #-8]
     e08:	6031      	str	r1, [r6, #0]
     e0a:	f853 2c04 	ldr.w	r2, [r3, #-4]
     e0e:	6032      	str	r2, [r6, #0]
    for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
     e10:	1bd8      	subs	r0, r3, r7
     e12:	4583      	cmp	fp, r0
     e14:	d8e2      	bhi.n	ddc <am_hal_iom_i2c_write_nb.part.9+0x100>
        g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
     e16:	eb04 0484 	add.w	r4, r4, r4, lsl #2
     e1a:	4a33      	ldr	r2, [pc, #204]	; (ee8 <am_hal_iom_i2c_write_nb.part.9+0x20c>)
     e1c:	00a0      	lsls	r0, r4, #2
     e1e:	1813      	adds	r3, r2, r0
        g_psIOMBuffers[ui32Module].pui32Data += (ui32TransferSize / 4);
     e20:	f02b 0c03 	bic.w	ip, fp, #3
        g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
     e24:	2101      	movs	r1, #1
        g_psIOMBuffers[ui32Module].ui32BytesLeft -= ui32TransferSize;
     e26:	eba5 040b 	sub.w	r4, r5, fp
        g_psIOMBuffers[ui32Module].pui32Data += (ui32TransferSize / 4);
     e2a:	4467      	add	r7, ip
        g_psIOMBuffers[ui32Module].ui32State = BUFFER_SENDING;
     e2c:	5011      	str	r1, [r2, r0]
        g_psIOMBuffers[ui32Module].pfnCallback = pfnCallback;
     e2e:	f8c3 a010 	str.w	sl, [r3, #16]
        g_psIOMBuffers[ui32Module].ui32BytesLeft -= ui32TransferSize;
     e32:	609c      	str	r4, [r3, #8]
        g_psIOMBuffers[ui32Module].pui32Data += (ui32TransferSize / 4);
     e34:	605f      	str	r7, [r3, #4]
    am_hal_debug_assert_msg(ui32NumBytes > 0,
     e36:	2d00      	cmp	r5, #0
     e38:	d048      	beq.n	ecc <am_hal_iom_i2c_write_nb.part.9+0x1f0>
    ui32Command |= ((ui32BusAddress << 16) & 0x03FF0000);
     e3a:	4f2c      	ldr	r7, [pc, #176]	; (eec <am_hal_iom_i2c_write_nb.part.9+0x210>)
    ui32Command |= (ui32Options & 0x5C00FF00);
     e3c:	f028 4223 	bic.w	r2, r8, #2734686208	; 0xa3000000
    ui32Command |= ((ui32BusAddress << 16) & 0x03FF0000);
     e40:	ea07 4309 	and.w	r3, r7, r9, lsl #16
    ui32Command |= (ui32Options & 0x5C00FF00);
     e44:	f002 20ff 	and.w	r0, r2, #4278255360	; 0xff00ff00
    ui32Command |= (ui32NumBytes & 0xFF);
     e48:	fa5f f985 	uxtb.w	r9, r5
    ui32Command |= (ui32Options & 0x5C00FF00);
     e4c:	ea43 0500 	orr.w	r5, r3, r0
     e50:	ea45 0109 	orr.w	r1, r5, r9
    AM_REGn(IOMSTR, ui32Module, CMD) = ui32Command;
     e54:	f8c6 1110 	str.w	r1, [r6, #272]	; 0x110
     e58:	e761      	b.n	d1e <am_hal_iom_i2c_write_nb.part.9+0x42>
    am_hal_debug_assert_msg(ui32NumBytes > 0,
     e5a:	4a25      	ldr	r2, [pc, #148]	; (ef0 <am_hal_iom_i2c_write_nb.part.9+0x214>)
     e5c:	4821      	ldr	r0, [pc, #132]	; (ee4 <am_hal_iom_i2c_write_nb.part.9+0x208>)
     e5e:	f240 6159 	movw	r1, #1625	; 0x659
     e62:	f000 fd05 	bl	1870 <am_hal_debug_error>
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
     e66:	2c02      	cmp	r4, #2
     e68:	f47f af4b 	bne.w	d02 <am_hal_iom_i2c_write_nb.part.9+0x26>
        if ( ui32Options & AM_HAL_IOM_RAW )
     e6c:	f018 4f80 	tst.w	r8, #1073741824	; 0x40000000
     e70:	d015      	beq.n	e9e <am_hal_iom_i2c_write_nb.part.9+0x1c2>
            am_hal_i2c_bit_bang_send(ui32BusAddress << 1, ui32NumBytes,
     e72:	ea4f 0149 	mov.w	r1, r9, lsl #1
     e76:	f3c8 7200 	ubfx	r2, r8, #28, #1
     e7a:	2300      	movs	r3, #0
     e7c:	f001 00fe 	and.w	r0, r1, #254	; 0xfe
     e80:	9201      	str	r2, [sp, #4]
     e82:	4629      	mov	r1, r5
     e84:	463a      	mov	r2, r7
     e86:	9300      	str	r3, [sp, #0]
     e88:	f001 f946 	bl	2118 <am_hal_i2c_bit_bang_send>
        if ( pfnCallback )
     e8c:	f1ba 0f00 	cmp.w	sl, #0
     e90:	f43f af45 	beq.w	d1e <am_hal_iom_i2c_write_nb.part.9+0x42>
            pfnCallback();
     e94:	46d4      	mov	ip, sl
}
     e96:	b003      	add	sp, #12
     e98:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            pfnCallback();
     e9c:	4760      	bx	ip
            am_hal_i2c_bit_bang_send(ui32BusAddress << 1, ui32NumBytes,
     e9e:	ea4f 0249 	mov.w	r2, r9, lsl #1
     ea2:	f3c8 7600 	ubfx	r6, r8, #28, #1
     ea6:	2401      	movs	r4, #1
     ea8:	f002 00fe 	and.w	r0, r2, #254	; 0xfe
     eac:	4629      	mov	r1, r5
     eae:	463a      	mov	r2, r7
     eb0:	9601      	str	r6, [sp, #4]
     eb2:	f3c8 2307 	ubfx	r3, r8, #8, #8
     eb6:	9400      	str	r4, [sp, #0]
     eb8:	f001 f92e 	bl	2118 <am_hal_i2c_bit_bang_send>
     ebc:	e7e6      	b.n	e8c <am_hal_iom_i2c_write_nb.part.9+0x1b0>
    am_hal_debug_assert_msg((am_hal_iom_fifo_empty_slots(ui32Module) >= ui32NumBytes),
     ebe:	4a0d      	ldr	r2, [pc, #52]	; (ef4 <am_hal_iom_i2c_write_nb.part.9+0x218>)
     ec0:	4808      	ldr	r0, [pc, #32]	; (ee4 <am_hal_iom_i2c_write_nb.part.9+0x208>)
     ec2:	f240 71d6 	movw	r1, #2006	; 0x7d6
     ec6:	f000 fcd3 	bl	1870 <am_hal_debug_error>
     eca:	e756      	b.n	d7a <am_hal_iom_i2c_write_nb.part.9+0x9e>
    am_hal_debug_assert_msg(ui32NumBytes > 0,
     ecc:	4a08      	ldr	r2, [pc, #32]	; (ef0 <am_hal_iom_i2c_write_nb.part.9+0x214>)
     ece:	4805      	ldr	r0, [pc, #20]	; (ee4 <am_hal_iom_i2c_write_nb.part.9+0x208>)
     ed0:	f240 714d 	movw	r1, #1869	; 0x74d
     ed4:	f000 fccc 	bl	1870 <am_hal_debug_error>
     ed8:	e7af      	b.n	e3a <am_hal_iom_i2c_write_nb.part.9+0x15e>
     eda:	bf00      	nop
     edc:	1000100c 	.word	0x1000100c
     ee0:	0000443c 	.word	0x0000443c
     ee4:	00004428 	.word	0x00004428
     ee8:	10001334 	.word	0x10001334
     eec:	03ff0000 	.word	0x03ff0000
     ef0:	00004404 	.word	0x00004404
     ef4:	00004530 	.word	0x00004530

00000ef8 <am_hal_iom_i2c_read_nq.part.8>:
am_hal_iom_i2c_read_nq(uint32_t ui32Module, uint32_t ui32BusAddress,
     ef8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     efc:	4607      	mov	r7, r0
     efe:	b087      	sub	sp, #28
     f00:	460d      	mov	r5, r1
     f02:	4692      	mov	sl, r2
    am_hal_debug_assert_msg(ui32NumBytes > 0,
     f04:	461e      	mov	r6, r3
     f06:	2b00      	cmp	r3, #0
     f08:	f000 8156 	beq.w	11b8 <am_hal_iom_i2c_read_nq.part.8+0x2c0>
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
     f0c:	2802      	cmp	r0, #2
     f0e:	f000 815c 	beq.w	11ca <am_hal_iom_i2c_read_nq.part.8+0x2d2>
    am_hal_debug_assert_msg(ui32NumBytes < 256, "I2C transfer too big.");
     f12:	2bff      	cmp	r3, #255	; 0xff
     f14:	f200 811b 	bhi.w	114e <am_hal_iom_i2c_read_nq.part.8+0x256>
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
     f18:	2f01      	cmp	r7, #1
     f1a:	f240 8121 	bls.w	1160 <am_hal_iom_i2c_read_nq.part.8+0x268>
    ui32IntConfig = AM_REGn(IOMSTR, ui32Module, INTEN);
     f1e:	f507 24a0 	add.w	r4, r7, #327680	; 0x50000
     f22:	3404      	adds	r4, #4
     f24:	0324      	lsls	r4, r4, #12
    AM_REGn(IOMSTR, ui32Module, INTEN) = 0;
     f26:	2100      	movs	r1, #0
    ui32IntConfig = AM_REGn(IOMSTR, ui32Module, INTEN);
     f28:	f8d4 b200 	ldr.w	fp, [r4, #512]	; 0x200
    AM_REGn(IOMSTR, ui32Module, INTEN) = 0;
     f2c:	f8c4 1200 	str.w	r1, [r4, #512]	; 0x200
    AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
     f30:	f8d4 5208 	ldr.w	r5, [r4, #520]	; 0x208
    ui32IntConfig = AM_REGn(IOMSTR, ui32Module, INTEN);
     f34:	f504 7000 	add.w	r0, r4, #512	; 0x200
    AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
     f38:	f045 0301 	orr.w	r3, r5, #1
     f3c:	f504 7202 	add.w	r2, r4, #520	; 0x208
     f40:	f8c4 3208 	str.w	r3, [r4, #520]	; 0x208
    ui32IntConfig = AM_REGn(IOMSTR, ui32Module, INTEN);
     f44:	9003      	str	r0, [sp, #12]
    AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
     f46:	9204      	str	r2, [sp, #16]
     f48:	f504 7901 	add.w	r9, r4, #516	; 0x204
    while ( ui32NumBytes )
     f4c:	2e00      	cmp	r6, #0
     f4e:	d071      	beq.n	1034 <am_hal_iom_i2c_read_nq.part.8+0x13c>
     f50:	2500      	movs	r5, #0
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
     f52:	2f01      	cmp	r7, #1
     f54:	d907      	bls.n	f66 <am_hal_iom_i2c_read_nq.part.8+0x6e>
        if ( bCmdCmp == true )
     f56:	2d00      	cmp	r5, #0
     f58:	d16c      	bne.n	1034 <am_hal_iom_i2c_read_nq.part.8+0x13c>
        bCmdCmp = AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP);
     f5a:	f8d9 5000 	ldr.w	r5, [r9]
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
     f5e:	2f01      	cmp	r7, #1
        bCmdCmp = AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP);
     f60:	f005 0501 	and.w	r5, r5, #1
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
     f64:	d8f7      	bhi.n	f56 <am_hal_iom_i2c_read_nq.part.8+0x5e>
    return AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ);
     f66:	f8d4 1100 	ldr.w	r1, [r4, #256]	; 0x100
        ui32BytesInFifo =  am_hal_iom_fifo_full_slots(ui32Module);
     f6a:	f001 087f 	and.w	r8, r1, #127	; 0x7f
        if ( ui32BytesInFifo >= ui32NumBytes )
     f6e:	4546      	cmp	r6, r8
    return AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ);
     f70:	f504 7c80 	add.w	ip, r4, #256	; 0x100
        if ( ui32BytesInFifo >= ui32NumBytes )
     f74:	d97a      	bls.n	106c <am_hal_iom_i2c_read_nq.part.8+0x174>
        else if ( ui32BytesInFifo >= 4 )
     f76:	f1b8 0f03 	cmp.w	r8, #3
     f7a:	d9ec      	bls.n	f56 <am_hal_iom_i2c_read_nq.part.8+0x5e>
    return AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ);
     f7c:	f8dc 0000 	ldr.w	r0, [ip]
            am_hal_iom_fifo_read(ui32Module, pui32Data, ui32BytesInFifo & ~0x3);
     f80:	f028 0303 	bic.w	r3, r8, #3
    am_hal_debug_assert_msg((am_hal_iom_fifo_full_slots(ui32Module) >= ui32NumBytes),
     f84:	f000 0e7f 	and.w	lr, r0, #127	; 0x7f
     f88:	4573      	cmp	r3, lr
     f8a:	f200 8155 	bhi.w	1238 <am_hal_iom_i2c_read_nq.part.8+0x340>
        pui32Data[i] = AM_REGn(IOMSTR, ui32Module, FIFO);
     f8e:	4652      	mov	r2, sl
     f90:	f008 017c 	and.w	r1, r8, #124	; 0x7c
     f94:	6820      	ldr	r0, [r4, #0]
     f96:	f842 0b04 	str.w	r0, [r2], #4
     f9a:	46d4      	mov	ip, sl
     f9c:	448a      	add	sl, r1
     f9e:	ebaa 080c 	sub.w	r8, sl, ip
     fa2:	f1a8 0e04 	sub.w	lr, r8, #4
    for ( i = 0; i < ui32NumWords; i++ )
     fa6:	4552      	cmp	r2, sl
     fa8:	f3ce 0182 	ubfx	r1, lr, #2, #3
     fac:	d03a      	beq.n	1024 <am_hal_iom_i2c_read_nq.part.8+0x12c>
     fae:	b319      	cbz	r1, ff8 <am_hal_iom_i2c_read_nq.part.8+0x100>
     fb0:	2901      	cmp	r1, #1
     fb2:	d01c      	beq.n	fee <am_hal_iom_i2c_read_nq.part.8+0xf6>
     fb4:	2902      	cmp	r1, #2
     fb6:	d017      	beq.n	fe8 <am_hal_iom_i2c_read_nq.part.8+0xf0>
     fb8:	2903      	cmp	r1, #3
     fba:	d012      	beq.n	fe2 <am_hal_iom_i2c_read_nq.part.8+0xea>
     fbc:	2904      	cmp	r1, #4
     fbe:	d00d      	beq.n	fdc <am_hal_iom_i2c_read_nq.part.8+0xe4>
     fc0:	2905      	cmp	r1, #5
     fc2:	d008      	beq.n	fd6 <am_hal_iom_i2c_read_nq.part.8+0xde>
     fc4:	2906      	cmp	r1, #6
     fc6:	d003      	beq.n	fd0 <am_hal_iom_i2c_read_nq.part.8+0xd8>
        pui32Data[i] = AM_REGn(IOMSTR, ui32Module, FIFO);
     fc8:	6820      	ldr	r0, [r4, #0]
     fca:	f8cc 0004 	str.w	r0, [ip, #4]
     fce:	3204      	adds	r2, #4
     fd0:	6821      	ldr	r1, [r4, #0]
     fd2:	f842 1b04 	str.w	r1, [r2], #4
     fd6:	6820      	ldr	r0, [r4, #0]
     fd8:	f842 0b04 	str.w	r0, [r2], #4
     fdc:	6821      	ldr	r1, [r4, #0]
     fde:	f842 1b04 	str.w	r1, [r2], #4
     fe2:	6820      	ldr	r0, [r4, #0]
     fe4:	f842 0b04 	str.w	r0, [r2], #4
     fe8:	6821      	ldr	r1, [r4, #0]
     fea:	f842 1b04 	str.w	r1, [r2], #4
     fee:	6820      	ldr	r0, [r4, #0]
     ff0:	f842 0b04 	str.w	r0, [r2], #4
    for ( i = 0; i < ui32NumWords; i++ )
     ff4:	4552      	cmp	r2, sl
     ff6:	d015      	beq.n	1024 <am_hal_iom_i2c_read_nq.part.8+0x12c>
        pui32Data[i] = AM_REGn(IOMSTR, ui32Module, FIFO);
     ff8:	4694      	mov	ip, r2
     ffa:	6821      	ldr	r1, [r4, #0]
     ffc:	f84c 1b04 	str.w	r1, [ip], #4
    1000:	6820      	ldr	r0, [r4, #0]
    1002:	6050      	str	r0, [r2, #4]
    1004:	6821      	ldr	r1, [r4, #0]
    1006:	f8cc 1004 	str.w	r1, [ip, #4]
    100a:	6820      	ldr	r0, [r4, #0]
    100c:	60d0      	str	r0, [r2, #12]
    100e:	6821      	ldr	r1, [r4, #0]
    1010:	6111      	str	r1, [r2, #16]
    1012:	6820      	ldr	r0, [r4, #0]
    1014:	6150      	str	r0, [r2, #20]
    1016:	6821      	ldr	r1, [r4, #0]
    1018:	6191      	str	r1, [r2, #24]
    101a:	6820      	ldr	r0, [r4, #0]
    101c:	61d0      	str	r0, [r2, #28]
    101e:	3220      	adds	r2, #32
    for ( i = 0; i < ui32NumWords; i++ )
    1020:	4552      	cmp	r2, sl
    1022:	d1e9      	bne.n	ff8 <am_hal_iom_i2c_read_nq.part.8+0x100>
            ui32NumBytes -= ui32BytesInFifo & ~0x3;
    1024:	1af6      	subs	r6, r6, r3
        if ( bCmdCmp == true )
    1026:	b92d      	cbnz	r5, 1034 <am_hal_iom_i2c_read_nq.part.8+0x13c>
        bCmdCmp = AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP);
    1028:	f8d9 5000 	ldr.w	r5, [r9]
    102c:	f005 0501 	and.w	r5, r5, #1
    while ( ui32NumBytes )
    1030:	2e00      	cmp	r6, #0
    1032:	d18e      	bne.n	f52 <am_hal_iom_i2c_read_nq.part.8+0x5a>
    ui32Status = am_hal_flash_delay_status_change(ui32StatusTimeout[ui32Module],
    1034:	4888      	ldr	r0, [pc, #544]	; (1258 <am_hal_iom_i2c_read_nq.part.8+0x360>)
    1036:	2301      	movs	r3, #1
    1038:	461a      	mov	r2, r3
    103a:	4649      	mov	r1, r9
    103c:	f850 0027 	ldr.w	r0, [r0, r7, lsl #2]
    1040:	f7ff fb18 	bl	674 <am_hal_flash_delay_status_change>
    AM_REGn(IOMSTR, ui32Module, INTCLR) = (ui32IntConfig | AM_REG_IOMSTR_INTSTAT_CMDCMP_M);
    1044:	9a04      	ldr	r2, [sp, #16]
    AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
    1046:	9b03      	ldr	r3, [sp, #12]
    AM_REGn(IOMSTR, ui32Module, INTCLR) = (ui32IntConfig | AM_REG_IOMSTR_INTSTAT_CMDCMP_M);
    1048:	f04b 0101 	orr.w	r1, fp, #1
    am_hal_debug_assert_msg(ui32Status == 1, "IOM CMDCMP was not seen");
    104c:	2801      	cmp	r0, #1
    AM_REGn(IOMSTR, ui32Module, INTCLR) = (ui32IntConfig | AM_REG_IOMSTR_INTSTAT_CMDCMP_M);
    104e:	6011      	str	r1, [r2, #0]
    ui32Status = am_hal_flash_delay_status_change(ui32StatusTimeout[ui32Module],
    1050:	4604      	mov	r4, r0
    AM_REGn(IOMSTR, ui32Module, INTEN) = ui32IntConfig;
    1052:	f8c3 b000 	str.w	fp, [r3]
    am_hal_debug_assert_msg(ui32Status == 1, "IOM CMDCMP was not seen");
    1056:	d005      	beq.n	1064 <am_hal_iom_i2c_read_nq.part.8+0x16c>
    1058:	4a80      	ldr	r2, [pc, #512]	; (125c <am_hal_iom_i2c_read_nq.part.8+0x364>)
    105a:	4881      	ldr	r0, [pc, #516]	; (1260 <am_hal_iom_i2c_read_nq.part.8+0x368>)
    105c:	f240 5151 	movw	r1, #1361	; 0x551
    1060:	f000 fc06 	bl	1870 <am_hal_debug_error>
}
    1064:	4620      	mov	r0, r4
    1066:	b007      	add	sp, #28
    1068:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return AM_BFRn(IOMSTR, ui32Module, FIFOPTR, FIFOSIZ);
    106c:	f8dc 2000 	ldr.w	r2, [ip]
    am_hal_debug_assert_msg((am_hal_iom_fifo_full_slots(ui32Module) >= ui32NumBytes),
    1070:	f002 087f 	and.w	r8, r2, #127	; 0x7f
    1074:	4546      	cmp	r6, r8
    1076:	f200 80be 	bhi.w	11f6 <am_hal_iom_i2c_read_nq.part.8+0x2fe>
    107a:	f006 0103 	and.w	r1, r6, #3
    for ( i = 0; i < ui32NumWords; i++ )
    107e:	08b6      	lsrs	r6, r6, #2
    1080:	d04b      	beq.n	111a <am_hal_iom_i2c_read_nq.part.8+0x222>
        pui32Data[i] = AM_REGn(IOMSTR, ui32Module, FIFO);
    1082:	4653      	mov	r3, sl
    1084:	6820      	ldr	r0, [r4, #0]
    1086:	f843 0b04 	str.w	r0, [r3], #4
    108a:	eb0a 0c86 	add.w	ip, sl, r6, lsl #2
    108e:	ebac 0e0a 	sub.w	lr, ip, sl
    1092:	f1ae 0204 	sub.w	r2, lr, #4
    for ( i = 0; i < ui32NumWords; i++ )
    1096:	459c      	cmp	ip, r3
    1098:	f3c2 0082 	ubfx	r0, r2, #2, #3
    109c:	d03d      	beq.n	111a <am_hal_iom_i2c_read_nq.part.8+0x222>
    109e:	b310      	cbz	r0, 10e6 <am_hal_iom_i2c_read_nq.part.8+0x1ee>
    10a0:	2801      	cmp	r0, #1
    10a2:	d01b      	beq.n	10dc <am_hal_iom_i2c_read_nq.part.8+0x1e4>
    10a4:	2802      	cmp	r0, #2
    10a6:	d016      	beq.n	10d6 <am_hal_iom_i2c_read_nq.part.8+0x1de>
    10a8:	2803      	cmp	r0, #3
    10aa:	d011      	beq.n	10d0 <am_hal_iom_i2c_read_nq.part.8+0x1d8>
    10ac:	2804      	cmp	r0, #4
    10ae:	d00c      	beq.n	10ca <am_hal_iom_i2c_read_nq.part.8+0x1d2>
    10b0:	2805      	cmp	r0, #5
    10b2:	d007      	beq.n	10c4 <am_hal_iom_i2c_read_nq.part.8+0x1cc>
    10b4:	2806      	cmp	r0, #6
        pui32Data[i] = AM_REGn(IOMSTR, ui32Module, FIFO);
    10b6:	bf1c      	itt	ne
    10b8:	6820      	ldrne	r0, [r4, #0]
    10ba:	f843 0b04 	strne.w	r0, [r3], #4
    10be:	6822      	ldr	r2, [r4, #0]
    10c0:	f843 2b04 	str.w	r2, [r3], #4
    10c4:	6820      	ldr	r0, [r4, #0]
    10c6:	f843 0b04 	str.w	r0, [r3], #4
    10ca:	6822      	ldr	r2, [r4, #0]
    10cc:	f843 2b04 	str.w	r2, [r3], #4
    10d0:	6820      	ldr	r0, [r4, #0]
    10d2:	f843 0b04 	str.w	r0, [r3], #4
    10d6:	6822      	ldr	r2, [r4, #0]
    10d8:	f843 2b04 	str.w	r2, [r3], #4
    10dc:	6820      	ldr	r0, [r4, #0]
    10de:	f843 0b04 	str.w	r0, [r3], #4
    for ( i = 0; i < ui32NumWords; i++ )
    10e2:	459c      	cmp	ip, r3
    10e4:	d019      	beq.n	111a <am_hal_iom_i2c_read_nq.part.8+0x222>
        pui32Data[i] = AM_REGn(IOMSTR, ui32Module, FIFO);
    10e6:	4698      	mov	r8, r3
    10e8:	f8d4 e000 	ldr.w	lr, [r4]
    10ec:	f848 eb04 	str.w	lr, [r8], #4
    10f0:	f8d4 e000 	ldr.w	lr, [r4]
    10f4:	f8c3 e004 	str.w	lr, [r3, #4]
    10f8:	f8d4 e000 	ldr.w	lr, [r4]
    10fc:	f8c8 e004 	str.w	lr, [r8, #4]
    1100:	6822      	ldr	r2, [r4, #0]
    1102:	60da      	str	r2, [r3, #12]
    1104:	6820      	ldr	r0, [r4, #0]
    1106:	6118      	str	r0, [r3, #16]
    1108:	6822      	ldr	r2, [r4, #0]
    110a:	615a      	str	r2, [r3, #20]
    110c:	6820      	ldr	r0, [r4, #0]
    110e:	6198      	str	r0, [r3, #24]
    1110:	6822      	ldr	r2, [r4, #0]
    1112:	61da      	str	r2, [r3, #28]
    1114:	3320      	adds	r3, #32
    for ( i = 0; i < ui32NumWords; i++ )
    1116:	459c      	cmp	ip, r3
    1118:	d1e5      	bne.n	10e6 <am_hal_iom_i2c_read_nq.part.8+0x1ee>
    if ( ui32Leftovers )
    111a:	b191      	cbz	r1, 1142 <am_hal_iom_i2c_read_nq.part.8+0x24a>
        sTempBuffer.words[0] = AM_REGn(IOMSTR, ui32Module, FIFO);
    111c:	6824      	ldr	r4, [r4, #0]
            pui8Data[j] = sTempBuffer.bytes[j];
    111e:	f80a 4026 	strb.w	r4, [sl, r6, lsl #2]
        for ( j = 0; j < ui32Leftovers; j++ )
    1122:	2901      	cmp	r1, #1
        pui8Data = (uint8_t *) (&pui32Data[i]);
    1124:	ea4f 0386 	mov.w	r3, r6, lsl #2
        for ( j = 0; j < ui32Leftovers; j++ )
    1128:	d00b      	beq.n	1142 <am_hal_iom_i2c_read_nq.part.8+0x24a>
            pui8Data[j] = sTempBuffer.bytes[j];
    112a:	449a      	add	sl, r3
        for ( j = 0; j < ui32Leftovers; j++ )
    112c:	2903      	cmp	r1, #3
            pui8Data[j] = sTempBuffer.bytes[j];
    112e:	f3c4 2607 	ubfx	r6, r4, #8, #8
    1132:	bf08      	it	eq
    1134:	f3c4 4407 	ubfxeq	r4, r4, #16, #8
    1138:	f88a 6001 	strb.w	r6, [sl, #1]
    113c:	bf08      	it	eq
    113e:	f88a 4002 	strbeq.w	r4, [sl, #2]
        if ( bCmdCmp == true )
    1142:	2d00      	cmp	r5, #0
    1144:	f47f af76 	bne.w	1034 <am_hal_iom_i2c_read_nq.part.8+0x13c>
        bCmdCmp = AM_BFRn(IOMSTR, ui32Module, INTSTAT, CMDCMP);
    1148:	f8d9 3000 	ldr.w	r3, [r9]
    114c:	e772      	b.n	1034 <am_hal_iom_i2c_read_nq.part.8+0x13c>
    am_hal_debug_assert_msg(ui32NumBytes < 256, "I2C transfer too big.");
    114e:	4a45      	ldr	r2, [pc, #276]	; (1264 <am_hal_iom_i2c_read_nq.part.8+0x36c>)
    1150:	4843      	ldr	r0, [pc, #268]	; (1260 <am_hal_iom_i2c_read_nq.part.8+0x368>)
    1152:	f240 510a 	movw	r1, #1290	; 0x50a
    1156:	f000 fb8b 	bl	1870 <am_hal_debug_error>
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    115a:	2f01      	cmp	r7, #1
    115c:	f63f aedf 	bhi.w	f1e <am_hal_iom_i2c_read_nq.part.8+0x26>
    1160:	4941      	ldr	r1, [pc, #260]	; (1268 <am_hal_iom_i2c_read_nq.part.8+0x370>)
    while ( g_bIomBusy[ui32Module] );
    1162:	5dcb      	ldrb	r3, [r1, r7]
    1164:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    1168:	2b00      	cmp	r3, #0
    116a:	d1fa      	bne.n	1162 <am_hal_iom_i2c_read_nq.part.8+0x26a>
    ui32IntConfig = AM_REGn(IOMSTR, ui32Module, INTEN);
    116c:	f507 24a0 	add.w	r4, r7, #327680	; 0x50000
    1170:	3404      	adds	r4, #4
    1172:	0324      	lsls	r4, r4, #12
    1174:	f504 7000 	add.w	r0, r4, #512	; 0x200
    1178:	f8d4 b200 	ldr.w	fp, [r4, #512]	; 0x200
    AM_REGn(IOMSTR, ui32Module, INTEN) = 0;
    117c:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
    AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
    1180:	f8d4 1208 	ldr.w	r1, [r4, #520]	; 0x208
    ui32IntConfig = AM_REGn(IOMSTR, ui32Module, INTEN);
    1184:	9003      	str	r0, [sp, #12]
    AM_BFWn(IOMSTR, ui32Module, INTCLR, CMDCMP, 1);
    1186:	f041 0301 	orr.w	r3, r1, #1
    118a:	f504 7202 	add.w	r2, r4, #520	; 0x208
    118e:	f8c4 3208 	str.w	r3, [r4, #520]	; 0x208
    1192:	9204      	str	r2, [sp, #16]
    am_hal_debug_assert_msg(ui32NumBytes > 0,
    1194:	2e00      	cmp	r6, #0
    1196:	d058      	beq.n	124a <am_hal_iom_i2c_read_nq.part.8+0x352>
    ui32Command |= (ui32Options & 0x5C00FF00);
    1198:	9910      	ldr	r1, [sp, #64]	; 0x40
    ui32Command |= ((ui32BusAddress << 16) & 0x03FF0000);
    119a:	4834      	ldr	r0, [pc, #208]	; (126c <am_hal_iom_i2c_read_nq.part.8+0x374>)
    ui32Command |= (ui32Options & 0x5C00FF00);
    119c:	f021 4823 	bic.w	r8, r1, #2734686208	; 0xa3000000
    ui32Command |= ((ui32BusAddress << 16) & 0x03FF0000);
    11a0:	ea00 4505 	and.w	r5, r0, r5, lsl #16
    ui32Command |= (ui32Options & 0x5C00FF00);
    11a4:	f008 23ff 	and.w	r3, r8, #4278255360	; 0xff00ff00
    11a8:	431d      	orrs	r5, r3
    11aa:	f045 4000 	orr.w	r0, r5, #2147483648	; 0x80000000
    ui32Command |= (ui32NumBytes & 0xFF);
    11ae:	b2f2      	uxtb	r2, r6
    ui32Command |= (ui32Options & 0x5C00FF00);
    11b0:	4310      	orrs	r0, r2
    AM_REGn(IOMSTR, ui32Module, CMD) = ui32Command;
    11b2:	f8c4 0110 	str.w	r0, [r4, #272]	; 0x110
    11b6:	e6c7      	b.n	f48 <am_hal_iom_i2c_read_nq.part.8+0x50>
    am_hal_debug_assert_msg(ui32NumBytes > 0,
    11b8:	4a2d      	ldr	r2, [pc, #180]	; (1270 <am_hal_iom_i2c_read_nq.part.8+0x378>)
    11ba:	4829      	ldr	r0, [pc, #164]	; (1260 <am_hal_iom_i2c_read_nq.part.8+0x368>)
    11bc:	f240 41ea 	movw	r1, #1258	; 0x4ea
    11c0:	f000 fb56 	bl	1870 <am_hal_debug_error>
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
    11c4:	2f02      	cmp	r7, #2
    11c6:	f47f aea7 	bne.w	f18 <am_hal_iom_i2c_read_nq.part.8+0x20>
        if ( ui32Options & AM_HAL_IOM_RAW )
    11ca:	9f10      	ldr	r7, [sp, #64]	; 0x40
    11cc:	f017 4480 	ands.w	r4, r7, #1073741824	; 0x40000000
    11d0:	d01d      	beq.n	120e <am_hal_iom_i2c_read_nq.part.8+0x316>
            am_hal_i2c_bit_bang_receive((ui32BusAddress << 1) | 1, ui32NumBytes,
    11d2:	0068      	lsls	r0, r5, #1
    11d4:	2400      	movs	r4, #0
    11d6:	f3c7 7300 	ubfx	r3, r7, #28, #1
    11da:	f040 0101 	orr.w	r1, r0, #1
    11de:	9301      	str	r3, [sp, #4]
    11e0:	b2c8      	uxtb	r0, r1
    11e2:	4652      	mov	r2, sl
    11e4:	4631      	mov	r1, r6
    11e6:	9400      	str	r4, [sp, #0]
    11e8:	4623      	mov	r3, r4
    11ea:	f000 fb43 	bl	1874 <am_hal_i2c_bit_bang_receive>
}
    11ee:	4620      	mov	r0, r4
    11f0:	b007      	add	sp, #28
    11f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    am_hal_debug_assert_msg((am_hal_iom_fifo_full_slots(ui32Module) >= ui32NumBytes),
    11f6:	f640 010e 	movw	r1, #2062	; 0x80e
    11fa:	4a1e      	ldr	r2, [pc, #120]	; (1274 <am_hal_iom_i2c_read_nq.part.8+0x37c>)
    11fc:	4818      	ldr	r0, [pc, #96]	; (1260 <am_hal_iom_i2c_read_nq.part.8+0x368>)
    11fe:	f000 fb37 	bl	1870 <am_hal_debug_error>
    1202:	f006 0103 	and.w	r1, r6, #3
    for ( i = 0; i < ui32NumWords; i++ )
    1206:	08b6      	lsrs	r6, r6, #2
    1208:	f47f af3b 	bne.w	1082 <am_hal_iom_i2c_read_nq.part.8+0x18a>
    120c:	e785      	b.n	111a <am_hal_iom_i2c_read_nq.part.8+0x222>
            am_hal_i2c_bit_bang_receive((ui32BusAddress << 1) | 1, ui32NumBytes,
    120e:	4631      	mov	r1, r6
    1210:	006d      	lsls	r5, r5, #1
    1212:	9e10      	ldr	r6, [sp, #64]	; 0x40
    1214:	f045 0c01 	orr.w	ip, r5, #1
    1218:	2301      	movs	r3, #1
    121a:	f3c7 7500 	ubfx	r5, r7, #28, #1
    121e:	e88d 0028 	stmia.w	sp, {r3, r5}
    1222:	fa5f f08c 	uxtb.w	r0, ip
    1226:	4652      	mov	r2, sl
    1228:	f3c6 2307 	ubfx	r3, r6, #8, #8
    122c:	f000 fb22 	bl	1874 <am_hal_i2c_bit_bang_receive>
}
    1230:	4620      	mov	r0, r4
    1232:	b007      	add	sp, #28
    1234:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    am_hal_debug_assert_msg((am_hal_iom_fifo_full_slots(ui32Module) >= ui32NumBytes),
    1238:	4a0e      	ldr	r2, [pc, #56]	; (1274 <am_hal_iom_i2c_read_nq.part.8+0x37c>)
    123a:	4809      	ldr	r0, [pc, #36]	; (1260 <am_hal_iom_i2c_read_nq.part.8+0x368>)
    123c:	9305      	str	r3, [sp, #20]
    123e:	f640 010e 	movw	r1, #2062	; 0x80e
    1242:	f000 fb15 	bl	1870 <am_hal_debug_error>
    1246:	9b05      	ldr	r3, [sp, #20]
    1248:	e6a1      	b.n	f8e <am_hal_iom_i2c_read_nq.part.8+0x96>
    am_hal_debug_assert_msg(ui32NumBytes > 0,
    124a:	4a09      	ldr	r2, [pc, #36]	; (1270 <am_hal_iom_i2c_read_nq.part.8+0x378>)
    124c:	4804      	ldr	r0, [pc, #16]	; (1260 <am_hal_iom_i2c_read_nq.part.8+0x368>)
    124e:	f240 714d 	movw	r1, #1869	; 0x74d
    1252:	f000 fb0d 	bl	1870 <am_hal_debug_error>
    1256:	e79f      	b.n	1198 <am_hal_iom_i2c_read_nq.part.8+0x2a0>
    1258:	10001004 	.word	0x10001004
    125c:	0000448c 	.word	0x0000448c
    1260:	00004428 	.word	0x00004428
    1264:	0000443c 	.word	0x0000443c
    1268:	1000100c 	.word	0x1000100c
    126c:	03ff0000 	.word	0x03ff0000
    1270:	00004404 	.word	0x00004404
    1274:	00004454 	.word	0x00004454

00001278 <am_hal_iom_enable>:
    if ( ui32Module < AM_REG_IOMSTR_NUM_MODULES )
    1278:	2801      	cmp	r0, #1
{
    127a:	b410      	push	{r4}
    if ( ui32Module < AM_REG_IOMSTR_NUM_MODULES )
    127c:	d906      	bls.n	128c <am_hal_iom_enable+0x14>
        if ( g_ui32Mod1Interface == AM_HAL_IOM_SPIMODE )
    127e:	481d      	ldr	r0, [pc, #116]	; (12f4 <am_hal_iom_enable+0x7c>)
    1280:	6803      	ldr	r3, [r0, #0]
    1282:	2b01      	cmp	r3, #1
    1284:	d025      	beq.n	12d2 <am_hal_iom_enable+0x5a>
}
    1286:	f85d 4b04 	ldr.w	r4, [sp], #4
    128a:	4770      	bx	lr
        AM_REGn(IOMSTR, ui32Module, CFG) |= AM_REG_IOMSTR_CFG_IFCEN(1);
    128c:	f500 23a0 	add.w	r3, r0, #327680	; 0x50000
    1290:	3304      	adds	r3, #4
    1292:	031b      	lsls	r3, r3, #12
        g_bIomBusy[ui32Module] = false;
    1294:	4918      	ldr	r1, [pc, #96]	; (12f8 <am_hal_iom_enable+0x80>)
        AM_REGn(IOMSTR, ui32Module, CFG) |= AM_REG_IOMSTR_CFG_IFCEN(1);
    1296:	f8d3 211c 	ldr.w	r2, [r3, #284]	; 0x11c
        g_bIomBusy[ui32Module] = false;
    129a:	2400      	movs	r4, #0
        AM_REGn(IOMSTR, ui32Module, CFG) |= AM_REG_IOMSTR_CFG_IFCEN(1);
    129c:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
    12a0:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
        g_bIomBusy[ui32Module] = false;
    12a4:	540c      	strb	r4, [r1, r0]
    if ( ui32Module == 0 )
    12a6:	2800      	cmp	r0, #0
    12a8:	d1e9      	bne.n	127e <am_hal_iom_enable+0x6>
        if ( g_ui32Mod0Interface == AM_HAL_IOM_SPIMODE )
    12aa:	4914      	ldr	r1, [pc, #80]	; (12fc <am_hal_iom_enable+0x84>)
    12ac:	680c      	ldr	r4, [r1, #0]
    12ae:	2c01      	cmp	r4, #1
    12b0:	d1e9      	bne.n	1286 <am_hal_iom_enable+0xe>
            AM_REGn(GPIO, 0, PADKEY) = AM_REG_GPIO_PADKEY_KEYVAL;
    12b2:	4913      	ldr	r1, [pc, #76]	; (1300 <am_hal_iom_enable+0x88>)
            AM_BFW(GPIO, PADREGB, PAD5INPEN, 1);
    12b4:	4b13      	ldr	r3, [pc, #76]	; (1304 <am_hal_iom_enable+0x8c>)
            AM_REGn(GPIO, 0, PADKEY) = AM_REG_GPIO_PADKEY_KEYVAL;
    12b6:	2273      	movs	r2, #115	; 0x73
    12b8:	600a      	str	r2, [r1, #0]
            AM_BFW(GPIO, PADREGB, PAD5INPEN, 1);
    12ba:	681c      	ldr	r4, [r3, #0]
    12bc:	f444 7200 	orr.w	r2, r4, #512	; 0x200
    12c0:	601a      	str	r2, [r3, #0]
            AM_BFW(GPIO, PADREGB, PAD6INPEN, 1);
    12c2:	681c      	ldr	r4, [r3, #0]
    12c4:	f444 3200 	orr.w	r2, r4, #131072	; 0x20000
    12c8:	601a      	str	r2, [r3, #0]
}
    12ca:	f85d 4b04 	ldr.w	r4, [sp], #4
            AM_REGn(GPIO, 0, PADKEY) = 0;
    12ce:	6008      	str	r0, [r1, #0]
}
    12d0:	4770      	bx	lr
            AM_REGn(GPIO, 0, PADKEY) = AM_REG_GPIO_PADKEY_KEYVAL;
    12d2:	490b      	ldr	r1, [pc, #44]	; (1300 <am_hal_iom_enable+0x88>)
            AM_BFW(GPIO, PADREGC, PAD8INPEN, 1);
    12d4:	4c0c      	ldr	r4, [pc, #48]	; (1308 <am_hal_iom_enable+0x90>)
            AM_REGn(GPIO, 0, PADKEY) = AM_REG_GPIO_PADKEY_KEYVAL;
    12d6:	2273      	movs	r2, #115	; 0x73
    12d8:	600a      	str	r2, [r1, #0]
            AM_BFW(GPIO, PADREGC, PAD8INPEN, 1);
    12da:	6820      	ldr	r0, [r4, #0]
    12dc:	f040 0302 	orr.w	r3, r0, #2
    12e0:	6023      	str	r3, [r4, #0]
            AM_BFW(GPIO, PADREGC, PAD9INPEN, 1);
    12e2:	6822      	ldr	r2, [r4, #0]
            AM_REGn(GPIO, 0, PADKEY) = 0;
    12e4:	2000      	movs	r0, #0
            AM_BFW(GPIO, PADREGC, PAD9INPEN, 1);
    12e6:	f442 7300 	orr.w	r3, r2, #512	; 0x200
    12ea:	6023      	str	r3, [r4, #0]
            AM_REGn(GPIO, 0, PADKEY) = 0;
    12ec:	6008      	str	r0, [r1, #0]
}
    12ee:	f85d 4b04 	ldr.w	r4, [sp], #4
    12f2:	4770      	bx	lr
    12f4:	10001014 	.word	0x10001014
    12f8:	1000100c 	.word	0x1000100c
    12fc:	10001010 	.word	0x10001010
    1300:	40010060 	.word	0x40010060
    1304:	40010004 	.word	0x40010004
    1308:	40010008 	.word	0x40010008

0000130c <am_hal_iom_config>:
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    130c:	2801      	cmp	r0, #1
    130e:	d900      	bls.n	1312 <am_hal_iom_config+0x6>
    1310:	4770      	bx	lr
{
    1312:	b538      	push	{r3, r4, r5, lr}
    ui32Config = psConfig->ui32InterfaceMode;
    1314:	680b      	ldr	r3, [r1, #0]
    if ( ui32Module == 0 )
    1316:	b348      	cbz	r0, 136c <am_hal_iom_config+0x60>
        g_ui32Mod1Interface = psConfig->ui32InterfaceMode;
    1318:	4a24      	ldr	r2, [pc, #144]	; (13ac <am_hal_iom_config+0xa0>)
    131a:	6013      	str	r3, [r2, #0]
    if ( psConfig->bSPHA )
    131c:	7a0d      	ldrb	r5, [r1, #8]
    131e:	b10d      	cbz	r5, 1324 <am_hal_iom_config+0x18>
        ui32Config |= AM_REG_IOMSTR_CFG_SPHA(1);
    1320:	f043 0304 	orr.w	r3, r3, #4
    if ( psConfig->bSPOL )
    1324:	7a4a      	ldrb	r2, [r1, #9]
    1326:	b10a      	cbz	r2, 132c <am_hal_iom_config+0x20>
        ui32Config |= AM_REG_IOMSTR_CFG_SPOL(1);
    1328:	f043 0302 	orr.w	r3, r3, #2
    AM_REGn(IOMSTR, ui32Module, CFG) = ui32Config;
    132c:	f500 20a0 	add.w	r0, r0, #327680	; 0x50000
    1330:	3004      	adds	r0, #4
    1332:	0304      	lsls	r4, r0, #12
    1334:	460d      	mov	r5, r1
    1336:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
    am_hal_debug_assert_msg(
    133a:	7a89      	ldrb	r1, [r1, #10]
    133c:	293c      	cmp	r1, #60	; 0x3c
    133e:	d82e      	bhi.n	139e <am_hal_iom_config+0x92>
    am_hal_debug_assert_msg(
    1340:	7aea      	ldrb	r2, [r5, #11]
    1342:	2a3c      	cmp	r2, #60	; 0x3c
    1344:	d824      	bhi.n	1390 <am_hal_iom_config+0x84>
    am_hal_debug_assert_msg(
    1346:	7aab      	ldrb	r3, [r5, #10]
    1348:	2b03      	cmp	r3, #3
    134a:	d91a      	bls.n	1382 <am_hal_iom_config+0x76>
    am_hal_debug_assert_msg(
    134c:	7ae8      	ldrb	r0, [r5, #11]
    134e:	2803      	cmp	r0, #3
    1350:	d90f      	bls.n	1372 <am_hal_iom_config+0x66>
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(psConfig->ui8WriteThreshold) |
    1352:	7aa9      	ldrb	r1, [r5, #10]
    1354:	020b      	lsls	r3, r1, #8
         AM_REG_IOMSTR_FIFOTHR_FIFORTHR(psConfig->ui8ReadThreshold));
    1356:	f000 023f 	and.w	r2, r0, #63	; 0x3f
        (AM_REG_IOMSTR_FIFOTHR_FIFOWTHR(psConfig->ui8WriteThreshold) |
    135a:	f403 507c 	and.w	r0, r3, #16128	; 0x3f00
    135e:	4310      	orrs	r0, r2
    AM_REGn(IOMSTR, ui32Module, FIFOTHR) =
    1360:	f8c4 0108 	str.w	r0, [r4, #264]	; 0x108
    AM_REGn(IOMSTR, ui32Module, CLKCFG) = psConfig->ui32ClockFrequency;
    1364:	686d      	ldr	r5, [r5, #4]
    1366:	f8c4 510c 	str.w	r5, [r4, #268]	; 0x10c
    136a:	bd38      	pop	{r3, r4, r5, pc}
        g_ui32Mod0Interface = psConfig->ui32InterfaceMode;
    136c:	4c10      	ldr	r4, [pc, #64]	; (13b0 <am_hal_iom_config+0xa4>)
    136e:	6023      	str	r3, [r4, #0]
    1370:	e7d4      	b.n	131c <am_hal_iom_config+0x10>
    am_hal_debug_assert_msg(
    1372:	4810      	ldr	r0, [pc, #64]	; (13b4 <am_hal_iom_config+0xa8>)
    1374:	4a10      	ldr	r2, [pc, #64]	; (13b8 <am_hal_iom_config+0xac>)
    1376:	f44f 71ad 	mov.w	r1, #346	; 0x15a
    137a:	f000 fa79 	bl	1870 <am_hal_debug_error>
    137e:	7ae8      	ldrb	r0, [r5, #11]
    1380:	e7e7      	b.n	1352 <am_hal_iom_config+0x46>
    am_hal_debug_assert_msg(
    1382:	4a0e      	ldr	r2, [pc, #56]	; (13bc <am_hal_iom_config+0xb0>)
    1384:	480b      	ldr	r0, [pc, #44]	; (13b4 <am_hal_iom_config+0xa8>)
    1386:	f44f 71ac 	mov.w	r1, #344	; 0x158
    138a:	f000 fa71 	bl	1870 <am_hal_debug_error>
    138e:	e7dd      	b.n	134c <am_hal_iom_config+0x40>
    am_hal_debug_assert_msg(
    1390:	4a0b      	ldr	r2, [pc, #44]	; (13c0 <am_hal_iom_config+0xb4>)
    1392:	4808      	ldr	r0, [pc, #32]	; (13b4 <am_hal_iom_config+0xa8>)
    1394:	f44f 71ab 	mov.w	r1, #342	; 0x156
    1398:	f000 fa6a 	bl	1870 <am_hal_debug_error>
    139c:	e7d3      	b.n	1346 <am_hal_iom_config+0x3a>
    am_hal_debug_assert_msg(
    139e:	4a09      	ldr	r2, [pc, #36]	; (13c4 <am_hal_iom_config+0xb8>)
    13a0:	4804      	ldr	r0, [pc, #16]	; (13b4 <am_hal_iom_config+0xa8>)
    13a2:	f44f 71aa 	mov.w	r1, #340	; 0x154
    13a6:	f000 fa63 	bl	1870 <am_hal_debug_error>
    13aa:	e7c9      	b.n	1340 <am_hal_iom_config+0x34>
    13ac:	10001014 	.word	0x10001014
    13b0:	10001010 	.word	0x10001010
    13b4:	00004428 	.word	0x00004428
    13b8:	000043e4 	.word	0x000043e4
    13bc:	000043c4 	.word	0x000043c4
    13c0:	000043a8 	.word	0x000043a8
    13c4:	00004388 	.word	0x00004388

000013c8 <am_hal_iom_i2c_write>:
    if ( ui32Module > AM_REG_IOMSTR_NUM_MODULES )
    13c8:	2802      	cmp	r0, #2
    13ca:	d823      	bhi.n	1414 <am_hal_iom_i2c_write+0x4c>
{
    13cc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    13d0:	461d      	mov	r5, r3
    13d2:	b08a      	sub	sp, #40	; 0x28
    13d4:	4617      	mov	r7, r2
    13d6:	460e      	mov	r6, r1
    13d8:	4604      	mov	r4, r0
    am_hal_debug_assert_msg(ui32NumBytes > 0,
    13da:	b1e3      	cbz	r3, 1416 <am_hal_iom_i2c_write+0x4e>
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
    13dc:	2802      	cmp	r0, #2
    13de:	d022      	beq.n	1426 <am_hal_iom_i2c_write+0x5e>
    am_hal_debug_assert_msg(ui32NumBytes < 256, "I2C transfer too big.");
    13e0:	2bff      	cmp	r3, #255	; 0xff
    13e2:	d830      	bhi.n	1446 <am_hal_iom_i2c_write+0x7e>
    if ( g_psIOMQueue[ui32Module].pui8Data != NULL )
    13e4:	ea4f 0844 	mov.w	r8, r4, lsl #1
    13e8:	f8df 9140 	ldr.w	r9, [pc, #320]	; 152c <am_hal_iom_i2c_write+0x164>
    13ec:	eb08 0204 	add.w	r2, r8, r4
    13f0:	eb09 0ac2 	add.w	sl, r9, r2, lsl #3
    13f4:	f8da 3014 	ldr.w	r3, [sl, #20]
    13f8:	2b00      	cmp	r3, #0
    13fa:	f040 8081 	bne.w	1500 <am_hal_iom_i2c_write+0x138>
    13fe:	9812      	ldr	r0, [sp, #72]	; 0x48
    1400:	9000      	str	r0, [sp, #0]
    1402:	462b      	mov	r3, r5
    1404:	463a      	mov	r2, r7
    1406:	4631      	mov	r1, r6
    1408:	4620      	mov	r0, r4
    140a:	f7ff faa9 	bl	960 <am_hal_iom_i2c_write_nq.part.7>
}
    140e:	b00a      	add	sp, #40	; 0x28
    1410:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1414:	4770      	bx	lr
    am_hal_debug_assert_msg(ui32NumBytes > 0,
    1416:	4a3f      	ldr	r2, [pc, #252]	; (1514 <am_hal_iom_i2c_write+0x14c>)
    1418:	483f      	ldr	r0, [pc, #252]	; (1518 <am_hal_iom_i2c_write+0x150>)
    141a:	f44f 61af 	mov.w	r1, #1400	; 0x578
    141e:	f000 fa27 	bl	1870 <am_hal_debug_error>
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
    1422:	2c02      	cmp	r4, #2
    1424:	d1de      	bne.n	13e4 <am_hal_iom_i2c_write+0x1c>
        if ( ui32Options & AM_HAL_IOM_RAW )
    1426:	9912      	ldr	r1, [sp, #72]	; 0x48
    1428:	004a      	lsls	r2, r1, #1
    142a:	d559      	bpl.n	14e0 <am_hal_iom_i2c_write+0x118>
            am_hal_i2c_bit_bang_send(ui32BusAddress << 1, ui32NumBytes,
    142c:	f3c1 7400 	ubfx	r4, r1, #28, #1
    1430:	0070      	lsls	r0, r6, #1
    1432:	2300      	movs	r3, #0
    1434:	463a      	mov	r2, r7
    1436:	4629      	mov	r1, r5
    1438:	e88d 0018 	stmia.w	sp, {r3, r4}
    143c:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
    1440:	f000 fe6a 	bl	2118 <am_hal_i2c_bit_bang_send>
    1444:	e7e3      	b.n	140e <am_hal_iom_i2c_write+0x46>
    am_hal_debug_assert_msg(ui32NumBytes < 256, "I2C transfer too big.");
    1446:	4834      	ldr	r0, [pc, #208]	; (1518 <am_hal_iom_i2c_write+0x150>)
    1448:	4a34      	ldr	r2, [pc, #208]	; (151c <am_hal_iom_i2c_write+0x154>)
    if ( g_psIOMQueue[ui32Module].pui8Data != NULL )
    144a:	f8df 90e0 	ldr.w	r9, [pc, #224]	; 152c <am_hal_iom_i2c_write+0x164>
    am_hal_debug_assert_msg(ui32NumBytes < 256, "I2C transfer too big.");
    144e:	f44f 61b3 	mov.w	r1, #1432	; 0x598
    if ( g_psIOMQueue[ui32Module].pui8Data != NULL )
    1452:	ea4f 0844 	mov.w	r8, r4, lsl #1
    am_hal_debug_assert_msg(ui32NumBytes < 256, "I2C transfer too big.");
    1456:	f000 fa0b 	bl	1870 <am_hal_debug_error>
    if ( g_psIOMQueue[ui32Module].pui8Data != NULL )
    145a:	eb08 0304 	add.w	r3, r8, r4
    145e:	eb09 00c3 	add.w	r0, r9, r3, lsl #3
    1462:	6941      	ldr	r1, [r0, #20]
    1464:	2900      	cmp	r1, #0
    1466:	d0ca      	beq.n	13fe <am_hal_iom_i2c_write+0x36>
    ui32Critical = am_hal_interrupt_master_disable();
    1468:	f7ff f9a8 	bl	7bc <am_hal_interrupt_master_disable>
    if ( (g_bIomBusy[ui32Module] == false) &&
    146c:	492c      	ldr	r1, [pc, #176]	; (1520 <am_hal_iom_i2c_write+0x158>)
    146e:	5d0a      	ldrb	r2, [r1, r4]
    ui32Critical = am_hal_interrupt_master_disable();
    1470:	4682      	mov	sl, r0
    if ( (g_bIomBusy[ui32Module] == false) &&
    1472:	b9ca      	cbnz	r2, 14a8 <am_hal_iom_i2c_write+0xe0>
        am_hal_queue_empty(&g_psIOMQueue[ui32Module]) )
    1474:	eb08 0c04 	add.w	ip, r8, r4
    1478:	eb09 0ecc 	add.w	lr, r9, ip, lsl #3
    if ( (g_bIomBusy[ui32Module] == false) &&
    147c:	f8de 3008 	ldr.w	r3, [lr, #8]
    1480:	b993      	cbnz	r3, 14a8 <am_hal_iom_i2c_write+0xe0>
    1482:	9812      	ldr	r0, [sp, #72]	; 0x48
    1484:	9301      	str	r3, [sp, #4]
    1486:	9000      	str	r0, [sp, #0]
    1488:	462b      	mov	r3, r5
    148a:	463a      	mov	r2, r7
    148c:	4631      	mov	r1, r6
    148e:	4620      	mov	r0, r4
    1490:	f7ff fc24 	bl	cdc <am_hal_iom_i2c_write_nb.part.9>
        am_hal_iom_queue_flush(ui32Module);
    1494:	4e23      	ldr	r6, [pc, #140]	; (1524 <am_hal_iom_i2c_write+0x15c>)
    am_hal_interrupt_master_set(ui32Critical);
    1496:	4650      	mov	r0, sl
    1498:	f7ff f994 	bl	7c4 <am_hal_interrupt_master_set>
        am_hal_iom_queue_flush(ui32Module);
    149c:	4620      	mov	r0, r4
    149e:	6834      	ldr	r4, [r6, #0]
    14a0:	47a0      	blx	r4
}
    14a2:	b00a      	add	sp, #40	; 0x28
    14a4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    14a8:	44a0      	add	r8, r4
    14aa:	eb09 00c8 	add.w	r0, r9, r8, lsl #3
        sIOMTransaction.pfnCallback = pfnCallback;
    14ae:	2300      	movs	r3, #0
        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_I2C_WRITE;
    14b0:	f04f 0902 	mov.w	r9, #2
        sIOMTransaction.ui32NumBytes = ui32NumBytes;
    14b4:	9507      	str	r5, [sp, #28]
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    14b6:	2201      	movs	r2, #1
        sIOMTransaction.ui32Options = ui32Options;
    14b8:	9d12      	ldr	r5, [sp, #72]	; 0x48
        sIOMTransaction.ui32Module = ui32Module;
    14ba:	9404      	str	r4, [sp, #16]
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    14bc:	a903      	add	r1, sp, #12
        sIOMTransaction.ui32ChipSelect = ui32BusAddress;
    14be:	9605      	str	r6, [sp, #20]
        sIOMTransaction.pui32Data = pui32Data;
    14c0:	9706      	str	r7, [sp, #24]
        sIOMTransaction.ui32Options = ui32Options;
    14c2:	9508      	str	r5, [sp, #32]
        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_I2C_WRITE;
    14c4:	f8cd 900c 	str.w	r9, [sp, #12]
        sIOMTransaction.pfnCallback = pfnCallback;
    14c8:	9309      	str	r3, [sp, #36]	; 0x24
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    14ca:	f000 f90f 	bl	16ec <am_hal_queue_item_add>
    14ce:	2800      	cmp	r0, #0
    14d0:	d1e0      	bne.n	1494 <am_hal_iom_i2c_write+0xcc>
            am_hal_debug_assert_msg(0,
    14d2:	4a15      	ldr	r2, [pc, #84]	; (1528 <am_hal_iom_i2c_write+0x160>)
    14d4:	4810      	ldr	r0, [pc, #64]	; (1518 <am_hal_iom_i2c_write+0x150>)
    14d6:	f640 3194 	movw	r1, #2964	; 0xb94
    14da:	f000 f9c9 	bl	1870 <am_hal_debug_error>
    14de:	e7d9      	b.n	1494 <am_hal_iom_i2c_write+0xcc>
            am_hal_i2c_bit_bang_send(ui32BusAddress << 1, ui32NumBytes,
    14e0:	0072      	lsls	r2, r6, #1
    14e2:	f002 00fe 	and.w	r0, r2, #254	; 0xfe
    14e6:	463a      	mov	r2, r7
    14e8:	9f12      	ldr	r7, [sp, #72]	; 0x48
    14ea:	f3c1 7400 	ubfx	r4, r1, #28, #1
    14ee:	2301      	movs	r3, #1
    14f0:	e88d 0018 	stmia.w	sp, {r3, r4}
    14f4:	4629      	mov	r1, r5
    14f6:	f3c7 2307 	ubfx	r3, r7, #8, #8
    14fa:	f000 fe0d 	bl	2118 <am_hal_i2c_bit_bang_send>
    14fe:	e786      	b.n	140e <am_hal_iom_i2c_write+0x46>
    am_hal_debug_assert_msg(ui32NumBytes > 0,
    1500:	2d00      	cmp	r5, #0
    1502:	d1b1      	bne.n	1468 <am_hal_iom_i2c_write+0xa0>
    1504:	4a03      	ldr	r2, [pc, #12]	; (1514 <am_hal_iom_i2c_write+0x14c>)
    1506:	4804      	ldr	r0, [pc, #16]	; (1518 <am_hal_iom_i2c_write+0x150>)
    1508:	f640 3163 	movw	r1, #2915	; 0xb63
    150c:	f000 f9b0 	bl	1870 <am_hal_debug_error>
    1510:	e7aa      	b.n	1468 <am_hal_iom_i2c_write+0xa0>
    1512:	bf00      	nop
    1514:	00004404 	.word	0x00004404
    1518:	00004428 	.word	0x00004428
    151c:	0000443c 	.word	0x0000443c
    1520:	1000100c 	.word	0x1000100c
    1524:	10001000 	.word	0x10001000
    1528:	000044a4 	.word	0x000044a4
    152c:	1000135c 	.word	0x1000135c

00001530 <am_hal_iom_i2c_read>:
    if ( ui32Module > AM_REG_IOMSTR_NUM_MODULES )
    1530:	2802      	cmp	r0, #2
    1532:	d823      	bhi.n	157c <am_hal_iom_i2c_read+0x4c>
{
    1534:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    1538:	461d      	mov	r5, r3
    153a:	b08a      	sub	sp, #40	; 0x28
    153c:	4617      	mov	r7, r2
    153e:	460e      	mov	r6, r1
    1540:	4604      	mov	r4, r0
    am_hal_debug_assert_msg(ui32NumBytes > 0,
    1542:	b1e3      	cbz	r3, 157e <am_hal_iom_i2c_read+0x4e>
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
    1544:	2802      	cmp	r0, #2
    1546:	d022      	beq.n	158e <am_hal_iom_i2c_read+0x5e>
    am_hal_debug_assert_msg(ui32NumBytes < 256, "I2C transfer too big.");
    1548:	2bff      	cmp	r3, #255	; 0xff
    154a:	d831      	bhi.n	15b0 <am_hal_iom_i2c_read+0x80>
    if ( g_psIOMQueue[ui32Module].pui8Data != NULL )
    154c:	ea4f 0844 	mov.w	r8, r4, lsl #1
    1550:	f8df 9144 	ldr.w	r9, [pc, #324]	; 1698 <am_hal_iom_i2c_read+0x168>
    1554:	eb08 0204 	add.w	r2, r8, r4
    1558:	eb09 0ac2 	add.w	sl, r9, r2, lsl #3
    155c:	f8da 3014 	ldr.w	r3, [sl, #20]
    1560:	2b00      	cmp	r3, #0
    1562:	f040 8083 	bne.w	166c <am_hal_iom_i2c_read+0x13c>
    1566:	9812      	ldr	r0, [sp, #72]	; 0x48
    1568:	9000      	str	r0, [sp, #0]
    156a:	462b      	mov	r3, r5
    156c:	463a      	mov	r2, r7
    156e:	4631      	mov	r1, r6
    1570:	4620      	mov	r0, r4
    1572:	f7ff fcc1 	bl	ef8 <am_hal_iom_i2c_read_nq.part.8>
}
    1576:	b00a      	add	sp, #40	; 0x28
    1578:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    157c:	4770      	bx	lr
    am_hal_debug_assert_msg(ui32NumBytes > 0,
    157e:	4a40      	ldr	r2, [pc, #256]	; (1680 <am_hal_iom_i2c_read+0x150>)
    1580:	4840      	ldr	r0, [pc, #256]	; (1684 <am_hal_iom_i2c_read+0x154>)
    1582:	f240 51e6 	movw	r1, #1510	; 0x5e6
    1586:	f000 f973 	bl	1870 <am_hal_debug_error>
    if ( ui32Module == AM_HAL_IOM_I2CBB_MODULE )
    158a:	2c02      	cmp	r4, #2
    158c:	d1de      	bne.n	154c <am_hal_iom_i2c_read+0x1c>
        if ( ui32Options & AM_HAL_IOM_RAW )
    158e:	9b12      	ldr	r3, [sp, #72]	; 0x48
    1590:	005a      	lsls	r2, r3, #1
    1592:	d55a      	bpl.n	164a <am_hal_iom_i2c_read+0x11a>
            am_hal_i2c_bit_bang_receive((ui32BusAddress << 1) | 1, ui32NumBytes,
    1594:	0070      	lsls	r0, r6, #1
    1596:	f3c3 7400 	ubfx	r4, r3, #28, #1
    159a:	f040 0601 	orr.w	r6, r0, #1
    159e:	2300      	movs	r3, #0
    15a0:	b2f0      	uxtb	r0, r6
    15a2:	463a      	mov	r2, r7
    15a4:	4629      	mov	r1, r5
    15a6:	e88d 0018 	stmia.w	sp, {r3, r4}
    15aa:	f000 f963 	bl	1874 <am_hal_i2c_bit_bang_receive>
    15ae:	e7e2      	b.n	1576 <am_hal_iom_i2c_read+0x46>
    am_hal_debug_assert_msg(ui32NumBytes < 256, "I2C transfer too big.");
    15b0:	4834      	ldr	r0, [pc, #208]	; (1684 <am_hal_iom_i2c_read+0x154>)
    15b2:	4a35      	ldr	r2, [pc, #212]	; (1688 <am_hal_iom_i2c_read+0x158>)
    if ( g_psIOMQueue[ui32Module].pui8Data != NULL )
    15b4:	f8df 90e0 	ldr.w	r9, [pc, #224]	; 1698 <am_hal_iom_i2c_read+0x168>
    am_hal_debug_assert_msg(ui32NumBytes < 256, "I2C transfer too big.");
    15b8:	f240 6106 	movw	r1, #1542	; 0x606
    if ( g_psIOMQueue[ui32Module].pui8Data != NULL )
    15bc:	ea4f 0844 	mov.w	r8, r4, lsl #1
    am_hal_debug_assert_msg(ui32NumBytes < 256, "I2C transfer too big.");
    15c0:	f000 f956 	bl	1870 <am_hal_debug_error>
    if ( g_psIOMQueue[ui32Module].pui8Data != NULL )
    15c4:	eb08 0304 	add.w	r3, r8, r4
    15c8:	eb09 00c3 	add.w	r0, r9, r3, lsl #3
    15cc:	6941      	ldr	r1, [r0, #20]
    15ce:	2900      	cmp	r1, #0
    15d0:	d0c9      	beq.n	1566 <am_hal_iom_i2c_read+0x36>
    ui32Critical = am_hal_interrupt_master_disable();
    15d2:	f7ff f8f3 	bl	7bc <am_hal_interrupt_master_disable>
    if ( (g_bIomBusy[ui32Module] == false) &&
    15d6:	492d      	ldr	r1, [pc, #180]	; (168c <am_hal_iom_i2c_read+0x15c>)
    15d8:	5d0a      	ldrb	r2, [r1, r4]
    ui32Critical = am_hal_interrupt_master_disable();
    15da:	4682      	mov	sl, r0
    if ( (g_bIomBusy[ui32Module] == false) &&
    15dc:	b9ca      	cbnz	r2, 1612 <am_hal_iom_i2c_read+0xe2>
        am_hal_queue_empty(&g_psIOMQueue[ui32Module]) )
    15de:	eb08 0c04 	add.w	ip, r8, r4
    15e2:	eb09 0ecc 	add.w	lr, r9, ip, lsl #3
    if ( (g_bIomBusy[ui32Module] == false) &&
    15e6:	f8de 3008 	ldr.w	r3, [lr, #8]
    15ea:	b993      	cbnz	r3, 1612 <am_hal_iom_i2c_read+0xe2>
    15ec:	9812      	ldr	r0, [sp, #72]	; 0x48
    15ee:	9301      	str	r3, [sp, #4]
    15f0:	9000      	str	r0, [sp, #0]
    15f2:	462b      	mov	r3, r5
    15f4:	463a      	mov	r2, r7
    15f6:	4631      	mov	r1, r6
    15f8:	4620      	mov	r0, r4
    15fa:	f7ff f909 	bl	810 <am_hal_iom_i2c_read_nb.part.10>
        am_hal_iom_queue_flush(ui32Module);
    15fe:	4e24      	ldr	r6, [pc, #144]	; (1690 <am_hal_iom_i2c_read+0x160>)
    am_hal_interrupt_master_set(ui32Critical);
    1600:	4650      	mov	r0, sl
    1602:	f7ff f8df 	bl	7c4 <am_hal_interrupt_master_set>
        am_hal_iom_queue_flush(ui32Module);
    1606:	4620      	mov	r0, r4
    1608:	6834      	ldr	r4, [r6, #0]
    160a:	47a0      	blx	r4
}
    160c:	b00a      	add	sp, #40	; 0x28
    160e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    1612:	44a0      	add	r8, r4
    1614:	eb09 00c8 	add.w	r0, r9, r8, lsl #3
        sIOMTransaction.pfnCallback = pfnCallback;
    1618:	2300      	movs	r3, #0
        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_I2C_READ;
    161a:	f04f 0903 	mov.w	r9, #3
        sIOMTransaction.ui32NumBytes = ui32NumBytes;
    161e:	9507      	str	r5, [sp, #28]
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    1620:	2201      	movs	r2, #1
        sIOMTransaction.ui32Options = ui32Options;
    1622:	9d12      	ldr	r5, [sp, #72]	; 0x48
        sIOMTransaction.ui32Module = ui32Module;
    1624:	9404      	str	r4, [sp, #16]
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    1626:	a903      	add	r1, sp, #12
        sIOMTransaction.ui32ChipSelect = ui32BusAddress;
    1628:	9605      	str	r6, [sp, #20]
        sIOMTransaction.pui32Data = pui32Data;
    162a:	9706      	str	r7, [sp, #24]
        sIOMTransaction.ui32Options = ui32Options;
    162c:	9508      	str	r5, [sp, #32]
        sIOMTransaction.ui32Operation = AM_HAL_IOM_QUEUE_I2C_READ;
    162e:	f8cd 900c 	str.w	r9, [sp, #12]
        sIOMTransaction.pfnCallback = pfnCallback;
    1632:	9309      	str	r3, [sp, #36]	; 0x24
        if ( am_hal_queue_item_add(&g_psIOMQueue[ui32Module], &sIOMTransaction, 1) == false )
    1634:	f000 f85a 	bl	16ec <am_hal_queue_item_add>
    1638:	2800      	cmp	r0, #0
    163a:	d1e0      	bne.n	15fe <am_hal_iom_i2c_read+0xce>
            am_hal_debug_assert_msg(0, "The IOM queue is full. Allocate more"
    163c:	4a15      	ldr	r2, [pc, #84]	; (1694 <am_hal_iom_i2c_read+0x164>)
    163e:	4811      	ldr	r0, [pc, #68]	; (1684 <am_hal_iom_i2c_read+0x154>)
    1640:	f640 31ff 	movw	r1, #3071	; 0xbff
    1644:	f000 f914 	bl	1870 <am_hal_debug_error>
    1648:	e7d9      	b.n	15fe <am_hal_iom_i2c_read+0xce>
            am_hal_i2c_bit_bang_receive((ui32BusAddress << 1) | 1, ui32NumBytes,
    164a:	0071      	lsls	r1, r6, #1
    164c:	f041 0201 	orr.w	r2, r1, #1
    1650:	b2d0      	uxtb	r0, r2
    1652:	463a      	mov	r2, r7
    1654:	9f12      	ldr	r7, [sp, #72]	; 0x48
    1656:	f3c3 7400 	ubfx	r4, r3, #28, #1
    165a:	2301      	movs	r3, #1
    165c:	e88d 0018 	stmia.w	sp, {r3, r4}
    1660:	4629      	mov	r1, r5
    1662:	f3c7 2307 	ubfx	r3, r7, #8, #8
    1666:	f000 f905 	bl	1874 <am_hal_i2c_bit_bang_receive>
    166a:	e784      	b.n	1576 <am_hal_iom_i2c_read+0x46>
    am_hal_debug_assert_msg(ui32NumBytes > 0,
    166c:	2d00      	cmp	r5, #0
    166e:	d1b0      	bne.n	15d2 <am_hal_iom_i2c_read+0xa2>
    1670:	4a03      	ldr	r2, [pc, #12]	; (1680 <am_hal_iom_i2c_read+0x150>)
    1672:	4804      	ldr	r0, [pc, #16]	; (1684 <am_hal_iom_i2c_read+0x154>)
    1674:	f640 31cf 	movw	r1, #3023	; 0xbcf
    1678:	f000 f8fa 	bl	1870 <am_hal_debug_error>
    167c:	e7a9      	b.n	15d2 <am_hal_iom_i2c_read+0xa2>
    167e:	bf00      	nop
    1680:	00004404 	.word	0x00004404
    1684:	00004428 	.word	0x00004428
    1688:	0000443c 	.word	0x0000443c
    168c:	1000100c 	.word	0x1000100c
    1690:	10001000 	.word	0x10001000
    1694:	000044a4 	.word	0x000044a4
    1698:	1000135c 	.word	0x1000135c

0000169c <am_hal_iom_int_clear>:
am_hal_iom_int_clear(uint32_t ui32Module, uint32_t ui32Interrupt)
{
    //
    // Validate parameters
    //
    if ( ui32Module >= AM_REG_IOMSTR_NUM_MODULES )
    169c:	2801      	cmp	r0, #1
    169e:	d805      	bhi.n	16ac <am_hal_iom_int_clear+0x10>
    {
        return;
    }

    AM_REGn(IOMSTR, ui32Module, INTCLR) = ui32Interrupt;
    16a0:	f500 20a0 	add.w	r0, r0, #327680	; 0x50000
    16a4:	3004      	adds	r0, #4
    16a6:	0302      	lsls	r2, r0, #12
    16a8:	f8c2 1208 	str.w	r1, [r2, #520]	; 0x208
    16ac:	4770      	bx	lr
    16ae:	bf00      	nop

000016b0 <am_hal_mcuctrl_bandgap_disable>:
am_hal_mcuctrl_bandgap_disable(void)
{
    //
    // Disable the Bandgap in the MCUCTRL.
    //
    AM_REG(MCUCTRL, BANDGAPEN) = ~AM_REG_MCUCTRL_BANDGAPEN_BGPEN_M;
    16b0:	4b02      	ldr	r3, [pc, #8]	; (16bc <am_hal_mcuctrl_bandgap_disable+0xc>)
    16b2:	f06f 0201 	mvn.w	r2, #1
    16b6:	601a      	str	r2, [r3, #0]
    16b8:	4770      	bx	lr
    16ba:	bf00      	nop
    16bc:	400200fc 	.word	0x400200fc

000016c0 <am_hal_mcuctrl_bucks_enable>:
am_hal_mcuctrl_bucks_enable(void)
{
    //
    // Enable the core buck converter in the MCUCTRL.
    //
    AM_BFW(MCUCTRL, SUPPLYSRC, COREBUCKEN, 1);
    16c0:	4b08      	ldr	r3, [pc, #32]	; (16e4 <am_hal_mcuctrl_bucks_enable+0x24>)
    AM_BFW(MCUCTRL, SUPPLYSRC, MEMBUCKEN, 1);

    //
    // Poll until core buck is enabled.
    //
    while( !AM_BFR(MCUCTRL, SUPPLYSTATUS, COREBUCKON) );
    16c2:	4a09      	ldr	r2, [pc, #36]	; (16e8 <am_hal_mcuctrl_bucks_enable+0x28>)
    AM_BFW(MCUCTRL, SUPPLYSRC, COREBUCKEN, 1);
    16c4:	6819      	ldr	r1, [r3, #0]
    16c6:	f041 0002 	orr.w	r0, r1, #2
    16ca:	6018      	str	r0, [r3, #0]
    AM_BFW(MCUCTRL, SUPPLYSRC, MEMBUCKEN, 1);
    16cc:	6819      	ldr	r1, [r3, #0]
    16ce:	f041 0001 	orr.w	r0, r1, #1
    16d2:	6018      	str	r0, [r3, #0]
    while( !AM_BFR(MCUCTRL, SUPPLYSTATUS, COREBUCKON) );
    16d4:	6813      	ldr	r3, [r2, #0]
    16d6:	0799      	lsls	r1, r3, #30
    16d8:	d5fc      	bpl.n	16d4 <am_hal_mcuctrl_bucks_enable+0x14>

    //
    // Poll until SRAM buck is enabled.
    //
    while( !AM_BFR(MCUCTRL, SUPPLYSTATUS, MEMBUCKON) );
    16da:	4a03      	ldr	r2, [pc, #12]	; (16e8 <am_hal_mcuctrl_bucks_enable+0x28>)
    16dc:	6811      	ldr	r1, [r2, #0]
    16de:	07cb      	lsls	r3, r1, #31
    16e0:	d5fc      	bpl.n	16dc <am_hal_mcuctrl_bucks_enable+0x1c>
}
    16e2:	4770      	bx	lr
    16e4:	40020010 	.word	0x40020010
    16e8:	40020014 	.word	0x40020014

000016ec <am_hal_queue_item_add>:
//! didn't have enough space.
//
//*****************************************************************************
bool
am_hal_queue_item_add(am_hal_queue_t *psQueue, const void *pvSource, uint32_t ui32NumItems)
{
    16ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    16ee:	4604      	mov	r4, r0
    uint32_t i;
    uint8_t *pui8Source;
    uint32_t ui32Bytes = ui32NumItems * psQueue->ui32ItemSize;
    16f0:	6907      	ldr	r7, [r0, #16]
{
    16f2:	460e      	mov	r6, r1
    uint32_t ui32Bytes = ui32NumItems * psQueue->ui32ItemSize;
    16f4:	fb07 f702 	mul.w	r7, r7, r2
    bool bSuccess = false;
    uint32_t ui32Primask;

    pui8Source = (uint8_t *) pvSource;

    ui32Primask = am_hal_interrupt_master_disable();
    16f8:	f7ff f860 	bl	7bc <am_hal_interrupt_master_disable>

    //
    // Check to make sure that the buffer isn't already full
    //
    if ( am_hal_queue_space_left(psQueue) >= ui32Bytes )
    16fc:	68a5      	ldr	r5, [r4, #8]
    16fe:	68e3      	ldr	r3, [r4, #12]
    1700:	1b59      	subs	r1, r3, r5
    1702:	428f      	cmp	r7, r1
    1704:	d87c      	bhi.n	1800 <am_hal_queue_item_add+0x114>
    {
        //
        // Loop over the bytes in the source array.
        //
        for ( i = 0; i < ui32Bytes; i++ )
    1706:	2f00      	cmp	r7, #0
    1708:	d073      	beq.n	17f2 <am_hal_queue_item_add+0x106>
        {
            //
            // Write the value to the buffer.
            //
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    170a:	4635      	mov	r5, r6
    170c:	6823      	ldr	r3, [r4, #0]
    170e:	6962      	ldr	r2, [r4, #20]
    1710:	f815 1b01 	ldrb.w	r1, [r5], #1
    1714:	54d1      	strb	r1, [r2, r3]

            //
            // Advance the write index, making sure to wrap if necessary.
            //
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    1716:	6823      	ldr	r3, [r4, #0]
    1718:	f8d4 e00c 	ldr.w	lr, [r4, #12]
    171c:	1c5a      	adds	r2, r3, #1
    171e:	19f1      	adds	r1, r6, r7
    1720:	f107 3cff 	add.w	ip, r7, #4294967295
    1724:	fbb2 f6fe 	udiv	r6, r2, lr
        for ( i = 0; i < ui32Bytes; i++ )
    1728:	42a9      	cmp	r1, r5
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    172a:	fb0e 2316 	mls	r3, lr, r6, r2
    172e:	6023      	str	r3, [r4, #0]
    1730:	f00c 0203 	and.w	r2, ip, #3
        for ( i = 0; i < ui32Bytes; i++ )
    1734:	d05c      	beq.n	17f0 <am_hal_queue_item_add+0x104>
    1736:	b34a      	cbz	r2, 178c <am_hal_queue_item_add+0xa0>
    1738:	2a01      	cmp	r2, #1
    173a:	d019      	beq.n	1770 <am_hal_queue_item_add+0x84>
    173c:	2a02      	cmp	r2, #2
    173e:	d00b      	beq.n	1758 <am_hal_queue_item_add+0x6c>
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    1740:	6962      	ldr	r2, [r4, #20]
    1742:	f815 6b01 	ldrb.w	r6, [r5], #1
    1746:	54d6      	strb	r6, [r2, r3]
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    1748:	6823      	ldr	r3, [r4, #0]
    174a:	68e6      	ldr	r6, [r4, #12]
    174c:	1c5a      	adds	r2, r3, #1
    174e:	fbb2 fef6 	udiv	lr, r2, r6
    1752:	fb06 231e 	mls	r3, r6, lr, r2
    1756:	6023      	str	r3, [r4, #0]
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    1758:	6962      	ldr	r2, [r4, #20]
    175a:	f815 6b01 	ldrb.w	r6, [r5], #1
    175e:	54d6      	strb	r6, [r2, r3]
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    1760:	6823      	ldr	r3, [r4, #0]
    1762:	68e6      	ldr	r6, [r4, #12]
    1764:	1c5a      	adds	r2, r3, #1
    1766:	fbb2 fcf6 	udiv	ip, r2, r6
    176a:	fb06 231c 	mls	r3, r6, ip, r2
    176e:	6023      	str	r3, [r4, #0]
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    1770:	6962      	ldr	r2, [r4, #20]
    1772:	f815 6b01 	ldrb.w	r6, [r5], #1
    1776:	54d6      	strb	r6, [r2, r3]
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    1778:	6823      	ldr	r3, [r4, #0]
    177a:	68e6      	ldr	r6, [r4, #12]
    177c:	1c5a      	adds	r2, r3, #1
        for ( i = 0; i < ui32Bytes; i++ )
    177e:	42a9      	cmp	r1, r5
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    1780:	fbb2 fef6 	udiv	lr, r2, r6
    1784:	fb06 231e 	mls	r3, r6, lr, r2
    1788:	6023      	str	r3, [r4, #0]
        for ( i = 0; i < ui32Bytes; i++ )
    178a:	d031      	beq.n	17f0 <am_hal_queue_item_add+0x104>
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    178c:	46ac      	mov	ip, r5
    178e:	6962      	ldr	r2, [r4, #20]
    1790:	f81c 6b01 	ldrb.w	r6, [ip], #1
    1794:	54d6      	strb	r6, [r2, r3]
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    1796:	6823      	ldr	r3, [r4, #0]
    1798:	68e2      	ldr	r2, [r4, #12]
    179a:	1c5e      	adds	r6, r3, #1
    179c:	fbb6 fef2 	udiv	lr, r6, r2
    17a0:	fb02 631e 	mls	r3, r2, lr, r6
    17a4:	6023      	str	r3, [r4, #0]
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    17a6:	6962      	ldr	r2, [r4, #20]
    17a8:	786e      	ldrb	r6, [r5, #1]
    17aa:	54d6      	strb	r6, [r2, r3]
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    17ac:	6823      	ldr	r3, [r4, #0]
    17ae:	68e2      	ldr	r2, [r4, #12]
    17b0:	1c5e      	adds	r6, r3, #1
    17b2:	fbb6 fef2 	udiv	lr, r6, r2
    17b6:	fb02 631e 	mls	r3, r2, lr, r6
    17ba:	6023      	str	r3, [r4, #0]
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    17bc:	6962      	ldr	r2, [r4, #20]
    17be:	f89c 6001 	ldrb.w	r6, [ip, #1]
    17c2:	54d6      	strb	r6, [r2, r3]
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    17c4:	6823      	ldr	r3, [r4, #0]
    17c6:	68e2      	ldr	r2, [r4, #12]
    17c8:	1c5e      	adds	r6, r3, #1
    17ca:	fbb6 fcf2 	udiv	ip, r6, r2
    17ce:	fb02 631c 	mls	r3, r2, ip, r6
    17d2:	6023      	str	r3, [r4, #0]
            psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    17d4:	6962      	ldr	r2, [r4, #20]
    17d6:	78ee      	ldrb	r6, [r5, #3]
    17d8:	54d6      	strb	r6, [r2, r3]
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    17da:	6823      	ldr	r3, [r4, #0]
    17dc:	68e2      	ldr	r2, [r4, #12]
    17de:	1c5e      	adds	r6, r3, #1
    17e0:	3504      	adds	r5, #4
    17e2:	fbb6 fef2 	udiv	lr, r6, r2
        for ( i = 0; i < ui32Bytes; i++ )
    17e6:	42a9      	cmp	r1, r5
            psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    17e8:	fb02 631e 	mls	r3, r2, lr, r6
    17ec:	6023      	str	r3, [r4, #0]
        for ( i = 0; i < ui32Bytes; i++ )
    17ee:	d1cd      	bne.n	178c <am_hal_queue_item_add+0xa0>
    17f0:	68a5      	ldr	r5, [r4, #8]
        }

        //
        // Update the length value appropriately.
        //
        psQueue->ui32Length += ui32Bytes;
    17f2:	443d      	add	r5, r7
    17f4:	60a5      	str	r5, [r4, #8]

        //
        // Report a success.
        //
        bSuccess = true;
    17f6:	2401      	movs	r4, #1
        // failure.
        //
        bSuccess = false;
    }

    am_hal_interrupt_master_set(ui32Primask);
    17f8:	f7fe ffe4 	bl	7c4 <am_hal_interrupt_master_set>

    return bSuccess;
}
    17fc:	4620      	mov	r0, r4
    17fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        bSuccess = false;
    1800:	2400      	movs	r4, #0
    am_hal_interrupt_master_set(ui32Primask);
    1802:	f7fe ffdf 	bl	7c4 <am_hal_interrupt_master_set>
}
    1806:	4620      	mov	r0, r4
    1808:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    180a:	bf00      	nop

0000180c <am_hal_rtc_osc_select>:
    // Set XT if flag is set.
    // Otherwise configure for LFRC.
    //
    if (ui32OSC)
    {
        AM_REG(CLKGEN, OCTRL) |= AM_REG_CLKGEN_OCTRL_OSEL_M;
    180c:	4a05      	ldr	r2, [pc, #20]	; (1824 <am_hal_rtc_osc_select+0x18>)
    180e:	6813      	ldr	r3, [r2, #0]
    if (ui32OSC)
    1810:	b918      	cbnz	r0, 181a <am_hal_rtc_osc_select+0xe>
    }
    else
    {
        AM_REG(CLKGEN, OCTRL) &= ~AM_REG_CLKGEN_OCTRL_OSEL_M;
    1812:	f023 0080 	bic.w	r0, r3, #128	; 0x80
    1816:	6010      	str	r0, [r2, #0]
    1818:	4770      	bx	lr
        AM_REG(CLKGEN, OCTRL) |= AM_REG_CLKGEN_OCTRL_OSEL_M;
    181a:	f043 0180 	orr.w	r1, r3, #128	; 0x80
    181e:	6011      	str	r1, [r2, #0]
    1820:	4770      	bx	lr
    1822:	bf00      	nop
    1824:	4000400c 	.word	0x4000400c

00001828 <am_hal_rtc_osc_disable>:
am_hal_rtc_osc_disable(void)
{
    //
    // Stop the RTC Oscillator.
    //
    AM_BFW(RTC, RTCCTL, RSTOP, 1);
    1828:	4a02      	ldr	r2, [pc, #8]	; (1834 <am_hal_rtc_osc_disable+0xc>)
    182a:	6813      	ldr	r3, [r2, #0]
    182c:	f043 0010 	orr.w	r0, r3, #16
    1830:	6010      	str	r0, [r2, #0]
    1832:	4770      	bx	lr
    1834:	40004050 	.word	0x40004050

00001838 <am_hal_sysctrl_sleep>:
        (AM_BFM(MCUCTRL, TPIUCTRL, ENABLE) == AM_REG_MCUCTRL_TPIUCTRL_ENABLE_DIS))
    {
        //
        // Prepare the core for deepsleep (write 1 to the DEEPSLEEP bit).
        //
        AM_BFW(SYSCTRL, SCR, SLEEPDEEP, 1);
    1838:	4a08      	ldr	r2, [pc, #32]	; (185c <am_hal_sysctrl_sleep+0x24>)
    if ((bSleepDeep == AM_HAL_SYSCTRL_SLEEP_DEEP) &&
    183a:	b118      	cbz	r0, 1844 <am_hal_sysctrl_sleep+0xc>
        (AM_BFM(MCUCTRL, TPIUCTRL, ENABLE) == AM_REG_MCUCTRL_TPIUCTRL_ENABLE_DIS))
    183c:	4b08      	ldr	r3, [pc, #32]	; (1860 <am_hal_sysctrl_sleep+0x28>)
    183e:	6818      	ldr	r0, [r3, #0]
    if ((bSleepDeep == AM_HAL_SYSCTRL_SLEEP_DEEP) &&
    1840:	07c3      	lsls	r3, r0, #31
    1842:	d505      	bpl.n	1850 <am_hal_sysctrl_sleep+0x18>
    }
    else
    {
        AM_BFW(SYSCTRL, SCR, SLEEPDEEP, 0);
    1844:	6811      	ldr	r1, [r2, #0]
    1846:	f021 0304 	bic.w	r3, r1, #4
    184a:	6013      	str	r3, [r2, #0]
    }

    //
    // Go to sleep.
    //
    AM_ASM_WFI;
    184c:	bf30      	wfi
    184e:	4770      	bx	lr
        AM_BFW(SYSCTRL, SCR, SLEEPDEEP, 1);
    1850:	6810      	ldr	r0, [r2, #0]
    1852:	f040 0104 	orr.w	r1, r0, #4
    1856:	6011      	str	r1, [r2, #0]
    AM_ASM_WFI;
    1858:	bf30      	wfi
    185a:	4770      	bx	lr
    185c:	e000ed10 	.word	0xe000ed10
    1860:	40020250 	.word	0x40020250

00001864 <am_hal_vcomp_disable>:
//
//*****************************************************************************
void
am_hal_vcomp_disable(void)
{
    AM_REG(VCOMP, PWDKEY) = AM_REG_VCOMP_PWDKEY_KEYVAL;
    1864:	4b01      	ldr	r3, [pc, #4]	; (186c <am_hal_vcomp_disable+0x8>)
    1866:	2237      	movs	r2, #55	; 0x37
    1868:	601a      	str	r2, [r3, #0]
    186a:	4770      	bx	lr
    186c:	4000c008 	.word	0x4000c008

00001870 <am_hal_debug_error>:
__weak void
#else
void __attribute__((weak))
#endif
am_hal_debug_error(const char *pcFile, uint32_t ui32Line, const char *pcMessage)
{
    1870:	e7fe      	b.n	1870 <am_hal_debug_error>
    1872:	bf00      	nop

00001874 <am_hal_i2c_bit_bang_receive>:
//*****************************************************************************
am_hal_i2c_bit_bang_enum_e
am_hal_i2c_bit_bang_receive(uint8_t address, uint32_t number_of_bytes,
                            uint8_t *pData, uint8_t ui8Offset,
                            bool bUseOffset, bool bNoStop)
{
    1874:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    PULL_SCL_HI();
    1878:	4c9b      	ldr	r4, [pc, #620]	; (1ae8 <am_hal_i2c_bit_bang_receive+0x274>)
{
    187a:	b083      	sub	sp, #12
    PULL_SCL_HI();
    187c:	68e7      	ldr	r7, [r4, #12]
{
    187e:	f89d 5030 	ldrb.w	r5, [sp, #48]	; 0x30
    PULL_SCL_HI();
    1882:	69a6      	ldr	r6, [r4, #24]
{
    1884:	9501      	str	r5, [sp, #4]
    while (!GET_SCL())
    1886:	6965      	ldr	r5, [r4, #20]
    PULL_SCL_HI();
    1888:	603e      	str	r6, [r7, #0]
    while (!GET_SCL())
    188a:	682d      	ldr	r5, [r5, #0]
{
    188c:	f89d a034 	ldrb.w	sl, [sp, #52]	; 0x34
    1890:	9300      	str	r3, [sp, #0]
    while (!GET_SCL())
    1892:	422e      	tst	r6, r5
{
    1894:	4607      	mov	r7, r0
    1896:	468b      	mov	fp, r1
    1898:	4690      	mov	r8, r2
    while (!GET_SCL())
    189a:	bf08      	it	eq
    189c:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    18a0:	d14c      	bne.n	193c <am_hal_i2c_bit_bang_receive+0xc8>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    18a2:	2004      	movs	r0, #4
    18a4:	f7fe fee2 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    18a8:	6962      	ldr	r2, [r4, #20]
    18aa:	69a3      	ldr	r3, [r4, #24]
    18ac:	6811      	ldr	r1, [r2, #0]
    18ae:	4219      	tst	r1, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    18b0:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    18b4:	d142      	bne.n	193c <am_hal_i2c_bit_bang_receive+0xc8>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    18b6:	f7fe fed9 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    18ba:	6966      	ldr	r6, [r4, #20]
    18bc:	69a3      	ldr	r3, [r4, #24]
    18be:	6832      	ldr	r2, [r6, #0]
    18c0:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    18c2:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    18c6:	d139      	bne.n	193c <am_hal_i2c_bit_bang_receive+0xc8>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    18c8:	f7fe fed0 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    18cc:	6961      	ldr	r1, [r4, #20]
    18ce:	69a6      	ldr	r6, [r4, #24]
    18d0:	680b      	ldr	r3, [r1, #0]
    18d2:	4233      	tst	r3, r6
        WAIT_FOR_QUARTER_I2C_CLOCK();
    18d4:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    18d8:	d130      	bne.n	193c <am_hal_i2c_bit_bang_receive+0xc8>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    18da:	f7fe fec7 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    18de:	6962      	ldr	r2, [r4, #20]
    18e0:	69a1      	ldr	r1, [r4, #24]
    18e2:	6816      	ldr	r6, [r2, #0]
    18e4:	420e      	tst	r6, r1
        WAIT_FOR_QUARTER_I2C_CLOCK();
    18e6:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    18ea:	d127      	bne.n	193c <am_hal_i2c_bit_bang_receive+0xc8>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    18ec:	f7fe febe 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    18f0:	6962      	ldr	r2, [r4, #20]
    18f2:	69a3      	ldr	r3, [r4, #24]
    18f4:	6811      	ldr	r1, [r2, #0]
    18f6:	4219      	tst	r1, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    18f8:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    18fc:	d11e      	bne.n	193c <am_hal_i2c_bit_bang_receive+0xc8>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    18fe:	f7fe feb5 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1902:	6966      	ldr	r6, [r4, #20]
    1904:	69a3      	ldr	r3, [r4, #24]
    1906:	6832      	ldr	r2, [r6, #0]
    1908:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    190a:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    190e:	d115      	bne.n	193c <am_hal_i2c_bit_bang_receive+0xc8>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1910:	f7fe feac 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1914:	6961      	ldr	r1, [r4, #20]
    1916:	69a6      	ldr	r6, [r4, #24]
    1918:	680b      	ldr	r3, [r1, #0]
    191a:	4233      	tst	r3, r6
        WAIT_FOR_QUARTER_I2C_CLOCK();
    191c:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1920:	d10c      	bne.n	193c <am_hal_i2c_bit_bang_receive+0xc8>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1922:	f7fe fea3 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1926:	6960      	ldr	r0, [r4, #20]
    1928:	69a1      	ldr	r1, [r4, #24]
    192a:	6802      	ldr	r2, [r0, #0]
    192c:	420a      	tst	r2, r1
    192e:	d105      	bne.n	193c <am_hal_i2c_bit_bang_receive+0xc8>
        if (--maxLoop == 0)
    1930:	3d08      	subs	r5, #8
    1932:	d1b6      	bne.n	18a2 <am_hal_i2c_bit_bang_receive+0x2e>
    status = i2c_send_byte(address);
    if ( status != AM_HAL_I2C_BIT_BANG_SUCCESS )
    {
        if ( status == AM_HAL_I2C_BIT_BANG_DATA_NAKED)
        {
            return AM_HAL_I2C_BIT_BANG_ADDRESS_NAKED;
    1934:	2003      	movs	r0, #3

    //
    // message successfully received (how could we fail???)
    //
    return AM_HAL_I2C_BIT_BANG_SUCCESS;
}
    1936:	b003      	add	sp, #12
    1938:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    WRITE_SDA_LO();
    193c:	6a26      	ldr	r6, [r4, #32]
    193e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    1940:	6033      	str	r3, [r6, #0]
    WAIT_I2C_CLOCK_HI_PERIOD();
    1942:	2005      	movs	r0, #5
    1944:	f7fe fe92 	bl	66c <am_hal_flash_delay>
    for (i = 0; i < 8; i++)
    1948:	2600      	movs	r6, #0
        if ( one_byte & (0x80 >> i) )
    194a:	f04f 0980 	mov.w	r9, #128	; 0x80
    194e:	fa49 f306 	asr.w	r3, r9, r6
    1952:	423b      	tst	r3, r7
        WRITE_SCL_LO();
    1954:	6920      	ldr	r0, [r4, #16]
            PULL_SDA_HI();
    1956:	bf14      	ite	ne
    1958:	69e3      	ldrne	r3, [r4, #28]
            WRITE_SDA_LO();
    195a:	6a23      	ldreq	r3, [r4, #32]
        WRITE_SCL_LO();
    195c:	69a1      	ldr	r1, [r4, #24]
            WRITE_SDA_LO();
    195e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
        WRITE_SCL_LO();
    1960:	6001      	str	r1, [r0, #0]
            WRITE_SDA_LO();
    1962:	601a      	str	r2, [r3, #0]
        WAIT_I2C_CLOCK_LOW_PERIOD();
    1964:	2007      	movs	r0, #7
    1966:	f7fe fe81 	bl	66c <am_hal_flash_delay>
    PULL_SCL_HI();
    196a:	68e0      	ldr	r0, [r4, #12]
    196c:	69a1      	ldr	r1, [r4, #24]
    while (!GET_SCL())
    196e:	6963      	ldr	r3, [r4, #20]
    PULL_SCL_HI();
    1970:	6001      	str	r1, [r0, #0]
    while (!GET_SCL())
    1972:	681a      	ldr	r2, [r3, #0]
    1974:	4211      	tst	r1, r2
    1976:	bf08      	it	eq
    1978:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    197c:	d149      	bne.n	1a12 <am_hal_i2c_bit_bang_receive+0x19e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    197e:	2004      	movs	r0, #4
    1980:	f7fe fe74 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1984:	6961      	ldr	r1, [r4, #20]
    1986:	69a3      	ldr	r3, [r4, #24]
    1988:	680a      	ldr	r2, [r1, #0]
    198a:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    198c:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1990:	d13f      	bne.n	1a12 <am_hal_i2c_bit_bang_receive+0x19e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1992:	f7fe fe6b 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1996:	6961      	ldr	r1, [r4, #20]
    1998:	69a3      	ldr	r3, [r4, #24]
    199a:	680a      	ldr	r2, [r1, #0]
    199c:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    199e:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    19a2:	d136      	bne.n	1a12 <am_hal_i2c_bit_bang_receive+0x19e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    19a4:	f7fe fe62 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    19a8:	6961      	ldr	r1, [r4, #20]
    19aa:	69a3      	ldr	r3, [r4, #24]
    19ac:	680a      	ldr	r2, [r1, #0]
    19ae:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    19b0:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    19b4:	d12d      	bne.n	1a12 <am_hal_i2c_bit_bang_receive+0x19e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    19b6:	f7fe fe59 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    19ba:	6961      	ldr	r1, [r4, #20]
    19bc:	69a3      	ldr	r3, [r4, #24]
    19be:	680a      	ldr	r2, [r1, #0]
    19c0:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    19c2:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    19c6:	d124      	bne.n	1a12 <am_hal_i2c_bit_bang_receive+0x19e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    19c8:	f7fe fe50 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    19cc:	6961      	ldr	r1, [r4, #20]
    19ce:	69a3      	ldr	r3, [r4, #24]
    19d0:	680a      	ldr	r2, [r1, #0]
    19d2:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    19d4:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    19d8:	d11b      	bne.n	1a12 <am_hal_i2c_bit_bang_receive+0x19e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    19da:	f7fe fe47 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    19de:	6961      	ldr	r1, [r4, #20]
    19e0:	69a3      	ldr	r3, [r4, #24]
    19e2:	680a      	ldr	r2, [r1, #0]
    19e4:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    19e6:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    19ea:	d112      	bne.n	1a12 <am_hal_i2c_bit_bang_receive+0x19e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    19ec:	f7fe fe3e 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    19f0:	6961      	ldr	r1, [r4, #20]
    19f2:	69a3      	ldr	r3, [r4, #24]
    19f4:	680a      	ldr	r2, [r1, #0]
    19f6:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    19f8:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    19fc:	d109      	bne.n	1a12 <am_hal_i2c_bit_bang_receive+0x19e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    19fe:	f7fe fe35 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1a02:	6960      	ldr	r0, [r4, #20]
    1a04:	69a1      	ldr	r1, [r4, #24]
    1a06:	6803      	ldr	r3, [r0, #0]
    1a08:	420b      	tst	r3, r1
    1a0a:	d102      	bne.n	1a12 <am_hal_i2c_bit_bang_receive+0x19e>
        if (--maxLoop == 0)
    1a0c:	3d08      	subs	r5, #8
    1a0e:	d1b6      	bne.n	197e <am_hal_i2c_bit_bang_receive+0x10a>
    1a10:	e790      	b.n	1934 <am_hal_i2c_bit_bang_receive+0xc0>
    for (i = 0; i < 8; i++)
    1a12:	3601      	adds	r6, #1
        WAIT_I2C_CLOCK_HI_PERIOD();
    1a14:	2005      	movs	r0, #5
    1a16:	f7fe fe29 	bl	66c <am_hal_flash_delay>
    for (i = 0; i < 8; i++)
    1a1a:	2e08      	cmp	r6, #8
    1a1c:	d197      	bne.n	194e <am_hal_i2c_bit_bang_receive+0xda>
    WRITE_SCL_LO();
    1a1e:	6927      	ldr	r7, [r4, #16]
    1a20:	69a2      	ldr	r2, [r4, #24]
    1a22:	603a      	str	r2, [r7, #0]
    WAIT_I2C_CLOCK_LOW_PERIOD();
    1a24:	2007      	movs	r0, #7
    1a26:	f7fe fe21 	bl	66c <am_hal_flash_delay>
    PULL_SCL_HI();
    1a2a:	68e0      	ldr	r0, [r4, #12]
    1a2c:	69a1      	ldr	r1, [r4, #24]
    while (!GET_SCL())
    1a2e:	6963      	ldr	r3, [r4, #20]
    PULL_SCL_HI();
    1a30:	6001      	str	r1, [r0, #0]
    while (!GET_SCL())
    1a32:	681f      	ldr	r7, [r3, #0]
    1a34:	4239      	tst	r1, r7
    1a36:	bf08      	it	eq
    1a38:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    1a3c:	d149      	bne.n	1ad2 <am_hal_i2c_bit_bang_receive+0x25e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1a3e:	2004      	movs	r0, #4
    1a40:	f7fe fe14 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1a44:	6962      	ldr	r2, [r4, #20]
    1a46:	69a1      	ldr	r1, [r4, #24]
    1a48:	6813      	ldr	r3, [r2, #0]
    1a4a:	420b      	tst	r3, r1
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1a4c:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1a50:	d13f      	bne.n	1ad2 <am_hal_i2c_bit_bang_receive+0x25e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1a52:	f7fe fe0b 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1a56:	6967      	ldr	r7, [r4, #20]
    1a58:	69a1      	ldr	r1, [r4, #24]
    1a5a:	683a      	ldr	r2, [r7, #0]
    1a5c:	420a      	tst	r2, r1
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1a5e:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1a62:	d136      	bne.n	1ad2 <am_hal_i2c_bit_bang_receive+0x25e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1a64:	f7fe fe02 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1a68:	6967      	ldr	r7, [r4, #20]
    1a6a:	69a3      	ldr	r3, [r4, #24]
    1a6c:	6839      	ldr	r1, [r7, #0]
    1a6e:	4219      	tst	r1, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1a70:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1a74:	d12d      	bne.n	1ad2 <am_hal_i2c_bit_bang_receive+0x25e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1a76:	f7fe fdf9 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1a7a:	6962      	ldr	r2, [r4, #20]
    1a7c:	69a7      	ldr	r7, [r4, #24]
    1a7e:	6813      	ldr	r3, [r2, #0]
    1a80:	423b      	tst	r3, r7
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1a82:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1a86:	d124      	bne.n	1ad2 <am_hal_i2c_bit_bang_receive+0x25e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1a88:	f7fe fdf0 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1a8c:	6961      	ldr	r1, [r4, #20]
    1a8e:	69a7      	ldr	r7, [r4, #24]
    1a90:	680a      	ldr	r2, [r1, #0]
    1a92:	423a      	tst	r2, r7
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1a94:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1a98:	d11b      	bne.n	1ad2 <am_hal_i2c_bit_bang_receive+0x25e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1a9a:	f7fe fde7 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1a9e:	6961      	ldr	r1, [r4, #20]
    1aa0:	69a3      	ldr	r3, [r4, #24]
    1aa2:	680f      	ldr	r7, [r1, #0]
    1aa4:	421f      	tst	r7, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1aa6:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1aaa:	d112      	bne.n	1ad2 <am_hal_i2c_bit_bang_receive+0x25e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1aac:	f7fe fdde 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1ab0:	6962      	ldr	r2, [r4, #20]
    1ab2:	69a1      	ldr	r1, [r4, #24]
    1ab4:	6813      	ldr	r3, [r2, #0]
    1ab6:	420b      	tst	r3, r1
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1ab8:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1abc:	d109      	bne.n	1ad2 <am_hal_i2c_bit_bang_receive+0x25e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1abe:	f7fe fdd5 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1ac2:	6960      	ldr	r0, [r4, #20]
    1ac4:	69a7      	ldr	r7, [r4, #24]
    1ac6:	6802      	ldr	r2, [r0, #0]
    1ac8:	423a      	tst	r2, r7
    1aca:	d102      	bne.n	1ad2 <am_hal_i2c_bit_bang_receive+0x25e>
        if (--maxLoop == 0)
    1acc:	3d08      	subs	r5, #8
    1ace:	d1b6      	bne.n	1a3e <am_hal_i2c_bit_bang_receive+0x1ca>
    1ad0:	e730      	b.n	1934 <am_hal_i2c_bit_bang_receive+0xc0>
    data_naked = GET_SDA();
    1ad2:	6a65      	ldr	r5, [r4, #36]	; 0x24
    1ad4:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    1ad6:	682d      	ldr	r5, [r5, #0]
    WAIT_I2C_CLOCK_HI_PERIOD();
    1ad8:	2005      	movs	r0, #5
    data_naked = GET_SDA();
    1ada:	400d      	ands	r5, r1
    WAIT_I2C_CLOCK_HI_PERIOD();
    1adc:	f7fe fdc6 	bl	66c <am_hal_flash_delay>
    if ( data_naked )
    1ae0:	b125      	cbz	r5, 1aec <am_hal_i2c_bit_bang_receive+0x278>
            return AM_HAL_I2C_BIT_BANG_ADDRESS_NAKED;
    1ae2:	2001      	movs	r0, #1
    1ae4:	e727      	b.n	1936 <am_hal_i2c_bit_bang_receive+0xc2>
    1ae6:	bf00      	nop
    1ae8:	10001018 	.word	0x10001018
    if ( bUseOffset )
    1aec:	9b01      	ldr	r3, [sp, #4]
    1aee:	2b00      	cmp	r3, #0
    1af0:	f040 81b4 	bne.w	1e5c <am_hal_i2c_bit_bang_receive+0x5e8>
    for (ui32I = 0; ui32I < number_of_bytes - 1; ui32I++)
    1af4:	f1bb 0b01 	subs.w	fp, fp, #1
    1af8:	f000 80d8 	beq.w	1cac <am_hal_i2c_bit_bang_receive+0x438>
    1afc:	46c1      	mov	r9, r8
    1afe:	44c3      	add	fp, r8
    while (!GET_SCL())
    1b00:	2700      	movs	r7, #0
    1b02:	463e      	mov	r6, r7
            data_byte |=  (0x80 >> i);
    1b04:	f04f 0880 	mov.w	r8, #128	; 0x80
        WRITE_SCL_LO();
    1b08:	6921      	ldr	r1, [r4, #16]
        PULL_SDA_HI();
    1b0a:	69e3      	ldr	r3, [r4, #28]
        WRITE_SCL_LO();
    1b0c:	69a0      	ldr	r0, [r4, #24]
        PULL_SDA_HI();
    1b0e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
        WRITE_SCL_LO();
    1b10:	6008      	str	r0, [r1, #0]
        PULL_SDA_HI();
    1b12:	601a      	str	r2, [r3, #0]
        WAIT_I2C_CLOCK_LOW_PERIOD();
    1b14:	2007      	movs	r0, #7
    1b16:	f7fe fda9 	bl	66c <am_hal_flash_delay>
    PULL_SCL_HI();
    1b1a:	68e1      	ldr	r1, [r4, #12]
    1b1c:	69a3      	ldr	r3, [r4, #24]
    while (!GET_SCL())
    1b1e:	6960      	ldr	r0, [r4, #20]
    PULL_SCL_HI();
    1b20:	600b      	str	r3, [r1, #0]
    while (!GET_SCL())
    1b22:	6802      	ldr	r2, [r0, #0]
    1b24:	4213      	tst	r3, r2
    1b26:	bf08      	it	eq
    1b28:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    1b2c:	d149      	bne.n	1bc2 <am_hal_i2c_bit_bang_receive+0x34e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1b2e:	2004      	movs	r0, #4
    1b30:	f7fe fd9c 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1b34:	6961      	ldr	r1, [r4, #20]
    1b36:	69a3      	ldr	r3, [r4, #24]
    1b38:	680a      	ldr	r2, [r1, #0]
    1b3a:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1b3c:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1b40:	d13f      	bne.n	1bc2 <am_hal_i2c_bit_bang_receive+0x34e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1b42:	f7fe fd93 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1b46:	6961      	ldr	r1, [r4, #20]
    1b48:	69a3      	ldr	r3, [r4, #24]
    1b4a:	680a      	ldr	r2, [r1, #0]
    1b4c:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1b4e:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1b52:	d136      	bne.n	1bc2 <am_hal_i2c_bit_bang_receive+0x34e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1b54:	f7fe fd8a 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1b58:	6961      	ldr	r1, [r4, #20]
    1b5a:	69a3      	ldr	r3, [r4, #24]
    1b5c:	680a      	ldr	r2, [r1, #0]
    1b5e:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1b60:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1b64:	d12d      	bne.n	1bc2 <am_hal_i2c_bit_bang_receive+0x34e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1b66:	f7fe fd81 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1b6a:	6961      	ldr	r1, [r4, #20]
    1b6c:	69a3      	ldr	r3, [r4, #24]
    1b6e:	680a      	ldr	r2, [r1, #0]
    1b70:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1b72:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1b76:	d124      	bne.n	1bc2 <am_hal_i2c_bit_bang_receive+0x34e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1b78:	f7fe fd78 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1b7c:	6961      	ldr	r1, [r4, #20]
    1b7e:	69a3      	ldr	r3, [r4, #24]
    1b80:	680a      	ldr	r2, [r1, #0]
    1b82:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1b84:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1b88:	d11b      	bne.n	1bc2 <am_hal_i2c_bit_bang_receive+0x34e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1b8a:	f7fe fd6f 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1b8e:	6961      	ldr	r1, [r4, #20]
    1b90:	69a3      	ldr	r3, [r4, #24]
    1b92:	680a      	ldr	r2, [r1, #0]
    1b94:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1b96:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1b9a:	d112      	bne.n	1bc2 <am_hal_i2c_bit_bang_receive+0x34e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1b9c:	f7fe fd66 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1ba0:	6961      	ldr	r1, [r4, #20]
    1ba2:	69a3      	ldr	r3, [r4, #24]
    1ba4:	680a      	ldr	r2, [r1, #0]
    1ba6:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1ba8:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1bac:	d109      	bne.n	1bc2 <am_hal_i2c_bit_bang_receive+0x34e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1bae:	f7fe fd5d 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1bb2:	6960      	ldr	r0, [r4, #20]
    1bb4:	69a1      	ldr	r1, [r4, #24]
    1bb6:	6803      	ldr	r3, [r0, #0]
    1bb8:	420b      	tst	r3, r1
    1bba:	d102      	bne.n	1bc2 <am_hal_i2c_bit_bang_receive+0x34e>
        if (--maxLoop == 0)
    1bbc:	3d08      	subs	r5, #8
    1bbe:	d1b6      	bne.n	1b2e <am_hal_i2c_bit_bang_receive+0x2ba>
    1bc0:	e6b8      	b.n	1934 <am_hal_i2c_bit_bang_receive+0xc0>
        if ( GET_SDA() )
    1bc2:	6a62      	ldr	r2, [r4, #36]	; 0x24
    1bc4:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    1bc6:	6811      	ldr	r1, [r2, #0]
    1bc8:	4201      	tst	r1, r0
    1bca:	d003      	beq.n	1bd4 <am_hal_i2c_bit_bang_receive+0x360>
            data_byte |=  (0x80 >> i);
    1bcc:	fa48 f306 	asr.w	r3, r8, r6
    1bd0:	431f      	orrs	r7, r3
    1bd2:	b2ff      	uxtb	r7, r7
    for (i = 0; i < 8; i++)
    1bd4:	3601      	adds	r6, #1
        WAIT_I2C_CLOCK_HI_PERIOD();
    1bd6:	2005      	movs	r0, #5
    1bd8:	f7fe fd48 	bl	66c <am_hal_flash_delay>
    for (i = 0; i < 8; i++)
    1bdc:	2e08      	cmp	r6, #8
    1bde:	d193      	bne.n	1b08 <am_hal_i2c_bit_bang_receive+0x294>
    WRITE_SCL_LO();
    1be0:	6921      	ldr	r1, [r4, #16]
        WRITE_SDA_LO();
    1be2:	6a26      	ldr	r6, [r4, #32]
    WRITE_SCL_LO();
    1be4:	69a0      	ldr	r0, [r4, #24]
        WRITE_SDA_LO();
    1be6:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    *pRxByte = data_byte;
    1be8:	f809 7b01 	strb.w	r7, [r9], #1
    WRITE_SCL_LO();
    1bec:	6008      	str	r0, [r1, #0]
        WRITE_SDA_LO();
    1bee:	6032      	str	r2, [r6, #0]
    WAIT_I2C_CLOCK_LOW_PERIOD();
    1bf0:	2007      	movs	r0, #7
    1bf2:	f7fe fd3b 	bl	66c <am_hal_flash_delay>
    PULL_SCL_HI();
    1bf6:	68e7      	ldr	r7, [r4, #12]
    1bf8:	69a3      	ldr	r3, [r4, #24]
    while (!GET_SCL())
    1bfa:	6961      	ldr	r1, [r4, #20]
    PULL_SCL_HI();
    1bfc:	603b      	str	r3, [r7, #0]
    while (!GET_SCL())
    1bfe:	680e      	ldr	r6, [r1, #0]
    1c00:	4233      	tst	r3, r6
    1c02:	bf08      	it	eq
    1c04:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    1c08:	d149      	bne.n	1c9e <am_hal_i2c_bit_bang_receive+0x42a>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1c0a:	2004      	movs	r0, #4
    1c0c:	f7fe fd2e 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1c10:	6962      	ldr	r2, [r4, #20]
    1c12:	69a7      	ldr	r7, [r4, #24]
    1c14:	6813      	ldr	r3, [r2, #0]
    1c16:	423b      	tst	r3, r7
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1c18:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1c1c:	d13f      	bne.n	1c9e <am_hal_i2c_bit_bang_receive+0x42a>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1c1e:	f7fe fd25 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1c22:	6961      	ldr	r1, [r4, #20]
    1c24:	69a6      	ldr	r6, [r4, #24]
    1c26:	680a      	ldr	r2, [r1, #0]
    1c28:	4232      	tst	r2, r6
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1c2a:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1c2e:	d136      	bne.n	1c9e <am_hal_i2c_bit_bang_receive+0x42a>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1c30:	f7fe fd1c 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1c34:	6967      	ldr	r7, [r4, #20]
    1c36:	69a3      	ldr	r3, [r4, #24]
    1c38:	6839      	ldr	r1, [r7, #0]
    1c3a:	4219      	tst	r1, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1c3c:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1c40:	d12d      	bne.n	1c9e <am_hal_i2c_bit_bang_receive+0x42a>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1c42:	f7fe fd13 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1c46:	6966      	ldr	r6, [r4, #20]
    1c48:	69a7      	ldr	r7, [r4, #24]
    1c4a:	6832      	ldr	r2, [r6, #0]
    1c4c:	423a      	tst	r2, r7
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1c4e:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1c52:	d124      	bne.n	1c9e <am_hal_i2c_bit_bang_receive+0x42a>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1c54:	f7fe fd0a 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1c58:	6961      	ldr	r1, [r4, #20]
    1c5a:	69a3      	ldr	r3, [r4, #24]
    1c5c:	680e      	ldr	r6, [r1, #0]
    1c5e:	421e      	tst	r6, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1c60:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1c64:	d11b      	bne.n	1c9e <am_hal_i2c_bit_bang_receive+0x42a>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1c66:	f7fe fd01 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1c6a:	6967      	ldr	r7, [r4, #20]
    1c6c:	69a1      	ldr	r1, [r4, #24]
    1c6e:	683a      	ldr	r2, [r7, #0]
    1c70:	420a      	tst	r2, r1
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1c72:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1c76:	d112      	bne.n	1c9e <am_hal_i2c_bit_bang_receive+0x42a>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1c78:	f7fe fcf8 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1c7c:	6966      	ldr	r6, [r4, #20]
    1c7e:	69a3      	ldr	r3, [r4, #24]
    1c80:	6837      	ldr	r7, [r6, #0]
    1c82:	421f      	tst	r7, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1c84:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1c88:	d109      	bne.n	1c9e <am_hal_i2c_bit_bang_receive+0x42a>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1c8a:	f7fe fcef 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1c8e:	6960      	ldr	r0, [r4, #20]
    1c90:	69a1      	ldr	r1, [r4, #24]
    1c92:	6802      	ldr	r2, [r0, #0]
    1c94:	420a      	tst	r2, r1
    1c96:	d102      	bne.n	1c9e <am_hal_i2c_bit_bang_receive+0x42a>
        if (--maxLoop == 0)
    1c98:	3d08      	subs	r5, #8
    1c9a:	d1b6      	bne.n	1c0a <am_hal_i2c_bit_bang_receive+0x396>
    1c9c:	e64a      	b.n	1934 <am_hal_i2c_bit_bang_receive+0xc0>
    WAIT_I2C_CLOCK_HI_PERIOD();
    1c9e:	2005      	movs	r0, #5
    1ca0:	f7fe fce4 	bl	66c <am_hal_flash_delay>
    for (ui32I = 0; ui32I < number_of_bytes - 1; ui32I++)
    1ca4:	45d9      	cmp	r9, fp
        pData++;
    1ca6:	46c8      	mov	r8, r9
    for (ui32I = 0; ui32I < number_of_bytes - 1; ui32I++)
    1ca8:	f47f af2a 	bne.w	1b00 <am_hal_i2c_bit_bang_receive+0x28c>
    while (!GET_SCL())
    1cac:	2600      	movs	r6, #0
    1cae:	4637      	mov	r7, r6
            data_byte |=  (0x80 >> i);
    1cb0:	f04f 0980 	mov.w	r9, #128	; 0x80
        WRITE_SCL_LO();
    1cb4:	6920      	ldr	r0, [r4, #16]
        PULL_SDA_HI();
    1cb6:	69e3      	ldr	r3, [r4, #28]
        WRITE_SCL_LO();
    1cb8:	69a1      	ldr	r1, [r4, #24]
        PULL_SDA_HI();
    1cba:	6aa2      	ldr	r2, [r4, #40]	; 0x28
        WRITE_SCL_LO();
    1cbc:	6001      	str	r1, [r0, #0]
        PULL_SDA_HI();
    1cbe:	601a      	str	r2, [r3, #0]
        WAIT_I2C_CLOCK_LOW_PERIOD();
    1cc0:	2007      	movs	r0, #7
    1cc2:	f7fe fcd3 	bl	66c <am_hal_flash_delay>
    PULL_SCL_HI();
    1cc6:	68e0      	ldr	r0, [r4, #12]
    1cc8:	69a3      	ldr	r3, [r4, #24]
    while (!GET_SCL())
    1cca:	6961      	ldr	r1, [r4, #20]
    PULL_SCL_HI();
    1ccc:	6003      	str	r3, [r0, #0]
    while (!GET_SCL())
    1cce:	680a      	ldr	r2, [r1, #0]
    1cd0:	4213      	tst	r3, r2
    1cd2:	bf08      	it	eq
    1cd4:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    1cd8:	d149      	bne.n	1d6e <am_hal_i2c_bit_bang_receive+0x4fa>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1cda:	2004      	movs	r0, #4
    1cdc:	f7fe fcc6 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1ce0:	6961      	ldr	r1, [r4, #20]
    1ce2:	69a3      	ldr	r3, [r4, #24]
    1ce4:	680a      	ldr	r2, [r1, #0]
    1ce6:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1ce8:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1cec:	d13f      	bne.n	1d6e <am_hal_i2c_bit_bang_receive+0x4fa>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1cee:	f7fe fcbd 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1cf2:	6961      	ldr	r1, [r4, #20]
    1cf4:	69a3      	ldr	r3, [r4, #24]
    1cf6:	680a      	ldr	r2, [r1, #0]
    1cf8:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1cfa:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1cfe:	d136      	bne.n	1d6e <am_hal_i2c_bit_bang_receive+0x4fa>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1d00:	f7fe fcb4 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1d04:	6961      	ldr	r1, [r4, #20]
    1d06:	69a3      	ldr	r3, [r4, #24]
    1d08:	680a      	ldr	r2, [r1, #0]
    1d0a:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1d0c:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1d10:	d12d      	bne.n	1d6e <am_hal_i2c_bit_bang_receive+0x4fa>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1d12:	f7fe fcab 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1d16:	6961      	ldr	r1, [r4, #20]
    1d18:	69a3      	ldr	r3, [r4, #24]
    1d1a:	680a      	ldr	r2, [r1, #0]
    1d1c:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1d1e:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1d22:	d124      	bne.n	1d6e <am_hal_i2c_bit_bang_receive+0x4fa>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1d24:	f7fe fca2 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1d28:	6961      	ldr	r1, [r4, #20]
    1d2a:	69a3      	ldr	r3, [r4, #24]
    1d2c:	680a      	ldr	r2, [r1, #0]
    1d2e:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1d30:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1d34:	d11b      	bne.n	1d6e <am_hal_i2c_bit_bang_receive+0x4fa>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1d36:	f7fe fc99 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1d3a:	6961      	ldr	r1, [r4, #20]
    1d3c:	69a3      	ldr	r3, [r4, #24]
    1d3e:	680a      	ldr	r2, [r1, #0]
    1d40:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1d42:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1d46:	d112      	bne.n	1d6e <am_hal_i2c_bit_bang_receive+0x4fa>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1d48:	f7fe fc90 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1d4c:	6961      	ldr	r1, [r4, #20]
    1d4e:	69a3      	ldr	r3, [r4, #24]
    1d50:	680a      	ldr	r2, [r1, #0]
    1d52:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1d54:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1d58:	d109      	bne.n	1d6e <am_hal_i2c_bit_bang_receive+0x4fa>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1d5a:	f7fe fc87 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1d5e:	6960      	ldr	r0, [r4, #20]
    1d60:	69a1      	ldr	r1, [r4, #24]
    1d62:	6803      	ldr	r3, [r0, #0]
    1d64:	420b      	tst	r3, r1
    1d66:	d102      	bne.n	1d6e <am_hal_i2c_bit_bang_receive+0x4fa>
        if (--maxLoop == 0)
    1d68:	3d08      	subs	r5, #8
    1d6a:	d1b6      	bne.n	1cda <am_hal_i2c_bit_bang_receive+0x466>
    1d6c:	e5e2      	b.n	1934 <am_hal_i2c_bit_bang_receive+0xc0>
        if ( GET_SDA() )
    1d6e:	6a62      	ldr	r2, [r4, #36]	; 0x24
    1d70:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    1d72:	6811      	ldr	r1, [r2, #0]
    1d74:	4201      	tst	r1, r0
    1d76:	d003      	beq.n	1d80 <am_hal_i2c_bit_bang_receive+0x50c>
            data_byte |=  (0x80 >> i);
    1d78:	fa49 f307 	asr.w	r3, r9, r7
    1d7c:	431e      	orrs	r6, r3
    1d7e:	b2f6      	uxtb	r6, r6
    for (i = 0; i < 8; i++)
    1d80:	3701      	adds	r7, #1
        WAIT_I2C_CLOCK_HI_PERIOD();
    1d82:	2005      	movs	r0, #5
    1d84:	f7fe fc72 	bl	66c <am_hal_flash_delay>
    for (i = 0; i < 8; i++)
    1d88:	2f08      	cmp	r7, #8
    1d8a:	d193      	bne.n	1cb4 <am_hal_i2c_bit_bang_receive+0x440>
    WRITE_SCL_LO();
    1d8c:	6921      	ldr	r1, [r4, #16]
        PULL_SDA_HI();
    1d8e:	69e7      	ldr	r7, [r4, #28]
    WRITE_SCL_LO();
    1d90:	69a5      	ldr	r5, [r4, #24]
        PULL_SDA_HI();
    1d92:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    *pRxByte = data_byte;
    1d94:	f888 6000 	strb.w	r6, [r8]
    WAIT_I2C_CLOCK_LOW_PERIOD();
    1d98:	2007      	movs	r0, #7
    WRITE_SCL_LO();
    1d9a:	600d      	str	r5, [r1, #0]
        PULL_SDA_HI();
    1d9c:	603a      	str	r2, [r7, #0]
    WAIT_I2C_CLOCK_LOW_PERIOD();
    1d9e:	f7fe fc65 	bl	66c <am_hal_flash_delay>
    PULL_SCL_HI();
    1da2:	68e0      	ldr	r0, [r4, #12]
    1da4:	69a3      	ldr	r3, [r4, #24]
    while (!GET_SCL())
    1da6:	6966      	ldr	r6, [r4, #20]
    PULL_SCL_HI();
    1da8:	6003      	str	r3, [r0, #0]
    while (!GET_SCL())
    1daa:	6831      	ldr	r1, [r6, #0]
    1dac:	4219      	tst	r1, r3
    1dae:	bf08      	it	eq
    1db0:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    1db4:	f040 811d 	bne.w	1ff2 <am_hal_i2c_bit_bang_receive+0x77e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1db8:	2004      	movs	r0, #4
    1dba:	f7fe fc57 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1dbe:	6967      	ldr	r7, [r4, #20]
    1dc0:	69a3      	ldr	r3, [r4, #24]
    1dc2:	683a      	ldr	r2, [r7, #0]
    1dc4:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1dc6:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1dca:	f040 8112 	bne.w	1ff2 <am_hal_i2c_bit_bang_receive+0x77e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1dce:	f7fe fc4d 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1dd2:	6966      	ldr	r6, [r4, #20]
    1dd4:	69a1      	ldr	r1, [r4, #24]
    1dd6:	6837      	ldr	r7, [r6, #0]
    1dd8:	420f      	tst	r7, r1
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1dda:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1dde:	f040 8108 	bne.w	1ff2 <am_hal_i2c_bit_bang_receive+0x77e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1de2:	f7fe fc43 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1de6:	6962      	ldr	r2, [r4, #20]
    1de8:	69a3      	ldr	r3, [r4, #24]
    1dea:	6816      	ldr	r6, [r2, #0]
    1dec:	421e      	tst	r6, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1dee:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1df2:	f040 80fe 	bne.w	1ff2 <am_hal_i2c_bit_bang_receive+0x77e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1df6:	f7fe fc39 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1dfa:	6961      	ldr	r1, [r4, #20]
    1dfc:	69a7      	ldr	r7, [r4, #24]
    1dfe:	680a      	ldr	r2, [r1, #0]
    1e00:	423a      	tst	r2, r7
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1e02:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1e06:	f040 80f4 	bne.w	1ff2 <am_hal_i2c_bit_bang_receive+0x77e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1e0a:	f7fe fc2f 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1e0e:	6966      	ldr	r6, [r4, #20]
    1e10:	69a3      	ldr	r3, [r4, #24]
    1e12:	6831      	ldr	r1, [r6, #0]
    1e14:	4219      	tst	r1, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1e16:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1e1a:	f040 80ea 	bne.w	1ff2 <am_hal_i2c_bit_bang_receive+0x77e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1e1e:	f7fe fc25 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1e22:	6967      	ldr	r7, [r4, #20]
    1e24:	69a6      	ldr	r6, [r4, #24]
    1e26:	683a      	ldr	r2, [r7, #0]
    1e28:	4232      	tst	r2, r6
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1e2a:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1e2e:	f040 80e0 	bne.w	1ff2 <am_hal_i2c_bit_bang_receive+0x77e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1e32:	f7fe fc1b 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1e36:	6961      	ldr	r1, [r4, #20]
    1e38:	69a3      	ldr	r3, [r4, #24]
    1e3a:	680f      	ldr	r7, [r1, #0]
    1e3c:	421f      	tst	r7, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1e3e:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1e42:	f040 80d6 	bne.w	1ff2 <am_hal_i2c_bit_bang_receive+0x77e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1e46:	f7fe fc11 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1e4a:	6960      	ldr	r0, [r4, #20]
    1e4c:	69a6      	ldr	r6, [r4, #24]
    1e4e:	6802      	ldr	r2, [r0, #0]
    1e50:	4232      	tst	r2, r6
    1e52:	f040 80ce 	bne.w	1ff2 <am_hal_i2c_bit_bang_receive+0x77e>
        if (--maxLoop == 0)
    1e56:	3d08      	subs	r5, #8
    1e58:	d1ae      	bne.n	1db8 <am_hal_i2c_bit_bang_receive+0x544>
    1e5a:	e56b      	b.n	1934 <am_hal_i2c_bit_bang_receive+0xc0>
        if ( one_byte & (0x80 >> i) )
    1e5c:	f04f 0980 	mov.w	r9, #128	; 0x80
    1e60:	9b00      	ldr	r3, [sp, #0]
        WRITE_SCL_LO();
    1e62:	6920      	ldr	r0, [r4, #16]
    1e64:	69a2      	ldr	r2, [r4, #24]
    1e66:	6002      	str	r2, [r0, #0]
        if ( one_byte & (0x80 >> i) )
    1e68:	fa49 f105 	asr.w	r1, r9, r5
    1e6c:	4219      	tst	r1, r3
            PULL_SDA_HI();
    1e6e:	bf14      	ite	ne
    1e70:	69e1      	ldrne	r1, [r4, #28]
            WRITE_SDA_LO();
    1e72:	6a21      	ldreq	r1, [r4, #32]
    1e74:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    1e76:	6008      	str	r0, [r1, #0]
        WAIT_I2C_CLOCK_LOW_PERIOD();
    1e78:	2007      	movs	r0, #7
    1e7a:	f7fe fbf7 	bl	66c <am_hal_flash_delay>
    PULL_SCL_HI();
    1e7e:	68e1      	ldr	r1, [r4, #12]
    1e80:	69a3      	ldr	r3, [r4, #24]
    while (!GET_SCL())
    1e82:	6962      	ldr	r2, [r4, #20]
    PULL_SCL_HI();
    1e84:	600b      	str	r3, [r1, #0]
    while (!GET_SCL())
    1e86:	6810      	ldr	r0, [r2, #0]
    1e88:	4203      	tst	r3, r0
    1e8a:	bf08      	it	eq
    1e8c:	f44f 76c8 	moveq.w	r6, #400	; 0x190
    1e90:	d149      	bne.n	1f26 <am_hal_i2c_bit_bang_receive+0x6b2>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1e92:	2004      	movs	r0, #4
    1e94:	f7fe fbea 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1e98:	6961      	ldr	r1, [r4, #20]
    1e9a:	69a3      	ldr	r3, [r4, #24]
    1e9c:	680a      	ldr	r2, [r1, #0]
    1e9e:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1ea0:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1ea4:	d13f      	bne.n	1f26 <am_hal_i2c_bit_bang_receive+0x6b2>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1ea6:	f7fe fbe1 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1eaa:	6967      	ldr	r7, [r4, #20]
    1eac:	69a1      	ldr	r1, [r4, #24]
    1eae:	683b      	ldr	r3, [r7, #0]
    1eb0:	420b      	tst	r3, r1
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1eb2:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1eb6:	d136      	bne.n	1f26 <am_hal_i2c_bit_bang_receive+0x6b2>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1eb8:	f7fe fbd8 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1ebc:	6962      	ldr	r2, [r4, #20]
    1ebe:	69a7      	ldr	r7, [r4, #24]
    1ec0:	6811      	ldr	r1, [r2, #0]
    1ec2:	4239      	tst	r1, r7
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1ec4:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1ec8:	d12d      	bne.n	1f26 <am_hal_i2c_bit_bang_receive+0x6b2>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1eca:	f7fe fbcf 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1ece:	6962      	ldr	r2, [r4, #20]
    1ed0:	69a3      	ldr	r3, [r4, #24]
    1ed2:	6817      	ldr	r7, [r2, #0]
    1ed4:	421f      	tst	r7, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1ed6:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1eda:	d124      	bne.n	1f26 <am_hal_i2c_bit_bang_receive+0x6b2>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1edc:	f7fe fbc6 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1ee0:	6961      	ldr	r1, [r4, #20]
    1ee2:	69a3      	ldr	r3, [r4, #24]
    1ee4:	680a      	ldr	r2, [r1, #0]
    1ee6:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1ee8:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1eec:	d11b      	bne.n	1f26 <am_hal_i2c_bit_bang_receive+0x6b2>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1eee:	f7fe fbbd 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1ef2:	6967      	ldr	r7, [r4, #20]
    1ef4:	69a1      	ldr	r1, [r4, #24]
    1ef6:	683b      	ldr	r3, [r7, #0]
    1ef8:	420b      	tst	r3, r1
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1efa:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1efe:	d112      	bne.n	1f26 <am_hal_i2c_bit_bang_receive+0x6b2>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1f00:	f7fe fbb4 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1f04:	6962      	ldr	r2, [r4, #20]
    1f06:	69a7      	ldr	r7, [r4, #24]
    1f08:	6811      	ldr	r1, [r2, #0]
    1f0a:	4239      	tst	r1, r7
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1f0c:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1f10:	d109      	bne.n	1f26 <am_hal_i2c_bit_bang_receive+0x6b2>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1f12:	f7fe fbab 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1f16:	6960      	ldr	r0, [r4, #20]
    1f18:	69a3      	ldr	r3, [r4, #24]
    1f1a:	6802      	ldr	r2, [r0, #0]
    1f1c:	421a      	tst	r2, r3
    1f1e:	d102      	bne.n	1f26 <am_hal_i2c_bit_bang_receive+0x6b2>
        if (--maxLoop == 0)
    1f20:	3e08      	subs	r6, #8
    1f22:	d1b6      	bne.n	1e92 <am_hal_i2c_bit_bang_receive+0x61e>
    1f24:	e506      	b.n	1934 <am_hal_i2c_bit_bang_receive+0xc0>
    for (i = 0; i < 8; i++)
    1f26:	3501      	adds	r5, #1
        WAIT_I2C_CLOCK_HI_PERIOD();
    1f28:	2005      	movs	r0, #5
    1f2a:	f7fe fb9f 	bl	66c <am_hal_flash_delay>
    for (i = 0; i < 8; i++)
    1f2e:	2d08      	cmp	r5, #8
    1f30:	d196      	bne.n	1e60 <am_hal_i2c_bit_bang_receive+0x5ec>
    WRITE_SCL_LO();
    1f32:	6926      	ldr	r6, [r4, #16]
    1f34:	69a7      	ldr	r7, [r4, #24]
    1f36:	6037      	str	r7, [r6, #0]
    WAIT_I2C_CLOCK_LOW_PERIOD();
    1f38:	2007      	movs	r0, #7
    1f3a:	f7fe fb97 	bl	66c <am_hal_flash_delay>
    PULL_SCL_HI();
    1f3e:	68e1      	ldr	r1, [r4, #12]
    1f40:	69a0      	ldr	r0, [r4, #24]
    while (!GET_SCL())
    1f42:	6963      	ldr	r3, [r4, #20]
    PULL_SCL_HI();
    1f44:	6008      	str	r0, [r1, #0]
    while (!GET_SCL())
    1f46:	681a      	ldr	r2, [r3, #0]
    1f48:	4202      	tst	r2, r0
    1f4a:	bf08      	it	eq
    1f4c:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    1f50:	f040 80b4 	bne.w	20bc <am_hal_i2c_bit_bang_receive+0x848>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1f54:	2004      	movs	r0, #4
    1f56:	f7fe fb89 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1f5a:	6966      	ldr	r6, [r4, #20]
    1f5c:	69a7      	ldr	r7, [r4, #24]
    1f5e:	6831      	ldr	r1, [r6, #0]
    1f60:	4239      	tst	r1, r7
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1f62:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1f66:	f040 80a9 	bne.w	20bc <am_hal_i2c_bit_bang_receive+0x848>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1f6a:	f7fe fb7f 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1f6e:	6962      	ldr	r2, [r4, #20]
    1f70:	69a3      	ldr	r3, [r4, #24]
    1f72:	6816      	ldr	r6, [r2, #0]
    1f74:	421e      	tst	r6, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1f76:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1f7a:	f040 809f 	bne.w	20bc <am_hal_i2c_bit_bang_receive+0x848>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1f7e:	f7fe fb75 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1f82:	6967      	ldr	r7, [r4, #20]
    1f84:	69a1      	ldr	r1, [r4, #24]
    1f86:	683a      	ldr	r2, [r7, #0]
    1f88:	420a      	tst	r2, r1
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1f8a:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1f8e:	f040 8095 	bne.w	20bc <am_hal_i2c_bit_bang_receive+0x848>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1f92:	f7fe fb6b 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1f96:	6966      	ldr	r6, [r4, #20]
    1f98:	69a3      	ldr	r3, [r4, #24]
    1f9a:	6837      	ldr	r7, [r6, #0]
    1f9c:	421f      	tst	r7, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1f9e:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1fa2:	f040 808b 	bne.w	20bc <am_hal_i2c_bit_bang_receive+0x848>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1fa6:	f7fe fb61 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1faa:	6961      	ldr	r1, [r4, #20]
    1fac:	69a6      	ldr	r6, [r4, #24]
    1fae:	680a      	ldr	r2, [r1, #0]
    1fb0:	4232      	tst	r2, r6
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1fb2:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1fb6:	f040 8081 	bne.w	20bc <am_hal_i2c_bit_bang_receive+0x848>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1fba:	f7fe fb57 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1fbe:	6967      	ldr	r7, [r4, #20]
    1fc0:	69a3      	ldr	r3, [r4, #24]
    1fc2:	6839      	ldr	r1, [r7, #0]
    1fc4:	4219      	tst	r1, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1fc6:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1fca:	d177      	bne.n	20bc <am_hal_i2c_bit_bang_receive+0x848>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1fcc:	f7fe fb4e 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1fd0:	6966      	ldr	r6, [r4, #20]
    1fd2:	69a7      	ldr	r7, [r4, #24]
    1fd4:	6832      	ldr	r2, [r6, #0]
    1fd6:	423a      	tst	r2, r7
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1fd8:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    1fdc:	d16e      	bne.n	20bc <am_hal_i2c_bit_bang_receive+0x848>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    1fde:	f7fe fb45 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    1fe2:	6960      	ldr	r0, [r4, #20]
    1fe4:	69a3      	ldr	r3, [r4, #24]
    1fe6:	6801      	ldr	r1, [r0, #0]
    1fe8:	4219      	tst	r1, r3
    1fea:	d167      	bne.n	20bc <am_hal_i2c_bit_bang_receive+0x848>
        if (--maxLoop == 0)
    1fec:	3d08      	subs	r5, #8
    1fee:	d1b1      	bne.n	1f54 <am_hal_i2c_bit_bang_receive+0x6e0>
    1ff0:	e4a0      	b.n	1934 <am_hal_i2c_bit_bang_receive+0xc0>
    WAIT_I2C_CLOCK_HI_PERIOD();
    1ff2:	2005      	movs	r0, #5
    1ff4:	f7fe fb3a 	bl	66c <am_hal_flash_delay>
    WRITE_SCL_LO();
    1ff8:	6925      	ldr	r5, [r4, #16]
    1ffa:	69a1      	ldr	r1, [r4, #24]
    1ffc:	6029      	str	r1, [r5, #0]
    WAIT_FOR_QUARTER_I2C_CLOCK();
    1ffe:	2004      	movs	r0, #4
    2000:	f7fe fb34 	bl	66c <am_hal_flash_delay>
    if (!bNoStop)
    2004:	f1ba 0f00 	cmp.w	sl, #0
    2008:	d16f      	bne.n	20ea <am_hal_i2c_bit_bang_receive+0x876>
        WRITE_SDA_LO();
    200a:	6a21      	ldr	r1, [r4, #32]
    200c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    200e:	600b      	str	r3, [r1, #0]
    WAIT_FOR_QUARTER_I2C_CLOCK();
    2010:	2004      	movs	r0, #4
    2012:	f7fe fb2b 	bl	66c <am_hal_flash_delay>
    PULL_SCL_HI();
    2016:	68e7      	ldr	r7, [r4, #12]
    2018:	69a0      	ldr	r0, [r4, #24]
    while (!GET_SCL())
    201a:	6966      	ldr	r6, [r4, #20]
    PULL_SCL_HI();
    201c:	6038      	str	r0, [r7, #0]
    while (!GET_SCL())
    201e:	6832      	ldr	r2, [r6, #0]
    2020:	4202      	tst	r2, r0
    2022:	d174      	bne.n	210e <am_hal_i2c_bit_bang_receive+0x89a>
    2024:	f44f 75c8 	mov.w	r5, #400	; 0x190
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2028:	2004      	movs	r0, #4
    202a:	f7fe fb1f 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    202e:	6961      	ldr	r1, [r4, #20]
    2030:	69a3      	ldr	r3, [r4, #24]
    2032:	680f      	ldr	r7, [r1, #0]
    2034:	421f      	tst	r7, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2036:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    203a:	d14b      	bne.n	20d4 <am_hal_i2c_bit_bang_receive+0x860>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    203c:	f7fe fb16 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2040:	6966      	ldr	r6, [r4, #20]
    2042:	69a1      	ldr	r1, [r4, #24]
    2044:	6832      	ldr	r2, [r6, #0]
    2046:	420a      	tst	r2, r1
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2048:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    204c:	d142      	bne.n	20d4 <am_hal_i2c_bit_bang_receive+0x860>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    204e:	f7fe fb0d 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2052:	6967      	ldr	r7, [r4, #20]
    2054:	69a3      	ldr	r3, [r4, #24]
    2056:	683e      	ldr	r6, [r7, #0]
    2058:	421e      	tst	r6, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    205a:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    205e:	d139      	bne.n	20d4 <am_hal_i2c_bit_bang_receive+0x860>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2060:	f7fe fb04 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2064:	6961      	ldr	r1, [r4, #20]
    2066:	69a7      	ldr	r7, [r4, #24]
    2068:	680a      	ldr	r2, [r1, #0]
    206a:	423a      	tst	r2, r7
        WAIT_FOR_QUARTER_I2C_CLOCK();
    206c:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    2070:	d130      	bne.n	20d4 <am_hal_i2c_bit_bang_receive+0x860>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2072:	f7fe fafb 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2076:	6966      	ldr	r6, [r4, #20]
    2078:	69a3      	ldr	r3, [r4, #24]
    207a:	6831      	ldr	r1, [r6, #0]
    207c:	4219      	tst	r1, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    207e:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    2082:	d127      	bne.n	20d4 <am_hal_i2c_bit_bang_receive+0x860>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2084:	f7fe faf2 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2088:	6967      	ldr	r7, [r4, #20]
    208a:	69a6      	ldr	r6, [r4, #24]
    208c:	683a      	ldr	r2, [r7, #0]
    208e:	4232      	tst	r2, r6
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2090:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    2094:	d11e      	bne.n	20d4 <am_hal_i2c_bit_bang_receive+0x860>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2096:	f7fe fae9 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    209a:	6961      	ldr	r1, [r4, #20]
    209c:	69a3      	ldr	r3, [r4, #24]
    209e:	680f      	ldr	r7, [r1, #0]
    20a0:	421f      	tst	r7, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    20a2:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    20a6:	d115      	bne.n	20d4 <am_hal_i2c_bit_bang_receive+0x860>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    20a8:	f7fe fae0 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    20ac:	6960      	ldr	r0, [r4, #20]
    20ae:	69a6      	ldr	r6, [r4, #24]
    20b0:	6802      	ldr	r2, [r0, #0]
    20b2:	4232      	tst	r2, r6
    20b4:	d10e      	bne.n	20d4 <am_hal_i2c_bit_bang_receive+0x860>
        if (--maxLoop == 0)
    20b6:	3d08      	subs	r5, #8
    20b8:	d1b6      	bne.n	2028 <am_hal_i2c_bit_bang_receive+0x7b4>
    20ba:	e43b      	b.n	1934 <am_hal_i2c_bit_bang_receive+0xc0>
    data_naked = GET_SDA();
    20bc:	6a65      	ldr	r5, [r4, #36]	; 0x24
    20be:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    20c0:	682d      	ldr	r5, [r5, #0]
    WAIT_I2C_CLOCK_HI_PERIOD();
    20c2:	2005      	movs	r0, #5
    data_naked = GET_SDA();
    20c4:	4035      	ands	r5, r6
    WAIT_I2C_CLOCK_HI_PERIOD();
    20c6:	f7fe fad1 	bl	66c <am_hal_flash_delay>
    if ( data_naked )
    20ca:	2d00      	cmp	r5, #0
    20cc:	f43f ad12 	beq.w	1af4 <am_hal_i2c_bit_bang_receive+0x280>
        return AM_HAL_I2C_BIT_BANG_DATA_NAKED;
    20d0:	2002      	movs	r0, #2
    20d2:	e430      	b.n	1936 <am_hal_i2c_bit_bang_receive+0xc2>
    WAIT_I2C_CLOCK_HI_PERIOD();
    20d4:	2005      	movs	r0, #5
    20d6:	f7fe fac9 	bl	66c <am_hal_flash_delay>
    if (!bNoStop)
    20da:	f1ba 0f00 	cmp.w	sl, #0
    20de:	d114      	bne.n	210a <am_hal_i2c_bit_bang_receive+0x896>
        PULL_SDA_HI();
    20e0:	69e5      	ldr	r5, [r4, #28]
    20e2:	6aa4      	ldr	r4, [r4, #40]	; 0x28
    20e4:	602c      	str	r4, [r5, #0]
    return AM_HAL_I2C_BIT_BANG_SUCCESS;
    20e6:	2000      	movs	r0, #0
    20e8:	e425      	b.n	1936 <am_hal_i2c_bit_bang_receive+0xc2>
        PULL_SDA_HI();
    20ea:	69e3      	ldr	r3, [r4, #28]
    20ec:	6aa7      	ldr	r7, [r4, #40]	; 0x28
    20ee:	601f      	str	r7, [r3, #0]
    WAIT_FOR_QUARTER_I2C_CLOCK();
    20f0:	2004      	movs	r0, #4
    20f2:	f7fe fabb 	bl	66c <am_hal_flash_delay>
    PULL_SCL_HI();
    20f6:	68e0      	ldr	r0, [r4, #12]
    20f8:	69a6      	ldr	r6, [r4, #24]
    while (!GET_SCL())
    20fa:	6962      	ldr	r2, [r4, #20]
    PULL_SCL_HI();
    20fc:	6006      	str	r6, [r0, #0]
    while (!GET_SCL())
    20fe:	6815      	ldr	r5, [r2, #0]
    2100:	422e      	tst	r6, r5
    2102:	d08f      	beq.n	2024 <am_hal_i2c_bit_bang_receive+0x7b0>
    WAIT_I2C_CLOCK_HI_PERIOD();
    2104:	2005      	movs	r0, #5
    2106:	f7fe fab1 	bl	66c <am_hal_flash_delay>
    return AM_HAL_I2C_BIT_BANG_SUCCESS;
    210a:	2000      	movs	r0, #0
    210c:	e413      	b.n	1936 <am_hal_i2c_bit_bang_receive+0xc2>
    WAIT_I2C_CLOCK_HI_PERIOD();
    210e:	2005      	movs	r0, #5
    2110:	f7fe faac 	bl	66c <am_hal_flash_delay>
    2114:	e7e4      	b.n	20e0 <am_hal_i2c_bit_bang_receive+0x86c>
    2116:	bf00      	nop

00002118 <am_hal_i2c_bit_bang_send>:
//*****************************************************************************
am_hal_i2c_bit_bang_enum_e
am_hal_i2c_bit_bang_send(uint8_t address, uint32_t number_of_bytes,
                         uint8_t *pData, uint8_t ui8Offset,
                         bool bUseOffset, bool bNoStop)
{
    2118:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    PULL_SCL_HI();
    211c:	4c9b      	ldr	r4, [pc, #620]	; (238c <am_hal_i2c_bit_bang_send+0x274>)
{
    211e:	b083      	sub	sp, #12
    PULL_SCL_HI();
    2120:	68e7      	ldr	r7, [r4, #12]
{
    2122:	f89d 5030 	ldrb.w	r5, [sp, #48]	; 0x30
    PULL_SCL_HI();
    2126:	69a6      	ldr	r6, [r4, #24]
{
    2128:	9501      	str	r5, [sp, #4]
    while (!GET_SCL())
    212a:	6965      	ldr	r5, [r4, #20]
    PULL_SCL_HI();
    212c:	603e      	str	r6, [r7, #0]
    while (!GET_SCL())
    212e:	682d      	ldr	r5, [r5, #0]
{
    2130:	f89d 7034 	ldrb.w	r7, [sp, #52]	; 0x34
    2134:	9700      	str	r7, [sp, #0]
    while (!GET_SCL())
    2136:	422e      	tst	r6, r5
{
    2138:	4607      	mov	r7, r0
    213a:	468a      	mov	sl, r1
    213c:	4691      	mov	r9, r2
    213e:	469b      	mov	fp, r3
    while (!GET_SCL())
    2140:	bf08      	it	eq
    2142:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    2146:	d14c      	bne.n	21e2 <am_hal_i2c_bit_bang_send+0xca>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2148:	2004      	movs	r0, #4
    214a:	f7fe fa8f 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    214e:	6962      	ldr	r2, [r4, #20]
    2150:	69a3      	ldr	r3, [r4, #24]
    2152:	6811      	ldr	r1, [r2, #0]
    2154:	4219      	tst	r1, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2156:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    215a:	d142      	bne.n	21e2 <am_hal_i2c_bit_bang_send+0xca>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    215c:	f7fe fa86 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2160:	6966      	ldr	r6, [r4, #20]
    2162:	69a3      	ldr	r3, [r4, #24]
    2164:	6832      	ldr	r2, [r6, #0]
    2166:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2168:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    216c:	d139      	bne.n	21e2 <am_hal_i2c_bit_bang_send+0xca>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    216e:	f7fe fa7d 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2172:	6961      	ldr	r1, [r4, #20]
    2174:	69a6      	ldr	r6, [r4, #24]
    2176:	680b      	ldr	r3, [r1, #0]
    2178:	4233      	tst	r3, r6
        WAIT_FOR_QUARTER_I2C_CLOCK();
    217a:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    217e:	d130      	bne.n	21e2 <am_hal_i2c_bit_bang_send+0xca>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2180:	f7fe fa74 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2184:	6962      	ldr	r2, [r4, #20]
    2186:	69a1      	ldr	r1, [r4, #24]
    2188:	6816      	ldr	r6, [r2, #0]
    218a:	420e      	tst	r6, r1
        WAIT_FOR_QUARTER_I2C_CLOCK();
    218c:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    2190:	d127      	bne.n	21e2 <am_hal_i2c_bit_bang_send+0xca>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2192:	f7fe fa6b 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2196:	6962      	ldr	r2, [r4, #20]
    2198:	69a3      	ldr	r3, [r4, #24]
    219a:	6811      	ldr	r1, [r2, #0]
    219c:	4219      	tst	r1, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    219e:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    21a2:	d11e      	bne.n	21e2 <am_hal_i2c_bit_bang_send+0xca>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    21a4:	f7fe fa62 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    21a8:	6966      	ldr	r6, [r4, #20]
    21aa:	69a3      	ldr	r3, [r4, #24]
    21ac:	6832      	ldr	r2, [r6, #0]
    21ae:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    21b0:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    21b4:	d115      	bne.n	21e2 <am_hal_i2c_bit_bang_send+0xca>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    21b6:	f7fe fa59 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    21ba:	6961      	ldr	r1, [r4, #20]
    21bc:	69a6      	ldr	r6, [r4, #24]
    21be:	680b      	ldr	r3, [r1, #0]
    21c0:	4233      	tst	r3, r6
        WAIT_FOR_QUARTER_I2C_CLOCK();
    21c2:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    21c6:	d10c      	bne.n	21e2 <am_hal_i2c_bit_bang_send+0xca>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    21c8:	f7fe fa50 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    21cc:	6960      	ldr	r0, [r4, #20]
    21ce:	69a1      	ldr	r1, [r4, #24]
    21d0:	6802      	ldr	r2, [r0, #0]
    21d2:	420a      	tst	r2, r1
    21d4:	d105      	bne.n	21e2 <am_hal_i2c_bit_bang_send+0xca>
        if (--maxLoop == 0)
    21d6:	3d08      	subs	r5, #8
    21d8:	d1b6      	bne.n	2148 <am_hal_i2c_bit_bang_send+0x30>
    }

    //
    // message successfully sent
    //
    return AM_HAL_I2C_BIT_BANG_SUCCESS;
    21da:	2003      	movs	r0, #3
}
    21dc:	b003      	add	sp, #12
    21de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    WRITE_SDA_LO();
    21e2:	6a26      	ldr	r6, [r4, #32]
    21e4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    21e6:	6033      	str	r3, [r6, #0]
    WAIT_I2C_CLOCK_HI_PERIOD();
    21e8:	2005      	movs	r0, #5
    21ea:	f7fe fa3f 	bl	66c <am_hal_flash_delay>
    for (i = 0; i < 8; i++)
    21ee:	2600      	movs	r6, #0
        if ( one_byte & (0x80 >> i) )
    21f0:	f04f 0880 	mov.w	r8, #128	; 0x80
    21f4:	fa48 f306 	asr.w	r3, r8, r6
    21f8:	423b      	tst	r3, r7
        WRITE_SCL_LO();
    21fa:	6920      	ldr	r0, [r4, #16]
            PULL_SDA_HI();
    21fc:	bf14      	ite	ne
    21fe:	69e3      	ldrne	r3, [r4, #28]
            WRITE_SDA_LO();
    2200:	6a23      	ldreq	r3, [r4, #32]
        WRITE_SCL_LO();
    2202:	69a1      	ldr	r1, [r4, #24]
            WRITE_SDA_LO();
    2204:	6aa2      	ldr	r2, [r4, #40]	; 0x28
        WRITE_SCL_LO();
    2206:	6001      	str	r1, [r0, #0]
            WRITE_SDA_LO();
    2208:	601a      	str	r2, [r3, #0]
        WAIT_I2C_CLOCK_LOW_PERIOD();
    220a:	2007      	movs	r0, #7
    220c:	f7fe fa2e 	bl	66c <am_hal_flash_delay>
    PULL_SCL_HI();
    2210:	68e0      	ldr	r0, [r4, #12]
    2212:	69a1      	ldr	r1, [r4, #24]
    while (!GET_SCL())
    2214:	6963      	ldr	r3, [r4, #20]
    PULL_SCL_HI();
    2216:	6001      	str	r1, [r0, #0]
    while (!GET_SCL())
    2218:	681a      	ldr	r2, [r3, #0]
    221a:	4211      	tst	r1, r2
    221c:	bf08      	it	eq
    221e:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    2222:	d149      	bne.n	22b8 <am_hal_i2c_bit_bang_send+0x1a0>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2224:	2004      	movs	r0, #4
    2226:	f7fe fa21 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    222a:	6961      	ldr	r1, [r4, #20]
    222c:	69a3      	ldr	r3, [r4, #24]
    222e:	680a      	ldr	r2, [r1, #0]
    2230:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2232:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    2236:	d13f      	bne.n	22b8 <am_hal_i2c_bit_bang_send+0x1a0>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2238:	f7fe fa18 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    223c:	6961      	ldr	r1, [r4, #20]
    223e:	69a3      	ldr	r3, [r4, #24]
    2240:	680a      	ldr	r2, [r1, #0]
    2242:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2244:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    2248:	d136      	bne.n	22b8 <am_hal_i2c_bit_bang_send+0x1a0>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    224a:	f7fe fa0f 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    224e:	6961      	ldr	r1, [r4, #20]
    2250:	69a3      	ldr	r3, [r4, #24]
    2252:	680a      	ldr	r2, [r1, #0]
    2254:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2256:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    225a:	d12d      	bne.n	22b8 <am_hal_i2c_bit_bang_send+0x1a0>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    225c:	f7fe fa06 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2260:	6961      	ldr	r1, [r4, #20]
    2262:	69a3      	ldr	r3, [r4, #24]
    2264:	680a      	ldr	r2, [r1, #0]
    2266:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2268:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    226c:	d124      	bne.n	22b8 <am_hal_i2c_bit_bang_send+0x1a0>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    226e:	f7fe f9fd 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2272:	6961      	ldr	r1, [r4, #20]
    2274:	69a3      	ldr	r3, [r4, #24]
    2276:	680a      	ldr	r2, [r1, #0]
    2278:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    227a:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    227e:	d11b      	bne.n	22b8 <am_hal_i2c_bit_bang_send+0x1a0>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2280:	f7fe f9f4 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2284:	6961      	ldr	r1, [r4, #20]
    2286:	69a3      	ldr	r3, [r4, #24]
    2288:	680a      	ldr	r2, [r1, #0]
    228a:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    228c:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    2290:	d112      	bne.n	22b8 <am_hal_i2c_bit_bang_send+0x1a0>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2292:	f7fe f9eb 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2296:	6961      	ldr	r1, [r4, #20]
    2298:	69a3      	ldr	r3, [r4, #24]
    229a:	680a      	ldr	r2, [r1, #0]
    229c:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    229e:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    22a2:	d109      	bne.n	22b8 <am_hal_i2c_bit_bang_send+0x1a0>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    22a4:	f7fe f9e2 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    22a8:	6960      	ldr	r0, [r4, #20]
    22aa:	69a1      	ldr	r1, [r4, #24]
    22ac:	6803      	ldr	r3, [r0, #0]
    22ae:	420b      	tst	r3, r1
    22b0:	d102      	bne.n	22b8 <am_hal_i2c_bit_bang_send+0x1a0>
        if (--maxLoop == 0)
    22b2:	3d08      	subs	r5, #8
    22b4:	d1b6      	bne.n	2224 <am_hal_i2c_bit_bang_send+0x10c>
    22b6:	e790      	b.n	21da <am_hal_i2c_bit_bang_send+0xc2>
    for (i = 0; i < 8; i++)
    22b8:	3601      	adds	r6, #1
        WAIT_I2C_CLOCK_HI_PERIOD();
    22ba:	2005      	movs	r0, #5
    22bc:	f7fe f9d6 	bl	66c <am_hal_flash_delay>
    for (i = 0; i < 8; i++)
    22c0:	2e08      	cmp	r6, #8
    22c2:	d197      	bne.n	21f4 <am_hal_i2c_bit_bang_send+0xdc>
    WRITE_SCL_LO();
    22c4:	6927      	ldr	r7, [r4, #16]
    22c6:	69a2      	ldr	r2, [r4, #24]
    22c8:	603a      	str	r2, [r7, #0]
    WAIT_I2C_CLOCK_LOW_PERIOD();
    22ca:	2007      	movs	r0, #7
    22cc:	f7fe f9ce 	bl	66c <am_hal_flash_delay>
    PULL_SCL_HI();
    22d0:	68e0      	ldr	r0, [r4, #12]
    22d2:	69a1      	ldr	r1, [r4, #24]
    while (!GET_SCL())
    22d4:	6963      	ldr	r3, [r4, #20]
    PULL_SCL_HI();
    22d6:	6001      	str	r1, [r0, #0]
    while (!GET_SCL())
    22d8:	681f      	ldr	r7, [r3, #0]
    22da:	4239      	tst	r1, r7
    22dc:	bf08      	it	eq
    22de:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    22e2:	d149      	bne.n	2378 <am_hal_i2c_bit_bang_send+0x260>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    22e4:	2004      	movs	r0, #4
    22e6:	f7fe f9c1 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    22ea:	6962      	ldr	r2, [r4, #20]
    22ec:	69a1      	ldr	r1, [r4, #24]
    22ee:	6813      	ldr	r3, [r2, #0]
    22f0:	420b      	tst	r3, r1
        WAIT_FOR_QUARTER_I2C_CLOCK();
    22f2:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    22f6:	d13f      	bne.n	2378 <am_hal_i2c_bit_bang_send+0x260>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    22f8:	f7fe f9b8 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    22fc:	6967      	ldr	r7, [r4, #20]
    22fe:	69a1      	ldr	r1, [r4, #24]
    2300:	683a      	ldr	r2, [r7, #0]
    2302:	420a      	tst	r2, r1
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2304:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    2308:	d136      	bne.n	2378 <am_hal_i2c_bit_bang_send+0x260>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    230a:	f7fe f9af 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    230e:	6967      	ldr	r7, [r4, #20]
    2310:	69a3      	ldr	r3, [r4, #24]
    2312:	6839      	ldr	r1, [r7, #0]
    2314:	4219      	tst	r1, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2316:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    231a:	d12d      	bne.n	2378 <am_hal_i2c_bit_bang_send+0x260>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    231c:	f7fe f9a6 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2320:	6962      	ldr	r2, [r4, #20]
    2322:	69a7      	ldr	r7, [r4, #24]
    2324:	6813      	ldr	r3, [r2, #0]
    2326:	423b      	tst	r3, r7
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2328:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    232c:	d124      	bne.n	2378 <am_hal_i2c_bit_bang_send+0x260>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    232e:	f7fe f99d 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2332:	6961      	ldr	r1, [r4, #20]
    2334:	69a7      	ldr	r7, [r4, #24]
    2336:	680a      	ldr	r2, [r1, #0]
    2338:	423a      	tst	r2, r7
        WAIT_FOR_QUARTER_I2C_CLOCK();
    233a:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    233e:	d11b      	bne.n	2378 <am_hal_i2c_bit_bang_send+0x260>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2340:	f7fe f994 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2344:	6961      	ldr	r1, [r4, #20]
    2346:	69a3      	ldr	r3, [r4, #24]
    2348:	680f      	ldr	r7, [r1, #0]
    234a:	421f      	tst	r7, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    234c:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    2350:	d112      	bne.n	2378 <am_hal_i2c_bit_bang_send+0x260>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2352:	f7fe f98b 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2356:	6962      	ldr	r2, [r4, #20]
    2358:	69a1      	ldr	r1, [r4, #24]
    235a:	6813      	ldr	r3, [r2, #0]
    235c:	420b      	tst	r3, r1
        WAIT_FOR_QUARTER_I2C_CLOCK();
    235e:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    2362:	d109      	bne.n	2378 <am_hal_i2c_bit_bang_send+0x260>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2364:	f7fe f982 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2368:	6960      	ldr	r0, [r4, #20]
    236a:	69a7      	ldr	r7, [r4, #24]
    236c:	6802      	ldr	r2, [r0, #0]
    236e:	423a      	tst	r2, r7
    2370:	d102      	bne.n	2378 <am_hal_i2c_bit_bang_send+0x260>
        if (--maxLoop == 0)
    2372:	3d08      	subs	r5, #8
    2374:	d1b6      	bne.n	22e4 <am_hal_i2c_bit_bang_send+0x1cc>
    2376:	e730      	b.n	21da <am_hal_i2c_bit_bang_send+0xc2>
    data_naked = GET_SDA();
    2378:	6a65      	ldr	r5, [r4, #36]	; 0x24
    237a:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    237c:	682d      	ldr	r5, [r5, #0]
    WAIT_I2C_CLOCK_HI_PERIOD();
    237e:	2005      	movs	r0, #5
    data_naked = GET_SDA();
    2380:	400d      	ands	r5, r1
    WAIT_I2C_CLOCK_HI_PERIOD();
    2382:	f7fe f973 	bl	66c <am_hal_flash_delay>
    if ( data_naked )
    2386:	b11d      	cbz	r5, 2390 <am_hal_i2c_bit_bang_send+0x278>
            return AM_HAL_I2C_BIT_BANG_ADDRESS_NAKED;
    2388:	2001      	movs	r0, #1
    238a:	e727      	b.n	21dc <am_hal_i2c_bit_bang_send+0xc4>
    238c:	10001018 	.word	0x10001018
    if ( bUseOffset )
    2390:	9b01      	ldr	r3, [sp, #4]
    2392:	2b00      	cmp	r3, #0
    2394:	f040 8164 	bne.w	2660 <am_hal_i2c_bit_bang_send+0x548>
    for (ui32I = 0; ui32I < number_of_bytes; ui32I++)
    2398:	f1ba 0f00 	cmp.w	sl, #0
    239c:	f000 80dd 	beq.w	255a <am_hal_i2c_bit_bang_send+0x442>
    23a0:	f109 3bff 	add.w	fp, r9, #4294967295
        if ( one_byte & (0x80 >> i) )
    23a4:	f04f 0880 	mov.w	r8, #128	; 0x80
    for (ui32I = 0; ui32I < number_of_bytes; ui32I++)
    23a8:	f04f 0900 	mov.w	r9, #0
    23ac:	f81b 7f01 	ldrb.w	r7, [fp, #1]!
    for (i = 0; i < 8; i++)
    23b0:	2600      	movs	r6, #0
        if ( one_byte & (0x80 >> i) )
    23b2:	fa48 f306 	asr.w	r3, r8, r6
    23b6:	423b      	tst	r3, r7
        WRITE_SCL_LO();
    23b8:	6920      	ldr	r0, [r4, #16]
            PULL_SDA_HI();
    23ba:	bf14      	ite	ne
    23bc:	69e3      	ldrne	r3, [r4, #28]
            WRITE_SDA_LO();
    23be:	6a23      	ldreq	r3, [r4, #32]
        WRITE_SCL_LO();
    23c0:	69a2      	ldr	r2, [r4, #24]
            WRITE_SDA_LO();
    23c2:	6aa1      	ldr	r1, [r4, #40]	; 0x28
        WRITE_SCL_LO();
    23c4:	6002      	str	r2, [r0, #0]
            WRITE_SDA_LO();
    23c6:	6019      	str	r1, [r3, #0]
        WAIT_I2C_CLOCK_LOW_PERIOD();
    23c8:	2007      	movs	r0, #7
    23ca:	f7fe f94f 	bl	66c <am_hal_flash_delay>
    PULL_SCL_HI();
    23ce:	68e0      	ldr	r0, [r4, #12]
    23d0:	69a3      	ldr	r3, [r4, #24]
    while (!GET_SCL())
    23d2:	6962      	ldr	r2, [r4, #20]
    PULL_SCL_HI();
    23d4:	6003      	str	r3, [r0, #0]
    while (!GET_SCL())
    23d6:	6811      	ldr	r1, [r2, #0]
    23d8:	420b      	tst	r3, r1
    23da:	bf08      	it	eq
    23dc:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    23e0:	d149      	bne.n	2476 <am_hal_i2c_bit_bang_send+0x35e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    23e2:	2004      	movs	r0, #4
    23e4:	f7fe f942 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    23e8:	6962      	ldr	r2, [r4, #20]
    23ea:	69a3      	ldr	r3, [r4, #24]
    23ec:	6811      	ldr	r1, [r2, #0]
    23ee:	4219      	tst	r1, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    23f0:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    23f4:	d13f      	bne.n	2476 <am_hal_i2c_bit_bang_send+0x35e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    23f6:	f7fe f939 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    23fa:	6962      	ldr	r2, [r4, #20]
    23fc:	69a3      	ldr	r3, [r4, #24]
    23fe:	6811      	ldr	r1, [r2, #0]
    2400:	4219      	tst	r1, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2402:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    2406:	d136      	bne.n	2476 <am_hal_i2c_bit_bang_send+0x35e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2408:	f7fe f930 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    240c:	6962      	ldr	r2, [r4, #20]
    240e:	69a3      	ldr	r3, [r4, #24]
    2410:	6811      	ldr	r1, [r2, #0]
    2412:	4219      	tst	r1, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2414:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    2418:	d12d      	bne.n	2476 <am_hal_i2c_bit_bang_send+0x35e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    241a:	f7fe f927 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    241e:	6962      	ldr	r2, [r4, #20]
    2420:	69a3      	ldr	r3, [r4, #24]
    2422:	6811      	ldr	r1, [r2, #0]
    2424:	4219      	tst	r1, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2426:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    242a:	d124      	bne.n	2476 <am_hal_i2c_bit_bang_send+0x35e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    242c:	f7fe f91e 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2430:	6962      	ldr	r2, [r4, #20]
    2432:	69a3      	ldr	r3, [r4, #24]
    2434:	6811      	ldr	r1, [r2, #0]
    2436:	4219      	tst	r1, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2438:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    243c:	d11b      	bne.n	2476 <am_hal_i2c_bit_bang_send+0x35e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    243e:	f7fe f915 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2442:	6962      	ldr	r2, [r4, #20]
    2444:	69a3      	ldr	r3, [r4, #24]
    2446:	6811      	ldr	r1, [r2, #0]
    2448:	4219      	tst	r1, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    244a:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    244e:	d112      	bne.n	2476 <am_hal_i2c_bit_bang_send+0x35e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2450:	f7fe f90c 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2454:	6962      	ldr	r2, [r4, #20]
    2456:	69a3      	ldr	r3, [r4, #24]
    2458:	6811      	ldr	r1, [r2, #0]
    245a:	4219      	tst	r1, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    245c:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    2460:	d109      	bne.n	2476 <am_hal_i2c_bit_bang_send+0x35e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2462:	f7fe f903 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2466:	6960      	ldr	r0, [r4, #20]
    2468:	69a3      	ldr	r3, [r4, #24]
    246a:	6802      	ldr	r2, [r0, #0]
    246c:	421a      	tst	r2, r3
    246e:	d102      	bne.n	2476 <am_hal_i2c_bit_bang_send+0x35e>
        if (--maxLoop == 0)
    2470:	3d08      	subs	r5, #8
    2472:	d1b6      	bne.n	23e2 <am_hal_i2c_bit_bang_send+0x2ca>
    2474:	e6b1      	b.n	21da <am_hal_i2c_bit_bang_send+0xc2>
    for (i = 0; i < 8; i++)
    2476:	3601      	adds	r6, #1
        WAIT_I2C_CLOCK_HI_PERIOD();
    2478:	2005      	movs	r0, #5
    247a:	f7fe f8f7 	bl	66c <am_hal_flash_delay>
    for (i = 0; i < 8; i++)
    247e:	2e08      	cmp	r6, #8
    2480:	d197      	bne.n	23b2 <am_hal_i2c_bit_bang_send+0x29a>
    WRITE_SCL_LO();
    2482:	6926      	ldr	r6, [r4, #16]
    2484:	69a7      	ldr	r7, [r4, #24]
    2486:	6037      	str	r7, [r6, #0]
    WAIT_I2C_CLOCK_LOW_PERIOD();
    2488:	2007      	movs	r0, #7
    248a:	f7fe f8ef 	bl	66c <am_hal_flash_delay>
    PULL_SCL_HI();
    248e:	68e1      	ldr	r1, [r4, #12]
    2490:	69a0      	ldr	r0, [r4, #24]
    while (!GET_SCL())
    2492:	6963      	ldr	r3, [r4, #20]
    PULL_SCL_HI();
    2494:	6008      	str	r0, [r1, #0]
    while (!GET_SCL())
    2496:	681a      	ldr	r2, [r3, #0]
    2498:	4210      	tst	r0, r2
    249a:	bf08      	it	eq
    249c:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    24a0:	d149      	bne.n	2536 <am_hal_i2c_bit_bang_send+0x41e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    24a2:	2004      	movs	r0, #4
    24a4:	f7fe f8e2 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    24a8:	6966      	ldr	r6, [r4, #20]
    24aa:	69a7      	ldr	r7, [r4, #24]
    24ac:	6831      	ldr	r1, [r6, #0]
    24ae:	4239      	tst	r1, r7
        WAIT_FOR_QUARTER_I2C_CLOCK();
    24b0:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    24b4:	d13f      	bne.n	2536 <am_hal_i2c_bit_bang_send+0x41e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    24b6:	f7fe f8d9 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    24ba:	6962      	ldr	r2, [r4, #20]
    24bc:	69a3      	ldr	r3, [r4, #24]
    24be:	6816      	ldr	r6, [r2, #0]
    24c0:	421e      	tst	r6, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    24c2:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    24c6:	d136      	bne.n	2536 <am_hal_i2c_bit_bang_send+0x41e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    24c8:	f7fe f8d0 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    24cc:	6967      	ldr	r7, [r4, #20]
    24ce:	69a1      	ldr	r1, [r4, #24]
    24d0:	683a      	ldr	r2, [r7, #0]
    24d2:	420a      	tst	r2, r1
        WAIT_FOR_QUARTER_I2C_CLOCK();
    24d4:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    24d8:	d12d      	bne.n	2536 <am_hal_i2c_bit_bang_send+0x41e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    24da:	f7fe f8c7 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    24de:	6966      	ldr	r6, [r4, #20]
    24e0:	69a3      	ldr	r3, [r4, #24]
    24e2:	6837      	ldr	r7, [r6, #0]
    24e4:	421f      	tst	r7, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    24e6:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    24ea:	d124      	bne.n	2536 <am_hal_i2c_bit_bang_send+0x41e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    24ec:	f7fe f8be 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    24f0:	6961      	ldr	r1, [r4, #20]
    24f2:	69a6      	ldr	r6, [r4, #24]
    24f4:	680a      	ldr	r2, [r1, #0]
    24f6:	4232      	tst	r2, r6
        WAIT_FOR_QUARTER_I2C_CLOCK();
    24f8:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    24fc:	d11b      	bne.n	2536 <am_hal_i2c_bit_bang_send+0x41e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    24fe:	f7fe f8b5 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2502:	6967      	ldr	r7, [r4, #20]
    2504:	69a3      	ldr	r3, [r4, #24]
    2506:	6839      	ldr	r1, [r7, #0]
    2508:	4219      	tst	r1, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    250a:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    250e:	d112      	bne.n	2536 <am_hal_i2c_bit_bang_send+0x41e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2510:	f7fe f8ac 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2514:	6966      	ldr	r6, [r4, #20]
    2516:	69a7      	ldr	r7, [r4, #24]
    2518:	6832      	ldr	r2, [r6, #0]
    251a:	423a      	tst	r2, r7
        WAIT_FOR_QUARTER_I2C_CLOCK();
    251c:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    2520:	d109      	bne.n	2536 <am_hal_i2c_bit_bang_send+0x41e>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2522:	f7fe f8a3 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2526:	6960      	ldr	r0, [r4, #20]
    2528:	69a3      	ldr	r3, [r4, #24]
    252a:	6801      	ldr	r1, [r0, #0]
    252c:	4219      	tst	r1, r3
    252e:	d102      	bne.n	2536 <am_hal_i2c_bit_bang_send+0x41e>
        if (--maxLoop == 0)
    2530:	3d08      	subs	r5, #8
    2532:	d1b6      	bne.n	24a2 <am_hal_i2c_bit_bang_send+0x38a>
    2534:	e651      	b.n	21da <am_hal_i2c_bit_bang_send+0xc2>
    data_naked = GET_SDA();
    2536:	6a65      	ldr	r5, [r4, #36]	; 0x24
    2538:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    253a:	682d      	ldr	r5, [r5, #0]
    WAIT_I2C_CLOCK_HI_PERIOD();
    253c:	2005      	movs	r0, #5
    data_naked = GET_SDA();
    253e:	4035      	ands	r5, r6
    WAIT_I2C_CLOCK_HI_PERIOD();
    2540:	f7fe f894 	bl	66c <am_hal_flash_delay>
    if ( data_naked )
    2544:	b125      	cbz	r5, 2550 <am_hal_i2c_bit_bang_send+0x438>
                if (ui32I != (number_of_bytes-1))
    2546:	f10a 37ff 	add.w	r7, sl, #4294967295
    254a:	454f      	cmp	r7, r9
    254c:	f040 815d 	bne.w	280a <am_hal_i2c_bit_bang_send+0x6f2>
    for (ui32I = 0; ui32I < number_of_bytes; ui32I++)
    2550:	f109 0901 	add.w	r9, r9, #1
    2554:	45ca      	cmp	sl, r9
    2556:	f47f af29 	bne.w	23ac <am_hal_i2c_bit_bang_send+0x294>
    bool data_naked = false;
    255a:	2500      	movs	r5, #0
    WRITE_SCL_LO();
    255c:	6920      	ldr	r0, [r4, #16]
    255e:	69a2      	ldr	r2, [r4, #24]
    2560:	6002      	str	r2, [r0, #0]
    WAIT_FOR_QUARTER_I2C_CLOCK();
    2562:	2004      	movs	r0, #4
    2564:	f7fe f882 	bl	66c <am_hal_flash_delay>
    if (!bNoStop)
    2568:	9b00      	ldr	r3, [sp, #0]
    256a:	2b00      	cmp	r3, #0
    256c:	d060      	beq.n	2630 <am_hal_i2c_bit_bang_send+0x518>
        PULL_SDA_HI();
    256e:	69e1      	ldr	r1, [r4, #28]
    2570:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    2572:	600e      	str	r6, [r1, #0]
    WAIT_FOR_QUARTER_I2C_CLOCK();
    2574:	2004      	movs	r0, #4
    2576:	f7fe f879 	bl	66c <am_hal_flash_delay>
    PULL_SCL_HI();
    257a:	68e7      	ldr	r7, [r4, #12]
    257c:	69a0      	ldr	r0, [r4, #24]
    while (!GET_SCL())
    257e:	6962      	ldr	r2, [r4, #20]
    PULL_SCL_HI();
    2580:	6038      	str	r0, [r7, #0]
    while (!GET_SCL())
    2582:	6813      	ldr	r3, [r2, #0]
    2584:	4218      	tst	r0, r3
    2586:	d163      	bne.n	2650 <am_hal_i2c_bit_bang_send+0x538>
    bool data_naked = false;
    2588:	f44f 76c8 	mov.w	r6, #400	; 0x190
        WAIT_FOR_QUARTER_I2C_CLOCK();
    258c:	2004      	movs	r0, #4
    258e:	f7fe f86d 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2592:	6961      	ldr	r1, [r4, #20]
    2594:	69a7      	ldr	r7, [r4, #24]
    2596:	680a      	ldr	r2, [r1, #0]
    2598:	423a      	tst	r2, r7
        WAIT_FOR_QUARTER_I2C_CLOCK();
    259a:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    259e:	f040 8124 	bne.w	27ea <am_hal_i2c_bit_bang_send+0x6d2>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    25a2:	f7fe f863 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    25a6:	6961      	ldr	r1, [r4, #20]
    25a8:	69a3      	ldr	r3, [r4, #24]
    25aa:	680f      	ldr	r7, [r1, #0]
    25ac:	421f      	tst	r7, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    25ae:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    25b2:	f040 811a 	bne.w	27ea <am_hal_i2c_bit_bang_send+0x6d2>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    25b6:	f7fe f859 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    25ba:	6962      	ldr	r2, [r4, #20]
    25bc:	69a1      	ldr	r1, [r4, #24]
    25be:	6813      	ldr	r3, [r2, #0]
    25c0:	420b      	tst	r3, r1
        WAIT_FOR_QUARTER_I2C_CLOCK();
    25c2:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    25c6:	f040 8110 	bne.w	27ea <am_hal_i2c_bit_bang_send+0x6d2>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    25ca:	f7fe f84f 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    25ce:	6967      	ldr	r7, [r4, #20]
    25d0:	69a1      	ldr	r1, [r4, #24]
    25d2:	683a      	ldr	r2, [r7, #0]
    25d4:	420a      	tst	r2, r1
        WAIT_FOR_QUARTER_I2C_CLOCK();
    25d6:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    25da:	f040 8106 	bne.w	27ea <am_hal_i2c_bit_bang_send+0x6d2>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    25de:	f7fe f845 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    25e2:	6967      	ldr	r7, [r4, #20]
    25e4:	69a3      	ldr	r3, [r4, #24]
    25e6:	6839      	ldr	r1, [r7, #0]
    25e8:	4219      	tst	r1, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    25ea:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    25ee:	f040 80fc 	bne.w	27ea <am_hal_i2c_bit_bang_send+0x6d2>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    25f2:	f7fe f83b 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    25f6:	6962      	ldr	r2, [r4, #20]
    25f8:	69a7      	ldr	r7, [r4, #24]
    25fa:	6813      	ldr	r3, [r2, #0]
    25fc:	423b      	tst	r3, r7
        WAIT_FOR_QUARTER_I2C_CLOCK();
    25fe:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    2602:	f040 80f2 	bne.w	27ea <am_hal_i2c_bit_bang_send+0x6d2>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2606:	f7fe f831 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    260a:	6961      	ldr	r1, [r4, #20]
    260c:	69a7      	ldr	r7, [r4, #24]
    260e:	680a      	ldr	r2, [r1, #0]
    2610:	423a      	tst	r2, r7
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2612:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    2616:	f040 80e8 	bne.w	27ea <am_hal_i2c_bit_bang_send+0x6d2>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    261a:	f7fe f827 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    261e:	6960      	ldr	r0, [r4, #20]
    2620:	69a3      	ldr	r3, [r4, #24]
    2622:	6801      	ldr	r1, [r0, #0]
    2624:	4219      	tst	r1, r3
    2626:	f040 80e0 	bne.w	27ea <am_hal_i2c_bit_bang_send+0x6d2>
        if (--maxLoop == 0)
    262a:	3e08      	subs	r6, #8
    262c:	d1ae      	bne.n	258c <am_hal_i2c_bit_bang_send+0x474>
    262e:	e5d4      	b.n	21da <am_hal_i2c_bit_bang_send+0xc2>
        WRITE_SDA_LO();
    2630:	6a21      	ldr	r1, [r4, #32]
    2632:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    2634:	600e      	str	r6, [r1, #0]
    WAIT_FOR_QUARTER_I2C_CLOCK();
    2636:	2004      	movs	r0, #4
    2638:	f7fe f818 	bl	66c <am_hal_flash_delay>
    PULL_SCL_HI();
    263c:	68e7      	ldr	r7, [r4, #12]
    263e:	69a0      	ldr	r0, [r4, #24]
    while (!GET_SCL())
    2640:	6962      	ldr	r2, [r4, #20]
    PULL_SCL_HI();
    2642:	6038      	str	r0, [r7, #0]
    while (!GET_SCL())
    2644:	6813      	ldr	r3, [r2, #0]
    2646:	4203      	tst	r3, r0
    2648:	d09e      	beq.n	2588 <am_hal_i2c_bit_bang_send+0x470>
        PULL_SDA_HI();
    264a:	69e7      	ldr	r7, [r4, #28]
    264c:	6aa4      	ldr	r4, [r4, #40]	; 0x28
    264e:	603c      	str	r4, [r7, #0]
    WAIT_I2C_CLOCK_HI_PERIOD();
    2650:	2005      	movs	r0, #5
    2652:	f7fe f80b 	bl	66c <am_hal_flash_delay>
    if ( data_naked )
    2656:	2d00      	cmp	r5, #0
    2658:	f000 80d9 	beq.w	280e <am_hal_i2c_bit_bang_send+0x6f6>
        return AM_HAL_I2C_BIT_BANG_DATA_NAKED;  // if it happens early
    265c:	2002      	movs	r0, #2
    265e:	e5bd      	b.n	21dc <am_hal_i2c_bit_bang_send+0xc4>
        if ( one_byte & (0x80 >> i) )
    2660:	f04f 0880 	mov.w	r8, #128	; 0x80
    2664:	fa48 f105 	asr.w	r1, r8, r5
    2668:	ea11 0f0b 	tst.w	r1, fp
        WRITE_SCL_LO();
    266c:	6920      	ldr	r0, [r4, #16]
            PULL_SDA_HI();
    266e:	bf14      	ite	ne
    2670:	69e1      	ldrne	r1, [r4, #28]
            WRITE_SDA_LO();
    2672:	6a21      	ldreq	r1, [r4, #32]
        WRITE_SCL_LO();
    2674:	69a2      	ldr	r2, [r4, #24]
            WRITE_SDA_LO();
    2676:	6aa3      	ldr	r3, [r4, #40]	; 0x28
        WRITE_SCL_LO();
    2678:	6002      	str	r2, [r0, #0]
            WRITE_SDA_LO();
    267a:	600b      	str	r3, [r1, #0]
        WAIT_I2C_CLOCK_LOW_PERIOD();
    267c:	2007      	movs	r0, #7
    267e:	f7fd fff5 	bl	66c <am_hal_flash_delay>
    PULL_SCL_HI();
    2682:	68e0      	ldr	r0, [r4, #12]
    2684:	69a1      	ldr	r1, [r4, #24]
    while (!GET_SCL())
    2686:	6962      	ldr	r2, [r4, #20]
    PULL_SCL_HI();
    2688:	6001      	str	r1, [r0, #0]
    while (!GET_SCL())
    268a:	6813      	ldr	r3, [r2, #0]
    268c:	4219      	tst	r1, r3
    268e:	bf08      	it	eq
    2690:	f44f 76c8 	moveq.w	r6, #400	; 0x190
    2694:	d149      	bne.n	272a <am_hal_i2c_bit_bang_send+0x612>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2696:	2004      	movs	r0, #4
    2698:	f7fd ffe8 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    269c:	6961      	ldr	r1, [r4, #20]
    269e:	69a3      	ldr	r3, [r4, #24]
    26a0:	680a      	ldr	r2, [r1, #0]
    26a2:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    26a4:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    26a8:	d13f      	bne.n	272a <am_hal_i2c_bit_bang_send+0x612>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    26aa:	f7fd ffdf 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    26ae:	6967      	ldr	r7, [r4, #20]
    26b0:	69a1      	ldr	r1, [r4, #24]
    26b2:	683b      	ldr	r3, [r7, #0]
    26b4:	420b      	tst	r3, r1
        WAIT_FOR_QUARTER_I2C_CLOCK();
    26b6:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    26ba:	d136      	bne.n	272a <am_hal_i2c_bit_bang_send+0x612>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    26bc:	f7fd ffd6 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    26c0:	6962      	ldr	r2, [r4, #20]
    26c2:	69a7      	ldr	r7, [r4, #24]
    26c4:	6811      	ldr	r1, [r2, #0]
    26c6:	4239      	tst	r1, r7
        WAIT_FOR_QUARTER_I2C_CLOCK();
    26c8:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    26cc:	d12d      	bne.n	272a <am_hal_i2c_bit_bang_send+0x612>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    26ce:	f7fd ffcd 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    26d2:	6962      	ldr	r2, [r4, #20]
    26d4:	69a3      	ldr	r3, [r4, #24]
    26d6:	6817      	ldr	r7, [r2, #0]
    26d8:	421f      	tst	r7, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    26da:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    26de:	d124      	bne.n	272a <am_hal_i2c_bit_bang_send+0x612>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    26e0:	f7fd ffc4 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    26e4:	6961      	ldr	r1, [r4, #20]
    26e6:	69a3      	ldr	r3, [r4, #24]
    26e8:	680a      	ldr	r2, [r1, #0]
    26ea:	421a      	tst	r2, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    26ec:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    26f0:	d11b      	bne.n	272a <am_hal_i2c_bit_bang_send+0x612>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    26f2:	f7fd ffbb 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    26f6:	6967      	ldr	r7, [r4, #20]
    26f8:	69a1      	ldr	r1, [r4, #24]
    26fa:	683b      	ldr	r3, [r7, #0]
    26fc:	420b      	tst	r3, r1
        WAIT_FOR_QUARTER_I2C_CLOCK();
    26fe:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    2702:	d112      	bne.n	272a <am_hal_i2c_bit_bang_send+0x612>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2704:	f7fd ffb2 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2708:	6962      	ldr	r2, [r4, #20]
    270a:	69a7      	ldr	r7, [r4, #24]
    270c:	6811      	ldr	r1, [r2, #0]
    270e:	4239      	tst	r1, r7
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2710:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    2714:	d109      	bne.n	272a <am_hal_i2c_bit_bang_send+0x612>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2716:	f7fd ffa9 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    271a:	6960      	ldr	r0, [r4, #20]
    271c:	69a3      	ldr	r3, [r4, #24]
    271e:	6802      	ldr	r2, [r0, #0]
    2720:	421a      	tst	r2, r3
    2722:	d102      	bne.n	272a <am_hal_i2c_bit_bang_send+0x612>
        if (--maxLoop == 0)
    2724:	3e08      	subs	r6, #8
    2726:	d1b6      	bne.n	2696 <am_hal_i2c_bit_bang_send+0x57e>
    2728:	e557      	b.n	21da <am_hal_i2c_bit_bang_send+0xc2>
    for (i = 0; i < 8; i++)
    272a:	3501      	adds	r5, #1
        WAIT_I2C_CLOCK_HI_PERIOD();
    272c:	2005      	movs	r0, #5
    272e:	f7fd ff9d 	bl	66c <am_hal_flash_delay>
    for (i = 0; i < 8; i++)
    2732:	2d08      	cmp	r5, #8
    2734:	d196      	bne.n	2664 <am_hal_i2c_bit_bang_send+0x54c>
    WRITE_SCL_LO();
    2736:	6926      	ldr	r6, [r4, #16]
    2738:	69a7      	ldr	r7, [r4, #24]
    273a:	6037      	str	r7, [r6, #0]
    WAIT_I2C_CLOCK_LOW_PERIOD();
    273c:	2007      	movs	r0, #7
    273e:	f7fd ff95 	bl	66c <am_hal_flash_delay>
    PULL_SCL_HI();
    2742:	68e1      	ldr	r1, [r4, #12]
    2744:	69a0      	ldr	r0, [r4, #24]
    while (!GET_SCL())
    2746:	6963      	ldr	r3, [r4, #20]
    PULL_SCL_HI();
    2748:	6008      	str	r0, [r1, #0]
    while (!GET_SCL())
    274a:	681a      	ldr	r2, [r3, #0]
    274c:	4210      	tst	r0, r2
    274e:	bf08      	it	eq
    2750:	f44f 75c8 	moveq.w	r5, #400	; 0x190
    2754:	d14e      	bne.n	27f4 <am_hal_i2c_bit_bang_send+0x6dc>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2756:	2004      	movs	r0, #4
    2758:	f7fd ff88 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    275c:	6966      	ldr	r6, [r4, #20]
    275e:	69a7      	ldr	r7, [r4, #24]
    2760:	6831      	ldr	r1, [r6, #0]
    2762:	4239      	tst	r1, r7
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2764:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    2768:	d144      	bne.n	27f4 <am_hal_i2c_bit_bang_send+0x6dc>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    276a:	f7fd ff7f 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    276e:	6962      	ldr	r2, [r4, #20]
    2770:	69a3      	ldr	r3, [r4, #24]
    2772:	6816      	ldr	r6, [r2, #0]
    2774:	421e      	tst	r6, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2776:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    277a:	d13b      	bne.n	27f4 <am_hal_i2c_bit_bang_send+0x6dc>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    277c:	f7fd ff76 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2780:	6967      	ldr	r7, [r4, #20]
    2782:	69a1      	ldr	r1, [r4, #24]
    2784:	683a      	ldr	r2, [r7, #0]
    2786:	420a      	tst	r2, r1
        WAIT_FOR_QUARTER_I2C_CLOCK();
    2788:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    278c:	d132      	bne.n	27f4 <am_hal_i2c_bit_bang_send+0x6dc>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    278e:	f7fd ff6d 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    2792:	6966      	ldr	r6, [r4, #20]
    2794:	69a3      	ldr	r3, [r4, #24]
    2796:	6837      	ldr	r7, [r6, #0]
    2798:	421f      	tst	r7, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    279a:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    279e:	d129      	bne.n	27f4 <am_hal_i2c_bit_bang_send+0x6dc>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    27a0:	f7fd ff64 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    27a4:	6961      	ldr	r1, [r4, #20]
    27a6:	69a6      	ldr	r6, [r4, #24]
    27a8:	680a      	ldr	r2, [r1, #0]
    27aa:	4232      	tst	r2, r6
        WAIT_FOR_QUARTER_I2C_CLOCK();
    27ac:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    27b0:	d120      	bne.n	27f4 <am_hal_i2c_bit_bang_send+0x6dc>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    27b2:	f7fd ff5b 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    27b6:	6967      	ldr	r7, [r4, #20]
    27b8:	69a3      	ldr	r3, [r4, #24]
    27ba:	6839      	ldr	r1, [r7, #0]
    27bc:	4219      	tst	r1, r3
        WAIT_FOR_QUARTER_I2C_CLOCK();
    27be:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    27c2:	d117      	bne.n	27f4 <am_hal_i2c_bit_bang_send+0x6dc>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    27c4:	f7fd ff52 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    27c8:	6966      	ldr	r6, [r4, #20]
    27ca:	69a7      	ldr	r7, [r4, #24]
    27cc:	6832      	ldr	r2, [r6, #0]
    27ce:	423a      	tst	r2, r7
        WAIT_FOR_QUARTER_I2C_CLOCK();
    27d0:	f04f 0004 	mov.w	r0, #4
    while (!GET_SCL())
    27d4:	d10e      	bne.n	27f4 <am_hal_i2c_bit_bang_send+0x6dc>
        WAIT_FOR_QUARTER_I2C_CLOCK();
    27d6:	f7fd ff49 	bl	66c <am_hal_flash_delay>
    while (!GET_SCL())
    27da:	6960      	ldr	r0, [r4, #20]
    27dc:	69a3      	ldr	r3, [r4, #24]
    27de:	6801      	ldr	r1, [r0, #0]
    27e0:	4219      	tst	r1, r3
    27e2:	d107      	bne.n	27f4 <am_hal_i2c_bit_bang_send+0x6dc>
        if (--maxLoop == 0)
    27e4:	3d08      	subs	r5, #8
    27e6:	d1b6      	bne.n	2756 <am_hal_i2c_bit_bang_send+0x63e>
    27e8:	e4f7      	b.n	21da <am_hal_i2c_bit_bang_send+0xc2>
    if (!bNoStop)
    27ea:	9e00      	ldr	r6, [sp, #0]
    27ec:	2e00      	cmp	r6, #0
    27ee:	f43f af2c 	beq.w	264a <am_hal_i2c_bit_bang_send+0x532>
    27f2:	e72d      	b.n	2650 <am_hal_i2c_bit_bang_send+0x538>
    data_naked = GET_SDA();
    27f4:	6a65      	ldr	r5, [r4, #36]	; 0x24
    27f6:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    27f8:	682d      	ldr	r5, [r5, #0]
    WAIT_I2C_CLOCK_HI_PERIOD();
    27fa:	2005      	movs	r0, #5
    data_naked = GET_SDA();
    27fc:	4035      	ands	r5, r6
    WAIT_I2C_CLOCK_HI_PERIOD();
    27fe:	f7fd ff35 	bl	66c <am_hal_flash_delay>
    if ( data_naked )
    2802:	2d00      	cmp	r5, #0
    2804:	f47f af2a 	bne.w	265c <am_hal_i2c_bit_bang_send+0x544>
    2808:	e5c6      	b.n	2398 <am_hal_i2c_bit_bang_send+0x280>
                    data_naked = true;
    280a:	2501      	movs	r5, #1
    280c:	e6a6      	b.n	255c <am_hal_i2c_bit_bang_send+0x444>
    return AM_HAL_I2C_BIT_BANG_SUCCESS;
    280e:	4628      	mov	r0, r5
    2810:	e4e4      	b.n	21dc <am_hal_i2c_bit_bang_send+0xc4>
    2812:	bf00      	nop

00002814 <g_pui8ApolloBootDemo>:
    2814:	1000 1000 94a5 0000 9511 0000 8195 0000     ................
	...
    282c:	9519 0000 0000 0000 0000 0000 0000 0000     ................
    283c:	0000 0000 9519 0000 9519 0000 0000 0000     ................
    284c:	9519 0000 9519 0000 9519 0000 9519 0000     ................
    285c:	9519 0000 9519 0000 9519 0000 9519 0000     ................
    286c:	9519 0000 9519 0000 9519 0000 9519 0000     ................
    287c:	80c5 0000 9519 0000 9519 0000 9519 0000     ................
    288c:	9519 0000 9519 0000 b580 b082 af00 2002     ............... 
    289c:	f001 fad0 2000 f64f 71ff f001 fb01 2000     ..... O..q..... 
    28ac:	4909 f001 fad7 2308 607b 687b 085b 2000     .I.....#{`{h[.. 
    28bc:	f64f 71ff 687a f001 fafd 2001 f001 fb42     O..qzh..... ..B.
    28cc:	3708 46bd bd80 bf00 1000 1000 b580 af00     .7.F............
    28dc:	2001 f001 fb37 4b05 681b 3301 4a03 6013     . ..7..K.h.3.J.`
    28ec:	2b1f d902 4b01 2200 601a bd80 1034 1000     .+...K.".`..4...
    28fc:	b580 af00 2000 f001 fa81 f001 fa15 4820     ..... ........ H
    290c:	f000 f8d6 4b1f 2273 601a 4b1f 4a1e 6812     .....Ks".`.K.J.h
    291c:	f022 0270 601a 4b1d 4a1c 6812 f422 427f     ".p..`.K.J.h"..B
    292c:	f442 5280 601a 4b17 2200 601a 4818 2105     B..R.`.K.".`.H.!
    293c:	f001 f89c f001 fb4c f001 fa0a f000 ff4e     ......L.......N.
    294c:	4814 f000 ff2d f7ff ff9f 2001 f001 faf2     .H..-...... ....
    295c:	201a f001 fb01 f001 fb27 2000 f64f 71ff     . ......'.. O..q
    296c:	f001 fa8c f001 fa20 2001 f001 fbe3 4b0a     ...... .. .....K
    297c:	681b 4807 2105 461a f001 f972 e7f4 bf00     .h.H.!.F..r.....
    298c:	95f1 0000 0060 4001 0054 4001 0028 4001     ....`..@T..@(..@
    299c:	100c 1000 9ac0 0000 1034 1000 b580 4668     ........4.....hF
    29ac:	3008 f000 f809 bd01 4618 bf00 0080 1840     .0.......F....@.
    29bc:	6800 4770 4618 bf00 b580 b096 af00 6078     .hpG.F........x`
    29cc:	f107 030c 2200 601a 3304 2200 601a 3304     .....".`.3.".`.3
    29dc:	2200 601a 3304 2200 601a 3304 2200 601a     .".`.3.".`.3.".`
    29ec:	3304 2200 601a 3304 2300 657b 6d7b 64fb     .3.".`.3.#{e{m.d
    29fc:	4b2d 681b 64fb 6cfb b2db f887 3050 6cfb     -K.h.d.l....P0.l
    2a0c:	0a1b b2db f887 3051 6cfb 0c1b b29b f8a7     ......Q0.l......
    2a1c:	3052 4b26 681b 64bb f897 3051 b2db f003     R0&K.h.d..Q0....
    2a2c:	0302 2b00 d005 2006 6879 f7ff ffbf 4603     ...+... yh.....F
    2a3c:	e001 f04f 33ff 647b 2000 6879 f7ff ffb6     ..O..3{d. yh....
    2a4c:	4603 627b 2001 6879 f7ff ffb0 4603 62bb     .F{b. yh.....F.b
    2a5c:	2002 6879 f7ff ffaa 4603 62fb 2003 6879     . yh.....F.b. yh
    2a6c:	f7ff ffa4 4603 633b 2004 6879 f7ff ff9e     .....F;c. yh....
    2a7c:	4603 637b 2005 6879 f7ff ff98 4603 63bb     .F{c. yh.....F.c
    2a8c:	2006 6879 f7ff ff92 4603 63fb 2007 6879     . yh.....F.c. yh
    2a9c:	f7ff ff8c 4603 643b f107 030c 4618 f001     .....F;d.....F..
    2aac:	faf1 2300 657b e7fe ed28 e000 ed38 e000     ...#{e..(...8...
    2abc:	b480 b083 af00 6078 4b03 687a 601a 370c     ......x`.Kzh.`.7
    2acc:	46bd f85d 7b04 4770 1140 1000 e92d 0fb0     .F]..{pG@...-...
    2adc:	b097 af00 e9c7 010c e9d7 230c 001c 2500     ...........#...%
    2aec:	ea54 0005 f000 8094 e9d7 230c 0859 ea4f     T..........#Y.O.
    2afc:	0032 e9d7 230c ea4f 0892 ea48 7883 ea4f     2....#O...H..xO.
    2b0c:	0993 eb10 0208 eb41 0309 e9c7 2314 e9d7     ......A......#..
    2b1c:	2314 ea4f 1a12 ea4a 7a03 ea4f 1b13 e9d7     .#O...J..zO.....
    2b2c:	2314 eb12 020a eb43 030b e9c7 2314 e9d7     .#....C......#..
    2b3c:	2314 0a11 62b9 6ab8 ea40 6003 62b8 0a19     .#...b.j@..`.b..
    2b4c:	62f9 e9d7 2314 e9d7 010a 1812 eb43 0301     .b...#......C...
    2b5c:	e9c7 2314 e9d7 2314 0c11 6239 6a38 ea40     ...#...#..9b8j@.
    2b6c:	4003 6238 0c19 6279 e9d7 2314 e9d7 0108     .@8b..yb...#....
    2b7c:	1812 eb43 0301 e9c7 2314 e9d7 2314 0019     ..C......#...#..
    2b8c:	61b9 2200 61fa e9d7 2314 e9d7 0106 1812     .a.".a...#......
    2b9c:	eb43 0301 e9c7 2314 e9d7 2314 08d1 60b9     C......#...#...`
    2bac:	68b8 ea40 7043 60b8 08d9 60f9 e9d7 2302     .h@.Cp.`...`...#
    2bbc:	e9c7 2314 e9d7 2314 1892 eb43 0303 0098     ...#...#..C.....
    2bcc:	6078 6879 ea41 7192 6079 0090 6038 e9d7     x`yhA..qy`..8`..
    2bdc:	0100 1812 eb43 0301 e9d7 010c 1a82 eb61     ....C.........a.
    2bec:	0303 e9c7 2312 e9d7 2312 3206 f143 0300     .....#...#.2C...
    2bfc:	0911 6139 6938 ea40 7003 6138 0919 6179     ..9a8i@..p8a..ya
    2c0c:	e9d7 2314 e9d7 0104 1812 eb43 0301 e029     ...#......C...).
    2c1c:	6b3b 647b 6c7b 085a 6c7b 089b 4413 643b     ;k{d{lZ.{l...D;d
    2c2c:	6c3b 091b 6c3a 4413 643b 6c3b 0a1b 6c3a     ;l..:l.D;d;l..:l
    2c3c:	4413 643b 6c3b 0c1b 6c3a 4413 643b 6c3b     .D;d;l..:l.D;d;l
    2c4c:	08db 643b 6c3a 4613 009b 4413 005b 6c7a     ..;d:l.F...D[.zl
    2c5c:	1ad3 63fb 6bfb 3306 091a 6c3b 4413 461a     ...c.k.3..;l.D.F
    2c6c:	f04f 0300 4610 4619 375c 46bd e8bd 0fb0     O....F.F\7.F....
    2c7c:	4770 bf00 b580 b084 af00 e9c7 0100 683a     pG............:h
    2c8c:	687b 4313 2b00 bf14 2300 2301 b2db 60fb     {h.C.+...#.#...`
    2c9c:	e008 e9d7 0100 f7ff ff19 e9c7 0100 68fb     ...............h
    2cac:	3301 60fb e9d7 2300 ea52 0103 d1f1 68fb     .3.`...#R......h
    2cbc:	4618 3710 46bd bd80 b580 b082 af00 e9c7     .F.7.F..........
    2ccc:	0100 e9d7 2300 2a00 f173 0100 da06 e9d7     .....#.*s.......
    2cdc:	2300 4252 eb63 0343 e9c7 2300 e9d7 2300     .#RBc.C....#...#
    2cec:	4610 4619 f7ff ffc6 4603 4618 3708 46bd     .F.F.....F.F.7.F
    2cfc:	bd80 bf00 b480 b085 af00 e9c7 0100 6838     ..............8h
    2d0c:	6879 4301 2900 bf14 2100 2101 b2c9 60f9     yh.C.)...!.!...`
    2d1c:	e00a e9d7 0100 0902 ea42 7201 090b e9c7     ........B..r....
    2d2c:	2300 68f9 3101 60f9 e9d7 0100 ea50 0c01     .#.h.1.`....P...
    2d3c:	d1ef 68fb 4618 3714 46bd f85d 7b04 4770     ...h.F.7.F]..{pG
    2d4c:	b480 b087 af00 6078 6039 2300 75fb 2300     ......x`9`.#.u.#
    2d5c:	613b 2300 60fb 687b 781b 2b2d d108 2301     ;a.#.`{h.x-+...#
    2d6c:	75fb 687b 3301 607b 68fb 3301 60fb e013     .u{h.3{`.h.3.`..
    2d7c:	e012 68fb 3301 60fb 693a 4613 009b 4413     ...h.3.`:i.F...D
    2d8c:	005b 613b 687b 781b 461a 693b 4413 3b30     [.;a{h.x.F;i.D0;
    2d9c:	613b 687b 3301 607b 687b 781b 2b2f d903     ;a{h.3{`{h.x/+..
    2dac:	687b 781b 2b39 d9e4 683b 2b00 d002 683b     {h.x9+..;h.+..;h
    2dbc:	68fa 601a 7dfb 2b00 d002 693b 425b e000     .h.`.}.+..;i[B..
    2dcc:	693b 4618 371c 46bd f85d 7b04 4770 bf00     ;i.F.7.F]..{pG..
    2ddc:	b580 b090 af00 e9c7 0102 607a 2300 63fb     ..........z`.#.c
    2dec:	2300 63bb e9d7 0102 f7ff fe70 e9c7 010c     .#.c......p.....
    2dfc:	68b9 6b3a 4613 009b 4413 005b 1acb 62fb     .h:k.F...D[....b
    2e0c:	6bfb 1c5a 63fa 6afa b2d2 3230 b2d2 f107     .kZ..c.j..02....
    2e1c:	0140 440b f803 2c30 e9d7 230c e9c7 2302     @..D..0,...#...#
    2e2c:	e9d7 2302 ea52 0103 d1dc 6bfb 63bb 687b     ...#R......k.c{h
    2e3c:	2b00 d011 e008 687b 1c5a 607a f107 0110     .+....{hZ.z`....
    2e4c:	6bfa 440a 7812 701a 6bfb 1e5a 63fa 2b00     .k.D.x.p.kZ..c.+
    2e5c:	d1f1 687b 2200 701a 6bbb 4618 3740 46bd     ..{h.".p.k.F@7.F
    2e6c:	bd80 bf00 b4b0 b08d af00 e9c7 0102 607a     ..............z`
    2e7c:	70fb 2300 62fb e9d7 2302 ea52 0103 d109     .p.#.b...#R.....
    2e8c:	6afb 1c5a 62fa f107 0230 4413 2230 f803     .jZ..b..0..D0"..
    2e9c:	2c20 e028 e027 7a3b f003 030f f887 302b      ,(.'.;z......+0
    2eac:	f897 302b 2b09 d90a 78fb 2b00 d001 2327     ..+0.+...x.+..'#
    2ebc:	e000 2307 f897 202b 4413 f887 302b 6afb     ...#..+ .D..+0.j
    2ecc:	1c5a 62fa f897 202b 3230 b2d2 f107 0130     Z..b..+ 02....0.
    2edc:	440b f803 2c20 e9d7 2302 0914 ea44 7403     .D.. ,...#..D..t
    2eec:	091d e9c7 4502 e9d7 2302 ea52 0103 d1d2     .....E...#R.....
    2efc:	6afb 627b 687b 2b00 d011 e008 687b 1c5a     .j{b{h.+....{hZ.
    2f0c:	607a f107 0110 6afa 440a 7812 701a 6afb     z`.....j.D.x.p.j
    2f1c:	1e5a 62fa 2b00 d1f1 687b 2200 701a 6a7b     Z..b.+..{h.".p{j
    2f2c:	4618 3734 46bd bcb0 4770 bf00 b480 b085     .F47.F..pG......
    2f3c:	af00 6078 2300 60fb 687b 2b00 d101 68fb     ..x`.#.`{h.+...h
    2f4c:	e00a e002 68fb 3301 60fb 687b 1c5a 607a     .....h.3.`{hZ.z`
    2f5c:	781b 2b00 d1f6 68fb 4618 3714 46bd f85d     .x.+...h.F.7.F].
    2f6c:	7b04 4770 b480 b087 af00 60f8 460b 607a     .{pG.......`.Fz`
    2f7c:	72fb 2300 617b 687b 2b00 dc01 697b e011     .r.#{a{h.+..{i..
    2f8c:	e00a 68fb 2b00 d004 68fb 1c5a 60fa 7afa     ...h.+...hZ..`.z
    2f9c:	701a 697b 3301 617b 687b 1e5a 607a 2b00     .p{i.3{a{hZ.z`.+
    2fac:	d1ef 697b 4618 371c 46bd f85d 7b04 4770     ..{i.F.7.F]..{pG
    2fbc:	b580 b08e af00 60f8 60b9 607a 68bb 681b     .......`.`z`.h.h
    2fcc:	62bb 6abb 2b03 dc02 f06f 0302 e0d6 edd7     .b.j.+..o.......
    2fdc:	7a03 eef5 7a40 eef1 fa10 d104 68bb 4a69     .z..@z.......hiJ
    2fec:	601a 2303 e0ca 68bb 627b 68fb 617b 697b     .`.#...h{b.h{a{i
    2ffc:	15db b2db 3b7f 623b 697b f3c3 0316 f443     .....;;b{i....C.
    300c:	0300 61fb 2300 633b 2300 637b 6a3b 2b1e     ...a.#;c.#{c;j.+
    301c:	dd02 f06f 0301 e0b1 6a3b f113 0f17 da02     ..o.....;j......
    302c:	f04f 33ff e0aa 6a3b 2b16 dd06 6a3b 3b17     O..3..;j.+..;j.;
    303c:	69fa fa02 f303 637b e01a 6a3b 2b00 db0f     .i....{c..;j.+..
    304c:	6a3b f1c3 0317 69fa fa42 f303 637b 6a3b     ;j.....iB...{c;j
    305c:	3301 69fa fa02 f303 f023 437f 633b e007     .3.i....#..C;c..
    306c:	69fb f023 427f 6a3b 43db fa42 f303 633b     .i#..B;j.CB...;c
    307c:	697b 2b00 da04 68bb 1c5a 60ba 222d 701a     {i.+...hZ..`-".p
    308c:	6b7b 2b00 d105 68bb 1c5a 60ba 2230 701a     {k.+...hZ..`0".p
    309c:	e023 6b7b 2b00 dd09 6b7b 461a ea4f 73e2     #.{k.+..{k.FO..s
    30ac:	4610 4619 68ba f7ff fe93 e012 68bb 1c5a     .F.F.h.......hZ.
    30bc:	60ba 222d 701a 6b7b 425b 461a ea4f 73e2     .`-".p{k[B.FO..s
    30cc:	4610 4619 68ba f7ff fe83 e002 68bb 3301     .F.F.h.......h.3
    30dc:	60bb 68bb 781b 2b00 d1f8 68bb 1c5a 60ba     .`.h.x.+...hZ..`
    30ec:	222e 701a 6b3b 2b00 d105 68bb 1c5a 60ba     .".p;k.+...hZ..`
    30fc:	2230 701a e03c 6a7a 68bb 1ad2 6abb 4413     0".p<.zj.h...j.D
    310c:	3b01 61bb 69ba 687b 429a bfb8 4613 61bb     .;.a.i{h.B...F.a
    311c:	2300 62fb e015 6b3a 4613 009b 4413 005b     .#.b..:k.F...D[.
    312c:	633b 68bb 1c5a 60ba 6b3a 1612 b2d2 3230     ;c.hZ..`:k....02
    313c:	b2d2 701a 6b3b f023 437f 633b 6afb 3301     ...p;k#..C;c.j.3
    314c:	62fb 6afa 69bb 429a dbe5 68bb 3b01 60bb     .b.j.i.B...h.;.`
    315c:	e002 68bb 3b01 60bb 68bb 781b 2b30 d104     ...h.;.`.h.x0+..
    316c:	68bb 3b01 781b 2b2e d1f3 68bb 3301 60bb     .h.;.x.+...h.3.`
    317c:	68bb 2200 701a 68ba 6a7b 1ad3 4618 3738     .h.".p.h{j...F87
    318c:	46bd bd80 2e30 0030 b580 b094 af00 60f8     .F..0.0........`
    319c:	60b9 607a 2300 63fb 2300 627b e2e9 2306     .`z`.#.c.#{b...#
    31ac:	633b 68bb 781b 2b25 d01f 68fb 2b00 d015     ;c.h.x%+...h.+..
    31bc:	68bb 781b 2b0a d10b 4bb2 781b 2b00 d007     .h.x.+...K.x.+..
    31cc:	68fb 1c5a 60fa 220d 701a 6bfb 3301 63fb     .hZ..`.".p.k.3.c
    31dc:	68fb 1c5a 60fa 68ba 7812 701a 68bb 3301     .hZ..`.h.x.p.h.3
    31ec:	60bb 6bfb 3301 63fb e2c3 68bb 3301 60bb     .`.k.3.c...h.3.`
    31fc:	2300 f887 302d f897 302d f887 302e 2320     .#..-0..-0...0 #
    320c:	f887 302f 68bb 781b 2b30 d105 2330 f887     ../0.h.x0+..0#..
    321c:	302f 68bb 3301 60bb f107 0310 68b8 4619     /0.h.3.`.....h.F
    322c:	f7ff fd8e 4603 63bb 693b 68ba 4413 60bb     .....F.c;i.h.D.`
    323c:	68bb 781b 2b73 d005 6bbb 2b00 da02 6bbb     .h.xs+...k.+...k
    324c:	425b 63bb 68bb 781b 2b2e d10e 68bb 3301     [B.c.h.x.+...h.3
    325c:	60bb f107 0310 68b8 4619 f7ff fd71 4603     .`.....h.F..q..F
    326c:	633b 693b 68ba 4413 60bb 68bb 781b 2b6c     ;c;i.h.D.`.h.xl+
    327c:	d10c 68bb 3301 60bb 68bb 781b 2b6c d105     ...h.3.`.h.xl+..
    328c:	68bb 3301 60bb 2301 f887 302d 68bb 781b     .h.3.`.#..-0.h.x
    329c:	3b46 2b32 f200 825d a101 f851 f023 bf00     F;2+..]...Q.#...
    32ac:	8ed1 0000 8f4b 0000 8f4b 0000 8f4b 0000     ....K...K...K...
    32bc:	8f4b 0000 8f4b 0000 8f4b 0000 8f4b 0000     K...K...K...K...
    32cc:	8f4b 0000 8f4b 0000 8f4b 0000 8f4b 0000     K...K...K...K...
    32dc:	8f4b 0000 8f4b 0000 8f4b 0000 8f4b 0000     K...K...K...K...
    32ec:	8f4b 0000 8f4b 0000 8c5f 0000 8f4b 0000     K...K..._...K...
    32fc:	8f4b 0000 8f4b 0000 8f4b 0000 8f4b 0000     K...K...K...K...
    330c:	8f4b 0000 8f4b 0000 8f4b 0000 8f4b 0000     K...K...K...K...
    331c:	8f4b 0000 8b65 0000 8d95 0000 8f4b 0000     K...e.......K...
    332c:	8ed1 0000 8f4b 0000 8f4b 0000 8d95 0000     ....K...K.......
    333c:	8f4b 0000 8f4b 0000 8f4b 0000 8f4b 0000     K...K...K...K...
    334c:	8f4b 0000 8f4b 0000 8f4b 0000 8f4b 0000     K...K...K...K...
    335c:	8f4b 0000 8b8b 0000 8f4b 0000 8cff 0000     K.......K.......
    336c:	8f4b 0000 8f4b 0000 8c59 0000 687b 1d1a     K...K...Y...{h..
    337c:	607a 681b f887 3023 68fb 2b00 d005 68fb     z`.h..#0.h.+...h
    338c:	1c5a 60fa f897 2023 701a 6bfb 3301 63fb     Z..`..# .p.k.3.c
    339c:	e1ec 687b 1d1a 607a 681b 64fb 6cf8 f7ff     ..{h..z`.h.d.l..
    33ac:	fdc5 6278 6bbb 2b00 dd1f 6bba 6a7b 429a     ..xb.k.+...k{j.B
    33bc:	d91b 6bba 6a7b 1ad3 63bb f897 302f 68f8     ...k{j...c../0.h
    33cc:	4619 6bba f7ff fdce 63b8 68fb 2b00 d001     .F.k.....c.h.+..
    33dc:	6bbb e000 2300 68fa 4413 60fb 6bbb 6bfa     .k...#.h.D.`.k.k
    33ec:	4413 63fb 2300 63bb e00f e00e 68fb 2b00     .D.c.#.c.....h.+
    33fc:	d005 68fb 1c5a 60fa 6cfa 7812 701a 6cfb     ...hZ..`.l.x.p.l
    340c:	3301 64fb 6bfb 3301 63fb 6cfb 781b 2b00     .3.d.k.3.c.l.x.+
    341c:	d1ec 6bbb 2b00 d022 6bbb 425b 63bb 6bba     ...k.+"..k[B.c.k
    342c:	6a7b 429a d91b 6bba 6a7b 1ad3 63bb f897     {j.B...k{j...c..
    343c:	302f 68f8 4619 6bba f7ff fd94 63b8 68fb     /0.h.F.k.....c.h
    344c:	2b00 d001 6bbb e000 2300 68fa 4413 60fb     .+...k...#.h.D.`
    345c:	6bbb 6bfa 4413 63fb 2300 63bb e186 e185     .k.k.D.c.#.c....
    346c:	2301 f887 302e f897 302d 2b00 d00c 687b     .#...0..-0.+..{h
    347c:	3307 f023 0307 f103 0208 607a e9d3 2300     .3#.......z`...#
    348c:	e009 bf00 1138 1000 687b 1d1a 607a 681b     ....8...{h..z`.h
    349c:	461a f04f 0300 e9c7 2310 6bbb 2b00 d01e     .FO......#.k.+..
    34ac:	e9d7 0110 f7ff fc26 4603 6bba 1ad3 63bb     ......&..F.k...c
    34bc:	f897 302f 68f8 4619 6bba f7ff fd53 63b8     ../0.h.F.k..S..c
    34cc:	68fb 2b00 d001 6bbb e000 2300 68fa 4413     .h.+...k...#.h.D
    34dc:	60fb 6bbb 6bfa 4413 63fb 2300 63bb f897     .`.k.k.D.c.#.c..
    34ec:	302e e9d7 0110 68fa f7ff fcbc 6378 68fb     .0.....h....xc.h
    34fc:	2b00 d003 6b7b 68fa 4413 60fb 6b7b 6bfa     .+..{k.h.D.`{k.k
    350c:	4413 63fb e132 f897 302d 2b00 d009 687b     .D.c2...-0.+..{h
    351c:	3307 f023 0307 f103 0208 607a e9d3 2300     .3#.......z`...#
    352c:	e006 687b 1d1a 607a 681b 461a f04f 0300     ..{h..z`.h.FO...
    353c:	e9c7 2310 6bbb 2b00 d01e e9d7 0110 f7ff     ...#.k.+........
    354c:	fb99 4603 6bba 1ad3 63bb f897 302f 68f8     ...F.k...c../0.h
    355c:	4619 6bba f7ff fd06 63b8 68fb 2b00 d001     .F.k.....c.h.+..
    356c:	6bbb e000 2300 68fa 4413 60fb 6bbb 6bfa     .k...#.h.D.`.k.k
    357c:	4413 63fb 2300 63bb e9d7 0110 68fa f7ff     .D.c.#.c.....h..
    358c:	fc27 6378 68fb 2b00 d003 6b7b 68fa 4413     '.xc.h.+..{k.h.D
    359c:	60fb 6b7b 6bfa 4413 63fb e0e7 f897 302d     .`{k.k.D.c....-0
    35ac:	2b00 d009 687b 3307 f023 0307 f103 0208     .+..{h.3#.......
    35bc:	607a e9d3 2300 e006 687b 1d1a 607a 681b     z`...#..{h..z`.h
    35cc:	461a ea4f 73e2 e9c7 2306 e9d7 2306 2a00     .FO..s...#...#.*
    35dc:	f173 0100 da0a e9d7 2306 4252 eb63 0343     s........#RBc.C.
    35ec:	e9c7 2310 2301 f887 302c e006 e9d7 2306     ...#.#..,0.....#
    35fc:	e9c7 2310 2300 f887 302c 6bbb 2b00 d04a     ...#.#..,0.k.+J.
    360c:	e9d7 2310 4610 4619 f7ff fb56 4603 6bba     ...#.F.F..V..F.k
    361c:	1ad3 63bb f897 302c 2b00 d011 6bbb 3b01     ...c..,0.+...k.;
    362c:	63bb f897 302f 2b30 d10a 68fb 2b00 d004     .c../00+...h.+..
    363c:	68fb 1c5a 60fa 222d 701a 6bfb 3301 63fb     .hZ..`-".p.k.3.c
    364c:	f897 302f 68f8 4619 6bba f7ff fc8b 63b8     ../0.h.F.k.....c
    365c:	68fb 2b00 d001 6bbb e000 2300 68fa 4413     .h.+...k...#.h.D
    366c:	60fb 6bbb 6bfa 4413 63fb 2300 63bb f897     .`.k.k.D.c.#.c..
    367c:	302c 2b00 d01e f897 302f 2b20 d11a 68fb     ,0.+..../0 +...h
    368c:	2b00 d004 68fb 1c5a 60fa 222d 701a 6bfb     .+...hZ..`-".p.k
    369c:	3301 63fb e00e f897 302c 2b00 d00a 68fb     .3.c....,0.+...h
    36ac:	2b00 d004 68fb 1c5a 60fa 222d 701a 6bfb     .+...hZ..`-".p.k
    36bc:	3301 63fb e9d7 0110 68fa f7ff fb89 6378     .3.c.....h....xc
    36cc:	68fb 2b00 d003 6b7b 68fa 4413 60fb 6b7b     .h.+..{k.h.D.`{k
    36dc:	6bfa 4413 63fb e049 68fb 2b00 d038 687b     .k.D.cI..h.+8.{h
    36ec:	3307 f023 0307 f103 0208 607a e9d3 2300     .3#.......z`...#
    36fc:	4610 4619 f000 fd98 4603 617b 68fb 2214     .F.F.....F{a.h."
    370c:	601a 6978 68f9 6b3a f7ff fc52 6378 6b7b     .`xi.h:k..R.xc{k
    371c:	2b00 da14 6b7b f1b3 3fff d102 4b1d 62bb     .+..{k...?...K.b
    372c:	e008 6b7b f113 0f02 d102 4b1b 62bb e001     ..{k.......K.b..
    373c:	4b1a 62bb 68fb 6aba 601a 2303 637b 6b7b     .K.b.h.j.`.#{c{k
    374c:	6bfa 4413 63fb 6b7b 68fa 4413 60fb e00d     .k.D.c{k.h.D.`..
    375c:	e00c 68fb 2b00 d005 68fb 1c5a 60fa 68ba     ...h.+...hZ..`.h
    376c:	7812 701a 6bfb 3301 63fb bf00 68bb 3301     .x.p.k.3.c...h.3
    377c:	60bb 68bb 781b 2b00 f47f ad11 68fb 2b00     .`.h.x.+.....h.+
    378c:	d002 68fb 2200 701a 6bfb 4618 3750 46bd     ...h.".p.k.FP7.F
    379c:	bd80 bf00 2e30 0030 2e23 0023 2e3f 003f     ....0.0.#.#.?.?.
    37ac:	b40f b580 b082 af00 f107 0314 603b 4809     ............;`.H
    37bc:	6939 683a f7ff fce8 6078 4b07 681b 4805     9i:h....x`.K.h.H
    37cc:	4798 687b 4618 3708 46bd e8bd 4080 b004     .G{h.F.7.F...@..
    37dc:	4770 bf00 1038 1000 1140 1000 b580 af00     pG..8...@.......
    37ec:	4801 f7ff ffdd bd80 9ad8 0000 b490 b082     .H..............
    37fc:	af00 6078 687b 685b f003 0302 2b00 f000     ..x`{h[h.....+..
    380c:	8094 687b 681b 2b00 da00 e04d 4b92 2273     ..{h.h.+..M..Ks"
    381c:	601a 687b 681b f003 03f8 085a 4b8f 4413     .`{h.h....Z..K.D
    382c:	461a 687b 681b f003 0307 009b 2102 4099     .F{h.h.......!.@
    383c:	687b 681b f003 03f8 0858 4b88 4403 6818     {h.h....X..K.D.h
    384c:	687b 681b f003 0307 009b 2407 fa04 f303     {h.h.......$....
    385c:	43db 4003 430b 6013 687b 681b f003 03fc     .C.@.C.`{h.h....
    386c:	f103 4380 f503 3380 461a 687b 681b f003     ...C...3.F{h.h..
    387c:	0303 00db 2118 4099 687b 681b f003 03fc     .....!.@{h.h....
    388c:	f103 4380 f503 3380 6818 687b 681b f003     ...C...3.h{h.h..
    389c:	0303 00db 24ff fa04 f303 43db 4003 430b     .....$.....C.@.C
    38ac:	6013 4b6d 2200 601a 687b 681b f003 0320     .`mK.".`{h.h.. .
    38bc:	08da 4b6b 4413 687a 6812 f002 021f 2101     ..kK.Dzh.h.....!
    38cc:	fa01 f202 601a 687b 681b f003 0320 08da     .....`{h.h.. ...
    38dc:	4b64 4413 461a 687b 685b f003 0301 2b00     dK.D.F{h[h.....+
    38ec:	d010 687b 681b f003 0320 08d9 4b5d 440b     ..{h.h.. ...]K.D
    38fc:	6819 687b 681b f003 031f 2001 fa00 f303     .h{h.h..... ....
    390c:	430b e010 687b 681b f003 0320 08d9 4b55     .C..{h.h.. ...UK
    391c:	440b 6819 687b 681b f003 031f 2001 fa00     .D.h{h.h..... ..
    392c:	f303 43db 400b 6013 e092 687b 681b 2b00     ...C.@.`..{h.h.+
    393c:	da00 e04d 4b48 2273 601a 687b 681b f003     ..M.HKs".`{h.h..
    394c:	03f8 085a 4b45 4413 461a 687b 681b f003     ..Z.EK.D.F{h.h..
    395c:	0307 009b 2106 4099 687b 681b f003 03f8     .....!.@{h.h....
    396c:	0858 4b3e 4403 6818 687b 681b f003 0307     X.>K.D.h{h.h....
    397c:	009b 2407 fa04 f303 43db 4003 430b 6013     ...$.....C.@.C.`
    398c:	687b 681b f003 03fc f103 4380 f503 3380     {h.h.......C...3
    399c:	461a 687b 681b f003 0303 00db 2118 4099     .F{h.h.......!.@
    39ac:	687b 681b f003 03fc f103 4380 f503 3380     {h.h.......C...3
    39bc:	6818 687b 681b f003 0303 00db 24ff fa04     .h{h.h.......$..
    39cc:	f303 43db 4003 430b 6013 4b23 2200 601a     ...C.@.C.`#K.".`
    39dc:	687b 681b f003 0320 08da 4b23 4413 687a     {h.h.. ...#K.Dzh
    39ec:	6812 f002 021f 2101 fa01 f202 601a 687b     .h.....!.....`{h
    39fc:	681b f003 0320 08da 4b1a 4413 461a 687b     .h.. ....K.D.F{h
    3a0c:	685b f003 0301 2b00 d010 687b 681b f003     [h.....+..{h.h..
    3a1c:	0320 08d9 4b13 440b 6819 687b 681b f003      ....K.D.h{h.h..
    3a2c:	031f 2001 fa00 f303 430b e010 687b 681b     ... .....C..{h.h
    3a3c:	f003 0320 08d9 4b0b 440b 6819 687b 681b     .. ....K.D.h{h.h
    3a4c:	f003 031f 2001 fa00 f303 43db 400b 6013     ..... .....C.@.`
    3a5c:	3708 46bd bc90 4770 0060 4001 0040 4001     .7.F..pG`..@@..@
    3a6c:	00a8 4001 0088 4001 00b4 4001 b580 b084     ...@...@...@....
    3a7c:	af00 6078 6039 2300 60fb e009 68fb 00db     ..x`9`.#.`...h..
    3a8c:	687a 4413 4618 f7ff feb1 68fb 3301 60fb     zh.D.F.....h.3.`
    3a9c:	68fa 683b 429a d3f1 3710 46bd bd80 bf00     .h;h.B...7.F....
    3aac:	b480 b083 af00 6078 6039 683b 00db 687a     ......x`9`;h..zh
    3abc:	4413 685b f003 0302 2b00 d043 683b 00db     .D[h.....+C.;h..
    3acc:	687a 4413 681b f003 0320 08da 4b2a 4413     zh.D.h.. ...*K.D
    3adc:	461a 683b 00db 6879 440b 685b f003 0301     .F;h..yh.D[h....
    3aec:	2b00 d016 683b 00db 6879 440b 681b f003     .+..;h..yh.D.h..
    3afc:	0320 08d9 4b20 440b 6819 683b 00db 6878      ... K.D.h;h..xh
    3b0c:	4403 681b f003 031f 2001 fa00 f303 430b     .D.h..... .....C
    3b1c:	e016 683b 00db 6879 440b 681b f003 0320     ..;h..yh.D.h.. .
    3b2c:	08d9 4b15 440b 6819 683b 00db 6878 4403     ...K.D.h;h..xh.D
    3b3c:	681b f003 031f 2001 fa00 f303 43db 400b     .h..... .....C.@
    3b4c:	6013 e014 683b 00db 687a 4413 681b f003     .`..;h..zh.D.h..
    3b5c:	0320 08da 4b09 4413 683a 00d2 6879 440a      ....K.D:h..yh.D
    3b6c:	6812 f002 021f 2101 fa01 f202 601a 370c     .h.....!.....`.7
    3b7c:	46bd f85d 7b04 4770 0088 4001 00a8 4001     .F]..{pG...@...@
    3b8c:	b480 b083 af00 6078 6039 683b 00db 687a     ......x`9`;h..zh
    3b9c:	4413 685b f003 0302 2b00 d043 683b 00db     .D[h.....+C.;h..
    3bac:	687a 4413 681b f003 0320 08da 4b2a 4413     zh.D.h.. ...*K.D
    3bbc:	461a 683b 00db 6879 440b 685b f003 0301     .F;h..yh.D[h....
    3bcc:	2b00 d116 683b 00db 6879 440b 681b f003     .+..;h..yh.D.h..
    3bdc:	0320 08d9 4b20 440b 6819 683b 00db 6878      ... K.D.h;h..xh
    3bec:	4403 681b f003 031f 2001 fa00 f303 430b     .D.h..... .....C
    3bfc:	e016 683b 00db 6879 440b 681b f003 0320     ..;h..yh.D.h.. .
    3c0c:	08d9 4b15 440b 6819 683b 00db 6878 4403     ...K.D.h;h..xh.D
    3c1c:	681b f003 031f 2001 fa00 f303 43db 400b     .h..... .....C.@
    3c2c:	6013 e014 683b 00db 687a 4413 681b f003     .`..;h..zh.D.h..
    3c3c:	0320 08da 4b09 4413 683a 00d2 6879 440a      ....K.D:h..yh.D
    3c4c:	6812 f002 021f 2101 fa01 f202 601a 370c     .h.....!.....`.7
    3c5c:	46bd f85d 7b04 4770 0088 4001 00b4 4001     .F]..{pG...@...@
    3c6c:	b580 b086 af00 60f8 60b9 607a 2300 617b     .......`.`z`.#{a
    3c7c:	e014 697b 2201 fa02 f303 461a 687b 4013     ..{i.".....F{h.@
    3c8c:	2b00 d004 68f8 6979 f7ff ff0a e003 68f8     .+...hyi.......h
    3c9c:	6979 f7ff ff75 697b 3301 617b 697a 68bb     yi..u.{i.3{azi.h
    3cac:	429a d3e6 3718 46bd bd80 bf00 4812 4913     .B...7.F.....H.I
    3cbc:	6001 f8d1 d000 4812 6801 f441 0170 6001     .`.....H.hA.p..`
    3ccc:	f3bf 8f4f f3bf 8f6f 480e 490f 4a0f f850     ..O...o..H.I.JP.
    3cdc:	3b04 f841 3b04 4291 f77f aff9 480c 490d     .;A..;.B.....H.I
    3cec:	f04f 0200 4288 bfb8 f840 2b04 f6ff affa     O....B..@..+....
    3cfc:	f7fe fdfe be00 0000 ed08 e000 8000 0000     ................
    3d0c:	ed88 e000 9b04 0000 1000 1000 1034 1000     ............4...
    3d1c:	1034 1000 1144 1000 b480 af00 e7fe bf00     4...D...........
    3d2c:	b480 af00 e7fe bf00 b508 f000 f9d7 f000     ................
    3d3c:	fa75 2001 f000 f9e8 2001 f000 f883 2002     u.. ..... ..... 
    3d4c:	f000 f880 f000 f9ee e8bd 4008 f000 b9be     ...........@....
    3d5c:	b510 4b10 681b f013 0401 b086 d001 b006     ...K.h..........
    3d6c:	bd10 a806 4b0c f840 3d14 f000 f9fd 4b0b     .....K@..=.....K
    3d7c:	490b 4a0c 2073 6018 6808 f020 0070 6008     .I.Js .`.h .p..`
    3d8c:	6811 f421 417f f441 5180 6011 601c b006     .h!..AA..Q.`.`..
    3d9c:	bd10 bf00 113c 1000 4240 000f 0060 4001     ....<...@B..`..@
    3dac:	0054 4001 0028 4001 4b0f 681b b510 f013     T..@(..@.K.h....
    3dbc:	0401 d000 bd10 f000 f937 4b0c 490c 4a0d     ........7..K.I.J
    3dcc:	2073 6018 6808 f020 0070 f040 0020 6008     s .`.h .p.@. ..`
    3ddc:	6811 f421 417f f441 51c0 6011 601c e8bd     .h!..AA..Q.`.`..
    3dec:	4010 f000 ba15 bf00 113c 1000 0060 4001     .@......<...`..@
    3dfc:	0054 4001 0028 4001 f000 b92c 4b05 4a06     T..@(..@..,..K.J
    3e0c:	b410 2100 2447 601c 6010 f85d 4b04 6019     ...!G$.`.`]..K.`
    3e1c:	4770 bf00 4014 4000 4018 4000 4a03 4b04     pG...@.@.@.@.J.K
    3e2c:	6812 f002 0207 f853 0022 4770 4018 4000     .h....S.".pG.@.@
    3e3c:	9ae4 0000 4b02 681a ea22 0000 6018 4770     .....K.h"....`pG
    3e4c:	400c 4000 4b02 681a 4310 6018 4770 bf00     .@.@.K.h.C.`pG..
    3e5c:	400c 4000 b430 680d 688c 684a 4b06 2d00     .@.@0..h.hJh.K.-
    3e6c:	ea42 4204 ea4f 1000 bf0c 2100 f04f 4100     B..BO......!O..A
    3e7c:	430a 50c2 bc30 4770 800c 4000 0100 4b07     .C.P0.pG...@...K
    3e8c:	58c2 b410 f001 2408 ea22 0204 f001 1101     .X.....$".......
    3e9c:	4311 50c1 f85d 4b04 4770 bf00 800c 4000     .C.P]..KpG.....@
    3eac:	0100 4b03 58c2 f001 2108 430a 50c2 4770     ...K.X...!.C.PpG
    3ebc:	800c 4000 b4f0 0100 4c1b 5904 f511 3f80     ...@.....L.Y...?
    3ecc:	bf08 0c24 f404 74c0 2c80 d016 f64f 75ff     ..$....t.,..O..u
    3edc:	2400 42a9 4626 4f15 f8df c054 d019 f511     .$.B&F.O..T.....
    3eec:	3f80 d01b 0c33 b291 041b 430c ea43 4212     .?..3......CC..B
    3efc:	51c4 f840 200c bcf0 4770 f64f 75ff 42a9     .Q@.. ..pGO..u.B
    3f0c:	ea4f 4402 4616 4f09 f8df c024 ebc3 0202     O..D.F.O..$.....
    3f1c:	d1e5 b292 4314 51c4 bcf0 4770 b292 4314     .....C.Q..pG...C
    3f2c:	f840 400c bcf0 4770 800c 4000 8004 4000     @..@..pG...@...@
    3f3c:	8008 4000 4b02 681a 4310 6018 4770 bf00     ...@.K.h.C.`pG..
    3f4c:	8200 4000 4b01 6018 4770 bf00 8208 4000     ...@.K.`pG.....@
    3f5c:	3801 f47f affd 4770 280f d80b 2805 d012     .8....pG.(...(..
    3f6c:	2806 d016 2804 d104 4b0d 681a f442 3280     .(...(...K.hB..2
    3f7c:	601a 4770 3810 f000 001f 2201 4b09 fa02     .`pG.8.....".K..
    3f8c:	f000 6018 4770 4b06 681a f442 3200 601a     ...`pG.K.hB..2.`
    3f9c:	4770 4b03 681a f442 2280 601a 4770 bf00     pG.K.hB..".`pG..
    3fac:	ed24 e000 e100 e000 f3ef 8010 b662 4770     $...........b.pG
    3fbc:	b510 4604 f7ff ff32 4b04 fba3 2000 0c80     ...F..2..K... ..
    3fcc:	fb04 f000 e8bd 4010 f7ff bfc2 9f81 165e     .......@......^.
    3fdc:	4b0d 681b 07da b430 d414 4a0c 6813 f043     .K.h..0....J.hC.
    3fec:	7380 6013 6813 01db d5fc 4809 4d09 4c0a     .s.`.h.....H.M.L
    3ffc:	490a 4b0b 6005 4a0b 250f f04f 30ff 6025     .I.K.`.J.%O..0%`
    400c:	6008 601a bc30 4770 113c 1000 edfc e000     .`.`0.pG<.......
    401c:	0fb0 e000 ce55 c5ac 0e40 e000 0e00 e000     ....U...@.......
    402c:	0e80 e000 0511 0015 b508 4a08 6813 021b     ...........J.h..
    403c:	d4fc f7ff fef3 4b06 fba3 2000 0c80 2332     .......K... ..2#
    404c:	fb03 f000 e8bd 4008 f7ff bf82 0e80 e000     .......@........
    405c:	9f81 165e 7803 b430 b193 4602 2300 f812     ..^..x0....F.#..
    406c:	1f01 3301 2900 d1fa f04f 4260 18c5 4614     ...3.)..O.`B...F
    407c:	f810 1b01 6813 2b00 d0fc 42a8 7021 d1f7     .....h.+...B!p..
    408c:	bc30 4770 4b0d 490e 681b 4a0e 6809 60c1     0.pG.K.I.h.J.h.`
    409c:	b470 6841 6815 4c0c 6942 4329 6041 6824     p.Ah.h.LBi)CA`$h
    40ac:	f003 0601 f3c3 0140 4322 f3c3 0380 7006     ......@."C.....p
    40bc:	7201 7403 6142 bc70 4770 bf00 01cc 4002     .r.tBap.pG.....@
    40cc:	01c4 4002 01c0 4002 01c8 4002 4b02 f06f     ...@...@...@.Ko.
    40dc:	0201 601a 4770 bf00 00fc 4002 4b08 4a09     ...`pG.....@.K.J
    40ec:	6819 f041 0102 6019 6819 f041 0101 6019     .hA....`.hA....`
    40fc:	6813 0799 d5fc 4a03 6813 07db d5fc 4770     .h.....J.h....pG
    410c:	0010 4002 0014 4002 4b05 681a b918 f022     ...@...@.K.h..".
    411c:	0280 601a 4770 f042 0280 601a 4770 bf00     ...`pGB....`pG..
    412c:	400c 4000 4b02 681a f042 0210 601a 4770     .@.@.K.hB....`pG
    413c:	4050 4000 b158 4b0a 681b f033 0201 4b09     P@.@X..K.h3....K
    414c:	681a d007 f022 0204 601a bf30 4770 4b05     .h.."....`0.pG.K
    415c:	681a e7f7 f042 0204 601a bf30 4770 bf00     .h..B....`0.pG..
    416c:	0250 4002 ed10 e000 b538 4b21 6804 2200     P..@....8.!K.h."
    417c:	601a b31c 491f 4b20 4a20 2001 6008 f5a4     .`...I K J. .`..
    418c:	4161 4291 bf88 461c f7ff fe48 1c43 d02c     aA.B...F..H.C.,.
    419c:	08c0 fbb0 f4f4 3c01 b2a4 4a19 4d19 4b1a     .......<...J.M.K
    41ac:	491a 6014 2000 2402 f240 2201 602c 6008     .I.`. .$@..",`.`
    41bc:	601a 2032 e8bd 4038 f7ff befa 4a10 6903     .`2 ..8@.....J.i
    41cc:	6013 6883 f8c2 30e0 68c2 490a 4b0e 2401     .`.h...0.h.I.K.$
    41dc:	3a01 fa04 f202 600a 6842 6819 430a 601a     .:.....`Bh.h.C.`
    41ec:	2032 e8bd 4038 f7ff bee3 2402 e7d5 bf00     2 ..8@.....$....
    41fc:	0304 e004 0004 e004 4240 000f a380 001d     ........@B......
    420c:	0010 e004 00f0 e004 0250 4002 0f00 e004     ........P..@....
    421c:	4b01 2200 601a 4770 0250 4002 4b01 2237     .K.".`pGP..@.K7"
    422c:	601a 4770 c008 4000 ea4f 0241 f1b2 43e0     .`pG...@O.A....C
    423c:	bf24 f5b3 1c00 f1dc 5cfe d90d f001 4c00     $........\.....L
    424c:	ea4f 02c0 ea4c 7050 f1b2 4f00 eb40 0083     O...L.Pp...O@...
    425c:	bf08 f020 0001 4770 f011 4f80 d121 f113     .. ...pG...O!...
    426c:	7238 bfbc f001 4000 4770 f441 1180 ea4f     8r.....@pGA...O.
    427c:	5252 f1c2 0218 f1c2 0c20 fa10 f30c fa20     RR...... ..... .
    428c:	f002 bf18 f040 0001 ea4f 23c1 ea4f 23d3     ....@...O..#O..#
    429c:	fa03 fc0c ea40 000c fa23 f302 ea4f 0343     ....@...#...O.C.
    42ac:	e7cc ea7f 5362 d107 ea50 3301 bf1e f04f     ....bS..P..3..O.
    42bc:	40fe f440 0040 4770 f001 4000 f040 40fe     .@@.@.pG...@@..@
    42cc:	f440 0000 4770 bf00 6942 616e 7972 4320     @...pG..Binary C
    42dc:	756f 746e 7265 4520 6178 706d 656c 000a     ounter Example..
    42ec:	3e3e 3e3e 3e3e 203e 0000 0000 3600 016e     >>>>>>> .....6n.
    42fc:	1b00 00b7 1200 007a 8d80 005b 3e00 0049     ......z...[..>I.
    430c:	0900 003d 50db 0034 c6c0 002d 0000 0000     ..=..P4...-.....
    431c:	0256 0000 0000 0000 0022 0000 0000 0000     V.......".......
    432c:	0021 0000 0000 0000 001c 0000 0000 0000     !...............
    433c:	001a 0000 0000 0000 0019 0000 0000 0000     ................

0000434c <g_sIOMConfig>:
    434c:	0000 0000 1c00 0904 0000 3c04               ...........<

00004358 <g_SPIpins>:
    4358:	0006 0000 000a 0000 0009 0000 000a 0000     ................

00004368 <CSWTCH.4>:
    4368:	3600 016e 1b00 00b7 1200 007a 8d80 005b     .6n.......z...[.
    4378:	3e00 0049 0900 003d 50db 0034 c6c0 002d     .>I...=..P4...-.
    4388:	4f49 204d 7277 7469 2065 6874 6572 6873     IOM write thresh
    4398:	6c6f 2064 6f74 206f 6962 2e67 0000 0000     old too big.....
    43a8:	4f49 204d 6572 6461 7420 7268 7365 6f68     IOM read thresho
    43b8:	646c 7420 6f6f 6220 6769 002e 4f49 204d     ld too big..IOM 
    43c8:	7277 7469 2065 6874 6572 6873 6c6f 2064     write threshold 
    43d8:	6f74 206f 6d73 6c61 2e6c 0000 4f49 204d     too small...IOM 
    43e8:	6572 6461 7420 7268 7365 6f68 646c 7420     read threshold t
    43f8:	6f6f 7320 616d 6c6c 002e 0000 7254 6979     oo small....Tryi
    4408:	676e 7420 206f 6f64 6120 3020 6220 7479     ng to do a 0 byt
    4418:	2065 7274 6e61 6173 7463 6f69 006e 0000     e transaction...
    4428:	2e2e 2e5c 5c2e 6d61 685f 6c61 695f 6d6f     ..\..\am_hal_iom
    4438:	632e 0000 3249 2043 7274 6e61 6673 7265     .c..I2C transfer
    4448:	7420 6f6f 6220 6769 002e 0000 6854 2065      too big....The 
    4458:	6966 6f66 6420 656f 6e73 7427 6320 6e6f     fifo doesn't con
    4468:	6174 6e69 7420 6568 7220 7165 6575 7473     tain the request
    4478:	6465 6e20 6d75 6562 2072 666f 6220 7479     ed number of byt
    4488:	7365 002e 4f49 204d 4d43 4344 504d 7720     es..IOM CMDCMP w
    4498:	7361 6e20 746f 7320 6565 006e 6854 2065     as not seen.The 
    44a8:	4f49 204d 7571 7565 2065 7369 6620 6c75     IOM queue is ful
    44b8:	2e6c 4120 6c6c 636f 7461 2065 6f6d 6572     l. Allocate more
    44c8:	656d 6f6d 7972 7420 206f 6874 2065 4f49     memory to the IO
    44d8:	204d 7571 7565 2c65 6f20 2072 6c61 6f6c     M queue, or allo
    44e8:	2077 7469 6d20 726f 7465 6d69 2065 6f74     w it moretime to
    44f8:	6520 706d 7974 6220 7465 6577 6e65 7420      empty between t
    4508:	6172 736e 6361 6974 6e6f 2e73 0000 0000     ransactions.....
    4518:	5053 2049 7274 6e61 6673 7265 7420 6f6f     SPI transfer too
    4528:	6220 6769 002e 0000 6854 2065 6966 6f66      big....The fifo
    4538:	6320 756f 646c 276e 2074 6966 2074 6874      couldn't fit th
    4548:	2065 6572 7571 7365 6574 2064 756e 626d     e requested numb
    4558:	7265 6f20 2066 7962 6574 0073               er of bytes.
