
coremark_gcc.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005888  00000000  00000000  00010000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .stack        00001000  10000000  10000000  00030000  2**2
                  ALLOC
  2 .data         00000048  10001000  00005888  00021000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00000528  10001048  000058d0  00021048  2**2
                  ALLOC
  4 .ARM.attributes 00000037  00000000  00000000  00021048  2**0
                  CONTENTS, READONLY
  5 .debug_info   0000db9c  00000000  00000000  0002107f  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00002e10  00000000  00000000  0002ec1b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    000097d0  00000000  00000000  00031a2b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_aranges 000007a8  00000000  00000000  0003b1fb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_ranges 00001800  00000000  00000000  0003b9a3  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00005bee  00000000  00000000  0003d1a3  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00002c00  00000000  00000000  00042d91  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000007c  00000000  00000000  00045991  2**0
                  CONTENTS, READONLY
 13 .debug_frame  00001608  00000000  00000000  00045a10  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <g_am_pfnVectors>:
       0:	00 10 00 10 15 3a 00 00 0d 3a 00 00 9d 3a 00 00     .....:...:...:..
      10:	9d 3a 00 00 9d 3a 00 00 9d 3a 00 00 00 00 00 00     .:...:...:......
	...
      2c:	11 3a 00 00 11 3a 00 00 00 00 00 00 11 3a 00 00     .:...:.......:..
      3c:	e1 0b 00 00 11 3a 00 00 11 3a 00 00 11 3a 00 00     .....:...:...:..
      4c:	11 3a 00 00 11 3a 00 00 11 3a 00 00 11 3a 00 00     .:...:...:...:..
      5c:	11 3a 00 00 11 3a 00 00 11 3a 00 00 11 3a 00 00     .:...:...:...:..
      6c:	11 3a 00 00 11 3a 00 00 11 3a 00 00 11 3a 00 00     .:...:...:...:..
      7c:	11 3a 00 00                                         .:..

00000080 <__aeabi_drsub>:
      80:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
      84:	e002      	b.n	8c <__adddf3>
      86:	bf00      	nop

00000088 <__aeabi_dsub>:
      88:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0000008c <__adddf3>:
      8c:	b530      	push	{r4, r5, lr}
      8e:	ea4f 0441 	mov.w	r4, r1, lsl #1
      92:	ea4f 0543 	mov.w	r5, r3, lsl #1
      96:	ea94 0f05 	teq	r4, r5
      9a:	bf08      	it	eq
      9c:	ea90 0f02 	teqeq	r0, r2
      a0:	bf1f      	itttt	ne
      a2:	ea54 0c00 	orrsne.w	ip, r4, r0
      a6:	ea55 0c02 	orrsne.w	ip, r5, r2
      aa:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
      ae:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
      b2:	f000 80e2 	beq.w	27a <__adddf3+0x1ee>
      b6:	ea4f 5454 	mov.w	r4, r4, lsr #21
      ba:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
      be:	bfb8      	it	lt
      c0:	426d      	neglt	r5, r5
      c2:	dd0c      	ble.n	de <__adddf3+0x52>
      c4:	442c      	add	r4, r5
      c6:	ea80 0202 	eor.w	r2, r0, r2
      ca:	ea81 0303 	eor.w	r3, r1, r3
      ce:	ea82 0000 	eor.w	r0, r2, r0
      d2:	ea83 0101 	eor.w	r1, r3, r1
      d6:	ea80 0202 	eor.w	r2, r0, r2
      da:	ea81 0303 	eor.w	r3, r1, r3
      de:	2d36      	cmp	r5, #54	; 0x36
      e0:	bf88      	it	hi
      e2:	bd30      	pophi	{r4, r5, pc}
      e4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
      e8:	ea4f 3101 	mov.w	r1, r1, lsl #12
      ec:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
      f0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
      f4:	d002      	beq.n	fc <__adddf3+0x70>
      f6:	4240      	negs	r0, r0
      f8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
      fc:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
     100:	ea4f 3303 	mov.w	r3, r3, lsl #12
     104:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
     108:	d002      	beq.n	110 <__adddf3+0x84>
     10a:	4252      	negs	r2, r2
     10c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
     110:	ea94 0f05 	teq	r4, r5
     114:	f000 80a7 	beq.w	266 <__adddf3+0x1da>
     118:	f1a4 0401 	sub.w	r4, r4, #1
     11c:	f1d5 0e20 	rsbs	lr, r5, #32
     120:	db0d      	blt.n	13e <__adddf3+0xb2>
     122:	fa02 fc0e 	lsl.w	ip, r2, lr
     126:	fa22 f205 	lsr.w	r2, r2, r5
     12a:	1880      	adds	r0, r0, r2
     12c:	f141 0100 	adc.w	r1, r1, #0
     130:	fa03 f20e 	lsl.w	r2, r3, lr
     134:	1880      	adds	r0, r0, r2
     136:	fa43 f305 	asr.w	r3, r3, r5
     13a:	4159      	adcs	r1, r3
     13c:	e00e      	b.n	15c <__adddf3+0xd0>
     13e:	f1a5 0520 	sub.w	r5, r5, #32
     142:	f10e 0e20 	add.w	lr, lr, #32
     146:	2a01      	cmp	r2, #1
     148:	fa03 fc0e 	lsl.w	ip, r3, lr
     14c:	bf28      	it	cs
     14e:	f04c 0c02 	orrcs.w	ip, ip, #2
     152:	fa43 f305 	asr.w	r3, r3, r5
     156:	18c0      	adds	r0, r0, r3
     158:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
     15c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
     160:	d507      	bpl.n	172 <__adddf3+0xe6>
     162:	f04f 0e00 	mov.w	lr, #0
     166:	f1dc 0c00 	rsbs	ip, ip, #0
     16a:	eb7e 0000 	sbcs.w	r0, lr, r0
     16e:	eb6e 0101 	sbc.w	r1, lr, r1
     172:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
     176:	d31b      	bcc.n	1b0 <__adddf3+0x124>
     178:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
     17c:	d30c      	bcc.n	198 <__adddf3+0x10c>
     17e:	0849      	lsrs	r1, r1, #1
     180:	ea5f 0030 	movs.w	r0, r0, rrx
     184:	ea4f 0c3c 	mov.w	ip, ip, rrx
     188:	f104 0401 	add.w	r4, r4, #1
     18c:	ea4f 5244 	mov.w	r2, r4, lsl #21
     190:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
     194:	f080 809a 	bcs.w	2cc <__adddf3+0x240>
     198:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
     19c:	bf08      	it	eq
     19e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
     1a2:	f150 0000 	adcs.w	r0, r0, #0
     1a6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
     1aa:	ea41 0105 	orr.w	r1, r1, r5
     1ae:	bd30      	pop	{r4, r5, pc}
     1b0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
     1b4:	4140      	adcs	r0, r0
     1b6:	eb41 0101 	adc.w	r1, r1, r1
     1ba:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
     1be:	f1a4 0401 	sub.w	r4, r4, #1
     1c2:	d1e9      	bne.n	198 <__adddf3+0x10c>
     1c4:	f091 0f00 	teq	r1, #0
     1c8:	bf04      	itt	eq
     1ca:	4601      	moveq	r1, r0
     1cc:	2000      	moveq	r0, #0
     1ce:	fab1 f381 	clz	r3, r1
     1d2:	bf08      	it	eq
     1d4:	3320      	addeq	r3, #32
     1d6:	f1a3 030b 	sub.w	r3, r3, #11
     1da:	f1b3 0220 	subs.w	r2, r3, #32
     1de:	da0c      	bge.n	1fa <__adddf3+0x16e>
     1e0:	320c      	adds	r2, #12
     1e2:	dd08      	ble.n	1f6 <__adddf3+0x16a>
     1e4:	f102 0c14 	add.w	ip, r2, #20
     1e8:	f1c2 020c 	rsb	r2, r2, #12
     1ec:	fa01 f00c 	lsl.w	r0, r1, ip
     1f0:	fa21 f102 	lsr.w	r1, r1, r2
     1f4:	e00c      	b.n	210 <__adddf3+0x184>
     1f6:	f102 0214 	add.w	r2, r2, #20
     1fa:	bfd8      	it	le
     1fc:	f1c2 0c20 	rsble	ip, r2, #32
     200:	fa01 f102 	lsl.w	r1, r1, r2
     204:	fa20 fc0c 	lsr.w	ip, r0, ip
     208:	bfdc      	itt	le
     20a:	ea41 010c 	orrle.w	r1, r1, ip
     20e:	4090      	lslle	r0, r2
     210:	1ae4      	subs	r4, r4, r3
     212:	bfa2      	ittt	ge
     214:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
     218:	4329      	orrge	r1, r5
     21a:	bd30      	popge	{r4, r5, pc}
     21c:	ea6f 0404 	mvn.w	r4, r4
     220:	3c1f      	subs	r4, #31
     222:	da1c      	bge.n	25e <__adddf3+0x1d2>
     224:	340c      	adds	r4, #12
     226:	dc0e      	bgt.n	246 <__adddf3+0x1ba>
     228:	f104 0414 	add.w	r4, r4, #20
     22c:	f1c4 0220 	rsb	r2, r4, #32
     230:	fa20 f004 	lsr.w	r0, r0, r4
     234:	fa01 f302 	lsl.w	r3, r1, r2
     238:	ea40 0003 	orr.w	r0, r0, r3
     23c:	fa21 f304 	lsr.w	r3, r1, r4
     240:	ea45 0103 	orr.w	r1, r5, r3
     244:	bd30      	pop	{r4, r5, pc}
     246:	f1c4 040c 	rsb	r4, r4, #12
     24a:	f1c4 0220 	rsb	r2, r4, #32
     24e:	fa20 f002 	lsr.w	r0, r0, r2
     252:	fa01 f304 	lsl.w	r3, r1, r4
     256:	ea40 0003 	orr.w	r0, r0, r3
     25a:	4629      	mov	r1, r5
     25c:	bd30      	pop	{r4, r5, pc}
     25e:	fa21 f004 	lsr.w	r0, r1, r4
     262:	4629      	mov	r1, r5
     264:	bd30      	pop	{r4, r5, pc}
     266:	f094 0f00 	teq	r4, #0
     26a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
     26e:	bf06      	itte	eq
     270:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
     274:	3401      	addeq	r4, #1
     276:	3d01      	subne	r5, #1
     278:	e74e      	b.n	118 <__adddf3+0x8c>
     27a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
     27e:	bf18      	it	ne
     280:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
     284:	d029      	beq.n	2da <__adddf3+0x24e>
     286:	ea94 0f05 	teq	r4, r5
     28a:	bf08      	it	eq
     28c:	ea90 0f02 	teqeq	r0, r2
     290:	d005      	beq.n	29e <__adddf3+0x212>
     292:	ea54 0c00 	orrs.w	ip, r4, r0
     296:	bf04      	itt	eq
     298:	4619      	moveq	r1, r3
     29a:	4610      	moveq	r0, r2
     29c:	bd30      	pop	{r4, r5, pc}
     29e:	ea91 0f03 	teq	r1, r3
     2a2:	bf1e      	ittt	ne
     2a4:	2100      	movne	r1, #0
     2a6:	2000      	movne	r0, #0
     2a8:	bd30      	popne	{r4, r5, pc}
     2aa:	ea5f 5c54 	movs.w	ip, r4, lsr #21
     2ae:	d105      	bne.n	2bc <__adddf3+0x230>
     2b0:	0040      	lsls	r0, r0, #1
     2b2:	4149      	adcs	r1, r1
     2b4:	bf28      	it	cs
     2b6:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
     2ba:	bd30      	pop	{r4, r5, pc}
     2bc:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
     2c0:	bf3c      	itt	cc
     2c2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
     2c6:	bd30      	popcc	{r4, r5, pc}
     2c8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
     2cc:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
     2d0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
     2d4:	f04f 0000 	mov.w	r0, #0
     2d8:	bd30      	pop	{r4, r5, pc}
     2da:	ea7f 5c64 	mvns.w	ip, r4, asr #21
     2de:	bf1a      	itte	ne
     2e0:	4619      	movne	r1, r3
     2e2:	4610      	movne	r0, r2
     2e4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
     2e8:	bf1c      	itt	ne
     2ea:	460b      	movne	r3, r1
     2ec:	4602      	movne	r2, r0
     2ee:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
     2f2:	bf06      	itte	eq
     2f4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
     2f8:	ea91 0f03 	teqeq	r1, r3
     2fc:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
     300:	bd30      	pop	{r4, r5, pc}
     302:	bf00      	nop

00000304 <__aeabi_ui2d>:
     304:	f090 0f00 	teq	r0, #0
     308:	bf04      	itt	eq
     30a:	2100      	moveq	r1, #0
     30c:	4770      	bxeq	lr
     30e:	b530      	push	{r4, r5, lr}
     310:	f44f 6480 	mov.w	r4, #1024	; 0x400
     314:	f104 0432 	add.w	r4, r4, #50	; 0x32
     318:	f04f 0500 	mov.w	r5, #0
     31c:	f04f 0100 	mov.w	r1, #0
     320:	e750      	b.n	1c4 <__adddf3+0x138>
     322:	bf00      	nop

00000324 <__aeabi_i2d>:
     324:	f090 0f00 	teq	r0, #0
     328:	bf04      	itt	eq
     32a:	2100      	moveq	r1, #0
     32c:	4770      	bxeq	lr
     32e:	b530      	push	{r4, r5, lr}
     330:	f44f 6480 	mov.w	r4, #1024	; 0x400
     334:	f104 0432 	add.w	r4, r4, #50	; 0x32
     338:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
     33c:	bf48      	it	mi
     33e:	4240      	negmi	r0, r0
     340:	f04f 0100 	mov.w	r1, #0
     344:	e73e      	b.n	1c4 <__adddf3+0x138>
     346:	bf00      	nop

00000348 <__aeabi_f2d>:
     348:	0042      	lsls	r2, r0, #1
     34a:	ea4f 01e2 	mov.w	r1, r2, asr #3
     34e:	ea4f 0131 	mov.w	r1, r1, rrx
     352:	ea4f 7002 	mov.w	r0, r2, lsl #28
     356:	bf1f      	itttt	ne
     358:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
     35c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
     360:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
     364:	4770      	bxne	lr
     366:	f092 0f00 	teq	r2, #0
     36a:	bf14      	ite	ne
     36c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
     370:	4770      	bxeq	lr
     372:	b530      	push	{r4, r5, lr}
     374:	f44f 7460 	mov.w	r4, #896	; 0x380
     378:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
     37c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
     380:	e720      	b.n	1c4 <__adddf3+0x138>
     382:	bf00      	nop

00000384 <__aeabi_ul2d>:
     384:	ea50 0201 	orrs.w	r2, r0, r1
     388:	bf08      	it	eq
     38a:	4770      	bxeq	lr
     38c:	b530      	push	{r4, r5, lr}
     38e:	f04f 0500 	mov.w	r5, #0
     392:	e00a      	b.n	3aa <__aeabi_l2d+0x16>

00000394 <__aeabi_l2d>:
     394:	ea50 0201 	orrs.w	r2, r0, r1
     398:	bf08      	it	eq
     39a:	4770      	bxeq	lr
     39c:	b530      	push	{r4, r5, lr}
     39e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
     3a2:	d502      	bpl.n	3aa <__aeabi_l2d+0x16>
     3a4:	4240      	negs	r0, r0
     3a6:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
     3aa:	f44f 6480 	mov.w	r4, #1024	; 0x400
     3ae:	f104 0432 	add.w	r4, r4, #50	; 0x32
     3b2:	ea5f 5c91 	movs.w	ip, r1, lsr #22
     3b6:	f43f aedc 	beq.w	172 <__adddf3+0xe6>
     3ba:	f04f 0203 	mov.w	r2, #3
     3be:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
     3c2:	bf18      	it	ne
     3c4:	3203      	addne	r2, #3
     3c6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
     3ca:	bf18      	it	ne
     3cc:	3203      	addne	r2, #3
     3ce:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
     3d2:	f1c2 0320 	rsb	r3, r2, #32
     3d6:	fa00 fc03 	lsl.w	ip, r0, r3
     3da:	fa20 f002 	lsr.w	r0, r0, r2
     3de:	fa01 fe03 	lsl.w	lr, r1, r3
     3e2:	ea40 000e 	orr.w	r0, r0, lr
     3e6:	fa21 f102 	lsr.w	r1, r1, r2
     3ea:	4414      	add	r4, r2
     3ec:	e6c1      	b.n	172 <__adddf3+0xe6>
     3ee:	bf00      	nop

000003f0 <__aeabi_dmul>:
     3f0:	b570      	push	{r4, r5, r6, lr}
     3f2:	f04f 0cff 	mov.w	ip, #255	; 0xff
     3f6:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
     3fa:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
     3fe:	bf1d      	ittte	ne
     400:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
     404:	ea94 0f0c 	teqne	r4, ip
     408:	ea95 0f0c 	teqne	r5, ip
     40c:	f000 f8de 	bleq	5cc <__aeabi_dmul+0x1dc>
     410:	442c      	add	r4, r5
     412:	ea81 0603 	eor.w	r6, r1, r3
     416:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
     41a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
     41e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
     422:	bf18      	it	ne
     424:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
     428:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
     42c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
     430:	d038      	beq.n	4a4 <__aeabi_dmul+0xb4>
     432:	fba0 ce02 	umull	ip, lr, r0, r2
     436:	f04f 0500 	mov.w	r5, #0
     43a:	fbe1 e502 	umlal	lr, r5, r1, r2
     43e:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
     442:	fbe0 e503 	umlal	lr, r5, r0, r3
     446:	f04f 0600 	mov.w	r6, #0
     44a:	fbe1 5603 	umlal	r5, r6, r1, r3
     44e:	f09c 0f00 	teq	ip, #0
     452:	bf18      	it	ne
     454:	f04e 0e01 	orrne.w	lr, lr, #1
     458:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
     45c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
     460:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
     464:	d204      	bcs.n	470 <__aeabi_dmul+0x80>
     466:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
     46a:	416d      	adcs	r5, r5
     46c:	eb46 0606 	adc.w	r6, r6, r6
     470:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
     474:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
     478:	ea4f 20c5 	mov.w	r0, r5, lsl #11
     47c:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
     480:	ea4f 2ece 	mov.w	lr, lr, lsl #11
     484:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
     488:	bf88      	it	hi
     48a:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
     48e:	d81e      	bhi.n	4ce <__aeabi_dmul+0xde>
     490:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
     494:	bf08      	it	eq
     496:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
     49a:	f150 0000 	adcs.w	r0, r0, #0
     49e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
     4a2:	bd70      	pop	{r4, r5, r6, pc}
     4a4:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
     4a8:	ea46 0101 	orr.w	r1, r6, r1
     4ac:	ea40 0002 	orr.w	r0, r0, r2
     4b0:	ea81 0103 	eor.w	r1, r1, r3
     4b4:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
     4b8:	bfc2      	ittt	gt
     4ba:	ebd4 050c 	rsbsgt	r5, r4, ip
     4be:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
     4c2:	bd70      	popgt	{r4, r5, r6, pc}
     4c4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
     4c8:	f04f 0e00 	mov.w	lr, #0
     4cc:	3c01      	subs	r4, #1
     4ce:	f300 80ab 	bgt.w	628 <__aeabi_dmul+0x238>
     4d2:	f114 0f36 	cmn.w	r4, #54	; 0x36
     4d6:	bfde      	ittt	le
     4d8:	2000      	movle	r0, #0
     4da:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
     4de:	bd70      	pople	{r4, r5, r6, pc}
     4e0:	f1c4 0400 	rsb	r4, r4, #0
     4e4:	3c20      	subs	r4, #32
     4e6:	da35      	bge.n	554 <__aeabi_dmul+0x164>
     4e8:	340c      	adds	r4, #12
     4ea:	dc1b      	bgt.n	524 <__aeabi_dmul+0x134>
     4ec:	f104 0414 	add.w	r4, r4, #20
     4f0:	f1c4 0520 	rsb	r5, r4, #32
     4f4:	fa00 f305 	lsl.w	r3, r0, r5
     4f8:	fa20 f004 	lsr.w	r0, r0, r4
     4fc:	fa01 f205 	lsl.w	r2, r1, r5
     500:	ea40 0002 	orr.w	r0, r0, r2
     504:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
     508:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
     50c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
     510:	fa21 f604 	lsr.w	r6, r1, r4
     514:	eb42 0106 	adc.w	r1, r2, r6
     518:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
     51c:	bf08      	it	eq
     51e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
     522:	bd70      	pop	{r4, r5, r6, pc}
     524:	f1c4 040c 	rsb	r4, r4, #12
     528:	f1c4 0520 	rsb	r5, r4, #32
     52c:	fa00 f304 	lsl.w	r3, r0, r4
     530:	fa20 f005 	lsr.w	r0, r0, r5
     534:	fa01 f204 	lsl.w	r2, r1, r4
     538:	ea40 0002 	orr.w	r0, r0, r2
     53c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
     540:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
     544:	f141 0100 	adc.w	r1, r1, #0
     548:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
     54c:	bf08      	it	eq
     54e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
     552:	bd70      	pop	{r4, r5, r6, pc}
     554:	f1c4 0520 	rsb	r5, r4, #32
     558:	fa00 f205 	lsl.w	r2, r0, r5
     55c:	ea4e 0e02 	orr.w	lr, lr, r2
     560:	fa20 f304 	lsr.w	r3, r0, r4
     564:	fa01 f205 	lsl.w	r2, r1, r5
     568:	ea43 0302 	orr.w	r3, r3, r2
     56c:	fa21 f004 	lsr.w	r0, r1, r4
     570:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
     574:	fa21 f204 	lsr.w	r2, r1, r4
     578:	ea20 0002 	bic.w	r0, r0, r2
     57c:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
     580:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
     584:	bf08      	it	eq
     586:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
     58a:	bd70      	pop	{r4, r5, r6, pc}
     58c:	f094 0f00 	teq	r4, #0
     590:	d10f      	bne.n	5b2 <__aeabi_dmul+0x1c2>
     592:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
     596:	0040      	lsls	r0, r0, #1
     598:	eb41 0101 	adc.w	r1, r1, r1
     59c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
     5a0:	bf08      	it	eq
     5a2:	3c01      	subeq	r4, #1
     5a4:	d0f7      	beq.n	596 <__aeabi_dmul+0x1a6>
     5a6:	ea41 0106 	orr.w	r1, r1, r6
     5aa:	f095 0f00 	teq	r5, #0
     5ae:	bf18      	it	ne
     5b0:	4770      	bxne	lr
     5b2:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
     5b6:	0052      	lsls	r2, r2, #1
     5b8:	eb43 0303 	adc.w	r3, r3, r3
     5bc:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
     5c0:	bf08      	it	eq
     5c2:	3d01      	subeq	r5, #1
     5c4:	d0f7      	beq.n	5b6 <__aeabi_dmul+0x1c6>
     5c6:	ea43 0306 	orr.w	r3, r3, r6
     5ca:	4770      	bx	lr
     5cc:	ea94 0f0c 	teq	r4, ip
     5d0:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
     5d4:	bf18      	it	ne
     5d6:	ea95 0f0c 	teqne	r5, ip
     5da:	d00c      	beq.n	5f6 <__aeabi_dmul+0x206>
     5dc:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
     5e0:	bf18      	it	ne
     5e2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
     5e6:	d1d1      	bne.n	58c <__aeabi_dmul+0x19c>
     5e8:	ea81 0103 	eor.w	r1, r1, r3
     5ec:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
     5f0:	f04f 0000 	mov.w	r0, #0
     5f4:	bd70      	pop	{r4, r5, r6, pc}
     5f6:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
     5fa:	bf06      	itte	eq
     5fc:	4610      	moveq	r0, r2
     5fe:	4619      	moveq	r1, r3
     600:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
     604:	d019      	beq.n	63a <__aeabi_dmul+0x24a>
     606:	ea94 0f0c 	teq	r4, ip
     60a:	d102      	bne.n	612 <__aeabi_dmul+0x222>
     60c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
     610:	d113      	bne.n	63a <__aeabi_dmul+0x24a>
     612:	ea95 0f0c 	teq	r5, ip
     616:	d105      	bne.n	624 <__aeabi_dmul+0x234>
     618:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
     61c:	bf1c      	itt	ne
     61e:	4610      	movne	r0, r2
     620:	4619      	movne	r1, r3
     622:	d10a      	bne.n	63a <__aeabi_dmul+0x24a>
     624:	ea81 0103 	eor.w	r1, r1, r3
     628:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
     62c:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
     630:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
     634:	f04f 0000 	mov.w	r0, #0
     638:	bd70      	pop	{r4, r5, r6, pc}
     63a:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
     63e:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
     642:	bd70      	pop	{r4, r5, r6, pc}

00000644 <__aeabi_ddiv>:
     644:	b570      	push	{r4, r5, r6, lr}
     646:	f04f 0cff 	mov.w	ip, #255	; 0xff
     64a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
     64e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
     652:	bf1d      	ittte	ne
     654:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
     658:	ea94 0f0c 	teqne	r4, ip
     65c:	ea95 0f0c 	teqne	r5, ip
     660:	f000 f8a7 	bleq	7b2 <__aeabi_ddiv+0x16e>
     664:	eba4 0405 	sub.w	r4, r4, r5
     668:	ea81 0e03 	eor.w	lr, r1, r3
     66c:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
     670:	ea4f 3101 	mov.w	r1, r1, lsl #12
     674:	f000 8088 	beq.w	788 <__aeabi_ddiv+0x144>
     678:	ea4f 3303 	mov.w	r3, r3, lsl #12
     67c:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
     680:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
     684:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
     688:	ea4f 2202 	mov.w	r2, r2, lsl #8
     68c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
     690:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
     694:	ea4f 2600 	mov.w	r6, r0, lsl #8
     698:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
     69c:	429d      	cmp	r5, r3
     69e:	bf08      	it	eq
     6a0:	4296      	cmpeq	r6, r2
     6a2:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
     6a6:	f504 7440 	add.w	r4, r4, #768	; 0x300
     6aa:	d202      	bcs.n	6b2 <__aeabi_ddiv+0x6e>
     6ac:	085b      	lsrs	r3, r3, #1
     6ae:	ea4f 0232 	mov.w	r2, r2, rrx
     6b2:	1ab6      	subs	r6, r6, r2
     6b4:	eb65 0503 	sbc.w	r5, r5, r3
     6b8:	085b      	lsrs	r3, r3, #1
     6ba:	ea4f 0232 	mov.w	r2, r2, rrx
     6be:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
     6c2:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
     6c6:	ebb6 0e02 	subs.w	lr, r6, r2
     6ca:	eb75 0e03 	sbcs.w	lr, r5, r3
     6ce:	bf22      	ittt	cs
     6d0:	1ab6      	subcs	r6, r6, r2
     6d2:	4675      	movcs	r5, lr
     6d4:	ea40 000c 	orrcs.w	r0, r0, ip
     6d8:	085b      	lsrs	r3, r3, #1
     6da:	ea4f 0232 	mov.w	r2, r2, rrx
     6de:	ebb6 0e02 	subs.w	lr, r6, r2
     6e2:	eb75 0e03 	sbcs.w	lr, r5, r3
     6e6:	bf22      	ittt	cs
     6e8:	1ab6      	subcs	r6, r6, r2
     6ea:	4675      	movcs	r5, lr
     6ec:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
     6f0:	085b      	lsrs	r3, r3, #1
     6f2:	ea4f 0232 	mov.w	r2, r2, rrx
     6f6:	ebb6 0e02 	subs.w	lr, r6, r2
     6fa:	eb75 0e03 	sbcs.w	lr, r5, r3
     6fe:	bf22      	ittt	cs
     700:	1ab6      	subcs	r6, r6, r2
     702:	4675      	movcs	r5, lr
     704:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
     708:	085b      	lsrs	r3, r3, #1
     70a:	ea4f 0232 	mov.w	r2, r2, rrx
     70e:	ebb6 0e02 	subs.w	lr, r6, r2
     712:	eb75 0e03 	sbcs.w	lr, r5, r3
     716:	bf22      	ittt	cs
     718:	1ab6      	subcs	r6, r6, r2
     71a:	4675      	movcs	r5, lr
     71c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
     720:	ea55 0e06 	orrs.w	lr, r5, r6
     724:	d018      	beq.n	758 <__aeabi_ddiv+0x114>
     726:	ea4f 1505 	mov.w	r5, r5, lsl #4
     72a:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
     72e:	ea4f 1606 	mov.w	r6, r6, lsl #4
     732:	ea4f 03c3 	mov.w	r3, r3, lsl #3
     736:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
     73a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
     73e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
     742:	d1c0      	bne.n	6c6 <__aeabi_ddiv+0x82>
     744:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
     748:	d10b      	bne.n	762 <__aeabi_ddiv+0x11e>
     74a:	ea41 0100 	orr.w	r1, r1, r0
     74e:	f04f 0000 	mov.w	r0, #0
     752:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
     756:	e7b6      	b.n	6c6 <__aeabi_ddiv+0x82>
     758:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
     75c:	bf04      	itt	eq
     75e:	4301      	orreq	r1, r0
     760:	2000      	moveq	r0, #0
     762:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
     766:	bf88      	it	hi
     768:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
     76c:	f63f aeaf 	bhi.w	4ce <__aeabi_dmul+0xde>
     770:	ebb5 0c03 	subs.w	ip, r5, r3
     774:	bf04      	itt	eq
     776:	ebb6 0c02 	subseq.w	ip, r6, r2
     77a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
     77e:	f150 0000 	adcs.w	r0, r0, #0
     782:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
     786:	bd70      	pop	{r4, r5, r6, pc}
     788:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
     78c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
     790:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
     794:	bfc2      	ittt	gt
     796:	ebd4 050c 	rsbsgt	r5, r4, ip
     79a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
     79e:	bd70      	popgt	{r4, r5, r6, pc}
     7a0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
     7a4:	f04f 0e00 	mov.w	lr, #0
     7a8:	3c01      	subs	r4, #1
     7aa:	e690      	b.n	4ce <__aeabi_dmul+0xde>
     7ac:	ea45 0e06 	orr.w	lr, r5, r6
     7b0:	e68d      	b.n	4ce <__aeabi_dmul+0xde>
     7b2:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
     7b6:	ea94 0f0c 	teq	r4, ip
     7ba:	bf08      	it	eq
     7bc:	ea95 0f0c 	teqeq	r5, ip
     7c0:	f43f af3b 	beq.w	63a <__aeabi_dmul+0x24a>
     7c4:	ea94 0f0c 	teq	r4, ip
     7c8:	d10a      	bne.n	7e0 <__aeabi_ddiv+0x19c>
     7ca:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
     7ce:	f47f af34 	bne.w	63a <__aeabi_dmul+0x24a>
     7d2:	ea95 0f0c 	teq	r5, ip
     7d6:	f47f af25 	bne.w	624 <__aeabi_dmul+0x234>
     7da:	4610      	mov	r0, r2
     7dc:	4619      	mov	r1, r3
     7de:	e72c      	b.n	63a <__aeabi_dmul+0x24a>
     7e0:	ea95 0f0c 	teq	r5, ip
     7e4:	d106      	bne.n	7f4 <__aeabi_ddiv+0x1b0>
     7e6:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
     7ea:	f43f aefd 	beq.w	5e8 <__aeabi_dmul+0x1f8>
     7ee:	4610      	mov	r0, r2
     7f0:	4619      	mov	r1, r3
     7f2:	e722      	b.n	63a <__aeabi_dmul+0x24a>
     7f4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
     7f8:	bf18      	it	ne
     7fa:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
     7fe:	f47f aec5 	bne.w	58c <__aeabi_dmul+0x19c>
     802:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
     806:	f47f af0d 	bne.w	624 <__aeabi_dmul+0x234>
     80a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
     80e:	f47f aeeb 	bne.w	5e8 <__aeabi_dmul+0x1f8>
     812:	e712      	b.n	63a <__aeabi_dmul+0x24a>

00000814 <__gedf2>:
     814:	f04f 3cff 	mov.w	ip, #4294967295
     818:	e006      	b.n	828 <__cmpdf2+0x4>
     81a:	bf00      	nop

0000081c <__ledf2>:
     81c:	f04f 0c01 	mov.w	ip, #1
     820:	e002      	b.n	828 <__cmpdf2+0x4>
     822:	bf00      	nop

00000824 <__cmpdf2>:
     824:	f04f 0c01 	mov.w	ip, #1
     828:	f84d cd04 	str.w	ip, [sp, #-4]!
     82c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
     830:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
     834:	ea4f 0c43 	mov.w	ip, r3, lsl #1
     838:	bf18      	it	ne
     83a:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
     83e:	d01b      	beq.n	878 <__cmpdf2+0x54>
     840:	b001      	add	sp, #4
     842:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
     846:	bf0c      	ite	eq
     848:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
     84c:	ea91 0f03 	teqne	r1, r3
     850:	bf02      	ittt	eq
     852:	ea90 0f02 	teqeq	r0, r2
     856:	2000      	moveq	r0, #0
     858:	4770      	bxeq	lr
     85a:	f110 0f00 	cmn.w	r0, #0
     85e:	ea91 0f03 	teq	r1, r3
     862:	bf58      	it	pl
     864:	4299      	cmppl	r1, r3
     866:	bf08      	it	eq
     868:	4290      	cmpeq	r0, r2
     86a:	bf2c      	ite	cs
     86c:	17d8      	asrcs	r0, r3, #31
     86e:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
     872:	f040 0001 	orr.w	r0, r0, #1
     876:	4770      	bx	lr
     878:	ea4f 0c41 	mov.w	ip, r1, lsl #1
     87c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
     880:	d102      	bne.n	888 <__cmpdf2+0x64>
     882:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
     886:	d107      	bne.n	898 <__cmpdf2+0x74>
     888:	ea4f 0c43 	mov.w	ip, r3, lsl #1
     88c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
     890:	d1d6      	bne.n	840 <__cmpdf2+0x1c>
     892:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
     896:	d0d3      	beq.n	840 <__cmpdf2+0x1c>
     898:	f85d 0b04 	ldr.w	r0, [sp], #4
     89c:	4770      	bx	lr
     89e:	bf00      	nop

000008a0 <__aeabi_cdrcmple>:
     8a0:	4684      	mov	ip, r0
     8a2:	4610      	mov	r0, r2
     8a4:	4662      	mov	r2, ip
     8a6:	468c      	mov	ip, r1
     8a8:	4619      	mov	r1, r3
     8aa:	4663      	mov	r3, ip
     8ac:	e000      	b.n	8b0 <__aeabi_cdcmpeq>
     8ae:	bf00      	nop

000008b0 <__aeabi_cdcmpeq>:
     8b0:	b501      	push	{r0, lr}
     8b2:	f7ff ffb7 	bl	824 <__cmpdf2>
     8b6:	2800      	cmp	r0, #0
     8b8:	bf48      	it	mi
     8ba:	f110 0f00 	cmnmi.w	r0, #0
     8be:	bd01      	pop	{r0, pc}

000008c0 <__aeabi_dcmpeq>:
     8c0:	f84d ed08 	str.w	lr, [sp, #-8]!
     8c4:	f7ff fff4 	bl	8b0 <__aeabi_cdcmpeq>
     8c8:	bf0c      	ite	eq
     8ca:	2001      	moveq	r0, #1
     8cc:	2000      	movne	r0, #0
     8ce:	f85d fb08 	ldr.w	pc, [sp], #8
     8d2:	bf00      	nop

000008d4 <__aeabi_dcmplt>:
     8d4:	f84d ed08 	str.w	lr, [sp, #-8]!
     8d8:	f7ff ffea 	bl	8b0 <__aeabi_cdcmpeq>
     8dc:	bf34      	ite	cc
     8de:	2001      	movcc	r0, #1
     8e0:	2000      	movcs	r0, #0
     8e2:	f85d fb08 	ldr.w	pc, [sp], #8
     8e6:	bf00      	nop

000008e8 <__aeabi_dcmple>:
     8e8:	f84d ed08 	str.w	lr, [sp, #-8]!
     8ec:	f7ff ffe0 	bl	8b0 <__aeabi_cdcmpeq>
     8f0:	bf94      	ite	ls
     8f2:	2001      	movls	r0, #1
     8f4:	2000      	movhi	r0, #0
     8f6:	f85d fb08 	ldr.w	pc, [sp], #8
     8fa:	bf00      	nop

000008fc <__aeabi_dcmpge>:
     8fc:	f84d ed08 	str.w	lr, [sp, #-8]!
     900:	f7ff ffce 	bl	8a0 <__aeabi_cdrcmple>
     904:	bf94      	ite	ls
     906:	2001      	movls	r0, #1
     908:	2000      	movhi	r0, #0
     90a:	f85d fb08 	ldr.w	pc, [sp], #8
     90e:	bf00      	nop

00000910 <__aeabi_dcmpgt>:
     910:	f84d ed08 	str.w	lr, [sp, #-8]!
     914:	f7ff ffc4 	bl	8a0 <__aeabi_cdrcmple>
     918:	bf34      	ite	cc
     91a:	2001      	movcc	r0, #1
     91c:	2000      	movcs	r0, #0
     91e:	f85d fb08 	ldr.w	pc, [sp], #8
     922:	bf00      	nop

00000924 <__aeabi_d2uiz>:
     924:	004a      	lsls	r2, r1, #1
     926:	d211      	bcs.n	94c <__aeabi_d2uiz+0x28>
     928:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
     92c:	d211      	bcs.n	952 <__aeabi_d2uiz+0x2e>
     92e:	d50d      	bpl.n	94c <__aeabi_d2uiz+0x28>
     930:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
     934:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
     938:	d40e      	bmi.n	958 <__aeabi_d2uiz+0x34>
     93a:	ea4f 23c1 	mov.w	r3, r1, lsl #11
     93e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
     942:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
     946:	fa23 f002 	lsr.w	r0, r3, r2
     94a:	4770      	bx	lr
     94c:	f04f 0000 	mov.w	r0, #0
     950:	4770      	bx	lr
     952:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
     956:	d102      	bne.n	95e <__aeabi_d2uiz+0x3a>
     958:	f04f 30ff 	mov.w	r0, #4294967295
     95c:	4770      	bx	lr
     95e:	f04f 0000 	mov.w	r0, #0
     962:	4770      	bx	lr

00000964 <__aeabi_d2f>:
     964:	ea4f 0241 	mov.w	r2, r1, lsl #1
     968:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
     96c:	bf24      	itt	cs
     96e:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
     972:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
     976:	d90d      	bls.n	994 <__aeabi_d2f+0x30>
     978:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
     97c:	ea4f 02c0 	mov.w	r2, r0, lsl #3
     980:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
     984:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
     988:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
     98c:	bf08      	it	eq
     98e:	f020 0001 	biceq.w	r0, r0, #1
     992:	4770      	bx	lr
     994:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
     998:	d121      	bne.n	9de <__aeabi_d2f+0x7a>
     99a:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
     99e:	bfbc      	itt	lt
     9a0:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
     9a4:	4770      	bxlt	lr
     9a6:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
     9aa:	ea4f 5252 	mov.w	r2, r2, lsr #21
     9ae:	f1c2 0218 	rsb	r2, r2, #24
     9b2:	f1c2 0c20 	rsb	ip, r2, #32
     9b6:	fa10 f30c 	lsls.w	r3, r0, ip
     9ba:	fa20 f002 	lsr.w	r0, r0, r2
     9be:	bf18      	it	ne
     9c0:	f040 0001 	orrne.w	r0, r0, #1
     9c4:	ea4f 23c1 	mov.w	r3, r1, lsl #11
     9c8:	ea4f 23d3 	mov.w	r3, r3, lsr #11
     9cc:	fa03 fc0c 	lsl.w	ip, r3, ip
     9d0:	ea40 000c 	orr.w	r0, r0, ip
     9d4:	fa23 f302 	lsr.w	r3, r3, r2
     9d8:	ea4f 0343 	mov.w	r3, r3, lsl #1
     9dc:	e7cc      	b.n	978 <__aeabi_d2f+0x14>
     9de:	ea7f 5362 	mvns.w	r3, r2, asr #21
     9e2:	d107      	bne.n	9f4 <__aeabi_d2f+0x90>
     9e4:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
     9e8:	bf1e      	ittt	ne
     9ea:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
     9ee:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
     9f2:	4770      	bxne	lr
     9f4:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
     9f8:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
     9fc:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
     a00:	4770      	bx	lr
     a02:	bf00      	nop

00000a04 <am_devices_led_array_init>:
void
am_devices_led_array_init(am_devices_led_t *psLEDs, uint32_t ui32NumLEDs)
{
    uint32_t i;

    if ( (psLEDs == NULL)                       ||
     a04:	2800      	cmp	r0, #0
     a06:	f000 80a8 	beq.w	b5a <am_devices_led_array_init+0x156>
    }

    //
    // Loop through the list of LEDs, configuring each one individually.
    //
    for ( i = 0; i < ui32NumLEDs; i++ )
     a0a:	1e4b      	subs	r3, r1, #1
     a0c:	2b1e      	cmp	r3, #30
     a0e:	f200 80a4 	bhi.w	b5a <am_devices_led_array_init+0x156>
{
     a12:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        am_hal_gpio_pin_config(psLED->ui32GPIONumber, AM_HAL_GPIO_3STATE);
     a16:	4d51      	ldr	r5, [pc, #324]	; (b5c <am_devices_led_array_init+0x158>)
     a18:	4c51      	ldr	r4, [pc, #324]	; (b60 <am_devices_led_array_init+0x15c>)
        am_hal_gpio_out_bit_replace(psLED->ui32GPIONumber,
     a1a:	4e52      	ldr	r6, [pc, #328]	; (b64 <am_devices_led_array_init+0x160>)
     a1c:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
     a20:	1d02      	adds	r2, r0, #4
        am_hal_gpio_pin_config(psLED->ui32GPIONumber, AM_HAL_GPIO_3STATE);
     a22:	f04f 0cff 	mov.w	ip, #255	; 0xff
     a26:	f04f 0e18 	mov.w	lr, #24
    if ( (psLED == NULL)    ||
     a2a:	2800      	cmp	r0, #0
     a2c:	d05f      	beq.n	aee <am_devices_led_array_init+0xea>
     a2e:	f852 7c04 	ldr.w	r7, [r2, #-4]
     a32:	2f31      	cmp	r7, #49	; 0x31
     a34:	d85b      	bhi.n	aee <am_devices_led_array_init+0xea>
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLED->ui32Polarity )
     a36:	6843      	ldr	r3, [r0, #4]
        am_hal_gpio_pin_config(psLED->ui32GPIONumber, AM_HAL_GPIO_OUTPUT);
     a38:	2773      	movs	r7, #115	; 0x73
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLED->ui32Polarity )
     a3a:	f013 0802 	ands.w	r8, r3, #2
        am_hal_gpio_pin_config(psLED->ui32GPIONumber, AM_HAL_GPIO_OUTPUT);
     a3e:	602f      	str	r7, [r5, #0]
     a40:	f852 3c04 	ldr.w	r3, [r2, #-4]
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLED->ui32Polarity )
     a44:	d05a      	beq.n	afc <am_devices_led_array_init+0xf8>
        am_hal_gpio_pin_config(psLED->ui32GPIONumber, AM_HAL_GPIO_OUTPUT);
     a46:	085f      	lsrs	r7, r3, #1
     a48:	f007 097c 	and.w	r9, r7, #124	; 0x7c
     a4c:	009b      	lsls	r3, r3, #2
     a4e:	f859 8004 	ldr.w	r8, [r9, r4]
     a52:	f003 031c 	and.w	r3, r3, #28
     a56:	f04f 0a07 	mov.w	sl, #7
     a5a:	fa0a f703 	lsl.w	r7, sl, r3
     a5e:	f04f 0b02 	mov.w	fp, #2
     a62:	fa0b f303 	lsl.w	r3, fp, r3
     a66:	ea28 0707 	bic.w	r7, r8, r7
     a6a:	431f      	orrs	r7, r3
     a6c:	f849 7004 	str.w	r7, [r9, r4]
     a70:	f852 3c04 	ldr.w	r3, [r2, #-4]
     a74:	f003 09fc 	and.w	r9, r3, #252	; 0xfc
     a78:	f109 4880 	add.w	r8, r9, #1073741824	; 0x40000000
     a7c:	f508 3b80 	add.w	fp, r8, #65536	; 0x10000
     a80:	00df      	lsls	r7, r3, #3
     a82:	f007 0318 	and.w	r3, r7, #24
     a86:	f8db 9000 	ldr.w	r9, [fp]
     a8a:	fa0c f703 	lsl.w	r7, ip, r3
     a8e:	ea29 0707 	bic.w	r7, r9, r7
     a92:	fa0e fa03 	lsl.w	sl, lr, r3
     a96:	ea47 030a 	orr.w	r3, r7, sl
     a9a:	f04f 0800 	mov.w	r8, #0
     a9e:	f8cb 3000 	str.w	r3, [fp]
     aa2:	f8c5 8000 	str.w	r8, [r5]
        am_hal_gpio_out_enable_bit_clear(psLED->ui32GPIONumber);
     aa6:	f852 7c04 	ldr.w	r7, [r2, #-4]
     aaa:	f04f 0901 	mov.w	r9, #1
     aae:	08fb      	lsrs	r3, r7, #3
     ab0:	f007 071f 	and.w	r7, r7, #31
     ab4:	f003 0b04 	and.w	fp, r3, #4
     ab8:	fa09 f307 	lsl.w	r3, r9, r7
     abc:	4f2a      	ldr	r7, [pc, #168]	; (b68 <am_devices_led_array_init+0x164>)
     abe:	f84b 3007 	str.w	r3, [fp, r7]
        am_hal_gpio_out_bit_replace(psLED->ui32GPIONumber,
     ac2:	f852 3c04 	ldr.w	r3, [r2, #-4]
     ac6:	08df      	lsrs	r7, r3, #3
     ac8:	f007 0a04 	and.w	sl, r7, #4
     acc:	6847      	ldr	r7, [r0, #4]
     ace:	f003 081f 	and.w	r8, r3, #31
     ad2:	07ff      	lsls	r7, r7, #31
     ad4:	f85a 3006 	ldr.w	r3, [sl, r6]
     ad8:	bf4b      	itete	mi
     ada:	fa09 f908 	lslmi.w	r9, r9, r8
     ade:	fa09 f808 	lslpl.w	r8, r9, r8
     ae2:	ea49 0303 	orrmi.w	r3, r9, r3
     ae6:	ea23 0308 	bicpl.w	r3, r3, r8
     aea:	f84a 3006 	str.w	r3, [sl, r6]
     aee:	3008      	adds	r0, #8
    for ( i = 0; i < ui32NumLEDs; i++ )
     af0:	4288      	cmp	r0, r1
     af2:	f102 0208 	add.w	r2, r2, #8
     af6:	d198      	bne.n	a2a <am_devices_led_array_init+0x26>
     af8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        am_hal_gpio_pin_config(psLED->ui32GPIONumber, AM_HAL_GPIO_3STATE);
     afc:	085f      	lsrs	r7, r3, #1
     afe:	f007 0a7c 	and.w	sl, r7, #124	; 0x7c
     b02:	009b      	lsls	r3, r3, #2
     b04:	f85a 9004 	ldr.w	r9, [sl, r4]
     b08:	f003 031c 	and.w	r3, r3, #28
     b0c:	f04f 0b07 	mov.w	fp, #7
     b10:	fa0b f703 	lsl.w	r7, fp, r3
     b14:	f04f 0b06 	mov.w	fp, #6
     b18:	fa0b f303 	lsl.w	r3, fp, r3
     b1c:	ea29 0907 	bic.w	r9, r9, r7
     b20:	ea49 0703 	orr.w	r7, r9, r3
     b24:	f84a 7004 	str.w	r7, [sl, r4]
     b28:	f852 3c04 	ldr.w	r3, [r2, #-4]
     b2c:	f003 0afc 	and.w	sl, r3, #252	; 0xfc
     b30:	f10a 4980 	add.w	r9, sl, #1073741824	; 0x40000000
     b34:	f509 3780 	add.w	r7, r9, #65536	; 0x10000
     b38:	00db      	lsls	r3, r3, #3
     b3a:	f8d7 a000 	ldr.w	sl, [r7]
     b3e:	f003 0918 	and.w	r9, r3, #24
     b42:	fa0c f309 	lsl.w	r3, ip, r9
     b46:	ea2a 0b03 	bic.w	fp, sl, r3
     b4a:	fa0e f909 	lsl.w	r9, lr, r9
     b4e:	ea4b 0309 	orr.w	r3, fp, r9
     b52:	603b      	str	r3, [r7, #0]
     b54:	f8c5 8000 	str.w	r8, [r5]
     b58:	e7a5      	b.n	aa6 <am_devices_led_array_init+0xa2>
     b5a:	4770      	bx	lr
     b5c:	40010060 	.word	0x40010060
     b60:	40010040 	.word	0x40010040
     b64:	40010088 	.word	0x40010088
     b68:	400100b4 	.word	0x400100b4

00000b6c <am_devices_led_on>:
//
//*****************************************************************************
void
am_devices_led_on(am_devices_led_t *psLEDs, uint32_t ui32LEDNum)
{
    if ( (psLEDs == NULL)                       ||
     b6c:	b1f0      	cbz	r0, bac <am_devices_led_on+0x40>
     b6e:	291e      	cmp	r1, #30
     b70:	d81c      	bhi.n	bac <am_devices_led_on+0x40>
         (ui32LEDNum >= MAX_LEDS)               ||
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
     b72:	f850 3031 	ldr.w	r3, [r0, r1, lsl #3]
         (ui32LEDNum >= MAX_LEDS)               ||
     b76:	2b31      	cmp	r3, #49	; 0x31
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
     b78:	eb00 00c1 	add.w	r0, r0, r1, lsl #3
         (ui32LEDNum >= MAX_LEDS)               ||
     b7c:	d816      	bhi.n	bac <am_devices_led_on+0x40>
    }
#else // AM_APOLLO3_GPIO
    //
    // Handle Direct Drive Versus 3-State (with pull-up or no buffer).
    //
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
     b7e:	6842      	ldr	r2, [r0, #4]
     b80:	0791      	lsls	r1, r2, #30
     b82:	d514      	bpl.n	bae <am_devices_led_on+0x42>
{
     b84:	b410      	push	{r4}
    {
        //
        // Set the output to the correct state for the LED.
        //
        am_hal_gpio_out_bit_replace(psLEDs[ui32LEDNum].ui32GPIONumber,
     b86:	07d2      	lsls	r2, r2, #31
     b88:	ea4f 04d3 	mov.w	r4, r3, lsr #3
     b8c:	f004 0c04 	and.w	ip, r4, #4
     b90:	4811      	ldr	r0, [pc, #68]	; (bd8 <am_devices_led_on+0x6c>)
     b92:	f003 031f 	and.w	r3, r3, #31
     b96:	d516      	bpl.n	bc6 <am_devices_led_on+0x5a>
     b98:	2101      	movs	r1, #1
     b9a:	f85c 2000 	ldr.w	r2, [ip, r0]
     b9e:	fa01 f303 	lsl.w	r3, r1, r3
     ba2:	4313      	orrs	r3, r2
     ba4:	f84c 3000 	str.w	r3, [ip, r0]
        // Turn on the output driver for the LED.
        //
        am_hal_gpio_out_enable_bit_set(psLEDs[ui32LEDNum].ui32GPIONumber);
    }
#endif //AM_APOLLO3_GPIO
}
     ba8:	f85d 4b04 	ldr.w	r4, [sp], #4
     bac:	4770      	bx	lr
        am_hal_gpio_out_enable_bit_set(psLEDs[ui32LEDNum].ui32GPIONumber);
     bae:	08d9      	lsrs	r1, r3, #3
     bb0:	f001 0c04 	and.w	ip, r1, #4
     bb4:	f003 031f 	and.w	r3, r3, #31
     bb8:	2201      	movs	r2, #1
     bba:	4808      	ldr	r0, [pc, #32]	; (bdc <am_devices_led_on+0x70>)
     bbc:	fa02 f103 	lsl.w	r1, r2, r3
     bc0:	f84c 1000 	str.w	r1, [ip, r0]
     bc4:	4770      	bx	lr
        am_hal_gpio_out_bit_replace(psLEDs[ui32LEDNum].ui32GPIONumber,
     bc6:	2101      	movs	r1, #1
     bc8:	f85c 2000 	ldr.w	r2, [ip, r0]
     bcc:	fa01 f403 	lsl.w	r4, r1, r3
     bd0:	ea22 0304 	bic.w	r3, r2, r4
     bd4:	e7e6      	b.n	ba4 <am_devices_led_on+0x38>
     bd6:	bf00      	nop
     bd8:	40010088 	.word	0x40010088
     bdc:	400100a8 	.word	0x400100a8

00000be0 <am_systick_isr>:
am_systick_isr(void)
{
    //
    // Add enough cycles to account for one full cycle of systick.
    //
    g_ui32SysTickWrappedTime += 0x01000000;
     be0:	4a02      	ldr	r2, [pc, #8]	; (bec <am_systick_isr+0xc>)
     be2:	6813      	ldr	r3, [r2, #0]
     be4:	f103 7080 	add.w	r0, r3, #16777216	; 0x1000000
     be8:	6010      	str	r0, [r2, #0]
     bea:	4770      	bx	lr
     bec:	10001048 	.word	0x10001048

00000bf0 <core_list_mergesort.constprop.2>:
    Note:
    We have a special header for the list that will always be first,
    but the algorithm could theoretically modify where the list starts.

 */
list_head *core_list_mergesort(list_head *list, list_cmp cmp, core_results *res) {
     bf0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    list_head *p, *q, *e, *tail;
    ee_s32 insize, nmerges, psize, qsize, i;

    insize = 1;
     bf4:	f04f 0c01 	mov.w	ip, #1
        list = NULL;
        tail = NULL;

        nmerges = 0;  /* count number of merges we do in this pass */

        while (p) {
     bf8:	f04f 0900 	mov.w	r9, #0
     bfc:	2800      	cmp	r0, #0
     bfe:	f000 8099 	beq.w	d34 <core_list_mergesort.constprop.2+0x144>
     c02:	f04f 0e00 	mov.w	lr, #0
     c06:	4671      	mov	r1, lr
     c08:	46f0      	mov	r8, lr
            /* step `insize' places along from p */
            q = p;
            psize = 0;
            for (i = 0; i < insize; i++) {
                psize++;
                q = q->next;
     c0a:	6803      	ldr	r3, [r0, #0]
     c0c:	f10c 32ff 	add.w	r2, ip, #4294967295
            nmerges++;  /* there exists a merge to be done */
     c10:	f108 0801 	add.w	r8, r8, #1
     c14:	f002 0507 	and.w	r5, r2, #7
                psize++;
     c18:	2401      	movs	r4, #1
                if (!q) break;
     c1a:	2b00      	cmp	r3, #0
     c1c:	d03f      	beq.n	c9e <core_list_mergesort.constprop.2+0xae>
            for (i = 0; i < insize; i++) {
     c1e:	4564      	cmp	r4, ip
     c20:	d03d      	beq.n	c9e <core_list_mergesort.constprop.2+0xae>
     c22:	b315      	cbz	r5, c6a <core_list_mergesort.constprop.2+0x7a>
     c24:	2d01      	cmp	r5, #1
     c26:	d01b      	beq.n	c60 <core_list_mergesort.constprop.2+0x70>
     c28:	2d02      	cmp	r5, #2
     c2a:	d016      	beq.n	c5a <core_list_mergesort.constprop.2+0x6a>
     c2c:	2d03      	cmp	r5, #3
     c2e:	d011      	beq.n	c54 <core_list_mergesort.constprop.2+0x64>
     c30:	2d04      	cmp	r5, #4
     c32:	d00c      	beq.n	c4e <core_list_mergesort.constprop.2+0x5e>
     c34:	2d05      	cmp	r5, #5
     c36:	d007      	beq.n	c48 <core_list_mergesort.constprop.2+0x58>
     c38:	2d06      	cmp	r5, #6
     c3a:	d002      	beq.n	c42 <core_list_mergesort.constprop.2+0x52>
                q = q->next;
     c3c:	681b      	ldr	r3, [r3, #0]
                psize++;
     c3e:	2402      	movs	r4, #2
                if (!q) break;
     c40:	b36b      	cbz	r3, c9e <core_list_mergesort.constprop.2+0xae>
                q = q->next;
     c42:	681b      	ldr	r3, [r3, #0]
                psize++;
     c44:	3401      	adds	r4, #1
                if (!q) break;
     c46:	b353      	cbz	r3, c9e <core_list_mergesort.constprop.2+0xae>
                q = q->next;
     c48:	681b      	ldr	r3, [r3, #0]
                psize++;
     c4a:	3401      	adds	r4, #1
                if (!q) break;
     c4c:	b33b      	cbz	r3, c9e <core_list_mergesort.constprop.2+0xae>
                q = q->next;
     c4e:	681b      	ldr	r3, [r3, #0]
                psize++;
     c50:	3401      	adds	r4, #1
                if (!q) break;
     c52:	b323      	cbz	r3, c9e <core_list_mergesort.constprop.2+0xae>
                q = q->next;
     c54:	681b      	ldr	r3, [r3, #0]
                psize++;
     c56:	3401      	adds	r4, #1
                if (!q) break;
     c58:	b30b      	cbz	r3, c9e <core_list_mergesort.constprop.2+0xae>
                q = q->next;
     c5a:	681b      	ldr	r3, [r3, #0]
                psize++;
     c5c:	3401      	adds	r4, #1
                if (!q) break;
     c5e:	b1f3      	cbz	r3, c9e <core_list_mergesort.constprop.2+0xae>
                q = q->next;
     c60:	681b      	ldr	r3, [r3, #0]
                psize++;
     c62:	3401      	adds	r4, #1
                if (!q) break;
     c64:	b1db      	cbz	r3, c9e <core_list_mergesort.constprop.2+0xae>
            for (i = 0; i < insize; i++) {
     c66:	4564      	cmp	r4, ip
     c68:	d019      	beq.n	c9e <core_list_mergesort.constprop.2+0xae>
                q = q->next;
     c6a:	681b      	ldr	r3, [r3, #0]
                psize++;
     c6c:	3401      	adds	r4, #1
     c6e:	4626      	mov	r6, r4
                if (!q) break;
     c70:	b1ab      	cbz	r3, c9e <core_list_mergesort.constprop.2+0xae>
                q = q->next;
     c72:	681b      	ldr	r3, [r3, #0]
                psize++;
     c74:	3401      	adds	r4, #1
                if (!q) break;
     c76:	b193      	cbz	r3, c9e <core_list_mergesort.constprop.2+0xae>
                q = q->next;
     c78:	681b      	ldr	r3, [r3, #0]
                psize++;
     c7a:	1cb4      	adds	r4, r6, #2
                if (!q) break;
     c7c:	b17b      	cbz	r3, c9e <core_list_mergesort.constprop.2+0xae>
                q = q->next;
     c7e:	681b      	ldr	r3, [r3, #0]
                psize++;
     c80:	1cf4      	adds	r4, r6, #3
                if (!q) break;
     c82:	b163      	cbz	r3, c9e <core_list_mergesort.constprop.2+0xae>
                q = q->next;
     c84:	681b      	ldr	r3, [r3, #0]
                psize++;
     c86:	1d34      	adds	r4, r6, #4
                if (!q) break;
     c88:	b14b      	cbz	r3, c9e <core_list_mergesort.constprop.2+0xae>
                q = q->next;
     c8a:	681b      	ldr	r3, [r3, #0]
                psize++;
     c8c:	1d74      	adds	r4, r6, #5
                if (!q) break;
     c8e:	b133      	cbz	r3, c9e <core_list_mergesort.constprop.2+0xae>
                q = q->next;
     c90:	681b      	ldr	r3, [r3, #0]
                psize++;
     c92:	1db4      	adds	r4, r6, #6
                if (!q) break;
     c94:	b11b      	cbz	r3, c9e <core_list_mergesort.constprop.2+0xae>
                q = q->next;
     c96:	681b      	ldr	r3, [r3, #0]
                psize++;
     c98:	1df4      	adds	r4, r6, #7
                if (!q) break;
     c9a:	2b00      	cmp	r3, #0
     c9c:	d1e3      	bne.n	c66 <core_list_mergesort.constprop.2+0x76>

                /* add the next element to the merged list */
                if (tail) {
                    tail->next = e;
                } else {
                    list = e;
     c9e:	4665      	mov	r5, ip
            while (psize > 0 || (qsize > 0 && q)) {
     ca0:	b344      	cbz	r4, cf4 <core_list_mergesort.constprop.2+0x104>
                } else if (qsize == 0 || !q) {
     ca2:	b38d      	cbz	r5, d08 <core_list_mergesort.constprop.2+0x118>
     ca4:	b383      	cbz	r3, d08 <core_list_mergesort.constprop.2+0x118>
                } else if (cmp(p->info,q->info,res) <= 0) {
     ca6:	f8d0 a004 	ldr.w	sl, [r0, #4]
     caa:	685f      	ldr	r7, [r3, #4]
        a->data16 = (a->data16 & 0xff00) | (0x00ff & (a->data16>>8));
     cac:	f9ba 2000 	ldrsh.w	r2, [sl]
    return a->idx - b->idx;
     cb0:	f9ba 6002 	ldrsh.w	r6, [sl, #2]
        a->data16 = (a->data16 & 0xff00) | (0x00ff & (a->data16>>8));
     cb4:	f022 0bff 	bic.w	fp, r2, #255	; 0xff
     cb8:	f3c2 2207 	ubfx	r2, r2, #8, #8
     cbc:	ea4b 0b02 	orr.w	fp, fp, r2
     cc0:	f8aa b000 	strh.w	fp, [sl]
        b->data16 = (b->data16 & 0xff00) | (0x00ff & (b->data16>>8));
     cc4:	f9b7 2000 	ldrsh.w	r2, [r7]
    return a->idx - b->idx;
     cc8:	f9b7 b002 	ldrsh.w	fp, [r7, #2]
        b->data16 = (b->data16 & 0xff00) | (0x00ff & (b->data16>>8));
     ccc:	f022 0aff 	bic.w	sl, r2, #255	; 0xff
    return a->idx - b->idx;
     cd0:	eba6 060b 	sub.w	r6, r6, fp
        b->data16 = (b->data16 & 0xff00) | (0x00ff & (b->data16>>8));
     cd4:	f3c2 2207 	ubfx	r2, r2, #8, #8
     cd8:	ea4a 0b02 	orr.w	fp, sl, r2
                } else if (cmp(p->info,q->info,res) <= 0) {
     cdc:	2e00      	cmp	r6, #0
        b->data16 = (b->data16 & 0xff00) | (0x00ff & (b->data16>>8));
     cde:	f8a7 b000 	strh.w	fp, [r7]
                } else if (cmp(p->info,q->info,res) <= 0) {
     ce2:	dd11      	ble.n	d08 <core_list_mergesort.constprop.2+0x118>
                    e = q; q = q->next; qsize--;
     ce4:	461f      	mov	r7, r3
     ce6:	681b      	ldr	r3, [r3, #0]
     ce8:	3d01      	subs	r5, #1
                if (tail) {
     cea:	b151      	cbz	r1, d02 <core_list_mergesort.constprop.2+0x112>
                    tail->next = e;
     cec:	600f      	str	r7, [r1, #0]
                    list = e;
     cee:	4639      	mov	r1, r7
            while (psize > 0 || (qsize > 0 && q)) {
     cf0:	2c00      	cmp	r4, #0
     cf2:	d1d6      	bne.n	ca2 <core_list_mergesort.constprop.2+0xb2>
     cf4:	b165      	cbz	r5, d10 <core_list_mergesort.constprop.2+0x120>
     cf6:	b17b      	cbz	r3, d18 <core_list_mergesort.constprop.2+0x128>
                    e = q; q = q->next; qsize--;
     cf8:	461f      	mov	r7, r3
     cfa:	3d01      	subs	r5, #1
     cfc:	681b      	ldr	r3, [r3, #0]
                if (tail) {
     cfe:	2900      	cmp	r1, #0
     d00:	d1f4      	bne.n	cec <core_list_mergesort.constprop.2+0xfc>
                    list = e;
     d02:	46be      	mov	lr, r7
     d04:	4639      	mov	r1, r7
     d06:	e7f3      	b.n	cf0 <core_list_mergesort.constprop.2+0x100>
                    e = p; p = p->next; psize--;
     d08:	4607      	mov	r7, r0
     d0a:	3c01      	subs	r4, #1
     d0c:	6800      	ldr	r0, [r0, #0]
     d0e:	e7ec      	b.n	cea <core_list_mergesort.constprop.2+0xfa>
        while (p) {
     d10:	4618      	mov	r0, r3
     d12:	2b00      	cmp	r3, #0
     d14:	f47f af79 	bne.w	c0a <core_list_mergesort.constprop.2+0x1a>
        }

        tail->next = NULL;

        /* If we have done only one merge, we're finished. */
        if (nmerges <= 1)   /* allow for nmerges==0, the empty list case */
     d18:	f1b8 0f01 	cmp.w	r8, #1
        tail->next = NULL;
     d1c:	f8c1 9000 	str.w	r9, [r1]
        if (nmerges <= 1)   /* allow for nmerges==0, the empty list case */
     d20:	d102      	bne.n	d28 <core_list_mergesort.constprop.2+0x138>
        insize *= 2;
    }
#if COMPILER_REQUIRES_SORT_RETURN
    return list;
#endif
}
     d22:	4670      	mov	r0, lr
     d24:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        insize *= 2;
     d28:	4670      	mov	r0, lr
     d2a:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
        while (p) {
     d2e:	2800      	cmp	r0, #0
     d30:	f47f af67 	bne.w	c02 <core_list_mergesort.constprop.2+0x12>
        tail->next = NULL;
     d34:	6000      	str	r0, [r0, #0]
     d36:	deff      	udf	#255	; 0xff

00000d38 <core_bench_list>:
ee_u16 core_bench_list(core_results *res, ee_s16 finder_idx) {
     d38:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ee_s16 find_num=res->seed3;
     d3c:	f9b0 5004 	ldrsh.w	r5, [r0, #4]
    list_head *list=res->list;
     d40:	f8d0 b024 	ldr.w	fp, [r0, #36]	; 0x24
ee_u16 core_bench_list(core_results *res, ee_s16 finder_idx) {
     d44:	b08d      	sub	sp, #52	; 0x34
    for (i=0; i<find_num; i++) {
     d46:	2d00      	cmp	r5, #0
ee_u16 core_bench_list(core_results *res, ee_s16 finder_idx) {
     d48:	9003      	str	r0, [sp, #12]
     d4a:	468c      	mov	ip, r1
    for (i=0; i<find_num; i++) {
     d4c:	f340 8215 	ble.w	117a <core_bench_list+0x442>
     d50:	2000      	movs	r0, #0
     d52:	4604      	mov	r4, r0
     d54:	4602      	mov	r2, r0
        while (list && (list->info->idx != info->idx))
     d56:	4686      	mov	lr, r0
    for (i=0; i<find_num; i++) {
     d58:	460f      	mov	r7, r1
     d5a:	4681      	mov	r9, r0
     d5c:	46aa      	mov	sl, r5
     d5e:	465b      	mov	r3, fp
     d60:	4688      	mov	r8, r1
    if (info->idx>=0) {
     d62:	2f00      	cmp	r7, #0
        info.data16= (i & 0xff) ;
     d64:	fa5f fc80 	uxtb.w	ip, r0
    if (info->idx>=0) {
     d68:	f2c0 81d5 	blt.w	1116 <core_bench_list+0x3de>
        while (list && (list->info->idx != info->idx))
     d6c:	2b00      	cmp	r3, #0
     d6e:	f000 81e2 	beq.w	1136 <core_bench_list+0x3fe>
     d72:	685d      	ldr	r5, [r3, #4]
     d74:	f9b5 b002 	ldrsh.w	fp, [r5, #2]
     d78:	45bb      	cmp	fp, r7
     d7a:	461d      	mov	r5, r3
     d7c:	d105      	bne.n	d8a <core_bench_list+0x52>
     d7e:	e007      	b.n	d90 <core_bench_list+0x58>
     d80:	6869      	ldr	r1, [r5, #4]
     d82:	f9b1 6002 	ldrsh.w	r6, [r1, #2]
     d86:	42be      	cmp	r6, r7
     d88:	d002      	beq.n	d90 <core_bench_list+0x58>
            list=list->next;
     d8a:	682d      	ldr	r5, [r5, #0]
        while (list && (list->info->idx != info->idx))
     d8c:	2d00      	cmp	r5, #0
     d8e:	d1f7      	bne.n	d80 <core_bench_list+0x48>
     d90:	2600      	movs	r6, #0
     d92:	e001      	b.n	d98 <core_bench_list+0x60>
    while (list) {
     d94:	461e      	mov	r6, r3
     d96:	460b      	mov	r3, r1
        tmp=list->next;
     d98:	6819      	ldr	r1, [r3, #0]
        list->next=next;
     d9a:	601e      	str	r6, [r3, #0]
    while (list) {
     d9c:	2900      	cmp	r1, #0
     d9e:	d1f9      	bne.n	d94 <core_bench_list+0x5c>
        if (this_find==NULL) {
     da0:	2d00      	cmp	r5, #0
     da2:	f000 81cb 	beq.w	113c <core_bench_list+0x404>
            if (this_find->info->data16 & 0x1) /* use found value */
     da6:	686e      	ldr	r6, [r5, #4]
     da8:	f9b6 b000 	ldrsh.w	fp, [r6]
            found++;
     dac:	3401      	adds	r4, #1
            if (this_find->info->data16 & 0x1) /* use found value */
     dae:	ea5f 76cb 	movs.w	r6, fp, lsl #31
            found++;
     db2:	b2a4      	uxth	r4, r4
            if (this_find->info->data16 & 0x1) /* use found value */
     db4:	d503      	bpl.n	dbe <core_bench_list+0x86>
                retval+=(this_find->info->data16 >> 9) & 1;
     db6:	f3cb 2140 	ubfx	r1, fp, #9, #1
     dba:	440a      	add	r2, r1
     dbc:	b292      	uxth	r2, r2
            if (this_find->next != NULL) {
     dbe:	6829      	ldr	r1, [r5, #0]
     dc0:	b121      	cbz	r1, dcc <core_bench_list+0x94>
                this_find->next = finder->next;
     dc2:	680e      	ldr	r6, [r1, #0]
     dc4:	602e      	str	r6, [r5, #0]
                finder->next=list->next;
     dc6:	681d      	ldr	r5, [r3, #0]
     dc8:	600d      	str	r5, [r1, #0]
                list->next=finder;
     dca:	6019      	str	r1, [r3, #0]
        if (info.idx>=0)
     dcc:	2f00      	cmp	r7, #0
     dce:	f100 0001 	add.w	r0, r0, #1
            info.idx++;
     dd2:	bfa8      	it	ge
     dd4:	3701      	addge	r7, #1
    for (i=0; i<find_num; i++) {
     dd6:	b201      	sxth	r1, r0
            info.idx++;
     dd8:	bfa8      	it	ge
     dda:	b23f      	sxthge	r7, r7
    for (i=0; i<find_num; i++) {
     ddc:	458a      	cmp	sl, r1
     dde:	dcc0      	bgt.n	d62 <core_bench_list+0x2a>
     de0:	ebc9 0084 	rsb	r0, r9, r4, lsl #2
     de4:	4402      	add	r2, r0
     de6:	970a      	str	r7, [sp, #40]	; 0x28
     de8:	b297      	uxth	r7, r2
     dea:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
     dee:	469b      	mov	fp, r3
     df0:	46c4      	mov	ip, r8
     df2:	9709      	str	r7, [sp, #36]	; 0x24
    if (finder_idx>0)
     df4:	f1bc 0f00 	cmp.w	ip, #0
     df8:	f340 8146 	ble.w	1088 <core_bench_list+0x350>
                retval=core_bench_matrix(&(res->mat),dtype,res->crc);
     dfc:	9c03      	ldr	r4, [sp, #12]
     dfe:	f8cd b014 	str.w	fp, [sp, #20]
     e02:	2301      	movs	r3, #1
     e04:	4622      	mov	r2, r4
     e06:	9306      	str	r3, [sp, #24]
     e08:	3228      	adds	r2, #40	; 0x28
     e0a:	9b05      	ldr	r3, [sp, #20]
     e0c:	9207      	str	r2, [sp, #28]
    if (finder_idx>0)
     e0e:	46da      	mov	sl, fp
                retval=core_bench_matrix(&(res->mat),dtype,res->crc);
     e10:	46a3      	mov	fp, r4
        while (p) {
     e12:	2b00      	cmp	r3, #0
     e14:	f000 81b5 	beq.w	1182 <core_bench_list+0x44a>
     e18:	2600      	movs	r6, #0
     e1a:	9605      	str	r6, [sp, #20]
     e1c:	4637      	mov	r7, r6
     e1e:	9608      	str	r6, [sp, #32]
            nmerges++;  /* there exists a merge to be done */
     e20:	9808      	ldr	r0, [sp, #32]
     e22:	9d06      	ldr	r5, [sp, #24]
                q = q->next;
     e24:	f8da 4000 	ldr.w	r4, [sl]
     e28:	1e69      	subs	r1, r5, #1
            nmerges++;  /* there exists a merge to be done */
     e2a:	3001      	adds	r0, #1
     e2c:	9008      	str	r0, [sp, #32]
     e2e:	f001 0307 	and.w	r3, r1, #7
                psize++;
     e32:	f04f 0c01 	mov.w	ip, #1
                if (!q) break;
     e36:	2c00      	cmp	r4, #0
     e38:	d053      	beq.n	ee2 <core_bench_list+0x1aa>
            for (i = 0; i < insize; i++) {
     e3a:	9a06      	ldr	r2, [sp, #24]
     e3c:	4594      	cmp	ip, r2
     e3e:	d050      	beq.n	ee2 <core_bench_list+0x1aa>
     e40:	b36b      	cbz	r3, e9e <core_bench_list+0x166>
     e42:	2b01      	cmp	r3, #1
     e44:	d024      	beq.n	e90 <core_bench_list+0x158>
     e46:	2b02      	cmp	r3, #2
     e48:	d01e      	beq.n	e88 <core_bench_list+0x150>
     e4a:	2b03      	cmp	r3, #3
     e4c:	d018      	beq.n	e80 <core_bench_list+0x148>
     e4e:	2b04      	cmp	r3, #4
     e50:	d012      	beq.n	e78 <core_bench_list+0x140>
     e52:	2b05      	cmp	r3, #5
     e54:	d00b      	beq.n	e6e <core_bench_list+0x136>
     e56:	2b06      	cmp	r3, #6
     e58:	d004      	beq.n	e64 <core_bench_list+0x12c>
                q = q->next;
     e5a:	6824      	ldr	r4, [r4, #0]
                psize++;
     e5c:	f04f 0c02 	mov.w	ip, #2
                if (!q) break;
     e60:	2c00      	cmp	r4, #0
     e62:	d03e      	beq.n	ee2 <core_bench_list+0x1aa>
                q = q->next;
     e64:	6824      	ldr	r4, [r4, #0]
                psize++;
     e66:	f10c 0c01 	add.w	ip, ip, #1
                if (!q) break;
     e6a:	2c00      	cmp	r4, #0
     e6c:	d039      	beq.n	ee2 <core_bench_list+0x1aa>
                q = q->next;
     e6e:	6824      	ldr	r4, [r4, #0]
                psize++;
     e70:	f10c 0c01 	add.w	ip, ip, #1
                if (!q) break;
     e74:	2c00      	cmp	r4, #0
     e76:	d034      	beq.n	ee2 <core_bench_list+0x1aa>
                q = q->next;
     e78:	6824      	ldr	r4, [r4, #0]
                psize++;
     e7a:	f10c 0c01 	add.w	ip, ip, #1
                if (!q) break;
     e7e:	b384      	cbz	r4, ee2 <core_bench_list+0x1aa>
                q = q->next;
     e80:	6824      	ldr	r4, [r4, #0]
                psize++;
     e82:	f10c 0c01 	add.w	ip, ip, #1
                if (!q) break;
     e86:	b364      	cbz	r4, ee2 <core_bench_list+0x1aa>
                q = q->next;
     e88:	6824      	ldr	r4, [r4, #0]
                psize++;
     e8a:	f10c 0c01 	add.w	ip, ip, #1
                if (!q) break;
     e8e:	b344      	cbz	r4, ee2 <core_bench_list+0x1aa>
                q = q->next;
     e90:	6824      	ldr	r4, [r4, #0]
                psize++;
     e92:	f10c 0c01 	add.w	ip, ip, #1
                if (!q) break;
     e96:	b324      	cbz	r4, ee2 <core_bench_list+0x1aa>
            for (i = 0; i < insize; i++) {
     e98:	9e06      	ldr	r6, [sp, #24]
     e9a:	45b4      	cmp	ip, r6
     e9c:	d021      	beq.n	ee2 <core_bench_list+0x1aa>
                q = q->next;
     e9e:	6824      	ldr	r4, [r4, #0]
                psize++;
     ea0:	f10c 0c01 	add.w	ip, ip, #1
     ea4:	46e6      	mov	lr, ip
                if (!q) break;
     ea6:	b1e4      	cbz	r4, ee2 <core_bench_list+0x1aa>
                q = q->next;
     ea8:	6824      	ldr	r4, [r4, #0]
                psize++;
     eaa:	f10c 0c01 	add.w	ip, ip, #1
                if (!q) break;
     eae:	b1c4      	cbz	r4, ee2 <core_bench_list+0x1aa>
                q = q->next;
     eb0:	6824      	ldr	r4, [r4, #0]
                psize++;
     eb2:	f10e 0c02 	add.w	ip, lr, #2
                if (!q) break;
     eb6:	b1a4      	cbz	r4, ee2 <core_bench_list+0x1aa>
                q = q->next;
     eb8:	6824      	ldr	r4, [r4, #0]
                psize++;
     eba:	f10e 0c03 	add.w	ip, lr, #3
                if (!q) break;
     ebe:	b184      	cbz	r4, ee2 <core_bench_list+0x1aa>
                q = q->next;
     ec0:	6824      	ldr	r4, [r4, #0]
                psize++;
     ec2:	f10e 0c04 	add.w	ip, lr, #4
                if (!q) break;
     ec6:	b164      	cbz	r4, ee2 <core_bench_list+0x1aa>
                q = q->next;
     ec8:	6824      	ldr	r4, [r4, #0]
                psize++;
     eca:	f10e 0c05 	add.w	ip, lr, #5
                if (!q) break;
     ece:	b144      	cbz	r4, ee2 <core_bench_list+0x1aa>
                q = q->next;
     ed0:	6824      	ldr	r4, [r4, #0]
                psize++;
     ed2:	f10e 0c06 	add.w	ip, lr, #6
                if (!q) break;
     ed6:	b124      	cbz	r4, ee2 <core_bench_list+0x1aa>
                q = q->next;
     ed8:	6824      	ldr	r4, [r4, #0]
                psize++;
     eda:	f10e 0c07 	add.w	ip, lr, #7
                if (!q) break;
     ede:	2c00      	cmp	r4, #0
     ee0:	d1da      	bne.n	e98 <core_bench_list+0x160>
                    list = e;
     ee2:	f8dd 9018 	ldr.w	r9, [sp, #24]
     ee6:	4666      	mov	r6, ip
     ee8:	464d      	mov	r5, r9
            while (psize > 0 || (qsize > 0 && q)) {
     eea:	2e00      	cmp	r6, #0
     eec:	d06b      	beq.n	fc6 <core_bench_list+0x28e>
                } else if (qsize == 0 || !q) {
     eee:	2d00      	cmp	r5, #0
     ef0:	d075      	beq.n	fde <core_bench_list+0x2a6>
     ef2:	2c00      	cmp	r4, #0
     ef4:	d073      	beq.n	fde <core_bench_list+0x2a6>
                } else if (cmp(p->info,q->info,res) <= 0) {
     ef6:	f8da 9004 	ldr.w	r9, [sl, #4]
     efa:	6860      	ldr	r0, [r4, #4]
    ee_s16 data=*pdata;
     efc:	f9b9 8000 	ldrsh.w	r8, [r9]
                } else if (cmp(p->info,q->info,res) <= 0) {
     f00:	9003      	str	r0, [sp, #12]
    if (optype) /* if cached, use cache */
     f02:	f018 0f80 	tst.w	r8, #128	; 0x80
     f06:	d16f      	bne.n	fe8 <core_bench_list+0x2b0>
        ee_s16 dtype=((data>>3) & 0xf); /* bits 3-6 is specific data for the operation */
     f08:	f3c8 02c3 	ubfx	r2, r8, #3, #4
        switch (flag) {
     f0c:	f018 0007 	ands.w	r0, r8, #7
        dtype |= dtype << 4; /* replicate the lower 4 bits to get an 8b value */
     f10:	ea42 1102 	orr.w	r1, r2, r2, lsl #4
        switch (flag) {
     f14:	d074      	beq.n	1000 <core_bench_list+0x2c8>
     f16:	2801      	cmp	r0, #1
     f18:	d170      	bne.n	ffc <core_bench_list+0x2c4>
                retval=core_bench_matrix(&(res->mat),dtype,res->crc);
     f1a:	f8bb 2038 	ldrh.w	r2, [fp, #56]	; 0x38
     f1e:	9807      	ldr	r0, [sp, #28]
     f20:	f001 fe24 	bl	2b6c <core_bench_matrix>
                if (res->crcmatrix==0)
     f24:	f8bb 303c 	ldrh.w	r3, [fp, #60]	; 0x3c
                retval=core_bench_matrix(&(res->mat),dtype,res->crc);
     f28:	b202      	sxth	r2, r0
                if (res->crcmatrix==0)
     f2a:	b90b      	cbnz	r3, f30 <core_bench_list+0x1f8>
                    res->crcmatrix=retval;
     f2c:	f8ab 003c 	strh.w	r0, [fp, #60]	; 0x3c
        res->crc=crcu16(retval,res->crc);
     f30:	f8bb 1038 	ldrh.w	r1, [fp, #56]	; 0x38
     f34:	9204      	str	r2, [sp, #16]
     f36:	b290      	uxth	r0, r2
     f38:	f002 fb04 	bl	3544 <crcu16>
        retval &= 0x007f;
     f3c:	9904      	ldr	r1, [sp, #16]
        res->crc=crcu16(retval,res->crc);
     f3e:	f8ab 0038 	strh.w	r0, [fp, #56]	; 0x38
        *pdata = (data & 0xff00) | 0x0080 | retval; /* cache the result */
     f42:	f028 02ff 	bic.w	r2, r8, #255	; 0xff
     f46:	f042 0380 	orr.w	r3, r2, #128	; 0x80
        retval &= 0x007f;
     f4a:	f001 087f 	and.w	r8, r1, #127	; 0x7f
        *pdata = (data & 0xff00) | 0x0080 | retval; /* cache the result */
     f4e:	ea48 0203 	orr.w	r2, r8, r3
     f52:	9803      	ldr	r0, [sp, #12]
     f54:	f8a9 2000 	strh.w	r2, [r9]
    ee_s16 data=*pdata;
     f58:	f9b0 9000 	ldrsh.w	r9, [r0]
    if (optype) /* if cached, use cache */
     f5c:	f019 0f80 	tst.w	r9, #128	; 0x80
     f60:	d149      	bne.n	ff6 <core_bench_list+0x2be>
        ee_s16 dtype=((data>>3) & 0xf); /* bits 3-6 is specific data for the operation */
     f62:	f3c9 03c3 	ubfx	r3, r9, #3, #4
        switch (flag) {
     f66:	f019 0207 	ands.w	r2, r9, #7
        dtype |= dtype << 4; /* replicate the lower 4 bits to get an 8b value */
     f6a:	ea43 1103 	orr.w	r1, r3, r3, lsl #4
        switch (flag) {
     f6e:	d065      	beq.n	103c <core_bench_list+0x304>
     f70:	2a01      	cmp	r2, #1
     f72:	d161      	bne.n	1038 <core_bench_list+0x300>
                retval=core_bench_matrix(&(res->mat),dtype,res->crc);
     f74:	f8bb 2038 	ldrh.w	r2, [fp, #56]	; 0x38
     f78:	9807      	ldr	r0, [sp, #28]
     f7a:	f001 fdf7 	bl	2b6c <core_bench_matrix>
                if (res->crcmatrix==0)
     f7e:	f8bb 103c 	ldrh.w	r1, [fp, #60]	; 0x3c
                retval=core_bench_matrix(&(res->mat),dtype,res->crc);
     f82:	b202      	sxth	r2, r0
                if (res->crcmatrix==0)
     f84:	b909      	cbnz	r1, f8a <core_bench_list+0x252>
                    res->crcmatrix=retval;
     f86:	f8ab 003c 	strh.w	r0, [fp, #60]	; 0x3c
        res->crc=crcu16(retval,res->crc);
     f8a:	f8bb 1038 	ldrh.w	r1, [fp, #56]	; 0x38
     f8e:	9204      	str	r2, [sp, #16]
     f90:	b290      	uxth	r0, r2
     f92:	f002 fad7 	bl	3544 <crcu16>
        retval &= 0x007f;
     f96:	9904      	ldr	r1, [sp, #16]
        res->crc=crcu16(retval,res->crc);
     f98:	f8ab 0038 	strh.w	r0, [fp, #56]	; 0x38
        *pdata = (data & 0xff00) | 0x0080 | retval; /* cache the result */
     f9c:	f029 02ff 	bic.w	r2, r9, #255	; 0xff
     fa0:	f042 0380 	orr.w	r3, r2, #128	; 0x80
     fa4:	9803      	ldr	r0, [sp, #12]
        retval &= 0x007f;
     fa6:	f001 027f 	and.w	r2, r1, #127	; 0x7f
        *pdata = (data & 0xff00) | 0x0080 | retval; /* cache the result */
     faa:	4313      	orrs	r3, r2
     fac:	8003      	strh	r3, [r0, #0]
    return val1 - val2;
     fae:	eba8 0302 	sub.w	r3, r8, r2
                } else if (cmp(p->info,q->info,res) <= 0) {
     fb2:	2b00      	cmp	r3, #0
     fb4:	dd13      	ble.n	fde <core_bench_list+0x2a6>
                    e = q; q = q->next; qsize--;
     fb6:	4621      	mov	r1, r4
     fb8:	6824      	ldr	r4, [r4, #0]
     fba:	3d01      	subs	r5, #1
                if (tail) {
     fbc:	b167      	cbz	r7, fd8 <core_bench_list+0x2a0>
                    tail->next = e;
     fbe:	6039      	str	r1, [r7, #0]
                    list = e;
     fc0:	460f      	mov	r7, r1
            while (psize > 0 || (qsize > 0 && q)) {
     fc2:	2e00      	cmp	r6, #0
     fc4:	d193      	bne.n	eee <core_bench_list+0x1b6>
     fc6:	2d00      	cmp	r5, #0
     fc8:	d053      	beq.n	1072 <core_bench_list+0x33a>
     fca:	2c00      	cmp	r4, #0
     fcc:	d055      	beq.n	107a <core_bench_list+0x342>
                    e = q; q = q->next; qsize--;
     fce:	4621      	mov	r1, r4
     fd0:	3d01      	subs	r5, #1
     fd2:	6824      	ldr	r4, [r4, #0]
                if (tail) {
     fd4:	2f00      	cmp	r7, #0
     fd6:	d1f2      	bne.n	fbe <core_bench_list+0x286>
                    list = e;
     fd8:	9105      	str	r1, [sp, #20]
     fda:	460f      	mov	r7, r1
     fdc:	e7f1      	b.n	fc2 <core_bench_list+0x28a>
                    e = p; p = p->next; psize--;
     fde:	4651      	mov	r1, sl
     fe0:	3e01      	subs	r6, #1
     fe2:	f8da a000 	ldr.w	sl, [sl]
     fe6:	e7e9      	b.n	fbc <core_bench_list+0x284>
    ee_s16 data=*pdata;
     fe8:	f9b0 9000 	ldrsh.w	r9, [r0]
    if (optype) /* if cached, use cache */
     fec:	f019 0f80 	tst.w	r9, #128	; 0x80
        return (data & 0x007f);
     ff0:	f008 087f 	and.w	r8, r8, #127	; 0x7f
    if (optype) /* if cached, use cache */
     ff4:	d0b5      	beq.n	f62 <core_bench_list+0x22a>
        return (data & 0x007f);
     ff6:	f009 027f 	and.w	r2, r9, #127	; 0x7f
     ffa:	e7d8      	b.n	fae <core_bench_list+0x276>
        switch (flag) {
     ffc:	4642      	mov	r2, r8
     ffe:	e797      	b.n	f30 <core_bench_list+0x1f8>
                retval=core_bench_state(res->size,res->memblock[3],res->seed1,res->seed2,dtype,res->crc);
    1000:	f8db e014 	ldr.w	lr, [fp, #20]
    1004:	f8bb c038 	ldrh.w	ip, [fp, #56]	; 0x38
    1008:	f9bb 2000 	ldrsh.w	r2, [fp]
    100c:	f9bb 3002 	ldrsh.w	r3, [fp, #2]
    1010:	f8db 0018 	ldr.w	r0, [fp, #24]
    1014:	f8cd c004 	str.w	ip, [sp, #4]
    1018:	2922      	cmp	r1, #34	; 0x22
    101a:	bfb8      	it	lt
    101c:	2122      	movlt	r1, #34	; 0x22
    101e:	9100      	str	r1, [sp, #0]
    1020:	4671      	mov	r1, lr
    1022:	f002 f9ef 	bl	3404 <core_bench_state>
                if (res->crcstate==0)
    1026:	f8bb 103e 	ldrh.w	r1, [fp, #62]	; 0x3e
                retval=core_bench_state(res->size,res->memblock[3],res->seed1,res->seed2,dtype,res->crc);
    102a:	b202      	sxth	r2, r0
                if (res->crcstate==0)
    102c:	2900      	cmp	r1, #0
    102e:	f47f af7f 	bne.w	f30 <core_bench_list+0x1f8>
                    res->crcstate=retval;
    1032:	f8ab 003e 	strh.w	r0, [fp, #62]	; 0x3e
    1036:	e77b      	b.n	f30 <core_bench_list+0x1f8>
        switch (flag) {
    1038:	464a      	mov	r2, r9
    103a:	e7a6      	b.n	f8a <core_bench_list+0x252>
                retval=core_bench_state(res->size,res->memblock[3],res->seed1,res->seed2,dtype,res->crc);
    103c:	f8db e014 	ldr.w	lr, [fp, #20]
    1040:	f8bb c038 	ldrh.w	ip, [fp, #56]	; 0x38
    1044:	f9bb 3002 	ldrsh.w	r3, [fp, #2]
    1048:	f9bb 2000 	ldrsh.w	r2, [fp]
    104c:	f8db 0018 	ldr.w	r0, [fp, #24]
    1050:	f8cd c004 	str.w	ip, [sp, #4]
    1054:	2922      	cmp	r1, #34	; 0x22
    1056:	bfb8      	it	lt
    1058:	2122      	movlt	r1, #34	; 0x22
    105a:	9100      	str	r1, [sp, #0]
    105c:	4671      	mov	r1, lr
    105e:	f002 f9d1 	bl	3404 <core_bench_state>
                if (res->crcstate==0)
    1062:	f8bb 303e 	ldrh.w	r3, [fp, #62]	; 0x3e
                retval=core_bench_state(res->size,res->memblock[3],res->seed1,res->seed2,dtype,res->crc);
    1066:	b202      	sxth	r2, r0
                if (res->crcstate==0)
    1068:	2b00      	cmp	r3, #0
    106a:	d18e      	bne.n	f8a <core_bench_list+0x252>
                    res->crcstate=retval;
    106c:	f8ab 003e 	strh.w	r0, [fp, #62]	; 0x3e
    1070:	e78b      	b.n	f8a <core_bench_list+0x252>
        while (p) {
    1072:	46a2      	mov	sl, r4
    1074:	2c00      	cmp	r4, #0
    1076:	f47f aed3 	bne.w	e20 <core_bench_list+0xe8>
        tail->next = NULL;
    107a:	2500      	movs	r5, #0
    107c:	603d      	str	r5, [r7, #0]
        if (nmerges <= 1)   /* allow for nmerges==0, the empty list case */
    107e:	9f08      	ldr	r7, [sp, #32]
    1080:	2f01      	cmp	r7, #1
    1082:	d173      	bne.n	116c <core_bench_list+0x434>
    1084:	f8dd b014 	ldr.w	fp, [sp, #20]
    remover=core_list_remove(list->next);
    1088:	f8db 6000 	ldr.w	r6, [fp]
    if (info->idx>=0) {
    108c:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    list_head *ret=item->next;
    108e:	6835      	ldr	r5, [r6, #0]
    tmp=item->info;
    1090:	6872      	ldr	r2, [r6, #4]
    item->next=item->next->next;
    1092:	e895 0003 	ldmia.w	r5, {r0, r1}
    ret->next=NULL;
    1096:	2400      	movs	r4, #0
    if (info->idx>=0) {
    1098:	42a7      	cmp	r7, r4
    item->info=ret->info;
    109a:	6071      	str	r1, [r6, #4]
    ret->info=tmp;
    109c:	606a      	str	r2, [r5, #4]
    item->next=item->next->next;
    109e:	6030      	str	r0, [r6, #0]
    ret->next=NULL;
    10a0:	602c      	str	r4, [r5, #0]
    if (info->idx>=0) {
    10a2:	db57      	blt.n	1154 <core_bench_list+0x41c>
    10a4:	46be      	mov	lr, r7
    10a6:	465c      	mov	r4, fp
        while (list && (list->info->idx != info->idx))
    10a8:	6863      	ldr	r3, [r4, #4]
    10aa:	f9b3 6002 	ldrsh.w	r6, [r3, #2]
    10ae:	4576      	cmp	r6, lr
    10b0:	d006      	beq.n	10c0 <core_bench_list+0x388>
            list=list->next;
    10b2:	6824      	ldr	r4, [r4, #0]
        while (list && (list->info->idx != info->idx))
    10b4:	2c00      	cmp	r4, #0
    10b6:	d1f7      	bne.n	10a8 <core_bench_list+0x370>
        finder=list->next;
    10b8:	f8db 7000 	ldr.w	r7, [fp]
    10bc:	463c      	mov	r4, r7
    while (finder) {
    10be:	b177      	cbz	r7, 10de <core_bench_list+0x3a6>
    10c0:	9909      	ldr	r1, [sp, #36]	; 0x24
        retval=crc16(list->info->data16,retval);
    10c2:	f8db 0004 	ldr.w	r0, [fp, #4]
    10c6:	f9b0 0000 	ldrsh.w	r0, [r0]
    10ca:	f002 fc03 	bl	38d4 <crc16>
        finder=finder->next;
    10ce:	6824      	ldr	r4, [r4, #0]
        retval=crc16(list->info->data16,retval);
    10d0:	4601      	mov	r1, r0
    while (finder) {
    10d2:	2c00      	cmp	r4, #0
    10d4:	d1f5      	bne.n	10c2 <core_bench_list+0x38a>
    10d6:	686a      	ldr	r2, [r5, #4]
    10d8:	f8db 7000 	ldr.w	r7, [fp]
    10dc:	9009      	str	r0, [sp, #36]	; 0x24
    item_removed->info=item_modified->info;
    10de:	687b      	ldr	r3, [r7, #4]
    item_removed->next=item_modified->next;
    10e0:	6839      	ldr	r1, [r7, #0]
    item_removed->info=item_modified->info;
    10e2:	606b      	str	r3, [r5, #4]
    list=core_list_mergesort(list,cmp_idx,NULL);
    10e4:	4658      	mov	r0, fp
    item_modified->info=tmp;
    10e6:	607a      	str	r2, [r7, #4]
    item_removed->next=item_modified->next;
    10e8:	6029      	str	r1, [r5, #0]
    item_modified->next=item_removed;
    10ea:	603d      	str	r5, [r7, #0]
    list=core_list_mergesort(list,cmp_idx,NULL);
    10ec:	f7ff fd80 	bl	bf0 <core_list_mergesort.constprop.2>
    finder=list->next;
    10f0:	6805      	ldr	r5, [r0, #0]
    list=core_list_mergesort(list,cmp_idx,NULL);
    10f2:	4681      	mov	r9, r0
    while (finder) {
    10f4:	b15d      	cbz	r5, 110e <core_bench_list+0x3d6>
    10f6:	9909      	ldr	r1, [sp, #36]	; 0x24
        retval=crc16(list->info->data16,retval);
    10f8:	f8d9 6004 	ldr.w	r6, [r9, #4]
    10fc:	f9b6 0000 	ldrsh.w	r0, [r6]
    1100:	f002 fbe8 	bl	38d4 <crc16>
        finder=finder->next;
    1104:	682d      	ldr	r5, [r5, #0]
        retval=crc16(list->info->data16,retval);
    1106:	4601      	mov	r1, r0
    while (finder) {
    1108:	2d00      	cmp	r5, #0
    110a:	d1f5      	bne.n	10f8 <core_bench_list+0x3c0>
    110c:	9009      	str	r0, [sp, #36]	; 0x24
}
    110e:	9809      	ldr	r0, [sp, #36]	; 0x24
    1110:	b00d      	add	sp, #52	; 0x34
    1112:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        while (list && ((list->info->data16 & 0xff) != info->data16))
    1116:	b173      	cbz	r3, 1136 <core_bench_list+0x3fe>
    1118:	6859      	ldr	r1, [r3, #4]
    111a:	780e      	ldrb	r6, [r1, #0]
    111c:	45b4      	cmp	ip, r6
    111e:	461d      	mov	r5, r3
    1120:	d105      	bne.n	112e <core_bench_list+0x3f6>
    1122:	e635      	b.n	d90 <core_bench_list+0x58>
    1124:	6869      	ldr	r1, [r5, #4]
    1126:	780e      	ldrb	r6, [r1, #0]
    1128:	4566      	cmp	r6, ip
    112a:	f43f ae31 	beq.w	d90 <core_bench_list+0x58>
            list=list->next;
    112e:	682d      	ldr	r5, [r5, #0]
        while (list && ((list->info->data16 & 0xff) != info->data16))
    1130:	2d00      	cmp	r5, #0
    1132:	d1f7      	bne.n	1124 <core_bench_list+0x3ec>
    1134:	e62c      	b.n	d90 <core_bench_list+0x58>
    1136:	f8de 6000 	ldr.w	r6, [lr]
    list_head *next=NULL, *tmp;
    113a:	2300      	movs	r3, #0
            retval+=(list->next->info->data16 >> 8) & 1;
    113c:	6871      	ldr	r1, [r6, #4]
    113e:	f991 6001 	ldrsb.w	r6, [r1, #1]
    1142:	f006 0b01 	and.w	fp, r6, #1
    1146:	445a      	add	r2, fp
            missed++;
    1148:	f109 0501 	add.w	r5, r9, #1
            retval+=(list->next->info->data16 >> 8) & 1;
    114c:	b292      	uxth	r2, r2
            missed++;
    114e:	fa1f f985 	uxth.w	r9, r5
    1152:	e63b      	b.n	dcc <core_bench_list+0x94>
    if (info->idx>=0) {
    1154:	465c      	mov	r4, fp
    1156:	990b      	ldr	r1, [sp, #44]	; 0x2c
    1158:	e002      	b.n	1160 <core_bench_list+0x428>
            list=list->next;
    115a:	6824      	ldr	r4, [r4, #0]
        while (list && ((list->info->data16 & 0xff) != info->data16))
    115c:	2c00      	cmp	r4, #0
    115e:	d0ab      	beq.n	10b8 <core_bench_list+0x380>
    1160:	6860      	ldr	r0, [r4, #4]
    1162:	f890 8000 	ldrb.w	r8, [r0]
    1166:	4588      	cmp	r8, r1
    1168:	d1f7      	bne.n	115a <core_bench_list+0x422>
    116a:	e7a9      	b.n	10c0 <core_bench_list+0x388>
        insize *= 2;
    116c:	9906      	ldr	r1, [sp, #24]
    116e:	f8dd a014 	ldr.w	sl, [sp, #20]
    1172:	0048      	lsls	r0, r1, #1
    1174:	9006      	str	r0, [sp, #24]
    1176:	4653      	mov	r3, sl
    1178:	e64b      	b.n	e12 <core_bench_list+0xda>
    for (i=0; i<find_num; i++) {
    117a:	2300      	movs	r3, #0
    info.idx=finder_idx;
    117c:	910a      	str	r1, [sp, #40]	; 0x28
    for (i=0; i<find_num; i++) {
    117e:	9309      	str	r3, [sp, #36]	; 0x24
    1180:	e638      	b.n	df4 <core_bench_list+0xbc>
    1182:	4698      	mov	r8, r3
        tail->next = NULL;
    1184:	f8c8 3000 	str.w	r3, [r8]
    1188:	deff      	udf	#255	; 0xff
    118a:	bf00      	nop

0000118c <core_list_init>:
    ee_u32 size=(blksize/per_item)-2; /* to accomodate systems with 64b pointers, and make sure same code is executed, set max list elements */
    118c:	4bb2      	ldr	r3, [pc, #712]	; (1458 <core_list_init+0x2cc>)
list_head *core_list_init(ee_u32 blksize, list_head *memblock, ee_s16 seed) {
    118e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ee_u32 size=(blksize/per_item)-2; /* to accomodate systems with 64b pointers, and make sure same code is executed, set max list elements */
    1192:	fba3 3000 	umull	r3, r0, r3, r0
    1196:	ea4f 1e10 	mov.w	lr, r0, lsr #4
    119a:	f1ae 0e02 	sub.w	lr, lr, #2
    list_head *memblock_end=memblock+size;
    119e:	eb01 07ce 	add.w	r7, r1, lr, lsl #3
    if ((*memblock+1) >= memblock_end)
    11a2:	f101 0910 	add.w	r9, r1, #16
    list->info->data16=(ee_s16)0x8080;
    11a6:	f248 0480 	movw	r4, #32896	; 0x8080
    list->next=NULL;
    11aa:	2300      	movs	r3, #0
    if ((*memblock+1) >= memblock_end)
    11ac:	454f      	cmp	r7, r9
    list->info=datablock;
    11ae:	e881 0088 	stmia.w	r1, {r3, r7}
list_head *core_list_init(ee_u32 blksize, list_head *memblock, ee_s16 seed) {
    11b2:	b083      	sub	sp, #12
    list->info->data16=(ee_s16)0x8080;
    11b4:	f841 403e 	str.w	r4, [r1, lr, lsl #3]
    list_data *datablock_end=datablock+size;
    11b8:	eb07 088e 	add.w	r8, r7, lr, lsl #2
    datablock++;
    11bc:	f107 0604 	add.w	r6, r7, #4
    memblock++;
    11c0:	f101 0408 	add.w	r4, r1, #8
    if ((*memblock+1) >= memblock_end)
    11c4:	d904      	bls.n	11d0 <core_list_init+0x44>
    if ((*datablock+1) >= datablock_end)
    11c6:	f107 0508 	add.w	r5, r7, #8
    11ca:	45a8      	cmp	r8, r5
    11cc:	f200 8139 	bhi.w	1442 <core_list_init+0x2b6>
    for (i=0; i<size; i++) {
    11d0:	f1be 0f00 	cmp.w	lr, #0
    11d4:	f000 80cb 	beq.w	136e <core_list_init+0x1e2>
    11d8:	f10e 35ff 	add.w	r5, lr, #4294967295
    if ((*memblock+1) >= memblock_end)
    11dc:	f104 0b08 	add.w	fp, r4, #8
    11e0:	f005 0003 	and.w	r0, r5, #3
    11e4:	455f      	cmp	r7, fp
    11e6:	b295      	uxth	r5, r2
    11e8:	9501      	str	r5, [sp, #4]
    to->idx=from->idx;
    11ea:	f647 79ff 	movw	r9, #32767	; 0x7fff
    if ((*memblock+1) >= memblock_end)
    11ee:	f200 80df 	bhi.w	13b0 <core_list_init+0x224>
    for (i=0; i<size; i++) {
    11f2:	2501      	movs	r5, #1
    11f4:	45ae      	cmp	lr, r5
    11f6:	f000 80ba 	beq.w	136e <core_list_init+0x1e2>
    11fa:	b390      	cbz	r0, 1262 <core_list_init+0xd6>
    11fc:	42a8      	cmp	r0, r5
    11fe:	d00d      	beq.n	121c <core_list_init+0x90>
    1200:	2802      	cmp	r0, #2
    1202:	d005      	beq.n	1210 <core_list_init+0x84>
    if ((*memblock+1) >= memblock_end)
    1204:	f104 0c08 	add.w	ip, r4, #8
    1208:	4567      	cmp	r7, ip
    120a:	f200 8102 	bhi.w	1412 <core_list_init+0x286>
    for (i=0; i<size; i++) {
    120e:	3501      	adds	r5, #1
    if ((*memblock+1) >= memblock_end)
    1210:	f104 0c08 	add.w	ip, r4, #8
    1214:	4567      	cmp	r7, ip
    1216:	f200 80df 	bhi.w	13d8 <core_list_init+0x24c>
    for (i=0; i<size; i++) {
    121a:	3501      	adds	r5, #1
    if ((*memblock+1) >= memblock_end)
    121c:	f104 0c08 	add.w	ip, r4, #8
    1220:	4567      	cmp	r7, ip
    1222:	d91a      	bls.n	125a <core_list_init+0xce>
    if ((*datablock+1) >= datablock_end)
    1224:	f106 0a04 	add.w	sl, r6, #4
    1228:	45d0      	cmp	r8, sl
    122a:	d916      	bls.n	125a <core_list_init+0xce>
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    122c:	9801      	ldr	r0, [sp, #4]
    newitem->next=insert_point->next;
    122e:	6023      	str	r3, [r4, #0]
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    1230:	fa1f fb85 	uxth.w	fp, r5
    1234:	ea8b 0000 	eor.w	r0, fp, r0
        ee_u16 dat=(datpat<<3) | (i&0x7); /* alternate between algorithms */
    1238:	00c0      	lsls	r0, r0, #3
    123a:	f000 0078 	and.w	r0, r0, #120	; 0x78
    123e:	f00b 0b07 	and.w	fp, fp, #7
    1242:	ea40 000b 	orr.w	r0, r0, fp
        info.data16=(dat<<8) | dat;     /* fill the data with actual data and upper bits with rebuild value */
    1246:	ea40 2000 	orr.w	r0, r0, r0, lsl #8
    insert_point->next=newitem;
    124a:	600c      	str	r4, [r1, #0]
    to->idx=from->idx;
    124c:	4623      	mov	r3, r4
    newitem->info=*datablock;
    124e:	6066      	str	r6, [r4, #4]
    to->idx=from->idx;
    1250:	f8a6 9002 	strh.w	r9, [r6, #2]
    to->data16=from->data16;
    1254:	8030      	strh	r0, [r6, #0]
    to->idx=from->idx;
    1256:	4664      	mov	r4, ip
    1258:	4656      	mov	r6, sl
    for (i=0; i<size; i++) {
    125a:	3501      	adds	r5, #1
    125c:	45ae      	cmp	lr, r5
    125e:	f000 8086 	beq.w	136e <core_list_init+0x1e2>
    if ((*memblock+1) >= memblock_end)
    1262:	f104 0c08 	add.w	ip, r4, #8
    1266:	4567      	cmp	r7, ip
    1268:	d91a      	bls.n	12a0 <core_list_init+0x114>
    if ((*datablock+1) >= datablock_end)
    126a:	f106 0a04 	add.w	sl, r6, #4
    126e:	45d0      	cmp	r8, sl
    1270:	d916      	bls.n	12a0 <core_list_init+0x114>
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    1272:	9801      	ldr	r0, [sp, #4]
    newitem->next=insert_point->next;
    1274:	6023      	str	r3, [r4, #0]
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    1276:	fa1f fb85 	uxth.w	fp, r5
    127a:	ea8b 0000 	eor.w	r0, fp, r0
        ee_u16 dat=(datpat<<3) | (i&0x7); /* alternate between algorithms */
    127e:	00c0      	lsls	r0, r0, #3
    1280:	f000 0078 	and.w	r0, r0, #120	; 0x78
    1284:	f00b 0b07 	and.w	fp, fp, #7
    1288:	ea40 000b 	orr.w	r0, r0, fp
        info.data16=(dat<<8) | dat;     /* fill the data with actual data and upper bits with rebuild value */
    128c:	ea40 2000 	orr.w	r0, r0, r0, lsl #8
    insert_point->next=newitem;
    1290:	600c      	str	r4, [r1, #0]
    to->idx=from->idx;
    1292:	4623      	mov	r3, r4
    newitem->info=*datablock;
    1294:	6066      	str	r6, [r4, #4]
    to->idx=from->idx;
    1296:	f8a6 9002 	strh.w	r9, [r6, #2]
    to->data16=from->data16;
    129a:	8030      	strh	r0, [r6, #0]
    to->idx=from->idx;
    129c:	4664      	mov	r4, ip
    129e:	4656      	mov	r6, sl
    if ((*memblock+1) >= memblock_end)
    12a0:	f104 0c08 	add.w	ip, r4, #8
    12a4:	4567      	cmp	r7, ip
    for (i=0; i<size; i++) {
    12a6:	f105 0501 	add.w	r5, r5, #1
    if ((*memblock+1) >= memblock_end)
    12aa:	d91a      	bls.n	12e2 <core_list_init+0x156>
    if ((*datablock+1) >= datablock_end)
    12ac:	f106 0a04 	add.w	sl, r6, #4
    12b0:	45d0      	cmp	r8, sl
    12b2:	d916      	bls.n	12e2 <core_list_init+0x156>
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    12b4:	9801      	ldr	r0, [sp, #4]
    newitem->next=insert_point->next;
    12b6:	6023      	str	r3, [r4, #0]
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    12b8:	fa1f fb85 	uxth.w	fp, r5
    12bc:	ea8b 0000 	eor.w	r0, fp, r0
        ee_u16 dat=(datpat<<3) | (i&0x7); /* alternate between algorithms */
    12c0:	00c0      	lsls	r0, r0, #3
    12c2:	f000 0078 	and.w	r0, r0, #120	; 0x78
    12c6:	f00b 0b07 	and.w	fp, fp, #7
    12ca:	ea40 000b 	orr.w	r0, r0, fp
        info.data16=(dat<<8) | dat;     /* fill the data with actual data and upper bits with rebuild value */
    12ce:	ea40 2000 	orr.w	r0, r0, r0, lsl #8
    insert_point->next=newitem;
    12d2:	600c      	str	r4, [r1, #0]
    to->idx=from->idx;
    12d4:	4623      	mov	r3, r4
    newitem->info=*datablock;
    12d6:	6066      	str	r6, [r4, #4]
    to->idx=from->idx;
    12d8:	f8a6 9002 	strh.w	r9, [r6, #2]
    to->data16=from->data16;
    12dc:	8030      	strh	r0, [r6, #0]
    to->idx=from->idx;
    12de:	4664      	mov	r4, ip
    12e0:	4656      	mov	r6, sl
    if ((*memblock+1) >= memblock_end)
    12e2:	f104 0a08 	add.w	sl, r4, #8
    12e6:	4557      	cmp	r7, sl
    for (i=0; i<size; i++) {
    12e8:	f105 0001 	add.w	r0, r5, #1
    if ((*memblock+1) >= memblock_end)
    12ec:	d91a      	bls.n	1324 <core_list_init+0x198>
    if ((*datablock+1) >= datablock_end)
    12ee:	f106 0b04 	add.w	fp, r6, #4
    12f2:	45d8      	cmp	r8, fp
    12f4:	d916      	bls.n	1324 <core_list_init+0x198>
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    12f6:	fa1f fc80 	uxth.w	ip, r0
    12fa:	9801      	ldr	r0, [sp, #4]
    newitem->next=insert_point->next;
    12fc:	6023      	str	r3, [r4, #0]
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    12fe:	ea8c 0000 	eor.w	r0, ip, r0
        ee_u16 dat=(datpat<<3) | (i&0x7); /* alternate between algorithms */
    1302:	00c0      	lsls	r0, r0, #3
    1304:	f000 0078 	and.w	r0, r0, #120	; 0x78
    1308:	f00c 0c07 	and.w	ip, ip, #7
    130c:	ea40 000c 	orr.w	r0, r0, ip
        info.data16=(dat<<8) | dat;     /* fill the data with actual data and upper bits with rebuild value */
    1310:	ea40 2000 	orr.w	r0, r0, r0, lsl #8
    insert_point->next=newitem;
    1314:	600c      	str	r4, [r1, #0]
    to->idx=from->idx;
    1316:	4623      	mov	r3, r4
    newitem->info=*datablock;
    1318:	6066      	str	r6, [r4, #4]
    to->idx=from->idx;
    131a:	f8a6 9002 	strh.w	r9, [r6, #2]
    to->data16=from->data16;
    131e:	8030      	strh	r0, [r6, #0]
    to->idx=from->idx;
    1320:	4654      	mov	r4, sl
    1322:	465e      	mov	r6, fp
    if ((*memblock+1) >= memblock_end)
    1324:	f104 0a08 	add.w	sl, r4, #8
    1328:	4557      	cmp	r7, sl
    for (i=0; i<size; i++) {
    132a:	f105 0002 	add.w	r0, r5, #2
    if ((*memblock+1) >= memblock_end)
    132e:	d91a      	bls.n	1366 <core_list_init+0x1da>
    if ((*datablock+1) >= datablock_end)
    1330:	f106 0b04 	add.w	fp, r6, #4
    1334:	45d8      	cmp	r8, fp
    1336:	d916      	bls.n	1366 <core_list_init+0x1da>
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    1338:	fa1f fc80 	uxth.w	ip, r0
    133c:	9801      	ldr	r0, [sp, #4]
    newitem->next=insert_point->next;
    133e:	6023      	str	r3, [r4, #0]
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    1340:	ea8c 0000 	eor.w	r0, ip, r0
        ee_u16 dat=(datpat<<3) | (i&0x7); /* alternate between algorithms */
    1344:	00c0      	lsls	r0, r0, #3
    1346:	f000 0078 	and.w	r0, r0, #120	; 0x78
    134a:	f00c 0c07 	and.w	ip, ip, #7
    134e:	ea40 000c 	orr.w	r0, r0, ip
        info.data16=(dat<<8) | dat;     /* fill the data with actual data and upper bits with rebuild value */
    1352:	ea40 2000 	orr.w	r0, r0, r0, lsl #8
    insert_point->next=newitem;
    1356:	600c      	str	r4, [r1, #0]
    to->idx=from->idx;
    1358:	4623      	mov	r3, r4
    newitem->info=*datablock;
    135a:	6066      	str	r6, [r4, #4]
    to->idx=from->idx;
    135c:	f8a6 9002 	strh.w	r9, [r6, #2]
    to->data16=from->data16;
    1360:	8030      	strh	r0, [r6, #0]
    to->idx=from->idx;
    1362:	4654      	mov	r4, sl
    1364:	465e      	mov	r6, fp
    for (i=0; i<size; i++) {
    1366:	3503      	adds	r5, #3
    1368:	45ae      	cmp	lr, r5
    136a:	f47f af7a 	bne.w	1262 <core_list_init+0xd6>
        if (i<size/5) /* first 20% of the list in order */
    136e:	4f3a      	ldr	r7, [pc, #232]	; (1458 <core_list_init+0x2cc>)
    1370:	fba7 050e 	umull	r0, r5, r7, lr
    1374:	ea4f 0e95 	mov.w	lr, r5, lsr #2
    while (finder->next!=NULL) {
    1378:	2602      	movs	r6, #2
    137a:	2501      	movs	r5, #1
    137c:	e00a      	b.n	1394 <core_list_init+0x208>
        if (i<size/5) /* first 20% of the list in order */
    137e:	4575      	cmp	r5, lr
            finder->info->idx=i++;
    1380:	685b      	ldr	r3, [r3, #4]
            finder->info->idx=0x3fff & (((i & 0x07) << 8) | pat); /* make sure the mixed items end up after the ones in sequence */
    1382:	bf25      	ittet	cs
    1384:	4338      	orrcs	r0, r7
    1386:	f3c0 000d 	ubfxcs	r0, r0, #0, #14
            finder->info->idx=i++;
    138a:	805d      	strhcc	r5, [r3, #2]
            finder->info->idx=0x3fff & (((i & 0x07) << 8) | pat); /* make sure the mixed items end up after the ones in sequence */
    138c:	8058      	strhcs	r0, [r3, #2]
    138e:	3601      	adds	r6, #1
    1390:	3501      	adds	r5, #1
    to->idx=from->idx;
    1392:	4623      	mov	r3, r4
    while (finder->next!=NULL) {
    1394:	681c      	ldr	r4, [r3, #0]
            finder->info->idx=0x3fff & (((i & 0x07) << 8) | pat); /* make sure the mixed items end up after the ones in sequence */
    1396:	0230      	lsls	r0, r6, #8
            ee_u16 pat=(ee_u16)(i++ ^ seed); /* get a pseudo random number */
    1398:	ea85 0702 	eor.w	r7, r5, r2
            finder->info->idx=0x3fff & (((i & 0x07) << 8) | pat); /* make sure the mixed items end up after the ones in sequence */
    139c:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
    while (finder->next!=NULL) {
    13a0:	2c00      	cmp	r4, #0
    13a2:	d1ec      	bne.n	137e <core_list_init+0x1f2>
    list = core_list_mergesort(list,cmp_idx,NULL);
    13a4:	4608      	mov	r0, r1
}
    13a6:	b003      	add	sp, #12
    13a8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    list = core_list_mergesort(list,cmp_idx,NULL);
    13ac:	f7ff bc20 	b.w	bf0 <core_list_mergesort.constprop.2>
    if ((*datablock+1) >= datablock_end)
    13b0:	f106 0a04 	add.w	sl, r6, #4
    13b4:	45d0      	cmp	r8, sl
    13b6:	f67f af1c 	bls.w	11f2 <core_list_init+0x66>
        ee_u16 dat=(datpat<<3) | (i&0x7); /* alternate between algorithms */
    13ba:	00ed      	lsls	r5, r5, #3
    13bc:	f005 0578 	and.w	r5, r5, #120	; 0x78
        info.data16=(dat<<8) | dat;     /* fill the data with actual data and upper bits with rebuild value */
    13c0:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    newitem->next=insert_point->next;
    13c4:	6023      	str	r3, [r4, #0]
    insert_point->next=newitem;
    13c6:	600c      	str	r4, [r1, #0]
    to->idx=from->idx;
    13c8:	4623      	mov	r3, r4
    newitem->info=*datablock;
    13ca:	6066      	str	r6, [r4, #4]
    to->idx=from->idx;
    13cc:	f8a6 9002 	strh.w	r9, [r6, #2]
    to->data16=from->data16;
    13d0:	8035      	strh	r5, [r6, #0]
    to->idx=from->idx;
    13d2:	465c      	mov	r4, fp
    13d4:	4656      	mov	r6, sl
    13d6:	e70c      	b.n	11f2 <core_list_init+0x66>
    if ((*datablock+1) >= datablock_end)
    13d8:	f106 0a04 	add.w	sl, r6, #4
    13dc:	45d0      	cmp	r8, sl
    13de:	f67f af1c 	bls.w	121a <core_list_init+0x8e>
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    13e2:	9801      	ldr	r0, [sp, #4]
    newitem->next=insert_point->next;
    13e4:	6023      	str	r3, [r4, #0]
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    13e6:	fa1f fb85 	uxth.w	fp, r5
    13ea:	ea8b 0000 	eor.w	r0, fp, r0
        ee_u16 dat=(datpat<<3) | (i&0x7); /* alternate between algorithms */
    13ee:	00c0      	lsls	r0, r0, #3
    13f0:	f000 0078 	and.w	r0, r0, #120	; 0x78
    13f4:	f00b 0b07 	and.w	fp, fp, #7
    13f8:	ea40 000b 	orr.w	r0, r0, fp
        info.data16=(dat<<8) | dat;     /* fill the data with actual data and upper bits with rebuild value */
    13fc:	ea40 2000 	orr.w	r0, r0, r0, lsl #8
    insert_point->next=newitem;
    1400:	600c      	str	r4, [r1, #0]
    to->idx=from->idx;
    1402:	4623      	mov	r3, r4
    newitem->info=*datablock;
    1404:	6066      	str	r6, [r4, #4]
    to->idx=from->idx;
    1406:	f8a6 9002 	strh.w	r9, [r6, #2]
    to->data16=from->data16;
    140a:	8030      	strh	r0, [r6, #0]
    to->idx=from->idx;
    140c:	4664      	mov	r4, ip
    140e:	4656      	mov	r6, sl
    1410:	e703      	b.n	121a <core_list_init+0x8e>
    if ((*datablock+1) >= datablock_end)
    1412:	f106 0b04 	add.w	fp, r6, #4
    1416:	45d8      	cmp	r8, fp
    1418:	f67f aef9 	bls.w	120e <core_list_init+0x82>
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    141c:	9801      	ldr	r0, [sp, #4]
    newitem->next=insert_point->next;
    141e:	6023      	str	r3, [r4, #0]
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    1420:	4068      	eors	r0, r5
        ee_u16 dat=(datpat<<3) | (i&0x7); /* alternate between algorithms */
    1422:	00c0      	lsls	r0, r0, #3
    1424:	f000 0078 	and.w	r0, r0, #120	; 0x78
    1428:	4328      	orrs	r0, r5
        info.data16=(dat<<8) | dat;     /* fill the data with actual data and upper bits with rebuild value */
    142a:	ea40 2a00 	orr.w	sl, r0, r0, lsl #8
    insert_point->next=newitem;
    142e:	600c      	str	r4, [r1, #0]
    to->idx=from->idx;
    1430:	4623      	mov	r3, r4
    newitem->info=*datablock;
    1432:	6066      	str	r6, [r4, #4]
    to->idx=from->idx;
    1434:	f8a6 9002 	strh.w	r9, [r6, #2]
    to->data16=from->data16;
    1438:	f8a6 a000 	strh.w	sl, [r6]
    to->idx=from->idx;
    143c:	4664      	mov	r4, ip
    143e:	465e      	mov	r6, fp
    1440:	e6e5      	b.n	120e <core_list_init+0x82>
    to->data16=from->data16;
    1442:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
    newitem->next=insert_point->next;
    1446:	608b      	str	r3, [r1, #8]
    insert_point->next=newitem;
    1448:	600c      	str	r4, [r1, #0]
    newitem->info=*datablock;
    144a:	60ce      	str	r6, [r1, #12]
    to->data16=from->data16;
    144c:	4623      	mov	r3, r4
    144e:	462e      	mov	r6, r5
    1450:	464c      	mov	r4, r9
    1452:	6078      	str	r0, [r7, #4]
    1454:	e6bc      	b.n	11d0 <core_list_init+0x44>
    1456:	bf00      	nop
    1458:	cccccccd 	.word	0xcccccccd

0000145c <iterate>:
    NULL.
*/
static ee_u16 list_known_crc[]   =      {(ee_u16)0xd4b0,(ee_u16)0x3340,(ee_u16)0x6a79,(ee_u16)0xe714,(ee_u16)0xe3c1};
static ee_u16 matrix_known_crc[] =      {(ee_u16)0xbe52,(ee_u16)0x1199,(ee_u16)0x5608,(ee_u16)0x1fd7,(ee_u16)0x0747};
static ee_u16 state_known_crc[]  =      {(ee_u16)0x5e47,(ee_u16)0x39bf,(ee_u16)0xe5a4,(ee_u16)0x8e3a,(ee_u16)0x8d84};
void *iterate(void *pres) {
    145c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ee_u32 i;
    ee_u16 crc;
    core_results *res=(core_results *)pres;
    ee_u32 iterations=res->iterations;
    145e:	69c7      	ldr	r7, [r0, #28]
    res->crc=0;
    1460:	2300      	movs	r3, #0
    1462:	6383      	str	r3, [r0, #56]	; 0x38
    1464:	63c3      	str	r3, [r0, #60]	; 0x3c
    res->crclist=0;
    res->crcmatrix=0;
    res->crcstate=0;

    for (i=0; i<iterations; i++) {
    1466:	2f00      	cmp	r7, #0
    1468:	d056      	beq.n	1518 <iterate+0xbc>
    146a:	4604      	mov	r4, r0
    146c:	1e7a      	subs	r2, r7, #1
        crc=core_bench_list(res,1);
    146e:	2101      	movs	r1, #1
    1470:	ea02 0601 	and.w	r6, r2, r1
    1474:	f7ff fc60 	bl	d38 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    1478:	8f21      	ldrh	r1, [r4, #56]	; 0x38
    147a:	f002 f863 	bl	3544 <crcu16>
        crc=core_bench_list(res,-1);
    147e:	f04f 31ff 	mov.w	r1, #4294967295
        res->crc=crcu16(crc,res->crc);
    1482:	8720      	strh	r0, [r4, #56]	; 0x38
        crc=core_bench_list(res,-1);
    1484:	4620      	mov	r0, r4
    1486:	f7ff fc57 	bl	d38 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    148a:	8f21      	ldrh	r1, [r4, #56]	; 0x38
    148c:	f002 f85a 	bl	3544 <crcu16>
    for (i=0; i<iterations; i++) {
    1490:	2501      	movs	r5, #1
    1492:	42af      	cmp	r7, r5
        res->crc=crcu16(crc,res->crc);
    1494:	8720      	strh	r0, [r4, #56]	; 0x38
        if (i==0) res->crclist=res->crc;
    1496:	8760      	strh	r0, [r4, #58]	; 0x3a
    for (i=0; i<iterations; i++) {
    1498:	d03e      	beq.n	1518 <iterate+0xbc>
    149a:	b19e      	cbz	r6, 14c4 <iterate+0x68>
        crc=core_bench_list(res,1);
    149c:	4629      	mov	r1, r5
    149e:	4620      	mov	r0, r4
    14a0:	f7ff fc4a 	bl	d38 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    14a4:	8f21      	ldrh	r1, [r4, #56]	; 0x38
    14a6:	f002 f84d 	bl	3544 <crcu16>
        crc=core_bench_list(res,-1);
    14aa:	f04f 31ff 	mov.w	r1, #4294967295
        res->crc=crcu16(crc,res->crc);
    14ae:	8720      	strh	r0, [r4, #56]	; 0x38
        crc=core_bench_list(res,-1);
    14b0:	4620      	mov	r0, r4
    14b2:	f7ff fc41 	bl	d38 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    14b6:	8f21      	ldrh	r1, [r4, #56]	; 0x38
    14b8:	f002 f844 	bl	3544 <crcu16>
    for (i=0; i<iterations; i++) {
    14bc:	3501      	adds	r5, #1
    14be:	42af      	cmp	r7, r5
        res->crc=crcu16(crc,res->crc);
    14c0:	8720      	strh	r0, [r4, #56]	; 0x38
    for (i=0; i<iterations; i++) {
    14c2:	d029      	beq.n	1518 <iterate+0xbc>
        crc=core_bench_list(res,1);
    14c4:	2101      	movs	r1, #1
    14c6:	4620      	mov	r0, r4
    14c8:	f7ff fc36 	bl	d38 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    14cc:	8f21      	ldrh	r1, [r4, #56]	; 0x38
    14ce:	f002 f839 	bl	3544 <crcu16>
        crc=core_bench_list(res,-1);
    14d2:	f04f 31ff 	mov.w	r1, #4294967295
        res->crc=crcu16(crc,res->crc);
    14d6:	8720      	strh	r0, [r4, #56]	; 0x38
        crc=core_bench_list(res,-1);
    14d8:	4620      	mov	r0, r4
    14da:	f7ff fc2d 	bl	d38 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    14de:	8f21      	ldrh	r1, [r4, #56]	; 0x38
    14e0:	f002 f830 	bl	3544 <crcu16>
        crc=core_bench_list(res,1);
    14e4:	2101      	movs	r1, #1
        res->crc=crcu16(crc,res->crc);
    14e6:	4684      	mov	ip, r0
    for (i=0; i<iterations; i++) {
    14e8:	186e      	adds	r6, r5, r1
        crc=core_bench_list(res,1);
    14ea:	4620      	mov	r0, r4
        res->crc=crcu16(crc,res->crc);
    14ec:	f8a4 c038 	strh.w	ip, [r4, #56]	; 0x38
        if (i==0) res->crclist=res->crc;
    14f0:	b1a5      	cbz	r5, 151c <iterate+0xc0>
        crc=core_bench_list(res,1);
    14f2:	f7ff fc21 	bl	d38 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    14f6:	8f21      	ldrh	r1, [r4, #56]	; 0x38
    14f8:	f002 f824 	bl	3544 <crcu16>
        crc=core_bench_list(res,-1);
    14fc:	f04f 31ff 	mov.w	r1, #4294967295
        res->crc=crcu16(crc,res->crc);
    1500:	8720      	strh	r0, [r4, #56]	; 0x38
        crc=core_bench_list(res,-1);
    1502:	4620      	mov	r0, r4
    1504:	f7ff fc18 	bl	d38 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    1508:	8f21      	ldrh	r1, [r4, #56]	; 0x38
    150a:	f002 f81b 	bl	3544 <crcu16>
    150e:	8720      	strh	r0, [r4, #56]	; 0x38
        if (i==0) res->crclist=res->crc;
    1510:	b13e      	cbz	r6, 1522 <iterate+0xc6>
    for (i=0; i<iterations; i++) {
    1512:	1c75      	adds	r5, r6, #1
    1514:	42af      	cmp	r7, r5
    1516:	d1d5      	bne.n	14c4 <iterate+0x68>
    }
    return NULL;
}
    1518:	2000      	movs	r0, #0
    151a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (i==0) res->crclist=res->crc;
    151c:	f8a4 c03a 	strh.w	ip, [r4, #58]	; 0x3a
    1520:	e7e7      	b.n	14f2 <iterate+0x96>
    1522:	8760      	strh	r0, [r4, #58]	; 0x3a
    1524:	e7f5      	b.n	1512 <iterate+0xb6>
    1526:	bf00      	nop

00001528 <main>:
    4 - Iterations  : Special, if set to 0, iterations will be automatically determined such that the benchmark will run between 10 to 100 secs

*/

#if MAIN_HAS_NOARGC
MAIN_RETURN_TYPE main(void) {
    1528:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    152c:	f6ad 0d44 	subw	sp, sp, #2116	; 0x844
    int argc=0;
    1530:	2300      	movs	r3, #0
    core_results results[MULTITHREAD];
#if (MEM_METHOD==MEM_STACK)
    ee_u8 stack_memblock[TOTAL_DATA_SIZE*MULTITHREAD];
#endif
    /* first call any initializations needed */
    portable_init(&(results[0].port), &argc, argv);
    1532:	a909      	add	r1, sp, #36	; 0x24
    1534:	aa0a      	add	r2, sp, #40	; 0x28
    1536:	f10d 006e 	add.w	r0, sp, #110	; 0x6e
    int argc=0;
    153a:	9309      	str	r3, [sp, #36]	; 0x24
    portable_init(&(results[0].port), &argc, argv);
    153c:	f001 fc90 	bl	2e60 <portable_init>
    /* First some checks to make sure benchmark will run ok */
    if (sizeof(struct list_head_s)>128) {
        ee_printf("list_head structure too big for comparable data!\n");
        return MAIN_RETURN_VAL;
    }
    results[0].seed1=get_seed(1);
    1540:	2001      	movs	r0, #1
    1542:	f001 ffdb 	bl	34fc <get_seed_32>
    1546:	f8ad 002c 	strh.w	r0, [sp, #44]	; 0x2c
    results[0].seed2=get_seed(2);
    154a:	2002      	movs	r0, #2
    154c:	f001 ffd6 	bl	34fc <get_seed_32>
    1550:	f8ad 002e 	strh.w	r0, [sp, #46]	; 0x2e
    results[0].seed3=get_seed(3);
    1554:	2003      	movs	r0, #3
    1556:	f001 ffd1 	bl	34fc <get_seed_32>
    155a:	f8ad 0030 	strh.w	r0, [sp, #48]	; 0x30
    results[0].iterations=get_seed_32(4);
    155e:	2004      	movs	r0, #4
    1560:	f001 ffcc 	bl	34fc <get_seed_32>
    1564:	9012      	str	r0, [sp, #72]	; 0x48
#if CORE_DEBUG
    results[0].iterations=1;
#endif
    results[0].execs=get_seed_32(5);
    1566:	2005      	movs	r0, #5
    1568:	f001 ffc8 	bl	34fc <get_seed_32>
    if (results[0].execs==0) { /* if not supplied, execute all algorithms */
    156c:	2800      	cmp	r0, #0
    156e:	f000 814a 	beq.w	1806 <main+0x2de>
    results[0].execs=get_seed_32(5);
    1572:	9013      	str	r0, [sp, #76]	; 0x4c
        results[0].execs=ALL_ALGORITHMS_MASK;
    }
        /* put in some default values based on one seed only for easy testing */
    if ((results[0].seed1==0) && (results[0].seed2==0) && (results[0].seed3==0)) { /* validation run */
    1574:	990b      	ldr	r1, [sp, #44]	; 0x2c
    1576:	2900      	cmp	r1, #0
    1578:	f040 81c3 	bne.w	1902 <main+0x3da>
    157c:	f9bd 4030 	ldrsh.w	r4, [sp, #48]	; 0x30
    1580:	2c00      	cmp	r4, #0
    1582:	f000 81c8 	beq.w	1916 <main+0x3ee>
        results[i].size=TOTAL_DATA_SIZE;
        results[i].seed1=results[0].seed1;
        results[i].seed2=results[0].seed2;
        results[i].seed3=results[0].seed3;
        results[i].err=0;
        results[i].execs=results[0].execs;
    1586:	9b13      	ldr	r3, [sp, #76]	; 0x4c
        results[i].seed1=results[0].seed1;
    1588:	f9bd 202c 	ldrsh.w	r2, [sp, #44]	; 0x2c
        results[i].memblock[0]=stack_memblock+i*TOTAL_DATA_SIZE;
    158c:	a91c      	add	r1, sp, #112	; 0x70
        results[i].err=0;
    158e:	2500      	movs	r5, #0
    1590:	f3c3 0640 	ubfx	r6, r3, #1, #1
    1594:	f003 0701 	and.w	r7, r3, #1
        results[i].memblock[0]=stack_memblock+i*TOTAL_DATA_SIZE;
    1598:	910d      	str	r1, [sp, #52]	; 0x34
    for (i=0 ; i<MULTITHREAD; i++)
        results[i].size=results[i].size/num_algorithms;
    /* Assign pointers */
    for (i=0; i<NUM_ALGORITHMS; i++) {
        ee_u32 ctx;
        if ((1<<(ee_u32)i) & results[0].execs) {
    159a:	f013 0101 	ands.w	r1, r3, #1
        results[i].err=0;
    159e:	f8ad 506c 	strh.w	r5, [sp, #108]	; 0x6c
        results[i].size=results[i].size/num_algorithms;
    15a2:	443e      	add	r6, r7
            for (ctx=0 ; ctx<MULTITHREAD; ctx++)
                results[ctx].memblock[i+1]=(char *)(results[ctx].memblock[0])+results[0].size*j;
    15a4:	bf18      	it	ne
    15a6:	ad1c      	addne	r5, sp, #112	; 0x70
        results[i].size=results[i].size/num_algorithms;
    15a8:	f3c3 0880 	ubfx	r8, r3, #2, #1
    15ac:	f003 0402 	and.w	r4, r3, #2
    15b0:	4446      	add	r6, r8
    15b2:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
                results[ctx].memblock[i+1]=(char *)(results[ctx].memblock[0])+results[0].size*j;
    15b6:	bf18      	it	ne
    15b8:	950e      	strne	r5, [sp, #56]	; 0x38
        results[i].size=results[i].size/num_algorithms;
    15ba:	fbb0 f0f6 	udiv	r0, r0, r6
            j++;
    15be:	bf18      	it	ne
    15c0:	2501      	movne	r5, #1
        results[i].size=results[i].size/num_algorithms;
    15c2:	f003 0604 	and.w	r6, r3, #4
    15c6:	9011      	str	r0, [sp, #68]	; 0x44
        if ((1<<(ee_u32)i) & results[0].execs) {
    15c8:	bf08      	it	eq
    15ca:	460d      	moveq	r5, r1
    15cc:	b134      	cbz	r4, 15dc <main+0xb4>
                results[ctx].memblock[i+1]=(char *)(results[ctx].memblock[0])+results[0].size*j;
    15ce:	f10d 0970 	add.w	r9, sp, #112	; 0x70
    15d2:	fb00 9705 	mla	r7, r0, r5, r9
            j++;
    15d6:	3501      	adds	r5, #1
                results[ctx].memblock[i+1]=(char *)(results[ctx].memblock[0])+results[0].size*j;
    15d8:	970f      	str	r7, [sp, #60]	; 0x3c
            j++;
    15da:	b2ad      	uxth	r5, r5
        if ((1<<(ee_u32)i) & results[0].execs) {
    15dc:	b126      	cbz	r6, 15e8 <main+0xc0>
                results[ctx].memblock[i+1]=(char *)(results[ctx].memblock[0])+results[0].size*j;
    15de:	f10d 0a70 	add.w	sl, sp, #112	; 0x70
    15e2:	fb00 a605 	mla	r6, r0, r5, sl
    15e6:	9610      	str	r6, [sp, #64]	; 0x40
        }
    }
    /* call inits */
    for (i=0 ; i<MULTITHREAD; i++) {
        if (results[i].execs & ID_LIST) {
    15e8:	2900      	cmp	r1, #0
    15ea:	f040 80ec 	bne.w	17c6 <main+0x29e>
            results[i].list=core_list_init(results[0].size,results[i].memblock[1],results[i].seed1);
        }
        if (results[i].execs & ID_MATRIX) {
    15ee:	2c00      	cmp	r4, #0
    15f0:	f040 80f3 	bne.w	17da <main+0x2b2>
            core_init_matrix(results[0].size, results[i].memblock[2], (ee_s32)results[i].seed1 | (((ee_s32)results[i].seed2) << 16), &(results[i].mat) );
        }
        if (results[i].execs & ID_STATE) {
    15f4:	075a      	lsls	r2, r3, #29
    15f6:	f100 80ff 	bmi.w	17f8 <main+0x2d0>
            core_init_state(results[0].size,results[i].seed1,results[i].memblock[3]);
        }
    }

    /* automatically determine number of iterations if not set */
    if (results[0].iterations==0) {
    15fa:	9812      	ldr	r0, [sp, #72]	; 0x48
    15fc:	2800      	cmp	r0, #0
    15fe:	f040 809f 	bne.w	1740 <main+0x218>
        secs_ret secs_passed=0;
        ee_u32 divisor;
        results[0].iterations=1;
    1602:	2201      	movs	r2, #1
        while (secs_passed < (secs_ret)1) {
    1604:	4fc8      	ldr	r7, [pc, #800]	; (1928 <main+0x400>)
        results[0].iterations=1;
    1606:	9212      	str	r2, [sp, #72]	; 0x48
        while (secs_passed < (secs_ret)1) {
    1608:	f04f 0a00 	mov.w	sl, #0
    res->crc=0;
    160c:	4681      	mov	r9, r0
            results[0].iterations*=10;
    160e:	9912      	ldr	r1, [sp, #72]	; 0x48
    1610:	eb01 0581 	add.w	r5, r1, r1, lsl #2
    1614:	006e      	lsls	r6, r5, #1
    1616:	9612      	str	r6, [sp, #72]	; 0x48
            start_time();
    1618:	f001 fbda 	bl	2dd0 <start_time>
    ee_u32 iterations=res->iterations;
    161c:	f8dd 8048 	ldr.w	r8, [sp, #72]	; 0x48
    res->crc=0;
    1620:	f8cd 9064 	str.w	r9, [sp, #100]	; 0x64
    1624:	f8cd 9068 	str.w	r9, [sp, #104]	; 0x68
    for (i=0; i<iterations; i++) {
    1628:	f1b8 0f00 	cmp.w	r8, #0
    162c:	d06b      	beq.n	1706 <main+0x1de>
        crc=core_bench_list(res,1);
    162e:	2101      	movs	r1, #1
    1630:	f108 34ff 	add.w	r4, r8, #4294967295
    1634:	a80b      	add	r0, sp, #44	; 0x2c
    1636:	ea04 0501 	and.w	r5, r4, r1
    163a:	f7ff fb7d 	bl	d38 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    163e:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
    1642:	f001 ff7f 	bl	3544 <crcu16>
        crc=core_bench_list(res,-1);
    1646:	f04f 31ff 	mov.w	r1, #4294967295
        res->crc=crcu16(crc,res->crc);
    164a:	f8ad 0064 	strh.w	r0, [sp, #100]	; 0x64
        crc=core_bench_list(res,-1);
    164e:	a80b      	add	r0, sp, #44	; 0x2c
    1650:	f7ff fb72 	bl	d38 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    1654:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
    1658:	f001 ff74 	bl	3544 <crcu16>
    for (i=0; i<iterations; i++) {
    165c:	2401      	movs	r4, #1
    165e:	45a0      	cmp	r8, r4
        res->crc=crcu16(crc,res->crc);
    1660:	f8ad 0064 	strh.w	r0, [sp, #100]	; 0x64
        if (i==0) res->crclist=res->crc;
    1664:	f8ad 0066 	strh.w	r0, [sp, #102]	; 0x66
    for (i=0; i<iterations; i++) {
    1668:	d04d      	beq.n	1706 <main+0x1de>
    166a:	b1bd      	cbz	r5, 169c <main+0x174>
        crc=core_bench_list(res,1);
    166c:	4621      	mov	r1, r4
    166e:	a80b      	add	r0, sp, #44	; 0x2c
    1670:	f7ff fb62 	bl	d38 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    1674:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
    1678:	f001 ff64 	bl	3544 <crcu16>
        crc=core_bench_list(res,-1);
    167c:	f04f 31ff 	mov.w	r1, #4294967295
        res->crc=crcu16(crc,res->crc);
    1680:	f8ad 0064 	strh.w	r0, [sp, #100]	; 0x64
        crc=core_bench_list(res,-1);
    1684:	a80b      	add	r0, sp, #44	; 0x2c
    1686:	f7ff fb57 	bl	d38 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    168a:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
    168e:	f001 ff59 	bl	3544 <crcu16>
    for (i=0; i<iterations; i++) {
    1692:	3401      	adds	r4, #1
    1694:	45a0      	cmp	r8, r4
        res->crc=crcu16(crc,res->crc);
    1696:	f8ad 0064 	strh.w	r0, [sp, #100]	; 0x64
    for (i=0; i<iterations; i++) {
    169a:	d034      	beq.n	1706 <main+0x1de>
        crc=core_bench_list(res,1);
    169c:	2101      	movs	r1, #1
    169e:	a80b      	add	r0, sp, #44	; 0x2c
    16a0:	f7ff fb4a 	bl	d38 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    16a4:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
    16a8:	f001 ff4c 	bl	3544 <crcu16>
        crc=core_bench_list(res,-1);
    16ac:	f04f 31ff 	mov.w	r1, #4294967295
        res->crc=crcu16(crc,res->crc);
    16b0:	f8ad 0064 	strh.w	r0, [sp, #100]	; 0x64
        crc=core_bench_list(res,-1);
    16b4:	a80b      	add	r0, sp, #44	; 0x2c
    16b6:	f7ff fb3f 	bl	d38 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    16ba:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
    16be:	f001 ff41 	bl	3544 <crcu16>
        crc=core_bench_list(res,1);
    16c2:	2101      	movs	r1, #1
        res->crc=crcu16(crc,res->crc);
    16c4:	4683      	mov	fp, r0
    for (i=0; i<iterations; i++) {
    16c6:	1866      	adds	r6, r4, r1
        crc=core_bench_list(res,1);
    16c8:	a80b      	add	r0, sp, #44	; 0x2c
        res->crc=crcu16(crc,res->crc);
    16ca:	f8ad b064 	strh.w	fp, [sp, #100]	; 0x64
        if (i==0) res->crclist=res->crc;
    16ce:	2c00      	cmp	r4, #0
    16d0:	f000 8294 	beq.w	1bfc <main+0x6d4>
        crc=core_bench_list(res,1);
    16d4:	f7ff fb30 	bl	d38 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    16d8:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
    16dc:	f001 ff32 	bl	3544 <crcu16>
        crc=core_bench_list(res,-1);
    16e0:	f04f 31ff 	mov.w	r1, #4294967295
        res->crc=crcu16(crc,res->crc);
    16e4:	f8ad 0064 	strh.w	r0, [sp, #100]	; 0x64
        crc=core_bench_list(res,-1);
    16e8:	a80b      	add	r0, sp, #44	; 0x2c
    16ea:	f7ff fb25 	bl	d38 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    16ee:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
    16f2:	f001 ff27 	bl	3544 <crcu16>
    16f6:	f8ad 0064 	strh.w	r0, [sp, #100]	; 0x64
        if (i==0) res->crclist=res->crc;
    16fa:	2e00      	cmp	r6, #0
    16fc:	f000 8281 	beq.w	1c02 <main+0x6da>
    for (i=0; i<iterations; i++) {
    1700:	1c74      	adds	r4, r6, #1
    1702:	45a0      	cmp	r8, r4
    1704:	d1ca      	bne.n	169c <main+0x174>
            iterate(&results[0]);
            stop_time();
    1706:	f001 fb7d 	bl	2e04 <stop_time>
            secs_passed=time_in_secs(get_time());
    170a:	f001 fb8f 	bl	2e2c <get_time>
    170e:	f001 fb97 	bl	2e40 <time_in_secs>
        while (secs_passed < (secs_ret)1) {
    1712:	4652      	mov	r2, sl
    1714:	463b      	mov	r3, r7
            secs_passed=time_in_secs(get_time());
    1716:	4680      	mov	r8, r0
    1718:	460d      	mov	r5, r1
        while (secs_passed < (secs_ret)1) {
    171a:	f7ff f8db 	bl	8d4 <__aeabi_dcmplt>
    171e:	2800      	cmp	r0, #0
    1720:	f47f af75 	bne.w	160e <main+0xe6>
        }
        /* now we know it executes for at least 1 sec, set actual run time at about 10 secs */
        divisor=(ee_u32)secs_passed;
    1724:	4640      	mov	r0, r8
    1726:	4629      	mov	r1, r5
    1728:	f7ff f8fc 	bl	924 <__aeabi_d2uiz>
        if (divisor==0) /* some machines cast float to int as 0 since this conversion is not defined by ANSI, but we know at least one second passed */
            divisor=1;
        results[0].iterations*=1+10/divisor;
    172c:	9b12      	ldr	r3, [sp, #72]	; 0x48
            divisor=1;
    172e:	2800      	cmp	r0, #0
    1730:	bf08      	it	eq
    1732:	2001      	moveq	r0, #1
        results[0].iterations*=1+10/divisor;
    1734:	270a      	movs	r7, #10
    1736:	fbb7 f0f0 	udiv	r0, r7, r0
    173a:	fb00 3203 	mla	r2, r0, r3, r3
    173e:	9212      	str	r2, [sp, #72]	; 0x48
    }
    /* perform actual benchmark */
    start_time();
    1740:	f001 fb46 	bl	2dd0 <start_time>
    }
    for (i=0 ; i<default_num_contexts; i++) {
        core_stop_parallel(&results[i]);
    }
#else
    iterate(&results[0]);
    1744:	a80b      	add	r0, sp, #44	; 0x2c
    1746:	f7ff fe89 	bl	145c <iterate>
#endif
    stop_time();
    174a:	f001 fb5b 	bl	2e04 <stop_time>
    total_time=get_time();
    174e:	f001 fb6d 	bl	2e2c <get_time>
    /* get a function of the input to report */
    seedcrc=crc16(results[0].seed1,seedcrc);
    1752:	2100      	movs	r1, #0
    total_time=get_time();
    1754:	4681      	mov	r9, r0
    seedcrc=crc16(results[0].seed1,seedcrc);
    1756:	f9bd 002c 	ldrsh.w	r0, [sp, #44]	; 0x2c
    175a:	f002 f8bb 	bl	38d4 <crc16>
    seedcrc=crc16(results[0].seed2,seedcrc);
    175e:	4601      	mov	r1, r0
    1760:	f9bd 002e 	ldrsh.w	r0, [sp, #46]	; 0x2e
    1764:	f002 f8b6 	bl	38d4 <crc16>
    seedcrc=crc16(results[0].seed3,seedcrc);
    1768:	4601      	mov	r1, r0
    176a:	f9bd 0030 	ldrsh.w	r0, [sp, #48]	; 0x30
    176e:	f002 f8b1 	bl	38d4 <crc16>
    seedcrc=crc16(results[0].size,seedcrc);
    1772:	4601      	mov	r1, r0
    1774:	f9bd 0044 	ldrsh.w	r0, [sp, #68]	; 0x44
    1778:	f002 f8ac 	bl	38d4 <crc16>

    switch (seedcrc) { /* test known output for common seeds */
    177c:	f647 3605 	movw	r6, #31493	; 0x7b05
    1780:	42b0      	cmp	r0, r6
    seedcrc=crc16(results[0].size,seedcrc);
    1782:	9005      	str	r0, [sp, #20]
    switch (seedcrc) { /* test known output for common seeds */
    1784:	f000 8222 	beq.w	1bcc <main+0x6a4>
    1788:	d840      	bhi.n	180c <main+0x2e4>
    178a:	f641 04f2 	movw	r4, #6386	; 0x18f2
    178e:	42a0      	cmp	r0, r4
    1790:	f000 8208 	beq.w	1ba4 <main+0x67c>
    1794:	f644 65af 	movw	r5, #20143	; 0x4eaf
    1798:	42a8      	cmp	r0, r5
    179a:	f040 80d3 	bne.w	1944 <main+0x41c>
            ee_printf("6k validation run parameters for coremark.\n");
            break;
        case 0x4eaf: /* seed1=0x8, seed2=0x8, seed3=0x8, size 400 per algorithm */
            known_id=2;
            ee_printf("Profile generation run parameters for coremark.\n");
            break;
    179e:	f24e 54a4 	movw	r4, #58788	; 0xe5a4
    17a2:	f245 6508 	movw	r5, #22024	; 0x5608
    17a6:	f646 2679 	movw	r6, #27257	; 0x6a79
            ee_printf("Profile generation run parameters for coremark.\n");
    17aa:	4860      	ldr	r0, [pc, #384]	; (192c <main+0x404>)
            break;
    17ac:	9404      	str	r4, [sp, #16]
    17ae:	4627      	mov	r7, r4
    17b0:	9503      	str	r5, [sp, #12]
    17b2:	462c      	mov	r4, r5
    17b4:	9602      	str	r6, [sp, #8]
            ee_printf("Profile generation run parameters for coremark.\n");
    17b6:	f001 fc85 	bl	30c4 <am_sprintf>
            known_id=2;
    17ba:	2302      	movs	r3, #2
            break;
    17bc:	46bb      	mov	fp, r7
    17be:	46a2      	mov	sl, r4
    17c0:	4630      	mov	r0, r6
            known_id=2;
    17c2:	9307      	str	r3, [sp, #28]
            break;
    17c4:	e040      	b.n	1848 <main+0x320>
            results[i].list=core_list_init(results[0].size,results[i].memblock[1],results[i].seed1);
    17c6:	990e      	ldr	r1, [sp, #56]	; 0x38
    17c8:	f7ff fce0 	bl	118c <core_list_init>
    17cc:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    17ce:	9014      	str	r0, [sp, #80]	; 0x50
    17d0:	f003 0402 	and.w	r4, r3, #2
        if (results[i].execs & ID_MATRIX) {
    17d4:	2c00      	cmp	r4, #0
    17d6:	f43f af0d 	beq.w	15f4 <main+0xcc>
            core_init_matrix(results[0].size, results[i].memblock[2], (ee_s32)results[i].seed1 | (((ee_s32)results[i].seed2) << 16), &(results[i].mat) );
    17da:	f9bd b02e 	ldrsh.w	fp, [sp, #46]	; 0x2e
    17de:	f9bd c02c 	ldrsh.w	ip, [sp, #44]	; 0x2c
    17e2:	990f      	ldr	r1, [sp, #60]	; 0x3c
    17e4:	9811      	ldr	r0, [sp, #68]	; 0x44
    17e6:	ea4c 420b 	orr.w	r2, ip, fp, lsl #16
    17ea:	ab15      	add	r3, sp, #84	; 0x54
    17ec:	f001 f9cc 	bl	2b88 <core_init_matrix>
    17f0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
        if (results[i].execs & ID_STATE) {
    17f2:	075a      	lsls	r2, r3, #29
    17f4:	f57f af01 	bpl.w	15fa <main+0xd2>
            core_init_state(results[0].size,results[i].seed1,results[i].memblock[3]);
    17f8:	9a10      	ldr	r2, [sp, #64]	; 0x40
    17fa:	f9bd 102c 	ldrsh.w	r1, [sp, #44]	; 0x2c
    17fe:	9811      	ldr	r0, [sp, #68]	; 0x44
    1800:	f001 fca2 	bl	3148 <core_init_state>
    1804:	e6f9      	b.n	15fa <main+0xd2>
        results[0].execs=ALL_ALGORITHMS_MASK;
    1806:	2007      	movs	r0, #7
    1808:	9013      	str	r0, [sp, #76]	; 0x4c
    180a:	e6b3      	b.n	1574 <main+0x4c>
    switch (seedcrc) { /* test known output for common seeds */
    180c:	9a05      	ldr	r2, [sp, #20]
    180e:	f648 2e02 	movw	lr, #35330	; 0x8a02
    1812:	4572      	cmp	r2, lr
    1814:	f000 81b2 	beq.w	1b7c <main+0x654>
    1818:	f64e 1cf5 	movw	ip, #59893	; 0xe9f5
    181c:	4562      	cmp	r2, ip
    181e:	f040 8091 	bne.w	1944 <main+0x41c>
        case 0xe9f5: /* seed1=0, seed2=0, seed3=0x66, size 666 per algorithm */
            known_id=3;
            ee_printf("2K performance run parameters for coremark.\n");
            break;
    1822:	f648 643a 	movw	r4, #36410	; 0x8e3a
    1826:	f641 75d7 	movw	r5, #8151	; 0x1fd7
    182a:	f24e 7614 	movw	r6, #59156	; 0xe714
            ee_printf("2K performance run parameters for coremark.\n");
    182e:	4840      	ldr	r0, [pc, #256]	; (1930 <main+0x408>)
            break;
    1830:	9404      	str	r4, [sp, #16]
    1832:	4627      	mov	r7, r4
    1834:	9503      	str	r5, [sp, #12]
    1836:	462c      	mov	r4, r5
    1838:	9602      	str	r6, [sp, #8]
            ee_printf("2K performance run parameters for coremark.\n");
    183a:	f001 fc43 	bl	30c4 <am_sprintf>
            known_id=3;
    183e:	2303      	movs	r3, #3
            break;
    1840:	46bb      	mov	fp, r7
    1842:	46a2      	mov	sl, r4
    1844:	4630      	mov	r0, r6
            known_id=3;
    1846:	9307      	str	r3, [sp, #28]
        default:
            total_errors=-1;
            break;
    }
    if (known_id>=0) {
        for (i=0 ; i<default_num_contexts; i++) {
    1848:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 1940 <main+0x418>
    184c:	f8d8 6000 	ldr.w	r6, [r8]
    1850:	2e00      	cmp	r6, #0
    1852:	d07c      	beq.n	194e <main+0x426>
    1854:	2600      	movs	r6, #0
    1856:	f8cd 9018 	str.w	r9, [sp, #24]
    185a:	4634      	mov	r4, r6
    185c:	4681      	mov	r9, r0
    185e:	e016      	b.n	188e <main+0x366>
                (results[i].crcmatrix!=matrix_known_crc[known_id])) {
                ee_printf("[%u]ERROR! matrix crc 0x%04x - should be 0x%04x\n",i,results[i].crcmatrix,matrix_known_crc[known_id]);
                results[i].err++;
            }
            if ((results[i].execs & ID_STATE) &&
                (results[i].crcstate!=state_known_crc[known_id])) {
    1860:	8fea      	ldrh	r2, [r5, #62]	; 0x3e
            if ((results[i].execs & ID_STATE) &&
    1862:	455a      	cmp	r2, fp
    1864:	d04a      	beq.n	18fc <main+0x3d4>
                ee_printf("[%u]ERROR! state crc 0x%04x - should be 0x%04x\n",i,results[i].crcstate,state_known_crc[known_id]);
    1866:	9b04      	ldr	r3, [sp, #16]
    1868:	4832      	ldr	r0, [pc, #200]	; (1934 <main+0x40c>)
    186a:	4621      	mov	r1, r4
    186c:	f001 fc2a 	bl	30c4 <am_sprintf>
                results[i].err++;
    1870:	f8b5 2040 	ldrh.w	r2, [r5, #64]	; 0x40
    1874:	3201      	adds	r2, #1
    1876:	b210      	sxth	r0, r2
    1878:	f8a5 0040 	strh.w	r0, [r5, #64]	; 0x40
        for (i=0 ; i<default_num_contexts; i++) {
    187c:	3401      	adds	r4, #1
    187e:	f8d8 7000 	ldr.w	r7, [r8]
    1882:	b2a4      	uxth	r4, r4
            }
            total_errors+=results[i].err;
    1884:	4406      	add	r6, r0
        for (i=0 ; i<default_num_contexts; i++) {
    1886:	42bc      	cmp	r4, r7
            total_errors+=results[i].err;
    1888:	b236      	sxth	r6, r6
        for (i=0 ; i<default_num_contexts; i++) {
    188a:	f080 8145 	bcs.w	1b18 <main+0x5f0>
            results[i].err=0;
    188e:	0125      	lsls	r5, r4, #4
    1890:	1928      	adds	r0, r5, r4
    1892:	f10d 0e2c 	add.w	lr, sp, #44	; 0x2c
    1896:	eb0e 0780 	add.w	r7, lr, r0, lsl #2
    189a:	2100      	movs	r1, #0
            if ((results[i].execs & ID_LIST) &&
    189c:	6a3a      	ldr	r2, [r7, #32]
            results[i].err=0;
    189e:	f8a7 1040 	strh.w	r1, [r7, #64]	; 0x40
            if ((results[i].execs & ID_LIST) &&
    18a2:	07d3      	lsls	r3, r2, #31
    18a4:	d50c      	bpl.n	18c0 <main+0x398>
                (results[i].crclist!=list_known_crc[known_id])) {
    18a6:	8f7a      	ldrh	r2, [r7, #58]	; 0x3a
            if ((results[i].execs & ID_LIST) &&
    18a8:	454a      	cmp	r2, r9
    18aa:	d009      	beq.n	18c0 <main+0x398>
                ee_printf("[%u]ERROR! list crc 0x%04x - should be 0x%04x\n",i,results[i].crclist,list_known_crc[known_id]);
    18ac:	9b02      	ldr	r3, [sp, #8]
    18ae:	4822      	ldr	r0, [pc, #136]	; (1938 <main+0x410>)
    18b0:	4621      	mov	r1, r4
    18b2:	f001 fc07 	bl	30c4 <am_sprintf>
                results[i].err++;
    18b6:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
    18ba:	3301      	adds	r3, #1
    18bc:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
            if ((results[i].execs & ID_MATRIX) &&
    18c0:	1928      	adds	r0, r5, r4
    18c2:	f10d 0c2c 	add.w	ip, sp, #44	; 0x2c
    18c6:	eb0c 0780 	add.w	r7, ip, r0, lsl #2
    18ca:	6a3b      	ldr	r3, [r7, #32]
    18cc:	0798      	lsls	r0, r3, #30
    18ce:	d50d      	bpl.n	18ec <main+0x3c4>
                (results[i].crcmatrix!=matrix_known_crc[known_id])) {
    18d0:	8fba      	ldrh	r2, [r7, #60]	; 0x3c
            if ((results[i].execs & ID_MATRIX) &&
    18d2:	4552      	cmp	r2, sl
    18d4:	d00a      	beq.n	18ec <main+0x3c4>
                ee_printf("[%u]ERROR! matrix crc 0x%04x - should be 0x%04x\n",i,results[i].crcmatrix,matrix_known_crc[known_id]);
    18d6:	9b03      	ldr	r3, [sp, #12]
    18d8:	4818      	ldr	r0, [pc, #96]	; (193c <main+0x414>)
    18da:	4621      	mov	r1, r4
    18dc:	f001 fbf2 	bl	30c4 <am_sprintf>
                results[i].err++;
    18e0:	f8b7 1040 	ldrh.w	r1, [r7, #64]	; 0x40
    18e4:	6a3b      	ldr	r3, [r7, #32]
    18e6:	3101      	adds	r1, #1
    18e8:	f8a7 1040 	strh.w	r1, [r7, #64]	; 0x40
                (results[i].crcstate!=state_known_crc[known_id])) {
    18ec:	4425      	add	r5, r4
    18ee:	f10d 0e2c 	add.w	lr, sp, #44	; 0x2c
            if ((results[i].execs & ID_STATE) &&
    18f2:	f013 0f04 	tst.w	r3, #4
                (results[i].crcstate!=state_known_crc[known_id])) {
    18f6:	eb0e 0585 	add.w	r5, lr, r5, lsl #2
            if ((results[i].execs & ID_STATE) &&
    18fa:	d1b1      	bne.n	1860 <main+0x338>
    18fc:	f9b5 0040 	ldrsh.w	r0, [r5, #64]	; 0x40
    1900:	e7bc      	b.n	187c <main+0x354>
    if ((results[0].seed1==1) && (results[0].seed2==0) && (results[0].seed3==0)) { /* perfromance run */
    1902:	2901      	cmp	r1, #1
    1904:	f47f ae3f 	bne.w	1586 <main+0x5e>
    1908:	f9bd 2030 	ldrsh.w	r2, [sp, #48]	; 0x30
    190c:	2a00      	cmp	r2, #0
    190e:	f47f ae3a 	bne.w	1586 <main+0x5e>
        results[0].seed1=0x3415;
    1912:	f243 4415 	movw	r4, #13333	; 0x3415
        results[0].seed3=0x66;
    1916:	2566      	movs	r5, #102	; 0x66
        results[0].seed1=0x3415;
    1918:	f8ad 402c 	strh.w	r4, [sp, #44]	; 0x2c
        results[0].seed2=0x3415;
    191c:	f8ad 402e 	strh.w	r4, [sp, #46]	; 0x2e
        results[0].seed3=0x66;
    1920:	f8ad 5030 	strh.w	r5, [sp, #48]	; 0x30
    1924:	e62f      	b.n	1586 <main+0x5e>
    1926:	bf00      	nop
    1928:	3ff00000 	.word	0x3ff00000
    192c:	00005308 	.word	0x00005308
    1930:	0000533c 	.word	0x0000533c
    1934:	000053fc 	.word	0x000053fc
    1938:	00005398 	.word	0x00005398
    193c:	000053c8 	.word	0x000053c8
    1940:	10001000 	.word	0x10001000
    ee_s16 known_id=-1,total_errors=0;
    1944:	f04f 36ff 	mov.w	r6, #4294967295
    1948:	f8df 832c 	ldr.w	r8, [pc, #812]	; 1c78 <main+0x750>
    194c:	9607      	str	r6, [sp, #28]
        }
    }
    total_errors+=check_data_types();
    194e:	f002 f85b 	bl	3a08 <check_data_types>
    /* and report results */
    ee_printf("CoreMark Size    : %lu\n",(ee_u32)results[0].size);
    1952:	9911      	ldr	r1, [sp, #68]	; 0x44
    total_errors+=check_data_types();
    1954:	4406      	add	r6, r0
    ee_printf("CoreMark Size    : %lu\n",(ee_u32)results[0].size);
    1956:	48ac      	ldr	r0, [pc, #688]	; (1c08 <main+0x6e0>)
    1958:	f001 fbb4 	bl	30c4 <am_sprintf>
    ee_printf("Total ticks      : %lu\n",(ee_u32)total_time);
    195c:	4649      	mov	r1, r9
    195e:	48ab      	ldr	r0, [pc, #684]	; (1c0c <main+0x6e4>)
    1960:	f001 fbb0 	bl	30c4 <am_sprintf>
#if HAS_FLOAT
    ee_printf("Total time (secs): %f\n",time_in_secs(total_time));
    1964:	4648      	mov	r0, r9
    1966:	f001 fa6b 	bl	2e40 <time_in_secs>
    196a:	4602      	mov	r2, r0
    196c:	460b      	mov	r3, r1
    196e:	48a8      	ldr	r0, [pc, #672]	; (1c10 <main+0x6e8>)
    1970:	f001 fba8 	bl	30c4 <am_sprintf>
    if (time_in_secs(total_time) > 0)
    1974:	4648      	mov	r0, r9
    1976:	f001 fa63 	bl	2e40 <time_in_secs>
    197a:	2200      	movs	r2, #0
    197c:	2300      	movs	r3, #0
    total_errors+=check_data_types();
    197e:	b2b6      	uxth	r6, r6
    if (time_in_secs(total_time) > 0)
    1980:	f7fe ffc6 	bl	910 <__aeabi_dcmpgt>
    1984:	b1b0      	cbz	r0, 19b4 <main+0x48c>
        ee_printf("Iterations/Sec   : %f\n",default_num_contexts*results[0].iterations/time_in_secs(total_time));
    1986:	9912      	ldr	r1, [sp, #72]	; 0x48
    1988:	f8d8 0000 	ldr.w	r0, [r8]
    198c:	fb00 f001 	mul.w	r0, r0, r1
    1990:	f7fe fcb8 	bl	304 <__aeabi_ui2d>
    1994:	4683      	mov	fp, r0
    1996:	4648      	mov	r0, r9
    1998:	468a      	mov	sl, r1
    199a:	f001 fa51 	bl	2e40 <time_in_secs>
    199e:	4602      	mov	r2, r0
    19a0:	460b      	mov	r3, r1
    19a2:	4658      	mov	r0, fp
    19a4:	4651      	mov	r1, sl
    19a6:	f7fe fe4d 	bl	644 <__aeabi_ddiv>
    19aa:	4602      	mov	r2, r0
    19ac:	460b      	mov	r3, r1
    19ae:	4899      	ldr	r0, [pc, #612]	; (1c14 <main+0x6ec>)
    19b0:	f001 fb88 	bl	30c4 <am_sprintf>
#else
    ee_printf("Total time (secs): %d\n",time_in_secs(total_time));
    if (time_in_secs(total_time) > 0)
        ee_printf("Iterations/Sec   : %d\n",default_num_contexts*results[0].iterations/time_in_secs(total_time));
#endif
    if (time_in_secs(total_time) < 10) {
    19b4:	4648      	mov	r0, r9
    19b6:	f001 fa43 	bl	2e40 <time_in_secs>
    19ba:	2200      	movs	r2, #0
    19bc:	4b96      	ldr	r3, [pc, #600]	; (1c18 <main+0x6f0>)
    19be:	f7fe ff89 	bl	8d4 <__aeabi_dcmplt>
    19c2:	2800      	cmp	r0, #0
    19c4:	f040 80ab 	bne.w	1b1e <main+0x5f6>
    total_errors+=check_data_types();
    19c8:	b235      	sxth	r5, r6
        ee_printf("ERROR! Must execute for at least 10 secs for a valid result!\n");
        total_errors++;
    }

    ee_printf("Iterations       : %lu\n",(ee_u32)default_num_contexts*results[0].iterations);
    19ca:	9a12      	ldr	r2, [sp, #72]	; 0x48
    19cc:	f8d8 1000 	ldr.w	r1, [r8]
    19d0:	4892      	ldr	r0, [pc, #584]	; (1c1c <main+0x6f4>)
    19d2:	fb01 f102 	mul.w	r1, r1, r2
    19d6:	f001 fb75 	bl	30c4 <am_sprintf>
    ee_printf("Compiler version : %s\n",COMPILER_VERSION);
    19da:	4991      	ldr	r1, [pc, #580]	; (1c20 <main+0x6f8>)
    19dc:	4891      	ldr	r0, [pc, #580]	; (1c24 <main+0x6fc>)
    19de:	f001 fb71 	bl	30c4 <am_sprintf>
//  ee_printf("Compiler flags   : %s\n",COMPILER_FLAGS);
#if (MULTITHREAD>1)
    ee_printf("Parallel %s : %d\n",PARALLEL_METHOD,default_num_contexts);
#endif
    ee_printf("Memory location  : %s\n",MEM_LOCATION);
    19e2:	4991      	ldr	r1, [pc, #580]	; (1c28 <main+0x700>)
    19e4:	4891      	ldr	r0, [pc, #580]	; (1c2c <main+0x704>)
    19e6:	f001 fb6d 	bl	30c4 <am_sprintf>
    /* output for verification */
    ee_printf("seedcrc          : 0x%04x\n",seedcrc);
    19ea:	9905      	ldr	r1, [sp, #20]
    19ec:	4890      	ldr	r0, [pc, #576]	; (1c30 <main+0x708>)
    19ee:	f001 fb69 	bl	30c4 <am_sprintf>
    if (results[0].execs & ID_LIST)
    19f2:	9f13      	ldr	r7, [sp, #76]	; 0x4c
    19f4:	07f9      	lsls	r1, r7, #31
    19f6:	d516      	bpl.n	1a26 <main+0x4fe>
        for (i=0 ; i<default_num_contexts; i++)
    19f8:	f8d8 4000 	ldr.w	r4, [r8]
    19fc:	b19c      	cbz	r4, 1a26 <main+0x4fe>
            ee_printf("[%d]crclist       : 0x%04x\n",i,results[i].crclist);
    19fe:	4e8d      	ldr	r6, [pc, #564]	; (1c34 <main+0x70c>)
        for (i=0 ; i<default_num_contexts; i++)
    1a00:	2700      	movs	r7, #0
            ee_printf("[%d]crclist       : 0x%04x\n",i,results[i].crclist);
    1a02:	eb07 1007 	add.w	r0, r7, r7, lsl #4
    1a06:	f10d 0c2c 	add.w	ip, sp, #44	; 0x2c
    1a0a:	eb0c 0e80 	add.w	lr, ip, r0, lsl #2
    1a0e:	4639      	mov	r1, r7
    1a10:	f8be 203a 	ldrh.w	r2, [lr, #58]	; 0x3a
    1a14:	4630      	mov	r0, r6
    1a16:	f001 fb55 	bl	30c4 <am_sprintf>
        for (i=0 ; i<default_num_contexts; i++)
    1a1a:	3701      	adds	r7, #1
    1a1c:	f8d8 1000 	ldr.w	r1, [r8]
    1a20:	b2bf      	uxth	r7, r7
    1a22:	428f      	cmp	r7, r1
    1a24:	d3ed      	bcc.n	1a02 <main+0x4da>
    if (results[0].execs & ID_MATRIX)
    1a26:	9f13      	ldr	r7, [sp, #76]	; 0x4c
    1a28:	07ba      	lsls	r2, r7, #30
    1a2a:	d518      	bpl.n	1a5e <main+0x536>
        for (i=0 ; i<default_num_contexts; i++)
    1a2c:	f8d8 2000 	ldr.w	r2, [r8]
    1a30:	2a00      	cmp	r2, #0
    1a32:	f000 80df 	beq.w	1bf4 <main+0x6cc>
            ee_printf("[%d]crcmatrix     : 0x%04x\n",i,results[i].crcmatrix);
    1a36:	4e80      	ldr	r6, [pc, #512]	; (1c38 <main+0x710>)
        for (i=0 ; i<default_num_contexts; i++)
    1a38:	2400      	movs	r4, #0
            ee_printf("[%d]crcmatrix     : 0x%04x\n",i,results[i].crcmatrix);
    1a3a:	eb04 1b04 	add.w	fp, r4, r4, lsl #4
    1a3e:	f10d 0a2c 	add.w	sl, sp, #44	; 0x2c
    1a42:	eb0a 038b 	add.w	r3, sl, fp, lsl #2
    1a46:	4621      	mov	r1, r4
    1a48:	8f9a      	ldrh	r2, [r3, #60]	; 0x3c
    1a4a:	4630      	mov	r0, r6
    1a4c:	f001 fb3a 	bl	30c4 <am_sprintf>
        for (i=0 ; i<default_num_contexts; i++)
    1a50:	3401      	adds	r4, #1
    1a52:	f8d8 1000 	ldr.w	r1, [r8]
    1a56:	b2a4      	uxth	r4, r4
    1a58:	428c      	cmp	r4, r1
    1a5a:	d3ee      	bcc.n	1a3a <main+0x512>
    1a5c:	9f13      	ldr	r7, [sp, #76]	; 0x4c
    if (results[0].execs & ID_STATE)
        for (i=0 ; i<default_num_contexts; i++)
    1a5e:	f8d8 2000 	ldr.w	r2, [r8]
    if (results[0].execs & ID_STATE)
    1a62:	f017 0f04 	tst.w	r7, #4
    1a66:	d014      	beq.n	1a92 <main+0x56a>
        for (i=0 ; i<default_num_contexts; i++)
    1a68:	b33a      	cbz	r2, 1aba <main+0x592>
            ee_printf("[%d]crcstate      : 0x%04x\n",i,results[i].crcstate);
    1a6a:	4e74      	ldr	r6, [pc, #464]	; (1c3c <main+0x714>)
        for (i=0 ; i<default_num_contexts; i++)
    1a6c:	2400      	movs	r4, #0
            ee_printf("[%d]crcstate      : 0x%04x\n",i,results[i].crcstate);
    1a6e:	eb04 1004 	add.w	r0, r4, r4, lsl #4
    1a72:	f10d 0c2c 	add.w	ip, sp, #44	; 0x2c
    1a76:	eb0c 0e80 	add.w	lr, ip, r0, lsl #2
    1a7a:	4621      	mov	r1, r4
    1a7c:	f8be 203e 	ldrh.w	r2, [lr, #62]	; 0x3e
    1a80:	4630      	mov	r0, r6
    1a82:	f001 fb1f 	bl	30c4 <am_sprintf>
        for (i=0 ; i<default_num_contexts; i++)
    1a86:	3401      	adds	r4, #1
    1a88:	f8d8 2000 	ldr.w	r2, [r8]
    1a8c:	b2a4      	uxth	r4, r4
    1a8e:	4294      	cmp	r4, r2
    1a90:	d3ed      	bcc.n	1a6e <main+0x546>
    for (i=0 ; i<default_num_contexts; i++)
    1a92:	b192      	cbz	r2, 1aba <main+0x592>
        ee_printf("[%d]crcfinal      : 0x%04x\n",i,results[i].crc);
    1a94:	4f6a      	ldr	r7, [pc, #424]	; (1c40 <main+0x718>)
    for (i=0 ; i<default_num_contexts; i++)
    1a96:	2600      	movs	r6, #0
        ee_printf("[%d]crcfinal      : 0x%04x\n",i,results[i].crc);
    1a98:	eb06 1b06 	add.w	fp, r6, r6, lsl #4
    1a9c:	aa0b      	add	r2, sp, #44	; 0x2c
    1a9e:	eb02 0a8b 	add.w	sl, r2, fp, lsl #2
    1aa2:	4631      	mov	r1, r6
    1aa4:	f8ba 2038 	ldrh.w	r2, [sl, #56]	; 0x38
    1aa8:	4638      	mov	r0, r7
    1aaa:	f001 fb0b 	bl	30c4 <am_sprintf>
    for (i=0 ; i<default_num_contexts; i++)
    1aae:	3601      	adds	r6, #1
    1ab0:	f8d8 3000 	ldr.w	r3, [r8]
    1ab4:	b2b6      	uxth	r6, r6
    1ab6:	429e      	cmp	r6, r3
    1ab8:	d3ee      	bcc.n	1a98 <main+0x570>
    if (total_errors==0) {
    1aba:	2d00      	cmp	r5, #0
    1abc:	d035      	beq.n	1b2a <main+0x602>
            ee_printf("\n");
        }
#endif
    }
    if (total_errors>0)
        ee_printf("Errors detected\n");
    1abe:	bfcc      	ite	gt
    1ac0:	4860      	ldrgt	r0, [pc, #384]	; (1c44 <main+0x71c>)
    if (total_errors<0)
        ee_printf("Cannot validate operation for these seed values, please compare with results on a known platform.\n");
    1ac2:	4861      	ldrle	r0, [pc, #388]	; (1c48 <main+0x720>)
    1ac4:	f001 fafe 	bl	30c4 <am_sprintf>
        portable_free(results[i].memblock[0]);
#endif


#if AM_PRINT_RESULTS
    float CMResult = default_num_contexts*results[0].iterations/time_in_secs(total_time) / (double)AM_CORECLK_MHZ;
    1ac8:	9b12      	ldr	r3, [sp, #72]	; 0x48
    1aca:	f8d8 0000 	ldr.w	r0, [r8]
    1ace:	fb00 f003 	mul.w	r0, r0, r3
    1ad2:	f7fe fc17 	bl	304 <__aeabi_ui2d>
    1ad6:	4680      	mov	r8, r0
    1ad8:	4648      	mov	r0, r9
    1ada:	468b      	mov	fp, r1
    1adc:	f001 f9b0 	bl	2e40 <time_in_secs>
    1ae0:	4602      	mov	r2, r0
    1ae2:	460b      	mov	r3, r1
    1ae4:	4640      	mov	r0, r8
    1ae6:	4659      	mov	r1, fp
    1ae8:	f7fe fdac 	bl	644 <__aeabi_ddiv>
    1aec:	2200      	movs	r2, #0
    1aee:	4b57      	ldr	r3, [pc, #348]	; (1c4c <main+0x724>)
    1af0:	f7fe fda8 	bl	644 <__aeabi_ddiv>
    1af4:	f7fe ff36 	bl	964 <__aeabi_d2f>
    ee_printf("CM/MHz=%.3f.\n", CMResult);
    1af8:	f7fe fc26 	bl	348 <__aeabi_f2d>
    1afc:	4602      	mov	r2, r0
    1afe:	460b      	mov	r3, r1
    1b00:	4853      	ldr	r0, [pc, #332]	; (1c50 <main+0x728>)
    1b02:	f001 fadf 	bl	30c4 <am_sprintf>

#endif //AM_PRINT_RESULTS

    /* And last call any target specific code for finalizing */
    portable_fini(&(results[0].port));
    1b06:	f10d 006e 	add.w	r0, sp, #110	; 0x6e
    1b0a:	f001 fa45 	bl	2f98 <portable_fini>

    return MAIN_RETURN_VAL;
}
    1b0e:	2000      	movs	r0, #0
    1b10:	f60d 0d44 	addw	sp, sp, #2116	; 0x844
    1b14:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1b18:	f8dd 9018 	ldr.w	r9, [sp, #24]
    1b1c:	e717      	b.n	194e <main+0x426>
        ee_printf("ERROR! Must execute for at least 10 secs for a valid result!\n");
    1b1e:	484d      	ldr	r0, [pc, #308]	; (1c54 <main+0x72c>)
    1b20:	f001 fad0 	bl	30c4 <am_sprintf>
        total_errors++;
    1b24:	1c73      	adds	r3, r6, #1
    1b26:	b21d      	sxth	r5, r3
    1b28:	e74f      	b.n	19ca <main+0x4a2>
        ee_printf("Correct operation validated. See readme.txt for run and reporting rules.\n");
    1b2a:	484b      	ldr	r0, [pc, #300]	; (1c58 <main+0x730>)
    1b2c:	f001 faca 	bl	30c4 <am_sprintf>
        if (known_id==3) {
    1b30:	9d07      	ldr	r5, [sp, #28]
    1b32:	2d03      	cmp	r5, #3
    1b34:	d1c8      	bne.n	1ac8 <main+0x5a0>
            ee_printf("CoreMark 1.0 : %f / %s %s",default_num_contexts*results[0].iterations/time_in_secs(total_time),COMPILER_VERSION,COMPILER_FLAGS);
    1b36:	9912      	ldr	r1, [sp, #72]	; 0x48
    1b38:	f8d8 0000 	ldr.w	r0, [r8]
    1b3c:	4e38      	ldr	r6, [pc, #224]	; (1c20 <main+0x6f8>)
    1b3e:	fb00 f001 	mul.w	r0, r0, r1
    1b42:	f7fe fbdf 	bl	304 <__aeabi_ui2d>
    1b46:	4604      	mov	r4, r0
    1b48:	4648      	mov	r0, r9
    1b4a:	460f      	mov	r7, r1
    1b4c:	f001 f978 	bl	2e40 <time_in_secs>
    1b50:	4602      	mov	r2, r0
    1b52:	460b      	mov	r3, r1
    1b54:	4620      	mov	r0, r4
    1b56:	4639      	mov	r1, r7
    1b58:	f7fe fd74 	bl	644 <__aeabi_ddiv>
    1b5c:	4a3f      	ldr	r2, [pc, #252]	; (1c5c <main+0x734>)
    1b5e:	9201      	str	r2, [sp, #4]
    1b60:	460b      	mov	r3, r1
    1b62:	4602      	mov	r2, r0
    1b64:	9600      	str	r6, [sp, #0]
    1b66:	483e      	ldr	r0, [pc, #248]	; (1c60 <main+0x738>)
    1b68:	f001 faac 	bl	30c4 <am_sprintf>
            ee_printf(" / %s",MEM_LOCATION);
    1b6c:	492e      	ldr	r1, [pc, #184]	; (1c28 <main+0x700>)
    1b6e:	483d      	ldr	r0, [pc, #244]	; (1c64 <main+0x73c>)
    1b70:	f001 faa8 	bl	30c4 <am_sprintf>
            ee_printf("\n");
    1b74:	483c      	ldr	r0, [pc, #240]	; (1c68 <main+0x740>)
    1b76:	f001 faa5 	bl	30c4 <am_sprintf>
    1b7a:	e7a5      	b.n	1ac8 <main+0x5a0>
            break;
    1b7c:	f645 6447 	movw	r4, #24135	; 0x5e47
    1b80:	f64b 6552 	movw	r5, #48722	; 0xbe52
    1b84:	f24d 46b0 	movw	r6, #54448	; 0xd4b0
            ee_printf("6k performance run parameters for coremark.\n");
    1b88:	4838      	ldr	r0, [pc, #224]	; (1c6c <main+0x744>)
            break;
    1b8a:	9404      	str	r4, [sp, #16]
    1b8c:	4627      	mov	r7, r4
    1b8e:	9503      	str	r5, [sp, #12]
    1b90:	462c      	mov	r4, r5
    1b92:	9602      	str	r6, [sp, #8]
            ee_printf("6k performance run parameters for coremark.\n");
    1b94:	f001 fa96 	bl	30c4 <am_sprintf>
            known_id=0;
    1b98:	2100      	movs	r1, #0
            break;
    1b9a:	46bb      	mov	fp, r7
    1b9c:	46a2      	mov	sl, r4
    1b9e:	4630      	mov	r0, r6
            known_id=0;
    1ba0:	9107      	str	r1, [sp, #28]
            break;
    1ba2:	e651      	b.n	1848 <main+0x320>
            break;
    1ba4:	f648 5484 	movw	r4, #36228	; 0x8d84
    1ba8:	f240 7547 	movw	r5, #1863	; 0x747
    1bac:	f24e 36c1 	movw	r6, #58305	; 0xe3c1
            ee_printf("2K validation run parameters for coremark.\n");
    1bb0:	482f      	ldr	r0, [pc, #188]	; (1c70 <main+0x748>)
            break;
    1bb2:	9404      	str	r4, [sp, #16]
    1bb4:	4627      	mov	r7, r4
    1bb6:	9503      	str	r5, [sp, #12]
    1bb8:	462c      	mov	r4, r5
    1bba:	9602      	str	r6, [sp, #8]
            ee_printf("2K validation run parameters for coremark.\n");
    1bbc:	f001 fa82 	bl	30c4 <am_sprintf>
            known_id=4;
    1bc0:	2104      	movs	r1, #4
            break;
    1bc2:	46bb      	mov	fp, r7
    1bc4:	46a2      	mov	sl, r4
    1bc6:	4630      	mov	r0, r6
            known_id=4;
    1bc8:	9107      	str	r1, [sp, #28]
            break;
    1bca:	e63d      	b.n	1848 <main+0x320>
            break;
    1bcc:	f643 14bf 	movw	r4, #14783	; 0x39bf
    1bd0:	f241 1599 	movw	r5, #4505	; 0x1199
    1bd4:	f44f 564d 	mov.w	r6, #13120	; 0x3340
            ee_printf("6k validation run parameters for coremark.\n");
    1bd8:	4826      	ldr	r0, [pc, #152]	; (1c74 <main+0x74c>)
            break;
    1bda:	9404      	str	r4, [sp, #16]
    1bdc:	4627      	mov	r7, r4
    1bde:	9503      	str	r5, [sp, #12]
    1be0:	462c      	mov	r4, r5
    1be2:	9602      	str	r6, [sp, #8]
            ee_printf("6k validation run parameters for coremark.\n");
    1be4:	f001 fa6e 	bl	30c4 <am_sprintf>
            known_id=1;
    1be8:	2301      	movs	r3, #1
            break;
    1bea:	46bb      	mov	fp, r7
    1bec:	46a2      	mov	sl, r4
    1bee:	4630      	mov	r0, r6
            known_id=1;
    1bf0:	9307      	str	r3, [sp, #28]
            break;
    1bf2:	e629      	b.n	1848 <main+0x320>
    if (results[0].execs & ID_STATE)
    1bf4:	077b      	lsls	r3, r7, #29
    1bf6:	f53f af60 	bmi.w	1aba <main+0x592>
    1bfa:	e74a      	b.n	1a92 <main+0x56a>
        if (i==0) res->crclist=res->crc;
    1bfc:	f8ad b066 	strh.w	fp, [sp, #102]	; 0x66
    1c00:	e568      	b.n	16d4 <main+0x1ac>
    1c02:	f8ad 0066 	strh.w	r0, [sp, #102]	; 0x66
    1c06:	e57b      	b.n	1700 <main+0x1d8>
    1c08:	0000542c 	.word	0x0000542c
    1c0c:	00005444 	.word	0x00005444
    1c10:	0000545c 	.word	0x0000545c
    1c14:	00005474 	.word	0x00005474
    1c18:	40240000 	.word	0x40240000
    1c1c:	000054cc 	.word	0x000054cc
    1c20:	000054e4 	.word	0x000054e4
    1c24:	0000552c 	.word	0x0000552c
    1c28:	00005544 	.word	0x00005544
    1c2c:	0000554c 	.word	0x0000554c
    1c30:	00005564 	.word	0x00005564
    1c34:	00005580 	.word	0x00005580
    1c38:	0000559c 	.word	0x0000559c
    1c3c:	000055b8 	.word	0x000055b8
    1c40:	000055d4 	.word	0x000055d4
    1c44:	0000566c 	.word	0x0000566c
    1c48:	00005680 	.word	0x00005680
    1c4c:	40380000 	.word	0x40380000
    1c50:	000056e4 	.word	0x000056e4
    1c54:	0000548c 	.word	0x0000548c
    1c58:	000055f0 	.word	0x000055f0
    1c5c:	00005658 	.word	0x00005658
    1c60:	0000563c 	.word	0x0000563c
    1c64:	00005664 	.word	0x00005664
    1c68:	00005740 	.word	0x00005740
    1c6c:	000052ac 	.word	0x000052ac
    1c70:	0000536c 	.word	0x0000536c
    1c74:	000052dc 	.word	0x000052dc
    1c78:	10001000 	.word	0x10001000

00001c7c <matrix_test>:
    4 - Multiply a matrix by a matrix.
    5 - Add a constant value to all elements of a matrix.

    After the last step, matrix A is back to original contents.
*/
ee_s16 matrix_test(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B, MATDAT val) {
    1c7c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1c80:	b091      	sub	sp, #68	; 0x44
    1c82:	9303      	str	r3, [sp, #12]
    1c84:	f9bd a068 	ldrsh.w	sl, [sp, #104]	; 0x68
    1c88:	9109      	str	r1, [sp, #36]	; 0x24
    1c8a:	920b      	str	r2, [sp, #44]	; 0x2c
/* Function: matrix_add_const
    Add a constant value to all elements of a matrix.
*/
void matrix_add_const(ee_u32 N, MATDAT *A, MATDAT val) {
    ee_u32 i,j;
    for (i=0; i<N; i++) {
    1c8c:	4603      	mov	r3, r0
    1c8e:	9008      	str	r0, [sp, #32]
    1c90:	2800      	cmp	r0, #0
    1c92:	f000 8754 	beq.w	2b3e <matrix_test+0xec2>
    1c96:	ea6f 500a 	mvn.w	r0, sl, lsl #20
    1c9a:	ea6f 5910 	mvn.w	r9, r0, lsr #20
    1c9e:	f04f 0e00 	mov.w	lr, #0
    1ca2:	fa1f f18a 	uxth.w	r1, sl
    1ca6:	005e      	lsls	r6, r3, #1
    1ca8:	1e5f      	subs	r7, r3, #1
    1caa:	f8cd a03c 	str.w	sl, [sp, #60]	; 0x3c
    1cae:	910c      	str	r1, [sp, #48]	; 0x30
    1cb0:	4694      	mov	ip, r2
    1cb2:	4618      	mov	r0, r3
    1cb4:	970a      	str	r7, [sp, #40]	; 0x28
    1cb6:	f8cd 9034 	str.w	r9, [sp, #52]	; 0x34
    1cba:	920e      	str	r2, [sp, #56]	; 0x38
    1cbc:	46f3      	mov	fp, lr
    1cbe:	46f2      	mov	sl, lr
    1cc0:	9605      	str	r6, [sp, #20]
    1cc2:	4614      	mov	r4, r2
    1cc4:	e0d7      	b.n	1e76 <matrix_test+0x1fa>
        for (j=0; j<N; j++) {
            A[i*N+j] += val;
    1cc6:	f8bc 8000 	ldrh.w	r8, [ip]
    for (i=0; i<N; i++) {
    1cca:	4602      	mov	r2, r0
            A[i*N+j] += val;
    1ccc:	4488      	add	r8, r1
    1cce:	2a01      	cmp	r2, #1
    1cd0:	f8ac 8000 	strh.w	r8, [ip]
    1cd4:	f000 80e6 	beq.w	1ea4 <matrix_test+0x228>
    1cd8:	f8bc 9002 	ldrh.w	r9, [ip, #2]
    1cdc:	2a02      	cmp	r2, #2
    1cde:	4489      	add	r9, r1
    1ce0:	f8ac 9002 	strh.w	r9, [ip, #2]
    1ce4:	f000 80de 	beq.w	1ea4 <matrix_test+0x228>
    1ce8:	f8bc e004 	ldrh.w	lr, [ip, #4]
    1cec:	2a04      	cmp	r2, #4
    1cee:	448e      	add	lr, r1
    1cf0:	f8ac e004 	strh.w	lr, [ip, #4]
    1cf4:	f040 80d8 	bne.w	1ea8 <matrix_test+0x22c>
    1cf8:	f8bc 5006 	ldrh.w	r5, [ip, #6]
    1cfc:	440d      	add	r5, r1
    1cfe:	f8ac 5006 	strh.w	r5, [ip, #6]
        for (j=0; j<N; j++) {
    1d02:	4613      	mov	r3, r2
    1d04:	4290      	cmp	r0, r2
    1d06:	f000 80af 	beq.w	1e68 <matrix_test+0x1ec>
    1d0a:	1a86      	subs	r6, r0, r2
    1d0c:	1f37      	subs	r7, r6, #4
    1d0e:	9604      	str	r6, [sp, #16]
    1d10:	9e0a      	ldr	r6, [sp, #40]	; 0x28
    1d12:	08bd      	lsrs	r5, r7, #2
    1d14:	1c6f      	adds	r7, r5, #1
    1d16:	1ab6      	subs	r6, r6, r2
    1d18:	9701      	str	r7, [sp, #4]
    1d1a:	2e02      	cmp	r6, #2
    1d1c:	ea4f 0787 	mov.w	r7, r7, lsl #2
    1d20:	9702      	str	r7, [sp, #8]
    1d22:	f240 8088 	bls.w	1e36 <matrix_test+0x1ba>
    1d26:	445a      	add	r2, fp
    1d28:	eb04 0642 	add.w	r6, r4, r2, lsl #1
            A[i*N+j] += val;
    1d2c:	f854 8012 	ldr.w	r8, [r4, r2, lsl #1]
    1d30:	9206      	str	r2, [sp, #24]
    1d32:	eb01 0208 	add.w	r2, r1, r8
    1d36:	9207      	str	r2, [sp, #28]
    1d38:	6872      	ldr	r2, [r6, #4]
    1d3a:	2700      	movs	r7, #0
    1d3c:	eb01 0e02 	add.w	lr, r1, r2
    1d40:	9a07      	ldr	r2, [sp, #28]
    1d42:	46b9      	mov	r9, r7
    1d44:	f36e 090f 	bfi	r9, lr, #0, #16
    1d48:	f362 070f 	bfi	r7, r2, #0, #16
    1d4c:	eb01 4818 	add.w	r8, r1, r8, lsr #16
    1d50:	f005 0e01 	and.w	lr, r5, #1
    1d54:	9d06      	ldr	r5, [sp, #24]
    1d56:	6872      	ldr	r2, [r6, #4]
    1d58:	f368 471f 	bfi	r7, r8, #16, #16
    1d5c:	f844 7015 	str.w	r7, [r4, r5, lsl #1]
    1d60:	9d01      	ldr	r5, [sp, #4]
    1d62:	eb01 4212 	add.w	r2, r1, r2, lsr #16
    1d66:	2701      	movs	r7, #1
    1d68:	f362 491f 	bfi	r9, r2, #16, #16
    1d6c:	42bd      	cmp	r5, r7
    1d6e:	f106 0208 	add.w	r2, r6, #8
    1d72:	f8c6 9004 	str.w	r9, [r6, #4]
    1d76:	d959      	bls.n	1e2c <matrix_test+0x1b0>
    1d78:	f1be 0f00 	cmp.w	lr, #0
    1d7c:	d01c      	beq.n	1db8 <matrix_test+0x13c>
    1d7e:	6817      	ldr	r7, [r2, #0]
    1d80:	6856      	ldr	r6, [r2, #4]
    1d82:	2500      	movs	r5, #0
    1d84:	eb01 0907 	add.w	r9, r1, r7
    1d88:	46ae      	mov	lr, r5
    1d8a:	eb01 0806 	add.w	r8, r1, r6
    1d8e:	eb01 4717 	add.w	r7, r1, r7, lsr #16
    1d92:	eb01 4616 	add.w	r6, r1, r6, lsr #16
    1d96:	f369 050f 	bfi	r5, r9, #0, #16
    1d9a:	f368 0e0f 	bfi	lr, r8, #0, #16
    1d9e:	f367 451f 	bfi	r5, r7, #16, #16
    1da2:	f366 4e1f 	bfi	lr, r6, #16, #16
    1da6:	e882 4020 	stmia.w	r2, {r5, lr}
    1daa:	9d01      	ldr	r5, [sp, #4]
    1dac:	2702      	movs	r7, #2
    1dae:	42bd      	cmp	r5, r7
    1db0:	4616      	mov	r6, r2
    1db2:	f102 0208 	add.w	r2, r2, #8
    1db6:	d939      	bls.n	1e2c <matrix_test+0x1b0>
    1db8:	9306      	str	r3, [sp, #24]
    1dba:	9007      	str	r0, [sp, #28]
    1dbc:	68b5      	ldr	r5, [r6, #8]
    1dbe:	f106 0e08 	add.w	lr, r6, #8
    1dc2:	68f6      	ldr	r6, [r6, #12]
    1dc4:	2300      	movs	r3, #0
    1dc6:	1988      	adds	r0, r1, r6
    1dc8:	eb01 0905 	add.w	r9, r1, r5
    1dcc:	4698      	mov	r8, r3
    1dce:	eb01 4616 	add.w	r6, r1, r6, lsr #16
    1dd2:	f360 080f 	bfi	r8, r0, #0, #16
    1dd6:	f369 030f 	bfi	r3, r9, #0, #16
    1dda:	eb01 4515 	add.w	r5, r1, r5, lsr #16
    1dde:	f366 481f 	bfi	r8, r6, #16, #16
    1de2:	f365 431f 	bfi	r3, r5, #16, #16
    1de6:	e882 0108 	stmia.w	r2, {r3, r8}
    1dea:	f10e 0608 	add.w	r6, lr, #8
    1dee:	f8de e008 	ldr.w	lr, [lr, #8]
    1df2:	6870      	ldr	r0, [r6, #4]
    1df4:	2300      	movs	r3, #0
    1df6:	eb01 090e 	add.w	r9, r1, lr
    1dfa:	4698      	mov	r8, r3
    1dfc:	eb01 4e1e 	add.w	lr, r1, lr, lsr #16
    1e00:	f369 030f 	bfi	r3, r9, #0, #16
    1e04:	f36e 431f 	bfi	r3, lr, #16, #16
    1e08:	180d      	adds	r5, r1, r0
    1e0a:	6093      	str	r3, [r2, #8]
    1e0c:	9b01      	ldr	r3, [sp, #4]
    1e0e:	f365 080f 	bfi	r8, r5, #0, #16
    1e12:	eb01 4010 	add.w	r0, r1, r0, lsr #16
    1e16:	3702      	adds	r7, #2
    1e18:	f360 481f 	bfi	r8, r0, #16, #16
    1e1c:	42bb      	cmp	r3, r7
    1e1e:	f8c2 800c 	str.w	r8, [r2, #12]
    1e22:	f102 0210 	add.w	r2, r2, #16
    1e26:	d8c9      	bhi.n	1dbc <matrix_test+0x140>
    1e28:	9b06      	ldr	r3, [sp, #24]
    1e2a:	9807      	ldr	r0, [sp, #28]
    1e2c:	9a02      	ldr	r2, [sp, #8]
    1e2e:	9e04      	ldr	r6, [sp, #16]
    1e30:	42b2      	cmp	r2, r6
    1e32:	4413      	add	r3, r2
    1e34:	d018      	beq.n	1e68 <matrix_test+0x1ec>
    1e36:	eb03 090b 	add.w	r9, r3, fp
        for (j=0; j<N; j++) {
    1e3a:	1c5a      	adds	r2, r3, #1
            A[i*N+j] += val;
    1e3c:	f834 8019 	ldrh.w	r8, [r4, r9, lsl #1]
        for (j=0; j<N; j++) {
    1e40:	4290      	cmp	r0, r2
            A[i*N+j] += val;
    1e42:	4488      	add	r8, r1
    1e44:	f824 8019 	strh.w	r8, [r4, r9, lsl #1]
        for (j=0; j<N; j++) {
    1e48:	d90e      	bls.n	1e68 <matrix_test+0x1ec>
            A[i*N+j] += val;
    1e4a:	445a      	add	r2, fp
        for (j=0; j<N; j++) {
    1e4c:	3302      	adds	r3, #2
            A[i*N+j] += val;
    1e4e:	f834 5012 	ldrh.w	r5, [r4, r2, lsl #1]
        for (j=0; j<N; j++) {
    1e52:	4298      	cmp	r0, r3
            A[i*N+j] += val;
    1e54:	440d      	add	r5, r1
    1e56:	f824 5012 	strh.w	r5, [r4, r2, lsl #1]
        for (j=0; j<N; j++) {
    1e5a:	d905      	bls.n	1e68 <matrix_test+0x1ec>
            A[i*N+j] += val;
    1e5c:	445b      	add	r3, fp
    1e5e:	f834 e013 	ldrh.w	lr, [r4, r3, lsl #1]
    1e62:	448e      	add	lr, r1
    1e64:	f824 e013 	strh.w	lr, [r4, r3, lsl #1]
    for (i=0; i<N; i++) {
    1e68:	f10a 0a01 	add.w	sl, sl, #1
    1e6c:	9b05      	ldr	r3, [sp, #20]
    1e6e:	4550      	cmp	r0, sl
    1e70:	449c      	add	ip, r3
    1e72:	4483      	add	fp, r0
    1e74:	d01a      	beq.n	1eac <matrix_test+0x230>
    1e76:	ea4f 025c 	mov.w	r2, ip, lsr #1
    1e7a:	4253      	negs	r3, r2
    1e7c:	f003 0303 	and.w	r3, r3, #3
    1e80:	4283      	cmp	r3, r0
    1e82:	bf28      	it	cs
    1e84:	4603      	movcs	r3, r0
    1e86:	2804      	cmp	r0, #4
    1e88:	f67f af1d 	bls.w	1cc6 <matrix_test+0x4a>
    1e8c:	461a      	mov	r2, r3
    1e8e:	2b00      	cmp	r3, #0
    1e90:	f43f af3b 	beq.w	1d0a <matrix_test+0x8e>
            A[i*N+j] += val;
    1e94:	f8bc 8000 	ldrh.w	r8, [ip]
    1e98:	2a01      	cmp	r2, #1
    1e9a:	4488      	add	r8, r1
    1e9c:	f8ac 8000 	strh.w	r8, [ip]
    1ea0:	f47f af1a 	bne.w	1cd8 <matrix_test+0x5c>
        for (j=0; j<N; j++) {
    1ea4:	4613      	mov	r3, r2
    1ea6:	e72d      	b.n	1d04 <matrix_test+0x88>
    1ea8:	2303      	movs	r3, #3
    1eaa:	e72b      	b.n	1d04 <matrix_test+0x88>
    1eac:	9c08      	ldr	r4, [sp, #32]
    1eae:	f8dd c034 	ldr.w	ip, [sp, #52]	; 0x34
    1eb2:	f8cd a004 	str.w	sl, [sp, #4]
    1eb6:	00a0      	lsls	r0, r4, #2
    for (i=0; i<N; i++) {
    1eb8:	2700      	movs	r7, #0
    1eba:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
    1ebe:	f8dd a03c 	ldr.w	sl, [sp, #60]	; 0x3c
    1ec2:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
    1ec6:	f8cd c010 	str.w	ip, [sp, #16]
    1eca:	9002      	str	r0, [sp, #8]
    1ecc:	46bc      	mov	ip, r7
    1ece:	4699      	mov	r9, r3
    1ed0:	eb0b 0e09 	add.w	lr, fp, r9
            C[i*N+j]=(MATRES)A[i*N+j] * (MATRES)val;
    1ed4:	f93b 6b02 	ldrsh.w	r6, [fp], #2
    1ed8:	4643      	mov	r3, r8
    1eda:	fb06 f50a 	mul.w	r5, r6, sl
    1ede:	f1a9 0202 	sub.w	r2, r9, #2
        for (j=0; j<N; j++) {
    1ee2:	45f3      	cmp	fp, lr
            C[i*N+j]=(MATRES)A[i*N+j] * (MATRES)val;
    1ee4:	f843 5b04 	str.w	r5, [r3], #4
    1ee8:	f3c2 0142 	ubfx	r1, r2, #1, #3
        for (j=0; j<N; j++) {
    1eec:	d069      	beq.n	1fc2 <matrix_test+0x346>
    1eee:	b3b9      	cbz	r1, 1f60 <matrix_test+0x2e4>
    1ef0:	2901      	cmp	r1, #1
    1ef2:	d02d      	beq.n	1f50 <matrix_test+0x2d4>
    1ef4:	2902      	cmp	r1, #2
    1ef6:	d025      	beq.n	1f44 <matrix_test+0x2c8>
    1ef8:	2903      	cmp	r1, #3
    1efa:	d01d      	beq.n	1f38 <matrix_test+0x2bc>
    1efc:	2904      	cmp	r1, #4
    1efe:	d015      	beq.n	1f2c <matrix_test+0x2b0>
    1f00:	2905      	cmp	r1, #5
    1f02:	d00d      	beq.n	1f20 <matrix_test+0x2a4>
    1f04:	2906      	cmp	r1, #6
    1f06:	d005      	beq.n	1f14 <matrix_test+0x298>
            C[i*N+j]=(MATRES)A[i*N+j] * (MATRES)val;
    1f08:	f93b 4b02 	ldrsh.w	r4, [fp], #2
    1f0c:	fb04 f00a 	mul.w	r0, r4, sl
    1f10:	f843 0b04 	str.w	r0, [r3], #4
    1f14:	f93b 7b02 	ldrsh.w	r7, [fp], #2
    1f18:	fb07 f60a 	mul.w	r6, r7, sl
    1f1c:	f843 6b04 	str.w	r6, [r3], #4
    1f20:	f93b 5b02 	ldrsh.w	r5, [fp], #2
    1f24:	fb05 f20a 	mul.w	r2, r5, sl
    1f28:	f843 2b04 	str.w	r2, [r3], #4
    1f2c:	f93b 1b02 	ldrsh.w	r1, [fp], #2
    1f30:	fb01 f40a 	mul.w	r4, r1, sl
    1f34:	f843 4b04 	str.w	r4, [r3], #4
    1f38:	f93b 0b02 	ldrsh.w	r0, [fp], #2
    1f3c:	fb00 f70a 	mul.w	r7, r0, sl
    1f40:	f843 7b04 	str.w	r7, [r3], #4
    1f44:	f93b 6b02 	ldrsh.w	r6, [fp], #2
    1f48:	fb06 f50a 	mul.w	r5, r6, sl
    1f4c:	f843 5b04 	str.w	r5, [r3], #4
    1f50:	f93b 2b02 	ldrsh.w	r2, [fp], #2
    1f54:	fb02 f10a 	mul.w	r1, r2, sl
        for (j=0; j<N; j++) {
    1f58:	45f3      	cmp	fp, lr
            C[i*N+j]=(MATRES)A[i*N+j] * (MATRES)val;
    1f5a:	f843 1b04 	str.w	r1, [r3], #4
        for (j=0; j<N; j++) {
    1f5e:	d030      	beq.n	1fc2 <matrix_test+0x346>
            C[i*N+j]=(MATRES)A[i*N+j] * (MATRES)val;
    1f60:	465c      	mov	r4, fp
    1f62:	461a      	mov	r2, r3
    1f64:	f934 0b02 	ldrsh.w	r0, [r4], #2
    1f68:	f9bb 7002 	ldrsh.w	r7, [fp, #2]
    1f6c:	f9b4 6002 	ldrsh.w	r6, [r4, #2]
    1f70:	f9bb 5006 	ldrsh.w	r5, [fp, #6]
    1f74:	f9bb 4008 	ldrsh.w	r4, [fp, #8]
    1f78:	fb00 f10a 	mul.w	r1, r0, sl
    1f7c:	f842 1b04 	str.w	r1, [r2], #4
    1f80:	fb06 f60a 	mul.w	r6, r6, sl
    1f84:	fb07 f70a 	mul.w	r7, r7, sl
    1f88:	f9bb 000a 	ldrsh.w	r0, [fp, #10]
    1f8c:	f9bb 100c 	ldrsh.w	r1, [fp, #12]
    1f90:	605f      	str	r7, [r3, #4]
    1f92:	6056      	str	r6, [r2, #4]
    1f94:	f9bb 200e 	ldrsh.w	r2, [fp, #14]
    1f98:	f10b 0b10 	add.w	fp, fp, #16
    1f9c:	fb05 f50a 	mul.w	r5, r5, sl
    1fa0:	fb04 f40a 	mul.w	r4, r4, sl
    1fa4:	fb00 f00a 	mul.w	r0, r0, sl
    1fa8:	fb01 f10a 	mul.w	r1, r1, sl
    1fac:	fb02 f60a 	mul.w	r6, r2, sl
        for (j=0; j<N; j++) {
    1fb0:	45f3      	cmp	fp, lr
            C[i*N+j]=(MATRES)A[i*N+j] * (MATRES)val;
    1fb2:	60dd      	str	r5, [r3, #12]
    1fb4:	611c      	str	r4, [r3, #16]
    1fb6:	6158      	str	r0, [r3, #20]
    1fb8:	6199      	str	r1, [r3, #24]
    1fba:	61de      	str	r6, [r3, #28]
    1fbc:	f103 0320 	add.w	r3, r3, #32
        for (j=0; j<N; j++) {
    1fc0:	d1ce      	bne.n	1f60 <matrix_test+0x2e4>
    for (i=0; i<N; i++) {
    1fc2:	9f01      	ldr	r7, [sp, #4]
    1fc4:	9b02      	ldr	r3, [sp, #8]
    1fc6:	f10c 0c01 	add.w	ip, ip, #1
    1fca:	45bc      	cmp	ip, r7
    1fcc:	4498      	add	r8, r3
    1fce:	f47f af7f 	bne.w	1ed0 <matrix_test+0x254>
    1fd2:	f04f 0c00 	mov.w	ip, #0
    1fd6:	464c      	mov	r4, r9
    1fd8:	9e09      	ldr	r6, [sp, #36]	; 0x24
    1fda:	f8dd 9010 	ldr.w	r9, [sp, #16]
    1fde:	f8dd b020 	ldr.w	fp, [sp, #32]
    1fe2:	f8dd a008 	ldr.w	sl, [sp, #8]
    1fe6:	9601      	str	r6, [sp, #4]
    1fe8:	4660      	mov	r0, ip
    1fea:	4665      	mov	r5, ip
    1fec:	46e0      	mov	r8, ip
    1fee:	eb06 0e0a 	add.w	lr, r6, sl
            cur=C[i*N+j];
    1ff2:	f856 3b04 	ldr.w	r3, [r6], #4
                ret+=10;
    1ff6:	b280      	uxth	r0, r0
    1ff8:	f100 010a 	add.w	r1, r0, #10
            tmp+=cur;
    1ffc:	4498      	add	r8, r3
                ret += (cur>prev) ? 1 : 0;
    1ffe:	42ab      	cmp	r3, r5
    2000:	bfc8      	it	gt
    2002:	3001      	addgt	r0, #1
    2004:	45c8      	cmp	r8, r9
                ret+=10;
    2006:	b20d      	sxth	r5, r1
                ret += (cur>prev) ? 1 : 0;
    2008:	b200      	sxth	r0, r0
    200a:	f1aa 0204 	sub.w	r2, sl, #4
    200e:	bfc4      	itt	gt
    2010:	4628      	movgt	r0, r5
    2012:	f04f 0800 	movgt.w	r8, #0
        for (j=0; j<N; j++) {
    2016:	4576      	cmp	r6, lr
            cur=C[i*N+j];
    2018:	461d      	mov	r5, r3
    201a:	f3c2 0781 	ubfx	r7, r2, #2, #2
        for (j=0; j<N; j++) {
    201e:	f000 8086 	beq.w	212e <matrix_test+0x4b2>
    2022:	2f00      	cmp	r7, #0
    2024:	d038      	beq.n	2098 <matrix_test+0x41c>
    2026:	2f01      	cmp	r7, #1
    2028:	d023      	beq.n	2072 <matrix_test+0x3f6>
    202a:	2f02      	cmp	r7, #2
    202c:	d010      	beq.n	2050 <matrix_test+0x3d4>
            cur=C[i*N+j];
    202e:	f856 3b04 	ldr.w	r3, [r6], #4
                ret+=10;
    2032:	b280      	uxth	r0, r0
    2034:	f100 010a 	add.w	r1, r0, #10
            tmp+=cur;
    2038:	4498      	add	r8, r3
                ret += (cur>prev) ? 1 : 0;
    203a:	42ab      	cmp	r3, r5
    203c:	bfc8      	it	gt
    203e:	3001      	addgt	r0, #1
                ret+=10;
    2040:	b20d      	sxth	r5, r1
    2042:	45c8      	cmp	r8, r9
                ret += (cur>prev) ? 1 : 0;
    2044:	b200      	sxth	r0, r0
    2046:	bfc4      	itt	gt
    2048:	f04f 0800 	movgt.w	r8, #0
    204c:	4628      	movgt	r0, r5
            cur=C[i*N+j];
    204e:	461d      	mov	r5, r3
    2050:	f856 7b04 	ldr.w	r7, [r6], #4
                ret+=10;
    2054:	b283      	uxth	r3, r0
    2056:	f103 020a 	add.w	r2, r3, #10
            tmp+=cur;
    205a:	44b8      	add	r8, r7
                ret += (cur>prev) ? 1 : 0;
    205c:	42af      	cmp	r7, r5
    205e:	bfc8      	it	gt
    2060:	3301      	addgt	r3, #1
                ret+=10;
    2062:	b211      	sxth	r1, r2
    2064:	45c8      	cmp	r8, r9
                ret += (cur>prev) ? 1 : 0;
    2066:	b218      	sxth	r0, r3
    2068:	bfc4      	itt	gt
    206a:	f04f 0800 	movgt.w	r8, #0
    206e:	4608      	movgt	r0, r1
            cur=C[i*N+j];
    2070:	463d      	mov	r5, r7
    2072:	f856 7b04 	ldr.w	r7, [r6], #4
                ret+=10;
    2076:	b280      	uxth	r0, r0
    2078:	f100 030a 	add.w	r3, r0, #10
            tmp+=cur;
    207c:	44b8      	add	r8, r7
                ret += (cur>prev) ? 1 : 0;
    207e:	42af      	cmp	r7, r5
    2080:	bfc8      	it	gt
    2082:	3001      	addgt	r0, #1
    2084:	45c8      	cmp	r8, r9
                ret+=10;
    2086:	b21d      	sxth	r5, r3
                ret += (cur>prev) ? 1 : 0;
    2088:	b200      	sxth	r0, r0
    208a:	bfc4      	itt	gt
    208c:	f04f 0800 	movgt.w	r8, #0
    2090:	4628      	movgt	r0, r5
        for (j=0; j<N; j++) {
    2092:	4576      	cmp	r6, lr
            cur=C[i*N+j];
    2094:	463d      	mov	r5, r7
        for (j=0; j<N; j++) {
    2096:	d04a      	beq.n	212e <matrix_test+0x4b2>
    2098:	4642      	mov	r2, r8
            cur=C[i*N+j];
    209a:	4631      	mov	r1, r6
                ret+=10;
    209c:	b280      	uxth	r0, r0
            cur=C[i*N+j];
    209e:	f851 8b04 	ldr.w	r8, [r1], #4
    20a2:	6873      	ldr	r3, [r6, #4]
    20a4:	684f      	ldr	r7, [r1, #4]
    20a6:	68f1      	ldr	r1, [r6, #12]
            tmp+=cur;
    20a8:	4442      	add	r2, r8
                ret += (cur>prev) ? 1 : 0;
    20aa:	45a8      	cmp	r8, r5
    20ac:	bfd4      	ite	le
    20ae:	4605      	movle	r5, r0
    20b0:	1c45      	addgt	r5, r0, #1
    20b2:	b22d      	sxth	r5, r5
    20b4:	454a      	cmp	r2, r9
                ret+=10;
    20b6:	f100 000a 	add.w	r0, r0, #10
    20ba:	b200      	sxth	r0, r0
    20bc:	bfd6      	itet	le
    20be:	4628      	movle	r0, r5
    20c0:	2500      	movgt	r5, #0
    20c2:	4615      	movle	r5, r2
    20c4:	b282      	uxth	r2, r0
            tmp+=cur;
    20c6:	441d      	add	r5, r3
                ret+=10;
    20c8:	f102 000a 	add.w	r0, r2, #10
                ret += (cur>prev) ? 1 : 0;
    20cc:	4543      	cmp	r3, r8
    20ce:	bfc8      	it	gt
    20d0:	3201      	addgt	r2, #1
    20d2:	b212      	sxth	r2, r2
    20d4:	454d      	cmp	r5, r9
                ret+=10;
    20d6:	fa0f f880 	sxth.w	r8, r0
    20da:	bfd4      	ite	le
    20dc:	4690      	movle	r8, r2
    20de:	2500      	movgt	r5, #0
    20e0:	fa1f f088 	uxth.w	r0, r8
    20e4:	f100 080a 	add.w	r8, r0, #10
                ret += (cur>prev) ? 1 : 0;
    20e8:	429f      	cmp	r7, r3
    20ea:	bfc8      	it	gt
    20ec:	3001      	addgt	r0, #1
            tmp+=cur;
    20ee:	197b      	adds	r3, r7, r5
    20f0:	454b      	cmp	r3, r9
                ret += (cur>prev) ? 1 : 0;
    20f2:	b205      	sxth	r5, r0
                ret+=10;
    20f4:	fa0f f288 	sxth.w	r2, r8
    20f8:	bfd8      	it	le
    20fa:	462a      	movle	r2, r5
    20fc:	fa1f f882 	uxth.w	r8, r2
    2100:	bfc8      	it	gt
    2102:	2300      	movgt	r3, #0
    2104:	f108 000a 	add.w	r0, r8, #10
            tmp+=cur;
    2108:	440b      	add	r3, r1
                ret += (cur>prev) ? 1 : 0;
    210a:	42b9      	cmp	r1, r7
    210c:	bfc8      	it	gt
    210e:	f108 0801 	addgt.w	r8, r8, #1
    2112:	fa0f f288 	sxth.w	r2, r8
    2116:	454b      	cmp	r3, r9
    2118:	f106 0610 	add.w	r6, r6, #16
                ret+=10;
    211c:	b200      	sxth	r0, r0
    211e:	bfce      	itee	gt
    2120:	2200      	movgt	r2, #0
    2122:	4610      	movle	r0, r2
    2124:	461a      	movle	r2, r3
        for (j=0; j<N; j++) {
    2126:	4576      	cmp	r6, lr
            cur=C[i*N+j];
    2128:	460d      	mov	r5, r1
        for (j=0; j<N; j++) {
    212a:	d1b6      	bne.n	209a <matrix_test+0x41e>
    212c:	4690      	mov	r8, r2
    for (i=0; i<N; i++) {
    212e:	f10c 0c01 	add.w	ip, ip, #1
    2132:	45e3      	cmp	fp, ip
    2134:	f47f af5b 	bne.w	1fee <matrix_test+0x372>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    2138:	2100      	movs	r1, #0
    213a:	f8dd b004 	ldr.w	fp, [sp, #4]
    213e:	f001 fbc9 	bl	38d4 <crc16>
    2142:	9e09      	ldr	r6, [sp, #36]	; 0x24
    2144:	9f02      	ldr	r7, [sp, #8]
    2146:	9903      	ldr	r1, [sp, #12]
    2148:	f8dd a02c 	ldr.w	sl, [sp, #44]	; 0x2c
    214c:	f8cd 9014 	str.w	r9, [sp, #20]
    2150:	443e      	add	r6, r7
    2152:	9004      	str	r0, [sp, #16]
    2154:	9601      	str	r6, [sp, #4]
    2156:	eb01 0804 	add.w	r8, r1, r4
    215a:	4689      	mov	r9, r1
void matrix_mul_vect(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B) {
    ee_u32 i,j;
    for (i=0; i<N; i++) {
        C[i]=0;
        for (j=0; j<N; j++) {
            C[i]+=(MATRES)A[i*N+j] * (MATRES)B[j];
    215c:	46ce      	mov	lr, r9
    215e:	46d4      	mov	ip, sl
    2160:	f93e 3b02 	ldrsh.w	r3, [lr], #2
    2164:	f93c 5b02 	ldrsh.w	r5, [ip], #2
    2168:	eba8 0009 	sub.w	r0, r8, r9
    216c:	1e82      	subs	r2, r0, #2
        for (j=0; j<N; j++) {
    216e:	45f0      	cmp	r8, lr
            C[i]+=(MATRES)A[i*N+j] * (MATRES)B[j];
    2170:	fb05 f303 	mul.w	r3, r5, r3
    2174:	f3c2 0642 	ubfx	r6, r2, #1, #3
        for (j=0; j<N; j++) {
    2178:	d072      	beq.n	2260 <matrix_test+0x5e4>
    217a:	b3ce      	cbz	r6, 21f0 <matrix_test+0x574>
    217c:	2e01      	cmp	r6, #1
    217e:	d02f      	beq.n	21e0 <matrix_test+0x564>
    2180:	2e02      	cmp	r6, #2
    2182:	d027      	beq.n	21d4 <matrix_test+0x558>
    2184:	2e03      	cmp	r6, #3
    2186:	d01f      	beq.n	21c8 <matrix_test+0x54c>
    2188:	2e04      	cmp	r6, #4
    218a:	d017      	beq.n	21bc <matrix_test+0x540>
    218c:	2e05      	cmp	r6, #5
    218e:	d00f      	beq.n	21b0 <matrix_test+0x534>
    2190:	2e06      	cmp	r6, #6
    2192:	d007      	beq.n	21a4 <matrix_test+0x528>
            C[i]+=(MATRES)A[i*N+j] * (MATRES)B[j];
    2194:	f93c 7b02 	ldrsh.w	r7, [ip], #2
    2198:	f9b9 1002 	ldrsh.w	r1, [r9, #2]
    219c:	f10e 0e02 	add.w	lr, lr, #2
    21a0:	fb07 3301 	mla	r3, r7, r1, r3
    21a4:	f93c 5b02 	ldrsh.w	r5, [ip], #2
    21a8:	f93e 0b02 	ldrsh.w	r0, [lr], #2
    21ac:	fb05 3300 	mla	r3, r5, r0, r3
    21b0:	f93c 6b02 	ldrsh.w	r6, [ip], #2
    21b4:	f93e 2b02 	ldrsh.w	r2, [lr], #2
    21b8:	fb06 3302 	mla	r3, r6, r2, r3
    21bc:	f93c 7b02 	ldrsh.w	r7, [ip], #2
    21c0:	f93e 1b02 	ldrsh.w	r1, [lr], #2
    21c4:	fb07 3301 	mla	r3, r7, r1, r3
    21c8:	f93c 5b02 	ldrsh.w	r5, [ip], #2
    21cc:	f93e 0b02 	ldrsh.w	r0, [lr], #2
    21d0:	fb05 3300 	mla	r3, r5, r0, r3
    21d4:	f93c 6b02 	ldrsh.w	r6, [ip], #2
    21d8:	f93e 2b02 	ldrsh.w	r2, [lr], #2
    21dc:	fb06 3302 	mla	r3, r6, r2, r3
    21e0:	f93e 1b02 	ldrsh.w	r1, [lr], #2
    21e4:	f93c 7b02 	ldrsh.w	r7, [ip], #2
        for (j=0; j<N; j++) {
    21e8:	45f0      	cmp	r8, lr
            C[i]+=(MATRES)A[i*N+j] * (MATRES)B[j];
    21ea:	fb07 3301 	mla	r3, r7, r1, r3
        for (j=0; j<N; j++) {
    21ee:	d037      	beq.n	2260 <matrix_test+0x5e4>
            C[i]+=(MATRES)A[i*N+j] * (MATRES)B[j];
    21f0:	4666      	mov	r6, ip
    21f2:	4672      	mov	r2, lr
    21f4:	f936 7b02 	ldrsh.w	r7, [r6], #2
    21f8:	f932 0b02 	ldrsh.w	r0, [r2], #2
    21fc:	f9be 1002 	ldrsh.w	r1, [lr, #2]
    2200:	f9bc 5002 	ldrsh.w	r5, [ip, #2]
    2204:	f9b6 6002 	ldrsh.w	r6, [r6, #2]
    2208:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
    220c:	fb07 3300 	mla	r3, r7, r0, r3
    2210:	fb05 3701 	mla	r7, r5, r1, r3
    2214:	f9be 3006 	ldrsh.w	r3, [lr, #6]
    2218:	f9bc 5006 	ldrsh.w	r5, [ip, #6]
    221c:	f9bc 0008 	ldrsh.w	r0, [ip, #8]
    2220:	f9be 1008 	ldrsh.w	r1, [lr, #8]
    2224:	fb06 7202 	mla	r2, r6, r2, r7
    2228:	fb05 2703 	mla	r7, r5, r3, r2
    222c:	f9bc 600a 	ldrsh.w	r6, [ip, #10]
    2230:	f9be 200a 	ldrsh.w	r2, [lr, #10]
    2234:	f9be 300c 	ldrsh.w	r3, [lr, #12]
    2238:	f9bc 500c 	ldrsh.w	r5, [ip, #12]
    223c:	fb00 7101 	mla	r1, r0, r1, r7
    2240:	fb06 1602 	mla	r6, r6, r2, r1
    2244:	f9be 700e 	ldrsh.w	r7, [lr, #14]
    2248:	f9bc 000e 	ldrsh.w	r0, [ip, #14]
    224c:	f10e 0e10 	add.w	lr, lr, #16
    2250:	fb05 6203 	mla	r2, r5, r3, r6
        for (j=0; j<N; j++) {
    2254:	45f0      	cmp	r8, lr
    2256:	f10c 0c10 	add.w	ip, ip, #16
            C[i]+=(MATRES)A[i*N+j] * (MATRES)B[j];
    225a:	fb00 2307 	mla	r3, r0, r7, r2
        for (j=0; j<N; j++) {
    225e:	d1c7      	bne.n	21f0 <matrix_test+0x574>
    2260:	f84b 3b04 	str.w	r3, [fp], #4
    for (i=0; i<N; i++) {
    2264:	9d01      	ldr	r5, [sp, #4]
    2266:	45ab      	cmp	fp, r5
    2268:	44a2      	add	sl, r4
    226a:	f47f af77 	bne.w	215c <matrix_test+0x4e0>
    226e:	f04f 0800 	mov.w	r8, #0
    2272:	9e09      	ldr	r6, [sp, #36]	; 0x24
    2274:	f8dd 9014 	ldr.w	r9, [sp, #20]
    2278:	f8dd b020 	ldr.w	fp, [sp, #32]
    227c:	f8dd a008 	ldr.w	sl, [sp, #8]
    2280:	9601      	str	r6, [sp, #4]
    2282:	4645      	mov	r5, r8
    2284:	4640      	mov	r0, r8
    2286:	46c4      	mov	ip, r8
    2288:	eb06 0e0a 	add.w	lr, r6, sl
            cur=C[i*N+j];
    228c:	f856 7b04 	ldr.w	r7, [r6], #4
                ret+=10;
    2290:	b283      	uxth	r3, r0
            tmp+=cur;
    2292:	44bc      	add	ip, r7
                ret+=10;
    2294:	f103 010a 	add.w	r1, r3, #10
    2298:	b20a      	sxth	r2, r1
                ret += (cur>prev) ? 1 : 0;
    229a:	42af      	cmp	r7, r5
    229c:	bfc8      	it	gt
    229e:	3301      	addgt	r3, #1
    22a0:	45cc      	cmp	ip, r9
    22a2:	b218      	sxth	r0, r3
    22a4:	bfc8      	it	gt
    22a6:	f04f 0c00 	movgt.w	ip, #0
    22aa:	f1aa 0304 	sub.w	r3, sl, #4
    22ae:	bfc8      	it	gt
    22b0:	4610      	movgt	r0, r2
        for (j=0; j<N; j++) {
    22b2:	45b6      	cmp	lr, r6
            cur=C[i*N+j];
    22b4:	463d      	mov	r5, r7
    22b6:	f3c3 0781 	ubfx	r7, r3, #2, #2
        for (j=0; j<N; j++) {
    22ba:	f000 8086 	beq.w	23ca <matrix_test+0x74e>
    22be:	2f00      	cmp	r7, #0
    22c0:	d038      	beq.n	2334 <matrix_test+0x6b8>
    22c2:	2f01      	cmp	r7, #1
    22c4:	d023      	beq.n	230e <matrix_test+0x692>
    22c6:	2f02      	cmp	r7, #2
    22c8:	d010      	beq.n	22ec <matrix_test+0x670>
            cur=C[i*N+j];
    22ca:	f856 1b04 	ldr.w	r1, [r6], #4
                ret+=10;
    22ce:	b280      	uxth	r0, r0
    22d0:	f100 020a 	add.w	r2, r0, #10
            tmp+=cur;
    22d4:	448c      	add	ip, r1
                ret += (cur>prev) ? 1 : 0;
    22d6:	42a9      	cmp	r1, r5
    22d8:	bfc8      	it	gt
    22da:	3001      	addgt	r0, #1
                ret+=10;
    22dc:	b215      	sxth	r5, r2
    22de:	45cc      	cmp	ip, r9
                ret += (cur>prev) ? 1 : 0;
    22e0:	b200      	sxth	r0, r0
    22e2:	bfc4      	itt	gt
    22e4:	f04f 0c00 	movgt.w	ip, #0
    22e8:	4628      	movgt	r0, r5
            cur=C[i*N+j];
    22ea:	460d      	mov	r5, r1
    22ec:	f856 3b04 	ldr.w	r3, [r6], #4
                ret+=10;
    22f0:	b287      	uxth	r7, r0
    22f2:	f107 010a 	add.w	r1, r7, #10
            tmp+=cur;
    22f6:	449c      	add	ip, r3
                ret += (cur>prev) ? 1 : 0;
    22f8:	42ab      	cmp	r3, r5
    22fa:	bfc8      	it	gt
    22fc:	3701      	addgt	r7, #1
                ret+=10;
    22fe:	b20a      	sxth	r2, r1
    2300:	45cc      	cmp	ip, r9
                ret += (cur>prev) ? 1 : 0;
    2302:	b238      	sxth	r0, r7
    2304:	bfc4      	itt	gt
    2306:	f04f 0c00 	movgt.w	ip, #0
    230a:	4610      	movgt	r0, r2
            cur=C[i*N+j];
    230c:	461d      	mov	r5, r3
    230e:	f856 3b04 	ldr.w	r3, [r6], #4
                ret+=10;
    2312:	b280      	uxth	r0, r0
    2314:	f100 070a 	add.w	r7, r0, #10
            tmp+=cur;
    2318:	449c      	add	ip, r3
                ret += (cur>prev) ? 1 : 0;
    231a:	42ab      	cmp	r3, r5
    231c:	bfc8      	it	gt
    231e:	3001      	addgt	r0, #1
    2320:	45cc      	cmp	ip, r9
                ret+=10;
    2322:	b23d      	sxth	r5, r7
                ret += (cur>prev) ? 1 : 0;
    2324:	b200      	sxth	r0, r0
    2326:	bfc4      	itt	gt
    2328:	f04f 0c00 	movgt.w	ip, #0
    232c:	4628      	movgt	r0, r5
        for (j=0; j<N; j++) {
    232e:	45b6      	cmp	lr, r6
            cur=C[i*N+j];
    2330:	461d      	mov	r5, r3
        for (j=0; j<N; j++) {
    2332:	d04a      	beq.n	23ca <matrix_test+0x74e>
    2334:	4662      	mov	r2, ip
            cur=C[i*N+j];
    2336:	4631      	mov	r1, r6
                ret+=10;
    2338:	b280      	uxth	r0, r0
            cur=C[i*N+j];
    233a:	f851 cb04 	ldr.w	ip, [r1], #4
    233e:	6873      	ldr	r3, [r6, #4]
    2340:	684f      	ldr	r7, [r1, #4]
    2342:	68f1      	ldr	r1, [r6, #12]
            tmp+=cur;
    2344:	4462      	add	r2, ip
                ret += (cur>prev) ? 1 : 0;
    2346:	45ac      	cmp	ip, r5
    2348:	bfd4      	ite	le
    234a:	4605      	movle	r5, r0
    234c:	1c45      	addgt	r5, r0, #1
    234e:	b22d      	sxth	r5, r5
    2350:	454a      	cmp	r2, r9
                ret+=10;
    2352:	f100 000a 	add.w	r0, r0, #10
    2356:	b200      	sxth	r0, r0
    2358:	bfd6      	itet	le
    235a:	4628      	movle	r0, r5
    235c:	2500      	movgt	r5, #0
    235e:	4615      	movle	r5, r2
    2360:	b282      	uxth	r2, r0
            tmp+=cur;
    2362:	441d      	add	r5, r3
                ret+=10;
    2364:	f102 000a 	add.w	r0, r2, #10
                ret += (cur>prev) ? 1 : 0;
    2368:	4563      	cmp	r3, ip
    236a:	bfc8      	it	gt
    236c:	3201      	addgt	r2, #1
    236e:	b212      	sxth	r2, r2
    2370:	454d      	cmp	r5, r9
                ret+=10;
    2372:	fa0f fc80 	sxth.w	ip, r0
    2376:	bfd4      	ite	le
    2378:	4694      	movle	ip, r2
    237a:	2500      	movgt	r5, #0
    237c:	fa1f f08c 	uxth.w	r0, ip
    2380:	f100 0c0a 	add.w	ip, r0, #10
                ret += (cur>prev) ? 1 : 0;
    2384:	429f      	cmp	r7, r3
    2386:	bfc8      	it	gt
    2388:	3001      	addgt	r0, #1
            tmp+=cur;
    238a:	197b      	adds	r3, r7, r5
    238c:	454b      	cmp	r3, r9
                ret += (cur>prev) ? 1 : 0;
    238e:	b205      	sxth	r5, r0
                ret+=10;
    2390:	fa0f f28c 	sxth.w	r2, ip
    2394:	bfd8      	it	le
    2396:	462a      	movle	r2, r5
    2398:	fa1f fc82 	uxth.w	ip, r2
    239c:	bfc8      	it	gt
    239e:	2300      	movgt	r3, #0
    23a0:	f10c 000a 	add.w	r0, ip, #10
            tmp+=cur;
    23a4:	440b      	add	r3, r1
                ret += (cur>prev) ? 1 : 0;
    23a6:	42b9      	cmp	r1, r7
    23a8:	bfc8      	it	gt
    23aa:	f10c 0c01 	addgt.w	ip, ip, #1
    23ae:	fa0f f28c 	sxth.w	r2, ip
    23b2:	454b      	cmp	r3, r9
    23b4:	f106 0610 	add.w	r6, r6, #16
                ret+=10;
    23b8:	b200      	sxth	r0, r0
    23ba:	bfce      	itee	gt
    23bc:	2200      	movgt	r2, #0
    23be:	4610      	movle	r0, r2
    23c0:	461a      	movle	r2, r3
        for (j=0; j<N; j++) {
    23c2:	45b6      	cmp	lr, r6
            cur=C[i*N+j];
    23c4:	460d      	mov	r5, r1
        for (j=0; j<N; j++) {
    23c6:	d1b6      	bne.n	2336 <matrix_test+0x6ba>
    23c8:	4694      	mov	ip, r2
    for (i=0; i<N; i++) {
    23ca:	f108 0801 	add.w	r8, r8, #1
    23ce:	45c3      	cmp	fp, r8
    23d0:	f47f af5a 	bne.w	2288 <matrix_test+0x60c>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    23d4:	9904      	ldr	r1, [sp, #16]
    23d6:	f8cd 8014 	str.w	r8, [sp, #20]
    23da:	f001 fa7b 	bl	38d4 <crc16>
    23de:	9e03      	ldr	r6, [sp, #12]
    23e0:	f8dd c02c 	ldr.w	ip, [sp, #44]	; 0x2c
    23e4:	f8dd a004 	ldr.w	sl, [sp, #4]
    23e8:	f8cd 901c 	str.w	r9, [sp, #28]
    23ec:	4426      	add	r6, r4
    23ee:	2700      	movs	r7, #0
    23f0:	9006      	str	r0, [sp, #24]
    23f2:	9704      	str	r7, [sp, #16]
    23f4:	46b1      	mov	r9, r6
    23f6:	9f03      	ldr	r7, [sp, #12]
    23f8:	eb04 0e0c 	add.w	lr, r4, ip
    23fc:	46d0      	mov	r8, sl
    for (i=0; i<N; i++) {
        for (j=0; j<N; j++) {
            C[i*N+j]=0;
            for(k=0;k<N;k++)
            {
                C[i*N+j]+=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    23fe:	46e3      	mov	fp, ip
    2400:	883b      	ldrh	r3, [r7, #0]
    2402:	f93b 1b02 	ldrsh.w	r1, [fp], #2
    2406:	ebae 050c 	sub.w	r5, lr, ip
    240a:	1ea8      	subs	r0, r5, #2
            for(k=0;k<N;k++)
    240c:	45de      	cmp	lr, fp
                C[i*N+j]+=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    240e:	fb11 f303 	smulbb	r3, r1, r3
    2412:	f3c0 0242 	ubfx	r2, r0, #1, #3
    2416:	eb07 0604 	add.w	r6, r7, r4
            for(k=0;k<N;k++)
    241a:	d075      	beq.n	2508 <matrix_test+0x88c>
    241c:	b3ba      	cbz	r2, 248e <matrix_test+0x812>
    241e:	2a01      	cmp	r2, #1
    2420:	d02d      	beq.n	247e <matrix_test+0x802>
    2422:	2a02      	cmp	r2, #2
    2424:	d025      	beq.n	2472 <matrix_test+0x7f6>
    2426:	2a03      	cmp	r2, #3
    2428:	d01d      	beq.n	2466 <matrix_test+0x7ea>
    242a:	2a04      	cmp	r2, #4
    242c:	d015      	beq.n	245a <matrix_test+0x7de>
    242e:	2a05      	cmp	r2, #5
    2430:	d00d      	beq.n	244e <matrix_test+0x7d2>
    2432:	2a06      	cmp	r2, #6
    2434:	d005      	beq.n	2442 <matrix_test+0x7c6>
                C[i*N+j]+=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    2436:	8835      	ldrh	r5, [r6, #0]
    2438:	f93b 1b02 	ldrsh.w	r1, [fp], #2
    243c:	4426      	add	r6, r4
    243e:	fb11 3305 	smlabb	r3, r1, r5, r3
    2442:	8832      	ldrh	r2, [r6, #0]
    2444:	f93b 0b02 	ldrsh.w	r0, [fp], #2
    2448:	4426      	add	r6, r4
    244a:	fb10 3302 	smlabb	r3, r0, r2, r3
    244e:	8835      	ldrh	r5, [r6, #0]
    2450:	f93b 1b02 	ldrsh.w	r1, [fp], #2
    2454:	4426      	add	r6, r4
    2456:	fb11 3305 	smlabb	r3, r1, r5, r3
    245a:	8832      	ldrh	r2, [r6, #0]
    245c:	f93b 0b02 	ldrsh.w	r0, [fp], #2
    2460:	4426      	add	r6, r4
    2462:	fb10 3302 	smlabb	r3, r0, r2, r3
    2466:	8835      	ldrh	r5, [r6, #0]
    2468:	f93b 1b02 	ldrsh.w	r1, [fp], #2
    246c:	4426      	add	r6, r4
    246e:	fb11 3305 	smlabb	r3, r1, r5, r3
    2472:	8832      	ldrh	r2, [r6, #0]
    2474:	f93b 0b02 	ldrsh.w	r0, [fp], #2
    2478:	4426      	add	r6, r4
    247a:	fb10 3302 	smlabb	r3, r0, r2, r3
    247e:	f93b 1b02 	ldrsh.w	r1, [fp], #2
    2482:	8835      	ldrh	r5, [r6, #0]
            for(k=0;k<N;k++)
    2484:	45de      	cmp	lr, fp
    2486:	4426      	add	r6, r4
                C[i*N+j]+=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    2488:	fb11 3305 	smlabb	r3, r1, r5, r3
            for(k=0;k<N;k++)
    248c:	d03c      	beq.n	2508 <matrix_test+0x88c>
    248e:	9701      	str	r7, [sp, #4]
                C[i*N+j]+=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    2490:	465f      	mov	r7, fp
    2492:	f9bb 0002 	ldrsh.w	r0, [fp, #2]
    2496:	f937 5b02 	ldrsh.w	r5, [r7], #2
    249a:	5b31      	ldrh	r1, [r6, r4]
    249c:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
    24a0:	8837      	ldrh	r7, [r6, #0]
    24a2:	fb15 3307 	smlabb	r3, r5, r7, r3
    24a6:	1935      	adds	r5, r6, r4
    24a8:	fb10 3701 	smlabb	r7, r0, r1, r3
    24ac:	f836 6014 	ldrh.w	r6, [r6, r4, lsl #1]
    24b0:	f9bb 1006 	ldrsh.w	r1, [fp, #6]
    24b4:	1928      	adds	r0, r5, r4
    24b6:	f835 5014 	ldrh.w	r5, [r5, r4, lsl #1]
    24ba:	fb12 7306 	smlabb	r3, r2, r6, r7
    24be:	f9bb 6008 	ldrsh.w	r6, [fp, #8]
    24c2:	f830 7014 	ldrh.w	r7, [r0, r4, lsl #1]
    24c6:	1902      	adds	r2, r0, r4
    24c8:	fb11 3005 	smlabb	r0, r1, r5, r3
    24cc:	1911      	adds	r1, r2, r4
    24ce:	fb16 0307 	smlabb	r3, r6, r7, r0
    24d2:	f9bb 500a 	ldrsh.w	r5, [fp, #10]
    24d6:	f832 2014 	ldrh.w	r2, [r2, r4, lsl #1]
    24da:	f831 6014 	ldrh.w	r6, [r1, r4, lsl #1]
    24de:	f9bb 000c 	ldrsh.w	r0, [fp, #12]
    24e2:	190f      	adds	r7, r1, r4
    24e4:	f10b 0b10 	add.w	fp, fp, #16
    24e8:	fb15 3102 	smlabb	r1, r5, r2, r3
    24ec:	f93b 5c02 	ldrsh.w	r5, [fp, #-2]
    24f0:	f837 2014 	ldrh.w	r2, [r7, r4, lsl #1]
    24f4:	fb10 1306 	smlabb	r3, r0, r6, r1
            for(k=0;k<N;k++)
    24f8:	45de      	cmp	lr, fp
    24fa:	eb07 0644 	add.w	r6, r7, r4, lsl #1
    24fe:	4426      	add	r6, r4
                C[i*N+j]+=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    2500:	fb15 3302 	smlabb	r3, r5, r2, r3
            for(k=0;k<N;k++)
    2504:	d1c4      	bne.n	2490 <matrix_test+0x814>
    2506:	9f01      	ldr	r7, [sp, #4]
    2508:	f848 3b04 	str.w	r3, [r8], #4
    250c:	3702      	adds	r7, #2
        for (j=0; j<N; j++) {
    250e:	45b9      	cmp	r9, r7
    2510:	f47f af75 	bne.w	23fe <matrix_test+0x782>
    for (i=0; i<N; i++) {
    2514:	9e04      	ldr	r6, [sp, #16]
    2516:	9905      	ldr	r1, [sp, #20]
    2518:	9802      	ldr	r0, [sp, #8]
    251a:	3601      	adds	r6, #1
    251c:	42b1      	cmp	r1, r6
    251e:	9604      	str	r6, [sp, #16]
    2520:	4482      	add	sl, r0
    2522:	46f4      	mov	ip, lr
    2524:	f47f af67 	bne.w	23f6 <matrix_test+0x77a>
    2528:	f04f 0800 	mov.w	r8, #0
    252c:	9e09      	ldr	r6, [sp, #36]	; 0x24
    252e:	f8dd 901c 	ldr.w	r9, [sp, #28]
    2532:	f8dd b020 	ldr.w	fp, [sp, #32]
    2536:	f8dd a008 	ldr.w	sl, [sp, #8]
    253a:	9601      	str	r6, [sp, #4]
    253c:	4645      	mov	r5, r8
    253e:	4640      	mov	r0, r8
    2540:	46c4      	mov	ip, r8
    2542:	eb0a 0e06 	add.w	lr, sl, r6
            cur=C[i*N+j];
    2546:	f856 2b04 	ldr.w	r2, [r6], #4
                ret+=10;
    254a:	b283      	uxth	r3, r0
            tmp+=cur;
    254c:	4494      	add	ip, r2
                ret+=10;
    254e:	f103 070a 	add.w	r7, r3, #10
                ret += (cur>prev) ? 1 : 0;
    2552:	42aa      	cmp	r2, r5
    2554:	bfc8      	it	gt
    2556:	3301      	addgt	r3, #1
    2558:	45cc      	cmp	ip, r9
                ret+=10;
    255a:	b23d      	sxth	r5, r7
                ret += (cur>prev) ? 1 : 0;
    255c:	b218      	sxth	r0, r3
    255e:	f1aa 0104 	sub.w	r1, sl, #4
    2562:	bfc4      	itt	gt
    2564:	4628      	movgt	r0, r5
    2566:	f04f 0c00 	movgt.w	ip, #0
        for (j=0; j<N; j++) {
    256a:	4576      	cmp	r6, lr
            cur=C[i*N+j];
    256c:	4615      	mov	r5, r2
    256e:	f3c1 0281 	ubfx	r2, r1, #2, #2
        for (j=0; j<N; j++) {
    2572:	f000 8086 	beq.w	2682 <matrix_test+0xa06>
    2576:	2a00      	cmp	r2, #0
    2578:	d038      	beq.n	25ec <matrix_test+0x970>
    257a:	2a01      	cmp	r2, #1
    257c:	d023      	beq.n	25c6 <matrix_test+0x94a>
    257e:	2a02      	cmp	r2, #2
    2580:	d010      	beq.n	25a4 <matrix_test+0x928>
            cur=C[i*N+j];
    2582:	f856 3b04 	ldr.w	r3, [r6], #4
                ret+=10;
    2586:	b280      	uxth	r0, r0
    2588:	f100 070a 	add.w	r7, r0, #10
            tmp+=cur;
    258c:	449c      	add	ip, r3
                ret += (cur>prev) ? 1 : 0;
    258e:	42ab      	cmp	r3, r5
    2590:	bfc8      	it	gt
    2592:	3001      	addgt	r0, #1
                ret+=10;
    2594:	b23d      	sxth	r5, r7
    2596:	45cc      	cmp	ip, r9
                ret += (cur>prev) ? 1 : 0;
    2598:	b200      	sxth	r0, r0
    259a:	bfc4      	itt	gt
    259c:	f04f 0c00 	movgt.w	ip, #0
    25a0:	4628      	movgt	r0, r5
            cur=C[i*N+j];
    25a2:	461d      	mov	r5, r3
    25a4:	f856 1b04 	ldr.w	r1, [r6], #4
                ret+=10;
    25a8:	b283      	uxth	r3, r0
    25aa:	f103 020a 	add.w	r2, r3, #10
            tmp+=cur;
    25ae:	448c      	add	ip, r1
                ret += (cur>prev) ? 1 : 0;
    25b0:	42a9      	cmp	r1, r5
    25b2:	bfc8      	it	gt
    25b4:	3301      	addgt	r3, #1
                ret+=10;
    25b6:	b217      	sxth	r7, r2
    25b8:	45cc      	cmp	ip, r9
                ret += (cur>prev) ? 1 : 0;
    25ba:	b218      	sxth	r0, r3
    25bc:	bfc4      	itt	gt
    25be:	f04f 0c00 	movgt.w	ip, #0
    25c2:	4638      	movgt	r0, r7
            cur=C[i*N+j];
    25c4:	460d      	mov	r5, r1
    25c6:	f856 1b04 	ldr.w	r1, [r6], #4
                ret+=10;
    25ca:	b280      	uxth	r0, r0
    25cc:	f100 030a 	add.w	r3, r0, #10
            tmp+=cur;
    25d0:	448c      	add	ip, r1
                ret += (cur>prev) ? 1 : 0;
    25d2:	42a9      	cmp	r1, r5
    25d4:	bfc8      	it	gt
    25d6:	3001      	addgt	r0, #1
    25d8:	45cc      	cmp	ip, r9
                ret+=10;
    25da:	b21d      	sxth	r5, r3
                ret += (cur>prev) ? 1 : 0;
    25dc:	b200      	sxth	r0, r0
    25de:	bfc4      	itt	gt
    25e0:	f04f 0c00 	movgt.w	ip, #0
    25e4:	4628      	movgt	r0, r5
        for (j=0; j<N; j++) {
    25e6:	4576      	cmp	r6, lr
            cur=C[i*N+j];
    25e8:	460d      	mov	r5, r1
        for (j=0; j<N; j++) {
    25ea:	d04a      	beq.n	2682 <matrix_test+0xa06>
    25ec:	4662      	mov	r2, ip
            cur=C[i*N+j];
    25ee:	4637      	mov	r7, r6
                ret+=10;
    25f0:	b280      	uxth	r0, r0
            cur=C[i*N+j];
    25f2:	f857 cb04 	ldr.w	ip, [r7], #4
    25f6:	6873      	ldr	r3, [r6, #4]
    25f8:	687f      	ldr	r7, [r7, #4]
    25fa:	68f1      	ldr	r1, [r6, #12]
            tmp+=cur;
    25fc:	4462      	add	r2, ip
                ret += (cur>prev) ? 1 : 0;
    25fe:	45ac      	cmp	ip, r5
    2600:	bfd4      	ite	le
    2602:	4605      	movle	r5, r0
    2604:	1c45      	addgt	r5, r0, #1
    2606:	b22d      	sxth	r5, r5
    2608:	454a      	cmp	r2, r9
                ret+=10;
    260a:	f100 000a 	add.w	r0, r0, #10
    260e:	b200      	sxth	r0, r0
    2610:	bfd6      	itet	le
    2612:	4628      	movle	r0, r5
    2614:	2500      	movgt	r5, #0
    2616:	4615      	movle	r5, r2
    2618:	b282      	uxth	r2, r0
            tmp+=cur;
    261a:	441d      	add	r5, r3
                ret+=10;
    261c:	f102 000a 	add.w	r0, r2, #10
                ret += (cur>prev) ? 1 : 0;
    2620:	4563      	cmp	r3, ip
    2622:	bfc8      	it	gt
    2624:	3201      	addgt	r2, #1
    2626:	b212      	sxth	r2, r2
    2628:	454d      	cmp	r5, r9
                ret+=10;
    262a:	fa0f fc80 	sxth.w	ip, r0
    262e:	bfd4      	ite	le
    2630:	4694      	movle	ip, r2
    2632:	2500      	movgt	r5, #0
    2634:	fa1f f08c 	uxth.w	r0, ip
    2638:	f100 0c0a 	add.w	ip, r0, #10
                ret += (cur>prev) ? 1 : 0;
    263c:	429f      	cmp	r7, r3
    263e:	bfc8      	it	gt
    2640:	3001      	addgt	r0, #1
            tmp+=cur;
    2642:	197b      	adds	r3, r7, r5
    2644:	454b      	cmp	r3, r9
                ret += (cur>prev) ? 1 : 0;
    2646:	b205      	sxth	r5, r0
                ret+=10;
    2648:	fa0f f28c 	sxth.w	r2, ip
    264c:	bfd8      	it	le
    264e:	462a      	movle	r2, r5
    2650:	fa1f fc82 	uxth.w	ip, r2
    2654:	bfc8      	it	gt
    2656:	2300      	movgt	r3, #0
    2658:	f10c 000a 	add.w	r0, ip, #10
            tmp+=cur;
    265c:	440b      	add	r3, r1
                ret += (cur>prev) ? 1 : 0;
    265e:	42b9      	cmp	r1, r7
    2660:	bfc8      	it	gt
    2662:	f10c 0c01 	addgt.w	ip, ip, #1
    2666:	fa0f f28c 	sxth.w	r2, ip
    266a:	454b      	cmp	r3, r9
    266c:	f106 0610 	add.w	r6, r6, #16
                ret+=10;
    2670:	b200      	sxth	r0, r0
    2672:	bfce      	itee	gt
    2674:	2200      	movgt	r2, #0
    2676:	4610      	movle	r0, r2
    2678:	461a      	movle	r2, r3
        for (j=0; j<N; j++) {
    267a:	4576      	cmp	r6, lr
            cur=C[i*N+j];
    267c:	460d      	mov	r5, r1
        for (j=0; j<N; j++) {
    267e:	d1b6      	bne.n	25ee <matrix_test+0x972>
    2680:	4694      	mov	ip, r2
    for (i=0; i<N; i++) {
    2682:	f108 0801 	add.w	r8, r8, #1
    2686:	45c3      	cmp	fp, r8
    2688:	f47f af5b 	bne.w	2542 <matrix_test+0x8c6>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    268c:	9906      	ldr	r1, [sp, #24]
    268e:	f8cd 8014 	str.w	r8, [sp, #20]
    2692:	f001 f91f 	bl	38d4 <crc16>
    2696:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
    2698:	9f03      	ldr	r7, [sp, #12]
    269a:	f8cd 901c 	str.w	r9, [sp, #28]
    269e:	2100      	movs	r1, #0
    26a0:	9006      	str	r0, [sp, #24]
    26a2:	eb07 0b04 	add.w	fp, r7, r4
    26a6:	9104      	str	r1, [sp, #16]
    26a8:	46b1      	mov	r9, r6
    26aa:	f8dd 800c 	ldr.w	r8, [sp, #12]
    26ae:	f8dd a004 	ldr.w	sl, [sp, #4]
    26b2:	eb04 0c09 	add.w	ip, r4, r9
    for (i=0; i<N; i++) {
        for (j=0; j<N; j++) {
            C[i*N+j]=0;
            for(k=0;k<N;k++)
            {
                MATRES tmp=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    26b6:	464f      	mov	r7, r9
    26b8:	f8b8 e000 	ldrh.w	lr, [r8]
    26bc:	f937 3b02 	ldrsh.w	r3, [r7], #2
    26c0:	ebac 0509 	sub.w	r5, ip, r9
    26c4:	fb1e f003 	smulbb	r0, lr, r3
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    26c8:	f3c0 0683 	ubfx	r6, r0, #2, #4
    26cc:	f3c0 1346 	ubfx	r3, r0, #5, #7
    26d0:	1eaa      	subs	r2, r5, #2
            for(k=0;k<N;k++)
    26d2:	45bc      	cmp	ip, r7
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    26d4:	fb03 f306 	mul.w	r3, r3, r6
    26d8:	f3c2 0141 	ubfx	r1, r2, #1, #2
    26dc:	eb08 0604 	add.w	r6, r8, r4
            for(k=0;k<N;k++)
    26e0:	d060      	beq.n	27a4 <matrix_test+0xb28>
    26e2:	b349      	cbz	r1, 2738 <matrix_test+0xabc>
    26e4:	2901      	cmp	r1, #1
    26e6:	d019      	beq.n	271c <matrix_test+0xaa0>
    26e8:	2902      	cmp	r1, #2
    26ea:	d00b      	beq.n	2704 <matrix_test+0xa88>
                MATRES tmp=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    26ec:	8830      	ldrh	r0, [r6, #0]
    26ee:	f937 5b02 	ldrsh.w	r5, [r7], #2
    26f2:	fb10 fe05 	smulbb	lr, r0, r5
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    26f6:	f3ce 0183 	ubfx	r1, lr, #2, #4
    26fa:	f3ce 1246 	ubfx	r2, lr, #5, #7
    26fe:	4426      	add	r6, r4
    2700:	fb02 3301 	mla	r3, r2, r1, r3
                MATRES tmp=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    2704:	8830      	ldrh	r0, [r6, #0]
    2706:	f937 5b02 	ldrsh.w	r5, [r7], #2
    270a:	fb10 fe05 	smulbb	lr, r0, r5
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    270e:	f3ce 0183 	ubfx	r1, lr, #2, #4
    2712:	f3ce 1246 	ubfx	r2, lr, #5, #7
    2716:	4426      	add	r6, r4
    2718:	fb02 3301 	mla	r3, r2, r1, r3
                MATRES tmp=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    271c:	f937 5b02 	ldrsh.w	r5, [r7], #2
    2720:	8830      	ldrh	r0, [r6, #0]
    2722:	fb10 fe05 	smulbb	lr, r0, r5
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    2726:	f3ce 0183 	ubfx	r1, lr, #2, #4
    272a:	f3ce 1246 	ubfx	r2, lr, #5, #7
            for(k=0;k<N;k++)
    272e:	45bc      	cmp	ip, r7
    2730:	4426      	add	r6, r4
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    2732:	fb02 3301 	mla	r3, r2, r1, r3
            for(k=0;k<N;k++)
    2736:	d035      	beq.n	27a4 <matrix_test+0xb28>
                MATRES tmp=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    2738:	463d      	mov	r5, r7
    273a:	8830      	ldrh	r0, [r6, #0]
    273c:	f935 2b02 	ldrsh.w	r2, [r5], #2
    2740:	f9b7 e002 	ldrsh.w	lr, [r7, #2]
    2744:	f9b5 5002 	ldrsh.w	r5, [r5, #2]
    2748:	5b31      	ldrh	r1, [r6, r4]
    274a:	fb10 f002 	smulbb	r0, r0, r2
    274e:	f836 2014 	ldrh.w	r2, [r6, r4, lsl #1]
    2752:	fb11 f10e 	smulbb	r1, r1, lr
    2756:	fb12 f205 	smulbb	r2, r2, r5
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    275a:	f3c0 1e46 	ubfx	lr, r0, #5, #7
    275e:	f3c0 0583 	ubfx	r5, r0, #2, #4
    2762:	4426      	add	r6, r4
    2764:	fb0e 3305 	mla	r3, lr, r5, r3
    2768:	f3c1 0583 	ubfx	r5, r1, #2, #4
    276c:	f3c1 1146 	ubfx	r1, r1, #5, #7
                MATRES tmp=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    2770:	f9b7 0006 	ldrsh.w	r0, [r7, #6]
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    2774:	fb01 3505 	mla	r5, r1, r5, r3
                MATRES tmp=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    2778:	f836 3014 	ldrh.w	r3, [r6, r4, lsl #1]
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    277c:	f3c2 0e83 	ubfx	lr, r2, #2, #4
                MATRES tmp=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    2780:	fb13 f000 	smulbb	r0, r3, r0
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    2784:	f3c2 1246 	ubfx	r2, r2, #5, #7
    2788:	3708      	adds	r7, #8
    278a:	fb02 550e 	mla	r5, r2, lr, r5
    278e:	eb06 0644 	add.w	r6, r6, r4, lsl #1
    2792:	f3c0 0283 	ubfx	r2, r0, #2, #4
    2796:	f3c0 1146 	ubfx	r1, r0, #5, #7
            for(k=0;k<N;k++)
    279a:	45bc      	cmp	ip, r7
    279c:	4426      	add	r6, r4
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    279e:	fb01 5302 	mla	r3, r1, r2, r5
            for(k=0;k<N;k++)
    27a2:	d1c9      	bne.n	2738 <matrix_test+0xabc>
    27a4:	f108 0802 	add.w	r8, r8, #2
        for (j=0; j<N; j++) {
    27a8:	45c3      	cmp	fp, r8
    27aa:	f84a 3b04 	str.w	r3, [sl], #4
    27ae:	d182      	bne.n	26b6 <matrix_test+0xa3a>
    for (i=0; i<N; i++) {
    27b0:	9f04      	ldr	r7, [sp, #16]
    27b2:	9e01      	ldr	r6, [sp, #4]
    27b4:	9d02      	ldr	r5, [sp, #8]
    27b6:	9b05      	ldr	r3, [sp, #20]
    27b8:	3701      	adds	r7, #1
    27ba:	442e      	add	r6, r5
    27bc:	42bb      	cmp	r3, r7
    27be:	9704      	str	r7, [sp, #16]
    27c0:	9601      	str	r6, [sp, #4]
    27c2:	46e1      	mov	r9, ip
    27c4:	f47f af71 	bne.w	26aa <matrix_test+0xa2e>
    27c8:	f04f 0e00 	mov.w	lr, #0
    27cc:	f8dd 901c 	ldr.w	r9, [sp, #28]
    27d0:	9f09      	ldr	r7, [sp, #36]	; 0x24
    27d2:	f8dd 8020 	ldr.w	r8, [sp, #32]
    27d6:	4676      	mov	r6, lr
    27d8:	4670      	mov	r0, lr
    27da:	46f2      	mov	sl, lr
    27dc:	46ac      	mov	ip, r5
            cur=C[i*N+j];
    27de:	463c      	mov	r4, r7
                ret+=10;
    27e0:	b280      	uxth	r0, r0
            cur=C[i*N+j];
    27e2:	f854 2b04 	ldr.w	r2, [r4], #4
                ret += (cur>prev) ? 1 : 0;
    27e6:	4552      	cmp	r2, sl
    27e8:	bfd4      	ite	le
    27ea:	4601      	movle	r1, r0
    27ec:	1c41      	addgt	r1, r0, #1
            tmp+=cur;
    27ee:	4416      	add	r6, r2
    27f0:	454e      	cmp	r6, r9
                ret += (cur>prev) ? 1 : 0;
    27f2:	fa0f fa81 	sxth.w	sl, r1
                ret+=10;
    27f6:	f100 000a 	add.w	r0, r0, #10
    27fa:	4467      	add	r7, ip
    27fc:	b200      	sxth	r0, r0
    27fe:	f1ac 0504 	sub.w	r5, ip, #4
    2802:	bfd4      	ite	le
    2804:	4650      	movle	r0, sl
    2806:	2600      	movgt	r6, #0
        for (j=0; j<N; j++) {
    2808:	42a7      	cmp	r7, r4
            cur=C[i*N+j];
    280a:	4692      	mov	sl, r2
    280c:	f3c5 0381 	ubfx	r3, r5, #2, #2
        for (j=0; j<N; j++) {
    2810:	f000 808b 	beq.w	292a <matrix_test+0xcae>
    2814:	2b00      	cmp	r3, #0
    2816:	d03c      	beq.n	2892 <matrix_test+0xc16>
    2818:	2b01      	cmp	r3, #1
    281a:	d025      	beq.n	2868 <matrix_test+0xbec>
    281c:	2b02      	cmp	r3, #2
    281e:	d012      	beq.n	2846 <matrix_test+0xbca>
            cur=C[i*N+j];
    2820:	f854 1b04 	ldr.w	r1, [r4], #4
                ret+=10;
    2824:	fa1f fb80 	uxth.w	fp, r0
    2828:	f10b 000a 	add.w	r0, fp, #10
            tmp+=cur;
    282c:	440e      	add	r6, r1
                ret += (cur>prev) ? 1 : 0;
    282e:	4291      	cmp	r1, r2
    2830:	bfc8      	it	gt
    2832:	f10b 0b01 	addgt.w	fp, fp, #1
                ret+=10;
    2836:	b202      	sxth	r2, r0
    2838:	454e      	cmp	r6, r9
                ret += (cur>prev) ? 1 : 0;
    283a:	fa0f f08b 	sxth.w	r0, fp
    283e:	bfc4      	itt	gt
    2840:	2600      	movgt	r6, #0
    2842:	4610      	movgt	r0, r2
            cur=C[i*N+j];
    2844:	468a      	mov	sl, r1
    2846:	f854 5b04 	ldr.w	r5, [r4], #4
                ret+=10;
    284a:	b283      	uxth	r3, r0
    284c:	f103 010a 	add.w	r1, r3, #10
            tmp+=cur;
    2850:	442e      	add	r6, r5
                ret += (cur>prev) ? 1 : 0;
    2852:	4555      	cmp	r5, sl
    2854:	bfc8      	it	gt
    2856:	3301      	addgt	r3, #1
                ret+=10;
    2858:	fa0f fa81 	sxth.w	sl, r1
    285c:	454e      	cmp	r6, r9
                ret += (cur>prev) ? 1 : 0;
    285e:	b218      	sxth	r0, r3
    2860:	bfc4      	itt	gt
    2862:	2600      	movgt	r6, #0
    2864:	4650      	movgt	r0, sl
            cur=C[i*N+j];
    2866:	46aa      	mov	sl, r5
    2868:	f854 5b04 	ldr.w	r5, [r4], #4
                ret+=10;
    286c:	fa1f fb80 	uxth.w	fp, r0
    2870:	f10b 000a 	add.w	r0, fp, #10
            tmp+=cur;
    2874:	442e      	add	r6, r5
                ret += (cur>prev) ? 1 : 0;
    2876:	4555      	cmp	r5, sl
    2878:	bfc8      	it	gt
    287a:	f10b 0b01 	addgt.w	fp, fp, #1
                ret+=10;
    287e:	b202      	sxth	r2, r0
    2880:	454e      	cmp	r6, r9
                ret += (cur>prev) ? 1 : 0;
    2882:	fa0f f08b 	sxth.w	r0, fp
    2886:	bfc4      	itt	gt
    2888:	2600      	movgt	r6, #0
    288a:	4610      	movgt	r0, r2
        for (j=0; j<N; j++) {
    288c:	42a7      	cmp	r7, r4
            cur=C[i*N+j];
    288e:	46aa      	mov	sl, r5
        for (j=0; j<N; j++) {
    2890:	d04b      	beq.n	292a <matrix_test+0xcae>
            cur=C[i*N+j];
    2892:	4621      	mov	r1, r4
                ret+=10;
    2894:	b283      	uxth	r3, r0
            cur=C[i*N+j];
    2896:	f851 5b04 	ldr.w	r5, [r1], #4
    289a:	6860      	ldr	r0, [r4, #4]
    289c:	6849      	ldr	r1, [r1, #4]
    289e:	68e2      	ldr	r2, [r4, #12]
                ret += (cur>prev) ? 1 : 0;
    28a0:	4555      	cmp	r5, sl
    28a2:	bfd4      	ite	le
    28a4:	469b      	movle	fp, r3
    28a6:	f103 0b01 	addgt.w	fp, r3, #1
            tmp+=cur;
    28aa:	442e      	add	r6, r5
    28ac:	454e      	cmp	r6, r9
                ret += (cur>prev) ? 1 : 0;
    28ae:	fa0f fa8b 	sxth.w	sl, fp
                ret+=10;
    28b2:	f103 030a 	add.w	r3, r3, #10
    28b6:	b21b      	sxth	r3, r3
    28b8:	bfd4      	ite	le
    28ba:	4653      	movle	r3, sl
    28bc:	2600      	movgt	r6, #0
    28be:	fa1f fb83 	uxth.w	fp, r3
            tmp+=cur;
    28c2:	4406      	add	r6, r0
                ret+=10;
    28c4:	f10b 030a 	add.w	r3, fp, #10
                ret += (cur>prev) ? 1 : 0;
    28c8:	42a8      	cmp	r0, r5
    28ca:	bfc8      	it	gt
    28cc:	f10b 0b01 	addgt.w	fp, fp, #1
    28d0:	454e      	cmp	r6, r9
                ret+=10;
    28d2:	b21d      	sxth	r5, r3
                ret += (cur>prev) ? 1 : 0;
    28d4:	fa0f fa8b 	sxth.w	sl, fp
    28d8:	bfc4      	itt	gt
    28da:	46aa      	movgt	sl, r5
    28dc:	2600      	movgt	r6, #0
                ret+=10;
    28de:	fa1f fb8a 	uxth.w	fp, sl
                ret += (cur>prev) ? 1 : 0;
    28e2:	4281      	cmp	r1, r0
    28e4:	bfd4      	ite	le
    28e6:	4658      	movle	r0, fp
    28e8:	f10b 0001 	addgt.w	r0, fp, #1
            tmp+=cur;
    28ec:	198b      	adds	r3, r1, r6
    28ee:	454b      	cmp	r3, r9
                ret += (cur>prev) ? 1 : 0;
    28f0:	fa0f fa80 	sxth.w	sl, r0
                ret+=10;
    28f4:	f10b 050a 	add.w	r5, fp, #10
    28f8:	fa0f fb85 	sxth.w	fp, r5
    28fc:	bfda      	itte	le
    28fe:	46d3      	movle	fp, sl
    2900:	461e      	movle	r6, r3
    2902:	2600      	movgt	r6, #0
    2904:	fa1f f58b 	uxth.w	r5, fp
    2908:	f105 000a 	add.w	r0, r5, #10
            tmp+=cur;
    290c:	4416      	add	r6, r2
                ret += (cur>prev) ? 1 : 0;
    290e:	428a      	cmp	r2, r1
    2910:	bfc8      	it	gt
    2912:	3501      	addgt	r5, #1
    2914:	3410      	adds	r4, #16
    2916:	454e      	cmp	r6, r9
                ret+=10;
    2918:	b201      	sxth	r1, r0
    291a:	bfc8      	it	gt
    291c:	2600      	movgt	r6, #0
                ret += (cur>prev) ? 1 : 0;
    291e:	b228      	sxth	r0, r5
    2920:	bfc8      	it	gt
    2922:	4608      	movgt	r0, r1
        for (j=0; j<N; j++) {
    2924:	42a7      	cmp	r7, r4
            cur=C[i*N+j];
    2926:	4692      	mov	sl, r2
        for (j=0; j<N; j++) {
    2928:	d1b3      	bne.n	2892 <matrix_test+0xc16>
    for (i=0; i<N; i++) {
    292a:	f10e 0401 	add.w	r4, lr, #1
    292e:	45a0      	cmp	r8, r4
    2930:	d001      	beq.n	2936 <matrix_test+0xcba>
    2932:	46a6      	mov	lr, r4
    2934:	e753      	b.n	27de <matrix_test+0xb62>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    2936:	9906      	ldr	r1, [sp, #24]
    2938:	f8cd e01c 	str.w	lr, [sp, #28]
    293c:	f000 ffca 	bl	38d4 <crc16>
    2940:	9008      	str	r0, [sp, #32]
    2942:	980b      	ldr	r0, [sp, #44]	; 0x2c
    2944:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    matrix_add_const(N,A,-val); /* return matrix to initial value */
    2946:	f04f 0a00 	mov.w	sl, #0
    294a:	0066      	lsls	r6, r4, #1
    294c:	46d1      	mov	r9, sl
    294e:	9604      	str	r6, [sp, #16]
    2950:	4683      	mov	fp, r0
    2952:	e0da      	b.n	2b0a <matrix_test+0xe8e>
            A[i*N+j] += val;
    2954:	f8bb 5000 	ldrh.w	r5, [fp]
    matrix_add_const(N,A,-val); /* return matrix to initial value */
    2958:	4621      	mov	r1, r4
            A[i*N+j] += val;
    295a:	1aae      	subs	r6, r5, r2
    295c:	2901      	cmp	r1, #1
    295e:	f8ab 6000 	strh.w	r6, [fp]
    2962:	f000 80ea 	beq.w	2b3a <matrix_test+0xebe>
    2966:	f8bb 7002 	ldrh.w	r7, [fp, #2]
    296a:	2902      	cmp	r1, #2
    296c:	eba7 0302 	sub.w	r3, r7, r2
    2970:	f8ab 3002 	strh.w	r3, [fp, #2]
    2974:	f000 80e1 	beq.w	2b3a <matrix_test+0xebe>
    2978:	f8bb 5004 	ldrh.w	r5, [fp, #4]
    297c:	2903      	cmp	r1, #3
    297e:	eba5 0602 	sub.w	r6, r5, r2
    2982:	f8ab 6004 	strh.w	r6, [fp, #4]
    2986:	f000 80d8 	beq.w	2b3a <matrix_test+0xebe>
    298a:	f8bb 7006 	ldrh.w	r7, [fp, #6]
    298e:	1abb      	subs	r3, r7, r2
    2990:	f8ab 3006 	strh.w	r3, [fp, #6]
        for (j=0; j<N; j++) {
    2994:	2304      	movs	r3, #4
    2996:	428c      	cmp	r4, r1
    2998:	f000 80b0 	beq.w	2afc <matrix_test+0xe80>
    299c:	1a65      	subs	r5, r4, r1
    299e:	1f2e      	subs	r6, r5, #4
    29a0:	9503      	str	r5, [sp, #12]
    29a2:	08b5      	lsrs	r5, r6, #2
    29a4:	9e07      	ldr	r6, [sp, #28]
    29a6:	1c6f      	adds	r7, r5, #1
    29a8:	1a76      	subs	r6, r6, r1
    29aa:	9701      	str	r7, [sp, #4]
    29ac:	2e02      	cmp	r6, #2
    29ae:	ea4f 0787 	mov.w	r7, r7, lsl #2
    29b2:	9702      	str	r7, [sp, #8]
    29b4:	f240 8087 	bls.w	2ac6 <matrix_test+0xe4a>
    29b8:	4451      	add	r1, sl
    29ba:	eb00 0641 	add.w	r6, r0, r1, lsl #1
            A[i*N+j] += val;
    29be:	f850 e011 	ldr.w	lr, [r0, r1, lsl #1]
    29c2:	9105      	str	r1, [sp, #20]
    29c4:	ebae 0102 	sub.w	r1, lr, r2
    29c8:	9106      	str	r1, [sp, #24]
    29ca:	6871      	ldr	r1, [r6, #4]
    29cc:	eba1 0802 	sub.w	r8, r1, r2
    29d0:	9906      	ldr	r1, [sp, #24]
    29d2:	2700      	movs	r7, #0
    29d4:	46bc      	mov	ip, r7
    29d6:	ebc2 4e1e 	rsb	lr, r2, lr, lsr #16
    29da:	f361 070f 	bfi	r7, r1, #0, #16
    29de:	f36e 471f 	bfi	r7, lr, #16, #16
    29e2:	f005 0e01 	and.w	lr, r5, #1
    29e6:	9d05      	ldr	r5, [sp, #20]
    29e8:	6871      	ldr	r1, [r6, #4]
    29ea:	f840 7015 	str.w	r7, [r0, r5, lsl #1]
    29ee:	9d01      	ldr	r5, [sp, #4]
    29f0:	ebc2 4111 	rsb	r1, r2, r1, lsr #16
    29f4:	f368 0c0f 	bfi	ip, r8, #0, #16
    29f8:	2701      	movs	r7, #1
    29fa:	f361 4c1f 	bfi	ip, r1, #16, #16
    29fe:	42bd      	cmp	r5, r7
    2a00:	f106 0108 	add.w	r1, r6, #8
    2a04:	f8c6 c004 	str.w	ip, [r6, #4]
    2a08:	d958      	bls.n	2abc <matrix_test+0xe40>
    2a0a:	f1be 0f00 	cmp.w	lr, #0
    2a0e:	d01b      	beq.n	2a48 <matrix_test+0xdcc>
    2a10:	680f      	ldr	r7, [r1, #0]
    2a12:	684e      	ldr	r6, [r1, #4]
    2a14:	2500      	movs	r5, #0
    2a16:	eba7 0c02 	sub.w	ip, r7, r2
    2a1a:	46ae      	mov	lr, r5
    2a1c:	ebc2 4817 	rsb	r8, r2, r7, lsr #16
    2a20:	1ab7      	subs	r7, r6, r2
    2a22:	f367 0e0f 	bfi	lr, r7, #0, #16
    2a26:	ebc2 4616 	rsb	r6, r2, r6, lsr #16
    2a2a:	f36c 050f 	bfi	r5, ip, #0, #16
    2a2e:	f368 451f 	bfi	r5, r8, #16, #16
    2a32:	f366 4e1f 	bfi	lr, r6, #16, #16
    2a36:	e881 4020 	stmia.w	r1, {r5, lr}
    2a3a:	9d01      	ldr	r5, [sp, #4]
    2a3c:	2702      	movs	r7, #2
    2a3e:	42bd      	cmp	r5, r7
    2a40:	460e      	mov	r6, r1
    2a42:	f101 0108 	add.w	r1, r1, #8
    2a46:	d939      	bls.n	2abc <matrix_test+0xe40>
    2a48:	9405      	str	r4, [sp, #20]
    2a4a:	9306      	str	r3, [sp, #24]
    2a4c:	68b5      	ldr	r5, [r6, #8]
    2a4e:	f106 0e08 	add.w	lr, r6, #8
    2a52:	68f6      	ldr	r6, [r6, #12]
    2a54:	2400      	movs	r4, #0
    2a56:	1ab3      	subs	r3, r6, r2
    2a58:	eba5 0802 	sub.w	r8, r5, r2
    2a5c:	46a4      	mov	ip, r4
    2a5e:	ebc2 4616 	rsb	r6, r2, r6, lsr #16
    2a62:	f363 0c0f 	bfi	ip, r3, #0, #16
    2a66:	f368 040f 	bfi	r4, r8, #0, #16
    2a6a:	ebc2 4515 	rsb	r5, r2, r5, lsr #16
    2a6e:	f366 4c1f 	bfi	ip, r6, #16, #16
    2a72:	f365 441f 	bfi	r4, r5, #16, #16
    2a76:	e881 1010 	stmia.w	r1, {r4, ip}
    2a7a:	f10e 0608 	add.w	r6, lr, #8
    2a7e:	f8de e008 	ldr.w	lr, [lr, #8]
    2a82:	6873      	ldr	r3, [r6, #4]
    2a84:	2400      	movs	r4, #0
    2a86:	ebae 0802 	sub.w	r8, lr, r2
    2a8a:	46a4      	mov	ip, r4
    2a8c:	ebc2 4e1e 	rsb	lr, r2, lr, lsr #16
    2a90:	f368 040f 	bfi	r4, r8, #0, #16
    2a94:	f36e 441f 	bfi	r4, lr, #16, #16
    2a98:	1a9d      	subs	r5, r3, r2
    2a9a:	608c      	str	r4, [r1, #8]
    2a9c:	9c01      	ldr	r4, [sp, #4]
    2a9e:	f365 0c0f 	bfi	ip, r5, #0, #16
    2aa2:	ebc2 4313 	rsb	r3, r2, r3, lsr #16
    2aa6:	3702      	adds	r7, #2
    2aa8:	f363 4c1f 	bfi	ip, r3, #16, #16
    2aac:	42bc      	cmp	r4, r7
    2aae:	f8c1 c00c 	str.w	ip, [r1, #12]
    2ab2:	f101 0110 	add.w	r1, r1, #16
    2ab6:	d8c9      	bhi.n	2a4c <matrix_test+0xdd0>
    2ab8:	9c05      	ldr	r4, [sp, #20]
    2aba:	9b06      	ldr	r3, [sp, #24]
    2abc:	9902      	ldr	r1, [sp, #8]
    2abe:	9e03      	ldr	r6, [sp, #12]
    2ac0:	42b1      	cmp	r1, r6
    2ac2:	440b      	add	r3, r1
    2ac4:	d01a      	beq.n	2afc <matrix_test+0xe80>
    2ac6:	eb0a 0803 	add.w	r8, sl, r3
        for (j=0; j<N; j++) {
    2aca:	1c59      	adds	r1, r3, #1
            A[i*N+j] += val;
    2acc:	f830 5018 	ldrh.w	r5, [r0, r8, lsl #1]
        for (j=0; j<N; j++) {
    2ad0:	428c      	cmp	r4, r1
            A[i*N+j] += val;
    2ad2:	eba5 0702 	sub.w	r7, r5, r2
    2ad6:	f820 7018 	strh.w	r7, [r0, r8, lsl #1]
        for (j=0; j<N; j++) {
    2ada:	d90f      	bls.n	2afc <matrix_test+0xe80>
            A[i*N+j] += val;
    2adc:	4451      	add	r1, sl
        for (j=0; j<N; j++) {
    2ade:	3302      	adds	r3, #2
            A[i*N+j] += val;
    2ae0:	f830 6011 	ldrh.w	r6, [r0, r1, lsl #1]
        for (j=0; j<N; j++) {
    2ae4:	429c      	cmp	r4, r3
            A[i*N+j] += val;
    2ae6:	eba6 0502 	sub.w	r5, r6, r2
    2aea:	f820 5011 	strh.w	r5, [r0, r1, lsl #1]
        for (j=0; j<N; j++) {
    2aee:	d905      	bls.n	2afc <matrix_test+0xe80>
            A[i*N+j] += val;
    2af0:	4453      	add	r3, sl
    2af2:	f830 1013 	ldrh.w	r1, [r0, r3, lsl #1]
    2af6:	1a8f      	subs	r7, r1, r2
    2af8:	f820 7013 	strh.w	r7, [r0, r3, lsl #1]
    for (i=0; i<N; i++) {
    2afc:	f109 0901 	add.w	r9, r9, #1
    2b00:	9b04      	ldr	r3, [sp, #16]
    2b02:	45a1      	cmp	r9, r4
    2b04:	449b      	add	fp, r3
    2b06:	44a2      	add	sl, r4
    2b08:	d02a      	beq.n	2b60 <matrix_test+0xee4>
    2b0a:	ea4f 075b 	mov.w	r7, fp, lsr #1
    2b0e:	427b      	negs	r3, r7
    2b10:	f003 0303 	and.w	r3, r3, #3
    2b14:	42a3      	cmp	r3, r4
    2b16:	bf28      	it	cs
    2b18:	4623      	movcs	r3, r4
    2b1a:	2c04      	cmp	r4, #4
    2b1c:	f67f af1a 	bls.w	2954 <matrix_test+0xcd8>
    matrix_add_const(N,A,-val); /* return matrix to initial value */
    2b20:	4619      	mov	r1, r3
    2b22:	2b00      	cmp	r3, #0
    2b24:	f43f af3a 	beq.w	299c <matrix_test+0xd20>
            A[i*N+j] += val;
    2b28:	f8bb 5000 	ldrh.w	r5, [fp]
    2b2c:	2901      	cmp	r1, #1
    2b2e:	eba5 0602 	sub.w	r6, r5, r2
    2b32:	f8ab 6000 	strh.w	r6, [fp]
    2b36:	f47f af16 	bne.w	2966 <matrix_test+0xcea>
        for (j=0; j<N; j++) {
    2b3a:	460b      	mov	r3, r1
    2b3c:	e72b      	b.n	2996 <matrix_test+0xd1a>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    2b3e:	4601      	mov	r1, r0
    2b40:	4604      	mov	r4, r0
    2b42:	f000 fec7 	bl	38d4 <crc16>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    2b46:	4601      	mov	r1, r0
    2b48:	4620      	mov	r0, r4
    2b4a:	f000 fec3 	bl	38d4 <crc16>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    2b4e:	4601      	mov	r1, r0
    2b50:	4620      	mov	r0, r4
    2b52:	f000 febf 	bl	38d4 <crc16>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    2b56:	4601      	mov	r1, r0
    2b58:	4620      	mov	r0, r4
    2b5a:	f000 febb 	bl	38d4 <crc16>
    2b5e:	9008      	str	r0, [sp, #32]
    return crc;
    2b60:	f9bd 0020 	ldrsh.w	r0, [sp, #32]
}
    2b64:	b011      	add	sp, #68	; 0x44
    2b66:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2b6a:	bf00      	nop

00002b6c <core_bench_matrix>:
ee_u16 core_bench_matrix(mat_params *p, ee_s16 seed, ee_u16 crc) {
    2b6c:	b530      	push	{r4, r5, lr}
    2b6e:	4614      	mov	r4, r2
    crc=crc16(matrix_test(N,C,A,B,val),crc);
    2b70:	c82d      	ldmia	r0, {r0, r2, r3, r5}
ee_u16 core_bench_matrix(mat_params *p, ee_s16 seed, ee_u16 crc) {
    2b72:	b083      	sub	sp, #12
    crc=crc16(matrix_test(N,C,A,B,val),crc);
    2b74:	9100      	str	r1, [sp, #0]
    2b76:	4629      	mov	r1, r5
    2b78:	f7ff f880 	bl	1c7c <matrix_test>
    2b7c:	4621      	mov	r1, r4
}
    2b7e:	b003      	add	sp, #12
    2b80:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    crc=crc16(matrix_test(N,C,A,B,val),crc);
    2b84:	f000 bea6 	b.w	38d4 <crc16>

00002b88 <core_init_matrix>:
ee_u32 core_init_matrix(ee_u32 blksize, void *memblk, ee_s32 seed, mat_params *p) {
    2b88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2b8c:	b087      	sub	sp, #28
        seed=1;
    2b8e:	2a00      	cmp	r2, #0
    2b90:	bf08      	it	eq
    2b92:	2201      	moveq	r2, #1
ee_u32 core_init_matrix(ee_u32 blksize, void *memblk, ee_s32 seed, mat_params *p) {
    2b94:	9305      	str	r3, [sp, #20]
    while (j<blksize) {
    2b96:	2800      	cmp	r0, #0
    2b98:	f000 810c 	beq.w	2db4 <core_init_matrix+0x22c>
    2b9c:	4684      	mov	ip, r0
    2b9e:	2000      	movs	r0, #0
    2ba0:	e000      	b.n	2ba4 <core_init_matrix+0x1c>
        i++;
    2ba2:	4630      	mov	r0, r6
    2ba4:	1c46      	adds	r6, r0, #1
        j=i*i*2*4;
    2ba6:	fb06 f706 	mul.w	r7, r6, r6
    while (j<blksize) {
    2baa:	ebbc 0fc7 	cmp.w	ip, r7, lsl #3
    2bae:	d8f8      	bhi.n	2ba2 <core_init_matrix+0x1a>
    A=(MATDAT *)align_mem(memblk);
    2bb0:	f101 38ff 	add.w	r8, r1, #4294967295
    2bb4:	f028 0403 	bic.w	r4, r8, #3
    2bb8:	3404      	adds	r4, #4
    B=A+N*N;
    2bba:	fb00 f300 	mul.w	r3, r0, r0
    2bbe:	0059      	lsls	r1, r3, #1
    2bc0:	4627      	mov	r7, r4
    2bc2:	440f      	add	r7, r1
    A=(MATDAT *)align_mem(memblk);
    2bc4:	9401      	str	r4, [sp, #4]
    B=A+N*N;
    2bc6:	9103      	str	r1, [sp, #12]
    2bc8:	9702      	str	r7, [sp, #8]
    2bca:	9004      	str	r0, [sp, #16]
    for (i=0; i<N; i++) {
    2bcc:	2800      	cmp	r0, #0
    2bce:	f000 80de 	beq.w	2d8e <core_init_matrix+0x206>
    N=i-1;
    2bd2:	2400      	movs	r4, #0
    2bd4:	9400      	str	r4, [sp, #0]
    2bd6:	2601      	movs	r6, #1
            seed = ( ( order * seed ) % 65536 );
    2bd8:	fb06 f202 	mul.w	r2, r6, r2
    2bdc:	f1d2 0900 	rsbs	r9, r2, #0
    2be0:	fa1f f389 	uxth.w	r3, r9
    2be4:	9f00      	ldr	r7, [sp, #0]
    2be6:	9901      	ldr	r1, [sp, #4]
            val = (seed + order);
    2be8:	fa1f fa86 	uxth.w	sl, r6
            seed = ( ( order * seed ) % 65536 );
    2bec:	b292      	uxth	r2, r2
    2bee:	bf58      	it	pl
    2bf0:	425a      	negpl	r2, r3
            val = (seed + order);
    2bf2:	eb0a 0502 	add.w	r5, sl, r2
    2bf6:	fb00 f707 	mul.w	r7, r0, r7
    2bfa:	9b02      	ldr	r3, [sp, #8]
    2bfc:	fa1f fe85 	uxth.w	lr, r5
    2c00:	007c      	lsls	r4, r7, #1
    2c02:	191d      	adds	r5, r3, r4
        for (j=0; j<N; j++) {
    2c04:	f04f 0b01 	mov.w	fp, #1
            B[i*N+j] = val;
    2c08:	f823 e017 	strh.w	lr, [r3, r7, lsl #1]
            val =  (val + order);
    2c0c:	44f2      	add	sl, lr
            A[i*N+j] = val;
    2c0e:	9b01      	ldr	r3, [sp, #4]
    2c10:	440c      	add	r4, r1
    2c12:	f100 38ff 	add.w	r8, r0, #4294967295
            val=matrix_clip(val,1);
    2c16:	fa5f fc8a 	uxtb.w	ip, sl
        for (j=0; j<N; j++) {
    2c1a:	4583      	cmp	fp, r0
    2c1c:	f008 0103 	and.w	r1, r8, #3
            order++;
    2c20:	445e      	add	r6, fp
            A[i*N+j] = val;
    2c22:	f823 c017 	strh.w	ip, [r3, r7, lsl #1]
    2c26:	f105 0902 	add.w	r9, r5, #2
    2c2a:	f104 0802 	add.w	r8, r4, #2
        for (j=0; j<N; j++) {
    2c2e:	f080 80a7 	bcs.w	2d80 <core_init_matrix+0x1f8>
    2c32:	2900      	cmp	r1, #0
    2c34:	d045      	beq.n	2cc2 <core_init_matrix+0x13a>
    2c36:	2901      	cmp	r1, #1
    2c38:	d02c      	beq.n	2c94 <core_init_matrix+0x10c>
    2c3a:	2902      	cmp	r1, #2
    2c3c:	d016      	beq.n	2c6c <core_init_matrix+0xe4>
            seed = ( ( order * seed ) % 65536 );
    2c3e:	fb06 f202 	mul.w	r2, r6, r2
    2c42:	4257      	negs	r7, r2
    2c44:	b2b9      	uxth	r1, r7
            val = (seed + order);
    2c46:	b2b3      	uxth	r3, r6
            seed = ( ( order * seed ) % 65536 );
    2c48:	b292      	uxth	r2, r2
    2c4a:	bf58      	it	pl
    2c4c:	424a      	negpl	r2, r1
            val = (seed + order);
    2c4e:	189f      	adds	r7, r3, r2
    2c50:	fa1f fb87 	uxth.w	fp, r7
            val =  (val + order);
    2c54:	445b      	add	r3, fp
            val=matrix_clip(val,1);
    2c56:	b2d9      	uxtb	r1, r3
            B[i*N+j] = val;
    2c58:	f8a5 b002 	strh.w	fp, [r5, #2]
    2c5c:	f109 0902 	add.w	r9, r9, #2
    2c60:	f108 0802 	add.w	r8, r8, #2
            order++;
    2c64:	3601      	adds	r6, #1
        for (j=0; j<N; j++) {
    2c66:	f04f 0b02 	mov.w	fp, #2
            A[i*N+j] = val;
    2c6a:	8061      	strh	r1, [r4, #2]
            seed = ( ( order * seed ) % 65536 );
    2c6c:	fb06 f202 	mul.w	r2, r6, r2
    2c70:	4254      	negs	r4, r2
    2c72:	b2a5      	uxth	r5, r4
            val = (seed + order);
    2c74:	b2b3      	uxth	r3, r6
            seed = ( ( order * seed ) % 65536 );
    2c76:	b292      	uxth	r2, r2
    2c78:	bf58      	it	pl
    2c7a:	426a      	negpl	r2, r5
            val = (seed + order);
    2c7c:	189f      	adds	r7, r3, r2
    2c7e:	fa1f fa87 	uxth.w	sl, r7
            val =  (val + order);
    2c82:	4453      	add	r3, sl
            val=matrix_clip(val,1);
    2c84:	b2d9      	uxtb	r1, r3
            B[i*N+j] = val;
    2c86:	f829 ab02 	strh.w	sl, [r9], #2
            A[i*N+j] = val;
    2c8a:	f828 1b02 	strh.w	r1, [r8], #2
        for (j=0; j<N; j++) {
    2c8e:	f10b 0b01 	add.w	fp, fp, #1
            order++;
    2c92:	3601      	adds	r6, #1
            seed = ( ( order * seed ) % 65536 );
    2c94:	fb06 f202 	mul.w	r2, r6, r2
    2c98:	4254      	negs	r4, r2
    2c9a:	b2a5      	uxth	r5, r4
            val = (seed + order);
    2c9c:	b2b3      	uxth	r3, r6
            seed = ( ( order * seed ) % 65536 );
    2c9e:	b292      	uxth	r2, r2
    2ca0:	bf58      	it	pl
    2ca2:	426a      	negpl	r2, r5
            val = (seed + order);
    2ca4:	189f      	adds	r7, r3, r2
    2ca6:	fa1f fc87 	uxth.w	ip, r7
            val =  (val + order);
    2caa:	4463      	add	r3, ip
        for (j=0; j<N; j++) {
    2cac:	f10b 0b01 	add.w	fp, fp, #1
            val=matrix_clip(val,1);
    2cb0:	b2d9      	uxtb	r1, r3
        for (j=0; j<N; j++) {
    2cb2:	4583      	cmp	fp, r0
            B[i*N+j] = val;
    2cb4:	f829 cb02 	strh.w	ip, [r9], #2
            order++;
    2cb8:	f106 0601 	add.w	r6, r6, #1
            A[i*N+j] = val;
    2cbc:	f828 1b02 	strh.w	r1, [r8], #2
        for (j=0; j<N; j++) {
    2cc0:	d25e      	bcs.n	2d80 <core_init_matrix+0x1f8>
            seed = ( ( order * seed ) % 65536 );
    2cc2:	fb06 f202 	mul.w	r2, r6, r2
    2cc6:	4254      	negs	r4, r2
    2cc8:	b2a5      	uxth	r5, r4
    2cca:	fa1f fe82 	uxth.w	lr, r2
            order++;
    2cce:	f106 0401 	add.w	r4, r6, #1
            seed = ( ( order * seed ) % 65536 );
    2cd2:	bf58      	it	pl
    2cd4:	f1c5 0e00 	rsbpl	lr, r5, #0
    2cd8:	fb04 f20e 	mul.w	r2, r4, lr
    2cdc:	f1d2 0a00 	rsbs	sl, r2, #0
    2ce0:	fa1f f38a 	uxth.w	r3, sl
    2ce4:	b291      	uxth	r1, r2
            order++;
    2ce6:	f106 0702 	add.w	r7, r6, #2
            seed = ( ( order * seed ) % 65536 );
    2cea:	bf58      	it	pl
    2cec:	4259      	negpl	r1, r3
    2cee:	fb07 f501 	mul.w	r5, r7, r1
    2cf2:	f1d5 0c00 	rsbs	ip, r5, #0
    2cf6:	fa1f f28c 	uxth.w	r2, ip
    2cfa:	b2ab      	uxth	r3, r5
    2cfc:	bf58      	it	pl
    2cfe:	4253      	negpl	r3, r2
            order++;
    2d00:	1cf5      	adds	r5, r6, #3
            seed = ( ( order * seed ) % 65536 );
    2d02:	fb05 f203 	mul.w	r2, r5, r3
    2d06:	f1d2 0a00 	rsbs	sl, r2, #0
            val = (seed + order);
    2d0a:	fa1f fc86 	uxth.w	ip, r6
            seed = ( ( order * seed ) % 65536 );
    2d0e:	fa1f fa8a 	uxth.w	sl, sl
            val = (seed + order);
    2d12:	44e6      	add	lr, ip
            seed = ( ( order * seed ) % 65536 );
    2d14:	b292      	uxth	r2, r2
    2d16:	bf58      	it	pl
    2d18:	f1ca 0200 	rsbpl	r2, sl, #0
            B[i*N+j] = val;
    2d1c:	46ca      	mov	sl, r9
            val = (seed + order);
    2d1e:	fa1f fe8e 	uxth.w	lr, lr
            B[i*N+j] = val;
    2d22:	f82a eb02 	strh.w	lr, [sl], #2
            val =  (val + order);
    2d26:	44f4      	add	ip, lr
            A[i*N+j] = val;
    2d28:	46c6      	mov	lr, r8
            val = (seed + order);
    2d2a:	b2a4      	uxth	r4, r4
    2d2c:	b2bf      	uxth	r7, r7
    2d2e:	b2ad      	uxth	r5, r5
            val=matrix_clip(val,1);
    2d30:	fa5f fc8c 	uxtb.w	ip, ip
            A[i*N+j] = val;
    2d34:	f82e cb02 	strh.w	ip, [lr], #2
            val = (seed + order);
    2d38:	4421      	add	r1, r4
    2d3a:	443b      	add	r3, r7
    2d3c:	eb05 0c02 	add.w	ip, r5, r2
    2d40:	b289      	uxth	r1, r1
    2d42:	b29b      	uxth	r3, r3
    2d44:	fa1f fc8c 	uxth.w	ip, ip
            val =  (val + order);
    2d48:	440c      	add	r4, r1
    2d4a:	441f      	add	r7, r3
    2d4c:	4465      	add	r5, ip
        for (j=0; j<N; j++) {
    2d4e:	f10b 0b04 	add.w	fp, fp, #4
            val=matrix_clip(val,1);
    2d52:	b2e4      	uxtb	r4, r4
    2d54:	b2ff      	uxtb	r7, r7
    2d56:	b2ed      	uxtb	r5, r5
        for (j=0; j<N; j++) {
    2d58:	4583      	cmp	fp, r0
            B[i*N+j] = val;
    2d5a:	f8a9 1002 	strh.w	r1, [r9, #2]
            order++;
    2d5e:	f106 0604 	add.w	r6, r6, #4
            A[i*N+j] = val;
    2d62:	f8a8 4002 	strh.w	r4, [r8, #2]
    2d66:	f109 0908 	add.w	r9, r9, #8
            B[i*N+j] = val;
    2d6a:	f8aa 3002 	strh.w	r3, [sl, #2]
    2d6e:	f108 0808 	add.w	r8, r8, #8
            A[i*N+j] = val;
    2d72:	f8ae 7002 	strh.w	r7, [lr, #2]
            B[i*N+j] = val;
    2d76:	f829 cc02 	strh.w	ip, [r9, #-2]
            A[i*N+j] = val;
    2d7a:	f828 5c02 	strh.w	r5, [r8, #-2]
        for (j=0; j<N; j++) {
    2d7e:	d3a0      	bcc.n	2cc2 <core_init_matrix+0x13a>
    for (i=0; i<N; i++) {
    2d80:	9900      	ldr	r1, [sp, #0]
    2d82:	3101      	adds	r1, #1
    2d84:	4281      	cmp	r1, r0
    2d86:	9100      	str	r1, [sp, #0]
    2d88:	f4ff af26 	bcc.w	2bd8 <core_init_matrix+0x50>
    2d8c:	9903      	ldr	r1, [sp, #12]
    p->C=(MATRES *)align_mem(B+N*N);
    2d8e:	9e02      	ldr	r6, [sp, #8]
    p->A=A;
    2d90:	9c01      	ldr	r4, [sp, #4]
    p->N=N;
    2d92:	9d04      	ldr	r5, [sp, #16]
    p->C=(MATRES *)align_mem(B+N*N);
    2d94:	4431      	add	r1, r6
    2d96:	1e4a      	subs	r2, r1, #1
    2d98:	f022 0303 	bic.w	r3, r2, #3
    2d9c:	9a05      	ldr	r2, [sp, #20]
    2d9e:	4690      	mov	r8, r2
    p->B=B;
    2da0:	46c2      	mov	sl, r8
    p->C=(MATRES *)align_mem(B+N*N);
    2da2:	3304      	adds	r3, #4
    2da4:	60d3      	str	r3, [r2, #12]
    p->A=A;
    2da6:	6054      	str	r4, [r2, #4]
    p->B=B;
    2da8:	f8ca 6008 	str.w	r6, [sl, #8]
    p->N=N;
    2dac:	6015      	str	r5, [r2, #0]
}
    2dae:	b007      	add	sp, #28
    2db0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    A=(MATDAT *)align_mem(memblk);
    2db4:	1e4b      	subs	r3, r1, #1
    2db6:	f023 0403 	bic.w	r4, r3, #3
    2dba:	1d20      	adds	r0, r4, #4
    B=A+N*N;
    2dbc:	f04f 31ff 	mov.w	r1, #4294967295
    2dc0:	3406      	adds	r4, #6
    2dc2:	2502      	movs	r5, #2
    A=(MATDAT *)align_mem(memblk);
    2dc4:	9001      	str	r0, [sp, #4]
    B=A+N*N;
    2dc6:	9104      	str	r1, [sp, #16]
    2dc8:	9402      	str	r4, [sp, #8]
    N=i-1;
    2dca:	4608      	mov	r0, r1
    B=A+N*N;
    2dcc:	9503      	str	r5, [sp, #12]
    2dce:	e700      	b.n	2bd2 <core_init_matrix+0x4a>

00002dd0 <start_time>:
    This function will be called right before starting the timed portion of the benchmark.

    Implementation may be capturing a system timer (as implemented in the example code)
    or zeroing some system parameters - e.g. setting the cpu clocks cycles to 0.
*/
void start_time(void) {
    2dd0:	b508      	push	{r3, lr}
    am_hal_systick_load(0x00FFFFFF);
    2dd2:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
    2dd6:	f002 f9c3 	bl	5160 <am_hal_systick_load>
    am_hal_systick_int_enable();
    2dda:	f002 f9b9 	bl	5150 <am_hal_systick_int_enable>
    am_hal_systick_start();
    2dde:	f002 f9a7 	bl	5130 <am_hal_systick_start>
    start_time_val = GETMYTIME;
    2de2:	f002 f9c3 	bl	516c <am_hal_systick_count>
    2de6:	4b04      	ldr	r3, [pc, #16]	; (2df8 <start_time+0x28>)
    2de8:	4904      	ldr	r1, [pc, #16]	; (2dfc <start_time+0x2c>)
    2dea:	681b      	ldr	r3, [r3, #0]
    START_PA_DUMP = 0x1;
    2dec:	4a04      	ldr	r2, [pc, #16]	; (2e00 <start_time+0x30>)
    start_time_val = GETMYTIME;
    2dee:	4418      	add	r0, r3
    START_PA_DUMP = 0x1;
    2df0:	2301      	movs	r3, #1
    start_time_val = GETMYTIME;
    2df2:	6008      	str	r0, [r1, #0]
    START_PA_DUMP = 0x1;
    2df4:	6013      	str	r3, [r2, #0]
    2df6:	bd08      	pop	{r3, pc}
    2df8:	10001048 	.word	0x10001048
    2dfc:	1000105c 	.word	0x1000105c
    2e00:	4ffff014 	.word	0x4ffff014

00002e04 <stop_time>:
    This function will be called right after ending the timed portion of the benchmark.

    Implementation may be capturing a system timer (as implemented in the example code)
    or other system parameters - e.g. reading the current value of cpu cycles counter.
*/
void stop_time(void) {
    2e04:	b508      	push	{r3, lr}
    am_hal_systick_stop();
    2e06:	f002 f99b 	bl	5140 <am_hal_systick_stop>
    stop_time_val = GETMYTIME;
    2e0a:	f002 f9af 	bl	516c <am_hal_systick_count>
    2e0e:	4b04      	ldr	r3, [pc, #16]	; (2e20 <stop_time+0x1c>)
    2e10:	4904      	ldr	r1, [pc, #16]	; (2e24 <stop_time+0x20>)
    2e12:	681b      	ldr	r3, [r3, #0]
    START_PA_DUMP = 0x0;
    2e14:	4a04      	ldr	r2, [pc, #16]	; (2e28 <stop_time+0x24>)
    stop_time_val = GETMYTIME;
    2e16:	4418      	add	r0, r3
    START_PA_DUMP = 0x0;
    2e18:	2300      	movs	r3, #0
    stop_time_val = GETMYTIME;
    2e1a:	6008      	str	r0, [r1, #0]
    START_PA_DUMP = 0x0;
    2e1c:	6013      	str	r3, [r2, #0]
    2e1e:	bd08      	pop	{r3, pc}
    2e20:	10001048 	.word	0x10001048
    2e24:	10001060 	.word	0x10001060
    2e28:	4ffff014 	.word	0x4ffff014

00002e2c <get_time>:
    This methodology is taken to accomodate any hardware or simulated platform.
    The sample implementation returns millisecs by default,
    and the resolution is controlled by <TIMER_RES_DIVIDER>
*/
CORE_TICKS get_time(void) {
    CORE_TICKS elapsed=(CORE_TICKS)(MYTIMEDIFF(stop_time_val, start_time_val));
    2e2c:	4a02      	ldr	r2, [pc, #8]	; (2e38 <get_time+0xc>)
    2e2e:	4b03      	ldr	r3, [pc, #12]	; (2e3c <get_time+0x10>)
    2e30:	6810      	ldr	r0, [r2, #0]
    2e32:	6819      	ldr	r1, [r3, #0]
    return elapsed;
}
    2e34:	1a40      	subs	r0, r0, r1
    2e36:	4770      	bx	lr
    2e38:	10001060 	.word	0x10001060
    2e3c:	1000105c 	.word	0x1000105c

00002e40 <time_in_secs>:
    Convert the value returned by get_time to seconds.

    The <secs_ret> type is used to accomodate systems with no support for floating point.
    Default implementation implemented by the EE_TICKS_PER_SEC macro above.
*/
secs_ret time_in_secs(CORE_TICKS ticks) {
    2e40:	b508      	push	{r3, lr}
    secs_ret retval=((secs_ret)ticks) / (secs_ret)EE_TICKS_PER_SEC;
    2e42:	f7fd fa5f 	bl	304 <__aeabi_ui2d>
    2e46:	a304      	add	r3, pc, #16	; (adr r3, 2e58 <time_in_secs+0x18>)
    2e48:	e9d3 2300 	ldrd	r2, r3, [r3]
    2e4c:	f7fd fbfa 	bl	644 <__aeabi_ddiv>
    return retval;
}
    2e50:	bd08      	pop	{r3, pc}
    2e52:	bf00      	nop
    2e54:	f3af 8000 	nop.w
    2e58:	00000000 	.word	0x00000000
    2e5c:	4176e360 	.word	0x4176e360

00002e60 <portable_init>:
    Target specific initialization code
    Test for some common mistakes.
*/

void portable_init(core_portable *p, int *argc, char *argv[])
{
    2e60:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    2e64:	f8df a128 	ldr.w	sl, [pc, #296]	; 2f90 <portable_init+0x130>
    am_bsp_pin_enable(COM_UART_TX);
    2e68:	4d41      	ldr	r5, [pc, #260]	; (2f70 <portable_init+0x110>)
    2e6a:	4e42      	ldr	r6, [pc, #264]	; (2f74 <portable_init+0x114>)
    2e6c:	f8df 8124 	ldr.w	r8, [pc, #292]	; 2f94 <portable_init+0x134>
    am_bsp_pin_enable(COM_UART_RX);
    2e70:	4f41      	ldr	r7, [pc, #260]	; (2f78 <portable_init+0x118>)
        ee_printf("ERROR! Please define ee_ptr_int to a type that holds a pointer!\n");
    }
    if (sizeof(ee_u32) != 4) {
        ee_printf("ERROR! Please define ee_u32 to a 32b unsigned type!\n");
    }
    p->portable_id=1;
    2e72:	f04f 0901 	mov.w	r9, #1
    2e76:	2100      	movs	r1, #0
    2e78:	f880 9000 	strb.w	r9, [r0]
    2e7c:	f44f 6280 	mov.w	r2, #1024	; 0x400
    2e80:	4650      	mov	r0, sl
    for(i = 0; i < PRTBUFSIZE; i++)
    {
        am_prtbuf[i] = 0x00;
    }
    am_pcBuf = am_prtbuf;
    am_bufcnt = 0;
    2e82:	2400      	movs	r4, #0
    2e84:	f002 fa0a 	bl	529c <memset>
    am_pcBuf = am_prtbuf;
    2e88:	4a3c      	ldr	r2, [pc, #240]	; (2f7c <portable_init+0x11c>)
    am_bufcnt = 0;
    2e8a:	4b3d      	ldr	r3, [pc, #244]	; (2f80 <portable_init+0x120>)
    am_pcBuf = am_prtbuf;
    2e8c:	f8c2 a000 	str.w	sl, [r2]
#endif // AM_PRINT_RESULTS

    //
    // Set the system clock to maximum frequency.
    //
    am_hal_clkgen_sysclk_select(AM_HAL_CLKGEN_SYSCLK_MAX);
    2e90:	4620      	mov	r0, r4
    am_bufcnt = 0;
    2e92:	601c      	str	r4, [r3, #0]
    am_hal_clkgen_sysclk_select(AM_HAL_CLKGEN_SYSCLK_MAX);
    2e94:	f002 f8a4 	bl	4fe0 <am_hal_clkgen_sysclk_select>
#ifndef NOFPU
    //
    // Enable the floating point module, and configure the core for lazy
    // stacking.
    //
    am_hal_sysctrl_fpu_enable();
    2e98:	f002 f934 	bl	5104 <am_hal_sysctrl_fpu_enable>
    am_hal_sysctrl_fpu_stacking_enable(true);
    2e9c:	4648      	mov	r0, r9
    2e9e:	f002 f939 	bl	5114 <am_hal_sysctrl_fpu_stacking_enable>
#endif

    //
    // Configure the board for low power.
    //
    am_bsp_low_power_init();
    2ea2:	f002 f887 	bl	4fb4 <am_bsp_low_power_init>

#ifdef AM_PART_APOLLO
    //
    // SRAM bank power setting.
    //
    am_hal_mcuctrl_sram_power_set(AM_HAL_MCUCTRL_SRAM_POWER_DOWN_1 |
    2ea6:	21fe      	movs	r1, #254	; 0xfe
    2ea8:	4608      	mov	r0, r1
    2eaa:	f002 f8ed 	bl	5088 <am_hal_mcuctrl_sram_power_set>
                                  AM_HAL_MCUCTRL_SRAM_POWER_DOWN_7);

    //
    // Flash bank power set.
    //
    am_hal_mcuctrl_flash_power_set(AM_HAL_MCUCTRL_FLASH_POWER_DOWN_1);
    2eae:	2002      	movs	r0, #2
    2eb0:	f002 f8e4 	bl	507c <am_hal_mcuctrl_flash_power_set>
    am_bsp_pin_enable(COM_UART_TX);
    2eb4:	f04f 0a73 	mov.w	sl, #115	; 0x73

#if !AM_PRINT_SKIP_BANNER
    //
    // Initialize the printf interface for UART output.
    //
    am_util_stdio_printf_init((am_util_stdio_print_char_t)am_bsp_uart_string_print);
    2eb8:	4832      	ldr	r0, [pc, #200]	; (2f84 <portable_init+0x124>)
    2eba:	f000 ff51 	bl	3d60 <am_util_stdio_printf_init>
    am_bsp_pin_enable(COM_UART_TX);
    2ebe:	f8c5 a000 	str.w	sl, [r5]
    2ec2:	6830      	ldr	r0, [r6, #0]
    2ec4:	f420 41e0 	bic.w	r1, r0, #28672	; 0x7000
    2ec8:	6031      	str	r1, [r6, #0]
    2eca:	f8d8 2000 	ldr.w	r2, [r8]
    2ece:	f022 4c7f 	bic.w	ip, r2, #4278190080	; 0xff000000
    2ed2:	f04c 5380 	orr.w	r3, ip, #268435456	; 0x10000000
    2ed6:	f8c8 3000 	str.w	r3, [r8]
    2eda:	602c      	str	r4, [r5, #0]
    am_bsp_pin_enable(COM_UART_RX);
    2edc:	f8c5 a000 	str.w	sl, [r5]
    2ee0:	6830      	ldr	r0, [r6, #0]
    2ee2:	f420 21e0 	bic.w	r1, r0, #458752	; 0x70000
    2ee6:	6031      	str	r1, [r6, #0]
    2ee8:	683a      	ldr	r2, [r7, #0]
    2eea:	f022 09ff 	bic.w	r9, r2, #255	; 0xff
    2eee:	f049 0312 	orr.w	r3, r9, #18
    2ef2:	603b      	str	r3, [r7, #0]
    am_hal_uart_clock_enable(ui32UartModule);
    2ef4:	4620      	mov	r0, r4
    am_bsp_pin_enable(COM_UART_RX);
    2ef6:	602c      	str	r4, [r5, #0]
    am_hal_uart_clock_enable(ui32UartModule);
    2ef8:	f002 f986 	bl	5208 <am_hal_uart_clock_enable>
    am_hal_uart_disable(ui32UartModule);
    2efc:	4620      	mov	r0, r4
    2efe:	f002 f979 	bl	51f4 <am_hal_uart_disable>
    am_hal_uart_config(ui32UartModule, &g_sUartConfig);
    2f02:	4620      	mov	r0, r4
    2f04:	4920      	ldr	r1, [pc, #128]	; (2f88 <portable_init+0x128>)
    2f06:	f002 f937 	bl	5178 <am_hal_uart_config>
    am_hal_uart_fifo_config(ui32UartModule, AM_HAL_UART_TX_FIFO_1_2 | AM_HAL_UART_RX_FIFO_1_2);
    2f0a:	2112      	movs	r1, #18
    2f0c:	4620      	mov	r0, r4
    2f0e:	f002 f99f 	bl	5250 <am_hal_uart_fifo_config>
    am_hal_uart_enable(ui32UartModule);
    2f12:	4620      	mov	r0, r4
    2f14:	f002 f964 	bl	51e0 <am_hal_uart_enable>
    uart_init(ui32UartModule);

    //
    // Clear the terminal and print the banner.
    //
    am_util_stdio_terminal_clear();
    2f18:	f002 f846 	bl	4fa8 <am_util_stdio_terminal_clear>
    am_util_stdio_printf("Ambiq Micro Coremark test...\n\n");
    2f1c:	481b      	ldr	r0, [pc, #108]	; (2f8c <portable_init+0x12c>)
    2f1e:	f002 f829 	bl	4f74 <am_util_stdio_printf>
    am_util_delay_ms(10);
    2f22:	200a      	movs	r0, #10
    2f24:	f000 fdaa 	bl	3a7c <am_util_delay_ms>
    am_hal_uart_disable(ui32UartModule);
    2f28:	4620      	mov	r0, r4
    2f2a:	f002 f963 	bl	51f4 <am_hal_uart_disable>
    am_hal_uart_clock_disable(ui32UartModule);
    2f2e:	4620      	mov	r0, r4
    2f30:	f002 f97e 	bl	5230 <am_hal_uart_clock_disable>
    am_bsp_pin_disable(COM_UART_TX);
    2f34:	f8c5 a000 	str.w	sl, [r5]
    2f38:	6830      	ldr	r0, [r6, #0]
    2f3a:	f420 41e0 	bic.w	r1, r0, #28672	; 0x7000
    2f3e:	6031      	str	r1, [r6, #0]
    2f40:	f8d8 2000 	ldr.w	r2, [r8]
    2f44:	f022 4c7f 	bic.w	ip, r2, #4278190080	; 0xff000000
    2f48:	f04c 53c0 	orr.w	r3, ip, #402653184	; 0x18000000
    2f4c:	f8c8 3000 	str.w	r3, [r8]
    2f50:	602c      	str	r4, [r5, #0]
    am_bsp_pin_disable(COM_UART_RX);
    2f52:	f8c5 a000 	str.w	sl, [r5]
    2f56:	6830      	ldr	r0, [r6, #0]
    2f58:	f420 21e0 	bic.w	r1, r0, #458752	; 0x70000
    2f5c:	6031      	str	r1, [r6, #0]
    2f5e:	683e      	ldr	r6, [r7, #0]
    2f60:	f026 02ff 	bic.w	r2, r6, #255	; 0xff
    2f64:	f042 0318 	orr.w	r3, r2, #24
    2f68:	603b      	str	r3, [r7, #0]
    2f6a:	602c      	str	r4, [r5, #0]
    2f6c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2f70:	40010060 	.word	0x40010060
    2f74:	40010050 	.word	0x40010050
    2f78:	40010024 	.word	0x40010024
    2f7c:	10001568 	.word	0x10001568
    2f80:	1000104c 	.word	0x1000104c
    2f84:	00004fd9 	.word	0x00004fd9
    2f88:	10001004 	.word	0x10001004
    2f8c:	00005744 	.word	0x00005744
    2f90:	10001168 	.word	0x10001168
    2f94:	40010020 	.word	0x40010020

00002f98 <portable_fini>:

/* Function : portable_fini
    Target specific final code
*/
void portable_fini(core_portable *p)
{
    2f98:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    p->portable_id=0;
    2f9a:	2500      	movs	r5, #0
    2f9c:	7005      	strb	r5, [r0, #0]
    uint32_t ui32UartModule = AM_BSP_UART_PRINT_INST;

    //
    // Initialize the printf interface for UART output.
    //
    am_util_stdio_printf_init((am_util_stdio_print_char_t)am_bsp_uart_string_print);
    2f9e:	4840      	ldr	r0, [pc, #256]	; (30a0 <portable_fini+0x108>)
    am_bsp_pin_enable(COM_UART_TX);
    2fa0:	4e40      	ldr	r6, [pc, #256]	; (30a4 <portable_fini+0x10c>)
    am_util_stdio_printf_init((am_util_stdio_print_char_t)am_bsp_uart_string_print);
    2fa2:	f000 fedd 	bl	3d60 <am_util_stdio_printf_init>
    am_bsp_pin_enable(COM_UART_TX);
    2fa6:	4a40      	ldr	r2, [pc, #256]	; (30a8 <portable_fini+0x110>)
    2fa8:	4940      	ldr	r1, [pc, #256]	; (30ac <portable_fini+0x114>)
    am_bsp_pin_enable(COM_UART_RX);
    2faa:	4841      	ldr	r0, [pc, #260]	; (30b0 <portable_fini+0x118>)
    am_bsp_pin_enable(COM_UART_TX);
    2fac:	2473      	movs	r4, #115	; 0x73
    2fae:	6014      	str	r4, [r2, #0]
    2fb0:	680b      	ldr	r3, [r1, #0]
    2fb2:	f423 47e0 	bic.w	r7, r3, #28672	; 0x7000
    2fb6:	600f      	str	r7, [r1, #0]
    2fb8:	6833      	ldr	r3, [r6, #0]
    2fba:	f023 477f 	bic.w	r7, r3, #4278190080	; 0xff000000
    2fbe:	f047 5380 	orr.w	r3, r7, #268435456	; 0x10000000
    2fc2:	6033      	str	r3, [r6, #0]
    2fc4:	6015      	str	r5, [r2, #0]
    am_bsp_pin_enable(COM_UART_RX);
    2fc6:	6014      	str	r4, [r2, #0]
    2fc8:	680e      	ldr	r6, [r1, #0]
    2fca:	f426 24e0 	bic.w	r4, r6, #458752	; 0x70000
    2fce:	600c      	str	r4, [r1, #0]
    2fd0:	6801      	ldr	r1, [r0, #0]
    //
    // Now, let's go parse the buffer and print it out!
    //
    pcBuf = am_prtbuf;
    iCnt = 0;
    while ( (*pcBuf != 0x00)  &&  (iCnt<PRTBUFSIZE) )
    2fd2:	4c38      	ldr	r4, [pc, #224]	; (30b4 <portable_fini+0x11c>)
    am_bsp_pin_enable(COM_UART_RX);
    2fd4:	f021 07ff 	bic.w	r7, r1, #255	; 0xff
    2fd8:	f047 0312 	orr.w	r3, r7, #18
    2fdc:	6003      	str	r3, [r0, #0]
    2fde:	6015      	str	r5, [r2, #0]
    am_hal_uart_clock_enable(ui32UartModule);
    2fe0:	4628      	mov	r0, r5
    2fe2:	f002 f911 	bl	5208 <am_hal_uart_clock_enable>
    am_hal_uart_disable(ui32UartModule);
    2fe6:	4628      	mov	r0, r5
    2fe8:	f002 f904 	bl	51f4 <am_hal_uart_disable>
    am_hal_uart_config(ui32UartModule, &g_sUartConfig);
    2fec:	4628      	mov	r0, r5
    2fee:	4932      	ldr	r1, [pc, #200]	; (30b8 <portable_fini+0x120>)
    2ff0:	f002 f8c2 	bl	5178 <am_hal_uart_config>
    am_hal_uart_fifo_config(ui32UartModule, AM_HAL_UART_TX_FIFO_1_2 | AM_HAL_UART_RX_FIFO_1_2);
    2ff4:	2112      	movs	r1, #18
    2ff6:	4628      	mov	r0, r5
    2ff8:	f002 f92a 	bl	5250 <am_hal_uart_fifo_config>
    am_hal_uart_enable(ui32UartModule);
    2ffc:	4628      	mov	r0, r5
    2ffe:	f002 f8ef 	bl	51e0 <am_hal_uart_enable>
    am_util_stdio_terminal_clear();
    3002:	f001 ffd1 	bl	4fa8 <am_util_stdio_terminal_clear>
    am_util_stdio_printf("\nAmbiq Micro Coremark run finished!\n\n");
    3006:	482d      	ldr	r0, [pc, #180]	; (30bc <portable_fini+0x124>)
    3008:	f001 ffb4 	bl	4f74 <am_util_stdio_printf>
    while ( (*pcBuf != 0x00)  &&  (iCnt<PRTBUFSIZE) )
    300c:	7822      	ldrb	r2, [r4, #0]
    300e:	b1a2      	cbz	r2, 303a <portable_fini+0xa2>
    {
        am_util_stdio_printf(pcBuf);
    3010:	4620      	mov	r0, r4
    3012:	f001 ffaf 	bl	4f74 <am_util_stdio_printf>
        while ( *pcBuf != 0x00 )
    3016:	7820      	ldrb	r0, [r4, #0]
    3018:	2800      	cmp	r0, #0
    301a:	d03f      	beq.n	309c <portable_fini+0x104>
    301c:	1b2d      	subs	r5, r5, r4
    301e:	1c67      	adds	r7, r4, #1
    3020:	7839      	ldrb	r1, [r7, #0]
        {
            pcBuf++;
    3022:	463c      	mov	r4, r7
    3024:	19ee      	adds	r6, r5, r7
    3026:	3701      	adds	r7, #1
        while ( *pcBuf != 0x00 )
    3028:	2900      	cmp	r1, #0
    302a:	d1f9      	bne.n	3020 <portable_fini+0x88>
    while ( (*pcBuf != 0x00)  &&  (iCnt<PRTBUFSIZE) )
    302c:	7863      	ldrb	r3, [r4, #1]
            iCnt++;
        }
        iCnt++;     // Account for the NULL terminator
    302e:	1c75      	adds	r5, r6, #1
        pcBuf++;    // Point after the NULL terminator to the next string
    3030:	3401      	adds	r4, #1
    while ( (*pcBuf != 0x00)  &&  (iCnt<PRTBUFSIZE) )
    3032:	b113      	cbz	r3, 303a <portable_fini+0xa2>
    3034:	f5b5 6f80 	cmp.w	r5, #1024	; 0x400
    3038:	dbea      	blt.n	3010 <portable_fini+0x78>
    am_util_delay_ms(10);
    303a:	200a      	movs	r0, #10
    303c:	f000 fd1e 	bl	3a7c <am_util_delay_ms>
    am_hal_uart_disable(ui32UartModule);
    3040:	2000      	movs	r0, #0
    3042:	f002 f8d7 	bl	51f4 <am_hal_uart_disable>
    am_hal_uart_clock_disable(ui32UartModule);
    3046:	2000      	movs	r0, #0
    3048:	f002 f8f2 	bl	5230 <am_hal_uart_clock_disable>
    am_bsp_pin_disable(COM_UART_TX);
    304c:	4a16      	ldr	r2, [pc, #88]	; (30a8 <portable_fini+0x110>)
    304e:	4917      	ldr	r1, [pc, #92]	; (30ac <portable_fini+0x114>)
    3050:	4f14      	ldr	r7, [pc, #80]	; (30a4 <portable_fini+0x10c>)
    am_bsp_pin_disable(COM_UART_RX);
    3052:	4d17      	ldr	r5, [pc, #92]	; (30b0 <portable_fini+0x118>)
#endif // AM_PRINT_RESULTS

    //
    // Enable the LEDs.
    //
    am_devices_led_array_init(am_bsp_psLEDs, AM_BSP_NUM_LEDS);
    3054:	481a      	ldr	r0, [pc, #104]	; (30c0 <portable_fini+0x128>)
    am_bsp_pin_disable(COM_UART_TX);
    3056:	2673      	movs	r6, #115	; 0x73
    3058:	6016      	str	r6, [r2, #0]
    305a:	680b      	ldr	r3, [r1, #0]
    305c:	f423 44e0 	bic.w	r4, r3, #28672	; 0x7000
    3060:	600c      	str	r4, [r1, #0]
    3062:	683b      	ldr	r3, [r7, #0]
    3064:	f023 447f 	bic.w	r4, r3, #4278190080	; 0xff000000
    3068:	f044 53c0 	orr.w	r3, r4, #402653184	; 0x18000000
    306c:	2400      	movs	r4, #0
    306e:	603b      	str	r3, [r7, #0]
    3070:	6014      	str	r4, [r2, #0]
    am_bsp_pin_disable(COM_UART_RX);
    3072:	6016      	str	r6, [r2, #0]
    3074:	680f      	ldr	r7, [r1, #0]
    3076:	f427 26e0 	bic.w	r6, r7, #458752	; 0x70000
    307a:	600e      	str	r6, [r1, #0]
    307c:	6829      	ldr	r1, [r5, #0]
    307e:	f021 0cff 	bic.w	ip, r1, #255	; 0xff
    3082:	f04c 0318 	orr.w	r3, ip, #24
    3086:	602b      	str	r3, [r5, #0]
    am_devices_led_array_init(am_bsp_psLEDs, AM_BSP_NUM_LEDS);
    3088:	2105      	movs	r1, #5
    am_bsp_pin_disable(COM_UART_RX);
    308a:	6014      	str	r4, [r2, #0]
    am_devices_led_array_init(am_bsp_psLEDs, AM_BSP_NUM_LEDS);
    308c:	f7fd fcba 	bl	a04 <am_devices_led_array_init>

    //
    // Turn on an LED.
    //
    am_devices_led_on(am_bsp_psLEDs, 0);
    3090:	4621      	mov	r1, r4
    3092:	480b      	ldr	r0, [pc, #44]	; (30c0 <portable_fini+0x128>)
    //
    // Re-enable flash and SRAM.
    //
    am_hal_pwrctrl_memory_enable(AM_HAL_PWRCTRL_MEMEN_ALL);
#endif // AM_PART_APOLLO2
}
    3094:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    am_devices_led_on(am_bsp_psLEDs, 0);
    3098:	f7fd bd68 	b.w	b6c <am_devices_led_on>
        while ( *pcBuf != 0x00 )
    309c:	462e      	mov	r6, r5
    309e:	e7c5      	b.n	302c <portable_fini+0x94>
    30a0:	00004fd9 	.word	0x00004fd9
    30a4:	40010020 	.word	0x40010020
    30a8:	40010060 	.word	0x40010060
    30ac:	40010050 	.word	0x40010050
    30b0:	40010024 	.word	0x40010024
    30b4:	10001168 	.word	0x10001168
    30b8:	10001004 	.word	0x10001004
    30bc:	0000571c 	.word	0x0000571c
    30c0:	10001020 	.word	0x10001020

000030c4 <am_sprintf>:

#if AM_PRINT_RESULTS
int am_sprintf(char *pcFmt, ...)
{
    30c4:	b40f      	push	{r0, r1, r2, r3}
    30c6:	b530      	push	{r4, r5, lr}
    uint32_t ui32NumChars;
    int iRet = 0;

    va_list pArgs;

    if ( am_bufcnt < PRTBUFSIZE )
    30c8:	4c1a      	ldr	r4, [pc, #104]	; (3134 <am_sprintf+0x70>)
    30ca:	6823      	ldr	r3, [r4, #0]
    30cc:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
{
    30d0:	b083      	sub	sp, #12
    if ( am_bufcnt < PRTBUFSIZE )
    30d2:	d305      	bcc.n	30e0 <am_sprintf+0x1c>
    int iRet = 0;
    30d4:	2000      	movs	r0, #0
        }
    } // if (am_bufcnt)

    return iRet;

} // am_sprintf()
    30d6:	b003      	add	sp, #12
    30d8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    30dc:	b004      	add	sp, #16
    30de:	4770      	bx	lr
        ui32NumChars = am_util_stdio_vsprintf(am_pcBuf, pcFmt, pArgs);
    30e0:	4d15      	ldr	r5, [pc, #84]	; (3138 <am_sprintf+0x74>)
    30e2:	9906      	ldr	r1, [sp, #24]
    30e4:	6828      	ldr	r0, [r5, #0]
        va_start(pArgs, pcFmt);
    30e6:	aa07      	add	r2, sp, #28
    30e8:	9201      	str	r2, [sp, #4]
        ui32NumChars = am_util_stdio_vsprintf(am_pcBuf, pcFmt, pArgs);
    30ea:	f000 fe3f 	bl	3d6c <am_util_stdio_vsprintf>
        if ( (am_bufcnt+ui32NumChars) >= PRTBUFSIZE )
    30ee:	6821      	ldr	r1, [r4, #0]
    30f0:	4401      	add	r1, r0
    30f2:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
    30f6:	d20e      	bcs.n	3116 <am_sprintf+0x52>
            am_bufcnt += ui32NumChars;
    30f8:	6822      	ldr	r2, [r4, #0]
            am_pcBuf++;                 // Skip NULL terminator
    30fa:	682b      	ldr	r3, [r5, #0]
            am_bufcnt += ui32NumChars;
    30fc:	4402      	add	r2, r0
    30fe:	6022      	str	r2, [r4, #0]
            am_bufcnt++;                // Include NULL terminator
    3100:	6822      	ldr	r2, [r4, #0]
            am_pcBuf++;                 // Skip NULL terminator
    3102:	1c41      	adds	r1, r0, #1
            am_bufcnt++;                // Include NULL terminator
    3104:	3201      	adds	r2, #1
            am_pcBuf++;                 // Skip NULL terminator
    3106:	440b      	add	r3, r1
            am_bufcnt++;                // Include NULL terminator
    3108:	6022      	str	r2, [r4, #0]
            am_pcBuf++;                 // Skip NULL terminator
    310a:	602b      	str	r3, [r5, #0]
} // am_sprintf()
    310c:	b003      	add	sp, #12
    310e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    3112:	b004      	add	sp, #16
    3114:	4770      	bx	lr
            am_util_stdio_sprintf(&am_prtbuf[PRTBUFSIZE-(40+1)], "BUFFER OVERFLOWED! Increase PRTBUFSIZE\n");
    3116:	4909      	ldr	r1, [pc, #36]	; (313c <am_sprintf+0x78>)
    3118:	4809      	ldr	r0, [pc, #36]	; (3140 <am_sprintf+0x7c>)
    311a:	f001 ff1d 	bl	4f58 <am_util_stdio_sprintf>
            am_prtbuf[PRTBUFSIZE-1] = 0x00;     // Double terminate the buffer
    311e:	4b09      	ldr	r3, [pc, #36]	; (3144 <am_sprintf+0x80>)
    3120:	2000      	movs	r0, #0
            am_pcBuf = &am_prtbuf[PRTBUFSIZE];  // Don't allow any further printing
    3122:	f503 6180 	add.w	r1, r3, #1024	; 0x400
            am_bufcnt = PRTBUFSIZE;             //  "
    3126:	f44f 6280 	mov.w	r2, #1024	; 0x400
            am_pcBuf = &am_prtbuf[PRTBUFSIZE];  // Don't allow any further printing
    312a:	6029      	str	r1, [r5, #0]
            am_prtbuf[PRTBUFSIZE-1] = 0x00;     // Double terminate the buffer
    312c:	f883 03ff 	strb.w	r0, [r3, #1023]	; 0x3ff
            am_bufcnt = PRTBUFSIZE;             //  "
    3130:	6022      	str	r2, [r4, #0]
    3132:	e7d0      	b.n	30d6 <am_sprintf+0x12>
    3134:	1000104c 	.word	0x1000104c
    3138:	10001568 	.word	0x10001568
    313c:	000056f4 	.word	0x000056f4
    3140:	1000153f 	.word	0x1000153f
    3144:	10001168 	.word	0x10001168

00003148 <core_init_state>:
    Actual patterns chosen depend on the seed parameter.

    Note:
    The seed parameter MUST be supplied from a source that cannot be determined at compile time
*/
void core_init_state(ee_u32 size, ee_s16 seed, ee_u8 *p) {
    3148:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ee_u8 *buf=0;
#if CORE_DEBUG
    ee_u8 *start=p;
    ee_printf("State: %d,%d\n",size,seed);
#endif
    size--;
    314c:	1e46      	subs	r6, r0, #1
    next=0;
    while ((total+next+1)<size) {
    314e:	2e01      	cmp	r6, #1
void core_init_state(ee_u32 size, ee_s16 seed, ee_u8 *p) {
    3150:	4684      	mov	ip, r0
    3152:	4615      	mov	r5, r2
    while ((total+next+1)<size) {
    3154:	d966      	bls.n	3224 <core_init_state+0xdc>
    3156:	1c4c      	adds	r4, r1, #1
            case 6: /* scientific */
                buf=scipat[(seed>>3) & 0x3];
                next=8;
            break;
            case 7: /* invalid */
                buf=errpat[(seed>>3) & 0x3];
    3158:	f8df 90d4 	ldr.w	r9, [pc, #212]	; 3230 <core_init_state+0xe8>
                buf=scipat[(seed>>3) & 0x3];
    315c:	f8df 80d4 	ldr.w	r8, [pc, #212]	; 3234 <core_init_state+0xec>
                buf=floatpat[(seed>>3) & 0x3];
    3160:	f8df e0d4 	ldr.w	lr, [pc, #212]	; 3238 <core_init_state+0xf0>
                buf=intpat[(seed>>3) & 0x3];
    3164:	4831      	ldr	r0, [pc, #196]	; (322c <core_init_state+0xe4>)
    3166:	b2a4      	uxth	r4, r4
    while ((total+next+1)<size) {
    3168:	2100      	movs	r1, #0
            *(p+total+i)=',';
    316a:	272c      	movs	r7, #44	; 0x2c
        switch (seed & 0x7) {
    316c:	f004 0307 	and.w	r3, r4, #7
    3170:	f1a3 0b03 	sub.w	fp, r3, #3
        seed++;
    3174:	b222      	sxth	r2, r4
                buf=errpat[(seed>>3) & 0x3];
    3176:	f3c2 03c1 	ubfx	r3, r2, #3, #2
        switch (seed & 0x7) {
    317a:	f1bb 0f04 	cmp.w	fp, #4
    317e:	d831      	bhi.n	31e4 <core_init_state+0x9c>
    3180:	e8df f00b 	tbb	[pc, fp]
    3184:	39390303 	.word	0x39390303
    3188:	49          	.byte	0x49
    3189:	00          	.byte	0x00
    while ((total+next+1)<size) {
    318a:	f101 0b09 	add.w	fp, r1, #9
    318e:	455e      	cmp	r6, fp
                buf=floatpat[(seed>>3) & 0x3];
    3190:	f85e 3023 	ldr.w	r3, [lr, r3, lsl #2]
    while ((total+next+1)<size) {
    3194:	d935      	bls.n	3202 <core_init_state+0xba>
                next=8;
    3196:	f04f 0a08 	mov.w	sl, #8
                *(p+total+i)=buf[i];
    319a:	781a      	ldrb	r2, [r3, #0]
    319c:	546a      	strb	r2, [r5, r1]
    319e:	186a      	adds	r2, r5, r1
    31a0:	7859      	ldrb	r1, [r3, #1]
    31a2:	7051      	strb	r1, [r2, #1]
    31a4:	7899      	ldrb	r1, [r3, #2]
    31a6:	7091      	strb	r1, [r2, #2]
    31a8:	78d9      	ldrb	r1, [r3, #3]
    31aa:	70d1      	strb	r1, [r2, #3]
            for(i=0;i<next;i++)
    31ac:	f1ba 0f04 	cmp.w	sl, #4
    31b0:	d012      	beq.n	31d8 <core_init_state+0x90>
                *(p+total+i)=buf[i];
    31b2:	7919      	ldrb	r1, [r3, #4]
    31b4:	7111      	strb	r1, [r2, #4]
            for(i=0;i<next;i++)
    31b6:	f1ba 0f05 	cmp.w	sl, #5
    31ba:	d00d      	beq.n	31d8 <core_init_state+0x90>
                *(p+total+i)=buf[i];
    31bc:	7959      	ldrb	r1, [r3, #5]
    31be:	7151      	strb	r1, [r2, #5]
            for(i=0;i<next;i++)
    31c0:	f1ba 0f06 	cmp.w	sl, #6
    31c4:	d008      	beq.n	31d8 <core_init_state+0x90>
                *(p+total+i)=buf[i];
    31c6:	7999      	ldrb	r1, [r3, #6]
    31c8:	7191      	strb	r1, [r2, #6]
            for(i=0;i<next;i++)
    31ca:	f1ba 0f08 	cmp.w	sl, #8
                *(p+total+i)=buf[i];
    31ce:	bf06      	itte	eq
    31d0:	79db      	ldrbeq	r3, [r3, #7]
    31d2:	71d3      	strbeq	r3, [r2, #7]
            for(i=0;i<next;i++)
    31d4:	f04f 0a07 	movne.w	sl, #7
    31d8:	3401      	adds	r4, #1
            *(p+total+i)=',';
    31da:	f802 700a 	strb.w	r7, [r2, sl]
    31de:	b2a4      	uxth	r4, r4
    31e0:	4659      	mov	r1, fp
    31e2:	e7c3      	b.n	316c <core_init_state+0x24>
    while ((total+next+1)<size) {
    31e4:	f101 0b05 	add.w	fp, r1, #5
    31e8:	455e      	cmp	r6, fp
                buf=intpat[(seed>>3) & 0x3];
    31ea:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    while ((total+next+1)<size) {
    31ee:	d908      	bls.n	3202 <core_init_state+0xba>
                next=4;
    31f0:	f04f 0a04 	mov.w	sl, #4
    31f4:	e7d1      	b.n	319a <core_init_state+0x52>
    while ((total+next+1)<size) {
    31f6:	f101 0b09 	add.w	fp, r1, #9
    31fa:	455e      	cmp	r6, fp
                buf=scipat[(seed>>3) & 0x3];
    31fc:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
    while ((total+next+1)<size) {
    3200:	d8c9      	bhi.n	3196 <core_init_state+0x4e>
            default: /* Never happen, just to make some compilers happy */
            break;
        }
    }
    size++;
    while (total<size) { /* fill the rest with 0 */
    3202:	4561      	cmp	r1, ip
    3204:	d210      	bcs.n	3228 <core_init_state+0xe0>
    3206:	1868      	adds	r0, r5, r1
    3208:	ebac 0201 	sub.w	r2, ip, r1
        total++;
    }
#if CORE_DEBUG
    ee_printf("State Input: %s\n",start);
#endif
}
    320c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3210:	2100      	movs	r1, #0
    3212:	f002 b843 	b.w	529c <memset>
    while ((total+next+1)<size) {
    3216:	f101 0b09 	add.w	fp, r1, #9
    321a:	455e      	cmp	r6, fp
                buf=errpat[(seed>>3) & 0x3];
    321c:	f859 3023 	ldr.w	r3, [r9, r3, lsl #2]
    while ((total+next+1)<size) {
    3220:	d8b9      	bhi.n	3196 <core_init_state+0x4e>
    3222:	e7ee      	b.n	3202 <core_init_state+0xba>
    ee_u32 total=0,next=0,i;
    3224:	2100      	movs	r1, #0
    3226:	e7ee      	b.n	3206 <core_init_state+0xbe>
    3228:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    322c:	00005784 	.word	0x00005784
    3230:	00005764 	.word	0x00005764
    3234:	00005794 	.word	0x00005794
    3238:	00005774 	.word	0x00005774

0000323c <core_state_transition>:

    The input pointer is updated to point to the end of the token, and the end state is returned (either specific format determined or invalid).
*/

enum CORE_STATE core_state_transition( ee_u8 **instr , ee_u32 *transition_count) {
    ee_u8 *str=*instr;
    323c:	6803      	ldr	r3, [r0, #0]
    ee_u8 NEXT_SYMBOL;
    enum CORE_STATE state=CORE_START;
    for( ; *str && state != CORE_INVALID; str++ ) {
    323e:	781a      	ldrb	r2, [r3, #0]
    3240:	b392      	cbz	r2, 32a8 <core_state_transition+0x6c>
        NEXT_SYMBOL = *str;
        if (NEXT_SYMBOL==',') /* end of this input */ {
    3242:	2a2c      	cmp	r2, #44	; 0x2c
    3244:	d02e      	beq.n	32a4 <core_state_transition+0x68>
enum CORE_STATE core_state_transition( ee_u8 **instr , ee_u32 *transition_count) {
    3246:	b410      	push	{r4}
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    3248:	f1a2 0430 	sub.w	r4, r2, #48	; 0x30
    324c:	2c09      	cmp	r4, #9
    324e:	d90f      	bls.n	3270 <core_state_transition+0x34>
        switch(state) {
        case CORE_START:
            if(ee_isdigit(NEXT_SYMBOL)) {
                state = CORE_INT;
            }
            else if( NEXT_SYMBOL == '+' || NEXT_SYMBOL == '-' ) {
    3250:	2a2b      	cmp	r2, #43	; 0x2b
    3252:	d02c      	beq.n	32ae <core_state_transition+0x72>
    3254:	2a2d      	cmp	r2, #45	; 0x2d
    3256:	d02a      	beq.n	32ae <core_state_transition+0x72>
                state = CORE_S1;
            }
            else if( NEXT_SYMBOL == '.' ) {
    3258:	2a2e      	cmp	r2, #46	; 0x2e
    325a:	f000 80b1 	beq.w	33c0 <core_state_transition+0x184>
            }
            else {
                state = CORE_INVALID;
                transition_count[CORE_INVALID]++;
            }
            transition_count[CORE_START]++;
    325e:	e891 0014 	ldmia.w	r1, {r2, r4}
                transition_count[CORE_INVALID]++;
    3262:	3401      	adds	r4, #1
            transition_count[CORE_START]++;
    3264:	3201      	adds	r2, #1
    3266:	e881 0014 	stmia.w	r1, {r2, r4}
    for( ; *str && state != CORE_INVALID; str++ ) {
    326a:	3301      	adds	r3, #1
                state = CORE_INVALID;
    326c:	2101      	movs	r1, #1
    326e:	e014      	b.n	329a <core_state_transition+0x5e>
            transition_count[CORE_START]++;
    3270:	680c      	ldr	r4, [r1, #0]
    3272:	3401      	adds	r4, #1
    3274:	600c      	str	r4, [r1, #0]
    for( ; *str && state != CORE_INVALID; str++ ) {
    3276:	785a      	ldrb	r2, [r3, #1]
    3278:	3301      	adds	r3, #1
    327a:	b372      	cbz	r2, 32da <core_state_transition+0x9e>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    327c:	2a2c      	cmp	r2, #44	; 0x2c
    327e:	f000 8092 	beq.w	33a6 <core_state_transition+0x16a>
                state = CORE_INVALID;
                transition_count[CORE_S1]++;
            }
            break;
        case CORE_INT:
            if( NEXT_SYMBOL == '.' ) {
    3282:	2a2e      	cmp	r2, #46	; 0x2e
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    3284:	f1a2 0430 	sub.w	r4, r2, #48	; 0x30
            if( NEXT_SYMBOL == '.' ) {
    3288:	d031      	beq.n	32ee <core_state_transition+0xb2>
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    328a:	2c09      	cmp	r4, #9
    328c:	f240 80a0 	bls.w	33d0 <core_state_transition+0x194>
                state = CORE_FLOAT;
                transition_count[CORE_INT]++;
            }
            else if(!ee_isdigit(NEXT_SYMBOL)) {
                state = CORE_INVALID;
                transition_count[CORE_INT]++;
    3290:	690a      	ldr	r2, [r1, #16]
    3292:	3201      	adds	r2, #1
    3294:	610a      	str	r2, [r1, #16]
    for( ; *str && state != CORE_INVALID; str++ ) {
    3296:	3301      	adds	r3, #1
                state = CORE_INVALID;
    3298:	2101      	movs	r1, #1
            break;
        default:
            break;
        }
    }
    *instr=str;
    329a:	6003      	str	r3, [r0, #0]
    return state;
}
    329c:	f85d 4b04 	ldr.w	r4, [sp], #4
    32a0:	4608      	mov	r0, r1
    32a2:	4770      	bx	lr
        if (NEXT_SYMBOL==',') /* end of this input */ {
    32a4:	2200      	movs	r2, #0
            str++;
    32a6:	3301      	adds	r3, #1
    *instr=str;
    32a8:	6003      	str	r3, [r0, #0]
}
    32aa:	4610      	mov	r0, r2
    32ac:	4770      	bx	lr
            transition_count[CORE_START]++;
    32ae:	680c      	ldr	r4, [r1, #0]
    32b0:	3401      	adds	r4, #1
    32b2:	600c      	str	r4, [r1, #0]
    for( ; *str && state != CORE_INVALID; str++ ) {
    32b4:	785a      	ldrb	r2, [r3, #1]
    32b6:	3301      	adds	r3, #1
    32b8:	2a00      	cmp	r2, #0
    32ba:	f000 809c 	beq.w	33f6 <core_state_transition+0x1ba>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    32be:	2a2c      	cmp	r2, #44	; 0x2c
    32c0:	f000 809b 	beq.w	33fa <core_state_transition+0x1be>
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    32c4:	f1a2 0430 	sub.w	r4, r2, #48	; 0x30
    32c8:	2c09      	cmp	r4, #9
    32ca:	d808      	bhi.n	32de <core_state_transition+0xa2>
                transition_count[CORE_S1]++;
    32cc:	688a      	ldr	r2, [r1, #8]
    32ce:	3201      	adds	r2, #1
    32d0:	608a      	str	r2, [r1, #8]
    for( ; *str && state != CORE_INVALID; str++ ) {
    32d2:	785a      	ldrb	r2, [r3, #1]
    32d4:	3301      	adds	r3, #1
    32d6:	2a00      	cmp	r2, #0
    32d8:	d1d0      	bne.n	327c <core_state_transition+0x40>
                state = CORE_INT;
    32da:	2104      	movs	r1, #4
    32dc:	e7dd      	b.n	329a <core_state_transition+0x5e>
            else if( NEXT_SYMBOL == '.' ) {
    32de:	2a2e      	cmp	r2, #46	; 0x2e
    32e0:	d064      	beq.n	33ac <core_state_transition+0x170>
                transition_count[CORE_S1]++;
    32e2:	688a      	ldr	r2, [r1, #8]
    32e4:	3201      	adds	r2, #1
    32e6:	608a      	str	r2, [r1, #8]
    for( ; *str && state != CORE_INVALID; str++ ) {
    32e8:	3301      	adds	r3, #1
                state = CORE_INVALID;
    32ea:	2101      	movs	r1, #1
    32ec:	e7d5      	b.n	329a <core_state_transition+0x5e>
                transition_count[CORE_INT]++;
    32ee:	690c      	ldr	r4, [r1, #16]
    32f0:	3401      	adds	r4, #1
    32f2:	610c      	str	r4, [r1, #16]
    for( ; *str && state != CORE_INVALID; str++ ) {
    32f4:	785a      	ldrb	r2, [r3, #1]
    32f6:	1c5c      	adds	r4, r3, #1
    32f8:	2a00      	cmp	r2, #0
    32fa:	d05e      	beq.n	33ba <core_state_transition+0x17e>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    32fc:	2a2c      	cmp	r2, #44	; 0x2c
    32fe:	d075      	beq.n	33ec <core_state_transition+0x1b0>
            if( NEXT_SYMBOL == 'E' || NEXT_SYMBOL == 'e' ) {
    3300:	f002 03df 	and.w	r3, r2, #223	; 0xdf
    3304:	2b45      	cmp	r3, #69	; 0x45
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    3306:	f1a2 0230 	sub.w	r2, r2, #48	; 0x30
            if( NEXT_SYMBOL == 'E' || NEXT_SYMBOL == 'e' ) {
    330a:	d009      	beq.n	3320 <core_state_transition+0xe4>
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    330c:	2a09      	cmp	r2, #9
    330e:	d844      	bhi.n	339a <core_state_transition+0x15e>
    for( ; *str && state != CORE_INVALID; str++ ) {
    3310:	7862      	ldrb	r2, [r4, #1]
    3312:	1c63      	adds	r3, r4, #1
    3314:	2a00      	cmp	r2, #0
    3316:	d072      	beq.n	33fe <core_state_transition+0x1c2>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    3318:	2a2c      	cmp	r2, #44	; 0x2c
    331a:	d068      	beq.n	33ee <core_state_transition+0x1b2>
    331c:	461c      	mov	r4, r3
    331e:	e7ef      	b.n	3300 <core_state_transition+0xc4>
                transition_count[CORE_FLOAT]++;
    3320:	694b      	ldr	r3, [r1, #20]
    3322:	3301      	adds	r3, #1
    3324:	614b      	str	r3, [r1, #20]
    for( ; *str && state != CORE_INVALID; str++ ) {
    3326:	7862      	ldrb	r2, [r4, #1]
    3328:	1c63      	adds	r3, r4, #1
    332a:	2a00      	cmp	r2, #0
    332c:	d05a      	beq.n	33e4 <core_state_transition+0x1a8>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    332e:	2a2c      	cmp	r2, #44	; 0x2c
    3330:	d05a      	beq.n	33e8 <core_state_transition+0x1ac>
            if( NEXT_SYMBOL == '+' || NEXT_SYMBOL == '-' ) {
    3332:	2a2b      	cmp	r2, #43	; 0x2b
                transition_count[CORE_S2]++;
    3334:	68cb      	ldr	r3, [r1, #12]
            if( NEXT_SYMBOL == '+' || NEXT_SYMBOL == '-' ) {
    3336:	d006      	beq.n	3346 <core_state_transition+0x10a>
    3338:	2a2d      	cmp	r2, #45	; 0x2d
    333a:	d004      	beq.n	3346 <core_state_transition+0x10a>
                transition_count[CORE_S2]++;
    333c:	1c5a      	adds	r2, r3, #1
    333e:	60ca      	str	r2, [r1, #12]
    for( ; *str && state != CORE_INVALID; str++ ) {
    3340:	1ca3      	adds	r3, r4, #2
                state = CORE_INVALID;
    3342:	2101      	movs	r1, #1
    3344:	e7a9      	b.n	329a <core_state_transition+0x5e>
                transition_count[CORE_S2]++;
    3346:	3301      	adds	r3, #1
    3348:	60cb      	str	r3, [r1, #12]
    for( ; *str && state != CORE_INVALID; str++ ) {
    334a:	78a2      	ldrb	r2, [r4, #2]
    334c:	1ca3      	adds	r3, r4, #2
    334e:	2a00      	cmp	r2, #0
    3350:	d046      	beq.n	33e0 <core_state_transition+0x1a4>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    3352:	2a2c      	cmp	r2, #44	; 0x2c
    3354:	d04d      	beq.n	33f2 <core_state_transition+0x1b6>
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    3356:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
    335a:	2b09      	cmp	r3, #9
    335c:	d811      	bhi.n	3382 <core_state_transition+0x146>
                transition_count[CORE_EXPONENT]++;
    335e:	698b      	ldr	r3, [r1, #24]
    3360:	3301      	adds	r3, #1
    3362:	618b      	str	r3, [r1, #24]
    for( ; *str && state != CORE_INVALID; str++ ) {
    3364:	78e2      	ldrb	r2, [r4, #3]
    3366:	1ce3      	adds	r3, r4, #3
    3368:	b14a      	cbz	r2, 337e <core_state_transition+0x142>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    336a:	2a2c      	cmp	r2, #44	; 0x2c
    336c:	d036      	beq.n	33dc <core_state_transition+0x1a0>
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    336e:	f1a2 0430 	sub.w	r4, r2, #48	; 0x30
    3372:	2c09      	cmp	r4, #9
    3374:	d80b      	bhi.n	338e <core_state_transition+0x152>
    for( ; *str && state != CORE_INVALID; str++ ) {
    3376:	f813 2f01 	ldrb.w	r2, [r3, #1]!
    337a:	2a00      	cmp	r2, #0
    337c:	d1f5      	bne.n	336a <core_state_transition+0x12e>
                state = CORE_SCIENTIFIC;
    337e:	2107      	movs	r1, #7
    3380:	e78b      	b.n	329a <core_state_transition+0x5e>
                transition_count[CORE_EXPONENT]++;
    3382:	698a      	ldr	r2, [r1, #24]
    3384:	3201      	adds	r2, #1
    3386:	618a      	str	r2, [r1, #24]
    for( ; *str && state != CORE_INVALID; str++ ) {
    3388:	1ce3      	adds	r3, r4, #3
                state = CORE_INVALID;
    338a:	2101      	movs	r1, #1
    338c:	e785      	b.n	329a <core_state_transition+0x5e>
                transition_count[CORE_INVALID]++;
    338e:	684a      	ldr	r2, [r1, #4]
    3390:	3201      	adds	r2, #1
    3392:	604a      	str	r2, [r1, #4]
    for( ; *str && state != CORE_INVALID; str++ ) {
    3394:	3301      	adds	r3, #1
                state = CORE_INVALID;
    3396:	2101      	movs	r1, #1
    3398:	e77f      	b.n	329a <core_state_transition+0x5e>
                transition_count[CORE_FLOAT]++;
    339a:	694b      	ldr	r3, [r1, #20]
    339c:	1c5a      	adds	r2, r3, #1
    339e:	614a      	str	r2, [r1, #20]
    for( ; *str && state != CORE_INVALID; str++ ) {
    33a0:	1c63      	adds	r3, r4, #1
                state = CORE_INVALID;
    33a2:	2101      	movs	r1, #1
    33a4:	e779      	b.n	329a <core_state_transition+0x5e>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    33a6:	2104      	movs	r1, #4
            str++;
    33a8:	3301      	adds	r3, #1
            break;
    33aa:	e776      	b.n	329a <core_state_transition+0x5e>
                transition_count[CORE_S1]++;
    33ac:	688c      	ldr	r4, [r1, #8]
    33ae:	3401      	adds	r4, #1
    33b0:	608c      	str	r4, [r1, #8]
    for( ; *str && state != CORE_INVALID; str++ ) {
    33b2:	785a      	ldrb	r2, [r3, #1]
    33b4:	1c5c      	adds	r4, r3, #1
    33b6:	2a00      	cmp	r2, #0
    33b8:	d1a0      	bne.n	32fc <core_state_transition+0xc0>
    33ba:	4623      	mov	r3, r4
                state = CORE_FLOAT;
    33bc:	2105      	movs	r1, #5
    33be:	e76c      	b.n	329a <core_state_transition+0x5e>
            transition_count[CORE_START]++;
    33c0:	680a      	ldr	r2, [r1, #0]
    33c2:	3201      	adds	r2, #1
    33c4:	600a      	str	r2, [r1, #0]
    for( ; *str && state != CORE_INVALID; str++ ) {
    33c6:	785a      	ldrb	r2, [r3, #1]
    33c8:	1c5c      	adds	r4, r3, #1
    33ca:	2a00      	cmp	r2, #0
    33cc:	d196      	bne.n	32fc <core_state_transition+0xc0>
    33ce:	e7f4      	b.n	33ba <core_state_transition+0x17e>
    33d0:	f813 2f01 	ldrb.w	r2, [r3, #1]!
    33d4:	2a00      	cmp	r2, #0
    33d6:	f47f af51 	bne.w	327c <core_state_transition+0x40>
    33da:	e77e      	b.n	32da <core_state_transition+0x9e>
                state = CORE_SCIENTIFIC;
    33dc:	2107      	movs	r1, #7
    33de:	e7e3      	b.n	33a8 <core_state_transition+0x16c>
                state = CORE_EXPONENT;
    33e0:	2106      	movs	r1, #6
    33e2:	e75a      	b.n	329a <core_state_transition+0x5e>
                state = CORE_S2;
    33e4:	2103      	movs	r1, #3
    33e6:	e758      	b.n	329a <core_state_transition+0x5e>
    33e8:	2103      	movs	r1, #3
    33ea:	e7dd      	b.n	33a8 <core_state_transition+0x16c>
    for( ; *str && state != CORE_INVALID; str++ ) {
    33ec:	4623      	mov	r3, r4
                state = CORE_FLOAT;
    33ee:	2105      	movs	r1, #5
    33f0:	e7da      	b.n	33a8 <core_state_transition+0x16c>
                state = CORE_EXPONENT;
    33f2:	2106      	movs	r1, #6
    33f4:	e7d8      	b.n	33a8 <core_state_transition+0x16c>
                state = CORE_S1;
    33f6:	2102      	movs	r1, #2
    33f8:	e74f      	b.n	329a <core_state_transition+0x5e>
    33fa:	2102      	movs	r1, #2
    33fc:	e7d4      	b.n	33a8 <core_state_transition+0x16c>
    for( ; *str && state != CORE_INVALID; str++ ) {
    33fe:	2105      	movs	r1, #5
    3400:	e74b      	b.n	329a <core_state_transition+0x5e>
    3402:	bf00      	nop

00003404 <core_bench_state>:
{
    3404:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    3408:	b092      	sub	sp, #72	; 0x48
    340a:	460c      	mov	r4, r1
    340c:	4682      	mov	sl, r0
    340e:	2100      	movs	r1, #0
    3410:	4691      	mov	r9, r2
    3412:	a80a      	add	r0, sp, #40	; 0x28
    3414:	2220      	movs	r2, #32
    3416:	4698      	mov	r8, r3
    ee_u8 *p=memblock;
    3418:	9401      	str	r4, [sp, #4]
{
    341a:	f9bd 6068 	ldrsh.w	r6, [sp, #104]	; 0x68
    341e:	f8bd 706c 	ldrh.w	r7, [sp, #108]	; 0x6c
    3422:	f001 ff3b 	bl	529c <memset>
    3426:	2220      	movs	r2, #32
    3428:	2100      	movs	r1, #0
    342a:	a802      	add	r0, sp, #8
    342c:	f001 ff36 	bl	529c <memset>
    while (*p!=0) {
    3430:	7822      	ldrb	r2, [r4, #0]
    3432:	2a00      	cmp	r2, #0
    3434:	d05a      	beq.n	34ec <core_bench_state+0xe8>
    3436:	ad01      	add	r5, sp, #4
        enum CORE_STATE fstate=core_state_transition(&p,track_counts);
    3438:	a90a      	add	r1, sp, #40	; 0x28
    343a:	4628      	mov	r0, r5
    343c:	f7ff fefe 	bl	323c <core_state_transition>
        final_counts[fstate]++;
    3440:	ab12      	add	r3, sp, #72	; 0x48
    3442:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    while (*p!=0) {
    3446:	9901      	ldr	r1, [sp, #4]
        final_counts[fstate]++;
    3448:	f850 3c40 	ldr.w	r3, [r0, #-64]
    while (*p!=0) {
    344c:	780a      	ldrb	r2, [r1, #0]
        final_counts[fstate]++;
    344e:	3301      	adds	r3, #1
    3450:	f840 3c40 	str.w	r3, [r0, #-64]
    while (*p!=0) {
    3454:	2a00      	cmp	r2, #0
    3456:	d1ef      	bne.n	3438 <core_bench_state+0x34>
    while (p < (memblock+blksize)) { /* insert some corruption */
    3458:	44a2      	add	sl, r4
    345a:	4554      	cmp	r4, sl
    p=memblock;
    345c:	9401      	str	r4, [sp, #4]
    345e:	7822      	ldrb	r2, [r4, #0]
    while (p < (memblock+blksize)) { /* insert some corruption */
    3460:	d241      	bcs.n	34e6 <core_bench_state+0xe2>
{
    3462:	4620      	mov	r0, r4
    3464:	e000      	b.n	3468 <core_bench_state+0x64>
    3466:	7802      	ldrb	r2, [r0, #0]
        if (*p!=',')
    3468:	2a2c      	cmp	r2, #44	; 0x2c
            *p^=(ee_u8)seed1;
    346a:	ea82 0109 	eor.w	r1, r2, r9
    346e:	bf1c      	itt	ne
    3470:	7001      	strbne	r1, [r0, #0]
    3472:	9801      	ldrne	r0, [sp, #4]
        p+=step;
    3474:	4430      	add	r0, r6
    while (p < (memblock+blksize)) { /* insert some corruption */
    3476:	4550      	cmp	r0, sl
        p+=step;
    3478:	9001      	str	r0, [sp, #4]
    while (p < (memblock+blksize)) { /* insert some corruption */
    347a:	d3f4      	bcc.n	3466 <core_bench_state+0x62>
    while (*p!=0) {
    347c:	7823      	ldrb	r3, [r4, #0]
    p=memblock;
    347e:	9401      	str	r4, [sp, #4]
    while (*p!=0) {
    3480:	2b00      	cmp	r3, #0
    3482:	d039      	beq.n	34f8 <core_bench_state+0xf4>
        enum CORE_STATE fstate=core_state_transition(&p,track_counts);
    3484:	a90a      	add	r1, sp, #40	; 0x28
    3486:	4628      	mov	r0, r5
    3488:	f7ff fed8 	bl	323c <core_state_transition>
        final_counts[fstate]++;
    348c:	f10d 0c48 	add.w	ip, sp, #72	; 0x48
    3490:	eb0c 0980 	add.w	r9, ip, r0, lsl #2
    while (*p!=0) {
    3494:	9a01      	ldr	r2, [sp, #4]
        final_counts[fstate]++;
    3496:	f859 0c40 	ldr.w	r0, [r9, #-64]
    while (*p!=0) {
    349a:	7811      	ldrb	r1, [r2, #0]
        final_counts[fstate]++;
    349c:	3001      	adds	r0, #1
    349e:	f849 0c40 	str.w	r0, [r9, #-64]
    while (*p!=0) {
    34a2:	2900      	cmp	r1, #0
    34a4:	d1ee      	bne.n	3484 <core_bench_state+0x80>
    while (p < (memblock+blksize)) { /* undo corruption is seed1 and seed2 are equal */
    34a6:	4554      	cmp	r4, sl
        p+=step;
    34a8:	9401      	str	r4, [sp, #4]
    while (p < (memblock+blksize)) { /* undo corruption is seed1 and seed2 are equal */
    34aa:	d20a      	bcs.n	34c2 <core_bench_state+0xbe>
        if (*p!=',')
    34ac:	7823      	ldrb	r3, [r4, #0]
    34ae:	2b2c      	cmp	r3, #44	; 0x2c
            *p^=(ee_u8)seed2;
    34b0:	ea83 0208 	eor.w	r2, r3, r8
    34b4:	bf1c      	itt	ne
    34b6:	7022      	strbne	r2, [r4, #0]
    34b8:	9c01      	ldrne	r4, [sp, #4]
        p+=step;
    34ba:	4434      	add	r4, r6
    while (p < (memblock+blksize)) { /* undo corruption is seed1 and seed2 are equal */
    34bc:	4554      	cmp	r4, sl
        p+=step;
    34be:	9401      	str	r4, [sp, #4]
    while (p < (memblock+blksize)) { /* undo corruption is seed1 and seed2 are equal */
    34c0:	d3f4      	bcc.n	34ac <core_bench_state+0xa8>
    34c2:	ac09      	add	r4, sp, #36	; 0x24
    34c4:	4626      	mov	r6, r4
        crc=crcu32(final_counts[i],crc);
    34c6:	4639      	mov	r1, r7
    34c8:	f855 0f04 	ldr.w	r0, [r5, #4]!
    34cc:	f000 f8d4 	bl	3678 <crcu32>
        crc=crcu32(track_counts[i],crc);
    34d0:	4601      	mov	r1, r0
    34d2:	f854 0f04 	ldr.w	r0, [r4, #4]!
    34d6:	f000 f8cf 	bl	3678 <crcu32>
    for (i=0; i<NUM_CORE_STATES; i++) {
    34da:	42b5      	cmp	r5, r6
        crc=crcu32(track_counts[i],crc);
    34dc:	4607      	mov	r7, r0
    for (i=0; i<NUM_CORE_STATES; i++) {
    34de:	d1f2      	bne.n	34c6 <core_bench_state+0xc2>
}
    34e0:	b012      	add	sp, #72	; 0x48
    34e2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    while (*p!=0) {
    34e6:	2a00      	cmp	r2, #0
    34e8:	d1cc      	bne.n	3484 <core_bench_state+0x80>
    34ea:	e7ea      	b.n	34c2 <core_bench_state+0xbe>
    while (p < (memblock+blksize)) { /* insert some corruption */
    34ec:	44a2      	add	sl, r4
    34ee:	4554      	cmp	r4, sl
    p=memblock;
    34f0:	9401      	str	r4, [sp, #4]
    34f2:	ad01      	add	r5, sp, #4
    while (p < (memblock+blksize)) { /* insert some corruption */
    34f4:	d3b5      	bcc.n	3462 <core_bench_state+0x5e>
    34f6:	e7e4      	b.n	34c2 <core_bench_state+0xbe>
    p=memblock;
    34f8:	9401      	str	r4, [sp, #4]
    34fa:	e7d7      	b.n	34ac <core_bench_state+0xa8>

000034fc <get_seed_32>:
    extern volatile ee_s32 seed3_volatile;
    extern volatile ee_s32 seed4_volatile;
    extern volatile ee_s32 seed5_volatile;
    ee_s32 get_seed_32(int i) {
        ee_s32 retval;
        switch (i) {
    34fc:	3801      	subs	r0, #1
    34fe:	2804      	cmp	r0, #4
    3500:	d813      	bhi.n	352a <get_seed_32+0x2e>
    3502:	e8df f000 	tbb	[pc, r0]
    3506:	0906      	.short	0x0906
    3508:	0f0c      	.short	0x0f0c
    350a:	03          	.byte	0x03
    350b:	00          	.byte	0x00
                break;
            case 4:
                retval=seed4_volatile;
                break;
            case 5:
                retval=seed5_volatile;
    350c:	4b08      	ldr	r3, [pc, #32]	; (3530 <get_seed_32+0x34>)
    350e:	6818      	ldr	r0, [r3, #0]
                break;
    3510:	4770      	bx	lr
                retval=seed1_volatile;
    3512:	4b08      	ldr	r3, [pc, #32]	; (3534 <get_seed_32+0x38>)
    3514:	6818      	ldr	r0, [r3, #0]
                break;
    3516:	4770      	bx	lr
                retval=seed2_volatile;
    3518:	4807      	ldr	r0, [pc, #28]	; (3538 <get_seed_32+0x3c>)
    351a:	6800      	ldr	r0, [r0, #0]
                break;
    351c:	4770      	bx	lr
                retval=seed3_volatile;
    351e:	4a07      	ldr	r2, [pc, #28]	; (353c <get_seed_32+0x40>)
    3520:	6810      	ldr	r0, [r2, #0]
                break;
    3522:	4770      	bx	lr
                retval=seed4_volatile;
    3524:	4906      	ldr	r1, [pc, #24]	; (3540 <get_seed_32+0x44>)
    3526:	6808      	ldr	r0, [r1, #0]
                break;
    3528:	4770      	bx	lr
            default:
                retval=0;
    352a:	2000      	movs	r0, #0
                break;
        }
        return retval;
    }
    352c:	4770      	bx	lr
    352e:	bf00      	nop
    3530:	10001058 	.word	0x10001058
    3534:	10001050 	.word	0x10001050
    3538:	10001054 	.word	0x10001054
    353c:	10001018 	.word	0x10001018
    3540:	1000101c 	.word	0x1000101c

00003544 <crcu16>:
        }
        else
            carry = 0;
        crc >>= 1;
        if (carry)
           crc |= 0x8000;
    3544:	f24a 0201 	movw	r2, #40961	; 0xa001
    3548:	084b      	lsrs	r3, r1, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    354a:	4041      	eors	r1, r0
    354c:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    3550:	ea83 0102 	eor.w	r1, r3, r2
           crc &= 0x7fff;
    }
    return crc;
}
ee_u16 crcu16(ee_u16 newval, ee_u16 crc) {
    crc=crcu8( (ee_u8) (newval)             ,crc);
    3554:	fa5f fc80 	uxtb.w	ip, r0
    3558:	bf18      	it	ne
    355a:	460b      	movne	r3, r1
ee_u16 crcu16(ee_u16 newval, ee_u16 crc) {
    355c:	b410      	push	{r4}
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    355e:	ea83 045c 	eor.w	r4, r3, ip, lsr #1
    3562:	085b      	lsrs	r3, r3, #1
    3564:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    3568:	ea83 0102 	eor.w	r1, r3, r2
    356c:	bf18      	it	ne
    356e:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    3570:	ea83 049c 	eor.w	r4, r3, ip, lsr #2
    3574:	085b      	lsrs	r3, r3, #1
    3576:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    357a:	ea83 0102 	eor.w	r1, r3, r2
    357e:	bf18      	it	ne
    3580:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    3582:	ea83 04dc 	eor.w	r4, r3, ip, lsr #3
    3586:	085b      	lsrs	r3, r3, #1
    3588:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    358c:	ea83 0102 	eor.w	r1, r3, r2
    3590:	bf18      	it	ne
    3592:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    3594:	ea83 141c 	eor.w	r4, r3, ip, lsr #4
    3598:	085b      	lsrs	r3, r3, #1
    359a:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    359e:	ea83 0102 	eor.w	r1, r3, r2
    35a2:	bf18      	it	ne
    35a4:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    35a6:	ea83 145c 	eor.w	r4, r3, ip, lsr #5
    35aa:	085b      	lsrs	r3, r3, #1
    35ac:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    35b0:	ea83 0102 	eor.w	r1, r3, r2
    35b4:	bf18      	it	ne
    35b6:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    35b8:	ea83 149c 	eor.w	r4, r3, ip, lsr #6
    35bc:	085b      	lsrs	r3, r3, #1
    35be:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    35c2:	ea83 0102 	eor.w	r1, r3, r2
    35c6:	bf18      	it	ne
    35c8:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    35ca:	ea83 14dc 	eor.w	r4, r3, ip, lsr #7
    35ce:	085b      	lsrs	r3, r3, #1
    35d0:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    35d4:	ea83 0c02 	eor.w	ip, r3, r2
    35d8:	bf18      	it	ne
    35da:	4663      	movne	r3, ip
    crc=crcu8( (ee_u8) ((newval)>>8)    ,crc);
    35dc:	0a00      	lsrs	r0, r0, #8
    35de:	0859      	lsrs	r1, r3, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    35e0:	4043      	eors	r3, r0
    35e2:	f013 0f01 	tst.w	r3, #1
    crc=crcu8( (ee_u8) ((newval)>>8)    ,crc);
    35e6:	fa5f fc80 	uxtb.w	ip, r0
           crc |= 0x8000;
    35ea:	ea81 0302 	eor.w	r3, r1, r2
    35ee:	bf08      	it	eq
    35f0:	460b      	moveq	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    35f2:	ea83 045c 	eor.w	r4, r3, ip, lsr #1
    35f6:	0858      	lsrs	r0, r3, #1
    35f8:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    35fc:	ea80 0302 	eor.w	r3, r0, r2
    3600:	bf08      	it	eq
    3602:	4603      	moveq	r3, r0
    3604:	085c      	lsrs	r4, r3, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    3606:	ea83 019c 	eor.w	r1, r3, ip, lsr #2
    360a:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    360e:	ea84 0002 	eor.w	r0, r4, r2
    3612:	bf18      	it	ne
    3614:	4604      	movne	r4, r0
    3616:	0863      	lsrs	r3, r4, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    3618:	ea84 01dc 	eor.w	r1, r4, ip, lsr #3
    361c:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    3620:	ea83 0402 	eor.w	r4, r3, r2
    3624:	bf18      	it	ne
    3626:	4623      	movne	r3, r4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    3628:	ea83 101c 	eor.w	r0, r3, ip, lsr #4
    362c:	085b      	lsrs	r3, r3, #1
    362e:	f010 0f01 	tst.w	r0, #1
           crc |= 0x8000;
    3632:	ea83 0102 	eor.w	r1, r3, r2
    3636:	bf18      	it	ne
    3638:	460b      	movne	r3, r1
    363a:	0858      	lsrs	r0, r3, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    363c:	ea83 145c 	eor.w	r4, r3, ip, lsr #5
    3640:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    3644:	ea80 0302 	eor.w	r3, r0, r2
    3648:	bf18      	it	ne
    364a:	4618      	movne	r0, r3
    364c:	0844      	lsrs	r4, r0, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    364e:	ea80 119c 	eor.w	r1, r0, ip, lsr #6
    3652:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    3656:	ea84 0002 	eor.w	r0, r4, r2
    365a:	bf18      	it	ne
    365c:	4604      	movne	r4, r0
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    365e:	ea84 11dc 	eor.w	r1, r4, ip, lsr #7
    3662:	0863      	lsrs	r3, r4, #1
    return crc;
    3664:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    3668:	ea83 0002 	eor.w	r0, r3, r2
}
    366c:	f85d 4b04 	ldr.w	r4, [sp], #4
    3670:	bf08      	it	eq
    3672:	4618      	moveq	r0, r3
    3674:	4770      	bx	lr
    3676:	bf00      	nop

00003678 <crcu32>:
           crc |= 0x8000;
    3678:	f24a 0201 	movw	r2, #40961	; 0xa001
    367c:	084b      	lsrs	r3, r1, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    367e:	4041      	eors	r1, r0
    3680:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    3684:	ea83 0102 	eor.w	r1, r3, r2
    3688:	bf18      	it	ne
    368a:	460b      	movne	r3, r1
ee_u16 crcu32(ee_u32 newval, ee_u16 crc) {
    368c:	b430      	push	{r4, r5}
    crc=crcu8( (ee_u8) (newval)             ,crc);
    368e:	b2c5      	uxtb	r5, r0
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    3690:	ea83 0455 	eor.w	r4, r3, r5, lsr #1
    3694:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    3696:	ea83 0c02 	eor.w	ip, r3, r2
    369a:	f014 0f01 	tst.w	r4, #1
    369e:	bf18      	it	ne
    36a0:	4663      	movne	r3, ip
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    36a2:	ea83 0195 	eor.w	r1, r3, r5, lsr #2
    36a6:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    36a8:	ea83 0402 	eor.w	r4, r3, r2
    36ac:	f011 0f01 	tst.w	r1, #1
    36b0:	bf18      	it	ne
    36b2:	4623      	movne	r3, r4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    36b4:	ea83 01d5 	eor.w	r1, r3, r5, lsr #3
    36b8:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    36ba:	ea83 0c02 	eor.w	ip, r3, r2
    36be:	f011 0f01 	tst.w	r1, #1
    36c2:	bf18      	it	ne
    36c4:	4663      	movne	r3, ip
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    36c6:	ea83 1415 	eor.w	r4, r3, r5, lsr #4
    36ca:	0859      	lsrs	r1, r3, #1
           crc |= 0x8000;
    36cc:	ea81 0302 	eor.w	r3, r1, r2
    36d0:	f014 0f01 	tst.w	r4, #1
    36d4:	bf18      	it	ne
    36d6:	4619      	movne	r1, r3
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    36d8:	ea81 1c55 	eor.w	ip, r1, r5, lsr #5
    36dc:	0849      	lsrs	r1, r1, #1
           crc |= 0x8000;
    36de:	ea81 0402 	eor.w	r4, r1, r2
    36e2:	f01c 0f01 	tst.w	ip, #1
    36e6:	bf18      	it	ne
    36e8:	4621      	movne	r1, r4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    36ea:	ea81 1c95 	eor.w	ip, r1, r5, lsr #6
    36ee:	084b      	lsrs	r3, r1, #1
           crc |= 0x8000;
    36f0:	ea83 0102 	eor.w	r1, r3, r2
    36f4:	f01c 0f01 	tst.w	ip, #1
    36f8:	bf18      	it	ne
    36fa:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    36fc:	ea83 15d5 	eor.w	r5, r3, r5, lsr #7
    3700:	f015 0f01 	tst.w	r5, #1
    3704:	ea4f 0353 	mov.w	r3, r3, lsr #1
           crc |= 0x8000;
    3708:	ea83 0402 	eor.w	r4, r3, r2
    crc=crcu8( (ee_u8) ((newval)>>8)    ,crc);
    370c:	f3c0 2107 	ubfx	r1, r0, #8, #8
    3710:	bf08      	it	eq
    3712:	461c      	moveq	r4, r3
    3714:	0863      	lsrs	r3, r4, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    3716:	404c      	eors	r4, r1
           crc |= 0x8000;
    3718:	ea83 0c02 	eor.w	ip, r3, r2
    371c:	f014 0f01 	tst.w	r4, #1
    crc=crcu8( (ee_u8) ((newval)>>8)    ,crc);
    3720:	b2cd      	uxtb	r5, r1
    3722:	bf18      	it	ne
    3724:	4663      	movne	r3, ip
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    3726:	ea83 0455 	eor.w	r4, r3, r5, lsr #1
    372a:	0859      	lsrs	r1, r3, #1
           crc |= 0x8000;
    372c:	ea81 0302 	eor.w	r3, r1, r2
    3730:	f014 0f01 	tst.w	r4, #1
    3734:	bf18      	it	ne
    3736:	4619      	movne	r1, r3
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    3738:	ea81 0c95 	eor.w	ip, r1, r5, lsr #2
    373c:	0849      	lsrs	r1, r1, #1
           crc |= 0x8000;
    373e:	ea81 0402 	eor.w	r4, r1, r2
    3742:	f01c 0f01 	tst.w	ip, #1
    3746:	bf18      	it	ne
    3748:	4621      	movne	r1, r4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    374a:	ea81 0cd5 	eor.w	ip, r1, r5, lsr #3
    374e:	084b      	lsrs	r3, r1, #1
           crc |= 0x8000;
    3750:	ea83 0102 	eor.w	r1, r3, r2
    3754:	f01c 0f01 	tst.w	ip, #1
    3758:	bf18      	it	ne
    375a:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    375c:	ea83 1415 	eor.w	r4, r3, r5, lsr #4
    3760:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    3762:	ea83 0c02 	eor.w	ip, r3, r2
    3766:	f014 0f01 	tst.w	r4, #1
    376a:	bf18      	it	ne
    376c:	4663      	movne	r3, ip
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    376e:	ea83 1155 	eor.w	r1, r3, r5, lsr #5
    3772:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    3774:	ea83 0402 	eor.w	r4, r3, r2
    3778:	f011 0f01 	tst.w	r1, #1
    377c:	bf18      	it	ne
    377e:	4623      	movne	r3, r4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    3780:	ea83 1195 	eor.w	r1, r3, r5, lsr #6
    3784:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    3786:	ea83 0c02 	eor.w	ip, r3, r2
    378a:	f011 0f01 	tst.w	r1, #1
    378e:	bf18      	it	ne
    3790:	4663      	movne	r3, ip
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    3792:	ea83 15d5 	eor.w	r5, r3, r5, lsr #7
    3796:	085c      	lsrs	r4, r3, #1
    3798:	f015 0f01 	tst.w	r5, #1
           crc |= 0x8000;
    379c:	ea84 0102 	eor.w	r1, r4, r2
    crc=crc16((ee_s16) newval       ,crc);
    crc=crc16((ee_s16) (newval>>16) ,crc);
    37a0:	ea4f 4010 	mov.w	r0, r0, lsr #16
    37a4:	bf08      	it	eq
    37a6:	4621      	moveq	r1, r4
    37a8:	084b      	lsrs	r3, r1, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    37aa:	4041      	eors	r1, r0
           crc |= 0x8000;
    37ac:	ea83 0c02 	eor.w	ip, r3, r2
    37b0:	f011 0f01 	tst.w	r1, #1
    crc=crcu8( (ee_u8) (newval)             ,crc);
    37b4:	b2c5      	uxtb	r5, r0
    37b6:	bf18      	it	ne
    37b8:	4663      	movne	r3, ip
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    37ba:	ea83 0455 	eor.w	r4, r3, r5, lsr #1
    37be:	0859      	lsrs	r1, r3, #1
           crc |= 0x8000;
    37c0:	ea81 0302 	eor.w	r3, r1, r2
    37c4:	f014 0f01 	tst.w	r4, #1
    37c8:	bf18      	it	ne
    37ca:	4619      	movne	r1, r3
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    37cc:	ea81 0c95 	eor.w	ip, r1, r5, lsr #2
    37d0:	0849      	lsrs	r1, r1, #1
           crc |= 0x8000;
    37d2:	ea81 0402 	eor.w	r4, r1, r2
    37d6:	f01c 0f01 	tst.w	ip, #1
    37da:	bf18      	it	ne
    37dc:	4621      	movne	r1, r4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    37de:	ea81 0cd5 	eor.w	ip, r1, r5, lsr #3
    37e2:	084b      	lsrs	r3, r1, #1
           crc |= 0x8000;
    37e4:	ea83 0102 	eor.w	r1, r3, r2
    37e8:	f01c 0f01 	tst.w	ip, #1
    37ec:	bf18      	it	ne
    37ee:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    37f0:	ea83 1415 	eor.w	r4, r3, r5, lsr #4
    37f4:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    37f6:	ea83 0c02 	eor.w	ip, r3, r2
    37fa:	f014 0f01 	tst.w	r4, #1
    37fe:	bf18      	it	ne
    3800:	4663      	movne	r3, ip
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    3802:	ea83 1155 	eor.w	r1, r3, r5, lsr #5
    3806:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    3808:	ea83 0402 	eor.w	r4, r3, r2
    380c:	f011 0f01 	tst.w	r1, #1
    3810:	bf18      	it	ne
    3812:	4623      	movne	r3, r4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    3814:	ea83 1195 	eor.w	r1, r3, r5, lsr #6
    3818:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    381a:	ea83 0c02 	eor.w	ip, r3, r2
    381e:	f011 0f01 	tst.w	r1, #1
    3822:	bf18      	it	ne
    3824:	4663      	movne	r3, ip
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    3826:	ea83 15d5 	eor.w	r5, r3, r5, lsr #7
    382a:	085b      	lsrs	r3, r3, #1
           crc |= 0x8000;
    382c:	ea83 0402 	eor.w	r4, r3, r2
    3830:	f015 0f01 	tst.w	r5, #1
    crc=crcu8( (ee_u8) ((newval)>>8)    ,crc);
    3834:	ea4f 2010 	mov.w	r0, r0, lsr #8
    3838:	bf18      	it	ne
    383a:	4623      	movne	r3, r4
    383c:	085d      	lsrs	r5, r3, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    383e:	4043      	eors	r3, r0
    3840:	f013 0f01 	tst.w	r3, #1
           crc |= 0x8000;
    3844:	ea85 0102 	eor.w	r1, r5, r2
    crc=crcu8( (ee_u8) ((newval)>>8)    ,crc);
    3848:	fa5f fc80 	uxtb.w	ip, r0
    384c:	bf14      	ite	ne
    384e:	4608      	movne	r0, r1
    3850:	4628      	moveq	r0, r5
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    3852:	ea80 035c 	eor.w	r3, r0, ip, lsr #1
    3856:	0844      	lsrs	r4, r0, #1
    3858:	f013 0f01 	tst.w	r3, #1
           crc |= 0x8000;
    385c:	ea84 0002 	eor.w	r0, r4, r2
    3860:	bf08      	it	eq
    3862:	4620      	moveq	r0, r4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    3864:	ea80 059c 	eor.w	r5, r0, ip, lsr #2
    3868:	0843      	lsrs	r3, r0, #1
    386a:	f015 0f01 	tst.w	r5, #1
           crc |= 0x8000;
    386e:	ea83 0102 	eor.w	r1, r3, r2
    3872:	bf08      	it	eq
    3874:	4619      	moveq	r1, r3
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    3876:	ea81 04dc 	eor.w	r4, r1, ip, lsr #3
    387a:	084d      	lsrs	r5, r1, #1
    387c:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    3880:	ea85 0002 	eor.w	r0, r5, r2
    3884:	bf08      	it	eq
    3886:	4628      	moveq	r0, r5
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    3888:	ea80 131c 	eor.w	r3, r0, ip, lsr #4
    388c:	0841      	lsrs	r1, r0, #1
    388e:	f013 0f01 	tst.w	r3, #1
           crc |= 0x8000;
    3892:	ea81 0402 	eor.w	r4, r1, r2
    3896:	bf08      	it	eq
    3898:	460c      	moveq	r4, r1
    389a:	0860      	lsrs	r0, r4, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    389c:	ea84 155c 	eor.w	r5, r4, ip, lsr #5
    38a0:	f015 0f01 	tst.w	r5, #1
           crc |= 0x8000;
    38a4:	ea80 0302 	eor.w	r3, r0, r2
    38a8:	bf18      	it	ne
    38aa:	4618      	movne	r0, r3
    38ac:	0844      	lsrs	r4, r0, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    38ae:	ea80 119c 	eor.w	r1, r0, ip, lsr #6
           crc |= 0x8000;
    38b2:	ea84 0502 	eor.w	r5, r4, r2
    38b6:	f011 0f01 	tst.w	r1, #1
    38ba:	bf18      	it	ne
    38bc:	462c      	movne	r4, r5
    38be:	0860      	lsrs	r0, r4, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    38c0:	ea84 1cdc 	eor.w	ip, r4, ip, lsr #7
    return crc;
    38c4:	f01c 0f01 	tst.w	ip, #1
           crc |= 0x8000;
    38c8:	ea82 0200 	eor.w	r2, r2, r0
}
    38cc:	bf18      	it	ne
    38ce:	4610      	movne	r0, r2
    38d0:	bc30      	pop	{r4, r5}
    38d2:	4770      	bx	lr

000038d4 <crc16>:
           crc |= 0x8000;
    38d4:	f24a 0201 	movw	r2, #40961	; 0xa001
    38d8:	084b      	lsrs	r3, r1, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    38da:	4041      	eors	r1, r0
    38dc:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    38e0:	ea83 0102 	eor.w	r1, r3, r2
    crc=crcu8( (ee_u8) (newval)             ,crc);
    38e4:	fa5f fc80 	uxtb.w	ip, r0
    38e8:	bf18      	it	ne
    38ea:	460b      	movne	r3, r1
ee_u16 crc16(ee_s16 newval, ee_u16 crc) {
    38ec:	b410      	push	{r4}
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    38ee:	ea83 045c 	eor.w	r4, r3, ip, lsr #1
    38f2:	085b      	lsrs	r3, r3, #1
    38f4:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    38f8:	ea83 0102 	eor.w	r1, r3, r2
    38fc:	bf18      	it	ne
    38fe:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    3900:	ea83 049c 	eor.w	r4, r3, ip, lsr #2
    3904:	085b      	lsrs	r3, r3, #1
    3906:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    390a:	ea83 0102 	eor.w	r1, r3, r2
    390e:	bf18      	it	ne
    3910:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    3912:	ea83 04dc 	eor.w	r4, r3, ip, lsr #3
    3916:	085b      	lsrs	r3, r3, #1
    3918:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    391c:	ea83 0102 	eor.w	r1, r3, r2
    3920:	bf18      	it	ne
    3922:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    3924:	ea83 141c 	eor.w	r4, r3, ip, lsr #4
    3928:	085b      	lsrs	r3, r3, #1
    392a:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    392e:	ea83 0102 	eor.w	r1, r3, r2
    3932:	bf18      	it	ne
    3934:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    3936:	ea83 145c 	eor.w	r4, r3, ip, lsr #5
    393a:	085b      	lsrs	r3, r3, #1
    393c:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    3940:	ea83 0102 	eor.w	r1, r3, r2
    3944:	bf18      	it	ne
    3946:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    3948:	ea83 149c 	eor.w	r4, r3, ip, lsr #6
    394c:	085b      	lsrs	r3, r3, #1
    394e:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    3952:	ea83 0102 	eor.w	r1, r3, r2
    3956:	bf18      	it	ne
    3958:	460b      	movne	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    395a:	ea83 14dc 	eor.w	r4, r3, ip, lsr #7
    395e:	085b      	lsrs	r3, r3, #1
    3960:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    3964:	ea83 0c02 	eor.w	ip, r3, r2
    3968:	bf18      	it	ne
    396a:	4663      	movne	r3, ip
    crc=crcu8( (ee_u8) ((newval)>>8)    ,crc);
    396c:	f3c0 2007 	ubfx	r0, r0, #8, #8
    3970:	0859      	lsrs	r1, r3, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    3972:	4043      	eors	r3, r0
    3974:	f013 0f01 	tst.w	r3, #1
    crc=crcu8( (ee_u8) ((newval)>>8)    ,crc);
    3978:	fa5f fc80 	uxtb.w	ip, r0
           crc |= 0x8000;
    397c:	ea81 0302 	eor.w	r3, r1, r2
    3980:	bf08      	it	eq
    3982:	460b      	moveq	r3, r1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    3984:	ea83 045c 	eor.w	r4, r3, ip, lsr #1
    3988:	0858      	lsrs	r0, r3, #1
    398a:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    398e:	ea80 0302 	eor.w	r3, r0, r2
    3992:	bf08      	it	eq
    3994:	4603      	moveq	r3, r0
    3996:	085c      	lsrs	r4, r3, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    3998:	ea83 019c 	eor.w	r1, r3, ip, lsr #2
    399c:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    39a0:	ea84 0002 	eor.w	r0, r4, r2
    39a4:	bf18      	it	ne
    39a6:	4604      	movne	r4, r0
    39a8:	0863      	lsrs	r3, r4, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    39aa:	ea84 01dc 	eor.w	r1, r4, ip, lsr #3
    39ae:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    39b2:	ea83 0402 	eor.w	r4, r3, r2
    39b6:	bf18      	it	ne
    39b8:	4623      	movne	r3, r4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    39ba:	ea83 101c 	eor.w	r0, r3, ip, lsr #4
    39be:	085b      	lsrs	r3, r3, #1
    39c0:	f010 0f01 	tst.w	r0, #1
           crc |= 0x8000;
    39c4:	ea83 0102 	eor.w	r1, r3, r2
    39c8:	bf18      	it	ne
    39ca:	460b      	movne	r3, r1
    39cc:	0858      	lsrs	r0, r3, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    39ce:	ea83 145c 	eor.w	r4, r3, ip, lsr #5
    39d2:	f014 0f01 	tst.w	r4, #1
           crc |= 0x8000;
    39d6:	ea80 0302 	eor.w	r3, r0, r2
    39da:	bf18      	it	ne
    39dc:	4618      	movne	r0, r3
    39de:	0844      	lsrs	r4, r0, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    39e0:	ea80 119c 	eor.w	r1, r0, ip, lsr #6
    39e4:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    39e8:	ea84 0002 	eor.w	r0, r4, r2
    39ec:	bf18      	it	ne
    39ee:	4604      	movne	r4, r0
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    39f0:	ea84 11dc 	eor.w	r1, r4, ip, lsr #7
    39f4:	0863      	lsrs	r3, r4, #1
    return crcu16((ee_u16)newval, crc);
    39f6:	f011 0f01 	tst.w	r1, #1
           crc |= 0x8000;
    39fa:	ea83 0002 	eor.w	r0, r3, r2
}
    39fe:	f85d 4b04 	ldr.w	r4, [sp], #4
    3a02:	bf08      	it	eq
    3a04:	4618      	moveq	r0, r3
    3a06:	4770      	bx	lr

00003a08 <check_data_types>:
    }
    if (retval>0) {
        ee_printf("ERROR: Please modify the datatypes in core_portme.h!\n");
    }
    return retval;
}
    3a08:	2000      	movs	r0, #0
    3a0a:	4770      	bx	lr

00003a0c <am_nmi_isr>:
// by a debugger.
//
//*****************************************************************************
void
am_nmi_isr(void)
{
    3a0c:	e7fe      	b.n	3a0c <am_nmi_isr>
    3a0e:	bf00      	nop

00003a10 <am_adc_isr>:
// for examination by a debugger.
//
//*****************************************************************************
void
am_default_isr(void)
{
    3a10:	e7fe      	b.n	3a10 <am_adc_isr>
    3a12:	bf00      	nop

00003a14 <am_reset_isr>:
    __asm("    ldr    r0, =0xE000ED08\n"
    3a14:	4811      	ldr	r0, [pc, #68]	; (3a5c <zero_loop+0x12>)
    3a16:	4912      	ldr	r1, [pc, #72]	; (3a60 <zero_loop+0x16>)
    3a18:	6001      	str	r1, [r0, #0]
    __asm("    ldr    sp, [r1]");
    3a1a:	f8d1 d000 	ldr.w	sp, [r1]
    __asm("ldr  r0, =0xE000ED88\n"
    3a1e:	4811      	ldr	r0, [pc, #68]	; (3a64 <zero_loop+0x1a>)
    3a20:	6801      	ldr	r1, [r0, #0]
    3a22:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    3a26:	6001      	str	r1, [r0, #0]
    3a28:	f3bf 8f4f 	dsb	sy
    3a2c:	f3bf 8f6f 	isb	sy
    __asm("    ldr     r0, =_init_data\n"
    3a30:	480d      	ldr	r0, [pc, #52]	; (3a68 <zero_loop+0x1e>)
    3a32:	490e      	ldr	r1, [pc, #56]	; (3a6c <zero_loop+0x22>)
    3a34:	4a0e      	ldr	r2, [pc, #56]	; (3a70 <zero_loop+0x26>)

00003a36 <copy_loop>:
    3a36:	f850 3b04 	ldr.w	r3, [r0], #4
    3a3a:	f841 3b04 	str.w	r3, [r1], #4
    3a3e:	4291      	cmp	r1, r2
    3a40:	dbf9      	blt.n	3a36 <copy_loop>
    __asm("    ldr     r0, =_sbss\n"
    3a42:	480c      	ldr	r0, [pc, #48]	; (3a74 <zero_loop+0x2a>)
    3a44:	490c      	ldr	r1, [pc, #48]	; (3a78 <zero_loop+0x2e>)
    3a46:	f04f 0200 	mov.w	r2, #0

00003a4a <zero_loop>:
    3a4a:	4288      	cmp	r0, r1
    3a4c:	bfb8      	it	lt
    3a4e:	f840 2b04 	strlt.w	r2, [r0], #4
    3a52:	dbfa      	blt.n	3a4a <zero_loop>
    main();
    3a54:	f7fd fd68 	bl	1528 <main>
    __asm("    bkpt     ");
    3a58:	be00      	bkpt	0x0000
    3a5a:	0000      	.short	0x0000
    3a5c:	e000ed08 	.word	0xe000ed08
    3a60:	00000000 	.word	0x00000000
    3a64:	e000ed88 	.word	0xe000ed88
    3a68:	00005888 	.word	0x00005888
    3a6c:	10001000 	.word	0x10001000
    3a70:	10001048 	.word	0x10001048
    3a74:	10001048 	.word	0x10001048
    3a78:	10001570 	.word	0x10001570

00003a7c <am_util_delay_ms>:
//! @returns None
//
//*****************************************************************************
void
am_util_delay_ms(uint32_t ui32MilliSeconds)
{
    3a7c:	b510      	push	{r4, lr}
    3a7e:	4604      	mov	r4, r0
#if AM_APOLLO3_CLKGEN
    am_hal_clkgen_status_t sClkgenStatus;
    am_hal_clkgen_status_get(&sClkgenStatus);
    ui32HFRC = sClkgenStatus.ui32SysclkFreq;
#else
    ui32HFRC = am_hal_clkgen_sysclk_get();
    3a80:	f001 fabe 	bl	5000 <am_hal_clkgen_sysclk_get>
#endif
    ui32Loops = ui32MilliSeconds * (ui32HFRC / 3000);
    3a84:	4b04      	ldr	r3, [pc, #16]	; (3a98 <am_util_delay_ms+0x1c>)
    3a86:	fba3 3000 	umull	r3, r0, r3, r0
    3a8a:	0980      	lsrs	r0, r0, #6

    //
    // Call the BOOTROM cycle delay function
    //
    am_hal_flash_delay(ui32Loops);
    3a8c:	fb04 f000 	mul.w	r0, r4, r0
}
    3a90:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    am_hal_flash_delay(ui32Loops);
    3a94:	f001 baca 	b.w	502c <am_hal_flash_delay>
    3a98:	057619f1 	.word	0x057619f1

00003a9c <am_fault_isr>:
}
#elif defined(__GNUC_STDC_INLINE__)
uint32_t __attribute__((naked))
am_fault_isr(void)
{
    __asm("    push    {r7,lr}");
    3a9c:	b580      	push	{r7, lr}
    __asm("    mov     r0, sp");
    3a9e:	4668      	mov	r0, sp
    __asm("    adds    r0, #(2*4)");
    3aa0:	3008      	adds	r0, #8
    __asm("    bl      am_util_faultisr_collect_data");
    3aa2:	f000 f805 	bl	3ab0 <am_util_faultisr_collect_data>
    __asm("    pop     {r0,pc}");
    3aa6:	bd01      	pop	{r0, pc}

00003aa8 <getStackedReg>:
}

uint32_t __attribute__((naked))
getStackedReg(uint32_t regnum, uint32_t u32SP)
{
    __asm("    lsls    r0, r0, #2");
    3aa8:	0080      	lsls	r0, r0, #2
    __asm("    adds    r0, r1");
    3aaa:	1840      	adds	r0, r0, r1
    __asm("    ldr     r0, [r0]");
    3aac:	6800      	ldr	r0, [r0, #0]
    __asm("    bx      lr");
    3aae:	4770      	bx	lr

00003ab0 <am_util_faultisr_collect_data>:
// am_fault_isr() was called.
//
//*****************************************************************************
void
am_util_faultisr_collect_data(uint32_t u32IsrSP)
{
    3ab0:	b500      	push	{lr}
    3ab2:	b093      	sub	sp, #76	; 0x4c
    volatile am_fault_t sFaultData;
    am_hal_mcuctrl_fault_t sHalFaultData = {0};
    3ab4:	2300      	movs	r3, #0
    // a breakpoint at the end of the routine.  If the printing is not used,
    // we'll get a compiler warning; so to avoid that warning, we'll use it
    // in a dummy assignment here.
    //
    sFaultData.u32CFSR = u32Mask;       // Avoid compiler warning
    sFaultData.u32CFSR = AM_REGVAL(AM_REG_SYSCTRL_CFSR_O);
    3ab6:	4a2d      	ldr	r2, [pc, #180]	; (3b6c <am_util_faultisr_collect_data+0xbc>)
    sFaultData.u32CFSR = u32Mask;       // Avoid compiler warning
    3ab8:	9310      	str	r3, [sp, #64]	; 0x40
    am_hal_mcuctrl_fault_t sHalFaultData = {0};
    3aba:	9301      	str	r3, [sp, #4]
    3abc:	9300      	str	r3, [sp, #0]
    3abe:	9302      	str	r3, [sp, #8]
    3ac0:	9303      	str	r3, [sp, #12]
    3ac2:	9304      	str	r3, [sp, #16]
    3ac4:	9305      	str	r3, [sp, #20]
    sFaultData.u32CFSR = AM_REGVAL(AM_REG_SYSCTRL_CFSR_O);
    3ac6:	6811      	ldr	r1, [r2, #0]
    3ac8:	9110      	str	r1, [sp, #64]	; 0x40
    sFaultData.u8MMSR  = (sFaultData.u32CFSR >> 0)  & 0xff;
    3aca:	9b10      	ldr	r3, [sp, #64]	; 0x40
    3acc:	b2d9      	uxtb	r1, r3
    3ace:	f88d 1044 	strb.w	r1, [sp, #68]	; 0x44
    sFaultData.u8BFSR  = (sFaultData.u32CFSR >> 8)  & 0xff;
    3ad2:	9b10      	ldr	r3, [sp, #64]	; 0x40
    3ad4:	f3c3 2107 	ubfx	r1, r3, #8, #8
    3ad8:	f88d 1045 	strb.w	r1, [sp, #69]	; 0x45
    sFaultData.u16UFSR = (sFaultData.u32CFSR >> 16) & 0xffff;
    3adc:	9b10      	ldr	r3, [sp, #64]	; 0x40
    3ade:	0c19      	lsrs	r1, r3, #16
    3ae0:	f8ad 1046 	strh.w	r1, [sp, #70]	; 0x46

    //
    // The address of the location that caused the fault.  e.g. if accessing an
    // invalid data location caused the fault, that address will appear here.
    //
    sFaultData.u32BFAR = AM_REGVAL(AM_REG_SYSCTRL_BFAR_O);
    3ae4:	6912      	ldr	r2, [r2, #16]
    3ae6:	920f      	str	r2, [sp, #60]	; 0x3c

    //
    // The address of the instruction that caused the fault is the stacked PC
    // if BFSR bit1 is set.
    //
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    3ae8:	f89d 1045 	ldrb.w	r1, [sp, #69]	; 0x45
    3aec:	078a      	lsls	r2, r1, #30
{
    3aee:	4603      	mov	r3, r0
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    3af0:	d436      	bmi.n	3b60 <am_util_faultisr_collect_data+0xb0>
    3af2:	f04f 32ff 	mov.w	r2, #4294967295

    //
    // Get the stacked registers.
    // Note - the address of the instruction that caused the fault is u32PC.
    //
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    3af6:	4619      	mov	r1, r3
    3af8:	2000      	movs	r0, #0
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    3afa:	920e      	str	r2, [sp, #56]	; 0x38
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    3afc:	f7ff ffd4 	bl	3aa8 <getStackedReg>
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    3b00:	4619      	mov	r1, r3
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    3b02:	4602      	mov	r2, r0
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    3b04:	2001      	movs	r0, #1
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    3b06:	9206      	str	r2, [sp, #24]
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    3b08:	f7ff ffce 	bl	3aa8 <getStackedReg>
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    3b0c:	4619      	mov	r1, r3
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    3b0e:	4602      	mov	r2, r0
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    3b10:	2002      	movs	r0, #2
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    3b12:	9207      	str	r2, [sp, #28]
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    3b14:	f7ff ffc8 	bl	3aa8 <getStackedReg>
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    3b18:	4619      	mov	r1, r3
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    3b1a:	4602      	mov	r2, r0
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    3b1c:	2003      	movs	r0, #3
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    3b1e:	9208      	str	r2, [sp, #32]
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    3b20:	f7ff ffc2 	bl	3aa8 <getStackedReg>
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    3b24:	4619      	mov	r1, r3
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    3b26:	4602      	mov	r2, r0
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    3b28:	2004      	movs	r0, #4
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    3b2a:	9209      	str	r2, [sp, #36]	; 0x24
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    3b2c:	f7ff ffbc 	bl	3aa8 <getStackedReg>
    3b30:	4602      	mov	r2, r0
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    3b32:	4619      	mov	r1, r3
    3b34:	2005      	movs	r0, #5
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    3b36:	920a      	str	r2, [sp, #40]	; 0x28
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    3b38:	f7ff ffb6 	bl	3aa8 <getStackedReg>
    3b3c:	4602      	mov	r2, r0
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    3b3e:	4619      	mov	r1, r3
    3b40:	2006      	movs	r0, #6
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    3b42:	920b      	str	r2, [sp, #44]	; 0x2c
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    3b44:	f7ff ffb0 	bl	3aa8 <getStackedReg>
    3b48:	4602      	mov	r2, r0
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    3b4a:	4619      	mov	r1, r3
    3b4c:	2007      	movs	r0, #7
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    3b4e:	920c      	str	r2, [sp, #48]	; 0x30
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    3b50:	f7ff ffaa 	bl	3aa8 <getStackedReg>
    3b54:	4601      	mov	r1, r0
    // Use the HAL MCUCTRL functions to read the fault data.
    //
#ifdef AM_APOLLO3_MCUCTRL
    am_hal_mcuctrl_info_get(AM_HAL_MCUCTRL_INFO_FAULT_STATUS, &sHalFaultData);
#else
    am_hal_mcuctrl_fault_status(&sHalFaultData);
    3b56:	4668      	mov	r0, sp
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    3b58:	910d      	str	r1, [sp, #52]	; 0x34
    am_hal_mcuctrl_fault_status(&sHalFaultData);
    3b5a:	f001 fa6b 	bl	5034 <am_hal_mcuctrl_fault_status>
    3b5e:	e7fe      	b.n	3b5e <am_util_faultisr_collect_data+0xae>
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    3b60:	4601      	mov	r1, r0
    3b62:	2006      	movs	r0, #6
    3b64:	f7ff ffa0 	bl	3aa8 <getStackedReg>
    3b68:	4602      	mov	r2, r0
    3b6a:	e7c4      	b.n	3af6 <am_util_faultisr_collect_data+0x46>
    3b6c:	e000ed28 	.word	0xe000ed28

00003b70 <uint64_to_str>:
// written).
//
//*****************************************************************************
static int
uint64_to_str(uint64_t ui64Val, char *pcBuf)
{
    3b70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3b74:	b095      	sub	sp, #84	; 0x54
    3b76:	f10d 0e34 	add.w	lr, sp, #52	; 0x34
    3b7a:	4604      	mov	r4, r0
        //
        // Get modulus
        //
        uMod = ui64Val - (u64Tmp * 10);

        tbuf[ix++] = uMod + '0';
    3b7c:	2001      	movs	r0, #1
{
    3b7e:	460d      	mov	r5, r1
    3b80:	920b      	str	r2, [sp, #44]	; 0x2c
    3b82:	46f4      	mov	ip, lr
    3b84:	900a      	str	r0, [sp, #40]	; 0x28
    3b86:	e00b      	b.n	3ba0 <uint64_to_str+0x30>
        tbuf[ix++] = uMod + '0';
    3b88:	f88c 3000 	strb.w	r3, [ip]
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    3b8c:	4604      	mov	r4, r0
    3b8e:	2500      	movs	r5, #0
        ui64Val = u64Tmp;
    } while ( ui64Val );
    3b90:	2800      	cmp	r0, #0
    3b92:	f000 8083 	beq.w	3c9c <uint64_to_str+0x12c>
    3b96:	990a      	ldr	r1, [sp, #40]	; 0x28
    3b98:	3101      	adds	r1, #1
    3b9a:	910a      	str	r1, [sp, #40]	; 0x28
    3b9c:	f10c 0c01 	add.w	ip, ip, #1
        q32 = (ui32Val>>1) + (ui32Val>>2);
    3ba0:	08a3      	lsrs	r3, r4, #2
    3ba2:	eb03 0154 	add.w	r1, r3, r4, lsr #1
        q32 += (q32 >> 4);
    3ba6:	eb01 1211 	add.w	r2, r1, r1, lsr #4
        q32 += (q32 >> 8);
    3baa:	eb02 2612 	add.w	r6, r2, r2, lsr #8
        q32 += (q32 >> 16);
    3bae:	eb06 4716 	add.w	r7, r6, r6, lsr #16
        q32 >>= 3;
    3bb2:	08f8      	lsrs	r0, r7, #3
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    3bb4:	1da3      	adds	r3, r4, #6
        r32 = ui32Val - q32*10;
    3bb6:	eb00 0880 	add.w	r8, r0, r0, lsl #2
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    3bba:	eba3 0148 	sub.w	r1, r3, r8, lsl #1
    3bbe:	eb00 1011 	add.w	r0, r0, r1, lsr #4
    if ( ui64Val >> 32 )
    3bc2:	462e      	mov	r6, r5
        uMod = ui64Val - (u64Tmp * 10);
    3bc4:	eb00 0280 	add.w	r2, r0, r0, lsl #2
    if ( ui64Val >> 32 )
    3bc8:	2700      	movs	r7, #0
        uMod = ui64Val - (u64Tmp * 10);
    3bca:	eba4 0342 	sub.w	r3, r4, r2, lsl #1
    if ( ui64Val >> 32 )
    3bce:	ea56 0107 	orrs.w	r1, r6, r7
        tbuf[ix++] = uMod + '0';
    3bd2:	f103 0330 	add.w	r3, r3, #48	; 0x30
    if ( ui64Val >> 32 )
    3bd6:	d0d7      	beq.n	3b88 <uint64_to_str+0x18>
        q64 = (ui64Val>>1) + (ui64Val>>2);
    3bd8:	08a0      	lsrs	r0, r4, #2
    3bda:	ea40 7385 	orr.w	r3, r0, r5, lsl #30
    3bde:	08ae      	lsrs	r6, r5, #2
    3be0:	9304      	str	r3, [sp, #16]
    3be2:	9605      	str	r6, [sp, #20]
    3be4:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    3be8:	086b      	lsrs	r3, r5, #1
    3bea:	ea4f 0234 	mov.w	r2, r4, rrx
    3bee:	1882      	adds	r2, r0, r2
    3bf0:	eb41 0303 	adc.w	r3, r1, r3
        q64 += (q64 >> 4);
    3bf4:	0911      	lsrs	r1, r2, #4
    3bf6:	ea41 7003 	orr.w	r0, r1, r3, lsl #28
    3bfa:	1812      	adds	r2, r2, r0
    3bfc:	ea4f 1613 	mov.w	r6, r3, lsr #4
    3c00:	4173      	adcs	r3, r6
        q64 += (q64 >> 8);
    3c02:	0a11      	lsrs	r1, r2, #8
    3c04:	ea41 6003 	orr.w	r0, r1, r3, lsl #24
    3c08:	0a1e      	lsrs	r6, r3, #8
    3c0a:	9601      	str	r6, [sp, #4]
    3c0c:	9000      	str	r0, [sp, #0]
    3c0e:	e9dd 0100 	ldrd	r0, r1, [sp]
    3c12:	1882      	adds	r2, r0, r2
    3c14:	4616      	mov	r6, r2
    3c16:	eb41 0303 	adc.w	r3, r1, r3
        q64 += (q64 >> 16);
    3c1a:	0c31      	lsrs	r1, r6, #16
        q64 += (q64 >> 8);
    3c1c:	461a      	mov	r2, r3
        q64 += (q64 >> 16);
    3c1e:	ea41 4003 	orr.w	r0, r1, r3, lsl #16
    3c22:	0c1b      	lsrs	r3, r3, #16
    3c24:	9303      	str	r3, [sp, #12]
    3c26:	9002      	str	r0, [sp, #8]
    3c28:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    3c2c:	eb10 0806 	adds.w	r8, r0, r6
    3c30:	eb41 0302 	adc.w	r3, r1, r2
        q64 += (q64 >> 32);
    3c34:	9308      	str	r3, [sp, #32]
    3c36:	9709      	str	r7, [sp, #36]	; 0x24
    3c38:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
    3c3c:	eb10 0208 	adds.w	r2, r0, r8
    3c40:	eb41 0303 	adc.w	r3, r1, r3
        q64 >>= 3;
    3c44:	08d1      	lsrs	r1, r2, #3
    3c46:	ea41 7643 	orr.w	r6, r1, r3, lsl #29
    3c4a:	08df      	lsrs	r7, r3, #3
        r64 = ui64Val - q64*10;
    3c4c:	00b8      	lsls	r0, r7, #2
    3c4e:	ea4f 0a86 	mov.w	sl, r6, lsl #2
    3c52:	eb1a 0906 	adds.w	r9, sl, r6
    3c56:	ea40 7896 	orr.w	r8, r0, r6, lsr #30
    3c5a:	eb48 0307 	adc.w	r3, r8, r7
    3c5e:	eb19 0209 	adds.w	r2, r9, r9
    3c62:	415b      	adcs	r3, r3
        return q64 + ((r64 + 6) >> 4);
    3c64:	f114 0b06 	adds.w	fp, r4, #6
    3c68:	f145 0500 	adc.w	r5, r5, #0
    3c6c:	ebbb 0202 	subs.w	r2, fp, r2
    3c70:	eb65 0303 	sbc.w	r3, r5, r3
    3c74:	0915      	lsrs	r5, r2, #4
    3c76:	ea45 7203 	orr.w	r2, r5, r3, lsl #28
    3c7a:	091b      	lsrs	r3, r3, #4
    3c7c:	9206      	str	r2, [sp, #24]
    3c7e:	9307      	str	r3, [sp, #28]
    3c80:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    3c84:	1996      	adds	r6, r2, r6
    3c86:	eb43 0507 	adc.w	r5, r3, r7
        uMod = ui64Val - (u64Tmp * 10);
    3c8a:	eb06 0786 	add.w	r7, r6, r6, lsl #2
    3c8e:	eba4 0447 	sub.w	r4, r4, r7, lsl #1
        tbuf[ix++] = uMod + '0';
    3c92:	3430      	adds	r4, #48	; 0x30
    3c94:	f88c 4000 	strb.w	r4, [ip]
    3c98:	4634      	mov	r4, r6
    3c9a:	e77c      	b.n	3b96 <uint64_to_str+0x26>
    iNumDig = ix;

    //
    // Now, reverse the buffer when saving to the caller's buffer.
    //
    if ( pcBuf )
    3c9c:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
    3c9e:	980a      	ldr	r0, [sp, #40]	; 0x28
    3ca0:	2e00      	cmp	r6, #0
    3ca2:	d059      	beq.n	3d58 <uint64_to_str+0x1e8>
    3ca4:	eb0e 0a00 	add.w	sl, lr, r0
    3ca8:	46d3      	mov	fp, sl
    3caa:	ea6f 0c0e 	mvn.w	ip, lr
    {
        while ( ix-- )
        {
            *pcBuf++ = tbuf[ix];
    3cae:	f81b 7d01 	ldrb.w	r7, [fp, #-1]!
    3cb2:	7037      	strb	r7, [r6, #0]
    3cb4:	44d4      	add	ip, sl
        while ( ix-- )
    3cb6:	45de      	cmp	lr, fp
    3cb8:	4632      	mov	r2, r6
    3cba:	f00c 0107 	and.w	r1, ip, #7
    3cbe:	bf08      	it	eq
    3cc0:	4632      	moveq	r2, r6
    3cc2:	d047      	beq.n	3d54 <uint64_to_str+0x1e4>
    3cc4:	b349      	cbz	r1, 3d1a <uint64_to_str+0x1aa>
    3cc6:	2901      	cmp	r1, #1
    3cc8:	d021      	beq.n	3d0e <uint64_to_str+0x19e>
    3cca:	2902      	cmp	r1, #2
    3ccc:	d01b      	beq.n	3d06 <uint64_to_str+0x196>
    3cce:	2903      	cmp	r1, #3
    3cd0:	d015      	beq.n	3cfe <uint64_to_str+0x18e>
    3cd2:	2904      	cmp	r1, #4
    3cd4:	d00f      	beq.n	3cf6 <uint64_to_str+0x186>
    3cd6:	2905      	cmp	r1, #5
    3cd8:	d009      	beq.n	3cee <uint64_to_str+0x17e>
    3cda:	2906      	cmp	r1, #6
            *pcBuf++ = tbuf[ix];
    3cdc:	bf1c      	itt	ne
    3cde:	f81b 1d01 	ldrbne.w	r1, [fp, #-1]!
    3ce2:	f802 1f01 	strbne.w	r1, [r2, #1]!
    3ce6:	f81b 3d01 	ldrb.w	r3, [fp, #-1]!
    3cea:	f802 3f01 	strb.w	r3, [r2, #1]!
    3cee:	f81b 6d01 	ldrb.w	r6, [fp, #-1]!
    3cf2:	f802 6f01 	strb.w	r6, [r2, #1]!
    3cf6:	f81b 4d01 	ldrb.w	r4, [fp, #-1]!
    3cfa:	f802 4f01 	strb.w	r4, [r2, #1]!
    3cfe:	f81b 7d01 	ldrb.w	r7, [fp, #-1]!
    3d02:	f802 7f01 	strb.w	r7, [r2, #1]!
    3d06:	f81b 5d01 	ldrb.w	r5, [fp, #-1]!
    3d0a:	f802 5f01 	strb.w	r5, [r2, #1]!
    3d0e:	f81b 8d01 	ldrb.w	r8, [fp, #-1]!
    3d12:	f802 8f01 	strb.w	r8, [r2, #1]!
        while ( ix-- )
    3d16:	45de      	cmp	lr, fp
    3d18:	d01b      	beq.n	3d52 <uint64_to_str+0x1e2>
            *pcBuf++ = tbuf[ix];
    3d1a:	f81b 1c01 	ldrb.w	r1, [fp, #-1]
    3d1e:	f81b 3c02 	ldrb.w	r3, [fp, #-2]
    3d22:	f81b 9c03 	ldrb.w	r9, [fp, #-3]
    3d26:	f81b 7c04 	ldrb.w	r7, [fp, #-4]
    3d2a:	f81b 6c05 	ldrb.w	r6, [fp, #-5]
    3d2e:	f81b 5c06 	ldrb.w	r5, [fp, #-6]
    3d32:	f81b 4c07 	ldrb.w	r4, [fp, #-7]
    3d36:	f81b ad08 	ldrb.w	sl, [fp, #-8]!
    3d3a:	7051      	strb	r1, [r2, #1]
        while ( ix-- )
    3d3c:	45de      	cmp	lr, fp
            *pcBuf++ = tbuf[ix];
    3d3e:	7093      	strb	r3, [r2, #2]
    3d40:	f882 9003 	strb.w	r9, [r2, #3]
    3d44:	7117      	strb	r7, [r2, #4]
    3d46:	7156      	strb	r6, [r2, #5]
    3d48:	7195      	strb	r5, [r2, #6]
    3d4a:	71d4      	strb	r4, [r2, #7]
    3d4c:	f802 af08 	strb.w	sl, [r2, #8]!
        while ( ix-- )
    3d50:	d1e3      	bne.n	3d1a <uint64_to_str+0x1aa>
    3d52:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
        }

        //
        // Terminate the caller's buffer
        //
        *pcBuf = 0x00;
    3d54:	2100      	movs	r1, #0
    3d56:	5411      	strb	r1, [r2, r0]
    }

    return iNumDig;
}
    3d58:	b015      	add	sp, #84	; 0x54
    3d5a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3d5e:	bf00      	nop

00003d60 <am_util_stdio_printf_init>:
    g_pfnCharPrint = pfnCharPrint;
    3d60:	4b01      	ldr	r3, [pc, #4]	; (3d68 <am_util_stdio_printf_init+0x8>)
    3d62:	6018      	str	r0, [r3, #0]
    3d64:	4770      	bx	lr
    3d66:	bf00      	nop
    3d68:	1000156c 	.word	0x1000156c

00003d6c <am_util_stdio_vsprintf>:
//! @return uint32_t representing the number of characters printed.
//
//******************************************************************************
uint32_t
am_util_stdio_vsprintf(char *pcBuf, const char *pcFmt, va_list pArgs)
{
    3d6c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3d70:	4680      	mov	r8, r0
    3d72:	b0b1      	sub	sp, #196	; 0xc4
    3d74:	4693      	mov	fp, r2
    char *pcStr;
    uint64_t ui64Val;
    int64_t i64Val;
    uint32_t ui32NumChars, ui32CharCnt = 0;
    3d76:	f04f 0900 	mov.w	r9, #0
    int iWidth, iVal, iPrecision;
    uint8_t ui8CharSpecifier, ui8PadChar;
    bool bLower, bLongLong, bNeg;
    uint32_t ui32strlen = 0;

    while ( *pcFmt != 0x0 )
    3d7a:	780b      	ldrb	r3, [r1, #0]
    3d7c:	b183      	cbz	r3, 3da0 <am_util_stdio_vsprintf+0x34>
    {
        iPrecision = 6;             // printf() default precision for %f is 6

        if ( *pcFmt != '%' )
    3d7e:	2b25      	cmp	r3, #37	; 0x25
    3d80:	d017      	beq.n	3db2 <am_util_stdio_vsprintf+0x46>
        {
            //
            // Accumulate the string portion of the format specification.
            //
            if ( pcBuf )
    3d82:	f1b8 0f00 	cmp.w	r8, #0
    3d86:	d005      	beq.n	3d94 <am_util_stdio_vsprintf+0x28>
            {
                // If '\n', convert to '\r\n'
                if ( *pcFmt == '\n'  &&  g_bTxtXlate )
    3d88:	2b0a      	cmp	r3, #10
    3d8a:	d038      	beq.n	3dfe <am_util_stdio_vsprintf+0x92>
                {
                    *pcBuf++ = '\r';
                    ++ui32CharCnt;
                }
                *pcBuf++ = *pcFmt;
    3d8c:	f888 3000 	strb.w	r3, [r8]
    3d90:	f108 0801 	add.w	r8, r8, #1
            }

            ++pcFmt;
    3d94:	3101      	adds	r1, #1
    while ( *pcFmt != 0x0 )
    3d96:	780b      	ldrb	r3, [r1, #0]
            ++ui32CharCnt;
    3d98:	f109 0901 	add.w	r9, r9, #1
    while ( *pcFmt != 0x0 )
    3d9c:	2b00      	cmp	r3, #0
    3d9e:	d1ee      	bne.n	3d7e <am_util_stdio_vsprintf+0x12>
    } // while ()

    //
    // Terminate the string
    //
    if ( pcBuf )
    3da0:	f1b8 0f00 	cmp.w	r8, #0
    3da4:	d001      	beq.n	3daa <am_util_stdio_vsprintf+0x3e>
    {
        *pcBuf = 0x0;
    3da6:	f888 3000 	strb.w	r3, [r8]
    }

    return (ui32CharCnt);
}
    3daa:	4648      	mov	r0, r9
    3dac:	b031      	add	sp, #196	; 0xc4
    3dae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ( *pcFmt == '0' )
    3db2:	784a      	ldrb	r2, [r1, #1]
    3db4:	2a30      	cmp	r2, #48	; 0x30
    3db6:	d03b      	beq.n	3e30 <am_util_stdio_vsprintf+0xc4>
        ++pcFmt;
    3db8:	1c4e      	adds	r6, r1, #1
        ui8PadChar = ' ';
    3dba:	2520      	movs	r5, #32
    if ( *pcStr == '-')
    3dbc:	2a2d      	cmp	r2, #45	; 0x2d
    3dbe:	d02c      	beq.n	3e1a <am_util_stdio_vsprintf+0xae>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    3dc0:	f1a2 0030 	sub.w	r0, r2, #48	; 0x30
    3dc4:	2809      	cmp	r0, #9
    3dc6:	d837      	bhi.n	3e38 <am_util_stdio_vsprintf+0xcc>
    uint32_t ui32Val = 0, uCnt = 0;
    3dc8:	2100      	movs	r1, #0
    bool bNeg = false;
    3dca:	468e      	mov	lr, r1
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    3dcc:	4630      	mov	r0, r6
        bNeg = true;
    3dce:	f04f 0c00 	mov.w	ip, #0
        ui32Val *= 10;
    3dd2:	eb0c 078c 	add.w	r7, ip, ip, lsl #2
        ui32Val += (*pcStr - '0');
    3dd6:	eb02 0a47 	add.w	sl, r2, r7, lsl #1
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    3dda:	f810 2f01 	ldrb.w	r2, [r0, #1]!
    3dde:	f1a2 0430 	sub.w	r4, r2, #48	; 0x30
    3de2:	2c09      	cmp	r4, #9
        ++uCnt;
    3de4:	f101 0101 	add.w	r1, r1, #1
        ui32Val += (*pcStr - '0');
    3de8:	f1aa 0c30 	sub.w	ip, sl, #48	; 0x30
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    3dec:	d9f1      	bls.n	3dd2 <am_util_stdio_vsprintf+0x66>
    3dee:	440e      	add	r6, r1
    return bNeg ? -ui32Val : ui32Val;
    3df0:	f1be 0f00 	cmp.w	lr, #0
    3df4:	f041 80a1 	bne.w	4f3a <am_util_stdio_vsprintf+0x11ce>
    3df8:	4664      	mov	r4, ip
    3dfa:	7832      	ldrb	r2, [r6, #0]
    3dfc:	e01e      	b.n	3e3c <am_util_stdio_vsprintf+0xd0>
                if ( *pcFmt == '\n'  &&  g_bTxtXlate )
    3dfe:	4ebd      	ldr	r6, [pc, #756]	; (40f4 <am_util_stdio_vsprintf+0x388>)
    3e00:	7837      	ldrb	r7, [r6, #0]
    3e02:	2f00      	cmp	r7, #0
    3e04:	d0c2      	beq.n	3d8c <am_util_stdio_vsprintf+0x20>
                    *pcBuf++ = '\r';
    3e06:	f04f 0c0d 	mov.w	ip, #13
    3e0a:	f888 c000 	strb.w	ip, [r8]
    3e0e:	780b      	ldrb	r3, [r1, #0]
                    ++ui32CharCnt;
    3e10:	f109 0901 	add.w	r9, r9, #1
                    *pcBuf++ = '\r';
    3e14:	f108 0801 	add.w	r8, r8, #1
    3e18:	e7b8      	b.n	3d8c <am_util_stdio_vsprintf+0x20>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    3e1a:	7872      	ldrb	r2, [r6, #1]
    3e1c:	f1a2 0430 	sub.w	r4, r2, #48	; 0x30
    3e20:	2c09      	cmp	r4, #9
        pcStr++;
    3e22:	f106 0001 	add.w	r0, r6, #1
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    3e26:	f200 8611 	bhi.w	4a4c <am_util_stdio_vsprintf+0xce0>
        uCnt++;
    3e2a:	2101      	movs	r1, #1
        bNeg = true;
    3e2c:	468e      	mov	lr, r1
    3e2e:	e7ce      	b.n	3dce <am_util_stdio_vsprintf+0x62>
    3e30:	788a      	ldrb	r2, [r1, #2]
            ++pcFmt;
    3e32:	1c8e      	adds	r6, r1, #2
            ui8PadChar = '0';
    3e34:	2530      	movs	r5, #48	; 0x30
    3e36:	e7c1      	b.n	3dbc <am_util_stdio_vsprintf+0x50>
    3e38:	7832      	ldrb	r2, [r6, #0]
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    3e3a:	2400      	movs	r4, #0
        if ( ( *pcFmt != 's' )  &&  ( iWidth < 0 ) )
    3e3c:	2a73      	cmp	r2, #115	; 0x73
    3e3e:	f000 8304 	beq.w	444a <am_util_stdio_vsprintf+0x6de>
    3e42:	ea84 73e4 	eor.w	r3, r4, r4, asr #31
        if (*pcFmt == '.')
    3e46:	2a2e      	cmp	r2, #46	; 0x2e
    3e48:	eba3 77e4 	sub.w	r7, r3, r4, asr #31
    3e4c:	f000 82ae 	beq.w	43ac <am_util_stdio_vsprintf+0x640>
        iPrecision = 6;             // printf() default precision for %f is 6
    3e50:	f04f 0a06 	mov.w	sl, #6
        if ( *pcFmt == 'l' )
    3e54:	2a6c      	cmp	r2, #108	; 0x6c
    3e56:	f000 82a3 	beq.w	43a0 <am_util_stdio_vsprintf+0x634>
        switch ( *pcFmt )
    3e5a:	f1a2 0046 	sub.w	r0, r2, #70	; 0x46
    3e5e:	2832      	cmp	r0, #50	; 0x32
    3e60:	f200 8294 	bhi.w	438c <am_util_stdio_vsprintf+0x620>
    3e64:	e8df f010 	tbh	[pc, r0, lsl #1]
    3e68:	02920115 	.word	0x02920115
    3e6c:	02920292 	.word	0x02920292
    3e70:	02920292 	.word	0x02920292
    3e74:	02920292 	.word	0x02920292
    3e78:	02920292 	.word	0x02920292
    3e7c:	02920292 	.word	0x02920292
    3e80:	02920292 	.word	0x02920292
    3e84:	02920292 	.word	0x02920292
    3e88:	02920292 	.word	0x02920292
    3e8c:	02920033 	.word	0x02920033
    3e90:	02920292 	.word	0x02920292
    3e94:	02920292 	.word	0x02920292
    3e98:	02920292 	.word	0x02920292
    3e9c:	02920292 	.word	0x02920292
    3ea0:	01360292 	.word	0x01360292
    3ea4:	0292014a 	.word	0x0292014a
    3ea8:	02920115 	.word	0x02920115
    3eac:	014a0292 	.word	0x014a0292
    3eb0:	02920292 	.word	0x02920292
    3eb4:	02920292 	.word	0x02920292
    3eb8:	02920292 	.word	0x02920292
    3ebc:	02920292 	.word	0x02920292
    3ec0:	02f00292 	.word	0x02f00292
    3ec4:	01f20292 	.word	0x01f20292
    3ec8:	02920292 	.word	0x02920292
    3ecc:	01ef      	.short	0x01ef
        bLower = bLongLong = false;
    3ece:	f04f 0c00 	mov.w	ip, #0
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    3ed2:	f8db 2000 	ldr.w	r2, [fp]
    3ed6:	2300      	movs	r3, #0
                                      va_arg(pArgs, uint32_t);
    3ed8:	f10b 0b04 	add.w	fp, fp, #4
                if ( iWidth )
    3edc:	2c00      	cmp	r4, #0
    3ede:	d06d      	beq.n	3fbc <am_util_stdio_vsprintf+0x250>
    int iDigits = ui64Val ? 0 : 1;
    3ee0:	ea52 0103 	orrs.w	r1, r2, r3
    3ee4:	bf0c      	ite	eq
    3ee6:	f04f 0e01 	moveq.w	lr, #1
    3eea:	f04f 0e00 	movne.w	lr, #0
    while ( ui64Val )
    3eee:	ea52 0103 	orrs.w	r1, r2, r3
    3ef2:	d00b      	beq.n	3f0c <am_util_stdio_vsprintf+0x1a0>
    3ef4:	4610      	mov	r0, r2
    3ef6:	4619      	mov	r1, r3
        ui64Val >>= 4;
    3ef8:	090c      	lsrs	r4, r1, #4
    3efa:	0900      	lsrs	r0, r0, #4
    3efc:	ea40 7001 	orr.w	r0, r0, r1, lsl #28
    3f00:	4621      	mov	r1, r4
    while ( ui64Val )
    3f02:	ea50 0401 	orrs.w	r4, r0, r1
        ++iDigits;
    3f06:	f10e 0e01 	add.w	lr, lr, #1
    while ( ui64Val )
    3f0a:	d1f5      	bne.n	3ef8 <am_util_stdio_vsprintf+0x18c>
                    iWidth -= ndigits_in_hex(ui64Val);
    3f0c:	eba7 070e 	sub.w	r7, r7, lr
    if ( i32NumChars <= 0 )
    3f10:	2f00      	cmp	r7, #0
    3f12:	f340 855f 	ble.w	49d4 <am_util_stdio_vsprintf+0xc68>
    while ( i32NumChars-- )
    3f16:	f107 3aff 	add.w	sl, r7, #4294967295
        if ( pcBuf )
    3f1a:	f1b8 0f00 	cmp.w	r8, #0
    3f1e:	f000 855a 	beq.w	49d6 <am_util_stdio_vsprintf+0xc6a>
            *pcBuf++ = cPadChar;
    3f22:	4641      	mov	r1, r8
    3f24:	f00a 0707 	and.w	r7, sl, #7
    3f28:	f801 5b01 	strb.w	r5, [r1], #1
    while ( i32NumChars-- )
    3f2c:	f10a 30ff 	add.w	r0, sl, #4294967295
    3f30:	eba1 0408 	sub.w	r4, r1, r8
    3f34:	f1ba 0f00 	cmp.w	sl, #0
    3f38:	d03d      	beq.n	3fb6 <am_util_stdio_vsprintf+0x24a>
    3f3a:	b32f      	cbz	r7, 3f88 <am_util_stdio_vsprintf+0x21c>
    3f3c:	2f01      	cmp	r7, #1
    3f3e:	d01c      	beq.n	3f7a <am_util_stdio_vsprintf+0x20e>
    3f40:	2f02      	cmp	r7, #2
    3f42:	d017      	beq.n	3f74 <am_util_stdio_vsprintf+0x208>
    3f44:	2f03      	cmp	r7, #3
    3f46:	d012      	beq.n	3f6e <am_util_stdio_vsprintf+0x202>
    3f48:	2f04      	cmp	r7, #4
    3f4a:	d00d      	beq.n	3f68 <am_util_stdio_vsprintf+0x1fc>
    3f4c:	2f05      	cmp	r7, #5
    3f4e:	d008      	beq.n	3f62 <am_util_stdio_vsprintf+0x1f6>
    3f50:	2f06      	cmp	r7, #6
            *pcBuf++ = cPadChar;
    3f52:	bf1c      	itt	ne
    3f54:	f801 5b01 	strbne.w	r5, [r1], #1
    while ( i32NumChars-- )
    3f58:	f100 30ff 	addne.w	r0, r0, #4294967295
            *pcBuf++ = cPadChar;
    3f5c:	f801 5b01 	strb.w	r5, [r1], #1
    while ( i32NumChars-- )
    3f60:	3801      	subs	r0, #1
            *pcBuf++ = cPadChar;
    3f62:	f801 5b01 	strb.w	r5, [r1], #1
    while ( i32NumChars-- )
    3f66:	3801      	subs	r0, #1
            *pcBuf++ = cPadChar;
    3f68:	f801 5b01 	strb.w	r5, [r1], #1
    while ( i32NumChars-- )
    3f6c:	3801      	subs	r0, #1
            *pcBuf++ = cPadChar;
    3f6e:	f801 5b01 	strb.w	r5, [r1], #1
    while ( i32NumChars-- )
    3f72:	3801      	subs	r0, #1
            *pcBuf++ = cPadChar;
    3f74:	f801 5b01 	strb.w	r5, [r1], #1
    while ( i32NumChars-- )
    3f78:	3801      	subs	r0, #1
            *pcBuf++ = cPadChar;
    3f7a:	f801 5b01 	strb.w	r5, [r1], #1
    while ( i32NumChars-- )
    3f7e:	3801      	subs	r0, #1
    3f80:	1c47      	adds	r7, r0, #1
    3f82:	eba1 0408 	sub.w	r4, r1, r8
    3f86:	d016      	beq.n	3fb6 <am_util_stdio_vsprintf+0x24a>
            *pcBuf++ = cPadChar;
    3f88:	468a      	mov	sl, r1
    while ( i32NumChars-- )
    3f8a:	3808      	subs	r0, #8
            *pcBuf++ = cPadChar;
    3f8c:	f80a 5b01 	strb.w	r5, [sl], #1
    3f90:	3108      	adds	r1, #8
    3f92:	f88a 5000 	strb.w	r5, [sl]
    3f96:	f801 5c06 	strb.w	r5, [r1, #-6]
    3f9a:	f801 5c05 	strb.w	r5, [r1, #-5]
    3f9e:	f801 5c04 	strb.w	r5, [r1, #-4]
    3fa2:	f801 5c03 	strb.w	r5, [r1, #-3]
    3fa6:	f801 5c02 	strb.w	r5, [r1, #-2]
    while ( i32NumChars-- )
    3faa:	1c47      	adds	r7, r0, #1
    3fac:	eba1 0408 	sub.w	r4, r1, r8
            *pcBuf++ = cPadChar;
    3fb0:	f801 5c01 	strb.w	r5, [r1, #-1]
    while ( i32NumChars-- )
    3fb4:	d1e8      	bne.n	3f88 <am_util_stdio_vsprintf+0x21c>
    3fb6:	4627      	mov	r7, r4
                    pcBuf += pcBuf ? iWidth : 0;
    3fb8:	44a0      	add	r8, r4
                    ui32CharCnt += iWidth;
    3fba:	44b9      	add	r9, r7
    if ( ui64Val == 0 )
    3fbc:	ea52 0103 	orrs.w	r1, r2, r3
    3fc0:	f040 821a 	bne.w	43f8 <am_util_stdio_vsprintf+0x68c>
        tbuf[ix++] = '0';   // Print a '0'
    3fc4:	f04f 0530 	mov.w	r5, #48	; 0x30
    3fc8:	f88d 50ac 	strb.w	r5, [sp, #172]	; 0xac
    if (pcBuf)
    3fcc:	2701      	movs	r7, #1
    3fce:	f1b8 0f00 	cmp.w	r8, #0
    3fd2:	f000 8235 	beq.w	4440 <am_util_stdio_vsprintf+0x6d4>
    3fd6:	4639      	mov	r1, r7
        while (ix--)
    3fd8:	2000      	movs	r0, #0
    3fda:	ac2b      	add	r4, sp, #172	; 0xac
    3fdc:	1863      	adds	r3, r4, r1
    3fde:	f103 3aff 	add.w	sl, r3, #4294967295
            *pcBuf++ = tbuf[ix];
    3fe2:	f813 cc01 	ldrb.w	ip, [r3, #-1]
    3fe6:	f888 c000 	strb.w	ip, [r8]
    3fea:	1e4d      	subs	r5, r1, #1
        while (ix--)
    3fec:	45a2      	cmp	sl, r4
    3fee:	f005 0107 	and.w	r1, r5, #7
    3ff2:	4643      	mov	r3, r8
    3ff4:	d047      	beq.n	4086 <am_util_stdio_vsprintf+0x31a>
    3ff6:	b359      	cbz	r1, 4050 <am_util_stdio_vsprintf+0x2e4>
    3ff8:	2901      	cmp	r1, #1
    3ffa:	d023      	beq.n	4044 <am_util_stdio_vsprintf+0x2d8>
    3ffc:	2902      	cmp	r1, #2
    3ffe:	d01d      	beq.n	403c <am_util_stdio_vsprintf+0x2d0>
    4000:	2903      	cmp	r1, #3
    4002:	d017      	beq.n	4034 <am_util_stdio_vsprintf+0x2c8>
    4004:	2904      	cmp	r1, #4
    4006:	d011      	beq.n	402c <am_util_stdio_vsprintf+0x2c0>
    4008:	2905      	cmp	r1, #5
    400a:	d00b      	beq.n	4024 <am_util_stdio_vsprintf+0x2b8>
    400c:	2906      	cmp	r1, #6
    400e:	d005      	beq.n	401c <am_util_stdio_vsprintf+0x2b0>
            *pcBuf++ = tbuf[ix];
    4010:	f81a 2d01 	ldrb.w	r2, [sl, #-1]!
    4014:	f888 2001 	strb.w	r2, [r8, #1]
    4018:	f108 0301 	add.w	r3, r8, #1
    401c:	f81a 5d01 	ldrb.w	r5, [sl, #-1]!
    4020:	f803 5f01 	strb.w	r5, [r3, #1]!
    4024:	f81a cd01 	ldrb.w	ip, [sl, #-1]!
    4028:	f803 cf01 	strb.w	ip, [r3, #1]!
    402c:	f81a 1d01 	ldrb.w	r1, [sl, #-1]!
    4030:	f803 1f01 	strb.w	r1, [r3, #1]!
    4034:	f81a 2d01 	ldrb.w	r2, [sl, #-1]!
    4038:	f803 2f01 	strb.w	r2, [r3, #1]!
    403c:	f81a 5d01 	ldrb.w	r5, [sl, #-1]!
    4040:	f803 5f01 	strb.w	r5, [r3, #1]!
    4044:	f81a cd01 	ldrb.w	ip, [sl, #-1]!
    4048:	f803 cf01 	strb.w	ip, [r3, #1]!
        while (ix--)
    404c:	45a2      	cmp	sl, r4
    404e:	d01a      	beq.n	4086 <am_util_stdio_vsprintf+0x31a>
            *pcBuf++ = tbuf[ix];
    4050:	f81a 2c01 	ldrb.w	r2, [sl, #-1]
    4054:	f81a 5c03 	ldrb.w	r5, [sl, #-3]
    4058:	f81a 1c02 	ldrb.w	r1, [sl, #-2]
    405c:	705a      	strb	r2, [r3, #1]
    405e:	70dd      	strb	r5, [r3, #3]
    4060:	f81a 2c04 	ldrb.w	r2, [sl, #-4]
    4064:	f81a 5c05 	ldrb.w	r5, [sl, #-5]
    4068:	7099      	strb	r1, [r3, #2]
    406a:	711a      	strb	r2, [r3, #4]
    406c:	f81a 1c06 	ldrb.w	r1, [sl, #-6]
    4070:	715d      	strb	r5, [r3, #5]
    4072:	f81a 2c07 	ldrb.w	r2, [sl, #-7]
    4076:	f81a 5d08 	ldrb.w	r5, [sl, #-8]!
    407a:	7199      	strb	r1, [r3, #6]
        while (ix--)
    407c:	45a2      	cmp	sl, r4
            *pcBuf++ = tbuf[ix];
    407e:	71da      	strb	r2, [r3, #7]
    4080:	f803 5f08 	strb.w	r5, [r3, #8]!
        while (ix--)
    4084:	d1e4      	bne.n	4050 <am_util_stdio_vsprintf+0x2e4>
        *pcBuf = 0;
    4086:	4440      	add	r0, r8
    4088:	2400      	movs	r4, #0
                    pcBuf += iVal;
    408a:	44b8      	add	r8, r7
        *pcBuf = 0;
    408c:	7044      	strb	r4, [r0, #1]
                ui32CharCnt += iVal;
    408e:	44b9      	add	r9, r7
                break;
    4090:	e01e      	b.n	40d0 <am_util_stdio_vsprintf+0x364>
                if ( pcBuf )
    4092:	f1b8 0f00 	cmp.w	r8, #0
    4096:	d01b      	beq.n	40d0 <am_util_stdio_vsprintf+0x364>
                    float fValue = va_arg(pArgs, double);
    4098:	f10b 0307 	add.w	r3, fp, #7
    409c:	f023 0b07 	bic.w	fp, r3, #7
    40a0:	e9db 0100 	ldrd	r0, r1, [fp]
    40a4:	f7fc fc5e 	bl	964 <__aeabi_d2f>
    40a8:	ee07 0a90 	vmov	s15, r0
    if (fValue == 0.0f)
    40ac:	eef5 7a40 	vcmp.f32	s15, #0.0
                    *(uint32_t*)pcBuf = 20;
    40b0:	2014      	movs	r0, #20
    if (fValue == 0.0f)
    40b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                    float fValue = va_arg(pArgs, double);
    40b6:	f10b 0b08 	add.w	fp, fp, #8
                    *(uint32_t*)pcBuf = 20;
    40ba:	f8c8 0000 	str.w	r0, [r8]
    if (fValue == 0.0f)
    40be:	f040 848d 	bne.w	49dc <am_util_stdio_vsprintf+0xc70>
        *(uint32_t*)pcBuf = 0x00 << 24 | ('0' << 16) | ('.' << 8) | ('0' << 0);
    40c2:	490d      	ldr	r1, [pc, #52]	; (40f8 <am_util_stdio_vsprintf+0x38c>)
    40c4:	f8c8 1000 	str.w	r1, [r8]
    40c8:	f04f 0a03 	mov.w	sl, #3
                    ui32CharCnt += iVal;
    40cc:	44d1      	add	r9, sl
                    pcBuf += iVal;
    40ce:	44d0      	add	r8, sl
        ++pcFmt;
    40d0:	1c71      	adds	r1, r6, #1
    40d2:	e652      	b.n	3d7a <am_util_stdio_vsprintf+0xe>
                ui8CharSpecifier = va_arg(pArgs, uint32_t);
    40d4:	f10b 0404 	add.w	r4, fp, #4
    40d8:	f89b 1000 	ldrb.w	r1, [fp]
                if ( pcBuf )
    40dc:	f1b8 0f00 	cmp.w	r8, #0
    40e0:	d003      	beq.n	40ea <am_util_stdio_vsprintf+0x37e>
                    *pcBuf++ = ui8CharSpecifier;
    40e2:	f888 1000 	strb.w	r1, [r8]
    40e6:	f108 0801 	add.w	r8, r8, #1
                ++ui32CharCnt;
    40ea:	f109 0901 	add.w	r9, r9, #1
                ui8CharSpecifier = va_arg(pArgs, uint32_t);
    40ee:	46a3      	mov	fp, r4
                break;
    40f0:	e7ee      	b.n	40d0 <am_util_stdio_vsprintf+0x364>
    40f2:	bf00      	nop
    40f4:	10001064 	.word	0x10001064
    40f8:	00302e30 	.word	0x00302e30
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
    40fc:	f8db 0000 	ldr.w	r0, [fp]
                                     va_arg(pArgs, int32_t);
    4100:	f10b 0b04 	add.w	fp, fp, #4
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
    4104:	17c1      	asrs	r1, r0, #31
                if ( i64Val < 0 )
    4106:	2800      	cmp	r0, #0
    4108:	f171 0300 	sbcs.w	r3, r1, #0
    410c:	f2c0 83ac 	blt.w	4868 <am_util_stdio_vsprintf+0xafc>
                    ui64Val = i64Val;
    4110:	e9cd 0118 	strd	r0, r1, [sp, #96]	; 0x60
                if ( iWidth )
    4114:	2c00      	cmp	r4, #0
    4116:	f000 83ba 	beq.w	488e <am_util_stdio_vsprintf+0xb22>
    int iNDigits = ui64Val ? 0 : 1;
    411a:	ea50 0301 	orrs.w	r3, r0, r1
    return ndigits_in_u64((uint64_t) i64Val);
    411e:	4602      	mov	r2, r0
    int iNDigits = ui64Val ? 0 : 1;
    4120:	bf0c      	ite	eq
    4122:	2401      	moveq	r4, #1
    4124:	2400      	movne	r4, #0
    while ( ui64Val )
    4126:	4308      	orrs	r0, r1
    return ndigits_in_u64((uint64_t) i64Val);
    4128:	460b      	mov	r3, r1
                    bNeg = false;
    412a:	bf18      	it	ne
    412c:	2000      	movne	r0, #0
    while ( ui64Val )
    412e:	f000 86ba 	beq.w	4ea6 <am_util_stdio_vsprintf+0x113a>
                    bNeg = false;
    4132:	901b      	str	r0, [sp, #108]	; 0x6c
    4134:	9620      	str	r6, [sp, #128]	; 0x80
    4136:	9521      	str	r5, [sp, #132]	; 0x84
    4138:	9722      	str	r7, [sp, #136]	; 0x88
    413a:	941a      	str	r4, [sp, #104]	; 0x68
    413c:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
    4140:	f8cd 9090 	str.w	r9, [sp, #144]	; 0x90
    4144:	f8cd 8094 	str.w	r8, [sp, #148]	; 0x94
    4148:	e009      	b.n	415e <am_util_stdio_vsprintf+0x3f2>
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    414a:	464a      	mov	r2, r9
    414c:	2300      	movs	r3, #0
        ++iNDigits;
    414e:	9d1a      	ldr	r5, [sp, #104]	; 0x68
    while ( ui64Val )
    4150:	ea52 0103 	orrs.w	r1, r2, r3
        ++iNDigits;
    4154:	f105 0501 	add.w	r5, r5, #1
    4158:	951a      	str	r5, [sp, #104]	; 0x68
    while ( ui64Val )
    415a:	f000 83a5 	beq.w	48a8 <am_util_stdio_vsprintf+0xb3c>
        q64 = (ui64Val>>1) + (ui64Val>>2);
    415e:	0896      	lsrs	r6, r2, #2
    4160:	ea46 7583 	orr.w	r5, r6, r3, lsl #30
    4164:	089f      	lsrs	r7, r3, #2
    4166:	970b      	str	r7, [sp, #44]	; 0x2c
    4168:	950a      	str	r5, [sp, #40]	; 0x28
    416a:	e9dd 450a 	ldrd	r4, r5, [sp, #40]	; 0x28
    416e:	0859      	lsrs	r1, r3, #1
    4170:	ea4f 0032 	mov.w	r0, r2, rrx
    4174:	1820      	adds	r0, r4, r0
    4176:	eb45 0101 	adc.w	r1, r5, r1
        q64 += (q64 >> 4);
    417a:	0904      	lsrs	r4, r0, #4
        q64 = (ui64Val>>1) + (ui64Val>>2);
    417c:	4606      	mov	r6, r0
        q64 += (q64 >> 4);
    417e:	ea44 7501 	orr.w	r5, r4, r1, lsl #28
    4182:	0908      	lsrs	r0, r1, #4
    4184:	9005      	str	r0, [sp, #20]
    4186:	9504      	str	r5, [sp, #16]
    4188:	e9dd 4504 	ldrd	r4, r5, [sp, #16]
    418c:	19a0      	adds	r0, r4, r6
    418e:	eb45 0101 	adc.w	r1, r5, r1
        q64 += (q64 >> 8);
    4192:	0a04      	lsrs	r4, r0, #8
        q64 += (q64 >> 4);
    4194:	4606      	mov	r6, r0
        q64 += (q64 >> 8);
    4196:	ea44 6501 	orr.w	r5, r4, r1, lsl #24
    419a:	0a08      	lsrs	r0, r1, #8
    419c:	9007      	str	r0, [sp, #28]
    419e:	9506      	str	r5, [sp, #24]
    41a0:	e9dd 4506 	ldrd	r4, r5, [sp, #24]
    41a4:	19a0      	adds	r0, r4, r6
    41a6:	eb45 0101 	adc.w	r1, r5, r1
        q64 += (q64 >> 16);
    41aa:	0c06      	lsrs	r6, r0, #16
    41ac:	ea46 4a01 	orr.w	sl, r6, r1, lsl #16
    41b0:	eb10 070a 	adds.w	r7, r0, sl
    41b4:	ea4f 4b11 	mov.w	fp, r1, lsr #16
    41b8:	eb41 000b 	adc.w	r0, r1, fp
        q64 += (q64 >> 32);
    41bc:	2400      	movs	r4, #0
    41be:	900e      	str	r0, [sp, #56]	; 0x38
    41c0:	940f      	str	r4, [sp, #60]	; 0x3c
    41c2:	e9dd 890e 	ldrd	r8, r9, [sp, #56]	; 0x38
        q32 = (ui32Val>>1) + (ui32Val>>2);
    41c6:	0895      	lsrs	r5, r2, #2
        q64 += (q64 >> 32);
    41c8:	eb18 0807 	adds.w	r8, r8, r7
    41cc:	eb49 0100 	adc.w	r1, r9, r0
        q32 = (ui32Val>>1) + (ui32Val>>2);
    41d0:	eb05 0c52 	add.w	ip, r5, r2, lsr #1
        q64 += (q64 >> 32);
    41d4:	4646      	mov	r6, r8
        q32 += (q32 >> 4);
    41d6:	eb0c 101c 	add.w	r0, ip, ip, lsr #4
        q64 += (q64 >> 32);
    41da:	460f      	mov	r7, r1
        q32 += (q32 >> 8);
    41dc:	eb00 2510 	add.w	r5, r0, r0, lsr #8
        q64 >>= 3;
    41e0:	08f4      	lsrs	r4, r6, #3
    if ( ui64Val >> 32 )
    41e2:	9312      	str	r3, [sp, #72]	; 0x48
    41e4:	f8cd 904c 	str.w	r9, [sp, #76]	; 0x4c
        q64 >>= 3;
    41e8:	08ff      	lsrs	r7, r7, #3
    41ea:	ea44 7641 	orr.w	r6, r4, r1, lsl #29
    41ee:	e9dd 8912 	ldrd	r8, r9, [sp, #72]	; 0x48
        q32 += (q32 >> 16);
    41f2:	eb05 4415 	add.w	r4, r5, r5, lsr #16
        r64 = ui64Val - q64*10;
    41f6:	00bd      	lsls	r5, r7, #2
    41f8:	ea45 7196 	orr.w	r1, r5, r6, lsr #30
        q32 >>= 3;
    41fc:	08e5      	lsrs	r5, r4, #3
        r32 = ui32Val - q32*10;
    41fe:	eb05 0485 	add.w	r4, r5, r5, lsl #2
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    4202:	f102 0e06 	add.w	lr, r2, #6
    4206:	ebae 0c44 	sub.w	ip, lr, r4, lsl #1
    420a:	ea58 0409 	orrs.w	r4, r8, r9
        r64 = ui64Val - q64*10;
    420e:	ea4f 0086 	mov.w	r0, r6, lsl #2
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    4212:	eb05 191c 	add.w	r9, r5, ip, lsr #4
    4216:	d098      	beq.n	414a <am_util_stdio_vsprintf+0x3de>
        r64 = ui64Val - q64*10;
    4218:	eb10 0e06 	adds.w	lr, r0, r6
    421c:	4179      	adcs	r1, r7
    421e:	eb1e 000e 	adds.w	r0, lr, lr
    4222:	4149      	adcs	r1, r1
        return q64 + ((r64 + 6) >> 4);
    4224:	3206      	adds	r2, #6
    4226:	f143 0300 	adc.w	r3, r3, #0
    422a:	1a15      	subs	r5, r2, r0
    422c:	eb63 0401 	sbc.w	r4, r3, r1
    4230:	0929      	lsrs	r1, r5, #4
    4232:	0922      	lsrs	r2, r4, #4
    4234:	ea41 7004 	orr.w	r0, r1, r4, lsl #28
    4238:	9016      	str	r0, [sp, #88]	; 0x58
    423a:	9217      	str	r2, [sp, #92]	; 0x5c
    423c:	e9dd 2316 	ldrd	r2, r3, [sp, #88]	; 0x58
    4240:	1992      	adds	r2, r2, r6
    4242:	417b      	adcs	r3, r7
    4244:	e783      	b.n	414e <am_util_stdio_vsprintf+0x3e2>
        switch ( *pcFmt )
    4246:	f04f 0c01 	mov.w	ip, #1
    424a:	e642      	b.n	3ed2 <am_util_stdio_vsprintf+0x166>
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    424c:	f8db 1000 	ldr.w	r1, [fp]
    4250:	2200      	movs	r2, #0
    4252:	e9cd 1218 	strd	r1, r2, [sp, #96]	; 0x60
                                      va_arg(pArgs, uint32_t);
    4256:	f10b 0b04 	add.w	fp, fp, #4
                if ( iWidth )
    425a:	2c00      	cmp	r4, #0
    425c:	f000 8269 	beq.w	4732 <am_util_stdio_vsprintf+0x9c6>
    int iNDigits = ui64Val ? 0 : 1;
    4260:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
    4264:	ea50 0301 	orrs.w	r3, r0, r1
    while ( ui64Val )
    4268:	4602      	mov	r2, r0
    426a:	460b      	mov	r3, r1
    int iNDigits = ui64Val ? 0 : 1;
    426c:	bf0c      	ite	eq
    426e:	2401      	moveq	r4, #1
    4270:	2400      	movne	r4, #0
    while ( ui64Val )
    4272:	ea52 0103 	orrs.w	r1, r2, r3
    4276:	f000 81fe 	beq.w	4676 <am_util_stdio_vsprintf+0x90a>
    427a:	961b      	str	r6, [sp, #108]	; 0x6c
    427c:	9520      	str	r5, [sp, #128]	; 0x80
    427e:	9721      	str	r7, [sp, #132]	; 0x84
    4280:	941a      	str	r4, [sp, #104]	; 0x68
    4282:	f8cd b088 	str.w	fp, [sp, #136]	; 0x88
    4286:	f8cd 908c 	str.w	r9, [sp, #140]	; 0x8c
    428a:	f8cd 8090 	str.w	r8, [sp, #144]	; 0x90
    428e:	e009      	b.n	42a4 <am_util_stdio_vsprintf+0x538>
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    4290:	464a      	mov	r2, r9
    4292:	2300      	movs	r3, #0
        ++iNDigits;
    4294:	9d1a      	ldr	r5, [sp, #104]	; 0x68
    while ( ui64Val )
    4296:	ea52 0103 	orrs.w	r1, r2, r3
        ++iNDigits;
    429a:	f105 0501 	add.w	r5, r5, #1
    429e:	951a      	str	r5, [sp, #104]	; 0x68
    while ( ui64Val )
    42a0:	f000 81db 	beq.w	465a <am_util_stdio_vsprintf+0x8ee>
        q64 = (ui64Val>>1) + (ui64Val>>2);
    42a4:	0895      	lsrs	r5, r2, #2
    42a6:	ea45 7783 	orr.w	r7, r5, r3, lsl #30
    42aa:	089c      	lsrs	r4, r3, #2
    42ac:	9708      	str	r7, [sp, #32]
    42ae:	9409      	str	r4, [sp, #36]	; 0x24
    42b0:	e9dd 4508 	ldrd	r4, r5, [sp, #32]
    42b4:	0859      	lsrs	r1, r3, #1
    42b6:	ea4f 0032 	mov.w	r0, r2, rrx
    42ba:	1820      	adds	r0, r4, r0
    42bc:	eb45 0101 	adc.w	r1, r5, r1
        q64 += (q64 >> 4);
    42c0:	0905      	lsrs	r5, r0, #4
        q64 = (ui64Val>>1) + (ui64Val>>2);
    42c2:	4606      	mov	r6, r0
        q64 += (q64 >> 4);
    42c4:	ea45 7401 	orr.w	r4, r5, r1, lsl #28
    42c8:	0908      	lsrs	r0, r1, #4
    42ca:	9001      	str	r0, [sp, #4]
    42cc:	9400      	str	r4, [sp, #0]
    42ce:	e9dd 4500 	ldrd	r4, r5, [sp]
    42d2:	19a0      	adds	r0, r4, r6
    42d4:	eb45 0101 	adc.w	r1, r5, r1
        q64 += (q64 >> 8);
    42d8:	0a05      	lsrs	r5, r0, #8
        q64 += (q64 >> 4);
    42da:	4606      	mov	r6, r0
        q64 += (q64 >> 8);
    42dc:	ea45 6401 	orr.w	r4, r5, r1, lsl #24
    42e0:	0a08      	lsrs	r0, r1, #8
    42e2:	9003      	str	r0, [sp, #12]
    42e4:	9402      	str	r4, [sp, #8]
    42e6:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
    42ea:	19a0      	adds	r0, r4, r6
    42ec:	eb45 0101 	adc.w	r1, r5, r1
        q64 += (q64 >> 16);
    42f0:	0c06      	lsrs	r6, r0, #16
    42f2:	ea46 4a01 	orr.w	sl, r6, r1, lsl #16
    42f6:	eb10 070a 	adds.w	r7, r0, sl
    42fa:	ea4f 4b11 	mov.w	fp, r1, lsr #16
    42fe:	eb41 000b 	adc.w	r0, r1, fp
        q64 += (q64 >> 32);
    4302:	2400      	movs	r4, #0
    4304:	900c      	str	r0, [sp, #48]	; 0x30
    4306:	940d      	str	r4, [sp, #52]	; 0x34
    4308:	e9dd 890c 	ldrd	r8, r9, [sp, #48]	; 0x30
        q32 = (ui32Val>>1) + (ui32Val>>2);
    430c:	0895      	lsrs	r5, r2, #2
        q64 += (q64 >> 32);
    430e:	eb18 0807 	adds.w	r8, r8, r7
    4312:	eb49 0100 	adc.w	r1, r9, r0
        q32 = (ui32Val>>1) + (ui32Val>>2);
    4316:	eb05 0c52 	add.w	ip, r5, r2, lsr #1
        q64 += (q64 >> 32);
    431a:	4646      	mov	r6, r8
        q32 += (q32 >> 4);
    431c:	eb0c 101c 	add.w	r0, ip, ip, lsr #4
        q64 += (q64 >> 32);
    4320:	460f      	mov	r7, r1
        q32 += (q32 >> 8);
    4322:	eb00 2510 	add.w	r5, r0, r0, lsr #8
        q64 >>= 3;
    4326:	08f4      	lsrs	r4, r6, #3
    if ( ui64Val >> 32 )
    4328:	9310      	str	r3, [sp, #64]	; 0x40
    432a:	f8cd 9044 	str.w	r9, [sp, #68]	; 0x44
        q64 >>= 3;
    432e:	08ff      	lsrs	r7, r7, #3
    4330:	ea44 7641 	orr.w	r6, r4, r1, lsl #29
    4334:	e9dd 8910 	ldrd	r8, r9, [sp, #64]	; 0x40
        q32 += (q32 >> 16);
    4338:	eb05 4415 	add.w	r4, r5, r5, lsr #16
        r64 = ui64Val - q64*10;
    433c:	00bd      	lsls	r5, r7, #2
    433e:	ea45 7196 	orr.w	r1, r5, r6, lsr #30
        q32 >>= 3;
    4342:	08e5      	lsrs	r5, r4, #3
        r32 = ui32Val - q32*10;
    4344:	eb05 0485 	add.w	r4, r5, r5, lsl #2
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    4348:	f102 0e06 	add.w	lr, r2, #6
    434c:	ebae 0c44 	sub.w	ip, lr, r4, lsl #1
    4350:	ea58 0409 	orrs.w	r4, r8, r9
        r64 = ui64Val - q64*10;
    4354:	ea4f 0086 	mov.w	r0, r6, lsl #2
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    4358:	eb05 191c 	add.w	r9, r5, ip, lsr #4
    435c:	d098      	beq.n	4290 <am_util_stdio_vsprintf+0x524>
        r64 = ui64Val - q64*10;
    435e:	eb10 0e06 	adds.w	lr, r0, r6
    4362:	4179      	adcs	r1, r7
    4364:	eb1e 000e 	adds.w	r0, lr, lr
    4368:	4149      	adcs	r1, r1
        return q64 + ((r64 + 6) >> 4);
    436a:	3206      	adds	r2, #6
    436c:	f143 0300 	adc.w	r3, r3, #0
    4370:	1a15      	subs	r5, r2, r0
    4372:	eb63 0401 	sbc.w	r4, r3, r1
    4376:	0929      	lsrs	r1, r5, #4
    4378:	0922      	lsrs	r2, r4, #4
    437a:	ea41 7004 	orr.w	r0, r1, r4, lsl #28
    437e:	9014      	str	r0, [sp, #80]	; 0x50
    4380:	9215      	str	r2, [sp, #84]	; 0x54
    4382:	e9dd 2314 	ldrd	r2, r3, [sp, #80]	; 0x50
    4386:	1992      	adds	r2, r2, r6
    4388:	417b      	adcs	r3, r7
    438a:	e783      	b.n	4294 <am_util_stdio_vsprintf+0x528>
                if ( pcBuf )
    438c:	f1b8 0f00 	cmp.w	r8, #0
    4390:	d003      	beq.n	439a <am_util_stdio_vsprintf+0x62e>
                    *pcBuf++ = *pcFmt;
    4392:	f888 2000 	strb.w	r2, [r8]
    4396:	f108 0801 	add.w	r8, r8, #1
                ++ui32CharCnt;
    439a:	f109 0901 	add.w	r9, r9, #1
                break;
    439e:	e697      	b.n	40d0 <am_util_stdio_vsprintf+0x364>
            if ( *pcFmt == 'l' )    // "ll" (long long)
    43a0:	7872      	ldrb	r2, [r6, #1]
    43a2:	2a6c      	cmp	r2, #108	; 0x6c
    43a4:	f000 81db 	beq.w	475e <am_util_stdio_vsprintf+0x9f2>
            pcFmt++;
    43a8:	3601      	adds	r6, #1
    43aa:	e556      	b.n	3e5a <am_util_stdio_vsprintf+0xee>
    if ( *pcStr == '-')
    43ac:	7873      	ldrb	r3, [r6, #1]
    43ae:	2b2d      	cmp	r3, #45	; 0x2d
            ++pcFmt;
    43b0:	f106 0001 	add.w	r0, r6, #1
    if ( *pcStr == '-')
    43b4:	f000 81c8 	beq.w	4748 <am_util_stdio_vsprintf+0x9dc>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    43b8:	f1a3 0630 	sub.w	r6, r3, #48	; 0x30
    43bc:	2e09      	cmp	r6, #9
    43be:	f200 8349 	bhi.w	4a54 <am_util_stdio_vsprintf+0xce8>
    uint32_t ui32Val = 0, uCnt = 0;
    43c2:	2200      	movs	r2, #0
    bool bNeg = false;
    43c4:	4694      	mov	ip, r2
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    43c6:	4606      	mov	r6, r0
    bool bNeg = false;
    43c8:	f04f 0a00 	mov.w	sl, #0
        ui32Val *= 10;
    43cc:	eb0a 018a 	add.w	r1, sl, sl, lsl #2
        ui32Val += (*pcStr - '0');
    43d0:	eb03 0141 	add.w	r1, r3, r1, lsl #1
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    43d4:	f816 3f01 	ldrb.w	r3, [r6, #1]!
    43d8:	f1a3 0e30 	sub.w	lr, r3, #48	; 0x30
    43dc:	f1be 0f09 	cmp.w	lr, #9
        ++uCnt;
    43e0:	f102 0201 	add.w	r2, r2, #1
        ui32Val += (*pcStr - '0');
    43e4:	f1a1 0a30 	sub.w	sl, r1, #48	; 0x30
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    43e8:	d9f0      	bls.n	43cc <am_util_stdio_vsprintf+0x660>
    return bNeg ? -ui32Val : ui32Val;
    43ea:	f1bc 0f00 	cmp.w	ip, #0
    43ee:	f000 8334 	beq.w	4a5a <am_util_stdio_vsprintf+0xcee>
    43f2:	f1c1 0a30 	rsb	sl, r1, #48	; 0x30
    43f6:	e330      	b.n	4a5a <am_util_stdio_vsprintf+0xcee>
    43f8:	f1bc 0f00 	cmp.w	ip, #0
    43fc:	bf14      	ite	ne
    43fe:	2727      	movne	r7, #39	; 0x27
    4400:	2707      	moveq	r7, #7
    4402:	f10d 04ab 	add.w	r4, sp, #171	; 0xab
    if ( ui64Val == 0 )
    4406:	2000      	movs	r0, #0
    4408:	e000      	b.n	440c <am_util_stdio_vsprintf+0x6a0>
        tbuf[ix++] = cCh + '0';
    440a:	4608      	mov	r0, r1
        cCh = ui64Val & 0xf;
    440c:	f002 010f 	and.w	r1, r2, #15
            cCh += bLower ? 0x27 : 0x7;
    4410:	eb01 0e07 	add.w	lr, r1, r7
        tbuf[ix++] = cCh + '0';
    4414:	2909      	cmp	r1, #9
    4416:	bf88      	it	hi
    4418:	4671      	movhi	r1, lr
        ui64Val >>= 4;
    441a:	0912      	lsrs	r2, r2, #4
    441c:	ea4f 1e13 	mov.w	lr, r3, lsr #4
    4420:	ea42 7203 	orr.w	r2, r2, r3, lsl #28
    4424:	4673      	mov	r3, lr
        tbuf[ix++] = cCh + '0';
    4426:	3130      	adds	r1, #48	; 0x30
    while ( ui64Val )
    4428:	ea52 0503 	orrs.w	r5, r2, r3
        tbuf[ix++] = cCh + '0';
    442c:	f804 1f01 	strb.w	r1, [r4, #1]!
    4430:	f100 0101 	add.w	r1, r0, #1
    while ( ui64Val )
    4434:	d1e9      	bne.n	440a <am_util_stdio_vsprintf+0x69e>
    4436:	460f      	mov	r7, r1
    if (pcBuf)
    4438:	f1b8 0f00 	cmp.w	r8, #0
    443c:	f47f adcd 	bne.w	3fda <am_util_stdio_vsprintf+0x26e>
    4440:	f04f 0800 	mov.w	r8, #0
                ui32CharCnt += iVal;
    4444:	44b9      	add	r9, r7
    4446:	e643      	b.n	40d0 <am_util_stdio_vsprintf+0x364>
        switch ( *pcFmt )
    4448:	463c      	mov	r4, r7
                pcStr = va_arg(pArgs, char *);
    444a:	f8db 0000 	ldr.w	r0, [fp]
    444e:	f10b 0b04 	add.w	fp, fp, #4
    if ( !pcBuf )
    4452:	2800      	cmp	r0, #0
    4454:	f000 8085 	beq.w	4562 <am_util_stdio_vsprintf+0x7f6>
    while ( *pcBuf++ )
    4458:	7801      	ldrb	r1, [r0, #0]
    445a:	1c42      	adds	r2, r0, #1
    445c:	4613      	mov	r3, r2
    445e:	2900      	cmp	r1, #0
    4460:	f000 84f3 	beq.w	4e4a <am_util_stdio_vsprintf+0x10de>
    4464:	eba3 0e00 	sub.w	lr, r3, r0
    4468:	f813 7b01 	ldrb.w	r7, [r3], #1
    446c:	2f00      	cmp	r7, #0
    446e:	d1f9      	bne.n	4464 <am_util_stdio_vsprintf+0x6f8>
                if ( iWidth > 0 )
    4470:	2c00      	cmp	r4, #0
    4472:	4677      	mov	r7, lr
    4474:	dd01      	ble.n	447a <am_util_stdio_vsprintf+0x70e>
                    if ( ui32strlen < iWidth )
    4476:	4574      	cmp	r4, lr
    4478:	d877      	bhi.n	456a <am_util_stdio_vsprintf+0x7fe>
                    if ( pcBuf )
    447a:	f1b8 0f00 	cmp.w	r8, #0
    447e:	f000 80e1 	beq.w	4644 <am_util_stdio_vsprintf+0x8d8>
    4482:	eba9 0a00 	sub.w	sl, r9, r0
                        *pcBuf++ = *pcStr;
    4486:	f808 1b01 	strb.w	r1, [r8], #1
    448a:	eb0a 0902 	add.w	r9, sl, r2
                while (*pcStr != 0x0)
    448e:	f812 1b01 	ldrb.w	r1, [r2], #1
    4492:	2900      	cmp	r1, #0
    4494:	d1f7      	bne.n	4486 <am_util_stdio_vsprintf+0x71a>
                if ( iWidth )
    4496:	2c00      	cmp	r4, #0
    4498:	f43f ae1a 	beq.w	40d0 <am_util_stdio_vsprintf+0x364>
                    iWidth = -iWidth;
    449c:	4263      	negs	r3, r4
                    if ( ui32strlen < iWidth )
    449e:	42bb      	cmp	r3, r7
    44a0:	f67f ae16 	bls.w	40d0 <am_util_stdio_vsprintf+0x364>
                        iWidth -= ui32strlen;
    44a4:	1bda      	subs	r2, r3, r7
    if ( i32NumChars <= 0 )
    44a6:	2a00      	cmp	r2, #0
    44a8:	f340 84c3 	ble.w	4e32 <am_util_stdio_vsprintf+0x10c6>
    while ( i32NumChars-- )
    44ac:	1e57      	subs	r7, r2, #1
        if ( pcBuf )
    44ae:	f1b8 0f00 	cmp.w	r8, #0
    44b2:	f000 84bf 	beq.w	4e34 <am_util_stdio_vsprintf+0x10c8>
            *pcBuf++ = cPadChar;
    44b6:	4643      	mov	r3, r8
    44b8:	f007 0407 	and.w	r4, r7, #7
    44bc:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
    44c0:	f107 3cff 	add.w	ip, r7, #4294967295
    44c4:	eba3 0108 	sub.w	r1, r3, r8
    44c8:	2f00      	cmp	r7, #0
    44ca:	d045      	beq.n	4558 <am_util_stdio_vsprintf+0x7ec>
    44cc:	b364      	cbz	r4, 4528 <am_util_stdio_vsprintf+0x7bc>
    44ce:	2c01      	cmp	r4, #1
    44d0:	d021      	beq.n	4516 <am_util_stdio_vsprintf+0x7aa>
    44d2:	2c02      	cmp	r4, #2
    44d4:	d01b      	beq.n	450e <am_util_stdio_vsprintf+0x7a2>
    44d6:	2c03      	cmp	r4, #3
    44d8:	d015      	beq.n	4506 <am_util_stdio_vsprintf+0x79a>
    44da:	2c04      	cmp	r4, #4
    44dc:	d00f      	beq.n	44fe <am_util_stdio_vsprintf+0x792>
    44de:	2c05      	cmp	r4, #5
    44e0:	d009      	beq.n	44f6 <am_util_stdio_vsprintf+0x78a>
    44e2:	2c06      	cmp	r4, #6
            *pcBuf++ = cPadChar;
    44e4:	bf1c      	itt	ne
    44e6:	f803 5b01 	strbne.w	r5, [r3], #1
    while ( i32NumChars-- )
    44ea:	f10c 3cff 	addne.w	ip, ip, #4294967295
            *pcBuf++ = cPadChar;
    44ee:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
    44f2:	f10c 3cff 	add.w	ip, ip, #4294967295
            *pcBuf++ = cPadChar;
    44f6:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
    44fa:	f10c 3cff 	add.w	ip, ip, #4294967295
            *pcBuf++ = cPadChar;
    44fe:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
    4502:	f10c 3cff 	add.w	ip, ip, #4294967295
            *pcBuf++ = cPadChar;
    4506:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
    450a:	f10c 3cff 	add.w	ip, ip, #4294967295
            *pcBuf++ = cPadChar;
    450e:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
    4512:	f10c 3cff 	add.w	ip, ip, #4294967295
            *pcBuf++ = cPadChar;
    4516:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
    451a:	f10c 3cff 	add.w	ip, ip, #4294967295
    451e:	f11c 0701 	adds.w	r7, ip, #1
    4522:	eba3 0108 	sub.w	r1, r3, r8
    4526:	d017      	beq.n	4558 <am_util_stdio_vsprintf+0x7ec>
            *pcBuf++ = cPadChar;
    4528:	4618      	mov	r0, r3
    while ( i32NumChars-- )
    452a:	f1ac 0c08 	sub.w	ip, ip, #8
            *pcBuf++ = cPadChar;
    452e:	f800 5b01 	strb.w	r5, [r0], #1
    4532:	3308      	adds	r3, #8
    4534:	7005      	strb	r5, [r0, #0]
    4536:	f803 5c06 	strb.w	r5, [r3, #-6]
    453a:	f803 5c05 	strb.w	r5, [r3, #-5]
    453e:	f803 5c04 	strb.w	r5, [r3, #-4]
    4542:	f803 5c03 	strb.w	r5, [r3, #-3]
    4546:	f803 5c02 	strb.w	r5, [r3, #-2]
    while ( i32NumChars-- )
    454a:	f11c 0001 	adds.w	r0, ip, #1
    454e:	eba3 0108 	sub.w	r1, r3, r8
            *pcBuf++ = cPadChar;
    4552:	f803 5c01 	strb.w	r5, [r3, #-1]
    while ( i32NumChars-- )
    4556:	d1e7      	bne.n	4528 <am_util_stdio_vsprintf+0x7bc>
    4558:	460d      	mov	r5, r1
    455a:	460a      	mov	r2, r1
                        pcBuf += pcBuf ? iWidth : 0;
    455c:	44a8      	add	r8, r5
                        ui32CharCnt += iWidth;
    455e:	4491      	add	r9, r2
    4560:	e5b6      	b.n	40d0 <am_util_stdio_vsprintf+0x364>
                if ( iWidth > 0 )
    4562:	2c00      	cmp	r4, #0
    4564:	f340 8443 	ble.w	4dee <am_util_stdio_vsprintf+0x1082>
        return ui32RetVal;
    4568:	4607      	mov	r7, r0
                        iWidth -= ui32strlen;
    456a:	1be2      	subs	r2, r4, r7
    if ( i32NumChars <= 0 )
    456c:	2a00      	cmp	r2, #0
    456e:	f340 8464 	ble.w	4e3a <am_util_stdio_vsprintf+0x10ce>
    while ( i32NumChars-- )
    4572:	f102 3eff 	add.w	lr, r2, #4294967295
        if ( pcBuf )
    4576:	f1b8 0f00 	cmp.w	r8, #0
    457a:	d05c      	beq.n	4636 <am_util_stdio_vsprintf+0x8ca>
            *pcBuf++ = cPadChar;
    457c:	4643      	mov	r3, r8
    457e:	f00e 0407 	and.w	r4, lr, #7
    4582:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
    4586:	f10e 3aff 	add.w	sl, lr, #4294967295
    458a:	eba3 0c08 	sub.w	ip, r3, r8
    458e:	f1be 0f00 	cmp.w	lr, #0
    4592:	d045      	beq.n	4620 <am_util_stdio_vsprintf+0x8b4>
    4594:	b364      	cbz	r4, 45f0 <am_util_stdio_vsprintf+0x884>
    4596:	2c01      	cmp	r4, #1
    4598:	d021      	beq.n	45de <am_util_stdio_vsprintf+0x872>
    459a:	2c02      	cmp	r4, #2
    459c:	d01b      	beq.n	45d6 <am_util_stdio_vsprintf+0x86a>
    459e:	2c03      	cmp	r4, #3
    45a0:	d015      	beq.n	45ce <am_util_stdio_vsprintf+0x862>
    45a2:	2c04      	cmp	r4, #4
    45a4:	d00f      	beq.n	45c6 <am_util_stdio_vsprintf+0x85a>
    45a6:	2c05      	cmp	r4, #5
    45a8:	d009      	beq.n	45be <am_util_stdio_vsprintf+0x852>
    45aa:	2c06      	cmp	r4, #6
            *pcBuf++ = cPadChar;
    45ac:	bf1c      	itt	ne
    45ae:	f803 5b01 	strbne.w	r5, [r3], #1
    while ( i32NumChars-- )
    45b2:	f10a 3aff 	addne.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
    45b6:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
    45ba:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
    45be:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
    45c2:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
    45c6:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
    45ca:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
    45ce:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
    45d2:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
    45d6:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
    45da:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
    45de:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
    45e2:	f10a 3aff 	add.w	sl, sl, #4294967295
    45e6:	f11a 0401 	adds.w	r4, sl, #1
    45ea:	eba3 0c08 	sub.w	ip, r3, r8
    45ee:	d017      	beq.n	4620 <am_util_stdio_vsprintf+0x8b4>
            *pcBuf++ = cPadChar;
    45f0:	4619      	mov	r1, r3
    while ( i32NumChars-- )
    45f2:	f1aa 0a08 	sub.w	sl, sl, #8
            *pcBuf++ = cPadChar;
    45f6:	f801 5b01 	strb.w	r5, [r1], #1
    45fa:	3308      	adds	r3, #8
    45fc:	700d      	strb	r5, [r1, #0]
    45fe:	f803 5c06 	strb.w	r5, [r3, #-6]
    4602:	f803 5c05 	strb.w	r5, [r3, #-5]
    4606:	f803 5c04 	strb.w	r5, [r3, #-4]
    460a:	f803 5c03 	strb.w	r5, [r3, #-3]
    460e:	f803 5c02 	strb.w	r5, [r3, #-2]
    while ( i32NumChars-- )
    4612:	f11a 0401 	adds.w	r4, sl, #1
    4616:	eba3 0c08 	sub.w	ip, r3, r8
            *pcBuf++ = cPadChar;
    461a:	f803 5c01 	strb.w	r5, [r3, #-1]
    while ( i32NumChars-- )
    461e:	d1e7      	bne.n	45f0 <am_util_stdio_vsprintf+0x884>
    4620:	4664      	mov	r4, ip
    4622:	4662      	mov	r2, ip
                while (*pcStr != 0x0)
    4624:	7801      	ldrb	r1, [r0, #0]
                        pcBuf += pcBuf ? iWidth : 0;
    4626:	44a0      	add	r8, r4
                        ui32CharCnt += iWidth;
    4628:	4491      	add	r9, r2
                while (*pcStr != 0x0)
    462a:	2900      	cmp	r1, #0
    462c:	f43f ad50 	beq.w	40d0 <am_util_stdio_vsprintf+0x364>
                        iWidth = 0;
    4630:	2400      	movs	r4, #0
    4632:	1c42      	adds	r2, r0, #1
    4634:	e721      	b.n	447a <am_util_stdio_vsprintf+0x70e>
                while (*pcStr != 0x0)
    4636:	7803      	ldrb	r3, [r0, #0]
                        ui32CharCnt += iWidth;
    4638:	4491      	add	r9, r2
                while (*pcStr != 0x0)
    463a:	2b00      	cmp	r3, #0
    463c:	f43f ad48 	beq.w	40d0 <am_util_stdio_vsprintf+0x364>
                        iWidth = 0;
    4640:	2400      	movs	r4, #0
    4642:	1c42      	adds	r2, r0, #1
    4644:	4690      	mov	r8, r2
    4646:	eba9 0000 	sub.w	r0, r9, r0
    464a:	eb00 0908 	add.w	r9, r0, r8
                while (*pcStr != 0x0)
    464e:	f818 1b01 	ldrb.w	r1, [r8], #1
    4652:	2900      	cmp	r1, #0
    4654:	d1f9      	bne.n	464a <am_util_stdio_vsprintf+0x8de>
    4656:	4688      	mov	r8, r1
    4658:	e71d      	b.n	4496 <am_util_stdio_vsprintf+0x72a>
    465a:	e9cd 6728 	strd	r6, r7, [sp, #160]	; 0xa0
    465e:	e9cd ab26 	strd	sl, fp, [sp, #152]	; 0x98
    4662:	9d20      	ldr	r5, [sp, #128]	; 0x80
    4664:	9c1a      	ldr	r4, [sp, #104]	; 0x68
    4666:	9e1b      	ldr	r6, [sp, #108]	; 0x6c
    4668:	9f21      	ldr	r7, [sp, #132]	; 0x84
    466a:	f8dd b088 	ldr.w	fp, [sp, #136]	; 0x88
    466e:	f8dd 908c 	ldr.w	r9, [sp, #140]	; 0x8c
    4672:	f8dd 8090 	ldr.w	r8, [sp, #144]	; 0x90
                    iWidth -= ndigits_in_u64(ui64Val);
    4676:	1b3c      	subs	r4, r7, r4
    if ( i32NumChars <= 0 )
    4678:	2c00      	cmp	r4, #0
    467a:	f340 81e3 	ble.w	4a44 <am_util_stdio_vsprintf+0xcd8>
    while ( i32NumChars-- )
    467e:	1e67      	subs	r7, r4, #1
        if ( pcBuf )
    4680:	f1b8 0f00 	cmp.w	r8, #0
    4684:	f000 81df 	beq.w	4a46 <am_util_stdio_vsprintf+0xcda>
            *pcBuf++ = cPadChar;
    4688:	4643      	mov	r3, r8
    468a:	f007 0007 	and.w	r0, r7, #7
    468e:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
    4692:	f1a4 0a02 	sub.w	sl, r4, #2
    4696:	eba3 0c08 	sub.w	ip, r3, r8
    469a:	2f00      	cmp	r7, #0
    469c:	d046      	beq.n	472c <am_util_stdio_vsprintf+0x9c0>
    469e:	b360      	cbz	r0, 46fa <am_util_stdio_vsprintf+0x98e>
    46a0:	2801      	cmp	r0, #1
    46a2:	d021      	beq.n	46e8 <am_util_stdio_vsprintf+0x97c>
    46a4:	2802      	cmp	r0, #2
    46a6:	d01b      	beq.n	46e0 <am_util_stdio_vsprintf+0x974>
    46a8:	2803      	cmp	r0, #3
    46aa:	d015      	beq.n	46d8 <am_util_stdio_vsprintf+0x96c>
    46ac:	2804      	cmp	r0, #4
    46ae:	d00f      	beq.n	46d0 <am_util_stdio_vsprintf+0x964>
    46b0:	2805      	cmp	r0, #5
    46b2:	d009      	beq.n	46c8 <am_util_stdio_vsprintf+0x95c>
    46b4:	2806      	cmp	r0, #6
            *pcBuf++ = cPadChar;
    46b6:	bf1c      	itt	ne
    46b8:	f803 5b01 	strbne.w	r5, [r3], #1
    while ( i32NumChars-- )
    46bc:	f10a 3aff 	addne.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
    46c0:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
    46c4:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
    46c8:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
    46cc:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
    46d0:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
    46d4:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
    46d8:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
    46dc:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
    46e0:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
    46e4:	f10a 3aff 	add.w	sl, sl, #4294967295
            *pcBuf++ = cPadChar;
    46e8:	f803 5b01 	strb.w	r5, [r3], #1
    while ( i32NumChars-- )
    46ec:	f10a 3aff 	add.w	sl, sl, #4294967295
    46f0:	f11a 0001 	adds.w	r0, sl, #1
    46f4:	eba3 0c08 	sub.w	ip, r3, r8
    46f8:	d018      	beq.n	472c <am_util_stdio_vsprintf+0x9c0>
            *pcBuf++ = cPadChar;
    46fa:	469e      	mov	lr, r3
    while ( i32NumChars-- )
    46fc:	f1aa 0a08 	sub.w	sl, sl, #8
            *pcBuf++ = cPadChar;
    4700:	f80e 5b01 	strb.w	r5, [lr], #1
    4704:	3308      	adds	r3, #8
    4706:	f88e 5000 	strb.w	r5, [lr]
    470a:	f803 5c06 	strb.w	r5, [r3, #-6]
    470e:	f803 5c05 	strb.w	r5, [r3, #-5]
    4712:	f803 5c04 	strb.w	r5, [r3, #-4]
    4716:	f803 5c03 	strb.w	r5, [r3, #-3]
    471a:	f803 5c02 	strb.w	r5, [r3, #-2]
    while ( i32NumChars-- )
    471e:	f11a 0701 	adds.w	r7, sl, #1
    4722:	eba3 0c08 	sub.w	ip, r3, r8
            *pcBuf++ = cPadChar;
    4726:	f803 5c01 	strb.w	r5, [r3, #-1]
    while ( i32NumChars-- )
    472a:	d1e6      	bne.n	46fa <am_util_stdio_vsprintf+0x98e>
    472c:	4664      	mov	r4, ip
                    pcBuf += pcBuf ? iWidth : 0;
    472e:	44e0      	add	r8, ip
                    ui32CharCnt += iWidth;
    4730:	44a1      	add	r9, r4
                iVal = uint64_to_str(ui64Val, pcBuf);
    4732:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
    4736:	4642      	mov	r2, r8
    4738:	f7ff fa1a 	bl	3b70 <uint64_to_str>
                if ( pcBuf )
    473c:	f1b8 0f00 	cmp.w	r8, #0
    4740:	d000      	beq.n	4744 <am_util_stdio_vsprintf+0x9d8>
                    pcBuf += iVal;
    4742:	4480      	add	r8, r0
                ui32CharCnt += iVal;
    4744:	4481      	add	r9, r0
                break;
    4746:	e4c3      	b.n	40d0 <am_util_stdio_vsprintf+0x364>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    4748:	78b3      	ldrb	r3, [r6, #2]
    474a:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
    474e:	2909      	cmp	r1, #9
        pcStr++;
    4750:	f106 0602 	add.w	r6, r6, #2
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    4754:	f200 8391 	bhi.w	4e7a <am_util_stdio_vsprintf+0x110e>
        uCnt++;
    4758:	2201      	movs	r2, #1
        bNeg = true;
    475a:	4694      	mov	ip, r2
    475c:	e634      	b.n	43c8 <am_util_stdio_vsprintf+0x65c>
        switch ( *pcFmt )
    475e:	78b2      	ldrb	r2, [r6, #2]
    4760:	f1a2 0c46 	sub.w	ip, r2, #70	; 0x46
                pcFmt++;
    4764:	3602      	adds	r6, #2
        switch ( *pcFmt )
    4766:	f1bc 0f32 	cmp.w	ip, #50	; 0x32
    476a:	f63f ae0f 	bhi.w	438c <am_util_stdio_vsprintf+0x620>
    476e:	a101      	add	r1, pc, #4	; (adr r1, 4774 <am_util_stdio_vsprintf+0xa08>)
    4770:	f851 f02c 	ldr.w	pc, [r1, ip, lsl #2]
    4774:	00004093 	.word	0x00004093
    4778:	0000438d 	.word	0x0000438d
    477c:	0000438d 	.word	0x0000438d
    4780:	0000438d 	.word	0x0000438d
    4784:	0000438d 	.word	0x0000438d
    4788:	0000438d 	.word	0x0000438d
    478c:	0000438d 	.word	0x0000438d
    4790:	0000438d 	.word	0x0000438d
    4794:	0000438d 	.word	0x0000438d
    4798:	0000438d 	.word	0x0000438d
    479c:	0000438d 	.word	0x0000438d
    47a0:	0000438d 	.word	0x0000438d
    47a4:	0000438d 	.word	0x0000438d
    47a8:	0000438d 	.word	0x0000438d
    47ac:	0000438d 	.word	0x0000438d
    47b0:	0000438d 	.word	0x0000438d
    47b4:	0000438d 	.word	0x0000438d
    47b8:	0000438d 	.word	0x0000438d
    47bc:	00004f45 	.word	0x00004f45
    47c0:	0000438d 	.word	0x0000438d
    47c4:	0000438d 	.word	0x0000438d
    47c8:	0000438d 	.word	0x0000438d
    47cc:	0000438d 	.word	0x0000438d
    47d0:	0000438d 	.word	0x0000438d
    47d4:	0000438d 	.word	0x0000438d
    47d8:	0000438d 	.word	0x0000438d
    47dc:	0000438d 	.word	0x0000438d
    47e0:	0000438d 	.word	0x0000438d
    47e4:	0000438d 	.word	0x0000438d
    47e8:	000040d5 	.word	0x000040d5
    47ec:	00004857 	.word	0x00004857
    47f0:	0000438d 	.word	0x0000438d
    47f4:	00004093 	.word	0x00004093
    47f8:	0000438d 	.word	0x0000438d
    47fc:	0000438d 	.word	0x0000438d
    4800:	00004857 	.word	0x00004857
    4804:	0000438d 	.word	0x0000438d
    4808:	0000438d 	.word	0x0000438d
    480c:	0000438d 	.word	0x0000438d
    4810:	0000438d 	.word	0x0000438d
    4814:	0000438d 	.word	0x0000438d
    4818:	0000438d 	.word	0x0000438d
    481c:	0000438d 	.word	0x0000438d
    4820:	0000438d 	.word	0x0000438d
    4824:	0000438d 	.word	0x0000438d
    4828:	00004449 	.word	0x00004449
    482c:	0000438d 	.word	0x0000438d
    4830:	00004841 	.word	0x00004841
    4834:	0000438d 	.word	0x0000438d
    4838:	0000438d 	.word	0x0000438d
    483c:	00004dd7 	.word	0x00004dd7
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    4840:	f10b 0207 	add.w	r2, fp, #7
    4844:	f022 0b07 	bic.w	fp, r2, #7
    4848:	e9db 0100 	ldrd	r0, r1, [fp]
    484c:	f10b 0b08 	add.w	fp, fp, #8
    4850:	e9cd 0118 	strd	r0, r1, [sp, #96]	; 0x60
    4854:	e501      	b.n	425a <am_util_stdio_vsprintf+0x4ee>
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
    4856:	f10b 0307 	add.w	r3, fp, #7
    485a:	f023 0b07 	bic.w	fp, r3, #7
    485e:	e9db 0100 	ldrd	r0, r1, [fp]
    4862:	f10b 0b08 	add.w	fp, fp, #8
    4866:	e44e      	b.n	4106 <am_util_stdio_vsprintf+0x39a>
                    ui64Val = -i64Val;          // Get absolute value
    4868:	4240      	negs	r0, r0
    486a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    486e:	e9cd 0118 	strd	r0, r1, [sp, #96]	; 0x60
                if ( iWidth )
    4872:	2c00      	cmp	r4, #0
    4874:	f040 834e 	bne.w	4f14 <am_util_stdio_vsprintf+0x11a8>
                        if ( pcBuf )
    4878:	f1b8 0f00 	cmp.w	r8, #0
    487c:	f000 82d1 	beq.w	4e22 <am_util_stdio_vsprintf+0x10b6>
                            *pcBuf++ = '-';
    4880:	252d      	movs	r5, #45	; 0x2d
    4882:	f888 5000 	strb.w	r5, [r8]
                        ++ui32CharCnt;
    4886:	f109 0901 	add.w	r9, r9, #1
                            *pcBuf++ = '-';
    488a:	f108 0801 	add.w	r8, r8, #1
                iVal = uint64_to_str(ui64Val, pcBuf);
    488e:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
    4892:	4642      	mov	r2, r8
    4894:	f7ff f96c 	bl	3b70 <uint64_to_str>
                if ( pcBuf )
    4898:	f1b8 0f00 	cmp.w	r8, #0
    489c:	f47f af51 	bne.w	4742 <am_util_stdio_vsprintf+0x9d6>
                    pcBuf += iVal;
    48a0:	f04f 0800 	mov.w	r8, #0
                ui32CharCnt += iVal;
    48a4:	4481      	add	r9, r0
    48a6:	e413      	b.n	40d0 <am_util_stdio_vsprintf+0x364>
    48a8:	e9cd 671e 	strd	r6, r7, [sp, #120]	; 0x78
    48ac:	9b1a      	ldr	r3, [sp, #104]	; 0x68
    48ae:	9f22      	ldr	r7, [sp, #136]	; 0x88
                    if ( bNeg )
    48b0:	9c1b      	ldr	r4, [sp, #108]	; 0x6c
    48b2:	9d21      	ldr	r5, [sp, #132]	; 0x84
    48b4:	9e20      	ldr	r6, [sp, #128]	; 0x80
    48b6:	f8dd 9090 	ldr.w	r9, [sp, #144]	; 0x90
    48ba:	f8dd 8094 	ldr.w	r8, [sp, #148]	; 0x94
    48be:	e9cd ab1c 	strd	sl, fp, [sp, #112]	; 0x70
                    iWidth -= ndigits_in_i64(ui64Val);
    48c2:	1aff      	subs	r7, r7, r3
    48c4:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
                    if ( bNeg )
    48c8:	b13c      	cbz	r4, 48da <am_util_stdio_vsprintf+0xb6e>
                        if ( ui8PadChar == '0' )
    48ca:	2d30      	cmp	r5, #48	; 0x30
                        --iWidth;
    48cc:	f107 31ff 	add.w	r1, r7, #4294967295
                        if ( ui8PadChar == '0' )
    48d0:	f000 82c3 	beq.w	4e5a <am_util_stdio_vsprintf+0x10ee>
    48d4:	2001      	movs	r0, #1
                        --iWidth;
    48d6:	460f      	mov	r7, r1
    48d8:	901b      	str	r0, [sp, #108]	; 0x6c
    if ( i32NumChars <= 0 )
    48da:	2f00      	cmp	r7, #0
    48dc:	f340 82d3 	ble.w	4e86 <am_util_stdio_vsprintf+0x111a>
    while ( i32NumChars-- )
    48e0:	1e78      	subs	r0, r7, #1
        if ( pcBuf )
    48e2:	f1b8 0f00 	cmp.w	r8, #0
    48e6:	d067      	beq.n	49b8 <am_util_stdio_vsprintf+0xc4c>
    48e8:	f010 0107 	ands.w	r1, r0, #7
    48ec:	f1a7 0a02 	sub.w	sl, r7, #2
    48f0:	4643      	mov	r3, r8
    48f2:	d03a      	beq.n	496a <am_util_stdio_vsprintf+0xbfe>
            *pcBuf++ = cPadChar;
    48f4:	4643      	mov	r3, r8
    48f6:	2901      	cmp	r1, #1
    48f8:	f1a7 0a03 	sub.w	sl, r7, #3
    48fc:	f803 5b01 	strb.w	r5, [r3], #1
    4900:	d033      	beq.n	496a <am_util_stdio_vsprintf+0xbfe>
    4902:	2902      	cmp	r1, #2
    4904:	d01b      	beq.n	493e <am_util_stdio_vsprintf+0xbd2>
    4906:	2903      	cmp	r1, #3
    4908:	d015      	beq.n	4936 <am_util_stdio_vsprintf+0xbca>
    490a:	2904      	cmp	r1, #4
    490c:	d00f      	beq.n	492e <am_util_stdio_vsprintf+0xbc2>
    490e:	2905      	cmp	r1, #5
    4910:	d009      	beq.n	4926 <am_util_stdio_vsprintf+0xbba>
    4912:	2906      	cmp	r1, #6
    4914:	bf1c      	itt	ne
    4916:	f803 5b01 	strbne.w	r5, [r3], #1
    491a:	f1a7 0a04 	subne.w	sl, r7, #4
    491e:	f803 5b01 	strb.w	r5, [r3], #1
    4922:	f10a 3aff 	add.w	sl, sl, #4294967295
    4926:	f803 5b01 	strb.w	r5, [r3], #1
    492a:	f10a 3aff 	add.w	sl, sl, #4294967295
    492e:	f803 5b01 	strb.w	r5, [r3], #1
    4932:	f10a 3aff 	add.w	sl, sl, #4294967295
    4936:	f803 5b01 	strb.w	r5, [r3], #1
    493a:	f10a 3aff 	add.w	sl, sl, #4294967295
    493e:	f803 5b01 	strb.w	r5, [r3], #1
    4942:	f10a 3aff 	add.w	sl, sl, #4294967295
    4946:	e010      	b.n	496a <am_util_stdio_vsprintf+0xbfe>
    4948:	f88c 5000 	strb.w	r5, [ip]
    494c:	3308      	adds	r3, #8
    494e:	f803 5c06 	strb.w	r5, [r3, #-6]
    4952:	f803 5c05 	strb.w	r5, [r3, #-5]
    4956:	f803 5c04 	strb.w	r5, [r3, #-4]
    495a:	f803 5c03 	strb.w	r5, [r3, #-3]
    495e:	f803 5c02 	strb.w	r5, [r3, #-2]
    4962:	f1aa 0a08 	sub.w	sl, sl, #8
    4966:	f803 5c01 	strb.w	r5, [r3, #-1]
    496a:	469c      	mov	ip, r3
    while ( i32NumChars-- )
    496c:	f11a 0401 	adds.w	r4, sl, #1
            *pcBuf++ = cPadChar;
    4970:	f80c 5b01 	strb.w	r5, [ip], #1
    4974:	ebac 0e08 	sub.w	lr, ip, r8
    while ( i32NumChars-- )
    4978:	d1e6      	bne.n	4948 <am_util_stdio_vsprintf+0xbdc>
                    if ( bNeg  &&  (ui8PadChar == ' ') )
    497a:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    497c:	44f0      	add	r8, lr
                    ui32CharCnt += iWidth;
    497e:	44f1      	add	r9, lr
                    if ( bNeg  &&  (ui8PadChar == ' ') )
    4980:	2a00      	cmp	r2, #0
    4982:	d084      	beq.n	488e <am_util_stdio_vsprintf+0xb22>
    4984:	2d20      	cmp	r5, #32
    4986:	d182      	bne.n	488e <am_util_stdio_vsprintf+0xb22>
                        if ( pcBuf )
    4988:	f1b8 0f00 	cmp.w	r8, #0
    498c:	f47f af78 	bne.w	4880 <am_util_stdio_vsprintf+0xb14>
                iVal = uint64_to_str(ui64Val, pcBuf);
    4990:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
    4994:	2200      	movs	r2, #0
    4996:	f7ff f8eb 	bl	3b70 <uint64_to_str>
                        ++ui32CharCnt;
    499a:	f109 0901 	add.w	r9, r9, #1
                iVal = uint64_to_str(ui64Val, pcBuf);
    499e:	f04f 0800 	mov.w	r8, #0
                ui32CharCnt += iVal;
    49a2:	4481      	add	r9, r0
    49a4:	f7ff bb94 	b.w	40d0 <am_util_stdio_vsprintf+0x364>
    if ( i32NumChars <= 0 )
    49a8:	2900      	cmp	r1, #0
                            ++ui32CharCnt;
    49aa:	f109 0901 	add.w	r9, r9, #1
    if ( i32NumChars <= 0 )
    49ae:	f340 82bc 	ble.w	4f2a <am_util_stdio_vsprintf+0x11be>
    while ( i32NumChars-- )
    49b2:	2201      	movs	r2, #1
    49b4:	1eb8      	subs	r0, r7, #2
    49b6:	921b      	str	r2, [sp, #108]	; 0x6c
    49b8:	3001      	adds	r0, #1
                    if ( bNeg  &&  (ui8PadChar == ' ') )
    49ba:	9f1b      	ldr	r7, [sp, #108]	; 0x6c
                    ui32CharCnt += iWidth;
    49bc:	4481      	add	r9, r0
                    if ( bNeg  &&  (ui8PadChar == ' ') )
    49be:	2f00      	cmp	r7, #0
    49c0:	f000 821b 	beq.w	4dfa <am_util_stdio_vsprintf+0x108e>
    49c4:	2d20      	cmp	r5, #32
    49c6:	d0e3      	beq.n	4990 <am_util_stdio_vsprintf+0xc24>
                iVal = uint64_to_str(ui64Val, pcBuf);
    49c8:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
    49cc:	2200      	movs	r2, #0
    49ce:	f7ff f8cf 	bl	3b70 <uint64_to_str>
    49d2:	e765      	b.n	48a0 <am_util_stdio_vsprintf+0xb34>
    if ( i32NumChars <= 0 )
    49d4:	2700      	movs	r7, #0
    49d6:	2400      	movs	r4, #0
    49d8:	f7ff baee 	b.w	3fb8 <am_util_stdio_vsprintf+0x24c>
    iExp2 = ((unFloatValue.I32 >> 23) & 0x000000FF) - 127;
    49dc:	ee17 7a90 	vmov	r7, s15
    49e0:	f3c7 5ec7 	ubfx	lr, r7, #23, #8
    49e4:	f1ae 017f 	sub.w	r1, lr, #127	; 0x7f
    i32Significand = (unFloatValue.I32 & 0x00FFFFFF) | 0x00800000;
    49e8:	f3c7 0216 	ubfx	r2, r7, #0, #23
    if (iExp2 >= 31)
    49ec:	291e      	cmp	r1, #30
    i32Significand = (unFloatValue.I32 & 0x00FFFFFF) | 0x00800000;
    49ee:	f442 0000 	orr.w	r0, r2, #8388608	; 0x800000
    if (iExp2 >= 31)
    49f2:	f300 8246 	bgt.w	4e82 <am_util_stdio_vsprintf+0x1116>
    else if (iExp2 < -23)
    49f6:	f111 0f17 	cmn.w	r1, #23
    49fa:	f2c0 823c 	blt.w	4e76 <am_util_stdio_vsprintf+0x110a>
    else if (iExp2 >= 23)
    49fe:	2916      	cmp	r1, #22
    4a00:	dd2f      	ble.n	4a62 <am_util_stdio_vsprintf+0xcf6>
        i32IntPart = i32Significand << (iExp2 - 23);
    4a02:	f1ae 0296 	sub.w	r2, lr, #150	; 0x96
    if (unFloatValue.I32 < 0)
    4a06:	2f00      	cmp	r7, #0
        i32IntPart = i32Significand << (iExp2 - 23);
    4a08:	fa00 f002 	lsl.w	r0, r0, r2
    if (unFloatValue.I32 < 0)
    4a0c:	f2c0 825c 	blt.w	4ec8 <am_util_stdio_vsprintf+0x115c>
    if (i32IntPart == 0)
    4a10:	2800      	cmp	r0, #0
    4a12:	f040 824c 	bne.w	4eae <am_util_stdio_vsprintf+0x1142>
    *pcBuf++ = '.';
    4a16:	252e      	movs	r5, #46	; 0x2e
        *pcBuf++ = '0';
    4a18:	f04f 0430 	mov.w	r4, #48	; 0x30
    *pcBuf++ = '.';
    4a1c:	f888 5001 	strb.w	r5, [r8, #1]
        *pcBuf++ = '0';
    4a20:	f888 4000 	strb.w	r4, [r8]
    4a24:	f108 0501 	add.w	r5, r8, #1
        *pcBuf++ = '0';
    4a28:	1caa      	adds	r2, r5, #2
    4a2a:	f04f 0430 	mov.w	r4, #48	; 0x30
    4a2e:	706c      	strb	r4, [r5, #1]
    4a30:	eba2 0008 	sub.w	r0, r2, r8
    *pcBuf = 0x00;
    4a34:	2500      	movs	r5, #0
                    if ( iVal < 0 )
    4a36:	42a8      	cmp	r0, r5
    *pcBuf = 0x00;
    4a38:	7015      	strb	r5, [r2, #0]
                    if ( iVal < 0 )
    4a3a:	f2c0 81e7 	blt.w	4e0c <am_util_stdio_vsprintf+0x10a0>
    4a3e:	4682      	mov	sl, r0
    4a40:	f7ff bb44 	b.w	40cc <am_util_stdio_vsprintf+0x360>
    if ( i32NumChars <= 0 )
    4a44:	2400      	movs	r4, #0
    4a46:	f04f 0c00 	mov.w	ip, #0
    4a4a:	e670      	b.n	472e <am_util_stdio_vsprintf+0x9c2>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    4a4c:	4606      	mov	r6, r0
    4a4e:	2400      	movs	r4, #0
    4a50:	f7ff b9f4 	b.w	3e3c <am_util_stdio_vsprintf+0xd0>
    4a54:	f04f 0a00 	mov.w	sl, #0
    uint32_t ui32Val = 0, uCnt = 0;
    4a58:	4652      	mov	r2, sl
            pcFmt += ui32NumChars;
    4a5a:	1886      	adds	r6, r0, r2
    4a5c:	5c82      	ldrb	r2, [r0, r2]
    4a5e:	f7ff b9f9 	b.w	3e54 <am_util_stdio_vsprintf+0xe8>
    else if (iExp2 >= 0)
    4a62:	2900      	cmp	r1, #0
    4a64:	f2c0 8214 	blt.w	4e90 <am_util_stdio_vsprintf+0x1124>
        i32FracPart = (i32Significand << (iExp2 + 1)) & 0x00FFFFFF;
    4a68:	f1ae 047e 	sub.w	r4, lr, #126	; 0x7e
    4a6c:	fa00 f304 	lsl.w	r3, r0, r4
        i32IntPart = i32Significand >> (23 - iExp2);
    4a70:	f1c1 0117 	rsb	r1, r1, #23
    if (unFloatValue.I32 < 0)
    4a74:	2f00      	cmp	r7, #0
        i32FracPart = (i32Significand << (iExp2 + 1)) & 0x00FFFFFF;
    4a76:	f023 447f 	bic.w	r4, r3, #4278190080	; 0xff000000
        i32IntPart = i32Significand >> (23 - iExp2);
    4a7a:	fa40 f001 	asr.w	r0, r0, r1
    if (unFloatValue.I32 < 0)
    4a7e:	f2c0 823b 	blt.w	4ef8 <am_util_stdio_vsprintf+0x118c>
    4a82:	4645      	mov	r5, r8
            uint64_to_str(i32IntPart, pcBuf);
    4a84:	462a      	mov	r2, r5
    4a86:	17c1      	asrs	r1, r0, #31
    4a88:	f7ff f872 	bl	3b70 <uint64_to_str>
        while (*pcBuf)    // Get to end of new string
    4a8c:	7829      	ldrb	r1, [r5, #0]
    4a8e:	b119      	cbz	r1, 4a98 <am_util_stdio_vsprintf+0xd2c>
    4a90:	f815 0f01 	ldrb.w	r0, [r5, #1]!
    4a94:	2800      	cmp	r0, #0
    4a96:	d1fb      	bne.n	4a90 <am_util_stdio_vsprintf+0xd24>
    *pcBuf++ = '.';
    4a98:	222e      	movs	r2, #46	; 0x2e
    4a9a:	702a      	strb	r2, [r5, #0]
    if (i32FracPart == 0)
    4a9c:	2c00      	cmp	r4, #0
    4a9e:	d0c3      	beq.n	4a28 <am_util_stdio_vsprintf+0xcbc>
    *pcBuf++ = '.';
    4aa0:	1c6a      	adds	r2, r5, #1
        iMax = iBufSize - (pcBuf - pcBufInitial) - 1;
    4aa2:	eba2 0008 	sub.w	r0, r2, r8
    4aa6:	f1c0 0c13 	rsb	ip, r0, #19
        iMax = (iMax > iPrecision) ? iPrecision : iMax;
    4aaa:	45e2      	cmp	sl, ip
    4aac:	bfa8      	it	ge
    4aae:	46e2      	movge	sl, ip
        for (jx = 0; jx < iMax; jx++)
    4ab0:	f1ba 0f00 	cmp.w	sl, #0
    4ab4:	f340 80b2 	ble.w	4c1c <am_util_stdio_vsprintf+0xeb0>
            i32FracPart *= 10;
    4ab8:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    4abc:	0067      	lsls	r7, r4, #1
    4abe:	eb05 000a 	add.w	r0, r5, sl
            *pcBuf++ = (i32FracPart >> 24) + '0';
    4ac2:	1639      	asrs	r1, r7, #24
    4ac4:	3130      	adds	r1, #48	; 0x30
    4ac6:	f10a 3eff 	add.w	lr, sl, #4294967295
        for (jx = 0; jx < iMax; jx++)
    4aca:	4290      	cmp	r0, r2
            *pcBuf++ = (i32FracPart >> 24) + '0';
    4acc:	7069      	strb	r1, [r5, #1]
    4ace:	901a      	str	r0, [sp, #104]	; 0x68
            i32FracPart &= 0x00FFFFFF;
    4ad0:	f027 447f 	bic.w	r4, r7, #4278190080	; 0xff000000
    4ad4:	f00e 0507 	and.w	r5, lr, #7
    4ad8:	4613      	mov	r3, r2
        for (jx = 0; jx < iMax; jx++)
    4ada:	f000 809c 	beq.w	4c16 <am_util_stdio_vsprintf+0xeaa>
    4ade:	2d00      	cmp	r5, #0
    4ae0:	d04d      	beq.n	4b7e <am_util_stdio_vsprintf+0xe12>
    4ae2:	2d01      	cmp	r5, #1
    4ae4:	d03f      	beq.n	4b66 <am_util_stdio_vsprintf+0xdfa>
    4ae6:	2d02      	cmp	r5, #2
    4ae8:	d034      	beq.n	4b54 <am_util_stdio_vsprintf+0xde8>
    4aea:	2d03      	cmp	r5, #3
    4aec:	d029      	beq.n	4b42 <am_util_stdio_vsprintf+0xdd6>
    4aee:	2d04      	cmp	r5, #4
    4af0:	d01e      	beq.n	4b30 <am_util_stdio_vsprintf+0xdc4>
    4af2:	2d05      	cmp	r5, #5
    4af4:	d013      	beq.n	4b1e <am_util_stdio_vsprintf+0xdb2>
    4af6:	2d06      	cmp	r5, #6
    4af8:	d008      	beq.n	4b0c <am_util_stdio_vsprintf+0xda0>
            i32FracPart *= 10;
    4afa:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    4afe:	0067      	lsls	r7, r4, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
    4b00:	1639      	asrs	r1, r7, #24
    4b02:	3130      	adds	r1, #48	; 0x30
    4b04:	f803 1f01 	strb.w	r1, [r3, #1]!
            i32FracPart &= 0x00FFFFFF;
    4b08:	f027 447f 	bic.w	r4, r7, #4278190080	; 0xff000000
            i32FracPart *= 10;
    4b0c:	eb04 0084 	add.w	r0, r4, r4, lsl #2
    4b10:	0045      	lsls	r5, r0, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
    4b12:	162c      	asrs	r4, r5, #24
    4b14:	3430      	adds	r4, #48	; 0x30
    4b16:	f803 4f01 	strb.w	r4, [r3, #1]!
            i32FracPart &= 0x00FFFFFF;
    4b1a:	f025 447f 	bic.w	r4, r5, #4278190080	; 0xff000000
            i32FracPart *= 10;
    4b1e:	eb04 0784 	add.w	r7, r4, r4, lsl #2
    4b22:	0078      	lsls	r0, r7, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
    4b24:	1601      	asrs	r1, r0, #24
    4b26:	3130      	adds	r1, #48	; 0x30
    4b28:	f803 1f01 	strb.w	r1, [r3, #1]!
            i32FracPart &= 0x00FFFFFF;
    4b2c:	f020 447f 	bic.w	r4, r0, #4278190080	; 0xff000000
            i32FracPart *= 10;
    4b30:	eb04 0584 	add.w	r5, r4, r4, lsl #2
    4b34:	006c      	lsls	r4, r5, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
    4b36:	1627      	asrs	r7, r4, #24
    4b38:	3730      	adds	r7, #48	; 0x30
    4b3a:	f803 7f01 	strb.w	r7, [r3, #1]!
            i32FracPart &= 0x00FFFFFF;
    4b3e:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
            i32FracPart *= 10;
    4b42:	eb04 0084 	add.w	r0, r4, r4, lsl #2
    4b46:	0045      	lsls	r5, r0, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
    4b48:	1629      	asrs	r1, r5, #24
    4b4a:	3130      	adds	r1, #48	; 0x30
    4b4c:	f803 1f01 	strb.w	r1, [r3, #1]!
            i32FracPart &= 0x00FFFFFF;
    4b50:	f025 447f 	bic.w	r4, r5, #4278190080	; 0xff000000
            i32FracPart *= 10;
    4b54:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    4b58:	0067      	lsls	r7, r4, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
    4b5a:	1638      	asrs	r0, r7, #24
    4b5c:	3030      	adds	r0, #48	; 0x30
    4b5e:	f803 0f01 	strb.w	r0, [r3, #1]!
            i32FracPart &= 0x00FFFFFF;
    4b62:	f027 447f 	bic.w	r4, r7, #4278190080	; 0xff000000
            i32FracPart *= 10;
    4b66:	eb04 0584 	add.w	r5, r4, r4, lsl #2
    4b6a:	006c      	lsls	r4, r5, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
    4b6c:	1621      	asrs	r1, r4, #24
    4b6e:	3130      	adds	r1, #48	; 0x30
    4b70:	f803 1f01 	strb.w	r1, [r3, #1]!
        for (jx = 0; jx < iMax; jx++)
    4b74:	9f1a      	ldr	r7, [sp, #104]	; 0x68
    4b76:	429f      	cmp	r7, r3
            i32FracPart &= 0x00FFFFFF;
    4b78:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
        for (jx = 0; jx < iMax; jx++)
    4b7c:	d04b      	beq.n	4c16 <am_util_stdio_vsprintf+0xeaa>
            i32FracPart *= 10;
    4b7e:	eb04 0084 	add.w	r0, r4, r4, lsl #2
    4b82:	0041      	lsls	r1, r0, #1
            i32FracPart &= 0x00FFFFFF;
    4b84:	f021 4c7f 	bic.w	ip, r1, #4278190080	; 0xff000000
            i32FracPart *= 10;
    4b88:	eb0c 058c 	add.w	r5, ip, ip, lsl #2
    4b8c:	006c      	lsls	r4, r5, #1
            i32FracPart &= 0x00FFFFFF;
    4b8e:	f024 4e7f 	bic.w	lr, r4, #4278190080	; 0xff000000
            i32FracPart *= 10;
    4b92:	eb0e 078e 	add.w	r7, lr, lr, lsl #2
    4b96:	ea4f 0c47 	mov.w	ip, r7, lsl #1
            i32FracPart &= 0x00FFFFFF;
    4b9a:	f02c 407f 	bic.w	r0, ip, #4278190080	; 0xff000000
            i32FracPart *= 10;
    4b9e:	eb00 0580 	add.w	r5, r0, r0, lsl #2
    4ba2:	ea4f 0e45 	mov.w	lr, r5, lsl #1
            i32FracPart &= 0x00FFFFFF;
    4ba6:	f02e 477f 	bic.w	r7, lr, #4278190080	; 0xff000000
            i32FracPart *= 10;
    4baa:	eb07 0087 	add.w	r0, r7, r7, lsl #2
    4bae:	0047      	lsls	r7, r0, #1
            i32FracPart &= 0x00FFFFFF;
    4bb0:	f027 457f 	bic.w	r5, r7, #4278190080	; 0xff000000
            i32FracPart *= 10;
    4bb4:	eb05 0085 	add.w	r0, r5, r5, lsl #2
    4bb8:	0045      	lsls	r5, r0, #1
            i32FracPart &= 0x00FFFFFF;
    4bba:	f025 407f 	bic.w	r0, r5, #4278190080	; 0xff000000
            i32FracPart *= 10;
    4bbe:	eb00 0080 	add.w	r0, r0, r0, lsl #2
            *pcBuf++ = (i32FracPart >> 24) + '0';
    4bc2:	1609      	asrs	r1, r1, #24
            i32FracPart *= 10;
    4bc4:	0040      	lsls	r0, r0, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
    4bc6:	3130      	adds	r1, #48	; 0x30
    4bc8:	1624      	asrs	r4, r4, #24
    4bca:	3430      	adds	r4, #48	; 0x30
    4bcc:	7059      	strb	r1, [r3, #1]
            i32FracPart &= 0x00FFFFFF;
    4bce:	f020 417f 	bic.w	r1, r0, #4278190080	; 0xff000000
            *pcBuf++ = (i32FracPart >> 24) + '0';
    4bd2:	709c      	strb	r4, [r3, #2]
            i32FracPart *= 10;
    4bd4:	eb01 0481 	add.w	r4, r1, r1, lsl #2
    4bd8:	0064      	lsls	r4, r4, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
    4bda:	1601      	asrs	r1, r0, #24
    4bdc:	ea4f 6c2c 	mov.w	ip, ip, asr #24
    4be0:	1620      	asrs	r0, r4, #24
    4be2:	ea4f 6e2e 	mov.w	lr, lr, asr #24
    4be6:	163f      	asrs	r7, r7, #24
    4be8:	162d      	asrs	r5, r5, #24
    4bea:	3730      	adds	r7, #48	; 0x30
    4bec:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
    4bf0:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
    4bf4:	3530      	adds	r5, #48	; 0x30
    4bf6:	3130      	adds	r1, #48	; 0x30
    4bf8:	3030      	adds	r0, #48	; 0x30
    4bfa:	715f      	strb	r7, [r3, #5]
    4bfc:	f883 c003 	strb.w	ip, [r3, #3]
    4c00:	f883 e004 	strb.w	lr, [r3, #4]
    4c04:	719d      	strb	r5, [r3, #6]
    4c06:	71d9      	strb	r1, [r3, #7]
        for (jx = 0; jx < iMax; jx++)
    4c08:	9f1a      	ldr	r7, [sp, #104]	; 0x68
            *pcBuf++ = (i32FracPart >> 24) + '0';
    4c0a:	f803 0f08 	strb.w	r0, [r3, #8]!
        for (jx = 0; jx < iMax; jx++)
    4c0e:	429f      	cmp	r7, r3
            i32FracPart &= 0x00FFFFFF;
    4c10:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
        for (jx = 0; jx < iMax; jx++)
    4c14:	d1b3      	bne.n	4b7e <am_util_stdio_vsprintf+0xe12>
    4c16:	4452      	add	r2, sl
    4c18:	eba2 0008 	sub.w	r0, r2, r8
        if ( ((i32FracPart * 10) >> 24) >= 5 )
    4c1c:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    4c20:	f343 55c7 	sbfx	r5, r3, #23, #8
    4c24:	2d04      	cmp	r5, #4
    4c26:	f77f af05 	ble.w	4a34 <am_util_stdio_vsprintf+0xcc8>
            pcBuftmp = pcBuf - 1;
    4c2a:	1e53      	subs	r3, r2, #1
            while ( pcBuftmp >= pcBufInitial )
    4c2c:	4598      	cmp	r8, r3
    4c2e:	f63f af01 	bhi.w	4a34 <am_util_stdio_vsprintf+0xcc8>
    4c32:	f108 37ff 	add.w	r7, r8, #4294967295
                if ( *pcBuftmp == '.' )
    4c36:	f812 1c01 	ldrb.w	r1, [r2, #-1]
    4c3a:	1afc      	subs	r4, r7, r3
    4c3c:	43e5      	mvns	r5, r4
    4c3e:	292e      	cmp	r1, #46	; 0x2e
    4c40:	f005 0407 	and.w	r4, r5, #7
    4c44:	d005      	beq.n	4c52 <am_util_stdio_vsprintf+0xee6>
                else if ( *pcBuftmp == '9' )
    4c46:	2939      	cmp	r1, #57	; 0x39
    4c48:	f040 8161 	bne.w	4f0e <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
    4c4c:	f04f 0130 	mov.w	r1, #48	; 0x30
    4c50:	7019      	strb	r1, [r3, #0]
                pcBuftmp--;
    4c52:	3b01      	subs	r3, #1
            while ( pcBuftmp >= pcBufInitial )
    4c54:	42bb      	cmp	r3, r7
    4c56:	f43f aeed 	beq.w	4a34 <am_util_stdio_vsprintf+0xcc8>
    4c5a:	2c00      	cmp	r4, #0
    4c5c:	d054      	beq.n	4d08 <am_util_stdio_vsprintf+0xf9c>
    4c5e:	2c01      	cmp	r4, #1
    4c60:	d045      	beq.n	4cee <am_util_stdio_vsprintf+0xf82>
    4c62:	2c02      	cmp	r4, #2
    4c64:	d039      	beq.n	4cda <am_util_stdio_vsprintf+0xf6e>
    4c66:	2c03      	cmp	r4, #3
    4c68:	d02d      	beq.n	4cc6 <am_util_stdio_vsprintf+0xf5a>
    4c6a:	2c04      	cmp	r4, #4
    4c6c:	d021      	beq.n	4cb2 <am_util_stdio_vsprintf+0xf46>
    4c6e:	2c05      	cmp	r4, #5
    4c70:	d015      	beq.n	4c9e <am_util_stdio_vsprintf+0xf32>
    4c72:	2c06      	cmp	r4, #6
    4c74:	d009      	beq.n	4c8a <am_util_stdio_vsprintf+0xf1e>
                if ( *pcBuftmp == '.' )
    4c76:	7819      	ldrb	r1, [r3, #0]
    4c78:	292e      	cmp	r1, #46	; 0x2e
    4c7a:	d005      	beq.n	4c88 <am_util_stdio_vsprintf+0xf1c>
                else if ( *pcBuftmp == '9' )
    4c7c:	2939      	cmp	r1, #57	; 0x39
    4c7e:	f040 8146 	bne.w	4f0e <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
    4c82:	f04f 0530 	mov.w	r5, #48	; 0x30
    4c86:	701d      	strb	r5, [r3, #0]
                pcBuftmp--;
    4c88:	3b01      	subs	r3, #1
                if ( *pcBuftmp == '.' )
    4c8a:	7819      	ldrb	r1, [r3, #0]
    4c8c:	292e      	cmp	r1, #46	; 0x2e
    4c8e:	d005      	beq.n	4c9c <am_util_stdio_vsprintf+0xf30>
                else if ( *pcBuftmp == '9' )
    4c90:	2939      	cmp	r1, #57	; 0x39
    4c92:	f040 813c 	bne.w	4f0e <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
    4c96:	f04f 0430 	mov.w	r4, #48	; 0x30
    4c9a:	701c      	strb	r4, [r3, #0]
                pcBuftmp--;
    4c9c:	3b01      	subs	r3, #1
                if ( *pcBuftmp == '.' )
    4c9e:	7819      	ldrb	r1, [r3, #0]
    4ca0:	292e      	cmp	r1, #46	; 0x2e
    4ca2:	d005      	beq.n	4cb0 <am_util_stdio_vsprintf+0xf44>
                else if ( *pcBuftmp == '9' )
    4ca4:	2939      	cmp	r1, #57	; 0x39
    4ca6:	f040 8132 	bne.w	4f0e <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
    4caa:	f04f 0130 	mov.w	r1, #48	; 0x30
    4cae:	7019      	strb	r1, [r3, #0]
                pcBuftmp--;
    4cb0:	3b01      	subs	r3, #1
                if ( *pcBuftmp == '.' )
    4cb2:	7819      	ldrb	r1, [r3, #0]
    4cb4:	292e      	cmp	r1, #46	; 0x2e
    4cb6:	d005      	beq.n	4cc4 <am_util_stdio_vsprintf+0xf58>
                else if ( *pcBuftmp == '9' )
    4cb8:	2939      	cmp	r1, #57	; 0x39
    4cba:	f040 8128 	bne.w	4f0e <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
    4cbe:	f04f 0530 	mov.w	r5, #48	; 0x30
    4cc2:	701d      	strb	r5, [r3, #0]
                pcBuftmp--;
    4cc4:	3b01      	subs	r3, #1
                if ( *pcBuftmp == '.' )
    4cc6:	7819      	ldrb	r1, [r3, #0]
    4cc8:	292e      	cmp	r1, #46	; 0x2e
    4cca:	d005      	beq.n	4cd8 <am_util_stdio_vsprintf+0xf6c>
                else if ( *pcBuftmp == '9' )
    4ccc:	2939      	cmp	r1, #57	; 0x39
    4cce:	f040 811e 	bne.w	4f0e <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
    4cd2:	f04f 0430 	mov.w	r4, #48	; 0x30
    4cd6:	701c      	strb	r4, [r3, #0]
                pcBuftmp--;
    4cd8:	3b01      	subs	r3, #1
                if ( *pcBuftmp == '.' )
    4cda:	7819      	ldrb	r1, [r3, #0]
    4cdc:	292e      	cmp	r1, #46	; 0x2e
    4cde:	d005      	beq.n	4cec <am_util_stdio_vsprintf+0xf80>
                else if ( *pcBuftmp == '9' )
    4ce0:	2939      	cmp	r1, #57	; 0x39
    4ce2:	f040 8114 	bne.w	4f0e <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
    4ce6:	f04f 0130 	mov.w	r1, #48	; 0x30
    4cea:	7019      	strb	r1, [r3, #0]
                pcBuftmp--;
    4cec:	3b01      	subs	r3, #1
                if ( *pcBuftmp == '.' )
    4cee:	7819      	ldrb	r1, [r3, #0]
    4cf0:	292e      	cmp	r1, #46	; 0x2e
    4cf2:	d005      	beq.n	4d00 <am_util_stdio_vsprintf+0xf94>
                else if ( *pcBuftmp == '9' )
    4cf4:	2939      	cmp	r1, #57	; 0x39
    4cf6:	f040 810a 	bne.w	4f0e <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
    4cfa:	f04f 0530 	mov.w	r5, #48	; 0x30
    4cfe:	701d      	strb	r5, [r3, #0]
                pcBuftmp--;
    4d00:	3b01      	subs	r3, #1
            while ( pcBuftmp >= pcBufInitial )
    4d02:	42bb      	cmp	r3, r7
    4d04:	f43f ae96 	beq.w	4a34 <am_util_stdio_vsprintf+0xcc8>
                if ( *pcBuftmp == '.' )
    4d08:	7819      	ldrb	r1, [r3, #0]
    4d0a:	292e      	cmp	r1, #46	; 0x2e
    4d0c:	d005      	beq.n	4d1a <am_util_stdio_vsprintf+0xfae>
                else if ( *pcBuftmp == '9' )
    4d0e:	2939      	cmp	r1, #57	; 0x39
    4d10:	f040 80fd 	bne.w	4f0e <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
    4d14:	f04f 0430 	mov.w	r4, #48	; 0x30
    4d18:	701c      	strb	r4, [r3, #0]
                pcBuftmp--;
    4d1a:	3b01      	subs	r3, #1
                if ( *pcBuftmp == '.' )
    4d1c:	7819      	ldrb	r1, [r3, #0]
    4d1e:	292e      	cmp	r1, #46	; 0x2e
                pcBuftmp--;
    4d20:	469a      	mov	sl, r3
                if ( *pcBuftmp == '.' )
    4d22:	d005      	beq.n	4d30 <am_util_stdio_vsprintf+0xfc4>
                else if ( *pcBuftmp == '9' )
    4d24:	2939      	cmp	r1, #57	; 0x39
    4d26:	f040 80f2 	bne.w	4f0e <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
    4d2a:	f04f 0130 	mov.w	r1, #48	; 0x30
    4d2e:	7019      	strb	r1, [r3, #0]
                if ( *pcBuftmp == '.' )
    4d30:	f81a 1c01 	ldrb.w	r1, [sl, #-1]
    4d34:	292e      	cmp	r1, #46	; 0x2e
                pcBuftmp--;
    4d36:	f10a 33ff 	add.w	r3, sl, #4294967295
                if ( *pcBuftmp == '.' )
    4d3a:	d006      	beq.n	4d4a <am_util_stdio_vsprintf+0xfde>
                else if ( *pcBuftmp == '9' )
    4d3c:	2939      	cmp	r1, #57	; 0x39
    4d3e:	f040 80e6 	bne.w	4f0e <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
    4d42:	f04f 0c30 	mov.w	ip, #48	; 0x30
    4d46:	f80a cc01 	strb.w	ip, [sl, #-1]
                if ( *pcBuftmp == '.' )
    4d4a:	f81a 1c02 	ldrb.w	r1, [sl, #-2]
    4d4e:	292e      	cmp	r1, #46	; 0x2e
                pcBuftmp--;
    4d50:	f1aa 0302 	sub.w	r3, sl, #2
                if ( *pcBuftmp == '.' )
    4d54:	d006      	beq.n	4d64 <am_util_stdio_vsprintf+0xff8>
                else if ( *pcBuftmp == '9' )
    4d56:	2939      	cmp	r1, #57	; 0x39
    4d58:	f040 80d9 	bne.w	4f0e <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
    4d5c:	f04f 0330 	mov.w	r3, #48	; 0x30
    4d60:	f80a 3c02 	strb.w	r3, [sl, #-2]
                if ( *pcBuftmp == '.' )
    4d64:	f81a 1c03 	ldrb.w	r1, [sl, #-3]
    4d68:	292e      	cmp	r1, #46	; 0x2e
                pcBuftmp--;
    4d6a:	f1aa 0303 	sub.w	r3, sl, #3
                if ( *pcBuftmp == '.' )
    4d6e:	d006      	beq.n	4d7e <am_util_stdio_vsprintf+0x1012>
                else if ( *pcBuftmp == '9' )
    4d70:	2939      	cmp	r1, #57	; 0x39
    4d72:	f040 80cc 	bne.w	4f0e <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
    4d76:	f04f 0530 	mov.w	r5, #48	; 0x30
    4d7a:	f80a 5c03 	strb.w	r5, [sl, #-3]
                if ( *pcBuftmp == '.' )
    4d7e:	f81a 1c04 	ldrb.w	r1, [sl, #-4]
    4d82:	292e      	cmp	r1, #46	; 0x2e
                pcBuftmp--;
    4d84:	f1aa 0304 	sub.w	r3, sl, #4
                if ( *pcBuftmp == '.' )
    4d88:	d006      	beq.n	4d98 <am_util_stdio_vsprintf+0x102c>
                else if ( *pcBuftmp == '9' )
    4d8a:	2939      	cmp	r1, #57	; 0x39
    4d8c:	f040 80bf 	bne.w	4f0e <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
    4d90:	f04f 0430 	mov.w	r4, #48	; 0x30
    4d94:	f80a 4c04 	strb.w	r4, [sl, #-4]
                if ( *pcBuftmp == '.' )
    4d98:	f81a 1c05 	ldrb.w	r1, [sl, #-5]
    4d9c:	292e      	cmp	r1, #46	; 0x2e
                pcBuftmp--;
    4d9e:	f1aa 0305 	sub.w	r3, sl, #5
                if ( *pcBuftmp == '.' )
    4da2:	d006      	beq.n	4db2 <am_util_stdio_vsprintf+0x1046>
                else if ( *pcBuftmp == '9' )
    4da4:	2939      	cmp	r1, #57	; 0x39
    4da6:	f040 80b2 	bne.w	4f0e <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
    4daa:	f04f 0130 	mov.w	r1, #48	; 0x30
    4dae:	f80a 1c05 	strb.w	r1, [sl, #-5]
                if ( *pcBuftmp == '.' )
    4db2:	f81a 1c06 	ldrb.w	r1, [sl, #-6]
    4db6:	292e      	cmp	r1, #46	; 0x2e
                pcBuftmp--;
    4db8:	f1aa 0306 	sub.w	r3, sl, #6
                if ( *pcBuftmp == '.' )
    4dbc:	d006      	beq.n	4dcc <am_util_stdio_vsprintf+0x1060>
                else if ( *pcBuftmp == '9' )
    4dbe:	2939      	cmp	r1, #57	; 0x39
    4dc0:	f040 80a5 	bne.w	4f0e <am_util_stdio_vsprintf+0x11a2>
                    *pcBuftmp = '0';
    4dc4:	f04f 0c30 	mov.w	ip, #48	; 0x30
    4dc8:	f80a cc06 	strb.w	ip, [sl, #-6]
                pcBuftmp--;
    4dcc:	f1aa 0307 	sub.w	r3, sl, #7
            while ( pcBuftmp >= pcBufInitial )
    4dd0:	42bb      	cmp	r3, r7
    4dd2:	d199      	bne.n	4d08 <am_util_stdio_vsprintf+0xf9c>
    4dd4:	e62e      	b.n	4a34 <am_util_stdio_vsprintf+0xcc8>
        switch ( *pcFmt )
    4dd6:	f04f 0c01 	mov.w	ip, #1
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    4dda:	f10b 0307 	add.w	r3, fp, #7
    4dde:	f023 0a07 	bic.w	sl, r3, #7
    4de2:	f10a 0b08 	add.w	fp, sl, #8
    4de6:	e9da 2300 	ldrd	r2, r3, [sl]
    4dea:	f7ff b877 	b.w	3edc <am_util_stdio_vsprintf+0x170>
                while (*pcStr != 0x0)
    4dee:	7801      	ldrb	r1, [r0, #0]
    4df0:	b369      	cbz	r1, 4e4e <am_util_stdio_vsprintf+0x10e2>
        return ui32RetVal;
    4df2:	4607      	mov	r7, r0
    4df4:	2201      	movs	r2, #1
    4df6:	f7ff bb40 	b.w	447a <am_util_stdio_vsprintf+0x70e>
                iVal = uint64_to_str(ui64Val, pcBuf);
    4dfa:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
    4dfe:	463a      	mov	r2, r7
    4e00:	f7fe feb6 	bl	3b70 <uint64_to_str>
    4e04:	46b8      	mov	r8, r7
                ui32CharCnt += iVal;
    4e06:	4481      	add	r9, r0
    4e08:	f7ff b962 	b.w	40d0 <am_util_stdio_vsprintf+0x364>
                        if ( iVal == AM_FTOA_ERR_VAL_TOO_SMALL )
    4e0c:	1c43      	adds	r3, r0, #1
    4e0e:	d032      	beq.n	4e76 <am_util_stdio_vsprintf+0x110a>
                        else if ( iVal == AM_FTOA_ERR_VAL_TOO_LARGE )
    4e10:	3002      	adds	r0, #2
    4e12:	d036      	beq.n	4e82 <am_util_stdio_vsprintf+0x1116>
                            u32PrntErrVal = (0x00 << 24) | ('?' << 16) |
    4e14:	4a4d      	ldr	r2, [pc, #308]	; (4f4c <am_util_stdio_vsprintf+0x11e0>)
                        *(uint32_t*)pcBuf = u32PrntErrVal;
    4e16:	f8c8 2000 	str.w	r2, [r8]
    4e1a:	f04f 0a03 	mov.w	sl, #3
    4e1e:	f7ff b955 	b.w	40cc <am_util_stdio_vsprintf+0x360>
                iVal = uint64_to_str(ui64Val, pcBuf);
    4e22:	4642      	mov	r2, r8
    4e24:	f7fe fea4 	bl	3b70 <uint64_to_str>
                        ++ui32CharCnt;
    4e28:	f109 0901 	add.w	r9, r9, #1
                ui32CharCnt += iVal;
    4e2c:	4481      	add	r9, r0
    4e2e:	f7ff b94f 	b.w	40d0 <am_util_stdio_vsprintf+0x364>
    if ( i32NumChars <= 0 )
    4e32:	2200      	movs	r2, #0
    4e34:	2500      	movs	r5, #0
    4e36:	f7ff bb91 	b.w	455c <am_util_stdio_vsprintf+0x7f0>
    4e3a:	2200      	movs	r2, #0
                        pcBuf += pcBuf ? iWidth : 0;
    4e3c:	f1b8 0f00 	cmp.w	r8, #0
    4e40:	f43f abf9 	beq.w	4636 <am_util_stdio_vsprintf+0x8ca>
    4e44:	4614      	mov	r4, r2
    4e46:	f7ff bbed 	b.w	4624 <am_util_stdio_vsprintf+0x8b8>
                if ( iWidth > 0 )
    4e4a:	2c00      	cmp	r4, #0
    4e4c:	dc02      	bgt.n	4e54 <am_util_stdio_vsprintf+0x10e8>
        return ui32RetVal;
    4e4e:	460f      	mov	r7, r1
    4e50:	f7ff bb21 	b.w	4496 <am_util_stdio_vsprintf+0x72a>
                    if ( ui32strlen < iWidth )
    4e54:	460f      	mov	r7, r1
    4e56:	f7ff bb88 	b.w	456a <am_util_stdio_vsprintf+0x7fe>
                            if ( pcBuf )
    4e5a:	f1b8 0f00 	cmp.w	r8, #0
    4e5e:	f43f ada3 	beq.w	49a8 <am_util_stdio_vsprintf+0xc3c>
                            ++ui32CharCnt;
    4e62:	2401      	movs	r4, #1
                                *pcBuf++ = '-';
    4e64:	232d      	movs	r3, #45	; 0x2d
    4e66:	f888 3000 	strb.w	r3, [r8]
                            ++ui32CharCnt;
    4e6a:	f109 0901 	add.w	r9, r9, #1
                        --iWidth;
    4e6e:	460f      	mov	r7, r1
                            ++ui32CharCnt;
    4e70:	941b      	str	r4, [sp, #108]	; 0x6c
                                *pcBuf++ = '-';
    4e72:	44a0      	add	r8, r4
    4e74:	e531      	b.n	48da <am_util_stdio_vsprintf+0xb6e>
                            u32PrntErrVal = (0x00 << 24) | ('0' << 16) |
    4e76:	4a36      	ldr	r2, [pc, #216]	; (4f50 <am_util_stdio_vsprintf+0x11e4>)
    4e78:	e7cd      	b.n	4e16 <am_util_stdio_vsprintf+0x10aa>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    4e7a:	f04f 0a00 	mov.w	sl, #0
        uCnt++;
    4e7e:	2201      	movs	r2, #1
    4e80:	e5eb      	b.n	4a5a <am_util_stdio_vsprintf+0xcee>
                            u32PrntErrVal = (0x00 << 24) | ('#' << 16) |
    4e82:	4a34      	ldr	r2, [pc, #208]	; (4f54 <am_util_stdio_vsprintf+0x11e8>)
    4e84:	e7c7      	b.n	4e16 <am_util_stdio_vsprintf+0x10aa>
                    pcBuf += pcBuf ? iWidth : 0;
    4e86:	f1b8 0f00 	cmp.w	r8, #0
    4e8a:	d13d      	bne.n	4f08 <am_util_stdio_vsprintf+0x119c>
    4e8c:	4640      	mov	r0, r8
    4e8e:	e594      	b.n	49ba <am_util_stdio_vsprintf+0xc4e>
        i32FracPart = (i32Significand & 0x00FFFFFF) >> -(iExp2 + 1);
    4e90:	43cd      	mvns	r5, r1
    if (unFloatValue.I32 < 0)
    4e92:	2f00      	cmp	r7, #0
        i32FracPart = (i32Significand & 0x00FFFFFF) >> -(iExp2 + 1);
    4e94:	fa40 f405 	asr.w	r4, r0, r5
    if (unFloatValue.I32 < 0)
    4e98:	db27      	blt.n	4eea <am_util_stdio_vsprintf+0x117e>
    4e9a:	4643      	mov	r3, r8
        *pcBuf++ = '0';
    4e9c:	f04f 0030 	mov.w	r0, #48	; 0x30
    4ea0:	7018      	strb	r0, [r3, #0]
    4ea2:	1c5d      	adds	r5, r3, #1
    4ea4:	e5f8      	b.n	4a98 <am_util_stdio_vsprintf+0xd2c>
                    iWidth -= ndigits_in_i64(ui64Val);
    4ea6:	1b3f      	subs	r7, r7, r4
                    bNeg = false;
    4ea8:	2400      	movs	r4, #0
    4eaa:	941b      	str	r4, [sp, #108]	; 0x6c
    4eac:	e515      	b.n	48da <am_util_stdio_vsprintf+0xb6e>
    if (i32IntPart == 0)
    4eae:	4643      	mov	r3, r8
    i32FracPart = 0;
    4eb0:	2400      	movs	r4, #0
        if (i32IntPart > 0)
    4eb2:	2800      	cmp	r0, #0
    4eb4:	dc37      	bgt.n	4f26 <am_util_stdio_vsprintf+0x11ba>
            *pcBuf++ = '-';
    4eb6:	1c5d      	adds	r5, r3, #1
    4eb8:	272d      	movs	r7, #45	; 0x2d
            uint64_to_str(-i32IntPart, pcBuf);
    4eba:	4240      	negs	r0, r0
    4ebc:	17c1      	asrs	r1, r0, #31
    4ebe:	462a      	mov	r2, r5
            *pcBuf++ = '-';
    4ec0:	701f      	strb	r7, [r3, #0]
            uint64_to_str(-i32IntPart, pcBuf);
    4ec2:	f7fe fe55 	bl	3b70 <uint64_to_str>
    4ec6:	e5e1      	b.n	4a8c <am_util_stdio_vsprintf+0xd20>
        *pcBuf++ = '-';
    4ec8:	f04f 0e2d 	mov.w	lr, #45	; 0x2d
    4ecc:	f888 e000 	strb.w	lr, [r8]
    4ed0:	f108 0301 	add.w	r3, r8, #1
    if (i32IntPart == 0)
    4ed4:	bb78      	cbnz	r0, 4f36 <am_util_stdio_vsprintf+0x11ca>
    *pcBuf++ = '.';
    4ed6:	272e      	movs	r7, #46	; 0x2e
        *pcBuf++ = '0';
    4ed8:	f04f 0030 	mov.w	r0, #48	; 0x30
    4edc:	f888 0001 	strb.w	r0, [r8, #1]
    *pcBuf++ = '.';
    4ee0:	f888 7002 	strb.w	r7, [r8, #2]
        *pcBuf++ = '0';
    4ee4:	f108 0502 	add.w	r5, r8, #2
    4ee8:	e59e      	b.n	4a28 <am_util_stdio_vsprintf+0xcbc>
        *pcBuf++ = '-';
    4eea:	f04f 0c2d 	mov.w	ip, #45	; 0x2d
    4eee:	f888 c000 	strb.w	ip, [r8]
    4ef2:	f108 0301 	add.w	r3, r8, #1
    4ef6:	e7d1      	b.n	4e9c <am_util_stdio_vsprintf+0x1130>
    4ef8:	272d      	movs	r7, #45	; 0x2d
    4efa:	f888 7000 	strb.w	r7, [r8]
    4efe:	f108 0301 	add.w	r3, r8, #1
    if (i32IntPart == 0)
    4f02:	2800      	cmp	r0, #0
    4f04:	d0ca      	beq.n	4e9c <am_util_stdio_vsprintf+0x1130>
    4f06:	e7d4      	b.n	4eb2 <am_util_stdio_vsprintf+0x1146>
    4f08:	f04f 0e00 	mov.w	lr, #0
    4f0c:	e535      	b.n	497a <am_util_stdio_vsprintf+0xc0e>
                    *pcBuftmp += 1;
    4f0e:	3101      	adds	r1, #1
    4f10:	7019      	strb	r1, [r3, #0]
    4f12:	e58f      	b.n	4a34 <am_util_stdio_vsprintf+0xcc8>
    int iNDigits = ui64Val ? 0 : 1;
    4f14:	460b      	mov	r3, r1
    4f16:	4301      	orrs	r1, r0
    4f18:	4602      	mov	r2, r0
    4f1a:	bf0c      	ite	eq
    4f1c:	2401      	moveq	r4, #1
    4f1e:	2400      	movne	r4, #0
                    bNeg = true;
    4f20:	2001      	movs	r0, #1
    4f22:	f7ff b906 	b.w	4132 <am_util_stdio_vsprintf+0x3c6>
        if (i32IntPart > 0)
    4f26:	461d      	mov	r5, r3
    4f28:	e5ac      	b.n	4a84 <am_util_stdio_vsprintf+0xd18>
                iVal = uint64_to_str(ui64Val, pcBuf);
    4f2a:	4642      	mov	r2, r8
    4f2c:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
    4f30:	f7fe fe1e 	bl	3b70 <uint64_to_str>
    4f34:	e4b4      	b.n	48a0 <am_util_stdio_vsprintf+0xb34>
    i32FracPart = 0;
    4f36:	2400      	movs	r4, #0
    4f38:	e7bb      	b.n	4eb2 <am_util_stdio_vsprintf+0x1146>
    4f3a:	f1ca 0430 	rsb	r4, sl, #48	; 0x30
    4f3e:	7832      	ldrb	r2, [r6, #0]
    4f40:	f7fe bf7c 	b.w	3e3c <am_util_stdio_vsprintf+0xd0>
        bLower = bLongLong = false;
    4f44:	f04f 0c00 	mov.w	ip, #0
    4f48:	e747      	b.n	4dda <am_util_stdio_vsprintf+0x106e>
    4f4a:	bf00      	nop
    4f4c:	003f2e3f 	.word	0x003f2e3f
    4f50:	00302e30 	.word	0x00302e30
    4f54:	00232e23 	.word	0x00232e23

00004f58 <am_util_stdio_sprintf>:
//! @return uint32_t representing the number of characters printed.
//
//******************************************************************************
uint32_t
am_util_stdio_sprintf(char *pcBuf, const char *pcFmt, ...)
{
    4f58:	b40e      	push	{r1, r2, r3}
    4f5a:	b500      	push	{lr}
    4f5c:	b082      	sub	sp, #8
    4f5e:	aa03      	add	r2, sp, #12
    4f60:	f852 1b04 	ldr.w	r1, [r2], #4
    uint32_t ui32CharCnt;

    va_list pArgs;
    va_start(pArgs, pcFmt);
    4f64:	9201      	str	r2, [sp, #4]
    ui32CharCnt = am_util_stdio_vsprintf(pcBuf, pcFmt, pArgs);
    4f66:	f7fe ff01 	bl	3d6c <am_util_stdio_vsprintf>
    va_end(pArgs);

    return ui32CharCnt;
}
    4f6a:	b002      	add	sp, #8
    4f6c:	f85d eb04 	ldr.w	lr, [sp], #4
    4f70:	b003      	add	sp, #12
    4f72:	4770      	bx	lr

00004f74 <am_util_stdio_printf>:
//! @return uint32_t representing the number of characters printed.
//
// *****************************************************************************
uint32_t
am_util_stdio_printf(const char *pcFmt, ...)
{
    4f74:	b40f      	push	{r0, r1, r2, r3}
    4f76:	b530      	push	{r4, r5, lr}
    4f78:	b083      	sub	sp, #12
    4f7a:	aa06      	add	r2, sp, #24
    //
    // Convert to the desired string.
    //
    va_list pArgs;
    va_start(pArgs, pcFmt);
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
    4f7c:	4c08      	ldr	r4, [pc, #32]	; (4fa0 <am_util_stdio_printf+0x2c>)
{
    4f7e:	f852 1b04 	ldr.w	r1, [r2], #4
    va_start(pArgs, pcFmt);
    4f82:	9201      	str	r2, [sp, #4]
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
    4f84:	4620      	mov	r0, r4
    4f86:	f7fe fef1 	bl	3d6c <am_util_stdio_vsprintf>
    va_end(pArgs);

    //
    // This is where we print the buffer to the configured interface.
    //
    g_pfnCharPrint(g_prfbuf);
    4f8a:	4b06      	ldr	r3, [pc, #24]	; (4fa4 <am_util_stdio_printf+0x30>)
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
    4f8c:	4605      	mov	r5, r0
    g_pfnCharPrint(g_prfbuf);
    4f8e:	6819      	ldr	r1, [r3, #0]
    4f90:	4620      	mov	r0, r4
    4f92:	4788      	blx	r1

    //
    // return the number of characters printed.
    //
    return ui32NumChars;
}
    4f94:	4628      	mov	r0, r5
    4f96:	b003      	add	sp, #12
    4f98:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    4f9c:	b004      	add	sp, #16
    4f9e:	4770      	bx	lr
    4fa0:	10001068 	.word	0x10001068
    4fa4:	1000156c 	.word	0x1000156c

00004fa8 <am_util_stdio_terminal_clear>:
    // left corner.
    // We'll first print a number of spaces, which helps get the ITM in sync
    // with AM Flash, especially after a reset event or a system clock
    // frequency change.
    //
    am_util_stdio_printf("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
    4fa8:	4801      	ldr	r0, [pc, #4]	; (4fb0 <am_util_stdio_terminal_clear+0x8>)
    4faa:	f7ff bfe3 	b.w	4f74 <am_util_stdio_printf>
    4fae:	bf00      	nop
    4fb0:	00005854 	.word	0x00005854

00004fb4 <am_bsp_low_power_init>:
//! @return None.
//
//*****************************************************************************
void
am_bsp_low_power_init(void)
{
    4fb4:	b508      	push	{r3, lr}
    //
    // Enable internal buck converters.
    //
    am_hal_mcuctrl_bucks_enable();
    4fb6:	f000 f879 	bl	50ac <am_hal_mcuctrl_bucks_enable>

    //
    // Turn off the voltage comparator as this is enabled on reset.
    //
    am_hal_vcomp_disable();
    4fba:	f000 f969 	bl	5290 <am_hal_vcomp_disable>

    //
    // Run the RTC off the LFRC.
    //
    am_hal_rtc_osc_select(AM_HAL_RTC_OSC_LFRC);
    4fbe:	2001      	movs	r0, #1
    4fc0:	f000 f88a 	bl	50d8 <am_hal_rtc_osc_select>

    //
    // Stop the XTAL.
    //
    am_hal_clkgen_osc_stop(AM_HAL_CLKGEN_OSC_XT);
    4fc4:	2001      	movs	r0, #1
    4fc6:	f000 f827 	bl	5018 <am_hal_clkgen_osc_stop>

    //
    // Disable the RTC.
    //
    am_hal_rtc_osc_disable();
    4fca:	f000 f893 	bl	50f4 <am_hal_rtc_osc_disable>

    //
    // Disable the bandgap.
    //
    am_hal_mcuctrl_bandgap_disable();
}
    4fce:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    am_hal_mcuctrl_bandgap_disable();
    4fd2:	f000 b863 	b.w	509c <am_hal_mcuctrl_bandgap_disable>
    4fd6:	bf00      	nop

00004fd8 <am_bsp_uart_string_print>:
//
//*****************************************************************************
void
am_bsp_uart_string_print(char *pcString)
{
    am_hal_uart_string_transmit_polled(0, pcString);
    4fd8:	4601      	mov	r1, r0
    4fda:	2000      	movs	r0, #0
    4fdc:	f000 b944 	b.w	5268 <am_hal_uart_string_transmit_polled>

00004fe0 <am_hal_clkgen_sysclk_select>:
am_hal_clkgen_sysclk_select(uint32_t ui32ClockSetting)
{
    //
    // Unlock the clock control register.
    //
    AM_REG(CLKGEN, CLKKEY) = AM_REG_CLKGEN_CLKKEY_KEYVAL;
    4fe0:	4b05      	ldr	r3, [pc, #20]	; (4ff8 <am_hal_clkgen_sysclk_select+0x18>)

    //
    // Set the HFRC divisor to the user-selected value.
    //
    AM_REG(CLKGEN, CCTRL) = ui32ClockSetting;
    4fe2:	4906      	ldr	r1, [pc, #24]	; (4ffc <am_hal_clkgen_sysclk_select+0x1c>)
{
    4fe4:	b410      	push	{r4}

    //
    // Lock the clock configuration registers.
    //
    AM_REG(CLKGEN, CLKKEY) = 0;
    4fe6:	2200      	movs	r2, #0
    AM_REG(CLKGEN, CLKKEY) = AM_REG_CLKGEN_CLKKEY_KEYVAL;
    4fe8:	2447      	movs	r4, #71	; 0x47
    4fea:	601c      	str	r4, [r3, #0]
    AM_REG(CLKGEN, CCTRL) = ui32ClockSetting;
    4fec:	6008      	str	r0, [r1, #0]
}
    4fee:	f85d 4b04 	ldr.w	r4, [sp], #4
    AM_REG(CLKGEN, CLKKEY) = 0;
    4ff2:	601a      	str	r2, [r3, #0]
}
    4ff4:	4770      	bx	lr
    4ff6:	bf00      	nop
    4ff8:	40004014 	.word	0x40004014
    4ffc:	40004018 	.word	0x40004018

00005000 <am_hal_clkgen_sysclk_get>:
    uint32_t ui32ClockSetting;

    //
    // Read the value of the clock divider.
    //
    ui32ClockSetting = AM_BFR(CLKGEN, CCTRL, CORESEL);
    5000:	4b03      	ldr	r3, [pc, #12]	; (5010 <am_hal_clkgen_sysclk_get+0x10>)
    5002:	4a04      	ldr	r2, [pc, #16]	; (5014 <am_hal_clkgen_sysclk_get+0x14>)
    5004:	6818      	ldr	r0, [r3, #0]
    5006:	f000 0107 	and.w	r1, r0, #7
        case AM_HAL_CLKGEN_SYSCLK_3MHZ:
            return 3000000;
        default:
            return 0xFFFFFFFF;
    }
}
    500a:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
    500e:	4770      	bx	lr
    5010:	40004018 	.word	0x40004018
    5014:	00005868 	.word	0x00005868

00005018 <am_hal_clkgen_osc_stop>:
//
//*****************************************************************************
void
am_hal_clkgen_osc_stop(uint32_t ui32OscFlags)
{
    if ( ui32OscFlags & (AM_HAL_CLKGEN_OSC_LFRC | AM_HAL_CLKGEN_OSC_XT) )
    5018:	0783      	lsls	r3, r0, #30
    501a:	d003      	beq.n	5024 <am_hal_clkgen_osc_stop+0xc>
    {
        //
        // Stop the oscillator(s).
        // Note that these bits are set in order to stop the oscillator.
        //
        AM_REG(CLKGEN, OCTRL) |= ui32OscFlags;
    501c:	4b02      	ldr	r3, [pc, #8]	; (5028 <am_hal_clkgen_osc_stop+0x10>)
    501e:	681a      	ldr	r2, [r3, #0]
    5020:	4310      	orrs	r0, r2
    5022:	6018      	str	r0, [r3, #0]
    5024:	4770      	bx	lr
    5026:	bf00      	nop
    5028:	4000400c 	.word	0x4000400c

0000502c <am_hal_flash_delay>:
}
#elif defined(__GNUC_STDC_INLINE__)
void __attribute__((naked))
am_hal_flash_delay(uint32_t ui32Iterations)
{
    __asm("    subs    r0, #1\n"
    502c:	3801      	subs	r0, #1
    502e:	f47f affd 	bne.w	502c <am_hal_flash_delay>
    5032:	4770      	bx	lr

00005034 <am_hal_mcuctrl_fault_status>:
    psFault->bSYS = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_SYS_M);

    //
    // Read the DCODE fault capture address register.
    //
    psFault->ui32DCODE = AM_REG(MCUCTRL, DCODEFAULTADDR);
    5034:	490d      	ldr	r1, [pc, #52]	; (506c <am_hal_mcuctrl_fault_status+0x38>)
    ui32FaultStat = AM_REG(MCUCTRL, FAULTSTATUS);
    5036:	4b0e      	ldr	r3, [pc, #56]	; (5070 <am_hal_mcuctrl_fault_status+0x3c>)

    //
    // Read the ICODE fault capture address register.
    //
    psFault->ui32ICODE |= AM_REG(MCUCTRL, ICODEFAULTADDR);
    5038:	4a0e      	ldr	r2, [pc, #56]	; (5074 <am_hal_mcuctrl_fault_status+0x40>)
    ui32FaultStat = AM_REG(MCUCTRL, FAULTSTATUS);
    503a:	681b      	ldr	r3, [r3, #0]
{
    503c:	b470      	push	{r4, r5, r6}
    psFault->ui32DCODE = AM_REG(MCUCTRL, DCODEFAULTADDR);
    503e:	680d      	ldr	r5, [r1, #0]
    5040:	60c5      	str	r5, [r0, #12]
    psFault->ui32ICODE |= AM_REG(MCUCTRL, ICODEFAULTADDR);
    5042:	6815      	ldr	r5, [r2, #0]
    5044:	6841      	ldr	r1, [r0, #4]

    //
    // Read the ICODE fault capture address register.
    //
    psFault->ui32SYS |= AM_REG(MCUCTRL, SYSFAULTADDR);
    5046:	4c0c      	ldr	r4, [pc, #48]	; (5078 <am_hal_mcuctrl_fault_status+0x44>)
    5048:	6942      	ldr	r2, [r0, #20]
    psFault->ui32ICODE |= AM_REG(MCUCTRL, ICODEFAULTADDR);
    504a:	4329      	orrs	r1, r5
    504c:	6041      	str	r1, [r0, #4]
    psFault->ui32SYS |= AM_REG(MCUCTRL, SYSFAULTADDR);
    504e:	6824      	ldr	r4, [r4, #0]
    psFault->bICODE = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_ICODE_M);
    5050:	f003 0601 	and.w	r6, r3, #1
    psFault->ui32SYS |= AM_REG(MCUCTRL, SYSFAULTADDR);
    5054:	4322      	orrs	r2, r4
    psFault->bICODE = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_ICODE_M);
    5056:	7006      	strb	r6, [r0, #0]
    psFault->bDCODE = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_DCODE_M);
    5058:	f3c3 0640 	ubfx	r6, r3, #1, #1
    psFault->bSYS = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_SYS_M);
    505c:	f3c3 0380 	ubfx	r3, r3, #2, #1
    psFault->bDCODE = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_DCODE_M);
    5060:	7206      	strb	r6, [r0, #8]
    psFault->bSYS = (ui32FaultStat & AM_REG_MCUCTRL_FAULTSTATUS_SYS_M);
    5062:	7403      	strb	r3, [r0, #16]
    psFault->ui32SYS |= AM_REG(MCUCTRL, SYSFAULTADDR);
    5064:	6142      	str	r2, [r0, #20]
}
    5066:	bc70      	pop	{r4, r5, r6}
    5068:	4770      	bx	lr
    506a:	bf00      	nop
    506c:	400201c4 	.word	0x400201c4
    5070:	400201cc 	.word	0x400201cc
    5074:	400201c0 	.word	0x400201c0
    5078:	400201c8 	.word	0x400201c8

0000507c <am_hal_mcuctrl_flash_power_set>:
am_hal_mcuctrl_flash_power_set(uint32_t ui32FlashPower)
{
    //
    // Write desired flash power state.
    //
    AM_REG(MCUCTRL, FLASHPWRDIS) = ui32FlashPower;
    507c:	4b01      	ldr	r3, [pc, #4]	; (5084 <am_hal_mcuctrl_flash_power_set+0x8>)
    507e:	6018      	str	r0, [r3, #0]
    5080:	4770      	bx	lr
    5082:	bf00      	nop
    5084:	40020148 	.word	0x40020148

00005088 <am_hal_mcuctrl_sram_power_set>:
                              uint32_t ui32SRAMPowerDeepSleep)
{
    //
    // Write desired SRAM power state.
    //
    AM_REG(MCUCTRL, SRAMPWRDIS) = ui32SRAMPower;
    5088:	4a02      	ldr	r2, [pc, #8]	; (5094 <am_hal_mcuctrl_sram_power_set+0xc>)

    //
    // Write desired SRAM deep sleep power state.
    //
    AM_REG(MCUCTRL, SRAMPWDINSLEEP) = ui32SRAMPowerDeepSleep;
    508a:	4b03      	ldr	r3, [pc, #12]	; (5098 <am_hal_mcuctrl_sram_power_set+0x10>)
    AM_REG(MCUCTRL, SRAMPWRDIS) = ui32SRAMPower;
    508c:	6010      	str	r0, [r2, #0]
    AM_REG(MCUCTRL, SRAMPWDINSLEEP) = ui32SRAMPowerDeepSleep;
    508e:	6019      	str	r1, [r3, #0]
    5090:	4770      	bx	lr
    5092:	bf00      	nop
    5094:	40020144 	.word	0x40020144
    5098:	40020140 	.word	0x40020140

0000509c <am_hal_mcuctrl_bandgap_disable>:
am_hal_mcuctrl_bandgap_disable(void)
{
    //
    // Disable the Bandgap in the MCUCTRL.
    //
    AM_REG(MCUCTRL, BANDGAPEN) = ~AM_REG_MCUCTRL_BANDGAPEN_BGPEN_M;
    509c:	4b02      	ldr	r3, [pc, #8]	; (50a8 <am_hal_mcuctrl_bandgap_disable+0xc>)
    509e:	f06f 0201 	mvn.w	r2, #1
    50a2:	601a      	str	r2, [r3, #0]
    50a4:	4770      	bx	lr
    50a6:	bf00      	nop
    50a8:	400200fc 	.word	0x400200fc

000050ac <am_hal_mcuctrl_bucks_enable>:
am_hal_mcuctrl_bucks_enable(void)
{
    //
    // Enable the core buck converter in the MCUCTRL.
    //
    AM_BFW(MCUCTRL, SUPPLYSRC, COREBUCKEN, 1);
    50ac:	4b08      	ldr	r3, [pc, #32]	; (50d0 <am_hal_mcuctrl_bucks_enable+0x24>)
    AM_BFW(MCUCTRL, SUPPLYSRC, MEMBUCKEN, 1);

    //
    // Poll until core buck is enabled.
    //
    while( !AM_BFR(MCUCTRL, SUPPLYSTATUS, COREBUCKON) );
    50ae:	4a09      	ldr	r2, [pc, #36]	; (50d4 <am_hal_mcuctrl_bucks_enable+0x28>)
    AM_BFW(MCUCTRL, SUPPLYSRC, COREBUCKEN, 1);
    50b0:	6819      	ldr	r1, [r3, #0]
    50b2:	f041 0002 	orr.w	r0, r1, #2
    50b6:	6018      	str	r0, [r3, #0]
    AM_BFW(MCUCTRL, SUPPLYSRC, MEMBUCKEN, 1);
    50b8:	6819      	ldr	r1, [r3, #0]
    50ba:	f041 0001 	orr.w	r0, r1, #1
    50be:	6018      	str	r0, [r3, #0]
    while( !AM_BFR(MCUCTRL, SUPPLYSTATUS, COREBUCKON) );
    50c0:	6813      	ldr	r3, [r2, #0]
    50c2:	0799      	lsls	r1, r3, #30
    50c4:	d5fc      	bpl.n	50c0 <am_hal_mcuctrl_bucks_enable+0x14>

    //
    // Poll until SRAM buck is enabled.
    //
    while( !AM_BFR(MCUCTRL, SUPPLYSTATUS, MEMBUCKON) );
    50c6:	4a03      	ldr	r2, [pc, #12]	; (50d4 <am_hal_mcuctrl_bucks_enable+0x28>)
    50c8:	6811      	ldr	r1, [r2, #0]
    50ca:	07cb      	lsls	r3, r1, #31
    50cc:	d5fc      	bpl.n	50c8 <am_hal_mcuctrl_bucks_enable+0x1c>
}
    50ce:	4770      	bx	lr
    50d0:	40020010 	.word	0x40020010
    50d4:	40020014 	.word	0x40020014

000050d8 <am_hal_rtc_osc_select>:
    // Set XT if flag is set.
    // Otherwise configure for LFRC.
    //
    if (ui32OSC)
    {
        AM_REG(CLKGEN, OCTRL) |= AM_REG_CLKGEN_OCTRL_OSEL_M;
    50d8:	4a05      	ldr	r2, [pc, #20]	; (50f0 <am_hal_rtc_osc_select+0x18>)
    50da:	6813      	ldr	r3, [r2, #0]
    if (ui32OSC)
    50dc:	b918      	cbnz	r0, 50e6 <am_hal_rtc_osc_select+0xe>
    }
    else
    {
        AM_REG(CLKGEN, OCTRL) &= ~AM_REG_CLKGEN_OCTRL_OSEL_M;
    50de:	f023 0080 	bic.w	r0, r3, #128	; 0x80
    50e2:	6010      	str	r0, [r2, #0]
    50e4:	4770      	bx	lr
        AM_REG(CLKGEN, OCTRL) |= AM_REG_CLKGEN_OCTRL_OSEL_M;
    50e6:	f043 0180 	orr.w	r1, r3, #128	; 0x80
    50ea:	6011      	str	r1, [r2, #0]
    50ec:	4770      	bx	lr
    50ee:	bf00      	nop
    50f0:	4000400c 	.word	0x4000400c

000050f4 <am_hal_rtc_osc_disable>:
am_hal_rtc_osc_disable(void)
{
    //
    // Stop the RTC Oscillator.
    //
    AM_BFW(RTC, RTCCTL, RSTOP, 1);
    50f4:	4a02      	ldr	r2, [pc, #8]	; (5100 <am_hal_rtc_osc_disable+0xc>)
    50f6:	6813      	ldr	r3, [r2, #0]
    50f8:	f043 0010 	orr.w	r0, r3, #16
    50fc:	6010      	str	r0, [r2, #0]
    50fe:	4770      	bx	lr
    5100:	40004050 	.word	0x40004050

00005104 <am_hal_sysctrl_fpu_enable>:
{
    //
    // Enable access to the FPU in both privileged and user modes.
    // NOTE: Write 0s to all reserved fields in this register.
    //
    AM_REG(SYSCTRL, CPACR) = (AM_REG_SYSCTRL_CPACR_CP11(0x3) |
    5104:	4b02      	ldr	r3, [pc, #8]	; (5110 <am_hal_sysctrl_fpu_enable+0xc>)
    5106:	f44f 0270 	mov.w	r2, #15728640	; 0xf00000
    510a:	601a      	str	r2, [r3, #0]
    510c:	4770      	bx	lr
    510e:	bf00      	nop
    5110:	e000ed88 	.word	0xe000ed88

00005114 <am_hal_sysctrl_fpu_stacking_enable>:
    {
        //
        // Enable automatic saving of FPU registers on exception entry, using lazy
        // context saving.
        //
        AM_REG(SYSCTRL, FPCCR) |= (AM_REG_SYSCTRL_FPCCR_ASPEN(0x1) |
    5114:	4a05      	ldr	r2, [pc, #20]	; (512c <am_hal_sysctrl_fpu_stacking_enable+0x18>)
    5116:	6813      	ldr	r3, [r2, #0]
    if (bLazy)
    5118:	b918      	cbnz	r0, 5122 <am_hal_sysctrl_fpu_stacking_enable+0xe>
    else
    {
        //
        // Enable automatic saving of FPU registers on exception entry.
        //
        AM_REG(SYSCTRL, FPCCR) |= AM_REG_SYSCTRL_FPCCR_ASPEN(0x1);
    511a:	f043 4000 	orr.w	r0, r3, #2147483648	; 0x80000000
    511e:	6010      	str	r0, [r2, #0]
    5120:	4770      	bx	lr
        AM_REG(SYSCTRL, FPCCR) |= (AM_REG_SYSCTRL_FPCCR_ASPEN(0x1) |
    5122:	f043 4140 	orr.w	r1, r3, #3221225472	; 0xc0000000
    5126:	6011      	str	r1, [r2, #0]
    5128:	4770      	bx	lr
    512a:	bf00      	nop
    512c:	e000ef34 	.word	0xe000ef34

00005130 <am_hal_systick_start>:
am_hal_systick_start(void)
{
    //
    // Start the systick timer.
    //
    AM_REG(SYSTICK, SYSTCSR) |= AM_REG_SYSTICK_SYSTCSR_ENABLE_M;
    5130:	4a02      	ldr	r2, [pc, #8]	; (513c <am_hal_systick_start+0xc>)
    5132:	6813      	ldr	r3, [r2, #0]
    5134:	f043 0001 	orr.w	r0, r3, #1
    5138:	6010      	str	r0, [r2, #0]
    513a:	4770      	bx	lr
    513c:	e000e010 	.word	0xe000e010

00005140 <am_hal_systick_stop>:
am_hal_systick_stop(void)
{
    //
    // Stop the systick timer.
    //
    AM_REG(SYSTICK, SYSTCSR) &= ~AM_REG_SYSTICK_SYSTCSR_ENABLE_M;
    5140:	4a02      	ldr	r2, [pc, #8]	; (514c <am_hal_systick_stop+0xc>)
    5142:	6813      	ldr	r3, [r2, #0]
    5144:	f023 0001 	bic.w	r0, r3, #1
    5148:	6010      	str	r0, [r2, #0]
    514a:	4770      	bx	lr
    514c:	e000e010 	.word	0xe000e010

00005150 <am_hal_systick_int_enable>:
am_hal_systick_int_enable(void)
{
    //
    // Enable the systick timer interrupt.
    //
    AM_REG(SYSTICK, SYSTCSR) |= AM_REG_SYSTICK_SYSTCSR_TICKINT_M;
    5150:	4a02      	ldr	r2, [pc, #8]	; (515c <am_hal_systick_int_enable+0xc>)
    5152:	6813      	ldr	r3, [r2, #0]
    5154:	f043 0002 	orr.w	r0, r3, #2
    5158:	6010      	str	r0, [r2, #0]
    515a:	4770      	bx	lr
    515c:	e000e010 	.word	0xe000e010

00005160 <am_hal_systick_load>:
am_hal_systick_load(uint32_t ui32LoadVal)
{
    //
    // Write the reload register.
    //
    AM_REG(SYSTICK, SYSTRVR) = ui32LoadVal;
    5160:	4b01      	ldr	r3, [pc, #4]	; (5168 <am_hal_systick_load+0x8>)
    5162:	6018      	str	r0, [r3, #0]
    5164:	4770      	bx	lr
    5166:	bf00      	nop
    5168:	e000e014 	.word	0xe000e014

0000516c <am_hal_systick_count>:
am_hal_systick_count(void)
{
    //
    // Return the current systick timer count value.
    //
    return AM_REG(SYSTICK, SYSTCVR);
    516c:	4b01      	ldr	r3, [pc, #4]	; (5174 <am_hal_systick_count+0x8>)
    516e:	6818      	ldr	r0, [r3, #0]
}
    5170:	4770      	bx	lr
    5172:	bf00      	nop
    5174:	e000e018 	.word	0xe000e018

00005178 <am_hal_uart_config>:
//
//*****************************************************************************
void
am_hal_uart_config(uint32_t ui32Module, am_hal_uart_config_t *psConfig)

{
    5178:	b570      	push	{r4, r5, r6, lr}
    517a:	460c      	mov	r4, r1
    uint32_t ui32ConfigVal = 0;

    //
    // Configure the Baudrate.
    //
    config_baudrate(0, psConfig->ui32BaudRate, am_hal_clkgen_sysclk_get());
    517c:	680d      	ldr	r5, [r1, #0]
    517e:	f7ff ff3f 	bl	5000 <am_hal_clkgen_sysclk_get>
    ui32BaudClk = BAUDCLK * ui32Baudrate;
    5182:	0129      	lsls	r1, r5, #4
    ui32IntegerDivisor = (uint32_t)(ui32UartClkFreq / ui32BaudClk);
    5184:	fbb0 f2f1 	udiv	r2, r0, r1
    if ( ui32IntegerDivisor == 0 )
    5188:	b30a      	cbz	r2, 51ce <am_hal_uart_config+0x56>
    AM_REGn(UART, 0, IBRD) = ui32IntegerDivisor;
    518a:	4d11      	ldr	r5, [pc, #68]	; (51d0 <am_hal_uart_config+0x58>)
    AM_REGn(UART, 0, FBRD) = ui32FractionDivisor;
    518c:	4e11      	ldr	r6, [pc, #68]	; (51d4 <am_hal_uart_config+0x5c>)
    AM_REGn(UART, 0, IBRD) = ui32IntegerDivisor;
    518e:	602a      	str	r2, [r5, #0]
    ui64IntermediateLong = (ui32UartClkFreq * 64) / ui32BaudClk;
    5190:	0183      	lsls	r3, r0, #6
    5192:	fbb3 f0f1 	udiv	r0, r3, r1
    5196:	eba0 1382 	sub.w	r3, r0, r2, lsl #6
    AM_REGn(UART, 0, IBRD) = ui32IntegerDivisor;
    519a:	602a      	str	r2, [r5, #0]
    ui32ConfigVal |= psConfig->ui32Parity;

    //
    // Write config to Line control register.
    //
    AM_REGn(UART, 0, LCRH) |= ui32ConfigVal;
    519c:	490e      	ldr	r1, [pc, #56]	; (51d8 <am_hal_uart_config+0x60>)
    AM_REGn(UART, 0, FBRD) = ui32FractionDivisor;
    519e:	6033      	str	r3, [r6, #0]
    AM_REGn(UART, 0, LCRH) |= ui32ConfigVal;
    51a0:	68e6      	ldr	r6, [r4, #12]
    ui32ConfigVal |= psConfig->ui32DataBits;
    51a2:	6863      	ldr	r3, [r4, #4]
    ui32ConfigVal |= psConfig->bTwoStopBits ? AM_REG_UART_LCRH_STP2_M : 0;
    51a4:	7a25      	ldrb	r5, [r4, #8]
    AM_REGn(UART, 0, LCRH) |= ui32ConfigVal;
    51a6:	6808      	ldr	r0, [r1, #0]

    //
    // Write the flow control settings to the control register.
    //
    AM_REGn(UART, 0, CR) |= psConfig->ui32FlowCtrl;
    51a8:	4a0c      	ldr	r2, [pc, #48]	; (51dc <am_hal_uart_config+0x64>)
    AM_REGn(UART, 0, LCRH) |= ui32ConfigVal;
    51aa:	4333      	orrs	r3, r6
    ui32ConfigVal |= psConfig->bTwoStopBits ? AM_REG_UART_LCRH_STP2_M : 0;
    51ac:	2d00      	cmp	r5, #0
    AM_REGn(UART, 0, LCRH) |= ui32ConfigVal;
    51ae:	ea43 0300 	orr.w	r3, r3, r0
    ui32ConfigVal |= psConfig->bTwoStopBits ? AM_REG_UART_LCRH_STP2_M : 0;
    51b2:	bf14      	ite	ne
    51b4:	2008      	movne	r0, #8
    51b6:	2000      	moveq	r0, #0
    AM_REGn(UART, 0, LCRH) |= ui32ConfigVal;
    51b8:	4303      	orrs	r3, r0
    51ba:	600b      	str	r3, [r1, #0]
    AM_REGn(UART, 0, CR) |= psConfig->ui32FlowCtrl;
    51bc:	6811      	ldr	r1, [r2, #0]
    51be:	6924      	ldr	r4, [r4, #16]
    51c0:	4321      	orrs	r1, r4
    51c2:	6011      	str	r1, [r2, #0]

    //
    // Set the clock select field for 24MHz from the HFRC
    //
    AM_REGn(UART, 0, CR) |= AM_REG_UART_CR_CLKSEL_24MHZ;
    51c4:	6813      	ldr	r3, [r2, #0]
    51c6:	f043 0610 	orr.w	r6, r3, #16
    51ca:	6016      	str	r6, [r2, #0]
    51cc:	bd70      	pop	{r4, r5, r6, pc}
    51ce:	e7fe      	b.n	51ce <am_hal_uart_config+0x56>
    51d0:	4001c024 	.word	0x4001c024
    51d4:	4001c028 	.word	0x4001c028
    51d8:	4001c02c 	.word	0x4001c02c
    51dc:	4001c030 	.word	0x4001c030

000051e0 <am_hal_uart_enable>:
am_hal_uart_enable(uint32_t ui32Module)
{
    //
    // Enable the UART, RX, and TX.
    //
    AM_REGn(UART, 0, CR) |= (AM_REG_UART_CR_UARTEN_M   |
    51e0:	4a03      	ldr	r2, [pc, #12]	; (51f0 <am_hal_uart_enable+0x10>)
    51e2:	6813      	ldr	r3, [r2, #0]
    51e4:	f443 7040 	orr.w	r0, r3, #768	; 0x300
    51e8:	f040 0101 	orr.w	r1, r0, #1
    51ec:	6011      	str	r1, [r2, #0]
    51ee:	4770      	bx	lr
    51f0:	4001c030 	.word	0x4001c030

000051f4 <am_hal_uart_disable>:
am_hal_uart_disable(uint32_t ui32Module)
{
    //
    // Disable the UART.
    //
    AM_REGn(UART, 0, CR) &= ~(AM_REG_UART_CR_UARTEN_M  |
    51f4:	4a03      	ldr	r2, [pc, #12]	; (5204 <am_hal_uart_disable+0x10>)
    51f6:	6813      	ldr	r3, [r2, #0]
    51f8:	f423 7040 	bic.w	r0, r3, #768	; 0x300
    51fc:	f020 0101 	bic.w	r1, r0, #1
    5200:	6011      	str	r1, [r2, #0]
    5202:	4770      	bx	lr
    5204:	4001c030 	.word	0x4001c030

00005208 <am_hal_uart_clock_enable>:
am_hal_uart_clock_enable(uint32_t ui32Module)
{
    //
    // Enable the UART clock in the MCUCTRL module.
    //
    AM_REGn(CLKGEN, 0, UARTEN) |= AM_REG_CLKGEN_UARTEN_UARTEN_M;
    5208:	4907      	ldr	r1, [pc, #28]	; (5228 <am_hal_uart_clock_enable+0x20>)

    //
    // Enable the UART clock.
    //
    AM_REGn(UART, 0, CR) |= AM_REG_UART_CR_CLKEN_M;
    520a:	4b08      	ldr	r3, [pc, #32]	; (522c <am_hal_uart_clock_enable+0x24>)
    AM_REGn(CLKGEN, 0, UARTEN) |= AM_REG_CLKGEN_UARTEN_UARTEN_M;
    520c:	680a      	ldr	r2, [r1, #0]
    520e:	f042 0001 	orr.w	r0, r2, #1
    5212:	6008      	str	r0, [r1, #0]
    AM_REGn(UART, 0, CR) |= AM_REG_UART_CR_CLKEN_M;
    5214:	6819      	ldr	r1, [r3, #0]
    5216:	f041 0208 	orr.w	r2, r1, #8
    521a:	601a      	str	r2, [r3, #0]

    //
    // Select default UART clock source
    //
    AM_REGn(UART, 0, CR) |= AM_REG_UART_CR_CLKSEL_24MHZ;
    521c:	6818      	ldr	r0, [r3, #0]
    521e:	f040 0110 	orr.w	r1, r0, #16
    5222:	6019      	str	r1, [r3, #0]
    5224:	4770      	bx	lr
    5226:	bf00      	nop
    5228:	4000402c 	.word	0x4000402c
    522c:	4001c030 	.word	0x4001c030

00005230 <am_hal_uart_clock_disable>:
am_hal_uart_clock_disable(uint32_t ui32Module)
{
    //
    // Disable the UART clock.
    //
    AM_REGn(UART, 0, CR) &= ~AM_REG_UART_CR_CLKEN_M;
    5230:	4905      	ldr	r1, [pc, #20]	; (5248 <am_hal_uart_clock_disable+0x18>)

    //
    // Disable the UART clock in the CLKGEN module.
    //
    AM_REGn(CLKGEN, 0, UARTEN) &= ~AM_REG_CLKGEN_UARTEN_UARTEN_M;
    5232:	4a06      	ldr	r2, [pc, #24]	; (524c <am_hal_uart_clock_disable+0x1c>)
    AM_REGn(UART, 0, CR) &= ~AM_REG_UART_CR_CLKEN_M;
    5234:	680b      	ldr	r3, [r1, #0]
    5236:	f023 0008 	bic.w	r0, r3, #8
    523a:	6008      	str	r0, [r1, #0]
    AM_REGn(CLKGEN, 0, UARTEN) &= ~AM_REG_CLKGEN_UARTEN_UARTEN_M;
    523c:	6811      	ldr	r1, [r2, #0]
    523e:	f021 0301 	bic.w	r3, r1, #1
    5242:	6013      	str	r3, [r2, #0]
    5244:	4770      	bx	lr
    5246:	bf00      	nop
    5248:	4001c030 	.word	0x4001c030
    524c:	4000402c 	.word	0x4000402c

00005250 <am_hal_uart_fifo_config>:
am_hal_uart_fifo_config(uint32_t ui32Module, uint32_t ui32LvlCfg)
{
    //
    // Enable the use of FIFOs.
    //
    AM_REGn(UART, 0, LCRH) |= AM_REG_UART_LCRH_FEN_M;
    5250:	4a03      	ldr	r2, [pc, #12]	; (5260 <am_hal_uart_fifo_config+0x10>)

    //
    // Write the FIFO level register.
    //
    AM_REGn(UART, 0, IFLS) = ui32LvlCfg;
    5252:	4804      	ldr	r0, [pc, #16]	; (5264 <am_hal_uart_fifo_config+0x14>)
    AM_REGn(UART, 0, LCRH) |= AM_REG_UART_LCRH_FEN_M;
    5254:	6813      	ldr	r3, [r2, #0]
    5256:	f043 0310 	orr.w	r3, r3, #16
    525a:	6013      	str	r3, [r2, #0]
    AM_REGn(UART, 0, IFLS) = ui32LvlCfg;
    525c:	6001      	str	r1, [r0, #0]
    525e:	4770      	bx	lr
    5260:	4001c02c 	.word	0x4001c02c
    5264:	4001c034 	.word	0x4001c034

00005268 <am_hal_uart_string_transmit_polled>:
//
//*****************************************************************************
void
am_hal_uart_string_transmit_polled(uint32_t ui32Module, char *pcString)
{
    while ( *pcString )
    5268:	7808      	ldrb	r0, [r1, #0]
    526a:	b160      	cbz	r0, 5286 <am_hal_uart_string_transmit_polled+0x1e>
{
    526c:	b410      	push	{r4}
    {
        //
        // Wait for space, i.e.  TX FIFO EMPTY.
        //
        while ( AM_BFRn(UART, 0, FR, TXFF) );
    526e:	4a06      	ldr	r2, [pc, #24]	; (5288 <am_hal_uart_string_transmit_polled+0x20>)

        //
        // Write the char.
        //
        AM_REGn(UART, 0, DR) = *pcString++;
    5270:	4c06      	ldr	r4, [pc, #24]	; (528c <am_hal_uart_string_transmit_polled+0x24>)
        while ( AM_BFRn(UART, 0, FR, TXFF) );
    5272:	6813      	ldr	r3, [r2, #0]
    5274:	069b      	lsls	r3, r3, #26
    5276:	d4fc      	bmi.n	5272 <am_hal_uart_string_transmit_polled+0xa>
        AM_REGn(UART, 0, DR) = *pcString++;
    5278:	6020      	str	r0, [r4, #0]
    while ( *pcString )
    527a:	f811 0f01 	ldrb.w	r0, [r1, #1]!
    527e:	2800      	cmp	r0, #0
    5280:	d1f7      	bne.n	5272 <am_hal_uart_string_transmit_polled+0xa>
    }
}
    5282:	f85d 4b04 	ldr.w	r4, [sp], #4
    5286:	4770      	bx	lr
    5288:	4001c018 	.word	0x4001c018
    528c:	4001c000 	.word	0x4001c000

00005290 <am_hal_vcomp_disable>:
//
//*****************************************************************************
void
am_hal_vcomp_disable(void)
{
    AM_REG(VCOMP, PWDKEY) = AM_REG_VCOMP_PWDKEY_KEYVAL;
    5290:	4b01      	ldr	r3, [pc, #4]	; (5298 <am_hal_vcomp_disable+0x8>)
    5292:	2237      	movs	r2, #55	; 0x37
    5294:	601a      	str	r2, [r3, #0]
    5296:	4770      	bx	lr
    5298:	4000c008 	.word	0x4000c008

0000529c <memset>:
    529c:	4402      	add	r2, r0
    529e:	4603      	mov	r3, r0
    52a0:	4293      	cmp	r3, r2
    52a2:	d100      	bne.n	52a6 <memset+0xa>
    52a4:	4770      	bx	lr
    52a6:	f803 1b01 	strb.w	r1, [r3], #1
    52aa:	e7f9      	b.n	52a0 <memset+0x4>
    52ac:	70206b36 	.word	0x70206b36
    52b0:	6f667265 	.word	0x6f667265
    52b4:	6e616d72 	.word	0x6e616d72
    52b8:	72206563 	.word	0x72206563
    52bc:	70206e75 	.word	0x70206e75
    52c0:	6d617261 	.word	0x6d617261
    52c4:	72657465 	.word	0x72657465
    52c8:	6f662073 	.word	0x6f662073
    52cc:	6f632072 	.word	0x6f632072
    52d0:	616d6572 	.word	0x616d6572
    52d4:	0a2e6b72 	.word	0x0a2e6b72
    52d8:	00000000 	.word	0x00000000
    52dc:	76206b36 	.word	0x76206b36
    52e0:	64696c61 	.word	0x64696c61
    52e4:	6f697461 	.word	0x6f697461
    52e8:	7572206e 	.word	0x7572206e
    52ec:	6170206e 	.word	0x6170206e
    52f0:	656d6172 	.word	0x656d6172
    52f4:	73726574 	.word	0x73726574
    52f8:	726f6620 	.word	0x726f6620
    52fc:	726f6320 	.word	0x726f6320
    5300:	72616d65 	.word	0x72616d65
    5304:	000a2e6b 	.word	0x000a2e6b
    5308:	666f7250 	.word	0x666f7250
    530c:	20656c69 	.word	0x20656c69
    5310:	656e6567 	.word	0x656e6567
    5314:	69746172 	.word	0x69746172
    5318:	72206e6f 	.word	0x72206e6f
    531c:	70206e75 	.word	0x70206e75
    5320:	6d617261 	.word	0x6d617261
    5324:	72657465 	.word	0x72657465
    5328:	6f662073 	.word	0x6f662073
    532c:	6f632072 	.word	0x6f632072
    5330:	616d6572 	.word	0x616d6572
    5334:	0a2e6b72 	.word	0x0a2e6b72
    5338:	00000000 	.word	0x00000000
    533c:	70204b32 	.word	0x70204b32
    5340:	6f667265 	.word	0x6f667265
    5344:	6e616d72 	.word	0x6e616d72
    5348:	72206563 	.word	0x72206563
    534c:	70206e75 	.word	0x70206e75
    5350:	6d617261 	.word	0x6d617261
    5354:	72657465 	.word	0x72657465
    5358:	6f662073 	.word	0x6f662073
    535c:	6f632072 	.word	0x6f632072
    5360:	616d6572 	.word	0x616d6572
    5364:	0a2e6b72 	.word	0x0a2e6b72
    5368:	00000000 	.word	0x00000000
    536c:	76204b32 	.word	0x76204b32
    5370:	64696c61 	.word	0x64696c61
    5374:	6f697461 	.word	0x6f697461
    5378:	7572206e 	.word	0x7572206e
    537c:	6170206e 	.word	0x6170206e
    5380:	656d6172 	.word	0x656d6172
    5384:	73726574 	.word	0x73726574
    5388:	726f6620 	.word	0x726f6620
    538c:	726f6320 	.word	0x726f6320
    5390:	72616d65 	.word	0x72616d65
    5394:	000a2e6b 	.word	0x000a2e6b
    5398:	5d75255b 	.word	0x5d75255b
    539c:	4f525245 	.word	0x4f525245
    53a0:	6c202152 	.word	0x6c202152
    53a4:	20747369 	.word	0x20747369
    53a8:	20637263 	.word	0x20637263
    53ac:	30257830 	.word	0x30257830
    53b0:	2d207834 	.word	0x2d207834
    53b4:	6f687320 	.word	0x6f687320
    53b8:	20646c75 	.word	0x20646c75
    53bc:	30206562 	.word	0x30206562
    53c0:	34302578 	.word	0x34302578
    53c4:	00000a78 	.word	0x00000a78
    53c8:	5d75255b 	.word	0x5d75255b
    53cc:	4f525245 	.word	0x4f525245
    53d0:	6d202152 	.word	0x6d202152
    53d4:	69727461 	.word	0x69727461
    53d8:	72632078 	.word	0x72632078
    53dc:	78302063 	.word	0x78302063
    53e0:	78343025 	.word	0x78343025
    53e4:	73202d20 	.word	0x73202d20
    53e8:	6c756f68 	.word	0x6c756f68
    53ec:	65622064 	.word	0x65622064
    53f0:	25783020 	.word	0x25783020
    53f4:	0a783430 	.word	0x0a783430
    53f8:	00000000 	.word	0x00000000
    53fc:	5d75255b 	.word	0x5d75255b
    5400:	4f525245 	.word	0x4f525245
    5404:	73202152 	.word	0x73202152
    5408:	65746174 	.word	0x65746174
    540c:	63726320 	.word	0x63726320
    5410:	25783020 	.word	0x25783020
    5414:	20783430 	.word	0x20783430
    5418:	6873202d 	.word	0x6873202d
    541c:	646c756f 	.word	0x646c756f
    5420:	20656220 	.word	0x20656220
    5424:	30257830 	.word	0x30257830
    5428:	000a7834 	.word	0x000a7834
    542c:	65726f43 	.word	0x65726f43
    5430:	6b72614d 	.word	0x6b72614d
    5434:	7a695320 	.word	0x7a695320
    5438:	20202065 	.word	0x20202065
    543c:	25203a20 	.word	0x25203a20
    5440:	000a756c 	.word	0x000a756c
    5444:	61746f54 	.word	0x61746f54
    5448:	6974206c 	.word	0x6974206c
    544c:	20736b63 	.word	0x20736b63
    5450:	20202020 	.word	0x20202020
    5454:	25203a20 	.word	0x25203a20
    5458:	000a756c 	.word	0x000a756c
    545c:	61746f54 	.word	0x61746f54
    5460:	6974206c 	.word	0x6974206c
    5464:	2820656d 	.word	0x2820656d
    5468:	73636573 	.word	0x73636573
    546c:	25203a29 	.word	0x25203a29
    5470:	00000a66 	.word	0x00000a66
    5474:	72657449 	.word	0x72657449
    5478:	6f697461 	.word	0x6f697461
    547c:	532f736e 	.word	0x532f736e
    5480:	20206365 	.word	0x20206365
    5484:	25203a20 	.word	0x25203a20
    5488:	00000a66 	.word	0x00000a66
    548c:	4f525245 	.word	0x4f525245
    5490:	4d202152 	.word	0x4d202152
    5494:	20747375 	.word	0x20747375
    5498:	63657865 	.word	0x63657865
    549c:	20657475 	.word	0x20657475
    54a0:	20726f66 	.word	0x20726f66
    54a4:	6c207461 	.word	0x6c207461
    54a8:	74736165 	.word	0x74736165
    54ac:	20303120 	.word	0x20303120
    54b0:	73636573 	.word	0x73636573
    54b4:	726f6620 	.word	0x726f6620
    54b8:	76206120 	.word	0x76206120
    54bc:	64696c61 	.word	0x64696c61
    54c0:	73657220 	.word	0x73657220
    54c4:	21746c75 	.word	0x21746c75
    54c8:	0000000a 	.word	0x0000000a
    54cc:	72657449 	.word	0x72657449
    54d0:	6f697461 	.word	0x6f697461
    54d4:	2020736e 	.word	0x2020736e
    54d8:	20202020 	.word	0x20202020
    54dc:	25203a20 	.word	0x25203a20
    54e0:	000a756c 	.word	0x000a756c
    54e4:	20434347 	.word	0x20434347
    54e8:	2e332e36 	.word	0x2e332e36
    54ec:	30322031 	.word	0x30322031
    54f0:	32303731 	.word	0x32303731
    54f4:	28203531 	.word	0x28203531
    54f8:	656c6572 	.word	0x656c6572
    54fc:	29657361 	.word	0x29657361
    5500:	52415b20 	.word	0x52415b20
    5504:	6d652f4d 	.word	0x6d652f4d
    5508:	64646562 	.word	0x64646562
    550c:	362d6465 	.word	0x362d6465
    5510:	6172622d 	.word	0x6172622d
    5514:	2068636e 	.word	0x2068636e
    5518:	69766572 	.word	0x69766572
    551c:	6e6f6973 	.word	0x6e6f6973
    5520:	35343220 	.word	0x35343220
    5524:	5d323135 	.word	0x5d323135
    5528:	00000000 	.word	0x00000000
    552c:	706d6f43 	.word	0x706d6f43
    5530:	72656c69 	.word	0x72656c69
    5534:	72657620 	.word	0x72657620
    5538:	6e6f6973 	.word	0x6e6f6973
    553c:	25203a20 	.word	0x25203a20
    5540:	00000a73 	.word	0x00000a73
    5544:	43415453 	.word	0x43415453
    5548:	0000004b 	.word	0x0000004b
    554c:	6f6d654d 	.word	0x6f6d654d
    5550:	6c207972 	.word	0x6c207972
    5554:	7461636f 	.word	0x7461636f
    5558:	206e6f69 	.word	0x206e6f69
    555c:	25203a20 	.word	0x25203a20
    5560:	00000a73 	.word	0x00000a73
    5564:	64656573 	.word	0x64656573
    5568:	20637263 	.word	0x20637263
    556c:	20202020 	.word	0x20202020
    5570:	20202020 	.word	0x20202020
    5574:	30203a20 	.word	0x30203a20
    5578:	34302578 	.word	0x34302578
    557c:	00000a78 	.word	0x00000a78
    5580:	5d64255b 	.word	0x5d64255b
    5584:	6c637263 	.word	0x6c637263
    5588:	20747369 	.word	0x20747369
    558c:	20202020 	.word	0x20202020
    5590:	203a2020 	.word	0x203a2020
    5594:	30257830 	.word	0x30257830
    5598:	000a7834 	.word	0x000a7834
    559c:	5d64255b 	.word	0x5d64255b
    55a0:	6d637263 	.word	0x6d637263
    55a4:	69727461 	.word	0x69727461
    55a8:	20202078 	.word	0x20202078
    55ac:	203a2020 	.word	0x203a2020
    55b0:	30257830 	.word	0x30257830
    55b4:	000a7834 	.word	0x000a7834
    55b8:	5d64255b 	.word	0x5d64255b
    55bc:	73637263 	.word	0x73637263
    55c0:	65746174 	.word	0x65746174
    55c4:	20202020 	.word	0x20202020
    55c8:	203a2020 	.word	0x203a2020
    55cc:	30257830 	.word	0x30257830
    55d0:	000a7834 	.word	0x000a7834
    55d4:	5d64255b 	.word	0x5d64255b
    55d8:	66637263 	.word	0x66637263
    55dc:	6c616e69 	.word	0x6c616e69
    55e0:	20202020 	.word	0x20202020
    55e4:	203a2020 	.word	0x203a2020
    55e8:	30257830 	.word	0x30257830
    55ec:	000a7834 	.word	0x000a7834
    55f0:	72726f43 	.word	0x72726f43
    55f4:	20746365 	.word	0x20746365
    55f8:	7265706f 	.word	0x7265706f
    55fc:	6f697461 	.word	0x6f697461
    5600:	6176206e 	.word	0x6176206e
    5604:	6164696c 	.word	0x6164696c
    5608:	2e646574 	.word	0x2e646574
    560c:	65655320 	.word	0x65655320
    5610:	61657220 	.word	0x61657220
    5614:	2e656d64 	.word	0x2e656d64
    5618:	20747874 	.word	0x20747874
    561c:	20726f66 	.word	0x20726f66
    5620:	206e7572 	.word	0x206e7572
    5624:	20646e61 	.word	0x20646e61
    5628:	6f706572 	.word	0x6f706572
    562c:	6e697472 	.word	0x6e697472
    5630:	75722067 	.word	0x75722067
    5634:	2e73656c 	.word	0x2e73656c
    5638:	0000000a 	.word	0x0000000a
    563c:	65726f43 	.word	0x65726f43
    5640:	6b72614d 	.word	0x6b72614d
    5644:	302e3120 	.word	0x302e3120
    5648:	25203a20 	.word	0x25203a20
    564c:	202f2066 	.word	0x202f2066
    5650:	25207325 	.word	0x25207325
    5654:	00000073 	.word	0x00000073
    5658:	67616c66 	.word	0x67616c66
    565c:	2d203a73 	.word	0x2d203a73
    5660:	0000336f 	.word	0x0000336f
    5664:	25202f20 	.word	0x25202f20
    5668:	00000073 	.word	0x00000073
    566c:	6f727245 	.word	0x6f727245
    5670:	64207372 	.word	0x64207372
    5674:	63657465 	.word	0x63657465
    5678:	0a646574 	.word	0x0a646574
    567c:	00000000 	.word	0x00000000
    5680:	6e6e6143 	.word	0x6e6e6143
    5684:	7620746f 	.word	0x7620746f
    5688:	64696c61 	.word	0x64696c61
    568c:	20657461 	.word	0x20657461
    5690:	7265706f 	.word	0x7265706f
    5694:	6f697461 	.word	0x6f697461
    5698:	6f66206e 	.word	0x6f66206e
    569c:	68742072 	.word	0x68742072
    56a0:	20657365 	.word	0x20657365
    56a4:	64656573 	.word	0x64656573
    56a8:	6c617620 	.word	0x6c617620
    56ac:	2c736575 	.word	0x2c736575
    56b0:	656c7020 	.word	0x656c7020
    56b4:	20657361 	.word	0x20657361
    56b8:	706d6f63 	.word	0x706d6f63
    56bc:	20657261 	.word	0x20657261
    56c0:	68746977 	.word	0x68746977
    56c4:	73657220 	.word	0x73657220
    56c8:	73746c75 	.word	0x73746c75
    56cc:	206e6f20 	.word	0x206e6f20
    56d0:	6e6b2061 	.word	0x6e6b2061
    56d4:	206e776f 	.word	0x206e776f
    56d8:	74616c70 	.word	0x74616c70
    56dc:	6d726f66 	.word	0x6d726f66
    56e0:	00000a2e 	.word	0x00000a2e
    56e4:	4d2f4d43 	.word	0x4d2f4d43
    56e8:	253d7a48 	.word	0x253d7a48
    56ec:	2e66332e 	.word	0x2e66332e
    56f0:	0000000a 	.word	0x0000000a
    56f4:	46465542 	.word	0x46465542
    56f8:	4f205245 	.word	0x4f205245
    56fc:	46524556 	.word	0x46524556
    5700:	45574f4c 	.word	0x45574f4c
    5704:	49202144 	.word	0x49202144
    5708:	6572636e 	.word	0x6572636e
    570c:	20657361 	.word	0x20657361
    5710:	42545250 	.word	0x42545250
    5714:	49534655 	.word	0x49534655
    5718:	000a455a 	.word	0x000a455a
    571c:	626d410a 	.word	0x626d410a
    5720:	4d207169 	.word	0x4d207169
    5724:	6f726369 	.word	0x6f726369
    5728:	726f4320 	.word	0x726f4320
    572c:	72616d65 	.word	0x72616d65
    5730:	7572206b 	.word	0x7572206b
    5734:	6966206e 	.word	0x6966206e
    5738:	6873696e 	.word	0x6873696e
    573c:	0a216465 	.word	0x0a216465
    5740:	0000000a 	.word	0x0000000a
    5744:	69626d41 	.word	0x69626d41
    5748:	694d2071 	.word	0x694d2071
    574c:	206f7263 	.word	0x206f7263
    5750:	65726f43 	.word	0x65726f43
    5754:	6b72616d 	.word	0x6b72616d
    5758:	73657420 	.word	0x73657420
    575c:	2e2e2e74 	.word	0x2e2e2e74
    5760:	00000a0a 	.word	0x00000a0a

00005764 <errpat>:
    5764:	000057a4 000057b0 000057bc 000057c8     .W...W...W...W..

00005774 <floatpat>:
    5774:	00005804 00005810 0000581c 00005828     .X...X...X..(X..

00005784 <intpat>:
    5784:	00005834 0000583c 00005844 0000584c     4X..<X..DX..LX..

00005794 <scipat>:
    5794:	000057d4 000057e0 000057ec 000057f8     .W...W...W...W..
    57a4:	332e3054 46312d65 00000000 542e542d     T0.3e-1F....-T.T
    57b4:	71542b2b 00000000 2e335431 7a346534     ++Tq....1T3.4e4z
    57c4:	00000000 302e3433 5e542d65 00000000     ....34.0e-T^....
    57d4:	30352e35 332b6530 00000000 32312e2d     5.500e+3....-.12
    57e4:	322d6533 00000000 6537382d 3233382b     3e-2....-87e+832
    57f4:	00000000 362e302b 32312d65 00000000     ....+0.6e-12....
    5804:	352e3533 30303434 00000000 3332312e     35.54400.....123
    5814:	30303534 00000000 3031312d 3030372e     4500....-110.700
    5824:	00000000 362e302b 30303434 00000000     ....+0.64400....
    5834:	32313035 00000000 34333231 00000000     5012....1234....
    5844:	3437382d 00000000 3232312b 00000000     -874....+122....
    5854:	0a0a0a0a 0a0a0a0a 0a0a0a0a 0a0a0a0a     ................
    5864:	00000a0a                                ....

00005868 <CSWTCH.4>:
    5868:	016e3600 00b71b00 007a1200 005b8d80     .6n.......z...[.
    5878:	00493e00 003d0900 003450db 002dc6c0     .>I...=..P4...-.
