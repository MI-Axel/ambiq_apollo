###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         10/Sep/2018  16:57:41
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\ambiq\AmbiqSuite-Rel1.2.12.tar\AmbiqSuite-Rel1.2.12\AmbiqSuite-Rel1.2.12\boards\apollo2_blue_evb\examples\binary_counter\iar\startup_iar.c
#    Command line =  
#        -f C:\Users\agao\AppData\Local\Temp\EW7E0F.tmp
#        (C:\ambiq\AmbiqSuite-Rel1.2.12.tar\AmbiqSuite-Rel1.2.12\AmbiqSuite-Rel1.2.12\boards\apollo2_blue_evb\examples\binary_counter\iar\startup_iar.c
#        -D iar -D AM_PACKAGE_BGA -D AM_PART_APOLLO2 -lcN
#        C:\ambiq\AmbiqSuite-Rel1.2.12.tar\AmbiqSuite-Rel1.2.12\AmbiqSuite-Rel1.2.12\boards\apollo2_blue_evb\examples\binary_counter\iar\bin
#        --diag_suppress Pa050 -o
#        C:\ambiq\AmbiqSuite-Rel1.2.12.tar\AmbiqSuite-Rel1.2.12\AmbiqSuite-Rel1.2.12\boards\apollo2_blue_evb\examples\binary_counter\iar\bin
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\ambiq\AmbiqSuite-Rel1.2.12.tar\AmbiqSuite-Rel1.2.12\AmbiqSuite-Rel1.2.12\boards\apollo2_blue_evb\examples\binary_counter\iar\..\src\
#        -I
#        C:\ambiq\AmbiqSuite-Rel1.2.12.tar\AmbiqSuite-Rel1.2.12\AmbiqSuite-Rel1.2.12\boards\apollo2_blue_evb\examples\binary_counter\iar\..\..\..\bsp\
#        -I
#        C:\ambiq\AmbiqSuite-Rel1.2.12.tar\AmbiqSuite-Rel1.2.12\AmbiqSuite-Rel1.2.12\boards\apollo2_blue_evb\examples\binary_counter\iar\..\..\..\..\..\
#        -I
#        C:\ambiq\AmbiqSuite-Rel1.2.12.tar\AmbiqSuite-Rel1.2.12\AmbiqSuite-Rel1.2.12\boards\apollo2_blue_evb\examples\binary_counter\iar\..\..\..\..\..\utils\
#        -I
#        C:\ambiq\AmbiqSuite-Rel1.2.12.tar\AmbiqSuite-Rel1.2.12\AmbiqSuite-Rel1.2.12\boards\apollo2_blue_evb\examples\binary_counter\iar\..\..\..\..\..\devices\
#        -I
#        C:\ambiq\AmbiqSuite-Rel1.2.12.tar\AmbiqSuite-Rel1.2.12\AmbiqSuite-Rel1.2.12\boards\apollo2_blue_evb\examples\binary_counter\iar\..\..\..\..\..\mcu\apollo2\
#        -On)
#    Locale       =  C
#    List file    =  
#        C:\ambiq\AmbiqSuite-Rel1.2.12.tar\AmbiqSuite-Rel1.2.12\AmbiqSuite-Rel1.2.12\boards\apollo2_blue_evb\examples\binary_counter\iar\bin\startup_iar.lst
#    Object file  =  
#        C:\ambiq\AmbiqSuite-Rel1.2.12.tar\AmbiqSuite-Rel1.2.12\AmbiqSuite-Rel1.2.12\boards\apollo2_blue_evb\examples\binary_counter\iar\bin\startup_iar.o
#
###############################################################################

C:\ambiq\AmbiqSuite-Rel1.2.12.tar\AmbiqSuite-Rel1.2.12\AmbiqSuite-Rel1.2.12\boards\apollo2_blue_evb\examples\binary_counter\iar\startup_iar.c
      1          //*****************************************************************************
      2          //
      3          //! @file startup_iar.c
      4          //!
      5          //! @brief Definitions for interrupt handlers, the vector table, and the stack.
      6          //
      7          //*****************************************************************************
      8          
      9          //*****************************************************************************
     10          //
     11          // Copyright (c) 2018, Ambiq Micro
     12          // All rights reserved.
     13          // 
     14          // Redistribution and use in source and binary forms, with or without
     15          // modification, are permitted provided that the following conditions are met:
     16          // 
     17          // 1. Redistributions of source code must retain the above copyright notice,
     18          // this list of conditions and the following disclaimer.
     19          // 
     20          // 2. Redistributions in binary form must reproduce the above copyright
     21          // notice, this list of conditions and the following disclaimer in the
     22          // documentation and/or other materials provided with the distribution.
     23          // 
     24          // 3. Neither the name of the copyright holder nor the names of its
     25          // contributors may be used to endorse or promote products derived from this
     26          // software without specific prior written permission.
     27          // 
     28          // Third party software included in this distribution is subject to the
     29          // additional license terms as defined in the /docs/licenses directory.
     30          // 
     31          // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     32          // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     33          // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     34          // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     35          // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     36          // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     37          // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     38          // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     39          // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     40          // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     41          // POSSIBILITY OF SUCH DAMAGE.
     42          //
     43          // This is part of revision 1.2.12 of the AmbiqSuite Development Package.
     44          //
     45          //*****************************************************************************
     46          
     47          #include <stdint.h>
     48          
     49          //*****************************************************************************
     50          //
     51          // Enable the IAR extensions for this source file.
     52          //
     53          //*****************************************************************************
     54          #pragma language = extended
     55          
     56          //*****************************************************************************
     57          //
     58          // Weak function links.
     59          //
     60          //*****************************************************************************
     61          #pragma weak am_mpufault_isr        = am_fault_isr
     62          #pragma weak am_busfault_isr        = am_fault_isr
     63          #pragma weak am_usagefault_isr      = am_fault_isr
     64          #pragma weak am_svcall_isr          = am_default_isr
     65          #pragma weak am_debugmon_isr        = am_default_isr
     66          #pragma weak am_pendsv_isr          = am_default_isr
     67          #pragma weak am_systick_isr         = am_default_isr
     68          #pragma weak am_brownout_isr        = am_default_isr
     69          #pragma weak am_watchdog_isr        = am_default_isr
     70          #pragma weak am_clkgen_isr          = am_default_isr
     71          #pragma weak am_vcomp_isr           = am_default_isr
     72          #pragma weak am_ioslave_ios_isr     = am_default_isr
     73          #pragma weak am_ioslave_acc_isr     = am_default_isr
     74          #pragma weak am_iomaster0_isr       = am_default_isr
     75          #pragma weak am_iomaster1_isr       = am_default_isr
     76          #pragma weak am_iomaster2_isr       = am_default_isr
     77          #pragma weak am_iomaster3_isr       = am_default_isr
     78          #pragma weak am_iomaster4_isr       = am_default_isr
     79          #pragma weak am_iomaster5_isr       = am_default_isr
     80          #pragma weak am_gpio_isr            = am_default_isr
     81          #pragma weak am_ctimer_isr          = am_default_isr
     82          #pragma weak am_uart_isr            = am_default_isr
     83          #pragma weak am_uart1_isr           = am_default_isr
     84          #pragma weak am_adc_isr             = am_default_isr
     85          #pragma weak am_pdm_isr             = am_default_isr
     86          #pragma weak am_stimer_isr          = am_default_isr
     87          #pragma weak am_stimer_cmpr0_isr    = am_default_isr
     88          #pragma weak am_stimer_cmpr1_isr    = am_default_isr
     89          #pragma weak am_stimer_cmpr2_isr    = am_default_isr
     90          #pragma weak am_stimer_cmpr3_isr    = am_default_isr
     91          #pragma weak am_stimer_cmpr4_isr    = am_default_isr
     92          #pragma weak am_stimer_cmpr5_isr    = am_default_isr
     93          #pragma weak am_stimer_cmpr6_isr    = am_default_isr
     94          #pragma weak am_stimer_cmpr7_isr    = am_default_isr
     95          #pragma weak am_flash_isr           = am_default_isr
     96          #pragma weak am_software0_isr       = am_default_isr
     97          #pragma weak am_software1_isr       = am_default_isr
     98          #pragma weak am_software2_isr       = am_default_isr
     99          #pragma weak am_software3_isr       = am_default_isr
    100          
    101          
    102          //*****************************************************************************
    103          //
    104          // Forward declaration of the default fault handlers.
    105          //
    106          //*****************************************************************************
    107          extern __stackless void am_reset_isr(void);
    108          extern __weak void am_nmi_isr(void);
    109          extern __weak void am_fault_isr(void);
    110          extern void am_mpufault_isr(void);
    111          extern void am_busfault_isr(void);
    112          extern void am_usagefault_isr(void);
    113          extern void am_svcall_isr(void);
    114          extern void am_debugmon_isr(void);
    115          extern void am_pendsv_isr(void);
    116          extern void am_systick_isr(void);
    117          extern void am_brownout_isr(void);
    118          extern void am_watchdog_isr(void);
    119          extern void am_clkgen_isr(void);
    120          extern void am_vcomp_isr(void);
    121          extern void am_ioslave_ios_isr(void);
    122          extern void am_ioslave_acc_isr(void);
    123          extern void am_iomaster0_isr(void);
    124          extern void am_iomaster1_isr(void);
    125          extern void am_iomaster2_isr(void);
    126          extern void am_iomaster3_isr(void);
    127          extern void am_iomaster4_isr(void);
    128          extern void am_iomaster5_isr(void);
    129          extern void am_gpio_isr(void);
    130          extern void am_ctimer_isr(void);
    131          extern void am_uart_isr(void);
    132          extern void am_uart1_isr(void);
    133          extern void am_adc_isr(void);
    134          extern void am_pdm_isr(void);
    135          extern void am_stimer_isr(void);
    136          extern void am_stimer_cmpr0_isr(void);
    137          extern void am_stimer_cmpr1_isr(void);
    138          extern void am_stimer_cmpr2_isr(void);
    139          extern void am_stimer_cmpr3_isr(void);
    140          extern void am_stimer_cmpr4_isr(void);
    141          extern void am_stimer_cmpr5_isr(void);
    142          extern void am_stimer_cmpr6_isr(void);
    143          extern void am_stimer_cmpr7_isr(void);
    144          extern void am_flash_isr(void);
    145          extern void am_software0_isr(void);
    146          extern void am_software1_isr(void);
    147          extern void am_software2_isr(void);
    148          extern void am_software3_isr(void);
    149          
    150          extern void am_default_isr(void);
    151          
    152          //*****************************************************************************
    153          //
    154          // The entry point for the application startup code.
    155          //
    156          //*****************************************************************************
    157          extern void __iar_program_start(void);
    158          
    159          //*****************************************************************************
    160          //
    161          // Reserve space for the system stack.
    162          //
    163          //*****************************************************************************
    164          static uint32_t pui32Stack[1024] @ ".noinit";
    165          
    166          //*****************************************************************************
    167          //
    168          // A union that describes the entries of the vector table.  The union is needed
    169          // since the first entry is the stack pointer and the remainder are function
    170          // pointers.
    171          //
    172          //*****************************************************************************
    173          typedef union
    174          {
    175              void (*pfnHandler)(void);
    176              uint32_t ui32Ptr;
    177          }
    178          uVectorEntry;
    179          
    180          //*****************************************************************************
    181          //
    182          // The vector table.  Note that the proper constructs must be placed on this to
    183          // ensure that it ends up at physical address 0x0000.0000.
    184          //
    185          // Note: Aliasing and weakly exporting am_mpufault_isr, am_busfault_isr, and
    186          // am_usagefault_isr does not work if am_fault_isr is defined externally.
    187          // Therefore, we'll explicitly use am_fault_isr in the table for those vectors.
    188          //
    189          //*****************************************************************************
    190          __root const uVectorEntry __vector_table[] @ ".intvec" =
    191          {
    192              { .ui32Ptr = (uint32_t)pui32Stack + sizeof(pui32Stack) },
    193                                                          // The initial stack pointer
    194              am_reset_isr,                               // The reset handler
    195              am_nmi_isr,                                 // The NMI handler
    196              am_fault_isr,                               // The hard fault handler
    197              am_fault_isr,                               // The MPU fault handler
    198              am_fault_isr,                               // The bus fault handler
    199              am_fault_isr,                               // The usage fault handler
    200              0,                                          // Reserved
    201              0,                                          // Reserved
    202              0,                                          // Reserved
    203              0,                                          // Reserved
    204              am_svcall_isr,                              // SVCall handle
    205              am_debugmon_isr,                            // Debug monitor handler
    206              0,                                          // Reserved
    207              am_pendsv_isr,                              // The PendSV handler
    208              am_systick_isr,                             // The SysTick handler
    209          
    210              //
    211              // Peripheral Interrupts
    212              //
    213              am_brownout_isr,                            //  0: Brownout
    214              am_watchdog_isr,                            //  1: Watchdog
    215              am_clkgen_isr,                              //  2: CLKGEN
    216              am_vcomp_isr,                               //  3: Voltage Comparator
    217              am_ioslave_ios_isr,                         //  4: I/O Slave general
    218              am_ioslave_acc_isr,                         //  5: I/O Slave access
    219              am_iomaster0_isr,                           //  6: I/O Master 0
    220              am_iomaster1_isr,                           //  7: I/O Master 1
    221              am_iomaster2_isr,                           //  8: I/O Master 2
    222              am_iomaster3_isr,                           //  9: I/O Master 3
    223              am_iomaster4_isr,                           // 10: I/O Master 4
    224              am_iomaster5_isr,                           // 11: I/O Master 5
    225              am_gpio_isr,                                // 12: GPIO
    226              am_ctimer_isr,                              // 13: CTIMER
    227              am_uart_isr,                                // 14: UART0
    228              am_uart1_isr,                               // 15: UART1
    229              am_adc_isr,                                 // 16: ADC
    230              am_pdm_isr,                                 // 17: PDM
    231              am_stimer_isr,                              // 18: STIMER
    232              am_stimer_cmpr0_isr,                        // 19: STIMER COMPARE0
    233              am_stimer_cmpr1_isr,                        // 20: STIMER COMPARE1
    234              am_stimer_cmpr2_isr,                        // 21: STIMER COMPARE2
    235              am_stimer_cmpr3_isr,                        // 22: STIMER COMPARE3
    236              am_stimer_cmpr4_isr,                        // 23: STIMER COMPARE4
    237              am_stimer_cmpr5_isr,                        // 24: STIMER COMPARE5
    238              am_stimer_cmpr6_isr,                        // 25: STIMER COMPARE6
    239              am_stimer_cmpr7_isr,                        // 26: STIMER COMPARE7
    240              am_flash_isr,                               // 27: FLASH
    241              am_software0_isr,                           // 28: SOFTWARE0
    242              am_software1_isr,                           // 29: SOFTWARE1
    243              am_software2_isr,                           // 30: SOFTWARE2
    244              am_software3_isr                            // 31: SOFTWARE3
    245          };
    246          
    247          //*****************************************************************************
    248          //
    249          // Note - The template for this function is originally found in IAR's module,
    250          //        low_level_init.c. As supplied by IAR, it is an empty function.
    251          //
    252          // This module contains the function `__low_level_init', a function
    253          // that is called before the `main' function of the program.  Normally
    254          // low-level initializations - such as setting the prefered interrupt
    255          // level or setting the watchdog - can be performed here.
    256          //
    257          // Note that this function is called before the data segments are
    258          // initialized, this means that this function cannot rely on the
    259          // values of global or static variables.
    260          //
    261          // When this function returns zero, the startup code will inhibit the
    262          // initialization of the data segments. The result is faster startup,
    263          // the drawback is that neither global nor static data will be
    264          // initialized.
    265          //
    266          // Copyright 1999-2017 IAR Systems AB.
    267          //
    268          // $Revision: 112610 $
    269          //
    270          //
    271          //
    272          //
    273          //*****************************************************************************
    274          #define AM_REGVAL(x)               (*((volatile uint32_t *)(x)))
    275          #define VTOR_ADDR                   0xE000ED08
    276          
    277          __interwork int __low_level_init(void)
    278          {
    279          
    280              AM_REGVAL(VTOR_ADDR) = (uint32_t)&__vector_table;
    281          
    282              /*==================================*/
    283              /* Choose if segment initialization */
    284              /* should be done or not.           */
    285              /* Return: 0 to omit seg_init       */
    286              /*         1 to run seg_init        */
    287              /*==================================*/
    288              return 1;
    289          }
    290          
    291          //*****************************************************************************
    292          //
    293          // This is the code that gets called when the processor first starts execution
    294          // following a reset event.  Only the absolutely necessary set is performed,
    295          // after which the application supplied entry() routine is called.
    296          //
    297          //*****************************************************************************
    298          void
    299          am_reset_isr(void)
    300          {
    301              //
    302              // Call the application's entry point.
    303              //
    304              __iar_program_start();
    305          }
    306          
    307          //*****************************************************************************
    308          //
    309          // This is the code that gets called when the processor receives a NMI.  This
    310          // simply enters an infinite loop, preserving the system state for examination
    311          // by a debugger.
    312          //
    313          //*****************************************************************************
    314          __weak void
    315          am_nmi_isr(void)
    316          {
    317              //
    318              // Enter an infinite loop.
    319              //
    320              while(1)
    321              {
    322              }
    323          }
    324          
    325          //*****************************************************************************
    326          //
    327          // This is the code that gets called when the processor receives a fault
    328          // interrupt.  This simply enters an infinite loop, preserving the system state
    329          // for examination by a debugger.
    330          //
    331          //*****************************************************************************
    332          __weak void
    333          am_fault_isr(void)
    334          {
    335              //
    336              // Enter an infinite loop.
    337              //
    338              while(1)
    339              {
    340              }
    341          }
    342          
    343          //*****************************************************************************
    344          //
    345          // This is the code that gets called when the processor receives an unexpected
    346          // interrupt.  This simply enters an infinite loop, preserving the system state
    347          // for examination by a debugger.
    348          //
    349          //*****************************************************************************
    350          static void
    351          am_default_isr(void)
    352          {
    353              //
    354              // Go into an infinite loop.
    355              //
    356              while(1)
    357              {
    358              }
    359          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   __low_level_init
       0   am_adc_isr
       0   am_brownout_isr
       0   am_clkgen_isr
       0   am_ctimer_isr
       0   am_debugmon_isr
       0   am_default_isr
       0   am_fault_isr
       0   am_flash_isr
       0   am_gpio_isr
       0   am_iomaster0_isr
       0   am_iomaster1_isr
       0   am_iomaster2_isr
       0   am_iomaster3_isr
       0   am_iomaster4_isr
       0   am_iomaster5_isr
       0   am_ioslave_acc_isr
       0   am_ioslave_ios_isr
       0   am_nmi_isr
       0   am_pdm_isr
       0   am_pendsv_isr
       0   am_reset_isr
         0   -> __iar_program_start
       0   am_software0_isr
       0   am_software1_isr
       0   am_software2_isr
       0   am_software3_isr
       0   am_stimer_cmpr0_isr
       0   am_stimer_cmpr1_isr
       0   am_stimer_cmpr2_isr
       0   am_stimer_cmpr3_isr
       0   am_stimer_cmpr4_isr
       0   am_stimer_cmpr5_isr
       0   am_stimer_cmpr6_isr
       0   am_stimer_cmpr7_isr
       0   am_stimer_isr
       0   am_svcall_isr
       0   am_systick_isr
       0   am_uart1_isr
       0   am_uart_isr
       0   am_vcomp_isr
       0   am_watchdog_isr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
      10  __low_level_init
     192  __vector_table
       2  am_nmi_isr
       6  am_reset_isr
       2  am_stimer_cmpr3_isr
          am_iomaster1_isr
          am_ioslave_ios_isr
          am_clkgen_isr
          am_iomaster2_isr
          am_iomaster3_isr
          am_pdm_isr
          am_debugmon_isr
          am_brownout_isr
          am_vcomp_isr
          am_pendsv_isr
          am_watchdog_isr
          am_ioslave_acc_isr
          am_iomaster4_isr
          am_adc_isr
          am_svcall_isr
          am_systick_isr
          am_iomaster0_isr
          am_ctimer_isr
          am_uart_isr
          am_uart1_isr
          am_stimer_cmpr0_isr
          am_stimer_cmpr1_isr
          am_stimer_isr
          am_gpio_isr
          am_iomaster5_isr
          am_stimer_cmpr2_isr
          am_stimer_cmpr4_isr
          am_software0_isr
          am_software3_isr
          am_stimer_cmpr6_isr
          am_default_isr
          am_software1_isr
          am_stimer_cmpr5_isr
          am_software2_isr
          am_stimer_cmpr7_isr
          am_flash_isr
       2  am_usagefault_isr
          am_fault_isr
          am_mpufault_isr
          am_busfault_isr
    4096  pui32Stack

 
   192 bytes in section .intvec
 4 096 bytes in section .noinit
    30 bytes in section .text
 
    26 bytes of CODE  memory (+ 4 bytes shared)
   192 bytes of CONST memory
 4 096 bytes of DATA  memory

Errors: none
Warnings: none
