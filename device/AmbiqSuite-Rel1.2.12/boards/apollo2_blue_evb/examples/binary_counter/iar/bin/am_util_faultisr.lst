###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         10/Sep/2018  16:57:41
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\ambiq\AmbiqSuite-Rel1.2.12.tar\AmbiqSuite-Rel1.2.12\AmbiqSuite-Rel1.2.12\utils\am_util_faultisr.c
#    Command line =  
#        -f C:\Users\agao\AppData\Local\Temp\EW790B.tmp
#        (C:\ambiq\AmbiqSuite-Rel1.2.12.tar\AmbiqSuite-Rel1.2.12\AmbiqSuite-Rel1.2.12\utils\am_util_faultisr.c
#        -D iar -D AM_PACKAGE_BGA -D AM_PART_APOLLO2 -lcN
#        C:\ambiq\AmbiqSuite-Rel1.2.12.tar\AmbiqSuite-Rel1.2.12\AmbiqSuite-Rel1.2.12\boards\apollo2_blue_evb\examples\binary_counter\iar\bin
#        --diag_suppress Pa050 -o
#        C:\ambiq\AmbiqSuite-Rel1.2.12.tar\AmbiqSuite-Rel1.2.12\AmbiqSuite-Rel1.2.12\boards\apollo2_blue_evb\examples\binary_counter\iar\bin
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\ambiq\AmbiqSuite-Rel1.2.12.tar\AmbiqSuite-Rel1.2.12\AmbiqSuite-Rel1.2.12\boards\apollo2_blue_evb\examples\binary_counter\iar\..\src\
#        -I
#        C:\ambiq\AmbiqSuite-Rel1.2.12.tar\AmbiqSuite-Rel1.2.12\AmbiqSuite-Rel1.2.12\boards\apollo2_blue_evb\examples\binary_counter\iar\..\..\..\bsp\
#        -I
#        C:\ambiq\AmbiqSuite-Rel1.2.12.tar\AmbiqSuite-Rel1.2.12\AmbiqSuite-Rel1.2.12\boards\apollo2_blue_evb\examples\binary_counter\iar\..\..\..\..\..\
#        -I
#        C:\ambiq\AmbiqSuite-Rel1.2.12.tar\AmbiqSuite-Rel1.2.12\AmbiqSuite-Rel1.2.12\boards\apollo2_blue_evb\examples\binary_counter\iar\..\..\..\..\..\utils\
#        -I
#        C:\ambiq\AmbiqSuite-Rel1.2.12.tar\AmbiqSuite-Rel1.2.12\AmbiqSuite-Rel1.2.12\boards\apollo2_blue_evb\examples\binary_counter\iar\..\..\..\..\..\devices\
#        -I
#        C:\ambiq\AmbiqSuite-Rel1.2.12.tar\AmbiqSuite-Rel1.2.12\AmbiqSuite-Rel1.2.12\boards\apollo2_blue_evb\examples\binary_counter\iar\..\..\..\..\..\mcu\apollo2\
#        -On)
#    Locale       =  C
#    List file    =  
#        C:\ambiq\AmbiqSuite-Rel1.2.12.tar\AmbiqSuite-Rel1.2.12\AmbiqSuite-Rel1.2.12\boards\apollo2_blue_evb\examples\binary_counter\iar\bin\am_util_faultisr.lst
#    Object file  =  
#        C:\ambiq\AmbiqSuite-Rel1.2.12.tar\AmbiqSuite-Rel1.2.12\AmbiqSuite-Rel1.2.12\boards\apollo2_blue_evb\examples\binary_counter\iar\bin\am_util_faultisr.o
#
###############################################################################

C:\ambiq\AmbiqSuite-Rel1.2.12.tar\AmbiqSuite-Rel1.2.12\AmbiqSuite-Rel1.2.12\utils\am_util_faultisr.c
      1          //*****************************************************************************
      2          //
      3          //! @file am_util_faultisr.c
      4          //!
      5          //! @brief An extended hard-fault handler.
      6          //
      7          // This module is intended to be completely portable with no HAL or BSP
      8          // dependencies.
      9          //
     10          // Further, it is intended to be compiler/platform independent enabling it to
     11          // run on GCC, Keil, IAR, etc.
     12          //
     13          //*****************************************************************************
     14          
     15          //*****************************************************************************
     16          //
     17          // Copyright (c) 2018, Ambiq Micro
     18          // All rights reserved.
     19          // 
     20          // Redistribution and use in source and binary forms, with or without
     21          // modification, are permitted provided that the following conditions are met:
     22          // 
     23          // 1. Redistributions of source code must retain the above copyright notice,
     24          // this list of conditions and the following disclaimer.
     25          // 
     26          // 2. Redistributions in binary form must reproduce the above copyright
     27          // notice, this list of conditions and the following disclaimer in the
     28          // documentation and/or other materials provided with the distribution.
     29          // 
     30          // 3. Neither the name of the copyright holder nor the names of its
     31          // contributors may be used to endorse or promote products derived from this
     32          // software without specific prior written permission.
     33          // 
     34          // Third party software included in this distribution is subject to the
     35          // additional license terms as defined in the /docs/licenses directory.
     36          // 
     37          // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     38          // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     39          // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     40          // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     41          // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     42          // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     43          // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     44          // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     45          // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     46          // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     47          // POSSIBILITY OF SUCH DAMAGE.
     48          //
     49          // This is part of revision 1.2.12 of the AmbiqSuite Development Package.
     50          //
     51          //*****************************************************************************
     52          
     53          #include <stdint.h>
     54          #include "am_mcu_apollo.h"
     55          
     56          //*****************************************************************************
     57          //
     58          // Macros
     59          //
     60          //*****************************************************************************
     61          
     62          //
     63          // Macros used by am_util_faultisr_collect_data().
     64          //
     65          #define AM_REG_SYSCTRL_CFSR_O                        0xE000ED28
     66          #define AM_REG_SYSCTRL_BFAR_O                        0xE000ED38
     67          #define AM_REGVAL(x)               (*((volatile uint32_t *)(x)))
     68          
     69          //*****************************************************************************
     70          //
     71          // Data structures
     72          //
     73          //*****************************************************************************
     74          
     75          //
     76          // Define a structure for local storage in am_util_faultisr_collect_data().
     77          // Set structure alignment to 1 byte to minimize storage requirements.
     78          //
     79          #pragma pack(1)
     80          typedef struct
     81          {
     82              //
     83              // Stacked registers
     84              //
     85              volatile uint32_t u32R0;
     86              volatile uint32_t u32R1;
     87              volatile uint32_t u32R2;
     88              volatile uint32_t u32R3;
     89              volatile uint32_t u32R12;
     90              volatile uint32_t u32LR;
     91              volatile uint32_t u32PC;
     92              volatile uint32_t u32PSR;
     93          
     94              //
     95              // Other data
     96              //
     97              volatile uint32_t u32FaultAddr;
     98              volatile uint32_t u32BFAR;
     99              volatile uint32_t u32CFSR;
    100              volatile uint8_t  u8MMSR;
    101              volatile uint8_t  u8BFSR;
    102              volatile uint16_t u16UFSR;
    103          
    104          } am_fault_t;
    105          
    106          //
    107          // Restore the default structure alignment
    108          //
    109          #pragma pack()
    110          
    111          //*****************************************************************************
    112          //
    113          // Prototypes
    114          //
    115          //*****************************************************************************
    116          void am_util_faultisr_collect_data(uint32_t u32IsrSP);
    117          
    118          //
    119          // Prototype for printf, if used.
    120          //
    121          extern uint32_t am_util_stdio_printf(char *pui8Fmt, ...);
    122          
    123          //*****************************************************************************
    124          //
    125          // am_fault_isr() replaces the weak one defined in the startup code.  This
    126          // simple function captures SP (which is needed by getStackedReg) then calls
    127          // the function that actually decodes the hard fault data,
    128          // am_util_faultisr_collect_data().
    129          //
    130          //*****************************************************************************
    131          //*****************************************************************************
    132          //
    133          // getStackedReg() will retrieve a specified register value, as it was stacked
    134          // by the processor after the fault, from the stack.
    135          //
    136          // The registers are stacked in the following order:
    137          //  R0, R1, R2, R3, R12, LR, PC, PSR.
    138          // To get R0 from the stack, call getStackedReg(0), r1 is getStackedReg(1)...
    139          //
    140          //*****************************************************************************
    141          #if (defined (__ARMCC_VERSION)) && (__ARMCC_VERSION < 6000000)
    142          __asm uint32_t
    143          am_fault_isr(void)
    144          {
    145              import  am_util_faultisr_collect_data
    146          
    147              push    {r7, lr}
    148              mov     r0, sp
    149              adds    r0, #(2*4)
    150              bl      am_util_faultisr_collect_data
    151              pop     {r0, pc}
    152          }
    153          
    154          __asm uint32_t
    155          getStackedReg(uint32_t regnum, uint32_t u32SP)
    156          {
    157              lsls    r0, r0, #2
    158              adds    r0, r0, r1
    159              ldr     r0, [r0]
    160              bx      lr
    161          }
    162          #elif (defined (__ARMCC_VERSION)) && (__ARMCC_VERSION > 6000000)
    163          uint32_t __attribute__((naked))
    164          am_fault_isr(void)
    165          {
    166              __asm("    push    {r7,lr}");
    167              __asm("    mov     r0, sp");
    168              __asm("    adds    r0, #(2*4)");
    169              __asm("    bl      am_util_faultisr_collect_data");
    170              __asm("    pop     {r0,pc}");
    171          }
    172          
    173          uint32_t __attribute__((naked))
    174          getStackedReg(uint32_t regnum, uint32_t u32SP)
    175          {
    176              __asm("    lsls    r0, r0, #2");
    177              __asm("    adds    r0, r1");
    178              __asm("    ldr     r0, [r0]");
    179              __asm("    bx      lr");
    180          }
    181          #elif defined(__GNUC_STDC_INLINE__)
    182          uint32_t __attribute__((naked))
    183          am_fault_isr(void)
    184          {
    185              __asm("    push    {r7,lr}");
    186              __asm("    mov     r0, sp");
    187              __asm("    adds    r0, #(2*4)");
    188              __asm("    bl      am_util_faultisr_collect_data");
    189              __asm("    pop     {r0,pc}");
    190          }
    191          
    192          uint32_t __attribute__((naked))
    193          getStackedReg(uint32_t regnum, uint32_t u32SP)
    194          {
    195              __asm("    lsls    r0, r0, #2");
    196              __asm("    adds    r0, r1");
    197              __asm("    ldr     r0, [r0]");
    198              __asm("    bx      lr");
    199          }
    200          #elif defined(__IAR_SYSTEMS_ICC__)
    201          #pragma diag_suppress = Pe940   // Suppress IAR compiler warning about missing
    202                                          // return statement on a non-void function
    203          __stackless uint32_t
    204          am_fault_isr(void)
    205          {
    206              __asm("     push    {r7,lr}");
    207              __asm("     mov     r0, sp");
    208              __asm("     adds    r0, #(2*4)");
    209              __asm("     bl      am_util_faultisr_collect_data");
    210              __asm("     pop     {r0,pc}");
    211          }
    212          
    213          __stackless uint32_t
    214          getStackedReg(uint32_t regnum, uint32_t u32SP)
    215          {
    216              __asm("     lsls    r0, r0, #2");
    217              __asm("     adds    r0, r0, r1");
    218              __asm("     ldr     r0, [r0]");
    219              __asm("     bx      lr");
    220          }
    221          #pragma diag_default = Pe940    // Restore IAR compiler warning
    222          #endif
    223          
    224          //*****************************************************************************
    225          //
    226          // am_util_faultisr_collect_data(uint32_t u32IsrSP);
    227          //
    228          // This function is intended to be called by am_fault_isr(), which is called
    229          // when the processor receives a hard fault interrupt.  This part of the
    230          // handler parses through the various fault codes and saves them into a data
    231          // structure so they can be readily examined by the user in the debugger.
    232          //
    233          // The input u32IsrSP is expected to be the value of the stack pointer when
    234          // am_fault_isr() was called.
    235          //
    236          //*****************************************************************************
    237          void
    238          am_util_faultisr_collect_data(uint32_t u32IsrSP)
    239          {
    240              volatile am_fault_t sFaultData;
    241              am_hal_mcuctrl_fault_t sHalFaultData = {0};
    242          
    243              uint32_t u32Mask = 0;
    244          
    245              //
    246              // Following is a brief overview of fault information provided by the M4.
    247              // More details can be found in the Cortex M4 User Guide.
    248              //
    249              // CFSR (Configurable Fault Status Reg) contains MMSR, BFSR, and UFSR:
    250              //   7:0    MMSR (MemManage)
    251              //          [0] IACCVIOL    Instr fetch from a location that does not
    252              //                          permit execution.
    253              //          [1] DACCVIOL    Data access violation flag. MMAR contains
    254              //                          address of the attempted access.
    255              //          [2] Reserved
    256              //          [3] MUNSTKERR   MemMange fault on unstacking for a return
    257              //                          from exception.
    258              //          [4] MSTKERR     MemMange fault on stacking for exception
    259              //                          entry.
    260              //          [5] MLSPERR     MemMange fault during FP lazy state
    261              //                          preservation.
    262              //          [6] Reserved
    263              //          [7] MMARVALID   MemManage Fault Addr Reg (MMFAR) valid flag.
    264              //  15:8    BusFault
    265              //          [0] IBUSERR     If set, instruction bus error.
    266              //          [1] PRECISERR   Data bus error. Stacked PC points to instr
    267              //                          that caused the fault.
    268              //          [2] IMPRECISERR Data bus error, but stacked return addr is not
    269              //                          related to the instr that caused the error and
    270              //                          BFAR is not valid.
    271              //          [3] UNSTKERR    Bus fault on unstacking for a return from
    272              //                          exception.
    273              //          [4] STKERR      Bus fault on stacking for exception entry.
    274              //          [5] LSPERR      Bus fault during FP lazy state preservation.
    275              //          [6] Reserved
    276              //          [7] BFARVALID   BFAR valid.
    277              //  31:16   UFSR (UsageFault)
    278              //          [0] UNDEFINSTR  Undefined instruction.
    279              //          [1] INVSTATE    Invalid state.
    280              //          [2] INVPC       Invalid PC load.
    281              //          [3] NOCP        No coprocessor.
    282              //        [7:4] Reserved
    283              //          [8] UNALIGNED   Unaligned access.
    284              //          [9] DIVBYZERO   Divide by zero.
    285              //      [15:10] Reserved
    286              //
    287          
    288              //
    289              // u32Mask is used for 2 things: 1) in the print loop, 2) as a spot to set
    290              // a breakpoint at the end of the routine.  If the printing is not used,
    291              // we'll get a compiler warning; so to avoid that warning, we'll use it
    292              // in a dummy assignment here.
    293              //
    294              sFaultData.u32CFSR = u32Mask;       // Avoid compiler warning
    295              sFaultData.u32CFSR = AM_REGVAL(AM_REG_SYSCTRL_CFSR_O);
    296              sFaultData.u8MMSR  = (sFaultData.u32CFSR >> 0)  & 0xff;
    297              sFaultData.u8BFSR  = (sFaultData.u32CFSR >> 8)  & 0xff;
    298              sFaultData.u16UFSR = (sFaultData.u32CFSR >> 16) & 0xffff;
    299          
    300              //
    301              // The address of the location that caused the fault.  e.g. if accessing an
    302              // invalid data location caused the fault, that address will appear here.
    303              //
    304              sFaultData.u32BFAR = AM_REGVAL(AM_REG_SYSCTRL_BFAR_O);
    305          
    306              //
    307              // The address of the instruction that caused the fault is the stacked PC
    308              // if BFSR bit1 is set.
    309              //
    310              sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    311          
    312              //
    313              // Get the stacked registers.
    314              // Note - the address of the instruction that caused the fault is u32PC.
    315              //
    316              sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    317              sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    318              sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    319              sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    320              sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    321              sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    322              sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    323              sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    324          
    325              //
    326              // Use the HAL MCUCTRL functions to read the fault data.
    327              //
    328          #ifdef AM_APOLLO3_MCUCTRL
    329              am_hal_mcuctrl_info_get(AM_HAL_MCUCTRL_INFO_FAULT_STATUS, &sHalFaultData);
    330          #else
    331              am_hal_mcuctrl_fault_status(&sHalFaultData);
    332          #endif
    333          
    334          
    335          #ifdef AM_UTIL_FAULTISR_PRINT
    336              //
    337              // If printf has previously been initialized in the application, we should
    338              // be able to print out the fault information.
    339              //
    340              am_util_stdio_printf("Hard Fault stacked data:\n");
    341              am_util_stdio_printf("    R0  = 0x%08X\n", sFaultData.u32R0);
    342              am_util_stdio_printf("    R1  = 0x%08X\n", sFaultData.u32R1);
    343              am_util_stdio_printf("    R2  = 0x%08X\n", sFaultData.u32R2);
    344              am_util_stdio_printf("    R3  = 0x%08X\n", sFaultData.u32R3);
    345              am_util_stdio_printf("    R12 = 0x%08X\n", sFaultData.u32R12);
    346              am_util_stdio_printf("    LR  = 0x%08X\n", sFaultData.u32LR);
    347              am_util_stdio_printf("    PC  = 0x%08X\n", sFaultData.u32PC);
    348              am_util_stdio_printf("    PSR = 0x%08X\n", sFaultData.u32PSR);
    349              am_util_stdio_printf("Other Hard Fault data:\n");
    350              am_util_stdio_printf("    Fault address = 0x%08X\n", sFaultData.u32FaultAddr);
    351              am_util_stdio_printf("    BFAR (Bus Fault Addr Reg) = 0x%08X\n", sFaultData.u32BFAR);
    352              am_util_stdio_printf("    MMSR (Mem Mgmt Fault Status Reg) = 0x%02X\n", sFaultData.u8MMSR);
    353              am_util_stdio_printf("    BFSR (Bus Fault Status Reg) = 0x%02X\n", sFaultData.u8BFSR);
    354              am_util_stdio_printf("    UFSR (Usage Fault Status Reg) = 0x%04X\n", sFaultData.u16UFSR);
    355          
    356              //
    357              // Print out any bits set in the BFSR.
    358              //
    359              u32Mask = 0x80;
    360              while (u32Mask)
    361              {
    362                  switch (sFaultData.u8BFSR & u32Mask)
    363                  {
    364                      case 0x80:
    365                          am_util_stdio_printf("        BFSR bit7: BFARVALID\n");
    366                          break;
    367                      case 0x40:
    368                          am_util_stdio_printf("        BFSR bit6: RESERVED\n");
    369                          break;
    370                      case 0x20:
    371                          am_util_stdio_printf("        BFSR bit5: LSPERR\n");
    372                          break;
    373                      case 0x10:
    374                          am_util_stdio_printf("        BFSR bit4: STKERR\n");
    375                          break;
    376                      case 0x08:
    377                          am_util_stdio_printf("        BFSR bit3: UNSTKERR\n");
    378                          break;
    379                      case 0x04:
    380                          am_util_stdio_printf("        BFSR bit2: IMPRECISERR\n");
    381                          break;
    382                      case 0x02:
    383                          am_util_stdio_printf("        BFSR bit1: PRECISEERR\n");
    384                          break;
    385                      case 0x01:
    386                          am_util_stdio_printf("        BFSR bit0: IBUSERR\n");
    387                          break;
    388                      default:
    389                          break;
    390                  }
    391                  u32Mask >>= 1;
    392              }
    393          
    394              //
    395              // Print out any Apollo2 Internal fault information.
    396              //
    397              am_util_stdio_printf("Apollo2 Fault data:\n");
    398              if (sHalFaultData.bICODE)
    399              {
    400                am_util_stdio_printf("   ICODE Fault Address: 0x%08X\n", sHalFaultData.ui32ICODE);
    401              }
    402              if (sHalFaultData.bDCODE)
    403              {
    404                am_util_stdio_printf("   DCODE Fault Address: 0x%08X\n", sHalFaultData.ui32DCODE);
    405              }
    406              if (sHalFaultData.bSYS)
    407              {
    408                am_util_stdio_printf("   SYS Fault Address: 0x%08X\n", sHalFaultData.ui32SYS);
    409              }
    410          
    411          
    412          #endif
    413          
    414              u32Mask = 0;
    415          
    416              //
    417              // Spin in an infinite loop.
    418              // We need to spin here inside the function so that we have access to
    419              // local data, i.e. sFaultData.
    420              //
    421              while(1)
    422              {
    423              }
    424          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   am_fault_isr
      88   am_util_faultisr_collect_data
        88   -> __aeabi_memclr4
        88   -> am_hal_mcuctrl_fault_status
        88   -> getStackedReg
       0   getStackedReg


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
      24  ?_0
      14  am_fault_isr
     166  am_util_faultisr_collect_data
      10  getStackedReg

 
  24 bytes in section .rodata
 198 bytes in section .text
 
 198 bytes of CODE  memory
  24 bytes of CONST memory

Errors: none
Warnings: none
