###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         23/Jan/2019  19:34:56
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\utils\am_util_stdio.c
#    Command line =  
#        -f C:\temp\EW110E.tmp
#        (C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\utils\am_util_stdio.c
#        -D iar -D AM_PART_APOLLO3 -D AM_PACKAGE_BGA -lcN
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\binary_counter\iar\bin
#        --diag_suppress Pa050 -o
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\binary_counter\iar\bin
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\binary_counter\iar\..\..\..\..\..\utils\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\binary_counter\iar\..\..\..\..\..\CMSIS\ARM\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\binary_counter\iar\..\..\..\..\..\CMSIS\AmbiqMicro\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\binary_counter\iar\..\..\..\..\..\mcu\apollo3\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\binary_counter\iar\..\..\..\..\..\devices\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\binary_counter\iar\..\..\..\bsp\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\binary_counter\iar\..\..\..\..\..\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\binary_counter\iar\..\src\
#        -On)
#    Locale       =  C
#    List file    =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\binary_counter\iar\bin\am_util_stdio.lst
#    Object file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\binary_counter\iar\bin\am_util_stdio.o
#
###############################################################################

C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\utils\am_util_stdio.c
      1          //*****************************************************************************
      2          //
      3          //! @file am_util_stdio.c
      4          //!
      5          //! @brief A few printf-style functions for use with Ambiq products
      6          //!
      7          //! Functions for performing printf-style operations without dynamic memory
      8          //! allocation.
      9          //
     10          //*****************************************************************************
     11          
     12          //*****************************************************************************
     13          //
     14          // Copyright (c) 2019, Ambiq Micro
     15          // All rights reserved.
     16          // 
     17          // Redistribution and use in source and binary forms, with or without
     18          // modification, are permitted provided that the following conditions are met:
     19          // 
     20          // 1. Redistributions of source code must retain the above copyright notice,
     21          // this list of conditions and the following disclaimer.
     22          // 
     23          // 2. Redistributions in binary form must reproduce the above copyright
     24          // notice, this list of conditions and the following disclaimer in the
     25          // documentation and/or other materials provided with the distribution.
     26          // 
     27          // 3. Neither the name of the copyright holder nor the names of its
     28          // contributors may be used to endorse or promote products derived from this
     29          // software without specific prior written permission.
     30          // 
     31          // Third party software included in this distribution is subject to the
     32          // additional license terms as defined in the /docs/licenses directory.
     33          // 
     34          // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     35          // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     36          // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     37          // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     38          // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     39          // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     40          // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     41          // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     42          // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     43          // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     44          // POSSIBILITY OF SUCH DAMAGE.
     45          //
     46          // This is part of revision v2.0.0 of the AmbiqSuite Development Package.
     47          //
     48          //*****************************************************************************
     49          
     50          #include <stdint.h>
     51          #include <stdbool.h>
     52          #include <stdarg.h>
     53          #include "am_util_stdio.h"
     54          
     55          //*****************************************************************************
     56          //
     57          // Global Variables
     58          //
     59          //*****************************************************************************
     60          
     61          // function pointer for printf
     62          am_util_stdio_print_char_t g_pfnCharPrint;
     63          
     64          // buffer for printf
     65          static char g_prfbuf[AM_PRINTF_BUFSIZE];
     66          
     67          // Flag to do conversion of '\n' to '\n\r' in sprintf()
     68          static bool g_bTxtXlate = false;
     69          
     70          //*****************************************************************************
     71          //
     72          //! @brief Sets the interface for printf calls.
     73          //!
     74          //! @param pfnCharPrint - Function pointer to be used to print to interface
     75          //!
     76          //! This function initializes the global print function which is used for
     77          //! printf. This allows users to define their own printf interface and pass it
     78          //! in as a am_util_stdio_print_char_t type.
     79          //!
     80          //! @return None.
     81          //
     82          //*****************************************************************************
     83          void
     84          am_util_stdio_printf_init(am_util_stdio_print_char_t pfnCharPrint)
     85          {
     86              g_pfnCharPrint = pfnCharPrint;
     87          }
     88          
     89          //*****************************************************************************
     90          //
     91          //! @brief Converts strings to 32-bit unsigned integers.
     92          //!
     93          //! @param *str - Pointer to the string to convert
     94          //! @param **endptr - strtoul will set this to the char after the converted num
     95          //! @param base - Base of the number as written in the input string.
     96          //!
     97          //! This function was implemented in a way similar to the strtoul function
     98          //! found in the C standard library. It will attempt to extract a numerical
     99          //! value from the input string, and return it to the caller. Invalid input
    100          //! strings will return a value of zero.
    101          //!
    102          //! @return uint32_t representing the numerical value from the string.
    103          //
    104          //*****************************************************************************
    105          uint32_t
    106          am_util_stdio_strtoul(const char *str, char **endptr, int base)
    107          {
    108              char *pos;
    109              uint32_t ui32BaseVal;
    110              uint32_t ui32RetVal;
    111          
    112              //
    113              // Prepare a pointer to start advancing through the string.
    114              //
    115              pos = (char *)str;
    116          
    117              //
    118              // Determine what base we are using. Default to '16', but change to other
    119              // values as specified by the user. If the user didn't specify anything,
    120              // try to guess the base value from looking at the first few characters of
    121              // the input
    122              //
    123              ui32BaseVal = 16;
    124          
    125              //
    126              // Switch to octal for a leading zero
    127              //
    128              if (*pos == '0')
    129              {
    130                  ui32BaseVal = 8;
    131                  pos++;
    132          
    133                  //
    134                  // Switch back to hex for a leading '0x'
    135                  //
    136                  if (*pos == 'x')
    137                  {
    138                      ui32BaseVal = 16;
    139                      pos++;
    140                  }
    141              }
    142          
    143              //
    144              // No matter what, if the user specified a base value, use that as the real
    145              // base value.
    146              //
    147              if (base)
    148              {
    149                  ui32BaseVal = base;
    150              }
    151          
    152              //
    153              // Start accumulating the converted integer value
    154              //
    155              ui32RetVal = 0;
    156          
    157              //
    158              // Loop through the digits, one character at a time. End the loop if the
    159              // number is out of range
    160              //
    161              while ((*pos >= 'a' && *pos <= 'f' && ui32BaseVal == 16) ||
    162                     (*pos >= 'A' && *pos <= 'F' && ui32BaseVal == 16) ||
    163                     (*pos >= '0' && *pos <= '9'))
    164              {
    165                  //
    166                  // Make sure to stop if we hit a NULL byte.
    167                  //
    168                  if (*pos == 0)
    169                  {
    170                      break;
    171                  }
    172          
    173                  //
    174                  // Multiply by the base value to move up one 'digit'
    175                  //
    176                  ui32RetVal *= ui32BaseVal;
    177          
    178                  //
    179                  // Add the value of the next character.
    180                  //
    181                  if (*pos >= '0' && *pos <= '9')
    182                  {
    183                      ui32RetVal += *pos - '0';
    184                  }
    185                  else if (*pos >= 'A' && *pos <= 'F')
    186                  {
    187                      ui32RetVal += (*pos - 'A') + 10;
    188                  }
    189                  else
    190                  {
    191                      ui32RetVal += (*pos - 'a') + 10;
    192                  }
    193          
    194                  //
    195                  // Grab the next character.
    196                  //
    197                  pos++;
    198              }
    199          
    200              //
    201              // If we get here, hopefully it means that we have parsed a number
    202              // correctly. The 'pos' pointer should already be pointing at the character
    203              // right after the last valid number, so set the enptr appropriately, and
    204              // return the calculated numerical value of the string.
    205              //
    206              if (endptr)
    207              {
    208                  *endptr = pos;
    209              }
    210          
    211              return ui32RetVal;
    212          }
    213          
    214          //*****************************************************************************
    215          //
    216          //  Divide an unsigned 32-bit value by 10.
    217          //
    218          //  Note: Adapted from Ch10 of Hackers Delight (hackersdelight.org).
    219          //
    220          //*****************************************************************************
    221          static uint64_t
    222          divu64_10(uint64_t ui64Val)
    223          {
    224              uint64_t q64, r64;
    225              uint32_t q32, r32, ui32Val;
    226          
    227              //
    228              // If a 32-bit value, use the more optimal 32-bit routine.
    229              //
    230              if ( ui64Val >> 32 )
    231              {
    232                  q64 = (ui64Val>>1) + (ui64Val>>2);
    233                  q64 += (q64 >> 4);
    234                  q64 += (q64 >> 8);
    235                  q64 += (q64 >> 16);
    236                  q64 += (q64 >> 32);
    237                  q64 >>= 3;
    238                  r64 = ui64Val - q64*10;
    239                  return q64 + ((r64 + 6) >> 4);
    240              }
    241              else
    242              {
    243                  ui32Val = (uint32_t)(ui64Val & 0xffffffff);
    244                  q32 = (ui32Val>>1) + (ui32Val>>2);
    245                  q32 += (q32 >> 4);
    246                  q32 += (q32 >> 8);
    247                  q32 += (q32 >> 16);
    248                  q32 >>= 3;
    249                  r32 = ui32Val - q32*10;
    250                  return (uint64_t)(q32 + ((r32 + 6) >> 4));
    251              }
    252          }
    253          
    254          //*****************************************************************************
    255          //
    256          // Return the number of decimal digits in an uint64_t.
    257          //
    258          // example: 10000 return 5, 123 returns 3.
    259          //
    260          //*****************************************************************************
    261          static int
    262          ndigits_in_u64(uint64_t ui64Val)
    263          {
    264              int iNDigits = ui64Val ? 0 : 1;
    265          
    266              while ( ui64Val )
    267              {
    268                  //
    269                  // ui32Val /= 10;
    270                  //
    271                  ui64Val = divu64_10(ui64Val);
    272                  ++iNDigits;
    273              }
    274          
    275              return iNDigits;
    276          }
    277          
    278          //*****************************************************************************
    279          //
    280          // Return the number of decimal digits in a 64-bit integer.
    281          //
    282          // Note: Does not include the '-' sign.
    283          //
    284          // example: -3 returns 1, 3 returns 1, 15 returns 2, -15 returns 2, ...
    285          //
    286          //*****************************************************************************
    287          static int
    288          ndigits_in_i64(int64_t i64Val)
    289          {
    290              if ( i64Val < 0 )
    291              {
    292                  //
    293                  // Get absolute value
    294                  //
    295                  i64Val = -i64Val;
    296              }
    297          
    298              return ndigits_in_u64((uint64_t) i64Val);
    299          }
    300          
    301          //*****************************************************************************
    302          //
    303          // Return the number of hex digits in an uint64_t.
    304          //
    305          //*****************************************************************************
    306          static int
    307          ndigits_in_hex(uint64_t ui64Val)
    308          {
    309              int iDigits = ui64Val ? 0 : 1;
    310          
    311              while ( ui64Val )
    312              {
    313                  ui64Val >>= 4;
    314                  ++iDigits;
    315              }
    316          
    317              return iDigits;
    318          }
    319          
    320          //*****************************************************************************
    321          //
    322          // Converts a string representing a decimal value to an int32_t.
    323          //
    324          // Returns the int32_t integer value.
    325          //
    326          // Note: If a count of the number of chars is desired, then provide
    327          // pui32CharCnt.
    328          //
    329          //*****************************************************************************
    330          static uint32_t
    331          decstr_to_int(const char *pcStr, uint32_t *pui32CharCnt)
    332          {
    333              bool bNeg = false;
    334              uint32_t ui32Val = 0, uCnt = 0;
    335          
    336              if ( *pcStr == '-')
    337              {
    338                  bNeg = true;
    339                  pcStr++;
    340                  uCnt++;
    341              }
    342          
    343              while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    344              {
    345                  ++uCnt;
    346          
    347                  //
    348                  // Multiply accumulated value by 10.
    349                  //
    350                  ui32Val *= 10;
    351          
    352                  //
    353                  // Add in the new low digit.
    354                  //
    355                  ui32Val += (*pcStr - '0');
    356                  pcStr++;
    357              }
    358          
    359              if ( pui32CharCnt )
    360              {
    361                  *pui32CharCnt = uCnt;
    362              }
    363          
    364              return bNeg ? -ui32Val : ui32Val;
    365          }
    366          
    367          //*****************************************************************************
    368          //
    369          // Converts ui64Val to a string.
    370          // Note: pcBuf[] must be sized for a minimum of 21 characters.
    371          //
    372          // Returns the number of decimal digits in the string.
    373          //
    374          // NOTE: If pcBuf is NULL, will compute a return ui64Val only (no chars
    375          // written).
    376          //
    377          //*****************************************************************************
    378          static int
    379          uint64_to_str(uint64_t ui64Val, char *pcBuf)
    380          {
    381              char tbuf[25];
    382              int ix = 0, iNumDig = 0;
    383              unsigned uMod;
    384              uint64_t u64Tmp;
    385          
    386              do
    387              {
    388                  //
    389                  // Divide by 10
    390                  //
    391                  u64Tmp = divu64_10(ui64Val);
    392          
    393                  //
    394                  // Get modulus
    395                  //
    396                  uMod = ui64Val - (u64Tmp * 10);
    397          
    398                  tbuf[ix++] = uMod + '0';
    399                  ui64Val = u64Tmp;
    400              } while ( ui64Val );
    401          
    402              //
    403              // Save the total number of digits
    404              //
    405              iNumDig = ix;
    406          
    407              //
    408              // Now, reverse the buffer when saving to the caller's buffer.
    409              //
    410              if ( pcBuf )
    411              {
    412                  while ( ix-- )
    413                  {
    414                      *pcBuf++ = tbuf[ix];
    415                  }
    416          
    417                  //
    418                  // Terminate the caller's buffer
    419                  //
    420                  *pcBuf = 0x00;
    421              }
    422          
    423              return iNumDig;
    424          }
    425          
    426          //*****************************************************************************
    427          //
    428          // Converts ui64Val to a hex string.  Alpha chars are lower case.
    429          // Input:
    430          //  ui64Val = Value to be converted.
    431          //  pcBuf[] must be sized for a minimum of 17 characters.
    432          //
    433          // Returns the number of hex digits required for ui64Val (does not
    434          //  include the terminating NULL char in the string).
    435          //
    436          // NOTE: If pcBuf is NULL, will compute a return value only (no chars
    437          // written).
    438          //
    439          //*****************************************************************************
    440          static int
    441          uint64_to_hexstr(uint64_t ui64Val, char *pcBuf, bool bLower)
    442          {
    443              int iNumDig, ix = 0;
    444              char cCh, tbuf[20];
    445          
    446              if ( ui64Val == 0 )
    447              {
    448                  tbuf[ix++] = '0';   // Print a '0'
    449              }
    450          
    451              while ( ui64Val )
    452              {
    453                  cCh = ui64Val & 0xf;
    454          
    455                  //
    456                  // Alpha character
    457                  //
    458                  if ( cCh > 9 )
    459                  {
    460                      cCh += bLower ? 0x27 : 0x7;
    461                  }
    462          
    463                  tbuf[ix++] = cCh + '0';
    464                  ui64Val >>= 4;
    465              }
    466          
    467              //
    468              // Save the total number of digits
    469              //
    470              iNumDig = ix;
    471          
    472              //
    473              // Now, reverse the buffer when saving to the callers buffer.
    474              //
    475              if (pcBuf)
    476              {
    477                  while (ix--)
    478                  {
    479                      *pcBuf++ = tbuf[ix];
    480                  }
    481          
    482                  //
    483                  // Terminate the caller's buffer
    484                  //
    485                  *pcBuf = 0;
    486              }
    487          
    488              return iNumDig;
    489          }
    490          
    491          //*****************************************************************************
    492          //
    493          // Return length of the given string.
    494          //
    495          //*****************************************************************************
    496          static uint32_t
    497          simple_strlen(char *pcBuf)
    498          {
    499              uint32_t ui32RetVal = 0;
    500              if ( !pcBuf )
    501              {
    502                  return ui32RetVal;
    503              }
    504          
    505              while ( *pcBuf++ )
    506              {
    507                  ui32RetVal++;
    508              }
    509              return ui32RetVal;
    510          }
    511          
    512          //*****************************************************************************
    513          //
    514          // Pad a string buffer with pad characters.
    515          //
    516          //*****************************************************************************
    517          static int32_t
    518          padbuffer(char *pcBuf, uint8_t cPadChar, int32_t i32NumChars)
    519          {
    520              int32_t i32Cnt = 0;
    521          
    522              if ( i32NumChars <= 0 )
    523              {
    524                  return i32Cnt;
    525              }
    526          
    527              while ( i32NumChars-- )
    528              {
    529                  if ( pcBuf )
    530                  {
    531                      *pcBuf++ = cPadChar;
    532                  }
    533                  i32Cnt++;
    534              }
    535          
    536              return i32Cnt;
    537          }
    538          
    539          //*****************************************************************************
    540          //
    541          //! @brief Text mode translates linefeed (\n) characters to carriage return/
    542          //! linefeed (CR/LF) combinations in printf() and sprintf() functions.
    543          //!
    544          //! @param bSetTextTranslationMode - true: Do LF to CR/LF translation.
    545          //! false: Don't do the text mode translation.
    546          //!
    547          //! This function causes the printf() and sprintf() functions to translate
    548          //! newline characters (\\n) into CR/LF (\\r\\n) combinations.
    549          //!
    550          //! @return Previous mode.
    551          //
    552          //*****************************************************************************
    553          bool
    554          am_util_stdio_textmode_set(bool bSetTextTranslationMode)
    555          {
    556              bool bRet = g_bTxtXlate;
    557          
    558              //
    559              // true=cvt LF chars to CR/LF
    560              //
    561              g_bTxtXlate = bSetTextTranslationMode;
    562          
    563              //
    564              // return previous mode.
    565              //
    566              return bRet;
    567          }
    568          
    569          //*****************************************************************************
    570          //
    571          //  Float to ASCII text. A basic implementation for providing support for
    572          //  single-precision %f.
    573          //
    574          //  param
    575          //      fValue     = Float value to be converted.
    576          //      pcBuf      = Buffer to place string AND input of buffer size.
    577          //      iPrecision = Desired number of decimal places.
    578          //      IMPORTANT: On entry, the first 32-bit word of pcBuf must
    579          //                 contain the size (in bytes) of the buffer!
    580          //                 The recommended size is at least 16 bytes.
    581          //
    582          //  This function performs a basic translation of a floating point single
    583          //  precision value to a string.
    584          //
    585          //  return Number of chars printed to the buffer.
    586          //
    587          //*****************************************************************************
    588          #define AM_FTOA_ERR_VAL_TOO_SMALL   -1
    589          #define AM_FTOA_ERR_VAL_TOO_LARGE   -2
    590          #define AM_FTOA_ERR_BUFSIZE         -3
    591          
    592          typedef union
    593          {
    594              int32_t I32;
    595              float F;
    596          } i32fl_t;
    597          
    598          static int ftoa(float fValue, char *pcBuf, int iPrecision)
    599          {
    600              i32fl_t unFloatValue;
    601              int iExp2, iBufSize;
    602              int32_t i32Significand, i32IntPart, i32FracPart;
    603              char *pcBufInitial, *pcBuftmp;
    604          
    605              iBufSize = *(uint32_t*)pcBuf;
    606              if (iBufSize < 4)
    607              {
    608                  return AM_FTOA_ERR_BUFSIZE;
    609              }
    610          
    611              if (fValue == 0.0f)
    612              {
    613                  // "0.0"
    614                  *(uint32_t*)pcBuf = 0x00 << 24 | ('0' << 16) | ('.' << 8) | ('0' << 0);
    615                  return 3;
    616              }
    617          
    618              pcBufInitial = pcBuf;
    619          
    620              unFloatValue.F = fValue;
    621          
    622              iExp2 = ((unFloatValue.I32 >> 23) & 0x000000FF) - 127;
    623              i32Significand = (unFloatValue.I32 & 0x00FFFFFF) | 0x00800000;
    624              i32FracPart = 0;
    625              i32IntPart = 0;
    626          
    627              if (iExp2 >= 31)
    628              {
    629                  return AM_FTOA_ERR_VAL_TOO_LARGE;
    630              }
    631              else if (iExp2 < -23)
    632              {
    633                  return AM_FTOA_ERR_VAL_TOO_SMALL;
    634              }
    635              else if (iExp2 >= 23)
    636              {
    637                  i32IntPart = i32Significand << (iExp2 - 23);
    638              }
    639              else if (iExp2 >= 0)
    640              {
    641                  i32IntPart = i32Significand >> (23 - iExp2);
    642                  i32FracPart = (i32Significand << (iExp2 + 1)) & 0x00FFFFFF;
    643              }
    644              else // if (iExp2 < 0)
    645              {
    646                  i32FracPart = (i32Significand & 0x00FFFFFF) >> -(iExp2 + 1);
    647              }
    648          
    649              if (unFloatValue.I32 < 0)
    650              {
    651                  *pcBuf++ = '-';
    652              }
    653          
    654              if (i32IntPart == 0)
    655              {
    656                  *pcBuf++ = '0';
    657              }
    658              else
    659              {
    660                  if (i32IntPart > 0)
    661                  {
    662                      uint64_to_str(i32IntPart, pcBuf);
    663                  }
    664                  else
    665                  {
    666                      *pcBuf++ = '-';
    667                      uint64_to_str(-i32IntPart, pcBuf);
    668                  }
    669                  while (*pcBuf)    // Get to end of new string
    670                  {
    671                      pcBuf++;
    672                  }
    673              }
    674          
    675              //
    676              // Now, begin the fractional part
    677              //
    678              *pcBuf++ = '.';
    679          
    680              if (i32FracPart == 0)
    681              {
    682                  *pcBuf++ = '0';
    683              }
    684              else
    685              {
    686                  int jx, iMax;
    687          
    688                  iMax = iBufSize - (pcBuf - pcBufInitial) - 1;
    689                  iMax = (iMax > iPrecision) ? iPrecision : iMax;
    690          
    691                  for (jx = 0; jx < iMax; jx++)
    692                  {
    693                      i32FracPart *= 10;
    694                      *pcBuf++ = (i32FracPart >> 24) + '0';
    695                      i32FracPart &= 0x00FFFFFF;
    696                  }
    697          
    698                  //
    699                  // Per the printf spec, the number of digits printed to the right of the
    700                  // decimal point (i.e. iPrecision) should be rounded.
    701                  // Some examples:
    702                  // Value        iPrecision          Formatted value
    703                  // 1.36399      Unspecified (6)     1.363990
    704                  // 1.36399      3                   1.364
    705                  // 1.36399      4                   1.3640
    706                  // 1.36399      5                   1.36399
    707                  // 1.363994     Unspecified (6)     1.363994
    708                  // 1.363994     3                   1.364
    709                  // 1.363994     4                   1.3640
    710                  // 1.363994     5                   1.36399
    711                  // 1.363995     Unspecified (6)     1.363995
    712                  // 1.363995     3                   1.364
    713                  // 1.363995     4                   1.3640
    714                  // 1.363995     5                   1.36400
    715                  // 1.996        Unspecified (6)     1.996000
    716                  // 1.996        2                   2.00
    717                  // 1.996        3                   1.996
    718                  // 1.996        4                   1.9960
    719                  //
    720                  // To determine whether to round up, we'll look at what the next
    721                  // decimal value would have been.
    722                  //
    723                  if ( ((i32FracPart * 10) >> 24) >= 5 )
    724                  {
    725                      //
    726                      // Yes, we need to round up.
    727                      // Go back through the string and make adjustments as necessary.
    728                      //
    729                      pcBuftmp = pcBuf - 1;
    730                      while ( pcBuftmp >= pcBufInitial )
    731                      {
    732                          if ( *pcBuftmp == '.' )
    733                          {
    734                          }
    735                          else if ( *pcBuftmp == '9' )
    736                          {
    737                              *pcBuftmp = '0';
    738                          }
    739                          else
    740                          {
    741                              *pcBuftmp += 1;
    742                              break;
    743                          }
    744                          pcBuftmp--;
    745                      }
    746                  }
    747              }
    748          
    749              //
    750              // Terminate the string and we're done
    751              //
    752              *pcBuf = 0x00;
    753          
    754              return (pcBuf - pcBufInitial);
    755          } // ftoa()
    756          
    757          //******************************************************************************
    758          //
    759          //! @brief Format data into string. (va_list implementation)
    760          //!
    761          //! @param *pcBuf - Pointer to the buffer to store the string
    762          //! @param *pcFmt - Pointer to formatter string
    763          //!
    764          //! A lite version of vsprintf().
    765          //!      Currently handles the following specifiers:
    766          //!      %c
    767          //!      %s
    768          //!      %[0][width]d (also %i)
    769          //!      %[0][width]u
    770          //!      %[0][width]x
    771          //!      %[.precision]f
    772          //!
    773          //!     Note than any unrecognized or unhandled format specifier character is
    774          //!     simply printed.  For example, "%%" will print a '%' character.
    775          //!
    776          //! @return uint32_t representing the number of characters printed.
    777          //
    778          //******************************************************************************
    779          uint32_t
    780          am_util_stdio_vsprintf(char *pcBuf, const char *pcFmt, va_list pArgs)
    781          {
    782              char *pcStr;
    783              uint64_t ui64Val;
    784              int64_t i64Val;
    785              uint32_t ui32NumChars, ui32CharCnt = 0;
    786              int iWidth, iVal, iPrecision;
    787              uint8_t ui8CharSpecifier, ui8PadChar;
    788              bool bLower, bLongLong, bNeg;
    789              uint32_t ui32strlen = 0;
    790          
    791              while ( *pcFmt != 0x0 )
    792              {
    793                  iPrecision = 6;             // printf() default precision for %f is 6
    794          
    795                  if ( *pcFmt != '%' )
    796                  {
    797                      //
    798                      // Accumulate the string portion of the format specification.
    799                      //
    800                      if ( pcBuf )
    801                      {
    802                          // If '\n', convert to '\r\n'
    803                          if ( *pcFmt == '\n'  &&  g_bTxtXlate )
    804                          {
    805                              *pcBuf++ = '\r';
    806                              ++ui32CharCnt;
    807                          }
    808                          *pcBuf++ = *pcFmt;
    809                      }
    810          
    811                      ++pcFmt;
    812                      ++ui32CharCnt;
    813                      continue;
    814                  }
    815          
    816                  //
    817                  // Handle the specifier.
    818                  //
    819                  ++pcFmt;
    820                  bLower = bLongLong = false;
    821          
    822                  //
    823                  // Default to space as ui8PadChar
    824                  //
    825                  ui8PadChar = ' ';
    826          
    827                  if ( *pcFmt == '0' )
    828                  {
    829                      ui8PadChar = '0';
    830                      ++pcFmt;
    831                  }
    832          
    833                  //
    834                  // Width specifier
    835                  //
    836                  iWidth = decstr_to_int(pcFmt, &ui32NumChars);
    837                  pcFmt += ui32NumChars;
    838          
    839                  //
    840                  // For now, only support a negative width specifier for %s
    841                  //
    842                  if ( ( *pcFmt != 's' )  &&  ( iWidth < 0 ) )
    843                  {
    844                      iWidth = -iWidth;
    845                  }
    846          
    847                  //
    848                  // Check for precision specifier
    849                  //
    850                  if (*pcFmt == '.')
    851                  {
    852                      ++pcFmt;
    853                      iPrecision = decstr_to_int(pcFmt, &ui32NumChars);
    854                      pcFmt += ui32NumChars;
    855                  }
    856          
    857                  //
    858                  // Check for the long or long long length field sub-specifiers, 'l' or
    859                  // 'll', which must be a modifier for either 'd', 'i', 'u', 'x', or 'X'
    860                  // (or even 'o', which is not currently supported). Other sub-specifiers
    861                  // like 'hh','h', etc. are not currently handled.
    862                  // Note - 'l' is used in Coremark, a primary reason it's supported here.
    863                  //
    864                  if ( *pcFmt == 'l' )
    865                  {
    866                      pcFmt++;
    867                      if ( *pcFmt == 'l' )    // "ll" (long long)
    868                      {
    869                          pcFmt++;
    870                          bLongLong = true;
    871                      }
    872                  }
    873          
    874                  switch ( *pcFmt )
    875                  {
    876                      case 'c':
    877                          ui8CharSpecifier = va_arg(pArgs, uint32_t);
    878          
    879                          if ( pcBuf )
    880                          {
    881                              *pcBuf++ = ui8CharSpecifier;
    882                          }
    883          
    884                          ++ui32CharCnt;
    885                          break;
    886          
    887                      case 's':
    888                          pcStr = va_arg(pArgs, char *);
    889          
    890                          //
    891                          // For %s, we support the width specifier. If iWidth is negative
    892                          // the string is left-aligned (padding on the right).  Otherwise
    893                          // the string is padded at the beginning with spaces.
    894                          //
    895                          ui32strlen = simple_strlen(pcStr);
    896                          if ( iWidth > 0 )
    897                          {
    898                              // Pad the beginning of the string (right-aligned).
    899                              if ( ui32strlen < iWidth )
    900                              {
    901                                  // String needs some padding.
    902                                  iWidth -= ui32strlen;
    903                                  iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    904                                  pcBuf += pcBuf ? iWidth : 0;
    905                                  ui32CharCnt += iWidth;
    906                                  iWidth = 0;
    907                              }
    908                          }
    909          
    910                          while (*pcStr != 0x0)
    911                          {
    912                              if ( pcBuf )
    913                              {
    914                                  *pcBuf++ = *pcStr;
    915                              }
    916          
    917                              ++pcStr;
    918                              ++ui32CharCnt;
    919                          }
    920          
    921                          if ( iWidth )
    922                          {
    923                              iWidth = -iWidth;
    924          
    925                              // Pad the end of the string (left-aligned).
    926                              if ( ui32strlen < iWidth )
    927                              {
    928                                  // String needs some padding.
    929                                  iWidth -= ui32strlen;
    930                                  iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    931                                  pcBuf += pcBuf ? iWidth : 0;
    932                                  ui32CharCnt += iWidth;
    933                                  iWidth = 0;
    934                              }
    935                          }
    936                          break;
    937          
    938                      case 'x':
    939                          bLower = true;
    940                      case 'X':
    941                          ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    942                                                va_arg(pArgs, uint32_t);
    943          
    944                          if ( iWidth )
    945                          {
    946                              //
    947                              // Compute # of leading chars
    948                              //
    949                              iWidth -= ndigits_in_hex(ui64Val);
    950          
    951                              iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    952                              pcBuf += pcBuf ? iWidth : 0;
    953                              ui32CharCnt += iWidth;
    954                              iWidth = 0;
    955                          }
    956          
    957                          iVal = uint64_to_hexstr(ui64Val, pcBuf, bLower);
    958          
    959                          if ( pcBuf )
    960                          {
    961                              pcBuf += iVal;
    962                          }
    963          
    964                          ui32CharCnt += iVal;
    965                          break;
    966          
    967                      case 'u':
    968                          ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    969                                                va_arg(pArgs, uint32_t);
    970          
    971                          if ( iWidth )
    972                          {
    973                              //
    974                              // We need to pad the beginning of the value.
    975                              // Compute # of leading chars
    976                              //
    977                              iWidth -= ndigits_in_u64(ui64Val);
    978          
    979                              iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    980                              pcBuf += pcBuf ? iWidth : 0;
    981                              ui32CharCnt += iWidth;
    982                              iWidth = 0;
    983                          }
    984          
    985                          iVal = uint64_to_str(ui64Val, pcBuf);
    986          
    987                          if ( pcBuf )
    988                          {
    989                              pcBuf += iVal;
    990                          }
    991          
    992                          ui32CharCnt += iVal;
    993                          break;
    994          
    995                      case 'd':
    996                      case 'i':
    997                          //
    998                          // Output for a negative number, for example, -5:
    999                          //   %d:-5
   1000                          //  %5d:   -5
   1001                          // %05d:-0005
   1002                          //
   1003                          i64Val = bLongLong ? va_arg(pArgs, int64_t) :
   1004                                               va_arg(pArgs, int32_t);
   1005          
   1006                          //
   1007                          // Get absolute value
   1008                          //
   1009                          if ( i64Val < 0 )
   1010                          {
   1011                              ui64Val = -i64Val;          // Get absolute value
   1012                              bNeg = true;
   1013                          }
   1014                          else
   1015                          {
   1016                              ui64Val = i64Val;
   1017                              bNeg = false;
   1018                          }
   1019          
   1020                          if ( iWidth )
   1021                          {
   1022                              //
   1023                              // We need to pad the beginning of the value.
   1024                              // Compute # of leading chars
   1025                              //
   1026                              iWidth -= ndigits_in_i64(ui64Val);
   1027          
   1028                              if ( bNeg )
   1029                              {
   1030                                  --iWidth;
   1031          
   1032                                  //
   1033                                  // Allow for the negative sign
   1034                                  //
   1035                                  if ( ui8PadChar == '0' )
   1036                                  {
   1037                                      //
   1038                                      // Print the neg sign BEFORE the leading zeros
   1039                                      //
   1040                                      if ( pcBuf )
   1041                                      {
   1042                                          *pcBuf++ = '-';
   1043                                      }
   1044          
   1045                                      ++ui32CharCnt;
   1046                                  }
   1047                              }
   1048          
   1049                              iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
   1050                              pcBuf += pcBuf ? iWidth : 0;
   1051                              ui32CharCnt += iWidth;
   1052                              iWidth = 0;
   1053          
   1054                              if ( bNeg  &&  (ui8PadChar == ' ') )
   1055                              {
   1056                                  //
   1057                                  // Print the neg sign AFTER the leading blanks
   1058                                  //
   1059                                  if ( pcBuf )
   1060                                  {
   1061                                      *pcBuf++ = '-';
   1062                                  }
   1063          
   1064                                  ++ui32CharCnt;
   1065                              }
   1066                          }
   1067                          else
   1068                          {
   1069                              if ( bNeg )
   1070                              {
   1071                                  if ( pcBuf )
   1072                                  {
   1073                                      *pcBuf++ = '-';
   1074                                  }
   1075                                  ++ui32CharCnt;
   1076                              }
   1077                          }
   1078          
   1079                          iVal = uint64_to_str(ui64Val, pcBuf);
   1080          
   1081                          if ( pcBuf )
   1082                          {
   1083                              pcBuf += iVal;
   1084                          }
   1085          
   1086                          ui32CharCnt += iVal;
   1087                          break;
   1088          
   1089          
   1090                      case 'f':
   1091                      case 'F':
   1092                          if ( pcBuf )
   1093                          {
   1094                              float fValue = va_arg(pArgs, double);
   1095          
   1096                              //
   1097                              // pcBuf is an input (size of buffer) and also an output of ftoa()
   1098                              //
   1099                              *(uint32_t*)pcBuf = 20;
   1100          
   1101                              iVal = ftoa(fValue, pcBuf, iPrecision);
   1102                              if ( iVal < 0 )
   1103                              {
   1104                                  uint32_t u32PrntErrVal;
   1105                                  if ( iVal == AM_FTOA_ERR_VAL_TOO_SMALL )
   1106                                  {
   1107                                      u32PrntErrVal = (0x00 << 24) | ('0' << 16) |
   1108                                                      ('.' << 8)   | ('0' << 0);  // "0.0"
   1109                                  }
   1110                                  else if ( iVal == AM_FTOA_ERR_VAL_TOO_LARGE )
   1111                                  {
   1112                                      u32PrntErrVal = (0x00 << 24) | ('#' << 16) |
   1113                                                      ('.' << 8)   | ('#' << 0);  // "#.#"
   1114                                  }
   1115                                  else
   1116                                  {
   1117                                      u32PrntErrVal = (0x00 << 24) | ('?' << 16) |
   1118                                                      ('.' << 8)   | ('?' << 0);  // "?.?"
   1119                                  }
   1120                                  *(uint32_t*)pcBuf = u32PrntErrVal;
   1121                                  iVal = 3;
   1122                              }
   1123                              ui32CharCnt += iVal;
   1124                              pcBuf += iVal;
   1125                          }
   1126                          break;
   1127          
   1128                      //
   1129                      // Invalid specifier character
   1130                      // For non-handled specifiers, we'll just print the character.
   1131                      // e.g. this will allow the normal printing of a '%' using
   1132                      // "%%".
   1133                      //
   1134                      default:
   1135                          if ( pcBuf )
   1136                          {
   1137                              *pcBuf++ = *pcFmt;
   1138                          }
   1139          
   1140                          ++ui32CharCnt;
   1141                          break;
   1142          
   1143                  } // switch()
   1144          
   1145                  //
   1146                  // Bump the format specification to the next character
   1147                  //
   1148                  ++pcFmt;
   1149          
   1150              } // while ()
   1151          
   1152              //
   1153              // Terminate the string
   1154              //
   1155              if ( pcBuf )
   1156              {
   1157                  *pcBuf = 0x0;
   1158              }
   1159          
   1160              return (ui32CharCnt);
   1161          }
   1162          
   1163          //******************************************************************************
   1164          //
   1165          //! @brief Format data into string.
   1166          //!
   1167          //! @param *pcBuf - Pointer to the buffer to store the string
   1168          //! @param *pcFmt - Pointer to formater string
   1169          //!
   1170          //! A lite version of vsprintf().
   1171          //!      Currently handles the following specifiers:
   1172          //!      %c
   1173          //!      %s
   1174          //!      %[0][width]d (also %i)
   1175          //!      %[0][width]u
   1176          //!      %[0][width]x
   1177          //!
   1178          //!     Note than any unrecognized or unhandled format specifier character is
   1179          //!     simply printed.  For example, "%%" will print a '%' character.
   1180          //!
   1181          //! @return uint32_t representing the number of characters printed.
   1182          //
   1183          //******************************************************************************
   1184          uint32_t
   1185          am_util_stdio_sprintf(char *pcBuf, const char *pcFmt, ...)
   1186          {
   1187              uint32_t ui32CharCnt;
   1188          
   1189              va_list pArgs;
   1190              va_start(pArgs, pcFmt);
   1191              ui32CharCnt = am_util_stdio_vsprintf(pcBuf, pcFmt, pArgs);
   1192              va_end(pArgs);
   1193          
   1194              return ui32CharCnt;
   1195          }
   1196          
   1197          //*****************************************************************************
   1198          //
   1199          //! @brief A lite version of printf()
   1200          //!
   1201          //! @param *pcFmt - Pointer to formatter string
   1202          //!
   1203          //!  See am_util_stdio_sprintf() for more details.
   1204          //!
   1205          //! @return uint32_t representing the number of characters printed.
   1206          //
   1207          // *****************************************************************************
   1208          uint32_t
   1209          am_util_stdio_printf(const char *pcFmt, ...)
   1210          {
   1211              uint32_t ui32NumChars;
   1212          
   1213              if (!g_pfnCharPrint)
   1214              {
   1215                  return 0;
   1216              }
   1217          
   1218              //
   1219              // Convert to the desired string.
   1220              //
   1221              va_list pArgs;
   1222              va_start(pArgs, pcFmt);
   1223              ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
   1224              va_end(pArgs);
   1225          
   1226              //
   1227              // This is where we print the buffer to the configured interface.
   1228              //
   1229              g_pfnCharPrint(g_prfbuf);
   1230          
   1231              //
   1232              // return the number of characters printed.
   1233              //
   1234              return ui32NumChars;
   1235          }
   1236          
   1237          //*****************************************************************************
   1238          //
   1239          //! @brief Clear the terminal screen
   1240          //!
   1241          //! This function clears a standard terminal screen.
   1242          //!
   1243          //! @return None.
   1244          //
   1245          //*****************************************************************************
   1246          void
   1247          am_util_stdio_terminal_clear(void)
   1248          {
   1249              //
   1250              // Escape codes to clear a terminal screen and put the cursor in the top
   1251              // left corner.
   1252              // We'll first print a number of spaces, which helps get the ITM in sync
   1253              // with AM Flash, especially after a reset event or a system clock
   1254              // frequency change.
   1255              //
   1256              am_util_stdio_printf("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
   1257          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   am_util_stdio_printf
        40   -- Indirect call
        40   -> am_util_stdio_vsprintf
       0   am_util_stdio_printf_init
      24   am_util_stdio_sprintf
        24   -> am_util_stdio_vsprintf
      12   am_util_stdio_strtoul
       8   am_util_stdio_terminal_clear
         8   -> am_util_stdio_printf
       0   am_util_stdio_textmode_set
      88   am_util_stdio_vsprintf
        88   -> __aeabi_d2f
        88   -> decstr_to_int
        88   -> ftoa
        88   -> ndigits_in_hex
        88   -> ndigits_in_i64
        88   -> ndigits_in_u64
        88   -> padbuffer
        88   -> simple_strlen
        88   -> uint64_to_hexstr
        88   -> uint64_to_str
       8   decstr_to_int
      16   divu64_10
      56   ftoa
        56   -> uint64_to_str
       0   ndigits_in_hex
      16   ndigits_in_i64
        16   -> ndigits_in_u64
      16   ndigits_in_u64
        16   -> divu64_10
       4   padbuffer
       0   simple_strlen
      36   uint64_to_hexstr
      64   uint64_to_str
        64   -> divu64_10


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
      20  ?_0
      54  am_util_stdio_printf
       8  am_util_stdio_printf_init
      26  am_util_stdio_sprintf
     154  am_util_stdio_strtoul
      10  am_util_stdio_terminal_clear
      14  am_util_stdio_textmode_set
    1058  am_util_stdio_vsprintf
      72  decstr_to_int
     190  divu64_10
     374  ftoa
       1  g_bTxtXlate
       4  g_pfnCharPrint
     256  g_prfbuf
      40  ndigits_in_hex
      26  ndigits_in_i64
      48  ndigits_in_u64
      34  padbuffer
      24  simple_strlen
     120  uint64_to_hexstr
     126  uint64_to_str

 
   261 bytes in section .bss
    20 bytes in section .rodata
 2 406 bytes in section .text
 
 2 406 bytes of CODE  memory
    20 bytes of CONST memory
   261 bytes of DATA  memory

Errors: none
Warnings: none
