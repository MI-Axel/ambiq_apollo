###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         12/Mar/2019  10:07:07
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_ctimer.c
#    Command line =  
#        -f C:\temp\EW806E.tmp
#        (C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_ctimer.c
#        -D iar -D AM_PART_APOLLO3 -D AM_PACKAGE_BGA -lcN
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --diag_suppress Pa050 -o
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\utils\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\ARM\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\AmbiqMicro\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\mcu\apollo3\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\devices\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\bsp\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\sound\
#        -On)
#    Locale       =  C
#    List file    =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_ctimer.lst
#    Object file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_ctimer.o
#
###############################################################################

C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_ctimer.c
      1          //*****************************************************************************
      2          //
      3          //  am_hal_ctimer.c
      4          //! @file
      5          //!
      6          //! @brief Functions for interfacing with the Counter/Timer module.
      7          //!
      8          //! @addtogroup ctimer3 Counter/Timer (CTIMER)
      9          //! @ingroup apollo3hal
     10          //! @{
     11          //
     12          //*****************************************************************************
     13          
     14          //*****************************************************************************
     15          //
     16          // Copyright (c) 2019, Ambiq Micro
     17          // All rights reserved.
     18          // 
     19          // Redistribution and use in source and binary forms, with or without
     20          // modification, are permitted provided that the following conditions are met:
     21          // 
     22          // 1. Redistributions of source code must retain the above copyright notice,
     23          // this list of conditions and the following disclaimer.
     24          // 
     25          // 2. Redistributions in binary form must reproduce the above copyright
     26          // notice, this list of conditions and the following disclaimer in the
     27          // documentation and/or other materials provided with the distribution.
     28          // 
     29          // 3. Neither the name of the copyright holder nor the names of its
     30          // contributors may be used to endorse or promote products derived from this
     31          // software without specific prior written permission.
     32          // 
     33          // Third party software included in this distribution is subject to the
     34          // additional license terms as defined in the /docs/licenses directory.
     35          // 
     36          // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     37          // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     38          // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     39          // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     40          // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     41          // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     42          // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     43          // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     44          // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     45          // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     46          // POSSIBILITY OF SUCH DAMAGE.
     47          //
     48          // This is part of revision v2.0.0 of the AmbiqSuite Development Package.
     49          //
     50          //*****************************************************************************
     51          
     52          #include <stdint.h>
     53          #include <stdbool.h>
     54          #include "am_mcu_apollo.h"
     55          
     56          //*****************************************************************************
     57          //
     58          // Address space distance between timer configuration registers.
     59          //
     60          //*****************************************************************************
     61          //! Size of timer register block. T/E, CMPA, CMPB, CTRL, AUXA, AUXB, AUXCTRL.
     62          #define TIMER_OFFSET            (&CTIMER->TMR1 - &CTIMER->TMR0)
     63          //! CMPR Register Offset.
     64          #define CTIMER_CMPR_OFFSET      (&CTIMER->CMPRB0 - &CTIMER->CMPRA0)
     65          //! AUX CMPR Register Offset.
     66          #define CTIMER_CMPR_AUX_OFFSET  (&CTIMER->CMPRAUXB0 - &CTIMER->CMPRAUXA0)
     67          
     68          
     69          //*****************************************************************************
     70          //
     71          // Adjacency check
     72          //
     73          // This is related to the timer read workaround. This macro checks to see if
     74          // the two supplied count values are within one "tick" of eachother. It should
     75          // still pass in the event of a timer rollover.
     76          //
     77          //*****************************************************************************
     78          //! Timer read workaround: Do count values differ by one tick or less.
     79          #define adjacent(A, B)      (((A) == (B)) || (((A) + 1) == (B)) || ((B) == 0))
     80          
     81          //*****************************************************************************
     82          //
     83          //! Array of function pointers for handling CTimer interrupts.
     84          //
     85          //*****************************************************************************
     86          static am_hal_ctimer_handler_t g_am_hal_ctimer_ppfnHandlers[32];
     87          
     88          //
     89          // Store the timer clock source value depending on segment.
     90          // Getting the source clock everytime from the CTRL register will incur bus
     91          // latency.  This table is maintained to minimize the read latency when
     92          // attempting to retrieve the CLKSRC.
     93          // CLKSRC is 5 bits, so uint8_t is adequate for the table.
     94          //
     95          static uint8_t
     96          g_ui8ClkSrc[AM_HAL_CTIMER_TIMERS_NUM][2] =
     97          {
     98              {0xFF, 0xFF}, {0xFF, 0xFF}, {0xFF, 0xFF}, {0xFF, 0xFF},
     99              {0xFF, 0xFF}, {0xFF, 0xFF}, {0xFF, 0xFF}, {0xFF, 0xFF}
    100          };
    101          
    102          //
    103          // Table of TMR register addresses.
    104          //
    105          static const uint32_t
    106          g_ui32TMRAddrTbl[AM_HAL_CTIMER_TIMERS_NUM] =
    107          {
    108              AM_REGADDR(CTIMER,TMR0), AM_REGADDR(CTIMER,TMR1), AM_REGADDR(CTIMER,TMR2),
    109              AM_REGADDR(CTIMER,TMR3), AM_REGADDR(CTIMER,TMR4), AM_REGADDR(CTIMER,TMR5),
    110              AM_REGADDR(CTIMER,TMR6), AM_REGADDR(CTIMER,TMR7)
    111          };
    112          
    113          //
    114          // Given the 5-bit clock source value as an index, this lookup table returns the
    115          // number of LSbs to be masked off for the back2back reads.
    116          //
    117          static const uint8_t
    118          g_ui8TmrClkSrcMask[32] =  // 5-bit field = 32 table entries
    119          {
    120              0x0F,       //  0: CTIMER_CTRL0_TMRA0CLK_TMRPIN     (CLK_PIN)
    121              0x0F,       //  1: CTIMER_CTRL0_TMRA0CLK_HFRC_DIV4  (HFRC_12MHZ)
    122              0x03,       //  2: CTIMER_CTRL0_TMRA0CLK_HFRC_DIV16 (HFRC_3MHZ)
    123              0x01,       //  3: CTIMER_CTRL0_TMRA0CLK_HFRC_DIV256  (HFRC_187_5KHZ)
    124              0x01,       //  4: CTIMER_CTRL0_TMRA0CLK_HFRC_DIV1024 (HFRC_47KHZ)
    125              0x01,       //  5: CTIMER_CTRL0_TMRA0CLK_HFRC_DIV4K (HFRC_12KHZ)
    126              0x00,       //  6: CTIMER_CTRL0_TMRA0CLK_XT         (XT_32_768KHZ)
    127              0x00,       //  7: CTIMER_CTRL0_TMRA0CLK_XT_DIV2    (XT_16_384KHZ)
    128              0x00,       //  8: CTIMER_CTRL0_TMRA0CLK_XT_DIV16   (XT_2_048KHZ)
    129              0x00,       //  9: CTIMER_CTRL0_TMRA0CLK_XT_DIV128  (XT_256HZ)
    130              0x00,       // 10: CTIMER_CTRL0_TMRA0CLK_LFRC_DIV2  (LFRC_512HZ)
    131              0x00,       // 11: CTIMER_CTRL0_TMRA0CLK_LFRC_DIV32 (LFRC_32HZ)
    132              0x00,       // 12: CTIMER_CTRL0_TMRA0CLK_LFRC_DIV1K (LFRC_1HZ)
    133              0x00,       // 13: CTIMER_CTRL0_TMRA0CLK_LFRC       (LFRC_1_16HZ)
    134              0x00,       // 14: CTIMER_CTRL0_TMRA0CLK_RTC_100HZ  (RTC_100HZ)
    135              0x00,       // 15: CTIMER_CTRL0_TMRA0CLK_HCLK_DIV4  (HCLK_DIV4)
    136              0x00,       // 16: CTIMER_CTRL0_TMRA0CLK_XT_DIV4    (XT_DIV4)
    137              0x00,       // 17: CTIMER_CTRL0_TMRA0CLK_XT_DIV8    (XT_DIV8)
    138              0x00,       // 18: CTIMER_CTRL0_TMRA0CLK_XT_DIV32   (XT_DIV32)
    139              0x00,       // 19: Reserved
    140              0x0F,       // 20: CTIMERxx OUT
    141              0x0F,       // 21:  "
    142              0x0F,       // 22:  "
    143              0x0F,       // 23:  "
    144              0x0F,       // 24:  "
    145              0x0F,       // 25:  "
    146              0x0F,       // 26:  "
    147              0x0F,       // 27:  "
    148              0x0F,       // 28:  "
    149              0x00,       // 29: CTIMER_CTRL0_TMRA0CLK_BUCKBLE
    150              0x00,       // 30: CTIMER_CTRL0_TMRA0CLK_BUCKB
    151              0x00        // 31: CTIMER_CTRL0_TMRA0CLK_BUCKA
    152          };
    153          
    154          //*****************************************************************************
    155          //
    156          // Lookup tables used by am_hal_ctimer_output_config().
    157          //
    158          //  CTx_tbl[] relates the padnum and pad funcsel based on a given CTx.
    159          //  Valid pads for CTx are: 4-7, 11-13, 18-19, 22-33, 35, 37, 39, 42-49.
    160          //
    161          //  outcfg_tbl[] contains attributes of the 4 output signal types for each
    162          //  of the 32 CTx signals. Therefore it is indexed by CTnumber 0-31.
    163          //  This table provides only the non-common OUTCFG attributes (2-5, other
    164          //  settings are shown below).
    165          //  OUTCFG 0 = Force output to 0.
    166          //  OUTCFG 1 = Force output to 1.
    167          //  OUTCFG 6 = A6OUT2.
    168          //  OUTCFG 7 = A7OUT2.
    169          //
    170          //*****************************************************************************
    171          #define CTXPADNUM(ctx)  ((CTx_tbl[ctx] >> 0) & 0x3f)
    172          #define CTXPADFNC(ctx)  ((CTx_tbl[ctx] >> 8) & 0x7)
    173          #define CTX(pad, fn)    ((fn << 8) | (pad << 0))
    174          static const uint16_t CTx_tbl[32] =
    175          {
    176              CTX(12,2), CTX(25,2), CTX(13,2), CTX(26,2), CTX(18,2),      // 0 - 4
    177              CTX(27,2), CTX(19,2), CTX(28,2), CTX( 5,7), CTX(29,2),      // 5 - 9
    178              CTX( 6,5), CTX(30,2), CTX(22,2), CTX(31,2), CTX(23,2),      // 10 - 14
    179              CTX(32,2), CTX(42,2), CTX( 4,6), CTX(43,2), CTX( 7,7),      // 15 - 19
    180              CTX(44,2), CTX(24,5), CTX(45,2), CTX(33,6), CTX(46,2),      // 20 - 24
    181              CTX(39,2), CTX(47,2), CTX(35,5), CTX(48,2), CTX(37,7),      // 25 - 29
    182              CTX(49,2), CTX(11,2)                                        // 30 - 31
    183          };
    184          
    185          #define OUTC(timB,timN,N2)      ((N2 << 4) | (timB << 3) | (timN << 0))
    186          #define OUTCTIMN(ctx,n)         (outcfg_tbl[ctx][n] & (0x7 << 0))
    187          #define OUTCTIMB(ctx,n)         (outcfg_tbl[ctx][n] & (0x1 << 3))
    188          #define OUTCO2(ctx,n)           (outcfg_tbl[ctx][n] & (0x1 << 4))
    189          static const uint8_t outcfg_tbl[32][4] =
    190          {
    191              {OUTC(0,0,0), OUTC(1,2,1), OUTC(0,5,1), OUTC(0,6,0)},     // CTX0:  A0OUT,  B2OUT2, A5OUT2, A6OUT
    192              {OUTC(0,0,1), OUTC(0,0,0), OUTC(0,5,0), OUTC(1,7,1)},     // CTX1:  A0OUT2, A0OUT,  A5OUT,  B7OUT2
    193              {OUTC(1,0,0), OUTC(1,1,1), OUTC(1,6,1), OUTC(0,7,0)},     // CTX2:  B0OUT,  B1OUT2, B6OUT2, A7OUT
    194              {OUTC(1,0,1), OUTC(1,0,0), OUTC(0,1,0), OUTC(0,6,0)},     // CTX3:  B0OUT2, B0OUT,  A1OUT,  A6OUT
    195              {OUTC(0,1,0), OUTC(0,2,1), OUTC(0,5,1), OUTC(1,5,0)},     // CTX4:  A1OUT,  A2OUT2, A5OUT2, B5OUT
    196              {OUTC(0,1,1), OUTC(0,1,0), OUTC(1,6,0), OUTC(0,7,0)},     // CTX5:  A1OUT2, A1OUT,  B6OUT,  A7OUT
    197              {OUTC(1,1,0), OUTC(0,1,0), OUTC(1,5,1), OUTC(1,7,0)},     // CTX6:  B1OUT,  A1OUT,  B5OUT2, B7OUT
    198              {OUTC(1,1,1), OUTC(1,1,0), OUTC(1,5,0), OUTC(0,7,0)},     // CTX7:  B1OUT2, B1OUT,  B5OUT,  A7OUT
    199              {OUTC(0,2,0), OUTC(0,3,1), OUTC(0,4,1), OUTC(1,6,0)},     // CTX8:  A2OUT,  A3OUT2, A4OUT2, B6OUT
    200              {OUTC(0,2,1), OUTC(0,2,0), OUTC(0,4,0), OUTC(1,0,0)},     // CTX9:  A2OUT2, A2OUT,  A4OUT,  B0OUT
    201              {OUTC(1,2,0), OUTC(1,3,1), OUTC(1,4,1), OUTC(0,6,0)},     // CTX10: B2OUT,  B3OUT2, B4OUT2, A6OUT
    202              {OUTC(1,2,1), OUTC(1,2,0), OUTC(1,4,0), OUTC(1,5,1)},     // CTX11: B2OUT2, B2OUT,  B4OUT,  B5OUT2
    203              {OUTC(0,3,0), OUTC(1,1,0), OUTC(1,0,1), OUTC(1,6,1)},     // CTX12: A3OUT,  B1OUT,  B0OUT2, B6OUT2
    204              {OUTC(0,3,1), OUTC(0,3,0), OUTC(0,6,0), OUTC(1,4,1)},     // CTX13: A3OUT2, A3OUT,  A6OUT,  B4OUT2
    205              {OUTC(1,3,0), OUTC(1,1,0), OUTC(1,7,1), OUTC(0,7,0)},     // CTX14: B3OUT,  B1OUT,  B7OUT2, A7OUT
    206              {OUTC(1,3,1), OUTC(1,3,0), OUTC(0,7,0), OUTC(0,4,1)},     // CTX15: B3OUT2, B3OUT,  A7OUT,  A4OUT2
    207              {OUTC(0,4,0), OUTC(0,0,0), OUTC(0,0,1), OUTC(1,3,1)},     // CTX16: A4OUT,  A0OUT,  A0OUT2, B3OUT2
    208              {OUTC(0,4,1), OUTC(1,7,0), OUTC(0,4,0), OUTC(0,1,1)},     // CTX17: A4OUT2, B7OUT,  A4OUT,  A1OUT2
    209              {OUTC(1,4,0), OUTC(1,0,0), OUTC(0,0,0), OUTC(0,3,1)},     // CTX18: B4OUT,  B0OUT,  A0OUT,  A3OUT2
    210              {OUTC(1,4,1), OUTC(0,2,0), OUTC(1,4,0), OUTC(1,1,1)},     // CTX19: B4OUT2, A2OUT,  B4OUT,  B1OUT2
    211              {OUTC(0,5,0), OUTC(0,1,0), OUTC(0,1,1), OUTC(1,2,1)},     // CTX20: A5OUT,  A1OUT,  A1OUT2, B2OUT2
    212              {OUTC(0,5,1), OUTC(0,1,0), OUTC(1,5,0), OUTC(0,0,1)},     // CTX21: A5OUT2, A1OUT,  B5OUT,  A0OUT2
    213              {OUTC(1,5,0), OUTC(0,6,0), OUTC(0,1,0), OUTC(0,2,1)},     // CTX22: B5OUT,  A6OUT,  A1OUT,  A2OUT2
    214              {OUTC(1,5,1), OUTC(0,7,0), OUTC(0,5,0), OUTC(1,0,1)},     // CTX23: B5OUT2, A7OUT,  A5OUT,  B0OUT2
    215              {OUTC(0,6,0), OUTC(0,2,0), OUTC(0,1,0), OUTC(1,1,1)},     // CTX24: A6OUT,  A2OUT,  A1OUT,  B1OUT2
    216              {OUTC(1,4,1), OUTC(1,2,0), OUTC(0,6,0), OUTC(0,2,1)},     // CTX25: B4OUT2, B2OUT,  A6OUT,  A2OUT2
    217              {OUTC(1,6,0), OUTC(1,2,0), OUTC(0,5,0), OUTC(0,1,1)},     // CTX26: B6OUT,  B2OUT,  A5OUT,  A1OUT2
    218              {OUTC(1,6,1), OUTC(0,1,0), OUTC(1,6,0), OUTC(1,2,1)},     // CTX27: B6OUT2, A1OUT,  B6OUT,  B2OUT2
    219              {OUTC(0,7,0), OUTC(0,3,0), OUTC(0,5,1), OUTC(1,0,1)},     // CTX28: A7OUT,  A3OUT,  A5OUT2, B0OUT2
    220              {OUTC(1,5,1), OUTC(0,1,0), OUTC(0,7,0), OUTC(0,3,1)},     // CTX29: B5OUT2, A1OUT,  A7OUT,  A3OUT2
    221              {OUTC(1,7,0), OUTC(1,3,0), OUTC(0,4,1), OUTC(0,0,1)},     // CTX30: B7OUT,  B3OUT,  A4OUT2, A0OUT2
    222              {OUTC(1,7,1), OUTC(0,6,0), OUTC(1,7,0), OUTC(1,3,1)},     // CTX31: B7OUT2, A6OUT,  B7OUT,  B3OUT2
    223          };
    224          
    225          //*****************************************************************************
    226          //
    227          // Static function for reading the timer value.
    228          //
    229          //*****************************************************************************
    230          #if (defined (__ARMCC_VERSION)) && (__ARMCC_VERSION < 6000000)
    231          __asm void
    232          am_hal_triple_read( uint32_t u32TimerAddr, uint32_t ui32Data[])
    233          {
    234              push {r4}                       // Save r4
    235              mrs     r4, PRIMASK             // Save current interrupt state
    236              cpsid   i                       // Disable INTs while reading the reg
    237              ldr     r3, [r1, #0]            // Read the designated register 3 times
    238              ldr     r2, [r1, #0]            //  "
    239              ldr     r1, [r1, #0]            //  "
    240              msr     PRIMASK, r4             // Restore interrupt state
    241              pop     {r4}                    // Restore r4
    242              str     r3, [r0, #0]            // Store 1st read value to array
    243              str     r2, [r0, #4]            // Store 2nd read value to array
    244              str     r1, [r0, #8]            // Store 3rd read value to array
    245              bx      lr                      // Return to caller
    246          }
    247          #elif (defined (__ARMCC_VERSION)) && (__ARMCC_VERSION >= 6000000)
    248          void
    249          am_hal_triple_read(uint32_t u32TimerAddr, uint32_t ui32Data[])
    250          {
    251            __asm (
    252              " mrs   r4, PRIMASK\n"
    253              " cpsid i\n"
    254              " nop\n"
    255              " ldr   R0, [%[u32TimerAddr], #0]\n"
    256              " ldr   R1, [%[u32TimerAddr], #0]\n"
    257              " ldr   R3, [%[u32TimerAddr], #0]\n"
    258              " msr   PRIMASK, r4\n"
    259              " str   R0, [%[ui32Data], #0]\n"
    260              " str   R1, [%[ui32Data], #4]\n"
    261              " str   R3, [%[ui32Data], #8]\n"
    262              :
    263              : [u32TimerAddr] "r" (u32TimerAddr),
    264                [ui32Data] "r" (&ui32Data[0])
    265              : "r0", "r1", "r3", "r4"
    266            );
    267          }
    268          #elif defined(__GNUC_STDC_INLINE__)
    269          __attribute__((naked))
    270          void
    271          am_hal_triple_read(uint32_t u32TimerAddr, uint32_t ui32Data[])
    272          {
    273              __asm
    274              (
    275                  "   push {r4}           \n"             // Save r4
    276                  "   mrs     r4, PRIMASK \n"             // Save current interrupt state
    277                  "   cpsid   i           \n"             // Disable INTs while reading the reg
    278                  "   ldr     r3, [r1, #0]\n"             // Read the designated register 3 times
    279                  "   ldr     r2, [r1, #0]\n"             //  "
    280                  "   ldr     r1, [r1, #0]\n"             //  "
    281                  "   msr     PRIMASK, r4 \n"             // Restore interrupt state
    282                  "   pop     {r4}        \n"             // Restore r4
    283                  "   str     r3, [r0, #0]\n"             // Store 1st read value to array
    284                  "   str     r2, [r0, #4]\n"             // Store 2nd read value to array
    285                  "   str     r1, [r0, #8]\n"             // Store 3rd read value to array
    286                  "   bx      lr          \n"             // Return to caller
    287              );
    288          }
    289          #elif defined(__IAR_SYSTEMS_ICC__)
    290          #pragma diag_suppress = Pe940   // Suppress IAR compiler warning about missing
    291                                          // return statement on a non-void function
    292          __stackless void
    293          am_hal_triple_read( uint32_t u32TimerAddr, uint32_t ui32Data[])
    294          {
    295              __asm(" push {r4}           ");         // Save r4
    296              __asm(" mrs     r4, PRIMASK ");         // Save current interrupt state
    297              __asm(" cpsid   i           ");         // Disable INTs while reading the reg
    298              __asm(" ldr     r3, [r1, #0]");         // Read the designated register 3 times
    299              __asm(" ldr     r2, [r1, #0]");         //  "
    300              __asm(" ldr     r1, [r1, #0]");         //  "
    301              __asm(" msr     PRIMASK, r4 ");         // Restore interrupt state
    302              __asm(" pop     {r4}        ");         // Restore r4
    303              __asm(" str     r3, [r0, #0]");         // Store 1st read value to array
    304              __asm(" str     r2, [r0, #4]");         // Store 2nd read value to array
    305              __asm(" str     r1, [r0, #8]");         // Store 3rd read value to array
    306              __asm(" bx      lr          ");         // Return to caller
    307          }
    308          #pragma diag_default = Pe940    // Restore IAR compiler warning
    309          #else
    310          #error Compiler is unknown, please contact Ambiq support team
    311          #endif
    312          
    313          //*****************************************************************************
    314          //
    315          //! @brief Convenience function for responding to CTimer interrupts.
    316          //!
    317          //! @param ui32Status is the interrupt status as returned by
    318          //! am_hal_ctimer_int_status_get()
    319          //!
    320          //! This function may be called from am_ctimer_isr() to read the status of
    321          //! the CTimer interrupts, determine which source caused the most recent
    322          //! interrupt, and call an interrupt handler function to respond. The interrupt
    323          //! handler to be called must be first registered with the
    324          //! am_hal_ctimer_int_register() function.
    325          //!
    326          //! In the event that multiple sources are active, the corresponding
    327          //! interrupt handlers will be called in numerical order based on interrupt def.
    328          //!
    329          //! @return None.
    330          //
    331          //*****************************************************************************
    332          void
    333          am_hal_ctimer_int_service(uint32_t ui32Status)
    334          {
    335          
    336              am_hal_ctimer_handler_t pfnHandler;
    337          
    338              while ( ui32Status )
    339              {
    340                  uint32_t ui32Clz;
    341                  //
    342                  // Pick one of any remaining active interrupt bits
    343                  //
    344          #ifdef __IAR_SYSTEMS_ICC__
    345                  ui32Clz = __CLZ(ui32Status);
    346          #else
    347                  ui32Clz = __builtin_clz(ui32Status);
    348          #endif
    349          
    350                  //
    351                  // Turn off the bit we picked in the working copy
    352                  //
    353                  ui32Status &= ~(0x80000000 >> ui32Clz);
    354          
    355                  //
    356                  // Check the bit handler table to see if there is an interrupt handler
    357                  // registered for this particular bit.
    358                  //
    359                  pfnHandler = g_am_hal_ctimer_ppfnHandlers[31 - ui32Clz];
    360                  if ( pfnHandler )
    361                  {
    362                      //
    363                      // If we found an interrupt handler routine, call it now.
    364                      //
    365                      pfnHandler();
    366                  }
    367              }
    368          
    369          } // am_hal_ctimer_int_service()
    370          
    371          //*****************************************************************************
    372          //
    373          //! @brief Register an interrupt handler for CTimer.
    374          //!
    375          //! @param ui32Interrupt - interrupt number to assign this interrupt handler to.
    376          //! @param pfnHandler - Function to call when this interrupt is received.
    377          //!
    378          //! This function allows the caller to specify a function that should be called
    379          //! any time a Ctimer interrupt is received. Registering an
    380          //! interrupt handler using this function adds the function pointer to an array
    381          //! in SRAM. This interrupt handler will be called by am_hal_ctimer_int_service()
    382          //! whenever the ui32Status parameter indicates that the corresponding interrupt.
    383          //!
    384          //! To remove an interrupt handler that has already been registered, the
    385          //! pfnHandler parameter may be set to zero.
    386          //!
    387          //! @note This function will not have any effect unless the
    388          //! am_hal_ctimer_int_service() function is being used.
    389          //!
    390          //! @return None.
    391          //
    392          //*****************************************************************************
    393          void
    394          am_hal_ctimer_int_register(uint32_t ui32Interrupt,
    395                                     am_hal_ctimer_handler_t pfnHandler)
    396          {
    397              uint32_t intIdx = 0;
    398          
    399              //
    400              // Check to make sure the interrupt number is valid. (Debug builds only)
    401              //
    402              switch (ui32Interrupt)
    403              {
    404                  case CTIMER_INTEN_CTMRA0C0INT_Msk:
    405                      intIdx = CTIMER_INTEN_CTMRA0C0INT_Pos;
    406                      break;
    407          
    408                  case CTIMER_INTEN_CTMRB0C0INT_Msk:
    409                      intIdx = CTIMER_INTEN_CTMRB0C0INT_Pos;
    410                      break;
    411          
    412                  case CTIMER_INTEN_CTMRA1C0INT_Msk:
    413                      intIdx = CTIMER_INTEN_CTMRA1C0INT_Pos;
    414                      break;
    415          
    416                  case CTIMER_INTEN_CTMRB1C0INT_Msk:
    417                      intIdx = CTIMER_INTEN_CTMRB1C0INT_Pos;
    418                      break;
    419          
    420                  case CTIMER_INTEN_CTMRA2C0INT_Msk:
    421                      intIdx = CTIMER_INTEN_CTMRA2C0INT_Pos;
    422                      break;
    423          
    424                  case CTIMER_INTEN_CTMRB2C0INT_Msk:
    425                      intIdx = CTIMER_INTEN_CTMRB2C0INT_Pos;
    426                      break;
    427          
    428                  case CTIMER_INTEN_CTMRA3C0INT_Msk:
    429                      intIdx = CTIMER_INTEN_CTMRA3C0INT_Pos;
    430                      break;
    431          
    432                  case CTIMER_INTEN_CTMRB3C0INT_Msk:
    433                      intIdx = CTIMER_INTEN_CTMRB3C0INT_Pos;
    434                      break;
    435          
    436                  case CTIMER_INTEN_CTMRA4C0INT_Msk:
    437                      intIdx = CTIMER_INTEN_CTMRA4C0INT_Pos;
    438                      break;
    439          
    440                  case CTIMER_INTEN_CTMRB4C0INT_Msk:
    441                      intIdx = CTIMER_INTEN_CTMRB4C0INT_Pos;
    442                      break;
    443          
    444                  case CTIMER_INTEN_CTMRA5C0INT_Msk:
    445                      intIdx = CTIMER_INTEN_CTMRA5C0INT_Pos;
    446                      break;
    447          
    448                  case CTIMER_INTEN_CTMRB5C0INT_Msk:
    449                      intIdx = CTIMER_INTEN_CTMRB5C0INT_Pos;
    450                      break;
    451          
    452                  case CTIMER_INTEN_CTMRA6C0INT_Msk:
    453                      intIdx = CTIMER_INTEN_CTMRA6C0INT_Pos;
    454                      break;
    455          
    456                  case CTIMER_INTEN_CTMRB6C0INT_Msk:
    457                      intIdx = CTIMER_INTEN_CTMRB6C0INT_Pos;
    458                      break;
    459          
    460                  case CTIMER_INTEN_CTMRA7C0INT_Msk:
    461                      intIdx = CTIMER_INTEN_CTMRA7C0INT_Pos;
    462                      break;
    463          
    464                  case CTIMER_INTEN_CTMRB7C0INT_Msk:
    465                      intIdx = CTIMER_INTEN_CTMRB7C0INT_Pos;
    466                      break;
    467          
    468                  // Counter/Timer A0 interrupt based on COMPR1.
    469                  case CTIMER_INTEN_CTMRA0C1INT_Msk:
    470                      intIdx = CTIMER_INTEN_CTMRA0C1INT_Pos;
    471                      break;
    472          
    473                  case CTIMER_INTEN_CTMRB0C1INT_Msk:
    474                      intIdx = CTIMER_INTEN_CTMRB0C1INT_Pos;
    475                      break;
    476          
    477                  case CTIMER_INTEN_CTMRA1C1INT_Msk:
    478                      intIdx = CTIMER_INTEN_CTMRA1C1INT_Pos;
    479                      break;
    480          
    481                  case CTIMER_INTEN_CTMRB1C1INT_Msk:
    482                      intIdx = CTIMER_INTEN_CTMRB1C1INT_Pos;
    483                      break;
    484          
    485                  case CTIMER_INTEN_CTMRA2C1INT_Msk:
    486                      intIdx = CTIMER_INTEN_CTMRA2C1INT_Pos;
    487                      break;
    488          
    489                  case CTIMER_INTEN_CTMRB2C1INT_Msk:
    490                      intIdx = CTIMER_INTEN_CTMRB2C1INT_Pos;
    491                      break;
    492          
    493                  case CTIMER_INTEN_CTMRA3C1INT_Msk:
    494                      intIdx = CTIMER_INTEN_CTMRA3C1INT_Pos;
    495                      break;
    496          
    497                  case CTIMER_INTEN_CTMRB3C1INT_Msk:
    498                      intIdx = CTIMER_INTEN_CTMRB3C1INT_Pos;
    499                      break;
    500          
    501                  case CTIMER_INTEN_CTMRA4C1INT_Msk:
    502                      intIdx = CTIMER_INTEN_CTMRA4C1INT_Pos;
    503                      break;
    504          
    505                  case CTIMER_INTEN_CTMRB4C1INT_Msk:
    506                      intIdx = CTIMER_INTEN_CTMRB4C1INT_Pos;
    507                      break;
    508                  case CTIMER_INTEN_CTMRA5C1INT_Msk:
    509                      intIdx = CTIMER_INTEN_CTMRA5C1INT_Pos;
    510                      break;
    511          
    512                  case CTIMER_INTEN_CTMRB5C1INT_Msk:
    513                      intIdx = CTIMER_INTEN_CTMRB5C1INT_Pos;
    514                      break;
    515                  case CTIMER_INTEN_CTMRA6C1INT_Msk:
    516                      intIdx = CTIMER_INTEN_CTMRA6C1INT_Pos;
    517                      break;
    518          
    519                  case CTIMER_INTEN_CTMRB6C1INT_Msk:
    520                      intIdx = CTIMER_INTEN_CTMRB6C1INT_Pos;
    521                      break;
    522                  case CTIMER_INTEN_CTMRA7C1INT_Msk:
    523                      intIdx = CTIMER_INTEN_CTMRA7C1INT_Pos;
    524                      break;
    525          
    526                  case CTIMER_INTEN_CTMRB7C1INT_Msk:
    527                      intIdx = CTIMER_INTEN_CTMRB7C1INT_Pos;
    528                      break;
    529          
    530                  default:
    531                      am_hal_debug_assert_msg(false, "CTimer interrupt number out of range.");
    532              }
    533          
    534              g_am_hal_ctimer_ppfnHandlers[intIdx] = pfnHandler;
    535          
    536          } // am_hal_ctimer_int_register()
    537          
    538          //*****************************************************************************
    539          //
    540          //! @brief Set up the counter/timer.
    541          //!
    542          //! @param ui32ConfigVal is the value to set the global enable register.
    543          //!
    544          //! This function sets the global enable register inside a critical section.
    545          //!
    546          //! @return None.
    547          //
    548          //*****************************************************************************
    549          void am_hal_ctimer_globen(uint32_t ui32ConfigVal)
    550          {
    551              uint32_t *pui32ConfigReg;
    552          
    553              //
    554              // Find the correct register to write.
    555              //
    556              pui32ConfigReg = (uint32_t *)(&CTIMERn(0)->GLOBEN);
    557          
    558              //
    559              // Begin critical section while config registers are read and modified.
    560              //
    561              AM_CRITICAL_BEGIN
    562          
    563              //
    564              // Write our configuration value.
    565              //
    566              AM_REGVAL(pui32ConfigReg) = ui32ConfigVal;
    567          
    568              //
    569              // Done with critical section.
    570              //
    571              AM_CRITICAL_END
    572          
    573          } // am_hal_ctimer_globen()
    574          
    575          //*****************************************************************************
    576          //
    577          //! @brief Set up the counter/timer.
    578          //!
    579          //! @param ui32TimerNumber is the number of the Timer that should be
    580          //! configured.
    581          //!
    582          //! @param psConfig is a pointer to a structure that holds important settings
    583          //! for the timer.
    584          //!
    585          //! This function should be used to perform the initial set-up of the
    586          //! counter-timer.
    587          //!
    588          //! @note This function is deprecated and will eventually be replaced by
    589          //! am_hal_ctimer_config_single(), which performs the same configuration
    590          //! without requiring a structure.
    591          //! Please use am_hal_ctimer_config_single().
    592          //!
    593          //! @return None.
    594          //
    595          //*****************************************************************************
    596          void
    597          am_hal_ctimer_config(uint32_t ui32TimerNumber,
    598                               am_hal_ctimer_config_t *psConfig)
    599          {
    600              uint32_t ui32ConfigVal;
    601              uint32_t ui32Seg, ui32ClkSrc;
    602          
    603              //
    604              // Start preparing the configuration word for this timer. The configuration
    605              // values for Timer A and Timer B provided in the config structure should
    606              // match the register definitions already, so we will mostly just need to
    607              // OR them together.
    608              //
    609              ui32ConfigVal = ( (psConfig->ui32TimerAConfig)  |
    610                                (psConfig->ui32TimerBConfig << 16) );
    611          
    612              //
    613              // OR in the Link bit if the timers need to be linked.
    614              //
    615              ui32ConfigVal |= psConfig->ui32Link ? AM_HAL_CTIMER_LINK : 0;
    616          
    617              //
    618              // Begin critical section while config registers are read and modified.
    619              //
    620              AM_CRITICAL_BEGIN
    621          
    622              //
    623              // Find the correct register to write.
    624              //
    625              uint32_t *pui32ConfigReg = (uint32_t *)(&CTIMERn(0)->CTRL0 +
    626                                                     (ui32TimerNumber * TIMER_OFFSET));
    627          
    628              //
    629              // Write our configuration value.
    630              //
    631              AM_REGVAL(pui32ConfigReg) = ui32ConfigVal;
    632          
    633              //
    634              // Done with critical section.
    635              //
    636              AM_CRITICAL_END
    637          
    638              //
    639              // Save the clock source for this timer.
    640              //
    641              if ( ( psConfig->ui32TimerAConfig != 0 )  ||  psConfig->ui32Link )
    642              {
    643                  ui32Seg = 0;
    644                  ui32ClkSrc = _FLD2VAL(CTIMER_CTRL0_TMRA0CLK, psConfig->ui32TimerAConfig);
    645              }
    646              else if ( psConfig->ui32TimerBConfig != 0)
    647              {
    648                  ui32Seg = 1;
    649                  ui32ClkSrc = _FLD2VAL(CTIMER_CTRL0_TMRA0CLK, psConfig->ui32TimerBConfig);
    650              }
    651              else
    652              {
    653                  return;
    654              }
    655          
    656              //
    657              // Save the clock source for this timer/segment.
    658              //
    659              g_ui8ClkSrc[ui32TimerNumber][ui32Seg] = ui32ClkSrc;
    660          
    661          } // am_hal_ctimer_config()
    662          
    663          //*****************************************************************************
    664          //
    665          //! @brief Set up the counter/timer.
    666          //!
    667          //! @param ui32TimerNumber is the number of the Timer that should be
    668          //! configured.
    669          //!
    670          //! @param ui32TimerSegment specifies which segment of the timer should be
    671          //! enabled.
    672          //!
    673          //! @param ui32ConfigVal specifies the configuration options for the selected
    674          //! timer.
    675          //!
    676          //! This function should be used to perform the initial set-up of the
    677          //! counter-timer. It can be used to configure either a 16-bit timer (A or B) or a
    678          //! 32-bit timer using the BOTH option.
    679          //!
    680          //! Valid values for ui32TimerSegment are:
    681          //!
    682          //!     AM_HAL_CTIMER_TIMERA
    683          //!     AM_HAL_CTIMER_TIMERB
    684          //!     AM_HAL_CTIMER_BOTH
    685          //!
    686          //! The timer's clock source, mode, interrupt, and external pin behavior are
    687          //! all controlled through the \e ui32Configval parameter. The valid options
    688          //! for ui32ConfigVal include any ORed together combination of the following:
    689          //!
    690          //! Clock configuration macros:
    691          //!
    692          //!     AM_HAL_CTIMER_HFRC_24MHZ
    693          //!     AM_HAL_CTIMER_LFRC_512HZ
    694          //!     ... etc. (See am_hal_ctimer.h for the full set of options.)
    695          //!
    696          //! Mode selection macros:
    697          //!
    698          //!     AM_HAL_CTIMER_FN_ONCE
    699          //!     AM_HAL_CTIMER_FN_REPEAT
    700          //!     AM_HAL_CTIMER_FN_PWM_ONCE
    701          //!     AM_HAL_CTIMER_FN_PWM_REPEAT
    702          //!     AM_HAL_CTIMER_FN_CONTINUOUS
    703          //!
    704          //! Interrupt control:
    705          //!
    706          //!     AM_HAL_CTIMER_INT_ENABLE
    707          //!
    708          //! Pin control:
    709          //!
    710          //!     AM_HAL_CTIMER_PIN_ENABLE
    711          //!     AM_HAL_CTIMER_PIN_INVERT
    712          //!
    713          //! ADC trigger (Timer 3 only):
    714          //!
    715          //!     AM_HAL_CTIMER_ADC_TRIG
    716          //!
    717          //! @return None.
    718          //
    719          //*****************************************************************************
    720          void
    721          am_hal_ctimer_config_single(uint32_t ui32TimerNumber,
    722                                      uint32_t ui32TimerSegment,
    723                                      uint32_t ui32ConfigVal)
    724          {
    725              volatile uint32_t *pui32ConfigReg;
    726              uint32_t ui32Seg, ui32ClkSrc;
    727          
    728              //
    729              // Find the correct register to write based on the timer number.
    730              //
    731              pui32ConfigReg = (uint32_t *)(&CTIMERn(0)->CTRL0 +
    732                                            (ui32TimerNumber * TIMER_OFFSET));
    733          
    734              //
    735              // Begin critical section while config registers are read and modified.
    736              //
    737              AM_CRITICAL_BEGIN
    738              uint32_t ui32WriteVal;
    739          
    740              //
    741              // Save the value that's already in the register.
    742              //
    743              ui32WriteVal = AM_REGVAL(pui32ConfigReg);
    744          
    745              //
    746              // If we're working with TIMERB, we need to shift our configuration value
    747              // up by 16 bits.
    748              //
    749          
    750              if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
    751              {
    752                  ui32ConfigVal = ((ui32ConfigVal & 0xFFFF) << 16);
    753              }
    754          
    755              //
    756              // Replace part of the saved register value with the configuration value
    757              // from the caller.
    758              //
    759              ui32WriteVal = (ui32WriteVal & ~(ui32TimerSegment)) | ui32ConfigVal;
    760          
    761              //
    762              // If we're configuring both timers, we need to set the "link" bit.
    763              //
    764              if ( ui32TimerSegment == AM_HAL_CTIMER_BOTH )
    765              {
    766                  ui32WriteVal |= AM_HAL_CTIMER_LINK;
    767              }
    768          
    769              //
    770              // Write our completed configuration value.
    771              //
    772              AM_REGVAL(pui32ConfigReg) = ui32WriteVal;
    773          
    774              //
    775              // Done with critical section.
    776              //
    777              AM_CRITICAL_END
    778          
    779              //
    780              // Save the clock source for this timer.
    781              //
    782          
    783              switch ( ui32TimerSegment )
    784              {
    785                  case AM_HAL_CTIMER_TIMERA:
    786                  case AM_HAL_CTIMER_BOTH:
    787                      ui32Seg = 0;
    788                      break;
    789                  case AM_HAL_CTIMER_TIMERB:
    790                      ui32Seg = 1;
    791                      break;
    792                  default:
    793                      return;
    794              }
    795          
    796              ui32ClkSrc = _FLD2VAL(CTIMER_CTRL0_TMRA0CLK, ui32ConfigVal);
    797          
    798              //
    799              // Save the clock source for this timer/segment.
    800              //
    801              g_ui8ClkSrc[ui32TimerNumber][ui32Seg] = (uint8_t)ui32ClkSrc;
    802          
    803          } // am_hal_ctimer_config_single()
    804          
    805          //*****************************************************************************
    806          //
    807          //! @brief Set up the counter/timer trigger.
    808          //!
    809          //! @param ui32TimerNumber is the number of the Timer that should be
    810          //! configured.
    811          //!
    812          //! @param ui32TimerSegment specifies which segment of the timer should be
    813          //! enabled.
    814          //!
    815          //! @param ui32ConfigVal specifies the configuration options for the selected
    816          //! timer trigger AUXn register.
    817          //!
    818          //! This function should be used to perform the configuration of the trigger
    819          //! for the counter-timer (A or B).
    820          //!
    821          //! Valid values for ui32TimerSegment are:
    822          //!
    823          //!     AM_HAL_CTIMER_TIMERA
    824          //!     AM_HAL_CTIMER_TIMERB
    825          //!
    826          //!
    827          //! @return None.
    828          //
    829          //*****************************************************************************
    830          void
    831          am_hal_ctimer_config_trigger(uint32_t ui32TimerNumber,
    832                                       uint32_t ui32TimerSegment,
    833                                       uint32_t ui32ConfigVal)
    834          {
    835              volatile uint32_t *pui32ConfigReg;
    836          
    837              //
    838              // Find the correct register to write based on the timer number.
    839              //
    840              pui32ConfigReg = (uint32_t *)(&CTIMERn(0)->AUX0 +
    841                                           (ui32TimerNumber * TIMER_OFFSET));
    842          
    843              //
    844              // Begin critical section while config registers are read and modified.
    845              //
    846              AM_CRITICAL_BEGIN
    847              uint32_t ui32WriteVal;
    848          
    849              //
    850              // Save the value that's already in the register.
    851              //
    852              ui32WriteVal = AM_REGVAL(pui32ConfigReg);
    853          
    854              //
    855              // If we're working with TIMERB, we need to shift our configuration value
    856              // up by 16 bits.
    857              //
    858          
    859              if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
    860              {
    861                  ui32ConfigVal = ((ui32ConfigVal & 0xFFFF) << 16);
    862              }
    863          
    864              //
    865              // Replace part of the saved register value with the configuration value
    866              // from the caller.
    867              //
    868              ui32WriteVal = (ui32WriteVal & ~(ui32TimerSegment)) | ui32ConfigVal;
    869          
    870              //
    871              // Write our completed configuration value.
    872              //
    873              AM_REGVAL(pui32ConfigReg) = ui32WriteVal;
    874          
    875              //
    876              // Done with critical section.
    877              //
    878              AM_CRITICAL_END
    879          
    880          } // am_hal_ctimer_config_trigger()
    881          
    882          //*****************************************************************************
    883          //
    884          //! @brief Start a timer
    885          //!
    886          //! @param ui32TimerNumber is the number of the timer to enable
    887          //!
    888          //! @param ui32TimerSegment specifies which segment of the timer should be
    889          //! enabled.  Valid values for ui32TimerSegment are:
    890          //!     AM_HAL_CTIMER_TIMERA
    891          //!     AM_HAL_CTIMER_TIMERB
    892          //!     AM_HAL_CTIMER_BOTH
    893          //!
    894          //! This function will enable a timer to begin incrementing. The \e
    895          //! ui32TimerNumber parameter selects the timer that should be enabled, for
    896          //! example, a 0 would target TIMER0. The \e ui32TimerSegment parameter allows
    897          //! the caller to individually select a segment within a timer to be enabled,
    898          //! such as TIMER0A, TIMER0B, or both.
    899          //!
    900          //! @return None.
    901          //
    902          //*****************************************************************************
    903          void
    904          am_hal_ctimer_start(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment)
    905          {
    906              uint32_t ui32Seg, ui32ClkSrc;
    907          
    908              //
    909              // Find the correct control register.
    910              //
    911              volatile uint32_t *pui32ConfigReg = (uint32_t *)(&CTIMERn(0)->CTRL0 +
    912                                                  (ui32TimerNumber * TIMER_OFFSET));
    913          
    914              //
    915              // Begin critical section while config registers are read and modified.
    916              //
    917              AM_CRITICAL_BEGIN
    918          
    919              //
    920              // Read the current value.
    921              //
    922              uint32_t ui32ConfigVal = *pui32ConfigReg;
    923          
    924              //
    925              // Clear out the "clear" bit.
    926              //
    927              ui32ConfigVal &= ~(ui32TimerSegment & (CTIMER_CTRL0_TMRA0CLR_Msk |
    928                                                     CTIMER_CTRL0_TMRB0CLR_Msk));
    929          
    930              //
    931              // Set the "enable bit"
    932              //
    933              ui32ConfigVal |= (ui32TimerSegment & (CTIMER_CTRL0_TMRA0EN_Msk |
    934                                                    CTIMER_CTRL0_TMRB0EN_Msk));
    935          
    936              //
    937              // While we already have the CTRL reg, get and save the CLKSRC.
    938              //
    939              if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
    940              {
    941                  ui32Seg = 1;
    942                  ui32ClkSrc = _FLD2VAL(CTIMER_CTRL0_TMRB0CLK, ui32ConfigVal);
    943              }
    944              else
    945              {
    946                  ui32Seg = 0;
    947                  ui32ClkSrc = _FLD2VAL(CTIMER_CTRL0_TMRA0CLK, ui32ConfigVal);
    948              }
    949          
    950              //
    951              // Save the clock source for this timer/segment.
    952              //
    953              g_ui8ClkSrc[ui32TimerNumber][ui32Seg] = ui32ClkSrc;
    954          
    955              //
    956              // Write the configuration to start the timer.
    957              //
    958              AM_REGVAL(pui32ConfigReg) = ui32ConfigVal;
    959          
    960              //
    961              // Done with critical section.
    962              //
    963              AM_CRITICAL_END
    964          
    965          } // am_hal_ctimer_start()
    966          
    967          //*****************************************************************************
    968          //
    969          //! @brief Stop a timer
    970          //!
    971          //! @param ui32TimerNumber is the number of the timer to disable.
    972          //!
    973          //! @param ui32TimerSegment specifies which segment of the timer should be
    974          //! disabled.
    975          //!
    976          //! This function will stop the selected timer from incrementing. The \e
    977          //! ui32TimerNumber parameter selects the timer that should be disabled, for
    978          //! example, a 0 would target TIMER0. The \e ui32TimerSegment parameter allows
    979          //! the caller to individually select a segment within a timer to be disabled,
    980          //! such as TIMER0A, TIMER0B, or both.
    981          //!
    982          //! This function will stop a counter/timer from counting, but does not return
    983          //! the count value to 'zero'. If you would like to reset the counter back to
    984          //! zero, try the am_hal_ctimer_clear() function instead.
    985          //!
    986          //! Valid values for ui32TimerSegment are:
    987          //!
    988          //!     AM_HAL_CTIMER_TIMERA
    989          //!     AM_HAL_CTIMER_TIMERB
    990          //!     AM_HAL_CTIMER_BOTH
    991          //!
    992          //! @return None.
    993          //
    994          //*****************************************************************************
    995          void
    996          am_hal_ctimer_stop(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment)
    997          {
    998              volatile uint32_t *pui32ConfigReg;
    999          
   1000              //
   1001              // Find the correct control register.
   1002              //
   1003              pui32ConfigReg = (uint32_t *)(&CTIMERn(0)->CTRL0 +
   1004                                           (ui32TimerNumber * TIMER_OFFSET));
   1005          
   1006              //
   1007              // Begin critical section.
   1008              //
   1009              AM_CRITICAL_BEGIN
   1010          
   1011              //
   1012              // Clear the "enable" bit
   1013              //
   1014              AM_REGVAL(pui32ConfigReg) &= ~(ui32TimerSegment &
   1015                                             (CTIMER_CTRL0_TMRA0EN_Msk |
   1016                                              CTIMER_CTRL0_TMRB0EN_Msk));
   1017          
   1018              //
   1019              // Done with critical section.
   1020              //
   1021              AM_CRITICAL_END
   1022          
   1023          } // am_hal_ctimer_stop()
   1024          
   1025          //*****************************************************************************
   1026          //
   1027          //! @brief Stops a timer and resets its value back to zero.
   1028          //!
   1029          //! @param ui32TimerNumber is the number of the timer to clear.
   1030          //!
   1031          //! @param ui32TimerSegment specifies which segment of the timer should be
   1032          //! cleared.
   1033          //!
   1034          //! This function will stop a free-running counter-timer, reset its value to
   1035          //! zero, and leave the timer disabled. When you would like to restart the
   1036          //! counter, you will need to call am_hal_ctimer_start().
   1037          //!
   1038          //! The \e ui32TimerSegment parameter allows the caller to individually select
   1039          //! a segment within, such as TIMER0A, TIMER0B, or both.
   1040          //!
   1041          //! Valid values for ui32TimerSegment are:
   1042          //!
   1043          //!     AM_HAL_CTIMER_TIMERA
   1044          //!     AM_HAL_CTIMER_TIMERB
   1045          //!     AM_HAL_CTIMER_BOTH
   1046          //!
   1047          //! @return None.
   1048          //
   1049          //*****************************************************************************
   1050          void
   1051          am_hal_ctimer_clear(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment)
   1052          {
   1053              volatile uint32_t *pui32ConfigReg;
   1054          
   1055              //
   1056              // Find the correct control register.
   1057              //
   1058              pui32ConfigReg = (uint32_t *)(&CTIMERn(0)->CTRL0 +
   1059                                           (ui32TimerNumber * TIMER_OFFSET));
   1060          
   1061              //
   1062              // Begin critical section.
   1063              //
   1064              AM_CRITICAL_BEGIN
   1065          
   1066              //
   1067              // Set the "clear" bit
   1068              //
   1069              AM_REGVAL(pui32ConfigReg) |= (ui32TimerSegment &
   1070                                            (CTIMER_CTRL0_TMRA0CLR_Msk |
   1071                                             CTIMER_CTRL0_TMRB0CLR_Msk));
   1072          
   1073              //
   1074              // Done with critical section.
   1075              //
   1076              AM_CRITICAL_END
   1077          
   1078          } // am_hal_ctimer_clear()
   1079          
   1080          //*****************************************************************************
   1081          //
   1082          //! @brief Returns the current free-running value of the selected timer.
   1083          //!
   1084          //! @param ui32TimerNumber is the number of the timer to read.
   1085          //! @param ui32TimerSegment specifies which segment of the timer should be
   1086          //! read.
   1087          //!
   1088          //! This function returns the current free-running value of the selected timer.
   1089          //!
   1090          //! @note When reading from a linked timer, be sure to use AM_HAL_CTIMER both
   1091          //! for the segment argument.
   1092          //!
   1093          //! Valid values for ui32TimerSegment are:
   1094          //!
   1095          //!     AM_HAL_CTIMER_TIMERA
   1096          //!     AM_HAL_CTIMER_TIMERB
   1097          //!     AM_HAL_CTIMER_BOTH
   1098          //!
   1099          //! @return Current timer value.
   1100          //
   1101          //*****************************************************************************
   1102          uint32_t
   1103          am_hal_ctimer_read(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment)
   1104          {
   1105              uint32_t ui32RetVal = 0;
   1106              uint32_t ui32ClkMsk, ui32Seg, ui32TmrAddr, ui32Ctrl;
   1107              uint8_t  ui8ClkSrc;
   1108              uint32_t ui32Values[3];
   1109          
   1110              //
   1111              // Determine the timer segment.
   1112              //
   1113              ui32Seg = ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB ) ? 1 : 0;
   1114          
   1115              //
   1116              // Get the address of the register for this timer.
   1117              //
   1118              ui32TmrAddr = g_ui32TMRAddrTbl[ui32TimerNumber];
   1119          
   1120              //
   1121              // Get the clock source for this timer.
   1122              //
   1123              ui8ClkSrc = g_ui8ClkSrc[ui32TimerNumber][ui32Seg];
   1124          
   1125              if ( ui8ClkSrc == 0xFF )
   1126              {
   1127                  //
   1128                  // If user did not configure using am_hal_ctimer_config_single() or
   1129                  // am_hal_ctimer_config(), read the register to get the clock source.
   1130                  // Note that this will incur bus latencies.
   1131                  //
   1132                  ui32Ctrl = AM_REGVAL(ui32TmrAddr + 0xC);
   1133                  if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
   1134                  {
   1135                      ui8ClkSrc = _FLD2VAL(CTIMER_CTRL0_TMRB0CLK, ui32Ctrl);
   1136                  }
   1137                  else
   1138                  {
   1139                      ui8ClkSrc = _FLD2VAL(CTIMER_CTRL0_TMRA0CLK, ui32Ctrl);
   1140                  }
   1141          
   1142                  //
   1143                  // And save the clock source to the lookup table.
   1144                  //
   1145                  g_ui8ClkSrc[ui32TimerNumber][ui32Seg] = ui8ClkSrc;
   1146              }
   1147          
   1148              //
   1149              // Based on the source clock, mask off bits not needed for the comparison.
   1150              //
   1151              ui32ClkMsk = g_ui8TmrClkSrcMask[ui8ClkSrc & _FLD2VAL(CTIMER_CTRL0_TMRA0CLK, 0xFFFFFFFF)];
   1152          
   1153              if ( ui32ClkMsk != 0 )
   1154              {
   1155                  if ( am_hal_burst_mode_status() == AM_HAL_BURST_MODE )
   1156                  {
   1157                      //
   1158                      // In burst mode, extend the mask by 1 bit.
   1159                      //
   1160                      ui32ClkMsk <<= 1;
   1161                      ui32ClkMsk |= 0x1;
   1162                  }
   1163          
   1164                  //
   1165                  // Invert the mask so that the unneeded bits can be masked off.
   1166                  //
   1167                  ui32ClkMsk = ~ui32ClkMsk;
   1168          
   1169                  //
   1170                  // Read the register into ui32Values[].
   1171                  //
   1172                  am_hal_triple_read(ui32TmrAddr, ui32Values);
   1173          
   1174                  //
   1175                  // Now determine which of the three values is the correct value.
   1176                  // If the first 2 match, then the values are both correct and we're done.
   1177                  // Otherwise, the third value is taken to be the correct value.
   1178                  //
   1179                  if ( (ui32Values[0] & ui32ClkMsk)  == (ui32Values[1] & ui32ClkMsk) )
   1180                  {
   1181                      //
   1182                      // If the first two values match, then neither one was a bad read.
   1183                      // We'll take this as the current time.
   1184                      //
   1185                      ui32RetVal = ui32Values[1];
   1186                  }
   1187                  else
   1188                  {
   1189                      ui32RetVal = ui32Values[2];
   1190                  }
   1191              }
   1192              else
   1193              {
   1194                  //
   1195                  // No need for the workaround.  Just read and return the register.
   1196                  //
   1197                  ui32RetVal = AM_REGVAL(ui32TmrAddr);
   1198              }
   1199          
   1200              //
   1201              // Get the correct return value
   1202              //
   1203              ui32RetVal &= ui32TimerSegment;
   1204          
   1205              if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
   1206              {
   1207                  ui32RetVal >>= 16;
   1208              }
   1209          
   1210              return ui32RetVal;
   1211          
   1212          } // am_hal_ctimer_read()
   1213          
   1214          //*****************************************************************************
   1215          //
   1216          //! @brief Configure timer pin output.
   1217          //!
   1218          //! @param ui32TimerNumber is the number of the timer to configure.
   1219          //!
   1220          //! @param ui32TimerSegment specifies which segment of the timer to use.
   1221          //!
   1222          //! @param ui32TimerOutputConfig Output Configuration options.
   1223          //!
   1224          //! This function will configure the output pin for the selected timer.
   1225          //!
   1226          //! ui32TimerNumber
   1227          //!     The timer number, 0-7.
   1228          //! ui32TimerSegment
   1229          //!     AM_HAL_CTIMER_TIMERA
   1230          //!     AM_HAL_CTIMER_TIMERB
   1231          //!     AM_HAL_CTIMER_BOTH
   1232          //! ui32PadNum
   1233          //!     Pad number to be used for the output signal.
   1234          //! eOutputType
   1235          //!     AM_HAL_CTIMER_OUTPUT_NORMAL
   1236          //!     AM_HAL_CTIMER_OUTPUT_SECONDARY
   1237          //!     AM_HAL_CTIMER_OUTPUT_FORCE0
   1238          //!     AM_HAL_CTIMER_OUTPUT_FORCE1
   1239          //! eDriveStrength
   1240          //!     AM_HAL_GPIO_PIN_DRIVESTRENGTH_2MA   = 0x0,
   1241          //!     AM_HAL_GPIO_PIN_DRIVESTRENGTH_4MA   = 0x1,
   1242          //!     AM_HAL_GPIO_PIN_DRIVESTRENGTH_8MA   = 0x2,
   1243          //!     AM_HAL_GPIO_PIN_DRIVESTRENGTH_12MA  = 0x3
   1244          //!
   1245          //! @return None.
   1246          //
   1247          //*****************************************************************************
   1248          uint32_t
   1249          am_hal_ctimer_output_config(uint32_t ui32TimerNumber,
   1250                                      uint32_t ui32TimerSegment,
   1251                                      uint32_t ui32PadNum,
   1252                                      uint32_t eOutputType,
   1253                                      uint32_t eDriveStrength)
   1254          {
   1255              uint32_t ux, ui32Ctx, ui32CtxPadNum;
   1256              uint32_t ui32CtxOutcfgFnc, ui32CtxOutcfgMsk, ui32CfgShf;
   1257          
   1258              am_hal_gpio_pincfg_t sPinCfg = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
   1259          
   1260              if ( (ui32PadNum > 49)  ||  (ui32TimerNumber > 7)   ||
   1261                   (eOutputType > AM_HAL_CTIMER_OUTPUT_FORCE1)    ||
   1262                   ( (ui32TimerSegment != AM_HAL_CTIMER_TIMERA) &&
   1263                     (ui32TimerSegment != AM_HAL_CTIMER_TIMERB) &&
   1264                     (ui32TimerSegment != AM_HAL_CTIMER_BOTH) ) )
   1265              {
   1266                  return AM_HAL_STATUS_INVALID_ARG;
   1267              }
   1268          
   1269              //
   1270              // Lookup the CTx number based on the given pad number.
   1271              //
   1272              for ( ux = 0; ux < 32; ux++ )
   1273              {
   1274                  ui32CtxPadNum = CTXPADNUM(ux);
   1275                  if ( ui32CtxPadNum == ui32PadNum )
   1276                  {
   1277                      ui32Ctx = ux;
   1278                      break;
   1279                  }
   1280                  ui32CtxPadNum = 0xFF;
   1281              }
   1282          
   1283              if ( ui32CtxPadNum >= AM_HAL_GPIO_MAX_PADS )
   1284              {
   1285                  // No valid pad found.
   1286                  return AM_HAL_STATUS_OUT_OF_RANGE;
   1287              }
   1288          
   1289              if ( ( ui32TimerNumber >= 6 )                               &&
   1290                   ( ui32TimerSegment == AM_HAL_CTIMER_TIMERA )           &&
   1291                   (eOutputType == AM_HAL_CTIMER_OUTPUT_SECONDARY) )
   1292              {
   1293                  //
   1294                  // A6OUT2 is function 6 for every CTx.
   1295                  // A7OUT2 is function 7 for every CTx.
   1296                  // Set the function to either 6 or 7.
   1297                  //
   1298                  ui32CtxOutcfgFnc = ui32TimerNumber;
   1299              }
   1300              else if ( eOutputType >= AM_HAL_CTIMER_OUTPUT_FORCE0 )
   1301              {
   1302                  // Set the function to 0 or 1.
   1303                  ui32CtxOutcfgFnc = eOutputType - AM_HAL_CTIMER_OUTPUT_FORCE0;
   1304              }
   1305              else
   1306              {
   1307                  //
   1308                  // Now, scan outcfg_tbl[] to determine how to set the pin.
   1309                  //
   1310                  for ( ux = 0; ux < 4; ux++ )
   1311                  {
   1312                      if ( (OUTCTIMN(ui32Ctx, ux) == ui32TimerNumber) )
   1313                      {
   1314                          bool bTimerB = OUTCTIMB(ui32Ctx, ux);
   1315                          bool bO2 = OUTCO2(ui32Ctx, ux) ? true : false;
   1316                          bool bOut2 = (eOutputType == AM_HAL_CTIMER_OUTPUT_SECONDARY);
   1317                          if ( ( ui32TimerSegment == AM_HAL_CTIMER_TIMERA )   &&
   1318                               (!bTimerB)                                     &&
   1319                               (bO2 == bOut2) )
   1320                          {
   1321                              break;
   1322                          }
   1323          
   1324                          if ( ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )   &&
   1325                               (bTimerB)                                      &&
   1326                               (bO2 == bOut2) )
   1327                          {
   1328                              break;
   1329                          }
   1330                      }
   1331                  }
   1332          
   1333                  if ( ux >= 4 )
   1334                  {
   1335                      return AM_HAL_STATUS_INVALID_OPERATION;
   1336                  }
   1337          
   1338                  ui32CtxOutcfgFnc = ux + 2;
   1339              }
   1340          
   1341              //
   1342              // Looks like everything is valid.  Configure the pin.
   1343              // Do the actual configuring inside a critical section.
   1344              //
   1345              ux = ui32Ctx % 10;
   1346              ui32CfgShf = ux * 3;
   1347              if ( ux > 4 )
   1348              {
   1349                  ui32CfgShf += 1;
   1350              }
   1351              ui32CtxOutcfgMsk   = 0x7 << ui32CfgShf;
   1352              ui32CtxOutcfgFnc <<= ui32CfgShf;
   1353          
   1354              //
   1355              // Begin critical section.
   1356              //
   1357              AM_CRITICAL_BEGIN
   1358          
   1359              //
   1360              // Note: It turns out that the offsets of the 4 OUTCFG registers are not
   1361              // evenly spaced.  Therefore we purposely use this 'if' chain to program
   1362              // them explicitly (as opposed to doing modulo math to compute an addr).
   1363              //
   1364              if ( ui32Ctx < 10 )
   1365              {
   1366                  CTIMER->OUTCFG0 &= ~ui32CtxOutcfgMsk;
   1367                  CTIMER->OUTCFG0 |=  ui32CtxOutcfgFnc;
   1368              }
   1369              else if ( ui32Ctx < 20 )
   1370              {
   1371                  CTIMER->OUTCFG1 &= ~ui32CtxOutcfgMsk;
   1372                  CTIMER->OUTCFG1 |=  ui32CtxOutcfgFnc;
   1373              }
   1374              else if ( ui32Ctx < 30 )
   1375              {
   1376                  CTIMER->OUTCFG2 &= ~ui32CtxOutcfgMsk;
   1377                  CTIMER->OUTCFG2 |=  ui32CtxOutcfgFnc;
   1378              }
   1379              else
   1380              {
   1381                  CTIMER->OUTCFG3 &= ~ui32CtxOutcfgMsk;
   1382                  CTIMER->OUTCFG3 |=  ui32CtxOutcfgFnc;
   1383              }
   1384          
   1385              GPIO->CTENCFG &= ~(1 << ui32Ctx);
   1386          
   1387              //
   1388              // Done with critical section.
   1389              //
   1390              AM_CRITICAL_END
   1391          
   1392              //
   1393              // Configure the GPIO for the given pad.
   1394              //
   1395              sPinCfg.uFuncSel = CTXPADFNC(ui32Ctx);
   1396              sPinCfg.eDriveStrength = eDriveStrength;
   1397              am_hal_gpio_pinconfig(ui32CtxPadNum, sPinCfg);
   1398          
   1399              return AM_HAL_STATUS_SUCCESS;
   1400          
   1401          } // am_hal_ctimer_output_config()
   1402          
   1403          //*****************************************************************************
   1404          //
   1405          //! @brief Configure timer inputs.
   1406          //!
   1407          //! @param ui32TimerNumber is the number of the timer to configure.
   1408          //!
   1409          //! @param ui32TimerSegment specifies which segment of the timer to use.
   1410          //!
   1411          //! @param ui32TimerInputConfig Input Configuration options.
   1412          //!
   1413          //! This function will configure the input pin for the selected timer.
   1414          //!
   1415          //! Valid values for ui32TimerSegment are:
   1416          //!     AM_HAL_CTIMER_TIMERA
   1417          //!     AM_HAL_CTIMER_TIMERB
   1418          //!     AM_HAL_CTIMER_BOTH
   1419          //!
   1420          //! @return None.
   1421          //
   1422          //*****************************************************************************
   1423          void
   1424          am_hal_ctimer_input_config(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment,
   1425                                     uint32_t ui32TimerInputConfig)
   1426          {
   1427              //
   1428              // Begin critical section.
   1429              //
   1430              AM_CRITICAL_BEGIN
   1431          
   1432              //
   1433              // Done with critical section.
   1434              //
   1435              AM_CRITICAL_END
   1436          
   1437          } // am_hal_ctimer_input_config()
   1438          
   1439          //*****************************************************************************
   1440          //
   1441          //! @brief Set a compare register.
   1442          //!
   1443          //! @param ui32TimerNumber is the number of the timer to configure.
   1444          //!
   1445          //! @param ui32TimerSegment specifies which segment of the timer to use.
   1446          //! Valid values for ui32TimerSegment are:
   1447          //!
   1448          //!     AM_HAL_CTIMER_TIMERA
   1449          //!     AM_HAL_CTIMER_TIMERB
   1450          //!     AM_HAL_CTIMER_BOTH
   1451          //!
   1452          //! @param ui32CompareReg specifies which compare register should be set
   1453          //! (either 0 or 1)
   1454          //!
   1455          //! @param ui32Value is the value that should be written to the compare
   1456          //! register.
   1457          //!
   1458          //! This function allows the caller to set the values in the compare registers
   1459          //! for a timer. These registers control the period and duty cycle of the
   1460          //! timers and their associated output pins. Please see the datasheet for
   1461          //! further information on the operation of the compare registers. The \e
   1462          //! ui32TimerSegment parameter allows the caller to individually select a
   1463          //! segment within, such as TIMER0A, TIMER0B, or both.
   1464          //!
   1465          //! @note For simple manipulations of period or duty cycle for timers and PWMs,
   1466          //! you may find it easier to use the am_hal_ctimer_period_set() function.
   1467          //!
   1468          //! @return None.
   1469          //
   1470          //*****************************************************************************
   1471          void
   1472          am_hal_ctimer_compare_set(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment,
   1473                                    uint32_t ui32CompareReg, uint32_t ui32Value)
   1474          {
   1475              volatile uint32_t *pui32CmprRegA, *pui32CmprRegB;
   1476              uint32_t ui32CmprRegA, ui32CmprRegB, ui32ValB;
   1477          
   1478              //
   1479              // Find the correct compare register to write.
   1480              // Assume A or BOTH.  We'll change later if B.
   1481              //
   1482              pui32CmprRegA = (uint32_t *)(&CTIMERn(0)->CMPRA0 +
   1483                                          (ui32TimerNumber * TIMER_OFFSET));
   1484              pui32CmprRegB = (uint32_t *)(&CTIMERn(0)->CMPRB0 +
   1485                                          (ui32TimerNumber * TIMER_OFFSET));
   1486              ui32ValB = ( ui32TimerSegment == AM_HAL_CTIMER_BOTH ) ?
   1487                         ui32Value >> 16 : ui32Value & 0xFFFF;
   1488          
   1489              //
   1490              // Write the compare register with the selected value.
   1491              // Begin critical section while CMPR registers are modified.
   1492              //
   1493              AM_CRITICAL_BEGIN
   1494          
   1495              ui32CmprRegA = *pui32CmprRegA;
   1496              ui32CmprRegB = *pui32CmprRegB;
   1497          
   1498              if ( ui32CompareReg == 1 )
   1499              {
   1500                  //
   1501                  // CMPR reg 1
   1502                  // Get the lower 16b (but may not be used if TIMERB).
   1503                  //
   1504                  ui32CmprRegA = ( (ui32CmprRegA & CTIMER_CMPRA0_CMPR0A0_Msk) |
   1505                                    _VAL2FLD(CTIMER_CMPRA0_CMPR1A0, ui32Value & 0xFFFF) );
   1506          
   1507                  //
   1508                  // Get the upper 16b (but may not be used if TIMERA)
   1509                  //
   1510                  ui32CmprRegB = ( (ui32CmprRegB & CTIMER_CMPRA0_CMPR0A0_Msk) |
   1511                                    _VAL2FLD(CTIMER_CMPRA0_CMPR1A0, ui32ValB) );
   1512              }
   1513              else
   1514              {
   1515                  //
   1516                  // CMPR reg 0
   1517                  // Get the lower 16b (but may not be used if TIMERB)
   1518                  //
   1519                  ui32CmprRegA = ( (ui32CmprRegA & CTIMER_CMPRA0_CMPR1A0_Msk) |
   1520                                   _VAL2FLD(CTIMER_CMPRA0_CMPR0A0, ui32Value & 0xFFFF) );
   1521          
   1522                  //
   1523                  // Set the upper 16b (but may not be used if TIMERA)
   1524                  //
   1525                  ui32CmprRegB = ( (ui32CmprRegB & CTIMER_CMPRA0_CMPR1A0_Msk) |
   1526                                   _VAL2FLD(CTIMER_CMPRA0_CMPR0A0, ui32ValB) );
   1527              }
   1528          
   1529              if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
   1530              {
   1531                  *pui32CmprRegB = ui32CmprRegB;
   1532              }
   1533              else
   1534              {
   1535                  //
   1536                  // It's TIMERA or BOTH.
   1537                  //
   1538                  *pui32CmprRegA = ui32CmprRegA;
   1539          
   1540                  if ( ui32TimerSegment == AM_HAL_CTIMER_BOTH )
   1541                  {
   1542                      *pui32CmprRegB = ui32CmprRegB;
   1543                  }
   1544              }
   1545          
   1546              //
   1547              // Done with critical section.
   1548              //
   1549              AM_CRITICAL_END
   1550          
   1551          } // am_hal_ctimer_compare_set()
   1552          
   1553          //*****************************************************************************
   1554          //
   1555          //! @brief Set a compare register.
   1556          //!
   1557          //! @param ui32TimerNumber is the number of the timer to configure.
   1558          //!
   1559          //! @param ui32TimerSegment specifies which segment of the timer to use.
   1560          //! Valid values for ui32TimerSegment are:
   1561          //!
   1562          //!     AM_HAL_CTIMER_TIMERA
   1563          //!     AM_HAL_CTIMER_TIMERB
   1564          //!     AM_HAL_CTIMER_BOTH
   1565          //!
   1566          //! @param ui32CompareReg specifies which compare register should be set
   1567          //! (either 0 or 1)
   1568          //!
   1569          //! @param ui32Value is the value that should be written to the compare
   1570          //! register.
   1571          //!
   1572          //! This function allows the caller to set the values in the compare registers
   1573          //! for a timer. These registers control the period and duty cycle of the
   1574          //! timers and their associated output pins. Please see the datasheet for
   1575          //! further information on the operation of the compare registers. The \e
   1576          //! ui32TimerSegment parameter allows the caller to individually select a
   1577          //! segment within, such as TIMER0A, TIMER0B, or both.
   1578          //!
   1579          //! @note For simple manipulations of period or duty cycle for timers and PWMs,
   1580          //! you may find it easier to use the am_hal_ctimer_period_set() function.
   1581          //!
   1582          //! @return None.
   1583          //
   1584          //*****************************************************************************
   1585          void
   1586          am_hal_ctimer_aux_compare_set(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment,
   1587                                        uint32_t ui32CompareReg, uint32_t ui32Value)
   1588          {
   1589              volatile uint32_t *pui32CmprRegA, *pui32CmprRegB;
   1590              uint32_t ui32CmprRegA, ui32CmprRegB, ui32ValB;
   1591          
   1592              //
   1593              // Find the correct compare register to write.
   1594              // Assume A or BOTH.  We'll change later if B.
   1595              //
   1596              pui32CmprRegA = (uint32_t *)(&CTIMERn(0)->CMPRAUXA0 +
   1597                                          (ui32TimerNumber * TIMER_OFFSET));
   1598              pui32CmprRegB = (uint32_t *)(&CTIMERn(0)->CMPRAUXB0 +
   1599                                          (ui32TimerNumber * TIMER_OFFSET));
   1600              ui32ValB = ( ui32TimerSegment == AM_HAL_CTIMER_BOTH ) ?
   1601                         ui32Value >> 16 : ui32Value & 0xFFFF;
   1602          
   1603              //
   1604              // Write the compare register with the selected value.
   1605              // Begin critical section while CMPR registers are modified.
   1606              //
   1607              AM_CRITICAL_BEGIN
   1608          
   1609              ui32CmprRegA = *pui32CmprRegA;
   1610              ui32CmprRegB = *pui32CmprRegB;
   1611          
   1612              if ( ui32CompareReg == 1 )
   1613              {
   1614                  //
   1615                  // CMPR reg 1
   1616                  // Get the lower 16b (but may not be used if TIMERB).
   1617                  //
   1618                  ui32CmprRegA = ( (ui32CmprRegA & CTIMER_CMPRAUXA0_CMPR2A0_Msk) |
   1619                                    _VAL2FLD(CTIMER_CMPRAUXA0_CMPR3A0, ui32Value & 0xFFFF) );
   1620          
   1621                  //
   1622                  // Get the upper 16b (but may not be used if TIMERA)
   1623                  //
   1624                  ui32CmprRegB = ( (ui32CmprRegB & CTIMER_CMPRAUXA0_CMPR2A0_Msk) |
   1625                                    _VAL2FLD(CTIMER_CMPRAUXA0_CMPR3A0, ui32ValB) );
   1626              }
   1627              else
   1628              {
   1629                  //
   1630                  // CMPR reg 0
   1631                  // Get the lower 16b (but may not be used if TIMERB)
   1632                  //
   1633                  ui32CmprRegA = ( (ui32CmprRegA & CTIMER_CMPRAUXA0_CMPR3A0_Msk) |
   1634                                   _VAL2FLD(CTIMER_CMPRAUXA0_CMPR2A0, ui32Value & 0xFFFF) );
   1635          
   1636                  //
   1637                  // Set the upper 16b (but may not be used if TIMERA)
   1638                  //
   1639                  ui32CmprRegB = ( (ui32CmprRegB & CTIMER_CMPRAUXA0_CMPR3A0_Msk) |
   1640                                   _VAL2FLD(CTIMER_CMPRAUXA0_CMPR2A0, ui32ValB) );
   1641              }
   1642          
   1643              if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
   1644              {
   1645                  *pui32CmprRegB = ui32CmprRegB;
   1646              }
   1647              else
   1648              {
   1649                  //
   1650                  // It's TIMERA or BOTH.
   1651                  //
   1652                  *pui32CmprRegA = ui32CmprRegA;
   1653          
   1654                  if ( ui32TimerSegment == AM_HAL_CTIMER_BOTH )
   1655                  {
   1656                      *pui32CmprRegB = ui32CmprRegB;
   1657                  }
   1658              }
   1659          
   1660              //
   1661              // Done with critical section.
   1662              //
   1663              AM_CRITICAL_END
   1664          
   1665          } // am_hal_ctimer_aux_compare_set()
   1666          
   1667          //*****************************************************************************
   1668          //
   1669          //! @brief Set the period and duty cycle of a timer.
   1670          //!
   1671          //! @param ui32TimerNumber is the number of the timer to configure.
   1672          //!
   1673          //! @param ui32TimerSegment specifies which segment of the timer to use.
   1674          //!
   1675          //! @param ui32Period specifies the desired period.  This parameter effectively
   1676          //! specifies the CTIMER CMPR field(s). The CMPR fields are handled in hardware
   1677          //! as (n+1) values, therefore ui32Period is actually specified as 1 less than
   1678          //! the desired period. Finally, as mentioned in the data sheet, the CMPR fields
   1679          //! cannot be 0 (a value of 1), so neither can ui32Period be 0.
   1680          //!
   1681          //! @param ui32OnTime set the number of clocks where the output signal is high.
   1682          //!
   1683          //! This function should be used for simple manipulations of the period and
   1684          //! duty cycle of a counter/timer. To set the period and/or duty cycle of a
   1685          //! linked timer pair, use AM_HAL_CTIMER_BOTH as the timer segment argument. If
   1686          //! you would like to set the period and/or duty cycle for both TIMERA and
   1687          //! TIMERB you will need to call this function twice: once for TIMERA, and once
   1688          //! for TIMERB.
   1689          //!
   1690          //! Valid values for ui32TimerSegment are:
   1691          //!
   1692          //!     AM_HAL_CTIMER_TIMERA
   1693          //!     AM_HAL_CTIMER_TIMERB
   1694          //!     AM_HAL_CTIMER_BOTH
   1695          //!
   1696          //! @note The ui32OnTime parameter will only work if the timer is currently
   1697          //! operating in one of the PWM modes.
   1698          //!
   1699          //! @return None.
   1700          //
   1701          //*****************************************************************************
   1702          void
   1703          am_hal_ctimer_period_set(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment,
   1704                                   uint32_t ui32Period, uint32_t ui32OnTime)
   1705          {
   1706              volatile uint32_t *pui32ControlReg;
   1707              volatile uint32_t *pui32CompareRegA;
   1708              volatile uint32_t *pui32CompareRegB;
   1709              uint32_t ui32Mode, ui32Comp0, ui32Comp1;
   1710          
   1711              //
   1712              // Find the correct control register to pull the function select field
   1713              // from.
   1714              //
   1715              pui32ControlReg = (uint32_t *)(&CTIMERn(0)->CTRL0 +
   1716                                            (ui32TimerNumber * TIMER_OFFSET));
   1717          
   1718              //
   1719              // Find the correct compare registers to write.
   1720              //
   1721              pui32CompareRegA = (uint32_t *)(&CTIMERn(0)->CMPRA0 +
   1722                                             (ui32TimerNumber * TIMER_OFFSET));
   1723          
   1724              pui32CompareRegB = (uint32_t *)(&CTIMERn(0)->CMPRB0 +
   1725                                             (ui32TimerNumber * TIMER_OFFSET));
   1726          
   1727              //
   1728              // Begin critical section.
   1729              //
   1730              AM_CRITICAL_BEGIN
   1731          
   1732              //
   1733              // Extract the timer mode from the register based on the ui32TimerSegment
   1734              // selected by the user.
   1735              //
   1736              ui32Mode = *pui32ControlReg;
   1737              if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
   1738              {
   1739                  ui32Mode = ui32Mode >> 16;
   1740              }
   1741          
   1742              //
   1743              // Mask to get to the bits we're interested in.
   1744              //
   1745              ui32Mode = ui32Mode & CTIMER_CTRL0_TMRA0FN_Msk;
   1746          
   1747              //
   1748              // If the mode is a PWM mode, we'll need to calculate the correct CMPR0 and
   1749              // CMPR1 values here.
   1750              //
   1751              if (ui32Mode == AM_HAL_CTIMER_FN_PWM_ONCE   ||
   1752                  ui32Mode == AM_HAL_CTIMER_FN_PWM_REPEAT)
   1753              {
   1754                  ui32Comp0 = ui32Period - ui32OnTime;
   1755                  ui32Comp1 = ui32Period;
   1756              }
   1757              else
   1758              {
   1759                  ui32Comp0 = ui32Period;
   1760                  ui32Comp1 = 0;
   1761              }
   1762          
   1763              //
   1764              // Based on the timer segment argument, write the calculated Compare 0 and
   1765              // Compare 1 values to the correct halves of the correct registers.
   1766              //
   1767              if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERA )
   1768              {
   1769                  //
   1770                  // For timer A, write the values to the TIMERA compare register.
   1771                  //
   1772                  *pui32CompareRegA = (_VAL2FLD(CTIMER_CMPRA0_CMPR0A0, ui32Comp0) |
   1773                                       _VAL2FLD(CTIMER_CMPRA0_CMPR1A0, ui32Comp1));
   1774              }
   1775              else if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
   1776              {
   1777                  //
   1778                  // For timer B, write the values to the TIMERA compare register.
   1779                  //
   1780                  *pui32CompareRegB = (_VAL2FLD(CTIMER_CMPRA0_CMPR0A0, ui32Comp0) |
   1781                                       _VAL2FLD(CTIMER_CMPRA0_CMPR1A0, ui32Comp1));
   1782              }
   1783              else
   1784              {
   1785                  //
   1786                  // For the linked case, write the lower halves of the values to the
   1787                  // TIMERA compare register, and the upper halves to the TIMERB compare
   1788                  // register.
   1789                  //
   1790                  *pui32CompareRegA = (_VAL2FLD(CTIMER_CMPRA0_CMPR0A0, ui32Comp0) |
   1791                                       _VAL2FLD(CTIMER_CMPRA0_CMPR1A0, ui32Comp1));
   1792          
   1793                  *pui32CompareRegB = (_VAL2FLD(CTIMER_CMPRA0_CMPR0A0, ui32Comp0 >> 16) |
   1794                                       _VAL2FLD(CTIMER_CMPRA0_CMPR1A0, ui32Comp1 >> 16));
   1795              }
   1796          
   1797              //
   1798              // Done with critical section.
   1799              //
   1800              AM_CRITICAL_END
   1801          
   1802          } // am_hal_ctimer_period_set()
   1803          
   1804          //*****************************************************************************
   1805          //
   1806          //! @brief Set the period and duty cycle of a timer.
   1807          //!
   1808          //! @param ui32TimerNumber is the number of the timer to configure.
   1809          //!
   1810          //! @param ui32TimerSegment specifies which segment of the timer to use.
   1811          //!
   1812          //! @param ui32Period specifies the desired period.  This parameter effectively
   1813          //! specifies the CTIMER CMPR field(s). The CMPR fields are handled in hardware
   1814          //! as (n+1) values, therefore ui32Period is actually specified as 1 less than
   1815          //! the desired period. Finally, as mentioned in the data sheet, the CMPR fields
   1816          //! cannot be 0 (a value of 1), so neither can ui32Period be 0.
   1817          //!
   1818          //! @param ui32OnTime set the number of clocks where the output signal is high.
   1819          //!
   1820          //! This function should be used for simple manipulations of the period and
   1821          //! duty cycle of a counter/timer. To set the period and/or duty cycle of a
   1822          //! linked timer pair, use AM_HAL_CTIMER_BOTH as the timer segment argument. If
   1823          //! you would like to set the period and/or duty cycle for both TIMERA and
   1824          //! TIMERB you will need to call this function twice: once for TIMERA, and once
   1825          //! for TIMERB.
   1826          //!
   1827          //! Valid values for ui32TimerSegment are:
   1828          //!
   1829          //!     AM_HAL_CTIMER_TIMERA
   1830          //!     AM_HAL_CTIMER_TIMERB
   1831          //!     AM_HAL_CTIMER_BOTH
   1832          //!
   1833          //! @note The ui32OnTime parameter will only work if the timer is currently
   1834          //! operating in one of the PWM modes.
   1835          //!
   1836          //! @return None.
   1837          //
   1838          //*****************************************************************************
   1839          void
   1840          am_hal_ctimer_aux_period_set(uint32_t ui32TimerNumber, uint32_t ui32TimerSegment,
   1841                                       uint32_t ui32Period, uint32_t ui32OnTime)
   1842          {
   1843              volatile uint32_t *pui32ControlReg;
   1844              volatile uint32_t *pui32CompareRegA;
   1845              volatile uint32_t *pui32CompareRegB;
   1846              uint32_t ui32Mode, ui32Comp0, ui32Comp1;
   1847          
   1848              //
   1849              // Find the correct control register to pull the function select field
   1850              // from.
   1851              //
   1852              pui32ControlReg = (uint32_t *)(&CTIMERn(0)->CTRL0 +
   1853                                            (ui32TimerNumber * TIMER_OFFSET));
   1854          
   1855              //
   1856              // Find the correct compare registers to write.
   1857              //
   1858              pui32CompareRegA = (uint32_t *)(&CTIMERn(0)->CMPRAUXA0 +
   1859                                             (ui32TimerNumber * TIMER_OFFSET));
   1860          
   1861              pui32CompareRegB = (uint32_t *)(&CTIMERn(0)->CMPRAUXB0 +
   1862                                             (ui32TimerNumber * TIMER_OFFSET));
   1863          
   1864              //
   1865              // Begin critical section.
   1866              //
   1867              AM_CRITICAL_BEGIN
   1868          
   1869              //
   1870              // Extract the timer mode from the register based on the ui32TimerSegment
   1871              // selected by the user.
   1872              //
   1873              ui32Mode = *pui32ControlReg;
   1874              if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
   1875              {
   1876                  ui32Mode = ui32Mode >> 16;
   1877              }
   1878          
   1879              //
   1880              // Mask to get to the bits we're interested in.
   1881              //
   1882              ui32Mode = ui32Mode & CTIMER_CTRL0_TMRA0FN_Msk;
   1883          
   1884              //
   1885              // If the mode is a PWM mode, we'll need to calculate the correct CMPR0 and
   1886              // CMPR1 values here.
   1887              //
   1888              if (ui32Mode == AM_HAL_CTIMER_FN_PWM_ONCE   ||
   1889                  ui32Mode == AM_HAL_CTIMER_FN_PWM_REPEAT)
   1890              {
   1891                  ui32Comp0 = ui32Period - ui32OnTime;
   1892                  ui32Comp1 = ui32Period;
   1893              }
   1894              else
   1895              {
   1896                  ui32Comp0 = ui32Period;
   1897                  ui32Comp1 = 0;
   1898              }
   1899          
   1900              //
   1901              // Based on the timer segment argument, write the calculated Compare 0 and
   1902              // Compare 1 values to the correct halves of the correct registers.
   1903              //
   1904              if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERA )
   1905              {
   1906                  //
   1907                  // For timer A, write the values to the TIMERA compare register.
   1908                  //
   1909                  *pui32CompareRegA = (_VAL2FLD(CTIMER_CMPRAUXA0_CMPR2A0, ui32Comp0) |
   1910                                       _VAL2FLD(CTIMER_CMPRAUXA0_CMPR3A0, ui32Comp1));
   1911              }
   1912              else if ( ui32TimerSegment == AM_HAL_CTIMER_TIMERB )
   1913              {
   1914                  //
   1915                  // For timer B, write the values to the TIMERA compare register.
   1916                  //
   1917                  *pui32CompareRegB = (_VAL2FLD(CTIMER_CMPRAUXA0_CMPR2A0, ui32Comp0) |
   1918                                       _VAL2FLD(CTIMER_CMPRAUXA0_CMPR3A0, ui32Comp1));
   1919              }
   1920              else
   1921              {
   1922                  //
   1923                  // For the linked case, write the lower halves of the values to the
   1924                  // TIMERA compare register, and the upper halves to the TIMERB compare
   1925                  // register.
   1926                  //
   1927                  *pui32CompareRegA = (_VAL2FLD(CTIMER_CMPRAUXA0_CMPR2A0, ui32Comp0) |
   1928                                       _VAL2FLD(CTIMER_CMPRAUXA0_CMPR3A0, ui32Comp1));
   1929          
   1930                  *pui32CompareRegB = (_VAL2FLD(CTIMER_CMPRAUXA0_CMPR2A0, ui32Comp0 >> 16) |
   1931                                       _VAL2FLD(CTIMER_CMPRAUXA0_CMPR3A0, ui32Comp1 >> 16));
   1932              }
   1933          
   1934              //
   1935              // Done with critical section.
   1936              //
   1937              AM_CRITICAL_END
   1938          
   1939          } // am_hal_ctimer_aux_period_set()
   1940          
   1941          //*****************************************************************************
   1942          //
   1943          //! @brief Enable the TIMERA3 ADC trigger
   1944          //!
   1945          //! This function enables the ADC trigger within TIMERA3.
   1946          //!
   1947          //! @return None.
   1948          //
   1949          //*****************************************************************************
   1950          void
   1951          am_hal_ctimer_adc_trigger_enable(void)
   1952          {
   1953              //
   1954              // Begin critical section.
   1955              //
   1956              AM_CRITICAL_BEGIN
   1957          
   1958              //
   1959              // Enable the ADC trigger.
   1960              //
   1961              CTIMERn(0)->CTRL3 |= CTIMER_CTRL3_ADCEN_Msk;
   1962          
   1963              //
   1964              // Done with critical section.
   1965              //
   1966              AM_CRITICAL_END
   1967          
   1968          } // am_hal_ctimer_adc_trigger_enable()
   1969          
   1970          //*****************************************************************************
   1971          //
   1972          //! @brief Disable the TIMERA3 ADC trigger
   1973          //!
   1974          //! This function disables the ADC trigger within TIMERA3.
   1975          //!
   1976          //! @return None.
   1977          //
   1978          //*****************************************************************************
   1979          void
   1980          am_hal_ctimer_adc_trigger_disable(void)
   1981          {
   1982              //
   1983              // Begin critical section.
   1984              //
   1985              AM_CRITICAL_BEGIN
   1986          
   1987              //
   1988              // Disable the ADC trigger.
   1989              //
   1990              CTIMERn(0)->CTRL3 &= ~CTIMER_CTRL3_ADCEN_Msk;
   1991          
   1992              //
   1993              // Done with critical section.
   1994              //
   1995              AM_CRITICAL_END
   1996          
   1997          } // am_hal_ctimer_adc_trigger_disable()
   1998          
   1999          //*****************************************************************************
   2000          //
   2001          //! @brief Enables the selected timer interrupt.
   2002          //!
   2003          //! @param ui32Interrupt is the interrupt to be used.
   2004          //!
   2005          //! This function will enable the selected interrupts in the main CTIMER
   2006          //! interrupt enable register. In order to receive an interrupt from a timer,
   2007          //! you will need to enable the interrupt for that timer in this main register,
   2008          //! as well as in the timer control register (accessible though
   2009          //! am_hal_ctimer_config()), and in the NVIC.
   2010          //!
   2011          //! ui32Interrupt should be the logical OR of one or more of the following
   2012          //! values:
   2013          //!
   2014          //!     AM_HAL_CTIMER_INT_TIMERAxCx, AM_HAL_CTIMER_INT_TIMERAxCx,
   2015          //!
   2016          //! @note The AM_HAL_CTIMER_INT_TIMER defines were re-definitions of
   2017          //!       AM_REG_CTIMER_INTEN_CTMRAxCxINT_M register defines. They are
   2018          //!       dropped in this release to go back to a single source definition.
   2019          //!
   2020          //! @return None.
   2021          //
   2022          //*****************************************************************************
   2023          void
   2024          am_hal_ctimer_int_enable(uint32_t ui32Interrupt)
   2025          {
   2026              //
   2027              // Begin critical section.
   2028              //
   2029              AM_CRITICAL_BEGIN
   2030          
   2031              //
   2032              // Enable the interrupt at the module level.
   2033              //
   2034              CTIMERn(0)->INTEN |= ui32Interrupt;
   2035          
   2036              //
   2037              // Done with critical section.
   2038              //
   2039              AM_CRITICAL_END
   2040          
   2041          } // am_hal_ctimer_int_enable()
   2042          
   2043          //*****************************************************************************
   2044          //
   2045          //! @brief Return the enabled timer interrupts.
   2046          //!
   2047          //! This function will return all enabled interrupts in the main CTIMER
   2048          //! interrupt enable register.
   2049          //!
   2050          //! @return return enabled interrupts. This will be a logical or of:
   2051          //!
   2052          //!     AM_REG_CTIMER_INTEN_CTMRAxC0INT_M, AM_HAL_CTIMER_INT_TIMERAxC1,
   2053          //!
   2054          //! @return Return the enabled timer interrupts.
   2055          //
   2056          //*****************************************************************************
   2057          uint32_t
   2058          am_hal_ctimer_int_enable_get(void)
   2059          {
   2060              //
   2061              // Return enabled interrupts.
   2062              //
   2063              return CTIMERn(0)->INTEN;
   2064          
   2065          } // am_hal_ctimer_int_enable_get()
   2066          
   2067          //*****************************************************************************
   2068          //
   2069          //! @brief Disables the selected timer interrupt.
   2070          //!
   2071          //! @param ui32Interrupt is the interrupt to be used.
   2072          //!
   2073          //! This function will disable the selected interrupts in the main CTIMER
   2074          //! interrupt register.
   2075          //!
   2076          //! ui32Interrupt should be the logical OR of one or more of the following
   2077          //! values:
   2078          //!
   2079          //!     AM_REG_CTIMER_INTEN_CTMRAxC0INT_M, AM_HAL_CTIMER_INT_TIMERAxC1,
   2080          //!
   2081          //! @return None.
   2082          //
   2083          //*****************************************************************************
   2084          void
   2085          am_hal_ctimer_int_disable(uint32_t ui32Interrupt)
   2086          {
   2087              //
   2088              // Begin critical section.
   2089              //
   2090              AM_CRITICAL_BEGIN
   2091          
   2092              //
   2093              // Disable the interrupt at the module level.
   2094              //
   2095              CTIMERn(0)->INTEN &= ~ui32Interrupt;
   2096          
   2097              //
   2098              // Done with critical section.
   2099              //
   2100              AM_CRITICAL_END
   2101          
   2102          } // am_hal_ctimer_int_disable()
   2103          
   2104          //*****************************************************************************
   2105          //
   2106          //! @brief Clears the selected timer interrupt.
   2107          //!
   2108          //! @param ui32Interrupt is the interrupt to be used.
   2109          //!
   2110          //! This function will clear the selected interrupts in the main CTIMER
   2111          //! interrupt register.
   2112          //!
   2113          //! ui32Interrupt should be the logical OR of one or more of the following
   2114          //! values:
   2115          //!
   2116          //!     AM_REG_CTIMER_INTEN_CTMRAxC0INT_M, AM_HAL_CTIMER_INT_TIMERAxC1,
   2117          //!
   2118          //! @return None.
   2119          //
   2120          //*****************************************************************************
   2121          void
   2122          am_hal_ctimer_int_clear(uint32_t ui32Interrupt)
   2123          {
   2124              //
   2125              // Begin critical section.
   2126              //
   2127              AM_CRITICAL_BEGIN
   2128          
   2129              //
   2130              // Disable the interrupt at the module level.
   2131              //
   2132              CTIMERn(0)->INTCLR = ui32Interrupt;
   2133          
   2134              //
   2135              // Done with critical section.
   2136              //
   2137              AM_CRITICAL_END
   2138          
   2139          } // am_hal_ctimer_int_clear()
   2140          
   2141          //*****************************************************************************
   2142          //
   2143          //! @brief Sets the selected timer interrupt.
   2144          //!
   2145          //! @param ui32Interrupt is the interrupt to be used.
   2146          //!
   2147          //! This function will set the selected interrupts in the main CTIMER
   2148          //! interrupt register.
   2149          //!
   2150          //! ui32Interrupt should be the logical OR of one or more of the following
   2151          //! values:
   2152          //!
   2153          //!     AM_REG_CTIMER_INTEN_CTMRAxC0INT_M, AM_HAL_CTIMER_INT_TIMERAxC1,
   2154          //!
   2155          //! @return None.
   2156          //
   2157          //*****************************************************************************
   2158          void
   2159          am_hal_ctimer_int_set(uint32_t ui32Interrupt)
   2160          {
   2161              //
   2162              // Begin critical section.
   2163              //
   2164              AM_CRITICAL_BEGIN
   2165          
   2166              //
   2167              // Set the interrupts.
   2168              //
   2169              CTIMERn(0)->INTSET = ui32Interrupt;
   2170          
   2171              //
   2172              // Done with critical section.
   2173              //
   2174              AM_CRITICAL_END
   2175          
   2176          } // am_hal_ctimer_int_set()
   2177          
   2178          //*****************************************************************************
   2179          //
   2180          //! @brief Returns either the enabled or raw timer interrupt status.
   2181          //!
   2182          //! This function will return the timer interrupt status.
   2183          //!
   2184          //! @param bEnabledOnly if true returns the status of the enabled interrupts
   2185          //! only.
   2186          //!
   2187          //! The return value will be the logical OR of one or more of the following
   2188          //! values:
   2189          //!
   2190          //!     AM_REG_CTIMER_INTEN_CTMRAxC0INT_M, AM_HAL_CTIMER_INT_TIMERAxC1,
   2191          //!
   2192          //! @return u32RetVal either the timer interrupt status, or interrupt enabled.
   2193          //
   2194          //*****************************************************************************
   2195          uint32_t
   2196          am_hal_ctimer_int_status_get(bool bEnabledOnly)
   2197          {
   2198              uint32_t u32RetVal = 0;
   2199          
   2200              //
   2201              // Begin critical section.
   2202              //
   2203              AM_CRITICAL_BEGIN
   2204          
   2205              //
   2206              // Return the desired status.
   2207              //
   2208          
   2209              if ( bEnabledOnly )
   2210              {
   2211                  u32RetVal  = CTIMERn(0)->INTSTAT;
   2212                  u32RetVal &= CTIMERn(0)->INTEN;
   2213              }
   2214              else
   2215              {
   2216                  u32RetVal = CTIMERn(0)->INTSTAT;
   2217              }
   2218          
   2219              //
   2220              // Done with critical section.
   2221              //
   2222              AM_CRITICAL_END
   2223          
   2224              return u32RetVal;
   2225          
   2226          } // am_hal_ctimer_int_status_get()
   2227          
   2228          //*****************************************************************************
   2229          //
   2230          // End Doxygen group.
   2231          //! @}
   2232          //
   2233          //*****************************************************************************

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   am_hal_ctimer_adc_trigger_disable
         8   -> am_hal_interrupt_master_disable
         8   -> am_hal_interrupt_master_set
       8   am_hal_ctimer_adc_trigger_enable
         8   -> am_hal_interrupt_master_disable
         8   -> am_hal_interrupt_master_set
      48   am_hal_ctimer_aux_compare_set
        48   -> am_hal_interrupt_master_disable
        48   -> am_hal_interrupt_master_set
      48   am_hal_ctimer_aux_period_set
        48   -> am_hal_interrupt_master_disable
        48   -> am_hal_interrupt_master_set
      24   am_hal_ctimer_clear
        24   -> am_hal_interrupt_master_disable
        24   -> am_hal_interrupt_master_set
      48   am_hal_ctimer_compare_set
        48   -> am_hal_interrupt_master_disable
        48   -> am_hal_interrupt_master_set
      24   am_hal_ctimer_config
        24   -> am_hal_interrupt_master_disable
        24   -> am_hal_interrupt_master_set
      32   am_hal_ctimer_config_single
        32   -> am_hal_interrupt_master_disable
        32   -> am_hal_interrupt_master_set
      32   am_hal_ctimer_config_trigger
        32   -> am_hal_interrupt_master_disable
        32   -> am_hal_interrupt_master_set
      16   am_hal_ctimer_globen
        16   -> am_hal_interrupt_master_disable
        16   -> am_hal_interrupt_master_set
      24   am_hal_ctimer_input_config
        24   -> am_hal_interrupt_master_disable
        24   -> am_hal_interrupt_master_set
      16   am_hal_ctimer_int_clear
        16   -> am_hal_interrupt_master_disable
        16   -> am_hal_interrupt_master_set
      16   am_hal_ctimer_int_disable
        16   -> am_hal_interrupt_master_disable
        16   -> am_hal_interrupt_master_set
      16   am_hal_ctimer_int_enable
        16   -> am_hal_interrupt_master_disable
        16   -> am_hal_interrupt_master_set
       0   am_hal_ctimer_int_enable_get
      16   am_hal_ctimer_int_register
        16   -> am_hal_debug_error
      16   am_hal_ctimer_int_service
        16   -- Indirect call
      16   am_hal_ctimer_int_set
        16   -> am_hal_interrupt_master_disable
        16   -> am_hal_interrupt_master_set
      24   am_hal_ctimer_int_status_get
        24   -> am_hal_interrupt_master_disable
        24   -> am_hal_interrupt_master_set
      56   am_hal_ctimer_output_config
        56   -> am_hal_gpio_pinconfig
        56   -> am_hal_interrupt_master_disable
        56   -> am_hal_interrupt_master_set
      48   am_hal_ctimer_period_set
        48   -> am_hal_interrupt_master_disable
        48   -> am_hal_interrupt_master_set
      56   am_hal_ctimer_read
        56   -> am_hal_triple_read
      32   am_hal_ctimer_start
        32   -> am_hal_interrupt_master_disable
        32   -> am_hal_interrupt_master_set
      24   am_hal_ctimer_stop
        24   -> am_hal_interrupt_master_disable
        24   -> am_hal_interrupt_master_set
       0   am_hal_triple_read


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_10
       4  ??DataTable23_11
       4  ??DataTable23_12
       4  ??DataTable23_13
       4  ??DataTable23_14
       4  ??DataTable23_15
       4  ??DataTable23_16
       4  ??DataTable23_17
       4  ??DataTable23_18
       4  ??DataTable23_19
       4  ??DataTable23_2
       4  ??DataTable23_20
       4  ??DataTable23_21
       4  ??DataTable23_22
       4  ??DataTable23_23
       4  ??DataTable23_24
       4  ??DataTable23_25
       4  ??DataTable23_26
       4  ??DataTable23_27
       4  ??DataTable23_3
       4  ??DataTable23_4
       4  ??DataTable23_5
       4  ??DataTable23_6
       4  ??DataTable23_7
       4  ??DataTable23_8
       4  ??DataTable23_9
      88  ?_0
      40  ?_1
       4  ?_2
      64  CTx_tbl
      26  am_hal_ctimer_adc_trigger_disable
      26  am_hal_ctimer_adc_trigger_enable
     124  am_hal_ctimer_aux_compare_set
     150  am_hal_ctimer_aux_period_set
      40  am_hal_ctimer_clear
     124  am_hal_ctimer_compare_set
     106  am_hal_ctimer_config
     120  am_hal_ctimer_config_single
      62  am_hal_ctimer_config_trigger
      24  am_hal_ctimer_globen
      22  am_hal_ctimer_input_config
      22  am_hal_ctimer_int_clear
      26  am_hal_ctimer_int_disable
      26  am_hal_ctimer_int_enable
       6  am_hal_ctimer_int_enable_get
     406  am_hal_ctimer_int_register
      46  am_hal_ctimer_int_service
      22  am_hal_ctimer_int_set
      46  am_hal_ctimer_int_status_get
     492  am_hal_ctimer_output_config
     150  am_hal_ctimer_period_set
     186  am_hal_ctimer_read
      88  am_hal_ctimer_start
      40  am_hal_ctimer_stop
      30  am_hal_triple_read
     128  g_am_hal_ctimer_ppfnHandlers
      32  g_ui32TMRAddrTbl
      16  g_ui8ClkSrc
      32  g_ui8TmrClkSrcMask
     128  outcfg_tbl

 
   128 bytes in section .bss
    16 bytes in section .data
   388 bytes in section .rodata
 2 522 bytes in section .text
 
 2 522 bytes of CODE  memory
   388 bytes of CONST memory
   144 bytes of DATA  memory

Errors: none
Warnings: none
