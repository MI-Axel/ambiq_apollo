###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         12/Mar/2019  10:07:10
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_stimer.c
#    Command line =  
#        -f C:\temp\EW8B8C.tmp
#        (C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_stimer.c
#        -D iar -D AM_PART_APOLLO3 -D AM_PACKAGE_BGA -lcN
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --diag_suppress Pa050 -o
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\utils\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\ARM\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\AmbiqMicro\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\mcu\apollo3\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\devices\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\bsp\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\sound\
#        -On)
#    Locale       =  C
#    List file    =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_stimer.lst
#    Object file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_stimer.o
#
###############################################################################

C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_stimer.c
      1          //*****************************************************************************
      2          //
      3          //  am_hal_stimer.c
      4          //! @file
      5          //!
      6          //! @brief Functions for interfacing with the system timer (STIMER).
      7          //!
      8          //! @addtogroup stimer3 System Timer (STIMER)
      9          //! @ingroup apollo3hal
     10          //! @{
     11          //
     12          //*****************************************************************************
     13          
     14          //*****************************************************************************
     15          //
     16          // Copyright (c) 2019, Ambiq Micro
     17          // All rights reserved.
     18          // 
     19          // Redistribution and use in source and binary forms, with or without
     20          // modification, are permitted provided that the following conditions are met:
     21          // 
     22          // 1. Redistributions of source code must retain the above copyright notice,
     23          // this list of conditions and the following disclaimer.
     24          // 
     25          // 2. Redistributions in binary form must reproduce the above copyright
     26          // notice, this list of conditions and the following disclaimer in the
     27          // documentation and/or other materials provided with the distribution.
     28          // 
     29          // 3. Neither the name of the copyright holder nor the names of its
     30          // contributors may be used to endorse or promote products derived from this
     31          // software without specific prior written permission.
     32          // 
     33          // Third party software included in this distribution is subject to the
     34          // additional license terms as defined in the /docs/licenses directory.
     35          // 
     36          // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     37          // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     38          // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     39          // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     40          // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     41          // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     42          // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     43          // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     44          // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     45          // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     46          // POSSIBILITY OF SUCH DAMAGE.
     47          //
     48          // This is part of revision v2.0.0 of the AmbiqSuite Development Package.
     49          //
     50          //*****************************************************************************
     51          
     52          #include <stdint.h>
     53          #include <stdbool.h>
     54          #include "am_mcu_apollo.h"
     55          
     56          
     57          //*****************************************************************************
     58          //
     59          //! @brief Set up the stimer.
     60          //!
     61          //! @param ui32STimerConfig is the value to load into the configuration reg.
     62          //!
     63          //! This function should be used to perform the initial set-up of the
     64          //! stimer.
     65          //!
     66          //! @return The 32-bit current config of the STimer Config register
     67          //
     68          //*****************************************************************************
     69          uint32_t
     70          am_hal_stimer_config(uint32_t ui32STimerConfig)
     71          {
     72              uint32_t ui32CurrVal;
     73          
     74              //
     75              // Read the current config
     76              //
     77              ui32CurrVal = CTIMER->STCFG;
     78          
     79              //
     80              // Write our configuration value.
     81              //
     82              CTIMER->STCFG = ui32STimerConfig;
     83          
     84          #if AM_PART_APOLLO2
     85              //
     86              // If all of the clock sources are not HFRC, disable LDO when sleeping if timers are enabled.
     87              //
     88              if ( (CTIMER->STCFG_b.CLKSELCTIMER->STCFG_b.CLKSEL == AM_REG_CTIMER_STCFG_CLKSEL_HFRC_DIV16)    ||
     89                   (CTIMER->STCFG_b.CLKSELCTIMER->STCFG_b.CLKSEL == AM_REG_CTIMER_STCFG_CLKSEL_HFRC_DIV256) )
     90              {
     91                  PWRCTRL->MISC_b.FORCEMEMVRLPTIMERS = 0;
     92              }
     93              else
     94              {
     95                  PWRCTRL->MISC_b.FORCEMEMVRLPTIMERS = 1;
     96              }
     97          #endif
     98          
     99              return ui32CurrVal;
    100          }
    101          
    102          //*****************************************************************************
    103          //
    104          //! @brief Get the current stimer value.
    105          //!
    106          //! This function can be used to read, uninvasively, the value in the stimer.
    107          //!
    108          //! @return The 32-bit value from the STimer counter register.
    109          //
    110          //*****************************************************************************
    111          uint32_t
    112          am_hal_stimer_counter_get(void)
    113          {
    114              return CTIMER->STTMR;
    115          }
    116          
    117          //*****************************************************************************
    118          //
    119          //! @brief Clear the stimer counter.
    120          //!
    121          //! This function clears the STimer Counter and leaves the stimer running.
    122          //!
    123          //! @return None.
    124          //
    125          //*****************************************************************************
    126          void
    127          am_hal_stimer_counter_clear(void)
    128          {
    129              //
    130              // Set the clear bit
    131              //
    132              CTIMER->STCFG |= CTIMER_STCFG_CLEAR_Msk;
    133          
    134              //
    135              // Reset the clear bit
    136              //
    137              CTIMER->STCFG &= ~CTIMER_STCFG_CLEAR_Msk;
    138          }
    139          
    140          //*****************************************************************************
    141          //
    142          //! @brief Set the compare value.
    143          //!
    144          //! @param ui32CmprInstance is the compare register instance number (0-7).
    145          //! @param ui32Delta is the value to add to the STimer counter and load into
    146          //!        the comparator register.
    147          //!
    148          //! NOTE: There is no way to set an absolute value into a comparator register.
    149          //!       Only deltas added to the STimer counter can be written to the compare
    150          //!       registers.
    151          //!
    152          //! @return None.
    153          //
    154          //*****************************************************************************
    155          void
    156          am_hal_stimer_compare_delta_set(uint32_t ui32CmprInstance, uint32_t ui32Delta)
    157          {
    158              uint32_t cfgVal;
    159              uint32_t numTries = 0;
    160          
    161              if ( ui32CmprInstance > 7 )
    162              {
    163                  return;
    164              }
    165          
    166              // We need to disable the compare temporarily while setting the delta value
    167              // That leaves a corner case where we could miss the trigger if setting a very
    168              // small delta. To avoid this, we take critical section, and we should ensure
    169              // that delta value is at least > 1
    170          
    171              //
    172              // Start a critical section.
    173              //
    174              AM_CRITICAL_BEGIN
    175          
    176              //
    177              // Get current CFG value
    178              //
    179              cfgVal = CTIMER->STCFG;
    180          
    181              //
    182              // Disable the compare if already enabled, when setting the new value
    183              //
    184              CTIMER->STCFG &= ~((AM_HAL_STIMER_CFG_COMPARE_A_ENABLE << ui32CmprInstance));
    185          
    186              // In rare case the delta might not be effective
    187              // We retry if that is the case.
    188              // Allow for some variability in the value owing to execution latency
    189              while (numTries++ < 4)
    190              {
    191                  uint32_t expVal;
    192                  uint32_t expMax;
    193                  uint32_t cmpVal;
    194          
    195                  // Expected value
    196                  expVal = CTIMER->STTMR + ui32Delta;
    197          
    198                  // Max allowed - taking care of latency
    199                  expMax = expVal + 10;
    200          
    201                  //
    202                  // Set the delta
    203                  //
    204                  AM_REGVAL(AM_REG_STIMER_COMPARE(0, ui32CmprInstance)) = ui32Delta;
    205          
    206                  // Read back the compare value
    207                  cmpVal = AM_REGVAL(AM_REG_STIMER_COMPARE(0, ui32CmprInstance));
    208          
    209                  // Make sure the value is in expected range
    210                  if (!AM_HAL_U32_SMALLER(cmpVal, expVal) && !AM_HAL_U32_GREATER(cmpVal, expMax))
    211                  {
    212                      break;
    213                  }
    214              }
    215          
    216          
    217              //
    218              // Restore Compare Enable bit
    219              //
    220              CTIMER->STCFG |= cfgVal & (AM_HAL_STIMER_CFG_COMPARE_A_ENABLE << ui32CmprInstance);
    221          
    222              //
    223              // End the critical section.
    224              //
    225              AM_CRITICAL_END
    226          }
    227          
    228          //*****************************************************************************
    229          //
    230          //! @brief Get the current stimer compare register value.
    231          //!
    232          //! @param ui32CmprInstance is the compare register instance number (0-7).
    233          //!
    234          //! This function can be used to read the value in an stimer compare register.
    235          //!
    236          //!
    237          //! @return None.
    238          //
    239          //*****************************************************************************
    240          uint32_t
    241          am_hal_stimer_compare_get(uint32_t ui32CmprInstance)
    242          {
    243              if ( ui32CmprInstance > 7 )
    244              {
    245                  return 0;
    246              }
    247          
    248              return AM_REGVAL(AM_REG_STIMER_COMPARE(0, ui32CmprInstance));
    249          }
    250          
    251          //*****************************************************************************
    252          //
    253          //! @brief Start capturing data with the specified capture register.
    254          //!
    255          //! @param ui32CaptureNum is the Capture Register Number to read (0-3).
    256          //! @param ui32GPIONumber is the pin number.
    257          //! @param bPolarity: false (0) = Capture on low to high transition.
    258          //!                   true  (1) = Capture on high to low transition.
    259          //!
    260          //! Use this function to start capturing.
    261          //!
    262          //! @return None.
    263          //
    264          //*****************************************************************************
    265          void
    266          am_hal_stimer_capture_start(uint32_t ui32CaptureNum,
    267                                      uint32_t ui32GPIONumber,
    268                                      bool bPolarity)
    269          {
    270              uint32_t ui32CapCtrl;
    271          
    272              if ( ui32GPIONumber > (AM_HAL_GPIO_MAX_PADS-1) )
    273              {
    274                  return;
    275              }
    276          
    277              //
    278              // Set the polarity and pin selection in the GPIO block.
    279              //
    280              switch (ui32CaptureNum)
    281              {
    282                   case 0:
    283                      GPIO->STMRCAP_b.STPOL0 = bPolarity;
    284                      GPIO->STMRCAP_b.STSEL0 = ui32GPIONumber;
    285                      ui32CapCtrl = CTIMER_CAPTURECONTROL_CAPTURE0_Msk;
    286                      break;
    287                   case 1:
    288                      GPIO->STMRCAP_b.STPOL1 = bPolarity;
    289                      GPIO->STMRCAP_b.STSEL1 = ui32GPIONumber;
    290                      ui32CapCtrl = CTIMER_CAPTURECONTROL_CAPTURE1_Msk;
    291                      break;
    292                   case 2:
    293                      GPIO->STMRCAP_b.STPOL2 = bPolarity;
    294                      GPIO->STMRCAP_b.STSEL2 = ui32GPIONumber;
    295                      ui32CapCtrl = CTIMER_CAPTURECONTROL_CAPTURE2_Msk;
    296                      break;
    297                   case 3:
    298                      GPIO->STMRCAP_b.STPOL3 = bPolarity;
    299                      GPIO->STMRCAP_b.STSEL3 = ui32GPIONumber;
    300                      ui32CapCtrl = CTIMER_CAPTURECONTROL_CAPTURE3_Msk;
    301                      break;
    302                   default:
    303                      return;     // error concealment.
    304              }
    305          
    306              //
    307              // Enable it in the CTIMER Block
    308              //
    309              CTIMER->CAPTURECONTROL |= ui32CapCtrl;
    310          }
    311          
    312          //*****************************************************************************
    313          //
    314          //! @brief Start capturing data with the specified capture register.
    315          //!
    316          //! @param ui32CaptureNum is the Capture Register Number to read.
    317          //!
    318          //! Use this function to start capturing.
    319          //!
    320          //! @return None.
    321          //
    322          //*****************************************************************************
    323          void am_hal_stimer_capture_stop(uint32_t ui32CaptureNum)
    324          {
    325              //
    326              // Disable it in the CTIMER block.
    327              //
    328              CTIMER->CAPTURECONTROL &=
    329                  ~(CTIMER_CAPTURECONTROL_CAPTURE0_Msk <<
    330                    ((CTIMER_CAPTURECONTROL_CAPTURE1_Pos -
    331                      CTIMER_CAPTURECONTROL_CAPTURE0_Pos) * ui32CaptureNum));
    332          }
    333          
    334          //*****************************************************************************
    335          //
    336          //! @brief Get the current stimer nvram register value.
    337          //!
    338          //! @param ui32NvramNum is the NVRAM Register Number to read.
    339          //! @param ui32NvramVal is the value to write to NVRAM.
    340          //!
    341          //! This function can be used to read the value in an stimer NVRAM register.
    342          //!
    343          //!
    344          //! @return None.
    345          //
    346          //*****************************************************************************
    347          void
    348          am_hal_stimer_nvram_set(uint32_t ui32NvramNum, uint32_t ui32NvramVal)
    349          {
    350              if ( ui32NvramNum > 3 )
    351              {
    352                  return;
    353              }
    354          
    355              //AM_REGn(CTIMER, 0, SNVR)
    356              //AM_REG_STIMER_NVRAM(0, ui32NvramNum) = ui32NvramVal;
    357          }
    358          
    359          //*****************************************************************************
    360          //
    361          //! @brief Get the current stimer nvram register value.
    362          //!
    363          //! @param ui32NvramNum is the NVRAM Register Number to read.
    364          //!
    365          //! This function can be used to read the value in an stimer NVRAM register.
    366          //!
    367          //!
    368          //! @return None.
    369          //
    370          //*****************************************************************************
    371          uint32_t am_hal_stimer_nvram_get(uint32_t ui32NvramNum)
    372          {
    373              if ( ui32NvramNum > 3 )
    374              {
    375                  return 0;
    376              }
    377          
    378              return AM_REGVAL(AM_REG_STIMER_NVRAM(0, ui32NvramNum));
    379          }
    380          
    381          //*****************************************************************************
    382          //
    383          //! @brief Get the current stimer capture register value.
    384          //!
    385          //! @param ui32CaptureNum is the Capture Register Number to read.
    386          //!
    387          //! This function can be used to read the value in an stimer capture register.
    388          //!
    389          //!
    390          //! @return None.
    391          //
    392          //*****************************************************************************
    393          uint32_t am_hal_stimer_capture_get(uint32_t ui32CaptureNum)
    394          {
    395              if ( ui32CaptureNum > 7 )
    396              {
    397                  return 0;
    398              }
    399          
    400              return AM_REGVAL(AM_REG_STIMER_CAPTURE(0, ui32CaptureNum));
    401          }
    402          
    403          //*****************************************************************************
    404          //
    405          //! @brief Enables the selected system timer interrupt.
    406          //!
    407          //! @param ui32Interrupt is the interrupt to be used.
    408          //!
    409          //! This function will enable the selected interrupts in the STIMER interrupt
    410          //! enable register. In order to receive an interrupt from an stimer component,
    411          //! you will need to enable the interrupt for that component in this main
    412          //! register, as well as in the stimer configuration register (accessible though
    413          //! am_hal_stimer_config()), and in the NVIC.
    414          //!
    415          //! ui32Interrupt should be the logical OR of one or more of the following
    416          //! values:
    417          //!
    418          //!     AM_HAL_STIMER_INT_COMPAREA
    419          //!     AM_HAL_STIMER_INT_COMPAREB
    420          //!     AM_HAL_STIMER_INT_COMPAREC
    421          //!     AM_HAL_STIMER_INT_COMPARED
    422          //!     AM_HAL_STIMER_INT_COMPAREE
    423          //!     AM_HAL_STIMER_INT_COMPAREF
    424          //!     AM_HAL_STIMER_INT_COMPAREG
    425          //!     AM_HAL_STIMER_INT_COMPAREH
    426          //!
    427          //!     AM_HAL_STIMER_INT_OVERFLOW
    428          //!
    429          //!     AM_HAL_STIMER_INT_CAPTUREA
    430          //!     AM_HAL_STIMER_INT_CAPTUREB
    431          //!     AM_HAL_STIMER_INT_CAPTUREC
    432          //!     AM_HAL_STIMER_INT_CAPTURED
    433          //!
    434          //! @return None.
    435          //
    436          //*****************************************************************************
    437          void
    438          am_hal_stimer_int_enable(uint32_t ui32Interrupt)
    439          {
    440              //
    441              // Enable the interrupt at the module level.
    442              //
    443              CTIMERn(0)->STMINTEN |= ui32Interrupt;
    444          }
    445          
    446          //*****************************************************************************
    447          //
    448          //! @brief Return the enabled stimer interrupts.
    449          //!
    450          //! This function will return all enabled interrupts in the STIMER
    451          //! interrupt enable register.
    452          //!
    453          //! @return return enabled interrupts. This will be a logical or of:
    454          //!
    455          //!     AM_HAL_STIMER_INT_COMPAREA
    456          //!     AM_HAL_STIMER_INT_COMPAREB
    457          //!     AM_HAL_STIMER_INT_COMPAREC
    458          //!     AM_HAL_STIMER_INT_COMPARED
    459          //!     AM_HAL_STIMER_INT_COMPAREE
    460          //!     AM_HAL_STIMER_INT_COMPAREF
    461          //!     AM_HAL_STIMER_INT_COMPAREG
    462          //!     AM_HAL_STIMER_INT_COMPAREH
    463          //!
    464          //!     AM_HAL_STIMER_INT_OVERFLOW
    465          //!
    466          //!     AM_HAL_STIMER_INT_CAPTUREA
    467          //!     AM_HAL_STIMER_INT_CAPTUREB
    468          //!     AM_HAL_STIMER_INT_CAPTUREC
    469          //!     AM_HAL_STIMER_INT_CAPTURED
    470          //!
    471          //! @return Return the enabled timer interrupts.
    472          //
    473          //*****************************************************************************
    474          uint32_t
    475          am_hal_stimer_int_enable_get(void)
    476          {
    477              //
    478              // Return enabled interrupts.
    479              //
    480              return CTIMERn(0)->STMINTEN;
    481          }
    482          
    483          //*****************************************************************************
    484          //
    485          //! @brief Disables the selected stimer interrupt.
    486          //!
    487          //! @param ui32Interrupt is the interrupt to be used.
    488          //!
    489          //! This function will disable the selected interrupts in the STIMER
    490          //! interrupt register.
    491          //!
    492          //! ui32Interrupt should be the logical OR of one or more of the following
    493          //! values:
    494          //!
    495          //!     AM_HAL_STIMER_INT_COMPAREA
    496          //!     AM_HAL_STIMER_INT_COMPAREB
    497          //!     AM_HAL_STIMER_INT_COMPAREC
    498          //!     AM_HAL_STIMER_INT_COMPARED
    499          //!     AM_HAL_STIMER_INT_COMPAREE
    500          //!     AM_HAL_STIMER_INT_COMPAREF
    501          //!     AM_HAL_STIMER_INT_COMPAREG
    502          //!     AM_HAL_STIMER_INT_COMPAREH
    503          //!
    504          //!     AM_HAL_STIMER_INT_OVERFLOW
    505          //!
    506          //!     AM_HAL_STIMER_INT_CAPTUREA
    507          //!     AM_HAL_STIMER_INT_CAPTUREB
    508          //!     AM_HAL_STIMER_INT_CAPTUREC
    509          //!     AM_HAL_STIMER_INT_CAPTURED
    510          //!
    511          //! @return None.
    512          //
    513          //*****************************************************************************
    514          void
    515          am_hal_stimer_int_disable(uint32_t ui32Interrupt)
    516          {
    517              //
    518              // Disable the interrupt at the module level.
    519              //
    520              CTIMERn(0)->STMINTEN &= ~ui32Interrupt;
    521          }
    522          
    523          //*****************************************************************************
    524          //
    525          //! @brief Sets the selected stimer interrupt.
    526          //!
    527          //! @param ui32Interrupt is the interrupt to be used.
    528          //!
    529          //! This function will set the selected interrupts in the STIMER
    530          //! interrupt register.
    531          //!
    532          //! ui32Interrupt should be the logical OR of one or more of the following
    533          //! values:
    534          //!
    535          //!     AM_HAL_STIMER_INT_COMPAREA
    536          //!     AM_HAL_STIMER_INT_COMPAREB
    537          //!     AM_HAL_STIMER_INT_COMPAREC
    538          //!     AM_HAL_STIMER_INT_COMPARED
    539          //!     AM_HAL_STIMER_INT_COMPAREE
    540          //!     AM_HAL_STIMER_INT_COMPAREF
    541          //!     AM_HAL_STIMER_INT_COMPAREG
    542          //!     AM_HAL_STIMER_INT_COMPAREH
    543          //!
    544          //!     AM_HAL_STIMER_INT_OVERFLOW
    545          //!
    546          //!     AM_HAL_STIMER_INT_CAPTUREA
    547          //!     AM_HAL_STIMER_INT_CAPTUREB
    548          //!     AM_HAL_STIMER_INT_CAPTUREC
    549          //!     AM_HAL_STIMER_INT_CAPTURED
    550          //!
    551          //! @return None.
    552          //
    553          //*****************************************************************************
    554          void
    555          am_hal_stimer_int_set(uint32_t ui32Interrupt)
    556          {
    557              //
    558              // Set the interrupts.
    559              //
    560              CTIMERn(0)->STMINTSET = ui32Interrupt;
    561          }
    562          
    563          //*****************************************************************************
    564          //
    565          //! @brief Clears the selected stimer interrupt.
    566          //!
    567          //! @param ui32Interrupt is the interrupt to be used.
    568          //!
    569          //! This function will clear the selected interrupts in the STIMER
    570          //! interrupt register.
    571          //!
    572          //! ui32Interrupt should be the logical OR of one or more of the following
    573          //! values:
    574          //!
    575          //!     AM_HAL_STIMER_INT_COMPAREA
    576          //!     AM_HAL_STIMER_INT_COMPAREB
    577          //!     AM_HAL_STIMER_INT_COMPAREC
    578          //!     AM_HAL_STIMER_INT_COMPARED
    579          //!     AM_HAL_STIMER_INT_COMPAREE
    580          //!     AM_HAL_STIMER_INT_COMPAREF
    581          //!     AM_HAL_STIMER_INT_COMPAREG
    582          //!     AM_HAL_STIMER_INT_COMPAREH
    583          //!
    584          //!     AM_HAL_STIMER_INT_OVERFLOW
    585          //!
    586          //!     AM_HAL_STIMER_INT_CAPTUREA
    587          //!     AM_HAL_STIMER_INT_CAPTUREB
    588          //!     AM_HAL_STIMER_INT_CAPTUREC
    589          //!     AM_HAL_STIMER_INT_CAPTURED
    590          //!
    591          //! @return None.
    592          //
    593          //*****************************************************************************
    594          void
    595          am_hal_stimer_int_clear(uint32_t ui32Interrupt)
    596          {
    597              //
    598              // Disable the interrupt at the module level.
    599              //
    600              CTIMERn(0)->STMINTCLR = ui32Interrupt;
    601          }
    602          
    603          
    604          //*****************************************************************************
    605          //
    606          //! @brief Returns either the enabled or raw stimer interrupt status.
    607          //!
    608          //! This function will return the stimer interrupt status.
    609          //!
    610          //! @param bEnabledOnly if true returns the status of the enabled interrupts
    611          //! only.
    612          //!
    613          //! The return value will be the logical OR of one or more of the following
    614          //! values:
    615          //!
    616          //!
    617          //! @return Returns the stimer interrupt status.
    618          //
    619          //*****************************************************************************
    620          uint32_t
    621          am_hal_stimer_int_status_get(bool bEnabledOnly)
    622          {
    623              //
    624              // Return the desired status.
    625              //
    626              uint32_t ui32RetVal = CTIMERn(0)->STMINTSTAT;
    627          
    628              if ( bEnabledOnly )
    629              {
    630                  ui32RetVal &= CTIMERn(0)->STMINTEN;
    631              }
    632          
    633              return ui32RetVal;
    634          }
    635          
    636          //*****************************************************************************
    637          //
    638          // End Doxygen group.
    639          //! @}
    640          //
    641          //*****************************************************************************

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   am_hal_stimer_capture_get
       8   am_hal_stimer_capture_start
       0   am_hal_stimer_capture_stop
      24   am_hal_stimer_compare_delta_set
        24   -> am_hal_interrupt_master_disable
        24   -> am_hal_interrupt_master_set
       0   am_hal_stimer_compare_get
       0   am_hal_stimer_config
       0   am_hal_stimer_counter_clear
       0   am_hal_stimer_counter_get
       0   am_hal_stimer_int_clear
       0   am_hal_stimer_int_disable
       0   am_hal_stimer_int_enable
       0   am_hal_stimer_int_enable_get
       0   am_hal_stimer_int_set
       0   am_hal_stimer_int_status_get
       0   am_hal_stimer_nvram_get
       0   am_hal_stimer_nvram_set


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
      18  am_hal_stimer_capture_get
     140  am_hal_stimer_capture_start
      14  am_hal_stimer_capture_stop
     106  am_hal_stimer_compare_delta_set
      18  am_hal_stimer_compare_get
      10  am_hal_stimer_config
      20  am_hal_stimer_counter_clear
       6  am_hal_stimer_counter_get
       6  am_hal_stimer_int_clear
      10  am_hal_stimer_int_disable
      10  am_hal_stimer_int_enable
       6  am_hal_stimer_int_enable_get
       6  am_hal_stimer_int_set
      22  am_hal_stimer_int_status_get
      18  am_hal_stimer_nvram_get
       6  am_hal_stimer_nvram_set

 
 460 bytes in section .text
 
 460 bytes of CODE memory

Errors: none
Warnings: none
