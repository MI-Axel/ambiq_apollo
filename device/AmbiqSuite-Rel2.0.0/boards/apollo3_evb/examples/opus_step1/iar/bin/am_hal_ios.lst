###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         12/Mar/2019  10:07:08
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_ios.c
#    Command line =  
#        -f C:\temp\EW848C.tmp
#        (C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_ios.c
#        -D iar -D AM_PART_APOLLO3 -D AM_PACKAGE_BGA -lcN
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --diag_suppress Pa050 -o
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\utils\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\ARM\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\AmbiqMicro\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\mcu\apollo3\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\devices\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\bsp\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\sound\
#        -On)
#    Locale       =  C
#    List file    =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_ios.lst
#    Object file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_ios.o
#
###############################################################################

C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_ios.c
      1          //*****************************************************************************
      2          //
      3          //  am_hal_ios.c
      4          //! @file
      5          //!
      6          //! @brief Functions for interfacing with the IO Slave module
      7          //!
      8          //! @addtogroup ios3 IO Slave (SPI/I2C)
      9          //! @ingroup apollo3hal
     10          //! @{
     11          //
     12          //*****************************************************************************
     13          
     14          //*****************************************************************************
     15          //
     16          // Copyright (c) 2019, Ambiq Micro
     17          // All rights reserved.
     18          // 
     19          // Redistribution and use in source and binary forms, with or without
     20          // modification, are permitted provided that the following conditions are met:
     21          // 
     22          // 1. Redistributions of source code must retain the above copyright notice,
     23          // this list of conditions and the following disclaimer.
     24          // 
     25          // 2. Redistributions in binary form must reproduce the above copyright
     26          // notice, this list of conditions and the following disclaimer in the
     27          // documentation and/or other materials provided with the distribution.
     28          // 
     29          // 3. Neither the name of the copyright holder nor the names of its
     30          // contributors may be used to endorse or promote products derived from this
     31          // software without specific prior written permission.
     32          // 
     33          // Third party software included in this distribution is subject to the
     34          // additional license terms as defined in the /docs/licenses directory.
     35          // 
     36          // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     37          // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     38          // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     39          // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     40          // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     41          // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     42          // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     43          // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     44          // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     45          // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     46          // POSSIBILITY OF SUCH DAMAGE.
     47          //
     48          // This is part of revision v2.0.0 of the AmbiqSuite Development Package.
     49          //
     50          //*****************************************************************************
     51          
     52          #include <stdint.h>
     53          #include <stdbool.h>
     54          #include "am_mcu_apollo.h"
     55          
     56          #define AM_HAL_IOS_MAX_SW_FIFO_SIZE 1023
     57          #define AM_HAL_MAGIC_IOS            0x123456
     58          #define AM_HAL_IOS_CHK_HANDLE(h)    ((h) && ((am_hal_handle_prefix_t *)(h))->s.bInit && (((am_hal_handle_prefix_t *)(h))->s.magic == AM_HAL_MAGIC_IOS))
     59          
     60          //*****************************************************************************
     61          //
     62          // SRAM Buffer structure
     63          //
     64          //*****************************************************************************
     65          am_hal_ios_buffer_t g_sSRAMBuffer;
     66          
     67          //*****************************************************************************
     68          //
     69          // Private Types.
     70          //
     71          //*****************************************************************************
     72          typedef struct
     73          {
     74              bool        bValid;
     75              uint32_t    regFIFOCFG;
     76              uint32_t    regFIFOTHR;
     77              uint32_t    regCFG;
     78              uint32_t    regINTEN;
     79              uint32_t    regACCINTEN;
     80          } am_hal_ios_register_state_t;
     81          
     82          typedef struct
     83          {
     84              am_hal_handle_prefix_t  prefix;
     85              //
     86              // Physical module number.
     87              //
     88              uint32_t                ui32Module;
     89          
     90              am_hal_ios_register_state_t registerState;
     91          
     92              uint8_t *pui8FIFOBase;
     93              uint8_t *pui8FIFOEnd;
     94              uint8_t *pui8FIFOPtr;
     95              uint8_t ui32HwFifoSize;
     96              uint32_t ui32FifoBaseOffset;
     97          } am_hal_ios_state_t;
     98          
     99          //*****************************************************************************
    100          //
    101          // Forward declarations of static funcitons.
    102          //
    103          //*****************************************************************************
    104          static void am_hal_ios_buffer_init(am_hal_ios_buffer_t *psBuffer,
    105                                             void *pvArray, uint32_t ui32Bytes);
    106          static void fifo_write(void *pHandle, uint8_t *pui8Data, uint32_t ui32NumBytes);
    107          static uint32_t am_hal_ios_fifo_ptr_set(void *pHandle, uint32_t ui32Offset);
    108          //*****************************************************************************
    109          //
    110          // Function-like macros.
    111          //
    112          //*****************************************************************************
    113          #define am_hal_ios_buffer_empty(psBuffer)                                   \
    114              ((psBuffer)->ui32Length == 0)
    115          
    116          #define am_hal_ios_buffer_full(psBuffer)                                    \
    117              ((psBuffer)->ui32Length == (psBuffer)->ui32Capacity)
    118          
    119          #define am_hal_ios_buffer_data_left(psBuffer)                               \
    120              ((psBuffer)->ui32Length)
    121          
    122          //*****************************************************************************
    123          //
    124          // Global Variables
    125          //
    126          //*****************************************************************************
    127          volatile uint8_t * const am_hal_ios_pui8LRAM = (uint8_t *)REG_IOSLAVE_BASEADDR;
    128          
    129          am_hal_ios_state_t g_IOShandles[AM_REG_IOSLAVE_NUM_MODULES];
    130          
    131          //*****************************************************************************
    132          //
    133          // IOS power control function
    134          //
    135          //*****************************************************************************
    136          uint32_t am_hal_ios_power_ctrl(void *pHandle,
    137                                         am_hal_sysctrl_power_state_e ePowerState,
    138                                         bool bRetainState)
    139          {
    140              am_hal_ios_state_t *pIOSState = (am_hal_ios_state_t*)pHandle;
    141          
    142          #ifndef AM_HAL_DISABLE_API_VALIDATION
    143              if ( !AM_HAL_IOS_CHK_HANDLE(pHandle) )
    144              {
    145                  return AM_HAL_STATUS_INVALID_HANDLE;
    146              }
    147          #endif
    148          
    149              //
    150              // Decode the requested power state and update IOS operation accordingly.
    151              //
    152              switch (ePowerState)
    153              {
    154                  case AM_HAL_SYSCTRL_WAKE:
    155                      if (bRetainState && !pIOSState->registerState.bValid)
    156                      {
    157                          return AM_HAL_STATUS_INVALID_OPERATION;
    158                      }
    159          
    160                      //
    161                      // Enable power control.
    162                      //
    163                      am_hal_pwrctrl_periph_enable((am_hal_pwrctrl_periph_e)(AM_HAL_PWRCTRL_PERIPH_IOS + pIOSState->ui32Module));
    164          
    165                      if (bRetainState)
    166                      {
    167                          //
    168                          // Restore IOS registers
    169                          IOSLAVEn(pIOSState->ui32Module)->FIFOCFG     = pIOSState->registerState.regFIFOCFG;
    170                          IOSLAVEn(pIOSState->ui32Module)->FIFOTHR     = pIOSState->registerState.regFIFOTHR;
    171                          IOSLAVEn(pIOSState->ui32Module)->CFG         = pIOSState->registerState.regCFG;
    172                          IOSLAVEn(pIOSState->ui32Module)->INTEN       = pIOSState->registerState.regINTEN;
    173                          IOSLAVEn(pIOSState->ui32Module)->REGACCINTEN = pIOSState->registerState.regACCINTEN;
    174          
    175                          pIOSState->registerState.bValid = false;
    176                      }
    177                      break;
    178          
    179                  case AM_HAL_SYSCTRL_NORMALSLEEP:
    180                  case AM_HAL_SYSCTRL_DEEPSLEEP:
    181                      if (bRetainState)
    182                      {
    183                          // Save IOS Registers
    184                          pIOSState->registerState.regFIFOCFG    = IOSLAVEn(pIOSState->ui32Module)->FIFOCFG;
    185                          pIOSState->registerState.regFIFOTHR    = IOSLAVEn(pIOSState->ui32Module)->FIFOTHR;
    186                          pIOSState->registerState.regCFG        = IOSLAVEn(pIOSState->ui32Module)->CFG;
    187                          pIOSState->registerState.regINTEN      = IOSLAVEn(pIOSState->ui32Module)->INTEN;
    188                          pIOSState->registerState.regACCINTEN   = IOSLAVEn(pIOSState->ui32Module)->REGACCINTEN;
    189                          pIOSState->registerState.bValid = true;
    190                      }
    191          
    192                      //
    193                      // Disable power control.
    194                      //
    195                      am_hal_pwrctrl_periph_disable((am_hal_pwrctrl_periph_e)(AM_HAL_PWRCTRL_PERIPH_IOS + pIOSState->ui32Module));
    196                      break;
    197          
    198                  default:
    199                      return AM_HAL_STATUS_INVALID_ARG;
    200              }
    201          
    202              //
    203              // Return the status.
    204              //
    205              return AM_HAL_STATUS_SUCCESS;
    206          } // am_hal_ios_power_ctrl()
    207          
    208          //*****************************************************************************
    209          //
    210          // IOS uninitialize function
    211          //
    212          //*****************************************************************************
    213          uint32_t am_hal_ios_uninitialize(void *pHandle)
    214          {
    215              am_hal_ios_state_t *pIOSState = (am_hal_ios_state_t*)pHandle;
    216          
    217          #ifndef AM_HAL_DISABLE_API_VALIDATION
    218              if (!AM_HAL_IOS_CHK_HANDLE(pHandle))
    219              {
    220                  return AM_HAL_STATUS_INVALID_HANDLE;
    221              }
    222          #endif
    223          
    224              if (pIOSState->prefix.s.bEnable)
    225              {
    226                  am_hal_ios_disable(pHandle);
    227              }
    228          
    229              pIOSState->prefix.s.bInit = false;
    230          
    231              return AM_HAL_STATUS_SUCCESS;
    232          } // am_hal_ios_uninitialize()
    233          
    234          
    235          //*****************************************************************************
    236          //
    237          // IOS initialization function
    238          //
    239          //*****************************************************************************
    240          uint32_t am_hal_ios_initialize(uint32_t ui32Module, void **ppHandle)
    241          {
    242          #ifndef AM_HAL_DISABLE_API_VALIDATION
    243              //
    244              // Validate the module number
    245              //
    246              if ( ui32Module >= AM_REG_IOSLAVE_NUM_MODULES )
    247              {
    248                  return AM_HAL_STATUS_OUT_OF_RANGE;
    249              }
    250          
    251              if (ppHandle == NULL)
    252              {
    253                  return AM_HAL_STATUS_INVALID_ARG;
    254              }
    255          
    256              if (g_IOShandles[ui32Module].prefix.s.bInit)
    257              {
    258                  return AM_HAL_STATUS_INVALID_OPERATION;
    259              }
    260          #endif
    261          
    262              g_IOShandles[ui32Module].prefix.s.bInit = true;
    263              g_IOShandles[ui32Module].prefix.s.bEnable = false;
    264              g_IOShandles[ui32Module].prefix.s.magic = AM_HAL_MAGIC_IOS;
    265          
    266              //
    267              // Initialize the handle.
    268              //
    269              g_IOShandles[ui32Module].ui32Module = ui32Module;
    270          
    271              //
    272              // Return the handle.
    273              //
    274              *ppHandle = (void *)&g_IOShandles[ui32Module];
    275          
    276              return AM_HAL_STATUS_SUCCESS;
    277          } // am_hal_ios_initialize()
    278          
    279          //*****************************************************************************
    280          //
    281          // IOS enable function
    282          //
    283          //*****************************************************************************
    284          uint32_t am_hal_ios_enable(void *pHandle)
    285          {
    286              am_hal_ios_state_t *pIOSState = (am_hal_ios_state_t*)pHandle;
    287          #ifndef AM_HAL_DISABLE_API_VALIDATION
    288              if (!AM_HAL_IOS_CHK_HANDLE(pHandle))
    289              {
    290                  return AM_HAL_STATUS_INVALID_HANDLE;
    291              }
    292          
    293              if (pIOSState->prefix.s.bEnable)
    294              {
    295                  return AM_HAL_STATUS_SUCCESS;
    296              }
    297          #endif
    298          
    299              IOSLAVEn(pIOSState->ui32Module)->CFG |= _VAL2FLD(IOSLAVE_CFG_IFCEN, 1);
    300          
    301              pIOSState->prefix.s.bEnable = true;
    302          
    303              return AM_HAL_STATUS_SUCCESS;
    304          } // am_hal_ios_enable()
    305          
    306          //*****************************************************************************
    307          //
    308          // IOS disable function
    309          //
    310          //*****************************************************************************
    311          uint32_t am_hal_ios_disable(void *pHandle)
    312          {
    313              am_hal_ios_state_t *pIOSState = (am_hal_ios_state_t*)pHandle;
    314          
    315          #ifndef AM_HAL_DISABLE_API_VALIDATION
    316              if (!AM_HAL_IOS_CHK_HANDLE(pHandle))
    317              {
    318                  return AM_HAL_STATUS_INVALID_HANDLE;
    319              }
    320          #endif
    321          
    322              if (!pIOSState->prefix.s.bEnable)
    323              {
    324                  return AM_HAL_STATUS_SUCCESS;
    325              }
    326          
    327              IOSLAVEn(pIOSState->ui32Module)->CFG &= ~(_VAL2FLD(IOSLAVE_CFG_IFCEN, 1));
    328          
    329              pIOSState->prefix.s.bEnable = false;
    330          
    331              return AM_HAL_STATUS_SUCCESS;
    332          
    333          } // am_hal_ios_disable()
    334          
    335          //*****************************************************************************
    336          //
    337          // IOS configuration function.
    338          //
    339          //*****************************************************************************
    340          uint32_t am_hal_ios_configure(void *pHandle, am_hal_ios_config_t *psConfig)
    341          {
    342              uint32_t ui32LRAMConfig = 0;
    343              am_hal_ios_state_t *pIOSState = (am_hal_ios_state_t*)pHandle;
    344              uint32_t ui32Module;
    345          
    346          #ifndef AM_HAL_DISABLE_API_VALIDATION
    347              if (!AM_HAL_IOS_CHK_HANDLE(pHandle))
    348              {
    349                  return AM_HAL_STATUS_INVALID_HANDLE;
    350              }
    351          
    352              //
    353              // Validate the parameters
    354              //
    355              if ( (psConfig == NULL) ||
    356                   (pIOSState->ui32Module >= AM_REG_IOSLAVE_NUM_MODULES) )
    357              {
    358                  return AM_HAL_STATUS_INVALID_ARG;
    359              }
    360              // Configure not allowed in Enabled state
    361              if (pIOSState->prefix.s.bEnable)
    362              {
    363                  return AM_HAL_STATUS_INVALID_OPERATION;
    364              }
    365          #endif
    366          
    367              ui32Module = pIOSState->ui32Module;
    368          
    369              am_hal_pwrctrl_periph_enable(AM_HAL_PWRCTRL_PERIPH_IOS);
    370          
    371              //
    372              // Record the FIFO parameters for later use.
    373              //
    374              pIOSState->pui8FIFOBase = (uint8_t *)(REG_IOSLAVE_BASEADDR + psConfig->ui32FIFOBase);
    375              pIOSState->pui8FIFOEnd = (uint8_t *)(REG_IOSLAVE_BASEADDR + psConfig->ui32RAMBase);
    376              pIOSState->ui32HwFifoSize = pIOSState->pui8FIFOEnd - pIOSState->pui8FIFOBase;
    377              pIOSState->ui32FifoBaseOffset = psConfig->ui32FIFOBase;
    378          
    379              //
    380              // Initialize the global SRAM buffer
    381              // Total size, which is SRAM Buffer plus the hardware FIFO needs to be
    382              // limited to 1023
    383              //
    384              if ( psConfig->ui32SRAMBufferCap > (AM_HAL_IOS_MAX_SW_FIFO_SIZE - pIOSState->ui32HwFifoSize + 1) )
    385              {
    386                  psConfig->ui32SRAMBufferCap = (AM_HAL_IOS_MAX_SW_FIFO_SIZE - pIOSState->ui32HwFifoSize + 1);
    387              }
    388              am_hal_ios_buffer_init(&g_sSRAMBuffer, psConfig->pui8SRAMBuffer, psConfig->ui32SRAMBufferCap);
    389          
    390              //
    391              // Calculate the value for the IO Slave FIFO configuration register.
    392              //
    393              ui32LRAMConfig  = _VAL2FLD(IOSLAVE_FIFOCFG_ROBASE,   psConfig->ui32ROBase >> 3);
    394              ui32LRAMConfig |= _VAL2FLD(IOSLAVE_FIFOCFG_FIFOBASE, psConfig->ui32FIFOBase >> 3);
    395              ui32LRAMConfig |= _VAL2FLD(IOSLAVE_FIFOCFG_FIFOMAX,  psConfig->ui32RAMBase >> 3);
    396          
    397              //
    398              // Just in case, disable the IOS
    399              //
    400              am_hal_ios_disable(pHandle);
    401          
    402              //
    403              // Write the configuration register with the user's selected interface
    404              // characteristics.
    405              //
    406              IOSLAVEn(ui32Module)->CFG = psConfig->ui32InterfaceSelect;
    407          
    408              //
    409              // Write the FIFO configuration register to set the memory map for the LRAM.
    410              //
    411              IOSLAVEn(ui32Module)->FIFOCFG = ui32LRAMConfig;
    412          
    413              //
    414              // Clear the FIFO State
    415              //
    416              IOSLAVEn(pIOSState->ui32Module)->FIFOCTR_b.FIFOCTR = 0x0;
    417              IOSLAVEn(pIOSState->ui32Module)->FIFOPTR_b.FIFOSIZ = 0x0;
    418              am_hal_ios_fifo_ptr_set(pHandle, pIOSState->ui32FifoBaseOffset);
    419          
    420              //
    421              // Enable the IOS. The following configuration options can't be set while
    422              // the IOS is disabled.
    423              //
    424              am_hal_ios_enable(pHandle);
    425          
    426              //
    427              // Initialize the FIFO pointer to the beginning of the FIFO section.
    428              //
    429              am_hal_ios_fifo_ptr_set(pHandle, psConfig->ui32FIFOBase);
    430          
    431              //
    432              // Write the FIFO threshold register.
    433              //
    434              IOSLAVEn(ui32Module)->FIFOTHR = psConfig->ui32FIFOThreshold;
    435          
    436              return AM_HAL_STATUS_SUCCESS;
    437          } // am_hal_ios_config()
    438          
    439          //*****************************************************************************
    440          //
    441          // IOS enable interrupts function
    442          //
    443          //*****************************************************************************
    444          uint32_t am_hal_ios_interrupt_enable(void *pHandle, uint32_t ui32IntMask)
    445          {
    446              uint32_t ui32Module;
    447          
    448          #ifndef AM_HAL_DISABLE_API_VALIDATION
    449              if (!AM_HAL_IOS_CHK_HANDLE(pHandle))
    450              {
    451                  return AM_HAL_STATUS_INVALID_HANDLE;
    452              }
    453          #endif
    454          
    455              ui32Module = ((am_hal_ios_state_t*)pHandle)->ui32Module;
    456          
    457              //
    458              // OR the desired interrupt into the enable register.
    459              //
    460              IOSLAVEn(ui32Module)->INTEN |= ui32IntMask;
    461          
    462              return AM_HAL_STATUS_SUCCESS;
    463          } // am_hal_ios_int_enable()
    464          
    465          //*****************************************************************************
    466          //
    467          // IOS disable interrupts function
    468          //
    469          //*****************************************************************************
    470          uint32_t am_hal_ios_interrupt_disable(void *pHandle, uint32_t ui32IntMask)
    471          {
    472              uint32_t ui32Module;
    473          
    474          #ifndef AM_HAL_DISABLE_API_VALIDATION
    475              if (!AM_HAL_IOS_CHK_HANDLE(pHandle))
    476              {
    477                  return AM_HAL_STATUS_INVALID_HANDLE;
    478              }
    479          #endif
    480          
    481              ui32Module = ((am_hal_ios_state_t*)pHandle)->ui32Module;
    482          
    483              //
    484              // Clear the desired bit from the interrupt enable register.
    485              //
    486              IOSLAVEn(ui32Module)->INTEN &= ~(ui32IntMask);
    487          
    488              return AM_HAL_STATUS_SUCCESS;
    489          } // am_hal_ios_int_disable()
    490          
    491          //*****************************************************************************
    492          //
    493          // IOS interrupt clear
    494          //
    495          //*****************************************************************************
    496          uint32_t am_hal_ios_interrupt_clear(void *pHandle, uint32_t ui32IntMask)
    497          {
    498              uint32_t ui32Module;
    499          
    500          #ifndef AM_HAL_DISABLE_API_VALIDATION
    501              if (!AM_HAL_IOS_CHK_HANDLE(pHandle))
    502              {
    503                  return AM_HAL_STATUS_INVALID_HANDLE;
    504              }
    505          #endif
    506          
    507              ui32Module = ((am_hal_ios_state_t*)pHandle)->ui32Module;
    508          
    509              //
    510              // Use the interrupt clear register to deactivate the chosen interrupt.
    511              //
    512              IOSLAVEn(ui32Module)->INTCLR = ui32IntMask;
    513          
    514              return AM_HAL_STATUS_SUCCESS;
    515          } // am_hal_ios_int_clear()
    516          
    517          //*****************************************************************************
    518          //
    519          // IOS get interrupt status
    520          //
    521          //*****************************************************************************
    522          uint32_t am_hal_ios_interrupt_status_get(void *pHandle, bool bEnabledOnly,
    523                                                   uint32_t *pui32IntStatus)
    524          {
    525              uint32_t ui32IntStatus = 0;
    526              uint32_t ui32Module;
    527          
    528          #ifndef AM_HAL_DISABLE_API_VALIDATION
    529              if ( !AM_HAL_IOS_CHK_HANDLE(pHandle) )
    530              {
    531                  return AM_HAL_STATUS_INVALID_HANDLE;
    532              }
    533          
    534              if ( !pui32IntStatus )
    535              {
    536                  return AM_HAL_STATUS_INVALID_ARG;
    537              }
    538          #endif
    539          
    540              ui32Module = ((am_hal_ios_state_t*)pHandle)->ui32Module;
    541          
    542              ui32IntStatus = IOSLAVEn(ui32Module)->INTSTAT;
    543          
    544              if ( bEnabledOnly )
    545              {
    546                  ui32IntStatus &= IOSLAVEn(ui32Module)->INTEN;
    547              }
    548          
    549              *pui32IntStatus = ui32IntStatus;
    550          
    551              return AM_HAL_STATUS_SUCCESS;
    552          } // am_hal_ios_int_status_get()
    553          
    554          //*****************************************************************************
    555          //
    556          //! @brief Check the amount of space used in the FIFO
    557          //!
    558          //! @param pui32UsedSpace is bytes used in the Overall FIFO.
    559          //!
    560          //! This function returns the available data in the overall FIFO yet to be
    561          //! read by the host. This takes into account the SRAM buffer and hardware FIFO
    562          //!
    563          //! @return success or error code
    564          //
    565          //*****************************************************************************
    566          uint32_t am_hal_ios_fifo_space_used(void *pHandle, uint32_t *pui32UsedSpace)
    567          {
    568              uint32_t ui32Module;
    569              uint32_t ui32Val = 0;
    570          
    571          #ifndef AM_HAL_DISABLE_API_VALIDATION
    572              if (!AM_HAL_IOS_CHK_HANDLE(pHandle))
    573              {
    574                  return AM_HAL_STATUS_INVALID_HANDLE;
    575              }
    576              if ( !pui32UsedSpace )
    577              {
    578                  return AM_HAL_STATUS_INVALID_ARG;
    579              }
    580          #endif
    581          
    582              ui32Module = ((am_hal_ios_state_t*)pHandle)->ui32Module;
    583          
    584              //
    585              // Start a critical section for thread safety.
    586              //
    587              AM_CRITICAL_BEGIN
    588          
    589              ui32Val = g_sSRAMBuffer.ui32Length;
    590              ui32Val += IOSLAVEn(ui32Module)->FIFOPTR_b.FIFOSIZ;
    591          
    592              //
    593              // End the critical section
    594              //
    595              AM_CRITICAL_END
    596          
    597              *pui32UsedSpace = ui32Val;
    598          
    599              return AM_HAL_STATUS_SUCCESS;
    600          } // am_hal_ios_fifo_space_used()
    601          
    602          //*****************************************************************************
    603          //
    604          //! @brief Check the amount of space left in the FIFO
    605          //!
    606          //! @param pui32LeftSpace is bytes left in the Overall FIFO.
    607          //!
    608          //! This function returns the available space in the overall FIFO to accept
    609          //! new data. This takes into account the SRAM buffer and hardware FIFO
    610          //!
    611          //! @return success or error code
    612          //
    613          //*****************************************************************************
    614          uint32_t am_hal_ios_fifo_space_left(void *pHandle, uint32_t *pui32LeftSpace)
    615          {
    616              uint32_t ui32Module;
    617              uint32_t ui32Val = 0;
    618          
    619          #ifndef AM_HAL_DISABLE_API_VALIDATION
    620              if (!AM_HAL_IOS_CHK_HANDLE(pHandle))
    621              {
    622                  return AM_HAL_STATUS_INVALID_HANDLE;
    623              }
    624              if ( !pui32LeftSpace )
    625              {
    626                  return AM_HAL_STATUS_INVALID_ARG;
    627              }
    628          #endif
    629          
    630              ui32Module = ((am_hal_ios_state_t*)pHandle)->ui32Module;
    631          
    632              //
    633              // Start a critical section for thread safety.
    634              //
    635              AM_CRITICAL_BEGIN
    636          
    637              //
    638              // We waste one byte in HW FIFO
    639              //
    640              ui32Val = g_sSRAMBuffer.ui32Capacity + ((am_hal_ios_state_t*)pHandle)->ui32HwFifoSize - 1;
    641              ui32Val -= g_sSRAMBuffer.ui32Length;
    642              ui32Val -= IOSLAVEn(ui32Module)->FIFOPTR_b.FIFOSIZ;
    643          
    644              //
    645              // End the critical section
    646              //
    647              AM_CRITICAL_END
    648          
    649              *pui32LeftSpace = ui32Val;
    650          
    651              return AM_HAL_STATUS_SUCCESS;
    652          } // am_hal_ios_fifo_space_left()
    653          
    654          //*****************************************************************************
    655          //
    656          //! @brief Check the amount of space left in the hardware FIFO
    657          //!
    658          //! @param pui32LeftSpace is bytes left in the IOS FIFO.
    659          //!
    660          //! This function reads the IOSLAVE FIFOPTR register and determines the amount
    661          //! of space left in the IOS LRAM FIFO.
    662          //!
    663          //! @return success or error code
    664          //
    665          //*****************************************************************************
    666          static uint32_t fifo_space_left(void *pHandle, uint32_t *pui32LeftSpace)
    667          {
    668              uint32_t ui32Module;
    669          
    670          #ifndef AM_HAL_DISABLE_API_VALIDATION
    671              if (!AM_HAL_IOS_CHK_HANDLE(pHandle))
    672              {
    673                  return AM_HAL_STATUS_INVALID_HANDLE;
    674              }
    675              if ( !pui32LeftSpace )
    676              {
    677                  return AM_HAL_STATUS_INVALID_ARG;
    678              }
    679          #endif
    680          
    681              ui32Module = ((am_hal_ios_state_t*)pHandle)->ui32Module;
    682          
    683              //
    684              // We waste one byte in HW FIFO
    685              //
    686              *pui32LeftSpace = ((uint32_t)((am_hal_ios_state_t*)pHandle)->ui32HwFifoSize - IOSLAVEn(ui32Module)->FIFOPTR_b.FIFOSIZ - 1);
    687          
    688              return AM_HAL_STATUS_SUCCESS;
    689          } // fifo_space_left()
    690          
    691          //*****************************************************************************
    692          //
    693          // Helper function for managing IOS FIFO writes.
    694          //
    695          //*****************************************************************************
    696          static void fifo_write(void *pHandle, uint8_t *pui8Data, uint32_t ui32NumBytes)
    697          {
    698              am_hal_ios_state_t *pIOSState = (am_hal_ios_state_t*)pHandle;
    699              uint8_t *pFifoPtr = pIOSState->pui8FIFOPtr;
    700              uint8_t *pFifoBase = pIOSState->pui8FIFOBase;
    701              uint8_t *pFifoEnd = pIOSState->pui8FIFOEnd;
    702          
    703              while ( ui32NumBytes )
    704              {
    705                  //
    706                  // Write the data to the FIFO
    707                  //
    708                  *pFifoPtr++ = *pui8Data++;
    709                  ui32NumBytes--;
    710          
    711                  //
    712                  // Make sure to wrap the FIFO pointer if necessary.
    713                  //
    714                  if ( pFifoPtr == pFifoEnd )
    715                  {
    716                      pFifoPtr = pFifoBase;
    717                  }
    718              }
    719              pIOSState->pui8FIFOPtr = pFifoPtr;
    720          } // fifo_write()
    721          
    722          //*****************************************************************************
    723          //
    724          // IOS interrupt service routine
    725          //
    726          //*****************************************************************************
    727          uint32_t am_hal_ios_interrupt_service(void *pHandle, uint32_t ui32IntMask)
    728          {
    729              uint32_t thresh;
    730              uint32_t freeSpace, usedSpace, chunk1, chunk2, ui32WriteIndex;
    731              uint32_t ui32Module;
    732          
    733          #ifndef AM_HAL_DISABLE_API_VALIDATION
    734              if (!AM_HAL_IOS_CHK_HANDLE(pHandle))
    735              {
    736                  return AM_HAL_STATUS_INVALID_HANDLE;
    737              }
    738          #endif
    739          
    740              ui32Module = ((am_hal_ios_state_t*)pHandle)->ui32Module;
    741          
    742              //
    743              // Check for FIFO size interrupts.
    744              //
    745              if ( ui32IntMask & AM_HAL_IOS_INT_FSIZE )
    746              {
    747                  thresh = IOSLAVEn(ui32Module)->FIFOTHR_b.FIFOTHR;
    748          
    749                  //
    750                  // While the FIFO is at or below threshold Add more data
    751                  // If Fifo level is above threshold, we're guaranteed an FSIZ interrupt
    752                  //
    753                  while ( g_sSRAMBuffer.ui32Length &&
    754                          ((usedSpace = IOSLAVEn(ui32Module)->FIFOPTR_b.FIFOSIZ) <= thresh) )
    755                  {
    756                      //
    757                      // So, we do have some data in SRAM which needs to be moved to FIFO.
    758                      // A chunk of data is a continguous set of bytes in SRAM that can be
    759                      //  written to FIFO. Determine the chunks of data from SRAM that can
    760                      //  be written. Up to two chunks possible
    761                      //
    762                      ui32WriteIndex = g_sSRAMBuffer.ui32WriteIndex;
    763                      chunk1 = ((ui32WriteIndex > (uint32_t)g_sSRAMBuffer.ui32ReadIndex) ?   \
    764                                  (ui32WriteIndex - (uint32_t)g_sSRAMBuffer.ui32ReadIndex) : \
    765                                  (g_sSRAMBuffer.ui32Capacity - (uint32_t)g_sSRAMBuffer.ui32ReadIndex));
    766                      chunk2 = g_sSRAMBuffer.ui32Length - chunk1;
    767                      // We waste one byte in HW FIFO
    768                      freeSpace = ((am_hal_ios_state_t*)pHandle)->ui32HwFifoSize - usedSpace - 1;
    769                      // Write data in chunks
    770                      // Determine the chunks of data from SRAM that can be written
    771                      if ( chunk1 > freeSpace )
    772                      {
    773                          fifo_write(pHandle, (uint8_t *)(g_sSRAMBuffer.pui8Data + g_sSRAMBuffer.ui32ReadIndex), freeSpace);
    774                          //
    775                          // Advance the read index, wrapping if needed.
    776                          //
    777                          g_sSRAMBuffer.ui32ReadIndex += freeSpace;
    778                          // No need to check for wrap as we wrote less than chunk1
    779                          //
    780                          // Adjust the length value to reflect the change.
    781                          //
    782                          g_sSRAMBuffer.ui32Length -= freeSpace;
    783                      }
    784                      else
    785                      {
    786                          fifo_write(pHandle, (uint8_t *)(g_sSRAMBuffer.pui8Data + g_sSRAMBuffer.ui32ReadIndex), chunk1);
    787          
    788                          //
    789                          // Update the read index - wrapping as needed
    790                          //
    791                          g_sSRAMBuffer.ui32ReadIndex += chunk1;
    792                          g_sSRAMBuffer.ui32ReadIndex %= g_sSRAMBuffer.ui32Capacity;
    793                          //
    794                          // Adjust the length value to reflect the change.
    795                          //
    796                          g_sSRAMBuffer.ui32Length -= chunk1;
    797                          freeSpace -= chunk1;
    798          
    799                          if ( freeSpace && chunk2 )
    800                          {
    801                              if ( chunk2 > freeSpace )
    802                              {
    803                                  fifo_write(pHandle, (uint8_t *)(g_sSRAMBuffer.pui8Data + g_sSRAMBuffer.ui32ReadIndex), freeSpace);
    804          
    805                                  //
    806                                  // Advance the read index, wrapping if needed.
    807                                  //
    808                                  g_sSRAMBuffer.ui32ReadIndex += freeSpace;
    809          
    810                                  // No need to check for wrap in chunk2
    811                                  //
    812                                  // Adjust the length value to reflect the change.
    813                                  //
    814                                  g_sSRAMBuffer.ui32Length -= freeSpace;
    815                              }
    816                              else
    817                              {
    818                                  fifo_write(pHandle, (uint8_t *)(g_sSRAMBuffer.pui8Data + g_sSRAMBuffer.ui32ReadIndex), chunk2);
    819                                  //
    820                                  // Advance the read index, wrapping if needed.
    821                                  //
    822                                  g_sSRAMBuffer.ui32ReadIndex += chunk2;
    823          
    824                                  // No need to check for wrap in chunk2
    825                                  //
    826                                  // Adjust the length value to reflect the change.
    827                                  //
    828                                  g_sSRAMBuffer.ui32Length -= chunk2;
    829                              }
    830                          }
    831                      }
    832          
    833                      //
    834                      // Need to retake the FIFO space, after Threshold interrupt has been reenabled
    835                      // Clear any spurious FSIZE interrupt that might have got raised
    836                      //
    837                      IOSLAVEn(ui32Module)->INTCLR_b.FSIZE = 1;
    838                  }
    839              }
    840          
    841              return AM_HAL_STATUS_SUCCESS;
    842          } // am_hal_ios_fifo_service()
    843          
    844          //*****************************************************************************
    845          //
    846          //! @brief Writes the specified number of bytes to the IOS fifo.
    847          //!
    848          //! @param pui8Data is a pointer to the data to be written to the fifo.
    849          //! @param ui32NumBytes is the number of bytes to send.
    850          //! @param pui32WrittenBytes is number of bytes written (could be less than ui32NumBytes, if not enough space)
    851          //!
    852          //! This function will write data from the caller-provided array to the IOS
    853          //! LRAM FIFO. If there is no space in the LRAM FIFO, the data will be copied
    854          //! to a temporary SRAM buffer instead.
    855          //!
    856          //! The maximum message size for the IO Slave is 1023 bytes.
    857          //!
    858          //! @note In order for SRAM copy operations in the function to work correctly,
    859          //! the \e am_hal_ios_buffer_service() function must be called in the ISR for
    860          //! the ioslave module.
    861          //!
    862          //! @return success or error code
    863          //
    864          //*****************************************************************************
    865          uint32_t am_hal_ios_fifo_write(void *pHandle, uint8_t *pui8Data, uint32_t ui32NumBytes, uint32_t *pui32WrittenBytes)
    866          {
    867              uint32_t ui32FIFOSpace = 0;
    868              uint32_t ui32SRAMSpace;
    869              uint32_t ui32SRAMLength;
    870              uint32_t totalBytes = ui32NumBytes;
    871              uint32_t ui32Module;
    872          
    873          #ifndef AM_HAL_DISABLE_API_VALIDATION
    874              if (!AM_HAL_IOS_CHK_HANDLE(pHandle))
    875              {
    876                  return AM_HAL_STATUS_INVALID_HANDLE;
    877              }
    878              if ( !pui8Data || !pui32WrittenBytes)
    879              {
    880                  return AM_HAL_STATUS_INVALID_ARG;
    881              }
    882          #endif
    883          
    884              ui32Module = ((am_hal_ios_state_t*)pHandle)->ui32Module;
    885          
    886              //
    887              // This operation will only work properly if an SRAM buffer has been
    888              // allocated. Make sure that am_hal_ios_fifo_buffer_init() has been called,
    889              // and the buffer pointer looks valid.
    890              //
    891              am_hal_debug_assert(g_sSRAMBuffer.pui8Data != 0);
    892          
    893              if ( ui32NumBytes == 0 )
    894              {
    895                  *pui32WrittenBytes = 0;
    896              }
    897              else
    898              {
    899                  //
    900                  // Start a critical section for thread safety.
    901                  //
    902                  AM_CRITICAL_BEGIN
    903          
    904                  ui32SRAMLength = g_sSRAMBuffer.ui32Length;
    905          
    906                  //
    907                  // End the critical section
    908                  //
    909                  AM_CRITICAL_END
    910          
    911                  //
    912                  // If the SRAM buffer is empty, we should just write directly to the FIFO.
    913                  //
    914                  if ( ui32SRAMLength == 0 )
    915                  {
    916                      fifo_space_left(pHandle, &ui32FIFOSpace);
    917          
    918                      //
    919                      // If the whole message fits, send it now.
    920                      //
    921                      if ( ui32NumBytes <= ui32FIFOSpace )
    922                      {
    923                          fifo_write(pHandle, pui8Data, ui32NumBytes);
    924                          ui32NumBytes = 0;
    925                      }
    926                      else
    927                      {
    928                          fifo_write(pHandle, pui8Data, ui32FIFOSpace);
    929                          ui32NumBytes -= ui32FIFOSpace;
    930                          pui8Data += ui32FIFOSpace;
    931                      }
    932                  }
    933          
    934                  //
    935                  // If there's still data, write it to the SRAM buffer.
    936                  //
    937                  if ( ui32NumBytes )
    938                  {
    939                      uint32_t idx, writeIdx, capacity, fifoSize;
    940                      ui32SRAMSpace = g_sSRAMBuffer.ui32Capacity - ui32SRAMLength;
    941          
    942                      writeIdx = g_sSRAMBuffer.ui32WriteIndex;
    943                      capacity = g_sSRAMBuffer.ui32Capacity;
    944          
    945                      //
    946                      // Make sure that the data will fit inside the SRAM buffer.
    947                      //
    948                      if ( ui32SRAMSpace > ui32NumBytes )
    949                      {
    950                          ui32SRAMSpace = ui32NumBytes;
    951                      }
    952          
    953                      //
    954                      // If the data will fit, write it to the SRAM buffer.
    955                      //
    956                      for ( idx = 0; idx < ui32SRAMSpace; idx++ )
    957                      {
    958                          g_sSRAMBuffer.pui8Data[(idx + writeIdx) % capacity] = pui8Data[idx];
    959                      }
    960          
    961                      ui32NumBytes -= idx;
    962          
    963                      //
    964                      // Start a critical section for thread safety before updating length & wrIdx.
    965                      //
    966                      AM_CRITICAL_BEGIN
    967          
    968                      //
    969                      // Advance the write index, making sure to wrap if necessary.
    970                      //
    971                      g_sSRAMBuffer.ui32WriteIndex = (idx + writeIdx) % capacity;
    972          
    973                      //
    974                      // Update the length value appropriately.
    975                      //
    976                      g_sSRAMBuffer.ui32Length += idx;
    977          
    978                      //
    979                      // End the critical section
    980                      //
    981                      AM_CRITICAL_END
    982          
    983                      // It is possible that there is a race condition that the FIFO level has
    984                      // gone below the threshold by the time we set the wrIdx above, and hence
    985                      // we may never get the threshold interrupt to serve the SRAM data we
    986                      // just wrote
    987          
    988                      // If that is the case, explicitly generate the FSIZE interrupt from here
    989                      fifoSize = IOSLAVEn(ui32Module)->FIFOPTR_b.FIFOSIZ;
    990          
    991                      if ( fifoSize <= IOSLAVEn(ui32Module)->FIFOTHR_b.FIFOTHR )
    992                      {
    993                          IOSLAVEn(ui32Module)->INTSET_b.FSIZE = 1;
    994                      }
    995                  }
    996          
    997                  *pui32WrittenBytes = totalBytes - ui32NumBytes;
    998              }
    999          
   1000              return AM_HAL_STATUS_SUCCESS;
   1001          } // am_hal_ios_fifo_write()
   1002          
   1003          //*****************************************************************************
   1004          //
   1005          //! @brief Sets the IOS FIFO pointer to the specified LRAM offset.
   1006          //!
   1007          //! @param ui32Offset is LRAM offset to set the FIFO pointer to.
   1008          //!
   1009          //! @return success or error code
   1010          //
   1011          //*****************************************************************************
   1012          static uint32_t am_hal_ios_fifo_ptr_set(void *pHandle, uint32_t ui32Offset)
   1013          {
   1014              uint32_t ui32Module;
   1015          
   1016          #ifndef AM_HAL_DISABLE_API_VALIDATION
   1017              if (!AM_HAL_IOS_CHK_HANDLE(pHandle))
   1018              {
   1019                  return AM_HAL_STATUS_INVALID_HANDLE;
   1020              }
   1021          #endif
   1022          
   1023              ui32Module = ((am_hal_ios_state_t*)pHandle)->ui32Module;
   1024          
   1025              //
   1026              // Start a critical section for thread safety.
   1027              //
   1028              AM_CRITICAL_BEGIN
   1029          
   1030              //
   1031              // Set the FIFO Update bit.
   1032              //
   1033              IOSLAVEn(ui32Module)->FUPD = 0x1;
   1034          
   1035              //
   1036              // Change the FIFO offset.
   1037              //
   1038              IOSLAVEn(ui32Module)->FIFOPTR = ui32Offset;
   1039          
   1040              //
   1041              // Clear the FIFO update bit.
   1042              //
   1043              IOSLAVEn(ui32Module)->FUPD = 0x0;
   1044          
   1045              //
   1046              // Set the global FIFO-pointer tracking variable.
   1047              //
   1048              ((am_hal_ios_state_t*)pHandle)->pui8FIFOPtr = (uint8_t *) (REG_IOSLAVE_BASEADDR + ui32Offset);
   1049          
   1050              //
   1051              // End the critical section.
   1052              //
   1053              AM_CRITICAL_END
   1054          
   1055              return AM_HAL_STATUS_SUCCESS;
   1056          } // am_hal_ios_fifo_ptr_set()
   1057          
   1058          //*****************************************************************************
   1059          //
   1060          // Initialize an SRAM buffer for use with the IO Slave.
   1061          //
   1062          //*****************************************************************************
   1063          static void am_hal_ios_buffer_init(am_hal_ios_buffer_t *psBuffer, void *pvArray,
   1064                                             uint32_t ui32Bytes)
   1065          {
   1066              psBuffer->ui32WriteIndex = 0;
   1067              psBuffer->ui32ReadIndex = 0;
   1068              psBuffer->ui32Length = 0;
   1069              psBuffer->ui32Capacity = ui32Bytes;
   1070              psBuffer->pui8Data = (uint8_t *)pvArray;
   1071          } // am_hal_ios_buffer_init()
   1072          
   1073          //*****************************************************************************
   1074          //
   1075          //! @brief IOS control function
   1076          //!
   1077          //! @param handle       - handle for the IOS.
   1078          //! @param eReq         - device specific special request code.
   1079          //! @param pArgs        - pointer to the request specific arguments.
   1080          //!
   1081          //! This function allows advanced settings
   1082          //!
   1083          //! @return success or error code
   1084          //
   1085          //*****************************************************************************
   1086          uint32_t am_hal_ios_control(void *pHandle, am_hal_ios_request_e eReq, void *pArgs)
   1087          {
   1088              am_hal_ios_state_t *pIOSState = (am_hal_ios_state_t*)pHandle;
   1089              uint32_t ui32Val = 0;
   1090          
   1091          #ifndef AM_HAL_DISABLE_API_VALIDATION
   1092              if (!AM_HAL_IOS_CHK_HANDLE(pHandle))
   1093              {
   1094                  return AM_HAL_STATUS_INVALID_HANDLE;
   1095              }
   1096          
   1097              //
   1098              // Validate the parameters
   1099              //
   1100              if ((eReq >= AM_HAL_IOS_REQ_MAX) || ((eReq < AM_HAL_IOS_REQ_ARG_MAX) && (NULL == pArgs)))
   1101              {
   1102                  return AM_HAL_STATUS_INVALID_ARG;
   1103              }
   1104          #endif
   1105          
   1106              switch (eReq)
   1107              {
   1108                  case AM_HAL_IOS_REQ_HOST_INTSET:
   1109                      IOSLAVEn(pIOSState->ui32Module)->IOINTCTL = _VAL2FLD(IOSLAVE_IOINTCTL_IOINTSET, *((uint32_t *)pArgs));
   1110                      break;
   1111                  case AM_HAL_IOS_REQ_HOST_INTCLR:
   1112                      IOSLAVEn(pIOSState->ui32Module)->IOINTCTL = _VAL2FLD(IOSLAVE_IOINTCTL_IOINTCLR, *((uint32_t *)pArgs));
   1113                      break;
   1114                  case AM_HAL_IOS_REQ_HOST_INTGET:
   1115                      *((uint32_t*)pArgs) = IOSLAVEn(pIOSState->ui32Module)->IOINTCTL_b.IOINT;
   1116                      break;
   1117                  case AM_HAL_IOS_REQ_HOST_INTEN_GET:
   1118                      *((uint32_t*)pArgs) = IOSLAVEn(pIOSState->ui32Module)->IOINTCTL_b.IOINTEN;
   1119                      break;
   1120                  case AM_HAL_IOS_REQ_READ_GADATA:
   1121                      *((uint32_t*)pArgs) = IOSLAVEn(pIOSState->ui32Module)->GENADD_b.GADATA;
   1122                      break;
   1123                  case AM_HAL_IOS_REQ_READ_POLL:
   1124                      while ( IOSLAVEn(pIOSState->ui32Module)->FUPD & IOSLAVE_FUPD_IOREAD_Msk );
   1125                      break;
   1126                  case AM_HAL_IOS_REQ_FIFO_UPDATE_CTR:
   1127                      am_hal_ios_fifo_space_used(pHandle, &ui32Val);
   1128                      IOSLAVEn(pIOSState->ui32Module)->FIFOCTR_b.FIFOCTR = ui32Val;
   1129                      break;
   1130                  case AM_HAL_IOS_REQ_FIFO_BUF_CLR:
   1131                      am_hal_ios_buffer_init(&g_sSRAMBuffer, NULL, 0);
   1132                      //
   1133                      // Clear the FIFO State
   1134                      //
   1135                      IOSLAVEn(pIOSState->ui32Module)->FIFOCTR_b.FIFOCTR = 0x0;
   1136                      IOSLAVEn(pIOSState->ui32Module)->FIFOPTR_b.FIFOSIZ = 0x0;
   1137                      break;
   1138                  case AM_HAL_IOS_REQ_MAX:
   1139                      break;
   1140              }
   1141          
   1142              return AM_HAL_STATUS_SUCCESS;
   1143          }
   1144          
   1145          //*****************************************************************************
   1146          //
   1147          //  End the doxygen group
   1148          //! @}
   1149          //
   1150          //*****************************************************************************

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   am_hal_ios_buffer_init
      32   am_hal_ios_configure
        32   -> am_hal_ios_buffer_init
        32   -> am_hal_ios_disable
        32   -> am_hal_ios_enable
        32   -> am_hal_ios_fifo_ptr_set
        32   -> am_hal_pwrctrl_periph_enable
      24   am_hal_ios_control
        24   -> am_hal_ios_buffer_init
        24   -> am_hal_ios_fifo_space_used
       4   am_hal_ios_disable
       4   am_hal_ios_enable
      24   am_hal_ios_fifo_ptr_set
        24   -> am_hal_interrupt_master_disable
        24   -> am_hal_interrupt_master_set
      32   am_hal_ios_fifo_space_left
        32   -> am_hal_interrupt_master_disable
        32   -> am_hal_interrupt_master_set
      32   am_hal_ios_fifo_space_used
        32   -> am_hal_interrupt_master_disable
        32   -> am_hal_interrupt_master_set
      64   am_hal_ios_fifo_write
        64   -> am_hal_debug_error
        64   -> am_hal_interrupt_master_disable
        64   -> am_hal_interrupt_master_set
        64   -> fifo_space_left
        64   -> fifo_write
       8   am_hal_ios_initialize
       0   am_hal_ios_interrupt_clear
       4   am_hal_ios_interrupt_disable
       4   am_hal_ios_interrupt_enable
      48   am_hal_ios_interrupt_service
        48   -> fifo_write
      16   am_hal_ios_interrupt_status_get
      24   am_hal_ios_power_ctrl
        24   -> am_hal_pwrctrl_periph_disable
        24   -> am_hal_pwrctrl_periph_enable
      16   am_hal_ios_uninitialize
        16   -> am_hal_ios_disable
       4   fifo_space_left
      16   fifo_write


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
      84  ?_0
      18  am_hal_ios_buffer_init
     314  am_hal_ios_configure
     342  am_hal_ios_control
      88  am_hal_ios_disable
      88  am_hal_ios_enable
      92  am_hal_ios_fifo_ptr_set
     110  am_hal_ios_fifo_space_left
      94  am_hal_ios_fifo_space_used
     360  am_hal_ios_fifo_write
     122  am_hal_ios_initialize
      44  am_hal_ios_interrupt_clear
      62  am_hal_ios_interrupt_disable
      62  am_hal_ios_interrupt_enable
     398  am_hal_ios_interrupt_service
      82  am_hal_ios_interrupt_status_get
     270  am_hal_ios_power_ctrl
       4  am_hal_ios_pui8LRAM
      56  am_hal_ios_uninitialize
      70  fifo_space_left
      38  fifo_write
      52  g_IOShandles
      20  g_sSRAMBuffer

 
    72 bytes in section .bss
    88 bytes in section .rodata
 2 730 bytes in section .text
 
 2 730 bytes of CODE  memory
    88 bytes of CONST memory
    72 bytes of DATA  memory

Errors: none
Warnings: none
