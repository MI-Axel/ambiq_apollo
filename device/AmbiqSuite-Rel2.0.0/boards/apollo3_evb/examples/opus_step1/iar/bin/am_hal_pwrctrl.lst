###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         12/Mar/2019  10:07:09
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_pwrctrl.c
#    Command line =  
#        -f C:\temp\EW876F.tmp
#        (C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_pwrctrl.c
#        -D iar -D AM_PART_APOLLO3 -D AM_PACKAGE_BGA -lcN
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --diag_suppress Pa050 -o
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\utils\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\ARM\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\AmbiqMicro\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\mcu\apollo3\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\devices\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\bsp\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\sound\
#        -On)
#    Locale       =  C
#    List file    =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_pwrctrl.lst
#    Object file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_pwrctrl.o
#
###############################################################################

C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_pwrctrl.c
      1          //*****************************************************************************
      2          //
      3          //  am_hal_pwrctrl.c
      4          //! @file
      5          //!
      6          //! @brief Functions for enabling and disabling power domains.
      7          //!
      8          //! @addtogroup pwrctrl3 Power Control
      9          //! @ingroup apollo3hal
     10          //! @{
     11          //
     12          //*****************************************************************************
     13          
     14          //*****************************************************************************
     15          //
     16          // Copyright (c) 2019, Ambiq Micro
     17          // All rights reserved.
     18          // 
     19          // Redistribution and use in source and binary forms, with or without
     20          // modification, are permitted provided that the following conditions are met:
     21          // 
     22          // 1. Redistributions of source code must retain the above copyright notice,
     23          // this list of conditions and the following disclaimer.
     24          // 
     25          // 2. Redistributions in binary form must reproduce the above copyright
     26          // notice, this list of conditions and the following disclaimer in the
     27          // documentation and/or other materials provided with the distribution.
     28          // 
     29          // 3. Neither the name of the copyright holder nor the names of its
     30          // contributors may be used to endorse or promote products derived from this
     31          // software without specific prior written permission.
     32          // 
     33          // Third party software included in this distribution is subject to the
     34          // additional license terms as defined in the /docs/licenses directory.
     35          // 
     36          // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     37          // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     38          // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     39          // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     40          // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     41          // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     42          // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     43          // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     44          // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     45          // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     46          // POSSIBILITY OF SUCH DAMAGE.
     47          //
     48          // This is part of revision v2.0.0 of the AmbiqSuite Development Package.
     49          //
     50          //*****************************************************************************
     51          
     52          #include <stdint.h>
     53          #include <stdbool.h>
     54          #include "am_mcu_apollo.h"
     55          
     56          //
     57          // Maximum number of checks to memory power status before declaring error.
     58          //
     59          #define AM_HAL_PWRCTRL_MAX_WFE  20
     60          
     61          //
     62          // Define the peripheral control structure.
     63          //
     64          const struct
     65          {
     66              uint32_t      ui32PeriphEnable;
     67              uint32_t      ui32PeriphStatus;
     68              uint32_t      ui32PeriphEvent;
     69          }
     70          am_hal_pwrctrl_peripheral_control[AM_HAL_PWRCTRL_PERIPH_MAX] =
     71          {
     72              {0, 0, 0},                                  //  AM_HAL_PWRCTRL_PERIPH_NONE
     73              {_VAL2FLD(PWRCTRL_DEVPWREN_PWRIOS, PWRCTRL_DEVPWREN_PWRIOS_EN),
     74               PWRCTRL_DEVPWRSTATUS_HCPA_Msk,
     75               _VAL2FLD(PWRCTRL_DEVPWREVENTEN_HCPAEVEN, PWRCTRL_DEVPWREVENTEN_HCPAEVEN_EN)},  // AM_HAL_PWRCTRL_PERIPH_IOS
     76              {_VAL2FLD(PWRCTRL_DEVPWREN_PWRIOM0, PWRCTRL_DEVPWREN_PWRIOM0_EN),
     77               PWRCTRL_DEVPWRSTATUS_HCPB_Msk,
     78               _VAL2FLD(PWRCTRL_DEVPWREVENTEN_HCPBEVEN, PWRCTRL_DEVPWREVENTEN_HCPBEVEN_EN)},  //  AM_HAL_PWRCTRL_PERIPH_IOM0
     79              {_VAL2FLD(PWRCTRL_DEVPWREN_PWRIOM1, PWRCTRL_DEVPWREN_PWRIOM1_EN),
     80               PWRCTRL_DEVPWRSTATUS_HCPB_Msk,
     81               _VAL2FLD(PWRCTRL_DEVPWREVENTEN_HCPBEVEN, PWRCTRL_DEVPWREVENTEN_HCPBEVEN_EN)},  //  AM_HAL_PWRCTRL_PERIPH_IOM1
     82              {_VAL2FLD(PWRCTRL_DEVPWREN_PWRIOM2, PWRCTRL_DEVPWREN_PWRIOM2_EN),
     83               PWRCTRL_DEVPWRSTATUS_HCPB_Msk,
     84               _VAL2FLD(PWRCTRL_DEVPWREVENTEN_HCPBEVEN, PWRCTRL_DEVPWREVENTEN_HCPBEVEN_EN)},  //  AM_HAL_PWRCTRL_PERIPH_IOM2
     85              {_VAL2FLD(PWRCTRL_DEVPWREN_PWRIOM3, PWRCTRL_DEVPWREN_PWRIOM3_EN),
     86               PWRCTRL_DEVPWRSTATUS_HCPC_Msk,
     87               _VAL2FLD(PWRCTRL_DEVPWREVENTEN_HCPCEVEN, PWRCTRL_DEVPWREVENTEN_HCPCEVEN_EN)},  //  AM_HAL_PWRCTRL_PERIPH_IOM3
     88              {_VAL2FLD(PWRCTRL_DEVPWREN_PWRIOM4, PWRCTRL_DEVPWREN_PWRIOM4_EN),
     89               PWRCTRL_DEVPWRSTATUS_HCPC_Msk,
     90               _VAL2FLD(PWRCTRL_DEVPWREVENTEN_HCPCEVEN, PWRCTRL_DEVPWREVENTEN_HCPCEVEN_EN)},  //  AM_HAL_PWRCTRL_PERIPH_IOM4
     91              {_VAL2FLD(PWRCTRL_DEVPWREN_PWRIOM5, PWRCTRL_DEVPWREN_PWRIOM5_EN),
     92               PWRCTRL_DEVPWRSTATUS_HCPC_Msk,
     93               _VAL2FLD(PWRCTRL_DEVPWREVENTEN_HCPCEVEN, PWRCTRL_DEVPWREVENTEN_HCPCEVEN_EN)},  //  AM_HAL_PWRCTRL_PERIPH_IOM5
     94              {_VAL2FLD(PWRCTRL_DEVPWREN_PWRUART0, PWRCTRL_DEVPWREN_PWRUART0_EN),
     95               PWRCTRL_DEVPWRSTATUS_HCPA_Msk,
     96               _VAL2FLD(PWRCTRL_DEVPWREVENTEN_HCPAEVEN, PWRCTRL_DEVPWREVENTEN_HCPAEVEN_EN)},  //  AM_HAL_PWRCTRL_PERIPH_UART0
     97              {_VAL2FLD(PWRCTRL_DEVPWREN_PWRUART1, PWRCTRL_DEVPWREN_PWRUART1_EN),
     98               PWRCTRL_DEVPWRSTATUS_HCPA_Msk,
     99               _VAL2FLD(PWRCTRL_DEVPWREVENTEN_HCPAEVEN, PWRCTRL_DEVPWREVENTEN_HCPAEVEN_EN)},  //  AM_HAL_PWRCTRL_PERIPH_UART1
    100              {_VAL2FLD(PWRCTRL_DEVPWREN_PWRADC, PWRCTRL_DEVPWREN_PWRADC_EN),
    101               PWRCTRL_DEVPWRSTATUS_PWRADC_Msk,
    102               _VAL2FLD(PWRCTRL_DEVPWREVENTEN_ADCEVEN, PWRCTRL_DEVPWREVENTEN_ADCEVEN_EN)},    //  AM_HAL_PWRCTRL_PERIPH_ADC
    103              {_VAL2FLD(PWRCTRL_DEVPWREN_PWRSCARD, PWRCTRL_DEVPWREN_PWRSCARD_EN),
    104               PWRCTRL_DEVPWRSTATUS_HCPA_Msk,
    105               _VAL2FLD(PWRCTRL_DEVPWREVENTEN_HCPAEVEN, PWRCTRL_DEVPWREVENTEN_HCPAEVEN_EN)},  //  AM_HAL_PWRCTRL_PERIPH_SCARD
    106              {_VAL2FLD(PWRCTRL_DEVPWREN_PWRMSPI, PWRCTRL_DEVPWREN_PWRMSPI_EN),
    107               PWRCTRL_DEVPWRSTATUS_PWRMSPI_Msk,
    108               _VAL2FLD(PWRCTRL_DEVPWREVENTEN_MSPIEVEN, PWRCTRL_DEVPWREVENTEN_MSPIEVEN_EN)},  //  AM_HAL_PWRCTRL_PERIPH_MSPI
    109              {_VAL2FLD(PWRCTRL_DEVPWREN_PWRPDM, PWRCTRL_DEVPWREN_PWRPDM_EN),
    110               PWRCTRL_DEVPWRSTATUS_PWRPDM_Msk,
    111               _VAL2FLD(PWRCTRL_DEVPWREVENTEN_PDMEVEN, PWRCTRL_DEVPWREVENTEN_PDMEVEN_EN)},    //  AM_HAL_PWRCTRL_PERIPH_PDM
    112              {_VAL2FLD(PWRCTRL_DEVPWREN_PWRBLEL, PWRCTRL_DEVPWREN_PWRBLEL_EN),
    113               PWRCTRL_DEVPWRSTATUS_BLEL_Msk,
    114               _VAL2FLD(PWRCTRL_DEVPWREVENTEN_BLELEVEN, PWRCTRL_DEVPWREVENTEN_BLELEVEN_EN)}   //  AM_HAL_PWRCTRL_PERIPH_BLEL
    115          };
    116          
    117          
    118          //
    119          // Define the memory control structure.
    120          //
    121          const struct
    122          {
    123              uint32_t      ui32MemoryEnable;
    124              uint32_t      ui32MemoryStatus;
    125              uint32_t      ui32MemoryEvent;
    126              uint32_t      ui32MemoryMask;
    127              uint32_t      ui32StatusMask;
    128          }
    129          am_hal_pwrctrl_memory_control[AM_HAL_PWRCTRL_MEM_MAX] =
    130          {
    131              {0, 0, 0},
    132              {AM_HAL_PWRCTRL_MEMEN_SRAM_8K_DTCM,
    133               AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_8K_DTCM,
    134               AM_HAL_PWRCTRL_MEMPWREVENTEN_SRAM_8K_DTCM,
    135               AM_HAL_PWRCTRL_MEM_REGION_SRAM_MASK,
    136               AM_HAL_PWRCTRL_MEM_REGION_SRAM_MASK},
    137              {AM_HAL_PWRCTRL_MEMEN_SRAM_32K_DTCM,
    138               AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_32K_DTCM,
    139               AM_HAL_PWRCTRL_MEMPWREVENTEN_SRAM_32K_DTCM,
    140               AM_HAL_PWRCTRL_MEM_REGION_SRAM_MASK,
    141               AM_HAL_PWRCTRL_MEM_REGION_SRAM_MASK},
    142              {AM_HAL_PWRCTRL_MEMEN_SRAM_64K_DTCM,
    143               AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_64K_DTCM,
    144               AM_HAL_PWRCTRL_MEMPWREVENTEN_SRAM_64K_DTCM,
    145               AM_HAL_PWRCTRL_MEM_REGION_SRAM_MASK,
    146               AM_HAL_PWRCTRL_MEM_REGION_SRAM_MASK},
    147              {AM_HAL_PWRCTRL_MEMEN_SRAM_96K,
    148               AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_96K,
    149               AM_HAL_PWRCTRL_MEMPWREVENTEN_SRAM_96K,
    150               AM_HAL_PWRCTRL_MEM_REGION_SRAM_MASK,
    151               AM_HAL_PWRCTRL_MEM_REGION_SRAM_MASK},
    152              {AM_HAL_PWRCTRL_MEMEN_SRAM_128K,
    153               AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_128K,
    154               AM_HAL_PWRCTRL_MEMPWREVENTEN_SRAM_128K,
    155               AM_HAL_PWRCTRL_MEM_REGION_SRAM_MASK,
    156               AM_HAL_PWRCTRL_MEM_REGION_SRAM_MASK},
    157              {AM_HAL_PWRCTRL_MEMEN_SRAM_160K,
    158               AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_160K,
    159               AM_HAL_PWRCTRL_MEMPWREVENTEN_SRAM_160K,
    160               AM_HAL_PWRCTRL_MEM_REGION_SRAM_MASK,
    161               AM_HAL_PWRCTRL_MEM_REGION_SRAM_MASK},
    162              {AM_HAL_PWRCTRL_MEMEN_SRAM_192K,
    163               AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_192K,
    164               AM_HAL_PWRCTRL_MEMPWREVENTEN_SRAM_192K,
    165               AM_HAL_PWRCTRL_MEM_REGION_SRAM_MASK,
    166               AM_HAL_PWRCTRL_MEM_REGION_SRAM_MASK},
    167              {AM_HAL_PWRCTRL_MEMEN_SRAM_224K,
    168               AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_224K,
    169               AM_HAL_PWRCTRL_MEMPWREVENTEN_SRAM_224K,
    170               AM_HAL_PWRCTRL_MEM_REGION_SRAM_MASK,
    171               AM_HAL_PWRCTRL_MEM_REGION_SRAM_MASK},
    172              {AM_HAL_PWRCTRL_MEMEN_SRAM_256K,
    173               AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_256K,
    174               AM_HAL_PWRCTRL_MEMPWREVENTEN_SRAM_256K,
    175               AM_HAL_PWRCTRL_MEM_REGION_SRAM_MASK,
    176               AM_HAL_PWRCTRL_MEM_REGION_SRAM_MASK},
    177              {AM_HAL_PWRCTRL_MEMEN_SRAM_288K,
    178               AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_288K,
    179               AM_HAL_PWRCTRL_MEMPWREVENTEN_SRAM_288K,
    180               AM_HAL_PWRCTRL_MEM_REGION_SRAM_MASK,
    181               AM_HAL_PWRCTRL_MEM_REGION_SRAM_MASK},
    182              {AM_HAL_PWRCTRL_MEMEN_SRAM_320K,
    183               AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_320K,
    184               AM_HAL_PWRCTRL_MEMPWREVENTEN_SRAM_320K,
    185               AM_HAL_PWRCTRL_MEM_REGION_SRAM_MASK,
    186               AM_HAL_PWRCTRL_MEM_REGION_SRAM_MASK},
    187              {AM_HAL_PWRCTRL_MEMEN_SRAM_352K,
    188               AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_352K,
    189               AM_HAL_PWRCTRL_MEMPWREVENTEN_SRAM_352K,
    190               AM_HAL_PWRCTRL_MEM_REGION_SRAM_MASK,
    191               AM_HAL_PWRCTRL_MEM_REGION_SRAM_MASK},
    192              {AM_HAL_PWRCTRL_MEMEN_SRAM_384K,
    193               AM_HAL_PWRCTRL_PWRONSTATUS_SRAM_384K,
    194               AM_HAL_PWRCTRL_MEMPWREVENTEN_SRAM_384K,
    195               AM_HAL_PWRCTRL_MEM_REGION_SRAM_MASK,
    196               AM_HAL_PWRCTRL_MEM_REGION_SRAM_MASK},
    197              {AM_HAL_PWRCTRL_MEMEN_FLASH_512K,
    198               AM_HAL_PWRCTRL_PWRONSTATUS_FLASH_512K,
    199               AM_HAL_PWRCTRL_MEMPWREVENTEN_FLASH_512K,
    200               AM_HAL_PWRCTRL_MEM_REGION_FLASH_MASK,
    201               AM_HAL_PWRCTRL_MEM_REGION_FLASH_MASK},
    202              {AM_HAL_PWRCTRL_MEMEN_FLASH_1M,
    203               AM_HAL_PWRCTRL_PWRONSTATUS_FLASH_1M,
    204               AM_HAL_PWRCTRL_MEMPWREVENTEN_FLASH_1M,
    205               AM_HAL_PWRCTRL_MEM_REGION_FLASH_MASK,
    206               AM_HAL_PWRCTRL_MEM_REGION_FLASH_MASK},
    207              {AM_HAL_PWRCTRL_MEMEN_CACHE,
    208               0,
    209               AM_HAL_PWRCTRL_MEMPWREVENTEN_CACHE,
    210               AM_HAL_PWRCTRL_MEM_REGION_CACHE_MASK,
    211               0},
    212              {AM_HAL_PWRCTRL_MEMEN_ALL,
    213               AM_HAL_PWRCTRL_PWRONSTATUS_ALL,
    214               AM_HAL_PWRCTRL_MEMPWREVENTEN_ALL,
    215               AM_HAL_PWRCTRL_MEM_REGION_ALL_MASK,
    216               AM_HAL_PWRCTRL_MEM_REGION_ALT_ALL_MASK}
    217          };
    218          
    219          // ****************************************************************************
    220          //
    221          //  am_hal_pwrctrl_periph_enable()
    222          //  Enable power for a peripheral.
    223          //
    224          // ****************************************************************************
    225          uint32_t
    226          am_hal_pwrctrl_periph_enable(am_hal_pwrctrl_periph_e ePeripheral)
    227          {
    228          
    229          
    230              //
    231              // Enable power control for the given device.
    232              //
    233              AM_CRITICAL_BEGIN
    234              PWRCTRL->DEVPWREN |= am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphEnable;
    235              AM_CRITICAL_END
    236          
    237          
    238          
    239          
    240              for (uint32_t wait_usecs = 0; wait_usecs < AM_HAL_PWRCTRL_MAX_WFE; wait_usecs += 10)
    241              {
    242                  am_hal_flash_delay(FLASH_CYCLES_US(10));
    243          
    244                  if ( (PWRCTRL->DEVPWRSTATUS & am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphStatus) > 0)
    245                  {
    246                      break;
    247                  }
    248              }
    249          
    250              //
    251              // Check the device status.
    252              //
    253              if ( (PWRCTRL->DEVPWRSTATUS & am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphStatus) > 0 )
    254              {
    255                  return AM_HAL_STATUS_SUCCESS;
    256              }
    257              else
    258              {
    259                  return AM_HAL_STATUS_FAIL;
    260              }
    261          
    262          }
    263          
    264          // ****************************************************************************
    265          //
    266          //  am_hal_pwrctrl_periph_disable()
    267          //  Disable power for a peripheral.
    268          //
    269          // ****************************************************************************
    270          uint32_t
    271          am_hal_pwrctrl_periph_disable(am_hal_pwrctrl_periph_e ePeripheral)
    272          {
    273          
    274              //
    275              // Disable power domain for the given device.
    276              //
    277              AM_CRITICAL_BEGIN
    278              PWRCTRL->DEVPWREN &= ~am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphEnable;
    279              AM_CRITICAL_END
    280          
    281          
    282              for (uint32_t wait_usecs = 0; wait_usecs < AM_HAL_PWRCTRL_MAX_WFE; wait_usecs += 10)
    283              {
    284                  am_hal_flash_delay(FLASH_CYCLES_US(10));
    285          
    286                  if ( (PWRCTRL->DEVPWRSTATUS & am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphStatus) == 0 )
    287                  {
    288                      break;
    289                  }
    290              }
    291          
    292              //
    293              // Check the device status.
    294              //
    295              if ( ( PWRCTRL->DEVPWRSTATUS & am_hal_pwrctrl_peripheral_control[ePeripheral].ui32PeriphStatus) == 0 )
    296              {
    297                  return AM_HAL_STATUS_SUCCESS;
    298              }
    299              else
    300              {
    301                  return AM_HAL_STATUS_FAIL;
    302              }
    303          }
    304          
    305          //*****************************************************************************
    306          //
    307          //! @brief Determine whether a peripheral is currently enabled.
    308          //!
    309          //! @param ePeripheral - The peripheral to enable.
    310          //! @param pui32Enabled - Pointer to a ui32 that will return as 1 or 0.
    311          //!
    312          //! This function determines to the caller whether a given peripheral is
    313          //! currently enabled or disabled.
    314          //!
    315          //! @return status - generic or interface specific status.
    316          //
    317          //*****************************************************************************
    318          uint32_t
    319          am_hal_pwrctrl_periph_enabled(am_hal_pwrctrl_periph_e ePeripheral,
    320                                        uint32_t *pui32Enabled)
    321          {
    322              uint32_t ui32Mask = 0;
    323              uint32_t ui32Enabled = 0;
    324          
    325              if ( pui32Enabled == NULL )
    326              {
    327                  return AM_HAL_STATUS_INVALID_ARG;
    328              }
    329          
    330              switch ( ePeripheral )
    331              {
    332                  case AM_HAL_PWRCTRL_PERIPH_NONE:
    333                  case AM_HAL_PWRCTRL_PERIPH_SCARD:
    334                      break;
    335                  case AM_HAL_PWRCTRL_PERIPH_IOS:
    336                  case AM_HAL_PWRCTRL_PERIPH_UART0:
    337                  case AM_HAL_PWRCTRL_PERIPH_UART1:
    338                      ui32Mask = PWRCTRL_DEVPWRSTATUS_HCPA_Msk;
    339                      break;
    340                  case AM_HAL_PWRCTRL_PERIPH_IOM0:
    341                  case AM_HAL_PWRCTRL_PERIPH_IOM1:
    342                  case AM_HAL_PWRCTRL_PERIPH_IOM2:
    343                      ui32Mask = PWRCTRL_DEVPWRSTATUS_HCPB_Msk;
    344                      break;
    345                  case AM_HAL_PWRCTRL_PERIPH_IOM3:
    346                  case AM_HAL_PWRCTRL_PERIPH_IOM4:
    347                  case AM_HAL_PWRCTRL_PERIPH_IOM5:
    348                      ui32Mask = PWRCTRL_DEVPWRSTATUS_HCPC_Msk;
    349                      break;
    350                  case AM_HAL_PWRCTRL_PERIPH_ADC:
    351                      ui32Mask = PWRCTRL_DEVPWRSTATUS_PWRADC_Msk;
    352                      break;
    353                  case AM_HAL_PWRCTRL_PERIPH_MSPI:
    354                      ui32Mask = PWRCTRL_DEVPWRSTATUS_PWRMSPI_Msk;
    355                      break;
    356                  case AM_HAL_PWRCTRL_PERIPH_PDM:
    357                      ui32Mask = PWRCTRL_DEVPWRSTATUS_PWRPDM_Msk;
    358                      break;
    359                  case AM_HAL_PWRCTRL_PERIPH_BLEL:
    360                      ui32Mask = PWRCTRL_DEVPWRSTATUS_BLEL_Msk;
    361                      break;
    362                  default:
    363                      return AM_HAL_STATUS_FAIL;
    364              }
    365          
    366              if ( ui32Mask != 0 )
    367              {
    368                  ui32Enabled = PWRCTRL->DEVPWRSTATUS & ui32Mask ? 1 : 0;
    369              }
    370          
    371              *pui32Enabled = ui32Enabled;
    372          
    373              return AM_HAL_STATUS_SUCCESS;
    374          }
    375          
    376          
    377          
    378          // ****************************************************************************
    379          //
    380          //  am_hal_pwrctrl_memory_enable()
    381          //  Enable a configuration of memory.
    382          //
    383          // ****************************************************************************
    384          uint32_t
    385          am_hal_pwrctrl_memory_enable(am_hal_pwrctrl_mem_e eMemConfig)
    386          {
    387              uint32_t ui32MemEnMask, ui32MemDisMask, ui32MemRegionMask, ui32MemStatusMask;
    388          
    389              ui32MemEnMask     =  am_hal_pwrctrl_memory_control[eMemConfig].ui32MemoryEnable;
    390              ui32MemDisMask    = ~am_hal_pwrctrl_memory_control[eMemConfig].ui32MemoryEnable;
    391              ui32MemRegionMask = am_hal_pwrctrl_memory_control[eMemConfig].ui32MemoryMask;
    392              ui32MemStatusMask = am_hal_pwrctrl_memory_control[eMemConfig].ui32StatusMask;
    393          
    394              //
    395              // Disable unneeded memory. If nothing to be disabled, skip to save time.
    396              //
    397              // Note that a deliberate disable step using a disable mask is taken here
    398              // for 2 reasons: 1) To only affect the specified type of memory, and 2)
    399              // To avoid inadvertently disabling any memory currently being depended on.
    400              //
    401              if ( ui32MemDisMask != 0 )
    402              {
    403                  PWRCTRL->MEMPWREN &=
    404                      ~(ui32MemDisMask & ui32MemRegionMask)                                   |
    405                       (_VAL2FLD(PWRCTRL_MEMPWREN_DTCM, PWRCTRL_MEMPWREN_DTCM_GROUP0DTCM0)    |
    406                        _VAL2FLD(PWRCTRL_MEMPWREN_FLASH0, PWRCTRL_MEMPWREN_FLASH0_EN));
    407                  am_hal_flash_delay(FLASH_CYCLES_US(1));
    408              }
    409          
    410          
    411              //
    412              // Enable the required memory.
    413              //
    414              if ( ui32MemEnMask != 0 )
    415              {
    416                  PWRCTRL->MEMPWREN |= ui32MemEnMask;
    417          
    418                  for (uint32_t wait_usecs = 0; wait_usecs < AM_HAL_PWRCTRL_MAX_WFE; wait_usecs += 10)
    419                  {
    420                      am_hal_flash_delay(FLASH_CYCLES_US(10));
    421          
    422                      if ( (PWRCTRL->MEMPWRSTATUS & ui32MemStatusMask) ==
    423                            am_hal_pwrctrl_memory_control[eMemConfig].ui32MemoryStatus )
    424                      {
    425                          break;
    426                      }
    427                  }
    428              }
    429          
    430              //
    431              // Return status based on whether the power control memory status has reached the desired state.
    432              //
    433              if ( ( PWRCTRL->MEMPWRSTATUS & ui32MemStatusMask) ==
    434                     am_hal_pwrctrl_memory_control[eMemConfig].ui32MemoryStatus )
    435              {
    436                  return AM_HAL_STATUS_SUCCESS;
    437              }
    438              else
    439              {
    440                  return AM_HAL_STATUS_FAIL;
    441              }
    442          }
    443          
    444          // ****************************************************************************
    445          //
    446          //  am_hal_pwrctrl_low_power_init()
    447          //  Initialize system for low power configuration.
    448          //
    449          // ****************************************************************************
    450          uint32_t
    451          am_hal_pwrctrl_low_power_init(void)
    452          {
    453              uint32_t      ui32Status;
    454          
    455              //
    456              // Take a snapshot of the reset status, if not done already
    457              //
    458              if (!gAmHalResetStatus)
    459              {
    460                  gAmHalResetStatus = RSTGEN->STAT;
    461              }
    462          
    463              //
    464              // Check if the BLE is already enabled.
    465              //
    466              if ( PWRCTRL->DEVPWRSTATUS_b.BLEL == 0)
    467              {
    468                  //
    469                  // First request the BLE feature and check that it was available and acknowledged.
    470                  //
    471                  MCUCTRL->FEATUREENABLE_b.BLEREQ = 1;
    472                  ui32Status = am_hal_flash_delay_status_check(10000,
    473                                  (uint32_t)&MCUCTRL->FEATUREENABLE,
    474                                  (MCUCTRL_FEATUREENABLE_BLEAVAIL_Msk |
    475                                    MCUCTRL_FEATUREENABLE_BLEACK_Msk  |
    476                                    MCUCTRL_FEATUREENABLE_BLEREQ_Msk),
    477                                  (MCUCTRL_FEATUREENABLE_BLEAVAIL_Msk |
    478                                   MCUCTRL_FEATUREENABLE_BLEACK_Msk   |
    479                                   MCUCTRL_FEATUREENABLE_BLEREQ_Msk),
    480                                   true);
    481          
    482                  if (AM_HAL_STATUS_SUCCESS != ui32Status)
    483                  {
    484                      return AM_HAL_STATUS_TIMEOUT;
    485                  }
    486          
    487                  //
    488                  // Next, enable the BLE Buck.
    489                  //
    490                  PWRCTRL->SUPPLYSRC |= _VAL2FLD(PWRCTRL_SUPPLYSRC_BLEBUCKEN,
    491                                                 PWRCTRL_SUPPLYSRC_BLEBUCKEN_EN);
    492          
    493                  //
    494                  // Allow the buck to go to low power mode in BLE sleep.
    495                  //
    496                  PWRCTRL->MISC |= _VAL2FLD(PWRCTRL_MISC_MEMVRLPBLE,
    497                                            PWRCTRL_MISC_MEMVRLPBLE_EN);
    498          
    499                  //
    500                  // Check for Apollo3 A0 Silicon.
    501                  //
    502                  if ( APOLLO3_A0 )
    503                  {
    504                      // Disable SIMO Buck clkdiv because if ble is out of reset then the same bit divides the simobuck clk too agressively.
    505                      MCUCTRL->SIMOBUCK4_b.SIMOBUCKCLKDIVSEL = 0x0;
    506                      MCUCTRL->BLEBUCK2_b.BLEBUCKTONHITRIM   = 0xF;
    507                      MCUCTRL->BLEBUCK2_b.BLEBUCKTONLOWTRIM  = 0xF;
    508                  }
    509              }
    510          
    511              return AM_HAL_STATUS_SUCCESS;
    512          }
    513          
    514          //*****************************************************************************
    515          //
    516          // End Doxygen group.
    517          //! @}
    518          //
    519          //*****************************************************************************

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   am_hal_pwrctrl_low_power_init
        16   -> am_hal_flash_delay_status_check
      40   am_hal_pwrctrl_memory_enable
        40   -> am_hal_flash_delay
      24   am_hal_pwrctrl_periph_disable
        24   -> am_hal_flash_delay
        24   -> am_hal_interrupt_master_disable
        24   -> am_hal_interrupt_master_set
      24   am_hal_pwrctrl_periph_enable
        24   -> am_hal_flash_delay
        24   -> am_hal_interrupt_master_disable
        24   -> am_hal_interrupt_master_set
       4   am_hal_pwrctrl_periph_enabled


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_12
       4  ??DataTable4_13
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
     134  am_hal_pwrctrl_low_power_init
     360  am_hal_pwrctrl_memory_control
     180  am_hal_pwrctrl_memory_enable
     100  am_hal_pwrctrl_periph_disable
     100  am_hal_pwrctrl_periph_enable
     144  am_hal_pwrctrl_periph_enabled
     180  am_hal_pwrctrl_peripheral_control

 
 540 bytes in section .rodata
 714 bytes in section .text
 
 714 bytes of CODE  memory
 540 bytes of CONST memory

Errors: none
Warnings: none
