###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         12/Mar/2019  10:07:07
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_clkgen.c
#    Command line =  
#        -f C:\temp\EW802E.tmp
#        (C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_clkgen.c
#        -D iar -D AM_PART_APOLLO3 -D AM_PACKAGE_BGA -lcN
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --diag_suppress Pa050 -o
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\utils\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\ARM\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\AmbiqMicro\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\mcu\apollo3\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\devices\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\bsp\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\sound\
#        -On)
#    Locale       =  C
#    List file    =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_clkgen.lst
#    Object file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_clkgen.o
#
###############################################################################

C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_clkgen.c
      1          // ****************************************************************************
      2          //
      3          //  am_hal_clkgen.c
      4          //! @file
      5          //!
      6          //! @brief Functions for interfacing with the CLKGEN.
      7          //!
      8          //! @addtogroup clkgen3 Clock Generator (CLKGEN)
      9          //! @ingroup apollo3hal
     10          //! @{
     11          //
     12          // ****************************************************************************
     13          
     14          // ****************************************************************************
     15          //
     16          // Copyright (c) 2019, Ambiq Micro
     17          // All rights reserved.
     18          // 
     19          // Redistribution and use in source and binary forms, with or without
     20          // modification, are permitted provided that the following conditions are met:
     21          // 
     22          // 1. Redistributions of source code must retain the above copyright notice,
     23          // this list of conditions and the following disclaimer.
     24          // 
     25          // 2. Redistributions in binary form must reproduce the above copyright
     26          // notice, this list of conditions and the following disclaimer in the
     27          // documentation and/or other materials provided with the distribution.
     28          // 
     29          // 3. Neither the name of the copyright holder nor the names of its
     30          // contributors may be used to endorse or promote products derived from this
     31          // software without specific prior written permission.
     32          // 
     33          // Third party software included in this distribution is subject to the
     34          // additional license terms as defined in the /docs/licenses directory.
     35          // 
     36          // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     37          // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     38          // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     39          // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     40          // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     41          // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     42          // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     43          // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     44          // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     45          // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     46          // POSSIBILITY OF SUCH DAMAGE.
     47          //
     48          // This is part of revision v2.0.0 of the AmbiqSuite Development Package.
     49          //
     50          // ****************************************************************************
     51          
     52          #include <stdint.h>
     53          #include <stdbool.h>
     54          #include "am_mcu_apollo.h"
     55          
     56          
     57          // ****************************************************************************
     58          //
     59          //  am_hal_clkgen_control()
     60          //      Apply various specific commands/controls on the CLKGEN module.
     61          //
     62          // ****************************************************************************
     63          uint32_t
     64          am_hal_clkgen_control(am_hal_clkgen_control_e eControl, void *pArgs)
     65          {
     66              uint32_t ui32Regval;
     67          
     68              //
     69              // Take a snapshot of the reset status, if not done already
     70              //
     71              if (!gAmHalResetStatus)
     72              {
     73                  gAmHalResetStatus = RSTGEN->STAT;
     74              }
     75          
     76              switch ( eControl )
     77              {
     78                  case AM_HAL_CLKGEN_CONTROL_SYSCLK_MAX:
     79                      //
     80                      // Unlock the clock control register.
     81                      // Set the HFRC divisor to the required operating value.
     82                      // Lock the clock configuration registers.
     83                      //
     84                      CLKGEN->CLKKEY         = CLKGEN_CLKKEY_CLKKEY_Key;
     85                      CLKGEN->CCTRL          = CLKGEN_CCTRL_CORESEL_HFRC;
     86                      CLKGEN->CLKKEY         = 0;
     87                      break;
     88          
     89                  case AM_HAL_CLKGEN_CONTROL_SYSCLK_DIV2:
     90                      CLKGEN->CLKKEY         = CLKGEN_CLKKEY_CLKKEY_Key;
     91                      CLKGEN->CCTRL          = CLKGEN_CCTRL_CORESEL_HFRC_DIV2;
     92                      CLKGEN->CLKKEY         = 0;
     93                      break;
     94          
     95                  case AM_HAL_CLKGEN_CONTROL_LFRC_START:
     96                      CLKGEN->OCTRL         &= ~_VAL2FLD(CLKGEN_OCTRL_STOPRC,
     97                                                         CLKGEN_OCTRL_STOPRC_STOP);
     98                      break;
     99          
    100                  case AM_HAL_CLKGEN_CONTROL_XTAL_START:
    101                      CLKGEN->OCTRL         &= ~_VAL2FLD(CLKGEN_OCTRL_STOPXT,
    102                                                         CLKGEN_OCTRL_STOPXT_STOP);
    103                      break;
    104          
    105                  case AM_HAL_CLKGEN_CONTROL_LFRC_STOP:
    106                      CLKGEN->OCTRL         |= _VAL2FLD(CLKGEN_OCTRL_STOPRC,
    107                                                        CLKGEN_OCTRL_STOPRC_STOP);
    108                      break;
    109          
    110                  case AM_HAL_CLKGEN_CONTROL_XTAL_STOP:
    111                      CLKGEN->OCTRL         |= _VAL2FLD(CLKGEN_OCTRL_STOPXT,
    112                                                        CLKGEN_OCTRL_STOPXT_STOP);
    113                      break;
    114          
    115                  case AM_HAL_CLKGEN_CONTROL_RTC_SEL_LFRC:
    116                      CLKGEN->OCTRL       |= _VAL2FLD(CLKGEN_OCTRL_OSEL,
    117                                                    CLKGEN_OCTRL_OSEL_RTC_LFRC);
    118                      break;
    119          
    120                  case AM_HAL_CLKGEN_CONTROL_RTC_SEL_XTAL:
    121                      CLKGEN->OCTRL       |= _VAL2FLD(CLKGEN_OCTRL_OSEL,
    122                                                    CLKGEN_OCTRL_OSEL_RTC_XT);
    123                      break;
    124          
    125                  case AM_HAL_CLKGEN_CONTROL_HFADJ_ENABLE:
    126                      if ( pArgs == 0 )
    127                      {
    128                          ui32Regval =
    129                              _VAL2FLD(CLKGEN_HFADJ_HFADJGAIN, CLKGEN_HFADJ_HFADJGAIN_Gain_of_1_in_2) |   /* Default value (Apollo3) */
    130                              _VAL2FLD(CLKGEN_HFADJ_HFWARMUP, CLKGEN_HFADJ_HFWARMUP_1SEC)             |   /* Default value */
    131                              _VAL2FLD(CLKGEN_HFADJ_HFXTADJ, 0x5B8)                                   |   /* Default value */
    132                              _VAL2FLD(CLKGEN_HFADJ_HFADJCK, CLKGEN_HFADJ_HFADJCK_4SEC)               |   /* Default value */
    133                              _VAL2FLD(CLKGEN_HFADJ_HFADJEN, CLKGEN_HFADJ_HFADJEN_EN);
    134                      }
    135                      else
    136                      {
    137                          ui32Regval = *(uint32_t*)pArgs;
    138                      }
    139          
    140                      //
    141                      // Make sure the ENABLE bit is set.
    142                      //
    143                      ui32Regval |= _VAL2FLD(CLKGEN_HFADJ_HFADJEN, CLKGEN_HFADJ_HFADJEN_EN);
    144                      CLKGEN->HFADJ = ui32Regval;
    145                      break;
    146          
    147                  case AM_HAL_CLKGEN_CONTROL_HFADJ_DISABLE:
    148                      CLKGEN->HFADJ_b.HFADJEN = 0;
    149                      break;
    150          
    151                  default:
    152                      return AM_HAL_STATUS_INVALID_ARG;
    153              }
    154          
    155              //
    156              // Return success status.
    157              //
    158              return AM_HAL_STATUS_SUCCESS;
    159          
    160          } // am_hal_clkgen_control()
    161          
    162          // ****************************************************************************
    163          //
    164          //  am_hal_clkgen_status_get()
    165          //  This function returns the current value of various CLKGEN statuses.
    166          //
    167          // ****************************************************************************
    168          uint32_t
    169          am_hal_clkgen_status_get(am_hal_clkgen_status_t *psStatus)
    170          {
    171              uint32_t ui32Status;
    172          
    173              if ( psStatus == NULL )
    174              {
    175                  return AM_HAL_STATUS_INVALID_ARG;
    176              }
    177          
    178              psStatus->ui32SysclkFreq =
    179                  CLKGEN->CCTRL_b.CORESEL                     ?
    180                      AM_HAL_CLKGEN_FREQ_MAX_HZ / 2           :
    181                      AM_HAL_CLKGEN_FREQ_MAX_HZ;
    182          
    183              ui32Status = CLKGEN->STATUS;
    184          
    185              psStatus->eRTCOSC =
    186                  _FLD2VAL(CLKGEN_STATUS_OMODE, ui32Status)   ?
    187                      AM_HAL_CLKGEN_STATUS_RTCOSC_LFRC        :
    188                      AM_HAL_CLKGEN_STATUS_RTCOSC_XTAL;
    189          
    190              psStatus->bXtalFailure =
    191                  _FLD2VAL(CLKGEN_STATUS_OSCF, ui32Status);
    192          
    193              return AM_HAL_STATUS_SUCCESS;
    194          
    195          } // am_hal_clkgen_status_get()
    196          
    197          // ****************************************************************************
    198          //
    199          //  am_hal_clkgen_clkout_enable()
    200          //  This function is used to select and enable CLKOUT.
    201          //
    202          // ****************************************************************************
    203          uint32_t
    204          am_hal_clkgen_clkout_enable(bool bEnable, am_hal_clkgen_clkout_e eClkSelect)
    205          {
    206              if ( !bEnable )
    207              {
    208                  CLKGEN->CLKOUT_b.CKEN = 0;
    209              }
    210          
    211              //
    212              // Do a basic validation of the eClkSelect parameter.
    213              // Not every value in the range is valid, but at least this simple check
    214              //  provides a reasonable chance that the parameter is valid.
    215              //
    216              if ( eClkSelect <= (am_hal_clkgen_clkout_e)CLKGEN_CLKOUT_CKSEL_LFRCNE )
    217              {
    218                  //
    219                  // Are we actually changing the frequency?
    220                  //
    221                  if ( CLKGEN->CLKOUT_b.CKSEL != eClkSelect )
    222                  {
    223                      //
    224                      // Disable before changing the clock
    225                      //
    226                      CLKGEN->CLKOUT_b.CKEN = 0;
    227          
    228                      //
    229                      // Set the new clock select
    230                      //
    231                      CLKGEN->CLKOUT_b.CKSEL = eClkSelect;
    232                  }
    233          
    234                  //
    235                  // Enable/disable as requested.
    236                  //
    237                  CLKGEN->CLKOUT_b.CKEN = bEnable;
    238              }
    239              else
    240              {
    241                  return AM_HAL_STATUS_INVALID_ARG;
    242              }
    243          
    244              //
    245              // Return success status.
    246              //
    247              return AM_HAL_STATUS_SUCCESS;
    248          
    249          } // am_hal_clkgen_clkout_enable()
    250          
    251          // ****************************************************************************
    252          //
    253          //  am_hal_clkgen_interrupt_enable()
    254          //  Enable selected CLKGEN Interrupts.
    255          //
    256          // ****************************************************************************
    257          uint32_t am_hal_clkgen_interrupt_enable(am_hal_clkgen_interrupt_e ui32IntMask)
    258          {
    259              if ( (ui32IntMask &
    260                      (CLKGEN_INTRPTEN_OF_Msk         |
    261                       CLKGEN_INTRPTEN_ACC_Msk        |
    262                       CLKGEN_INTRPTEN_ACF_Msk)) == 0 )
    263              {
    264                  return AM_HAL_STATUS_INVALID_ARG;
    265              }
    266          
    267              //
    268              // Set the interrupt enables according to the mask.
    269              //
    270              CLKGEN->INTRPTEN |= ui32IntMask;
    271          
    272              //
    273              // Return success status.
    274              //
    275              return AM_HAL_STATUS_SUCCESS;
    276          
    277          } // am_hal_clkgen_interrupt_enable()
    278          
    279          // ****************************************************************************
    280          //
    281          //  am_hal_clkgen_interrupt_disable(
    282          //  Disable selected CLKGEN Interrupts.
    283          //
    284          // ****************************************************************************
    285          uint32_t
    286          am_hal_clkgen_interrupt_disable(am_hal_clkgen_interrupt_e ui32IntMask)
    287          {
    288              if ( (ui32IntMask &
    289                      (CLKGEN_INTRPTEN_OF_Msk         |
    290                       CLKGEN_INTRPTEN_ACC_Msk        |
    291                       CLKGEN_INTRPTEN_ACF_Msk)) == 0 )
    292              {
    293                  return AM_HAL_STATUS_INVALID_ARG;
    294              }
    295          
    296              //
    297              // Disable the interrupts.
    298              //
    299              CLKGEN->INTRPTEN &= ~ui32IntMask;
    300          
    301              //
    302              // Return success status.
    303              //
    304              return AM_HAL_STATUS_SUCCESS;
    305          
    306          } // am_hal_clkgen_interrupt_disable()
    307          
    308          //*****************************************************************************
    309          //
    310          //  am_hal_clkgen_interrupt_clear()
    311          //  IOM interrupt clear
    312          //
    313          //*****************************************************************************
    314          uint32_t
    315          am_hal_clkgen_interrupt_clear(am_hal_clkgen_interrupt_e ui32IntMask)
    316          {
    317              if ( (ui32IntMask &
    318                      (CLKGEN_INTRPTEN_OF_Msk         |
    319                       CLKGEN_INTRPTEN_ACC_Msk        |
    320                       CLKGEN_INTRPTEN_ACF_Msk)) == 0 )
    321              {
    322                  return AM_HAL_STATUS_INVALID_ARG;
    323              }
    324          
    325              //
    326              // Clear the requested interrupts.
    327              //
    328              CLKGEN->INTRPTCLR = ui32IntMask;
    329          
    330              //
    331              // Return success status.
    332              //
    333              return AM_HAL_STATUS_SUCCESS;
    334          
    335          } // am_hal_clkgen_interrupt_clear()
    336          
    337          // ****************************************************************************
    338          //
    339          //  am_hal_clkgen_interrupt_status_get()
    340          //  Return CLKGEN interrupts.
    341          //
    342          // ****************************************************************************
    343          uint32_t
    344          am_hal_clkgen_interrupt_status_get(bool bEnabledOnly,
    345                                             uint32_t *pui32IntStatus)
    346          {
    347              uint32_t ui32IntStatus;
    348          
    349              if ( !pui32IntStatus )
    350              {
    351                  return AM_HAL_STATUS_INVALID_ARG;
    352              }
    353          
    354              ui32IntStatus = CLKGEN->INTRPTSTAT;
    355          
    356              if ( bEnabledOnly )
    357              {
    358                  ui32IntStatus &= CLKGEN->INTRPTEN;
    359              }
    360          
    361              *pui32IntStatus = ui32IntStatus;
    362          
    363              //
    364              // Return success status.
    365              //
    366              return AM_HAL_STATUS_SUCCESS;
    367          
    368          } // am_hal_clkgen_interrupt_status_get)
    369          
    370          // ****************************************************************************
    371          //
    372          // This function sets the CLKGEN interrupts.
    373          //
    374          // ****************************************************************************
    375          uint32_t
    376          am_hal_clkgen_interrupt_set(am_hal_clkgen_interrupt_e ui32IntMask)
    377          {
    378              if ( (ui32IntMask &
    379                      (CLKGEN_INTRPTEN_OF_Msk         |
    380                       CLKGEN_INTRPTEN_ACC_Msk        |
    381                       CLKGEN_INTRPTEN_ACF_Msk)) == 0 )
    382              {
    383                  return AM_HAL_STATUS_INVALID_ARG;
    384              }
    385          
    386              //
    387              // Set the interrupt status.
    388              //
    389              CLKGEN->INTRPTSET = ui32IntMask;
    390          
    391              //
    392              // Return success status.
    393              //
    394              return AM_HAL_STATUS_SUCCESS;
    395          
    396          } // am_hal_clkgen_interrupt_set()
    397          
    398          
    399          
    400          //*****************************************************************************
    401          //
    402          // End Doxygen group.
    403          //! @}
    404          //
    405          //*****************************************************************************

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   am_hal_clkgen_clkout_enable
       8   am_hal_clkgen_control
       0   am_hal_clkgen_interrupt_clear
       0   am_hal_clkgen_interrupt_disable
       0   am_hal_clkgen_interrupt_enable
       0   am_hal_clkgen_interrupt_set
       0   am_hal_clkgen_interrupt_status_get
       0   am_hal_clkgen_status_get


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_11
       4  ??DataTable7_12
       4  ??DataTable7_13
       4  ??DataTable7_14
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
      88  am_hal_clkgen_clkout_enable
     204  am_hal_clkgen_control
      24  am_hal_clkgen_interrupt_clear
      28  am_hal_clkgen_interrupt_disable
      28  am_hal_clkgen_interrupt_enable
      24  am_hal_clkgen_interrupt_set
      34  am_hal_clkgen_interrupt_status_get
      50  am_hal_clkgen_status_get

 
 540 bytes in section .text
 
 540 bytes of CODE memory

Errors: none
Warnings: none
