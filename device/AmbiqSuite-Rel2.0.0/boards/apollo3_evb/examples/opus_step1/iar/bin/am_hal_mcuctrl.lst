###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         12/Mar/2019  10:07:08
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_mcuctrl.c
#    Command line =  
#        -f C:\temp\EW8569.tmp
#        (C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_mcuctrl.c
#        -D iar -D AM_PART_APOLLO3 -D AM_PACKAGE_BGA -lcN
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --diag_suppress Pa050 -o
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\utils\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\ARM\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\AmbiqMicro\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\mcu\apollo3\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\devices\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\bsp\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\sound\
#        -On)
#    Locale       =  C
#    List file    =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_mcuctrl.lst
#    Object file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_mcuctrl.o
#
###############################################################################

C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_mcuctrl.c
      1          //*****************************************************************************
      2          //
      3          //  am_hal_mcuctrl.c
      4          //! @file
      5          //!
      6          //! @brief Functions for interfacing with the MCUCTRL.
      7          //!
      8          //! @addtogroup mcuctrl3 MCU Control (MCUCTRL)
      9          //! @ingroup apollo3hal
     10          //! @{
     11          //
     12          //*****************************************************************************
     13          
     14          //*****************************************************************************
     15          //
     16          // Copyright (c) 2019, Ambiq Micro
     17          // All rights reserved.
     18          // 
     19          // Redistribution and use in source and binary forms, with or without
     20          // modification, are permitted provided that the following conditions are met:
     21          // 
     22          // 1. Redistributions of source code must retain the above copyright notice,
     23          // this list of conditions and the following disclaimer.
     24          // 
     25          // 2. Redistributions in binary form must reproduce the above copyright
     26          // notice, this list of conditions and the following disclaimer in the
     27          // documentation and/or other materials provided with the distribution.
     28          // 
     29          // 3. Neither the name of the copyright holder nor the names of its
     30          // contributors may be used to endorse or promote products derived from this
     31          // software without specific prior written permission.
     32          // 
     33          // Third party software included in this distribution is subject to the
     34          // additional license terms as defined in the /docs/licenses directory.
     35          // 
     36          // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     37          // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     38          // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     39          // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     40          // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     41          // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     42          // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     43          // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     44          // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     45          // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     46          // POSSIBILITY OF SUCH DAMAGE.
     47          //
     48          // This is part of revision v2.0.0 of the AmbiqSuite Development Package.
     49          //
     50          //*****************************************************************************
     51          
     52          #include <stdint.h>
     53          #include <stdbool.h>
     54          #include "am_mcu_apollo.h"
     55          
     56          //*****************************************************************************
     57          //
     58          // Global Variables.
     59          //
     60          //*****************************************************************************
     61          //
     62          // Define the flash sizes from CHIPPN.
     63          //
     64          const uint32_t
     65          g_am_hal_mcuctrl_flash_size[AM_HAL_MCUCTRL_CHIPPN_FLASH_SIZE_N] =
     66          {
     67               16 * 1024,             /* 0x0 0x00004000   16 KB */
     68               32 * 1024,             /* 0x1 0x00008000   32 KB */
     69               64 * 1024,             /* 0x2 0x00010000   64 KB */
     70              128 * 1024,             /* 0x3 0x00020000  128 KB */
     71              256 * 1024,             /* 0x4 0x00040000  256 KB */
     72              512 * 1024,             /* 0x5 0x00080000  512 KB */
     73                1 * 1024 * 1024,      /* 0x6 0x00100000    1 MB */
     74                2 * 1024 * 1024,      /* 0x7 0x00200000    2 MB */
     75          };
     76          
     77          const uint32_t
     78          g_am_hal_mcuctrl_sram_size[AM_HAL_MCUCTRL_CHIPPN_SRAM_SIZE_N] =
     79          {
     80               16 * 1024,             /* 0x0 0x00004000   16 KB */
     81               32 * 1024,             /* 0x1 0x00008000   32 KB */
     82               64 * 1024,             /* 0x2 0x00010000   64 KB */
     83              128 * 1024,             /* 0x3 0x00020000  128 KB */
     84              256 * 1024,             /* 0x4 0x00040000  256 KB */
     85              512 * 1024,             /* 0x5 0x00080000  512 KB */
     86                1 * 1024 * 1024,      /* 0x6 0x00100000    1 MB */
     87              384 * 1024,             /* 0x7 0x00200000  384 KB */
     88          };
     89          
     90          // ****************************************************************************
     91          //
     92          //  device_info_get()
     93          //  Gets all relevant device information.
     94          //
     95          // ****************************************************************************
     96          static void
     97          device_info_get(am_hal_mcuctrl_device_t *psDevice)
     98          {
     99              //
    100              // Read the Part Number.
    101              //
    102              psDevice->ui32ChipPN = MCUCTRL->CHIPPN;
    103          
    104              //
    105              // Read the Chip ID0.
    106              //
    107              psDevice->ui32ChipID0 = MCUCTRL->CHIPID0;
    108          
    109              //
    110              // Read the Chip ID1.
    111              //
    112              psDevice->ui32ChipID1 = MCUCTRL->CHIPID1;
    113          
    114              //
    115              // Read the Chip Revision.
    116              //
    117              psDevice->ui32ChipRev = MCUCTRL->CHIPREV;
    118          
    119              //
    120              // Read the Chip VENDOR ID.
    121              //
    122              psDevice->ui32VendorID = MCUCTRL->VENDORID;
    123          
    124              //
    125              // Read the SKU (new for Apollo3).
    126              //
    127              psDevice->ui32SKU = MCUCTRL->SKU;
    128          
    129              //
    130              // Qualified from Part Number.
    131              //
    132              psDevice->ui32Qualified = (psDevice->ui32ChipPN >> MCUCTRL_CHIPPN_PARTNUM_QUAL_S) & 0x1;
    133          
    134              //
    135              // Flash size from Part Number.
    136              //
    137              psDevice->ui32FlashSize =
    138                  g_am_hal_mcuctrl_flash_size[
    139                      (psDevice->ui32ChipPN & MCUCTRL_CHIPPN_PARTNUM_FLASHSIZE_M) >>
    140                      MCUCTRL_CHIPPN_PARTNUM_FLASHSIZE_S];
    141          
    142              //
    143              // SRAM size from Part Number.
    144              //
    145              psDevice->ui32SRAMSize =
    146                  g_am_hal_mcuctrl_sram_size[
    147                      (psDevice->ui32ChipPN & MCUCTRL_CHIPPN_PARTNUM_SRAMSIZE_M) >>
    148                       MCUCTRL_CHIPPN_PARTNUM_SRAMSIZE_S];
    149          
    150              //
    151              // Now, let's look at the JEDEC info.
    152              // The full partnumber is 12 bits total, but is scattered across 2 registers.
    153              // Bits [11:8] are 0xE.
    154              // Bits [7:4] are 0xE for Apollo, 0xD for Apollo2.
    155              // Bits [3:0] are defined differently for Apollo and Apollo2.
    156              //   For Apollo, the low nibble is 0x0.
    157              //   For Apollo2, the low nibble indicates flash and SRAM size.
    158              //
    159              psDevice->ui32JedecPN  = JEDEC->PID0_b.PNL8 << 0;
    160              psDevice->ui32JedecPN |= JEDEC->PID1_b.PNH4 << 8;
    161          
    162              //
    163              // JEPID is the JEP-106 Manufacturer ID Code, which is assigned to Ambiq as
    164              //  0x1B, with parity bit is 0x9B.  It is 8 bits located across 2 registers.
    165              //
    166              psDevice->ui32JedecJEPID  = JEDEC->PID1_b.JEPIDL << 0;
    167              psDevice->ui32JedecJEPID |= JEDEC->PID2_b.JEPIDH << 4;
    168          
    169              //
    170              // CHIPREV is 8 bits located across 2 registers.
    171              //
    172              psDevice->ui32JedecCHIPREV  = JEDEC->PID2_b.CHIPREVH4 << 4;
    173              psDevice->ui32JedecCHIPREV |= JEDEC->PID3_b.CHIPREVL4 << 0;
    174          
    175              //
    176              // Let's get the Coresight ID (32-bits across 4 registers)
    177              // For Apollo and Apollo2, it's expected to be 0xB105100D.
    178              //
    179              psDevice->ui32JedecCID  = JEDEC->CID3_b.CID << 24;
    180              psDevice->ui32JedecCID |= JEDEC->CID2_b.CID << 16;
    181              psDevice->ui32JedecCID |= JEDEC->CID1_b.CID <<  8;
    182              psDevice->ui32JedecCID |= JEDEC->CID0_b.CID <<  0;
    183          } // device_info_get()
    184          
    185          //*****************************************************************************
    186          //
    187          //  mcuctrl_fault_status()
    188          //  Gets the fault status and capture registers.
    189          //
    190          //*****************************************************************************
    191          static void
    192          mcuctrl_fault_status(am_hal_mcuctrl_fault_t *psFault)
    193          {
    194              uint32_t ui32FaultStat;
    195          
    196              //
    197              // Read the Fault Status Register.
    198              //
    199              ui32FaultStat = MCUCTRL->FAULTSTATUS;
    200              psFault->bICODE = (bool)(ui32FaultStat & MCUCTRL_FAULTSTATUS_ICODEFAULT_Msk);
    201              psFault->bDCODE = (bool)(ui32FaultStat & MCUCTRL_FAULTSTATUS_DCODEFAULT_Msk);
    202              psFault->bSYS   = (bool)(ui32FaultStat & MCUCTRL_FAULTSTATUS_SYSFAULT_Msk);
    203          
    204              //
    205              // Read the DCODE fault capture address register.
    206              //
    207              psFault->ui32DCODE = MCUCTRL->DCODEFAULTADDR;
    208          
    209              //
    210              // Read the ICODE fault capture address register.
    211              //
    212              psFault->ui32ICODE |= MCUCTRL->ICODEFAULTADDR;
    213          
    214              //
    215              // Read the ICODE fault capture address register.
    216              //
    217              psFault->ui32SYS |= MCUCTRL->SYSFAULTADDR;
    218          } // mcuctrl_fault_status()
    219          
    220          // ****************************************************************************
    221          //
    222          //  am_hal_mcuctrl_control()
    223          //  Apply various specific commands/controls on the MCUCTRL module.
    224          //
    225          // ****************************************************************************
    226          uint32_t
    227          am_hal_mcuctrl_control(am_hal_mcuctrl_control_e eControl, void *pArgs)
    228          {
    229              switch ( eControl )
    230              {
    231                  case AM_HAL_MCUCTRL_CONTROL_FAULT_CAPTURE_ENABLE:
    232                      //
    233                      // Enable the Fault Capture registers.
    234                      //
    235                      MCUCTRL->FAULTCAPTUREEN_b.FAULTCAPTUREEN = 1;
    236                      break;
    237          
    238                  case AM_HAL_MCUCTRL_CONTROL_FAULT_CAPTURE_DISABLE:
    239                      //
    240                      // Disable the Fault Capture registers.
    241                      //
    242                      MCUCTRL->FAULTCAPTUREEN_b.FAULTCAPTUREEN = 0;
    243                      break;
    244          
    245                  case AM_HAL_MCUCTRL_CONTROL_EXTCLK32K_ENABLE:
    246                      //
    247                      // Configure the bits in XTALCTRL that enable external 32KHz clock.
    248                      //
    249                      MCUCTRL->XTALCTRL &=
    250                          ~(MCUCTRL_XTALCTRL_PDNBCMPRXTAL_Msk                 |
    251                            MCUCTRL_XTALCTRL_PDNBCOREXTAL_Msk                 |
    252                            MCUCTRL_XTALCTRL_BYPCMPRXTAL_Msk                  |
    253                            MCUCTRL_XTALCTRL_FDBKDSBLXTAL_Msk                 |
    254                            MCUCTRL_XTALCTRL_XTALSWE_Msk);
    255          
    256                      MCUCTRL->XTALCTRL |=
    257                          (uint32_t)MCUCTRL_XTALCTRL_PDNBCMPRXTAL_PWRDNCOMP   |
    258                          (uint32_t)MCUCTRL_XTALCTRL_PDNBCOREXTAL_PWRDNCORE   |
    259                          (uint32_t)MCUCTRL_XTALCTRL_BYPCMPRXTAL_BYPCOMP      |
    260                          (uint32_t)MCUCTRL_XTALCTRL_FDBKDSBLXTAL_DIS         |
    261                          (uint32_t)MCUCTRL_XTALCTRL_XTALSWE_OVERRIDE_EN;
    262                      break;
    263          
    264                  case AM_HAL_MCUCTRL_CONTROL_EXTCLK32K_DISABLE:
    265                      //
    266                      // Configure the bits in XTALCTRL that disable external 32KHz
    267                      // clock, thus re-configuring for the crystal.
    268                      //
    269                      MCUCTRL->XTALCTRL &=
    270                          ~(MCUCTRL_XTALCTRL_PDNBCMPRXTAL_Msk                 |
    271                            MCUCTRL_XTALCTRL_PDNBCOREXTAL_Msk                 |
    272                            MCUCTRL_XTALCTRL_BYPCMPRXTAL_Msk                  |
    273                            MCUCTRL_XTALCTRL_FDBKDSBLXTAL_Msk                 |
    274                            MCUCTRL_XTALCTRL_XTALSWE_Msk);
    275          
    276                      MCUCTRL->XTALCTRL |=
    277                          (uint32_t)MCUCTRL_XTALCTRL_PDNBCMPRXTAL_PWRUPCOMP   |
    278                          (uint32_t)MCUCTRL_XTALCTRL_PDNBCOREXTAL_PWRUPCORE   |
    279                          (uint32_t)MCUCTRL_XTALCTRL_BYPCMPRXTAL_USECOMP      |
    280                          (uint32_t)MCUCTRL_XTALCTRL_FDBKDSBLXTAL_EN          |
    281                          (uint32_t)MCUCTRL_XTALCTRL_XTALSWE_OVERRIDE_DIS;
    282                      break;
    283          
    284                  default:
    285                      return AM_HAL_STATUS_INVALID_ARG;
    286              }
    287          
    288              //
    289              // Return success status.
    290              //
    291              return AM_HAL_STATUS_SUCCESS;
    292          
    293          } // am_hal_mcuctrl_control()
    294          
    295          // ****************************************************************************
    296          //
    297          //  am_hal_mcuctrl_status_get()
    298          //! This function returns  current status of the MCUCTRL as obtained from
    299          //! various registers of the MCUCTRL block.
    300          //
    301          // ****************************************************************************
    302          uint32_t
    303          am_hal_mcuctrl_status_get(am_hal_mcuctrl_status_t *psStatus)
    304          {
    305              uint32_t ui32Status;
    306          
    307              if ( psStatus == NULL )
    308              {
    309                  return AM_HAL_STATUS_INVALID_ARG;
    310              }
    311          
    312              ui32Status = MCUCTRL->FEATUREENABLE;
    313              psStatus->bBurstAck =
    314                  _FLD2VAL(MCUCTRL_FEATUREENABLE_BURSTACK, ui32Status);
    315              psStatus->bBLEAck =
    316                  _FLD2VAL(MCUCTRL_FEATUREENABLE_BLEACK, ui32Status);
    317          
    318              psStatus->bDebuggerLockout =
    319                  _FLD2VAL(MCUCTRL_DEBUGGER_LOCKOUT, MCUCTRL->DEBUGGER);
    320          
    321              psStatus->bADCcalibrated =
    322                  _FLD2VAL(MCUCTRL_ADCCAL_ADCCALIBRATED, MCUCTRL->ADCCAL);
    323          
    324              psStatus->bBattLoadEnabled =
    325                  _FLD2VAL(MCUCTRL_ADCBATTLOAD_BATTLOAD, MCUCTRL->ADCBATTLOAD);
    326          
    327              ui32Status = MCUCTRL->BOOTLOADER;
    328              psStatus->bSecBootOnColdRst =
    329                  _FLD2VAL(MCUCTRL_BOOTLOADER_SECBOOT, ui32Status);
    330              psStatus->bSecBootOnWarmRst =
    331                  _FLD2VAL(MCUCTRL_BOOTLOADER_SECBOOTONRST, ui32Status);
    332          
    333              return AM_HAL_STATUS_SUCCESS;
    334          
    335          } // am_hal_mcuctrl_status_get()
    336          
    337          // ****************************************************************************
    338          //
    339          //  am_hal_mcuctrl_info_get()
    340          //  Get information of the given MCUCTRL item.
    341          //
    342          // ****************************************************************************
    343          uint32_t
    344          am_hal_mcuctrl_info_get(am_hal_mcuctrl_infoget_e eInfoGet, void *pInfo)
    345          {
    346              am_hal_mcuctrl_feature_t *psFeature;
    347              uint32_t ui32Feature;
    348          
    349              if ( pInfo == NULL )
    350              {
    351                  return AM_HAL_STATUS_INVALID_ARG;
    352              }
    353          
    354              switch ( eInfoGet )
    355              {
    356                  case AM_HAL_MCUCTRL_INFO_FEATURES_AVAIL:
    357                      psFeature = (am_hal_mcuctrl_feature_t*)pInfo;
    358                      ui32Feature = MCUCTRL->FEATUREENABLE;
    359                      psFeature->bBurstAvail =
    360                          _FLD2VAL(MCUCTRL_FEATUREENABLE_BURSTAVAIL, ui32Feature);
    361                      psFeature->bBLEavail =
    362                          _FLD2VAL(MCUCTRL_FEATUREENABLE_BLEAVAIL, ui32Feature);
    363          
    364                      ui32Feature = MCUCTRL->BOOTLOADER;
    365                      psFeature->ui8SecBootFeature =
    366                          _FLD2VAL(MCUCTRL_BOOTLOADER_SECBOOTFEATURE, ui32Feature);
    367          
    368                      ui32Feature = MCUCTRL->SKU;
    369                      psFeature->bBLEFeature =
    370                          _FLD2VAL(MCUCTRL_SKU_ALLOWBLE, ui32Feature);
    371                      psFeature->bBurstFeature =
    372                          _FLD2VAL(MCUCTRL_SKU_ALLOWBURST, ui32Feature);
    373                      break;
    374          
    375                  case AM_HAL_MCUCTRL_INFO_DEVICEID:
    376                      device_info_get((am_hal_mcuctrl_device_t *)pInfo);
    377                      break;
    378          
    379                  case AM_HAL_MCUCTRL_INFO_FAULT_STATUS:
    380                      mcuctrl_fault_status((am_hal_mcuctrl_fault_t*)pInfo);
    381                      break;
    382          
    383                  default:
    384                      return AM_HAL_STATUS_INVALID_ARG;
    385              }
    386              //
    387              // Return success status.
    388              //
    389              return AM_HAL_STATUS_SUCCESS;
    390          
    391          } // am_hal_mcuctrl_info_get()
    392          
    393          //*****************************************************************************
    394          //
    395          // End Doxygen group.
    396          //! @}
    397          //
    398          //*****************************************************************************

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   am_hal_mcuctrl_control
      24   am_hal_mcuctrl_info_get
        24   -> device_info_get
        24   -> mcuctrl_fault_status
       0   am_hal_mcuctrl_status_get
       0   device_info_get
       0   mcuctrl_fault_status


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_12
       4  ??DataTable4_13
       4  ??DataTable4_14
       4  ??DataTable4_15
       4  ??DataTable4_16
       4  ??DataTable4_17
       4  ??DataTable4_18
       4  ??DataTable4_19
       4  ??DataTable4_2
       4  ??DataTable4_20
       4  ??DataTable4_21
       4  ??DataTable4_22
       4  ??DataTable4_23
       4  ??DataTable4_24
       4  ??DataTable4_25
       4  ??DataTable4_26
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
      94  am_hal_mcuctrl_control
     118  am_hal_mcuctrl_info_get
      90  am_hal_mcuctrl_status_get
     202  device_info_get
      64  g_am_hal_mcuctrl_flash_size
      64  g_am_hal_mcuctrl_sram_size
      58  mcuctrl_fault_status

 
 128 bytes in section .rodata
 670 bytes in section .text
 
 670 bytes of CODE  memory
 128 bytes of CONST memory

Errors: none
Warnings: none
