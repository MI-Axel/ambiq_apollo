###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         12/Mar/2019  10:07:09
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_reset.c
#    Command line =  
#        -f C:\temp\EW8946.tmp
#        (C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_reset.c
#        -D iar -D AM_PART_APOLLO3 -D AM_PACKAGE_BGA -lcN
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --diag_suppress Pa050 -o
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\utils\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\ARM\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\AmbiqMicro\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\mcu\apollo3\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\devices\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\bsp\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\sound\
#        -On)
#    Locale       =  C
#    List file    =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_reset.lst
#    Object file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_reset.o
#
###############################################################################

C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_reset.c
      1          //*****************************************************************************
      2          //
      3          //  am_hal_reset.c
      4          //! @file
      5          //!
      6          //! @brief Hardware abstraction layer for the Reset Generator module.
      7          //!
      8          //! @addtogroup rstgen2 Reset Generator (RSTGEN)
      9          //! @ingroup apollo2hal
     10          //! @{
     11          //
     12          //*****************************************************************************
     13          
     14          //*****************************************************************************
     15          //
     16          // Copyright (c) 2019, Ambiq Micro
     17          // All rights reserved.
     18          // 
     19          // Redistribution and use in source and binary forms, with or without
     20          // modification, are permitted provided that the following conditions are met:
     21          // 
     22          // 1. Redistributions of source code must retain the above copyright notice,
     23          // this list of conditions and the following disclaimer.
     24          // 
     25          // 2. Redistributions in binary form must reproduce the above copyright
     26          // notice, this list of conditions and the following disclaimer in the
     27          // documentation and/or other materials provided with the distribution.
     28          // 
     29          // 3. Neither the name of the copyright holder nor the names of its
     30          // contributors may be used to endorse or promote products derived from this
     31          // software without specific prior written permission.
     32          // 
     33          // Third party software included in this distribution is subject to the
     34          // additional license terms as defined in the /docs/licenses directory.
     35          // 
     36          // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     37          // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     38          // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     39          // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     40          // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     41          // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     42          // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     43          // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     44          // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     45          // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     46          // POSSIBILITY OF SUCH DAMAGE.
     47          //
     48          // This is part of revision v2.0.0 of the AmbiqSuite Development Package.
     49          //
     50          //*****************************************************************************
     51          
     52          #include "am_mcu_apollo.h"
     53          
     54          uint32_t gAmHalResetStatus = 0;
     55          
     56          //*****************************************************************************
     57          //
     58          //  am_hal_reset_enable()
     59          //  Enable and configure the Reset controller.
     60          //
     61          //*****************************************************************************
     62          uint32_t
     63          am_hal_reset_configure(am_hal_reset_configure_e eConfigure)
     64          {
     65              uint32_t ui32Val;
     66              bool     bEnable;
     67          
     68              switch ( eConfigure )
     69              {
     70                  case AM_HAL_RESET_BROWNOUT_HIGH_ENABLE:
     71                      bEnable = true;
     72                      ui32Val = RSTGEN_CFG_BODHREN_Msk;
     73                      break;
     74          
     75                  case AM_HAL_RESET_WDT_RESET_ENABLE:
     76                      bEnable = true;
     77                      ui32Val = RSTGEN_CFG_WDREN_Msk;
     78                      break;
     79          
     80                  case AM_HAL_RESET_BROWNOUT_HIGH_DISABLE:
     81                      bEnable = false;
     82                      ui32Val = RSTGEN_CFG_BODHREN_Msk;
     83                      break;
     84          
     85                  case AM_HAL_RESET_WDT_RESET_DISABLE:
     86                      bEnable = false;
     87                      ui32Val = RSTGEN_CFG_WDREN_Msk;
     88                      break;
     89          
     90                  default:
     91                      return AM_HAL_STATUS_INVALID_ARG;
     92              }
     93          
     94              AM_CRITICAL_BEGIN
     95              if ( bEnable )
     96              {
     97                  RSTGEN->CFG |= ui32Val;
     98              }
     99              else
    100              {
    101                  RSTGEN->CFG &= ~ui32Val;
    102              }
    103              AM_CRITICAL_END
    104          
    105              //
    106              // Return success status.
    107              //
    108              return AM_HAL_STATUS_SUCCESS;
    109          
    110          } // am_hal_reset_configure()
    111          
    112          
    113          //*****************************************************************************
    114          //
    115          //  am_hal_reset_control()
    116          //  Perform various reset functions including assertion of software resets.
    117          //
    118          //*****************************************************************************
    119          uint32_t
    120          am_hal_reset_control(am_hal_reset_control_e eControl, void *pArgs)
    121          {
    122              switch ( eControl )
    123              {
    124                  case AM_HAL_RESET_CONTROL_SWPOR:
    125                      //
    126                      // Perform a Power On Reset level reset.
    127                      // Write the POR key to the software POR register.
    128                      //
    129                      RSTGEN->SWPOR =
    130                             _VAL2FLD(RSTGEN_SWPOR_SWPORKEY, RSTGEN_SWPOR_SWPORKEY_KEYVALUE);
    131                      break;
    132          
    133                  case AM_HAL_RESET_CONTROL_SWPOI:
    134                      //
    135                      // Perform a Power On Initialization level reset.
    136                      // Write the POI key to the software POI register.
    137                      //
    138                      RSTGEN->SWPOI =
    139                          _VAL2FLD(RSTGEN_SWPOI_SWPOIKEY, RSTGEN_SWPOI_SWPOIKEY_KEYVALUE);
    140                      break;
    141          
    142                  case AM_HAL_RESET_CONTROL_STATUSCLEAR:
    143                      //
    144                      // Clear ALL of the reset status register bits.
    145                      //
    146                      RSTGEN->STAT = 0;
    147                      break;
    148          
    149                  case AM_HAL_RESET_CONTROL_TPIU_RESET:
    150                      //
    151                      // Reset the TPIU.
    152                      //
    153                      RSTGEN->TPIURST = _VAL2FLD(RSTGEN_TPIURST_TPIURST, 1);
    154                      break;
    155          
    156                  default:
    157                      return AM_HAL_STATUS_INVALID_ARG;
    158              }
    159          
    160              //
    161              // Return success status.
    162              //
    163              return AM_HAL_STATUS_SUCCESS;
    164          
    165          } // am_hal_reset_control()
    166          
    167          
    168          //*****************************************************************************
    169          //
    170          //  am_hal_reset_status_get()
    171          //  Return status of the reset generator.
    172          //  Application MUST call this API at least once before going to deepsleep
    173          //  Otherwise this API will not provide correct reset status
    174          //
    175          //*****************************************************************************
    176          uint32_t
    177          am_hal_reset_status_get(am_hal_reset_status_t *psStatus)
    178          {
    179              // Need to read the status only the very first time
    180          
    181              if ( psStatus == NULL )
    182              {
    183                  return AM_HAL_STATUS_INVALID_ARG;
    184              }
    185          
    186              //
    187              // Retrieve the reset generator status bits
    188              //
    189              if (!gAmHalResetStatus)
    190              {
    191                  gAmHalResetStatus = RSTGEN->STAT;
    192              }
    193              psStatus->eStatus      = (am_hal_reset_status_e)gAmHalResetStatus;
    194              psStatus->bEXTStat     = _FLD2VAL(RSTGEN_STAT_EXRSTAT, gAmHalResetStatus);
    195              psStatus->bPORStat     = _FLD2VAL(RSTGEN_STAT_PORSTAT, gAmHalResetStatus);
    196              psStatus->bBODStat     = _FLD2VAL(RSTGEN_STAT_BORSTAT, gAmHalResetStatus);
    197              psStatus->bSWPORStat   = _FLD2VAL(RSTGEN_STAT_SWRSTAT, gAmHalResetStatus);
    198              psStatus->bSWPOIStat   = _FLD2VAL(RSTGEN_STAT_POIRSTAT, gAmHalResetStatus);
    199              psStatus->bDBGRStat    = _FLD2VAL(RSTGEN_STAT_DBGRSTAT, gAmHalResetStatus);
    200              psStatus->bWDTStat     = _FLD2VAL(RSTGEN_STAT_WDRSTAT, gAmHalResetStatus);
    201              psStatus->bBOUnregStat = _FLD2VAL(RSTGEN_STAT_BOUSTAT, gAmHalResetStatus);
    202              psStatus->bBOCOREStat  = _FLD2VAL(RSTGEN_STAT_BOCSTAT, gAmHalResetStatus);
    203              psStatus->bBOMEMStat   = _FLD2VAL(RSTGEN_STAT_BOFSTAT, gAmHalResetStatus);
    204              psStatus->bBOBLEStat   = _FLD2VAL(RSTGEN_STAT_BOBSTAT, gAmHalResetStatus);
    205          
    206              //
    207              // Return status.
    208              // If the Reset Status is 0 - this implies application did not capture the snapshot
    209              // before deepsleep, and hence the result is invalid
    210              //
    211              return (gAmHalResetStatus ? AM_HAL_STATUS_SUCCESS : AM_HAL_STATUS_FAIL);
    212          
    213          } // am_hal_reset_status_get()
    214          
    215          //*****************************************************************************
    216          //
    217          //! @brief Enable selected RSTGEN Interrupts.
    218          //!
    219          //! Use this function to enable the reset generator interrupts.
    220          //!
    221          //! @param ui32IntMask - One or more of the following bits, any of which can
    222          //! be ORed together.
    223          //!   AM_HAL_RESET_INTERRUPT_BODH
    224          //!
    225          //! @return status      - generic or interface specific status.
    226          //
    227          //*****************************************************************************
    228          uint32_t
    229          am_hal_reset_interrupt_enable(uint32_t ui32IntMask)
    230          {
    231              AM_CRITICAL_BEGIN
    232              RSTGEN->INTEN |= ui32IntMask;
    233              AM_CRITICAL_END
    234          
    235              //
    236              // Return success status.
    237              //
    238              return AM_HAL_STATUS_SUCCESS;
    239          
    240          } // am_hal_reset_interrupt_enable()
    241          
    242          //*****************************************************************************
    243          //
    244          //  am_hal_reset_interrupt_disable()
    245          //  Disable selected RSTGEN Interrupts.
    246          //
    247          //*****************************************************************************
    248          uint32_t
    249          am_hal_reset_interrupt_disable(uint32_t ui32IntMask)
    250          {
    251              AM_CRITICAL_BEGIN
    252              RSTGEN->INTEN &= ~ui32IntMask;
    253              AM_CRITICAL_END
    254          
    255              //
    256              // Return success status.
    257              //
    258              return AM_HAL_STATUS_SUCCESS;
    259          
    260          } // am_hal_reset_interrupt_disable()
    261          
    262          //*****************************************************************************
    263          //
    264          //  am_hal_reset_interrupt_clear()
    265          //  Reset generator interrupt clear
    266          //
    267          //*****************************************************************************
    268          uint32_t
    269          am_hal_reset_interrupt_clear(uint32_t ui32IntMask)
    270          {
    271              RSTGEN->INTEN = ui32IntMask;
    272          
    273              //
    274              // Return success status.
    275              //
    276              return AM_HAL_STATUS_SUCCESS;
    277          
    278          } // am_hal_reset_interrupt_clear()
    279          
    280          //*****************************************************************************
    281          //
    282          //  am_hal_reset_interrupt_status_get()
    283          //  Get interrupt status of reset generator.
    284          //
    285          //*****************************************************************************
    286          uint32_t
    287          am_hal_reset_interrupt_status_get(bool bEnabledOnly,
    288                                            uint32_t *pui32IntStatus)
    289          {
    290              if ( pui32IntStatus == NULL )
    291              {
    292                  return AM_HAL_STATUS_INVALID_ARG;
    293              }
    294          
    295              //
    296              // Retrieve the reset generator status bits
    297              //
    298              *pui32IntStatus = RSTGEN->INTSTAT;
    299          
    300              //
    301              // Return success status.
    302              //
    303              return AM_HAL_STATUS_SUCCESS;
    304          
    305          } // am_hal_reset_interrupt_status_get()
    306          
    307          
    308          //*****************************************************************************
    309          //
    310          // End Doxygen group.
    311          //! @}
    312          //
    313          //*****************************************************************************

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   am_hal_reset_configure
        24   -> am_hal_interrupt_master_disable
        24   -> am_hal_interrupt_master_set
       0   am_hal_reset_control
       0   am_hal_reset_interrupt_clear
      16   am_hal_reset_interrupt_disable
        16   -> am_hal_interrupt_master_disable
        16   -> am_hal_interrupt_master_set
      16   am_hal_reset_interrupt_enable
        16   -> am_hal_interrupt_master_disable
        16   -> am_hal_interrupt_master_set
       0   am_hal_reset_interrupt_status_get
       0   am_hal_reset_status_get


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
      98  am_hal_reset_configure
      62  am_hal_reset_control
      10  am_hal_reset_interrupt_clear
      28  am_hal_reset_interrupt_disable
      28  am_hal_reset_interrupt_enable
      20  am_hal_reset_interrupt_status_get
     150  am_hal_reset_status_get
       4  gAmHalResetStatus

 
   4 bytes in section .bss
 424 bytes in section .text
 
 424 bytes of CODE memory
   4 bytes of DATA memory

Errors: none
Warnings: none
