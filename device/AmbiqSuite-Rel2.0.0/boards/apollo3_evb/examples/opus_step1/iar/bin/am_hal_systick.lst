###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         12/Mar/2019  10:07:10
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_systick.c
#    Command line =  
#        -f C:\temp\EW8BCC.tmp
#        (C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_systick.c
#        -D iar -D AM_PART_APOLLO3 -D AM_PACKAGE_BGA -lcN
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --diag_suppress Pa050 -o
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\utils\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\ARM\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\AmbiqMicro\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\mcu\apollo3\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\devices\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\bsp\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\sound\
#        -On)
#    Locale       =  C
#    List file    =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_systick.lst
#    Object file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_systick.o
#
###############################################################################

C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_systick.c
      1          //*****************************************************************************
      2          //
      3          //  am_hal_systick.c
      4          //! @file
      5          //!
      6          //! @brief Functions for interfacing with the SYSTICK
      7          //!
      8          //! @addtogroup systick3 System Timer (SYSTICK)
      9          //! @ingroup apollo3hal
     10          //! @{
     11          //
     12          //*****************************************************************************
     13          
     14          //*****************************************************************************
     15          //
     16          // Copyright (c) 2019, Ambiq Micro
     17          // All rights reserved.
     18          // 
     19          // Redistribution and use in source and binary forms, with or without
     20          // modification, are permitted provided that the following conditions are met:
     21          // 
     22          // 1. Redistributions of source code must retain the above copyright notice,
     23          // this list of conditions and the following disclaimer.
     24          // 
     25          // 2. Redistributions in binary form must reproduce the above copyright
     26          // notice, this list of conditions and the following disclaimer in the
     27          // documentation and/or other materials provided with the distribution.
     28          // 
     29          // 3. Neither the name of the copyright holder nor the names of its
     30          // contributors may be used to endorse or promote products derived from this
     31          // software without specific prior written permission.
     32          // 
     33          // Third party software included in this distribution is subject to the
     34          // additional license terms as defined in the /docs/licenses directory.
     35          // 
     36          // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     37          // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     38          // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     39          // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     40          // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     41          // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     42          // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     43          // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     44          // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     45          // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     46          // POSSIBILITY OF SUCH DAMAGE.
     47          //
     48          // This is part of revision v2.0.0 of the AmbiqSuite Development Package.
     49          //
     50          //*****************************************************************************
     51          
     52          #include <stdint.h>
     53          #include <stdbool.h>
     54          #include "am_mcu_apollo.h"
     55          
     56          
     57          //*****************************************************************************
     58          //
     59          // Macro definitions
     60          //
     61          //*****************************************************************************
     62          #define SYSTICK_MAX_TICKS   ((1 << 24)-1)
     63          #define MAX_U32             (0xffffffff)
     64          
     65          //*****************************************************************************
     66          //
     67          //! @brief Start the SYSTICK.
     68          //!
     69          //! This function starts the systick timer.
     70          //!
     71          //! @note This timer does not run in deep-sleep mode as it runs from the core
     72          //! clock, which is gated in deep-sleep. If a timer is needed in deep-sleep use
     73          //! one of the ctimers instead. Also to note is this timer will consume higher
     74          //! power than the ctimers.
     75          //!
     76          //! @return None.
     77          //
     78          //*****************************************************************************
     79          void
     80          am_hal_systick_start(void)
     81          {
     82              //
     83              // Start the systick timer.
     84              //
     85              SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk;
     86          }
     87          
     88          //*****************************************************************************
     89          //
     90          //! @brief Stop the SYSTICK.
     91          //!
     92          //! This function stops the systick timer.
     93          //!
     94          //! @note This timer does not run in deep-sleep mode as it runs from the core
     95          //! clock, which is gated in deep-sleep. If a timer is needed in deep-sleep use
     96          //! one of the ctimers instead. Also to note is this timer will consume higher
     97          //! power than the ctimers.
     98          //!
     99          //! @return None.
    100          //
    101          //*****************************************************************************
    102          void
    103          am_hal_systick_stop(void)
    104          {
    105              //
    106              // Stop the systick timer.
    107              //
    108              SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
    109          }
    110          
    111          //*****************************************************************************
    112          //
    113          //! @brief Enable the interrupt in the SYSTICK.
    114          //!
    115          //! This function enables the interupt in the systick timer.
    116          //!
    117          //! @return None.
    118          //
    119          //*****************************************************************************
    120          void
    121          am_hal_systick_int_enable(void)
    122          {
    123              //
    124              // Enable the systick timer interrupt.
    125              //
    126              SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk;
    127          }
    128          
    129          //*****************************************************************************
    130          //
    131          //! @brief Disable the interrupt in the SYSTICK.
    132          //!
    133          //! This function disables the interupt in the systick timer.
    134          //!
    135          //! @return None.
    136          //
    137          //*****************************************************************************
    138          void
    139          am_hal_systick_int_disable(void)
    140          {
    141              //
    142              // Disable the systick timer interrupt.
    143              //
    144              SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
    145          }
    146          
    147          //*****************************************************************************
    148          //
    149          //! @brief Reads the interrupt status.
    150          //!
    151          //! This function reads the interrupt status in the systick timer.
    152          //!
    153          //! @return the interrupt status.
    154          //
    155          //*****************************************************************************
    156          uint32_t
    157          am_hal_systick_int_status_get(void)
    158          {
    159              //
    160              // Return the systick timer interrupt status.
    161              //
    162              return SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk;
    163          }
    164          
    165          //*****************************************************************************
    166          //
    167          //! @brief Reset the interrupt in the SYSTICK.
    168          //!
    169          //! This function resets the systick timer by clearing out the configuration
    170          //! register.
    171          //!
    172          //! @return None.
    173          //
    174          //*****************************************************************************
    175          void
    176          am_hal_systick_reset(void)
    177          {
    178              //
    179              // Reset the systick timer interrupt.
    180              //
    181              SysTick->CTRL = 0x0;
    182          }
    183          
    184          //*****************************************************************************
    185          //
    186          //! @brief Load the value into the SYSTICK.
    187          //!
    188          //! @param ui32LoadVal the desired load value for the systick. Maximum value is
    189          //! 0x00FF.FFFF.
    190          //!
    191          //! This function loads the desired value into the systick timer.
    192          //!
    193          //! @return None.
    194          //
    195          //*****************************************************************************
    196          void
    197          am_hal_systick_load(uint32_t ui32LoadVal)
    198          {
    199              //
    200              //  The proper SysTick initialization sequence is: (p 4-36 of the M4 UG).
    201              //      1. Program reload value
    202              //      2. Clear current value
    203              //      3. Program CSR
    204              // Write the given value to the reload register.
    205              // Write the Current Value Register to clear it to 0.
    206              //
    207              SysTick->LOAD = ui32LoadVal;
    208              SysTick->VAL = 0;
    209          }
    210          
    211          //*****************************************************************************
    212          //
    213          //! @brief Get the current count value in the SYSTICK.
    214          //!
    215          //! This function gets the current count value in the systick timer.
    216          //!
    217          //! @return Current count value.
    218          //
    219          //*****************************************************************************
    220          uint32_t
    221          am_hal_systick_count(void)
    222          {
    223              //
    224              // Return the current systick timer count value.
    225              //
    226              return SysTick->VAL;
    227          }
    228          
    229          //*****************************************************************************
    230          //
    231          //! @brief Wait the specified number of ticks.
    232          //!
    233          //! This function delays for the given number of SysTick ticks.
    234          //!
    235          //! @note If the SysTick timer is being used elsewhere, it will be corrupted
    236          //! by calling this function.
    237          //!
    238          //! @return 0 if successful.
    239          //
    240          //*****************************************************************************
    241          uint32_t
    242          am_hal_systick_wait_ticks(uint32_t ui32Ticks)
    243          {
    244          
    245              if ( ui32Ticks == 0 )
    246              {
    247                  ui32Ticks++;                // Make sure we get the COUNTFLAG
    248              }
    249          
    250              //
    251              //  The proper SysTick initialization sequence is: (p 4-36 of the M4 UG).
    252              //      1. Program reload value
    253              //      2. Clear current value
    254              //      3. Program CSR
    255              //
    256              // Set the reload value to the required number of ticks.
    257              //
    258              SysTick->LOAD = ui32Ticks;
    259          
    260              //
    261              // Clear the current count.
    262              //
    263              SysTick->VAL = 0x0;
    264          
    265              //
    266              // Set to use the processor clock, but don't cause an exception (we'll poll).
    267              //
    268              SysTick->CTRL = SysTick_CTRL_ENABLE_Msk;
    269          
    270              //
    271              // Poll till done
    272              //
    273              while ( !(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) );
    274          
    275              //
    276              // And disable systick before exiting.
    277              //
    278              SysTick->CTRL = 0x0;
    279          
    280              return 0;
    281          }
    282          
    283          //*****************************************************************************
    284          //
    285          //! @brief Delay the specified number of microseconds.
    286          //!
    287          //! This function will use the SysTick timer to delay until the specified
    288          //!  number of microseconds have elapsed.  It uses the processor clocks and
    289          //!  takes into account the current CORESEL setting.
    290          //!
    291          //! @note If the SysTick timer is being used elsewhere, it will be corrupted
    292          //! by calling this function.
    293          //!
    294          //! @return Total number of SysTick ticks delayed.
    295          //
    296          //*****************************************************************************
    297          uint32_t
    298          am_hal_systick_delay_us(uint32_t ui32NumUs)
    299          {
    300              uint32_t ui32nLoops, ui32Ticks, uRet;
    301              uint32_t ui32ClkFreq, ui32TicksPerMHz;
    302              uint32_t ui32CoreSel = CLKGEN->CCTRL_b.CORESEL;
    303          
    304              ui32nLoops = 0;
    305              if ( (ui32CoreSel <= AM_HAL_CLKGEN_CORESEL_MAXDIV)  &&  (ui32NumUs >= 2) )
    306              {
    307                  //
    308                  // Determine clock freq, then whether we need more than 1 iteration.
    309                  //
    310                  ui32ClkFreq = AM_HAL_CLKGEN_FREQ_MAX_MHZ >> ui32CoreSel;
    311          #if defined(AM_PART_APOLLO)
    312                  if ( ui32CoreSel > 1 )
    313                  {
    314                      ui32ClkFreq = AM_HAL_CLKGEN_FREQ_MAX_MHZ / (ui32CoreSel + 1);
    315                  }
    316          #endif
    317          #if !defined(AM_PART_APOLLO) && !defined(AM_PART_APOLLO2)
    318                  ui32ClkFreq <<= (am_hal_burst_mode_status() == AM_HAL_BURST_MODE)? 1 : 0;
    319          #endif
    320                  ui32TicksPerMHz = SYSTICK_MAX_TICKS / ui32ClkFreq;
    321                  if ( ui32NumUs > ui32TicksPerMHz )
    322                  {
    323                      //
    324                      // Get number of required loops, as well as additional ticks.
    325                      //
    326                      ui32nLoops = ui32NumUs / ui32TicksPerMHz;
    327                      ui32NumUs  = ui32NumUs % ui32TicksPerMHz;
    328                  }
    329          
    330                  //
    331                  // Compute the number of ticks required.
    332                  // Allow for about 2us of call overhead.
    333                  //
    334                  ui32Ticks = (ui32NumUs - 2) * ui32ClkFreq;
    335              }
    336              else
    337              {
    338                  ui32Ticks = 1;
    339              }
    340          
    341              uRet = (ui32nLoops * SYSTICK_MAX_TICKS) + ui32Ticks;
    342              while ( ui32nLoops )
    343              {
    344                  am_hal_systick_wait_ticks(SYSTICK_MAX_TICKS);
    345                  ui32nLoops--;
    346              }
    347              am_hal_systick_wait_ticks(ui32Ticks);
    348          
    349              return uRet;
    350          }
    351          
    352          //*****************************************************************************
    353          //
    354          // End Doxygen group.
    355          //! @}
    356          //
    357          //*****************************************************************************

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   am_hal_systick_count
      32   am_hal_systick_delay_us
        32   -> am_hal_systick_wait_ticks
       0   am_hal_systick_int_disable
       0   am_hal_systick_int_enable
       0   am_hal_systick_int_status_get
       0   am_hal_systick_load
       0   am_hal_systick_reset
       0   am_hal_systick_start
       0   am_hal_systick_stop
       0   am_hal_systick_wait_ticks


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       6  am_hal_systick_count
     126  am_hal_systick_delay_us
      12  am_hal_systick_int_disable
      12  am_hal_systick_int_enable
      10  am_hal_systick_int_status_get
      12  am_hal_systick_load
       8  am_hal_systick_reset
      12  am_hal_systick_start
      12  am_hal_systick_stop
      38  am_hal_systick_wait_ticks

 
 268 bytes in section .text
 
 268 bytes of CODE memory

Errors: none
Warnings: none
