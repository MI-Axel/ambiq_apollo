###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         12/Mar/2019  10:07:09
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_queue.c
#    Command line =  
#        -f C:\temp\EW880D.tmp
#        (C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_queue.c
#        -D iar -D AM_PART_APOLLO3 -D AM_PACKAGE_BGA -lcN
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --diag_suppress Pa050 -o
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\utils\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\ARM\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\AmbiqMicro\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\mcu\apollo3\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\devices\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\bsp\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\sound\
#        -On)
#    Locale       =  C
#    List file    =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_queue.lst
#    Object file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_queue.o
#
###############################################################################

C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_queue.c
      1          //*****************************************************************************
      2          //
      3          //  am_hal_queue.c
      4          //! @file
      5          //!
      6          //! @brief Functions for implementing a queue system.
      7          //!
      8          //! @addtogroup Miscellaneous3 Software Features (MISC)
      9          //! @ingroup apollo3hal
     10          //! @{
     11          //
     12          //*****************************************************************************
     13          
     14          //*****************************************************************************
     15          //
     16          // Copyright (c) 2019, Ambiq Micro
     17          // All rights reserved.
     18          // 
     19          // Redistribution and use in source and binary forms, with or without
     20          // modification, are permitted provided that the following conditions are met:
     21          // 
     22          // 1. Redistributions of source code must retain the above copyright notice,
     23          // this list of conditions and the following disclaimer.
     24          // 
     25          // 2. Redistributions in binary form must reproduce the above copyright
     26          // notice, this list of conditions and the following disclaimer in the
     27          // documentation and/or other materials provided with the distribution.
     28          // 
     29          // 3. Neither the name of the copyright holder nor the names of its
     30          // contributors may be used to endorse or promote products derived from this
     31          // software without specific prior written permission.
     32          // 
     33          // Third party software included in this distribution is subject to the
     34          // additional license terms as defined in the /docs/licenses directory.
     35          // 
     36          // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     37          // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     38          // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     39          // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     40          // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     41          // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     42          // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     43          // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     44          // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     45          // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     46          // POSSIBILITY OF SUCH DAMAGE.
     47          //
     48          // This is part of revision v2.0.0 of the AmbiqSuite Development Package.
     49          //
     50          //*****************************************************************************
     51          
     52          #include <stdint.h>
     53          #include <stdbool.h>
     54          #include "am_mcu_apollo.h"
     55          
     56          //*****************************************************************************
     57          //
     58          //! @brief Initializes a queue.
     59          //!
     60          //! @param psQueue - Pointer to a queue structure.
     61          //! @param pvData - Pointer to a memory location to be used for data storage.
     62          //! @param ui32ItemSize - Number of bytes per item in the queue.
     63          //! @param ui32ArraySize - Number of bytes in the data array.
     64          //!
     65          //! This function initializes the members of a queue structure and attaches it
     66          //! to an array of memory that it can use for storage. This function should be
     67          //! called before the queue is used.
     68          //!
     69          //! In this example, we are creating a queue that can hold 1024 32-bit
     70          //! integers. The integers themselves will be stored in the array named
     71          //! pui32WorkingSpace, while information about the queue itself will be stored
     72          //! in sDataQueue.
     73          //!
     74          //! @note The caller should not modify any of the members of am_hal_queue_t
     75          //! structures. The queue API will handle these members in a thread-safe way.
     76          //!
     77          //! @note The queue will remember what size data is in it. Other queue API
     78          //! functions will perform transfers in units of "items" where one "item" is
     79          //! the number of bytes you specify in the \e ui32ItemSize argument upon
     80          //! initialization.
     81          //!
     82          //! Example usage:
     83          //!
     84          //! @code
     85          //!
     86          //! //
     87          //! // Declare a queue structure and an array of bytes we can use to store
     88          //! // data.
     89          //! //
     90          //! am_hal_queue_t sDataQueue;
     91          //! uint32_t pui32WorkingSpace[1024];
     92          //!
     93          //! //
     94          //! // Attach the queue structure to the working memory.
     95          //! //
     96          //! am_hal_queue_init(&sDataQueue, pui8WorkingSpace, sizeof(uint32_t)
     97          //!                   sizeof(pui32WorkingSpace));
     98          //!
     99          //! @endcode
    100          //!
    101          //! The am_hal_queue_from_array macro is a convenient shorthand for this
    102          //! operation. The code below does the same thing as the code above.
    103          //!
    104          //! @code
    105          //!
    106          //! //
    107          //! // Declare a queue structure and an array of bytes we can use to store
    108          //! // data.
    109          //! //
    110          //! am_hal_queue_t sDataQueue;
    111          //! uint32_t pui32WorkingSpace[1024];
    112          //!
    113          //! //
    114          //! // Attach the queue structure to the working memory.
    115          //! //
    116          //! am_hal_queue_from_array(&sDataQueue, pui8WorkingSpace);
    117          //!
    118          //! @endcode
    119          //
    120          //*****************************************************************************
    121          void
    122          am_hal_queue_init(am_hal_queue_t *psQueue, void *pvData, uint32_t ui32ItemSize,
    123                            uint32_t ui32ArraySize)
    124          {
    125              psQueue->ui32WriteIndex = 0;
    126              psQueue->ui32ReadIndex = 0;
    127              psQueue->ui32Length = 0;
    128              psQueue->ui32Capacity = ui32ArraySize;
    129              psQueue->ui32ItemSize = ui32ItemSize;
    130              psQueue->pui8Data = (uint8_t *) pvData;
    131          }
    132          
    133          //*****************************************************************************
    134          //
    135          //! @brief Adds an item to the Queue
    136          //!
    137          //! @param psQueue - Pointer to a queue structure.
    138          //! @param pvSource - Pointer to the data to be added.
    139          //! @param ui32NumItems - Number of items to be added.
    140          //!
    141          //! This function will copy the data pointed to by pvSource into the queue. The
    142          //! \e ui32NumItems term specifies the number of items to be copied from \e
    143          //! pvSource. The size of an "item" depends on how the queue was initialized.
    144          //! Please see am_hal_queue_init() for more information on this.
    145          //!
    146          //! @return true if the add operation was successful, or false if the queue
    147          //! didn't have enough space.
    148          //
    149          //*****************************************************************************
    150          bool
    151          am_hal_queue_item_add(am_hal_queue_t *psQueue, const void *pvSource, uint32_t ui32NumItems)
    152          {
    153              uint8_t *pui8Source;
    154              uint32_t ui32Bytes = ui32NumItems * psQueue->ui32ItemSize;
    155              bool bSuccess = false;
    156          
    157              pui8Source = (uint8_t *) pvSource;
    158          
    159              AM_CRITICAL_BEGIN
    160          
    161              //
    162              // Check to make sure that the buffer isn't already full
    163              //
    164              if ( am_hal_queue_space_left(psQueue) >= ui32Bytes )
    165              {
    166                  //
    167                  // Loop over the bytes in the source array.
    168                  //
    169                  for ( uint32_t i = 0; i < ui32Bytes; i++ )
    170                  {
    171                      //
    172                      // Write the value to the buffer, but only if the source pointer is
    173                      // valid.
    174                      //
    175                      if (pvSource)
    176                      {
    177                          psQueue->pui8Data[psQueue->ui32WriteIndex] = pui8Source[i];
    178                      }
    179          
    180                      //
    181                      // Advance the write index, making sure to wrap if necessary.
    182                      //
    183                      psQueue->ui32WriteIndex = ((psQueue->ui32WriteIndex + 1) %
    184                                                  psQueue->ui32Capacity);
    185                  }
    186          
    187                  //
    188                  // Update the length value appropriately.
    189                  //
    190                  psQueue->ui32Length += ui32Bytes;
    191          
    192                  //
    193                  // Report a success.
    194                  //
    195                  bSuccess = true;
    196              }
    197              else
    198              {
    199                  //
    200                  // The buffer can't fit the amount of data requested. Return a
    201                  // failure.
    202                  //
    203                  bSuccess = false;
    204              }
    205          
    206              AM_CRITICAL_END
    207          
    208              return bSuccess;
    209          }
    210          
    211          //*****************************************************************************
    212          //
    213          //! @brief Removes an item from the Queue
    214          //!
    215          //! @param psQueue - Pointer to a queue structure.
    216          //! @param pvDest - Pointer to the data to be added.
    217          //! @param ui32NumItems - Number of items to be added.
    218          //!
    219          //! This function will copy the data from the queue into the memory pointed to
    220          //! by pvDest. The \e ui32NumItems term specifies the number of items to be
    221          //! copied from the queue. The size of an "item" depends on how the queue was
    222          //! initialized.  Please see am_hal_queue_init() for more information on this.
    223          //!
    224          //! @return true if we were able to pull the requested number of items from the
    225          //! queue, or false if the queue didn't have that many items to pull.
    226          //
    227          //*****************************************************************************
    228          bool
    229          am_hal_queue_item_get(am_hal_queue_t *psQueue, void *pvDest, uint32_t ui32NumItems)
    230          {
    231              uint8_t *pui8Dest;
    232              uint32_t ui32Bytes = ui32NumItems * psQueue->ui32ItemSize;
    233              bool bSuccess = false;
    234          
    235              pui8Dest = (uint8_t *) pvDest;
    236          
    237              AM_CRITICAL_BEGIN
    238          
    239              //
    240              // Check to make sure that the buffer isn't empty
    241              //
    242              if ( am_hal_queue_data_left(psQueue) >= ui32Bytes )
    243              {
    244                  //
    245                  // Loop over the bytes in the destination array.
    246                  //
    247                  for ( uint32_t i = 0; i < ui32Bytes; i++ )
    248                  {
    249                      //
    250                      // Grab the next value from the buffer, but only if the
    251                      // destination pointer is valid.
    252                      //
    253                      if (pvDest)
    254                      {
    255                          pui8Dest[i] = psQueue->pui8Data[psQueue->ui32ReadIndex];
    256                      }
    257          
    258                      //
    259                      // Advance the read index, wrapping if needed.
    260                      //
    261                      psQueue->ui32ReadIndex = ((psQueue->ui32ReadIndex + 1) %
    262                                                 psQueue->ui32Capacity);
    263                  }
    264          
    265                  //
    266                  // Adjust the length value to reflect the change.
    267                  //
    268                  psQueue->ui32Length -= ui32Bytes;
    269          
    270                  //
    271                  // Report a success.
    272                  //
    273                  bSuccess = true;
    274              }
    275              else
    276              {
    277                  //
    278                  // If the buffer didn't have enough data, just return false.
    279                  //
    280                  bSuccess = false;
    281              }
    282          
    283              AM_CRITICAL_END
    284          
    285              return bSuccess;
    286          }
    287          
    288          //*****************************************************************************
    289          //
    290          // End Doxygen group.
    291          //! @}
    292          //
    293          //*****************************************************************************

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   am_hal_queue_init
      40   am_hal_queue_item_add
        40   -> am_hal_interrupt_master_disable
        40   -> am_hal_interrupt_master_set
      40   am_hal_queue_item_get
        40   -> am_hal_interrupt_master_disable
        40   -> am_hal_interrupt_master_set


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      24  am_hal_queue_init
     108  am_hal_queue_item_add
     104  am_hal_queue_item_get

 
 236 bytes in section .text
 
 236 bytes of CODE memory

Errors: none
Warnings: none
