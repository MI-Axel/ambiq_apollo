###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         12/Mar/2019  10:07:10
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_uart.c
#    Command line =  
#        -f C:\temp\EW8DD2.tmp
#        (C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_uart.c
#        -D iar -D AM_PART_APOLLO3 -D AM_PACKAGE_BGA -lcN
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --diag_suppress Pa050 -o
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\utils\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\ARM\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\AmbiqMicro\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\mcu\apollo3\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\devices\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\bsp\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\sound\
#        -On)
#    Locale       =  C
#    List file    =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_uart.lst
#    Object file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_uart.o
#
###############################################################################

C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_uart.c
      1          //*****************************************************************************
      2          //
      3          //  am_hal_uart.c
      4          //! @file
      5          //!
      6          //! @brief Functions for interfacing with the UART.
      7          //!
      8          //! @addtogroup uart2 UART
      9          //! @ingroup apollo2hal
     10          //! @{
     11          //
     12          //*****************************************************************************
     13          
     14          //*****************************************************************************
     15          //
     16          // Copyright (c) 2019, Ambiq Micro
     17          // All rights reserved.
     18          // 
     19          // Redistribution and use in source and binary forms, with or without
     20          // modification, are permitted provided that the following conditions are met:
     21          // 
     22          // 1. Redistributions of source code must retain the above copyright notice,
     23          // this list of conditions and the following disclaimer.
     24          // 
     25          // 2. Redistributions in binary form must reproduce the above copyright
     26          // notice, this list of conditions and the following disclaimer in the
     27          // documentation and/or other materials provided with the distribution.
     28          // 
     29          // 3. Neither the name of the copyright holder nor the names of its
     30          // contributors may be used to endorse or promote products derived from this
     31          // software without specific prior written permission.
     32          // 
     33          // Third party software included in this distribution is subject to the
     34          // additional license terms as defined in the /docs/licenses directory.
     35          // 
     36          // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     37          // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     38          // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     39          // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     40          // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     41          // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     42          // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     43          // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     44          // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     45          // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     46          // POSSIBILITY OF SUCH DAMAGE.
     47          //
     48          // This is part of revision v2.0.0 of the AmbiqSuite Development Package.
     49          //
     50          //*****************************************************************************
     51          
     52          #include <stdint.h>
     53          #include <stdbool.h>
     54          #include "am_mcu_apollo.h"
     55          
     56          //*****************************************************************************
     57          //
     58          // UART magic number for handle verification.
     59          //
     60          //*****************************************************************************
     61          #define AM_HAL_MAGIC_UART               0xEA9E06
     62          
     63          #define AM_HAL_UART_CHK_HANDLE(h)                                             \
     64              ((h) &&                                                                   \
     65               ((am_hal_handle_prefix_t *)(h))->s.bInit &&                              \
     66               (((am_hal_handle_prefix_t *)(h))->s.magic == AM_HAL_MAGIC_UART))
     67          
     68          //*****************************************************************************
     69          //
     70          // Convenience macro for passing errors.
     71          //
     72          //*****************************************************************************
     73          #define RETURN_ON_ERROR(x)                                                    \
     74              if ((x) != AM_HAL_STATUS_SUCCESS)                                         \
     75              {                                                                         \
     76                  return (x);                                                           \
     77              };
     78          
     79          //*****************************************************************************
     80          //
     81          // Baudrate to byte-time in microseconds with a little extra margin.
     82          //
     83          //*****************************************************************************
     84          #define ONE_BYTE_US(baudrate)       (12000000/(baudrate))
     85          #define ONE_BYTE_DELAY(handle)                                                \
     86              am_hal_flash_delay(FLASH_CYCLES_US(ONE_BYTE_US((handle)->ui32BaudRate)))
     87          
     88          //*****************************************************************************
     89          //
     90          // Structure for handling UART register state information for power up/down
     91          //
     92          //*****************************************************************************
     93          typedef struct
     94          {
     95              bool bValid;
     96              uint32_t regILPR;
     97              uint32_t regIBRD;
     98              uint32_t regFBRD;
     99              uint32_t regLCRH;
    100              uint32_t regCR;
    101              uint32_t regIFLS;
    102              uint32_t regIER;
    103          }
    104          am_hal_uart_register_state_t;
    105          
    106          //*****************************************************************************
    107          //
    108          // Structure for handling UART HAL state information.
    109          //
    110          //*****************************************************************************
    111          typedef struct
    112          {
    113              am_hal_handle_prefix_t prefix;
    114              am_hal_uart_register_state_t sRegState;
    115          
    116              uint32_t ui32Module;
    117          
    118              bool bEnableTxQueue;
    119              am_hal_queue_t sTxQueue;
    120          
    121              bool bEnableRxQueue;
    122              am_hal_queue_t sRxQueue;
    123          
    124              uint32_t ui32BaudRate;
    125          }
    126          am_hal_uart_state_t;
    127          
    128          //*****************************************************************************
    129          //
    130          // State structure for each module.
    131          //
    132          //*****************************************************************************
    133          am_hal_uart_state_t g_am_hal_uart_states[AM_REG_UART_NUM_MODULES];
    134          
    135          //*****************************************************************************
    136          //
    137          // Prototypes for static functions.
    138          //
    139          //*****************************************************************************
    140          static uint32_t config_baudrate(uint32_t ui32Module, uint32_t ui32Baudrate, uint32_t *ui32UartClkFreq);
    141          
    142          static uint32_t buffer_configure(void *pHandle,
    143                                           uint8_t *pui8TxBuffer,
    144                                           uint32_t ui32TxBufferSize,
    145                                           uint8_t *pui8RxBuffer,
    146                                           uint32_t ui32RxBufferSize);
    147          
    148          static uint32_t tx_queue_update(void *pHandle);
    149          static uint32_t rx_queue_update(void *pHandle);
    150          
    151          static uint32_t uart_fifo_read(void *pHandle,
    152                                         uint8_t *pui8Data,
    153                                         uint32_t ui32NumBytes,
    154                                         uint32_t *pui32NumBytesRead);
    155          
    156          static uint32_t uart_fifo_write(void *pHandle,
    157                                          uint8_t *pui8Data,
    158                                          uint32_t ui32NumBytes,
    159                                          uint32_t *pui32NumBytesWritten);
    160          
    161          //*****************************************************************************
    162          //
    163          // Initialization function.
    164          //
    165          //*****************************************************************************
    166          uint32_t
    167          am_hal_uart_initialize(uint32_t ui32Module, void **ppHandle)
    168          {
    169              //
    170              // Check that the request module is in range.
    171              //
    172              if (ui32Module >= AM_REG_UART_NUM_MODULES )
    173              {
    174                  return AM_HAL_STATUS_OUT_OF_RANGE;
    175              }
    176          
    177              //
    178              // Check for valid arguements.
    179              //
    180              if (!ppHandle)
    181              {
    182                  return AM_HAL_STATUS_INVALID_ARG;
    183              }
    184          
    185              //
    186              // Check if the handle is unallocated.
    187              //
    188              if (g_am_hal_uart_states[ui32Module].prefix.s.bInit)
    189              {
    190                  return AM_HAL_STATUS_INVALID_OPERATION;
    191              }
    192          
    193              //
    194              // Initialize the handle.
    195              //
    196              g_am_hal_uart_states[ui32Module].prefix.s.bInit = true;
    197              g_am_hal_uart_states[ui32Module].prefix.s.magic = AM_HAL_MAGIC_UART;
    198              g_am_hal_uart_states[ui32Module].ui32Module = ui32Module;
    199              g_am_hal_uart_states[ui32Module].sRegState.bValid = false;
    200              g_am_hal_uart_states[ui32Module].ui32BaudRate = 0;
    201          
    202              //
    203              // Return the handle.
    204              //
    205              *ppHandle = (void *)&g_am_hal_uart_states[ui32Module];
    206          
    207              //
    208              // Return the status.
    209              //
    210              return AM_HAL_STATUS_SUCCESS;
    211          } // am_hal_uart_initialize()
    212          
    213          //*****************************************************************************
    214          //
    215          // De-Initialization function.
    216          //
    217          //*****************************************************************************
    218          uint32_t
    219          am_hal_uart_deinitialize(void *pHandle)
    220          {
    221              am_hal_uart_state_t *pState = (am_hal_uart_state_t *)pHandle;
    222          
    223              //
    224              // Check the handle.
    225              //
    226              if (!AM_HAL_UART_CHK_HANDLE(pHandle))
    227              {
    228                  return AM_HAL_STATUS_INVALID_HANDLE;
    229              }
    230          
    231              //
    232              // Reset the handle.
    233              //
    234              pState->prefix.s.bInit = false;
    235              pState->ui32Module = 0;
    236              pState->sRegState.bValid = false;
    237          
    238              //
    239              // Return the status.
    240              //
    241              return AM_HAL_STATUS_SUCCESS;
    242          } // am_hal_uart_deinitialize()
    243          
    244          //*****************************************************************************
    245          //
    246          // Power control functions.
    247          //
    248          //*****************************************************************************
    249          uint32_t
    250          am_hal_uart_power_control(void *pHandle,
    251                                    am_hal_sysctrl_power_state_e ePowerState,
    252                                    bool bRetainState)
    253          {
    254              am_hal_uart_state_t *pState = (am_hal_uart_state_t *) pHandle;
    255              uint32_t ui32Module = pState->ui32Module;
    256          
    257              am_hal_pwrctrl_periph_e eUARTPowerModule = ((am_hal_pwrctrl_periph_e)
    258                                                          (AM_HAL_PWRCTRL_PERIPH_UART0 +
    259                                                           ui32Module));
    260          
    261              //
    262              // Check to make sure this is a valid handle.
    263              //
    264              if (!AM_HAL_UART_CHK_HANDLE(pHandle))
    265              {
    266                  return AM_HAL_STATUS_INVALID_HANDLE;
    267              }
    268          
    269              //
    270              // Decode the requested power state and update UART operation accordingly.
    271              //
    272              switch (ePowerState)
    273              {
    274                  //
    275                  // Turn on the UART.
    276                  //
    277                  case AM_HAL_SYSCTRL_WAKE:
    278                      //
    279                      // Make sure we don't try to restore an invalid state.
    280                      //
    281                      if (bRetainState && !pState->sRegState.bValid)
    282                      {
    283                          return AM_HAL_STATUS_INVALID_OPERATION;
    284                      }
    285          
    286                      //
    287                      // Enable power control.
    288                      //
    289                      am_hal_pwrctrl_periph_enable(eUARTPowerModule);
    290          
    291                      if (bRetainState)
    292                      {
    293                          //
    294                          // Restore UART registers
    295                          //
    296                          AM_CRITICAL_BEGIN
    297          
    298                          UARTn(ui32Module)->ILPR = pState->sRegState.regILPR;
    299                          UARTn(ui32Module)->IBRD = pState->sRegState.regIBRD;
    300                          UARTn(ui32Module)->FBRD = pState->sRegState.regFBRD;
    301                          UARTn(ui32Module)->LCRH = pState->sRegState.regLCRH;
    302                          UARTn(ui32Module)->CR   = pState->sRegState.regCR;
    303                          UARTn(ui32Module)->IFLS = pState->sRegState.regIFLS;
    304                          UARTn(ui32Module)->IER  = pState->sRegState.regIER;
    305          
    306                          pState->sRegState.bValid = false;
    307          
    308                          AM_CRITICAL_END
    309                      }
    310                      break;
    311          
    312                  //
    313                  // Turn off the UART.
    314                  //
    315                  case AM_HAL_SYSCTRL_NORMALSLEEP:
    316                  case AM_HAL_SYSCTRL_DEEPSLEEP:
    317                      if (bRetainState)
    318                      {
    319                          AM_CRITICAL_BEGIN
    320          
    321                          pState->sRegState.regILPR = UARTn(ui32Module)->ILPR;
    322                          pState->sRegState.regIBRD = UARTn(ui32Module)->IBRD;
    323                          pState->sRegState.regFBRD = UARTn(ui32Module)->FBRD;
    324                          pState->sRegState.regLCRH = UARTn(ui32Module)->LCRH;
    325                          pState->sRegState.regCR   = UARTn(ui32Module)->CR;
    326                          pState->sRegState.regIFLS = UARTn(ui32Module)->IFLS;
    327                          pState->sRegState.regIER  = UARTn(ui32Module)->IER;
    328                          pState->sRegState.bValid = true;
    329          
    330                          AM_CRITICAL_END
    331                      }
    332          
    333                      //
    334                      // Clear all interrupts before sleeping as having a pending UART
    335                      // interrupt burns power.
    336                      //
    337                      am_hal_uart_interrupt_clear(pState, 0xFFFFFFFF);
    338          
    339                      //
    340                      // Disable power control.
    341                      //
    342                      am_hal_pwrctrl_periph_disable(eUARTPowerModule);
    343                      break;
    344          
    345                  default:
    346                      return AM_HAL_STATUS_INVALID_ARG;
    347              }
    348          
    349              //
    350              // Return the status.
    351              //
    352              return AM_HAL_STATUS_SUCCESS;
    353          } // am_hal_uart_power_control()
    354          
    355          //*****************************************************************************
    356          //
    357          // UART configuration.
    358          //
    359          //*****************************************************************************
    360          uint32_t
    361          am_hal_uart_configure(void *pHandle, const am_hal_uart_config_t *psConfig)
    362          {
    363              am_hal_uart_state_t *pState = (am_hal_uart_state_t *) pHandle;
    364              uint32_t ui32Module = pState->ui32Module;
    365          
    366              uint32_t ui32ErrorStatus;
    367          
    368              //
    369              // Check to make sure this is a valid handle.
    370              //
    371              if (!AM_HAL_UART_CHK_HANDLE(pHandle))
    372              {
    373                  return AM_HAL_STATUS_INVALID_HANDLE;
    374              }
    375          
    376              //
    377              // Reset the CR register to a known value.
    378              //
    379              UARTn(ui32Module)->CR = 0;
    380          
    381              //
    382              // Start by enabling the clocks, which needs to happen in a critical
    383              // section.
    384              //
    385              AM_CRITICAL_BEGIN
    386          
    387              UARTn(ui32Module)->CR_b.CLKEN = 1;
    388              UARTn(ui32Module)->CR_b.CLKSEL = UART0_CR_CLKSEL_24MHZ;
    389          
    390              AM_CRITICAL_END
    391          
    392              //
    393              // Disable the UART.
    394              //
    395              AM_CRITICAL_BEGIN
    396          
    397              UARTn(ui32Module)->CR_b.UARTEN = 0;
    398              UARTn(ui32Module)->CR_b.RXE = 0;
    399              UARTn(ui32Module)->CR_b.TXE = 0;
    400          
    401              AM_CRITICAL_END
    402          
    403              //
    404              // Set the baud rate.
    405              //
    406                  ui32ErrorStatus = config_baudrate(ui32Module, psConfig->ui32BaudRate,
    407                                                    &(pState->ui32BaudRate));
    408          
    409              RETURN_ON_ERROR(ui32ErrorStatus);
    410          
    411              //
    412              // Copy the configuration options into the appropriate registers.
    413              //
    414              UARTn(ui32Module)->CR_b.RTSEN = 0;
    415              UARTn(ui32Module)->CR_b.CTSEN = 0;
    416              UARTn(ui32Module)->CR |= psConfig->ui32FlowControl;
    417          
    418              UARTn(ui32Module)->IFLS = psConfig->ui32FifoLevels;
    419          
    420              UARTn(ui32Module)->LCRH = (psConfig->ui32DataBits   |
    421                                         psConfig->ui32Parity     |
    422                                         psConfig->ui32StopBits   |
    423                                         AM_HAL_UART_FIFO_ENABLE);
    424          
    425              //
    426              // Enable the UART, RX, and TX.
    427              //
    428              AM_CRITICAL_BEGIN
    429          
    430              UARTn(ui32Module)->CR_b.UARTEN = 1;
    431              UARTn(ui32Module)->CR_b.RXE = 1;
    432              UARTn(ui32Module)->CR_b.TXE = 1;
    433          
    434              AM_CRITICAL_END
    435          
    436              //
    437              // Set up any buffers that might exist.
    438              //
    439              buffer_configure(pHandle,
    440                               psConfig->pui8TxBuffer,
    441                               psConfig->ui32TxBufferSize,
    442                               psConfig->pui8RxBuffer,
    443                               psConfig->ui32RxBufferSize);
    444          
    445              return AM_HAL_STATUS_SUCCESS;
    446          } // am_hal_uart_configure()
    447          
    448          //*****************************************************************************
    449          //
    450          // Allows the UART HAL to use extra space to store TX and RX data.
    451          //
    452          //*****************************************************************************
    453          static uint32_t
    454          buffer_configure(void *pHandle, uint8_t *pui8TxBuffer, uint32_t ui32TxBufferSize,
    455                           uint8_t *pui8RxBuffer, uint32_t ui32RxBufferSize)
    456          {
    457              am_hal_uart_state_t *pState = (am_hal_uart_state_t *) pHandle;
    458              uint32_t ui32ErrorStatus;
    459          
    460              //
    461              // Check to make sure this is a valid handle.
    462              //
    463              if (!AM_HAL_UART_CHK_HANDLE(pHandle))
    464              {
    465                  return AM_HAL_STATUS_INVALID_HANDLE;
    466              }
    467          
    468              //
    469              // Check to see if we have a TX buffer.
    470              //
    471              if (pui8TxBuffer && ui32TxBufferSize)
    472              {
    473                  //
    474                  // If so, initialzie the transmit queue, and enable the TX FIFO
    475                  // interrupt.
    476                  //
    477                  pState->bEnableTxQueue = true;
    478                  am_hal_queue_init(&pState->sTxQueue, pui8TxBuffer, 1, ui32TxBufferSize);
    479                  ui32ErrorStatus = am_hal_uart_interrupt_enable(pHandle, AM_HAL_UART_INT_TX);
    480                  RETURN_ON_ERROR(ui32ErrorStatus);
    481              }
    482              else
    483              {
    484                  //
    485                  // If not, make sure the TX FIFO interrupt is disabled.
    486                  //
    487                  pState->bEnableTxQueue = false;
    488                  ui32ErrorStatus = am_hal_uart_interrupt_disable(pHandle, AM_HAL_UART_INT_TX);
    489                  RETURN_ON_ERROR(ui32ErrorStatus);
    490              }
    491          
    492              //
    493              // Check to see if we have an RX buffer.
    494              //
    495              if (pui8RxBuffer && ui32RxBufferSize)
    496              {
    497                  //
    498                  // If so, initialize the receive queue and the associated interupts.
    499                  //
    500                  pState->bEnableRxQueue = true;
    501                  am_hal_queue_init(&pState->sRxQueue, pui8RxBuffer, 1, ui32RxBufferSize);
    502                  ui32ErrorStatus = am_hal_uart_interrupt_enable(pHandle, (AM_HAL_UART_INT_RX |
    503                                                                           AM_HAL_UART_INT_RX_TMOUT));
    504                  RETURN_ON_ERROR(ui32ErrorStatus);
    505              }
    506              else
    507              {
    508                  pState->bEnableRxQueue = false;
    509                  ui32ErrorStatus = am_hal_uart_interrupt_disable(pHandle, (AM_HAL_UART_INT_RX |
    510                                                                            AM_HAL_UART_INT_RX_TMOUT));
    511                  RETURN_ON_ERROR(ui32ErrorStatus);
    512              }
    513          
    514              return AM_HAL_STATUS_SUCCESS;
    515          } // buffer_configure()
    516          
    517          //*****************************************************************************
    518          //
    519          // Set Baud Rate based on the UART clock frequency.
    520          //
    521          //*****************************************************************************
    522          #define BAUDCLK     (16) // Number of UART clocks needed per bit.
    523          static uint32_t
    524          config_baudrate(uint32_t ui32Module, uint32_t ui32DesiredBaudrate, uint32_t *pui32ActualBaud)
    525          {
    526              uint64_t ui64FractionDivisorLong;
    527              uint64_t ui64IntermediateLong;
    528              uint32_t ui32IntegerDivisor;
    529              uint32_t ui32FractionDivisor;
    530              uint32_t ui32BaudClk;
    531              uint32_t ui32UartClkFreq;
    532          
    533              switch ( UARTn(ui32Module)->CR_b.CLKSEL )
    534              {
    535                  case UART0_CR_CLKSEL_24MHZ:
    536                      ui32UartClkFreq = 24000000;
    537                      break;
    538          
    539                  case UART0_CR_CLKSEL_12MHZ:
    540                      ui32UartClkFreq = 12000000;
    541                      break;
    542          
    543                  case UART0_CR_CLKSEL_6MHZ:
    544                      ui32UartClkFreq = 6000000;
    545                      break;
    546          
    547                  case UART0_CR_CLKSEL_3MHZ:
    548                      ui32UartClkFreq = 3000000;
    549                      break;
    550          
    551                  default:
    552                      *pui32ActualBaud = 0;
    553                      return AM_HAL_UART_STATUS_CLOCK_NOT_CONFIGURED;
    554              }
    555          
    556              //
    557              // Calculate register values.
    558              //
    559              ui32BaudClk = BAUDCLK * ui32DesiredBaudrate;
    560              ui32IntegerDivisor = (uint32_t)(ui32UartClkFreq / ui32BaudClk);
    561              ui64IntermediateLong = (ui32UartClkFreq * 64) / ui32BaudClk;
    562              ui64FractionDivisorLong = ui64IntermediateLong - (ui32IntegerDivisor * 64);
    563              ui32FractionDivisor = (uint32_t)ui64FractionDivisorLong;
    564          
    565              //
    566              // Check the result.
    567              //
    568              if (ui32IntegerDivisor == 0)
    569              {
    570                  *pui32ActualBaud = 0;
    571                  return AM_HAL_UART_STATUS_BAUDRATE_NOT_POSSIBLE;
    572              }
    573          
    574              //
    575              // Write the UART regs.
    576              //
    577              // TODO: Is this double-write of IBRD really intended?
    578              UARTn(ui32Module)->IBRD = ui32IntegerDivisor;
    579              UARTn(ui32Module)->IBRD = ui32IntegerDivisor;
    580              UARTn(ui32Module)->FBRD = ui32FractionDivisor;
    581          
    582              //
    583              // Return the actual baud rate.
    584              //
    585              *pui32ActualBaud = (ui32UartClkFreq / ((BAUDCLK * ui32IntegerDivisor) + ui32FractionDivisor));
    586              return AM_HAL_STATUS_SUCCESS;
    587          } // config_baudrate()
    588          
    589          //*****************************************************************************
    590          //
    591          // Read as much data from the UART FIFO as possible, up to ui32NumBytes
    592          //
    593          //*****************************************************************************
    594          static uint32_t
    595          uart_fifo_read(void *pHandle, uint8_t *pui8Data, uint32_t ui32NumBytes,
    596                         uint32_t *pui32NumBytesRead)
    597          {
    598              uint32_t i = 0;
    599              uint32_t ui32ReadData;
    600              uint32_t ui32ErrorStatus = AM_HAL_STATUS_SUCCESS;
    601          
    602              am_hal_uart_state_t *pState = (am_hal_uart_state_t *) pHandle;
    603              uint32_t ui32Module = pState->ui32Module;
    604          
    605              //
    606              // Start a loop where we attempt to read everything requested.
    607              //
    608              while (i < ui32NumBytes)
    609              {
    610                  //
    611                  // If the fifo is empty, return with the number of bytes we read.
    612                  // Otherwise, read the data into the provided buffer.
    613                  //
    614                  if ( UARTn(ui32Module)->FR_b.RXFE )
    615                  {
    616                      break;
    617                  }
    618                  else
    619                  {
    620                      ui32ReadData = UARTn(ui32Module)->DR;
    621          
    622                      //
    623                      // If error bits are set, we need to alert the caller.
    624                      //
    625                      if (ui32ReadData & (_VAL2FLD(UART0_DR_OEDATA, UART0_DR_OEDATA_ERR) |
    626                                          _VAL2FLD(UART0_DR_BEDATA, UART0_DR_BEDATA_ERR) |
    627                                          _VAL2FLD(UART0_DR_PEDATA, UART0_DR_PEDATA_ERR) |
    628                                          _VAL2FLD(UART0_DR_FEDATA, UART0_DR_FEDATA_ERR)) )
    629                      {
    630                          ui32ErrorStatus =  AM_HAL_UART_STATUS_BUS_ERROR;
    631                          break;
    632                      }
    633                      else
    634                      {
    635                          pui8Data[i++] = ui32ReadData & 0xFF;
    636                      }
    637                  }
    638              }
    639          
    640              if (pui32NumBytesRead)
    641              {
    642                  *pui32NumBytesRead = i;
    643              }
    644          
    645              return ui32ErrorStatus;
    646          } // uart_fifo_read()
    647          
    648          //*****************************************************************************
    649          //
    650          // Read as much data from the UART FIFO as possible, up to ui32NumBytes
    651          //
    652          //*****************************************************************************
    653          static uint32_t
    654          uart_fifo_write(void *pHandle, uint8_t *pui8Data, uint32_t ui32NumBytes,
    655                          uint32_t *pui32NumBytesWritten)
    656          {
    657              uint32_t i = 0;
    658          
    659              am_hal_uart_state_t *pState = (am_hal_uart_state_t *) pHandle;
    660              uint32_t ui32Module = pState->ui32Module;
    661          
    662              //
    663              // Start a loop where we attempt to write everything requested.
    664              //
    665              while (i < ui32NumBytes)
    666              {
    667                  //
    668                  // If the TX FIFO is full, break out of the loop. We've sent everything
    669                  // we can.
    670                  //
    671                  if ( UARTn(ui32Module)->FR_b.TXFF )
    672                  {
    673                      break;
    674                  }
    675                  else
    676                  {
    677                      UARTn(ui32Module)->DR = pui8Data[i++];
    678                  }
    679              }
    680          
    681              //
    682              // Let the caller know how much we sent.
    683              //
    684              if (pui32NumBytesWritten)
    685              {
    686                  *pui32NumBytesWritten = i;
    687              }
    688          
    689              return AM_HAL_STATUS_SUCCESS;
    690          } // uart_fifo_write()
    691          
    692          //*****************************************************************************
    693          //
    694          // Attempt to read N bytes from the FIFO, but give up if they aren't there.
    695          //
    696          //*****************************************************************************
    697          static uint32_t
    698          read_nonblocking(void *pHandle, uint8_t *pui8Data, uint32_t ui32NumBytes,
    699                           uint32_t *pui32NumBytesRead)
    700          {
    701              uint32_t ui32BufferData;
    702              uint32_t ui32BytesTransferred;
    703              uint32_t ui32ErrorStatus = AM_HAL_STATUS_SUCCESS;
    704          
    705              am_hal_uart_state_t *pState = (am_hal_uart_state_t *) pHandle;
    706          
    707              //
    708              // Check to make sure this is a valid handle.
    709              //
    710              if (!AM_HAL_UART_CHK_HANDLE(pHandle))
    711              {
    712                  return AM_HAL_STATUS_INVALID_HANDLE;
    713              }
    714          
    715              //
    716              // Start by setting the number of bytes read to 0.
    717              //
    718              if (pui32NumBytesRead)
    719              {
    720                  *pui32NumBytesRead = 0;
    721              }
    722          
    723              if (ui32NumBytes == 0)
    724              {
    725                  return AM_HAL_STATUS_SUCCESS;
    726              }
    727          
    728              //
    729              // Check to see if the circular receive buffer has been enabled.
    730              //
    731              if (pState->bEnableRxQueue)
    732              {
    733                  //
    734                  // If it is, update it, and then try to read the requested number of
    735                  // bytes, giving up if fewer were actually found.
    736                  //
    737                  ui32ErrorStatus = rx_queue_update(pHandle);
    738                  RETURN_ON_ERROR(ui32ErrorStatus);
    739          
    740                  ui32BufferData = am_hal_queue_data_left(&pState->sRxQueue);
    741          
    742                  ui32BytesTransferred = (ui32NumBytes < ui32BufferData ?
    743                                          ui32NumBytes : ui32BufferData);
    744          
    745                  am_hal_queue_item_get(&pState->sRxQueue, pui8Data, ui32BytesTransferred);
    746              }
    747              else
    748              {
    749                  //
    750                  // If the buffer isn't enabled, just read straight from the FIFO.
    751                  //
    752                  ui32ErrorStatus = uart_fifo_read(pHandle, pui8Data, ui32NumBytes,
    753                                                   &ui32BytesTransferred);
    754              }
    755          
    756              //
    757              // Let the caller know how much we transferred if they provided us with a
    758              // pointer.
    759              //
    760              if (pui32NumBytesRead)
    761              {
    762                  *pui32NumBytesRead = ui32BytesTransferred;
    763              }
    764          
    765              return ui32ErrorStatus;
    766          } // read_nonblocking()
    767          
    768          //*****************************************************************************
    769          //
    770          // Attempt to write N bytes to the FIFO, but give up if there's no space.
    771          //
    772          //*****************************************************************************
    773          static uint32_t
    774          write_nonblocking(void *pHandle, uint8_t *pui8Data, uint32_t ui32NumBytes,
    775                            uint32_t *pui32NumBytesWritten)
    776          {
    777              uint32_t ui32ErrorStatus;
    778              uint32_t ui32BufferSpace;
    779              uint32_t ui32BytesTransferred;
    780          
    781              am_hal_uart_state_t *pState = (am_hal_uart_state_t *) pHandle;
    782          
    783              //
    784              // Check to make sure this is a valid handle.
    785              //
    786              if (!AM_HAL_UART_CHK_HANDLE(pHandle))
    787              {
    788                  return AM_HAL_STATUS_INVALID_HANDLE;
    789              }
    790          
    791              //
    792              // Let the caller know how much we transferred if they provided us with a
    793              // pointer.
    794              //
    795              if (pui32NumBytesWritten)
    796              {
    797                  *pui32NumBytesWritten = 0;
    798              }
    799          
    800              if (ui32NumBytes == 0)
    801              {
    802                  return AM_HAL_STATUS_SUCCESS;
    803              }
    804          
    805              //
    806              // Check to see if the circular transmit buffer has been enabled.
    807              //
    808              if (pState->bEnableTxQueue)
    809              {
    810                  //
    811                  // If it has, been enabled, write as much data to it as we can, and let
    812                  // the caller know how much that was.
    813                  //
    814                  ui32BufferSpace = am_hal_queue_space_left(&pState->sTxQueue);
    815          
    816                  ui32BytesTransferred = (ui32NumBytes < ui32BufferSpace ?
    817                                          ui32NumBytes : ui32BufferSpace);
    818          
    819                  am_hal_queue_item_add(&pState->sTxQueue, pui8Data, ui32BytesTransferred);
    820          
    821                  //
    822                  // Transfer as much data as possible from the queue to the fifo.
    823                  //
    824                  ui32ErrorStatus = tx_queue_update(pHandle);
    825                  RETURN_ON_ERROR(ui32ErrorStatus);
    826              }
    827              else
    828              {
    829                  //
    830                  // If the buffer isn't enabled, just write straight to the FIFO.
    831                  //
    832                  uart_fifo_write(pHandle, pui8Data, ui32NumBytes,
    833                                  &ui32BytesTransferred);
    834              }
    835          
    836              //
    837              // Let the caller know how much we transferred if they provided us with a
    838              // pointer.
    839              //
    840              if (pui32NumBytesWritten)
    841              {
    842                  *pui32NumBytesWritten = ui32BytesTransferred;
    843              }
    844          
    845              return AM_HAL_STATUS_SUCCESS;
    846          } // write_nonblocking()
    847          
    848          //*****************************************************************************
    849          //
    850          // This function will keep reading bytes until it either gets N bytes or runs
    851          // into an error.
    852          //
    853          //*****************************************************************************
    854          static uint32_t
    855          read_timeout(void *pHandle, uint8_t *pui8Data, uint32_t ui32NumBytes,
    856                       uint32_t *pui32NumBytesRead, uint32_t ui32TimeoutMs)
    857          {
    858              uint32_t ui32Status, ui32BytesRead, ui32RemainingBytes,
    859                       ui32TimeSpent, i;
    860          
    861              //
    862              // If we don't have a timeout, just pass this directly to the nonblocking
    863              // call.
    864              //
    865              if (ui32TimeoutMs == 0)
    866              {
    867                  return read_nonblocking(pHandle, pui8Data, ui32NumBytes,
    868                                          pui32NumBytesRead);
    869              }
    870          
    871              i = 0;
    872              ui32RemainingBytes = ui32NumBytes;
    873              ui32TimeSpent = 0;
    874          
    875              //
    876              // Loop until we're done reading. This will either be because we hit a
    877              // timeout, or we got the right number of bytes. If the caller specified
    878              // "wait forever", then don't check the timeout.
    879              //
    880              while (ui32RemainingBytes && (ui32TimeSpent < ui32TimeoutMs))
    881              {
    882                  //
    883                  // Read as much as we can.
    884                  //
    885                  ui32BytesRead = 0;
    886                  ui32Status = read_nonblocking(pHandle, &pui8Data[i],
    887                                                ui32RemainingBytes,
    888                                                &ui32BytesRead);
    889                  //
    890                  // Update the tracking variables.
    891                  //
    892                  i += ui32BytesRead;
    893                  ui32RemainingBytes -= ui32BytesRead;
    894          
    895                  if (ui32Status != AM_HAL_STATUS_SUCCESS)
    896                  {
    897                      if (pui32NumBytesRead)
    898                      {
    899                          *pui32NumBytesRead = i;
    900                      }
    901          
    902                      return ui32Status;
    903                  }
    904          
    905                  //
    906                  // Update the timeout.
    907                  //
    908                  if (ui32RemainingBytes)
    909                  {
    910                      am_hal_flash_delay(FLASH_CYCLES_US(1));
    911          
    912                      if (ui32TimeoutMs != AM_HAL_UART_WAIT_FOREVER)
    913                      {
    914                          ui32TimeSpent++;
    915                      }
    916                  }
    917              }
    918          
    919              if (pui32NumBytesRead)
    920              {
    921                  *pui32NumBytesRead = i;
    922              }
    923          
    924              return AM_HAL_STATUS_SUCCESS;
    925          } // read_timeout()
    926          
    927          //*****************************************************************************
    928          //
    929          // This function will keep writing bytes until it either sends N bytes or runs
    930          // into an error.
    931          //
    932          //*****************************************************************************
    933          static uint32_t
    934          write_timeout(void *pHandle, uint8_t *pui8Data, uint32_t ui32NumBytes,
    935                        uint32_t *pui32NumBytesWritten, uint32_t ui32TimeoutMs)
    936          {
    937              uint32_t ui32Status, ui32BytesWritten, ui32RemainingBytes,
    938                       ui32TimeSpent, i;
    939          
    940              i = 0;
    941              ui32RemainingBytes = ui32NumBytes;
    942              ui32TimeSpent = 0;
    943          
    944              //
    945              // If we don't have a timeout, just pass this directly to the nonblocking
    946              // call.
    947              //
    948              if (ui32TimeoutMs == 0)
    949              {
    950                  return write_nonblocking(pHandle, pui8Data, ui32NumBytes,
    951                                           pui32NumBytesWritten);
    952              }
    953          
    954              //
    955              // Loop until we're done write. This will either be because we hit a
    956              // timeout, or we sent the right number of bytes. If the caller specified
    957              // "wait forever", then don't check the timeout.
    958              //
    959              while (ui32RemainingBytes && (ui32TimeSpent < ui32TimeoutMs))
    960              {
    961                  //
    962                  // Write as much as we can.
    963                  //
    964                  ui32BytesWritten = 0;
    965                  ui32Status = write_nonblocking(pHandle, &pui8Data[i],
    966                                                 ui32RemainingBytes,
    967                                                 &ui32BytesWritten);
    968                  //
    969                  // Update the tracking variables.
    970                  //
    971                  i += ui32BytesWritten;
    972                  ui32RemainingBytes -= ui32BytesWritten;
    973          
    974                  if (ui32Status != AM_HAL_STATUS_SUCCESS)
    975                  {
    976                      if (pui32NumBytesWritten)
    977                      {
    978                          *pui32NumBytesWritten = i;
    979                      }
    980          
    981                      return ui32Status;
    982                  }
    983          
    984                  //
    985                  // Update the timeout.
    986                  //
    987                  if (ui32RemainingBytes)
    988                  {
    989                      am_hal_flash_delay(FLASH_CYCLES_US(1));
    990          
    991                      if (ui32TimeoutMs != AM_HAL_UART_WAIT_FOREVER)
    992                      {
    993                          ui32TimeSpent++;
    994                      }
    995                  }
    996              }
    997          
    998              if (pui32NumBytesWritten)
    999              {
   1000                  *pui32NumBytesWritten = i;
   1001              }
   1002          
   1003              return AM_HAL_STATUS_SUCCESS;
   1004          } // write_timeout()
   1005          
   1006          //*****************************************************************************
   1007          //
   1008          // Send or receive bytes.
   1009          //
   1010          //*****************************************************************************
   1011          uint32_t
   1012          am_hal_uart_transfer(void *pHandle, const am_hal_uart_transfer_t *pTransfer)
   1013          {
   1014              //
   1015              // Pick the right function to use based on the transfer structure.
   1016              //
   1017              if (pTransfer->ui32Direction == AM_HAL_UART_WRITE)
   1018              {
   1019                  return write_timeout(pHandle,
   1020                                       pTransfer->pui8Data,
   1021                                       pTransfer->ui32NumBytes,
   1022                                       pTransfer->pui32BytesTransferred,
   1023                                       pTransfer->ui32TimeoutMs);
   1024              }
   1025              else if (pTransfer->ui32Direction == AM_HAL_UART_READ)
   1026              {
   1027                  return read_timeout(pHandle,
   1028                                      pTransfer->pui8Data,
   1029                                      pTransfer->ui32NumBytes,
   1030                                      pTransfer->pui32BytesTransferred,
   1031                                      pTransfer->ui32TimeoutMs);
   1032              }
   1033          
   1034              return AM_HAL_STATUS_INVALID_OPERATION;
   1035          } // am_hal_uart_transfer()
   1036          
   1037          //*****************************************************************************
   1038          //
   1039          // Wait for all of the traffic in the TX pipeline to be sent.
   1040          //
   1041          //*****************************************************************************
   1042          uint32_t
   1043          am_hal_uart_tx_flush(void *pHandle)
   1044          {
   1045              am_hal_uart_state_t *pState = (am_hal_uart_state_t *) pHandle;
   1046              uint32_t ui32Module = pState->ui32Module;
   1047          
   1048              //
   1049              // If we have a TX queue, we should wait for it to empty.
   1050              //
   1051              if (pState->bEnableTxQueue)
   1052              {
   1053                  while (am_hal_queue_data_left(&(pState->sTxQueue)))
   1054                  {
   1055                      ONE_BYTE_DELAY(pState);
   1056                  }
   1057              }
   1058          
   1059              //
   1060              // Wait for the TX busy bit to go low.
   1061              //
   1062              while ( UARTn(ui32Module)->FR_b.BUSY )
   1063              {
   1064                  ONE_BYTE_DELAY(pState);
   1065              }
   1066          
   1067              return AM_HAL_STATUS_SUCCESS;
   1068          } // am_hal_uart_tx_flush()
   1069          
   1070          //*****************************************************************************
   1071          //
   1072          // Return the most recent set of UART flags.
   1073          //
   1074          //*****************************************************************************
   1075          uint32_t
   1076          am_hal_uart_flags_get(void *pHandle, uint32_t *ui32Flags)
   1077          {
   1078              am_hal_uart_state_t *pState = (am_hal_uart_state_t *) pHandle;
   1079              uint32_t ui32Module = pState->ui32Module;
   1080          
   1081              //
   1082              // Check to make sure this is a valid handle.
   1083              //
   1084              if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   1085              {
   1086                  return AM_HAL_STATUS_INVALID_HANDLE;
   1087              }
   1088          
   1089              return UARTn(ui32Module)->FR;
   1090          } // am_hal_uart_flags_get()
   1091          
   1092          //*****************************************************************************
   1093          //
   1094          // Empty the UART RX FIFO, and place the data into the RX queue.
   1095          //
   1096          //*****************************************************************************
   1097          static uint32_t
   1098          rx_queue_update(void *pHandle)
   1099          {
   1100              am_hal_uart_state_t *pState = (am_hal_uart_state_t *) pHandle;
   1101          
   1102              uint8_t pui8Data[AM_HAL_UART_FIFO_MAX];
   1103              uint32_t ui32BytesTransferred;
   1104              uint32_t ui32ErrorStatus;
   1105          
   1106              AM_CRITICAL_BEGIN
   1107          
   1108              //
   1109              // Read as much of the FIFO as we can.
   1110              //
   1111              ui32ErrorStatus = uart_fifo_read(pHandle, pui8Data, AM_HAL_UART_FIFO_MAX,
   1112                                               &ui32BytesTransferred);
   1113              //
   1114              // If we were successful, go ahead and transfer the data along to the
   1115              // buffer.
   1116              //
   1117              if (ui32ErrorStatus == AM_HAL_STATUS_SUCCESS)
   1118              {
   1119                  if (!am_hal_queue_item_add(&pState->sRxQueue, pui8Data,
   1120                                             ui32BytesTransferred))
   1121                  {
   1122                      ui32ErrorStatus = AM_HAL_UART_STATUS_RX_QUEUE_FULL;
   1123                  }
   1124              }
   1125          
   1126              AM_CRITICAL_END
   1127          
   1128              return ui32ErrorStatus;
   1129          } // rx_queue_update()
   1130          
   1131          //*****************************************************************************
   1132          //
   1133          // Transfer as much data as possible from the TX queue to the TX FIFO.
   1134          //
   1135          //*****************************************************************************
   1136          static uint32_t
   1137          tx_queue_update(void *pHandle)
   1138          {
   1139              am_hal_uart_state_t *pState = (am_hal_uart_state_t *) pHandle;
   1140              uint32_t ui32Module = pState->ui32Module;
   1141          
   1142              uint8_t pui8Data;
   1143              uint32_t ui32BytesTransferred;
   1144              uint32_t ui32ErrorStatus = AM_HAL_STATUS_SUCCESS;
   1145          
   1146              AM_CRITICAL_BEGIN
   1147          
   1148              //
   1149              // Loop as long as the TX fifo isn't full yet.
   1150              //
   1151              while ( !UARTn(ui32Module)->FR_b.TXFF )
   1152              {
   1153                  //
   1154                  // Attempt to grab an item from the queue, and add it to the fifo.
   1155                  //
   1156                  if (am_hal_queue_item_get(&pState->sTxQueue, &pui8Data, 1))
   1157                  {
   1158                      ui32ErrorStatus = uart_fifo_write(pHandle, &pui8Data, 1,
   1159                                                        &ui32BytesTransferred);
   1160          
   1161                      if (ui32ErrorStatus != AM_HAL_STATUS_SUCCESS)
   1162                      {
   1163                          break;
   1164                      }
   1165                  }
   1166                  else
   1167                  {
   1168                      //
   1169                      // If we didn't get anything from the FIFO, we can just return.
   1170                      //
   1171                      break;
   1172                  }
   1173              }
   1174          
   1175              AM_CRITICAL_END
   1176          
   1177              return ui32ErrorStatus;
   1178          } // tx_queue_update()
   1179          
   1180          //*****************************************************************************
   1181          //
   1182          // Interrupt service
   1183          //
   1184          //*****************************************************************************
   1185          uint32_t
   1186          am_hal_uart_interrupt_service(void *pHandle, uint32_t ui32Status, uint32_t *pui32UartTxIdle)
   1187          {
   1188              am_hal_uart_state_t *pState = (am_hal_uart_state_t *) pHandle;
   1189              uint32_t ui32Module = pState->ui32Module;
   1190              uint32_t ui32ErrorStatus;
   1191          
   1192              if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   1193              {
   1194                  return AM_HAL_STATUS_INVALID_HANDLE;
   1195              }
   1196          
   1197              //
   1198              // Check to see if we have filled the Rx FIFO past the configured limit, or
   1199              // if we have an 'old' character or two sitting in the FIFO.
   1200              //
   1201              if ((ui32Status & (UART0_IES_RXRIS_Msk | UART0_IES_RTRIS_Msk)) &&
   1202                  pState->bEnableRxQueue)
   1203              {
   1204                  ui32ErrorStatus = rx_queue_update(pHandle);
   1205                  RETURN_ON_ERROR(ui32ErrorStatus);
   1206              }
   1207          
   1208              //
   1209              // Check to see if our TX buffer has been recently emptied. If so, we
   1210              // should refill it from the TX ring buffer.
   1211              //
   1212              if ((ui32Status & UART0_IES_TXRIS_Msk) && pState->bEnableTxQueue)
   1213              {
   1214                  ui32ErrorStatus = tx_queue_update(pHandle);
   1215                  RETURN_ON_ERROR(ui32ErrorStatus);
   1216              }
   1217          
   1218              //
   1219              // If this pointer is null, we can just return success now. There is no
   1220              // need to figure out if the UARt is idle.
   1221              //
   1222              if (pui32UartTxIdle == 0)
   1223              {
   1224                  return AM_HAL_STATUS_SUCCESS;
   1225              }
   1226          
   1227              //
   1228              // Check to see if we should report the UART TX-side idle. This is true if
   1229              // the queue is empty and the BUSY bit is low. The check is complicated
   1230              // because we don't want to check the queue status unless queues have been
   1231              // configured.
   1232              //
   1233              if (pState->bEnableTxQueue)
   1234              {
   1235                  if ( am_hal_queue_empty(&(pState->sTxQueue) )   &&
   1236                       ( UARTn(ui32Module)->FR_b.BUSY == false ) )
   1237                  {
   1238                      *pui32UartTxIdle = true;
   1239                  }
   1240              }
   1241              else if ( UARTn(ui32Module)->FR_b.BUSY == false )
   1242              {
   1243                  *pui32UartTxIdle = true;
   1244              }
   1245              else
   1246              {
   1247                  *pui32UartTxIdle = false;
   1248              }
   1249          
   1250              return AM_HAL_STATUS_SUCCESS;
   1251          } // am_hal_uart_interrupt_service()
   1252          
   1253          //*****************************************************************************
   1254          //
   1255          // Interrupt enable.
   1256          //
   1257          //*****************************************************************************
   1258          uint32_t
   1259          am_hal_uart_interrupt_enable(void *pHandle, uint32_t ui32IntMask)
   1260          {
   1261              am_hal_uart_state_t *pState = (am_hal_uart_state_t *) pHandle;
   1262              uint32_t ui32Module = pState->ui32Module;
   1263          
   1264              if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   1265              {
   1266                  return AM_HAL_STATUS_INVALID_HANDLE;
   1267              }
   1268          
   1269              UARTn(ui32Module)->IER |= ui32IntMask;
   1270          
   1271              return AM_HAL_STATUS_SUCCESS;
   1272          } // am_hal_uart_interrupt_enable()
   1273          
   1274          //*****************************************************************************
   1275          //
   1276          // Interrupt disable.
   1277          //
   1278          //*****************************************************************************
   1279          uint32_t
   1280          am_hal_uart_interrupt_disable(void *pHandle, uint32_t ui32IntMask)
   1281          {
   1282              am_hal_uart_state_t *pState = (am_hal_uart_state_t *) pHandle;
   1283              uint32_t ui32Module = pState->ui32Module;
   1284          
   1285              if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   1286              {
   1287                  return AM_HAL_STATUS_INVALID_HANDLE;
   1288              }
   1289          
   1290              UARTn(ui32Module)->IER &= ~ui32IntMask;
   1291          
   1292              return AM_HAL_STATUS_SUCCESS;
   1293          } // am_hal_uart_interrupt_disable()
   1294          
   1295          //*****************************************************************************
   1296          //
   1297          // Interrupt clear.
   1298          //
   1299          //*****************************************************************************
   1300          uint32_t
   1301          am_hal_uart_interrupt_clear(void *pHandle, uint32_t ui32IntMask)
   1302          {
   1303              am_hal_uart_state_t *pState = (am_hal_uart_state_t *) pHandle;
   1304              uint32_t ui32Module = pState->ui32Module;
   1305          
   1306              if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   1307              {
   1308                  return AM_HAL_STATUS_INVALID_HANDLE;
   1309              }
   1310          
   1311              UARTn(ui32Module)->IEC = ui32IntMask;
   1312          
   1313              return AM_HAL_STATUS_SUCCESS;
   1314          } // am_hal_uart_interrupt_clear()
   1315          
   1316          //*****************************************************************************
   1317          //
   1318          // Returns the interrupt status.
   1319          //
   1320          //*****************************************************************************
   1321          uint32_t
   1322          am_hal_uart_interrupt_status_get(void *pHandle, uint32_t *pui32Status, bool bEnabledOnly)
   1323          {
   1324              am_hal_uart_state_t *pState = (am_hal_uart_state_t *) pHandle;
   1325              uint32_t ui32Module = pState->ui32Module;
   1326          
   1327              if (!AM_HAL_UART_CHK_HANDLE(pHandle))
   1328              {
   1329                  return AM_HAL_STATUS_INVALID_HANDLE;
   1330              }
   1331          
   1332              //
   1333              // If requested, only return the interrupts that are enabled.
   1334              //
   1335              *pui32Status = bEnabledOnly ? UARTn(ui32Module)->MIS : UARTn(ui32Module)->IES;
   1336          
   1337              return AM_HAL_STATUS_SUCCESS;
   1338          } // am_hal_uart_interrupt_status_get()

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   am_hal_uart_configure
        40   -> am_hal_interrupt_master_disable
        40   -> am_hal_interrupt_master_set
        40   -> buffer_configure
        40   -> config_baudrate
       0   am_hal_uart_deinitialize
       8   am_hal_uart_flags_get
       8   am_hal_uart_initialize
       8   am_hal_uart_interrupt_clear
      12   am_hal_uart_interrupt_disable
      12   am_hal_uart_interrupt_enable
      32   am_hal_uart_interrupt_service
        32   -> rx_queue_update
        32   -> tx_queue_update
      12   am_hal_uart_interrupt_status_get
      32   am_hal_uart_power_control
        32   -> am_hal_interrupt_master_disable
        32   -> am_hal_interrupt_master_set
        32   -> am_hal_pwrctrl_periph_disable
        32   -> am_hal_pwrctrl_periph_enable
        32   -> am_hal_uart_interrupt_clear
      16   am_hal_uart_transfer
        16   -> read_timeout
        16   -> write_timeout
      16   am_hal_uart_tx_flush
        16   -> am_hal_flash_delay
      32   buffer_configure
        32   -> am_hal_queue_init
        32   -> am_hal_uart_interrupt_disable
        32   -> am_hal_uart_interrupt_enable
      32   config_baudrate
      40   read_nonblocking
        40   -> am_hal_queue_item_get
        40   -> rx_queue_update
        40   -> uart_fifo_read
      48   read_timeout
        48   -> am_hal_flash_delay
        48   -> read_nonblocking
      56   rx_queue_update
        56   -> am_hal_interrupt_master_disable
        56   -> am_hal_interrupt_master_set
        56   -> am_hal_queue_item_add
        56   -> uart_fifo_read
      32   tx_queue_update
        32   -> am_hal_interrupt_master_disable
        32   -> am_hal_interrupt_master_set
        32   -> am_hal_queue_item_get
        32   -> uart_fifo_write
      24   uart_fifo_read
      20   uart_fifo_write
      40   write_nonblocking
        40   -> am_hal_queue_item_add
        40   -> tx_queue_update
        40   -> uart_fifo_write
      48   write_timeout
        48   -> am_hal_flash_delay
        48   -> write_nonblocking


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_10
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable18_6
       4  ??DataTable18_7
       4  ??DataTable18_8
       4  ??DataTable18_9
     436  am_hal_uart_configure
      46  am_hal_uart_deinitialize
      44  am_hal_uart_flags_get
     126  am_hal_uart_initialize
      46  am_hal_uart_interrupt_clear
      58  am_hal_uart_interrupt_disable
      58  am_hal_uart_interrupt_enable
     180  am_hal_uart_interrupt_service
      70  am_hal_uart_interrupt_status_get
     340  am_hal_uart_power_control
      58  am_hal_uart_transfer
     114  am_hal_uart_tx_flush
     190  buffer_configure
     184  config_baudrate
     200  g_am_hal_uart_states
     140  read_nonblocking
     134  read_timeout
      64  rx_queue_update
      82  tx_queue_update
      88  uart_fifo_read
      64  uart_fifo_write
     138  write_nonblocking
     134  write_timeout

 
   200 bytes in section .bss
 2 838 bytes in section .text
 
 2 838 bytes of CODE memory
   200 bytes of DATA memory

Errors: none
Warnings: none
