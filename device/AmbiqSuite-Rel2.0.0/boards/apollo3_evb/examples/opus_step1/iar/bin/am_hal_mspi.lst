###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         12/Mar/2019  10:07:09
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_mspi.c
#    Command line =  
#        -f C:\temp\EW872F.tmp
#        (C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_mspi.c
#        -D iar -D AM_PART_APOLLO3 -D AM_PACKAGE_BGA -lcN
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --diag_suppress Pa050 -o
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\utils\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\ARM\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\AmbiqMicro\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\mcu\apollo3\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\devices\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\bsp\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\sound\
#        -On)
#    Locale       =  C
#    List file    =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_mspi.lst
#    Object file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_mspi.o
#
###############################################################################

C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_mspi.c
      1          //*****************************************************************************
      2          //
      3          //  am_hal_mspi.c
      4          //! @file
      5          //!
      6          //! @brief Functions for interfacing with the MSPI.
      7          //!
      8          //! @addtogroup mcuctrl3 Multi-bit SPI (MSPI)
      9          //! @ingroup apollo3hal
     10          //! @{
     11          //
     12          //*****************************************************************************
     13          
     14          //*****************************************************************************
     15          //
     16          // Copyright (c) 2019, Ambiq Micro
     17          // All rights reserved.
     18          // 
     19          // Redistribution and use in source and binary forms, with or without
     20          // modification, are permitted provided that the following conditions are met:
     21          // 
     22          // 1. Redistributions of source code must retain the above copyright notice,
     23          // this list of conditions and the following disclaimer.
     24          // 
     25          // 2. Redistributions in binary form must reproduce the above copyright
     26          // notice, this list of conditions and the following disclaimer in the
     27          // documentation and/or other materials provided with the distribution.
     28          // 
     29          // 3. Neither the name of the copyright holder nor the names of its
     30          // contributors may be used to endorse or promote products derived from this
     31          // software without specific prior written permission.
     32          // 
     33          // Third party software included in this distribution is subject to the
     34          // additional license terms as defined in the /docs/licenses directory.
     35          // 
     36          // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     37          // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     38          // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     39          // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     40          // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     41          // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     42          // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     43          // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     44          // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     45          // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     46          // POSSIBILITY OF SUCH DAMAGE.
     47          //
     48          // This is part of revision v2.0.0 of the AmbiqSuite Development Package.
     49          //
     50          //*****************************************************************************
     51          
     52          #include <stdint.h>
     53          #include <stdbool.h>
     54          #include "am_mcu_apollo.h"
     55          
     56          //*****************************************************************************
     57          //
     58          // Private Types.
     59          //
     60          //*****************************************************************************
     61          
     62          #define AM_HAL_MAGIC_MSPI               0xBEBEBE
     63          #define AM_HAL_MSPI_CHK_HANDLE(h)       ((h) && ((am_hal_handle_prefix_t *)(h))->s.bInit && (((am_hal_handle_prefix_t *)(h))->s.magic == AM_HAL_MAGIC_MSPI))
     64          #define AM_HAL_MSPI_HW_IDX_MAX          (AM_REG_MSPI_CQCURIDX_CQCURIDX_M >> AM_REG_MSPI_CQCURIDX_CQCURIDX_S)    // 8 bit value
     65          #define AM_HAL_MSPI_MAX_CQ_ENTRIES      (256)
     66          
     67          
     68          
     69          // For MSPI - Need to Set the flag for unpausing
     70          #define AM_HAL_MSPI_SC_PAUSE_CQ         AM_HAL_MSPI_SC_PAUSE(AM_HAL_MSPI_PAUSE_FLAG_CQ)
     71          #define AM_HAL_MSPI_SC_PAUSE_SEQLOOP    AM_HAL_MSPI_SC_PAUSE(AM_HAL_MSPI_PAUSE_FLAG_SEQLOOP)
     72          #define AM_HAL_MSPI_SC_UNPAUSE_CQ       AM_HAL_MSPI_SC_UNPAUSE(AM_HAL_MSPI_PAUSE_FLAG_CQ)
     73          #define AM_HAL_MSPI_SC_UNPAUSE_SEQLOOP  AM_HAL_MSPI_SC_UNPAUSE(AM_HAL_MSPI_PAUSE_FLAG_SEQLOOP)
     74          #define AM_HAL_MSPI_SC_PAUSE_BLOCK      AM_HAL_MSPI_SC_PAUSE(AM_HAL_MSPI_PAUSE_FLAG_BLOCK)
     75          #define AM_HAL_MSPI_SC_UNPAUSE_BLOCK    AM_HAL_MSPI_SC_UNPAUSE(AM_HAL_MSPI_PAUSE_FLAG_BLOCK)
     76          
     77          
     78          // Max time to wait when attempting to pause the command queue
     79          #define AM_HAL_MSPI_MAX_PAUSE_DELAY     (100*1000) // 100ms
     80          
     81          //
     82          // Command Queue entry structure for DMA transfer.
     83          //
     84          typedef struct
     85          {
     86          #if MSPI_USE_CQ
     87              uint32_t                    ui32PAUSENAddr;
     88              uint32_t                    ui32PAUSEENVal;
     89              uint32_t                    ui32PAUSEN2Addr;
     90              uint32_t                    ui32PAUSEEN2Val;
     91          #endif
     92          #if !MSPI_USE_CQ
     93              // Need to disable the DMA before reconfiguring it
     94              uint32_t                    ui32DMACFG2Addr;
     95              uint32_t                    ui32DMACFG2Val;
     96          #endif
     97              uint32_t                    ui32DMATARGADDRAddr;
     98              uint32_t                    ui32DMATARGADDRVal;
     99              uint32_t                    ui32DMADEVADDRAddr;
    100              uint32_t                    ui32DMADEVADDRVal;
    101              uint32_t                    ui32DMATOTCOUNTAddr;
    102              uint32_t                    ui32DMATOTCOUNTVal;
    103              uint32_t                    ui32DMACFG1Addr;
    104              uint32_t                    ui32DMACFG1Val;
    105          #if MSPI_USE_CQ
    106              // Need to disable the DMA to prepare for next reconfig
    107              // Need to have this following the DMAEN for CMDQ
    108              uint32_t                    ui32DMACFG2Addr;
    109              uint32_t                    ui32DMACFG2Val;
    110              uint32_t                    ui32SETCLRAddr;
    111              uint32_t                    ui32SETCLRVal;
    112          #endif
    113          } am_hal_mspi_cq_dma_entry_t;
    114          
    115          //
    116          // structure for Hi Prio DMA transfer.
    117          //
    118          typedef struct
    119          {
    120              uint32_t                    ui32DMATARGADDRVal;
    121              uint32_t                    ui32DMADEVADDRVal;
    122              uint32_t                    ui32DMATOTCOUNTVal;
    123              uint32_t                    ui32DMACFG1Val;
    124              am_hal_mspi_callback_t      pfnCallback;
    125              void                        *pCallbackCtxt;
    126          } am_hal_mspi_dma_entry_t;
    127          
    128          //
    129          // Command Queue entry structure for Sequence Repeat
    130          //
    131          typedef struct
    132          {
    133              uint32_t                    ui32PAUSENAddr;
    134              uint32_t                    ui32PAUSEENVal;
    135              uint32_t                    ui32PAUSEN2Addr;
    136              uint32_t                    ui32PAUSEEN2Val;
    137              uint32_t                    ui32SETCLRAddr;
    138              uint32_t                    ui32SETCLRVal;
    139          } am_hal_mspi_cq_loop_entry_t;
    140          
    141          //
    142          // Command Queue entry structure for PIO transfer.
    143          //
    144          typedef struct
    145          {
    146              uint32_t                    ui32ADDRAddr;
    147              uint32_t                    ui32ADDRVal;
    148              uint32_t                    ui32INSTRAddr;
    149              uint32_t                    ui32INSTRVal;
    150              uint32_t                    ui32CTRLAddr;
    151              uint32_t                    ui32CTRLVal;
    152          } am_hal_mspi_cq_pio_entry_t;
    153          
    154          typedef struct
    155          {
    156              bool        bValid;
    157              uint32_t    regCFG;
    158              uint32_t    regMSPICFG;
    159              uint32_t    regPADCFG;
    160              uint32_t    regPADOUTEN;
    161              uint32_t    regFLASH;
    162              uint32_t    regSCRAMBLING;
    163              uint32_t    regCQCFG;
    164              uint32_t    regCQADDR;
    165              uint32_t    regCQPAUSE;
    166              uint32_t    regCQCURIDX;
    167              uint32_t    regCQENDIDX;
    168              uint32_t    regINTEN;
    169              // TODO: May be no need to preserve these values, as they are constants anyways?
    170              uint32_t    regDMABCOUNT;
    171              uint32_t    regDMATHRESH;
    172          } am_hal_mspi_register_state_t;
    173          
    174          //
    175          // Command Queue control structure.
    176          //
    177          typedef struct
    178          {
    179              void     *pCmdQHdl;
    180          } am_hal_mspi_CQ_t;
    181          
    182          typedef enum
    183          {
    184              AM_HAL_MSPI_SEQ_NONE,
    185              AM_HAL_MSPI_SEQ_UNDER_CONSTRUCTION,
    186              AM_HAL_MSPI_SEQ_RUNNING,
    187          } am_hal_mspi_seq_e;
    188          
    189          //
    190          // MSPI State structure.
    191          //
    192          typedef struct
    193          {
    194              //
    195              // Handle validation prefix.
    196              //
    197              am_hal_handle_prefix_t  prefix;
    198          
    199              //
    200              // Physical module number.
    201              //
    202              uint32_t                      ui32Module;
    203          
    204              //
    205              // Selected flash device configuration.
    206              //
    207              am_hal_mspi_device_e          eDeviceConfig;
    208          
    209              //
    210              // Clock frequency
    211              //
    212              am_hal_mspi_clock_e           eClockFreq;
    213          
    214              //
    215              // Endianess of the FIFO interface.
    216              //
    217              bool                          bBigEndian;
    218          
    219              //
    220              // Delay timeout value.
    221              //
    222              uint32_t                      waitTimeout;
    223              // DMA Transfer Control Buffer size in words.
    224              uint32_t                      ui32TCBSize;
    225          
    226              // DMA Transfer Control Buffer
    227              uint32_t                      *pTCB;
    228          
    229              uint32_t ui32LastIdxProcessed;
    230              uint32_t ui32NumCQEntries;
    231              uint32_t ui32TxnInt;
    232          
    233              //
    234              // Stores the CQ callbacks.
    235              //
    236              am_hal_mspi_callback_t pfnCallback[AM_HAL_MSPI_MAX_CQ_ENTRIES];
    237          
    238              void                   *pCallbackCtxt[AM_HAL_MSPI_MAX_CQ_ENTRIES];
    239          #if MSPI_USE_CQ
    240              //
    241              // Command Queue.
    242              //
    243              am_hal_mspi_CQ_t              CQ;
    244              // To support sequence
    245              am_hal_mspi_seq_e             eSeq;
    246              bool                          bAutonomous;
    247              uint32_t                      ui32NumTransactions;
    248              volatile bool                 bRestart;
    249              uint32_t                      block;
    250              // To support high priority transactions - out of band
    251              // High Priority DMA transactions
    252              volatile bool                 bHP;
    253              uint32_t                      ui32NumHPEntries;
    254              uint32_t                      ui32NumHPPendingEntries;
    255              uint32_t                      ui32MaxHPTransactions;
    256              uint32_t                      ui32NextHPIdx;
    257              uint32_t                      ui32LastHPIdxProcessed;
    258              am_hal_mspi_dma_entry_t       *pHPTransactions;
    259          #else
    260              uint32_t                      ui32MaxTransactions;
    261              uint32_t                      ui32NextIdx;
    262              am_hal_mspi_cq_dma_entry_t    *pTransactions;
    263          #endif
    264          
    265              //
    266              // MSPI Capabilities.
    267              //
    268              am_hal_mspi_capabilities_t    capabilities;
    269          
    270              // Power Save-Restore register state
    271              am_hal_mspi_register_state_t  registerState;
    272          } am_hal_mspi_state_t;
    273          
    274          //*****************************************************************************
    275          //
    276          // Global Variables.
    277          //
    278          //*****************************************************************************
    279          am_hal_mspi_state_t             g_MSPIState[AM_REG_MSPI_NUM_MODULES];
    280          
    281          
    282          #if !MSPI_USE_CQ
    283          void (*g_pfnDMACallback[AM_REG_MSPI_NUM_MODULES])(void);
    284          void *g_pCallbackCtxt[AM_REG_MSPI_NUM_MODULES];
    285          #endif //!MSPI_USE_CQ
    286          
    287          //*****************************************************************************
    288          //
    289          // Internal Functions.
    290          //
    291          //*****************************************************************************
    292          static uint32_t
    293          get_pause_val(am_hal_mspi_state_t *pMSPIState, uint32_t pause)
    294          {
    295              uint32_t retval;
    296              switch (pMSPIState->block)
    297              {
    298                  case 1:
    299                      // Pause the CQ till the whole block is built
    300                      retval = pause | AM_HAL_MSPI_CQP_PAUSE_DEFAULT | AM_HAL_MSPI_PAUSE_FLAG_BLOCK;
    301                      pMSPIState->block = 2;
    302                      break;
    303                  case 2:
    304                      // No pausing allowed
    305                      retval = AM_HAL_MSPI_PAUSE_DEFAULT;
    306                      break;
    307                  default: // case 0
    308                      retval = pause | AM_HAL_MSPI_CQP_PAUSE_DEFAULT;
    309              }
    310              return retval;
    311          }
    312          
    313          uint32_t
    314          build_dma_cmdlist(am_hal_mspi_state_t *pMSPIState,
    315                            am_hal_mspi_trans_e eMode,
    316                            void  *pCQEntry,
    317                            void  *pTransaction)
    318          {
    319              uint32_t ui32Module = pMSPIState->ui32Module;
    320          
    321              switch(eMode)
    322              {
    323                  case AM_HAL_MSPI_TRANS_PIO:
    324                  {
    325                      am_hal_mspi_cq_pio_entry_t    *pPIOEntry = (am_hal_mspi_cq_pio_entry_t*)pCQEntry;
    326                      am_hal_mspi_pio_transfer_t    *pPIOTrans = (am_hal_mspi_pio_transfer_t*)pTransaction;
    327          
    328                      //
    329                      // Perform some sanity checks on the transaction.
    330                      //
    331                      if (pPIOTrans->ui32NumBytes > 65535)
    332                      {
    333                        return AM_HAL_STATUS_OUT_OF_RANGE;
    334                      }
    335          
    336                      //
    337                      // Command to set the CTRL register.
    338                      //
    339                      pPIOEntry->ui32ADDRAddr            = (uint32_t)&MSPIn(ui32Module)->ADDR;
    340                      pPIOEntry->ui32ADDRVal             = _VAL2FLD(MSPI_ADDR_ADDR, pPIOTrans->ui32DeviceAddr);
    341                      pPIOEntry->ui32INSTRAddr           = (uint32_t)&MSPIn(ui32Module)->INSTR;
    342                      pPIOEntry->ui32INSTRVal            = _VAL2FLD(MSPI_INSTR_INSTR, pPIOTrans->ui16DeviceInstr);
    343                      pPIOEntry->ui32CTRLAddr            = (uint32_t)&MSPIn(ui32Module)->CTRL;
    344                      pPIOEntry->ui32CTRLVal             =
    345                          _VAL2FLD(MSPI_CTRL_XFERBYTES, pPIOTrans->ui32NumBytes)  |   // Set the number of bytes to transfer.
    346                          _VAL2FLD(MSPI_CTRL_PIOSCRAMBLE, pPIOTrans->bScrambling) |   // Set the scrambling if selected.
    347                          _VAL2FLD(MSPI_CTRL_TXRX, pPIOTrans->eDirection)         |   // Set transmit or receive operation.
    348                          _VAL2FLD(MSPI_CTRL_SENDI, pPIOTrans->bSendInstr)        |   // Enable sending the instruction.
    349                          _VAL2FLD(MSPI_CTRL_SENDA, pPIOTrans->bSendAddr)         |   // Enable sending the address.
    350                          _VAL2FLD(MSPI_CTRL_ENTURN, pPIOTrans->bTurnaround)      |   // Set the turn-around if needed.
    351                          _VAL2FLD(MSPI_CTRL_BIGENDIAN, pMSPIState->bBigEndian)   |   // Set the FIFO endian format.
    352                          _VAL2FLD(MSPI_CTRL_QUADCMD, pPIOTrans->bQuadCmd)        |   // Set the Quad Command if indicated.
    353                          _VAL2FLD(MSPI_CTRL_START, 1);                               // Start the transfer.
    354          
    355                  }
    356                  break;
    357                  case AM_HAL_MSPI_TRANS_DMA:
    358                  {
    359                      am_hal_mspi_cq_dma_entry_t    *pDMAEntry = (am_hal_mspi_cq_dma_entry_t *)pCQEntry;
    360                      am_hal_mspi_dma_transfer_t    *pDMATrans = (am_hal_mspi_dma_transfer_t *)pTransaction;
    361          
    362                      //
    363                      // Perform some sanity checks on the transaction.
    364                      //
    365                      if (pDMATrans->ui32TransferCount > 65535)
    366                      {
    367                        return AM_HAL_STATUS_OUT_OF_RANGE;
    368                      }
    369                      if (pMSPIState->block && (pDMATrans->ui32PauseCondition != 0))
    370                      {
    371                          // Paused operations not allowed in block mode
    372                          return AM_HAL_STATUS_INVALID_OPERATION;
    373                      }
    374          
    375                      //
    376                      // Command to set the DMACFG to disable DMA.
    377                      // Need to make sure we disable DMA before we can reprogram
    378                      //
    379                      pDMAEntry->ui32DMACFG2Addr     = (uint32_t)&MSPIn(ui32Module)->DMACFG;
    380                      pDMAEntry->ui32DMACFG2Val      = _VAL2FLD(MSPI_DMACFG_DMAEN, 0);
    381          
    382                      //
    383                      // Command to set the DMATARGADDR
    384                      //
    385                      pDMAEntry->ui32DMATARGADDRAddr = (uint32_t)&MSPIn(ui32Module)->DMATARGADDR;
    386                      pDMAEntry->ui32DMATARGADDRVal  = pDMATrans->ui32SRAMAddress;
    387          
    388                      //
    389                      // Command to set the DMADEVADDR
    390                      //
    391                      pDMAEntry->ui32DMADEVADDRAddr  = (uint32_t)&MSPIn(ui32Module)->DMADEVADDR;
    392                      pDMAEntry->ui32DMADEVADDRVal   = pDMATrans->ui32DeviceAddress;
    393          
    394                      //
    395                      // Command to set the DMATOTALCOUNT
    396                      //
    397                      pDMAEntry->ui32DMATOTCOUNTAddr = (uint32_t)&MSPIn(ui32Module)->DMATOTCOUNT;
    398                      pDMAEntry->ui32DMATOTCOUNTVal  = pDMATrans->ui32TransferCount;
    399          
    400                      //
    401                      // Command to set the DMACFG to start DMA.
    402                      //
    403                      pDMAEntry->ui32DMACFG1Addr     = (uint32_t)&MSPIn(ui32Module)->DMACFG;
    404                      pDMAEntry->ui32DMACFG1Val      =
    405                          _VAL2FLD(MSPI_DMACFG_DMAPWROFF, 0)   |  // DMA Auto Power-off not supported!
    406                          _VAL2FLD(MSPI_DMACFG_DMAPRI, pDMATrans->ui8Priority)    |
    407                          _VAL2FLD(MSPI_DMACFG_DMADIR, pDMATrans->eDirection)     |
    408                          _VAL2FLD(MSPI_DMACFG_DMAEN, 3);
    409          #if MSPI_USE_CQ
    410                      pDMAEntry->ui32PAUSENAddr = pDMAEntry->ui32PAUSEN2Addr = (uint32_t)&MSPIn(ui32Module)->CQPAUSE;
    411                      pDMAEntry->ui32PAUSEENVal = get_pause_val(pMSPIState, pDMATrans->ui32PauseCondition);
    412                      pDMAEntry->ui32PAUSEEN2Val = AM_HAL_MSPI_PAUSE_DEFAULT;
    413                      pDMAEntry->ui32SETCLRVal = pDMATrans->ui32StatusSetClr;
    414                      pDMAEntry->ui32SETCLRAddr = (uint32_t)&MSPIn(ui32Module)->CQSETCLEAR;
    415          #endif
    416                  }
    417                  break;
    418              }
    419          
    420              //
    421              // Return the status.
    422              //
    423              return AM_HAL_STATUS_SUCCESS;
    424          }
    425          
    426          //*****************************************************************************
    427          //
    428          //! @brief Writes data to the MSPI FIFO.
    429          //!
    430          //! @param ui32Module - Selects the MSPI module to use (zero or one).
    431          //! @param pui32Data - Pointer to an array of the data to be written.
    432          //! @param ui32NumBytes - Number of BYTES to copy into the FIFO.
    433          //!
    434          //! This function copies data from the array \e pui32Data into the MSPI FIFO.
    435          //!
    436          //! @return HAL status of the operation.
    437          //
    438          //*****************************************************************************
    439          static uint32_t
    440          mspi_fifo_write(uint32_t ui32Module, uint32_t *pui32Data,
    441                          uint32_t ui32NumBytes, uint32_t ui32Timeout)
    442          {
    443              uint32_t ui32Index;
    444              uint32_t ui32Status = AM_HAL_STATUS_SUCCESS;
    445          
    446              //
    447              // Validate parameters
    448              //
    449              if ( ui32Module >= AM_REG_MSPI_NUM_MODULES )
    450              {
    451                  return AM_HAL_STATUS_OUT_OF_RANGE;
    452              }
    453          
    454              //
    455              // Loop over the words in the array until we have the correct number of
    456              // bytes.
    457              //
    458              for ( ui32Index = 0; (4 * ui32Index) < ui32NumBytes; ui32Index++ )
    459              {
    460                  //
    461                  // Write the word to the FIFO.
    462                  //
    463                  MSPIn(ui32Module)->TXFIFO = pui32Data[ui32Index];
    464          
    465                  //
    466                  // Wait for the word to go out if there is no room in the FIFO.
    467                  //
    468                  ui32Status = am_hal_flash_delay_status_check(ui32Timeout,
    469                                                               (uint32_t)&MSPIn(ui32Module)->TXENTRIES,
    470                                                               MSPI_TXENTRIES_TXENTRIES_Msk,
    471                                                               _VAL2FLD(MSPI_TXENTRIES_TXENTRIES, AM_HAL_MSPI_MAX_FIFO_SIZE),
    472                                                               false);
    473              }
    474          
    475              //
    476              // Return the status.
    477              //
    478              return ui32Status;
    479          }
    480          
    481          //*****************************************************************************
    482          //
    483          //! @brief Reads data from the MSPI FIFO.
    484          //!
    485          //! @param ui32Module - Selects the IOM module to use (zero or one).
    486          //! @param pui32Data - Pointer to an array where the FIFO data will be copied.
    487          //! @param ui32NumBytes - Number of bytes to copy into array.
    488          //!
    489          //! This function copies data from the MSPI FIFO into the array \e pui32Data.
    490          //!
    491          //! @return HAL status of the operation.
    492          //
    493          //*****************************************************************************
    494          static uint32_t
    495          mspi_fifo_read(uint32_t ui32Module, uint32_t *pui32Data,
    496                         uint32_t ui32NumBytes, uint32_t ui32Timeout)
    497          {
    498              am_hal_mspi_buffer(4) sTempBuffer;
    499              uint32_t i, ui32NumWords, ui32Leftovers;
    500              uint32_t ui32Status;
    501          
    502              //
    503              // Validate parameters
    504              //
    505              if ( ui32Module >= AM_REG_MSPI_NUM_MODULES )
    506              {
    507                  return AM_HAL_STATUS_OUT_OF_RANGE;
    508              }
    509          
    510              //
    511              // Figure out how many whole words we're reading from the fifo, and how
    512              // many bytes will be left over when we're done.
    513              //
    514              ui32NumWords = ui32NumBytes / 4;
    515              ui32Leftovers = ui32NumBytes - (ui32NumWords * 4);
    516          
    517              //
    518              // Copy out as many full words as we can.
    519              //
    520              for ( i = 0; i < ui32NumWords; i++ )
    521              {
    522                  //
    523                  // Wait for additinal entries in the MSPI RX FIFO.
    524                  //
    525                  ui32Status = am_hal_flash_delay_status_check(ui32Timeout,
    526                                                               (uint32_t)&MSPIn(ui32Module)->RXENTRIES,
    527                                                               MSPI_RXENTRIES_RXENTRIES_Msk,
    528                                                               _VAL2FLD(MSPI_RXENTRIES_RXENTRIES, 0),
    529                                                               false);
    530          
    531                  //
    532                  // Check for timeout
    533                  //
    534                  if (AM_HAL_STATUS_SUCCESS != ui32Status)
    535                  {
    536                      return ui32Status;
    537                  }
    538          
    539                  //
    540                  // Copy data out of the FIFO, one word at a time.
    541                  //
    542                  pui32Data[i] = MSPIn(ui32Module)->RXFIFO;
    543              }
    544          
    545              //
    546              // If there were leftovers, we'll copy them carefully. Pull the last word
    547              // from the fifo (there should only be one) into a temporary buffer. Also,
    548              // create an 8-bit pointer to help us copy the remaining bytes one at a
    549              // time.
    550              //
    551              // Note: If the data buffer we were given was truly a word pointer like the
    552              // definition requests, we wouldn't need to do this. It's possible to call
    553              // this function with a re-cast or packed pointer instead though. If that
    554              // happens, we want to be careful not to overwrite any data that might be
    555              // sitting just past the end of the destination array.
    556              //
    557              if ( ui32Leftovers )
    558              {
    559                  //
    560                  // Wait for additinal entries in the MSPI RX FIFO.
    561                  //
    562                  ui32Status = am_hal_flash_delay_status_check(ui32Timeout,
    563                                                               (uint32_t)&MSPIn(ui32Module)->RXENTRIES,
    564                                                               MSPI_RXENTRIES_RXENTRIES_Msk,
    565                                                               _VAL2FLD(MSPI_RXENTRIES_RXENTRIES, 0),
    566                                                               false);
    567          
    568                  //
    569                  // Check for timeout
    570                  //
    571                  if (AM_HAL_STATUS_SUCCESS != ui32Status)
    572                  {
    573                      return ui32Status;
    574                  }
    575          
    576                  //
    577                  // Read the next word from the RX FIFO.
    578                  //
    579                  sTempBuffer.words[0] = MSPIn(ui32Module)->RXFIFO;
    580                  uint8_t *pui8Data;
    581                  pui8Data = (uint8_t *) (&pui32Data[i]);
    582          
    583                  //
    584                  // If we had leftover bytes, copy them out one byte at a time.
    585                  //
    586                  for ( int j = 0; j < ui32Leftovers; j++ )
    587                  {
    588                      pui8Data[j] = sTempBuffer.bytes[j];
    589                  }
    590              }
    591          
    592              return AM_HAL_STATUS_SUCCESS;
    593          }
    594          
    595          #if !MSPI_USE_CQ
    596          static void
    597          run_txn_cmdlist(void *pCQEntry, uint32_t numEntries)
    598          {
    599              uint32_t ix;
    600              am_hal_cmdq_entry_t *pCmd = (am_hal_cmdq_entry_t *)pCQEntry;
    601          
    602              for ( ix = 0; ix < numEntries; ix++, pCmd++ )
    603              {
    604                  *((uint32_t *)pCmd->address) = pCmd->value;
    605              }
    606          } // run_txn_cmdlist()
    607          
    608          static uint32_t
    609          mspi_dma_add_transaction(void *pHandle,
    610                                   am_hal_mspi_dma_transfer_t *psTransaction,
    611                                   am_hal_mspi_callback_t pfnCallback,
    612                                   void *pCallbackCtxt)
    613          {
    614              am_hal_mspi_state_t         *pMSPIState = (am_hal_mspi_state_t *)pHandle;
    615              am_hal_mspi_cq_dma_entry_t  *pCQEntry;
    616              uint32_t  index = pMSPIState->ui32NextIdx % pMSPIState->ui32MaxTransactions;
    617          
    618              //
    619              // Check to see if there is enough room in the queue
    620              //
    621              if ( pMSPIState->ui32NumCQEntries == pMSPIState->ui32MaxTransactions )
    622              {
    623                  return AM_HAL_STATUS_OUT_OF_RANGE;
    624              }
    625          
    626              pCQEntry = &pMSPIState->pTransactions[index];
    627          
    628          
    629              if (AM_HAL_STATUS_SUCCESS != build_dma_cmdlist(pMSPIState, AM_HAL_MSPI_TRANS_DMA, pCQEntry, (void *)psTransaction))
    630              {
    631                return AM_HAL_STATUS_FAIL;
    632              }
    633          
    634              //
    635              // Store the callback function pointer.
    636              //
    637              pMSPIState->pfnCallback[index] = pfnCallback;
    638              pMSPIState->pCallbackCtxt[index] = pCallbackCtxt;
    639              pMSPIState->ui32NextIdx++;
    640              return AM_HAL_STATUS_SUCCESS;
    641          } // am_hal_mspi_DmaAddTransaction()
    642          
    643          #else
    644          
    645          
    646          //*****************************************************************************
    647          //
    648          //! @brief Initializes the MSPI Command Queue.
    649          //!
    650          //! @param handle       - handle for the interface.
    651          //! @param ui32Length   - length of the SRAM Command Queue buffer in words.
    652          //! @param pTCB         - pointer to the SRAM to use for the Command Queue.
    653          //!
    654          //! This function initializes the global command queue structure.
    655          //!
    656          //! @return HAL status of the operation.
    657          //
    658          //
    659          //*****************************************************************************
    660          static uint32_t
    661          mspi_cq_init(uint32_t ui32Module, uint32_t ui32Length,
    662                       uint32_t *pTCB)
    663          {
    664              am_hal_cmdq_cfg_t cqCfg;
    665          
    666              cqCfg.pCmdQBuf = pTCB;
    667              cqCfg.cmdQSize = ui32Length / 2;
    668              cqCfg.priority = AM_HAL_CMDQ_PRIO_HI;
    669              return am_hal_cmdq_init((am_hal_cmdq_if_e)(AM_HAL_CMDQ_IF_MSPI + ui32Module),
    670                                      &cqCfg, &g_MSPIState[ui32Module].CQ.pCmdQHdl);
    671          }
    672          
    673          //*****************************************************************************
    674          //
    675          //! @brief Terminates the MSPI Command Queue.
    676          //!
    677          //! @param ui32Module   - MSPI instance.
    678          //!
    679          //! This function resets the global command queue structure.
    680          //!
    681          //! @return HAL status of the operation.
    682          //
    683          //
    684          //*****************************************************************************
    685          static uint32_t
    686          mspi_cq_term(void *pHandle)
    687          {
    688              am_hal_mspi_state_t           *pMSPIState = (am_hal_mspi_state_t *)pHandle;
    689              uint32_t                      ui32Module = pMSPIState->ui32Module;
    690          
    691              if (g_MSPIState[ui32Module].CQ.pCmdQHdl)
    692              {
    693                  am_hal_cmdq_term(g_MSPIState[ui32Module].CQ.pCmdQHdl, true);
    694                  g_MSPIState[ui32Module].CQ.pCmdQHdl = NULL;
    695              }
    696          
    697              //
    698              // Return the status.
    699              //
    700              return AM_HAL_STATUS_SUCCESS;
    701          }
    702          
    703          //*****************************************************************************
    704          //
    705          //! @brief Adds a transaction the MSPI Command Queue.
    706          //!
    707          //! @param handle       - handle for the interface.
    708          //! @param pTransaction - transaction to add to the CQ
    709          //! @param pfnCallback  - pointer the callback function to be executed when
    710          //!                       transaction is complete.
    711          //! @param pCallbackCtxt- pointer to the state/context to pass to callback
    712          //!                       function.
    713          //!
    714          //! This function copies data from the IOM FIFO into the array \e pui32Data.
    715          //! This is how input data from SPI or I2C transactions may be retrieved.
    716          //!
    717          //!
    718          //! @return HAL status of the operation.
    719          //
    720          //
    721          //*****************************************************************************
    722          static uint32_t
    723          mspi_cq_add_transaction(void *pHandle,
    724                                  void *pTransaction,
    725                                  am_hal_mspi_trans_e eMode,
    726                                  am_hal_mspi_callback_t pfnCallback,
    727                                  void *pCallbackCtxt)
    728          {
    729              am_hal_mspi_state_t     *pMSPIState = (am_hal_mspi_state_t *)pHandle;
    730              am_hal_cmdq_entry_t     *pCQBlock;
    731              uint32_t                index;
    732              uint32_t                size = 1;
    733              am_hal_mspi_CQ_t        *pCQ = &pMSPIState->CQ;
    734              uint32_t                ui32Status = AM_HAL_STATUS_SUCCESS;
    735          
    736              //
    737              // Determine the transfer mode and set up accordingly.
    738              //
    739              switch(eMode)
    740              {
    741                  case AM_HAL_MSPI_TRANS_PIO:
    742                      size = sizeof(am_hal_mspi_cq_pio_entry_t);
    743                      break;
    744                  case AM_HAL_MSPI_TRANS_DMA:
    745                      size = sizeof(am_hal_mspi_cq_dma_entry_t);
    746                      break;
    747              }
    748          
    749              //
    750              // Check to see if there is enough room in the CQ
    751              //
    752              if (pMSPIState->ui32NumCQEntries == AM_HAL_MSPI_MAX_CQ_ENTRIES)
    753              {
    754                  return AM_HAL_STATUS_OUT_OF_RANGE;
    755              }
    756              ui32Status = am_hal_cmdq_alloc_block(pCQ->pCmdQHdl, size / 8, &pCQBlock, &index);
    757              if (ui32Status != AM_HAL_STATUS_SUCCESS)
    758              {
    759                  return ui32Status;
    760              }
    761          
    762              ui32Status = build_dma_cmdlist(pMSPIState, eMode, pCQBlock, pTransaction);
    763              if (ui32Status != AM_HAL_STATUS_SUCCESS)
    764              {
    765                  am_hal_cmdq_release_block(pCQ->pCmdQHdl);
    766                  return ui32Status;
    767              }
    768          
    769              //
    770              // Because we set AM_HAL_IOM_CQUPD_INT_FLAG, an interrupt will occur once
    771              // we reach this point in the Command Queue.  In the service routine, we'll
    772              // look for the appropriate callback.
    773              //
    774              // If ENDIDX has been reached, the CQ will pause here. Otherwise will
    775              // continue with the next CQ entry.
    776              //
    777          
    778              //
    779              // Store the callback function pointer.
    780              //
    781              pMSPIState->pfnCallback[index & (AM_HAL_MSPI_MAX_CQ_ENTRIES - 1)] = pfnCallback;
    782              pMSPIState->pCallbackCtxt[index & (AM_HAL_MSPI_MAX_CQ_ENTRIES - 1)] = pCallbackCtxt;
    783          
    784              //
    785              // Return the status.
    786              //
    787              return ui32Status;
    788          }
    789          
    790          //*****************************************************************************
    791          //
    792          //! @brief Enable the Command Queue operation.
    793          //!
    794          //! @param handle       - handle for the interface.
    795          //!
    796          //! This function enables Command Queue operation.
    797          //!
    798          //!
    799          //! @return HAL status of the operation.
    800          //
    801          //
    802          //*****************************************************************************
    803          static uint32_t
    804          mspi_cq_enable(void *pHandle)
    805          {
    806              am_hal_mspi_state_t *pMSPIState = (am_hal_mspi_state_t *)pHandle;
    807          
    808              //
    809              // Enable the Command Queue operation
    810              //
    811              return am_hal_cmdq_enable(pMSPIState->CQ.pCmdQHdl);
    812          }
    813          //*****************************************************************************
    814          //
    815          //! @brief Disable the Command Queue operation.
    816          //!
    817          //! @param handle       - handle for the interface.
    818          //!
    819          //! This function disables the Command Queue operation.
    820          //!
    821          //!
    822          //! @return HAL status of the operation.
    823          //
    824          //
    825          //*****************************************************************************
    826          static uint32_t
    827          mspi_cq_disable(void *pHandle)
    828          {
    829              am_hal_mspi_state_t  *pMSPIState = (am_hal_mspi_state_t *)pHandle;
    830          
    831              //
    832              // Disable the Command Queue operation
    833              //
    834              return am_hal_cmdq_disable(pMSPIState->CQ.pCmdQHdl);
    835          }
    836          
    837          static uint32_t
    838          mspi_cq_pause(am_hal_mspi_state_t *pMSPIState)
    839          {
    840              uint32_t status = AM_HAL_STATUS_SUCCESS;
    841              uint32_t ui32usMaxDelay = AM_HAL_MSPI_MAX_PAUSE_DELAY;
    842          
    843              MSPIn(pMSPIState->ui32Module)->CQSETCLEAR = AM_HAL_MSPI_SC_PAUSE_CQ;
    844              // It is possible that CQ is disabled once the last transaction is processed
    845              while ( MSPIn(pMSPIState->ui32Module)->CQCFG_b.CQEN )
    846              {
    847                  // Need to make sure we're paused at a designated pause point
    848                  if ( MSPIn(pMSPIState->ui32Module)->CQSTAT_b.CQPAUSED && (MSPIn(pMSPIState->ui32Module)->CQPAUSE & AM_HAL_MSPI_PAUSE_FLAG_CQ))
    849                  {
    850                      break;
    851                  }
    852                  if ( ui32usMaxDelay-- )
    853                  {
    854                      //
    855                      // Call the BOOTROM cycle function to delay for about 1 microsecond.
    856                      //
    857                      am_hal_flash_delay( FLASH_CYCLES_US(1) );
    858                  }
    859                  else
    860                  {
    861                      return AM_HAL_STATUS_TIMEOUT;
    862                  }
    863              }
    864              if (status == AM_HAL_STATUS_SUCCESS)
    865              {
    866                  // Now that CQ is guaranteed to not progress further - we need to still wait in case the current CQ entry
    867                  // resulted in a DMA state....need to make sure we finish the current DMA
    868                  status = am_hal_flash_delay_status_check(AM_HAL_MSPI_MAX_PAUSE_DELAY,
    869                                                       (uint32_t)&MSPIn(pMSPIState->ui32Module)->DMASTAT,
    870                                                       MSPI_DMASTAT_DMATIP_Msk,
    871                                                       _VAL2FLD(MSPI_DMASTAT_DMATIP, 0),
    872                                                       true);
    873          
    874              }
    875              return status;
    876          }
    877          
    878          static void
    879          program_dma(void *pHandle)
    880          {
    881              am_hal_mspi_state_t         *pMSPIState = (am_hal_mspi_state_t *)pHandle;
    882              uint32_t                    ui32Module = pMSPIState->ui32Module;
    883              uint32_t                    index = (pMSPIState->ui32LastHPIdxProcessed + 1) % pMSPIState->ui32MaxHPTransactions;
    884              am_hal_mspi_dma_entry_t     *pDMAEntry = &pMSPIState->pHPTransactions[index];
    885          
    886              // Need to make sure we disable DMA before we can reprogram
    887              MSPIn(ui32Module)->DMACFG = _VAL2FLD(MSPI_DMACFG_DMAEN, 0);
    888              //
    889              // set the DMATARGADDR
    890              //
    891              MSPIn(ui32Module)->DMATARGADDR = pDMAEntry->ui32DMATARGADDRVal;
    892          
    893              //
    894              // set the DMADEVADDR
    895              //
    896              MSPIn(ui32Module)->DMADEVADDR = pDMAEntry->ui32DMADEVADDRVal;
    897          
    898              //
    899              // set the DMATOTALCOUNT
    900              //
    901              MSPIn(ui32Module)->DMATOTCOUNT = pDMAEntry->ui32DMATOTCOUNTVal;
    902          
    903              //
    904              // set the DMACFG to start DMA.
    905              //
    906              MSPIn(ui32Module)->DMACFG = pDMAEntry->ui32DMACFG1Val;
    907          }
    908          
    909          
    910          static uint32_t
    911          sched_hiprio(am_hal_mspi_state_t *pMSPIState, uint32_t numTrans)
    912          {
    913              uint32_t ui32NumPend;
    914              uint32_t ui32Status = AM_HAL_STATUS_SUCCESS;
    915              //
    916              // Start a critical section.
    917              //
    918              AM_CRITICAL_BEGIN
    919          
    920              ui32NumPend = pMSPIState->ui32NumHPEntries;
    921              pMSPIState->ui32NumHPEntries += numTrans;
    922          
    923              //
    924              // End the critical section.
    925              //
    926              AM_CRITICAL_END
    927          
    928          
    929              if (0 == ui32NumPend)
    930              {
    931                  // Force CQ to Pause
    932                  ui32Status = mspi_cq_pause(pMSPIState);
    933                  if (ui32Status != AM_HAL_STATUS_SUCCESS)
    934                  {
    935                      return ui32Status;
    936                  }
    937                  pMSPIState->ui32TxnInt = 0;
    938                  // Clear DMACMP interrupt
    939                  MSPIn(pMSPIState->ui32Module)->INTCLR = AM_HAL_MSPI_INT_DMACMP | AM_HAL_MSPI_INT_CMDCMP;
    940                  // Enable DMACMP interrupt
    941                  MSPIn(pMSPIState->ui32Module)->INTEN |= AM_HAL_MSPI_INT_DMACMP | AM_HAL_MSPI_INT_CMDCMP;
    942                  pMSPIState->bHP = true;
    943                  //
    944                  // Program the DMA
    945                  //
    946                  program_dma(pMSPIState);
    947              }
    948              return ui32Status;
    949          }
    950          
    951          
    952          static uint32_t
    953          mspi_add_hp_transaction(void *pHandle,
    954                                  am_hal_mspi_dma_transfer_t *pDMATrans,
    955                                  am_hal_mspi_callback_t pfnCallback,
    956                                  void *pCallbackCtxt)
    957          {
    958              am_hal_mspi_state_t         *pMSPIState = (am_hal_mspi_state_t *)pHandle;
    959              am_hal_mspi_dma_entry_t     *pDMAEntry;
    960          
    961              uint32_t  index = pMSPIState->ui32NextHPIdx % pMSPIState->ui32MaxHPTransactions;
    962          
    963              //
    964              // Check to see if there is enough room in the queue
    965              //
    966              if ( pMSPIState->ui32NumHPEntries == pMSPIState->ui32MaxHPTransactions )
    967              {
    968                  return AM_HAL_STATUS_OUT_OF_RANGE;
    969              }
    970          
    971              pDMAEntry = &pMSPIState->pHPTransactions[index];
    972              pDMAEntry->ui32DMATARGADDRVal = pDMATrans->ui32SRAMAddress;
    973              pDMAEntry->ui32DMADEVADDRVal   = pDMATrans->ui32DeviceAddress;
    974              pDMAEntry->ui32DMATOTCOUNTVal  = pDMATrans->ui32TransferCount;
    975              pDMAEntry->ui32DMACFG1Val      =
    976                  _VAL2FLD(MSPI_DMACFG_DMAPWROFF, 0)   |  // DMA Auto Power-off not supported!
    977                  _VAL2FLD(MSPI_DMACFG_DMAPRI, pDMATrans->ui8Priority)    |
    978                  _VAL2FLD(MSPI_DMACFG_DMADIR, pDMATrans->eDirection)     |
    979                  _VAL2FLD(MSPI_DMACFG_DMAEN, 3);
    980              pDMAEntry->pfnCallback = pfnCallback;
    981              pDMAEntry->pCallbackCtxt = pCallbackCtxt;
    982          
    983              pMSPIState->ui32NextHPIdx++;
    984              return AM_HAL_STATUS_SUCCESS;
    985          } // am_hal_mspi_DmaAddTransaction()
    986          
    987          #endif
    988          
    989          //*****************************************************************************
    990          //
    991          //! @brief Configure the internal PADs.
    992          //!
    993          //! @param handle       - handle for the interface.
    994          //! @param eMSPIDevice  - external device configuration for MSPI
    995          //! This function configures the internal pads based on the external device
    996          //! configuration.
    997          //!
    998          //!
    999          //! @return HAL status of the operation.
   1000          //
   1001          //
   1002          //*****************************************************************************
   1003          static uint32_t
   1004          mspi_pad_configure(void *pHandle,
   1005                             am_hal_mspi_device_e eMSPIDevice)
   1006          {
   1007              am_hal_mspi_state_t           *pMSPIState = (am_hal_mspi_state_t *)pHandle;
   1008              uint32_t                      ui32Module = pMSPIState->ui32Module;
   1009          
   1010              // MSPI PADOUTEN:
   1011              // Bit 0 - 7 : DS0 - DS7
   1012              // Bit 8     : CLK
   1013              switch ( eMSPIDevice )
   1014              {
   1015                  case AM_HAL_MSPI_FLASH_SERIAL_CE0:
   1016                  case AM_HAL_MSPI_FLASH_DUAL_CE0:
   1017                      MSPIn(ui32Module)->PADCFG = 0;
   1018                      MSPIn(ui32Module)->PADOUTEN = 0x103;
   1019                      break;
   1020                  case AM_HAL_MSPI_FLASH_SERIAL_CE1:
   1021                  case AM_HAL_MSPI_FLASH_DUAL_CE1:
   1022                      MSPIn(ui32Module)->PADCFG = 0;
   1023                      MSPIn(ui32Module)->PADOUTEN = 0x130;
   1024                      break;
   1025                  case AM_HAL_MSPI_FLASH_QUAD_CE0:
   1026                      MSPIn(ui32Module)->PADCFG = 0;
   1027                      MSPIn(ui32Module)->PADOUTEN = 0x10F;
   1028                      break;
   1029                  case AM_HAL_MSPI_FLASH_QUAD_CE1:
   1030                      MSPIn(ui32Module)->PADCFG = 0;
   1031                      MSPIn(ui32Module)->PADOUTEN = 0x1F0;
   1032                      break;
   1033                  case AM_HAL_MSPI_FLASH_OCTAL_CE0:
   1034                  case AM_HAL_MSPI_FLASH_OCTAL_CE1:
   1035                  case AM_HAL_MSPI_FLASH_QUADPAIRED:
   1036                      MSPIn(ui32Module)->PADCFG = 0;
   1037                      MSPIn(ui32Module)->PADOUTEN = 0x1FF;
   1038                      break;
   1039                  case AM_HAL_MSPI_FLASH_QUADPAIRED_SERIAL:
   1040                      MSPIn(ui32Module)->PADCFG = 0;
   1041                      MSPIn(ui32Module)->PADOUTEN = 0x133;
   1042                      break;
   1043              }
   1044          
   1045              //
   1046              // Return the status.
   1047              //
   1048              return AM_HAL_STATUS_SUCCESS;
   1049          }
   1050          
   1051          static void mspi_seq_loopback(void *pCallbackCtxt, uint32_t status)
   1052          {
   1053              // Reset the state to allow serving callbacks for next set
   1054              am_hal_mspi_state_t *pMSPIState = (am_hal_mspi_state_t *)pCallbackCtxt;
   1055              pMSPIState->ui32NumCQEntries = pMSPIState->ui32NumTransactions + 1;
   1056              pMSPIState->ui32LastIdxProcessed = 0;
   1057              pMSPIState->bRestart = true;
   1058              // Now resume the CQ - to finish loopback
   1059              // Resume the CQ
   1060              MSPIn(pMSPIState->ui32Module)->CQSETCLEAR = AM_HAL_MSPI_SC_UNPAUSE_SEQLOOP;
   1061          }
   1062          
   1063          //*****************************************************************************
   1064          //
   1065          // External Functions.
   1066          //
   1067          //*****************************************************************************
   1068          
   1069          //
   1070          // MSPI initialization function
   1071          //
   1072          uint32_t
   1073          am_hal_mspi_initialize(uint32_t ui32Module, void **ppHandle)
   1074          {
   1075              // Compile time check to ensure ENTRY_SIZE macros are defined correctly
   1076              // incorrect definition will cause divide by 0 error at build time
   1077              am_ct_assert((sizeof(am_hal_mspi_cq_dma_entry_t) + 8) == AM_HAL_MSPI_CQ_ENTRY_SIZE);
   1078              am_ct_assert(sizeof(am_hal_mspi_dma_entry_t) == AM_HAL_MSPI_HIPRIO_ENTRY_SIZE);
   1079          
   1080          #ifndef AM_HAL_DISABLE_API_VALIDATION
   1081              //
   1082              // Check that the request module is in range.
   1083              //
   1084              if (ui32Module >= AM_REG_MSPI_NUM_MODULES )
   1085              {
   1086                  return AM_HAL_STATUS_OUT_OF_RANGE;
   1087              }
   1088          
   1089              //
   1090              // Check for valid arguements.
   1091              //
   1092              if (!ppHandle)
   1093              {
   1094                  return AM_HAL_STATUS_INVALID_ARG;
   1095              }
   1096          
   1097              //
   1098              // Check if the handle is unallocated.
   1099              //
   1100              if (g_MSPIState[ui32Module].prefix.s.bInit)
   1101              {
   1102                  return AM_HAL_STATUS_INVALID_OPERATION;
   1103              }
   1104          #endif
   1105          
   1106              //
   1107              // Initialize the handle.
   1108              //
   1109              g_MSPIState[ui32Module].prefix.s.bInit = true;
   1110              g_MSPIState[ui32Module].prefix.s.magic = AM_HAL_MAGIC_MSPI;
   1111              g_MSPIState[ui32Module].ui32Module = ui32Module;
   1112          
   1113              //
   1114              // Return the handle.
   1115              //
   1116              *ppHandle = (void *)&g_MSPIState[ui32Module];
   1117          
   1118              //
   1119              // Return the status.
   1120              //
   1121              return AM_HAL_STATUS_SUCCESS;
   1122          }
   1123          
   1124          //
   1125          // MSPI Disable function
   1126          //
   1127          uint32_t
   1128          am_hal_mspi_disable(void *pHandle)
   1129          {
   1130              am_hal_mspi_state_t           *pMSPIState = (am_hal_mspi_state_t *)pHandle;
   1131          
   1132          #ifndef AM_HAL_DISABLE_API_VALIDATION
   1133              //
   1134              // Check the handle.
   1135              //
   1136              if (!AM_HAL_MSPI_CHK_HANDLE(pHandle))
   1137              {
   1138                  return AM_HAL_STATUS_INVALID_HANDLE;
   1139              }
   1140          #endif
   1141          
   1142              if (!pMSPIState->prefix.s.bEnable)
   1143              {
   1144                  return AM_HAL_STATUS_SUCCESS;
   1145              }
   1146          
   1147          #if MSPI_USE_CQ
   1148          
   1149              if (pMSPIState->pTCB)
   1150              {
   1151                  //
   1152                  // Disable the Command Queue.
   1153                  //
   1154                  mspi_cq_disable(pHandle);
   1155          
   1156                  //
   1157                  // Reset the Command Queue.
   1158                  //
   1159                  mspi_cq_term(pHandle);
   1160              }
   1161          
   1162          #endif // MSPI_USE_CQ
   1163          
   1164              pMSPIState->prefix.s.bEnable = false;
   1165          
   1166              //
   1167              // Return the status.
   1168              //
   1169              return AM_HAL_STATUS_SUCCESS;
   1170          }
   1171          
   1172          
   1173          //
   1174          // MSPI Deinitialize function
   1175          //
   1176          uint32_t
   1177          am_hal_mspi_deinitialize(void *pHandle)
   1178          {
   1179              am_hal_mspi_state_t           *pMSPIState = (am_hal_mspi_state_t *)pHandle;
   1180          
   1181          #ifndef AM_HAL_DISABLE_API_VALIDATION
   1182              //
   1183              // Check the handle.
   1184              //
   1185              if (!AM_HAL_MSPI_CHK_HANDLE(pHandle))
   1186              {
   1187                  return AM_HAL_STATUS_INVALID_HANDLE;
   1188              }
   1189          #endif
   1190          
   1191              if (pMSPIState->prefix.s.bEnable)
   1192              {
   1193                  am_hal_mspi_disable(pHandle);
   1194              }
   1195          
   1196              //
   1197              // Reset the handle.
   1198              //
   1199              pMSPIState->prefix.s.bInit = false;
   1200              pMSPIState->ui32Module = 0;
   1201              pMSPIState->eDeviceConfig = (am_hal_mspi_device_e)0;
   1202          
   1203              //
   1204              // Return the status.
   1205              //
   1206              return AM_HAL_STATUS_SUCCESS;
   1207          }
   1208          
   1209          //
   1210          // MSPI device configuration function
   1211          //
   1212          uint32_t
   1213          am_hal_mspi_device_configure(void *pHandle,
   1214                                       am_hal_mspi_dev_config_t *pConfig)
   1215          {
   1216              am_hal_mspi_state_t           *pMSPIState = (am_hal_mspi_state_t *)pHandle;
   1217              uint32_t                      ui32Module;
   1218              uint32_t                      ui32Config = 0;
   1219          
   1220          #ifndef AM_HAL_DISABLE_API_VALIDATION
   1221              //
   1222              // Check the handle.
   1223              //
   1224              if (!AM_HAL_MSPI_CHK_HANDLE(pHandle))
   1225              {
   1226                  return AM_HAL_STATUS_INVALID_HANDLE;
   1227              }
   1228          
   1229              //
   1230              // Configure not allowed in Enabled state
   1231              //
   1232              if (pMSPIState->prefix.s.bEnable)
   1233              {
   1234                  return AM_HAL_STATUS_INVALID_OPERATION;
   1235              }
   1236          #endif
   1237          
   1238              ui32Module = pMSPIState->ui32Module;
   1239              //
   1240              // Set the external flash device configuration.
   1241              //
   1242              ui32Config = _VAL2FLD(MSPI_CFG_DEVCFG, pConfig->eDeviceConfig);
   1243          
   1244              //
   1245              // If separate MOSI/MISO, then configure.
   1246              //
   1247              if ( pConfig->bSeparateIO )
   1248              {
   1249                  ui32Config |= _VAL2FLD(MSPI_CFG_SEPIO, 1);
   1250              }
   1251          
   1252              //
   1253              // Set the clock polarity and phase based on SPI mode.
   1254              //
   1255              switch(pConfig->eSpiMode)
   1256              {
   1257                  case AM_HAL_MSPI_SPI_MODE_0:                  // CPOL = 0; CPHA = 0
   1258                      ui32Config |= _VAL2FLD(MSPI_CFG_CPOL, 0)    |
   1259                                    _VAL2FLD(MSPI_CFG_CPHA, 0);
   1260                      break;
   1261                  case AM_HAL_MSPI_SPI_MODE_2:                  // CPOL = 1; CPHA = 0
   1262                      ui32Config |= _VAL2FLD(MSPI_CFG_CPOL, 1)    |
   1263                                    _VAL2FLD(MSPI_CFG_CPHA, 0);
   1264                      break;
   1265                  case AM_HAL_MSPI_SPI_MODE_1:                  // CPOL = 0; CPHA = 1
   1266                      ui32Config |= _VAL2FLD(MSPI_CFG_CPOL, 0)    |
   1267                                    _VAL2FLD(MSPI_CFG_CPHA, 1);
   1268                      break;
   1269                  case AM_HAL_MSPI_SPI_MODE_3:                  // CPOL = 1; CPHA = 1
   1270                      ui32Config |= _VAL2FLD(MSPI_CFG_CPOL, 1)    |
   1271                                    _VAL2FLD(MSPI_CFG_CPHA, 1);
   1272                      break;
   1273              }
   1274          
   1275              //
   1276              // Set the number of turn-around cycles.
   1277              //
   1278              ui32Config |= _VAL2FLD(MSPI_CFG_TURNAROUND, pConfig->ui8TurnAround);
   1279          
   1280              //
   1281              // Set the address configuration.
   1282              //
   1283              ui32Config |= _VAL2FLD(MSPI_CFG_ASIZE, pConfig->eAddrCfg);
   1284          
   1285              //
   1286              // Set the instruction configuration.
   1287              //
   1288              ui32Config |= _VAL2FLD(MSPI_CFG_ISIZE, pConfig->eInstrCfg);
   1289          
   1290              //
   1291              // Set the configuration in the MSPI peripheral.
   1292              //
   1293              MSPIn(ui32Module)->CFG = ui32Config;
   1294          
   1295              //
   1296              // Set the clock divisor to get the desired MSPI clock frequency.
   1297              //
   1298              MSPIn(ui32Module)->MSPICFG_b.CLKDIV = pConfig->eClockFreq;
   1299          
   1300              //
   1301              // Adjust the clock edge configuration depending upon the clock frequency.
   1302              //
   1303              if ( pConfig->eClockFreq == AM_HAL_MSPI_CLK_48MHZ )
   1304              {
   1305                  MSPIn(ui32Module)->MSPICFG_b.TXNEG = 1;
   1306                  MSPIn(ui32Module)->MSPICFG_b.RXNEG = 0;
   1307                  MSPIn(ui32Module)->MSPICFG_b.RXCAP = 1;
   1308              }
   1309              else
   1310              {
   1311                  MSPIn(ui32Module)->MSPICFG_b.TXNEG = 0;
   1312                  MSPIn(ui32Module)->MSPICFG_b.RXNEG = 0;
   1313                  MSPIn(ui32Module)->MSPICFG_b.RXCAP = 1;
   1314              }
   1315          
   1316              //
   1317              // Set the APBCLK for continuous operation.
   1318              //
   1319              MSPIn(ui32Module)->MSPICFG_b.APBCLK = 0;
   1320          
   1321              //
   1322              // Reset the register storage for next write.
   1323              //
   1324              ui32Config = 0;
   1325          
   1326              //
   1327              // Set whether to send an instruction.
   1328              //
   1329              if ( pConfig->bSendInstr )
   1330              {
   1331                  ui32Config |= _VAL2FLD(MSPI_FLASH_XIPSENDI, 1);
   1332              }
   1333          
   1334              //
   1335              // Set whether to send an address.
   1336              //
   1337              if ( pConfig->bSendAddr )
   1338              {
   1339                  ui32Config |= _VAL2FLD(MSPI_FLASH_XIPSENDA, 1);
   1340              }
   1341          
   1342              //
   1343              // Set whether to enable the TX to RX turnaround.
   1344              //
   1345              if ( pConfig->bTurnaround )
   1346              {
   1347                  ui32Config |= _VAL2FLD(MSPI_FLASH_XIPENTURN, 1);
   1348              }
   1349          
   1350              //
   1351              // Set to Little Endian mode by default.
   1352              //
   1353              ui32Config |= _VAL2FLD(MSPI_FLASH_XIPBIGENDIAN, pMSPIState->bBigEndian);
   1354          
   1355              //
   1356              // Set the XIP ACK value to default to 1's during latency period.
   1357              //
   1358              ui32Config |= _VAL2FLD(MSPI_FLASH_XIPACK, MSPI_FLASH_XIPACK_TERMINATE);
   1359          
   1360              //
   1361              // Set the read instruction.
   1362              //
   1363              ui32Config |= _VAL2FLD(MSPI_FLASH_READINSTR, pConfig->ui8ReadInstr);
   1364          
   1365              //
   1366              // Set the write instruction.
   1367              //
   1368              ui32Config |= _VAL2FLD(MSPI_FLASH_WRITEINSTR, pConfig->ui8WriteInstr);
   1369          
   1370              //
   1371              // Set the configuration in the MSPI peripheral.
   1372              //
   1373              MSPIn(ui32Module)->FLASH = ui32Config;
   1374          
   1375              g_MSPIState[ui32Module].pTCB = pConfig->pTCB;
   1376              g_MSPIState[ui32Module].ui32TCBSize = pConfig->ui32TCBSize;
   1377          
   1378              if (pConfig->pTCB)
   1379              {
   1380                  // set the DMABCOUNT
   1381                  MSPIn(ui32Module)->DMABCOUNT = AM_HAL_MSPI_DEFAULT_BURST_COUNT;
   1382          
   1383                  // set the DMATHRESH
   1384                  MSPIn(ui32Module)->DMATHRESH = AM_HAL_MSPI_DEFAULT_BURST_COUNT >> 2;
   1385              }
   1386              //
   1387              // Reset the register storage for next write.
   1388              //
   1389              ui32Config = 0;
   1390          
   1391              //
   1392              // Set the scrambling start and end addresses aligned to 64K region.
   1393              //
   1394              MSPIn(ui32Module)->SCRAMBLING =
   1395                  _VAL2FLD(MSPI_SCRAMBLING_SCRSTART, pConfig->scramblingStartAddr >> 16) |
   1396                  _VAL2FLD(MSPI_SCRAMBLING_SCREND, pConfig->scramblingEndAddr >> 16);
   1397          
   1398              //
   1399              // Set the selected IOM to disable.
   1400              //
   1401              MSPIn(ui32Module)->MSPICFG_b.IOMSEL = 7;
   1402          
   1403              //
   1404              // Configure the MSPI PADs.
   1405              //
   1406              mspi_pad_configure(pHandle, pConfig->eDeviceConfig);
   1407          
   1408              //
   1409              // Set the default endianess for the FIFO.
   1410              //
   1411              pMSPIState->bBigEndian = false;
   1412          
   1413              //
   1414              // Store the clock frequency for later SW workarounds.
   1415              //
   1416              pMSPIState->eClockFreq = pConfig->eClockFreq;
   1417          
   1418              //
   1419              // Set the default maximum delay timeout value.
   1420              //
   1421              pMSPIState->waitTimeout = 10000;
   1422          
   1423              //
   1424              // Return the status.
   1425              //
   1426              return AM_HAL_STATUS_SUCCESS;
   1427          }
   1428          
   1429          //
   1430          // MSPI device configuration function
   1431          //
   1432          uint32_t
   1433          am_hal_mspi_enable(void *pHandle)
   1434          {
   1435              am_hal_mspi_state_t           *pMSPIState = (am_hal_mspi_state_t *)pHandle;
   1436          
   1437          #ifndef AM_HAL_DISABLE_API_VALIDATION
   1438              //
   1439              // Check the handle.
   1440              //
   1441              if (!AM_HAL_MSPI_CHK_HANDLE(pHandle))
   1442              {
   1443                  return AM_HAL_STATUS_INVALID_HANDLE;
   1444              }
   1445          #endif
   1446          
   1447              if (pMSPIState->pTCB)
   1448              {
   1449                  pMSPIState->ui32LastIdxProcessed = 0;
   1450                  pMSPIState->ui32NumCQEntries = 0;
   1451          
   1452          #if MSPI_USE_CQ
   1453          
   1454                  //
   1455                  // Initialize the Command Queue service with memory supplied by the application.
   1456                  //
   1457                  mspi_cq_init(pMSPIState->ui32Module, pMSPIState->ui32TCBSize, pMSPIState->pTCB);
   1458                  // Initialize Flags used to force CQ Pause
   1459                  MSPIn(pMSPIState->ui32Module)->CQSETCLEAR = AM_HAL_MSPI_SC_UNPAUSE_CQ | AM_HAL_MSPI_SC_PAUSE_SEQLOOP;
   1460                  pMSPIState->pHPTransactions = NULL;
   1461                  pMSPIState->bHP = false;
   1462                  pMSPIState->ui32NumHPPendingEntries = 0;
   1463                  pMSPIState->block = 0;
   1464                  pMSPIState->ui32NumHPEntries = 0;
   1465                  pMSPIState->eSeq = AM_HAL_MSPI_SEQ_NONE;
   1466                  pMSPIState->ui32NumTransactions = 0;
   1467                  pMSPIState->bAutonomous = true;
   1468          
   1469          #else
   1470                  // Use the buffer for software queuing for DMA
   1471                  // Determine the maximum number of transactions based on the memory provided
   1472                  pMSPIState->ui32MaxTransactions = pMSPIState->ui32TCBSize * 4 / sizeof(am_hal_mspi_cq_dma_entry_t);
   1473                  if (pMSPIState->ui32MaxTransactions > 0)
   1474                  {
   1475                      if (pMSPIState->ui32MaxTransactions > AM_HAL_MSPI_MAX_CQ_ENTRIES)
   1476                      {
   1477                          pMSPIState->ui32MaxTransactions = AM_HAL_MSPI_MAX_CQ_ENTRIES;
   1478                      }
   1479                      pMSPIState->ui32NextIdx = pMSPIState->ui32LastIdxProcessed + 1;
   1480                      pMSPIState->pTransactions = (am_hal_mspi_cq_dma_entry_t *)pMSPIState->pTCB;
   1481                  }
   1482          
   1483          #endif // MSPI_USE_CQ
   1484              }
   1485          
   1486              pMSPIState->prefix.s.bEnable = true;
   1487          
   1488              //
   1489              // Return the status.
   1490              //
   1491              return AM_HAL_STATUS_SUCCESS;
   1492          }
   1493          
   1494          //
   1495          // MSPI device specific control function.
   1496          //
   1497          uint32_t am_hal_mspi_control(void *pHandle,
   1498                                       am_hal_mspi_request_e eRequest,
   1499                                       void *pConfig)
   1500          {
   1501              am_hal_mspi_state_t           *pMSPIState = (am_hal_mspi_state_t *)pHandle;
   1502              uint32_t                      ui32Module;
   1503              uint32_t                      ui32Status = AM_HAL_STATUS_SUCCESS;
   1504          
   1505          #ifndef AM_HAL_DISABLE_API_VALIDATION
   1506              //
   1507              // Check the handle.
   1508              //
   1509              if ( !AM_HAL_MSPI_CHK_HANDLE(pHandle) )
   1510              {
   1511                  return AM_HAL_STATUS_INVALID_HANDLE;
   1512              }
   1513          
   1514              //
   1515              // Validate the parameters
   1516              //
   1517              if (eRequest > AM_HAL_MSPI_REQ_MAX)
   1518              {
   1519                  return AM_HAL_STATUS_INVALID_ARG;
   1520              }
   1521          #endif
   1522              ui32Module = pMSPIState->ui32Module;
   1523              switch(eRequest)
   1524              {
   1525                  case AM_HAL_MSPI_REQ_APBCLK:
   1526                      if (!pConfig)
   1527                      {
   1528                          return AM_HAL_STATUS_INVALID_ARG;
   1529                      }
   1530          
   1531                      //
   1532                      // Enable/Disable APBCLK.
   1533                      //
   1534                      MSPIn(ui32Module)->MSPICFG_b.APBCLK = *((uint32_t *)pConfig);
   1535                      break;
   1536          
   1537                  case AM_HAL_MSPI_REQ_FLAG_SETCLR:
   1538                      if (!pConfig)
   1539                      {
   1540                          return AM_HAL_STATUS_INVALID_ARG;
   1541                      }
   1542                      if (*((uint32_t *)pConfig) & AM_HAL_MSPI_SC_RESV_MASK)
   1543                      {
   1544                          return AM_HAL_STATUS_INVALID_ARG;
   1545                      }
   1546          
   1547                      MSPIn(ui32Module)->CQSETCLEAR = *((uint32_t *)pConfig);
   1548                      break;
   1549          
   1550                  case AM_HAL_MSPI_REQ_LINK_IOM:
   1551                      if (!pConfig)
   1552                      {
   1553                          return AM_HAL_STATUS_INVALID_ARG;
   1554                      }
   1555          
   1556                      //
   1557                      // Set the Linked IOM
   1558                      //
   1559                      MSPIn(ui32Module)->MSPICFG_b.IOMSEL = *((uint32_t *)pConfig);
   1560                      break;
   1561          
   1562                  case AM_HAL_MSPI_REQ_SCRAMB_DIS:
   1563                      //
   1564                      // Disable scrambling.
   1565                      //
   1566                      MSPIn(ui32Module)->SCRAMBLING_b.SCRENABLE = 0;
   1567                      break;
   1568          
   1569                  case AM_HAL_MSPI_REQ_SCRAMB_EN:
   1570                      //
   1571                      // Enable scrambling.
   1572                      //
   1573                      MSPIn(ui32Module)->SCRAMBLING_b.SCRENABLE = 1;
   1574                      break;
   1575          
   1576                  case AM_HAL_MSPI_REQ_XIPACK:
   1577                      if (!pConfig)
   1578                      {
   1579                          return AM_HAL_STATUS_INVALID_ARG;
   1580                      }
   1581                      //
   1582                      // Enable/Disable XIPACK.
   1583                      //
   1584                      MSPIn(ui32Module)->FLASH_b.XIPACK = *((uint32_t *)pConfig);
   1585                      break;
   1586          
   1587                  case AM_HAL_MSPI_REQ_XIP_DIS:
   1588                      //
   1589                      // Disable XIP.
   1590                      //
   1591                      MSPIn(ui32Module)->FLASH_b.XIPEN = 0;
   1592                      break;
   1593          
   1594                  case AM_HAL_MSPI_REQ_XIP_EN:
   1595                      //
   1596                      // Enable XIP.
   1597                      //
   1598                      MSPIn(ui32Module)->FLASH_b.XIPEN = 1;
   1599                      break;
   1600          
   1601                  case AM_HAL_MSPI_REQ_PAUSE:
   1602                      ui32Status = mspi_cq_pause(pMSPIState);
   1603                      break;
   1604          
   1605                  case AM_HAL_MSPI_REQ_UNPAUSE:
   1606                      // Resume the CQ
   1607                      MSPIn(ui32Module)->CQSETCLEAR = AM_HAL_MSPI_SC_UNPAUSE_CQ;
   1608                      break;
   1609          
   1610                  case AM_HAL_MSPI_REQ_SET_SEQMODE:
   1611                  {
   1612                      am_hal_mspi_seq_e eSeq;
   1613                      if (!pConfig)
   1614                      {
   1615                          return AM_HAL_STATUS_INVALID_ARG;
   1616                      }
   1617                      if (!pMSPIState->pTCB)
   1618                      {
   1619                          // No space for CMDQ
   1620                          return AM_HAL_STATUS_INVALID_OPERATION;
   1621                      }
   1622                      eSeq = *((bool *)pConfig) ? AM_HAL_MSPI_SEQ_UNDER_CONSTRUCTION: AM_HAL_MSPI_SEQ_NONE;
   1623                      if (eSeq == pMSPIState->eSeq)
   1624                      {
   1625                          // Nothing to do
   1626                          return AM_HAL_STATUS_SUCCESS;
   1627                      }
   1628          
   1629                      // Make sure there is no high priority transaction in progress
   1630                      if (pMSPIState->ui32NumHPEntries)
   1631                      {
   1632                          return AM_HAL_STATUS_INVALID_OPERATION;
   1633                      }
   1634                      switch (pMSPIState->eSeq)
   1635                      {
   1636                          case AM_HAL_MSPI_SEQ_RUNNING:
   1637                          {
   1638                              ui32Status = mspi_cq_pause(pMSPIState);
   1639                              break;
   1640                          }
   1641                          case AM_HAL_MSPI_SEQ_NONE:
   1642                          {
   1643                              // Make sure there is no non-blocking transaction in progress
   1644                              if (pMSPIState->ui32NumCQEntries)
   1645                              {
   1646                                  return AM_HAL_STATUS_INVALID_OPERATION;
   1647                              }
   1648                              break;
   1649                          }
   1650                          default:
   1651                              ;
   1652                      }
   1653                      if (ui32Status == AM_HAL_STATUS_SUCCESS)
   1654                      {
   1655                          // Reset the cmdq
   1656                          am_hal_cmdq_reset(pMSPIState->CQ.pCmdQHdl);
   1657                          pMSPIState->ui32LastIdxProcessed = 0;
   1658                          pMSPIState->ui32NumTransactions = 0;
   1659                          pMSPIState->ui32NumCQEntries = 0;
   1660                          pMSPIState->eSeq = eSeq;
   1661                          pMSPIState->bAutonomous = true;
   1662                      }
   1663                      break;
   1664                  }
   1665          
   1666                  case AM_HAL_MSPI_REQ_SEQ_END:
   1667                  {
   1668                      uint32_t ui32Status = AM_HAL_STATUS_SUCCESS;
   1669                      am_hal_cmdq_entry_t     *pCQBlock;
   1670                      uint32_t                index;
   1671                      am_hal_mspi_seq_end_t *pLoop = (am_hal_mspi_seq_end_t *)pConfig;
   1672                      uint32_t pause = 0;
   1673                      uint32_t scUnpause = 0;
   1674                      if (!pConfig)
   1675                      {
   1676                          return AM_HAL_STATUS_INVALID_ARG;
   1677                      }
   1678                      if (pLoop->ui32PauseCondition & AM_HAL_MSPI_PAUSE_FLAG_RESV)
   1679                      {
   1680                          return AM_HAL_STATUS_INVALID_ARG;
   1681                      }
   1682                      if (pLoop->ui32StatusSetClr & AM_HAL_MSPI_SC_RESV_MASK)
   1683                      {
   1684                          return AM_HAL_STATUS_INVALID_ARG;
   1685                      }
   1686                      if (pMSPIState->block)
   1687                      {
   1688                          // End the block if the sequence is ending
   1689                          pMSPIState->block = 0;
   1690                          // Unblock the whole batch of commands in this block
   1691                          MSPIn(ui32Module)->CQSETCLEAR = AM_HAL_MSPI_SC_UNPAUSE_BLOCK;
   1692                      }
   1693                      if ((pLoop->bLoop) && (!pMSPIState->bAutonomous))
   1694                      {
   1695                          // Need to insert special element in CQ to cause a callback
   1696                          // This is to reset internal state
   1697                          ui32Status = am_hal_cmdq_alloc_block(pMSPIState->CQ.pCmdQHdl, 1, &pCQBlock, &index);
   1698                          if (ui32Status != AM_HAL_STATUS_SUCCESS)
   1699                          {
   1700                              return ui32Status;
   1701                          }
   1702                          else
   1703                          {
   1704                              //
   1705                              // Store the callback function pointer.
   1706                              //
   1707                              pMSPIState->pfnCallback[index & (AM_HAL_MSPI_MAX_CQ_ENTRIES - 1)] = mspi_seq_loopback;
   1708                              pMSPIState->pCallbackCtxt[index & (AM_HAL_MSPI_MAX_CQ_ENTRIES - 1)] = (void *)pMSPIState;
   1709          
   1710                              // Dummy Entry
   1711                              pCQBlock->address = (uint32_t)&MSPIn(ui32Module)->CQSETCLEAR;
   1712                              pCQBlock->value = 0;
   1713                              //
   1714                              // Post to the CQ.
   1715                              //
   1716                              ui32Status = am_hal_cmdq_post_block(pMSPIState->CQ.pCmdQHdl, true);
   1717          
   1718                              if (AM_HAL_STATUS_SUCCESS != ui32Status)
   1719                              {
   1720                                  am_hal_cmdq_release_block(pMSPIState->CQ.pCmdQHdl);
   1721                                  return ui32Status;
   1722                              }
   1723                              else
   1724                              {
   1725                                  pMSPIState->ui32NumCQEntries++;
   1726                              }
   1727                              // Use SWFLAG6 to cause a pause
   1728                              pause = AM_HAL_MSPI_PAUSE_FLAG_SEQLOOP;
   1729                              // Revert back the flag after SW callback unpauses it
   1730                              scUnpause = AM_HAL_MSPI_SC_PAUSE_SEQLOOP;
   1731                          }
   1732                      }
   1733                      // Insert the loopback
   1734                      ui32Status = am_hal_cmdq_alloc_block(pMSPIState->CQ.pCmdQHdl, sizeof(am_hal_mspi_cq_loop_entry_t) / 8, &pCQBlock, &index);
   1735                      if (ui32Status != AM_HAL_STATUS_SUCCESS)
   1736                      {
   1737                          return ui32Status;
   1738                      }
   1739                      else
   1740                      {
   1741                          am_hal_mspi_cq_loop_entry_t *pLoopEntry = (am_hal_mspi_cq_loop_entry_t *)pCQBlock;
   1742                          pLoopEntry->ui32PAUSENAddr = pLoopEntry->ui32PAUSEN2Addr = (uint32_t)&MSPIn(ui32Module)->CQPAUSE;
   1743                          pLoopEntry->ui32SETCLRAddr = (uint32_t)&MSPIn(ui32Module)->CQSETCLEAR;
   1744                          pLoopEntry->ui32PAUSEENVal = get_pause_val(pMSPIState, pLoop->ui32PauseCondition | pause);
   1745                          pLoopEntry->ui32PAUSEEN2Val = AM_HAL_MSPI_PAUSE_DEFAULT;
   1746                          pLoopEntry->ui32SETCLRVal = pLoop->ui32StatusSetClr | scUnpause;
   1747          
   1748                          //
   1749                          // Post to the CQ.
   1750                          //
   1751                          if (pLoop->bLoop)
   1752                          {
   1753                              ui32Status = am_hal_cmdq_post_loop_block(pMSPIState->CQ.pCmdQHdl, false);
   1754                          }
   1755                          else
   1756                          {
   1757                              ui32Status = am_hal_cmdq_post_block(pMSPIState->CQ.pCmdQHdl, false);
   1758                          }
   1759          
   1760                          if (AM_HAL_STATUS_SUCCESS != ui32Status)
   1761                          {
   1762                              am_hal_cmdq_release_block(pMSPIState->CQ.pCmdQHdl);
   1763                          }
   1764                          else
   1765                          {
   1766                              pMSPIState->ui32NumCQEntries++;
   1767                              pMSPIState->eSeq = (pLoop->bLoop) ? AM_HAL_MSPI_SEQ_RUNNING : AM_HAL_MSPI_SEQ_NONE;
   1768                          }
   1769                      }
   1770                      // Now enable the CQ
   1771                      //
   1772                      // Enable the Command Queue
   1773                      //
   1774                      ui32Status = mspi_cq_enable(pHandle);
   1775                      return ui32Status;
   1776                      //break;
   1777                  }
   1778          
   1779                  case AM_HAL_MSPI_REQ_INIT_HIPRIO:
   1780                  {
   1781                      am_hal_mspi_hiprio_cfg_t *pHPCfg = (am_hal_mspi_hiprio_cfg_t *)pConfig;
   1782                      if (!pConfig)
   1783                      {
   1784                          return AM_HAL_STATUS_INVALID_ARG;
   1785                      }
   1786                      if (pMSPIState->pHPTransactions)
   1787                      {
   1788                          return AM_HAL_STATUS_INVALID_OPERATION;
   1789                      }
   1790                      pMSPIState->ui32NumHPEntries = pMSPIState->ui32LastHPIdxProcessed = 0;
   1791                      pMSPIState->ui32NextHPIdx = pMSPIState->ui32LastHPIdxProcessed + 1;
   1792                      pMSPIState->pHPTransactions = (am_hal_mspi_dma_entry_t *)pHPCfg->pBuf;
   1793                      pMSPIState->ui32MaxHPTransactions = pHPCfg->size / sizeof(am_hal_mspi_dma_entry_t);
   1794                      break;
   1795                  }
   1796          
   1797                  case AM_HAL_MSPI_REQ_START_BLOCK:
   1798                      // Pause the next block from proceeding till whole block is finished
   1799                      MSPIn(ui32Module)->CQSETCLEAR = AM_HAL_MSPI_SC_PAUSE_BLOCK;
   1800                      pMSPIState->block = 1;
   1801                      pMSPIState->ui32NumHPPendingEntries = 0;
   1802                      break;
   1803          
   1804                  case AM_HAL_MSPI_REQ_END_BLOCK:
   1805                      // Unblock the whole batch of commands in this block
   1806                      MSPIn(ui32Module)->CQSETCLEAR = AM_HAL_MSPI_SC_UNPAUSE_BLOCK;
   1807                      pMSPIState->block = 0;
   1808                      if (!pMSPIState->ui32NumHPPendingEntries)
   1809                      {
   1810                          // Now it is okay to let go of the block of HiPrio transactions
   1811                          ui32Status = sched_hiprio(pMSPIState, pMSPIState->ui32NumHPPendingEntries);
   1812                          if (ui32Status == AM_HAL_STATUS_SUCCESS)
   1813                          {
   1814                              pMSPIState->ui32NumHPPendingEntries = 0;
   1815                          }
   1816                      }
   1817                      break;
   1818          
   1819                  case AM_HAL_MSPI_REQ_CQ_RAW:
   1820                  {
   1821          #if MSPI_USE_CQ
   1822                      am_hal_mspi_cq_raw_t *pCqRaw = (am_hal_mspi_cq_raw_t *)pConfig;
   1823                      am_hal_cmdq_entry_t *pCQBlock;
   1824                      uint32_t            ui32Critical = 0;
   1825                      uint32_t            ui32NumPend;
   1826                      uint32_t            index;
   1827                      if (!pCqRaw)
   1828                      {
   1829                          return AM_HAL_STATUS_INVALID_ARG;
   1830                      }
   1831                      if (!pMSPIState->CQ.pCmdQHdl)
   1832                      {
   1833                          return AM_HAL_STATUS_INVALID_OPERATION;
   1834                      }
   1835                      //
   1836                      // Check to see if there is enough room in the CQ
   1837                      //
   1838                      if ((pMSPIState->ui32NumCQEntries == AM_HAL_MSPI_MAX_CQ_ENTRIES) ||
   1839                          (am_hal_cmdq_alloc_block(pMSPIState->CQ.pCmdQHdl, pCqRaw->numEntries + 3, &pCQBlock, &index)))
   1840                      {
   1841                          return AM_HAL_STATUS_OUT_OF_RANGE;
   1842                      }
   1843          
   1844                      pCQBlock->address = (uint32_t)&MSPIn(ui32Module)->CQPAUSE;
   1845                      pCQBlock->value = get_pause_val(pMSPIState, pCqRaw->ui32PauseCondition);
   1846                      pCQBlock++;
   1847                      // Copy the CQ Entry contents
   1848                      for (uint32_t i = 0; i < pCqRaw->numEntries; i++, pCQBlock++)
   1849                      {
   1850                          pCQBlock->address = pCqRaw->pCQEntry[i].address;
   1851                          pCQBlock->value = pCqRaw->pCQEntry[i].value;
   1852                      }
   1853                      // If there is a need - populate the jump back address
   1854                      if (pCqRaw->pJmpAddr)
   1855                      {
   1856                          *(pCqRaw->pJmpAddr) = (uint32_t)pCQBlock;
   1857                      }
   1858                      pCQBlock->address = (uint32_t)&MSPIn(ui32Module)->CQPAUSE;
   1859                      pCQBlock->value = AM_HAL_MSPI_PAUSE_DEFAULT;
   1860                      pCQBlock++;
   1861                      pCQBlock->address = (uint32_t)&MSPIn(ui32Module)->CQSETCLEAR;
   1862                      pCQBlock->value = pCqRaw->ui32StatusSetClr;
   1863                      //
   1864                      // Store the callback function pointer.
   1865                      //
   1866                      pMSPIState->pfnCallback[index & (AM_HAL_MSPI_MAX_CQ_ENTRIES - 1)] = pCqRaw->pfnCallback;
   1867                      pMSPIState->pCallbackCtxt[index & (AM_HAL_MSPI_MAX_CQ_ENTRIES - 1)] = pCqRaw->pCallbackCtxt;
   1868          
   1869                      //
   1870                      // Need to protect access of ui32NumPendTransactions as it is accessed
   1871                      // from ISR as well
   1872                      if (pMSPIState->eSeq == AM_HAL_MSPI_SEQ_NONE)
   1873                      {
   1874                          //
   1875                          // Start a critical section.
   1876                          //
   1877                          ui32Critical = am_hal_interrupt_master_disable();
   1878                      }
   1879          
   1880                      //
   1881                      // Post the transaction to the CQ.
   1882                      // Register for interrupt only if there is a callback
   1883                      //
   1884                      ui32Status = am_hal_cmdq_post_block(pMSPIState->CQ.pCmdQHdl, pCqRaw->pfnCallback);
   1885                      if (AM_HAL_STATUS_SUCCESS != ui32Status)
   1886                      {
   1887                          if (pMSPIState->eSeq == AM_HAL_MSPI_SEQ_NONE)
   1888                          {
   1889                              //
   1890                              // End the critical section.
   1891                              //
   1892                              am_hal_interrupt_master_set(ui32Critical);
   1893                          }
   1894          
   1895                          am_hal_cmdq_release_block(pMSPIState->CQ.pCmdQHdl);
   1896                      }
   1897                      else
   1898                      {
   1899                          ui32NumPend = pMSPIState->ui32NumCQEntries++;
   1900                          pMSPIState->ui32NumTransactions++;
   1901                          if (pCqRaw->pfnCallback)
   1902                          {
   1903                              pMSPIState->bAutonomous = false;
   1904                          }
   1905                          if (pMSPIState->eSeq == AM_HAL_MSPI_SEQ_NONE)
   1906                          {
   1907                              //
   1908                              // End the critical section.
   1909                              //
   1910                              am_hal_interrupt_master_set(ui32Critical);
   1911                              if (ui32NumPend == 0)
   1912                              {
   1913                                  //
   1914                                  // Enable the Command Queue
   1915                                  //
   1916                                  ui32Status = mspi_cq_enable(pHandle);
   1917                                  if (AM_HAL_STATUS_SUCCESS != ui32Status)
   1918                                  {
   1919                                      return ui32Status;
   1920                                  }
   1921                              }
   1922                          }
   1923                      }
   1924          #else // !AM_HAL_MSPI_CQ
   1925                      ui32Status =  AM_HAL_STATUS_INVALID_ARG;
   1926          #endif
   1927                      break;
   1928                  }
   1929          
   1930                  default:
   1931                      return AM_HAL_STATUS_INVALID_ARG;
   1932              }
   1933          
   1934              //
   1935              // Return the status.
   1936              //
   1937              return ui32Status;
   1938          }
   1939          
   1940          //
   1941          // MSPI get capabilities
   1942          //
   1943          uint32_t am_hal_mspi_capabilities_get(void *pHandle,
   1944                                                am_hal_mspi_capabilities_t **pCapabilities)
   1945          {
   1946            am_hal_mspi_state_t           *pMSPIState = (am_hal_mspi_state_t *)pHandle;
   1947            uint32_t                      ui32Module;
   1948          
   1949          #ifndef AM_HAL_DISABLE_API_VALIDATION
   1950              //
   1951              // Check the handle.
   1952              //
   1953              if (!AM_HAL_MSPI_CHK_HANDLE(pHandle))
   1954              {
   1955                  return AM_HAL_STATUS_INVALID_HANDLE;
   1956              }
   1957          #endif
   1958          
   1959              ui32Module = pMSPIState->ui32Module;
   1960              //
   1961              // copy the pointer the MSPI instance capabilities into the passed pointer
   1962              //
   1963              *pCapabilities = &g_MSPIState[ui32Module].capabilities;
   1964          
   1965              //
   1966              // Return the status.
   1967              //
   1968              return AM_HAL_STATUS_SUCCESS;
   1969          }
   1970          
   1971          //
   1972          // MSPI blocking transfer function
   1973          //
   1974          uint32_t am_hal_mspi_blocking_transfer(void *pHandle,
   1975                                                 am_hal_mspi_pio_transfer_t *pTransaction,
   1976                                                 uint32_t ui32Timeout)
   1977          {
   1978              am_hal_mspi_state_t           *pMSPIState = (am_hal_mspi_state_t *)pHandle;
   1979              uint32_t                      ui32Module;
   1980              uint32_t                      ui32Control = 0;
   1981              uint32_t                      ui32Status = AM_HAL_STATUS_SUCCESS;
   1982              uint32_t                      intMask;
   1983          
   1984          #ifndef AM_HAL_DISABLE_API_VALIDATION
   1985              //
   1986              // Check the handle.
   1987              //
   1988              if (!AM_HAL_MSPI_CHK_HANDLE(pHandle))
   1989              {
   1990                  return AM_HAL_STATUS_INVALID_HANDLE;
   1991              }
   1992          
   1993          #endif
   1994              ui32Module = pMSPIState->ui32Module;
   1995          
   1996              // Make sure there is no non-blocking transaction in progress
   1997              if (pMSPIState->ui32NumCQEntries || pMSPIState->ui32NumHPEntries)
   1998              {
   1999                  return AM_HAL_STATUS_INVALID_OPERATION;
   2000              }
   2001          #if MSPI_USE_CQ
   2002              if (pMSPIState->eSeq == AM_HAL_MSPI_SEQ_RUNNING)
   2003              {
   2004                  // Dynamic additions to sequence not allowed
   2005                  return AM_HAL_STATUS_INVALID_OPERATION;
   2006              }
   2007          #endif
   2008          
   2009              //
   2010              // Set the number of bytes to transfer.
   2011              //
   2012              ui32Control |= _VAL2FLD(MSPI_CTRL_XFERBYTES, pTransaction->ui32NumBytes);
   2013          
   2014              //
   2015              // Set the PIO default to scrambling disabled.
   2016              //
   2017              ui32Control |= _VAL2FLD(MSPI_CTRL_PIOSCRAMBLE, pTransaction->bScrambling);
   2018          
   2019              //
   2020              // Set transmit or receive operation.
   2021              //
   2022              ui32Control |= _VAL2FLD(MSPI_CTRL_TXRX, pTransaction->eDirection);
   2023          
   2024              //
   2025              // Set the indication to send an instruction and set the instruction value if
   2026              // we have a valid instruction.
   2027              //
   2028              if ( pTransaction->bSendInstr )
   2029              {
   2030                  ui32Control |= _VAL2FLD(MSPI_CTRL_SENDI, 1);
   2031                  MSPIn(ui32Module)->INSTR =
   2032                      _VAL2FLD(MSPI_INSTR_INSTR, pTransaction->ui16DeviceInstr);
   2033              }
   2034          
   2035              //
   2036              // Set the inidication to send an address and set the address value if we have
   2037              // a valid address.
   2038              //
   2039              if ( pTransaction->bSendAddr )
   2040              {
   2041                  ui32Control |= _VAL2FLD(MSPI_CTRL_SENDA, 1);
   2042                  MSPIn(ui32Module)->ADDR =
   2043                      _VAL2FLD(MSPI_ADDR_ADDR, pTransaction->ui32DeviceAddr);
   2044              }
   2045          
   2046              //
   2047              // Set the turn-around if needed.
   2048              //
   2049              if ( pTransaction->bTurnaround )
   2050              {
   2051                  ui32Control |= _VAL2FLD(MSPI_CTRL_ENTURN, 1);
   2052              }
   2053          
   2054              //
   2055              // Set the default FIFO Little Endian format.
   2056              //
   2057              ui32Control |= _VAL2FLD(MSPI_CTRL_BIGENDIAN, pMSPIState->bBigEndian);
   2058          
   2059              //
   2060              // Set the Quad Command if this is transmit and the device is configured
   2061              // for Dual Quad mode.
   2062              //
   2063              if ( pTransaction->bQuadCmd )
   2064              {
   2065                  ui32Control |= _VAL2FLD(MSPI_CTRL_QUADCMD, 1);
   2066              }
   2067          
   2068              //
   2069              // Start the Transfer.
   2070              //
   2071              ui32Control |= _VAL2FLD(MSPI_CTRL_START, 1);
   2072          
   2073              // Disable all interrupts
   2074              intMask = MSPIn(ui32Module)->INTEN;
   2075              MSPIn(ui32Module)->INTEN = 0;
   2076              MSPIn(ui32Module)->INTCLR = AM_HAL_MSPI_INT_ALL;
   2077          
   2078              //
   2079              // Initiate the Transfer.
   2080              //
   2081              MSPIn(ui32Module)->CTRL = ui32Control;
   2082          
   2083              //
   2084              // Read or Feed the FIFOs.
   2085              //
   2086              if ( AM_HAL_MSPI_RX == pTransaction->eDirection )
   2087              {
   2088                  ui32Status = mspi_fifo_read(ui32Module, pTransaction->pui32Buffer,
   2089                                              pTransaction->ui32NumBytes, pMSPIState->waitTimeout);
   2090              }
   2091              else if ( AM_HAL_MSPI_TX == pTransaction->eDirection )
   2092              {
   2093                  ui32Status = mspi_fifo_write(ui32Module, pTransaction->pui32Buffer,
   2094                                               pTransaction->ui32NumBytes, pMSPIState->waitTimeout );
   2095              }
   2096          
   2097              //
   2098              // Check status.
   2099              //
   2100              if (AM_HAL_STATUS_SUCCESS != ui32Status)
   2101              {
   2102                  //
   2103                  // Restore interrupts
   2104                  //
   2105                  MSPIn(ui32Module)->INTCLR = AM_HAL_MSPI_INT_ALL;
   2106                  MSPIn(ui32Module)->INTEN = intMask;
   2107                  return ui32Status;
   2108              }
   2109          
   2110              //
   2111              // Wait for the command to complete.
   2112              //
   2113              ui32Status = am_hal_flash_delay_status_check(ui32Timeout,
   2114                                                           (uint32_t)&MSPIn(ui32Module)->CTRL,
   2115                                                           MSPI_CTRL_STATUS_Msk,
   2116                                                           _VAL2FLD(MSPI_CTRL_STATUS, 1),
   2117                                                           true);
   2118          
   2119              //
   2120              // Restore interrupts
   2121              //
   2122              MSPIn(ui32Module)->INTCLR = AM_HAL_MSPI_INT_ALL;
   2123              MSPIn(ui32Module)->INTEN = intMask;
   2124          
   2125              //
   2126              // Return the status.
   2127              //
   2128              return ui32Status;
   2129          
   2130          }
   2131          
   2132          //
   2133          // MSPI Non-Blocking transfer function
   2134          //
   2135          uint32_t am_hal_mspi_nonblocking_transfer(void *pHandle,
   2136                                                    void *pTransfer,
   2137                                                    am_hal_mspi_trans_e eMode,
   2138                                                    am_hal_mspi_callback_t pfnCallback,
   2139                                                    void *pCallbackCtxt)
   2140          {
   2141              am_hal_mspi_state_t           *pMSPIState = (am_hal_mspi_state_t *)pHandle;
   2142              uint32_t                      ui32Status = AM_HAL_STATUS_SUCCESS;
   2143              uint32_t ui32NumPend;
   2144          
   2145          #ifndef AM_HAL_DISABLE_API_VALIDATION
   2146              //
   2147              // Check the handle.
   2148              //
   2149              if (!AM_HAL_MSPI_CHK_HANDLE(pHandle))
   2150              {
   2151                  return AM_HAL_STATUS_INVALID_HANDLE;
   2152              }
   2153              if (!pMSPIState->pTCB)
   2154              {
   2155                  return AM_HAL_STATUS_INVALID_OPERATION;
   2156              }
   2157          #endif
   2158          
   2159          #if MSPI_USE_CQ
   2160          #if 0 // We should be able to queue up the CQ even if high priority transaction is in progress
   2161              if (pMSPIState->ui32NumHPEntries)
   2162              {
   2163                  return AM_HAL_STATUS_INVALID_OPERATION;
   2164              }
   2165          #endif
   2166              if (pMSPIState->eSeq == AM_HAL_MSPI_SEQ_RUNNING)
   2167              {
   2168                  // Dynamic additions to sequence not allowed
   2169                  return AM_HAL_STATUS_INVALID_OPERATION;
   2170              }
   2171              //
   2172              // DMA defaults to using the Command Queue
   2173              //
   2174              ui32Status = mspi_cq_add_transaction(pHandle, pTransfer, eMode, pfnCallback, pCallbackCtxt);
   2175          
   2176              if (AM_HAL_STATUS_SUCCESS != ui32Status)
   2177              {
   2178                  return ui32Status;
   2179              }
   2180              else
   2181              {
   2182          
   2183                  uint32_t ui32Critical = 0;
   2184          
   2185                  if (pMSPIState->eSeq == AM_HAL_MSPI_SEQ_NONE)
   2186                  {
   2187                      //
   2188                      // Start a critical section.
   2189                      //
   2190                      ui32Critical = am_hal_interrupt_master_disable();
   2191                  }
   2192          
   2193                  //
   2194                  // Post the transaction to the CQ.
   2195                  //
   2196                  ui32Status = am_hal_cmdq_post_block(pMSPIState->CQ.pCmdQHdl, pfnCallback);
   2197          
   2198                  if (AM_HAL_STATUS_SUCCESS != ui32Status)
   2199                  {
   2200                      if (pMSPIState->eSeq == AM_HAL_MSPI_SEQ_NONE)
   2201                      {
   2202                          //
   2203                          // End the critical section.
   2204                          //
   2205                          am_hal_interrupt_master_set(ui32Critical);
   2206                      }
   2207          
   2208                      am_hal_cmdq_release_block(pMSPIState->CQ.pCmdQHdl);
   2209                  }
   2210                  else
   2211                  {
   2212                      ui32NumPend = pMSPIState->ui32NumCQEntries++;
   2213                      pMSPIState->ui32NumTransactions++;
   2214                      if (pfnCallback)
   2215                      {
   2216                          pMSPIState->bAutonomous = false;
   2217                      }
   2218                      if (pMSPIState->eSeq == AM_HAL_MSPI_SEQ_NONE)
   2219                      {
   2220                          //
   2221                          // End the critical section.
   2222                          //
   2223                          am_hal_interrupt_master_set(ui32Critical);
   2224                          if (ui32NumPend == 0)
   2225                          {
   2226                              //
   2227                              // Enable the Command Queue
   2228                              //
   2229                              ui32Status = mspi_cq_enable(pHandle);
   2230                              if (AM_HAL_STATUS_SUCCESS != ui32Status)
   2231                              {
   2232                                  return ui32Status;
   2233                              }
   2234                          }
   2235                      }
   2236                  }
   2237              }
   2238          
   2239          #else
   2240              if (pMSPIState->ui32MaxTransactions == 0)
   2241              {
   2242                  return AM_HAL_STATUS_INVALID_OPERATION;
   2243              }
   2244          
   2245              if (AM_HAL_MSPI_TRANS_DMA != eMode)
   2246              {
   2247                  return AM_HAL_STATUS_INVALID_ARG;
   2248              }
   2249          
   2250              ui32Status = mspi_dma_add_transaction(pHandle, pTransfer, pfnCallback, pCallbackCtxt);
   2251          
   2252              if (ui32Status == AM_HAL_STATUS_SUCCESS)
   2253              {
   2254                  //
   2255                  // Start a critical section.
   2256                  //
   2257                  AM_CRITICAL_BEGIN
   2258          
   2259                  ui32NumPend = pMSPIState->ui32NumCQEntries++;
   2260          
   2261                  //
   2262                  // End the critical section.
   2263                  //
   2264                  AM_CRITICAL_END
   2265          
   2266          
   2267                  if (0 == ui32NumPend)
   2268                  {
   2269                      uint32_t index = (pMSPIState->ui32LastIdxProcessed + 1) % pMSPIState->ui32MaxTransactions;
   2270          
   2271                      pMSPIState->ui32TxnInt = 0;
   2272                      //
   2273                      // Run the command list
   2274                      //
   2275                      run_txn_cmdlist(&pMSPIState->pTransactions[index], sizeof(am_hal_mspi_cq_dma_entry_t) / sizeof(am_hal_cmdq_entry_t));
   2276                  }
   2277              }
   2278          
   2279          #endif // !MSPI_USE_CQ
   2280          
   2281              //
   2282              // Return the status.
   2283              //
   2284              return ui32Status;
   2285          }
   2286          
   2287          //
   2288          // MSPI status function
   2289          //
   2290          uint32_t am_hal_mspi_status_get(void *pHandle,
   2291                                          am_hal_mspi_status_t *pStatus )
   2292          {
   2293              am_hal_mspi_state_t           *pMSPIState = (am_hal_mspi_state_t *)pHandle;
   2294              uint32_t                      ui32Module;
   2295          
   2296          #ifndef AM_HAL_DISABLE_API_VALIDATION
   2297              //
   2298              // Check the handle.
   2299              //
   2300              if (!AM_HAL_MSPI_CHK_HANDLE(pHandle))
   2301              {
   2302                  return AM_HAL_STATUS_INVALID_HANDLE;
   2303              }
   2304          #endif
   2305          
   2306              ui32Module = pMSPIState->ui32Module;
   2307              //
   2308              // Get the Command Complete status.
   2309              //
   2310              // TODO: Need to implement.
   2311          
   2312              //
   2313              // Get the FIFO status.
   2314              //
   2315              // TODO: Need to implement.
   2316          
   2317              //
   2318              //  Get the DMA status.
   2319              //
   2320              pStatus->bErr = ((MSPIn(ui32Module)->DMASTAT & MSPI_DMASTAT_DMAERR_Msk) > 0);
   2321              pStatus->bCmp = ((MSPIn(ui32Module)->DMASTAT & MSPI_DMASTAT_DMACPL_Msk) > 0);
   2322              pStatus->bTIP = ((MSPIn(ui32Module)->DMASTAT & MSPI_DMASTAT_DMATIP_Msk) > 0);
   2323          
   2324              //
   2325              // Get the CQ status.
   2326              //
   2327              // TODO: Need to implement.
   2328              pStatus->ui32NumCQEntries = pMSPIState->ui32NumCQEntries;
   2329          
   2330              //
   2331              // Get the scrambling status.
   2332              //
   2333              // TODO: Need to implement.
   2334          
   2335              //
   2336              // Return the status.
   2337              //
   2338              return AM_HAL_STATUS_SUCCESS;
   2339          }
   2340          
   2341          //
   2342          // MSPI enable interrupts function
   2343          //
   2344          uint32_t am_hal_mspi_interrupt_enable(void *pHandle,
   2345                                                uint32_t ui32IntMask)
   2346          {
   2347              am_hal_mspi_state_t           *pMSPIState = (am_hal_mspi_state_t *)pHandle;
   2348              uint32_t                      ui32Module;
   2349          
   2350          #ifndef AM_HAL_DISABLE_API_VALIDATION
   2351              //
   2352              // Check the handle.
   2353              //
   2354              if (!AM_HAL_MSPI_CHK_HANDLE(pHandle))
   2355              {
   2356                  return AM_HAL_STATUS_INVALID_HANDLE;
   2357              }
   2358          #endif
   2359          
   2360              ui32Module = pMSPIState->ui32Module;
   2361              //
   2362              // Set the interrupt enables according to the mask.
   2363              //
   2364              MSPIn(ui32Module)->INTEN |= ui32IntMask;
   2365          
   2366              //
   2367              // Return the status.
   2368              //
   2369              return AM_HAL_STATUS_SUCCESS;
   2370          }
   2371          
   2372          //
   2373          // MSPI disable interrupts function
   2374          //
   2375          uint32_t am_hal_mspi_interrupt_disable(void *pHandle,
   2376                                                 uint32_t ui32IntMask)
   2377          {
   2378              am_hal_mspi_state_t           *pMSPIState = (am_hal_mspi_state_t *)pHandle;
   2379              uint32_t                      ui32Module;
   2380          
   2381          #ifndef AM_HAL_DISABLE_API_VALIDATION
   2382              //
   2383              // Check the handle.
   2384              //
   2385              if (!AM_HAL_MSPI_CHK_HANDLE(pHandle))
   2386              {
   2387                  return AM_HAL_STATUS_INVALID_HANDLE;
   2388              }
   2389          #endif
   2390          
   2391              ui32Module = pMSPIState->ui32Module;
   2392              //
   2393              // Clear the interrupt enables according to the mask.
   2394              //
   2395              MSPIn(ui32Module)->INTEN &= ~ui32IntMask;
   2396          
   2397              //
   2398              // Return the status.
   2399              //
   2400              return AM_HAL_STATUS_SUCCESS;
   2401          }
   2402          
   2403          //
   2404          // MSPI interrupt status function
   2405          //
   2406          uint32_t am_hal_mspi_interrupt_status_get(void *pHandle,
   2407                                                    uint32_t  *pui32Status,
   2408                                                    bool bEnabledOnly)
   2409          {
   2410              am_hal_mspi_state_t           *pMSPIState = (am_hal_mspi_state_t *)pHandle;
   2411              uint32_t                      ui32Module;
   2412          
   2413          #ifndef AM_HAL_DISABLE_API_VALIDATION
   2414              //
   2415              // Check the handle.
   2416              //
   2417              if (!AM_HAL_MSPI_CHK_HANDLE(pHandle))
   2418              {
   2419                  return AM_HAL_STATUS_INVALID_HANDLE;
   2420              }
   2421          #endif
   2422          
   2423              ui32Module = pMSPIState->ui32Module;
   2424              //
   2425              // if requested, only return the interrupts that are enabled.
   2426              //
   2427              if ( bEnabledOnly )
   2428              {
   2429                  uint32_t ui32RetVal = MSPIn(ui32Module)->INTSTAT;
   2430                  *pui32Status = ui32RetVal & MSPIn(ui32Module)->INTEN;
   2431              }
   2432              else
   2433              {
   2434                  *pui32Status = MSPIn(ui32Module)->INTSTAT;
   2435              }
   2436          
   2437              return AM_HAL_STATUS_SUCCESS;
   2438          }
   2439          
   2440          //
   2441          // MSPI interrupt clear
   2442          //
   2443          uint32_t am_hal_mspi_interrupt_clear(void *pHandle,
   2444                                               uint32_t ui32IntMask)
   2445          {
   2446              am_hal_mspi_state_t           *pMSPIState = (am_hal_mspi_state_t *)pHandle;
   2447              uint32_t                      ui32Module;
   2448          
   2449          #ifndef AM_HAL_DISABLE_API_VALIDATION
   2450              //
   2451              // Check the handle.
   2452              //
   2453              if ( !AM_HAL_MSPI_CHK_HANDLE(pHandle) )
   2454              {
   2455                  return AM_HAL_STATUS_INVALID_HANDLE;
   2456              }
   2457          #endif
   2458          
   2459              ui32Module = pMSPIState->ui32Module;
   2460              //
   2461              // clear the requested interrupts.
   2462              //
   2463              MSPIn(ui32Module)->INTCLR = ui32IntMask;
   2464          
   2465              //
   2466              // Return the status.
   2467              //
   2468              return AM_HAL_STATUS_SUCCESS;
   2469          }
   2470          
   2471          //
   2472          // MSPI interrupt service routine
   2473          //
   2474          uint32_t am_hal_mspi_interrupt_service(void *pHandle, uint32_t ui32IntStatus)
   2475          {
   2476              am_hal_mspi_state_t           *pMSPIState = (am_hal_mspi_state_t *)pHandle;
   2477              uint32_t                      ui32Module;
   2478              uint32_t                      ui32Status;
   2479          
   2480          #ifndef AM_HAL_DISABLE_API_VALIDATION
   2481              //
   2482              // Check the handle.
   2483              //
   2484              if (!AM_HAL_MSPI_CHK_HANDLE(pHandle))
   2485              {
   2486                  return AM_HAL_STATUS_INVALID_HANDLE;
   2487              }
   2488          #endif
   2489          
   2490              ui32Module = pMSPIState->ui32Module;
   2491              //
   2492              // Add a delay to help make the service function work.
   2493              // TODO - why do we need this?
   2494              //
   2495          //    am_hal_flash_delay(FLASH_CYCLES_US(10));
   2496          
   2497          #if MSPI_USE_CQ
   2498              if (pMSPIState->bHP)
   2499              {
   2500          #if 0
   2501                  if (ui32IntStatus & AM_HAL_MSPI_INT_CQUPD)
   2502                  {
   2503                      while(1);
   2504                  }
   2505          #endif
   2506                  //
   2507                  // Accumulate the INTSTAT for this transaction
   2508                  //
   2509                  pMSPIState->ui32TxnInt |= ui32IntStatus;
   2510          
   2511                  //
   2512                  // We need to wait for the DMA complete as well
   2513                  //
   2514                  if (pMSPIState->ui32TxnInt & (AM_HAL_MSPI_INT_DMACMP | AM_HAL_MSPI_INT_ERR))
   2515                  {
   2516                      uint32_t index;
   2517          
   2518                      //
   2519                      // Wait for the command completion
   2520                      //
   2521                      if (!(pMSPIState->ui32TxnInt & AM_HAL_MSPI_INT_CMDCMP))
   2522                      {
   2523                          // TODO - We are waiting for CMDCMP indefinetely in the ISR
   2524                          // May need to re-evaluate
   2525                          while (!MSPIn(ui32Module)->INTSTAT_b.CMDCMP);
   2526                      }
   2527                      pMSPIState->ui32TxnInt |= MSPIn(ui32Module)->INTSTAT;
   2528          
   2529                      //
   2530                      // Clear the interrupt status
   2531                      //
   2532                      MSPIn(ui32Module)->INTCLR = AM_HAL_MSPI_INT_ALL;
   2533          
   2534                      //
   2535                      // Need to determine the error, call the callback with proper status
   2536                      //
   2537                      if (pMSPIState->ui32TxnInt & AM_HAL_MSPI_INT_ERR)
   2538                      {
   2539                          ui32Status = AM_HAL_STATUS_FAIL;
   2540          
   2541                          //
   2542                          // Disable DMA
   2543                          //
   2544                          MSPIn(ui32Module)->DMACFG_b.DMAEN = 0;
   2545          
   2546                          //
   2547                          // Must reset xfer block
   2548                          //
   2549                          MSPIn(ui32Module)->MSPICFG_b.IPRSTN = 0;  // in reset
   2550                          MSPIn(ui32Module)->MSPICFG_b.IPRSTN = 1;  // back out -- clears current transfer
   2551                      }
   2552                      else
   2553                      {
   2554                          ui32Status = AM_HAL_STATUS_SUCCESS;
   2555                      }
   2556          
   2557                      pMSPIState->ui32LastHPIdxProcessed++;
   2558                      pMSPIState->ui32NumHPEntries--;
   2559                      index = pMSPIState->ui32LastHPIdxProcessed % pMSPIState->ui32MaxHPTransactions;
   2560                      am_hal_mspi_dma_entry_t *pDMAEntry = &pMSPIState->pHPTransactions[index];
   2561          
   2562                      //
   2563                      // Call the callback
   2564                      //
   2565                      if ( pDMAEntry->pfnCallback != NULL )
   2566                      {
   2567                          pDMAEntry->pfnCallback(pDMAEntry->pCallbackCtxt, ui32Status);
   2568                          pDMAEntry->pfnCallback = NULL;
   2569                      }
   2570          
   2571                      //
   2572                      // Post next transaction if queue is not empty
   2573                      //
   2574                      if (pMSPIState->ui32NumHPEntries)
   2575                      {
   2576                          pMSPIState->ui32TxnInt = 0;
   2577                          program_dma(pMSPIState);
   2578                      }
   2579                      else
   2580                      {
   2581                          pMSPIState->bHP = false;
   2582                          // Unpause the CQ
   2583                          //
   2584                          // Command to set the DMACFG to disable DMA.
   2585                          // Need to make sure we disable DMA before we can reprogram
   2586                          //
   2587                          MSPIn(ui32Module)->DMACFG = _VAL2FLD(MSPI_DMACFG_DMAEN, 0);
   2588                          // Restore interrupts
   2589                          MSPIn(ui32Module)->INTEN &= ~(AM_HAL_MSPI_INT_DMACMP | AM_HAL_MSPI_INT_CMDCMP);
   2590                          // Resume the CQ
   2591                          MSPIn(ui32Module)->CQSETCLEAR = AM_HAL_MSPI_SC_UNPAUSE_CQ;
   2592                      }
   2593                  }
   2594                  return AM_HAL_STATUS_SUCCESS;
   2595              }
   2596          #endif
   2597              //
   2598              // Need to check if there is an ongoing transaction
   2599              // This is needed because we may get interrupts even for the XIP transactions
   2600              //
   2601              if (pMSPIState->ui32NumCQEntries)
   2602              {
   2603          #if MSPI_USE_CQ
   2604                  am_hal_cmdq_status_t status;
   2605                  uint32_t index;
   2606                  am_hal_mspi_CQ_t *pCQ = &g_MSPIState[ui32Module].CQ;
   2607          
   2608                  //
   2609                  // Get the current and last indexes.
   2610                  //
   2611                  if (pCQ->pCmdQHdl)
   2612                  {
   2613                      ui32Status = am_hal_cmdq_get_status(pCQ->pCmdQHdl, &status);
   2614          
   2615                      if (AM_HAL_STATUS_SUCCESS == ui32Status)
   2616                      {
   2617                          // For Sequence - this can be updated in the callback
   2618                          pMSPIState->bRestart = false;
   2619                          //
   2620                          // Figure out which callbacks need to be handled.
   2621                          //
   2622                          while (!pMSPIState->bRestart && (pMSPIState->ui32LastIdxProcessed != status.lastIdxProcessed))
   2623                          {
   2624          
   2625                              pMSPIState->ui32LastIdxProcessed++;
   2626                              pMSPIState->ui32NumCQEntries--;
   2627                              index = pMSPIState->ui32LastIdxProcessed & (AM_HAL_MSPI_MAX_CQ_ENTRIES - 1);
   2628                              if ( pMSPIState->pfnCallback[index] != NULL )
   2629                              {
   2630                                  pMSPIState->pfnCallback[index](pMSPIState->pCallbackCtxt[index], AM_HAL_STATUS_SUCCESS);
   2631                                  if (pMSPIState->eSeq != AM_HAL_MSPI_SEQ_RUNNING)
   2632                                  {
   2633                                      pMSPIState->pfnCallback[index] = NULL;
   2634                                  }
   2635                              }
   2636                          }
   2637          
   2638                          // For Sequence - this can be updated in the callback
   2639                          if (!pMSPIState->bRestart)
   2640                          {
   2641                              //
   2642                              // Process one extra callback if there was an error.
   2643                              //
   2644                              if ( (ui32IntStatus & AM_HAL_MSPI_INT_ERR) || (status.bErr) )
   2645                              {
   2646                                  pMSPIState->ui32LastIdxProcessed++;
   2647                                  pMSPIState->ui32NumCQEntries--;
   2648                                  index = pMSPIState->ui32LastIdxProcessed & (AM_HAL_MSPI_MAX_CQ_ENTRIES - 1);
   2649                                  if ( pMSPIState->pfnCallback[index] != NULL )
   2650                                  {
   2651                                      pMSPIState->pfnCallback[index](pMSPIState->pCallbackCtxt[index], AM_HAL_STATUS_FAIL);
   2652                                      if (pMSPIState->eSeq != AM_HAL_MSPI_SEQ_RUNNING)
   2653                                      {
   2654                                          pMSPIState->pfnCallback[index] = NULL;
   2655                                      }
   2656                                  }
   2657                                  // Disable CQ
   2658                                  mspi_cq_disable(pMSPIState);
   2659                                  // Disable DMA
   2660                                  MSPIn(ui32Module)->DMACFG_b.DMAEN = 0;
   2661          
   2662                                  // Must reset xfer block
   2663                                  MSPIn(ui32Module)->MSPICFG_b.IPRSTN = 0;  // in reset
   2664                                  MSPIn(ui32Module)->MSPICFG_b.IPRSTN = 1;  // back out -- clears current transfer
   2665          
   2666                                  // Clear the CQ error.
   2667                                  MSPIn(ui32Module)->CQSTAT |= _VAL2FLD(MSPI_CQSTAT_CQERR, 0);
   2668                                  am_hal_cmdq_error_resume(pCQ->pCmdQHdl);
   2669                                  // Re-enable CQ
   2670                                  mspi_cq_enable(pMSPIState);
   2671                              }
   2672                              if ((pMSPIState->ui32NumCQEntries == 0) && (pMSPIState->eSeq != AM_HAL_MSPI_SEQ_RUNNING))
   2673                              {
   2674                                  // Disable CQ
   2675                                  mspi_cq_disable(pMSPIState);
   2676                              }
   2677                          }
   2678                      }
   2679                  }
   2680          #else
   2681                  //
   2682                  // Accumulate the INTSTAT for this transaction
   2683                  //
   2684                  pMSPIState->ui32TxnInt |= ui32IntStatus;
   2685          
   2686                  //
   2687                  // We need to wait for the DMA complete as well
   2688                  //
   2689                  if (pMSPIState->ui32TxnInt & (AM_HAL_MSPI_INT_DMACMP | AM_HAL_MSPI_INT_ERR))
   2690                  {
   2691                      uint32_t index;
   2692          
   2693                      //
   2694                      // Wait for the command completion
   2695                      //
   2696                      if (!(pMSPIState->ui32TxnInt & AM_HAL_MSPI_INT_CMDCMP))
   2697                      {
   2698                          // TODO - We are waiting for CMDCMP indefinetely in the ISR
   2699                          // May need to re-evaluate
   2700                          while (!MSPIn(ui32Module)->INTSTAT_b.CMDCMP);
   2701                      }
   2702                      pMSPIState->ui32TxnInt |= MSPIn(ui32Module)->INTSTAT;
   2703          
   2704                      //
   2705                      // Clear the interrupt status
   2706                      //
   2707                      MSPIn(ui32Module)->INTCLR = AM_HAL_MSPI_INT_ALL;
   2708          
   2709                      //
   2710                      // Need to determine the error, call the callback with proper status
   2711                      //
   2712                      if (pMSPIState->ui32TxnInt & AM_HAL_MSPI_INT_ERR)
   2713                      {
   2714                          ui32Status = AM_HAL_STATUS_FAIL;
   2715          
   2716                          //
   2717                          // Disable DMA
   2718                          //
   2719                          MSPIn(ui32Module)->DMACFG_b.DMAEN = 0;
   2720          
   2721                          //
   2722                          // Must reset xfer block
   2723                          //
   2724                          MSPIn(ui32Module)->MSPICFG_b.IPRSTN = 0;  // in reset
   2725                          MSPIn(ui32Module)->MSPICFG_b.IPRSTN = 1;  // back out -- clears current transfer
   2726                      }
   2727                      else
   2728                      {
   2729                          ui32Status = AM_HAL_STATUS_SUCCESS;
   2730                      }
   2731          
   2732                      pMSPIState->ui32LastIdxProcessed++;
   2733                      pMSPIState->ui32NumCQEntries--;
   2734                      index = pMSPIState->ui32LastIdxProcessed % pMSPIState->ui32MaxTransactions;
   2735          
   2736                      //
   2737                      // Call the callback
   2738                      //
   2739                      if ( pMSPIState->pfnCallback[index] != NULL )
   2740                      {
   2741                          pMSPIState->pfnCallback[index](pMSPIState->pCallbackCtxt[index], ui32Status);
   2742                          pMSPIState->pfnCallback[index] = NULL;
   2743                      }
   2744          
   2745                      //
   2746                      // Post next transaction if queue is not empty
   2747                      //
   2748                      if (pMSPIState->ui32NumCQEntries)
   2749                      {
   2750                          index = (pMSPIState->ui32LastIdxProcessed + 1) % pMSPIState->ui32MaxTransactions;
   2751          
   2752                          pMSPIState->ui32TxnInt = 0;
   2753                          run_txn_cmdlist(&pMSPIState->pTransactions[index], sizeof(am_hal_mspi_cq_dma_entry_t) / sizeof(am_hal_cmdq_entry_t));
   2754                      }
   2755                  }
   2756          
   2757          #endif // !MSPI_USE_CQ
   2758          
   2759                  if (pMSPIState->ui32NumCQEntries == 0)
   2760                  {
   2761                      // Disable DMA
   2762                      MSPIn(ui32Module)->DMACFG_b.DMAEN = 0;
   2763                  }
   2764              }
   2765          
   2766            //
   2767            // Return the status.
   2768            //
   2769            return AM_HAL_STATUS_SUCCESS;
   2770          }
   2771          
   2772          //
   2773          // MSPI power control function
   2774          //
   2775          uint32_t am_hal_mspi_power_control(void *pHandle,
   2776                                             am_hal_sysctrl_power_state_e ePowerState,
   2777                                             bool bRetainState)
   2778          {
   2779              am_hal_mspi_state_t           *pMSPIState = (am_hal_mspi_state_t *)pHandle;
   2780          
   2781          #ifndef AM_HAL_DISABLE_API_VALIDATION
   2782              //
   2783              // Check the handle.
   2784              //
   2785              if (!AM_HAL_MSPI_CHK_HANDLE(pHandle))
   2786              {
   2787                  return AM_HAL_STATUS_INVALID_HANDLE;
   2788              }
   2789          #endif
   2790          
   2791              //
   2792              // Decode the requested power state and update MSPI operation accordingly.
   2793              //
   2794              switch (ePowerState)
   2795              {
   2796                  case AM_HAL_SYSCTRL_WAKE:
   2797          
   2798                      if (bRetainState && !pMSPIState->registerState.bValid)
   2799                      {
   2800                          return AM_HAL_STATUS_INVALID_OPERATION;
   2801                      }
   2802          
   2803                      //
   2804                      // Enable power control.
   2805                      //
   2806                      am_hal_pwrctrl_periph_enable((am_hal_pwrctrl_periph_e)(AM_HAL_PWRCTRL_PERIPH_MSPI));
   2807          
   2808                      if (bRetainState)
   2809                      {
   2810                          //
   2811                          // Restore MSPI registers
   2812                          //
   2813                          MSPIn(pMSPIState->ui32Module)->CFG        = pMSPIState->registerState.regCFG;
   2814                          MSPIn(pMSPIState->ui32Module)->MSPICFG    = pMSPIState->registerState.regMSPICFG;
   2815                          MSPIn(pMSPIState->ui32Module)->PADCFG     = pMSPIState->registerState.regPADCFG;
   2816                          MSPIn(pMSPIState->ui32Module)->PADOUTEN   = pMSPIState->registerState.regPADOUTEN;
   2817                          MSPIn(pMSPIState->ui32Module)->FLASH      = pMSPIState->registerState.regFLASH;
   2818                          MSPIn(pMSPIState->ui32Module)->SCRAMBLING = pMSPIState->registerState.regSCRAMBLING;
   2819                          MSPIn(pMSPIState->ui32Module)->CQCFG      = pMSPIState->registerState.regCQCFG;
   2820                          MSPIn(pMSPIState->ui32Module)->CQADDR     = pMSPIState->registerState.regCQADDR;
   2821                          MSPIn(pMSPIState->ui32Module)->CQPAUSE    = pMSPIState->registerState.regCQPAUSE;
   2822                          MSPIn(pMSPIState->ui32Module)->CQCURIDX   = pMSPIState->registerState.regCQCURIDX;
   2823                          MSPIn(pMSPIState->ui32Module)->CQENDIDX   = pMSPIState->registerState.regCQENDIDX;
   2824                          MSPIn(pMSPIState->ui32Module)->INTEN      = pMSPIState->registerState.regINTEN;
   2825          
   2826                          // TODO: May be we can just set these values, as they are constants anyways?
   2827                          MSPIn(pMSPIState->ui32Module)->DMABCOUNT  = pMSPIState->registerState.regDMABCOUNT;
   2828                          MSPIn(pMSPIState->ui32Module)->DMATHRESH  = pMSPIState->registerState.regDMATHRESH;
   2829          
   2830                          pMSPIState->registerState.bValid = false;
   2831                      }
   2832                      break;
   2833          
   2834                  case AM_HAL_SYSCTRL_NORMALSLEEP:
   2835                  case AM_HAL_SYSCTRL_DEEPSLEEP:
   2836                      if (bRetainState)
   2837                      {
   2838                          //
   2839                          // Save MSPI Registers
   2840                          //
   2841                          pMSPIState->registerState.regCFG        = MSPIn(pMSPIState->ui32Module)->CFG;
   2842                          pMSPIState->registerState.regMSPICFG    = MSPIn(pMSPIState->ui32Module)->MSPICFG;
   2843                          pMSPIState->registerState.regPADCFG     = MSPIn(pMSPIState->ui32Module)->PADCFG;
   2844                          pMSPIState->registerState.regPADOUTEN   = MSPIn(pMSPIState->ui32Module)->PADOUTEN;
   2845                          pMSPIState->registerState.regFLASH      = MSPIn(pMSPIState->ui32Module)->FLASH;
   2846                          pMSPIState->registerState.regSCRAMBLING = MSPIn(pMSPIState->ui32Module)->SCRAMBLING;
   2847                          pMSPIState->registerState.regCQADDR     = MSPIn(pMSPIState->ui32Module)->CQADDR;
   2848                          pMSPIState->registerState.regCQPAUSE    = MSPIn(pMSPIState->ui32Module)->CQPAUSE;
   2849                          pMSPIState->registerState.regCQCURIDX   = MSPIn(pMSPIState->ui32Module)->CQCURIDX;
   2850                          pMSPIState->registerState.regCQENDIDX   = MSPIn(pMSPIState->ui32Module)->CQENDIDX;
   2851                          pMSPIState->registerState.regINTEN      = MSPIn(pMSPIState->ui32Module)->INTEN;
   2852          
   2853                          // TODO: May be no need to store these values, as they are constants anyways?
   2854                          pMSPIState->registerState.regDMABCOUNT  = MSPIn(pMSPIState->ui32Module)->DMABCOUNT;
   2855                          pMSPIState->registerState.regDMATHRESH  = MSPIn(pMSPIState->ui32Module)->DMATHRESH;
   2856          
   2857                          //
   2858                          // Set the CQCFG last
   2859                          //
   2860                          pMSPIState->registerState.regCQCFG      = MSPIn(pMSPIState->ui32Module)->CQCFG;
   2861                          pMSPIState->registerState.bValid        = true;
   2862                      }
   2863          
   2864                      //
   2865                      // Disable power control.
   2866                      //
   2867                      am_hal_pwrctrl_periph_disable((am_hal_pwrctrl_periph_e)(AM_HAL_PWRCTRL_PERIPH_MSPI));
   2868                      break;
   2869          
   2870                  default:
   2871                      return AM_HAL_STATUS_INVALID_ARG;
   2872              }
   2873          
   2874              //
   2875              // Return the status.
   2876              //
   2877              return AM_HAL_STATUS_SUCCESS;
   2878          }
   2879          
   2880          //
   2881          // MSPI High Priority transfer function
   2882          //
   2883          uint32_t am_hal_mspi_highprio_transfer(void *pHandle,
   2884                                                 am_hal_mspi_dma_transfer_t *pTransfer,
   2885                                                 am_hal_mspi_trans_e eMode,
   2886                                                 am_hal_mspi_callback_t pfnCallback,
   2887                                                 void *pCallbackCtxt)
   2888          {
   2889              am_hal_mspi_state_t           *pMSPIState = (am_hal_mspi_state_t *)pHandle;
   2890              uint32_t                      ui32Status = AM_HAL_STATUS_SUCCESS;
   2891          
   2892          #ifndef AM_HAL_DISABLE_API_VALIDATION
   2893              //
   2894              // Check the handle.
   2895              //
   2896              if (!AM_HAL_MSPI_CHK_HANDLE(pHandle))
   2897              {
   2898                  return AM_HAL_STATUS_INVALID_HANDLE;
   2899              }
   2900              if (!pMSPIState->pTCB)
   2901              {
   2902                  return AM_HAL_STATUS_INVALID_OPERATION;
   2903              }
   2904              if (!pMSPIState->pHPTransactions)
   2905              {
   2906                  return AM_HAL_STATUS_INVALID_OPERATION;
   2907              }
   2908              if (pTransfer->ui32PauseCondition != 0)
   2909              {
   2910                  return AM_HAL_STATUS_INVALID_ARG;
   2911              }
   2912              if (pTransfer->ui32StatusSetClr != 0)
   2913              {
   2914                  return AM_HAL_STATUS_INVALID_ARG;
   2915              }
   2916          #endif
   2917          #if MSPI_USE_CQ
   2918          
   2919              ui32Status = mspi_add_hp_transaction(pHandle, pTransfer, pfnCallback, pCallbackCtxt);
   2920          
   2921              if (ui32Status == AM_HAL_STATUS_SUCCESS)
   2922              {
   2923                  if (!(pMSPIState->block))
   2924                  {
   2925                      ui32Status = sched_hiprio(pMSPIState, 1);
   2926                  }
   2927                  else
   2928                  {
   2929                      pMSPIState->ui32NumHPPendingEntries++;
   2930                  }
   2931              }
   2932          
   2933          #else
   2934              ui32Status =  AM_HAL_STATUS_INVALID_OPERATION;
   2935          #endif // !MSPI_USE_CQ
   2936          
   2937              //
   2938              // Return the status.
   2939              //
   2940              return ui32Status;
   2941          }
   2942          
   2943          
   2944          //*****************************************************************************
   2945          //
   2946          // End Doxygen group.
   2947          //! @}
   2948          //
   2949          //*****************************************************************************

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      56   am_hal_mspi_blocking_transfer
        56   -> am_hal_flash_delay_status_check
        56   -> mspi_fifo_read
        56   -> mspi_fifo_write
       8   am_hal_mspi_capabilities_get
      64   am_hal_mspi_control
        64   -> am_hal_cmdq_alloc_block
        64   -> am_hal_cmdq_post_block
        64   -> am_hal_cmdq_post_loop_block
        64   -> am_hal_cmdq_release_block
        64   -> am_hal_cmdq_reset
        64   -> am_hal_interrupt_master_disable
        64   -> am_hal_interrupt_master_set
        64   -> get_pause_val
        64   -> mspi_cq_enable
        64   -> mspi_cq_pause
        64   -> sched_hiprio
      16   am_hal_mspi_deinitialize
        16   -> am_hal_mspi_disable
      32   am_hal_mspi_device_configure
        32   -> mspi_pad_configure
      16   am_hal_mspi_disable
        16   -> mspi_cq_disable
        16   -> mspi_cq_term
      16   am_hal_mspi_enable
        16   -> mspi_cq_init
      40   am_hal_mspi_highprio_transfer
        40   -> mspi_add_hp_transaction
        40   -> sched_hiprio
       8   am_hal_mspi_initialize
       8   am_hal_mspi_interrupt_clear
      12   am_hal_mspi_interrupt_disable
      12   am_hal_mspi_interrupt_enable
      56   am_hal_mspi_interrupt_service
        56   -- Indirect call
        56   -> am_hal_cmdq_error_resume
        56   -> am_hal_cmdq_get_status
        56   -> mspi_cq_disable
        56   -> mspi_cq_enable
        56   -> program_dma
      16   am_hal_mspi_interrupt_status_get
      48   am_hal_mspi_nonblocking_transfer
        48   -> am_hal_cmdq_post_block
        48   -> am_hal_cmdq_release_block
        48   -> am_hal_interrupt_master_disable
        48   -> am_hal_interrupt_master_set
        48   -> mspi_cq_add_transaction
        48   -> mspi_cq_enable
      24   am_hal_mspi_power_control
        24   -> am_hal_pwrctrl_periph_disable
        24   -> am_hal_pwrctrl_periph_enable
      12   am_hal_mspi_status_get
      40   build_dma_cmdlist
        40   -> get_pause_val
       0   get_pause_val
      16   mspi_add_hp_transaction
      56   mspi_cq_add_transaction
        56   -> am_hal_cmdq_alloc_block
        56   -> am_hal_cmdq_release_block
        56   -> build_dma_cmdlist
      16   mspi_cq_disable
        16   -> am_hal_cmdq_disable
      16   mspi_cq_enable
        16   -> am_hal_cmdq_enable
      32   mspi_cq_init
        32   -> am_hal_cmdq_init
      32   mspi_cq_pause
        32   -> am_hal_flash_delay
        32   -> am_hal_flash_delay_status_check
      24   mspi_cq_term
        24   -> am_hal_cmdq_term
      56   mspi_fifo_read
        56   -> am_hal_flash_delay_status_check
      32   mspi_fifo_write
        32   -> am_hal_flash_delay_status_check
      16   mspi_pad_configure
      12   mspi_seq_loopback
      16   program_dma
      24   sched_hiprio
        24   -> am_hal_interrupt_master_disable
        24   -> am_hal_interrupt_master_set
        24   -> mspi_cq_pause
        24   -> program_dma


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable17
       4  ??DataTable23
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_2
       4  ??DataTable24_3
       4  ??DataTable25
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_2
       4  ??DataTable27_3
     328  am_hal_mspi_blocking_transfer
      56  am_hal_mspi_capabilities_get
    1498  am_hal_mspi_control
      64  am_hal_mspi_deinitialize
     518  am_hal_mspi_device_configure
      72  am_hal_mspi_disable
     132  am_hal_mspi_enable
     140  am_hal_mspi_highprio_transfer
     108  am_hal_mspi_initialize
      46  am_hal_mspi_interrupt_clear
      56  am_hal_mspi_interrupt_disable
      56  am_hal_mspi_interrupt_enable
     734  am_hal_mspi_interrupt_service
      82  am_hal_mspi_interrupt_status_get
     240  am_hal_mspi_nonblocking_transfer
     514  am_hal_mspi_power_control
      88  am_hal_mspi_status_get
     386  build_dma_cmdlist
    2196  g_MSPIState
      44  get_pause_val
     112  mspi_add_hp_transaction
     170  mspi_cq_add_transaction
      16  mspi_cq_disable
      16  mspi_cq_enable
      54  mspi_cq_init
     138  mspi_cq_pause
      68  mspi_cq_term
     190  mspi_fifo_read
      88  mspi_fifo_write
     232  mspi_pad_configure
      44  mspi_seq_loopback
      96  program_dma
     116  sched_hiprio

 
 2 196 bytes in section .bss
 6 554 bytes in section .text
 
 6 554 bytes of CODE memory
 2 196 bytes of DATA memory

Errors: none
Warnings: none
