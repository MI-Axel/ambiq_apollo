###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         12/Mar/2019  10:07:08
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_itm.c
#    Command line =  
#        -f C:\temp\EW8558.tmp
#        (C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_itm.c
#        -D iar -D AM_PART_APOLLO3 -D AM_PACKAGE_BGA -lcN
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --diag_suppress Pa050 -o
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\utils\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\ARM\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\AmbiqMicro\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\mcu\apollo3\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\devices\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\bsp\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\sound\
#        -On)
#    Locale       =  C
#    List file    =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_itm.lst
#    Object file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_itm.o
#
###############################################################################

C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_itm.c
      1          //*****************************************************************************
      2          //
      3          //  am_hal_itm.c
      4          //! @file
      5          //!
      6          //! @brief Functions for operating the instrumentation trace macrocell
      7          //!
      8          //! @addtogroup itm3 Instrumentation Trace Macrocell (ITM)
      9          //! @ingroup apollo3hal
     10          //! @{
     11          //
     12          //*****************************************************************************
     13          
     14          //*****************************************************************************
     15          //
     16          // Copyright (c) 2019, Ambiq Micro
     17          // All rights reserved.
     18          // 
     19          // Redistribution and use in source and binary forms, with or without
     20          // modification, are permitted provided that the following conditions are met:
     21          // 
     22          // 1. Redistributions of source code must retain the above copyright notice,
     23          // this list of conditions and the following disclaimer.
     24          // 
     25          // 2. Redistributions in binary form must reproduce the above copyright
     26          // notice, this list of conditions and the following disclaimer in the
     27          // documentation and/or other materials provided with the distribution.
     28          // 
     29          // 3. Neither the name of the copyright holder nor the names of its
     30          // contributors may be used to endorse or promote products derived from this
     31          // software without specific prior written permission.
     32          // 
     33          // Third party software included in this distribution is subject to the
     34          // additional license terms as defined in the /docs/licenses directory.
     35          // 
     36          // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     37          // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     38          // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     39          // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     40          // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     41          // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     42          // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     43          // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     44          // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     45          // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     46          // POSSIBILITY OF SUCH DAMAGE.
     47          //
     48          // This is part of revision v2.0.0 of the AmbiqSuite Development Package.
     49          //
     50          //*****************************************************************************
     51          
     52          #include <stdint.h>
     53          #include <stdbool.h>
     54          #include "am_mcu_apollo.h"
     55          
     56          //*****************************************************************************
     57          //
     58          // Global Variables
     59          //
     60          //*****************************************************************************
     61          
     62          //*****************************************************************************
     63          //
     64          //! @brief Enables the ITM
     65          //!
     66          //! This function enables the ARM ITM by setting the TRCENA bit in the DEMCR
     67          //! register.
     68          //!
     69          //! @return None.
     70          //
     71          //*****************************************************************************
     72          void
     73          am_hal_itm_enable(void)
     74          {
     75              //
     76              // To be able to access ITM registers, set the Trace Enable bit
     77              // in the Debug Exception and Monitor Control Register (DEMCR).
     78              //
     79              CoreDebug->DEMCR |= _VAL2FLD(CoreDebug_DEMCR_TRCENA, 1);
     80              while ( !(CoreDebug->DEMCR & _VAL2FLD(CoreDebug_DEMCR_TRCENA, 1)) );
     81          
     82              //
     83              // Write the key to the ITM Lock Access register to unlock the ITM_TCR.
     84              //
     85              ITM->LAR = ITM_LAR_KEYVAL;
     86          
     87              //
     88              // Set the enable bits in the ITM trace enable register, and the ITM
     89              // control registers to enable trace data output.
     90              //
     91              ITM->TPR = 0x0000000F;
     92              ITM->TER = 0xFFFFFFFF;
     93          
     94              //
     95              // Write to the ITM control and status register.
     96              //
     97              ITM->TCR =
     98                  _VAL2FLD(ITM_TCR_TraceBusID, 0x15)      |
     99                  _VAL2FLD(ITM_TCR_GTSFREQ, 1)            |
    100                  _VAL2FLD(ITM_TCR_TSPrescale, 1)         |
    101                  _VAL2FLD(ITM_TCR_SWOENA, 1)             |
    102                  _VAL2FLD(ITM_TCR_DWTENA, 0)             |
    103                  _VAL2FLD(ITM_TCR_SYNCENA, 0)            |
    104                  _VAL2FLD(ITM_TCR_TSENA, 0)              |
    105                  _VAL2FLD(ITM_TCR_ITMENA, 1);
    106          
    107          
    108          
    109          }
    110          
    111          //*****************************************************************************
    112          //
    113          //! @brief Disables the ITM
    114          //!
    115          //! This function completely disables the ARM ITM by resetting the TRCENA bit
    116          //! in the DEMCR register.
    117          //!
    118          //! @return None.
    119          //
    120          //*****************************************************************************
    121          void
    122          am_hal_itm_disable(void)
    123          {
    124          
    125              if ( MCUCTRL->TPIUCTRL == 0 )
    126              {
    127                  //
    128                  // This is a disable without enable, which could be the case with some
    129                  // earlier versions of SBL. To avoid a hang, ITM (particularly TPIU
    130                  // clock) must first be enabled.
    131                  //
    132                  am_hal_itm_enable();
    133              }
    134          
    135              //
    136              // Make sure the ITM/TPIU is not busy.
    137              //
    138              am_hal_itm_not_busy();
    139          
    140              //
    141              // Make sure the ITM_TCR is unlocked.
    142              //
    143              ITM->LAR = ITM_LAR_KEYVAL;
    144          
    145              //
    146              // Disable the ITM.
    147              //
    148              for (int ix = 0; ix < 100; ix++)
    149              {
    150                  ITM->TCR &= ~_VAL2FLD(ITM_TCR_ITMENA, 1);
    151                  while ( ITM->TCR  & (_VAL2FLD(ITM_TCR_ITMENA, 1)  |  _VAL2FLD(ITM_TCR_BUSY, 1)) );
    152              }
    153          
    154              //
    155              // Reset the TRCENA bit in the DEMCR register, which should disable the ITM
    156              // for operation.
    157              //
    158              CoreDebug->DEMCR &= ~_VAL2FLD(CoreDebug_DEMCR_TRCENA, 1);
    159              while ( CoreDebug->DEMCR & _VAL2FLD(CoreDebug_DEMCR_TRCENA, 1) );
    160          
    161              //
    162              // Disable the TPIU clock source in MCU control.
    163              //
    164              MCUCTRL->TPIUCTRL =
    165                  _VAL2FLD(MCUCTRL_TPIUCTRL_CLKSEL, MCUCTRL_TPIUCTRL_CLKSEL_LOWPWR) |
    166                  _VAL2FLD(MCUCTRL_TPIUCTRL_ENABLE, MCUCTRL_TPIUCTRL_ENABLE_DIS);
    167              while (MCUCTRL->TPIUCTRL);
    168          
    169          }
    170          
    171          //*****************************************************************************
    172          //
    173          //! @brief Checks if itm is busy and provides a delay to flush the fifo
    174          //!
    175          //! This function disables the ARM ITM by resetting the TRCENA bit in the DEMCR
    176          //! register.
    177          //!
    178          //! @return None.
    179          //
    180          //*****************************************************************************
    181          void
    182          am_hal_itm_not_busy(void)
    183          {
    184              //
    185              // Make sure the ITM/TPIU is not busy.
    186              //
    187              while (ITM->TCR & _VAL2FLD(ITM_TCR_BUSY, 1));
    188          
    189              //
    190              // wait for 50us for the data to flush out
    191              //
    192              am_hal_flash_delay(FLASH_CYCLES_US(50));
    193          }
    194          
    195          //*****************************************************************************
    196          //
    197          //! @brief Enables tracing on a given set of ITM ports
    198          //!
    199          //! @param ui8portNum - Set ports to be enabled
    200          //!
    201          //! Enables tracing on the ports referred to by \e ui8portNum by writing the
    202          //! associated bit in the Trace Privilege Register in the ITM. The value for
    203          //! ui8portNum should be the logical OR one or more of the following values:
    204          //!
    205          //! \e ITM_PRIVMASK_0_7 - enable ports 0 through 7
    206          //! \e ITM_PRIVMASK_8_15 - enable ports 8 through 15
    207          //! \e ITM_PRIVMASK_16_23 - enable ports 16 through 23
    208          //! \e ITM_PRIVMASK_24_31 - enable ports 24 through 31
    209          //!
    210          //! @return None.
    211          //
    212          //*****************************************************************************
    213          void
    214          am_hal_itm_trace_port_enable(uint8_t ui8portNum)
    215          {
    216              ITM->TPR |= (0x00000001 << (ui8portNum>>3));
    217          }
    218          
    219          //*****************************************************************************
    220          //
    221          //! @brief Disable tracing on the given ITM stimulus port.
    222          //!
    223          //! @param ui8portNum
    224          //!
    225          //! Disables tracing on the ports referred to by \e ui8portNum by writing the
    226          //! associated bit in the Trace Privilege Register in the ITM. The value for
    227          //! ui8portNum should be the logical OR one or more of the following values:
    228          //!
    229          //! \e ITM_PRIVMASK_0_7 - disable ports 0 through 7
    230          //! \e ITM_PRIVMASK_8_15 - disable ports 8 through 15
    231          //! \e ITM_PRIVMASK_16_23 - disable ports 16 through 23
    232          //! \e ITM_PRIVMASK_24_31 - disable ports 24 through 31
    233          //!
    234          //! @return None.
    235          //
    236          //*****************************************************************************
    237          void
    238          am_hal_itm_trace_port_disable(uint8_t ui8portNum)
    239          {
    240              ITM->TPR &= ~(0x00000001 << (ui8portNum >> 3));
    241          }
    242          
    243          //*****************************************************************************
    244          //
    245          //! @brief Poll the given ITM stimulus register until not busy.
    246          //!
    247          //! @param ui32StimReg - stimulus register
    248          //!
    249          //! @return true if not busy, false if busy (timed out or other error).
    250          //
    251          //*****************************************************************************
    252          bool
    253          am_hal_itm_stimulus_not_busy(uint32_t ui32StimReg)
    254          {
    255              uint32_t ui32StimAddr = (uint32_t)&ITM->PORT[0] + (4 * ui32StimReg);
    256          
    257              //
    258              // Busy waiting until it is available, non-zero means ready.
    259              //
    260              while ( !AM_REGVAL(ui32StimAddr) );
    261          
    262              return true;
    263          }
    264          
    265          //*****************************************************************************
    266          //
    267          //! @brief Writes a 32-bit value to the given ITM stimulus register.
    268          //!
    269          //! @param ui32StimReg - stimulus register
    270          //! @param ui32Value - value to be written.
    271          //!
    272          //! Write a word to the desired stimulus register.
    273          //!
    274          //! @return None.
    275          //
    276          //*****************************************************************************
    277          void
    278          am_hal_itm_stimulus_reg_word_write(uint32_t ui32StimReg, uint32_t ui32Value)
    279          {
    280              uint32_t ui32StimAddr = (uint32_t)&ITM->PORT[0] + (4 * ui32StimReg);
    281          
    282          
    283              //
    284              // Busy waiting until it is available, non-zero means ready
    285              //
    286              while (!AM_REGVAL(ui32StimAddr));
    287          
    288              //
    289              // Write the register.
    290              //
    291              AM_REGVAL(ui32StimAddr) = ui32Value;
    292          }
    293          
    294          //*****************************************************************************
    295          //
    296          //! @brief Writes a short to the given ITM stimulus register.
    297          //!
    298          //! @param ui32StimReg - stimulus register
    299          //! @param ui16Value - short to be written.
    300          //!
    301          //! Write a short to the desired stimulus register.
    302          //!
    303          //! @return None.
    304          //
    305          //*****************************************************************************
    306          void
    307          am_hal_itm_stimulus_reg_short_write(uint32_t ui32StimReg, uint16_t ui16Value)
    308          {
    309              uint32_t ui32StimAddr = (uint32_t)&ITM->PORT[0] + (4 * ui32StimReg);
    310          
    311              //
    312              // Busy waiting until it is available non-zero means ready
    313              //
    314              while ( !AM_REGVAL(ui32StimAddr) );
    315          
    316              //
    317              // Write the register.
    318              //
    319              *((volatile uint16_t *) ui32StimAddr) = ui16Value;
    320          }
    321          
    322          //*****************************************************************************
    323          //
    324          //! @brief Writes a byte to the given ITM stimulus register.
    325          //!
    326          //! @param ui32StimReg - stimulus register
    327          //! @param ui8Value - byte to be written.
    328          //!
    329          //! Write a byte to the desired stimulus register.
    330          //!
    331          //! @return None.
    332          //
    333          //*****************************************************************************
    334          void
    335          am_hal_itm_stimulus_reg_byte_write(uint32_t ui32StimReg, uint8_t ui8Value)
    336          {
    337              uint32_t ui32StimAddr = (uint32_t)&ITM->PORT[0] + (4 * ui32StimReg);
    338          
    339              //
    340              // Busy waiting until it is available (non-zero means ready)
    341              //
    342              while (!AM_REGVAL(ui32StimAddr));
    343          
    344              //
    345              // Write the register.
    346              //
    347              *((volatile uint8_t *) ui32StimAddr) = ui8Value;
    348          }
    349          
    350          //*****************************************************************************
    351          //
    352          //! @brief Sends a Sync Packet.
    353          //!
    354          //! Sends a sync packet. This can be useful for external software should it
    355          //! become out of sync with the ITM stream.
    356          //!
    357          //! @return None.
    358          //
    359          //*****************************************************************************
    360          void
    361          am_hal_itm_sync_send(void)
    362          {
    363              //
    364              // Write the register.
    365              //
    366              am_hal_itm_stimulus_reg_word_write(AM_HAL_ITM_SYNC_REG,
    367                                                 AM_HAL_ITM_SYNC_VAL);
    368          }
    369          
    370          //*****************************************************************************
    371          //
    372          //! @brief Poll the print stimulus registers until not busy.
    373          //!
    374          //! @return true if not busy, false if busy (timed out or other error).
    375          //
    376          //*****************************************************************************
    377          bool
    378          am_hal_itm_print_not_busy(void)
    379          {
    380              //
    381              // Poll stimulus register allocated for printing.
    382              //
    383              am_hal_itm_stimulus_not_busy(0);
    384          
    385          
    386              return true;
    387          }
    388          
    389          //*****************************************************************************
    390          //
    391          //! @brief Prints a char string out of the ITM.
    392          //!
    393          //! @param pcString pointer to the character sting
    394          //!
    395          //! This function prints a sting out of the ITM.
    396          //!
    397          //! @return None.
    398          //
    399          //*****************************************************************************
    400          void
    401          am_hal_itm_print(char *pcString)
    402          {
    403              uint32_t ui32Length = 0;
    404          
    405              //
    406              // Determine the length of the string.
    407              //
    408              while (*(pcString + ui32Length))
    409              {
    410                  ui32Length++;
    411              }
    412          
    413              //
    414              // If there is no longer a word left, empty out the remaining characters.
    415              //
    416              while (ui32Length)
    417              {
    418                      //
    419                      // Print string out the ITM.
    420                      //
    421                      am_hal_itm_stimulus_reg_byte_write(0, (uint8_t)*pcString++);
    422          
    423                      //
    424                      // Subtract from length.
    425                      //
    426                      ui32Length--;
    427              }
    428          }
    429          //*****************************************************************************
    430          //
    431          // End Doxygen group.
    432          //! @}
    433          //
    434          //*****************************************************************************

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   am_hal_itm_disable
         8   -> am_hal_itm_enable
         8   -> am_hal_itm_not_busy
       0   am_hal_itm_enable
       8   am_hal_itm_not_busy
         8   -> am_hal_flash_delay
      16   am_hal_itm_print
        16   -> am_hal_itm_stimulus_reg_byte_write
       8   am_hal_itm_print_not_busy
         8   -> am_hal_itm_stimulus_not_busy
       0   am_hal_itm_stimulus_not_busy
       0   am_hal_itm_stimulus_reg_byte_write
       0   am_hal_itm_stimulus_reg_short_write
       0   am_hal_itm_stimulus_reg_word_write
       8   am_hal_itm_sync_send
         8   -> am_hal_itm_stimulus_reg_word_write
       4   am_hal_itm_trace_port_disable
       4   am_hal_itm_trace_port_enable


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
      80  am_hal_itm_disable
      44  am_hal_itm_enable
      20  am_hal_itm_not_busy
      36  am_hal_itm_print
      12  am_hal_itm_print_not_busy
      18  am_hal_itm_stimulus_not_busy
      16  am_hal_itm_stimulus_reg_byte_write
      16  am_hal_itm_stimulus_reg_short_write
      16  am_hal_itm_stimulus_reg_word_write
      14  am_hal_itm_sync_send
      24  am_hal_itm_trace_port_disable
      24  am_hal_itm_trace_port_enable

 
 356 bytes in section .text
 
 356 bytes of CODE memory

Errors: none
Warnings: none
