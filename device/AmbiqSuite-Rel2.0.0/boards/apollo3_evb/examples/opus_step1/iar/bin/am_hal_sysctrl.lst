###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         12/Mar/2019  10:07:10
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_sysctrl.c
#    Command line =  
#        -f C:\temp\EW8BCD.tmp
#        (C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_sysctrl.c
#        -D iar -D AM_PART_APOLLO3 -D AM_PACKAGE_BGA -lcN
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --diag_suppress Pa050 -o
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\utils\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\ARM\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\AmbiqMicro\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\mcu\apollo3\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\devices\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\bsp\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\sound\
#        -On)
#    Locale       =  C
#    List file    =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_sysctrl.lst
#    Object file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_sysctrl.o
#
###############################################################################

C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_sysctrl.c
      1          //*****************************************************************************
      2          //
      3          //  am_hal_sysctrl.c
      4          //! @file
      5          //!
      6          //! @brief Functions for interfacing with the M4F system control registers
      7          //!
      8          //! @addtogroup sysctrl3 System Control (SYSCTRL)
      9          //! @ingroup apollo3hal
     10          //! @{
     11          //
     12          //*****************************************************************************
     13          
     14          //*****************************************************************************
     15          //
     16          // Copyright (c) 2019, Ambiq Micro
     17          // All rights reserved.
     18          // 
     19          // Redistribution and use in source and binary forms, with or without
     20          // modification, are permitted provided that the following conditions are met:
     21          // 
     22          // 1. Redistributions of source code must retain the above copyright notice,
     23          // this list of conditions and the following disclaimer.
     24          // 
     25          // 2. Redistributions in binary form must reproduce the above copyright
     26          // notice, this list of conditions and the following disclaimer in the
     27          // documentation and/or other materials provided with the distribution.
     28          // 
     29          // 3. Neither the name of the copyright holder nor the names of its
     30          // contributors may be used to endorse or promote products derived from this
     31          // software without specific prior written permission.
     32          // 
     33          // Third party software included in this distribution is subject to the
     34          // additional license terms as defined in the /docs/licenses directory.
     35          // 
     36          // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     37          // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     38          // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     39          // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     40          // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     41          // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     42          // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     43          // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     44          // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     45          // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     46          // POSSIBILITY OF SUCH DAMAGE.
     47          //
     48          // This is part of revision v2.0.0 of the AmbiqSuite Development Package.
     49          //
     50          //*****************************************************************************
     51          
     52          #include <stdint.h>
     53          #include <stdbool.h>
     54          #include "am_mcu_apollo.h"
     55          
     56          
     57          //*****************************************************************************
     58          //
     59          //  Globals
     60          //
     61          //*****************************************************************************
     62          //
     63          // g_ui32BusWriteFlush is used by the macro, am_hal_sysctrl_bus_write_flush().
     64          // It is made global here to avoid compiler 'set but not used' warnings.
     65          //
     66          static volatile uint32_t g_ui32BusWriteFlush;
     67          
     68          //*****************************************************************************
     69          //
     70          //! @brief Place the core into sleep or deepsleep.
     71          //!
     72          //! @param bSleepDeep - False for Normal or True Deep sleep.
     73          //!
     74          //! This function puts the MCU to sleep or deepsleep depending on bSleepDeep.
     75          //!
     76          //! Valid values for bSleepDeep are:
     77          //!
     78          //!     AM_HAL_SYSCTRL_SLEEP_NORMAL
     79          //!     AM_HAL_SYSCTRL_SLEEP_DEEP
     80          //!
     81          //! @return None.
     82          //
     83          //*****************************************************************************
     84          void
     85          am_hal_sysctrl_sleep(bool bSleepDeep)
     86          {
     87              //
     88              // Disable interrupts and save the previous interrupt state.
     89              //
     90              AM_CRITICAL_BEGIN
     91          
     92              //
     93              // If the user selected DEEPSLEEP and the TPIU is off, attempt to enter
     94              // DEEP SLEEP.
     95              //
     96              if ( (bSleepDeep == AM_HAL_SYSCTRL_SLEEP_DEEP)    &&
     97                   (MCUCTRL->TPIUCTRL_b.ENABLE == MCUCTRL_TPIUCTRL_ENABLE_DIS) )
     98              {
     99                  //
    100                  // Prepare the core for deepsleep (write 1 to the DEEPSLEEP bit).
    101                  //
    102                  SCB->SCR |= _VAL2FLD(SCB_SCR_SLEEPDEEP, 1);
    103              }
    104              else
    105              {
    106                  //
    107                  // Prepare the core for normal sleep (write 0 to the DEEPSLEEP bit).
    108                  //
    109                  SCB->SCR &= ~_VAL2FLD(SCB_SCR_SLEEPDEEP, 1);
    110              }
    111          
    112              //
    113              // Before executing WFI, flush any buffered core and peripheral writes.
    114              //
    115              __DSB();
    116              am_hal_sysctrl_bus_write_flush();
    117          
    118              //
    119              // Execute the sleep instruction.
    120              //
    121              __WFI();
    122          
    123              //
    124              // Upon wake, execute the Instruction Sync Barrier instruction.
    125              //
    126              __ISB();
    127          
    128              //
    129              // Restore the interrupt state.
    130              //
    131              AM_CRITICAL_END
    132          }
    133          
    134          //*****************************************************************************
    135          //
    136          //! @brief Enable the floating point module.
    137          //!
    138          //! Call this function to enable the ARM hardware floating point module.
    139          //!
    140          //! @return None.
    141          //
    142          //*****************************************************************************
    143          void
    144          am_hal_sysctrl_fpu_enable(void)
    145          {
    146              //
    147              // Enable access to the FPU in both privileged and user modes.
    148              // NOTE: Write 0s to all reserved fields in this register.
    149              //
    150              SCB->CPACR = _VAL2FLD(SCB_CPACR_CP11, 0x3) |
    151                           _VAL2FLD(SCB_CPACR_CP10, 0x3);
    152          }
    153          
    154          //*****************************************************************************
    155          //
    156          //! @brief Disable the floating point module.
    157          //!
    158          //! Call this function to disable the ARM hardware floating point module.
    159          //!
    160          //! @return None.
    161          //
    162          //*****************************************************************************
    163          void
    164          am_hal_sysctrl_fpu_disable(void)
    165          {
    166              //
    167              // Disable access to the FPU in both privileged and user modes.
    168              // NOTE: Write 0s to all reserved fields in this register.
    169              //
    170              SCB->CPACR = 0x00000000                         &
    171                           ~(_VAL2FLD(SCB_CPACR_CP11, 0x3) |
    172                             _VAL2FLD(SCB_CPACR_CP10, 0x3));
    173          }
    174          
    175          //*****************************************************************************
    176          //
    177          //! @brief Enable stacking of FPU registers on exception entry.
    178          //!
    179          //! @param bLazy - Set to "true" to enable "lazy stacking".
    180          //!
    181          //! This function allows the core to save floating-point information to the
    182          //! stack on exception entry. Setting the bLazy option enables "lazy stacking"
    183          //! for interrupt handlers.  Normally, mixing floating-point code and interrupt
    184          //! driven routines causes increased interrupt latency, because the core must
    185          //! save extra information to the stack upon exception entry. With the lazy
    186          //! stacking option enabled, the core will skip the saving of floating-point
    187          //! registers when possible, reducing average interrupt latency.
    188          //!
    189          //! @note At reset of the Cortex M4, the ASPEN and LSPEN bits are set to 1,
    190          //! enabling Lazy mode by default. Therefore this function will generally
    191          //! only have an affect when setting for full-context save (or when switching
    192          //! from full-context to lazy mode).
    193          //!
    194          //! @note See also:
    195          //! infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dai0298a/DAFGGBJD.html
    196          //!
    197          //! @note Three valid FPU context saving modes are possible.
    198          //! 1. Lazy           ASPEN=1 LSPEN=1 am_hal_sysctrl_fpu_stacking_enable(true)
    199          //!                                   and default.
    200          //! 2. Full-context   ASPEN=1 LSPEN=0 am_hal_sysctrl_fpu_stacking_enable(false)
    201          //! 3. No FPU state   ASPEN=0 LSPEN=0 am_hal_sysctrl_fpu_stacking_disable()
    202          //! 4. Invalid        ASPEN=0 LSPEN=1
    203          //!
    204          //! @return None.
    205          //
    206          //*****************************************************************************
    207          void
    208          am_hal_sysctrl_fpu_stacking_enable(bool bLazy)
    209          {
    210              uint32_t ui32fpccr;
    211          
    212              //
    213              // Set the requested FPU stacking mode in ISRs.
    214              //
    215              AM_CRITICAL_BEGIN
    216          #define SYSCTRL_FPCCR_LAZY  (FPU_FPCCR_ASPEN_Msk | FPU_FPCCR_LSPEN_Msk)
    217              ui32fpccr  = FPU->FPCCR;
    218              ui32fpccr &= ~SYSCTRL_FPCCR_LAZY;
    219              ui32fpccr |= (bLazy ? SYSCTRL_FPCCR_LAZY : FPU_FPCCR_ASPEN_Msk);
    220              FPU->FPCCR = ui32fpccr;
    221              AM_CRITICAL_END
    222          }
    223          
    224          //*****************************************************************************
    225          //
    226          //! @brief Disable FPU register stacking on exception entry.
    227          //!
    228          //! This function disables all stacking of floating point registers for
    229          //! interrupt handlers.  This mode should only be used when it is absolutely
    230          //! known that no FPU instructions will be executed in an ISR.
    231          //!
    232          //! @return None.
    233          //
    234          //*****************************************************************************
    235          void
    236          am_hal_sysctrl_fpu_stacking_disable(void)
    237          {
    238              //
    239              // Completely disable FPU context save on entry to ISRs.
    240              //
    241              AM_CRITICAL_BEGIN
    242              FPU->FPCCR &= ~SYSCTRL_FPCCR_LAZY;
    243              AM_CRITICAL_END
    244          }
    245          
    246          //*****************************************************************************
    247          //
    248          //! @brief Issue a system wide reset using the AIRCR bit in the M4 system ctrl.
    249          //!
    250          //! This function issues a system wide reset (Apollo POR level reset).
    251          //!
    252          //! @return None.
    253          //
    254          //*****************************************************************************
    255          void
    256          am_hal_sysctrl_aircr_reset(void)
    257          {
    258              //
    259              // Set the system reset bit in the AIRCR register
    260              //
    261              __NVIC_SystemReset();
    262          }
    263          
    264          //*****************************************************************************
    265          //
    266          // End Doxygen group.
    267          //! @}
    268          //
    269          //*****************************************************************************

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   __NVIC_SystemReset
       8   am_hal_sysctrl_aircr_reset
         8   -> __NVIC_SystemReset
       0   am_hal_sysctrl_fpu_disable
       0   am_hal_sysctrl_fpu_enable
       8   am_hal_sysctrl_fpu_stacking_disable
         8   -> am_hal_interrupt_master_disable
         8   -> am_hal_interrupt_master_set
      16   am_hal_sysctrl_fpu_stacking_enable
        16   -> am_hal_interrupt_master_disable
        16   -> am_hal_interrupt_master_set
      16   am_hal_sysctrl_sleep
        16   -> am_hal_interrupt_master_disable
        16   -> am_hal_interrupt_master_set


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
      26  __NVIC_SystemReset
       8  am_hal_sysctrl_aircr_reset
       8  am_hal_sysctrl_fpu_disable
      10  am_hal_sysctrl_fpu_enable
      26  am_hal_sysctrl_fpu_stacking_disable
      48  am_hal_sysctrl_fpu_stacking_enable
      74  am_hal_sysctrl_sleep
       4  g_ui32BusWriteFlush

 
   4 bytes in section .bss
 232 bytes in section .text
 
 232 bytes of CODE memory
   4 bytes of DATA memory

Errors: none
Warnings: none
