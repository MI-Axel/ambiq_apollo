###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         12/Mar/2019  10:07:06
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_cachectrl.c
#    Command line =  
#        -f C:\temp\EW7E29.tmp
#        (C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_cachectrl.c
#        -D iar -D AM_PART_APOLLO3 -D AM_PACKAGE_BGA -lcN
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --diag_suppress Pa050 -o
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\utils\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\ARM\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\AmbiqMicro\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\mcu\apollo3\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\devices\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\bsp\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\sound\
#        -On)
#    Locale       =  C
#    List file    =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_cachectrl.lst
#    Object file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_cachectrl.o
#
###############################################################################

C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_cachectrl.c
      1          //*****************************************************************************
      2          //
      3          //  am_hal_cachectrl.c
      4          //! @file
      5          //!
      6          //! @brief Functions for interfacing with the CACHE controller.
      7          //!
      8          //! @addtogroup clkgen3 Clock Generator (CACHE)
      9          //! @ingroup apollo3hal
     10          //! @{
     11          //
     12          //*****************************************************************************
     13          
     14          //*****************************************************************************
     15          //
     16          // Copyright (c) 2019, Ambiq Micro
     17          // All rights reserved.
     18          // 
     19          // Redistribution and use in source and binary forms, with or without
     20          // modification, are permitted provided that the following conditions are met:
     21          // 
     22          // 1. Redistributions of source code must retain the above copyright notice,
     23          // this list of conditions and the following disclaimer.
     24          // 
     25          // 2. Redistributions in binary form must reproduce the above copyright
     26          // notice, this list of conditions and the following disclaimer in the
     27          // documentation and/or other materials provided with the distribution.
     28          // 
     29          // 3. Neither the name of the copyright holder nor the names of its
     30          // contributors may be used to endorse or promote products derived from this
     31          // software without specific prior written permission.
     32          // 
     33          // Third party software included in this distribution is subject to the
     34          // additional license terms as defined in the /docs/licenses directory.
     35          // 
     36          // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     37          // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     38          // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     39          // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     40          // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     41          // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     42          // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     43          // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     44          // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     45          // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     46          // POSSIBILITY OF SUCH DAMAGE.
     47          //
     48          // This is part of revision v2.0.0 of the AmbiqSuite Development Package.
     49          //
     50          //*****************************************************************************
     51          
     52          #include <stdint.h>
     53          #include <stdbool.h>
     54          #include "am_mcu_apollo.h"
     55          
     56          //*****************************************************************************
     57          //
     58          //  Default settings for the cache.
     59          //
     60          //*****************************************************************************
     61          const am_hal_cachectrl_config_t am_hal_cachectrl_defaults =
     62          {
     63              .bLRU                       = 0,
     64              .eDescript                  = AM_HAL_CACHECTRL_DESCR_1WAY_128B_1024E,
     65              .eMode                      = AM_HAL_CACHECTRL_CONFIG_MODE_INSTR_DATA,
     66              .eEnableNCregions           = AM_HAL_CACHECTRL_CONFIG_NCREG_NONE,
     67          };
     68          
     69          //*****************************************************************************
     70          //
     71          //  Configure the cache with given and recommended settings, but do not enable.
     72          //
     73          //*****************************************************************************
     74          uint32_t
     75          am_hal_cachectrl_config(const am_hal_cachectrl_config_t *psConfig)
     76          {
     77              //
     78              // In the case where cache is currently enabled, we need to gracefully
     79              // bow out of that configuration before reconfiguring.  The best way to
     80              // accomplish that is to shut down the ID bits, leaving the cache enabled.
     81              // Once the instr and data caches have been disabled, we can safely set
     82              // any new configuration, including disabling the controller.
     83              //
     84              AM_CRITICAL_BEGIN
     85              CACHECTRL->CACHECFG &=
     86                  ~(CACHECTRL_CACHECFG_DCACHE_ENABLE_Msk  |
     87                    CACHECTRL_CACHECFG_ICACHE_ENABLE_Msk);
     88              AM_CRITICAL_END
     89          
     90              CACHECTRL->CACHECFG =
     91                  _VAL2FLD(CACHECTRL_CACHECFG_ENABLE, 0)                              |
     92                  _VAL2FLD(CACHECTRL_CACHECFG_CACHE_CLKGATE, 1)                       |
     93                  _VAL2FLD(CACHECTRL_CACHECFG_CACHE_LS, 0)                            |
     94                  _VAL2FLD(CACHECTRL_CACHECFG_DATA_CLKGATE, 1)                        |
     95                  _VAL2FLD(CACHECTRL_CACHECFG_ENABLE_MONITOR, 0)                      |
     96                  _VAL2FLD(CACHECTRL_CACHECFG_LRU, psConfig->bLRU)                    |
     97                  _VAL2FLD(CACHECTRL_CACHECFG_CONFIG, psConfig->eDescript)            |
     98                  ((psConfig->eEnableNCregions << CACHECTRL_CACHECFG_ENABLE_NC0_Pos) &
     99                      (CACHECTRL_CACHECFG_ENABLE_NC1_Msk      |
    100                       CACHECTRL_CACHECFG_ENABLE_NC0_Msk))                            |
    101                  ((psConfig->eMode << CACHECTRL_CACHECFG_ICACHE_ENABLE_Pos) &
    102                      (CACHECTRL_CACHECFG_DCACHE_ENABLE_Msk   |
    103                       CACHECTRL_CACHECFG_ICACHE_ENABLE_Msk));
    104          
    105          
    106              return AM_HAL_STATUS_SUCCESS;
    107          
    108          } // am_hal_cachectrl_enable()
    109          
    110          //*****************************************************************************
    111          //
    112          //  Enable the cache.
    113          //
    114          //*****************************************************************************
    115          uint32_t
    116          am_hal_cachectrl_enable(void)
    117          {
    118              CACHECTRL->CACHECFG |= _VAL2FLD(CACHECTRL_CACHECFG_ENABLE, 1);
    119          
    120              return AM_HAL_STATUS_SUCCESS;
    121          } // am_hal_cachectrl_enable()
    122          
    123          //*****************************************************************************
    124          //
    125          //  Disable the cache.
    126          //
    127          //*****************************************************************************
    128          uint32_t
    129          am_hal_cachectrl_disable(void)
    130          {
    131              //
    132              // Shut down as gracefully as possible.
    133              // Disable the I/D cache enable bits first to allow a little time
    134              // for any in-flight transactions to hand off to the line buffer.
    135              // Then clear the enable.
    136              //
    137              AM_CRITICAL_BEGIN
    138              CACHECTRL->CACHECFG &= ~(_VAL2FLD(CACHECTRL_CACHECFG_ICACHE_ENABLE, 1) |
    139                                       _VAL2FLD(CACHECTRL_CACHECFG_DCACHE_ENABLE, 1));
    140              CACHECTRL->CACHECFG &= ~_VAL2FLD(CACHECTRL_CACHECFG_ENABLE, 1);
    141              AM_CRITICAL_END
    142          
    143              return AM_HAL_STATUS_SUCCESS;
    144          } // am_hal_cachectrl_disable()
    145          
    146          //*****************************************************************************
    147          //
    148          //  Select the cache configuration type.
    149          //
    150          //*****************************************************************************
    151          uint32_t
    152          am_hal_cachectrl_control(am_hal_cachectrl_control_e eControl, void *pArgs)
    153          {
    154              uint32_t ui32Val;
    155              uint32_t ui32SetMask = 0;
    156          
    157              switch ( eControl )
    158              {
    159                  case AM_HAL_CACHECTRL_CONTROL_FLASH_CACHE_INVALIDATE:
    160                      ui32SetMask = CACHECTRL_CTRL_INVALIDATE_Msk;
    161                      break;
    162                  case AM_HAL_CACHECTRL_CONTROL_STATISTICS_RESET:
    163                      if ( !_FLD2VAL(CACHECTRL_CACHECFG_ENABLE_MONITOR, CACHECTRL->CACHECFG) )
    164                      {
    165                          //
    166                          // The monitor must be enabled for the reset to have any affect.
    167                          //
    168                          return AM_HAL_STATUS_INVALID_OPERATION;
    169                      }
    170                      else
    171                      {
    172                          ui32SetMask = CACHECTRL_CTRL_RESET_STAT_Msk;
    173                      }
    174                      break;
    175                  case AM_HAL_CACHECTRL_CONTROL_FLASH_ALL_SLEEP_ENABLE:
    176                      ui32SetMask = CACHECTRL_CTRL_FLASH0_SLM_ENABLE_Msk      |
    177                                    CACHECTRL_CTRL_FLASH1_SLM_ENABLE_Msk;
    178                      break;
    179                  case AM_HAL_CACHECTRL_CONTROL_FLASH_ALL_SLEEP_DISABLE:
    180                      ui32SetMask = CACHECTRL_CTRL_FLASH0_SLM_DISABLE_Msk     |
    181                                    CACHECTRL_CTRL_FLASH1_SLM_DISABLE_Msk;
    182                      break;
    183                  case AM_HAL_CACHECTRL_CONTROL_FLASH0_SLEEP_ENABLE:
    184                      ui32SetMask = CACHECTRL_CTRL_FLASH0_SLM_ENABLE_Msk;
    185                      break;
    186                  case AM_HAL_CACHECTRL_CONTROL_FLASH0_SLEEP_DISABLE:
    187                      ui32SetMask = CACHECTRL_CTRL_FLASH0_SLM_DISABLE_Msk;
    188                      break;
    189                  case AM_HAL_CACHECTRL_CONTROL_FLASH1_SLEEP_ENABLE:
    190                      ui32SetMask = CACHECTRL_CTRL_FLASH1_SLM_ENABLE_Msk;
    191                      break;
    192                  case AM_HAL_CACHECTRL_CONTROL_FLASH1_SLEEP_DISABLE:
    193                      ui32SetMask = CACHECTRL_CTRL_FLASH1_SLM_DISABLE_Msk;
    194                      break;
    195                  case AM_HAL_CACHECTRL_CONTROL_MONITOR_ENABLE:
    196                      ui32SetMask = 0;
    197                      AM_CRITICAL_BEGIN
    198                      CACHECTRL->CACHECFG |= CACHECTRL_CACHECFG_ENABLE_MONITOR_Msk;
    199                      AM_CRITICAL_END
    200                      break;
    201                  case AM_HAL_CACHECTRL_CONTROL_MONITOR_DISABLE:
    202                      ui32SetMask = 0;
    203                      AM_CRITICAL_BEGIN
    204                      CACHECTRL->CACHECFG &= ~CACHECTRL_CACHECFG_ENABLE_MONITOR_Msk;
    205                      AM_CRITICAL_END
    206                      break;
    207                  case AM_HAL_CACHECTRL_CONTROL_LPMMODE_SET:
    208                      //
    209                      // Safely set LPMMODE.
    210                      // The new mode is passed by reference via pArgs.  That is, pArgs is
    211                      // assumed to be a pointer to a uint32_t of the new LPMMODE value.
    212                      //
    213                      if ( !pArgs  ||
    214                           (*((uint32_t*)pArgs) > CACHECTRL_FLASHCFG_LPMMODE_ALWAYS) )
    215                      {
    216                          return AM_HAL_STATUS_INVALID_ARG;
    217                      }
    218                      AM_CRITICAL_BEGIN
    219                      ui32Val = am_hal_flash_load_ui32((uint32_t*)&CACHECTRL->FLASHCFG);
    220                      ui32Val &= ~CACHECTRL_FLASHCFG_LPMMODE_Msk;
    221                      ui32Val |= _VAL2FLD(CACHECTRL_FLASHCFG_LPMMODE, *((uint32_t*)pArgs));
    222                      am_hal_flash_store_ui32((uint32_t*)&CACHECTRL->FLASHCFG, ui32Val);
    223                      AM_CRITICAL_END
    224                      break;
    225                  default:
    226                      return AM_HAL_STATUS_INVALID_ARG;
    227              }
    228          
    229              //
    230              // All fields in the CACHECTRL register are write-only or read-only.
    231              // A write to CACHECTRL acts as a mask-set.  That is, only the bits
    232              // written as '1' have an effect, any bits written as '0' are unaffected.
    233              //
    234              // Important note - setting of an enable and disable simultanously has
    235              // unpredicable results.
    236              //
    237              if ( ui32SetMask )
    238              {
    239                  CACHECTRL->CTRL = ui32SetMask;
    240              }
    241          
    242              return AM_HAL_STATUS_SUCCESS;
    243          
    244          } // am_hal_cachectrl_control()
    245          
    246          //*****************************************************************************
    247          //
    248          //  Cache controller status function
    249          //
    250          //*****************************************************************************
    251          uint32_t
    252          am_hal_cachectrl_status_get(am_hal_cachectrl_status_t *psStatus)
    253          {
    254              uint32_t ui32Status;
    255          
    256              if ( psStatus == NULL )
    257              {
    258                  return AM_HAL_STATUS_INVALID_ARG;
    259              }
    260          
    261              ui32Status = CACHECTRL->CTRL;
    262          
    263              psStatus->bFlash0SleepMode =
    264                  _FLD2VAL(CACHECTRL_CTRL_FLASH0_SLM_STATUS, ui32Status);
    265              psStatus->bFlash1SleepMode =
    266                  _FLD2VAL(CACHECTRL_CTRL_FLASH1_SLM_STATUS, ui32Status);
    267              psStatus->bCacheReady =
    268                  _FLD2VAL(CACHECTRL_CTRL_CACHE_READY, ui32Status);
    269          
    270              return AM_HAL_STATUS_SUCCESS;
    271          
    272          } // am_hal_cachectrl_status_get()
    273          
    274          
    275          //*****************************************************************************
    276          //
    277          // End Doxygen group.
    278          //! @}
    279          //
    280          //*****************************************************************************

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   am_hal_cachectrl_config
        16   -> am_hal_interrupt_master_disable
        16   -> am_hal_interrupt_master_set
      32   am_hal_cachectrl_control
        32   -> am_hal_flash_load_ui32
        32   -> am_hal_flash_store_ui32
        32   -> am_hal_interrupt_master_disable
        32   -> am_hal_interrupt_master_set
       8   am_hal_cachectrl_disable
         8   -> am_hal_interrupt_master_disable
         8   -> am_hal_interrupt_master_set
       0   am_hal_cachectrl_enable
       0   am_hal_cachectrl_status_get


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
      74  am_hal_cachectrl_config
     260  am_hal_cachectrl_control
       4  am_hal_cachectrl_defaults
      36  am_hal_cachectrl_disable
      14  am_hal_cachectrl_enable
      48  am_hal_cachectrl_status_get

 
   4 bytes in section .rodata
 444 bytes in section .text
 
 444 bytes of CODE  memory
   4 bytes of CONST memory

Errors: none
Warnings: none
