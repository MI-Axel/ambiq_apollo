###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         12/Mar/2019  10:07:06
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_burst.c
#    Command line =  
#        -f C:\temp\EW7E28.tmp
#        (C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_burst.c
#        -D iar -D AM_PART_APOLLO3 -D AM_PACKAGE_BGA -lcN
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --diag_suppress Pa050 -o
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\utils\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\ARM\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\AmbiqMicro\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\mcu\apollo3\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\devices\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\bsp\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\sound\
#        -On)
#    Locale       =  C
#    List file    =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_burst.lst
#    Object file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_burst.o
#
###############################################################################

C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_burst.c
      1          //*****************************************************************************
      2          //
      3          //  am_hal_burst.c
      4          //! @file
      5          //!
      6          //! @brief Functions for controlling Burst Mode operation.
      7          //!
      8          //! @addtogroup burstmode3
      9          //! @ingroup apollo3hal
     10          //! @{
     11          //
     12          //*****************************************************************************
     13          
     14          //*****************************************************************************
     15          //
     16          // Copyright (c) 2019, Ambiq Micro
     17          // All rights reserved.
     18          // 
     19          // Redistribution and use in source and binary forms, with or without
     20          // modification, are permitted provided that the following conditions are met:
     21          // 
     22          // 1. Redistributions of source code must retain the above copyright notice,
     23          // this list of conditions and the following disclaimer.
     24          // 
     25          // 2. Redistributions in binary form must reproduce the above copyright
     26          // notice, this list of conditions and the following disclaimer in the
     27          // documentation and/or other materials provided with the distribution.
     28          // 
     29          // 3. Neither the name of the copyright holder nor the names of its
     30          // contributors may be used to endorse or promote products derived from this
     31          // software without specific prior written permission.
     32          // 
     33          // Third party software included in this distribution is subject to the
     34          // additional license terms as defined in the /docs/licenses directory.
     35          // 
     36          // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     37          // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     38          // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     39          // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     40          // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     41          // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     42          // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     43          // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     44          // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     45          // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     46          // POSSIBILITY OF SUCH DAMAGE.
     47          //
     48          // This is part of revision v2.0.0 of the AmbiqSuite Development Package.
     49          //
     50          //*****************************************************************************
     51          
     52          #include <stdint.h>
     53          #include <stdbool.h>
     54          #include "am_mcu_apollo.h"
     55          #include "am_util.h"
     56          
     57          //
     58          // Globals.
     59          //
     60          bool    g_am_hal_burst_mode_available = false;
     61          
     62          // ****************************************************************************
     63          //
     64          //  am_hal_burst_mode_initialize()
     65          //  Burst mode initialization function
     66          //
     67          // ****************************************************************************
     68          uint32_t
     69          am_hal_burst_mode_initialize(am_hal_burst_avail_e *peBurstAvail)
     70          {
     71              uint32_t    ui32Status;
     72              //
     73              // Check if the Burst Mode feature is available based on the SKU.
     74              //
     75              if ( 0 == MCUCTRL->SKU_b.ALLOWBURST )
     76              {
     77                  //
     78                  // Burst mode is not available.
     79                  //
     80                  g_am_hal_burst_mode_available = false;
     81                  *peBurstAvail = AM_HAL_BURST_NOTAVAIL;
     82                  return AM_HAL_STATUS_INVALID_OPERATION;
     83              }
     84          
     85              //
     86              // Enable the Burst Feature Event (DEVPWREVENTEN).
     87              //
     88              PWRCTRL->DEVPWREVENTEN_b.BURSTEVEN = 1;
     89          
     90              //
     91              // BLE buck is shared by Burst as well
     92              // Enable the BLE buck trim values if in use
     93              //
     94              if (PWRCTRL->SUPPLYSRC_b.BLEBUCKEN)
     95              {
     96                  if ( APOLLO3_GE_A1 )
     97                  {
     98                      CLKGEN->BLEBUCKTONADJ =
     99                          _VAL2FLD(CLKGEN_BLEBUCKTONADJ_ZEROLENDETECTEN, CLKGEN_BLEBUCKTONADJ_ZEROLENDETECTEN_EN)         |
    100                          _VAL2FLD(CLKGEN_BLEBUCKTONADJ_ZEROLENDETECTTRIM, CLKGEN_BLEBUCKTONADJ_ZEROLENDETECTTRIM_SetF)   |
    101                          _VAL2FLD(CLKGEN_BLEBUCKTONADJ_TONADJUSTEN, CLKGEN_BLEBUCKTONADJ_TONADJUSTEN_EN)                 |
    102                          _VAL2FLD(CLKGEN_BLEBUCKTONADJ_TONADJUSTPERIOD, CLKGEN_BLEBUCKTONADJ_TONADJUSTPERIOD_HFRC_94KHz) |
    103                          _VAL2FLD(CLKGEN_BLEBUCKTONADJ_TONHIGHTHRESHOLD, 0x10)                                           |
    104                          _VAL2FLD(CLKGEN_BLEBUCKTONADJ_TONLOWTHRESHOLD, 0xF);
    105                  }
    106              }
    107          
    108              //
    109              // Enable the Burst Functionality (FEATUREENABLE).
    110              //
    111              MCUCTRL->FEATUREENABLE_b.BURSTREQ = 1;
    112          
    113              ui32Status = am_hal_flash_delay_status_check(10000,
    114                                      (uint32_t)&MCUCTRL->FEATUREENABLE,
    115                                      MCUCTRL_FEATUREENABLE_BURSTACK_Msk,
    116                                      MCUCTRL_FEATUREENABLE_BURSTACK_Msk,
    117                                      true);
    118          
    119              if ( ui32Status != AM_HAL_STATUS_SUCCESS )
    120              {
    121                  g_am_hal_burst_mode_available = false;
    122                  *peBurstAvail = AM_HAL_BURST_NOTAVAIL;
    123                  return ui32Status;
    124              }
    125          
    126              if ( 0 == MCUCTRL->FEATUREENABLE_b.BURSTAVAIL )
    127              {
    128                  //
    129                  // Burst mode is not available.
    130                  //
    131                  g_am_hal_burst_mode_available = false;
    132                  *peBurstAvail = AM_HAL_BURST_NOTAVAIL;
    133                  return AM_HAL_STATUS_INVALID_OPERATION;
    134              }
    135          
    136              //
    137              // Check the ACK for the Burst Functionality.
    138              //
    139              if ( MCUCTRL->FEATUREENABLE_b.BURSTACK == 0 )
    140              {
    141                  //
    142                  // If NACK, return status.
    143                  //
    144                  g_am_hal_burst_mode_available = false;
    145                  *peBurstAvail = AM_HAL_BURST_NOTAVAIL;
    146                  return AM_HAL_STATUS_INVALID_OPERATION;
    147              }
    148          
    149              //
    150              // Return Availability
    151              //
    152              g_am_hal_burst_mode_available = true;
    153              *peBurstAvail = AM_HAL_BURST_AVAIL;
    154              return AM_HAL_STATUS_SUCCESS;
    155          }
    156          
    157          // ****************************************************************************
    158          //
    159          //  am_hal_burst_mode_enable()
    160          //  Burst mode enable function
    161          //
    162          // ****************************************************************************
    163          uint32_t
    164          am_hal_burst_mode_enable(am_hal_burst_mode_e *peBurstStatus)
    165          {
    166              uint32_t    ui32Status;
    167          
    168              //
    169              // Check if Burst Mode is allowed and return status if it is not.
    170              //
    171              if (!g_am_hal_burst_mode_available)
    172              {
    173                  *peBurstStatus = AM_HAL_NORMAL_MODE;
    174                  return AM_HAL_STATUS_INVALID_OPERATION;
    175              }
    176          
    177              //
    178              // Request Burst Mode Enable (FREQCTRL)
    179              //
    180              CLKGEN->FREQCTRL_b.BURSTREQ = CLKGEN_FREQCTRL_BURSTREQ_EN;
    181          
    182          //    while (0 == AM_BFR(CLKGEN, FREQCTRL, BURSTACK));
    183              ui32Status = am_hal_flash_delay_status_check(10000,
    184                              (uint32_t)&CLKGEN->FREQCTRL,
    185                              CLKGEN_FREQCTRL_BURSTSTATUS_Msk,
    186                              CLKGEN_FREQCTRL_BURSTSTATUS_Msk,
    187                              true);
    188          
    189              if ( ui32Status != AM_HAL_STATUS_SUCCESS )
    190              {
    191                  *peBurstStatus = AM_HAL_NORMAL_MODE;
    192                  return ui32Status;
    193              }
    194          
    195              //
    196              // Check that the Burst Request was ACK'd.
    197              //
    198              if ( 0 == CLKGEN->FREQCTRL_b.BURSTACK )
    199              {
    200                  *peBurstStatus = AM_HAL_NORMAL_MODE;
    201                  return AM_HAL_STATUS_FAIL;
    202              }
    203          
    204              //
    205              // Check the Burst Mode Status (FREQCTRL)
    206              //
    207              if ( CLKGEN->FREQCTRL_b.BURSTSTATUS > 0)
    208              {
    209                  *peBurstStatus =  AM_HAL_BURST_MODE;
    210              }
    211              else
    212              {
    213                  *peBurstStatus =  AM_HAL_NORMAL_MODE;
    214              }
    215          
    216              return AM_HAL_STATUS_SUCCESS;
    217          }
    218          
    219          // ****************************************************************************
    220          //
    221          //  am_hal_burst_mode_disable()
    222          //  Burst mode disable function
    223          //
    224          // ****************************************************************************
    225          uint32_t
    226          am_hal_burst_mode_disable(am_hal_burst_mode_e *peBurstStatus)
    227          {
    228              uint32_t    ui32Status;
    229          
    230              //
    231              // Request Burst Mode Enable (FREQCTRL)
    232              //
    233              //
    234              // Safely disable burst mode.
    235              //
    236              AM_CRITICAL_BEGIN
    237              am_hal_flash_store_ui32((uint32_t*)&CLKGEN->FREQCTRL, CLKGEN_FREQCTRL_BURSTREQ_DIS);
    238              AM_CRITICAL_END
    239          
    240              //
    241              // Disable the Burst Feature Event (DEVPWREVENTEN).
    242              //
    243              PWRCTRL->DEVPWREVENTEN_b.BURSTEVEN = 0;
    244          
    245              ui32Status = am_hal_flash_delay_status_check(10000,
    246                                      (uint32_t)&CLKGEN->FREQCTRL,
    247                                      CLKGEN_FREQCTRL_BURSTSTATUS_Msk,
    248                                      0,
    249                                      true);
    250          
    251              if ( ui32Status != AM_HAL_STATUS_SUCCESS )
    252              {
    253                  *peBurstStatus = AM_HAL_NORMAL_MODE;
    254                  return ui32Status;
    255              }
    256          
    257              //
    258              // Check the Burst Mode Status (FREQCTRL)
    259              //
    260              //
    261              // Check the Burst Mode Status (FREQCTRL)
    262              //
    263              if ( CLKGEN->FREQCTRL_b.BURSTSTATUS > 0 )
    264              {
    265                  *peBurstStatus = AM_HAL_BURST_MODE;
    266              }
    267              else
    268              {
    269                  *peBurstStatus = AM_HAL_NORMAL_MODE;
    270              }
    271          
    272          
    273              return AM_HAL_STATUS_SUCCESS;
    274          }
    275          
    276          //*****************************************************************************
    277          //
    278          // am_hal_burst_mode_status() - Return current burst mode state.
    279          //
    280          // Implemented as a macro, this function returns the current burst mode state.
    281          //     AM_HAL_BURST_MODE
    282          //     AM_HAL_NORMAL_MODE
    283          //
    284          //*****************************************************************************
    285          
    286          //*****************************************************************************
    287          //
    288          // End Doxygen group.
    289          //! @}
    290          //
    291          //*****************************************************************************

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   am_hal_burst_mode_disable
        24   -> am_hal_flash_delay_status_check
        24   -> am_hal_flash_store_ui32
        24   -> am_hal_interrupt_master_disable
        24   -> am_hal_interrupt_master_set
      16   am_hal_burst_mode_enable
        16   -> am_hal_flash_delay_status_check
      16   am_hal_burst_mode_initialize
        16   -> am_hal_flash_delay_status_check


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
      92  am_hal_burst_mode_disable
     104  am_hal_burst_mode_enable
     172  am_hal_burst_mode_initialize
       1  g_am_hal_burst_mode_available

 
   1 byte  in section .bss
 404 bytes in section .text
 
 404 bytes of CODE memory
   1 byte  of DATA memory

Errors: none
Warnings: none
