###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         12/Mar/2019  10:07:06
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_adc.c
#    Command line =  
#        -f C:\temp\EW7AD7.tmp
#        (C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_adc.c
#        -D iar -D AM_PART_APOLLO3 -D AM_PACKAGE_BGA -lcN
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --diag_suppress Pa050 -o
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\utils\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\ARM\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\AmbiqMicro\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\mcu\apollo3\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\devices\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\bsp\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\sound\
#        -On)
#    Locale       =  C
#    List file    =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_adc.lst
#    Object file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_adc.o
#
###############################################################################

C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_adc.c
      1          //*****************************************************************************
      2          //
      3          //  am_hal_adc.c
      4          //! @file
      5          //!
      6          //! @brief Functions for interfacing with the Analog to Digital Converter.
      7          //!
      8          //! @addtogroup adc2 Analog-to-Digital Converter (ADC)
      9          //! @ingroup apollo2hal
     10          //! @{
     11          //
     12          //*****************************************************************************
     13          
     14          //*****************************************************************************
     15          //
     16          // Copyright (c) 2019, Ambiq Micro
     17          // All rights reserved.
     18          // 
     19          // Redistribution and use in source and binary forms, with or without
     20          // modification, are permitted provided that the following conditions are met:
     21          // 
     22          // 1. Redistributions of source code must retain the above copyright notice,
     23          // this list of conditions and the following disclaimer.
     24          // 
     25          // 2. Redistributions in binary form must reproduce the above copyright
     26          // notice, this list of conditions and the following disclaimer in the
     27          // documentation and/or other materials provided with the distribution.
     28          // 
     29          // 3. Neither the name of the copyright holder nor the names of its
     30          // contributors may be used to endorse or promote products derived from this
     31          // software without specific prior written permission.
     32          // 
     33          // Third party software included in this distribution is subject to the
     34          // additional license terms as defined in the /docs/licenses directory.
     35          // 
     36          // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     37          // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     38          // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     39          // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     40          // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     41          // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     42          // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     43          // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     44          // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     45          // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     46          // POSSIBILITY OF SUCH DAMAGE.
     47          //
     48          // This is part of revision v2.0.0 of the AmbiqSuite Development Package.
     49          //
     50          //*****************************************************************************
     51          
     52          #include <stdint.h>
     53          #include <stdbool.h>
     54          #include "am_mcu_apollo.h"
     55          
     56          //*****************************************************************************
     57          //
     58          // Private Types.
     59          //
     60          //*****************************************************************************
     61          
     62          #define AM_HAL_MAGIC_ADC                0xAFAFAF
     63          #define AM_HAL_ADC_CHK_HANDLE(h)        ((h) && ((am_hal_handle_prefix_t *)(h))->s.bInit && (((am_hal_handle_prefix_t *)(h))->s.magic == AM_HAL_MAGIC_ADC))
     64          
     65          //
     66          // ADC Power save register state.
     67          //
     68          typedef struct
     69          {
     70              bool          bValid;
     71              uint32_t      regCFG;
     72              uint32_t      regSL0CFG;
     73              uint32_t      regSL1CFG;
     74              uint32_t      regSL2CFG;
     75              uint32_t      regSL3CFG;
     76              uint32_t      regSL4CFG;
     77              uint32_t      regSL5CFG;
     78              uint32_t      regSL6CFG;
     79              uint32_t      regSL7CFG;
     80              uint32_t      regWULIM;
     81              uint32_t      regWLLIM;
     82              uint32_t      regINTEN;
     83          } am_hal_adc_register_state_t;
     84          
     85          //
     86          // ADC State structure.
     87          //
     88          typedef struct
     89          {
     90              //
     91              // Handle validation prefix.
     92              //
     93              am_hal_handle_prefix_t      prefix;
     94          
     95              //
     96              // Physical module number.
     97              //
     98              uint32_t                    ui32Module;
     99          
    100              //
    101              // ADC Capabilities.
    102              //
    103              am_hal_adc_capabilities_t   capabilities;
    104          
    105              // Power Save-Restore register state
    106              am_hal_adc_register_state_t registerState;
    107          
    108          } am_hal_adc_state_t;
    109          
    110          //*****************************************************************************
    111          //
    112          // Global Variables.
    113          //
    114          //*****************************************************************************
    115          am_hal_adc_state_t             g_ADCState[AM_REG_ADC_NUM_MODULES];
    116          
    117          uint32_t                       g_ADCSlotsConfigured;
    118          
    119          //*****************************************************************************
    120          //
    121          //! @brief ADC initialization function
    122          //!
    123          //! @param ui32Module   - module instance.
    124          //! @param handle       - returns the handle for the module instance.
    125          //!
    126          //! This function accepts a module instance, allocates the interface and then
    127          //! returns a handle to be used by the remaining interface functions.
    128          //!
    129          //! @return status      - generic or interface specific status.
    130          //
    131          //*****************************************************************************
    132          uint32_t
    133          am_hal_adc_initialize(uint32_t ui32Module, void **ppHandle)
    134          {
    135          
    136          #ifndef AM_HAL_DISABLE_API_VALIDATION
    137              //
    138              // Validate the module number
    139              //
    140              if ( ui32Module >= AM_REG_ADC_NUM_MODULES )
    141              {
    142                  return AM_HAL_STATUS_OUT_OF_RANGE;
    143              }
    144          
    145              //
    146              // Check for valid arguements.
    147              //
    148              if ( !ppHandle )
    149              {
    150                  return AM_HAL_STATUS_INVALID_ARG;
    151              }
    152          
    153              //
    154              // Check if the handle is unallocated.
    155              //
    156              if ( g_ADCState[ui32Module].prefix.s.bInit )
    157              {
    158                  return AM_HAL_STATUS_INVALID_OPERATION;
    159              }
    160          #endif
    161          
    162              //
    163              // Initialize the handle.
    164              //
    165              g_ADCState[ui32Module].prefix.s.bInit = true;
    166              g_ADCState[ui32Module].prefix.s.magic = AM_HAL_MAGIC_ADC;
    167              g_ADCState[ui32Module].ui32Module = ui32Module;
    168          
    169              //
    170              // Initialize the number of slots configured.
    171              //
    172              g_ADCSlotsConfigured = 0;
    173          
    174              //
    175              // Return the handle.
    176              //
    177              *ppHandle = (void *)&g_ADCState[ui32Module];
    178          
    179              //
    180              // Return the status.
    181              //
    182              return AM_HAL_STATUS_SUCCESS;
    183          }
    184          
    185          //*****************************************************************************
    186          //
    187          //! @brief MSPI deinitialization function
    188          //!
    189          //! @param handle       - returns the handle for the module instance.
    190          //!
    191          //! This function accepts a handle to an instance and de-initializes the
    192          //! interface.
    193          //!
    194          //! @return status      - generic or interface specific status.
    195          //
    196          //*****************************************************************************
    197          uint32_t
    198          am_hal_adc_deinitialize(void *pHandle)
    199          {
    200              uint32_t            status = AM_HAL_STATUS_SUCCESS;
    201              am_hal_adc_state_t  *pADCState = (am_hal_adc_state_t *)pHandle;
    202          
    203          #ifndef AM_HAL_DISABLE_API_VALIDATION
    204              //
    205              // Check the handle.
    206              //
    207              if ( !AM_HAL_ADC_CHK_HANDLE(pHandle) )
    208              {
    209                  return AM_HAL_STATUS_INVALID_HANDLE;
    210              }
    211          #endif
    212          
    213              if ( pADCState->prefix.s.bEnable )
    214              {
    215                  status = am_hal_adc_disable(pHandle);
    216              }
    217          
    218              pADCState->prefix.s.bInit = false;
    219          
    220              //
    221              // Return the status.
    222              //
    223              return status;
    224          }
    225          
    226          //*****************************************************************************
    227          //
    228          //! @brief ADC configuration function
    229          //!
    230          //! @param handle   - handle for the module instance.
    231          //! @param pConfig  - pointer to the configuration structure.
    232          //!
    233          //! This function configures the ADC for operation.
    234          //!
    235          //! @return status      - generic or interface specific status.
    236          //
    237          //*****************************************************************************
    238          uint32_t
    239          am_hal_adc_configure(void *pHandle,
    240                               am_hal_adc_config_t *psConfig)
    241          {
    242              uint32_t            ui32Config;
    243              am_hal_adc_state_t  *pADCState = (am_hal_adc_state_t *)pHandle;
    244              uint32_t            ui32Module = pADCState->ui32Module;
    245          
    246          #ifndef AM_HAL_DISABLE_API_VALIDATION
    247              //
    248              // Check the handle.
    249              //
    250              if ( !AM_HAL_ADC_CHK_HANDLE(pHandle) )
    251              {
    252                  return AM_HAL_STATUS_INVALID_HANDLE;
    253              }
    254          #endif
    255          
    256              ui32Config = 0;
    257          
    258              //
    259              // Set the ADC clock source.
    260              //
    261              ui32Config |= _VAL2FLD(ADC_CFG_CLKSEL, psConfig->eClock);
    262          
    263              //
    264              // Set the ADC trigger polarity.
    265              //
    266              ui32Config |= _VAL2FLD(ADC_CFG_TRIGPOL, psConfig->ePolarity);
    267          
    268              //
    269              // Set the ADC trigger.
    270              //
    271              ui32Config |= _VAL2FLD(ADC_CFG_TRIGSEL, psConfig->eTrigger);
    272          
    273              //
    274              // Set the ADC reference voltage.
    275              //
    276              ui32Config |= _VAL2FLD(ADC_CFG_REFSEL, psConfig->eReference);
    277          
    278              //
    279              // Set the Destructive FIFO read.
    280              //
    281              ui32Config |= _VAL2FLD(ADC_CFG_DFIFORDEN, 1);
    282          
    283              //
    284              // Set the ADC clock mode.
    285              //
    286              ui32Config |= _VAL2FLD(ADC_CFG_CKMODE, psConfig->eClockMode);
    287          
    288              //
    289              // Set the ADC low power mode.
    290              //
    291              ui32Config |= _VAL2FLD(ADC_CFG_LPMODE, psConfig->ePowerMode);
    292          
    293              //
    294              // Set the ADC repetition mode.
    295              //
    296              ui32Config |= _VAL2FLD(ADC_CFG_RPTEN, psConfig->eRepeat);
    297          
    298              //
    299              // Set the configuration in the ADC peripheral.
    300              //
    301              ADCn(ui32Module)->CFG = ui32Config;
    302          
    303              //
    304              // Return status.
    305              //
    306              return AM_HAL_STATUS_SUCCESS;
    307          }
    308          
    309          //*****************************************************************************
    310          //
    311          //! @brief ADC slot configuration function
    312          //!
    313          //! @param handle   - handle for the module instance.
    314          //! @param pConfig  - pointer to the configuration structure.
    315          //!
    316          //! This function configures the ADC slot for operation.
    317          //!
    318          //! @return status      - generic or interface specific status.
    319          //
    320          //*****************************************************************************
    321          uint32_t
    322          am_hal_adc_configure_slot(void *pHandle,
    323                                    uint32_t ui32SlotNumber,
    324                                    am_hal_adc_slot_config_t *pSlotConfig)
    325          {
    326              uint32_t            ui32Config;
    327              uint32_t            ui32RegOffset;
    328              am_hal_adc_state_t  *pADCState = (am_hal_adc_state_t *)pHandle;
    329              uint32_t            ui32Module = pADCState->ui32Module;
    330          
    331          #ifndef AM_HAL_DISABLE_API_VALIDATION
    332              //
    333              // Check the handle.
    334              //
    335              if ( !AM_HAL_ADC_CHK_HANDLE(pHandle) )
    336              {
    337                  return AM_HAL_STATUS_INVALID_HANDLE;
    338              }
    339          
    340              //
    341              // Check the slot number.
    342              //
    343              if ( ui32SlotNumber >= AM_HAL_ADC_MAX_SLOTS )
    344              {
    345                  return AM_HAL_STATUS_OUT_OF_RANGE;
    346              }
    347          #endif
    348          
    349              ui32Config = 0;
    350          
    351              //
    352              // Set the measurements to average
    353              //
    354              ui32Config |= _VAL2FLD(ADC_SL0CFG_ADSEL0, pSlotConfig->eMeasToAvg);
    355          
    356              //
    357              // Set the precision mode.
    358              //
    359              ui32Config |= _VAL2FLD(ADC_SL0CFG_PRMODE0, pSlotConfig->ePrecisionMode);
    360          
    361              //
    362              // Set the channel.
    363              //
    364              ui32Config |= _VAL2FLD(ADC_SL0CFG_CHSEL0, pSlotConfig->eChannel);
    365          
    366              //
    367              // Enable window comparison if configured.
    368              //
    369              ui32Config |= _VAL2FLD(ADC_SL0CFG_WCEN0, pSlotConfig->bWindowCompare);
    370          
    371              //
    372              // Enable the slot if configured.
    373              //
    374              ui32Config |= _VAL2FLD(ADC_SL0CFG_SLEN0, pSlotConfig->bEnabled);
    375          
    376              //
    377              // Locate the correct register for this ADC slot.
    378              //
    379              ui32RegOffset = ((uint32_t)&ADCn(ui32Module)->SL0CFG) + (4 * ui32SlotNumber);
    380          
    381              //
    382              // Write the register with the caller's configuration value.
    383              //
    384              AM_REGVAL(ui32RegOffset) = ui32Config;
    385          
    386              //
    387              // Update the nubmer of slots configured.
    388              //
    389              g_ADCSlotsConfigured++;
    390          
    391              //
    392              // Return the status.
    393              //
    394              return AM_HAL_STATUS_SUCCESS;
    395          }
    396          
    397          //*****************************************************************************
    398          //
    399          //! @brief ADC DMA configuration function
    400          //!
    401          //! @param handle   - handle for the module instance.
    402          //! @param pConfig  - pointer to the configuration structure.
    403          //!
    404          //! This function configures the ADC DMA for operation.
    405          //!
    406          //! @return status      - generic or interface specific status.
    407          //
    408          //*****************************************************************************
    409          uint32_t
    410          am_hal_adc_configure_dma(void *pHandle,
    411                                   am_hal_adc_dma_config_t *pDMAConfig)
    412          {
    413              uint32_t    ui32Config;
    414              uint32_t    ui32Module = ((am_hal_adc_state_t *)pHandle)->ui32Module;
    415          
    416          #ifndef AM_HAL_DISABLE_API_VALIDATION
    417              //
    418              // Check the handle.
    419              //
    420              if ( !AM_HAL_ADC_CHK_HANDLE(pHandle) )
    421              {
    422                  return AM_HAL_STATUS_INVALID_HANDLE;
    423              }
    424          #endif
    425          
    426              ui32Config = 0;
    427          
    428              //
    429              // Configure the DMA complete power-off.
    430              //
    431              ui32Config |= _VAL2FLD(ADC_DMACFG_DPWROFF, 0);      // DPWROFF not supported!
    432          
    433              //
    434              // Configure the data to be transferred.
    435              //
    436              if ( g_ADCSlotsConfigured > 1 )
    437              {
    438                  // Need slot number to distinguish between slot results.
    439                  ui32Config |= _VAL2FLD(ADC_DMACFG_DMAMSK, ADC_DMACFG_DMAMSK_DIS);
    440              }
    441              else
    442              {
    443                  ui32Config |= _VAL2FLD(ADC_DMACFG_DMAMSK, ADC_DMACFG_DMAMSK_EN);
    444              }
    445          
    446              //
    447              // Enable DMA Halt on Status (DMAERR or DMACPL) by default.
    448              //
    449              ui32Config |= _VAL2FLD(ADC_DMACFG_DMAHONSTAT, ADC_DMACFG_DMAHONSTAT_EN);
    450          
    451              //
    452              // Configure the DMA dynamic priority handling.
    453              //
    454              ui32Config |= _VAL2FLD(ADC_DMACFG_DMADYNPRI, pDMAConfig->bDynamicPriority);
    455          
    456              //
    457              // Configure the DMA static priority.
    458              //
    459              ui32Config |= _VAL2FLD(ADC_DMACFG_DMAPRI, pDMAConfig->ePriority);
    460          
    461              //
    462              // Enable the DMA (does not start until ADC is enabled and triggered).
    463              //
    464              ui32Config |= _VAL2FLD(ADC_DMACFG_DMAEN, ADC_DMACFG_DMAEN_EN);
    465          
    466              //
    467              // Set the DMA configuration.
    468              //
    469              ADCn(ui32Module)->DMACFG = ui32Config;
    470          
    471              //
    472              // Set the DMA transfer count.
    473              //
    474              ADCn(ui32Module)->DMATOTCOUNT_b.TOTCOUNT = pDMAConfig->ui32SampleCount;
    475          
    476              //
    477              // Set the DMA target address.
    478              //
    479              ADCn(ui32Module)->DMATARGADDR = pDMAConfig->ui32TargetAddress;
    480          
    481              //
    482              // Set the DMA trigger on FIFO 75% full.
    483              //
    484              ADCn(ui32Module)->DMATRIGEN = ADC_DMATRIGEN_DFIFO75_Msk;
    485          
    486              //
    487              // Return the status.
    488              //
    489              return AM_HAL_STATUS_SUCCESS;
    490          }
    491          
    492          //*****************************************************************************
    493          //
    494          //! @brief ADC device specific control function.
    495          //!
    496          //! @param handle   - handle for the module instance.
    497          //!
    498          //! This function provides for special control functions for the ADC operation.
    499          //!
    500          //! @return status      - generic or interface specific status.
    501          //
    502          //*****************************************************************************
    503          uint32_t am_hal_adc_control(void *pHandle,
    504                                      am_hal_adc_request_e eRequest,
    505                                      void *pConfig)
    506          {
    507              uint32_t    ui32Module = ((am_hal_adc_state_t *)pHandle)->ui32Module;
    508          
    509          #ifndef AM_HAL_DISABLE_API_VALIDATION
    510              //
    511              // Check the handle.
    512              //
    513              if ( !AM_HAL_ADC_CHK_HANDLE(pHandle) )
    514              {
    515                  return AM_HAL_STATUS_INVALID_HANDLE;
    516              }
    517          #endif
    518          
    519              switch(eRequest)
    520              {
    521                  case AM_HAL_ADC_REQ_WINDOW_CONFIG:
    522                  {
    523                      am_hal_adc_window_config_t *pWindowConfig = (am_hal_adc_window_config_t *)pConfig;
    524          
    525          #ifndef AM_HAL_DISABLE_API_VALIDATION
    526                      //
    527                      // Check the window limits.
    528                      //
    529                      if ( (pWindowConfig->ui32Upper > ADC_WULIM_ULIM_Msk)   ||
    530                           (pWindowConfig->ui32Lower > ADC_WLLIM_LLIM_Msk) )
    531                      {
    532                          return AM_HAL_STATUS_OUT_OF_RANGE;
    533                      }
    534          #endif
    535                      //
    536                      // Set the window comparison upper and lower limits.
    537                      //
    538                      ADCn(ui32Module)->WULIM = _VAL2FLD(ADC_WULIM_ULIM, pWindowConfig->ui32Upper);
    539                      ADCn(ui32Module)->WLLIM = _VAL2FLD(ADC_WLLIM_LLIM, pWindowConfig->ui32Lower);
    540          
    541                      //
    542                      // Set the window scale per precision mode if indicated.
    543                      //
    544                      ADCn(ui32Module)->SCWLIM = _VAL2FLD(ADC_SCWLIM_SCWLIMEN,
    545                                                          pWindowConfig->bScaleLimits);
    546                  }
    547                  break;
    548                  default:
    549                      return AM_HAL_STATUS_INVALID_ARG;
    550              }
    551          
    552              //
    553              // Return status.
    554              //
    555              return AM_HAL_STATUS_SUCCESS;
    556          }
    557          
    558          //*****************************************************************************
    559          //
    560          //! @brief ADC enable function
    561          //!
    562          //! @param handle   - handle for the module instance.
    563          //!
    564          //! This function enables the ADC operation.
    565          //!
    566          //! @return status      - generic or interface specific status.
    567          //
    568          //*****************************************************************************
    569          uint32_t
    570          am_hal_adc_enable(void *pHandle)
    571          {
    572              am_hal_adc_state_t  *pADCState = (am_hal_adc_state_t *)pHandle;
    573              uint32_t            ui32Module = pADCState->ui32Module;
    574          
    575          #ifndef AM_HAL_DISABLE_API_VALIDATION
    576              //
    577              // Check the handle.
    578              //
    579              if ( !AM_HAL_ADC_CHK_HANDLE(pHandle) )
    580              {
    581                  return AM_HAL_STATUS_INVALID_HANDLE;
    582              }
    583          
    584              if ( pADCState->prefix.s.bEnable )
    585              {
    586                  return AM_HAL_STATUS_SUCCESS;
    587              }
    588          #endif
    589          
    590              //
    591              // Enable the ADC.
    592              //
    593              ADCn(ui32Module)->CFG_b.ADCEN = 0x1;
    594          
    595              //
    596              // Set flag to indicate module is enabled.
    597              //
    598              pADCState->prefix.s.bEnable = true;
    599          
    600              //
    601              // Return the status.
    602              //
    603              return AM_HAL_STATUS_SUCCESS;
    604          }
    605          
    606          //*****************************************************************************
    607          //
    608          //! @brief ADC disable function
    609          //!
    610          //! @param handle   - handle for the module instance.
    611          //!
    612          //! This function disables the ADC operation.
    613          //!
    614          //! @return status      - generic or interface specific status.
    615          //
    616          //*****************************************************************************
    617          uint32_t
    618          am_hal_adc_disable(void *pHandle)
    619          {
    620              am_hal_adc_state_t  *pADCState = (am_hal_adc_state_t *)pHandle;
    621              uint32_t            ui32Module = pADCState->ui32Module;
    622          
    623          #ifndef AM_HAL_DISABLE_API_VALIDATION
    624              //
    625              // Check the handle.
    626              //
    627              if ( !AM_HAL_ADC_CHK_HANDLE(pHandle) )
    628              {
    629                  return AM_HAL_STATUS_INVALID_HANDLE;
    630              }
    631          #endif
    632          
    633              //
    634              // Disable the ADC.
    635              //
    636              ADCn(ui32Module)->CFG_b.ADCEN = 0x0;
    637          
    638              //
    639              // Set flag to indicate module is disabled.
    640              //
    641              pADCState->prefix.s.bEnable = false;
    642          
    643              //
    644              // Return the status.
    645              //
    646              return AM_HAL_STATUS_SUCCESS;
    647          }
    648          
    649          //*****************************************************************************
    650          //
    651          //! @brief ADC status function
    652          //!
    653          //! @param handle       - handle for the interface.
    654          //!
    655          //! This function returns the current status of the DMA operation.
    656          //!
    657          //! @return status      - DMA status flags.
    658          //
    659          //*****************************************************************************
    660          uint32_t
    661          am_hal_adc_status_get(void *pHandle, am_hal_adc_status_t *pStatus )
    662          {
    663              uint32_t    ui32Module = ((am_hal_adc_state_t *)pHandle)->ui32Module;
    664          
    665          #ifndef AM_HAL_DISABLE_API_VALIDATION
    666              //
    667              // Check the handle.
    668              //
    669              if ( !AM_HAL_ADC_CHK_HANDLE(pHandle) )
    670              {
    671                  return AM_HAL_STATUS_INVALID_HANDLE;
    672              }
    673          #endif
    674          
    675              //
    676              // Get the power status.
    677              //
    678              pStatus->bPoweredOn = (ADCn(ui32Module)->STAT & ADC_STAT_PWDSTAT_Msk) ==
    679                                    _VAL2FLD(ADC_STAT_PWDSTAT, ADC_STAT_PWDSTAT_ON);
    680          
    681              //
    682              // Get the low power mode 1 status.
    683              //
    684              pStatus->bLPMode1 = (ADCn(ui32Module)->STAT & ADC_STAT_PWDSTAT_Msk) ==
    685                                  _VAL2FLD(ADC_STAT_PWDSTAT, ADC_STAT_PWDSTAT_POWERED_DOWN);
    686          
    687              //
    688              //  Get the DMA status.
    689              //
    690              pStatus->bErr = ((ADCn(ui32Module)->DMASTAT & ADC_DMASTAT_DMAERR_Msk) > 0);
    691              pStatus->bCmp = ((ADCn(ui32Module)->DMASTAT & ADC_DMASTAT_DMACPL_Msk) > 0);
    692              pStatus->bTIP = ((ADCn(ui32Module)->DMASTAT & ADC_DMASTAT_DMATIP_Msk) > 0);
    693          
    694              //
    695              // Return the status.
    696              //
    697              return AM_HAL_STATUS_SUCCESS;
    698          }
    699          
    700          //*****************************************************************************
    701          //
    702          //! @brief ADC enable interrupts function
    703          //!
    704          //! @param handle       - handle for the interface.
    705          //! @param ui32IntMask  - ADC interrupt mask.
    706          //!
    707          //! This function enables the specific indicated interrupts.
    708          //!
    709          //! @return status      - generic or interface specific status.
    710          //
    711          //*****************************************************************************
    712          uint32_t
    713          am_hal_adc_interrupt_enable(void *pHandle, uint32_t ui32IntMask)
    714          {
    715              uint32_t    ui32Module = ((am_hal_adc_state_t*)pHandle)->ui32Module;
    716          
    717          #ifndef AM_HAL_DISABLE_API_VALIDATION
    718              //
    719              // Check the handle.
    720              //
    721              if ( !AM_HAL_ADC_CHK_HANDLE(pHandle) )
    722              {
    723                  return AM_HAL_STATUS_INVALID_HANDLE;
    724              }
    725          #endif
    726          
    727              //
    728              // Enable the interrupts.
    729              //
    730              ADCn(ui32Module)->INTEN |= ui32IntMask;
    731          
    732              //
    733              // Return the status.
    734              //
    735              return AM_HAL_STATUS_SUCCESS;
    736          }
    737          
    738          //*****************************************************************************
    739          //
    740          //! @brief ADC disable interrupts function
    741          //!
    742          //! @param handle       - handle for the interface.
    743          //! @param ui32IntMask  - ADC interrupt mask.
    744          //!
    745          //! This function disable the specific indicated interrupts.
    746          //!
    747          //! @return status      - generic or interface specific status.
    748          //
    749          //*****************************************************************************
    750          uint32_t
    751          am_hal_adc_interrupt_disable(void *pHandle, uint32_t ui32IntMask)
    752          {
    753              uint32_t    ui32Module = ((am_hal_adc_state_t*)pHandle)->ui32Module;
    754          
    755          #ifndef AM_HAL_DISABLE_API_VALIDATION
    756              //
    757              // Check the handle.
    758              //
    759              if ( !AM_HAL_ADC_CHK_HANDLE(pHandle) )
    760              {
    761                  return AM_HAL_STATUS_INVALID_HANDLE;
    762              }
    763          #endif
    764          
    765              //
    766              // Disable the interrupts.
    767              //
    768              ADCn(ui32Module)->INTEN &= ~ui32IntMask;
    769          
    770              //
    771              // Return the status.
    772              //
    773              return AM_HAL_STATUS_SUCCESS;
    774          }
    775          
    776          //*****************************************************************************
    777          //
    778          //! @brief ADC interrupt status function
    779          //!
    780          //! @param handle       - handle for the interface.
    781          //!
    782          //! This function returns the specific indicated interrupt status.
    783          //!
    784          //! @return status      - generic or interface specific status.
    785          //
    786          //*****************************************************************************
    787          uint32_t
    788          am_hal_adc_interrupt_status(void *pHandle,
    789                                      uint32_t  *pui32Status,
    790                                      bool bEnabledOnly)
    791          {
    792              uint32_t    ui32Module = ((am_hal_adc_state_t*)pHandle)->ui32Module;
    793          
    794          #ifndef AM_HAL_DISABLE_API_VALIDATION
    795              //
    796              // Check the handle.
    797              //
    798              if ( !AM_HAL_ADC_CHK_HANDLE(pHandle) )
    799              {
    800                  return AM_HAL_STATUS_INVALID_HANDLE;
    801              }
    802          #endif
    803          
    804              //
    805              // if requested, only return the interrupts that are enabled.
    806              //
    807              if ( bEnabledOnly )
    808              {
    809                  uint32_t ui32RetVal = ADCn(ui32Module)->INTSTAT;
    810                  *pui32Status = ADCn(ui32Module)->INTEN & ui32RetVal;
    811              }
    812              else
    813              {
    814                  *pui32Status = ADCn(ui32Module)->INTSTAT;
    815              }
    816          
    817              //
    818              // Return the status.
    819              //
    820              return AM_HAL_STATUS_SUCCESS;
    821          }
    822          
    823          
    824          //*****************************************************************************
    825          //
    826          //! @brief ADC interrupt clear
    827          //!
    828          //! @param handle         - handle for the interface.
    829          //! @param ui32IntMask    - uint32_t for interrupts to clear
    830          //!
    831          //! This function clears the interrupts for the given peripheral.
    832          //!
    833          //! @return status      - generic or interface specific status.
    834          //
    835          //*****************************************************************************
    836          uint32_t
    837          am_hal_adc_interrupt_clear(void *pHandle, uint32_t ui32IntMask)
    838          {
    839              uint32_t    ui32Module = ((am_hal_adc_state_t*)pHandle)->ui32Module;
    840          
    841          #ifndef AM_HAL_DISABLE_API_VALIDATION
    842              //
    843              // Check the handle.
    844              //
    845              if ( !AM_HAL_ADC_CHK_HANDLE(pHandle) )
    846              {
    847                  return AM_HAL_STATUS_INVALID_HANDLE;
    848              }
    849          #endif
    850          
    851              //
    852              // Clear the interrupts.
    853              //
    854              ADCn(ui32Module)->INTCLR = ui32IntMask;
    855          
    856              //
    857              // Return the status.
    858              //
    859              return AM_HAL_STATUS_SUCCESS;
    860          }
    861          
    862          //*****************************************************************************
    863          //
    864          //! @brief ADC sample read function
    865          //!
    866          //! @param pHandle              - handle for the module instance.
    867          //! @param ui32SlotNumber       - desired slot number to filter samples on.
    868          //!                               If set to AM_HAL_ADC_MAX_SLOTS then all
    869          //!                               values will be provided.
    870          //! @param ui32BufferSize       - number of entries in the sample buffer.
    871          //!                               If 0 then samples will be read directly
    872          //!                               from the FIFO.
    873          //! @param pui32SampleBuffer    - pointer to the input sample buffer.
    874          //! @param pui32NumberSamples   - returns the number of samples found.
    875          //! @param pui32Samples         - pointer to a sample buffer to process.
    876          //!                               If NULL then samples will be read directly
    877          //!                               from the FIFO.
    878          //!
    879          //!
    880          //! This function reads samples from the ADC FIFO or an SRAM sample buffer
    881          //! returned by a DMA operation.
    882          //!
    883          //! @return status      - generic or interface specific status.
    884          //
    885          //*****************************************************************************
    886          uint32_t am_hal_adc_samples_read(void *pHandle,
    887                                           uint32_t *pui32InSampleBuffer,
    888                                           uint32_t *pui32InOutNumberSamples,
    889                                           am_hal_adc_sample_t *pui32OutBuffer)
    890          
    891          {
    892              uint32_t      ui32Sample;
    893              uint32_t      ui32RequestedSamples = *pui32InOutNumberSamples;
    894          
    895              uint32_t ui32Module = ((am_hal_adc_state_t*)pHandle)->ui32Module;
    896          
    897          #ifndef AM_HAL_DISABLE_API_VALIDATION
    898              //
    899              // Check the handle.
    900              //
    901              if ( !AM_HAL_ADC_CHK_HANDLE(pHandle) )
    902              {
    903                  return AM_HAL_STATUS_INVALID_HANDLE;
    904              }
    905          
    906              //
    907              // Check the output sample buffer pointer.
    908              //
    909              if ( NULL == pui32OutBuffer )
    910              {
    911                  return AM_HAL_STATUS_INVALID_ARG;
    912              }
    913          #endif
    914          
    915          
    916              *pui32InOutNumberSamples = 0;
    917          
    918              //
    919              // Check if we are reading directly from FIFO or DMA SRAM buffer.
    920              //
    921              if ( NULL == pui32InSampleBuffer )
    922              {
    923                  //
    924                  // Grab a value from the ADC FIFO
    925                  //
    926                  do
    927                  {
    928                      ui32Sample = ADCn(ui32Module)->FIFOPR;
    929                      pui32OutBuffer->ui32Slot   = AM_HAL_ADC_FIFO_SLOT(ui32Sample);
    930                      pui32OutBuffer->ui32Sample = AM_HAL_ADC_FIFO_SAMPLE(ui32Sample);
    931                      pui32OutBuffer++;
    932                      (*pui32InOutNumberSamples)++;
    933                  } while ((AM_HAL_ADC_FIFO_COUNT(ui32Sample) > 0) &&
    934                           (*pui32InOutNumberSamples < ui32RequestedSamples));
    935              }
    936              else
    937              {
    938                  //
    939                  // Process the samples from the provided sample buffer
    940                  //
    941                  do
    942                  {
    943                      ui32Sample = ADCn(ui32Module)->FIFOPR;
    944                      pui32OutBuffer->ui32Slot   = AM_HAL_ADC_FIFO_SLOT(*pui32InSampleBuffer);
    945                      pui32OutBuffer->ui32Sample = AM_HAL_ADC_FIFO_SAMPLE(*pui32InSampleBuffer);
    946                      pui32InSampleBuffer++;
    947                      pui32OutBuffer++;
    948                      (*pui32InOutNumberSamples)++;
    949                  } while (*pui32InOutNumberSamples < ui32RequestedSamples);
    950              }
    951          
    952              //
    953              // Return FIFO valid bits.
    954              //
    955              return AM_HAL_STATUS_SUCCESS;
    956          }
    957          
    958          //*****************************************************************************
    959          //
    960          //! @brief Issue Software Trigger to the ADC.
    961          //!
    962          //! @param handle   - handle for the module instance.
    963          //!
    964          //! This function triggers the ADC operation.
    965          //!
    966          //! @return status      - generic or interface specific status.
    967          //
    968          //*****************************************************************************
    969          uint32_t
    970          am_hal_adc_sw_trigger(void *pHandle)
    971          {
    972              uint32_t    ui32Module = ((am_hal_adc_state_t*)pHandle)->ui32Module;
    973          
    974          #ifndef AM_HAL_DISABLE_API_VALIDATION
    975              //
    976              // Check the handle.
    977              //
    978              if ( !AM_HAL_ADC_CHK_HANDLE(pHandle) )
    979              {
    980                  return AM_HAL_STATUS_INVALID_HANDLE;
    981              }
    982          #endif
    983          
    984              //
    985              // Write to the Software trigger register in the ADC.
    986              //
    987              ADCn(ui32Module)->SWT = 0x37;
    988          
    989              //
    990              // Return the status.
    991              //
    992              return AM_HAL_STATUS_SUCCESS;
    993          }
    994          
    995          //*****************************************************************************
    996          //
    997          //! @brief ADC power control function
    998          //!
    999          //! @param handle       - handle for the interface.
   1000          //! @param ePowerState  - the desired power state to move the peripheral to.
   1001          //! @param bRetainState - flag (if true) to save/restore peripheral state upon
   1002          //!                       power state change.
   1003          //!
   1004          //! This function updates the peripheral to a given power state.
   1005          //!
   1006          //! @return status      - generic or interface specific status.
   1007          //
   1008          //*****************************************************************************
   1009          uint32_t
   1010          am_hal_adc_power_control(void *pHandle,
   1011                                   am_hal_sysctrl_power_state_e ePowerState,
   1012                                   bool bRetainState)
   1013          {
   1014              am_hal_adc_state_t  *pADCState = (am_hal_adc_state_t *)pHandle;
   1015              uint32_t            ui32Module = pADCState->ui32Module;
   1016          
   1017          #ifndef AM_HAL_DISABLE_API_VALIDATION
   1018              //
   1019              // Check the handle.
   1020              //
   1021              if ( !AM_HAL_ADC_CHK_HANDLE(pHandle) )
   1022              {
   1023                  return AM_HAL_STATUS_INVALID_HANDLE;
   1024              }
   1025          #endif
   1026          
   1027              //
   1028              // Decode the requested power state and update MSPI operation accordingly.
   1029              //
   1030              switch (ePowerState)
   1031              {
   1032                  case AM_HAL_SYSCTRL_WAKE:
   1033                      if ( bRetainState  &&  !pADCState->registerState.bValid )
   1034                      {
   1035                          return AM_HAL_STATUS_INVALID_OPERATION;
   1036                      }
   1037          
   1038                      //
   1039                      // Enable the ADC power domain.
   1040                      //
   1041                      am_hal_pwrctrl_periph_enable(AM_HAL_PWRCTRL_PERIPH_ADC);
   1042          
   1043                      if ( bRetainState )
   1044                      {
   1045                          ADCn(ui32Module)->SL0CFG = pADCState->registerState.regSL0CFG;
   1046                          ADCn(ui32Module)->SL1CFG = pADCState->registerState.regSL1CFG;
   1047                          ADCn(ui32Module)->SL2CFG = pADCState->registerState.regSL2CFG;
   1048                          ADCn(ui32Module)->SL3CFG = pADCState->registerState.regSL3CFG;
   1049                          ADCn(ui32Module)->SL4CFG = pADCState->registerState.regSL4CFG;
   1050                          ADCn(ui32Module)->SL5CFG = pADCState->registerState.regSL5CFG;
   1051                          ADCn(ui32Module)->SL6CFG = pADCState->registerState.regSL6CFG;
   1052                          ADCn(ui32Module)->SL7CFG = pADCState->registerState.regSL7CFG;
   1053                          ADCn(ui32Module)->WULIM  = pADCState->registerState.regWULIM;
   1054                          ADCn(ui32Module)->WLLIM  = pADCState->registerState.regWLLIM;
   1055                          ADCn(ui32Module)->INTEN  = pADCState->registerState.regINTEN;
   1056                          ADCn(ui32Module)->CFG    = pADCState->registerState.regCFG;
   1057          
   1058                          pADCState->registerState.bValid     = false;
   1059                      }
   1060                      break;
   1061          
   1062                  case AM_HAL_SYSCTRL_NORMALSLEEP:
   1063                  case AM_HAL_SYSCTRL_DEEPSLEEP:
   1064                      if ( bRetainState )
   1065                      {
   1066                          pADCState->registerState.regSL0CFG  = ADCn(ui32Module)->SL0CFG;
   1067                          pADCState->registerState.regSL1CFG  = ADCn(ui32Module)->SL1CFG;
   1068                          pADCState->registerState.regSL2CFG  = ADCn(ui32Module)->SL2CFG;
   1069                          pADCState->registerState.regSL3CFG  = ADCn(ui32Module)->SL3CFG;
   1070                          pADCState->registerState.regSL4CFG  = ADCn(ui32Module)->SL4CFG;
   1071                          pADCState->registerState.regSL5CFG  = ADCn(ui32Module)->SL5CFG;
   1072                          pADCState->registerState.regSL6CFG  = ADCn(ui32Module)->SL6CFG;
   1073                          pADCState->registerState.regSL7CFG  = ADCn(ui32Module)->SL7CFG;
   1074                          pADCState->registerState.regWULIM   = ADCn(ui32Module)->WULIM;
   1075                          pADCState->registerState.regWLLIM   = ADCn(ui32Module)->WLLIM;
   1076                          pADCState->registerState.regINTEN   = ADCn(ui32Module)->INTEN;
   1077                          pADCState->registerState.regCFG     = ADCn(ui32Module)->CFG;
   1078          
   1079                          pADCState->registerState.bValid     = true;
   1080                      }
   1081          
   1082                      //
   1083                      // Disable the ADC power domain.
   1084                      //
   1085                      am_hal_pwrctrl_periph_disable(AM_HAL_PWRCTRL_PERIPH_ADC);
   1086                      break;
   1087          
   1088                  default:
   1089                      return AM_HAL_STATUS_INVALID_ARG;
   1090              }
   1091          
   1092              //
   1093              // Return the status.
   1094              //
   1095              return AM_HAL_STATUS_SUCCESS;
   1096          }
   1097          
   1098          //*****************************************************************************
   1099          //
   1100          // End Doxygen group.
   1101          //! @}
   1102          //
   1103          //*****************************************************************************

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      12   am_hal_adc_configure
      16   am_hal_adc_configure_dma
      16   am_hal_adc_configure_slot
      16   am_hal_adc_control
      16   am_hal_adc_deinitialize
        16   -> am_hal_adc_disable
       8   am_hal_adc_disable
       8   am_hal_adc_enable
       4   am_hal_adc_initialize
       4   am_hal_adc_interrupt_clear
       8   am_hal_adc_interrupt_disable
       8   am_hal_adc_interrupt_enable
      12   am_hal_adc_interrupt_status
      24   am_hal_adc_power_control
        24   -> am_hal_pwrctrl_periph_disable
        24   -> am_hal_pwrctrl_periph_enable
      16   am_hal_adc_samples_read
       8   am_hal_adc_status_get
       4   am_hal_adc_sw_trigger


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
     124  am_hal_adc_configure
     130  am_hal_adc_configure_dma
     120  am_hal_adc_configure_slot
     110  am_hal_adc_control
      60  am_hal_adc_deinitialize
      66  am_hal_adc_disable
      80  am_hal_adc_enable
     126  am_hal_adc_initialize
      44  am_hal_adc_interrupt_clear
      54  am_hal_adc_interrupt_disable
      54  am_hal_adc_interrupt_enable
      80  am_hal_adc_interrupt_status
     322  am_hal_adc_power_control
     152  am_hal_adc_samples_read
     114  am_hal_adc_status_get
      44  am_hal_adc_sw_trigger
       4  g_ADCSlotsConfigured
      64  g_ADCState

 
    68 bytes in section .bss
 1 696 bytes in section .text
 
 1 696 bytes of CODE memory
    68 bytes of DATA memory

Errors: none
Warnings: none
