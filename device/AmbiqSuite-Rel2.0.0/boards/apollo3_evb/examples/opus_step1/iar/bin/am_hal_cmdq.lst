###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         12/Mar/2019  10:07:07
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_cmdq.c
#    Command line =  
#        -f C:\temp\EW806D.tmp
#        (C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_cmdq.c
#        -D iar -D AM_PART_APOLLO3 -D AM_PACKAGE_BGA -lcN
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --diag_suppress Pa050 -o
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\utils\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\ARM\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\AmbiqMicro\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\mcu\apollo3\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\devices\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\bsp\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\sound\
#        -On)
#    Locale       =  C
#    List file    =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_cmdq.lst
#    Object file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_cmdq.o
#
###############################################################################

C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_cmdq.c
      1          //*****************************************************************************
      2          //
      3          //  am_hal_cmdq.c
      4          //! @file
      5          //!
      6          //! @brief Functions for support command queue operations.
      7          //!
      8          //! @addtogroup
      9          //! @ingroup apollo3hal
     10          //! @{
     11          //
     12          //*****************************************************************************
     13          
     14          //*****************************************************************************
     15          //
     16          // Copyright (c) 2019, Ambiq Micro
     17          // All rights reserved.
     18          // 
     19          // Redistribution and use in source and binary forms, with or without
     20          // modification, are permitted provided that the following conditions are met:
     21          // 
     22          // 1. Redistributions of source code must retain the above copyright notice,
     23          // this list of conditions and the following disclaimer.
     24          // 
     25          // 2. Redistributions in binary form must reproduce the above copyright
     26          // notice, this list of conditions and the following disclaimer in the
     27          // documentation and/or other materials provided with the distribution.
     28          // 
     29          // 3. Neither the name of the copyright holder nor the names of its
     30          // contributors may be used to endorse or promote products derived from this
     31          // software without specific prior written permission.
     32          // 
     33          // Third party software included in this distribution is subject to the
     34          // additional license terms as defined in the /docs/licenses directory.
     35          // 
     36          // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     37          // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     38          // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     39          // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     40          // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     41          // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     42          // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     43          // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     44          // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     45          // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     46          // POSSIBILITY OF SUCH DAMAGE.
     47          //
     48          // This is part of revision v2.0.0 of the AmbiqSuite Development Package.
     49          //
     50          //*****************************************************************************
     51          
     52          #include <stdint.h>
     53          #include <stdbool.h>
     54          #include "am_mcu_apollo.h"
     55          
     56          #define AM_HAL_MAGIC_CMDQ           0xCDCDCD
     57          #define AM_HAL_CMDQ_CHK_HANDLE(h)   ((h) && ((am_hal_handle_prefix_t *)(h))->s.bInit && (((am_hal_handle_prefix_t *)(h))->s.magic == AM_HAL_MAGIC_CMDQ))
     58          
     59          // Make sure certain register assumptions are valid - else throw compile error
     60          // Make sure the max HWIDX value is same for BLEIF, MSPI & IOM
     61          // Make sure the CQCFG structure is same for BLEIF, MSPI & IOM
     62          #if ((IOM0_CQCURIDX_CQCURIDX_Msk != MSPI_CQCURIDX_CQCURIDX_Msk) || \
     63               (IOM0_CQCURIDX_CQCURIDX_Pos != MSPI_CQCURIDX_CQCURIDX_Pos) || \
     64               (IOM0_CQCFG_CQEN_Pos != MSPI_CQCFG_CQEN_Pos) || \
     65               (IOM0_CQCFG_CQEN_Msk != MSPI_CQCFG_CQEN_Msk) || \
     66               (IOM0_CQCFG_CQPRI_Pos != MSPI_CQCFG_CQPRI_Pos) || \
     67               (IOM0_CQCFG_CQPRI_Msk != MSPI_CQCFG_CQPRI_Msk) || \
     68               (IOM0_CQCURIDX_CQCURIDX_Msk != BLEIF_CQCURIDX_CQCURIDX_Msk) || \
     69               (IOM0_CQCURIDX_CQCURIDX_Pos != BLEIF_CQCURIDX_CQCURIDX_Pos) || \
     70               (IOM0_CQCFG_CQEN_Pos != BLEIF_CQCFG_CQEN_Pos) || \
     71               (IOM0_CQCFG_CQEN_Msk != BLEIF_CQCFG_CQEN_Msk) || \
     72               (IOM0_CQCFG_CQPRI_Pos != BLEIF_CQCFG_CQPRI_Pos) || \
     73               (IOM0_CQCFG_CQPRI_Msk != BLEIF_CQCFG_CQPRI_Msk) \
     74               )
     75          #error "MSPI and IOM HWIDX, CQCFG implementation needs to match for current CMDQ HAL implementation"
     76          #endif
     77          
     78          #define AM_HAL_CMDQ_HW_IDX_MAX                      (IOM0_CQCURIDX_CQCURIDX_Msk >> IOM0_CQCURIDX_CQCURIDX_Pos)  // 8 bit value
     79          #define AM_HAL_CMDQ_ENABLE_CQ(cfgReg)               {AM_REGVAL((cfgReg)) |= _VAL2FLD(IOM0_CQCFG_CQEN, IOM0_CQCFG_CQEN_EN); }
     80          #define AM_HAL_CMDQ_DISABLE_CQ(cfgReg)              {AM_REGVAL((cfgReg)) &= ~_VAL2FLD(IOM0_CQCFG_CQEN, IOM0_CQCFG_CQEN_EN); }
     81          #define AM_HAL_CMDQ_INIT_CQCFG(cfgReg, pri, enable) {AM_REGVAL((cfgReg)) = _VAL2FLD(IOM0_CQCFG_CQPRI, (pri)) | _VAL2FLD(IOM0_CQCFG_CQEN, (enable)); }
     82          
     83          
     84          // Need to set the lsb of the CQ entry address for hardware to raise a CQUPD interrupt when processing this entry
     85          #define AM_HAL_CMDQ_ENABLE_CQUPD_INT                0x1
     86          
     87          typedef struct
     88          {
     89              volatile uint32_t*      regCQCfg;
     90              volatile uint32_t*      regCQAddr;
     91              volatile uint32_t*      regCurIdx;
     92              volatile uint32_t*      regEndIdx;
     93              volatile uint32_t*      regCQPause;
     94              uint32_t                bitMaskCQPauseIdx;
     95              volatile uint32_t*      regCQStat;
     96          
     97              // Different hardware blocks have different bit assignments for status flags
     98              uint32_t                bitMaskCQStatTIP;
     99              uint32_t                bitMaskCQStatErr;
    100              uint32_t                bitMaskCQStatPaused;
    101          } am_hal_cmdq_registers_t;
    102          
    103          typedef struct
    104          {
    105              am_hal_handle_prefix_t  prefix;
    106              uint32_t                cmdQBufStart;
    107              uint32_t                cmdQBufEnd;
    108              uint32_t                cmdQHead;
    109              uint32_t                cmdQTail;
    110              uint32_t                cmdQNextTail;
    111              uint32_t                cmdQSize;
    112              uint32_t                curIdx;
    113              uint32_t                endIdx;
    114              const am_hal_cmdq_registers_t *pReg;
    115              uint32_t                rawSeqStart;
    116          } am_hal_cmdq_t;
    117          
    118          // Global variables
    119          static am_hal_cmdq_t gAmHalCmdq[AM_HAL_CMDQ_IF_MAX];
    120          
    121          static const am_hal_cmdq_registers_t gAmHalCmdQReg[AM_HAL_CMDQ_IF_MAX] =
    122          {
    123              // AM_HAL_CMDQ_IF_IOM0
    124              {
    125                  &IOM0->CQCFG,           &IOM0->CQADDR,
    126                  &IOM0->CQCURIDX,        &IOM0->CQENDIDX,
    127                  &IOM0->CQPAUSEEN,       IOM0_CQPAUSEEN_CQPEN_IDXEQ,
    128                  &IOM0->CQSTAT,          IOM0_CQSTAT_CQTIP_Msk,
    129                  IOM0_CQSTAT_CQERR_Msk,  IOM0_CQSTAT_CQPAUSED_Msk
    130              },
    131              // AM_HAL_CMDQ_IF_IOM1
    132              {
    133                  &IOM1->CQCFG,           &IOM1->CQADDR,
    134                  &IOM1->CQCURIDX,        &IOM1->CQENDIDX,
    135                  &IOM1->CQPAUSEEN,       IOM0_CQPAUSEEN_CQPEN_IDXEQ,
    136                  &IOM1->CQSTAT,          IOM0_CQSTAT_CQTIP_Msk,
    137                  IOM0_CQSTAT_CQERR_Msk,  IOM0_CQSTAT_CQPAUSED_Msk
    138              },
    139              // AM_HAL_CMDQ_IF_IOM2
    140              {
    141                  &IOM2->CQCFG,           &IOM2->CQADDR,
    142                  &IOM2->CQCURIDX,        &IOM2->CQENDIDX,
    143                  &IOM2->CQPAUSEEN,       IOM0_CQPAUSEEN_CQPEN_IDXEQ,
    144                  &IOM2->CQSTAT,          IOM0_CQSTAT_CQTIP_Msk,
    145                  IOM0_CQSTAT_CQERR_Msk,  IOM0_CQSTAT_CQPAUSED_Msk
    146              },
    147              // AM_HAL_CMDQ_IF_IOM3
    148              {
    149                  &IOM3->CQCFG,           &IOM3->CQADDR,
    150                  &IOM3->CQCURIDX,        &IOM3->CQENDIDX,
    151                  &IOM3->CQPAUSEEN,       IOM0_CQPAUSEEN_CQPEN_IDXEQ,
    152                  &IOM3->CQSTAT,          IOM0_CQSTAT_CQTIP_Msk,
    153                  IOM0_CQSTAT_CQERR_Msk,  IOM0_CQSTAT_CQPAUSED_Msk
    154                  },
    155              // AM_HAL_CMDQ_IF_IOM4
    156              {
    157                  &IOM4->CQCFG,           &IOM4->CQADDR,
    158                  &IOM4->CQCURIDX,        &IOM4->CQENDIDX,
    159                  &IOM4->CQPAUSEEN,       IOM0_CQPAUSEEN_CQPEN_IDXEQ,
    160                  &IOM4->CQSTAT,          IOM0_CQSTAT_CQTIP_Msk,
    161                  IOM0_CQSTAT_CQERR_Msk,  IOM0_CQSTAT_CQPAUSED_Msk
    162              },
    163              // AM_HAL_CMDQ_IF_IOM5
    164              {
    165                  &IOM5->CQCFG,           &IOM5->CQADDR,
    166                  &IOM5->CQCURIDX,        &IOM5->CQENDIDX,
    167                  &IOM5->CQPAUSEEN,       IOM0_CQPAUSEEN_CQPEN_IDXEQ,
    168                  &IOM5->CQSTAT,          IOM0_CQSTAT_CQTIP_Msk,
    169                  IOM0_CQSTAT_CQERR_Msk,  IOM0_CQSTAT_CQPAUSED_Msk
    170              },
    171              // AM_HAL_CMDQ_IF_MSPI
    172              {
    173                  &MSPI->CQCFG,           &MSPI->CQADDR,
    174                  &MSPI->CQCURIDX,        &MSPI->CQENDIDX,
    175                  &MSPI->CQPAUSE,         MSPI_CQPAUSE_CQMASK_CQIDX,
    176                  &MSPI->CQSTAT,          MSPI_CQSTAT_CQTIP_Msk,
    177                  MSPI_CQSTAT_CQERR_Msk,  MSPI_CQSTAT_CQPAUSED_Msk
    178              },
    179              // AM_HAL_CMDQ_IF_BLEIF
    180              {
    181                  &BLEIF->CQCFG,          &BLEIF->CQADDR,
    182                  &BLEIF->CQCURIDX,       &BLEIF->CQENDIDX,
    183                  &BLEIF->CQPAUSEEN,      BLEIF_CQPAUSEEN_CQPEN_CNTEQ,
    184                  &BLEIF->CQSTAT,         BLEIF_CQSTAT_CQTIP_Msk,
    185                  BLEIF_CQSTAT_CQERR_Msk, BLEIF_CQSTAT_CQPAUSED_Msk
    186              },
    187          };
    188          
    189          // Sync up with the current hardware indices and pointers
    190          static void
    191          update_indices(am_hal_cmdq_t *pCmdQ)
    192          {
    193              int32_t hwCurIdx;
    194          
    195              //
    196              // Start a critical section.
    197              //
    198              AM_CRITICAL_BEGIN
    199          
    200              hwCurIdx = AM_REGVAL(pCmdQ->pReg->regCurIdx) & AM_HAL_CMDQ_HW_IDX_MAX;
    201          
    202              // Derive the 32b values from the current hardware index values
    203              // It is guaranteed that pCmdQ->endIdx is <= pCmdQ->curIdx + AM_HAL_CMDQ_HW_IDX_MAX - 1
    204              pCmdQ->curIdx = (pCmdQ->endIdx & ~AM_HAL_CMDQ_HW_IDX_MAX) | hwCurIdx;
    205              if (AM_HAL_U32_SMALLER(pCmdQ->endIdx, pCmdQ->curIdx))
    206              {
    207                  pCmdQ->curIdx -= (AM_HAL_CMDQ_HW_IDX_MAX + 1);
    208              }
    209              pCmdQ->cmdQHead = AM_REGVAL(pCmdQ->pReg->regCQAddr);
    210          
    211              //
    212              // End the critical section.
    213              //
    214              AM_CRITICAL_END
    215          }
    216          
    217          //*****************************************************************************
    218          //
    219          //! @brief  Initialize a Command Queue
    220          //!
    221          //! Initializes the command queue data structure for the given interface
    222          //!
    223          //! @param  hwIf identifies the underlying hardware interface
    224          //! @param  cmdQSize Size of supplied memory in multiple of 8 Bytes
    225          //! @param  pCmdQBuf Command Queue Buffer
    226          //! @param  ppHandle Return Parameter - handle for the command queue
    227          //!
    228          //! @return Returns 0 on success
    229          //
    230          //*****************************************************************************
    231          uint32_t am_hal_cmdq_init(am_hal_cmdq_if_e hwIf, am_hal_cmdq_cfg_t *pCfg, void **ppHandle)
    232          {
    233              am_hal_cmdq_t *pCmdQ;
    234          #ifndef AM_HAL_DISABLE_API_VALIDATION
    235              if (hwIf >= AM_HAL_CMDQ_IF_MAX)
    236              {
    237                  return AM_HAL_STATUS_OUT_OF_RANGE;
    238              }
    239              if (!pCfg || !pCfg->pCmdQBuf || !ppHandle || (pCfg->cmdQSize < 2))
    240              {
    241                  return AM_HAL_STATUS_INVALID_ARG;
    242              }
    243              if (gAmHalCmdq[hwIf].prefix.s.bInit)
    244              {
    245                  return AM_HAL_STATUS_INVALID_OPERATION;
    246              }
    247          #endif
    248              pCmdQ = &gAmHalCmdq[hwIf];
    249              pCmdQ->cmdQSize = pCfg->cmdQSize * sizeof(am_hal_cmdq_entry_t);
    250              pCmdQ->cmdQTail = pCmdQ->cmdQNextTail = pCmdQ->cmdQHead = pCmdQ->cmdQBufStart = (uint32_t)pCfg->pCmdQBuf;
    251              pCmdQ->cmdQBufEnd = (uint32_t)pCfg->pCmdQBuf + pCfg->cmdQSize * sizeof(am_hal_cmdq_entry_t);
    252              pCmdQ->prefix.s.bInit = true;
    253              pCmdQ->prefix.s.bEnable = false;
    254              pCmdQ->prefix.s.magic = AM_HAL_MAGIC_CMDQ;
    255              pCmdQ->pReg = &gAmHalCmdQReg[hwIf];
    256              pCmdQ->curIdx = 0;
    257              pCmdQ->endIdx = 0;
    258              AM_REGVAL(pCmdQ->pReg->regCurIdx) = 0;
    259              AM_REGVAL(pCmdQ->pReg->regEndIdx) = 0;
    260              AM_REGVAL(pCmdQ->pReg->regCQPause) |= pCmdQ->pReg->bitMaskCQPauseIdx;
    261              // Initialize the hardware registers
    262              AM_REGVAL(pCmdQ->pReg->regCQAddr) = (uint32_t)pCfg->pCmdQBuf;
    263              AM_HAL_CMDQ_INIT_CQCFG(pCmdQ->pReg->regCQCfg, pCfg->priority, false);
    264              *ppHandle = pCmdQ;
    265              return AM_HAL_STATUS_SUCCESS;
    266          }
    267          
    268          //*****************************************************************************
    269          //
    270          //! @brief  Enable a Command Queue
    271          //!
    272          //! Enables the command queue for the given interface
    273          //!
    274          //! @param  pHandle handle for the command queue
    275          //!
    276          //! @return Returns 0 on success
    277          //
    278          //*****************************************************************************
    279          uint32_t am_hal_cmdq_enable(void *pHandle)
    280          {
    281              am_hal_cmdq_t *pCmdQ = (am_hal_cmdq_t *)pHandle;
    282          #ifndef AM_HAL_DISABLE_API_VALIDATION
    283              if (!AM_HAL_CMDQ_CHK_HANDLE(pHandle))
    284              {
    285                  return AM_HAL_STATUS_INVALID_HANDLE;
    286              }
    287          
    288              if (pCmdQ->prefix.s.bEnable)
    289              {
    290                  return AM_HAL_STATUS_SUCCESS;
    291              }
    292          #endif
    293              AM_HAL_CMDQ_ENABLE_CQ(pCmdQ->pReg->regCQCfg);
    294              pCmdQ->prefix.s.bEnable = true;
    295              return AM_HAL_STATUS_SUCCESS;
    296          }
    297          
    298          //*****************************************************************************
    299          //
    300          //! @brief  Disable a Command Queue
    301          //!
    302          //! Disables the command queue for the given interface
    303          //!
    304          //! @param  pHandle handle for the command queue
    305          //!
    306          //! @return Returns 0 on success
    307          //
    308          //*****************************************************************************
    309          uint32_t am_hal_cmdq_disable(void *pHandle)
    310          {
    311              am_hal_cmdq_t *pCmdQ = (am_hal_cmdq_t *)pHandle;
    312          #ifndef AM_HAL_DISABLE_API_VALIDATION
    313              if (!AM_HAL_CMDQ_CHK_HANDLE(pHandle))
    314              {
    315                  return AM_HAL_STATUS_INVALID_HANDLE;
    316              }
    317          #endif
    318          
    319              if (!pCmdQ->prefix.s.bEnable)
    320              {
    321                  return AM_HAL_STATUS_SUCCESS;
    322              }
    323              AM_HAL_CMDQ_DISABLE_CQ(pCmdQ->pReg->regCQCfg);
    324              pCmdQ->prefix.s.bEnable = false;
    325              return AM_HAL_STATUS_SUCCESS;
    326          }
    327          
    328          //*****************************************************************************
    329          //
    330          //! @brief  Allocate a block of commands for posting to a command queue
    331          //!
    332          //! Allocates a contiguous block of command queue entries from the available
    333          //! space in command queue
    334          //!
    335          //! @param  pHandle handle for the command queue
    336          //! @param  numCmd Size of the command block (each block being 8 bytes)
    337          //! @param  ppBlock - Return parameter - Pointer to contiguous block of commands,
    338          //! which can be posted
    339          //! @param  pIdx - Return parameter - monotonically increasing transaction index
    340          //!
    341          //! This function will take care of determining that enough space is available
    342          //! to create the desired block. It also takes care of necessary wrap-around
    343          //!
    344          //! @return Returns 0 on success
    345          //
    346          //*****************************************************************************
    347          uint32_t am_hal_cmdq_alloc_block(void *pHandle, uint32_t numCmd, am_hal_cmdq_entry_t **ppBlock, uint32_t *pIdx)
    348          {
    349              am_hal_cmdq_t *pCmdQ = (am_hal_cmdq_t *)pHandle;
    350              am_hal_cmdq_entry_t *pCmdQEntry;
    351              uint32_t blockAddr;
    352          #ifndef AM_HAL_DISABLE_API_VALIDATION
    353              if (!AM_HAL_CMDQ_CHK_HANDLE(pHandle))
    354              {
    355                  return AM_HAL_STATUS_INVALID_HANDLE;
    356              }
    357              if (!ppBlock || !pIdx)
    358              {
    359                  return AM_HAL_STATUS_INVALID_ARG;
    360              }
    361              if (pCmdQ->cmdQTail != pCmdQ->cmdQNextTail)
    362              {
    363                  // Previously allocated block has not been posted/aborted yet
    364                  return AM_HAL_STATUS_INVALID_OPERATION;
    365              }
    366          #endif
    367              update_indices(pCmdQ);
    368              // We need to not use the hwIdx completely, as otherwise we can not distinguish between
    369              // Empty and full case
    370              if (AM_HAL_U32_SMALLER((pCmdQ->curIdx + AM_HAL_CMDQ_HW_IDX_MAX - 1), (pCmdQ->endIdx)))
    371              {
    372                  return AM_HAL_STATUS_OUT_OF_RANGE;
    373              }
    374              // Determine if we can allocate the block, and if so, where
    375              if (pCmdQ->cmdQTail >= pCmdQ->cmdQHead)
    376              {
    377                  // Choices: Following last block if there is enough space before wrap
    378                  // Otherwise, need to allocate block from the top of the memory
    379                  // For a sequence - we'll always come to this case, as the sequence is not started before building
    380          
    381                  // Need space for 2 more entries - one for updating curIdx, other for CQ Wrap
    382                  if ((pCmdQ->cmdQTail + (numCmd + 2)*sizeof(am_hal_cmdq_entry_t)) <= pCmdQ->cmdQBufEnd)
    383                  {
    384                      // Enough space in the queue without wrap
    385                      blockAddr = pCmdQ->cmdQTail;
    386                  }
    387                  else
    388                  {
    389                      // Need to wrap
    390                      // Need space for 1 more entry - for updating curIdx
    391                      if ((pCmdQ->cmdQBufStart + (numCmd + 1) * sizeof(am_hal_cmdq_entry_t)) < pCmdQ->cmdQHead)
    392                      {
    393                          // Initialize the tail of CmdQ for Wrap
    394                          pCmdQEntry = (am_hal_cmdq_entry_t *)pCmdQ->cmdQTail;
    395                          pCmdQEntry->address = (uint32_t)pCmdQ->pReg->regCQAddr;
    396                          pCmdQEntry->value = pCmdQ->cmdQBufStart;
    397                          blockAddr = pCmdQ->cmdQBufStart;
    398                      }
    399                      else
    400                      {
    401                          return AM_HAL_STATUS_OUT_OF_RANGE;
    402                      }
    403                  }
    404              }
    405              else
    406              {
    407                  // Need space for 1 more entry - for updating curIdx
    408                  if ((pCmdQ->cmdQTail + (numCmd + 1) * sizeof(am_hal_cmdq_entry_t)) < pCmdQ->cmdQHead)
    409                  {
    410                      blockAddr = pCmdQ->cmdQTail;
    411                  }
    412                  else
    413                  {
    414                      return AM_HAL_STATUS_OUT_OF_RANGE;
    415                  }
    416              }
    417              *ppBlock = (am_hal_cmdq_entry_t *)blockAddr;
    418              *pIdx = ++pCmdQ->endIdx;
    419              pCmdQ->cmdQNextTail = blockAddr + numCmd * sizeof(am_hal_cmdq_entry_t);
    420              return AM_HAL_STATUS_SUCCESS;
    421          }
    422          
    423          //*****************************************************************************
    424          //
    425          //! @brief  Release a block of commands previously allocated
    426          //!
    427          //! Releases the  contiguous block of command queue entries previously allocated
    428          //! without posting
    429          //!
    430          //! @param  pHandle handle for the command queue
    431          //!
    432          //! This function will internally handles the curIdx/endIdx manipulation.
    433          //! It also takes care of necessary wrap-around
    434          //!
    435          //! @return Returns 0 on success
    436          //
    437          //*****************************************************************************
    438          uint32_t am_hal_cmdq_release_block(void *pHandle)
    439          {
    440              am_hal_cmdq_t *pCmdQ = (am_hal_cmdq_t *)pHandle;
    441          #ifndef AM_HAL_DISABLE_API_VALIDATION
    442              if (!AM_HAL_CMDQ_CHK_HANDLE(pHandle))
    443              {
    444                  return AM_HAL_STATUS_INVALID_HANDLE;
    445              }
    446              if (pCmdQ->cmdQTail == pCmdQ->cmdQNextTail)
    447              {
    448                  // No block has been allocated
    449                  return AM_HAL_STATUS_INVALID_OPERATION;
    450              }
    451          #endif
    452              // Free up the block
    453              pCmdQ->cmdQNextTail = pCmdQ->cmdQTail;
    454              pCmdQ->endIdx--;
    455          
    456              return AM_HAL_STATUS_SUCCESS;
    457          }
    458          
    459          //*****************************************************************************
    460          //
    461          //! @brief  Post the last block allocated
    462          //!
    463          //! Post the  contiguous block of command queue entries previously allocated
    464          //!
    465          //! @param  pHandle handle for the command queue
    466          //! @param  bInt Whether the UPD interrupt is desired once the block is processed
    467          //!
    468          //! @return Returns 0 on success
    469          //
    470          //*****************************************************************************
    471          uint32_t am_hal_cmdq_post_block(void *pHandle, bool bInt)
    472          {
    473              am_hal_cmdq_t *pCmdQ = (am_hal_cmdq_t *)pHandle;
    474              am_hal_cmdq_entry_t *pCmdQEntry;
    475          #ifndef AM_HAL_DISABLE_API_VALIDATION
    476              if (!AM_HAL_CMDQ_CHK_HANDLE(pHandle))
    477              {
    478                  return AM_HAL_STATUS_INVALID_HANDLE;
    479              }
    480              if (pCmdQ->cmdQTail == pCmdQ->cmdQNextTail)
    481              {
    482                  // No block has been allocated
    483                  return AM_HAL_STATUS_INVALID_OPERATION;
    484              }
    485          #endif
    486              // CmdQ entries have already been populated. Just need to inform hardware of the new endIdx
    487              // Fill up the index update entry
    488              pCmdQEntry = (am_hal_cmdq_entry_t *)pCmdQ->cmdQNextTail;
    489              pCmdQEntry->address = ((uint32_t)pCmdQ->pReg->regCurIdx) | (bInt ? AM_HAL_CMDQ_ENABLE_CQUPD_INT : 0);
    490              pCmdQEntry->value = pCmdQ->endIdx;
    491              // cmdQNextTail should now point to the first entry after the allocated block
    492              pCmdQ->cmdQTail = pCmdQ->cmdQNextTail = (uint32_t)(pCmdQEntry + 1);
    493              AM_REGVAL(pCmdQ->pReg->regEndIdx) = pCmdQ->endIdx & AM_HAL_CMDQ_HW_IDX_MAX;
    494              return AM_HAL_STATUS_SUCCESS;
    495          }
    496          
    497          //*****************************************************************************
    498          //
    499          //! @brief  Get Command Queue status
    500          //!
    501          //! Get the current state of the Command queue
    502          //!
    503          //! @param  pHandle handle for the command queue
    504          //! @param  pStatus Return Parameter - status information
    505          //!
    506          //! @return Returns 0 on success
    507          //
    508          //*****************************************************************************
    509          uint32_t am_hal_cmdq_get_status(void *pHandle, am_hal_cmdq_status_t *pStatus)
    510          {
    511              am_hal_cmdq_t *pCmdQ = (am_hal_cmdq_t *)pHandle;
    512              uint32_t status;
    513          #ifndef AM_HAL_DISABLE_API_VALIDATION
    514              if (!AM_HAL_CMDQ_CHK_HANDLE(pHandle))
    515              {
    516                  return AM_HAL_STATUS_INVALID_HANDLE;
    517              }
    518              if (!pStatus)
    519              {
    520                  return AM_HAL_STATUS_INVALID_ARG;
    521              }
    522          #endif
    523              update_indices(pCmdQ);
    524              pStatus->lastIdxProcessed = pCmdQ->curIdx;
    525              pStatus->lastIdxAllocated = pCmdQ->endIdx;
    526              pStatus->lastIdxPosted = pCmdQ->endIdx - ((pCmdQ->cmdQNextTail == pCmdQ->cmdQTail) ? 0 : 1);
    527              status = AM_REGVAL(pCmdQ->pReg->regCQStat);
    528              pStatus->bTIP = status & pCmdQ->pReg->bitMaskCQStatTIP;
    529              pStatus->bPaused = status & pCmdQ->pReg->bitMaskCQStatPaused;
    530              pStatus->bErr = status & pCmdQ->pReg->bitMaskCQStatErr;
    531          
    532              return AM_HAL_STATUS_SUCCESS;
    533          }
    534          
    535          //*****************************************************************************
    536          //
    537          //! @brief  Terminate a Command Queue
    538          //!
    539          //! Terminates the command queue data structure
    540          //!
    541          //! @param  pHandle handle for the command queue
    542          //!
    543          //! @return Returns 0 on success
    544          //
    545          //*****************************************************************************
    546          uint32_t am_hal_cmdq_term(void *pHandle, bool bForce)
    547          {
    548              am_hal_cmdq_t *pCmdQ = (am_hal_cmdq_t *)pHandle;
    549          #ifndef AM_HAL_DISABLE_API_VALIDATION
    550              if (!AM_HAL_CMDQ_CHK_HANDLE(pHandle))
    551              {
    552                  return AM_HAL_STATUS_INVALID_HANDLE;
    553              }
    554          #endif
    555              update_indices(pCmdQ);
    556              if (!bForce && (pCmdQ->curIdx != pCmdQ->endIdx))
    557              {
    558                  return AM_HAL_STATUS_IN_USE;
    559              }
    560              pCmdQ->prefix.s.bInit = false;
    561              // Disable Command Queue
    562              AM_HAL_CMDQ_DISABLE_CQ(pCmdQ->pReg->regCQCfg);
    563              AM_REGVAL(pCmdQ->pReg->regCQPause) &= ~pCmdQ->pReg->bitMaskCQPauseIdx;
    564              return AM_HAL_STATUS_SUCCESS;
    565          }
    566          
    567          //*****************************************************************************
    568          //
    569          //! @brief  Clear the CQ error and resume with the next transaction.
    570          //! The CQ is left disabled after this call
    571          //! It is the responsibility of the caller to re-enable the CQ
    572          //!
    573          //! @param  pHandle handle for the command queue
    574          //!
    575          //! @return Returns 0 on success
    576          //
    577          //*****************************************************************************
    578          uint32_t am_hal_cmdq_error_resume(void *pHandle)
    579          {
    580              am_hal_cmdq_t *pCmdQ = (am_hal_cmdq_t *)pHandle;
    581              am_hal_cmdq_entry_t *pCQAddr;
    582          #ifndef AM_HAL_DISABLE_API_VALIDATION
    583              if (!AM_HAL_CMDQ_CHK_HANDLE(pHandle))
    584              {
    585                  return AM_HAL_STATUS_INVALID_HANDLE;
    586              }
    587          
    588              if (!pCmdQ->prefix.s.bEnable)
    589              {
    590                  return AM_HAL_STATUS_SUCCESS;
    591              }
    592          #endif
    593              // First Disable the Command Queue
    594              AM_HAL_CMDQ_DISABLE_CQ(pCmdQ->pReg->regCQCfg);
    595          
    596              // Need to identify end of block for the transaction where hardware is stuck
    597              // Move the CQADDR to the last entry in the block which will update the curIdx
    598              // and then move on.
    599              pCQAddr = (am_hal_cmdq_entry_t *)AM_REGVAL(pCmdQ->pReg->regCQAddr);
    600              while ((pCQAddr->address & ~AM_HAL_CMDQ_ENABLE_CQUPD_INT) != (uint32_t)(pCmdQ->pReg->regCurIdx))
    601              {
    602                  // Is this element changing the CQ Address itself?
    603                  if (pCQAddr->address == (uint32_t)(pCmdQ->pReg->regCQAddr))
    604                  {
    605                      pCQAddr = (am_hal_cmdq_entry_t *)pCQAddr->value;
    606                  }
    607                  else
    608                  {
    609                      ++pCQAddr;
    610                  }
    611              }
    612          
    613              // The pCQAddr now points to the address of the command which will update the curIdx
    614              // Disable update interrupt, as we would have already handled this error
    615              *(&pCQAddr->address) = (uint32_t)pCmdQ->pReg->regCurIdx;
    616              AM_REGVAL(pCmdQ->pReg->regCQAddr) = (uint32_t)pCQAddr;
    617          
    618              return AM_HAL_STATUS_SUCCESS;
    619          }
    620          
    621          //*****************************************************************************
    622          //
    623          //! @brief  Pause the CQ after finishing the current transaction.
    624          //! The CQ is in paused state after this function returns, at the beginning of next transaction
    625          //!
    626          //! @param  pHandle handle for the command queue
    627          //! @param  pSETCLRAddr Points to the SETCLR register for the module
    628          //! @param  ui32CQPauseSETCLR Value to be written to Pause the CQ
    629          //! @param  ui32CQUnpauseSETCLR Value to be written to unpause the CQ
    630          //! @param  ui32usMaxDelay Max time to wait (in uS)
    631          //!
    632          //! @return Returns 0 on success
    633          //
    634          //*****************************************************************************
    635          uint32_t am_hal_cmdq_pause(void *pHandle, uint32_t *pSETCLRAddr, uint32_t ui32CQPauseSETCLR, uint32_t ui32CQUnpauseSETCLR, uint32_t ui32usMaxDelay)
    636          {
    637              am_hal_cmdq_t *pCmdQ = (am_hal_cmdq_t *)pHandle;
    638              uint32_t      cqAddr;
    639              am_hal_cmdq_entry_t *pCQAddr;
    640              am_hal_cmdq_entry_t cqEntry;
    641              uint32_t status = AM_HAL_STATUS_SUCCESS;
    642          #ifndef AM_HAL_DISABLE_API_VALIDATION
    643              if (!AM_HAL_CMDQ_CHK_HANDLE(pHandle))
    644              {
    645                  return AM_HAL_STATUS_INVALID_HANDLE;
    646              }
    647          
    648              if (!pCmdQ->prefix.s.bEnable)
    649              {
    650                  return AM_HAL_STATUS_SUCCESS;
    651              }
    652          #endif
    653              // First Pause the Command Queue
    654              *pSETCLRAddr = ui32CQPauseSETCLR;
    655              status = am_hal_flash_delay_status_change(ui32usMaxDelay, (uint32_t)pCmdQ->pReg->regCQStat, pCmdQ->pReg->bitMaskCQStatPaused, pCmdQ->pReg->bitMaskCQStatPaused);
    656              if (status != AM_HAL_STATUS_SUCCESS)
    657              {
    658                  return status;
    659              }
    660              // Now seek for the end of current transaction
    661              cqAddr = AM_REGVAL(pCmdQ->pReg->regCQAddr);
    662              if (cqAddr == pCmdQ->cmdQNextTail)
    663              {
    664                  // Already at the end
    665                  // No need to do anything else
    666              }
    667              else
    668              {
    669                  // Need to identify end of block for the transaction
    670                  pCQAddr = (am_hal_cmdq_entry_t *)cqAddr;
    671                  while ((pCQAddr->address & ~AM_HAL_CMDQ_ENABLE_CQUPD_INT) != (uint32_t)(pCmdQ->pReg->regCurIdx))
    672                  {
    673                      if ( (uint32_t) ++pCQAddr >= pCmdQ->cmdQBufEnd )
    674                      {
    675                          // This should not happen
    676                          return AM_HAL_STATUS_FAIL;
    677                      }
    678                  }
    679          
    680                  // The pCQAddr now points to the address of the command which will update the curIdx
    681                  // We need to resume the CQ till it finishes this entry
    682                  // For that we'll temporarily replace the next entry to cause a Pause
    683                  // Backup the current content
    684                  cqEntry = *(++pCQAddr);
    685                  pCQAddr->address = (uint32_t)pSETCLRAddr;
    686                  pCQAddr->value = ui32CQPauseSETCLR;
    687                  // Wait for it to execute this new entry, or get paused for some other condition
    688                  do
    689                  {
    690                      // Resume the CQ
    691                      *pSETCLRAddr = ui32CQUnpauseSETCLR;
    692                      // Ensure CQ sees it
    693                      am_hal_flash_delay(3);
    694                      // Now wait for it to be paused again
    695                      status = am_hal_flash_delay_status_change(ui32usMaxDelay, (uint32_t)pCmdQ->pReg->regCQStat, pCmdQ->pReg->bitMaskCQStatPaused, pCmdQ->pReg->bitMaskCQStatPaused);
    696                      if (status != AM_HAL_STATUS_SUCCESS)
    697                      {
    698                          return status;
    699                      }
    700                      // Try Setting the PAUSE condition while in same position
    701                      *pSETCLRAddr = ui32CQPauseSETCLR;
    702                      // Ensure CQ sees it
    703                      am_hal_flash_delay(3);
    704                      status = am_hal_flash_delay_status_change(ui32usMaxDelay, (uint32_t)pCmdQ->pReg->regCQStat, pCmdQ->pReg->bitMaskCQStatPaused, pCmdQ->pReg->bitMaskCQStatPaused);
    705                      if (status != AM_HAL_STATUS_SUCCESS)
    706                      {
    707                          return status;
    708                      }
    709                      if (cqAddr == AM_REGVAL(pCmdQ->pReg->regCQAddr))
    710                      {
    711                          // CQ no longer moving
    712                          break;
    713                      }
    714                      else
    715                      {
    716                          cqAddr = AM_REGVAL(pCmdQ->pReg->regCQAddr);
    717                      }
    718          #if 0
    719                      // Now that it is paused - check if we have reached our entry - or it paused somewhere else
    720                      cqAddr = AM_REGVAL(pCmdQ->pReg->regCQAddr);
    721                      if (cqAddr != (uint32_t)(pCQAddr + 1))
    722                      {
    723                          // It paused due to some other reason
    724                          // Try Setting the PAUSE condition while in same position
    725                          *pSETCLRAddr = ui32CQPauseSETCLR;
    726                          // Ensure CQ sees it
    727                          am_hal_flash_delay(3);
    728                          status = am_hal_flash_delay_status_change(ui32usMaxDelay, (uint32_t)pCmdQ->pReg->regCQStat, pCmdQ->pReg->bitMaskCQStatPaused, pCmdQ->pReg->bitMaskCQStatPaused);
    729                          if (status != AM_HAL_STATUS_SUCCESS)
    730                          {
    731                              return status;
    732                          }
    733                          if (AM_REGVAL(pCmdQ->pReg->regCQAddr) == cqAddr)
    734                          {
    735                              // CQ did not move after we set the PAUSE - so it is at a designated pause place
    736                              // Safe to return now
    737                              break;
    738                          }
    739                          else
    740                          {
    741                              // CQ is moving...need to retry
    742                          }
    743                      }
    744                      else
    745                      {
    746                          // Reached the desired place
    747                          break;
    748                      }
    749          #endif
    750                  } while(1);
    751                  // Now let's revert the CQ content and set the CQADDR to correct place for it to resume later
    752                  // when the CQ is unpaused
    753                  *pCQAddr = cqEntry;
    754                  if (AM_REGVAL(pCmdQ->pReg->regCQAddr) == (uint32_t)(pCQAddr + 1))
    755                  {
    756                      AM_REGVAL(pCmdQ->pReg->regCQAddr) = (uint32_t)pCQAddr;
    757                  }
    758              }
    759          
    760              return AM_HAL_STATUS_SUCCESS;
    761          }
    762          
    763          //*****************************************************************************
    764          //
    765          //! @brief  Reset the Command Queue
    766          //!
    767          //! Reset the Command Queue & associated data structures
    768          //! This will force the CQ reset
    769          //! Caller needs to ensure CQ is in steady state before this is done
    770          //! This also disables the CQ
    771          //!
    772          //! @param  pHandle handle for the command queue
    773          //!
    774          //! @return Returns 0 on success
    775          //
    776          //*****************************************************************************
    777          uint32_t am_hal_cmdq_reset(void *pHandle)
    778          {
    779              am_hal_cmdq_t *pCmdQ = (am_hal_cmdq_t *)pHandle;
    780          #ifndef AM_HAL_DISABLE_API_VALIDATION
    781              if (!AM_HAL_CMDQ_CHK_HANDLE(pHandle))
    782              {
    783                  return AM_HAL_STATUS_INVALID_HANDLE;
    784              }
    785              if (pCmdQ->prefix.s.bEnable)
    786              {
    787                  return AM_HAL_STATUS_INVALID_OPERATION;
    788              }
    789          #endif
    790              AM_HAL_CMDQ_DISABLE_CQ(pCmdQ->pReg->regCQCfg);
    791              pCmdQ->cmdQTail = pCmdQ->cmdQNextTail = pCmdQ->cmdQHead = pCmdQ->cmdQBufStart;
    792              pCmdQ->curIdx = 0;
    793              pCmdQ->endIdx = 0;
    794              AM_REGVAL(pCmdQ->pReg->regCurIdx) = 0;
    795              AM_REGVAL(pCmdQ->pReg->regEndIdx) = 0;
    796              // Initialize the hardware registers
    797              AM_REGVAL(pCmdQ->pReg->regCQAddr) = pCmdQ->cmdQBufStart;
    798              pCmdQ->prefix.s.bEnable = false;
    799              return AM_HAL_STATUS_SUCCESS;
    800          }
    801          
    802          //*****************************************************************************
    803          //
    804          //! @brief  Post the last block allocated with the additional wrap to start
    805          //!
    806          //! Post the  contiguous block of command queue entries previously allocated
    807          //! with the additional wrap to start
    808          //!
    809          //! @param  pHandle handle for the command queue
    810          //! @param  bInt Whether the UPD interrupt is desired once the block is processed
    811          //!
    812          //! @return Returns 0 on success
    813          //
    814          //*****************************************************************************
    815          uint32_t am_hal_cmdq_post_loop_block(void *pHandle, bool bInt)
    816          {
    817              am_hal_cmdq_t *pCmdQ = (am_hal_cmdq_t *)pHandle;
    818              am_hal_cmdq_entry_t *pCmdQEntry;
    819          #ifndef AM_HAL_DISABLE_API_VALIDATION
    820              if (!AM_HAL_CMDQ_CHK_HANDLE(pHandle))
    821              {
    822                  return AM_HAL_STATUS_INVALID_HANDLE;
    823              }
    824              if (pCmdQ->cmdQTail == pCmdQ->cmdQNextTail)
    825              {
    826                  // No block has been allocated
    827                  return AM_HAL_STATUS_INVALID_OPERATION;
    828              }
    829          #endif
    830              // CmdQ entries have already been populated. Just need to inform hardware of the new endIdx
    831              // Reset the index to 0
    832              pCmdQEntry = (am_hal_cmdq_entry_t *)pCmdQ->cmdQNextTail;
    833              pCmdQEntry->address = (uint32_t)pCmdQ->pReg->regCurIdx;
    834              pCmdQEntry->value = 0;
    835              pCmdQEntry++;
    836              // Fill up the loopback entry
    837              // At the alloc time, we were guaranteed one extra entry for loopback
    838              pCmdQEntry->address = (uint32_t)pCmdQ->pReg->regCQAddr | (bInt ? AM_HAL_CMDQ_ENABLE_CQUPD_INT : 0);
    839              pCmdQEntry->value = pCmdQ->cmdQBufStart;
    840              // cmdQNextTail should now point to the first entry after the allocated block
    841              pCmdQ->cmdQTail = pCmdQ->cmdQNextTail = (uint32_t)(pCmdQEntry + 1);
    842              // Since we are not updating the curIdx - this will cause CQ to run indefinetely
    843              AM_REGVAL(pCmdQ->pReg->regEndIdx) = pCmdQ->endIdx & AM_HAL_CMDQ_HW_IDX_MAX;
    844              return AM_HAL_STATUS_SUCCESS;
    845          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   am_hal_cmdq_alloc_block
        32   -> update_indices
       0   am_hal_cmdq_disable
       0   am_hal_cmdq_enable
       4   am_hal_cmdq_error_resume
      16   am_hal_cmdq_get_status
        16   -> update_indices
      12   am_hal_cmdq_init
      56   am_hal_cmdq_pause
        56   -> am_hal_flash_delay
        56   -> am_hal_flash_delay_status_change
       8   am_hal_cmdq_post_block
       8   am_hal_cmdq_post_loop_block
       0   am_hal_cmdq_release_block
       0   am_hal_cmdq_reset
      16   am_hal_cmdq_term
        16   -> update_indices
      16   update_indices
        16   -> am_hal_interrupt_master_disable
        16   -> am_hal_interrupt_master_set


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
     240  am_hal_cmdq_alloc_block
      68  am_hal_cmdq_disable
      68  am_hal_cmdq_enable
     112  am_hal_cmdq_error_resume
     130  am_hal_cmdq_get_status
     224  am_hal_cmdq_init
     326  am_hal_cmdq_pause
      98  am_hal_cmdq_post_block
     110  am_hal_cmdq_post_loop_block
      52  am_hal_cmdq_release_block
     106  am_hal_cmdq_reset
     100  am_hal_cmdq_term
     320  gAmHalCmdQReg
     352  gAmHalCmdq
      64  update_indices

 
   352 bytes in section .bss
   320 bytes in section .rodata
 1 710 bytes in section .text
 
 1 710 bytes of CODE  memory
   320 bytes of CONST memory
   352 bytes of DATA  memory

Errors: none
Warnings: none
