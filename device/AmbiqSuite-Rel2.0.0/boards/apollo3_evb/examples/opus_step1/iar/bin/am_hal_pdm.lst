###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         12/Mar/2019  10:07:09
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_pdm.c
#    Command line =  
#        -f C:\temp\EW875F.tmp
#        (C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_pdm.c
#        -D iar -D AM_PART_APOLLO3 -D AM_PACKAGE_BGA -lcN
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --diag_suppress Pa050 -o
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\utils\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\ARM\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\AmbiqMicro\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\mcu\apollo3\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\devices\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\bsp\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\sound\
#        -On)
#    Locale       =  C
#    List file    =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_pdm.lst
#    Object file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_pdm.o
#
###############################################################################

C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_pdm.c
      1          //*****************************************************************************
      2          //
      3          //! @file am_hal_pdm.c
      4          //!
      5          //! @brief HAL implementation for the PDM module.
      6          //!
      7          //! @addtogroup
      8          //! @ingroup
      9          //! @{
     10          //
     11          //*****************************************************************************
     12          
     13          //*****************************************************************************
     14          //
     15          // Copyright (c) 2019, Ambiq Micro
     16          // All rights reserved.
     17          // 
     18          // Redistribution and use in source and binary forms, with or without
     19          // modification, are permitted provided that the following conditions are met:
     20          // 
     21          // 1. Redistributions of source code must retain the above copyright notice,
     22          // this list of conditions and the following disclaimer.
     23          // 
     24          // 2. Redistributions in binary form must reproduce the above copyright
     25          // notice, this list of conditions and the following disclaimer in the
     26          // documentation and/or other materials provided with the distribution.
     27          // 
     28          // 3. Neither the name of the copyright holder nor the names of its
     29          // contributors may be used to endorse or promote products derived from this
     30          // software without specific prior written permission.
     31          // 
     32          // Third party software included in this distribution is subject to the
     33          // additional license terms as defined in the /docs/licenses directory.
     34          // 
     35          // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     36          // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     37          // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     38          // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     39          // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     40          // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     41          // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     42          // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     43          // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     44          // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     45          // POSSIBILITY OF SUCH DAMAGE.
     46          //
     47          // This is part of revision v2.0.0 of the AmbiqSuite Development Package.
     48          //
     49          //*****************************************************************************
     50          
     51          #include <stdint.h>
     52          #include <stdbool.h>
     53          #include "am_mcu_apollo.h"
     54          
     55          //*****************************************************************************
     56          //
     57          // PDM magic number for handle verification.
     58          //
     59          //*****************************************************************************
     60          #define AM_HAL_MAGIC_PDM                0xF956E2
     61          
     62          #define AM_HAL_PDM_HANDLE_VALID(h)                                            \
     63              ((h) &&                                                                   \
     64               ((am_hal_handle_prefix_t *)(h))->s.bInit &&                              \
     65               (((am_hal_handle_prefix_t *)(h))->s.magic == AM_HAL_MAGIC_PDM))
     66          
     67          //*****************************************************************************
     68          //
     69          // Convenience macro for passing errors.
     70          //
     71          //*****************************************************************************
     72          #define RETURN_ON_ERROR(x)                                                    \
     73              if ((x) != AM_HAL_STATUS_SUCCESS)                                         \
     74              {                                                                         \
     75                  return (x);                                                           \
     76              };
     77          
     78          //*****************************************************************************
     79          //
     80          // Abbreviation for validating handles and returning errors.
     81          //
     82          //*****************************************************************************
     83          #ifndef AM_HAL_DISABLE_API_VALIDATION
     84          
     85          #define AM_HAL_PDM_HANDLE_CHECK(h)                                            \
     86              if (!AM_HAL_PDM_HANDLE_VALID(h))                                          \
     87              {                                                                         \
     88                  return AM_HAL_STATUS_INVALID_HANDLE;                                  \
     89              }
     90          
     91          #else
     92          
     93          #define AM_HAL_PDM_HANDLE_CHECK(h)
     94          
     95          #endif
     96          
     97          //*****************************************************************************
     98          //
     99          // Helper macros for delays.
    100          //
    101          //*****************************************************************************
    102          #define delay_ms(ms)                                                          \
    103              if (1)                                                                    \
    104              {                                                                         \
    105                  am_hal_clkgen_status_t sClkGenStatus;                                 \
    106                  am_hal_clkgen_status_get(&sClkGenStatus);                             \
    107                  am_hal_flash_delay((ms) * (sClkGenStatus.ui32SysclkFreq / 3000));     \
    108              }
    109          
    110          #define delay_us(us)                                                          \
    111              if (1)                                                                    \
    112              {                                                                         \
    113                  am_hal_clkgen_status_t sClkGenStatus;                                 \
    114                  am_hal_clkgen_status_get(&sClkGenStatus);                             \
    115                  am_hal_flash_delay((us) * (sClkGenStatus.ui32SysclkFreq / 3000000));  \
    116              }
    117          
    118          //*****************************************************************************
    119          //
    120          // Structure for handling PDM register state information for power up/down
    121          //
    122          //*****************************************************************************
    123          typedef struct
    124          {
    125              bool bValid;
    126          }
    127          am_hal_pdm_register_state_t;
    128          
    129          //*****************************************************************************
    130          //
    131          // Structure for handling PDM HAL state information.
    132          //
    133          //*****************************************************************************
    134          typedef struct
    135          {
    136              am_hal_handle_prefix_t prefix;
    137              am_hal_pdm_register_state_t sRegState;
    138              uint32_t ui32Module;
    139          }
    140          am_hal_pdm_state_t;
    141          
    142          //*****************************************************************************
    143          //
    144          // State structure for each module.
    145          //
    146          //*****************************************************************************
    147          am_hal_pdm_state_t g_am_hal_pdm_states[AM_REG_PDM_NUM_MODULES];
    148          
    149          //*****************************************************************************
    150          //
    151          // Initialization function.
    152          //
    153          //*****************************************************************************
    154          uint32_t
    155          am_hal_pdm_initialize(uint32_t ui32Module, void **ppHandle)
    156          {
    157              //
    158              // Check that the request module is in range.
    159              //
    160              if ( ui32Module >= AM_REG_PDM_NUM_MODULES )
    161              {
    162                  return AM_HAL_STATUS_OUT_OF_RANGE;
    163              }
    164          
    165              //
    166              // Check for valid arguements.
    167              //
    168              if (!ppHandle)
    169              {
    170                  return AM_HAL_STATUS_INVALID_ARG;
    171              }
    172          
    173              //
    174              // Check if the handle is unallocated.
    175              //
    176              if (g_am_hal_pdm_states[ui32Module].prefix.s.bInit)
    177              {
    178                  return AM_HAL_STATUS_INVALID_OPERATION;
    179              }
    180          
    181              //
    182              // Initialize the handle.
    183              //
    184              g_am_hal_pdm_states[ui32Module].prefix.s.bInit = true;
    185              g_am_hal_pdm_states[ui32Module].prefix.s.magic = AM_HAL_MAGIC_PDM;
    186              g_am_hal_pdm_states[ui32Module].ui32Module = ui32Module;
    187              g_am_hal_pdm_states[ui32Module].sRegState.bValid = false;
    188          
    189              //
    190              // Return the handle.
    191              //
    192              *ppHandle = (void *)&g_am_hal_pdm_states[ui32Module];
    193          
    194              //
    195              // Return the status.
    196              //
    197              return AM_HAL_STATUS_SUCCESS;
    198          }
    199          
    200          //*****************************************************************************
    201          //
    202          // De-Initialization function.
    203          //
    204          //*****************************************************************************
    205          uint32_t
    206          am_hal_pdm_deinitialize(void *pHandle)
    207          {
    208              am_hal_pdm_state_t *pState = (am_hal_pdm_state_t *)pHandle;
    209          
    210              //
    211              // Check the handle.
    212              //
    213              AM_HAL_PDM_HANDLE_CHECK(pHandle);
    214          
    215              //
    216              // Reset the handle.
    217              //
    218              pState->prefix.s.bInit = false;
    219              pState->prefix.s.magic = 0;
    220              pState->ui32Module = 0;
    221          
    222              //
    223              // Return the status.
    224              //
    225              return AM_HAL_STATUS_SUCCESS;
    226          }
    227          
    228          //*****************************************************************************
    229          //
    230          // Power control function.
    231          //
    232          //*****************************************************************************
    233          uint32_t
    234          am_hal_pdm_power_control(void *pHandle,
    235                                   am_hal_sysctrl_power_state_e ePowerState,
    236                                   bool bRetainState)
    237          {
    238              am_hal_pdm_state_t *pState = (am_hal_pdm_state_t *) pHandle;
    239              uint32_t ui32Module = pState->ui32Module;
    240          
    241              am_hal_pwrctrl_periph_e ePDMPowerModule = ((am_hal_pwrctrl_periph_e)
    242                                                          (AM_HAL_PWRCTRL_PERIPH_PDM +
    243                                                           ui32Module));
    244              //
    245              // Check the handle.
    246              //
    247              AM_HAL_PDM_HANDLE_CHECK(pHandle);
    248          
    249              //
    250              // Decode the requested power state and update PDM operation accordingly.
    251              //
    252              switch (ePowerState)
    253              {
    254                  //
    255                  // Turn on the PDM.
    256                  //
    257                  case AM_HAL_SYSCTRL_WAKE:
    258                      //
    259                      // Make sure we don't try to restore an invalid state.
    260                      //
    261                      if (bRetainState && !pState->sRegState.bValid)
    262                      {
    263                          return AM_HAL_STATUS_INVALID_OPERATION;
    264                      }
    265          
    266                      //
    267                      // Enable power control.
    268                      //
    269                      am_hal_pwrctrl_periph_enable(ePDMPowerModule);
    270          
    271                      if (bRetainState)
    272                      {
    273                          //
    274                          // Restore PDM registers
    275                          //
    276                          AM_CRITICAL_BEGIN;
    277          
    278                          pState->sRegState.bValid = false;
    279          
    280                          AM_CRITICAL_END;
    281                      }
    282                      break;
    283          
    284                  //
    285                  // Turn off the PDM.
    286                  //
    287                  case AM_HAL_SYSCTRL_NORMALSLEEP:
    288                  case AM_HAL_SYSCTRL_DEEPSLEEP:
    289                      if (bRetainState)
    290                      {
    291                          AM_CRITICAL_BEGIN;
    292          
    293                          pState->sRegState.bValid = true;
    294          
    295                          AM_CRITICAL_END;
    296                      }
    297          
    298                      //
    299                      // Disable power control.
    300                      //
    301                      am_hal_pwrctrl_periph_disable(ePDMPowerModule);
    302                      break;
    303          
    304                  default:
    305                      return AM_HAL_STATUS_INVALID_ARG;
    306              }
    307          
    308              //
    309              // Return the status.
    310              //
    311              return AM_HAL_STATUS_SUCCESS;
    312          }
    313          
    314          //*****************************************************************************
    315          //
    316          // Configure the PDM.
    317          //
    318          //*****************************************************************************
    319          uint32_t
    320          am_hal_pdm_configure(void *pHandle, am_hal_pdm_config_t *psConfig)
    321          {
    322              am_hal_pdm_state_t *pState = (am_hal_pdm_state_t *) pHandle;
    323              uint32_t ui32Module = pState->ui32Module;
    324              AM_HAL_PDM_HANDLE_CHECK(pHandle);
    325          
    326              //
    327              // Apply the config structure settings to the PCFG register.
    328              //
    329              PDMn(ui32Module)->PCFG_b.SOFTMUTE = psConfig->bSoftMute;
    330              PDMn(ui32Module)->PCFG_b.CYCLES = psConfig->ui32GainChangeDelay;
    331              PDMn(ui32Module)->PCFG_b.HPCUTOFF = psConfig->ui32HighPassCutoff;
    332              PDMn(ui32Module)->PCFG_b.ADCHPD = psConfig->bHighPassEnable;
    333              PDMn(ui32Module)->PCFG_b.SINCRATE = psConfig->ui32DecimationRate;
    334              PDMn(ui32Module)->PCFG_b.MCLKDIV = psConfig->eClkDivider;
    335              PDMn(ui32Module)->PCFG_b.PGALEFT = psConfig->eLeftGain;
    336              PDMn(ui32Module)->PCFG_b.PGARIGHT = psConfig->eRightGain;
    337              PDMn(ui32Module)->PCFG_b.LRSWAP = psConfig->bLRSwap;
    338          
    339              //
    340              // Set the PDM Core enable bit to enable PDM to PCM conversions.
    341              //
    342              PDMn(ui32Module)->PCFG_b.PDMCOREEN = PDM_PCFG_PDMCOREEN_EN;
    343          
    344              //
    345              // Program the "voice" registers.
    346              //
    347              PDMn(ui32Module)->VCFG_b.PDMCLKEN = PDM_VCFG_PDMCLKEN_DIS;
    348              PDMn(ui32Module)->VCFG_b.IOCLKEN = PDM_VCFG_IOCLKEN_DIS;
    349              PDMn(ui32Module)->VCFG_b.RSTB = PDM_VCFG_RSTB_RESET;
    350              PDMn(ui32Module)->VCFG_b.CHSET = psConfig->ePCMChannels;
    351              PDMn(ui32Module)->VCFG_b.PCMPACK = psConfig->bDataPacking;
    352              PDMn(ui32Module)->VCFG_b.SELAP = psConfig->ePDMClkSource;
    353              PDMn(ui32Module)->VCFG_b.DMICKDEL = psConfig->bPDMSampleDelay;
    354              PDMn(ui32Module)->VCFG_b.BCLKINV = psConfig->bInvertI2SBCLK;
    355              PDMn(ui32Module)->VCFG_b.I2SEN = psConfig->bI2SEnable;
    356              PDMn(ui32Module)->VCFG_b.PDMCLKSEL = psConfig->ePDMClkSpeed;
    357          
    358              delay_us(100);
    359          
    360              PDMn(ui32Module)->VCFG_b.RSTB = PDM_VCFG_RSTB_NORM;
    361          
    362              return AM_HAL_STATUS_SUCCESS;
    363          }
    364          
    365          //*****************************************************************************
    366          //
    367          // Enable the PDM.
    368          //
    369          //*****************************************************************************
    370          uint32_t
    371          am_hal_pdm_enable(void *pHandle)
    372          {
    373              am_hal_pdm_state_t *pState = (am_hal_pdm_state_t *) pHandle;
    374              uint32_t ui32Module = pState->ui32Module;
    375              AM_HAL_PDM_HANDLE_CHECK(pHandle);
    376          
    377              PDMn(ui32Module)->VCFG_b.IOCLKEN = PDM_VCFG_IOCLKEN_EN;
    378              PDMn(ui32Module)->VCFG_b.PDMCLKEN = PDM_VCFG_PDMCLKEN_EN;
    379          
    380              return AM_HAL_STATUS_SUCCESS;
    381          }
    382          
    383          //*****************************************************************************
    384          //
    385          // Disable the PDM.
    386          //
    387          //*****************************************************************************
    388          uint32_t
    389          am_hal_pdm_disable(void *pHandle)
    390          {
    391              am_hal_pdm_state_t *pState = (am_hal_pdm_state_t *) pHandle;
    392              uint32_t ui32Module = pState->ui32Module;
    393              AM_HAL_PDM_HANDLE_CHECK(pHandle);
    394          
    395              PDMn(ui32Module)->VCFG_b.IOCLKEN = PDM_VCFG_IOCLKEN_DIS;
    396              PDMn(ui32Module)->VCFG_b.PDMCLKEN = PDM_VCFG_PDMCLKEN_DIS;
    397          
    398              return AM_HAL_STATUS_SUCCESS;
    399          }
    400          
    401          //*****************************************************************************
    402          //
    403          // Starts a DMA transaction from the PDM directly to SRAM
    404          //
    405          //*****************************************************************************
    406          uint32_t
    407          am_hal_pdm_dma_start(void *pHandle, am_hal_pdm_transfer_t *pDmaCfg)
    408          {
    409              am_hal_pdm_state_t *pState = (am_hal_pdm_state_t *) pHandle;
    410              uint32_t ui32Module = pState->ui32Module;
    411              AM_HAL_PDM_HANDLE_CHECK(pHandle);
    412          
    413              //
    414              // Calculate a FIFO threshold that will work. The PDM DMA hardware can only
    415              // perform transactions where the total count is an integer multiple of the
    416              // threshold value. We will loop here to try to find a threshold value and
    417              // an integer multiple (ui32NumReloads) that will fit the total count the
    418              // user asked for.
    419              //
    420              uint32_t ui32Threshold = 0;
    421              uint32_t ui32NumReloads = 1;
    422          
    423              for (ui32NumReloads = 1; ui32NumReloads < pDmaCfg->ui32TotalCount; ui32NumReloads++)
    424              {
    425                  //
    426                  // Check to make sure the total count is evenly divisible into chunks
    427                  // that are smaller than the maximum threshold size.
    428                  //
    429                  if (((pDmaCfg->ui32TotalCount % ui32NumReloads) == 0) &&
    430                      ((pDmaCfg->ui32TotalCount / ui32NumReloads) <= 0x1F))
    431                  {
    432                      ui32Threshold = pDmaCfg->ui32TotalCount / ui32NumReloads;
    433                      break;
    434                  }
    435              }
    436          
    437              //
    438              // If we didn't find a threshold that will work, throw an error.
    439              //
    440              if (ui32Threshold == 0)
    441              {
    442                  return AM_HAL_PDM_STATUS_BAD_TOTALCOUNT;
    443              }
    444          
    445              PDMn(ui32Module)->FIFOTHR = ui32Threshold;
    446          
    447              //
    448              // Configure DMA.
    449              //
    450              PDMn(ui32Module)->DMACFG = 0;
    451              PDMn(ui32Module)->DMACFG_b.DMAPRI = PDM_DMACFG_DMAPRI_LOW;
    452              PDMn(ui32Module)->DMACFG_b.DMADIR = PDM_DMACFG_DMADIR_P2M;
    453              PDMn(ui32Module)->DMATOTCOUNT = pDmaCfg->ui32TotalCount;
    454              PDMn(ui32Module)->DMATARGADDR = pDmaCfg->ui32TargetAddr;
    455          
    456              //
    457              // Make sure the trigger is set for threshold.
    458              //
    459              PDMn(ui32Module)->DMATRIGEN_b.DTHR = 1;
    460          
    461              //
    462              // Enable DMA
    463              //
    464              PDMn(ui32Module)->DMACFG_b.DMAEN = PDM_DMACFG_DMAEN_EN;
    465          
    466          //    //
    467          //    // Reset the voice module.
    468          //    //
    469          //    PDMn(ui32Module)->VCFG_b.RSTB = PDM_VCFG_RSTB_RESET;
    470          //
    471          //    delay_us(100);
    472          //
    473          //    PDMn(ui32Module)->VCFG_b.RSTB = PDM_VCFG_RSTB_NORM;
    474          //    PDMn(ui32Module)->VCFG_b.PDMCLKEN = 1;
    475          
    476              return AM_HAL_STATUS_SUCCESS;
    477          }
    478          
    479          //*****************************************************************************
    480          //
    481          // Flush the PDM FIFO
    482          //
    483          //*****************************************************************************
    484          uint32_t
    485          am_hal_pdm_fifo_flush(void *pHandle)
    486          {
    487              am_hal_pdm_state_t *pState = (am_hal_pdm_state_t *) pHandle;
    488              uint32_t ui32Module = pState->ui32Module;
    489              AM_HAL_PDM_HANDLE_CHECK(pHandle);
    490          
    491              PDMn(ui32Module)->FIFOFLUSH = 1;
    492          
    493              return AM_HAL_STATUS_SUCCESS;
    494          }
    495          
    496          //*****************************************************************************
    497          //
    498          // Enable PDM passthrough to the I2S slave.
    499          //
    500          //*****************************************************************************
    501          uint32_t
    502          am_hal_pdm_i2s_enable(void *pHandle)
    503          {
    504              am_hal_pdm_state_t *pState = (am_hal_pdm_state_t *) pHandle;
    505              AM_HAL_PDM_HANDLE_CHECK(pHandle);
    506              uint32_t ui32Module = pState->ui32Module;
    507          
    508              PDMn(ui32Module)->VCFG_b.I2SEN = PDM_VCFG_I2SEN_EN;
    509          
    510              return AM_HAL_STATUS_SUCCESS;
    511          }
    512          
    513          //*****************************************************************************
    514          //
    515          // Disable PDM passthrough to the I2S slave.
    516          //
    517          //*****************************************************************************
    518          uint32_t
    519          am_hal_pdm_i2s_disable(void *pHandle)
    520          {
    521              am_hal_pdm_state_t *pState = (am_hal_pdm_state_t *) pHandle;
    522              AM_HAL_PDM_HANDLE_CHECK(pHandle);
    523              uint32_t ui32Module = pState->ui32Module;
    524          
    525              PDMn(ui32Module)->VCFG_b.I2SEN = PDM_VCFG_I2SEN_DIS;
    526          
    527              return AM_HAL_STATUS_SUCCESS;
    528          }
    529          
    530          //*****************************************************************************
    531          //
    532          // Interrupt enable.
    533          //
    534          //*****************************************************************************
    535          uint32_t
    536          am_hal_pdm_interrupt_enable(void *pHandle, uint32_t ui32IntMask)
    537          {
    538              am_hal_pdm_state_t *pState = (am_hal_pdm_state_t *) pHandle;
    539              uint32_t ui32Module = pState->ui32Module;
    540          
    541              //
    542              // Check the handle.
    543              //
    544              AM_HAL_PDM_HANDLE_CHECK(pHandle);
    545          
    546              PDMn(ui32Module)->INTEN |= ui32IntMask;
    547          
    548              return AM_HAL_STATUS_SUCCESS;
    549          }
    550          
    551          //*****************************************************************************
    552          //
    553          // Interrupt disable.
    554          //
    555          //*****************************************************************************
    556          uint32_t
    557          am_hal_pdm_interrupt_disable(void *pHandle, uint32_t ui32IntMask)
    558          {
    559              am_hal_pdm_state_t *pState = (am_hal_pdm_state_t *) pHandle;
    560              uint32_t ui32Module = pState->ui32Module;
    561          
    562              //
    563              // Check the handle.
    564              //
    565              AM_HAL_PDM_HANDLE_CHECK(pHandle);
    566          
    567              PDMn(ui32Module)->INTEN &= ~ui32IntMask;
    568          
    569              return AM_HAL_STATUS_SUCCESS;
    570          }
    571          
    572          //*****************************************************************************
    573          //
    574          // Interrupt clear.
    575          //
    576          //*****************************************************************************
    577          uint32_t
    578          am_hal_pdm_interrupt_clear(void *pHandle, uint32_t ui32IntMask)
    579          {
    580              am_hal_pdm_state_t *pState = (am_hal_pdm_state_t *) pHandle;
    581              uint32_t ui32Module = pState->ui32Module;
    582          
    583              //
    584              // Check the handle.
    585              //
    586              AM_HAL_PDM_HANDLE_CHECK(pHandle);
    587          
    588              PDMn(ui32Module)->INTCLR = ui32IntMask;
    589          
    590              return AM_HAL_STATUS_SUCCESS;
    591          }
    592          
    593          //*****************************************************************************
    594          //
    595          // Returns the interrupt status.
    596          //
    597          //*****************************************************************************
    598          uint32_t
    599          am_hal_pdm_interrupt_status_get(void *pHandle, uint32_t *pui32Status, bool bEnabledOnly)
    600          {
    601              am_hal_pdm_state_t *pState = (am_hal_pdm_state_t *) pHandle;
    602              uint32_t ui32Module = pState->ui32Module;
    603          
    604              //
    605              // Check the handle.
    606              //
    607              AM_HAL_PDM_HANDLE_CHECK(pHandle);
    608          
    609              //
    610              // If requested, only return the interrupts that are enabled.
    611              //
    612              if ( bEnabledOnly )
    613              {
    614                  *pui32Status = PDMn(ui32Module)->INTSTAT;
    615                  *pui32Status &= PDMn(ui32Module)->INTEN;
    616              }
    617              else
    618              {
    619                  *pui32Status = PDMn(ui32Module)->INTSTAT;
    620              }
    621          
    622              return AM_HAL_STATUS_SUCCESS;
    623          }
    624          
    625          //*****************************************************************************
    626          //
    627          // End Doxygen group.
    628          //! @}
    629          //
    630          //*****************************************************************************

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   am_hal_pdm_configure
        40   -> am_hal_clkgen_status_get
        40   -> am_hal_flash_delay
       0   am_hal_pdm_deinitialize
      12   am_hal_pdm_disable
      20   am_hal_pdm_dma_start
      12   am_hal_pdm_enable
       8   am_hal_pdm_fifo_flush
       8   am_hal_pdm_i2s_disable
       8   am_hal_pdm_i2s_enable
       8   am_hal_pdm_initialize
       8   am_hal_pdm_interrupt_clear
      12   am_hal_pdm_interrupt_disable
      12   am_hal_pdm_interrupt_enable
      16   am_hal_pdm_interrupt_status_get
      32   am_hal_pdm_power_control
        32   -> am_hal_interrupt_master_disable
        32   -> am_hal_interrupt_master_set
        32   -> am_hal_pwrctrl_periph_disable
        32   -> am_hal_pwrctrl_periph_enable


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
     440  am_hal_pdm_configure
      50  am_hal_pdm_deinitialize
      70  am_hal_pdm_disable
     220  am_hal_pdm_dma_start
      70  am_hal_pdm_enable
      46  am_hal_pdm_fifo_flush
      54  am_hal_pdm_i2s_disable
      54  am_hal_pdm_i2s_enable
     116  am_hal_pdm_initialize
      46  am_hal_pdm_interrupt_clear
      56  am_hal_pdm_interrupt_disable
      56  am_hal_pdm_interrupt_enable
      86  am_hal_pdm_interrupt_status_get
     154  am_hal_pdm_power_control
      12  g_am_hal_pdm_states

 
    12 bytes in section .bss
 1 538 bytes in section .text
 
 1 538 bytes of CODE memory
    12 bytes of DATA memory

Errors: none
Warnings: none
