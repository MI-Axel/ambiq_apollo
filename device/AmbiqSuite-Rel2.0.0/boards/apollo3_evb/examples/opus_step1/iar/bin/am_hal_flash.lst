###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         12/Mar/2019  10:07:07
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_flash.c
#    Command line =  
#        -f C:\temp\EW8245.tmp
#        (C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_flash.c
#        -D iar -D AM_PART_APOLLO3 -D AM_PACKAGE_BGA -lcN
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --diag_suppress Pa050 -o
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\utils\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\ARM\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\AmbiqMicro\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\mcu\apollo3\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\devices\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\bsp\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\sound\
#        -On)
#    Locale       =  C
#    List file    =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_flash.lst
#    Object file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_flash.o
#
###############################################################################

C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_flash.c
      1          //*****************************************************************************
      2          //
      3          //  am_hal_flash.c
      4          //! @file
      5          //!
      6          //! @brief Functions for performing Flash operations.
      7          //!
      8          //! IMPORTANT: Interrupts are active during execution of all HAL flash
      9          //! functions. If an interrupt occurs during execution of a flash function
     10          //! that programs or erases flash or INFO space, errors will occur if the
     11          //! interrupt service routine (ISR) is located in on-chip flash.
     12          //! If interrupts are expected during execution of a flash function that
     13          //! programs or erases either flash or INFO space:
     14          //! - Interrupts must be disabled via a critical section handler prior to
     15          //!   calling the flash function.
     16          //! - Alternatively, applicable ISRs must be located in non-flash address space
     17          //!   (i.e. SRAM, off-chip ROM, etc.).
     18          //!
     19          //! @addtogroup flash3 Flash
     20          //! @ingroup apollo3hal
     21          //! @{
     22          //
     23          //*****************************************************************************
     24          
     25          //*****************************************************************************
     26          //
     27          // Copyright (c) 2019, Ambiq Micro
     28          // All rights reserved.
     29          // 
     30          // Redistribution and use in source and binary forms, with or without
     31          // modification, are permitted provided that the following conditions are met:
     32          // 
     33          // 1. Redistributions of source code must retain the above copyright notice,
     34          // this list of conditions and the following disclaimer.
     35          // 
     36          // 2. Redistributions in binary form must reproduce the above copyright
     37          // notice, this list of conditions and the following disclaimer in the
     38          // documentation and/or other materials provided with the distribution.
     39          // 
     40          // 3. Neither the name of the copyright holder nor the names of its
     41          // contributors may be used to endorse or promote products derived from this
     42          // software without specific prior written permission.
     43          // 
     44          // Third party software included in this distribution is subject to the
     45          // additional license terms as defined in the /docs/licenses directory.
     46          // 
     47          // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     48          // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     49          // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     50          // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     51          // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     52          // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     53          // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     54          // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     55          // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     56          // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     57          // POSSIBILITY OF SUCH DAMAGE.
     58          //
     59          // This is part of revision v2.0.0 of the AmbiqSuite Development Package.
     60          //
     61          //*****************************************************************************
     62          
     63          #include <stdint.h>
     64          #include <stdbool.h>
     65          #include "am_mcu_apollo.h"
     66          
     67          //
     68          // Look-up table
     69          //
     70          const g_am_hal_flash_t g_am_hal_flash =
     71          {
     72                   ((int  (*)(uint32_t, uint32_t)) 0x0800004d),                                  // flash_mass_erase
     73                   ((int  (*)(uint32_t, uint32_t, uint32_t))  0x08000051),                       // flash_page_erase
     74                   ((int  (*)(uint32_t, uint32_t *, uint32_t *, uint32_t))  0x08000055),         // flash_program_main
     75                   ((int  (*)(uint32_t, uint32_t, uint32_t *, uint32_t, uint32_t))  0x08000059), // flash_program_info_area
     76                   ((int  (*)(uint32_t, uint32_t)) 0x0800006d),                                  // flash_mass_erase_nb
     77                   ((int  (*)(uint32_t, uint32_t, uint32_t)) 0x08000071),                        // flash_page_erase_nb
     78                   ((int  (*)( uint32_t, uint32_t))  0x08000095),                                // flash_page_erase2_nb
     79                   ((bool (*)(void)) 0x0800007d),                                                // flash_nb_operation_complete
     80                   ((uint32_t (*)(uint32_t *)) 0x08000075),                                      // flash_util_read_word
     81                   ((void (*)( uint32_t *, uint32_t)) 0x08000079),                               // flash_util_write_word
     82                   ((void (*)(uint32_t ))            0x0800009D),                                // bootrom_delay_cycles
     83                   ((int  (*)( uint32_t, uint32_t))  0x08000081),                                // flash_info_erase
     84                   ((int  (*)( uint32_t, uint32_t))  0x08000089),                                // flash_info_plus_main_erase
     85                   ((int  (*)(uint32_t))             0x08000091),                                // flash_info_plus_main_erase_both
     86                   ((int  (*)( uint32_t ))           0x08000099),                                // flash_recovery
     87                   ((void (*)(void))  0x0800005d),                                               // flash_program_main_from_sram
     88                   ((void (*)(void))  0x08000061),                                               // flash_program_info_area_from_sram
     89                   ((void (*)(void))  0x08000065),                                               // flash_erase_main_pages_from_sram
     90                   ((void (*)(void))  0x08000069),                                               // flash_mass_erase_from_sram
     91                   ((void (*)(void))                 0x08000085),                                // flash_info_erase_from_sram
     92                   ((void (*)(void))                 0x0800008D),                                // flash_info_plus_main_erase_from_sram
     93                   ((void (*)(void))                 0x080000A1),                                // flash_nb_operation_complete_from_sram
     94                   ((void (*)(void))                 0x080000A5),                                // flash_page_erase2_nb_from_sram
     95                   ((void (*)(void))                 0x080000A9)                                 // flash_recovery_from_sram
     96          };
     97          
     98          const uint32_t ui32SramMaxAddr = 0x10060000;
     99          //*****************************************************************************
    100          //
    101          //! @brief This function performs a mass erase on a flash instance.
    102          //!
    103          //! @param ui32ProgramKey - The flash program key.
    104          //! @param ui32FlashInst - The flash instance to erase.
    105          //!
    106          //! This function will erase the desired instance of flash.
    107          //!
    108          //! @note For Apollo3, each flash instance contains a maximum of 512KB.
    109          //!
    110          //! @note Interrupts are active during execution of this function. Any interrupt
    111          //! taken could cause execution errors. Please see the IMPORTANT note under
    112          //! Detailed Description above for more details.
    113          //!
    114          //! @return 0 for success, non-zero for failure.
    115          //
    116          //*****************************************************************************
    117          int
    118          am_hal_flash_mass_erase(uint32_t ui32ProgramKey, uint32_t ui32FlashInst)
    119          {
    120              return g_am_hal_flash.flash_mass_erase(ui32ProgramKey, ui32FlashInst);
    121          } // am_hal_flash_mass_erase()
    122          
    123          //*****************************************************************************
    124          //
    125          //! @brief This function performs a page erase on a flash instance.
    126          //!
    127          //! @param ui32ProgramKey - The flash program key.
    128          //! @param ui32FlashInst - The flash instance to reference the page number with.
    129          //! @param ui32PageNum - The flash page relative to the specified instance.
    130          //!
    131          //! This function will erase the desired flash page in the desired instance of
    132          //! flash.
    133          //!
    134          //! @note For Apollo3, each flash page is 8KB (or AM_HAL_FLASH_PAGE_SIZE).
    135          //! Each flash instance contains a maximum of 64 pages (or
    136          //! AM_HAL_FLASH_INSTANCE_PAGES).
    137          //!
    138          //! @note When given an absolute flash address, a couple of helpful macros can
    139          //! be utilized when calling this function.
    140          //! For example:
    141          //!     am_hal_flash_page_erase(AM_HAL_FLASH_PROGRAM_KEY,
    142          //!                             AM_HAL_FLASH_ADDR2INST(ui32Addr),
    143          //!                             AM_HAL_FLASH_ADDR2PAGE(ui32Addr) );
    144          //!
    145          //! @note Interrupts are active during execution of this function. Any interrupt
    146          //! taken could cause execution errors. Please see the IMPORTANT note under
    147          //! Detailed Description above for more details.
    148          //!
    149          //! @return 0 for success, non-zero for failure.
    150          //
    151          //*****************************************************************************
    152          int
    153          am_hal_flash_page_erase(uint32_t ui32ProgramKey, uint32_t ui32FlashInst,
    154                                  uint32_t ui32PageNum)
    155          {
    156              return g_am_hal_flash.flash_page_erase(ui32ProgramKey,
    157                                                     ui32FlashInst,
    158                                                     ui32PageNum);
    159          } // am_hal_flash_page_erase()
    160          
    161          //*****************************************************************************
    162          //
    163          //! @brief This programs up to N words of the Main array on one flash instance.
    164          //!
    165          //! @param ui32ProgramKey - The programming key, AM_HAL_FLASH_PROGRAM_KEY.
    166          //! @param pui32Src - Pointer to word aligned array of data to program into
    167          //! the flash instance.
    168          //! @param pui32Dst - Pointer to the word aligned flash location where
    169          //! programming of the flash instance is to begin.
    170          //! @param ui32NumWords - The number of words to be programmed.
    171          //!
    172          //! This function will program multiple words in main flash.
    173          //!
    174          //! @note Interrupts are active during execution of this function. Any interrupt
    175          //! taken could cause execution errors. Please see the IMPORTANT note under
    176          //! Detailed Description above for more details.
    177          //!
    178          //! @return 0 for success, non-zero for failure.
    179          //
    180          //*****************************************************************************
    181          int
    182          am_hal_flash_program_main(uint32_t ui32ProgramKey, uint32_t *pui32Src,
    183                                    uint32_t *pui32Dst, uint32_t ui32NumWords)
    184          {
    185              uint32_t ui32MaxSrcAddr = (uint32_t)pui32Src + (ui32NumWords << 2);
    186          
    187              // workround, the last word of SRAM cannot be the source
    188              // of programming by BootRom, check to see if it is the last
    189              if (ui32MaxSrcAddr == ui32SramMaxAddr)
    190              {
    191                  uint32_t ui32Temp;
    192                  int iRetVal;
    193                  
    194                  // program the other words using the boot-rom function
    195                  if (ui32NumWords > 1) 
    196                  {
    197                      iRetVal = g_am_hal_flash.flash_program_main(
    198                                  ui32ProgramKey,
    199                                  pui32Src,
    200                                  pui32Dst,
    201                                  ui32NumWords - 1);
    202                      // return if anything wrong
    203                      if (iRetVal != 0)
    204                      {
    205                          return iRetVal;
    206                      }
    207                  }
    208                  // program the last word of the pSrc from a local 
    209                  // variable if it is the last word of SRAM
    210                  ui32Temp = *(uint32_t *)(ui32MaxSrcAddr - 4);
    211                  return g_am_hal_flash.flash_program_main(
    212                                  ui32ProgramKey, 
    213                                  &ui32Temp,
    214                                  pui32Dst + ui32NumWords - 1, 
    215                                  1);
    216              }
    217              return g_am_hal_flash.flash_program_main(ui32ProgramKey, pui32Src,
    218                                                       pui32Dst, ui32NumWords);
    219          } // am_hal_flash_program_main()
    220          
    221          
    222          //*****************************************************************************
    223          //
    224          //! @brief This clears the specified bits in the addressed flash word
    225          //!
    226          //! @param ui32ProgramKey - The programming key, AM_HAL_FLASH_PROGRAM_KEY.
    227          //! @param pui32Addr - Pointer to word aligned flash word to program into
    228          //! @param ui32BitMask - The bits to be cleared
    229          //!
    230          //! This function will clear one of more bits in a word in main flash.
    231          //! This function is mainly used when the same word is to be written multiple times
    232          //! few bits at a time, between erase cycle
    233          //!
    234          //! @note Interrupts are active during execution of this function. Any interrupt
    235          //! taken could cause execution errors. Please see the IMPORTANT note under
    236          //! Detailed Description above for more details.
    237          //!
    238          //! @note We can reprogram a bit in flash to 0 only once. This function takes
    239          //! care of not re-clearing bits if they are already programmed as 0
    240          //!
    241          //! @return 0 for success, non-zero for failure.
    242          //
    243          //*****************************************************************************
    244          int
    245          am_hal_flash_clear_bits(uint32_t ui32ProgramKey, uint32_t *pui32Addr,
    246                                  uint32_t ui32BitMask)
    247          {
    248              uint32_t ui32Val = ~ui32BitMask;
    249              // CAUTION: We can reprogram a bit in flash to 0 only once...so make sure we do not re-clear bits
    250              ui32Val |= ~(*pui32Addr);
    251          
    252              return g_am_hal_flash.flash_program_main(ui32ProgramKey, &ui32Val,
    253                                                       pui32Addr, 1);
    254          } // am_hal_flash_clear_bits()
    255          
    256          //*****************************************************************************
    257          //
    258          //! @brief This reprograms 1 word of the Main array on one flash instance.
    259          //!
    260          //! @param ui32ProgramKey - The programming key, AM_HAL_FLASH_PROGRAM_KEY.
    261          //! @param ui32Value - one word of data to program into the flash instance.
    262          //! @param pui32Dst - Pointer to the word aligned flash location where
    263          //! programming of the flash instance is to begin.
    264          //!
    265          //! This function will reprogram one word in main flash.
    266          //!
    267          //! @note Interrupts are active during execution of this function. Any interrupt
    268          //! taken could cause execution errors. Please see the IMPORTANT note under
    269          //! Detailed Description above for more details.
    270          //!
    271          //! @return 0 for success, non-zero for failure.
    272          //
    273          //*****************************************************************************
    274          int 
    275          am_hal_flash_reprogram_ui32(uint32_t ui32ProgramKey, 
    276                                      uint32_t ui32Data,
    277                                      uint32_t *pui32Dst)
    278          {
    279              int iRC = 0;
    280              
    281              if (ui32Data != *pui32Dst)
    282              {
    283                  // bits already set to 0 should not be rewritten to 0
    284                  ui32Data |= ~(*pui32Dst);
    285          
    286                  iRC = g_am_hal_flash.flash_program_main(
    287                          ui32ProgramKey,
    288                          &ui32Data,       // source data
    289                          pui32Dst,        // destination
    290                          1 );             // number of words
    291              } 
    292          
    293              return iRC;
    294          } // am_hal_flash_reprogram_ui32()
    295          
    296          //*****************************************************************************
    297          //
    298          //! @brief This function programs multiple words in the customer INFO space.
    299          //!
    300          //! @param ui32InfoKey - The customer INFO space key.
    301          //! @param ui32InfoInst - The INFO space instance, 0 or 1.
    302          //! @param *pui32Src - Pointer to word aligned array of data to program into
    303          //! the customer INFO space.
    304          //! @param ui32Offset - Word offset into customer INFO space (offset of 0 is
    305          //! the first word, 1 is second word, etc.).
    306          //! @param ui32NumWords - The number of words to be programmed, must not
    307          //! exceed AM_HAL_FLASH_INFO_SIZE/4.
    308          //!
    309          //! This function will program multiple words in the customer INFO space.
    310          //!
    311          //! @note Interrupts are active during execution of this function. Any interrupt
    312          //! taken could cause execution errors. Please see the IMPORTANT note under
    313          //! Detailed Description above for more details.
    314          //!
    315          //! @return 0 for success, non-zero for failure.
    316          //
    317          //*****************************************************************************
    318          int
    319          am_hal_flash_program_info(uint32_t ui32InfoKey, uint32_t ui32InfoInst,
    320                                    uint32_t *pui32Src, uint32_t ui32Offset,
    321                                    uint32_t ui32NumWords)
    322          {
    323              uint32_t ui32MaxSrcAddr = (uint32_t)pui32Src + (ui32NumWords << 2);
    324          
    325              // workround, the last word of SRAM cannot be the source
    326              // of programming by BootRom, check to see if it is the last
    327              if (ui32MaxSrcAddr == ui32SramMaxAddr)
    328              {
    329                  uint32_t ui32Temp;
    330                  int iRetVal;
    331                  
    332                  // program the other words using the boot-rom function
    333                  if (ui32NumWords > 1) 
    334                  {
    335                      iRetVal = g_am_hal_flash.flash_program_info_area(
    336                                  ui32InfoKey,
    337                                  ui32InfoInst,
    338                                  pui32Src,
    339                                  ui32Offset,
    340                                  ui32NumWords - 1);
    341                      // return if anything wrong
    342                      if (iRetVal != 0)
    343                      {
    344                          return iRetVal;
    345                      }
    346                  }
    347                  // program the last word of the pSrc from a local 
    348                  // variable if it is the last word of SRAM
    349                  ui32Temp = *(uint32_t *)(ui32MaxSrcAddr - 4);
    350                  return g_am_hal_flash.flash_program_info_area(
    351                                  ui32InfoKey,
    352                                  ui32InfoInst,
    353                                  &ui32Temp,
    354                                  ui32Offset + ui32NumWords - 1,
    355                                  1);
    356              }
    357              return g_am_hal_flash.flash_program_info_area(ui32InfoKey, ui32InfoInst, pui32Src,
    358                                                            ui32Offset, ui32NumWords);
    359          
    360          } // am_hal_flash_program_info()
    361          
    362          //*****************************************************************************
    363          //
    364          //! @brief This function reprograms one word in the customer INFO space.
    365          //!
    366          //! @param ui32InfoKey - The customer INFO space key.
    367          //! @param ui32InfoInst - The INFO space instance, 0 or 1.
    368          //! @param ui32Value - one word of data to program into the customer INFO.
    369          //! INFO space.
    370          //! @param ui32Offset - Word offset into customer INFO space (offset of 0 is
    371          //! the first word, 1 is second word, etc.).
    372          //!
    373          //! This function will program one word in the customer INFO space.
    374          //!
    375          //! @note Interrupts are active during execution of this function. Any interrupt
    376          //! taken could cause execution errors. Please see the IMPORTANT note under
    377          //! Detailed Description above for more details.
    378          //!
    379          //! @return 0 for success, non-zero for failure.
    380          //
    381          //*****************************************************************************
    382          int
    383          am_hal_flash_reprogram_info_ui32(uint32_t ui32InfoKey, uint32_t ui32InfoInst,
    384                                           uint32_t ui32Data, uint32_t ui32Offset)
    385          {
    386              int iRC = 0;
    387              uint32_t *pui32Dst = (uint32_t *)(AM_HAL_FLASH_INFO_ADDR + ui32Offset);
    388              
    389              if (ui32Data != *pui32Dst)
    390              {
    391                  // bits already set to 0 should not be rewritten to 0
    392                  ui32Data |= ~(*pui32Dst);
    393          
    394                  iRC = g_am_hal_flash.flash_program_info_area(
    395                          ui32InfoKey, ui32InfoInst, 
    396                          &ui32Data, ui32Offset, 1);
    397              } 
    398          
    399              return iRC;
    400              
    401          } // am_hal_flash_reprogram_info_ui32()
    402          
    403          //*****************************************************************************
    404          //
    405          //! @brief This function erases an instance of the customer INFO space.
    406          //!
    407          //! @param ui32InfoKey - The customer INFO space programming key
    408          //! (AM_HAL_FLASH_INFO_KEY).
    409          //! @param ui32Inst - The flash instance, either 0 or 1.
    410          //!
    411          //! This function will erase the the customer INFO space of the specified
    412          //! instance.
    413          //!
    414          //! @note Interrupts are active during execution of this function. Any interrupt
    415          //! taken could cause execution errors. Please see the IMPORTANT note under
    416          //! Detailed Description above for more details.
    417          //!
    418          //! @return 0 for success, non-zero for failure.
    419          //
    420          //*****************************************************************************
    421          int
    422          am_hal_flash_erase_info(uint32_t ui32InfoKey,
    423                                  uint32_t ui32Inst)
    424          {
    425              return g_am_hal_flash.flash_info_erase(ui32InfoKey, ui32Inst);
    426          } // am_hal_flash_erase_info()
    427          
    428          //*****************************************************************************
    429          //
    430          //! @brief This function erases the main instance + the customer INFO space.
    431          //!
    432          //! @param ui32InfoKey - The customer INFO space key.
    433          //! @param ui32Inst      - The flash instance, either 0 or 1.
    434          //!
    435          //! This function will erase the main flash + the customer INFO space of the
    436          //! specified instance.
    437          //!
    438          //! @note Interrupts are active during execution of this function. Any interrupt
    439          //! taken could cause execution errors. Please see the IMPORTANT note under
    440          //! Detailed Description above for more details.
    441          //!
    442          //! @return 0 for success, non-zero for failure.
    443          //
    444          //*****************************************************************************
    445          int
    446          am_hal_flash_erase_main_plus_info(uint32_t ui32InfoKey,
    447                                            uint32_t ui32Inst)
    448          {
    449              return g_am_hal_flash.flash_info_plus_main_erase(ui32InfoKey,
    450                                                               ui32Inst);
    451          } // am_hal_flash_erase_main_plus_info()
    452          
    453          //*****************************************************************************
    454          //
    455          //! @brief This function erases the main flash + the customer INFO space.
    456          //!
    457          //! @param ui32InfoKey - The customer INFO space key.
    458          //!
    459          //! This function will erase both instances the main flash + the
    460          //! customer INFO space.
    461          //!
    462          //! @note Interrupts are active during execution of this function. Any interrupt
    463          //! taken could cause execution errors. Please see the IMPORTANT note under
    464          //! Detailed Description above for more details.
    465          //!
    466          //! @return 0 for success, non-zero for failure.
    467          //
    468          //*****************************************************************************
    469          int
    470          am_hal_flash_erase_main_plus_info_both_instances(uint32_t ui32InfoKey)
    471          {
    472              return g_am_hal_flash.flash_info_plus_main_erase_both(ui32InfoKey);
    473          } // am_hal_flash_erase_main_plus_info_both_instances()
    474          
    475          //*****************************************************************************
    476          //
    477          //! @brief This function erases both main flash instances + both customer INFO
    478          //! space instances.
    479          //!
    480          //! @param ui32RecoveryKey - The recovery key.
    481          //!
    482          //! This function erases both main instances and both customer INFOinstances
    483          //! even if the customer INFO space is programmed to not be erasable. This
    484          //! function completely erases the flash main and info instances and wipes the
    485          //! SRAM. Upon completion of the erasure operations, it does a POI (power on
    486          //! initialization) reset.
    487          //!
    488          //! @note The customer key lock is enforced by this function.  Therefore, the
    489          //! customer key must be written prior to calling otherwise, the function will
    490          //! fail.  Therefore, always check for a return code.  If the function returns,
    491          //! a failure has occured.
    492          //!
    493          //! @note Interrupts are active during execution of this function. Any interrupt
    494          //! taken could cause execution errors. Please see the IMPORTANT note under
    495          //! Detailed Description above for more details.
    496          //!
    497          //! @return Does not return if successful.  Returns failure code otherwise.
    498          //
    499          //*****************************************************************************
    500          void
    501          am_hal_flash_recovery(uint32_t ui32RecoveryKey)
    502          {
    503              g_am_hal_flash.flash_recovery(ui32RecoveryKey);
    504          } // am_hal_flash_recovery()
    505          
    506          //*****************************************************************************
    507          //
    508          //! @brief Use the bootrom to implement a spin loop.
    509          //!
    510          //! @param ui32Iterations - Number of iterations to delay.  Must be >=1; the
    511          //! value of 0 will result in an extremely long delay.
    512          //!
    513          //! Use this function to implement a CPU busy waiting spin loop without cache
    514          //! or delay uncertainties.
    515          //!
    516          //! Notes for Apollo3:
    517          //! - The ROM-based function executes at 3 cycles per iteration plus the normal
    518          //!   function call, entry, and exit overhead and latencies.
    519          //! - Cache settings affect call overhead.  However, the cache does not affect
    520          //!   the time while inside the BOOTROM function.
    521          //! - Due to total call overhead, the minimum delay (i.e. when ui32Iterations
    522          //!   is 1) is approximately 2-3us when cache is enabled, and about 5.5us when
    523          //!   cache is disabled.  Above these times, delays become linear (next item).
    524          //! - Use of the FLASH_CYCLE_US() or FLASH_CYCLE_US_NOCACHE() macros for the
    525          //!   ui32Iteractions parameter will result in approximate microsecond timing
    526          //!   as long as the desired delay values are above the minimums above.
    527          //! - The delay time, even inside the BOOTROM function, IS affected by burst
    528          //!   mode enabled or not.
    529          //! - The value for ui32Iteractions must be 1 or greater.
    530          //!
    531          //! Example:
    532          //! - MCU operating at 48MHz -> 20.83 ns / cycle
    533          //! - Therefore each iteration (once inside the bootrom function) will consume
    534          //!   62.5ns (non-burst-mode).
    535          //!
    536          //! @note Interrupts are active during execution of this function.  Therefore,
    537          //! any interrupt taken will affect the delay timing.
    538          //!
    539          //! @return None.
    540          //
    541          //*****************************************************************************
    542          void
    543          am_hal_flash_delay(uint32_t ui32Iterations)
    544          {
    545              g_am_hal_flash.bootrom_delay_cycles(ui32Iterations);
    546          } // am_hal_flash_delay()
    547          
    548          //*****************************************************************************
    549          //
    550          //! @brief Delays for a desired amount of cycles while also waiting for a
    551          //! status to change a value.
    552          //!
    553          //! @param ui32usMaxDelay - Maximum number of ~1uS delay loops.
    554          //! @param ui32Address    - Address of the register for the status change.
    555          //! @param ui32Mask       - Mask for the status change.
    556          //! @param ui32Value      - Target value for the status change.
    557          //!
    558          //! This function will delay for approximately the given number of microseconds
    559          //! while checking for a status change, exiting when either the given time has
    560          //! expired or the status change is detected.
    561          //!
    562          //! @returns 0 = timeout.
    563          //!          1 = status change detected.
    564          //
    565          //*****************************************************************************
    566          uint32_t
    567          am_hal_flash_delay_status_change(uint32_t ui32usMaxDelay, uint32_t ui32Address,
    568                                           uint32_t ui32Mask, uint32_t ui32Value)
    569          {
    570              while ( 1 )
    571              {
    572                  //
    573                  // Check the status
    574                  //
    575                  if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    576                  {
    577                      return AM_HAL_STATUS_SUCCESS;
    578                  }
    579          
    580                  if (ui32usMaxDelay--)
    581                  {
    582                      //
    583                      // Call the BOOTROM cycle function to delay for about 1 microsecond.
    584                      //
    585                      am_hal_flash_delay( FLASH_CYCLES_US(1) );
    586                  }
    587                  else
    588                  {
    589                      break;
    590                  }
    591              }
    592          
    593              return AM_HAL_STATUS_TIMEOUT;
    594          
    595          } // am_hal_flash_delay_status_change()
    596          
    597          //*****************************************************************************
    598          //
    599          //! @brief Delays for a desired amount of cycles while also waiting for a
    600          //! status to equal OR not-equal to a value.
    601          //!
    602          //! @param ui32usMaxDelay - Maximum number of ~1uS delay loops.
    603          //! @param ui32Address    - Address of the register for the status change.
    604          //! @param ui32Mask       - Mask for the status change.
    605          //! @param ui32Value      - Target value for the status change.
    606          //! @param bIsEqual       - Check for equal if true; not-equal if false.
    607          //!
    608          //! This function will delay for approximately the given number of microseconds
    609          //! while checking for a status change, exiting when either the given time has
    610          //! expired or the status change is detected.
    611          //!
    612          //! @returns 0 = timeout.
    613          //!          1 = status change detected.
    614          //
    615          //*****************************************************************************
    616          uint32_t
    617          am_hal_flash_delay_status_check(uint32_t ui32usMaxDelay, uint32_t ui32Address,
    618                                          uint32_t ui32Mask, uint32_t ui32Value,
    619                                          bool bIsEqual)
    620          {
    621              while ( 1 )
    622              {
    623                  //
    624                  // Check the status
    625                  //
    626                  if ( bIsEqual )
    627                  {
    628                      if ( ( AM_REGVAL(ui32Address) & ui32Mask ) == ui32Value )
    629                      {
    630                          return AM_HAL_STATUS_SUCCESS;
    631                      }
    632                  }
    633                  else
    634                  {
    635                      if ( ( AM_REGVAL(ui32Address) & ui32Mask ) != ui32Value )
    636                      {
    637                          return AM_HAL_STATUS_SUCCESS;
    638                      }
    639                  }
    640          
    641                  if ( ui32usMaxDelay-- )
    642                  {
    643                      //
    644                      // Call the BOOTROM cycle function to delay for about 1 microsecond.
    645                      //
    646                      am_hal_flash_delay( FLASH_CYCLES_US(1) );
    647                  }
    648                  else
    649                  {
    650                      break;
    651                  }
    652              }
    653          
    654              return AM_HAL_STATUS_TIMEOUT;
    655          
    656          } // am_hal_flash_delay_status_check()
    657          
    658          //*****************************************************************************
    659          //
    660          //! @brief Static Helper Function to check customer info valid bits erasure.
    661          //!
    662          //! Use this function to test the state of the 128 valid bits at the beginning
    663          //! of customer info space. If these are all erased then return true.
    664          //!
    665          //! @return true if the customer info bits are currently erased.
    666          //
    667          //*****************************************************************************
    668          static bool
    669          customer_info_signature_erased(void)
    670          {
    671              uint32_t *pui32Signature = (uint32_t *) AM_HAL_FLASH_INFO_ADDR;
    672          
    673              return ( (pui32Signature[3] == 0xFFFFFFFF)  &&
    674                       (pui32Signature[2] == 0xFFFFFFFF)  &&
    675                       (pui32Signature[1] == 0xFFFFFFFF)  &&
    676                       (pui32Signature[0] == 0xFFFFFFFF) ) ? true : false;
    677          
    678          } // customer_info_signature_erased()
    679          
    680          //*****************************************************************************
    681          //
    682          //! @brief Static Helper Function to set customer info valid bits
    683          //!
    684          //! Use this function to set the state of the 128 valid bits at the beginning
    685          //! of customer info space. If these bits are not set correctly then the
    686          //! customer protection bits in the INFO space will not be honored by the
    687          //! hardware.
    688          //!
    689          //! @return Zero for success. Non-Zero for errors.
    690          //
    691          //*****************************************************************************
    692          static int
    693          customer_info_signature_set(uint32_t ui32InfoKey)
    694          {
    695              uint32_t ui32Valid[4];
    696              int iRC;
    697          
    698              //
    699              // If they are already set then we are done.
    700              //
    701              if ( am_hal_flash_customer_info_signature_check() )
    702              {
    703                  return 0;
    704              }
    705          
    706              //
    707              // If they are not erased at this point we have an error.
    708              //
    709              if ( !customer_info_signature_erased() )
    710              {
    711                  return (2 << 16);
    712              }
    713          
    714              //
    715              // OK they need to be set so do it.
    716              //
    717              ui32Valid[3] = AM_HAL_FLASH_INFO_SIGNATURE3;
    718              ui32Valid[2] = AM_HAL_FLASH_INFO_SIGNATURE2;
    719              ui32Valid[1] = AM_HAL_FLASH_INFO_SIGNATURE1;
    720              ui32Valid[0] = AM_HAL_FLASH_INFO_SIGNATURE0;
    721          
    722              iRC = g_am_hal_flash.flash_program_info_area(ui32InfoKey,
    723                                                      0,         // instance
    724                                                      ui32Valid, // source data
    725                                                      0,         // offset
    726                                                      4);        // number of words
    727              return iRC | ((iRC) ? (1 << 16) : 0);
    728          
    729          } // customer_info_signature_set()
    730          
    731          //*****************************************************************************
    732          //
    733          //! @brief Check that the customer info bits are valid.
    734          //!
    735          //! Use this function to test the state of the 128 valid bits at the beginning
    736          //! of customer info space. If these are not set correctly then the customer
    737          //! protection bits in the INFO space will not be honored by the hardware.
    738          //!
    739          //! @return true if valid.
    740          //
    741          //*****************************************************************************
    742          bool
    743          am_hal_flash_customer_info_signature_check(void)
    744          {
    745              uint32_t *pui32Signature = (uint32_t *)AM_HAL_FLASH_INFO_ADDR;
    746          
    747              return ( (pui32Signature[3] == AM_HAL_FLASH_INFO_SIGNATURE3)    &&
    748                       (pui32Signature[2] == AM_HAL_FLASH_INFO_SIGNATURE2)    &&
    749                       (pui32Signature[1] == AM_HAL_FLASH_INFO_SIGNATURE1)    &&
    750                       (pui32Signature[0] == AM_HAL_FLASH_INFO_SIGNATURE0) );
    751          
    752          } // am_hal_flash_customer_info_signature_check()
    753          
    754          //*****************************************************************************
    755          //
    756          //! @brief INFO signature set.
    757          //!
    758          //! @param ui32InfoKey - The customer INFO space programming key
    759          //!
    760          //! Use this function to set the state of the 128 valid bits at the beginning
    761          //! of customer info space, if needed.
    762          //!
    763          //! @note Interrupts are active during execution of this function. Any interrupt
    764          //! taken could cause execution errors. Please see the IMPORTANT note under
    765          //! Detailed Description above for more details.
    766          //!
    767          //! @return Zero for success. Non-Zero for errors.
    768          //
    769          //*****************************************************************************
    770          bool
    771          am_hal_flash_info_signature_set(uint32_t ui32InfoKey)
    772          {
    773              //
    774              // Check and set signature.
    775              //
    776              return customer_info_signature_set(ui32InfoKey) ? false : true;
    777          
    778          } // am_hal_flash_info_signature_set()
    779          
    780          //*****************************************************************************
    781          //
    782          //! @brief Disable FLASH INFO space.
    783          //!
    784          //! @param ui32InfoKey - The customer INFO space programming key
    785          //!
    786          //! Use this function to set the state of the 128 valid bits at the beginning
    787          //! of customer info space, if needed. Then disable FLASH erasure.
    788          //!
    789          //! @note Interrupts are active during execution of this function. Any interrupt
    790          //! taken could cause execution errors. Please see the IMPORTANT note under
    791          //! Detailed Description above for more details.
    792          //!
    793          //! @return Zero for success. Non-Zero for errors.
    794          //
    795          //*****************************************************************************
    796          int32_t
    797          am_hal_flash_info_erase_disable(uint32_t ui32InfoKey)
    798          {
    799              int iRC;
    800              uint32_t ui32SecurityValue;
    801          
    802              //
    803              // Security protection only works if the signature data is correct.
    804              //
    805              iRC = customer_info_signature_set(ui32InfoKey);
    806              if ( iRC )
    807              {
    808                  return iRC;
    809              }
    810          
    811              //
    812              // Clear bit in INFO space to disable erasure.
    813              //
    814              ui32SecurityValue = AM_REGVAL(AM_HAL_FLASH_INFO_SECURITY_ADDR)  &
    815                                  ~AM_HAL_FLASH_INFO_SECURITY_ENINFOERASE_M;
    816          
    817              //
    818              // Now write the word to the flash INFO space.
    819              //
    820              return g_am_hal_flash.flash_program_info_area(
    821                      ui32InfoKey,
    822                      0,                                  // instance
    823                      &ui32SecurityValue,                 // source data
    824                      AM_HAL_FLASH_INFO_SECURITY_O / 4,   // word offset
    825                      1 );                                // number of words
    826          
    827          } // am_hal_flash_info_erase_disable()
    828          
    829          //*****************************************************************************
    830          //
    831          //! @brief Check for Disabled FLASH INFO space.
    832          //!
    833          //! Use this function to determine whether FLASH INFO erasure is disabled.
    834          //!
    835          //! @return true if FLASH INFO erase is disabled, otherwise false.
    836          //
    837          //*****************************************************************************
    838          bool
    839          am_hal_flash_info_erase_disable_check(void)
    840          {
    841              //
    842              // If they are erased at this point then SRAM wipe can't be enabled.
    843              //
    844              if ( customer_info_signature_erased() )
    845              {
    846                  return false;
    847              }
    848          
    849              //
    850              // If they are not valid at this point then SRAM wipe can't be enabled.
    851              //
    852              if ( !am_hal_flash_customer_info_signature_check() )
    853              {
    854                  return false;
    855              }
    856          
    857              //
    858              // Looking good so far, now check the SRAM WIPE bit.
    859              //
    860              return AM_REGVAL(AM_HAL_FLASH_INFO_SECURITY_ADDR)   &
    861                               AM_HAL_FLASH_INFO_SECURITY_ENINFOERASE_M  ? false : true;
    862          
    863          } // am_hal_flash_info_erase_disable_check()
    864          
    865          //*****************************************************************************
    866          //
    867          //! @brief Mask off 1 to 4 quadrants of FLASH INFO space for programming.
    868          //!
    869          //! Use this function to set the state of the 128 valid bits at the beginning
    870          //! of customer info space, if needed. Then and the mask bits with the INFO
    871          //! space programming disable bits.
    872          //!
    873          //! @param ui32InfoKey - The customer INFO space programming key
    874          //!
    875          //! @param ui32Mask - A mask of the 4 quadrants of info space where
    876          //!                   bit0 = First quadrant (first 2KB).
    877          //!                   bit1 = Second quadrant (second 2KB).
    878          //!                   bit2 = Third quadrant (third 2KB).
    879          //!                   bit3 = Fourth quadrant (fourth 2KB).
    880          //!
    881          //! @note This function disables only, any quadrant already disabled is not
    882          //! reenabled.  That is, any ui32Mask bits specified as 0 are essentially nops.
    883          //!
    884          //! @note Interrupts are active during execution of this function. Any interrupt
    885          //! taken could cause execution errors. Please see the IMPORTANT note under
    886          //! Detailed Description above for more details.
    887          //!
    888          //! @return Zero for success. Non-Zero for errors.
    889          //
    890          //*****************************************************************************
    891          int32_t
    892          am_hal_flash_info_program_disable(uint32_t ui32InfoKey, uint32_t ui32Mask)
    893          {
    894              int iRC;
    895              uint32_t ui32SecurityValue;
    896          
    897              //
    898              // Security protection only works if the signature data is correct.
    899              //
    900              iRC = customer_info_signature_set(ui32InfoKey);
    901              if ( iRC )
    902              {
    903                  return iRC;
    904              }
    905          
    906              //
    907              // Make sure we have a valid mask and get the mask into the correct position.
    908              //
    909              ui32Mask <<= AM_HAL_FLASH_INFO_SECURITY_ENINFOPRGM_S;
    910              ui32Mask &= AM_HAL_FLASH_INFO_SECURITY_ENINFOPRGM_M;
    911          
    912              //
    913              // The security bit set to 1 enables programming, 0 disables programming.
    914              //
    915              ui32SecurityValue = AM_REGVAL(AM_HAL_FLASH_INFO_SECURITY_ADDR) & ~ui32Mask;
    916          
    917              //
    918              // Now write the word to the flash INFO space.
    919              //
    920              return g_am_hal_flash.flash_program_info_area(
    921                      ui32InfoKey,
    922                      0,                                  // instance
    923                      &ui32SecurityValue,                 // source data
    924                      AM_HAL_FLASH_INFO_SECURITY_O / 4,   // word offset
    925                      1 );                                // number of words
    926          
    927          } // am_hal_flash_info_program_disable()
    928          
    929          //*****************************************************************************
    930          //
    931          //! @brief Return a mask specifying which quadrants of customer INFO space have
    932          //! been disabled for programming.
    933          //!
    934          //! Use this function to determine whether programming of customer INFO space
    935          //! has been disabled.
    936          //!
    937          //! @return A 4-bit mask of the disabled quadrants.
    938          //! 0xFFFFFFFF indicates an error.
    939          //! 0x0  indicates all customer INFO space programming is enabled.
    940          //! 0xF  indicates all customer INFO space programming is disabled.
    941          //! bit0 indicates the first customer INFO space is disabled for programming.
    942          //! bit1 indicates the second customer INFO space is disabled for programming.
    943          //! bit2 indicates the third customer INFO space is disabled for programming.
    944          //! bit3 indicates the fourth customer INFO space is disabled for programming.
    945          //
    946          //*****************************************************************************
    947          uint32_t
    948          am_hal_flash_info_program_disable_get(void)
    949          {
    950              //
    951              // If they are erased at this point then SRAM wipe can't be enabled.
    952              //
    953              if ( customer_info_signature_erased() )
    954              {
    955                  return 0xFFFFFFFF;
    956              }
    957          
    958              //
    959              // If not valid at this point, then INFO programming can't be enabled.
    960              //
    961              if ( !am_hal_flash_customer_info_signature_check() )
    962              {
    963                  return 0xFFFFFFFF;
    964              }
    965          
    966              //
    967              // Looking good so far, now return a mask of the disabled bits.
    968              //
    969              return  ((AM_REGVAL(AM_HAL_FLASH_INFO_SECURITY_ADDR) &
    970                          AM_HAL_FLASH_INFO_SECURITY_ENINFOPRGM_M) ^
    971                          AM_HAL_FLASH_INFO_SECURITY_ENINFOPRGM_M) >>
    972                          AM_HAL_FLASH_INFO_SECURITY_ENINFOPRGM_S;
    973          
    974          } // am_hal_flash_info_program_disable_get()
    975          
    976          //*****************************************************************************
    977          //
    978          //! @brief Enable FLASH debugger protection (FLASH gets wiped if a debugger is
    979          //! connected).
    980          //!
    981          //! @param ui32InfoKey - The customer INFO space programming key
    982          //!
    983          //! Use this function to set the state of the 128 valid bits at the beginning
    984          //! of customer info space, if needed. Then set the FLASH wipe bit to zero.
    985          //!
    986          //! @note Interrupts are active during execution of this function. Any interrupt
    987          //! taken could cause execution errors. Please see the IMPORTANT note under
    988          //! Detailed Description above for more details.
    989          //!
    990          //! @return Zero for success. Non-Zero for errors.
    991          //
    992          //*****************************************************************************
    993          int32_t
    994          am_hal_flash_wipe_flash_enable(uint32_t ui32InfoKey)
    995          {
    996              int iRC;
    997              uint32_t ui32SecurityValue;
    998          
    999              //
   1000              // Security protection only works if the signature data is correct.
   1001              //
   1002              iRC = customer_info_signature_set(ui32InfoKey);
   1003              if ( iRC )
   1004              {
   1005                  return iRC;
   1006              }
   1007          
   1008              //
   1009              // Clear the FLASH Wipe bit.
   1010              //
   1011              ui32SecurityValue = AM_REGVAL(AM_HAL_FLASH_INFO_SECURITY_ADDR) &
   1012                                  ~AM_HAL_FLASH_INFO_SECURITY_FLASHWIPE_M;
   1013          
   1014              //
   1015              // Now write the word to the flash INFO space.
   1016              //
   1017              return g_am_hal_flash.flash_program_info_area(
   1018                      ui32InfoKey,
   1019                      0,                                  // instance
   1020                      &ui32SecurityValue,                 // source data
   1021                      AM_HAL_FLASH_INFO_SECURITY_O / 4,   // word offset
   1022                      1 );                                // number of words
   1023          
   1024          } // am_hal_flash_wipe_flash_enable()
   1025          
   1026          //*****************************************************************************
   1027          //
   1028          //! @brief check for FLASH wipe protection enabled.
   1029          //!
   1030          //! Use this function to determine if FLASH wipe protection is enabled.
   1031          //!
   1032          //! @return true if FLASH wipe protection is enabled, otherwise false.
   1033          //
   1034          //*****************************************************************************
   1035          bool
   1036          am_hal_flash_wipe_flash_enable_check(void)
   1037          {
   1038              //
   1039              // If they are erased at this point then flash wipe can't be enabled.
   1040              //
   1041              if ( customer_info_signature_erased() )
   1042              {
   1043                  return false;
   1044              }
   1045          
   1046              //
   1047              // If they are not valid at this point then flash wipe can't be enabled.
   1048              //
   1049              if ( !am_hal_flash_customer_info_signature_check() )
   1050              {
   1051                  return false;
   1052              }
   1053          
   1054              //
   1055              // Looking good so far, now check the Flash WIPE bit.
   1056              //
   1057              return AM_REGVAL(AM_HAL_FLASH_INFO_SECURITY_ADDR) &
   1058                               AM_HAL_FLASH_INFO_SECURITY_FLASHWIPE_M ? false : true;
   1059          
   1060          } // am_hal_flash_wipe_flash_enable_check()
   1061          
   1062          //*****************************************************************************
   1063          //
   1064          //! @brief Enable SRAM protection so SRAM gets wiped if a debgger is connected.
   1065          //!
   1066          //! @param ui32InfoKey - The customer INFO space programming key
   1067          //!
   1068          //! Use this function to set the state of the 128 valid bits at the beginning
   1069          //! of customer info space, if needed. Then set the SRAM wipe bit to zero.
   1070          //!
   1071          //! @note Interrupts are active during execution of this function. Any interrupt
   1072          //! taken could cause execution errors. Please see the IMPORTANT note under
   1073          //! Detailed Description above for more details.
   1074          //!
   1075          //! @return Zero for success. Non-Zero for errors.
   1076          //
   1077          //*****************************************************************************
   1078          int32_t
   1079          am_hal_flash_wipe_sram_enable(uint32_t ui32InfoKey)
   1080          {
   1081              int iRC;
   1082              uint32_t ui32SecurityValue;
   1083          
   1084              //
   1085              // Security protection only works if the signature data is correct.
   1086              //
   1087              iRC = customer_info_signature_set(ui32InfoKey);
   1088              if ( iRC )
   1089              {
   1090                  return iRC;
   1091              }
   1092          
   1093              //
   1094              // Clear the SRAM Wipe bit.
   1095              //
   1096              ui32SecurityValue = AM_REGVAL(AM_HAL_FLASH_INFO_SECURITY_ADDR) &
   1097                                  ~AM_HAL_FLASH_INFO_SECURITY_SRAMWIPE_M;
   1098          
   1099              //
   1100              // Now write the word to the flash INFO space.
   1101              //
   1102              return g_am_hal_flash.flash_program_info_area(
   1103                      ui32InfoKey,
   1104                      0,                                  // instance
   1105                      &ui32SecurityValue,                 // source data
   1106                      AM_HAL_FLASH_INFO_SECURITY_O / 4,   // word offset
   1107                      1 );                                // number of words
   1108          
   1109          } // am_hal_flash_wipe_sram_enable()
   1110          
   1111          //*****************************************************************************
   1112          //
   1113          //! @brief check for SRAM protection enabled.
   1114          //!
   1115          //! Use this function to determine if SRAM protection is enabled.
   1116          //!
   1117          //! @return true if SRAM wipe protection is enabled, otherwise false.
   1118          //
   1119          //*****************************************************************************
   1120          bool
   1121          am_hal_flash_wipe_sram_enable_check(void)
   1122          {
   1123              //
   1124              // If they are erased at this point then SRAM wipe can't be enabled.
   1125              //
   1126              if ( customer_info_signature_erased() )
   1127              {
   1128                  return false;
   1129              }
   1130          
   1131              //
   1132              // If they are not vale at this point then SRAM wipe can't be enabled.
   1133              //
   1134              if ( !am_hal_flash_customer_info_signature_check() )
   1135              {
   1136                  return false;
   1137              }
   1138          
   1139              //
   1140              // Looking good so far, now check the SRAM WIPE bit.
   1141              //
   1142              return AM_REGVAL(AM_HAL_FLASH_INFO_SECURITY_ADDR) &
   1143                               AM_HAL_FLASH_INFO_SECURITY_SRAMWIPE_M ? false : true;
   1144          
   1145          } // am_hal_flash_wipe_sram_enable_check()
   1146          
   1147          //*****************************************************************************
   1148          //
   1149          //! @brief Disable Output from ITM/SWO.
   1150          //!
   1151          //! @param ui32InfoKey - The customer INFO space programming key
   1152          //!
   1153          //! Use this function to set the state of the 128 valid bits at the beginning
   1154          //! of customer info space, if needed. Set the SWO disable bit to zero.
   1155          //!
   1156          //! @note Interrupts are active during execution of this function. Any interrupt
   1157          //! taken could cause execution errors. Please see the IMPORTANT note under
   1158          //! Detailed Description above for more details.
   1159          //!
   1160          //! @return Zero for success. Non-Zero for errors.
   1161          //
   1162          //*****************************************************************************
   1163          int32_t
   1164          am_hal_flash_swo_disable(uint32_t ui32InfoKey)
   1165          {
   1166              int iRC;
   1167              uint32_t ui32SecurityValue;
   1168          
   1169              //
   1170              // Security protection only works if the signature data is correct.
   1171              //
   1172              iRC = customer_info_signature_set(ui32InfoKey);
   1173              if ( iRC )
   1174              {
   1175                  return iRC;
   1176              }
   1177          
   1178              //
   1179              // Clear the SWO bit.
   1180              //
   1181              ui32SecurityValue = AM_REGVAL(AM_HAL_FLASH_INFO_SECURITY_ADDR) &
   1182                                  ~AM_HAL_FLASH_INFO_SECURITY_SWOCTRL_M;
   1183          
   1184              //
   1185              // Now write the word to the flash INFO space.
   1186              //
   1187              return g_am_hal_flash.flash_program_info_area(
   1188                      ui32InfoKey,
   1189                      0,                                  // instance
   1190                      &ui32SecurityValue,                 // source data
   1191                      AM_HAL_FLASH_INFO_SECURITY_O / 4,   // word offset
   1192                      1 );                                // number of words
   1193          
   1194          } // am_hal_flash_swo_disable()
   1195          
   1196          //*****************************************************************************
   1197          //
   1198          //! @brief check for SWO disabled.
   1199          //!
   1200          //! Use this function to determine if the SWO is disabled.
   1201          //!
   1202          //! @return true if the ITM/SWO is disabled, otherwise false.
   1203          //
   1204          //*****************************************************************************
   1205          bool
   1206          am_hal_flash_swo_disable_check(void)
   1207          {
   1208              //
   1209              // If they are erased at this point then SRAM wipe can't be enabled.
   1210              //
   1211              if ( customer_info_signature_erased() )
   1212              {
   1213                  return false;
   1214              }
   1215          
   1216              //
   1217              // If they are not vale at this point then SRAM wipe can't be enabled.
   1218              //
   1219              if ( !am_hal_flash_customer_info_signature_check() )
   1220              {
   1221                  return false;
   1222              }
   1223          
   1224              //
   1225              // Looking good so far, now check the SWO bit.
   1226              //
   1227              return AM_REGVAL(AM_HAL_FLASH_INFO_SECURITY_ADDR) &
   1228                      AM_HAL_FLASH_INFO_SECURITY_SWOCTRL_M ? false : true;
   1229          
   1230          } // am_hal_flash_swo_disable_check()
   1231          
   1232          //*****************************************************************************
   1233          //
   1234          //! @brief Disable Connections from a debugger on the SWD interface.
   1235          //!
   1236          //! @param ui32InfoKey - The customer INFO space programming key
   1237          //!
   1238          //! Use this function to set the state of the 128 valid bits at the beginning
   1239          //! of customer info space, if needed. Set the debugger disable bit to zero.
   1240          //!
   1241          //! @note Interrupts are active during execution of this function. Any interrupt
   1242          //! taken could cause execution errors. Please see the IMPORTANT note under
   1243          //! Detailed Description above for more details.
   1244          //!
   1245          //! @return Zero for success. Non-Zero for errors.
   1246          //
   1247          //*****************************************************************************
   1248          int32_t
   1249          am_hal_flash_debugger_disable(uint32_t ui32InfoKey)
   1250          {
   1251              int iRC;
   1252              uint32_t ui32SecurityValue;
   1253          
   1254              //
   1255              // Security protection only works if the signature data is correct.
   1256              //
   1257              iRC = customer_info_signature_set(ui32InfoKey);
   1258              if ( iRC )
   1259              {
   1260                  return iRC;
   1261              }
   1262          
   1263              //
   1264              // Clear the DEBUGGER bit.
   1265              //
   1266              ui32SecurityValue = AM_REGVAL(AM_HAL_FLASH_INFO_SECURITY_ADDR) &
   1267                                  ~AM_HAL_FLASH_INFO_SECURITY_DEBUGGERPROT_M;
   1268          
   1269              //
   1270              // Now write the word to the flash INFO space.
   1271              //
   1272              return g_am_hal_flash.flash_program_info_area(
   1273                      ui32InfoKey,
   1274                      0,                                  // instance
   1275                      &ui32SecurityValue,                 // source data
   1276                      AM_HAL_FLASH_INFO_SECURITY_O / 4,   // word offset
   1277                      1 );                                // number of words
   1278          
   1279          } // am_hal_flash_debugger_disable()
   1280          
   1281          //*****************************************************************************
   1282          //
   1283          //! @brief check for debugger disabled.
   1284          //!
   1285          //! Use this function to determine if the debugger is disabled.
   1286          //!
   1287          //! @return true if the debugger is disabled, otherwise false.
   1288          //
   1289          //*****************************************************************************
   1290          bool
   1291          am_hal_flash_debugger_disable_check(void)
   1292          {
   1293              //
   1294              // If they are erased at this point then SRAM wipe can't be enabled.
   1295              //
   1296              if ( customer_info_signature_erased() )
   1297              {
   1298                  return false;
   1299              }
   1300          
   1301              //
   1302              // If they are not vale at this point then SRAM wipe can't be enabled.
   1303              //
   1304              if ( !am_hal_flash_customer_info_signature_check() )
   1305              {
   1306                  return false;
   1307              }
   1308          
   1309              //
   1310              // Looking good so far, now check the debugger disable bit.
   1311              //
   1312              return AM_REGVAL(AM_HAL_FLASH_INFO_SECURITY_ADDR) &
   1313                               AM_HAL_FLASH_INFO_SECURITY_DEBUGGERPROT_M ? false : true;
   1314          
   1315          } // am_hal_flash_debugger_disable_check()
   1316          
   1317          //*****************************************************************************
   1318          //
   1319          //! @brief This static helper function generates a 64-bit protection mask.
   1320          //!
   1321          //! @param pui32StartAddress - Starting address in flash to begin protection.
   1322          //! @param pui32StopAddress  - Ending address in flash to stop protection.
   1323          //!
   1324          //! This function computes a chunk map for the protection range.
   1325          //!
   1326          //! @return Inverse of the actual chunk mask.  That is, chunks to be protected
   1327          //! are represented as 0 in the returned mask, while chunks to be left alone
   1328          //! are represented as 1.  This value can therefore be directly ANDed with the
   1329          //! existing bits in INFO space.
   1330          //! Note that -1 is returned if input parameters are invalid - this return
   1331          //! value would indicate that no chunks are to be protected.
   1332          //!
   1333          //
   1334          //*****************************************************************************
   1335          static uint64_t
   1336          generate_chunk_mask(uint32_t *pui32StartAddress, uint32_t *pui32StopAddress)
   1337          {
   1338              uint32_t ui32ChunkStart, ui32ChunkStop;
   1339              uint32_t ui32Width;
   1340              uint64_t ui64Mask;
   1341          
   1342              //
   1343              // Validate the address input parameters
   1344              //
   1345              if ( (pui32StartAddress > pui32StopAddress)  ||
   1346                   (pui32StopAddress > (uint32_t*)AM_HAL_FLASH_LARGEST_VALID_ADDR) )
   1347              {
   1348                  //
   1349                  // Argument error, return value to leave all chunks unprotected.
   1350                  //
   1351                  return 0xFFFFFFFFFFFFFFFF;
   1352              }
   1353          
   1354              //
   1355              // Extract chunk related information
   1356              //
   1357              ui32ChunkStart = AM_HAL_FLASH_INFO_ADDR2CHUNK((uint32_t)pui32StartAddress);
   1358              ui32ChunkStop  = AM_HAL_FLASH_INFO_ADDR2CHUNK((uint32_t)pui32StopAddress);
   1359              ui32Width = ui32ChunkStop - ui32ChunkStart + 1;
   1360          
   1361              if ( ui32Width == 64 )
   1362              {
   1363                  ui64Mask = (uint64_t)0xFFFFFFFFFFFFFFFFLLU;
   1364              }
   1365              else
   1366              {
   1367                  ui64Mask = ( ((uint64_t)0x0000000000000001) << ui32Width) - 1;
   1368                  ui64Mask <<= ui32ChunkStart;
   1369              }
   1370          
   1371              //
   1372              // OK now return the chunk mask (inverted).
   1373              //
   1374              return ~ui64Mask;
   1375          
   1376          } // generate_chunk_mask()
   1377          
   1378          //*****************************************************************************
   1379          //
   1380          //! @brief This function sets copy protection for a range of flash chunks.
   1381          //!
   1382          //! @param ui32InfoKey - The customer INFO space programming key
   1383          //! @param pui32StartAddress - Starting address in flash to begin protection.
   1384          //! @param pui32StopAddress - Ending address in flash to stop protection.
   1385          //!
   1386          //! This function will set copy protection bits for a range of flash chunks
   1387          //!
   1388          //! @note Each flash chunk contains 16KBytes and corresponds to one bit in
   1389          //! the protection register. Set the bit to zero to enable protection.
   1390          //!
   1391          //! @note Interrupts are active during execution of this function. Any interrupt
   1392          //! taken could cause execution errors. Please see the IMPORTANT note under
   1393          //! Detailed Description above for more details.
   1394          //!
   1395          //! @return
   1396          //!     0 for success.
   1397          //!     0x400000 if the protection bits were already programmed (mask the return
   1398          //!              value with 0x3FFFFF to ignore this case and treat as success).
   1399          //!     Otherwise, non-zero for failure.
   1400          //
   1401          //*****************************************************************************
   1402          int32_t
   1403          am_hal_flash_copy_protect_set(uint32_t ui32InfoKey,
   1404                                        uint32_t *pui32StartAddress,
   1405                                        uint32_t *pui32StopAddress)
   1406          {
   1407              int iRC;
   1408              bool bModified = false;
   1409              uint64_t ui64Mask;
   1410              uint32_t ui32Work;
   1411              uint32_t ui32Protection[2];
   1412              uint32_t *pui32Protection = (uint32_t *)AM_HAL_FLASH_INFO_COPYPROT_ADDR;
   1413          
   1414              //
   1415              // Extract chunk mask from parameters.
   1416              // Also checks parameter validity (returns -1 if bad parameters).
   1417              //
   1418              ui64Mask = generate_chunk_mask(pui32StartAddress, pui32StopAddress);
   1419              if ( ~ui64Mask == 0x0 )
   1420              {
   1421                  return 0x100000;
   1422              }
   1423          
   1424              //
   1425              // Go get the current settings for copy protection.
   1426              //
   1427              ui32Protection[0] = pui32Protection[0];
   1428              ui32Protection[1] = pui32Protection[1];
   1429          
   1430              //
   1431              // AND mask off the necessary protection bits in the lower word.
   1432              //
   1433              ui32Work = (uint32_t)ui64Mask;
   1434              if ( ( ~ui32Work )  &&  ( ui32Work != ui32Protection[0] ) )
   1435              {
   1436                  bModified = true;
   1437                  // Need to change only the bits changing - bits already set to 0 should not be rewritten to 0
   1438                  // Flash has limits on number of times a bit can be set to 0
   1439                  ui32Protection[0] = ui32Work | ~ui32Protection[0];
   1440                  iRC = g_am_hal_flash.flash_program_info_area(
   1441                          ui32InfoKey,
   1442                          0,                                      // instance
   1443                          &ui32Protection[0],                     // source data
   1444                          (AM_HAL_FLASH_INFO_COPYPROT_O / 4) + 0, // word offset
   1445                          1 );                                    // number of words
   1446          
   1447                  if ( iRC )
   1448                  {
   1449                      return iRC | 0x10000;
   1450                  }
   1451              }
   1452          
   1453              //
   1454              // AND mask off the necessary protection bits in the upper word.
   1455              //
   1456              ui32Work = (uint32_t)(ui64Mask >> 32);
   1457              if ( ( ~ui32Work )  &&  ( ui32Work != ui32Protection[1] ) )
   1458              {
   1459                  bModified = true;
   1460                  // Need to change only the bits changing - bits already set to 0 should not be rewritten to 0
   1461                  // Flash has limits on number of times a bit can be set to 0
   1462                  ui32Protection[1] = ui32Work | ~ui32Protection[1];
   1463                  iRC = g_am_hal_flash.flash_program_info_area(
   1464                          ui32InfoKey,
   1465                          0,                                      // instance
   1466                          &ui32Protection[1],                     // source data
   1467                          (AM_HAL_FLASH_INFO_COPYPROT_O / 4) + 1, // word offset
   1468                          1 );                                    // number of words
   1469          
   1470                  if ( iRC )
   1471                  {
   1472                      return iRC | 0x20000;
   1473                  }
   1474              }
   1475          
   1476              if ( bModified )
   1477              {
   1478                  return 0;
   1479              }
   1480              else
   1481              {
   1482                  return 0x400000;
   1483              }
   1484          
   1485          } // am_hal_flash_copy_protect_set()
   1486          
   1487          //*****************************************************************************
   1488          //
   1489          //! @brief This function checks copy protection for a range of flash chunks.
   1490          //!
   1491          //! @param pui32StartAddress - Starting address in flash.
   1492          //! @param pui32StopAddress - Ending address in flash.
   1493          //!
   1494          //! This function will check copy protection bits for a range of flash chunks
   1495          //! it expects all chunks in the range to be protected.
   1496          //!
   1497          //! @note Each flash chunk contains 16KBytes and corresponds to one bit in
   1498          //! the protection register. Set the bit to zero to enable protection.
   1499          //!
   1500          //! @return false for at least one chunk in the covered range is not protected,
   1501          //!         and true if all chunks in the covered range are protected.
   1502          //!
   1503          //
   1504          //*****************************************************************************
   1505          bool
   1506          am_hal_flash_copy_protect_check(uint32_t *pui32StartAddress,
   1507                                          uint32_t *pui32StopAddress)
   1508          {
   1509              uint64_t ui64Mask;
   1510              uint32_t ui32Work;
   1511              uint32_t *pui32Protection = (uint32_t *)AM_HAL_FLASH_INFO_COPYPROT_ADDR;
   1512          
   1513              //
   1514              // Extract chunk mask from parameters.
   1515              // Also checks parameter validity (returns -1 if bad parameters).
   1516              //
   1517              ui64Mask = generate_chunk_mask(pui32StartAddress, pui32StopAddress);
   1518              if ( ~ui64Mask == 0x0 )
   1519              {
   1520                  return false;
   1521              }
   1522          
   1523              //
   1524              // Now check the lower word of protection bits.
   1525              //
   1526              ui32Work = (uint32_t)ui64Mask;
   1527              if ( ~ui32Work  &  pui32Protection[0] )
   1528              {
   1529                  return false;
   1530              }
   1531          
   1532              //
   1533              // Now check the lower word of protection bits.
   1534              //
   1535              ui32Work = (uint32_t)(ui64Mask >> 32);
   1536              if ( ~ui32Work & pui32Protection[1] )
   1537              {
   1538                  return false;
   1539              }
   1540          
   1541              //
   1542              // If we get here, there are no unprotected chunks within specified range.
   1543              //
   1544              return true;
   1545          
   1546          } // am_hal_flash_copy_protect_check()
   1547          
   1548          //*****************************************************************************
   1549          //
   1550          //! @brief This function sets write protection for a range of flash chunks.
   1551          //!
   1552          //! @param ui32InfoKey - The customer INFO space programming key
   1553          //! @param pui32StartAddress - Starting address in flash to begin protection.
   1554          //! @param pui32StopAddress - Ending address in flash to stop protection.
   1555          //!
   1556          //! This function will set write protection bits for a range of flash chunks
   1557          //!
   1558          //! @note Each flash chunk contains 16KBytes and corresponds to one bit in
   1559          //! the protection register. Set the bit to zero to enable protection.
   1560          //!
   1561          //! @note Interrupts are active during execution of this function. Any interrupt
   1562          //! taken could cause execution errors. Please see the IMPORTANT note under
   1563          //! Detailed Description above for more details.
   1564          //!
   1565          //! @return
   1566          //!     0 for success.
   1567          //!     0x400000 if the protection bits were already programmed (mask the return
   1568          //!              value with 0x3FFFFF to ignore this case and treat as success).
   1569          //!     Otherwise, non-zero for failure.
   1570          //
   1571          //*****************************************************************************
   1572          int32_t
   1573          am_hal_flash_write_protect_set(uint32_t ui32InfoKey,
   1574                                         uint32_t *pui32StartAddress,
   1575                                         uint32_t *pui32StopAddress)
   1576          {
   1577              int iRC;
   1578              bool bModified = false;
   1579              uint64_t ui64Mask;
   1580              uint32_t ui32Work;
   1581              uint32_t ui32Protection[2];
   1582              uint32_t *pui32Protection = (uint32_t *)AM_HAL_FLASH_INFO_WRITPROT_ADDR;
   1583          
   1584              //
   1585              // Extract chunk mask from parameters.
   1586              // Also checks parameter validity (returns -1 if bad parameters).
   1587              //
   1588              ui64Mask = generate_chunk_mask(pui32StartAddress, pui32StopAddress);
   1589              if ( ~ui64Mask == 0x0 )
   1590              {
   1591                  return 0x100000;
   1592              }
   1593          
   1594              //
   1595              // Go get the current settings for copy protection.
   1596              //
   1597              ui32Protection[0] = pui32Protection[0];
   1598              ui32Protection[1] = pui32Protection[1];
   1599          
   1600              //
   1601              // AND mask off the necessary protection bits in the lower word.
   1602              //
   1603              ui32Work = (uint32_t)ui64Mask;
   1604              if ( ( ~ui32Work )  &&  ( ui32Work != ui32Protection[0] ) )
   1605              {
   1606                  bModified = true;
   1607                  // Need to change only the bits changing - bits already set to 0 should not be rewritten to 0
   1608                  // Flash has limits on number of times a bit can be set to 0
   1609                  ui32Protection[0] = ui32Work | ~ui32Protection[0];
   1610                  iRC = g_am_hal_flash.flash_program_info_area(
   1611                          ui32InfoKey,
   1612                          0,                                      // instance
   1613                          &ui32Protection[0],                     // source data
   1614                          (AM_HAL_FLASH_INFO_WRITPROT_O / 4) + 0, // word offset
   1615                          1 );                                    // number of words
   1616          
   1617                  if ( iRC )
   1618                  {
   1619                      return iRC | 0x10000;
   1620                  }
   1621              }
   1622          
   1623              //
   1624              // AND mask off the necessary protection bits in the upper word.
   1625              //
   1626              ui32Work = (uint32_t)(ui64Mask >> 32);
   1627              if ( ( ~ui32Work )  &&  ( ui32Work != ui32Protection[1] ) )
   1628              {
   1629                  bModified = true;
   1630                  // Need to change only the bits changing - bits already set to 0 should not be rewritten to 0
   1631                  // Flash has limits on number of times a bit can be set to 0
   1632                  ui32Protection[1] = ui32Work | ~ui32Protection[1];
   1633                  iRC = g_am_hal_flash.flash_program_info_area(
   1634                          ui32InfoKey,
   1635                          0,                                      // instance
   1636                          &ui32Protection[1],                     // source data
   1637                          (AM_HAL_FLASH_INFO_WRITPROT_O / 4) + 1, // word offset
   1638                          1 );                                    // number of words
   1639          
   1640                  if ( iRC )
   1641                  {
   1642                      return iRC | 0x20000;
   1643                  }
   1644              }
   1645          
   1646              if ( bModified )
   1647              {
   1648                  return 0;
   1649              }
   1650              else
   1651              {
   1652                  return 0x400000;
   1653              }
   1654          
   1655          } // am_hal_flash_write_protect_set()
   1656          
   1657          //*****************************************************************************
   1658          //
   1659          //! @brief This function checks write protection for a range of flash chunks.
   1660          //!
   1661          //! @param pui32StartAddress - Starting address in flash.
   1662          //! @param pui32StopAddress - Ending address in flash.
   1663          //!
   1664          //! This function will check write protection bits for a range of flash chunks
   1665          //! it expects all chunks in the range to be protected.
   1666          //!
   1667          //! @note Each flash chunk contains 16KBytes and corresponds to one bit in
   1668          //! the protection register. Set the bit to zero to enable protection.
   1669          //!
   1670          //! @return false for at least one chunk in the covered range is not protected,
   1671          //!         and true if all chunks in the covered range are protected.
   1672          //!
   1673          //
   1674          //*****************************************************************************
   1675          bool
   1676          am_hal_flash_write_protect_check(uint32_t *pui32StartAddress,
   1677                                           uint32_t *pui32StopAddress)
   1678          {
   1679              uint64_t ui64Mask;
   1680              uint32_t ui32Work;
   1681              uint32_t *pui32Protection = (uint32_t *)AM_HAL_FLASH_INFO_WRITPROT_ADDR;
   1682          
   1683              //
   1684              // Extract chunk mask from parameters.
   1685              // Also checks parameter validity (returns -1 if bad parameters).
   1686              //
   1687              ui64Mask = generate_chunk_mask(pui32StartAddress, pui32StopAddress);
   1688              if ( ~ui64Mask == 0x0 )
   1689              {
   1690                  return false;
   1691              }
   1692          
   1693              //
   1694              // Now check the lower word of protection bits.
   1695              //
   1696              ui32Work = (uint32_t)ui64Mask;
   1697              if ( ~ui32Work & pui32Protection[0] )
   1698              {
   1699                  return false;
   1700              }
   1701          
   1702              //
   1703              // Now check the lower word of protection bits.
   1704              //
   1705              ui32Work = (uint32_t)(ui64Mask >> 32);
   1706              if ( ~ui32Work & pui32Protection[1] )
   1707              {
   1708                  return false;
   1709              }
   1710          
   1711              //
   1712              // If we get here, there are no unprotected chunks within specified range.
   1713              //
   1714              return true;
   1715          
   1716          }// am_hal_flash_write_protect_check()
   1717          
   1718          //*****************************************************************************
   1719          //
   1720          //! @brief Read a uint32 value from a valid memory or peripheral location.
   1721          //!
   1722          //! @param ui32Address - The location to be read.
   1723          //!
   1724          //! Use this function to safely read a value from peripheral or memory locations.
   1725          //!
   1726          //! This function calls a function that resides BOOTROM or SRAM to do the actual
   1727          //! read, thus completely avoiding any conflict with flash or INFO space.
   1728          //!
   1729          //! @return The value read from the given address.
   1730          //
   1731          //*****************************************************************************
   1732          uint32_t
   1733          am_hal_flash_load_ui32(uint32_t *pui32Address)
   1734          {
   1735              return g_am_hal_flash.flash_util_read_word(pui32Address);
   1736          } // am_hal_flash_load_ui32()
   1737          
   1738          //*****************************************************************************
   1739          //
   1740          //! @brief Write a given uint32 value to a valid memory or peripheral location.
   1741          //!
   1742          //! @param pui32Address - The location to be written.
   1743          //!
   1744          //! Use this function to safely store a value to peripheral or memory locations.
   1745          //!
   1746          //! This function calls a function that resides in BOOTROM or SRAM to do the
   1747          //! actual write, thus completely avoiding any conflict with flash or INFO.
   1748          //!
   1749          //! @return The value read from the given address.
   1750          //
   1751          //*****************************************************************************
   1752          #if defined(__GNUC_STDC_INLINE__)    
   1753          uint32_t SRAM_write_ui32[12 / 4] =
   1754              {
   1755                  //
   1756                  // A very simple, word-aligned function residing in SRAM (stack).  This
   1757                  // function writes a given memory location while executing outside of
   1758                  // flash. It then does a read back to ensure that the write completed.
   1759                  // Prototype:   uint32_t SRAM_write_ui32(ui32Addr, ui32Value);
   1760                  //
   1761                  0xBF006001,         // 6001   str    r1,[r0,#0]
   1762                                      // BF00   nop
   1763                  0xBF006800,         // 6800   ldr    r0,[r0,#0]
   1764                                      // BF00   nop
   1765                  0xBF004770          // 4770   bx lr
   1766                                      // BF00   nop
   1767              };
   1768          #elif (defined (__ARMCC_VERSION) || defined(__IAR_SYSTEMS_ICC__))
   1769          #else
   1770          #error Compiler is unknown, please contact Ambiq support team
   1771          #endif
   1772          
   1773          void
   1774          am_hal_flash_store_ui32(uint32_t *pui32Address, uint32_t ui32Value)
   1775          {
   1776          #if (defined (__ARMCC_VERSION) || defined(__IAR_SYSTEMS_ICC__))
   1777              uint32_t SRAM_write_ui32[12 / 4] =
   1778              {
   1779                  //
   1780                  // A very simple, word-aligned function residing in SRAM (stack).  This
   1781                  // function writes a given memory location while executing outside of
   1782                  // flash. It then does a read back to ensure that the write completed.
   1783                  // Prototype:   uint32_t SRAM_write_ui32(ui32Addr, ui32Value);
   1784                  //
   1785                  0xBF006001,         // 6001   str    r1,[r0,#0]
   1786                                      // BF00   nop
   1787                  0xBF006800,         // 6800   ldr    r0,[r0,#0]
   1788                                      // BF00   nop
   1789                  0xBF004770          // 4770   bx lr
   1790                                      // BF00   nop
   1791              };
   1792          #elif defined(__GNUC_STDC_INLINE__)    
   1793          #else
   1794          #error Compiler is unknown, please contact Ambiq support team
   1795          #endif
   1796          
   1797              //
   1798              // Call the simple routine that has been coded in SRAM.
   1799              // First set up a function pointer to the array, being sure to set the
   1800              //  .T bit (Thumb bit, bit0) in the branch address, then use that
   1801              //  function ptr to call the SRAM function.
   1802              //
   1803              uint32_t SRAMCode = (uint32_t)SRAM_write_ui32 | 0x1;
   1804              uint32_t (*pFunc)(uint32_t*, uint32_t) = (uint32_t (*)(uint32_t*, uint32_t))SRAMCode;
   1805              (*pFunc)(pui32Address, ui32Value);
   1806          
   1807          } // am_hal_flash_store_ui32()
   1808          
   1809          //*****************************************************************************
   1810          //
   1811          // End Doxygen group.
   1812          //! @}
   1813          //
   1814          //*****************************************************************************

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   am_hal_flash_clear_bits
        24   -- Indirect call
      24   am_hal_flash_copy_protect_check
        24   -> generate_chunk_mask
      64   am_hal_flash_copy_protect_set
        64   -- Indirect call
        64   -> generate_chunk_mask
       0   am_hal_flash_customer_info_signature_check
      24   am_hal_flash_debugger_disable
        24   -- Indirect call
        24   -> customer_info_signature_set
       8   am_hal_flash_debugger_disable_check
         8   -> am_hal_flash_customer_info_signature_check
         8   -> customer_info_signature_erased
       8   am_hal_flash_delay
         8   -- Indirect call
      24   am_hal_flash_delay_status_change
        24   -> am_hal_flash_delay
      24   am_hal_flash_delay_status_check
        24   -> am_hal_flash_delay
      16   am_hal_flash_erase_info
        16   -- Indirect call
      16   am_hal_flash_erase_main_plus_info
        16   -- Indirect call
       8   am_hal_flash_erase_main_plus_info_both_instances
         8   -- Indirect call
      24   am_hal_flash_info_erase_disable
        24   -- Indirect call
        24   -> customer_info_signature_set
       8   am_hal_flash_info_erase_disable_check
         8   -> am_hal_flash_customer_info_signature_check
         8   -> customer_info_signature_erased
      32   am_hal_flash_info_program_disable
        32   -- Indirect call
        32   -> customer_info_signature_set
       8   am_hal_flash_info_program_disable_get
         8   -> am_hal_flash_customer_info_signature_check
         8   -> customer_info_signature_erased
       8   am_hal_flash_info_signature_set
         8   -> customer_info_signature_set
       8   am_hal_flash_load_ui32
         8   -- Indirect call
      16   am_hal_flash_mass_erase
        16   -- Indirect call
      16   am_hal_flash_page_erase
        16   -- Indirect call
      40   am_hal_flash_program_info
        40   -- Indirect call
      32   am_hal_flash_program_main
        32   -- Indirect call
       8   am_hal_flash_recovery
         8   -- Indirect call
      32   am_hal_flash_reprogram_info_ui32
        32   -- Indirect call
      24   am_hal_flash_reprogram_ui32
        24   -- Indirect call
      32   am_hal_flash_store_ui32
        32   -- Indirect call
      24   am_hal_flash_swo_disable
        24   -- Indirect call
        24   -> customer_info_signature_set
       8   am_hal_flash_swo_disable_check
         8   -> am_hal_flash_customer_info_signature_check
         8   -> customer_info_signature_erased
      24   am_hal_flash_wipe_flash_enable
        24   -- Indirect call
        24   -> customer_info_signature_set
       8   am_hal_flash_wipe_flash_enable_check
         8   -> am_hal_flash_customer_info_signature_check
         8   -> customer_info_signature_erased
      24   am_hal_flash_wipe_sram_enable
        24   -- Indirect call
        24   -> customer_info_signature_set
       8   am_hal_flash_wipe_sram_enable_check
         8   -> am_hal_flash_customer_info_signature_check
         8   -> customer_info_signature_erased
      24   am_hal_flash_write_protect_check
        24   -> generate_chunk_mask
      64   am_hal_flash_write_protect_set
        64   -- Indirect call
        64   -> generate_chunk_mask
       0   customer_info_signature_erased
      32   customer_info_signature_set
        32   -- Indirect call
        32   -> am_hal_flash_customer_info_signature_check
        32   -> customer_info_signature_erased
      24   generate_chunk_mask
        24 __aeabi_llsl


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable32
       4  ??DataTable32_1
       4  ??DataTable32_10
       4  ??DataTable32_2
       4  ??DataTable32_3
       4  ??DataTable32_4
       4  ??DataTable32_5
       4  ??DataTable32_6
       4  ??DataTable32_7
       4  ??DataTable32_8
       4  ??DataTable32_9
      12  ?_0
      40  am_hal_flash_clear_bits
      68  am_hal_flash_copy_protect_check
     224  am_hal_flash_copy_protect_set
      54  am_hal_flash_customer_info_signature_check
      50  am_hal_flash_debugger_disable
      42  am_hal_flash_debugger_disable_check
      16  am_hal_flash_delay
      42  am_hal_flash_delay_status_change
      68  am_hal_flash_delay_status_check
      20  am_hal_flash_erase_info
      20  am_hal_flash_erase_main_plus_info
      16  am_hal_flash_erase_main_plus_info_both_instances
      54  am_hal_flash_info_erase_disable
      46  am_hal_flash_info_erase_disable_check
      60  am_hal_flash_info_program_disable
      46  am_hal_flash_info_program_disable_get
      24  am_hal_flash_info_signature_set
      14  am_hal_flash_load_ui32
      20  am_hal_flash_mass_erase
      24  am_hal_flash_page_erase
     130  am_hal_flash_program_info
     114  am_hal_flash_program_main
      16  am_hal_flash_recovery
      72  am_hal_flash_reprogram_info_ui32
      48  am_hal_flash_reprogram_ui32
      34  am_hal_flash_store_ui32
      54  am_hal_flash_swo_disable
      46  am_hal_flash_swo_disable_check
      54  am_hal_flash_wipe_flash_enable
      46  am_hal_flash_wipe_flash_enable_check
      54  am_hal_flash_wipe_sram_enable
      46  am_hal_flash_wipe_sram_enable_check
      68  am_hal_flash_write_protect_check
     224  am_hal_flash_write_protect_set
      56  customer_info_signature_erased
      96  customer_info_signature_set
      96  g_am_hal_flash
      90  generate_chunk_mask
       4  ui32SramMaxAddr

 
   112 bytes in section .rodata
 2 240 bytes in section .text
 
 2 240 bytes of CODE  memory
   112 bytes of CONST memory

Errors: none
Warnings: none
