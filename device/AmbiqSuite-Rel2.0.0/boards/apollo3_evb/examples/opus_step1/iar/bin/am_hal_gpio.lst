###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         12/Mar/2019  10:07:08
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_gpio.c
#    Command line =  
#        -f C:\temp\EW8302.tmp
#        (C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_gpio.c
#        -D iar -D AM_PART_APOLLO3 -D AM_PACKAGE_BGA -lcN
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --diag_suppress Pa050 -o
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\utils\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\ARM\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\CMSIS\AmbiqMicro\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\mcu\apollo3\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\devices\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\bsp\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\..\..\..\..\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\..\src\sound\
#        -On)
#    Locale       =  C
#    List file    =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_gpio.lst
#    Object file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\opus_step1\iar\bin\am_hal_gpio.o
#
###############################################################################

C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\mcu\apollo3\hal\am_hal_gpio.c
      1          //*****************************************************************************
      2          //
      3          //  am_hal_gpio.c
      4          //! @file
      5          //!
      6          //! @brief Functions for interfacing with the GPIO module
      7          //!
      8          //! @addtogroup gpio3 GPIO
      9          //! @ingroup apollo3hal
     10          //! @{
     11          //
     12          //*****************************************************************************
     13          
     14          //*****************************************************************************
     15          //
     16          // Copyright (c) 2019, Ambiq Micro
     17          // All rights reserved.
     18          // 
     19          // Redistribution and use in source and binary forms, with or without
     20          // modification, are permitted provided that the following conditions are met:
     21          // 
     22          // 1. Redistributions of source code must retain the above copyright notice,
     23          // this list of conditions and the following disclaimer.
     24          // 
     25          // 2. Redistributions in binary form must reproduce the above copyright
     26          // notice, this list of conditions and the following disclaimer in the
     27          // documentation and/or other materials provided with the distribution.
     28          // 
     29          // 3. Neither the name of the copyright holder nor the names of its
     30          // contributors may be used to endorse or promote products derived from this
     31          // software without specific prior written permission.
     32          // 
     33          // Third party software included in this distribution is subject to the
     34          // additional license terms as defined in the /docs/licenses directory.
     35          // 
     36          // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     37          // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     38          // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     39          // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     40          // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     41          // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     42          // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     43          // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     44          // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     45          // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     46          // POSSIBILITY OF SUCH DAMAGE.
     47          //
     48          // This is part of revision v2.0.0 of the AmbiqSuite Development Package.
     49          //
     50          //*****************************************************************************
     51          
     52          #include <stdint.h>
     53          #include <stdbool.h>
     54          #include "am_mcu_apollo.h"
     55          
     56          //*****************************************************************************
     57          //  Local defines.
     58          //*****************************************************************************
     59          #define AM_HAL_ENABLE_API_VALIDATION
     60          
     61          //
     62          // Generally define GPIO PADREG and GPIOCFG bitfields
     63          //
     64          #define PADREG_FLD_76_S         6
     65          #define PADREG_FLD_FNSEL_S      3
     66          #define PADREG_FLD_DRVSTR_S     2
     67          #define PADREG_FLD_INPEN_S      1
     68          #define PADREG_FLD_PULLUP_S     0
     69          
     70          #define GPIOCFG_FLD_INTD_S      3
     71          #define GPIOCFG_FLD_OUTCFG_S    1
     72          #define GPIOCFG_FLD_INCFG_S     0
     73          
     74          //*****************************************************************************
     75          //
     76          // Globals
     77          //
     78          //*****************************************************************************
     79          //*****************************************************************************
     80          //  Define some common GPIO configurations.
     81          //*****************************************************************************
     82          const am_hal_gpio_pincfg_t g_AM_HAL_GPIO_DISABLE =
     83          {
     84              .uFuncSel       = 3,
     85              .eDriveStrength = AM_HAL_GPIO_PIN_DRIVESTRENGTH_2MA,
     86              .eGPOutcfg      = AM_HAL_GPIO_PIN_OUTCFG_DISABLE
     87          };
     88          
     89          const am_hal_gpio_pincfg_t g_AM_HAL_GPIO_OUTPUT =
     90          {
     91              .uFuncSel       = 3,
     92              .eDriveStrength = AM_HAL_GPIO_PIN_DRIVESTRENGTH_2MA,
     93              .eGPOutcfg      = AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL
     94          };
     95          
     96          const am_hal_gpio_pincfg_t g_AM_HAL_GPIO_TRISTATE =
     97          {
     98              .uFuncSel       = 3,
     99              .eDriveStrength = AM_HAL_GPIO_PIN_DRIVESTRENGTH_2MA,
    100              .eGPOutcfg      = AM_HAL_GPIO_PIN_OUTCFG_TRISTATE
    101          };
    102          
    103          const am_hal_gpio_pincfg_t g_AM_HAL_GPIO_INPUT =
    104          {
    105              .uFuncSel       = 3,
    106              .eGPOutcfg      = AM_HAL_GPIO_PIN_OUTCFG_DISABLE,
    107              .eGPInput       = AM_HAL_GPIO_PIN_INPUT_ENABLE,
    108              .eGPRdZero      = AM_HAL_GPIO_PIN_RDZERO_READPIN
    109          };
    110          
    111          //
    112          // Variations of output (drive strengths, read, etc)
    113          //
    114          const am_hal_gpio_pincfg_t g_AM_HAL_GPIO_OUTPUT_4 =
    115          {
    116              .uFuncSel       = 3,
    117              .eDriveStrength = AM_HAL_GPIO_PIN_DRIVESTRENGTH_4MA,
    118              .eGPOutcfg      = AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL
    119          };
    120          
    121          const am_hal_gpio_pincfg_t g_AM_HAL_GPIO_OUTPUT_8 =
    122          {
    123              .uFuncSel       = 3,
    124              .eDriveStrength = AM_HAL_GPIO_PIN_DRIVESTRENGTH_8MA,
    125              .eGPOutcfg      = AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL
    126          };
    127          
    128          const am_hal_gpio_pincfg_t g_AM_HAL_GPIO_OUTPUT_12 =
    129          {
    130              .uFuncSel       = 3,
    131              .eDriveStrength = AM_HAL_GPIO_PIN_DRIVESTRENGTH_12MA,
    132              .eGPOutcfg      = AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL
    133          };
    134          
    135          const am_hal_gpio_pincfg_t g_AM_HAL_GPIO_OUTPUT_WITH_READ =
    136          {
    137              .uFuncSel       = 3,
    138              .eDriveStrength = AM_HAL_GPIO_PIN_DRIVESTRENGTH_2MA,
    139              .eGPOutcfg      = AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL,
    140              .eGPInput       = AM_HAL_GPIO_PIN_INPUT_ENABLE,
    141              .eGPRdZero      = AM_HAL_GPIO_PIN_RDZERO_READPIN
    142          };
    143          
    144          //*****************************************************************************
    145          //
    146          //  g_ui8Inpen[]
    147          //  This lookup table determines whether the INPEN bit is required based on
    148          //  the pin number and FNSEL.
    149          //
    150          //*****************************************************************************
    151          static const uint8_t
    152          g_ui8Inpen[50] =
    153          {
    154              //0     1     2     3     4     5     6     7     8     9
    155              0x23, 0x23, 0x24, 0xE2, 0xA1, 0x23, 0x07, 0x10, 0x03, 0x43, // Pins 0-9
    156              0x00, 0xE1, 0x51, 0xA1, 0x61, 0x35, 0x25, 0xC5, 0x81, 0x41, // Pins 10-19
    157              0x01, 0xB0, 0x60, 0xD1, 0x30, 0x31, 0xA1, 0x31, 0x01, 0xF1, // Pins 20-29
    158              0x00, 0x11, 0xB1, 0x21, 0xD1, 0x01, 0xE5, 0x11, 0x05, 0x30, // Pins 30-39
    159              0x37, 0x10, 0x30, 0x31, 0x00, 0x61, 0x00, 0x40, 0x30, 0x31  // Pins 40-49
    160          };
    161          
    162          //*****************************************************************************
    163          //
    164          //  g_ui8Bit76Capabilities[]
    165          //  This lookup table specifies capabilities of each pad for PADREG bits 7:6.
    166          //
    167          //*****************************************************************************
    168          #define CAP_PUP     0x01    // PULLUP
    169          #define CAP_PDN     0x08    // PULLDOWN (pin 20 only)
    170          #define CAP_VDD     0x02    // VDD PWR (power source)
    171          #define CAP_VSS     0x04    // VSS PWR (ground sink)
    172          #define CAP_RSV     0x80    // bits 7:6 are reserved for this pin
    173          static const uint8_t
    174          g_ui8Bit76Capabilities[50] =
    175          {
    176              //0        1        2        3        4        5        6        7        8        9
    177              CAP_PUP, CAP_PUP, CAP_RSV, CAP_VDD, CAP_RSV, CAP_PUP, CAP_PUP, CAP_RSV, CAP_PUP, CAP_PUP,   // Pins 0-9
    178              CAP_RSV, CAP_RSV, CAP_RSV, CAP_RSV, CAP_RSV, CAP_RSV, CAP_RSV, CAP_RSV, CAP_RSV, CAP_RSV,   // Pins 10-19
    179              CAP_PDN, CAP_RSV, CAP_RSV, CAP_RSV, CAP_RSV, CAP_PUP, CAP_RSV, CAP_PUP, CAP_RSV, CAP_RSV,   // Pins 20-29
    180              CAP_RSV, CAP_RSV, CAP_RSV, CAP_RSV, CAP_RSV, CAP_RSV, CAP_VDD, CAP_VSS, CAP_RSV, CAP_PUP,   // Pins 30-39
    181              CAP_PUP, CAP_VSS, CAP_PUP, CAP_PUP, CAP_RSV, CAP_RSV, CAP_RSV, CAP_RSV, CAP_PUP, CAP_PUP    // Pins 40-49
    182          };
    183          
    184          //*****************************************************************************
    185          //
    186          // g_ui8nCEpins[]
    187          // This lookup table lists the nCE funcsel value as a function of the pin.
    188          //  Almost every pad has a nCE function (except for 4 pads).  Every one of those
    189          //  nCE functions can select a polarity (active low or high) via the INTD field.
    190          // All non-nCE functions use INCFG and INTD to select interrupt transition types.
    191          // A lookup will return 0-7 if the pin supports nCE, and 8 if it does not.
    192          //
    193          // The truth table summarizes behavior.  For the purposes of this table, assume
    194          //  "A" is the funcsel that selects nCE (and thus polarity is needed) for the
    195          //  given pad.  Then "!A" is any other funcsel and selects interrupt transition.
    196          //
    197          //  funcsel     INCFG       INTD        Behavior
    198          //    !A        0           0           Interrupt on L->H transition.
    199          //    !A        0           1           Interrupt on H->L transition.
    200          //    !A        1           0           No interrupts.
    201          //    !A        1           1           Interrupt either direction.
    202          //     A        x           0           nCE polarity active low.
    203          //     A        x           1           nCE polarity active high.
    204          //
    205          //*****************************************************************************
    206          static const uint8_t
    207          g_ui8nCEpins[50] =
    208          {
    209              // 0     1     2     3     4     5     6     7     8     9
    210              0x07, 0x07, 0x07, 0x02, 0x02, 0x08, 0x08, 0x00, 0x02, 0x02,     // Pads 0-9
    211              0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,     // Pads 10-19
    212              0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,     // Pads 20-29
    213              0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x08,     // Pads 30-39
    214              0x08, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01      // Pads 40-49
    215          };
    216          
    217          //*****************************************************************************
    218          //
    219          // g_ui8NCEtable[]
    220          // This lookup table lists all available NCEs. It basically reproduces the
    221          //  "NCE Encoding Table" from the datasheet.
    222          // The format of this table is:
    223          //  High nibble=IOM number; 0-5, MSPI=6 (IOMNUM_MSPI).
    224          //  Low nibble=CE number (0-3).
    225          //  Every 4 bytes (word) represent the next GPIO number/index.
    226          //
    227          //*****************************************************************************
    228          static const uint8_t
    229          g_ui8NCEtable[50][4] =
    230          {
    231               // 0       1       2       3    = OUTCFG
    232              {0x32,   0x42,   0x52,   0x13},  // NCE0
    233              {0x02,   0x12,   0x22,   0x60},  // NCE1
    234              {0x33,   0x43,   0x53,   0x21},  // NCE2
    235              {0x30,   0x40,   0x50,   0x20},  // NCE3
    236              {0x31,   0x41,   0x51,   0x11},  // NCE4
    237              {0xFF,   0xFF,   0xFF,   0xFF},  // NCE5
    238              {0xFF,   0xFF,   0xFF,   0xFF},  // NCE6
    239              {0x31,   0x41,   0x51,   0x60},  // NCE7
    240              {0x30,   0x40,   0x50,   0x00},  // NCE8
    241              {0x33,   0x43,   0x53,   0x23},  // NCE9
    242              {0x32,   0x42,   0x52,   0x60},  // NCE10
    243              {0x00,   0x10,   0x20,   0x30},  // NCE11
    244              {0x30,   0x40,   0x50,   0x61},  // NCE12
    245              {0x31,   0x41,   0x51,   0x01},  // NCE13
    246              {0x02,   0x12,   0x22,   0x42},  // NCE14
    247              {0x03,   0x13,   0x23,   0x60},  // NCE15
    248              {0x00,   0x10,   0x20,   0x50},  // NCE16
    249              {0x01,   0x11,   0x21,   0x41},  // NCE17
    250              {0x02,   0x12,   0x22,   0x32},  // NCE18
    251              {0x03,   0x13,   0x33,   0x60},  // NCE19
    252              {0x31,   0x41,   0x51,   0x21},  // NCE20
    253              {0x32,   0x42,   0x52,   0x22},  // NCE21
    254              {0x33,   0x43,   0x53,   0x03},  // NCE22
    255              {0x00,   0x10,   0x20,   0x40},  // NCE23
    256              {0x01,   0x11,   0x21,   0x51},  // NCE24
    257              {0x32,   0x42,   0x52,   0x02},  // NCE25
    258              {0x33,   0x43,   0x53,   0x13},  // NCE26
    259              {0x30,   0x40,   0x50,   0x10},  // NCE27
    260              {0x31,   0x41,   0x51,   0x60},  // NCE28
    261              {0x32,   0x42,   0x52,   0x12},  // NCE29
    262              {0x33,   0x43,   0x53,   0x03},  // NCE30
    263              {0x00,   0x10,   0x20,   0x40},  // NCE31
    264              {0x01,   0x11,   0x21,   0x61},  // NCE32
    265              {0x02,   0x12,   0x22,   0x52},  // NCE33
    266              {0x03,   0x13,   0x23,   0x33},  // NCE34
    267              {0x00,   0x10,   0x20,   0x30},  // NCE35
    268              {0x31,   0x41,   0x51,   0x61},  // NCE36
    269              {0x32,   0x42,   0x52,   0x02},  // NCE37
    270              {0x03,   0x13,   0x33,   0x53},  // NCE38
    271              {0xFF,   0xFF,   0xFF,   0xFF},  // NCE39
    272              {0xFF,   0xFF,   0xFF,   0xFF},  // NCE40
    273              {0x01,   0x11,   0x21,   0x61},  // NCE41
    274              {0x00,   0x10,   0x20,   0x50},  // NCE42
    275              {0x01,   0x11,   0x21,   0x61},  // NCE43
    276              {0x02,   0x12,   0x22,   0x52},  // NCE44
    277              {0x33,   0x43,   0x53,   0x13},  // NCE45
    278              {0x30,   0x40,   0x50,   0x61},  // NCE46
    279              {0x01,   0x11,   0x21,   0x31},  // NCE47
    280              {0x02,   0x12,   0x22,   0x32},  // NCE48
    281              {0x03,   0x13,   0x23,   0x43}   // NCE49
    282          };
    283          
    284          //*****************************************************************************
    285          //
    286          // Array of function pointers for handling GPIO interrupts.
    287          //
    288          //*****************************************************************************
    289          static am_hal_gpio_handler_t gpio_ppfnHandlers[AM_HAL_GPIO_MAX_PADS];
    290          
    291          //*****************************************************************************
    292          //
    293          // Helper functions
    294          //  num_bits64() - Determine how many bits are set in a 64-bit value.
    295          //  pincfg_equ() - compare 2 am_hal_gpio_pincfg_t structures for equality.
    296          //
    297          //*****************************************************************************
    298          static bool
    299          pincfg_equ(void *cfg1, void *cfg2)
    300          {
    301              uint32_t ui32A, ui32B;
    302          
    303              //
    304              // We're assuming that am_hal_gpio_pincfg_t boils down to a uint32_t,
    305              // which is its intent.
    306              //
    307              ui32A = *((uint32_t*)cfg1);
    308              ui32B = *((uint32_t*)cfg2);
    309          
    310              return ui32A == ui32B ? true : false;
    311          
    312          } // pincfg_equ()
    313          
    314          static uint32_t
    315          num_bits64(uint64_t ui64bitmask)
    316          {
    317              uint32_t ux = 0;
    318              while ( ui64bitmask )
    319              {
    320                  ux += ui64bitmask & 1;
    321                  ui64bitmask >>= 1;
    322              }
    323              return ux;
    324          } // num_bits64()
    325          
    326          
    327          //*****************************************************************************
    328          //
    329          //! @brief Configure an Apollo3 pin.
    330          //!
    331          //! @param ui32Pin    - pin number to be configured.
    332          //! @param ui32Config - Contains multiple descriptor fields.
    333          //!
    334          //! This function configures a pin according to the parameters in ui32Config.
    335          //! All parameters are validated, and the given pin is configured according
    336          //! to the designated parameters.
    337          //!
    338          //! @return Status.
    339          //
    340          //*****************************************************************************
    341          uint32_t
    342          am_hal_gpio_pinconfig(uint32_t ui32Pin, am_hal_gpio_pincfg_t bfGpioCfg)
    343          
    344          {
    345              uint32_t ui32Padreg, ui32AltPadCfg, ui32GPCfg;
    346              uint32_t ui32Funcsel, ui32PowerSw;
    347              bool bClearEnable = false;
    348          
    349          #ifdef AM_HAL_ENABLE_API_VALIDATION
    350              if ( ui32Pin > 49 )
    351              {
    352                  return AM_HAL_STATUS_INVALID_ARG;
    353              }
    354          #endif // AM_HAL_ENABLE_API_VALIDATION
    355          
    356              //
    357              // Initialize the PADREG accumulator variables.
    358              //
    359              ui32GPCfg = ui32Padreg = ui32AltPadCfg = 0;
    360          
    361              //
    362              // Get the requested function and/or power switch.
    363              //
    364              ui32Funcsel = bfGpioCfg.uFuncSel;
    365              ui32PowerSw = bfGpioCfg.ePowerSw;
    366          
    367              ui32Padreg |= ui32Funcsel << PADREG_FLD_FNSEL_S;
    368          
    369              //
    370              // Check for invalid configuration requests.
    371              //
    372              if ( bfGpioCfg.ePullup != AM_HAL_GPIO_PIN_PULLUP_NONE )
    373              {
    374                  //
    375                  // This setting is needed for all pullup settings including
    376                  // AM_HAL_GPIO_PIN_PULLUP_WEAK and AM_HAL_GPIO_PIN_PULLDOWN.
    377                  //
    378                  ui32Padreg |= (0x1 << PADREG_FLD_PULLUP_S);
    379          
    380                  //
    381                  // Check for specific pullup or pulldown settings.
    382                  //
    383                  if ( (bfGpioCfg.ePullup >= AM_HAL_GPIO_PIN_PULLUP_1_5K) &&
    384                       (bfGpioCfg.ePullup <= AM_HAL_GPIO_PIN_PULLUP_24K) )
    385                  {
    386                      ui32Padreg |= ((bfGpioCfg.ePullup - AM_HAL_GPIO_PIN_PULLUP_1_5K) <<
    387                                     PADREG_FLD_76_S);
    388          #ifdef AM_HAL_ENABLE_API_VALIDATION
    389                      if ( !(g_ui8Bit76Capabilities[ui32Pin] & CAP_PUP) )
    390                      {
    391                          return AM_HAL_GPIO_ERR_PULLUP;
    392                      }
    393                  }
    394                  else if ( bfGpioCfg.ePullup == AM_HAL_GPIO_PIN_PULLDOWN )
    395                  {
    396                      if ( ui32Pin != 20 )
    397                      {
    398                          return AM_HAL_GPIO_ERR_PULLDOWN;
    399                      }
    400                  }
    401                  else if ( bfGpioCfg.ePullup == AM_HAL_GPIO_PIN_PULLUP_WEAK )
    402                  {
    403                      if ( g_ui8Bit76Capabilities[ui32Pin] & (CAP_PUP | CAP_PDN) )
    404                      {
    405                          return AM_HAL_GPIO_ERR_PULLUP;
    406                      }
    407          #endif // AM_HAL_ENABLE_API_VALIDATION
    408                  }
    409              }
    410          
    411              //
    412              // Check if requesting a power switch pin
    413              //
    414              if ( ui32PowerSw != AM_HAL_GPIO_PIN_POWERSW_NONE )
    415              {
    416                  if ( (ui32PowerSw == AM_HAL_GPIO_PIN_POWERSW_VDD)  &&
    417                       (g_ui8Bit76Capabilities[ui32Pin] & CAP_VDD) )
    418                  {
    419                      ui32Padreg |= 0x1 << PADREG_FLD_76_S;
    420                  }
    421                  else if ( (ui32PowerSw == AM_HAL_GPIO_PIN_POWERSW_VSS)  &&
    422                            (g_ui8Bit76Capabilities[ui32Pin] & CAP_VSS) )
    423                  {
    424                      ui32Padreg |= 0x2 << PADREG_FLD_76_S;
    425                  }
    426                  else
    427                  {
    428                      return AM_HAL_GPIO_ERR_PWRSW;
    429                  }
    430              }
    431          
    432              //
    433              // Depending on the selected pin and FNSEL, determine if INPEN needs to be set.
    434              //
    435              ui32Padreg |= (g_ui8Inpen[ui32Pin] & (1 << ui32Funcsel)) ? (1 << PADREG_FLD_INPEN_S) : 0;
    436          
    437              //
    438              // Configure ui32GpCfg based on whether nCE requested.
    439              //
    440              if ( g_ui8nCEpins[ui32Pin] == ui32Funcsel )
    441              {
    442                  uint32_t ui32Outcfg;
    443                  uint8_t ui8CEtbl;
    444          
    445          #ifdef AM_HAL_ENABLE_API_VALIDATION
    446                  //
    447                  // User is configuring a nCE. Verify the requested settings and set the
    448                  // polarity and OUTCFG values (INCFG is not used here and should be 0).
    449                  // Valid uNCE values are 0-3 (uNCE is a 2-bit field).
    450                  // Valid uIOMnum are 0-6 (0-5 for IOMs, 6 for MSPI, 7 is invalid).
    451                  //
    452                  if ( bfGpioCfg.uIOMnum > IOMNUM_MAX )
    453                  {
    454                      return AM_HAL_GPIO_ERR_INVCE;   // Invalid CE specified
    455                  }
    456          #endif // AM_HAL_ENABLE_API_VALIDATION
    457          
    458                  //
    459                  // Construct the entry we expect to find in the table. We can determine
    460                  // the OUTCFG value by looking for that value in the pin row.
    461                  //
    462                  ui8CEtbl = (bfGpioCfg.uIOMnum << 4) | bfGpioCfg.uNCE;
    463                  for ( ui32Outcfg = 0; ui32Outcfg < 4; ui32Outcfg++ )
    464                  {
    465                      if ( g_ui8NCEtable[ui32Pin][ui32Outcfg] == ui8CEtbl )
    466                      {
    467                          break;
    468                      }
    469                  }
    470          
    471          #ifdef AM_HAL_ENABLE_API_VALIDATION
    472                  if ( ui32Outcfg >= 4 )
    473                  {
    474                      return AM_HAL_GPIO_ERR_INVCEPIN;
    475                  }
    476          #endif // AM_HAL_ENABLE_API_VALIDATION
    477          
    478                  ui32GPCfg |= (ui32Outcfg       << GPIOCFG_FLD_OUTCFG_S) |
    479                               (bfGpioCfg.eCEpol << GPIOCFG_FLD_INTD_S)   |
    480                               (0                << GPIOCFG_FLD_INCFG_S);
    481              }
    482              else
    483              {
    484                  //
    485                  // It's not nCE, it's one of the other funcsels.
    486                  // Start by setting the value of the requested GPIO input.
    487                  //
    488                  ui32Padreg |= (bfGpioCfg.eGPInput << PADREG_FLD_INPEN_S);
    489          
    490                  //
    491                  // Map the requested interrupt direction settings into the Apollo3
    492                  //  GPIOCFG register field, which is a 4-bit field:
    493                  //  [INTD(1):OUTCFG(2):INCFG(1)].
    494                  // Bit0 of eIntDir maps to GPIOCFG.INTD  (b3).
    495                  // Bit1 of eIntDir maps to GPIOCFG.INCFG (b0).
    496                  //
    497                  ui32GPCfg |= (bfGpioCfg.eGPOutcfg << GPIOCFG_FLD_OUTCFG_S)              |
    498                               (((bfGpioCfg.eIntDir >> 0) & 0x1) << GPIOCFG_FLD_INTD_S)   |
    499                               (((bfGpioCfg.eIntDir >> 1) & 0x1) << GPIOCFG_FLD_INCFG_S);
    500          
    501                  if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
    502                       pincfg_equ(&bfGpioCfg, (void*)&g_AM_HAL_GPIO_DISABLE) )
    503                  {
    504                      //
    505                      // For pushpull configurations, we must be sure to clear the ENABLE
    506                      // bit.  In pushpull, these bits turn on FAST GPIO.  For regular
    507                      // GPIO, they must be clear.
    508                      //
    509                      bClearEnable = true;
    510                  }
    511          
    512                  //
    513                  // There is some overlap between eGPRdZero and eIntDir as both settings
    514                  //  utilize the overloaded INCFG bit.
    515                  // Therefore the two fields should be used in a mutually exclusive
    516                  //  manner. For flexibility however they are not disallowed because
    517                  //  their functionality is dependent on FUNCSEL and whether interrupts
    518                  //  are used.
    519                  //
    520                  // In the vein of mutual exclusion, eGPRdZero is primarily intended for
    521                  //  use when GPIO interrupts are not in use and can be used when no
    522                  //  eIntDir setting is provided.
    523                  // If eIntDir is provided, eGPRdZero is ignored and can only be
    524                  //  achieved via the AM_HAL_GPIO_PIN_INTDIR_NONE setting.
    525                  //
    526                  if ( bfGpioCfg.eIntDir == 0 )
    527                  {
    528                      ui32GPCfg &= ~(1 << GPIOCFG_FLD_INCFG_S);
    529                      ui32GPCfg |= (bfGpioCfg.eGPRdZero << GPIOCFG_FLD_INCFG_S);
    530                  }
    531              }
    532          
    533              switch ( bfGpioCfg.eDriveStrength )
    534              {
    535                  // DRIVESTRENGTH is a 2-bit field.
    536                  //  bit0 maps to bit2 of a PADREG field.
    537                  //  bit1 maps to bit0 of an ALTPADCFG field.
    538                  case AM_HAL_GPIO_PIN_DRIVESTRENGTH_2MA:
    539                      ui32Padreg    |= (0 << PADREG_FLD_DRVSTR_S);
    540                      ui32AltPadCfg |= (0 << 0);
    541                      break;
    542                  case AM_HAL_GPIO_PIN_DRIVESTRENGTH_4MA:
    543                      ui32Padreg    |= (1 << PADREG_FLD_DRVSTR_S);
    544                      ui32AltPadCfg |= (0 << 0);
    545                      break;
    546                  case AM_HAL_GPIO_PIN_DRIVESTRENGTH_8MA:
    547                      ui32Padreg    |= (0 << PADREG_FLD_DRVSTR_S);
    548                      ui32AltPadCfg |= (1 << 0);
    549                      break;
    550                  case AM_HAL_GPIO_PIN_DRIVESTRENGTH_12MA:
    551                      ui32Padreg    |= (1 << PADREG_FLD_DRVSTR_S);
    552                      ui32AltPadCfg |= (1 << 0);
    553                      break;
    554              }
    555          
    556              //
    557              // At this point, the 3 configuration variables, ui32GpioCfg, ui32Padreg,
    558              //  and ui32AltPadCfg values are set (at bit position 0) and ready to write
    559              //  to their respective register bitfields.
    560              //
    561              uint32_t ui32GPCfgAddr, ui32PadregAddr, ui32AltpadAddr;
    562              uint32_t ui32GPCfgClearMask, ui32PadClearMask;
    563              uint32_t ui32GPCfgShft, ui32PadShft;
    564          
    565              ui32GPCfgAddr       = (uint32_t)&GPIO->CFGA       + ((ui32Pin & ~0x7) >> 1);
    566              ui32PadregAddr      = (uint32_t)&GPIO->PADREGA    + (ui32Pin & ~0x3);
    567              ui32AltpadAddr      = (uint32_t)&GPIO->ALTPADCFGA + (ui32Pin & ~0x3);
    568              ui32GPCfgShft       = ((ui32Pin & 0x7) << 2);
    569              ui32PadShft         = ((ui32Pin & 0x3) << 3);
    570              ui32GPCfgClearMask  = ~((uint32_t)0xF  << ui32GPCfgShft);
    571              ui32PadClearMask    = ~((uint32_t)0xFF << ui32PadShft);
    572          
    573              //
    574              // Get the new values into their rightful bit positions.
    575              //
    576              ui32Padreg    <<= ui32PadShft;
    577              ui32AltPadCfg <<= ui32PadShft;
    578              ui32GPCfg     <<= ui32GPCfgShft;
    579          
    580              AM_CRITICAL_BEGIN
    581          
    582              if ( bClearEnable )
    583              {
    584                  //
    585                  // We're configuring a mode that requires clearing the Enable bit.
    586                  //
    587                  am_hal_gpio_output_tristate_disable(ui32Pin);
    588              }
    589          
    590              GPIO->PADKEY = GPIO_PADKEY_PADKEY_Key;
    591          
    592              AM_REGVAL(ui32PadregAddr)  = (AM_REGVAL(ui32PadregAddr) & ui32PadClearMask)   | ui32Padreg;
    593              AM_REGVAL(ui32GPCfgAddr)   = (AM_REGVAL(ui32GPCfgAddr)  & ui32GPCfgClearMask) | ui32GPCfg;
    594              AM_REGVAL(ui32AltpadAddr)  = (AM_REGVAL(ui32AltpadAddr) & ui32PadClearMask)   | ui32AltPadCfg;
    595          
    596              GPIO->PADKEY = 0;
    597          
    598              AM_CRITICAL_END
    599          
    600              return AM_HAL_STATUS_SUCCESS;
    601          
    602          } // am_hal_gpio_pinconfig()
    603          
    604          //*****************************************************************************
    605          //
    606          // brief Configure specified pins for FAST GPIO operation.
    607          //
    608          // ui64PinMask - a mask specifying up to 8 pins to be configured and
    609          //               used for FAST GPIO (only bits 0-49 are valid).
    610          // bfGpioCfg   - The GPIO configuration (same as am_hal_gpio_pinconfig()).
    611          //               All of the pins specified by ui64PinMask will be set to this
    612          //               configuration.
    613          // ui32Masks   - If provided, an array to receive 2 32-bit values of the
    614          //               SET and CLEAR masks that are used for the BBSETCLEAR reg.
    615          //               Two 32-bit wds are placed for each pin indicated by the mask.
    616          //               The 2 32-bit values will be placed at incremental indexes.
    617          //               For example, say pin numbers 5 and 19 are indicated in the
    618          //               mask, and an array pointer is provided in ui32Masks.  This
    619          //               array must be allocated by the caller to be at least 4 words.
    620          //               ui32Masks[0] = the set   mask used for pin 5.
    621          //               ui32Masks[1] = the clear mask used for pin 5.
    622          //               ui32Masks[2] = the set   mask used for pin 19.
    623          //               ui32Masks[3] = the clear mask used for pin 19.
    624          //               It is recommended that this array be allocated to 16 uint32_t.
    625          //
    626          //*****************************************************************************
    627          uint32_t
    628          am_hal_gpio_fast_pinconfig(uint64_t ui64PinMask,
    629                                     am_hal_gpio_pincfg_t bfGpioCfg,
    630                                     uint32_t ui32Masks[])
    631          {
    632              uint32_t ux, ui32pinnum, ui32retval, ui32Mask;
    633          
    634          #ifdef AM_HAL_ENABLE_API_VALIDATION
    635              if ( (ui64PinMask & ~(((uint64_t)1 << AM_HAL_GPIO_MAX_PADS) - 1))   ||
    636                   (num_bits64(ui64PinMask) > 8)                                  ||
    637                   (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_TRISTATE) )
    638              {
    639                  return AM_HAL_STATUS_INVALID_ARG;
    640              }
    641          #endif // AM_HAL_ENABLE_API_VALIDATION
    642          
    643              //
    644              // Roll through the pin mask and configure any designated pins per the
    645              // bfGpioCfg parameter, and enable for Fast GPIO.
    646              //
    647              ui32Mask = 0;
    648              ui32pinnum = 0;
    649              ux = 0;
    650              while ( ui64PinMask )
    651              {
    652                  if ( ui64PinMask & 0x1 )
    653                  {
    654                      //
    655                      // It is assumed that the caller will have disabled Fast GPIO and
    656                      // initialized the pin value before calling this function. Therefore
    657                      // no value initialization is done before the pin configuration, nor
    658                      // is the am_hal_gpio_fastgpio_disable() called here.
    659                      //
    660                      // Configure the pin.
    661                      //
    662                      ui32retval = am_hal_gpio_pinconfig(ui32pinnum, bfGpioCfg);
    663                      if ( ui32retval )
    664                      {
    665                          return ui32retval;
    666                      }
    667          
    668                      ui32Mask |= 1 << (ui32pinnum & 0x7);
    669          
    670                      //
    671                      // Enable the FAST GPIO for this pin
    672                      //
    673                      am_hal_gpio_fastgpio_enable(ui32pinnum);
    674          
    675                      if ( ui32Masks )
    676                      {
    677                          ui32Masks[ux + 0] = _VAL2FLD(APBDMA_BBSETCLEAR_SET,   ui32Mask);
    678                          ui32Masks[ux + 1] = _VAL2FLD(APBDMA_BBSETCLEAR_CLEAR, ui32Mask);
    679                      }
    680                      ux += 2;    // Get next indexes
    681                  }
    682                  ui32pinnum++;
    683                  ui64PinMask >>= 1;
    684              }
    685          
    686              return AM_HAL_STATUS_SUCCESS;
    687          
    688          } // am_hal_gpio_fast_pinconfig()
    689          
    690          //*****************************************************************************
    691          //
    692          //! @brief Read GPIO.
    693          //!
    694          //! @param ui32Pin    - pin number to be read.
    695          //! @param eReadType  - State type to read.  One of:
    696          //!     AM_HAL_GPIO_INPUT_READ
    697          //!     AM_HAL_GPIO_OUTPUT_READ
    698          //!     AM_HAL_GPIO_ENABLE_READ
    699          //! @param pui32ReadState - Pointer to the value to contain the read state.
    700          //!        When reading the value of a bit, will be either 0 or 1.
    701          //!
    702          //! This function reads a pin state as given by ui32Type.
    703          //!
    704          //! @return Status.
    705          //
    706          //*****************************************************************************
    707          uint32_t
    708          am_hal_gpio_state_read(uint32_t ui32Pin,
    709                                 am_hal_gpio_read_type_e eReadType,
    710                                 uint32_t *pui32ReadState)
    711          {
    712              uint32_t ui32ReadValue = 0xFFFFFFFF;
    713              uint32_t ui32BaseAddr, ui32Shift;
    714          
    715          #ifdef AM_HAL_ENABLE_API_VALIDATION
    716              if ( pui32ReadState == NULL )
    717              {
    718                  return AM_HAL_STATUS_INVALID_ARG;
    719              }
    720          
    721              if ( ui32Pin >= AM_HAL_GPIO_MAX_PADS )
    722              {
    723                  *pui32ReadState = ui32ReadValue;
    724                  return AM_HAL_STATUS_OUT_OF_RANGE;
    725              }
    726          #endif // AM_HAL_ENABLE_API_VALIDATION
    727          
    728              //
    729              // Compute base address + offset of 0 or 4.
    730              //
    731              ui32BaseAddr = ((ui32Pin & 0x20) >> (3 + 2));   // 0 or 1
    732              ui32Shift    = ui32Pin & 0x1F;
    733              //ui32Mask     = 1 << ui32Shift;
    734          
    735              switch ( eReadType )
    736              {
    737                  case AM_HAL_GPIO_INPUT_READ:
    738                      //
    739                      // Assumes eIntDir != AM_HAL_GPIO_PIN_INTDIR_NONE   &&
    740                      //         eIntDir != AM_HAL_GPIO_PIN_INTDIR_BOTH
    741                      // If either of those configs are set, returns 0.
    742                      //
    743                      ui32ReadValue = AM_REGVAL(&GPIO->RDA + ui32BaseAddr);
    744                      ui32ReadValue = (ui32ReadValue >> ui32Shift) & 0x01;
    745                      break;
    746                  case AM_HAL_GPIO_OUTPUT_READ:
    747                      ui32ReadValue = AM_REGVAL(&GPIO->WTA + ui32BaseAddr);
    748                      ui32ReadValue = (ui32ReadValue >> ui32Shift) & 0x01;
    749                      break;
    750                  case AM_HAL_GPIO_ENABLE_READ:
    751                      ui32ReadValue = AM_REGVAL(&GPIO->ENA + ui32BaseAddr);
    752                      ui32ReadValue = (ui32ReadValue >> ui32Shift) & 0x01;
    753                      break;
    754                  default:
    755                      return AM_HAL_STATUS_INVALID_ARG;
    756              }
    757          
    758              *pui32ReadState = ui32ReadValue;
    759          
    760              return AM_HAL_STATUS_SUCCESS;
    761          } // am_hal_gpio_state_read()
    762          
    763          //*****************************************************************************
    764          //
    765          //! @brief Write GPIO.
    766          //!
    767          //! @param ui32Pin    - pin number to be read.
    768          //!
    769          //! @param ui32Type   - State type to write.  One of:
    770          //!     AM_HAL_GPIO_OUTPUT_SET              - Write a one to a GPIO.
    771          //!     AM_HAL_GPIO_OUTPUT_CLEAR            - Write a zero to a GPIO.
    772          //!     AM_HAL_GPIO_OUTPUT_TOGGLE           - Toggle the GPIO value.
    773          //!     The following two apply when output is set for TriState (OUTCFG==3).
    774          //!     AM_HAL_GPIO_OUTPUT_TRISTATE_ENABLE  - Enable  a tri-state GPIO.
    775          //!     AM_HAL_GPIO_OUTPUT_TRISTATE_DISABLE - Disable a tri-state GPIO.
    776          //!
    777          //! This function writes a GPIO value.
    778          //!
    779          //! @return Status.
    780          //!         Fails if the pad is not configured for GPIO (PADFNCSEL != 3).
    781          //
    782          //*****************************************************************************
    783          uint32_t
    784          am_hal_gpio_state_write(uint32_t ui32Pin, am_hal_gpio_write_type_e eWriteType)
    785          {
    786              uint32_t ui32Mask, ui32Off;
    787              uint32_t ui32Return = AM_HAL_STATUS_SUCCESS;
    788          
    789          #ifdef AM_HAL_ENABLE_API_VALIDATION
    790              if ( ui32Pin >= AM_HAL_GPIO_MAX_PADS )
    791              {
    792                  return AM_HAL_STATUS_OUT_OF_RANGE;
    793              }
    794          
    795              if ( eWriteType > AM_HAL_GPIO_OUTPUT_TRISTATE_TOGGLE )
    796              {
    797                  return AM_HAL_STATUS_INVALID_ARG;
    798              }
    799          #endif // AM_HAL_ENABLE_API_VALIDATION
    800          
    801              ui32Mask = (uint32_t)0x1 << (ui32Pin % 32);
    802              ui32Off  = (ui32Pin & 0x20) >> 3;   // 0 or 4
    803          
    804              AM_CRITICAL_BEGIN;
    805          
    806              ui32Off /= 4;   // 0 or 1 for ptr arithmetic
    807              switch ( eWriteType )
    808              {
    809                  case AM_HAL_GPIO_OUTPUT_SET:                // Write a one to a GPIO.
    810                      AM_REGVAL(&GPIO->WTSA + ui32Off) = ui32Mask;
    811                      break;
    812                  case AM_HAL_GPIO_OUTPUT_CLEAR:              // Write a zero to a GPIO.
    813                      AM_REGVAL(&GPIO->WTCA + ui32Off) = ui32Mask;
    814                      break;
    815                  case AM_HAL_GPIO_OUTPUT_TOGGLE:             // Toggle the GPIO value.
    816                      AM_REGVAL(&GPIO->WTA + ui32Off) ^= ui32Mask;
    817                      break;
    818                  case AM_HAL_GPIO_OUTPUT_TRISTATE_ENABLE:    // Enable  a tri-state GPIO.
    819                      AM_REGVAL(&GPIO->ENSA + ui32Off) = ui32Mask;
    820                      break;
    821                  case AM_HAL_GPIO_OUTPUT_TRISTATE_DISABLE:   // Disable a tri-state GPIO.
    822                      AM_REGVAL(&GPIO->ENCA + ui32Off) = ui32Mask;
    823                      break;
    824                  case AM_HAL_GPIO_OUTPUT_TRISTATE_TOGGLE:   // Toggle a tri-state GPIO.
    825                      AM_REGVAL(&GPIO->ENCA + ui32Off) ^= ui32Mask;
    826                      break;
    827                  default:
    828                      // Type values were validated on entry.
    829                      // We can't return from here because we're in a critical section.
    830                      ui32Return = AM_HAL_STATUS_INVALID_ARG;
    831                      break;
    832              }
    833          
    834              AM_CRITICAL_END;
    835          
    836              return ui32Return;
    837          } // am_hal_gpio_state_write()
    838          
    839          //*****************************************************************************
    840          //
    841          // Enable GPIO interrupts.
    842          //
    843          //*****************************************************************************
    844          uint32_t
    845          am_hal_gpio_interrupt_enable(uint64_t ui64InterruptMask)
    846          {
    847          #ifdef AM_HAL_ENABLE_API_VALIDATION
    848              //
    849              // Check parameters
    850              //
    851              if ( ui64InterruptMask &  ~(((uint64_t)1 << AM_HAL_GPIO_MAX_PADS) - 1) )
    852              {
    853                  return AM_HAL_STATUS_OUT_OF_RANGE;
    854              }
    855          #endif // AM_HAL_ENABLE_API_VALIDATION
    856          
    857              //
    858              // Enable the interrupts.
    859              //
    860              AM_CRITICAL_BEGIN
    861          
    862              GPIO->INT0EN |= (uint32_t)(ui64InterruptMask & 0xFFFFFFFF);
    863              GPIO->INT1EN |= (uint32_t)(ui64InterruptMask >> 32);
    864          
    865              AM_CRITICAL_END
    866          
    867              //
    868              // Return the status.
    869              //
    870              return AM_HAL_STATUS_SUCCESS;
    871          
    872          } // am_hal_gpio_interrupt_enable()
    873          
    874          //*****************************************************************************
    875          //
    876          // Disable GPIO interrupts.
    877          //
    878          //*****************************************************************************
    879          uint32_t
    880          am_hal_gpio_interrupt_disable(uint64_t ui64InterruptMask)
    881          {
    882          #ifdef AM_HAL_ENABLE_API_VALIDATION
    883              //
    884              // Check parameters
    885              //
    886              if ( ui64InterruptMask &  ~(((uint64_t)1 << AM_HAL_GPIO_MAX_PADS) - 1) )
    887              {
    888                  return AM_HAL_STATUS_OUT_OF_RANGE;
    889              }
    890          #endif // AM_HAL_ENABLE_API_VALIDATION
    891          
    892              //
    893              // Disable the interrupts.
    894              //
    895              AM_CRITICAL_BEGIN
    896          
    897              GPIO->INT0EN &= ~((uint32_t)(ui64InterruptMask & 0xFFFFFFFF));
    898              GPIO->INT1EN &= ~((uint32_t)(ui64InterruptMask >> 32));
    899          
    900              AM_CRITICAL_END
    901          
    902              //
    903              // Return the status.
    904              //
    905              return AM_HAL_STATUS_SUCCESS;
    906          
    907          } // am_hal_gpio_interrupt_disable()
    908          
    909          //*****************************************************************************
    910          //
    911          // Clear GPIO interrupts.
    912          //
    913          //*****************************************************************************
    914          uint32_t
    915          am_hal_gpio_interrupt_clear(uint64_t ui64InterruptMask)
    916          {
    917          #ifdef AM_HAL_ENABLE_API_VALIDATION
    918              //
    919              // Check parameters
    920              //
    921              if ( ui64InterruptMask &  ~(((uint64_t)1 << AM_HAL_GPIO_MAX_PADS) - 1) )
    922              {
    923                  return AM_HAL_STATUS_OUT_OF_RANGE;
    924              }
    925          #endif // AM_HAL_ENABLE_API_VALIDATION
    926          
    927              //
    928              // Clear the interrupts.
    929              //
    930              AM_CRITICAL_BEGIN
    931          
    932              GPIO->INT0CLR = (uint32_t)(ui64InterruptMask & 0xFFFFFFFF);
    933              GPIO->INT1CLR = (uint32_t)(ui64InterruptMask >> 32);
    934          
    935              AM_CRITICAL_END
    936          
    937              //
    938              // Return the status.
    939              //
    940              return AM_HAL_STATUS_SUCCESS;
    941          
    942          } // am_hal_gpio_interrupt_clear()
    943          
    944          //*****************************************************************************
    945          //
    946          // Get GPIO interrupt status.
    947          //
    948          //*****************************************************************************
    949          uint32_t
    950          am_hal_gpio_interrupt_status_get(bool bEnabledOnly, uint64_t *pui64IntStatus)
    951          {
    952          
    953              uint64_t ui64RetVal, ui64Mask;
    954          
    955          #ifdef AM_HAL_ENABLE_API_VALIDATION
    956              if ( pui64IntStatus == NULL )
    957              {
    958                  return AM_HAL_STATUS_INVALID_ARG;
    959              }
    960          #endif // AM_HAL_ENABLE_API_VALIDATION
    961          
    962              //
    963              // Initialize variable outside critical section
    964              //
    965              ui64Mask   = 0xFFFFFFFFFFFFFFFF;
    966          
    967              //
    968              // Combine upper or lower GPIO words into one 64 bit return value.
    969              //
    970              AM_CRITICAL_BEGIN
    971          
    972              ui64RetVal  = ((uint64_t)GPIO->INT1STAT) << 32;
    973              ui64RetVal |= ((uint64_t)GPIO->INT0STAT) << 0;
    974          
    975              if ( bEnabledOnly )
    976              {
    977                  ui64Mask    = ((uint64_t)GPIO->INT1EN) << 32;
    978                  ui64Mask   |= ((uint64_t)GPIO->INT0EN) << 0;
    979              }
    980          
    981              ui64RetVal &= ui64Mask;
    982          
    983              *pui64IntStatus = ui64RetVal;
    984          
    985              AM_CRITICAL_END
    986          
    987              //
    988              // Return the status.
    989              //
    990              return AM_HAL_STATUS_SUCCESS;
    991          
    992          } // am_hal_gpio_interrupt_status_get()
    993          
    994          //*****************************************************************************
    995          //
    996          // GPIO interrupt service routine registration.
    997          //
    998          //*****************************************************************************
    999          uint32_t
   1000          am_hal_gpio_interrupt_register(uint32_t ui32GPIONumber,
   1001                                         am_hal_gpio_handler_t pfnHandler)
   1002          {
   1003          #ifdef AM_HAL_ENABLE_API_VALIDATION
   1004              //
   1005              // Check parameters
   1006              //
   1007              if ( ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS )
   1008              {
   1009                  return AM_HAL_STATUS_OUT_OF_RANGE;
   1010              }
   1011          
   1012              if ( pfnHandler == NULL )
   1013              {
   1014                  return AM_HAL_STATUS_INVALID_ARG;
   1015              }
   1016          #endif // AM_HAL_ENABLE_API_VALIDATION
   1017          
   1018              //
   1019              // Store the handler function pointer.
   1020              //
   1021              gpio_ppfnHandlers[ui32GPIONumber] = pfnHandler;
   1022          
   1023              //
   1024              // Return the status.
   1025              //
   1026              return AM_HAL_STATUS_SUCCESS;
   1027          
   1028          } // am_hal_gpio_interrupt_register()
   1029          
   1030          //*****************************************************************************
   1031          //
   1032          // GPIO interrupt service routine.
   1033          //
   1034          //*****************************************************************************
   1035          uint32_t
   1036          am_hal_gpio_interrupt_service(uint64_t ui64Status)
   1037          {
   1038              uint32_t ui32RetStatus = AM_HAL_STATUS_SUCCESS;
   1039              uint32_t ui32Status, ui32Clz, ui32FFS, ui32Cnt;
   1040          
   1041              am_hal_gpio_handler_t pfnHandler;
   1042          
   1043          #ifdef AM_HAL_ENABLE_API_VALIDATION
   1044              //
   1045              // Check parameters
   1046              //
   1047              if ( ui64Status  &  ~(((uint64_t)1 << AM_HAL_GPIO_MAX_PADS) - 1) )
   1048              {
   1049                  return AM_HAL_STATUS_OUT_OF_RANGE;
   1050              }
   1051          
   1052              if ( ui64Status == 0 )
   1053              {
   1054                  return AM_HAL_STATUS_FAIL;
   1055              }
   1056          #endif // AM_HAL_ENABLE_API_VALIDATION
   1057          
   1058              //
   1059              // Handle interrupts.
   1060              // The 1st iteration handles any active interrupts in the lower 32 bits.
   1061              // The 2nd iteration handles any active interrupts in the upper 32 bits.
   1062              // (The order of handling upper or lower bits is somewhat arbitrary.)
   1063              //
   1064              ui32Cnt = 0;
   1065              while ( ui32Cnt < 33 )
   1066              {
   1067                  //
   1068                  // Get upper or lower status word.
   1069                  //
   1070                  ui32Status = (uint32_t)(ui64Status >> ui32Cnt);
   1071          
   1072                  while ( ui32Status )
   1073                  {
   1074                      //
   1075                      // We need to FFS (Find First Set).  We can easily zero-base FFS
   1076                      // since we know that at least 1 bit is set in ui32Status.
   1077                      // FFS(x) = 31 - clz(x & -x).       // Zero-based version of FFS.
   1078                      //
   1079                      ui32FFS = ui32Status & (uint32_t)(-(int32_t)ui32Status);
   1080          #ifdef __IAR_SYSTEMS_ICC__
   1081                      ui32Clz = __CLZ(ui32FFS);
   1082          #else
   1083                      ui32Clz = __builtin_clz(ui32FFS);
   1084          #endif
   1085                      ui32FFS = 31 - ui32Clz;
   1086          
   1087                      //
   1088                      // Turn off the bit we picked in the working copy
   1089                      //
   1090                      ui32Status &= ~(0x00000001 << ui32FFS);
   1091          
   1092                      //
   1093                      // Check the bit handler table to see if there is an interrupt handler
   1094                      // registered for this particular bit.
   1095                      //
   1096                      pfnHandler = gpio_ppfnHandlers[ui32Cnt + ui32FFS];
   1097                      if ( pfnHandler )
   1098                      {
   1099                          //
   1100                          // If we found an interrupt handler routine, call it now.
   1101                          //
   1102                          pfnHandler();
   1103                      }
   1104                      else
   1105                      {
   1106                          //
   1107                          // No handler was registered for the GPIO that interrupted.
   1108                          // Return an error.
   1109                          //
   1110                          ui32RetStatus = AM_HAL_STATUS_INVALID_OPERATION;
   1111                      }
   1112                  }
   1113                  ui32Cnt += 32;
   1114              }
   1115          
   1116              //
   1117              // Return the status.
   1118              //
   1119              return ui32RetStatus;
   1120          
   1121          } // am_hal_gpio_interrupt_service()
   1122          
   1123          
   1124          //*****************************************************************************
   1125          //
   1126          // End Doxygen group.
   1127          //! @}
   1128          //
   1129          //*****************************************************************************

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   am_hal_gpio_fast_pinconfig
        40   -> am_hal_gpio_pinconfig
        40   -> num_bits64
      16   am_hal_gpio_interrupt_clear
        16   -> am_hal_interrupt_master_disable
        16   -> am_hal_interrupt_master_set
      16   am_hal_gpio_interrupt_disable
        16   -> am_hal_interrupt_master_disable
        16   -> am_hal_interrupt_master_set
      16   am_hal_gpio_interrupt_enable
        16   -> am_hal_interrupt_master_disable
        16   -> am_hal_interrupt_master_set
       0   am_hal_gpio_interrupt_register
      40   am_hal_gpio_interrupt_service
        40   -- Indirect call
        40 __aeabi_llsr
      32   am_hal_gpio_interrupt_status_get
        32   -> am_hal_interrupt_master_disable
        32   -> am_hal_interrupt_master_set
      72   am_hal_gpio_pinconfig
        72   -> am_hal_interrupt_master_disable
        72   -> am_hal_interrupt_master_set
        72   -> pincfg_equ
      16   am_hal_gpio_state_read
      32   am_hal_gpio_state_write
        32   -> am_hal_interrupt_master_disable
        32   -> am_hal_interrupt_master_set
       0   num_bits64
       0   pincfg_equ


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_16
       4  ??DataTable10_17
       4  ??DataTable10_18
       4  ??DataTable10_19
       4  ??DataTable10_2
       4  ??DataTable10_20
       4  ??DataTable10_21
       4  ??DataTable10_22
       4  ??DataTable10_23
       4  ??DataTable10_24
       4  ??DataTable10_25
       4  ??DataTable10_26
       4  ??DataTable10_27
       4  ??DataTable10_28
       4  ??DataTable10_29
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
     178  am_hal_gpio_fast_pinconfig
      50  am_hal_gpio_interrupt_clear
      58  am_hal_gpio_interrupt_disable
      58  am_hal_gpio_interrupt_enable
      30  am_hal_gpio_interrupt_register
     134  am_hal_gpio_interrupt_service
     108  am_hal_gpio_interrupt_status_get
     674  am_hal_gpio_pinconfig
     104  am_hal_gpio_state_read
     162  am_hal_gpio_state_write
       4  g_AM_HAL_GPIO_DISABLE
       4  g_AM_HAL_GPIO_INPUT
       4  g_AM_HAL_GPIO_OUTPUT
       4  g_AM_HAL_GPIO_OUTPUT_12
       4  g_AM_HAL_GPIO_OUTPUT_4
       4  g_AM_HAL_GPIO_OUTPUT_8
       4  g_AM_HAL_GPIO_OUTPUT_WITH_READ
       4  g_AM_HAL_GPIO_TRISTATE
      52  g_ui8Bit76Capabilities
      52  g_ui8Inpen
     200  g_ui8NCEtable
      52  g_ui8nCEpins
     200  gpio_ppfnHandlers
      32  num_bits64
      18  pincfg_equ

 
   200 bytes in section .bss
   388 bytes in section .rodata
 1 726 bytes in section .text
 
 1 726 bytes of CODE  memory
   388 bytes of CONST memory
   200 bytes of DATA  memory

Errors: none
Warnings: none
