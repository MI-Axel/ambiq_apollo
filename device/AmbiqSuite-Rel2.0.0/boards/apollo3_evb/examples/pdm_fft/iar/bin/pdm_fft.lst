###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         23/Jan/2019  17:45:14
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\pdm_fft\src\pdm_fft.c
#    Command line =  
#        -f C:\temp\EWA221.tmp
#        (C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\pdm_fft\src\pdm_fft.c
#        -D iar -D __FPU_PRESENT -D AM_PART_APOLLO3 -D UNITY_INCLUDE_CONFIG_H
#        -D AM_UTIL_FAULTISR_PRINT -D AM_PACKAGE_BGA -lcN
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\pdm_fft\iar\bin
#        --diag_suppress Pa050 -o
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\pdm_fft\iar\bin
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\pdm_fft\iar\..\..\..\..\..\mcu\apollo3\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\pdm_fft\iar\..\..\..\..\..\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\pdm_fft\iar\..\src\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\pdm_fft\iar\..\..\..\..\..\CMSIS\AmbiqMicro\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\pdm_fft\iar\..\..\..\..\..\utils\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\pdm_fft\iar\..\..\..\..\..\devices\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\pdm_fft\iar\..\..\..\bsp\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\pdm_fft\iar\..\..\..\..\..CMSIS\ARM\Include\
#        -I
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\pdm_fft\iar\..\..\..\..\..\CMSIS\ARM\Include\
#        -Ohs --no_size_constraints)
#    Locale       =  C
#    List file    =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\pdm_fft\iar\bin\pdm_fft.lst
#    Object file  =  
#        C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\pdm_fft\iar\bin\pdm_fft.o
#
###############################################################################

C:\Users\agao\ambiq_apollo\device\AmbiqSuite-Rel2.0.0\boards\apollo3_evb\examples\pdm_fft\src\pdm_fft.c
      1          //*****************************************************************************
      2          //
      3          //! @file pdm_fft.c
      4          //!
      5          //! @brief An example to show basic PDM operation.
      6          //!
      7          //! This example enables the PDM interface to record audio signals from an
      8          //! external microphone. The required pin connections are:
      9          //!
     10          //! GPIO 10 - PDM DATA
     11          //! GPIO 11 - PDM CLK
     12          //
     13          //*****************************************************************************
     14          
     15          //*****************************************************************************
     16          //
     17          // Copyright (c) 2019, Ambiq Micro
     18          // All rights reserved.
     19          // 
     20          // Redistribution and use in source and binary forms, with or without
     21          // modification, are permitted provided that the following conditions are met:
     22          // 
     23          // 1. Redistributions of source code must retain the above copyright notice,
     24          // this list of conditions and the following disclaimer.
     25          // 
     26          // 2. Redistributions in binary form must reproduce the above copyright
     27          // notice, this list of conditions and the following disclaimer in the
     28          // documentation and/or other materials provided with the distribution.
     29          // 
     30          // 3. Neither the name of the copyright holder nor the names of its
     31          // contributors may be used to endorse or promote products derived from this
     32          // software without specific prior written permission.
     33          // 
     34          // Third party software included in this distribution is subject to the
     35          // additional license terms as defined in the /docs/licenses directory.
     36          // 
     37          // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     38          // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     39          // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     40          // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     41          // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     42          // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     43          // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     44          // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     45          // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     46          // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     47          // POSSIBILITY OF SUCH DAMAGE.
     48          //
     49          // This is part of revision v2.0.0 of the AmbiqSuite Development Package.
     50          //
     51          //*****************************************************************************
     52          
     53          #define ARM_MATH_CM4
     54          #include <arm_math.h>
     55          
     56          #include "am_mcu_apollo.h"
     57          #include "am_bsp.h"
     58          #include "am_util.h"
     59          
     60          //*****************************************************************************
     61          //
     62          // Example parameters.
     63          //
     64          //*****************************************************************************
     65          #define PDM_FFT_SIZE                4096
     66          #define PDM_FFT_BYTES               (PDM_FFT_SIZE * 2)
     67          #define PRINT_PDM_DATA              0
     68          #define PRINT_FFT_DATA              0
     69          
     70          //*****************************************************************************
     71          //
     72          // Global variables.
     73          //
     74          //*****************************************************************************
     75          volatile bool g_bPDMDataReady = false;
     76          uint32_t g_ui32PDMDataBuffer[PDM_FFT_SIZE];
     77          float g_fPDMTimeDomain[PDM_FFT_SIZE * 2];
     78          float g_fPDMFrequencyDomain[PDM_FFT_SIZE * 2];
     79          float g_fPDMMagnitudes[PDM_FFT_SIZE * 2];
     80          uint32_t g_ui32SampleFreq;
     81          
     82          //*****************************************************************************
     83          //
     84          // PDM configuration information.
     85          //
     86          //*****************************************************************************
     87          void *PDMHandle;
     88          
     89          am_hal_pdm_config_t g_sPdmConfig =
     90          {
     91              .eClkDivider = AM_HAL_PDM_MCLKDIV_1,
     92              .eLeftGain = AM_HAL_PDM_GAIN_0DB,
     93              .eRightGain = AM_HAL_PDM_GAIN_0DB,
     94              .ui32DecimationRate = 64,
     95              .bHighPassEnable = 0,
     96              .ui32HighPassCutoff = 0xB,
     97              .ePDMClkSpeed = AM_HAL_PDM_CLK_6MHZ,
     98              .bInvertI2SBCLK = 0,
     99              .ePDMClkSource = AM_HAL_PDM_INTERNAL_CLK,
    100              .bPDMSampleDelay = 0,
    101              .bDataPacking = 1,
    102              .ePCMChannels = AM_HAL_PDM_CHANNEL_RIGHT,
    103              .bLRSwap = 0,
    104          };
    105          
    106          //*****************************************************************************
    107          //
    108          // PDM initialization.
    109          //
    110          //*****************************************************************************
    111          void
    112          pdm_init(void)
    113          {
    114              //
    115              // Initialize, power-up, and configure the PDM.
    116              //
    117              am_hal_pdm_initialize(0, &PDMHandle);
    118              am_hal_pdm_power_control(PDMHandle, AM_HAL_PDM_POWER_ON, false);
    119              am_hal_pdm_configure(PDMHandle, &g_sPdmConfig);
    120              am_hal_pdm_enable(PDMHandle);
    121          
    122              //
    123              // Configure the necessary pins.
    124              //
    125              am_hal_gpio_pincfg_t sPinCfg = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    126          
    127              sPinCfg.uFuncSel = AM_HAL_PIN_11_PDMDATA;
    128              am_hal_gpio_pinconfig(11, sPinCfg);
    129          
    130              sPinCfg.uFuncSel = AM_HAL_PIN_12_PDMCLK;
    131              am_hal_gpio_pinconfig(12, sPinCfg);
    132          
    133              am_hal_gpio_state_write(14, AM_HAL_GPIO_OUTPUT_CLEAR);
    134              am_hal_gpio_pinconfig(14, g_AM_HAL_GPIO_OUTPUT);
    135          
    136              //
    137              // Configure and enable PDM interrupts (set up to trigger on DMA
    138              // completion).
    139              //
    140              am_hal_pdm_interrupt_enable(PDMHandle, (AM_HAL_PDM_INT_DERR
    141                                                      | AM_HAL_PDM_INT_DCMP
    142                                                      | AM_HAL_PDM_INT_UNDFL
    143                                                      | AM_HAL_PDM_INT_OVF));
    144          
    145              NVIC_EnableIRQ(PDM_IRQn);
    146          }
    147          
    148          //*****************************************************************************
    149          //
    150          // Print PDM configuration data.
    151          //
    152          //*****************************************************************************
    153          void
    154          pdm_config_print(void)
    155          {
    156              uint32_t ui32PDMClk;
    157              uint32_t ui32MClkDiv;
    158              float fFrequencyUnits;
    159          
    160              //
    161              // Read the config structure to figure out what our internal clock is set
    162              // to.
    163              //
    164              switch (g_sPdmConfig.eClkDivider)
    165              {
    166                  case AM_HAL_PDM_MCLKDIV_4: ui32MClkDiv = 4; break;
    167                  case AM_HAL_PDM_MCLKDIV_3: ui32MClkDiv = 3; break;
    168                  case AM_HAL_PDM_MCLKDIV_2: ui32MClkDiv = 2; break;
    169                  case AM_HAL_PDM_MCLKDIV_1: ui32MClkDiv = 1; break;
    170          
    171                  default:
    172                      ui32MClkDiv = 0;
    173              }
    174          
    175              switch (g_sPdmConfig.ePDMClkSpeed)
    176              {
    177                  case AM_HAL_PDM_CLK_12MHZ:  ui32PDMClk = 12000000; break;
    178                  case AM_HAL_PDM_CLK_6MHZ:   ui32PDMClk =  6000000; break;
    179                  case AM_HAL_PDM_CLK_3MHZ:   ui32PDMClk =  3000000; break;
    180                  case AM_HAL_PDM_CLK_1_5MHZ: ui32PDMClk =  1500000; break;
    181                  case AM_HAL_PDM_CLK_750KHZ: ui32PDMClk =   750000; break;
    182                  case AM_HAL_PDM_CLK_375KHZ: ui32PDMClk =   375000; break;
    183                  case AM_HAL_PDM_CLK_187KHZ: ui32PDMClk =   187000; break;
    184          
    185                  default:
    186                      ui32PDMClk = 0;
    187              }
    188          
    189              //
    190              // Record the effective sample frequency. We'll need it later to print the
    191              // loudest frequency from the sample.
    192              //
    193              g_ui32SampleFreq = (ui32PDMClk /
    194                                  (ui32MClkDiv * 2 * g_sPdmConfig.ui32DecimationRate));
    195          
    196              fFrequencyUnits = (float) g_ui32SampleFreq / (float) PDM_FFT_SIZE;
    197          
    198              am_util_stdio_printf("Settings:\n");
    199              am_util_stdio_printf("PDM Clock (Hz):         %12d\n", ui32PDMClk);
    200              am_util_stdio_printf("Decimation Rate:        %12d\n", g_sPdmConfig.ui32DecimationRate);
    201              am_util_stdio_printf("Effective Sample Freq.: %12d\n", g_ui32SampleFreq);
    202              am_util_stdio_printf("FFT Length:             %12d\n\n", PDM_FFT_SIZE);
    203              am_util_stdio_printf("FFT Resolution: %15.3f Hz\n", fFrequencyUnits);
    204          }
    205          
    206          //*****************************************************************************
    207          //
    208          // Start a transaction to get some number of bytes from the PDM interface.
    209          //
    210          //*****************************************************************************
    211          void
    212          pdm_data_get(void)
    213          {
    214              //
    215              // Configure DMA and target address.
    216              //
    217              am_hal_pdm_transfer_t sTransfer;
    218              sTransfer.ui32TargetAddr = (uint32_t ) g_ui32PDMDataBuffer;
    219              sTransfer.ui32TotalCount = PDM_FFT_BYTES;
    220          
    221              //
    222              // Start the data transfer.
    223              //
    224              am_hal_pdm_enable(PDMHandle);
    225              am_util_delay_ms(100);
    226              am_hal_pdm_fifo_flush(PDMHandle);
    227              am_hal_pdm_dma_start(PDMHandle, &sTransfer);
    228          }
    229          
    230          //*****************************************************************************
    231          //
    232          // PDM interrupt handler.
    233          //
    234          //*****************************************************************************
    235          void
    236          am_pdm0_isr(void)
    237          {
    238              uint32_t ui32Status;
    239          
    240              //
    241              // Read the interrupt status.
    242              //
    243              am_hal_pdm_interrupt_status_get(PDMHandle, &ui32Status, true);
    244              am_hal_pdm_interrupt_clear(PDMHandle, ui32Status);
    245          
    246              //
    247              // Once our DMA transaction completes, we will disable the PDM and send a
    248              // flag back down to the main routine. Disabling the PDM is only necessary
    249              // because this example only implemented a single buffer for storing FFT
    250              // data. More complex programs could use a system of multiple buffers to
    251              // allow the CPU to run the FFT in one buffer while the DMA pulls PCM data
    252              // into another buffer.
    253              //
    254              if (ui32Status & AM_HAL_PDM_INT_DCMP)
    255              {
    256                  am_hal_pdm_disable(PDMHandle);
    257                  g_bPDMDataReady = true;
    258              }
    259          }
    260          
    261          //*****************************************************************************
    262          //
    263          // Analyze and print frequency data.
    264          //
    265          //*****************************************************************************
    266          void
    267          pcm_fft_print(void)
    268          {
    269              float fMaxValue;
    270              uint32_t ui32MaxIndex;
    271              int16_t *pi16PDMData = (int16_t *) g_ui32PDMDataBuffer;
    272              uint32_t ui32LoudestFrequency;
    273          
    274              //
    275              // Convert the PDM samples to floats, and arrange them in the format
    276              // required by the FFT function.
    277              //
    278              for (uint32_t i = 0; i < PDM_FFT_SIZE; i++)
    279              {
    280                  if (PRINT_PDM_DATA)
    281                  {
    282                      am_util_stdio_printf("%d\n", pi16PDMData[i]);
    283                  }
    284          
    285                  g_fPDMTimeDomain[2 * i] = pi16PDMData[i] / 1.0;
    286                  g_fPDMTimeDomain[2 * i + 1] = 0.0;
    287              }
    288          
    289              if (PRINT_PDM_DATA)
    290              {
    291                  am_util_stdio_printf("END\n");
    292              }
    293          
    294              //
    295              // Perform the FFT.
    296              //
    297              arm_cfft_radix4_instance_f32 S;
    298              arm_cfft_radix4_init_f32(&S, PDM_FFT_SIZE, 0, 1);
    299              arm_cfft_radix4_f32(&S, g_fPDMTimeDomain);
    300              arm_cmplx_mag_f32(g_fPDMTimeDomain, g_fPDMMagnitudes, PDM_FFT_SIZE);
    301          
    302              if (PRINT_FFT_DATA)
    303              {
    304                  for (uint32_t i = 0; i < PDM_FFT_SIZE / 2; i++)
    305                  {
    306                      am_util_stdio_printf("%f\n", g_fPDMMagnitudes[i]);
    307                  }
    308          
    309                  am_util_stdio_printf("END\n");
    310              }
    311          
    312              //
    313              // Find the frequency bin with the largest magnitude.
    314              //
    315              arm_max_f32(g_fPDMMagnitudes, PDM_FFT_SIZE / 2, &fMaxValue, &ui32MaxIndex);
    316          
    317              ui32LoudestFrequency = (g_ui32SampleFreq * ui32MaxIndex) / PDM_FFT_SIZE;
    318          
    319              if (PRINT_FFT_DATA)
    320              {
    321                  am_util_stdio_printf("Loudest frequency bin: %d\n", ui32MaxIndex);
    322              }
    323          
    324              am_util_stdio_printf("Loudest frequency: %d         \r", ui32LoudestFrequency);
    325          }
    326          
    327          //*****************************************************************************
    328          //
    329          // Main
    330          //
    331          //*****************************************************************************
    332          int
    333          main(void)
    334          {
    335              //
    336              // Perform the standard initialzation for clocks, cache settings, and
    337              // board-level low-power operation.
    338              //
    339              am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_SYSCLK_MAX, 0);
    340              am_hal_cachectrl_config(&am_hal_cachectrl_defaults);
    341              am_hal_cachectrl_enable();
    342              //am_bsp_low_power_init();
    343          
    344              //
    345              // Initialize the printf interface for ITM output
    346              //
    347              am_bsp_itm_printf_enable();
    348          
    349              //
    350              // Print the banner.
    351              //
    352              am_util_stdio_terminal_clear();
    353              am_util_stdio_printf("PDM FFT example.\n\n");
    354          
    355              //
    356              // Turn on the PDM, set it up for our chosen recording settings, and start
    357              // the first DMA transaction.
    358              //
    359              pdm_init();
    360              pdm_config_print();
    361              am_hal_pdm_fifo_flush(PDMHandle);
    362              pdm_data_get();
    363          
    364              //
    365              // Loop forever while sleeping.
    366              //
    367              while (1)
    368              {
    369                  am_hal_interrupt_master_disable();
    370          
    371                  if (g_bPDMDataReady)
    372                  {
    373                      g_bPDMDataReady = false;
    374          
    375                      pcm_fft_print();
    376          
    377                      while (PRINT_PDM_DATA || PRINT_FFT_DATA);
    378          
    379                      //
    380                      // Start converting the next set of PCM samples.
    381                      //
    382                      pdm_data_get();
    383                  }
    384          
    385                  //
    386                  // Go to Deep Sleep.
    387                  //
    388                  am_hal_sysctrl_sleep(AM_HAL_SYSCTRL_SLEEP_DEEP);
    389          
    390                  am_hal_interrupt_master_enable();
    391              }
    392          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   am_pdm0_isr
        16   -> am_hal_pdm_disable
        16   -> am_hal_pdm_interrupt_clear
        16   -> am_hal_pdm_interrupt_status_get
      64   main
        64   -> __aeabi_f2d
        64   -> am_bsp_itm_printf_enable
        64   -> am_hal_cachectrl_config
        64   -> am_hal_cachectrl_enable
        64   -> am_hal_clkgen_control
        64   -> am_hal_gpio_pinconfig
        64   -> am_hal_gpio_state_write
        64   -> am_hal_interrupt_master_disable
        64   -> am_hal_interrupt_master_enable
        64   -> am_hal_pdm_configure
        64   -> am_hal_pdm_dma_start
        64   -> am_hal_pdm_enable
        64   -> am_hal_pdm_fifo_flush
        64   -> am_hal_pdm_initialize
        64   -> am_hal_pdm_interrupt_enable
        64   -> am_hal_pdm_power_control
        64   -> am_hal_sysctrl_sleep
        64   -> am_util_delay_ms
        64   -> am_util_stdio_printf
        64   -> am_util_stdio_terminal_clear
        64   -> arm_cfft_radix4_f32
        64   -> arm_cfft_radix4_init_f32
        64   -> arm_cmplx_mag_f32
        64   -> arm_max_f32
      48   pcm_fft_print
        48   -> am_util_stdio_printf
        48   -> arm_cfft_radix4_f32
        48   -> arm_cfft_radix4_init_f32
        48   -> arm_cmplx_mag_f32
        48   -> arm_max_f32
      24   pdm_config_print
        24   -> __aeabi_f2d
         0   -> am_util_stdio_printf
        24   -> am_util_stdio_printf
      16   pdm_data_get
        16   -> am_hal_pdm_dma_start
        16   -> am_hal_pdm_enable
        16   -> am_hal_pdm_fifo_flush
        16   -> am_util_delay_ms
      16   pdm_init
        16   -> am_hal_gpio_pinconfig
        16   -> am_hal_gpio_state_write
        16   -> am_hal_pdm_configure
        16   -> am_hal_pdm_enable
        16   -> am_hal_pdm_initialize
        16   -> am_hal_pdm_interrupt_enable
        16   -> am_hal_pdm_power_control


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_12
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
       4  ?_0
      12  ?_1
      32  ?_2
      32  ?_3
      32  ?_4
      32  ?_5
      28  ?_6
      32  ?_7
      20  ?_8
      46  am_pdm0_isr
   32768  g_fPDMFrequencyDomain
   32768  g_fPDMTimeDomain
   32812  g_sPdmConfig
          g_bPDMDataReady
          g_ui32SampleFreq
          PDMHandle
          g_fPDMMagnitudes
   16384  g_ui32PDMDataBuffer
     582  main
     172  pcm_fft_print
     208  pdm_config_print
      48  pdm_data_get
     116  pdm_init

 
 81 920 bytes in section .bss
 32 812 bytes in section .data
  1 448 bytes in section .text
 
   1 448 bytes of CODE memory
 114 732 bytes of DATA memory

Errors: none
Warnings: none
