
bin/audio_experiment.axf:     file format elf32-littlearm


Disassembly of section .text:

0000c000 <g_am_pfnVectors>:
    c000:	00 10 00 10 bd dc 00 00 b5 dc 00 00 ed cc 00 00     ................
    c010:	ed cc 00 00 ed cc 00 00 ed cc 00 00 00 00 00 00     ................
	...
    c02c:	b9 dc 00 00 b9 dc 00 00 00 00 00 00 b9 dc 00 00     ................
    c03c:	b9 dc 00 00 b9 dc 00 00 b9 dc 00 00 b9 dc 00 00     ................
    c04c:	b9 dc 00 00 b9 dc 00 00 b9 dc 00 00 b9 dc 00 00     ................
    c05c:	b9 dc 00 00 b9 dc 00 00 b9 dc 00 00 b9 dc 00 00     ................
    c06c:	b9 dc 00 00 b9 dc 00 00 7d dd 00 00 69 dd 00 00     ........}...i...
    c07c:	b9 dc 00 00 b9 dc 00 00 b9 dc 00 00 b9 dc 00 00     ................
    c08c:	5d de 00 00 b9 dc 00 00 b9 dc 00 00 b9 dc 00 00     ]...............
    c09c:	b9 dc 00 00 b9 dc 00 00 b9 dc 00 00 b9 dc 00 00     ................
    c0ac:	b9 dc 00 00 b9 dc 00 00 b9 dc 00 00 b9 dc 00 00     ................
    c0bc:	b9 dc 00 00 b9 dc 00 00 b9 dc 00 00 b9 dc 00 00     ................
    c0cc:	b9 dc 00 00                                         ....

0000c0d0 <__Patchable>:
	...

0000c100 <memcpy>:
    c100:	4684      	mov	ip, r0
    c102:	ea41 0300 	orr.w	r3, r1, r0
    c106:	f013 0303 	ands.w	r3, r3, #3
    c10a:	d16d      	bne.n	c1e8 <memcpy+0xe8>
    c10c:	3a40      	subs	r2, #64	; 0x40
    c10e:	d341      	bcc.n	c194 <memcpy+0x94>
    c110:	f851 3b04 	ldr.w	r3, [r1], #4
    c114:	f840 3b04 	str.w	r3, [r0], #4
    c118:	f851 3b04 	ldr.w	r3, [r1], #4
    c11c:	f840 3b04 	str.w	r3, [r0], #4
    c120:	f851 3b04 	ldr.w	r3, [r1], #4
    c124:	f840 3b04 	str.w	r3, [r0], #4
    c128:	f851 3b04 	ldr.w	r3, [r1], #4
    c12c:	f840 3b04 	str.w	r3, [r0], #4
    c130:	f851 3b04 	ldr.w	r3, [r1], #4
    c134:	f840 3b04 	str.w	r3, [r0], #4
    c138:	f851 3b04 	ldr.w	r3, [r1], #4
    c13c:	f840 3b04 	str.w	r3, [r0], #4
    c140:	f851 3b04 	ldr.w	r3, [r1], #4
    c144:	f840 3b04 	str.w	r3, [r0], #4
    c148:	f851 3b04 	ldr.w	r3, [r1], #4
    c14c:	f840 3b04 	str.w	r3, [r0], #4
    c150:	f851 3b04 	ldr.w	r3, [r1], #4
    c154:	f840 3b04 	str.w	r3, [r0], #4
    c158:	f851 3b04 	ldr.w	r3, [r1], #4
    c15c:	f840 3b04 	str.w	r3, [r0], #4
    c160:	f851 3b04 	ldr.w	r3, [r1], #4
    c164:	f840 3b04 	str.w	r3, [r0], #4
    c168:	f851 3b04 	ldr.w	r3, [r1], #4
    c16c:	f840 3b04 	str.w	r3, [r0], #4
    c170:	f851 3b04 	ldr.w	r3, [r1], #4
    c174:	f840 3b04 	str.w	r3, [r0], #4
    c178:	f851 3b04 	ldr.w	r3, [r1], #4
    c17c:	f840 3b04 	str.w	r3, [r0], #4
    c180:	f851 3b04 	ldr.w	r3, [r1], #4
    c184:	f840 3b04 	str.w	r3, [r0], #4
    c188:	f851 3b04 	ldr.w	r3, [r1], #4
    c18c:	f840 3b04 	str.w	r3, [r0], #4
    c190:	3a40      	subs	r2, #64	; 0x40
    c192:	d2bd      	bcs.n	c110 <memcpy+0x10>
    c194:	3230      	adds	r2, #48	; 0x30
    c196:	d311      	bcc.n	c1bc <memcpy+0xbc>
    c198:	f851 3b04 	ldr.w	r3, [r1], #4
    c19c:	f840 3b04 	str.w	r3, [r0], #4
    c1a0:	f851 3b04 	ldr.w	r3, [r1], #4
    c1a4:	f840 3b04 	str.w	r3, [r0], #4
    c1a8:	f851 3b04 	ldr.w	r3, [r1], #4
    c1ac:	f840 3b04 	str.w	r3, [r0], #4
    c1b0:	f851 3b04 	ldr.w	r3, [r1], #4
    c1b4:	f840 3b04 	str.w	r3, [r0], #4
    c1b8:	3a10      	subs	r2, #16
    c1ba:	d2ed      	bcs.n	c198 <memcpy+0x98>
    c1bc:	320c      	adds	r2, #12
    c1be:	d305      	bcc.n	c1cc <memcpy+0xcc>
    c1c0:	f851 3b04 	ldr.w	r3, [r1], #4
    c1c4:	f840 3b04 	str.w	r3, [r0], #4
    c1c8:	3a04      	subs	r2, #4
    c1ca:	d2f9      	bcs.n	c1c0 <memcpy+0xc0>
    c1cc:	3204      	adds	r2, #4
    c1ce:	d008      	beq.n	c1e2 <memcpy+0xe2>
    c1d0:	07d2      	lsls	r2, r2, #31
    c1d2:	bf1c      	itt	ne
    c1d4:	f811 3b01 	ldrbne.w	r3, [r1], #1
    c1d8:	f800 3b01 	strbne.w	r3, [r0], #1
    c1dc:	d301      	bcc.n	c1e2 <memcpy+0xe2>
    c1de:	880b      	ldrh	r3, [r1, #0]
    c1e0:	8003      	strh	r3, [r0, #0]
    c1e2:	4660      	mov	r0, ip
    c1e4:	4770      	bx	lr
    c1e6:	bf00      	nop
    c1e8:	2a08      	cmp	r2, #8
    c1ea:	d313      	bcc.n	c214 <memcpy+0x114>
    c1ec:	078b      	lsls	r3, r1, #30
    c1ee:	d08d      	beq.n	c10c <memcpy+0xc>
    c1f0:	f010 0303 	ands.w	r3, r0, #3
    c1f4:	d08a      	beq.n	c10c <memcpy+0xc>
    c1f6:	f1c3 0304 	rsb	r3, r3, #4
    c1fa:	1ad2      	subs	r2, r2, r3
    c1fc:	07db      	lsls	r3, r3, #31
    c1fe:	bf1c      	itt	ne
    c200:	f811 3b01 	ldrbne.w	r3, [r1], #1
    c204:	f800 3b01 	strbne.w	r3, [r0], #1
    c208:	d380      	bcc.n	c10c <memcpy+0xc>
    c20a:	f831 3b02 	ldrh.w	r3, [r1], #2
    c20e:	f820 3b02 	strh.w	r3, [r0], #2
    c212:	e77b      	b.n	c10c <memcpy+0xc>
    c214:	3a04      	subs	r2, #4
    c216:	d3d9      	bcc.n	c1cc <memcpy+0xcc>
    c218:	3a01      	subs	r2, #1
    c21a:	f811 3b01 	ldrb.w	r3, [r1], #1
    c21e:	f800 3b01 	strb.w	r3, [r0], #1
    c222:	d2f9      	bcs.n	c218 <memcpy+0x118>
    c224:	780b      	ldrb	r3, [r1, #0]
    c226:	7003      	strb	r3, [r0, #0]
    c228:	784b      	ldrb	r3, [r1, #1]
    c22a:	7043      	strb	r3, [r0, #1]
    c22c:	788b      	ldrb	r3, [r1, #2]
    c22e:	7083      	strb	r3, [r0, #2]
    c230:	4660      	mov	r0, ip
    c232:	4770      	bx	lr

0000c234 <__aeabi_d2f>:
    c234:	ea4f 0241 	mov.w	r2, r1, lsl #1
    c238:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
    c23c:	bf24      	itt	cs
    c23e:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
    c242:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
    c246:	d90d      	bls.n	c264 <__aeabi_d2f+0x30>
    c248:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    c24c:	ea4f 02c0 	mov.w	r2, r0, lsl #3
    c250:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
    c254:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
    c258:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
    c25c:	bf08      	it	eq
    c25e:	f020 0001 	biceq.w	r0, r0, #1
    c262:	4770      	bx	lr
    c264:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
    c268:	d121      	bne.n	c2ae <__aeabi_d2f+0x7a>
    c26a:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
    c26e:	bfbc      	itt	lt
    c270:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
    c274:	4770      	bxlt	lr
    c276:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    c27a:	ea4f 5252 	mov.w	r2, r2, lsr #21
    c27e:	f1c2 0218 	rsb	r2, r2, #24
    c282:	f1c2 0c20 	rsb	ip, r2, #32
    c286:	fa10 f30c 	lsls.w	r3, r0, ip
    c28a:	fa20 f002 	lsr.w	r0, r0, r2
    c28e:	bf18      	it	ne
    c290:	f040 0001 	orrne.w	r0, r0, #1
    c294:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    c298:	ea4f 23d3 	mov.w	r3, r3, lsr #11
    c29c:	fa03 fc0c 	lsl.w	ip, r3, ip
    c2a0:	ea40 000c 	orr.w	r0, r0, ip
    c2a4:	fa23 f302 	lsr.w	r3, r3, r2
    c2a8:	ea4f 0343 	mov.w	r3, r3, lsl #1
    c2ac:	e7cc      	b.n	c248 <__aeabi_d2f+0x14>
    c2ae:	ea7f 5362 	mvns.w	r3, r2, asr #21
    c2b2:	d107      	bne.n	c2c4 <__aeabi_d2f+0x90>
    c2b4:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
    c2b8:	bf1e      	ittt	ne
    c2ba:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
    c2be:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
    c2c2:	4770      	bxne	lr
    c2c4:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
    c2c8:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    c2cc:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    c2d0:	4770      	bx	lr
    c2d2:	bf00      	nop

0000c2d4 <__aeabi_ldivmod>:
    c2d4:	b97b      	cbnz	r3, c2f6 <__aeabi_ldivmod+0x22>
    c2d6:	b972      	cbnz	r2, c2f6 <__aeabi_ldivmod+0x22>
    c2d8:	2900      	cmp	r1, #0
    c2da:	bfbe      	ittt	lt
    c2dc:	2000      	movlt	r0, #0
    c2de:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
    c2e2:	e006      	blt.n	c2f2 <__aeabi_ldivmod+0x1e>
    c2e4:	bf08      	it	eq
    c2e6:	2800      	cmpeq	r0, #0
    c2e8:	bf1c      	itt	ne
    c2ea:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
    c2ee:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
    c2f2:	f000 b83f 	b.w	c374 <__aeabi_idiv0>
    c2f6:	f1ad 0c08 	sub.w	ip, sp, #8
    c2fa:	e96d ce04 	strd	ip, lr, [sp, #-16]!
    c2fe:	2900      	cmp	r1, #0
    c300:	db09      	blt.n	c316 <__aeabi_ldivmod+0x42>
    c302:	2b00      	cmp	r3, #0
    c304:	db1a      	blt.n	c33c <__aeabi_ldivmod+0x68>
    c306:	f029 f8dd 	bl	354c4 <__udivmoddi4>
    c30a:	f8dd e004 	ldr.w	lr, [sp, #4]
    c30e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    c312:	b004      	add	sp, #16
    c314:	4770      	bx	lr
    c316:	4240      	negs	r0, r0
    c318:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    c31c:	2b00      	cmp	r3, #0
    c31e:	db1b      	blt.n	c358 <__aeabi_ldivmod+0x84>
    c320:	f029 f8d0 	bl	354c4 <__udivmoddi4>
    c324:	f8dd e004 	ldr.w	lr, [sp, #4]
    c328:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    c32c:	b004      	add	sp, #16
    c32e:	4240      	negs	r0, r0
    c330:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    c334:	4252      	negs	r2, r2
    c336:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    c33a:	4770      	bx	lr
    c33c:	4252      	negs	r2, r2
    c33e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    c342:	f029 f8bf 	bl	354c4 <__udivmoddi4>
    c346:	f8dd e004 	ldr.w	lr, [sp, #4]
    c34a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    c34e:	b004      	add	sp, #16
    c350:	4240      	negs	r0, r0
    c352:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    c356:	4770      	bx	lr
    c358:	4252      	negs	r2, r2
    c35a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    c35e:	f029 f8b1 	bl	354c4 <__udivmoddi4>
    c362:	f8dd e004 	ldr.w	lr, [sp, #4]
    c366:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    c36a:	b004      	add	sp, #16
    c36c:	4252      	negs	r2, r2
    c36e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    c372:	4770      	bx	lr

0000c374 <__aeabi_idiv0>:
    c374:	4770      	bx	lr
    c376:	bf00      	nop

0000c378 <main>:
#define MAX_PACKET_SIZE         1500



int main(void)
{
    c378:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c37c:	f6ad 0d6c 	subw	sp, sp, #2156	; 0x86c
    int g_opusErr;
    uint32_t g_audioSampleRate = 16000;
    int32_t g_audioChannel = 1;
    opus_int32 g_opusComplexity = 0;
    opus_int32 g_opusEncRet;
    int16_t g_opusTestData[FRAME_SIZE] = {
    c380:	f44f 7220 	mov.w	r2, #640	; 0x280
    c384:	4960      	ldr	r1, [pc, #384]	; (c508 <main+0x190>)
    //
    // Turn the LEDs off
    //
    for (int ix = 0; ix < AM_BSP_NUM_LEDS; ix++) 
    {
        am_devices_led_off(am_bsp_psLEDs, ix);
    c386:	4d61      	ldr	r5, [pc, #388]	; (c50c <main+0x194>)
    int16_t g_opusTestData[FRAME_SIZE] = {
    c388:	a803      	add	r0, sp, #12
    c38a:	f7ff feb9 	bl	c100 <memcpy>
    uint8_t g_opusOutputBuff[MAX_PACKET_SIZE] = {0};
    c38e:	f240 52dc 	movw	r2, #1500	; 0x5dc
    c392:	2100      	movs	r1, #0
    c394:	a8a3      	add	r0, sp, #652	; 0x28c
    c396:	f028 fee5 	bl	35164 <memset>
    am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_SYSCLK_MAX, 0);
    c39a:	2100      	movs	r1, #0
    c39c:	4608      	mov	r0, r1
    c39e:	f026 ff77 	bl	33290 <am_hal_clkgen_control>
    am_hal_cachectrl_config(&am_hal_cachectrl_defaults);
    c3a2:	485b      	ldr	r0, [pc, #364]	; (c510 <main+0x198>)
    c3a4:	f026 ff40 	bl	33228 <am_hal_cachectrl_config>
    am_hal_cachectrl_enable();
    c3a8:	f026 ff68 	bl	3327c <am_hal_cachectrl_enable>
    am_bsp_low_power_init();
    c3ac:	f026 fedc 	bl	33168 <am_bsp_low_power_init>
    am_hal_gpio_pinconfig(AM_BSP_GPIO_BUTTON0, g_deepsleep_button0);
    c3b0:	4b58      	ldr	r3, [pc, #352]	; (c514 <main+0x19c>)
    c3b2:	2010      	movs	r0, #16
    c3b4:	6819      	ldr	r1, [r3, #0]
    c3b6:	f000 fa7d 	bl	c8b4 <am_hal_gpio_pinconfig>
    am_hal_gpio_interrupt_clear(AM_HAL_GPIO_BIT(AM_BSP_GPIO_BUTTON0));
    c3ba:	2100      	movs	r1, #0
    c3bc:	f44f 3080 	mov.w	r0, #65536	; 0x10000
    c3c0:	f000 fc5e 	bl	cc80 <am_hal_gpio_interrupt_clear>
    am_hal_gpio_interrupt_enable(AM_HAL_GPIO_BIT(AM_BSP_GPIO_BUTTON0));
    c3c4:	2100      	movs	r1, #0
    c3c6:	f44f 3080 	mov.w	r0, #65536	; 0x10000
    c3ca:	f000 fc31 	bl	cc30 <am_hal_gpio_interrupt_enable>
    am_devices_led_array_init(am_bsp_psLEDs, AM_BSP_NUM_LEDS);
    c3ce:	2105      	movs	r1, #5
    c3d0:	4628      	mov	r0, r5
    c3d2:	f001 fbe5 	bl	dba0 <am_devices_led_array_init>
    for (int ix = 0; ix < AM_BSP_NUM_LEDS; ix++) 
    c3d6:	2400      	movs	r4, #0
        am_devices_led_off(am_bsp_psLEDs, ix);
    c3d8:	4621      	mov	r1, r4
    c3da:	4628      	mov	r0, r5
    for (int ix = 0; ix < AM_BSP_NUM_LEDS; ix++) 
    c3dc:	3401      	adds	r4, #1
        am_devices_led_off(am_bsp_psLEDs, ix);
    c3de:	f001 fc29 	bl	dc34 <am_devices_led_off>
    for (int ix = 0; ix < AM_BSP_NUM_LEDS; ix++) 
    c3e2:	2c05      	cmp	r4, #5
    c3e4:	d1f8      	bne.n	c3d8 <main+0x60>
    }
    //
    // TimerA0 init.
    //
    timerA0_init();
    c3e6:	f001 fca3 	bl	dd30 <timerA0_init>

    //
    // Enable the timer Interrupt.
    //
    am_hal_ctimer_int_enable(AM_HAL_CTIMER_INT_TIMERA0);
    c3ea:	2001      	movs	r0, #1
    c3ec:	f027 f866 	bl	334bc <am_hal_ctimer_int_enable>
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    c3f0:	4b49      	ldr	r3, [pc, #292]	; (c518 <main+0x1a0>)
    c3f2:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    c3f6:	f44f 5100 	mov.w	r1, #8192	; 0x2000
    c3fa:	6019      	str	r1, [r3, #0]
    c3fc:	601a      	str	r2, [r3, #0]
#endif  // AM_CMSIS_REGS

    //
    // Enable interrupts to the core.
    //
    am_hal_interrupt_master_enable();
    c3fe:	f027 f9b3 	bl	33768 <am_hal_interrupt_master_enable>
    
    // Turn on PDM
    pdm_init();
    c402:	f001 fce1 	bl	ddc8 <pdm_init>
    
    //
    // Initialize the printf interface for UART output
    //
    am_bsp_uart_printf_enable();
    c406:	f026 fee1 	bl	331cc <am_bsp_uart_printf_enable>
    
    //
    // Print the banner.
    //
//    am_util_stdio_terminal_clear();
    DebugLog("Starting audio test\r\n\n");
    c40a:	4844      	ldr	r0, [pc, #272]	; (c51c <main+0x1a4>)
    c40c:	f001 fc8a 	bl	dd24 <DebugLog>
    //
    // Start timer A0
    //
    am_hal_ctimer_start(0, AM_HAL_CTIMER_TIMERA);
    c410:	f64f 71ff 	movw	r1, #65535	; 0xffff
    c414:	2000      	movs	r0, #0
    c416:	f026 ffcf 	bl	333b8 <am_hal_ctimer_start>

    //
    // Opus codec init
    //
    g_opusEnc = opus_encoder_create((opus_int32)g_audioSampleRate, g_audioChannel, OPUS_APPLICATION_AUDIO, &g_opusErr);
    c41a:	ab02      	add	r3, sp, #8
    c41c:	f640 0201 	movw	r2, #2049	; 0x801
    c420:	2101      	movs	r1, #1
    c422:	f44f 507a 	mov.w	r0, #16000	; 0x3e80
    c426:	f023 f8dd 	bl	2f5e4 <opus_encoder_create>
    if (g_opusErr != OPUS_OK)
    c42a:	9d02      	ldr	r5, [sp, #8]
    g_opusEnc = opus_encoder_create((opus_int32)g_audioSampleRate, g_audioChannel, OPUS_APPLICATION_AUDIO, &g_opusErr);
    c42c:	4604      	mov	r4, r0
    if (g_opusErr != OPUS_OK)
    c42e:	b13d      	cbz	r5, c440 <main+0xc8>
    {
        am_util_stdio_printf("Cannot create encoder: %s\r\n", opus_strerror(g_opusErr));
    c430:	4628      	mov	r0, r5
    c432:	f017 fe0f 	bl	24054 <opus_strerror>
    c436:	4601      	mov	r1, r0
    c438:	4839      	ldr	r0, [pc, #228]	; (c520 <main+0x1a8>)
    c43a:	f001 fb97 	bl	db6c <am_util_stdio_printf>
    c43e:	e7fe      	b.n	c43e <main+0xc6>
        while(1);
    }
//    opus_encoder_ctl(g_opusEnc, OPUS_SET_BITRATE(bitrate_bps));
    opus_encoder_ctl(g_opusEnc, OPUS_SET_BANDWIDTH(OPUS_BANDWIDTH_MEDIUMBAND));
    c440:	f240 424e 	movw	r2, #1102	; 0x44e
    c444:	f640 71a8 	movw	r1, #4008	; 0xfa8
    c448:	f026 f810 	bl	3246c <opus_encoder_ctl>
//    opus_encoder_ctl(g_opusEnc, OPUS_SET_VBR(use_vbr));
//    opus_encoder_ctl(g_opusEnc, OPUS_SET_VBR_CONSTRAINT(cvbr));
    opus_encoder_ctl(g_opusEnc, OPUS_SET_COMPLEXITY(g_opusComplexity));
    c44c:	462a      	mov	r2, r5
    c44e:	f640 71aa 	movw	r1, #4010	; 0xfaa
    c452:	4620      	mov	r0, r4
    c454:	f026 f80a 	bl	3246c <opus_encoder_ctl>
//    opus_encoder_ctl(g_opusEnc, OPUS_SET_INBAND_FEC(use_inbandfec));
//    opus_encoder_ctl(g_opusEnc, OPUS_SET_FORCE_CHANNELS(forcechannels));
//    opus_encoder_ctl(g_opusEnc, OPUS_SET_DTX(use_dtx));
//    opus_encoder_ctl(g_opusEnc, OPUS_SET_PACKET_LOSS_PERC(packet_loss_perc));
    opus_encoder_ctl(g_opusEnc, OPUS_SET_LSB_DEPTH(16));
    c458:	2210      	movs	r2, #16
    c45a:	f640 71c4 	movw	r1, #4036	; 0xfc4
    c45e:	4620      	mov	r0, r4
    c460:	f026 f804 	bl	3246c <opus_encoder_ctl>
//    opus_encoder_ctl(g_opusEnc, OPUS_SET_EXPERT_FRAME_DURATION(variable_duration));

    DebugLog("Opus encoder initialization is finished!\r\n\n");
    c464:	482f      	ldr	r0, [pc, #188]	; (c524 <main+0x1ac>)
    c466:	f001 fc5d 	bl	dd24 <DebugLog>
   
    g_opusEncRet = opus_encode(g_opusEnc, g_opusTestData, FRAME_SIZE, g_opusOutputBuff, MAX_PACKET_SIZE);
    c46a:	f240 52dc 	movw	r2, #1500	; 0x5dc
    c46e:	a903      	add	r1, sp, #12
    c470:	9200      	str	r2, [sp, #0]
    c472:	aba3      	add	r3, sp, #652	; 0x28c
    c474:	4620      	mov	r0, r4
    c476:	f44f 72a0 	mov.w	r2, #320	; 0x140
    c47a:	f025 ff83 	bl	32384 <opus_encode>
    if(g_opusEncRet < 0)
    c47e:	1e01      	subs	r1, r0, #0
    c480:	db3a      	blt.n	c4f8 <main+0x180>
    {
        am_util_stdio_printf("encode failed: %s\r\n", opus_strerror(g_opusEncRet));
    }
    else
    {
        am_util_stdio_printf("encode finished: %d bytes is encoded.\r\n", g_opusEncRet);
    c482:	4829      	ldr	r0, [pc, #164]	; (c528 <main+0x1b0>)
    c484:	f001 fb72 	bl	db6c <am_util_stdio_printf>
    c488:	4d28      	ldr	r5, [pc, #160]	; (c52c <main+0x1b4>)
    c48a:	4c29      	ldr	r4, [pc, #164]	; (c530 <main+0x1b8>)
    c48c:	f8df a0ac 	ldr.w	sl, [pc, #172]	; c53c <main+0x1c4>
    c490:	f8df 90ac 	ldr.w	r9, [pc, #172]	; c540 <main+0x1c8>
    c494:	4e27      	ldr	r6, [pc, #156]	; (c534 <main+0x1bc>)
            else 
            {
                g_numFramesCaptured = 0;
                g_audioRunningFlag = 0;
                am_hal_pdm_disable(PDMHandle);
                am_devices_led_off(am_bsp_psLEDs, 0);
    c496:	4f1d      	ldr	r7, [pc, #116]	; (c50c <main+0x194>)
                DebugLog("PDM data recording ends!\r\n");
    c498:	f8df 80a8 	ldr.w	r8, [pc, #168]	; c544 <main+0x1cc>
    c49c:	e002      	b.n	c4a4 <main+0x12c>
        
        }
    //
    // Go to Deep Sleep.
    //
        am_hal_sysctrl_sleep(AM_HAL_SYSCTRL_SLEEP_DEEP);
    c49e:	2001      	movs	r0, #1
    c4a0:	f027 fb04 	bl	33aac <am_hal_sysctrl_sleep>
         if (g_bPDMDataReady) 
    c4a4:	782b      	ldrb	r3, [r5, #0]
            g_bPDMDataReady = false;
    c4a6:	f04f 0b00 	mov.w	fp, #0
         if (g_bPDMDataReady) 
    c4aa:	b15b      	cbz	r3, c4c4 <main+0x14c>
            g_bPDMDataReady = false;
    c4ac:	f885 b000 	strb.w	fp, [r5]
            g_numFramesCaptured++;
    c4b0:	8823      	ldrh	r3, [r4, #0]
    c4b2:	3301      	adds	r3, #1
    c4b4:	b21b      	sxth	r3, r3
    c4b6:	8023      	strh	r3, [r4, #0]
            if (g_numFramesCaptured < NUM_FRAMES) 
    c4b8:	8823      	ldrh	r3, [r4, #0]
    c4ba:	b21b      	sxth	r3, r3
    c4bc:	2b31      	cmp	r3, #49	; 0x31
    c4be:	dc0b      	bgt.n	c4d8 <main+0x160>
                pdm_data_get();  // Start converting the next set of PCM samples.
    c4c0:	f001 fcb0 	bl	de24 <pdm_data_get>
        if (g_ui32TimerCount >=1)
    c4c4:	6833      	ldr	r3, [r6, #0]
    c4c6:	2b00      	cmp	r3, #0
    c4c8:	d0e9      	beq.n	c49e <main+0x126>
            g_ui32TimerCount = 0;
    c4ca:	2300      	movs	r3, #0
            am_devices_led_toggle(am_bsp_psLEDs, 1);
    c4cc:	2101      	movs	r1, #1
    c4ce:	4638      	mov	r0, r7
            g_ui32TimerCount = 0;
    c4d0:	6033      	str	r3, [r6, #0]
            am_devices_led_toggle(am_bsp_psLEDs, 1);
    c4d2:	f001 fbc7 	bl	dc64 <am_devices_led_toggle>
    c4d6:	e7e2      	b.n	c49e <main+0x126>
                am_hal_pdm_disable(PDMHandle);
    c4d8:	f8d9 0000 	ldr.w	r0, [r9]
                g_numFramesCaptured = 0;
    c4dc:	f8a4 b000 	strh.w	fp, [r4]
                g_audioRunningFlag = 0;
    c4e0:	f88a b000 	strb.w	fp, [sl]
                am_hal_pdm_disable(PDMHandle);
    c4e4:	f000 f930 	bl	c748 <am_hal_pdm_disable>
                am_devices_led_off(am_bsp_psLEDs, 0);
    c4e8:	4638      	mov	r0, r7
    c4ea:	4659      	mov	r1, fp
    c4ec:	f001 fba2 	bl	dc34 <am_devices_led_off>
                DebugLog("PDM data recording ends!\r\n");
    c4f0:	4640      	mov	r0, r8
    c4f2:	f001 fc17 	bl	dd24 <DebugLog>
    c4f6:	e7e5      	b.n	c4c4 <main+0x14c>
        am_util_stdio_printf("encode failed: %s\r\n", opus_strerror(g_opusEncRet));
    c4f8:	f017 fdac 	bl	24054 <opus_strerror>
    c4fc:	4601      	mov	r1, r0
    c4fe:	480e      	ldr	r0, [pc, #56]	; (c538 <main+0x1c0>)
    c500:	f001 fb34 	bl	db6c <am_util_stdio_printf>
    c504:	e7c0      	b.n	c488 <main+0x110>
    c506:	bf00      	nop
    c508:	000357ac 	.word	0x000357ac
    c50c:	1000102c 	.word	0x1000102c
    c510:	0003b734 	.word	0x0003b734
    c514:	00035c58 	.word	0x00035c58
    c518:	e000e100 	.word	0xe000e100
    c51c:	00035a2c 	.word	0x00035a2c
    c520:	00035a44 	.word	0x00035a44
    c524:	00035a60 	.word	0x00035a60
    c528:	00035aa0 	.word	0x00035aa0
    c52c:	10001999 	.word	0x10001999
    c530:	1000199a 	.word	0x1000199a
    c534:	10001994 	.word	0x10001994
    c538:	00035a8c 	.word	0x00035a8c
    c53c:	10001998 	.word	0x10001998
    c540:	100113ec 	.word	0x100113ec
    c544:	00035ac8 	.word	0x00035ac8

0000c548 <am_hal_pdm_initialize>:
am_hal_pdm_initialize(uint32_t ui32Module, void **ppHandle)
{
    //
    // Check that the request module is in range.
    //
    if ( ui32Module >= AM_REG_PDM_NUM_MODULES )
    c548:	b9a0      	cbnz	r0, c574 <am_hal_pdm_initialize+0x2c>
    }

    //
    // Check for valid arguements.
    //
    if (!ppHandle)
    c54a:	b1c1      	cbz	r1, c57e <am_hal_pdm_initialize+0x36>
    }

    //
    // Check if the handle is unallocated.
    //
    if (g_am_hal_pdm_states[ui32Module].prefix.s.bInit)
    c54c:	4b0d      	ldr	r3, [pc, #52]	; (c584 <am_hal_pdm_initialize+0x3c>)
    c54e:	78da      	ldrb	r2, [r3, #3]
{
    c550:	b430      	push	{r4, r5}
    if (g_am_hal_pdm_states[ui32Module].prefix.s.bInit)
    c552:	f3c2 0400 	ubfx	r4, r2, #0, #1
    c556:	b2e0      	uxtb	r0, r4
    c558:	b970      	cbnz	r0, c578 <am_hal_pdm_initialize+0x30>
    }

    //
    // Initialize the handle.
    //
    g_am_hal_pdm_states[ui32Module].prefix.s.bInit = true;
    c55a:	f042 0201 	orr.w	r2, r2, #1
    c55e:	70da      	strb	r2, [r3, #3]
    g_am_hal_pdm_states[ui32Module].prefix.s.magic = AM_HAL_MAGIC_PDM;
    c560:	681a      	ldr	r2, [r3, #0]
    c562:	4d09      	ldr	r5, [pc, #36]	; (c588 <am_hal_pdm_initialize+0x40>)
    g_am_hal_pdm_states[ui32Module].ui32Module = ui32Module;
    g_am_hal_pdm_states[ui32Module].sRegState.bValid = false;
    c564:	711c      	strb	r4, [r3, #4]
    g_am_hal_pdm_states[ui32Module].prefix.s.magic = AM_HAL_MAGIC_PDM;
    c566:	f365 0217 	bfi	r2, r5, #0, #24
    c56a:	601a      	str	r2, [r3, #0]
    g_am_hal_pdm_states[ui32Module].ui32Module = ui32Module;
    c56c:	6098      	str	r0, [r3, #8]

    //
    // Return the status.
    //
    return AM_HAL_STATUS_SUCCESS;
}
    c56e:	bc30      	pop	{r4, r5}
    *ppHandle = (void *)&g_am_hal_pdm_states[ui32Module];
    c570:	600b      	str	r3, [r1, #0]
}
    c572:	4770      	bx	lr
        return AM_HAL_STATUS_OUT_OF_RANGE;
    c574:	2005      	movs	r0, #5
    c576:	4770      	bx	lr
        return AM_HAL_STATUS_INVALID_OPERATION;
    c578:	2007      	movs	r0, #7
}
    c57a:	bc30      	pop	{r4, r5}
    c57c:	4770      	bx	lr
        return AM_HAL_STATUS_INVALID_ARG;
    c57e:	2006      	movs	r0, #6
}
    c580:	4770      	bx	lr
    c582:	bf00      	nop
    c584:	100019dc 	.word	0x100019dc
    c588:	00f956e2 	.word	0x00f956e2

0000c58c <am_hal_pdm_power_control>:
//*****************************************************************************
uint32_t
am_hal_pdm_power_control(void *pHandle,
                         am_hal_sysctrl_power_state_e ePowerState,
                         bool bRetainState)
{
    c58c:	b5f0      	push	{r4, r5, r6, r7, lr}
                                                (AM_HAL_PWRCTRL_PERIPH_PDM +
                                                 ui32Module));
    //
    // Check the handle.
    //
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    c58e:	6803      	ldr	r3, [r0, #0]
    c590:	4c1d      	ldr	r4, [pc, #116]	; (c608 <am_hal_pdm_power_control+0x7c>)
    c592:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    c596:	42a3      	cmp	r3, r4
{
    c598:	b083      	sub	sp, #12
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    c59a:	d10f      	bne.n	c5bc <am_hal_pdm_power_control+0x30>
    am_hal_pwrctrl_periph_e ePDMPowerModule = ((am_hal_pwrctrl_periph_e)
    c59c:	6883      	ldr	r3, [r0, #8]
    c59e:	330d      	adds	r3, #13
    c5a0:	4617      	mov	r7, r2
    c5a2:	460c      	mov	r4, r1
    c5a4:	4606      	mov	r6, r0
    c5a6:	b2dd      	uxtb	r5, r3

    //
    // Decode the requested power state and update PDM operation accordingly.
    //
    switch (ePowerState)
    c5a8:	b171      	cbz	r1, c5c8 <am_hal_pdm_power_control+0x3c>
    c5aa:	2902      	cmp	r1, #2
    c5ac:	d809      	bhi.n	c5c2 <am_hal_pdm_power_control+0x36>
        //
        // Turn off the PDM.
        //
        case AM_HAL_SYSCTRL_NORMALSLEEP:
        case AM_HAL_SYSCTRL_DEEPSLEEP:
            if (bRetainState)
    c5ae:	b9d2      	cbnz	r2, c5e6 <am_hal_pdm_power_control+0x5a>
            }

            //
            // Disable power control.
            //
            am_hal_pwrctrl_periph_disable(ePDMPowerModule);
    c5b0:	4628      	mov	r0, r5
    c5b2:	f027 f9fb 	bl	339ac <am_hal_pwrctrl_periph_disable>
    }

    //
    // Return the status.
    //
    return AM_HAL_STATUS_SUCCESS;
    c5b6:	2000      	movs	r0, #0
}
    c5b8:	b003      	add	sp, #12
    c5ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    c5bc:	2002      	movs	r0, #2
}
    c5be:	b003      	add	sp, #12
    c5c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
            return AM_HAL_STATUS_INVALID_ARG;
    c5c2:	2006      	movs	r0, #6
}
    c5c4:	b003      	add	sp, #12
    c5c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
            if (bRetainState && !pState->sRegState.bValid)
    c5c8:	b1b2      	cbz	r2, c5f8 <am_hal_pdm_power_control+0x6c>
    c5ca:	7903      	ldrb	r3, [r0, #4]
    c5cc:	b1cb      	cbz	r3, c602 <am_hal_pdm_power_control+0x76>
            am_hal_pwrctrl_periph_enable(ePDMPowerModule);
    c5ce:	4628      	mov	r0, r5
    c5d0:	f027 f9c2 	bl	33958 <am_hal_pwrctrl_periph_enable>
                AM_CRITICAL_BEGIN;
    c5d4:	f027 f8cc 	bl	33770 <am_hal_interrupt_master_disable>
    c5d8:	9000      	str	r0, [sp, #0]
                AM_CRITICAL_END;
    c5da:	9800      	ldr	r0, [sp, #0]
                pState->sRegState.bValid = false;
    c5dc:	7134      	strb	r4, [r6, #4]
                AM_CRITICAL_END;
    c5de:	f027 f8cb 	bl	33778 <am_hal_interrupt_master_set>
    return AM_HAL_STATUS_SUCCESS;
    c5e2:	4620      	mov	r0, r4
    c5e4:	e7eb      	b.n	c5be <am_hal_pdm_power_control+0x32>
                AM_CRITICAL_BEGIN;
    c5e6:	f027 f8c3 	bl	33770 <am_hal_interrupt_master_disable>
                pState->sRegState.bValid = true;
    c5ea:	2301      	movs	r3, #1
                AM_CRITICAL_BEGIN;
    c5ec:	9001      	str	r0, [sp, #4]
                AM_CRITICAL_END;
    c5ee:	9801      	ldr	r0, [sp, #4]
                pState->sRegState.bValid = true;
    c5f0:	7133      	strb	r3, [r6, #4]
                AM_CRITICAL_END;
    c5f2:	f027 f8c1 	bl	33778 <am_hal_interrupt_master_set>
    c5f6:	e7db      	b.n	c5b0 <am_hal_pdm_power_control+0x24>
            am_hal_pwrctrl_periph_enable(ePDMPowerModule);
    c5f8:	4628      	mov	r0, r5
    c5fa:	f027 f9ad 	bl	33958 <am_hal_pwrctrl_periph_enable>
    return AM_HAL_STATUS_SUCCESS;
    c5fe:	4638      	mov	r0, r7
    c600:	e7dd      	b.n	c5be <am_hal_pdm_power_control+0x32>
                return AM_HAL_STATUS_INVALID_OPERATION;
    c602:	2007      	movs	r0, #7
    c604:	e7db      	b.n	c5be <am_hal_pdm_power_control+0x32>
    c606:	bf00      	nop
    c608:	01f956e2 	.word	0x01f956e2

0000c60c <am_hal_pdm_configure>:
uint32_t
am_hal_pdm_configure(void *pHandle, am_hal_pdm_config_t *psConfig)
{
    am_hal_pdm_state_t *pState = (am_hal_pdm_state_t *) pHandle;
    uint32_t ui32Module = pState->ui32Module;
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    c60c:	6803      	ldr	r3, [r0, #0]
    c60e:	4a3f      	ldr	r2, [pc, #252]	; (c70c <am_hal_pdm_configure+0x100>)
    c610:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    c614:	4293      	cmp	r3, r2
    c616:	d001      	beq.n	c61c <am_hal_pdm_configure+0x10>
    c618:	2002      	movs	r0, #2
#else
    AM_BFWen(PDM, ui32Module, VCFG, RSTB, NORM);
#endif

    return AM_HAL_STATUS_SUCCESS;
}
    c61a:	4770      	bx	lr
{
    c61c:	b510      	push	{r4, lr}
    PDMn(ui32Module)->PCFG_b.SOFTMUTE = psConfig->bSoftMute;
    c61e:	4c3c      	ldr	r4, [pc, #240]	; (c710 <am_hal_pdm_configure+0x104>)
    c620:	7f4a      	ldrb	r2, [r1, #29]
    c622:	6823      	ldr	r3, [r4, #0]
    c624:	f362 0341 	bfi	r3, r2, #1, #1
    c628:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.CYCLES = psConfig->ui32GainChangeDelay;
    c62a:	6823      	ldr	r3, [r4, #0]
    c62c:	698a      	ldr	r2, [r1, #24]
    c62e:	f362 0384 	bfi	r3, r2, #2, #3
    c632:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.HPCUTOFF = psConfig->ui32HighPassCutoff;
    c634:	6823      	ldr	r3, [r4, #0]
    c636:	68ca      	ldr	r2, [r1, #12]
    c638:	f362 1348 	bfi	r3, r2, #5, #4
    c63c:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.ADCHPD = psConfig->bHighPassEnable;
    c63e:	6823      	ldr	r3, [r4, #0]
    c640:	7a0a      	ldrb	r2, [r1, #8]
    c642:	f362 2349 	bfi	r3, r2, #9, #1
    c646:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.SINCRATE = psConfig->ui32DecimationRate;
    c648:	6823      	ldr	r3, [r4, #0]
    c64a:	684a      	ldr	r2, [r1, #4]
    c64c:	f362 2390 	bfi	r3, r2, #10, #7
    c650:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.MCLKDIV = psConfig->eClkDivider;
    c652:	6823      	ldr	r3, [r4, #0]
    c654:	780a      	ldrb	r2, [r1, #0]
    c656:	f362 4352 	bfi	r3, r2, #17, #2
    c65a:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.PGALEFT = psConfig->eLeftGain;
    c65c:	6823      	ldr	r3, [r4, #0]
    c65e:	784a      	ldrb	r2, [r1, #1]
    c660:	f362 5359 	bfi	r3, r2, #21, #5
    c664:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.PGARIGHT = psConfig->eRightGain;
    c666:	7888      	ldrb	r0, [r1, #2]
    c668:	6823      	ldr	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.LRSWAP = psConfig->bLRSwap;
    c66a:	7f8a      	ldrb	r2, [r1, #30]
    PDMn(ui32Module)->PCFG_b.PGARIGHT = psConfig->eRightGain;
    c66c:	f360 639e 	bfi	r3, r0, #26, #5
    c670:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.LRSWAP = psConfig->bLRSwap;
    c672:	6823      	ldr	r3, [r4, #0]
    c674:	f362 73df 	bfi	r3, r2, #31, #1
    c678:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.PDMCOREEN = PDM_PCFG_PDMCOREEN_EN;
    c67a:	6823      	ldr	r3, [r4, #0]
    c67c:	f043 0301 	orr.w	r3, r3, #1
    c680:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->VCFG_b.PDMCLKEN = PDM_VCFG_PDMCLKEN_DIS;
    c682:	6863      	ldr	r3, [r4, #4]
    c684:	f36f 639a 	bfc	r3, #26, #1
    c688:	6063      	str	r3, [r4, #4]
    PDMn(ui32Module)->VCFG_b.IOCLKEN = PDM_VCFG_IOCLKEN_DIS;
    c68a:	6863      	ldr	r3, [r4, #4]
    c68c:	f36f 73df 	bfc	r3, #31, #1
    c690:	6063      	str	r3, [r4, #4]
    PDMn(ui32Module)->VCFG_b.RSTB = PDM_VCFG_RSTB_RESET;
    c692:	6863      	ldr	r3, [r4, #4]
    c694:	f36f 739e 	bfc	r3, #30, #1
    c698:	6063      	str	r3, [r4, #4]
    PDMn(ui32Module)->VCFG_b.CHSET = psConfig->ePCMChannels;
    c69a:	6863      	ldr	r3, [r4, #4]
    c69c:	7d4a      	ldrb	r2, [r1, #21]
    c69e:	f362 03c4 	bfi	r3, r2, #3, #2
    c6a2:	6063      	str	r3, [r4, #4]
    PDMn(ui32Module)->VCFG_b.PCMPACK = psConfig->bDataPacking;
    c6a4:	6863      	ldr	r3, [r4, #4]
    c6a6:	7d0a      	ldrb	r2, [r1, #20]
    c6a8:	f362 2308 	bfi	r3, r2, #8, #1
    c6ac:	6063      	str	r3, [r4, #4]
    PDMn(ui32Module)->VCFG_b.SELAP = psConfig->ePDMClkSource;
    c6ae:	6863      	ldr	r3, [r4, #4]
    c6b0:	7c8a      	ldrb	r2, [r1, #18]
    c6b2:	f362 4310 	bfi	r3, r2, #16, #1
    c6b6:	6063      	str	r3, [r4, #4]
    PDMn(ui32Module)->VCFG_b.DMICKDEL = psConfig->bPDMSampleDelay;
    c6b8:	6863      	ldr	r3, [r4, #4]
    c6ba:	7cca      	ldrb	r2, [r1, #19]
    c6bc:	f362 4351 	bfi	r3, r2, #17, #1
    c6c0:	6063      	str	r3, [r4, #4]
    PDMn(ui32Module)->VCFG_b.BCLKINV = psConfig->bInvertI2SBCLK;
    c6c2:	7c4a      	ldrb	r2, [r1, #17]
    c6c4:	6863      	ldr	r3, [r4, #4]
    c6c6:	f362 43d3 	bfi	r3, r2, #19, #1
    c6ca:	6063      	str	r3, [r4, #4]
    PDMn(ui32Module)->VCFG_b.I2SEN = psConfig->bI2SEnable;
    c6cc:	7f0a      	ldrb	r2, [r1, #28]
    c6ce:	6863      	ldr	r3, [r4, #4]
    c6d0:	f362 5314 	bfi	r3, r2, #20, #1
    c6d4:	6063      	str	r3, [r4, #4]
    PDMn(ui32Module)->VCFG_b.PDMCLKSEL = psConfig->ePDMClkSpeed;
    c6d6:	7c0a      	ldrb	r2, [r1, #16]
    c6d8:	6863      	ldr	r3, [r4, #4]
{
    c6da:	b084      	sub	sp, #16
    PDMn(ui32Module)->VCFG_b.PDMCLKSEL = psConfig->ePDMClkSpeed;
    c6dc:	f362 63dd 	bfi	r3, r2, #27, #3
    c6e0:	6063      	str	r3, [r4, #4]
    delay_us(100);
    c6e2:	a801      	add	r0, sp, #4
    c6e4:	f026 fe30 	bl	33348 <am_hal_clkgen_status_get>
    c6e8:	9801      	ldr	r0, [sp, #4]
    c6ea:	4b0a      	ldr	r3, [pc, #40]	; (c714 <am_hal_pdm_configure+0x108>)
    c6ec:	fba3 3000 	umull	r3, r0, r3, r0
    c6f0:	0c80      	lsrs	r0, r0, #18
    c6f2:	2364      	movs	r3, #100	; 0x64
    c6f4:	fb03 f000 	mul.w	r0, r3, r0
    c6f8:	f026 ff04 	bl	33504 <am_hal_flash_delay>
    PDMn(ui32Module)->VCFG_b.RSTB = PDM_VCFG_RSTB_NORM;
    c6fc:	6863      	ldr	r3, [r4, #4]
    return AM_HAL_STATUS_SUCCESS;
    c6fe:	2000      	movs	r0, #0
    PDMn(ui32Module)->VCFG_b.RSTB = PDM_VCFG_RSTB_NORM;
    c700:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    c704:	6063      	str	r3, [r4, #4]
}
    c706:	b004      	add	sp, #16
    c708:	bd10      	pop	{r4, pc}
    c70a:	bf00      	nop
    c70c:	01f956e2 	.word	0x01f956e2
    c710:	50011000 	.word	0x50011000
    c714:	165e9f81 	.word	0x165e9f81

0000c718 <am_hal_pdm_enable>:
uint32_t
am_hal_pdm_enable(void *pHandle)
{
    am_hal_pdm_state_t *pState = (am_hal_pdm_state_t *) pHandle;
    uint32_t ui32Module = pState->ui32Module;
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    c718:	6803      	ldr	r3, [r0, #0]
    c71a:	4a09      	ldr	r2, [pc, #36]	; (c740 <am_hal_pdm_enable+0x28>)
    c71c:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    c720:	4293      	cmp	r3, r2
    c722:	d10a      	bne.n	c73a <am_hal_pdm_enable+0x22>

#if AM_CMSIS_REGS
    PDMn(ui32Module)->VCFG_b.IOCLKEN = PDM_VCFG_IOCLKEN_EN;
    c724:	4b07      	ldr	r3, [pc, #28]	; (c744 <am_hal_pdm_enable+0x2c>)
    c726:	685a      	ldr	r2, [r3, #4]
    c728:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
    c72c:	605a      	str	r2, [r3, #4]
    PDMn(ui32Module)->VCFG_b.PDMCLKEN = PDM_VCFG_PDMCLKEN_EN;
    c72e:	685a      	ldr	r2, [r3, #4]
    c730:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
    c734:	605a      	str	r2, [r3, #4]
#else
    AM_BFWen(PDM, ui32Module, VCFG, IOCLKEN, EN);
    AM_BFWen(PDM, ui32Module, VCFG, PDMCLKEN, EN);
#endif

    return AM_HAL_STATUS_SUCCESS;
    c736:	2000      	movs	r0, #0
    c738:	4770      	bx	lr
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    c73a:	2002      	movs	r0, #2
}
    c73c:	4770      	bx	lr
    c73e:	bf00      	nop
    c740:	01f956e2 	.word	0x01f956e2
    c744:	50011000 	.word	0x50011000

0000c748 <am_hal_pdm_disable>:
uint32_t
am_hal_pdm_disable(void *pHandle)
{
    am_hal_pdm_state_t *pState = (am_hal_pdm_state_t *) pHandle;
    uint32_t ui32Module = pState->ui32Module;
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    c748:	6803      	ldr	r3, [r0, #0]
    c74a:	4a09      	ldr	r2, [pc, #36]	; (c770 <am_hal_pdm_disable+0x28>)
    c74c:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    c750:	4293      	cmp	r3, r2
    c752:	d10a      	bne.n	c76a <am_hal_pdm_disable+0x22>

#if AM_CMSIS_REGS
    PDMn(ui32Module)->VCFG_b.IOCLKEN = PDM_VCFG_IOCLKEN_DIS;
    c754:	4b07      	ldr	r3, [pc, #28]	; (c774 <am_hal_pdm_disable+0x2c>)
    c756:	685a      	ldr	r2, [r3, #4]
    c758:	f36f 72df 	bfc	r2, #31, #1
    c75c:	605a      	str	r2, [r3, #4]
    PDMn(ui32Module)->VCFG_b.PDMCLKEN = PDM_VCFG_PDMCLKEN_DIS;
    c75e:	685a      	ldr	r2, [r3, #4]
    c760:	f36f 629a 	bfc	r2, #26, #1
    c764:	605a      	str	r2, [r3, #4]
#else
    AM_BFWen(PDM, ui32Module, VCFG, IOCLKEN, DIS);
    AM_BFWen(PDM, ui32Module, VCFG, PDMCLKEN, DIS);
#endif

    return AM_HAL_STATUS_SUCCESS;
    c766:	2000      	movs	r0, #0
    c768:	4770      	bx	lr
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    c76a:	2002      	movs	r0, #2
}
    c76c:	4770      	bx	lr
    c76e:	bf00      	nop
    c770:	01f956e2 	.word	0x01f956e2
    c774:	50011000 	.word	0x50011000

0000c778 <am_hal_pdm_dma_start>:
uint32_t
am_hal_pdm_dma_start(void *pHandle, am_hal_pdm_transfer_t *pDmaCfg)
{
    am_hal_pdm_state_t *pState = (am_hal_pdm_state_t *) pHandle;
    uint32_t ui32Module = pState->ui32Module;
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    c778:	6803      	ldr	r3, [r0, #0]
    c77a:	4a22      	ldr	r2, [pc, #136]	; (c804 <am_hal_pdm_dma_start+0x8c>)
    c77c:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    c780:	4293      	cmp	r3, r2
    c782:	d113      	bne.n	c7ac <am_hal_pdm_dma_start+0x34>
    // user asked for.
    //
    uint32_t ui32Threshold = 0;
    uint32_t ui32NumReloads = 1;

    for (ui32NumReloads = 1; ui32NumReloads < pDmaCfg->ui32TotalCount; ui32NumReloads++)
    c784:	684a      	ldr	r2, [r1, #4]
    c786:	2a01      	cmp	r2, #1
    c788:	d938      	bls.n	c7fc <am_hal_pdm_dma_start+0x84>
{
    c78a:	b410      	push	{r4}
    for (ui32NumReloads = 1; ui32NumReloads < pDmaCfg->ui32TotalCount; ui32NumReloads++)
    c78c:	2301      	movs	r3, #1
    {
        //
        // Check to make sure the total count is evenly divisible into chunks
        // that are smaller than the maximum threshold size.
        //
        if (((pDmaCfg->ui32TotalCount % ui32NumReloads) == 0) &&
    c78e:	fbb2 f4f3 	udiv	r4, r2, r3
    c792:	fb03 2014 	mls	r0, r3, r4, r2
    for (ui32NumReloads = 1; ui32NumReloads < pDmaCfg->ui32TotalCount; ui32NumReloads++)
    c796:	3301      	adds	r3, #1
        if (((pDmaCfg->ui32TotalCount % ui32NumReloads) == 0) &&
    c798:	b908      	cbnz	r0, c79e <am_hal_pdm_dma_start+0x26>
    c79a:	2c1f      	cmp	r4, #31
    c79c:	d908      	bls.n	c7b0 <am_hal_pdm_dma_start+0x38>
    for (ui32NumReloads = 1; ui32NumReloads < pDmaCfg->ui32TotalCount; ui32NumReloads++)
    c79e:	429a      	cmp	r2, r3
    c7a0:	d1f5      	bne.n	c78e <am_hal_pdm_dma_start+0x16>
    //
    // If we didn't find a threshold that will work, throw an error.
    //
    if (ui32Threshold == 0)
    {
        return AM_HAL_PDM_STATUS_BAD_TOTALCOUNT;
    c7a2:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
//    AM_BFWen(PDM, ui32Module, VCFG, RSTB, NORM);
//    AM_BFWn(PDM, ui32Module, VCFG, PDMCLKEN, 1);
//#endif

    return AM_HAL_STATUS_SUCCESS;
}
    c7a6:	f85d 4b04 	ldr.w	r4, [sp], #4
    c7aa:	4770      	bx	lr
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    c7ac:	2002      	movs	r0, #2
    c7ae:	4770      	bx	lr
    if (ui32Threshold == 0)
    c7b0:	2c00      	cmp	r4, #0
    c7b2:	d0f6      	beq.n	c7a2 <am_hal_pdm_dma_start+0x2a>
    PDMn(ui32Module)->FIFOTHR = ui32Threshold;
    c7b4:	4b14      	ldr	r3, [pc, #80]	; (c808 <am_hal_pdm_dma_start+0x90>)
    c7b6:	615c      	str	r4, [r3, #20]
    PDMn(ui32Module)->DMACFG = 0;
    c7b8:	f8c3 0280 	str.w	r0, [r3, #640]	; 0x280
    PDMn(ui32Module)->DMACFG_b.DMAPRI = PDM_DMACFG_DMAPRI_LOW;
    c7bc:	f8b3 4280 	ldrh.w	r4, [r3, #640]	; 0x280
    c7c0:	f360 2408 	bfi	r4, r0, #8, #1
    c7c4:	f8a3 4280 	strh.w	r4, [r3, #640]	; 0x280
    PDMn(ui32Module)->DMACFG_b.DMADIR = PDM_DMACFG_DMADIR_P2M;
    c7c8:	f8b3 4280 	ldrh.w	r4, [r3, #640]	; 0x280
    c7cc:	f360 0482 	bfi	r4, r0, #2, #1
    c7d0:	f8a3 4280 	strh.w	r4, [r3, #640]	; 0x280
    PDMn(ui32Module)->DMATOTCOUNT = pDmaCfg->ui32TotalCount;
    c7d4:	f8c3 2288 	str.w	r2, [r3, #648]	; 0x288
    PDMn(ui32Module)->DMATARGADDR = pDmaCfg->ui32TargetAddr;
    c7d8:	680a      	ldr	r2, [r1, #0]
    c7da:	f8c3 228c 	str.w	r2, [r3, #652]	; 0x28c
    PDMn(ui32Module)->DMATRIGEN_b.DTHR = 1;
    c7de:	f893 2240 	ldrb.w	r2, [r3, #576]	; 0x240
    c7e2:	f042 0201 	orr.w	r2, r2, #1
    c7e6:	f883 2240 	strb.w	r2, [r3, #576]	; 0x240
    PDMn(ui32Module)->DMACFG_b.DMAEN = PDM_DMACFG_DMAEN_EN;
    c7ea:	f8b3 2280 	ldrh.w	r2, [r3, #640]	; 0x280
    c7ee:	f042 0201 	orr.w	r2, r2, #1
    c7f2:	f8a3 2280 	strh.w	r2, [r3, #640]	; 0x280
}
    c7f6:	f85d 4b04 	ldr.w	r4, [sp], #4
    c7fa:	4770      	bx	lr
        return AM_HAL_PDM_STATUS_BAD_TOTALCOUNT;
    c7fc:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
}
    c800:	4770      	bx	lr
    c802:	bf00      	nop
    c804:	01f956e2 	.word	0x01f956e2
    c808:	50011000 	.word	0x50011000

0000c80c <am_hal_pdm_fifo_flush>:
uint32_t
am_hal_pdm_fifo_flush(void *pHandle)
{
    am_hal_pdm_state_t *pState = (am_hal_pdm_state_t *) pHandle;
    uint32_t ui32Module = pState->ui32Module;
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    c80c:	6803      	ldr	r3, [r0, #0]
    c80e:	4a06      	ldr	r2, [pc, #24]	; (c828 <am_hal_pdm_fifo_flush+0x1c>)
    c810:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    c814:	4293      	cmp	r3, r2
    c816:	d104      	bne.n	c822 <am_hal_pdm_fifo_flush+0x16>

#if AM_CMSIS_REGS
    PDMn(ui32Module)->FIFOFLUSH = 1;
    c818:	4b04      	ldr	r3, [pc, #16]	; (c82c <am_hal_pdm_fifo_flush+0x20>)
    c81a:	2201      	movs	r2, #1
    c81c:	611a      	str	r2, [r3, #16]
#else
    AM_REGn(PDM, ui32Module, FIFOFLUSH) = 1;
#endif

    return AM_HAL_STATUS_SUCCESS;
    c81e:	2000      	movs	r0, #0
    c820:	4770      	bx	lr
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    c822:	2002      	movs	r0, #2
}
    c824:	4770      	bx	lr
    c826:	bf00      	nop
    c828:	01f956e2 	.word	0x01f956e2
    c82c:	50011000 	.word	0x50011000

0000c830 <am_hal_pdm_interrupt_enable>:
    uint32_t ui32Module = pState->ui32Module;

    //
    // Check the handle.
    //
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    c830:	6803      	ldr	r3, [r0, #0]
    c832:	4a07      	ldr	r2, [pc, #28]	; (c850 <am_hal_pdm_interrupt_enable+0x20>)
    c834:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    c838:	4293      	cmp	r3, r2
    c83a:	d107      	bne.n	c84c <am_hal_pdm_interrupt_enable+0x1c>

#if AM_CMSIS_REGS
    PDMn(ui32Module)->INTEN |= ui32IntMask;
    c83c:	4a05      	ldr	r2, [pc, #20]	; (c854 <am_hal_pdm_interrupt_enable+0x24>)
    c83e:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
    c842:	4319      	orrs	r1, r3
    c844:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
#else
    AM_REGn(PDM, ui32Module, INTEN) |= ui32IntMask;
#endif

    return AM_HAL_STATUS_SUCCESS;
    c848:	2000      	movs	r0, #0
    c84a:	4770      	bx	lr
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    c84c:	2002      	movs	r0, #2
}
    c84e:	4770      	bx	lr
    c850:	01f956e2 	.word	0x01f956e2
    c854:	50011000 	.word	0x50011000

0000c858 <am_hal_pdm_interrupt_clear>:
    uint32_t ui32Module = pState->ui32Module;

    //
    // Check the handle.
    //
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    c858:	6803      	ldr	r3, [r0, #0]
    c85a:	4a05      	ldr	r2, [pc, #20]	; (c870 <am_hal_pdm_interrupt_clear+0x18>)
    c85c:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    c860:	4293      	cmp	r3, r2

#if AM_CMSIS_REGS
    PDMn(ui32Module)->INTCLR = ui32IntMask;
    c862:	bf03      	ittte	eq
    c864:	4b03      	ldreq	r3, [pc, #12]	; (c874 <am_hal_pdm_interrupt_clear+0x1c>)
#else
    AM_REGn(PDM, ui32Module, INTCLR) = ui32IntMask;
#endif

    return AM_HAL_STATUS_SUCCESS;
    c866:	2000      	moveq	r0, #0
    PDMn(ui32Module)->INTCLR = ui32IntMask;
    c868:	f8c3 1208 	streq.w	r1, [r3, #520]	; 0x208
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    c86c:	2002      	movne	r0, #2
}
    c86e:	4770      	bx	lr
    c870:	01f956e2 	.word	0x01f956e2
    c874:	50011000 	.word	0x50011000

0000c878 <am_hal_pdm_interrupt_status_get>:
    uint32_t ui32Module = pState->ui32Module;

    //
    // Check the handle.
    //
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    c878:	6803      	ldr	r3, [r0, #0]
    c87a:	480c      	ldr	r0, [pc, #48]	; (c8ac <am_hal_pdm_interrupt_status_get+0x34>)
    c87c:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    c880:	4283      	cmp	r3, r0
    c882:	d110      	bne.n	c8a6 <am_hal_pdm_interrupt_status_get+0x2e>

#if AM_CMSIS_REGS
    //
    // If requested, only return the interrupts that are enabled.
    //
    if ( bEnabledOnly )
    c884:	b92a      	cbnz	r2, c892 <am_hal_pdm_interrupt_status_get+0x1a>
        *pui32Status = PDMn(ui32Module)->INTSTAT;
        *pui32Status &= PDMn(ui32Module)->INTEN;
    }
    else
    {
        *pui32Status = PDMn(ui32Module)->INTSTAT;
    c886:	4b0a      	ldr	r3, [pc, #40]	; (c8b0 <am_hal_pdm_interrupt_status_get+0x38>)
    c888:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
    c88c:	600b      	str	r3, [r1, #0]
    {
        *pui32Status = AM_REGn(PDM, ui32Module, INTSTAT);
    }
#endif

    return AM_HAL_STATUS_SUCCESS;
    c88e:	4610      	mov	r0, r2
    c890:	4770      	bx	lr
        *pui32Status = PDMn(ui32Module)->INTSTAT;
    c892:	4a07      	ldr	r2, [pc, #28]	; (c8b0 <am_hal_pdm_interrupt_status_get+0x38>)
    c894:	f8d2 3204 	ldr.w	r3, [r2, #516]	; 0x204
    c898:	600b      	str	r3, [r1, #0]
        *pui32Status &= PDMn(ui32Module)->INTEN;
    c89a:	f8d2 2200 	ldr.w	r2, [r2, #512]	; 0x200
    c89e:	4013      	ands	r3, r2
    c8a0:	600b      	str	r3, [r1, #0]
    return AM_HAL_STATUS_SUCCESS;
    c8a2:	2000      	movs	r0, #0
    c8a4:	4770      	bx	lr
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    c8a6:	2002      	movs	r0, #2
}
    c8a8:	4770      	bx	lr
    c8aa:	bf00      	nop
    c8ac:	01f956e2 	.word	0x01f956e2
    c8b0:	50011000 	.word	0x50011000

0000c8b4 <am_hal_gpio_pinconfig>:
    uint32_t ui32Padreg, ui32AltPadCfg, ui32GPCfg;
    uint32_t ui32Funcsel, ui32PowerSw;
    bool bClearEnable = false;

#ifdef AM_HAL_ENABLE_API_VALIDATION
    if ( ui32Pin > 49 )
    c8b4:	2831      	cmp	r0, #49	; 0x31
    c8b6:	f200 80c2 	bhi.w	ca3e <am_hal_gpio_pinconfig+0x18a>
{
    c8ba:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ui32GPCfg = ui32Padreg = ui32AltPadCfg = 0;

    //
    // Get the requested function and/or power switch.
    //
    ui32Funcsel = bfGpioCfg.uFuncSel;
    c8be:	f001 0207 	and.w	r2, r1, #7
    ui32Padreg |= ui32Funcsel << PADREG_FLD_FNSEL_S;

    //
    // Check for invalid configuration requests.
    //
    if ( bfGpioCfg.ePullup != AM_HAL_GPIO_PIN_PULLUP_NONE )
    c8c2:	f011 07e0 	ands.w	r7, r1, #224	; 0xe0
{
    c8c6:	b087      	sub	sp, #28
    ui32Padreg |= ui32Funcsel << PADREG_FLD_FNSEL_S;
    c8c8:	ea4f 03c2 	mov.w	r3, r2, lsl #3
    ui32PowerSw = bfGpioCfg.ePowerSw;
    c8cc:	f3c1 04c1 	ubfx	r4, r1, #3, #2
    if ( bfGpioCfg.ePullup != AM_HAL_GPIO_PIN_PULLUP_NONE )
    c8d0:	d011      	beq.n	c8f6 <am_hal_gpio_pinconfig+0x42>
        ui32Padreg |= (0x1 << PADREG_FLD_PULLUP_S);

        //
        // Check for specific pullup or pulldown settings.
        //
        if ( (bfGpioCfg.ePullup >= AM_HAL_GPIO_PIN_PULLUP_1_5K) &&
    c8d2:	f3c1 1642 	ubfx	r6, r1, #5, #3
    c8d6:	1db5      	adds	r5, r6, #6
    c8d8:	f005 0507 	and.w	r5, r5, #7
    c8dc:	2d03      	cmp	r5, #3
        ui32Padreg |= (0x1 << PADREG_FLD_PULLUP_S);
    c8de:	f043 0301 	orr.w	r3, r3, #1
        if ( (bfGpioCfg.ePullup >= AM_HAL_GPIO_PIN_PULLUP_1_5K) &&
    c8e2:	f200 80ae 	bhi.w	ca42 <am_hal_gpio_pinconfig+0x18e>
             (bfGpioCfg.ePullup <= AM_HAL_GPIO_PIN_PULLUP_24K) )
        {
            ui32Padreg |= ((bfGpioCfg.ePullup - AM_HAL_GPIO_PIN_PULLUP_1_5K) <<
                           PADREG_FLD_76_S);
#ifdef AM_HAL_ENABLE_API_VALIDATION
            if ( !(g_ui8Bit76Capabilities[ui32Pin] & CAP_PUP) )
    c8e6:	4d85      	ldr	r5, [pc, #532]	; (cafc <am_hal_gpio_pinconfig+0x248>)
    c8e8:	5c2d      	ldrb	r5, [r5, r0]
    c8ea:	07ef      	lsls	r7, r5, #31
    c8ec:	f140 80b4 	bpl.w	ca58 <am_hal_gpio_pinconfig+0x1a4>
            ui32Padreg |= ((bfGpioCfg.ePullup - AM_HAL_GPIO_PIN_PULLUP_1_5K) <<
    c8f0:	3e02      	subs	r6, #2
    c8f2:	ea43 1386 	orr.w	r3, r3, r6, lsl #6
    }

    //
    // Check if requesting a power switch pin
    //
    if ( ui32PowerSw != AM_HAL_GPIO_PIN_POWERSW_NONE )
    c8f6:	2c00      	cmp	r4, #0
    c8f8:	f040 8096 	bne.w	ca28 <am_hal_gpio_pinconfig+0x174>
    }

    //
    // Depending on the selected pin and FNSEL, determine if INPEN needs to be set.
    //
    ui32Padreg |= (g_ui8Inpen[ui32Pin] & (1 << ui32Funcsel)) ? (1 << PADREG_FLD_INPEN_S) : 0;
    c8fc:	4d80      	ldr	r5, [pc, #512]	; (cb00 <am_hal_gpio_pinconfig+0x24c>)

    //
    // Configure ui32GpCfg based on whether nCE requested.
    //
    if ( g_ui8nCEpins[ui32Pin] == ui32Funcsel )
    c8fe:	4c81      	ldr	r4, [pc, #516]	; (cb04 <am_hal_gpio_pinconfig+0x250>)
    ui32Padreg |= (g_ui8Inpen[ui32Pin] & (1 << ui32Funcsel)) ? (1 << PADREG_FLD_INPEN_S) : 0;
    c900:	5c2d      	ldrb	r5, [r5, r0]
    if ( g_ui8nCEpins[ui32Pin] == ui32Funcsel )
    c902:	5c24      	ldrb	r4, [r4, r0]
    ui32Padreg |= (g_ui8Inpen[ui32Pin] & (1 << ui32Funcsel)) ? (1 << PADREG_FLD_INPEN_S) : 0;
    c904:	4115      	asrs	r5, r2
    c906:	006d      	lsls	r5, r5, #1
    c908:	f005 0502 	and.w	r5, r5, #2
    if ( g_ui8nCEpins[ui32Pin] == ui32Funcsel )
    c90c:	4294      	cmp	r4, r2
    ui32Padreg |= (g_ui8Inpen[ui32Pin] & (1 << ui32Funcsel)) ? (1 << PADREG_FLD_INPEN_S) : 0;
    c90e:	ea45 0503 	orr.w	r5, r5, r3
    if ( g_ui8nCEpins[ui32Pin] == ui32Funcsel )
    c912:	f000 80b0 	beq.w	ca76 <am_hal_gpio_pinconfig+0x1c2>
        //  [INTD(1):OUTCFG(2):INCFG(1)].
        // Bit0 of eIntDir maps to GPIOCFG.INTD  (b3).
        // Bit1 of eIntDir maps to GPIOCFG.INCFG (b0).
        //
        ui32GPCfg |= (bfGpioCfg.eGPOutcfg << GPIOCFG_FLD_OUTCFG_S)              |
                     (((bfGpioCfg.eIntDir >> 0) & 0x1) << GPIOCFG_FLD_INTD_S)   |
    c916:	f3c1 3341 	ubfx	r3, r1, #13, #2
                     (((bfGpioCfg.eIntDir >> 1) & 0x1) << GPIOCFG_FLD_INCFG_S);

        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
    c91a:	f3c1 2407 	ubfx	r4, r1, #8, #8
                     (((bfGpioCfg.eIntDir >> 1) & 0x1) << GPIOCFG_FLD_INCFG_S);
    c91e:	105a      	asrs	r2, r3, #1
        ui32GPCfg |= (bfGpioCfg.eGPOutcfg << GPIOCFG_FLD_OUTCFG_S)              |
    c920:	f3c1 2681 	ubfx	r6, r1, #10, #2
                     (((bfGpioCfg.eIntDir >> 0) & 0x1) << GPIOCFG_FLD_INTD_S)   |
    c924:	00db      	lsls	r3, r3, #3
        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
    c926:	f004 070c 	and.w	r7, r4, #12
                     (((bfGpioCfg.eIntDir >> 0) & 0x1) << GPIOCFG_FLD_INTD_S)   |
    c92a:	ea42 0646 	orr.w	r6, r2, r6, lsl #1
    c92e:	f003 0308 	and.w	r3, r3, #8
        ui32Padreg |= (bfGpioCfg.eGPInput << PADREG_FLD_INPEN_S);
    c932:	f3c1 3200 	ubfx	r2, r1, #12, #1
        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
    c936:	2f04      	cmp	r7, #4
                     (((bfGpioCfg.eIntDir >> 0) & 0x1) << GPIOCFG_FLD_INTD_S)   |
    c938:	ea46 0603 	orr.w	r6, r6, r3
        ui32Padreg |= (bfGpioCfg.eGPInput << PADREG_FLD_INPEN_S);
    c93c:	ea45 0542 	orr.w	r5, r5, r2, lsl #1
        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
    c940:	f000 8093 	beq.w	ca6a <am_hal_gpio_pinconfig+0x1b6>
    ui32B = *((uint32_t*)cfg2);
    c944:	4b70      	ldr	r3, [pc, #448]	; (cb08 <am_hal_gpio_pinconfig+0x254>)
        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
    c946:	681b      	ldr	r3, [r3, #0]
    c948:	1acb      	subs	r3, r1, r3
    c94a:	fab3 f383 	clz	r3, r3
    c94e:	095b      	lsrs	r3, r3, #5
        //  use when GPIO interrupts are not in use and can be used when no
        //  eIntDir setting is provided.
        // If eIntDir is provided, eGPRdZero is ignored and can only be
        //  achieved via the AM_HAL_GPIO_PIN_INTDIR_NONE setting.
        //
        if ( bfGpioCfg.eIntDir == 0 )
    c950:	f014 0f60 	tst.w	r4, #96	; 0x60
        {
            ui32GPCfg &= ~(1 << GPIOCFG_FLD_INCFG_S);
            ui32GPCfg |= (bfGpioCfg.eGPRdZero << GPIOCFG_FLD_INCFG_S);
    c954:	bf04      	itt	eq
    c956:	f3c1 32c0 	ubfxeq	r2, r1, #15, #1
    c95a:	f362 0600 	bfieq	r6, r2, #0, #1
    c95e:	ea4f 0e80 	mov.w	lr, r0, lsl #2
        }
    }

    switch ( bfGpioCfg.eDriveStrength )
    c962:	f3c1 2101 	ubfx	r1, r1, #8, #2
    c966:	ea4f 0cc0 	mov.w	ip, r0, lsl #3
    c96a:	2902      	cmp	r1, #2
    c96c:	f00c 0c18 	and.w	ip, ip, #24
    c970:	f000 80a7 	beq.w	cac2 <am_hal_gpio_pinconfig+0x20e>
    c974:	f200 809e 	bhi.w	cab4 <am_hal_gpio_pinconfig+0x200>
    c978:	2901      	cmp	r1, #1
    c97a:	f040 8098 	bne.w	caae <am_hal_gpio_pinconfig+0x1fa>
            ui32AltPadCfg |= (0 << 0);
            break;
        case AM_HAL_GPIO_PIN_DRIVESTRENGTH_4MA:
            ui32Padreg    |= (1 << PADREG_FLD_DRVSTR_S);
            ui32AltPadCfg |= (0 << 0);
            break;
    c97e:	2200      	movs	r2, #0
            ui32Padreg    |= (1 << PADREG_FLD_DRVSTR_S);
    c980:	f045 0504 	orr.w	r5, r5, #4
            break;
    c984:	9203      	str	r2, [sp, #12]
    c986:	4604      	mov	r4, r0
    uint32_t ui32GPCfgShft, ui32PadShft;

#if AM_CMSIS_REGS
    ui32GPCfgAddr       = (uint32_t)&GPIO->CFGA       + ((ui32Pin & ~0x7) >> 1);
    ui32PadregAddr      = (uint32_t)&GPIO->PADREGA    + (ui32Pin & ~0x3);
    ui32AltpadAddr      = (uint32_t)&GPIO->ALTPADCFGA + (ui32Pin & ~0x3);
    c988:	4a60      	ldr	r2, [pc, #384]	; (cb0c <am_hal_gpio_pinconfig+0x258>)
    c98a:	4961      	ldr	r1, [pc, #388]	; (cb10 <am_hal_gpio_pinconfig+0x25c>)
    ui32GPCfgAddr       = (uint32_t)&GPIO->CFGA       + ((ui32Pin & ~0x7) >> 1);
    c98c:	4861      	ldr	r0, [pc, #388]	; (cb14 <am_hal_gpio_pinconfig+0x260>)
    c98e:	9302      	str	r3, [sp, #8]
#else // AM_CMSIS_REGS
    ui32GPCfgAddr       = AM_REG_GPIOn(0) + AM_REG_GPIO_CFGA_O       + ((ui32Pin & ~0x7) >> 1);
    ui32PadregAddr      = AM_REG_GPIOn(0) + AM_REG_GPIO_PADREGA_O    + (ui32Pin & ~0x3);
    ui32AltpadAddr      = AM_REG_GPIOn(0) + AM_REG_GPIO_ALTPADCFGA_O + (ui32Pin & ~0x3);
#endif // AM_CMSIS_REGS
    ui32GPCfgShft       = ((ui32Pin & 0x7) << 2);
    c990:	f00e 0e1c 	and.w	lr, lr, #28
    ui32PadShft         = ((ui32Pin & 0x3) << 3);
    ui32GPCfgClearMask  = ~((uint32_t)0xF  << ui32GPCfgShft);
    c994:	f04f 080f 	mov.w	r8, #15
    ui32PadClearMask    = ~((uint32_t)0xFF << ui32PadShft);
    c998:	27ff      	movs	r7, #255	; 0xff
    ui32AltpadAddr      = (uint32_t)&GPIO->ALTPADCFGA + (ui32Pin & ~0x3);
    c99a:	e9cd 2100 	strd	r2, r1, [sp]
    ui32GPCfgClearMask  = ~((uint32_t)0xF  << ui32GPCfgShft);
    c99e:	fa08 f80e 	lsl.w	r8, r8, lr
    ui32PadClearMask    = ~((uint32_t)0xFF << ui32PadShft);
    c9a2:	fa07 f70c 	lsl.w	r7, r7, ip
    //
    // Get the new values into their rightful bit positions.
    //
    ui32Padreg    <<= ui32PadShft;
    ui32AltPadCfg <<= ui32PadShft;
    ui32GPCfg     <<= ui32GPCfgShft;
    c9a6:	fa06 f60e 	lsl.w	r6, r6, lr
    ui32Padreg    <<= ui32PadShft;
    c9aa:	fa05 f50c 	lsl.w	r5, r5, ip
    ui32GPCfgAddr       = (uint32_t)&GPIO->CFGA       + ((ui32Pin & ~0x7) >> 1);
    c9ae:	ea00 0954 	and.w	r9, r0, r4, lsr #1

    AM_CRITICAL_BEGIN
    c9b2:	f026 fedd 	bl	33770 <am_hal_interrupt_master_disable>
    ui32PadregAddr      = (uint32_t)&GPIO->PADREGA    + (ui32Pin & ~0x3);
    c9b6:	f024 0b03 	bic.w	fp, r4, #3

    if ( bClearEnable )
    c9ba:	9b02      	ldr	r3, [sp, #8]
    AM_CRITICAL_BEGIN
    c9bc:	9005      	str	r0, [sp, #20]
    ui32PadregAddr      = (uint32_t)&GPIO->PADREGA    + (ui32Pin & ~0x3);
    c9be:	f10b 4a80 	add.w	sl, fp, #1073741824	; 0x40000000
    ui32GPCfgClearMask  = ~((uint32_t)0xF  << ui32GPCfgShft);
    c9c2:	ea6f 0808 	mvn.w	r8, r8
    ui32PadClearMask    = ~((uint32_t)0xFF << ui32PadShft);
    c9c6:	43ff      	mvns	r7, r7
    ui32PadregAddr      = (uint32_t)&GPIO->PADREGA    + (ui32Pin & ~0x3);
    c9c8:	f50a 3a80 	add.w	sl, sl, #65536	; 0x10000
    if ( bClearEnable )
    c9cc:	e9dd 2100 	ldrd	r2, r1, [sp]
    c9d0:	b14b      	cbz	r3, c9e6 <am_hal_gpio_pinconfig+0x132>
    {
        //
        // We're configuring a mode that requires clearing the Enable bit.
        //
        am_hal_gpio_output_tristate_disable(ui32Pin);
    c9d2:	f004 031f 	and.w	r3, r4, #31
    c9d6:	f04f 0c01 	mov.w	ip, #1
    c9da:	0964      	lsrs	r4, r4, #5
    c9dc:	484e      	ldr	r0, [pc, #312]	; (cb18 <am_hal_gpio_pinconfig+0x264>)
    c9de:	fa0c f303 	lsl.w	r3, ip, r3
    c9e2:	f840 3024 	str.w	r3, [r0, r4, lsl #2]
    }

#if AM_CMSIS_REGS
    GPIO->PADKEY = GPIO_PADKEY_PADKEY_Key;
    c9e6:	4b4d      	ldr	r3, [pc, #308]	; (cb1c <am_hal_gpio_pinconfig+0x268>)
    c9e8:	2073      	movs	r0, #115	; 0x73
    c9ea:	6618      	str	r0, [r3, #96]	; 0x60

    AM_REGVAL(ui32PadregAddr)  = (AM_REGVAL(ui32PadregAddr) & ui32PadClearMask)   | ui32Padreg;
    c9ec:	f8da 0000 	ldr.w	r0, [sl]
    c9f0:	4038      	ands	r0, r7
    c9f2:	4305      	orrs	r5, r0
    c9f4:	f8ca 5000 	str.w	r5, [sl]
    AM_REGVAL(ui32GPCfgAddr)   = (AM_REGVAL(ui32GPCfgAddr)  & ui32GPCfgClearMask) | ui32GPCfg;
    c9f8:	f859 0001 	ldr.w	r0, [r9, r1]
    c9fc:	ea00 0808 	and.w	r8, r0, r8
    ca00:	ea48 0606 	orr.w	r6, r8, r6
    ca04:	f849 6001 	str.w	r6, [r9, r1]
    AM_REGVAL(ui32AltpadAddr)  = (AM_REGVAL(ui32AltpadAddr) & ui32PadClearMask)   | ui32AltPadCfg;
    ca08:	f85b 1002 	ldr.w	r1, [fp, r2]
    ca0c:	400f      	ands	r7, r1
    ca0e:	9903      	ldr	r1, [sp, #12]

    GPIO->PADKEY = 0;
    ca10:	2400      	movs	r4, #0
    AM_REGVAL(ui32AltpadAddr)  = (AM_REGVAL(ui32AltpadAddr) & ui32PadClearMask)   | ui32AltPadCfg;
    ca12:	430f      	orrs	r7, r1
    ca14:	f84b 7002 	str.w	r7, [fp, r2]
    GPIO->PADKEY = 0;
    ca18:	661c      	str	r4, [r3, #96]	; 0x60
    AM_REGVAL(ui32AltpadAddr)  = (AM_REGVAL(ui32AltpadAddr) & ui32PadClearMask)   | ui32AltPadCfg;

    AM_REGn(GPIO, 0, PADKEY) = 0;
#endif // AM_CMSIS_REGS

    AM_CRITICAL_END
    ca1a:	9805      	ldr	r0, [sp, #20]
    ca1c:	f026 feac 	bl	33778 <am_hal_interrupt_master_set>

    return AM_HAL_STATUS_SUCCESS;
    ca20:	4620      	mov	r0, r4

} // am_hal_gpio_pinconfig()
    ca22:	b007      	add	sp, #28
    ca24:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ( (ui32PowerSw == AM_HAL_GPIO_PIN_POWERSW_VDD)  &&
    ca28:	2c01      	cmp	r4, #1
    ca2a:	d017      	beq.n	ca5c <am_hal_gpio_pinconfig+0x1a8>
        else if ( (ui32PowerSw == AM_HAL_GPIO_PIN_POWERSW_VSS)  &&
    ca2c:	2c02      	cmp	r4, #2
    ca2e:	d11e      	bne.n	ca6e <am_hal_gpio_pinconfig+0x1ba>
                  (g_ui8Bit76Capabilities[ui32Pin] & CAP_VSS) )
    ca30:	4c32      	ldr	r4, [pc, #200]	; (cafc <am_hal_gpio_pinconfig+0x248>)
        else if ( (ui32PowerSw == AM_HAL_GPIO_PIN_POWERSW_VSS)  &&
    ca32:	5c24      	ldrb	r4, [r4, r0]
    ca34:	0764      	lsls	r4, r4, #29
    ca36:	d51a      	bpl.n	ca6e <am_hal_gpio_pinconfig+0x1ba>
            ui32Padreg |= 0x2 << PADREG_FLD_76_S;
    ca38:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    ca3c:	e75e      	b.n	c8fc <am_hal_gpio_pinconfig+0x48>
        return AM_HAL_STATUS_INVALID_ARG;
    ca3e:	2006      	movs	r0, #6
} // am_hal_gpio_pinconfig()
    ca40:	4770      	bx	lr
        else if ( bfGpioCfg.ePullup == AM_HAL_GPIO_PIN_PULLDOWN )
    ca42:	2fc0      	cmp	r7, #192	; 0xc0
    ca44:	d042      	beq.n	cacc <am_hal_gpio_pinconfig+0x218>
        else if ( bfGpioCfg.ePullup == AM_HAL_GPIO_PIN_PULLUP_WEAK )
    ca46:	2f20      	cmp	r7, #32
    ca48:	f47f af55 	bne.w	c8f6 <am_hal_gpio_pinconfig+0x42>
            if ( g_ui8Bit76Capabilities[ui32Pin] & (CAP_PUP | CAP_PDN) )
    ca4c:	4d2b      	ldr	r5, [pc, #172]	; (cafc <am_hal_gpio_pinconfig+0x248>)
    ca4e:	5c2d      	ldrb	r5, [r5, r0]
    ca50:	f015 0f09 	tst.w	r5, #9
    ca54:	f43f af4f 	beq.w	c8f6 <am_hal_gpio_pinconfig+0x42>
                return AM_HAL_GPIO_ERR_PULLUP;
    ca58:	4831      	ldr	r0, [pc, #196]	; (cb20 <am_hal_gpio_pinconfig+0x26c>)
    ca5a:	e7e2      	b.n	ca22 <am_hal_gpio_pinconfig+0x16e>
             (g_ui8Bit76Capabilities[ui32Pin] & CAP_VDD) )
    ca5c:	4c27      	ldr	r4, [pc, #156]	; (cafc <am_hal_gpio_pinconfig+0x248>)
        if ( (ui32PowerSw == AM_HAL_GPIO_PIN_POWERSW_VDD)  &&
    ca5e:	5c24      	ldrb	r4, [r4, r0]
    ca60:	07a5      	lsls	r5, r4, #30
    ca62:	d504      	bpl.n	ca6e <am_hal_gpio_pinconfig+0x1ba>
            ui32Padreg |= 0x1 << PADREG_FLD_76_S;
    ca64:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    ca68:	e748      	b.n	c8fc <am_hal_gpio_pinconfig+0x48>
            bClearEnable = true;
    ca6a:	2301      	movs	r3, #1
    ca6c:	e770      	b.n	c950 <am_hal_gpio_pinconfig+0x9c>
            return AM_HAL_GPIO_ERR_PWRSW;
    ca6e:	482d      	ldr	r0, [pc, #180]	; (cb24 <am_hal_gpio_pinconfig+0x270>)
} // am_hal_gpio_pinconfig()
    ca70:	b007      	add	sp, #28
    ca72:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ( bfGpioCfg.uIOMnum > IOMNUM_MAX )
    ca76:	f3c1 4302 	ubfx	r3, r1, #16, #3
    ca7a:	2b07      	cmp	r3, #7
    ca7c:	d02b      	beq.n	cad6 <am_hal_gpio_pinconfig+0x222>
            if ( g_ui8NCEtable[ui32Pin][ui32Outcfg] == ui8CEtbl )
    ca7e:	4c2a      	ldr	r4, [pc, #168]	; (cb28 <am_hal_gpio_pinconfig+0x274>)
        ui8CEtbl = (bfGpioCfg.uIOMnum << 4) | bfGpioCfg.uNCE;
    ca80:	f3c1 42c1 	ubfx	r2, r1, #19, #2
            if ( g_ui8NCEtable[ui32Pin][ui32Outcfg] == ui8CEtbl )
    ca84:	f814 6020 	ldrb.w	r6, [r4, r0, lsl #2]
        ui8CEtbl = (bfGpioCfg.uIOMnum << 4) | bfGpioCfg.uNCE;
    ca88:	ea42 1303 	orr.w	r3, r2, r3, lsl #4
            if ( g_ui8NCEtable[ui32Pin][ui32Outcfg] == ui8CEtbl )
    ca8c:	429e      	cmp	r6, r3
    ca8e:	d024      	beq.n	cada <am_hal_gpio_pinconfig+0x226>
    ca90:	ea4f 0e80 	mov.w	lr, r0, lsl #2
    ca94:	eb04 020e 	add.w	r2, r4, lr
    ca98:	7854      	ldrb	r4, [r2, #1]
    ca9a:	429c      	cmp	r4, r3
    ca9c:	d027      	beq.n	caee <am_hal_gpio_pinconfig+0x23a>
    ca9e:	7894      	ldrb	r4, [r2, #2]
    caa0:	429c      	cmp	r4, r3
    caa2:	d026      	beq.n	caf2 <am_hal_gpio_pinconfig+0x23e>
    caa4:	78d2      	ldrb	r2, [r2, #3]
    caa6:	429a      	cmp	r2, r3
    caa8:	d025      	beq.n	caf6 <am_hal_gpio_pinconfig+0x242>
            return AM_HAL_GPIO_ERR_INVCEPIN;
    caaa:	4820      	ldr	r0, [pc, #128]	; (cb2c <am_hal_gpio_pinconfig+0x278>)
    caac:	e7b9      	b.n	ca22 <am_hal_gpio_pinconfig+0x16e>
    switch ( bfGpioCfg.eDriveStrength )
    caae:	2200      	movs	r2, #0
    cab0:	9203      	str	r2, [sp, #12]
    cab2:	e768      	b.n	c986 <am_hal_gpio_pinconfig+0xd2>
    cab4:	2701      	movs	r7, #1
    cab6:	fa07 f20c 	lsl.w	r2, r7, ip
            ui32Padreg    |= (1 << PADREG_FLD_DRVSTR_S);
    caba:	f045 0504 	orr.w	r5, r5, #4
    cabe:	9203      	str	r2, [sp, #12]
            break;
    cac0:	e761      	b.n	c986 <am_hal_gpio_pinconfig+0xd2>
    cac2:	2701      	movs	r7, #1
    cac4:	fa07 f20c 	lsl.w	r2, r7, ip
    cac8:	9203      	str	r2, [sp, #12]
            break;
    caca:	e75c      	b.n	c986 <am_hal_gpio_pinconfig+0xd2>
            if ( ui32Pin != 20 )
    cacc:	2814      	cmp	r0, #20
    cace:	f43f af12 	beq.w	c8f6 <am_hal_gpio_pinconfig+0x42>
                return AM_HAL_GPIO_ERR_PULLDOWN;
    cad2:	4817      	ldr	r0, [pc, #92]	; (cb30 <am_hal_gpio_pinconfig+0x27c>)
    cad4:	e7a5      	b.n	ca22 <am_hal_gpio_pinconfig+0x16e>
            return AM_HAL_GPIO_ERR_INVCE;   // Invalid CE specified
    cad6:	4817      	ldr	r0, [pc, #92]	; (cb34 <am_hal_gpio_pinconfig+0x280>)
    cad8:	e7a3      	b.n	ca22 <am_hal_gpio_pinconfig+0x16e>
        for ( ui32Outcfg = 0; ui32Outcfg < 4; ui32Outcfg++ )
    cada:	2600      	movs	r6, #0
    cadc:	ea4f 0e80 	mov.w	lr, r0, lsl #2
                     (bfGpioCfg.eCEpol << GPIOCFG_FLD_INTD_S)   |
    cae0:	f3c1 5340 	ubfx	r3, r1, #21, #1
        ui32GPCfg |= (ui32Outcfg       << GPIOCFG_FLD_OUTCFG_S) |
    cae4:	0076      	lsls	r6, r6, #1
                     (bfGpioCfg.eCEpol << GPIOCFG_FLD_INTD_S)   |
    cae6:	ea46 06c3 	orr.w	r6, r6, r3, lsl #3
    bool bClearEnable = false;
    caea:	2300      	movs	r3, #0
    caec:	e739      	b.n	c962 <am_hal_gpio_pinconfig+0xae>
        for ( ui32Outcfg = 0; ui32Outcfg < 4; ui32Outcfg++ )
    caee:	2601      	movs	r6, #1
    caf0:	e7f6      	b.n	cae0 <am_hal_gpio_pinconfig+0x22c>
    caf2:	2602      	movs	r6, #2
    caf4:	e7f4      	b.n	cae0 <am_hal_gpio_pinconfig+0x22c>
    caf6:	2603      	movs	r6, #3
    caf8:	e7f2      	b.n	cae0 <am_hal_gpio_pinconfig+0x22c>
    cafa:	bf00      	nop
    cafc:	00035af0 	.word	0x00035af0
    cb00:	00035b24 	.word	0x00035b24
    cb04:	00035c20 	.word	0x00035c20
    cb08:	00035ae4 	.word	0x00035ae4
    cb0c:	400100e0 	.word	0x400100e0
    cb10:	40010040 	.word	0x40010040
    cb14:	7ffffffc 	.word	0x7ffffffc
    cb18:	400100b4 	.word	0x400100b4
    cb1c:	40010000 	.word	0x40010000
    cb20:	08000100 	.word	0x08000100
    cb24:	08000102 	.word	0x08000102
    cb28:	00035b58 	.word	0x00035b58
    cb2c:	08000104 	.word	0x08000104
    cb30:	08000101 	.word	0x08000101
    cb34:	08000103 	.word	0x08000103

0000cb38 <am_hal_gpio_state_read>:
{
    uint32_t ui32ReadValue = 0xFFFFFFFF;
    uint32_t ui32BaseAddr, ui32Shift;

#ifdef AM_HAL_ENABLE_API_VALIDATION
    if ( pui32ReadState == NULL )
    cb38:	b1a2      	cbz	r2, cb64 <am_hal_gpio_state_read+0x2c>
    {
        return AM_HAL_STATUS_INVALID_ARG;
    }

    if ( ui32Pin >= AM_HAL_GPIO_MAX_PADS )
    cb3a:	2831      	cmp	r0, #49	; 0x31
    cb3c:	d814      	bhi.n	cb68 <am_hal_gpio_state_read+0x30>
#if AM_CMSIS_REGS
    ui32BaseAddr = ((ui32Pin & 0x20) >> (3 + 2));   // 0 or 1
    ui32Shift    = ui32Pin & 0x1F;
    //ui32Mask     = 1 << ui32Shift;

    switch ( eReadType )
    cb3e:	2901      	cmp	r1, #1
    ui32BaseAddr = ((ui32Pin & 0x20) >> (3 + 2));   // 0 or 1
    cb40:	ea4f 1350 	mov.w	r3, r0, lsr #5
    ui32Shift    = ui32Pin & 0x1F;
    cb44:	f000 001f 	and.w	r0, r0, #31
    switch ( eReadType )
    cb48:	d013      	beq.n	cb72 <am_hal_gpio_state_read+0x3a>
    cb4a:	d31c      	bcc.n	cb86 <am_hal_gpio_state_read+0x4e>
    cb4c:	2902      	cmp	r1, #2
    cb4e:	d109      	bne.n	cb64 <am_hal_gpio_state_read+0x2c>
        case AM_HAL_GPIO_OUTPUT_READ:
            ui32ReadValue = AM_REGVAL(&GPIO->WTA + ui32BaseAddr);
            ui32ReadValue = (ui32ReadValue >> ui32Shift) & 0x01;
            break;
        case AM_HAL_GPIO_ENABLE_READ:
            ui32ReadValue = AM_REGVAL(&GPIO->ENA + ui32BaseAddr);
    cb50:	4912      	ldr	r1, [pc, #72]	; (cb9c <am_hal_gpio_state_read+0x64>)
    cb52:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
            ui32ReadValue = (ui32ReadValue >> ui32Shift) & 0x01;
    cb56:	fa23 f000 	lsr.w	r0, r3, r0
    cb5a:	f000 0001 	and.w	r0, r0, #1
        default:
            return AM_HAL_STATUS_INVALID_ARG;
    }
#endif // AM_CMSIS_REGS

    *pui32ReadState = ui32ReadValue;
    cb5e:	6010      	str	r0, [r2, #0]

    return AM_HAL_STATUS_SUCCESS;
    cb60:	2000      	movs	r0, #0
    cb62:	4770      	bx	lr
            return AM_HAL_STATUS_INVALID_ARG;
    cb64:	2006      	movs	r0, #6
} // am_hal_gpio_state_read()
    cb66:	4770      	bx	lr
        *pui32ReadState = ui32ReadValue;
    cb68:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    cb6c:	6013      	str	r3, [r2, #0]
        return AM_HAL_STATUS_OUT_OF_RANGE;
    cb6e:	2005      	movs	r0, #5
    cb70:	4770      	bx	lr
            ui32ReadValue = AM_REGVAL(&GPIO->WTA + ui32BaseAddr);
    cb72:	490b      	ldr	r1, [pc, #44]	; (cba0 <am_hal_gpio_state_read+0x68>)
    cb74:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
            ui32ReadValue = (ui32ReadValue >> ui32Shift) & 0x01;
    cb78:	fa23 f000 	lsr.w	r0, r3, r0
    cb7c:	f000 0001 	and.w	r0, r0, #1
    *pui32ReadState = ui32ReadValue;
    cb80:	6010      	str	r0, [r2, #0]
    return AM_HAL_STATUS_SUCCESS;
    cb82:	2000      	movs	r0, #0
    cb84:	4770      	bx	lr
            ui32ReadValue = AM_REGVAL(&GPIO->RDA + ui32BaseAddr);
    cb86:	4907      	ldr	r1, [pc, #28]	; (cba4 <am_hal_gpio_state_read+0x6c>)
    cb88:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
            ui32ReadValue = (ui32ReadValue >> ui32Shift) & 0x01;
    cb8c:	fa23 f000 	lsr.w	r0, r3, r0
    cb90:	f000 0001 	and.w	r0, r0, #1
    *pui32ReadState = ui32ReadValue;
    cb94:	6010      	str	r0, [r2, #0]
    return AM_HAL_STATUS_SUCCESS;
    cb96:	2000      	movs	r0, #0
    cb98:	4770      	bx	lr
    cb9a:	bf00      	nop
    cb9c:	400100a0 	.word	0x400100a0
    cba0:	40010088 	.word	0x40010088
    cba4:	40010080 	.word	0x40010080

0000cba8 <am_hal_gpio_state_write>:
{
    uint32_t ui32Mask, ui32Off;
    uint32_t ui32Return = AM_HAL_STATUS_SUCCESS;

#ifdef AM_HAL_ENABLE_API_VALIDATION
    if ( ui32Pin >= AM_HAL_GPIO_MAX_PADS )
    cba8:	2831      	cmp	r0, #49	; 0x31
    cbaa:	d819      	bhi.n	cbe0 <am_hal_gpio_state_write+0x38>
    {
        return AM_HAL_STATUS_OUT_OF_RANGE;
    }

    if ( eWriteType > AM_HAL_GPIO_OUTPUT_TRISTATE_TOGGLE )
    cbac:	2905      	cmp	r1, #5
    cbae:	d815      	bhi.n	cbdc <am_hal_gpio_state_write+0x34>
{
    cbb0:	b570      	push	{r4, r5, r6, lr}
    {
        return AM_HAL_STATUS_INVALID_ARG;
    }
#endif // AM_HAL_ENABLE_API_VALIDATION

    ui32Mask = (uint32_t)0x1 << (ui32Pin % 32);
    cbb2:	f000 031f 	and.w	r3, r0, #31
{
    cbb6:	b082      	sub	sp, #8
    ui32Off  = (ui32Pin & 0x20) >> 3;   // 0 or 4
    cbb8:	08c0      	lsrs	r0, r0, #3
    ui32Mask = (uint32_t)0x1 << (ui32Pin % 32);
    cbba:	2201      	movs	r2, #1
    cbbc:	460d      	mov	r5, r1
    ui32Off  = (ui32Pin & 0x20) >> 3;   // 0 or 4
    cbbe:	f000 0404 	and.w	r4, r0, #4
    ui32Mask = (uint32_t)0x1 << (ui32Pin % 32);
    cbc2:	fa02 f603 	lsl.w	r6, r2, r3

    AM_CRITICAL_BEGIN;
    cbc6:	f026 fdd3 	bl	33770 <am_hal_interrupt_master_disable>

#if AM_CMSIS_REGS
    ui32Off /= 4;   // 0 or 1 for ptr arithmetic
    switch ( eWriteType )
    cbca:	1e69      	subs	r1, r5, #1
    AM_CRITICAL_BEGIN;
    cbcc:	9001      	str	r0, [sp, #4]
    switch ( eWriteType )
    cbce:	2904      	cmp	r1, #4
    cbd0:	d81b      	bhi.n	cc0a <am_hal_gpio_state_write+0x62>
    cbd2:	e8df f001 	tbb	[pc, r1]
    cbd6:	1217      	.short	0x1217
    cbd8:	070f      	.short	0x070f
    cbda:	1d          	.byte	0x1d
    cbdb:	00          	.byte	0x00
        return AM_HAL_STATUS_INVALID_ARG;
    cbdc:	2006      	movs	r0, #6
#endif // AM_CMSIS_REGS

    AM_CRITICAL_END;

    return ui32Return;
} // am_hal_gpio_state_write()
    cbde:	4770      	bx	lr
        return AM_HAL_STATUS_OUT_OF_RANGE;
    cbe0:	2005      	movs	r0, #5
    cbe2:	4770      	bx	lr
            AM_REGVAL(&GPIO->ENSA + ui32Off) = ui32Mask;
    cbe4:	4b0d      	ldr	r3, [pc, #52]	; (cc1c <am_hal_gpio_state_write+0x74>)
    cbe6:	50e6      	str	r6, [r4, r3]
    AM_CRITICAL_END;
    cbe8:	9801      	ldr	r0, [sp, #4]
    cbea:	f026 fdc5 	bl	33778 <am_hal_interrupt_master_set>
    return ui32Return;
    cbee:	2000      	movs	r0, #0
} // am_hal_gpio_state_write()
    cbf0:	b002      	add	sp, #8
    cbf2:	bd70      	pop	{r4, r5, r6, pc}
            AM_REGVAL(&GPIO->ENCA + ui32Off) = ui32Mask;
    cbf4:	4b0a      	ldr	r3, [pc, #40]	; (cc20 <am_hal_gpio_state_write+0x78>)
    cbf6:	50e6      	str	r6, [r4, r3]
            break;
    cbf8:	e7f6      	b.n	cbe8 <am_hal_gpio_state_write+0x40>
            AM_REGVAL(&GPIO->WTA + ui32Off) ^= ui32Mask;
    cbfa:	4a0a      	ldr	r2, [pc, #40]	; (cc24 <am_hal_gpio_state_write+0x7c>)
    cbfc:	58a3      	ldr	r3, [r4, r2]
    cbfe:	4073      	eors	r3, r6
    cc00:	50a3      	str	r3, [r4, r2]
            break;
    cc02:	e7f1      	b.n	cbe8 <am_hal_gpio_state_write+0x40>
            AM_REGVAL(&GPIO->WTSA + ui32Off) = ui32Mask;
    cc04:	4b08      	ldr	r3, [pc, #32]	; (cc28 <am_hal_gpio_state_write+0x80>)
    cc06:	50e6      	str	r6, [r4, r3]
            break;
    cc08:	e7ee      	b.n	cbe8 <am_hal_gpio_state_write+0x40>
            AM_REGVAL(&GPIO->WTCA + ui32Off) = ui32Mask;
    cc0a:	4b08      	ldr	r3, [pc, #32]	; (cc2c <am_hal_gpio_state_write+0x84>)
    cc0c:	50e6      	str	r6, [r4, r3]
            break;
    cc0e:	e7eb      	b.n	cbe8 <am_hal_gpio_state_write+0x40>
            AM_REGVAL(&GPIO->ENCA + ui32Off) ^= ui32Mask;
    cc10:	4a03      	ldr	r2, [pc, #12]	; (cc20 <am_hal_gpio_state_write+0x78>)
    cc12:	58a3      	ldr	r3, [r4, r2]
    cc14:	4073      	eors	r3, r6
    cc16:	50a3      	str	r3, [r4, r2]
            break;
    cc18:	e7e6      	b.n	cbe8 <am_hal_gpio_state_write+0x40>
    cc1a:	bf00      	nop
    cc1c:	400100a8 	.word	0x400100a8
    cc20:	400100b4 	.word	0x400100b4
    cc24:	40010088 	.word	0x40010088
    cc28:	40010090 	.word	0x40010090
    cc2c:	40010098 	.word	0x40010098

0000cc30 <am_hal_gpio_interrupt_enable>:
// Enable GPIO interrupts.
//
//*****************************************************************************
uint32_t
am_hal_gpio_interrupt_enable(uint64_t ui64InterruptMask)
{
    cc30:	b530      	push	{r4, r5, lr}
#ifdef AM_HAL_ENABLE_API_VALIDATION
    //
    // Check parameters
    //
    if ( ui64InterruptMask &  ~(((uint64_t)1 << AM_HAL_GPIO_MAX_PADS) - 1) )
    cc32:	4b11      	ldr	r3, [pc, #68]	; (cc78 <am_hal_gpio_interrupt_enable+0x48>)
    cc34:	2200      	movs	r2, #0
    cc36:	ea02 0400 	and.w	r4, r2, r0
    cc3a:	ea03 0501 	and.w	r5, r3, r1
    cc3e:	ea54 0305 	orrs.w	r3, r4, r5
{
    cc42:	b083      	sub	sp, #12
    if ( ui64InterruptMask &  ~(((uint64_t)1 << AM_HAL_GPIO_MAX_PADS) - 1) )
    cc44:	d115      	bne.n	cc72 <am_hal_gpio_interrupt_enable+0x42>
    cc46:	460d      	mov	r5, r1
    cc48:	4604      	mov	r4, r0
#endif // AM_HAL_ENABLE_API_VALIDATION

    //
    // Enable the interrupts.
    //
    AM_CRITICAL_BEGIN
    cc4a:	f026 fd91 	bl	33770 <am_hal_interrupt_master_disable>

#if AM_CMSIS_REGS
    GPIO->INT0EN |= (uint32_t)(ui64InterruptMask & 0xFFFFFFFF);
    cc4e:	4b0b      	ldr	r3, [pc, #44]	; (cc7c <am_hal_gpio_interrupt_enable+0x4c>)
    AM_CRITICAL_BEGIN
    cc50:	9001      	str	r0, [sp, #4]
    GPIO->INT0EN |= (uint32_t)(ui64InterruptMask & 0xFFFFFFFF);
    cc52:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    cc56:	4322      	orrs	r2, r4
    cc58:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
    GPIO->INT1EN |= (uint32_t)(ui64InterruptMask >> 32);
    cc5c:	f8d3 2210 	ldr.w	r2, [r3, #528]	; 0x210
    cc60:	432a      	orrs	r2, r5
    cc62:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
#else // AM_CMSIS_REGS
    AM_REG(GPIO, INT1EN) |= (ui64InterruptMask >> 32);
    AM_REG(GPIO, INT0EN) |= (ui64InterruptMask & 0xFFFFFFFF);
#endif // AM_CMSIS_REGS

    AM_CRITICAL_END
    cc66:	9801      	ldr	r0, [sp, #4]
    cc68:	f026 fd86 	bl	33778 <am_hal_interrupt_master_set>

    //
    // Return the status.
    //
    return AM_HAL_STATUS_SUCCESS;
    cc6c:	2000      	movs	r0, #0

} // am_hal_gpio_interrupt_enable()
    cc6e:	b003      	add	sp, #12
    cc70:	bd30      	pop	{r4, r5, pc}
        return AM_HAL_STATUS_OUT_OF_RANGE;
    cc72:	2005      	movs	r0, #5
} // am_hal_gpio_interrupt_enable()
    cc74:	b003      	add	sp, #12
    cc76:	bd30      	pop	{r4, r5, pc}
    cc78:	fffc0000 	.word	0xfffc0000
    cc7c:	40010000 	.word	0x40010000

0000cc80 <am_hal_gpio_interrupt_clear>:
// Clear GPIO interrupts.
//
//*****************************************************************************
uint32_t
am_hal_gpio_interrupt_clear(uint64_t ui64InterruptMask)
{
    cc80:	b530      	push	{r4, r5, lr}
#ifdef AM_HAL_ENABLE_API_VALIDATION
    //
    // Check parameters
    //
    if ( ui64InterruptMask &  ~(((uint64_t)1 << AM_HAL_GPIO_MAX_PADS) - 1) )
    cc82:	4b0e      	ldr	r3, [pc, #56]	; (ccbc <am_hal_gpio_interrupt_clear+0x3c>)
    cc84:	2200      	movs	r2, #0
    cc86:	ea02 0400 	and.w	r4, r2, r0
    cc8a:	ea03 0501 	and.w	r5, r3, r1
    cc8e:	ea54 0305 	orrs.w	r3, r4, r5
{
    cc92:	b083      	sub	sp, #12
    if ( ui64InterruptMask &  ~(((uint64_t)1 << AM_HAL_GPIO_MAX_PADS) - 1) )
    cc94:	d10f      	bne.n	ccb6 <am_hal_gpio_interrupt_clear+0x36>
    cc96:	460d      	mov	r5, r1
    cc98:	4604      	mov	r4, r0
#endif // AM_HAL_ENABLE_API_VALIDATION

    //
    // Clear the interrupts.
    //
    AM_CRITICAL_BEGIN
    cc9a:	f026 fd69 	bl	33770 <am_hal_interrupt_master_disable>

#if AM_CMSIS_REGS
    GPIO->INT0CLR = (uint32_t)(ui64InterruptMask & 0xFFFFFFFF);
    cc9e:	4b08      	ldr	r3, [pc, #32]	; (ccc0 <am_hal_gpio_interrupt_clear+0x40>)
    AM_CRITICAL_BEGIN
    cca0:	9001      	str	r0, [sp, #4]
    GPIO->INT0CLR = (uint32_t)(ui64InterruptMask & 0xFFFFFFFF);
    cca2:	f8c3 4208 	str.w	r4, [r3, #520]	; 0x208
    GPIO->INT1CLR = (uint32_t)(ui64InterruptMask >> 32);
    cca6:	f8c3 5218 	str.w	r5, [r3, #536]	; 0x218
#else // AM_CMSIS_REGS
    AM_REG(GPIO, INT1CLR) = (ui64InterruptMask >> 32);
    AM_REG(GPIO, INT0CLR) = (ui64InterruptMask & 0xFFFFFFFF);
#endif // AM_CMSIS_REGS

    AM_CRITICAL_END
    ccaa:	9801      	ldr	r0, [sp, #4]
    ccac:	f026 fd64 	bl	33778 <am_hal_interrupt_master_set>

    //
    // Return the status.
    //
    return AM_HAL_STATUS_SUCCESS;
    ccb0:	2000      	movs	r0, #0

} // am_hal_gpio_interrupt_clear()
    ccb2:	b003      	add	sp, #12
    ccb4:	bd30      	pop	{r4, r5, pc}
        return AM_HAL_STATUS_OUT_OF_RANGE;
    ccb6:	2005      	movs	r0, #5
} // am_hal_gpio_interrupt_clear()
    ccb8:	b003      	add	sp, #12
    ccba:	bd30      	pop	{r4, r5, pc}
    ccbc:	fffc0000 	.word	0xfffc0000
    ccc0:	40010000 	.word	0x40010000

0000ccc4 <am_util_delay_ms>:
//! @returns None
//
//*****************************************************************************
void
am_util_delay_ms(uint32_t ui32MilliSeconds)
{
    ccc4:	b510      	push	{r4, lr}
    ccc6:	b084      	sub	sp, #16
    ccc8:	4604      	mov	r4, r0
    uint32_t ui32Loops, ui32HFRC;

#if AM_APOLLO3_CLKGEN
    am_hal_clkgen_status_t sClkgenStatus;
    am_hal_clkgen_status_get(&sClkgenStatus);
    ccca:	a801      	add	r0, sp, #4
    cccc:	f026 fb3c 	bl	33348 <am_hal_clkgen_status_get>
    ui32HFRC = sClkgenStatus.ui32SysclkFreq;
#else
    ui32HFRC = am_hal_clkgen_sysclk_get();
#endif
    ui32Loops = ui32MilliSeconds * (ui32HFRC / 3000);
    ccd0:	9801      	ldr	r0, [sp, #4]
    ccd2:	4b05      	ldr	r3, [pc, #20]	; (cce8 <am_util_delay_ms+0x24>)
    ccd4:	fba3 3000 	umull	r3, r0, r3, r0
    ccd8:	0980      	lsrs	r0, r0, #6

    //
    // Call the BOOTROM cycle delay function
    //
    am_hal_flash_delay(ui32Loops);
    ccda:	fb04 f000 	mul.w	r0, r4, r0
    ccde:	f026 fc11 	bl	33504 <am_hal_flash_delay>
}
    cce2:	b004      	add	sp, #16
    cce4:	bd10      	pop	{r4, pc}
    cce6:	bf00      	nop
    cce8:	057619f1 	.word	0x057619f1

0000ccec <HardFault_Handler>:
}
#elif defined(__GNUC_STDC_INLINE__)
uint32_t __attribute__((naked))
HardFault_Handler(void)
{
    __asm("    push    {r7,lr}");
    ccec:	b580      	push	{r7, lr}
    __asm("    mov     r0, sp");
    ccee:	4668      	mov	r0, sp
    __asm("    adds    r0, #(2*4)");
    ccf0:	3008      	adds	r0, #8
    __asm("    bl      am_util_faultisr_collect_data");
    ccf2:	f000 f805 	bl	cd00 <am_util_faultisr_collect_data>
    __asm("    pop     {r0,pc}");
    ccf6:	bd01      	pop	{r0, pc}

0000ccf8 <getStackedReg>:
}

uint32_t __attribute__((naked))
getStackedReg(uint32_t regnum, uint32_t u32SP)
{
    __asm("    lsls    r0, r0, #2");
    ccf8:	0080      	lsls	r0, r0, #2
    __asm("    adds    r0, r1");
    ccfa:	1840      	adds	r0, r0, r1
    __asm("    ldr     r0, [r0]");
    ccfc:	6800      	ldr	r0, [r0, #0]
    __asm("    bx      lr");
    ccfe:	4770      	bx	lr

0000cd00 <am_util_faultisr_collect_data>:
// HardFault_Handler() was called.
//
//*****************************************************************************
void
am_util_faultisr_collect_data(uint32_t u32IsrSP)
{
    cd00:	b500      	push	{lr}
    volatile am_fault_t sFaultData;
    am_hal_mcuctrl_fault_t sHalFaultData = {0};
    cd02:	2300      	movs	r3, #0
{
    cd04:	b093      	sub	sp, #76	; 0x4c
    am_hal_mcuctrl_fault_t sHalFaultData = {0};
    cd06:	e9cd 3300 	strd	r3, r3, [sp]
    cd0a:	e9cd 3302 	strd	r3, r3, [sp, #8]
    cd0e:	e9cd 3304 	strd	r3, r3, [sp, #16]
    // a breakpoint at the end of the routine.  If the printing is not used,
    // we'll get a compiler warning; so to avoid that warning, we'll use it
    // in a dummy assignment here.
    //
    sFaultData.u32CFSR = u32Mask;       // Avoid compiler warning
    sFaultData.u32CFSR = AM_REGVAL(AM_REG_SYSCTRL_CFSR_O);
    cd12:	4a27      	ldr	r2, [pc, #156]	; (cdb0 <am_util_faultisr_collect_data+0xb0>)
    sFaultData.u32CFSR = u32Mask;       // Avoid compiler warning
    cd14:	9310      	str	r3, [sp, #64]	; 0x40
    sFaultData.u32CFSR = AM_REGVAL(AM_REG_SYSCTRL_CFSR_O);
    cd16:	6813      	ldr	r3, [r2, #0]
    cd18:	9310      	str	r3, [sp, #64]	; 0x40
    sFaultData.u8MMSR  = (sFaultData.u32CFSR >> 0)  & 0xff;
    cd1a:	9b10      	ldr	r3, [sp, #64]	; 0x40
    cd1c:	b2db      	uxtb	r3, r3
    cd1e:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
    sFaultData.u8BFSR  = (sFaultData.u32CFSR >> 8)  & 0xff;
    cd22:	9b10      	ldr	r3, [sp, #64]	; 0x40
    cd24:	f3c3 2307 	ubfx	r3, r3, #8, #8
    cd28:	f88d 3045 	strb.w	r3, [sp, #69]	; 0x45
    sFaultData.u16UFSR = (sFaultData.u32CFSR >> 16) & 0xffff;
    cd2c:	9b10      	ldr	r3, [sp, #64]	; 0x40
    cd2e:	0c1b      	lsrs	r3, r3, #16
    cd30:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46

    //
    // The address of the location that caused the fault.  e.g. if accessing an
    // invalid data location caused the fault, that address will appear here.
    //
    sFaultData.u32BFAR = AM_REGVAL(AM_REG_SYSCTRL_BFAR_O);
    cd34:	6913      	ldr	r3, [r2, #16]
    cd36:	930f      	str	r3, [sp, #60]	; 0x3c

    //
    // The address of the instruction that caused the fault is the stacked PC
    // if BFSR bit1 is set.
    //
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    cd38:	f89d 2045 	ldrb.w	r2, [sp, #69]	; 0x45
    cd3c:	0792      	lsls	r2, r2, #30
{
    cd3e:	4603      	mov	r3, r0
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    cd40:	d430      	bmi.n	cda4 <am_util_faultisr_collect_data+0xa4>
    cd42:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff

    //
    // Get the stacked registers.
    // Note - the address of the instruction that caused the fault is u32PC.
    //
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    cd46:	4619      	mov	r1, r3
    cd48:	2000      	movs	r0, #0
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    cd4a:	920e      	str	r2, [sp, #56]	; 0x38
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    cd4c:	f7ff ffd4 	bl	ccf8 <getStackedReg>
    cd50:	4602      	mov	r2, r0
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    cd52:	2001      	movs	r0, #1
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    cd54:	9206      	str	r2, [sp, #24]
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    cd56:	f7ff ffcf 	bl	ccf8 <getStackedReg>
    cd5a:	4602      	mov	r2, r0
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    cd5c:	2002      	movs	r0, #2
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    cd5e:	9207      	str	r2, [sp, #28]
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    cd60:	f7ff ffca 	bl	ccf8 <getStackedReg>
    cd64:	4602      	mov	r2, r0
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    cd66:	2003      	movs	r0, #3
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    cd68:	9208      	str	r2, [sp, #32]
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    cd6a:	f7ff ffc5 	bl	ccf8 <getStackedReg>
    cd6e:	4602      	mov	r2, r0
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    cd70:	2004      	movs	r0, #4
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    cd72:	9209      	str	r2, [sp, #36]	; 0x24
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    cd74:	f7ff ffc0 	bl	ccf8 <getStackedReg>
    cd78:	4602      	mov	r2, r0
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    cd7a:	2005      	movs	r0, #5
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    cd7c:	920a      	str	r2, [sp, #40]	; 0x28
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    cd7e:	f7ff ffbb 	bl	ccf8 <getStackedReg>
    cd82:	4602      	mov	r2, r0
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    cd84:	2006      	movs	r0, #6
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    cd86:	920b      	str	r2, [sp, #44]	; 0x2c
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    cd88:	f7ff ffb6 	bl	ccf8 <getStackedReg>
    cd8c:	4602      	mov	r2, r0
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    cd8e:	2007      	movs	r0, #7
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    cd90:	920c      	str	r2, [sp, #48]	; 0x30
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    cd92:	f7ff ffb1 	bl	ccf8 <getStackedReg>

    //
    // Use the HAL MCUCTRL functions to read the fault data.
    //
#ifdef AM_APOLLO3_MCUCTRL
    am_hal_mcuctrl_info_get(AM_HAL_MCUCTRL_INFO_FAULT_STATUS, &sHalFaultData);
    cd96:	4669      	mov	r1, sp
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    cd98:	4603      	mov	r3, r0
    am_hal_mcuctrl_info_get(AM_HAL_MCUCTRL_INFO_FAULT_STATUS, &sHalFaultData);
    cd9a:	2002      	movs	r0, #2
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    cd9c:	930d      	str	r3, [sp, #52]	; 0x34
    am_hal_mcuctrl_info_get(AM_HAL_MCUCTRL_INFO_FAULT_STATUS, &sHalFaultData);
    cd9e:	f026 fd45 	bl	3382c <am_hal_mcuctrl_info_get>
    cda2:	e7fe      	b.n	cda2 <am_util_faultisr_collect_data+0xa2>
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    cda4:	4601      	mov	r1, r0
    cda6:	2006      	movs	r0, #6
    cda8:	f7ff ffa6 	bl	ccf8 <getStackedReg>
    cdac:	4602      	mov	r2, r0
    cdae:	e7ca      	b.n	cd46 <am_util_faultisr_collect_data+0x46>
    cdb0:	e000ed28 	.word	0xe000ed28

0000cdb4 <uint64_to_str>:
// written).
//
//*****************************************************************************
static int
uint64_to_str(uint64_t ui64Val, char *pcBuf)
{
    cdb4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cdb8:	b097      	sub	sp, #92	; 0x5c
    cdba:	4682      	mov	sl, r0
    cdbc:	468b      	mov	fp, r1
    char tbuf[25];
    int ix = 0, iNumDig = 0;
    cdbe:	2300      	movs	r3, #0
{
    cdc0:	920d      	str	r2, [sp, #52]	; 0x34
    cdc2:	469c      	mov	ip, r3
    cdc4:	e9cd ab00 	strd	sl, fp, [sp]
    cdc8:	4606      	mov	r6, r0
    cdca:	460f      	mov	r7, r1
    cdcc:	e00b      	b.n	cde6 <uint64_to_str+0x32>
        //
        // Get modulus
        //
        uMod = ui64Val - (u64Tmp * 10);

        tbuf[ix++] = uMod + '0';
    cdce:	f80b 2c01 	strb.w	r2, [fp, #-1]
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    cdd2:	4619      	mov	r1, r3
    cdd4:	2200      	movs	r2, #0
    cdd6:	e9cd 1200 	strd	r1, r2, [sp]
        ui64Val = u64Tmp;
    } while ( ui64Val );
    cdda:	2b00      	cmp	r3, #0
    cddc:	f000 80a5 	beq.w	cf2a <uint64_to_str+0x176>
    cde0:	e9dd 6700 	ldrd	r6, r7, [sp]
{
    cde4:	46f4      	mov	ip, lr
        q64 += (q64 >> 4);
    cde6:	2300      	movs	r3, #0
    cde8:	2400      	movs	r4, #0
    cdea:	e9cd 3402 	strd	r3, r4, [sp, #8]
        q64 += (q64 >> 8);
    cdee:	e9cd 3404 	strd	r3, r4, [sp, #16]
        q64 += (q64 >> 16);
    cdf2:	e9cd 3406 	strd	r3, r4, [sp, #24]
        q64 += (q64 >> 32);
    cdf6:	e9cd 340a 	strd	r3, r4, [sp, #40]	; 0x28
        q64 >>= 3;
    cdfa:	4698      	mov	r8, r3
        q32 = (ui32Val>>1) + (ui32Val>>2);
    cdfc:	08b3      	lsrs	r3, r6, #2
    cdfe:	eb03 0356 	add.w	r3, r3, r6, lsr #1
        q32 += (q32 >> 4);
    ce02:	eb03 1313 	add.w	r3, r3, r3, lsr #4
        q32 += (q32 >> 8);
    ce06:	eb03 2313 	add.w	r3, r3, r3, lsr #8
        q64 >>= 3;
    ce0a:	46a1      	mov	r9, r4
        q32 += (q32 >> 16);
    ce0c:	eb03 4313 	add.w	r3, r3, r3, lsr #16
        q32 >>= 3;
    ce10:	08da      	lsrs	r2, r3, #3
        return q64 + ((r64 + 6) >> 4);
    ce12:	4644      	mov	r4, r8
    ce14:	464d      	mov	r5, r9
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    ce16:	4633      	mov	r3, r6
        q64 = (ui64Val>>1) + (ui64Val>>2);
    ce18:	08b0      	lsrs	r0, r6, #2
        return q64 + ((r64 + 6) >> 4);
    ce1a:	e9cd 4508 	strd	r4, r5, [sp, #32]
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    ce1e:	3306      	adds	r3, #6
        r32 = ui32Val - q32*10;
    ce20:	eb02 0482 	add.w	r4, r2, r2, lsl #2
    ce24:	f10c 0e01 	add.w	lr, ip, #1
        tbuf[ix++] = uMod + '0';
    ce28:	ae0f      	add	r6, sp, #60	; 0x3c
    ce2a:	4476      	add	r6, lr
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    ce2c:	eba3 0344 	sub.w	r3, r3, r4, lsl #1
        q64 = (ui64Val>>1) + (ui64Val>>2);
    ce30:	ea40 7087 	orr.w	r0, r0, r7, lsl #30
    if ( ui64Val >> 32 )
    ce34:	463c      	mov	r4, r7
        q64 = (ui64Val>>1) + (ui64Val>>2);
    ce36:	08b9      	lsrs	r1, r7, #2
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    ce38:	eb02 1313 	add.w	r3, r2, r3, lsr #4
        tbuf[ix++] = uMod + '0';
    ce3c:	46b3      	mov	fp, r6
    ce3e:	4637      	mov	r7, r6
    ce40:	9e00      	ldr	r6, [sp, #0]
        uMod = ui64Val - (u64Tmp * 10);
    ce42:	eb03 0283 	add.w	r2, r3, r3, lsl #2
    if ( ui64Val >> 32 )
    ce46:	2500      	movs	r5, #0
        uMod = ui64Val - (u64Tmp * 10);
    ce48:	eba6 0242 	sub.w	r2, r6, r2, lsl #1
    if ( ui64Val >> 32 )
    ce4c:	ea54 0a05 	orrs.w	sl, r4, r5
        tbuf[ix++] = uMod + '0';
    ce50:	f102 0230 	add.w	r2, r2, #48	; 0x30
    if ( ui64Val >> 32 )
    ce54:	d0bb      	beq.n	cdce <uint64_to_str+0x1a>
        q64 = (ui64Val>>1) + (ui64Val>>2);
    ce56:	e9dd 2300 	ldrd	r2, r3, [sp]
    ce5a:	085b      	lsrs	r3, r3, #1
    ce5c:	ea4f 0232 	mov.w	r2, r2, rrx
    ce60:	eb12 0a00 	adds.w	sl, r2, r0
    ce64:	eb43 0b01 	adc.w	fp, r3, r1
        q64 += (q64 >> 4);
    ce68:	ea4f 131a 	mov.w	r3, sl, lsr #4
    ce6c:	ea43 730b 	orr.w	r3, r3, fp, lsl #28
    ce70:	9302      	str	r3, [sp, #8]
    ce72:	ea4f 131b 	mov.w	r3, fp, lsr #4
    ce76:	9303      	str	r3, [sp, #12]
    ce78:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    ce7c:	eb12 020a 	adds.w	r2, r2, sl
    ce80:	eb43 030b 	adc.w	r3, r3, fp
        q64 += (q64 >> 8);
    ce84:	0a11      	lsrs	r1, r2, #8
    ce86:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
    ce8a:	9104      	str	r1, [sp, #16]
    ce8c:	0a19      	lsrs	r1, r3, #8
    ce8e:	9105      	str	r1, [sp, #20]
    ce90:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    ce94:	1880      	adds	r0, r0, r2
    ce96:	4159      	adcs	r1, r3
    ce98:	460b      	mov	r3, r1
        q64 += (q64 >> 16);
    ce9a:	0c01      	lsrs	r1, r0, #16
    ce9c:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    cea0:	9106      	str	r1, [sp, #24]
    cea2:	0c19      	lsrs	r1, r3, #16
    cea4:	9107      	str	r1, [sp, #28]
        q64 += (q64 >> 8);
    cea6:	4602      	mov	r2, r0
        q64 += (q64 >> 16);
    cea8:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    ceac:	1880      	adds	r0, r0, r2
    ceae:	4159      	adcs	r1, r3
        q64 += (q64 >> 32);
    ceb0:	e9cd 150a 	strd	r1, r5, [sp, #40]	; 0x28
        q64 += (q64 >> 16);
    ceb4:	4602      	mov	r2, r0
    ceb6:	460b      	mov	r3, r1
        q64 += (q64 >> 32);
    ceb8:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    cebc:	1880      	adds	r0, r0, r2
    cebe:	4159      	adcs	r1, r3
        q64 >>= 3;
    cec0:	ea4f 08d0 	mov.w	r8, r0, lsr #3
    cec4:	ea48 7841 	orr.w	r8, r8, r1, lsl #29
    cec8:	ea4f 09d1 	mov.w	r9, r1, lsr #3
        return q64 + ((r64 + 6) >> 4);
    cecc:	e9dd ab00 	ldrd	sl, fp, [sp]
        r64 = ui64Val - q64*10;
    ced0:	ea4f 0189 	mov.w	r1, r9, lsl #2
    ced4:	ea4f 0288 	mov.w	r2, r8, lsl #2
    ced8:	eb12 0008 	adds.w	r0, r2, r8
    cedc:	ea41 7398 	orr.w	r3, r1, r8, lsr #30
    cee0:	eb43 0109 	adc.w	r1, r3, r9
        return q64 + ((r64 + 6) >> 4);
    cee4:	f11a 0a06 	adds.w	sl, sl, #6
    cee8:	f14b 0b00 	adc.w	fp, fp, #0
        r64 = ui64Val - q64*10;
    ceec:	1802      	adds	r2, r0, r0
    ceee:	eb41 0301 	adc.w	r3, r1, r1
        return q64 + ((r64 + 6) >> 4);
    cef2:	ebba 0002 	subs.w	r0, sl, r2
    cef6:	eb6b 0103 	sbc.w	r1, fp, r3
    cefa:	0903      	lsrs	r3, r0, #4
    cefc:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
    cf00:	9308      	str	r3, [sp, #32]
    cf02:	090b      	lsrs	r3, r1, #4
    cf04:	9309      	str	r3, [sp, #36]	; 0x24
    cf06:	e9dd ab08 	ldrd	sl, fp, [sp, #32]
    cf0a:	eb1a 0a08 	adds.w	sl, sl, r8
    cf0e:	eb4b 0b09 	adc.w	fp, fp, r9
    cf12:	4653      	mov	r3, sl
    cf14:	465c      	mov	r4, fp
    cf16:	e9cd 3400 	strd	r3, r4, [sp]
        uMod = ui64Val - (u64Tmp * 10);
    cf1a:	eb0a 038a 	add.w	r3, sl, sl, lsl #2
    cf1e:	eba6 0643 	sub.w	r6, r6, r3, lsl #1
        tbuf[ix++] = uMod + '0';
    cf22:	3630      	adds	r6, #48	; 0x30
    cf24:	f807 6c01 	strb.w	r6, [r7, #-1]
    cf28:	e75a      	b.n	cde0 <uint64_to_str+0x2c>
    iNumDig = ix;

    //
    // Now, reverse the buffer when saving to the caller's buffer.
    //
    if ( pcBuf )
    cf2a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    cf2c:	4660      	mov	r0, ip
    cf2e:	b16a      	cbz	r2, cf4c <uint64_to_str+0x198>
    cf30:	465b      	mov	r3, fp
    cf32:	3a01      	subs	r2, #1
    {
        while ( ix-- )
        {
            *pcBuf++ = tbuf[ix];
    cf34:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
    cf38:	f802 1f01 	strb.w	r1, [r2, #1]!
        while ( ix-- )
    cf3c:	a90f      	add	r1, sp, #60	; 0x3c
    cf3e:	4299      	cmp	r1, r3
    cf40:	d1f8      	bne.n	cf34 <uint64_to_str+0x180>
        }

        //
        // Terminate the caller's buffer
        //
        *pcBuf = 0x00;
    cf42:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    cf44:	4403      	add	r3, r0
    cf46:	461a      	mov	r2, r3
    cf48:	2300      	movs	r3, #0
    cf4a:	7053      	strb	r3, [r2, #1]
    }

    return iNumDig;
}
    cf4c:	4670      	mov	r0, lr
    cf4e:	b017      	add	sp, #92	; 0x5c
    cf50:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000cf54 <am_util_stdio_printf_init>:
    g_pfnCharPrint = pfnCharPrint;
    cf54:	4b01      	ldr	r3, [pc, #4]	; (cf5c <am_util_stdio_printf_init+0x8>)
    cf56:	6018      	str	r0, [r3, #0]
}
    cf58:	4770      	bx	lr
    cf5a:	bf00      	nop
    cf5c:	100019e8 	.word	0x100019e8

0000cf60 <am_util_stdio_vsprintf>:
//! @return uint32_t representing the number of characters printed.
//
//******************************************************************************
uint32_t
am_util_stdio_vsprintf(char *pcBuf, const char *pcFmt, va_list pArgs)
{
    cf60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cf64:	b09b      	sub	sp, #108	; 0x6c
    cf66:	4682      	mov	sl, r0
    cf68:	4689      	mov	r9, r1
    cf6a:	9201      	str	r2, [sp, #4]
    char *pcStr;
    uint64_t ui64Val;
    int64_t i64Val;
    uint32_t ui32NumChars, ui32CharCnt = 0;
    cf6c:	f04f 0b00 	mov.w	fp, #0
    int iWidth, iVal, iPrecision;
    uint8_t ui8CharSpecifier, ui8PadChar;
    bool bLower, bLongLong, bNeg;
    uint32_t ui32strlen = 0;

    while ( *pcFmt != 0x0 )
    cf70:	f899 3000 	ldrb.w	r3, [r9]
    cf74:	b1bb      	cbz	r3, cfa6 <am_util_stdio_vsprintf+0x46>
    {
        iPrecision = 6;             // printf() default precision for %f is 6

        if ( *pcFmt != '%' )
    cf76:	2b25      	cmp	r3, #37	; 0x25
    cf78:	f109 0501 	add.w	r5, r9, #1
    cf7c:	d01c      	beq.n	cfb8 <am_util_stdio_vsprintf+0x58>
    cf7e:	f10b 0201 	add.w	r2, fp, #1
        {
            //
            // Accumulate the string portion of the format specification.
            //
            if ( pcBuf )
    cf82:	f1ba 0f00 	cmp.w	sl, #0
    cf86:	f000 8091 	beq.w	d0ac <am_util_stdio_vsprintf+0x14c>
            {
                // If '\n', convert to '\r\n'
                if ( *pcFmt == '\n'  &&  g_bTxtXlate )
    cf8a:	2b0a      	cmp	r3, #10
    cf8c:	f10a 0101 	add.w	r1, sl, #1
    cf90:	f000 808f 	beq.w	d0b2 <am_util_stdio_vsprintf+0x152>
                {
                    *pcBuf++ = '\r';
                    ++ui32CharCnt;
                }
                *pcBuf++ = *pcFmt;
    cf94:	f88a 3000 	strb.w	r3, [sl]
    cf98:	4693      	mov	fp, r2
    cf9a:	468a      	mov	sl, r1
            }

            ++pcFmt;
    cf9c:	46a9      	mov	r9, r5
    while ( *pcFmt != 0x0 )
    cf9e:	f899 3000 	ldrb.w	r3, [r9]
    cfa2:	2b00      	cmp	r3, #0
    cfa4:	d1e7      	bne.n	cf76 <am_util_stdio_vsprintf+0x16>
    } // while ()

    //
    // Terminate the string
    //
    if ( pcBuf )
    cfa6:	f1ba 0f00 	cmp.w	sl, #0
    cfaa:	d001      	beq.n	cfb0 <am_util_stdio_vsprintf+0x50>
    {
        *pcBuf = 0x0;
    cfac:	f88a 3000 	strb.w	r3, [sl]
    }

    return (ui32CharCnt);
}
    cfb0:	4658      	mov	r0, fp
    cfb2:	b01b      	add	sp, #108	; 0x6c
    cfb4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ( *pcFmt == '0' )
    cfb8:	f899 3001 	ldrb.w	r3, [r9, #1]
    cfbc:	2b30      	cmp	r3, #48	; 0x30
    cfbe:	bf03      	ittte	eq
    cfc0:	f899 3002 	ldrbeq.w	r3, [r9, #2]
            ++pcFmt;
    cfc4:	f109 0502 	addeq.w	r5, r9, #2
            ui8PadChar = '0';
    cfc8:	f04f 0830 	moveq.w	r8, #48	; 0x30
        ui8PadChar = ' ';
    cfcc:	f04f 0820 	movne.w	r8, #32
    if ( *pcStr == '-')
    cfd0:	2b2d      	cmp	r3, #45	; 0x2d
    cfd2:	d07e      	beq.n	d0d2 <am_util_stdio_vsprintf+0x172>
    uint32_t ui32Val = 0, uCnt = 0;
    cfd4:	2100      	movs	r1, #0
    bool bNeg = false;
    cfd6:	460e      	mov	r6, r1
    if ( *pcStr == '-')
    cfd8:	462a      	mov	r2, r5
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    cfda:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    cfde:	2809      	cmp	r0, #9
    cfe0:	f04f 0400 	mov.w	r4, #0
    cfe4:	d80f      	bhi.n	d006 <am_util_stdio_vsprintf+0xa6>
        ui32Val *= 10;
    cfe6:	eb04 0484 	add.w	r4, r4, r4, lsl #2
        ui32Val += (*pcStr - '0');
    cfea:	eb03 0444 	add.w	r4, r3, r4, lsl #1
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    cfee:	f812 3f01 	ldrb.w	r3, [r2, #1]!
    cff2:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    cff6:	2809      	cmp	r0, #9
        ui32Val += (*pcStr - '0');
    cff8:	f1a4 0430 	sub.w	r4, r4, #48	; 0x30
        ++uCnt;
    cffc:	f101 0101 	add.w	r1, r1, #1
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    d000:	d9f1      	bls.n	cfe6 <am_util_stdio_vsprintf+0x86>
    d002:	5c6b      	ldrb	r3, [r5, r1]
    d004:	186a      	adds	r2, r5, r1
    return bNeg ? -ui32Val : ui32Val;
    d006:	b106      	cbz	r6, d00a <am_util_stdio_vsprintf+0xaa>
    d008:	4264      	negs	r4, r4
        if ( ( *pcFmt != 's' )  &&  ( iWidth < 0 ) )
    d00a:	2b73      	cmp	r3, #115	; 0x73
        iWidth = decstr_to_int(pcFmt, &ui32NumChars);
    d00c:	4621      	mov	r1, r4
    d00e:	f102 0901 	add.w	r9, r2, #1
        if ( ( *pcFmt != 's' )  &&  ( iWidth < 0 ) )
    d012:	f000 8167 	beq.w	d2e4 <am_util_stdio_vsprintf+0x384>
    d016:	ea84 71e4 	eor.w	r1, r4, r4, asr #31
    d01a:	eba1 71e4 	sub.w	r1, r1, r4, asr #31
        if (*pcFmt == '.')
    d01e:	2b2e      	cmp	r3, #46	; 0x2e
    d020:	910e      	str	r1, [sp, #56]	; 0x38
    d022:	f000 813b 	beq.w	d29c <am_util_stdio_vsprintf+0x33c>
        iPrecision = 6;             // printf() default precision for %f is 6
    d026:	2506      	movs	r5, #6
        if ( *pcFmt == 'l' )
    d028:	2b6c      	cmp	r3, #108	; 0x6c
    d02a:	d157      	bne.n	d0dc <am_util_stdio_vsprintf+0x17c>
            if ( *pcFmt == 'l' )    // "ll" (long long)
    d02c:	7853      	ldrb	r3, [r2, #1]
    d02e:	2b6c      	cmp	r3, #108	; 0x6c
    d030:	f000 808e 	beq.w	d150 <am_util_stdio_vsprintf+0x1f0>
        switch ( *pcFmt )
    d034:	f1a3 0246 	sub.w	r2, r3, #70	; 0x46
    d038:	f109 0901 	add.w	r9, r9, #1
    d03c:	2a32      	cmp	r2, #50	; 0x32
    d03e:	f200 8123 	bhi.w	d288 <am_util_stdio_vsprintf+0x328>
    d042:	e8df f012 	tbh	[pc, r2, lsl #1]
    d046:	00c2      	.short	0x00c2
    d048:	01210121 	.word	0x01210121
    d04c:	01210121 	.word	0x01210121
    d050:	01210121 	.word	0x01210121
    d054:	01210121 	.word	0x01210121
    d058:	01210121 	.word	0x01210121
    d05c:	01210121 	.word	0x01210121
    d060:	01210121 	.word	0x01210121
    d064:	01210121 	.word	0x01210121
    d068:	01990121 	.word	0x01990121
    d06c:	01210121 	.word	0x01210121
    d070:	01210121 	.word	0x01210121
    d074:	01210121 	.word	0x01210121
    d078:	01210121 	.word	0x01210121
    d07c:	01210121 	.word	0x01210121
    d080:	01b60113 	.word	0x01b60113
    d084:	00c20121 	.word	0x00c20121
    d088:	01210121 	.word	0x01210121
    d08c:	012101b6 	.word	0x012101b6
    d090:	01210121 	.word	0x01210121
    d094:	01210121 	.word	0x01210121
    d098:	01210121 	.word	0x01210121
    d09c:	01210121 	.word	0x01210121
    d0a0:	0121014e 	.word	0x0121014e
    d0a4:	01210235 	.word	0x01210235
    d0a8:	024e0121 	.word	0x024e0121
    d0ac:	4693      	mov	fp, r2
            ++pcFmt;
    d0ae:	46a9      	mov	r9, r5
    d0b0:	e775      	b.n	cf9e <am_util_stdio_vsprintf+0x3e>
                if ( *pcFmt == '\n'  &&  g_bTxtXlate )
    d0b2:	48a6      	ldr	r0, [pc, #664]	; (d34c <am_util_stdio_vsprintf+0x3ec>)
    d0b4:	7800      	ldrb	r0, [r0, #0]
    d0b6:	2800      	cmp	r0, #0
    d0b8:	f43f af6c 	beq.w	cf94 <am_util_stdio_vsprintf+0x34>
                    *pcBuf++ = '\r';
    d0bc:	4650      	mov	r0, sl
    d0be:	230d      	movs	r3, #13
    d0c0:	f800 3b02 	strb.w	r3, [r0], #2
    d0c4:	468a      	mov	sl, r1
    d0c6:	f899 3000 	ldrb.w	r3, [r9]
    d0ca:	f10b 0202 	add.w	r2, fp, #2
    d0ce:	4601      	mov	r1, r0
    d0d0:	e760      	b.n	cf94 <am_util_stdio_vsprintf+0x34>
        uCnt++;
    d0d2:	2101      	movs	r1, #1
        bNeg = true;
    d0d4:	460e      	mov	r6, r1
        pcStr++;
    d0d6:	186a      	adds	r2, r5, r1
    d0d8:	786b      	ldrb	r3, [r5, #1]
    d0da:	e77e      	b.n	cfda <am_util_stdio_vsprintf+0x7a>
        switch ( *pcFmt )
    d0dc:	f1a3 0246 	sub.w	r2, r3, #70	; 0x46
    d0e0:	2a32      	cmp	r2, #50	; 0x32
    d0e2:	f200 80d1 	bhi.w	d288 <am_util_stdio_vsprintf+0x328>
    d0e6:	e8df f012 	tbh	[pc, r2, lsl #1]
    d0ea:	0070      	.short	0x0070
    d0ec:	00cf00cf 	.word	0x00cf00cf
    d0f0:	00cf00cf 	.word	0x00cf00cf
    d0f4:	00cf00cf 	.word	0x00cf00cf
    d0f8:	00cf00cf 	.word	0x00cf00cf
    d0fc:	00cf00cf 	.word	0x00cf00cf
    d100:	00cf00cf 	.word	0x00cf00cf
    d104:	00cf00cf 	.word	0x00cf00cf
    d108:	00cf00cf 	.word	0x00cf00cf
    d10c:	014700cf 	.word	0x014700cf
    d110:	00cf00cf 	.word	0x00cf00cf
    d114:	00cf00cf 	.word	0x00cf00cf
    d118:	00cf00cf 	.word	0x00cf00cf
    d11c:	00cf00cf 	.word	0x00cf00cf
    d120:	00cf00cf 	.word	0x00cf00cf
    d124:	016400c1 	.word	0x016400c1
    d128:	007000cf 	.word	0x007000cf
    d12c:	00cf00cf 	.word	0x00cf00cf
    d130:	00cf0164 	.word	0x00cf0164
    d134:	00cf00cf 	.word	0x00cf00cf
    d138:	00cf00cf 	.word	0x00cf00cf
    d13c:	00cf00cf 	.word	0x00cf00cf
    d140:	00cf00cf 	.word	0x00cf00cf
    d144:	00cf00fc 	.word	0x00cf00fc
    d148:	00cf01e3 	.word	0x00cf01e3
    d14c:	01fa00cf 	.word	0x01fa00cf
    d150:	7893      	ldrb	r3, [r2, #2]
    d152:	f1a3 0146 	sub.w	r1, r3, #70	; 0x46
    d156:	f102 0903 	add.w	r9, r2, #3
    d15a:	2932      	cmp	r1, #50	; 0x32
    d15c:	f200 8094 	bhi.w	d288 <am_util_stdio_vsprintf+0x328>
    d160:	e8df f011 	tbh	[pc, r1, lsl #1]
    d164:	00920033 	.word	0x00920033
    d168:	00920092 	.word	0x00920092
    d16c:	00920092 	.word	0x00920092
    d170:	00920092 	.word	0x00920092
    d174:	00920092 	.word	0x00920092
    d178:	00920092 	.word	0x00920092
    d17c:	00920092 	.word	0x00920092
    d180:	00920092 	.word	0x00920092
    d184:	00920092 	.word	0x00920092
    d188:	00920414 	.word	0x00920414
    d18c:	00920092 	.word	0x00920092
    d190:	00920092 	.word	0x00920092
    d194:	00920092 	.word	0x00920092
    d198:	00920092 	.word	0x00920092
    d19c:	00840092 	.word	0x00840092
    d1a0:	00920222 	.word	0x00920222
    d1a4:	00920033 	.word	0x00920033
    d1a8:	02220092 	.word	0x02220092
    d1ac:	00920092 	.word	0x00920092
    d1b0:	00920092 	.word	0x00920092
    d1b4:	00920092 	.word	0x00920092
    d1b8:	00920092 	.word	0x00920092
    d1bc:	00bf0092 	.word	0x00bf0092
    d1c0:	02160092 	.word	0x02160092
    d1c4:	00920092 	.word	0x00920092
    d1c8:	0412      	.short	0x0412
                if ( pcBuf )
    d1ca:	f1ba 0f00 	cmp.w	sl, #0
    d1ce:	f43f aecf 	beq.w	cf70 <am_util_stdio_vsprintf+0x10>
                    float fValue = va_arg(pArgs, double);
    d1d2:	9b01      	ldr	r3, [sp, #4]
    d1d4:	3307      	adds	r3, #7
    d1d6:	f023 0307 	bic.w	r3, r3, #7
    d1da:	e9d3 0100 	ldrd	r0, r1, [r3]
    d1de:	3308      	adds	r3, #8
    d1e0:	9301      	str	r3, [sp, #4]
    d1e2:	f7ff f827 	bl	c234 <__aeabi_d2f>
    d1e6:	ee07 0a90 	vmov	s15, r0
    if (fValue == 0.0f)
    d1ea:	eef5 7a40 	vcmp.f32	s15, #0.0
                    *(uint32_t*)pcBuf = 20;
    d1ee:	2314      	movs	r3, #20
    if (fValue == 0.0f)
    d1f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                    *(uint32_t*)pcBuf = 20;
    d1f4:	f8ca 3000 	str.w	r3, [sl]
    if (fValue == 0.0f)
    d1f8:	f000 843e 	beq.w	da78 <am_util_stdio_vsprintf+0xb18>
    iExp2 = ((unFloatValue.I32 >> 23) & 0x000000FF) - 127;
    d1fc:	f3c0 51c7 	ubfx	r1, r0, #23, #8
    d200:	f1a1 027f 	sub.w	r2, r1, #127	; 0x7f
    d204:	4603      	mov	r3, r0
    if (iExp2 >= 31)
    d206:	2a1e      	cmp	r2, #30
    i32Significand = (unFloatValue.I32 & 0x00FFFFFF) | 0x00800000;
    d208:	f3c0 0016 	ubfx	r0, r0, #0, #23
    d20c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    if (iExp2 >= 31)
    d210:	f300 844a 	bgt.w	daa8 <am_util_stdio_vsprintf+0xb48>
    else if (iExp2 < -23)
    d214:	f112 0f17 	cmn.w	r2, #23
    d218:	f2c0 8479 	blt.w	db0e <am_util_stdio_vsprintf+0xbae>
    else if (iExp2 >= 23)
    d21c:	2a16      	cmp	r2, #22
    d21e:	f10a 0701 	add.w	r7, sl, #1
    d222:	f340 836f 	ble.w	d904 <am_util_stdio_vsprintf+0x9a4>
        i32IntPart = i32Significand << (iExp2 - 23);
    d226:	3996      	subs	r1, #150	; 0x96
    if (unFloatValue.I32 < 0)
    d228:	2b00      	cmp	r3, #0
        i32IntPart = i32Significand << (iExp2 - 23);
    d22a:	fa00 f001 	lsl.w	r0, r0, r1
    if (unFloatValue.I32 < 0)
    d22e:	f2c0 844d 	blt.w	dacc <am_util_stdio_vsprintf+0xb6c>
    d232:	4656      	mov	r6, sl
    i32FracPart = 0;
    d234:	2400      	movs	r4, #0
    if (i32IntPart == 0)
    d236:	2800      	cmp	r0, #0
    d238:	f040 843c 	bne.w	dab4 <am_util_stdio_vsprintf+0xb54>
    d23c:	1c7a      	adds	r2, r7, #1
        *pcBuf++ = '0';
    d23e:	f04f 0330 	mov.w	r3, #48	; 0x30
    d242:	7033      	strb	r3, [r6, #0]
    *pcBuf++ = '.';
    d244:	232e      	movs	r3, #46	; 0x2e
    d246:	703b      	strb	r3, [r7, #0]
    if (i32FracPart == 0)
    d248:	2c00      	cmp	r4, #0
    d24a:	f040 83d8 	bne.w	d9fe <am_util_stdio_vsprintf+0xa9e>
        *pcBuf++ = '0';
    d24e:	1cba      	adds	r2, r7, #2
    d250:	f04f 0330 	mov.w	r3, #48	; 0x30
    d254:	707b      	strb	r3, [r7, #1]
    d256:	eba2 010a 	sub.w	r1, r2, sl
    *pcBuf = 0x00;
    d25a:	2300      	movs	r3, #0
                    if ( iVal < 0 )
    d25c:	4299      	cmp	r1, r3
    *pcBuf = 0x00;
    d25e:	7013      	strb	r3, [r2, #0]
                    if ( iVal < 0 )
    d260:	f2c0 841e 	blt.w	daa0 <am_util_stdio_vsprintf+0xb40>
    d264:	460b      	mov	r3, r1
                    ui32CharCnt += iVal;
    d266:	449b      	add	fp, r3
                    pcBuf += iVal;
    d268:	449a      	add	sl, r3
    d26a:	e681      	b.n	cf70 <am_util_stdio_vsprintf+0x10>
                ui8CharSpecifier = va_arg(pArgs, uint32_t);
    d26c:	9a01      	ldr	r2, [sp, #4]
    d26e:	1d13      	adds	r3, r2, #4
                if ( pcBuf )
    d270:	f1ba 0f00 	cmp.w	sl, #0
    d274:	d004      	beq.n	d280 <am_util_stdio_vsprintf+0x320>
                ui8CharSpecifier = va_arg(pArgs, uint32_t);
    d276:	6812      	ldr	r2, [r2, #0]
    d278:	f88a 2000 	strb.w	r2, [sl]
                    *pcBuf++ = ui8CharSpecifier;
    d27c:	f10a 0a01 	add.w	sl, sl, #1
                ++ui32CharCnt;
    d280:	f10b 0b01 	add.w	fp, fp, #1
                ui8CharSpecifier = va_arg(pArgs, uint32_t);
    d284:	9301      	str	r3, [sp, #4]
                break;
    d286:	e673      	b.n	cf70 <am_util_stdio_vsprintf+0x10>
                if ( pcBuf )
    d288:	f1ba 0f00 	cmp.w	sl, #0
    d28c:	d003      	beq.n	d296 <am_util_stdio_vsprintf+0x336>
                    *pcBuf++ = *pcFmt;
    d28e:	f88a 3000 	strb.w	r3, [sl]
    d292:	f10a 0a01 	add.w	sl, sl, #1
                ++ui32CharCnt;
    d296:	f10b 0b01 	add.w	fp, fp, #1
                break;
    d29a:	e669      	b.n	cf70 <am_util_stdio_vsprintf+0x10>
    if ( *pcStr == '-')
    d29c:	7851      	ldrb	r1, [r2, #1]
    d29e:	292d      	cmp	r1, #45	; 0x2d
    d2a0:	f000 821a 	beq.w	d6d8 <am_util_stdio_vsprintf+0x778>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    d2a4:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
    d2a8:	2b09      	cmp	r3, #9
    d2aa:	f200 8305 	bhi.w	d8b8 <am_util_stdio_vsprintf+0x958>
    bool bNeg = false;
    d2ae:	2600      	movs	r6, #0
    uint32_t ui32Val = 0, uCnt = 0;
    d2b0:	4632      	mov	r2, r6
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    d2b2:	4648      	mov	r0, r9
        uCnt++;
    d2b4:	2300      	movs	r3, #0
        ui32Val *= 10;
    d2b6:	eb03 0383 	add.w	r3, r3, r3, lsl #2
        ui32Val += (*pcStr - '0');
    d2ba:	eb01 0343 	add.w	r3, r1, r3, lsl #1
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    d2be:	f810 1f01 	ldrb.w	r1, [r0, #1]!
    d2c2:	f1a1 0530 	sub.w	r5, r1, #48	; 0x30
    d2c6:	2d09      	cmp	r5, #9
        ui32Val += (*pcStr - '0');
    d2c8:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
        ++uCnt;
    d2cc:	f102 0201 	add.w	r2, r2, #1
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    d2d0:	d9f1      	bls.n	d2b6 <am_util_stdio_vsprintf+0x356>
    return bNeg ? -ui32Val : ui32Val;
    d2d2:	b106      	cbz	r6, d2d6 <am_util_stdio_vsprintf+0x376>
    d2d4:	425b      	negs	r3, r3
            pcFmt += ui32NumChars;
    d2d6:	444a      	add	r2, r9
            iPrecision = decstr_to_int(pcFmt, &ui32NumChars);
    d2d8:	461d      	mov	r5, r3
    d2da:	f102 0901 	add.w	r9, r2, #1
    d2de:	7813      	ldrb	r3, [r2, #0]
    d2e0:	e6a2      	b.n	d028 <am_util_stdio_vsprintf+0xc8>
        switch ( *pcFmt )
    d2e2:	990e      	ldr	r1, [sp, #56]	; 0x38
                pcStr = va_arg(pArgs, char *);
    d2e4:	9b01      	ldr	r3, [sp, #4]
    d2e6:	681f      	ldr	r7, [r3, #0]
    d2e8:	1d1a      	adds	r2, r3, #4
    if ( !pcBuf )
    d2ea:	b38f      	cbz	r7, d350 <am_util_stdio_vsprintf+0x3f0>
    while ( *pcBuf++ )
    d2ec:	7838      	ldrb	r0, [r7, #0]
    d2ee:	1c7b      	adds	r3, r7, #1
    d2f0:	461c      	mov	r4, r3
    d2f2:	2800      	cmp	r0, #0
    d2f4:	f000 835c 	beq.w	d9b0 <am_util_stdio_vsprintf+0xa50>
    d2f8:	1be6      	subs	r6, r4, r7
    d2fa:	f814 5b01 	ldrb.w	r5, [r4], #1
    d2fe:	2d00      	cmp	r5, #0
    d300:	d1fa      	bne.n	d2f8 <am_util_stdio_vsprintf+0x398>
                if ( iWidth > 0 )
    d302:	2900      	cmp	r1, #0
    d304:	dd02      	ble.n	d30c <am_util_stdio_vsprintf+0x3ac>
                    if ( ui32strlen < iWidth )
    d306:	428e      	cmp	r6, r1
    d308:	f0c0 8356 	bcc.w	d9b8 <am_util_stdio_vsprintf+0xa58>
    d30c:	465c      	mov	r4, fp
    d30e:	1be4      	subs	r4, r4, r7
    d310:	4657      	mov	r7, sl
                        *pcBuf++ = *pcStr;
    d312:	4655      	mov	r5, sl
    d314:	eb04 0b03 	add.w	fp, r4, r3
                    if ( pcBuf )
    d318:	b15f      	cbz	r7, d332 <am_util_stdio_vsprintf+0x3d2>
                        *pcBuf++ = *pcStr;
    d31a:	7028      	strb	r0, [r5, #0]
                while (*pcStr != 0x0)
    d31c:	f813 0b01 	ldrb.w	r0, [r3], #1
                        *pcBuf++ = *pcStr;
    d320:	3701      	adds	r7, #1
                while (*pcStr != 0x0)
    d322:	2800      	cmp	r0, #0
    d324:	f000 81c5 	beq.w	d6b2 <am_util_stdio_vsprintf+0x752>
                        *pcBuf++ = *pcStr;
    d328:	463d      	mov	r5, r7
    d32a:	eb04 0b03 	add.w	fp, r4, r3
                    if ( pcBuf )
    d32e:	2f00      	cmp	r7, #0
    d330:	d1f3      	bne.n	d31a <am_util_stdio_vsprintf+0x3ba>
    d332:	46ba      	mov	sl, r7
    d334:	eb04 0b03 	add.w	fp, r4, r3
                while (*pcStr != 0x0)
    d338:	f813 0b01 	ldrb.w	r0, [r3], #1
    d33c:	2800      	cmp	r0, #0
    d33e:	d1f9      	bne.n	d334 <am_util_stdio_vsprintf+0x3d4>
                if ( iWidth )
    d340:	2900      	cmp	r1, #0
    d342:	f040 81ba 	bne.w	d6ba <am_util_stdio_vsprintf+0x75a>
                pcStr = va_arg(pArgs, char *);
    d346:	9201      	str	r2, [sp, #4]
    d348:	e612      	b.n	cf70 <am_util_stdio_vsprintf+0x10>
    d34a:	bf00      	nop
    d34c:	10001890 	.word	0x10001890
                if ( iWidth > 0 )
    d350:	2900      	cmp	r1, #0
    d352:	f340 838a 	ble.w	da6a <am_util_stdio_vsprintf+0xb0a>
        return ui32RetVal;
    d356:	463e      	mov	r6, r7
    if ( i32NumChars <= 0 )
    d358:	2900      	cmp	r1, #0
    d35a:	f300 8304 	bgt.w	d966 <am_util_stdio_vsprintf+0xa06>
    d35e:	465c      	mov	r4, fp
    d360:	2300      	movs	r3, #0
                        pcBuf += pcBuf ? iWidth : 0;
    d362:	f1ba 0f00 	cmp.w	sl, #0
    d366:	d000      	beq.n	d36a <am_util_stdio_vsprintf+0x40a>
    d368:	449a      	add	sl, r3
                while (*pcStr != 0x0)
    d36a:	7838      	ldrb	r0, [r7, #0]
    d36c:	2800      	cmp	r0, #0
    d36e:	f000 83f3 	beq.w	db58 <am_util_stdio_vsprintf+0xbf8>
                        iWidth = 0;
    d372:	2100      	movs	r1, #0
    d374:	1c7b      	adds	r3, r7, #1
    d376:	e7ca      	b.n	d30e <am_util_stdio_vsprintf+0x3ae>
        bLower = bLongLong = false;
    d378:	2500      	movs	r5, #0
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    d37a:	9b01      	ldr	r3, [sp, #4]
    d37c:	681a      	ldr	r2, [r3, #0]
                                      va_arg(pArgs, uint32_t);
    d37e:	3304      	adds	r3, #4
    d380:	9301      	str	r3, [sp, #4]
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    d382:	2300      	movs	r3, #0
                if ( iWidth )
    d384:	2c00      	cmp	r4, #0
    d386:	f040 80bd 	bne.w	d504 <am_util_stdio_vsprintf+0x5a4>
    if ( ui64Val == 0 )
    d38a:	ea52 0103 	orrs.w	r1, r2, r3
    d38e:	f040 80dd 	bne.w	d54c <am_util_stdio_vsprintf+0x5ec>
    if (pcBuf)
    d392:	f1ba 0f00 	cmp.w	sl, #0
    d396:	f000 828d 	beq.w	d8b4 <am_util_stdio_vsprintf+0x954>
            *pcBuf++ = tbuf[ix];
    d39a:	f10a 0501 	add.w	r5, sl, #1
    d39e:	f04f 0330 	mov.w	r3, #48	; 0x30
    d3a2:	f88a 3000 	strb.w	r3, [sl]
    d3a6:	2001      	movs	r0, #1
    d3a8:	46aa      	mov	sl, r5
        *pcBuf = 0;
    d3aa:	2300      	movs	r3, #0
    d3ac:	702b      	strb	r3, [r5, #0]
                ui32CharCnt += iVal;
    d3ae:	4483      	add	fp, r0
                break;
    d3b0:	e5de      	b.n	cf70 <am_util_stdio_vsprintf+0x10>
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
    d3b2:	9b01      	ldr	r3, [sp, #4]
    d3b4:	6818      	ldr	r0, [r3, #0]
                                     va_arg(pArgs, int32_t);
    d3b6:	3304      	adds	r3, #4
    d3b8:	9301      	str	r3, [sp, #4]
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
    d3ba:	17c1      	asrs	r1, r0, #31
                if ( i64Val < 0 )
    d3bc:	2800      	cmp	r0, #0
    d3be:	f171 0300 	sbcs.w	r3, r1, #0
    d3c2:	f2c0 8194 	blt.w	d6ee <am_util_stdio_vsprintf+0x78e>
                    ui64Val = i64Val;
    d3c6:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
                if ( iWidth )
    d3ca:	2c00      	cmp	r4, #0
    d3cc:	d065      	beq.n	d49a <am_util_stdio_vsprintf+0x53a>
    int iNDigits = ui64Val ? 0 : 1;
    d3ce:	4603      	mov	r3, r0
    d3d0:	430b      	orrs	r3, r1
    return ndigits_in_u64((uint64_t) i64Val);
    d3d2:	460c      	mov	r4, r1
    d3d4:	4603      	mov	r3, r0
    int iNDigits = ui64Val ? 0 : 1;
    d3d6:	bf0c      	ite	eq
    d3d8:	f04f 0e01 	moveq.w	lr, #1
    d3dc:	f04f 0e00 	movne.w	lr, #0
    while ( ui64Val )
    d3e0:	4323      	orrs	r3, r4
    d3e2:	f000 8396 	beq.w	db12 <am_util_stdio_vsprintf+0xbb2>
                    bNeg = false;
    d3e6:	2300      	movs	r3, #0
    d3e8:	e9cd 380f 	strd	r3, r8, [sp, #60]	; 0x3c
    d3ec:	e9cd 0102 	strd	r0, r1, [sp, #8]
    d3f0:	e9cd ba11 	strd	fp, sl, [sp, #68]	; 0x44
    d3f4:	f8cd 904c 	str.w	r9, [sp, #76]	; 0x4c
        q64 = (ui64Val>>1) + (ui64Val>>2);
    d3f8:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
        q64 += (q64 >> 4);
    d3fc:	2300      	movs	r3, #0
    d3fe:	2400      	movs	r4, #0
    d400:	e9cd 3408 	strd	r3, r4, [sp, #32]
        q64 += (q64 >> 8);
    d404:	e9cd 3406 	strd	r3, r4, [sp, #24]
        q64 += (q64 >> 16);
    d408:	e9cd 3404 	strd	r3, r4, [sp, #16]
        q64 += (q64 >> 32);
    d40c:	e9cd 340a 	strd	r3, r4, [sp, #40]	; 0x28
        q32 = (ui32Val>>1) + (ui32Val>>2);
    d410:	0843      	lsrs	r3, r0, #1
    d412:	eb03 0390 	add.w	r3, r3, r0, lsr #2
        q32 += (q32 >> 4);
    d416:	eb03 1313 	add.w	r3, r3, r3, lsr #4
        q32 += (q32 >> 8);
    d41a:	eb03 2313 	add.w	r3, r3, r3, lsr #8
        q32 += (q32 >> 16);
    d41e:	eb03 4313 	add.w	r3, r3, r3, lsr #16
        q32 >>= 3;
    d422:	08db      	lsrs	r3, r3, #3
        q32 = (ui32Val>>1) + (ui32Val>>2);
    d424:	4602      	mov	r2, r0
        r32 = ui32Val - q32*10;
    d426:	eb03 0c83 	add.w	ip, r3, r3, lsl #2
        q64 = (ui64Val>>1) + (ui64Val>>2);
    d42a:	0886      	lsrs	r6, r0, #2
    if ( ui64Val >> 32 )
    d42c:	460c      	mov	r4, r1
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    d42e:	3206      	adds	r2, #6
    if ( ui64Val >> 32 )
    d430:	2500      	movs	r5, #0
        q64 = (ui64Val>>1) + (ui64Val>>2);
    d432:	ea46 7681 	orr.w	r6, r6, r1, lsl #30
    d436:	088f      	lsrs	r7, r1, #2
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    d438:	eba2 024c 	sub.w	r2, r2, ip, lsl #1
    if ( ui64Val >> 32 )
    d43c:	ea54 0105 	orrs.w	r1, r4, r5
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    d440:	eb03 1312 	add.w	r3, r3, r2, lsr #4
    if ( ui64Val >> 32 )
    d444:	f040 80ba 	bne.w	d5bc <am_util_stdio_vsprintf+0x65c>
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    d448:	4619      	mov	r1, r3
    d44a:	2200      	movs	r2, #0
        ++iNDigits;
    d44c:	f10e 0e01 	add.w	lr, lr, #1
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    d450:	e9cd 1202 	strd	r1, r2, [sp, #8]
    while ( ui64Val )
    d454:	2b00      	cmp	r3, #0
    d456:	d1cf      	bne.n	d3f8 <am_util_stdio_vsprintf+0x498>
                    iWidth -= ndigits_in_i64(ui64Val);
    d458:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    d45a:	eba3 0e0e 	sub.w	lr, r3, lr
                    if ( bNeg )
    d45e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    d460:	e9dd 8b10 	ldrd	r8, fp, [sp, #64]	; 0x40
    d464:	e9dd a912 	ldrd	sl, r9, [sp, #72]	; 0x48
    d468:	b13b      	cbz	r3, d47a <am_util_stdio_vsprintf+0x51a>
                        if ( ui8PadChar == '0' )
    d46a:	f1b8 0f30 	cmp.w	r8, #48	; 0x30
                        --iWidth;
    d46e:	f10e 3eff 	add.w	lr, lr, #4294967295	; 0xffffffff
                        if ( ui8PadChar == '0' )
    d472:	f000 82a3 	beq.w	d9bc <am_util_stdio_vsprintf+0xa5c>
    d476:	2301      	movs	r3, #1
    d478:	930f      	str	r3, [sp, #60]	; 0x3c
    if ( i32NumChars <= 0 )
    d47a:	f1be 0f00 	cmp.w	lr, #0
    d47e:	f300 821e 	bgt.w	d8be <am_util_stdio_vsprintf+0x95e>
    d482:	2200      	movs	r2, #0
                    pcBuf += pcBuf ? iWidth : 0;
    d484:	f1ba 0f00 	cmp.w	sl, #0
    d488:	f000 82fc 	beq.w	da84 <am_util_stdio_vsprintf+0xb24>
                    if ( bNeg  &&  (ui8PadChar == ' ') )
    d48c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
                    pcBuf += pcBuf ? iWidth : 0;
    d48e:	4492      	add	sl, r2
                    if ( bNeg  &&  (ui8PadChar == ' ') )
    d490:	b11b      	cbz	r3, d49a <am_util_stdio_vsprintf+0x53a>
    d492:	f1b8 0f20 	cmp.w	r8, #32
    d496:	f000 8132 	beq.w	d6fe <am_util_stdio_vsprintf+0x79e>
                iVal = uint64_to_str(ui64Val, pcBuf);
    d49a:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
    d49e:	4652      	mov	r2, sl
    d4a0:	f7ff fc88 	bl	cdb4 <uint64_to_str>
                if ( pcBuf )
    d4a4:	f1ba 0f00 	cmp.w	sl, #0
    d4a8:	d081      	beq.n	d3ae <am_util_stdio_vsprintf+0x44e>
                    pcBuf += iVal;
    d4aa:	4482      	add	sl, r0
                ui32CharCnt += iVal;
    d4ac:	4483      	add	fp, r0
    d4ae:	e55f      	b.n	cf70 <am_util_stdio_vsprintf+0x10>
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    d4b0:	9a01      	ldr	r2, [sp, #4]
    d4b2:	6813      	ldr	r3, [r2, #0]
                                      va_arg(pArgs, uint32_t);
    d4b4:	3204      	adds	r2, #4
    d4b6:	9201      	str	r2, [sp, #4]
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    d4b8:	4619      	mov	r1, r3
    d4ba:	2200      	movs	r2, #0
    d4bc:	e9cd 120c 	strd	r1, r2, [sp, #48]	; 0x30
                if ( iWidth )
    d4c0:	2c00      	cmp	r4, #0
    d4c2:	f040 8127 	bne.w	d714 <am_util_stdio_vsprintf+0x7b4>
                iVal = uint64_to_str(ui64Val, pcBuf);
    d4c6:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
    d4ca:	4652      	mov	r2, sl
    d4cc:	f7ff fc72 	bl	cdb4 <uint64_to_str>
                if ( pcBuf )
    d4d0:	f1ba 0f00 	cmp.w	sl, #0
    d4d4:	d1e9      	bne.n	d4aa <am_util_stdio_vsprintf+0x54a>
    d4d6:	f04f 0a00 	mov.w	sl, #0
                ui32CharCnt += iVal;
    d4da:	4483      	add	fp, r0
    d4dc:	e548      	b.n	cf70 <am_util_stdio_vsprintf+0x10>
                bLower = true;
    d4de:	2501      	movs	r5, #1
    d4e0:	e74b      	b.n	d37a <am_util_stdio_vsprintf+0x41a>
        bLower = bLongLong = false;
    d4e2:	2300      	movs	r3, #0
                bLower = true;
    d4e4:	2501      	movs	r5, #1
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    d4e6:	2b00      	cmp	r3, #0
    d4e8:	f43f af47 	beq.w	d37a <am_util_stdio_vsprintf+0x41a>
    d4ec:	9b01      	ldr	r3, [sp, #4]
    d4ee:	3307      	adds	r3, #7
    d4f0:	f023 0307 	bic.w	r3, r3, #7
    d4f4:	f103 0208 	add.w	r2, r3, #8
    d4f8:	9201      	str	r2, [sp, #4]
    d4fa:	e9d3 2300 	ldrd	r2, r3, [r3]
                if ( iWidth )
    d4fe:	2c00      	cmp	r4, #0
    d500:	f43f af43 	beq.w	d38a <am_util_stdio_vsprintf+0x42a>
    int iDigits = ui64Val ? 0 : 1;
    d504:	ea52 0103 	orrs.w	r1, r2, r3
    d508:	bf0c      	ite	eq
    d50a:	2401      	moveq	r4, #1
    d50c:	2400      	movne	r4, #0
    while ( ui64Val )
    d50e:	ea52 0103 	orrs.w	r1, r2, r3
    d512:	d00c      	beq.n	d52e <am_util_stdio_vsprintf+0x5ce>
    d514:	4610      	mov	r0, r2
    d516:	4619      	mov	r1, r3
        ui64Val >>= 4;
    d518:	0906      	lsrs	r6, r0, #4
    d51a:	ea46 7601 	orr.w	r6, r6, r1, lsl #28
    d51e:	090f      	lsrs	r7, r1, #4
    d520:	4630      	mov	r0, r6
    d522:	4639      	mov	r1, r7
    while ( ui64Val )
    d524:	ea50 0601 	orrs.w	r6, r0, r1
        ++iDigits;
    d528:	f104 0401 	add.w	r4, r4, #1
    while ( ui64Val )
    d52c:	d1f4      	bne.n	d518 <am_util_stdio_vsprintf+0x5b8>
                    iWidth -= ndigits_in_hex(ui64Val);
    d52e:	990e      	ldr	r1, [sp, #56]	; 0x38
    d530:	1b09      	subs	r1, r1, r4
    if ( i32NumChars <= 0 )
    d532:	2900      	cmp	r1, #0
    d534:	f300 81a1 	bgt.w	d87a <am_util_stdio_vsprintf+0x91a>
    d538:	2000      	movs	r0, #0
                    pcBuf += pcBuf ? iWidth : 0;
    d53a:	f1ba 0f00 	cmp.w	sl, #0
    d53e:	f000 81b5 	beq.w	d8ac <am_util_stdio_vsprintf+0x94c>
    if ( ui64Val == 0 )
    d542:	ea52 0103 	orrs.w	r1, r2, r3
    d546:	4482      	add	sl, r0
    d548:	f43f af23 	beq.w	d392 <am_util_stdio_vsprintf+0x432>
    d54c:	2d00      	cmp	r5, #0
    d54e:	bf14      	ite	ne
    d550:	2527      	movne	r5, #39	; 0x27
    d552:	2507      	moveq	r5, #7
    if ( i32NumChars <= 0 )
    d554:	af15      	add	r7, sp, #84	; 0x54
    int iNumDig, ix = 0;
    d556:	2600      	movs	r6, #0
    d558:	f8cd 9008 	str.w	r9, [sp, #8]
        ui64Val >>= 4;
    d55c:	0914      	lsrs	r4, r2, #4
        cCh = ui64Val & 0xf;
    d55e:	f002 020f 	and.w	r2, r2, #15
        ui64Val >>= 4;
    d562:	ea4f 1813 	mov.w	r8, r3, lsr #4
            cCh += bLower ? 0x27 : 0x7;
    d566:	18a8      	adds	r0, r5, r2
        if ( cCh > 9 )
    d568:	2a09      	cmp	r2, #9
        ui64Val >>= 4;
    d56a:	46c6      	mov	lr, r8
    d56c:	ea44 7403 	orr.w	r4, r4, r3, lsl #28
        tbuf[ix++] = cCh + '0';
    d570:	f100 0030 	add.w	r0, r0, #48	; 0x30
    d574:	f102 0c30 	add.w	ip, r2, #48	; 0x30
    d578:	f106 0901 	add.w	r9, r6, #1
        if ( cCh > 9 )
    d57c:	d978      	bls.n	d670 <am_util_stdio_vsprintf+0x710>
        ui64Val >>= 4;
    d57e:	4622      	mov	r2, r4
    d580:	4643      	mov	r3, r8
    while ( ui64Val )
    d582:	ea52 0103 	orrs.w	r1, r2, r3
        tbuf[ix++] = cCh + '0';
    d586:	f807 0b01 	strb.w	r0, [r7], #1
    while ( ui64Val )
    d58a:	d07a      	beq.n	d682 <am_util_stdio_vsprintf+0x722>
    if ( i32NumChars <= 0 )
    d58c:	464e      	mov	r6, r9
    d58e:	e7e5      	b.n	d55c <am_util_stdio_vsprintf+0x5fc>
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    d590:	9b01      	ldr	r3, [sp, #4]
    d592:	3307      	adds	r3, #7
    d594:	f023 0307 	bic.w	r3, r3, #7
    d598:	f103 0208 	add.w	r2, r3, #8
    d59c:	9201      	str	r2, [sp, #4]
    d59e:	e9d3 2300 	ldrd	r2, r3, [r3]
    d5a2:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
    d5a6:	e78b      	b.n	d4c0 <am_util_stdio_vsprintf+0x560>
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
    d5a8:	9b01      	ldr	r3, [sp, #4]
    d5aa:	3307      	adds	r3, #7
    d5ac:	f023 0307 	bic.w	r3, r3, #7
    d5b0:	f103 0208 	add.w	r2, r3, #8
    d5b4:	9201      	str	r2, [sp, #4]
    d5b6:	e9d3 0100 	ldrd	r0, r1, [r3]
    d5ba:	e6ff      	b.n	d3bc <am_util_stdio_vsprintf+0x45c>
        q64 = (ui64Val>>1) + (ui64Val>>2);
    d5bc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    d5c0:	085b      	lsrs	r3, r3, #1
    d5c2:	ea4f 0232 	mov.w	r2, r2, rrx
    d5c6:	1990      	adds	r0, r2, r6
    d5c8:	eb43 0107 	adc.w	r1, r3, r7
        q64 += (q64 >> 4);
    d5cc:	0903      	lsrs	r3, r0, #4
    d5ce:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
    d5d2:	9308      	str	r3, [sp, #32]
    d5d4:	090b      	lsrs	r3, r1, #4
    d5d6:	9309      	str	r3, [sp, #36]	; 0x24
    d5d8:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
    d5dc:	1812      	adds	r2, r2, r0
    d5de:	414b      	adcs	r3, r1
        q64 += (q64 >> 8);
    d5e0:	0a11      	lsrs	r1, r2, #8
    d5e2:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
    d5e6:	9106      	str	r1, [sp, #24]
    d5e8:	0a19      	lsrs	r1, r3, #8
    d5ea:	9107      	str	r1, [sp, #28]
    d5ec:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    d5f0:	1880      	adds	r0, r0, r2
    d5f2:	4159      	adcs	r1, r3
    d5f4:	460b      	mov	r3, r1
        q64 += (q64 >> 16);
    d5f6:	0c01      	lsrs	r1, r0, #16
    d5f8:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    d5fc:	9104      	str	r1, [sp, #16]
    d5fe:	0c19      	lsrs	r1, r3, #16
    d600:	9105      	str	r1, [sp, #20]
        q64 += (q64 >> 8);
    d602:	4602      	mov	r2, r0
        q64 += (q64 >> 16);
    d604:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    d608:	1880      	adds	r0, r0, r2
    d60a:	4159      	adcs	r1, r3
        q64 += (q64 >> 32);
    d60c:	e9cd 150a 	strd	r1, r5, [sp, #40]	; 0x28
        q64 += (q64 >> 16);
    d610:	4602      	mov	r2, r0
    d612:	460b      	mov	r3, r1
        q64 += (q64 >> 32);
    d614:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    d618:	1880      	adds	r0, r0, r2
    d61a:	4159      	adcs	r1, r3
        q64 >>= 3;
    d61c:	ea4f 08d0 	mov.w	r8, r0, lsr #3
    d620:	ea48 7841 	orr.w	r8, r8, r1, lsl #29
    d624:	ea4f 09d1 	mov.w	r9, r1, lsr #3
        return q64 + ((r64 + 6) >> 4);
    d628:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
        r64 = ui64Val - q64*10;
    d62c:	ea4f 0489 	mov.w	r4, r9, lsl #2
    d630:	ea4f 0288 	mov.w	r2, r8, lsl #2
    d634:	ea44 7398 	orr.w	r3, r4, r8, lsr #30
    d638:	eb12 0408 	adds.w	r4, r2, r8
    d63c:	eb43 0509 	adc.w	r5, r3, r9
        return q64 + ((r64 + 6) >> 4);
    d640:	3006      	adds	r0, #6
    d642:	f141 0100 	adc.w	r1, r1, #0
        r64 = ui64Val - q64*10;
    d646:	1922      	adds	r2, r4, r4
    d648:	eb45 0305 	adc.w	r3, r5, r5
        return q64 + ((r64 + 6) >> 4);
    d64c:	1a80      	subs	r0, r0, r2
    d64e:	eb61 0103 	sbc.w	r1, r1, r3
    d652:	ea4f 1a10 	mov.w	sl, r0, lsr #4
    d656:	ea4a 7a01 	orr.w	sl, sl, r1, lsl #28
    d65a:	eb1a 0308 	adds.w	r3, sl, r8
    d65e:	ea4f 1b11 	mov.w	fp, r1, lsr #4
    d662:	eb4b 0409 	adc.w	r4, fp, r9
        ++iNDigits;
    d666:	f10e 0e01 	add.w	lr, lr, #1
        return q64 + ((r64 + 6) >> 4);
    d66a:	e9cd 3402 	strd	r3, r4, [sp, #8]
    d66e:	e6c3      	b.n	d3f8 <am_util_stdio_vsprintf+0x498>
        ui64Val >>= 4;
    d670:	4622      	mov	r2, r4
    d672:	4643      	mov	r3, r8
    while ( ui64Val )
    d674:	ea52 0103 	orrs.w	r1, r2, r3
        tbuf[ix++] = cCh + '0';
    d678:	f106 0901 	add.w	r9, r6, #1
    d67c:	f807 cb01 	strb.w	ip, [r7], #1
    while ( ui64Val )
    d680:	d184      	bne.n	d58c <am_util_stdio_vsprintf+0x62c>
    d682:	464d      	mov	r5, r9
    d684:	4628      	mov	r0, r5
    d686:	f8dd 9008 	ldr.w	r9, [sp, #8]
    if (pcBuf)
    d68a:	f1ba 0f00 	cmp.w	sl, #0
    d68e:	f43f af22 	beq.w	d4d6 <am_util_stdio_vsprintf+0x576>
    d692:	ab15      	add	r3, sp, #84	; 0x54
    d694:	eb0a 0405 	add.w	r4, sl, r5
    d698:	442b      	add	r3, r5
    d69a:	f10a 32ff 	add.w	r2, sl, #4294967295	; 0xffffffff
            *pcBuf++ = tbuf[ix];
    d69e:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
    d6a2:	f802 1f01 	strb.w	r1, [r2, #1]!
        while (ix--)
    d6a6:	a915      	add	r1, sp, #84	; 0x54
    d6a8:	4299      	cmp	r1, r3
    d6aa:	d1f8      	bne.n	d69e <am_util_stdio_vsprintf+0x73e>
    d6ac:	4455      	add	r5, sl
    d6ae:	46a2      	mov	sl, r4
    d6b0:	e67b      	b.n	d3aa <am_util_stdio_vsprintf+0x44a>
    d6b2:	46ba      	mov	sl, r7
                if ( iWidth )
    d6b4:	2900      	cmp	r1, #0
    d6b6:	f43f ae46 	beq.w	d346 <am_util_stdio_vsprintf+0x3e6>
                    iWidth = -iWidth;
    d6ba:	4249      	negs	r1, r1
                    if ( ui32strlen < iWidth )
    d6bc:	42b1      	cmp	r1, r6
    d6be:	f67f ae42 	bls.w	d346 <am_util_stdio_vsprintf+0x3e6>
                        iWidth -= ui32strlen;
    d6c2:	1b89      	subs	r1, r1, r6
    if ( i32NumChars <= 0 )
    d6c4:	2900      	cmp	r1, #0
    d6c6:	f300 8163 	bgt.w	d990 <am_util_stdio_vsprintf+0xa30>
    d6ca:	2100      	movs	r1, #0
                        pcBuf += pcBuf ? iWidth : 0;
    d6cc:	f1ba 0f00 	cmp.w	sl, #0
    d6d0:	f43f ae39 	beq.w	d346 <am_util_stdio_vsprintf+0x3e6>
    d6d4:	448a      	add	sl, r1
    d6d6:	e636      	b.n	d346 <am_util_stdio_vsprintf+0x3e6>
    d6d8:	7891      	ldrb	r1, [r2, #2]
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    d6da:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
    d6de:	2b09      	cmp	r3, #9
        pcStr++;
    d6e0:	f102 0002 	add.w	r0, r2, #2
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    d6e4:	f200 8234 	bhi.w	db50 <am_util_stdio_vsprintf+0xbf0>
        bNeg = true;
    d6e8:	2601      	movs	r6, #1
        uCnt++;
    d6ea:	4632      	mov	r2, r6
    d6ec:	e5e2      	b.n	d2b4 <am_util_stdio_vsprintf+0x354>
                    ui64Val = -i64Val;          // Get absolute value
    d6ee:	4240      	negs	r0, r0
    d6f0:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    d6f4:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
                if ( iWidth )
    d6f8:	2c00      	cmp	r4, #0
    d6fa:	f040 80fa 	bne.w	d8f2 <am_util_stdio_vsprintf+0x992>
                        if ( pcBuf )
    d6fe:	f1ba 0f00 	cmp.w	sl, #0
    d702:	d004      	beq.n	d70e <am_util_stdio_vsprintf+0x7ae>
                            *pcBuf++ = '-';
    d704:	232d      	movs	r3, #45	; 0x2d
    d706:	f88a 3000 	strb.w	r3, [sl]
    d70a:	f10a 0a01 	add.w	sl, sl, #1
                        ++ui32CharCnt;
    d70e:	f10b 0b01 	add.w	fp, fp, #1
    d712:	e6c2      	b.n	d49a <am_util_stdio_vsprintf+0x53a>
    int iNDigits = ui64Val ? 0 : 1;
    d714:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
    d718:	4603      	mov	r3, r0
    d71a:	430b      	orrs	r3, r1
    while ( ui64Val )
    d71c:	460c      	mov	r4, r1
    d71e:	4603      	mov	r3, r0
    int iNDigits = ui64Val ? 0 : 1;
    d720:	bf0c      	ite	eq
    d722:	f04f 0e01 	moveq.w	lr, #1
    d726:	f04f 0e00 	movne.w	lr, #0
    while ( ui64Val )
    d72a:	4323      	orrs	r3, r4
    d72c:	d03c      	beq.n	d7a8 <am_util_stdio_vsprintf+0x848>
    d72e:	e9cd 0102 	strd	r0, r1, [sp, #8]
    d732:	e9cd ba10 	strd	fp, sl, [sp, #64]	; 0x40
    d736:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
    d73a:	f8cd 9048 	str.w	r9, [sp, #72]	; 0x48
        q64 = (ui64Val>>1) + (ui64Val>>2);
    d73e:	e9dd 5602 	ldrd	r5, r6, [sp, #8]
        q64 += (q64 >> 4);
    d742:	2300      	movs	r3, #0
    d744:	2400      	movs	r4, #0
        q64 = (ui64Val>>1) + (ui64Val>>2);
    d746:	08a8      	lsrs	r0, r5, #2
        q64 += (q64 >> 4);
    d748:	e9cd 3408 	strd	r3, r4, [sp, #32]
        q64 += (q64 >> 8);
    d74c:	e9cd 3406 	strd	r3, r4, [sp, #24]
        q64 += (q64 >> 16);
    d750:	e9cd 3404 	strd	r3, r4, [sp, #16]
        q64 += (q64 >> 32);
    d754:	e9cd 340a 	strd	r3, r4, [sp, #40]	; 0x28
        q64 = (ui64Val>>1) + (ui64Val>>2);
    d758:	ea40 7086 	orr.w	r0, r0, r6, lsl #30
        q32 = (ui32Val>>1) + (ui32Val>>2);
    d75c:	462c      	mov	r4, r5
        q64 = (ui64Val>>1) + (ui64Val>>2);
    d75e:	08b1      	lsrs	r1, r6, #2
        q32 = (ui32Val>>1) + (ui32Val>>2);
    d760:	086e      	lsrs	r6, r5, #1
    d762:	eb06 0694 	add.w	r6, r6, r4, lsr #2
        q32 += (q32 >> 4);
    d766:	eb06 1616 	add.w	r6, r6, r6, lsr #4
    if ( ui64Val >> 32 )
    d76a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
        q32 += (q32 >> 8);
    d76e:	eb06 2616 	add.w	r6, r6, r6, lsr #8
        q32 += (q32 >> 16);
    d772:	eb06 4616 	add.w	r6, r6, r6, lsr #16
        q32 >>= 3;
    d776:	08f6      	lsrs	r6, r6, #3
        r32 = ui32Val - q32*10;
    d778:	eb06 0c86 	add.w	ip, r6, r6, lsl #2
    if ( ui64Val >> 32 )
    d77c:	461c      	mov	r4, r3
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    d77e:	1d97      	adds	r7, r2, #6
    if ( ui64Val >> 32 )
    d780:	2500      	movs	r5, #0
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    d782:	eba7 074c 	sub.w	r7, r7, ip, lsl #1
    if ( ui64Val >> 32 )
    d786:	ea54 0305 	orrs.w	r3, r4, r5
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    d78a:	eb06 1617 	add.w	r6, r6, r7, lsr #4
    if ( ui64Val >> 32 )
    d78e:	d118      	bne.n	d7c2 <am_util_stdio_vsprintf+0x862>
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    d790:	4633      	mov	r3, r6
    d792:	2400      	movs	r4, #0
        ++iNDigits;
    d794:	f10e 0e01 	add.w	lr, lr, #1
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    d798:	e9cd 3402 	strd	r3, r4, [sp, #8]
    while ( ui64Val )
    d79c:	2e00      	cmp	r6, #0
    d79e:	d1ce      	bne.n	d73e <am_util_stdio_vsprintf+0x7de>
    d7a0:	e9dd 8b0f 	ldrd	r8, fp, [sp, #60]	; 0x3c
    d7a4:	e9dd a911 	ldrd	sl, r9, [sp, #68]	; 0x44
                    iWidth -= ndigits_in_u64(ui64Val);
    d7a8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    d7aa:	eba3 030e 	sub.w	r3, r3, lr
    if ( i32NumChars <= 0 )
    d7ae:	2b00      	cmp	r3, #0
    d7b0:	f300 80c7 	bgt.w	d942 <am_util_stdio_vsprintf+0x9e2>
    d7b4:	2200      	movs	r2, #0
                    pcBuf += pcBuf ? iWidth : 0;
    d7b6:	f1ba 0f00 	cmp.w	sl, #0
    d7ba:	f000 8190 	beq.w	dade <am_util_stdio_vsprintf+0xb7e>
    d7be:	4492      	add	sl, r2
    d7c0:	e681      	b.n	d4c6 <am_util_stdio_vsprintf+0x566>
        q64 = (ui64Val>>1) + (ui64Val>>2);
    d7c2:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
    d7c6:	087f      	lsrs	r7, r7, #1
    d7c8:	ea4f 0636 	mov.w	r6, r6, rrx
    d7cc:	1982      	adds	r2, r0, r6
    d7ce:	eb41 0307 	adc.w	r3, r1, r7
        q64 += (q64 >> 4);
    d7d2:	0911      	lsrs	r1, r2, #4
    d7d4:	ea41 7103 	orr.w	r1, r1, r3, lsl #28
    d7d8:	9108      	str	r1, [sp, #32]
    d7da:	0919      	lsrs	r1, r3, #4
    d7dc:	9109      	str	r1, [sp, #36]	; 0x24
    d7de:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
    d7e2:	1880      	adds	r0, r0, r2
    d7e4:	4159      	adcs	r1, r3
    d7e6:	460b      	mov	r3, r1
        q64 += (q64 >> 8);
    d7e8:	0a01      	lsrs	r1, r0, #8
    d7ea:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
    d7ee:	9106      	str	r1, [sp, #24]
    d7f0:	0a19      	lsrs	r1, r3, #8
    d7f2:	9107      	str	r1, [sp, #28]
        q64 += (q64 >> 4);
    d7f4:	4602      	mov	r2, r0
        q64 += (q64 >> 8);
    d7f6:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    d7fa:	1880      	adds	r0, r0, r2
    d7fc:	4159      	adcs	r1, r3
    d7fe:	460b      	mov	r3, r1
        q64 += (q64 >> 16);
    d800:	0c01      	lsrs	r1, r0, #16
    d802:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    d806:	9104      	str	r1, [sp, #16]
    d808:	0c19      	lsrs	r1, r3, #16
    d80a:	9105      	str	r1, [sp, #20]
        q64 += (q64 >> 8);
    d80c:	4602      	mov	r2, r0
        q64 += (q64 >> 16);
    d80e:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    d812:	1880      	adds	r0, r0, r2
    d814:	4159      	adcs	r1, r3
        q64 += (q64 >> 32);
    d816:	e9cd 150a 	strd	r1, r5, [sp, #40]	; 0x28
        q64 += (q64 >> 16);
    d81a:	4602      	mov	r2, r0
    d81c:	460b      	mov	r3, r1
        q64 += (q64 >> 32);
    d81e:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    d822:	1880      	adds	r0, r0, r2
    d824:	4159      	adcs	r1, r3
        q64 >>= 3;
    d826:	ea4f 08d0 	mov.w	r8, r0, lsr #3
    d82a:	ea48 7841 	orr.w	r8, r8, r1, lsl #29
    d82e:	ea4f 09d1 	mov.w	r9, r1, lsr #3
        return q64 + ((r64 + 6) >> 4);
    d832:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
        r64 = ui64Val - q64*10;
    d836:	ea4f 0489 	mov.w	r4, r9, lsl #2
    d83a:	ea4f 0288 	mov.w	r2, r8, lsl #2
    d83e:	ea44 7398 	orr.w	r3, r4, r8, lsr #30
    d842:	eb12 0408 	adds.w	r4, r2, r8
    d846:	eb43 0509 	adc.w	r5, r3, r9
        return q64 + ((r64 + 6) >> 4);
    d84a:	3006      	adds	r0, #6
    d84c:	f141 0100 	adc.w	r1, r1, #0
        r64 = ui64Val - q64*10;
    d850:	1922      	adds	r2, r4, r4
    d852:	eb45 0305 	adc.w	r3, r5, r5
        return q64 + ((r64 + 6) >> 4);
    d856:	1a80      	subs	r0, r0, r2
    d858:	eb61 0103 	sbc.w	r1, r1, r3
    d85c:	ea4f 1a10 	mov.w	sl, r0, lsr #4
    d860:	ea4a 7a01 	orr.w	sl, sl, r1, lsl #28
    d864:	eb1a 0308 	adds.w	r3, sl, r8
    d868:	ea4f 1b11 	mov.w	fp, r1, lsr #4
    d86c:	eb4b 0409 	adc.w	r4, fp, r9
        ++iNDigits;
    d870:	f10e 0e01 	add.w	lr, lr, #1
        return q64 + ((r64 + 6) >> 4);
    d874:	e9cd 3402 	strd	r3, r4, [sp, #8]
    d878:	e761      	b.n	d73e <am_util_stdio_vsprintf+0x7de>
    while ( i32NumChars-- )
    d87a:	3901      	subs	r1, #1
    d87c:	4656      	mov	r6, sl
    int32_t i32Cnt = 0;
    d87e:	2000      	movs	r0, #0
    d880:	1e4f      	subs	r7, r1, #1
    d882:	1c44      	adds	r4, r0, #1
        if ( pcBuf )
    d884:	b156      	cbz	r6, d89c <am_util_stdio_vsprintf+0x93c>
            *pcBuf++ = cPadChar;
    d886:	46bc      	mov	ip, r7
    d888:	460f      	mov	r7, r1
    d88a:	f886 8000 	strb.w	r8, [r6]
    d88e:	4620      	mov	r0, r4
    d890:	4661      	mov	r1, ip
    d892:	3601      	adds	r6, #1
    while ( i32NumChars-- )
    d894:	2f00      	cmp	r7, #0
    d896:	d1f3      	bne.n	d880 <am_util_stdio_vsprintf+0x920>
    d898:	4483      	add	fp, r0
    d89a:	e64e      	b.n	d53a <am_util_stdio_vsprintf+0x5da>
    d89c:	2900      	cmp	r1, #0
    d89e:	f000 8126 	beq.w	daee <am_util_stdio_vsprintf+0xb8e>
    d8a2:	3902      	subs	r1, #2
    d8a4:	3002      	adds	r0, #2
    d8a6:	2f00      	cmp	r7, #0
    d8a8:	d1ea      	bne.n	d880 <am_util_stdio_vsprintf+0x920>
    d8aa:	e7f5      	b.n	d898 <am_util_stdio_vsprintf+0x938>
    if ( ui64Val == 0 )
    d8ac:	ea52 0103 	orrs.w	r1, r2, r3
    d8b0:	f47f ae4c 	bne.w	d54c <am_util_stdio_vsprintf+0x5ec>
    d8b4:	2001      	movs	r0, #1
    d8b6:	e60e      	b.n	d4d6 <am_util_stdio_vsprintf+0x576>
    uint32_t ui32Val = 0, uCnt = 0;
    d8b8:	2200      	movs	r2, #0
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    d8ba:	4613      	mov	r3, r2
    d8bc:	e50b      	b.n	d2d6 <am_util_stdio_vsprintf+0x376>
    while ( i32NumChars-- )
    d8be:	f10e 33ff 	add.w	r3, lr, #4294967295	; 0xffffffff
    d8c2:	4650      	mov	r0, sl
    int32_t i32Cnt = 0;
    d8c4:	2200      	movs	r2, #0
    d8c6:	1e5c      	subs	r4, r3, #1
    d8c8:	1c51      	adds	r1, r2, #1
        if ( pcBuf )
    d8ca:	b150      	cbz	r0, d8e2 <am_util_stdio_vsprintf+0x982>
            *pcBuf++ = cPadChar;
    d8cc:	4625      	mov	r5, r4
    d8ce:	461c      	mov	r4, r3
    d8d0:	f880 8000 	strb.w	r8, [r0]
    d8d4:	460a      	mov	r2, r1
    d8d6:	462b      	mov	r3, r5
    d8d8:	3001      	adds	r0, #1
    while ( i32NumChars-- )
    d8da:	2c00      	cmp	r4, #0
    d8dc:	d1f3      	bne.n	d8c6 <am_util_stdio_vsprintf+0x966>
    d8de:	4493      	add	fp, r2
    d8e0:	e5d0      	b.n	d484 <am_util_stdio_vsprintf+0x524>
    d8e2:	2b00      	cmp	r3, #0
    d8e4:	f000 8110 	beq.w	db08 <am_util_stdio_vsprintf+0xba8>
    d8e8:	3b02      	subs	r3, #2
    d8ea:	3202      	adds	r2, #2
    d8ec:	2c00      	cmp	r4, #0
    d8ee:	d1ea      	bne.n	d8c6 <am_util_stdio_vsprintf+0x966>
    d8f0:	e7f5      	b.n	d8de <am_util_stdio_vsprintf+0x97e>
    int iNDigits = ui64Val ? 0 : 1;
    d8f2:	4603      	mov	r3, r0
    d8f4:	430b      	orrs	r3, r1
    d8f6:	bf0c      	ite	eq
    d8f8:	f04f 0e01 	moveq.w	lr, #1
    d8fc:	f04f 0e00 	movne.w	lr, #0
                    bNeg = true;
    d900:	2301      	movs	r3, #1
    d902:	e571      	b.n	d3e8 <am_util_stdio_vsprintf+0x488>
    else if (iExp2 >= 0)
    d904:	2a00      	cmp	r2, #0
    d906:	f2c0 80f5 	blt.w	daf4 <am_util_stdio_vsprintf+0xb94>
        i32FracPart = (i32Significand << (iExp2 + 1)) & 0x00FFFFFF;
    d90a:	f1a1 047e 	sub.w	r4, r1, #126	; 0x7e
    d90e:	fa00 f404 	lsl.w	r4, r0, r4
        i32IntPart = i32Significand >> (23 - iExp2);
    d912:	f1c2 0217 	rsb	r2, r2, #23
    if (unFloatValue.I32 < 0)
    d916:	2b00      	cmp	r3, #0
        i32FracPart = (i32Significand << (iExp2 + 1)) & 0x00FFFFFF;
    d918:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
        i32IntPart = i32Significand >> (23 - iExp2);
    d91c:	fa40 f002 	asr.w	r0, r0, r2
    if (unFloatValue.I32 < 0)
    d920:	f2c0 80d5 	blt.w	dace <am_util_stdio_vsprintf+0xb6e>
    d924:	4656      	mov	r6, sl
            uint64_to_str(i32IntPart, pcBuf);
    d926:	4632      	mov	r2, r6
    d928:	17c1      	asrs	r1, r0, #31
    d92a:	f7ff fa43 	bl	cdb4 <uint64_to_str>
        while (*pcBuf)    // Get to end of new string
    d92e:	7833      	ldrb	r3, [r6, #0]
    d930:	b90b      	cbnz	r3, d936 <am_util_stdio_vsprintf+0x9d6>
    d932:	e100      	b.n	db36 <am_util_stdio_vsprintf+0xbd6>
    d934:	463e      	mov	r6, r7
    d936:	7873      	ldrb	r3, [r6, #1]
            pcBuf++;
    d938:	1c77      	adds	r7, r6, #1
        while (*pcBuf)    // Get to end of new string
    d93a:	2b00      	cmp	r3, #0
    d93c:	d1fa      	bne.n	d934 <am_util_stdio_vsprintf+0x9d4>
    d93e:	1cb2      	adds	r2, r6, #2
    d940:	e480      	b.n	d244 <am_util_stdio_vsprintf+0x2e4>
    while ( i32NumChars-- )
    d942:	3b01      	subs	r3, #1
    d944:	4650      	mov	r0, sl
    int32_t i32Cnt = 0;
    d946:	2200      	movs	r2, #0
    d948:	1c51      	adds	r1, r2, #1
    d94a:	1e5c      	subs	r4, r3, #1
        if ( pcBuf )
    d94c:	2800      	cmp	r0, #0
    d94e:	d042      	beq.n	d9d6 <am_util_stdio_vsprintf+0xa76>
            *pcBuf++ = cPadChar;
    d950:	4625      	mov	r5, r4
    d952:	f880 8000 	strb.w	r8, [r0]
    d956:	461c      	mov	r4, r3
    d958:	460a      	mov	r2, r1
    d95a:	462b      	mov	r3, r5
    d95c:	3001      	adds	r0, #1
    while ( i32NumChars-- )
    d95e:	2c00      	cmp	r4, #0
    d960:	d1f2      	bne.n	d948 <am_util_stdio_vsprintf+0x9e8>
    d962:	4493      	add	fp, r2
    d964:	e727      	b.n	d7b6 <am_util_stdio_vsprintf+0x856>
    d966:	1e48      	subs	r0, r1, #1
    d968:	4654      	mov	r4, sl
    int32_t i32Cnt = 0;
    d96a:	2300      	movs	r3, #0
    d96c:	1c59      	adds	r1, r3, #1
    d96e:	1e45      	subs	r5, r0, #1
        if ( pcBuf )
    d970:	b3bc      	cbz	r4, d9e2 <am_util_stdio_vsprintf+0xa82>
            *pcBuf++ = cPadChar;
    d972:	f884 8000 	strb.w	r8, [r4]
    d976:	460b      	mov	r3, r1
    d978:	3401      	adds	r4, #1
    d97a:	4601      	mov	r1, r0
    while ( i32NumChars-- )
    d97c:	4628      	mov	r0, r5
    d97e:	2900      	cmp	r1, #0
    d980:	d1f4      	bne.n	d96c <am_util_stdio_vsprintf+0xa0c>
    d982:	eb0b 0403 	add.w	r4, fp, r3
    d986:	e4ec      	b.n	d362 <am_util_stdio_vsprintf+0x402>
                bLongLong = true;
    d988:	2301      	movs	r3, #1
    d98a:	e5ab      	b.n	d4e4 <am_util_stdio_vsprintf+0x584>
        bLower = bLongLong = false;
    d98c:	2500      	movs	r5, #0
    d98e:	e5ad      	b.n	d4ec <am_util_stdio_vsprintf+0x58c>
    while ( i32NumChars-- )
    d990:	1e4b      	subs	r3, r1, #1
    d992:	4654      	mov	r4, sl
    int32_t i32Cnt = 0;
    d994:	2100      	movs	r1, #0
    d996:	1c48      	adds	r0, r1, #1
    d998:	1e5d      	subs	r5, r3, #1
        if ( pcBuf )
    d99a:	b34c      	cbz	r4, d9f0 <am_util_stdio_vsprintf+0xa90>
            *pcBuf++ = cPadChar;
    d99c:	f884 8000 	strb.w	r8, [r4]
    d9a0:	4601      	mov	r1, r0
    d9a2:	3401      	adds	r4, #1
    d9a4:	4618      	mov	r0, r3
    while ( i32NumChars-- )
    d9a6:	462b      	mov	r3, r5
    d9a8:	2800      	cmp	r0, #0
    d9aa:	d1f4      	bne.n	d996 <am_util_stdio_vsprintf+0xa36>
    d9ac:	448b      	add	fp, r1
    d9ae:	e68d      	b.n	d6cc <am_util_stdio_vsprintf+0x76c>
                if ( iWidth > 0 )
    d9b0:	2900      	cmp	r1, #0
    d9b2:	f340 809a 	ble.w	daea <am_util_stdio_vsprintf+0xb8a>
                    if ( ui32strlen < iWidth )
    d9b6:	4606      	mov	r6, r0
    d9b8:	1b89      	subs	r1, r1, r6
    d9ba:	e4cd      	b.n	d358 <am_util_stdio_vsprintf+0x3f8>
                            if ( pcBuf )
    d9bc:	f1ba 0f00 	cmp.w	sl, #0
    d9c0:	d004      	beq.n	d9cc <am_util_stdio_vsprintf+0xa6c>
                                *pcBuf++ = '-';
    d9c2:	232d      	movs	r3, #45	; 0x2d
    d9c4:	f88a 3000 	strb.w	r3, [sl]
    d9c8:	f10a 0a01 	add.w	sl, sl, #1
                            ++ui32CharCnt;
    d9cc:	2301      	movs	r3, #1
    d9ce:	f10b 0b01 	add.w	fp, fp, #1
    d9d2:	930f      	str	r3, [sp, #60]	; 0x3c
    d9d4:	e551      	b.n	d47a <am_util_stdio_vsprintf+0x51a>
    while ( i32NumChars-- )
    d9d6:	2b00      	cmp	r3, #0
    d9d8:	f000 80a1 	beq.w	db1e <am_util_stdio_vsprintf+0xbbe>
    d9dc:	3b02      	subs	r3, #2
    d9de:	3202      	adds	r2, #2
    d9e0:	e7bd      	b.n	d95e <am_util_stdio_vsprintf+0x9fe>
    d9e2:	2800      	cmp	r0, #0
    d9e4:	f000 809e 	beq.w	db24 <am_util_stdio_vsprintf+0xbc4>
    d9e8:	4629      	mov	r1, r5
    d9ea:	3302      	adds	r3, #2
    d9ec:	1e85      	subs	r5, r0, #2
    d9ee:	e7c5      	b.n	d97c <am_util_stdio_vsprintf+0xa1c>
    d9f0:	2b00      	cmp	r3, #0
    d9f2:	f000 809d 	beq.w	db30 <am_util_stdio_vsprintf+0xbd0>
    d9f6:	4628      	mov	r0, r5
    d9f8:	3102      	adds	r1, #2
    d9fa:	1e9d      	subs	r5, r3, #2
    d9fc:	e7d3      	b.n	d9a6 <am_util_stdio_vsprintf+0xa46>
        iMax = iBufSize - (pcBuf - pcBufInitial) - 1;
    d9fe:	eba2 010a 	sub.w	r1, r2, sl
    da02:	f1c1 0313 	rsb	r3, r1, #19
        iMax = (iMax > iPrecision) ? iPrecision : iMax;
    da06:	42ab      	cmp	r3, r5
    da08:	bfa8      	it	ge
    da0a:	462b      	movge	r3, r5
        for (jx = 0; jx < iMax; jx++)
    da0c:	2b00      	cmp	r3, #0
    da0e:	dd0d      	ble.n	da2c <am_util_stdio_vsprintf+0xacc>
    da10:	18d1      	adds	r1, r2, r3
            i32FracPart *= 10;
    da12:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    da16:	0064      	lsls	r4, r4, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
    da18:	1623      	asrs	r3, r4, #24
    da1a:	3330      	adds	r3, #48	; 0x30
    da1c:	f802 3b01 	strb.w	r3, [r2], #1
        for (jx = 0; jx < iMax; jx++)
    da20:	4291      	cmp	r1, r2
            i32FracPart &= 0x00FFFFFF;
    da22:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
        for (jx = 0; jx < iMax; jx++)
    da26:	d1f4      	bne.n	da12 <am_util_stdio_vsprintf+0xab2>
    da28:	eba2 010a 	sub.w	r1, r2, sl
        if ( ((i32FracPart * 10) >> 24) >= 5 )
    da2c:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    da30:	f344 53c7 	sbfx	r3, r4, #23, #8
    da34:	2b04      	cmp	r3, #4
    da36:	f77f ac10 	ble.w	d25a <am_util_stdio_vsprintf+0x2fa>
            pcBuftmp = pcBuf - 1;
    da3a:	1e53      	subs	r3, r2, #1
            while ( pcBuftmp >= pcBufInitial )
    da3c:	459a      	cmp	sl, r3
    da3e:	f63f ac0c 	bhi.w	d25a <am_util_stdio_vsprintf+0x2fa>
    da42:	f10a 35ff 	add.w	r5, sl, #4294967295	; 0xffffffff
    da46:	e005      	b.n	da54 <am_util_stdio_vsprintf+0xaf4>
                    *pcBuftmp = '0';
    da48:	f04f 0030 	mov.w	r0, #48	; 0x30
    da4c:	7058      	strb	r0, [r3, #1]
            while ( pcBuftmp >= pcBufInitial )
    da4e:	429d      	cmp	r5, r3
    da50:	f43f ac03 	beq.w	d25a <am_util_stdio_vsprintf+0x2fa>
    da54:	461c      	mov	r4, r3
                if ( *pcBuftmp == '.' )
    da56:	f813 0901 	ldrb.w	r0, [r3], #-1
    da5a:	282e      	cmp	r0, #46	; 0x2e
    da5c:	d0f7      	beq.n	da4e <am_util_stdio_vsprintf+0xaee>
                else if ( *pcBuftmp == '9' )
    da5e:	2839      	cmp	r0, #57	; 0x39
    da60:	d0f2      	beq.n	da48 <am_util_stdio_vsprintf+0xae8>
                    *pcBuftmp += 1;
    da62:	3001      	adds	r0, #1
    da64:	7020      	strb	r0, [r4, #0]
    da66:	f7ff bbf8 	b.w	d25a <am_util_stdio_vsprintf+0x2fa>
                while (*pcStr != 0x0)
    da6a:	7838      	ldrb	r0, [r7, #0]
    da6c:	2800      	cmp	r0, #0
    da6e:	d03c      	beq.n	daea <am_util_stdio_vsprintf+0xb8a>
    da70:	465c      	mov	r4, fp
        return ui32RetVal;
    da72:	463e      	mov	r6, r7
    da74:	2301      	movs	r3, #1
    da76:	e44a      	b.n	d30e <am_util_stdio_vsprintf+0x3ae>
        *(uint32_t*)pcBuf = 0x00 << 24 | ('0' << 16) | ('.' << 8) | ('0' << 0);
    da78:	4b39      	ldr	r3, [pc, #228]	; (db60 <am_util_stdio_vsprintf+0xc00>)
    da7a:	f8ca 3000 	str.w	r3, [sl]
    da7e:	2303      	movs	r3, #3
    da80:	f7ff bbf1 	b.w	d266 <am_util_stdio_vsprintf+0x306>
                    if ( bNeg  &&  (ui8PadChar == ' ') )
    da84:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    da86:	b11b      	cbz	r3, da90 <am_util_stdio_vsprintf+0xb30>
    da88:	f1b8 0f20 	cmp.w	r8, #32
    da8c:	f43f ae3f 	beq.w	d70e <am_util_stdio_vsprintf+0x7ae>
                iVal = uint64_to_str(ui64Val, pcBuf);
    da90:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
    da94:	4652      	mov	r2, sl
    da96:	f7ff f98d 	bl	cdb4 <uint64_to_str>
                ui32CharCnt += iVal;
    da9a:	4483      	add	fp, r0
    da9c:	f7ff ba68 	b.w	cf70 <am_util_stdio_vsprintf+0x10>
                        if ( iVal == AM_FTOA_ERR_VAL_TOO_SMALL )
    daa0:	1c4b      	adds	r3, r1, #1
    daa2:	d034      	beq.n	db0e <am_util_stdio_vsprintf+0xbae>
                        else if ( iVal == AM_FTOA_ERR_VAL_TOO_LARGE )
    daa4:	3102      	adds	r1, #2
    daa6:	d141      	bne.n	db2c <am_util_stdio_vsprintf+0xbcc>
                            u32PrntErrVal = (0x00 << 24) | ('#' << 16) |
    daa8:	4b2e      	ldr	r3, [pc, #184]	; (db64 <am_util_stdio_vsprintf+0xc04>)
                        *(uint32_t*)pcBuf = u32PrntErrVal;
    daaa:	f8ca 3000 	str.w	r3, [sl]
    daae:	2303      	movs	r3, #3
    dab0:	f7ff bbd9 	b.w	d266 <am_util_stdio_vsprintf+0x306>
        if (i32IntPart > 0)
    dab4:	f73f af37 	bgt.w	d926 <am_util_stdio_vsprintf+0x9c6>
            uint64_to_str(-i32IntPart, pcBuf);
    dab8:	4240      	negs	r0, r0
            *pcBuf++ = '-';
    daba:	232d      	movs	r3, #45	; 0x2d
    dabc:	7033      	strb	r3, [r6, #0]
            uint64_to_str(-i32IntPart, pcBuf);
    dabe:	463a      	mov	r2, r7
    dac0:	17c1      	asrs	r1, r0, #31
    dac2:	463e      	mov	r6, r7
    dac4:	f7ff f976 	bl	cdb4 <uint64_to_str>
    dac8:	3701      	adds	r7, #1
    daca:	e730      	b.n	d92e <am_util_stdio_vsprintf+0x9ce>
    i32FracPart = 0;
    dacc:	2400      	movs	r4, #0
        *pcBuf++ = '-';
    dace:	4653      	mov	r3, sl
    dad0:	222d      	movs	r2, #45	; 0x2d
    dad2:	f803 2b02 	strb.w	r2, [r3], #2
    dad6:	463e      	mov	r6, r7
    dad8:	461f      	mov	r7, r3
    dada:	f7ff bbac 	b.w	d236 <am_util_stdio_vsprintf+0x2d6>
                iVal = uint64_to_str(ui64Val, pcBuf);
    dade:	4652      	mov	r2, sl
    dae0:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
    dae4:	f7ff f966 	bl	cdb4 <uint64_to_str>
    dae8:	e4f5      	b.n	d4d6 <am_util_stdio_vsprintf+0x576>
        return ui32RetVal;
    daea:	4606      	mov	r6, r0
    daec:	e428      	b.n	d340 <am_util_stdio_vsprintf+0x3e0>
    daee:	4620      	mov	r0, r4
    daf0:	44a3      	add	fp, r4
    daf2:	e522      	b.n	d53a <am_util_stdio_vsprintf+0x5da>
        i32FracPart = (i32Significand & 0x00FFFFFF) >> -(iExp2 + 1);
    daf4:	43d2      	mvns	r2, r2
    if (unFloatValue.I32 < 0)
    daf6:	2b00      	cmp	r3, #0
        i32FracPart = (i32Significand & 0x00FFFFFF) >> -(iExp2 + 1);
    daf8:	fa40 f402 	asr.w	r4, r0, r2
    dafc:	f10a 0202 	add.w	r2, sl, #2
    if (unFloatValue.I32 < 0)
    db00:	db1d      	blt.n	db3e <am_util_stdio_vsprintf+0xbde>
    db02:	4656      	mov	r6, sl
    db04:	f7ff bb9b 	b.w	d23e <am_util_stdio_vsprintf+0x2de>
    db08:	460a      	mov	r2, r1
    db0a:	448b      	add	fp, r1
    db0c:	e4ba      	b.n	d484 <am_util_stdio_vsprintf+0x524>
                            u32PrntErrVal = (0x00 << 24) | ('0' << 16) |
    db0e:	4b14      	ldr	r3, [pc, #80]	; (db60 <am_util_stdio_vsprintf+0xc00>)
    db10:	e7cb      	b.n	daaa <am_util_stdio_vsprintf+0xb4a>
                    iWidth -= ndigits_in_i64(ui64Val);
    db12:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    db14:	eba3 0e0e 	sub.w	lr, r3, lr
                    bNeg = false;
    db18:	2300      	movs	r3, #0
    db1a:	930f      	str	r3, [sp, #60]	; 0x3c
    db1c:	e4ad      	b.n	d47a <am_util_stdio_vsprintf+0x51a>
    db1e:	460a      	mov	r2, r1
    db20:	448b      	add	fp, r1
    db22:	e648      	b.n	d7b6 <am_util_stdio_vsprintf+0x856>
    db24:	460b      	mov	r3, r1
    db26:	eb0b 0401 	add.w	r4, fp, r1
    db2a:	e41a      	b.n	d362 <am_util_stdio_vsprintf+0x402>
                            u32PrntErrVal = (0x00 << 24) | ('?' << 16) |
    db2c:	4b0e      	ldr	r3, [pc, #56]	; (db68 <am_util_stdio_vsprintf+0xc08>)
    db2e:	e7bc      	b.n	daaa <am_util_stdio_vsprintf+0xb4a>
    db30:	4601      	mov	r1, r0
    db32:	4483      	add	fp, r0
    db34:	e5ca      	b.n	d6cc <am_util_stdio_vsprintf+0x76c>
        while (*pcBuf)    // Get to end of new string
    db36:	463a      	mov	r2, r7
    db38:	4637      	mov	r7, r6
    db3a:	f7ff bb83 	b.w	d244 <am_util_stdio_vsprintf+0x2e4>
        *pcBuf++ = '-';
    db3e:	4653      	mov	r3, sl
    db40:	212d      	movs	r1, #45	; 0x2d
    db42:	f803 1b03 	strb.w	r1, [r3], #3
    db46:	463e      	mov	r6, r7
    db48:	4617      	mov	r7, r2
    db4a:	461a      	mov	r2, r3
    db4c:	f7ff bb77 	b.w	d23e <am_util_stdio_vsprintf+0x2de>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    db50:	2300      	movs	r3, #0
        uCnt++;
    db52:	2201      	movs	r2, #1
    db54:	f7ff bbbe 	b.w	d2d4 <am_util_stdio_vsprintf+0x374>
                pcStr = va_arg(pArgs, char *);
    db58:	9201      	str	r2, [sp, #4]
                        ui32CharCnt += iWidth;
    db5a:	46a3      	mov	fp, r4
    db5c:	f7ff ba08 	b.w	cf70 <am_util_stdio_vsprintf+0x10>
    db60:	00302e30 	.word	0x00302e30
    db64:	00232e23 	.word	0x00232e23
    db68:	003f2e3f 	.word	0x003f2e3f

0000db6c <am_util_stdio_printf>:
//! @return uint32_t representing the number of characters printed.
//
// *****************************************************************************
uint32_t
am_util_stdio_printf(const char *pcFmt, ...)
{
    db6c:	b40f      	push	{r0, r1, r2, r3}
    db6e:	b530      	push	{r4, r5, lr}
    db70:	b083      	sub	sp, #12
    db72:	aa06      	add	r2, sp, #24
    //
    // Convert to the desired string.
    //
    va_list pArgs;
    va_start(pArgs, pcFmt);
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
    db74:	4c08      	ldr	r4, [pc, #32]	; (db98 <am_util_stdio_printf+0x2c>)
{
    db76:	f852 1b04 	ldr.w	r1, [r2], #4
    va_start(pArgs, pcFmt);
    db7a:	9201      	str	r2, [sp, #4]
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
    db7c:	4620      	mov	r0, r4
    db7e:	f7ff f9ef 	bl	cf60 <am_util_stdio_vsprintf>
    va_end(pArgs);

    //
    // This is where we print the buffer to the configured interface.
    //
    g_pfnCharPrint(g_prfbuf);
    db82:	4b06      	ldr	r3, [pc, #24]	; (db9c <am_util_stdio_printf+0x30>)
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
    db84:	4605      	mov	r5, r0
    g_pfnCharPrint(g_prfbuf);
    db86:	681b      	ldr	r3, [r3, #0]
    db88:	4620      	mov	r0, r4
    db8a:	4798      	blx	r3

    //
    // return the number of characters printed.
    //
    return ui32NumChars;
}
    db8c:	4628      	mov	r0, r5
    db8e:	b003      	add	sp, #12
    db90:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    db94:	b004      	add	sp, #16
    db96:	4770      	bx	lr
    db98:	10001894 	.word	0x10001894
    db9c:	100019e8 	.word	0x100019e8

0000dba0 <am_devices_led_array_init>:
void
am_devices_led_array_init(am_devices_led_t *psLEDs, uint32_t ui32NumLEDs)
{
    uint32_t i;

    if ( (psLEDs == NULL)                       ||
    dba0:	b360      	cbz	r0, dbfc <am_devices_led_array_init+0x5c>
    }

    //
    // Loop through the list of LEDs, configuring each one individually.
    //
    for ( i = 0; i < ui32NumLEDs; i++ )
    dba2:	1e4b      	subs	r3, r1, #1
    dba4:	2b1e      	cmp	r3, #30
    dba6:	d829      	bhi.n	dbfc <am_devices_led_array_init+0x5c>
{
    dba8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_TRISTATE);
    dbac:	4f14      	ldr	r7, [pc, #80]	; (dc00 <am_devices_led_array_init+0x60>)
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_OUTPUT);
    dbae:	f8df 8054 	ldr.w	r8, [pc, #84]	; dc04 <am_devices_led_array_init+0x64>
    dbb2:	4604      	mov	r4, r0
    dbb4:	eb00 06c1 	add.w	r6, r0, r1, lsl #3
    dbb8:	1d05      	adds	r5, r0, #4
    if ( (psLED == NULL)    ||
    dbba:	b1c4      	cbz	r4, dbee <am_devices_led_array_init+0x4e>
         (psLED->ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    dbbc:	f855 3c04 	ldr.w	r3, [r5, #-4]
    if ( (psLED == NULL)    ||
    dbc0:	2b31      	cmp	r3, #49	; 0x31
    dbc2:	d814      	bhi.n	dbee <am_devices_led_array_init+0x4e>
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLED->ui32Polarity )
    dbc4:	6862      	ldr	r2, [r4, #4]
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_TRISTATE);
    dbc6:	4618      	mov	r0, r3
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLED->ui32Polarity )
    dbc8:	0793      	lsls	r3, r2, #30
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_OUTPUT);
    dbca:	bf4c      	ite	mi
    dbcc:	f8d8 1000 	ldrmi.w	r1, [r8]
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_TRISTATE);
    dbd0:	6839      	ldrpl	r1, [r7, #0]
    dbd2:	f7fe fe6f 	bl	c8b4 <am_hal_gpio_pinconfig>
        am_hal_gpio_state_write(psLED->ui32GPIONumber, AM_HAL_GPIO_OUTPUT_TRISTATE_DISABLE);
    dbd6:	2103      	movs	r1, #3
    dbd8:	f855 0c04 	ldr.w	r0, [r5, #-4]
    dbdc:	f7fe ffe4 	bl	cba8 <am_hal_gpio_state_write>
                                AM_HAL_GPIO_OUTPUT_SET : AM_HAL_GPIO_OUTPUT_CLEAR);
    dbe0:	6861      	ldr	r1, [r4, #4]
        am_hal_gpio_state_write(psLED->ui32GPIONumber,
    dbe2:	f855 0c04 	ldr.w	r0, [r5, #-4]
    dbe6:	f001 0101 	and.w	r1, r1, #1
    dbea:	f7fe ffdd 	bl	cba8 <am_hal_gpio_state_write>
    dbee:	3408      	adds	r4, #8
    for ( i = 0; i < ui32NumLEDs; i++ )
    dbf0:	42b4      	cmp	r4, r6
    dbf2:	f105 0508 	add.w	r5, r5, #8
    dbf6:	d1e0      	bne.n	dbba <am_devices_led_array_init+0x1a>
    {
        am_devices_led_init(psLEDs + i);
    }
}
    dbf8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    dbfc:	4770      	bx	lr
    dbfe:	bf00      	nop
    dc00:	00035aec 	.word	0x00035aec
    dc04:	00035ae8 	.word	0x00035ae8

0000dc08 <am_devices_led_on>:
//
//*****************************************************************************
void
am_devices_led_on(am_devices_led_t *psLEDs, uint32_t ui32LEDNum)
{
    if ( (psLEDs == NULL)                       ||
    dc08:	b170      	cbz	r0, dc28 <am_devices_led_on+0x20>
    dc0a:	291e      	cmp	r1, #30
    dc0c:	d80c      	bhi.n	dc28 <am_devices_led_on+0x20>
         (ui32LEDNum >= MAX_LEDS)               ||
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    dc0e:	f850 3031 	ldr.w	r3, [r0, r1, lsl #3]
         (ui32LEDNum >= MAX_LEDS)               ||
    dc12:	2b31      	cmp	r3, #49	; 0x31
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    dc14:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
         (ui32LEDNum >= MAX_LEDS)               ||
    dc18:	d806      	bhi.n	dc28 <am_devices_led_on+0x20>

#if AM_APOLLO3_GPIO
    //
    // Handle Direct Drive Versus 3-State (with pull-up or no buffer).
    //
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    dc1a:	6849      	ldr	r1, [r1, #4]
    dc1c:	078a      	lsls	r2, r1, #30
    dc1e:	d404      	bmi.n	dc2a <am_devices_led_on+0x22>
    else
    {
        //
        // Turn on the output driver for the LED.
        //
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    dc20:	4618      	mov	r0, r3
    dc22:	2104      	movs	r1, #4
    dc24:	f7fe bfc0 	b.w	cba8 <am_hal_gpio_state_write>
        // Turn on the output driver for the LED.
        //
        am_hal_gpio_out_enable_bit_set(psLEDs[ui32LEDNum].ui32GPIONumber);
    }
#endif //AM_APOLLO3_GPIO
}
    dc28:	4770      	bx	lr
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    dc2a:	f001 0101 	and.w	r1, r1, #1
    dc2e:	4618      	mov	r0, r3
    dc30:	f7fe bfba 	b.w	cba8 <am_hal_gpio_state_write>

0000dc34 <am_devices_led_off>:
//
//*****************************************************************************
void
am_devices_led_off(am_devices_led_t *psLEDs, uint32_t ui32LEDNum)
{
    if ( (psLEDs == NULL)                       ||
    dc34:	b170      	cbz	r0, dc54 <am_devices_led_off+0x20>
    dc36:	291e      	cmp	r1, #30
    dc38:	d80c      	bhi.n	dc54 <am_devices_led_off+0x20>
         (ui32LEDNum >= MAX_LEDS)               ||
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    dc3a:	f850 3031 	ldr.w	r3, [r0, r1, lsl #3]
         (ui32LEDNum >= MAX_LEDS)               ||
    dc3e:	2b31      	cmp	r3, #49	; 0x31
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    dc40:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
         (ui32LEDNum >= MAX_LEDS)               ||
    dc44:	d806      	bhi.n	dc54 <am_devices_led_off+0x20>

#if AM_APOLLO3_GPIO
    //
    // Handle Direct Drive Versus 3-State (with pull-up or no buffer).
    //
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    dc46:	6849      	ldr	r1, [r1, #4]
    dc48:	078a      	lsls	r2, r1, #30
    dc4a:	d404      	bmi.n	dc56 <am_devices_led_off+0x22>
    else
    {
        //
        // Turn off the output driver for the LED.
        //
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    dc4c:	4618      	mov	r0, r3
    dc4e:	2103      	movs	r1, #3
    dc50:	f7fe bfaa 	b.w	cba8 <am_hal_gpio_state_write>
        // Turn off the output driver for the LED.
        //
        am_hal_gpio_out_enable_bit_clear(psLEDs[ui32LEDNum].ui32GPIONumber);
    }
#endif
}
    dc54:	4770      	bx	lr
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    dc56:	43c9      	mvns	r1, r1
    dc58:	f001 0101 	and.w	r1, r1, #1
    dc5c:	4618      	mov	r0, r3
    dc5e:	f7fe bfa3 	b.w	cba8 <am_hal_gpio_state_write>
    dc62:	bf00      	nop

0000dc64 <am_devices_led_toggle>:
//
//*****************************************************************************
void
am_devices_led_toggle(am_devices_led_t *psLEDs, uint32_t ui32LEDNum)
{
    if ( (psLEDs == NULL)                       ||
    dc64:	b1e0      	cbz	r0, dca0 <am_devices_led_toggle+0x3c>
    dc66:	291e      	cmp	r1, #30
    dc68:	d81a      	bhi.n	dca0 <am_devices_led_toggle+0x3c>
         (ui32LEDNum >= MAX_LEDS)               ||
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    dc6a:	f850 3031 	ldr.w	r3, [r0, r1, lsl #3]
         (ui32LEDNum >= MAX_LEDS)               ||
    dc6e:	2b31      	cmp	r3, #49	; 0x31
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    dc70:	eb00 02c1 	add.w	r2, r0, r1, lsl #3
         (ui32LEDNum >= MAX_LEDS)               ||
    dc74:	d814      	bhi.n	dca0 <am_devices_led_toggle+0x3c>
{
    dc76:	b530      	push	{r4, r5, lr}

#if AM_APOLLO3_GPIO
    //
    // Handle Direct Drive Versus 3-State (with pull-up or no buffer).
    //
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    dc78:	6852      	ldr	r2, [r2, #4]
    dc7a:	4604      	mov	r4, r0
    {
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    dc7c:	4618      	mov	r0, r3
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    dc7e:	0793      	lsls	r3, r2, #30
{
    dc80:	b083      	sub	sp, #12
    dc82:	460d      	mov	r5, r1
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    dc84:	d40d      	bmi.n	dca2 <am_devices_led_toggle+0x3e>
        uint32_t ui32Ret, ui32Value;

        //
        // Check to see if the LED pin is enabled.
        //
        ui32Ret = am_hal_gpio_state_read(psLEDs[ui32LEDNum].ui32GPIONumber,
    dc86:	aa01      	add	r2, sp, #4
    dc88:	2102      	movs	r1, #2
    dc8a:	f7fe ff55 	bl	cb38 <am_hal_gpio_state_read>
                                         AM_HAL_GPIO_ENABLE_READ, &ui32Value);

        if ( ui32Ret == AM_HAL_STATUS_SUCCESS )
    dc8e:	b958      	cbnz	r0, dca8 <am_devices_led_toggle+0x44>
        {
            if ( ui32Value )
    dc90:	9b01      	ldr	r3, [sp, #4]
    dc92:	f854 0035 	ldr.w	r0, [r4, r5, lsl #3]
    dc96:	b14b      	cbz	r3, dcac <am_devices_led_toggle+0x48>
            {
                //
                // If it was enabled, turn if off.
                //
                am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    dc98:	2103      	movs	r1, #3
    dc9a:	f7fe ff85 	bl	cba8 <am_hal_gpio_state_write>
    dc9e:	e003      	b.n	dca8 <am_devices_led_toggle+0x44>
    dca0:	4770      	bx	lr
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    dca2:	2102      	movs	r1, #2
    dca4:	f7fe ff80 	bl	cba8 <am_hal_gpio_state_write>
            //
            am_hal_gpio_out_enable_bit_set(psLEDs[ui32LEDNum].ui32GPIONumber);
        }
    }
#endif
}
    dca8:	b003      	add	sp, #12
    dcaa:	bd30      	pop	{r4, r5, pc}
                am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    dcac:	2104      	movs	r1, #4
    dcae:	f7fe ff7b 	bl	cba8 <am_hal_gpio_state_write>
    dcb2:	e7f9      	b.n	dca8 <am_devices_led_toggle+0x44>

0000dcb4 <NMI_Handler>:
#if AM_CMSIS_REGS
NMI_Handler(void)
#else // AM_CMSIS_REGS
am_nmi_isr(void)
#endif // AM_CMSIS_REGS
{
    dcb4:	e7fe      	b.n	dcb4 <NMI_Handler>
    dcb6:	bf00      	nop

0000dcb8 <DebugMon_Handler>:
// for examination by a debugger.
//
//*****************************************************************************
void
am_default_isr(void)
{
    dcb8:	e7fe      	b.n	dcb8 <DebugMon_Handler>
    dcba:	bf00      	nop

0000dcbc <Reset_Handler>:
    __asm("    ldr    r0, =0xE000ED08\n"
    dcbc:	4811      	ldr	r0, [pc, #68]	; (dd04 <zero_loop+0x12>)
    dcbe:	4912      	ldr	r1, [pc, #72]	; (dd08 <zero_loop+0x16>)
    dcc0:	6001      	str	r1, [r0, #0]
    __asm("    ldr    sp, [r1]");
    dcc2:	f8d1 d000 	ldr.w	sp, [r1]
    __asm("ldr  r0, =0xE000ED88\n"
    dcc6:	4811      	ldr	r0, [pc, #68]	; (dd0c <zero_loop+0x1a>)
    dcc8:	6801      	ldr	r1, [r0, #0]
    dcca:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    dcce:	6001      	str	r1, [r0, #0]
    dcd0:	f3bf 8f4f 	dsb	sy
    dcd4:	f3bf 8f6f 	isb	sy
    __asm("    ldr     r0, =_init_data\n"
    dcd8:	480d      	ldr	r0, [pc, #52]	; (dd10 <zero_loop+0x1e>)
    dcda:	490e      	ldr	r1, [pc, #56]	; (dd14 <zero_loop+0x22>)
    dcdc:	4a0e      	ldr	r2, [pc, #56]	; (dd18 <zero_loop+0x26>)

0000dcde <copy_loop>:
    dcde:	f850 3b04 	ldr.w	r3, [r0], #4
    dce2:	f841 3b04 	str.w	r3, [r1], #4
    dce6:	4291      	cmp	r1, r2
    dce8:	dbf9      	blt.n	dcde <copy_loop>
    __asm("    ldr     r0, =_sbss\n"
    dcea:	480c      	ldr	r0, [pc, #48]	; (dd1c <zero_loop+0x2a>)
    dcec:	490c      	ldr	r1, [pc, #48]	; (dd20 <zero_loop+0x2e>)
    dcee:	f04f 0200 	mov.w	r2, #0

0000dcf2 <zero_loop>:
    dcf2:	4288      	cmp	r0, r1
    dcf4:	bfb8      	it	lt
    dcf6:	f840 2b04 	strlt.w	r2, [r0], #4
    dcfa:	dbfa      	blt.n	dcf2 <zero_loop>
    main();
    dcfc:	f7fe fb3c 	bl	c378 <main>
    __asm("    bkpt     ");
    dd00:	be00      	bkpt	0x0000
    dd02:	0000      	.short	0x0000
    dd04:	e000ed08 	.word	0xe000ed08
    dd08:	0000c000 	.word	0x0000c000
    dd0c:	e000ed88 	.word	0xe000ed88
    dd10:	0003b874 	.word	0x0003b874
    dd14:	10001000 	.word	0x10001000
    dd18:	10001890 	.word	0x10001890
    dd1c:	10001890 	.word	0x10001890
    dd20:	100114e0 	.word	0x100114e0

0000dd24 <DebugLog>:

//*****************************************************************************
// The stdio function for debug usage
//*****************************************************************************

void DebugLog(const char* s) { am_util_stdio_printf("%s", s); }
    dd24:	4601      	mov	r1, r0
    dd26:	4801      	ldr	r0, [pc, #4]	; (dd2c <DebugLog+0x8>)
    dd28:	f7ff bf20 	b.w	db6c <am_util_stdio_printf>
    dd2c:	00035c54 	.word	0x00035c54

0000dd30 <timerA0_init>:
// Function to initialize Timer A0 to interrupt every 1/4 second.
//
//*****************************************************************************
void
timerA0_init(void)
{
    dd30:	b508      	push	{r3, lr}
    // Enable the LFRC.
    //
#if USE_XTAL
    am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_XTAL_START, 0);
#else
    am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_LFRC_START, 0);
    dd32:	2100      	movs	r1, #0
    dd34:	2002      	movs	r0, #2
    dd36:	f025 faab 	bl	33290 <am_hal_clkgen_control>
#endif

    //
    // Set up timer A0.
    //
    am_hal_ctimer_clear(0, AM_HAL_CTIMER_TIMERA);
    dd3a:	f64f 71ff 	movw	r1, #65535	; 0xffff
    dd3e:	2000      	movs	r0, #0
    dd40:	f025 fb52 	bl	333e8 <am_hal_ctimer_clear>
    am_hal_ctimer_config(0, &g_sTimer0);
    dd44:	4907      	ldr	r1, [pc, #28]	; (dd64 <timerA0_init+0x34>)
    dd46:	2000      	movs	r0, #0
    dd48:	f025 fb1c 	bl	33384 <am_hal_ctimer_config>
    //
    ui32Period = 32;
#if USE_XTAL
    ui32Period *= 8;
#endif
    am_hal_ctimer_period_set(0, AM_HAL_CTIMER_TIMERA, ui32Period,
    dd4c:	2310      	movs	r3, #16
    dd4e:	2000      	movs	r0, #0
    dd50:	2220      	movs	r2, #32
    dd52:	f64f 71ff 	movw	r1, #65535	; 0xffff
    dd56:	f025 fb5b 	bl	33410 <am_hal_ctimer_period_set>
                             (ui32Period >> 1));

    //
    // Clear the timer Interrupt
    //
    am_hal_ctimer_int_clear(AM_HAL_CTIMER_INT_TIMERA0);
    dd5a:	2001      	movs	r0, #1
}
    dd5c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    am_hal_ctimer_int_clear(AM_HAL_CTIMER_INT_TIMERA0);
    dd60:	f025 bbc0 	b.w	334e4 <am_hal_ctimer_int_clear>
    dd64:	10001000 	.word	0x10001000

0000dd68 <am_ctimer_isr>:
am_ctimer_isr(void)
{
    //
    // Increment count and set limit based on the number of LEDs available.
    //
    g_ui32TimerCount++;
    dd68:	4a03      	ldr	r2, [pc, #12]	; (dd78 <am_ctimer_isr+0x10>)
    dd6a:	6813      	ldr	r3, [r2, #0]
//    }

    //
    // Clear TimerA0 Interrupt (write to clear).
    //
    am_hal_ctimer_int_clear(AM_HAL_CTIMER_INT_TIMERA0);
    dd6c:	2001      	movs	r0, #1
    g_ui32TimerCount++;
    dd6e:	4403      	add	r3, r0
    dd70:	6013      	str	r3, [r2, #0]
    am_hal_ctimer_int_clear(AM_HAL_CTIMER_INT_TIMERA0);
    dd72:	f025 bbb7 	b.w	334e4 <am_hal_ctimer_int_clear>
    dd76:	bf00      	nop
    dd78:	10001994 	.word	0x10001994

0000dd7c <am_gpio_isr>:
//*****************************************************************************
// GPIO ISR
// Will enable the PDM, set number of frames transferred to 0, and turn on LED
//*****************************************************************************
void am_gpio_isr(void) 
{
    dd7c:	b510      	push	{r4, lr}
    //
    // Delay for debounce.
    //
    am_util_delay_ms(200);
    dd7e:	20c8      	movs	r0, #200	; 0xc8
    dd80:	f7fe ffa0 	bl	ccc4 <am_util_delay_ms>
  
    //
    // Clear the GPIO Interrupt (write to clear).
    //
    am_hal_gpio_interrupt_clear(AM_HAL_GPIO_BIT(AM_BSP_GPIO_BUTTON0));
    dd84:	f44f 3080 	mov.w	r0, #65536	; 0x10000
    dd88:	2100      	movs	r1, #0
    dd8a:	f7fe ff79 	bl	cc80 <am_hal_gpio_interrupt_clear>
    if(g_audioRunningFlag == 0)
    dd8e:	4a0b      	ldr	r2, [pc, #44]	; (ddbc <am_gpio_isr+0x40>)
    dd90:	7813      	ldrb	r3, [r2, #0]
    dd92:	b103      	cbz	r3, dd96 <am_gpio_isr+0x1a>
        am_hal_pdm_enable(PDMHandle);
    } 
    //
    // Turn on LED 0
    //
}
    dd94:	bd10      	pop	{r4, pc}
        am_hal_pdm_fifo_flush(PDMHandle);
    dd96:	4c0a      	ldr	r4, [pc, #40]	; (ddc0 <am_gpio_isr+0x44>)
        am_devices_led_on(am_bsp_psLEDs, 0);
    dd98:	480a      	ldr	r0, [pc, #40]	; (ddc4 <am_gpio_isr+0x48>)
    dd9a:	f003 01ff 	and.w	r1, r3, #255	; 0xff
        g_audioRunningFlag = 1;
    dd9e:	2301      	movs	r3, #1
    dda0:	7013      	strb	r3, [r2, #0]
        am_devices_led_on(am_bsp_psLEDs, 0);
    dda2:	f7ff ff31 	bl	dc08 <am_devices_led_on>
        am_hal_pdm_fifo_flush(PDMHandle);
    dda6:	6820      	ldr	r0, [r4, #0]
    dda8:	f7fe fd30 	bl	c80c <am_hal_pdm_fifo_flush>
        pdm_data_get();
    ddac:	f000 f83a 	bl	de24 <pdm_data_get>
        am_hal_pdm_enable(PDMHandle);
    ddb0:	6820      	ldr	r0, [r4, #0]
}
    ddb2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        am_hal_pdm_enable(PDMHandle);
    ddb6:	f7fe bcaf 	b.w	c718 <am_hal_pdm_enable>
    ddba:	bf00      	nop
    ddbc:	10001998 	.word	0x10001998
    ddc0:	100113ec 	.word	0x100113ec
    ddc4:	1000102c 	.word	0x1000102c

0000ddc8 <pdm_init>:

//*****************************************************************************
// PDM initialization.
//*****************************************************************************
void pdm_init(void) 
{
    ddc8:	b538      	push	{r3, r4, r5, lr}
  //
  // Initialize, power-up, and configure the PDM.
  //
  am_hal_pdm_initialize(0, &PDMHandle);
    ddca:	4c13      	ldr	r4, [pc, #76]	; (de18 <pdm_init+0x50>)
    ddcc:	2000      	movs	r0, #0
    ddce:	4621      	mov	r1, r4
    ddd0:	f7fe fbba 	bl	c548 <am_hal_pdm_initialize>
  am_hal_pdm_power_control(PDMHandle, AM_HAL_PDM_POWER_ON, false);
    ddd4:	2200      	movs	r2, #0
    ddd6:	4611      	mov	r1, r2
    ddd8:	6820      	ldr	r0, [r4, #0]
    ddda:	f7fe fbd7 	bl	c58c <am_hal_pdm_power_control>
  am_hal_pdm_configure(PDMHandle, &g_sPdmConfig);
    ddde:	490f      	ldr	r1, [pc, #60]	; (de1c <pdm_init+0x54>)
    dde0:	6820      	ldr	r0, [r4, #0]
    dde2:	f7fe fc13 	bl	c60c <am_hal_pdm_configure>
  am_hal_pdm_enable(PDMHandle);
    dde6:	6820      	ldr	r0, [r4, #0]
    dde8:	f7fe fc96 	bl	c718 <am_hal_pdm_enable>

  //
  // Configure the necessary pins.
  //
  am_hal_gpio_pincfg_t sPinCfg = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    ddec:	2500      	movs	r5, #0

  // ARPIT 181019
  // sPinCfg.uFuncSel = AM_HAL_PIN_10_PDMCLK;
  // am_hal_gpio_pinconfig(10, sPinCfg);
  sPinCfg.uFuncSel = AM_HAL_PIN_12_PDMCLK;
    ddee:	2305      	movs	r3, #5
    ddf0:	f363 0502 	bfi	r5, r3, #0, #3
  am_hal_gpio_pinconfig(12, sPinCfg);
    ddf4:	4629      	mov	r1, r5
    ddf6:	200c      	movs	r0, #12
    ddf8:	f7fe fd5c 	bl	c8b4 <am_hal_gpio_pinconfig>

  sPinCfg.uFuncSel = AM_HAL_PIN_11_PDMDATA;
  am_hal_gpio_pinconfig(11, sPinCfg);
    ddfc:	f045 0107 	orr.w	r1, r5, #7
    de00:	200b      	movs	r0, #11
    de02:	f7fe fd57 	bl	c8b4 <am_hal_gpio_pinconfig>

  //
  // Configure and enable PDM interrupts (set up to trigger on DMA
  // completion).
  //
  am_hal_pdm_interrupt_enable(PDMHandle,
    de06:	6820      	ldr	r0, [r4, #0]
    de08:	211e      	movs	r1, #30
    de0a:	f7fe fd11 	bl	c830 <am_hal_pdm_interrupt_enable>
    de0e:	4b04      	ldr	r3, [pc, #16]	; (de20 <pdm_init+0x58>)
    de10:	f44f 2200 	mov.w	r2, #524288	; 0x80000
    de14:	601a      	str	r2, [r3, #0]
#if AM_CMSIS_REGS
  NVIC_EnableIRQ(PDM_IRQn);
#else
  am_hal_interrupt_enable(AM_HAL_INTERRUPT_PDM);
#endif
}
    de16:	bd38      	pop	{r3, r4, r5, pc}
    de18:	100113ec 	.word	0x100113ec
    de1c:	1000100c 	.word	0x1000100c
    de20:	e000e100 	.word	0xe000e100

0000de24 <pdm_data_get>:
//
// Start a transaction to get some number of bytes from the PDM interface.
//
//*****************************************************************************
void pdm_data_get(void) 
{
    de24:	b500      	push	{lr}
  //
  // Configure DMA and target address.
  //
  am_hal_pdm_transfer_t sTransfer;
  sTransfer.ui32TargetAddr =
      (uint32_t)(&captured_data[FRAME_SIZE * g_numFramesCaptured]);
    de26:	4b0a      	ldr	r3, [pc, #40]	; (de50 <pdm_data_get+0x2c>)
    de28:	4a0a      	ldr	r2, [pc, #40]	; (de54 <pdm_data_get+0x30>)
    de2a:	881b      	ldrh	r3, [r3, #0]
  sTransfer.ui32TotalCount = 4 * FRAME_SIZE;  // Each sample is 2 bytes

  //
  // Start the data transfer.
  //
  am_hal_pdm_dma_start(PDMHandle, &sTransfer);
    de2c:	490a      	ldr	r1, [pc, #40]	; (de58 <pdm_data_get+0x34>)
      (uint32_t)(&captured_data[FRAME_SIZE * g_numFramesCaptured]);
    de2e:	b21b      	sxth	r3, r3
{
    de30:	b083      	sub	sp, #12
      (uint32_t)(&captured_data[FRAME_SIZE * g_numFramesCaptured]);
    de32:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    de36:	eb02 2303 	add.w	r3, r2, r3, lsl #8
  sTransfer.ui32TargetAddr =
    de3a:	9300      	str	r3, [sp, #0]
  am_hal_pdm_dma_start(PDMHandle, &sTransfer);
    de3c:	6808      	ldr	r0, [r1, #0]
  sTransfer.ui32TotalCount = 4 * FRAME_SIZE;  // Each sample is 2 bytes
    de3e:	f44f 63a0 	mov.w	r3, #1280	; 0x500
  am_hal_pdm_dma_start(PDMHandle, &sTransfer);
    de42:	4669      	mov	r1, sp
  sTransfer.ui32TotalCount = 4 * FRAME_SIZE;  // Each sample is 2 bytes
    de44:	9301      	str	r3, [sp, #4]
  am_hal_pdm_dma_start(PDMHandle, &sTransfer);
    de46:	f7fe fc97 	bl	c778 <am_hal_pdm_dma_start>
}
    de4a:	b003      	add	sp, #12
    de4c:	f85d fb04 	ldr.w	pc, [sp], #4
    de50:	1000199a 	.word	0x1000199a
    de54:	100019ec 	.word	0x100019ec
    de58:	100113ec 	.word	0x100113ec

0000de5c <am_pdm_isr>:
//
// PDM interrupt handler.
//
//*****************************************************************************
void am_pdm_isr(void) 
{
    de5c:	b510      	push	{r4, lr}
  uint32_t ui32Status;
  //
  // Read the interrupt status.
  //
  am_hal_pdm_interrupt_status_get(PDMHandle, &ui32Status, true);
    de5e:	4c09      	ldr	r4, [pc, #36]	; (de84 <am_pdm_isr+0x28>)
{
    de60:	b082      	sub	sp, #8
  am_hal_pdm_interrupt_status_get(PDMHandle, &ui32Status, true);
    de62:	2201      	movs	r2, #1
    de64:	a901      	add	r1, sp, #4
    de66:	6820      	ldr	r0, [r4, #0]
    de68:	f7fe fd06 	bl	c878 <am_hal_pdm_interrupt_status_get>
  am_hal_pdm_interrupt_clear(PDMHandle, ui32Status);
    de6c:	6820      	ldr	r0, [r4, #0]
    de6e:	9901      	ldr	r1, [sp, #4]
    de70:	f7fe fcf2 	bl	c858 <am_hal_pdm_interrupt_clear>

  //
  // Once our DMA transaction completes, send a flag to the main routine
  //
  if (ui32Status & AM_HAL_PDM_INT_DCMP) g_bPDMDataReady = true;
    de74:	9b01      	ldr	r3, [sp, #4]
    de76:	071b      	lsls	r3, r3, #28
    de78:	d502      	bpl.n	de80 <am_pdm_isr+0x24>
    de7a:	4b03      	ldr	r3, [pc, #12]	; (de88 <am_pdm_isr+0x2c>)
    de7c:	2201      	movs	r2, #1
    de7e:	701a      	strb	r2, [r3, #0]
}
    de80:	b002      	add	sp, #8
    de82:	bd10      	pop	{r4, pc}
    de84:	100113ec 	.word	0x100113ec
    de88:	10001999 	.word	0x10001999

0000de8c <silk_encode_signs>:
    opus_int                    length,                             /* I    length of input                             */
    const opus_int              signalType,                         /* I    Signal type                                 */
    const opus_int              quantOffsetType,                    /* I    Quantization offset type                    */
    const opus_int              sum_pulses[ MAX_NB_SHELL_BLOCKS ]   /* I    Sum of absolute pulses per block            */
)
{
    de8c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    de90:	b082      	sub	sp, #8

    icdf[ 1 ] = 0;
    q_ptr = pulses;
    i = silk_SMULBB( 7, silk_ADD_LSHIFT( quantOffsetType, signalType, 1 ) );
    icdf_ptr = &silk_sign_iCDF[ i ];
    length = silk_RSHIFT( length + SHELL_CODEC_FRAME_LENGTH/2, LOG2_SHELL_CODEC_FRAME_LENGTH );
    de92:	f102 0708 	add.w	r7, r2, #8
{
    de96:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    icdf[ 1 ] = 0;
    de98:	2200      	movs	r2, #0
    length = silk_RSHIFT( length + SHELL_CODEC_FRAME_LENGTH/2, LOG2_SHELL_CODEC_FRAME_LENGTH );
    de9a:	113f      	asrs	r7, r7, #4
    for( i = 0; i < length; i++ ) {
    de9c:	4297      	cmp	r7, r2
    i = silk_SMULBB( 7, silk_ADD_LSHIFT( quantOffsetType, signalType, 1 ) );
    de9e:	eb04 0343 	add.w	r3, r4, r3, lsl #1
    icdf[ 1 ] = 0;
    dea2:	f88d 2005 	strb.w	r2, [sp, #5]
    for( i = 0; i < length; i++ ) {
    dea6:	f340 811d 	ble.w	e0e4 <silk_encode_signs+0x258>
    deaa:	fa0f f883 	sxth.w	r8, r3
    deae:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
        p = sum_pulses[ i ];
        if( p > 0 ) {
            icdf[ 0 ] = icdf_ptr[ silk_min( p & 0x1F, 6 ) ];
    deb0:	f8df a248 	ldr.w	sl, [pc, #584]	; e0fc <silk_encode_signs+0x270>
    deb4:	1f1d      	subs	r5, r3, #4
    deb6:	4606      	mov	r6, r0
    deb8:	f101 0410 	add.w	r4, r1, #16
    debc:	eb05 0787 	add.w	r7, r5, r7, lsl #2
    dec0:	f04f 0907 	mov.w	r9, #7
    dec4:	e046      	b.n	df54 <silk_encode_signs+0xc8>
            for( j = 0; j < SHELL_CODEC_FRAME_LENGTH; j++ ) {
                if( q_ptr[ j ] != 0 ) {
    dec6:	f914 1c0e 	ldrsb.w	r1, [r4, #-14]
    deca:	2900      	cmp	r1, #0
    decc:	d165      	bne.n	df9a <silk_encode_signs+0x10e>
    dece:	f914 1c0d 	ldrsb.w	r1, [r4, #-13]
    ded2:	2900      	cmp	r1, #0
    ded4:	d16c      	bne.n	dfb0 <silk_encode_signs+0x124>
    ded6:	f914 1c0c 	ldrsb.w	r1, [r4, #-12]
    deda:	2900      	cmp	r1, #0
    dedc:	d173      	bne.n	dfc6 <silk_encode_signs+0x13a>
    dede:	f914 1c0b 	ldrsb.w	r1, [r4, #-11]
    dee2:	2900      	cmp	r1, #0
    dee4:	d17a      	bne.n	dfdc <silk_encode_signs+0x150>
    dee6:	f914 1c0a 	ldrsb.w	r1, [r4, #-10]
    deea:	2900      	cmp	r1, #0
    deec:	f040 8082 	bne.w	dff4 <silk_encode_signs+0x168>
    def0:	f914 1c09 	ldrsb.w	r1, [r4, #-9]
    def4:	2900      	cmp	r1, #0
    def6:	f040 8089 	bne.w	e00c <silk_encode_signs+0x180>
    defa:	f914 1c08 	ldrsb.w	r1, [r4, #-8]
    defe:	2900      	cmp	r1, #0
    df00:	f040 8090 	bne.w	e024 <silk_encode_signs+0x198>
    df04:	f914 1c07 	ldrsb.w	r1, [r4, #-7]
    df08:	2900      	cmp	r1, #0
    df0a:	f040 8097 	bne.w	e03c <silk_encode_signs+0x1b0>
    df0e:	f914 1c06 	ldrsb.w	r1, [r4, #-6]
    df12:	2900      	cmp	r1, #0
    df14:	f040 809e 	bne.w	e054 <silk_encode_signs+0x1c8>
    df18:	f914 1c05 	ldrsb.w	r1, [r4, #-5]
    df1c:	2900      	cmp	r1, #0
    df1e:	f040 80a5 	bne.w	e06c <silk_encode_signs+0x1e0>
    df22:	f914 1c04 	ldrsb.w	r1, [r4, #-4]
    df26:	2900      	cmp	r1, #0
    df28:	f040 80ac 	bne.w	e084 <silk_encode_signs+0x1f8>
    df2c:	f914 1c03 	ldrsb.w	r1, [r4, #-3]
    df30:	2900      	cmp	r1, #0
    df32:	f040 80b3 	bne.w	e09c <silk_encode_signs+0x210>
    df36:	f914 1c02 	ldrsb.w	r1, [r4, #-2]
    df3a:	2900      	cmp	r1, #0
    df3c:	f040 80ba 	bne.w	e0b4 <silk_encode_signs+0x228>
    df40:	f914 1c01 	ldrsb.w	r1, [r4, #-1]
    df44:	2900      	cmp	r1, #0
    df46:	f040 80c1 	bne.w	e0cc <silk_encode_signs+0x240>
    for( i = 0; i < length; i++ ) {
    df4a:	42af      	cmp	r7, r5
    df4c:	f104 0410 	add.w	r4, r4, #16
    df50:	f000 80c8 	beq.w	e0e4 <silk_encode_signs+0x258>
        p = sum_pulses[ i ];
    df54:	f855 3f04 	ldr.w	r3, [r5, #4]!
        if( p > 0 ) {
    df58:	2b00      	cmp	r3, #0
    df5a:	ddf6      	ble.n	df4a <silk_encode_signs+0xbe>
            icdf[ 0 ] = icdf_ptr[ silk_min( p & 0x1F, 6 ) ];
    df5c:	f003 031f 	and.w	r3, r3, #31
    df60:	2b05      	cmp	r3, #5
    df62:	bfc8      	it	gt
    df64:	2306      	movgt	r3, #6
    df66:	fb18 3309 	smlabb	r3, r8, r9, r3
                if( q_ptr[ j ] != 0 ) {
    df6a:	f914 1c10 	ldrsb.w	r1, [r4, #-16]
            icdf[ 0 ] = icdf_ptr[ silk_min( p & 0x1F, 6 ) ];
    df6e:	f813 300a 	ldrb.w	r3, [r3, sl]
    df72:	f88d 3004 	strb.w	r3, [sp, #4]
                if( q_ptr[ j ] != 0 ) {
    df76:	2900      	cmp	r1, #0
    df78:	f040 80b7 	bne.w	e0ea <silk_encode_signs+0x25e>
    df7c:	f914 1c0f 	ldrsb.w	r1, [r4, #-15]
    df80:	2900      	cmp	r1, #0
    df82:	d0a0      	beq.n	dec6 <silk_encode_signs+0x3a>
                    ec_enc_icdf( psRangeEnc, silk_enc_map( q_ptr[ j ]), icdf, 8 );
    df84:	13c9      	asrs	r1, r1, #15
    df86:	3101      	adds	r1, #1
    df88:	2308      	movs	r3, #8
    df8a:	aa01      	add	r2, sp, #4
    df8c:	4630      	mov	r0, r6
    df8e:	f01b ff77 	bl	29e80 <ec_enc_icdf>
                if( q_ptr[ j ] != 0 ) {
    df92:	f914 1c0e 	ldrsb.w	r1, [r4, #-14]
    df96:	2900      	cmp	r1, #0
    df98:	d099      	beq.n	dece <silk_encode_signs+0x42>
                    ec_enc_icdf( psRangeEnc, silk_enc_map( q_ptr[ j ]), icdf, 8 );
    df9a:	13c9      	asrs	r1, r1, #15
    df9c:	3101      	adds	r1, #1
    df9e:	2308      	movs	r3, #8
    dfa0:	aa01      	add	r2, sp, #4
    dfa2:	4630      	mov	r0, r6
    dfa4:	f01b ff6c 	bl	29e80 <ec_enc_icdf>
                if( q_ptr[ j ] != 0 ) {
    dfa8:	f914 1c0d 	ldrsb.w	r1, [r4, #-13]
    dfac:	2900      	cmp	r1, #0
    dfae:	d092      	beq.n	ded6 <silk_encode_signs+0x4a>
                    ec_enc_icdf( psRangeEnc, silk_enc_map( q_ptr[ j ]), icdf, 8 );
    dfb0:	13c9      	asrs	r1, r1, #15
    dfb2:	3101      	adds	r1, #1
    dfb4:	2308      	movs	r3, #8
    dfb6:	aa01      	add	r2, sp, #4
    dfb8:	4630      	mov	r0, r6
    dfba:	f01b ff61 	bl	29e80 <ec_enc_icdf>
                if( q_ptr[ j ] != 0 ) {
    dfbe:	f914 1c0c 	ldrsb.w	r1, [r4, #-12]
    dfc2:	2900      	cmp	r1, #0
    dfc4:	d08b      	beq.n	dede <silk_encode_signs+0x52>
                    ec_enc_icdf( psRangeEnc, silk_enc_map( q_ptr[ j ]), icdf, 8 );
    dfc6:	13c9      	asrs	r1, r1, #15
    dfc8:	3101      	adds	r1, #1
    dfca:	2308      	movs	r3, #8
    dfcc:	aa01      	add	r2, sp, #4
    dfce:	4630      	mov	r0, r6
    dfd0:	f01b ff56 	bl	29e80 <ec_enc_icdf>
                if( q_ptr[ j ] != 0 ) {
    dfd4:	f914 1c0b 	ldrsb.w	r1, [r4, #-11]
    dfd8:	2900      	cmp	r1, #0
    dfda:	d084      	beq.n	dee6 <silk_encode_signs+0x5a>
                    ec_enc_icdf( psRangeEnc, silk_enc_map( q_ptr[ j ]), icdf, 8 );
    dfdc:	13c9      	asrs	r1, r1, #15
    dfde:	3101      	adds	r1, #1
    dfe0:	2308      	movs	r3, #8
    dfe2:	aa01      	add	r2, sp, #4
    dfe4:	4630      	mov	r0, r6
    dfe6:	f01b ff4b 	bl	29e80 <ec_enc_icdf>
                if( q_ptr[ j ] != 0 ) {
    dfea:	f914 1c0a 	ldrsb.w	r1, [r4, #-10]
    dfee:	2900      	cmp	r1, #0
    dff0:	f43f af7e 	beq.w	def0 <silk_encode_signs+0x64>
                    ec_enc_icdf( psRangeEnc, silk_enc_map( q_ptr[ j ]), icdf, 8 );
    dff4:	13c9      	asrs	r1, r1, #15
    dff6:	3101      	adds	r1, #1
    dff8:	2308      	movs	r3, #8
    dffa:	aa01      	add	r2, sp, #4
    dffc:	4630      	mov	r0, r6
    dffe:	f01b ff3f 	bl	29e80 <ec_enc_icdf>
                if( q_ptr[ j ] != 0 ) {
    e002:	f914 1c09 	ldrsb.w	r1, [r4, #-9]
    e006:	2900      	cmp	r1, #0
    e008:	f43f af77 	beq.w	defa <silk_encode_signs+0x6e>
                    ec_enc_icdf( psRangeEnc, silk_enc_map( q_ptr[ j ]), icdf, 8 );
    e00c:	13c9      	asrs	r1, r1, #15
    e00e:	3101      	adds	r1, #1
    e010:	2308      	movs	r3, #8
    e012:	aa01      	add	r2, sp, #4
    e014:	4630      	mov	r0, r6
    e016:	f01b ff33 	bl	29e80 <ec_enc_icdf>
                if( q_ptr[ j ] != 0 ) {
    e01a:	f914 1c08 	ldrsb.w	r1, [r4, #-8]
    e01e:	2900      	cmp	r1, #0
    e020:	f43f af70 	beq.w	df04 <silk_encode_signs+0x78>
                    ec_enc_icdf( psRangeEnc, silk_enc_map( q_ptr[ j ]), icdf, 8 );
    e024:	13c9      	asrs	r1, r1, #15
    e026:	3101      	adds	r1, #1
    e028:	2308      	movs	r3, #8
    e02a:	aa01      	add	r2, sp, #4
    e02c:	4630      	mov	r0, r6
    e02e:	f01b ff27 	bl	29e80 <ec_enc_icdf>
                if( q_ptr[ j ] != 0 ) {
    e032:	f914 1c07 	ldrsb.w	r1, [r4, #-7]
    e036:	2900      	cmp	r1, #0
    e038:	f43f af69 	beq.w	df0e <silk_encode_signs+0x82>
                    ec_enc_icdf( psRangeEnc, silk_enc_map( q_ptr[ j ]), icdf, 8 );
    e03c:	13c9      	asrs	r1, r1, #15
    e03e:	3101      	adds	r1, #1
    e040:	2308      	movs	r3, #8
    e042:	aa01      	add	r2, sp, #4
    e044:	4630      	mov	r0, r6
    e046:	f01b ff1b 	bl	29e80 <ec_enc_icdf>
                if( q_ptr[ j ] != 0 ) {
    e04a:	f914 1c06 	ldrsb.w	r1, [r4, #-6]
    e04e:	2900      	cmp	r1, #0
    e050:	f43f af62 	beq.w	df18 <silk_encode_signs+0x8c>
                    ec_enc_icdf( psRangeEnc, silk_enc_map( q_ptr[ j ]), icdf, 8 );
    e054:	13c9      	asrs	r1, r1, #15
    e056:	3101      	adds	r1, #1
    e058:	2308      	movs	r3, #8
    e05a:	aa01      	add	r2, sp, #4
    e05c:	4630      	mov	r0, r6
    e05e:	f01b ff0f 	bl	29e80 <ec_enc_icdf>
                if( q_ptr[ j ] != 0 ) {
    e062:	f914 1c05 	ldrsb.w	r1, [r4, #-5]
    e066:	2900      	cmp	r1, #0
    e068:	f43f af5b 	beq.w	df22 <silk_encode_signs+0x96>
                    ec_enc_icdf( psRangeEnc, silk_enc_map( q_ptr[ j ]), icdf, 8 );
    e06c:	13c9      	asrs	r1, r1, #15
    e06e:	3101      	adds	r1, #1
    e070:	2308      	movs	r3, #8
    e072:	aa01      	add	r2, sp, #4
    e074:	4630      	mov	r0, r6
    e076:	f01b ff03 	bl	29e80 <ec_enc_icdf>
                if( q_ptr[ j ] != 0 ) {
    e07a:	f914 1c04 	ldrsb.w	r1, [r4, #-4]
    e07e:	2900      	cmp	r1, #0
    e080:	f43f af54 	beq.w	df2c <silk_encode_signs+0xa0>
                    ec_enc_icdf( psRangeEnc, silk_enc_map( q_ptr[ j ]), icdf, 8 );
    e084:	13c9      	asrs	r1, r1, #15
    e086:	3101      	adds	r1, #1
    e088:	2308      	movs	r3, #8
    e08a:	aa01      	add	r2, sp, #4
    e08c:	4630      	mov	r0, r6
    e08e:	f01b fef7 	bl	29e80 <ec_enc_icdf>
                if( q_ptr[ j ] != 0 ) {
    e092:	f914 1c03 	ldrsb.w	r1, [r4, #-3]
    e096:	2900      	cmp	r1, #0
    e098:	f43f af4d 	beq.w	df36 <silk_encode_signs+0xaa>
                    ec_enc_icdf( psRangeEnc, silk_enc_map( q_ptr[ j ]), icdf, 8 );
    e09c:	13c9      	asrs	r1, r1, #15
    e09e:	3101      	adds	r1, #1
    e0a0:	2308      	movs	r3, #8
    e0a2:	aa01      	add	r2, sp, #4
    e0a4:	4630      	mov	r0, r6
    e0a6:	f01b feeb 	bl	29e80 <ec_enc_icdf>
                if( q_ptr[ j ] != 0 ) {
    e0aa:	f914 1c02 	ldrsb.w	r1, [r4, #-2]
    e0ae:	2900      	cmp	r1, #0
    e0b0:	f43f af46 	beq.w	df40 <silk_encode_signs+0xb4>
                    ec_enc_icdf( psRangeEnc, silk_enc_map( q_ptr[ j ]), icdf, 8 );
    e0b4:	13c9      	asrs	r1, r1, #15
    e0b6:	3101      	adds	r1, #1
    e0b8:	2308      	movs	r3, #8
    e0ba:	aa01      	add	r2, sp, #4
    e0bc:	4630      	mov	r0, r6
    e0be:	f01b fedf 	bl	29e80 <ec_enc_icdf>
                if( q_ptr[ j ] != 0 ) {
    e0c2:	f914 1c01 	ldrsb.w	r1, [r4, #-1]
    e0c6:	2900      	cmp	r1, #0
    e0c8:	f43f af3f 	beq.w	df4a <silk_encode_signs+0xbe>
                    ec_enc_icdf( psRangeEnc, silk_enc_map( q_ptr[ j ]), icdf, 8 );
    e0cc:	13c9      	asrs	r1, r1, #15
    e0ce:	3101      	adds	r1, #1
    e0d0:	2308      	movs	r3, #8
    e0d2:	aa01      	add	r2, sp, #4
    e0d4:	4630      	mov	r0, r6
    e0d6:	f01b fed3 	bl	29e80 <ec_enc_icdf>
    for( i = 0; i < length; i++ ) {
    e0da:	42af      	cmp	r7, r5
    e0dc:	f104 0410 	add.w	r4, r4, #16
    e0e0:	f47f af38 	bne.w	df54 <silk_encode_signs+0xc8>
                }
            }
        }
        q_ptr += SHELL_CODEC_FRAME_LENGTH;
    }
}
    e0e4:	b002      	add	sp, #8
    e0e6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                    ec_enc_icdf( psRangeEnc, silk_enc_map( q_ptr[ j ]), icdf, 8 );
    e0ea:	13c9      	asrs	r1, r1, #15
    e0ec:	3101      	adds	r1, #1
    e0ee:	2308      	movs	r3, #8
    e0f0:	aa01      	add	r2, sp, #4
    e0f2:	4630      	mov	r0, r6
    e0f4:	f01b fec4 	bl	29e80 <ec_enc_icdf>
    e0f8:	e740      	b.n	df7c <silk_encode_signs+0xf0>
    e0fa:	bf00      	nop
    e0fc:	000371d0 	.word	0x000371d0

0000e100 <silk_Get_Encoder_Size>:
    opus_int                        *encSizeBytes       /* O    Number of bytes in SILK encoder state           */
)
{
    opus_int ret = SILK_NO_ERROR;

    *encSizeBytes = sizeof( silk_encoder );
    e100:	f244 33c8 	movw	r3, #17352	; 0x43c8
    e104:	6003      	str	r3, [r0, #0]

    return ret;
}
    e106:	2000      	movs	r0, #0
    e108:	4770      	bx	lr
    e10a:	bf00      	nop

0000e10c <silk_InitEncoder>:
opus_int silk_InitEncoder(                              /* O    Returns error code                              */
    void                            *encState,          /* I/O  State                                           */
    int                              arch,              /* I    Run-time architecture                           */
    silk_EncControlStruct           *encStatus          /* O    Encoder Status                                  */
)
{
    e10c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    e110:	4604      	mov	r4, r0
    e112:	4615      	mov	r5, r2
    e114:	460e      	mov	r6, r1
    opus_int n, ret = SILK_NO_ERROR;

    psEnc = (silk_encoder *)encState;

    /* Reset encoder */
    silk_memset( psEnc, 0, sizeof( silk_encoder ) );
    e116:	f244 32c8 	movw	r2, #17352	; 0x43c8
    e11a:	2100      	movs	r1, #0
    e11c:	f027 f822 	bl	35164 <memset>
    for( n = 0; n < ENCODER_NUM_CHANNELS; n++ ) {
        if( ret += silk_init_encoder( &psEnc->state_Fxx[ n ], arch ) ) {
    e120:	4631      	mov	r1, r6
    e122:	4620      	mov	r0, r4
    e124:	f007 fec4 	bl	15eb0 <silk_init_encoder>
    e128:	4680      	mov	r8, r0
    e12a:	f504 5006 	add.w	r0, r4, #8576	; 0x2180
    e12e:	4631      	mov	r1, r6
    e130:	3038      	adds	r0, #56	; 0x38
    e132:	f007 febd 	bl	15eb0 <silk_init_encoder>

    state_Fxx = psEnc->state_Fxx;

    encStatus->nChannelsAPI              = psEnc->nChannelsAPI;
    encStatus->nChannelsInternal         = psEnc->nChannelsInternal;
    encStatus->API_sampleRate            = state_Fxx[ 0 ].sCmn.API_fs_Hz;
    e136:	f241 16cc 	movw	r6, #4556	; 0x11cc
    encStatus->packetLossPercentage      = state_Fxx[ 0 ].sCmn.PacketLoss_perc;
    encStatus->complexity                = state_Fxx[ 0 ].sCmn.Complexity;
    encStatus->useInBandFEC              = state_Fxx[ 0 ].sCmn.useInBandFEC;
    encStatus->useDTX                    = state_Fxx[ 0 ].sCmn.useDTX;
    encStatus->useCBR                    = state_Fxx[ 0 ].sCmn.useCBR;
    encStatus->internalSampleRate        = silk_SMULBB( state_Fxx[ 0 ].sCmn.fs_kHz, 1000 );
    e13a:	f504 538f 	add.w	r3, r4, #4576	; 0x11e0
    psEnc->nChannelsAPI = 1;
    e13e:	f244 31b0 	movw	r1, #17328	; 0x43b0
    e142:	2201      	movs	r2, #1
    encStatus->internalSampleRate        = silk_SMULBB( state_Fxx[ 0 ].sCmn.fs_kHz, 1000 );
    e144:	681f      	ldr	r7, [r3, #0]
    encStatus->API_sampleRate            = state_Fxx[ 0 ].sCmn.API_fs_Hz;
    e146:	59a6      	ldr	r6, [r4, r6]
    psEnc->nChannelsAPI = 1;
    e148:	5062      	str	r2, [r4, r1]
    psEnc->nChannelsInternal = 1;
    e14a:	f244 3cb4 	movw	ip, #17332	; 0x43b4
    encStatus->maxInternalSampleRate     = state_Fxx[ 0 ].sCmn.maxInternal_fs_Hz;
    e14e:	f241 11d4 	movw	r1, #4564	; 0x11d4
    psEnc->nChannelsInternal = 1;
    e152:	f844 200c 	str.w	r2, [r4, ip]
    encStatus->maxInternalSampleRate     = state_Fxx[ 0 ].sCmn.maxInternal_fs_Hz;
    e156:	5861      	ldr	r1, [r4, r1]
    encStatus->API_sampleRate            = state_Fxx[ 0 ].sCmn.API_fs_Hz;
    e158:	60ae      	str	r6, [r5, #8]
    encStatus->nChannelsInternal         = psEnc->nChannelsInternal;
    e15a:	e9c5 2200 	strd	r2, r2, [r5]
    encStatus->desiredInternalSampleRate = state_Fxx[ 0 ].sCmn.desiredInternal_fs_Hz;
    e15e:	f241 16dc 	movw	r6, #4572	; 0x11dc
    encStatus->minInternalSampleRate     = state_Fxx[ 0 ].sCmn.minInternal_fs_Hz;
    e162:	f241 12d8 	movw	r2, #4568	; 0x11d8
    encStatus->desiredInternalSampleRate = state_Fxx[ 0 ].sCmn.desiredInternal_fs_Hz;
    e166:	59a6      	ldr	r6, [r4, r6]
    encStatus->minInternalSampleRate     = state_Fxx[ 0 ].sCmn.minInternal_fs_Hz;
    e168:	58a2      	ldr	r2, [r4, r2]
    encStatus->maxInternalSampleRate     = state_Fxx[ 0 ].sCmn.maxInternal_fs_Hz;
    e16a:	60e9      	str	r1, [r5, #12]
    encStatus->payloadSize_ms            = state_Fxx[ 0 ].sCmn.PacketSize_ms;
    e16c:	f241 2104 	movw	r1, #4612	; 0x1204
    encStatus->minInternalSampleRate     = state_Fxx[ 0 ].sCmn.minInternal_fs_Hz;
    e170:	612a      	str	r2, [r5, #16]
    encStatus->bitRate                   = state_Fxx[ 0 ].sCmn.TargetRate_bps;
    e172:	f504 5290 	add.w	r2, r4, #4608	; 0x1200
    encStatus->payloadSize_ms            = state_Fxx[ 0 ].sCmn.PacketSize_ms;
    e176:	5861      	ldr	r1, [r4, r1]
    encStatus->bitRate                   = state_Fxx[ 0 ].sCmn.TargetRate_bps;
    e178:	6812      	ldr	r2, [r2, #0]
    encStatus->desiredInternalSampleRate = state_Fxx[ 0 ].sCmn.desiredInternal_fs_Hz;
    e17a:	616e      	str	r6, [r5, #20]
    encStatus->payloadSize_ms            = state_Fxx[ 0 ].sCmn.PacketSize_ms;
    e17c:	61a9      	str	r1, [r5, #24]
    encStatus->packetLossPercentage      = state_Fxx[ 0 ].sCmn.PacketLoss_perc;
    e17e:	f241 2608 	movw	r6, #4616	; 0x1208
    encStatus->complexity                = state_Fxx[ 0 ].sCmn.Complexity;
    e182:	f241 2110 	movw	r1, #4624	; 0x1210
    encStatus->packetLossPercentage      = state_Fxx[ 0 ].sCmn.PacketLoss_perc;
    e186:	59a6      	ldr	r6, [r4, r6]
    encStatus->complexity                = state_Fxx[ 0 ].sCmn.Complexity;
    e188:	5861      	ldr	r1, [r4, r1]
    encStatus->bitRate                   = state_Fxx[ 0 ].sCmn.TargetRate_bps;
    e18a:	61ea      	str	r2, [r5, #28]
    encStatus->useInBandFEC              = state_Fxx[ 0 ].sCmn.useInBandFEC;
    e18c:	f241 72c8 	movw	r2, #6088	; 0x17c8
    encStatus->packetLossPercentage      = state_Fxx[ 0 ].sCmn.PacketLoss_perc;
    e190:	622e      	str	r6, [r5, #32]
    encStatus->useDTX                    = state_Fxx[ 0 ].sCmn.useDTX;
    e192:	f241 76bc 	movw	r6, #6076	; 0x17bc
    encStatus->useInBandFEC              = state_Fxx[ 0 ].sCmn.useInBandFEC;
    e196:	58a2      	ldr	r2, [r4, r2]
    encStatus->useDTX                    = state_Fxx[ 0 ].sCmn.useDTX;
    e198:	59a6      	ldr	r6, [r4, r6]
    encStatus->useInBandFEC              = state_Fxx[ 0 ].sCmn.useInBandFEC;
    e19a:	62aa      	str	r2, [r5, #40]	; 0x28
    encStatus->internalSampleRate        = silk_SMULBB( state_Fxx[ 0 ].sCmn.fs_kHz, 1000 );
    e19c:	b23b      	sxth	r3, r7
    e19e:	ebc3 1243 	rsb	r2, r3, r3, lsl #5
    e1a2:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    encStatus->allowBandwidthSwitch      = state_Fxx[ 0 ].sCmn.allow_bandwidth_switch;
    e1a6:	f241 12b8 	movw	r2, #4536	; 0x11b8
    encStatus->complexity                = state_Fxx[ 0 ].sCmn.Complexity;
    e1aa:	6269      	str	r1, [r5, #36]	; 0x24
    encStatus->allowBandwidthSwitch      = state_Fxx[ 0 ].sCmn.allow_bandwidth_switch;
    e1ac:	58a2      	ldr	r2, [r4, r2]
    encStatus->useCBR                    = state_Fxx[ 0 ].sCmn.useCBR;
    e1ae:	f241 2144 	movw	r1, #4676	; 0x1244
    encStatus->internalSampleRate        = silk_SMULBB( state_Fxx[ 0 ].sCmn.fs_kHz, 1000 );
    e1b2:	00db      	lsls	r3, r3, #3
    encStatus->inWBmodeWithoutVariableLP = state_Fxx[ 0 ].sCmn.fs_kHz == 16 && state_Fxx[ 0 ].sCmn.sLP.mode == 0;
    e1b4:	2f10      	cmp	r7, #16
    encStatus->useCBR                    = state_Fxx[ 0 ].sCmn.useCBR;
    e1b6:	5861      	ldr	r1, [r4, r1]
    e1b8:	6369      	str	r1, [r5, #52]	; 0x34
    encStatus->allowBandwidthSwitch      = state_Fxx[ 0 ].sCmn.allow_bandwidth_switch;
    e1ba:	e9c5 3212 	strd	r3, r2, [r5, #72]	; 0x48
    encStatus->inWBmodeWithoutVariableLP = state_Fxx[ 0 ].sCmn.fs_kHz == 16 && state_Fxx[ 0 ].sCmn.sLP.mode == 0;
    e1be:	bf08      	it	eq
    e1c0:	69e3      	ldreq	r3, [r4, #28]
    encStatus->useDTX                    = state_Fxx[ 0 ].sCmn.useDTX;
    e1c2:	632e      	str	r6, [r5, #48]	; 0x30
    encStatus->inWBmodeWithoutVariableLP = state_Fxx[ 0 ].sCmn.fs_kHz == 16 && state_Fxx[ 0 ].sCmn.sLP.mode == 0;
    e1c4:	bf06      	itte	eq
    e1c6:	fab3 f383 	clzeq	r3, r3
    e1ca:	095b      	lsreq	r3, r3, #5
    e1cc:	2300      	movne	r3, #0
        if( ret += silk_init_encoder( &psEnc->state_Fxx[ n ], arch ) ) {
    e1ce:	4440      	add	r0, r8
    encStatus->inWBmodeWithoutVariableLP = state_Fxx[ 0 ].sCmn.fs_kHz == 16 && state_Fxx[ 0 ].sCmn.sLP.mode == 0;
    e1d0:	652b      	str	r3, [r5, #80]	; 0x50
}
    e1d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    e1d6:	bf00      	nop

0000e1d8 <silk_Encode>:
    ec_enc                          *psRangeEnc,        /* I/O  Compressor data structure                       */
    opus_int32                      *nBytesOut,         /* I/O  Number of bytes in payload (input: Max bytes)   */
    const opus_int                  prefillFlag,        /* I    Flag to indicate prefilling buffers no coding   */
    opus_int                        activity            /* I    Decision of Opus voice activity detector        */
)
{
    e1d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e1dc:	b0ab      	sub	sp, #172	; 0xac
    e1de:	468b      	mov	fp, r1
    silk_encoder *psEnc = ( silk_encoder * )encState;
    VARDECL( opus_int16, buf );
    opus_int transition, curr_block, tot_blocks;
    SAVE_STACK;

    if (encControl->reducedDependency)
    e1e0:	6c49      	ldr	r1, [r1, #68]	; 0x44
{
    e1e2:	af08      	add	r7, sp, #32
    e1e4:	4681      	mov	r9, r0
    e1e6:	e9c7 231a 	strd	r2, r3, [r7, #104]	; 0x68
    if (encControl->reducedDependency)
    e1ea:	b131      	cbz	r1, e1fa <silk_Encode+0x22>
    {
       psEnc->state_Fxx[0].sCmn.first_frame_after_reset = 1;
    e1ec:	f241 2138 	movw	r1, #4664	; 0x1238
       psEnc->state_Fxx[1].sCmn.first_frame_after_reset = 1;
    e1f0:	f243 32f0 	movw	r2, #13296	; 0x33f0
       psEnc->state_Fxx[0].sCmn.first_frame_after_reset = 1;
    e1f4:	2301      	movs	r3, #1
    e1f6:	5043      	str	r3, [r0, r1]
       psEnc->state_Fxx[1].sCmn.first_frame_after_reset = 1;
    e1f8:	5083      	str	r3, [r0, r2]
    }
    psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded = psEnc->state_Fxx[ 1 ].sCmn.nFramesEncoded = 0;
    e1fa:	f643 012c 	movw	r1, #14380	; 0x382c
    e1fe:	f241 6274 	movw	r2, #5748	; 0x1674
    e202:	2300      	movs	r3, #0
    e204:	f849 3001 	str.w	r3, [r9, r1]

    /* Check values in encoder control structure */
    if( ( ret = check_control_input( encControl ) ) != 0 ) {
    e208:	4658      	mov	r0, fp
    psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded = psEnc->state_Fxx[ 1 ].sCmn.nFramesEncoded = 0;
    e20a:	f849 3002 	str.w	r3, [r9, r2]
    if( ( ret = check_control_input( encControl ) ) != 0 ) {
    e20e:	f007 fd7f 	bl	15d10 <check_control_input>
    e212:	6578      	str	r0, [r7, #84]	; 0x54
    e214:	2800      	cmp	r0, #0
    e216:	f040 80f3 	bne.w	e400 <silk_Encode+0x228>
        return ret;
    }

    encControl->switchReady = 0;

    if( encControl->nChannelsInternal > psEnc->nChannelsInternal ) {
    e21a:	f244 33b4 	movw	r3, #17332	; 0x43b4
    e21e:	f8db c004 	ldr.w	ip, [fp, #4]
    e222:	f859 3003 	ldr.w	r3, [r9, r3]
    encControl->switchReady = 0;
    e226:	f8cb 0058 	str.w	r0, [fp, #88]	; 0x58
    if( encControl->nChannelsInternal > psEnc->nChannelsInternal ) {
    e22a:	459c      	cmp	ip, r3
    e22c:	f300 83fd 	bgt.w	ea2a <silk_Encode+0x852>
    e230:	4682      	mov	sl, r0
            silk_memcpy( &psEnc->state_Fxx[ 1 ].sCmn.resampler_state, &psEnc->state_Fxx[ 0 ].sCmn.resampler_state, sizeof( silk_resampler_state_struct ) );
            silk_memcpy( &psEnc->state_Fxx[ 1 ].sCmn.In_HP_State,     &psEnc->state_Fxx[ 0 ].sCmn.In_HP_State,     sizeof( psEnc->state_Fxx[ 1 ].sCmn.In_HP_State ) );
        }
    }

    transition = (encControl->payloadSize_ms != psEnc->state_Fxx[ 0 ].sCmn.PacketSize_ms) || (psEnc->nChannelsInternal != encControl->nChannelsInternal);
    e232:	f241 2304 	movw	r3, #4612	; 0x1204
    e236:	f8db 2018 	ldr.w	r2, [fp, #24]
    e23a:	f859 3003 	ldr.w	r3, [r9, r3]
    e23e:	637a      	str	r2, [r7, #52]	; 0x34
    e240:	429a      	cmp	r2, r3
    e242:	f000 8509 	beq.w	ec58 <silk_Encode+0xa80>
    e246:	2301      	movs	r3, #1
    e248:	667b      	str	r3, [r7, #100]	; 0x64

    psEnc->nChannelsAPI = encControl->nChannelsAPI;
    e24a:	f244 34b0 	movw	r4, #17328	; 0x43b0
    e24e:	f8db 1000 	ldr.w	r1, [fp]
    psEnc->nChannelsInternal = encControl->nChannelsInternal;

    nBlocksOf10ms = silk_DIV32( 100 * nSamplesIn, encControl->API_sampleRate );
    e252:	f8db 2008 	ldr.w	r2, [fp, #8]
    psEnc->nChannelsAPI = encControl->nChannelsAPI;
    e256:	f849 1004 	str.w	r1, [r9, r4]
    nBlocksOf10ms = silk_DIV32( 100 * nSamplesIn, encControl->API_sampleRate );
    e25a:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
    psEnc->nChannelsInternal = encControl->nChannelsInternal;
    e25c:	f244 30b4 	movw	r0, #17332	; 0x43b4
    nBlocksOf10ms = silk_DIV32( 100 * nSamplesIn, encControl->API_sampleRate );
    e260:	2364      	movs	r3, #100	; 0x64
    e262:	fb03 f301 	mul.w	r3, r3, r1
    e266:	fb93 f1f2 	sdiv	r1, r3, r2
    tot_blocks = ( nBlocksOf10ms > 1 ) ? nBlocksOf10ms >> 1 : 1;
    e26a:	2901      	cmp	r1, #1
    psEnc->nChannelsInternal = encControl->nChannelsInternal;
    e26c:	f849 c000 	str.w	ip, [r9, r0]
    nBlocksOf10ms = silk_DIV32( 100 * nSamplesIn, encControl->API_sampleRate );
    e270:	6639      	str	r1, [r7, #96]	; 0x60
    tot_blocks = ( nBlocksOf10ms > 1 ) ? nBlocksOf10ms >> 1 : 1;
    e272:	f340 8495 	ble.w	eba0 <silk_Encode+0x9c8>
    e276:	1049      	asrs	r1, r1, #1
    e278:	6539      	str	r1, [r7, #80]	; 0x50
    curr_block = 0;
    if( prefillFlag ) {
    e27a:	f8d7 10b8 	ldr.w	r1, [r7, #184]	; 0xb8
    e27e:	2900      	cmp	r1, #0
    e280:	f040 8789 	bne.w	f196 <silk_Encode+0xfbe>
            psEnc->state_Fxx[ n ].sCmn.controlled_since_last_payload = 0;
            psEnc->state_Fxx[ n ].sCmn.prefillFlag = 1;
        }
    } else {
        /* Only accept input lengths that are a multiple of 10 ms */
        if( nBlocksOf10ms * encControl->API_sampleRate != 100 * nSamplesIn || nSamplesIn < 0 ) {
    e284:	6e39      	ldr	r1, [r7, #96]	; 0x60
    e286:	fb01 f102 	mul.w	r1, r1, r2
    e28a:	428b      	cmp	r3, r1
    e28c:	f040 8783 	bne.w	f196 <silk_Encode+0xfbe>
    e290:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
    e292:	2800      	cmp	r0, #0
    e294:	f2c0 877f 	blt.w	f196 <silk_Encode+0xfbe>
            celt_assert( 0 );
            RESTORE_STACK;
            return SILK_ENC_INPUT_INVALID_NO_OF_SAMPLES;
        }
        /* Make sure no more than one packet can be produced */
        if( 1000 * (opus_int32)nSamplesIn > encControl->payloadSize_ms * encControl->API_sampleRate ) {
    e298:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    e29a:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    e29e:	fb02 f303 	mul.w	r3, r2, r3
    e2a2:	fb01 f200 	mul.w	r2, r1, r0
    e2a6:	429a      	cmp	r2, r3
    e2a8:	f300 8775 	bgt.w	f196 <silk_Encode+0xfbe>
    opus_int   n, i, nBits, flags, tmp_payloadSize_ms = 0, tmp_complexity = 0, ret = 0;
    e2ac:	2300      	movs	r3, #0
    e2ae:	637b      	str	r3, [r7, #52]	; 0x34
    e2b0:	62bb      	str	r3, [r7, #40]	; 0x28
            RESTORE_STACK;
            return SILK_ENC_INPUT_INVALID_NO_OF_SAMPLES;
        }
    }

    for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    e2b2:	f1bc 0f00 	cmp.w	ip, #0
    e2b6:	f340 870a 	ble.w	f0ce <silk_Encode+0xef6>
    e2ba:	f509 4387 	add.w	r3, r9, #17280	; 0x4380
    e2be:	f509 5491 	add.w	r4, r9, #4640	; 0x1220
    e2c2:	2500      	movs	r5, #0
            silk_assert( 0 );
            RESTORE_STACK;
            return ret;
        }
        if( psEnc->state_Fxx[n].sCmn.first_frame_after_reset || transition ) {
            for( i = 0; i < psEnc->state_Fxx[ 0 ].sCmn.nFramesPerPacket; i++ ) {
    e2c4:	f509 56b3 	add.w	r6, r9, #5728	; 0x1660
    e2c8:	3340      	adds	r3, #64	; 0x40
    e2ca:	46ca      	mov	sl, r9
    e2cc:	3418      	adds	r4, #24
                psEnc->state_Fxx[ n ].sCmn.LBRR_flags[ i ] = 0;
    e2ce:	46a8      	mov	r8, r5
    e2d0:	64bb      	str	r3, [r7, #72]	; 0x48
            for( i = 0; i < psEnc->state_Fxx[ 0 ].sCmn.nFramesPerPacket; i++ ) {
    e2d2:	3610      	adds	r6, #16
    e2d4:	4628      	mov	r0, r5
    e2d6:	4699      	mov	r9, r3
    e2d8:	e014      	b.n	e304 <silk_Encode+0x12c>
        if( psEnc->state_Fxx[n].sCmn.first_frame_after_reset || transition ) {
    e2da:	6e7b      	ldr	r3, [r7, #100]	; 0x64
    e2dc:	bb0b      	cbnz	r3, e322 <silk_Encode+0x14a>
    for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    e2de:	f8db 3004 	ldr.w	r3, [fp, #4]
            }
        }
        psEnc->state_Fxx[ n ].sCmn.inDTX = psEnc->state_Fxx[ n ].sCmn.useDTX;
    e2e2:	f8d4 2584 	ldr.w	r2, [r4, #1412]	; 0x584
    e2e6:	f8c4 2588 	str.w	r2, [r4, #1416]	; 0x588
    for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    e2ea:	3501      	adds	r5, #1
    e2ec:	42ab      	cmp	r3, r5
    e2ee:	f340 8092 	ble.w	e416 <silk_Encode+0x23e>
        opus_int force_fs_kHz = (n==1) ? psEnc->state_Fxx[0].sCmn.fs_kHz : 0;
    e2f2:	2d01      	cmp	r5, #1
    e2f4:	bf08      	it	eq
    e2f6:	f50a 538f 	addeq.w	r3, sl, #4576	; 0x11e0
    e2fa:	f504 5406 	add.w	r4, r4, #8576	; 0x2180
    e2fe:	bf08      	it	eq
    e300:	6818      	ldreq	r0, [r3, #0]
    e302:	3438      	adds	r4, #56	; 0x38
        if( ( ret = silk_control_encoder( &psEnc->state_Fxx[ n ], encControl, psEnc->allowBandwidthSwitch, n, force_fs_kHz ) ) != 0 ) {
    e304:	f8d9 2000 	ldr.w	r2, [r9]
    e308:	9000      	str	r0, [sp, #0]
    e30a:	f5a4 5091 	sub.w	r0, r4, #4640	; 0x1220
    e30e:	3818      	subs	r0, #24
    e310:	462b      	mov	r3, r5
    e312:	4659      	mov	r1, fp
    e314:	f007 fe70 	bl	15ff8 <silk_control_encoder>
    e318:	2800      	cmp	r0, #0
    e31a:	d176      	bne.n	e40a <silk_Encode+0x232>
        if( psEnc->state_Fxx[n].sCmn.first_frame_after_reset || transition ) {
    e31c:	6823      	ldr	r3, [r4, #0]
    e31e:	2b00      	cmp	r3, #0
    e320:	d0db      	beq.n	e2da <silk_Encode+0x102>
            for( i = 0; i < psEnc->state_Fxx[ 0 ].sCmn.nFramesPerPacket; i++ ) {
    e322:	6833      	ldr	r3, [r6, #0]
    e324:	2b00      	cmp	r3, #0
    e326:	ddda      	ble.n	e2de <silk_Encode+0x106>
                psEnc->state_Fxx[ n ].sCmn.LBRR_flags[ i ] = 0;
    e328:	f8c4 803c 	str.w	r8, [r4, #60]	; 0x3c
            for( i = 0; i < psEnc->state_Fxx[ 0 ].sCmn.nFramesPerPacket; i++ ) {
    e32c:	6833      	ldr	r3, [r6, #0]
    e32e:	2b01      	cmp	r3, #1
    e330:	ddd5      	ble.n	e2de <silk_Encode+0x106>
                psEnc->state_Fxx[ n ].sCmn.LBRR_flags[ i ] = 0;
    e332:	f8c4 8040 	str.w	r8, [r4, #64]	; 0x40
            for( i = 0; i < psEnc->state_Fxx[ 0 ].sCmn.nFramesPerPacket; i++ ) {
    e336:	6833      	ldr	r3, [r6, #0]
    e338:	2b02      	cmp	r3, #2
                psEnc->state_Fxx[ n ].sCmn.LBRR_flags[ i ] = 0;
    e33a:	bfc8      	it	gt
    e33c:	f8c4 8044 	strgt.w	r8, [r4, #68]	; 0x44
    e340:	e7cd      	b.n	e2de <silk_Encode+0x106>
    e342:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    e344:	46d1      	mov	r9, sl
    e346:	681b      	ldr	r3, [r3, #0]
    e348:	f8d7 a058 	ldr.w	sl, [r7, #88]	; 0x58
            break;
        }
        curr_block++;
    }

    psEnc->nPrevChannelsInternal = encControl->nChannelsInternal;
    e34c:	f8db 2004 	ldr.w	r2, [fp, #4]
    e350:	f244 30b8 	movw	r0, #17336	; 0x43b8

    encControl->allowBandwidthSwitch = psEnc->allowBandwidthSwitch;
    encControl->inWBmodeWithoutVariableLP = psEnc->state_Fxx[ 0 ].sCmn.fs_kHz == 16 && psEnc->state_Fxx[ 0 ].sCmn.sLP.mode == 0;
    e354:	2b10      	cmp	r3, #16
    psEnc->nPrevChannelsInternal = encControl->nChannelsInternal;
    e356:	f849 2000 	str.w	r2, [r9, r0]
    encControl->internalSampleRate = silk_SMULBB( psEnc->state_Fxx[ 0 ].sCmn.fs_kHz, 1000 );
    e35a:	b21b      	sxth	r3, r3
    encControl->inWBmodeWithoutVariableLP = psEnc->state_Fxx[ 0 ].sCmn.fs_kHz == 16 && psEnc->state_Fxx[ 0 ].sCmn.sLP.mode == 0;
    e35c:	bf08      	it	eq
    e35e:	f8d9 001c 	ldreq.w	r0, [r9, #28]
    encControl->allowBandwidthSwitch = psEnc->allowBandwidthSwitch;
    e362:	f8cb 104c 	str.w	r1, [fp, #76]	; 0x4c
    encControl->internalSampleRate = silk_SMULBB( psEnc->state_Fxx[ 0 ].sCmn.fs_kHz, 1000 );
    e366:	ebc3 1143 	rsb	r1, r3, r3, lsl #5
    encControl->inWBmodeWithoutVariableLP = psEnc->state_Fxx[ 0 ].sCmn.fs_kHz == 16 && psEnc->state_Fxx[ 0 ].sCmn.sLP.mode == 0;
    e36a:	bf08      	it	eq
    e36c:	fab0 f080 	clzeq	r0, r0
    encControl->internalSampleRate = silk_SMULBB( psEnc->state_Fxx[ 0 ].sCmn.fs_kHz, 1000 );
    e370:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    encControl->stereoWidth_Q14 = encControl->toMono ? 0 : psEnc->sStereo.smth_width_Q14;
    e374:	f8db 103c 	ldr.w	r1, [fp, #60]	; 0x3c
    encControl->inWBmodeWithoutVariableLP = psEnc->state_Fxx[ 0 ].sCmn.fs_kHz == 16 && psEnc->state_Fxx[ 0 ].sCmn.sLP.mode == 0;
    e378:	bf0c      	ite	eq
    e37a:	0940      	lsreq	r0, r0, #5
    e37c:	2000      	movne	r0, #0
    encControl->internalSampleRate = silk_SMULBB( psEnc->state_Fxx[ 0 ].sCmn.fs_kHz, 1000 );
    e37e:	00db      	lsls	r3, r3, #3
    encControl->inWBmodeWithoutVariableLP = psEnc->state_Fxx[ 0 ].sCmn.fs_kHz == 16 && psEnc->state_Fxx[ 0 ].sCmn.sLP.mode == 0;
    e380:	f8cb 0050 	str.w	r0, [fp, #80]	; 0x50
    encControl->internalSampleRate = silk_SMULBB( psEnc->state_Fxx[ 0 ].sCmn.fs_kHz, 1000 );
    e384:	f8cb 3048 	str.w	r3, [fp, #72]	; 0x48
    encControl->stereoWidth_Q14 = encControl->toMono ? 0 : psEnc->sStereo.smth_width_Q14;
    e388:	b921      	cbnz	r1, e394 <silk_Encode+0x1bc>
    e38a:	f244 338c 	movw	r3, #17292	; 0x438c
    e38e:	f939 3003 	ldrsh.w	r3, [r9, r3]
    e392:	657b      	str	r3, [r7, #84]	; 0x54
    e394:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    e396:	f8cb 3054 	str.w	r3, [fp, #84]	; 0x54
    if( prefillFlag ) {
    e39a:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
    e39e:	b1cb      	cbz	r3, e3d4 <silk_Encode+0x1fc>
        encControl->payloadSize_ms = tmp_payloadSize_ms;
    e3a0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    e3a2:	f8cb 3018 	str.w	r3, [fp, #24]
        encControl->complexity = tmp_complexity;
        for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    e3a6:	2a00      	cmp	r2, #0
        encControl->complexity = tmp_complexity;
    e3a8:	6abb      	ldr	r3, [r7, #40]	; 0x28
    e3aa:	f8cb 3024 	str.w	r3, [fp, #36]	; 0x24
        for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    e3ae:	dd11      	ble.n	e3d4 <silk_Encode+0x1fc>
            psEnc->state_Fxx[ n ].sCmn.controlled_since_last_payload = 0;
    e3b0:	f241 203c 	movw	r0, #4668	; 0x123c
            psEnc->state_Fxx[ n ].sCmn.prefillFlag = 0;
    e3b4:	f241 2148 	movw	r1, #4680	; 0x1248
            psEnc->state_Fxx[ n ].sCmn.controlled_since_last_payload = 0;
    e3b8:	2300      	movs	r3, #0
        for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    e3ba:	2a01      	cmp	r2, #1
            psEnc->state_Fxx[ n ].sCmn.controlled_since_last_payload = 0;
    e3bc:	f849 3000 	str.w	r3, [r9, r0]
            psEnc->state_Fxx[ n ].sCmn.prefillFlag = 0;
    e3c0:	f849 3001 	str.w	r3, [r9, r1]
        for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    e3c4:	d006      	beq.n	e3d4 <silk_Encode+0x1fc>
            psEnc->state_Fxx[ n ].sCmn.controlled_since_last_payload = 0;
    e3c6:	f243 31f4 	movw	r1, #13300	; 0x33f4
            psEnc->state_Fxx[ n ].sCmn.prefillFlag = 0;
    e3ca:	f509 5250 	add.w	r2, r9, #13312	; 0x3400
            psEnc->state_Fxx[ n ].sCmn.controlled_since_last_payload = 0;
    e3ce:	f849 3001 	str.w	r3, [r9, r1]
            psEnc->state_Fxx[ n ].sCmn.prefillFlag = 0;
    e3d2:	6013      	str	r3, [r2, #0]
        }
    }

    encControl->signalType = psEnc->state_Fxx[0].sCmn.indices.signalType;
    e3d4:	f241 239d 	movw	r3, #4765	; 0x129d
    encControl->offset = silk_Quantization_Offsets_Q10
                         [ psEnc->state_Fxx[0].sCmn.indices.signalType >> 1 ]
                         [ psEnc->state_Fxx[0].sCmn.indices.quantOffsetType ];
    e3d8:	f241 229e 	movw	r2, #4766	; 0x129e
    encControl->signalType = psEnc->state_Fxx[0].sCmn.indices.signalType;
    e3dc:	f919 3003 	ldrsb.w	r3, [r9, r3]
    e3e0:	f8cb 305c 	str.w	r3, [fp, #92]	; 0x5c
                         [ psEnc->state_Fxx[0].sCmn.indices.quantOffsetType ];
    e3e4:	f919 1002 	ldrsb.w	r1, [r9, r2]
    e3e8:	4acf      	ldr	r2, [pc, #828]	; (e728 <silk_Encode+0x550>)
    RESTORE_STACK;
    return ret;
    e3ea:	f8c7 a054 	str.w	sl, [r7, #84]	; 0x54
                         [ psEnc->state_Fxx[0].sCmn.indices.quantOffsetType ];
    e3ee:	f023 0301 	bic.w	r3, r3, #1
    e3f2:	440b      	add	r3, r1
    e3f4:	f932 3013 	ldrsh.w	r3, [r2, r3, lsl #1]
    e3f8:	f8cb 3060 	str.w	r3, [fp, #96]	; 0x60
    e3fc:	f8d7 d01c 	ldr.w	sp, [r7, #28]
}
    e400:	6d78      	ldr	r0, [r7, #84]	; 0x54
    e402:	378c      	adds	r7, #140	; 0x8c
    e404:	46bd      	mov	sp, r7
    e406:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e40a:	6578      	str	r0, [r7, #84]	; 0x54
    e40c:	6d78      	ldr	r0, [r7, #84]	; 0x54
    e40e:	378c      	adds	r7, #140	; 0x8c
    e410:	46bd      	mov	sp, r7
    e412:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e416:	46d1      	mov	r9, sl
    e418:	4682      	mov	sl, r0
        10 * nBlocksOf10ms * psEnc->state_Fxx[ 0 ].sCmn.fs_kHz;
    e41a:	6e39      	ldr	r1, [r7, #96]	; 0x60
    ALLOC( buf, nSamplesFromInputMax, opus_int16 );
    e41c:	f8c7 d01c 	str.w	sp, [r7, #28]
        10 * nBlocksOf10ms * psEnc->state_Fxx[ 0 ].sCmn.fs_kHz;
    e420:	f509 538f 	add.w	r3, r9, #4576	; 0x11e0
        silk_DIV32_16( nSamplesToBufferMax *
    e424:	f241 12cc 	movw	r2, #4556	; 0x11cc
        10 * nBlocksOf10ms * psEnc->state_Fxx[ 0 ].sCmn.fs_kHz;
    e428:	eb01 0081 	add.w	r0, r1, r1, lsl #2
    e42c:	647b      	str	r3, [r7, #68]	; 0x44
    e42e:	681b      	ldr	r3, [r3, #0]
        silk_DIV32_16( nSamplesToBufferMax *
    e430:	f859 1002 	ldr.w	r1, [r9, r2]
    curr_block = 0;
    e434:	f8c7 a058 	str.w	sl, [r7, #88]	; 0x58
        10 * nBlocksOf10ms * psEnc->state_Fxx[ 0 ].sCmn.fs_kHz;
    e438:	0042      	lsls	r2, r0, #1
    e43a:	60ba      	str	r2, [r7, #8]
        silk_DIV32_16( nSamplesToBufferMax *
    e43c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    nSamplesToBufferMax =
    e440:	fb03 f202 	mul.w	r2, r3, r2
        silk_DIV32_16( nSamplesToBufferMax *
    e444:	fb00 f003 	mul.w	r0, r0, r3
    nSamplesToBufferMax =
    e448:	63ba      	str	r2, [r7, #56]	; 0x38
        silk_DIV32_16( nSamplesToBufferMax *
    e44a:	fb02 f201 	mul.w	r2, r2, r1
    nSamplesFromInputMax =
    e44e:	fb92 f2f0 	sdiv	r2, r2, r0
    ALLOC( buf, nSamplesFromInputMax, opus_int16 );
    e452:	0052      	lsls	r2, r2, #1
    e454:	3208      	adds	r2, #8
    e456:	f022 0207 	bic.w	r2, r2, #7
    e45a:	ebad 0d02 	sub.w	sp, sp, r2
    e45e:	f509 52b3 	add.w	r2, r9, #5728	; 0x1660
    e462:	f509 548f 	add.w	r4, r9, #4576	; 0x11e0
    e466:	320c      	adds	r2, #12
            if( psEnc->nPrevChannelsInternal == 2 && psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded == 0 ) {
    e468:	f509 4587 	add.w	r5, r9, #17280	; 0x4380
    e46c:	65fa      	str	r2, [r7, #92]	; 0x5c
    e46e:	f104 0208 	add.w	r2, r4, #8
    e472:	667a      	str	r2, [r7, #100]	; 0x64
    e474:	f105 0238 	add.w	r2, r5, #56	; 0x38
    e478:	623a      	str	r2, [r7, #32]
                        maxBits -= encControl->maxBits / ( tot_blocks * 2 );
    e47a:	6d3a      	ldr	r2, [r7, #80]	; 0x50
    e47c:	f509 50b4 	add.w	r0, r9, #5760	; 0x1680
    e480:	0052      	lsls	r2, r2, #1
    ALLOC( buf, nSamplesFromInputMax, opus_int16 );
    e482:	ae08      	add	r6, sp, #32
    e484:	3010      	adds	r0, #16
                        maxBits -= encControl->maxBits / ( tot_blocks * 2 );
    e486:	61ba      	str	r2, [r7, #24]
    curr_block = 0;
    e488:	2200      	movs	r2, #0
    ALLOC( buf, nSamplesFromInputMax, opus_int16 );
    e48a:	64fe      	str	r6, [r7, #76]	; 0x4c
    e48c:	63f8      	str	r0, [r7, #60]	; 0x3c
    curr_block = 0;
    e48e:	663a      	str	r2, [r7, #96]	; 0x60
    e490:	460c      	mov	r4, r1
    e492:	46ca      	mov	sl, r9
    e494:	e0e4      	b.n	e660 <silk_Encode+0x488>
            if( psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded == 0 && !prefillFlag ) {
    e496:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
    e49a:	2b00      	cmp	r3, #0
    e49c:	f000 83fc 	beq.w	ec98 <silk_Encode+0xac0>
            silk_HP_variable_cutoff( psEnc->state_Fxx );
    e4a0:	4650      	mov	r0, sl
    e4a2:	f006 f825 	bl	144f0 <silk_HP_variable_cutoff>
            nBits = silk_DIV32_16( silk_MUL( encControl->bitRate, encControl->payloadSize_ms ), 1000 );
    e4a6:	e9db 2406 	ldrd	r2, r4, [fp, #24]
    e4aa:	49a0      	ldr	r1, [pc, #640]	; (e72c <silk_Encode+0x554>)
    e4ac:	fb02 f304 	mul.w	r3, r2, r4
    e4b0:	fb81 0103 	smull	r0, r1, r1, r3
    e4b4:	17db      	asrs	r3, r3, #31
    e4b6:	f50a 58b3 	add.w	r8, sl, #5728	; 0x1660
    e4ba:	ebc3 13a1 	rsb	r3, r3, r1, asr #6
    e4be:	f108 0810 	add.w	r8, r8, #16
            nBits = silk_DIV32_16( nBits, psEnc->state_Fxx[ 0 ].sCmn.nFramesPerPacket );
    e4c2:	f8d8 0000 	ldr.w	r0, [r8]
    e4c6:	fb93 f0f0 	sdiv	r0, r3, r0
            TargetRate_bps -= silk_DIV32_16( silk_MUL( psEnc->nBitsExceeded, 1000 ), BITRESERVOIR_DECAY_TIME_MS );
    e4ca:	f244 33ac 	movw	r3, #17324	; 0x43ac
    e4ce:	b201      	sxth	r1, r0
                TargetRate_bps = silk_SMULBB( nBits, 100 );
    e4d0:	eb01 0181 	add.w	r1, r1, r1, lsl #2
    e4d4:	eb01 0181 	add.w	r1, r1, r1, lsl #2
            if( encControl->payloadSize_ms == 10 ) {
    e4d8:	2a0a      	cmp	r2, #10
            TargetRate_bps -= silk_DIV32_16( silk_MUL( psEnc->nBitsExceeded, 1000 ), BITRESERVOIR_DECAY_TIME_MS );
    e4da:	f85a 3003 	ldr.w	r3, [sl, r3]
            if( !prefillFlag && psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded > 0 ) {
    e4de:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
                TargetRate_bps = silk_SMULBB( nBits, 100 );
    e4e2:	bf0c      	ite	eq
    e4e4:	0089      	lsleq	r1, r1, #2
                TargetRate_bps = silk_SMULBB( nBits, 50 );
    e4e6:	0049      	lslne	r1, r1, #1
            TargetRate_bps -= silk_DIV32_16( silk_MUL( psEnc->nBitsExceeded, 1000 ), BITRESERVOIR_DECAY_TIME_MS );
    e4e8:	eba1 0343 	sub.w	r3, r1, r3, lsl #1
            if( !prefillFlag && psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded > 0 ) {
    e4ec:	b9aa      	cbnz	r2, e51a <silk_Encode+0x342>
    e4ee:	f85a 5009 	ldr.w	r5, [sl, r9]
    e4f2:	2d00      	cmp	r5, #0
    e4f4:	dd11      	ble.n	e51a <silk_Encode+0x342>
   suitable for making coding decisions.
  Return: The number of bits.
          This will always be slightly larger than the exact value (e.g., all
           rounding error is in the positive direction).*/
static OPUS_INLINE int ec_tell(ec_ctx *_this){
  return _this->nbits_total-EC_ILOG(_this->rng);
    e4f6:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
    e4fa:	69d1      	ldr	r1, [r2, #28]
    e4fc:	6952      	ldr	r2, [r2, #20]
                opus_int32 bitsBalance = ec_tell( psRangeEnc ) - psEnc->nBitsUsedLBRR - nBits * psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded;
    e4fe:	f244 36a8 	movw	r6, #17320	; 0x43a8
    e502:	fab1 f181 	clz	r1, r1
    e506:	f1c1 0120 	rsb	r1, r1, #32
    e50a:	f85a 6006 	ldr.w	r6, [sl, r6]
    e50e:	1a52      	subs	r2, r2, r1
    e510:	1b92      	subs	r2, r2, r6
    e512:	fb00 2015 	mls	r0, r0, r5, r2
                TargetRate_bps -= silk_DIV32_16( silk_MUL( bitsBalance, 1000 ), BITRESERVOIR_DECAY_TIME_MS );
    e516:	eba3 0340 	sub.w	r3, r3, r0, lsl #1
            TargetRate_bps = silk_LIMIT( TargetRate_bps, encControl->bitRate, 5000 );
    e51a:	f241 3288 	movw	r2, #5000	; 0x1388
    e51e:	4294      	cmp	r4, r2
    e520:	f340 8106 	ble.w	e730 <silk_Encode+0x558>
    e524:	42a3      	cmp	r3, r4
    e526:	dc03      	bgt.n	e530 <silk_Encode+0x358>
    e528:	4293      	cmp	r3, r2
    e52a:	bfb8      	it	lt
    e52c:	4613      	movlt	r3, r2
    e52e:	461c      	mov	r4, r3
            if( encControl->nChannelsInternal == 2 ) {
    e530:	f8db 2004 	ldr.w	r2, [fp, #4]
    e534:	6e7b      	ldr	r3, [r7, #100]	; 0x64
    e536:	2a02      	cmp	r2, #2
    e538:	681b      	ldr	r3, [r3, #0]
    e53a:	f000 8106 	beq.w	e74a <silk_Encode+0x572>
                silk_memcpy( psEnc->state_Fxx[ 0 ].sCmn.inputBuf, psEnc->sStereo.sMid, 2 * sizeof( opus_int16 ) );
    e53e:	f244 3274 	movw	r2, #17268	; 0x4374
    e542:	f241 31e8 	movw	r1, #5096	; 0x13e8
    e546:	f85a 0002 	ldr.w	r0, [sl, r2]
    e54a:	f84a 0001 	str.w	r0, [sl, r1]
                silk_memcpy( psEnc->sStereo.sMid, &psEnc->state_Fxx[ 0 ].sCmn.inputBuf[ psEnc->state_Fxx[ 0 ].sCmn.frame_length ], 2 * sizeof( opus_int16 ) );
    e54e:	f603 13f4 	addw	r3, r3, #2548	; 0x9f4
    e552:	f50a 4587 	add.w	r5, sl, #17280	; 0x4380
    e556:	f85a 3013 	ldr.w	r3, [sl, r3, lsl #1]
    e55a:	f84a 3002 	str.w	r3, [sl, r2]
    e55e:	3544      	adds	r5, #68	; 0x44
            silk_encode_do_VAD_Fxx( &psEnc->state_Fxx[ 0 ], activity );
    e560:	f8d7 10bc 	ldr.w	r1, [r7, #188]	; 0xbc
    e564:	4650      	mov	r0, sl
    e566:	f00c faeb 	bl	1ab40 <silk_encode_do_VAD_FIX>
            for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    e56a:	f8db 2004 	ldr.w	r2, [fp, #4]
    e56e:	2a00      	cmp	r2, #0
    e570:	f340 817c 	ble.w	e86c <silk_Encode+0x694>
                if( tot_blocks == 2 && curr_block == 0 ) {
    e574:	6d3b      	ldr	r3, [r7, #80]	; 0x50
                maxBits = encControl->maxBits;
    e576:	f8db c038 	ldr.w	ip, [fp, #56]	; 0x38
                if( tot_blocks == 2 && curr_block == 0 ) {
    e57a:	2b02      	cmp	r3, #2
    e57c:	f000 81b5 	beq.w	e8ea <silk_Encode+0x712>
                } else if( tot_blocks == 3 ) {
    e580:	2b03      	cmp	r3, #3
    e582:	f000 81ec 	beq.w	e95e <silk_Encode+0x786>
                maxBits = encControl->maxBits;
    e586:	f8c7 c040 	str.w	ip, [r7, #64]	; 0x40
                useCBR = encControl->useCBR && curr_block == tot_blocks - 1;
    e58a:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
    e58e:	461e      	mov	r6, r3
    e590:	b133      	cbz	r3, e5a0 <silk_Encode+0x3c8>
    e592:	6d39      	ldr	r1, [r7, #80]	; 0x50
    e594:	6e38      	ldr	r0, [r7, #96]	; 0x60
    e596:	3901      	subs	r1, #1
    e598:	1a0e      	subs	r6, r1, r0
    e59a:	fab6 f686 	clz	r6, r6
    e59e:	0976      	lsrs	r6, r6, #5
                if( encControl->nChannelsInternal == 1 ) {
    e5a0:	2a01      	cmp	r2, #1
    e5a2:	f000 81b0 	beq.w	e906 <silk_Encode+0x72e>
                    channelRate_bps = MStargetRates_bps[ n ];
    e5a6:	e9d7 411d 	ldrd	r4, r1, [r7, #116]	; 0x74
                    if( n == 0 && MStargetRates_bps[ 1 ] > 0 ) {
    e5aa:	2900      	cmp	r1, #0
    e5ac:	dd06      	ble.n	e5bc <silk_Encode+0x3e4>
                        maxBits -= encControl->maxBits / ( tot_blocks * 2 );
    e5ae:	6c3e      	ldr	r6, [r7, #64]	; 0x40
    e5b0:	69b8      	ldr	r0, [r7, #24]
    e5b2:	fb9c f0f0 	sdiv	r0, ip, r0
    e5b6:	1a30      	subs	r0, r6, r0
    e5b8:	6438      	str	r0, [r7, #64]	; 0x40
                        useCBR = 0;
    e5ba:	2600      	movs	r6, #0
                if( channelRate_bps > 0 ) {
    e5bc:	2c00      	cmp	r4, #0
    e5be:	f300 8158 	bgt.w	e872 <silk_Encode+0x69a>
                psEnc->state_Fxx[ n ].sCmn.controlled_since_last_payload = 0;
    e5c2:	f241 263c 	movw	r6, #4668	; 0x123c
                psEnc->state_Fxx[ n ].sCmn.nFramesEncoded++;
    e5c6:	f85a 0009 	ldr.w	r0, [sl, r9]
                psEnc->state_Fxx[ n ].sCmn.controlled_since_last_payload = 0;
    e5ca:	2400      	movs	r4, #0
    e5cc:	f84a 4006 	str.w	r4, [sl, r6]
                psEnc->state_Fxx[ n ].sCmn.inputBufIx = 0;
    e5d0:	6dfe      	ldr	r6, [r7, #92]	; 0x5c
                psEnc->state_Fxx[ n ].sCmn.nFramesEncoded++;
    e5d2:	3001      	adds	r0, #1
                psEnc->state_Fxx[ n ].sCmn.inputBufIx = 0;
    e5d4:	6034      	str	r4, [r6, #0]
                psEnc->state_Fxx[ n ].sCmn.nFramesEncoded++;
    e5d6:	f84a 0009 	str.w	r0, [sl, r9]
                if( tot_blocks == 2 && curr_block == 0 ) {
    e5da:	6d38      	ldr	r0, [r7, #80]	; 0x50
    e5dc:	2802      	cmp	r0, #2
                maxBits = encControl->maxBits;
    e5de:	4666      	mov	r6, ip
                if( tot_blocks == 2 && curr_block == 0 ) {
    e5e0:	f000 8173 	beq.w	e8ca <silk_Encode+0x6f2>
                } else if( tot_blocks == 3 ) {
    e5e4:	2803      	cmp	r0, #3
    e5e6:	f000 8215 	beq.w	ea14 <silk_Encode+0x83c>
                useCBR = encControl->useCBR && curr_block == tot_blocks - 1;
    e5ea:	461c      	mov	r4, r3
    e5ec:	b133      	cbz	r3, e5fc <silk_Encode+0x424>
    e5ee:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    e5f0:	6e38      	ldr	r0, [r7, #96]	; 0x60
    e5f2:	3b01      	subs	r3, #1
    e5f4:	1a1c      	subs	r4, r3, r0
    e5f6:	fab4 f484 	clz	r4, r4
    e5fa:	0964      	lsrs	r4, r4, #5
                if( channelRate_bps > 0 ) {
    e5fc:	2900      	cmp	r1, #0
    e5fe:	f300 8191 	bgt.w	e924 <silk_Encode+0x74c>
                psEnc->state_Fxx[ n ].sCmn.nFramesEncoded++;
    e602:	f643 042c 	movw	r4, #14380	; 0x382c
    e606:	f85a 3009 	ldr.w	r3, [sl, r9]
    e60a:	f85a 1004 	ldr.w	r1, [sl, r4]
    e60e:	3101      	adds	r1, #1
    e610:	f84a 1004 	str.w	r1, [sl, r4]
                psEnc->state_Fxx[ n ].sCmn.controlled_since_last_payload = 0;
    e614:	f243 30f4 	movw	r0, #13300	; 0x33f4
                psEnc->state_Fxx[ n ].sCmn.inputBufIx = 0;
    e618:	f643 0424 	movw	r4, #14372	; 0x3824
                psEnc->state_Fxx[ n ].sCmn.controlled_since_last_payload = 0;
    e61c:	2100      	movs	r1, #0
    e61e:	f84a 1000 	str.w	r1, [sl, r0]
                psEnc->state_Fxx[ n ].sCmn.inputBufIx = 0;
    e622:	f84a 1004 	str.w	r1, [sl, r4]
            if( *nBytesOut > 0 && psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded == psEnc->state_Fxx[ 0 ].sCmn.nFramesPerPacket) {
    e626:	f8d7 10b4 	ldr.w	r1, [r7, #180]	; 0xb4
            psEnc->prev_decode_only_middle = psEnc->sStereo.mid_only_flags[ psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded - 1 ];
    e62a:	f244 34a3 	movw	r4, #17315	; 0x43a3
            if( *nBytesOut > 0 && psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded == psEnc->state_Fxx[ 0 ].sCmn.nFramesPerPacket) {
    e62e:	6808      	ldr	r0, [r1, #0]
            psEnc->prev_decode_only_middle = psEnc->sStereo.mid_only_flags[ psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded - 1 ];
    e630:	eb0a 0103 	add.w	r1, sl, r3
            if( *nBytesOut > 0 && psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded == psEnc->state_Fxx[ 0 ].sCmn.nFramesPerPacket) {
    e634:	2800      	cmp	r0, #0
            psEnc->prev_decode_only_middle = psEnc->sStereo.mid_only_flags[ psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded - 1 ];
    e636:	5709      	ldrsb	r1, [r1, r4]
    e638:	6029      	str	r1, [r5, #0]
            if( *nBytesOut > 0 && psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded == psEnc->state_Fxx[ 0 ].sCmn.nFramesPerPacket) {
    e63a:	dd04      	ble.n	e646 <silk_Encode+0x46e>
    e63c:	f8d8 0000 	ldr.w	r0, [r8]
    e640:	4298      	cmp	r0, r3
    e642:	f000 819a 	beq.w	e97a <silk_Encode+0x7a2>
    e646:	6c7b      	ldr	r3, [r7, #68]	; 0x44
            if( nSamplesIn == 0 ) {
    e648:	6efa      	ldr	r2, [r7, #108]	; 0x6c
    e64a:	681b      	ldr	r3, [r3, #0]
    e64c:	2a00      	cmp	r2, #0
    e64e:	f000 8299 	beq.w	eb84 <silk_Encode+0x9ac>
        curr_block++;
    e652:	6e39      	ldr	r1, [r7, #96]	; 0x60
    e654:	f241 12cc 	movw	r2, #4556	; 0x11cc
    e658:	3101      	adds	r1, #1
    e65a:	f85a 4002 	ldr.w	r4, [sl, r2]
    e65e:	6639      	str	r1, [r7, #96]	; 0x60
        nSamplesToBuffer  = psEnc->state_Fxx[ 0 ].sCmn.frame_length - psEnc->state_Fxx[ 0 ].sCmn.inputBufIx;
    e660:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
        if( encControl->nChannelsAPI == 2 && encControl->nChannelsInternal == 2 ) {
    e662:	f8db 0000 	ldr.w	r0, [fp]
        nSamplesToBuffer  = psEnc->state_Fxx[ 0 ].sCmn.frame_length - psEnc->state_Fxx[ 0 ].sCmn.inputBufIx;
    e666:	6815      	ldr	r5, [r2, #0]
    e668:	6e7a      	ldr	r2, [r7, #100]	; 0x64
    e66a:	6812      	ldr	r2, [r2, #0]
    e66c:	eba2 0905 	sub.w	r9, r2, r5
        nSamplesToBuffer  = silk_min( nSamplesToBuffer, nSamplesToBufferMax );
    e670:	6bba      	ldr	r2, [r7, #56]	; 0x38
    e672:	4591      	cmp	r9, r2
    e674:	bfa8      	it	ge
    e676:	4691      	movge	r9, r2
        nSamplesFromInput = silk_DIV32_16( nSamplesToBuffer * psEnc->state_Fxx[ 0 ].sCmn.API_fs_Hz, psEnc->state_Fxx[ 0 ].sCmn.fs_kHz * 1000 );
    e678:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
        if( encControl->nChannelsAPI == 2 && encControl->nChannelsInternal == 2 ) {
    e67c:	2802      	cmp	r0, #2
        nSamplesFromInput = silk_DIV32_16( nSamplesToBuffer * psEnc->state_Fxx[ 0 ].sCmn.API_fs_Hz, psEnc->state_Fxx[ 0 ].sCmn.fs_kHz * 1000 );
    e67e:	fb04 f409 	mul.w	r4, r4, r9
    e682:	fb02 f303 	mul.w	r3, r2, r3
    e686:	fb94 f4f3 	sdiv	r4, r4, r3
        if( encControl->nChannelsAPI == 2 && encControl->nChannelsInternal == 2 ) {
    e68a:	f000 80b9 	beq.w	e800 <silk_Encode+0x628>
            silk_memcpy(buf, samplesIn, nSamplesFromInput*sizeof(opus_int16));
    e68e:	6cfe      	ldr	r6, [r7, #76]	; 0x4c
    e690:	6eb9      	ldr	r1, [r7, #104]	; 0x68
    e692:	0062      	lsls	r2, r4, #1
    e694:	4630      	mov	r0, r6
    e696:	f7fd fd33 	bl	c100 <memcpy>
            ret += silk_resampler( &psEnc->state_Fxx[ 0 ].sCmn.resampler_state,
    e69a:	f605 11f6 	addw	r1, r5, #2550	; 0x9f6
    e69e:	eb0a 0141 	add.w	r1, sl, r1, lsl #1
    e6a2:	4623      	mov	r3, r4
    e6a4:	4632      	mov	r2, r6
    e6a6:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
    e6a8:	f00a fb24 	bl	18cf4 <silk_resampler>
            psEnc->state_Fxx[ 0 ].sCmn.inputBufIx += nSamplesToBuffer;
    e6ac:	6df9      	ldr	r1, [r7, #92]	; 0x5c
            ret += silk_resampler( &psEnc->state_Fxx[ 0 ].sCmn.resampler_state,
    e6ae:	6dbd      	ldr	r5, [r7, #88]	; 0x58
            psEnc->state_Fxx[ 0 ].sCmn.inputBufIx += nSamplesToBuffer;
    e6b0:	680b      	ldr	r3, [r1, #0]
    e6b2:	6e7a      	ldr	r2, [r7, #100]	; 0x64
    e6b4:	444b      	add	r3, r9
            ret += silk_resampler( &psEnc->state_Fxx[ 0 ].sCmn.resampler_state,
    e6b6:	4405      	add	r5, r0
    e6b8:	6812      	ldr	r2, [r2, #0]
    e6ba:	65bd      	str	r5, [r7, #88]	; 0x58
            psEnc->state_Fxx[ 0 ].sCmn.inputBufIx += nSamplesToBuffer;
    e6bc:	600b      	str	r3, [r1, #0]
        samplesIn  += nSamplesFromInput * encControl->nChannelsAPI;
    e6be:	f8db 1000 	ldr.w	r1, [fp]
        nSamplesIn -= nSamplesFromInput;
    e6c2:	6efd      	ldr	r5, [r7, #108]	; 0x6c
        samplesIn  += nSamplesFromInput * encControl->nChannelsAPI;
    e6c4:	fb01 f004 	mul.w	r0, r1, r4
        nSamplesIn -= nSamplesFromInput;
    e6c8:	1b2c      	subs	r4, r5, r4
    e6ca:	66fc      	str	r4, [r7, #108]	; 0x6c
        samplesIn  += nSamplesFromInput * encControl->nChannelsAPI;
    e6cc:	6ebc      	ldr	r4, [r7, #104]	; 0x68
    e6ce:	eb04 0040 	add.w	r0, r4, r0, lsl #1
    e6d2:	66b8      	str	r0, [r7, #104]	; 0x68
        psEnc->allowBandwidthSwitch = 0;
    e6d4:	6cb8      	ldr	r0, [r7, #72]	; 0x48
    e6d6:	2100      	movs	r1, #0
        if( psEnc->state_Fxx[ 0 ].sCmn.inputBufIx >= psEnc->state_Fxx[ 0 ].sCmn.frame_length ) {
    e6d8:	4293      	cmp	r3, r2
        psEnc->allowBandwidthSwitch = 0;
    e6da:	6001      	str	r1, [r0, #0]
        if( psEnc->state_Fxx[ 0 ].sCmn.inputBufIx >= psEnc->state_Fxx[ 0 ].sCmn.frame_length ) {
    e6dc:	f6ff ae31 	blt.w	e342 <silk_Encode+0x16a>
            if( psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded == 0 && !prefillFlag ) {
    e6e0:	f241 6974 	movw	r9, #5748	; 0x1674
    e6e4:	f85a 6009 	ldr.w	r6, [sl, r9]
    e6e8:	2e00      	cmp	r6, #0
    e6ea:	f43f aed4 	beq.w	e496 <silk_Encode+0x2be>
            silk_HP_variable_cutoff( psEnc->state_Fxx );
    e6ee:	4650      	mov	r0, sl
    e6f0:	f005 fefe 	bl	144f0 <silk_HP_variable_cutoff>
            nBits = silk_DIV32_16( silk_MUL( encControl->bitRate, encControl->payloadSize_ms ), 1000 );
    e6f4:	e9db 2406 	ldrd	r2, r4, [fp, #24]
    e6f8:	490c      	ldr	r1, [pc, #48]	; (e72c <silk_Encode+0x554>)
    e6fa:	fb02 f304 	mul.w	r3, r2, r4
    e6fe:	fb81 0103 	smull	r0, r1, r1, r3
    e702:	17db      	asrs	r3, r3, #31
    e704:	ebc3 13a1 	rsb	r3, r3, r1, asr #6
            if( !prefillFlag ) {
    e708:	f8d7 10b8 	ldr.w	r1, [r7, #184]	; 0xb8
    e70c:	f50a 58b3 	add.w	r8, sl, #5728	; 0x1660
    e710:	2900      	cmp	r1, #0
    e712:	f47f aed4 	bne.w	e4be <silk_Encode+0x2e6>
    e716:	f50a 4587 	add.w	r5, sl, #17280	; 0x4380
    e71a:	f108 0810 	add.w	r8, r8, #16
    e71e:	3528      	adds	r5, #40	; 0x28
                nBits -= psEnc->nBitsUsedLBRR;
    e720:	6829      	ldr	r1, [r5, #0]
    e722:	1a5b      	subs	r3, r3, r1
    e724:	e6cd      	b.n	e4c2 <silk_Encode+0x2ea>
    e726:	bf00      	nop
    e728:	00036c88 	.word	0x00036c88
    e72c:	10624dd3 	.word	0x10624dd3
            TargetRate_bps = silk_LIMIT( TargetRate_bps, encControl->bitRate, 5000 );
    e730:	4293      	cmp	r3, r2
    e732:	f300 80d8 	bgt.w	e8e6 <silk_Encode+0x70e>
    e736:	429c      	cmp	r4, r3
            if( encControl->nChannelsInternal == 2 ) {
    e738:	f8db 2004 	ldr.w	r2, [fp, #4]
            TargetRate_bps = silk_LIMIT( TargetRate_bps, encControl->bitRate, 5000 );
    e73c:	bfb8      	it	lt
    e73e:	461c      	movlt	r4, r3
    e740:	6e7b      	ldr	r3, [r7, #100]	; 0x64
            if( encControl->nChannelsInternal == 2 ) {
    e742:	2a02      	cmp	r2, #2
    e744:	681b      	ldr	r3, [r3, #0]
    e746:	f47f aefa 	bne.w	e53e <silk_Encode+0x366>
    e74a:	f85a 2009 	ldr.w	r2, [sl, r9]
                silk_stereo_LR_to_MS( &psEnc->sStereo, &psEnc->state_Fxx[ 0 ].sCmn.inputBuf[ 2 ], &psEnc->state_Fxx[ 1 ].sCmn.inputBuf[ 2 ],
    e74e:	9306      	str	r3, [sp, #24]
    e750:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    e752:	681b      	ldr	r3, [r3, #0]
    e754:	9305      	str	r3, [sp, #20]
    e756:	f8db 303c 	ldr.w	r3, [fp, #60]	; 0x3c
    e75a:	9304      	str	r3, [sp, #16]
    e75c:	f244 35a4 	movw	r5, #17316	; 0x43a4
    e760:	f241 11b4 	movw	r1, #4532	; 0x11b4
                    psEnc->sStereo.predIx[ psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded ], &psEnc->sStereo.mid_only_flags[ psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded ],
    e764:	eb02 0342 	add.w	r3, r2, r2, lsl #1
                silk_stereo_LR_to_MS( &psEnc->sStereo, &psEnc->state_Fxx[ 0 ].sCmn.inputBuf[ 2 ], &psEnc->state_Fxx[ 1 ].sCmn.inputBuf[ 2 ],
    e768:	442a      	add	r2, r5
    e76a:	f85a 1001 	ldr.w	r1, [sl, r1]
    e76e:	9103      	str	r1, [sp, #12]
    e770:	eb0a 0002 	add.w	r0, sl, r2
                    psEnc->sStereo.predIx[ psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded ], &psEnc->sStereo.mid_only_flags[ psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded ],
    e774:	eb0a 0343 	add.w	r3, sl, r3, lsl #1
                silk_stereo_LR_to_MS( &psEnc->sStereo, &psEnc->state_Fxx[ 0 ].sCmn.inputBuf[ 2 ], &psEnc->state_Fxx[ 1 ].sCmn.inputBuf[ 2 ],
    e778:	f107 0674 	add.w	r6, r7, #116	; 0x74
    e77c:	9000      	str	r0, [sp, #0]
    e77e:	f503 4387 	add.w	r3, r3, #17280	; 0x4380
    e782:	f50a 5256 	add.w	r2, sl, #13696	; 0x3580
    e786:	f50a 519f 	add.w	r1, sl, #5088	; 0x13e0
    e78a:	f50a 4086 	add.w	r0, sl, #17152	; 0x4300
    e78e:	3312      	adds	r3, #18
    e790:	9601      	str	r6, [sp, #4]
    e792:	9402      	str	r4, [sp, #8]
    e794:	3224      	adds	r2, #36	; 0x24
    e796:	310c      	adds	r1, #12
    e798:	3070      	adds	r0, #112	; 0x70
    e79a:	f006 fe63 	bl	15464 <silk_stereo_LR_to_MS>
                if( psEnc->sStereo.mid_only_flags[ psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded ] == 0 ) {
    e79e:	f85a 3009 	ldr.w	r3, [sl, r9]
    e7a2:	4453      	add	r3, sl
    e7a4:	575e      	ldrsb	r6, [r3, r5]
    e7a6:	2e00      	cmp	r6, #0
    e7a8:	f000 8177 	beq.w	ea9a <silk_Encode+0x8c2>
                    psEnc->state_Fxx[ 1 ].sCmn.VAD_flags[ psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded ] = 0;
    e7ac:	f243 4228 	movw	r2, #13352	; 0x3428
    e7b0:	2100      	movs	r1, #0
    e7b2:	f50a 4587 	add.w	r5, sl, #17280	; 0x4380
    e7b6:	5499      	strb	r1, [r3, r2]
    e7b8:	3544      	adds	r5, #68	; 0x44
                if( !prefillFlag ) {
    e7ba:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
    e7be:	2b00      	cmp	r3, #0
    e7c0:	f47f aece 	bne.w	e560 <silk_Encode+0x388>
                    silk_stereo_encode_pred( psRangeEnc, psEnc->sStereo.predIx[ psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded ] );
    e7c4:	f85a 3009 	ldr.w	r3, [sl, r9]
    e7c8:	f8d7 00b0 	ldr.w	r0, [r7, #176]	; 0xb0
    e7cc:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    e7d0:	eb0a 0143 	add.w	r1, sl, r3, lsl #1
    e7d4:	f501 4187 	add.w	r1, r1, #17280	; 0x4380
    e7d8:	3112      	adds	r1, #18
    e7da:	f00b fc27 	bl	1a02c <silk_stereo_encode_pred>
                    if( psEnc->state_Fxx[ 1 ].sCmn.VAD_flags[ psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded ] == 0 ) {
    e7de:	f85a 3009 	ldr.w	r3, [sl, r9]
    e7e2:	f243 4228 	movw	r2, #13352	; 0x3428
    e7e6:	4453      	add	r3, sl
    e7e8:	569a      	ldrsb	r2, [r3, r2]
    e7ea:	2a00      	cmp	r2, #0
    e7ec:	f47f aeb8 	bne.w	e560 <silk_Encode+0x388>
                        silk_stereo_encode_mid_only( psRangeEnc, psEnc->sStereo.mid_only_flags[ psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded ] );
    e7f0:	f244 32a4 	movw	r2, #17316	; 0x43a4
    e7f4:	f8d7 00b0 	ldr.w	r0, [r7, #176]	; 0xb0
    e7f8:	5699      	ldrsb	r1, [r3, r2]
    e7fa:	f00b fc4d 	bl	1a098 <silk_stereo_encode_mid_only>
    e7fe:	e6af      	b.n	e560 <silk_Encode+0x388>
        if( encControl->nChannelsAPI == 2 && encControl->nChannelsInternal == 2 ) {
    e800:	f8db 3004 	ldr.w	r3, [fp, #4]
    e804:	2b02      	cmp	r3, #2
    e806:	f000 835a 	beq.w	eebe <silk_Encode+0xce6>
        } else if( encControl->nChannelsAPI == 2 && encControl->nChannelsInternal == 1 ) {
    e80a:	2b01      	cmp	r3, #1
    e80c:	f47f af3f 	bne.w	e68e <silk_Encode+0x4b6>
            for( n = 0; n < nSamplesFromInput; n++ ) {
    e810:	2c00      	cmp	r4, #0
    e812:	dd12      	ble.n	e83a <silk_Encode+0x662>
    e814:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    e816:	1c9a      	adds	r2, r3, #2
    e818:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    e81a:	eb02 0084 	add.w	r0, r2, r4, lsl #2
    e81e:	1e99      	subs	r1, r3, #2
                sum = samplesIn[ 2 * n ] + samplesIn[ 2 * n + 1 ];
    e820:	f932 3c02 	ldrsh.w	r3, [r2, #-2]
    e824:	f932 6b04 	ldrsh.w	r6, [r2], #4
    e828:	4433      	add	r3, r6
                buf[ n ] = (opus_int16)silk_RSHIFT_ROUND( sum,  1 );
    e82a:	f003 0601 	and.w	r6, r3, #1
    e82e:	eb06 0363 	add.w	r3, r6, r3, asr #1
            for( n = 0; n < nSamplesFromInput; n++ ) {
    e832:	4290      	cmp	r0, r2
                buf[ n ] = (opus_int16)silk_RSHIFT_ROUND( sum,  1 );
    e834:	f821 3f02 	strh.w	r3, [r1, #2]!
            for( n = 0; n < nSamplesFromInput; n++ ) {
    e838:	d1f2      	bne.n	e820 <silk_Encode+0x648>
            ret += silk_resampler( &psEnc->state_Fxx[ 0 ].sCmn.resampler_state,
    e83a:	f605 11f6 	addw	r1, r5, #2550	; 0x9f6
    e83e:	4623      	mov	r3, r4
    e840:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
    e842:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
    e844:	eb0a 0141 	add.w	r1, sl, r1, lsl #1
    e848:	f00a fa54 	bl	18cf4 <silk_resampler>
            if( psEnc->nPrevChannelsInternal == 2 && psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded == 0 ) {
    e84c:	6a3b      	ldr	r3, [r7, #32]
            ret += silk_resampler( &psEnc->state_Fxx[ 0 ].sCmn.resampler_state,
    e84e:	6dba      	ldr	r2, [r7, #88]	; 0x58
            if( psEnc->nPrevChannelsInternal == 2 && psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded == 0 ) {
    e850:	681b      	ldr	r3, [r3, #0]
            ret += silk_resampler( &psEnc->state_Fxx[ 0 ].sCmn.resampler_state,
    e852:	4402      	add	r2, r0
            if( psEnc->nPrevChannelsInternal == 2 && psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded == 0 ) {
    e854:	2b02      	cmp	r3, #2
            ret += silk_resampler( &psEnc->state_Fxx[ 0 ].sCmn.resampler_state,
    e856:	65ba      	str	r2, [r7, #88]	; 0x58
            if( psEnc->nPrevChannelsInternal == 2 && psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded == 0 ) {
    e858:	f000 83b5 	beq.w	efc6 <silk_Encode+0xdee>
    e85c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    e85e:	6e7a      	ldr	r2, [r7, #100]	; 0x64
    e860:	681b      	ldr	r3, [r3, #0]
    e862:	6812      	ldr	r2, [r2, #0]
            psEnc->state_Fxx[ 0 ].sCmn.inputBufIx += nSamplesToBuffer;
    e864:	6df9      	ldr	r1, [r7, #92]	; 0x5c
    e866:	444b      	add	r3, r9
    e868:	600b      	str	r3, [r1, #0]
    e86a:	e728      	b.n	e6be <silk_Encode+0x4e6>
    e86c:	f85a 3009 	ldr.w	r3, [sl, r9]
    e870:	e6d9      	b.n	e626 <silk_Encode+0x44e>
                    silk_control_SNR( &psEnc->state_Fxx[ n ].sCmn, channelRate_bps );
    e872:	4621      	mov	r1, r4
    e874:	4650      	mov	r0, sl
    e876:	f007 fad1 	bl	15e1c <silk_control_SNR>
                    if( psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded - n <= 0 ) {
    e87a:	f85a 3009 	ldr.w	r3, [sl, r9]
                    if( ( ret = silk_encode_frame_Fxx( &psEnc->state_Fxx[ n ], nBytesOut, psRangeEnc, condCoding, maxBits, useCBR ) ) != 0 ) {
    e87e:	9601      	str	r6, [sp, #4]
                        condCoding = CODE_INDEPENDENTLY;
    e880:	2b00      	cmp	r3, #0
                    if( ( ret = silk_encode_frame_Fxx( &psEnc->state_Fxx[ n ], nBytesOut, psRangeEnc, condCoding, maxBits, useCBR ) ) != 0 ) {
    e882:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    e884:	9300      	str	r3, [sp, #0]
    e886:	e9d7 212c 	ldrd	r2, r1, [r7, #176]	; 0xb0
    e88a:	bfcc      	ite	gt
    e88c:	2302      	movgt	r3, #2
    e88e:	2300      	movle	r3, #0
    e890:	4650      	mov	r0, sl
    e892:	f00c f99d 	bl	1abd0 <silk_encode_frame_FIX>
    e896:	65b8      	str	r0, [r7, #88]	; 0x58
                psEnc->state_Fxx[ n ].sCmn.controlled_since_last_payload = 0;
    e898:	f241 203c 	movw	r0, #4668	; 0x123c
                psEnc->state_Fxx[ n ].sCmn.nFramesEncoded++;
    e89c:	f85a 3009 	ldr.w	r3, [sl, r9]
    e8a0:	f8db 2004 	ldr.w	r2, [fp, #4]
                psEnc->state_Fxx[ n ].sCmn.controlled_since_last_payload = 0;
    e8a4:	2100      	movs	r1, #0
    e8a6:	f84a 1000 	str.w	r1, [sl, r0]
                psEnc->state_Fxx[ n ].sCmn.inputBufIx = 0;
    e8aa:	6df8      	ldr	r0, [r7, #92]	; 0x5c
                psEnc->state_Fxx[ n ].sCmn.nFramesEncoded++;
    e8ac:	3301      	adds	r3, #1
            for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    e8ae:	2a01      	cmp	r2, #1
                psEnc->state_Fxx[ n ].sCmn.inputBufIx = 0;
    e8b0:	6001      	str	r1, [r0, #0]
                psEnc->state_Fxx[ n ].sCmn.nFramesEncoded++;
    e8b2:	f84a 3009 	str.w	r3, [sl, r9]
            for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    e8b6:	f77f aeb6 	ble.w	e626 <silk_Encode+0x44e>
    e8ba:	e9db 3c0d 	ldrd	r3, ip, [fp, #52]	; 0x34
                if( tot_blocks == 2 && curr_block == 0 ) {
    e8be:	6d38      	ldr	r0, [r7, #80]	; 0x50
    e8c0:	6fb9      	ldr	r1, [r7, #120]	; 0x78
    e8c2:	2802      	cmp	r0, #2
                maxBits = encControl->maxBits;
    e8c4:	4666      	mov	r6, ip
                if( tot_blocks == 2 && curr_block == 0 ) {
    e8c6:	f47f ae8d 	bne.w	e5e4 <silk_Encode+0x40c>
    e8ca:	6e38      	ldr	r0, [r7, #96]	; 0x60
    e8cc:	2800      	cmp	r0, #0
    e8ce:	f47f ae8c 	bne.w	e5ea <silk_Encode+0x412>
                    maxBits = maxBits * 3 / 5;
    e8d2:	eb0c 064c 	add.w	r6, ip, ip, lsl #1
    e8d6:	f1a0 3099 	sub.w	r0, r0, #2576980377	; 0x99999999
    e8da:	fb80 4006 	smull	r4, r0, r0, r6
    e8de:	17f6      	asrs	r6, r6, #31
    e8e0:	ebc6 0660 	rsb	r6, r6, r0, asr #1
    e8e4:	e681      	b.n	e5ea <silk_Encode+0x412>
            TargetRate_bps = silk_LIMIT( TargetRate_bps, encControl->bitRate, 5000 );
    e8e6:	4614      	mov	r4, r2
    e8e8:	e622      	b.n	e530 <silk_Encode+0x358>
                if( tot_blocks == 2 && curr_block == 0 ) {
    e8ea:	6e3b      	ldr	r3, [r7, #96]	; 0x60
    e8ec:	2b00      	cmp	r3, #0
    e8ee:	f47f ae4a 	bne.w	e586 <silk_Encode+0x3ae>
                    maxBits = maxBits * 3 / 5;
    e8f2:	4ed7      	ldr	r6, [pc, #860]	; (ec50 <silk_Encode+0xa78>)
    e8f4:	eb0c 034c 	add.w	r3, ip, ip, lsl #1
    e8f8:	fb86 1603 	smull	r1, r6, r6, r3
    e8fc:	17db      	asrs	r3, r3, #31
    e8fe:	ebc3 0366 	rsb	r3, r3, r6, asr #1
    e902:	643b      	str	r3, [r7, #64]	; 0x40
    e904:	e641      	b.n	e58a <silk_Encode+0x3b2>
                if( channelRate_bps > 0 ) {
    e906:	2c00      	cmp	r4, #0
    e908:	dcb3      	bgt.n	e872 <silk_Encode+0x69a>
                psEnc->state_Fxx[ n ].sCmn.controlled_since_last_payload = 0;
    e90a:	f241 203c 	movw	r0, #4668	; 0x123c
                psEnc->state_Fxx[ n ].sCmn.nFramesEncoded++;
    e90e:	f85a 3009 	ldr.w	r3, [sl, r9]
                psEnc->state_Fxx[ n ].sCmn.controlled_since_last_payload = 0;
    e912:	2100      	movs	r1, #0
    e914:	f84a 1000 	str.w	r1, [sl, r0]
                psEnc->state_Fxx[ n ].sCmn.inputBufIx = 0;
    e918:	6df8      	ldr	r0, [r7, #92]	; 0x5c
                psEnc->state_Fxx[ n ].sCmn.nFramesEncoded++;
    e91a:	3301      	adds	r3, #1
                psEnc->state_Fxx[ n ].sCmn.inputBufIx = 0;
    e91c:	6001      	str	r1, [r0, #0]
                psEnc->state_Fxx[ n ].sCmn.nFramesEncoded++;
    e91e:	f84a 3009 	str.w	r3, [sl, r9]
    e922:	e680      	b.n	e626 <silk_Encode+0x44e>
                    silk_control_SNR( &psEnc->state_Fxx[ n ].sCmn, channelRate_bps );
    e924:	f50a 5206 	add.w	r2, sl, #8576	; 0x2180
    e928:	3238      	adds	r2, #56	; 0x38
    e92a:	4610      	mov	r0, r2
    e92c:	65ba      	str	r2, [r7, #88]	; 0x58
    e92e:	f007 fa75 	bl	15e1c <silk_control_SNR>
                    if( psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded - n <= 0 ) {
    e932:	f85a 3009 	ldr.w	r3, [sl, r9]
    e936:	6dba      	ldr	r2, [r7, #88]	; 0x58
    e938:	2b01      	cmp	r3, #1
    e93a:	f340 8329 	ble.w	ef90 <silk_Encode+0xdb8>
                    } else if( n > 0 && psEnc->prev_decode_only_middle ) {
    e93e:	682b      	ldr	r3, [r5, #0]
                        condCoding = CODE_INDEPENDENTLY_NO_LTP_SCALING;
    e940:	2b00      	cmp	r3, #0
    e942:	bf0c      	ite	eq
    e944:	2302      	moveq	r3, #2
    e946:	2301      	movne	r3, #1
                    if( ( ret = silk_encode_frame_Fxx( &psEnc->state_Fxx[ n ], nBytesOut, psRangeEnc, condCoding, maxBits, useCBR ) ) != 0 ) {
    e948:	e9cd 6400 	strd	r6, r4, [sp]
    e94c:	4610      	mov	r0, r2
    e94e:	e9d7 212c 	ldrd	r2, r1, [r7, #176]	; 0xb0
    e952:	f00c f93d 	bl	1abd0 <silk_encode_frame_FIX>
    e956:	f8db 2004 	ldr.w	r2, [fp, #4]
    e95a:	65b8      	str	r0, [r7, #88]	; 0x58
    e95c:	e651      	b.n	e602 <silk_Encode+0x42a>
                    if( curr_block == 0 ) {
    e95e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
    e960:	2b00      	cmp	r3, #0
    e962:	f000 80ac 	beq.w	eabe <silk_Encode+0x8e6>
                    } else if( curr_block == 1 ) {
    e966:	2b01      	cmp	r3, #1
    e968:	f47f ae0d 	bne.w	e586 <silk_Encode+0x3ae>
                        maxBits = maxBits * 3 / 4;
    e96c:	eb1c 064c 	adds.w	r6, ip, ip, lsl #1
    e970:	bf48      	it	mi
    e972:	3603      	addmi	r6, #3
    e974:	10b3      	asrs	r3, r6, #2
    e976:	643b      	str	r3, [r7, #64]	; 0x40
    e978:	e607      	b.n	e58a <silk_Encode+0x3b2>
                for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    e97a:	2a00      	cmp	r2, #0
    e97c:	f340 80b4 	ble.w	eae8 <silk_Encode+0x910>
                    for( i = 0; i < psEnc->state_Fxx[ n ].sCmn.nFramesPerPacket; i++ ) {
    e980:	2b00      	cmp	r3, #0
    e982:	f340 83aa 	ble.w	f0da <silk_Encode+0xf02>
                        flags |= psEnc->state_Fxx[ n ].sCmn.VAD_flags[ i ];
    e986:	f241 2170 	movw	r1, #4720	; 0x1270
                    for( i = 0; i < psEnc->state_Fxx[ n ].sCmn.nFramesPerPacket; i++ ) {
    e98a:	2b01      	cmp	r3, #1
                        flags |= psEnc->state_Fxx[ n ].sCmn.VAD_flags[ i ];
    e98c:	f91a 4001 	ldrsb.w	r4, [sl, r1]
                    for( i = 0; i < psEnc->state_Fxx[ n ].sCmn.nFramesPerPacket; i++ ) {
    e990:	f000 8406 	beq.w	f1a0 <silk_Encode+0xfc8>
                        flags |= psEnc->state_Fxx[ n ].sCmn.VAD_flags[ i ];
    e994:	f241 2171 	movw	r1, #4721	; 0x1271
                    for( i = 0; i < psEnc->state_Fxx[ n ].sCmn.nFramesPerPacket; i++ ) {
    e998:	2b02      	cmp	r3, #2
                        flags |= psEnc->state_Fxx[ n ].sCmn.VAD_flags[ i ];
    e99a:	f91a 1001 	ldrsb.w	r1, [sl, r1]
    e99e:	ea41 0144 	orr.w	r1, r1, r4, lsl #1
    e9a2:	ea4f 0441 	mov.w	r4, r1, lsl #1
                    for( i = 0; i < psEnc->state_Fxx[ n ].sCmn.nFramesPerPacket; i++ ) {
    e9a6:	d005      	beq.n	e9b4 <silk_Encode+0x7dc>
                        flags |= psEnc->state_Fxx[ n ].sCmn.VAD_flags[ i ];
    e9a8:	f241 2372 	movw	r3, #4722	; 0x1272
    e9ac:	f91a 1003 	ldrsb.w	r1, [sl, r3]
    e9b0:	4321      	orrs	r1, r4
    e9b2:	004c      	lsls	r4, r1, #1
                    flags |= psEnc->state_Fxx[ n ].sCmn.LBRR_flag;
    e9b4:	f241 2373 	movw	r3, #4723	; 0x1273
                for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    e9b8:	2a02      	cmp	r2, #2
                    flags |= psEnc->state_Fxx[ n ].sCmn.LBRR_flag;
    e9ba:	f91a 1003 	ldrsb.w	r1, [sl, r3]
    e9be:	ea41 0104 	orr.w	r1, r1, r4
                for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    e9c2:	f040 8092 	bne.w	eaea <silk_Encode+0x912>
                    for( i = 0; i < psEnc->state_Fxx[ n ].sCmn.nFramesPerPacket; i++ ) {
    e9c6:	f643 0328 	movw	r3, #14376	; 0x3828
    e9ca:	0049      	lsls	r1, r1, #1
    e9cc:	f85a 3003 	ldr.w	r3, [sl, r3]
    e9d0:	2b00      	cmp	r3, #0
    e9d2:	dd19      	ble.n	ea08 <silk_Encode+0x830>
                        flags |= psEnc->state_Fxx[ n ].sCmn.VAD_flags[ i ];
    e9d4:	f243 4428 	movw	r4, #13352	; 0x3428
                    for( i = 0; i < psEnc->state_Fxx[ n ].sCmn.nFramesPerPacket; i++ ) {
    e9d8:	2b01      	cmp	r3, #1
                        flags |= psEnc->state_Fxx[ n ].sCmn.VAD_flags[ i ];
    e9da:	f91a 4004 	ldrsb.w	r4, [sl, r4]
    e9de:	ea41 0104 	orr.w	r1, r1, r4
    e9e2:	ea4f 0141 	mov.w	r1, r1, lsl #1
                    for( i = 0; i < psEnc->state_Fxx[ n ].sCmn.nFramesPerPacket; i++ ) {
    e9e6:	d00f      	beq.n	ea08 <silk_Encode+0x830>
                        flags |= psEnc->state_Fxx[ n ].sCmn.VAD_flags[ i ];
    e9e8:	f243 4429 	movw	r4, #13353	; 0x3429
                    for( i = 0; i < psEnc->state_Fxx[ n ].sCmn.nFramesPerPacket; i++ ) {
    e9ec:	2b02      	cmp	r3, #2
                        flags |= psEnc->state_Fxx[ n ].sCmn.VAD_flags[ i ];
    e9ee:	f91a 4004 	ldrsb.w	r4, [sl, r4]
    e9f2:	ea41 0104 	orr.w	r1, r1, r4
    e9f6:	ea4f 0141 	mov.w	r1, r1, lsl #1
                    for( i = 0; i < psEnc->state_Fxx[ n ].sCmn.nFramesPerPacket; i++ ) {
    e9fa:	d005      	beq.n	ea08 <silk_Encode+0x830>
                        flags |= psEnc->state_Fxx[ n ].sCmn.VAD_flags[ i ];
    e9fc:	f243 432a 	movw	r3, #13354	; 0x342a
    ea00:	f91a 3003 	ldrsb.w	r3, [sl, r3]
    ea04:	4319      	orrs	r1, r3
    ea06:	0049      	lsls	r1, r1, #1
                    flags |= psEnc->state_Fxx[ n ].sCmn.LBRR_flag;
    ea08:	f243 432b 	movw	r3, #13355	; 0x342b
    ea0c:	f91a 3003 	ldrsb.w	r3, [sl, r3]
    ea10:	4319      	orrs	r1, r3
    ea12:	e06a      	b.n	eaea <silk_Encode+0x912>
                    if( curr_block == 0 ) {
    ea14:	6e38      	ldr	r0, [r7, #96]	; 0x60
    ea16:	2800      	cmp	r0, #0
    ea18:	d15b      	bne.n	ead2 <silk_Encode+0x8fa>
                        maxBits = maxBits * 2 / 5;
    ea1a:	488d      	ldr	r0, [pc, #564]	; (ec50 <silk_Encode+0xa78>)
    ea1c:	0076      	lsls	r6, r6, #1
    ea1e:	fb80 4006 	smull	r4, r0, r0, r6
    ea22:	17f6      	asrs	r6, r6, #31
    ea24:	ebc6 0660 	rsb	r6, r6, r0, asr #1
    ea28:	e5df      	b.n	e5ea <silk_Encode+0x412>
        ret += silk_init_encoder( &psEnc->state_Fxx[ 1 ], psEnc->state_Fxx[ 0 ].sCmn.arch );
    ea2a:	f241 33e4 	movw	r3, #5092	; 0x13e4
    ea2e:	f242 15b8 	movw	r5, #8632	; 0x21b8
    ea32:	eb09 0405 	add.w	r4, r9, r5
    ea36:	f859 1003 	ldr.w	r1, [r9, r3]
    ea3a:	4620      	mov	r0, r4
    ea3c:	f007 fa38 	bl	15eb0 <silk_init_encoder>
        if( psEnc->nChannelsAPI == 2 ) {
    ea40:	f244 32b0 	movw	r2, #17328	; 0x43b0
        silk_memset( psEnc->sStereo.pred_prev_Q13, 0, sizeof( psEnc->sStereo.pred_prev_Q13 ) );
    ea44:	f244 3370 	movw	r3, #17264	; 0x4370
        ret += silk_init_encoder( &psEnc->state_Fxx[ 1 ], psEnc->state_Fxx[ 0 ].sCmn.arch );
    ea48:	4682      	mov	sl, r0
        silk_memset( psEnc->sStereo.sSide, 0, sizeof( psEnc->sStereo.sSide ) );
    ea4a:	f244 3078 	movw	r0, #17272	; 0x4378
        if( psEnc->nChannelsAPI == 2 ) {
    ea4e:	f859 1002 	ldr.w	r1, [r9, r2]
        silk_memset( psEnc->sStereo.pred_prev_Q13, 0, sizeof( psEnc->sStereo.pred_prev_Q13 ) );
    ea52:	6d7e      	ldr	r6, [r7, #84]	; 0x54
    ea54:	f849 6003 	str.w	r6, [r9, r3]
        psEnc->sStereo.mid_side_amp_Q0[ 0 ] = 0;
    ea58:	f244 327c 	movw	r2, #17276	; 0x437c
        silk_memset( psEnc->sStereo.sSide, 0, sizeof( psEnc->sStereo.sSide ) );
    ea5c:	f849 6000 	str.w	r6, [r9, r0]
        psEnc->sStereo.mid_side_amp_Q0[ 1 ] = 1;
    ea60:	f509 4387 	add.w	r3, r9, #17280	; 0x4380
        psEnc->sStereo.mid_side_amp_Q0[ 0 ] = 0;
    ea64:	6d78      	ldr	r0, [r7, #84]	; 0x54
    ea66:	f849 0002 	str.w	r0, [r9, r2]
        psEnc->sStereo.mid_side_amp_Q0[ 3 ] = 1;
    ea6a:	f244 3688 	movw	r6, #17288	; 0x4388
        psEnc->sStereo.mid_side_amp_Q0[ 1 ] = 1;
    ea6e:	2201      	movs	r2, #1
    ea70:	601a      	str	r2, [r3, #0]
        psEnc->sStereo.mid_side_amp_Q0[ 2 ] = 0;
    ea72:	f244 3084 	movw	r0, #17284	; 0x4384
        psEnc->sStereo.smth_width_Q14 = SILK_FIX_CONST( 1, 14 );
    ea76:	f244 338c 	movw	r3, #17292	; 0x438c
        psEnc->sStereo.mid_side_amp_Q0[ 3 ] = 1;
    ea7a:	f849 2006 	str.w	r2, [r9, r6]
        if( psEnc->nChannelsAPI == 2 ) {
    ea7e:	2902      	cmp	r1, #2
        psEnc->sStereo.smth_width_Q14 = SILK_FIX_CONST( 1, 14 );
    ea80:	f44f 4280 	mov.w	r2, #16384	; 0x4000
        psEnc->sStereo.mid_side_amp_Q0[ 2 ] = 0;
    ea84:	6d7e      	ldr	r6, [r7, #84]	; 0x54
    ea86:	f849 6000 	str.w	r6, [r9, r0]
        psEnc->sStereo.smth_width_Q14 = SILK_FIX_CONST( 1, 14 );
    ea8a:	f849 2003 	str.w	r2, [r9, r3]
        if( psEnc->nChannelsAPI == 2 ) {
    ea8e:	f000 8326 	beq.w	f0de <silk_Encode+0xf06>
    ea92:	f8db c004 	ldr.w	ip, [fp, #4]
    ea96:	f7ff bbcc 	b.w	e232 <silk_Encode+0x5a>
                    if( psEnc->prev_decode_only_middle == 1 ) {
    ea9a:	f244 33c4 	movw	r3, #17348	; 0x43c4
    ea9e:	eb0a 0503 	add.w	r5, sl, r3
    eaa2:	f85a 3003 	ldr.w	r3, [sl, r3]
    eaa6:	643b      	str	r3, [r7, #64]	; 0x40
    eaa8:	2b01      	cmp	r3, #1
    eaaa:	f000 8336 	beq.w	f11a <silk_Encode+0xf42>
                    silk_encode_do_VAD_Fxx( &psEnc->state_Fxx[ 1 ], activity );
    eaae:	f50a 5006 	add.w	r0, sl, #8576	; 0x2180
    eab2:	3038      	adds	r0, #56	; 0x38
    eab4:	f8d7 10bc 	ldr.w	r1, [r7, #188]	; 0xbc
    eab8:	f00c f842 	bl	1ab40 <silk_encode_do_VAD_FIX>
    eabc:	e67d      	b.n	e7ba <silk_Encode+0x5e2>
                        maxBits = maxBits * 2 / 5;
    eabe:	4e64      	ldr	r6, [pc, #400]	; (ec50 <silk_Encode+0xa78>)
    eac0:	ea4f 034c 	mov.w	r3, ip, lsl #1
    eac4:	fb86 1603 	smull	r1, r6, r6, r3
    eac8:	17db      	asrs	r3, r3, #31
    eaca:	ebc3 0366 	rsb	r3, r3, r6, asr #1
    eace:	643b      	str	r3, [r7, #64]	; 0x40
    ead0:	e55b      	b.n	e58a <silk_Encode+0x3b2>
                    } else if( curr_block == 1 ) {
    ead2:	2801      	cmp	r0, #1
    ead4:	f47f ad89 	bne.w	e5ea <silk_Encode+0x412>
                        maxBits = maxBits * 3 / 4;
    ead8:	eb1c 0c4c 	adds.w	ip, ip, ip, lsl #1
    eadc:	bf48      	it	mi
    eade:	f10c 0c03 	addmi.w	ip, ip, #3
    eae2:	ea4f 06ac 	mov.w	r6, ip, asr #2
    eae6:	e580      	b.n	e5ea <silk_Encode+0x412>
                flags = 0;
    eae8:	2100      	movs	r1, #0
                if( !prefillFlag ) {
    eaea:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
    eaee:	2b00      	cmp	r3, #0
    eaf0:	f000 8262 	beq.w	efb8 <silk_Encode+0xde0>
                if( psEnc->state_Fxx[ 0 ].sCmn.inDTX && ( encControl->nChannelsInternal == 1 || psEnc->state_Fxx[ 1 ].sCmn.inDTX ) ) {
    eaf4:	f50a 53be 	add.w	r3, sl, #6080	; 0x17c0
    eaf8:	681b      	ldr	r3, [r3, #0]
    eafa:	b14b      	cbz	r3, eb10 <silk_Encode+0x938>
    eafc:	f8db 3004 	ldr.w	r3, [fp, #4]
    eb00:	2b01      	cmp	r3, #1
    eb02:	d048      	beq.n	eb96 <silk_Encode+0x9be>
    eb04:	f643 1378 	movw	r3, #14712	; 0x3978
    eb08:	f85a 3003 	ldr.w	r3, [sl, r3]
    eb0c:	2b00      	cmp	r3, #0
    eb0e:	d142      	bne.n	eb96 <silk_Encode+0x9be>
    eb10:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
    eb14:	681a      	ldr	r2, [r3, #0]
    eb16:	00d2      	lsls	r2, r2, #3
                psEnc->nBitsExceeded -= silk_DIV32_16( silk_MUL( encControl->bitRate, encControl->payloadSize_ms ), 1000 );
    eb18:	e9db 0306 	ldrd	r0, r3, [fp, #24]
                psEnc->nBitsExceeded += *nBytesOut * 8;
    eb1c:	f244 3cac 	movw	ip, #17324	; 0x43ac
                psEnc->nBitsExceeded -= silk_DIV32_16( silk_MUL( encControl->bitRate, encControl->payloadSize_ms ), 1000 );
    eb20:	4d4c      	ldr	r5, [pc, #304]	; (ec54 <silk_Encode+0xa7c>)
                psEnc->nBitsExceeded += *nBytesOut * 8;
    eb22:	f85a 100c 	ldr.w	r1, [sl, ip]
                psEnc->nBitsExceeded -= silk_DIV32_16( silk_MUL( encControl->bitRate, encControl->payloadSize_ms ), 1000 );
    eb26:	fb03 f300 	mul.w	r3, r3, r0
    eb2a:	fb85 6503 	smull	r6, r5, r5, r3
    eb2e:	17db      	asrs	r3, r3, #31
                psEnc->nBitsExceeded += *nBytesOut * 8;
    eb30:	440a      	add	r2, r1
                psEnc->nBitsExceeded -= silk_DIV32_16( silk_MUL( encControl->bitRate, encControl->payloadSize_ms ), 1000 );
    eb32:	eba3 13a5 	sub.w	r3, r3, r5, asr #6
    eb36:	4413      	add	r3, r2
                speech_act_thr_for_switch_Q8 = silk_SMLAWB( SILK_FIX_CONST( SPEECH_ACTIVITY_DTX_THRES, 8 ),
    eb38:	f244 34bc 	movw	r4, #17340	; 0x43bc
                psEnc->nBitsExceeded  = silk_LIMIT( psEnc->nBitsExceeded, 0, 10000 );
    eb3c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    eb40:	f242 7110 	movw	r1, #10000	; 0x2710
    eb44:	428b      	cmp	r3, r1
                speech_act_thr_for_switch_Q8 = silk_SMLAWB( SILK_FIX_CONST( SPEECH_ACTIVITY_DTX_THRES, 8 ),
    eb46:	f85a 6004 	ldr.w	r6, [sl, r4]
                psEnc->nBitsExceeded  = silk_LIMIT( psEnc->nBitsExceeded, 0, 10000 );
    eb4a:	bfa8      	it	ge
    eb4c:	460b      	movge	r3, r1
                speech_act_thr_for_switch_Q8 = silk_SMLAWB( SILK_FIX_CONST( SPEECH_ACTIVITY_DTX_THRES, 8 ),
    eb4e:	f640 4274 	movw	r2, #3188	; 0xc74
                if( psEnc->state_Fxx[ 0 ].sCmn.speech_activity_Q8 < speech_act_thr_for_switch_Q8 ) {
    eb52:	f241 11b4 	movw	r1, #4532	; 0x11b4
                speech_act_thr_for_switch_Q8 = silk_SMLAWB( SILK_FIX_CONST( SPEECH_ACTIVITY_DTX_THRES, 8 ),
    eb56:	fb16 f202 	smulbb	r2, r6, r2
                if( psEnc->state_Fxx[ 0 ].sCmn.speech_activity_Q8 < speech_act_thr_for_switch_Q8 ) {
    eb5a:	f85a 1001 	ldr.w	r1, [sl, r1]
                psEnc->nBitsExceeded  = silk_LIMIT( psEnc->nBitsExceeded, 0, 10000 );
    eb5e:	f84a 300c 	str.w	r3, [sl, ip]
                speech_act_thr_for_switch_Q8 = silk_SMLAWB( SILK_FIX_CONST( SPEECH_ACTIVITY_DTX_THRES, 8 ),
    eb62:	1412      	asrs	r2, r2, #16
    eb64:	320d      	adds	r2, #13
                if( psEnc->state_Fxx[ 0 ].sCmn.speech_activity_Q8 < speech_act_thr_for_switch_Q8 ) {
    eb66:	4291      	cmp	r1, r2
    eb68:	f280 8214 	bge.w	ef94 <silk_Encode+0xdbc>
                    psEnc->allowBandwidthSwitch = 1;
    eb6c:	6cb9      	ldr	r1, [r7, #72]	; 0x48
    eb6e:	2201      	movs	r2, #1
                    psEnc->timeSinceSwitchAllowed_ms = 0;
    eb70:	2300      	movs	r3, #0
                    psEnc->allowBandwidthSwitch = 1;
    eb72:	600a      	str	r2, [r1, #0]
                    psEnc->timeSinceSwitchAllowed_ms = 0;
    eb74:	f84a 3004 	str.w	r3, [sl, r4]
            if( nSamplesIn == 0 ) {
    eb78:	6efa      	ldr	r2, [r7, #108]	; 0x6c
    eb7a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    eb7c:	681b      	ldr	r3, [r3, #0]
    eb7e:	2a00      	cmp	r2, #0
    eb80:	f47f ad67 	bne.w	e652 <silk_Encode+0x47a>
    eb84:	46d1      	mov	r9, sl
    eb86:	f244 32c0 	movw	r2, #17344	; 0x43c0
    eb8a:	f8d7 a058 	ldr.w	sl, [r7, #88]	; 0x58
    eb8e:	f859 1002 	ldr.w	r1, [r9, r2]
    eb92:	f7ff bbdb 	b.w	e34c <silk_Encode+0x174>
                    *nBytesOut = 0;
    eb96:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
    eb9a:	2200      	movs	r2, #0
    eb9c:	601a      	str	r2, [r3, #0]
    eb9e:	e7bb      	b.n	eb18 <silk_Encode+0x940>
    if( prefillFlag ) {
    eba0:	f8d7 10b8 	ldr.w	r1, [r7, #184]	; 0xb8
    eba4:	2900      	cmp	r1, #0
    eba6:	f000 8325 	beq.w	f1f4 <silk_Encode+0x101c>
        if( nBlocksOf10ms != 1 ) {
    ebaa:	6e3b      	ldr	r3, [r7, #96]	; 0x60
    ebac:	2b01      	cmp	r3, #1
    ebae:	f040 82f2 	bne.w	f196 <silk_Encode+0xfbe>
        if ( prefillFlag == 2 ) {
    ebb2:	2902      	cmp	r1, #2
    ebb4:	d10b      	bne.n	ebce <silk_Encode+0x9f6>
            save_LP = psEnc->state_Fxx[ 0 ].sCmn.sLP;
    ebb6:	f109 0510 	add.w	r5, r9, #16
    ebba:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    ebbc:	f107 0474 	add.w	r4, r7, #116	; 0x74
    ebc0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
            save_LP.saved_fs_kHz = psEnc->state_Fxx[ 0 ].sCmn.fs_kHz;
    ebc2:	f509 538f 	add.w	r3, r9, #4576	; 0x11e0
            save_LP = psEnc->state_Fxx[ 0 ].sCmn.sLP;
    ebc6:	682a      	ldr	r2, [r5, #0]
            save_LP.saved_fs_kHz = psEnc->state_Fxx[ 0 ].sCmn.fs_kHz;
    ebc8:	681b      	ldr	r3, [r3, #0]
    ebca:	65fb      	str	r3, [r7, #92]	; 0x5c
            save_LP = psEnc->state_Fxx[ 0 ].sCmn.sLP;
    ebcc:	6022      	str	r2, [r4, #0]
        for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    ebce:	f1bc 0f00 	cmp.w	ip, #0
    ebd2:	f340 81e7 	ble.w	efa4 <silk_Encode+0xdcc>
    ebd6:	464c      	mov	r4, r9
    ebd8:	2500      	movs	r5, #0
            ret = silk_init_encoder( &psEnc->state_Fxx[ n ], psEnc->state_Fxx[ n ].sCmn.arch );
    ebda:	f241 38e4 	movw	r8, #5092	; 0x13e4
    ebde:	f242 16b8 	movw	r6, #8632	; 0x21b8
    ebe2:	f854 1008 	ldr.w	r1, [r4, r8]
    ebe6:	4620      	mov	r0, r4
    ebe8:	f007 f962 	bl	15eb0 <silk_init_encoder>
            if ( prefillFlag == 2 ) {
    ebec:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
    ebf0:	2b02      	cmp	r3, #2
            ret = silk_init_encoder( &psEnc->state_Fxx[ n ], psEnc->state_Fxx[ n ].sCmn.arch );
    ebf2:	4682      	mov	sl, r0
            if ( prefillFlag == 2 ) {
    ebf4:	d03b      	beq.n	ec6e <silk_Encode+0xa96>
        for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    ebf6:	f8db 3004 	ldr.w	r3, [fp, #4]
    ebfa:	3501      	adds	r5, #1
    ebfc:	42ab      	cmp	r3, r5
    ebfe:	4434      	add	r4, r6
    ec00:	dcef      	bgt.n	ebe2 <silk_Encode+0xa0a>
    ec02:	469c      	mov	ip, r3
        encControl->payloadSize_ms = 10;
    ec04:	220a      	movs	r2, #10
        encControl->complexity = 0;
    ec06:	2300      	movs	r3, #0
        tmp_payloadSize_ms = encControl->payloadSize_ms;
    ec08:	f8db 1018 	ldr.w	r1, [fp, #24]
        encControl->payloadSize_ms = 10;
    ec0c:	f8cb 2018 	str.w	r2, [fp, #24]
        for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    ec10:	459c      	cmp	ip, r3
        tmp_complexity = encControl->complexity;
    ec12:	f8db 2024 	ldr.w	r2, [fp, #36]	; 0x24
        tmp_payloadSize_ms = encControl->payloadSize_ms;
    ec16:	6379      	str	r1, [r7, #52]	; 0x34
        tmp_complexity = encControl->complexity;
    ec18:	62ba      	str	r2, [r7, #40]	; 0x28
        encControl->complexity = 0;
    ec1a:	f8cb 3024 	str.w	r3, [fp, #36]	; 0x24
        for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    ec1e:	f340 814a 	ble.w	eeb6 <silk_Encode+0xcde>
            psEnc->state_Fxx[ n ].sCmn.controlled_since_last_payload = 0;
    ec22:	f241 203c 	movw	r0, #4668	; 0x123c
            psEnc->state_Fxx[ n ].sCmn.prefillFlag = 1;
    ec26:	f241 2148 	movw	r1, #4680	; 0x1248
    ec2a:	2201      	movs	r2, #1
        for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    ec2c:	f1bc 0f02 	cmp.w	ip, #2
            psEnc->state_Fxx[ n ].sCmn.controlled_since_last_payload = 0;
    ec30:	f849 3000 	str.w	r3, [r9, r0]
            psEnc->state_Fxx[ n ].sCmn.prefillFlag = 1;
    ec34:	f849 2001 	str.w	r2, [r9, r1]
        for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    ec38:	f040 813c 	bne.w	eeb4 <silk_Encode+0xcdc>
            psEnc->state_Fxx[ n ].sCmn.controlled_since_last_payload = 0;
    ec3c:	f243 30f4 	movw	r0, #13300	; 0x33f4
            psEnc->state_Fxx[ n ].sCmn.prefillFlag = 1;
    ec40:	f509 5150 	add.w	r1, r9, #13312	; 0x3400
            psEnc->state_Fxx[ n ].sCmn.controlled_since_last_payload = 0;
    ec44:	f849 3000 	str.w	r3, [r9, r0]
    tot_blocks = ( nBlocksOf10ms > 1 ) ? nBlocksOf10ms >> 1 : 1;
    ec48:	653a      	str	r2, [r7, #80]	; 0x50
            psEnc->state_Fxx[ n ].sCmn.prefillFlag = 1;
    ec4a:	600a      	str	r2, [r1, #0]
    ec4c:	f7ff bb35 	b.w	e2ba <silk_Encode+0xe2>
    ec50:	66666667 	.word	0x66666667
    ec54:	10624dd3 	.word	0x10624dd3
    transition = (encControl->payloadSize_ms != psEnc->state_Fxx[ 0 ].sCmn.PacketSize_ms) || (psEnc->nChannelsInternal != encControl->nChannelsInternal);
    ec58:	f244 33b4 	movw	r3, #17332	; 0x43b4
    ec5c:	f859 3003 	ldr.w	r3, [r9, r3]
    ec60:	ebb3 030c 	subs.w	r3, r3, ip
    ec64:	bf18      	it	ne
    ec66:	2301      	movne	r3, #1
    ec68:	667b      	str	r3, [r7, #100]	; 0x64
    ec6a:	f7ff baee 	b.w	e24a <silk_Encode+0x72>
                psEnc->state_Fxx[ n ].sCmn.sLP = save_LP;
    ec6e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    ec70:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
    ec74:	f107 0c74 	add.w	ip, r7, #116	; 0x74
    ec78:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    ec7c:	f104 0e10 	add.w	lr, r4, #16
    ec80:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
        for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    ec84:	f8db 3004 	ldr.w	r3, [fp, #4]
                psEnc->state_Fxx[ n ].sCmn.sLP = save_LP;
    ec88:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
    ec8a:	f8ce 2000 	str.w	r2, [lr]
        for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    ec8e:	3501      	adds	r5, #1
    ec90:	429d      	cmp	r5, r3
    ec92:	4434      	add	r4, r6
    ec94:	dba5      	blt.n	ebe2 <silk_Encode+0xa0a>
    ec96:	e7b4      	b.n	ec02 <silk_Encode+0xa2a>
                iCDF[ 0 ] = 256 - silk_RSHIFT( 256, ( psEnc->state_Fxx[ 0 ].sCmn.nFramesPerPacket + 1 ) * encControl->nChannelsInternal );
    ec98:	f241 6470 	movw	r4, #5744	; 0x1670
    ec9c:	4619      	mov	r1, r3
    ec9e:	f8db 2004 	ldr.w	r2, [fp, #4]
    eca2:	f85a 3004 	ldr.w	r3, [sl, r4]
                opus_uint8 iCDF[ 2 ] = { 0, 0 };
    eca6:	f887 1071 	strb.w	r1, [r7, #113]	; 0x71
                iCDF[ 0 ] = 256 - silk_RSHIFT( 256, ( psEnc->state_Fxx[ 0 ].sCmn.nFramesPerPacket + 1 ) * encControl->nChannelsInternal );
    ecaa:	fb03 2202 	mla	r2, r3, r2, r2
    ecae:	f44f 7380 	mov.w	r3, #256	; 0x100
    ecb2:	4113      	asrs	r3, r2
    ecb4:	f107 0288 	add.w	r2, r7, #136	; 0x88
    ecb8:	425b      	negs	r3, r3
    ecba:	f802 3d18 	strb.w	r3, [r2, #-24]!
                ec_enc_icdf( psRangeEnc, 0, iCDF, 8 );
    ecbe:	f8d7 10b8 	ldr.w	r1, [r7, #184]	; 0xb8
    ecc2:	f8d7 00b0 	ldr.w	r0, [r7, #176]	; 0xb0
    ecc6:	2308      	movs	r3, #8
    ecc8:	f01b f8da 	bl	29e80 <ec_enc_icdf>
                for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    eccc:	f8db 3004 	ldr.w	r3, [fp, #4]
                    for( i = 0; i < psEnc->state_Fxx[ n ].sCmn.nFramesPerPacket; i++ ) {
    ecd0:	f85a 2004 	ldr.w	r2, [sl, r4]
                for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    ecd4:	2b00      	cmp	r3, #0
                iCDF[ 0 ] = 256 - silk_RSHIFT( 256, ( psEnc->state_Fxx[ 0 ].sCmn.nFramesPerPacket + 1 ) * encControl->nChannelsInternal );
    ecd6:	eb0a 0804 	add.w	r8, sl, r4
                for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    ecda:	f340 81b1 	ble.w	f040 <silk_Encode+0xe68>
                    for( i = 0; i < psEnc->state_Fxx[ n ].sCmn.nFramesPerPacket; i++ ) {
    ecde:	2a00      	cmp	r2, #0
    ece0:	f340 8260 	ble.w	f1a4 <silk_Encode+0xfcc>
                        LBRR_symbol |= silk_LSHIFT( psEnc->state_Fxx[ n ].sCmn.LBRR_flags[ i ], i );
    ece4:	f241 2174 	movw	r1, #4724	; 0x1274
                    for( i = 0; i < psEnc->state_Fxx[ n ].sCmn.nFramesPerPacket; i++ ) {
    ece8:	2a01      	cmp	r2, #1
                        LBRR_symbol |= silk_LSHIFT( psEnc->state_Fxx[ n ].sCmn.LBRR_flags[ i ], i );
    ecea:	f85a 1001 	ldr.w	r1, [sl, r1]
                    for( i = 0; i < psEnc->state_Fxx[ n ].sCmn.nFramesPerPacket; i++ ) {
    ecee:	f000 8208 	beq.w	f102 <silk_Encode+0xf2a>
                        LBRR_symbol |= silk_LSHIFT( psEnc->state_Fxx[ n ].sCmn.LBRR_flags[ i ], i );
    ecf2:	f241 2078 	movw	r0, #4728	; 0x1278
                    for( i = 0; i < psEnc->state_Fxx[ n ].sCmn.nFramesPerPacket; i++ ) {
    ecf6:	2a02      	cmp	r2, #2
                        LBRR_symbol |= silk_LSHIFT( psEnc->state_Fxx[ n ].sCmn.LBRR_flags[ i ], i );
    ecf8:	f85a 0000 	ldr.w	r0, [sl, r0]
    ecfc:	ea41 0140 	orr.w	r1, r1, r0, lsl #1
                    for( i = 0; i < psEnc->state_Fxx[ n ].sCmn.nFramesPerPacket; i++ ) {
    ed00:	f000 81c2 	beq.w	f088 <silk_Encode+0xeb0>
                        LBRR_symbol |= silk_LSHIFT( psEnc->state_Fxx[ n ].sCmn.LBRR_flags[ i ], i );
    ed04:	f241 257c 	movw	r5, #4732	; 0x127c
                    psEnc->state_Fxx[ n ].sCmn.LBRR_flag = LBRR_symbol > 0 ? 1 : 0;
    ed08:	f241 2073 	movw	r0, #4723	; 0x1273
                        LBRR_symbol |= silk_LSHIFT( psEnc->state_Fxx[ n ].sCmn.LBRR_flags[ i ], i );
    ed0c:	f85a 5005 	ldr.w	r5, [sl, r5]
    ed10:	ea41 0185 	orr.w	r1, r1, r5, lsl #2
                    psEnc->state_Fxx[ n ].sCmn.LBRR_flag = LBRR_symbol > 0 ? 1 : 0;
    ed14:	2900      	cmp	r1, #0
    ed16:	bfcc      	ite	gt
    ed18:	2501      	movgt	r5, #1
    ed1a:	2500      	movle	r5, #0
    ed1c:	f80a 5000 	strb.w	r5, [sl, r0]
                    if( LBRR_symbol && psEnc->state_Fxx[ n ].sCmn.nFramesPerPacket > 1 ) {
    ed20:	f040 81bb 	bne.w	f09a <silk_Encode+0xec2>
                for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    ed24:	2b01      	cmp	r3, #1
    ed26:	d035      	beq.n	ed94 <silk_Encode+0xbbc>
                    for( i = 0; i < psEnc->state_Fxx[ n ].sCmn.nFramesPerPacket; i++ ) {
    ed28:	f643 0328 	movw	r3, #14376	; 0x3828
    ed2c:	f85a 3003 	ldr.w	r3, [sl, r3]
    ed30:	2b00      	cmp	r3, #0
    ed32:	f340 8241 	ble.w	f1b8 <silk_Encode+0xfe0>
                        LBRR_symbol |= silk_LSHIFT( psEnc->state_Fxx[ n ].sCmn.LBRR_flags[ i ], i );
    ed36:	f243 422c 	movw	r2, #13356	; 0x342c
                    for( i = 0; i < psEnc->state_Fxx[ n ].sCmn.nFramesPerPacket; i++ ) {
    ed3a:	2b01      	cmp	r3, #1
                        LBRR_symbol |= silk_LSHIFT( psEnc->state_Fxx[ n ].sCmn.LBRR_flags[ i ], i );
    ed3c:	f85a 1002 	ldr.w	r1, [sl, r2]
                    for( i = 0; i < psEnc->state_Fxx[ n ].sCmn.nFramesPerPacket; i++ ) {
    ed40:	f000 8240 	beq.w	f1c4 <silk_Encode+0xfec>
                        LBRR_symbol |= silk_LSHIFT( psEnc->state_Fxx[ n ].sCmn.LBRR_flags[ i ], i );
    ed44:	f243 4230 	movw	r2, #13360	; 0x3430
                    for( i = 0; i < psEnc->state_Fxx[ n ].sCmn.nFramesPerPacket; i++ ) {
    ed48:	2b02      	cmp	r3, #2
                        LBRR_symbol |= silk_LSHIFT( psEnc->state_Fxx[ n ].sCmn.LBRR_flags[ i ], i );
    ed4a:	f85a 2002 	ldr.w	r2, [sl, r2]
    ed4e:	ea41 0142 	orr.w	r1, r1, r2, lsl #1
                    for( i = 0; i < psEnc->state_Fxx[ n ].sCmn.nFramesPerPacket; i++ ) {
    ed52:	f000 8240 	beq.w	f1d6 <silk_Encode+0xffe>
                        LBRR_symbol |= silk_LSHIFT( psEnc->state_Fxx[ n ].sCmn.LBRR_flags[ i ], i );
    ed56:	f243 4034 	movw	r0, #13364	; 0x3434
                    psEnc->state_Fxx[ n ].sCmn.LBRR_flag = LBRR_symbol > 0 ? 1 : 0;
    ed5a:	f243 422b 	movw	r2, #13355	; 0x342b
                        LBRR_symbol |= silk_LSHIFT( psEnc->state_Fxx[ n ].sCmn.LBRR_flags[ i ], i );
    ed5e:	f85a 0000 	ldr.w	r0, [sl, r0]
    ed62:	ea41 0180 	orr.w	r1, r1, r0, lsl #2
                    psEnc->state_Fxx[ n ].sCmn.LBRR_flag = LBRR_symbol > 0 ? 1 : 0;
    ed66:	2900      	cmp	r1, #0
    ed68:	bfcc      	ite	gt
    ed6a:	2001      	movgt	r0, #1
    ed6c:	2000      	movle	r0, #0
    ed6e:	f80a 0002 	strb.w	r0, [sl, r2]
                    if( LBRR_symbol && psEnc->state_Fxx[ n ].sCmn.nFramesPerPacket > 1 ) {
    ed72:	d009      	beq.n	ed88 <silk_Encode+0xbb0>
                        ec_enc_icdf( psRangeEnc, LBRR_symbol - 1, silk_LBRR_flags_iCDF_ptr[ psEnc->state_Fxx[ n ].sCmn.nFramesPerPacket - 2 ], 8 );
    ed74:	3b02      	subs	r3, #2
    ed76:	4ac2      	ldr	r2, [pc, #776]	; (f080 <silk_Encode+0xea8>)
    ed78:	f8d7 00b0 	ldr.w	r0, [r7, #176]	; 0xb0
    ed7c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    ed80:	3901      	subs	r1, #1
    ed82:	2308      	movs	r3, #8
    ed84:	f01b f87c 	bl	29e80 <ec_enc_icdf>
                for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    ed88:	f8db 3004 	ldr.w	r3, [fp, #4]
                for( i = 0; i < psEnc->state_Fxx[ 0 ].sCmn.nFramesPerPacket; i++ ) {
    ed8c:	f85a 2004 	ldr.w	r2, [sl, r4]
    ed90:	2a00      	cmp	r2, #0
    ed92:	dd60      	ble.n	ee56 <silk_Encode+0xc7e>
    ed94:	f50a 4287 	add.w	r2, sl, #17280	; 0x4380
                                condCoding = CODE_INDEPENDENTLY;
    ed98:	2500      	movs	r5, #0
    ed9a:	3212      	adds	r2, #18
                                if( psEnc->state_Fxx[ 1 ].sCmn.LBRR_flags[ i ] == 0 ) {
    ed9c:	f8c7 b02c 	str.w	fp, [r7, #44]	; 0x2c
    eda0:	f8d7 b0b0 	ldr.w	fp, [r7, #176]	; 0xb0
    eda4:	f8c7 a024 	str.w	sl, [r7, #36]	; 0x24
    eda8:	617a      	str	r2, [r7, #20]
    edaa:	607e      	str	r6, [r7, #4]
    edac:	46aa      	mov	sl, r5
                    for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    edae:	2b00      	cmp	r3, #0
    edb0:	dd45      	ble.n	ee3e <silk_Encode+0xc66>
    edb2:	eb05 0185 	add.w	r1, r5, r5, lsl #2
    edb6:	0189      	lsls	r1, r1, #6
                                if( psEnc->state_Fxx[ 1 ].sCmn.LBRR_flags[ i ] == 0 ) {
    edb8:	f50a 5250 	add.w	r2, sl, #13312	; 0x3400
    edbc:	6339      	str	r1, [r7, #48]	; 0x30
    edbe:	6a79      	ldr	r1, [r7, #36]	; 0x24
    edc0:	697c      	ldr	r4, [r7, #20]
    edc2:	322c      	adds	r2, #44	; 0x2c
    edc4:	188a      	adds	r2, r1, r2
    edc6:	eb05 0045 	add.w	r0, r5, r5, lsl #1
    edca:	eb04 0040 	add.w	r0, r4, r0, lsl #1
    edce:	60fa      	str	r2, [r7, #12]
    edd0:	6e7c      	ldr	r4, [r7, #100]	; 0x64
    edd2:	6138      	str	r0, [r7, #16]
    edd4:	eb0a 02ca 	add.w	r2, sl, sl, lsl #3
    edd8:	643a      	str	r2, [r7, #64]	; 0x40
                    for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    edda:	2600      	movs	r6, #0
    eddc:	eb04 020a 	add.w	r2, r4, sl
                        if( psEnc->state_Fxx[ n ].sCmn.LBRR_flags[ i ] ) {
    ede0:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
    ede4:	b321      	cbz	r1, ee30 <silk_Encode+0xc58>
                            if( encControl->nChannelsInternal == 2 && n == 0 ) {
    ede6:	2b02      	cmp	r3, #2
    ede8:	f000 812e 	beq.w	f048 <silk_Encode+0xe70>
                            if( i > 0 && psEnc->state_Fxx[ n ].sCmn.LBRR_flags[ i - 1 ] ) {
    edec:	2d00      	cmp	r5, #0
    edee:	f000 8145 	beq.w	f07c <silk_Encode+0xea4>
    edf2:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
                                condCoding = CODE_CONDITIONALLY;
    edf6:	2a00      	cmp	r2, #0
    edf8:	bf18      	it	ne
    edfa:	2202      	movne	r2, #2
                            silk_encode_indices( &psEnc->state_Fxx[ n ].sCmn, psRangeEnc, i, 1, condCoding );
    edfc:	f5a4 508f 	sub.w	r0, r4, #4576	; 0x11e0
    ee00:	2301      	movs	r3, #1
    ee02:	9200      	str	r2, [sp, #0]
    ee04:	3808      	subs	r0, #8
    ee06:	462a      	mov	r2, r5
    ee08:	4659      	mov	r1, fp
    ee0a:	f000 f9f9 	bl	f200 <silk_encode_indices>
    ee0e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
                            silk_encode_pulses( psRangeEnc, psEnc->state_Fxx[ n ].sCmn.indices_LBRR[i].signalType, psEnc->state_Fxx[ n ].sCmn.indices_LBRR[i].quantOffsetType,
    ee10:	6820      	ldr	r0, [r4, #0]
    ee12:	18e1      	adds	r1, r4, r3
    ee14:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    ee16:	f991 260a 	ldrsb.w	r2, [r1, #1546]	; 0x60a
    ee1a:	f991 1609 	ldrsb.w	r1, [r1, #1545]	; 0x609
    ee1e:	9000      	str	r0, [sp, #0]
    ee20:	f503 63cb 	add.w	r3, r3, #1624	; 0x658
    ee24:	4423      	add	r3, r4
    ee26:	4658      	mov	r0, fp
    ee28:	f000 fb82 	bl	f530 <silk_encode_pulses>
    ee2c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    ee2e:	685b      	ldr	r3, [r3, #4]
                    for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    ee30:	3601      	adds	r6, #1
    ee32:	f504 5406 	add.w	r4, r4, #8576	; 0x2180
    ee36:	429e      	cmp	r6, r3
    ee38:	f104 0438 	add.w	r4, r4, #56	; 0x38
    ee3c:	dbce      	blt.n	eddc <silk_Encode+0xc04>
                for( i = 0; i < psEnc->state_Fxx[ 0 ].sCmn.nFramesPerPacket; i++ ) {
    ee3e:	f8d8 2000 	ldr.w	r2, [r8]
    ee42:	3501      	adds	r5, #1
    ee44:	42aa      	cmp	r2, r5
    ee46:	f10a 0a04 	add.w	sl, sl, #4
    ee4a:	dcb0      	bgt.n	edae <silk_Encode+0xbd6>
    ee4c:	687e      	ldr	r6, [r7, #4]
    ee4e:	f8d7 a024 	ldr.w	sl, [r7, #36]	; 0x24
    ee52:	f8d7 b02c 	ldr.w	fp, [r7, #44]	; 0x2c
                for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    ee56:	2b00      	cmp	r3, #0
    ee58:	dd0e      	ble.n	ee78 <silk_Encode+0xca0>
    ee5a:	f50a 5393 	add.w	r3, sl, #4704	; 0x1260
    ee5e:	3314      	adds	r3, #20
                    silk_memset( psEnc->state_Fxx[ n ].sCmn.LBRR_flags, 0, sizeof( psEnc->state_Fxx[ n ].sCmn.LBRR_flags ) );
    ee60:	2200      	movs	r2, #0
    ee62:	f242 10b8 	movw	r0, #8632	; 0x21b8
    ee66:	601a      	str	r2, [r3, #0]
    ee68:	605a      	str	r2, [r3, #4]
    ee6a:	609a      	str	r2, [r3, #8]
                for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    ee6c:	f8db 1004 	ldr.w	r1, [fp, #4]
    ee70:	3601      	adds	r6, #1
    ee72:	42b1      	cmp	r1, r6
    ee74:	4403      	add	r3, r0
    ee76:	dcf6      	bgt.n	ee66 <silk_Encode+0xc8e>
    ee78:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
    ee7c:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
    ee80:	69db      	ldr	r3, [r3, #28]
    ee82:	6952      	ldr	r2, [r2, #20]
    ee84:	fab3 f383 	clz	r3, r3
                psEnc->nBitsUsedLBRR = ec_tell( psRangeEnc );
    ee88:	f244 35a8 	movw	r5, #17320	; 0x43a8
    ee8c:	f1c3 0320 	rsb	r3, r3, #32
    ee90:	1ad3      	subs	r3, r2, r3
    ee92:	f84a 3005 	str.w	r3, [sl, r5]
            silk_HP_variable_cutoff( psEnc->state_Fxx );
    ee96:	4650      	mov	r0, sl
    ee98:	f005 fb2a 	bl	144f0 <silk_HP_variable_cutoff>
            nBits = silk_DIV32_16( silk_MUL( encControl->bitRate, encControl->payloadSize_ms ), 1000 );
    ee9c:	e9db 2406 	ldrd	r2, r4, [fp, #24]
    eea0:	4978      	ldr	r1, [pc, #480]	; (f084 <silk_Encode+0xeac>)
    eea2:	fb02 f304 	mul.w	r3, r2, r4
    eea6:	fb81 0103 	smull	r0, r1, r1, r3
    eeaa:	17db      	asrs	r3, r3, #31
                psEnc->nBitsUsedLBRR = ec_tell( psRangeEnc );
    eeac:	4455      	add	r5, sl
            nBits = silk_DIV32_16( silk_MUL( encControl->bitRate, encControl->payloadSize_ms ), 1000 );
    eeae:	ebc3 13a1 	rsb	r3, r3, r1, asr #6
    eeb2:	e435      	b.n	e720 <silk_Encode+0x548>
        for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    eeb4:	4694      	mov	ip, r2
    tot_blocks = ( nBlocksOf10ms > 1 ) ? nBlocksOf10ms >> 1 : 1;
    eeb6:	2301      	movs	r3, #1
    eeb8:	653b      	str	r3, [r7, #80]	; 0x50
    eeba:	f7ff b9fa 	b.w	e2b2 <silk_Encode+0xda>
            opus_int id = psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded;
    eebe:	f241 6374 	movw	r3, #5748	; 0x1674
            for( n = 0; n < nSamplesFromInput; n++ ) {
    eec2:	2c00      	cmp	r4, #0
            opus_int id = psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded;
    eec4:	f85a 0003 	ldr.w	r0, [sl, r3]
            for( n = 0; n < nSamplesFromInput; n++ ) {
    eec8:	dd0a      	ble.n	eee0 <silk_Encode+0xd08>
    eeca:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    eecc:	6ebe      	ldr	r6, [r7, #104]	; 0x68
    eece:	1e9a      	subs	r2, r3, #2
    eed0:	2300      	movs	r3, #0
                buf[ n ] = samplesIn[ 2 * n ];
    eed2:	f836 1023 	ldrh.w	r1, [r6, r3, lsl #2]
    eed6:	f822 1f02 	strh.w	r1, [r2, #2]!
            for( n = 0; n < nSamplesFromInput; n++ ) {
    eeda:	3301      	adds	r3, #1
    eedc:	429c      	cmp	r4, r3
    eede:	d1f8      	bne.n	eed2 <silk_Encode+0xcfa>
            if( psEnc->nPrevChannelsInternal == 1 && id==0 ) {
    eee0:	6a3b      	ldr	r3, [r7, #32]
    eee2:	681b      	ldr	r3, [r3, #0]
    eee4:	f50a 5661 	add.w	r6, sl, #14400	; 0x3840
    eee8:	2b01      	cmp	r3, #1
    eeea:	f106 0608 	add.w	r6, r6, #8
    eeee:	f000 80e4 	beq.w	f0ba <silk_Encode+0xee2>
            ret += silk_resampler( &psEnc->state_Fxx[ 0 ].sCmn.resampler_state,
    eef2:	f605 11f6 	addw	r1, r5, #2550	; 0x9f6
    eef6:	eb0a 0141 	add.w	r1, sl, r1, lsl #1
    eefa:	4623      	mov	r3, r4
    eefc:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
    eefe:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
    ef00:	f009 fef8 	bl	18cf4 <silk_resampler>
            nSamplesToBuffer  = silk_min( nSamplesToBuffer, 10 * nBlocksOf10ms * psEnc->state_Fxx[ 1 ].sCmn.fs_kHz );
    ef04:	f243 3398 	movw	r3, #13208	; 0x3398
            nSamplesToBuffer  = psEnc->state_Fxx[ 1 ].sCmn.frame_length - psEnc->state_Fxx[ 1 ].sCmn.inputBufIx;
    ef08:	f643 0824 	movw	r8, #14372	; 0x3824
            nSamplesToBuffer  = silk_min( nSamplesToBuffer, 10 * nBlocksOf10ms * psEnc->state_Fxx[ 1 ].sCmn.fs_kHz );
    ef0c:	f85a 5003 	ldr.w	r5, [sl, r3]
            psEnc->state_Fxx[ 0 ].sCmn.inputBufIx += nSamplesToBuffer;
    ef10:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
            nSamplesToBuffer  = psEnc->state_Fxx[ 1 ].sCmn.frame_length - psEnc->state_Fxx[ 1 ].sCmn.inputBufIx;
    ef12:	f85a 1008 	ldr.w	r1, [sl, r8]
            psEnc->state_Fxx[ 0 ].sCmn.inputBufIx += nSamplesToBuffer;
    ef16:	681b      	ldr	r3, [r3, #0]
    ef18:	643b      	str	r3, [r7, #64]	; 0x40
            nSamplesToBuffer  = psEnc->state_Fxx[ 1 ].sCmn.frame_length - psEnc->state_Fxx[ 1 ].sCmn.inputBufIx;
    ef1a:	f243 32a0 	movw	r2, #13216	; 0x33a0
            nSamplesToBuffer  = silk_min( nSamplesToBuffer, 10 * nBlocksOf10ms * psEnc->state_Fxx[ 1 ].sCmn.fs_kHz );
    ef1e:	68bb      	ldr	r3, [r7, #8]
            nSamplesToBuffer  = psEnc->state_Fxx[ 1 ].sCmn.frame_length - psEnc->state_Fxx[ 1 ].sCmn.inputBufIx;
    ef20:	f85a 2002 	ldr.w	r2, [sl, r2]
            nSamplesToBuffer  = silk_min( nSamplesToBuffer, 10 * nBlocksOf10ms * psEnc->state_Fxx[ 1 ].sCmn.fs_kHz );
    ef24:	fb05 f503 	mul.w	r5, r5, r3
            psEnc->state_Fxx[ 0 ].sCmn.inputBufIx += nSamplesToBuffer;
    ef28:	6c3b      	ldr	r3, [r7, #64]	; 0x40
            nSamplesToBuffer  = psEnc->state_Fxx[ 1 ].sCmn.frame_length - psEnc->state_Fxx[ 1 ].sCmn.inputBufIx;
    ef2a:	1a52      	subs	r2, r2, r1
            psEnc->state_Fxx[ 0 ].sCmn.inputBufIx += nSamplesToBuffer;
    ef2c:	444b      	add	r3, r9
            nSamplesToBuffer  = silk_min( nSamplesToBuffer, 10 * nBlocksOf10ms * psEnc->state_Fxx[ 1 ].sCmn.fs_kHz );
    ef2e:	4295      	cmp	r5, r2
            psEnc->state_Fxx[ 0 ].sCmn.inputBufIx += nSamplesToBuffer;
    ef30:	469c      	mov	ip, r3
            ret += silk_resampler( &psEnc->state_Fxx[ 0 ].sCmn.resampler_state,
    ef32:	6dbb      	ldr	r3, [r7, #88]	; 0x58
            nSamplesToBuffer  = silk_min( nSamplesToBuffer, 10 * nBlocksOf10ms * psEnc->state_Fxx[ 1 ].sCmn.fs_kHz );
    ef34:	bfa8      	it	ge
    ef36:	4615      	movge	r5, r2
            psEnc->state_Fxx[ 0 ].sCmn.inputBufIx += nSamplesToBuffer;
    ef38:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
            ret += silk_resampler( &psEnc->state_Fxx[ 0 ].sCmn.resampler_state,
    ef3a:	4699      	mov	r9, r3
            for( n = 0; n < nSamplesFromInput; n++ ) {
    ef3c:	2c00      	cmp	r4, #0
            ret += silk_resampler( &psEnc->state_Fxx[ 0 ].sCmn.resampler_state,
    ef3e:	4481      	add	r9, r0
            psEnc->state_Fxx[ 0 ].sCmn.inputBufIx += nSamplesToBuffer;
    ef40:	f8c2 c000 	str.w	ip, [r2]
            for( n = 0; n < nSamplesFromInput; n++ ) {
    ef44:	dd0c      	ble.n	ef60 <silk_Encode+0xd88>
    ef46:	6eb8      	ldr	r0, [r7, #104]	; 0x68
    ef48:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
    ef4a:	4603      	mov	r3, r0
    ef4c:	3a02      	subs	r2, #2
    ef4e:	eb00 0084 	add.w	r0, r0, r4, lsl #2
                buf[ n ] = samplesIn[ 2 * n + 1 ];
    ef52:	f8b3 c002 	ldrh.w	ip, [r3, #2]
    ef56:	f822 cf02 	strh.w	ip, [r2, #2]!
    ef5a:	3304      	adds	r3, #4
            for( n = 0; n < nSamplesFromInput; n++ ) {
    ef5c:	4298      	cmp	r0, r3
    ef5e:	d1f8      	bne.n	ef52 <silk_Encode+0xd7a>
            ret += silk_resampler( &psEnc->state_Fxx[ 1 ].sCmn.resampler_state,
    ef60:	f501 51d6 	add.w	r1, r1, #6848	; 0x1ac0
    ef64:	3112      	adds	r1, #18
    ef66:	eb0a 0141 	add.w	r1, sl, r1, lsl #1
    ef6a:	4623      	mov	r3, r4
    ef6c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
    ef6e:	4630      	mov	r0, r6
    ef70:	f009 fec0 	bl	18cf4 <silk_resampler>
            psEnc->state_Fxx[ 1 ].sCmn.inputBufIx += nSamplesToBuffer;
    ef74:	f85a 1008 	ldr.w	r1, [sl, r8]
    ef78:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    ef7a:	6e7a      	ldr	r2, [r7, #100]	; 0x64
    ef7c:	681b      	ldr	r3, [r3, #0]
    ef7e:	6812      	ldr	r2, [r2, #0]
    ef80:	440d      	add	r5, r1
            ret += silk_resampler( &psEnc->state_Fxx[ 1 ].sCmn.resampler_state,
    ef82:	eb09 0100 	add.w	r1, r9, r0
    ef86:	65b9      	str	r1, [r7, #88]	; 0x58
            psEnc->state_Fxx[ 1 ].sCmn.inputBufIx += nSamplesToBuffer;
    ef88:	f84a 5008 	str.w	r5, [sl, r8]
        if( encControl->nChannelsAPI == 2 && encControl->nChannelsInternal == 2 ) {
    ef8c:	f7ff bb97 	b.w	e6be <silk_Encode+0x4e6>
                        condCoding = CODE_INDEPENDENTLY;
    ef90:	2300      	movs	r3, #0
    ef92:	e4d9      	b.n	e948 <silk_Encode+0x770>
                    psEnc->allowBandwidthSwitch = 0;
    ef94:	6cba      	ldr	r2, [r7, #72]	; 0x48
                    psEnc->timeSinceSwitchAllowed_ms += encControl->payloadSize_ms;
    ef96:	4430      	add	r0, r6
                    psEnc->allowBandwidthSwitch = 0;
    ef98:	2300      	movs	r3, #0
    ef9a:	6013      	str	r3, [r2, #0]
                    psEnc->timeSinceSwitchAllowed_ms += encControl->payloadSize_ms;
    ef9c:	f84a 0004 	str.w	r0, [sl, r4]
    efa0:	f7ff bb51 	b.w	e646 <silk_Encode+0x46e>
        encControl->payloadSize_ms = 10;
    efa4:	220a      	movs	r2, #10
        encControl->complexity = 0;
    efa6:	2300      	movs	r3, #0
        encControl->payloadSize_ms = 10;
    efa8:	f8cb 2018 	str.w	r2, [fp, #24]
        tmp_complexity = encControl->complexity;
    efac:	f8db 2024 	ldr.w	r2, [fp, #36]	; 0x24
    efb0:	62ba      	str	r2, [r7, #40]	; 0x28
        encControl->complexity = 0;
    efb2:	f8cb 3024 	str.w	r3, [fp, #36]	; 0x24
    efb6:	e77e      	b.n	eeb6 <silk_Encode+0xcde>
                    ec_enc_patch_initial_bits( psRangeEnc, flags, ( psEnc->state_Fxx[ 0 ].sCmn.nFramesPerPacket + 1 ) * encControl->nChannelsInternal );
    efb8:	fb00 2202 	mla	r2, r0, r2, r2
    efbc:	f8d7 00b0 	ldr.w	r0, [r7, #176]	; 0xb0
    efc0:	f01b f862 	bl	2a088 <ec_enc_patch_initial_bits>
    efc4:	e596      	b.n	eaf4 <silk_Encode+0x91c>
            if( psEnc->nPrevChannelsInternal == 2 && psEnc->state_Fxx[ 0 ].sCmn.nFramesEncoded == 0 ) {
    efc6:	f241 6374 	movw	r3, #5748	; 0x1674
    efca:	f85a 3003 	ldr.w	r3, [sl, r3]
    efce:	2b00      	cmp	r3, #0
    efd0:	f47f ac44 	bne.w	e85c <silk_Encode+0x684>
                   &psEnc->state_Fxx[ 1 ].sCmn.inputBuf[ psEnc->state_Fxx[ 1 ].sCmn.inputBufIx + 2 ], buf, nSamplesFromInput );
    efd4:	f643 0524 	movw	r5, #14372	; 0x3824
               ret += silk_resampler( &psEnc->state_Fxx[ 1 ].sCmn.resampler_state,
    efd8:	f50a 5061 	add.w	r0, sl, #14400	; 0x3840
                   &psEnc->state_Fxx[ 1 ].sCmn.inputBuf[ psEnc->state_Fxx[ 1 ].sCmn.inputBufIx + 2 ], buf, nSamplesFromInput );
    efdc:	f85a 1005 	ldr.w	r1, [sl, r5]
               ret += silk_resampler( &psEnc->state_Fxx[ 1 ].sCmn.resampler_state,
    efe0:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
    efe2:	f501 51d6 	add.w	r1, r1, #6848	; 0x1ac0
    efe6:	3112      	adds	r1, #18
    efe8:	4623      	mov	r3, r4
    efea:	eb0a 0141 	add.w	r1, sl, r1, lsl #1
    efee:	3008      	adds	r0, #8
    eff0:	f009 fe80 	bl	18cf4 <silk_resampler>
               for( n = 0; n < psEnc->state_Fxx[ 0 ].sCmn.frame_length; n++ ) {
    eff4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
    eff6:	681a      	ldr	r2, [r3, #0]
               ret += silk_resampler( &psEnc->state_Fxx[ 1 ].sCmn.resampler_state,
    eff8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
               for( n = 0; n < psEnc->state_Fxx[ 0 ].sCmn.frame_length; n++ ) {
    effa:	2a00      	cmp	r2, #0
               ret += silk_resampler( &psEnc->state_Fxx[ 1 ].sCmn.resampler_state,
    effc:	4403      	add	r3, r0
    effe:	65bb      	str	r3, [r7, #88]	; 0x58
               for( n = 0; n < psEnc->state_Fxx[ 0 ].sCmn.frame_length; n++ ) {
    f000:	f340 80f4 	ble.w	f1ec <silk_Encode+0x1014>
                        silk_RSHIFT(psEnc->state_Fxx[ 0 ].sCmn.inputBuf[ psEnc->state_Fxx[ 0 ].sCmn.inputBufIx+n+2 ]
    f004:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    f006:	f85a 1005 	ldr.w	r1, [sl, r5]
    f00a:	681b      	ldr	r3, [r3, #0]
    f00c:	f501 56d6 	add.w	r6, r1, #6848	; 0x1ac0
    f010:	f50a 5056 	add.w	r0, sl, #13696	; 0x3580
    f014:	eb0a 0543 	add.w	r5, sl, r3, lsl #1
    f018:	3612      	adds	r6, #18
    f01a:	4411      	add	r1, r2
    f01c:	3024      	adds	r0, #36	; 0x24
    f01e:	f505 559f 	add.w	r5, r5, #5088	; 0x13e0
    f022:	eb0a 0646 	add.w	r6, sl, r6, lsl #1
    f026:	eb00 0c41 	add.w	ip, r0, r1, lsl #1
    f02a:	350a      	adds	r5, #10
    f02c:	f936 0b02 	ldrsh.w	r0, [r6], #2
    f030:	f935 1f02 	ldrsh.w	r1, [r5, #2]!
    f034:	4401      	add	r1, r0
    f036:	1049      	asrs	r1, r1, #1
               for( n = 0; n < psEnc->state_Fxx[ 0 ].sCmn.frame_length; n++ ) {
    f038:	45b4      	cmp	ip, r6
                  psEnc->state_Fxx[ 0 ].sCmn.inputBuf[ psEnc->state_Fxx[ 0 ].sCmn.inputBufIx+n+2 ] =
    f03a:	8029      	strh	r1, [r5, #0]
               for( n = 0; n < psEnc->state_Fxx[ 0 ].sCmn.frame_length; n++ ) {
    f03c:	d1f6      	bne.n	f02c <silk_Encode+0xe54>
    f03e:	e411      	b.n	e864 <silk_Encode+0x68c>
                for( i = 0; i < psEnc->state_Fxx[ 0 ].sCmn.nFramesPerPacket; i++ ) {
    f040:	2a00      	cmp	r2, #0
    f042:	f73f aea7 	bgt.w	ed94 <silk_Encode+0xbbc>
    f046:	e717      	b.n	ee78 <silk_Encode+0xca0>
                            if( encControl->nChannelsInternal == 2 && n == 0 ) {
    f048:	2e00      	cmp	r6, #0
    f04a:	f47f aecf 	bne.w	edec <silk_Encode+0xc14>
                                silk_stereo_encode_pred( psRangeEnc, psEnc->sStereo.predIx[ i ] );
    f04e:	6939      	ldr	r1, [r7, #16]
    f050:	603a      	str	r2, [r7, #0]
    f052:	4658      	mov	r0, fp
    f054:	f00a ffea 	bl	1a02c <silk_stereo_encode_pred>
                                if( psEnc->state_Fxx[ 1 ].sCmn.LBRR_flags[ i ] == 0 ) {
    f058:	68fb      	ldr	r3, [r7, #12]
    f05a:	683a      	ldr	r2, [r7, #0]
    f05c:	681b      	ldr	r3, [r3, #0]
    f05e:	2b00      	cmp	r3, #0
    f060:	f47f aec4 	bne.w	edec <silk_Encode+0xc14>
                                    silk_stereo_encode_mid_only( psRangeEnc, psEnc->sStereo.mid_only_flags[ i ] );
    f064:	f505 4387 	add.w	r3, r5, #17280	; 0x4380
    f068:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    f06a:	3324      	adds	r3, #36	; 0x24
    f06c:	4658      	mov	r0, fp
    f06e:	56d1      	ldrsb	r1, [r2, r3]
    f070:	f00b f812 	bl	1a098 <silk_stereo_encode_mid_only>
    f074:	683a      	ldr	r2, [r7, #0]
                            if( i > 0 && psEnc->state_Fxx[ n ].sCmn.LBRR_flags[ i - 1 ] ) {
    f076:	2d00      	cmp	r5, #0
    f078:	f47f aebb 	bne.w	edf2 <silk_Encode+0xc1a>
                                condCoding = CODE_INDEPENDENTLY;
    f07c:	462a      	mov	r2, r5
    f07e:	e6bd      	b.n	edfc <silk_Encode+0xc24>
    f080:	00036c64 	.word	0x00036c64
    f084:	10624dd3 	.word	0x10624dd3
                    psEnc->state_Fxx[ n ].sCmn.LBRR_flag = LBRR_symbol > 0 ? 1 : 0;
    f088:	2900      	cmp	r1, #0
    f08a:	f241 2073 	movw	r0, #4723	; 0x1273
    f08e:	bfcc      	ite	gt
    f090:	2501      	movgt	r5, #1
    f092:	2500      	movle	r5, #0
    f094:	f80a 5000 	strb.w	r5, [sl, r0]
                    if( LBRR_symbol && psEnc->state_Fxx[ n ].sCmn.nFramesPerPacket > 1 ) {
    f098:	d03b      	beq.n	f112 <silk_Encode+0xf3a>
                        ec_enc_icdf( psRangeEnc, LBRR_symbol - 1, silk_LBRR_flags_iCDF_ptr[ psEnc->state_Fxx[ n ].sCmn.nFramesPerPacket - 2 ], 8 );
    f09a:	4b58      	ldr	r3, [pc, #352]	; (f1fc <silk_Encode+0x1024>)
    f09c:	f8d7 00b0 	ldr.w	r0, [r7, #176]	; 0xb0
    f0a0:	3a02      	subs	r2, #2
    f0a2:	3901      	subs	r1, #1
    f0a4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    f0a8:	2308      	movs	r3, #8
    f0aa:	f01a fee9 	bl	29e80 <ec_enc_icdf>
    f0ae:	f8db 3004 	ldr.w	r3, [fp, #4]
                for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    f0b2:	2b01      	cmp	r3, #1
    f0b4:	f73f ae38 	bgt.w	ed28 <silk_Encode+0xb50>
    f0b8:	e668      	b.n	ed8c <silk_Encode+0xbb4>
            if( psEnc->nPrevChannelsInternal == 1 && id==0 ) {
    f0ba:	2800      	cmp	r0, #0
    f0bc:	f47f af19 	bne.w	eef2 <silk_Encode+0xd1a>
               silk_memcpy( &psEnc->state_Fxx[ 1 ].sCmn.resampler_state, &psEnc->state_Fxx[ 0 ].sCmn.resampler_state, sizeof(psEnc->state_Fxx[ 1 ].sCmn.resampler_state));
    f0c0:	f44f 7296 	mov.w	r2, #300	; 0x12c
    f0c4:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
    f0c6:	4630      	mov	r0, r6
    f0c8:	f7fd f81a 	bl	c100 <memcpy>
    f0cc:	e711      	b.n	eef2 <silk_Encode+0xd1a>
    f0ce:	f509 4387 	add.w	r3, r9, #17280	; 0x4380
    f0d2:	3340      	adds	r3, #64	; 0x40
    f0d4:	64bb      	str	r3, [r7, #72]	; 0x48
    f0d6:	f7ff b9a0 	b.w	e41a <silk_Encode+0x242>
                    for( i = 0; i < psEnc->state_Fxx[ n ].sCmn.nFramesPerPacket; i++ ) {
    f0da:	2400      	movs	r4, #0
    f0dc:	e46a      	b.n	e9b4 <silk_Encode+0x7dc>
            silk_memcpy( &psEnc->state_Fxx[ 1 ].sCmn.resampler_state, &psEnc->state_Fxx[ 0 ].sCmn.resampler_state, sizeof( silk_resampler_state_struct ) );
    f0de:	f509 51b4 	add.w	r1, r9, #5760	; 0x1680
    f0e2:	f509 5061 	add.w	r0, r9, #14400	; 0x3840
    f0e6:	3110      	adds	r1, #16
    f0e8:	3008      	adds	r0, #8
    f0ea:	f44f 7296 	mov.w	r2, #300	; 0x12c
    f0ee:	f7fd f807 	bl	c100 <memcpy>
            silk_memcpy( &psEnc->state_Fxx[ 1 ].sCmn.In_HP_State,     &psEnc->state_Fxx[ 0 ].sCmn.In_HP_State,     sizeof( psEnc->state_Fxx[ 1 ].sCmn.In_HP_State ) );
    f0f2:	f8d9 3000 	ldr.w	r3, [r9]
    f0f6:	f849 3005 	str.w	r3, [r9, r5]
    f0fa:	f8d9 3004 	ldr.w	r3, [r9, #4]
    f0fe:	6063      	str	r3, [r4, #4]
    f100:	e4c7      	b.n	ea92 <silk_Encode+0x8ba>
                    psEnc->state_Fxx[ n ].sCmn.LBRR_flag = LBRR_symbol > 0 ? 1 : 0;
    f102:	2900      	cmp	r1, #0
    f104:	f241 2273 	movw	r2, #4723	; 0x1273
    f108:	bfd4      	ite	le
    f10a:	2100      	movle	r1, #0
    f10c:	2101      	movgt	r1, #1
    f10e:	f80a 1002 	strb.w	r1, [sl, r2]
                for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    f112:	2b01      	cmp	r3, #1
    f114:	f43f ae3e 	beq.w	ed94 <silk_Encode+0xbbc>
    f118:	e606      	b.n	ed28 <silk_Encode+0xb50>
                        silk_memset( &psEnc->state_Fxx[ 1 ].sShape,               0, sizeof( psEnc->state_Fxx[ 1 ].sShape ) );
    f11a:	f50a 5376 	add.w	r3, sl, #15744	; 0x3d80
    f11e:	3338      	adds	r3, #56	; 0x38
    f120:	f643 52b8 	movw	r2, #15800	; 0x3db8
                        silk_memset( &psEnc->state_Fxx[ 1 ].sCmn.sNSQ,            0, sizeof( psEnc->state_Fxx[ 1 ].sCmn.sNSQ ) );
    f124:	f50a 5009 	add.w	r0, sl, #8768	; 0x2240
                        silk_memset( &psEnc->state_Fxx[ 1 ].sShape,               0, sizeof( psEnc->state_Fxx[ 1 ].sShape ) );
    f128:	f84a 6002 	str.w	r6, [sl, r2]
                        silk_memset( &psEnc->state_Fxx[ 1 ].sCmn.sNSQ,            0, sizeof( psEnc->state_Fxx[ 1 ].sCmn.sNSQ ) );
    f12c:	4631      	mov	r1, r6
                        silk_memset( &psEnc->state_Fxx[ 1 ].sShape,               0, sizeof( psEnc->state_Fxx[ 1 ].sShape ) );
    f12e:	605e      	str	r6, [r3, #4]
    f130:	609e      	str	r6, [r3, #8]
    f132:	60de      	str	r6, [r3, #12]
                        silk_memset( &psEnc->state_Fxx[ 1 ].sCmn.sNSQ,            0, sizeof( psEnc->state_Fxx[ 1 ].sCmn.sNSQ ) );
    f134:	f44f 5288 	mov.w	r2, #4352	; 0x1100
    f138:	300c      	adds	r0, #12
    f13a:	f026 f813 	bl	35164 <memset>
                        silk_memset( psEnc->state_Fxx[ 1 ].sCmn.prev_NLSFq_Q15,   0, sizeof( psEnc->state_Fxx[ 1 ].sCmn.prev_NLSFq_Q15 ) );
    f13e:	f50a 504d 	add.w	r0, sl, #13120	; 0x3340
    f142:	2220      	movs	r2, #32
    f144:	4631      	mov	r1, r6
    f146:	300c      	adds	r0, #12
    f148:	f026 f80c 	bl	35164 <memset>
                        silk_memset( &psEnc->state_Fxx[ 1 ].sCmn.sLP.In_LP_State, 0, sizeof( psEnc->state_Fxx[ 1 ].sCmn.sLP.In_LP_State ) );
    f14c:	f242 13c8 	movw	r3, #8648	; 0x21c8
    f150:	eb0a 0203 	add.w	r2, sl, r3
    f154:	f84a 6003 	str.w	r6, [sl, r3]
    f158:	6056      	str	r6, [r2, #4]
                        psEnc->state_Fxx[ 1 ].sShape.LastGainIndex         = 10;
    f15a:	f643 52b8 	movw	r2, #15800	; 0x3db8
                        psEnc->state_Fxx[ 1 ].sCmn.prevLag                 = 100;
    f15e:	f243 3078 	movw	r0, #13176	; 0x3378
                        psEnc->state_Fxx[ 1 ].sShape.LastGainIndex         = 10;
    f162:	230a      	movs	r3, #10
                        psEnc->state_Fxx[ 1 ].sCmn.sNSQ.lagPrev            = 100;
    f164:	f243 3134 	movw	r1, #13108	; 0x3334
                        psEnc->state_Fxx[ 1 ].sShape.LastGainIndex         = 10;
    f168:	f80a 3002 	strb.w	r3, [sl, r2]
                        psEnc->state_Fxx[ 1 ].sCmn.prevSignalType          = TYPE_NO_VOICE_ACTIVITY;
    f16c:	f243 3c75 	movw	ip, #13173	; 0x3375
                        psEnc->state_Fxx[ 1 ].sCmn.prevLag                 = 100;
    f170:	2364      	movs	r3, #100	; 0x64
                        psEnc->state_Fxx[ 1 ].sCmn.sNSQ.prev_gain_Q16      = 65536;
    f172:	f243 3244 	movw	r2, #13124	; 0x3344
                        psEnc->state_Fxx[ 1 ].sCmn.prevLag                 = 100;
    f176:	f84a 3000 	str.w	r3, [sl, r0]
                        psEnc->state_Fxx[ 1 ].sCmn.sNSQ.lagPrev            = 100;
    f17a:	f84a 3001 	str.w	r3, [sl, r1]
                        psEnc->state_Fxx[ 1 ].sCmn.first_frame_after_reset = 1;
    f17e:	f243 30f0 	movw	r0, #13296	; 0x33f0
                        psEnc->state_Fxx[ 1 ].sCmn.sNSQ.prev_gain_Q16      = 65536;
    f182:	f44f 3380 	mov.w	r3, #65536	; 0x10000
                        psEnc->state_Fxx[ 1 ].sCmn.prevSignalType          = TYPE_NO_VOICE_ACTIVITY;
    f186:	f80a 600c 	strb.w	r6, [sl, ip]
                        psEnc->state_Fxx[ 1 ].sCmn.sNSQ.prev_gain_Q16      = 65536;
    f18a:	f84a 3002 	str.w	r3, [sl, r2]
                        psEnc->state_Fxx[ 1 ].sCmn.first_frame_after_reset = 1;
    f18e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    f190:	f84a 3000 	str.w	r3, [sl, r0]
    f194:	e48b      	b.n	eaae <silk_Encode+0x8d6>
            return SILK_ENC_INPUT_INVALID_NO_OF_SAMPLES;
    f196:	f06f 0364 	mvn.w	r3, #100	; 0x64
    f19a:	657b      	str	r3, [r7, #84]	; 0x54
    f19c:	f7ff b930 	b.w	e400 <silk_Encode+0x228>
    f1a0:	0064      	lsls	r4, r4, #1
    f1a2:	e407      	b.n	e9b4 <silk_Encode+0x7dc>
                    psEnc->state_Fxx[ n ].sCmn.LBRR_flag = LBRR_symbol > 0 ? 1 : 0;
    f1a4:	f241 2273 	movw	r2, #4723	; 0x1273
    f1a8:	f8d7 10b8 	ldr.w	r1, [r7, #184]	; 0xb8
    f1ac:	f80a 1002 	strb.w	r1, [sl, r2]
                for( n = 0; n < encControl->nChannelsInternal; n++ ) {
    f1b0:	2b01      	cmp	r3, #1
    f1b2:	f47f adb9 	bne.w	ed28 <silk_Encode+0xb50>
    f1b6:	e650      	b.n	ee5a <silk_Encode+0xc82>
                    psEnc->state_Fxx[ n ].sCmn.LBRR_flag = LBRR_symbol > 0 ? 1 : 0;
    f1b8:	f243 432b 	movw	r3, #13355	; 0x342b
    f1bc:	2200      	movs	r2, #0
    f1be:	f80a 2003 	strb.w	r2, [sl, r3]
    f1c2:	e5e1      	b.n	ed88 <silk_Encode+0xbb0>
    f1c4:	2900      	cmp	r1, #0
    f1c6:	f243 432b 	movw	r3, #13355	; 0x342b
    f1ca:	bfd4      	ite	le
    f1cc:	2100      	movle	r1, #0
    f1ce:	2101      	movgt	r1, #1
    f1d0:	f80a 1003 	strb.w	r1, [sl, r3]
    f1d4:	e5d8      	b.n	ed88 <silk_Encode+0xbb0>
    f1d6:	2900      	cmp	r1, #0
    f1d8:	f243 422b 	movw	r2, #13355	; 0x342b
    f1dc:	bfcc      	ite	gt
    f1de:	2001      	movgt	r0, #1
    f1e0:	2000      	movle	r0, #0
    f1e2:	f80a 0002 	strb.w	r0, [sl, r2]
                    if( LBRR_symbol && psEnc->state_Fxx[ n ].sCmn.nFramesPerPacket > 1 ) {
    f1e6:	f47f adc5 	bne.w	ed74 <silk_Encode+0xb9c>
    f1ea:	e5cd      	b.n	ed88 <silk_Encode+0xbb0>
    f1ec:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    f1ee:	681b      	ldr	r3, [r3, #0]
    f1f0:	f7ff bb38 	b.w	e864 <silk_Encode+0x68c>
    tot_blocks = ( nBlocksOf10ms > 1 ) ? nBlocksOf10ms >> 1 : 1;
    f1f4:	2101      	movs	r1, #1
    f1f6:	6539      	str	r1, [r7, #80]	; 0x50
    f1f8:	f7ff b844 	b.w	e284 <silk_Encode+0xac>
    f1fc:	00036c64 	.word	0x00036c64

0000f200 <silk_encode_indices>:
    ec_enc                      *psRangeEnc,                    /* I/O  Compressor data structure                   */
    opus_int                    FrameIndex,                     /* I    Frame number                                */
    opus_int                    encode_LBRR,                    /* I    Flag indicating LBRR data is being encoded  */
    opus_int                    condCoding                      /* I    The type of conditional coding to use       */
)
{
    f200:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f204:	4681      	mov	r9, r0
    f206:	b08d      	sub	sp, #52	; 0x34
    f208:	460d      	mov	r5, r1
    opus_int   encode_absolute_lagIndex, delta_lagIndex;
    opus_int16 ec_ix[ MAX_LPC_ORDER ];
    opus_uint8 pred_Q8[ MAX_LPC_ORDER ];
    const SideInfoIndices *psIndices;

    if( encode_LBRR ) {
    f20a:	2b00      	cmp	r3, #0
    f20c:	f000 80bf 	beq.w	f38e <silk_encode_indices+0x18e>
         psIndices = &psEncC->indices_LBRR[ FrameIndex ];
    f210:	eb02 02c2 	add.w	r2, r2, r2, lsl #3
    f214:	0094      	lsls	r4, r2, #2
    }

    /*******************************************/
    /* Encode signal type and quantizer offset */
    /*******************************************/
    typeOffset = 2 * psIndices->signalType + psIndices->quantOffsetType;
    f216:	1903      	adds	r3, r0, r4
    f218:	f241 72f1 	movw	r2, #6129	; 0x17f1
    f21c:	f241 71f2 	movw	r1, #6130	; 0x17f2
         psIndices = &psEncC->indices_LBRR[ FrameIndex ];
    f220:	f504 54be 	add.w	r4, r4, #6080	; 0x17c0
    typeOffset = 2 * psIndices->signalType + psIndices->quantOffsetType;
    f224:	569a      	ldrsb	r2, [r3, r2]
    f226:	5659      	ldrsb	r1, [r3, r1]
         psIndices = &psEncC->indices_LBRR[ FrameIndex ];
    f228:	3414      	adds	r4, #20
    f22a:	4404      	add	r4, r0
    typeOffset = 2 * psIndices->signalType + psIndices->quantOffsetType;
    f22c:	eb01 0142 	add.w	r1, r1, r2, lsl #1
    celt_assert( typeOffset >= 0 && typeOffset < 6 );
    celt_assert( encode_LBRR == 0 || typeOffset >= 2 );
    if( encode_LBRR || typeOffset >= 2 ) {
        ec_enc_icdf( psRangeEnc, typeOffset - 2, silk_type_offset_VAD_iCDF, 8 );
    f230:	3902      	subs	r1, #2
    f232:	2308      	movs	r3, #8
    f234:	4ab1      	ldr	r2, [pc, #708]	; (f4fc <silk_encode_indices+0x2fc>)
    f236:	4628      	mov	r0, r5
    f238:	f01a fe22 	bl	29e80 <ec_enc_icdf>

    /****************/
    /* Encode gains */
    /****************/
    /* first subframe */
    if( condCoding == CODE_CONDITIONALLY ) {
    f23c:	9b16      	ldr	r3, [sp, #88]	; 0x58
    f23e:	f994 1000 	ldrsb.w	r1, [r4]
    f242:	2b02      	cmp	r3, #2
    f244:	f000 80b9 	beq.w	f3ba <silk_encode_indices+0x1ba>
        silk_assert( psIndices->GainsIndices[ 0 ] >= 0 && psIndices->GainsIndices[ 0 ] < MAX_DELTA_GAIN_QUANT - MIN_DELTA_GAIN_QUANT + 1 );
        ec_enc_icdf( psRangeEnc, psIndices->GainsIndices[ 0 ], silk_delta_gain_iCDF, 8 );
    } else {
        /* independent coding, in two stages: MSB bits followed by 3 LSBs */
        silk_assert( psIndices->GainsIndices[ 0 ] >= 0 && psIndices->GainsIndices[ 0 ] < N_LEVELS_QGAIN );
        ec_enc_icdf( psRangeEnc, silk_RSHIFT( psIndices->GainsIndices[ 0 ], 3 ), silk_gain_iCDF[ psIndices->signalType ], 8 );
    f248:	f994 201d 	ldrsb.w	r2, [r4, #29]
    f24c:	4bac      	ldr	r3, [pc, #688]	; (f500 <silk_encode_indices+0x300>)
    f24e:	10c9      	asrs	r1, r1, #3
    f250:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
    f254:	4628      	mov	r0, r5
    f256:	2308      	movs	r3, #8
    f258:	f01a fe12 	bl	29e80 <ec_enc_icdf>
        ec_enc_icdf( psRangeEnc, psIndices->GainsIndices[ 0 ] & 7, silk_uniform8_iCDF, 8 );
    f25c:	7821      	ldrb	r1, [r4, #0]
    f25e:	4aa9      	ldr	r2, [pc, #676]	; (f504 <silk_encode_indices+0x304>)
    f260:	f001 0107 	and.w	r1, r1, #7
    f264:	2308      	movs	r3, #8
    f266:	4628      	mov	r0, r5
    f268:	f01a fe0a 	bl	29e80 <ec_enc_icdf>
    }

    /* remaining subframes */
    for( i = 1; i < psEncC->nb_subfr; i++ ) {
    f26c:	f241 13e4 	movw	r3, #4580	; 0x11e4
    f270:	f859 3003 	ldr.w	r3, [r9, r3]
    f274:	2b01      	cmp	r3, #1
    f276:	dd10      	ble.n	f29a <silk_encode_indices+0x9a>
    f278:	f509 578f 	add.w	r7, r9, #4576	; 0x11e0
        silk_assert( psIndices->GainsIndices[ i ] >= 0 && psIndices->GainsIndices[ i ] < MAX_DELTA_GAIN_QUANT - MIN_DELTA_GAIN_QUANT + 1 );
        ec_enc_icdf( psRangeEnc, psIndices->GainsIndices[ i ], silk_delta_gain_iCDF, 8 );
    f27c:	f8df 8290 	ldr.w	r8, [pc, #656]	; f510 <silk_encode_indices+0x310>
    f280:	3704      	adds	r7, #4
    f282:	1c66      	adds	r6, r4, #1
    f284:	2308      	movs	r3, #8
    f286:	4642      	mov	r2, r8
    f288:	f916 1b01 	ldrsb.w	r1, [r6], #1
    f28c:	4628      	mov	r0, r5
    f28e:	f01a fdf7 	bl	29e80 <ec_enc_icdf>
    for( i = 1; i < psEncC->nb_subfr; i++ ) {
    f292:	683a      	ldr	r2, [r7, #0]
    f294:	1b33      	subs	r3, r6, r4
    f296:	429a      	cmp	r2, r3
    f298:	dcf4      	bgt.n	f284 <silk_encode_indices+0x84>
    }

    /****************/
    /* Encode NLSFs */
    /****************/
    ec_enc_icdf( psRangeEnc, psIndices->NLSFIndices[ 0 ], &psEncC->psNLSF_CB->CB1_iCDF[ ( psIndices->signalType >> 1 ) * psEncC->psNLSF_CB->nVectors ], 8 );
    f29a:	f241 2654 	movw	r6, #4692	; 0x1254
    f29e:	f994 301d 	ldrsb.w	r3, [r4, #29]
    f2a2:	f859 0006 	ldr.w	r0, [r9, r6]
    f2a6:	f994 1008 	ldrsb.w	r1, [r4, #8]
    f2aa:	f9b0 7000 	ldrsh.w	r7, [r0]
    f2ae:	6902      	ldr	r2, [r0, #16]
        if( psIndices->NLSFIndices[ i+1 ] >= NLSF_QUANT_MAX_AMPLITUDE ) {
            ec_enc_icdf( psRangeEnc, 2 * NLSF_QUANT_MAX_AMPLITUDE, &psEncC->psNLSF_CB->ec_iCDF[ ec_ix[ i ] ], 8 );
            ec_enc_icdf( psRangeEnc, psIndices->NLSFIndices[ i+1 ] - NLSF_QUANT_MAX_AMPLITUDE, silk_NLSF_EXT_iCDF, 8 );
        } else if( psIndices->NLSFIndices[ i+1 ] <= -NLSF_QUANT_MAX_AMPLITUDE ) {
            ec_enc_icdf( psRangeEnc, 0, &psEncC->psNLSF_CB->ec_iCDF[ ec_ix[ i ] ], 8 );
            ec_enc_icdf( psRangeEnc, -psIndices->NLSFIndices[ i+1 ] - NLSF_QUANT_MAX_AMPLITUDE, silk_NLSF_EXT_iCDF, 8 );
    f2b0:	f8df b274 	ldr.w	fp, [pc, #628]	; f528 <silk_encode_indices+0x328>
    ec_enc_icdf( psRangeEnc, psIndices->NLSFIndices[ 0 ], &psEncC->psNLSF_CB->CB1_iCDF[ ( psIndices->signalType >> 1 ) * psEncC->psNLSF_CB->nVectors ], 8 );
    f2b4:	105b      	asrs	r3, r3, #1
    f2b6:	fb07 2203 	mla	r2, r7, r3, r2
    f2ba:	4628      	mov	r0, r5
    f2bc:	2308      	movs	r3, #8
    f2be:	f01a fddf 	bl	29e80 <ec_enc_icdf>
    f2c2:	f509 5a92 	add.w	sl, r9, #4672	; 0x1240
    silk_NLSF_unpack( ec_ix, pred_Q8, psEncC->psNLSF_CB, psIndices->NLSFIndices[ 0 ] );
    f2c6:	f859 2006 	ldr.w	r2, [r9, r6]
    f2ca:	f994 3008 	ldrsb.w	r3, [r4, #8]
    f2ce:	a804      	add	r0, sp, #16
    f2d0:	4669      	mov	r1, sp
    f2d2:	4680      	mov	r8, r0
    f2d4:	f10a 0a14 	add.w	sl, sl, #20
    f2d8:	f005 fb76 	bl	149c8 <silk_NLSF_unpack>
    f2dc:	f104 0609 	add.w	r6, r4, #9
    for( i = 0; i < psEncC->psNLSF_CB->order; i++ ) {
    f2e0:	2700      	movs	r7, #0
    f2e2:	e00c      	b.n	f2fe <silk_encode_indices+0xfe>
            ec_enc_icdf( psRangeEnc, 0, &psEncC->psNLSF_CB->ec_iCDF[ ec_ix[ i ] ], 8 );
    f2e4:	f01a fdcc 	bl	29e80 <ec_enc_icdf>
            ec_enc_icdf( psRangeEnc, -psIndices->NLSFIndices[ i+1 ] - NLSF_QUANT_MAX_AMPLITUDE, silk_NLSF_EXT_iCDF, 8 );
    f2e8:	f996 3000 	ldrsb.w	r3, [r6]
    f2ec:	f06f 0103 	mvn.w	r1, #3
    f2f0:	1ac9      	subs	r1, r1, r3
    f2f2:	465a      	mov	r2, fp
    f2f4:	2308      	movs	r3, #8
    f2f6:	4628      	mov	r0, r5
    f2f8:	f01a fdc2 	bl	29e80 <ec_enc_icdf>
    f2fc:	3601      	adds	r6, #1
    for( i = 0; i < psEncC->psNLSF_CB->order; i++ ) {
    f2fe:	f8da 3000 	ldr.w	r3, [sl]
    f302:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
    f306:	42ba      	cmp	r2, r7
        if( psIndices->NLSFIndices[ i+1 ] >= NLSF_QUANT_MAX_AMPLITUDE ) {
    f308:	f107 0701 	add.w	r7, r7, #1
    for( i = 0; i < psEncC->psNLSF_CB->order; i++ ) {
    f30c:	dd26      	ble.n	f35c <silk_encode_indices+0x15c>
        if( psIndices->NLSFIndices[ i+1 ] >= NLSF_QUANT_MAX_AMPLITUDE ) {
    f30e:	f996 e000 	ldrsb.w	lr, [r6]
    f312:	69db      	ldr	r3, [r3, #28]
    f314:	f938 cb02 	ldrsh.w	ip, [r8], #2
    f318:	f1be 0f03 	cmp.w	lr, #3
    f31c:	449c      	add	ip, r3
    f31e:	dc0e      	bgt.n	f33e <silk_encode_indices+0x13e>
        } else if( psIndices->NLSFIndices[ i+1 ] <= -NLSF_QUANT_MAX_AMPLITUDE ) {
    f320:	f11e 0f03 	cmn.w	lr, #3
            ec_enc_icdf( psRangeEnc, 0, &psEncC->psNLSF_CB->ec_iCDF[ ec_ix[ i ] ], 8 );
    f324:	4662      	mov	r2, ip
    f326:	4628      	mov	r0, r5
    f328:	f04f 0308 	mov.w	r3, #8
    f32c:	f04f 0100 	mov.w	r1, #0
        } else if( psIndices->NLSFIndices[ i+1 ] <= -NLSF_QUANT_MAX_AMPLITUDE ) {
    f330:	dbd8      	blt.n	f2e4 <silk_encode_indices+0xe4>
        } else {
            ec_enc_icdf( psRangeEnc, psIndices->NLSFIndices[ i+1 ] + NLSF_QUANT_MAX_AMPLITUDE, &psEncC->psNLSF_CB->ec_iCDF[ ec_ix[ i ] ], 8 );
    f332:	2308      	movs	r3, #8
    f334:	f10e 0104 	add.w	r1, lr, #4
    f338:	f01a fda2 	bl	29e80 <ec_enc_icdf>
    f33c:	e7de      	b.n	f2fc <silk_encode_indices+0xfc>
            ec_enc_icdf( psRangeEnc, 2 * NLSF_QUANT_MAX_AMPLITUDE, &psEncC->psNLSF_CB->ec_iCDF[ ec_ix[ i ] ], 8 );
    f33e:	2308      	movs	r3, #8
    f340:	4662      	mov	r2, ip
    f342:	4619      	mov	r1, r3
    f344:	4628      	mov	r0, r5
    f346:	f01a fd9b 	bl	29e80 <ec_enc_icdf>
            ec_enc_icdf( psRangeEnc, psIndices->NLSFIndices[ i+1 ] - NLSF_QUANT_MAX_AMPLITUDE, silk_NLSF_EXT_iCDF, 8 );
    f34a:	f996 1000 	ldrsb.w	r1, [r6]
    f34e:	2308      	movs	r3, #8
    f350:	3904      	subs	r1, #4
    f352:	465a      	mov	r2, fp
    f354:	4628      	mov	r0, r5
    f356:	f01a fd93 	bl	29e80 <ec_enc_icdf>
    f35a:	e7cf      	b.n	f2fc <silk_encode_indices+0xfc>
        }
    }

    /* Encode NLSF interpolation factor */
    if( psEncC->nb_subfr == MAX_NB_SUBFR ) {
    f35c:	f241 13e4 	movw	r3, #4580	; 0x11e4
    f360:	f859 3003 	ldr.w	r3, [r9, r3]
    f364:	2b04      	cmp	r3, #4
    f366:	f000 809f 	beq.w	f4a8 <silk_encode_indices+0x2a8>
        silk_assert( psIndices->NLSFInterpCoef_Q2 >= 0 && psIndices->NLSFInterpCoef_Q2 < 5 );
        ec_enc_icdf( psRangeEnc, psIndices->NLSFInterpCoef_Q2, silk_NLSF_interpolation_factor_iCDF, 8 );
    }

    if( psIndices->signalType == TYPE_VOICED )
    f36a:	f994 301d 	ldrsb.w	r3, [r4, #29]
    f36e:	2b02      	cmp	r3, #2
    f370:	d029      	beq.n	f3c6 <silk_encode_indices+0x1c6>
            ec_enc_icdf( psRangeEnc, psIndices->LTP_scaleIndex, silk_LTPscale_iCDF, 8 );
        }
        silk_assert( !condCoding || psIndices->LTP_scaleIndex == 0 );
    }

    psEncC->ec_prevSignalType = psIndices->signalType;
    f372:	f241 6188 	movw	r1, #5768	; 0x1688

    /***************/
    /* Encode seed */
    /***************/
    silk_assert( psIndices->Seed >= 0 && psIndices->Seed < 4 );
    ec_enc_icdf( psRangeEnc, psIndices->Seed, silk_uniform4_iCDF, 8 );
    f376:	4a64      	ldr	r2, [pc, #400]	; (f508 <silk_encode_indices+0x308>)
    psEncC->ec_prevSignalType = psIndices->signalType;
    f378:	f849 3001 	str.w	r3, [r9, r1]
    ec_enc_icdf( psRangeEnc, psIndices->Seed, silk_uniform4_iCDF, 8 );
    f37c:	4628      	mov	r0, r5
    f37e:	2308      	movs	r3, #8
    f380:	f994 1022 	ldrsb.w	r1, [r4, #34]	; 0x22
    f384:	f01a fd7c 	bl	29e80 <ec_enc_icdf>
}
    f388:	b00d      	add	sp, #52	; 0x34
    f38a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
         psIndices = &psEncC->indices;
    f38e:	f500 5494 	add.w	r4, r0, #4736	; 0x1280
    typeOffset = 2 * psIndices->signalType + psIndices->quantOffsetType;
    f392:	f994 301d 	ldrsb.w	r3, [r4, #29]
    f396:	f994 101e 	ldrsb.w	r1, [r4, #30]
    f39a:	eb01 0143 	add.w	r1, r1, r3, lsl #1
    if( encode_LBRR || typeOffset >= 2 ) {
    f39e:	2901      	cmp	r1, #1
    f3a0:	f73f af46 	bgt.w	f230 <silk_encode_indices+0x30>
        ec_enc_icdf( psRangeEnc, typeOffset, silk_type_offset_no_VAD_iCDF, 8 );
    f3a4:	2308      	movs	r3, #8
    f3a6:	4a59      	ldr	r2, [pc, #356]	; (f50c <silk_encode_indices+0x30c>)
    f3a8:	4628      	mov	r0, r5
    f3aa:	f01a fd69 	bl	29e80 <ec_enc_icdf>
    if( condCoding == CODE_CONDITIONALLY ) {
    f3ae:	9b16      	ldr	r3, [sp, #88]	; 0x58
    f3b0:	f994 1000 	ldrsb.w	r1, [r4]
    f3b4:	2b02      	cmp	r3, #2
    f3b6:	f47f af47 	bne.w	f248 <silk_encode_indices+0x48>
        ec_enc_icdf( psRangeEnc, psIndices->GainsIndices[ 0 ], silk_delta_gain_iCDF, 8 );
    f3ba:	2308      	movs	r3, #8
    f3bc:	4a54      	ldr	r2, [pc, #336]	; (f510 <silk_encode_indices+0x310>)
    f3be:	4628      	mov	r0, r5
    f3c0:	f01a fd5e 	bl	29e80 <ec_enc_icdf>
    f3c4:	e752      	b.n	f26c <silk_encode_indices+0x6c>
        if( condCoding == CODE_CONDITIONALLY && psEncC->ec_prevSignalType == TYPE_VOICED ) {
    f3c6:	9b16      	ldr	r3, [sp, #88]	; 0x58
    f3c8:	f9b4 701a 	ldrsh.w	r7, [r4, #26]
    f3cc:	2b02      	cmp	r3, #2
    f3ce:	d116      	bne.n	f3fe <silk_encode_indices+0x1fe>
    f3d0:	f241 6388 	movw	r3, #5768	; 0x1688
    f3d4:	f859 3003 	ldr.w	r3, [r9, r3]
    f3d8:	2b02      	cmp	r3, #2
    f3da:	d110      	bne.n	f3fe <silk_encode_indices+0x1fe>
            delta_lagIndex = psIndices->lagIndex - psEncC->ec_prevLagIndex;
    f3dc:	f241 668c 	movw	r6, #5772	; 0x168c
    f3e0:	f939 1006 	ldrsh.w	r1, [r9, r6]
    f3e4:	1a79      	subs	r1, r7, r1
            if( delta_lagIndex < -8 || delta_lagIndex > 11 ) {
    f3e6:	f101 0308 	add.w	r3, r1, #8
    f3ea:	2b13      	cmp	r3, #19
    f3ec:	d964      	bls.n	f4b8 <silk_encode_indices+0x2b8>
            ec_enc_icdf( psRangeEnc, delta_lagIndex, silk_pitch_delta_iCDF, 8 );
    f3ee:	2308      	movs	r3, #8
    f3f0:	4a48      	ldr	r2, [pc, #288]	; (f514 <silk_encode_indices+0x314>)
    f3f2:	2100      	movs	r1, #0
    f3f4:	4628      	mov	r0, r5
    f3f6:	f01a fd43 	bl	29e80 <ec_enc_icdf>
    f3fa:	f9b4 701a 	ldrsh.w	r7, [r4, #26]
            pitch_high_bits = silk_DIV32_16( psIndices->lagIndex, silk_RSHIFT( psEncC->fs_kHz, 1 ) );
    f3fe:	f509 528f 	add.w	r2, r9, #4576	; 0x11e0
            ec_enc_icdf( psRangeEnc, pitch_high_bits, silk_pitch_lag_iCDF, 8 );
    f402:	2308      	movs	r3, #8
            pitch_high_bits = silk_DIV32_16( psIndices->lagIndex, silk_RSHIFT( psEncC->fs_kHz, 1 ) );
    f404:	6810      	ldr	r0, [r2, #0]
            ec_enc_icdf( psRangeEnc, pitch_high_bits, silk_pitch_lag_iCDF, 8 );
    f406:	4a44      	ldr	r2, [pc, #272]	; (f518 <silk_encode_indices+0x318>)
            pitch_high_bits = silk_DIV32_16( psIndices->lagIndex, silk_RSHIFT( psEncC->fs_kHz, 1 ) );
    f408:	1040      	asrs	r0, r0, #1
    f40a:	fb97 f1f0 	sdiv	r1, r7, r0
            pitch_low_bits = psIndices->lagIndex - silk_SMULBB( pitch_high_bits, silk_RSHIFT( psEncC->fs_kHz, 1 ) );
    f40e:	fb11 f600 	smulbb	r6, r1, r0
            ec_enc_icdf( psRangeEnc, pitch_high_bits, silk_pitch_lag_iCDF, 8 );
    f412:	4628      	mov	r0, r5
    f414:	f01a fd34 	bl	29e80 <ec_enc_icdf>
            ec_enc_icdf( psRangeEnc, pitch_low_bits, psEncC->pitch_lag_low_bits_iCDF, 8 );
    f418:	f241 234c 	movw	r3, #4684	; 0x124c
            pitch_low_bits = psIndices->lagIndex - silk_SMULBB( pitch_high_bits, silk_RSHIFT( psEncC->fs_kHz, 1 ) );
    f41c:	1bbe      	subs	r6, r7, r6
            ec_enc_icdf( psRangeEnc, pitch_low_bits, psEncC->pitch_lag_low_bits_iCDF, 8 );
    f41e:	f859 2003 	ldr.w	r2, [r9, r3]
    f422:	4631      	mov	r1, r6
    f424:	2308      	movs	r3, #8
    f426:	4628      	mov	r0, r5
    f428:	f01a fd2a 	bl	29e80 <ec_enc_icdf>
        psEncC->ec_prevLagIndex = psIndices->lagIndex;
    f42c:	f241 638c 	movw	r3, #5772	; 0x168c
    f430:	8b62      	ldrh	r2, [r4, #26]
    f432:	f829 2003 	strh.w	r2, [r9, r3]
        ec_enc_icdf( psRangeEnc, psIndices->contourIndex, psEncC->pitch_contour_iCDF, 8 );
    f436:	f241 2350 	movw	r3, #4688	; 0x1250
    f43a:	f994 101c 	ldrsb.w	r1, [r4, #28]
    f43e:	f859 2003 	ldr.w	r2, [r9, r3]
    f442:	4628      	mov	r0, r5
    f444:	2308      	movs	r3, #8
    f446:	f01a fd1b 	bl	29e80 <ec_enc_icdf>
        ec_enc_icdf( psRangeEnc, psIndices->PERIndex, silk_LTP_per_index_iCDF, 8 );
    f44a:	2308      	movs	r3, #8
    f44c:	4a33      	ldr	r2, [pc, #204]	; (f51c <silk_encode_indices+0x31c>)
    f44e:	f994 1020 	ldrsb.w	r1, [r4, #32]
    f452:	4628      	mov	r0, r5
    f454:	f01a fd14 	bl	29e80 <ec_enc_icdf>
        for( k = 0; k < psEncC->nb_subfr; k++ ) {
    f458:	f241 13e4 	movw	r3, #4580	; 0x11e4
    f45c:	f859 3003 	ldr.w	r3, [r9, r3]
    f460:	2b00      	cmp	r3, #0
    f462:	dd15      	ble.n	f490 <silk_encode_indices+0x290>
    f464:	f509 578f 	add.w	r7, r9, #4576	; 0x11e0
    f468:	f8df a0c0 	ldr.w	sl, [pc, #192]	; f52c <silk_encode_indices+0x32c>
    f46c:	3704      	adds	r7, #4
    f46e:	f104 0804 	add.w	r8, r4, #4
    f472:	2600      	movs	r6, #0
            ec_enc_icdf( psRangeEnc, psIndices->LTPIndex[ k ], silk_LTP_gain_iCDF_ptrs[ psIndices->PERIndex ], 8 );
    f474:	f994 3020 	ldrsb.w	r3, [r4, #32]
    f478:	f918 1b01 	ldrsb.w	r1, [r8], #1
    f47c:	f85a 2023 	ldr.w	r2, [sl, r3, lsl #2]
    f480:	4628      	mov	r0, r5
    f482:	2308      	movs	r3, #8
    f484:	f01a fcfc 	bl	29e80 <ec_enc_icdf>
        for( k = 0; k < psEncC->nb_subfr; k++ ) {
    f488:	683b      	ldr	r3, [r7, #0]
    f48a:	3601      	adds	r6, #1
    f48c:	42b3      	cmp	r3, r6
    f48e:	dcf1      	bgt.n	f474 <silk_encode_indices+0x274>
        if( condCoding == CODE_INDEPENDENTLY ) {
    f490:	9b16      	ldr	r3, [sp, #88]	; 0x58
    f492:	b933      	cbnz	r3, f4a2 <silk_encode_indices+0x2a2>
            ec_enc_icdf( psRangeEnc, psIndices->LTP_scaleIndex, silk_LTPscale_iCDF, 8 );
    f494:	2308      	movs	r3, #8
    f496:	4a22      	ldr	r2, [pc, #136]	; (f520 <silk_encode_indices+0x320>)
    f498:	f994 1021 	ldrsb.w	r1, [r4, #33]	; 0x21
    f49c:	4628      	mov	r0, r5
    f49e:	f01a fcef 	bl	29e80 <ec_enc_icdf>
    f4a2:	f994 301d 	ldrsb.w	r3, [r4, #29]
    f4a6:	e764      	b.n	f372 <silk_encode_indices+0x172>
        ec_enc_icdf( psRangeEnc, psIndices->NLSFInterpCoef_Q2, silk_NLSF_interpolation_factor_iCDF, 8 );
    f4a8:	2308      	movs	r3, #8
    f4aa:	4a1e      	ldr	r2, [pc, #120]	; (f524 <silk_encode_indices+0x324>)
    f4ac:	f994 101f 	ldrsb.w	r1, [r4, #31]
    f4b0:	4628      	mov	r0, r5
    f4b2:	f01a fce5 	bl	29e80 <ec_enc_icdf>
    f4b6:	e758      	b.n	f36a <silk_encode_indices+0x16a>
            ec_enc_icdf( psRangeEnc, delta_lagIndex, silk_pitch_delta_iCDF, 8 );
    f4b8:	3109      	adds	r1, #9
    f4ba:	2308      	movs	r3, #8
    f4bc:	4a15      	ldr	r2, [pc, #84]	; (f514 <silk_encode_indices+0x314>)
    f4be:	4628      	mov	r0, r5
    f4c0:	f01a fcde 	bl	29e80 <ec_enc_icdf>
        psEncC->ec_prevLagIndex = psIndices->lagIndex;
    f4c4:	8b63      	ldrh	r3, [r4, #26]
    f4c6:	f829 3006 	strh.w	r3, [r9, r6]
        ec_enc_icdf( psRangeEnc, psIndices->contourIndex, psEncC->pitch_contour_iCDF, 8 );
    f4ca:	f241 2350 	movw	r3, #4688	; 0x1250
    f4ce:	f994 101c 	ldrsb.w	r1, [r4, #28]
    f4d2:	f859 2003 	ldr.w	r2, [r9, r3]
    f4d6:	4628      	mov	r0, r5
    f4d8:	2308      	movs	r3, #8
    f4da:	f01a fcd1 	bl	29e80 <ec_enc_icdf>
        ec_enc_icdf( psRangeEnc, psIndices->PERIndex, silk_LTP_per_index_iCDF, 8 );
    f4de:	2308      	movs	r3, #8
    f4e0:	4a0e      	ldr	r2, [pc, #56]	; (f51c <silk_encode_indices+0x31c>)
    f4e2:	f994 1020 	ldrsb.w	r1, [r4, #32]
    f4e6:	4628      	mov	r0, r5
    f4e8:	f01a fcca 	bl	29e80 <ec_enc_icdf>
        for( k = 0; k < psEncC->nb_subfr; k++ ) {
    f4ec:	f241 13e4 	movw	r3, #4580	; 0x11e4
    f4f0:	f859 3003 	ldr.w	r3, [r9, r3]
    f4f4:	2b00      	cmp	r3, #0
    f4f6:	dcb5      	bgt.n	f464 <silk_encode_indices+0x264>
    f4f8:	e7d3      	b.n	f4a2 <silk_encode_indices+0x2a2>
    f4fa:	bf00      	nop
    f4fc:	00036d38 	.word	0x00036d38
    f500:	00035c88 	.word	0x00035c88
    f504:	00036d58 	.word	0x00036d58
    f508:	00036d44 	.word	0x00036d44
    f50c:	00036d3c 	.word	0x00036d3c
    f510:	00035c5c 	.word	0x00035c5c
    f514:	00036da0 	.word	0x00036da0
    f518:	00036db8 	.word	0x00036db8
    f51c:	00035e78 	.word	0x00035e78
    f520:	00036c74 	.word	0x00036c74
    f524:	00036c80 	.word	0x00036c80
    f528:	00036c78 	.word	0x00036c78
    f52c:	00035d1c 	.word	0x00035d1c

0000f530 <silk_encode_pulses>:
    const opus_int              signalType,                     /* I    Signal type                                 */
    const opus_int              quantOffsetType,                /* I    quantOffsetType                             */
    opus_int8                   pulses[],                       /* I    quantization indices                        */
    const opus_int              frame_length                    /* I    Frame length                                */
)
{
    f530:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f534:	b0a7      	sub	sp, #156	; 0x9c
    f536:	af02      	add	r7, sp, #8
    f538:	e9c7 2101 	strd	r2, r1, [r7, #4]
    /****************************/
    /* Prepare for shell coding */
    /****************************/
    /* Calculate number of shell blocks */
    silk_assert( 1 << LOG2_SHELL_CODEC_FRAME_LENGTH == SHELL_CODEC_FRAME_LENGTH );
    iter = silk_RSHIFT( frame_length, LOG2_SHELL_CODEC_FRAME_LENGTH );
    f53c:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
{
    f540:	613b      	str	r3, [r7, #16]
    iter = silk_RSHIFT( frame_length, LOG2_SHELL_CODEC_FRAME_LENGTH );
    f542:	1112      	asrs	r2, r2, #4
    f544:	4614      	mov	r4, r2
    f546:	623a      	str	r2, [r7, #32]
{
    f548:	4683      	mov	fp, r0
    silk_memset( pulses_comb, 0, 8 * sizeof( opus_int ) ); /* Fixing Valgrind reported problem*/
    f54a:	2220      	movs	r2, #32
    f54c:	2100      	movs	r1, #0
    f54e:	f107 0070 	add.w	r0, r7, #112	; 0x70
    f552:	f025 fe07 	bl	35164 <memset>
    if( iter * SHELL_CODEC_FRAME_LENGTH < frame_length ) {
    f556:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
    f55a:	0126      	lsls	r6, r4, #4
    f55c:	429e      	cmp	r6, r3
    f55e:	da0c      	bge.n	f57a <silk_encode_pulses+0x4a>
        celt_assert( frame_length == 12 * 10 ); /* Make sure only happens for 10 ms @ 12 kHz */
        iter++;
    f560:	6a38      	ldr	r0, [r7, #32]
        silk_memset( &pulses[ frame_length ], 0, SHELL_CODEC_FRAME_LENGTH * sizeof(opus_int8));
    f562:	6939      	ldr	r1, [r7, #16]
        iter++;
    f564:	3001      	adds	r0, #1
        silk_memset( &pulses[ frame_length ], 0, SHELL_CODEC_FRAME_LENGTH * sizeof(opus_int8));
    f566:	18ca      	adds	r2, r1, r3
        iter++;
    f568:	6238      	str	r0, [r7, #32]
        silk_memset( &pulses[ frame_length ], 0, SHELL_CODEC_FRAME_LENGTH * sizeof(opus_int8));
    f56a:	f8d7 00b8 	ldr.w	r0, [r7, #184]	; 0xb8
    f56e:	2300      	movs	r3, #0
    f570:	500b      	str	r3, [r1, r0]
    f572:	3610      	adds	r6, #16
    f574:	6053      	str	r3, [r2, #4]
    f576:	6093      	str	r3, [r2, #8]
    f578:	60d3      	str	r3, [r2, #12]
    }

    /* Take the absolute value of the pulses */
    ALLOC( abs_pulses, iter * SHELL_CODEC_FRAME_LENGTH, opus_int );
    f57a:	00b3      	lsls	r3, r6, #2
    f57c:	3308      	adds	r3, #8
    f57e:	ebad 0d03 	sub.w	sp, sp, r3
    f582:	aa02      	add	r2, sp, #8
    silk_assert( !( SHELL_CODEC_FRAME_LENGTH & 3 ) );
    for( i = 0; i < iter * SHELL_CODEC_FRAME_LENGTH; i+=4 ) {
    f584:	2e00      	cmp	r6, #0
    ALLOC( abs_pulses, iter * SHELL_CODEC_FRAME_LENGTH, opus_int );
    f586:	60fa      	str	r2, [r7, #12]
    for( i = 0; i < iter * SHELL_CODEC_FRAME_LENGTH; i+=4 ) {
    f588:	dd1e      	ble.n	f5c8 <silk_encode_pulses+0x98>
    f58a:	693b      	ldr	r3, [r7, #16]
    f58c:	441e      	add	r6, r3
        abs_pulses[i+0] = ( opus_int )silk_abs( pulses[ i + 0 ] );
    f58e:	f993 5000 	ldrsb.w	r5, [r3]
        abs_pulses[i+1] = ( opus_int )silk_abs( pulses[ i + 1 ] );
    f592:	f993 4001 	ldrsb.w	r4, [r3, #1]
        abs_pulses[i+2] = ( opus_int )silk_abs( pulses[ i + 2 ] );
    f596:	f993 0002 	ldrsb.w	r0, [r3, #2]
        abs_pulses[i+3] = ( opus_int )silk_abs( pulses[ i + 3 ] );
    f59a:	f993 1003 	ldrsb.w	r1, [r3, #3]
        abs_pulses[i+0] = ( opus_int )silk_abs( pulses[ i + 0 ] );
    f59e:	2d00      	cmp	r5, #0
    f5a0:	bfb8      	it	lt
    f5a2:	426d      	neglt	r5, r5
        abs_pulses[i+1] = ( opus_int )silk_abs( pulses[ i + 1 ] );
    f5a4:	2c00      	cmp	r4, #0
    f5a6:	bfb8      	it	lt
    f5a8:	4264      	neglt	r4, r4
        abs_pulses[i+2] = ( opus_int )silk_abs( pulses[ i + 2 ] );
    f5aa:	2800      	cmp	r0, #0
    f5ac:	bfb8      	it	lt
    f5ae:	4240      	neglt	r0, r0
    f5b0:	3304      	adds	r3, #4
        abs_pulses[i+3] = ( opus_int )silk_abs( pulses[ i + 3 ] );
    f5b2:	2900      	cmp	r1, #0
    f5b4:	bfb8      	it	lt
    f5b6:	4249      	neglt	r1, r1
    for( i = 0; i < iter * SHELL_CODEC_FRAME_LENGTH; i+=4 ) {
    f5b8:	429e      	cmp	r6, r3
        abs_pulses[i+1] = ( opus_int )silk_abs( pulses[ i + 1 ] );
    f5ba:	e9c2 5400 	strd	r5, r4, [r2]
        abs_pulses[i+3] = ( opus_int )silk_abs( pulses[ i + 3 ] );
    f5be:	e9c2 0102 	strd	r0, r1, [r2, #8]
    f5c2:	f102 0210 	add.w	r2, r2, #16
    for( i = 0; i < iter * SHELL_CODEC_FRAME_LENGTH; i+=4 ) {
    f5c6:	d1e2      	bne.n	f58e <silk_encode_pulses+0x5e>
    }

    /* Calc sum pulses per shell code frame */
    ALLOC( sum_pulses, iter, opus_int );
    f5c8:	6a39      	ldr	r1, [r7, #32]
    f5ca:	008a      	lsls	r2, r1, #2
    f5cc:	f102 030a 	add.w	r3, r2, #10
    f5d0:	f023 0307 	bic.w	r3, r3, #7
    f5d4:	ebad 0d03 	sub.w	sp, sp, r3
    f5d8:	a802      	add	r0, sp, #8
    ALLOC( nRshifts, iter, opus_int );
    f5da:	ebad 0d03 	sub.w	sp, sp, r3
    f5de:	ab02      	add	r3, sp, #8
    abs_pulses_ptr = abs_pulses;
    for( i = 0; i < iter; i++ ) {
    f5e0:	2900      	cmp	r1, #0
    ALLOC( sum_pulses, iter, opus_int );
    f5e2:	61f8      	str	r0, [r7, #28]
    ALLOC( nRshifts, iter, opus_int );
    f5e4:	617b      	str	r3, [r7, #20]
    for( i = 0; i < iter; i++ ) {
    f5e6:	f340 819e 	ble.w	f926 <silk_encode_pulses+0x3f6>
        nRshifts[ i ] = 0;

        while( 1 ) {
            /* 1+1 -> 2 */
            scale_down = combine_and_check( pulses_comb, abs_pulses_ptr, silk_max_pulses_table[ 0 ], 8 );
    f5ea:	4bbb      	ldr	r3, [pc, #748]	; (f8d8 <silk_encode_pulses+0x3a8>)
    f5ec:	f8c7 b000 	str.w	fp, [r7]
            /* 2+2 -> 4 */
            scale_down += combine_and_check( pulses_comb, pulses_comb, silk_max_pulses_table[ 1 ], 4 );
    f5f0:	f893 8001 	ldrb.w	r8, [r3, #1]
            /* 4+4 -> 8 */
            scale_down += combine_and_check( pulses_comb, pulses_comb, silk_max_pulses_table[ 2 ], 2 );
    f5f4:	7899      	ldrb	r1, [r3, #2]
            scale_down = combine_and_check( pulses_comb, abs_pulses_ptr, silk_max_pulses_table[ 0 ], 8 );
    f5f6:	781d      	ldrb	r5, [r3, #0]
            /* 8+8 -> 16 */
            scale_down += combine_and_check( &sum_pulses[ i ], pulses_comb, silk_max_pulses_table[ 3 ], 1 );
    f5f8:	78db      	ldrb	r3, [r3, #3]
    f5fa:	637b      	str	r3, [r7, #52]	; 0x34
    f5fc:	697b      	ldr	r3, [r7, #20]
            scale_down += combine_and_check( pulses_comb, pulses_comb, silk_max_pulses_table[ 2 ], 2 );
    f5fe:	6579      	str	r1, [r7, #84]	; 0x54
    f600:	3a04      	subs	r2, #4
            scale_down += combine_and_check( &sum_pulses[ i ], pulses_comb, silk_max_pulses_table[ 3 ], 1 );
    f602:	f04f 0900 	mov.w	r9, #0
    f606:	61ba      	str	r2, [r7, #24]
    f608:	189a      	adds	r2, r3, r2
    f60a:	3b04      	subs	r3, #4
    f60c:	65fb      	str	r3, [r7, #92]	; 0x5c
    f60e:	627a      	str	r2, [r7, #36]	; 0x24
    f610:	69fb      	ldr	r3, [r7, #28]
    f612:	68fa      	ldr	r2, [r7, #12]
    f614:	63bb      	str	r3, [r7, #56]	; 0x38
    f616:	e9c7 9910 	strd	r9, r9, [r7, #64]	; 0x40
    f61a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    f61c:	f8c7 9048 	str.w	r9, [r7, #72]	; 0x48
    f620:	f8c7 9030 	str.w	r9, [r7, #48]	; 0x30
    f624:	f8c7 904c 	str.w	r9, [r7, #76]	; 0x4c
    f628:	f8c7 9028 	str.w	r9, [r7, #40]	; 0x28
    f62c:	f8c7 903c 	str.w	r9, [r7, #60]	; 0x3c
    f630:	f8c7 902c 	str.w	r9, [r7, #44]	; 0x2c
    f634:	f8c7 9064 	str.w	r9, [r7, #100]	; 0x64
    f638:	f8c7 9050 	str.w	r9, [r7, #80]	; 0x50
    f63c:	f8c7 9058 	str.w	r9, [r7, #88]	; 0x58
    f640:	f8c7 906c 	str.w	r9, [r7, #108]	; 0x6c
    f644:	464e      	mov	r6, r9
    f646:	f102 0a40 	add.w	sl, r2, #64	; 0x40
    f64a:	46ce      	mov	lr, r9
    f64c:	46c3      	mov	fp, r8
        nRshifts[ i ] = 0;
    f64e:	461a      	mov	r2, r3
    f650:	e95a 8c10 	ldrd	r8, ip, [sl, #-64]	; 0x40
    f654:	2300      	movs	r3, #0
    f656:	f842 3f04 	str.w	r3, [r2, #4]!
    f65a:	4663      	mov	r3, ip
    f65c:	65fa      	str	r2, [r7, #92]	; 0x5c
    f65e:	46c4      	mov	ip, r8
    f660:	4698      	mov	r8, r3
    f662:	e056      	b.n	f712 <silk_encode_pulses+0x1e2>
        sum = pulses_in[ 2 * k ] + pulses_in[ 2 * k + 1 ];
    f664:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    f666:	6e79      	ldr	r1, [r7, #100]	; 0x64
    f668:	eb03 0e01 	add.w	lr, r3, r1
        if( sum > max_pulses ) {
    f66c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    f66e:	4573      	cmp	r3, lr
    f670:	f2c0 80eb 	blt.w	f84a <silk_encode_pulses+0x31a>
    f674:	2201      	movs	r2, #1
    f676:	eb0e 0306 	add.w	r3, lr, r6
    f67a:	66fa      	str	r2, [r7, #108]	; 0x6c
    f67c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    f67e:	429a      	cmp	r2, r3
    f680:	db04      	blt.n	f68c <silk_encode_pulses+0x15c>
        pulses_comb[ k ] = sum;
    f682:	6bba      	ldr	r2, [r7, #56]	; 0x38
    f684:	6013      	str	r3, [r2, #0]

            if( scale_down ) {
    f686:	2c00      	cmp	r4, #0
    f688:	f000 80af 	beq.w	f7ea <silk_encode_pulses+0x2ba>
                /* We need to downscale the quantization signal */
                nRshifts[ i ]++;
    f68c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
                for( k = 0; k < SHELL_CODEC_FRAME_LENGTH; k++ ) {
                    abs_pulses_ptr[ k ] = silk_RSHIFT( abs_pulses_ptr[ k ], 1 );
    f68e:	e95a 010e 	ldrd	r0, r1, [sl, #-56]	; 0x38
                nRshifts[ i ]++;
    f692:	681c      	ldr	r4, [r3, #0]
                    abs_pulses_ptr[ k ] = silk_RSHIFT( abs_pulses_ptr[ k ], 1 );
    f694:	e95a 230c 	ldrd	r2, r3, [sl, #-48]	; 0x30
    f698:	1040      	asrs	r0, r0, #1
    f69a:	1049      	asrs	r1, r1, #1
    f69c:	1052      	asrs	r2, r2, #1
    f69e:	105b      	asrs	r3, r3, #1
    f6a0:	66bb      	str	r3, [r7, #104]	; 0x68
    f6a2:	e94a 010e 	strd	r0, r1, [sl, #-56]	; 0x38
                nRshifts[ i ]++;
    f6a6:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
                    abs_pulses_ptr[ k ] = silk_RSHIFT( abs_pulses_ptr[ k ], 1 );
    f6a8:	f84a 2c30 	str.w	r2, [sl, #-48]
    f6ac:	e95a 1208 	ldrd	r1, r2, [sl, #-32]
                nRshifts[ i ]++;
    f6b0:	3401      	adds	r4, #1
    f6b2:	601c      	str	r4, [r3, #0]
                    abs_pulses_ptr[ k ] = silk_RSHIFT( abs_pulses_ptr[ k ], 1 );
    f6b4:	f85a 0c24 	ldr.w	r0, [sl, #-36]
    f6b8:	f85a 4c28 	ldr.w	r4, [sl, #-40]
    f6bc:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    f6be:	f84a 3c2c 	str.w	r3, [sl, #-44]
    f6c2:	1049      	asrs	r1, r1, #1
    f6c4:	1052      	asrs	r2, r2, #1
    f6c6:	f85a 3c18 	ldr.w	r3, [sl, #-24]
    f6ca:	f84a 1c20 	str.w	r1, [sl, #-32]
    f6ce:	1064      	asrs	r4, r4, #1
    f6d0:	1040      	asrs	r0, r0, #1
    f6d2:	f84a 2c1c 	str.w	r2, [sl, #-28]
    f6d6:	e95a 1203 	ldrd	r1, r2, [sl, #-12]
    f6da:	e94a 400a 	strd	r4, r0, [sl, #-40]	; 0x28
    f6de:	f85a 4c14 	ldr.w	r4, [sl, #-20]
    f6e2:	f85a 0c10 	ldr.w	r0, [sl, #-16]
    f6e6:	105b      	asrs	r3, r3, #1
    f6e8:	f84a 3c18 	str.w	r3, [sl, #-24]
    f6ec:	ea4f 0c6c 	mov.w	ip, ip, asr #1
    f6f0:	f85a 3c04 	ldr.w	r3, [sl, #-4]
    f6f4:	ea4f 0868 	mov.w	r8, r8, asr #1
    f6f8:	1064      	asrs	r4, r4, #1
    f6fa:	1040      	asrs	r0, r0, #1
    f6fc:	1049      	asrs	r1, r1, #1
    f6fe:	1052      	asrs	r2, r2, #1
    f700:	e94a c810 	strd	ip, r8, [sl, #-64]	; 0x40
    f704:	e94a 4005 	strd	r4, r0, [sl, #-20]
    f708:	e94a 1203 	strd	r1, r2, [sl, #-12]
    f70c:	105b      	asrs	r3, r3, #1
    f70e:	f84a 3c04 	str.w	r3, [sl, #-4]
        sum = pulses_in[ 2 * k ] + pulses_in[ 2 * k + 1 ];
    f712:	eb08 000c 	add.w	r0, r8, ip
        if( sum > max_pulses ) {
    f716:	4285      	cmp	r5, r0
    f718:	f2c0 80a4 	blt.w	f864 <silk_encode_pulses+0x334>
        sum = pulses_in[ 2 * k ] + pulses_in[ 2 * k + 1 ];
    f71c:	e95a 230e 	ldrd	r2, r3, [sl, #-56]	; 0x38
    f720:	4413      	add	r3, r2
        if( sum > max_pulses ) {
    f722:	429d      	cmp	r5, r3
    f724:	f2c0 80af 	blt.w	f886 <silk_encode_pulses+0x356>
        sum = pulses_in[ 2 * k ] + pulses_in[ 2 * k + 1 ];
    f728:	e95a 120c 	ldrd	r1, r2, [sl, #-48]	; 0x30
    f72c:	188a      	adds	r2, r1, r2
        if( sum > max_pulses ) {
    f72e:	4295      	cmp	r5, r2
        sum = pulses_in[ 2 * k ] + pulses_in[ 2 * k + 1 ];
    f730:	663a      	str	r2, [r7, #96]	; 0x60
        if( sum > max_pulses ) {
    f732:	f2c0 80b9 	blt.w	f8a8 <silk_encode_pulses+0x378>
        sum = pulses_in[ 2 * k ] + pulses_in[ 2 * k + 1 ];
    f736:	e95a 120a 	ldrd	r1, r2, [sl, #-40]	; 0x28
    f73a:	188a      	adds	r2, r1, r2
        if( sum > max_pulses ) {
    f73c:	4295      	cmp	r5, r2
        sum = pulses_in[ 2 * k ] + pulses_in[ 2 * k + 1 ];
    f73e:	66ba      	str	r2, [r7, #104]	; 0x68
        if( sum > max_pulses ) {
    f740:	f2c0 80c1 	blt.w	f8c6 <silk_encode_pulses+0x396>
        sum = pulses_in[ 2 * k ] + pulses_in[ 2 * k + 1 ];
    f744:	e95a 2108 	ldrd	r2, r1, [sl, #-32]
    f748:	440a      	add	r2, r1
        if( sum > max_pulses ) {
    f74a:	4295      	cmp	r5, r2
    f74c:	f2c0 80c6 	blt.w	f8dc <silk_encode_pulses+0x3ac>
        sum = pulses_in[ 2 * k ] + pulses_in[ 2 * k + 1 ];
    f750:	e95a 1406 	ldrd	r1, r4, [sl, #-24]
    f754:	4421      	add	r1, r4
        if( sum > max_pulses ) {
    f756:	428d      	cmp	r5, r1
    f758:	f2c0 80c7 	blt.w	f8ea <silk_encode_pulses+0x3ba>
        sum = pulses_in[ 2 * k ] + pulses_in[ 2 * k + 1 ];
    f75c:	e95a 6404 	ldrd	r6, r4, [sl, #-16]
    f760:	eb06 0e04 	add.w	lr, r6, r4
        if( sum > max_pulses ) {
    f764:	4575      	cmp	r5, lr
    f766:	f2c0 80c9 	blt.w	f8fc <silk_encode_pulses+0x3cc>
        sum = pulses_in[ 2 * k ] + pulses_in[ 2 * k + 1 ];
    f76a:	e95a 4602 	ldrd	r4, r6, [sl, #-8]
    f76e:	4426      	add	r6, r4
        if( sum > max_pulses ) {
    f770:	42b5      	cmp	r5, r6
    f772:	f04f 0901 	mov.w	r9, #1
    f776:	e9c7 1212 	strd	r1, r2, [r7, #72]	; 0x48
    f77a:	f2c0 80cf 	blt.w	f91c <silk_encode_pulses+0x3ec>
    f77e:	e9c7 990a 	strd	r9, r9, [r7, #40]	; 0x28
    f782:	e9c7 6e0f 	strd	r6, lr, [r7, #60]	; 0x3c
    f786:	f8c7 9030 	str.w	r9, [r7, #48]	; 0x30
    f78a:	46ce      	mov	lr, r9
    f78c:	f8c7 9044 	str.w	r9, [r7, #68]	; 0x44
    f790:	f8c7 9050 	str.w	r9, [r7, #80]	; 0x50
    f794:	f8c7 906c 	str.w	r9, [r7, #108]	; 0x6c
    return 0;
    f798:	2400      	movs	r4, #0
        sum = pulses_in[ 2 * k ] + pulses_in[ 2 * k + 1 ];
    f79a:	1819      	adds	r1, r3, r0
        if( sum > max_pulses ) {
    f79c:	458b      	cmp	fp, r1
    f79e:	db58      	blt.n	f852 <silk_encode_pulses+0x322>
        sum = pulses_in[ 2 * k ] + pulses_in[ 2 * k + 1 ];
    f7a0:	6e3a      	ldr	r2, [r7, #96]	; 0x60
    f7a2:	6eb8      	ldr	r0, [r7, #104]	; 0x68
    f7a4:	4402      	add	r2, r0
        if( sum > max_pulses ) {
    f7a6:	4593      	cmp	fp, r2
    f7a8:	db66      	blt.n	f878 <silk_encode_pulses+0x348>
        sum = pulses_in[ 2 * k ] + pulses_in[ 2 * k + 1 ];
    f7aa:	e9d7 3012 	ldrd	r3, r0, [r7, #72]	; 0x48
    f7ae:	4403      	add	r3, r0
        if( sum > max_pulses ) {
    f7b0:	459b      	cmp	fp, r3
        sum = pulses_in[ 2 * k ] + pulses_in[ 2 * k + 1 ];
    f7b2:	65bb      	str	r3, [r7, #88]	; 0x58
    f7b4:	eb01 0602 	add.w	r6, r1, r2
        if( sum > max_pulses ) {
    f7b8:	db6e      	blt.n	f898 <silk_encode_pulses+0x368>
        sum = pulses_in[ 2 * k ] + pulses_in[ 2 * k + 1 ];
    f7ba:	e9d7 030f 	ldrd	r0, r3, [r7, #60]	; 0x3c
    f7be:	4403      	add	r3, r0
        if( sum > max_pulses ) {
    f7c0:	459b      	cmp	fp, r3
        sum = pulses_in[ 2 * k ] + pulses_in[ 2 * k + 1 ];
    f7c2:	667b      	str	r3, [r7, #100]	; 0x64
        if( sum > max_pulses ) {
    f7c4:	f04f 0301 	mov.w	r3, #1
    f7c8:	db77      	blt.n	f8ba <silk_encode_pulses+0x38a>
    f7ca:	647b      	str	r3, [r7, #68]	; 0x44
    f7cc:	653b      	str	r3, [r7, #80]	; 0x50
    f7ce:	66fb      	str	r3, [r7, #108]	; 0x6c
    f7d0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    f7d2:	42b3      	cmp	r3, r6
    f7d4:	f6bf af46 	bge.w	f664 <silk_encode_pulses+0x134>
    f7d8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    f7da:	42b3      	cmp	r3, r6
    f7dc:	f2c0 8175 	blt.w	faca <silk_encode_pulses+0x59a>
        pulses_comb[ k ] = sum;
    f7e0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    f7e2:	4696      	mov	lr, r2
    f7e4:	601e      	str	r6, [r3, #0]
    f7e6:	460e      	mov	r6, r1
    f7e8:	e750      	b.n	f68c <silk_encode_pulses+0x15c>
    f7ea:	4613      	mov	r3, r2
    f7ec:	3304      	adds	r3, #4
    f7ee:	63bb      	str	r3, [r7, #56]	; 0x38
    for( i = 0; i < iter; i++ ) {
    f7f0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    f7f2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    f7f4:	4293      	cmp	r3, r2
    f7f6:	f10a 0a40 	add.w	sl, sl, #64	; 0x40
    f7fa:	f47f af28 	bne.w	f64e <silk_encode_pulses+0x11e>
    f7fe:	4633      	mov	r3, r6
    f800:	673b      	str	r3, [r7, #112]	; 0x70
    f802:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    f804:	f8d7 b000 	ldr.w	fp, [r7]
    f808:	b10b      	cbz	r3, f80e <silk_encode_pulses+0x2de>
    f80a:	f8c7 e074 	str.w	lr, [r7, #116]	; 0x74
    f80e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    f810:	b10b      	cbz	r3, f816 <silk_encode_pulses+0x2e6>
    f812:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    f814:	67bb      	str	r3, [r7, #120]	; 0x78
    f816:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    f818:	b10b      	cbz	r3, f81e <silk_encode_pulses+0x2ee>
    f81a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
    f81c:	67fb      	str	r3, [r7, #124]	; 0x7c
    f81e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    f820:	b113      	cbz	r3, f828 <silk_encode_pulses+0x2f8>
    f822:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    f824:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
    f828:	6abb      	ldr	r3, [r7, #40]	; 0x28
    f82a:	b113      	cbz	r3, f832 <silk_encode_pulses+0x302>
    f82c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    f82e:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
    f832:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    f834:	b113      	cbz	r3, f83c <silk_encode_pulses+0x30c>
    f836:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    f838:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
    f83c:	f1b9 0f00 	cmp.w	r9, #0
    f840:	d073      	beq.n	f92a <silk_encode_pulses+0x3fa>
    f842:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    f844:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
    f848:	e06f      	b.n	f92a <silk_encode_pulses+0x3fa>
    f84a:	3401      	adds	r4, #1
    f84c:	1993      	adds	r3, r2, r6
        if( sum > max_pulses ) {
    f84e:	4696      	mov	lr, r2
    f850:	e714      	b.n	f67c <silk_encode_pulses+0x14c>
    f852:	6eba      	ldr	r2, [r7, #104]	; 0x68
    f854:	667a      	str	r2, [r7, #100]	; 0x64
    f856:	6e3a      	ldr	r2, [r7, #96]	; 0x60
    f858:	65ba      	str	r2, [r7, #88]	; 0x58
    f85a:	460e      	mov	r6, r1
    f85c:	4674      	mov	r4, lr
    f85e:	461a      	mov	r2, r3
    f860:	4601      	mov	r1, r0
    f862:	e7b5      	b.n	f7d0 <silk_encode_pulses+0x2a0>
    f864:	6e7b      	ldr	r3, [r7, #100]	; 0x64
    f866:	66bb      	str	r3, [r7, #104]	; 0x68
    f868:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    f86a:	663b      	str	r3, [r7, #96]	; 0x60
    f86c:	4630      	mov	r0, r6
    f86e:	4673      	mov	r3, lr
            return 1;
    f870:	2401      	movs	r4, #1
        if( sum > max_pulses ) {
    f872:	f04f 0e02 	mov.w	lr, #2
    f876:	e790      	b.n	f79a <silk_encode_pulses+0x26a>
    f878:	6e3a      	ldr	r2, [r7, #96]	; 0x60
    f87a:	65ba      	str	r2, [r7, #88]	; 0x58
    f87c:	4674      	mov	r4, lr
    f87e:	6678      	str	r0, [r7, #100]	; 0x64
    f880:	185e      	adds	r6, r3, r1
    f882:	461a      	mov	r2, r3
    f884:	e7a4      	b.n	f7d0 <silk_encode_pulses+0x2a0>
    f886:	6e7b      	ldr	r3, [r7, #100]	; 0x64
    f888:	66bb      	str	r3, [r7, #104]	; 0x68
    f88a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    f88c:	663b      	str	r3, [r7, #96]	; 0x60
            return 1;
    f88e:	2401      	movs	r4, #1
        if( sum > max_pulses ) {
    f890:	4673      	mov	r3, lr
    f892:	f04f 0e02 	mov.w	lr, #2
    f896:	e780      	b.n	f79a <silk_encode_pulses+0x26a>
    f898:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    f89a:	667b      	str	r3, [r7, #100]	; 0x64
    f89c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
    f89e:	65bb      	str	r3, [r7, #88]	; 0x58
    f8a0:	2301      	movs	r3, #1
    f8a2:	4674      	mov	r4, lr
    f8a4:	66fb      	str	r3, [r7, #108]	; 0x6c
    f8a6:	e793      	b.n	f7d0 <silk_encode_pulses+0x2a0>
    f8a8:	6e7a      	ldr	r2, [r7, #100]	; 0x64
    f8aa:	66ba      	str	r2, [r7, #104]	; 0x68
    f8ac:	2401      	movs	r4, #1
    f8ae:	6dba      	ldr	r2, [r7, #88]	; 0x58
    f8b0:	66fc      	str	r4, [r7, #108]	; 0x6c
    f8b2:	663a      	str	r2, [r7, #96]	; 0x60
    f8b4:	f04f 0e02 	mov.w	lr, #2
    f8b8:	e76f      	b.n	f79a <silk_encode_pulses+0x26a>
    f8ba:	6eb8      	ldr	r0, [r7, #104]	; 0x68
    f8bc:	653b      	str	r3, [r7, #80]	; 0x50
    f8be:	4674      	mov	r4, lr
    f8c0:	6678      	str	r0, [r7, #100]	; 0x64
    f8c2:	66fb      	str	r3, [r7, #108]	; 0x6c
    f8c4:	e784      	b.n	f7d0 <silk_encode_pulses+0x2a0>
    f8c6:	6e79      	ldr	r1, [r7, #100]	; 0x64
    f8c8:	2201      	movs	r2, #1
    f8ca:	653a      	str	r2, [r7, #80]	; 0x50
    f8cc:	e9c7 121a 	strd	r1, r2, [r7, #104]	; 0x68
            return 1;
    f8d0:	4614      	mov	r4, r2
        if( sum > max_pulses ) {
    f8d2:	f04f 0e02 	mov.w	lr, #2
    f8d6:	e760      	b.n	f79a <silk_encode_pulses+0x26a>
    f8d8:	00036dd8 	.word	0x00036dd8
    f8dc:	2401      	movs	r4, #1
    f8de:	647c      	str	r4, [r7, #68]	; 0x44
    f8e0:	653c      	str	r4, [r7, #80]	; 0x50
    f8e2:	66fc      	str	r4, [r7, #108]	; 0x6c
    f8e4:	f04f 0e02 	mov.w	lr, #2
    f8e8:	e757      	b.n	f79a <silk_encode_pulses+0x26a>
    f8ea:	2401      	movs	r4, #1
    f8ec:	633c      	str	r4, [r7, #48]	; 0x30
    f8ee:	64fa      	str	r2, [r7, #76]	; 0x4c
    f8f0:	647c      	str	r4, [r7, #68]	; 0x44
    f8f2:	653c      	str	r4, [r7, #80]	; 0x50
    f8f4:	66fc      	str	r4, [r7, #108]	; 0x6c
    f8f6:	f04f 0e02 	mov.w	lr, #2
    f8fa:	e74e      	b.n	f79a <silk_encode_pulses+0x26a>
    f8fc:	e9c7 1212 	strd	r1, r2, [r7, #72]	; 0x48
    f900:	f04f 0901 	mov.w	r9, #1
    f904:	f8c7 9030 	str.w	r9, [r7, #48]	; 0x30
    f908:	f8c7 9044 	str.w	r9, [r7, #68]	; 0x44
    f90c:	f8c7 9050 	str.w	r9, [r7, #80]	; 0x50
    f910:	f8c7 906c 	str.w	r9, [r7, #108]	; 0x6c
            return 1;
    f914:	464c      	mov	r4, r9
        if( sum > max_pulses ) {
    f916:	f04f 0e02 	mov.w	lr, #2
    f91a:	e73e      	b.n	f79a <silk_encode_pulses+0x26a>
    f91c:	f8c7 e040 	str.w	lr, [r7, #64]	; 0x40
    f920:	e9c7 990b 	strd	r9, r9, [r7, #44]	; 0x2c
    f924:	e7f0      	b.n	f908 <silk_encode_pulses+0x3d8>
    f926:	1f13      	subs	r3, r2, #4
    f928:	61bb      	str	r3, [r7, #24]
    /**************/
    /* find rate level that leads to fewest bits for coding of pulses per block info */
    minSumBits_Q5 = silk_int32_MAX;
    for( k = 0; k < N_RATE_LEVELS - 1; k++ ) {
        nBits_ptr  = silk_pulses_per_block_BITS_Q5[ k ];
        sumBits_Q5 = silk_rate_levels_BITS_Q5[ signalType >> 1 ][ k ];
    f92a:	68bb      	ldr	r3, [r7, #8]
    f92c:	4d68      	ldr	r5, [pc, #416]	; (fad0 <silk_encode_pulses+0x5a0>)
    minSumBits_Q5 = silk_int32_MAX;
    f92e:	f8d7 a01c 	ldr.w	sl, [r7, #28]
    f932:	f8c7 b068 	str.w	fp, [r7, #104]	; 0x68
        sumBits_Q5 = silk_rate_levels_BITS_Q5[ signalType >> 1 ][ k ];
    f936:	ea4f 0963 	mov.w	r9, r3, asr #1
    f93a:	4b66      	ldr	r3, [pc, #408]	; (fad4 <silk_encode_pulses+0x5a4>)
    f93c:	eb09 09c9 	add.w	r9, r9, r9, lsl #3
    f940:	eb09 0e03 	add.w	lr, r9, r3
    f944:	e9d7 3205 	ldrd	r3, r2, [r7, #20]
    for( k = 0; k < N_RATE_LEVELS - 1; k++ ) {
    f948:	f04f 0c00 	mov.w	ip, #0
    minSumBits_Q5 = silk_int32_MAX;
    f94c:	f8c7 906c 	str.w	r9, [r7, #108]	; 0x6c
    f950:	f8d7 9020 	ldr.w	r9, [r7, #32]
    opus_int   i, k, j, iter, bit, nLS, scale_down, RateLevelIndex = 0;
    f954:	4664      	mov	r4, ip
    f956:	189e      	adds	r6, r3, r2
    minSumBits_Q5 = silk_int32_MAX;
    f958:	f06f 4800 	mvn.w	r8, #2147483648	; 0x80000000
    f95c:	469b      	mov	fp, r3
        for( i = 0; i < iter; i++ ) {
    f95e:	f1b9 0f00 	cmp.w	r9, #0
        sumBits_Q5 = silk_rate_levels_BITS_Q5[ signalType >> 1 ][ k ];
    f962:	f81e 1b01 	ldrb.w	r1, [lr], #1
        for( i = 0; i < iter; i++ ) {
    f966:	dd0e      	ble.n	f986 <silk_encode_pulses+0x456>
    f968:	f1ab 0304 	sub.w	r3, fp, #4
    f96c:	4652      	mov	r2, sl
            if( nRshifts[ i ] > 0 ) {
    f96e:	f853 0f04 	ldr.w	r0, [r3, #4]!
    f972:	2800      	cmp	r0, #0
                sumBits_Q5 += nBits_ptr[ SILK_MAX_PULSES + 1 ];
            } else {
                sumBits_Q5 += nBits_ptr[ sum_pulses[ i ] ];
    f974:	bfd6      	itet	le
    f976:	6810      	ldrle	r0, [r2, #0]
                sumBits_Q5 += nBits_ptr[ SILK_MAX_PULSES + 1 ];
    f978:	7c68      	ldrbgt	r0, [r5, #17]
                sumBits_Q5 += nBits_ptr[ sum_pulses[ i ] ];
    f97a:	5c28      	ldrble	r0, [r5, r0]
        for( i = 0; i < iter; i++ ) {
    f97c:	429e      	cmp	r6, r3
                sumBits_Q5 += nBits_ptr[ sum_pulses[ i ] ];
    f97e:	4401      	add	r1, r0
    f980:	f102 0204 	add.w	r2, r2, #4
        for( i = 0; i < iter; i++ ) {
    f984:	d1f3      	bne.n	f96e <silk_encode_pulses+0x43e>
            }
        }
        if( sumBits_Q5 < minSumBits_Q5 ) {
    f986:	4541      	cmp	r1, r8
    f988:	bfb8      	it	lt
    f98a:	4664      	movlt	r4, ip
    for( k = 0; k < N_RATE_LEVELS - 1; k++ ) {
    f98c:	f10c 0c01 	add.w	ip, ip, #1
    f990:	bfb8      	it	lt
    f992:	4688      	movlt	r8, r1
    f994:	f1bc 0f09 	cmp.w	ip, #9
    f998:	f105 0512 	add.w	r5, r5, #18
    f99c:	d1df      	bne.n	f95e <silk_encode_pulses+0x42e>
    f99e:	e9d7 b91a 	ldrd	fp, r9, [r7, #104]	; 0x68
            minSumBits_Q5 = sumBits_Q5;
            RateLevelIndex = k;
        }
    }
    ec_enc_icdf( psRangeEnc, RateLevelIndex, silk_rate_levels_iCDF[ signalType >> 1 ], 8 );
    f9a2:	4a4d      	ldr	r2, [pc, #308]	; (fad8 <silk_encode_pulses+0x5a8>)
    f9a4:	2308      	movs	r3, #8
    f9a6:	444a      	add	r2, r9
    f9a8:	4621      	mov	r1, r4
    f9aa:	4658      	mov	r0, fp
    f9ac:	f01a fa68 	bl	29e80 <ec_enc_icdf>

    /***************************************************/
    /* Sum-Weighted-Pulses Encoding                    */
    /***************************************************/
    cdf_ptr = silk_pulses_per_block_iCDF[ RateLevelIndex ];
    f9b0:	4b4a      	ldr	r3, [pc, #296]	; (fadc <silk_encode_pulses+0x5ac>)
    f9b2:	eb04 04c4 	add.w	r4, r4, r4, lsl #3
    f9b6:	eb03 0244 	add.w	r2, r3, r4, lsl #1
    f9ba:	66ba      	str	r2, [r7, #104]	; 0x68
    for( i = 0; i < iter; i++ ) {
    f9bc:	6a3a      	ldr	r2, [r7, #32]
    f9be:	2a00      	cmp	r2, #0
    f9c0:	dd74      	ble.n	faac <silk_encode_pulses+0x57c>
    f9c2:	697a      	ldr	r2, [r7, #20]
    f9c4:	f8d7 801c 	ldr.w	r8, [r7, #28]
        } else {
            ec_enc_icdf( psRangeEnc, SILK_MAX_PULSES + 1, cdf_ptr, 8 );
            for( k = 0; k < nRshifts[ i ] - 1; k++ ) {
                ec_enc_icdf( psRangeEnc, SILK_MAX_PULSES + 1, silk_pulses_per_block_iCDF[ N_RATE_LEVELS - 1 ], 8 );
            }
            ec_enc_icdf( psRangeEnc, sum_pulses[ i ], silk_pulses_per_block_iCDF[ N_RATE_LEVELS - 1 ], 8 );
    f9c8:	f103 09a2 	add.w	r9, r3, #162	; 0xa2
    f9cc:	69bb      	ldr	r3, [r7, #24]
    f9ce:	1f16      	subs	r6, r2, #4
    f9d0:	66fe      	str	r6, [r7, #108]	; 0x6c
    f9d2:	eb02 0a03 	add.w	sl, r2, r3
    f9d6:	e008      	b.n	f9ea <silk_encode_pulses+0x4ba>
    f9d8:	f8d8 1000 	ldr.w	r1, [r8]
    f9dc:	4658      	mov	r0, fp
    f9de:	f01a fa4f 	bl	29e80 <ec_enc_icdf>
    for( i = 0; i < iter; i++ ) {
    f9e2:	45b2      	cmp	sl, r6
    f9e4:	f108 0804 	add.w	r8, r8, #4
    f9e8:	d019      	beq.n	fa1e <silk_encode_pulses+0x4ee>
        if( nRshifts[ i ] == 0 ) {
    f9ea:	f856 5f04 	ldr.w	r5, [r6, #4]!
            ec_enc_icdf( psRangeEnc, sum_pulses[ i ], cdf_ptr, 8 );
    f9ee:	6eba      	ldr	r2, [r7, #104]	; 0x68
    f9f0:	2308      	movs	r3, #8
        if( nRshifts[ i ] == 0 ) {
    f9f2:	2d00      	cmp	r5, #0
    f9f4:	d0f0      	beq.n	f9d8 <silk_encode_pulses+0x4a8>
            ec_enc_icdf( psRangeEnc, SILK_MAX_PULSES + 1, cdf_ptr, 8 );
    f9f6:	2111      	movs	r1, #17
    f9f8:	4658      	mov	r0, fp
    f9fa:	f01a fa41 	bl	29e80 <ec_enc_icdf>
            for( k = 0; k < nRshifts[ i ] - 1; k++ ) {
    f9fe:	2d01      	cmp	r5, #1
    fa00:	dd0a      	ble.n	fa18 <silk_encode_pulses+0x4e8>
    fa02:	3d01      	subs	r5, #1
    fa04:	2400      	movs	r4, #0
    fa06:	3401      	adds	r4, #1
                ec_enc_icdf( psRangeEnc, SILK_MAX_PULSES + 1, silk_pulses_per_block_iCDF[ N_RATE_LEVELS - 1 ], 8 );
    fa08:	2308      	movs	r3, #8
    fa0a:	464a      	mov	r2, r9
    fa0c:	2111      	movs	r1, #17
    fa0e:	4658      	mov	r0, fp
    fa10:	f01a fa36 	bl	29e80 <ec_enc_icdf>
            for( k = 0; k < nRshifts[ i ] - 1; k++ ) {
    fa14:	42ac      	cmp	r4, r5
    fa16:	d1f6      	bne.n	fa06 <silk_encode_pulses+0x4d6>
            ec_enc_icdf( psRangeEnc, sum_pulses[ i ], silk_pulses_per_block_iCDF[ N_RATE_LEVELS - 1 ], 8 );
    fa18:	2308      	movs	r3, #8
    fa1a:	464a      	mov	r2, r9
    fa1c:	e7dc      	b.n	f9d8 <silk_encode_pulses+0x4a8>
    fa1e:	69fb      	ldr	r3, [r7, #28]
    fa20:	69ba      	ldr	r2, [r7, #24]
    fa22:	68fc      	ldr	r4, [r7, #12]
    fa24:	1f1d      	subs	r5, r3, #4
    fa26:	189e      	adds	r6, r3, r2

    /******************/
    /* Shell Encoding */
    /******************/
    for( i = 0; i < iter; i++ ) {
        if( sum_pulses[ i ] > 0 ) {
    fa28:	f855 3f04 	ldr.w	r3, [r5, #4]!
    fa2c:	2b00      	cmp	r3, #0
            silk_shell_encoder( psRangeEnc, &abs_pulses[ i * SHELL_CODEC_FRAME_LENGTH ] );
    fa2e:	4621      	mov	r1, r4
    fa30:	4658      	mov	r0, fp
    fa32:	f104 0440 	add.w	r4, r4, #64	; 0x40
        if( sum_pulses[ i ] > 0 ) {
    fa36:	dd01      	ble.n	fa3c <silk_encode_pulses+0x50c>
            silk_shell_encoder( psRangeEnc, &abs_pulses[ i * SHELL_CODEC_FRAME_LENGTH ] );
    fa38:	f003 fe40 	bl	136bc <silk_shell_encoder>
    for( i = 0; i < iter; i++ ) {
    fa3c:	42ae      	cmp	r6, r5
    fa3e:	d1f3      	bne.n	fa28 <silk_encode_pulses+0x4f8>
    fa40:	e9d7 3205 	ldrd	r3, r2, [r7, #20]
    fa44:	4413      	add	r3, r2
    fa46:	66bb      	str	r3, [r7, #104]	; 0x68
    fa48:	693b      	ldr	r3, [r7, #16]
            nLS = nRshifts[ i ] - 1;
            for( k = 0; k < SHELL_CODEC_FRAME_LENGTH; k++ ) {
                abs_q = (opus_int8)silk_abs( pulses_ptr[ k ] );
                for( j = nLS; j > 0; j-- ) {
                    bit = silk_RSHIFT( abs_q, j ) & 1;
                    ec_enc_icdf( psRangeEnc, bit, silk_lsb_iCDF, 8 );
    fa4a:	4e25      	ldr	r6, [pc, #148]	; (fae0 <silk_encode_pulses+0x5b0>)
    fa4c:	6efa      	ldr	r2, [r7, #108]	; 0x6c
    fa4e:	f103 0a0f 	add.w	sl, r3, #15
        if( nRshifts[ i ] > 0 ) {
    fa52:	f852 3f04 	ldr.w	r3, [r2, #4]!
    fa56:	66fa      	str	r2, [r7, #108]	; 0x6c
    fa58:	2b00      	cmp	r3, #0
    fa5a:	dd21      	ble.n	faa0 <silk_encode_pulses+0x570>
            nLS = nRshifts[ i ] - 1;
    fa5c:	f103 39ff 	add.w	r9, r3, #4294967295	; 0xffffffff
    fa60:	f1aa 0810 	sub.w	r8, sl, #16
                abs_q = (opus_int8)silk_abs( pulses_ptr[ k ] );
    fa64:	f918 5f01 	ldrsb.w	r5, [r8, #1]!
    fa68:	2d00      	cmp	r5, #0
    fa6a:	bfdc      	itt	le
    fa6c:	426d      	negle	r5, r5
    fa6e:	b26d      	sxtble	r5, r5
                for( j = nLS; j > 0; j-- ) {
    fa70:	f1b9 0f00 	cmp.w	r9, #0
    fa74:	d00b      	beq.n	fa8e <silk_encode_pulses+0x55e>
    fa76:	464c      	mov	r4, r9
                    bit = silk_RSHIFT( abs_q, j ) & 1;
    fa78:	fa45 f104 	asr.w	r1, r5, r4
                    ec_enc_icdf( psRangeEnc, bit, silk_lsb_iCDF, 8 );
    fa7c:	f001 0101 	and.w	r1, r1, #1
    fa80:	2308      	movs	r3, #8
    fa82:	4632      	mov	r2, r6
    fa84:	4658      	mov	r0, fp
    fa86:	f01a f9fb 	bl	29e80 <ec_enc_icdf>
                for( j = nLS; j > 0; j-- ) {
    fa8a:	3c01      	subs	r4, #1
    fa8c:	d1f4      	bne.n	fa78 <silk_encode_pulses+0x548>
                }
                bit = abs_q & 1;
                ec_enc_icdf( psRangeEnc, bit, silk_lsb_iCDF, 8 );
    fa8e:	f005 0101 	and.w	r1, r5, #1
    fa92:	2308      	movs	r3, #8
    fa94:	4632      	mov	r2, r6
    fa96:	4658      	mov	r0, fp
    fa98:	f01a f9f2 	bl	29e80 <ec_enc_icdf>
            for( k = 0; k < SHELL_CODEC_FRAME_LENGTH; k++ ) {
    fa9c:	45c2      	cmp	sl, r8
    fa9e:	d1e1      	bne.n	fa64 <silk_encode_pulses+0x534>
    for( i = 0; i < iter; i++ ) {
    faa0:	e9d7 321a 	ldrd	r3, r2, [r7, #104]	; 0x68
    faa4:	4293      	cmp	r3, r2
    faa6:	f10a 0a10 	add.w	sl, sl, #16
    faaa:	d1d2      	bne.n	fa52 <silk_encode_pulses+0x522>
    }

    /****************/
    /* Encode signs */
    /****************/
    silk_encode_signs( psRangeEnc, pulses, frame_length, signalType, quantOffsetType, sum_pulses );
    faac:	69fb      	ldr	r3, [r7, #28]
    faae:	9301      	str	r3, [sp, #4]
    fab0:	687b      	ldr	r3, [r7, #4]
    fab2:	9300      	str	r3, [sp, #0]
    fab4:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
    fab8:	68bb      	ldr	r3, [r7, #8]
    faba:	6939      	ldr	r1, [r7, #16]
    fabc:	4658      	mov	r0, fp
    fabe:	f7fe f9e5 	bl	de8c <silk_encode_signs>
    RESTORE_STACK;
}
    fac2:	3794      	adds	r7, #148	; 0x94
    fac4:	46bd      	mov	sp, r7
    fac6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( sum > max_pulses ) {
    faca:	4696      	mov	lr, r2
    facc:	460e      	mov	r6, r1
    face:	e5dd      	b.n	f68c <silk_encode_pulses+0x15c>
    fad0:	00036ddc 	.word	0x00036ddc
    fad4:	00036f34 	.word	0x00036f34
    fad8:	00036f48 	.word	0x00036f48
    fadc:	00036e80 	.word	0x00036e80
    fae0:	00036cf4 	.word	0x00036cf4

0000fae4 <silk_gains_quant>:
    opus_int32                  gain_Q16[ MAX_NB_SUBFR ],       /* I/O  gains (quantized out)                       */
    opus_int8                   *prev_ind,                      /* I/O  last index in previous frame                */
    const opus_int              conditional,                    /* I    first gain is delta coded if 1              */
    const opus_int              nb_subfr                        /* I    number of subframes                         */
)
{
    fae4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    fae8:	b083      	sub	sp, #12
    faea:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    opus_int k, double_step_size_threshold;

    for( k = 0; k < nb_subfr; k++ ) {
    faec:	2d00      	cmp	r5, #0
    faee:	dd70      	ble.n	fbd2 <silk_gains_quant+0xee>
    faf0:	9301      	str	r3, [sp, #4]
    faf2:	4693      	mov	fp, r2
    faf4:	1f0c      	subs	r4, r1, #4
    faf6:	4682      	mov	sl, r0
    faf8:	f04f 0900 	mov.w	r9, #0
        /* Convert to log scale, scale, floor() */
        ind[ k ] = silk_SMULWB( SCALE_Q16, silk_lin2log( gain_Q16[ k ] ) - OFFSET );
    fafc:	f640 06cb 	movw	r6, #2251	; 0x8cb
            double_step_size_threshold = 2 * MAX_DELTA_GAIN_QUANT - N_LEVELS_QGAIN + *prev_ind;
            if( ind[ k ] > double_step_size_threshold ) {
                ind[ k ] = double_step_size_threshold + silk_RSHIFT( ind[ k ] - double_step_size_threshold + 1, 1 );
            }

            ind[ k ] = silk_LIMIT_int( ind[ k ], MIN_DELTA_GAIN_QUANT, MAX_DELTA_GAIN_QUANT );
    fb00:	f06f 0803 	mvn.w	r8, #3
    fb04:	f641 4771 	movw	r7, #7281	; 0x1c71
    fb08:	e027      	b.n	fb5a <silk_gains_quant+0x76>

            /* Accumulate deltas */
            if( ind[ k ] > double_step_size_threshold ) {
                *prev_ind += silk_LSHIFT( ind[ k ], 1 ) - double_step_size_threshold;
    fb0a:	f89b 1000 	ldrb.w	r1, [fp]
    fb0e:	1a8a      	subs	r2, r1, r2
    fb10:	eb02 0240 	add.w	r2, r2, r0, lsl #1
                *prev_ind = silk_min_int( *prev_ind, N_LEVELS_QGAIN - 1 );
    fb14:	b252      	sxtb	r2, r2
    fb16:	2a3f      	cmp	r2, #63	; 0x3f
    fb18:	bfa8      	it	ge
    fb1a:	223f      	movge	r2, #63	; 0x3f
    fb1c:	f88b 2000 	strb.w	r2, [fp]
            } else {
                *prev_ind += ind[ k ];
            }

            /* Shift to make non-negative */
            ind[ k ] -= MIN_DELTA_GAIN_QUANT;
    fb20:	f89a 2000 	ldrb.w	r2, [sl]
    fb24:	3204      	adds	r2, #4
    fb26:	f88a 2000 	strb.w	r2, [sl]
    fb2a:	f99b 1000 	ldrsb.w	r1, [fp]
    fb2e:	fb07 f001 	mul.w	r0, r7, r1
    fb32:	1402      	asrs	r2, r0, #16
    fb34:	201d      	movs	r0, #29
    fb36:	fb10 2001 	smlabb	r0, r0, r1, r2
    fb3a:	f600 002a 	addw	r0, r0, #2090	; 0x82a
    fb3e:	f640 727f 	movw	r2, #3967	; 0xf7f
    fb42:	4290      	cmp	r0, r2
    fb44:	bfa8      	it	ge
    fb46:	4610      	movge	r0, r2
        }

        /* Scale and convert to linear scale */
        gain_Q16[ k ] = silk_log2lin( silk_min_32( silk_SMULWB( INV_SCALE_Q16, *prev_ind ) + OFFSET, 3967 ) ); /* 3967 = 31 in Q7 */
    fb48:	f007 ff76 	bl	17a38 <silk_log2lin>
    for( k = 0; k < nb_subfr; k++ ) {
    fb4c:	f109 0901 	add.w	r9, r9, #1
    fb50:	454d      	cmp	r5, r9
        gain_Q16[ k ] = silk_log2lin( silk_min_32( silk_SMULWB( INV_SCALE_Q16, *prev_ind ) + OFFSET, 3967 ) ); /* 3967 = 31 in Q7 */
    fb52:	6020      	str	r0, [r4, #0]
    fb54:	f10a 0a01 	add.w	sl, sl, #1
    for( k = 0; k < nb_subfr; k++ ) {
    fb58:	d03b      	beq.n	fbd2 <silk_gains_quant+0xee>
        ind[ k ] = silk_SMULWB( SCALE_Q16, silk_lin2log( gain_Q16[ k ] ) - OFFSET );
    fb5a:	f854 0f04 	ldr.w	r0, [r4, #4]!
    fb5e:	f007 ff2b 	bl	179b8 <silk_lin2log>
    fb62:	6820      	ldr	r0, [r4, #0]
    fb64:	f007 ff28 	bl	179b8 <silk_lin2log>
    fb68:	f6a0 002a 	subw	r0, r0, #2090	; 0x82a
    fb6c:	fb10 f006 	smulbb	r0, r0, r6
    fb70:	1400      	asrs	r0, r0, #16
    fb72:	b241      	sxtb	r1, r0
    fb74:	f88a 1000 	strb.w	r1, [sl]
        if( ind[ k ] < *prev_ind ) {
    fb78:	f99b 2000 	ldrsb.w	r2, [fp]
    fb7c:	428a      	cmp	r2, r1
            ind[ k ]++;
    fb7e:	bfc4      	itt	gt
    fb80:	1c41      	addgt	r1, r0, #1
    fb82:	b249      	sxtbgt	r1, r1
    fb84:	f381 0106 	usat	r1, #6, r1
        ind[ k ] = silk_LIMIT_int( ind[ k ], 0, N_LEVELS_QGAIN - 1 );
    fb88:	f88a 1000 	strb.w	r1, [sl]
    fb8c:	f99b 2000 	ldrsb.w	r2, [fp]
        if( k == 0 && conditional == 0 ) {
    fb90:	f1b9 0f00 	cmp.w	r9, #0
    fb94:	d020      	beq.n	fbd8 <silk_gains_quant+0xf4>
            ind[ k ] = ind[ k ] - *prev_ind;
    fb96:	1a89      	subs	r1, r1, r2
    fb98:	b249      	sxtb	r1, r1
    fb9a:	f88a 1000 	strb.w	r1, [sl]
            double_step_size_threshold = 2 * MAX_DELTA_GAIN_QUANT - N_LEVELS_QGAIN + *prev_ind;
    fb9e:	f99b 2000 	ldrsb.w	r2, [fp]
    fba2:	3208      	adds	r2, #8
            if( ind[ k ] > double_step_size_threshold ) {
    fba4:	4291      	cmp	r1, r2
    fba6:	dd04      	ble.n	fbb2 <silk_gains_quant+0xce>
                ind[ k ] = double_step_size_threshold + silk_RSHIFT( ind[ k ] - double_step_size_threshold + 1, 1 );
    fba8:	1a89      	subs	r1, r1, r2
    fbaa:	3101      	adds	r1, #1
    fbac:	eb02 0161 	add.w	r1, r2, r1, asr #1
    fbb0:	b249      	sxtb	r1, r1
    fbb2:	4541      	cmp	r1, r8
    fbb4:	bfb8      	it	lt
    fbb6:	4641      	movlt	r1, r8
    fbb8:	2924      	cmp	r1, #36	; 0x24
    fbba:	bfa8      	it	ge
    fbbc:	2124      	movge	r1, #36	; 0x24
            if( ind[ k ] > double_step_size_threshold ) {
    fbbe:	4291      	cmp	r1, r2
            ind[ k ] = silk_LIMIT_int( ind[ k ], MIN_DELTA_GAIN_QUANT, MAX_DELTA_GAIN_QUANT );
    fbc0:	f88a 1000 	strb.w	r1, [sl]
    fbc4:	b2c8      	uxtb	r0, r1
            if( ind[ k ] > double_step_size_threshold ) {
    fbc6:	dca0      	bgt.n	fb0a <silk_gains_quant+0x26>
                *prev_ind += ind[ k ];
    fbc8:	f89b 2000 	ldrb.w	r2, [fp]
    fbcc:	4402      	add	r2, r0
    fbce:	b252      	sxtb	r2, r2
    fbd0:	e7a4      	b.n	fb1c <silk_gains_quant+0x38>
    }
}
    fbd2:	b003      	add	sp, #12
    fbd4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( k == 0 && conditional == 0 ) {
    fbd8:	9b01      	ldr	r3, [sp, #4]
    fbda:	2b00      	cmp	r3, #0
    fbdc:	d1db      	bne.n	fb96 <silk_gains_quant+0xb2>
            ind[ k ] = silk_LIMIT_int( ind[ k ], *prev_ind + MIN_DELTA_GAIN_QUANT, N_LEVELS_QGAIN - 1 );
    fbde:	2a43      	cmp	r2, #67	; 0x43
    fbe0:	dd07      	ble.n	fbf2 <silk_gains_quant+0x10e>
    fbe2:	f640 7053 	movw	r0, #3923	; 0xf53
    fbe6:	223f      	movs	r2, #63	; 0x3f
    fbe8:	f88a 2000 	strb.w	r2, [sl]
            *prev_ind = ind[ k ];
    fbec:	f88b 2000 	strb.w	r2, [fp]
    fbf0:	e7aa      	b.n	fb48 <silk_gains_quant+0x64>
            ind[ k ] = silk_LIMIT_int( ind[ k ], *prev_ind + MIN_DELTA_GAIN_QUANT, N_LEVELS_QGAIN - 1 );
    fbf2:	3a04      	subs	r2, #4
    fbf4:	4291      	cmp	r1, r2
    fbf6:	bfb8      	it	lt
    fbf8:	4611      	movlt	r1, r2
    fbfa:	ebc1 00c1 	rsb	r0, r1, r1, lsl #3
    fbfe:	fb07 f201 	mul.w	r2, r7, r1
    fc02:	eb01 0080 	add.w	r0, r1, r0, lsl #2
    fc06:	eb00 4022 	add.w	r0, r0, r2, asr #16
    fc0a:	f600 002a 	addw	r0, r0, #2090	; 0x82a
    fc0e:	b24a      	sxtb	r2, r1
    fc10:	e7ea      	b.n	fbe8 <silk_gains_quant+0x104>
    fc12:	bf00      	nop

0000fc14 <silk_gains_dequant>:
    const opus_int8             ind[ MAX_NB_SUBFR ],            /* I    gain indices                                */
    opus_int8                   *prev_ind,                      /* I/O  last index in previous frame                */
    const opus_int              conditional,                    /* I    first gain is delta coded if 1              */
    const opus_int              nb_subfr                        /* I    number of subframes                          */
)
{
    fc14:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    fc18:	9e0a      	ldr	r6, [sp, #40]	; 0x28
    opus_int   k, ind_tmp, double_step_size_threshold;

    for( k = 0; k < nb_subfr; k++ ) {
    fc1a:	2e00      	cmp	r6, #0
    fc1c:	dd30      	ble.n	fc80 <silk_gains_dequant+0x6c>
    fc1e:	4692      	mov	sl, r2
    fc20:	460d      	mov	r5, r1
    fc22:	bb7b      	cbnz	r3, fc84 <silk_gains_dequant+0x70>
    fc24:	f1a0 0b04 	sub.w	fp, r0, #4
    fc28:	4699      	mov	r9, r3
            }
        }
        *prev_ind = silk_LIMIT_int( *prev_ind, 0, N_LEVELS_QGAIN - 1 );

        /* Scale and convert to linear scale */
        gain_Q16[ k ] = silk_log2lin( silk_min_32( silk_SMULWB( INV_SCALE_Q16, *prev_ind ) + OFFSET, 3967 ) ); /* 3967 = 31 in Q7 */
    fc2a:	f641 4871 	movw	r8, #7281	; 0x1c71
    fc2e:	271d      	movs	r7, #29
    fc30:	f99a 3000 	ldrsb.w	r3, [sl]
            double_step_size_threshold = 2 * MAX_DELTA_GAIN_QUANT - N_LEVELS_QGAIN + *prev_ind;
    fc34:	f103 0108 	add.w	r1, r3, #8
    fc38:	b2d8      	uxtb	r0, r3
                *prev_ind += silk_LSHIFT( ind_tmp, 1 ) - double_step_size_threshold;
    fc3a:	1a42      	subs	r2, r0, r1
        if( k == 0 && conditional == 0 ) {
    fc3c:	f1b9 0f00 	cmp.w	r9, #0
    fc40:	d05f      	beq.n	fd02 <silk_gains_dequant+0xee>
            ind_tmp = ind[ k ] + MIN_DELTA_GAIN_QUANT;
    fc42:	f915 3009 	ldrsb.w	r3, [r5, r9]
    fc46:	3b04      	subs	r3, #4
    fc48:	fa5f fc83 	uxtb.w	ip, r3
            if( ind_tmp > double_step_size_threshold ) {
    fc4c:	428b      	cmp	r3, r1
                *prev_ind += silk_LSHIFT( ind_tmp, 1 ) - double_step_size_threshold;
    fc4e:	eb02 044c 	add.w	r4, r2, ip, lsl #1
                *prev_ind += ind_tmp;
    fc52:	bfd8      	it	le
    fc54:	eb00 040c 	addle.w	r4, r0, ip
    fc58:	b264      	sxtb	r4, r4
    fc5a:	f384 0406 	usat	r4, #6, r4
        gain_Q16[ k ] = silk_log2lin( silk_min_32( silk_SMULWB( INV_SCALE_Q16, *prev_ind ) + OFFSET, 3967 ) ); /* 3967 = 31 in Q7 */
    fc5e:	fb08 f004 	mul.w	r0, r8, r4
    fc62:	1400      	asrs	r0, r0, #16
    fc64:	fb17 0004 	smlabb	r0, r7, r4, r0
        *prev_ind = silk_LIMIT_int( *prev_ind, 0, N_LEVELS_QGAIN - 1 );
    fc68:	f88a 4000 	strb.w	r4, [sl]
        gain_Q16[ k ] = silk_log2lin( silk_min_32( silk_SMULWB( INV_SCALE_Q16, *prev_ind ) + OFFSET, 3967 ) ); /* 3967 = 31 in Q7 */
    fc6c:	f600 002a 	addw	r0, r0, #2090	; 0x82a
    fc70:	f007 fee2 	bl	17a38 <silk_log2lin>
    for( k = 0; k < nb_subfr; k++ ) {
    fc74:	f109 0901 	add.w	r9, r9, #1
    fc78:	454e      	cmp	r6, r9
        gain_Q16[ k ] = silk_log2lin( silk_min_32( silk_SMULWB( INV_SCALE_Q16, *prev_ind ) + OFFSET, 3967 ) ); /* 3967 = 31 in Q7 */
    fc7a:	f84b 0f04 	str.w	r0, [fp, #4]!
    for( k = 0; k < nb_subfr; k++ ) {
    fc7e:	d1d7      	bne.n	fc30 <silk_gains_dequant+0x1c>
    }
}
    fc80:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    fc84:	1e4d      	subs	r5, r1, #1
    fc86:	442e      	add	r6, r5
    fc88:	f1a0 0b04 	sub.w	fp, r0, #4
        gain_Q16[ k ] = silk_log2lin( silk_min_32( silk_SMULWB( INV_SCALE_Q16, *prev_ind ) + OFFSET, 3967 ) ); /* 3967 = 31 in Q7 */
    fc8c:	f641 4771 	movw	r7, #7281	; 0x1c71
    fc90:	241d      	movs	r4, #29
            ind_tmp = ind[ k ] + MIN_DELTA_GAIN_QUANT;
    fc92:	f915 1f01 	ldrsb.w	r1, [r5, #1]!
    fc96:	f99a 0000 	ldrsb.w	r0, [sl]
    fc9a:	3904      	subs	r1, #4
            double_step_size_threshold = 2 * MAX_DELTA_GAIN_QUANT - N_LEVELS_QGAIN + *prev_ind;
    fc9c:	f100 0c08 	add.w	ip, r0, #8
    fca0:	b2cb      	uxtb	r3, r1
    fca2:	b2c0      	uxtb	r0, r0
                *prev_ind += silk_LSHIFT( ind_tmp, 1 ) - double_step_size_threshold;
    fca4:	eb00 0243 	add.w	r2, r0, r3, lsl #1
                *prev_ind += ind_tmp;
    fca8:	4403      	add	r3, r0
                *prev_ind += silk_LSHIFT( ind_tmp, 1 ) - double_step_size_threshold;
    fcaa:	eba2 020c 	sub.w	r2, r2, ip
        *prev_ind = silk_LIMIT_int( *prev_ind, 0, N_LEVELS_QGAIN - 1 );
    fcae:	b25b      	sxtb	r3, r3
    fcb0:	f383 0306 	usat	r3, #6, r3
    fcb4:	b252      	sxtb	r2, r2
    fcb6:	f382 0206 	usat	r2, #6, r2
        gain_Q16[ k ] = silk_log2lin( silk_min_32( silk_SMULWB( INV_SCALE_Q16, *prev_ind ) + OFFSET, 3967 ) ); /* 3967 = 31 in Q7 */
    fcba:	fb07 f003 	mul.w	r0, r7, r3
    fcbe:	fb07 fe02 	mul.w	lr, r7, r2
    fcc2:	1400      	asrs	r0, r0, #16
    fcc4:	ea4f 4e2e 	mov.w	lr, lr, asr #16
    fcc8:	fb14 0003 	smlabb	r0, r4, r3, r0
            if( ind_tmp > double_step_size_threshold ) {
    fccc:	458c      	cmp	ip, r1
        gain_Q16[ k ] = silk_log2lin( silk_min_32( silk_SMULWB( INV_SCALE_Q16, *prev_ind ) + OFFSET, 3967 ) ); /* 3967 = 31 in Q7 */
    fcce:	fb14 ee02 	smlabb	lr, r4, r2, lr
    fcd2:	f600 002a 	addw	r0, r0, #2090	; 0x82a
            if( ind_tmp > double_step_size_threshold ) {
    fcd6:	db08      	blt.n	fcea <silk_gains_dequant+0xd6>
        *prev_ind = silk_LIMIT_int( *prev_ind, 0, N_LEVELS_QGAIN - 1 );
    fcd8:	f88a 3000 	strb.w	r3, [sl]
        gain_Q16[ k ] = silk_log2lin( silk_min_32( silk_SMULWB( INV_SCALE_Q16, *prev_ind ) + OFFSET, 3967 ) ); /* 3967 = 31 in Q7 */
    fcdc:	f007 feac 	bl	17a38 <silk_log2lin>
    for( k = 0; k < nb_subfr; k++ ) {
    fce0:	42ae      	cmp	r6, r5
        gain_Q16[ k ] = silk_log2lin( silk_min_32( silk_SMULWB( INV_SCALE_Q16, *prev_ind ) + OFFSET, 3967 ) ); /* 3967 = 31 in Q7 */
    fce2:	f84b 0f04 	str.w	r0, [fp, #4]!
    for( k = 0; k < nb_subfr; k++ ) {
    fce6:	d1d4      	bne.n	fc92 <silk_gains_dequant+0x7e>
    fce8:	e7ca      	b.n	fc80 <silk_gains_dequant+0x6c>
        *prev_ind = silk_LIMIT_int( *prev_ind, 0, N_LEVELS_QGAIN - 1 );
    fcea:	f88a 2000 	strb.w	r2, [sl]
        gain_Q16[ k ] = silk_log2lin( silk_min_32( silk_SMULWB( INV_SCALE_Q16, *prev_ind ) + OFFSET, 3967 ) ); /* 3967 = 31 in Q7 */
    fcee:	f60e 002a 	addw	r0, lr, #2090	; 0x82a
    fcf2:	f007 fea1 	bl	17a38 <silk_log2lin>
    for( k = 0; k < nb_subfr; k++ ) {
    fcf6:	42ae      	cmp	r6, r5
        gain_Q16[ k ] = silk_log2lin( silk_min_32( silk_SMULWB( INV_SCALE_Q16, *prev_ind ) + OFFSET, 3967 ) ); /* 3967 = 31 in Q7 */
    fcf8:	f84b 0f04 	str.w	r0, [fp, #4]!
    for( k = 0; k < nb_subfr; k++ ) {
    fcfc:	d1c9      	bne.n	fc92 <silk_gains_dequant+0x7e>
}
    fcfe:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
            *prev_ind = silk_max_int( ind[ k ], *prev_ind - 16 );
    fd02:	f995 4000 	ldrsb.w	r4, [r5]
    fd06:	3b10      	subs	r3, #16
}

/* silk_min() versions with typecast in the function call */
static OPUS_INLINE opus_int silk_max_int(opus_int a, opus_int b)
{
    return (((a) > (b)) ? (a) : (b));
    fd08:	429c      	cmp	r4, r3
    fd0a:	bfb8      	it	lt
    fd0c:	461c      	movlt	r4, r3
    fd0e:	b264      	sxtb	r4, r4
    fd10:	e7a3      	b.n	fc5a <silk_gains_dequant+0x46>
    fd12:	bf00      	nop

0000fd14 <silk_gains_ID>:
{
    opus_int   k;
    opus_int32 gainsID;

    gainsID = 0;
    for( k = 0; k < nb_subfr; k++ ) {
    fd14:	2900      	cmp	r1, #0
    fd16:	dd09      	ble.n	fd2c <silk_gains_ID+0x18>
    fd18:	1e43      	subs	r3, r0, #1
    fd1a:	4419      	add	r1, r3
    gainsID = 0;
    fd1c:	2000      	movs	r0, #0
        gainsID = silk_ADD_LSHIFT32( ind[ k ], gainsID, 8 );
    fd1e:	f913 2f01 	ldrsb.w	r2, [r3, #1]!
    for( k = 0; k < nb_subfr; k++ ) {
    fd22:	4299      	cmp	r1, r3
        gainsID = silk_ADD_LSHIFT32( ind[ k ], gainsID, 8 );
    fd24:	eb02 2000 	add.w	r0, r2, r0, lsl #8
    for( k = 0; k < nb_subfr; k++ ) {
    fd28:	d1f9      	bne.n	fd1e <silk_gains_ID+0xa>
    fd2a:	4770      	bx	lr
    gainsID = 0;
    fd2c:	2000      	movs	r0, #0
    }

    return gainsID;
}
    fd2e:	4770      	bx	lr

0000fd30 <silk_interpolate>:
    const opus_int16            x0[ MAX_LPC_ORDER ],            /* I    first vector                                */
    const opus_int16            x1[ MAX_LPC_ORDER ],            /* I    second vector                               */
    const opus_int              ifact_Q2,                       /* I    interp. factor, weight on 2nd vector        */
    const opus_int              d                               /* I    number of parameters                        */
)
{
    fd30:	b470      	push	{r4, r5, r6}
    fd32:	9e03      	ldr	r6, [sp, #12]
    opus_int i;

    celt_assert( ifact_Q2 >= 0 );
    celt_assert( ifact_Q2 <= 4 );

    for( i = 0; i < d; i++ ) {
    fd34:	2e00      	cmp	r6, #0
    fd36:	dd12      	ble.n	fd5e <silk_interpolate+0x2e>
    fd38:	3902      	subs	r1, #2
    fd3a:	eb01 0646 	add.w	r6, r1, r6, lsl #1
    fd3e:	b21b      	sxth	r3, r3
    fd40:	3a02      	subs	r2, #2
    fd42:	3802      	subs	r0, #2
        xi[ i ] = (opus_int16)silk_ADD_RSHIFT( x0[ i ], silk_SMULBB( x1[ i ] - x0[ i ], ifact_Q2 ), 2 );
    fd44:	f831 5f02 	ldrh.w	r5, [r1, #2]!
    fd48:	f832 4f02 	ldrh.w	r4, [r2, #2]!
    fd4c:	1b64      	subs	r4, r4, r5
    fd4e:	fb14 f403 	smulbb	r4, r4, r3
    fd52:	eb05 04a4 	add.w	r4, r5, r4, asr #2
    for( i = 0; i < d; i++ ) {
    fd56:	428e      	cmp	r6, r1
        xi[ i ] = (opus_int16)silk_ADD_RSHIFT( x0[ i ], silk_SMULBB( x1[ i ] - x0[ i ], ifact_Q2 ), 2 );
    fd58:	f820 4f02 	strh.w	r4, [r0, #2]!
    for( i = 0; i < d; i++ ) {
    fd5c:	d1f2      	bne.n	fd44 <silk_interpolate+0x14>
    }
}
    fd5e:	bc70      	pop	{r4, r5, r6}
    fd60:	4770      	bx	lr
    fd62:	bf00      	nop

0000fd64 <silk_LP_variable_cutoff>:
void silk_LP_variable_cutoff(
    silk_LP_state               *psLP,                          /* I/O  LP filter state                             */
    opus_int16                  *frame,                         /* I/O  Low-pass filtered output signal             */
    const opus_int              frame_length                    /* I    Frame length                                */
)
{
    fd64:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    opus_int     ind = 0;

    silk_assert( psLP->transition_frame_no >= 0 && psLP->transition_frame_no <= TRANSITION_FRAMES );

    /* Run filter if needed */
    if( psLP->mode != 0 ) {
    fd68:	68c4      	ldr	r4, [r0, #12]
{
    fd6a:	b08f      	sub	sp, #60	; 0x3c
    if( psLP->mode != 0 ) {
    fd6c:	b914      	cbnz	r4, fd74 <silk_LP_variable_cutoff+0x10>

        /* ARMA low-pass filtering */
        silk_assert( TRANSITION_NB == 3 && TRANSITION_NA == 2 );
        silk_biquad_alt_stride1( frame, B_Q28, A_Q28, psLP->In_LP_State, frame, frame_length);
    }
}
    fd6e:	b00f      	add	sp, #60	; 0x3c
    fd70:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        fac_Q16 = silk_LSHIFT( TRANSITION_FRAMES - psLP->transition_frame_no, 16 - 6 );
    fd74:	f8d0 b008 	ldr.w	fp, [r0, #8]
    fd78:	4617      	mov	r7, r2
    fd7a:	f5cb 7280 	rsb	r2, fp, #256	; 0x100
    fd7e:	0292      	lsls	r2, r2, #10
        ind      = silk_RSHIFT( fac_Q16, 16 );
    fd80:	1416      	asrs	r6, r2, #16
    if( ind < TRANSITION_INT_NUM - 1 ) {
    fd82:	2e03      	cmp	r6, #3
    fd84:	4603      	mov	r3, r0
    fd86:	460d      	mov	r5, r1
    fd88:	f300 8093 	bgt.w	feb2 <silk_LP_variable_cutoff+0x14e>
        fac_Q16 -= silk_LSHIFT( ind, 16 );
    fd8c:	eba2 4206 	sub.w	r2, r2, r6, lsl #16
        if( fac_Q16 > 0 ) {
    fd90:	2a00      	cmp	r2, #0
    fd92:	f340 8114 	ble.w	ffbe <silk_LP_variable_cutoff+0x25a>
    fd96:	1c71      	adds	r1, r6, #1
            if( fac_Q16 < 32768 ) { /* fac_Q16 is in range of a 16-bit int */
    fd98:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    fd9c:	9103      	str	r1, [sp, #12]
    fd9e:	f280 8095 	bge.w	fecc <silk_LP_variable_cutoff+0x168>
                    B_Q28[ nb ] = silk_SMLAWB(
    fda2:	f8df e250 	ldr.w	lr, [pc, #592]	; fff4 <silk_LP_variable_cutoff+0x290>
                    A_Q28[ na ] = silk_SMLAWB(
    fda6:	4890      	ldr	r0, [pc, #576]	; (ffe8 <silk_LP_variable_cutoff+0x284>)
                    B_Q28[ nb ] = silk_SMLAWB(
    fda8:	eb06 0846 	add.w	r8, r6, r6, lsl #1
    fdac:	ea4f 0888 	mov.w	r8, r8, lsl #2
    fdb0:	eb0e 0a08 	add.w	sl, lr, r8
    fdb4:	eb01 0c41 	add.w	ip, r1, r1, lsl #1
                    A_Q28[ na ] = silk_SMLAWB(
    fdb8:	eb00 01c6 	add.w	r1, r0, r6, lsl #3
    fdbc:	9107      	str	r1, [sp, #28]
                    B_Q28[ nb ] = silk_SMLAWB(
    fdbe:	f85e 1008 	ldr.w	r1, [lr, r8]
    fdc2:	9105      	str	r1, [sp, #20]
    fdc4:	f8da 1004 	ldr.w	r1, [sl, #4]
    fdc8:	9104      	str	r1, [sp, #16]
    fdca:	f8da 1008 	ldr.w	r1, [sl, #8]
    fdce:	9106      	str	r1, [sp, #24]
    fdd0:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
                    A_Q28[ na ] = silk_SMLAWB(
    fdd4:	9907      	ldr	r1, [sp, #28]
    fdd6:	f850 a036 	ldr.w	sl, [r0, r6, lsl #3]
                    B_Q28[ nb ] = silk_SMLAWB(
    fdda:	eb0e 090c 	add.w	r9, lr, ip
    fdde:	f85e c00c 	ldr.w	ip, [lr, ip]
    fde2:	e9d9 e801 	ldrd	lr, r8, [r9, #4]
                    A_Q28[ na ] = silk_SMLAWB(
    fde6:	f8d1 9004 	ldr.w	r9, [r1, #4]
    fdea:	9903      	ldr	r1, [sp, #12]
    fdec:	f850 6031 	ldr.w	r6, [r0, r1, lsl #3]
    fdf0:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
                    B_Q28[ nb ] = silk_SMLAWB(
    fdf4:	9805      	ldr	r0, [sp, #20]
                    A_Q28[ na ] = silk_SMLAWB(
    fdf6:	6849      	ldr	r1, [r1, #4]
                    B_Q28[ nb ] = silk_SMLAWB(
    fdf8:	ebac 0c00 	sub.w	ip, ip, r0
    fdfc:	9804      	ldr	r0, [sp, #16]
    fdfe:	ebae 0e00 	sub.w	lr, lr, r0
    fe02:	9806      	ldr	r0, [sp, #24]
    fe04:	eba8 0800 	sub.w	r8, r8, r0
    fe08:	fa1f f08e 	uxth.w	r0, lr
    fe0c:	ea4f 4e2e 	mov.w	lr, lr, asr #16
    fe10:	fb02 f000 	mul.w	r0, r2, r0
    fe14:	fb02 fe0e 	mul.w	lr, r2, lr
    fe18:	eb0e 4e20 	add.w	lr, lr, r0, asr #16
    fe1c:	fa1f f088 	uxth.w	r0, r8
    fe20:	ea4f 4828 	mov.w	r8, r8, asr #16
    fe24:	fb02 f000 	mul.w	r0, r2, r0
    fe28:	fb02 f808 	mul.w	r8, r2, r8
    fe2c:	eb08 4820 	add.w	r8, r8, r0, asr #16
    fe30:	fa1f f08c 	uxth.w	r0, ip
    fe34:	ea4f 4c2c 	mov.w	ip, ip, asr #16
    fe38:	fb02 f000 	mul.w	r0, r2, r0
                    A_Q28[ na ] = silk_SMLAWB(
    fe3c:	eba1 0109 	sub.w	r1, r1, r9
                    B_Q28[ nb ] = silk_SMLAWB(
    fe40:	fb02 fc0c 	mul.w	ip, r2, ip
    fe44:	eb0c 4c20 	add.w	ip, ip, r0, asr #16
                    A_Q28[ na ] = silk_SMLAWB(
    fe48:	b288      	uxth	r0, r1
    fe4a:	1409      	asrs	r1, r1, #16
    fe4c:	fb02 f000 	mul.w	r0, r2, r0
    fe50:	eba6 060a 	sub.w	r6, r6, sl
    fe54:	fb02 f101 	mul.w	r1, r2, r1
    fe58:	eb01 4120 	add.w	r1, r1, r0, asr #16
    fe5c:	b2b0      	uxth	r0, r6
    fe5e:	1436      	asrs	r6, r6, #16
    fe60:	fb02 f000 	mul.w	r0, r2, r0
    fe64:	fb02 f606 	mul.w	r6, r2, r6
    fe68:	eb06 4620 	add.w	r6, r6, r0, asr #16
                    B_Q28[ nb ] = silk_SMLAWB(
    fe6c:	9a04      	ldr	r2, [sp, #16]
    fe6e:	9806      	ldr	r0, [sp, #24]
    fe70:	4472      	add	r2, lr
    fe72:	4686      	mov	lr, r0
    fe74:	9805      	ldr	r0, [sp, #20]
    fe76:	44c6      	add	lr, r8
    fe78:	4484      	add	ip, r0
                    A_Q28[ na ] = silk_SMLAWB(
    fe7a:	4449      	add	r1, r9
    fe7c:	4456      	add	r6, sl
                    B_Q28[ nb ] = silk_SMLAWB(
    fe7e:	e9cd 2e0c 	strd	r2, lr, [sp, #48]	; 0x30
                    A_Q28[ na ] = silk_SMLAWB(
    fe82:	e9cd 1c0a 	strd	r1, ip, [sp, #40]	; 0x28
    fe86:	9609      	str	r6, [sp, #36]	; 0x24
    fe88:	f10d 0c2c 	add.w	ip, sp, #44	; 0x2c
    fe8c:	aa09      	add	r2, sp, #36	; 0x24
        psLP->transition_frame_no = silk_LIMIT( psLP->transition_frame_no + psLP->mode, 0, TRANSITION_FRAMES );
    fe8e:	445c      	add	r4, fp
    fe90:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
    fe94:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
    fe98:	bfa8      	it	ge
    fe9a:	f44f 7480 	movge.w	r4, #256	; 0x100
    fe9e:	609c      	str	r4, [r3, #8]
    fea0:	4628      	mov	r0, r5
        silk_biquad_alt_stride1( frame, B_Q28, A_Q28, psLP->In_LP_State, frame, frame_length);
    fea2:	e9cd 5700 	strd	r5, r7, [sp]
    fea6:	4661      	mov	r1, ip
    fea8:	f007 fb6e 	bl	17588 <silk_biquad_alt_stride1>
}
    feac:	b00f      	add	sp, #60	; 0x3c
    feae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        silk_memcpy( B_Q28, silk_Transition_LP_B_Q28[ TRANSITION_INT_NUM - 1 ], TRANSITION_NB * sizeof( opus_int32 ) );
    feb2:	4a4e      	ldr	r2, [pc, #312]	; (ffec <silk_LP_variable_cutoff+0x288>)
        silk_memcpy( A_Q28, silk_Transition_LP_A_Q28[ TRANSITION_INT_NUM - 1 ], TRANSITION_NA * sizeof( opus_int32 ) );
    feb4:	4e4e      	ldr	r6, [pc, #312]	; (fff0 <silk_LP_variable_cutoff+0x28c>)
        silk_memcpy( B_Q28, silk_Transition_LP_B_Q28[ TRANSITION_INT_NUM - 1 ], TRANSITION_NB * sizeof( opus_int32 ) );
    feb6:	ca07      	ldmia	r2, {r0, r1, r2}
    feb8:	f10d 0c2c 	add.w	ip, sp, #44	; 0x2c
    febc:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
        silk_memcpy( A_Q28, silk_Transition_LP_A_Q28[ TRANSITION_INT_NUM - 1 ], TRANSITION_NA * sizeof( opus_int32 ) );
    fec0:	e896 0003 	ldmia.w	r6, {r0, r1}
    fec4:	aa09      	add	r2, sp, #36	; 0x24
    fec6:	e882 0003 	stmia.w	r2, {r0, r1}
    feca:	e7e0      	b.n	fe8e <silk_LP_variable_cutoff+0x12a>
                    B_Q28[ nb ] = silk_SMLAWB(
    fecc:	f8df e124 	ldr.w	lr, [pc, #292]	; fff4 <silk_LP_variable_cutoff+0x290>
                    A_Q28[ na ] = silk_SMLAWB(
    fed0:	4845      	ldr	r0, [pc, #276]	; (ffe8 <silk_LP_variable_cutoff+0x284>)
                    B_Q28[ nb ] = silk_SMLAWB(
    fed2:	eb01 0841 	add.w	r8, r1, r1, lsl #1
    fed6:	ea4f 0888 	mov.w	r8, r8, lsl #2
    feda:	eb0e 0a08 	add.w	sl, lr, r8
                    A_Q28[ na ] = silk_SMLAWB(
    fede:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
    fee2:	9107      	str	r1, [sp, #28]
                    B_Q28[ nb ] = silk_SMLAWB(
    fee4:	f85e 1008 	ldr.w	r1, [lr, r8]
    fee8:	9105      	str	r1, [sp, #20]
    feea:	f8da 1004 	ldr.w	r1, [sl, #4]
    feee:	9106      	str	r1, [sp, #24]
    fef0:	eb06 0c46 	add.w	ip, r6, r6, lsl #1
    fef4:	f8da 1008 	ldr.w	r1, [sl, #8]
    fef8:	9104      	str	r1, [sp, #16]
    fefa:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
                    A_Q28[ na ] = silk_SMLAWB(
    fefe:	9907      	ldr	r1, [sp, #28]
    ff00:	f850 a036 	ldr.w	sl, [r0, r6, lsl #3]
                    B_Q28[ nb ] = silk_SMLAWB(
    ff04:	eb0e 090c 	add.w	r9, lr, ip
    ff08:	f85e c00c 	ldr.w	ip, [lr, ip]
    ff0c:	e9d9 8e01 	ldrd	r8, lr, [r9, #4]
                    A_Q28[ na ] = silk_SMLAWB(
    ff10:	f8d1 9004 	ldr.w	r9, [r1, #4]
    ff14:	9903      	ldr	r1, [sp, #12]
    ff16:	eb00 06c6 	add.w	r6, r0, r6, lsl #3
    ff1a:	f850 1031 	ldr.w	r1, [r0, r1, lsl #3]
                    B_Q28[ nb ] = silk_SMLAWB(
    ff1e:	9805      	ldr	r0, [sp, #20]
    ff20:	eba0 0c0c 	sub.w	ip, r0, ip
                    A_Q28[ na ] = silk_SMLAWB(
    ff24:	6870      	ldr	r0, [r6, #4]
                    B_Q28[ nb ] = silk_SMLAWB(
    ff26:	9e06      	ldr	r6, [sp, #24]
    ff28:	eba6 0808 	sub.w	r8, r6, r8
    ff2c:	9e04      	ldr	r6, [sp, #16]
    ff2e:	b212      	sxth	r2, r2
    ff30:	eba6 0e0e 	sub.w	lr, r6, lr
    ff34:	fa1f f688 	uxth.w	r6, r8
    ff38:	ea4f 4828 	mov.w	r8, r8, asr #16
    ff3c:	fb02 f606 	mul.w	r6, r2, r6
    ff40:	fb02 f808 	mul.w	r8, r2, r8
    ff44:	eb08 4826 	add.w	r8, r8, r6, asr #16
    ff48:	fa1f f68e 	uxth.w	r6, lr
    ff4c:	ea4f 4e2e 	mov.w	lr, lr, asr #16
    ff50:	fb02 f606 	mul.w	r6, r2, r6
    ff54:	fb02 fe0e 	mul.w	lr, r2, lr
    ff58:	eb0e 4e26 	add.w	lr, lr, r6, asr #16
    ff5c:	fa1f f68c 	uxth.w	r6, ip
    ff60:	ea4f 4c2c 	mov.w	ip, ip, asr #16
    ff64:	fb02 f606 	mul.w	r6, r2, r6
                    A_Q28[ na ] = silk_SMLAWB(
    ff68:	eba9 0000 	sub.w	r0, r9, r0
                    B_Q28[ nb ] = silk_SMLAWB(
    ff6c:	fb02 fc0c 	mul.w	ip, r2, ip
    ff70:	eb0c 4c26 	add.w	ip, ip, r6, asr #16
                    A_Q28[ na ] = silk_SMLAWB(
    ff74:	b286      	uxth	r6, r0
    ff76:	1400      	asrs	r0, r0, #16
    ff78:	eba1 0a0a 	sub.w	sl, r1, sl
    ff7c:	fb02 f606 	mul.w	r6, r2, r6
    ff80:	fb02 f000 	mul.w	r0, r2, r0
    ff84:	eb00 4026 	add.w	r0, r0, r6, asr #16
    ff88:	fa1f f68a 	uxth.w	r6, sl
    ff8c:	ea4f 4a2a 	mov.w	sl, sl, asr #16
    ff90:	fb02 f606 	mul.w	r6, r2, r6
    ff94:	fb02 fa0a 	mul.w	sl, r2, sl
    ff98:	eb0a 4a26 	add.w	sl, sl, r6, asr #16
                    B_Q28[ nb ] = silk_SMLAWB(
    ff9c:	9e04      	ldr	r6, [sp, #16]
    ff9e:	9a06      	ldr	r2, [sp, #24]
    ffa0:	44b6      	add	lr, r6
    ffa2:	9e05      	ldr	r6, [sp, #20]
    ffa4:	4442      	add	r2, r8
    ffa6:	4466      	add	r6, ip
                    A_Q28[ na ] = silk_SMLAWB(
    ffa8:	4448      	add	r0, r9
    ffaa:	4451      	add	r1, sl
                    B_Q28[ nb ] = silk_SMLAWB(
    ffac:	e9cd 2e0c 	strd	r2, lr, [sp, #48]	; 0x30
                    A_Q28[ na ] = silk_SMLAWB(
    ffb0:	e9cd 060a 	strd	r0, r6, [sp, #40]	; 0x28
    ffb4:	9109      	str	r1, [sp, #36]	; 0x24
    ffb6:	f10d 0c2c 	add.w	ip, sp, #44	; 0x2c
    ffba:	aa09      	add	r2, sp, #36	; 0x24
    ffbc:	e767      	b.n	fe8e <silk_LP_variable_cutoff+0x12a>
            silk_memcpy( B_Q28, silk_Transition_LP_B_Q28[ ind ], TRANSITION_NB * sizeof( opus_int32 ) );
    ffbe:	4a0d      	ldr	r2, [pc, #52]	; (fff4 <silk_LP_variable_cutoff+0x290>)
            silk_memcpy( A_Q28, silk_Transition_LP_A_Q28[ ind ], TRANSITION_NA * sizeof( opus_int32 ) );
    ffc0:	f8df e024 	ldr.w	lr, [pc, #36]	; ffe8 <silk_LP_variable_cutoff+0x284>
            silk_memcpy( B_Q28, silk_Transition_LP_B_Q28[ ind ], TRANSITION_NB * sizeof( opus_int32 ) );
    ffc4:	eb06 0146 	add.w	r1, r6, r6, lsl #1
    ffc8:	eb02 0281 	add.w	r2, r2, r1, lsl #2
    ffcc:	ca07      	ldmia	r2, {r0, r1, r2}
    ffce:	f10d 0c2c 	add.w	ip, sp, #44	; 0x2c
            silk_memcpy( A_Q28, silk_Transition_LP_A_Q28[ ind ], TRANSITION_NA * sizeof( opus_int32 ) );
    ffd2:	eb0e 06c6 	add.w	r6, lr, r6, lsl #3
            silk_memcpy( B_Q28, silk_Transition_LP_B_Q28[ ind ], TRANSITION_NB * sizeof( opus_int32 ) );
    ffd6:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
            silk_memcpy( A_Q28, silk_Transition_LP_A_Q28[ ind ], TRANSITION_NA * sizeof( opus_int32 ) );
    ffda:	e896 0003 	ldmia.w	r6, {r0, r1}
    ffde:	aa09      	add	r2, sp, #36	; 0x24
    ffe0:	e882 0003 	stmia.w	r2, {r0, r1}
    ffe4:	e753      	b.n	fe8e <silk_LP_variable_cutoff+0x12a>
    ffe6:	bf00      	nop
    ffe8:	00036c90 	.word	0x00036c90
    ffec:	00036ce8 	.word	0x00036ce8
    fff0:	00036cb0 	.word	0x00036cb0
    fff4:	00036cb8 	.word	0x00036cb8

0000fff8 <silk_NLSF_decode>:
void silk_NLSF_decode(
          opus_int16            *pNLSF_Q15,                     /* O    Quantized NLSF vector [ LPC_ORDER ]         */
          opus_int8             *NLSFIndices,                   /* I    Codebook path vector [ LPC_ORDER + 1 ]      */
    const silk_NLSF_CB_struct   *psNLSF_CB                      /* I    Codebook object                             */
)
{
    fff8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    fffc:	b097      	sub	sp, #92	; 0x5c
    fffe:	4615      	mov	r5, r2
    opus_int32       NLSF_Q15_tmp;
    const opus_uint8 *pCB_element;
    const opus_int16 *pCB_Wght_Q9;

    /* Unpack entropy table indices and predictor for current CB1 index */
    silk_NLSF_unpack( ec_ix, pred_Q8, psNLSF_CB, NLSFIndices[ 0 ] );
   10000:	ae02      	add	r6, sp, #8
{
   10002:	9001      	str	r0, [sp, #4]
    silk_NLSF_unpack( ec_ix, pred_Q8, psNLSF_CB, NLSFIndices[ 0 ] );
   10004:	f991 3000 	ldrsb.w	r3, [r1]
{
   10008:	460f      	mov	r7, r1
    silk_NLSF_unpack( ec_ix, pred_Q8, psNLSF_CB, NLSFIndices[ 0 ] );
   1000a:	a806      	add	r0, sp, #24
   1000c:	4631      	mov	r1, r6
   1000e:	f004 fcdb 	bl	149c8 <silk_NLSF_unpack>

    /* Predictive residual dequantizer */
    silk_NLSF_residual_dequant( res_Q10, &NLSFIndices[ 1 ], pred_Q8, psNLSF_CB->quantStepSize_Q16, psNLSF_CB->order );
   10012:	f9b5 a002 	ldrsh.w	sl, [r5, #2]
   10016:	f9b5 8004 	ldrsh.w	r8, [r5, #4]
    for( i = order-1; i >= 0; i-- ) {
   1001a:	f1ba 0f00 	cmp.w	sl, #0
   1001e:	4652      	mov	r2, sl
   10020:	dd33      	ble.n	1008a <silk_NLSF_decode+0x92>
   10022:	ab0e      	add	r3, sp, #56	; 0x38
   10024:	eb03 0e4a 	add.w	lr, r3, sl, lsl #1
   10028:	eb06 0c0a 	add.w	ip, r6, sl
   1002c:	eb07 090a 	add.w	r9, r7, sl
    out_Q10 = 0;
   10030:	2000      	movs	r0, #0
   10032:	e004      	b.n	1003e <silk_NLSF_decode+0x46>
   10034:	4418      	add	r0, r3
    for( i = order-1; i >= 0; i-- ) {
   10036:	4566      	cmp	r6, ip
        x_Q10[ i ] = out_Q10;
   10038:	f82e 0d02 	strh.w	r0, [lr, #-2]!
    for( i = order-1; i >= 0; i-- ) {
   1003c:	d025      	beq.n	1008a <silk_NLSF_decode+0x92>
        out_Q10  = silk_LSHIFT( indices[ i ], 10 );
   1003e:	f919 1901 	ldrsb.w	r1, [r9], #-1
        pred_Q10 = silk_RSHIFT( silk_SMULBB( out_Q10, (opus_int16)pred_coef_Q8[ i ] ), 8 );
   10042:	f81c bc01 	ldrb.w	fp, [ip, #-1]
   10046:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
        out_Q10  = silk_LSHIFT( indices[ i ], 10 );
   1004a:	0289      	lsls	r1, r1, #10
            out_Q10 = silk_SUB16( out_Q10, SILK_FIX_CONST( NLSF_QUANT_LEVEL_ADJ, 10 ) );
   1004c:	f1a1 0366 	sub.w	r3, r1, #102	; 0x66
   10050:	b29c      	uxth	r4, r3
   10052:	141b      	asrs	r3, r3, #16
        pred_Q10 = silk_RSHIFT( silk_SMULBB( out_Q10, (opus_int16)pred_coef_Q8[ i ] ), 8 );
   10054:	fb1b f000 	smulbb	r0, fp, r0
   10058:	fb08 f404 	mul.w	r4, r8, r4
   1005c:	fb08 f303 	mul.w	r3, r8, r3
        if( out_Q10 > 0 ) {
   10060:	2900      	cmp	r1, #0
        pred_Q10 = silk_RSHIFT( silk_SMULBB( out_Q10, (opus_int16)pred_coef_Q8[ i ] ), 8 );
   10062:	ea4f 2020 	mov.w	r0, r0, asr #8
   10066:	eb03 4324 	add.w	r3, r3, r4, asr #16
        if( out_Q10 > 0 ) {
   1006a:	dce3      	bgt.n	10034 <silk_NLSF_decode+0x3c>
        } else if( out_Q10 < 0 ) {
   1006c:	d0e3      	beq.n	10036 <silk_NLSF_decode+0x3e>
            out_Q10 = silk_ADD16( out_Q10, SILK_FIX_CONST( NLSF_QUANT_LEVEL_ADJ, 10 ) );
   1006e:	3166      	adds	r1, #102	; 0x66
   10070:	b28b      	uxth	r3, r1
   10072:	1409      	asrs	r1, r1, #16
   10074:	fb08 f303 	mul.w	r3, r8, r3
   10078:	fb08 f101 	mul.w	r1, r8, r1
   1007c:	eb01 4123 	add.w	r1, r1, r3, asr #16
   10080:	4408      	add	r0, r1
    for( i = order-1; i >= 0; i-- ) {
   10082:	4566      	cmp	r6, ip
        x_Q10[ i ] = out_Q10;
   10084:	f82e 0d02 	strh.w	r0, [lr, #-2]!
    for( i = order-1; i >= 0; i-- ) {
   10088:	d1d9      	bne.n	1003e <silk_NLSF_decode+0x46>

    /* Apply inverse square-rooted weights to first stage and add to output */
    pCB_element = &psNLSF_CB->CB1_NLSF_Q8[ NLSFIndices[ 0 ] * psNLSF_CB->order ];
   1008a:	f997 1000 	ldrsb.w	r1, [r7]
    pCB_Wght_Q9 = &psNLSF_CB->CB1_Wght_Q9[ NLSFIndices[ 0 ] * psNLSF_CB->order ];
    for( i = 0; i < psNLSF_CB->order; i++ ) {
   1008e:	f1ba 0f00 	cmp.w	sl, #0
    pCB_element = &psNLSF_CB->CB1_NLSF_Q8[ NLSFIndices[ 0 ] * psNLSF_CB->order ];
   10092:	fb11 f30a 	smulbb	r3, r1, sl
    pCB_Wght_Q9 = &psNLSF_CB->CB1_Wght_Q9[ NLSFIndices[ 0 ] * psNLSF_CB->order ];
   10096:	e9d5 0402 	ldrd	r0, r4, [r5, #8]
   1009a:	ea4f 0343 	mov.w	r3, r3, lsl #1
    for( i = 0; i < psNLSF_CB->order; i++ ) {
   1009e:	dd2b      	ble.n	100f8 <silk_NLSF_decode+0x100>
   100a0:	3b02      	subs	r3, #2
   100a2:	441c      	add	r4, r3
   100a4:	9b01      	ldr	r3, [sp, #4]
   100a6:	fb0a 0a01 	mla	sl, sl, r1, r0
   100aa:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
   100ae:	af0e      	add	r7, sp, #56	; 0x38
   100b0:	1e9e      	subs	r6, r3, #2
   100b2:	2000      	movs	r0, #0
   100b4:	e009      	b.n	100ca <silk_NLSF_decode+0xd2>
        NLSF_Q15_tmp = silk_ADD_LSHIFT32( silk_DIV32_16( silk_LSHIFT( (opus_int32)res_Q10[ i ], 14 ), pCB_Wght_Q9[ i ] ), (opus_int16)pCB_element[ i ], 7 );
        pNLSF_Q15[ i ] = (opus_int16)silk_LIMIT( NLSF_Q15_tmp, 0, 32767 );
   100b6:	2b00      	cmp	r3, #0
   100b8:	db25      	blt.n	10106 <silk_NLSF_decode+0x10e>
   100ba:	b21b      	sxth	r3, r3
   100bc:	f826 3f02 	strh.w	r3, [r6, #2]!
    for( i = 0; i < psNLSF_CB->order; i++ ) {
   100c0:	f9b5 2002 	ldrsh.w	r2, [r5, #2]
   100c4:	3001      	adds	r0, #1
   100c6:	4282      	cmp	r2, r0
   100c8:	dd16      	ble.n	100f8 <silk_NLSF_decode+0x100>
        NLSF_Q15_tmp = silk_ADD_LSHIFT32( silk_DIV32_16( silk_LSHIFT( (opus_int32)res_Q10[ i ], 14 ), pCB_Wght_Q9[ i ] ), (opus_int16)pCB_element[ i ], 7 );
   100ca:	f937 3b02 	ldrsh.w	r3, [r7], #2
   100ce:	f81a 2f01 	ldrb.w	r2, [sl, #1]!
   100d2:	f934 1f02 	ldrsh.w	r1, [r4, #2]!
   100d6:	039b      	lsls	r3, r3, #14
   100d8:	fb93 f3f1 	sdiv	r3, r3, r1
   100dc:	eb03 13c2 	add.w	r3, r3, r2, lsl #7
        pNLSF_Q15[ i ] = (opus_int16)silk_LIMIT( NLSF_Q15_tmp, 0, 32767 );
   100e0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   100e4:	dbe7      	blt.n	100b6 <silk_NLSF_decode+0xbe>
   100e6:	f647 73ff 	movw	r3, #32767	; 0x7fff
   100ea:	f826 3f02 	strh.w	r3, [r6, #2]!
    for( i = 0; i < psNLSF_CB->order; i++ ) {
   100ee:	f9b5 2002 	ldrsh.w	r2, [r5, #2]
   100f2:	3001      	adds	r0, #1
   100f4:	4282      	cmp	r2, r0
   100f6:	dce8      	bgt.n	100ca <silk_NLSF_decode+0xd2>
    }

    /* NLSF stabilization */
    silk_NLSF_stabilize( pNLSF_Q15, psNLSF_CB->deltaMin_Q15, psNLSF_CB->order );
   100f8:	6a69      	ldr	r1, [r5, #36]	; 0x24
   100fa:	9801      	ldr	r0, [sp, #4]
   100fc:	f008 fb46 	bl	1878c <silk_NLSF_stabilize>
}
   10100:	b017      	add	sp, #92	; 0x5c
   10102:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        pNLSF_Q15[ i ] = (opus_int16)silk_LIMIT( NLSF_Q15_tmp, 0, 32767 );
   10106:	2300      	movs	r3, #0
   10108:	e7d8      	b.n	100bc <silk_NLSF_decode+0xc4>
   1010a:	bf00      	nop

0001010c <silk_NSQ_c>:
    const opus_int32            Gains_Q16[ MAX_NB_SUBFR ],                  /* I    Quantization step sizes         */
    const opus_int              pitchL[ MAX_NB_SUBFR ],                     /* I    Pitch lags                      */
    const opus_int              Lambda_Q10,                                 /* I    Rate/distortion tradeoff        */
    const opus_int              LTP_scale_Q14                               /* I    LTP state scaling               */
)
{
   1010c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10110:	b0c7      	sub	sp, #284	; 0x11c
   10112:	af02      	add	r7, sp, #8
   10114:	4605      	mov	r5, r0
   10116:	4616      	mov	r6, r2
        LSF_interpolation_flag = 0;
    } else {
        LSF_interpolation_flag = 1;
    }

    ALLOC( sLTP_Q15, psEncC->ltp_mem_length + psEncC->frame_length, opus_int32 );
   10118:	f241 14f0 	movw	r4, #4592	; 0x11f0
   1011c:	f241 10e8 	movw	r0, #4584	; 0x11e8
{
   10120:	468b      	mov	fp, r1
   10122:	61fa      	str	r2, [r7, #28]
    NSQ->rand_seed = psIndices->Seed;
   10124:	f241 02f4 	movw	r2, #4340	; 0x10f4
    ALLOC( sLTP_Q15, psEncC->ltp_mem_length + psEncC->frame_length, opus_int32 );
   10128:	f855 c004 	ldr.w	ip, [r5, r4]
    NSQ->rand_seed = psIndices->Seed;
   1012c:	f996 1022 	ldrsb.w	r1, [r6, #34]	; 0x22
{
   10130:	647b      	str	r3, [r7, #68]	; 0x44
    ALLOC( sLTP_Q15, psEncC->ltp_mem_length + psEncC->frame_length, opus_int32 );
   10132:	462c      	mov	r4, r5
   10134:	582d      	ldr	r5, [r5, r0]
    NSQ->rand_seed = psIndices->Seed;
   10136:	f84b 1002 	str.w	r1, [fp, r2]
   1013a:	4630      	mov	r0, r6
    ALLOC( sLTP, psEncC->ltp_mem_length + psEncC->frame_length, opus_int16 );
    ALLOC( x_sc_Q10, psEncC->subfr_length, opus_int32 );
   1013c:	f241 12ec 	movw	r2, #4588	; 0x11ec
    ALLOC( sLTP_Q15, psEncC->ltp_mem_length + psEncC->frame_length, opus_int32 );
   10140:	4465      	add	r5, ip
    ALLOC( x_sc_Q10, psEncC->subfr_length, opus_int32 );
   10142:	58a6      	ldr	r6, [r4, r2]
    offset_Q10 = silk_Quantization_Offsets_Q10[ psIndices->signalType >> 1 ][ psIndices->quantOffsetType ];
   10144:	f990 201d 	ldrsb.w	r2, [r0, #29]
   10148:	f990 901e 	ldrsb.w	r9, [r0, #30]
    ALLOC( x_sc_Q10, psEncC->subfr_length, opus_int32 );
   1014c:	62fc      	str	r4, [r7, #44]	; 0x2c
    ALLOC( sLTP_Q15, psEncC->ltp_mem_length + psEncC->frame_length, opus_int32 );
   1014e:	ea4f 0e85 	mov.w	lr, r5, lsl #2
   10152:	f10e 0e0a 	add.w	lr, lr, #10
    offset_Q10 = silk_Quantization_Offsets_Q10[ psIndices->signalType >> 1 ][ psIndices->quantOffsetType ];
   10156:	4611      	mov	r1, r2
    ALLOC( sLTP_Q15, psEncC->ltp_mem_length + psEncC->frame_length, opus_int32 );
   10158:	f02e 0e07 	bic.w	lr, lr, #7
   1015c:	ebad 0d0e 	sub.w	sp, sp, lr
    offset_Q10 = silk_Quantization_Offsets_Q10[ psIndices->signalType >> 1 ][ psIndices->quantOffsetType ];
   10160:	f8c7 20cc 	str.w	r2, [r7, #204]	; 0xcc
    ALLOC( sLTP, psEncC->ltp_mem_length + psEncC->frame_length, opus_int16 );
   10164:	006d      	lsls	r5, r5, #1
{
   10166:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
   1016a:	f8c7 210c 	str.w	r2, [r7, #268]	; 0x10c
    offset_Q10 = silk_Quantization_Offsets_Q10[ psIndices->signalType >> 1 ][ psIndices->quantOffsetType ];
   1016e:	f021 0e01 	bic.w	lr, r1, #1
    /* Set up pointers to start of sub frame */
    NSQ->sLTP_shp_buf_idx = psEncC->ltp_mem_length;
    NSQ->sLTP_buf_idx     = psEncC->ltp_mem_length;
    pxq                   = &NSQ->xq[ psEncC->ltp_mem_length ];
    for( k = 0; k < psEncC->nb_subfr; k++ ) {
   10172:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    offset_Q10 = silk_Quantization_Offsets_Q10[ psIndices->signalType >> 1 ][ psIndices->quantOffsetType ];
   10174:	4bbf      	ldr	r3, [pc, #764]	; (10474 <silk_NSQ_c+0x368>)
    if( psIndices->NLSFInterpCoef_Q2 == 4 ) {
   10176:	f990 a01f 	ldrsb.w	sl, [r0, #31]
{
   1017a:	f8d7 0148 	ldr.w	r0, [r7, #328]	; 0x148
    ALLOC( x_sc_Q10, psEncC->subfr_length, opus_int32 );
   1017e:	00b6      	lsls	r6, r6, #2
    ALLOC( sLTP, psEncC->ltp_mem_length + psEncC->frame_length, opus_int16 );
   10180:	3508      	adds	r5, #8
    for( k = 0; k < psEncC->nb_subfr; k++ ) {
   10182:	f241 14e4 	movw	r4, #4580	; 0x11e4
    offset_Q10 = silk_Quantization_Offsets_Q10[ psIndices->signalType >> 1 ][ psIndices->quantOffsetType ];
   10186:	44ce      	add	lr, r9
    ALLOC( sLTP, psEncC->ltp_mem_length + psEncC->frame_length, opus_int16 );
   10188:	f025 0507 	bic.w	r5, r5, #7
    ALLOC( x_sc_Q10, psEncC->subfr_length, opus_int32 );
   1018c:	360a      	adds	r6, #10
    for( k = 0; k < psEncC->nb_subfr; k++ ) {
   1018e:	5914      	ldr	r4, [r2, r4]
    offset_Q10 = silk_Quantization_Offsets_Q10[ psIndices->signalType >> 1 ][ psIndices->quantOffsetType ];
   10190:	f933 301e 	ldrsh.w	r3, [r3, lr, lsl #1]
   10194:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    ALLOC( sLTP_Q15, psEncC->ltp_mem_length + psEncC->frame_length, opus_int32 );
   10198:	aa02      	add	r2, sp, #8
    ALLOC( x_sc_Q10, psEncC->subfr_length, opus_int32 );
   1019a:	f026 0607 	bic.w	r6, r6, #7
    ALLOC( sLTP, psEncC->ltp_mem_length + psEncC->frame_length, opus_int16 );
   1019e:	ebad 0d05 	sub.w	sp, sp, r5
    pxq                   = &NSQ->xq[ psEncC->ltp_mem_length ];
   101a2:	eb0b 034c 	add.w	r3, fp, ip, lsl #1
    ALLOC( sLTP_Q15, psEncC->ltp_mem_length + psEncC->frame_length, opus_int32 );
   101a6:	f8c7 20b8 	str.w	r2, [r7, #184]	; 0xb8
    ALLOC( sLTP, psEncC->ltp_mem_length + psEncC->frame_length, opus_int16 );
   101aa:	aa02      	add	r2, sp, #8
    ALLOC( x_sc_Q10, psEncC->subfr_length, opus_int32 );
   101ac:	ebad 0d06 	sub.w	sp, sp, r6
    lag = NSQ->lagPrev;
   101b0:	f241 06e8 	movw	r6, #4328	; 0x10e8
    if( psIndices->NLSFInterpCoef_Q2 == 4 ) {
   101b4:	f1ba 0a04 	subs.w	sl, sl, #4
    NSQ->sLTP_shp_buf_idx = psEncC->ltp_mem_length;
   101b8:	f241 08f0 	movw	r8, #4336	; 0x10f0
    NSQ->sLTP_buf_idx     = psEncC->ltp_mem_length;
   101bc:	f241 05ec 	movw	r5, #4332	; 0x10ec
    pxq                   = &NSQ->xq[ psEncC->ltp_mem_length ];
   101c0:	64bb      	str	r3, [r7, #72]	; 0x48
    ALLOC( x_sc_Q10, psEncC->subfr_length, opus_int32 );
   101c2:	ab02      	add	r3, sp, #8
    if( psIndices->NLSFInterpCoef_Q2 == 4 ) {
   101c4:	bf18      	it	ne
   101c6:	f04f 0a01 	movne.w	sl, #1
    ALLOC( x_sc_Q10, psEncC->subfr_length, opus_int32 );
   101ca:	653b      	str	r3, [r7, #80]	; 0x50
    for( k = 0; k < psEncC->nb_subfr; k++ ) {
   101cc:	2c00      	cmp	r4, #0
    lag = NSQ->lagPrev;
   101ce:	f85b 3006 	ldr.w	r3, [fp, r6]
    NSQ->sLTP_shp_buf_idx = psEncC->ltp_mem_length;
   101d2:	f84b c008 	str.w	ip, [fp, r8]
    ALLOC( sLTP, psEncC->ltp_mem_length + psEncC->frame_length, opus_int16 );
   101d6:	60fa      	str	r2, [r7, #12]
    NSQ->sLTP_buf_idx     = psEncC->ltp_mem_length;
   101d8:	f84b c005 	str.w	ip, [fp, r5]
    lag = NSQ->lagPrev;
   101dc:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
    for( k = 0; k < psEncC->nb_subfr; k++ ) {
   101e0:	f341 8025 	ble.w	1122e <silk_NSQ_c+0x1122>
            q2_Q10  = silk_ADD32( q1_Q10, 1024 - QUANT_LEVEL_ADJUST_Q10 );
            rd1_Q20 = silk_SMULBB( q1_Q10, Lambda_Q10 );
            rd2_Q20 = silk_SMULBB( q2_Q10, Lambda_Q10 );
        } else if( q1_Q0 == -1 ) {
            q2_Q10  = offset_Q10;
            q1_Q10  = silk_SUB32( q2_Q10, 1024 - QUANT_LEVEL_ADJUST_Q10 );
   101e4:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
   101e8:	f8d7 110c 	ldr.w	r1, [r7, #268]	; 0x10c
            int rdo_offset = Lambda_Q10/2 - 512;
   101ec:	f8d7 615c 	ldr.w	r6, [r7, #348]	; 0x15c
   101f0:	3804      	subs	r0, #4
            q1_Q10  = silk_SUB32( q2_Q10, 1024 - QUANT_LEVEL_ADJUST_Q10 );
   101f2:	f5a3 726c 	sub.w	r2, r3, #944	; 0x3b0
   101f6:	65f8      	str	r0, [r7, #92]	; 0x5c
   101f8:	1f08      	subs	r0, r1, #4
   101fa:	60ba      	str	r2, [r7, #8]
            rd1_Q20 = silk_SMULBB( -q1_Q10, Lambda_Q10 );
   101fc:	4254      	negs	r4, r2
   101fe:	6638      	str	r0, [r7, #96]	; 0x60
   10200:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
   10204:	f8d7 0150 	ldr.w	r0, [r7, #336]	; 0x150
   10208:	b212      	sxth	r2, r2
            q2_Q10  = silk_ADD32( q1_Q10, 1024 - QUANT_LEVEL_ADJUST_Q10 );
   1020a:	f503 756c 	add.w	r5, r3, #944	; 0x3b0
   1020e:	3804      	subs	r0, #4
   10210:	63fd      	str	r5, [r7, #60]	; 0x3c
   10212:	6678      	str	r0, [r7, #100]	; 0x64
            rd1_Q20 = silk_SMULBB( -q1_Q10, Lambda_Q10 );
   10214:	fb14 f002 	smulbb	r0, r4, r2
            rd2_Q20 = silk_SMULBB( q2_Q10, Lambda_Q10 );
   10218:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
            rd1_Q20 = silk_SMULBB( -q1_Q10, Lambda_Q10 );
   1021a:	6078      	str	r0, [r7, #4]
            rd2_Q20 = silk_SMULBB(  q2_Q10, Lambda_Q10 );
   1021c:	f8d7 00e0 	ldr.w	r0, [r7, #224]	; 0xe0
            rd1_Q20 = silk_SMULBB( -q1_Q10, Lambda_Q10 );
   10220:	677a      	str	r2, [r7, #116]	; 0x74
            rd2_Q20 = silk_SMULBB(  q2_Q10, Lambda_Q10 );
   10222:	fb02 f000 	mul.w	r0, r2, r0
            if( ( k & ( 3 - silk_LSHIFT( LSF_interpolation_flag, 1 ) ) ) == 0 ) {
   10226:	ea4f 054a 	mov.w	r5, sl, lsl #1
            rd2_Q20 = silk_SMULBB( q2_Q10, Lambda_Q10 );
   1022a:	fb11 f202 	smulbb	r2, r1, r2
            int rdo_offset = Lambda_Q10/2 - 512;
   1022e:	1073      	asrs	r3, r6, #1
            rd2_Q20 = silk_SMULBB( q2_Q10, Lambda_Q10 );
   10230:	633a      	str	r2, [r7, #48]	; 0x30
    for( k = 0; k < psEncC->nb_subfr; k++ ) {
   10232:	2600      	movs	r6, #0
            if( ( k & ( 3 - silk_LSHIFT( LSF_interpolation_flag, 1 ) ) ) == 0 ) {
   10234:	f1c5 0203 	rsb	r2, r5, #3
    for( k = 0; k < psEncC->nb_subfr; k++ ) {
   10238:	66fe      	str	r6, [r7, #108]	; 0x6c
            if( ( k & ( 3 - silk_LSHIFT( LSF_interpolation_flag, 1 ) ) ) == 0 ) {
   1023a:	603a      	str	r2, [r7, #0]
   1023c:	f50b 5687 	add.w	r6, fp, #4320	; 0x10e0
   10240:	f1ca 0201 	rsb	r2, sl, #1
   10244:	63be      	str	r6, [r7, #56]	; 0x38
   10246:	627a      	str	r2, [r7, #36]	; 0x24
   10248:	6afe      	ldr	r6, [r7, #44]	; 0x2c
            rd2_Q20 = silk_SMULBB(  q2_Q10, Lambda_Q10 );
   1024a:	64f8      	str	r0, [r7, #76]	; 0x4c
            int rdo_offset = Lambda_Q10/2 - 512;
   1024c:	f5a3 7200 	sub.w	r2, r3, #512	; 0x200
   10250:	f50b 5c87 	add.w	ip, fp, #4320	; 0x10e0
   10254:	673a      	str	r2, [r7, #112]	; 0x70
            } else if (q1_Q10 < -rdo_offset) {
   10256:	f5c3 7200 	rsb	r2, r3, #512	; 0x200
   1025a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1025c:	f8c7 c058 	str.w	ip, [r7, #88]	; 0x58
   10260:	f506 5c90 	add.w	ip, r6, #4608	; 0x1200
   10264:	f8c7 c034 	str.w	ip, [r7, #52]	; 0x34
   10268:	643a      	str	r2, [r7, #64]	; 0x40
   1026a:	f506 5c8f 	add.w	ip, r6, #4576	; 0x11e0
   1026e:	f103 021c 	add.w	r2, r3, #28
   10272:	330c      	adds	r3, #12
   10274:	6db9      	ldr	r1, [r7, #88]	; 0x58
   10276:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
   1027a:	4663      	mov	r3, ip
   1027c:	330c      	adds	r3, #12
   1027e:	657b      	str	r3, [r7, #84]	; 0x54
   10280:	460b      	mov	r3, r1
   10282:	3318      	adds	r3, #24
   10284:	65bb      	str	r3, [r7, #88]	; 0x58
   10286:	460b      	mov	r3, r1
   10288:	3310      	adds	r3, #16
   1028a:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
   1028e:	63ba      	str	r2, [r7, #56]	; 0x38
   10290:	6b79      	ldr	r1, [r7, #52]	; 0x34
   10292:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
   10294:	f8c7 b100 	str.w	fp, [r7, #256]	; 0x100
   10298:	460b      	mov	r3, r1
   1029a:	331c      	adds	r3, #28
   1029c:	4661      	mov	r1, ip
   1029e:	637b      	str	r3, [r7, #52]	; 0x34
   102a0:	1d0b      	adds	r3, r1, #4
   102a2:	613b      	str	r3, [r7, #16]
   102a4:	f60b 733c 	addw	r3, fp, #3900	; 0xf3c
   102a8:	61bb      	str	r3, [r7, #24]
   102aa:	f50b 6370 	add.w	r3, fp, #3840	; 0xf00
   102ae:	623b      	str	r3, [r7, #32]
   102b0:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
   102b4:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
   102b8:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
   102bc:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
   102c0:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
   102c4:	66bb      	str	r3, [r7, #104]	; 0x68
   102c6:	f506 5391 	add.w	r3, r6, #4640	; 0x1220
   102ca:	62bb      	str	r3, [r7, #40]	; 0x28
   102cc:	f50b 63a0 	add.w	r3, fp, #1280	; 0x500
   102d0:	617b      	str	r3, [r7, #20]
        HarmShapeFIRPacked_Q14  =                          silk_RSHIFT( HarmShapeGain_Q14[ k ], 2 );
   102d2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   102d4:	f853 1f04 	ldr.w	r1, [r3, #4]!
   102d8:	65fb      	str	r3, [r7, #92]	; 0x5c
        NSQ->rewhite_flag = 0;
   102da:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   102dc:	461a      	mov	r2, r3
   102de:	2300      	movs	r3, #0
   102e0:	6013      	str	r3, [r2, #0]
        HarmShapeFIRPacked_Q14 |= silk_LSHIFT( (opus_int32)silk_RSHIFT( HarmShapeGain_Q14[ k ], 1 ), 16 );
   102e2:	104a      	asrs	r2, r1, #1
        A_Q12      = &PredCoef_Q12[ (( k >> 1 ) | ( 1 - LSF_interpolation_flag )) * MAX_LPC_ORDER ];
   102e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
        HarmShapeFIRPacked_Q14 |= silk_LSHIFT( (opus_int32)silk_RSHIFT( HarmShapeGain_Q14[ k ], 1 ), 16 );
   102e6:	0412      	lsls	r2, r2, #16
   102e8:	ea42 02a1 	orr.w	r2, r2, r1, asr #2
        A_Q12      = &PredCoef_Q12[ (( k >> 1 ) | ( 1 - LSF_interpolation_flag )) * MAX_LPC_ORDER ];
   102ec:	461c      	mov	r4, r3
        HarmShapeFIRPacked_Q14 |= silk_LSHIFT( (opus_int32)silk_RSHIFT( HarmShapeGain_Q14[ k ], 1 ), 16 );
   102ee:	f8c7 20e8 	str.w	r2, [r7, #232]	; 0xe8
        A_Q12      = &PredCoef_Q12[ (( k >> 1 ) | ( 1 - LSF_interpolation_flag )) * MAX_LPC_ORDER ];
   102f2:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
   102f6:	ea44 0360 	orr.w	r3, r4, r0, asr #1
   102fa:	eb02 1343 	add.w	r3, r2, r3, lsl #5
   102fe:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
        if( psIndices->signalType == TYPE_VOICED ) {
   10302:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
   10306:	2b02      	cmp	r3, #2
            lag = pitchL[ k ];
   10308:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
        if( psIndices->signalType == TYPE_VOICED ) {
   1030c:	f000 86bc 	beq.w	11088 <silk_NSQ_c+0xf7c>
   10310:	f853 a020 	ldr.w	sl, [r3, r0, lsl #2]
   10314:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
   10318:	f8d3 b000 	ldr.w	fp, [r3]
   1031c:	f04f 0900 	mov.w	r9, #0
{
    opus_int   i, lag;
    opus_int32 gain_adj_Q16, inv_gain_Q31, inv_gain_Q26;

    lag          = pitchL[ subfr ];
    inv_gain_Q31 = silk_INVERSE32_varQ( silk_max( Gains_Q16[ subfr ], 1 ), 47 );
   10320:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   10322:	f8d3 c000 	ldr.w	ip, [r3]
        silk_nsq_scale_states( psEncC, NSQ, x16, x_sc_Q10, sLTP, sLTP_Q15, k, LTP_scale_Q14, Gains_Q16, pitchL, psIndices->signalType );
   10326:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   10328:	681b      	ldr	r3, [r3, #0]
   1032a:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
    inv_gain_Q31 = silk_INVERSE32_varQ( silk_max( Gains_Q16[ subfr ], 1 ), 47 );
   1032e:	4663      	mov	r3, ip
   10330:	2b01      	cmp	r3, #1
   10332:	bfb8      	it	lt
   10334:	2301      	movlt	r3, #1
#endif

#ifndef OVERRIDE_silk_CLZ32
static OPUS_INLINE opus_int32 silk_CLZ32(opus_int32 in32)
{
    return in32 ? 32 - EC_ILOG(in32) : 32;
   10336:	fab3 f183 	clz	r1, r3

    silk_assert( b32 != 0 );
    silk_assert( Qres > 0 );

    /* Compute number of bits head room and normalize input */
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
   1033a:	3901      	subs	r1, #1
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                */
   1033c:	408b      	lsls	r3, r1

    /* Inverse of b32, with 14 bits of precision */
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm    */
   1033e:	141a      	asrs	r2, r3, #16
   10340:	f06f 4560 	mvn.w	r5, #3758096384	; 0xe0000000

    /* First approximation */
    result = silk_LSHIFT(b32_inv, 16);                                          /* Q: 61 - b_headrm            */

    /* Compute residual by subtracting product of denominator and first approximation from one */
    err_Q32 = silk_LSHIFT( ((opus_int32)1<<29) - silk_SMULWB(b32_nrm, b32_inv), 3 );        /* Q32                        */
   10344:	b29b      	uxth	r3, r3
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm    */
   10346:	fb95 f5f2 	sdiv	r5, r5, r2
    err_Q32 = silk_LSHIFT( ((opus_int32)1<<29) - silk_SMULWB(b32_nrm, b32_inv), 3 );        /* Q32                        */
   1034a:	b22e      	sxth	r6, r5
   1034c:	fb06 f202 	mul.w	r2, r6, r2
   10350:	fb06 f303 	mul.w	r3, r6, r3
   10354:	eb02 4323 	add.w	r3, r2, r3, asr #16
   10358:	f1c3 5300 	rsb	r3, r3, #536870912	; 0x20000000
   1035c:	00db      	lsls	r3, r3, #3

    /* Refinement */
    result = silk_SMLAWW(result, err_Q32, b32_inv);                             /* Q: 61 - b_headrm            */
   1035e:	b29c      	uxth	r4, r3
   10360:	141a      	asrs	r2, r3, #16
   10362:	13e8      	asrs	r0, r5, #15
   10364:	fb06 f404 	mul.w	r4, r6, r4
   10368:	fb06 f202 	mul.w	r2, r6, r2
   1036c:	3001      	adds	r0, #1
   1036e:	eb02 4224 	add.w	r2, r2, r4, asr #16

    /* Convert to Qres domain */
    lshift = 61 - b_headrm - Qres;
   10372:	f1c1 010e 	rsb	r1, r1, #14
    result = silk_SMLAWW(result, err_Q32, b32_inv);                             /* Q: 61 - b_headrm            */
   10376:	1040      	asrs	r0, r0, #1
   10378:	eb02 4205 	add.w	r2, r2, r5, lsl #16
    if( lshift <= 0 ) {
   1037c:	2900      	cmp	r1, #0
    result = silk_SMLAWW(result, err_Q32, b32_inv);                             /* Q: 61 - b_headrm            */
   1037e:	fb03 2000 	mla	r0, r3, r0, r2
    if( lshift <= 0 ) {
   10382:	f340 866c 	ble.w	1105e <silk_NSQ_c+0xf52>
        return silk_LSHIFT_SAT32(result, -lshift);
    } else {
        if( lshift < 32){
            return silk_RSHIFT(result, lshift);
   10386:	fa40 f401 	asr.w	r4, r0, r1
    silk_assert( inv_gain_Q31 != 0 );

    /* Scale input */
    inv_gain_Q26 = silk_RSHIFT_ROUND( inv_gain_Q31, 5 );
    for( i = 0; i < psEncC->subfr_length; i++ ) {
   1038a:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
    inv_gain_Q26 = silk_RSHIFT_ROUND( inv_gain_Q31, 5 );
   1038e:	1125      	asrs	r5, r4, #4
   10390:	3501      	adds	r5, #1
    for( i = 0; i < psEncC->subfr_length; i++ ) {
   10392:	2b00      	cmp	r3, #0
    inv_gain_Q26 = silk_RSHIFT_ROUND( inv_gain_Q31, 5 );
   10394:	ea4f 0665 	mov.w	r6, r5, asr #1
    for( i = 0; i < psEncC->subfr_length; i++ ) {
   10398:	dd1c      	ble.n	103d4 <silk_NSQ_c+0x2c8>
   1039a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
        x_sc_Q10[ i ] = silk_SMULWW( x16[ i ], inv_gain_Q26 );
   1039c:	142d      	asrs	r5, r5, #16
   1039e:	eb02 0843 	add.w	r8, r2, r3, lsl #1
   103a2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   103a4:	3501      	adds	r5, #1
   103a6:	106d      	asrs	r5, r5, #1
   103a8:	b236      	sxth	r6, r6
   103aa:	f1a8 0802 	sub.w	r8, r8, #2
   103ae:	1e90      	subs	r0, r2, #2
   103b0:	f1a3 0e04 	sub.w	lr, r3, #4
   103b4:	f930 3f02 	ldrsh.w	r3, [r0, #2]!
   103b8:	b299      	uxth	r1, r3
   103ba:	141a      	asrs	r2, r3, #16
   103bc:	fb06 f101 	mul.w	r1, r6, r1
   103c0:	fb06 f202 	mul.w	r2, r6, r2
   103c4:	eb02 4221 	add.w	r2, r2, r1, asr #16
   103c8:	fb05 2303 	mla	r3, r5, r3, r2
    for( i = 0; i < psEncC->subfr_length; i++ ) {
   103cc:	4580      	cmp	r8, r0
        x_sc_Q10[ i ] = silk_SMULWW( x16[ i ], inv_gain_Q26 );
   103ce:	f84e 3f04 	str.w	r3, [lr, #4]!
    for( i = 0; i < psEncC->subfr_length; i++ ) {
   103d2:	d1ef      	bne.n	103b4 <silk_NSQ_c+0x2a8>
    }

    /* After rewhitening the LTP state is un-scaled, so scale with inv_gain_Q16 */
    if( NSQ->rewhite_flag ) {
   103d4:	f1b9 0f00 	cmp.w	r9, #0
   103d8:	d030      	beq.n	1043c <silk_NSQ_c+0x330>
        if( subfr == 0 ) {
   103da:	6efb      	ldr	r3, [r7, #108]	; 0x6c
   103dc:	b95b      	cbnz	r3, 103f6 <silk_NSQ_c+0x2ea>
            /* Do LTP downscaling */
            inv_gain_Q31 = silk_LSHIFT( silk_SMULWB( inv_gain_Q31, LTP_scale_Q14 ), 2 );
   103de:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
   103e2:	b2a2      	uxth	r2, r4
   103e4:	b21b      	sxth	r3, r3
   103e6:	1424      	asrs	r4, r4, #16
   103e8:	fb03 f202 	mul.w	r2, r3, r2
   103ec:	fb03 f404 	mul.w	r4, r3, r4
   103f0:	eb04 4422 	add.w	r4, r4, r2, asr #16
   103f4:	00a4      	lsls	r4, r4, #2
        }
        for( i = NSQ->sLTP_buf_idx - lag - LTP_ORDER / 2; i < NSQ->sLTP_buf_idx; i++ ) {
   103f6:	ebab 000a 	sub.w	r0, fp, sl
   103fa:	1e83      	subs	r3, r0, #2
   103fc:	455b      	cmp	r3, fp
   103fe:	da1d      	bge.n	1043c <silk_NSQ_c+0x330>
   10400:	68fb      	ldr	r3, [r7, #12]
   10402:	f100 4100 	add.w	r1, r0, #2147483648	; 0x80000000
   10406:	3903      	subs	r1, #3
   10408:	1e9d      	subs	r5, r3, #2
   1040a:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
   1040e:	eb03 0141 	add.w	r1, r3, r1, lsl #1
   10412:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
   10416:	3803      	subs	r0, #3
            silk_assert( i < MAX_FRAME_LENGTH );
            sLTP_Q15[ i ] = silk_SMULWB( inv_gain_Q31, sLTP[ i ] );
   10418:	1426      	asrs	r6, r4, #16
   1041a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   1041e:	eb05 054b 	add.w	r5, r5, fp, lsl #1
   10422:	b2a4      	uxth	r4, r4
   10424:	f931 3f02 	ldrsh.w	r3, [r1, #2]!
   10428:	fb04 f203 	mul.w	r2, r4, r3
   1042c:	fb03 f306 	mul.w	r3, r3, r6
   10430:	eb03 4322 	add.w	r3, r3, r2, asr #16
        for( i = NSQ->sLTP_buf_idx - lag - LTP_ORDER / 2; i < NSQ->sLTP_buf_idx; i++ ) {
   10434:	428d      	cmp	r5, r1
            sLTP_Q15[ i ] = silk_SMULWB( inv_gain_Q31, sLTP[ i ] );
   10436:	f840 3f04 	str.w	r3, [r0, #4]!
        for( i = NSQ->sLTP_buf_idx - lag - LTP_ORDER / 2; i < NSQ->sLTP_buf_idx; i++ ) {
   1043a:	d1f3      	bne.n	10424 <silk_NSQ_c+0x318>
        }
    }

    /* Adjust for changing gain */
    if( Gains_Q16[ subfr ] != NSQ->prev_gain_Q16 ) {
   1043c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   1043e:	6819      	ldr	r1, [r3, #0]
   10440:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
   10444:	458c      	cmp	ip, r1
   10446:	681b      	ldr	r3, [r3, #0]
   10448:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
   1044c:	f000 8230 	beq.w	108b0 <silk_NSQ_c+0x7a4>
   10450:	2900      	cmp	r1, #0
   10452:	f000 860f 	beq.w	11074 <silk_NSQ_c+0xf68>
    a_headrm = silk_CLZ32( silk_abs(a32) ) - 1;
   10456:	ea81 74e1 	eor.w	r4, r1, r1, asr #31
   1045a:	eba4 74e1 	sub.w	r4, r4, r1, asr #31
   1045e:	fab4 f484 	clz	r4, r4
   10462:	1e63      	subs	r3, r4, #1
    a32_nrm = silk_LSHIFT(a32, a_headrm);                                       /* Q: a_headrm                  */
   10464:	4099      	lsls	r1, r3
   10466:	341c      	adds	r4, #28
   10468:	f1bc 0f00 	cmp.w	ip, #0
   1046c:	f000 8609 	beq.w	11082 <silk_NSQ_c+0xf76>
   10470:	e002      	b.n	10478 <silk_NSQ_c+0x36c>
   10472:	bf00      	nop
   10474:	00036c88 	.word	0x00036c88
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
   10478:	ea8c 75ec 	eor.w	r5, ip, ip, asr #31
   1047c:	eba5 75ec 	sub.w	r5, r5, ip, asr #31
   10480:	fab5 f585 	clz	r5, r5
   10484:	3d01      	subs	r5, #1
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                  */
   10486:	fa0c fc05 	lsl.w	ip, ip, r5
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1048a:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1048e:	140e      	asrs	r6, r1, #16
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   10490:	ea4f 402c 	mov.w	r0, ip, asr #16
   10494:	fb93 f0f0 	sdiv	r0, r3, r0
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   10498:	b28b      	uxth	r3, r1
   1049a:	b200      	sxth	r0, r0
   1049c:	fb00 f303 	mul.w	r3, r0, r3
   104a0:	fb00 f606 	mul.w	r6, r0, r6
   104a4:	eb06 4623 	add.w	r6, r6, r3, asr #16
    a32_nrm = silk_SUB32_ovflw(a32_nrm, silk_LSHIFT_ovflw( silk_SMMUL(b32_nrm, result), 3 ));  /* Q: a_headrm   */
   104a8:	fb8c 2306 	smull	r2, r3, ip, r6
   104ac:	eba1 01c3 	sub.w	r1, r1, r3, lsl #3
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   104b0:	b28b      	uxth	r3, r1
   104b2:	1409      	asrs	r1, r1, #16
   104b4:	fb00 f303 	mul.w	r3, r0, r3
   104b8:	fb00 f101 	mul.w	r1, r0, r1
    lshift = 29 + a_headrm - b_headrm - Qres;
   104bc:	1b64      	subs	r4, r4, r5
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   104be:	eb01 4323 	add.w	r3, r1, r3, asr #16
    if( lshift < 0 ) {
   104c2:	f1b4 0210 	subs.w	r2, r4, #16
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   104c6:	4433      	add	r3, r6
    if( lshift < 0 ) {
   104c8:	f100 85f0 	bmi.w	110ac <silk_NSQ_c+0xfa0>
        if( lshift < 32){
   104cc:	2a1f      	cmp	r2, #31
   104ce:	f300 862c 	bgt.w	1112a <silk_NSQ_c+0x101e>
            return silk_RSHIFT(result, lshift);
   104d2:	4113      	asrs	r3, r2
   104d4:	141a      	asrs	r2, r3, #16
   104d6:	f8c7 2104 	str.w	r2, [r7, #260]	; 0x104
   104da:	b29a      	uxth	r2, r3
   104dc:	f8c7 210c 	str.w	r2, [r7, #268]	; 0x10c
        gain_adj_Q16 =  silk_DIV32_varQ( NSQ->prev_gain_Q16, Gains_Q16[ subfr ], 16 );

        /* Scale long-term shaping state */
        for( i = NSQ->sLTP_shp_buf_idx - psEncC->ltp_mem_length; i < NSQ->sLTP_shp_buf_idx; i++ ) {
   104e0:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   104e2:	f241 10f0 	movw	r0, #4592	; 0x11f0
   104e6:	5808      	ldr	r0, [r1, r0]
   104e8:	f8d7 1108 	ldr.w	r1, [r7, #264]	; 0x108
   104ec:	1a08      	subs	r0, r1, r0
   104ee:	4288      	cmp	r0, r1
   104f0:	da21      	bge.n	10536 <silk_NSQ_c+0x42a>
   104f2:	f8d7 4100 	ldr.w	r4, [r7, #256]	; 0x100
   104f6:	f8d7 210c 	ldr.w	r2, [r7, #268]	; 0x10c
   104fa:	f500 70a0 	add.w	r0, r0, #320	; 0x140
   104fe:	eb04 0680 	add.w	r6, r4, r0, lsl #2
   10502:	6978      	ldr	r0, [r7, #20]
   10504:	eb00 0c81 	add.w	ip, r0, r1, lsl #2
   10508:	f8d7 1104 	ldr.w	r1, [r7, #260]	; 0x104
            NSQ->sLTP_shp_Q14[ i ] = silk_SMULWW( gain_adj_Q16, NSQ->sLTP_shp_Q14[ i ] );
   1050c:	6830      	ldr	r0, [r6, #0]
   1050e:	b204      	sxth	r4, r0
   10510:	13c0      	asrs	r0, r0, #15
   10512:	fb02 f504 	mul.w	r5, r2, r4
   10516:	3001      	adds	r0, #1
   10518:	fb01 f404 	mul.w	r4, r1, r4
   1051c:	1040      	asrs	r0, r0, #1
   1051e:	eb04 4425 	add.w	r4, r4, r5, asr #16
   10522:	fb03 4000 	mla	r0, r3, r0, r4
   10526:	f846 0b04 	str.w	r0, [r6], #4
        for( i = NSQ->sLTP_shp_buf_idx - psEncC->ltp_mem_length; i < NSQ->sLTP_shp_buf_idx; i++ ) {
   1052a:	45b4      	cmp	ip, r6
   1052c:	d1ee      	bne.n	1050c <silk_NSQ_c+0x400>
   1052e:	f8c7 1104 	str.w	r1, [r7, #260]	; 0x104
   10532:	f8c7 210c 	str.w	r2, [r7, #268]	; 0x10c
        }

        /* Scale long-term prediction state */
        if( signal_type == TYPE_VOICED && NSQ->rewhite_flag == 0 ) {
   10536:	f8d7 10cc 	ldr.w	r1, [r7, #204]	; 0xcc
   1053a:	2902      	cmp	r1, #2
   1053c:	f000 85c5 	beq.w	110ca <silk_NSQ_c+0xfbe>
            for( i = NSQ->sLTP_buf_idx - lag - LTP_ORDER / 2; i < NSQ->sLTP_buf_idx; i++ ) {
                sLTP_Q15[ i ] = silk_SMULWW( gain_adj_Q16, sLTP_Q15[ i ] );
            }
        }

        NSQ->sLF_AR_shp_Q14 = silk_SMULWW( gain_adj_Q16, NSQ->sLF_AR_shp_Q14 );
   10540:	f8d7 5100 	ldr.w	r5, [r7, #256]	; 0x100
   10544:	f8d7 210c 	ldr.w	r2, [r7, #268]	; 0x10c
        NSQ->sDiff_shp_Q14 = silk_SMULWW( gain_adj_Q16, NSQ->sDiff_shp_Q14 );

        /* Scale short-term prediction and shaping states */
        for( i = 0; i < NSQ_LPC_BUF_LENGTH; i++ ) {
            NSQ->sLPC_Q14[ i ] = silk_SMULWW( gain_adj_Q16, NSQ->sLPC_Q14[ i ] );
   10548:	f8d5 6f04 	ldr.w	r6, [r5, #3844]	; 0xf04
   1054c:	f8d5 cf00 	ldr.w	ip, [r5, #3840]	; 0xf00
        NSQ->sLF_AR_shp_Q14 = silk_SMULWW( gain_adj_Q16, NSQ->sLF_AR_shp_Q14 );
   10550:	f505 5187 	add.w	r1, r5, #4320	; 0x10e0
        NSQ->sDiff_shp_Q14 = silk_SMULWW( gain_adj_Q16, NSQ->sDiff_shp_Q14 );
   10554:	f241 08e4 	movw	r8, #4324	; 0x10e4
        NSQ->sLF_AR_shp_Q14 = silk_SMULWW( gain_adj_Q16, NSQ->sLF_AR_shp_Q14 );
   10558:	680c      	ldr	r4, [r1, #0]
        NSQ->sDiff_shp_Q14 = silk_SMULWW( gain_adj_Q16, NSQ->sDiff_shp_Q14 );
   1055a:	f855 0008 	ldr.w	r0, [r5, r8]
        NSQ->sLF_AR_shp_Q14 = silk_SMULWW( gain_adj_Q16, NSQ->sLF_AR_shp_Q14 );
   1055e:	f8c7 10f8 	str.w	r1, [r7, #248]	; 0xf8
   10562:	fa0f fe84 	sxth.w	lr, r4
            NSQ->sLPC_Q14[ i ] = silk_SMULWW( gain_adj_Q16, NSQ->sLPC_Q14[ i ] );
   10566:	4629      	mov	r1, r5
        NSQ->sLF_AR_shp_Q14 = silk_SMULWW( gain_adj_Q16, NSQ->sLF_AR_shp_Q14 );
   10568:	fb02 f50e 	mul.w	r5, r2, lr
   1056c:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
            NSQ->sLPC_Q14[ i ] = silk_SMULWW( gain_adj_Q16, NSQ->sLPC_Q14[ i ] );
   10570:	f8d1 9f0c 	ldr.w	r9, [r1, #3852]	; 0xf0c
   10574:	f8d1 af10 	ldr.w	sl, [r1, #3856]	; 0xf10
        NSQ->sLF_AR_shp_Q14 = silk_SMULWW( gain_adj_Q16, NSQ->sLF_AR_shp_Q14 );
   10578:	13e4      	asrs	r4, r4, #15
   1057a:	fb02 fe0e 	mul.w	lr, r2, lr
   1057e:	3401      	adds	r4, #1
            NSQ->sLPC_Q14[ i ] = silk_SMULWW( gain_adj_Q16, NSQ->sLPC_Q14[ i ] );
   10580:	460a      	mov	r2, r1
        NSQ->sLF_AR_shp_Q14 = silk_SMULWW( gain_adj_Q16, NSQ->sLF_AR_shp_Q14 );
   10582:	eb0e 4e25 	add.w	lr, lr, r5, asr #16
   10586:	1064      	asrs	r4, r4, #1
            NSQ->sLPC_Q14[ i ] = silk_SMULWW( gain_adj_Q16, NSQ->sLPC_Q14[ i ] );
   10588:	f8d1 5f08 	ldr.w	r5, [r1, #3848]	; 0xf08
        NSQ->sLF_AR_shp_Q14 = silk_SMULWW( gain_adj_Q16, NSQ->sLF_AR_shp_Q14 );
   1058c:	f8d7 10f8 	ldr.w	r1, [r7, #248]	; 0xf8
   10590:	fb03 e404 	mla	r4, r3, r4, lr
   10594:	600c      	str	r4, [r1, #0]
        NSQ->sDiff_shp_Q14 = silk_SMULWW( gain_adj_Q16, NSQ->sDiff_shp_Q14 );
   10596:	f8d7 110c 	ldr.w	r1, [r7, #268]	; 0x10c
   1059a:	b204      	sxth	r4, r0
   1059c:	fb01 fe04 	mul.w	lr, r1, r4
   105a0:	f8d7 1104 	ldr.w	r1, [r7, #260]	; 0x104
   105a4:	13c0      	asrs	r0, r0, #15
   105a6:	fb01 f404 	mul.w	r4, r1, r4
   105aa:	3001      	adds	r0, #1
            NSQ->sLPC_Q14[ i ] = silk_SMULWW( gain_adj_Q16, NSQ->sLPC_Q14[ i ] );
   105ac:	f8d2 1f14 	ldr.w	r1, [r2, #3860]	; 0xf14
   105b0:	f8c7 1100 	str.w	r1, [r7, #256]	; 0x100
        NSQ->sDiff_shp_Q14 = silk_SMULWW( gain_adj_Q16, NSQ->sDiff_shp_Q14 );
   105b4:	eb04 442e 	add.w	r4, r4, lr, asr #16
   105b8:	1040      	asrs	r0, r0, #1
   105ba:	fb03 4000 	mla	r0, r3, r0, r4
            NSQ->sLPC_Q14[ i ] = silk_SMULWW( gain_adj_Q16, NSQ->sLPC_Q14[ i ] );
   105be:	f8d7 110c 	ldr.w	r1, [r7, #268]	; 0x10c
        NSQ->sDiff_shp_Q14 = silk_SMULWW( gain_adj_Q16, NSQ->sDiff_shp_Q14 );
   105c2:	f842 0008 	str.w	r0, [r2, r8]
            NSQ->sLPC_Q14[ i ] = silk_SMULWW( gain_adj_Q16, NSQ->sLPC_Q14[ i ] );
   105c6:	fa0f f08c 	sxth.w	r0, ip
   105ca:	fb01 f400 	mul.w	r4, r1, r0
   105ce:	f8d7 1104 	ldr.w	r1, [r7, #260]	; 0x104
   105d2:	f8d2 8f18 	ldr.w	r8, [r2, #3864]	; 0xf18
   105d6:	ea4f 3cec 	mov.w	ip, ip, asr #15
   105da:	fb01 f000 	mul.w	r0, r1, r0
   105de:	f10c 0c01 	add.w	ip, ip, #1
   105e2:	f8d2 1f1c 	ldr.w	r1, [r2, #3868]	; 0xf1c
   105e6:	f8c7 10fc 	str.w	r1, [r7, #252]	; 0xfc
   105ea:	ea4f 0c6c 	mov.w	ip, ip, asr #1
   105ee:	f8d7 110c 	ldr.w	r1, [r7, #268]	; 0x10c
   105f2:	eb00 4024 	add.w	r0, r0, r4, asr #16
   105f6:	fb03 000c 	mla	r0, r3, ip, r0
   105fa:	fa0f fe86 	sxth.w	lr, r6
   105fe:	f8d2 4f20 	ldr.w	r4, [r2, #3872]	; 0xf20
   10602:	f8c2 0f00 	str.w	r0, [r2, #3840]	; 0xf00
   10606:	fb01 f00e 	mul.w	r0, r1, lr
   1060a:	f8d7 1104 	ldr.w	r1, [r7, #260]	; 0x104
   1060e:	f8c7 40f8 	str.w	r4, [r7, #248]	; 0xf8
   10612:	13f4      	asrs	r4, r6, #15
   10614:	fb01 fe0e 	mul.w	lr, r1, lr
   10618:	3401      	adds	r4, #1
   1061a:	eb0e 4e20 	add.w	lr, lr, r0, asr #16
   1061e:	1064      	asrs	r4, r4, #1
   10620:	fb03 e404 	mla	r4, r3, r4, lr
   10624:	f8c2 4f04 	str.w	r4, [r2, #3844]	; 0xf04
   10628:	f8d7 410c 	ldr.w	r4, [r7, #268]	; 0x10c
   1062c:	f8d2 cf24 	ldr.w	ip, [r2, #3876]	; 0xf24
   10630:	b22e      	sxth	r6, r5
   10632:	13e8      	asrs	r0, r5, #15
   10634:	fb04 f406 	mul.w	r4, r4, r6
   10638:	3001      	adds	r0, #1
   1063a:	fb01 f606 	mul.w	r6, r1, r6
   1063e:	eb06 4624 	add.w	r6, r6, r4, asr #16
   10642:	1040      	asrs	r0, r0, #1
   10644:	fb03 6000 	mla	r0, r3, r0, r6
   10648:	f8c2 0f08 	str.w	r0, [r2, #3848]	; 0xf08
   1064c:	f8d7 110c 	ldr.w	r1, [r7, #268]	; 0x10c
   10650:	f8d2 ef28 	ldr.w	lr, [r2, #3880]	; 0xf28
   10654:	fa0f f589 	sxth.w	r5, r9
   10658:	fb01 f005 	mul.w	r0, r1, r5
   1065c:	f8d7 1104 	ldr.w	r1, [r7, #260]	; 0x104
   10660:	ea4f 34e9 	mov.w	r4, r9, asr #15
   10664:	fb01 f505 	mul.w	r5, r1, r5
   10668:	3401      	adds	r4, #1
   1066a:	f8d7 110c 	ldr.w	r1, [r7, #268]	; 0x10c
   1066e:	f8d7 9100 	ldr.w	r9, [r7, #256]	; 0x100
   10672:	1064      	asrs	r4, r4, #1
   10674:	eb05 4020 	add.w	r0, r5, r0, asr #16
   10678:	fb03 0004 	mla	r0, r3, r4, r0
   1067c:	fa0f f68a 	sxth.w	r6, sl
   10680:	f8c2 0f0c 	str.w	r0, [r2, #3852]	; 0xf0c
   10684:	fb01 f006 	mul.w	r0, r1, r6
   10688:	f8d7 1104 	ldr.w	r1, [r7, #260]	; 0x104
   1068c:	ea4f 34ea 	mov.w	r4, sl, asr #15
   10690:	fb01 f606 	mul.w	r6, r1, r6
   10694:	3401      	adds	r4, #1
   10696:	eb06 4620 	add.w	r6, r6, r0, asr #16
   1069a:	1064      	asrs	r4, r4, #1
   1069c:	fb03 6404 	mla	r4, r3, r4, r6
   106a0:	f8c2 4f10 	str.w	r4, [r2, #3856]	; 0xf10
   106a4:	4616      	mov	r6, r2
   106a6:	fa0f f589 	sxth.w	r5, r9
   106aa:	f8d7 1104 	ldr.w	r1, [r7, #260]	; 0x104
   106ae:	4648      	mov	r0, r9
   106b0:	f8d2 9f2c 	ldr.w	r9, [r2, #3884]	; 0xf2c
   106b4:	f8d7 210c 	ldr.w	r2, [r7, #268]	; 0x10c
   106b8:	13c0      	asrs	r0, r0, #15
   106ba:	fb02 f405 	mul.w	r4, r2, r5
   106be:	3001      	adds	r0, #1
   106c0:	fb01 f505 	mul.w	r5, r1, r5
   106c4:	eb05 4524 	add.w	r5, r5, r4, asr #16
   106c8:	f8d7 110c 	ldr.w	r1, [r7, #268]	; 0x10c
   106cc:	1040      	asrs	r0, r0, #1
   106ce:	fb03 5000 	mla	r0, r3, r0, r5
   106d2:	fa0f f588 	sxth.w	r5, r8
   106d6:	f8c6 0f14 	str.w	r0, [r6, #3860]	; 0xf14
   106da:	fb01 f005 	mul.w	r0, r1, r5
   106de:	f8d7 1104 	ldr.w	r1, [r7, #260]	; 0x104
   106e2:	ea4f 34e8 	mov.w	r4, r8, asr #15
   106e6:	fb01 f505 	mul.w	r5, r1, r5
   106ea:	eb05 4520 	add.w	r5, r5, r0, asr #16
   106ee:	3401      	adds	r4, #1
   106f0:	f8d7 00fc 	ldr.w	r0, [r7, #252]	; 0xfc
   106f4:	f8d7 110c 	ldr.w	r1, [r7, #268]	; 0x10c
   106f8:	f8d6 8f30 	ldr.w	r8, [r6, #3888]	; 0xf30
   106fc:	4632      	mov	r2, r6
   106fe:	1064      	asrs	r4, r4, #1
   10700:	fb03 5404 	mla	r4, r3, r4, r5
   10704:	b206      	sxth	r6, r0
   10706:	f8c2 4f18 	str.w	r4, [r2, #3864]	; 0xf18
   1070a:	fb01 f406 	mul.w	r4, r1, r6
   1070e:	f8d7 1104 	ldr.w	r1, [r7, #260]	; 0x104
   10712:	13c5      	asrs	r5, r0, #15
   10714:	fb01 f606 	mul.w	r6, r1, r6
   10718:	eb06 4624 	add.w	r6, r6, r4, asr #16
   1071c:	3501      	adds	r5, #1
   1071e:	f8d7 40f8 	ldr.w	r4, [r7, #248]	; 0xf8
   10722:	f8d7 110c 	ldr.w	r1, [r7, #268]	; 0x10c
   10726:	f8d2 0f34 	ldr.w	r0, [r2, #3892]	; 0xf34
   1072a:	106d      	asrs	r5, r5, #1
   1072c:	fb03 6505 	mla	r5, r3, r5, r6
   10730:	b226      	sxth	r6, r4
   10732:	f8c2 5f1c 	str.w	r5, [r2, #3868]	; 0xf1c
   10736:	fb01 f506 	mul.w	r5, r1, r6
   1073a:	f8d7 1104 	ldr.w	r1, [r7, #260]	; 0x104
   1073e:	13e4      	asrs	r4, r4, #15
   10740:	fb01 f606 	mul.w	r6, r1, r6
   10744:	3401      	adds	r4, #1
   10746:	eb06 4625 	add.w	r6, r6, r5, asr #16
   1074a:	f8d7 110c 	ldr.w	r1, [r7, #268]	; 0x10c
   1074e:	1064      	asrs	r4, r4, #1
   10750:	fb03 6404 	mla	r4, r3, r4, r6
   10754:	fa0f f68c 	sxth.w	r6, ip
   10758:	f8c2 4f20 	str.w	r4, [r2, #3872]	; 0xf20
   1075c:	fb01 f406 	mul.w	r4, r1, r6
   10760:	f8d7 1104 	ldr.w	r1, [r7, #260]	; 0x104
   10764:	ea4f 35ec 	mov.w	r5, ip, asr #15
   10768:	fb01 f606 	mul.w	r6, r1, r6
   1076c:	3501      	adds	r5, #1
   1076e:	eb06 4624 	add.w	r6, r6, r4, asr #16
   10772:	f8d7 110c 	ldr.w	r1, [r7, #268]	; 0x10c
   10776:	106d      	asrs	r5, r5, #1
   10778:	fb03 6505 	mla	r5, r3, r5, r6
   1077c:	fa0f fc8e 	sxth.w	ip, lr
   10780:	f8c2 5f24 	str.w	r5, [r2, #3876]	; 0xf24
   10784:	fb01 f50c 	mul.w	r5, r1, ip
   10788:	f8d7 1104 	ldr.w	r1, [r7, #260]	; 0x104
   1078c:	ea4f 34ee 	mov.w	r4, lr, asr #15
   10790:	fb01 fc0c 	mul.w	ip, r1, ip
   10794:	3401      	adds	r4, #1
   10796:	eb0c 4c25 	add.w	ip, ip, r5, asr #16
   1079a:	f8d7 110c 	ldr.w	r1, [r7, #268]	; 0x10c
   1079e:	1064      	asrs	r4, r4, #1
   107a0:	fb03 c404 	mla	r4, r3, r4, ip
   107a4:	fa0f f689 	sxth.w	r6, r9
   107a8:	f8c2 4f28 	str.w	r4, [r2, #3880]	; 0xf28
   107ac:	fb01 f406 	mul.w	r4, r1, r6
   107b0:	f8d7 1104 	ldr.w	r1, [r7, #260]	; 0x104
   107b4:	f8c7 2100 	str.w	r2, [r7, #256]	; 0x100
   107b8:	fb01 f606 	mul.w	r6, r1, r6
   107bc:	eb06 4424 	add.w	r4, r6, r4, asr #16
   107c0:	f8d7 610c 	ldr.w	r6, [r7, #268]	; 0x10c
   107c4:	fa0f f588 	sxth.w	r5, r8
   107c8:	fb06 f605 	mul.w	r6, r6, r5
   107cc:	fb01 f505 	mul.w	r5, r1, r5
   107d0:	eb05 4526 	add.w	r5, r5, r6, asr #16
   107d4:	ea4f 3ee9 	mov.w	lr, r9, asr #15
   107d8:	f8d7 610c 	ldr.w	r6, [r7, #268]	; 0x10c
   107dc:	ea4f 3ce8 	mov.w	ip, r8, asr #15
   107e0:	f10e 0e01 	add.w	lr, lr, #1
   107e4:	fa0f f880 	sxth.w	r8, r0
   107e8:	13c0      	asrs	r0, r0, #15
   107ea:	fb06 f608 	mul.w	r6, r6, r8
   107ee:	ea4f 0e6e 	mov.w	lr, lr, asr #1
   107f2:	fb01 f808 	mul.w	r8, r1, r8
   107f6:	3001      	adds	r0, #1
   107f8:	fb03 440e 	mla	r4, r3, lr, r4
   107fc:	eb08 4826 	add.w	r8, r8, r6, asr #16
   10800:	1040      	asrs	r0, r0, #1
   10802:	fb03 8000 	mla	r0, r3, r0, r8
   10806:	f8c2 4f2c 	str.w	r4, [r2, #3884]	; 0xf2c
   1080a:	f10c 0c01 	add.w	ip, ip, #1
   1080e:	f8d2 4f38 	ldr.w	r4, [r2, #3896]	; 0xf38
   10812:	f8c2 0f34 	str.w	r0, [r2, #3892]	; 0xf34
   10816:	ea4f 0c6c 	mov.w	ip, ip, asr #1
   1081a:	f8d2 0f3c 	ldr.w	r0, [r2, #3900]	; 0xf3c
   1081e:	f8d7 110c 	ldr.w	r1, [r7, #268]	; 0x10c
   10822:	fb03 550c 	mla	r5, r3, ip, r5
   10826:	b226      	sxth	r6, r4
   10828:	fb01 fc06 	mul.w	ip, r1, r6
   1082c:	f8c2 5f30 	str.w	r5, [r2, #3888]	; 0xf30
   10830:	f8d7 1104 	ldr.w	r1, [r7, #260]	; 0x104
   10834:	b205      	sxth	r5, r0
   10836:	13c0      	asrs	r0, r0, #15
   10838:	f100 0e01 	add.w	lr, r0, #1
   1083c:	f8d7 010c 	ldr.w	r0, [r7, #268]	; 0x10c
   10840:	fb01 f606 	mul.w	r6, r1, r6
   10844:	13e4      	asrs	r4, r4, #15
   10846:	eb06 462c 	add.w	r6, r6, ip, asr #16
   1084a:	3401      	adds	r4, #1
   1084c:	fb00 fc05 	mul.w	ip, r0, r5
   10850:	fb01 f505 	mul.w	r5, r1, r5
   10854:	eb05 452c 	add.w	r5, r5, ip, asr #16
   10858:	1064      	asrs	r4, r4, #1
   1085a:	ea4f 006e 	mov.w	r0, lr, asr #1
   1085e:	fb03 6404 	mla	r4, r3, r4, r6
   10862:	fb03 5000 	mla	r0, r3, r0, r5
   10866:	f502 5683 	add.w	r6, r2, #4192	; 0x1060
   1086a:	f502 5c86 	add.w	ip, r2, #4288	; 0x10c0
   1086e:	f8c2 4f38 	str.w	r4, [r2, #3896]	; 0xf38
   10872:	f8c2 0f3c 	str.w	r0, [r2, #3900]	; 0xf3c
   10876:	f8d7 1104 	ldr.w	r1, [r7, #260]	; 0x104
   1087a:	f8d7 210c 	ldr.w	r2, [r7, #268]	; 0x10c
   1087e:	361c      	adds	r6, #28
   10880:	f10c 0c1c 	add.w	ip, ip, #28
        }
        for( i = 0; i < MAX_SHAPE_LPC_ORDER; i++ ) {
            NSQ->sAR2_Q14[ i ] = silk_SMULWW( gain_adj_Q16, NSQ->sAR2_Q14[ i ] );
   10884:	f856 0f04 	ldr.w	r0, [r6, #4]!
   10888:	b204      	sxth	r4, r0
   1088a:	13c0      	asrs	r0, r0, #15
   1088c:	fb02 f504 	mul.w	r5, r2, r4
   10890:	3001      	adds	r0, #1
   10892:	fb01 f404 	mul.w	r4, r1, r4
   10896:	1040      	asrs	r0, r0, #1
   10898:	eb04 4425 	add.w	r4, r4, r5, asr #16
   1089c:	fb03 4000 	mla	r0, r3, r0, r4
        for( i = 0; i < MAX_SHAPE_LPC_ORDER; i++ ) {
   108a0:	45b4      	cmp	ip, r6
            NSQ->sAR2_Q14[ i ] = silk_SMULWW( gain_adj_Q16, NSQ->sAR2_Q14[ i ] );
   108a2:	6030      	str	r0, [r6, #0]
        for( i = 0; i < MAX_SHAPE_LPC_ORDER; i++ ) {
   108a4:	d1ee      	bne.n	10884 <silk_NSQ_c+0x778>
        }

        /* Save inverse gain */
        NSQ->prev_gain_Q16 = Gains_Q16[ subfr ];
   108a6:	6eba      	ldr	r2, [r7, #104]	; 0x68
   108a8:	6db9      	ldr	r1, [r7, #88]	; 0x58
   108aa:	6813      	ldr	r3, [r2, #0]
   108ac:	600b      	str	r3, [r1, #0]
   108ae:	6811      	ldr	r1, [r2, #0]
        silk_noise_shape_quantizer( NSQ, psIndices->signalType, x_sc_Q10, pulses, pxq, sLTP_Q15, A_Q12, B_Q14,
   108b0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
    shp_lag_ptr  = &NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx - lag + HARM_SHAPE_FIR_TAPS / 2 ];
   108b2:	f8d7 5108 	ldr.w	r5, [r7, #264]	; 0x108
        silk_noise_shape_quantizer( NSQ, psIndices->signalType, x_sc_Q10, pulses, pxq, sLTP_Q15, A_Q12, B_Q14,
   108b6:	f853 9f04 	ldr.w	r9, [r3, #4]!
   108ba:	663b      	str	r3, [r7, #96]	; 0x60
   108bc:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   108be:	f853 6f04 	ldr.w	r6, [r3, #4]!
   108c2:	667b      	str	r3, [r7, #100]	; 0x64
   108c4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   108c6:	681c      	ldr	r4, [r3, #0]
   108c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
   108ca:	681b      	ldr	r3, [r3, #0]
   108cc:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
    pred_lag_ptr = &sLTP_Q15[ NSQ->sLTP_buf_idx - lag + LTP_ORDER / 2 ];
   108d0:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
   108d4:	ebab 0203 	sub.w	r2, fp, r3
    shp_lag_ptr  = &NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx - lag + HARM_SHAPE_FIR_TAPS / 2 ];
   108d8:	1aeb      	subs	r3, r5, r3
    pred_lag_ptr = &sLTP_Q15[ NSQ->sLTP_buf_idx - lag + LTP_ORDER / 2 ];
   108da:	f8d7 50b8 	ldr.w	r5, [r7, #184]	; 0xb8
   108de:	3202      	adds	r2, #2
   108e0:	eb05 0282 	add.w	r2, r5, r2, lsl #2
   108e4:	f8c7 2084 	str.w	r2, [r7, #132]	; 0x84
    shp_lag_ptr  = &NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx - lag + HARM_SHAPE_FIR_TAPS / 2 ];
   108e8:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
   108ec:	f203 1341 	addw	r3, r3, #321	; 0x141
   108f0:	eb02 0583 	add.w	r5, r2, r3, lsl #2
   108f4:	f8c7 50fc 	str.w	r5, [r7, #252]	; 0xfc
    for( i = 0; i < length; i++ ) {
   108f8:	f8d7 5080 	ldr.w	r5, [r7, #128]	; 0x80
   108fc:	2d00      	cmp	r5, #0
    Gain_Q10     = silk_RSHIFT( Gain_Q16, 6 );
   108fe:	ea4f 18a1 	mov.w	r8, r1, asr #6
    for( i = 0; i < length; i++ ) {
   10902:	f340 82d5 	ble.w	10eb0 <silk_NSQ_c+0xda4>
        n_AR_Q12 = silk_NSQ_noise_shape_feedback_loop(&NSQ->sDiff_shp_Q14, NSQ->sAR2_Q14, AR_shp_Q13, shapingLPCOrder, arch);
   10906:	4613      	mov	r3, r2
   10908:	f502 5284 	add.w	r2, r2, #4224	; 0x1080
   1090c:	f8c7 20c8 	str.w	r2, [r7, #200]	; 0xc8
   10910:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
        tmp1 = data1[j + 0];
        data1[j + 0] = tmp2;
        out = silk_SMLAWB(out, tmp2, coef[j]);
    }
    data1[order - 1] = tmp1;
    out = silk_SMLAWB(out, tmp1, coef[order - 1]);
   10914:	f8c7 40c0 	str.w	r4, [r7, #192]	; 0xc0
   10918:	1ee0      	subs	r0, r4, #3
   1091a:	0840      	lsrs	r0, r0, #1
   1091c:	eb02 00c0 	add.w	r0, r2, r0, lsl #3
   10920:	fa0f f888 	sxth.w	r8, r8
    data1[order - 1] = tmp1;
   10924:	f104 4580 	add.w	r5, r4, #1073741824	; 0x40000000
   10928:	f8c7 80ec 	str.w	r8, [r7, #236]	; 0xec
   1092c:	f100 0808 	add.w	r8, r0, #8
   10930:	f8d7 00c8 	ldr.w	r0, [r7, #200]	; 0xc8
   10934:	f8c7 8088 	str.w	r8, [r7, #136]	; 0x88
   10938:	3d01      	subs	r5, #1
   1093a:	eb00 0085 	add.w	r0, r0, r5, lsl #2
   1093e:	f8c7 00a0 	str.w	r0, [r7, #160]	; 0xa0
    out = silk_SMLAWB(out, tmp1, coef[order - 1]);
   10942:	f104 4400 	add.w	r4, r4, #2147483648	; 0x80000000
   10946:	f8d7 00bc 	ldr.w	r0, [r7, #188]	; 0xbc
   1094a:	f8d7 5080 	ldr.w	r5, [r7, #128]	; 0x80
   1094e:	461a      	mov	r2, r3
   10950:	3c01      	subs	r4, #1
   10952:	4692      	mov	sl, r2
   10954:	f241 0ef4 	movw	lr, #4340	; 0x10f4
   10958:	eb00 0044 	add.w	r0, r0, r4, lsl #1
   1095c:	f8c7 009c 	str.w	r0, [r7, #156]	; 0x9c
   10960:	eb0a 000e 	add.w	r0, sl, lr
   10964:	f853 300e 	ldr.w	r3, [r3, lr]
    out = silk_RSHIFT(order, 1);
   10968:	f8d7 40c0 	ldr.w	r4, [r7, #192]	; 0xc0
   1096c:	4686      	mov	lr, r0
    out = silk_RSHIFT( order, 1 );
   1096e:	f8d7 00c4 	ldr.w	r0, [r7, #196]	; 0xc4
    out = silk_RSHIFT(order, 1);
   10972:	1064      	asrs	r4, r4, #1
    out = silk_RSHIFT( order, 1 );
   10974:	1040      	asrs	r0, r0, #1
   10976:	f8c7 00a8 	str.w	r0, [r7, #168]	; 0xa8
    out = silk_RSHIFT(order, 1);
   1097a:	f8c7 40a4 	str.w	r4, [r7, #164]	; 0xa4
            n_LTP_Q13 = silk_SMLAWT( n_LTP_Q13, shp_lag_ptr[ -1 ],                      HarmShapeFIRPacked_Q14 );
   1097e:	f8d7 00e8 	ldr.w	r0, [r7, #232]	; 0xe8
        n_LF_Q12 = silk_SMLAWT( n_LF_Q12, NSQ->sLF_AR_shp_Q14, LF_shp_Q14 );
   10982:	1434      	asrs	r4, r6, #16
   10984:	f8c7 40b0 	str.w	r4, [r7, #176]	; 0xb0
   10988:	b234      	sxth	r4, r6
   1098a:	f8c7 4094 	str.w	r4, [r7, #148]	; 0x94
            n_LTP_Q13 = silk_SMLAWT( n_LTP_Q13, shp_lag_ptr[ -1 ],                      HarmShapeFIRPacked_Q14 );
   1098e:	1404      	asrs	r4, r0, #16
   10990:	67fc      	str	r4, [r7, #124]	; 0x7c
            n_LTP_Q13 = silk_SMULWB( silk_ADD32( shp_lag_ptr[ 0 ], shp_lag_ptr[ -2 ] ), HarmShapeFIRPacked_Q14 );
   10992:	b204      	sxth	r4, r0
   10994:	67bc      	str	r4, [r7, #120]	; 0x78
   10996:	6cbc      	ldr	r4, [r7, #72]	; 0x48
   10998:	69be      	ldr	r6, [r7, #24]
   1099a:	3c02      	subs	r4, #2
   1099c:	f8c7 40e4 	str.w	r4, [r7, #228]	; 0xe4
   109a0:	f8d7 4138 	ldr.w	r4, [r7, #312]	; 0x138
   109a4:	f8c7 4104 	str.w	r4, [r7, #260]	; 0x104
        xq[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( silk_SMULWW( xq_Q14, Gain_Q10 ), 8 ) );
   109a8:	1549      	asrs	r1, r1, #21
   109aa:	6d3c      	ldr	r4, [r7, #80]	; 0x50
   109ac:	f241 0ce4 	movw	ip, #4324	; 0x10e4
   109b0:	3101      	adds	r1, #1
   109b2:	1049      	asrs	r1, r1, #1
   109b4:	3c04      	subs	r4, #4
   109b6:	f852 200c 	ldr.w	r2, [r2, ip]
   109ba:	f8c7 10ac 	str.w	r1, [r7, #172]	; 0xac
   109be:	fa0f f989 	sxth.w	r9, r9
   109c2:	44d4      	add	ip, sl
   109c4:	f8c7 40e8 	str.w	r4, [r7, #232]	; 0xe8
   109c8:	f50a 5187 	add.w	r1, sl, #4320	; 0x10e0
   109cc:	eb06 0485 	add.w	r4, r6, r5, lsl #2
   109d0:	f8c7 9098 	str.w	r9, [r7, #152]	; 0x98
   109d4:	f8c7 c08c 	str.w	ip, [r7, #140]	; 0x8c
   109d8:	f8c7 4090 	str.w	r4, [r7, #144]	; 0x90
   109dc:	f8c7 10f8 	str.w	r1, [r7, #248]	; 0xf8
   109e0:	f8d7 a0dc 	ldr.w	sl, [r7, #220]	; 0xdc
   109e4:	46b3      	mov	fp, r6
   109e6:	4691      	mov	r9, r2
   109e8:	46f0      	mov	r8, lr
        NSQ->rand_seed = silk_RAND( NSQ->rand_seed );
   109ea:	4ae5      	ldr	r2, [pc, #916]	; (10d80 <silk_NSQ_c+0xc74>)
   109ec:	49e5      	ldr	r1, [pc, #916]	; (10d84 <silk_NSQ_c+0xc78>)
    out = silk_SMLAWB( out, buf32[  0 ], coef16[ 0 ] );
   109ee:	f9ba 0000 	ldrsh.w	r0, [sl]
   109f2:	fb02 1303 	mla	r3, r2, r3, r1
   109f6:	f8c8 3000 	str.w	r3, [r8]
   109fa:	f85b 6b04 	ldr.w	r6, [fp], #4
    out = silk_SMLAWB( out, buf32[ -1 ], coef16[ 1 ] );
   109fe:	f9ba 2002 	ldrsh.w	r2, [sl, #2]
   10a02:	f85b 3c08 	ldr.w	r3, [fp, #-8]
    out = silk_SMLAWB( out, buf32[ -2 ], coef16[ 2 ] );
   10a06:	f85b 5c0c 	ldr.w	r5, [fp, #-12]
    out = silk_SMLAWB( out, buf32[ -1 ], coef16[ 1 ] );
   10a0a:	fa1f fe83 	uxth.w	lr, r3
   10a0e:	ea4f 4c23 	mov.w	ip, r3, asr #16
   10a12:	fb02 fe0e 	mul.w	lr, r2, lr
   10a16:	fb02 f30c 	mul.w	r3, r2, ip
    out = silk_SMLAWB( out, buf32[  0 ], coef16[ 0 ] );
   10a1a:	b2b2      	uxth	r2, r6
   10a1c:	1436      	asrs	r6, r6, #16
   10a1e:	fb00 f202 	mul.w	r2, r0, r2
   10a22:	fb00 f006 	mul.w	r0, r0, r6
   10a26:	eb00 4022 	add.w	r0, r0, r2, asr #16
   10a2a:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
    out = silk_SMLAWB( out, buf32[ -2 ], coef16[ 2 ] );
   10a2e:	f9ba c004 	ldrsh.w	ip, [sl, #4]
    out = silk_SMLAWB( out, buf32[ -3 ], coef16[ 3 ] );
   10a32:	f85b 6c10 	ldr.w	r6, [fp, #-16]
    out = silk_SMLAWB( out, buf32[ -1 ], coef16[ 1 ] );
   10a36:	eb03 432e 	add.w	r3, r3, lr, asr #16
    out = silk_SMLAWB( out, buf32[  0 ], coef16[ 0 ] );
   10a3a:	4410      	add	r0, r2
    out = silk_SMLAWB( out, buf32[ -1 ], coef16[ 1 ] );
   10a3c:	1819      	adds	r1, r3, r0
    out = silk_SMLAWB( out, buf32[ -2 ], coef16[ 2 ] );
   10a3e:	b2a8      	uxth	r0, r5
   10a40:	142d      	asrs	r5, r5, #16
   10a42:	fb0c f000 	mul.w	r0, ip, r0
   10a46:	fb0c f305 	mul.w	r3, ip, r5
   10a4a:	eb03 4320 	add.w	r3, r3, r0, asr #16
    out = silk_SMLAWB( out, buf32[ -3 ], coef16[ 3 ] );
   10a4e:	f9ba c006 	ldrsh.w	ip, [sl, #6]
    out = silk_SMLAWB( out, buf32[ -4 ], coef16[ 4 ] );
   10a52:	f85b 5c14 	ldr.w	r5, [fp, #-20]
    out = silk_SMLAWB( out, buf32[ -2 ], coef16[ 2 ] );
   10a56:	185a      	adds	r2, r3, r1
    out = silk_SMLAWB( out, buf32[ -3 ], coef16[ 3 ] );
   10a58:	b2b1      	uxth	r1, r6
   10a5a:	1436      	asrs	r6, r6, #16
   10a5c:	fb0c f101 	mul.w	r1, ip, r1
   10a60:	fb0c f006 	mul.w	r0, ip, r6
   10a64:	eb00 4021 	add.w	r0, r0, r1, asr #16
    out = silk_SMLAWB( out, buf32[ -4 ], coef16[ 4 ] );
   10a68:	f9ba c008 	ldrsh.w	ip, [sl, #8]
    out = silk_SMLAWB( out, buf32[ -5 ], coef16[ 5 ] );
   10a6c:	f85b 6c18 	ldr.w	r6, [fp, #-24]
    out = silk_SMLAWB( out, buf32[ -3 ], coef16[ 3 ] );
   10a70:	1883      	adds	r3, r0, r2
    out = silk_SMLAWB( out, buf32[ -4 ], coef16[ 4 ] );
   10a72:	b2aa      	uxth	r2, r5
   10a74:	142d      	asrs	r5, r5, #16
   10a76:	fb0c f202 	mul.w	r2, ip, r2
   10a7a:	fb0c f105 	mul.w	r1, ip, r5
    out = silk_SMLAWB( out, buf32[ -5 ], coef16[ 5 ] );
   10a7e:	f9ba c00a 	ldrsh.w	ip, [sl, #10]
    out = silk_SMLAWB( out, buf32[ -6 ], coef16[ 6 ] );
   10a82:	f85b 5c1c 	ldr.w	r5, [fp, #-28]
    out = silk_SMLAWB( out, buf32[ -5 ], coef16[ 5 ] );
   10a86:	fa1f fe86 	uxth.w	lr, r6
   10a8a:	1436      	asrs	r6, r6, #16
    out = silk_SMLAWB( out, buf32[ -4 ], coef16[ 4 ] );
   10a8c:	eb01 4122 	add.w	r1, r1, r2, asr #16
    out = silk_SMLAWB( out, buf32[ -5 ], coef16[ 5 ] );
   10a90:	fb0c fe0e 	mul.w	lr, ip, lr
   10a94:	fb0c f206 	mul.w	r2, ip, r6
    out = silk_SMLAWB( out, buf32[ -6 ], coef16[ 6 ] );
   10a98:	f9ba c00c 	ldrsh.w	ip, [sl, #12]
    out = silk_SMLAWB( out, buf32[ -4 ], coef16[ 4 ] );
   10a9c:	18c8      	adds	r0, r1, r3
    out = silk_SMLAWB( out, buf32[ -5 ], coef16[ 5 ] );
   10a9e:	eb02 422e 	add.w	r2, r2, lr, asr #16
    out = silk_SMLAWB( out, buf32[ -6 ], coef16[ 6 ] );
   10aa2:	b2ae      	uxth	r6, r5
   10aa4:	142d      	asrs	r5, r5, #16
    out = silk_SMLAWB( out, buf32[ -5 ], coef16[ 5 ] );
   10aa6:	1811      	adds	r1, r2, r0
    out = silk_SMLAWB( out, buf32[ -7 ], coef16[ 7 ] );
   10aa8:	f85b 3c20 	ldr.w	r3, [fp, #-32]
    out = silk_SMLAWB( out, buf32[ -8 ], coef16[ 8 ] );
   10aac:	f85b 0c24 	ldr.w	r0, [fp, #-36]
    out = silk_SMLAWB( out, buf32[ -6 ], coef16[ 6 ] );
   10ab0:	fb0c f606 	mul.w	r6, ip, r6
   10ab4:	fb0c f205 	mul.w	r2, ip, r5
   10ab8:	eb02 4226 	add.w	r2, r2, r6, asr #16
    out = silk_SMLAWB( out, buf32[ -7 ], coef16[ 7 ] );
   10abc:	f9ba 500e 	ldrsh.w	r5, [sl, #14]
    out = silk_SMLAWB( out, buf32[ -9 ], coef16[ 9 ] );
   10ac0:	f85b 6c28 	ldr.w	r6, [fp, #-40]
    out = silk_SMLAWB( out, buf32[ -6 ], coef16[ 6 ] );
   10ac4:	440a      	add	r2, r1
    out = silk_SMLAWB( out, buf32[ -7 ], coef16[ 7 ] );
   10ac6:	b299      	uxth	r1, r3
   10ac8:	141b      	asrs	r3, r3, #16
   10aca:	fb05 f101 	mul.w	r1, r5, r1
   10ace:	fb05 f303 	mul.w	r3, r5, r3
   10ad2:	eb03 4321 	add.w	r3, r3, r1, asr #16
    out = silk_SMLAWB( out, buf32[ -8 ], coef16[ 8 ] );
   10ad6:	f9ba 5010 	ldrsh.w	r5, [sl, #16]
    out = silk_SMLAWB( out, buf32[ -9 ], coef16[ 9 ] );
   10ada:	f9ba 1012 	ldrsh.w	r1, [sl, #18]
    out = silk_SMLAWB( out, buf32[ -7 ], coef16[ 7 ] );
   10ade:	441a      	add	r2, r3
    out = silk_SMLAWB( out, buf32[ -8 ], coef16[ 8 ] );
   10ae0:	b283      	uxth	r3, r0
   10ae2:	1400      	asrs	r0, r0, #16
   10ae4:	fb05 f303 	mul.w	r3, r5, r3
   10ae8:	fb05 f500 	mul.w	r5, r5, r0
   10aec:	eb05 4523 	add.w	r5, r5, r3, asr #16
    out = silk_SMLAWB( out, buf32[ -9 ], coef16[ 9 ] );
   10af0:	b2b3      	uxth	r3, r6
   10af2:	1436      	asrs	r6, r6, #16
   10af4:	fb01 f303 	mul.w	r3, r1, r3
   10af8:	fb01 f606 	mul.w	r6, r1, r6
    out = silk_SMLAWB( out, buf32[ -8 ], coef16[ 8 ] );
   10afc:	442a      	add	r2, r5
    out = silk_SMLAWB( out, buf32[ -9 ], coef16[ 9 ] );
   10afe:	eb06 4623 	add.w	r6, r6, r3, asr #16
   10b02:	18b3      	adds	r3, r6, r2
   10b04:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
    if( order == 16 )
   10b08:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
   10b0c:	2b10      	cmp	r3, #16
   10b0e:	d152      	bne.n	10bb6 <silk_NSQ_c+0xaaa>
        out = silk_SMLAWB( out, buf32[ -10 ], coef16[ 10 ] );
   10b10:	f85b 2c2c 	ldr.w	r2, [fp, #-44]
   10b14:	f9ba 3014 	ldrsh.w	r3, [sl, #20]
        out = silk_SMLAWB( out, buf32[ -11 ], coef16[ 11 ] );
   10b18:	f85b 5c30 	ldr.w	r5, [fp, #-48]
   10b1c:	f9ba 1016 	ldrsh.w	r1, [sl, #22]
        out = silk_SMLAWB( out, buf32[ -10 ], coef16[ 10 ] );
   10b20:	f8d7 410c 	ldr.w	r4, [r7, #268]	; 0x10c
        out = silk_SMLAWB( out, buf32[ -13 ], coef16[ 13 ] );
   10b24:	f9ba e01a 	ldrsh.w	lr, [sl, #26]
        out = silk_SMLAWB( out, buf32[ -10 ], coef16[ 10 ] );
   10b28:	b290      	uxth	r0, r2
   10b2a:	1412      	asrs	r2, r2, #16
   10b2c:	fb03 f600 	mul.w	r6, r3, r0
        out = silk_SMLAWB( out, buf32[ -11 ], coef16[ 11 ] );
   10b30:	fa1f fc85 	uxth.w	ip, r5
        out = silk_SMLAWB( out, buf32[ -10 ], coef16[ 10 ] );
   10b34:	fb03 f002 	mul.w	r0, r3, r2
        out = silk_SMLAWB( out, buf32[ -11 ], coef16[ 11 ] );
   10b38:	142d      	asrs	r5, r5, #16
        out = silk_SMLAWB( out, buf32[ -10 ], coef16[ 10 ] );
   10b3a:	eb00 4026 	add.w	r0, r0, r6, asr #16
        out = silk_SMLAWB( out, buf32[ -12 ], coef16[ 12 ] );
   10b3e:	f85b 2c34 	ldr.w	r2, [fp, #-52]
   10b42:	f9ba 6018 	ldrsh.w	r6, [sl, #24]
        out = silk_SMLAWB( out, buf32[ -13 ], coef16[ 13 ] );
   10b46:	f85b 3c38 	ldr.w	r3, [fp, #-56]
        out = silk_SMLAWB( out, buf32[ -11 ], coef16[ 11 ] );
   10b4a:	fb01 fc0c 	mul.w	ip, r1, ip
   10b4e:	fb01 f505 	mul.w	r5, r1, r5
   10b52:	eb05 452c 	add.w	r5, r5, ip, asr #16
        out = silk_SMLAWB( out, buf32[ -10 ], coef16[ 10 ] );
   10b56:	4420      	add	r0, r4
        out = silk_SMLAWB( out, buf32[ -11 ], coef16[ 11 ] );
   10b58:	4428      	add	r0, r5
        out = silk_SMLAWB( out, buf32[ -12 ], coef16[ 12 ] );
   10b5a:	b295      	uxth	r5, r2
   10b5c:	1412      	asrs	r2, r2, #16
   10b5e:	fb06 f505 	mul.w	r5, r6, r5
   10b62:	fb06 f602 	mul.w	r6, r6, r2
   10b66:	eb06 4625 	add.w	r6, r6, r5, asr #16
        out = silk_SMLAWB( out, buf32[ -13 ], coef16[ 13 ] );
   10b6a:	b29d      	uxth	r5, r3
   10b6c:	141b      	asrs	r3, r3, #16
        out = silk_SMLAWB( out, buf32[ -14 ], coef16[ 14 ] );
   10b6e:	f85b 1c3c 	ldr.w	r1, [fp, #-60]
   10b72:	f9ba 201c 	ldrsh.w	r2, [sl, #28]
        out = silk_SMLAWB( out, buf32[ -13 ], coef16[ 13 ] );
   10b76:	fb0e f505 	mul.w	r5, lr, r5
   10b7a:	fb0e f303 	mul.w	r3, lr, r3
   10b7e:	eb03 4325 	add.w	r3, r3, r5, asr #16
        out = silk_SMLAWB( out, buf32[ -12 ], coef16[ 12 ] );
   10b82:	4430      	add	r0, r6
        out = silk_SMLAWB( out, buf32[ -13 ], coef16[ 13 ] );
   10b84:	4418      	add	r0, r3
        out = silk_SMLAWB( out, buf32[ -15 ], coef16[ 15 ] );
   10b86:	f85b 6c40 	ldr.w	r6, [fp, #-64]
   10b8a:	f9ba 501e 	ldrsh.w	r5, [sl, #30]
        out = silk_SMLAWB( out, buf32[ -14 ], coef16[ 14 ] );
   10b8e:	b28b      	uxth	r3, r1
   10b90:	1409      	asrs	r1, r1, #16
   10b92:	fb02 f303 	mul.w	r3, r2, r3
   10b96:	fb02 f201 	mul.w	r2, r2, r1
   10b9a:	eb02 4223 	add.w	r2, r2, r3, asr #16
        out = silk_SMLAWB( out, buf32[ -15 ], coef16[ 15 ] );
   10b9e:	b2b3      	uxth	r3, r6
   10ba0:	1436      	asrs	r6, r6, #16
   10ba2:	fb05 f303 	mul.w	r3, r5, r3
   10ba6:	fb05 f606 	mul.w	r6, r5, r6
        out = silk_SMLAWB( out, buf32[ -14 ], coef16[ 14 ] );
   10baa:	4410      	add	r0, r2
        out = silk_SMLAWB( out, buf32[ -15 ], coef16[ 15 ] );
   10bac:	eb06 4323 	add.w	r3, r6, r3, asr #16
   10bb0:	4403      	add	r3, r0
   10bb2:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
        if( signalType == TYPE_VOICED ) {
   10bb6:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
   10bba:	2b02      	cmp	r3, #2
   10bbc:	f000 81d0 	beq.w	10f60 <silk_NSQ_c+0xe54>
   10bc0:	2300      	movs	r3, #0
   10bc2:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
            LTP_pred_Q13 = 0;
   10bc6:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
    out = silk_SMLAWB(out, tmp2, coef[0]);
   10bca:	f8d7 00bc 	ldr.w	r0, [r7, #188]	; 0xbc
    tmp1 = data1[0];
   10bce:	f8d7 10c8 	ldr.w	r1, [r7, #200]	; 0xc8
    out = silk_SMLAWB(out, tmp2, coef[0]);
   10bd2:	f9b0 3000 	ldrsh.w	r3, [r0]
    tmp1 = data1[0];
   10bd6:	680e      	ldr	r6, [r1, #0]
    data1[0] = tmp2;
   10bd8:	f8c1 9000 	str.w	r9, [r1]
    out = silk_SMLAWB(out, tmp2, coef[0]);
   10bdc:	fa1f f289 	uxth.w	r2, r9
   10be0:	ea4f 4429 	mov.w	r4, r9, asr #16
   10be4:	fb03 f202 	mul.w	r2, r3, r2
   10be8:	fb03 f404 	mul.w	r4, r3, r4
   10bec:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
   10bf0:	eb04 4222 	add.w	r2, r4, r2, asr #16
   10bf4:	441a      	add	r2, r3
    for (j = 2; j < order; j += 2) {
   10bf6:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
   10bfa:	2b02      	cmp	r3, #2
   10bfc:	dd27      	ble.n	10c4e <silk_NSQ_c+0xb42>
   10bfe:	f8c7 80d4 	str.w	r8, [r7, #212]	; 0xd4
   10c02:	f8d7 8088 	ldr.w	r8, [r7, #136]	; 0x88
   10c06:	4681      	mov	r9, r0
   10c08:	468c      	mov	ip, r1
        out = silk_SMLAWB(out, tmp1, coef[j - 1]);
   10c0a:	f9b9 3002 	ldrsh.w	r3, [r9, #2]
        tmp2 = data1[j - 1];
   10c0e:	f8dc 4004 	ldr.w	r4, [ip, #4]
        out = silk_SMLAWB(out, tmp2, coef[j]);
   10c12:	f939 ef04 	ldrsh.w	lr, [r9, #4]!
        data1[j - 1] = tmp1;
   10c16:	f8cc 6004 	str.w	r6, [ip, #4]
        out = silk_SMLAWB(out, tmp1, coef[j - 1]);
   10c1a:	b2b5      	uxth	r5, r6
   10c1c:	1436      	asrs	r6, r6, #16
   10c1e:	fb03 f505 	mul.w	r5, r3, r5
        out = silk_SMLAWB(out, tmp2, coef[j]);
   10c22:	b2a0      	uxth	r0, r4
        out = silk_SMLAWB(out, tmp1, coef[j - 1]);
   10c24:	fb03 f306 	mul.w	r3, r3, r6
        out = silk_SMLAWB(out, tmp2, coef[j]);
   10c28:	1421      	asrs	r1, r4, #16
        tmp1 = data1[j + 0];
   10c2a:	f8dc 6008 	ldr.w	r6, [ip, #8]
        data1[j + 0] = tmp2;
   10c2e:	f84c 4f08 	str.w	r4, [ip, #8]!
        out = silk_SMLAWB(out, tmp2, coef[j]);
   10c32:	fb0e f000 	mul.w	r0, lr, r0
   10c36:	fb0e f101 	mul.w	r1, lr, r1
        out = silk_SMLAWB(out, tmp1, coef[j - 1]);
   10c3a:	eb03 4325 	add.w	r3, r3, r5, asr #16
        out = silk_SMLAWB(out, tmp2, coef[j]);
   10c3e:	eb01 4020 	add.w	r0, r1, r0, asr #16
        out = silk_SMLAWB(out, tmp1, coef[j - 1]);
   10c42:	441a      	add	r2, r3
    for (j = 2; j < order; j += 2) {
   10c44:	45c4      	cmp	ip, r8
        out = silk_SMLAWB(out, tmp2, coef[j]);
   10c46:	4402      	add	r2, r0
    for (j = 2; j < order; j += 2) {
   10c48:	d1df      	bne.n	10c0a <silk_NSQ_c+0xafe>
   10c4a:	f8d7 80d4 	ldr.w	r8, [r7, #212]	; 0xd4
        n_LF_Q12 = silk_SMULWB( NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx - 1 ], LF_shp_Q14 );
   10c4e:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
    data1[order - 1] = tmp1;
   10c52:	f8d7 10a0 	ldr.w	r1, [r7, #160]	; 0xa0
   10c56:	f203 133f 	addw	r3, r3, #319	; 0x13f
   10c5a:	600e      	str	r6, [r1, #0]
   10c5c:	f8d7 1100 	ldr.w	r1, [r7, #256]	; 0x100
   10c60:	f851 0023 	ldr.w	r0, [r1, r3, lsl #2]
        n_AR_Q12 = silk_SMLAWB( n_AR_Q12, NSQ->sLF_AR_shp_Q14, Tilt_Q14 );
   10c64:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
   10c68:	f8d7 1098 	ldr.w	r1, [r7, #152]	; 0x98
   10c6c:	681c      	ldr	r4, [r3, #0]
    out = silk_SMLAWB(out, tmp1, coef[order - 1]);
   10c6e:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
   10c72:	f9b3 9000 	ldrsh.w	r9, [r3]
        n_LF_Q12 = silk_SMULWB( NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx - 1 ], LF_shp_Q14 );
   10c76:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
   10c7a:	b2b5      	uxth	r5, r6
   10c7c:	1436      	asrs	r6, r6, #16
        n_AR_Q12 = silk_SMLAWB( n_AR_Q12, NSQ->sLF_AR_shp_Q14, Tilt_Q14 );
   10c7e:	ea4f 4e24 	mov.w	lr, r4, asr #16
        n_LF_Q12 = silk_SMULWB( NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx - 1 ], LF_shp_Q14 );
   10c82:	fa1f fc80 	uxth.w	ip, r0
        n_AR_Q12 = silk_SMLAWB( n_AR_Q12, NSQ->sLF_AR_shp_Q14, Tilt_Q14 );
   10c86:	b2a4      	uxth	r4, r4
   10c88:	fb09 f505 	mul.w	r5, r9, r5
        n_LF_Q12 = silk_SMULWB( NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx - 1 ], LF_shp_Q14 );
   10c8c:	1400      	asrs	r0, r0, #16
   10c8e:	fb09 f606 	mul.w	r6, r9, r6
   10c92:	fb03 fc0c 	mul.w	ip, r3, ip
   10c96:	fb03 f000 	mul.w	r0, r3, r0
   10c9a:	eb06 4625 	add.w	r6, r6, r5, asr #16
        n_AR_Q12 = silk_SMLAWB( n_AR_Q12, NSQ->sLF_AR_shp_Q14, Tilt_Q14 );
   10c9e:	fb01 f30e 	mul.w	r3, r1, lr
   10ca2:	fb01 f504 	mul.w	r5, r1, r4
   10ca6:	eb03 4325 	add.w	r3, r3, r5, asr #16
   10caa:	18b5      	adds	r5, r6, r2
   10cac:	eb03 0545 	add.w	r5, r3, r5, lsl #1
        n_LF_Q12 = silk_SMLAWT( n_LF_Q12, NSQ->sLF_AR_shp_Q14, LF_shp_Q14 );
   10cb0:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
        tmp1 = silk_SUB32( silk_LSHIFT32( LPC_pred_Q10, 2 ), n_AR_Q12 );        /* Q12 */
   10cb4:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
        n_LF_Q12 = silk_SMULWB( NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx - 1 ], LF_shp_Q14 );
   10cb8:	eb00 4c2c 	add.w	ip, r0, ip, asr #16
        n_LF_Q12 = silk_SMLAWT( n_LF_Q12, NSQ->sLF_AR_shp_Q14, LF_shp_Q14 );
   10cbc:	fb02 cc0e 	mla	ip, r2, lr, ip
   10cc0:	fb02 f104 	mul.w	r1, r2, r4
        tmp1 = silk_SUB32( silk_LSHIFT32( LPC_pred_Q10, 2 ), n_AR_Q12 );        /* Q12 */
   10cc4:	ebc5 0283 	rsb	r2, r5, r3, lsl #2
        if( lag > 0 ) {
   10cc8:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
        n_LF_Q12 = silk_SMLAWT( n_LF_Q12, NSQ->sLF_AR_shp_Q14, LF_shp_Q14 );
   10ccc:	eb0c 4121 	add.w	r1, ip, r1, asr #16
        if( lag > 0 ) {
   10cd0:	2b00      	cmp	r3, #0
        n_LF_Q12 = silk_SMLAWT( n_LF_Q12, NSQ->sLF_AR_shp_Q14, LF_shp_Q14 );
   10cd2:	f8c7 1108 	str.w	r1, [r7, #264]	; 0x108
        tmp1 = silk_SUB32( tmp1, n_LF_Q12 );                                    /* Q12 */
   10cd6:	eba2 0201 	sub.w	r2, r2, r1
        if( lag > 0 ) {
   10cda:	f340 813d 	ble.w	10f58 <silk_NSQ_c+0xe4c>
            n_LTP_Q13 = silk_SMULWB( silk_ADD32( shp_lag_ptr[ 0 ], shp_lag_ptr[ -2 ] ), HarmShapeFIRPacked_Q14 );
   10cde:	f8d7 40fc 	ldr.w	r4, [r7, #252]	; 0xfc
   10ce2:	6fb9      	ldr	r1, [r7, #120]	; 0x78
   10ce4:	f854 0c08 	ldr.w	r0, [r4, #-8]
   10ce8:	6823      	ldr	r3, [r4, #0]
            n_LTP_Q13 = silk_SMLAWT( n_LTP_Q13, shp_lag_ptr[ -1 ],                      HarmShapeFIRPacked_Q14 );
   10cea:	f854 4c04 	ldr.w	r4, [r4, #-4]
            n_LTP_Q13 = silk_SMULWB( silk_ADD32( shp_lag_ptr[ 0 ], shp_lag_ptr[ -2 ] ), HarmShapeFIRPacked_Q14 );
   10cee:	4403      	add	r3, r0
   10cf0:	b29e      	uxth	r6, r3
   10cf2:	141b      	asrs	r3, r3, #16
   10cf4:	fb01 f606 	mul.w	r6, r1, r6
   10cf8:	fb01 f303 	mul.w	r3, r1, r3
            n_LTP_Q13 = silk_SMLAWT( n_LTP_Q13, shp_lag_ptr[ -1 ],                      HarmShapeFIRPacked_Q14 );
   10cfc:	6ff9      	ldr	r1, [r7, #124]	; 0x7c
   10cfe:	1420      	asrs	r0, r4, #16
            n_LTP_Q13 = silk_SMULWB( silk_ADD32( shp_lag_ptr[ 0 ], shp_lag_ptr[ -2 ] ), HarmShapeFIRPacked_Q14 );
   10d00:	eb03 4326 	add.w	r3, r3, r6, asr #16
            n_LTP_Q13 = silk_SMLAWT( n_LTP_Q13, shp_lag_ptr[ -1 ],                      HarmShapeFIRPacked_Q14 );
   10d04:	b2a4      	uxth	r4, r4
   10d06:	fb01 3300 	mla	r3, r1, r0, r3
   10d0a:	fb01 f404 	mul.w	r4, r1, r4
   10d0e:	eb03 4424 	add.w	r4, r3, r4, asr #16
            tmp2 = silk_SUB32( LTP_pred_Q13, n_LTP_Q13 );                       /* Q13 */
   10d12:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
   10d16:	eba3 0444 	sub.w	r4, r3, r4, lsl #1
            tmp1 = silk_ADD_LSHIFT32( tmp2, tmp1, 1 );                          /* Q13 */
   10d1a:	eb04 0442 	add.w	r4, r4, r2, lsl #1
            tmp1 = silk_RSHIFT_ROUND( tmp1, 3 );                                /* Q10 */
   10d1e:	10a3      	asrs	r3, r4, #2
            shp_lag_ptr++;
   10d20:	f8d7 40fc 	ldr.w	r4, [r7, #252]	; 0xfc
            tmp1 = silk_RSHIFT_ROUND( tmp1, 3 );                                /* Q10 */
   10d24:	3301      	adds	r3, #1
            shp_lag_ptr++;
   10d26:	1d22      	adds	r2, r4, #4
   10d28:	f8c7 20fc 	str.w	r2, [r7, #252]	; 0xfc
            tmp1 = silk_RSHIFT_ROUND( tmp1, 3 );                                /* Q10 */
   10d2c:	105b      	asrs	r3, r3, #1
        r_Q10 = silk_SUB32( x_sc_Q10[ i ], tmp1 );                              /* residual error Q10 */
   10d2e:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
        if (Lambda_Q10 > 2048) {
   10d32:	f8d7 115c 	ldr.w	r1, [r7, #348]	; 0x15c
        r_Q10 = silk_SUB32( x_sc_Q10[ i ], tmp1 );                              /* residual error Q10 */
   10d36:	f852 4f04 	ldr.w	r4, [r2, #4]!
   10d3a:	f8c7 20e8 	str.w	r2, [r7, #232]	; 0xe8
        if( NSQ->rand_seed < 0 ) {
   10d3e:	f8d8 2000 	ldr.w	r2, [r8]
        r_Q10 = silk_SUB32( x_sc_Q10[ i ], tmp1 );                              /* residual error Q10 */
   10d42:	1ae3      	subs	r3, r4, r3
        if( NSQ->rand_seed < 0 ) {
   10d44:	2a00      	cmp	r2, #0
        r_Q10 = silk_LIMIT_32( r_Q10, -(31 << 10), 30 << 10 );
   10d46:	4a10      	ldr	r2, [pc, #64]	; (10d88 <silk_NSQ_c+0xc7c>)
            r_Q10 = -r_Q10;
   10d48:	bfb8      	it	lt
   10d4a:	425b      	neglt	r3, r3
        r_Q10 = silk_LIMIT_32( r_Q10, -(31 << 10), 30 << 10 );
   10d4c:	4293      	cmp	r3, r2
   10d4e:	bfb8      	it	lt
   10d50:	4613      	movlt	r3, r2
   10d52:	f5b3 4ff0 	cmp.w	r3, #30720	; 0x7800
        q1_Q10 = silk_SUB32( r_Q10, offset_Q10 );
   10d56:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
   10d5a:	bfa8      	it	ge
   10d5c:	f44f 43f0 	movge.w	r3, #30720	; 0x7800
        if (Lambda_Q10 > 2048) {
   10d60:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
        q1_Q10 = silk_SUB32( r_Q10, offset_Q10 );
   10d64:	eba3 0202 	sub.w	r2, r3, r2
        if (Lambda_Q10 > 2048) {
   10d68:	f340 80e8 	ble.w	10f3c <silk_NSQ_c+0xe30>
            if (q1_Q10 > rdo_offset) {
   10d6c:	6f39      	ldr	r1, [r7, #112]	; 0x70
   10d6e:	428a      	cmp	r2, r1
   10d70:	f340 8149 	ble.w	11006 <silk_NSQ_c+0xefa>
                q1_Q0 = silk_RSHIFT( q1_Q10 - rdo_offset, 10 );
   10d74:	1a56      	subs	r6, r2, r1
   10d76:	12b6      	asrs	r6, r6, #10
        if( q1_Q0 > 0 ) {
   10d78:	2e00      	cmp	r6, #0
   10d7a:	f340 80e3 	ble.w	10f44 <silk_NSQ_c+0xe38>
   10d7e:	e005      	b.n	10d8c <silk_NSQ_c+0xc80>
   10d80:	0bb38435 	.word	0x0bb38435
   10d84:	3619636b 	.word	0x3619636b
   10d88:	ffff8400 	.word	0xffff8400
            q1_Q10  = silk_SUB32( silk_LSHIFT( q1_Q0, 10 ), QUANT_LEVEL_ADJUST_Q10 );
   10d8c:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
            rd2_Q20 = silk_SMULBB( q2_Q10, Lambda_Q10 );
   10d90:	6f79      	ldr	r1, [r7, #116]	; 0x74
            q1_Q10  = silk_SUB32( silk_LSHIFT( q1_Q0, 10 ), QUANT_LEVEL_ADJUST_Q10 );
   10d92:	eb02 2686 	add.w	r6, r2, r6, lsl #10
            q1_Q10  = silk_ADD32( q1_Q10, offset_Q10 );
   10d96:	3e50      	subs	r6, #80	; 0x50
            q2_Q10  = silk_ADD32( q1_Q10, 1024 );
   10d98:	f506 6080 	add.w	r0, r6, #1024	; 0x400
   10d9c:	eba3 0c00 	sub.w	ip, r3, r0
   10da0:	1b9a      	subs	r2, r3, r6
            rd2_Q20 = silk_SMULBB( q2_Q10, Lambda_Q10 );
   10da2:	fb10 fe01 	smulbb	lr, r0, r1
            rd1_Q20 = silk_SMULBB( q1_Q10, Lambda_Q10 );
   10da6:	fb16 f301 	smulbb	r3, r6, r1
        rd1_Q20 = silk_SMLABB( rd1_Q20, rr_Q10, rr_Q10 );
   10daa:	b212      	sxth	r2, r2
        rd2_Q20 = silk_SMLABB( rd2_Q20, rr_Q10, rr_Q10 );
   10dac:	fa0f fc8c 	sxth.w	ip, ip
        rd1_Q20 = silk_SMLABB( rd1_Q20, rr_Q10, rr_Q10 );
   10db0:	fb02 3202 	mla	r2, r2, r2, r3
        rd2_Q20 = silk_SMLABB( rd2_Q20, rr_Q10, rr_Q10 );
   10db4:	fb0c ec0c 	mla	ip, ip, ip, lr
        if( rd2_Q20 < rd1_Q20 ) {
   10db8:	4562      	cmp	r2, ip
   10dba:	bfd8      	it	le
   10dbc:	4630      	movle	r0, r6
        pulses[ i ] = (opus_int8)silk_RSHIFT_ROUND( q1_Q10, 10 );
   10dbe:	1243      	asrs	r3, r0, #9
   10dc0:	3301      	adds	r3, #1
   10dc2:	f8d7 6104 	ldr.w	r6, [r7, #260]	; 0x104
        xq[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( silk_SMULWW( xq_Q14, Gain_Q10 ), 8 ) );
   10dc6:	f8d7 10ec 	ldr.w	r1, [r7, #236]	; 0xec
        pulses[ i ] = (opus_int8)silk_RSHIFT_ROUND( q1_Q10, 10 );
   10dca:	105b      	asrs	r3, r3, #1
   10dcc:	7033      	strb	r3, [r6, #0]
        if ( NSQ->rand_seed < 0 ) {
   10dce:	f8d8 3000 	ldr.w	r3, [r8]
        exc_Q14 = silk_LSHIFT( q1_Q10, 4 );
   10dd2:	0100      	lsls	r0, r0, #4
        if ( NSQ->rand_seed < 0 ) {
   10dd4:	2b00      	cmp	r3, #0
        LPC_exc_Q14 = silk_ADD_LSHIFT32( exc_Q14, LTP_pred_Q13, 1 );
   10dd6:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
           exc_Q14 = -exc_Q14;
   10dda:	bfb8      	it	lt
   10ddc:	4240      	neglt	r0, r0
        LPC_exc_Q14 = silk_ADD_LSHIFT32( exc_Q14, LTP_pred_Q13, 1 );
   10dde:	4418      	add	r0, r3
        xq_Q14      = silk_ADD_LSHIFT32( LPC_exc_Q14, LPC_pred_Q10, 4 );
   10de0:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
   10de4:	eb00 1303 	add.w	r3, r0, r3, lsl #4
        xq[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( silk_SMULWW( xq_Q14, Gain_Q10 ), 8 ) );
   10de8:	fa1f fc83 	uxth.w	ip, r3
   10dec:	141a      	asrs	r2, r3, #16
   10dee:	fb01 f202 	mul.w	r2, r1, r2
   10df2:	fb01 fc0c 	mul.w	ip, r1, ip
   10df6:	eb02 4c2c 	add.w	ip, r2, ip, asr #16
   10dfa:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
   10dfe:	fb02 cc03 	mla	ip, r2, r3, ip
   10e02:	ea4f 1cec 	mov.w	ip, ip, asr #7
   10e06:	f10c 0c01 	add.w	ip, ip, #1
   10e0a:	ea4f 0c6c 	mov.w	ip, ip, asr #1
   10e0e:	f5bc 4f00 	cmp.w	ip, #32768	; 0x8000
   10e12:	f280 8090 	bge.w	10f36 <silk_NSQ_c+0xe2a>
   10e16:	f51c 4f00 	cmn.w	ip, #32768	; 0x8000
   10e1a:	f2c0 80fb 	blt.w	11014 <silk_NSQ_c+0xf08>
   10e1e:	fa0f fc8c 	sxth.w	ip, ip
   10e22:	f8d7 10e4 	ldr.w	r1, [r7, #228]	; 0xe4
        NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx ] = silk_SUB_LSHIFT32( sLF_AR_shp_Q14, n_LF_Q12, 2 );
   10e26:	f8d7 20f0 	ldr.w	r2, [r7, #240]	; 0xf0
        NSQ->sDiff_shp_Q14 = silk_SUB_LSHIFT32( xq_Q14, x_sc_Q10[ i ], 4 );
   10e2a:	eba3 1904 	sub.w	r9, r3, r4, lsl #4
        NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx ] = silk_SUB_LSHIFT32( sLF_AR_shp_Q14, n_LF_Q12, 2 );
   10e2e:	6812      	ldr	r2, [r2, #0]
        xq[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( silk_SMULWW( xq_Q14, Gain_Q10 ), 8 ) );
   10e30:	f821 cf02 	strh.w	ip, [r1, #2]!
        *psLPC_Q14 = xq_Q14;
   10e34:	f8cb 3000 	str.w	r3, [fp]
        sLTP_Q15[ NSQ->sLTP_buf_idx ] = silk_LSHIFT( LPC_exc_Q14, 1 );
   10e38:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
        xq[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( silk_SMULWW( xq_Q14, Gain_Q10 ), 8 ) );
   10e3c:	f8c7 10e4 	str.w	r1, [r7, #228]	; 0xe4
        sLTP_Q15[ NSQ->sLTP_buf_idx ] = silk_LSHIFT( LPC_exc_Q14, 1 );
   10e40:	f8d3 e000 	ldr.w	lr, [r3]
        NSQ->sDiff_shp_Q14 = silk_SUB_LSHIFT32( xq_Q14, x_sc_Q10[ i ], 4 );
   10e44:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
        NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx ] = silk_SUB_LSHIFT32( sLF_AR_shp_Q14, n_LF_Q12, 2 );
   10e48:	f8d7 1108 	ldr.w	r1, [r7, #264]	; 0x108
        NSQ->sDiff_shp_Q14 = silk_SUB_LSHIFT32( xq_Q14, x_sc_Q10[ i ], 4 );
   10e4c:	f8c3 9000 	str.w	r9, [r3]
        NSQ->sLTP_shp_buf_idx++;
   10e50:	1c53      	adds	r3, r2, #1
   10e52:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
        NSQ->sLF_AR_shp_Q14 = sLF_AR_shp_Q14;
   10e56:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
        sLF_AR_shp_Q14 = silk_SUB_LSHIFT32( NSQ->sDiff_shp_Q14, n_AR_Q12, 2 );
   10e5a:	eba9 0585 	sub.w	r5, r9, r5, lsl #2
        NSQ->sLF_AR_shp_Q14 = sLF_AR_shp_Q14;
   10e5e:	601d      	str	r5, [r3, #0]
        NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx ] = silk_SUB_LSHIFT32( sLF_AR_shp_Q14, n_LF_Q12, 2 );
   10e60:	eba5 0181 	sub.w	r1, r5, r1, lsl #2
   10e64:	f502 7ca0 	add.w	ip, r2, #320	; 0x140
   10e68:	f8d7 5100 	ldr.w	r5, [r7, #256]	; 0x100
        NSQ->sLTP_shp_buf_idx++;
   10e6c:	f8d7 20f0 	ldr.w	r2, [r7, #240]	; 0xf0
        NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx ] = silk_SUB_LSHIFT32( sLF_AR_shp_Q14, n_LF_Q12, 2 );
   10e70:	f845 102c 	str.w	r1, [r5, ip, lsl #2]
        NSQ->sLTP_shp_buf_idx++;
   10e74:	f8d7 1108 	ldr.w	r1, [r7, #264]	; 0x108
   10e78:	6011      	str	r1, [r2, #0]
        NSQ->sLTP_buf_idx++;
   10e7a:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
   10e7e:	f10e 0301 	add.w	r3, lr, #1
   10e82:	6013      	str	r3, [r2, #0]
        NSQ->rand_seed = silk_ADD32_ovflw( NSQ->rand_seed, pulses[ i ] );
   10e84:	f996 2000 	ldrsb.w	r2, [r6]
   10e88:	f8d8 3000 	ldr.w	r3, [r8]
   10e8c:	4413      	add	r3, r2
   10e8e:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
   10e92:	f8c8 3000 	str.w	r3, [r8]
   10e96:	3201      	adds	r2, #1
   10e98:	f8c7 2104 	str.w	r2, [r7, #260]	; 0x104
        sLTP_Q15[ NSQ->sLTP_buf_idx ] = silk_LSHIFT( LPC_exc_Q14, 1 );
   10e9c:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
   10ea0:	0040      	lsls	r0, r0, #1
   10ea2:	f842 002e 	str.w	r0, [r2, lr, lsl #2]
    for( i = 0; i < length; i++ ) {
   10ea6:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
   10eaa:	455a      	cmp	r2, fp
   10eac:	f47f ad9d 	bne.w	109ea <silk_NSQ_c+0x8de>
    silk_memcpy( NSQ->sLPC_Q14, &NSQ->sLPC_Q14[ length ], NSQ_LPC_BUF_LENGTH * sizeof( opus_int32 ) );
   10eb0:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   10eb4:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
   10eb8:	f503 7370 	add.w	r3, r3, #960	; 0x3c0
   10ebc:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   10ec0:	6a3a      	ldr	r2, [r7, #32]
   10ec2:	f103 0140 	add.w	r1, r3, #64	; 0x40
   10ec6:	681d      	ldr	r5, [r3, #0]
   10ec8:	685c      	ldr	r4, [r3, #4]
   10eca:	6898      	ldr	r0, [r3, #8]
   10ecc:	68de      	ldr	r6, [r3, #12]
   10ece:	60d6      	str	r6, [r2, #12]
   10ed0:	3310      	adds	r3, #16
   10ed2:	428b      	cmp	r3, r1
   10ed4:	6015      	str	r5, [r2, #0]
   10ed6:	6054      	str	r4, [r2, #4]
   10ed8:	6090      	str	r0, [r2, #8]
   10eda:	f102 0210 	add.w	r2, r2, #16
   10ede:	d1f2      	bne.n	10ec6 <silk_NSQ_c+0xdba>
   10ee0:	f8d7 10bc 	ldr.w	r1, [r7, #188]	; 0xbc
        x16    += psEncC->subfr_length;
   10ee4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    for( k = 0; k < psEncC->nb_subfr; k++ ) {
   10ee6:	693a      	ldr	r2, [r7, #16]
        x16    += psEncC->subfr_length;
   10ee8:	681b      	ldr	r3, [r3, #0]
    for( k = 0; k < psEncC->nb_subfr; k++ ) {
   10eea:	6814      	ldr	r4, [r2, #0]
   10eec:	6efa      	ldr	r2, [r7, #108]	; 0x6c
   10eee:	3130      	adds	r1, #48	; 0x30
   10ef0:	f8c7 10bc 	str.w	r1, [r7, #188]	; 0xbc
   10ef4:	f8d7 10d8 	ldr.w	r1, [r7, #216]	; 0xd8
   10ef8:	310a      	adds	r1, #10
   10efa:	f8c7 10d8 	str.w	r1, [r7, #216]	; 0xd8
   10efe:	6eb9      	ldr	r1, [r7, #104]	; 0x68
   10f00:	3104      	adds	r1, #4
   10f02:	66b9      	str	r1, [r7, #104]	; 0x68
        pulses += psEncC->subfr_length;
   10f04:	f8d7 1138 	ldr.w	r1, [r7, #312]	; 0x138
   10f08:	4419      	add	r1, r3
   10f0a:	f8c7 1138 	str.w	r1, [r7, #312]	; 0x138
        x16    += psEncC->subfr_length;
   10f0e:	6c79      	ldr	r1, [r7, #68]	; 0x44
   10f10:	005b      	lsls	r3, r3, #1
   10f12:	4419      	add	r1, r3
   10f14:	6479      	str	r1, [r7, #68]	; 0x44
        pxq    += psEncC->subfr_length;
   10f16:	6cb9      	ldr	r1, [r7, #72]	; 0x48
    for( k = 0; k < psEncC->nb_subfr; k++ ) {
   10f18:	3201      	adds	r2, #1
        pxq    += psEncC->subfr_length;
   10f1a:	4419      	add	r1, r3
    for( k = 0; k < psEncC->nb_subfr; k++ ) {
   10f1c:	4294      	cmp	r4, r2
   10f1e:	66fa      	str	r2, [r7, #108]	; 0x6c
        pxq    += psEncC->subfr_length;
   10f20:	64b9      	str	r1, [r7, #72]	; 0x48
    for( k = 0; k < psEncC->nb_subfr; k++ ) {
   10f22:	f340 815a 	ble.w	111da <silk_NSQ_c+0x10ce>
   10f26:	69fb      	ldr	r3, [r7, #28]
   10f28:	f993 301d 	ldrsb.w	r3, [r3, #29]
   10f2c:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
   10f30:	4610      	mov	r0, r2
   10f32:	f7ff b9ce 	b.w	102d2 <silk_NSQ_c+0x1c6>
        xq[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( silk_SMULWW( xq_Q14, Gain_Q10 ), 8 ) );
   10f36:	f647 7cff 	movw	ip, #32767	; 0x7fff
   10f3a:	e772      	b.n	10e22 <silk_NSQ_c+0xd16>
        q1_Q0 = silk_RSHIFT( q1_Q10, 10 );
   10f3c:	1296      	asrs	r6, r2, #10
        if( q1_Q0 > 0 ) {
   10f3e:	2e00      	cmp	r6, #0
   10f40:	f73f af24 	bgt.w	10d8c <silk_NSQ_c+0xc80>
        } else if( q1_Q0 == 0 ) {
   10f44:	d169      	bne.n	1101a <silk_NSQ_c+0xf0e>
   10f46:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
            rd2_Q20 = silk_SMULBB( q2_Q10, Lambda_Q10 );
   10f48:	f8d7 e030 	ldr.w	lr, [r7, #48]	; 0x30
            q1_Q10  = offset_Q10;
   10f4c:	f8d7 60e0 	ldr.w	r6, [r7, #224]	; 0xe0
   10f50:	eba3 0c00 	sub.w	ip, r3, r0
            rd1_Q20 = silk_SMULBB( q1_Q10, Lambda_Q10 );
   10f54:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   10f56:	e728      	b.n	10daa <silk_NSQ_c+0xc9e>
            tmp1 = silk_RSHIFT_ROUND( tmp1, 2 );                                /* Q10 */
   10f58:	1053      	asrs	r3, r2, #1
   10f5a:	3301      	adds	r3, #1
   10f5c:	105b      	asrs	r3, r3, #1
   10f5e:	e6e6      	b.n	10d2e <silk_NSQ_c+0xc22>
            LTP_pred_Q13 = silk_SMLAWB( LTP_pred_Q13, pred_lag_ptr[  0 ], b_Q14[ 0 ] );
   10f60:	f8d7 4084 	ldr.w	r4, [r7, #132]	; 0x84
   10f64:	f8d7 50d8 	ldr.w	r5, [r7, #216]	; 0xd8
   10f68:	6826      	ldr	r6, [r4, #0]
   10f6a:	f9b5 0000 	ldrsh.w	r0, [r5]
            LTP_pred_Q13 = silk_SMLAWB( LTP_pred_Q13, pred_lag_ptr[ -1 ], b_Q14[ 1 ] );
   10f6e:	f854 1c04 	ldr.w	r1, [r4, #-4]
   10f72:	f9b5 5002 	ldrsh.w	r5, [r5, #2]
            LTP_pred_Q13 = silk_SMLAWB( LTP_pred_Q13, pred_lag_ptr[ -2 ], b_Q14[ 2 ] );
   10f76:	f854 3c08 	ldr.w	r3, [r4, #-8]
            LTP_pred_Q13 = silk_SMLAWB( LTP_pred_Q13, pred_lag_ptr[  0 ], b_Q14[ 0 ] );
   10f7a:	b2b2      	uxth	r2, r6
   10f7c:	1436      	asrs	r6, r6, #16
   10f7e:	fb00 fc02 	mul.w	ip, r0, r2
   10f82:	fb00 f206 	mul.w	r2, r0, r6
            LTP_pred_Q13 = silk_SMLAWB( LTP_pred_Q13, pred_lag_ptr[ -1 ], b_Q14[ 1 ] );
   10f86:	b28e      	uxth	r6, r1
   10f88:	1409      	asrs	r1, r1, #16
   10f8a:	fb05 f606 	mul.w	r6, r5, r6
   10f8e:	fb05 f501 	mul.w	r5, r5, r1
            LTP_pred_Q13 = silk_SMLAWB( LTP_pred_Q13, pred_lag_ptr[ -2 ], b_Q14[ 2 ] );
   10f92:	f8d7 10d8 	ldr.w	r1, [r7, #216]	; 0xd8
            LTP_pred_Q13 = silk_SMLAWB( LTP_pred_Q13, pred_lag_ptr[ -3 ], b_Q14[ 3 ] );
   10f96:	f854 0c0c 	ldr.w	r0, [r4, #-12]
            LTP_pred_Q13 = silk_SMLAWB( LTP_pred_Q13, pred_lag_ptr[ -2 ], b_Q14[ 2 ] );
   10f9a:	f9b1 1004 	ldrsh.w	r1, [r1, #4]
            LTP_pred_Q13 = silk_SMLAWB( LTP_pred_Q13, pred_lag_ptr[  0 ], b_Q14[ 0 ] );
   10f9e:	eb02 422c 	add.w	r2, r2, ip, asr #16
            LTP_pred_Q13 = silk_SMLAWB( LTP_pred_Q13, pred_lag_ptr[ -1 ], b_Q14[ 1 ] );
   10fa2:	eb05 4526 	add.w	r5, r5, r6, asr #16
            LTP_pred_Q13 = silk_SMLAWB( LTP_pred_Q13, pred_lag_ptr[  0 ], b_Q14[ 0 ] );
   10fa6:	3202      	adds	r2, #2
            LTP_pred_Q13 = silk_SMLAWB( LTP_pred_Q13, pred_lag_ptr[ -1 ], b_Q14[ 1 ] );
   10fa8:	442a      	add	r2, r5
            LTP_pred_Q13 = silk_SMLAWB( LTP_pred_Q13, pred_lag_ptr[ -3 ], b_Q14[ 3 ] );
   10faa:	f8d7 60d8 	ldr.w	r6, [r7, #216]	; 0xd8
            LTP_pred_Q13 = silk_SMLAWB( LTP_pred_Q13, pred_lag_ptr[ -2 ], b_Q14[ 2 ] );
   10fae:	b29d      	uxth	r5, r3
   10fb0:	141b      	asrs	r3, r3, #16
   10fb2:	fb01 f505 	mul.w	r5, r1, r5
   10fb6:	fb01 f303 	mul.w	r3, r1, r3
   10fba:	eb03 4325 	add.w	r3, r3, r5, asr #16
            LTP_pred_Q13 = silk_SMLAWB( LTP_pred_Q13, pred_lag_ptr[ -3 ], b_Q14[ 3 ] );
   10fbe:	f9b6 1006 	ldrsh.w	r1, [r6, #6]
            LTP_pred_Q13 = silk_SMLAWB( LTP_pred_Q13, pred_lag_ptr[ -4 ], b_Q14[ 4 ] );
   10fc2:	f8d7 50d8 	ldr.w	r5, [r7, #216]	; 0xd8
   10fc6:	f854 6c10 	ldr.w	r6, [r4, #-16]
   10fca:	f9b5 5008 	ldrsh.w	r5, [r5, #8]
            LTP_pred_Q13 = silk_SMLAWB( LTP_pred_Q13, pred_lag_ptr[ -2 ], b_Q14[ 2 ] );
   10fce:	441a      	add	r2, r3
            LTP_pred_Q13 = silk_SMLAWB( LTP_pred_Q13, pred_lag_ptr[ -3 ], b_Q14[ 3 ] );
   10fd0:	b283      	uxth	r3, r0
   10fd2:	1400      	asrs	r0, r0, #16
   10fd4:	fb01 f303 	mul.w	r3, r1, r3
   10fd8:	fb01 f100 	mul.w	r1, r1, r0
   10fdc:	eb01 4123 	add.w	r1, r1, r3, asr #16
            LTP_pred_Q13 = silk_SMLAWB( LTP_pred_Q13, pred_lag_ptr[ -4 ], b_Q14[ 4 ] );
   10fe0:	b2b3      	uxth	r3, r6
   10fe2:	1436      	asrs	r6, r6, #16
   10fe4:	fb05 f303 	mul.w	r3, r5, r3
   10fe8:	fb05 f606 	mul.w	r6, r5, r6
            LTP_pred_Q13 = silk_SMLAWB( LTP_pred_Q13, pred_lag_ptr[ -3 ], b_Q14[ 3 ] );
   10fec:	440a      	add	r2, r1
            LTP_pred_Q13 = silk_SMLAWB( LTP_pred_Q13, pred_lag_ptr[ -4 ], b_Q14[ 4 ] );
   10fee:	eb06 4323 	add.w	r3, r6, r3, asr #16
   10ff2:	4413      	add	r3, r2
   10ff4:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
            pred_lag_ptr++;
   10ff8:	1d22      	adds	r2, r4, #4
   10ffa:	005b      	lsls	r3, r3, #1
   10ffc:	f8c7 2084 	str.w	r2, [r7, #132]	; 0x84
   11000:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
   11004:	e5e1      	b.n	10bca <silk_NSQ_c+0xabe>
            } else if (q1_Q10 < -rdo_offset) {
   11006:	6c39      	ldr	r1, [r7, #64]	; 0x40
   11008:	428a      	cmp	r2, r1
   1100a:	da1c      	bge.n	11046 <silk_NSQ_c+0xf3a>
                q1_Q0 = silk_RSHIFT( q1_Q10 + rdo_offset, 10 );
   1100c:	6f39      	ldr	r1, [r7, #112]	; 0x70
   1100e:	1856      	adds	r6, r2, r1
   11010:	12b6      	asrs	r6, r6, #10
   11012:	e6b1      	b.n	10d78 <silk_NSQ_c+0xc6c>
        xq[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( silk_SMULWW( xq_Q14, Gain_Q10 ), 8 ) );
   11014:	f8df c220 	ldr.w	ip, [pc, #544]	; 11238 <silk_NSQ_c+0x112c>
   11018:	e703      	b.n	10e22 <silk_NSQ_c+0xd16>
        } else if( q1_Q0 == -1 ) {
   1101a:	1c71      	adds	r1, r6, #1
   1101c:	d016      	beq.n	1104c <silk_NSQ_c+0xf40>
            q1_Q10  = silk_ADD32( silk_LSHIFT( q1_Q0, 10 ), QUANT_LEVEL_ADJUST_Q10 );
   1101e:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
            rd2_Q20 = silk_SMULBB( -q2_Q10, Lambda_Q10 );
   11022:	6f79      	ldr	r1, [r7, #116]	; 0x74
            q1_Q10  = silk_ADD32( silk_LSHIFT( q1_Q0, 10 ), QUANT_LEVEL_ADJUST_Q10 );
   11024:	eb02 2686 	add.w	r6, r2, r6, lsl #10
            q2_Q10  = silk_ADD32( q1_Q10, 1024 );
   11028:	f506 608a 	add.w	r0, r6, #1104	; 0x450
            q1_Q10  = silk_ADD32( q1_Q10, offset_Q10 );
   1102c:	3650      	adds	r6, #80	; 0x50
            rd2_Q20 = silk_SMULBB( -q2_Q10, Lambda_Q10 );
   1102e:	f1c0 0e00 	rsb	lr, r0, #0
            rd1_Q20 = silk_SMULBB( -q1_Q10, Lambda_Q10 );
   11032:	f1c6 0900 	rsb	r9, r6, #0
   11036:	eba3 0c00 	sub.w	ip, r3, r0
   1103a:	1b9a      	subs	r2, r3, r6
            rd2_Q20 = silk_SMULBB( -q2_Q10, Lambda_Q10 );
   1103c:	fb1e fe01 	smulbb	lr, lr, r1
            rd1_Q20 = silk_SMULBB( -q1_Q10, Lambda_Q10 );
   11040:	fb19 f301 	smulbb	r3, r9, r1
   11044:	e6b1      	b.n	10daa <silk_NSQ_c+0xc9e>
            } else if (q1_Q10 < 0) {
   11046:	2a00      	cmp	r2, #0
   11048:	f6bf af7d 	bge.w	10f46 <silk_NSQ_c+0xe3a>
        q1_Q10 = silk_SUB32( r_Q10, offset_Q10 );
   1104c:	68be      	ldr	r6, [r7, #8]
            rd2_Q20 = silk_SMULBB(  q2_Q10, Lambda_Q10 );
   1104e:	f8d7 e04c 	ldr.w	lr, [r7, #76]	; 0x4c
            q2_Q10  = offset_Q10;
   11052:	f8d7 00e0 	ldr.w	r0, [r7, #224]	; 0xe0
        q1_Q10 = silk_SUB32( r_Q10, offset_Q10 );
   11056:	4694      	mov	ip, r2
   11058:	1b9a      	subs	r2, r3, r6
            rd1_Q20 = silk_SMULBB( -q1_Q10, Lambda_Q10 );
   1105a:	687b      	ldr	r3, [r7, #4]
   1105c:	e6a5      	b.n	10daa <silk_NSQ_c+0xc9e>
        return silk_LSHIFT_SAT32(result, -lshift);
   1105e:	4249      	negs	r1, r1
   11060:	f06f 4600 	mvn.w	r6, #2147483648	; 0x80000000
   11064:	410e      	asrs	r6, r1
   11066:	42b0      	cmp	r0, r6
   11068:	f340 80aa 	ble.w	111c0 <silk_NSQ_c+0x10b4>
   1106c:	4634      	mov	r4, r6
   1106e:	408c      	lsls	r4, r1
   11070:	f7ff b98b 	b.w	1038a <silk_NSQ_c+0x27e>
   11074:	231f      	movs	r3, #31
   11076:	243c      	movs	r4, #60	; 0x3c
    a32_nrm = silk_LSHIFT(a32, a_headrm);                                       /* Q: a_headrm                  */
   11078:	4099      	lsls	r1, r3
   1107a:	f1bc 0f00 	cmp.w	ip, #0
   1107e:	f47f a9fb 	bne.w	10478 <silk_NSQ_c+0x36c>
   11082:	251f      	movs	r5, #31
   11084:	f7ff b9ff 	b.w	10486 <silk_NSQ_c+0x37a>
            lag = pitchL[ k ];
   11088:	4619      	mov	r1, r3
   1108a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
   1108c:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
            if( ( k & ( 3 - silk_LSHIFT( LSF_interpolation_flag, 1 ) ) ) == 0 ) {
   11090:	6839      	ldr	r1, [r7, #0]
            lag = pitchL[ k ];
   11092:	f8c7 20b4 	str.w	r2, [r7, #180]	; 0xb4
            if( ( k & ( 3 - silk_LSHIFT( LSF_interpolation_flag, 1 ) ) ) == 0 ) {
   11096:	4219      	tst	r1, r3
   11098:	d05c      	beq.n	11154 <silk_NSQ_c+0x1048>
   1109a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
   1109e:	4692      	mov	sl, r2
   110a0:	f8d3 b000 	ldr.w	fp, [r3]
   110a4:	f04f 0900 	mov.w	r9, #0
   110a8:	f7ff b93a 	b.w	10320 <silk_NSQ_c+0x214>
        return silk_LSHIFT_SAT32(result, -lshift);
   110ac:	f1c4 0410 	rsb	r4, r4, #16
   110b0:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   110b4:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
   110b8:	4122      	asrs	r2, r4
   110ba:	4121      	asrs	r1, r4
   110bc:	428a      	cmp	r2, r1
   110be:	dd3b      	ble.n	11138 <silk_NSQ_c+0x102c>
   110c0:	4293      	cmp	r3, r2
   110c2:	f340 8086 	ble.w	111d2 <silk_NSQ_c+0x10c6>
   110c6:	4613      	mov	r3, r2
   110c8:	e03b      	b.n	11142 <silk_NSQ_c+0x1036>
        if( signal_type == TYPE_VOICED && NSQ->rewhite_flag == 0 ) {
   110ca:	f1b9 0f00 	cmp.w	r9, #0
   110ce:	f47f aa37 	bne.w	10540 <silk_NSQ_c+0x434>
            for( i = NSQ->sLTP_buf_idx - lag - LTP_ORDER / 2; i < NSQ->sLTP_buf_idx; i++ ) {
   110d2:	ebab 060a 	sub.w	r6, fp, sl
   110d6:	1eb0      	subs	r0, r6, #2
   110d8:	4558      	cmp	r0, fp
   110da:	f6bf aa31 	bge.w	10540 <silk_NSQ_c+0x434>
   110de:	f8d7 10b8 	ldr.w	r1, [r7, #184]	; 0xb8
   110e2:	f8d7 210c 	ldr.w	r2, [r7, #268]	; 0x10c
   110e6:	f106 4680 	add.w	r6, r6, #1073741824	; 0x40000000
   110ea:	3e03      	subs	r6, #3
   110ec:	f1a1 0c04 	sub.w	ip, r1, #4
   110f0:	eb01 0686 	add.w	r6, r1, r6, lsl #2
   110f4:	f8d7 1104 	ldr.w	r1, [r7, #260]	; 0x104
   110f8:	eb0c 0c8b 	add.w	ip, ip, fp, lsl #2
                sLTP_Q15[ i ] = silk_SMULWW( gain_adj_Q16, sLTP_Q15[ i ] );
   110fc:	f856 0f04 	ldr.w	r0, [r6, #4]!
   11100:	b204      	sxth	r4, r0
   11102:	13c0      	asrs	r0, r0, #15
   11104:	fb02 f504 	mul.w	r5, r2, r4
   11108:	3001      	adds	r0, #1
   1110a:	fb01 f404 	mul.w	r4, r1, r4
   1110e:	1040      	asrs	r0, r0, #1
   11110:	eb04 4425 	add.w	r4, r4, r5, asr #16
   11114:	fb03 4000 	mla	r0, r3, r0, r4
            for( i = NSQ->sLTP_buf_idx - lag - LTP_ORDER / 2; i < NSQ->sLTP_buf_idx; i++ ) {
   11118:	45b4      	cmp	ip, r6
                sLTP_Q15[ i ] = silk_SMULWW( gain_adj_Q16, sLTP_Q15[ i ] );
   1111a:	6030      	str	r0, [r6, #0]
            for( i = NSQ->sLTP_buf_idx - lag - LTP_ORDER / 2; i < NSQ->sLTP_buf_idx; i++ ) {
   1111c:	d1ee      	bne.n	110fc <silk_NSQ_c+0xff0>
   1111e:	f8c7 1104 	str.w	r1, [r7, #260]	; 0x104
   11122:	f8c7 210c 	str.w	r2, [r7, #268]	; 0x10c
   11126:	f7ff ba0b 	b.w	10540 <silk_NSQ_c+0x434>
        if( lshift < 32){
   1112a:	2300      	movs	r3, #0
   1112c:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
   11130:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
   11134:	f7ff b9d4 	b.w	104e0 <silk_NSQ_c+0x3d4>
        return silk_LSHIFT_SAT32(result, -lshift);
   11138:	428b      	cmp	r3, r1
   1113a:	dc48      	bgt.n	111ce <silk_NSQ_c+0x10c2>
   1113c:	4293      	cmp	r3, r2
   1113e:	bfb8      	it	lt
   11140:	4613      	movlt	r3, r2
   11142:	40a3      	lsls	r3, r4
   11144:	141a      	asrs	r2, r3, #16
   11146:	f8c7 2104 	str.w	r2, [r7, #260]	; 0x104
   1114a:	b29a      	uxth	r2, r3
   1114c:	f8c7 210c 	str.w	r2, [r7, #268]	; 0x10c
   11150:	f7ff b9c6 	b.w	104e0 <silk_NSQ_c+0x3d4>
                start_idx = psEncC->ltp_mem_length - lag - psEncC->predictLPCOrder - LTP_ORDER / 2;
   11154:	6afd      	ldr	r5, [r7, #44]	; 0x2c
                silk_LPC_analysis_filter( &sLTP[ start_idx ], &NSQ->xq[ start_idx + k * psEncC->subfr_length ],
   11156:	6d79      	ldr	r1, [r7, #84]	; 0x54
   11158:	461e      	mov	r6, r3
                start_idx = psEncC->ltp_mem_length - lag - psEncC->predictLPCOrder - LTP_ORDER / 2;
   1115a:	f241 14f0 	movw	r4, #4592	; 0x11f0
   1115e:	6abb      	ldr	r3, [r7, #40]	; 0x28
                silk_LPC_analysis_filter( &sLTP[ start_idx ], &NSQ->xq[ start_idx + k * psEncC->subfr_length ],
   11160:	6809      	ldr	r1, [r1, #0]
   11162:	4610      	mov	r0, r2
                start_idx = psEncC->ltp_mem_length - lag - psEncC->predictLPCOrder - LTP_ORDER / 2;
   11164:	681a      	ldr	r2, [r3, #0]
   11166:	592b      	ldr	r3, [r5, r4]
                silk_LPC_analysis_filter( &sLTP[ start_idx ], &NSQ->xq[ start_idx + k * psEncC->subfr_length ],
   11168:	9200      	str	r2, [sp, #0]
                start_idx = psEncC->ltp_mem_length - lag - psEncC->predictLPCOrder - LTP_ORDER / 2;
   1116a:	1a18      	subs	r0, r3, r0
   1116c:	1a80      	subs	r0, r0, r2
                silk_LPC_analysis_filter( &sLTP[ start_idx ], &NSQ->xq[ start_idx + k * psEncC->subfr_length ],
   1116e:	f241 32e4 	movw	r2, #5092	; 0x13e4
                start_idx = psEncC->ltp_mem_length - lag - psEncC->predictLPCOrder - LTP_ORDER / 2;
   11172:	3802      	subs	r0, #2
                silk_LPC_analysis_filter( &sLTP[ start_idx ], &NSQ->xq[ start_idx + k * psEncC->subfr_length ],
   11174:	58aa      	ldr	r2, [r5, r2]
   11176:	9201      	str	r2, [sp, #4]
   11178:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
   1117c:	fb01 0106 	mla	r1, r1, r6, r0
   11180:	eb02 0141 	add.w	r1, r2, r1, lsl #1
   11184:	68fa      	ldr	r2, [r7, #12]
   11186:	1a1b      	subs	r3, r3, r0
   11188:	eb02 0040 	add.w	r0, r2, r0, lsl #1
   1118c:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
   11190:	f006 fc7c 	bl	17a8c <silk_LPC_analysis_filter>
                NSQ->rewhite_flag = 1;
   11194:	6bba      	ldr	r2, [r7, #56]	; 0x38
                NSQ->sLTP_buf_idx = psEncC->ltp_mem_length;
   11196:	f855 b004 	ldr.w	fp, [r5, r4]
   1119a:	6efe      	ldr	r6, [r7, #108]	; 0x6c
                NSQ->rewhite_flag = 1;
   1119c:	2301      	movs	r3, #1
   1119e:	6013      	str	r3, [r2, #0]
                NSQ->sLTP_buf_idx = psEncC->ltp_mem_length;
   111a0:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
   111a4:	f8c2 b000 	str.w	fp, [r2]
   111a8:	69fa      	ldr	r2, [r7, #28]
   111aa:	f992 201d 	ldrsb.w	r2, [r2, #29]
   111ae:	f8c7 20cc 	str.w	r2, [r7, #204]	; 0xcc
   111b2:	f8d7 2158 	ldr.w	r2, [r7, #344]	; 0x158
   111b6:	4699      	mov	r9, r3
   111b8:	f852 a026 	ldr.w	sl, [r2, r6, lsl #2]
   111bc:	f7ff b8b0 	b.w	10320 <silk_NSQ_c+0x214>
        return silk_LSHIFT_SAT32(result, -lshift);
   111c0:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
   111c4:	410c      	asrs	r4, r1
   111c6:	4284      	cmp	r4, r0
   111c8:	bfb8      	it	lt
   111ca:	4604      	movlt	r4, r0
   111cc:	e74f      	b.n	1106e <silk_NSQ_c+0xf62>
        return silk_LSHIFT_SAT32(result, -lshift);
   111ce:	460b      	mov	r3, r1
   111d0:	e7b7      	b.n	11142 <silk_NSQ_c+0x1036>
   111d2:	428b      	cmp	r3, r1
   111d4:	bfb8      	it	lt
   111d6:	460b      	movlt	r3, r1
   111d8:	e7b3      	b.n	11142 <silk_NSQ_c+0x1036>
   111da:	f8d7 b100 	ldr.w	fp, [r7, #256]	; 0x100
    silk_memmove( NSQ->xq,           &NSQ->xq[           psEncC->frame_length ], psEncC->ltp_mem_length * sizeof( opus_int16 ) );
   111de:	6af9      	ldr	r1, [r7, #44]	; 0x2c
    NSQ->lagPrev = pitchL[ psEncC->nb_subfr - 1 ];
   111e0:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
   111e4:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
    silk_memmove( NSQ->xq,           &NSQ->xq[           psEncC->frame_length ], psEncC->ltp_mem_length * sizeof( opus_int16 ) );
   111e8:	f241 15f0 	movw	r5, #4592	; 0x11f0
   111ec:	f241 16e8 	movw	r6, #4584	; 0x11e8
    NSQ->lagPrev = pitchL[ psEncC->nb_subfr - 1 ];
   111f0:	3c01      	subs	r4, #1
    silk_memmove( NSQ->xq,           &NSQ->xq[           psEncC->frame_length ], psEncC->ltp_mem_length * sizeof( opus_int16 ) );
   111f2:	594a      	ldr	r2, [r1, r5]
    NSQ->lagPrev = pitchL[ psEncC->nb_subfr - 1 ];
   111f4:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
   111f8:	f241 00e8 	movw	r0, #4328	; 0x10e8
    silk_memmove( NSQ->xq,           &NSQ->xq[           psEncC->frame_length ], psEncC->ltp_mem_length * sizeof( opus_int16 ) );
   111fc:	460c      	mov	r4, r1
   111fe:	5989      	ldr	r1, [r1, r6]
    NSQ->lagPrev = pitchL[ psEncC->nb_subfr - 1 ];
   11200:	f84b 3000 	str.w	r3, [fp, r0]
    silk_memmove( NSQ->xq,           &NSQ->xq[           psEncC->frame_length ], psEncC->ltp_mem_length * sizeof( opus_int16 ) );
   11204:	eb0b 0141 	add.w	r1, fp, r1, lsl #1
   11208:	0052      	lsls	r2, r2, #1
   1120a:	4658      	mov	r0, fp
   1120c:	f023 ff46 	bl	3509c <memmove>
    silk_memmove( NSQ->sLTP_shp_Q14, &NSQ->sLTP_shp_Q14[ psEncC->frame_length ], psEncC->ltp_mem_length * sizeof( opus_int32 ) );
   11210:	59a1      	ldr	r1, [r4, r6]
   11212:	5962      	ldr	r2, [r4, r5]
   11214:	6978      	ldr	r0, [r7, #20]
   11216:	f501 71a0 	add.w	r1, r1, #320	; 0x140
   1121a:	eb0b 0181 	add.w	r1, fp, r1, lsl #2
   1121e:	0092      	lsls	r2, r2, #2
   11220:	f023 ff3c 	bl	3509c <memmove>
}
   11224:	f507 778a 	add.w	r7, r7, #276	; 0x114
   11228:	46bd      	mov	sp, r7
   1122a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1122e:	f50b 63a0 	add.w	r3, fp, #1280	; 0x500
   11232:	617b      	str	r3, [r7, #20]
   11234:	e7d3      	b.n	111de <silk_NSQ_c+0x10d2>
   11236:	bf00      	nop
   11238:	ffff8000 	.word	0xffff8000

0001123c <silk_NSQ_del_dec_c>:
    const opus_int32            Gains_Q16[ MAX_NB_SUBFR ],                  /* I    Quantization step sizes         */
    const opus_int              pitchL[ MAX_NB_SUBFR ],                     /* I    Pitch lags                      */
    const opus_int              Lambda_Q10,                                 /* I    Rate/distortion tradeoff        */
    const opus_int              LTP_scale_Q14                               /* I    LTP state scaling               */
)
{
   1123c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11240:	4605      	mov	r5, r0
   11242:	f5ad 7d13 	sub.w	sp, sp, #588	; 0x24c
    lag = NSQ->lagPrev;

    silk_assert( NSQ->prev_gain_Q16 != 0 );

    /* Initialize delayed decision states */
    ALLOC( psDelDec, psEncC->nStatesDelayedDecision, NSQ_del_dec_struct );
   11246:	f241 2014 	movw	r0, #4628	; 0x1214
   1124a:	582e      	ldr	r6, [r5, r0]
   1124c:	f240 5414 	movw	r4, #1300	; 0x514
{
   11250:	af02      	add	r7, sp, #8
    ALLOC( psDelDec, psEncC->nStatesDelayedDecision, NSQ_del_dec_struct );
   11252:	fb04 f406 	mul.w	r4, r4, r6
   11256:	f104 000a 	add.w	r0, r4, #10
{
   1125a:	468c      	mov	ip, r1
    ALLOC( psDelDec, psEncC->nStatesDelayedDecision, NSQ_del_dec_struct );
   1125c:	667d      	str	r5, [r7, #100]	; 0x64
   1125e:	f020 0007 	bic.w	r0, r0, #7
    lag = NSQ->lagPrev;
   11262:	f241 05e8 	movw	r5, #4328	; 0x10e8
    ALLOC( psDelDec, psEncC->nStatesDelayedDecision, NSQ_del_dec_struct );
   11266:	ebad 0d00 	sub.w	sp, sp, r0
{
   1126a:	f8c7 10bc 	str.w	r1, [r7, #188]	; 0xbc
    ALLOC( psDelDec, psEncC->nStatesDelayedDecision, NSQ_del_dec_struct );
   1126e:	a802      	add	r0, sp, #8
{
   11270:	653a      	str	r2, [r7, #80]	; 0x50
    silk_memset( psDelDec, 0, psEncC->nStatesDelayedDecision * sizeof( NSQ_del_dec_struct ) );
   11272:	2100      	movs	r1, #0
   11274:	4622      	mov	r2, r4
{
   11276:	663b      	str	r3, [r7, #96]	; 0x60
    lag = NSQ->lagPrev;
   11278:	f85c 3005 	ldr.w	r3, [ip, r5]
   1127c:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
   11280:	4664      	mov	r4, ip
    ALLOC( psDelDec, psEncC->nStatesDelayedDecision, NSQ_del_dec_struct );
   11282:	f8c7 6190 	str.w	r6, [r7, #400]	; 0x190
   11286:	f8c7 0144 	str.w	r0, [r7, #324]	; 0x144
    silk_memset( psDelDec, 0, psEncC->nStatesDelayedDecision * sizeof( NSQ_del_dec_struct ) );
   1128a:	f023 ff6b 	bl	35164 <memset>
   1128e:	f241 13f0 	movw	r3, #4592	; 0x11f0
   11292:	6e7d      	ldr	r5, [r7, #100]	; 0x64
   11294:	f504 6170 	add.w	r1, r4, #3840	; 0xf00
   11298:	f855 8003 	ldr.w	r8, [r5, r3]
   1129c:	6139      	str	r1, [r7, #16]
   1129e:	f504 5384 	add.w	r3, r4, #4224	; 0x1080
    for( k = 0; k < psEncC->nStatesDelayedDecision; k++ ) {
   112a2:	2e00      	cmp	r6, #0
   112a4:	60fb      	str	r3, [r7, #12]
   112a6:	f342 81ec 	ble.w	13682 <silk_NSQ_del_dec_c+0x2446>
   112aa:	460e      	mov	r6, r1
   112ac:	f8d7 10bc 	ldr.w	r1, [r7, #188]	; 0xbc
   112b0:	f8d7 4144 	ldr.w	r4, [r7, #324]	; 0x144
   112b4:	f501 5387 	add.w	r3, r1, #4320	; 0x10e0
   112b8:	4618      	mov	r0, r3
   112ba:	60bb      	str	r3, [r7, #8]
   112bc:	f208 133f 	addw	r3, r8, #319	; 0x13f
   112c0:	f241 02e4 	movw	r2, #4324	; 0x10e4
   112c4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   112c8:	f8c7 3194 	str.w	r3, [r7, #404]	; 0x194
   112cc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   112ce:	6800      	ldr	r0, [r0, #0]
   112d0:	588a      	ldr	r2, [r1, r2]
   112d2:	f993 b022 	ldrsb.w	fp, [r3, #34]	; 0x22
   112d6:	f8c7 019c 	str.w	r0, [r7, #412]	; 0x19c
   112da:	2500      	movs	r5, #0
   112dc:	f8c7 2198 	str.w	r2, [r7, #408]	; 0x198
        psDD                 = &psDelDec[ k ];
        psDD->Seed           = ( k + psIndices->Seed ) & 3;
        psDD->SeedInit       = psDD->Seed;
        psDD->RD_Q10         = 0;
   112e0:	46aa      	mov	sl, r5
   112e2:	f501 6974 	add.w	r9, r1, #3904	; 0xf40
        psDD->LF_AR_Q14      = NSQ->sLF_AR_shp_Q14;
   112e6:	f8d7 219c 	ldr.w	r2, [r7, #412]	; 0x19c
   112ea:	f8c4 2500 	str.w	r2, [r4, #1280]	; 0x500
        psDD->Seed           = ( k + psIndices->Seed ) & 3;
   112ee:	eb05 030b 	add.w	r3, r5, fp
        psDD->Diff_Q14       = NSQ->sDiff_shp_Q14;
   112f2:	f8d7 2198 	ldr.w	r2, [r7, #408]	; 0x198
   112f6:	f8c4 2504 	str.w	r2, [r4, #1284]	; 0x504
        psDD->Seed           = ( k + psIndices->Seed ) & 3;
   112fa:	f003 0303 	and.w	r3, r3, #3
        psDD->Shape_Q14[ 0 ] = NSQ->sLTP_shp_Q14[ psEncC->ltp_mem_length - 1 ];
   112fe:	f8d7 2194 	ldr.w	r2, [r7, #404]	; 0x194
   11302:	f8c4 2400 	str.w	r2, [r4, #1024]	; 0x400
        psDD->Seed           = ( k + psIndices->Seed ) & 3;
   11306:	f8c4 3508 	str.w	r3, [r4, #1288]	; 0x508
        psDD->SeedInit       = psDD->Seed;
   1130a:	f8c4 350c 	str.w	r3, [r4, #1292]	; 0x50c
        psDD->RD_Q10         = 0;
   1130e:	f8c4 a510 	str.w	sl, [r4, #1296]	; 0x510
        silk_memcpy( psDD->sLPC_Q14, NSQ->sLPC_Q14, NSQ_LPC_BUF_LENGTH * sizeof( opus_int32 ) );
   11312:	4633      	mov	r3, r6
   11314:	4622      	mov	r2, r4
   11316:	f8d3 c000 	ldr.w	ip, [r3]
   1131a:	6858      	ldr	r0, [r3, #4]
   1131c:	6899      	ldr	r1, [r3, #8]
   1131e:	f8d3 e00c 	ldr.w	lr, [r3, #12]
   11322:	f8c2 e00c 	str.w	lr, [r2, #12]
   11326:	3310      	adds	r3, #16
   11328:	454b      	cmp	r3, r9
   1132a:	f8c2 c000 	str.w	ip, [r2]
   1132e:	6050      	str	r0, [r2, #4]
   11330:	6091      	str	r1, [r2, #8]
   11332:	f102 0210 	add.w	r2, r2, #16
   11336:	d1ee      	bne.n	11316 <silk_NSQ_del_dec_c+0xda>
        silk_memcpy( psDD->sAR2_Q14, NSQ->sAR2_Q14, sizeof( NSQ->sAR2_Q14 ) );
   11338:	f504 6094 	add.w	r0, r4, #1184	; 0x4a0
   1133c:	2260      	movs	r2, #96	; 0x60
   1133e:	68f9      	ldr	r1, [r7, #12]
   11340:	f7fa fede 	bl	c100 <memcpy>
    for( k = 0; k < psEncC->nStatesDelayedDecision; k++ ) {
   11344:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
   11348:	3501      	adds	r5, #1
   1134a:	42ab      	cmp	r3, r5
   1134c:	f204 5414 	addw	r4, r4, #1300	; 0x514
   11350:	d1c9      	bne.n	112e6 <silk_NSQ_del_dec_c+0xaa>
    }

    offset_Q10   = silk_Quantization_Offsets_Q10[ psIndices->signalType >> 1 ][ psIndices->quantOffsetType ];
   11352:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   11354:	49c8      	ldr	r1, [pc, #800]	; (11678 <silk_NSQ_del_dec_c+0x43c>)
   11356:	f993 401d 	ldrsb.w	r4, [r3, #29]
   1135a:	f993 001e 	ldrsb.w	r0, [r3, #30]
   1135e:	f8c7 40b8 	str.w	r4, [r7, #184]	; 0xb8
   11362:	f024 0301 	bic.w	r3, r4, #1
   11366:	4403      	add	r3, r0
    smpl_buf_idx = 0; /* index of oldest samples */

    decisionDelay = silk_min_int( DECISION_DELAY, psEncC->subfr_length );
   11368:	f241 12ec 	movw	r2, #4588	; 0x11ec
   1136c:	6e78      	ldr	r0, [r7, #100]	; 0x64
    offset_Q10   = silk_Quantization_Offsets_Q10[ psIndices->signalType >> 1 ][ psIndices->quantOffsetType ];
   1136e:	f931 3013 	ldrsh.w	r3, [r1, r3, lsl #1]
    decisionDelay = silk_min_int( DECISION_DELAY, psEncC->subfr_length );
   11372:	5882      	ldr	r2, [r0, r2]
    offset_Q10   = silk_Quantization_Offsets_Q10[ psIndices->signalType >> 1 ][ psIndices->quantOffsetType ];
   11374:	f8c7 3194 	str.w	r3, [r7, #404]	; 0x194
    return (((a) < (b)) ? (a) : (b));
   11378:	2a28      	cmp	r2, #40	; 0x28
   1137a:	4613      	mov	r3, r2
   1137c:	bfa8      	it	ge
   1137e:	2328      	movge	r3, #40	; 0x28

    /* For voiced frames limit the decision delay to lower than the pitch lag */
    if( psIndices->signalType == TYPE_VOICED ) {
   11380:	2c02      	cmp	r4, #2
   11382:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
   11386:	f002 80b6 	beq.w	134f6 <silk_NSQ_del_dec_c+0x22ba>
        for( k = 0; k < psEncC->nb_subfr; k++ ) {
            decisionDelay = silk_min_int( decisionDelay, pitchL[ k ] - LTP_ORDER / 2 - 1 );
        }
    } else {
        if( lag > 0 ) {
   1138a:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
   1138e:	2b00      	cmp	r3, #0
   11390:	dd07      	ble.n	113a2 <silk_NSQ_del_dec_c+0x166>
   11392:	f8d7 10ec 	ldr.w	r1, [r7, #236]	; 0xec
            decisionDelay = silk_min_int( decisionDelay, lag - LTP_ORDER / 2 - 1 );
   11396:	3b03      	subs	r3, #3
   11398:	4299      	cmp	r1, r3
   1139a:	bfa8      	it	ge
   1139c:	4619      	movge	r1, r3
   1139e:	f8c7 10ec 	str.w	r1, [r7, #236]	; 0xec
        LSF_interpolation_flag = 0;
    } else {
        LSF_interpolation_flag = 1;
    }

    ALLOC( sLTP_Q15, psEncC->ltp_mem_length + psEncC->frame_length, opus_int32 );
   113a2:	6e7d      	ldr	r5, [r7, #100]	; 0x64
    if( psIndices->NLSFInterpCoef_Q2 == 4 ) {
   113a4:	6d39      	ldr	r1, [r7, #80]	; 0x50
    ALLOC( sLTP_Q15, psEncC->ltp_mem_length + psEncC->frame_length, opus_int32 );
   113a6:	f241 13e8 	movw	r3, #4584	; 0x11e8
    /* Set up pointers to start of sub frame */
    pxq                   = &NSQ->xq[ psEncC->ltp_mem_length ];
    NSQ->sLTP_shp_buf_idx = psEncC->ltp_mem_length;
    NSQ->sLTP_buf_idx     = psEncC->ltp_mem_length;
    subfr = 0;
    for( k = 0; k < psEncC->nb_subfr; k++ ) {
   113aa:	f241 14e4 	movw	r4, #4580	; 0x11e4
    ALLOC( sLTP_Q15, psEncC->ltp_mem_length + psEncC->frame_length, opus_int32 );
   113ae:	58eb      	ldr	r3, [r5, r3]
    if( psIndices->NLSFInterpCoef_Q2 == 4 ) {
   113b0:	f991 101f 	ldrsb.w	r1, [r1, #31]
    ALLOC( sLTP_Q15, psEncC->ltp_mem_length + psEncC->frame_length, opus_int32 );
   113b4:	4443      	add	r3, r8
   113b6:	0098      	lsls	r0, r3, #2
   113b8:	300a      	adds	r0, #10
    ALLOC( sLTP, psEncC->ltp_mem_length + psEncC->frame_length, opus_int16 );
   113ba:	005b      	lsls	r3, r3, #1
    ALLOC( sLTP_Q15, psEncC->ltp_mem_length + psEncC->frame_length, opus_int32 );
   113bc:	f020 0007 	bic.w	r0, r0, #7
    ALLOC( sLTP, psEncC->ltp_mem_length + psEncC->frame_length, opus_int16 );
   113c0:	3308      	adds	r3, #8
    ALLOC( sLTP_Q15, psEncC->ltp_mem_length + psEncC->frame_length, opus_int32 );
   113c2:	ebad 0d00 	sub.w	sp, sp, r0
    ALLOC( sLTP, psEncC->ltp_mem_length + psEncC->frame_length, opus_int16 );
   113c6:	f023 0307 	bic.w	r3, r3, #7
    ALLOC( sLTP_Q15, psEncC->ltp_mem_length + psEncC->frame_length, opus_int32 );
   113ca:	a802      	add	r0, sp, #8
    ALLOC( x_sc_Q10, psEncC->subfr_length, opus_int32 );
   113cc:	0092      	lsls	r2, r2, #2
    ALLOC( sLTP, psEncC->ltp_mem_length + psEncC->frame_length, opus_int16 );
   113ce:	ebad 0d03 	sub.w	sp, sp, r3
   113d2:	ae02      	add	r6, sp, #8
    ALLOC( x_sc_Q10, psEncC->subfr_length, opus_int32 );
   113d4:	320a      	adds	r2, #10
   113d6:	f022 0207 	bic.w	r2, r2, #7
    NSQ->sLTP_buf_idx     = psEncC->ltp_mem_length;
   113da:	f241 03ec 	movw	r3, #4332	; 0x10ec
    ALLOC( sLTP_Q15, psEncC->ltp_mem_length + psEncC->frame_length, opus_int32 );
   113de:	f8c7 00a0 	str.w	r0, [r7, #160]	; 0xa0
    ALLOC( sLTP, psEncC->ltp_mem_length + psEncC->frame_length, opus_int16 );
   113e2:	617e      	str	r6, [r7, #20]
    for( k = 0; k < psEncC->nb_subfr; k++ ) {
   113e4:	5928      	ldr	r0, [r5, r4]
    NSQ->sLTP_shp_buf_idx = psEncC->ltp_mem_length;
   113e6:	f8d7 60bc 	ldr.w	r6, [r7, #188]	; 0xbc
   113ea:	f241 04f0 	movw	r4, #4336	; 0x10f0
    if( psIndices->NLSFInterpCoef_Q2 == 4 ) {
   113ee:	3904      	subs	r1, #4
    ALLOC( x_sc_Q10, psEncC->subfr_length, opus_int32 );
   113f0:	ebad 0d02 	sub.w	sp, sp, r2
    NSQ->sLTP_shp_buf_idx = psEncC->ltp_mem_length;
   113f4:	f846 8004 	str.w	r8, [r6, r4]
    ALLOC( x_sc_Q10, psEncC->subfr_length, opus_int32 );
   113f8:	aa02      	add	r2, sp, #8
    if( psIndices->NLSFInterpCoef_Q2 == 4 ) {
   113fa:	bf18      	it	ne
   113fc:	2101      	movne	r1, #1
    NSQ->sLTP_buf_idx     = psEncC->ltp_mem_length;
   113fe:	f846 8003 	str.w	r8, [r6, r3]
    for( k = 0; k < psEncC->nb_subfr; k++ ) {
   11402:	2800      	cmp	r0, #0
    pxq                   = &NSQ->xq[ psEncC->ltp_mem_length ];
   11404:	eb06 0348 	add.w	r3, r6, r8, lsl #1
    ALLOC( x_sc_Q10, psEncC->subfr_length, opus_int32 );
   11408:	67fa      	str	r2, [r7, #124]	; 0x7c
    NSQ->sLTP_buf_idx     = psEncC->ltp_mem_length;
   1140a:	4634      	mov	r4, r6
    pxq                   = &NSQ->xq[ psEncC->ltp_mem_length ];
   1140c:	66bb      	str	r3, [r7, #104]	; 0x68
    for( k = 0; k < psEncC->nb_subfr; k++ ) {
   1140e:	f342 8132 	ble.w	13676 <silk_NSQ_del_dec_c+0x243a>
                q2_Q10  = silk_ADD32( q1_Q10, 1024 - QUANT_LEVEL_ADJUST_Q10 );
                rd1_Q10 = silk_SMULBB( q1_Q10, Lambda_Q10 );
                rd2_Q10 = silk_SMULBB( q2_Q10, Lambda_Q10 );
            } else if( q1_Q0 == -1 ) {
                q2_Q10  = offset_Q10;
                q1_Q10  = silk_SUB32( q2_Q10, 1024 - QUANT_LEVEL_ADJUST_Q10 );
   11412:	f8d7 2194 	ldr.w	r2, [r7, #404]	; 0x194
   11416:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
                q2_Q10  = silk_ADD32( q1_Q10, 1024 - QUANT_LEVEL_ADJUST_Q10 );
   1141a:	f502 766c 	add.w	r6, r2, #944	; 0x3b0
   1141e:	f8c7 60c4 	str.w	r6, [r7, #196]	; 0xc4
   11422:	f504 5c87 	add.w	ip, r4, #4320	; 0x10e0
    smpl_buf_idx = 0; /* index of oldest samples */
   11426:	2600      	movs	r6, #0
   11428:	f8c7 6148 	str.w	r6, [r7, #328]	; 0x148
   1142c:	f8c7 c038 	str.w	ip, [r7, #56]	; 0x38
   11430:	4626      	mov	r6, r4
   11432:	f505 5c90 	add.w	ip, r5, #4608	; 0x1200
   11436:	462c      	mov	r4, r5
   11438:	f8c7 c034 	str.w	ip, [r7, #52]	; 0x34
   1143c:	f506 5c87 	add.w	ip, r6, #4320	; 0x10e0
   11440:	f8c7 c0e0 	str.w	ip, [r7, #224]	; 0xe0
   11444:	f504 5c8f 	add.w	ip, r4, #4576	; 0x11e0
   11448:	f8c7 c054 	str.w	ip, [r7, #84]	; 0x54
   1144c:	f506 5c87 	add.w	ip, r6, #4320	; 0x10e0
   11450:	f8d7 5278 	ldr.w	r5, [r7, #632]	; 0x278
   11454:	f8c7 c04c 	str.w	ip, [r7, #76]	; 0x4c
   11458:	005b      	lsls	r3, r3, #1
   1145a:	f504 5c90 	add.w	ip, r4, #4608	; 0x1200
   1145e:	f083 0001 	eor.w	r0, r3, #1
   11462:	f8c7 c02c 	str.w	ip, [r7, #44]	; 0x2c
                q1_Q10  = silk_SUB32( q2_Q10, 1024 - QUANT_LEVEL_ADJUST_Q10 );
   11466:	f5a2 736c 	sub.w	r3, r2, #944	; 0x3b0
   1146a:	f504 5c8f 	add.w	ip, r4, #4576	; 0x11e0
   1146e:	66fb      	str	r3, [r7, #108]	; 0x6c
                rd1_Q10 = silk_SMULBB( -q1_Q10, Lambda_Q10 );
   11470:	f1c3 0e00 	rsb	lr, r3, #0
   11474:	f8c7 c030 	str.w	ip, [r7, #48]	; 0x30
   11478:	f8d7 328c 	ldr.w	r3, [r7, #652]	; 0x28c
   1147c:	f1a5 0c04 	sub.w	ip, r5, #4
   11480:	f8d7 527c 	ldr.w	r5, [r7, #636]	; 0x27c
   11484:	f8c7 c040 	str.w	ip, [r7, #64]	; 0x40
   11488:	b21b      	sxth	r3, r3
   1148a:	f1a5 0c04 	sub.w	ip, r5, #4
   1148e:	f8d7 5280 	ldr.w	r5, [r7, #640]	; 0x280
   11492:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
   11496:	43c0      	mvns	r0, r0
   11498:	f8c7 c044 	str.w	ip, [r7, #68]	; 0x44
   1149c:	f1a5 0c04 	sub.w	ip, r5, #4
   114a0:	f8d7 5154 	ldr.w	r5, [r7, #340]	; 0x154
   114a4:	6038      	str	r0, [r7, #0]
   114a6:	3002      	adds	r0, #2
   114a8:	6278      	str	r0, [r7, #36]	; 0x24
   114aa:	fb1e f005 	smulbb	r0, lr, r5
   114ae:	6738      	str	r0, [r7, #112]	; 0x70
                rd2_Q10 = silk_SMULBB(  q2_Q10, Lambda_Q10 );
   114b0:	f8d7 0194 	ldr.w	r0, [r7, #404]	; 0x194
                int rdo_offset = Lambda_Q10/2 - 512;
   114b4:	f8d7 328c 	ldr.w	r3, [r7, #652]	; 0x28c
   114b8:	f8c7 c048 	str.w	ip, [r7, #72]	; 0x48
            if( ( k & ( 3 - silk_LSHIFT( LSF_interpolation_flag, 1 ) ) ) == 0 ) {
   114bc:	004a      	lsls	r2, r1, #1
                rd2_Q10 = silk_SMULBB(  q2_Q10, Lambda_Q10 );
   114be:	4684      	mov	ip, r0
            if( ( k & ( 3 - silk_LSHIFT( LSF_interpolation_flag, 1 ) ) ) == 0 ) {
   114c0:	f1c2 0203 	rsb	r2, r2, #3
                int rdo_offset = Lambda_Q10/2 - 512;
   114c4:	105b      	asrs	r3, r3, #1
                rd2_Q10 = silk_SMULBB(  q2_Q10, Lambda_Q10 );
   114c6:	4628      	mov	r0, r5
   114c8:	fb0c fc05 	mul.w	ip, ip, r5
            if( ( k & ( 3 - silk_LSHIFT( LSF_interpolation_flag, 1 ) ) ) == 0 ) {
   114cc:	607a      	str	r2, [r7, #4]
                rd2_Q10 = silk_SMULBB( q2_Q10, Lambda_Q10 );
   114ce:	f8d7 50c4 	ldr.w	r5, [r7, #196]	; 0xc4
                rd2_Q10 = silk_SMULBB(  q2_Q10, Lambda_Q10 );
   114d2:	f8c7 c0dc 	str.w	ip, [r7, #220]	; 0xdc
   114d6:	f1c1 0201 	rsb	r2, r1, #1
   114da:	623a      	str	r2, [r7, #32]
                int rdo_offset = Lambda_Q10/2 - 512;
   114dc:	f5a3 7200 	sub.w	r2, r3, #512	; 0x200
                rd2_Q10 = silk_SMULBB( q2_Q10, Lambda_Q10 );
   114e0:	fb15 f000 	smulbb	r0, r5, r0
                int rdo_offset = Lambda_Q10/2 - 512;
   114e4:	f8c7 213c 	str.w	r2, [r7, #316]	; 0x13c
                } else if (q1_Q10 < -rdo_offset) {
   114e8:	f5c3 7200 	rsb	r2, r3, #512	; 0x200
    for( k = 0; k < psEncC->nb_subfr; k++ ) {
   114ec:	2300      	movs	r3, #0
                rd2_Q10 = silk_SMULBB( q2_Q10, Lambda_Q10 );
   114ee:	f8c7 00c0 	str.w	r0, [r7, #192]	; 0xc0
                } else if (q1_Q10 < -rdo_offset) {
   114f2:	f8c7 20d0 	str.w	r2, [r7, #208]	; 0xd0
    for( k = 0; k < psEncC->nb_subfr; k++ ) {
   114f6:	67bb      	str	r3, [r7, #120]	; 0x78
    subfr = 0;
   114f8:	65fb      	str	r3, [r7, #92]	; 0x5c
   114fa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   114fc:	6b7d      	ldr	r5, [r7, #52]	; 0x34
   114fe:	f103 021c 	add.w	r2, r3, #28
   11502:	330c      	adds	r3, #12
   11504:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
   11508:	462b      	mov	r3, r5
   1150a:	f8d7 50e0 	ldr.w	r5, [r7, #224]	; 0xe0
   1150e:	63ba      	str	r2, [r7, #56]	; 0x38
   11510:	3314      	adds	r3, #20
   11512:	637b      	str	r3, [r7, #52]	; 0x34
   11514:	462b      	mov	r3, r5
   11516:	6d7d      	ldr	r5, [r7, #84]	; 0x54
   11518:	3310      	adds	r3, #16
   1151a:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
   1151e:	462b      	mov	r3, r5
   11520:	6cfd      	ldr	r5, [r7, #76]	; 0x4c
   11522:	330c      	adds	r3, #12
   11524:	657b      	str	r3, [r7, #84]	; 0x54
   11526:	462b      	mov	r3, r5
   11528:	6afd      	ldr	r5, [r7, #44]	; 0x2c
   1152a:	3318      	adds	r3, #24
   1152c:	64fb      	str	r3, [r7, #76]	; 0x4c
   1152e:	462b      	mov	r3, r5
   11530:	6b3d      	ldr	r5, [r7, #48]	; 0x30
   11532:	331c      	adds	r3, #28
   11534:	62fb      	str	r3, [r7, #44]	; 0x2c
   11536:	1d2b      	adds	r3, r5, #4
   11538:	633b      	str	r3, [r7, #48]	; 0x30
   1153a:	f8d7 3274 	ldr.w	r3, [r7, #628]	; 0x274
   1153e:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
   11542:	f504 5291 	add.w	r2, r4, #4640	; 0x1220
   11546:	f8d7 3270 	ldr.w	r3, [r7, #624]	; 0x270
   1154a:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
   1154e:	62ba      	str	r2, [r7, #40]	; 0x28
   11550:	f504 5392 	add.w	r3, r4, #4672	; 0x1240
   11554:	f506 62a0 	add.w	r2, r6, #1280	; 0x500
   11558:	6fbc      	ldr	r4, [r7, #120]	; 0x78
   1155a:	61fa      	str	r2, [r7, #28]
   1155c:	61bb      	str	r3, [r7, #24]
        HarmShapeFIRPacked_Q14  =                          silk_RSHIFT( HarmShapeGain_Q14[ k ], 2 );
   1155e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   11560:	f853 0f04 	ldr.w	r0, [r3, #4]!
   11564:	643b      	str	r3, [r7, #64]	; 0x40
        HarmShapeFIRPacked_Q14 |= silk_LSHIFT( (opus_int32)silk_RSHIFT( HarmShapeGain_Q14[ k ], 1 ), 16 );
   11566:	1042      	asrs	r2, r0, #1
        A_Q12      = &PredCoef_Q12[ ( ( k >> 1 ) | ( 1 - LSF_interpolation_flag ) ) * MAX_LPC_ORDER ];
   11568:	6a3b      	ldr	r3, [r7, #32]
        HarmShapeFIRPacked_Q14 |= silk_LSHIFT( (opus_int32)silk_RSHIFT( HarmShapeGain_Q14[ k ], 1 ), 16 );
   1156a:	0412      	lsls	r2, r2, #16
   1156c:	ea42 02a0 	orr.w	r2, r2, r0, asr #2
        A_Q12      = &PredCoef_Q12[ ( ( k >> 1 ) | ( 1 - LSF_interpolation_flag ) ) * MAX_LPC_ORDER ];
   11570:	4619      	mov	r1, r3
        HarmShapeFIRPacked_Q14 |= silk_LSHIFT( (opus_int32)silk_RSHIFT( HarmShapeGain_Q14[ k ], 1 ), 16 );
   11572:	f8c7 2088 	str.w	r2, [r7, #136]	; 0x88
        A_Q12      = &PredCoef_Q12[ ( ( k >> 1 ) | ( 1 - LSF_interpolation_flag ) ) * MAX_LPC_ORDER ];
   11576:	f8d7 226c 	ldr.w	r2, [r7, #620]	; 0x26c
   1157a:	ea41 0364 	orr.w	r3, r1, r4, asr #1
   1157e:	eb02 1343 	add.w	r3, r2, r3, lsl #5
   11582:	f8c7 3184 	str.w	r3, [r7, #388]	; 0x184
        NSQ->rewhite_flag = 0;
   11586:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   11588:	2100      	movs	r1, #0
   1158a:	6019      	str	r1, [r3, #0]
        if( psIndices->signalType == TYPE_VOICED ) {
   1158c:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
   11590:	2b02      	cmp	r3, #2
   11592:	f001 85e5 	beq.w	13160 <silk_NSQ_del_dec_c+0x1f24>
   11596:	f8d7 2288 	ldr.w	r2, [r7, #648]	; 0x288
   1159a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   1159c:	f852 9024 	ldr.w	r9, [r2, r4, lsl #2]
   115a0:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
   115a4:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
   115a8:	6812      	ldr	r2, [r2, #0]
   115aa:	f8c7 2190 	str.w	r2, [r7, #400]	; 0x190
   115ae:	3301      	adds	r3, #1
   115b0:	4688      	mov	r8, r1
   115b2:	65fb      	str	r3, [r7, #92]	; 0x5c
   115b4:	4622      	mov	r2, r4
    opus_int            i, k, lag;
    opus_int32          gain_adj_Q16, inv_gain_Q31, inv_gain_Q26;
    NSQ_del_dec_struct  *psDD;

    lag          = pitchL[ subfr ];
    inv_gain_Q31 = silk_INVERSE32_varQ( silk_max( Gains_Q16[ subfr ], 1 ), 47 );
   115b6:	f8d7 3284 	ldr.w	r3, [r7, #644]	; 0x284
   115ba:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   115be:	f8c7 3198 	str.w	r3, [r7, #408]	; 0x198
   115c2:	2b01      	cmp	r3, #1
   115c4:	bfb8      	it	lt
   115c6:	2301      	movlt	r3, #1
   115c8:	fab3 f183 	clz	r1, r3
        silk_nsq_del_dec_scale_states( psEncC, NSQ, psDelDec, x16, x_sc_Q10, sLTP, sLTP_Q15, k,
   115cc:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
   115ce:	3901      	subs	r1, #1
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                */
   115d0:	408b      	lsls	r3, r1
   115d2:	6812      	ldr	r2, [r2, #0]
   115d4:	f8c7 215c 	str.w	r2, [r7, #348]	; 0x15c
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm    */
   115d8:	f06f 4460 	mvn.w	r4, #3758096384	; 0xe0000000
   115dc:	141a      	asrs	r2, r3, #16
    err_Q32 = silk_LSHIFT( ((opus_int32)1<<29) - silk_SMULWB(b32_nrm, b32_inv), 3 );        /* Q32                        */
   115de:	b29b      	uxth	r3, r3
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm    */
   115e0:	fb94 f4f2 	sdiv	r4, r4, r2
    err_Q32 = silk_LSHIFT( ((opus_int32)1<<29) - silk_SMULWB(b32_nrm, b32_inv), 3 );        /* Q32                        */
   115e4:	b225      	sxth	r5, r4
   115e6:	fb05 f202 	mul.w	r2, r5, r2
   115ea:	fb05 f303 	mul.w	r3, r5, r3
   115ee:	eb02 4323 	add.w	r3, r2, r3, asr #16
   115f2:	f1c3 5300 	rsb	r3, r3, #536870912	; 0x20000000
   115f6:	00db      	lsls	r3, r3, #3
    result = silk_SMLAWW(result, err_Q32, b32_inv);                             /* Q: 61 - b_headrm            */
   115f8:	b29e      	uxth	r6, r3
   115fa:	141a      	asrs	r2, r3, #16
   115fc:	13e0      	asrs	r0, r4, #15
   115fe:	fb05 f606 	mul.w	r6, r5, r6
   11602:	fb05 f202 	mul.w	r2, r5, r2
   11606:	3001      	adds	r0, #1
   11608:	eb02 4226 	add.w	r2, r2, r6, asr #16
   1160c:	1040      	asrs	r0, r0, #1
   1160e:	eb02 4204 	add.w	r2, r2, r4, lsl #16
   11612:	fb03 2200 	mla	r2, r3, r0, r2
   11616:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    lshift = 61 - b_headrm - Qres;
   11618:	f1c1 010e 	rsb	r1, r1, #14
   1161c:	681b      	ldr	r3, [r3, #0]
   1161e:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
    if( lshift <= 0 ) {
   11622:	2900      	cmp	r1, #0
   11624:	f341 8587 	ble.w	13136 <silk_NSQ_del_dec_c+0x1efa>
            return silk_RSHIFT(result, lshift);
   11628:	fa42 f401 	asr.w	r4, r2, r1
   1162c:	461a      	mov	r2, r3
    silk_assert( inv_gain_Q31 != 0 );

    /* Scale input */
    inv_gain_Q26 = silk_RSHIFT_ROUND( inv_gain_Q31, 5 );
   1162e:	1123      	asrs	r3, r4, #4
   11630:	3301      	adds	r3, #1
    for( i = 0; i < psEncC->subfr_length; i++ ) {
   11632:	2a00      	cmp	r2, #0
    inv_gain_Q26 = silk_RSHIFT_ROUND( inv_gain_Q31, 5 );
   11634:	ea4f 0663 	mov.w	r6, r3, asr #1
    for( i = 0; i < psEncC->subfr_length; i++ ) {
   11638:	dd20      	ble.n	1167c <silk_NSQ_del_dec_c+0x440>
        x_sc_Q10[ i ] = silk_SMULWW( x16[ i ], inv_gain_Q26 );
   1163a:	141d      	asrs	r5, r3, #16
   1163c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   1163e:	eb03 0e42 	add.w	lr, r3, r2, lsl #1
   11642:	1e98      	subs	r0, r3, #2
   11644:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
   11646:	3501      	adds	r5, #1
   11648:	106d      	asrs	r5, r5, #1
   1164a:	b236      	sxth	r6, r6
   1164c:	f1ae 0e02 	sub.w	lr, lr, #2
   11650:	f1a3 0c04 	sub.w	ip, r3, #4
   11654:	f930 3f02 	ldrsh.w	r3, [r0, #2]!
   11658:	b299      	uxth	r1, r3
   1165a:	141a      	asrs	r2, r3, #16
   1165c:	fb06 f101 	mul.w	r1, r6, r1
   11660:	fb06 f202 	mul.w	r2, r6, r2
   11664:	eb02 4221 	add.w	r2, r2, r1, asr #16
   11668:	fb05 2303 	mla	r3, r5, r3, r2
    for( i = 0; i < psEncC->subfr_length; i++ ) {
   1166c:	4586      	cmp	lr, r0
        x_sc_Q10[ i ] = silk_SMULWW( x16[ i ], inv_gain_Q26 );
   1166e:	f84c 3f04 	str.w	r3, [ip, #4]!
    for( i = 0; i < psEncC->subfr_length; i++ ) {
   11672:	d1ef      	bne.n	11654 <silk_NSQ_del_dec_c+0x418>
   11674:	e002      	b.n	1167c <silk_NSQ_del_dec_c+0x440>
   11676:	bf00      	nop
   11678:	00036c88 	.word	0x00036c88
    }

    /* After rewhitening the LTP state is un-scaled, so scale with inv_gain_Q16 */
    if( NSQ->rewhite_flag ) {
   1167c:	f1b8 0f00 	cmp.w	r8, #0
   11680:	d032      	beq.n	116e8 <silk_NSQ_del_dec_c+0x4ac>
        if( subfr == 0 ) {
   11682:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   11684:	b95b      	cbnz	r3, 1169e <silk_NSQ_del_dec_c+0x462>
            /* Do LTP downscaling */
            inv_gain_Q31 = silk_LSHIFT( silk_SMULWB( inv_gain_Q31, LTP_scale_Q14 ), 2 );
   11686:	f8d7 3290 	ldr.w	r3, [r7, #656]	; 0x290
   1168a:	b2a2      	uxth	r2, r4
   1168c:	b21b      	sxth	r3, r3
   1168e:	1424      	asrs	r4, r4, #16
   11690:	fb03 f404 	mul.w	r4, r3, r4
   11694:	fb03 f202 	mul.w	r2, r3, r2
   11698:	eb04 4222 	add.w	r2, r4, r2, asr #16
   1169c:	0094      	lsls	r4, r2, #2
        }
        for( i = NSQ->sLTP_buf_idx - lag - LTP_ORDER / 2; i < NSQ->sLTP_buf_idx; i++ ) {
   1169e:	f8d7 2190 	ldr.w	r2, [r7, #400]	; 0x190
   116a2:	eba2 0009 	sub.w	r0, r2, r9
   116a6:	1e83      	subs	r3, r0, #2
   116a8:	4293      	cmp	r3, r2
   116aa:	da1d      	bge.n	116e8 <silk_NSQ_del_dec_c+0x4ac>
   116ac:	697b      	ldr	r3, [r7, #20]
   116ae:	f100 4100 	add.w	r1, r0, #2147483648	; 0x80000000
   116b2:	3903      	subs	r1, #3
   116b4:	1e9d      	subs	r5, r3, #2
   116b6:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
   116ba:	eb03 0141 	add.w	r1, r3, r1, lsl #1
   116be:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
   116c2:	3803      	subs	r0, #3
            silk_assert( i < MAX_FRAME_LENGTH );
            sLTP_Q15[ i ] = silk_SMULWB( inv_gain_Q31, sLTP[ i ] );
   116c4:	1426      	asrs	r6, r4, #16
   116c6:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   116ca:	eb05 0542 	add.w	r5, r5, r2, lsl #1
   116ce:	b2a4      	uxth	r4, r4
   116d0:	f931 3f02 	ldrsh.w	r3, [r1, #2]!
   116d4:	fb04 f203 	mul.w	r2, r4, r3
   116d8:	fb03 f306 	mul.w	r3, r3, r6
   116dc:	eb03 4322 	add.w	r3, r3, r2, asr #16
        for( i = NSQ->sLTP_buf_idx - lag - LTP_ORDER / 2; i < NSQ->sLTP_buf_idx; i++ ) {
   116e0:	428d      	cmp	r5, r1
            sLTP_Q15[ i ] = silk_SMULWB( inv_gain_Q31, sLTP[ i ] );
   116e2:	f840 3f04 	str.w	r3, [r0, #4]!
        for( i = NSQ->sLTP_buf_idx - lag - LTP_ORDER / 2; i < NSQ->sLTP_buf_idx; i++ ) {
   116e6:	d1f3      	bne.n	116d0 <silk_NSQ_del_dec_c+0x494>
   116e8:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
        }
    }

    /* Adjust for changing gain */
    if( Gains_Q16[ subfr ] != NSQ->prev_gain_Q16 ) {
   116ec:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   116ee:	6812      	ldr	r2, [r2, #0]
   116f0:	681b      	ldr	r3, [r3, #0]
   116f2:	f8c7 218c 	str.w	r2, [r7, #396]	; 0x18c
   116f6:	f8d7 2198 	ldr.w	r2, [r7, #408]	; 0x198
   116fa:	429a      	cmp	r2, r3
   116fc:	f000 8209 	beq.w	11b12 <silk_NSQ_del_dec_c+0x8d6>
   11700:	2b00      	cmp	r3, #0
   11702:	f001 8547 	beq.w	13194 <silk_NSQ_del_dec_c+0x1f58>
    a_headrm = silk_CLZ32( silk_abs(a32) ) - 1;
   11706:	ea83 71e3 	eor.w	r1, r3, r3, asr #31
   1170a:	eba1 71e3 	sub.w	r1, r1, r3, asr #31
   1170e:	fab1 f181 	clz	r1, r1
   11712:	1e4a      	subs	r2, r1, #1
   11714:	f101 061c 	add.w	r6, r1, #28
    a32_nrm = silk_LSHIFT(a32, a_headrm);                                       /* Q: a_headrm                  */
   11718:	4093      	lsls	r3, r2
   1171a:	f8d7 2198 	ldr.w	r2, [r7, #408]	; 0x198
   1171e:	2a00      	cmp	r2, #0
   11720:	f001 851b 	beq.w	1315a <silk_NSQ_del_dec_c+0x1f1e>
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
   11724:	2a00      	cmp	r2, #0
   11726:	bfb8      	it	lt
   11728:	4252      	neglt	r2, r2
   1172a:	fab2 f582 	clz	r5, r2
   1172e:	f8d7 2198 	ldr.w	r2, [r7, #408]	; 0x198
   11732:	3d01      	subs	r5, #1
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                  */
   11734:	fa02 f005 	lsl.w	r0, r2, r5
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   11738:	1402      	asrs	r2, r0, #16
   1173a:	f06f 4160 	mvn.w	r1, #3758096384	; 0xe0000000
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1173e:	141c      	asrs	r4, r3, #16
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   11740:	fb91 f2f2 	sdiv	r2, r1, r2
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   11744:	b299      	uxth	r1, r3
   11746:	b212      	sxth	r2, r2
   11748:	fb02 f101 	mul.w	r1, r2, r1
   1174c:	fb02 f404 	mul.w	r4, r2, r4
   11750:	eb04 4421 	add.w	r4, r4, r1, asr #16
    a32_nrm = silk_SUB32_ovflw(a32_nrm, silk_LSHIFT_ovflw( silk_SMMUL(b32_nrm, result), 3 ));  /* Q: a_headrm   */
   11754:	fb80 0104 	smull	r0, r1, r0, r4
   11758:	eba3 03c1 	sub.w	r3, r3, r1, lsl #3
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1175c:	b299      	uxth	r1, r3
   1175e:	141b      	asrs	r3, r3, #16
   11760:	fb02 f101 	mul.w	r1, r2, r1
   11764:	fb02 f303 	mul.w	r3, r2, r3
    lshift = 29 + a_headrm - b_headrm - Qres;
   11768:	1b75      	subs	r5, r6, r5
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1176a:	eb03 4321 	add.w	r3, r3, r1, asr #16
    if( lshift < 0 ) {
   1176e:	f1b5 0210 	subs.w	r2, r5, #16
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   11772:	4423      	add	r3, r4
    if( lshift < 0 ) {
   11774:	f101 8512 	bmi.w	1319c <silk_NSQ_del_dec_c+0x1f60>
        if( lshift < 32){
   11778:	2a1f      	cmp	r2, #31
            return silk_RSHIFT(result, lshift);
   1177a:	bfd4      	ite	le
   1177c:	4113      	asrle	r3, r2
            return 0;
   1177e:	2300      	movgt	r3, #0
        gain_adj_Q16 =  silk_DIV32_varQ( NSQ->prev_gain_Q16, Gains_Q16[ subfr ], 16 );

        /* Scale long-term shaping state */
        for( i = NSQ->sLTP_shp_buf_idx - psEncC->ltp_mem_length; i < NSQ->sLTP_shp_buf_idx; i++ ) {
   11780:	6e79      	ldr	r1, [r7, #100]	; 0x64
   11782:	f241 12f0 	movw	r2, #4592	; 0x11f0
   11786:	588a      	ldr	r2, [r1, r2]
   11788:	f8d7 118c 	ldr.w	r1, [r7, #396]	; 0x18c
   1178c:	1a8a      	subs	r2, r1, r2
   1178e:	428a      	cmp	r2, r1
   11790:	da23      	bge.n	117da <silk_NSQ_del_dec_c+0x59e>
   11792:	f8d7 00bc 	ldr.w	r0, [r7, #188]	; 0xbc
   11796:	f502 72a0 	add.w	r2, r2, #320	; 0x140
   1179a:	eb00 0482 	add.w	r4, r0, r2, lsl #2
   1179e:	69fa      	ldr	r2, [r7, #28]
            NSQ->sLTP_shp_Q14[ i ] = silk_SMULWW( gain_adj_Q16, NSQ->sLTP_shp_Q14[ i ] );
   117a0:	ea4f 4c23 	mov.w	ip, r3, asr #16
   117a4:	b29e      	uxth	r6, r3
   117a6:	eb02 0581 	add.w	r5, r2, r1, lsl #2
   117aa:	6822      	ldr	r2, [r4, #0]
   117ac:	b211      	sxth	r1, r2
   117ae:	13d2      	asrs	r2, r2, #15
   117b0:	fb06 f001 	mul.w	r0, r6, r1
   117b4:	3201      	adds	r2, #1
   117b6:	fb01 f10c 	mul.w	r1, r1, ip
   117ba:	1052      	asrs	r2, r2, #1
   117bc:	eb01 4120 	add.w	r1, r1, r0, asr #16
   117c0:	fb03 1202 	mla	r2, r3, r2, r1
   117c4:	f844 2b04 	str.w	r2, [r4], #4
        for( i = NSQ->sLTP_shp_buf_idx - psEncC->ltp_mem_length; i < NSQ->sLTP_shp_buf_idx; i++ ) {
   117c8:	42a5      	cmp	r5, r4
   117ca:	d1ee      	bne.n	117aa <silk_NSQ_del_dec_c+0x56e>
   117cc:	f8d7 2284 	ldr.w	r2, [r7, #644]	; 0x284
   117d0:	6fb9      	ldr	r1, [r7, #120]	; 0x78
   117d2:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
   117d6:	f8c7 2198 	str.w	r2, [r7, #408]	; 0x198
        }

        /* Scale long-term prediction state */
        if( signal_type == TYPE_VOICED && NSQ->rewhite_flag == 0 ) {
   117da:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
   117de:	2a02      	cmp	r2, #2
   117e0:	f001 84f0 	beq.w	131c4 <silk_NSQ_del_dec_c+0x1f88>
            for( i = NSQ->sLTP_buf_idx - lag - LTP_ORDER / 2; i < NSQ->sLTP_buf_idx - decisionDelay; i++ ) {
                sLTP_Q15[ i ] = silk_SMULWW( gain_adj_Q16, sLTP_Q15[ i ] );
            }
        }

        for( k = 0; k < nStatesDelayedDecision; k++ ) {
   117e4:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
   117e8:	2a00      	cmp	r2, #0
   117ea:	f340 8188 	ble.w	11afe <silk_NSQ_del_dec_c+0x8c2>
   117ee:	4611      	mov	r1, r2
   117f0:	f8d7 0144 	ldr.w	r0, [r7, #324]	; 0x144
   117f4:	460c      	mov	r4, r1
   117f6:	f240 5214 	movw	r2, #1300	; 0x514
   117fa:	fb02 0204 	mla	r2, r2, r4, r0
   117fe:	f8c7 219c 	str.w	r2, [r7, #412]	; 0x19c
            psDD = &psDelDec[ k ];

            /* Scale scalar states */
            psDD->LF_AR_Q14 = silk_SMULWW( gain_adj_Q16, psDD->LF_AR_Q14 );
   11802:	1419      	asrs	r1, r3, #16
   11804:	b29a      	uxth	r2, r3
   11806:	f500 7a7f 	add.w	sl, r0, #1020	; 0x3fc
   1180a:	f8d0 4500 	ldr.w	r4, [r0, #1280]	; 0x500
            psDD->Diff_Q14 = silk_SMULWW( gain_adj_Q16, psDD->Diff_Q14 );
   1180e:	f8d0 b504 	ldr.w	fp, [r0, #1284]	; 0x504

            /* Scale short-term prediction and shaping states */
            for( i = 0; i < NSQ_LPC_BUF_LENGTH; i++ ) {
                psDD->sLPC_Q14[ i ] = silk_SMULWW( gain_adj_Q16, psDD->sLPC_Q14[ i ] );
   11812:	6886      	ldr	r6, [r0, #8]
            psDD->LF_AR_Q14 = silk_SMULWW( gain_adj_Q16, psDD->LF_AR_Q14 );
   11814:	fa0f f984 	sxth.w	r9, r4
   11818:	ea4f 38e4 	mov.w	r8, r4, asr #15
   1181c:	f108 0801 	add.w	r8, r8, #1
   11820:	fb02 f409 	mul.w	r4, r2, r9
   11824:	fb09 f901 	mul.w	r9, r9, r1
                psDD->sLPC_Q14[ i ] = silk_SMULWW( gain_adj_Q16, psDD->sLPC_Q14[ i ] );
   11828:	e9d0 ec00 	ldrd	lr, ip, [r0]
            psDD->LF_AR_Q14 = silk_SMULWW( gain_adj_Q16, psDD->LF_AR_Q14 );
   1182c:	eb09 4924 	add.w	r9, r9, r4, asr #16
   11830:	ea4f 0868 	mov.w	r8, r8, asr #1
   11834:	fb03 9808 	mla	r8, r3, r8, r9
            psDD->Diff_Q14 = silk_SMULWW( gain_adj_Q16, psDD->Diff_Q14 );
   11838:	fa0f f98b 	sxth.w	r9, fp
   1183c:	ea4f 3beb 	mov.w	fp, fp, asr #15
            psDD->LF_AR_Q14 = silk_SMULWW( gain_adj_Q16, psDD->LF_AR_Q14 );
   11840:	f8c0 8500 	str.w	r8, [r0, #1280]	; 0x500
            psDD->Diff_Q14 = silk_SMULWW( gain_adj_Q16, psDD->Diff_Q14 );
   11844:	f10b 0b01 	add.w	fp, fp, #1
   11848:	fb02 f809 	mul.w	r8, r2, r9
   1184c:	fb09 f901 	mul.w	r9, r9, r1
   11850:	eb09 4928 	add.w	r9, r9, r8, asr #16
   11854:	ea4f 0b6b 	mov.w	fp, fp, asr #1
                psDD->sLPC_Q14[ i ] = silk_SMULWW( gain_adj_Q16, psDD->sLPC_Q14[ i ] );
   11858:	fa0f f88e 	sxth.w	r8, lr
   1185c:	ea4f 3eee 	mov.w	lr, lr, asr #15
            psDD->Diff_Q14 = silk_SMULWW( gain_adj_Q16, psDD->Diff_Q14 );
   11860:	fb03 9b0b 	mla	fp, r3, fp, r9
                psDD->sLPC_Q14[ i ] = silk_SMULWW( gain_adj_Q16, psDD->sLPC_Q14[ i ] );
   11864:	f10e 0e01 	add.w	lr, lr, #1
   11868:	fb02 f908 	mul.w	r9, r2, r8
   1186c:	fb01 f808 	mul.w	r8, r1, r8
   11870:	eb08 4829 	add.w	r8, r8, r9, asr #16
   11874:	ea4f 0e6e 	mov.w	lr, lr, asr #1
   11878:	fb03 8e0e 	mla	lr, r3, lr, r8
   1187c:	fa0f f98c 	sxth.w	r9, ip
   11880:	ea4f 3cec 	mov.w	ip, ip, asr #15
   11884:	f8c0 e000 	str.w	lr, [r0]
   11888:	f10c 0c01 	add.w	ip, ip, #1
   1188c:	fb02 fe09 	mul.w	lr, r2, r9
   11890:	fb09 f901 	mul.w	r9, r9, r1
   11894:	eb09 492e 	add.w	r9, r9, lr, asr #16
   11898:	ea4f 0c6c 	mov.w	ip, ip, asr #1
   1189c:	e9d0 5403 	ldrd	r5, r4, [r0, #12]
   118a0:	fb03 9c0c 	mla	ip, r3, ip, r9
   118a4:	fa0f f986 	sxth.w	r9, r6
   118a8:	13f6      	asrs	r6, r6, #15
   118aa:	f8c0 c004 	str.w	ip, [r0, #4]
   118ae:	3601      	adds	r6, #1
   118b0:	fb02 fc09 	mul.w	ip, r2, r9
   118b4:	fb09 f901 	mul.w	r9, r9, r1
   118b8:	eb09 492c 	add.w	r9, r9, ip, asr #16
   118bc:	1076      	asrs	r6, r6, #1
   118be:	fb03 9606 	mla	r6, r3, r6, r9
   118c2:	fa0f fc85 	sxth.w	ip, r5
   118c6:	13ed      	asrs	r5, r5, #15
   118c8:	6086      	str	r6, [r0, #8]
   118ca:	3501      	adds	r5, #1
   118cc:	fb02 f60c 	mul.w	r6, r2, ip
   118d0:	fb0c fc01 	mul.w	ip, ip, r1
   118d4:	eb0c 4c26 	add.w	ip, ip, r6, asr #16
   118d8:	106d      	asrs	r5, r5, #1
   118da:	fb03 c505 	mla	r5, r3, r5, ip
   118de:	b226      	sxth	r6, r4
   118e0:	60c5      	str	r5, [r0, #12]
   118e2:	13e4      	asrs	r4, r4, #15
   118e4:	fb02 f506 	mul.w	r5, r2, r6
   118e8:	fb06 f601 	mul.w	r6, r6, r1
   118ec:	eb06 4625 	add.w	r6, r6, r5, asr #16
   118f0:	3401      	adds	r4, #1
   118f2:	6945      	ldr	r5, [r0, #20]
   118f4:	f8d0 8018 	ldr.w	r8, [r0, #24]
   118f8:	f8d0 e01c 	ldr.w	lr, [r0, #28]
   118fc:	f8d0 9020 	ldr.w	r9, [r0, #32]
   11900:	f8d0 c024 	ldr.w	ip, [r0, #36]	; 0x24
            psDD->Diff_Q14 = silk_SMULWW( gain_adj_Q16, psDD->Diff_Q14 );
   11904:	f8c0 b504 	str.w	fp, [r0, #1284]	; 0x504
                psDD->sLPC_Q14[ i ] = silk_SMULWW( gain_adj_Q16, psDD->sLPC_Q14[ i ] );
   11908:	1064      	asrs	r4, r4, #1
   1190a:	fb03 6404 	mla	r4, r3, r4, r6
   1190e:	b22e      	sxth	r6, r5
   11910:	6945      	ldr	r5, [r0, #20]
   11912:	6104      	str	r4, [r0, #16]
   11914:	13ed      	asrs	r5, r5, #15
   11916:	fb02 f406 	mul.w	r4, r2, r6
   1191a:	3501      	adds	r5, #1
   1191c:	fb06 f601 	mul.w	r6, r6, r1
   11920:	eb06 4624 	add.w	r6, r6, r4, asr #16
   11924:	106d      	asrs	r5, r5, #1
   11926:	fb03 6505 	mla	r5, r3, r5, r6
   1192a:	fa0f f488 	sxth.w	r4, r8
   1192e:	ea4f 38e8 	mov.w	r8, r8, asr #15
   11932:	6145      	str	r5, [r0, #20]
   11934:	f108 0801 	add.w	r8, r8, #1
   11938:	fb02 f504 	mul.w	r5, r2, r4
   1193c:	fb04 f401 	mul.w	r4, r4, r1
   11940:	ea4f 0868 	mov.w	r8, r8, asr #1
   11944:	eb04 4425 	add.w	r4, r4, r5, asr #16
   11948:	fb03 4408 	mla	r4, r3, r8, r4
   1194c:	fa0f f88e 	sxth.w	r8, lr
   11950:	ea4f 3eee 	mov.w	lr, lr, asr #15
   11954:	6184      	str	r4, [r0, #24]
   11956:	f10e 0e01 	add.w	lr, lr, #1
   1195a:	fb02 f408 	mul.w	r4, r2, r8
   1195e:	fb08 f801 	mul.w	r8, r8, r1
   11962:	eb08 4824 	add.w	r8, r8, r4, asr #16
   11966:	ea4f 0e6e 	mov.w	lr, lr, asr #1
   1196a:	fb03 8e0e 	mla	lr, r3, lr, r8
   1196e:	fa0f f889 	sxth.w	r8, r9
   11972:	ea4f 39e9 	mov.w	r9, r9, asr #15
   11976:	f8c0 e01c 	str.w	lr, [r0, #28]
   1197a:	f109 0901 	add.w	r9, r9, #1
   1197e:	fb02 fe08 	mul.w	lr, r2, r8
   11982:	fb08 f801 	mul.w	r8, r8, r1
   11986:	eb08 482e 	add.w	r8, r8, lr, asr #16
   1198a:	ea4f 0969 	mov.w	r9, r9, asr #1
   1198e:	fb03 8909 	mla	r9, r3, r9, r8
   11992:	ea4f 3eec 	mov.w	lr, ip, asr #15
   11996:	fa0f f88c 	sxth.w	r8, ip
   1199a:	f8d0 b028 	ldr.w	fp, [r0, #40]	; 0x28
   1199e:	6ac6      	ldr	r6, [r0, #44]	; 0x2c
   119a0:	6b05      	ldr	r5, [r0, #48]	; 0x30
   119a2:	6b44      	ldr	r4, [r0, #52]	; 0x34
   119a4:	f8c0 9020 	str.w	r9, [r0, #32]
   119a8:	fb02 fc08 	mul.w	ip, r2, r8
   119ac:	f10e 0e01 	add.w	lr, lr, #1
   119b0:	fb08 f801 	mul.w	r8, r8, r1
   119b4:	eb08 482c 	add.w	r8, r8, ip, asr #16
   119b8:	ea4f 0e6e 	mov.w	lr, lr, asr #1
   119bc:	fb03 8e0e 	mla	lr, r3, lr, r8
   119c0:	ea4f 3ceb 	mov.w	ip, fp, asr #15
   119c4:	fa0f f88b 	sxth.w	r8, fp
   119c8:	f8c0 e024 	str.w	lr, [r0, #36]	; 0x24
   119cc:	f10c 0c01 	add.w	ip, ip, #1
   119d0:	fb02 fe08 	mul.w	lr, r2, r8
   119d4:	fb08 f801 	mul.w	r8, r8, r1
   119d8:	eb08 482e 	add.w	r8, r8, lr, asr #16
   119dc:	ea4f 0c6c 	mov.w	ip, ip, asr #1
   119e0:	fb03 8c0c 	mla	ip, r3, ip, r8
   119e4:	fa0f f886 	sxth.w	r8, r6
   119e8:	13f6      	asrs	r6, r6, #15
   119ea:	f8c0 c028 	str.w	ip, [r0, #40]	; 0x28
   119ee:	3601      	adds	r6, #1
   119f0:	fb02 fc08 	mul.w	ip, r2, r8
   119f4:	fb08 f801 	mul.w	r8, r8, r1
   119f8:	eb08 482c 	add.w	r8, r8, ip, asr #16
   119fc:	1076      	asrs	r6, r6, #1
   119fe:	fa0f fe85 	sxth.w	lr, r5
   11a02:	fb03 8606 	mla	r6, r3, r6, r8
   11a06:	fa0f fc84 	sxth.w	ip, r4
   11a0a:	62c6      	str	r6, [r0, #44]	; 0x2c
   11a0c:	13ed      	asrs	r5, r5, #15
   11a0e:	fb02 f60e 	mul.w	r6, r2, lr
   11a12:	13e4      	asrs	r4, r4, #15
   11a14:	fb0e fe01 	mul.w	lr, lr, r1
   11a18:	eb0e 4e26 	add.w	lr, lr, r6, asr #16
   11a1c:	3501      	adds	r5, #1
   11a1e:	fb02 f60c 	mul.w	r6, r2, ip
   11a22:	3401      	adds	r4, #1
   11a24:	fb0c fc01 	mul.w	ip, ip, r1
   11a28:	eb0c 4c26 	add.w	ip, ip, r6, asr #16
   11a2c:	106d      	asrs	r5, r5, #1
   11a2e:	1064      	asrs	r4, r4, #1
   11a30:	fb03 e505 	mla	r5, r3, r5, lr
   11a34:	fb03 c404 	mla	r4, r3, r4, ip
   11a38:	e9c0 540c 	strd	r5, r4, [r0, #48]	; 0x30
   11a3c:	e9d0 640e 	ldrd	r6, r4, [r0, #56]	; 0x38
   11a40:	b235      	sxth	r5, r6
   11a42:	13f6      	asrs	r6, r6, #15
   11a44:	3601      	adds	r6, #1
   11a46:	ea4f 0e66 	mov.w	lr, r6, asr #1
   11a4a:	13e6      	asrs	r6, r4, #15
   11a4c:	fb02 fc05 	mul.w	ip, r2, r5
   11a50:	fa0f f884 	sxth.w	r8, r4
   11a54:	3601      	adds	r6, #1
   11a56:	fb05 f501 	mul.w	r5, r5, r1
   11a5a:	eb05 452c 	add.w	r5, r5, ip, asr #16
   11a5e:	fb08 f401 	mul.w	r4, r8, r1
   11a62:	ea4f 0c66 	mov.w	ip, r6, asr #1
   11a66:	fb02 f608 	mul.w	r6, r2, r8
   11a6a:	eb04 4426 	add.w	r4, r4, r6, asr #16
   11a6e:	fb03 440c 	mla	r4, r3, ip, r4
   11a72:	fb03 550e 	mla	r5, r3, lr, r5
   11a76:	e9c0 540e 	strd	r5, r4, [r0, #56]	; 0x38
   11a7a:	f200 469c 	addw	r6, r0, #1180	; 0x49c
   11a7e:	f200 4cfc 	addw	ip, r0, #1276	; 0x4fc
            }
            for( i = 0; i < MAX_SHAPE_LPC_ORDER; i++ ) {
                psDD->sAR2_Q14[ i ] = silk_SMULWW( gain_adj_Q16, psDD->sAR2_Q14[ i ] );
   11a82:	f856 4f04 	ldr.w	r4, [r6, #4]!
   11a86:	b225      	sxth	r5, r4
   11a88:	13e4      	asrs	r4, r4, #15
   11a8a:	fb02 fe05 	mul.w	lr, r2, r5
   11a8e:	3401      	adds	r4, #1
   11a90:	fb05 f501 	mul.w	r5, r5, r1
   11a94:	1064      	asrs	r4, r4, #1
   11a96:	eb05 452e 	add.w	r5, r5, lr, asr #16
   11a9a:	fb03 5404 	mla	r4, r3, r4, r5
            for( i = 0; i < MAX_SHAPE_LPC_ORDER; i++ ) {
   11a9e:	45b4      	cmp	ip, r6
                psDD->sAR2_Q14[ i ] = silk_SMULWW( gain_adj_Q16, psDD->sAR2_Q14[ i ] );
   11aa0:	6034      	str	r4, [r6, #0]
            for( i = 0; i < MAX_SHAPE_LPC_ORDER; i++ ) {
   11aa2:	d1ee      	bne.n	11a82 <silk_NSQ_del_dec_c+0x846>
   11aa4:	f500 7657 	add.w	r6, r0, #860	; 0x35c
   11aa8:	46d4      	mov	ip, sl
            }
            for( i = 0; i < DECISION_DELAY; i++ ) {
                psDD->Pred_Q15[  i ] = silk_SMULWW( gain_adj_Q16, psDD->Pred_Q15[  i ] );
   11aaa:	f856 4f04 	ldr.w	r4, [r6, #4]!
   11aae:	b225      	sxth	r5, r4
   11ab0:	13e4      	asrs	r4, r4, #15
   11ab2:	fb02 fe05 	mul.w	lr, r2, r5
   11ab6:	3401      	adds	r4, #1
   11ab8:	fb05 f501 	mul.w	r5, r5, r1
   11abc:	eb05 452e 	add.w	r5, r5, lr, asr #16
   11ac0:	1064      	asrs	r4, r4, #1
   11ac2:	fb03 5404 	mla	r4, r3, r4, r5
   11ac6:	6034      	str	r4, [r6, #0]
                psDD->Shape_Q14[ i ] = silk_SMULWW( gain_adj_Q16, psDD->Shape_Q14[ i ] );
   11ac8:	f85c 4f04 	ldr.w	r4, [ip, #4]!
   11acc:	b225      	sxth	r5, r4
   11ace:	13e4      	asrs	r4, r4, #15
   11ad0:	fb02 fe05 	mul.w	lr, r2, r5
   11ad4:	3401      	adds	r4, #1
   11ad6:	fb05 f501 	mul.w	r5, r5, r1
   11ada:	1064      	asrs	r4, r4, #1
   11adc:	eb05 452e 	add.w	r5, r5, lr, asr #16
   11ae0:	fb03 5404 	mla	r4, r3, r4, r5
            for( i = 0; i < DECISION_DELAY; i++ ) {
   11ae4:	45b2      	cmp	sl, r6
                psDD->Shape_Q14[ i ] = silk_SMULWW( gain_adj_Q16, psDD->Shape_Q14[ i ] );
   11ae6:	f8cc 4000 	str.w	r4, [ip]
            for( i = 0; i < DECISION_DELAY; i++ ) {
   11aea:	d1de      	bne.n	11aaa <silk_NSQ_del_dec_c+0x86e>
        for( k = 0; k < nStatesDelayedDecision; k++ ) {
   11aec:	f8d7 419c 	ldr.w	r4, [r7, #412]	; 0x19c
   11af0:	f200 5014 	addw	r0, r0, #1300	; 0x514
   11af4:	4284      	cmp	r4, r0
   11af6:	f20a 5a14 	addw	sl, sl, #1300	; 0x514
   11afa:	f47f ae86 	bne.w	1180a <silk_NSQ_del_dec_c+0x5ce>
            }
        }

        /* Save inverse gain */
        NSQ->prev_gain_Q16 = Gains_Q16[ subfr ];
   11afe:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   11b00:	461a      	mov	r2, r3
   11b02:	f8d7 3198 	ldr.w	r3, [r7, #408]	; 0x198
   11b06:	6013      	str	r3, [r2, #0]
   11b08:	f8d7 3284 	ldr.w	r3, [r7, #644]	; 0x284
   11b0c:	6fba      	ldr	r2, [r7, #120]	; 0x78
   11b0e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    ALLOC( psSampleState, nStatesDelayedDecision, NSQ_sample_pair );
   11b12:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
    shp_lag_ptr  = &NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx - lag + HARM_SHAPE_FIR_TAPS / 2 ];
   11b16:	f8d7 118c 	ldr.w	r1, [r7, #396]	; 0x18c
{
   11b1a:	f8c7 d03c 	str.w	sp, [r7, #60]	; 0x3c
    ALLOC( psSampleState, nStatesDelayedDecision, NSQ_sample_pair );
   11b1e:	ebc2 00c2 	rsb	r0, r2, r2, lsl #3
   11b22:	00c0      	lsls	r0, r0, #3
    shp_lag_ptr  = &NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx - lag + HARM_SHAPE_FIR_TAPS / 2 ];
   11b24:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
    pred_lag_ptr = &sLTP_Q15[ NSQ->sLTP_buf_idx - lag + LTP_ORDER / 2 ];
   11b28:	f8d7 4190 	ldr.w	r4, [r7, #400]	; 0x190
    ALLOC( psSampleState, nStatesDelayedDecision, NSQ_sample_pair );
   11b2c:	3008      	adds	r0, #8
    shp_lag_ptr  = &NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx - lag + HARM_SHAPE_FIR_TAPS / 2 ];
   11b2e:	1a89      	subs	r1, r1, r2
    ALLOC( psSampleState, nStatesDelayedDecision, NSQ_sample_pair );
   11b30:	ebad 0d00 	sub.w	sp, sp, r0
    shp_lag_ptr  = &NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx - lag + HARM_SHAPE_FIR_TAPS / 2 ];
   11b34:	f8d7 00bc 	ldr.w	r0, [r7, #188]	; 0xbc
   11b38:	f201 1141 	addw	r1, r1, #321	; 0x141
   11b3c:	eb00 0181 	add.w	r1, r0, r1, lsl #2
    Gain_Q10     = silk_RSHIFT( Gain_Q16, 6 );
   11b40:	119b      	asrs	r3, r3, #6
    pred_lag_ptr = &sLTP_Q15[ NSQ->sLTP_buf_idx - lag + LTP_ORDER / 2 ];
   11b42:	1aa2      	subs	r2, r4, r2
    shp_lag_ptr  = &NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx - lag + HARM_SHAPE_FIR_TAPS / 2 ];
   11b44:	f8c7 10c8 	str.w	r1, [r7, #200]	; 0xc8
    Gain_Q10     = silk_RSHIFT( Gain_Q16, 6 );
   11b48:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
    pred_lag_ptr = &sLTP_Q15[ NSQ->sLTP_buf_idx - lag + LTP_ORDER / 2 ];
   11b4c:	f8d7 10a0 	ldr.w	r1, [r7, #160]	; 0xa0
    ALLOC( psSampleState, nStatesDelayedDecision, NSQ_sample_pair );
   11b50:	ab02      	add	r3, sp, #8
    pred_lag_ptr = &sLTP_Q15[ NSQ->sLTP_buf_idx - lag + LTP_ORDER / 2 ];
   11b52:	3202      	adds	r2, #2
    ALLOC( psSampleState, nStatesDelayedDecision, NSQ_sample_pair );
   11b54:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158
        silk_noise_shape_quantizer_del_dec( NSQ, psDelDec, psIndices->signalType, x_sc_Q10, pulses, pxq, sLTP_Q15,
   11b58:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    pred_lag_ptr = &sLTP_Q15[ NSQ->sLTP_buf_idx - lag + LTP_ORDER / 2 ];
   11b5a:	eb01 0282 	add.w	r2, r1, r2, lsl #2
   11b5e:	f8c7 2084 	str.w	r2, [r7, #132]	; 0x84
        silk_noise_shape_quantizer_del_dec( NSQ, psDelDec, psIndices->signalType, x_sc_Q10, pulses, pxq, sLTP_Q15,
   11b62:	461a      	mov	r2, r3
   11b64:	f852 3f04 	ldr.w	r3, [r2, #4]!
   11b68:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
   11b6c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   11b6e:	647a      	str	r2, [r7, #68]	; 0x44
   11b70:	f853 1f04 	ldr.w	r1, [r3, #4]!
   11b74:	64bb      	str	r3, [r7, #72]	; 0x48
   11b76:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   11b78:	f8c7 1094 	str.w	r1, [r7, #148]	; 0x94
   11b7c:	681a      	ldr	r2, [r3, #0]
   11b7e:	6abb      	ldr	r3, [r7, #40]	; 0x28
   11b80:	f8c7 2174 	str.w	r2, [r7, #372]	; 0x174
   11b84:	6818      	ldr	r0, [r3, #0]
   11b86:	69bb      	ldr	r3, [r7, #24]
   11b88:	f8c7 016c 	str.w	r0, [r7, #364]	; 0x16c
   11b8c:	681b      	ldr	r3, [r3, #0]
   11b8e:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
    for( i = 0; i < length; i++ ) {
   11b92:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
   11b96:	2b00      	cmp	r3, #0
   11b98:	f340 8602 	ble.w	127a0 <silk_NSQ_del_dec_c+0x1564>
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp1, AR_shp_Q13[ shapingLPCOrder - 1 ] );
   11b9c:	f102 4300 	add.w	r3, r2, #2147483648	; 0x80000000
   11ba0:	f8d7 4170 	ldr.w	r4, [r7, #368]	; 0x170
   11ba4:	3b01      	subs	r3, #1
   11ba6:	eb04 0343 	add.w	r3, r4, r3, lsl #1
   11baa:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
            n_LTP_Q14 = silk_SMLAWT( n_LTP_Q14, shp_lag_ptr[ -1 ],                      HarmShapeFIRPacked_Q14 );
   11bae:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
   11bb2:	141b      	asrs	r3, r3, #16
   11bb4:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
    out = silk_RSHIFT( order, 1 );
   11bb8:	1043      	asrs	r3, r0, #1
   11bba:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
            n_AR_Q14 = silk_RSHIFT( shapingLPCOrder, 1 );
   11bbe:	1053      	asrs	r3, r2, #1
   11bc0:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168
            n_LF_Q14 = silk_SMLAWT( n_LF_Q14, psDD->LF_AR_Q14, LF_shp_Q14 );            /* Q12 */
   11bc4:	140b      	asrs	r3, r1, #16
   11bc6:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
   11bca:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
   11bce:	2b00      	cmp	r3, #0
   11bd0:	f300 8640 	bgt.w	12854 <silk_NSQ_del_dec_c+0x1618>
   11bd4:	2300      	movs	r3, #0
   11bd6:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
   11bda:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
   11bde:	1eda      	subs	r2, r3, #3
   11be0:	3b01      	subs	r3, #1
   11be2:	f8c7 20a4 	str.w	r2, [r7, #164]	; 0xa4
   11be6:	65bb      	str	r3, [r7, #88]	; 0x58
   11be8:	f8d7 60f0 	ldr.w	r6, [r7, #240]	; 0xf0
   11bec:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
   11bf0:	4633      	mov	r3, r6
   11bf2:	330f      	adds	r3, #15
   11bf4:	0099      	lsls	r1, r3, #2
   11bf6:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
   11bfa:	ebc6 7386 	rsb	r3, r6, r6, lsl #30
   11bfe:	f240 5514 	movw	r5, #1300	; 0x514
   11c02:	009b      	lsls	r3, r3, #2
   11c04:	0854      	lsrs	r4, r2, #1
   11c06:	442b      	add	r3, r5
   11c08:	00e4      	lsls	r4, r4, #3
   11c0a:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
   11c0e:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
   11c12:	f106 0310 	add.w	r3, r6, #16
   11c16:	677c      	str	r4, [r7, #116]	; 0x74
   11c18:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
   11c1c:	6dbc      	ldr	r4, [r7, #88]	; 0x58
   11c1e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   11c20:	1ab2      	subs	r2, r6, r2
   11c22:	00a4      	lsls	r4, r4, #2
   11c24:	eb03 0342 	add.w	r3, r3, r2, lsl #1
   11c28:	f8c7 40f4 	str.w	r4, [r7, #244]	; 0xf4
   11c2c:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
   11c30:	6ffc      	ldr	r4, [r7, #124]	; 0x7c
   11c32:	f8d7 3268 	ldr.w	r3, [r7, #616]	; 0x268
   11c36:	f1a1 003c 	sub.w	r0, r1, #60	; 0x3c
   11c3a:	1820      	adds	r0, r4, r0
   11c3c:	4413      	add	r3, r2
   11c3e:	f8c7 00d4 	str.w	r0, [r7, #212]	; 0xd4
   11c42:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
   11c46:	f8d7 0144 	ldr.w	r0, [r7, #324]	; 0x144
   11c4a:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
   11c4e:	fb05 0303 	mla	r3, r5, r3, r0
   11c52:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
        if( signalType == TYPE_VOICED ) {
   11c56:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
   11c5a:	1841      	adds	r1, r0, r1
   11c5c:	2b02      	cmp	r3, #2
   11c5e:	f8c7 10d8 	str.w	r1, [r7, #216]	; 0xd8
   11c62:	f000 8403 	beq.w	1246c <silk_NSQ_del_dec_c+0x1230>
            LTP_pred_Q14 = 0;
   11c66:	2300      	movs	r3, #0
   11c68:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
        if( lag > 0 ) {
   11c6c:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
   11c70:	2b00      	cmp	r3, #0
   11c72:	f340 8450 	ble.w	12516 <silk_NSQ_del_dec_c+0x12da>
            n_LTP_Q14 = silk_SMULWB( silk_ADD32( shp_lag_ptr[ 0 ], shp_lag_ptr[ -2 ] ), HarmShapeFIRPacked_Q14 );
   11c76:	f8d7 40c8 	ldr.w	r4, [r7, #200]	; 0xc8
            n_LTP_Q14 = silk_SMLAWT( n_LTP_Q14, shp_lag_ptr[ -1 ],                      HarmShapeFIRPacked_Q14 );
   11c7a:	e954 3101 	ldrd	r3, r1, [r4, #-4]
            n_LTP_Q14 = silk_SMULWB( silk_ADD32( shp_lag_ptr[ 0 ], shp_lag_ptr[ -2 ] ), HarmShapeFIRPacked_Q14 );
   11c7e:	f854 2c08 	ldr.w	r2, [r4, #-8]
   11c82:	440a      	add	r2, r1
   11c84:	1411      	asrs	r1, r2, #16
   11c86:	b290      	uxth	r0, r2
   11c88:	f9b7 2088 	ldrsh.w	r2, [r7, #136]	; 0x88
   11c8c:	fb02 f000 	mul.w	r0, r2, r0
   11c90:	fb02 f201 	mul.w	r2, r2, r1
   11c94:	eb02 4220 	add.w	r2, r2, r0, asr #16
            n_LTP_Q14 = silk_SMLAWT( n_LTP_Q14, shp_lag_ptr[ -1 ],                      HarmShapeFIRPacked_Q14 );
   11c98:	f8d7 0080 	ldr.w	r0, [r7, #128]	; 0x80
   11c9c:	1419      	asrs	r1, r3, #16
   11c9e:	b29b      	uxth	r3, r3
   11ca0:	fb00 2201 	mla	r2, r0, r1, r2
   11ca4:	fb00 f303 	mul.w	r3, r0, r3
   11ca8:	eb02 4323 	add.w	r3, r2, r3, asr #16
            shp_lag_ptr++;
   11cac:	1d22      	adds	r2, r4, #4
   11cae:	f8c7 20c8 	str.w	r2, [r7, #200]	; 0xc8
            n_LTP_Q14 = silk_SUB_LSHIFT32( LTP_pred_Q14, n_LTP_Q14, 2 );            /* Q12 -> Q14 */
   11cb2:	f8d7 2180 	ldr.w	r2, [r7, #384]	; 0x180
   11cb6:	eba2 0383 	sub.w	r3, r2, r3, lsl #2
   11cba:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
        for( k = 0; k < nStatesDelayedDecision; k++ ) {
   11cbe:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
   11cc2:	2b00      	cmp	r3, #0
   11cc4:	f340 829e 	ble.w	12204 <silk_NSQ_del_dec_c+0xfc8>
   11cc8:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
   11ccc:	f9b7 9090 	ldrsh.w	r9, [r7, #144]	; 0x90
   11cd0:	6819      	ldr	r1, [r3, #0]
    out = silk_SMLAWB( out, buf32[  0 ], coef16[ 0 ] );
   11cd2:	f8d7 3184 	ldr.w	r3, [r7, #388]	; 0x184
   11cd6:	f8c7 1128 	str.w	r1, [r7, #296]	; 0x128
   11cda:	f9b3 2000 	ldrsh.w	r2, [r3]
   11cde:	f8c7 20f8 	str.w	r2, [r7, #248]	; 0xf8
    out = silk_SMLAWB( out, buf32[ -1 ], coef16[ 1 ] );
   11ce2:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
   11ce6:	f8c7 20fc 	str.w	r2, [r7, #252]	; 0xfc
    out = silk_SMLAWB( out, buf32[ -2 ], coef16[ 2 ] );
   11cea:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
   11cee:	f8c7 2100 	str.w	r2, [r7, #256]	; 0x100
    out = silk_SMLAWB( out, buf32[ -3 ], coef16[ 3 ] );
   11cf2:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
   11cf6:	f8c7 2104 	str.w	r2, [r7, #260]	; 0x104
    out = silk_SMLAWB( out, buf32[ -4 ], coef16[ 4 ] );
   11cfa:	f9b3 2008 	ldrsh.w	r2, [r3, #8]
   11cfe:	f8c7 2108 	str.w	r2, [r7, #264]	; 0x108
    out = silk_SMLAWB( out, buf32[ -5 ], coef16[ 5 ] );
   11d02:	f9b3 200a 	ldrsh.w	r2, [r3, #10]
   11d06:	f8c7 210c 	str.w	r2, [r7, #268]	; 0x10c
    out = silk_SMLAWB( out, buf32[ -6 ], coef16[ 6 ] );
   11d0a:	f9b3 200c 	ldrsh.w	r2, [r3, #12]
   11d0e:	f8c7 2110 	str.w	r2, [r7, #272]	; 0x110
    out = silk_SMLAWB( out, buf32[ -7 ], coef16[ 7 ] );
   11d12:	f9b3 200e 	ldrsh.w	r2, [r3, #14]
   11d16:	f8c7 2114 	str.w	r2, [r7, #276]	; 0x114
    out = silk_SMLAWB( out, buf32[ -8 ], coef16[ 8 ] );
   11d1a:	f9b3 2010 	ldrsh.w	r2, [r3, #16]
    out = silk_SMLAWB( out, buf32[ -9 ], coef16[ 9 ] );
   11d1e:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
   11d22:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp2, AR_shp_Q13[ 0 ] );
   11d26:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
    out = silk_SMLAWB( out, buf32[ -8 ], coef16[ 8 ] );
   11d2a:	f8c7 2118 	str.w	r2, [r7, #280]	; 0x118
   11d2e:	f9b3 3000 	ldrsh.w	r3, [r3]
   11d32:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178
   11d36:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
   11d3a:	f9b3 3000 	ldrsh.w	r3, [r3]
   11d3e:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
            psSS[ 0 ].Diff_Q14     = silk_SUB_LSHIFT32( xq_Q14, x_Q10[ i ], 4 );
   11d42:	010b      	lsls	r3, r1, #4
   11d44:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
   11d48:	f9b7 3098 	ldrsh.w	r3, [r7, #152]	; 0x98
   11d4c:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
   11d50:	f9b7 3094 	ldrsh.w	r3, [r7, #148]	; 0x94
   11d54:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
   11d58:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
   11d5c:	f8c7 3198 	str.w	r3, [r7, #408]	; 0x198
   11d60:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
   11d64:	f8d7 a0d8 	ldr.w	sl, [r7, #216]	; 0xd8
   11d68:	f8d7 b144 	ldr.w	fp, [r7, #324]	; 0x144
   11d6c:	009b      	lsls	r3, r3, #2
   11d6e:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
   11d72:	6f7b      	ldr	r3, [r7, #116]	; 0x74
   11d74:	3308      	adds	r3, #8
   11d76:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
   11d7a:	46c8      	mov	r8, r9
            psDD->Seed = silk_RAND( psDD->Seed );
   11d7c:	f8db 3508 	ldr.w	r3, [fp, #1288]	; 0x508
   11d80:	4ae6      	ldr	r2, [pc, #920]	; (1211c <silk_NSQ_del_dec_c+0xee0>)
   11d82:	49e7      	ldr	r1, [pc, #924]	; (12120 <silk_NSQ_del_dec_c+0xee4>)
    out = silk_SMLAWB( out, buf32[ -2 ], coef16[ 2 ] );
   11d84:	f8d7 5100 	ldr.w	r5, [r7, #256]	; 0x100
   11d88:	fb02 1303 	mla	r3, r2, r3, r1
   11d8c:	f8cb 3508 	str.w	r3, [fp, #1288]	; 0x508
   11d90:	f8c7 318c 	str.w	r3, [r7, #396]	; 0x18c
    out = silk_SMLAWB( out, buf32[  0 ], coef16[ 0 ] );
   11d94:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
   11d98:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
   11d9c:	f85b 4023 	ldr.w	r4, [fp, r3, lsl #2]
    out = silk_SMLAWB( out, buf32[ -2 ], coef16[ 2 ] );
   11da0:	e95a 1002 	ldrd	r1, r0, [sl, #-8]
    out = silk_SMLAWB( out, buf32[  0 ], coef16[ 0 ] );
   11da4:	b2a3      	uxth	r3, r4
   11da6:	1424      	asrs	r4, r4, #16
   11da8:	fb02 f303 	mul.w	r3, r2, r3
   11dac:	fb02 f404 	mul.w	r4, r2, r4
    out = silk_SMLAWB( out, buf32[ -1 ], coef16[ 1 ] );
   11db0:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
    out = silk_SMLAWB( out, buf32[  0 ], coef16[ 0 ] );
   11db4:	eb04 4423 	add.w	r4, r4, r3, asr #16
    out = silk_SMLAWB( out, buf32[ -1 ], coef16[ 1 ] );
   11db8:	b283      	uxth	r3, r0
   11dba:	1400      	asrs	r0, r0, #16
   11dbc:	fb02 f303 	mul.w	r3, r2, r3
   11dc0:	fb02 f000 	mul.w	r0, r2, r0
    out = silk_SMLAWB( out, buf32[  0 ], coef16[ 0 ] );
   11dc4:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
    out = silk_SMLAWB( out, buf32[ -1 ], coef16[ 1 ] );
   11dc8:	eb00 4023 	add.w	r0, r0, r3, asr #16
    out = silk_SMLAWB( out, buf32[  0 ], coef16[ 0 ] );
   11dcc:	4414      	add	r4, r2
    out = silk_SMLAWB( out, buf32[ -1 ], coef16[ 1 ] );
   11dce:	4420      	add	r0, r4
    out = silk_SMLAWB( out, buf32[ -4 ], coef16[ 4 ] );
   11dd0:	e95a 3204 	ldrd	r3, r2, [sl, #-16]
    out = silk_SMLAWB( out, buf32[ -2 ], coef16[ 2 ] );
   11dd4:	b28c      	uxth	r4, r1
   11dd6:	1409      	asrs	r1, r1, #16
   11dd8:	fb05 f404 	mul.w	r4, r5, r4
   11ddc:	fb05 f101 	mul.w	r1, r5, r1
   11de0:	eb01 4124 	add.w	r1, r1, r4, asr #16
    out = silk_SMLAWB( out, buf32[ -3 ], coef16[ 3 ] );
   11de4:	f8d7 4104 	ldr.w	r4, [r7, #260]	; 0x104
    out = silk_SMLAWB( out, buf32[ -2 ], coef16[ 2 ] );
   11de8:	4408      	add	r0, r1
    out = silk_SMLAWB( out, buf32[ -3 ], coef16[ 3 ] );
   11dea:	b291      	uxth	r1, r2
   11dec:	1412      	asrs	r2, r2, #16
   11dee:	fb04 f202 	mul.w	r2, r4, r2
   11df2:	fb04 f101 	mul.w	r1, r4, r1
   11df6:	eb02 4521 	add.w	r5, r2, r1, asr #16
   11dfa:	182a      	adds	r2, r5, r0
    out = silk_SMLAWB( out, buf32[ -4 ], coef16[ 4 ] );
   11dfc:	f8d7 5108 	ldr.w	r5, [r7, #264]	; 0x108
   11e00:	b298      	uxth	r0, r3
   11e02:	141b      	asrs	r3, r3, #16
    out = silk_SMLAWB( out, buf32[ -6 ], coef16[ 6 ] );
   11e04:	e95a 1406 	ldrd	r1, r4, [sl, #-24]
    out = silk_SMLAWB( out, buf32[ -4 ], coef16[ 4 ] );
   11e08:	fb05 f303 	mul.w	r3, r5, r3
   11e0c:	fb05 f000 	mul.w	r0, r5, r0
   11e10:	eb03 4020 	add.w	r0, r3, r0, asr #16
   11e14:	1885      	adds	r5, r0, r2
    out = silk_SMLAWB( out, buf32[ -5 ], coef16[ 5 ] );
   11e16:	f8d7 210c 	ldr.w	r2, [r7, #268]	; 0x10c
   11e1a:	b2a3      	uxth	r3, r4
   11e1c:	1424      	asrs	r4, r4, #16
   11e1e:	fb02 f004 	mul.w	r0, r2, r4
   11e22:	fb02 f303 	mul.w	r3, r2, r3
   11e26:	eb00 4023 	add.w	r0, r0, r3, asr #16
   11e2a:	4428      	add	r0, r5
    out = silk_SMLAWB( out, buf32[ -6 ], coef16[ 6 ] );
   11e2c:	f8d7 5110 	ldr.w	r5, [r7, #272]	; 0x110
    out = silk_SMLAWB( out, buf32[ -8 ], coef16[ 8 ] );
   11e30:	e95a 3208 	ldrd	r3, r2, [sl, #-32]
    out = silk_SMLAWB( out, buf32[ -6 ], coef16[ 6 ] );
   11e34:	b28c      	uxth	r4, r1
   11e36:	1409      	asrs	r1, r1, #16
   11e38:	fb05 f404 	mul.w	r4, r5, r4
   11e3c:	fb05 f101 	mul.w	r1, r5, r1
   11e40:	eb01 4124 	add.w	r1, r1, r4, asr #16
    out = silk_SMLAWB( out, buf32[ -7 ], coef16[ 7 ] );
   11e44:	f8d7 4114 	ldr.w	r4, [r7, #276]	; 0x114
    out = silk_SMLAWB( out, buf32[ -9 ], coef16[ 9 ] );
   11e48:	f85a 5c24 	ldr.w	r5, [sl, #-36]
    out = silk_SMLAWB( out, buf32[ -6 ], coef16[ 6 ] );
   11e4c:	4408      	add	r0, r1
    out = silk_SMLAWB( out, buf32[ -7 ], coef16[ 7 ] );
   11e4e:	b291      	uxth	r1, r2
   11e50:	1412      	asrs	r2, r2, #16
   11e52:	fb04 f202 	mul.w	r2, r4, r2
   11e56:	fb04 f101 	mul.w	r1, r4, r1
   11e5a:	eb02 4121 	add.w	r1, r2, r1, asr #16
   11e5e:	4408      	add	r0, r1
    out = silk_SMLAWB( out, buf32[ -8 ], coef16[ 8 ] );
   11e60:	f8d7 1118 	ldr.w	r1, [r7, #280]	; 0x118
   11e64:	b29a      	uxth	r2, r3
   11e66:	141b      	asrs	r3, r3, #16
   11e68:	fb01 f202 	mul.w	r2, r1, r2
   11e6c:	fb01 f303 	mul.w	r3, r1, r3
    out = silk_SMLAWB( out, buf32[ -9 ], coef16[ 9 ] );
   11e70:	f8d7 111c 	ldr.w	r1, [r7, #284]	; 0x11c
    out = silk_SMLAWB( out, buf32[ -8 ], coef16[ 8 ] );
   11e74:	eb03 4322 	add.w	r3, r3, r2, asr #16
    out = silk_SMLAWB( out, buf32[ -9 ], coef16[ 9 ] );
   11e78:	b2aa      	uxth	r2, r5
   11e7a:	142d      	asrs	r5, r5, #16
   11e7c:	fb01 f202 	mul.w	r2, r1, r2
   11e80:	fb01 f505 	mul.w	r5, r1, r5
    out = silk_SMLAWB( out, buf32[ -8 ], coef16[ 8 ] );
   11e84:	4403      	add	r3, r0
    out = silk_SMLAWB( out, buf32[ -9 ], coef16[ 9 ] );
   11e86:	eb05 4522 	add.w	r5, r5, r2, asr #16
   11e8a:	18e9      	adds	r1, r5, r3
    if( order == 16 )
   11e8c:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
   11e90:	2b10      	cmp	r3, #16
   11e92:	d153      	bne.n	11f3c <silk_NSQ_del_dec_c+0xd00>
        out = silk_SMLAWB( out, buf32[ -10 ], coef16[ 10 ] );
   11e94:	f8d7 6184 	ldr.w	r6, [r7, #388]	; 0x184
   11e98:	f85a 2c28 	ldr.w	r2, [sl, #-40]
   11e9c:	f9b6 3014 	ldrsh.w	r3, [r6, #20]
        out = silk_SMLAWB( out, buf32[ -11 ], coef16[ 11 ] );
   11ea0:	f9b6 0016 	ldrsh.w	r0, [r6, #22]
   11ea4:	f85a 4c2c 	ldr.w	r4, [sl, #-44]
        out = silk_SMLAWB( out, buf32[ -10 ], coef16[ 10 ] );
   11ea8:	b295      	uxth	r5, r2
   11eaa:	1412      	asrs	r2, r2, #16
   11eac:	fb03 f505 	mul.w	r5, r3, r5
   11eb0:	fb03 f602 	mul.w	r6, r3, r2
   11eb4:	eb06 4625 	add.w	r6, r6, r5, asr #16
        out = silk_SMLAWB( out, buf32[ -12 ], coef16[ 12 ] );
   11eb8:	f8d7 3184 	ldr.w	r3, [r7, #388]	; 0x184
   11ebc:	f85a 2c30 	ldr.w	r2, [sl, #-48]
   11ec0:	f9b3 5018 	ldrsh.w	r5, [r3, #24]
        out = silk_SMLAWB( out, buf32[ -13 ], coef16[ 13 ] );
   11ec4:	f85a 3c34 	ldr.w	r3, [sl, #-52]
        out = silk_SMLAWB( out, buf32[ -10 ], coef16[ 10 ] );
   11ec8:	4431      	add	r1, r6
        out = silk_SMLAWB( out, buf32[ -11 ], coef16[ 11 ] );
   11eca:	b2a6      	uxth	r6, r4
   11ecc:	1424      	asrs	r4, r4, #16
   11ece:	fb00 f606 	mul.w	r6, r0, r6
   11ed2:	fb00 f404 	mul.w	r4, r0, r4
   11ed6:	eb04 4426 	add.w	r4, r4, r6, asr #16
        out = silk_SMLAWB( out, buf32[ -13 ], coef16[ 13 ] );
   11eda:	f8d7 6184 	ldr.w	r6, [r7, #388]	; 0x184
        out = silk_SMLAWB( out, buf32[ -14 ], coef16[ 14 ] );
   11ede:	f85a 0c38 	ldr.w	r0, [sl, #-56]
        out = silk_SMLAWB( out, buf32[ -13 ], coef16[ 13 ] );
   11ee2:	f9b6 c01a 	ldrsh.w	ip, [r6, #26]
        out = silk_SMLAWB( out, buf32[ -11 ], coef16[ 11 ] );
   11ee6:	4421      	add	r1, r4
        out = silk_SMLAWB( out, buf32[ -12 ], coef16[ 12 ] );
   11ee8:	b294      	uxth	r4, r2
   11eea:	1412      	asrs	r2, r2, #16
   11eec:	fb05 f404 	mul.w	r4, r5, r4
   11ef0:	fb05 f502 	mul.w	r5, r5, r2
   11ef4:	eb05 4524 	add.w	r5, r5, r4, asr #16
        out = silk_SMLAWB( out, buf32[ -13 ], coef16[ 13 ] );
   11ef8:	b29c      	uxth	r4, r3
   11efa:	141b      	asrs	r3, r3, #16
   11efc:	fb0c f404 	mul.w	r4, ip, r4
   11f00:	fb0c f303 	mul.w	r3, ip, r3
   11f04:	eb03 4324 	add.w	r3, r3, r4, asr #16
        out = silk_SMLAWB( out, buf32[ -12 ], coef16[ 12 ] );
   11f08:	4429      	add	r1, r5
        out = silk_SMLAWB( out, buf32[ -14 ], coef16[ 14 ] );
   11f0a:	f9b6 201c 	ldrsh.w	r2, [r6, #28]
        out = silk_SMLAWB( out, buf32[ -15 ], coef16[ 15 ] );
   11f0e:	f85a 5c3c 	ldr.w	r5, [sl, #-60]
   11f12:	f9b6 401e 	ldrsh.w	r4, [r6, #30]
        out = silk_SMLAWB( out, buf32[ -13 ], coef16[ 13 ] );
   11f16:	4419      	add	r1, r3
        out = silk_SMLAWB( out, buf32[ -14 ], coef16[ 14 ] );
   11f18:	b283      	uxth	r3, r0
   11f1a:	1400      	asrs	r0, r0, #16
   11f1c:	fb02 f303 	mul.w	r3, r2, r3
   11f20:	fb02 f200 	mul.w	r2, r2, r0
   11f24:	eb02 4223 	add.w	r2, r2, r3, asr #16
        out = silk_SMLAWB( out, buf32[ -15 ], coef16[ 15 ] );
   11f28:	b2ab      	uxth	r3, r5
   11f2a:	142d      	asrs	r5, r5, #16
   11f2c:	fb04 f303 	mul.w	r3, r4, r3
   11f30:	fb04 f505 	mul.w	r5, r4, r5
        out = silk_SMLAWB( out, buf32[ -14 ], coef16[ 14 ] );
   11f34:	4411      	add	r1, r2
        out = silk_SMLAWB( out, buf32[ -15 ], coef16[ 15 ] );
   11f36:	eb05 4323 	add.w	r3, r5, r3, asr #16
   11f3a:	4419      	add	r1, r3
            tmp2 = silk_SMLAWB( psDD->Diff_Q14, psDD->sAR2_Q14[ 0 ], warping_Q16 );
   11f3c:	f8db 04a0 	ldr.w	r0, [fp, #1184]	; 0x4a0
   11f40:	f8db 3504 	ldr.w	r3, [fp, #1284]	; 0x504
            tmp1 = silk_SMLAWB( psDD->sAR2_Q14[ 0 ], psDD->sAR2_Q14[ 1 ] - tmp2, warping_Q16 );
   11f44:	f8db 54a4 	ldr.w	r5, [fp, #1188]	; 0x4a4
            tmp2 = silk_SMLAWB( psDD->Diff_Q14, psDD->sAR2_Q14[ 0 ], warping_Q16 );
   11f48:	b284      	uxth	r4, r0
   11f4a:	1402      	asrs	r2, r0, #16
   11f4c:	fb08 f404 	mul.w	r4, r8, r4
   11f50:	fb08 f202 	mul.w	r2, r8, r2
   11f54:	eb02 4224 	add.w	r2, r2, r4, asr #16
   11f58:	4413      	add	r3, r2
            tmp1 = silk_SMLAWB( psDD->sAR2_Q14[ 0 ], psDD->sAR2_Q14[ 1 ] - tmp2, warping_Q16 );
   11f5a:	1aea      	subs	r2, r5, r3
   11f5c:	b296      	uxth	r6, r2
   11f5e:	1412      	asrs	r2, r2, #16
   11f60:	fb08 f606 	mul.w	r6, r8, r6
   11f64:	46ac      	mov	ip, r5
   11f66:	fb08 f202 	mul.w	r2, r8, r2
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp2, AR_shp_Q13[ 0 ] );
   11f6a:	f8d7 5178 	ldr.w	r5, [r7, #376]	; 0x178
            psDD->sAR2_Q14[ 0 ] = tmp2;
   11f6e:	f8cb 34a0 	str.w	r3, [fp, #1184]	; 0x4a0
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp2, AR_shp_Q13[ 0 ] );
   11f72:	b29c      	uxth	r4, r3
            tmp1 = silk_SMLAWB( psDD->sAR2_Q14[ 0 ], psDD->sAR2_Q14[ 1 ] - tmp2, warping_Q16 );
   11f74:	eb02 4226 	add.w	r2, r2, r6, asr #16
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp2, AR_shp_Q13[ 0 ] );
   11f78:	f8d7 6178 	ldr.w	r6, [r7, #376]	; 0x178
   11f7c:	fb05 f504 	mul.w	r5, r5, r4
   11f80:	141c      	asrs	r4, r3, #16
   11f82:	fb06 f404 	mul.w	r4, r6, r4
   11f86:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
   11f8a:	eb04 4425 	add.w	r4, r4, r5, asr #16
   11f8e:	18e3      	adds	r3, r4, r3
   11f90:	f8c7 3188 	str.w	r3, [r7, #392]	; 0x188
            for( j = 2; j < shapingLPCOrder; j += 2 ) {
   11f94:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
            LPC_pred_Q14 = silk_LSHIFT( LPC_pred_Q14, 4 );                              /* Q10 -> Q14 */
   11f98:	0109      	lsls	r1, r1, #4
            for( j = 2; j < shapingLPCOrder; j += 2 ) {
   11f9a:	2b02      	cmp	r3, #2
            LPC_pred_Q14 = silk_LSHIFT( LPC_pred_Q14, 4 );                              /* Q10 -> Q14 */
   11f9c:	f8c7 1190 	str.w	r1, [r7, #400]	; 0x190
            tmp1 = silk_SMLAWB( psDD->sAR2_Q14[ 0 ], psDD->sAR2_Q14[ 1 ] - tmp2, warping_Q16 );
   11fa0:	4402      	add	r2, r0
            for( j = 2; j < shapingLPCOrder; j += 2 ) {
   11fa2:	dd4f      	ble.n	12044 <silk_NSQ_del_dec_c+0xe08>
   11fa4:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
   11fa8:	f8c7 b150 	str.w	fp, [r7, #336]	; 0x150
   11fac:	445b      	add	r3, fp
   11fae:	46de      	mov	lr, fp
   11fb0:	f8d7 9170 	ldr.w	r9, [r7, #368]	; 0x170
   11fb4:	f8d7 b188 	ldr.w	fp, [r7, #392]	; 0x188
   11fb8:	f8c7 319c 	str.w	r3, [r7, #412]	; 0x19c
   11fbc:	f8c7 a14c 	str.w	sl, [r7, #332]	; 0x14c
                tmp2 = silk_SMLAWB( psDD->sAR2_Q14[ j - 1 ], psDD->sAR2_Q14[ j + 0 ] - tmp1, warping_Q16 );
   11fc0:	f8de a4a8 	ldr.w	sl, [lr, #1192]	; 0x4a8
                n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp1, AR_shp_Q13[ j - 1 ] );
   11fc4:	f9b9 1002 	ldrsh.w	r1, [r9, #2]
                psDD->sAR2_Q14[ j - 1 ] = tmp1;
   11fc8:	f8ce 24a4 	str.w	r2, [lr, #1188]	; 0x4a4
                tmp2 = silk_SMLAWB( psDD->sAR2_Q14[ j - 1 ], psDD->sAR2_Q14[ j + 0 ] - tmp1, warping_Q16 );
   11fcc:	ebaa 0302 	sub.w	r3, sl, r2
   11fd0:	b298      	uxth	r0, r3
   11fd2:	141b      	asrs	r3, r3, #16
   11fd4:	fb08 f000 	mul.w	r0, r8, r0
   11fd8:	fb08 f303 	mul.w	r3, r8, r3
   11fdc:	eb03 4320 	add.w	r3, r3, r0, asr #16
   11fe0:	4463      	add	r3, ip
                n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp1, AR_shp_Q13[ j - 1 ] );
   11fe2:	b296      	uxth	r6, r2
                tmp1 = silk_SMLAWB( psDD->sAR2_Q14[ j + 0 ], psDD->sAR2_Q14[ j + 1 ] - tmp2, warping_Q16 );
   11fe4:	f8de c4ac 	ldr.w	ip, [lr, #1196]	; 0x4ac
                n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp2, AR_shp_Q13[ j ] );
   11fe8:	f939 0f04 	ldrsh.w	r0, [r9, #4]!
                psDD->sAR2_Q14[ j + 0 ] = tmp2;
   11fec:	f8ce 34a8 	str.w	r3, [lr, #1192]	; 0x4a8
                n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp1, AR_shp_Q13[ j - 1 ] );
   11ff0:	1412      	asrs	r2, r2, #16
   11ff2:	fb01 f202 	mul.w	r2, r1, r2
   11ff6:	fb01 f606 	mul.w	r6, r1, r6
                tmp1 = silk_SMLAWB( psDD->sAR2_Q14[ j + 0 ], psDD->sAR2_Q14[ j + 1 ] - tmp2, warping_Q16 );
   11ffa:	ebac 0403 	sub.w	r4, ip, r3
                n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp1, AR_shp_Q13[ j - 1 ] );
   11ffe:	eb02 4626 	add.w	r6, r2, r6, asr #16
                n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp2, AR_shp_Q13[ j ] );
   12002:	b29a      	uxth	r2, r3
   12004:	141b      	asrs	r3, r3, #16
   12006:	fb00 f102 	mul.w	r1, r0, r2
   1200a:	fb00 f303 	mul.w	r3, r0, r3
   1200e:	eb03 4321 	add.w	r3, r3, r1, asr #16
                n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp1, AR_shp_Q13[ j - 1 ] );
   12012:	445e      	add	r6, fp
                tmp1 = silk_SMLAWB( psDD->sAR2_Q14[ j + 0 ], psDD->sAR2_Q14[ j + 1 ] - tmp2, warping_Q16 );
   12014:	b2a5      	uxth	r5, r4
                n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp2, AR_shp_Q13[ j ] );
   12016:	eb03 0b06 	add.w	fp, r3, r6
                tmp1 = silk_SMLAWB( psDD->sAR2_Q14[ j + 0 ], psDD->sAR2_Q14[ j + 1 ] - tmp2, warping_Q16 );
   1201a:	1424      	asrs	r4, r4, #16
            for( j = 2; j < shapingLPCOrder; j += 2 ) {
   1201c:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
                tmp1 = silk_SMLAWB( psDD->sAR2_Q14[ j + 0 ], psDD->sAR2_Q14[ j + 1 ] - tmp2, warping_Q16 );
   12020:	fb08 f505 	mul.w	r5, r8, r5
   12024:	fb08 f404 	mul.w	r4, r8, r4
   12028:	f10e 0e08 	add.w	lr, lr, #8
   1202c:	eb04 4525 	add.w	r5, r4, r5, asr #16
            for( j = 2; j < shapingLPCOrder; j += 2 ) {
   12030:	459e      	cmp	lr, r3
                tmp1 = silk_SMLAWB( psDD->sAR2_Q14[ j + 0 ], psDD->sAR2_Q14[ j + 1 ] - tmp2, warping_Q16 );
   12032:	eb05 020a 	add.w	r2, r5, sl
            for( j = 2; j < shapingLPCOrder; j += 2 ) {
   12036:	d1c3      	bne.n	11fc0 <silk_NSQ_del_dec_c+0xd84>
   12038:	f8c7 b188 	str.w	fp, [r7, #392]	; 0x188
   1203c:	f8d7 a14c 	ldr.w	sl, [r7, #332]	; 0x14c
   12040:	f8d7 b150 	ldr.w	fp, [r7, #336]	; 0x150
            psDD->sAR2_Q14[ shapingLPCOrder - 1 ] = tmp1;
   12044:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
            n_LF_Q14 = silk_SMULWB( psDD->Shape_Q14[ *smpl_buf_idx ], LF_shp_Q14 );     /* Q12 */
   12048:	f8d7 4124 	ldr.w	r4, [r7, #292]	; 0x124
            psDD->sAR2_Q14[ shapingLPCOrder - 1 ] = tmp1;
   1204c:	eb0b 0103 	add.w	r1, fp, r3
            n_LF_Q14 = silk_SMULWB( psDD->Shape_Q14[ *smpl_buf_idx ], LF_shp_Q14 );     /* Q12 */
   12050:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
            psDD->sAR2_Q14[ shapingLPCOrder - 1 ] = tmp1;
   12054:	f8c1 24a0 	str.w	r2, [r1, #1184]	; 0x4a0
            n_LF_Q14 = silk_SMULWB( psDD->Shape_Q14[ *smpl_buf_idx ], LF_shp_Q14 );     /* Q12 */
   12058:	445b      	add	r3, fp
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, psDD->LF_AR_Q14, Tilt_Q14 );              /* Q12 */
   1205a:	f8db 1500 	ldr.w	r1, [fp, #1280]	; 0x500
            n_LF_Q14 = silk_SMULWB( psDD->Shape_Q14[ *smpl_buf_idx ], LF_shp_Q14 );     /* Q12 */
   1205e:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
   12062:	b29d      	uxth	r5, r3
   12064:	141b      	asrs	r3, r3, #16
   12066:	fb04 f505 	mul.w	r5, r4, r5
   1206a:	fb04 f303 	mul.w	r3, r4, r3
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp1, AR_shp_Q13[ shapingLPCOrder - 1 ] );
   1206e:	f8d7 412c 	ldr.w	r4, [r7, #300]	; 0x12c
   12072:	b290      	uxth	r0, r2
   12074:	1412      	asrs	r2, r2, #16
   12076:	fb04 f000 	mul.w	r0, r4, r0
   1207a:	fb04 f202 	mul.w	r2, r4, r2
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, psDD->LF_AR_Q14, Tilt_Q14 );              /* Q12 */
   1207e:	f8d7 4120 	ldr.w	r4, [r7, #288]	; 0x120
   12082:	140e      	asrs	r6, r1, #16
   12084:	b289      	uxth	r1, r1
   12086:	fb04 fc06 	mul.w	ip, r4, r6
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp1, AR_shp_Q13[ shapingLPCOrder - 1 ] );
   1208a:	eb02 4220 	add.w	r2, r2, r0, asr #16
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, psDD->LF_AR_Q14, Tilt_Q14 );              /* Q12 */
   1208e:	fb04 f001 	mul.w	r0, r4, r1
            n_LF_Q14 = silk_SMLAWT( n_LF_Q14, psDD->LF_AR_Q14, LF_shp_Q14 );            /* Q12 */
   12092:	f8d7 4164 	ldr.w	r4, [r7, #356]	; 0x164
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, psDD->LF_AR_Q14, Tilt_Q14 );              /* Q12 */
   12096:	eb0c 4c20 	add.w	ip, ip, r0, asr #16
            n_LF_Q14 = silk_SMULWB( psDD->Shape_Q14[ *smpl_buf_idx ], LF_shp_Q14 );     /* Q12 */
   1209a:	eb03 4325 	add.w	r3, r3, r5, asr #16
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp1, AR_shp_Q13[ shapingLPCOrder - 1 ] );
   1209e:	f8d7 0188 	ldr.w	r0, [r7, #392]	; 0x188
            n_LF_Q14 = silk_SMLAWT( n_LF_Q14, psDD->LF_AR_Q14, LF_shp_Q14 );            /* Q12 */
   120a2:	fb01 f104 	mul.w	r1, r1, r4
   120a6:	fb06 3304 	mla	r3, r6, r4, r3
   120aa:	eb03 4321 	add.w	r3, r3, r1, asr #16
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp1, AR_shp_Q13[ shapingLPCOrder - 1 ] );
   120ae:	4402      	add	r2, r0
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, psDD->LF_AR_Q14, Tilt_Q14 );              /* Q12 */
   120b0:	eb0c 0242 	add.w	r2, ip, r2, lsl #1
            n_LF_Q14 = silk_LSHIFT( n_LF_Q14, 2 );                                      /* Q12 -> Q14 */
   120b4:	ea4f 0983 	mov.w	r9, r3, lsl #2
            tmp2 = silk_ADD32( n_LTP_Q14, LPC_pred_Q14 );                               /* Q13 */
   120b8:	f8d7 1134 	ldr.w	r1, [r7, #308]	; 0x134
   120bc:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
            n_AR_Q14 = silk_LSHIFT( n_AR_Q14, 2 );                                      /* Q12 -> Q14 */
   120c0:	0094      	lsls	r4, r2, #2
            tmp1 = silk_ADD32( n_AR_Q14, n_LF_Q14 );                                    /* Q14 */
   120c2:	eb09 0204 	add.w	r2, r9, r4
            tmp2 = silk_ADD32( n_LTP_Q14, LPC_pred_Q14 );                               /* Q13 */
   120c6:	440b      	add	r3, r1
            tmp1 = silk_SUB32( tmp2, tmp1 );                                            /* Q13 */
   120c8:	1a9b      	subs	r3, r3, r2
            tmp1 = silk_RSHIFT_ROUND( tmp1, 4 );                                        /* Q10 */
   120ca:	10db      	asrs	r3, r3, #3
            r_Q10 = silk_SUB32( x_Q10[ i ], tmp1 );                                     /* residual error Q10 */
   120cc:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
            if (Lambda_Q10 > 2048) {
   120d0:	f8d7 128c 	ldr.w	r1, [r7, #652]	; 0x28c
            tmp1 = silk_RSHIFT_ROUND( tmp1, 4 );                                        /* Q10 */
   120d4:	3301      	adds	r3, #1
            r_Q10 = silk_SUB32( x_Q10[ i ], tmp1 );                                     /* residual error Q10 */
   120d6:	eba2 0363 	sub.w	r3, r2, r3, asr #1
            if ( psDD->Seed < 0 ) {
   120da:	f8d7 218c 	ldr.w	r2, [r7, #396]	; 0x18c
   120de:	2a00      	cmp	r2, #0
            r_Q10 = silk_LIMIT_32( r_Q10, -(31 << 10), 30 << 10 );
   120e0:	4a10      	ldr	r2, [pc, #64]	; (12124 <silk_NSQ_del_dec_c+0xee8>)
                r_Q10 = -r_Q10;
   120e2:	bfb8      	it	lt
   120e4:	425b      	neglt	r3, r3
            r_Q10 = silk_LIMIT_32( r_Q10, -(31 << 10), 30 << 10 );
   120e6:	4293      	cmp	r3, r2
   120e8:	bfb8      	it	lt
   120ea:	4613      	movlt	r3, r2
   120ec:	f5b3 4ff0 	cmp.w	r3, #30720	; 0x7800
            q1_Q10 = silk_SUB32( r_Q10, offset_Q10 );
   120f0:	f8d7 2194 	ldr.w	r2, [r7, #404]	; 0x194
   120f4:	bfa8      	it	ge
   120f6:	f44f 43f0 	movge.w	r3, #30720	; 0x7800
            if (Lambda_Q10 > 2048) {
   120fa:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
            q1_Q10 = silk_SUB32( r_Q10, offset_Q10 );
   120fe:	eba3 0202 	sub.w	r2, r3, r2
            if (Lambda_Q10 > 2048) {
   12102:	f340 8215 	ble.w	12530 <silk_NSQ_del_dec_c+0x12f4>
                if (q1_Q10 > rdo_offset) {
   12106:	f8d7 113c 	ldr.w	r1, [r7, #316]	; 0x13c
   1210a:	4291      	cmp	r1, r2
   1210c:	f280 8221 	bge.w	12552 <silk_NSQ_del_dec_c+0x1316>
                    q1_Q0 = silk_RSHIFT( q1_Q10 - rdo_offset, 10 );
   12110:	1a50      	subs	r0, r2, r1
   12112:	1280      	asrs	r0, r0, #10
            if( q1_Q0 > 0 ) {
   12114:	2800      	cmp	r0, #0
   12116:	f340 820f 	ble.w	12538 <silk_NSQ_del_dec_c+0x12fc>
   1211a:	e005      	b.n	12128 <silk_NSQ_del_dec_c+0xeec>
   1211c:	0bb38435 	.word	0x0bb38435
   12120:	3619636b 	.word	0x3619636b
   12124:	ffff8400 	.word	0xffff8400
                q1_Q10  = silk_SUB32( silk_LSHIFT( q1_Q0, 10 ), QUANT_LEVEL_ADJUST_Q10 );
   12128:	f8d7 2194 	ldr.w	r2, [r7, #404]	; 0x194
                rd2_Q10 = silk_SMULBB( q2_Q10, Lambda_Q10 );
   1212c:	f8d7 5154 	ldr.w	r5, [r7, #340]	; 0x154
                q1_Q10  = silk_SUB32( silk_LSHIFT( q1_Q0, 10 ), QUANT_LEVEL_ADJUST_Q10 );
   12130:	eb02 2080 	add.w	r0, r2, r0, lsl #10
                q1_Q10  = silk_ADD32( q1_Q10, offset_Q10 );
   12134:	3850      	subs	r0, #80	; 0x50
                q2_Q10  = silk_ADD32( q1_Q10, 1024 );
   12136:	f500 6680 	add.w	r6, r0, #1024	; 0x400
                rd2_Q10 = silk_SMULBB( q2_Q10, Lambda_Q10 );
   1213a:	fb16 fe05 	smulbb	lr, r6, r5
   1213e:	1b99      	subs	r1, r3, r6
   12140:	1a1a      	subs	r2, r3, r0
   12142:	46b4      	mov	ip, r6
                rd1_Q10 = silk_SMULBB( q1_Q10, Lambda_Q10 );
   12144:	fb10 f305 	smulbb	r3, r0, r5
   12148:	4605      	mov	r5, r0
            rd2_Q10 = silk_RSHIFT( silk_SMLABB( rd2_Q10, rr_Q10, rr_Q10 ), 10 );
   1214a:	b209      	sxth	r1, r1
            rd1_Q10 = silk_RSHIFT( silk_SMLABB( rd1_Q10, rr_Q10, rr_Q10 ), 10 );
   1214c:	b212      	sxth	r2, r2
   1214e:	fb02 3202 	mla	r2, r2, r2, r3
            rd2_Q10 = silk_RSHIFT( silk_SMLABB( rd2_Q10, rr_Q10, rr_Q10 ), 10 );
   12152:	fb01 e301 	mla	r3, r1, r1, lr
            rd1_Q10 = silk_RSHIFT( silk_SMLABB( rd1_Q10, rr_Q10, rr_Q10 ), 10 );
   12156:	1292      	asrs	r2, r2, #10
   12158:	f8db 1510 	ldr.w	r1, [fp, #1296]	; 0x510
            rd2_Q10 = silk_RSHIFT( silk_SMLABB( rd2_Q10, rr_Q10, rr_Q10 ), 10 );
   1215c:	129b      	asrs	r3, r3, #10
            if( rd1_Q10 < rd2_Q10 ) {
   1215e:	4293      	cmp	r3, r2
   12160:	eb01 0e03 	add.w	lr, r1, r3
   12164:	4411      	add	r1, r2
   12166:	f340 81db 	ble.w	12520 <silk_NSQ_del_dec_c+0x12e4>
                psSS[ 0 ].RD_Q10 = silk_ADD32( psDD->RD_Q10, rd1_Q10 );
   1216a:	f8d7 2198 	ldr.w	r2, [r7, #408]	; 0x198
                psSS[ 1 ].Q_Q10  = q2_Q10;
   1216e:	f8c7 c19c 	str.w	ip, [r7, #412]	; 0x19c
   12172:	46ac      	mov	ip, r5
   12174:	f8d7 519c 	ldr.w	r5, [r7, #412]	; 0x19c
                psSS[ 0 ].RD_Q10 = silk_ADD32( psDD->RD_Q10, rd1_Q10 );
   12178:	6051      	str	r1, [r2, #4]
                psSS[ 1 ].RD_Q10 = silk_ADD32( psDD->RD_Q10, rd2_Q10 );
   1217a:	f8c2 e020 	str.w	lr, [r2, #32]
                psSS[ 0 ].Q_Q10  = q1_Q10;
   1217e:	6010      	str	r0, [r2, #0]
                psSS[ 1 ].Q_Q10  = q2_Q10;
   12180:	61d6      	str	r6, [r2, #28]
            if ( psDD->Seed < 0 ) {
   12182:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
            xq_Q14      = silk_ADD32( LPC_exc_Q14, LPC_pred_Q14 );
   12186:	f8d7 2190 	ldr.w	r2, [r7, #400]	; 0x190
            psSS[ 0 ].LPC_exc_Q14  = LPC_exc_Q14;
   1218a:	f8d7 0198 	ldr.w	r0, [r7, #408]	; 0x198
            if ( psDD->Seed < 0 ) {
   1218e:	2b00      	cmp	r3, #0
            exc_Q14 = silk_LSHIFT32( psSS[ 0 ].Q_Q10, 4 );
   12190:	ea4f 1c0c 	mov.w	ip, ip, lsl #4
            LPC_exc_Q14 = silk_ADD32( exc_Q14, LTP_pred_Q14 );
   12194:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
                exc_Q14 = -exc_Q14;
   12198:	bfb8      	it	lt
   1219a:	f1cc 0c00 	rsblt	ip, ip, #0
            LPC_exc_Q14 = silk_ADD32( exc_Q14, LTP_pred_Q14 );
   1219e:	4463      	add	r3, ip
            xq_Q14      = silk_ADD32( LPC_exc_Q14, LPC_pred_Q14 );
   121a0:	1899      	adds	r1, r3, r2
            psSS[ 0 ].Diff_Q14     = silk_SUB_LSHIFT32( xq_Q14, x_Q10[ i ], 4 );
   121a2:	f8d7 217c 	ldr.w	r2, [r7, #380]	; 0x17c
            psSS[ 0 ].LPC_exc_Q14  = LPC_exc_Q14;
   121a6:	6183      	str	r3, [r0, #24]
            psSS[ 0 ].Diff_Q14     = silk_SUB_LSHIFT32( xq_Q14, x_Q10[ i ], 4 );
   121a8:	1a8a      	subs	r2, r1, r2
            sLF_AR_shp_Q14         = silk_SUB32( psSS[ 0 ].Diff_Q14, n_AR_Q14 );
   121aa:	1b13      	subs	r3, r2, r4
            psSS[ 0 ].Diff_Q14     = silk_SUB_LSHIFT32( xq_Q14, x_Q10[ i ], 4 );
   121ac:	6102      	str	r2, [r0, #16]
            psSS[ 0 ].LF_AR_Q14    = sLF_AR_shp_Q14;
   121ae:	60c3      	str	r3, [r0, #12]
            psSS[ 0 ].sLTP_shp_Q14 = silk_SUB32( sLF_AR_shp_Q14, n_LF_Q14 );
   121b0:	eba3 0209 	sub.w	r2, r3, r9
            if ( psDD->Seed < 0 ) {
   121b4:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
            psSS[ 0 ].sLTP_shp_Q14 = silk_SUB32( sLF_AR_shp_Q14, n_LF_Q14 );
   121b8:	6142      	str	r2, [r0, #20]
            if ( psDD->Seed < 0 ) {
   121ba:	2b00      	cmp	r3, #0
            exc_Q14 = silk_LSHIFT32( psSS[ 1 ].Q_Q10, 4 );
   121bc:	ea4f 1505 	mov.w	r5, r5, lsl #4
            LPC_exc_Q14 = silk_ADD32( exc_Q14, LTP_pred_Q14 );
   121c0:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
            psSS[ 0 ].xq_Q14       = xq_Q14;
   121c4:	6081      	str	r1, [r0, #8]
                exc_Q14 = -exc_Q14;
   121c6:	bfb8      	it	lt
   121c8:	426d      	neglt	r5, r5
            LPC_exc_Q14 = silk_ADD32( exc_Q14, LTP_pred_Q14 );
   121ca:	441d      	add	r5, r3
            xq_Q14      = silk_ADD32( LPC_exc_Q14, LPC_pred_Q14 );
   121cc:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
            psSS[ 1 ].LPC_exc_Q14  = LPC_exc_Q14;
   121d0:	6345      	str	r5, [r0, #52]	; 0x34
            xq_Q14      = silk_ADD32( LPC_exc_Q14, LPC_pred_Q14 );
   121d2:	442b      	add	r3, r5
   121d4:	461a      	mov	r2, r3
            psSS[ 1 ].Diff_Q14     = silk_SUB_LSHIFT32( xq_Q14, x_Q10[ i ], 4 );
   121d6:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
            psSS[ 1 ].xq_Q14       = xq_Q14;
   121da:	6242      	str	r2, [r0, #36]	; 0x24
            psSS[ 1 ].Diff_Q14     = silk_SUB_LSHIFT32( xq_Q14, x_Q10[ i ], 4 );
   121dc:	1ad3      	subs	r3, r2, r3
            sLF_AR_shp_Q14         = silk_SUB32( psSS[ 1 ].Diff_Q14, n_AR_Q14 );
   121de:	1b1c      	subs	r4, r3, r4
            psSS[ 1 ].Diff_Q14     = silk_SUB_LSHIFT32( xq_Q14, x_Q10[ i ], 4 );
   121e0:	e9c0 430a 	strd	r4, r3, [r0, #40]	; 0x28
            psSS[ 1 ].LPC_exc_Q14  = LPC_exc_Q14;
   121e4:	4603      	mov	r3, r0
   121e6:	3338      	adds	r3, #56	; 0x38
   121e8:	f8c7 3198 	str.w	r3, [r7, #408]	; 0x198
        for( k = 0; k < nStatesDelayedDecision; k++ ) {
   121ec:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
   121f0:	f20b 5b14 	addw	fp, fp, #1300	; 0x514
            psSS[ 1 ].sLTP_shp_Q14 = silk_SUB32( sLF_AR_shp_Q14, n_LF_Q14 );
   121f4:	eba4 0109 	sub.w	r1, r4, r9
        for( k = 0; k < nStatesDelayedDecision; k++ ) {
   121f8:	459b      	cmp	fp, r3
            psSS[ 1 ].sLTP_shp_Q14 = silk_SUB32( sLF_AR_shp_Q14, n_LF_Q14 );
   121fa:	6301      	str	r1, [r0, #48]	; 0x30
   121fc:	f20a 5a14 	addw	sl, sl, #1300	; 0x514
        for( k = 0; k < nStatesDelayedDecision; k++ ) {
   12200:	f47f adbc 	bne.w	11d7c <silk_NSQ_del_dec_c+0xb40>
        *smpl_buf_idx  = ( *smpl_buf_idx - 1 ) % DECISION_DELAY;
   12204:	f8d7 2148 	ldr.w	r2, [r7, #328]	; 0x148
   12208:	1e53      	subs	r3, r2, #1
        if( *smpl_buf_idx < 0 ) *smpl_buf_idx += DECISION_DELAY;
   1220a:	2a00      	cmp	r2, #0
   1220c:	f000 81d5 	beq.w	125ba <silk_NSQ_del_dec_c+0x137e>
   12210:	ea4f 0883 	mov.w	r8, r3, lsl #2
   12214:	f8c7 3148 	str.w	r3, [r7, #328]	; 0x148
   12218:	461a      	mov	r2, r3
        last_smple_idx = ( *smpl_buf_idx + decisionDelay ) % DECISION_DELAY;
   1221a:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
   1221e:	4413      	add	r3, r2
   12220:	4ae3      	ldr	r2, [pc, #908]	; (125b0 <silk_NSQ_del_dec_c+0x1374>)
   12222:	17dc      	asrs	r4, r3, #31
   12224:	fb82 1203 	smull	r1, r2, r2, r3
   12228:	ebc4 1422 	rsb	r4, r4, r2, asr #4
   1222c:	eb04 0484 	add.w	r4, r4, r4, lsl #2
   12230:	eba3 04c4 	sub.w	r4, r3, r4, lsl #3
        RDmin_Q10 = psSampleState[ 0 ][ 0 ].RD_Q10;
   12234:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
   12238:	6859      	ldr	r1, [r3, #4]
        for( k = 1; k < nStatesDelayedDecision; k++ ) {
   1223a:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
   1223e:	2b01      	cmp	r3, #1
   12240:	f340 82fa 	ble.w	12838 <silk_NSQ_del_dec_c+0x15fc>
   12244:	f8d7 2158 	ldr.w	r2, [r7, #344]	; 0x158
   12248:	461e      	mov	r6, r3
        Winner_ind = 0;
   1224a:	2500      	movs	r5, #0
        for( k = 1; k < nStatesDelayedDecision; k++ ) {
   1224c:	2301      	movs	r3, #1
            if( psSampleState[ k ][ 0 ].RD_Q10 < RDmin_Q10 ) {
   1224e:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
   12250:	4288      	cmp	r0, r1
   12252:	bfb8      	it	lt
   12254:	461d      	movlt	r5, r3
        for( k = 1; k < nStatesDelayedDecision; k++ ) {
   12256:	f103 0301 	add.w	r3, r3, #1
            if( psSampleState[ k ][ 0 ].RD_Q10 < RDmin_Q10 ) {
   1225a:	bfb8      	it	lt
   1225c:	4601      	movlt	r1, r0
        for( k = 1; k < nStatesDelayedDecision; k++ ) {
   1225e:	429e      	cmp	r6, r3
   12260:	f102 0238 	add.w	r2, r2, #56	; 0x38
   12264:	d1f3      	bne.n	1224e <silk_NSQ_del_dec_c+0x1012>
        Winner_rand_state = psDelDec[ Winner_ind ].RandState[ last_smple_idx ];
   12266:	f8d7 2144 	ldr.w	r2, [r7, #324]	; 0x144
   1226a:	f240 5314 	movw	r3, #1300	; 0x514
   1226e:	fb03 2505 	mla	r5, r3, r5, r2
   12272:	f104 0360 	add.w	r3, r4, #96	; 0x60
   12276:	f855 e023 	ldr.w	lr, [r5, r3, lsl #2]
   1227a:	4613      	mov	r3, r2
   1227c:	00a4      	lsls	r4, r4, #2
   1227e:	191e      	adds	r6, r3, r4
                psSampleState[ k ][ 0 ].RD_Q10 = silk_ADD32( psSampleState[ k ][ 0 ].RD_Q10, silk_int32_MAX >> 4 );
   12280:	f8d7 915c 	ldr.w	r9, [r7, #348]	; 0x15c
   12284:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
        for( k = 0; k < nStatesDelayedDecision; k++ ) {
   12288:	2200      	movs	r2, #0
                psSampleState[ k ][ 0 ].RD_Q10 = silk_ADD32( psSampleState[ k ][ 0 ].RD_Q10, silk_int32_MAX >> 4 );
   1228a:	f06f 4c78 	mvn.w	ip, #4160749568	; 0xf8000000
            if( psDelDec[ k ].RandState[ last_smple_idx ] != Winner_rand_state ) {
   1228e:	f8d6 1180 	ldr.w	r1, [r6, #384]	; 0x180
   12292:	4571      	cmp	r1, lr
        for( k = 0; k < nStatesDelayedDecision; k++ ) {
   12294:	f102 0201 	add.w	r2, r2, #1
   12298:	f206 5614 	addw	r6, r6, #1300	; 0x514
            if( psDelDec[ k ].RandState[ last_smple_idx ] != Winner_rand_state ) {
   1229c:	d005      	beq.n	122aa <silk_NSQ_del_dec_c+0x106e>
                psSampleState[ k ][ 0 ].RD_Q10 = silk_ADD32( psSampleState[ k ][ 0 ].RD_Q10, silk_int32_MAX >> 4 );
   1229e:	6858      	ldr	r0, [r3, #4]
                psSampleState[ k ][ 1 ].RD_Q10 = silk_ADD32( psSampleState[ k ][ 1 ].RD_Q10, silk_int32_MAX >> 4 );
   122a0:	6a19      	ldr	r1, [r3, #32]
                psSampleState[ k ][ 0 ].RD_Q10 = silk_ADD32( psSampleState[ k ][ 0 ].RD_Q10, silk_int32_MAX >> 4 );
   122a2:	4460      	add	r0, ip
                psSampleState[ k ][ 1 ].RD_Q10 = silk_ADD32( psSampleState[ k ][ 1 ].RD_Q10, silk_int32_MAX >> 4 );
   122a4:	4461      	add	r1, ip
                psSampleState[ k ][ 0 ].RD_Q10 = silk_ADD32( psSampleState[ k ][ 0 ].RD_Q10, silk_int32_MAX >> 4 );
   122a6:	6058      	str	r0, [r3, #4]
                psSampleState[ k ][ 1 ].RD_Q10 = silk_ADD32( psSampleState[ k ][ 1 ].RD_Q10, silk_int32_MAX >> 4 );
   122a8:	6219      	str	r1, [r3, #32]
        for( k = 0; k < nStatesDelayedDecision; k++ ) {
   122aa:	4591      	cmp	r9, r2
   122ac:	f103 0338 	add.w	r3, r3, #56	; 0x38
   122b0:	dced      	bgt.n	1228e <silk_NSQ_del_dec_c+0x1052>
        for( k = 1; k < nStatesDelayedDecision; k++ ) {
   122b2:	f8d7 015c 	ldr.w	r0, [r7, #348]	; 0x15c
        RDmax_Q10  = psSampleState[ 0 ][ 0 ].RD_Q10;
   122b6:	f8d7 2158 	ldr.w	r2, [r7, #344]	; 0x158
        for( k = 1; k < nStatesDelayedDecision; k++ ) {
   122ba:	f04f 0900 	mov.w	r9, #0
   122be:	2801      	cmp	r0, #1
        RDmax_Q10  = psSampleState[ 0 ][ 0 ].RD_Q10;
   122c0:	6851      	ldr	r1, [r2, #4]
        RDmin_Q10  = psSampleState[ 0 ][ 1 ].RD_Q10;
   122c2:	f8d2 c020 	ldr.w	ip, [r2, #32]
        for( k = 1; k < nStatesDelayedDecision; k++ ) {
   122c6:	464e      	mov	r6, r9
   122c8:	dd13      	ble.n	122f2 <silk_NSQ_del_dec_c+0x10b6>
   122ca:	2301      	movs	r3, #1
   122cc:	4686      	mov	lr, r0
            if( psSampleState[ k ][ 0 ].RD_Q10 > RDmax_Q10 ) {
   122ce:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
   122d0:	4288      	cmp	r0, r1
   122d2:	bfc8      	it	gt
   122d4:	4601      	movgt	r1, r0
            if( psSampleState[ k ][ 1 ].RD_Q10 < RDmin_Q10 ) {
   122d6:	6d90      	ldr	r0, [r2, #88]	; 0x58
            if( psSampleState[ k ][ 0 ].RD_Q10 > RDmax_Q10 ) {
   122d8:	bfc8      	it	gt
   122da:	461e      	movgt	r6, r3
            if( psSampleState[ k ][ 1 ].RD_Q10 < RDmin_Q10 ) {
   122dc:	4560      	cmp	r0, ip
   122de:	bfb8      	it	lt
   122e0:	4699      	movlt	r9, r3
        for( k = 1; k < nStatesDelayedDecision; k++ ) {
   122e2:	f103 0301 	add.w	r3, r3, #1
            if( psSampleState[ k ][ 1 ].RD_Q10 < RDmin_Q10 ) {
   122e6:	bfb8      	it	lt
   122e8:	4684      	movlt	ip, r0
        for( k = 1; k < nStatesDelayedDecision; k++ ) {
   122ea:	459e      	cmp	lr, r3
   122ec:	f102 0238 	add.w	r2, r2, #56	; 0x38
   122f0:	dced      	bgt.n	122ce <silk_NSQ_del_dec_c+0x1092>
        if( RDmin_Q10 < RDmax_Q10 ) {
   122f2:	458c      	cmp	ip, r1
   122f4:	f2c0 8168 	blt.w	125c8 <silk_NSQ_del_dec_c+0x138c>
            xq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   122f8:	f507 7310 	add.w	r3, r7, #576	; 0x240
   122fc:	4425      	add	r5, r4
   122fe:	441c      	add	r4, r3
   12300:	f8d5 02c0 	ldr.w	r0, [r5, #704]	; 0x2c0
   12304:	f854 3ca0 	ldr.w	r3, [r4, #-160]
            pulses[  i - decisionDelay ] = (opus_int8)silk_RSHIFT_ROUND( psDD->Q_Q10[ last_smple_idx ], 10 );
   12308:	f8d5 2220 	ldr.w	r2, [r5, #544]	; 0x220
            xq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   1230c:	b21e      	sxth	r6, r3
   1230e:	b284      	uxth	r4, r0
   12310:	13db      	asrs	r3, r3, #15
   12312:	1401      	asrs	r1, r0, #16
   12314:	fb06 f101 	mul.w	r1, r6, r1
   12318:	3301      	adds	r3, #1
   1231a:	fb06 f404 	mul.w	r4, r6, r4
   1231e:	eb01 4424 	add.w	r4, r1, r4, asr #16
   12322:	105b      	asrs	r3, r3, #1
   12324:	fb00 4303 	mla	r3, r0, r3, r4
            pulses[  i - decisionDelay ] = (opus_int8)silk_RSHIFT_ROUND( psDD->Q_Q10[ last_smple_idx ], 10 );
   12328:	1252      	asrs	r2, r2, #9
   1232a:	f8d7 10a8 	ldr.w	r1, [r7, #168]	; 0xa8
            xq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   1232e:	11db      	asrs	r3, r3, #7
            pulses[  i - decisionDelay ] = (opus_int8)silk_RSHIFT_ROUND( psDD->Q_Q10[ last_smple_idx ], 10 );
   12330:	3201      	adds	r2, #1
            xq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   12332:	3301      	adds	r3, #1
            pulses[  i - decisionDelay ] = (opus_int8)silk_RSHIFT_ROUND( psDD->Q_Q10[ last_smple_idx ], 10 );
   12334:	1052      	asrs	r2, r2, #1
            xq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   12336:	105b      	asrs	r3, r3, #1
            pulses[  i - decisionDelay ] = (opus_int8)silk_RSHIFT_ROUND( psDD->Q_Q10[ last_smple_idx ], 10 );
   12338:	f801 2b01 	strb.w	r2, [r1], #1
            xq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   1233c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
            pulses[  i - decisionDelay ] = (opus_int8)silk_RSHIFT_ROUND( psDD->Q_Q10[ last_smple_idx ], 10 );
   12340:	f8c7 10a8 	str.w	r1, [r7, #168]	; 0xa8
            xq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   12344:	f280 8136 	bge.w	125b4 <silk_NSQ_del_dec_c+0x1378>
   12348:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   1234c:	f2c0 8165 	blt.w	1261a <silk_NSQ_del_dec_c+0x13de>
   12350:	b21b      	sxth	r3, r3
            NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx - decisionDelay ] = psDD->Shape_Q14[ last_smple_idx ];
   12352:	f8d7 60e0 	ldr.w	r6, [r7, #224]	; 0xe0
   12356:	f8d5 4400 	ldr.w	r4, [r5, #1024]	; 0x400
            sLTP_Q15[          NSQ->sLTP_buf_idx     - decisionDelay ] = psDD->Pred_Q15[  last_smple_idx ];
   1235a:	f8d5 0360 	ldr.w	r0, [r5, #864]	; 0x360
   1235e:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
            xq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   12362:	f8d7 50a4 	ldr.w	r5, [r7, #164]	; 0xa4
            NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx - decisionDelay ] = psDD->Shape_Q14[ last_smple_idx ];
   12366:	6831      	ldr	r1, [r6, #0]
            sLTP_Q15[          NSQ->sLTP_buf_idx     - decisionDelay ] = psDD->Pred_Q15[  last_smple_idx ];
   12368:	6812      	ldr	r2, [r2, #0]
            xq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   1236a:	f825 3b02 	strh.w	r3, [r5], #2
   1236e:	f8c7 50a4 	str.w	r5, [r7, #164]	; 0xa4
            NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx - decisionDelay ] = psDD->Shape_Q14[ last_smple_idx ];
   12372:	f8d7 50ec 	ldr.w	r5, [r7, #236]	; 0xec
   12376:	1b4b      	subs	r3, r1, r5
   12378:	f503 73a0 	add.w	r3, r3, #320	; 0x140
        NSQ->sLTP_shp_buf_idx++;
   1237c:	f101 0c01 	add.w	ip, r1, #1
            NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx - decisionDelay ] = psDD->Shape_Q14[ last_smple_idx ];
   12380:	f8d7 10bc 	ldr.w	r1, [r7, #188]	; 0xbc
   12384:	f841 4023 	str.w	r4, [r1, r3, lsl #2]
            sLTP_Q15[          NSQ->sLTP_buf_idx     - decisionDelay ] = psDD->Pred_Q15[  last_smple_idx ];
   12388:	1b53      	subs	r3, r2, r5
   1238a:	f8d7 10a0 	ldr.w	r1, [r7, #160]	; 0xa0
        NSQ->sLTP_shp_buf_idx++;
   1238e:	f8c6 c000 	str.w	ip, [r6]
            sLTP_Q15[          NSQ->sLTP_buf_idx     - decisionDelay ] = psDD->Pred_Q15[  last_smple_idx ];
   12392:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
        NSQ->sLTP_buf_idx++;
   12396:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
   1239a:	3201      	adds	r2, #1
   1239c:	601a      	str	r2, [r3, #0]
        for( k = 0; k < nStatesDelayedDecision; k++ ) {
   1239e:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
   123a2:	2b00      	cmp	r3, #0
   123a4:	dd35      	ble.n	12412 <silk_NSQ_del_dec_c+0x11d6>
   123a6:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
   123aa:	f8d7 1148 	ldr.w	r1, [r7, #328]	; 0x148
   123ae:	f8d7 4158 	ldr.w	r4, [r7, #344]	; 0x158
   123b2:	f8d7 60cc 	ldr.w	r6, [r7, #204]	; 0xcc
   123b6:	f8d7 c138 	ldr.w	ip, [r7, #312]	; 0x138
   123ba:	eb03 0581 	add.w	r5, r3, r1, lsl #2
            psDD->Diff_Q14                           = psSS->Diff_Q14;
   123be:	e9d4 0103 	ldrd	r0, r1, [r4, #12]
            psDD->Pred_Q15[  *smpl_buf_idx ]         = silk_LSHIFT32( psSS->LPC_exc_Q14, 1 );
   123c2:	69a2      	ldr	r2, [r4, #24]
            psDD->LF_AR_Q14                          = psSS->LF_AR_Q14;
   123c4:	f8c3 0500 	str.w	r0, [r3, #1280]	; 0x500
            psDD->Diff_Q14                           = psSS->Diff_Q14;
   123c8:	f8c3 1504 	str.w	r1, [r3, #1284]	; 0x504
            psDD->sLPC_Q14[ NSQ_LPC_BUF_LENGTH + i ] = psSS->xq_Q14;
   123cc:	68a0      	ldr	r0, [r4, #8]
   123ce:	f843 0026 	str.w	r0, [r3, r6, lsl #2]
            psDD->Pred_Q15[  *smpl_buf_idx ]         = silk_LSHIFT32( psSS->LPC_exc_Q14, 1 );
   123d2:	0051      	lsls	r1, r2, #1
   123d4:	f8c5 1360 	str.w	r1, [r5, #864]	; 0x360
            psDD->Q_Q10[     *smpl_buf_idx ]         = psSS->Q_Q10;
   123d8:	6822      	ldr	r2, [r4, #0]
            psDD->Shape_Q14[ *smpl_buf_idx ]         = psSS->sLTP_shp_Q14;
   123da:	6961      	ldr	r1, [r4, #20]
            psDD->Xq_Q14[    *smpl_buf_idx ]         = psSS->xq_Q14;
   123dc:	f8c5 02c0 	str.w	r0, [r5, #704]	; 0x2c0
            psDD->Q_Q10[     *smpl_buf_idx ]         = psSS->Q_Q10;
   123e0:	f8c5 2220 	str.w	r2, [r5, #544]	; 0x220
            psDD->Shape_Q14[ *smpl_buf_idx ]         = psSS->sLTP_shp_Q14;
   123e4:	f8c5 1400 	str.w	r1, [r5, #1024]	; 0x400
            psDD->Seed                               = silk_ADD32_ovflw( psDD->Seed, silk_RSHIFT_ROUND( psSS->Q_Q10, 10 ) );
   123e8:	f8d3 1508 	ldr.w	r1, [r3, #1288]	; 0x508
            psDD->RD_Q10                             = psSS->RD_Q10;
   123ec:	6860      	ldr	r0, [r4, #4]
            psDD->Seed                               = silk_ADD32_ovflw( psDD->Seed, silk_RSHIFT_ROUND( psSS->Q_Q10, 10 ) );
   123ee:	1252      	asrs	r2, r2, #9
   123f0:	3201      	adds	r2, #1
   123f2:	eb01 0262 	add.w	r2, r1, r2, asr #1
   123f6:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
            psDD->RandState[ *smpl_buf_idx ]         = psDD->Seed;
   123fa:	f8c5 2180 	str.w	r2, [r5, #384]	; 0x180
   123fe:	f203 5314 	addw	r3, r3, #1300	; 0x514
            psDD->RD_Q10                             = psSS->RD_Q10;
   12402:	f843 0c04 	str.w	r0, [r3, #-4]
        for( k = 0; k < nStatesDelayedDecision; k++ ) {
   12406:	4563      	cmp	r3, ip
   12408:	f205 5514 	addw	r5, r5, #1300	; 0x514
   1240c:	f104 0438 	add.w	r4, r4, #56	; 0x38
   12410:	d1d5      	bne.n	123be <silk_NSQ_del_dec_c+0x1182>
        delayedGain_Q10[     *smpl_buf_idx ]         = Gain_Q10;
   12412:	f507 7310 	add.w	r3, r7, #576	; 0x240
   12416:	4498      	add	r8, r3
   12418:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
   1241c:	f848 1ca0 	str.w	r1, [r8, #-160]
   12420:	f8d7 10b4 	ldr.w	r1, [r7, #180]	; 0xb4
    for( i = 0; i < length; i++ ) {
   12424:	f8d7 20cc 	ldr.w	r2, [r7, #204]	; 0xcc
   12428:	3904      	subs	r1, #4
   1242a:	f8c7 10b4 	str.w	r1, [r7, #180]	; 0xb4
   1242e:	f8d7 10d8 	ldr.w	r1, [r7, #216]	; 0xd8
   12432:	3104      	adds	r1, #4
   12434:	f8c7 10d8 	str.w	r1, [r7, #216]	; 0xd8
   12438:	f8d7 1140 	ldr.w	r1, [r7, #320]	; 0x140
   1243c:	3101      	adds	r1, #1
   1243e:	f8c7 1140 	str.w	r1, [r7, #320]	; 0x140
   12442:	f8d7 10d4 	ldr.w	r1, [r7, #212]	; 0xd4
   12446:	3104      	adds	r1, #4
   12448:	f8c7 10d4 	str.w	r1, [r7, #212]	; 0xd4
   1244c:	f8d7 109c 	ldr.w	r1, [r7, #156]	; 0x9c
   12450:	f1a2 030f 	sub.w	r3, r2, #15
   12454:	4299      	cmp	r1, r3
   12456:	f102 0201 	add.w	r2, r2, #1
   1245a:	f340 81a1 	ble.w	127a0 <silk_NSQ_del_dec_c+0x1564>
        if( signalType == TYPE_VOICED ) {
   1245e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
    for( i = 0; i < length; i++ ) {
   12462:	f8c7 20cc 	str.w	r2, [r7, #204]	; 0xcc
        if( signalType == TYPE_VOICED ) {
   12466:	2b02      	cmp	r3, #2
   12468:	f47f abfd 	bne.w	11c66 <silk_NSQ_del_dec_c+0xa2a>
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[  0 ], b_Q14[ 0 ] );
   1246c:	f8d7 6084 	ldr.w	r6, [r7, #132]	; 0x84
   12470:	f8d7 10e4 	ldr.w	r1, [r7, #228]	; 0xe4
   12474:	6835      	ldr	r5, [r6, #0]
   12476:	f9b1 2000 	ldrsh.w	r2, [r1]
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -1 ], b_Q14[ 1 ] );
   1247a:	f856 3c04 	ldr.w	r3, [r6, #-4]
   1247e:	f9b1 1002 	ldrsh.w	r1, [r1, #2]
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -2 ], b_Q14[ 2 ] );
   12482:	f856 0c08 	ldr.w	r0, [r6, #-8]
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[  0 ], b_Q14[ 0 ] );
   12486:	b2ac      	uxth	r4, r5
   12488:	142d      	asrs	r5, r5, #16
   1248a:	fb02 f404 	mul.w	r4, r2, r4
   1248e:	fb02 f205 	mul.w	r2, r2, r5
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -1 ], b_Q14[ 1 ] );
   12492:	b29d      	uxth	r5, r3
   12494:	141b      	asrs	r3, r3, #16
   12496:	fb01 f505 	mul.w	r5, r1, r5
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[  0 ], b_Q14[ 0 ] );
   1249a:	eb02 4224 	add.w	r2, r2, r4, asr #16
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -1 ], b_Q14[ 1 ] );
   1249e:	fb01 f303 	mul.w	r3, r1, r3
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -2 ], b_Q14[ 2 ] );
   124a2:	f8d7 40e4 	ldr.w	r4, [r7, #228]	; 0xe4
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[  0 ], b_Q14[ 0 ] );
   124a6:	3202      	adds	r2, #2
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -1 ], b_Q14[ 1 ] );
   124a8:	eb03 4325 	add.w	r3, r3, r5, asr #16
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -2 ], b_Q14[ 2 ] );
   124ac:	f9b4 1004 	ldrsh.w	r1, [r4, #4]
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -3 ], b_Q14[ 3 ] );
   124b0:	f856 4c0c 	ldr.w	r4, [r6, #-12]
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -1 ], b_Q14[ 1 ] );
   124b4:	4413      	add	r3, r2
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -3 ], b_Q14[ 3 ] );
   124b6:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -2 ], b_Q14[ 2 ] );
   124ba:	b285      	uxth	r5, r0
   124bc:	1400      	asrs	r0, r0, #16
   124be:	fb01 f505 	mul.w	r5, r1, r5
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -3 ], b_Q14[ 3 ] );
   124c2:	f9b2 2006 	ldrsh.w	r2, [r2, #6]
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -2 ], b_Q14[ 2 ] );
   124c6:	fb01 f100 	mul.w	r1, r1, r0
   124ca:	eb01 4125 	add.w	r1, r1, r5, asr #16
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -3 ], b_Q14[ 3 ] );
   124ce:	b2a5      	uxth	r5, r4
   124d0:	1424      	asrs	r4, r4, #16
   124d2:	fb02 f505 	mul.w	r5, r2, r5
   124d6:	fb02 f204 	mul.w	r2, r2, r4
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -4 ], b_Q14[ 4 ] );
   124da:	f8d7 40e4 	ldr.w	r4, [r7, #228]	; 0xe4
   124de:	f856 0c10 	ldr.w	r0, [r6, #-16]
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -2 ], b_Q14[ 2 ] );
   124e2:	4419      	add	r1, r3
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -4 ], b_Q14[ 4 ] );
   124e4:	f9b4 3008 	ldrsh.w	r3, [r4, #8]
   124e8:	b284      	uxth	r4, r0
   124ea:	1400      	asrs	r0, r0, #16
   124ec:	fb03 f404 	mul.w	r4, r3, r4
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -3 ], b_Q14[ 3 ] );
   124f0:	eb02 4225 	add.w	r2, r2, r5, asr #16
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -4 ], b_Q14[ 4 ] );
   124f4:	fb03 f300 	mul.w	r3, r3, r0
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -3 ], b_Q14[ 3 ] );
   124f8:	440a      	add	r2, r1
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -4 ], b_Q14[ 4 ] );
   124fa:	eb03 4324 	add.w	r3, r3, r4, asr #16
   124fe:	4413      	add	r3, r2
            LTP_pred_Q14 = silk_LSHIFT( LTP_pred_Q14, 1 );                          /* Q13 -> Q14 */
   12500:	005b      	lsls	r3, r3, #1
   12502:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
        if( lag > 0 ) {
   12506:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
            pred_lag_ptr++;
   1250a:	1d32      	adds	r2, r6, #4
        if( lag > 0 ) {
   1250c:	2b00      	cmp	r3, #0
            pred_lag_ptr++;
   1250e:	f8c7 2084 	str.w	r2, [r7, #132]	; 0x84
        if( lag > 0 ) {
   12512:	f73f abb0 	bgt.w	11c76 <silk_NSQ_del_dec_c+0xa3a>
            n_LTP_Q14 = 0;
   12516:	2300      	movs	r3, #0
   12518:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
   1251c:	f7ff bbcf 	b.w	11cbe <silk_NSQ_del_dec_c+0xa82>
                psSS[ 0 ].RD_Q10 = silk_ADD32( psDD->RD_Q10, rd2_Q10 );
   12520:	f8d7 3198 	ldr.w	r3, [r7, #408]	; 0x198
   12524:	f8c3 e004 	str.w	lr, [r3, #4]
                psSS[ 1 ].RD_Q10 = silk_ADD32( psDD->RD_Q10, rd1_Q10 );
   12528:	6219      	str	r1, [r3, #32]
                psSS[ 0 ].Q_Q10  = q2_Q10;
   1252a:	601e      	str	r6, [r3, #0]
                psSS[ 1 ].Q_Q10  = q1_Q10;
   1252c:	61d8      	str	r0, [r3, #28]
   1252e:	e628      	b.n	12182 <silk_NSQ_del_dec_c+0xf46>
            q1_Q0 = silk_RSHIFT( q1_Q10, 10 );
   12530:	1290      	asrs	r0, r2, #10
            if( q1_Q0 > 0 ) {
   12532:	2800      	cmp	r0, #0
   12534:	f73f adf8 	bgt.w	12128 <silk_NSQ_del_dec_c+0xeec>
            } else if( q1_Q0 == 0 ) {
   12538:	d114      	bne.n	12564 <silk_NSQ_del_dec_c+0x1328>
   1253a:	f8d7 60c4 	ldr.w	r6, [r7, #196]	; 0xc4
            psSS[ 0 ].Diff_Q14     = silk_SUB_LSHIFT32( xq_Q14, x_Q10[ i ], 4 );
   1253e:	f8d7 0194 	ldr.w	r0, [r7, #404]	; 0x194
                rd2_Q10 = silk_SMULBB( q2_Q10, Lambda_Q10 );
   12542:	f8d7 e0c0 	ldr.w	lr, [r7, #192]	; 0xc0
   12546:	1b99      	subs	r1, r3, r6
            psSS[ 0 ].Diff_Q14     = silk_SUB_LSHIFT32( xq_Q14, x_Q10[ i ], 4 );
   12548:	4605      	mov	r5, r0
   1254a:	46b4      	mov	ip, r6
                rd1_Q10 = silk_SMULBB( q1_Q10, Lambda_Q10 );
   1254c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
   12550:	e5fb      	b.n	1214a <silk_NSQ_del_dec_c+0xf0e>
                } else if (q1_Q10 < -rdo_offset) {
   12552:	f8d7 10d0 	ldr.w	r1, [r7, #208]	; 0xd0
   12556:	4291      	cmp	r1, r2
   12558:	dd1d      	ble.n	12596 <silk_NSQ_del_dec_c+0x135a>
                    q1_Q0 = silk_RSHIFT( q1_Q10 + rdo_offset, 10 );
   1255a:	f8d7 113c 	ldr.w	r1, [r7, #316]	; 0x13c
   1255e:	1888      	adds	r0, r1, r2
   12560:	1280      	asrs	r0, r0, #10
   12562:	e5d7      	b.n	12114 <silk_NSQ_del_dec_c+0xed8>
            } else if( q1_Q0 == -1 ) {
   12564:	1c41      	adds	r1, r0, #1
   12566:	d018      	beq.n	1259a <silk_NSQ_del_dec_c+0x135e>
                q1_Q10  = silk_ADD32( silk_LSHIFT( q1_Q0, 10 ), QUANT_LEVEL_ADJUST_Q10 );
   12568:	f8d7 2194 	ldr.w	r2, [r7, #404]	; 0x194
   1256c:	eb02 2080 	add.w	r0, r2, r0, lsl #10
                q1_Q10  = silk_ADD32( q1_Q10, offset_Q10 );
   12570:	3050      	adds	r0, #80	; 0x50
                q2_Q10  = silk_ADD32( q1_Q10, 1024 );
   12572:	f500 6680 	add.w	r6, r0, #1024	; 0x400
                rd2_Q10 = silk_SMULBB( -q2_Q10, Lambda_Q10 );
   12576:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
   1257a:	f1c6 0e00 	rsb	lr, r6, #0
   1257e:	fb1e fe02 	smulbb	lr, lr, r2
   12582:	1b99      	subs	r1, r3, r6
   12584:	1a1a      	subs	r2, r3, r0
                rd1_Q10 = silk_SMULBB( -q1_Q10, Lambda_Q10 );
   12586:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
   1258a:	4245      	negs	r5, r0
   1258c:	fb15 f303 	smulbb	r3, r5, r3
   12590:	46b4      	mov	ip, r6
   12592:	4605      	mov	r5, r0
   12594:	e5d9      	b.n	1214a <silk_NSQ_del_dec_c+0xf0e>
                } else if (q1_Q10 < 0) {
   12596:	2a00      	cmp	r2, #0
   12598:	dacf      	bge.n	1253a <silk_NSQ_del_dec_c+0x12fe>
                rd1_Q10 = silk_SMULBB( q1_Q10, Lambda_Q10 );
   1259a:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
   1259c:	f8d7 6194 	ldr.w	r6, [r7, #404]	; 0x194
                rd2_Q10 = silk_SMULBB(  q2_Q10, Lambda_Q10 );
   125a0:	f8d7 e0dc 	ldr.w	lr, [r7, #220]	; 0xdc
            q1_Q10 = silk_SUB32( r_Q10, offset_Q10 );
   125a4:	4611      	mov	r1, r2
                rd1_Q10 = silk_SMULBB( q1_Q10, Lambda_Q10 );
   125a6:	4605      	mov	r5, r0
            q1_Q10 = silk_SUB32( r_Q10, offset_Q10 );
   125a8:	1a1a      	subs	r2, r3, r0
                rd1_Q10 = silk_SMULBB( q1_Q10, Lambda_Q10 );
   125aa:	46b4      	mov	ip, r6
                rd1_Q10 = silk_SMULBB( -q1_Q10, Lambda_Q10 );
   125ac:	6f3b      	ldr	r3, [r7, #112]	; 0x70
   125ae:	e5cc      	b.n	1214a <silk_NSQ_del_dec_c+0xf0e>
   125b0:	66666667 	.word	0x66666667
            xq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   125b4:	f647 73ff 	movw	r3, #32767	; 0x7fff
   125b8:	e6cb      	b.n	12352 <silk_NSQ_del_dec_c+0x1116>
        if( *smpl_buf_idx < 0 ) *smpl_buf_idx += DECISION_DELAY;
   125ba:	2327      	movs	r3, #39	; 0x27
   125bc:	f04f 089c 	mov.w	r8, #156	; 0x9c
   125c0:	f8c7 3148 	str.w	r3, [r7, #328]	; 0x148
   125c4:	461a      	mov	r2, r3
   125c6:	e628      	b.n	1221a <silk_NSQ_del_dec_c+0xfde>
   125c8:	f8d7 1144 	ldr.w	r1, [r7, #324]	; 0x144
   125cc:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
   125d0:	1a5b      	subs	r3, r3, r1
   125d2:	f1a3 023c 	sub.w	r2, r3, #60	; 0x3c
            silk_memcpy( ( (opus_int32 *)&psDelDec[ RDmax_ind ] ) + i,
   125d6:	f240 5314 	movw	r3, #1300	; 0x514
   125da:	fb03 2006 	mla	r0, r3, r6, r2
   125de:	fb03 2309 	mla	r3, r3, r9, r2
   125e2:	4408      	add	r0, r1
   125e4:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
   125e8:	4419      	add	r1, r3
   125ea:	f7f9 fd89 	bl	c100 <memcpy>
            silk_memcpy( &psSampleState[ RDmax_ind ][ 0 ], &psSampleState[ RDmin_ind ][ 1 ], sizeof( NSQ_sample_struct ) );
   125ee:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
   125f2:	ebc9 0cc9 	rsb	ip, r9, r9, lsl #3
   125f6:	eb03 0ccc 	add.w	ip, r3, ip, lsl #3
   125fa:	f10c 0c1c 	add.w	ip, ip, #28
   125fe:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   12602:	ebc6 0ec6 	rsb	lr, r6, r6, lsl #3
   12606:	f8d7 6158 	ldr.w	r6, [r7, #344]	; 0x158
   1260a:	eb06 06ce 	add.w	r6, r6, lr, lsl #3
   1260e:	c60f      	stmia	r6!, {r0, r1, r2, r3}
   12610:	e89c 0007 	ldmia.w	ip, {r0, r1, r2}
   12614:	e886 0007 	stmia.w	r6, {r0, r1, r2}
   12618:	e66e      	b.n	122f8 <silk_NSQ_del_dec_c+0x10bc>
            xq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   1261a:	4b8d      	ldr	r3, [pc, #564]	; (12850 <silk_NSQ_del_dec_c+0x1614>)
   1261c:	e699      	b.n	12352 <silk_NSQ_del_dec_c+0x1116>
        RDmin_Q10  = psSampleState[ 0 ][ 1 ].RD_Q10;
   1261e:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
   12622:	f8d7 5144 	ldr.w	r5, [r7, #324]	; 0x144
   12626:	f8d3 c020 	ldr.w	ip, [r3, #32]
        RDmin_ind = 0;
   1262a:	f04f 0900 	mov.w	r9, #0
        RDmax_ind = 0;
   1262e:	464e      	mov	r6, r9
        if( RDmin_Q10 < RDmax_Q10 ) {
   12630:	458c      	cmp	ip, r1
   12632:	f2c0 848a 	blt.w	12f4a <silk_NSQ_del_dec_c+0x1d0e>
        if( subfr > 0 || i >= decisionDelay ) {
   12636:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
   1263a:	2b00      	cmp	r3, #0
   1263c:	f000 84b4 	beq.w	12fa8 <silk_NSQ_del_dec_c+0x1d6c>
   12640:	00a4      	lsls	r4, r4, #2
            xq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   12642:	f507 7310 	add.w	r3, r7, #576	; 0x240
   12646:	4425      	add	r5, r4
   12648:	441c      	add	r4, r3
   1264a:	f8d5 02c0 	ldr.w	r0, [r5, #704]	; 0x2c0
   1264e:	f854 3ca0 	ldr.w	r3, [r4, #-160]
            pulses[  i - decisionDelay ] = (opus_int8)silk_RSHIFT_ROUND( psDD->Q_Q10[ last_smple_idx ], 10 );
   12652:	f8d5 2220 	ldr.w	r2, [r5, #544]	; 0x220
            xq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   12656:	b21e      	sxth	r6, r3
   12658:	b284      	uxth	r4, r0
   1265a:	1401      	asrs	r1, r0, #16
   1265c:	13db      	asrs	r3, r3, #15
   1265e:	fb06 f101 	mul.w	r1, r6, r1
   12662:	3301      	adds	r3, #1
   12664:	fb06 f404 	mul.w	r4, r6, r4
   12668:	eb01 4424 	add.w	r4, r1, r4, asr #16
   1266c:	105b      	asrs	r3, r3, #1
   1266e:	fb00 4303 	mla	r3, r0, r3, r4
   12672:	11db      	asrs	r3, r3, #7
            pulses[  i - decisionDelay ] = (opus_int8)silk_RSHIFT_ROUND( psDD->Q_Q10[ last_smple_idx ], 10 );
   12674:	f8d7 00ec 	ldr.w	r0, [r7, #236]	; 0xec
   12678:	f8d7 1268 	ldr.w	r1, [r7, #616]	; 0x268
   1267c:	1252      	asrs	r2, r2, #9
            xq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   1267e:	3301      	adds	r3, #1
            pulses[  i - decisionDelay ] = (opus_int8)silk_RSHIFT_ROUND( psDD->Q_Q10[ last_smple_idx ], 10 );
   12680:	1a09      	subs	r1, r1, r0
   12682:	3201      	adds	r2, #1
            xq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   12684:	105b      	asrs	r3, r3, #1
            pulses[  i - decisionDelay ] = (opus_int8)silk_RSHIFT_ROUND( psDD->Q_Q10[ last_smple_idx ], 10 );
   12686:	f8d7 00f0 	ldr.w	r0, [r7, #240]	; 0xf0
   1268a:	1052      	asrs	r2, r2, #1
            xq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   1268c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
            pulses[  i - decisionDelay ] = (opus_int8)silk_RSHIFT_ROUND( psDD->Q_Q10[ last_smple_idx ], 10 );
   12690:	540a      	strb	r2, [r1, r0]
            xq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   12692:	f280 84de 	bge.w	13052 <silk_NSQ_del_dec_c+0x1e16>
   12696:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   1269a:	f2c0 853c 	blt.w	13116 <silk_NSQ_del_dec_c+0x1eda>
   1269e:	b21b      	sxth	r3, r3
   126a0:	4606      	mov	r6, r0
            NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx - decisionDelay ] = psDD->Shape_Q14[ last_smple_idx ];
   126a2:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
   126a6:	f8d5 0400 	ldr.w	r0, [r5, #1024]	; 0x400
   126aa:	6811      	ldr	r1, [r2, #0]
            sLTP_Q15[          NSQ->sLTP_buf_idx     - decisionDelay ] = psDD->Pred_Q15[  last_smple_idx ];
   126ac:	f8d5 4360 	ldr.w	r4, [r5, #864]	; 0x360
   126b0:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
            xq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   126b4:	f8d7 50a8 	ldr.w	r5, [r7, #168]	; 0xa8
            sLTP_Q15[          NSQ->sLTP_buf_idx     - decisionDelay ] = psDD->Pred_Q15[  last_smple_idx ];
   126b8:	6812      	ldr	r2, [r2, #0]
            xq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   126ba:	f825 3016 	strh.w	r3, [r5, r6, lsl #1]
            NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx - decisionDelay ] = psDD->Shape_Q14[ last_smple_idx ];
   126be:	f8d7 50ec 	ldr.w	r5, [r7, #236]	; 0xec
   126c2:	f8d7 60bc 	ldr.w	r6, [r7, #188]	; 0xbc
   126c6:	1b4b      	subs	r3, r1, r5
   126c8:	f503 73a0 	add.w	r3, r3, #320	; 0x140
            sLTP_Q15[          NSQ->sLTP_buf_idx     - decisionDelay ] = psDD->Pred_Q15[  last_smple_idx ];
   126cc:	1b55      	subs	r5, r2, r5
            NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx - decisionDelay ] = psDD->Shape_Q14[ last_smple_idx ];
   126ce:	f846 0023 	str.w	r0, [r6, r3, lsl #2]
            sLTP_Q15[          NSQ->sLTP_buf_idx     - decisionDelay ] = psDD->Pred_Q15[  last_smple_idx ];
   126d2:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
   126d6:	f843 4025 	str.w	r4, [r3, r5, lsl #2]
        NSQ->sLTP_shp_buf_idx++;
   126da:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
   126de:	3101      	adds	r1, #1
   126e0:	6019      	str	r1, [r3, #0]
        NSQ->sLTP_buf_idx++;
   126e2:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
   126e6:	3201      	adds	r2, #1
   126e8:	601a      	str	r2, [r3, #0]
        for( k = 0; k < nStatesDelayedDecision; k++ ) {
   126ea:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
   126ee:	2b00      	cmp	r3, #0
   126f0:	dd35      	ble.n	1275e <silk_NSQ_del_dec_c+0x1522>
   126f2:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
   126f6:	f8d7 1148 	ldr.w	r1, [r7, #328]	; 0x148
   126fa:	f8d7 4158 	ldr.w	r4, [r7, #344]	; 0x158
   126fe:	f8d7 60d8 	ldr.w	r6, [r7, #216]	; 0xd8
   12702:	f8d7 c140 	ldr.w	ip, [r7, #320]	; 0x140
   12706:	eb03 0581 	add.w	r5, r3, r1, lsl #2
            psDD->Diff_Q14                           = psSS->Diff_Q14;
   1270a:	e9d4 0103 	ldrd	r0, r1, [r4, #12]
            psDD->Pred_Q15[  *smpl_buf_idx ]         = silk_LSHIFT32( psSS->LPC_exc_Q14, 1 );
   1270e:	69a2      	ldr	r2, [r4, #24]
            psDD->LF_AR_Q14                          = psSS->LF_AR_Q14;
   12710:	f8c3 0500 	str.w	r0, [r3, #1280]	; 0x500
            psDD->Diff_Q14                           = psSS->Diff_Q14;
   12714:	f8c3 1504 	str.w	r1, [r3, #1284]	; 0x504
            psDD->sLPC_Q14[ NSQ_LPC_BUF_LENGTH + i ] = psSS->xq_Q14;
   12718:	68a0      	ldr	r0, [r4, #8]
   1271a:	f843 0026 	str.w	r0, [r3, r6, lsl #2]
            psDD->Pred_Q15[  *smpl_buf_idx ]         = silk_LSHIFT32( psSS->LPC_exc_Q14, 1 );
   1271e:	0051      	lsls	r1, r2, #1
   12720:	f8c5 1360 	str.w	r1, [r5, #864]	; 0x360
            psDD->Q_Q10[     *smpl_buf_idx ]         = psSS->Q_Q10;
   12724:	6822      	ldr	r2, [r4, #0]
            psDD->Shape_Q14[ *smpl_buf_idx ]         = psSS->sLTP_shp_Q14;
   12726:	6961      	ldr	r1, [r4, #20]
            psDD->Xq_Q14[    *smpl_buf_idx ]         = psSS->xq_Q14;
   12728:	f8c5 02c0 	str.w	r0, [r5, #704]	; 0x2c0
            psDD->Q_Q10[     *smpl_buf_idx ]         = psSS->Q_Q10;
   1272c:	f8c5 2220 	str.w	r2, [r5, #544]	; 0x220
            psDD->Shape_Q14[ *smpl_buf_idx ]         = psSS->sLTP_shp_Q14;
   12730:	f8c5 1400 	str.w	r1, [r5, #1024]	; 0x400
            psDD->Seed                               = silk_ADD32_ovflw( psDD->Seed, silk_RSHIFT_ROUND( psSS->Q_Q10, 10 ) );
   12734:	f8d3 1508 	ldr.w	r1, [r3, #1288]	; 0x508
            psDD->RD_Q10                             = psSS->RD_Q10;
   12738:	6860      	ldr	r0, [r4, #4]
            psDD->Seed                               = silk_ADD32_ovflw( psDD->Seed, silk_RSHIFT_ROUND( psSS->Q_Q10, 10 ) );
   1273a:	1252      	asrs	r2, r2, #9
   1273c:	3201      	adds	r2, #1
   1273e:	eb01 0262 	add.w	r2, r1, r2, asr #1
   12742:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
            psDD->RandState[ *smpl_buf_idx ]         = psDD->Seed;
   12746:	f8c5 2180 	str.w	r2, [r5, #384]	; 0x180
   1274a:	f203 5314 	addw	r3, r3, #1300	; 0x514
            psDD->RD_Q10                             = psSS->RD_Q10;
   1274e:	f843 0c04 	str.w	r0, [r3, #-4]
        for( k = 0; k < nStatesDelayedDecision; k++ ) {
   12752:	459c      	cmp	ip, r3
   12754:	f205 5514 	addw	r5, r5, #1300	; 0x514
   12758:	f104 0438 	add.w	r4, r4, #56	; 0x38
   1275c:	d1d5      	bne.n	1270a <silk_NSQ_del_dec_c+0x14ce>
        delayedGain_Q10[     *smpl_buf_idx ]         = Gain_Q10;
   1275e:	f507 7310 	add.w	r3, r7, #576	; 0x240
   12762:	4498      	add	r8, r3
   12764:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
   12768:	f848 2ca0 	str.w	r2, [r8, #-160]
   1276c:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
    for( i = 0; i < length; i++ ) {
   12770:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
   12774:	3201      	adds	r2, #1
   12776:	f8c7 20d8 	str.w	r2, [r7, #216]	; 0xd8
   1277a:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
   1277e:	3201      	adds	r2, #1
   12780:	f8c7 214c 	str.w	r2, [r7, #332]	; 0x14c
   12784:	f8d7 20cc 	ldr.w	r2, [r7, #204]	; 0xcc
   12788:	3301      	adds	r3, #1
   1278a:	4293      	cmp	r3, r2
   1278c:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
   12790:	f2c0 808e 	blt.w	128b0 <silk_NSQ_del_dec_c+0x1674>
   12794:	461a      	mov	r2, r3
   12796:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
   1279a:	4293      	cmp	r3, r2
   1279c:	f73f aa24 	bgt.w	11be8 <silk_NSQ_del_dec_c+0x9ac>
    for( k = 0; k < nStatesDelayedDecision; k++ ) {
   127a0:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
   127a4:	2b00      	cmp	r3, #0
   127a6:	dd1d      	ble.n	127e4 <silk_NSQ_del_dec_c+0x15a8>
   127a8:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
   127ac:	ea4f 0882 	mov.w	r8, r2, lsl #2
   127b0:	f8d7 2144 	ldr.w	r2, [r7, #324]	; 0x144
   127b4:	f240 5914 	movw	r9, #1300	; 0x514
   127b8:	fb09 2903 	mla	r9, r9, r3, r2
   127bc:	4694      	mov	ip, r2
        silk_memcpy( psDD->sLPC_Q14, &psDD->sLPC_Q14[ length ], NSQ_LPC_BUF_LENGTH * sizeof( opus_int32 ) );
   127be:	eb08 040c 	add.w	r4, r8, ip
   127c2:	f104 0e40 	add.w	lr, r4, #64	; 0x40
   127c6:	4666      	mov	r6, ip
   127c8:	6820      	ldr	r0, [r4, #0]
   127ca:	6861      	ldr	r1, [r4, #4]
   127cc:	68a2      	ldr	r2, [r4, #8]
   127ce:	68e3      	ldr	r3, [r4, #12]
   127d0:	4635      	mov	r5, r6
   127d2:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   127d4:	3410      	adds	r4, #16
   127d6:	4574      	cmp	r4, lr
   127d8:	462e      	mov	r6, r5
   127da:	d1f5      	bne.n	127c8 <silk_NSQ_del_dec_c+0x158c>
   127dc:	f20c 5c14 	addw	ip, ip, #1300	; 0x514
    for( k = 0; k < nStatesDelayedDecision; k++ ) {
   127e0:	45cc      	cmp	ip, r9
   127e2:	d1ec      	bne.n	127be <silk_NSQ_del_dec_c+0x1582>
   127e4:	f8d7 0170 	ldr.w	r0, [r7, #368]	; 0x170
        x16    += psEncC->subfr_length;
   127e8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    for( k = 0; k < psEncC->nb_subfr; k++ ) {
   127ea:	6b3a      	ldr	r2, [r7, #48]	; 0x30
        x16    += psEncC->subfr_length;
   127ec:	681b      	ldr	r3, [r3, #0]
    for( k = 0; k < psEncC->nb_subfr; k++ ) {
   127ee:	6fb9      	ldr	r1, [r7, #120]	; 0x78
   127f0:	6812      	ldr	r2, [r2, #0]
   127f2:	f8d7 d03c 	ldr.w	sp, [r7, #60]	; 0x3c
   127f6:	3030      	adds	r0, #48	; 0x30
   127f8:	f8c7 0170 	str.w	r0, [r7, #368]	; 0x170
   127fc:	f8d7 00e4 	ldr.w	r0, [r7, #228]	; 0xe4
   12800:	300a      	adds	r0, #10
   12802:	f8c7 00e4 	str.w	r0, [r7, #228]	; 0xe4
        pulses += psEncC->subfr_length;
   12806:	f8d7 0268 	ldr.w	r0, [r7, #616]	; 0x268
   1280a:	4418      	add	r0, r3
   1280c:	f8c7 0268 	str.w	r0, [r7, #616]	; 0x268
        x16    += psEncC->subfr_length;
   12810:	6e38      	ldr	r0, [r7, #96]	; 0x60
   12812:	005b      	lsls	r3, r3, #1
   12814:	4418      	add	r0, r3
   12816:	6638      	str	r0, [r7, #96]	; 0x60
        pxq    += psEncC->subfr_length;
   12818:	6eb8      	ldr	r0, [r7, #104]	; 0x68
    for( k = 0; k < psEncC->nb_subfr; k++ ) {
   1281a:	3101      	adds	r1, #1
        pxq    += psEncC->subfr_length;
   1281c:	4418      	add	r0, r3
    for( k = 0; k < psEncC->nb_subfr; k++ ) {
   1281e:	428a      	cmp	r2, r1
   12820:	67b9      	str	r1, [r7, #120]	; 0x78
        pxq    += psEncC->subfr_length;
   12822:	66b8      	str	r0, [r7, #104]	; 0x68
    for( k = 0; k < psEncC->nb_subfr; k++ ) {
   12824:	f340 8540 	ble.w	132a8 <silk_NSQ_del_dec_c+0x206c>
   12828:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   1282a:	f993 301d 	ldrsb.w	r3, [r3, #29]
   1282e:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
   12832:	460c      	mov	r4, r1
   12834:	f7fe be93 	b.w	1155e <silk_NSQ_del_dec_c+0x322>
        Winner_rand_state = psDelDec[ Winner_ind ].RandState[ last_smple_idx ];
   12838:	f104 0360 	add.w	r3, r4, #96	; 0x60
   1283c:	f8d7 2144 	ldr.w	r2, [r7, #324]	; 0x144
   12840:	f852 e023 	ldr.w	lr, [r2, r3, lsl #2]
        for( k = 0; k < nStatesDelayedDecision; k++ ) {
   12844:	f040 872b 	bne.w	1369e <silk_NSQ_del_dec_c+0x2462>
   12848:	4615      	mov	r5, r2
   1284a:	4613      	mov	r3, r2
   1284c:	e516      	b.n	1227c <silk_NSQ_del_dec_c+0x1040>
   1284e:	bf00      	nop
   12850:	ffff8000 	.word	0xffff8000
   12854:	1ed3      	subs	r3, r2, #3
   12856:	4611      	mov	r1, r2
   12858:	085a      	lsrs	r2, r3, #1
   1285a:	00d2      	lsls	r2, r2, #3
   1285c:	f8c7 20b4 	str.w	r2, [r7, #180]	; 0xb4
   12860:	f8d7 0144 	ldr.w	r0, [r7, #324]	; 0x144
   12864:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
   12868:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
   1286c:	f240 5314 	movw	r3, #1300	; 0x514
   12870:	fb03 0302 	mla	r3, r3, r2, r0
   12874:	3901      	subs	r1, #1
   12876:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
   1287a:	008b      	lsls	r3, r1, #2
   1287c:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
   12880:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
   12884:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
   12888:	65b9      	str	r1, [r7, #88]	; 0x58
   1288a:	4293      	cmp	r3, r2
   1288c:	bfa8      	it	ge
   1288e:	4613      	movge	r3, r2
   12890:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
   12894:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   12896:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   12898:	4413      	add	r3, r2
   1289a:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
            n_LF_Q14 = silk_SMLAWT( n_LF_Q14, psDD->LF_AR_Q14, LF_shp_Q14 );            /* Q12 */
   1289e:	230f      	movs	r3, #15
   128a0:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
   128a4:	2310      	movs	r3, #16
   128a6:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
    for( i = 0; i < length; i++ ) {
   128aa:	2300      	movs	r3, #0
   128ac:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
        if( signalType == TYPE_VOICED ) {
   128b0:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
   128b4:	2b02      	cmp	r3, #2
   128b6:	f000 83dc 	beq.w	13072 <silk_NSQ_del_dec_c+0x1e36>
            LTP_pred_Q14 = 0;
   128ba:	2300      	movs	r3, #0
   128bc:	f8c7 3188 	str.w	r3, [r7, #392]	; 0x188
        if( lag > 0 ) {
   128c0:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
   128c4:	2b00      	cmp	r3, #0
   128c6:	f340 83d0 	ble.w	1306a <silk_NSQ_del_dec_c+0x1e2e>
            n_LTP_Q14 = silk_SMULWB( silk_ADD32( shp_lag_ptr[ 0 ], shp_lag_ptr[ -2 ] ), HarmShapeFIRPacked_Q14 );
   128ca:	f8d7 40c8 	ldr.w	r4, [r7, #200]	; 0xc8
            n_LTP_Q14 = silk_SMLAWT( n_LTP_Q14, shp_lag_ptr[ -1 ],                      HarmShapeFIRPacked_Q14 );
   128ce:	e954 1302 	ldrd	r1, r3, [r4, #-8]
            n_LTP_Q14 = silk_SMULWB( silk_ADD32( shp_lag_ptr[ 0 ], shp_lag_ptr[ -2 ] ), HarmShapeFIRPacked_Q14 );
   128d2:	6822      	ldr	r2, [r4, #0]
   128d4:	440a      	add	r2, r1
   128d6:	1411      	asrs	r1, r2, #16
   128d8:	b290      	uxth	r0, r2
   128da:	f9b7 2088 	ldrsh.w	r2, [r7, #136]	; 0x88
   128de:	fb02 f000 	mul.w	r0, r2, r0
   128e2:	fb02 f201 	mul.w	r2, r2, r1
   128e6:	eb02 4220 	add.w	r2, r2, r0, asr #16
            n_LTP_Q14 = silk_SMLAWT( n_LTP_Q14, shp_lag_ptr[ -1 ],                      HarmShapeFIRPacked_Q14 );
   128ea:	f8d7 0080 	ldr.w	r0, [r7, #128]	; 0x80
   128ee:	1419      	asrs	r1, r3, #16
   128f0:	b29b      	uxth	r3, r3
   128f2:	fb00 2201 	mla	r2, r0, r1, r2
   128f6:	fb00 f303 	mul.w	r3, r0, r3
   128fa:	eb02 4323 	add.w	r3, r2, r3, asr #16
            shp_lag_ptr++;
   128fe:	1d22      	adds	r2, r4, #4
   12900:	f8c7 20c8 	str.w	r2, [r7, #200]	; 0xc8
            n_LTP_Q14 = silk_SUB_LSHIFT32( LTP_pred_Q14, n_LTP_Q14, 2 );            /* Q12 -> Q14 */
   12904:	f8d7 2188 	ldr.w	r2, [r7, #392]	; 0x188
   12908:	eba2 0383 	sub.w	r3, r2, r3, lsl #2
   1290c:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
        for( k = 0; k < nStatesDelayedDecision; k++ ) {
   12910:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
   12914:	2b00      	cmp	r3, #0
   12916:	f340 82a2 	ble.w	12e5e <silk_NSQ_del_dec_c+0x1c22>
   1291a:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
   1291c:	f8d7 20f0 	ldr.w	r2, [r7, #240]	; 0xf0
   12920:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    out = silk_SMLAWB( out, buf32[  0 ], coef16[ 0 ] );
   12924:	f8d7 3184 	ldr.w	r3, [r7, #388]	; 0x184
   12928:	f8c7 1100 	str.w	r1, [r7, #256]	; 0x100
   1292c:	f9b3 2000 	ldrsh.w	r2, [r3]
   12930:	f8c7 2134 	str.w	r2, [r7, #308]	; 0x134
    out = silk_SMLAWB( out, buf32[ -1 ], coef16[ 1 ] );
   12934:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
   12938:	f8c7 2130 	str.w	r2, [r7, #304]	; 0x130
    out = silk_SMLAWB( out, buf32[ -2 ], coef16[ 2 ] );
   1293c:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
   12940:	f8c7 212c 	str.w	r2, [r7, #300]	; 0x12c
    out = silk_SMLAWB( out, buf32[ -3 ], coef16[ 3 ] );
   12944:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
   12948:	f8c7 2128 	str.w	r2, [r7, #296]	; 0x128
    out = silk_SMLAWB( out, buf32[ -4 ], coef16[ 4 ] );
   1294c:	f9b3 2008 	ldrsh.w	r2, [r3, #8]
   12950:	f8c7 2124 	str.w	r2, [r7, #292]	; 0x124
    out = silk_SMLAWB( out, buf32[ -5 ], coef16[ 5 ] );
   12954:	f9b3 200a 	ldrsh.w	r2, [r3, #10]
   12958:	f8c7 2120 	str.w	r2, [r7, #288]	; 0x120
    out = silk_SMLAWB( out, buf32[ -6 ], coef16[ 6 ] );
   1295c:	f9b3 200c 	ldrsh.w	r2, [r3, #12]
   12960:	f8c7 211c 	str.w	r2, [r7, #284]	; 0x11c
    out = silk_SMLAWB( out, buf32[ -7 ], coef16[ 7 ] );
   12964:	f9b3 200e 	ldrsh.w	r2, [r3, #14]
   12968:	f8c7 2118 	str.w	r2, [r7, #280]	; 0x118
    out = silk_SMLAWB( out, buf32[ -8 ], coef16[ 8 ] );
   1296c:	f9b3 2010 	ldrsh.w	r2, [r3, #16]
    out = silk_SMLAWB( out, buf32[ -9 ], coef16[ 9 ] );
   12970:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
   12974:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp2, AR_shp_Q13[ 0 ] );
   12978:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
    out = silk_SMLAWB( out, buf32[ -8 ], coef16[ 8 ] );
   1297c:	f8c7 2114 	str.w	r2, [r7, #276]	; 0x114
   12980:	f9b3 3000 	ldrsh.w	r3, [r3]
   12984:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
   12988:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
   1298c:	f9b3 3000 	ldrsh.w	r3, [r3]
   12990:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
            psSS[ 0 ].Diff_Q14     = silk_SUB_LSHIFT32( xq_Q14, x_Q10[ i ], 4 );
   12994:	010b      	lsls	r3, r1, #4
   12996:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
   1299a:	f9b7 9090 	ldrsh.w	r9, [r7, #144]	; 0x90
   1299e:	f9b7 3098 	ldrsh.w	r3, [r7, #152]	; 0x98
   129a2:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
   129a6:	f9b7 3094 	ldrsh.w	r3, [r7, #148]	; 0x94
   129aa:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
   129ae:	f8d7 114c 	ldr.w	r1, [r7, #332]	; 0x14c
   129b2:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
   129b6:	f8d7 2158 	ldr.w	r2, [r7, #344]	; 0x158
   129ba:	f8c7 2198 	str.w	r2, [r7, #408]	; 0x198
   129be:	eb03 0a81 	add.w	sl, r3, r1, lsl #2
   129c2:	469b      	mov	fp, r3
   129c4:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
   129c8:	f8d7 2148 	ldr.w	r2, [r7, #328]	; 0x148
   129cc:	3308      	adds	r3, #8
   129ce:	0092      	lsls	r2, r2, #2
   129d0:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
   129d4:	465b      	mov	r3, fp
   129d6:	f8c7 210c 	str.w	r2, [r7, #268]	; 0x10c
   129da:	46d3      	mov	fp, sl
   129dc:	46c8      	mov	r8, r9
   129de:	469a      	mov	sl, r3
            psDD->Seed = silk_RAND( psDD->Seed );
   129e0:	f8da 3508 	ldr.w	r3, [sl, #1288]	; 0x508
   129e4:	4ae5      	ldr	r2, [pc, #916]	; (12d7c <silk_NSQ_del_dec_c+0x1b40>)
   129e6:	49e6      	ldr	r1, [pc, #920]	; (12d80 <silk_NSQ_del_dec_c+0x1b44>)
    out = silk_SMLAWB( out, buf32[ -2 ], coef16[ 2 ] );
   129e8:	f8d7 512c 	ldr.w	r5, [r7, #300]	; 0x12c
   129ec:	fb02 1303 	mla	r3, r2, r3, r1
   129f0:	f8ca 3508 	str.w	r3, [sl, #1288]	; 0x508
   129f4:	f8c7 3190 	str.w	r3, [r7, #400]	; 0x190
    out = silk_SMLAWB( out, buf32[  0 ], coef16[ 0 ] );
   129f8:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
   129fc:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
   12a00:	f85a 4023 	ldr.w	r4, [sl, r3, lsl #2]
    out = silk_SMLAWB( out, buf32[ -2 ], coef16[ 2 ] );
   12a04:	e95b 1002 	ldrd	r1, r0, [fp, #-8]
    out = silk_SMLAWB( out, buf32[  0 ], coef16[ 0 ] );
   12a08:	b2a3      	uxth	r3, r4
   12a0a:	1424      	asrs	r4, r4, #16
   12a0c:	fb02 f303 	mul.w	r3, r2, r3
   12a10:	fb02 f404 	mul.w	r4, r2, r4
    out = silk_SMLAWB( out, buf32[ -1 ], coef16[ 1 ] );
   12a14:	f8d7 2130 	ldr.w	r2, [r7, #304]	; 0x130
    out = silk_SMLAWB( out, buf32[  0 ], coef16[ 0 ] );
   12a18:	eb04 4423 	add.w	r4, r4, r3, asr #16
    out = silk_SMLAWB( out, buf32[ -1 ], coef16[ 1 ] );
   12a1c:	b283      	uxth	r3, r0
   12a1e:	1400      	asrs	r0, r0, #16
   12a20:	fb02 f303 	mul.w	r3, r2, r3
   12a24:	fb02 f000 	mul.w	r0, r2, r0
    out = silk_SMLAWB( out, buf32[  0 ], coef16[ 0 ] );
   12a28:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
    out = silk_SMLAWB( out, buf32[ -1 ], coef16[ 1 ] );
   12a2c:	eb00 4023 	add.w	r0, r0, r3, asr #16
    out = silk_SMLAWB( out, buf32[  0 ], coef16[ 0 ] );
   12a30:	4414      	add	r4, r2
    out = silk_SMLAWB( out, buf32[ -1 ], coef16[ 1 ] );
   12a32:	4420      	add	r0, r4
    out = silk_SMLAWB( out, buf32[ -4 ], coef16[ 4 ] );
   12a34:	e95b 3204 	ldrd	r3, r2, [fp, #-16]
    out = silk_SMLAWB( out, buf32[ -2 ], coef16[ 2 ] );
   12a38:	b28c      	uxth	r4, r1
   12a3a:	1409      	asrs	r1, r1, #16
   12a3c:	fb05 f404 	mul.w	r4, r5, r4
   12a40:	fb05 f101 	mul.w	r1, r5, r1
   12a44:	eb01 4124 	add.w	r1, r1, r4, asr #16
    out = silk_SMLAWB( out, buf32[ -3 ], coef16[ 3 ] );
   12a48:	f8d7 4128 	ldr.w	r4, [r7, #296]	; 0x128
    out = silk_SMLAWB( out, buf32[ -2 ], coef16[ 2 ] );
   12a4c:	4408      	add	r0, r1
    out = silk_SMLAWB( out, buf32[ -3 ], coef16[ 3 ] );
   12a4e:	b291      	uxth	r1, r2
   12a50:	1412      	asrs	r2, r2, #16
   12a52:	fb04 f202 	mul.w	r2, r4, r2
   12a56:	fb04 f101 	mul.w	r1, r4, r1
   12a5a:	eb02 4521 	add.w	r5, r2, r1, asr #16
   12a5e:	182a      	adds	r2, r5, r0
    out = silk_SMLAWB( out, buf32[ -4 ], coef16[ 4 ] );
   12a60:	f8d7 5124 	ldr.w	r5, [r7, #292]	; 0x124
   12a64:	b298      	uxth	r0, r3
   12a66:	141b      	asrs	r3, r3, #16
    out = silk_SMLAWB( out, buf32[ -6 ], coef16[ 6 ] );
   12a68:	e95b 1406 	ldrd	r1, r4, [fp, #-24]
    out = silk_SMLAWB( out, buf32[ -4 ], coef16[ 4 ] );
   12a6c:	fb05 f303 	mul.w	r3, r5, r3
   12a70:	fb05 f000 	mul.w	r0, r5, r0
   12a74:	eb03 4020 	add.w	r0, r3, r0, asr #16
   12a78:	1885      	adds	r5, r0, r2
    out = silk_SMLAWB( out, buf32[ -5 ], coef16[ 5 ] );
   12a7a:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
   12a7e:	b2a3      	uxth	r3, r4
   12a80:	1424      	asrs	r4, r4, #16
   12a82:	fb02 f004 	mul.w	r0, r2, r4
   12a86:	fb02 f303 	mul.w	r3, r2, r3
   12a8a:	eb00 4023 	add.w	r0, r0, r3, asr #16
   12a8e:	4428      	add	r0, r5
    out = silk_SMLAWB( out, buf32[ -6 ], coef16[ 6 ] );
   12a90:	f8d7 511c 	ldr.w	r5, [r7, #284]	; 0x11c
    out = silk_SMLAWB( out, buf32[ -8 ], coef16[ 8 ] );
   12a94:	e95b 3208 	ldrd	r3, r2, [fp, #-32]
    out = silk_SMLAWB( out, buf32[ -6 ], coef16[ 6 ] );
   12a98:	b28c      	uxth	r4, r1
   12a9a:	1409      	asrs	r1, r1, #16
   12a9c:	fb05 f404 	mul.w	r4, r5, r4
   12aa0:	fb05 f101 	mul.w	r1, r5, r1
   12aa4:	eb01 4124 	add.w	r1, r1, r4, asr #16
    out = silk_SMLAWB( out, buf32[ -7 ], coef16[ 7 ] );
   12aa8:	f8d7 4118 	ldr.w	r4, [r7, #280]	; 0x118
    out = silk_SMLAWB( out, buf32[ -9 ], coef16[ 9 ] );
   12aac:	f85b 5c24 	ldr.w	r5, [fp, #-36]
    out = silk_SMLAWB( out, buf32[ -6 ], coef16[ 6 ] );
   12ab0:	4408      	add	r0, r1
    out = silk_SMLAWB( out, buf32[ -7 ], coef16[ 7 ] );
   12ab2:	b291      	uxth	r1, r2
   12ab4:	1412      	asrs	r2, r2, #16
   12ab6:	fb04 f202 	mul.w	r2, r4, r2
   12aba:	fb04 f101 	mul.w	r1, r4, r1
   12abe:	eb02 4121 	add.w	r1, r2, r1, asr #16
   12ac2:	4408      	add	r0, r1
    out = silk_SMLAWB( out, buf32[ -8 ], coef16[ 8 ] );
   12ac4:	f8d7 1114 	ldr.w	r1, [r7, #276]	; 0x114
   12ac8:	b29a      	uxth	r2, r3
   12aca:	141b      	asrs	r3, r3, #16
   12acc:	fb01 f202 	mul.w	r2, r1, r2
   12ad0:	fb01 f303 	mul.w	r3, r1, r3
    out = silk_SMLAWB( out, buf32[ -9 ], coef16[ 9 ] );
   12ad4:	f8d7 1110 	ldr.w	r1, [r7, #272]	; 0x110
    out = silk_SMLAWB( out, buf32[ -8 ], coef16[ 8 ] );
   12ad8:	eb03 4322 	add.w	r3, r3, r2, asr #16
    out = silk_SMLAWB( out, buf32[ -9 ], coef16[ 9 ] );
   12adc:	b2aa      	uxth	r2, r5
   12ade:	142d      	asrs	r5, r5, #16
   12ae0:	fb01 f202 	mul.w	r2, r1, r2
   12ae4:	fb01 f505 	mul.w	r5, r1, r5
    out = silk_SMLAWB( out, buf32[ -8 ], coef16[ 8 ] );
   12ae8:	4403      	add	r3, r0
    out = silk_SMLAWB( out, buf32[ -9 ], coef16[ 9 ] );
   12aea:	eb05 4522 	add.w	r5, r5, r2, asr #16
   12aee:	18e9      	adds	r1, r5, r3
    if( order == 16 )
   12af0:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
   12af4:	2b10      	cmp	r3, #16
   12af6:	d153      	bne.n	12ba0 <silk_NSQ_del_dec_c+0x1964>
        out = silk_SMLAWB( out, buf32[ -10 ], coef16[ 10 ] );
   12af8:	f8d7 6184 	ldr.w	r6, [r7, #388]	; 0x184
   12afc:	f85b 2c28 	ldr.w	r2, [fp, #-40]
   12b00:	f9b6 3014 	ldrsh.w	r3, [r6, #20]
        out = silk_SMLAWB( out, buf32[ -11 ], coef16[ 11 ] );
   12b04:	f9b6 0016 	ldrsh.w	r0, [r6, #22]
   12b08:	f85b 4c2c 	ldr.w	r4, [fp, #-44]
        out = silk_SMLAWB( out, buf32[ -10 ], coef16[ 10 ] );
   12b0c:	b295      	uxth	r5, r2
   12b0e:	1412      	asrs	r2, r2, #16
   12b10:	fb03 f505 	mul.w	r5, r3, r5
   12b14:	fb03 f602 	mul.w	r6, r3, r2
   12b18:	eb06 4625 	add.w	r6, r6, r5, asr #16
        out = silk_SMLAWB( out, buf32[ -12 ], coef16[ 12 ] );
   12b1c:	f8d7 3184 	ldr.w	r3, [r7, #388]	; 0x184
   12b20:	f85b 2c30 	ldr.w	r2, [fp, #-48]
   12b24:	f9b3 5018 	ldrsh.w	r5, [r3, #24]
        out = silk_SMLAWB( out, buf32[ -13 ], coef16[ 13 ] );
   12b28:	f85b 3c34 	ldr.w	r3, [fp, #-52]
        out = silk_SMLAWB( out, buf32[ -10 ], coef16[ 10 ] );
   12b2c:	4431      	add	r1, r6
        out = silk_SMLAWB( out, buf32[ -11 ], coef16[ 11 ] );
   12b2e:	b2a6      	uxth	r6, r4
   12b30:	1424      	asrs	r4, r4, #16
   12b32:	fb00 f606 	mul.w	r6, r0, r6
   12b36:	fb00 f404 	mul.w	r4, r0, r4
   12b3a:	eb04 4426 	add.w	r4, r4, r6, asr #16
        out = silk_SMLAWB( out, buf32[ -13 ], coef16[ 13 ] );
   12b3e:	f8d7 6184 	ldr.w	r6, [r7, #388]	; 0x184
        out = silk_SMLAWB( out, buf32[ -14 ], coef16[ 14 ] );
   12b42:	f85b 0c38 	ldr.w	r0, [fp, #-56]
        out = silk_SMLAWB( out, buf32[ -13 ], coef16[ 13 ] );
   12b46:	f9b6 c01a 	ldrsh.w	ip, [r6, #26]
        out = silk_SMLAWB( out, buf32[ -11 ], coef16[ 11 ] );
   12b4a:	4421      	add	r1, r4
        out = silk_SMLAWB( out, buf32[ -12 ], coef16[ 12 ] );
   12b4c:	b294      	uxth	r4, r2
   12b4e:	1412      	asrs	r2, r2, #16
   12b50:	fb05 f404 	mul.w	r4, r5, r4
   12b54:	fb05 f502 	mul.w	r5, r5, r2
   12b58:	eb05 4524 	add.w	r5, r5, r4, asr #16
        out = silk_SMLAWB( out, buf32[ -13 ], coef16[ 13 ] );
   12b5c:	b29c      	uxth	r4, r3
   12b5e:	141b      	asrs	r3, r3, #16
   12b60:	fb0c f404 	mul.w	r4, ip, r4
   12b64:	fb0c f303 	mul.w	r3, ip, r3
   12b68:	eb03 4324 	add.w	r3, r3, r4, asr #16
        out = silk_SMLAWB( out, buf32[ -12 ], coef16[ 12 ] );
   12b6c:	4429      	add	r1, r5
        out = silk_SMLAWB( out, buf32[ -14 ], coef16[ 14 ] );
   12b6e:	f9b6 201c 	ldrsh.w	r2, [r6, #28]
        out = silk_SMLAWB( out, buf32[ -15 ], coef16[ 15 ] );
   12b72:	f85b 5c3c 	ldr.w	r5, [fp, #-60]
   12b76:	f9b6 401e 	ldrsh.w	r4, [r6, #30]
        out = silk_SMLAWB( out, buf32[ -13 ], coef16[ 13 ] );
   12b7a:	4419      	add	r1, r3
        out = silk_SMLAWB( out, buf32[ -14 ], coef16[ 14 ] );
   12b7c:	b283      	uxth	r3, r0
   12b7e:	1400      	asrs	r0, r0, #16
   12b80:	fb02 f303 	mul.w	r3, r2, r3
   12b84:	fb02 f200 	mul.w	r2, r2, r0
   12b88:	eb02 4223 	add.w	r2, r2, r3, asr #16
        out = silk_SMLAWB( out, buf32[ -15 ], coef16[ 15 ] );
   12b8c:	b2ab      	uxth	r3, r5
   12b8e:	142d      	asrs	r5, r5, #16
   12b90:	fb04 f303 	mul.w	r3, r4, r3
   12b94:	fb04 f505 	mul.w	r5, r4, r5
        out = silk_SMLAWB( out, buf32[ -14 ], coef16[ 14 ] );
   12b98:	4411      	add	r1, r2
        out = silk_SMLAWB( out, buf32[ -15 ], coef16[ 15 ] );
   12b9a:	eb05 4323 	add.w	r3, r5, r3, asr #16
   12b9e:	4419      	add	r1, r3
            tmp2 = silk_SMLAWB( psDD->Diff_Q14, psDD->sAR2_Q14[ 0 ], warping_Q16 );
   12ba0:	f8da 04a0 	ldr.w	r0, [sl, #1184]	; 0x4a0
   12ba4:	f8da 3504 	ldr.w	r3, [sl, #1284]	; 0x504
            tmp1 = silk_SMLAWB( psDD->sAR2_Q14[ 0 ], psDD->sAR2_Q14[ 1 ] - tmp2, warping_Q16 );
   12ba8:	f8da 54a4 	ldr.w	r5, [sl, #1188]	; 0x4a4
   12bac:	f8c7 5178 	str.w	r5, [r7, #376]	; 0x178
            tmp2 = silk_SMLAWB( psDD->Diff_Q14, psDD->sAR2_Q14[ 0 ], warping_Q16 );
   12bb0:	b284      	uxth	r4, r0
   12bb2:	1402      	asrs	r2, r0, #16
   12bb4:	fb08 f404 	mul.w	r4, r8, r4
   12bb8:	fb08 f202 	mul.w	r2, r8, r2
   12bbc:	eb02 4224 	add.w	r2, r2, r4, asr #16
   12bc0:	4413      	add	r3, r2
            tmp1 = silk_SMLAWB( psDD->sAR2_Q14[ 0 ], psDD->sAR2_Q14[ 1 ] - tmp2, warping_Q16 );
   12bc2:	1aea      	subs	r2, r5, r3
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp2, AR_shp_Q13[ 0 ] );
   12bc4:	f8d7 5180 	ldr.w	r5, [r7, #384]	; 0x180
            psDD->sAR2_Q14[ 0 ] = tmp2;
   12bc8:	f8ca 34a0 	str.w	r3, [sl, #1184]	; 0x4a0
            tmp1 = silk_SMLAWB( psDD->sAR2_Q14[ 0 ], psDD->sAR2_Q14[ 1 ] - tmp2, warping_Q16 );
   12bcc:	b296      	uxth	r6, r2
   12bce:	1412      	asrs	r2, r2, #16
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp2, AR_shp_Q13[ 0 ] );
   12bd0:	b29c      	uxth	r4, r3
   12bd2:	46ae      	mov	lr, r5
            tmp1 = silk_SMLAWB( psDD->sAR2_Q14[ 0 ], psDD->sAR2_Q14[ 1 ] - tmp2, warping_Q16 );
   12bd4:	fb08 f606 	mul.w	r6, r8, r6
   12bd8:	fb08 f202 	mul.w	r2, r8, r2
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp2, AR_shp_Q13[ 0 ] );
   12bdc:	fb05 f504 	mul.w	r5, r5, r4
            tmp1 = silk_SMLAWB( psDD->sAR2_Q14[ 0 ], psDD->sAR2_Q14[ 1 ] - tmp2, warping_Q16 );
   12be0:	eb02 4226 	add.w	r2, r2, r6, asr #16
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp2, AR_shp_Q13[ 0 ] );
   12be4:	141c      	asrs	r4, r3, #16
   12be6:	4676      	mov	r6, lr
            LPC_pred_Q14 = silk_LSHIFT( LPC_pred_Q14, 4 );                              /* Q10 -> Q14 */
   12be8:	0109      	lsls	r1, r1, #4
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp2, AR_shp_Q13[ 0 ] );
   12bea:	fb06 f404 	mul.w	r4, r6, r4
            LPC_pred_Q14 = silk_LSHIFT( LPC_pred_Q14, 4 );                              /* Q10 -> Q14 */
   12bee:	f8c7 118c 	str.w	r1, [r7, #396]	; 0x18c
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp2, AR_shp_Q13[ 0 ] );
   12bf2:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
            for( j = 2; j < shapingLPCOrder; j += 2 ) {
   12bf6:	f8d7 1174 	ldr.w	r1, [r7, #372]	; 0x174
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp2, AR_shp_Q13[ 0 ] );
   12bfa:	eb04 4425 	add.w	r4, r4, r5, asr #16
   12bfe:	18e3      	adds	r3, r4, r3
            for( j = 2; j < shapingLPCOrder; j += 2 ) {
   12c00:	2902      	cmp	r1, #2
            tmp1 = silk_SMLAWB( psDD->sAR2_Q14[ 0 ], psDD->sAR2_Q14[ 1 ] - tmp2, warping_Q16 );
   12c02:	4402      	add	r2, r0
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp2, AR_shp_Q13[ 0 ] );
   12c04:	469e      	mov	lr, r3
            for( j = 2; j < shapingLPCOrder; j += 2 ) {
   12c06:	dd4f      	ble.n	12ca8 <silk_NSQ_del_dec_c+0x1a6c>
   12c08:	f8d7 10f4 	ldr.w	r1, [r7, #244]	; 0xf4
   12c0c:	f8d7 9170 	ldr.w	r9, [r7, #368]	; 0x170
   12c10:	f8d7 c178 	ldr.w	ip, [r7, #376]	; 0x178
   12c14:	f8c7 a150 	str.w	sl, [r7, #336]	; 0x150
   12c18:	4451      	add	r1, sl
   12c1a:	f8c7 b178 	str.w	fp, [r7, #376]	; 0x178
   12c1e:	f8c7 119c 	str.w	r1, [r7, #412]	; 0x19c
   12c22:	46d6      	mov	lr, sl
   12c24:	469b      	mov	fp, r3
                tmp2 = silk_SMLAWB( psDD->sAR2_Q14[ j - 1 ], psDD->sAR2_Q14[ j + 0 ] - tmp1, warping_Q16 );
   12c26:	f8de a4a8 	ldr.w	sl, [lr, #1192]	; 0x4a8
                n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp1, AR_shp_Q13[ j - 1 ] );
   12c2a:	f9b9 1002 	ldrsh.w	r1, [r9, #2]
                psDD->sAR2_Q14[ j - 1 ] = tmp1;
   12c2e:	f8ce 24a4 	str.w	r2, [lr, #1188]	; 0x4a4
                tmp2 = silk_SMLAWB( psDD->sAR2_Q14[ j - 1 ], psDD->sAR2_Q14[ j + 0 ] - tmp1, warping_Q16 );
   12c32:	ebaa 0302 	sub.w	r3, sl, r2
   12c36:	b298      	uxth	r0, r3
   12c38:	141b      	asrs	r3, r3, #16
   12c3a:	fb08 f000 	mul.w	r0, r8, r0
   12c3e:	fb08 f303 	mul.w	r3, r8, r3
   12c42:	eb03 4320 	add.w	r3, r3, r0, asr #16
   12c46:	4463      	add	r3, ip
                n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp1, AR_shp_Q13[ j - 1 ] );
   12c48:	b296      	uxth	r6, r2
                tmp1 = silk_SMLAWB( psDD->sAR2_Q14[ j + 0 ], psDD->sAR2_Q14[ j + 1 ] - tmp2, warping_Q16 );
   12c4a:	f8de c4ac 	ldr.w	ip, [lr, #1196]	; 0x4ac
                n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp2, AR_shp_Q13[ j ] );
   12c4e:	f939 0f04 	ldrsh.w	r0, [r9, #4]!
                psDD->sAR2_Q14[ j + 0 ] = tmp2;
   12c52:	f8ce 34a8 	str.w	r3, [lr, #1192]	; 0x4a8
                n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp1, AR_shp_Q13[ j - 1 ] );
   12c56:	1412      	asrs	r2, r2, #16
   12c58:	fb01 f202 	mul.w	r2, r1, r2
   12c5c:	fb01 f606 	mul.w	r6, r1, r6
                tmp1 = silk_SMLAWB( psDD->sAR2_Q14[ j + 0 ], psDD->sAR2_Q14[ j + 1 ] - tmp2, warping_Q16 );
   12c60:	ebac 0403 	sub.w	r4, ip, r3
                n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp1, AR_shp_Q13[ j - 1 ] );
   12c64:	eb02 4626 	add.w	r6, r2, r6, asr #16
                n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp2, AR_shp_Q13[ j ] );
   12c68:	b29a      	uxth	r2, r3
   12c6a:	141b      	asrs	r3, r3, #16
   12c6c:	fb00 f102 	mul.w	r1, r0, r2
   12c70:	fb00 f303 	mul.w	r3, r0, r3
   12c74:	eb03 4321 	add.w	r3, r3, r1, asr #16
                n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp1, AR_shp_Q13[ j - 1 ] );
   12c78:	445e      	add	r6, fp
                tmp1 = silk_SMLAWB( psDD->sAR2_Q14[ j + 0 ], psDD->sAR2_Q14[ j + 1 ] - tmp2, warping_Q16 );
   12c7a:	b2a5      	uxth	r5, r4
                n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp2, AR_shp_Q13[ j ] );
   12c7c:	eb03 0b06 	add.w	fp, r3, r6
                tmp1 = silk_SMLAWB( psDD->sAR2_Q14[ j + 0 ], psDD->sAR2_Q14[ j + 1 ] - tmp2, warping_Q16 );
   12c80:	1424      	asrs	r4, r4, #16
            for( j = 2; j < shapingLPCOrder; j += 2 ) {
   12c82:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
                tmp1 = silk_SMLAWB( psDD->sAR2_Q14[ j + 0 ], psDD->sAR2_Q14[ j + 1 ] - tmp2, warping_Q16 );
   12c86:	fb08 f505 	mul.w	r5, r8, r5
   12c8a:	fb08 f404 	mul.w	r4, r8, r4
   12c8e:	f10e 0e08 	add.w	lr, lr, #8
   12c92:	eb04 4525 	add.w	r5, r4, r5, asr #16
            for( j = 2; j < shapingLPCOrder; j += 2 ) {
   12c96:	4573      	cmp	r3, lr
                tmp1 = silk_SMLAWB( psDD->sAR2_Q14[ j + 0 ], psDD->sAR2_Q14[ j + 1 ] - tmp2, warping_Q16 );
   12c98:	eb05 020a 	add.w	r2, r5, sl
            for( j = 2; j < shapingLPCOrder; j += 2 ) {
   12c9c:	d1c3      	bne.n	12c26 <silk_NSQ_del_dec_c+0x19ea>
   12c9e:	46de      	mov	lr, fp
   12ca0:	f8d7 a150 	ldr.w	sl, [r7, #336]	; 0x150
   12ca4:	f8d7 b178 	ldr.w	fp, [r7, #376]	; 0x178
            psDD->sAR2_Q14[ shapingLPCOrder - 1 ] = tmp1;
   12ca8:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
            n_LF_Q14 = silk_SMULWB( psDD->Shape_Q14[ *smpl_buf_idx ], LF_shp_Q14 );     /* Q12 */
   12cac:	f8d7 4104 	ldr.w	r4, [r7, #260]	; 0x104
            psDD->sAR2_Q14[ shapingLPCOrder - 1 ] = tmp1;
   12cb0:	eb0a 0103 	add.w	r1, sl, r3
            n_LF_Q14 = silk_SMULWB( psDD->Shape_Q14[ *smpl_buf_idx ], LF_shp_Q14 );     /* Q12 */
   12cb4:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
            psDD->sAR2_Q14[ shapingLPCOrder - 1 ] = tmp1;
   12cb8:	f8c1 24a0 	str.w	r2, [r1, #1184]	; 0x4a0
            n_LF_Q14 = silk_SMULWB( psDD->Shape_Q14[ *smpl_buf_idx ], LF_shp_Q14 );     /* Q12 */
   12cbc:	4453      	add	r3, sl
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, psDD->LF_AR_Q14, Tilt_Q14 );              /* Q12 */
   12cbe:	f8da 1500 	ldr.w	r1, [sl, #1280]	; 0x500
            n_LF_Q14 = silk_SMULWB( psDD->Shape_Q14[ *smpl_buf_idx ], LF_shp_Q14 );     /* Q12 */
   12cc2:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
   12cc6:	b29d      	uxth	r5, r3
   12cc8:	141b      	asrs	r3, r3, #16
   12cca:	fb04 f505 	mul.w	r5, r4, r5
   12cce:	fb04 f303 	mul.w	r3, r4, r3
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp1, AR_shp_Q13[ shapingLPCOrder - 1 ] );
   12cd2:	f8d7 40fc 	ldr.w	r4, [r7, #252]	; 0xfc
   12cd6:	b290      	uxth	r0, r2
   12cd8:	1412      	asrs	r2, r2, #16
   12cda:	fb04 f000 	mul.w	r0, r4, r0
   12cde:	fb04 f202 	mul.w	r2, r4, r2
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, psDD->LF_AR_Q14, Tilt_Q14 );              /* Q12 */
   12ce2:	f8d7 4108 	ldr.w	r4, [r7, #264]	; 0x108
   12ce6:	140e      	asrs	r6, r1, #16
   12ce8:	b289      	uxth	r1, r1
   12cea:	fb04 fc06 	mul.w	ip, r4, r6
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp1, AR_shp_Q13[ shapingLPCOrder - 1 ] );
   12cee:	eb02 4220 	add.w	r2, r2, r0, asr #16
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, psDD->LF_AR_Q14, Tilt_Q14 );              /* Q12 */
   12cf2:	fb04 f001 	mul.w	r0, r4, r1
            n_LF_Q14 = silk_SMLAWT( n_LF_Q14, psDD->LF_AR_Q14, LF_shp_Q14 );            /* Q12 */
   12cf6:	f8d7 4164 	ldr.w	r4, [r7, #356]	; 0x164
            n_LF_Q14 = silk_SMULWB( psDD->Shape_Q14[ *smpl_buf_idx ], LF_shp_Q14 );     /* Q12 */
   12cfa:	eb03 4325 	add.w	r3, r3, r5, asr #16
            n_LF_Q14 = silk_SMLAWT( n_LF_Q14, psDD->LF_AR_Q14, LF_shp_Q14 );            /* Q12 */
   12cfe:	fb04 f101 	mul.w	r1, r4, r1
   12d02:	fb04 3306 	mla	r3, r4, r6, r3
   12d06:	eb03 4321 	add.w	r3, r3, r1, asr #16
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, psDD->LF_AR_Q14, Tilt_Q14 );              /* Q12 */
   12d0a:	eb0c 4c20 	add.w	ip, ip, r0, asr #16
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, tmp1, AR_shp_Q13[ shapingLPCOrder - 1 ] );
   12d0e:	4472      	add	r2, lr
            n_AR_Q14 = silk_SMLAWB( n_AR_Q14, psDD->LF_AR_Q14, Tilt_Q14 );              /* Q12 */
   12d10:	eb0c 0242 	add.w	r2, ip, r2, lsl #1
            n_LF_Q14 = silk_LSHIFT( n_LF_Q14, 2 );                                      /* Q12 -> Q14 */
   12d14:	ea4f 0983 	mov.w	r9, r3, lsl #2
            tmp2 = silk_ADD32( n_LTP_Q14, LPC_pred_Q14 );                               /* Q13 */
   12d18:	f8d7 1138 	ldr.w	r1, [r7, #312]	; 0x138
   12d1c:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
            n_AR_Q14 = silk_LSHIFT( n_AR_Q14, 2 );                                      /* Q12 -> Q14 */
   12d20:	0094      	lsls	r4, r2, #2
            tmp1 = silk_ADD32( n_AR_Q14, n_LF_Q14 );                                    /* Q14 */
   12d22:	eb04 0209 	add.w	r2, r4, r9
            tmp2 = silk_ADD32( n_LTP_Q14, LPC_pred_Q14 );                               /* Q13 */
   12d26:	440b      	add	r3, r1
            tmp1 = silk_SUB32( tmp2, tmp1 );                                            /* Q13 */
   12d28:	1a9b      	subs	r3, r3, r2
            tmp1 = silk_RSHIFT_ROUND( tmp1, 4 );                                        /* Q10 */
   12d2a:	10db      	asrs	r3, r3, #3
            r_Q10 = silk_SUB32( x_Q10[ i ], tmp1 );                                     /* residual error Q10 */
   12d2c:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
            if (Lambda_Q10 > 2048) {
   12d30:	f8d7 128c 	ldr.w	r1, [r7, #652]	; 0x28c
            tmp1 = silk_RSHIFT_ROUND( tmp1, 4 );                                        /* Q10 */
   12d34:	3301      	adds	r3, #1
            r_Q10 = silk_SUB32( x_Q10[ i ], tmp1 );                                     /* residual error Q10 */
   12d36:	eba2 0363 	sub.w	r3, r2, r3, asr #1
            if ( psDD->Seed < 0 ) {
   12d3a:	f8d7 2190 	ldr.w	r2, [r7, #400]	; 0x190
   12d3e:	2a00      	cmp	r2, #0
            r_Q10 = silk_LIMIT_32( r_Q10, -(31 << 10), 30 << 10 );
   12d40:	4a10      	ldr	r2, [pc, #64]	; (12d84 <silk_NSQ_del_dec_c+0x1b48>)
                r_Q10 = -r_Q10;
   12d42:	bfb8      	it	lt
   12d44:	425b      	neglt	r3, r3
            r_Q10 = silk_LIMIT_32( r_Q10, -(31 << 10), 30 << 10 );
   12d46:	4293      	cmp	r3, r2
   12d48:	bfb8      	it	lt
   12d4a:	4613      	movlt	r3, r2
   12d4c:	f5b3 4ff0 	cmp.w	r3, #30720	; 0x7800
            q1_Q10 = silk_SUB32( r_Q10, offset_Q10 );
   12d50:	f8d7 2194 	ldr.w	r2, [r7, #404]	; 0x194
   12d54:	bfa8      	it	ge
   12d56:	f44f 43f0 	movge.w	r3, #30720	; 0x7800
            if (Lambda_Q10 > 2048) {
   12d5a:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
            q1_Q10 = silk_SUB32( r_Q10, offset_Q10 );
   12d5e:	eba3 0202 	sub.w	r2, r3, r2
            if (Lambda_Q10 > 2048) {
   12d62:	f340 8136 	ble.w	12fd2 <silk_NSQ_del_dec_c+0x1d96>
                if (q1_Q10 > rdo_offset) {
   12d66:	f8d7 113c 	ldr.w	r1, [r7, #316]	; 0x13c
   12d6a:	428a      	cmp	r2, r1
   12d6c:	f340 8142 	ble.w	12ff4 <silk_NSQ_del_dec_c+0x1db8>
                    q1_Q0 = silk_RSHIFT( q1_Q10 - rdo_offset, 10 );
   12d70:	1a50      	subs	r0, r2, r1
   12d72:	1280      	asrs	r0, r0, #10
            if( q1_Q0 > 0 ) {
   12d74:	2800      	cmp	r0, #0
   12d76:	f340 8130 	ble.w	12fda <silk_NSQ_del_dec_c+0x1d9e>
   12d7a:	e005      	b.n	12d88 <silk_NSQ_del_dec_c+0x1b4c>
   12d7c:	0bb38435 	.word	0x0bb38435
   12d80:	3619636b 	.word	0x3619636b
   12d84:	ffff8400 	.word	0xffff8400
                q1_Q10  = silk_SUB32( silk_LSHIFT( q1_Q0, 10 ), QUANT_LEVEL_ADJUST_Q10 );
   12d88:	f8d7 2194 	ldr.w	r2, [r7, #404]	; 0x194
                rd2_Q10 = silk_SMULBB( q2_Q10, Lambda_Q10 );
   12d8c:	f8d7 5154 	ldr.w	r5, [r7, #340]	; 0x154
                q1_Q10  = silk_SUB32( silk_LSHIFT( q1_Q0, 10 ), QUANT_LEVEL_ADJUST_Q10 );
   12d90:	eb02 2080 	add.w	r0, r2, r0, lsl #10
                q1_Q10  = silk_ADD32( q1_Q10, offset_Q10 );
   12d94:	3850      	subs	r0, #80	; 0x50
                q2_Q10  = silk_ADD32( q1_Q10, 1024 );
   12d96:	f500 6680 	add.w	r6, r0, #1024	; 0x400
                rd2_Q10 = silk_SMULBB( q2_Q10, Lambda_Q10 );
   12d9a:	fb16 fe05 	smulbb	lr, r6, r5
   12d9e:	1b99      	subs	r1, r3, r6
   12da0:	1a1a      	subs	r2, r3, r0
   12da2:	46b4      	mov	ip, r6
                rd1_Q10 = silk_SMULBB( q1_Q10, Lambda_Q10 );
   12da4:	fb10 f305 	smulbb	r3, r0, r5
   12da8:	4605      	mov	r5, r0
            rd2_Q10 = silk_RSHIFT( silk_SMLABB( rd2_Q10, rr_Q10, rr_Q10 ), 10 );
   12daa:	b209      	sxth	r1, r1
            rd1_Q10 = silk_RSHIFT( silk_SMLABB( rd1_Q10, rr_Q10, rr_Q10 ), 10 );
   12dac:	b212      	sxth	r2, r2
   12dae:	fb02 3202 	mla	r2, r2, r2, r3
            rd2_Q10 = silk_RSHIFT( silk_SMLABB( rd2_Q10, rr_Q10, rr_Q10 ), 10 );
   12db2:	fb01 e301 	mla	r3, r1, r1, lr
            rd1_Q10 = silk_RSHIFT( silk_SMLABB( rd1_Q10, rr_Q10, rr_Q10 ), 10 );
   12db6:	1292      	asrs	r2, r2, #10
   12db8:	f8da 1510 	ldr.w	r1, [sl, #1296]	; 0x510
            rd2_Q10 = silk_RSHIFT( silk_SMLABB( rd2_Q10, rr_Q10, rr_Q10 ), 10 );
   12dbc:	129b      	asrs	r3, r3, #10
            if( rd1_Q10 < rd2_Q10 ) {
   12dbe:	429a      	cmp	r2, r3
   12dc0:	eb03 0e01 	add.w	lr, r3, r1
   12dc4:	4411      	add	r1, r2
   12dc6:	f280 80f7 	bge.w	12fb8 <silk_NSQ_del_dec_c+0x1d7c>
                psSS[ 0 ].RD_Q10 = silk_ADD32( psDD->RD_Q10, rd1_Q10 );
   12dca:	f8d7 3198 	ldr.w	r3, [r7, #408]	; 0x198
   12dce:	6059      	str	r1, [r3, #4]
                psSS[ 1 ].RD_Q10 = silk_ADD32( psDD->RD_Q10, rd2_Q10 );
   12dd0:	f8c3 e020 	str.w	lr, [r3, #32]
                psSS[ 0 ].Q_Q10  = q1_Q10;
   12dd4:	6018      	str	r0, [r3, #0]
                psSS[ 1 ].Q_Q10  = q2_Q10;
   12dd6:	61de      	str	r6, [r3, #28]
            if ( psDD->Seed < 0 ) {
   12dd8:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
            psSS[ 0 ].LPC_exc_Q14  = LPC_exc_Q14;
   12ddc:	f8d7 1198 	ldr.w	r1, [r7, #408]	; 0x198
            if ( psDD->Seed < 0 ) {
   12de0:	2b00      	cmp	r3, #0
            exc_Q14 = silk_LSHIFT32( psSS[ 0 ].Q_Q10, 4 );
   12de2:	ea4f 1505 	mov.w	r5, r5, lsl #4
            LPC_exc_Q14 = silk_ADD32( exc_Q14, LTP_pred_Q14 );
   12de6:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
                exc_Q14 = -exc_Q14;
   12dea:	bfb8      	it	lt
   12dec:	426d      	neglt	r5, r5
            LPC_exc_Q14 = silk_ADD32( exc_Q14, LTP_pred_Q14 );
   12dee:	441d      	add	r5, r3
            xq_Q14      = silk_ADD32( LPC_exc_Q14, LPC_pred_Q14 );
   12df0:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
            psSS[ 0 ].LPC_exc_Q14  = LPC_exc_Q14;
   12df4:	618d      	str	r5, [r1, #24]
            xq_Q14      = silk_ADD32( LPC_exc_Q14, LPC_pred_Q14 );
   12df6:	195a      	adds	r2, r3, r5
            psSS[ 0 ].Diff_Q14     = silk_SUB_LSHIFT32( xq_Q14, x_Q10[ i ], 4 );
   12df8:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
            psSS[ 0 ].xq_Q14       = xq_Q14;
   12dfc:	608a      	str	r2, [r1, #8]
            psSS[ 0 ].Diff_Q14     = silk_SUB_LSHIFT32( xq_Q14, x_Q10[ i ], 4 );
   12dfe:	1ad3      	subs	r3, r2, r3
            sLF_AR_shp_Q14         = silk_SUB32( psSS[ 0 ].Diff_Q14, n_AR_Q14 );
   12e00:	1b1a      	subs	r2, r3, r4
            psSS[ 0 ].Diff_Q14     = silk_SUB_LSHIFT32( xq_Q14, x_Q10[ i ], 4 );
   12e02:	610b      	str	r3, [r1, #16]
            psSS[ 0 ].sLTP_shp_Q14 = silk_SUB32( sLF_AR_shp_Q14, n_LF_Q14 );
   12e04:	eba2 0309 	sub.w	r3, r2, r9
   12e08:	614b      	str	r3, [r1, #20]
            if ( psDD->Seed < 0 ) {
   12e0a:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
            psSS[ 0 ].LF_AR_Q14    = sLF_AR_shp_Q14;
   12e0e:	60ca      	str	r2, [r1, #12]
            if ( psDD->Seed < 0 ) {
   12e10:	2b00      	cmp	r3, #0
            exc_Q14 = silk_LSHIFT32( psSS[ 1 ].Q_Q10, 4 );
   12e12:	ea4f 1c0c 	mov.w	ip, ip, lsl #4
            LPC_exc_Q14 = silk_ADD32( exc_Q14, LTP_pred_Q14 );
   12e16:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
            xq_Q14      = silk_ADD32( LPC_exc_Q14, LPC_pred_Q14 );
   12e1a:	f8d7 218c 	ldr.w	r2, [r7, #396]	; 0x18c
            psSS[ 1 ].xq_Q14       = xq_Q14;
   12e1e:	f8d7 5198 	ldr.w	r5, [r7, #408]	; 0x198
                exc_Q14 = -exc_Q14;
   12e22:	bfb8      	it	lt
   12e24:	f1cc 0c00 	rsblt	ip, ip, #0
            LPC_exc_Q14 = silk_ADD32( exc_Q14, LTP_pred_Q14 );
   12e28:	4463      	add	r3, ip
            xq_Q14      = silk_ADD32( LPC_exc_Q14, LPC_pred_Q14 );
   12e2a:	441a      	add	r2, r3
   12e2c:	4611      	mov	r1, r2
            psSS[ 1 ].Diff_Q14     = silk_SUB_LSHIFT32( xq_Q14, x_Q10[ i ], 4 );
   12e2e:	f8d7 217c 	ldr.w	r2, [r7, #380]	; 0x17c
            psSS[ 1 ].LPC_exc_Q14  = LPC_exc_Q14;
   12e32:	636b      	str	r3, [r5, #52]	; 0x34
   12e34:	f105 0338 	add.w	r3, r5, #56	; 0x38
            psSS[ 1 ].Diff_Q14     = silk_SUB_LSHIFT32( xq_Q14, x_Q10[ i ], 4 );
   12e38:	1a8a      	subs	r2, r1, r2
   12e3a:	f8c7 3198 	str.w	r3, [r7, #408]	; 0x198
        for( k = 0; k < nStatesDelayedDecision; k++ ) {
   12e3e:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
            psSS[ 1 ].xq_Q14       = xq_Q14;
   12e42:	6269      	str	r1, [r5, #36]	; 0x24
            sLF_AR_shp_Q14         = silk_SUB32( psSS[ 1 ].Diff_Q14, n_AR_Q14 );
   12e44:	1b14      	subs	r4, r2, r4
   12e46:	f20a 5a14 	addw	sl, sl, #1300	; 0x514
            psSS[ 1 ].sLTP_shp_Q14 = silk_SUB32( sLF_AR_shp_Q14, n_LF_Q14 );
   12e4a:	eba4 0009 	sub.w	r0, r4, r9
        for( k = 0; k < nStatesDelayedDecision; k++ ) {
   12e4e:	4553      	cmp	r3, sl
            psSS[ 1 ].sLTP_shp_Q14 = silk_SUB32( sLF_AR_shp_Q14, n_LF_Q14 );
   12e50:	6328      	str	r0, [r5, #48]	; 0x30
            psSS[ 1 ].Diff_Q14     = silk_SUB_LSHIFT32( xq_Q14, x_Q10[ i ], 4 );
   12e52:	e9c5 420a 	strd	r4, r2, [r5, #40]	; 0x28
   12e56:	f20b 5b14 	addw	fp, fp, #1300	; 0x514
        for( k = 0; k < nStatesDelayedDecision; k++ ) {
   12e5a:	f47f adc1 	bne.w	129e0 <silk_NSQ_del_dec_c+0x17a4>
        *smpl_buf_idx  = ( *smpl_buf_idx - 1 ) % DECISION_DELAY;
   12e5e:	f8d7 2148 	ldr.w	r2, [r7, #328]	; 0x148
   12e62:	1e53      	subs	r3, r2, #1
        if( *smpl_buf_idx < 0 ) *smpl_buf_idx += DECISION_DELAY;
   12e64:	2a00      	cmp	r2, #0
   12e66:	f000 80f9 	beq.w	1305c <silk_NSQ_del_dec_c+0x1e20>
   12e6a:	ea4f 0883 	mov.w	r8, r3, lsl #2
   12e6e:	f8c7 3148 	str.w	r3, [r7, #328]	; 0x148
   12e72:	4618      	mov	r0, r3
        last_smple_idx = ( *smpl_buf_idx + decisionDelay ) % DECISION_DELAY;
   12e74:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
   12e78:	4cd0      	ldr	r4, [pc, #832]	; (131bc <silk_NSQ_del_dec_c+0x1f80>)
        for( k = 1; k < nStatesDelayedDecision; k++ ) {
   12e7a:	f8d7 615c 	ldr.w	r6, [r7, #348]	; 0x15c
        RDmin_Q10 = psSampleState[ 0 ][ 0 ].RD_Q10;
   12e7e:	f8d7 2158 	ldr.w	r2, [r7, #344]	; 0x158
        last_smple_idx = ( *smpl_buf_idx + decisionDelay ) % DECISION_DELAY;
   12e82:	4403      	add	r3, r0
   12e84:	fba4 0403 	umull	r0, r4, r4, r3
   12e88:	0964      	lsrs	r4, r4, #5
   12e8a:	eb04 0484 	add.w	r4, r4, r4, lsl #2
        for( k = 1; k < nStatesDelayedDecision; k++ ) {
   12e8e:	2e01      	cmp	r6, #1
        RDmin_Q10 = psSampleState[ 0 ][ 0 ].RD_Q10;
   12e90:	6851      	ldr	r1, [r2, #4]
        last_smple_idx = ( *smpl_buf_idx + decisionDelay ) % DECISION_DELAY;
   12e92:	eba3 04c4 	sub.w	r4, r3, r4, lsl #3
        for( k = 1; k < nStatesDelayedDecision; k++ ) {
   12e96:	f340 8142 	ble.w	1311e <silk_NSQ_del_dec_c+0x1ee2>
        Winner_ind = 0;
   12e9a:	2500      	movs	r5, #0
        for( k = 1; k < nStatesDelayedDecision; k++ ) {
   12e9c:	2301      	movs	r3, #1
            if( psSampleState[ k ][ 0 ].RD_Q10 < RDmin_Q10 ) {
   12e9e:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
   12ea0:	4288      	cmp	r0, r1
   12ea2:	bfb8      	it	lt
   12ea4:	461d      	movlt	r5, r3
        for( k = 1; k < nStatesDelayedDecision; k++ ) {
   12ea6:	f103 0301 	add.w	r3, r3, #1
            if( psSampleState[ k ][ 0 ].RD_Q10 < RDmin_Q10 ) {
   12eaa:	bfb8      	it	lt
   12eac:	4601      	movlt	r1, r0
        for( k = 1; k < nStatesDelayedDecision; k++ ) {
   12eae:	429e      	cmp	r6, r3
   12eb0:	f102 0238 	add.w	r2, r2, #56	; 0x38
   12eb4:	d1f3      	bne.n	12e9e <silk_NSQ_del_dec_c+0x1c62>
        Winner_rand_state = psDelDec[ Winner_ind ].RandState[ last_smple_idx ];
   12eb6:	f8d7 2144 	ldr.w	r2, [r7, #324]	; 0x144
   12eba:	f8d7 915c 	ldr.w	r9, [r7, #348]	; 0x15c
   12ebe:	f240 5314 	movw	r3, #1300	; 0x514
   12ec2:	fb03 2505 	mla	r5, r3, r5, r2
   12ec6:	f104 0360 	add.w	r3, r4, #96	; 0x60
   12eca:	f855 e023 	ldr.w	lr, [r5, r3, lsl #2]
   12ece:	4613      	mov	r3, r2
   12ed0:	eb03 0684 	add.w	r6, r3, r4, lsl #2
   12ed4:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
        for( k = 0; k < nStatesDelayedDecision; k++ ) {
   12ed8:	2200      	movs	r2, #0
                psSampleState[ k ][ 0 ].RD_Q10 = silk_ADD32( psSampleState[ k ][ 0 ].RD_Q10, silk_int32_MAX >> 4 );
   12eda:	f06f 4c78 	mvn.w	ip, #4160749568	; 0xf8000000
            if( psDelDec[ k ].RandState[ last_smple_idx ] != Winner_rand_state ) {
   12ede:	f8d6 1180 	ldr.w	r1, [r6, #384]	; 0x180
   12ee2:	458e      	cmp	lr, r1
        for( k = 0; k < nStatesDelayedDecision; k++ ) {
   12ee4:	f102 0201 	add.w	r2, r2, #1
   12ee8:	f206 5614 	addw	r6, r6, #1300	; 0x514
            if( psDelDec[ k ].RandState[ last_smple_idx ] != Winner_rand_state ) {
   12eec:	d005      	beq.n	12efa <silk_NSQ_del_dec_c+0x1cbe>
                psSampleState[ k ][ 0 ].RD_Q10 = silk_ADD32( psSampleState[ k ][ 0 ].RD_Q10, silk_int32_MAX >> 4 );
   12eee:	6858      	ldr	r0, [r3, #4]
                psSampleState[ k ][ 1 ].RD_Q10 = silk_ADD32( psSampleState[ k ][ 1 ].RD_Q10, silk_int32_MAX >> 4 );
   12ef0:	6a19      	ldr	r1, [r3, #32]
                psSampleState[ k ][ 0 ].RD_Q10 = silk_ADD32( psSampleState[ k ][ 0 ].RD_Q10, silk_int32_MAX >> 4 );
   12ef2:	4460      	add	r0, ip
                psSampleState[ k ][ 1 ].RD_Q10 = silk_ADD32( psSampleState[ k ][ 1 ].RD_Q10, silk_int32_MAX >> 4 );
   12ef4:	4461      	add	r1, ip
                psSampleState[ k ][ 0 ].RD_Q10 = silk_ADD32( psSampleState[ k ][ 0 ].RD_Q10, silk_int32_MAX >> 4 );
   12ef6:	6058      	str	r0, [r3, #4]
                psSampleState[ k ][ 1 ].RD_Q10 = silk_ADD32( psSampleState[ k ][ 1 ].RD_Q10, silk_int32_MAX >> 4 );
   12ef8:	6219      	str	r1, [r3, #32]
        for( k = 0; k < nStatesDelayedDecision; k++ ) {
   12efa:	4591      	cmp	r9, r2
   12efc:	f103 0338 	add.w	r3, r3, #56	; 0x38
   12f00:	dced      	bgt.n	12ede <silk_NSQ_del_dec_c+0x1ca2>
        for( k = 1; k < nStatesDelayedDecision; k++ ) {
   12f02:	f8d7 015c 	ldr.w	r0, [r7, #348]	; 0x15c
        RDmax_Q10  = psSampleState[ 0 ][ 0 ].RD_Q10;
   12f06:	f8d7 2158 	ldr.w	r2, [r7, #344]	; 0x158
        for( k = 1; k < nStatesDelayedDecision; k++ ) {
   12f0a:	f04f 0900 	mov.w	r9, #0
   12f0e:	2801      	cmp	r0, #1
        RDmax_Q10  = psSampleState[ 0 ][ 0 ].RD_Q10;
   12f10:	6851      	ldr	r1, [r2, #4]
        RDmin_Q10  = psSampleState[ 0 ][ 1 ].RD_Q10;
   12f12:	f8d2 c020 	ldr.w	ip, [r2, #32]
        for( k = 1; k < nStatesDelayedDecision; k++ ) {
   12f16:	464e      	mov	r6, r9
   12f18:	f77f ab8a 	ble.w	12630 <silk_NSQ_del_dec_c+0x13f4>
   12f1c:	2301      	movs	r3, #1
   12f1e:	4686      	mov	lr, r0
            if( psSampleState[ k ][ 0 ].RD_Q10 > RDmax_Q10 ) {
   12f20:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
   12f22:	4288      	cmp	r0, r1
   12f24:	bfc8      	it	gt
   12f26:	4601      	movgt	r1, r0
            if( psSampleState[ k ][ 1 ].RD_Q10 < RDmin_Q10 ) {
   12f28:	6d90      	ldr	r0, [r2, #88]	; 0x58
            if( psSampleState[ k ][ 0 ].RD_Q10 > RDmax_Q10 ) {
   12f2a:	bfc8      	it	gt
   12f2c:	461e      	movgt	r6, r3
            if( psSampleState[ k ][ 1 ].RD_Q10 < RDmin_Q10 ) {
   12f2e:	4560      	cmp	r0, ip
   12f30:	bfb8      	it	lt
   12f32:	4699      	movlt	r9, r3
        for( k = 1; k < nStatesDelayedDecision; k++ ) {
   12f34:	f103 0301 	add.w	r3, r3, #1
            if( psSampleState[ k ][ 1 ].RD_Q10 < RDmin_Q10 ) {
   12f38:	bfb8      	it	lt
   12f3a:	4684      	movlt	ip, r0
        for( k = 1; k < nStatesDelayedDecision; k++ ) {
   12f3c:	459e      	cmp	lr, r3
   12f3e:	f102 0238 	add.w	r2, r2, #56	; 0x38
   12f42:	dced      	bgt.n	12f20 <silk_NSQ_del_dec_c+0x1ce4>
        if( RDmin_Q10 < RDmax_Q10 ) {
   12f44:	458c      	cmp	ip, r1
   12f46:	f6bf ab76 	bge.w	12636 <silk_NSQ_del_dec_c+0x13fa>
   12f4a:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
            silk_memcpy( ( (opus_int32 *)&psDelDec[ RDmax_ind ] ) + i,
   12f4e:	f240 5c14 	movw	ip, #1300	; 0x514
   12f52:	0099      	lsls	r1, r3, #2
   12f54:	ebc3 7283 	rsb	r2, r3, r3, lsl #30
   12f58:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
   12f5c:	fb0c 1006 	mla	r0, ip, r6, r1
   12f60:	fb0c 1109 	mla	r1, ip, r9, r1
   12f64:	ea4f 0c82 	mov.w	ip, r2, lsl #2
   12f68:	4419      	add	r1, r3
   12f6a:	f20c 5214 	addw	r2, ip, #1300	; 0x514
   12f6e:	4418      	add	r0, r3
   12f70:	f7f9 f8c6 	bl	c100 <memcpy>
            silk_memcpy( &psSampleState[ RDmax_ind ][ 0 ], &psSampleState[ RDmin_ind ][ 1 ], sizeof( NSQ_sample_struct ) );
   12f74:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
   12f78:	ebc9 0cc9 	rsb	ip, r9, r9, lsl #3
   12f7c:	eb03 0ccc 	add.w	ip, r3, ip, lsl #3
   12f80:	f10c 0c1c 	add.w	ip, ip, #28
   12f84:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   12f88:	ebc6 0ec6 	rsb	lr, r6, r6, lsl #3
   12f8c:	f8d7 6158 	ldr.w	r6, [r7, #344]	; 0x158
   12f90:	eb06 06ce 	add.w	r6, r6, lr, lsl #3
   12f94:	c60f      	stmia	r6!, {r0, r1, r2, r3}
   12f96:	e89c 0007 	ldmia.w	ip, {r0, r1, r2}
        if( subfr > 0 || i >= decisionDelay ) {
   12f9a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
            silk_memcpy( &psSampleState[ RDmax_ind ][ 0 ], &psSampleState[ RDmin_ind ][ 1 ], sizeof( NSQ_sample_struct ) );
   12f9e:	e886 0007 	stmia.w	r6, {r0, r1, r2}
        if( subfr > 0 || i >= decisionDelay ) {
   12fa2:	2b00      	cmp	r3, #0
   12fa4:	f47f ab4c 	bne.w	12640 <silk_NSQ_del_dec_c+0x1404>
   12fa8:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
   12fac:	6819      	ldr	r1, [r3, #0]
   12fae:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
   12fb2:	681a      	ldr	r2, [r3, #0]
   12fb4:	f7ff bb91 	b.w	126da <silk_NSQ_del_dec_c+0x149e>
                psSS[ 0 ].RD_Q10 = silk_ADD32( psDD->RD_Q10, rd2_Q10 );
   12fb8:	f8d7 2198 	ldr.w	r2, [r7, #408]	; 0x198
                psSS[ 1 ].Q_Q10  = q1_Q10;
   12fbc:	f8c7 519c 	str.w	r5, [r7, #412]	; 0x19c
                psSS[ 0 ].RD_Q10 = silk_ADD32( psDD->RD_Q10, rd2_Q10 );
   12fc0:	f8c2 e004 	str.w	lr, [r2, #4]
                psSS[ 1 ].Q_Q10  = q1_Q10;
   12fc4:	4665      	mov	r5, ip
                psSS[ 1 ].RD_Q10 = silk_ADD32( psDD->RD_Q10, rd1_Q10 );
   12fc6:	6211      	str	r1, [r2, #32]
                psSS[ 1 ].Q_Q10  = q1_Q10;
   12fc8:	f8d7 c19c 	ldr.w	ip, [r7, #412]	; 0x19c
                psSS[ 0 ].Q_Q10  = q2_Q10;
   12fcc:	6016      	str	r6, [r2, #0]
                psSS[ 1 ].Q_Q10  = q1_Q10;
   12fce:	61d0      	str	r0, [r2, #28]
   12fd0:	e702      	b.n	12dd8 <silk_NSQ_del_dec_c+0x1b9c>
            q1_Q0 = silk_RSHIFT( q1_Q10, 10 );
   12fd2:	1290      	asrs	r0, r2, #10
            if( q1_Q0 > 0 ) {
   12fd4:	2800      	cmp	r0, #0
   12fd6:	f73f aed7 	bgt.w	12d88 <silk_NSQ_del_dec_c+0x1b4c>
            } else if( q1_Q0 == 0 ) {
   12fda:	d114      	bne.n	13006 <silk_NSQ_del_dec_c+0x1dca>
   12fdc:	f8d7 60c4 	ldr.w	r6, [r7, #196]	; 0xc4
            for( j = 2; j < shapingLPCOrder; j += 2 ) {
   12fe0:	f8d7 0194 	ldr.w	r0, [r7, #404]	; 0x194
                rd2_Q10 = silk_SMULBB( q2_Q10, Lambda_Q10 );
   12fe4:	f8d7 e0c0 	ldr.w	lr, [r7, #192]	; 0xc0
   12fe8:	1b99      	subs	r1, r3, r6
            for( j = 2; j < shapingLPCOrder; j += 2 ) {
   12fea:	4605      	mov	r5, r0
   12fec:	46b4      	mov	ip, r6
                rd1_Q10 = silk_SMULBB( q1_Q10, Lambda_Q10 );
   12fee:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
   12ff2:	e6da      	b.n	12daa <silk_NSQ_del_dec_c+0x1b6e>
                } else if (q1_Q10 < -rdo_offset) {
   12ff4:	f8d7 10d0 	ldr.w	r1, [r7, #208]	; 0xd0
   12ff8:	428a      	cmp	r2, r1
   12ffa:	da1d      	bge.n	13038 <silk_NSQ_del_dec_c+0x1dfc>
                    q1_Q0 = silk_RSHIFT( q1_Q10 + rdo_offset, 10 );
   12ffc:	f8d7 113c 	ldr.w	r1, [r7, #316]	; 0x13c
   13000:	1850      	adds	r0, r2, r1
   13002:	1280      	asrs	r0, r0, #10
   13004:	e6b6      	b.n	12d74 <silk_NSQ_del_dec_c+0x1b38>
            } else if( q1_Q0 == -1 ) {
   13006:	1c45      	adds	r5, r0, #1
   13008:	d018      	beq.n	1303c <silk_NSQ_del_dec_c+0x1e00>
                q1_Q10  = silk_ADD32( silk_LSHIFT( q1_Q0, 10 ), QUANT_LEVEL_ADJUST_Q10 );
   1300a:	f8d7 2194 	ldr.w	r2, [r7, #404]	; 0x194
   1300e:	eb02 2080 	add.w	r0, r2, r0, lsl #10
                q1_Q10  = silk_ADD32( q1_Q10, offset_Q10 );
   13012:	3050      	adds	r0, #80	; 0x50
                q2_Q10  = silk_ADD32( q1_Q10, 1024 );
   13014:	f500 6680 	add.w	r6, r0, #1024	; 0x400
                rd2_Q10 = silk_SMULBB( -q2_Q10, Lambda_Q10 );
   13018:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
   1301c:	f1c6 0e00 	rsb	lr, r6, #0
   13020:	fb1e fe02 	smulbb	lr, lr, r2
   13024:	1b99      	subs	r1, r3, r6
   13026:	1a1a      	subs	r2, r3, r0
                rd1_Q10 = silk_SMULBB( -q1_Q10, Lambda_Q10 );
   13028:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
   1302c:	4245      	negs	r5, r0
   1302e:	fb15 f303 	smulbb	r3, r5, r3
   13032:	46b4      	mov	ip, r6
   13034:	4605      	mov	r5, r0
   13036:	e6b8      	b.n	12daa <silk_NSQ_del_dec_c+0x1b6e>
                } else if (q1_Q10 < 0) {
   13038:	2a00      	cmp	r2, #0
   1303a:	dacf      	bge.n	12fdc <silk_NSQ_del_dec_c+0x1da0>
                rd1_Q10 = silk_SMULBB( q1_Q10, Lambda_Q10 );
   1303c:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
   1303e:	f8d7 6194 	ldr.w	r6, [r7, #404]	; 0x194
                rd2_Q10 = silk_SMULBB(  q2_Q10, Lambda_Q10 );
   13042:	f8d7 e0dc 	ldr.w	lr, [r7, #220]	; 0xdc
            q1_Q10 = silk_SUB32( r_Q10, offset_Q10 );
   13046:	4611      	mov	r1, r2
                rd1_Q10 = silk_SMULBB( q1_Q10, Lambda_Q10 );
   13048:	4605      	mov	r5, r0
            q1_Q10 = silk_SUB32( r_Q10, offset_Q10 );
   1304a:	1a1a      	subs	r2, r3, r0
                rd1_Q10 = silk_SMULBB( q1_Q10, Lambda_Q10 );
   1304c:	46b4      	mov	ip, r6
                rd1_Q10 = silk_SMULBB( -q1_Q10, Lambda_Q10 );
   1304e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
   13050:	e6ab      	b.n	12daa <silk_NSQ_del_dec_c+0x1b6e>
            xq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   13052:	f647 73ff 	movw	r3, #32767	; 0x7fff
   13056:	4606      	mov	r6, r0
   13058:	f7ff bb23 	b.w	126a2 <silk_NSQ_del_dec_c+0x1466>
        if( *smpl_buf_idx < 0 ) *smpl_buf_idx += DECISION_DELAY;
   1305c:	2327      	movs	r3, #39	; 0x27
   1305e:	f04f 089c 	mov.w	r8, #156	; 0x9c
   13062:	f8c7 3148 	str.w	r3, [r7, #328]	; 0x148
   13066:	4618      	mov	r0, r3
   13068:	e704      	b.n	12e74 <silk_NSQ_del_dec_c+0x1c38>
            n_LTP_Q14 = 0;
   1306a:	2300      	movs	r3, #0
   1306c:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
   13070:	e44e      	b.n	12910 <silk_NSQ_del_dec_c+0x16d4>
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[  0 ], b_Q14[ 0 ] );
   13072:	f8d7 6084 	ldr.w	r6, [r7, #132]	; 0x84
   13076:	f8d7 10e4 	ldr.w	r1, [r7, #228]	; 0xe4
   1307a:	6835      	ldr	r5, [r6, #0]
   1307c:	f9b1 2000 	ldrsh.w	r2, [r1]
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -1 ], b_Q14[ 1 ] );
   13080:	f856 3c04 	ldr.w	r3, [r6, #-4]
   13084:	f9b1 1002 	ldrsh.w	r1, [r1, #2]
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -2 ], b_Q14[ 2 ] );
   13088:	f856 0c08 	ldr.w	r0, [r6, #-8]
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[  0 ], b_Q14[ 0 ] );
   1308c:	b2ac      	uxth	r4, r5
   1308e:	142d      	asrs	r5, r5, #16
   13090:	fb02 f404 	mul.w	r4, r2, r4
   13094:	fb02 f205 	mul.w	r2, r2, r5
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -1 ], b_Q14[ 1 ] );
   13098:	b29d      	uxth	r5, r3
   1309a:	141b      	asrs	r3, r3, #16
   1309c:	fb01 f505 	mul.w	r5, r1, r5
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[  0 ], b_Q14[ 0 ] );
   130a0:	eb02 4224 	add.w	r2, r2, r4, asr #16
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -1 ], b_Q14[ 1 ] );
   130a4:	fb01 f303 	mul.w	r3, r1, r3
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -2 ], b_Q14[ 2 ] );
   130a8:	f8d7 40e4 	ldr.w	r4, [r7, #228]	; 0xe4
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[  0 ], b_Q14[ 0 ] );
   130ac:	3202      	adds	r2, #2
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -1 ], b_Q14[ 1 ] );
   130ae:	eb03 4325 	add.w	r3, r3, r5, asr #16
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -2 ], b_Q14[ 2 ] );
   130b2:	f9b4 1004 	ldrsh.w	r1, [r4, #4]
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -3 ], b_Q14[ 3 ] );
   130b6:	f856 4c0c 	ldr.w	r4, [r6, #-12]
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -1 ], b_Q14[ 1 ] );
   130ba:	4413      	add	r3, r2
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -3 ], b_Q14[ 3 ] );
   130bc:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -2 ], b_Q14[ 2 ] );
   130c0:	b285      	uxth	r5, r0
   130c2:	1400      	asrs	r0, r0, #16
   130c4:	fb01 f505 	mul.w	r5, r1, r5
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -3 ], b_Q14[ 3 ] );
   130c8:	f9b2 2006 	ldrsh.w	r2, [r2, #6]
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -2 ], b_Q14[ 2 ] );
   130cc:	fb01 f100 	mul.w	r1, r1, r0
   130d0:	eb01 4125 	add.w	r1, r1, r5, asr #16
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -3 ], b_Q14[ 3 ] );
   130d4:	b2a5      	uxth	r5, r4
   130d6:	1424      	asrs	r4, r4, #16
   130d8:	fb02 f505 	mul.w	r5, r2, r5
   130dc:	fb02 f204 	mul.w	r2, r2, r4
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -4 ], b_Q14[ 4 ] );
   130e0:	f8d7 40e4 	ldr.w	r4, [r7, #228]	; 0xe4
   130e4:	f856 0c10 	ldr.w	r0, [r6, #-16]
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -2 ], b_Q14[ 2 ] );
   130e8:	4419      	add	r1, r3
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -4 ], b_Q14[ 4 ] );
   130ea:	f9b4 3008 	ldrsh.w	r3, [r4, #8]
   130ee:	b284      	uxth	r4, r0
   130f0:	1400      	asrs	r0, r0, #16
   130f2:	fb03 f404 	mul.w	r4, r3, r4
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -3 ], b_Q14[ 3 ] );
   130f6:	eb02 4225 	add.w	r2, r2, r5, asr #16
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -4 ], b_Q14[ 4 ] );
   130fa:	fb03 f300 	mul.w	r3, r3, r0
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -3 ], b_Q14[ 3 ] );
   130fe:	440a      	add	r2, r1
            LTP_pred_Q14 = silk_SMLAWB( LTP_pred_Q14, pred_lag_ptr[ -4 ], b_Q14[ 4 ] );
   13100:	eb03 4324 	add.w	r3, r3, r4, asr #16
   13104:	4413      	add	r3, r2
            LTP_pred_Q14 = silk_LSHIFT( LTP_pred_Q14, 1 );                          /* Q13 -> Q14 */
   13106:	005b      	lsls	r3, r3, #1
            pred_lag_ptr++;
   13108:	1d32      	adds	r2, r6, #4
   1310a:	f8c7 2084 	str.w	r2, [r7, #132]	; 0x84
            LTP_pred_Q14 = silk_LSHIFT( LTP_pred_Q14, 1 );                          /* Q13 -> Q14 */
   1310e:	f8c7 3188 	str.w	r3, [r7, #392]	; 0x188
   13112:	f7ff bbd5 	b.w	128c0 <silk_NSQ_del_dec_c+0x1684>
            xq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   13116:	4b2a      	ldr	r3, [pc, #168]	; (131c0 <silk_NSQ_del_dec_c+0x1f84>)
   13118:	4606      	mov	r6, r0
   1311a:	f7ff bac2 	b.w	126a2 <silk_NSQ_del_dec_c+0x1466>
        Winner_rand_state = psDelDec[ Winner_ind ].RandState[ last_smple_idx ];
   1311e:	f104 0360 	add.w	r3, r4, #96	; 0x60
   13122:	f8d7 2144 	ldr.w	r2, [r7, #324]	; 0x144
   13126:	f852 e023 	ldr.w	lr, [r2, r3, lsl #2]
        for( k = 0; k < nStatesDelayedDecision; k++ ) {
   1312a:	f47f aa78 	bne.w	1261e <silk_NSQ_del_dec_c+0x13e2>
   1312e:	4615      	mov	r5, r2
   13130:	4613      	mov	r3, r2
   13132:	46b1      	mov	r9, r6
   13134:	e6cc      	b.n	12ed0 <silk_NSQ_del_dec_c+0x1c94>
        return silk_LSHIFT_SAT32(result, -lshift);
   13136:	4249      	negs	r1, r1
   13138:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
   1313c:	410b      	asrs	r3, r1
   1313e:	429a      	cmp	r2, r3
   13140:	dc05      	bgt.n	1314e <silk_NSQ_del_dec_c+0x1f12>
   13142:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   13146:	410b      	asrs	r3, r1
   13148:	4293      	cmp	r3, r2
   1314a:	bfb8      	it	lt
   1314c:	4613      	movlt	r3, r2
   1314e:	fa03 f401 	lsl.w	r4, r3, r1
   13152:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
   13156:	f7fe ba6a 	b.w	1162e <silk_NSQ_del_dec_c+0x3f2>
   1315a:	251f      	movs	r5, #31
   1315c:	f7fe baea 	b.w	11734 <silk_NSQ_del_dec_c+0x4f8>
            lag = pitchL[ k ];
   13160:	f8d7 3288 	ldr.w	r3, [r7, #648]	; 0x288
   13164:	4618      	mov	r0, r3
   13166:	f850 3024 	ldr.w	r3, [r0, r4, lsl #2]
            if( ( k & ( 3 - silk_LSHIFT( LSF_interpolation_flag, 1 ) ) ) == 0 ) {
   1316a:	6878      	ldr	r0, [r7, #4]
            lag = pitchL[ k ];
   1316c:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
            if( ( k & ( 3 - silk_LSHIFT( LSF_interpolation_flag, 1 ) ) ) == 0 ) {
   13170:	ea10 0a04 	ands.w	sl, r0, r4
   13174:	d055      	beq.n	13222 <silk_NSQ_del_dec_c+0x1fe6>
   13176:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
   13178:	f8c7 20d4 	str.w	r2, [r7, #212]	; 0xd4
   1317c:	4688      	mov	r8, r1
   1317e:	f8d7 10e8 	ldr.w	r1, [r7, #232]	; 0xe8
   13182:	3201      	adds	r2, #1
   13184:	6809      	ldr	r1, [r1, #0]
   13186:	65fa      	str	r2, [r7, #92]	; 0x5c
   13188:	f8c7 1190 	str.w	r1, [r7, #400]	; 0x190
   1318c:	4699      	mov	r9, r3
   1318e:	6fba      	ldr	r2, [r7, #120]	; 0x78
   13190:	f7fe ba11 	b.w	115b6 <silk_NSQ_del_dec_c+0x37a>
   13194:	263c      	movs	r6, #60	; 0x3c
   13196:	221f      	movs	r2, #31
   13198:	f7fe babe 	b.w	11718 <silk_NSQ_del_dec_c+0x4dc>
        return silk_LSHIFT_SAT32(result, -lshift);
   1319c:	f1c5 0510 	rsb	r5, r5, #16
   131a0:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   131a4:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
   131a8:	412a      	asrs	r2, r5
   131aa:	4129      	asrs	r1, r5
   131ac:	428a      	cmp	r2, r1
   131ae:	f340 8194 	ble.w	134da <silk_NSQ_del_dec_c+0x229e>
   131b2:	4293      	cmp	r3, r2
   131b4:	f340 819b 	ble.w	134ee <silk_NSQ_del_dec_c+0x22b2>
   131b8:	4613      	mov	r3, r2
   131ba:	e193      	b.n	134e4 <silk_NSQ_del_dec_c+0x22a8>
   131bc:	cccccccd 	.word	0xcccccccd
   131c0:	ffff8000 	.word	0xffff8000
        if( signal_type == TYPE_VOICED && NSQ->rewhite_flag == 0 ) {
   131c4:	f1b8 0f00 	cmp.w	r8, #0
   131c8:	f47e ab0c 	bne.w	117e4 <silk_NSQ_del_dec_c+0x5a8>
            for( i = NSQ->sLTP_buf_idx - lag - LTP_ORDER / 2; i < NSQ->sLTP_buf_idx - decisionDelay; i++ ) {
   131cc:	f8d7 1190 	ldr.w	r1, [r7, #400]	; 0x190
   131d0:	f8d7 00ec 	ldr.w	r0, [r7, #236]	; 0xec
   131d4:	eba1 0409 	sub.w	r4, r1, r9
   131d8:	1ea2      	subs	r2, r4, #2
   131da:	1a09      	subs	r1, r1, r0
   131dc:	428a      	cmp	r2, r1
   131de:	f6be ab01 	bge.w	117e4 <silk_NSQ_del_dec_c+0x5a8>
   131e2:	f8d7 00a0 	ldr.w	r0, [r7, #160]	; 0xa0
   131e6:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
   131ea:	3c03      	subs	r4, #3
   131ec:	1f02      	subs	r2, r0, #4
   131ee:	eb00 0484 	add.w	r4, r0, r4, lsl #2
   131f2:	eb02 0581 	add.w	r5, r2, r1, lsl #2
                sLTP_Q15[ i ] = silk_SMULWW( gain_adj_Q16, sLTP_Q15[ i ] );
   131f6:	ea4f 4c23 	mov.w	ip, r3, asr #16
   131fa:	b29e      	uxth	r6, r3
   131fc:	f854 2f04 	ldr.w	r2, [r4, #4]!
   13200:	b211      	sxth	r1, r2
   13202:	13d2      	asrs	r2, r2, #15
   13204:	fb06 f001 	mul.w	r0, r6, r1
   13208:	3201      	adds	r2, #1
   1320a:	fb01 f10c 	mul.w	r1, r1, ip
   1320e:	1052      	asrs	r2, r2, #1
   13210:	eb01 4120 	add.w	r1, r1, r0, asr #16
   13214:	fb03 1202 	mla	r2, r3, r2, r1
            for( i = NSQ->sLTP_buf_idx - lag - LTP_ORDER / 2; i < NSQ->sLTP_buf_idx - decisionDelay; i++ ) {
   13218:	42a5      	cmp	r5, r4
                sLTP_Q15[ i ] = silk_SMULWW( gain_adj_Q16, sLTP_Q15[ i ] );
   1321a:	6022      	str	r2, [r4, #0]
            for( i = NSQ->sLTP_buf_idx - lag - LTP_ORDER / 2; i < NSQ->sLTP_buf_idx - decisionDelay; i++ ) {
   1321c:	d1ee      	bne.n	131fc <silk_NSQ_del_dec_c+0x1fc0>
   1321e:	f7fe bae1 	b.w	117e4 <silk_NSQ_del_dec_c+0x5a8>
                if( k == 2 ) {
   13222:	2c02      	cmp	r4, #2
   13224:	f000 8180 	beq.w	13528 <silk_NSQ_del_dec_c+0x22ec>
   13228:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   1322a:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
   1322e:	3301      	adds	r3, #1
   13230:	65fb      	str	r3, [r7, #92]	; 0x5c
                start_idx = psEncC->ltp_mem_length - lag - psEncC->predictLPCOrder - LTP_ORDER / 2;
   13232:	6e7e      	ldr	r6, [r7, #100]	; 0x64
   13234:	6abb      	ldr	r3, [r7, #40]	; 0x28
   13236:	f8d7 10b0 	ldr.w	r1, [r7, #176]	; 0xb0
   1323a:	681d      	ldr	r5, [r3, #0]
                silk_LPC_analysis_filter( &sLTP[ start_idx ], &NSQ->xq[ start_idx + k * psEncC->subfr_length ],
   1323c:	6d7a      	ldr	r2, [r7, #84]	; 0x54
   1323e:	6fbc      	ldr	r4, [r7, #120]	; 0x78
   13240:	6812      	ldr	r2, [r2, #0]
                start_idx = psEncC->ltp_mem_length - lag - psEncC->predictLPCOrder - LTP_ORDER / 2;
   13242:	f241 18f0 	movw	r8, #4592	; 0x11f0
   13246:	f856 3008 	ldr.w	r3, [r6, r8]
   1324a:	1a58      	subs	r0, r3, r1
   1324c:	1b40      	subs	r0, r0, r5
                silk_LPC_analysis_filter( &sLTP[ start_idx ], &NSQ->xq[ start_idx + k * psEncC->subfr_length ],
   1324e:	f241 31e4 	movw	r1, #5092	; 0x13e4
                start_idx = psEncC->ltp_mem_length - lag - psEncC->predictLPCOrder - LTP_ORDER / 2;
   13252:	3802      	subs	r0, #2
                silk_LPC_analysis_filter( &sLTP[ start_idx ], &NSQ->xq[ start_idx + k * psEncC->subfr_length ],
   13254:	fb02 0204 	mla	r2, r2, r4, r0
   13258:	4634      	mov	r4, r6
   1325a:	5876      	ldr	r6, [r6, r1]
   1325c:	9601      	str	r6, [sp, #4]
   1325e:	f8d7 10bc 	ldr.w	r1, [r7, #188]	; 0xbc
   13262:	eb01 0142 	add.w	r1, r1, r2, lsl #1
   13266:	697a      	ldr	r2, [r7, #20]
   13268:	9500      	str	r5, [sp, #0]
   1326a:	1a1b      	subs	r3, r3, r0
   1326c:	eb02 0040 	add.w	r0, r2, r0, lsl #1
   13270:	f8d7 2184 	ldr.w	r2, [r7, #388]	; 0x184
   13274:	f004 fc0a 	bl	17a8c <silk_LPC_analysis_filter>
                NSQ->sLTP_buf_idx = psEncC->ltp_mem_length;
   13278:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
   1327c:	f854 3008 	ldr.w	r3, [r4, r8]
   13280:	6013      	str	r3, [r2, #0]
                NSQ->rewhite_flag = 1;
   13282:	6bba      	ldr	r2, [r7, #56]	; 0x38
                NSQ->sLTP_buf_idx = psEncC->ltp_mem_length;
   13284:	f8c7 3190 	str.w	r3, [r7, #400]	; 0x190
                NSQ->rewhite_flag = 1;
   13288:	2301      	movs	r3, #1
   1328a:	6013      	str	r3, [r2, #0]
   1328c:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   1328e:	6fbc      	ldr	r4, [r7, #120]	; 0x78
   13290:	f992 201d 	ldrsb.w	r2, [r2, #29]
   13294:	f8c7 20b8 	str.w	r2, [r7, #184]	; 0xb8
   13298:	f8d7 2288 	ldr.w	r2, [r7, #648]	; 0x288
   1329c:	4698      	mov	r8, r3
   1329e:	f852 9024 	ldr.w	r9, [r2, r4, lsl #2]
   132a2:	4622      	mov	r2, r4
   132a4:	f7fe b987 	b.w	115b6 <silk_NSQ_del_dec_c+0x37a>
   132a8:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
   132ac:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
   132b0:	4413      	add	r3, r2
   132b2:	4619      	mov	r1, r3
    for( k = 1; k < psEncC->nStatesDelayedDecision; k++ ) {
   132b4:	f241 2314 	movw	r3, #4628	; 0x1214
   132b8:	6e78      	ldr	r0, [r7, #100]	; 0x64
    RDmin_Q10 = psDelDec[ 0 ].RD_Q10;
   132ba:	f8d7 2144 	ldr.w	r2, [r7, #324]	; 0x144
    for( k = 1; k < psEncC->nStatesDelayedDecision; k++ ) {
   132be:	58c6      	ldr	r6, [r0, r3]
    RDmin_Q10 = psDelDec[ 0 ].RD_Q10;
   132c0:	f8d2 5510 	ldr.w	r5, [r2, #1296]	; 0x510
    for( k = 1; k < psEncC->nStatesDelayedDecision; k++ ) {
   132c4:	2e01      	cmp	r6, #1
   132c6:	f340 81cd 	ble.w	13664 <silk_NSQ_del_dec_c+0x2428>
   132ca:	2301      	movs	r3, #1
    Winner_ind = 0;
   132cc:	2400      	movs	r4, #0
        if( psDelDec[ k ].RD_Q10 < RDmin_Q10 ) {
   132ce:	f8d2 0a24 	ldr.w	r0, [r2, #2596]	; 0xa24
   132d2:	42a8      	cmp	r0, r5
   132d4:	bfb8      	it	lt
   132d6:	461c      	movlt	r4, r3
    for( k = 1; k < psEncC->nStatesDelayedDecision; k++ ) {
   132d8:	f103 0301 	add.w	r3, r3, #1
        if( psDelDec[ k ].RD_Q10 < RDmin_Q10 ) {
   132dc:	bfb8      	it	lt
   132de:	4605      	movlt	r5, r0
    for( k = 1; k < psEncC->nStatesDelayedDecision; k++ ) {
   132e0:	429e      	cmp	r6, r3
   132e2:	f202 5214 	addw	r2, r2, #1300	; 0x514
   132e6:	d1f2      	bne.n	132ce <silk_NSQ_del_dec_c+0x2092>
   132e8:	f240 5214 	movw	r2, #1300	; 0x514
   132ec:	fb02 f204 	mul.w	r2, r2, r4
   132f0:	f502 6294 	add.w	r2, r2, #1184	; 0x4a0
   132f4:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   132f8:	f8c7 219c 	str.w	r2, [r7, #412]	; 0x19c
   132fc:	eb03 1383 	add.w	r3, r3, r3, lsl #6
   13300:	f8d7 2144 	ldr.w	r2, [r7, #324]	; 0x144
   13304:	f8c7 3198 	str.w	r3, [r7, #408]	; 0x198
    psIndices->Seed = psDD->SeedInit;
   13308:	f240 5314 	movw	r3, #1300	; 0x514
   1330c:	fb03 2304 	mla	r3, r3, r4, r2
   13310:	6d38      	ldr	r0, [r7, #80]	; 0x50
   13312:	f8d3 350c 	ldr.w	r3, [r3, #1292]	; 0x50c
   13316:	f880 3022 	strb.w	r3, [r0, #34]	; 0x22
    Gain_Q10 = silk_RSHIFT32( Gains_Q16[ psEncC->nb_subfr - 1 ], 6 );
   1331a:	f241 12e4 	movw	r2, #4580	; 0x11e4
   1331e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   13320:	589b      	ldr	r3, [r3, r2]
   13322:	f8d7 2284 	ldr.w	r2, [r7, #644]	; 0x284
   13326:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   1332a:	3b01      	subs	r3, #1
   1332c:	f852 b023 	ldr.w	fp, [r2, r3, lsl #2]
    for( i = 0; i < decisionDelay; i++ ) {
   13330:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
   13334:	2a00      	cmp	r2, #0
    Gain_Q10 = silk_RSHIFT32( Gains_Q16[ psEncC->nb_subfr - 1 ], 6 );
   13336:	ea4f 1eab 	mov.w	lr, fp, asr #6
    for( i = 0; i < decisionDelay; i++ ) {
   1333a:	dd6d      	ble.n	13418 <silk_NSQ_del_dec_c+0x21dc>
   1333c:	f8d7 0268 	ldr.w	r0, [r7, #616]	; 0x268
   13340:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
   13344:	f8c7 4194 	str.w	r4, [r7, #404]	; 0x194
   13348:	ea4f 0942 	mov.w	r9, r2, lsl #1
   1334c:	f089 0901 	eor.w	r9, r9, #1
   13350:	eba0 0802 	sub.w	r8, r0, r2
   13354:	6eb8      	ldr	r0, [r7, #104]	; 0x68
   13356:	ea6f 0909 	mvn.w	r9, r9
   1335a:	f503 5587 	add.w	r5, r3, #4320	; 0x10e0
   1335e:	4448      	add	r0, r9
        pxq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   13360:	ea4f 5b6b 	mov.w	fp, fp, asr #21
   13364:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   13368:	f10b 0b01 	add.w	fp, fp, #1
   1336c:	4681      	mov	r9, r0
   1336e:	f105 0010 	add.w	r0, r5, #16
   13372:	ea4f 0b6b 	mov.w	fp, fp, asr #1
   13376:	fa0f fe8e 	sxth.w	lr, lr
   1337a:	f8c7 00e0 	str.w	r0, [r7, #224]	; 0xe0
   1337e:	eb03 1a83 	add.w	sl, r3, r3, lsl #6
    for( i = 0; i < decisionDelay; i++ ) {
   13382:	2600      	movs	r6, #0
   13384:	4614      	mov	r4, r2
        last_smple_idx = ( last_smple_idx - 1 ) % DECISION_DELAY;
   13386:	4acb      	ldr	r2, [pc, #812]	; (136b4 <silk_NSQ_del_dec_c+0x2478>)
   13388:	1e4b      	subs	r3, r1, #1
   1338a:	fb82 1203 	smull	r1, r2, r2, r3
   1338e:	17d9      	asrs	r1, r3, #31
   13390:	ebc1 1122 	rsb	r1, r1, r2, asr #4
   13394:	eb01 0181 	add.w	r1, r1, r1, lsl #2
        if( last_smple_idx < 0 ) last_smple_idx += DECISION_DELAY;
   13398:	ebb3 01c1 	subs.w	r1, r3, r1, lsl #3
   1339c:	bf48      	it	mi
   1339e:	3128      	addmi	r1, #40	; 0x28
   133a0:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
   133a4:	eb0a 0001 	add.w	r0, sl, r1
   133a8:	eb03 0080 	add.w	r0, r3, r0, lsl #2
        pxq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   133ac:	f647 7cff 	movw	ip, #32767	; 0x7fff
   133b0:	f8d0 32c0 	ldr.w	r3, [r0, #704]	; 0x2c0
   133b4:	b29a      	uxth	r2, r3
   133b6:	141d      	asrs	r5, r3, #16
   133b8:	fb0e f202 	mul.w	r2, lr, r2
   133bc:	fb0e f505 	mul.w	r5, lr, r5
   133c0:	eb05 4522 	add.w	r5, r5, r2, asr #16
   133c4:	fb03 530b 	mla	r3, r3, fp, r5
        pulses[   i - decisionDelay ] = (opus_int8)silk_RSHIFT_ROUND( psDD->Q_Q10[ last_smple_idx ], 10 );
   133c8:	f8d0 2220 	ldr.w	r2, [r0, #544]	; 0x220
        pxq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   133cc:	11db      	asrs	r3, r3, #7
        pulses[   i - decisionDelay ] = (opus_int8)silk_RSHIFT_ROUND( psDD->Q_Q10[ last_smple_idx ], 10 );
   133ce:	1252      	asrs	r2, r2, #9
        pxq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   133d0:	3301      	adds	r3, #1
        pulses[   i - decisionDelay ] = (opus_int8)silk_RSHIFT_ROUND( psDD->Q_Q10[ last_smple_idx ], 10 );
   133d2:	3201      	adds	r2, #1
        pxq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   133d4:	105b      	asrs	r3, r3, #1
        pulses[   i - decisionDelay ] = (opus_int8)silk_RSHIFT_ROUND( psDD->Q_Q10[ last_smple_idx ], 10 );
   133d6:	1052      	asrs	r2, r2, #1
        pxq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   133d8:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
        pulses[   i - decisionDelay ] = (opus_int8)silk_RSHIFT_ROUND( psDD->Q_Q10[ last_smple_idx ], 10 );
   133dc:	f808 2b01 	strb.w	r2, [r8], #1
        pxq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   133e0:	da06      	bge.n	133f0 <silk_NSQ_del_dec_c+0x21b4>
   133e2:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   133e6:	bfb4      	ite	lt
   133e8:	f8df c2cc 	ldrlt.w	ip, [pc, #716]	; 136b8 <silk_NSQ_del_dec_c+0x247c>
   133ec:	fa0f fc83 	sxthge.w	ip, r3
        NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx - decisionDelay + i ] = psDD->Shape_Q14[ last_smple_idx ];
   133f0:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
   133f4:	f8d0 2400 	ldr.w	r2, [r0, #1024]	; 0x400
   133f8:	681b      	ldr	r3, [r3, #0]
   133fa:	f8d7 00bc 	ldr.w	r0, [r7, #188]	; 0xbc
        pxq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   133fe:	f829 cf02 	strh.w	ip, [r9, #2]!
        NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx - decisionDelay + i ] = psDD->Shape_Q14[ last_smple_idx ];
   13402:	1b1b      	subs	r3, r3, r4
   13404:	4433      	add	r3, r6
   13406:	f503 73a0 	add.w	r3, r3, #320	; 0x140
    for( i = 0; i < decisionDelay; i++ ) {
   1340a:	3601      	adds	r6, #1
   1340c:	42b4      	cmp	r4, r6
        NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx - decisionDelay + i ] = psDD->Shape_Q14[ last_smple_idx ];
   1340e:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
    for( i = 0; i < decisionDelay; i++ ) {
   13412:	d1b8      	bne.n	13386 <silk_NSQ_del_dec_c+0x214a>
   13414:	f8d7 4194 	ldr.w	r4, [r7, #404]	; 0x194
    silk_memcpy( NSQ->sLPC_Q14, &psDD->sLPC_Q14[ psEncC->subfr_length ], NSQ_LPC_BUF_LENGTH * sizeof( opus_int32 ) );
   13418:	6e7a      	ldr	r2, [r7, #100]	; 0x64
   1341a:	693d      	ldr	r5, [r7, #16]
   1341c:	f241 13ec 	movw	r3, #4588	; 0x11ec
   13420:	58d6      	ldr	r6, [r2, r3]
   13422:	f8d7 3198 	ldr.w	r3, [r7, #408]	; 0x198
   13426:	4433      	add	r3, r6
   13428:	461e      	mov	r6, r3
   1342a:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
   1342e:	eb03 0686 	add.w	r6, r3, r6, lsl #2
   13432:	f106 0e40 	add.w	lr, r6, #64	; 0x40
   13436:	46b4      	mov	ip, r6
   13438:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   1343c:	45f4      	cmp	ip, lr
   1343e:	6028      	str	r0, [r5, #0]
   13440:	6069      	str	r1, [r5, #4]
   13442:	60aa      	str	r2, [r5, #8]
   13444:	60eb      	str	r3, [r5, #12]
   13446:	4666      	mov	r6, ip
   13448:	f105 0510 	add.w	r5, r5, #16
   1344c:	d1f3      	bne.n	13436 <silk_NSQ_del_dec_c+0x21fa>
    silk_memcpy( NSQ->sAR2_Q14, psDD->sAR2_Q14, sizeof( psDD->sAR2_Q14 ) );
   1344e:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
   13452:	f8d7 5144 	ldr.w	r5, [r7, #324]	; 0x144
   13456:	68f8      	ldr	r0, [r7, #12]
   13458:	4619      	mov	r1, r3
   1345a:	4429      	add	r1, r5
   1345c:	2260      	movs	r2, #96	; 0x60
   1345e:	f7f8 fe4f 	bl	c100 <memcpy>
    NSQ->lagPrev        = pitchL[ psEncC->nb_subfr - 1 ];
   13462:	6e79      	ldr	r1, [r7, #100]	; 0x64
   13464:	f241 13e4 	movw	r3, #4580	; 0x11e4
    NSQ->sLF_AR_shp_Q14 = psDD->LF_AR_Q14;
   13468:	f240 5214 	movw	r2, #1300	; 0x514
    NSQ->lagPrev        = pitchL[ psEncC->nb_subfr - 1 ];
   1346c:	58cb      	ldr	r3, [r1, r3]
   1346e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    NSQ->sLF_AR_shp_Q14 = psDD->LF_AR_Q14;
   13472:	fb02 5404 	mla	r4, r2, r4, r5
    NSQ->lagPrev        = pitchL[ psEncC->nb_subfr - 1 ];
   13476:	3b01      	subs	r3, #1
   13478:	f8d7 2288 	ldr.w	r2, [r7, #648]	; 0x288
    NSQ->sLF_AR_shp_Q14 = psDD->LF_AR_Q14;
   1347c:	68bd      	ldr	r5, [r7, #8]
    NSQ->lagPrev        = pitchL[ psEncC->nb_subfr - 1 ];
   1347e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    NSQ->sLF_AR_shp_Q14 = psDD->LF_AR_Q14;
   13482:	f8d4 2500 	ldr.w	r2, [r4, #1280]	; 0x500
   13486:	602a      	str	r2, [r5, #0]
    silk_memmove( NSQ->xq,           &NSQ->xq[           psEncC->frame_length ], psEncC->ltp_mem_length * sizeof( opus_int16 ) );
   13488:	f241 18f0 	movw	r8, #4592	; 0x11f0
   1348c:	f241 16e8 	movw	r6, #4584	; 0x11e8
    NSQ->lagPrev        = pitchL[ psEncC->nb_subfr - 1 ];
   13490:	f8d7 50bc 	ldr.w	r5, [r7, #188]	; 0xbc
    silk_memmove( NSQ->xq,           &NSQ->xq[           psEncC->frame_length ], psEncC->ltp_mem_length * sizeof( opus_int16 ) );
   13494:	f851 2008 	ldr.w	r2, [r1, r8]
   13498:	5989      	ldr	r1, [r1, r6]
    NSQ->sDiff_shp_Q14  = psDD->Diff_Q14;
   1349a:	f8d4 4504 	ldr.w	r4, [r4, #1284]	; 0x504
    NSQ->lagPrev        = pitchL[ psEncC->nb_subfr - 1 ];
   1349e:	f241 0ce8 	movw	ip, #4328	; 0x10e8
    NSQ->sDiff_shp_Q14  = psDD->Diff_Q14;
   134a2:	f241 00e4 	movw	r0, #4324	; 0x10e4
    NSQ->lagPrev        = pitchL[ psEncC->nb_subfr - 1 ];
   134a6:	f845 300c 	str.w	r3, [r5, ip]
    silk_memmove( NSQ->xq,           &NSQ->xq[           psEncC->frame_length ], psEncC->ltp_mem_length * sizeof( opus_int16 ) );
   134aa:	eb05 0141 	add.w	r1, r5, r1, lsl #1
    NSQ->sDiff_shp_Q14  = psDD->Diff_Q14;
   134ae:	502c      	str	r4, [r5, r0]
    silk_memmove( NSQ->xq,           &NSQ->xq[           psEncC->frame_length ], psEncC->ltp_mem_length * sizeof( opus_int16 ) );
   134b0:	0052      	lsls	r2, r2, #1
   134b2:	4628      	mov	r0, r5
   134b4:	f021 fdf2 	bl	3509c <memmove>
    silk_memmove( NSQ->sLTP_shp_Q14, &NSQ->sLTP_shp_Q14[ psEncC->frame_length ], psEncC->ltp_mem_length * sizeof( opus_int32 ) );
   134b8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   134ba:	69f8      	ldr	r0, [r7, #28]
   134bc:	5999      	ldr	r1, [r3, r6]
   134be:	f853 2008 	ldr.w	r2, [r3, r8]
   134c2:	f501 71a0 	add.w	r1, r1, #320	; 0x140
   134c6:	eb05 0181 	add.w	r1, r5, r1, lsl #2
   134ca:	0092      	lsls	r2, r2, #2
   134cc:	f021 fde6 	bl	3509c <memmove>
}
   134d0:	f507 7711 	add.w	r7, r7, #580	; 0x244
   134d4:	46bd      	mov	sp, r7
   134d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   134da:	428b      	cmp	r3, r1
   134dc:	dc05      	bgt.n	134ea <silk_NSQ_del_dec_c+0x22ae>
   134de:	4293      	cmp	r3, r2
   134e0:	bfb8      	it	lt
   134e2:	4613      	movlt	r3, r2
   134e4:	40ab      	lsls	r3, r5
   134e6:	f7fe b94b 	b.w	11780 <silk_NSQ_del_dec_c+0x544>
   134ea:	460b      	mov	r3, r1
   134ec:	e7fa      	b.n	134e4 <silk_NSQ_del_dec_c+0x22a8>
   134ee:	428b      	cmp	r3, r1
   134f0:	bfb8      	it	lt
   134f2:	460b      	movlt	r3, r1
   134f4:	e7f6      	b.n	134e4 <silk_NSQ_del_dec_c+0x22a8>
        for( k = 0; k < psEncC->nb_subfr; k++ ) {
   134f6:	f241 13e4 	movw	r3, #4580	; 0x11e4
   134fa:	58c3      	ldr	r3, [r0, r3]
   134fc:	2b00      	cmp	r3, #0
   134fe:	f77d af50 	ble.w	113a2 <silk_NSQ_del_dec_c+0x166>
   13502:	f8d7 1288 	ldr.w	r1, [r7, #648]	; 0x288
   13506:	f8d7 40ec 	ldr.w	r4, [r7, #236]	; 0xec
   1350a:	3904      	subs	r1, #4
   1350c:	eb01 0383 	add.w	r3, r1, r3, lsl #2
            decisionDelay = silk_min_int( decisionDelay, pitchL[ k ] - LTP_ORDER / 2 - 1 );
   13510:	f851 0f04 	ldr.w	r0, [r1, #4]!
   13514:	3803      	subs	r0, #3
   13516:	4284      	cmp	r4, r0
   13518:	bfa8      	it	ge
   1351a:	4604      	movge	r4, r0
        for( k = 0; k < psEncC->nb_subfr; k++ ) {
   1351c:	428b      	cmp	r3, r1
   1351e:	d1f7      	bne.n	13510 <silk_NSQ_del_dec_c+0x22d4>
   13520:	f8c7 40ec 	str.w	r4, [r7, #236]	; 0xec
   13524:	f7fd bf3d 	b.w	113a2 <silk_NSQ_del_dec_c+0x166>
                    for( i = 1; i < psEncC->nStatesDelayedDecision; i++ ) {
   13528:	6b7b      	ldr	r3, [r7, #52]	; 0x34
                    RDmin_Q10 = psDelDec[ 0 ].RD_Q10;
   1352a:	f8d7 2144 	ldr.w	r2, [r7, #324]	; 0x144
                    for( i = 1; i < psEncC->nStatesDelayedDecision; i++ ) {
   1352e:	6818      	ldr	r0, [r3, #0]
                    RDmin_Q10 = psDelDec[ 0 ].RD_Q10;
   13530:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
                    for( i = 1; i < psEncC->nStatesDelayedDecision; i++ ) {
   13534:	2801      	cmp	r0, #1
   13536:	f340 8091 	ble.w	1365c <silk_NSQ_del_dec_c+0x2420>
   1353a:	2301      	movs	r3, #1
                        if( psDelDec[ i ].RD_Q10 < RDmin_Q10 ) {
   1353c:	f8d2 4a24 	ldr.w	r4, [r2, #2596]	; 0xa24
   13540:	428c      	cmp	r4, r1
   13542:	bfb8      	it	lt
   13544:	469a      	movlt	sl, r3
                    for( i = 1; i < psEncC->nStatesDelayedDecision; i++ ) {
   13546:	f103 0301 	add.w	r3, r3, #1
                        if( psDelDec[ i ].RD_Q10 < RDmin_Q10 ) {
   1354a:	bfb8      	it	lt
   1354c:	4621      	movlt	r1, r4
                    for( i = 1; i < psEncC->nStatesDelayedDecision; i++ ) {
   1354e:	4298      	cmp	r0, r3
   13550:	f202 5214 	addw	r2, r2, #1300	; 0x514
   13554:	d1f2      	bne.n	1353c <silk_NSQ_del_dec_c+0x2300>
   13556:	f8d7 2144 	ldr.w	r2, [r7, #324]	; 0x144
                    for( i = 0; i < psEncC->nStatesDelayedDecision; i++ ) {
   1355a:	2300      	movs	r3, #0
                            psDelDec[ i ].RD_Q10 += ( silk_int32_MAX >> 4 );
   1355c:	f06f 4478 	mvn.w	r4, #4160749568	; 0xf8000000
                        if( i != Winner_ind ) {
   13560:	4553      	cmp	r3, sl
   13562:	f000 8095 	beq.w	13690 <silk_NSQ_del_dec_c+0x2454>
                            psDelDec[ i ].RD_Q10 += ( silk_int32_MAX >> 4 );
   13566:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
                    for( i = 0; i < psEncC->nStatesDelayedDecision; i++ ) {
   1356a:	3301      	adds	r3, #1
                            psDelDec[ i ].RD_Q10 += ( silk_int32_MAX >> 4 );
   1356c:	4421      	add	r1, r4
                    for( i = 0; i < psEncC->nStatesDelayedDecision; i++ ) {
   1356e:	4283      	cmp	r3, r0
                            psDelDec[ i ].RD_Q10 += ( silk_int32_MAX >> 4 );
   13570:	f8c2 1510 	str.w	r1, [r2, #1296]	; 0x510
   13574:	f202 5214 	addw	r2, r2, #1300	; 0x514
                    for( i = 0; i < psEncC->nStatesDelayedDecision; i++ ) {
   13578:	d1f2      	bne.n	13560 <silk_NSQ_del_dec_c+0x2324>
                    last_smple_idx = smpl_buf_idx + decisionDelay;
   1357a:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
   1357e:	f8d7 1148 	ldr.w	r1, [r7, #328]	; 0x148
                    for( i = 0; i < decisionDelay; i++ ) {
   13582:	2b00      	cmp	r3, #0
                    last_smple_idx = smpl_buf_idx + decisionDelay;
   13584:	eb03 0c01 	add.w	ip, r3, r1
                    for( i = 0; i < decisionDelay; i++ ) {
   13588:	dd62      	ble.n	13650 <silk_NSQ_del_dec_c+0x2414>
   1358a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   1358c:	683a      	ldr	r2, [r7, #0]
   1358e:	f8d7 6284 	ldr.w	r6, [r7, #644]	; 0x284
   13592:	eb03 0802 	add.w	r8, r3, r2
   13596:	f8d7 3268 	ldr.w	r3, [r7, #616]	; 0x268
   1359a:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
   1359e:	eb0a 0a8a 	add.w	sl, sl, sl, lsl #2
   135a2:	eb0a 1a8a 	add.w	sl, sl, sl, lsl #6
   135a6:	eba3 0902 	sub.w	r9, r3, r2
   135aa:	f04f 0e00 	mov.w	lr, #0
                        last_smple_idx = ( last_smple_idx - 1 ) % DECISION_DELAY;
   135ae:	4a41      	ldr	r2, [pc, #260]	; (136b4 <silk_NSQ_del_dec_c+0x2478>)
   135b0:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
   135b4:	fb82 1203 	smull	r1, r2, r2, r3
   135b8:	ea4f 7ce3 	mov.w	ip, r3, asr #31
   135bc:	ebcc 1c22 	rsb	ip, ip, r2, asr #4
   135c0:	eb0c 0c8c 	add.w	ip, ip, ip, lsl #2
                        if( last_smple_idx < 0 ) last_smple_idx += DECISION_DELAY;
   135c4:	ebb3 0ccc 	subs.w	ip, r3, ip, lsl #3
   135c8:	bf48      	it	mi
   135ca:	f10c 0c28 	addmi.w	ip, ip, #40	; 0x28
   135ce:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
   135d2:	eb0a 020c 	add.w	r2, sl, ip
   135d6:	eb03 0282 	add.w	r2, r3, r2, lsl #2
                        pxq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   135da:	f647 70ff 	movw	r0, #32767	; 0x7fff
                        pulses[   i - decisionDelay ] = (opus_int8)silk_RSHIFT_ROUND( psDD->Q_Q10[ last_smple_idx ], 10 );
   135de:	f8d2 3220 	ldr.w	r3, [r2, #544]	; 0x220
                        pxq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   135e2:	f8d2 42c0 	ldr.w	r4, [r2, #704]	; 0x2c0
                        pulses[   i - decisionDelay ] = (opus_int8)silk_RSHIFT_ROUND( psDD->Q_Q10[ last_smple_idx ], 10 );
   135e6:	125b      	asrs	r3, r3, #9
   135e8:	3301      	adds	r3, #1
   135ea:	105b      	asrs	r3, r3, #1
   135ec:	f809 3b01 	strb.w	r3, [r9], #1
                        pxq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   135f0:	6873      	ldr	r3, [r6, #4]
   135f2:	b2a5      	uxth	r5, r4
   135f4:	fa0f fb83 	sxth.w	fp, r3
   135f8:	1421      	asrs	r1, r4, #16
   135fa:	13db      	asrs	r3, r3, #15
   135fc:	3301      	adds	r3, #1
   135fe:	fb0b f505 	mul.w	r5, fp, r5
   13602:	fb0b f101 	mul.w	r1, fp, r1
   13606:	105b      	asrs	r3, r3, #1
   13608:	eb01 4125 	add.w	r1, r1, r5, asr #16
   1360c:	fb04 1303 	mla	r3, r4, r3, r1
   13610:	135b      	asrs	r3, r3, #13
   13612:	3301      	adds	r3, #1
   13614:	105b      	asrs	r3, r3, #1
   13616:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1361a:	da04      	bge.n	13626 <silk_NSQ_del_dec_c+0x23ea>
   1361c:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   13620:	bfb4      	ite	lt
   13622:	4825      	ldrlt	r0, [pc, #148]	; (136b8 <silk_NSQ_del_dec_c+0x247c>)
   13624:	b218      	sxthge	r0, r3
                        NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx - decisionDelay + i ] = psDD->Shape_Q14[ last_smple_idx ];
   13626:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
   1362a:	f8d7 10ec 	ldr.w	r1, [r7, #236]	; 0xec
   1362e:	681b      	ldr	r3, [r3, #0]
                        pxq[ i - decisionDelay ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND(
   13630:	f828 0f02 	strh.w	r0, [r8, #2]!
                        NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx - decisionDelay + i ] = psDD->Shape_Q14[ last_smple_idx ];
   13634:	1a5b      	subs	r3, r3, r1
   13636:	4473      	add	r3, lr
   13638:	f503 73a0 	add.w	r3, r3, #320	; 0x140
                    for( i = 0; i < decisionDelay; i++ ) {
   1363c:	f10e 0e01 	add.w	lr, lr, #1
                        NSQ->sLTP_shp_Q14[ NSQ->sLTP_shp_buf_idx - decisionDelay + i ] = psDD->Shape_Q14[ last_smple_idx ];
   13640:	f8d7 00bc 	ldr.w	r0, [r7, #188]	; 0xbc
   13644:	f8d2 2400 	ldr.w	r2, [r2, #1024]	; 0x400
   13648:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
                    for( i = 0; i < decisionDelay; i++ ) {
   1364c:	4571      	cmp	r1, lr
   1364e:	d1ae      	bne.n	135ae <silk_NSQ_del_dec_c+0x2372>
                if( k == 2 ) {
   13650:	2301      	movs	r3, #1
   13652:	65fb      	str	r3, [r7, #92]	; 0x5c
                    subfr = 0;
   13654:	2300      	movs	r3, #0
   13656:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
   1365a:	e5ea      	b.n	13232 <silk_NSQ_del_dec_c+0x1ff6>
                    for( i = 0; i < psEncC->nStatesDelayedDecision; i++ ) {
   1365c:	2800      	cmp	r0, #0
   1365e:	f73f af7c 	bgt.w	1355a <silk_NSQ_del_dec_c+0x231e>
   13662:	e78a      	b.n	1357a <silk_NSQ_del_dec_c+0x233e>
    for( k = 1; k < psEncC->nStatesDelayedDecision; k++ ) {
   13664:	2300      	movs	r3, #0
   13666:	f8c7 3198 	str.w	r3, [r7, #408]	; 0x198
    Winner_ind = 0;
   1366a:	461c      	mov	r4, r3
    for( k = 1; k < psEncC->nStatesDelayedDecision; k++ ) {
   1366c:	f44f 6394 	mov.w	r3, #1184	; 0x4a0
   13670:	f8c7 319c 	str.w	r3, [r7, #412]	; 0x19c
   13674:	e648      	b.n	13308 <silk_NSQ_del_dec_c+0x20cc>
   13676:	f506 63a0 	add.w	r3, r6, #1280	; 0x500
    for( k = 0; k < psEncC->nb_subfr; k++ ) {
   1367a:	f8d7 10ec 	ldr.w	r1, [r7, #236]	; 0xec
   1367e:	61fb      	str	r3, [r7, #28]
   13680:	e618      	b.n	132b4 <silk_NSQ_del_dec_c+0x2078>
   13682:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
   13686:	f503 5387 	add.w	r3, r3, #4320	; 0x10e0
   1368a:	60bb      	str	r3, [r7, #8]
   1368c:	f7fd be61 	b.w	11352 <silk_NSQ_del_dec_c+0x116>
                    for( i = 0; i < psEncC->nStatesDelayedDecision; i++ ) {
   13690:	3301      	adds	r3, #1
   13692:	4283      	cmp	r3, r0
   13694:	f202 5214 	addw	r2, r2, #1300	; 0x514
   13698:	f47f af62 	bne.w	13560 <silk_NSQ_del_dec_c+0x2324>
   1369c:	e76d      	b.n	1357a <silk_NSQ_del_dec_c+0x233e>
        RDmin_Q10  = psSampleState[ 0 ][ 1 ].RD_Q10;
   1369e:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
        RDmin_ind = 0;
   136a2:	f04f 0900 	mov.w	r9, #0
   136a6:	00a4      	lsls	r4, r4, #2
        RDmax_ind = 0;
   136a8:	464e      	mov	r6, r9
        RDmin_Q10  = psSampleState[ 0 ][ 1 ].RD_Q10;
   136aa:	f8d3 c020 	ldr.w	ip, [r3, #32]
   136ae:	4615      	mov	r5, r2
   136b0:	f7fe be1f 	b.w	122f2 <silk_NSQ_del_dec_c+0x10b6>
   136b4:	66666667 	.word	0x66666667
   136b8:	ffff8000 	.word	0xffff8000

000136bc <silk_shell_encoder>:
/* Shell encoder, operates on one shell code frame of 16 pulses */
void silk_shell_encoder(
    ec_enc                      *psRangeEnc,                    /* I/O  compressor data structure                   */
    const opus_int              *pulses0                        /* I    data: nonnegative pulse amplitudes          */
)
{
   136bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   136c0:	4688      	mov	r8, r1
   136c2:	b093      	sub	sp, #76	; 0x4c
        out[ k ] = in[ 2 * k ] + in[ 2 * k + 1 ];
   136c4:	f8d8 3018 	ldr.w	r3, [r8, #24]
   136c8:	9303      	str	r3, [sp, #12]
   136ca:	680e      	ldr	r6, [r1, #0]
   136cc:	f8d8 3004 	ldr.w	r3, [r8, #4]
   136d0:	688c      	ldr	r4, [r1, #8]
   136d2:	f8d8 2010 	ldr.w	r2, [r8, #16]
   136d6:	6949      	ldr	r1, [r1, #20]
   136d8:	f8d8 5024 	ldr.w	r5, [r8, #36]	; 0x24
   136dc:	f8d8 7034 	ldr.w	r7, [r8, #52]	; 0x34
   136e0:	18f3      	adds	r3, r6, r3
   136e2:	9301      	str	r3, [sp, #4]
   136e4:	f8d8 300c 	ldr.w	r3, [r8, #12]
   136e8:	191c      	adds	r4, r3, r4
   136ea:	9402      	str	r4, [sp, #8]
   136ec:	f8d8 301c 	ldr.w	r3, [r8, #28]
   136f0:	188c      	adds	r4, r1, r2
   136f2:	9903      	ldr	r1, [sp, #12]
   136f4:	4419      	add	r1, r3
   136f6:	f8d8 3020 	ldr.w	r3, [r8, #32]
   136fa:	9106      	str	r1, [sp, #24]
   136fc:	441d      	add	r5, r3
   136fe:	e9d8 360a 	ldrd	r3, r6, [r8, #40]	; 0x28
   13702:	eb03 0b06 	add.w	fp, r3, r6
   13706:	f8d8 3030 	ldr.w	r3, [r8, #48]	; 0x30
   1370a:	441f      	add	r7, r3
   1370c:	e9d8 360e 	ldrd	r3, r6, [r8, #56]	; 0x38
   13710:	eb03 0a06 	add.w	sl, r3, r6
   13714:	e9dd 3201 	ldrd	r3, r2, [sp, #4]
   13718:	1866      	adds	r6, r4, r1
   1371a:	9604      	str	r6, [sp, #16]
   1371c:	4413      	add	r3, r2
   1371e:	9e04      	ldr	r6, [sp, #16]
   13720:	9305      	str	r3, [sp, #20]
   13722:	eb0b 0205 	add.w	r2, fp, r5
   13726:	9203      	str	r2, [sp, #12]
   13728:	4433      	add	r3, r6
   1372a:	9e03      	ldr	r6, [sp, #12]
   1372c:	9307      	str	r3, [sp, #28]
   1372e:	eb07 020a 	add.w	r2, r7, sl
   13732:	9209      	str	r2, [sp, #36]	; 0x24
   13734:	18b2      	adds	r2, r6, r2
   13736:	9208      	str	r2, [sp, #32]
   13738:	461e      	mov	r6, r3
   1373a:	4413      	add	r3, r2
   1373c:	9a01      	ldr	r2, [sp, #4]
   1373e:	920a      	str	r2, [sp, #40]	; 0x28
   13740:	9a02      	ldr	r2, [sp, #8]
   13742:	f8cd a044 	str.w	sl, [sp, #68]	; 0x44
    if( p > 0 ) {
   13746:	2b00      	cmp	r3, #0
{
   13748:	4681      	mov	r9, r0
        out[ k ] = in[ 2 * k ] + in[ 2 * k + 1 ];
   1374a:	e9cd 240b 	strd	r2, r4, [sp, #44]	; 0x2c
   1374e:	e9cd 150d 	strd	r1, r5, [sp, #52]	; 0x34
   13752:	e9cd b70f 	strd	fp, r7, [sp, #60]	; 0x3c
    if( p > 0 ) {
   13756:	dd07      	ble.n	13768 <silk_shell_encoder+0xac>
        ec_enc_icdf( psRangeEnc, p_child1, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
   13758:	4a5e      	ldr	r2, [pc, #376]	; (138d4 <silk_shell_encoder+0x218>)
   1375a:	495f      	ldr	r1, [pc, #380]	; (138d8 <silk_shell_encoder+0x21c>)
   1375c:	5cd2      	ldrb	r2, [r2, r3]
   1375e:	2308      	movs	r3, #8
   13760:	440a      	add	r2, r1
   13762:	4631      	mov	r1, r6
   13764:	f016 fb8c 	bl	29e80 <ec_enc_icdf>
    if( p > 0 ) {
   13768:	9a07      	ldr	r2, [sp, #28]
   1376a:	2a00      	cmp	r2, #0
   1376c:	dd08      	ble.n	13780 <silk_shell_encoder+0xc4>
        ec_enc_icdf( psRangeEnc, p_child1, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
   1376e:	4b59      	ldr	r3, [pc, #356]	; (138d4 <silk_shell_encoder+0x218>)
   13770:	495a      	ldr	r1, [pc, #360]	; (138dc <silk_shell_encoder+0x220>)
   13772:	5c9a      	ldrb	r2, [r3, r2]
   13774:	4648      	mov	r0, r9
   13776:	440a      	add	r2, r1
   13778:	2308      	movs	r3, #8
   1377a:	9905      	ldr	r1, [sp, #20]
   1377c:	f016 fb80 	bl	29e80 <ec_enc_icdf>
    if( p > 0 ) {
   13780:	9a05      	ldr	r2, [sp, #20]
   13782:	2a00      	cmp	r2, #0
   13784:	dd08      	ble.n	13798 <silk_shell_encoder+0xdc>
        ec_enc_icdf( psRangeEnc, p_child1, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
   13786:	4b53      	ldr	r3, [pc, #332]	; (138d4 <silk_shell_encoder+0x218>)
   13788:	4955      	ldr	r1, [pc, #340]	; (138e0 <silk_shell_encoder+0x224>)
   1378a:	5c9a      	ldrb	r2, [r3, r2]
   1378c:	4648      	mov	r0, r9
   1378e:	440a      	add	r2, r1
   13790:	2308      	movs	r3, #8
   13792:	9901      	ldr	r1, [sp, #4]
   13794:	f016 fb74 	bl	29e80 <ec_enc_icdf>
    if( p > 0 ) {
   13798:	9901      	ldr	r1, [sp, #4]
   1379a:	2900      	cmp	r1, #0
   1379c:	dd09      	ble.n	137b2 <silk_shell_encoder+0xf6>
        ec_enc_icdf( psRangeEnc, p_child1, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
   1379e:	4b4d      	ldr	r3, [pc, #308]	; (138d4 <silk_shell_encoder+0x218>)
   137a0:	4a50      	ldr	r2, [pc, #320]	; (138e4 <silk_shell_encoder+0x228>)
   137a2:	5c5b      	ldrb	r3, [r3, r1]
   137a4:	f8d8 1000 	ldr.w	r1, [r8]
   137a8:	441a      	add	r2, r3
   137aa:	4648      	mov	r0, r9
   137ac:	2308      	movs	r3, #8
   137ae:	f016 fb67 	bl	29e80 <ec_enc_icdf>
    if( p > 0 ) {
   137b2:	9902      	ldr	r1, [sp, #8]
   137b4:	2900      	cmp	r1, #0
   137b6:	dd09      	ble.n	137cc <silk_shell_encoder+0x110>
        ec_enc_icdf( psRangeEnc, p_child1, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
   137b8:	4b46      	ldr	r3, [pc, #280]	; (138d4 <silk_shell_encoder+0x218>)
   137ba:	4a4a      	ldr	r2, [pc, #296]	; (138e4 <silk_shell_encoder+0x228>)
   137bc:	5c5b      	ldrb	r3, [r3, r1]
   137be:	f8d8 1008 	ldr.w	r1, [r8, #8]
   137c2:	441a      	add	r2, r3
   137c4:	4648      	mov	r0, r9
   137c6:	2308      	movs	r3, #8
   137c8:	f016 fb5a 	bl	29e80 <ec_enc_icdf>
    if( p > 0 ) {
   137cc:	9a04      	ldr	r2, [sp, #16]
   137ce:	2a00      	cmp	r2, #0
   137d0:	dd08      	ble.n	137e4 <silk_shell_encoder+0x128>
        ec_enc_icdf( psRangeEnc, p_child1, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
   137d2:	4b40      	ldr	r3, [pc, #256]	; (138d4 <silk_shell_encoder+0x218>)
   137d4:	4942      	ldr	r1, [pc, #264]	; (138e0 <silk_shell_encoder+0x224>)
   137d6:	5c9a      	ldrb	r2, [r3, r2]
   137d8:	4648      	mov	r0, r9
   137da:	440a      	add	r2, r1
   137dc:	2308      	movs	r3, #8
   137de:	4621      	mov	r1, r4
   137e0:	f016 fb4e 	bl	29e80 <ec_enc_icdf>
    if( p > 0 ) {
   137e4:	2c00      	cmp	r4, #0
   137e6:	dd09      	ble.n	137fc <silk_shell_encoder+0x140>
        ec_enc_icdf( psRangeEnc, p_child1, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
   137e8:	4b3a      	ldr	r3, [pc, #232]	; (138d4 <silk_shell_encoder+0x218>)
   137ea:	4a3e      	ldr	r2, [pc, #248]	; (138e4 <silk_shell_encoder+0x228>)
   137ec:	5d1b      	ldrb	r3, [r3, r4]
   137ee:	f8d8 1010 	ldr.w	r1, [r8, #16]
   137f2:	441a      	add	r2, r3
   137f4:	4648      	mov	r0, r9
   137f6:	2308      	movs	r3, #8
   137f8:	f016 fb42 	bl	29e80 <ec_enc_icdf>
    if( p > 0 ) {
   137fc:	9906      	ldr	r1, [sp, #24]
   137fe:	2900      	cmp	r1, #0
   13800:	dd09      	ble.n	13816 <silk_shell_encoder+0x15a>
        ec_enc_icdf( psRangeEnc, p_child1, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
   13802:	4b34      	ldr	r3, [pc, #208]	; (138d4 <silk_shell_encoder+0x218>)
   13804:	4a37      	ldr	r2, [pc, #220]	; (138e4 <silk_shell_encoder+0x228>)
   13806:	5c5b      	ldrb	r3, [r3, r1]
   13808:	f8d8 1018 	ldr.w	r1, [r8, #24]
   1380c:	441a      	add	r2, r3
   1380e:	4648      	mov	r0, r9
   13810:	2308      	movs	r3, #8
   13812:	f016 fb35 	bl	29e80 <ec_enc_icdf>
    if( p > 0 ) {
   13816:	9a08      	ldr	r2, [sp, #32]
   13818:	2a00      	cmp	r2, #0
   1381a:	dd08      	ble.n	1382e <silk_shell_encoder+0x172>
        ec_enc_icdf( psRangeEnc, p_child1, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
   1381c:	4b2d      	ldr	r3, [pc, #180]	; (138d4 <silk_shell_encoder+0x218>)
   1381e:	492f      	ldr	r1, [pc, #188]	; (138dc <silk_shell_encoder+0x220>)
   13820:	5c9a      	ldrb	r2, [r3, r2]
   13822:	4648      	mov	r0, r9
   13824:	440a      	add	r2, r1
   13826:	2308      	movs	r3, #8
   13828:	9903      	ldr	r1, [sp, #12]
   1382a:	f016 fb29 	bl	29e80 <ec_enc_icdf>
    if( p > 0 ) {
   1382e:	9a03      	ldr	r2, [sp, #12]
   13830:	2a00      	cmp	r2, #0
   13832:	dd08      	ble.n	13846 <silk_shell_encoder+0x18a>
        ec_enc_icdf( psRangeEnc, p_child1, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
   13834:	4b27      	ldr	r3, [pc, #156]	; (138d4 <silk_shell_encoder+0x218>)
   13836:	492a      	ldr	r1, [pc, #168]	; (138e0 <silk_shell_encoder+0x224>)
   13838:	5c9a      	ldrb	r2, [r3, r2]
   1383a:	4648      	mov	r0, r9
   1383c:	440a      	add	r2, r1
   1383e:	2308      	movs	r3, #8
   13840:	4629      	mov	r1, r5
   13842:	f016 fb1d 	bl	29e80 <ec_enc_icdf>
    if( p > 0 ) {
   13846:	2d00      	cmp	r5, #0
   13848:	dd09      	ble.n	1385e <silk_shell_encoder+0x1a2>
        ec_enc_icdf( psRangeEnc, p_child1, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
   1384a:	4b22      	ldr	r3, [pc, #136]	; (138d4 <silk_shell_encoder+0x218>)
   1384c:	4a25      	ldr	r2, [pc, #148]	; (138e4 <silk_shell_encoder+0x228>)
   1384e:	5d5b      	ldrb	r3, [r3, r5]
   13850:	f8d8 1020 	ldr.w	r1, [r8, #32]
   13854:	441a      	add	r2, r3
   13856:	4648      	mov	r0, r9
   13858:	2308      	movs	r3, #8
   1385a:	f016 fb11 	bl	29e80 <ec_enc_icdf>
    if( p > 0 ) {
   1385e:	f1bb 0f00 	cmp.w	fp, #0
   13862:	dd0a      	ble.n	1387a <silk_shell_encoder+0x1be>
        ec_enc_icdf( psRangeEnc, p_child1, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
   13864:	4b1b      	ldr	r3, [pc, #108]	; (138d4 <silk_shell_encoder+0x218>)
   13866:	4a1f      	ldr	r2, [pc, #124]	; (138e4 <silk_shell_encoder+0x228>)
   13868:	f813 300b 	ldrb.w	r3, [r3, fp]
   1386c:	f8d8 1028 	ldr.w	r1, [r8, #40]	; 0x28
   13870:	441a      	add	r2, r3
   13872:	4648      	mov	r0, r9
   13874:	2308      	movs	r3, #8
   13876:	f016 fb03 	bl	29e80 <ec_enc_icdf>
    if( p > 0 ) {
   1387a:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1387c:	2a00      	cmp	r2, #0
   1387e:	dd08      	ble.n	13892 <silk_shell_encoder+0x1d6>
        ec_enc_icdf( psRangeEnc, p_child1, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
   13880:	4b14      	ldr	r3, [pc, #80]	; (138d4 <silk_shell_encoder+0x218>)
   13882:	4917      	ldr	r1, [pc, #92]	; (138e0 <silk_shell_encoder+0x224>)
   13884:	5c9a      	ldrb	r2, [r3, r2]
   13886:	4648      	mov	r0, r9
   13888:	440a      	add	r2, r1
   1388a:	2308      	movs	r3, #8
   1388c:	4639      	mov	r1, r7
   1388e:	f016 faf7 	bl	29e80 <ec_enc_icdf>
    if( p > 0 ) {
   13892:	2f00      	cmp	r7, #0
   13894:	dd09      	ble.n	138aa <silk_shell_encoder+0x1ee>
        ec_enc_icdf( psRangeEnc, p_child1, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
   13896:	4b0f      	ldr	r3, [pc, #60]	; (138d4 <silk_shell_encoder+0x218>)
   13898:	4a12      	ldr	r2, [pc, #72]	; (138e4 <silk_shell_encoder+0x228>)
   1389a:	5ddb      	ldrb	r3, [r3, r7]
   1389c:	f8d8 1030 	ldr.w	r1, [r8, #48]	; 0x30
   138a0:	441a      	add	r2, r3
   138a2:	4648      	mov	r0, r9
   138a4:	2308      	movs	r3, #8
   138a6:	f016 faeb 	bl	29e80 <ec_enc_icdf>
    if( p > 0 ) {
   138aa:	f1ba 0f00 	cmp.w	sl, #0
   138ae:	dd0d      	ble.n	138cc <silk_shell_encoder+0x210>
        ec_enc_icdf( psRangeEnc, p_child1, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
   138b0:	4b08      	ldr	r3, [pc, #32]	; (138d4 <silk_shell_encoder+0x218>)
   138b2:	4a0c      	ldr	r2, [pc, #48]	; (138e4 <silk_shell_encoder+0x228>)
   138b4:	f813 300a 	ldrb.w	r3, [r3, sl]
   138b8:	f8d8 1038 	ldr.w	r1, [r8, #56]	; 0x38
   138bc:	441a      	add	r2, r3
   138be:	4648      	mov	r0, r9
   138c0:	2308      	movs	r3, #8
    encode_split( psRangeEnc, pulses0[ 10 ], pulses1[ 5 ], silk_shell_code_table0 );

    encode_split( psRangeEnc, pulses1[  6 ], pulses2[ 3 ], silk_shell_code_table1 );
    encode_split( psRangeEnc, pulses0[ 12 ], pulses1[ 6 ], silk_shell_code_table0 );
    encode_split( psRangeEnc, pulses0[ 14 ], pulses1[ 7 ], silk_shell_code_table0 );
}
   138c2:	b013      	add	sp, #76	; 0x4c
   138c4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        ec_enc_icdf( psRangeEnc, p_child1, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
   138c8:	f016 bada 	b.w	29e80 <ec_enc_icdf>
}
   138cc:	b013      	add	sp, #76	; 0x4c
   138ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   138d2:	bf00      	nop
   138d4:	000371bc 	.word	0x000371bc
   138d8:	00037124 	.word	0x00037124
   138dc:	0003708c 	.word	0x0003708c
   138e0:	00036ff4 	.word	0x00036ff4
   138e4:	00036f5c 	.word	0x00036f5c

000138e8 <silk_VAD_Init>:
/* Initialization of the Silk VAD */
/**********************************/
opus_int silk_VAD_Init(                                         /* O    Return value, 0 if success                  */
    silk_VAD_state              *psSilk_VAD                     /* I/O  Pointer to Silk VAD state                   */
)
{
   138e8:	b538      	push	{r3, r4, r5, lr}
    opus_int b, ret = 0;

    /* reset state memory */
    silk_memset( psSilk_VAD, 0, sizeof( silk_VAD_state ) );
   138ea:	2270      	movs	r2, #112	; 0x70
   138ec:	2100      	movs	r1, #0
   138ee:	f021 fc39 	bl	35164 <memset>
   138f2:	4603      	mov	r3, r0

    /* init noise levels */
    /* Initialize array with approx pink noise levels (psd proportional to inverse of frequency) */
    for( b = 0; b < VAD_N_BANDS; b++ ) {
        psSilk_VAD->NoiseLevelBias[ b ] = silk_max_32( silk_DIV32_16( VAD_NOISE_LEVELS_BIAS, b + 1 ), 1 );
   138f4:	2432      	movs	r4, #50	; 0x32
   138f6:	2019      	movs	r0, #25
   138f8:	2110      	movs	r1, #16
   138fa:	220c      	movs	r2, #12
    }

    /* Initialize state */
    for( b = 0; b < VAD_N_BANDS; b++ ) {
        psSilk_VAD->NL[ b ]     = silk_MUL( 100, psSilk_VAD->NoiseLevelBias[ b ] );
   138fc:	f241 3588 	movw	r5, #5000	; 0x1388
        psSilk_VAD->NoiseLevelBias[ b ] = silk_max_32( silk_DIV32_16( VAD_NOISE_LEVELS_BIAS, b + 1 ), 1 );
   13900:	65dc      	str	r4, [r3, #92]	; 0x5c
   13902:	6618      	str	r0, [r3, #96]	; 0x60
        psSilk_VAD->inv_NL[ b ] = silk_DIV32( silk_int32_MAX, psSilk_VAD->NL[ b ] );
   13904:	4c10      	ldr	r4, [pc, #64]	; (13948 <silk_VAD_Init+0x60>)
        psSilk_VAD->NoiseLevelBias[ b ] = silk_max_32( silk_DIV32_16( VAD_NOISE_LEVELS_BIAS, b + 1 ), 1 );
   13906:	6659      	str	r1, [r3, #100]	; 0x64
        psSilk_VAD->NL[ b ]     = silk_MUL( 100, psSilk_VAD->NoiseLevelBias[ b ] );
   13908:	f640 10c4 	movw	r0, #2500	; 0x9c4
        psSilk_VAD->inv_NL[ b ] = silk_DIV32( silk_int32_MAX, psSilk_VAD->NL[ b ] );
   1390c:	490f      	ldr	r1, [pc, #60]	; (1394c <silk_VAD_Init+0x64>)
        psSilk_VAD->NoiseLevelBias[ b ] = silk_max_32( silk_DIV32_16( VAD_NOISE_LEVELS_BIAS, b + 1 ), 1 );
   1390e:	669a      	str	r2, [r3, #104]	; 0x68
        psSilk_VAD->NL[ b ]     = silk_MUL( 100, psSilk_VAD->NoiseLevelBias[ b ] );
   13910:	63dd      	str	r5, [r3, #60]	; 0x3c
   13912:	f44f 62c8 	mov.w	r2, #1600	; 0x640
        psSilk_VAD->inv_NL[ b ] = silk_DIV32( silk_int32_MAX, psSilk_VAD->NL[ b ] );
   13916:	f505 15a3 	add.w	r5, r5, #1335296	; 0x146000
   1391a:	f205 7559 	addw	r5, r5, #1881	; 0x759
   1391e:	64dc      	str	r4, [r3, #76]	; 0x4c
        psSilk_VAD->NL[ b ]     = silk_MUL( 100, psSilk_VAD->NoiseLevelBias[ b ] );
   13920:	6418      	str	r0, [r3, #64]	; 0x40
   13922:	f44f 6496 	mov.w	r4, #1200	; 0x4b0
        psSilk_VAD->inv_NL[ b ] = silk_DIV32( silk_int32_MAX, psSilk_VAD->NL[ b ] );
   13926:	480a      	ldr	r0, [pc, #40]	; (13950 <silk_VAD_Init+0x68>)
   13928:	6519      	str	r1, [r3, #80]	; 0x50
        psSilk_VAD->NL[ b ]     = silk_MUL( 100, psSilk_VAD->NoiseLevelBias[ b ] );
   1392a:	645a      	str	r2, [r3, #68]	; 0x44
    }
    psSilk_VAD->counter = 15;
   1392c:	210f      	movs	r1, #15

    /* init smoothed energy-to-noise ratio*/
    for( b = 0; b < VAD_N_BANDS; b++ ) {
        psSilk_VAD->NrgRatioSmth_Q8[ b ] = 100 * 256;       /* 100 * 256 --> 20 dB SNR */
   1392e:	f44f 42c8 	mov.w	r2, #25600	; 0x6400
        psSilk_VAD->inv_NL[ b ] = silk_DIV32( silk_int32_MAX, psSilk_VAD->NL[ b ] );
   13932:	6598      	str	r0, [r3, #88]	; 0x58
   13934:	655d      	str	r5, [r3, #84]	; 0x54
        psSilk_VAD->NL[ b ]     = silk_MUL( 100, psSilk_VAD->NoiseLevelBias[ b ] );
   13936:	649c      	str	r4, [r3, #72]	; 0x48
    psSilk_VAD->counter = 15;
   13938:	66d9      	str	r1, [r3, #108]	; 0x6c
        psSilk_VAD->NrgRatioSmth_Q8[ b ] = 100 * 256;       /* 100 * 256 --> 20 dB SNR */
   1393a:	e9c3 220a 	strd	r2, r2, [r3, #40]	; 0x28
   1393e:	e9c3 220c 	strd	r2, r2, [r3, #48]	; 0x30
    }

    return( ret );
}
   13942:	2000      	movs	r0, #0
   13944:	bd38      	pop	{r3, r4, r5, pc}
   13946:	bf00      	nop
   13948:	00068db8 	.word	0x00068db8
   1394c:	000d1b71 	.word	0x000d1b71
   13950:	001b4e81 	.word	0x001b4e81

00013954 <silk_VAD_GetSA_Q8_c>:
/***************************************/
opus_int silk_VAD_GetSA_Q8_c(                                   /* O    Return value, 0 if success                  */
    silk_encoder_state          *psEncC,                        /* I/O  Encoder state                               */
    const opus_int16            pIn[]                           /* I    PCM input                                   */
)
{
   13954:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    celt_assert( psEncC->frame_length == 8 * silk_RSHIFT( psEncC->frame_length, 3 ) );

    /***********************/
    /* Filter and Decimate */
    /***********************/
    decimated_framelength1 = silk_RSHIFT( psEncC->frame_length, 1 );
   13958:	f241 13e8 	movw	r3, #4584	; 0x11e8
{
   1395c:	b091      	sub	sp, #68	; 0x44
    decimated_framelength1 = silk_RSHIFT( psEncC->frame_length, 1 );
   1395e:	58c2      	ldr	r2, [r0, r3]
    decimated_framelength2 = silk_RSHIFT( psEncC->frame_length, 2 );
   13960:	1094      	asrs	r4, r2, #2
    decimated_framelength = silk_RSHIFT( psEncC->frame_length, 3 );
   13962:	10d6      	asrs	r6, r2, #3
       [0-1 kHz| temp. |1-2 kHz|    2-4 kHz    |            4-8 kHz           |

       They're arranged to allow the minimal ( frame_length / 4 ) extra
       scratch space during the downsampling process */
    X_offset[ 0 ] = 0;
    X_offset[ 1 ] = decimated_framelength + decimated_framelength2;
   13964:	eb04 0806 	add.w	r8, r4, r6
    X_offset[ 2 ] = X_offset[ 1 ] + decimated_framelength;
   13968:	eb08 0a06 	add.w	sl, r8, r6
    X_offset[ 3 ] = X_offset[ 2 ] + decimated_framelength2;
   1396c:	eb0a 0c04 	add.w	ip, sl, r4
    decimated_framelength1 = silk_RSHIFT( psEncC->frame_length, 1 );
   13970:	ea4f 0b62 	mov.w	fp, r2, asr #1
    ALLOC( X, X_offset[ 3 ] + decimated_framelength1, opus_int16 );
   13974:	eb0c 030b 	add.w	r3, ip, fp
   13978:	005b      	lsls	r3, r3, #1
   1397a:	3308      	adds	r3, #8
   1397c:	f023 0307 	bic.w	r3, r3, #7
{
   13980:	af02      	add	r7, sp, #8
    ALLOC( X, X_offset[ 3 ] + decimated_framelength1, opus_int16 );
   13982:	ebad 0d03 	sub.w	sp, sp, r3
   13986:	ad02      	add	r5, sp, #8
{
   13988:	4681      	mov	r9, r0

    /* 0-8 kHz to 0-4 kHz and 4-8 kHz */
    silk_ana_filt_bank_1( pIn, &psSilk_VAD->AnaState[  0 ],
   1398a:	eb05 034c 	add.w	r3, r5, ip, lsl #1
    X_offset[ 0 ] = 0;
   1398e:	f04f 0e00 	mov.w	lr, #0
    silk_ana_filt_bank_1( pIn, &psSilk_VAD->AnaState[  0 ],
   13992:	4608      	mov	r0, r1
   13994:	9200      	str	r2, [sp, #0]
   13996:	f109 0124 	add.w	r1, r9, #36	; 0x24
   1399a:	462a      	mov	r2, r5
    X_offset[ 3 ] = X_offset[ 2 ] + decimated_framelength2;
   1399c:	f8c7 c034 	str.w	ip, [r7, #52]	; 0x34
    X_offset[ 0 ] = 0;
   139a0:	f8c7 e028 	str.w	lr, [r7, #40]	; 0x28
    X_offset[ 2 ] = X_offset[ 1 ] + decimated_framelength;
   139a4:	e9c7 8a0b 	strd	r8, sl, [r7, #44]	; 0x2c
    silk_ana_filt_bank_1( pIn, &psSilk_VAD->AnaState[  0 ],
   139a8:	f003 fd7a 	bl	174a0 <silk_ana_filt_bank_1>
        X, &X[ X_offset[ 3 ] ], psEncC->frame_length );

    /* 0-4 kHz to 0-2 kHz and 2-4 kHz */
    silk_ana_filt_bank_1( X, &psSilk_VAD->AnaState1[ 0 ],
   139ac:	eb05 034a 	add.w	r3, r5, sl, lsl #1
   139b0:	462a      	mov	r2, r5
   139b2:	4628      	mov	r0, r5
   139b4:	f109 012c 	add.w	r1, r9, #44	; 0x2c
   139b8:	f8cd b000 	str.w	fp, [sp]
   139bc:	f003 fd70 	bl	174a0 <silk_ana_filt_bank_1>
        X, &X[ X_offset[ 2 ] ], decimated_framelength1 );

    /* 0-2 kHz to 0-1 kHz and 1-2 kHz */
    silk_ana_filt_bank_1( X, &psSilk_VAD->AnaState2[ 0 ],
   139c0:	eb05 0348 	add.w	r3, r5, r8, lsl #1
   139c4:	9400      	str	r4, [sp, #0]
   139c6:	462a      	mov	r2, r5
   139c8:	4628      	mov	r0, r5
   139ca:	f109 0134 	add.w	r1, r9, #52	; 0x34
   139ce:	f003 fd67 	bl	174a0 <silk_ana_filt_bank_1>
   139d2:	eb05 0246 	add.w	r2, r5, r6, lsl #1
        X, &X[ X_offset[ 1 ] ], decimated_framelength2 );

    /*********************************************/
    /* HP filter on lowest band (differentiator) */
    /*********************************************/
    X[ decimated_framelength - 1 ] = silk_RSHIFT( X[ decimated_framelength - 1 ], 1 );
   139d6:	1e73      	subs	r3, r6, #1
   139d8:	f932 4c02 	ldrsh.w	r4, [r2, #-2]
    HPstateTmp = X[ decimated_framelength - 1 ];
    for( i = decimated_framelength - 1; i > 0; i-- ) {
   139dc:	2b00      	cmp	r3, #0
    X[ decimated_framelength - 1 ] = silk_RSHIFT( X[ decimated_framelength - 1 ], 1 );
   139de:	ea4f 0464 	mov.w	r4, r4, asr #1
   139e2:	f822 4c02 	strh.w	r4, [r2, #-2]
    for( i = decimated_framelength - 1; i > 0; i-- ) {
   139e6:	dd28      	ble.n	13a3a <silk_VAD_GetSA_Q8_c+0xe6>
   139e8:	2e03      	cmp	r6, #3
   139ea:	dd19      	ble.n	13a20 <silk_VAD_GetSA_Q8_c+0xcc>
   139ec:	1f31      	subs	r1, r6, #4
   139ee:	f021 0101 	bic.w	r1, r1, #1
   139f2:	3e03      	subs	r6, #3
   139f4:	b220      	sxth	r0, r4
   139f6:	1a76      	subs	r6, r6, r1
        X[ i - 1 ]  = silk_RSHIFT( X[ i - 1 ], 1 );
   139f8:	f932 1c04 	ldrsh.w	r1, [r2, #-4]
   139fc:	f932 ec06 	ldrsh.w	lr, [r2, #-6]
        X[ i ]     -= X[ i - 1 ];
   13a00:	f3c1 014f 	ubfx	r1, r1, #1, #16
   13a04:	eba0 0c01 	sub.w	ip, r0, r1
   13a08:	3b02      	subs	r3, #2
        X[ i - 1 ]  = silk_RSHIFT( X[ i - 1 ], 1 );
   13a0a:	ea4f 006e 	mov.w	r0, lr, asr #1
        X[ i ]     -= X[ i - 1 ];
   13a0e:	1a09      	subs	r1, r1, r0
   13a10:	429e      	cmp	r6, r3
   13a12:	f822 cc02 	strh.w	ip, [r2, #-2]
        X[ i - 1 ]  = silk_RSHIFT( X[ i - 1 ], 1 );
   13a16:	f822 0c06 	strh.w	r0, [r2, #-6]
        X[ i ]     -= X[ i - 1 ];
   13a1a:	f822 1d04 	strh.w	r1, [r2, #-4]!
   13a1e:	d1eb      	bne.n	139f8 <silk_VAD_GetSA_Q8_c+0xa4>
   13a20:	eb05 0243 	add.w	r2, r5, r3, lsl #1
        X[ i - 1 ]  = silk_RSHIFT( X[ i - 1 ], 1 );
   13a24:	f932 1c02 	ldrsh.w	r1, [r2, #-2]
        X[ i ]     -= X[ i - 1 ];
   13a28:	8810      	ldrh	r0, [r2, #0]
        X[ i - 1 ]  = silk_RSHIFT( X[ i - 1 ], 1 );
   13a2a:	1049      	asrs	r1, r1, #1
        X[ i ]     -= X[ i - 1 ];
   13a2c:	1a40      	subs	r0, r0, r1
    for( i = decimated_framelength - 1; i > 0; i-- ) {
   13a2e:	3b01      	subs	r3, #1
        X[ i - 1 ]  = silk_RSHIFT( X[ i - 1 ], 1 );
   13a30:	f822 1c02 	strh.w	r1, [r2, #-2]
        X[ i ]     -= X[ i - 1 ];
   13a34:	f822 0902 	strh.w	r0, [r2], #-2
    for( i = decimated_framelength - 1; i > 0; i-- ) {
   13a38:	d1f4      	bne.n	13a24 <silk_VAD_GetSA_Q8_c+0xd0>
    }
    X[ 0 ] -= psSilk_VAD->HPstate;
   13a3a:	f8b9 105c 	ldrh.w	r1, [r9, #92]	; 0x5c
   13a3e:	882b      	ldrh	r3, [r5, #0]
    psSilk_VAD->HPstate = HPstateTmp;
   13a40:	f8a9 405c 	strh.w	r4, [r9, #92]	; 0x5c
    /*************************************/
    /* Calculate the energy in each band */
    /*************************************/
    for( b = 0; b < VAD_N_BANDS; b++ ) {
        /* Find the decimated framelength in the non-uniformly divided bands */
        decimated_framelength = silk_RSHIFT( psEncC->frame_length, silk_min_int( VAD_N_BANDS - b, VAD_N_BANDS - 1 ) );
   13a44:	f241 12e8 	movw	r2, #4584	; 0x11e8
    X[ 0 ] -= psSilk_VAD->HPstate;
   13a48:	1a5b      	subs	r3, r3, r1
        decimated_framelength = silk_RSHIFT( psEncC->frame_length, silk_min_int( VAD_N_BANDS - b, VAD_N_BANDS - 1 ) );
   13a4a:	f859 2002 	ldr.w	r2, [r9, r2]
    X[ 0 ] -= psSilk_VAD->HPstate;
   13a4e:	802b      	strh	r3, [r5, #0]
   13a50:	f109 033c 	add.w	r3, r9, #60	; 0x3c
                silk_assert( sumSquared >= 0 );
            }

            /* Add/saturate summed energy of current subframe */
            if( s < VAD_INTERNAL_SUBFRAMES - 1 ) {
                Xnrg[ b ] = silk_ADD_POS_SAT32( Xnrg[ b ], sumSquared );
   13a54:	f8c7 9000 	str.w	r9, [r7]
        decimated_framelength = silk_RSHIFT( psEncC->frame_length, silk_min_int( VAD_N_BANDS - b, VAD_N_BANDS - 1 ) );
   13a58:	607a      	str	r2, [r7, #4]
   13a5a:	f107 0808 	add.w	r8, r7, #8
   13a5e:	f107 0b28 	add.w	fp, r7, #40	; 0x28
   13a62:	f04f 0a04 	mov.w	sl, #4
                Xnrg[ b ] = silk_ADD_POS_SAT32( Xnrg[ b ], sumSquared );
   13a66:	4699      	mov	r9, r3
   13a68:	4656      	mov	r6, sl
   13a6a:	2e03      	cmp	r6, #3
        decimated_framelength = silk_RSHIFT( psEncC->frame_length, silk_min_int( VAD_N_BANDS - b, VAD_N_BANDS - 1 ) );
   13a6c:	687b      	ldr	r3, [r7, #4]
        Xnrg[ b ] = psSilk_VAD->XnrgSubfr[ b ];
   13a6e:	f859 4b04 	ldr.w	r4, [r9], #4
   13a72:	f848 4b04 	str.w	r4, [r8], #4
   13a76:	bfa8      	it	ge
   13a78:	2603      	movge	r6, #3
        decimated_framelength = silk_RSHIFT( psEncC->frame_length, silk_min_int( VAD_N_BANDS - b, VAD_N_BANDS - 1 ) );
   13a7a:	fa43 f606 	asr.w	r6, r3, r6
        dec_subframe_length = silk_RSHIFT( decimated_framelength, VAD_INTERNAL_SUBFRAMES_LOG2 );
   13a7e:	10b6      	asrs	r6, r6, #2
        Xnrg[ b ] = psSilk_VAD->XnrgSubfr[ b ];
   13a80:	f04f 0e04 	mov.w	lr, #4
        dec_subframe_offset = 0;
   13a84:	f04f 0c00 	mov.w	ip, #0
            for( i = 0; i < dec_subframe_length; i++ ) {
   13a88:	2e00      	cmp	r6, #0
   13a8a:	dd1d      	ble.n	13ac8 <silk_VAD_GetSA_Q8_c+0x174>
   13a8c:	f8db 2000 	ldr.w	r2, [fp]
   13a90:	18b0      	adds	r0, r6, r2
   13a92:	4460      	add	r0, ip
   13a94:	4462      	add	r2, ip
   13a96:	eb05 0040 	add.w	r0, r5, r0, lsl #1
   13a9a:	eb05 0242 	add.w	r2, r5, r2, lsl #1
            sumSquared = 0;
   13a9e:	2100      	movs	r1, #0
                x_tmp = silk_RSHIFT(
   13aa0:	f932 3b02 	ldrsh.w	r3, [r2], #2
   13aa4:	10db      	asrs	r3, r3, #3
            for( i = 0; i < dec_subframe_length; i++ ) {
   13aa6:	4290      	cmp	r0, r2
                sumSquared = silk_SMLABB( sumSquared, x_tmp, x_tmp );
   13aa8:	fb03 1103 	mla	r1, r3, r3, r1
            for( i = 0; i < dec_subframe_length; i++ ) {
   13aac:	d1f8      	bne.n	13aa0 <silk_VAD_GetSA_Q8_c+0x14c>
            if( s < VAD_INTERNAL_SUBFRAMES - 1 ) {
   13aae:	f1be 0f01 	cmp.w	lr, #1
   13ab2:	d00e      	beq.n	13ad2 <silk_VAD_GetSA_Q8_c+0x17e>
                Xnrg[ b ] = silk_ADD_POS_SAT32( Xnrg[ b ], sumSquared );
   13ab4:	190c      	adds	r4, r1, r4
   13ab6:	f100 8221 	bmi.w	13efc <silk_VAD_GetSA_Q8_c+0x5a8>
            for( i = 0; i < dec_subframe_length; i++ ) {
   13aba:	2e00      	cmp	r6, #0
                Xnrg[ b ] = silk_ADD_POS_SAT32( Xnrg[ b ], sumSquared );
   13abc:	f848 4c04 	str.w	r4, [r8, #-4]
            } else {
                /* Look-ahead subframe */
                Xnrg[ b ] = silk_ADD_POS_SAT32( Xnrg[ b ], silk_RSHIFT( sumSquared, 1 ) );
            }

            dec_subframe_offset += dec_subframe_length;
   13ac0:	44b4      	add	ip, r6
   13ac2:	f10e 3eff 	add.w	lr, lr, #4294967295	; 0xffffffff
            for( i = 0; i < dec_subframe_length; i++ ) {
   13ac6:	dce1      	bgt.n	13a8c <silk_VAD_GetSA_Q8_c+0x138>
            if( s < VAD_INTERNAL_SUBFRAMES - 1 ) {
   13ac8:	f1be 0f01 	cmp.w	lr, #1
            sumSquared = 0;
   13acc:	f04f 0100 	mov.w	r1, #0
            if( s < VAD_INTERNAL_SUBFRAMES - 1 ) {
   13ad0:	d1f0      	bne.n	13ab4 <silk_VAD_GetSA_Q8_c+0x160>
                Xnrg[ b ] = silk_ADD_POS_SAT32( Xnrg[ b ], silk_RSHIFT( sumSquared, 1 ) );
   13ad2:	eb14 0461 	adds.w	r4, r4, r1, asr #1
   13ad6:	bf48      	it	mi
   13ad8:	f06f 4400 	mvnmi.w	r4, #2147483648	; 0x80000000
    for( b = 0; b < VAD_N_BANDS; b++ ) {
   13adc:	f1ba 0a01 	subs.w	sl, sl, #1
                Xnrg[ b ] = silk_ADD_POS_SAT32( Xnrg[ b ], silk_RSHIFT( sumSquared, 1 ) );
   13ae0:	f848 4c04 	str.w	r4, [r8, #-4]
        }
        psSilk_VAD->XnrgSubfr[ b ] = sumSquared;
   13ae4:	f849 1c04 	str.w	r1, [r9, #-4]
   13ae8:	f10b 0b04 	add.w	fp, fp, #4
    for( b = 0; b < VAD_N_BANDS; b++ ) {
   13aec:	d1bc      	bne.n	13a68 <silk_VAD_GetSA_Q8_c+0x114>
   13aee:	f8d7 9000 	ldr.w	r9, [r7]
    opus_int   k;
    opus_int32 nl, nrg, inv_nrg;
    opus_int   coef, min_coef;

    /* Initially faster smoothing */
    if( psSilk_VAD->counter < 1000 ) { /* 1000 = 20 sec */
   13af2:	f8d9 3090 	ldr.w	r3, [r9, #144]	; 0x90
   13af6:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
   13afa:	f280 8208 	bge.w	13f0e <silk_VAD_GetSA_Q8_c+0x5ba>
        min_coef = silk_DIV32_16( silk_int16_MAX, silk_RSHIFT( psSilk_VAD->counter, 4 ) + 1 );
   13afe:	111a      	asrs	r2, r3, #4
        /* Increment frame counter */
        psSilk_VAD->counter++;
   13b00:	3301      	adds	r3, #1
   13b02:	f8c9 3090 	str.w	r3, [r9, #144]	; 0x90
        /* Get old noise level estimate for current band */
        nl = psSilk_VAD->NL[ k ];
        silk_assert( nl >= 0 );

        /* Add bias */
        nrg = silk_ADD_POS_SAT32( pX[ k ], psSilk_VAD->NoiseLevelBias[ k ] );
   13b06:	68b9      	ldr	r1, [r7, #8]
   13b08:	f8d9 3080 	ldr.w	r3, [r9, #128]	; 0x80
   13b0c:	185b      	adds	r3, r3, r1
        min_coef = silk_DIV32_16( silk_int16_MAX, silk_RSHIFT( psSilk_VAD->counter, 4 ) + 1 );
   13b0e:	f102 0201 	add.w	r2, r2, #1
   13b12:	f647 74ff 	movw	r4, #32767	; 0x7fff
   13b16:	fb94 f4f2 	sdiv	r4, r4, r2
        nl = psSilk_VAD->NL[ k ];
   13b1a:	f8d9 2060 	ldr.w	r2, [r9, #96]	; 0x60
        nrg = silk_ADD_POS_SAT32( pX[ k ], psSilk_VAD->NoiseLevelBias[ k ] );
   13b1e:	f100 81ff 	bmi.w	13f20 <silk_VAD_GetSA_Q8_c+0x5cc>
        /* Invert energies */
        inv_nrg = silk_DIV32( silk_int32_MAX, nrg );
        silk_assert( inv_nrg >= 0 );

        /* Less update when subband energy is high */
        if( nrg > silk_LSHIFT( nl, 3 ) ) {
   13b22:	ebb3 0fc2 	cmp.w	r3, r2, lsl #3
        inv_nrg = silk_DIV32( silk_int32_MAX, nrg );
   13b26:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
   13b2a:	fb91 f1f3 	sdiv	r1, r1, r3
        if( nrg > silk_LSHIFT( nl, 3 ) ) {
   13b2e:	f300 81fa 	bgt.w	13f26 <silk_VAD_GetSA_Q8_c+0x5d2>
            coef = VAD_NOISE_LEVEL_SMOOTH_COEF_Q16 >> 3;
        } else if( nrg < nl ) {
   13b32:	4293      	cmp	r3, r2
   13b34:	f280 8256 	bge.w	13fe4 <silk_VAD_GetSA_Q8_c+0x690>
            coef = VAD_NOISE_LEVEL_SMOOTH_COEF_Q16;
   13b38:	f44f 6380 	mov.w	r3, #1024	; 0x400

        /* Initially faster smoothing */
        coef = silk_max_int( coef, min_coef );

        /* Smooth inverse energies */
        psSilk_VAD->inv_NL[ k ] = silk_SMLAWB( psSilk_VAD->inv_NL[ k ], inv_nrg - psSilk_VAD->inv_NL[ k ], coef );
   13b3c:	f8d9 5070 	ldr.w	r5, [r9, #112]	; 0x70
        nrg = silk_ADD_POS_SAT32( pX[ k ], psSilk_VAD->NoiseLevelBias[ k ] );
   13b40:	f8d9 2084 	ldr.w	r2, [r9, #132]	; 0x84
    return (((a) > (b)) ? (a) : (b));
   13b44:	42a3      	cmp	r3, r4
   13b46:	bfb8      	it	lt
   13b48:	4623      	movlt	r3, r4
        psSilk_VAD->inv_NL[ k ] = silk_SMLAWB( psSilk_VAD->inv_NL[ k ], inv_nrg - psSilk_VAD->inv_NL[ k ], coef );
   13b4a:	1b49      	subs	r1, r1, r5
   13b4c:	b21b      	sxth	r3, r3
   13b4e:	b288      	uxth	r0, r1
   13b50:	1409      	asrs	r1, r1, #16
   13b52:	fb03 f000 	mul.w	r0, r3, r0
   13b56:	fb03 f301 	mul.w	r3, r3, r1
   13b5a:	eb03 4020 	add.w	r0, r3, r0, asr #16
   13b5e:	1943      	adds	r3, r0, r5
        /* Compute noise level by inverting again */
        nl = silk_DIV32( silk_int32_MAX, psSilk_VAD->inv_NL[ k ] );
        silk_assert( nl >= 0 );

        /* Limit noise levels (guarantee 7 bits of head room) */
        nl = silk_min( nl, 0x00FFFFFF );
   13b60:	f06f 467f 	mvn.w	r6, #4278190080	; 0xff000000
        nrg = silk_ADD_POS_SAT32( pX[ k ], psSilk_VAD->NoiseLevelBias[ k ] );
   13b64:	68f9      	ldr	r1, [r7, #12]
        psSilk_VAD->inv_NL[ k ] = silk_SMLAWB( psSilk_VAD->inv_NL[ k ], inv_nrg - psSilk_VAD->inv_NL[ k ], coef );
   13b66:	f8c9 3070 	str.w	r3, [r9, #112]	; 0x70
        nl = silk_DIV32( silk_int32_MAX, psSilk_VAD->inv_NL[ k ] );
   13b6a:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   13b6e:	fb90 f3f3 	sdiv	r3, r0, r3
        nl = silk_min( nl, 0x00FFFFFF );
   13b72:	42b3      	cmp	r3, r6
   13b74:	bfa8      	it	ge
   13b76:	4633      	movge	r3, r6
        nrg = silk_ADD_POS_SAT32( pX[ k ], psSilk_VAD->NoiseLevelBias[ k ] );
   13b78:	1852      	adds	r2, r2, r1

        /* Store as part of state */
        psSilk_VAD->NL[ k ] = nl;
   13b7a:	f8c9 3060 	str.w	r3, [r9, #96]	; 0x60
        nl = psSilk_VAD->NL[ k ];
   13b7e:	f8d9 3064 	ldr.w	r3, [r9, #100]	; 0x64
        nrg = silk_ADD_POS_SAT32( pX[ k ], psSilk_VAD->NoiseLevelBias[ k ] );
   13b82:	f100 81e0 	bmi.w	13f46 <silk_VAD_GetSA_Q8_c+0x5f2>
        inv_nrg = silk_DIV32( silk_int32_MAX, nrg );
   13b86:	fb90 f1f2 	sdiv	r1, r0, r2
        if( nrg > silk_LSHIFT( nl, 3 ) ) {
   13b8a:	ebb2 0fc3 	cmp.w	r2, r3, lsl #3
   13b8e:	f300 81e2 	bgt.w	13f56 <silk_VAD_GetSA_Q8_c+0x602>
        } else if( nrg < nl ) {
   13b92:	429a      	cmp	r2, r3
   13b94:	f280 81e3 	bge.w	13f5e <silk_VAD_GetSA_Q8_c+0x60a>
            coef = VAD_NOISE_LEVEL_SMOOTH_COEF_Q16;
   13b98:	f44f 6380 	mov.w	r3, #1024	; 0x400
        psSilk_VAD->inv_NL[ k ] = silk_SMLAWB( psSilk_VAD->inv_NL[ k ], inv_nrg - psSilk_VAD->inv_NL[ k ], coef );
   13b9c:	f8d9 5074 	ldr.w	r5, [r9, #116]	; 0x74
        nrg = silk_ADD_POS_SAT32( pX[ k ], psSilk_VAD->NoiseLevelBias[ k ] );
   13ba0:	f8d9 2088 	ldr.w	r2, [r9, #136]	; 0x88
   13ba4:	42a3      	cmp	r3, r4
   13ba6:	bfb8      	it	lt
   13ba8:	4623      	movlt	r3, r4
        psSilk_VAD->inv_NL[ k ] = silk_SMLAWB( psSilk_VAD->inv_NL[ k ], inv_nrg - psSilk_VAD->inv_NL[ k ], coef );
   13baa:	1b49      	subs	r1, r1, r5
   13bac:	b21b      	sxth	r3, r3
   13bae:	b288      	uxth	r0, r1
   13bb0:	1409      	asrs	r1, r1, #16
   13bb2:	fb03 f000 	mul.w	r0, r3, r0
   13bb6:	fb03 f301 	mul.w	r3, r3, r1
   13bba:	eb03 4020 	add.w	r0, r3, r0, asr #16
   13bbe:	1943      	adds	r3, r0, r5
        nl = silk_min( nl, 0x00FFFFFF );
   13bc0:	f06f 467f 	mvn.w	r6, #4278190080	; 0xff000000
        nrg = silk_ADD_POS_SAT32( pX[ k ], psSilk_VAD->NoiseLevelBias[ k ] );
   13bc4:	6939      	ldr	r1, [r7, #16]
        psSilk_VAD->inv_NL[ k ] = silk_SMLAWB( psSilk_VAD->inv_NL[ k ], inv_nrg - psSilk_VAD->inv_NL[ k ], coef );
   13bc6:	f8c9 3074 	str.w	r3, [r9, #116]	; 0x74
        nl = silk_DIV32( silk_int32_MAX, psSilk_VAD->inv_NL[ k ] );
   13bca:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   13bce:	fb90 f3f3 	sdiv	r3, r0, r3
        nl = silk_min( nl, 0x00FFFFFF );
   13bd2:	42b3      	cmp	r3, r6
   13bd4:	bfa8      	it	ge
   13bd6:	4633      	movge	r3, r6
        nrg = silk_ADD_POS_SAT32( pX[ k ], psSilk_VAD->NoiseLevelBias[ k ] );
   13bd8:	1852      	adds	r2, r2, r1
        psSilk_VAD->NL[ k ] = nl;
   13bda:	f8c9 3064 	str.w	r3, [r9, #100]	; 0x64
        nl = psSilk_VAD->NL[ k ];
   13bde:	f8d9 3068 	ldr.w	r3, [r9, #104]	; 0x68
        nrg = silk_ADD_POS_SAT32( pX[ k ], psSilk_VAD->NoiseLevelBias[ k ] );
   13be2:	f100 81b3 	bmi.w	13f4c <silk_VAD_GetSA_Q8_c+0x5f8>
        inv_nrg = silk_DIV32( silk_int32_MAX, nrg );
   13be6:	fb90 f1f2 	sdiv	r1, r0, r2
        if( nrg > silk_LSHIFT( nl, 3 ) ) {
   13bea:	ebb2 0fc3 	cmp.w	r2, r3, lsl #3
   13bee:	f300 81b0 	bgt.w	13f52 <silk_VAD_GetSA_Q8_c+0x5fe>
        } else if( nrg < nl ) {
   13bf2:	429a      	cmp	r2, r3
   13bf4:	f280 81db 	bge.w	13fae <silk_VAD_GetSA_Q8_c+0x65a>
            coef = VAD_NOISE_LEVEL_SMOOTH_COEF_Q16;
   13bf8:	f44f 6380 	mov.w	r3, #1024	; 0x400
        psSilk_VAD->inv_NL[ k ] = silk_SMLAWB( psSilk_VAD->inv_NL[ k ], inv_nrg - psSilk_VAD->inv_NL[ k ], coef );
   13bfc:	f8d9 5078 	ldr.w	r5, [r9, #120]	; 0x78
        nrg = silk_ADD_POS_SAT32( pX[ k ], psSilk_VAD->NoiseLevelBias[ k ] );
   13c00:	697a      	ldr	r2, [r7, #20]
   13c02:	42a3      	cmp	r3, r4
   13c04:	bfb8      	it	lt
   13c06:	4623      	movlt	r3, r4
        psSilk_VAD->inv_NL[ k ] = silk_SMLAWB( psSilk_VAD->inv_NL[ k ], inv_nrg - psSilk_VAD->inv_NL[ k ], coef );
   13c08:	1b49      	subs	r1, r1, r5
   13c0a:	b21b      	sxth	r3, r3
   13c0c:	b288      	uxth	r0, r1
   13c0e:	1409      	asrs	r1, r1, #16
   13c10:	fb03 f000 	mul.w	r0, r3, r0
   13c14:	fb03 f301 	mul.w	r3, r3, r1
   13c18:	eb03 4120 	add.w	r1, r3, r0, asr #16
   13c1c:	194b      	adds	r3, r1, r5
        nl = silk_min( nl, 0x00FFFFFF );
   13c1e:	f06f 467f 	mvn.w	r6, #4278190080	; 0xff000000
        nrg = silk_ADD_POS_SAT32( pX[ k ], psSilk_VAD->NoiseLevelBias[ k ] );
   13c22:	f8d9 008c 	ldr.w	r0, [r9, #140]	; 0x8c
        psSilk_VAD->inv_NL[ k ] = silk_SMLAWB( psSilk_VAD->inv_NL[ k ], inv_nrg - psSilk_VAD->inv_NL[ k ], coef );
   13c26:	f8c9 3078 	str.w	r3, [r9, #120]	; 0x78
        nl = silk_DIV32( silk_int32_MAX, psSilk_VAD->inv_NL[ k ] );
   13c2a:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
   13c2e:	fb91 f3f3 	sdiv	r3, r1, r3
        nl = silk_min( nl, 0x00FFFFFF );
   13c32:	42b3      	cmp	r3, r6
   13c34:	bfa8      	it	ge
   13c36:	4633      	movge	r3, r6
        nrg = silk_ADD_POS_SAT32( pX[ k ], psSilk_VAD->NoiseLevelBias[ k ] );
   13c38:	1810      	adds	r0, r2, r0
        psSilk_VAD->NL[ k ] = nl;
   13c3a:	f8c9 3068 	str.w	r3, [r9, #104]	; 0x68
        nl = psSilk_VAD->NL[ k ];
   13c3e:	f8d9 306c 	ldr.w	r3, [r9, #108]	; 0x6c
        nrg = silk_ADD_POS_SAT32( pX[ k ], psSilk_VAD->NoiseLevelBias[ k ] );
   13c42:	f100 817a 	bmi.w	13f3a <silk_VAD_GetSA_Q8_c+0x5e6>
        inv_nrg = silk_DIV32( silk_int32_MAX, nrg );
   13c46:	fb91 f2f0 	sdiv	r2, r1, r0
        if( nrg > silk_LSHIFT( nl, 3 ) ) {
   13c4a:	ebb0 0fc3 	cmp.w	r0, r3, lsl #3
   13c4e:	f300 8184 	bgt.w	13f5a <silk_VAD_GetSA_Q8_c+0x606>
        } else if( nrg < nl ) {
   13c52:	4283      	cmp	r3, r0
   13c54:	f340 8197 	ble.w	13f86 <silk_VAD_GetSA_Q8_c+0x632>
            coef = VAD_NOISE_LEVEL_SMOOTH_COEF_Q16;
   13c58:	f44f 6380 	mov.w	r3, #1024	; 0x400
        psSilk_VAD->inv_NL[ k ] = silk_SMLAWB( psSilk_VAD->inv_NL[ k ], inv_nrg - psSilk_VAD->inv_NL[ k ], coef );
   13c5c:	f8d9 007c 	ldr.w	r0, [r9, #124]	; 0x7c
            input_tilt = silk_SMLAWB( input_tilt, tiltWeights[ b ], SNR_Q7 );
   13c60:	49dd      	ldr	r1, [pc, #884]	; (13fd8 <silk_VAD_GetSA_Q8_c+0x684>)
   13c62:	42a3      	cmp	r3, r4
   13c64:	bfb8      	it	lt
   13c66:	4623      	movlt	r3, r4
        psSilk_VAD->inv_NL[ k ] = silk_SMLAWB( psSilk_VAD->inv_NL[ k ], inv_nrg - psSilk_VAD->inv_NL[ k ], coef );
   13c68:	1a12      	subs	r2, r2, r0
   13c6a:	b21b      	sxth	r3, r3
   13c6c:	b294      	uxth	r4, r2
   13c6e:	1412      	asrs	r2, r2, #16
   13c70:	fb03 f404 	mul.w	r4, r3, r4
   13c74:	fb03 f302 	mul.w	r3, r3, r2
   13c78:	eb03 4324 	add.w	r3, r3, r4, asr #16
        nl = silk_min( nl, 0x00FFFFFF );
   13c7c:	f06f 447f 	mvn.w	r4, #4278190080	; 0xff000000
        psSilk_VAD->inv_NL[ k ] = silk_SMLAWB( psSilk_VAD->inv_NL[ k ], inv_nrg - psSilk_VAD->inv_NL[ k ], coef );
   13c80:	4403      	add	r3, r0
        nl = silk_DIV32( silk_int32_MAX, psSilk_VAD->inv_NL[ k ] );
   13c82:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
   13c86:	fb92 f2f3 	sdiv	r2, r2, r3
        nl = silk_min( nl, 0x00FFFFFF );
   13c8a:	42a2      	cmp	r2, r4
    sumSquared = 0;
   13c8c:	f04f 0500 	mov.w	r5, #0
        nl = silk_min( nl, 0x00FFFFFF );
   13c90:	bfa8      	it	ge
   13c92:	4622      	movge	r2, r4
        psSilk_VAD->inv_NL[ k ] = silk_SMLAWB( psSilk_VAD->inv_NL[ k ], inv_nrg - psSilk_VAD->inv_NL[ k ], coef );
   13c94:	f8c9 307c 	str.w	r3, [r9, #124]	; 0x7c
        psSilk_VAD->NL[ k ] = nl;
   13c98:	f8c9 206c 	str.w	r2, [r9, #108]	; 0x6c
    for( b = 0; b < VAD_N_BANDS; b++ ) {
   13c9c:	462e      	mov	r6, r5
    input_tilt = 0;
   13c9e:	46ab      	mov	fp, r5
   13ca0:	f109 0a60 	add.w	sl, r9, #96	; 0x60
   13ca4:	f107 0818 	add.w	r8, r7, #24
        speech_nrg = Xnrg[ b ] - psSilk_VAD->NL[ b ];
   13ca8:	f107 0308 	add.w	r3, r7, #8
   13cac:	f85a 2b04 	ldr.w	r2, [sl], #4
   13cb0:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
   13cb4:	1a9c      	subs	r4, r3, r2
        if( speech_nrg > 0 ) {
   13cb6:	2c00      	cmp	r4, #0
   13cb8:	f340 8137 	ble.w	13f2a <silk_VAD_GetSA_Q8_c+0x5d6>
            if( ( Xnrg[ b ] & 0xFF800000 ) == 0 ) {
   13cbc:	48c7      	ldr	r0, [pc, #796]	; (13fdc <silk_VAD_GetSA_Q8_c+0x688>)
   13cbe:	6079      	str	r1, [r7, #4]
   13cc0:	4203      	tst	r3, r0
                NrgToNoiseRatio_Q8[ b ] = silk_DIV32( Xnrg[ b ], silk_RSHIFT( psSilk_VAD->NL[ b ], 8 ) + 1 );
   13cc2:	bf14      	ite	ne
   13cc4:	1212      	asrne	r2, r2, #8
                NrgToNoiseRatio_Q8[ b ] = silk_DIV32( silk_LSHIFT( Xnrg[ b ], 8 ), psSilk_VAD->NL[ b ] + 1 );
   13cc6:	021b      	lsleq	r3, r3, #8
                NrgToNoiseRatio_Q8[ b ] = silk_DIV32( Xnrg[ b ], silk_RSHIFT( psSilk_VAD->NL[ b ], 8 ) + 1 );
   13cc8:	3201      	adds	r2, #1
   13cca:	fb93 f3f2 	sdiv	r3, r3, r2
            SNR_Q7 = silk_lin2log( NrgToNoiseRatio_Q8[ b ] ) - 8 * 128;
   13cce:	4618      	mov	r0, r3
   13cd0:	f848 3026 	str.w	r3, [r8, r6, lsl #2]
   13cd4:	f003 fe70 	bl	179b8 <silk_lin2log>
            if( speech_nrg < ( (opus_int32)1 << 20 ) ) {
   13cd8:	4bc1      	ldr	r3, [pc, #772]	; (13fe0 <silk_VAD_GetSA_Q8_c+0x68c>)
   13cda:	6879      	ldr	r1, [r7, #4]
            SNR_Q7 = silk_lin2log( NrgToNoiseRatio_Q8[ b ] ) - 8 * 128;
   13cdc:	f5a0 6080 	sub.w	r0, r0, #1024	; 0x400
            sumSquared = silk_SMLABB( sumSquared, SNR_Q7, SNR_Q7 );          /* Q14 */
   13ce0:	b200      	sxth	r0, r0
            if( speech_nrg < ( (opus_int32)1 << 20 ) ) {
   13ce2:	429c      	cmp	r4, r3
            sumSquared = silk_SMLABB( sumSquared, SNR_Q7, SNR_Q7 );          /* Q14 */
   13ce4:	fb00 5500 	mla	r5, r0, r0, r5
            if( speech_nrg < ( (opus_int32)1 << 20 ) ) {
   13ce8:	dc23      	bgt.n	13d32 <silk_VAD_GetSA_Q8_c+0x3de>
   13cea:	fab4 f384 	clz	r3, r4
    * frac_Q7 = silk_ROR32(in, 24 - lzeros) & 0x7f;
   13cee:	f1c3 0218 	rsb	r2, r3, #24
    if( rot == 0 ) {
   13cf2:	2a00      	cmp	r2, #0
   13cf4:	d002      	beq.n	13cfc <silk_VAD_GetSA_Q8_c+0x3a8>
        return (opus_int32) ((x << m) | (x >> (32 - m)));
   13cf6:	bfb8      	it	lt
   13cf8:	3220      	addlt	r2, #32
        return (opus_int32) ((x << (32 - r)) | (x >> r));
   13cfa:	41d4      	rors	r4, r2
   13cfc:	f004 047f 	and.w	r4, r4, #127	; 0x7f
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   13d00:	eb04 0cc4 	add.w	ip, r4, r4, lsl #3
        y = 32768;
   13d04:	f013 0f01 	tst.w	r3, #1
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   13d08:	ebc4 04cc 	rsb	r4, r4, ip, lsl #3
        y = 32768;
   13d0c:	f24b 4286 	movw	r2, #46214	; 0xb486
    y >>= silk_RSHIFT(lz, 1);
   13d10:	ea4f 0363 	mov.w	r3, r3, asr #1
        y = 32768;
   13d14:	bf18      	it	ne
   13d16:	f44f 4200 	movne.w	r2, #32768	; 0x8000
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   13d1a:	ebc4 0484 	rsb	r4, r4, r4, lsl #2
    y >>= silk_RSHIFT(lz, 1);
   13d1e:	411a      	asrs	r2, r3
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   13d20:	b2a3      	uxth	r3, r4
   13d22:	fb02 f303 	mul.w	r3, r2, r3
   13d26:	eb02 4323 	add.w	r3, r2, r3, asr #16
                SNR_Q7 = silk_SMULWB( silk_LSHIFT( silk_SQRT_APPROX( speech_nrg ), 6 ), SNR_Q7 );
   13d2a:	019b      	lsls	r3, r3, #6
   13d2c:	fb00 f003 	mul.w	r0, r0, r3
   13d30:	1400      	asrs	r0, r0, #16
            input_tilt = silk_SMLAWB( input_tilt, tiltWeights[ b ], SNR_Q7 );
   13d32:	f851 3026 	ldr.w	r3, [r1, r6, lsl #2]
   13d36:	b29a      	uxth	r2, r3
   13d38:	141b      	asrs	r3, r3, #16
   13d3a:	fb00 f202 	mul.w	r2, r0, r2
   13d3e:	fb00 f003 	mul.w	r0, r0, r3
   13d42:	eb00 4022 	add.w	r0, r0, r2, asr #16
   13d46:	4483      	add	fp, r0
    for( b = 0; b < VAD_N_BANDS; b++ ) {
   13d48:	3601      	adds	r6, #1
   13d4a:	2e04      	cmp	r6, #4
   13d4c:	d1ac      	bne.n	13ca8 <silk_VAD_GetSA_Q8_c+0x354>
    sumSquared = silk_DIV32_16( sumSquared, VAD_N_BANDS ); /* Q14 */
   13d4e:	1e2b      	subs	r3, r5, #0
   13d50:	bfb8      	it	lt
   13d52:	3303      	addlt	r3, #3
   13d54:	109b      	asrs	r3, r3, #2
    if( x <= 0 ) {
   13d56:	2b00      	cmp	r3, #0
   13d58:	f340 80ec 	ble.w	13f34 <silk_VAD_GetSA_Q8_c+0x5e0>
   13d5c:	fab3 f083 	clz	r0, r3
    * frac_Q7 = silk_ROR32(in, 24 - lzeros) & 0x7f;
   13d60:	f1c0 0118 	rsb	r1, r0, #24
    if( rot == 0 ) {
   13d64:	2900      	cmp	r1, #0
   13d66:	d002      	beq.n	13d6e <silk_VAD_GetSA_Q8_c+0x41a>
        return (opus_int32) ((x << m) | (x >> (32 - m)));
   13d68:	bfb8      	it	lt
   13d6a:	3120      	addlt	r1, #32
        return (opus_int32) ((x << (32 - r)) | (x >> r));
   13d6c:	41cb      	rors	r3, r1
   13d6e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   13d72:	eb03 04c3 	add.w	r4, r3, r3, lsl #3
        y = 32768;
   13d76:	f010 0f01 	tst.w	r0, #1
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   13d7a:	ebc3 03c4 	rsb	r3, r3, r4, lsl #3
        y = 32768;
   13d7e:	f24b 4186 	movw	r1, #46214	; 0xb486
    y >>= silk_RSHIFT(lz, 1);
   13d82:	ea4f 0060 	mov.w	r0, r0, asr #1
        y = 32768;
   13d86:	bf18      	it	ne
   13d88:	f44f 4100 	movne.w	r1, #32768	; 0x8000
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   13d8c:	ebc3 0383 	rsb	r3, r3, r3, lsl #2
    y >>= silk_RSHIFT(lz, 1);
   13d90:	4101      	asrs	r1, r0
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   13d92:	b29b      	uxth	r3, r3
   13d94:	fb01 f303 	mul.w	r3, r1, r3
   13d98:	eb01 4323 	add.w	r3, r1, r3, asr #16
   13d9c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   13da0:	b21b      	sxth	r3, r3
   13da2:	f64a 70c8 	movw	r0, #45000	; 0xafc8
   13da6:	fb00 f003 	mul.w	r0, r0, r3
   13daa:	1400      	asrs	r0, r0, #16
   13dac:	3880      	subs	r0, #128	; 0x80
    SA_Q15 = silk_sigm_Q15( silk_SMULWB( VAD_SNR_FACTOR_Q16, pSNR_dB_Q7 ) - VAD_NEGATIVE_OFFSET_Q5 );
   13dae:	f005 ff5d 	bl	19c6c <silk_sigm_Q15>
   13db2:	4682      	mov	sl, r0
    psEncC->input_tilt_Q15 = silk_LSHIFT( silk_sigm_Q15( input_tilt ) - 16384, 1 );
   13db4:	4658      	mov	r0, fp
   13db6:	f005 ff59 	bl	19c6c <silk_sigm_Q15>
        speech_nrg += ( b + 1 ) * silk_RSHIFT( Xnrg[ b ] - psSilk_VAD->NL[ b ], 4 );
   13dba:	f8d9 2060 	ldr.w	r2, [r9, #96]	; 0x60
   13dbe:	68fe      	ldr	r6, [r7, #12]
   13dc0:	f8d9 1064 	ldr.w	r1, [r9, #100]	; 0x64
   13dc4:	68bd      	ldr	r5, [r7, #8]
   13dc6:	693c      	ldr	r4, [r7, #16]
   13dc8:	f8d9 3068 	ldr.w	r3, [r9, #104]	; 0x68
   13dcc:	eba5 0c02 	sub.w	ip, r5, r2
   13dd0:	1a71      	subs	r1, r6, r1
    if( psEncC->frame_length == 20 * psEncC->fs_kHz ) {
   13dd2:	f509 528f 	add.w	r2, r9, #4576	; 0x11e0
        speech_nrg += ( b + 1 ) * silk_RSHIFT( Xnrg[ b ] - psSilk_VAD->NL[ b ], 4 );
   13dd6:	1109      	asrs	r1, r1, #4
   13dd8:	ea4f 1c2c 	mov.w	ip, ip, asr #4
   13ddc:	1ae3      	subs	r3, r4, r3
   13dde:	f8d9 506c 	ldr.w	r5, [r9, #108]	; 0x6c
    if( psEncC->frame_length == 20 * psEncC->fs_kHz ) {
   13de2:	6814      	ldr	r4, [r2, #0]
        speech_nrg += ( b + 1 ) * silk_RSHIFT( Xnrg[ b ] - psSilk_VAD->NL[ b ], 4 );
   13de4:	697e      	ldr	r6, [r7, #20]
    psEncC->input_tilt_Q15 = silk_LSHIFT( silk_sigm_Q15( input_tilt ) - 16384, 1 );
   13de6:	f5a0 4280 	sub.w	r2, r0, #16384	; 0x4000
        speech_nrg += ( b + 1 ) * silk_RSHIFT( Xnrg[ b ] - psSilk_VAD->NL[ b ], 4 );
   13dea:	eb0c 0c41 	add.w	ip, ip, r1, lsl #1
    psEncC->input_tilt_Q15 = silk_LSHIFT( silk_sigm_Q15( input_tilt ) - 16384, 1 );
   13dee:	f241 2e68 	movw	lr, #4712	; 0x1268
    if( psEncC->frame_length == 20 * psEncC->fs_kHz ) {
   13df2:	f241 11e8 	movw	r1, #4584	; 0x11e8
    psEncC->input_tilt_Q15 = silk_LSHIFT( silk_sigm_Q15( input_tilt ) - 16384, 1 );
   13df6:	0052      	lsls	r2, r2, #1
        speech_nrg += ( b + 1 ) * silk_RSHIFT( Xnrg[ b ] - psSilk_VAD->NL[ b ], 4 );
   13df8:	111b      	asrs	r3, r3, #4
   13dfa:	1b75      	subs	r5, r6, r5
    if( psEncC->frame_length == 20 * psEncC->fs_kHz ) {
   13dfc:	f859 1001 	ldr.w	r1, [r9, r1]
    psEncC->input_tilt_Q15 = silk_LSHIFT( silk_sigm_Q15( input_tilt ) - 16384, 1 );
   13e00:	f849 200e 	str.w	r2, [r9, lr]
        speech_nrg += ( b + 1 ) * silk_RSHIFT( Xnrg[ b ] - psSilk_VAD->NL[ b ], 4 );
   13e04:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    if( psEncC->frame_length == 20 * psEncC->fs_kHz ) {
   13e08:	00a2      	lsls	r2, r4, #2
        speech_nrg += ( b + 1 ) * silk_RSHIFT( Xnrg[ b ] - psSilk_VAD->NL[ b ], 4 );
   13e0a:	1128      	asrs	r0, r5, #4
   13e0c:	4463      	add	r3, ip
    if( psEncC->frame_length == 20 * psEncC->fs_kHz ) {
   13e0e:	1915      	adds	r5, r2, r4
        speech_nrg += ( b + 1 ) * silk_RSHIFT( Xnrg[ b ] - psSilk_VAD->NL[ b ], 4 );
   13e10:	eb03 0380 	add.w	r3, r3, r0, lsl #2
    if( psEncC->frame_length == 20 * psEncC->fs_kHz ) {
   13e14:	ebb1 0f85 	cmp.w	r1, r5, lsl #2
        speech_nrg = silk_RSHIFT32( speech_nrg, 1 );
   13e18:	bf08      	it	eq
   13e1a:	105b      	asreq	r3, r3, #1
    if( speech_nrg <= 0 ) {
   13e1c:	2b00      	cmp	r3, #0
   13e1e:	f340 808f 	ble.w	13f40 <silk_VAD_GetSA_Q8_c+0x5ec>
    } else if( speech_nrg < 16384 ) {
   13e22:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
   13e26:	da24      	bge.n	13e72 <silk_VAD_GetSA_Q8_c+0x51e>
        speech_nrg = silk_LSHIFT32( speech_nrg, 16 );
   13e28:	041b      	lsls	r3, r3, #16
   13e2a:	fab3 f583 	clz	r5, r3
    * frac_Q7 = silk_ROR32(in, 24 - lzeros) & 0x7f;
   13e2e:	f1c5 0018 	rsb	r0, r5, #24
   13e32:	41c3      	rors	r3, r0
   13e34:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   13e38:	eb03 06c3 	add.w	r6, r3, r3, lsl #3
        y = 32768;
   13e3c:	f015 0f01 	tst.w	r5, #1
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   13e40:	ebc3 03c6 	rsb	r3, r3, r6, lsl #3
        y = 32768;
   13e44:	f24b 4086 	movw	r0, #46214	; 0xb486
    y >>= silk_RSHIFT(lz, 1);
   13e48:	ea4f 0565 	mov.w	r5, r5, asr #1
        y = 32768;
   13e4c:	bf18      	it	ne
   13e4e:	f44f 4000 	movne.w	r0, #32768	; 0x8000
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   13e52:	ebc3 0383 	rsb	r3, r3, r3, lsl #2
    y >>= silk_RSHIFT(lz, 1);
   13e56:	4128      	asrs	r0, r5
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   13e58:	b29b      	uxth	r3, r3
   13e5a:	fb00 f303 	mul.w	r3, r0, r3
   13e5e:	eb00 4323 	add.w	r3, r0, r3, asr #16
        SA_Q15 = silk_SMULWB( 32768 + speech_nrg, SA_Q15 );
   13e62:	fa0f fa8a 	sxth.w	sl, sl
   13e66:	f503 4300 	add.w	r3, r3, #32768	; 0x8000
   13e6a:	fb0a f303 	mul.w	r3, sl, r3
   13e6e:	ea4f 4a23 	mov.w	sl, r3, asr #16
    smooth_coef_Q16 = silk_SMULWB( VAD_SNR_SMOOTH_COEF_Q18, silk_SMULWB( (opus_int32)SA_Q15, SA_Q15 ) );
   13e72:	fa1f f58a 	uxth.w	r5, sl
   13e76:	fa0f f38a 	sxth.w	r3, sl
   13e7a:	fb03 f305 	mul.w	r3, r3, r5
   13e7e:	fb1a f52a 	smultb	r5, sl, sl
   13e82:	eb05 4523 	add.w	r5, r5, r3, asr #16
    psEncC->speech_activity_Q8 = silk_min_int( silk_RSHIFT( SA_Q15, 7 ), silk_uint8_MAX );
   13e86:	ea4f 13ea 	mov.w	r3, sl, asr #7
    if( psEncC->frame_length == 10 * psEncC->fs_kHz ) {
   13e8a:	4422      	add	r2, r4
    return (((a) < (b)) ? (a) : (b));
   13e8c:	2bff      	cmp	r3, #255	; 0xff
    psEncC->speech_activity_Q8 = silk_min_int( silk_RSHIFT( SA_Q15, 7 ), silk_uint8_MAX );
   13e8e:	f241 10b4 	movw	r0, #4532	; 0x11b4
    smooth_coef_Q16 = silk_SMULWB( VAD_SNR_SMOOTH_COEF_Q18, silk_SMULWB( (opus_int32)SA_Q15, SA_Q15 ) );
   13e92:	b22d      	sxth	r5, r5
   13e94:	bfa8      	it	ge
   13e96:	23ff      	movge	r3, #255	; 0xff
   13e98:	032d      	lsls	r5, r5, #12
    if( psEncC->frame_length == 10 * psEncC->fs_kHz ) {
   13e9a:	ebb1 0f42 	cmp.w	r1, r2, lsl #1
   13e9e:	f509 5692 	add.w	r6, r9, #4672	; 0x1240
   13ea2:	f509 5493 	add.w	r4, r9, #4704	; 0x1260
    psEncC->speech_activity_Q8 = silk_min_int( silk_RSHIFT( SA_Q15, 7 ), silk_uint8_MAX );
   13ea6:	f849 3000 	str.w	r3, [r9, r0]
    smooth_coef_Q16 = silk_SMULWB( VAD_SNR_SMOOTH_COEF_Q18, silk_SMULWB( (opus_int32)SA_Q15, SA_Q15 ) );
   13eaa:	bf14      	ite	ne
   13eac:	142d      	asrne	r5, r5, #16
        smooth_coef_Q16 >>= 1;
   13eae:	146d      	asreq	r5, r5, #17
   13eb0:	3618      	adds	r6, #24
   13eb2:	3408      	adds	r4, #8
   13eb4:	f109 0948 	add.w	r9, r9, #72	; 0x48
        psSilk_VAD->NrgRatioSmth_Q8[ b ] = silk_SMLAWB( psSilk_VAD->NrgRatioSmth_Q8[ b ],
   13eb8:	f859 1f04 	ldr.w	r1, [r9, #4]!
   13ebc:	f858 3b04 	ldr.w	r3, [r8], #4
   13ec0:	1a5b      	subs	r3, r3, r1
   13ec2:	b29a      	uxth	r2, r3
   13ec4:	1418      	asrs	r0, r3, #16
   13ec6:	fb05 f000 	mul.w	r0, r5, r0
   13eca:	fb05 f302 	mul.w	r3, r5, r2
   13ece:	eb00 4023 	add.w	r0, r0, r3, asr #16
   13ed2:	4408      	add	r0, r1
   13ed4:	f8c9 0000 	str.w	r0, [r9]
        SNR_Q7 = 3 * ( silk_lin2log( psSilk_VAD->NrgRatioSmth_Q8[b] ) - 8 * 128 );
   13ed8:	f003 fd6e 	bl	179b8 <silk_lin2log>
   13edc:	eb00 0040 	add.w	r0, r0, r0, lsl #1
        psEncC->input_quality_bands_Q15[ b ] = silk_sigm_Q15( silk_RSHIFT( SNR_Q7 - 16 * 128, 4 ) );
   13ee0:	f5a0 50a0 	sub.w	r0, r0, #5120	; 0x1400
   13ee4:	1100      	asrs	r0, r0, #4
   13ee6:	f005 fec1 	bl	19c6c <silk_sigm_Q15>
   13eea:	f846 0b04 	str.w	r0, [r6], #4
    for( b = 0; b < VAD_N_BANDS; b++ ) {
   13eee:	42b4      	cmp	r4, r6
   13ef0:	d1e2      	bne.n	13eb8 <silk_VAD_GetSA_Q8_c+0x564>
}
   13ef2:	2000      	movs	r0, #0
   13ef4:	373c      	adds	r7, #60	; 0x3c
   13ef6:	46bd      	mov	sp, r7
   13ef8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                Xnrg[ b ] = silk_ADD_POS_SAT32( Xnrg[ b ], sumSquared );
   13efc:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
   13f00:	f848 3c04 	str.w	r3, [r8, #-4]
            dec_subframe_offset += dec_subframe_length;
   13f04:	44b4      	add	ip, r6
   13f06:	f10e 3eff 	add.w	lr, lr, #4294967295	; 0xffffffff
                Xnrg[ b ] = silk_ADD_POS_SAT32( Xnrg[ b ], sumSquared );
   13f0a:	461c      	mov	r4, r3
   13f0c:	e5bc      	b.n	13a88 <silk_VAD_GetSA_Q8_c+0x134>
        nrg = silk_ADD_POS_SAT32( pX[ k ], psSilk_VAD->NoiseLevelBias[ k ] );
   13f0e:	f8d9 3080 	ldr.w	r3, [r9, #128]	; 0x80
   13f12:	68b9      	ldr	r1, [r7, #8]
        nl = psSilk_VAD->NL[ k ];
   13f14:	f8d9 2060 	ldr.w	r2, [r9, #96]	; 0x60
        nrg = silk_ADD_POS_SAT32( pX[ k ], psSilk_VAD->NoiseLevelBias[ k ] );
   13f18:	185b      	adds	r3, r3, r1
        min_coef = 0;
   13f1a:	4654      	mov	r4, sl
        nrg = silk_ADD_POS_SAT32( pX[ k ], psSilk_VAD->NoiseLevelBias[ k ] );
   13f1c:	f57f ae01 	bpl.w	13b22 <silk_VAD_GetSA_Q8_c+0x1ce>
        inv_nrg = silk_DIV32( silk_int32_MAX, nrg );
   13f20:	2101      	movs	r1, #1
            coef = VAD_NOISE_LEVEL_SMOOTH_COEF_Q16 >> 3;
   13f22:	2380      	movs	r3, #128	; 0x80
   13f24:	e60a      	b.n	13b3c <silk_VAD_GetSA_Q8_c+0x1e8>
   13f26:	2380      	movs	r3, #128	; 0x80
   13f28:	e608      	b.n	13b3c <silk_VAD_GetSA_Q8_c+0x1e8>
            NrgToNoiseRatio_Q8[ b ] = 256;
   13f2a:	f44f 7380 	mov.w	r3, #256	; 0x100
   13f2e:	f848 3026 	str.w	r3, [r8, r6, lsl #2]
   13f32:	e709      	b.n	13d48 <silk_VAD_GetSA_Q8_c+0x3f4>
    if( x <= 0 ) {
   13f34:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   13f38:	e739      	b.n	13dae <silk_VAD_GetSA_Q8_c+0x45a>
        inv_nrg = silk_DIV32( silk_int32_MAX, nrg );
   13f3a:	2201      	movs	r2, #1
            coef = VAD_NOISE_LEVEL_SMOOTH_COEF_Q16 >> 3;
   13f3c:	2380      	movs	r3, #128	; 0x80
   13f3e:	e68d      	b.n	13c5c <silk_VAD_GetSA_Q8_c+0x308>
        SA_Q15 = silk_RSHIFT( SA_Q15, 1 );
   13f40:	ea4f 0a6a 	mov.w	sl, sl, asr #1
   13f44:	e795      	b.n	13e72 <silk_VAD_GetSA_Q8_c+0x51e>
        inv_nrg = silk_DIV32( silk_int32_MAX, nrg );
   13f46:	2101      	movs	r1, #1
            coef = VAD_NOISE_LEVEL_SMOOTH_COEF_Q16 >> 3;
   13f48:	2380      	movs	r3, #128	; 0x80
   13f4a:	e627      	b.n	13b9c <silk_VAD_GetSA_Q8_c+0x248>
        inv_nrg = silk_DIV32( silk_int32_MAX, nrg );
   13f4c:	2101      	movs	r1, #1
            coef = VAD_NOISE_LEVEL_SMOOTH_COEF_Q16 >> 3;
   13f4e:	2380      	movs	r3, #128	; 0x80
   13f50:	e654      	b.n	13bfc <silk_VAD_GetSA_Q8_c+0x2a8>
   13f52:	2380      	movs	r3, #128	; 0x80
   13f54:	e652      	b.n	13bfc <silk_VAD_GetSA_Q8_c+0x2a8>
   13f56:	2380      	movs	r3, #128	; 0x80
   13f58:	e620      	b.n	13b9c <silk_VAD_GetSA_Q8_c+0x248>
   13f5a:	2380      	movs	r3, #128	; 0x80
   13f5c:	e67e      	b.n	13c5c <silk_VAD_GetSA_Q8_c+0x308>
            coef = silk_SMULWB( silk_SMULWW( inv_nrg, nl ), VAD_NOISE_LEVEL_SMOOTH_COEF_Q16 << 1 );
   13f5e:	b218      	sxth	r0, r3
   13f60:	13da      	asrs	r2, r3, #15
   13f62:	b28d      	uxth	r5, r1
   13f64:	140b      	asrs	r3, r1, #16
   13f66:	3201      	adds	r2, #1
   13f68:	fb00 f505 	mul.w	r5, r0, r5
   13f6c:	fb00 f303 	mul.w	r3, r0, r3
   13f70:	eb03 4325 	add.w	r3, r3, r5, asr #16
   13f74:	1052      	asrs	r2, r2, #1
   13f76:	fb01 3202 	mla	r2, r1, r2, r3
   13f7a:	f3c2 134a 	ubfx	r3, r2, #5, #11
   13f7e:	1412      	asrs	r2, r2, #16
   13f80:	eb03 23c2 	add.w	r3, r3, r2, lsl #11
   13f84:	e60a      	b.n	13b9c <silk_VAD_GetSA_Q8_c+0x248>
   13f86:	b218      	sxth	r0, r3
   13f88:	13d9      	asrs	r1, r3, #15
   13f8a:	b295      	uxth	r5, r2
   13f8c:	1413      	asrs	r3, r2, #16
   13f8e:	3101      	adds	r1, #1
   13f90:	fb00 f505 	mul.w	r5, r0, r5
   13f94:	fb00 f303 	mul.w	r3, r0, r3
   13f98:	eb03 4325 	add.w	r3, r3, r5, asr #16
   13f9c:	1049      	asrs	r1, r1, #1
   13f9e:	fb02 3101 	mla	r1, r2, r1, r3
   13fa2:	f3c1 134a 	ubfx	r3, r1, #5, #11
   13fa6:	1409      	asrs	r1, r1, #16
   13fa8:	eb03 23c1 	add.w	r3, r3, r1, lsl #11
   13fac:	e656      	b.n	13c5c <silk_VAD_GetSA_Q8_c+0x308>
   13fae:	b218      	sxth	r0, r3
   13fb0:	13da      	asrs	r2, r3, #15
   13fb2:	b28d      	uxth	r5, r1
   13fb4:	140b      	asrs	r3, r1, #16
   13fb6:	3201      	adds	r2, #1
   13fb8:	fb00 f505 	mul.w	r5, r0, r5
   13fbc:	fb00 f303 	mul.w	r3, r0, r3
   13fc0:	eb03 4325 	add.w	r3, r3, r5, asr #16
   13fc4:	1052      	asrs	r2, r2, #1
   13fc6:	fb01 3202 	mla	r2, r1, r2, r3
   13fca:	f3c2 134a 	ubfx	r3, r2, #5, #11
   13fce:	1412      	asrs	r2, r2, #16
   13fd0:	eb03 23c2 	add.w	r3, r3, r2, lsl #11
   13fd4:	e612      	b.n	13bfc <silk_VAD_GetSA_Q8_c+0x2a8>
   13fd6:	bf00      	nop
   13fd8:	000371fc 	.word	0x000371fc
   13fdc:	ff800000 	.word	0xff800000
   13fe0:	000fffff 	.word	0x000fffff
   13fe4:	b213      	sxth	r3, r2
   13fe6:	b288      	uxth	r0, r1
   13fe8:	13d2      	asrs	r2, r2, #15
   13fea:	140d      	asrs	r5, r1, #16
   13fec:	fb03 f000 	mul.w	r0, r3, r0
   13ff0:	3201      	adds	r2, #1
   13ff2:	fb03 f305 	mul.w	r3, r3, r5
   13ff6:	eb03 4320 	add.w	r3, r3, r0, asr #16
   13ffa:	1052      	asrs	r2, r2, #1
   13ffc:	fb01 3202 	mla	r2, r1, r2, r3
   14000:	f3c2 134a 	ubfx	r3, r2, #5, #11
   14004:	1412      	asrs	r2, r2, #16
   14006:	eb03 23c2 	add.w	r3, r3, r2, lsl #11
   1400a:	e597      	b.n	13b3c <silk_VAD_GetSA_Q8_c+0x1e8>

0001400c <silk_control_audio_bandwidth>:
{
    opus_int   fs_kHz;
    opus_int   orig_kHz;
    opus_int32 fs_Hz;

    orig_kHz = psEncC->fs_kHz;
   1400c:	f500 538f 	add.w	r3, r0, #4576	; 0x11e0
{
   14010:	b470      	push	{r4, r5, r6}
    orig_kHz = psEncC->fs_kHz;
   14012:	681b      	ldr	r3, [r3, #0]
    /* Handle a bandwidth-switching reset where we need to be aware what the last sampling rate was. */
    if( orig_kHz == 0 ) {
   14014:	b903      	cbnz	r3, 14018 <silk_control_audio_bandwidth+0xc>
        orig_kHz = psEncC->sLP.saved_fs_kHz;
   14016:	6a03      	ldr	r3, [r0, #32]
    }
    fs_kHz = orig_kHz;
    fs_Hz = silk_SMULBB( fs_kHz, 1000 );
   14018:	b21a      	sxth	r2, r3
   1401a:	ebc2 1542 	rsb	r5, r2, r2, lsl #5
   1401e:	f241 14cc 	movw	r4, #4556	; 0x11cc
   14022:	eb02 0285 	add.w	r2, r2, r5, lsl #2
    if( fs_Hz == 0 ) {
   14026:	00d2      	lsls	r2, r2, #3
   14028:	5904      	ldr	r4, [r0, r4]
   1402a:	d03d      	beq.n	140a8 <silk_control_audio_bandwidth+0x9c>
   1402c:	f241 15d4 	movw	r5, #4564	; 0x11d4
   14030:	f241 16d8 	movw	r6, #4568	; 0x11d8
        /* Encoder has just been initialized */
        fs_Hz  = silk_min( psEncC->desiredInternal_fs_Hz, psEncC->API_fs_Hz );
        fs_kHz = silk_DIV32_16( fs_Hz, 1000 );
    } else if( fs_Hz > psEncC->API_fs_Hz || fs_Hz > psEncC->maxInternal_fs_Hz || fs_Hz < psEncC->minInternal_fs_Hz ) {
   14034:	42a2      	cmp	r2, r4
   14036:	5945      	ldr	r5, [r0, r5]
   14038:	5986      	ldr	r6, [r0, r6]
   1403a:	dc26      	bgt.n	1408a <silk_control_audio_bandwidth+0x7e>
   1403c:	42aa      	cmp	r2, r5
   1403e:	dc24      	bgt.n	1408a <silk_control_audio_bandwidth+0x7e>
   14040:	42b2      	cmp	r2, r6
   14042:	db22      	blt.n	1408a <silk_control_audio_bandwidth+0x7e>
        fs_Hz  = silk_min( fs_Hz, psEncC->maxInternal_fs_Hz );
        fs_Hz  = silk_max( fs_Hz, psEncC->minInternal_fs_Hz );
        fs_kHz = silk_DIV32_16( fs_Hz, 1000 );
    } else {
        /* State machine for the internal sampling rate switching */
        if( psEncC->sLP.transition_frame_no >= TRANSITION_FRAMES ) {
   14044:	6984      	ldr	r4, [r0, #24]
   14046:	2cff      	cmp	r4, #255	; 0xff
            /* Stop transition phase */
            psEncC->sLP.mode = 0;
   14048:	bfc4      	itt	gt
   1404a:	2500      	movgt	r5, #0
   1404c:	61c5      	strgt	r5, [r0, #28]
        }
        if( psEncC->allow_bandwidth_switch || encControl->opusCanSwitch ) {
   1404e:	f241 15b8 	movw	r5, #4536	; 0x11b8
   14052:	5945      	ldr	r5, [r0, r5]
   14054:	2d00      	cmp	r5, #0
   14056:	d036      	beq.n	140c6 <silk_control_audio_bandwidth+0xba>
            /* Check if we should switch down */
            if( silk_SMULBB( orig_kHz, 1000 ) > psEncC->desiredInternal_fs_Hz )
   14058:	f241 15dc 	movw	r5, #4572	; 0x11dc
   1405c:	5945      	ldr	r5, [r0, r5]
   1405e:	4295      	cmp	r5, r2
   14060:	da35      	bge.n	140ce <silk_control_audio_bandwidth+0xc2>
            {
                /* Switch down */
                if( psEncC->sLP.mode == 0 ) {
   14062:	69c2      	ldr	r2, [r0, #28]
   14064:	2a00      	cmp	r2, #0
   14066:	d04f      	beq.n	14108 <silk_control_audio_bandwidth+0xfc>
                    psEncC->sLP.transition_frame_no = TRANSITION_FRAMES;

                    /* Reset transition filter state */
                    silk_memset( psEncC->sLP.In_LP_State, 0, sizeof( psEncC->sLP.In_LP_State ) );
                }
                if( encControl->opusCanSwitch ) {
   14068:	6c0a      	ldr	r2, [r1, #64]	; 0x40
   1406a:	2a00      	cmp	r2, #0
   1406c:	d144      	bne.n	140f8 <silk_control_audio_bandwidth+0xec>
                    psEncC->sLP.mode = 0;

                    /* Switch to a lower sample frequency */
                    fs_kHz = orig_kHz == 16 ? 12 : 8;
                } else {
                   if( psEncC->sLP.transition_frame_no <= 0 ) {
   1406e:	2c00      	cmp	r4, #0
   14070:	dc52      	bgt.n	14118 <silk_control_audio_bandwidth+0x10c>
                    psEncC->sLP.mode = 1;
                } else {
                   if( psEncC->sLP.mode == 0 ) {
                       encControl->switchReady = 1;
                       /* Make room for redundancy */
                       encControl->maxBits -= encControl->maxBits * 5 / ( encControl->payloadSize_ms + 5 );
   14072:	6b8a      	ldr	r2, [r1, #56]	; 0x38
   14074:	698c      	ldr	r4, [r1, #24]
   14076:	eb02 0082 	add.w	r0, r2, r2, lsl #2
   1407a:	3405      	adds	r4, #5
   1407c:	fb90 f0f4 	sdiv	r0, r0, r4
                       encControl->switchReady = 1;
   14080:	2401      	movs	r4, #1
                       encControl->maxBits -= encControl->maxBits * 5 / ( encControl->payloadSize_ms + 5 );
   14082:	1a12      	subs	r2, r2, r0
   14084:	638a      	str	r2, [r1, #56]	; 0x38
                       encControl->switchReady = 1;
   14086:	658c      	str	r4, [r1, #88]	; 0x58
   14088:	e00b      	b.n	140a2 <silk_control_audio_bandwidth+0x96>
        fs_Hz  = silk_min( fs_Hz, psEncC->maxInternal_fs_Hz );
   1408a:	42ac      	cmp	r4, r5
   1408c:	bfa8      	it	ge
   1408e:	462c      	movge	r4, r5
        fs_Hz  = silk_max( fs_Hz, psEncC->minInternal_fs_Hz );
   14090:	42b4      	cmp	r4, r6
        fs_kHz = silk_DIV32_16( fs_Hz, 1000 );
   14092:	4b25      	ldr	r3, [pc, #148]	; (14128 <silk_control_audio_bandwidth+0x11c>)
        fs_Hz  = silk_max( fs_Hz, psEncC->minInternal_fs_Hz );
   14094:	bfb8      	it	lt
   14096:	4634      	movlt	r4, r6
        fs_kHz = silk_DIV32_16( fs_Hz, 1000 );
   14098:	fb83 2304 	smull	r2, r3, r3, r4
   1409c:	17e4      	asrs	r4, r4, #31
   1409e:	ebc4 13a3 	rsb	r3, r4, r3, asr #6
            }
        }
    }

    return fs_kHz;
}
   140a2:	4618      	mov	r0, r3
   140a4:	bc70      	pop	{r4, r5, r6}
   140a6:	4770      	bx	lr
        fs_Hz  = silk_min( psEncC->desiredInternal_fs_Hz, psEncC->API_fs_Hz );
   140a8:	f241 12dc 	movw	r2, #4572	; 0x11dc
        fs_kHz = silk_DIV32_16( fs_Hz, 1000 );
   140ac:	4b1e      	ldr	r3, [pc, #120]	; (14128 <silk_control_audio_bandwidth+0x11c>)
        fs_Hz  = silk_min( psEncC->desiredInternal_fs_Hz, psEncC->API_fs_Hz );
   140ae:	5880      	ldr	r0, [r0, r2]
   140b0:	4284      	cmp	r4, r0
   140b2:	bfa8      	it	ge
   140b4:	4604      	movge	r4, r0
        fs_kHz = silk_DIV32_16( fs_Hz, 1000 );
   140b6:	fb83 2304 	smull	r2, r3, r3, r4
   140ba:	17e4      	asrs	r4, r4, #31
   140bc:	ebc4 13a3 	rsb	r3, r4, r3, asr #6
}
   140c0:	4618      	mov	r0, r3
   140c2:	bc70      	pop	{r4, r5, r6}
   140c4:	4770      	bx	lr
        if( psEncC->allow_bandwidth_switch || encControl->opusCanSwitch ) {
   140c6:	6c0d      	ldr	r5, [r1, #64]	; 0x40
   140c8:	2d00      	cmp	r5, #0
   140ca:	d1c5      	bne.n	14058 <silk_control_audio_bandwidth+0x4c>
   140cc:	e7e9      	b.n	140a2 <silk_control_audio_bandwidth+0x96>
            if( silk_SMULBB( orig_kHz, 1000 ) < psEncC->desiredInternal_fs_Hz )
   140ce:	dd0d      	ble.n	140ec <silk_control_audio_bandwidth+0xe0>
                if( encControl->opusCanSwitch ) {
   140d0:	6c0a      	ldr	r2, [r1, #64]	; 0x40
   140d2:	b32a      	cbz	r2, 14120 <silk_control_audio_bandwidth+0x114>
                    psEncC->sLP.transition_frame_no = 0;
   140d4:	2200      	movs	r2, #0
                    fs_kHz = orig_kHz == 8 ? 12 : 16;
   140d6:	2b08      	cmp	r3, #8
                    psEncC->sLP.mode = 1;
   140d8:	f04f 0101 	mov.w	r1, #1
                    fs_kHz = orig_kHz == 8 ? 12 : 16;
   140dc:	bf14      	ite	ne
   140de:	2310      	movne	r3, #16
   140e0:	230c      	moveq	r3, #12
                    psEncC->sLP.transition_frame_no = 0;
   140e2:	6182      	str	r2, [r0, #24]
                    silk_memset( psEncC->sLP.In_LP_State, 0, sizeof( psEncC->sLP.In_LP_State ) );
   140e4:	6102      	str	r2, [r0, #16]
   140e6:	6142      	str	r2, [r0, #20]
                    psEncC->sLP.mode = 1;
   140e8:	61c1      	str	r1, [r0, #28]
   140ea:	e7da      	b.n	140a2 <silk_control_audio_bandwidth+0x96>
               if (psEncC->sLP.mode<0)
   140ec:	69c2      	ldr	r2, [r0, #28]
   140ee:	2a00      	cmp	r2, #0
   140f0:	dad7      	bge.n	140a2 <silk_control_audio_bandwidth+0x96>
                  psEncC->sLP.mode = 1;
   140f2:	2201      	movs	r2, #1
   140f4:	61c2      	str	r2, [r0, #28]
   140f6:	e7d4      	b.n	140a2 <silk_control_audio_bandwidth+0x96>
                    fs_kHz = orig_kHz == 16 ? 12 : 8;
   140f8:	2b10      	cmp	r3, #16
                    psEncC->sLP.mode = 0;
   140fa:	f04f 0200 	mov.w	r2, #0
                    fs_kHz = orig_kHz == 16 ? 12 : 8;
   140fe:	bf14      	ite	ne
   14100:	2308      	movne	r3, #8
   14102:	230c      	moveq	r3, #12
                    psEncC->sLP.mode = 0;
   14104:	61c2      	str	r2, [r0, #28]
   14106:	e7cc      	b.n	140a2 <silk_control_audio_bandwidth+0x96>
                    silk_memset( psEncC->sLP.In_LP_State, 0, sizeof( psEncC->sLP.In_LP_State ) );
   14108:	6102      	str	r2, [r0, #16]
   1410a:	6142      	str	r2, [r0, #20]
                if( encControl->opusCanSwitch ) {
   1410c:	6c0a      	ldr	r2, [r1, #64]	; 0x40
                    psEncC->sLP.transition_frame_no = TRANSITION_FRAMES;
   1410e:	f44f 7180 	mov.w	r1, #256	; 0x100
   14112:	6181      	str	r1, [r0, #24]
                if( encControl->opusCanSwitch ) {
   14114:	2a00      	cmp	r2, #0
   14116:	d1ef      	bne.n	140f8 <silk_control_audio_bandwidth+0xec>
                       psEncC->sLP.mode = -2;
   14118:	f06f 0201 	mvn.w	r2, #1
   1411c:	61c2      	str	r2, [r0, #28]
   1411e:	e7c0      	b.n	140a2 <silk_control_audio_bandwidth+0x96>
                   if( psEncC->sLP.mode == 0 ) {
   14120:	69c2      	ldr	r2, [r0, #28]
   14122:	2a00      	cmp	r2, #0
   14124:	d1e5      	bne.n	140f2 <silk_control_audio_bandwidth+0xe6>
   14126:	e7a4      	b.n	14072 <silk_control_audio_bandwidth+0x66>
   14128:	10624dd3 	.word	0x10624dd3

0001412c <silk_quant_LTP_gains>:
    const opus_int32            xX_Q17[ MAX_NB_SUBFR*LTP_ORDER ],           /* I    Correlation vector in Q18       */
    const opus_int              subfr_len,                                  /* I    Number of samples per subframe  */
    const opus_int              nb_subfr,                                   /* I    Number of subframes             */
    int                         arch                                        /* I    Run-time architecture           */
)
{
   1412c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14130:	b099      	sub	sp, #100	; 0x64
   14132:	e9cd 1012 	strd	r1, r0, [sp, #72]	; 0x48
   14136:	9211      	str	r2, [sp, #68]	; 0x44
   14138:	9a26      	ldr	r2, [sp, #152]	; 0x98
   1413a:	930d      	str	r3, [sp, #52]	; 0x34
   1413c:	ab14      	add	r3, sp, #80	; 0x50
   1413e:	4413      	add	r3, r2
    /***************************************************/
    /* iterate over different codebooks with different */
    /* rates/distortions, and choose best */
    /***************************************************/
    min_rate_dist_Q7 = silk_int32_MAX;
    best_sum_log_gain_Q7 = 0;
   14140:	2400      	movs	r4, #0
   14142:	930f      	str	r3, [sp, #60]	; 0x3c
    min_rate_dist_Q7 = silk_int32_MAX;
   14144:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
    best_sum_log_gain_Q7 = 0;
   14148:	9410      	str	r4, [sp, #64]	; 0x40
    for( k = 0; k < 3; k++ ) {
   1414a:	46a2      	mov	sl, r4
    min_rate_dist_Q7 = silk_int32_MAX;
   1414c:	930e      	str	r3, [sp, #56]	; 0x38
        /* Safety margin for pitch gain control, to take into account factors
           such as state rescaling/rewhitening. */
        opus_int32 gain_safety = SILK_FIX_CONST( 0.4, 7 );

        cl_ptr_Q5  = silk_LTP_gain_BITS_Q5_ptrs[ k ];
   1414e:	4b6f      	ldr	r3, [pc, #444]	; (1430c <silk_quant_LTP_gains+0x1e0>)
   14150:	f853 302a 	ldr.w	r3, [r3, sl, lsl #2]
   14154:	9308      	str	r3, [sp, #32]
        cbk_ptr_Q7 = silk_LTP_vq_ptrs_Q7[        k ];
   14156:	4b6e      	ldr	r3, [pc, #440]	; (14310 <silk_quant_LTP_gains+0x1e4>)
   14158:	f853 302a 	ldr.w	r3, [r3, sl, lsl #2]
   1415c:	9309      	str	r3, [sp, #36]	; 0x24
        cbk_gain_ptr_Q7 = silk_LTP_vq_gain_ptrs_Q7[ k ];
   1415e:	4b6d      	ldr	r3, [pc, #436]	; (14314 <silk_quant_LTP_gains+0x1e8>)
   14160:	f853 302a 	ldr.w	r3, [r3, sl, lsl #2]
   14164:	930a      	str	r3, [sp, #40]	; 0x28
        cbk_size   = silk_LTP_vq_sizes[          k ];
   14166:	4b6c      	ldr	r3, [pc, #432]	; (14318 <silk_quant_LTP_gains+0x1ec>)
   14168:	f913 300a 	ldrsb.w	r3, [r3, sl]
   1416c:	930b      	str	r3, [sp, #44]	; 0x2c
        XX_Q17_ptr = XX_Q17;
        xX_Q17_ptr = xX_Q17;

        res_nrg_Q15 = 0;
        rate_dist_Q7 = 0;
        sum_log_gain_tmp_Q7 = *sum_log_gain_Q7;
   1416e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14170:	681d      	ldr	r5, [r3, #0]
        for( j = 0; j < nb_subfr; j++ ) {
   14172:	9b26      	ldr	r3, [sp, #152]	; 0x98
   14174:	2b00      	cmp	r3, #0
   14176:	f340 80c0 	ble.w	142fa <silk_quant_LTP_gains+0x1ce>
        XX_Q17_ptr = XX_Q17;
   1417a:	e9dd 7823 	ldrd	r7, r8, [sp, #140]	; 0x8c
        rate_dist_Q7 = 0;
   1417e:	2400      	movs	r4, #0
            max_gain_Q7 = silk_log2lin( ( SILK_FIX_CONST( MAX_SUM_LOG_GAIN_DB / 6.0, 7 ) - sum_log_gain_tmp_Q7 )
   14180:	463b      	mov	r3, r7
   14182:	f8cd a030 	str.w	sl, [sp, #48]	; 0x30
   14186:	4647      	mov	r7, r8
        res_nrg_Q15 = 0;
   14188:	46a1      	mov	r9, r4
   1418a:	ae14      	add	r6, sp, #80	; 0x50
            max_gain_Q7 = silk_log2lin( ( SILK_FIX_CONST( MAX_SUM_LOG_GAIN_DB / 6.0, 7 ) - sum_log_gain_tmp_Q7 )
   1418c:	f641 0b55 	movw	fp, #6229	; 0x1855
   14190:	f8dd a03c 	ldr.w	sl, [sp, #60]	; 0x3c
   14194:	4698      	mov	r8, r3
   14196:	e008      	b.n	141aa <silk_quant_LTP_gains+0x7e>
   14198:	3601      	adds	r6, #1
        for( j = 0; j < nb_subfr; j++ ) {
   1419a:	45b2      	cmp	sl, r6
                arch                    /* I    Run-time architecture                                   */
            );

            res_nrg_Q15  = silk_ADD_POS_SAT32( res_nrg_Q15, res_nrg_Q15_subfr );
            rate_dist_Q7 = silk_ADD_POS_SAT32( rate_dist_Q7, rate_dist_Q7_subfr );
            sum_log_gain_tmp_Q7 = silk_max(0, sum_log_gain_tmp_Q7
   1419c:	f04f 0500 	mov.w	r5, #0
                                + silk_lin2log( gain_safety + gain_Q7 ) - SILK_FIX_CONST( 7, 7 ));

            XX_Q17_ptr += LTP_ORDER * LTP_ORDER;
   141a0:	f108 0864 	add.w	r8, r8, #100	; 0x64
            xX_Q17_ptr += LTP_ORDER;
   141a4:	f107 0714 	add.w	r7, r7, #20
        for( j = 0; j < nb_subfr; j++ ) {
   141a8:	d039      	beq.n	1421e <silk_quant_LTP_gains+0xf2>
            max_gain_Q7 = silk_log2lin( ( SILK_FIX_CONST( MAX_SUM_LOG_GAIN_DB / 6.0, 7 ) - sum_log_gain_tmp_Q7 )
   141aa:	ebab 0005 	sub.w	r0, fp, r5
   141ae:	f003 fc43 	bl	17a38 <silk_log2lin>
            silk_VQ_WMat_EC(
   141b2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   141b4:	9307      	str	r3, [sp, #28]
   141b6:	9b25      	ldr	r3, [sp, #148]	; 0x94
   141b8:	9305      	str	r3, [sp, #20]
   141ba:	9b08      	ldr	r3, [sp, #32]
   141bc:	9304      	str	r3, [sp, #16]
   141be:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   141c0:	9303      	str	r3, [sp, #12]
   141c2:	9b09      	ldr	r3, [sp, #36]	; 0x24
   141c4:	f8cd 8000 	str.w	r8, [sp]
            max_gain_Q7 = silk_log2lin( ( SILK_FIX_CONST( MAX_SUM_LOG_GAIN_DB / 6.0, 7 ) - sum_log_gain_tmp_Q7 )
   141c8:	3833      	subs	r0, #51	; 0x33
            silk_VQ_WMat_EC(
   141ca:	9006      	str	r0, [sp, #24]
   141cc:	e9cd 7301 	strd	r7, r3, [sp, #4]
   141d0:	aa16      	add	r2, sp, #88	; 0x58
   141d2:	ab17      	add	r3, sp, #92	; 0x5c
   141d4:	a915      	add	r1, sp, #84	; 0x54
   141d6:	4630      	mov	r0, r6
   141d8:	f000 f8a0 	bl	1431c <silk_VQ_WMat_EC_c>
            rate_dist_Q7 = silk_ADD_POS_SAT32( rate_dist_Q7, rate_dist_Q7_subfr );
   141dc:	e9dd 2315 	ldrd	r2, r3, [sp, #84]	; 0x54
            sum_log_gain_tmp_Q7 = silk_max(0, sum_log_gain_tmp_Q7
   141e0:	9817      	ldr	r0, [sp, #92]	; 0x5c
            res_nrg_Q15  = silk_ADD_POS_SAT32( res_nrg_Q15, res_nrg_Q15_subfr );
   141e2:	eb19 0902 	adds.w	r9, r9, r2
   141e6:	bf48      	it	mi
   141e8:	f06f 4900 	mvnmi.w	r9, #2147483648	; 0x80000000
            sum_log_gain_tmp_Q7 = silk_max(0, sum_log_gain_tmp_Q7
   141ec:	3033      	adds	r0, #51	; 0x33
            rate_dist_Q7 = silk_ADD_POS_SAT32( rate_dist_Q7, rate_dist_Q7_subfr );
   141ee:	18e4      	adds	r4, r4, r3
   141f0:	bf48      	it	mi
   141f2:	f06f 4400 	mvnmi.w	r4, #2147483648	; 0x80000000
            sum_log_gain_tmp_Q7 = silk_max(0, sum_log_gain_tmp_Q7
   141f6:	f003 fbdf 	bl	179b8 <silk_lin2log>
   141fa:	4428      	add	r0, r5
   141fc:	f5b0 7f60 	cmp.w	r0, #896	; 0x380
   14200:	dbca      	blt.n	14198 <silk_quant_LTP_gains+0x6c>
   14202:	9817      	ldr	r0, [sp, #92]	; 0x5c
   14204:	3033      	adds	r0, #51	; 0x33
   14206:	f003 fbd7 	bl	179b8 <silk_lin2log>
   1420a:	3601      	adds	r6, #1
   1420c:	4405      	add	r5, r0
        for( j = 0; j < nb_subfr; j++ ) {
   1420e:	45b2      	cmp	sl, r6
            sum_log_gain_tmp_Q7 = silk_max(0, sum_log_gain_tmp_Q7
   14210:	f5a5 7560 	sub.w	r5, r5, #896	; 0x380
            XX_Q17_ptr += LTP_ORDER * LTP_ORDER;
   14214:	f108 0864 	add.w	r8, r8, #100	; 0x64
            xX_Q17_ptr += LTP_ORDER;
   14218:	f107 0714 	add.w	r7, r7, #20
        for( j = 0; j < nb_subfr; j++ ) {
   1421c:	d1c5      	bne.n	141aa <silk_quant_LTP_gains+0x7e>
        }

        if( rate_dist_Q7 <= min_rate_dist_Q7 ) {
   1421e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   14220:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
   14224:	42a3      	cmp	r3, r4
   14226:	da5d      	bge.n	142e4 <silk_quant_LTP_gains+0x1b8>
    for( k = 0; k < 3; k++ ) {
   14228:	f10a 0a01 	add.w	sl, sl, #1
   1422c:	f1ba 0f03 	cmp.w	sl, #3
   14230:	d18d      	bne.n	1414e <silk_quant_LTP_gains+0x22>
            silk_memcpy( cbk_index, temp_idx, nb_subfr * sizeof( opus_int8 ) );
            best_sum_log_gain_Q7 = sum_log_gain_tmp_Q7;
        }
    }

    cbk_ptr_Q7 = silk_LTP_vq_ptrs_Q7[ *periodicity_index ];
   14232:	9b11      	ldr	r3, [sp, #68]	; 0x44
   14234:	4a36      	ldr	r2, [pc, #216]	; (14310 <silk_quant_LTP_gains+0x1e4>)
   14236:	f993 3000 	ldrsb.w	r3, [r3]
   1423a:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    for( j = 0; j < nb_subfr; j++ ) {
   1423e:	9b26      	ldr	r3, [sp, #152]	; 0x98
   14240:	2b00      	cmp	r3, #0
   14242:	dd3d      	ble.n	142c0 <silk_quant_LTP_gains+0x194>
   14244:	4618      	mov	r0, r3
   14246:	9b12      	ldr	r3, [sp, #72]	; 0x48
   14248:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   1424a:	3b01      	subs	r3, #1
        for( k = 0; k < LTP_ORDER; k++ ) {
            B_Q14[ j * LTP_ORDER + k ] = silk_LSHIFT( cbk_ptr_Q7[ cbk_index[ j ] * LTP_ORDER + k ], 7 );
   1424c:	46d6      	mov	lr, sl
   1424e:	eb03 0c00 	add.w	ip, r3, r0
   14252:	2405      	movs	r4, #5
   14254:	2701      	movs	r7, #1
   14256:	2602      	movs	r6, #2
   14258:	2504      	movs	r5, #4
   1425a:	f913 0f01 	ldrsb.w	r0, [r3, #1]!
   1425e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    for( j = 0; j < nb_subfr; j++ ) {
   14262:	4563      	cmp	r3, ip
            B_Q14[ j * LTP_ORDER + k ] = silk_LSHIFT( cbk_ptr_Q7[ cbk_index[ j ] * LTP_ORDER + k ], 7 );
   14264:	5608      	ldrsb	r0, [r1, r0]
   14266:	ea4f 10c0 	mov.w	r0, r0, lsl #7
   1426a:	8010      	strh	r0, [r2, #0]
   1426c:	f993 0000 	ldrsb.w	r0, [r3]
   14270:	fb14 7000 	smlabb	r0, r4, r0, r7
   14274:	f102 020a 	add.w	r2, r2, #10
   14278:	5608      	ldrsb	r0, [r1, r0]
   1427a:	ea4f 10c0 	mov.w	r0, r0, lsl #7
   1427e:	f822 0c08 	strh.w	r0, [r2, #-8]
   14282:	f993 0000 	ldrsb.w	r0, [r3]
   14286:	fb14 6000 	smlabb	r0, r4, r0, r6
   1428a:	5608      	ldrsb	r0, [r1, r0]
   1428c:	ea4f 10c0 	mov.w	r0, r0, lsl #7
   14290:	f822 0c06 	strh.w	r0, [r2, #-6]
   14294:	f993 0000 	ldrsb.w	r0, [r3]
   14298:	fb14 e000 	smlabb	r0, r4, r0, lr
   1429c:	5608      	ldrsb	r0, [r1, r0]
   1429e:	ea4f 10c0 	mov.w	r0, r0, lsl #7
   142a2:	f822 0c04 	strh.w	r0, [r2, #-4]
   142a6:	f993 0000 	ldrsb.w	r0, [r3]
   142aa:	fb14 5000 	smlabb	r0, r4, r0, r5
   142ae:	5608      	ldrsb	r0, [r1, r0]
   142b0:	ea4f 10c0 	mov.w	r0, r0, lsl #7
   142b4:	f822 0c02 	strh.w	r0, [r2, #-2]
    for( j = 0; j < nb_subfr; j++ ) {
   142b8:	d1cf      	bne.n	1425a <silk_quant_LTP_gains+0x12e>
        }
    }

    if( nb_subfr == 2 ) {
   142ba:	9b26      	ldr	r3, [sp, #152]	; 0x98
   142bc:	2b02      	cmp	r3, #2
   142be:	d021      	beq.n	14304 <silk_quant_LTP_gains+0x1d8>
        res_nrg_Q15 = silk_RSHIFT32( res_nrg_Q15, 1 );
    } else {
        res_nrg_Q15 = silk_RSHIFT32( res_nrg_Q15, 2 );
   142c0:	ea4f 00a9 	mov.w	r0, r9, asr #2
    }

    *sum_log_gain_Q7 = best_sum_log_gain_Q7;
   142c4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   142c6:	461a      	mov	r2, r3
   142c8:	9b10      	ldr	r3, [sp, #64]	; 0x40
   142ca:	6013      	str	r3, [r2, #0]
    *pred_gain_dB_Q7 = (opus_int)silk_SMULBB( -3, silk_lin2log( res_nrg_Q15 ) - ( 15 << 7 ) );
   142cc:	f003 fb74 	bl	179b8 <silk_lin2log>
   142d0:	f5a0 60f0 	sub.w	r0, r0, #1920	; 0x780
   142d4:	9b22      	ldr	r3, [sp, #136]	; 0x88
   142d6:	b200      	sxth	r0, r0
   142d8:	eba0 0080 	sub.w	r0, r0, r0, lsl #2
   142dc:	6018      	str	r0, [r3, #0]
}
   142de:	b019      	add	sp, #100	; 0x64
   142e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   142e4:	9a26      	ldr	r2, [sp, #152]	; 0x98
            *periodicity_index = (opus_int8)k;
   142e6:	9b11      	ldr	r3, [sp, #68]	; 0x44
            silk_memcpy( cbk_index, temp_idx, nb_subfr * sizeof( opus_int8 ) );
   142e8:	9812      	ldr	r0, [sp, #72]	; 0x48
            *periodicity_index = (opus_int8)k;
   142ea:	f883 a000 	strb.w	sl, [r3]
            silk_memcpy( cbk_index, temp_idx, nb_subfr * sizeof( opus_int8 ) );
   142ee:	a914      	add	r1, sp, #80	; 0x50
   142f0:	f7f7 ff06 	bl	c100 <memcpy>
   142f4:	9510      	str	r5, [sp, #64]	; 0x40
   142f6:	940e      	str	r4, [sp, #56]	; 0x38
   142f8:	e796      	b.n	14228 <silk_quant_LTP_gains+0xfc>
        res_nrg_Q15 = 0;
   142fa:	f04f 0900 	mov.w	r9, #0
        rate_dist_Q7 = 0;
   142fe:	464c      	mov	r4, r9
   14300:	461a      	mov	r2, r3
   14302:	e7f0      	b.n	142e6 <silk_quant_LTP_gains+0x1ba>
        res_nrg_Q15 = silk_RSHIFT32( res_nrg_Q15, 1 );
   14304:	ea4f 0069 	mov.w	r0, r9, asr #1
   14308:	e7dc      	b.n	142c4 <silk_quant_LTP_gains+0x198>
   1430a:	bf00      	nop
   1430c:	00035cd8 	.word	0x00035cd8
   14310:	00035e88 	.word	0x00035e88
   14314:	00035e7c 	.word	0x00035e7c
   14318:	00035e94 	.word	0x00035e94

0001431c <silk_VQ_WMat_EC_c>:
    const opus_uint8            *cl_Q5,                         /* I    code length for each codebook vector        */
    const opus_int              subfr_len,                      /* I    number of samples per subframe              */
    const opus_int32            max_gain_Q7,                    /* I    maximum sum of absolute LTP coefficients    */
    const opus_int              L                               /* I    number of vectors in codebook               */
)
{
   1431c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14320:	b08b      	sub	sp, #44	; 0x2c
    /* Loop over codebook */
    *rate_dist_Q8 = silk_int32_MAX;
    *res_nrg_Q15 = silk_int32_MAX;
    cb_row_Q7 = cb_Q7;
    /* In things go really bad, at least *ind is set to something safe. */
    *ind = 0;
   14322:	f04f 0900 	mov.w	r9, #0
{
   14326:	9d15      	ldr	r5, [sp, #84]	; 0x54
   14328:	f8dd a050 	ldr.w	sl, [sp, #80]	; 0x50
    neg_xX_Q24[ 4 ] = -silk_LSHIFT32( xX_Q17[ 4 ], 7 );
   1432c:	692c      	ldr	r4, [r5, #16]
    neg_xX_Q24[ 1 ] = -silk_LSHIFT32( xX_Q17[ 1 ], 7 );
   1432e:	e9d5 8e00 	ldrd	r8, lr, [r5]
    neg_xX_Q24[ 3 ] = -silk_LSHIFT32( xX_Q17[ 3 ], 7 );
   14332:	e9d5 c702 	ldrd	ip, r7, [r5, #8]
    neg_xX_Q24[ 0 ] = -silk_LSHIFT32( xX_Q17[ 0 ], 7 );
   14336:	ea4f 16c8 	mov.w	r6, r8, lsl #7
    *rate_dist_Q8 = silk_int32_MAX;
   1433a:	f06f 4500 	mvn.w	r5, #2147483648	; 0x80000000
   1433e:	6015      	str	r5, [r2, #0]
    neg_xX_Q24[ 0 ] = -silk_LSHIFT32( xX_Q17[ 0 ], 7 );
   14340:	9601      	str	r6, [sp, #4]
    *res_nrg_Q15 = silk_int32_MAX;
   14342:	600d      	str	r5, [r1, #0]
    neg_xX_Q24[ 1 ] = -silk_LSHIFT32( xX_Q17[ 1 ], 7 );
   14344:	ea4f 16ce 	mov.w	r6, lr, lsl #7
    for( k = 0; k < L; k++ ) {
   14348:	9d1b      	ldr	r5, [sp, #108]	; 0x6c
    neg_xX_Q24[ 1 ] = -silk_LSHIFT32( xX_Q17[ 1 ], 7 );
   1434a:	9602      	str	r6, [sp, #8]
    neg_xX_Q24[ 2 ] = -silk_LSHIFT32( xX_Q17[ 2 ], 7 );
   1434c:	ea4f 16cc 	mov.w	r6, ip, lsl #7
   14350:	9603      	str	r6, [sp, #12]
    for( k = 0; k < L; k++ ) {
   14352:	454d      	cmp	r5, r9
    neg_xX_Q24[ 3 ] = -silk_LSHIFT32( xX_Q17[ 3 ], 7 );
   14354:	ea4f 16c7 	mov.w	r6, r7, lsl #7
   14358:	9604      	str	r6, [sp, #16]
    *ind = 0;
   1435a:	f880 9000 	strb.w	r9, [r0]
    for( k = 0; k < L; k++ ) {
   1435e:	f340 80c3 	ble.w	144e8 <silk_VQ_WMat_EC_c+0x1cc>
   14362:	01e4      	lsls	r4, r4, #7
   14364:	4264      	negs	r4, r4
   14366:	e9cd 0308 	strd	r0, r3, [sp, #32]
        sum2_Q24 = silk_LSHIFT32( sum2_Q24, 1 );
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[ 18 ], cb_row_Q7[ 3 ] );
        sum1_Q15 = silk_SMLAWB( sum1_Q15,        sum2_Q24,  cb_row_Q7[ 3 ] );

        /* last row of XX_Q17 */
        sum2_Q24 = silk_LSHIFT32( neg_xX_Q24[ 4 ], 1 );
   1436a:	0063      	lsls	r3, r4, #1
   1436c:	9305      	str	r3, [sp, #20]
   1436e:	9b16      	ldr	r3, [sp, #88]	; 0x58
   14370:	e9cd 2106 	strd	r2, r1, [sp, #24]
   14374:	f103 0805 	add.w	r8, r3, #5
        sum1_Q15 = silk_SMLAWB( sum1_Q15,        sum2_Q24,  cb_row_Q7[ 0 ] );
   14378:	4656      	mov	r6, sl
   1437a:	e005      	b.n	14388 <silk_VQ_WMat_EC_c+0x6c>
    for( k = 0; k < L; k++ ) {
   1437c:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
   1437e:	f109 0901 	add.w	r9, r9, #1
   14382:	454b      	cmp	r3, r9
   14384:	f000 80b0 	beq.w	144e8 <silk_VQ_WMat_EC_c+0x1cc>
        sum2_Q24 = silk_MLA( neg_xX_Q24[ 0 ], XX_Q17[  1 ], cb_row_Q7[ 1 ] );
   14388:	f918 7c04 	ldrsb.w	r7, [r8, #-4]
   1438c:	6873      	ldr	r3, [r6, #4]
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[  2 ], cb_row_Q7[ 2 ] );
   1438e:	f918 4c03 	ldrsb.w	r4, [r8, #-3]
   14392:	68b5      	ldr	r5, [r6, #8]
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[  3 ], cb_row_Q7[ 3 ] );
   14394:	f918 0c02 	ldrsb.w	r0, [r8, #-2]
        sum2_Q24 = silk_MLA( neg_xX_Q24[ 1 ], XX_Q17[  7 ], cb_row_Q7[ 2 ] );
   14398:	69f1      	ldr	r1, [r6, #28]
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[  0 ], cb_row_Q7[ 0 ] );
   1439a:	f918 cc05 	ldrsb.w	ip, [r8, #-5]
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[  4 ], cb_row_Q7[ 4 ] );
   1439e:	f918 2c01 	ldrsb.w	r2, [r8, #-1]
        sum2_Q24 = silk_MLA( neg_xX_Q24[ 0 ], XX_Q17[  1 ], cb_row_Q7[ 1 ] );
   143a2:	fb03 fa07 	mul.w	sl, r3, r7
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[  2 ], cb_row_Q7[ 2 ] );
   143a6:	9b01      	ldr	r3, [sp, #4]
   143a8:	ebaa 0a03 	sub.w	sl, sl, r3
   143ac:	fb05 aa04 	mla	sl, r5, r4, sl
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[  3 ], cb_row_Q7[ 3 ] );
   143b0:	68f5      	ldr	r5, [r6, #12]
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[  0 ], cb_row_Q7[ 0 ] );
   143b2:	6833      	ldr	r3, [r6, #0]
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[  3 ], cb_row_Q7[ 3 ] );
   143b4:	fb05 aa00 	mla	sl, r5, r0, sl
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[  8 ], cb_row_Q7[ 3 ] );
   143b8:	9d02      	ldr	r5, [sp, #8]
        sum2_Q24 = silk_MLA( neg_xX_Q24[ 1 ], XX_Q17[  7 ], cb_row_Q7[ 2 ] );
   143ba:	fb01 fe04 	mul.w	lr, r1, r4
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[  8 ], cb_row_Q7[ 3 ] );
   143be:	6a31      	ldr	r1, [r6, #32]
   143c0:	ebae 0e05 	sub.w	lr, lr, r5
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[  0 ], cb_row_Q7[ 0 ] );
   143c4:	fb03 fb0c 	mul.w	fp, r3, ip
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[  4 ], cb_row_Q7[ 4 ] );
   143c8:	6935      	ldr	r5, [r6, #16]
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[  6 ], cb_row_Q7[ 1 ] );
   143ca:	69b3      	ldr	r3, [r6, #24]
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[  8 ], cb_row_Q7[ 3 ] );
   143cc:	fb01 ee00 	mla	lr, r1, r0, lr
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[  9 ], cb_row_Q7[ 4 ] );
   143d0:	6a71      	ldr	r1, [r6, #36]	; 0x24
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[  6 ], cb_row_Q7[ 1 ] );
   143d2:	fb03 f307 	mul.w	r3, r3, r7
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[  4 ], cb_row_Q7[ 4 ] );
   143d6:	fb05 aa02 	mla	sl, r5, r2, sl
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[  9 ], cb_row_Q7[ 4 ] );
   143da:	fb01 ee02 	mla	lr, r1, r2, lr
        sum2_Q24 = silk_MLA( neg_xX_Q24[ 2 ], XX_Q17[ 13 ], cb_row_Q7[ 3 ] );
   143de:	6b75      	ldr	r5, [r6, #52]	; 0x34
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[ 14 ], cb_row_Q7[ 4 ] );
   143e0:	9903      	ldr	r1, [sp, #12]
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[  6 ], cb_row_Q7[ 1 ] );
   143e2:	eb03 0e4e 	add.w	lr, r3, lr, lsl #1
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[ 12 ], cb_row_Q7[ 2 ] );
   143e6:	6b33      	ldr	r3, [r6, #48]	; 0x30
   143e8:	9300      	str	r3, [sp, #0]
        sum2_Q24 = silk_MLA( neg_xX_Q24[ 2 ], XX_Q17[ 13 ], cb_row_Q7[ 3 ] );
   143ea:	fb05 f500 	mul.w	r5, r5, r0
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[ 14 ], cb_row_Q7[ 4 ] );
   143ee:	6bb3      	ldr	r3, [r6, #56]	; 0x38
   143f0:	1a6d      	subs	r5, r5, r1
   143f2:	fb03 5502 	mla	r5, r3, r2, r5
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[ 12 ], cb_row_Q7[ 2 ] );
   143f6:	9b00      	ldr	r3, [sp, #0]
        sum2_Q24 = silk_MLA( neg_xX_Q24[ 3 ], XX_Q17[ 19 ], cb_row_Q7[ 4 ] );
   143f8:	6cf1      	ldr	r1, [r6, #76]	; 0x4c
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[ 12 ], cb_row_Q7[ 2 ] );
   143fa:	fb03 f304 	mul.w	r3, r3, r4
   143fe:	eb03 0545 	add.w	r5, r3, r5, lsl #1
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[ 18 ], cb_row_Q7[ 3 ] );
   14402:	6cb3      	ldr	r3, [r6, #72]	; 0x48
   14404:	9300      	str	r3, [sp, #0]
        sum2_Q24 = silk_LSHIFT32( sum2_Q24, 1 );
   14406:	9b04      	ldr	r3, [sp, #16]
        sum2_Q24 = silk_MLA( neg_xX_Q24[ 3 ], XX_Q17[ 19 ], cb_row_Q7[ 4 ] );
   14408:	fb01 f102 	mul.w	r1, r1, r2
        sum2_Q24 = silk_LSHIFT32( sum2_Q24, 1 );
   1440c:	1ac9      	subs	r1, r1, r3
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[ 18 ], cb_row_Q7[ 3 ] );
   1440e:	9b00      	ldr	r3, [sp, #0]
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[  0 ], cb_row_Q7[ 0 ] );
   14410:	eb0b 0a4a 	add.w	sl, fp, sl, lsl #1
        sum1_Q15 = silk_SMLAWB( sum1_Q15,        sum2_Q24,  cb_row_Q7[ 0 ] );
   14414:	fa1f fb8a 	uxth.w	fp, sl
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[ 18 ], cb_row_Q7[ 3 ] );
   14418:	fb03 f300 	mul.w	r3, r3, r0
        sum1_Q15 = silk_SMLAWB( sum1_Q15,        sum2_Q24,  cb_row_Q7[ 0 ] );
   1441c:	ea4f 4a2a 	mov.w	sl, sl, asr #16
   14420:	fb0c fb0b 	mul.w	fp, ip, fp
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[ 18 ], cb_row_Q7[ 3 ] );
   14424:	eb03 0141 	add.w	r1, r3, r1, lsl #1
        sum1_Q15 = silk_SMLAWB( sum1_Q15,        sum2_Q24,  cb_row_Q7[ 0 ] );
   14428:	fb0c fa0a 	mul.w	sl, ip, sl
        sum1_Q15 = silk_SMLAWB( sum1_Q15,        sum2_Q24,  cb_row_Q7[ 2 ] );
   1442c:	b2ab      	uxth	r3, r5
   1442e:	142d      	asrs	r5, r5, #16
        sum1_Q15 = silk_SMLAWB( sum1_Q15,        sum2_Q24,  cb_row_Q7[ 0 ] );
   14430:	eb0a 4a2b 	add.w	sl, sl, fp, asr #16
        sum1_Q15 = silk_SMLAWB( sum1_Q15,        sum2_Q24,  cb_row_Q7[ 1 ] );
   14434:	fa1f fc8e 	uxth.w	ip, lr
        sum1_Q15 = silk_SMLAWB( sum1_Q15,        sum2_Q24,  cb_row_Q7[ 2 ] );
   14438:	fb04 fb03 	mul.w	fp, r4, r3
   1443c:	fb04 f505 	mul.w	r5, r4, r5
        sum1_Q15 = silk_SMLAWB( sum1_Q15,        sum2_Q24,  cb_row_Q7[ 1 ] );
   14440:	ea4f 4e2e 	mov.w	lr, lr, asr #16
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[ 24 ], cb_row_Q7[ 4 ] );
   14444:	6e33      	ldr	r3, [r6, #96]	; 0x60
   14446:	9c05      	ldr	r4, [sp, #20]
        sum1_Q15 = silk_SMLAWB( sum1_Q15,        sum2_Q24,  cb_row_Q7[ 1 ] );
   14448:	fb07 fc0c 	mul.w	ip, r7, ip
   1444c:	fb07 fe0e 	mul.w	lr, r7, lr
        sum1_Q15 = silk_SMLAWB( sum1_Q15,        sum2_Q24,  cb_row_Q7[ 0 ] );
   14450:	f50a 4a00 	add.w	sl, sl, #32768	; 0x8000
        sum1_Q15 = silk_SMLAWB( sum1_Q15,        sum2_Q24,  cb_row_Q7[ 1 ] );
   14454:	eb0e 4e2c 	add.w	lr, lr, ip, asr #16
        sum1_Q15 = silk_SMLAWB( sum1_Q15,        sum2_Q24,  cb_row_Q7[ 3 ] );
   14458:	b28f      	uxth	r7, r1
        sum2_Q24 = silk_MLA( sum2_Q24,        XX_Q17[ 24 ], cb_row_Q7[ 4 ] );
   1445a:	fb03 4302 	mla	r3, r3, r2, r4
        sum1_Q15 = silk_SMLAWB( sum1_Q15,        sum2_Q24,  cb_row_Q7[ 0 ] );
   1445e:	f10a 0a21 	add.w	sl, sl, #33	; 0x21
        sum1_Q15 = silk_SMLAWB( sum1_Q15,        sum2_Q24,  cb_row_Q7[ 3 ] );
   14462:	1409      	asrs	r1, r1, #16
        sum1_Q15 = silk_SMLAWB( sum1_Q15,        sum2_Q24,  cb_row_Q7[ 4 ] );
   14464:	fa1f fc83 	uxth.w	ip, r3
        sum1_Q15 = silk_SMLAWB( sum1_Q15,        sum2_Q24,  cb_row_Q7[ 1 ] );
   14468:	44f2      	add	sl, lr
        sum1_Q15 = silk_SMLAWB( sum1_Q15,        sum2_Q24,  cb_row_Q7[ 2 ] );
   1446a:	eb05 452b 	add.w	r5, r5, fp, asr #16
        sum1_Q15 = silk_SMLAWB( sum1_Q15,        sum2_Q24,  cb_row_Q7[ 3 ] );
   1446e:	fb00 f707 	mul.w	r7, r0, r7
   14472:	fb00 f101 	mul.w	r1, r0, r1
        sum1_Q15 = silk_SMLAWB( sum1_Q15,        sum2_Q24,  cb_row_Q7[ 4 ] );
   14476:	141b      	asrs	r3, r3, #16
        sum1_Q15 = silk_SMLAWB( sum1_Q15,        sum2_Q24,  cb_row_Q7[ 2 ] );
   14478:	44aa      	add	sl, r5
        sum1_Q15 = silk_SMLAWB( sum1_Q15,        sum2_Q24,  cb_row_Q7[ 3 ] );
   1447a:	eb01 4127 	add.w	r1, r1, r7, asr #16
        sum1_Q15 = silk_SMLAWB( sum1_Q15,        sum2_Q24,  cb_row_Q7[ 4 ] );
   1447e:	fb02 fc0c 	mul.w	ip, r2, ip
   14482:	fb02 f303 	mul.w	r3, r2, r3
        sum1_Q15 = silk_SMLAWB( sum1_Q15,        sum2_Q24,  cb_row_Q7[ 3 ] );
   14486:	448a      	add	sl, r1
        sum1_Q15 = silk_SMLAWB( sum1_Q15,        sum2_Q24,  cb_row_Q7[ 4 ] );
   14488:	eb03 432c 	add.w	r3, r3, ip, asr #16

        /* find best */
        if( sum1_Q15 >= 0 ) {
   1448c:	eb13 0a0a 	adds.w	sl, r3, sl
   14490:	f108 0805 	add.w	r8, r8, #5
   14494:	f53f af72 	bmi.w	1437c <silk_VQ_WMat_EC_c+0x60>
        gain_tmp_Q7 = cb_gain_Q7[k];
   14498:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   1449a:	f813 4009 	ldrb.w	r4, [r3, r9]
        penalty = silk_LSHIFT32( silk_max( silk_SUB32( gain_tmp_Q7, max_gain_Q7 ), 0 ), 11 );
   1449e:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   144a0:	1ae5      	subs	r5, r4, r3
   144a2:	ea25 75e5 	bic.w	r5, r5, r5, asr #31
            /* Translate residual energy to bits using high-rate assumption (6 dB ==> 1 bit/sample) */
            bits_res_Q8 = silk_SMULBB( subfr_len, silk_lin2log( sum1_Q15 + penalty) - (15 << 7) );
   144a6:	eb0a 25c5 	add.w	r5, sl, r5, lsl #11
   144aa:	4628      	mov	r0, r5
   144ac:	f003 fa84 	bl	179b8 <silk_lin2log>
            /* In the following line we reduce the codelength component by half ("-1"); seems to slghtly improve quality */
            bits_tot_Q8 = silk_ADD_LSHIFT32( bits_res_Q8, cl_Q5[ k ], 3-1 );
   144b0:	9b18      	ldr	r3, [sp, #96]	; 0x60
            if( bits_tot_Q8 <= *rate_dist_Q8 ) {
   144b2:	9906      	ldr	r1, [sp, #24]
            bits_tot_Q8 = silk_ADD_LSHIFT32( bits_res_Q8, cl_Q5[ k ], 3-1 );
   144b4:	f813 2009 	ldrb.w	r2, [r3, r9]
   144b8:	9f19      	ldr	r7, [sp, #100]	; 0x64
            if( bits_tot_Q8 <= *rate_dist_Q8 ) {
   144ba:	680b      	ldr	r3, [r1, #0]
            bits_res_Q8 = silk_SMULBB( subfr_len, silk_lin2log( sum1_Q15 + penalty) - (15 << 7) );
   144bc:	f5a0 60f0 	sub.w	r0, r0, #1920	; 0x780
            bits_tot_Q8 = silk_ADD_LSHIFT32( bits_res_Q8, cl_Q5[ k ], 3-1 );
   144c0:	0092      	lsls	r2, r2, #2
   144c2:	fb17 2000 	smlabb	r0, r7, r0, r2
            if( bits_tot_Q8 <= *rate_dist_Q8 ) {
   144c6:	4283      	cmp	r3, r0
   144c8:	f6ff af58 	blt.w	1437c <silk_VQ_WMat_EC_c+0x60>
                *rate_dist_Q8 = bits_tot_Q8;
                *res_nrg_Q15 = sum1_Q15 + penalty;
   144cc:	9b07      	ldr	r3, [sp, #28]
                *rate_dist_Q8 = bits_tot_Q8;
   144ce:	6008      	str	r0, [r1, #0]
                *res_nrg_Q15 = sum1_Q15 + penalty;
   144d0:	601d      	str	r5, [r3, #0]
                *ind = (opus_int8)k;
   144d2:	9b08      	ldr	r3, [sp, #32]
   144d4:	f883 9000 	strb.w	r9, [r3]
                *gain_Q7 = gain_tmp_Q7;
   144d8:	9b09      	ldr	r3, [sp, #36]	; 0x24
   144da:	601c      	str	r4, [r3, #0]
    for( k = 0; k < L; k++ ) {
   144dc:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
   144de:	f109 0901 	add.w	r9, r9, #1
   144e2:	454b      	cmp	r3, r9
   144e4:	f47f af50 	bne.w	14388 <silk_VQ_WMat_EC_c+0x6c>
        }

        /* Go to next cbk vector */
        cb_row_Q7 += LTP_ORDER;
    }
}
   144e8:	b00b      	add	sp, #44	; 0x2c
   144ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   144ee:	bf00      	nop

000144f0 <silk_HP_variable_cutoff>:
   opus_int   quality_Q15;
   opus_int32 pitch_freq_Hz_Q16, pitch_freq_log_Q7, delta_freq_Q7;
   silk_encoder_state *psEncC1 = &state_Fxx[ 0 ].sCmn;

   /* Adaptive cutoff frequency: estimate low end of pitch frequency range */
   if( psEncC1->prevSignalType == TYPE_VOICED ) {
   144f0:	f241 13bd 	movw	r3, #4541	; 0x11bd
   144f4:	56c3      	ldrsb	r3, [r0, r3]
   144f6:	2b02      	cmp	r3, #2
   144f8:	d000      	beq.n	144fc <silk_HP_variable_cutoff+0xc>
   144fa:	4770      	bx	lr
      /* difference, in log domain */
      pitch_freq_Hz_Q16 = silk_DIV32_16( silk_LSHIFT( silk_MUL( psEncC1->fs_kHz, 1000 ), 16 ), psEncC1->prevLag );
   144fc:	f500 528f 	add.w	r2, r0, #4576	; 0x11e0
{
   14500:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14504:	4605      	mov	r5, r0
      pitch_freq_Hz_Q16 = silk_DIV32_16( silk_LSHIFT( silk_MUL( psEncC1->fs_kHz, 1000 ), 16 ), psEncC1->prevLag );
   14506:	6810      	ldr	r0, [r2, #0]
   14508:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   1450c:	f505 528e 	add.w	r2, r5, #4544	; 0x11c0
   14510:	fb03 f300 	mul.w	r3, r3, r0
   14514:	041b      	lsls	r3, r3, #16
   14516:	6810      	ldr	r0, [r2, #0]
      pitch_freq_log_Q7 = silk_lin2log( pitch_freq_Hz_Q16 ) - ( 16 << 7 );
   14518:	fb93 f0f0 	sdiv	r0, r3, r0
   1451c:	f003 fa4c 	bl	179b8 <silk_lin2log>

      /* adjustment based on quality */
      quality_Q15 = psEncC1->input_quality_bands_Q15[ 0 ];
   14520:	f241 2358 	movw	r3, #4696	; 0x1258
      pitch_freq_log_Q7 = silk_lin2log( pitch_freq_Hz_Q16 ) - ( 16 << 7 );
   14524:	f5a0 6800 	sub.w	r8, r0, #2048	; 0x800
      quality_Q15 = psEncC1->input_quality_bands_Q15[ 0 ];
   14528:	58eb      	ldr	r3, [r5, r3]
      pitch_freq_log_Q7 = silk_SMLAWB( pitch_freq_log_Q7, silk_SMULWB( silk_LSHIFT( -quality_Q15, 2 ), quality_Q15 ),
   1452a:	425a      	negs	r2, r3
   1452c:	0092      	lsls	r2, r2, #2
   1452e:	b21b      	sxth	r3, r3
   14530:	b296      	uxth	r6, r2
   14532:	1412      	asrs	r2, r2, #16
   14534:	fb03 f606 	mul.w	r6, r3, r6
   14538:	f44f 1070 	mov.w	r0, #3932160	; 0x3c0000
   1453c:	fb03 f302 	mul.w	r3, r3, r2
   14540:	eb03 4626 	add.w	r6, r3, r6, asr #16
   14544:	f003 fa38 	bl	179b8 <silk_lin2log>
   14548:	fa1f f788 	uxth.w	r7, r8
   1454c:	1a3c      	subs	r4, r7, r0
   1454e:	f44f 1070 	mov.w	r0, #3932160	; 0x3c0000
   14552:	f003 fa31 	bl	179b8 <silk_lin2log>
   14556:	1a38      	subs	r0, r7, r0
   14558:	f500 6000 	add.w	r0, r0, #2048	; 0x800
   1455c:	f504 6400 	add.w	r4, r4, #2048	; 0x800
   14560:	b200      	sxth	r0, r0
   14562:	b2b3      	uxth	r3, r6
   14564:	fb16 f424 	smultb	r4, r6, r4
   14568:	fb03 f300 	mul.w	r3, r3, r0
   1456c:	eb04 4323 	add.w	r3, r4, r3, asr #16
            pitch_freq_log_Q7 - ( silk_lin2log( SILK_FIX_CONST( VARIABLE_HP_MIN_CUTOFF_HZ, 16 ) ) - ( 16 << 7 ) ) );

      /* delta_freq = pitch_freq_log - psEnc->variable_HP_smth1; */
      delta_freq_Q7 = pitch_freq_log_Q7 - silk_RSHIFT( psEncC1->variable_HP_smth1_Q15, 8 );
   14570:	68a9      	ldr	r1, [r5, #8]
      pitch_freq_log_Q7 = silk_SMLAWB( pitch_freq_log_Q7, silk_SMULWB( silk_LSHIFT( -quality_Q15, 2 ), quality_Q15 ),
   14572:	4443      	add	r3, r8
      if( delta_freq_Q7 < 0 ) {
   14574:	ebb3 2321 	subs.w	r3, r3, r1, asr #8
   14578:	d430      	bmi.n	145dc <silk_HP_variable_cutoff+0xec>
         /* less smoothing for decreasing pitch frequency, to track something close to the minimum */
         delta_freq_Q7 = silk_MUL( delta_freq_Q7, 3 );
      }

      /* limit delta, to reduce impact of outliers in pitch estimation */
      delta_freq_Q7 = silk_LIMIT_32( delta_freq_Q7, -SILK_FIX_CONST( VARIABLE_HP_MAX_DELTA_FREQ, 7 ), SILK_FIX_CONST( VARIABLE_HP_MAX_DELTA_FREQ, 7 ) );
   1457a:	2b33      	cmp	r3, #51	; 0x33
   1457c:	dd30      	ble.n	145e0 <silk_HP_variable_cutoff+0xf0>
   1457e:	2333      	movs	r3, #51	; 0x33

      /* update smoother */
      psEncC1->variable_HP_smth1_Q15 = silk_SMLAWB( psEncC1->variable_HP_smth1_Q15,
   14580:	f241 10b4 	movw	r0, #4532	; 0x11b4
   14584:	f641 129a 	movw	r2, #6554	; 0x199a
   14588:	5e28      	ldrsh	r0, [r5, r0]
   1458a:	fb03 f300 	mul.w	r3, r3, r0
   1458e:	b298      	uxth	r0, r3
   14590:	141b      	asrs	r3, r3, #16
   14592:	fb02 f000 	mul.w	r0, r2, r0
   14596:	fb02 f303 	mul.w	r3, r2, r3
   1459a:	eb03 4310 	add.w	r3, r3, r0, lsr #16
   1459e:	440b      	add	r3, r1
   145a0:	60ab      	str	r3, [r5, #8]
            silk_SMULBB( psEncC1->speech_activity_Q8, delta_freq_Q7 ), SILK_FIX_CONST( VARIABLE_HP_SMTH_COEF1, 16 ) );

      /* limit frequency range */
      psEncC1->variable_HP_smth1_Q15 = silk_LIMIT_32( psEncC1->variable_HP_smth1_Q15,
   145a2:	203c      	movs	r0, #60	; 0x3c
   145a4:	f003 fa08 	bl	179b8 <silk_lin2log>
   145a8:	4604      	mov	r4, r0
   145aa:	2064      	movs	r0, #100	; 0x64
   145ac:	f003 fa04 	bl	179b8 <silk_lin2log>
   145b0:	0200      	lsls	r0, r0, #8
   145b2:	ebb0 2f04 	cmp.w	r0, r4, lsl #8
   145b6:	da1e      	bge.n	145f6 <silk_HP_variable_cutoff+0x106>
   145b8:	203c      	movs	r0, #60	; 0x3c
   145ba:	68ac      	ldr	r4, [r5, #8]
   145bc:	f003 f9fc 	bl	179b8 <silk_lin2log>
   145c0:	ebb4 2f00 	cmp.w	r4, r0, lsl #8
   145c4:	dc25      	bgt.n	14612 <silk_HP_variable_cutoff+0x122>
   145c6:	2064      	movs	r0, #100	; 0x64
   145c8:	68ac      	ldr	r4, [r5, #8]
   145ca:	f003 f9f5 	bl	179b8 <silk_lin2log>
   145ce:	ebb4 2f00 	cmp.w	r4, r0, lsl #8
   145d2:	db0b      	blt.n	145ec <silk_HP_variable_cutoff+0xfc>
   145d4:	68a8      	ldr	r0, [r5, #8]
   145d6:	60a8      	str	r0, [r5, #8]
            silk_LSHIFT( silk_lin2log( VARIABLE_HP_MIN_CUTOFF_HZ ), 8 ),
            silk_LSHIFT( silk_lin2log( VARIABLE_HP_MAX_CUTOFF_HZ ), 8 ) );
   }
}
   145d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
         delta_freq_Q7 = silk_MUL( delta_freq_Q7, 3 );
   145dc:	eb03 0343 	add.w	r3, r3, r3, lsl #1
      delta_freq_Q7 = silk_LIMIT_32( delta_freq_Q7, -SILK_FIX_CONST( VARIABLE_HP_MAX_DELTA_FREQ, 7 ), SILK_FIX_CONST( VARIABLE_HP_MAX_DELTA_FREQ, 7 ) );
   145e0:	f06f 0232 	mvn.w	r2, #50	; 0x32
   145e4:	4293      	cmp	r3, r2
   145e6:	bfb8      	it	lt
   145e8:	4613      	movlt	r3, r2
   145ea:	e7c9      	b.n	14580 <silk_HP_variable_cutoff+0x90>
      psEncC1->variable_HP_smth1_Q15 = silk_LIMIT_32( psEncC1->variable_HP_smth1_Q15,
   145ec:	2064      	movs	r0, #100	; 0x64
   145ee:	f003 f9e3 	bl	179b8 <silk_lin2log>
   145f2:	0200      	lsls	r0, r0, #8
   145f4:	e7ef      	b.n	145d6 <silk_HP_variable_cutoff+0xe6>
   145f6:	2064      	movs	r0, #100	; 0x64
   145f8:	68ac      	ldr	r4, [r5, #8]
   145fa:	f003 f9dd 	bl	179b8 <silk_lin2log>
   145fe:	ebb4 2f00 	cmp.w	r4, r0, lsl #8
   14602:	dcf3      	bgt.n	145ec <silk_HP_variable_cutoff+0xfc>
   14604:	203c      	movs	r0, #60	; 0x3c
   14606:	68ac      	ldr	r4, [r5, #8]
   14608:	f003 f9d6 	bl	179b8 <silk_lin2log>
   1460c:	ebb4 2f00 	cmp.w	r4, r0, lsl #8
   14610:	dae0      	bge.n	145d4 <silk_HP_variable_cutoff+0xe4>
   14612:	203c      	movs	r0, #60	; 0x3c
   14614:	f003 f9d0 	bl	179b8 <silk_lin2log>
   14618:	0200      	lsls	r0, r0, #8
   1461a:	e7dc      	b.n	145d6 <silk_HP_variable_cutoff+0xe6>

0001461c <silk_NLSF_encode>:
    const opus_int16            *pW_Q2,                         /* I    NLSF weight vector [ LPC_ORDER ]            */
    const opus_int              NLSF_mu_Q20,                    /* I    Rate weight for the RD optimization         */
    const opus_int              nSurvivors,                     /* I    Max survivors after first stage             */
    const opus_int              signalType                      /* I    Signal type: 0/1/2                          */
)
{
   1461c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14620:	b0b5      	sub	sp, #212	; 0xd4
   14622:	4692      	mov	sl, r2
   14624:	af06      	add	r7, sp, #24
   14626:	460d      	mov	r5, r1
   14628:	6279      	str	r1, [r7, #36]	; 0x24
   1462a:	60b8      	str	r0, [r7, #8]

    celt_assert( signalType >= 0 && signalType <= 2 );
    silk_assert( NLSF_mu_Q20 <= 32767 && NLSF_mu_Q20 >= 0 );

    /* NLSF stabilization */
    silk_NLSF_stabilize( pNLSF_Q15, psNLSF_CB->deltaMin_Q15, psNLSF_CB->order );
   1462c:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
   14630:	f8da 1024 	ldr.w	r1, [sl, #36]	; 0x24
{
   14634:	617b      	str	r3, [r7, #20]
    silk_NLSF_stabilize( pNLSF_Q15, psNLSF_CB->deltaMin_Q15, psNLSF_CB->order );
   14636:	4628      	mov	r0, r5
   14638:	f004 f8a8 	bl	1878c <silk_NLSF_stabilize>

    /* First stage: VQ */
    ALLOC( err_Q24, psNLSF_CB->nVectors, opus_int32 );
   1463c:	f9ba 0000 	ldrsh.w	r0, [sl]
    silk_NLSF_VQ( err_Q24, pNLSF_Q15, psNLSF_CB->CB1_NLSF_Q8, psNLSF_CB->CB1_Wght_Q9, psNLSF_CB->nVectors, psNLSF_CB->order );
   14640:	f9ba 4002 	ldrsh.w	r4, [sl, #2]
    ALLOC( err_Q24, psNLSF_CB->nVectors, opus_int32 );
   14644:	0081      	lsls	r1, r0, #2
   14646:	310a      	adds	r1, #10
   14648:	f021 0107 	bic.w	r1, r1, #7
   1464c:	ebad 0d01 	sub.w	sp, sp, r1
    silk_NLSF_VQ( err_Q24, pNLSF_Q15, psNLSF_CB->CB1_NLSF_Q8, psNLSF_CB->CB1_Wght_Q9, psNLSF_CB->nVectors, psNLSF_CB->order );
   14650:	e9da 2302 	ldrd	r2, r3, [sl, #8]
   14654:	e9cd 0400 	strd	r0, r4, [sp]

    /* Sort the quantization errors */
    ALLOC( tempIndices1, nSurvivors, opus_int );
   14658:	f8d7 40e4 	ldr.w	r4, [r7, #228]	; 0xe4
    silk_NLSF_VQ( err_Q24, pNLSF_Q15, psNLSF_CB->CB1_NLSF_Q8, psNLSF_CB->CB1_Wght_Q9, psNLSF_CB->nVectors, psNLSF_CB->order );
   1465c:	4629      	mov	r1, r5
    ALLOC( tempIndices1, nSurvivors, opus_int );
   1465e:	00a5      	lsls	r5, r4, #2
    ALLOC( err_Q24, psNLSF_CB->nVectors, opus_int32 );
   14660:	ae06      	add	r6, sp, #24
    ALLOC( tempIndices1, nSurvivors, opus_int );
   14662:	f105 040a 	add.w	r4, r5, #10
    silk_NLSF_VQ( err_Q24, pNLSF_Q15, psNLSF_CB->CB1_NLSF_Q8, psNLSF_CB->CB1_Wght_Q9, psNLSF_CB->nVectors, psNLSF_CB->order );
   14666:	4630      	mov	r0, r6
    ALLOC( tempIndices1, nSurvivors, opus_int );
   14668:	f024 0407 	bic.w	r4, r4, #7
    silk_NLSF_VQ( err_Q24, pNLSF_Q15, psNLSF_CB->CB1_NLSF_Q8, psNLSF_CB->CB1_Wght_Q9, psNLSF_CB->nVectors, psNLSF_CB->order );
   1466c:	f000 f95c 	bl	14928 <silk_NLSF_VQ>
    ALLOC( tempIndices1, nSurvivors, opus_int );
   14670:	ebad 0d04 	sub.w	sp, sp, r4
   14674:	ab06      	add	r3, sp, #24
    silk_insertion_sort_increasing( err_Q24, tempIndices1, psNLSF_CB->nVectors, nSurvivors );
   14676:	4630      	mov	r0, r6
   14678:	4619      	mov	r1, r3
    ALLOC( tempIndices1, nSurvivors, opus_int );
   1467a:	613b      	str	r3, [r7, #16]
    silk_insertion_sort_increasing( err_Q24, tempIndices1, psNLSF_CB->nVectors, nSurvivors );
   1467c:	f9ba 2000 	ldrsh.w	r2, [sl]
   14680:	461e      	mov	r6, r3
   14682:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
   14686:	f005 fb1d 	bl	19cc4 <silk_insertion_sort_increasing>

    ALLOC( RD_Q25, nSurvivors, opus_int32 );
   1468a:	ebad 0d04 	sub.w	sp, sp, r4
    ALLOC( tempIndices2, nSurvivors * MAX_LPC_ORDER, opus_int8 );
   1468e:	f8d7 10e4 	ldr.w	r1, [r7, #228]	; 0xe4

    /* Loop over survivors */
    for( s = 0; s < nSurvivors; s++ ) {
   14692:	f8d7 00e4 	ldr.w	r0, [r7, #228]	; 0xe4
    ALLOC( tempIndices2, nSurvivors * MAX_LPC_ORDER, opus_int8 );
   14696:	466b      	mov	r3, sp
   14698:	eba3 1301 	sub.w	r3, r3, r1, lsl #4
    ALLOC( RD_Q25, nSurvivors, opus_int32 );
   1469c:	aa06      	add	r2, sp, #24
    ALLOC( tempIndices2, nSurvivors * MAX_LPC_ORDER, opus_int8 );
   1469e:	469d      	mov	sp, r3
   146a0:	a906      	add	r1, sp, #24
    for( s = 0; s < nSurvivors; s++ ) {
   146a2:	2800      	cmp	r0, #0
    ALLOC( RD_Q25, nSurvivors, opus_int32 );
   146a4:	60fa      	str	r2, [r7, #12]
    ALLOC( tempIndices2, nSurvivors * MAX_LPC_ORDER, opus_int8 );
   146a6:	6079      	str	r1, [r7, #4]
    for( s = 0; s < nSurvivors; s++ ) {
   146a8:	f340 80f5 	ble.w	14896 <silk_NLSF_encode+0x27a>
   146ac:	3d04      	subs	r5, #4
   146ae:	1970      	adds	r0, r6, r5
   146b0:	61b8      	str	r0, [r7, #24]
        /* Trellis quantizer */
        RD_Q25[ s ] = silk_NLSF_del_dec_quant( &tempIndices2[ s * MAX_LPC_ORDER ], res_Q10, W_adj_Q5, pred_Q8, ec_ix,
            psNLSF_CB->ec_Rates_Q5, psNLSF_CB->quantStepSize_Q16, psNLSF_CB->invQuantStepSize_Q6, NLSF_mu_Q20, psNLSF_CB->order );

        /* Add rate for first stage */
        iCDF_ptr = &psNLSF_CB->CB1_iCDF[ ( signalType >> 1 ) * psNLSF_CB->nVectors ];
   146b2:	f8d7 00e8 	ldr.w	r0, [r7, #232]	; 0xe8
   146b6:	f8c7 a028 	str.w	sl, [r7, #40]	; 0x28
   146ba:	1040      	asrs	r0, r0, #1
   146bc:	1f33      	subs	r3, r6, #4
   146be:	6238      	str	r0, [r7, #32]
            prob_Q8 = 256 - iCDF_ptr[ ind1 ];
        } else {
            prob_Q8 = iCDF_ptr[ ind1 - 1 ] - iCDF_ptr[ ind1 ];
        }
        bits_q7 = ( 8 << 7 ) - silk_lin2log( prob_Q8 );
        RD_Q25[ s ] = silk_SMLABB( RD_Q25[ s ], bits_q7, silk_RSHIFT( NLSF_mu_Q20, 2 ) );
   146c0:	f8d7 00e0 	ldr.w	r0, [r7, #224]	; 0xe0
   146c4:	63bb      	str	r3, [r7, #56]	; 0x38
   146c6:	1f13      	subs	r3, r2, #4
   146c8:	f340 008f 	sbfx	r0, r0, #2, #16
   146cc:	e9c7 130c 	strd	r1, r3, [r7, #48]	; 0x30
   146d0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   146d2:	61f8      	str	r0, [r7, #28]
        ind1 = tempIndices1[ s ];
   146d4:	f853 4f04 	ldr.w	r4, [r3, #4]!
   146d8:	63bb      	str	r3, [r7, #56]	; 0x38
        pCB_element = &psNLSF_CB->CB1_NLSF_Q8[ ind1 * psNLSF_CB->order ];
   146da:	6abb      	ldr	r3, [r7, #40]	; 0x28
        ind1 = tempIndices1[ s ];
   146dc:	62fc      	str	r4, [r7, #44]	; 0x2c
        pCB_element = &psNLSF_CB->CB1_NLSF_Q8[ ind1 * psNLSF_CB->order ];
   146de:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
   146e2:	6898      	ldr	r0, [r3, #8]
        pCB_Wght_Q9 = &psNLSF_CB->CB1_Wght_Q9[ ind1 * psNLSF_CB->order ];
   146e4:	68de      	ldr	r6, [r3, #12]
        for( i = 0; i < psNLSF_CB->order; i++ ) {
   146e6:	2a00      	cmp	r2, #0
        pCB_element = &psNLSF_CB->CB1_NLSF_Q8[ ind1 * psNLSF_CB->order ];
   146e8:	fb04 f302 	mul.w	r3, r4, r2
        pCB_Wght_Q9 = &psNLSF_CB->CB1_Wght_Q9[ ind1 * psNLSF_CB->order ];
   146ec:	ea4f 0143 	mov.w	r1, r3, lsl #1
        for( i = 0; i < psNLSF_CB->order; i++ ) {
   146f0:	f340 8089 	ble.w	14806 <silk_NLSF_encode+0x1ea>
   146f4:	3b01      	subs	r3, #1
   146f6:	eb00 0c03 	add.w	ip, r0, r3
   146fa:	f107 0358 	add.w	r3, r7, #88	; 0x58
   146fe:	eb03 0342 	add.w	r3, r3, r2, lsl #1
   14702:	63fb      	str	r3, [r7, #60]	; 0x3c
   14704:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   14706:	f1a3 0b02 	sub.w	fp, r3, #2
   1470a:	697b      	ldr	r3, [r7, #20]
   1470c:	3902      	subs	r1, #2
   1470e:	440e      	add	r6, r1
   14710:	f107 0558 	add.w	r5, r7, #88	; 0x58
   14714:	f1a3 0a02 	sub.w	sl, r3, #2
   14718:	f107 0e78 	add.w	lr, r7, #120	; 0x78
   1471c:	e040      	b.n	147a0 <silk_NLSF_encode+0x184>
    a_headrm = silk_CLZ32( silk_abs(a32) ) - 1;
   1471e:	ea82 79e2 	eor.w	r9, r2, r2, asr #31
   14722:	eba9 79e2 	sub.w	r9, r9, r2, asr #31
   14726:	fab9 f989 	clz	r9, r9
   1472a:	f109 33ff 	add.w	r3, r9, #4294967295	; 0xffffffff
    a32_nrm = silk_LSHIFT(a32, a_headrm);                                       /* Q: a_headrm                  */
   1472e:	409a      	lsls	r2, r3
   14730:	f109 091c 	add.w	r9, r9, #28
   14734:	2800      	cmp	r0, #0
   14736:	d04c      	beq.n	147d2 <silk_NLSF_encode+0x1b6>
   14738:	fab0 f480 	clz	r4, r0
   1473c:	3c01      	subs	r4, #1
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                  */
   1473e:	40a0      	lsls	r0, r4
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   14740:	1403      	asrs	r3, r0, #16
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   14742:	b291      	uxth	r1, r2
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   14744:	f06f 4860 	mvn.w	r8, #3758096384	; 0xe0000000
   14748:	fb98 f3f3 	sdiv	r3, r8, r3
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1474c:	ea4f 4822 	mov.w	r8, r2, asr #16
   14750:	b21b      	sxth	r3, r3
   14752:	fb03 f101 	mul.w	r1, r3, r1
   14756:	fb03 f808 	mul.w	r8, r3, r8
   1475a:	eb08 4821 	add.w	r8, r8, r1, asr #16
    a32_nrm = silk_SUB32_ovflw(a32_nrm, silk_LSHIFT_ovflw( silk_SMMUL(b32_nrm, result), 3 ));  /* Q: a_headrm   */
   1475e:	fb88 0100 	smull	r0, r1, r8, r0
   14762:	eba2 02c1 	sub.w	r2, r2, r1, lsl #3
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   14766:	b291      	uxth	r1, r2
   14768:	1412      	asrs	r2, r2, #16
   1476a:	fb03 f101 	mul.w	r1, r3, r1
   1476e:	fb03 f302 	mul.w	r3, r3, r2
    lshift = 29 + a_headrm - b_headrm - Qres;
   14772:	eba9 0404 	sub.w	r4, r9, r4
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   14776:	eb03 4321 	add.w	r3, r3, r1, asr #16
   1477a:	4443      	add	r3, r8
    if( lshift < 0 ) {
   1477c:	f1b4 0815 	subs.w	r8, r4, #21
   14780:	d429      	bmi.n	147d6 <silk_NLSF_encode+0x1ba>
        if( lshift < 32){
   14782:	f1b8 0f1f 	cmp.w	r8, #31
            return silk_RSHIFT(result, lshift);
   14786:	bfd8      	it	le
   14788:	fa43 f808 	asrle.w	r8, r3, r8
   1478c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1478e:	bfd4      	ite	le
   14790:	fa0f f888 	sxthle.w	r8, r8
        if( lshift < 32){
   14794:	f04f 0800 	movgt.w	r8, #0
   14798:	429d      	cmp	r5, r3
            W_adj_Q5[ i ] = silk_DIV32_varQ( (opus_int32)pW_Q2[ i ], silk_SMULBB( W_tmp_Q9, W_tmp_Q9 ), 21 );
   1479a:	f82e 8b02 	strh.w	r8, [lr], #2
        for( i = 0; i < psNLSF_CB->order; i++ ) {
   1479e:	d032      	beq.n	14806 <silk_NLSF_encode+0x1ea>
            NLSF_tmp_Q15[ i ] = silk_LSHIFT16( (opus_int16)pCB_element[ i ], 7 );
   147a0:	f81c 3f01 	ldrb.w	r3, [ip, #1]!
            res_Q10[ i ] = (opus_int16)silk_RSHIFT( silk_SMULBB( pNLSF_Q15[ i ] - NLSF_tmp_Q15[ i ], W_tmp_Q9 ), 14 );
   147a4:	f83b 1f02 	ldrh.w	r1, [fp, #2]!
            W_tmp_Q9 = pCB_Wght_Q9[ i ];
   147a8:	f936 0f02 	ldrsh.w	r0, [r6, #2]!
            W_adj_Q5[ i ] = silk_DIV32_varQ( (opus_int32)pW_Q2[ i ], silk_SMULBB( W_tmp_Q9, W_tmp_Q9 ), 21 );
   147ac:	f93a 2f02 	ldrsh.w	r2, [sl, #2]!
            res_Q10[ i ] = (opus_int16)silk_RSHIFT( silk_SMULBB( pNLSF_Q15[ i ] - NLSF_tmp_Q15[ i ], W_tmp_Q9 ), 14 );
   147b0:	eba1 11c3 	sub.w	r1, r1, r3, lsl #7
   147b4:	fb11 f100 	smulbb	r1, r1, r0
   147b8:	1389      	asrs	r1, r1, #14
   147ba:	f825 1b02 	strh.w	r1, [r5], #2
            W_adj_Q5[ i ] = silk_DIV32_varQ( (opus_int32)pW_Q2[ i ], silk_SMULBB( W_tmp_Q9, W_tmp_Q9 ), 21 );
   147be:	fb00 f000 	mul.w	r0, r0, r0
   147c2:	2a00      	cmp	r2, #0
   147c4:	d1ab      	bne.n	1471e <silk_NLSF_encode+0x102>
   147c6:	231f      	movs	r3, #31
   147c8:	f04f 093c 	mov.w	r9, #60	; 0x3c
    a32_nrm = silk_LSHIFT(a32, a_headrm);                                       /* Q: a_headrm                  */
   147cc:	409a      	lsls	r2, r3
   147ce:	2800      	cmp	r0, #0
   147d0:	d1b2      	bne.n	14738 <silk_NLSF_encode+0x11c>
   147d2:	241f      	movs	r4, #31
   147d4:	e7b3      	b.n	1473e <silk_NLSF_encode+0x122>
        return silk_LSHIFT_SAT32(result, -lshift);
   147d6:	f1c4 0415 	rsb	r4, r4, #21
   147da:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   147de:	fa42 f804 	asr.w	r8, r2, r4
   147e2:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
   147e6:	fa42 f904 	asr.w	r9, r2, r4
   147ea:	45c1      	cmp	r9, r8
   147ec:	da75      	bge.n	148da <silk_NLSF_encode+0x2be>
   147ee:	4598      	cmp	r8, r3
   147f0:	da77      	bge.n	148e2 <silk_NLSF_encode+0x2c6>
   147f2:	4643      	mov	r3, r8
   147f4:	fa03 f804 	lsl.w	r8, r3, r4
        for( i = 0; i < psNLSF_CB->order; i++ ) {
   147f8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   147fa:	fa0f f888 	sxth.w	r8, r8
   147fe:	429d      	cmp	r5, r3
            W_adj_Q5[ i ] = silk_DIV32_varQ( (opus_int32)pW_Q2[ i ], silk_SMULBB( W_tmp_Q9, W_tmp_Q9 ), 21 );
   14800:	f82e 8b02 	strh.w	r8, [lr], #2
        for( i = 0; i < psNLSF_CB->order; i++ ) {
   14804:	d1cc      	bne.n	147a0 <silk_NLSF_encode+0x184>
        silk_NLSF_unpack( ec_ix, pred_Q8, psNLSF_CB, ind1 );
   14806:	6abc      	ldr	r4, [r7, #40]	; 0x28
   14808:	6afe      	ldr	r6, [r7, #44]	; 0x2c
   1480a:	4622      	mov	r2, r4
   1480c:	4633      	mov	r3, r6
   1480e:	f107 0148 	add.w	r1, r7, #72	; 0x48
   14812:	f107 0098 	add.w	r0, r7, #152	; 0x98
   14816:	f000 f8d7 	bl	149c8 <silk_NLSF_unpack>
        RD_Q25[ s ] = silk_NLSF_del_dec_quant( &tempIndices2[ s * MAX_LPC_ORDER ], res_Q10, W_adj_Q5, pred_Q8, ec_ix,
   1481a:	f9b4 1006 	ldrsh.w	r1, [r4, #6]
   1481e:	f9b4 2004 	ldrsh.w	r2, [r4, #4]
   14822:	f9b4 0002 	ldrsh.w	r0, [r4, #2]
   14826:	6a23      	ldr	r3, [r4, #32]
   14828:	f8d7 50e0 	ldr.w	r5, [r7, #224]	; 0xe0
   1482c:	9504      	str	r5, [sp, #16]
   1482e:	e9cd 2102 	strd	r2, r1, [sp, #8]
   14832:	f107 0598 	add.w	r5, r7, #152	; 0x98
   14836:	9005      	str	r0, [sp, #20]
   14838:	9301      	str	r3, [sp, #4]
   1483a:	9500      	str	r5, [sp, #0]
   1483c:	6b3d      	ldr	r5, [r7, #48]	; 0x30
   1483e:	f107 0348 	add.w	r3, r7, #72	; 0x48
   14842:	f107 0278 	add.w	r2, r7, #120	; 0x78
   14846:	f107 0158 	add.w	r1, r7, #88	; 0x58
   1484a:	4628      	mov	r0, r5
   1484c:	f000 f8f6 	bl	14a3c <silk_NLSF_del_dec_quant>
        iCDF_ptr = &psNLSF_CB->CB1_iCDF[ ( signalType >> 1 ) * psNLSF_CB->nVectors ];
   14850:	f9b4 3000 	ldrsh.w	r3, [r4]
   14854:	6a39      	ldr	r1, [r7, #32]
   14856:	6922      	ldr	r2, [r4, #16]
        RD_Q25[ s ] = silk_NLSF_del_dec_quant( &tempIndices2[ s * MAX_LPC_ORDER ], res_Q10, W_adj_Q5, pred_Q8, ec_ix,
   14858:	6b7c      	ldr	r4, [r7, #52]	; 0x34
        iCDF_ptr = &psNLSF_CB->CB1_iCDF[ ( signalType >> 1 ) * psNLSF_CB->nVectors ];
   1485a:	fb01 f303 	mul.w	r3, r1, r3
        RD_Q25[ s ] = silk_NLSF_del_dec_quant( &tempIndices2[ s * MAX_LPC_ORDER ], res_Q10, W_adj_Q5, pred_Q8, ec_ix,
   1485e:	6060      	str	r0, [r4, #4]
        iCDF_ptr = &psNLSF_CB->CB1_iCDF[ ( signalType >> 1 ) * psNLSF_CB->nVectors ];
   14860:	18d1      	adds	r1, r2, r3
        if( ind1 == 0 ) {
   14862:	2e00      	cmp	r6, #0
   14864:	d145      	bne.n	148f2 <silk_NLSF_encode+0x2d6>
            prob_Q8 = 256 - iCDF_ptr[ ind1 ];
   14866:	5cd0      	ldrb	r0, [r2, r3]
        bits_q7 = ( 8 << 7 ) - silk_lin2log( prob_Q8 );
   14868:	f5c0 7080 	rsb	r0, r0, #256	; 0x100
   1486c:	f003 f8a4 	bl	179b8 <silk_lin2log>
        RD_Q25[ s ] = silk_SMLABB( RD_Q25[ s ], bits_q7, silk_RSHIFT( NLSF_mu_Q20, 2 ) );
   14870:	f854 3f04 	ldr.w	r3, [r4, #4]!
   14874:	69fa      	ldr	r2, [r7, #28]
   14876:	637c      	str	r4, [r7, #52]	; 0x34
        bits_q7 = ( 8 << 7 ) - silk_lin2log( prob_Q8 );
   14878:	f5c0 6080 	rsb	r0, r0, #1024	; 0x400
        RD_Q25[ s ] = silk_SMLABB( RD_Q25[ s ], bits_q7, silk_RSHIFT( NLSF_mu_Q20, 2 ) );
   1487c:	fb12 3000 	smlabb	r0, r2, r0, r3
   14880:	462b      	mov	r3, r5
   14882:	3310      	adds	r3, #16
   14884:	633b      	str	r3, [r7, #48]	; 0x30
    for( s = 0; s < nSurvivors; s++ ) {
   14886:	69ba      	ldr	r2, [r7, #24]
   14888:	6bbb      	ldr	r3, [r7, #56]	; 0x38
        RD_Q25[ s ] = silk_SMLABB( RD_Q25[ s ], bits_q7, silk_RSHIFT( NLSF_mu_Q20, 2 ) );
   1488a:	6020      	str	r0, [r4, #0]
    for( s = 0; s < nSurvivors; s++ ) {
   1488c:	4293      	cmp	r3, r2
   1488e:	f47f af21 	bne.w	146d4 <silk_NLSF_encode+0xb8>
   14892:	f8d7 a028 	ldr.w	sl, [r7, #40]	; 0x28
    }

    /* Find the lowest rate-distortion error */
    silk_insertion_sort_increasing( RD_Q25, &bestIndex, nSurvivors, 1 );
   14896:	68fd      	ldr	r5, [r7, #12]
   14898:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
   1489c:	f107 0144 	add.w	r1, r7, #68	; 0x44
   148a0:	4628      	mov	r0, r5
   148a2:	2301      	movs	r3, #1
   148a4:	f005 fa0e 	bl	19cc4 <silk_insertion_sort_increasing>

    NLSFIndices[ 0 ] = (opus_int8)tempIndices1[ bestIndex ];
   148a8:	68bc      	ldr	r4, [r7, #8]
   148aa:	6c79      	ldr	r1, [r7, #68]	; 0x44
   148ac:	693b      	ldr	r3, [r7, #16]
   148ae:	4620      	mov	r0, r4
   148b0:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   148b4:	f800 3b01 	strb.w	r3, [r0], #1
    silk_memcpy( &NLSFIndices[ 1 ], &tempIndices2[ bestIndex * MAX_LPC_ORDER ], psNLSF_CB->order * sizeof( opus_int8 ) );
   148b8:	687b      	ldr	r3, [r7, #4]
   148ba:	f9ba 2002 	ldrsh.w	r2, [sl, #2]
   148be:	eb03 1101 	add.w	r1, r3, r1, lsl #4
   148c2:	f7f7 fc1d 	bl	c100 <memcpy>

    /* Decode */
    silk_NLSF_decode( pNLSF_Q15, NLSFIndices, psNLSF_CB );
   148c6:	6a78      	ldr	r0, [r7, #36]	; 0x24
   148c8:	4652      	mov	r2, sl
   148ca:	4621      	mov	r1, r4
   148cc:	f7fb fb94 	bl	fff8 <silk_NLSF_decode>

    ret = RD_Q25[ 0 ];
    RESTORE_STACK;
    return ret;
}
   148d0:	6828      	ldr	r0, [r5, #0]
   148d2:	37bc      	adds	r7, #188	; 0xbc
   148d4:	46bd      	mov	sp, r7
   148d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   148da:	4599      	cmp	r9, r3
   148dc:	da05      	bge.n	148ea <silk_NLSF_encode+0x2ce>
   148de:	464b      	mov	r3, r9
   148e0:	e788      	b.n	147f4 <silk_NLSF_encode+0x1d8>
   148e2:	454b      	cmp	r3, r9
   148e4:	bfb8      	it	lt
   148e6:	464b      	movlt	r3, r9
   148e8:	e784      	b.n	147f4 <silk_NLSF_encode+0x1d8>
   148ea:	4543      	cmp	r3, r8
   148ec:	bfb8      	it	lt
   148ee:	4643      	movlt	r3, r8
   148f0:	e780      	b.n	147f4 <silk_NLSF_encode+0x1d8>
            prob_Q8 = iCDF_ptr[ ind1 - 1 ] - iCDF_ptr[ ind1 ];
   148f2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   148f4:	18ca      	adds	r2, r1, r3
   148f6:	5ccb      	ldrb	r3, [r1, r3]
   148f8:	f812 0c01 	ldrb.w	r0, [r2, #-1]
        bits_q7 = ( 8 << 7 ) - silk_lin2log( prob_Q8 );
   148fc:	1ac0      	subs	r0, r0, r3
   148fe:	f003 f85b 	bl	179b8 <silk_lin2log>
        RD_Q25[ s ] = silk_SMLABB( RD_Q25[ s ], bits_q7, silk_RSHIFT( NLSF_mu_Q20, 2 ) );
   14902:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   14904:	69f9      	ldr	r1, [r7, #28]
   14906:	f852 3f04 	ldr.w	r3, [r2, #4]!
   1490a:	637a      	str	r2, [r7, #52]	; 0x34
        bits_q7 = ( 8 << 7 ) - silk_lin2log( prob_Q8 );
   1490c:	f5c0 6080 	rsb	r0, r0, #1024	; 0x400
        RD_Q25[ s ] = silk_SMLABB( RD_Q25[ s ], bits_q7, silk_RSHIFT( NLSF_mu_Q20, 2 ) );
   14910:	fb10 3001 	smlabb	r0, r0, r1, r3
   14914:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   14916:	6010      	str	r0, [r2, #0]
   14918:	3310      	adds	r3, #16
   1491a:	633b      	str	r3, [r7, #48]	; 0x30
    for( s = 0; s < nSurvivors; s++ ) {
   1491c:	69ba      	ldr	r2, [r7, #24]
   1491e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   14920:	4293      	cmp	r3, r2
   14922:	f47f aed7 	bne.w	146d4 <silk_NLSF_encode+0xb8>
   14926:	e7b4      	b.n	14892 <silk_NLSF_encode+0x276>

00014928 <silk_NLSF_VQ>:
    const opus_uint8            pCB_Q8[],                       /* I    Codebook vectors [K*LPC_order]              */
    const opus_int16            pWght_Q9[],                     /* I    Codebook weights [K*LPC_order]              */
    const opus_int              K,                              /* I    Number of codebook vectors                  */
    const opus_int              LPC_order                       /* I    Number of LPCs                              */
)
{
   14928:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1492c:	b083      	sub	sp, #12
   1492e:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    celt_assert( ( LPC_order & 1 ) == 0 );

    /* Loop over codebook */
    cb_Q8_ptr = pCB_Q8;
    w_Q9_ptr = pWght_Q9;
    for( i = 0; i < K; i++ ) {
   14930:	2c00      	cmp	r4, #0
   14932:	dd44      	ble.n	149be <silk_NLSF_VQ+0x96>

            silk_assert( sum_error_Q24 >= 0 );
        }
        err_Q24[ i ] = sum_error_Q24;
        cb_Q8_ptr += LPC_order;
        w_Q9_ptr += LPC_order;
   14934:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   14936:	3804      	subs	r0, #4
   14938:	eb00 0484 	add.w	r4, r0, r4, lsl #2
   1493c:	ea4f 0b45 	mov.w	fp, r5, lsl #1
   14940:	9400      	str	r4, [sp, #0]
   14942:	f1ab 0402 	sub.w	r4, fp, #2
   14946:	442a      	add	r2, r5
   14948:	9401      	str	r4, [sp, #4]
        for( m = LPC_order-2; m >= 0; m -= 2 ) {
   1494a:	f1a5 0a02 	sub.w	sl, r5, #2
   1494e:	f1ba 0f00 	cmp.w	sl, #0
   14952:	db37      	blt.n	149c4 <silk_NLSF_VQ+0x9c>
        pred_Q24 = 0;
   14954:	f04f 0800 	mov.w	r8, #0
        for( m = LPC_order-2; m >= 0; m -= 2 ) {
   14958:	f8dd e004 	ldr.w	lr, [sp, #4]
        sum_error_Q24 = 0;
   1495c:	4645      	mov	r5, r8
        for( m = LPC_order-2; m >= 0; m -= 2 ) {
   1495e:	4691      	mov	r9, r2
   14960:	46d4      	mov	ip, sl
            diff_Q15 = silk_SUB_LSHIFT32( in_Q15[ m + 1 ], (opus_int32)cb_Q8_ptr[ m + 1 ], 7 ); /* range: [ -32767 : 32767 ]*/
   14962:	f819 7c01 	ldrb.w	r7, [r9, #-1]
   14966:	f931 400e 	ldrsh.w	r4, [r1, lr]
            diff_Q15 = silk_SUB_LSHIFT32( in_Q15[ m ], (opus_int32)cb_Q8_ptr[ m ], 7 ); /* range: [ -32767 : 32767 ]*/
   1496a:	f931 601c 	ldrsh.w	r6, [r1, ip, lsl #1]
            diff_Q15 = silk_SUB_LSHIFT32( in_Q15[ m + 1 ], (opus_int32)cb_Q8_ptr[ m + 1 ], 7 ); /* range: [ -32767 : 32767 ]*/
   1496e:	eba4 14c7 	sub.w	r4, r4, r7, lsl #7
            diffw_Q24 = silk_SMULBB( diff_Q15, w_Q9_ptr[ m + 1 ] );
   14972:	f833 700e 	ldrh.w	r7, [r3, lr]
   14976:	fb17 f404 	smulbb	r4, r7, r4
            diff_Q15 = silk_SUB_LSHIFT32( in_Q15[ m ], (opus_int32)cb_Q8_ptr[ m ], 7 ); /* range: [ -32767 : 32767 ]*/
   1497a:	f819 7d02 	ldrb.w	r7, [r9, #-2]!
   1497e:	eba6 16c7 	sub.w	r6, r6, r7, lsl #7
            sum_error_Q24 = silk_ADD32( sum_error_Q24, silk_abs( silk_SUB_RSHIFT32( diffw_Q24, pred_Q24, 1 ) ) );
   14982:	eba4 0768 	sub.w	r7, r4, r8, asr #1
            diffw_Q24 = silk_SMULBB( diff_Q15, w_Q9_ptr[ m ] );
   14986:	f833 801c 	ldrh.w	r8, [r3, ip, lsl #1]
            sum_error_Q24 = silk_ADD32( sum_error_Q24, silk_abs( silk_SUB_RSHIFT32( diffw_Q24, pred_Q24, 1 ) ) );
   1498a:	2f00      	cmp	r7, #0
            diffw_Q24 = silk_SMULBB( diff_Q15, w_Q9_ptr[ m ] );
   1498c:	fb18 f806 	smulbb	r8, r8, r6
            sum_error_Q24 = silk_ADD32( sum_error_Q24, silk_abs( silk_SUB_RSHIFT32( diffw_Q24, pred_Q24, 1 ) ) );
   14990:	bfb8      	it	lt
   14992:	427f      	neglt	r7, r7
            sum_error_Q24 = silk_ADD32( sum_error_Q24, silk_abs( silk_SUB_RSHIFT32( diffw_Q24, pred_Q24, 1 ) ) );
   14994:	eba8 0464 	sub.w	r4, r8, r4, asr #1
            sum_error_Q24 = silk_ADD32( sum_error_Q24, silk_abs( silk_SUB_RSHIFT32( diffw_Q24, pred_Q24, 1 ) ) );
   14998:	442f      	add	r7, r5
            sum_error_Q24 = silk_ADD32( sum_error_Q24, silk_abs( silk_SUB_RSHIFT32( diffw_Q24, pred_Q24, 1 ) ) );
   1499a:	ea84 75e4 	eor.w	r5, r4, r4, asr #31
   1499e:	eba5 75e4 	sub.w	r5, r5, r4, asr #31
        for( m = LPC_order-2; m >= 0; m -= 2 ) {
   149a2:	f1bc 0c02 	subs.w	ip, ip, #2
   149a6:	f1ae 0e04 	sub.w	lr, lr, #4
            sum_error_Q24 = silk_ADD32( sum_error_Q24, silk_abs( silk_SUB_RSHIFT32( diffw_Q24, pred_Q24, 1 ) ) );
   149aa:	443d      	add	r5, r7
        for( m = LPC_order-2; m >= 0; m -= 2 ) {
   149ac:	d5d9      	bpl.n	14962 <silk_NLSF_VQ+0x3a>
   149ae:	9c0d      	ldr	r4, [sp, #52]	; 0x34
        err_Q24[ i ] = sum_error_Q24;
   149b0:	f840 5f04 	str.w	r5, [r0, #4]!
   149b4:	4422      	add	r2, r4
    for( i = 0; i < K; i++ ) {
   149b6:	9c00      	ldr	r4, [sp, #0]
   149b8:	4284      	cmp	r4, r0
        w_Q9_ptr += LPC_order;
   149ba:	445b      	add	r3, fp
    for( i = 0; i < K; i++ ) {
   149bc:	d1c7      	bne.n	1494e <silk_NLSF_VQ+0x26>
    }
}
   149be:	b003      	add	sp, #12
   149c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        sum_error_Q24 = 0;
   149c4:	2500      	movs	r5, #0
   149c6:	e7f2      	b.n	149ae <silk_NLSF_VQ+0x86>

000149c8 <silk_NLSF_unpack>:
          opus_int16            ec_ix[],                        /* O    Indices to entropy tables [ LPC_ORDER ]     */
          opus_uint8            pred_Q8[],                      /* O    LSF predictor [ LPC_ORDER ]                 */
    const silk_NLSF_CB_struct   *psNLSF_CB,                     /* I    Codebook object                             */
    const opus_int              CB1_index                       /* I    Index of vector in first LSF codebook       */
)
{
   149c8:	b5f0      	push	{r4, r5, r6, r7, lr}
    opus_int   i;
    opus_uint8 entry;
    const opus_uint8 *ec_sel_ptr;

    ec_sel_ptr = &psNLSF_CB->ec_sel[ CB1_index * psNLSF_CB->order / 2 ];
   149ca:	f9b2 5002 	ldrsh.w	r5, [r2, #2]
   149ce:	6994      	ldr	r4, [r2, #24]
   149d0:	fb03 f305 	mul.w	r3, r3, r5
   149d4:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
    for( i = 0; i < psNLSF_CB->order; i += 2 ) {
   149d8:	2d00      	cmp	r5, #0
    ec_sel_ptr = &psNLSF_CB->ec_sel[ CB1_index * psNLSF_CB->order / 2 ];
   149da:	eb04 0c63 	add.w	ip, r4, r3, asr #1
    for( i = 0; i < psNLSF_CB->order; i += 2 ) {
   149de:	dd2b      	ble.n	14a38 <silk_NLSF_unpack+0x70>
   149e0:	4607      	mov	r7, r0
   149e2:	2400      	movs	r4, #0
        entry = *ec_sel_ptr++;
   149e4:	f81c 3b01 	ldrb.w	r3, [ip], #1
        ec_ix  [ i     ] = silk_SMULBB( silk_RSHIFT( entry, 1 ) & 7, 2 * NLSF_QUANT_MAX_AMPLITUDE + 1 );
        pred_Q8[ i     ] = psNLSF_CB->pred_Q8[ i + ( entry & 1 ) * ( psNLSF_CB->order - 1 ) ];
   149e8:	f8d2 e014 	ldr.w	lr, [r2, #20]
        ec_ix  [ i     ] = silk_SMULBB( silk_RSHIFT( entry, 1 ) & 7, 2 * NLSF_QUANT_MAX_AMPLITUDE + 1 );
   149ec:	f3c3 0642 	ubfx	r6, r3, #1, #3
   149f0:	eb06 06c6 	add.w	r6, r6, r6, lsl #3
   149f4:	f820 6014 	strh.w	r6, [r0, r4, lsl #1]
        pred_Q8[ i     ] = psNLSF_CB->pred_Q8[ i + ( entry & 1 ) * ( psNLSF_CB->order - 1 ) ];
   149f8:	f9b2 5002 	ldrsh.w	r5, [r2, #2]
   149fc:	f003 0601 	and.w	r6, r3, #1
   14a00:	3d01      	subs	r5, #1
   14a02:	fb06 e505 	mla	r5, r6, r5, lr
        ec_ix  [ i + 1 ] = silk_SMULBB( silk_RSHIFT( entry, 5 ) & 7, 2 * NLSF_QUANT_MAX_AMPLITUDE + 1 );
   14a06:	095e      	lsrs	r6, r3, #5
        pred_Q8[ i     ] = psNLSF_CB->pred_Q8[ i + ( entry & 1 ) * ( psNLSF_CB->order - 1 ) ];
   14a08:	5d2d      	ldrb	r5, [r5, r4]
   14a0a:	550d      	strb	r5, [r1, r4]
        ec_ix  [ i + 1 ] = silk_SMULBB( silk_RSHIFT( entry, 5 ) & 7, 2 * NLSF_QUANT_MAX_AMPLITUDE + 1 );
   14a0c:	eb06 06c6 	add.w	r6, r6, r6, lsl #3
   14a10:	807e      	strh	r6, [r7, #2]
        pred_Q8[ i + 1 ] = psNLSF_CB->pred_Q8[ i + ( silk_RSHIFT( entry, 4 ) & 1 ) * ( psNLSF_CB->order - 1 ) + 1 ];
   14a12:	f9b2 6002 	ldrsh.w	r6, [r2, #2]
   14a16:	6955      	ldr	r5, [r2, #20]
   14a18:	f3c3 1300 	ubfx	r3, r3, #4, #1
   14a1c:	4425      	add	r5, r4
   14a1e:	3e01      	subs	r6, #1
   14a20:	fb06 5303 	mla	r3, r6, r3, r5
   14a24:	190d      	adds	r5, r1, r4
   14a26:	785b      	ldrb	r3, [r3, #1]
   14a28:	706b      	strb	r3, [r5, #1]
    for( i = 0; i < psNLSF_CB->order; i += 2 ) {
   14a2a:	f9b2 3002 	ldrsh.w	r3, [r2, #2]
   14a2e:	3402      	adds	r4, #2
   14a30:	42a3      	cmp	r3, r4
   14a32:	f107 0704 	add.w	r7, r7, #4
   14a36:	dcd5      	bgt.n	149e4 <silk_NLSF_unpack+0x1c>
    }
}
   14a38:	bdf0      	pop	{r4, r5, r6, r7, pc}
   14a3a:	bf00      	nop

00014a3c <silk_NLSF_del_dec_quant>:
    const opus_int              quant_step_size_Q16,            /* I    Quantization step size                      */
    const opus_int16            inv_quant_step_size_Q6,         /* I    Inverse quantization step size              */
    const opus_int32            mu_Q20,                         /* I    R/D tradeoff                                */
    const opus_int16            order                           /* I    Number of input values                      */
)
{
   14a3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14a40:	b0df      	sub	sp, #380	; 0x17c
   14a42:	f64d 0466 	movw	r4, #55398	; 0xd866
   14a46:	900d      	str	r0, [sp, #52]	; 0x34
   14a48:	f9bd 01ac 	ldrsh.w	r0, [sp, #428]	; 0x1ac
   14a4c:	9005      	str	r0, [sp, #20]
   14a4e:	f9bd 01b4 	ldrsh.w	r0, [sp, #436]	; 0x1b4
   14a52:	900c      	str	r0, [sp, #48]	; 0x30
   14a54:	f9bd e1a8 	ldrsh.w	lr, [sp, #424]	; 0x1a8
   14a58:	f06f 0c08 	mvn.w	ip, #8
   14a5c:	f06f 0709 	mvn.w	r7, #9
   14a60:	2600      	movs	r6, #0
   14a62:	f10d 0ad8 	add.w	sl, sp, #216	; 0xd8
   14a66:	f50d 7994 	add.w	r9, sp, #296	; 0x128
   14a6a:	e01b      	b.n	14aa4 <silk_NLSF_del_dec_quant+0x68>
        out0_Q10 = silk_LSHIFT( i, 10 );
        out1_Q10 = silk_ADD16( out0_Q10, 1024 );
        if( i > 0 ) {
            out0_Q10 = silk_SUB16( out0_Q10, SILK_FIX_CONST( NLSF_QUANT_LEVEL_ADJ, 10 ) );
            out1_Q10 = silk_SUB16( out1_Q10, SILK_FIX_CONST( NLSF_QUANT_LEVEL_ADJ, 10 ) );
        } else if( i == 0 ) {
   14a6c:	f000 8371 	beq.w	15152 <silk_NLSF_del_dec_quant+0x716>
            out1_Q10 = silk_SUB16( out1_Q10, SILK_FIX_CONST( NLSF_QUANT_LEVEL_ADJ, 10 ) );
        } else if( i == -1 ) {
   14a70:	1c78      	adds	r0, r7, #1
   14a72:	f000 8383 	beq.w	1517c <silk_NLSF_del_dec_quant+0x740>
   14a76:	f504 6080 	add.w	r0, r4, #1024	; 0x400
   14a7a:	b200      	sxth	r0, r0
            out0_Q10 = silk_ADD16( out0_Q10, SILK_FIX_CONST( NLSF_QUANT_LEVEL_ADJ, 10 ) );
        } else {
            out0_Q10 = silk_ADD16( out0_Q10, SILK_FIX_CONST( NLSF_QUANT_LEVEL_ADJ, 10 ) );
            out1_Q10 = silk_ADD16( out1_Q10, SILK_FIX_CONST( NLSF_QUANT_LEVEL_ADJ, 10 ) );
        }
        out0_Q10_table[ i + NLSF_QUANT_MAX_AMPLITUDE_EXT ] = silk_RSHIFT( silk_SMULBB( out0_Q10, quant_step_size_Q16 ), 16 );
   14a7c:	fb05 f50e 	mul.w	r5, r5, lr
        out1_Q10_table[ i + NLSF_QUANT_MAX_AMPLITUDE_EXT ] = silk_RSHIFT( silk_SMULBB( out1_Q10, quant_step_size_Q16 ), 16 );
   14a80:	fb00 f00e 	mul.w	r0, r0, lr
        out0_Q10_table[ i + NLSF_QUANT_MAX_AMPLITUDE_EXT ] = silk_RSHIFT( silk_SMULBB( out0_Q10, quant_step_size_Q16 ), 16 );
   14a84:	142d      	asrs	r5, r5, #16
        out1_Q10_table[ i + NLSF_QUANT_MAX_AMPLITUDE_EXT ] = silk_RSHIFT( silk_SMULBB( out1_Q10, quant_step_size_Q16 ), 16 );
   14a86:	1400      	asrs	r0, r0, #16
    for (i = -NLSF_QUANT_MAX_AMPLITUDE_EXT; i <= NLSF_QUANT_MAX_AMPLITUDE_EXT-1; i++)
   14a88:	f1bc 0f0a 	cmp.w	ip, #10
        out0_Q10_table[ i + NLSF_QUANT_MAX_AMPLITUDE_EXT ] = silk_RSHIFT( silk_SMULBB( out0_Q10, quant_step_size_Q16 ), 16 );
   14a8c:	f84a 5026 	str.w	r5, [sl, r6, lsl #2]
        out1_Q10_table[ i + NLSF_QUANT_MAX_AMPLITUDE_EXT ] = silk_RSHIFT( silk_SMULBB( out1_Q10, quant_step_size_Q16 ), 16 );
   14a90:	f849 0026 	str.w	r0, [r9, r6, lsl #2]
    for (i = -NLSF_QUANT_MAX_AMPLITUDE_EXT; i <= NLSF_QUANT_MAX_AMPLITUDE_EXT-1; i++)
   14a94:	d011      	beq.n	14aba <silk_NLSF_del_dec_quant+0x7e>
   14a96:	f504 6480 	add.w	r4, r4, #1024	; 0x400
   14a9a:	b2a4      	uxth	r4, r4
   14a9c:	3601      	adds	r6, #1
   14a9e:	3701      	adds	r7, #1
   14aa0:	f10c 0c01 	add.w	ip, ip, #1
        if( i > 0 ) {
   14aa4:	2f00      	cmp	r7, #0
   14aa6:	b225      	sxth	r5, r4
   14aa8:	f1a4 08cc 	sub.w	r8, r4, #204	; 0xcc
   14aac:	f504 704d 	add.w	r0, r4, #820	; 0x334
   14ab0:	dddc      	ble.n	14a6c <silk_NLSF_del_dec_quant+0x30>
   14ab2:	fa0f f588 	sxth.w	r5, r8
   14ab6:	b200      	sxth	r0, r0
   14ab8:	e7e0      	b.n	14a7c <silk_NLSF_del_dec_quant+0x40>
    silk_assert( (NLSF_QUANT_DEL_DEC_STATES & (NLSF_QUANT_DEL_DEC_STATES-1)) == 0 );     /* must be power of two */

    nStates = 1;
    RD_Q25[ 0 ] = 0;
    prev_out_Q10[ 0 ] = 0;
    for( i = order - 1; i >= 0; i-- ) {
   14aba:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    RD_Q25[ 0 ] = 0;
   14abc:	2000      	movs	r0, #0
    prev_out_Q10[ 0 ] = 0;
   14abe:	f10d 0b48 	add.w	fp, sp, #72	; 0x48
    for( i = order - 1; i >= 0; i-- ) {
   14ac2:	4285      	cmp	r5, r0
    RD_Q25[ 0 ] = 0;
   14ac4:	901e      	str	r0, [sp, #120]	; 0x78
    prev_out_Q10[ 0 ] = 0;
   14ac6:	f8ab 0000 	strh.w	r0, [fp]
    for( i = order - 1; i >= 0; i-- ) {
   14aca:	f340 8224 	ble.w	14f16 <silk_NLSF_del_dec_quant+0x4da>
   14ace:	006c      	lsls	r4, r5, #1
   14ad0:	4422      	add	r2, r4
   14ad2:	920a      	str	r2, [sp, #40]	; 0x28
   14ad4:	9a68      	ldr	r2, [sp, #416]	; 0x1a0
                min_max_Q25 = silk_int32_MAX;
                max_min_Q25 = 0;
                ind_min_max = 0;
                ind_max_min = 0;
                for( j = 0; j < NLSF_QUANT_DEL_DEC_STATES; j++ ) {
                    if( min_max_Q25 > RD_max_Q25[ j ] ) {
   14ad6:	9004      	str	r0, [sp, #16]
   14ad8:	442b      	add	r3, r5
   14ada:	9309      	str	r3, [sp, #36]	; 0x24
   14adc:	1913      	adds	r3, r2, r4
   14ade:	9307      	str	r3, [sp, #28]
   14ae0:	ab26      	add	r3, sp, #152	; 0x98
   14ae2:	442b      	add	r3, r5
   14ae4:	9302      	str	r3, [sp, #8]
   14ae6:	ab26      	add	r3, sp, #152	; 0x98
   14ae8:	43db      	mvns	r3, r3
   14aea:	930b      	str	r3, [sp, #44]	; 0x2c
   14aec:	9b6c      	ldr	r3, [sp, #432]	; 0x1b0
   14aee:	b21b      	sxth	r3, r3
   14af0:	4421      	add	r1, r4
   14af2:	9306      	str	r3, [sp, #24]
    nStates = 1;
   14af4:	2301      	movs	r3, #1
   14af6:	9108      	str	r1, [sp, #32]
   14af8:	9303      	str	r3, [sp, #12]
   14afa:	9b09      	ldr	r3, [sp, #36]	; 0x24
   14afc:	980b      	ldr	r0, [sp, #44]	; 0x2c
   14afe:	3b01      	subs	r3, #1
   14b00:	461a      	mov	r2, r3
   14b02:	9309      	str	r3, [sp, #36]	; 0x24
            pred_Q10 = silk_RSHIFT( silk_SMULBB( (opus_int16)pred_coef_Q8[ i ], prev_out_Q10[ j ] ), 8 );
   14b04:	f892 c000 	ldrb.w	ip, [r2]
        in_Q10 = x_Q10[ i ];
   14b08:	9a08      	ldr	r2, [sp, #32]
            pred_Q10 = silk_RSHIFT( silk_SMULBB( (opus_int16)pred_coef_Q8[ i ], prev_out_Q10[ j ] ), 8 );
   14b0a:	f8bb 3000 	ldrh.w	r3, [fp]
        in_Q10 = x_Q10[ i ];
   14b0e:	f932 1d02 	ldrsh.w	r1, [r2, #-2]!
   14b12:	9208      	str	r2, [sp, #32]
        rates_Q5 = &ec_rates_Q5[ ec_ix[ i ] ];
   14b14:	9a07      	ldr	r2, [sp, #28]
            res_Q10  = silk_SUB16( in_Q10, pred_Q10 );
   14b16:	9101      	str	r1, [sp, #4]
        rates_Q5 = &ec_rates_Q5[ ec_ix[ i ] ];
   14b18:	f932 ed02 	ldrsh.w	lr, [r2, #-2]!
   14b1c:	9207      	str	r2, [sp, #28]
            RD_Q25[ j ]           = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate0_Q5 );
   14b1e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
            pred_Q10 = silk_RSHIFT( silk_SMULBB( (opus_int16)pred_coef_Q8[ i ], prev_out_Q10[ j ] ), 8 );
   14b20:	fb13 f30c 	smulbb	r3, r3, ip
            RD_Q25[ j ]           = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate0_Q5 );
   14b24:	f932 4d02 	ldrsh.w	r4, [r2, #-2]!
   14b28:	920a      	str	r2, [sp, #40]	; 0x28
            pred_Q10 = silk_RSHIFT( silk_SMULBB( (opus_int16)pred_coef_Q8[ i ], prev_out_Q10[ j ] ), 8 );
   14b2a:	121b      	asrs	r3, r3, #8
            ind_tmp  = silk_RSHIFT( silk_SMULBB( inv_quant_step_size_Q6, res_Q10 ), 16 );
   14b2c:	9a05      	ldr	r2, [sp, #20]
            res_Q10  = silk_SUB16( in_Q10, pred_Q10 );
   14b2e:	1ace      	subs	r6, r1, r3
            ind_tmp  = silk_RSHIFT( silk_SMULBB( inv_quant_step_size_Q6, res_Q10 ), 16 );
   14b30:	fb16 f602 	smulbb	r6, r6, r2
            ind_tmp  = silk_LIMIT( ind_tmp, -NLSF_QUANT_MAX_AMPLITUDE_EXT, NLSF_QUANT_MAX_AMPLITUDE_EXT-1 );
   14b34:	f06f 0109 	mvn.w	r1, #9
            ind_tmp  = silk_RSHIFT( silk_SMULBB( inv_quant_step_size_Q6, res_Q10 ), 16 );
   14b38:	1436      	asrs	r6, r6, #16
            ind_tmp  = silk_LIMIT( ind_tmp, -NLSF_QUANT_MAX_AMPLITUDE_EXT, NLSF_QUANT_MAX_AMPLITUDE_EXT-1 );
   14b3a:	42b1      	cmp	r1, r6
   14b3c:	bfb8      	it	lt
   14b3e:	4631      	movlt	r1, r6
   14b40:	2909      	cmp	r1, #9
   14b42:	bfa8      	it	ge
   14b44:	2109      	movge	r1, #9
            out0_Q10 = out0_Q10_table[ ind_tmp + NLSF_QUANT_MAX_AMPLITUDE_EXT ];
   14b46:	aa5e      	add	r2, sp, #376	; 0x178
   14b48:	f101 050a 	add.w	r5, r1, #10
   14b4c:	eb02 0585 	add.w	r5, r2, r5, lsl #2
            out0_Q10  = silk_ADD16( out0_Q10, pred_Q10 );
   14b50:	b29b      	uxth	r3, r3
   14b52:	f855 2ca0 	ldr.w	r2, [r5, #-160]
            out1_Q10  = silk_ADD16( out1_Q10, pred_Q10 );
   14b56:	f855 5c50 	ldr.w	r5, [r5, #-80]
            out0_Q10  = silk_ADD16( out0_Q10, pred_Q10 );
   14b5a:	441a      	add	r2, r3
            out1_Q10  = silk_ADD16( out1_Q10, pred_Q10 );
   14b5c:	442b      	add	r3, r5
   14b5e:	9d02      	ldr	r5, [sp, #8]
   14b60:	eb00 0a05 	add.w	sl, r0, r5
            prev_out_Q10[ j + nStates ] = out1_Q10;
   14b64:	9803      	ldr	r0, [sp, #12]
            ind[ j ][ i ] = (opus_int8)ind_tmp;
   14b66:	f805 1d01 	strb.w	r1, [r5, #-1]!
            out0_Q10  = silk_ADD16( out0_Q10, pred_Q10 );
   14b6a:	b292      	uxth	r2, r2
            out1_Q10  = silk_ADD16( out1_Q10, pred_Q10 );
   14b6c:	b29b      	uxth	r3, r3
            prev_out_Q10[ j           ] = out0_Q10;
   14b6e:	f8ab 2000 	strh.w	r2, [fp]
            prev_out_Q10[ j + nStates ] = out1_Q10;
   14b72:	f82b 3010 	strh.w	r3, [fp, r0, lsl #1]
        rates_Q5 = &ec_rates_Q5[ ec_ix[ i ] ];
   14b76:	9869      	ldr	r0, [sp, #420]	; 0x1a4
            ind[ j ][ i ] = (opus_int8)ind_tmp;
   14b78:	9502      	str	r5, [sp, #8]
            if( ind_tmp + 1 >= NLSF_QUANT_MAX_AMPLITUDE ) {
   14b7a:	2e02      	cmp	r6, #2
   14b7c:	f8bd 5004 	ldrh.w	r5, [sp, #4]
        rates_Q5 = &ec_rates_Q5[ ec_ix[ i ] ];
   14b80:	eb00 090e 	add.w	r9, r0, lr
            if( ind_tmp + 1 >= NLSF_QUANT_MAX_AMPLITUDE ) {
   14b84:	f300 8204 	bgt.w	14f90 <silk_NLSF_del_dec_quant+0x554>
            } else if( ind_tmp <= -NLSF_QUANT_MAX_AMPLITUDE ) {
   14b88:	1cf7      	adds	r7, r6, #3
   14b8a:	f2c0 8277 	blt.w	1507c <silk_NLSF_del_dec_quant+0x640>
                rate0_Q5 = rates_Q5[ ind_tmp +     NLSF_QUANT_MAX_AMPLITUDE ];
   14b8e:	eb09 0601 	add.w	r6, r9, r1
   14b92:	f896 e004 	ldrb.w	lr, [r6, #4]
                rate1_Q5 = rates_Q5[ ind_tmp + 1 + NLSF_QUANT_MAX_AMPLITUDE ];
   14b96:	7976      	ldrb	r6, [r6, #5]
            RD_tmp_Q25            = RD_Q25[ j ];
   14b98:	f8dd 8078 	ldr.w	r8, [sp, #120]	; 0x78
            RD_Q25[ j ]           = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate0_Q5 );
   14b9c:	9f06      	ldr	r7, [sp, #24]
   14b9e:	1aaa      	subs	r2, r5, r2
            RD_Q25[ j + nStates ] = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate1_Q5 );
   14ba0:	1aeb      	subs	r3, r5, r3
            RD_Q25[ j ]           = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate0_Q5 );
   14ba2:	fb12 f202 	smulbb	r2, r2, r2
            RD_Q25[ j + nStates ] = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate1_Q5 );
   14ba6:	fb13 f303 	smulbb	r3, r3, r3
            RD_Q25[ j ]           = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate0_Q5 );
   14baa:	fb04 8202 	mla	r2, r4, r2, r8
            RD_Q25[ j + nStates ] = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate1_Q5 );
   14bae:	fb04 8303 	mla	r3, r4, r3, r8
            RD_Q25[ j ]           = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate0_Q5 );
   14bb2:	fb07 220e 	mla	r2, r7, lr, r2
            RD_Q25[ j + nStates ] = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate1_Q5 );
   14bb6:	fb07 3306 	mla	r3, r7, r6, r3
   14bba:	9f03      	ldr	r7, [sp, #12]
            RD_Q25[ j ]           = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate0_Q5 );
   14bbc:	921e      	str	r2, [sp, #120]	; 0x78
            RD_Q25[ j + nStates ] = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate1_Q5 );
   14bbe:	a81e      	add	r0, sp, #120	; 0x78
        for( j = 0; j < nStates; j++ ) {
   14bc0:	2f01      	cmp	r7, #1
            RD_Q25[ j + nStates ] = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate1_Q5 );
   14bc2:	f840 3027 	str.w	r3, [r0, r7, lsl #2]
        for( j = 0; j < nStates; j++ ) {
   14bc6:	f000 8263 	beq.w	15090 <silk_NLSF_del_dec_quant+0x654>
            pred_Q10 = silk_RSHIFT( silk_SMULBB( (opus_int16)pred_coef_Q8[ i ], prev_out_Q10[ j ] ), 8 );
   14bca:	f8bb 3002 	ldrh.w	r3, [fp, #2]
            res_Q10  = silk_SUB16( in_Q10, pred_Q10 );
   14bce:	9a01      	ldr	r2, [sp, #4]
            ind[ j ][ i ] = (opus_int8)ind_tmp;
   14bd0:	9802      	ldr	r0, [sp, #8]
            pred_Q10 = silk_RSHIFT( silk_SMULBB( (opus_int16)pred_coef_Q8[ i ], prev_out_Q10[ j ] ), 8 );
   14bd2:	fb13 f30c 	smulbb	r3, r3, ip
   14bd6:	121b      	asrs	r3, r3, #8
            res_Q10  = silk_SUB16( in_Q10, pred_Q10 );
   14bd8:	eba2 0e03 	sub.w	lr, r2, r3
            ind_tmp  = silk_RSHIFT( silk_SMULBB( inv_quant_step_size_Q6, res_Q10 ), 16 );
   14bdc:	9a05      	ldr	r2, [sp, #20]
   14bde:	fb1e fe02 	smulbb	lr, lr, r2
            ind_tmp  = silk_LIMIT( ind_tmp, -NLSF_QUANT_MAX_AMPLITUDE_EXT, NLSF_QUANT_MAX_AMPLITUDE_EXT-1 );
   14be2:	f06f 0609 	mvn.w	r6, #9
            ind_tmp  = silk_RSHIFT( silk_SMULBB( inv_quant_step_size_Q6, res_Q10 ), 16 );
   14be6:	ea4f 4e2e 	mov.w	lr, lr, asr #16
            ind_tmp  = silk_LIMIT( ind_tmp, -NLSF_QUANT_MAX_AMPLITUDE_EXT, NLSF_QUANT_MAX_AMPLITUDE_EXT-1 );
   14bea:	4576      	cmp	r6, lr
   14bec:	bfb8      	it	lt
   14bee:	4676      	movlt	r6, lr
   14bf0:	2e09      	cmp	r6, #9
   14bf2:	bfa8      	it	ge
   14bf4:	2609      	movge	r6, #9
            out0_Q10 = out0_Q10_table[ ind_tmp + NLSF_QUANT_MAX_AMPLITUDE_EXT ];
   14bf6:	aa5e      	add	r2, sp, #376	; 0x178
   14bf8:	f106 080a 	add.w	r8, r6, #10
   14bfc:	eb02 0888 	add.w	r8, r2, r8, lsl #2
            out0_Q10  = silk_ADD16( out0_Q10, pred_Q10 );
   14c00:	b29b      	uxth	r3, r3
   14c02:	f858 2ca0 	ldr.w	r2, [r8, #-160]
            out1_Q10  = silk_ADD16( out1_Q10, pred_Q10 );
   14c06:	f858 8c50 	ldr.w	r8, [r8, #-80]
            ind[ j ][ i ] = (opus_int8)ind_tmp;
   14c0a:	7406      	strb	r6, [r0, #16]
            out0_Q10  = silk_ADD16( out0_Q10, pred_Q10 );
   14c0c:	441a      	add	r2, r3
            out1_Q10  = silk_ADD16( out1_Q10, pred_Q10 );
   14c0e:	4443      	add	r3, r8
            prev_out_Q10[ j + nStates ] = out1_Q10;
   14c10:	f107 0801 	add.w	r8, r7, #1
            out0_Q10  = silk_ADD16( out0_Q10, pred_Q10 );
   14c14:	b292      	uxth	r2, r2
            out1_Q10  = silk_ADD16( out1_Q10, pred_Q10 );
   14c16:	b29b      	uxth	r3, r3
            if( ind_tmp + 1 >= NLSF_QUANT_MAX_AMPLITUDE ) {
   14c18:	f1be 0f02 	cmp.w	lr, #2
            prev_out_Q10[ j           ] = out0_Q10;
   14c1c:	f8ab 2002 	strh.w	r2, [fp, #2]
            prev_out_Q10[ j + nStates ] = out1_Q10;
   14c20:	f82b 3018 	strh.w	r3, [fp, r8, lsl #1]
            if( ind_tmp + 1 >= NLSF_QUANT_MAX_AMPLITUDE ) {
   14c24:	f300 81be 	bgt.w	14fa4 <silk_NLSF_del_dec_quant+0x568>
            } else if( ind_tmp <= -NLSF_QUANT_MAX_AMPLITUDE ) {
   14c28:	f11e 0f03 	cmn.w	lr, #3
   14c2c:	f2c0 824f 	blt.w	150ce <silk_NLSF_del_dec_quant+0x692>
                rate0_Q5 = rates_Q5[ ind_tmp +     NLSF_QUANT_MAX_AMPLITUDE ];
   14c30:	444e      	add	r6, r9
   14c32:	f896 e004 	ldrb.w	lr, [r6, #4]
                rate1_Q5 = rates_Q5[ ind_tmp + 1 + NLSF_QUANT_MAX_AMPLITUDE ];
   14c36:	7976      	ldrb	r6, [r6, #5]
            RD_Q25[ j ]           = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate0_Q5 );
   14c38:	981f      	ldr	r0, [sp, #124]	; 0x7c
   14c3a:	1aaa      	subs	r2, r5, r2
            RD_Q25[ j + nStates ] = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate1_Q5 );
   14c3c:	1aeb      	subs	r3, r5, r3
            RD_Q25[ j ]           = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate0_Q5 );
   14c3e:	fb12 f202 	smulbb	r2, r2, r2
            RD_Q25[ j + nStates ] = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate1_Q5 );
   14c42:	fb13 f303 	smulbb	r3, r3, r3
            RD_Q25[ j ]           = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate0_Q5 );
   14c46:	fb04 0202 	mla	r2, r4, r2, r0
            RD_Q25[ j + nStates ] = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate1_Q5 );
   14c4a:	fb04 0303 	mla	r3, r4, r3, r0
            RD_Q25[ j ]           = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate0_Q5 );
   14c4e:	9806      	ldr	r0, [sp, #24]
   14c50:	fb00 220e 	mla	r2, r0, lr, r2
            RD_Q25[ j + nStates ] = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate1_Q5 );
   14c54:	fb00 3306 	mla	r3, r0, r6, r3
        for( j = 0; j < nStates; j++ ) {
   14c58:	9803      	ldr	r0, [sp, #12]
            RD_Q25[ j ]           = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate0_Q5 );
   14c5a:	921f      	str	r2, [sp, #124]	; 0x7c
            RD_Q25[ j + nStates ] = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate1_Q5 );
   14c5c:	aa1e      	add	r2, sp, #120	; 0x78
        for( j = 0; j < nStates; j++ ) {
   14c5e:	2802      	cmp	r0, #2
            RD_Q25[ j + nStates ] = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate1_Q5 );
   14c60:	f842 3028 	str.w	r3, [r2, r8, lsl #2]
        for( j = 0; j < nStates; j++ ) {
   14c64:	f000 81b4 	beq.w	14fd0 <silk_NLSF_del_dec_quant+0x594>
            pred_Q10 = silk_RSHIFT( silk_SMULBB( (opus_int16)pred_coef_Q8[ i ], prev_out_Q10[ j ] ), 8 );
   14c68:	f8bb 3004 	ldrh.w	r3, [fp, #4]
            res_Q10  = silk_SUB16( in_Q10, pred_Q10 );
   14c6c:	9a01      	ldr	r2, [sp, #4]
            ind[ j ][ i ] = (opus_int8)ind_tmp;
   14c6e:	9f02      	ldr	r7, [sp, #8]
            pred_Q10 = silk_RSHIFT( silk_SMULBB( (opus_int16)pred_coef_Q8[ i ], prev_out_Q10[ j ] ), 8 );
   14c70:	fb13 f30c 	smulbb	r3, r3, ip
   14c74:	121b      	asrs	r3, r3, #8
            res_Q10  = silk_SUB16( in_Q10, pred_Q10 );
   14c76:	1ad6      	subs	r6, r2, r3
            ind_tmp  = silk_RSHIFT( silk_SMULBB( inv_quant_step_size_Q6, res_Q10 ), 16 );
   14c78:	9a05      	ldr	r2, [sp, #20]
   14c7a:	fb16 f602 	smulbb	r6, r6, r2
            ind_tmp  = silk_LIMIT( ind_tmp, -NLSF_QUANT_MAX_AMPLITUDE_EXT, NLSF_QUANT_MAX_AMPLITUDE_EXT-1 );
   14c7e:	f06f 0109 	mvn.w	r1, #9
            ind_tmp  = silk_RSHIFT( silk_SMULBB( inv_quant_step_size_Q6, res_Q10 ), 16 );
   14c82:	1436      	asrs	r6, r6, #16
            ind_tmp  = silk_LIMIT( ind_tmp, -NLSF_QUANT_MAX_AMPLITUDE_EXT, NLSF_QUANT_MAX_AMPLITUDE_EXT-1 );
   14c84:	42b1      	cmp	r1, r6
   14c86:	bfb8      	it	lt
   14c88:	4631      	movlt	r1, r6
   14c8a:	2909      	cmp	r1, #9
   14c8c:	bfa8      	it	ge
   14c8e:	2109      	movge	r1, #9
            out0_Q10 = out0_Q10_table[ ind_tmp + NLSF_QUANT_MAX_AMPLITUDE_EXT ];
   14c90:	aa5e      	add	r2, sp, #376	; 0x178
   14c92:	f101 0e0a 	add.w	lr, r1, #10
   14c96:	eb02 0e8e 	add.w	lr, r2, lr, lsl #2
            out0_Q10  = silk_ADD16( out0_Q10, pred_Q10 );
   14c9a:	b29b      	uxth	r3, r3
   14c9c:	f85e 2ca0 	ldr.w	r2, [lr, #-160]
            out1_Q10  = silk_ADD16( out1_Q10, pred_Q10 );
   14ca0:	f85e ec50 	ldr.w	lr, [lr, #-80]
            ind[ j ][ i ] = (opus_int8)ind_tmp;
   14ca4:	f887 1020 	strb.w	r1, [r7, #32]
            out0_Q10  = silk_ADD16( out0_Q10, pred_Q10 );
   14ca8:	441a      	add	r2, r3
            out1_Q10  = silk_ADD16( out1_Q10, pred_Q10 );
   14caa:	4473      	add	r3, lr
            prev_out_Q10[ j + nStates ] = out1_Q10;
   14cac:	f100 0e02 	add.w	lr, r0, #2
            out0_Q10  = silk_ADD16( out0_Q10, pred_Q10 );
   14cb0:	b292      	uxth	r2, r2
            out1_Q10  = silk_ADD16( out1_Q10, pred_Q10 );
   14cb2:	b29b      	uxth	r3, r3
            if( ind_tmp + 1 >= NLSF_QUANT_MAX_AMPLITUDE ) {
   14cb4:	2e02      	cmp	r6, #2
            prev_out_Q10[ j           ] = out0_Q10;
   14cb6:	f8ab 2004 	strh.w	r2, [fp, #4]
            prev_out_Q10[ j + nStates ] = out1_Q10;
   14cba:	f82b 301e 	strh.w	r3, [fp, lr, lsl #1]
            if( ind_tmp + 1 >= NLSF_QUANT_MAX_AMPLITUDE ) {
   14cbe:	f300 817d 	bgt.w	14fbc <silk_NLSF_del_dec_quant+0x580>
            } else if( ind_tmp <= -NLSF_QUANT_MAX_AMPLITUDE ) {
   14cc2:	1cf0      	adds	r0, r6, #3
   14cc4:	f2c0 8213 	blt.w	150ee <silk_NLSF_del_dec_quant+0x6b2>
                rate0_Q5 = rates_Q5[ ind_tmp +     NLSF_QUANT_MAX_AMPLITUDE ];
   14cc8:	4449      	add	r1, r9
   14cca:	790e      	ldrb	r6, [r1, #4]
                rate1_Q5 = rates_Q5[ ind_tmp + 1 + NLSF_QUANT_MAX_AMPLITUDE ];
   14ccc:	7949      	ldrb	r1, [r1, #5]
            RD_tmp_Q25            = RD_Q25[ j ];
   14cce:	f8dd 8080 	ldr.w	r8, [sp, #128]	; 0x80
            RD_Q25[ j ]           = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate0_Q5 );
   14cd2:	9806      	ldr	r0, [sp, #24]
        for( j = 0; j < nStates; j++ ) {
   14cd4:	9f03      	ldr	r7, [sp, #12]
            RD_Q25[ j ]           = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate0_Q5 );
   14cd6:	1aaa      	subs	r2, r5, r2
   14cd8:	fb12 f202 	smulbb	r2, r2, r2
            RD_Q25[ j + nStates ] = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate1_Q5 );
   14cdc:	1aeb      	subs	r3, r5, r3
            RD_Q25[ j ]           = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate0_Q5 );
   14cde:	fb04 8202 	mla	r2, r4, r2, r8
   14ce2:	fb00 2206 	mla	r2, r0, r6, r2
            RD_Q25[ j + nStates ] = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate1_Q5 );
   14ce6:	fb13 f303 	smulbb	r3, r3, r3
            RD_Q25[ j ]           = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate0_Q5 );
   14cea:	9220      	str	r2, [sp, #128]	; 0x80
            RD_Q25[ j + nStates ] = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate1_Q5 );
   14cec:	fb04 8303 	mla	r3, r4, r3, r8
   14cf0:	aa1e      	add	r2, sp, #120	; 0x78
   14cf2:	fb00 3301 	mla	r3, r0, r1, r3
        for( j = 0; j < nStates; j++ ) {
   14cf6:	2f03      	cmp	r7, #3
            RD_Q25[ j + nStates ] = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate1_Q5 );
   14cf8:	f842 302e 	str.w	r3, [r2, lr, lsl #2]
        for( j = 0; j < nStates; j++ ) {
   14cfc:	d049      	beq.n	14d92 <silk_NLSF_del_dec_quant+0x356>
            pred_Q10 = silk_RSHIFT( silk_SMULBB( (opus_int16)pred_coef_Q8[ i ], prev_out_Q10[ j ] ), 8 );
   14cfe:	f8bb 3006 	ldrh.w	r3, [fp, #6]
            res_Q10  = silk_SUB16( in_Q10, pred_Q10 );
   14d02:	9a01      	ldr	r2, [sp, #4]
            ind_tmp  = silk_RSHIFT( silk_SMULBB( inv_quant_step_size_Q6, res_Q10 ), 16 );
   14d04:	9905      	ldr	r1, [sp, #20]
            pred_Q10 = silk_RSHIFT( silk_SMULBB( (opus_int16)pred_coef_Q8[ i ], prev_out_Q10[ j ] ), 8 );
   14d06:	fb13 f30c 	smulbb	r3, r3, ip
   14d0a:	121b      	asrs	r3, r3, #8
            res_Q10  = silk_SUB16( in_Q10, pred_Q10 );
   14d0c:	1ad2      	subs	r2, r2, r3
            ind_tmp  = silk_RSHIFT( silk_SMULBB( inv_quant_step_size_Q6, res_Q10 ), 16 );
   14d0e:	fb12 f201 	smulbb	r2, r2, r1
            ind_tmp  = silk_LIMIT( ind_tmp, -NLSF_QUANT_MAX_AMPLITUDE_EXT, NLSF_QUANT_MAX_AMPLITUDE_EXT-1 );
   14d12:	f06f 0609 	mvn.w	r6, #9
            ind_tmp  = silk_RSHIFT( silk_SMULBB( inv_quant_step_size_Q6, res_Q10 ), 16 );
   14d16:	1412      	asrs	r2, r2, #16
            ind_tmp  = silk_LIMIT( ind_tmp, -NLSF_QUANT_MAX_AMPLITUDE_EXT, NLSF_QUANT_MAX_AMPLITUDE_EXT-1 );
   14d18:	4296      	cmp	r6, r2
   14d1a:	bfb8      	it	lt
   14d1c:	4616      	movlt	r6, r2
   14d1e:	2e09      	cmp	r6, #9
   14d20:	bfa8      	it	ge
   14d22:	2609      	movge	r6, #9
            out0_Q10 = out0_Q10_table[ ind_tmp + NLSF_QUANT_MAX_AMPLITUDE_EXT ];
   14d24:	a95e      	add	r1, sp, #376	; 0x178
   14d26:	f106 000a 	add.w	r0, r6, #10
   14d2a:	eb01 0080 	add.w	r0, r1, r0, lsl #2
            ind[ j ][ i ] = (opus_int8)ind_tmp;
   14d2e:	9902      	ldr	r1, [sp, #8]
            out0_Q10  = silk_ADD16( out0_Q10, pred_Q10 );
   14d30:	f850 cca0 	ldr.w	ip, [r0, #-160]
            out1_Q10  = silk_ADD16( out1_Q10, pred_Q10 );
   14d34:	f850 0c50 	ldr.w	r0, [r0, #-80]
            ind[ j ][ i ] = (opus_int8)ind_tmp;
   14d38:	f881 6030 	strb.w	r6, [r1, #48]	; 0x30
            out0_Q10  = silk_ADD16( out0_Q10, pred_Q10 );
   14d3c:	b29b      	uxth	r3, r3
   14d3e:	eb0c 0103 	add.w	r1, ip, r3
            out1_Q10  = silk_ADD16( out1_Q10, pred_Q10 );
   14d42:	4403      	add	r3, r0
            prev_out_Q10[ j + nStates ] = out1_Q10;
   14d44:	1cf8      	adds	r0, r7, #3
            out0_Q10  = silk_ADD16( out0_Q10, pred_Q10 );
   14d46:	b289      	uxth	r1, r1
            out1_Q10  = silk_ADD16( out1_Q10, pred_Q10 );
   14d48:	b29b      	uxth	r3, r3
            if( ind_tmp + 1 >= NLSF_QUANT_MAX_AMPLITUDE ) {
   14d4a:	2a02      	cmp	r2, #2
            prev_out_Q10[ j           ] = out0_Q10;
   14d4c:	f8ab 1006 	strh.w	r1, [fp, #6]
            prev_out_Q10[ j + nStates ] = out1_Q10;
   14d50:	f82b 3010 	strh.w	r3, [fp, r0, lsl #1]
            if( ind_tmp + 1 >= NLSF_QUANT_MAX_AMPLITUDE ) {
   14d54:	f340 81af 	ble.w	150b6 <silk_NLSF_del_dec_quant+0x67a>
                if( ind_tmp + 1 == NLSF_QUANT_MAX_AMPLITUDE ) {
   14d58:	2a03      	cmp	r2, #3
   14d5a:	f000 81eb 	beq.w	15134 <silk_NLSF_del_dec_quant+0x6f8>
                    rate0_Q5 = silk_SMLABB( 280 - 43 * NLSF_QUANT_MAX_AMPLITUDE, 43, ind_tmp );
   14d5e:	222b      	movs	r2, #43	; 0x2b
   14d60:	fb02 f206 	mul.w	r2, r2, r6
   14d64:	f102 0c6c 	add.w	ip, r2, #108	; 0x6c
                    rate1_Q5 = silk_ADD16( rate0_Q5, 43 );
   14d68:	3297      	adds	r2, #151	; 0x97
            RD_tmp_Q25            = RD_Q25[ j ];
   14d6a:	9e21      	ldr	r6, [sp, #132]	; 0x84
            RD_Q25[ j ]           = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate0_Q5 );
   14d6c:	1a69      	subs	r1, r5, r1
            RD_Q25[ j + nStates ] = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate1_Q5 );
   14d6e:	1aed      	subs	r5, r5, r3
            RD_Q25[ j ]           = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate0_Q5 );
   14d70:	fb11 f101 	smulbb	r1, r1, r1
   14d74:	9b06      	ldr	r3, [sp, #24]
            RD_Q25[ j + nStates ] = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate1_Q5 );
   14d76:	fb15 f505 	smulbb	r5, r5, r5
            RD_Q25[ j ]           = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate0_Q5 );
   14d7a:	fb04 6101 	mla	r1, r4, r1, r6
            RD_Q25[ j + nStates ] = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate1_Q5 );
   14d7e:	fb04 6505 	mla	r5, r4, r5, r6
            RD_Q25[ j ]           = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate0_Q5 );
   14d82:	fb03 110c 	mla	r1, r3, ip, r1
            RD_Q25[ j + nStates ] = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate1_Q5 );
   14d86:	fb03 5502 	mla	r5, r3, r2, r5
   14d8a:	ab1e      	add	r3, sp, #120	; 0x78
            RD_Q25[ j ]           = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate0_Q5 );
   14d8c:	9121      	str	r1, [sp, #132]	; 0x84
            RD_Q25[ j + nStates ] = silk_SMLABB( silk_MLA( RD_tmp_Q25, silk_SMULBB( diff_Q10, diff_Q10 ), w_Q5[ i ] ), mu_Q20, rate1_Q5 );
   14d8e:	f843 5020 	str.w	r5, [r3, r0, lsl #2]
   14d92:	9a1e      	ldr	r2, [sp, #120]	; 0x78
                if( RD_Q25[ j ] > RD_Q25[ j + NLSF_QUANT_DEL_DEC_STATES ] ) {
   14d94:	9b22      	ldr	r3, [sp, #136]	; 0x88
   14d96:	4293      	cmp	r3, r2
   14d98:	f280 813e 	bge.w	15018 <silk_NLSF_del_dec_quant+0x5dc>
                    RD_max_Q25[ j ]                         = RD_Q25[ j ];
   14d9c:	ad1a      	add	r5, sp, #104	; 0x68
                    RD_min_Q25[ j ]                         = RD_Q25[ j + NLSF_QUANT_DEL_DEC_STATES ];
   14d9e:	ae16      	add	r6, sp, #88	; 0x58
                    RD_Q25[ j ]                             = RD_min_Q25[ j ];
   14da0:	931e      	str	r3, [sp, #120]	; 0x78
                    RD_Q25[ j + NLSF_QUANT_DEL_DEC_STATES ] = RD_max_Q25[ j ];
   14da2:	9222      	str	r2, [sp, #136]	; 0x88
                    RD_max_Q25[ j ]                         = RD_Q25[ j ];
   14da4:	602a      	str	r2, [r5, #0]
                    RD_min_Q25[ j ]                         = RD_Q25[ j + NLSF_QUANT_DEL_DEC_STATES ];
   14da6:	6033      	str	r3, [r6, #0]
                    out0_Q10 = prev_out_Q10[ j ];
   14da8:	f9bb 2000 	ldrsh.w	r2, [fp]
                    prev_out_Q10[ j ] = prev_out_Q10[ j + NLSF_QUANT_DEL_DEC_STATES ];
   14dac:	f8bb 3008 	ldrh.w	r3, [fp, #8]
   14db0:	f8ab 3000 	strh.w	r3, [fp]
                    prev_out_Q10[ j + NLSF_QUANT_DEL_DEC_STATES ] = out0_Q10;
   14db4:	f8ab 2008 	strh.w	r2, [fp, #8]
                if( RD_Q25[ j ] > RD_Q25[ j + NLSF_QUANT_DEL_DEC_STATES ] ) {
   14db8:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   14dba:	9a23      	ldr	r2, [sp, #140]	; 0x8c
                    ind_sort[ j ] = j + NLSF_QUANT_DEL_DEC_STATES;
   14dbc:	a80e      	add	r0, sp, #56	; 0x38
   14dbe:	2104      	movs	r1, #4
                if( RD_Q25[ j ] > RD_Q25[ j + NLSF_QUANT_DEL_DEC_STATES ] ) {
   14dc0:	4293      	cmp	r3, r2
                    ind_sort[ j ] = j + NLSF_QUANT_DEL_DEC_STATES;
   14dc2:	9001      	str	r0, [sp, #4]
   14dc4:	910e      	str	r1, [sp, #56]	; 0x38
                if( RD_Q25[ j ] > RD_Q25[ j + NLSF_QUANT_DEL_DEC_STATES ] ) {
   14dc6:	f300 8134 	bgt.w	15032 <silk_NLSF_del_dec_quant+0x5f6>
                    RD_min_Q25[ j ] = RD_Q25[ j ];
   14dca:	6073      	str	r3, [r6, #4]
                    ind_sort[ j ] = j;
   14dcc:	9b01      	ldr	r3, [sp, #4]
                    RD_max_Q25[ j ] = RD_Q25[ j + NLSF_QUANT_DEL_DEC_STATES ];
   14dce:	606a      	str	r2, [r5, #4]
                    ind_sort[ j ] = j;
   14dd0:	2101      	movs	r1, #1
   14dd2:	6059      	str	r1, [r3, #4]
                if( RD_Q25[ j ] > RD_Q25[ j + NLSF_QUANT_DEL_DEC_STATES ] ) {
   14dd4:	9a24      	ldr	r2, [sp, #144]	; 0x90
   14dd6:	9b20      	ldr	r3, [sp, #128]	; 0x80
   14dd8:	4293      	cmp	r3, r2
   14dda:	f300 813e 	bgt.w	1505a <silk_NLSF_del_dec_quant+0x61e>
                    RD_min_Q25[ j ] = RD_Q25[ j ];
   14dde:	60b3      	str	r3, [r6, #8]
                    ind_sort[ j ] = j;
   14de0:	9b01      	ldr	r3, [sp, #4]
                    RD_max_Q25[ j ] = RD_Q25[ j + NLSF_QUANT_DEL_DEC_STATES ];
   14de2:	60aa      	str	r2, [r5, #8]
                    ind_sort[ j ] = j;
   14de4:	461a      	mov	r2, r3
   14de6:	2302      	movs	r3, #2
   14de8:	6093      	str	r3, [r2, #8]
                if( RD_Q25[ j ] > RD_Q25[ j + NLSF_QUANT_DEL_DEC_STATES ] ) {
   14dea:	f8dd a084 	ldr.w	sl, [sp, #132]	; 0x84
   14dee:	9a25      	ldr	r2, [sp, #148]	; 0x94
   14df0:	4592      	cmp	sl, r2
   14df2:	f300 80fb 	bgt.w	14fec <silk_NLSF_del_dec_quant+0x5b0>
                    ind_sort[ j ] = j;
   14df6:	9901      	ldr	r1, [sp, #4]
                    RD_min_Q25[ j ] = RD_Q25[ j ];
   14df8:	f8c6 a00c 	str.w	sl, [r6, #12]
                    ind_sort[ j ] = j;
   14dfc:	2303      	movs	r3, #3
                    RD_max_Q25[ j ] = RD_Q25[ j + NLSF_QUANT_DEL_DEC_STATES ];
   14dfe:	60ea      	str	r2, [r5, #12]
                    ind_sort[ j ] = j;
   14e00:	60cb      	str	r3, [r1, #12]
   14e02:	4691      	mov	r9, r2
   14e04:	e04d      	b.n	14ea2 <silk_NLSF_del_dec_quant+0x466>
                    if( min_max_Q25 > RD_max_Q25[ j ] ) {
   14e06:	4611      	mov	r1, r2
                        min_max_Q25 = RD_max_Q25[ j ];
                        ind_min_max = j;
                    }
                    if( max_min_Q25 < RD_min_Q25[ j ] ) {
   14e08:	6872      	ldr	r2, [r6, #4]
                    if( min_max_Q25 > RD_max_Q25[ j ] ) {
   14e0a:	2300      	movs	r3, #0
                    if( max_min_Q25 < RD_min_Q25[ j ] ) {
   14e0c:	4282      	cmp	r2, r0
                    if( min_max_Q25 > RD_max_Q25[ j ] ) {
   14e0e:	4698      	mov	r8, r3
   14e10:	f04f 0e04 	mov.w	lr, #4
                    if( max_min_Q25 < RD_min_Q25[ j ] ) {
   14e14:	dc55      	bgt.n	14ec2 <silk_NLSF_del_dec_quant+0x486>
   14e16:	2400      	movs	r4, #0
   14e18:	4602      	mov	r2, r0
   14e1a:	46a4      	mov	ip, r4
                    if( min_max_Q25 > RD_max_Q25[ j ] ) {
   14e1c:	68a8      	ldr	r0, [r5, #8]
   14e1e:	4281      	cmp	r1, r0
   14e20:	bfd8      	it	le
   14e22:	4608      	movle	r0, r1
                    if( max_min_Q25 < RD_min_Q25[ j ] ) {
   14e24:	68b1      	ldr	r1, [r6, #8]
                    if( min_max_Q25 > RD_max_Q25[ j ] ) {
   14e26:	bfc2      	ittt	gt
   14e28:	2320      	movgt	r3, #32
   14e2a:	f04f 0e06 	movgt.w	lr, #6
                for( j = 0; j < NLSF_QUANT_DEL_DEC_STATES; j++ ) {
   14e2e:	f04f 0802 	movgt.w	r8, #2
                    if( max_min_Q25 < RD_min_Q25[ j ] ) {
   14e32:	428a      	cmp	r2, r1
   14e34:	bfae      	itee	ge
   14e36:	4611      	movge	r1, r2
   14e38:	2420      	movlt	r4, #32
                for( j = 0; j < NLSF_QUANT_DEL_DEC_STATES; j++ ) {
   14e3a:	f04f 0c02 	movlt.w	ip, #2
                    if( min_max_Q25 > RD_max_Q25[ j ] ) {
   14e3e:	4548      	cmp	r0, r9
   14e40:	bfd1      	iteee	le
   14e42:	4681      	movle	r9, r0
   14e44:	2330      	movgt	r3, #48	; 0x30
   14e46:	f04f 0e07 	movgt.w	lr, #7
                for( j = 0; j < NLSF_QUANT_DEL_DEC_STATES; j++ ) {
   14e4a:	f04f 0803 	movgt.w	r8, #3
                    if( max_min_Q25 < RD_min_Q25[ j ] ) {
   14e4e:	4551      	cmp	r1, sl
   14e50:	db3b      	blt.n	14eca <silk_NLSF_del_dec_quant+0x48e>
                        max_min_Q25 = RD_min_Q25[ j ];
                        ind_max_min = j;
                    }
                }
                if( min_max_Q25 >= max_min_Q25 ) {
   14e52:	4549      	cmp	r1, r9
   14e54:	dd3f      	ble.n	14ed6 <silk_NLSF_del_dec_quant+0x49a>
                ind_sort[     ind_max_min ] = ind_sort[     ind_min_max ] ^ NLSF_QUANT_DEL_DEC_STATES;
                RD_Q25[       ind_max_min ] = RD_Q25[       ind_min_max + NLSF_QUANT_DEL_DEC_STATES ];
                prev_out_Q10[ ind_max_min ] = prev_out_Q10[ ind_min_max + NLSF_QUANT_DEL_DEC_STATES ];
                RD_min_Q25[   ind_max_min ] = 0;
                RD_max_Q25[   ind_min_max ] = silk_int32_MAX;
                silk_memcpy( ind[ ind_max_min ], ind[ ind_min_max ], MAX_LPC_ORDER * sizeof( opus_int8 ) );
   14e56:	aa26      	add	r2, sp, #152	; 0x98
   14e58:	4413      	add	r3, r2
                ind_sort[     ind_max_min ] = ind_sort[     ind_min_max ] ^ NLSF_QUANT_DEL_DEC_STATES;
   14e5a:	9f01      	ldr	r7, [sp, #4]
                silk_memcpy( ind[ ind_max_min ], ind[ ind_min_max ], MAX_LPC_ORDER * sizeof( opus_int8 ) );
   14e5c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
                ind_sort[     ind_max_min ] = ind_sort[     ind_min_max ] ^ NLSF_QUANT_DEL_DEC_STATES;
   14e5e:	f857 9028 	ldr.w	r9, [r7, r8, lsl #2]
                RD_min_Q25[   ind_max_min ] = 0;
   14e62:	9f04      	ldr	r7, [sp, #16]
   14e64:	f846 702c 	str.w	r7, [r6, ip, lsl #2]
                RD_max_Q25[   ind_min_max ] = silk_int32_MAX;
   14e68:	f06f 4a00 	mvn.w	sl, #2147483648	; 0x80000000
   14e6c:	f845 a028 	str.w	sl, [r5, r8, lsl #2]
                RD_Q25[       ind_max_min ] = RD_Q25[       ind_min_max + NLSF_QUANT_DEL_DEC_STATES ];
   14e70:	af1e      	add	r7, sp, #120	; 0x78
                silk_memcpy( ind[ ind_max_min ], ind[ ind_min_max ], MAX_LPC_ORDER * sizeof( opus_int8 ) );
   14e72:	f10d 0898 	add.w	r8, sp, #152	; 0x98
   14e76:	4444      	add	r4, r8
                RD_Q25[       ind_max_min ] = RD_Q25[       ind_min_max + NLSF_QUANT_DEL_DEC_STATES ];
   14e78:	f10d 0878 	add.w	r8, sp, #120	; 0x78
   14e7c:	f857 702e 	ldr.w	r7, [r7, lr, lsl #2]
   14e80:	f848 702c 	str.w	r7, [r8, ip, lsl #2]
                silk_memcpy( ind[ ind_max_min ], ind[ ind_min_max ], MAX_LPC_ORDER * sizeof( opus_int8 ) );
   14e84:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
                ind_sort[     ind_max_min ] = ind_sort[     ind_min_max ] ^ NLSF_QUANT_DEL_DEC_STATES;
   14e88:	9f01      	ldr	r7, [sp, #4]
                prev_out_Q10[ ind_max_min ] = prev_out_Q10[ ind_min_max + NLSF_QUANT_DEL_DEC_STATES ];
   14e8a:	f93b e01e 	ldrsh.w	lr, [fp, lr, lsl #1]
   14e8e:	f8d6 a00c 	ldr.w	sl, [r6, #12]
   14e92:	f82b e01c 	strh.w	lr, [fp, ip, lsl #1]
                ind_sort[     ind_max_min ] = ind_sort[     ind_min_max ] ^ NLSF_QUANT_DEL_DEC_STATES;
   14e96:	f089 0904 	eor.w	r9, r9, #4
   14e9a:	f847 902c 	str.w	r9, [r7, ip, lsl #2]
   14e9e:	f8d5 900c 	ldr.w	r9, [r5, #12]
   14ea2:	6830      	ldr	r0, [r6, #0]
                    if( min_max_Q25 > RD_max_Q25[ j ] ) {
   14ea4:	e9d5 2100 	ldrd	r2, r1, [r5]
   14ea8:	428a      	cmp	r2, r1
   14eaa:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   14eae:	ddaa      	ble.n	14e06 <silk_NLSF_del_dec_quant+0x3ca>
                    if( max_min_Q25 < RD_min_Q25[ j ] ) {
   14eb0:	6872      	ldr	r2, [r6, #4]
   14eb2:	4282      	cmp	r2, r0
                    if( min_max_Q25 > RD_max_Q25[ j ] ) {
   14eb4:	f04f 0310 	mov.w	r3, #16
   14eb8:	f04f 0e05 	mov.w	lr, #5
                for( j = 0; j < NLSF_QUANT_DEL_DEC_STATES; j++ ) {
   14ebc:	f04f 0801 	mov.w	r8, #1
                    if( max_min_Q25 < RD_min_Q25[ j ] ) {
   14ec0:	dda9      	ble.n	14e16 <silk_NLSF_del_dec_quant+0x3da>
   14ec2:	2410      	movs	r4, #16
                for( j = 0; j < NLSF_QUANT_DEL_DEC_STATES; j++ ) {
   14ec4:	f04f 0c01 	mov.w	ip, #1
   14ec8:	e7a8      	b.n	14e1c <silk_NLSF_del_dec_quant+0x3e0>
                if( min_max_Q25 >= max_min_Q25 ) {
   14eca:	45d1      	cmp	r9, sl
   14ecc:	da03      	bge.n	14ed6 <silk_NLSF_del_dec_quant+0x49a>
   14ece:	2430      	movs	r4, #48	; 0x30
                for( j = 0; j < NLSF_QUANT_DEL_DEC_STATES; j++ ) {
   14ed0:	f04f 0c03 	mov.w	ip, #3
   14ed4:	e7bf      	b.n	14e56 <silk_NLSF_del_dec_quant+0x41a>
            }
            /* increment index if it comes from the upper half */
            for( j = 0; j < NLSF_QUANT_DEL_DEC_STATES; j++ ) {
                ind[ j ][ i ] += silk_RSHIFT( ind_sort[ j ], NLSF_QUANT_DEL_DEC_STATES_LOG2 );
   14ed6:	9e02      	ldr	r6, [sp, #8]
   14ed8:	9d01      	ldr	r5, [sp, #4]
   14eda:	7832      	ldrb	r2, [r6, #0]
   14edc:	682c      	ldr	r4, [r5, #0]
   14ede:	6868      	ldr	r0, [r5, #4]
   14ee0:	7c33      	ldrb	r3, [r6, #16]
   14ee2:	68a9      	ldr	r1, [r5, #8]
   14ee4:	68ed      	ldr	r5, [r5, #12]
   14ee6:	eb02 02a4 	add.w	r2, r2, r4, asr #2
   14eea:	7032      	strb	r2, [r6, #0]
   14eec:	f896 4020 	ldrb.w	r4, [r6, #32]
   14ef0:	f896 2030 	ldrb.w	r2, [r6, #48]	; 0x30
   14ef4:	eb03 03a0 	add.w	r3, r3, r0, asr #2
   14ef8:	eb04 01a1 	add.w	r1, r4, r1, asr #2
   14efc:	eb02 05a5 	add.w	r5, r2, r5, asr #2
   14f00:	7433      	strb	r3, [r6, #16]
   14f02:	f886 1020 	strb.w	r1, [r6, #32]
   14f06:	4633      	mov	r3, r6
   14f08:	f886 5030 	strb.w	r5, [r6, #48]	; 0x30
    for( i = order - 1; i >= 0; i-- ) {
   14f0c:	aa26      	add	r2, sp, #152	; 0x98
   14f0e:	4293      	cmp	r3, r2
   14f10:	f47f adf3 	bne.w	14afa <silk_NLSF_del_dec_quant+0xbe>

    /* last sample: find winner, copy indices and return RD value */
    ind_tmp = 0;
    min_Q25 = silk_int32_MAX;
    for( j = 0; j < 2 * NLSF_QUANT_DEL_DEC_STATES; j++ ) {
        if( min_Q25 > RD_Q25[ j ] ) {
   14f14:	981e      	ldr	r0, [sp, #120]	; 0x78
   14f16:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   14f18:	9b20      	ldr	r3, [sp, #128]	; 0x80
   14f1a:	9d25      	ldr	r5, [sp, #148]	; 0x94
   14f1c:	4290      	cmp	r0, r2
   14f1e:	bfda      	itte	le
   14f20:	4602      	movle	r2, r0
   14f22:	2400      	movle	r4, #0
    for( j = 0; j < 2 * NLSF_QUANT_DEL_DEC_STATES; j++ ) {
   14f24:	2401      	movgt	r4, #1
        if( min_Q25 > RD_Q25[ j ] ) {
   14f26:	4293      	cmp	r3, r2
   14f28:	bfa8      	it	ge
   14f2a:	4613      	movge	r3, r2
   14f2c:	9a21      	ldr	r2, [sp, #132]	; 0x84
    for( j = 0; j < 2 * NLSF_QUANT_DEL_DEC_STATES; j++ ) {
   14f2e:	bfb8      	it	lt
   14f30:	2402      	movlt	r4, #2
        if( min_Q25 > RD_Q25[ j ] ) {
   14f32:	429a      	cmp	r2, r3
   14f34:	bfa8      	it	ge
   14f36:	461a      	movge	r2, r3
   14f38:	9b22      	ldr	r3, [sp, #136]	; 0x88
    for( j = 0; j < 2 * NLSF_QUANT_DEL_DEC_STATES; j++ ) {
   14f3a:	bfb8      	it	lt
   14f3c:	2403      	movlt	r4, #3
        if( min_Q25 > RD_Q25[ j ] ) {
   14f3e:	4293      	cmp	r3, r2
   14f40:	bfa8      	it	ge
   14f42:	4613      	movge	r3, r2
   14f44:	9a23      	ldr	r2, [sp, #140]	; 0x8c
    for( j = 0; j < 2 * NLSF_QUANT_DEL_DEC_STATES; j++ ) {
   14f46:	bfb8      	it	lt
   14f48:	2404      	movlt	r4, #4
        if( min_Q25 > RD_Q25[ j ] ) {
   14f4a:	429a      	cmp	r2, r3
   14f4c:	bfa8      	it	ge
   14f4e:	461a      	movge	r2, r3
   14f50:	9b24      	ldr	r3, [sp, #144]	; 0x90
    for( j = 0; j < 2 * NLSF_QUANT_DEL_DEC_STATES; j++ ) {
   14f52:	bfb8      	it	lt
   14f54:	2405      	movlt	r4, #5
        if( min_Q25 > RD_Q25[ j ] ) {
   14f56:	4293      	cmp	r3, r2
   14f58:	bfa8      	it	ge
   14f5a:	4613      	movge	r3, r2
            min_Q25 = RD_Q25[ j ];
            ind_tmp = j;
        }
    }
    for( j = 0; j < order; j++ ) {
   14f5c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    for( j = 0; j < 2 * NLSF_QUANT_DEL_DEC_STATES; j++ ) {
   14f5e:	bfb8      	it	lt
   14f60:	2406      	movlt	r4, #6
        if( min_Q25 > RD_Q25[ j ] ) {
   14f62:	429d      	cmp	r5, r3
   14f64:	bfac      	ite	ge
   14f66:	461d      	movge	r5, r3
    for( j = 0; j < 2 * NLSF_QUANT_DEL_DEC_STATES; j++ ) {
   14f68:	2407      	movlt	r4, #7
    for( j = 0; j < order; j++ ) {
   14f6a:	2a00      	cmp	r2, #0
   14f6c:	dd07      	ble.n	14f7e <silk_NLSF_del_dec_quant+0x542>
        indices[ j ] = ind[ ind_tmp & ( NLSF_QUANT_DEL_DEC_STATES - 1 ) ][ j ];
   14f6e:	f004 0103 	and.w	r1, r4, #3
   14f72:	ab26      	add	r3, sp, #152	; 0x98
   14f74:	eb03 1101 	add.w	r1, r3, r1, lsl #4
   14f78:	980d      	ldr	r0, [sp, #52]	; 0x34
   14f7a:	f7f7 f8c1 	bl	c100 <memcpy>
        silk_assert( indices[ j ] >= -NLSF_QUANT_MAX_AMPLITUDE_EXT );
        silk_assert( indices[ j ] <=  NLSF_QUANT_MAX_AMPLITUDE_EXT );
    }
    indices[ 0 ] += silk_RSHIFT( ind_tmp, NLSF_QUANT_DEL_DEC_STATES_LOG2 );
   14f7e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   14f80:	7813      	ldrb	r3, [r2, #0]
    silk_assert( indices[ 0 ] <= NLSF_QUANT_MAX_AMPLITUDE_EXT );
    silk_assert( min_Q25 >= 0 );
    return min_Q25;
}
   14f82:	4628      	mov	r0, r5
    indices[ 0 ] += silk_RSHIFT( ind_tmp, NLSF_QUANT_DEL_DEC_STATES_LOG2 );
   14f84:	eb03 0494 	add.w	r4, r3, r4, lsr #2
   14f88:	7014      	strb	r4, [r2, #0]
}
   14f8a:	b05f      	add	sp, #380	; 0x17c
   14f8c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if( ind_tmp + 1 == NLSF_QUANT_MAX_AMPLITUDE ) {
   14f90:	2e03      	cmp	r6, #3
   14f92:	f000 80a7 	beq.w	150e4 <silk_NLSF_del_dec_quant+0x6a8>
                    rate0_Q5 = silk_SMLABB( 280 - 43 * NLSF_QUANT_MAX_AMPLITUDE, 43, ind_tmp );
   14f96:	262b      	movs	r6, #43	; 0x2b
   14f98:	fb06 f601 	mul.w	r6, r6, r1
   14f9c:	f106 0e6c 	add.w	lr, r6, #108	; 0x6c
                    rate1_Q5 = silk_ADD16( rate0_Q5, 43 );
   14fa0:	3697      	adds	r6, #151	; 0x97
   14fa2:	e5f9      	b.n	14b98 <silk_NLSF_del_dec_quant+0x15c>
                if( ind_tmp + 1 == NLSF_QUANT_MAX_AMPLITUDE ) {
   14fa4:	f1be 0f03 	cmp.w	lr, #3
   14fa8:	f000 80ab 	beq.w	15102 <silk_NLSF_del_dec_quant+0x6c6>
                    rate0_Q5 = silk_SMLABB( 280 - 43 * NLSF_QUANT_MAX_AMPLITUDE, 43, ind_tmp );
   14fac:	f04f 0e2b 	mov.w	lr, #43	; 0x2b
   14fb0:	fb0e f606 	mul.w	r6, lr, r6
   14fb4:	f106 0e6c 	add.w	lr, r6, #108	; 0x6c
                    rate1_Q5 = silk_ADD16( rate0_Q5, 43 );
   14fb8:	3697      	adds	r6, #151	; 0x97
   14fba:	e63d      	b.n	14c38 <silk_NLSF_del_dec_quant+0x1fc>
                if( ind_tmp + 1 == NLSF_QUANT_MAX_AMPLITUDE ) {
   14fbc:	2e03      	cmp	r6, #3
   14fbe:	f000 80aa 	beq.w	15116 <silk_NLSF_del_dec_quant+0x6da>
                    rate0_Q5 = silk_SMLABB( 280 - 43 * NLSF_QUANT_MAX_AMPLITUDE, 43, ind_tmp );
   14fc2:	262b      	movs	r6, #43	; 0x2b
   14fc4:	fb06 f101 	mul.w	r1, r6, r1
   14fc8:	f101 066c 	add.w	r6, r1, #108	; 0x6c
                    rate1_Q5 = silk_ADD16( rate0_Q5, 43 );
   14fcc:	3197      	adds	r1, #151	; 0x97
   14fce:	e67e      	b.n	14cce <silk_NLSF_del_dec_quant+0x292>
                ind[ j + nStates ][ i ] = ind[ j ][ i ] + 1;
   14fd0:	ab5e      	add	r3, sp, #376	; 0x178
   14fd2:	449a      	add	sl, r3
   14fd4:	9a02      	ldr	r2, [sp, #8]
   14fd6:	3101      	adds	r1, #1
   14fd8:	f80a 1cc0 	strb.w	r1, [sl, #-192]
   14fdc:	7c13      	ldrb	r3, [r2, #16]
   14fde:	3301      	adds	r3, #1
   14fe0:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
   14fe4:	2304      	movs	r3, #4
   14fe6:	9303      	str	r3, [sp, #12]
   14fe8:	4613      	mov	r3, r2
   14fea:	e78f      	b.n	14f0c <silk_NLSF_del_dec_quant+0x4d0>
                    ind_sort[ j ] = j + NLSF_QUANT_DEL_DEC_STATES;
   14fec:	4611      	mov	r1, r2
                    RD_min_Q25[ j ]                         = RD_Q25[ j + NLSF_QUANT_DEL_DEC_STATES ];
   14fee:	60f2      	str	r2, [r6, #12]
                    RD_Q25[ j ]                             = RD_min_Q25[ j ];
   14ff0:	9221      	str	r2, [sp, #132]	; 0x84
                    RD_max_Q25[ j ]                         = RD_Q25[ j ];
   14ff2:	f8c5 a00c 	str.w	sl, [r5, #12]
                    ind_sort[ j ] = j + NLSF_QUANT_DEL_DEC_STATES;
   14ff6:	4652      	mov	r2, sl
                    RD_Q25[ j + NLSF_QUANT_DEL_DEC_STATES ] = RD_max_Q25[ j ];
   14ff8:	f8cd a094 	str.w	sl, [sp, #148]	; 0x94
                    ind_sort[ j ] = j + NLSF_QUANT_DEL_DEC_STATES;
   14ffc:	468a      	mov	sl, r1
   14ffe:	9901      	ldr	r1, [sp, #4]
                    out0_Q10 = prev_out_Q10[ j ];
   15000:	f9bb 0006 	ldrsh.w	r0, [fp, #6]
                    prev_out_Q10[ j ] = prev_out_Q10[ j + NLSF_QUANT_DEL_DEC_STATES ];
   15004:	f8bb 400e 	ldrh.w	r4, [fp, #14]
   15008:	f8ab 4006 	strh.w	r4, [fp, #6]
                    ind_sort[ j ] = j + NLSF_QUANT_DEL_DEC_STATES;
   1500c:	2307      	movs	r3, #7
                    prev_out_Q10[ j + NLSF_QUANT_DEL_DEC_STATES ] = out0_Q10;
   1500e:	f8ab 000e 	strh.w	r0, [fp, #14]
                    ind_sort[ j ] = j + NLSF_QUANT_DEL_DEC_STATES;
   15012:	60cb      	str	r3, [r1, #12]
   15014:	4691      	mov	r9, r2
   15016:	e744      	b.n	14ea2 <silk_NLSF_del_dec_quant+0x466>
                    RD_min_Q25[ j ] = RD_Q25[ j ];
   15018:	ae16      	add	r6, sp, #88	; 0x58
                    RD_max_Q25[ j ] = RD_Q25[ j + NLSF_QUANT_DEL_DEC_STATES ];
   1501a:	ad1a      	add	r5, sp, #104	; 0x68
                    RD_min_Q25[ j ] = RD_Q25[ j ];
   1501c:	6032      	str	r2, [r6, #0]
                    RD_max_Q25[ j ] = RD_Q25[ j + NLSF_QUANT_DEL_DEC_STATES ];
   1501e:	602b      	str	r3, [r5, #0]
                    ind_sort[ j ] = j;
   15020:	aa0e      	add	r2, sp, #56	; 0x38
   15022:	9b04      	ldr	r3, [sp, #16]
   15024:	9201      	str	r2, [sp, #4]
   15026:	930e      	str	r3, [sp, #56]	; 0x38
                if( RD_Q25[ j ] > RD_Q25[ j + NLSF_QUANT_DEL_DEC_STATES ] ) {
   15028:	9a23      	ldr	r2, [sp, #140]	; 0x8c
   1502a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1502c:	4293      	cmp	r3, r2
   1502e:	f77f aecc 	ble.w	14dca <silk_NLSF_del_dec_quant+0x38e>
                    RD_min_Q25[ j ]                         = RD_Q25[ j + NLSF_QUANT_DEL_DEC_STATES ];
   15032:	6072      	str	r2, [r6, #4]
                    RD_Q25[ j ]                             = RD_min_Q25[ j ];
   15034:	921f      	str	r2, [sp, #124]	; 0x7c
                    prev_out_Q10[ j ] = prev_out_Q10[ j + NLSF_QUANT_DEL_DEC_STATES ];
   15036:	f8bb 200a 	ldrh.w	r2, [fp, #10]
                    out0_Q10 = prev_out_Q10[ j ];
   1503a:	f9bb 1002 	ldrsh.w	r1, [fp, #2]
                    prev_out_Q10[ j ] = prev_out_Q10[ j + NLSF_QUANT_DEL_DEC_STATES ];
   1503e:	f8ab 2002 	strh.w	r2, [fp, #2]
                    ind_sort[ j ] = j + NLSF_QUANT_DEL_DEC_STATES;
   15042:	9a01      	ldr	r2, [sp, #4]
                    RD_max_Q25[ j ]                         = RD_Q25[ j ];
   15044:	606b      	str	r3, [r5, #4]
                    RD_Q25[ j + NLSF_QUANT_DEL_DEC_STATES ] = RD_max_Q25[ j ];
   15046:	9323      	str	r3, [sp, #140]	; 0x8c
                    ind_sort[ j ] = j + NLSF_QUANT_DEL_DEC_STATES;
   15048:	2305      	movs	r3, #5
   1504a:	6053      	str	r3, [r2, #4]
                if( RD_Q25[ j ] > RD_Q25[ j + NLSF_QUANT_DEL_DEC_STATES ] ) {
   1504c:	9b20      	ldr	r3, [sp, #128]	; 0x80
   1504e:	9a24      	ldr	r2, [sp, #144]	; 0x90
                    prev_out_Q10[ j + NLSF_QUANT_DEL_DEC_STATES ] = out0_Q10;
   15050:	f8ab 100a 	strh.w	r1, [fp, #10]
                if( RD_Q25[ j ] > RD_Q25[ j + NLSF_QUANT_DEL_DEC_STATES ] ) {
   15054:	4293      	cmp	r3, r2
   15056:	f77f aec2 	ble.w	14dde <silk_NLSF_del_dec_quant+0x3a2>
                    RD_max_Q25[ j ]                         = RD_Q25[ j ];
   1505a:	60ab      	str	r3, [r5, #8]
                    RD_Q25[ j + NLSF_QUANT_DEL_DEC_STATES ] = RD_max_Q25[ j ];
   1505c:	9324      	str	r3, [sp, #144]	; 0x90
                    ind_sort[ j ] = j + NLSF_QUANT_DEL_DEC_STATES;
   1505e:	9b01      	ldr	r3, [sp, #4]
                    out0_Q10 = prev_out_Q10[ j ];
   15060:	f9bb 1004 	ldrsh.w	r1, [fp, #4]
                    RD_min_Q25[ j ]                         = RD_Q25[ j + NLSF_QUANT_DEL_DEC_STATES ];
   15064:	60b2      	str	r2, [r6, #8]
                    ind_sort[ j ] = j + NLSF_QUANT_DEL_DEC_STATES;
   15066:	4618      	mov	r0, r3
                    RD_Q25[ j ]                             = RD_min_Q25[ j ];
   15068:	9220      	str	r2, [sp, #128]	; 0x80
                    ind_sort[ j ] = j + NLSF_QUANT_DEL_DEC_STATES;
   1506a:	2306      	movs	r3, #6
                    prev_out_Q10[ j ] = prev_out_Q10[ j + NLSF_QUANT_DEL_DEC_STATES ];
   1506c:	f8bb 200c 	ldrh.w	r2, [fp, #12]
                    ind_sort[ j ] = j + NLSF_QUANT_DEL_DEC_STATES;
   15070:	6083      	str	r3, [r0, #8]
                    prev_out_Q10[ j + NLSF_QUANT_DEL_DEC_STATES ] = out0_Q10;
   15072:	f8ab 100c 	strh.w	r1, [fp, #12]
                    prev_out_Q10[ j ] = prev_out_Q10[ j + NLSF_QUANT_DEL_DEC_STATES ];
   15076:	f8ab 2004 	strh.w	r2, [fp, #4]
   1507a:	e6b6      	b.n	14dea <silk_NLSF_del_dec_quant+0x3ae>
                if( ind_tmp == -NLSF_QUANT_MAX_AMPLITUDE ) {
   1507c:	3604      	adds	r6, #4
   1507e:	d054      	beq.n	1512a <silk_NLSF_del_dec_quant+0x6ee>
                    rate0_Q5 = silk_SMLABB( 280 - 43 * NLSF_QUANT_MAX_AMPLITUDE, -43, ind_tmp );
   15080:	f06f 062a 	mvn.w	r6, #42	; 0x2a
   15084:	fb06 f601 	mul.w	r6, r6, r1
   15088:	f106 0e6c 	add.w	lr, r6, #108	; 0x6c
                    rate1_Q5 = silk_SUB16( rate0_Q5, 43 );
   1508c:	3641      	adds	r6, #65	; 0x41
   1508e:	e583      	b.n	14b98 <silk_NLSF_del_dec_quant+0x15c>
                ind[ j + nStates ][ i ] = ind[ j ][ i ] + 1;
   15090:	ab5e      	add	r3, sp, #376	; 0x178
   15092:	4453      	add	r3, sl
   15094:	3101      	adds	r1, #1
   15096:	f803 1cd0 	strb.w	r1, [r3, #-208]
                ind[ j ][ i ] = ind[ j - nStates ][ i ];
   1509a:	9a02      	ldr	r2, [sp, #8]
   1509c:	ab5e      	add	r3, sp, #376	; 0x178
   1509e:	449a      	add	sl, r3
   150a0:	f992 3000 	ldrsb.w	r3, [r2]
   150a4:	f80a 3cc0 	strb.w	r3, [sl, #-192]
   150a8:	7c13      	ldrb	r3, [r2, #16]
   150aa:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
            nStates = silk_LSHIFT( nStates, 1 );
   150ae:	2302      	movs	r3, #2
   150b0:	9303      	str	r3, [sp, #12]
   150b2:	4613      	mov	r3, r2
   150b4:	e72a      	b.n	14f0c <silk_NLSF_del_dec_quant+0x4d0>
            } else if( ind_tmp <= -NLSF_QUANT_MAX_AMPLITUDE ) {
   150b6:	1cd7      	adds	r7, r2, #3
   150b8:	da28      	bge.n	1510c <silk_NLSF_del_dec_quant+0x6d0>
                if( ind_tmp == -NLSF_QUANT_MAX_AMPLITUDE ) {
   150ba:	3204      	adds	r2, #4
   150bc:	d030      	beq.n	15120 <silk_NLSF_del_dec_quant+0x6e4>
                    rate0_Q5 = silk_SMLABB( 280 - 43 * NLSF_QUANT_MAX_AMPLITUDE, -43, ind_tmp );
   150be:	f06f 022a 	mvn.w	r2, #42	; 0x2a
   150c2:	fb02 f206 	mul.w	r2, r2, r6
   150c6:	f102 0c6c 	add.w	ip, r2, #108	; 0x6c
                    rate1_Q5 = silk_SUB16( rate0_Q5, 43 );
   150ca:	3241      	adds	r2, #65	; 0x41
   150cc:	e64d      	b.n	14d6a <silk_NLSF_del_dec_quant+0x32e>
                if( ind_tmp == -NLSF_QUANT_MAX_AMPLITUDE ) {
   150ce:	f11e 0f04 	cmn.w	lr, #4
   150d2:	d034      	beq.n	1513e <silk_NLSF_del_dec_quant+0x702>
                    rate0_Q5 = silk_SMLABB( 280 - 43 * NLSF_QUANT_MAX_AMPLITUDE, -43, ind_tmp );
   150d4:	f06f 0e2a 	mvn.w	lr, #42	; 0x2a
   150d8:	fb0e f606 	mul.w	r6, lr, r6
   150dc:	f106 0e6c 	add.w	lr, r6, #108	; 0x6c
                    rate1_Q5 = silk_SUB16( rate0_Q5, 43 );
   150e0:	3641      	adds	r6, #65	; 0x41
   150e2:	e5a9      	b.n	14c38 <silk_NLSF_del_dec_quant+0x1fc>
                    rate0_Q5 = rates_Q5[ ind_tmp + NLSF_QUANT_MAX_AMPLITUDE ];
   150e4:	f899 e007 	ldrb.w	lr, [r9, #7]
                    rate1_Q5 = 280;
   150e8:	f44f 768c 	mov.w	r6, #280	; 0x118
   150ec:	e554      	b.n	14b98 <silk_NLSF_del_dec_quant+0x15c>
                if( ind_tmp == -NLSF_QUANT_MAX_AMPLITUDE ) {
   150ee:	3604      	adds	r6, #4
   150f0:	d02a      	beq.n	15148 <silk_NLSF_del_dec_quant+0x70c>
                    rate0_Q5 = silk_SMLABB( 280 - 43 * NLSF_QUANT_MAX_AMPLITUDE, -43, ind_tmp );
   150f2:	f06f 062a 	mvn.w	r6, #42	; 0x2a
   150f6:	fb06 f101 	mul.w	r1, r6, r1
   150fa:	f101 066c 	add.w	r6, r1, #108	; 0x6c
                    rate1_Q5 = silk_SUB16( rate0_Q5, 43 );
   150fe:	3141      	adds	r1, #65	; 0x41
   15100:	e5e5      	b.n	14cce <silk_NLSF_del_dec_quant+0x292>
                    rate0_Q5 = rates_Q5[ ind_tmp + NLSF_QUANT_MAX_AMPLITUDE ];
   15102:	f899 e007 	ldrb.w	lr, [r9, #7]
                    rate1_Q5 = 280;
   15106:	f44f 768c 	mov.w	r6, #280	; 0x118
   1510a:	e595      	b.n	14c38 <silk_NLSF_del_dec_quant+0x1fc>
                rate0_Q5 = rates_Q5[ ind_tmp +     NLSF_QUANT_MAX_AMPLITUDE ];
   1510c:	444e      	add	r6, r9
   1510e:	f896 c004 	ldrb.w	ip, [r6, #4]
                rate1_Q5 = rates_Q5[ ind_tmp + 1 + NLSF_QUANT_MAX_AMPLITUDE ];
   15112:	7972      	ldrb	r2, [r6, #5]
   15114:	e629      	b.n	14d6a <silk_NLSF_del_dec_quant+0x32e>
                    rate0_Q5 = rates_Q5[ ind_tmp + NLSF_QUANT_MAX_AMPLITUDE ];
   15116:	f899 6007 	ldrb.w	r6, [r9, #7]
                    rate1_Q5 = 280;
   1511a:	f44f 718c 	mov.w	r1, #280	; 0x118
   1511e:	e5d6      	b.n	14cce <silk_NLSF_del_dec_quant+0x292>
                    rate1_Q5 = rates_Q5[ ind_tmp + 1 + NLSF_QUANT_MAX_AMPLITUDE ];
   15120:	f899 2001 	ldrb.w	r2, [r9, #1]
                    rate0_Q5 = 280;
   15124:	f44f 7c8c 	mov.w	ip, #280	; 0x118
   15128:	e61f      	b.n	14d6a <silk_NLSF_del_dec_quant+0x32e>
                    rate1_Q5 = rates_Q5[ ind_tmp + 1 + NLSF_QUANT_MAX_AMPLITUDE ];
   1512a:	f899 6001 	ldrb.w	r6, [r9, #1]
                    rate0_Q5 = 280;
   1512e:	f44f 7e8c 	mov.w	lr, #280	; 0x118
   15132:	e531      	b.n	14b98 <silk_NLSF_del_dec_quant+0x15c>
                    rate0_Q5 = rates_Q5[ ind_tmp + NLSF_QUANT_MAX_AMPLITUDE ];
   15134:	f899 c007 	ldrb.w	ip, [r9, #7]
                    rate1_Q5 = 280;
   15138:	f44f 728c 	mov.w	r2, #280	; 0x118
   1513c:	e615      	b.n	14d6a <silk_NLSF_del_dec_quant+0x32e>
                    rate1_Q5 = rates_Q5[ ind_tmp + 1 + NLSF_QUANT_MAX_AMPLITUDE ];
   1513e:	f899 6001 	ldrb.w	r6, [r9, #1]
                    rate0_Q5 = 280;
   15142:	f44f 7e8c 	mov.w	lr, #280	; 0x118
   15146:	e577      	b.n	14c38 <silk_NLSF_del_dec_quant+0x1fc>
                    rate1_Q5 = rates_Q5[ ind_tmp + 1 + NLSF_QUANT_MAX_AMPLITUDE ];
   15148:	f899 1001 	ldrb.w	r1, [r9, #1]
                    rate0_Q5 = 280;
   1514c:	f44f 768c 	mov.w	r6, #280	; 0x118
   15150:	e5bd      	b.n	14cce <silk_NLSF_del_dec_quant+0x292>
   15152:	b2b5      	uxth	r5, r6
   15154:	02a8      	lsls	r0, r5, #10
   15156:	f5a0 5011 	sub.w	r0, r0, #9280	; 0x2440
   1515a:	3536      	adds	r5, #54	; 0x36
   1515c:	3826      	subs	r0, #38	; 0x26
   1515e:	02ad      	lsls	r5, r5, #10
   15160:	fa0f f880 	sxth.w	r8, r0
   15164:	b22d      	sxth	r5, r5
        out0_Q10_table[ i + NLSF_QUANT_MAX_AMPLITUDE_EXT ] = silk_RSHIFT( silk_SMULBB( out0_Q10, quant_step_size_Q16 ), 16 );
   15166:	fb05 f00e 	mul.w	r0, r5, lr
        out1_Q10_table[ i + NLSF_QUANT_MAX_AMPLITUDE_EXT ] = silk_RSHIFT( silk_SMULBB( out1_Q10, quant_step_size_Q16 ), 16 );
   1516a:	fb08 f50e 	mul.w	r5, r8, lr
        out0_Q10_table[ i + NLSF_QUANT_MAX_AMPLITUDE_EXT ] = silk_RSHIFT( silk_SMULBB( out0_Q10, quant_step_size_Q16 ), 16 );
   1516e:	1400      	asrs	r0, r0, #16
        out1_Q10_table[ i + NLSF_QUANT_MAX_AMPLITUDE_EXT ] = silk_RSHIFT( silk_SMULBB( out1_Q10, quant_step_size_Q16 ), 16 );
   15170:	142d      	asrs	r5, r5, #16
        out0_Q10_table[ i + NLSF_QUANT_MAX_AMPLITUDE_EXT ] = silk_RSHIFT( silk_SMULBB( out0_Q10, quant_step_size_Q16 ), 16 );
   15172:	f84a 0026 	str.w	r0, [sl, r6, lsl #2]
        out1_Q10_table[ i + NLSF_QUANT_MAX_AMPLITUDE_EXT ] = silk_RSHIFT( silk_SMULBB( out1_Q10, quant_step_size_Q16 ), 16 );
   15176:	f849 5026 	str.w	r5, [r9, r6, lsl #2]
   1517a:	e48c      	b.n	14a96 <silk_NLSF_del_dec_quant+0x5a>
   1517c:	f106 0037 	add.w	r0, r6, #55	; 0x37
   15180:	0280      	lsls	r0, r0, #10
   15182:	fa0f f880 	sxth.w	r8, r0
   15186:	e7ee      	b.n	15166 <silk_NLSF_del_dec_quant+0x72a>

00015188 <silk_process_NLSFs>:
    silk_encoder_state          *psEncC,                            /* I/O  Encoder state                               */
    opus_int16                  PredCoef_Q12[ 2 ][ MAX_LPC_ORDER ], /* O    Prediction coefficients                     */
    opus_int16                  pNLSF_Q15[         MAX_LPC_ORDER ], /* I/O  Normalized LSFs (quant out) (0 - (2^15-1))  */
    const opus_int16            prev_NLSFq_Q15[    MAX_LPC_ORDER ]  /* I    Previous Normalized LSFs (0 - (2^15-1))     */
)
{
   15188:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1518c:	4604      	mov	r4, r0

    /***********************/
    /* Calculate mu values */
    /***********************/
    /* NLSF_mu  = 0.003 - 0.0015 * psEnc->speech_activity; */
    NLSF_mu_Q20 = silk_SMLAWB( SILK_FIX_CONST( 0.003, 20 ), SILK_FIX_CONST( -0.001, 28 ), psEncC->speech_activity_Q8 );
   1518e:	f241 15b4 	movw	r5, #4532	; 0x11b4
    if( psEncC->nb_subfr == 2 ) {
   15192:	f241 16e4 	movw	r6, #4580	; 0x11e4
    NLSF_mu_Q20 = silk_SMLAWB( SILK_FIX_CONST( 0.003, 20 ), SILK_FIX_CONST( -0.001, 28 ), psEncC->speech_activity_Q8 );
   15196:	5f65      	ldrsh	r5, [r4, r5]
    if( psEncC->nb_subfr == 2 ) {
   15198:	59a6      	ldr	r6, [r4, r6]
    NLSF_mu_Q20 = silk_SMLAWB( SILK_FIX_CONST( 0.003, 20 ), SILK_FIX_CONST( -0.001, 28 ), psEncC->speech_activity_Q8 );
   1519a:	f24e 706e 	movw	r0, #59246	; 0xe76e
   1519e:	fb00 f005 	mul.w	r0, r0, r5
    if( psEncC->nb_subfr == 2 ) {
   151a2:	2e02      	cmp	r6, #2
    NLSF_mu_Q20 = silk_SMLAWB( SILK_FIX_CONST( 0.003, 20 ), SILK_FIX_CONST( -0.001, 28 ), psEncC->speech_activity_Q8 );
   151a4:	ea4f 4020 	mov.w	r0, r0, asr #16
   151a8:	f64f 77fb 	movw	r7, #65531	; 0xfffb

    celt_assert( NLSF_mu_Q20 >  0 );
    silk_assert( NLSF_mu_Q20 <= SILK_FIX_CONST( 0.005, 20 ) );

    /* Calculate NLSF weights */
    silk_NLSF_VQ_weights_laroia( pNLSFW_QW, pNLSF_Q15, psEncC->predictLPCOrder );
   151ac:	f504 5691 	add.w	r6, r4, #4640	; 0x1220
    NLSF_mu_Q20 = silk_SMLAWB( SILK_FIX_CONST( 0.003, 20 ), SILK_FIX_CONST( -0.001, 28 ), psEncC->speech_activity_Q8 );
   151b0:	fb15 0507 	smlabb	r5, r5, r7, r0
{
   151b4:	b09c      	sub	sp, #112	; 0x70
   151b6:	4617      	mov	r7, r2
   151b8:	4688      	mov	r8, r1
    NLSF_mu_Q20 = silk_SMLAWB( SILK_FIX_CONST( 0.003, 20 ), SILK_FIX_CONST( -0.001, 28 ), psEncC->speech_activity_Q8 );
   151ba:	f605 454a 	addw	r5, r5, #3146	; 0xc4a
    silk_NLSF_VQ_weights_laroia( pNLSFW_QW, pNLSF_Q15, psEncC->predictLPCOrder );
   151be:	6832      	ldr	r2, [r6, #0]
   151c0:	a80c      	add	r0, sp, #48	; 0x30
   151c2:	4639      	mov	r1, r7
{
   151c4:	4699      	mov	r9, r3
        NLSF_mu_Q20 = silk_ADD_RSHIFT( NLSF_mu_Q20, NLSF_mu_Q20, 1 );
   151c6:	bf08      	it	eq
   151c8:	eb05 0565 	addeq.w	r5, r5, r5, asr #1
    silk_NLSF_VQ_weights_laroia( pNLSFW_QW, pNLSF_Q15, psEncC->predictLPCOrder );
   151cc:	f003 fc04 	bl	189d8 <silk_NLSF_VQ_weights_laroia>

    /* Update NLSF weights for interpolated NLSFs */
    doInterpolate = ( psEncC->useInterpolatedNLSFs == 1 ) && ( psEncC->indices.NLSFInterpCoef_Q2 < 4 );
   151d0:	f241 2318 	movw	r3, #4632	; 0x1218
   151d4:	58e3      	ldr	r3, [r4, r3]
   151d6:	2b01      	cmp	r3, #1
   151d8:	d025      	beq.n	15226 <silk_process_NLSFs+0x9e>
                  silk_SMULBB( pNLSFW0_temp_QW[ i ], i_sqr_Q15 ), 16) );
            silk_assert( pNLSFW_QW[ i ] >= 1 );
        }
    }

    silk_NLSF_encode( psEncC->indices.NLSFIndices, pNLSF_Q15, psEncC->psNLSF_CB, pNLSFW_QW,
   151da:	f241 2334 	movw	r3, #4660	; 0x1234
        NLSF_mu_Q20, psEncC->NLSF_MSVQ_Survivors, psEncC->indices.signalType );
   151de:	f241 219d 	movw	r1, #4765	; 0x129d
    silk_NLSF_encode( psEncC->indices.NLSFIndices, pNLSF_Q15, psEncC->psNLSF_CB, pNLSFW_QW,
   151e2:	58e3      	ldr	r3, [r4, r3]
   151e4:	5661      	ldrsb	r1, [r4, r1]
   151e6:	f241 2254 	movw	r2, #4692	; 0x1254
   151ea:	f504 5094 	add.w	r0, r4, #4736	; 0x1280
   151ee:	58a2      	ldr	r2, [r4, r2]
   151f0:	9102      	str	r1, [sp, #8]
   151f2:	e9cd 5300 	strd	r5, r3, [sp]
   151f6:	4639      	mov	r1, r7
   151f8:	ab0c      	add	r3, sp, #48	; 0x30
   151fa:	3008      	adds	r0, #8
   151fc:	f7ff fa0e 	bl	1461c <silk_NLSF_encode>

    /* Convert quantized NLSFs back to LPC coefficients */
    silk_NLSF2A( PredCoef_Q12[ 1 ], pNLSF_Q15, psEncC->predictLPCOrder, psEncC->arch );
   15200:	f241 33e4 	movw	r3, #5092	; 0x13e4
   15204:	f108 0520 	add.w	r5, r8, #32
   15208:	4639      	mov	r1, r7
   1520a:	6832      	ldr	r2, [r6, #0]
   1520c:	58e3      	ldr	r3, [r4, r3]
   1520e:	4628      	mov	r0, r5
   15210:	f002 fef8 	bl	18004 <silk_NLSF2A>
        silk_NLSF2A( PredCoef_Q12[ 0 ], pNLSF0_temp_Q15, psEncC->predictLPCOrder, psEncC->arch );

    } else {
        /* Copy LPC coefficients for first half from second half */
        celt_assert( psEncC->predictLPCOrder <= MAX_LPC_ORDER );
        silk_memcpy( PredCoef_Q12[ 0 ], PredCoef_Q12[ 1 ], psEncC->predictLPCOrder * sizeof( opus_int16 ) );
   15214:	6832      	ldr	r2, [r6, #0]
   15216:	4629      	mov	r1, r5
   15218:	0052      	lsls	r2, r2, #1
   1521a:	4640      	mov	r0, r8
    }
}
   1521c:	b01c      	add	sp, #112	; 0x70
   1521e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        silk_memcpy( PredCoef_Q12[ 0 ], PredCoef_Q12[ 1 ], psEncC->predictLPCOrder * sizeof( opus_int16 ) );
   15222:	f7f6 bf6d 	b.w	c100 <memcpy>
    doInterpolate = ( psEncC->useInterpolatedNLSFs == 1 ) && ( psEncC->indices.NLSFInterpCoef_Q2 < 4 );
   15226:	f241 2a9f 	movw	sl, #4767	; 0x129f
   1522a:	f914 300a 	ldrsb.w	r3, [r4, sl]
   1522e:	2b03      	cmp	r3, #3
   15230:	dcd3      	bgt.n	151da <silk_process_NLSFs+0x52>
        silk_interpolate( pNLSF0_temp_Q15, prev_NLSFq_Q15, pNLSF_Q15,
   15232:	6832      	ldr	r2, [r6, #0]
   15234:	9200      	str	r2, [sp, #0]
   15236:	a804      	add	r0, sp, #16
   15238:	463a      	mov	r2, r7
   1523a:	4649      	mov	r1, r9
   1523c:	f7fa fd78 	bl	fd30 <silk_interpolate>
        silk_NLSF_VQ_weights_laroia( pNLSFW0_temp_QW, pNLSF0_temp_Q15, psEncC->predictLPCOrder );
   15240:	6832      	ldr	r2, [r6, #0]
   15242:	a904      	add	r1, sp, #16
   15244:	a814      	add	r0, sp, #80	; 0x50
   15246:	f003 fbc7 	bl	189d8 <silk_NLSF_VQ_weights_laroia>
        i_sqr_Q15 = silk_LSHIFT( silk_SMULBB( psEncC->indices.NLSFInterpCoef_Q2, psEncC->indices.NLSFInterpCoef_Q2 ), 11 );
   1524a:	f914 300a 	ldrsb.w	r3, [r4, sl]
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   1524e:	6832      	ldr	r2, [r6, #0]
        i_sqr_Q15 = silk_LSHIFT( silk_SMULBB( psEncC->indices.NLSFInterpCoef_Q2, psEncC->indices.NLSFInterpCoef_Q2 ), 11 );
   15250:	fb13 f303 	smulbb	r3, r3, r3
   15254:	02db      	lsls	r3, r3, #11
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   15256:	2a00      	cmp	r2, #0
        i_sqr_Q15 = silk_LSHIFT( silk_SMULBB( psEncC->indices.NLSFInterpCoef_Q2, psEncC->indices.NLSFInterpCoef_Q2 ), 11 );
   15258:	b21b      	sxth	r3, r3
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   1525a:	f340 80d3 	ble.w	15404 <silk_process_NLSFs+0x27c>
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   1525e:	f9bd 1030 	ldrsh.w	r1, [sp, #48]	; 0x30
   15262:	f8bd 0050 	ldrh.w	r0, [sp, #80]	; 0x50
   15266:	1049      	asrs	r1, r1, #1
   15268:	fb10 f003 	smulbb	r0, r0, r3
   1526c:	eb01 4120 	add.w	r1, r1, r0, asr #16
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   15270:	2a01      	cmp	r2, #1
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   15272:	f8ad 1030 	strh.w	r1, [sp, #48]	; 0x30
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   15276:	f000 80c5 	beq.w	15404 <silk_process_NLSFs+0x27c>
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   1527a:	f9bd 1032 	ldrsh.w	r1, [sp, #50]	; 0x32
   1527e:	f8bd 0052 	ldrh.w	r0, [sp, #82]	; 0x52
   15282:	1049      	asrs	r1, r1, #1
   15284:	fb10 f003 	smulbb	r0, r0, r3
   15288:	eb01 4120 	add.w	r1, r1, r0, asr #16
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   1528c:	2a02      	cmp	r2, #2
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   1528e:	f8ad 1032 	strh.w	r1, [sp, #50]	; 0x32
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   15292:	f000 80b7 	beq.w	15404 <silk_process_NLSFs+0x27c>
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   15296:	f9bd 1034 	ldrsh.w	r1, [sp, #52]	; 0x34
   1529a:	f8bd 0054 	ldrh.w	r0, [sp, #84]	; 0x54
   1529e:	1049      	asrs	r1, r1, #1
   152a0:	fb10 f003 	smulbb	r0, r0, r3
   152a4:	eb01 4120 	add.w	r1, r1, r0, asr #16
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   152a8:	2a03      	cmp	r2, #3
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   152aa:	f8ad 1034 	strh.w	r1, [sp, #52]	; 0x34
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   152ae:	f000 80a9 	beq.w	15404 <silk_process_NLSFs+0x27c>
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   152b2:	f9bd 1036 	ldrsh.w	r1, [sp, #54]	; 0x36
   152b6:	f8bd 0056 	ldrh.w	r0, [sp, #86]	; 0x56
   152ba:	1049      	asrs	r1, r1, #1
   152bc:	fb10 f003 	smulbb	r0, r0, r3
   152c0:	eb01 4120 	add.w	r1, r1, r0, asr #16
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   152c4:	2a04      	cmp	r2, #4
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   152c6:	f8ad 1036 	strh.w	r1, [sp, #54]	; 0x36
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   152ca:	f000 809b 	beq.w	15404 <silk_process_NLSFs+0x27c>
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   152ce:	f9bd 1038 	ldrsh.w	r1, [sp, #56]	; 0x38
   152d2:	f8bd 0058 	ldrh.w	r0, [sp, #88]	; 0x58
   152d6:	1049      	asrs	r1, r1, #1
   152d8:	fb10 f003 	smulbb	r0, r0, r3
   152dc:	eb01 4120 	add.w	r1, r1, r0, asr #16
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   152e0:	2a05      	cmp	r2, #5
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   152e2:	f8ad 1038 	strh.w	r1, [sp, #56]	; 0x38
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   152e6:	f000 808d 	beq.w	15404 <silk_process_NLSFs+0x27c>
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   152ea:	f9bd 103a 	ldrsh.w	r1, [sp, #58]	; 0x3a
   152ee:	f8bd 005a 	ldrh.w	r0, [sp, #90]	; 0x5a
   152f2:	1049      	asrs	r1, r1, #1
   152f4:	fb10 f003 	smulbb	r0, r0, r3
   152f8:	eb01 4120 	add.w	r1, r1, r0, asr #16
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   152fc:	2a06      	cmp	r2, #6
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   152fe:	f8ad 103a 	strh.w	r1, [sp, #58]	; 0x3a
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   15302:	d07f      	beq.n	15404 <silk_process_NLSFs+0x27c>
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   15304:	f9bd 103c 	ldrsh.w	r1, [sp, #60]	; 0x3c
   15308:	f8bd 005c 	ldrh.w	r0, [sp, #92]	; 0x5c
   1530c:	1049      	asrs	r1, r1, #1
   1530e:	fb10 f003 	smulbb	r0, r0, r3
   15312:	eb01 4120 	add.w	r1, r1, r0, asr #16
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   15316:	2a07      	cmp	r2, #7
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   15318:	f8ad 103c 	strh.w	r1, [sp, #60]	; 0x3c
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   1531c:	d072      	beq.n	15404 <silk_process_NLSFs+0x27c>
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   1531e:	f9bd 103e 	ldrsh.w	r1, [sp, #62]	; 0x3e
   15322:	f8bd 005e 	ldrh.w	r0, [sp, #94]	; 0x5e
   15326:	1049      	asrs	r1, r1, #1
   15328:	fb10 f003 	smulbb	r0, r0, r3
   1532c:	eb01 4120 	add.w	r1, r1, r0, asr #16
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   15330:	2a08      	cmp	r2, #8
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   15332:	f8ad 103e 	strh.w	r1, [sp, #62]	; 0x3e
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   15336:	d065      	beq.n	15404 <silk_process_NLSFs+0x27c>
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   15338:	f9bd 1040 	ldrsh.w	r1, [sp, #64]	; 0x40
   1533c:	f8bd 0060 	ldrh.w	r0, [sp, #96]	; 0x60
   15340:	1049      	asrs	r1, r1, #1
   15342:	fb10 f003 	smulbb	r0, r0, r3
   15346:	eb01 4120 	add.w	r1, r1, r0, asr #16
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   1534a:	2a09      	cmp	r2, #9
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   1534c:	f8ad 1040 	strh.w	r1, [sp, #64]	; 0x40
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   15350:	d058      	beq.n	15404 <silk_process_NLSFs+0x27c>
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   15352:	f9bd 1042 	ldrsh.w	r1, [sp, #66]	; 0x42
   15356:	f8bd 0062 	ldrh.w	r0, [sp, #98]	; 0x62
   1535a:	1049      	asrs	r1, r1, #1
   1535c:	fb10 f003 	smulbb	r0, r0, r3
   15360:	eb01 4120 	add.w	r1, r1, r0, asr #16
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   15364:	2a0a      	cmp	r2, #10
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   15366:	f8ad 1042 	strh.w	r1, [sp, #66]	; 0x42
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   1536a:	d04b      	beq.n	15404 <silk_process_NLSFs+0x27c>
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   1536c:	f9bd 1044 	ldrsh.w	r1, [sp, #68]	; 0x44
   15370:	f8bd 0064 	ldrh.w	r0, [sp, #100]	; 0x64
   15374:	1049      	asrs	r1, r1, #1
   15376:	fb10 f003 	smulbb	r0, r0, r3
   1537a:	eb01 4120 	add.w	r1, r1, r0, asr #16
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   1537e:	2a0b      	cmp	r2, #11
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   15380:	f8ad 1044 	strh.w	r1, [sp, #68]	; 0x44
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   15384:	d03e      	beq.n	15404 <silk_process_NLSFs+0x27c>
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   15386:	f9bd 1046 	ldrsh.w	r1, [sp, #70]	; 0x46
   1538a:	f8bd 0066 	ldrh.w	r0, [sp, #102]	; 0x66
   1538e:	1049      	asrs	r1, r1, #1
   15390:	fb10 f003 	smulbb	r0, r0, r3
   15394:	eb01 4120 	add.w	r1, r1, r0, asr #16
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   15398:	2a0c      	cmp	r2, #12
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   1539a:	f8ad 1046 	strh.w	r1, [sp, #70]	; 0x46
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   1539e:	d031      	beq.n	15404 <silk_process_NLSFs+0x27c>
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   153a0:	f9bd 1048 	ldrsh.w	r1, [sp, #72]	; 0x48
   153a4:	f8bd 0068 	ldrh.w	r0, [sp, #104]	; 0x68
   153a8:	1049      	asrs	r1, r1, #1
   153aa:	fb10 f003 	smulbb	r0, r0, r3
   153ae:	eb01 4120 	add.w	r1, r1, r0, asr #16
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   153b2:	2a0d      	cmp	r2, #13
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   153b4:	f8ad 1048 	strh.w	r1, [sp, #72]	; 0x48
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   153b8:	d024      	beq.n	15404 <silk_process_NLSFs+0x27c>
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   153ba:	f9bd 104a 	ldrsh.w	r1, [sp, #74]	; 0x4a
   153be:	f8bd 006a 	ldrh.w	r0, [sp, #106]	; 0x6a
   153c2:	1049      	asrs	r1, r1, #1
   153c4:	fb10 f003 	smulbb	r0, r0, r3
   153c8:	eb01 4120 	add.w	r1, r1, r0, asr #16
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   153cc:	2a0e      	cmp	r2, #14
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   153ce:	f8ad 104a 	strh.w	r1, [sp, #74]	; 0x4a
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   153d2:	d017      	beq.n	15404 <silk_process_NLSFs+0x27c>
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   153d4:	f9bd 104c 	ldrsh.w	r1, [sp, #76]	; 0x4c
   153d8:	f8bd 006c 	ldrh.w	r0, [sp, #108]	; 0x6c
   153dc:	1049      	asrs	r1, r1, #1
   153de:	fb10 f003 	smulbb	r0, r0, r3
   153e2:	eb01 4120 	add.w	r1, r1, r0, asr #16
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   153e6:	2a0f      	cmp	r2, #15
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   153e8:	f8ad 104c 	strh.w	r1, [sp, #76]	; 0x4c
        for( i = 0; i < psEncC->predictLPCOrder; i++ ) {
   153ec:	d00a      	beq.n	15404 <silk_process_NLSFs+0x27c>
            pNLSFW_QW[ i ] = silk_ADD16( silk_RSHIFT( pNLSFW_QW[ i ], 1 ), silk_RSHIFT(
   153ee:	f9bd 204e 	ldrsh.w	r2, [sp, #78]	; 0x4e
   153f2:	f8bd 106e 	ldrh.w	r1, [sp, #110]	; 0x6e
   153f6:	fb11 f103 	smulbb	r1, r1, r3
   153fa:	1053      	asrs	r3, r2, #1
   153fc:	eb03 4321 	add.w	r3, r3, r1, asr #16
   15400:	f8ad 304e 	strh.w	r3, [sp, #78]	; 0x4e
    silk_NLSF_encode( psEncC->indices.NLSFIndices, pNLSF_Q15, psEncC->psNLSF_CB, pNLSFW_QW,
   15404:	f241 2334 	movw	r3, #4660	; 0x1234
   15408:	f241 2254 	movw	r2, #4692	; 0x1254
   1540c:	58e3      	ldr	r3, [r4, r3]
   1540e:	58a2      	ldr	r2, [r4, r2]
        NLSF_mu_Q20, psEncC->NLSF_MSVQ_Survivors, psEncC->indices.signalType );
   15410:	f241 219d 	movw	r1, #4765	; 0x129d
    silk_NLSF_encode( psEncC->indices.NLSFIndices, pNLSF_Q15, psEncC->psNLSF_CB, pNLSFW_QW,
   15414:	f504 5094 	add.w	r0, r4, #4736	; 0x1280
   15418:	5661      	ldrsb	r1, [r4, r1]
   1541a:	9102      	str	r1, [sp, #8]
   1541c:	e9cd 5300 	strd	r5, r3, [sp]
    silk_NLSF2A( PredCoef_Q12[ 1 ], pNLSF_Q15, psEncC->predictLPCOrder, psEncC->arch );
   15420:	f241 35e4 	movw	r5, #5092	; 0x13e4
    silk_NLSF_encode( psEncC->indices.NLSFIndices, pNLSF_Q15, psEncC->psNLSF_CB, pNLSFW_QW,
   15424:	ab0c      	add	r3, sp, #48	; 0x30
   15426:	4639      	mov	r1, r7
   15428:	3008      	adds	r0, #8
   1542a:	f7ff f8f7 	bl	1461c <silk_NLSF_encode>
    silk_NLSF2A( PredCoef_Q12[ 1 ], pNLSF_Q15, psEncC->predictLPCOrder, psEncC->arch );
   1542e:	5963      	ldr	r3, [r4, r5]
   15430:	6832      	ldr	r2, [r6, #0]
   15432:	4639      	mov	r1, r7
   15434:	f108 0020 	add.w	r0, r8, #32
   15438:	f002 fde4 	bl	18004 <silk_NLSF2A>
            psEncC->indices.NLSFInterpCoef_Q2, psEncC->predictLPCOrder );
   1543c:	f241 239f 	movw	r3, #4767	; 0x129f
        silk_interpolate( pNLSF0_temp_Q15, prev_NLSFq_Q15, pNLSF_Q15,
   15440:	6832      	ldr	r2, [r6, #0]
   15442:	56e3      	ldrsb	r3, [r4, r3]
   15444:	9200      	str	r2, [sp, #0]
   15446:	4649      	mov	r1, r9
   15448:	463a      	mov	r2, r7
   1544a:	a804      	add	r0, sp, #16
   1544c:	f7fa fc70 	bl	fd30 <silk_interpolate>
        silk_NLSF2A( PredCoef_Q12[ 0 ], pNLSF0_temp_Q15, psEncC->predictLPCOrder, psEncC->arch );
   15450:	5963      	ldr	r3, [r4, r5]
   15452:	6832      	ldr	r2, [r6, #0]
   15454:	a904      	add	r1, sp, #16
   15456:	4640      	mov	r0, r8
   15458:	f002 fdd4 	bl	18004 <silk_NLSF2A>
}
   1545c:	b01c      	add	sp, #112	; 0x70
   1545e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   15462:	bf00      	nop

00015464 <silk_stereo_LR_to_MS>:
    opus_int                    prev_speech_act_Q8,             /* I    Speech activity level in previous frame     */
    opus_int                    toMono,                         /* I    Last frame before a stereo->mono transition */
    opus_int                    fs_kHz,                         /* I    Sample rate (kHz)                           */
    opus_int                    frame_length                    /* I    Number of samples                           */
)
{
   15464:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15468:	b093      	sub	sp, #76	; 0x4c
   1546a:	af02      	add	r7, sp, #8
   1546c:	e9c7 0208 	strd	r0, r2, [r7, #32]
    VARDECL( opus_int16, LP_side );
    VARDECL( opus_int16, HP_side );
    opus_int16 *mid = &x1[ -2 ];
    SAVE_STACK;

    ALLOC( side, frame_length + 2, opus_int16 );
   15470:	f8d7 4080 	ldr.w	r4, [r7, #128]	; 0x80
{
   15474:	61bb      	str	r3, [r7, #24]
    ALLOC( side, frame_length + 2, opus_int16 );
   15476:	1ca5      	adds	r5, r4, #2
   15478:	006d      	lsls	r5, r5, #1
   1547a:	f105 0408 	add.w	r4, r5, #8
   1547e:	f024 0407 	bic.w	r4, r4, #7
   15482:	ebad 0d04 	sub.w	sp, sp, r4
   15486:	ab02      	add	r3, sp, #8
   15488:	62fb      	str	r3, [r7, #44]	; 0x2c
    opus_int16 *mid = &x1[ -2 ];
   1548a:	1f0b      	subs	r3, r1, #4
   1548c:	607b      	str	r3, [r7, #4]
    /* Convert to basic mid/side signals */
    for( n = 0; n < frame_length + 2; n++ ) {
   1548e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
{
   15492:	62b9      	str	r1, [r7, #40]	; 0x28
    for( n = 0; n < frame_length + 2; n++ ) {
   15494:	3301      	adds	r3, #1
   15496:	f2c0 8417 	blt.w	15cc8 <silk_stereo_LR_to_MS+0x864>
   1549a:	1f2b      	subs	r3, r5, #4
   1549c:	eb01 0e03 	add.w	lr, r1, r3
   154a0:	613b      	str	r3, [r7, #16]
   154a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   154a4:	f1a3 0c06 	sub.w	ip, r3, #6
   154a8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   154aa:	f1ae 0e02 	sub.w	lr, lr, #2
   154ae:	1f8c      	subs	r4, r1, #6
   154b0:	1e9e      	subs	r6, r3, #2
        sum  = x1[ n - 2 ] + (opus_int32)x2[ n - 2 ];
        diff = x1[ n - 2 ] - (opus_int32)x2[ n - 2 ];
        mid[  n ] = (opus_int16)silk_RSHIFT_ROUND( sum, 1 );
        side[ n ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( diff, 1 ) );
   154b2:	f647 78ff 	movw	r8, #32767	; 0x7fff
        sum  = x1[ n - 2 ] + (opus_int32)x2[ n - 2 ];
   154b6:	f93c 2f02 	ldrsh.w	r2, [ip, #2]!
   154ba:	f934 3f02 	ldrsh.w	r3, [r4, #2]!
   154be:	18d0      	adds	r0, r2, r3
        diff = x1[ n - 2 ] - (opus_int32)x2[ n - 2 ];
   154c0:	1a9b      	subs	r3, r3, r2
        side[ n ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( diff, 1 ) );
   154c2:	f003 0201 	and.w	r2, r3, #1
        mid[  n ] = (opus_int16)silk_RSHIFT_ROUND( sum, 1 );
   154c6:	f000 0101 	and.w	r1, r0, #1
        side[ n ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( diff, 1 ) );
   154ca:	eb02 0363 	add.w	r3, r2, r3, asr #1
        mid[  n ] = (opus_int16)silk_RSHIFT_ROUND( sum, 1 );
   154ce:	eb01 0160 	add.w	r1, r1, r0, asr #1
        side[ n ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( diff, 1 ) );
   154d2:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
        mid[  n ] = (opus_int16)silk_RSHIFT_ROUND( sum, 1 );
   154d6:	8021      	strh	r1, [r4, #0]
        side[ n ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( diff, 1 ) );
   154d8:	f000 81ba 	beq.w	15850 <silk_stereo_LR_to_MS+0x3ec>
    for( n = 0; n < frame_length + 2; n++ ) {
   154dc:	45a6      	cmp	lr, r4
        side[ n ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( diff, 1 ) );
   154de:	f826 3f02 	strh.w	r3, [r6, #2]!
    for( n = 0; n < frame_length + 2; n++ ) {
   154e2:	d1e8      	bne.n	154b6 <silk_stereo_LR_to_MS+0x52>
    }

    /* Buffering */
    silk_memcpy( mid,  state->sMid,  2 * sizeof( opus_int16 ) );
   154e4:	6a38      	ldr	r0, [r7, #32]
   154e6:	6abe      	ldr	r6, [r7, #40]	; 0x28
   154e8:	6843      	ldr	r3, [r0, #4]
   154ea:	f846 3c04 	str.w	r3, [r6, #-4]
    silk_memcpy( side, state->sSide, 2 * sizeof( opus_int16 ) );
   154ee:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   154f0:	6883      	ldr	r3, [r0, #8]
    silk_memcpy( state->sMid,  &mid[  frame_length ], 2 * sizeof( opus_int16 ) );
    silk_memcpy( state->sSide, &side[ frame_length ], 2 * sizeof( opus_int16 ) );
   154f2:	693c      	ldr	r4, [r7, #16]
    silk_memcpy( side, state->sSide, 2 * sizeof( opus_int16 ) );
   154f4:	6013      	str	r3, [r2, #0]
    silk_memcpy( state->sSide, &side[ frame_length ], 2 * sizeof( opus_int16 ) );
   154f6:	5913      	ldr	r3, [r2, r4]
    silk_memcpy( state->sMid,  &mid[  frame_length ], 2 * sizeof( opus_int16 ) );
   154f8:	687a      	ldr	r2, [r7, #4]

    /* LP and HP filter mid signal */
    ALLOC( LP_mid, frame_length, opus_int16 );
   154fa:	3504      	adds	r5, #4
   154fc:	f025 0507 	bic.w	r5, r5, #7
    silk_memcpy( state->sMid,  &mid[  frame_length ], 2 * sizeof( opus_int16 ) );
   15500:	5912      	ldr	r2, [r2, r4]
    silk_memcpy( state->sSide, &side[ frame_length ], 2 * sizeof( opus_int16 ) );
   15502:	6083      	str	r3, [r0, #8]
    ALLOC( HP_mid, frame_length, opus_int16 );
    for( n = 0; n < frame_length; n++ ) {
   15504:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
    silk_memcpy( state->sMid,  &mid[  frame_length ], 2 * sizeof( opus_int16 ) );
   15508:	6042      	str	r2, [r0, #4]
    ALLOC( LP_mid, frame_length, opus_int16 );
   1550a:	ebad 0d05 	sub.w	sp, sp, r5
   1550e:	a902      	add	r1, sp, #8
    for( n = 0; n < frame_length; n++ ) {
   15510:	2b00      	cmp	r3, #0
    ALLOC( HP_mid, frame_length, opus_int16 );
   15512:	ebad 0d05 	sub.w	sp, sp, r5
   15516:	f10d 0908 	add.w	r9, sp, #8
    for( n = 0; n < frame_length; n++ ) {
   1551a:	f340 83cc 	ble.w	15cb6 <silk_stereo_LR_to_MS+0x852>
   1551e:	2b02      	cmp	r3, #2
   15520:	f103 3aff 	add.w	sl, r3, #4294967295	; 0xffffffff
   15524:	f340 83e3 	ble.w	15cee <silk_stereo_LR_to_MS+0x88a>
   15528:	4632      	mov	r2, r6
   1552a:	f936 6c04 	ldrsh.w	r6, [r6, #-4]
   1552e:	f932 5c02 	ldrsh.w	r5, [r2, #-2]
   15532:	2401      	movs	r4, #1
   15534:	2000      	movs	r0, #0
        sum = silk_RSHIFT_ROUND( silk_ADD_LSHIFT( mid[ n ] + (opus_int32)mid[ n + 2 ], mid[ n + 1 ], 1 ), 2 );
   15536:	46b6      	mov	lr, r6
   15538:	f932 6010 	ldrsh.w	r6, [r2, r0, lsl #1]
   1553c:	44b6      	add	lr, r6
   1553e:	eb0e 0e45 	add.w	lr, lr, r5, lsl #1
   15542:	ea4f 0e6e 	mov.w	lr, lr, asr #1
   15546:	f10e 0e01 	add.w	lr, lr, #1
   1554a:	ea4f 0e6e 	mov.w	lr, lr, asr #1
        LP_mid[ n ] = sum;
        HP_mid[ n ] = mid[ n + 1 ] - sum;
   1554e:	eba5 0c0e 	sub.w	ip, r5, lr
        sum = silk_RSHIFT_ROUND( silk_ADD_LSHIFT( mid[ n ] + (opus_int32)mid[ n + 2 ], mid[ n + 1 ], 1 ), 2 );
   15552:	462b      	mov	r3, r5
   15554:	f932 5014 	ldrsh.w	r5, [r2, r4, lsl #1]
        HP_mid[ n ] = mid[ n + 1 ] - sum;
   15558:	f829 c010 	strh.w	ip, [r9, r0, lsl #1]
        sum = silk_RSHIFT_ROUND( silk_ADD_LSHIFT( mid[ n ] + (opus_int32)mid[ n + 2 ], mid[ n + 1 ], 1 ), 2 );
   1555c:	442b      	add	r3, r5
   1555e:	eb03 0346 	add.w	r3, r3, r6, lsl #1
   15562:	105b      	asrs	r3, r3, #1
   15564:	3301      	adds	r3, #1
   15566:	105b      	asrs	r3, r3, #1
        HP_mid[ n ] = mid[ n + 1 ] - sum;
   15568:	eba6 0c03 	sub.w	ip, r6, r3
        LP_mid[ n ] = sum;
   1556c:	f821 e010 	strh.w	lr, [r1, r0, lsl #1]
        HP_mid[ n ] = mid[ n + 1 ] - sum;
   15570:	f829 c014 	strh.w	ip, [r9, r4, lsl #1]
        LP_mid[ n ] = sum;
   15574:	f821 3014 	strh.w	r3, [r1, r4, lsl #1]
   15578:	3402      	adds	r4, #2
   1557a:	4554      	cmp	r4, sl
   1557c:	f100 0002 	add.w	r0, r0, #2
   15580:	dbd9      	blt.n	15536 <silk_stereo_LR_to_MS+0xd2>
   15582:	6abb      	ldr	r3, [r7, #40]	; 0x28
   15584:	f8d7 4080 	ldr.w	r4, [r7, #128]	; 0x80
   15588:	f100 4500 	add.w	r5, r0, #2147483648	; 0x80000000
   1558c:	3d01      	subs	r5, #1
   1558e:	006d      	lsls	r5, r5, #1
   15590:	1eae      	subs	r6, r5, #2
   15592:	eb03 0e05 	add.w	lr, r3, r5
   15596:	eb01 0c05 	add.w	ip, r1, r5
   1559a:	441e      	add	r6, r3
   1559c:	444d      	add	r5, r9
        sum = silk_RSHIFT_ROUND( silk_ADD_LSHIFT( mid[ n ] + (opus_int32)mid[ n + 2 ], mid[ n + 1 ], 1 ), 2 );
   1559e:	f9b6 8000 	ldrsh.w	r8, [r6]
   155a2:	f93e 3f02 	ldrsh.w	r3, [lr, #2]!
   155a6:	f936 2f02 	ldrsh.w	r2, [r6, #2]!
   155aa:	4443      	add	r3, r8
   155ac:	eb03 0342 	add.w	r3, r3, r2, lsl #1
   155b0:	105b      	asrs	r3, r3, #1
   155b2:	3301      	adds	r3, #1
   155b4:	105b      	asrs	r3, r3, #1
    for( n = 0; n < frame_length; n++ ) {
   155b6:	3001      	adds	r0, #1
        HP_mid[ n ] = mid[ n + 1 ] - sum;
   155b8:	1ad2      	subs	r2, r2, r3
    for( n = 0; n < frame_length; n++ ) {
   155ba:	42a0      	cmp	r0, r4
        HP_mid[ n ] = mid[ n + 1 ] - sum;
   155bc:	f825 2f02 	strh.w	r2, [r5, #2]!
        LP_mid[ n ] = sum;
   155c0:	f82c 3f02 	strh.w	r3, [ip, #2]!
    for( n = 0; n < frame_length; n++ ) {
   155c4:	dbeb      	blt.n	1559e <silk_stereo_LR_to_MS+0x13a>
    }

    /* LP and HP filter side signal */
    ALLOC( LP_side, frame_length, opus_int16 );
   155c6:	693b      	ldr	r3, [r7, #16]
   155c8:	3308      	adds	r3, #8
   155ca:	f023 0307 	bic.w	r3, r3, #7
   155ce:	ebad 0d03 	sub.w	sp, sp, r3
   155d2:	aa02      	add	r2, sp, #8
    ALLOC( HP_side, frame_length, opus_int16 );
   155d4:	ebad 0d03 	sub.w	sp, sp, r3
   155d8:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   155dc:	2b02      	cmp	r3, #2
   155de:	f10d 0808 	add.w	r8, sp, #8
   155e2:	f340 8387 	ble.w	15cf4 <silk_stereo_LR_to_MS+0x890>
   155e6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   155e8:	f9b3 c000 	ldrsh.w	ip, [r3]
   155ec:	f9b3 6002 	ldrsh.w	r6, [r3, #2]
   155f0:	469e      	mov	lr, r3
   155f2:	2501      	movs	r5, #1
    for( n = 0; n < frame_length; n++ ) {
   155f4:	2400      	movs	r4, #0
        sum = silk_RSHIFT_ROUND( silk_ADD_LSHIFT( side[ n ] + (opus_int32)side[ n + 2 ], side[ n + 1 ], 1 ), 2 );
   155f6:	46e3      	mov	fp, ip
   155f8:	f9be c004 	ldrsh.w	ip, [lr, #4]
   155fc:	44e3      	add	fp, ip
   155fe:	eb0b 0b46 	add.w	fp, fp, r6, lsl #1
   15602:	ea4f 0b6b 	mov.w	fp, fp, asr #1
   15606:	f10b 0b01 	add.w	fp, fp, #1
   1560a:	ea4f 0b6b 	mov.w	fp, fp, asr #1
        LP_side[ n ] = sum;
        HP_side[ n ] = side[ n + 1 ] - sum;
   1560e:	eba6 000b 	sub.w	r0, r6, fp
        sum = silk_RSHIFT_ROUND( silk_ADD_LSHIFT( side[ n ] + (opus_int32)side[ n + 2 ], side[ n + 1 ], 1 ), 2 );
   15612:	4633      	mov	r3, r6
   15614:	f9be 6006 	ldrsh.w	r6, [lr, #6]
        HP_side[ n ] = side[ n + 1 ] - sum;
   15618:	f828 0014 	strh.w	r0, [r8, r4, lsl #1]
        sum = silk_RSHIFT_ROUND( silk_ADD_LSHIFT( side[ n ] + (opus_int32)side[ n + 2 ], side[ n + 1 ], 1 ), 2 );
   1561c:	4433      	add	r3, r6
   1561e:	eb03 034c 	add.w	r3, r3, ip, lsl #1
   15622:	105b      	asrs	r3, r3, #1
   15624:	3301      	adds	r3, #1
   15626:	105b      	asrs	r3, r3, #1
        HP_side[ n ] = side[ n + 1 ] - sum;
   15628:	ebac 0003 	sub.w	r0, ip, r3
        LP_side[ n ] = sum;
   1562c:	f822 b014 	strh.w	fp, [r2, r4, lsl #1]
        HP_side[ n ] = side[ n + 1 ] - sum;
   15630:	f828 0015 	strh.w	r0, [r8, r5, lsl #1]
        LP_side[ n ] = sum;
   15634:	f822 3015 	strh.w	r3, [r2, r5, lsl #1]
   15638:	3502      	adds	r5, #2
   1563a:	4555      	cmp	r5, sl
   1563c:	f104 0402 	add.w	r4, r4, #2
   15640:	f10e 0e04 	add.w	lr, lr, #4
   15644:	dbd7      	blt.n	155f6 <silk_stereo_LR_to_MS+0x192>
   15646:	f8d7 5080 	ldr.w	r5, [r7, #128]	; 0x80
   1564a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1564c:	0066      	lsls	r6, r4, #1
   1564e:	f1a6 0c02 	sub.w	ip, r6, #2
   15652:	eb02 0e0c 	add.w	lr, r2, ip
   15656:	441e      	add	r6, r3
   15658:	44c4      	add	ip, r8
        sum = silk_RSHIFT_ROUND( silk_ADD_LSHIFT( side[ n ] + (opus_int32)side[ n + 2 ], side[ n + 1 ], 1 ), 2 );
   1565a:	f9b6 a000 	ldrsh.w	sl, [r6]
   1565e:	f936 0f02 	ldrsh.w	r0, [r6, #2]!
   15662:	f9b6 3002 	ldrsh.w	r3, [r6, #2]
   15666:	4453      	add	r3, sl
   15668:	eb03 0340 	add.w	r3, r3, r0, lsl #1
   1566c:	105b      	asrs	r3, r3, #1
   1566e:	3301      	adds	r3, #1
   15670:	105b      	asrs	r3, r3, #1
   15672:	3401      	adds	r4, #1
        HP_side[ n ] = side[ n + 1 ] - sum;
   15674:	1ac0      	subs	r0, r0, r3
    for( n = 0; n < frame_length; n++ ) {
   15676:	42ac      	cmp	r4, r5
        HP_side[ n ] = side[ n + 1 ] - sum;
   15678:	f82c 0f02 	strh.w	r0, [ip, #2]!
        LP_side[ n ] = sum;
   1567c:	f82e 3f02 	strh.w	r3, [lr, #2]!
    for( n = 0; n < frame_length; n++ ) {
   15680:	dbeb      	blt.n	1565a <silk_stereo_LR_to_MS+0x1f6>
   15682:	f8d7 5080 	ldr.w	r5, [r7, #128]	; 0x80
    }

    /* Find energies and predictors */
    is10msFrame = frame_length == 10 * fs_kHz;
   15686:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
   15688:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
   1568a:	009b      	lsls	r3, r3, #2
   1568c:	181c      	adds	r4, r3, r0
   1568e:	617b      	str	r3, [r7, #20]
    smooth_coef_Q16 = is10msFrame ?
        SILK_FIX_CONST( STEREO_RATIO_SMOOTH_COEF / 2, 16 ) :
        SILK_FIX_CONST( STEREO_RATIO_SMOOTH_COEF,     16 );
    smooth_coef_Q16 = silk_SMULWB( silk_SMULBB( prev_speech_act_Q8, prev_speech_act_Q8 ), smooth_coef_Q16 );
   15690:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    is10msFrame = frame_length == 10 * fs_kHz;
   15692:	0064      	lsls	r4, r4, #1
    smooth_coef_Q16 = silk_SMULWB( silk_SMULBB( prev_speech_act_Q8, prev_speech_act_Q8 ), smooth_coef_Q16 );
   15694:	fb13 f003 	smulbb	r0, r3, r3
        SILK_FIX_CONST( STEREO_RATIO_SMOOTH_COEF / 2, 16 ) :
   15698:	f240 238f 	movw	r3, #655	; 0x28f
   1569c:	42ac      	cmp	r4, r5
   1569e:	bf08      	it	eq
   156a0:	f44f 73a4 	moveq.w	r3, #328	; 0x148
    smooth_coef_Q16 = silk_SMULWB( silk_SMULBB( prev_speech_act_Q8, prev_speech_act_Q8 ), smooth_coef_Q16 );
   156a4:	fa1f fa80 	uxth.w	sl, r0
   156a8:	1400      	asrs	r0, r0, #16
   156aa:	fb03 fa0a 	mul.w	sl, r3, sl
   156ae:	fb03 f300 	mul.w	r3, r3, r0
   156b2:	eb03 4a1a 	add.w	sl, r3, sl, lsr #16

    pred_Q13[ 0 ] = silk_stereo_find_predictor( &LP_ratio_Q14, LP_mid, LP_side, &state->mid_side_amp_Q0[ 0 ], frame_length, smooth_coef_Q16 );
   156b6:	e9cd 5a00 	strd	r5, sl, [sp]
   156ba:	6a3d      	ldr	r5, [r7, #32]
   156bc:	462b      	mov	r3, r5
   156be:	330c      	adds	r3, #12
   156c0:	f107 0030 	add.w	r0, r7, #48	; 0x30
   156c4:	f004 fcee 	bl	1a0a4 <silk_stereo_find_predictor>
    pred_Q13[ 1 ] = silk_stereo_find_predictor( &HP_ratio_Q14, HP_mid, HP_side, &state->mid_side_amp_Q0[ 2 ], frame_length, smooth_coef_Q16 );
   156c8:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
    pred_Q13[ 0 ] = silk_stereo_find_predictor( &LP_ratio_Q14, LP_mid, LP_side, &state->mid_side_amp_Q0[ 0 ], frame_length, smooth_coef_Q16 );
   156cc:	63b8      	str	r0, [r7, #56]	; 0x38
    pred_Q13[ 1 ] = silk_stereo_find_predictor( &HP_ratio_Q14, HP_mid, HP_side, &state->mid_side_amp_Q0[ 2 ], frame_length, smooth_coef_Q16 );
   156ce:	4642      	mov	r2, r8
   156d0:	9300      	str	r3, [sp, #0]
   156d2:	4649      	mov	r1, r9
   156d4:	f105 0314 	add.w	r3, r5, #20
   156d8:	f8cd a004 	str.w	sl, [sp, #4]
   156dc:	f107 0034 	add.w	r0, r7, #52	; 0x34
   156e0:	f004 fce0 	bl	1a0a4 <silk_stereo_find_predictor>
    /* Ratio of the norms of residual and mid signals */
    frac_Q16 = silk_SMLABB( HP_ratio_Q14, LP_ratio_Q14, 3 );
   156e4:	e9d7 320c 	ldrd	r3, r2, [r7, #48]	; 0x30
   156e8:	f04f 0b03 	mov.w	fp, #3
   156ec:	fb13 2b0b 	smlabb	fp, r3, fp, r2
    frac_Q16 = silk_min( frac_Q16, SILK_FIX_CONST( 1, 16 ) );

    /* Determine bitrate distribution between mid and side, and possibly reduce stereo width */
    total_rate_bps -= is10msFrame ? 1200 : 600;      /* Subtract approximate bitrate for coding stereo parameters */
   156f0:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   156f4:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
    pred_Q13[ 1 ] = silk_stereo_find_predictor( &HP_ratio_Q14, HP_mid, HP_side, &state->mid_side_amp_Q0[ 2 ], frame_length, smooth_coef_Q16 );
   156f6:	63f8      	str	r0, [r7, #60]	; 0x3c
    total_rate_bps -= is10msFrame ? 1200 : 600;      /* Subtract approximate bitrate for coding stereo parameters */
   156f8:	429c      	cmp	r4, r3
   156fa:	bf14      	ite	ne
   156fc:	f44f 7416 	movne.w	r4, #600	; 0x258
   15700:	f44f 6496 	moveq.w	r4, #1200	; 0x4b0
   15704:	6f3b      	ldr	r3, [r7, #112]	; 0x70
    frac_Q16 = silk_min( frac_Q16, SILK_FIX_CONST( 1, 16 ) );
   15706:	f5bb 3f80 	cmp.w	fp, #65536	; 0x10000
   1570a:	bfa8      	it	ge
   1570c:	f44f 3b80 	movge.w	fp, #65536	; 0x10000
    total_rate_bps -= is10msFrame ? 1200 : 600;      /* Subtract approximate bitrate for coding stereo parameters */
   15710:	eba3 0904 	sub.w	r9, r3, r4
   15714:	eb0b 064b 	add.w	r6, fp, fp, lsl #1
   15718:	f44f 7516 	mov.w	r5, #600	; 0x258
   1571c:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
    if( total_rate_bps < 1 ) {
   15720:	f1b9 0f00 	cmp.w	r9, #0
    pred_Q13[ 1 ] = silk_stereo_find_predictor( &HP_ratio_Q14, HP_mid, HP_side, &state->mid_side_amp_Q0[ 2 ], frame_length, smooth_coef_Q16 );
   15724:	4680      	mov	r8, r0
   15726:	fb12 3505 	smlabb	r5, r2, r5, r3
   1572a:	f506 2050 	add.w	r0, r6, #851968	; 0xd0000
    if( total_rate_bps < 1 ) {
   1572e:	f340 8151 	ble.w	159d4 <silk_stereo_LR_to_MS+0x570>
   15732:	fab9 fe89 	clz	lr, r9
   15736:	f10e 34ff 	add.w	r4, lr, #4294967295	; 0xffffffff
   1573a:	fa09 f404 	lsl.w	r4, r9, r4
   1573e:	1423      	asrs	r3, r4, #16
   15740:	f10e 0e1c 	add.w	lr, lr, #28
   15744:	61fb      	str	r3, [r7, #28]
   15746:	fa1f fc84 	uxth.w	ip, r4
   1574a:	2800      	cmp	r0, #0
   1574c:	f000 80f7 	beq.w	1593e <silk_stereo_LR_to_MS+0x4da>
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
   15750:	ea80 72e0 	eor.w	r2, r0, r0, asr #31
   15754:	eba2 72e0 	sub.w	r2, r2, r0, asr #31
   15758:	fab2 f282 	clz	r2, r2
   1575c:	3a01      	subs	r2, #1
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                  */
   1575e:	4090      	lsls	r0, r2
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   15760:	1403      	asrs	r3, r0, #16
   15762:	f06f 4160 	mvn.w	r1, #3758096384	; 0xe0000000
   15766:	fb91 f3f3 	sdiv	r3, r1, r3
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1576a:	69f9      	ldr	r1, [r7, #28]
   1576c:	b21b      	sxth	r3, r3
   1576e:	fb01 f103 	mul.w	r1, r1, r3
   15772:	fb0c fc03 	mul.w	ip, ip, r3
   15776:	eb01 4c2c 	add.w	ip, r1, ip, asr #16
    a32_nrm = silk_SUB32_ovflw(a32_nrm, silk_LSHIFT_ovflw( silk_SMMUL(b32_nrm, result), 3 ));  /* Q: a_headrm   */
   1577a:	fb80 010c 	smull	r0, r1, r0, ip
   1577e:	eba4 04c1 	sub.w	r4, r4, r1, lsl #3
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   15782:	b2a1      	uxth	r1, r4
   15784:	1424      	asrs	r4, r4, #16
   15786:	fb03 f101 	mul.w	r1, r3, r1
   1578a:	fb03 f404 	mul.w	r4, r3, r4
    lshift = 29 + a_headrm - b_headrm - Qres;
   1578e:	ebae 0202 	sub.w	r2, lr, r2
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   15792:	eb04 4421 	add.w	r4, r4, r1, asr #16
    if( lshift < 0 ) {
   15796:	f1b2 0313 	subs.w	r3, r2, #19
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1579a:	44a4      	add	ip, r4
    if( lshift < 0 ) {
   1579c:	f100 8126 	bmi.w	159ec <silk_stereo_LR_to_MS+0x588>
        if( lshift < 32){
   157a0:	2b1f      	cmp	r3, #31
            return silk_RSHIFT(result, lshift);
   157a2:	bfd4      	ite	le
   157a4:	fa4c f303 	asrle.w	r3, ip, r3
            return 0;
   157a8:	2300      	movgt	r3, #0
    }
    min_mid_rate_bps = silk_SMLABB( 2000, fs_kHz, 600 );
    silk_assert( min_mid_rate_bps < 32767 );
    /* Default bitrate distribution: 8 parts for Mid and (5+3*frac) parts for Side. so: mid_rate = ( 8 / ( 13 + 3 * frac ) ) * total_ rate */
    frac_3_Q16 = silk_MUL( 3, frac_Q16 );
    mid_side_rates_bps[ 0 ] = silk_DIV32_varQ( total_rate_bps, SILK_FIX_CONST( 8 + 5, 16 ) + frac_3_Q16, 16+3 );
   157aa:	6efa      	ldr	r2, [r7, #108]	; 0x6c
    /* If Mid bitrate below minimum, reduce stereo width */
    if( mid_side_rates_bps[ 0 ] < min_mid_rate_bps ) {
   157ac:	42ab      	cmp	r3, r5
    mid_side_rates_bps[ 0 ] = silk_DIV32_varQ( total_rate_bps, SILK_FIX_CONST( 8 + 5, 16 ) + frac_3_Q16, 16+3 );
   157ae:	6013      	str	r3, [r2, #0]
    if( mid_side_rates_bps[ 0 ] < min_mid_rate_bps ) {
   157b0:	da54      	bge.n	1585c <silk_stereo_LR_to_MS+0x3f8>
        mid_side_rates_bps[ 0 ] = min_mid_rate_bps;
        mid_side_rates_bps[ 1 ] = total_rate_bps - mid_side_rates_bps[ 0 ];
        /* width = 4 * ( 2 * side_rate - min_rate ) / ( ( 1 + 3 * frac ) * min_rate ) */
        width_Q14 = silk_DIV32_varQ( silk_LSHIFT( mid_side_rates_bps[ 1 ], 1 ) - min_mid_rate_bps,
            silk_SMULWB( SILK_FIX_CONST( 1, 16 ) + frac_3_Q16, min_mid_rate_bps ), 14+2 );
   157b2:	b2b1      	uxth	r1, r6
   157b4:	b22a      	sxth	r2, r5
   157b6:	fb02 f201 	mul.w	r2, r2, r1
        mid_side_rates_bps[ 0 ] = min_mid_rate_bps;
   157ba:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
        mid_side_rates_bps[ 1 ] = total_rate_bps - mid_side_rates_bps[ 0 ];
   157bc:	eba9 0005 	sub.w	r0, r9, r5
            silk_SMULWB( SILK_FIX_CONST( 1, 16 ) + frac_3_Q16, min_mid_rate_bps ), 14+2 );
   157c0:	1413      	asrs	r3, r2, #16
        mid_side_rates_bps[ 1 ] = total_rate_bps - mid_side_rates_bps[ 0 ];
   157c2:	6048      	str	r0, [r1, #4]
            silk_SMULWB( SILK_FIX_CONST( 1, 16 ) + frac_3_Q16, min_mid_rate_bps ), 14+2 );
   157c4:	f506 3280 	add.w	r2, r6, #65536	; 0x10000
   157c8:	ebd5 0040 	rsbs	r0, r5, r0, lsl #1
        mid_side_rates_bps[ 0 ] = min_mid_rate_bps;
   157cc:	600d      	str	r5, [r1, #0]
        width_Q14 = silk_DIV32_varQ( silk_LSHIFT( mid_side_rates_bps[ 1 ], 1 ) - min_mid_rate_bps,
   157ce:	fb12 3225 	smlatb	r2, r2, r5, r3
   157d2:	f040 80dd 	bne.w	15990 <silk_stereo_LR_to_MS+0x52c>
   157d6:	231f      	movs	r3, #31
   157d8:	f04f 0e3c 	mov.w	lr, #60	; 0x3c
    a32_nrm = silk_LSHIFT(a32, a_headrm);                                       /* Q: a_headrm                  */
   157dc:	4098      	lsls	r0, r3
   157de:	2a00      	cmp	r2, #0
   157e0:	f000 80e4 	beq.w	159ac <silk_stereo_LR_to_MS+0x548>
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
   157e4:	ea82 74e2 	eor.w	r4, r2, r2, asr #31
   157e8:	eba4 74e2 	sub.w	r4, r4, r2, asr #31
   157ec:	fab4 f484 	clz	r4, r4
   157f0:	3c01      	subs	r4, #1
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                  */
   157f2:	40a2      	lsls	r2, r4
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   157f4:	1411      	asrs	r1, r2, #16
   157f6:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   157fa:	ea4f 4c20 	mov.w	ip, r0, asr #16
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   157fe:	fb93 f1f1 	sdiv	r1, r3, r1
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   15802:	b283      	uxth	r3, r0
   15804:	b209      	sxth	r1, r1
   15806:	fb01 f303 	mul.w	r3, r1, r3
   1580a:	fb01 fc0c 	mul.w	ip, r1, ip
   1580e:	eb0c 4c23 	add.w	ip, ip, r3, asr #16
    a32_nrm = silk_SUB32_ovflw(a32_nrm, silk_LSHIFT_ovflw( silk_SMMUL(b32_nrm, result), 3 ));  /* Q: a_headrm   */
   15812:	fb82 230c 	smull	r2, r3, r2, ip
   15816:	eba0 00c3 	sub.w	r0, r0, r3, lsl #3
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1581a:	b283      	uxth	r3, r0
   1581c:	1400      	asrs	r0, r0, #16
   1581e:	fb01 f303 	mul.w	r3, r1, r3
   15822:	fb01 f000 	mul.w	r0, r1, r0
    lshift = 29 + a_headrm - b_headrm - Qres;
   15826:	ebae 0404 	sub.w	r4, lr, r4
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1582a:	eb00 4023 	add.w	r0, r0, r3, asr #16
    if( lshift < 0 ) {
   1582e:	f1b4 0310 	subs.w	r3, r4, #16
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   15832:	4484      	add	ip, r0
    if( lshift < 0 ) {
   15834:	f100 8231 	bmi.w	15c9a <silk_stereo_LR_to_MS+0x836>
        if( lshift < 32){
   15838:	2b1f      	cmp	r3, #31
   1583a:	f300 822c 	bgt.w	15c96 <silk_stereo_LR_to_MS+0x832>
            return silk_RSHIFT(result, lshift);
   1583e:	fa4c fc03 	asr.w	ip, ip, r3
        width_Q14 = silk_LIMIT( width_Q14, 0, SILK_FIX_CONST( 1, 14 ) );
   15842:	f5bc 4f80 	cmp.w	ip, #16384	; 0x4000
   15846:	f340 8258 	ble.w	15cfa <silk_stereo_LR_to_MS+0x896>
   1584a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
   1584e:	e00a      	b.n	15866 <silk_stereo_LR_to_MS+0x402>
    for( n = 0; n < frame_length + 2; n++ ) {
   15850:	45a6      	cmp	lr, r4
        side[ n ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( diff, 1 ) );
   15852:	f826 8f02 	strh.w	r8, [r6, #2]!
    for( n = 0; n < frame_length + 2; n++ ) {
   15856:	f47f ae2e 	bne.w	154b6 <silk_stereo_LR_to_MS+0x52>
   1585a:	e643      	b.n	154e4 <silk_stereo_LR_to_MS+0x80>
    } else {
        mid_side_rates_bps[ 1 ] = total_rate_bps - mid_side_rates_bps[ 0 ];
   1585c:	eba9 0303 	sub.w	r3, r9, r3
   15860:	6053      	str	r3, [r2, #4]
        width_Q14 = SILK_FIX_CONST( 1, 14 );
   15862:	f44f 4380 	mov.w	r3, #16384	; 0x4000
    }

    /* Smoother */
    state->smth_width_Q14 = (opus_int16)silk_SMLAWB( state->smth_width_Q14, width_Q14 - state->smth_width_Q14, smooth_coef_Q16 );
   15866:	6a38      	ldr	r0, [r7, #32]
   15868:	f9b0 201c 	ldrsh.w	r2, [r0, #28]
   1586c:	1a9b      	subs	r3, r3, r2
   1586e:	b299      	uxth	r1, r3
   15870:	fb13 232a 	smlatb	r3, r3, sl, r2
   15874:	fa0f fa8a 	sxth.w	sl, sl
   15878:	fb0a fa01 	mul.w	sl, sl, r1
   1587c:	eb03 432a 	add.w	r3, r3, sl, asr #16
   15880:	8383      	strh	r3, [r0, #28]

    /* At very low bitrates or for inputs that are nearly amplitude panned, switch to panned-mono coding */
    *mid_only_flag = 0;
   15882:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   15884:	2400      	movs	r4, #0
   15886:	701c      	strb	r4, [r3, #0]
    if( toMono ) {
   15888:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   1588a:	2b00      	cmp	r3, #0
   1588c:	f040 80c0 	bne.w	15a10 <silk_stereo_LR_to_MS+0x5ac>
        /* Last frame before stereo->mono transition; collapse stereo width */
        width_Q14 = 0;
        pred_Q13[ 0 ] = 0;
        pred_Q13[ 1 ] = 0;
        silk_stereo_quant_pred( pred_Q13, ix );
    } else if( state->width_prev_Q14 == 0 &&
   15890:	f9b0 201e 	ldrsh.w	r2, [r0, #30]
   15894:	f9b0 301c 	ldrsh.w	r3, [r0, #28]
   15898:	ea4f 01c9 	mov.w	r1, r9, lsl #3
   1589c:	2a00      	cmp	r2, #0
   1589e:	d150      	bne.n	15942 <silk_stereo_LR_to_MS+0x4de>
        ( 8 * total_rate_bps < 13 * min_mid_rate_bps || silk_SMULWB( frac_Q16, state->smth_width_Q14 ) < SILK_FIX_CONST( 0.05, 14 ) ) )
   158a0:	eb05 0245 	add.w	r2, r5, r5, lsl #1
   158a4:	eb05 0582 	add.w	r5, r5, r2, lsl #2
    } else if( state->width_prev_Q14 == 0 &&
   158a8:	428d      	cmp	r5, r1
   158aa:	dc0d      	bgt.n	158c8 <silk_stereo_LR_to_MS+0x464>
        ( 8 * total_rate_bps < 13 * min_mid_rate_bps || silk_SMULWB( frac_Q16, state->smth_width_Q14 ) < SILK_FIX_CONST( 0.05, 14 ) ) )
   158ac:	fa1f f18b 	uxth.w	r1, fp
   158b0:	ea4f 422b 	mov.w	r2, fp, asr #16
   158b4:	fb03 f101 	mul.w	r1, r3, r1
   158b8:	fb03 f202 	mul.w	r2, r3, r2
   158bc:	eb02 4221 	add.w	r2, r2, r1, asr #16
   158c0:	f240 3132 	movw	r1, #818	; 0x332
   158c4:	428a      	cmp	r2, r1
   158c6:	dc73      	bgt.n	159b0 <silk_stereo_LR_to_MS+0x54c>
    {
        /* Code as panned-mono; previous frame already had zero width */
        /* Scale down and quantize predictors */
        pred_Q13[ 0 ] = silk_RSHIFT( silk_SMULBB( state->smth_width_Q14, pred_Q13[ 0 ] ), 14 );
   158c8:	6bba      	ldr	r2, [r7, #56]	; 0x38
        pred_Q13[ 1 ] = silk_RSHIFT( silk_SMULBB( state->smth_width_Q14, pred_Q13[ 1 ] ), 14 );
        silk_stereo_quant_pred( pred_Q13, ix );
   158ca:	69b9      	ldr	r1, [r7, #24]
        pred_Q13[ 1 ] = silk_RSHIFT( silk_SMULBB( state->smth_width_Q14, pred_Q13[ 1 ] ), 14 );
   158cc:	fb18 f003 	smulbb	r0, r8, r3
        pred_Q13[ 0 ] = silk_RSHIFT( silk_SMULBB( state->smth_width_Q14, pred_Q13[ 0 ] ), 14 );
   158d0:	fb12 f303 	smulbb	r3, r2, r3
   158d4:	139b      	asrs	r3, r3, #14
        pred_Q13[ 1 ] = silk_RSHIFT( silk_SMULBB( state->smth_width_Q14, pred_Q13[ 1 ] ), 14 );
   158d6:	1382      	asrs	r2, r0, #14
        silk_stereo_quant_pred( pred_Q13, ix );
   158d8:	f107 0038 	add.w	r0, r7, #56	; 0x38
        pred_Q13[ 0 ] = silk_RSHIFT( silk_SMULBB( state->smth_width_Q14, pred_Q13[ 0 ] ), 14 );
   158dc:	e9c7 320e 	strd	r3, r2, [r7, #56]	; 0x38
        silk_stereo_quant_pred( pred_Q13, ix );
   158e0:	f004 fda4 	bl	1a42c <silk_stereo_quant_pred>
        /* Collapse stereo width */
        width_Q14 = 0;
        pred_Q13[ 0 ] = 0;
        pred_Q13[ 1 ] = 0;
        mid_side_rates_bps[ 0 ] = total_rate_bps;
   158e4:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
        pred_Q13[ 0 ] = 0;
   158e6:	2300      	movs	r3, #0
        mid_side_rates_bps[ 1 ] = 0;
   158e8:	e9c1 9300 	strd	r9, r3, [r1]
        *mid_only_flag = 1;
   158ec:	469b      	mov	fp, r3
   158ee:	603b      	str	r3, [r7, #0]
        pred_Q13[ 1 ] = 0;
   158f0:	e9c7 330e 	strd	r3, r3, [r7, #56]	; 0x38
        *mid_only_flag = 1;
   158f4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   158f6:	2201      	movs	r2, #1
   158f8:	701a      	strb	r2, [r3, #0]
        width_Q14 = state->smth_width_Q14;
    }

    /* Make sure to keep on encoding until the tapered output has been transmitted */
    if( *mid_only_flag == 1 ) {
        state->silent_side_len += frame_length - STEREO_INTERP_LEN_MS * fs_kHz;
   158fa:	6a39      	ldr	r1, [r7, #32]
   158fc:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
   15900:	8c0b      	ldrh	r3, [r1, #32]
        if( state->silent_side_len < LA_SHAPE_MS * fs_kHz ) {
   15902:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
        state->silent_side_len += frame_length - STEREO_INTERP_LEN_MS * fs_kHz;
   15904:	4413      	add	r3, r2
   15906:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
   15908:	00d5      	lsls	r5, r2, #3
        if( state->silent_side_len < LA_SHAPE_MS * fs_kHz ) {
   1590a:	697a      	ldr	r2, [r7, #20]
        state->silent_side_len += frame_length - STEREO_INTERP_LEN_MS * fs_kHz;
   1590c:	1b5b      	subs	r3, r3, r5
   1590e:	b21b      	sxth	r3, r3
        if( state->silent_side_len < LA_SHAPE_MS * fs_kHz ) {
   15910:	4402      	add	r2, r0
   15912:	4293      	cmp	r3, r2
        state->silent_side_len += frame_length - STEREO_INTERP_LEN_MS * fs_kHz;
   15914:	840b      	strh	r3, [r1, #32]
        if( state->silent_side_len < LA_SHAPE_MS * fs_kHz ) {
   15916:	f280 81a4 	bge.w	15c62 <silk_stereo_LR_to_MS+0x7fe>
            *mid_only_flag = 0;
   1591a:	6eba      	ldr	r2, [r7, #104]	; 0x68
   1591c:	2300      	movs	r3, #0
   1591e:	7013      	strb	r3, [r2, #0]
        }
    } else {
        state->silent_side_len = 0;
    }

    if( *mid_only_flag == 0 && mid_side_rates_bps[ 1 ] < 1 ) {
   15920:	6efb      	ldr	r3, [r7, #108]	; 0x6c
   15922:	685b      	ldr	r3, [r3, #4]
   15924:	2b00      	cmp	r3, #0
   15926:	f300 808f 	bgt.w	15a48 <silk_stereo_LR_to_MS+0x5e4>
        mid_side_rates_bps[ 1 ] = 1;
        mid_side_rates_bps[ 0 ] = silk_max_int( 1, total_rate_bps - mid_side_rates_bps[ 1 ]);
   1592a:	f109 34ff 	add.w	r4, r9, #4294967295	; 0xffffffff
    return (((a) > (b)) ? (a) : (b));
   1592e:	2c01      	cmp	r4, #1
   15930:	6efa      	ldr	r2, [r7, #108]	; 0x6c
   15932:	bfb8      	it	lt
   15934:	2401      	movlt	r4, #1
        mid_side_rates_bps[ 1 ] = 1;
   15936:	2301      	movs	r3, #1
   15938:	e9c2 4300 	strd	r4, r3, [r2]
   1593c:	e084      	b.n	15a48 <silk_stereo_LR_to_MS+0x5e4>
   1593e:	221f      	movs	r2, #31
   15940:	e70d      	b.n	1575e <silk_stereo_LR_to_MS+0x2fa>
        ( 8 * total_rate_bps < 11 * min_mid_rate_bps || silk_SMULWB( frac_Q16, state->smth_width_Q14 ) < SILK_FIX_CONST( 0.02, 14 ) ) )
   15942:	eb05 0285 	add.w	r2, r5, r5, lsl #2
   15946:	eb05 0542 	add.w	r5, r5, r2, lsl #1
    } else if( state->width_prev_Q14 != 0 &&
   1594a:	428d      	cmp	r5, r1
   1594c:	dc0c      	bgt.n	15968 <silk_stereo_LR_to_MS+0x504>
        ( 8 * total_rate_bps < 11 * min_mid_rate_bps || silk_SMULWB( frac_Q16, state->smth_width_Q14 ) < SILK_FIX_CONST( 0.02, 14 ) ) )
   1594e:	fa1f f18b 	uxth.w	r1, fp
   15952:	ea4f 422b 	mov.w	r2, fp, asr #16
   15956:	fb03 f101 	mul.w	r1, r3, r1
   1595a:	fb03 f202 	mul.w	r2, r3, r2
   1595e:	eb02 4221 	add.w	r2, r2, r1, asr #16
   15962:	f5b2 7fa4 	cmp.w	r2, #328	; 0x148
   15966:	da23      	bge.n	159b0 <silk_stereo_LR_to_MS+0x54c>
        pred_Q13[ 0 ] = silk_RSHIFT( silk_SMULBB( state->smth_width_Q14, pred_Q13[ 0 ] ), 14 );
   15968:	6bba      	ldr	r2, [r7, #56]	; 0x38
        silk_stereo_quant_pred( pred_Q13, ix );
   1596a:	69b9      	ldr	r1, [r7, #24]
        pred_Q13[ 1 ] = silk_RSHIFT( silk_SMULBB( state->smth_width_Q14, pred_Q13[ 1 ] ), 14 );
   1596c:	fb18 f003 	smulbb	r0, r8, r3
        pred_Q13[ 0 ] = silk_RSHIFT( silk_SMULBB( state->smth_width_Q14, pred_Q13[ 0 ] ), 14 );
   15970:	fb12 f303 	smulbb	r3, r2, r3
   15974:	139b      	asrs	r3, r3, #14
        pred_Q13[ 1 ] = silk_RSHIFT( silk_SMULBB( state->smth_width_Q14, pred_Q13[ 1 ] ), 14 );
   15976:	1382      	asrs	r2, r0, #14
        silk_stereo_quant_pred( pred_Q13, ix );
   15978:	f107 0038 	add.w	r0, r7, #56	; 0x38
        pred_Q13[ 0 ] = silk_RSHIFT( silk_SMULBB( state->smth_width_Q14, pred_Q13[ 0 ] ), 14 );
   1597c:	e9c7 320e 	strd	r3, r2, [r7, #56]	; 0x38
        silk_stereo_quant_pred( pred_Q13, ix );
   15980:	f004 fd54 	bl	1a42c <silk_stereo_quant_pred>
        pred_Q13[ 0 ] = 0;
   15984:	2300      	movs	r3, #0
        pred_Q13[ 1 ] = 0;
   15986:	469b      	mov	fp, r3
   15988:	603b      	str	r3, [r7, #0]
   1598a:	e9c7 330e 	strd	r3, r3, [r7, #56]	; 0x38
   1598e:	e04a      	b.n	15a26 <silk_stereo_LR_to_MS+0x5c2>
    a_headrm = silk_CLZ32( silk_abs(a32) ) - 1;
   15990:	ea80 7ee0 	eor.w	lr, r0, r0, asr #31
   15994:	ebae 7ee0 	sub.w	lr, lr, r0, asr #31
   15998:	fabe fe8e 	clz	lr, lr
   1599c:	f10e 33ff 	add.w	r3, lr, #4294967295	; 0xffffffff
    a32_nrm = silk_LSHIFT(a32, a_headrm);                                       /* Q: a_headrm                  */
   159a0:	4098      	lsls	r0, r3
   159a2:	f10e 0e1c 	add.w	lr, lr, #28
   159a6:	2a00      	cmp	r2, #0
   159a8:	f47f af1c 	bne.w	157e4 <silk_stereo_LR_to_MS+0x380>
   159ac:	241f      	movs	r4, #31
   159ae:	e720      	b.n	157f2 <silk_stereo_LR_to_MS+0x38e>
    } else if( state->smth_width_Q14 > SILK_FIX_CONST( 0.95, 14 ) ) {
   159b0:	f643 42cd 	movw	r2, #15565	; 0x3ccd
   159b4:	4293      	cmp	r3, r2
   159b6:	f340 8158 	ble.w	15c6a <silk_stereo_LR_to_MS+0x806>
        silk_stereo_quant_pred( pred_Q13, ix );
   159ba:	69b9      	ldr	r1, [r7, #24]
   159bc:	f107 0038 	add.w	r0, r7, #56	; 0x38
   159c0:	f004 fd34 	bl	1a42c <silk_stereo_quant_pred>
   159c4:	f44f 4380 	mov.w	r3, #16384	; 0x4000
   159c8:	603b      	str	r3, [r7, #0]
        width_Q14 = SILK_FIX_CONST( 1, 14 );
   159ca:	469b      	mov	fp, r3
   159cc:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
   159d0:	67bb      	str	r3, [r7, #120]	; 0x78
   159d2:	e028      	b.n	15a26 <silk_stereo_LR_to_MS+0x5c2>
   159d4:	f44f 4380 	mov.w	r3, #16384	; 0x4000
   159d8:	f04f 0e3b 	mov.w	lr, #59	; 0x3b
   159dc:	f04f 0c00 	mov.w	ip, #0
   159e0:	61fb      	str	r3, [r7, #28]
   159e2:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
        total_rate_bps = 1;
   159e6:	f04f 0901 	mov.w	r9, #1
   159ea:	e6ae      	b.n	1574a <silk_stereo_LR_to_MS+0x2e6>
        return silk_LSHIFT_SAT32(result, -lshift);
   159ec:	f1c2 0213 	rsb	r2, r2, #19
   159f0:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
   159f4:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
   159f8:	4114      	asrs	r4, r2
   159fa:	4113      	asrs	r3, r2
   159fc:	429c      	cmp	r4, r3
   159fe:	f300 812c 	bgt.w	15c5a <silk_stereo_LR_to_MS+0x7f6>
   15a02:	459c      	cmp	ip, r3
   15a04:	f340 8163 	ble.w	15cce <silk_stereo_LR_to_MS+0x86a>
   15a08:	469c      	mov	ip, r3
   15a0a:	fa0c f302 	lsl.w	r3, ip, r2
   15a0e:	e6cc      	b.n	157aa <silk_stereo_LR_to_MS+0x346>
        silk_stereo_quant_pred( pred_Q13, ix );
   15a10:	69b9      	ldr	r1, [r7, #24]
   15a12:	67bc      	str	r4, [r7, #120]	; 0x78
   15a14:	f107 0038 	add.w	r0, r7, #56	; 0x38
        pred_Q13[ 1 ] = 0;
   15a18:	e9c7 440e 	strd	r4, r4, [r7, #56]	; 0x38
        silk_stereo_quant_pred( pred_Q13, ix );
   15a1c:	f004 fd06 	bl	1a42c <silk_stereo_quant_pred>
   15a20:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   15a22:	603b      	str	r3, [r7, #0]
        width_Q14 = 0;
   15a24:	469b      	mov	fp, r3
    if( *mid_only_flag == 1 ) {
   15a26:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   15a28:	f993 3000 	ldrsb.w	r3, [r3]
   15a2c:	2b01      	cmp	r3, #1
   15a2e:	f43f af64 	beq.w	158fa <silk_stereo_LR_to_MS+0x496>
   15a32:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
   15a34:	00d5      	lsls	r5, r2, #3
        state->silent_side_len = 0;
   15a36:	6a3a      	ldr	r2, [r7, #32]
   15a38:	2300      	movs	r3, #0
   15a3a:	8413      	strh	r3, [r2, #32]
    if( *mid_only_flag == 0 && mid_side_rates_bps[ 1 ] < 1 ) {
   15a3c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   15a3e:	f993 3000 	ldrsb.w	r3, [r3]
   15a42:	2b00      	cmp	r3, #0
   15a44:	f43f af6c 	beq.w	15920 <silk_stereo_LR_to_MS+0x4bc>
    }

    /* Interpolate predictors and subtract prediction from side channel */
    pred0_Q13  = -state->pred_prev_Q13[ 0 ];
   15a48:	6a3b      	ldr	r3, [r7, #32]
    pred1_Q13  = -state->pred_prev_Q13[ 1 ];
    w_Q24      =  silk_LSHIFT( state->width_prev_Q14, 10 );
    denom_Q16  = silk_DIV32_16( (opus_int32)1 << 16, STEREO_INTERP_LEN_MS * fs_kHz );
    delta0_Q13 = -silk_RSHIFT_ROUND( silk_SMULBB( pred_Q13[ 0 ] - state->pred_prev_Q13[ 0 ], denom_Q16 ), 16 );
   15a4a:	6bb9      	ldr	r1, [r7, #56]	; 0x38
    pred0_Q13  = -state->pred_prev_Q13[ 0 ];
   15a4c:	f9b3 a000 	ldrsh.w	sl, [r3]
    pred1_Q13  = -state->pred_prev_Q13[ 1 ];
   15a50:	f9b3 9002 	ldrsh.w	r9, [r3, #2]
    delta1_Q13 = -silk_RSHIFT_ROUND( silk_SMULBB( pred_Q13[ 1 ] - state->pred_prev_Q13[ 1 ], denom_Q16 ), 16 );
   15a54:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    w_Q24      =  silk_LSHIFT( state->width_prev_Q14, 10 );
   15a56:	f9b3 801e 	ldrsh.w	r8, [r3, #30]
    delta0_Q13 = -silk_RSHIFT_ROUND( silk_SMULBB( pred_Q13[ 0 ] - state->pred_prev_Q13[ 0 ], denom_Q16 ), 16 );
   15a5a:	60f9      	str	r1, [r7, #12]
    denom_Q16  = silk_DIV32_16( (opus_int32)1 << 16, STEREO_INTERP_LEN_MS * fs_kHz );
   15a5c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    delta0_Q13 = -silk_RSHIFT_ROUND( silk_SMULBB( pred_Q13[ 0 ] - state->pred_prev_Q13[ 0 ], denom_Q16 ), 16 );
   15a60:	eba1 010a 	sub.w	r1, r1, sl
    denom_Q16  = silk_DIV32_16( (opus_int32)1 << 16, STEREO_INTERP_LEN_MS * fs_kHz );
   15a64:	fb93 f3f5 	sdiv	r3, r3, r5
    delta0_Q13 = -silk_RSHIFT_ROUND( silk_SMULBB( pred_Q13[ 0 ] - state->pred_prev_Q13[ 0 ], denom_Q16 ), 16 );
   15a68:	b21b      	sxth	r3, r3
   15a6a:	fb11 f103 	smulbb	r1, r1, r3
    delta1_Q13 = -silk_RSHIFT_ROUND( silk_SMULBB( pred_Q13[ 1 ] - state->pred_prev_Q13[ 1 ], denom_Q16 ), 16 );
   15a6e:	60ba      	str	r2, [r7, #8]
   15a70:	eba2 0209 	sub.w	r2, r2, r9
    deltaw_Q24 =  silk_LSHIFT( silk_SMULWB( width_Q14 - state->width_prev_Q14, denom_Q16 ), 10 );
   15a74:	ebab 0b08 	sub.w	fp, fp, r8
    delta1_Q13 = -silk_RSHIFT_ROUND( silk_SMULBB( pred_Q13[ 1 ] - state->pred_prev_Q13[ 1 ], denom_Q16 ), 16 );
   15a78:	fb12 f203 	smulbb	r2, r2, r3
    delta0_Q13 = -silk_RSHIFT_ROUND( silk_SMULBB( pred_Q13[ 0 ] - state->pred_prev_Q13[ 0 ], denom_Q16 ), 16 );
   15a7c:	13c9      	asrs	r1, r1, #15
    deltaw_Q24 =  silk_LSHIFT( silk_SMULWB( width_Q14 - state->width_prev_Q14, denom_Q16 ), 10 );
   15a7e:	fa1f f08b 	uxth.w	r0, fp
    delta1_Q13 = -silk_RSHIFT_ROUND( silk_SMULBB( pred_Q13[ 1 ] - state->pred_prev_Q13[ 1 ], denom_Q16 ), 16 );
   15a82:	13d2      	asrs	r2, r2, #15
    deltaw_Q24 =  silk_LSHIFT( silk_SMULWB( width_Q14 - state->width_prev_Q14, denom_Q16 ), 10 );
   15a84:	ea4f 4b2b 	mov.w	fp, fp, asr #16
    delta0_Q13 = -silk_RSHIFT_ROUND( silk_SMULBB( pred_Q13[ 0 ] - state->pred_prev_Q13[ 0 ], denom_Q16 ), 16 );
   15a88:	3101      	adds	r1, #1
    deltaw_Q24 =  silk_LSHIFT( silk_SMULWB( width_Q14 - state->width_prev_Q14, denom_Q16 ), 10 );
   15a8a:	fb03 f000 	mul.w	r0, r3, r0
   15a8e:	fb03 fb0b 	mul.w	fp, r3, fp
    delta1_Q13 = -silk_RSHIFT_ROUND( silk_SMULBB( pred_Q13[ 1 ] - state->pred_prev_Q13[ 1 ], denom_Q16 ), 16 );
   15a92:	3201      	adds	r2, #1
    delta0_Q13 = -silk_RSHIFT_ROUND( silk_SMULBB( pred_Q13[ 0 ] - state->pred_prev_Q13[ 0 ], denom_Q16 ), 16 );
   15a94:	104b      	asrs	r3, r1, #1
    deltaw_Q24 =  silk_LSHIFT( silk_SMULWB( width_Q14 - state->width_prev_Q14, denom_Q16 ), 10 );
   15a96:	eb0b 4b20 	add.w	fp, fp, r0, asr #16
    delta0_Q13 = -silk_RSHIFT_ROUND( silk_SMULBB( pred_Q13[ 0 ] - state->pred_prev_Q13[ 0 ], denom_Q16 ), 16 );
   15a9a:	61fb      	str	r3, [r7, #28]
    for( n = 0; n < STEREO_INTERP_LEN_MS * fs_kHz; n++ ) {
   15a9c:	2d00      	cmp	r5, #0
    delta1_Q13 = -silk_RSHIFT_ROUND( silk_SMULBB( pred_Q13[ 1 ] - state->pred_prev_Q13[ 1 ], denom_Q16 ), 16 );
   15a9e:	ea4f 0362 	mov.w	r3, r2, asr #1
    pred0_Q13  = -state->pred_prev_Q13[ 0 ];
   15aa2:	f1ca 0a00 	rsb	sl, sl, #0
    delta1_Q13 = -silk_RSHIFT_ROUND( silk_SMULBB( pred_Q13[ 1 ] - state->pred_prev_Q13[ 1 ], denom_Q16 ), 16 );
   15aa6:	61bb      	str	r3, [r7, #24]
    pred1_Q13  = -state->pred_prev_Q13[ 1 ];
   15aa8:	f1c9 0900 	rsb	r9, r9, #0
    w_Q24      =  silk_LSHIFT( state->width_prev_Q14, 10 );
   15aac:	ea4f 2888 	mov.w	r8, r8, lsl #10
    deltaw_Q24 =  silk_LSHIFT( silk_SMULWB( width_Q14 - state->width_prev_Q14, denom_Q16 ), 10 );
   15ab0:	ea4f 2b8b 	mov.w	fp, fp, lsl #10
    for( n = 0; n < STEREO_INTERP_LEN_MS * fs_kHz; n++ ) {
   15ab4:	dd5c      	ble.n	15b70 <silk_stereo_LR_to_MS+0x70c>
   15ab6:	f8c7 b014 	str.w	fp, [r7, #20]
   15aba:	f04f 0c00 	mov.w	ip, #0
   15abe:	f8d7 b004 	ldr.w	fp, [r7, #4]
   15ac2:	e00a      	b.n	15ada <silk_stereo_LR_to_MS+0x676>
        pred1_Q13 += delta1_Q13;
        w_Q24   += deltaw_Q24;
        sum = silk_LSHIFT( silk_ADD_LSHIFT( mid[ n ] + (opus_int32)mid[ n + 2 ], mid[ n + 1 ], 1 ), 9 );    /* Q11 */
        sum = silk_SMLAWB( silk_SMULWB( w_Q24, side[ n + 1 ] ), sum, pred0_Q13 );               /* Q8  */
        sum = silk_SMLAWB( sum, silk_LSHIFT( (opus_int32)mid[ n + 1 ], 11 ), pred1_Q13 );       /* Q8  */
        x2[ n - 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( sum, 8 ) );
   15ac4:	f510 4f00 	cmn.w	r0, #32768	; 0x8000
   15ac8:	f2c0 80c3 	blt.w	15c52 <silk_stereo_LR_to_MS+0x7ee>
   15acc:	b200      	sxth	r0, r0
   15ace:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   15ad0:	441c      	add	r4, r3
    for( n = 0; n < STEREO_INTERP_LEN_MS * fs_kHz; n++ ) {
   15ad2:	4565      	cmp	r5, ip
        x2[ n - 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( sum, 8 ) );
   15ad4:	f824 0c02 	strh.w	r0, [r4, #-2]
    for( n = 0; n < STEREO_INTERP_LEN_MS * fs_kHz; n++ ) {
   15ad8:	dd4a      	ble.n	15b70 <silk_stereo_LR_to_MS+0x70c>
        sum = silk_LSHIFT( silk_ADD_LSHIFT( mid[ n ] + (opus_int32)mid[ n + 2 ], mid[ n + 1 ], 1 ), 9 );    /* Q11 */
   15ada:	ea4f 044c 	mov.w	r4, ip, lsl #1
   15ade:	eb0b 0304 	add.w	r3, fp, r4
   15ae2:	6aba      	ldr	r2, [r7, #40]	; 0x28
   15ae4:	f9b3 1002 	ldrsh.w	r1, [r3, #2]
   15ae8:	69fb      	ldr	r3, [r7, #28]
   15aea:	f932 001c 	ldrsh.w	r0, [r2, ip, lsl #1]
   15aee:	f93b 601c 	ldrsh.w	r6, [fp, ip, lsl #1]
   15af2:	ebaa 0a03 	sub.w	sl, sl, r3
        w_Q24   += deltaw_Q24;
   15af6:	697b      	ldr	r3, [r7, #20]
        sum = silk_SMLAWB( silk_SMULWB( w_Q24, side[ n + 1 ] ), sum, pred0_Q13 );               /* Q8  */
   15af8:	f10c 0c01 	add.w	ip, ip, #1
        w_Q24   += deltaw_Q24;
   15afc:	4498      	add	r8, r3
        sum = silk_SMLAWB( silk_SMULWB( w_Q24, side[ n + 1 ] ), sum, pred0_Q13 );               /* Q8  */
   15afe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
        sum = silk_LSHIFT( silk_ADD_LSHIFT( mid[ n ] + (opus_int32)mid[ n + 2 ], mid[ n + 1 ], 1 ), 9 );    /* Q11 */
   15b00:	4430      	add	r0, r6
        sum = silk_SMLAWB( silk_SMULWB( w_Q24, side[ n + 1 ] ), sum, pred0_Q13 );               /* Q8  */
   15b02:	f933 201c 	ldrsh.w	r2, [r3, ip, lsl #1]
   15b06:	69bb      	ldr	r3, [r7, #24]
        sum = silk_LSHIFT( silk_ADD_LSHIFT( mid[ n ] + (opus_int32)mid[ n + 2 ], mid[ n + 1 ], 1 ), 9 );    /* Q11 */
   15b08:	eb00 0041 	add.w	r0, r0, r1, lsl #1
   15b0c:	0240      	lsls	r0, r0, #9
        sum = silk_SMLAWB( silk_SMULWB( w_Q24, side[ n + 1 ] ), sum, pred0_Q13 );               /* Q8  */
   15b0e:	1406      	asrs	r6, r0, #16
   15b10:	eba9 0903 	sub.w	r9, r9, r3
   15b14:	b283      	uxth	r3, r0
   15b16:	fa0f f08a 	sxth.w	r0, sl
   15b1a:	fb00 f303 	mul.w	r3, r0, r3
        sum = silk_SMLAWB( sum, silk_LSHIFT( (opus_int32)mid[ n + 1 ], 11 ), pred1_Q13 );       /* Q8  */
   15b1e:	02c9      	lsls	r1, r1, #11
        sum = silk_SMLAWB( silk_SMULWB( w_Q24, side[ n + 1 ] ), sum, pred0_Q13 );               /* Q8  */
   15b20:	fb00 f006 	mul.w	r0, r0, r6
   15b24:	fa1f fe88 	uxth.w	lr, r8
   15b28:	ea4f 4628 	mov.w	r6, r8, asr #16
   15b2c:	fb02 fe0e 	mul.w	lr, r2, lr
   15b30:	eb00 4023 	add.w	r0, r0, r3, asr #16
   15b34:	fb02 f206 	mul.w	r2, r2, r6
        sum = silk_SMLAWB( sum, silk_LSHIFT( (opus_int32)mid[ n + 1 ], 11 ), pred1_Q13 );       /* Q8  */
   15b38:	fa0f f389 	sxth.w	r3, r9
   15b3c:	b28e      	uxth	r6, r1
   15b3e:	1409      	asrs	r1, r1, #16
        sum = silk_SMLAWB( silk_SMULWB( w_Q24, side[ n + 1 ] ), sum, pred0_Q13 );               /* Q8  */
   15b40:	eb02 422e 	add.w	r2, r2, lr, asr #16
        sum = silk_SMLAWB( sum, silk_LSHIFT( (opus_int32)mid[ n + 1 ], 11 ), pred1_Q13 );       /* Q8  */
   15b44:	fb03 f606 	mul.w	r6, r3, r6
   15b48:	fb03 f101 	mul.w	r1, r3, r1
        sum = silk_SMLAWB( silk_SMULWB( w_Q24, side[ n + 1 ] ), sum, pred0_Q13 );               /* Q8  */
   15b4c:	4410      	add	r0, r2
        sum = silk_SMLAWB( sum, silk_LSHIFT( (opus_int32)mid[ n + 1 ], 11 ), pred1_Q13 );       /* Q8  */
   15b4e:	eb01 4626 	add.w	r6, r1, r6, asr #16
   15b52:	4430      	add	r0, r6
        x2[ n - 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( sum, 8 ) );
   15b54:	11c0      	asrs	r0, r0, #7
   15b56:	3001      	adds	r0, #1
   15b58:	1040      	asrs	r0, r0, #1
   15b5a:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
   15b5e:	dbb1      	blt.n	15ac4 <silk_stereo_LR_to_MS+0x660>
   15b60:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   15b62:	441c      	add	r4, r3
   15b64:	f647 70ff 	movw	r0, #32767	; 0x7fff
    for( n = 0; n < STEREO_INTERP_LEN_MS * fs_kHz; n++ ) {
   15b68:	4565      	cmp	r5, ip
        x2[ n - 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( sum, 8 ) );
   15b6a:	f824 0c02 	strh.w	r0, [r4, #-2]
    for( n = 0; n < STEREO_INTERP_LEN_MS * fs_kHz; n++ ) {
   15b6e:	dcb4      	bgt.n	15ada <silk_stereo_LR_to_MS+0x676>
    }

    pred0_Q13 = -pred_Q13[ 0 ];
   15b70:	68fb      	ldr	r3, [r7, #12]
   15b72:	f1c3 0800 	rsb	r8, r3, #0
    pred1_Q13 = -pred_Q13[ 1 ];
   15b76:	68bb      	ldr	r3, [r7, #8]
   15b78:	f1c3 0e00 	rsb	lr, r3, #0
    w_Q24     =  silk_LSHIFT( width_Q14, 10 );
    for( n = STEREO_INTERP_LEN_MS * fs_kHz; n < frame_length; n++ ) {
   15b7c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   15b80:	429d      	cmp	r5, r3
   15b82:	da5b      	bge.n	15c3c <silk_stereo_LR_to_MS+0x7d8>
   15b84:	6aba      	ldr	r2, [r7, #40]	; 0x28
   15b86:	693b      	ldr	r3, [r7, #16]
   15b88:	4413      	add	r3, r2
   15b8a:	f105 4600 	add.w	r6, r5, #2147483648	; 0x80000000
   15b8e:	3b02      	subs	r3, #2
   15b90:	3e02      	subs	r6, #2
   15b92:	62bb      	str	r3, [r7, #40]	; 0x28
   15b94:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   15b96:	0076      	lsls	r6, r6, #1
   15b98:	4433      	add	r3, r6
   15b9a:	4699      	mov	r9, r3
   15b9c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   15b9e:	f105 4c00 	add.w	ip, r5, #2147483648	; 0x80000000
   15ba2:	3501      	adds	r5, #1
   15ba4:	eb03 0545 	add.w	r5, r3, r5, lsl #1
        sum = silk_LSHIFT( silk_ADD_LSHIFT( mid[ n ] + (opus_int32)mid[ n + 2 ], mid[ n + 1 ], 1 ), 9 );    /* Q11 */
        sum = silk_SMLAWB( silk_SMULWB( w_Q24, side[ n + 1 ] ), sum, pred0_Q13 );               /* Q8  */
   15ba8:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   15baa:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
   15bae:	fa0f f888 	sxth.w	r8, r8
   15bb2:	fa0f fe8e 	sxth.w	lr, lr
   15bb6:	4416      	add	r6, r2
   15bb8:	eb02 0c4c 	add.w	ip, r2, ip, lsl #1
   15bbc:	ea4f 4b23 	mov.w	fp, r3, asr #16
   15bc0:	fa1f fa83 	uxth.w	sl, r3
   15bc4:	e008      	b.n	15bd8 <silk_stereo_LR_to_MS+0x774>
        sum = silk_SMLAWB( sum, silk_LSHIFT( (opus_int32)mid[ n + 1 ], 11 ), pred1_Q13 );       /* Q8  */
        x2[ n - 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( sum, 8 ) );
   15bc6:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   15bca:	db44      	blt.n	15c56 <silk_stereo_LR_to_MS+0x7f2>
   15bcc:	b21b      	sxth	r3, r3
   15bce:	f829 3f02 	strh.w	r3, [r9, #2]!
    for( n = STEREO_INTERP_LEN_MS * fs_kHz; n < frame_length; n++ ) {
   15bd2:	6abb      	ldr	r3, [r7, #40]	; 0x28
   15bd4:	459c      	cmp	ip, r3
   15bd6:	d031      	beq.n	15c3c <silk_stereo_LR_to_MS+0x7d8>
        sum = silk_LSHIFT( silk_ADD_LSHIFT( mid[ n ] + (opus_int32)mid[ n + 2 ], mid[ n + 1 ], 1 ), 9 );    /* Q11 */
   15bd8:	f9b6 0000 	ldrsh.w	r0, [r6]
   15bdc:	f93c 2f02 	ldrsh.w	r2, [ip, #2]!
   15be0:	f936 3f02 	ldrsh.w	r3, [r6, #2]!
        sum = silk_SMLAWB( silk_SMULWB( w_Q24, side[ n + 1 ] ), sum, pred0_Q13 );               /* Q8  */
   15be4:	f935 1b02 	ldrsh.w	r1, [r5], #2
        sum = silk_LSHIFT( silk_ADD_LSHIFT( mid[ n ] + (opus_int32)mid[ n + 2 ], mid[ n + 1 ], 1 ), 9 );    /* Q11 */
   15be8:	4402      	add	r2, r0
   15bea:	eb02 0243 	add.w	r2, r2, r3, lsl #1
   15bee:	0252      	lsls	r2, r2, #9
        sum = silk_SMLAWB( silk_SMULWB( w_Q24, side[ n + 1 ] ), sum, pred0_Q13 );               /* Q8  */
   15bf0:	b290      	uxth	r0, r2
   15bf2:	1412      	asrs	r2, r2, #16
        sum = silk_SMLAWB( sum, silk_LSHIFT( (opus_int32)mid[ n + 1 ], 11 ), pred1_Q13 );       /* Q8  */
   15bf4:	02db      	lsls	r3, r3, #11
        sum = silk_SMLAWB( silk_SMULWB( w_Q24, side[ n + 1 ] ), sum, pred0_Q13 );               /* Q8  */
   15bf6:	fb08 f000 	mul.w	r0, r8, r0
   15bfa:	fb08 f202 	mul.w	r2, r8, r2
   15bfe:	fb01 f40a 	mul.w	r4, r1, sl
   15c02:	eb02 4220 	add.w	r2, r2, r0, asr #16
   15c06:	fb01 f10b 	mul.w	r1, r1, fp
        sum = silk_SMLAWB( sum, silk_LSHIFT( (opus_int32)mid[ n + 1 ], 11 ), pred1_Q13 );       /* Q8  */
   15c0a:	b298      	uxth	r0, r3
   15c0c:	141b      	asrs	r3, r3, #16
        sum = silk_SMLAWB( silk_SMULWB( w_Q24, side[ n + 1 ] ), sum, pred0_Q13 );               /* Q8  */
   15c0e:	eb01 4124 	add.w	r1, r1, r4, asr #16
        sum = silk_SMLAWB( sum, silk_LSHIFT( (opus_int32)mid[ n + 1 ], 11 ), pred1_Q13 );       /* Q8  */
   15c12:	fb0e f000 	mul.w	r0, lr, r0
   15c16:	fb0e f303 	mul.w	r3, lr, r3
        sum = silk_SMLAWB( silk_SMULWB( w_Q24, side[ n + 1 ] ), sum, pred0_Q13 );               /* Q8  */
   15c1a:	4411      	add	r1, r2
        sum = silk_SMLAWB( sum, silk_LSHIFT( (opus_int32)mid[ n + 1 ], 11 ), pred1_Q13 );       /* Q8  */
   15c1c:	eb03 4320 	add.w	r3, r3, r0, asr #16
   15c20:	440b      	add	r3, r1
        x2[ n - 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( sum, 8 ) );
   15c22:	11db      	asrs	r3, r3, #7
   15c24:	3301      	adds	r3, #1
   15c26:	105b      	asrs	r3, r3, #1
   15c28:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   15c2c:	dbcb      	blt.n	15bc6 <silk_stereo_LR_to_MS+0x762>
   15c2e:	f647 73ff 	movw	r3, #32767	; 0x7fff
   15c32:	f829 3f02 	strh.w	r3, [r9, #2]!
    for( n = STEREO_INTERP_LEN_MS * fs_kHz; n < frame_length; n++ ) {
   15c36:	6abb      	ldr	r3, [r7, #40]	; 0x28
   15c38:	459c      	cmp	ip, r3
   15c3a:	d1cd      	bne.n	15bd8 <silk_stereo_LR_to_MS+0x774>
    }
    state->pred_prev_Q13[ 0 ] = (opus_int16)pred_Q13[ 0 ];
   15c3c:	6a3b      	ldr	r3, [r7, #32]
   15c3e:	68f9      	ldr	r1, [r7, #12]
    state->pred_prev_Q13[ 1 ] = (opus_int16)pred_Q13[ 1 ];
    state->width_prev_Q14     = (opus_int16)width_Q14;
   15c40:	683a      	ldr	r2, [r7, #0]
    state->pred_prev_Q13[ 0 ] = (opus_int16)pred_Q13[ 0 ];
   15c42:	8019      	strh	r1, [r3, #0]
    state->pred_prev_Q13[ 1 ] = (opus_int16)pred_Q13[ 1 ];
   15c44:	68b9      	ldr	r1, [r7, #8]
   15c46:	8059      	strh	r1, [r3, #2]
    RESTORE_STACK;
}
   15c48:	3744      	adds	r7, #68	; 0x44
    state->width_prev_Q14     = (opus_int16)width_Q14;
   15c4a:	83da      	strh	r2, [r3, #30]
}
   15c4c:	46bd      	mov	sp, r7
   15c4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        x2[ n - 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( sum, 8 ) );
   15c52:	482e      	ldr	r0, [pc, #184]	; (15d0c <silk_stereo_LR_to_MS+0x8a8>)
   15c54:	e73b      	b.n	15ace <silk_stereo_LR_to_MS+0x66a>
        x2[ n - 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( sum, 8 ) );
   15c56:	4b2d      	ldr	r3, [pc, #180]	; (15d0c <silk_stereo_LR_to_MS+0x8a8>)
   15c58:	e7b9      	b.n	15bce <silk_stereo_LR_to_MS+0x76a>
   15c5a:	45a4      	cmp	ip, r4
   15c5c:	dd3b      	ble.n	15cd6 <silk_stereo_LR_to_MS+0x872>
   15c5e:	46a4      	mov	ip, r4
   15c60:	e6d3      	b.n	15a0a <silk_stereo_LR_to_MS+0x5a6>
            state->silent_side_len = 10000;
   15c62:	f242 7310 	movw	r3, #10000	; 0x2710
   15c66:	840b      	strh	r3, [r1, #32]
   15c68:	e6e8      	b.n	15a3c <silk_stereo_LR_to_MS+0x5d8>
        pred_Q13[ 0 ] = silk_RSHIFT( silk_SMULBB( state->smth_width_Q14, pred_Q13[ 0 ] ), 14 );
   15c6a:	6bb9      	ldr	r1, [r7, #56]	; 0x38
        pred_Q13[ 1 ] = silk_RSHIFT( silk_SMULBB( state->smth_width_Q14, pred_Q13[ 1 ] ), 14 );
   15c6c:	fb18 f203 	smulbb	r2, r8, r3
        pred_Q13[ 0 ] = silk_RSHIFT( silk_SMULBB( state->smth_width_Q14, pred_Q13[ 0 ] ), 14 );
   15c70:	fb11 f303 	smulbb	r3, r1, r3
   15c74:	139b      	asrs	r3, r3, #14
        pred_Q13[ 1 ] = silk_RSHIFT( silk_SMULBB( state->smth_width_Q14, pred_Q13[ 1 ] ), 14 );
   15c76:	1392      	asrs	r2, r2, #14
        silk_stereo_quant_pred( pred_Q13, ix );
   15c78:	69b9      	ldr	r1, [r7, #24]
   15c7a:	f107 0038 	add.w	r0, r7, #56	; 0x38
        pred_Q13[ 0 ] = silk_RSHIFT( silk_SMULBB( state->smth_width_Q14, pred_Q13[ 0 ] ), 14 );
   15c7e:	e9c7 320e 	strd	r3, r2, [r7, #56]	; 0x38
        silk_stereo_quant_pred( pred_Q13, ix );
   15c82:	f004 fbd3 	bl	1a42c <silk_stereo_quant_pred>
        width_Q14 = state->smth_width_Q14;
   15c86:	6a3b      	ldr	r3, [r7, #32]
   15c88:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
   15c8c:	603b      	str	r3, [r7, #0]
   15c8e:	469b      	mov	fp, r3
   15c90:	029b      	lsls	r3, r3, #10
   15c92:	67bb      	str	r3, [r7, #120]	; 0x78
   15c94:	e6c7      	b.n	15a26 <silk_stereo_LR_to_MS+0x5c2>
        if( lshift < 32){
   15c96:	2300      	movs	r3, #0
   15c98:	e5e5      	b.n	15866 <silk_stereo_LR_to_MS+0x402>
        return silk_LSHIFT_SAT32(result, -lshift);
   15c9a:	f1c4 0410 	rsb	r4, r4, #16
   15c9e:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   15ca2:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
   15ca6:	4123      	asrs	r3, r4
   15ca8:	4122      	asrs	r2, r4
   15caa:	4293      	cmp	r3, r2
   15cac:	dd17      	ble.n	15cde <silk_stereo_LR_to_MS+0x87a>
   15cae:	459c      	cmp	ip, r3
   15cb0:	dd28      	ble.n	15d04 <silk_stereo_LR_to_MS+0x8a0>
   15cb2:	469c      	mov	ip, r3
   15cb4:	e018      	b.n	15ce8 <silk_stereo_LR_to_MS+0x884>
    ALLOC( LP_side, frame_length, opus_int16 );
   15cb6:	ebad 0d05 	sub.w	sp, sp, r5
   15cba:	aa02      	add	r2, sp, #8
    ALLOC( HP_side, frame_length, opus_int16 );
   15cbc:	ebad 0d05 	sub.w	sp, sp, r5
   15cc0:	f10d 0808 	add.w	r8, sp, #8
   15cc4:	461d      	mov	r5, r3
   15cc6:	e4de      	b.n	15686 <silk_stereo_LR_to_MS+0x222>
   15cc8:	1f2b      	subs	r3, r5, #4
   15cca:	613b      	str	r3, [r7, #16]
   15ccc:	e40a      	b.n	154e4 <silk_stereo_LR_to_MS+0x80>
   15cce:	45a4      	cmp	ip, r4
   15cd0:	bfb8      	it	lt
   15cd2:	46a4      	movlt	ip, r4
   15cd4:	e699      	b.n	15a0a <silk_stereo_LR_to_MS+0x5a6>
   15cd6:	459c      	cmp	ip, r3
   15cd8:	bfb8      	it	lt
   15cda:	469c      	movlt	ip, r3
   15cdc:	e695      	b.n	15a0a <silk_stereo_LR_to_MS+0x5a6>
   15cde:	4594      	cmp	ip, r2
   15ce0:	dc0e      	bgt.n	15d00 <silk_stereo_LR_to_MS+0x89c>
   15ce2:	459c      	cmp	ip, r3
   15ce4:	bfb8      	it	lt
   15ce6:	469c      	movlt	ip, r3
   15ce8:	fa0c fc04 	lsl.w	ip, ip, r4
   15cec:	e5a9      	b.n	15842 <silk_stereo_LR_to_MS+0x3de>
    for( n = 0; n < frame_length; n++ ) {
   15cee:	2000      	movs	r0, #0
   15cf0:	4633      	mov	r3, r6
   15cf2:	e447      	b.n	15584 <silk_stereo_LR_to_MS+0x120>
    ALLOC( HP_side, frame_length, opus_int16 );
   15cf4:	2400      	movs	r4, #0
   15cf6:	461d      	mov	r5, r3
   15cf8:	e4a7      	b.n	1564a <silk_stereo_LR_to_MS+0x1e6>
   15cfa:	ea2c 73ec 	bic.w	r3, ip, ip, asr #31
   15cfe:	e5b2      	b.n	15866 <silk_stereo_LR_to_MS+0x402>
   15d00:	4694      	mov	ip, r2
   15d02:	e7f1      	b.n	15ce8 <silk_stereo_LR_to_MS+0x884>
   15d04:	4594      	cmp	ip, r2
   15d06:	bfb8      	it	lt
   15d08:	4694      	movlt	ip, r2
   15d0a:	e7ed      	b.n	15ce8 <silk_stereo_LR_to_MS+0x884>
   15d0c:	ffff8000 	.word	0xffff8000

00015d10 <check_control_input>:
    silk_EncControlStruct        *encControl                    /* I    Control structure                           */
)
{
    celt_assert( encControl != NULL );

    if( ( ( encControl->API_sampleRate            !=  8000 ) &&
   15d10:	6883      	ldr	r3, [r0, #8]
   15d12:	f5b3 5ffa 	cmp.w	r3, #8000	; 0x1f40
   15d16:	d015      	beq.n	15d44 <check_control_input+0x34>
   15d18:	f642 62e0 	movw	r2, #12000	; 0x2ee0
   15d1c:	4293      	cmp	r3, r2
   15d1e:	d011      	beq.n	15d44 <check_control_input+0x34>
          ( encControl->API_sampleRate            != 12000 ) &&
   15d20:	f5b3 5f7a 	cmp.w	r3, #16000	; 0x3e80
   15d24:	d00e      	beq.n	15d44 <check_control_input+0x34>
          ( encControl->API_sampleRate            != 16000 ) &&
   15d26:	f645 52c0 	movw	r2, #24000	; 0x5dc0
   15d2a:	4293      	cmp	r3, r2
   15d2c:	d00a      	beq.n	15d44 <check_control_input+0x34>
          ( encControl->API_sampleRate            != 24000 ) &&
   15d2e:	f5b3 4ffa 	cmp.w	r3, #32000	; 0x7d00
   15d32:	d007      	beq.n	15d44 <check_control_input+0x34>
          ( encControl->API_sampleRate            != 32000 ) &&
   15d34:	f64a 4244 	movw	r2, #44100	; 0xac44
   15d38:	4293      	cmp	r3, r2
   15d3a:	d003      	beq.n	15d44 <check_control_input+0x34>
          ( encControl->API_sampleRate            != 44100 ) &&
   15d3c:	f64b 3280 	movw	r2, #48000	; 0xbb80
   15d40:	4293      	cmp	r3, r2
   15d42:	d15a      	bne.n	15dfa <check_control_input+0xea>
          ( encControl->API_sampleRate            != 48000 ) ) ||
        ( ( encControl->desiredInternalSampleRate !=  8000 ) &&
   15d44:	6943      	ldr	r3, [r0, #20]
          ( encControl->API_sampleRate            != 48000 ) ) ||
   15d46:	f5b3 5ffa 	cmp.w	r3, #8000	; 0x1f40
   15d4a:	d006      	beq.n	15d5a <check_control_input+0x4a>
        ( ( encControl->desiredInternalSampleRate !=  8000 ) &&
   15d4c:	f642 62e0 	movw	r2, #12000	; 0x2ee0
   15d50:	4293      	cmp	r3, r2
   15d52:	d002      	beq.n	15d5a <check_control_input+0x4a>
          ( encControl->desiredInternalSampleRate != 12000 ) &&
   15d54:	f5b3 5f7a 	cmp.w	r3, #16000	; 0x3e80
   15d58:	d14f      	bne.n	15dfa <check_control_input+0xea>
          ( encControl->desiredInternalSampleRate != 16000 ) ) ||
        ( ( encControl->maxInternalSampleRate     !=  8000 ) &&
   15d5a:	68c2      	ldr	r2, [r0, #12]
          ( encControl->desiredInternalSampleRate != 16000 ) ) ||
   15d5c:	f5b2 5ffa 	cmp.w	r2, #8000	; 0x1f40
   15d60:	d006      	beq.n	15d70 <check_control_input+0x60>
        ( ( encControl->maxInternalSampleRate     !=  8000 ) &&
   15d62:	f642 61e0 	movw	r1, #12000	; 0x2ee0
   15d66:	428a      	cmp	r2, r1
   15d68:	d002      	beq.n	15d70 <check_control_input+0x60>
          ( encControl->maxInternalSampleRate     != 12000 ) &&
   15d6a:	f5b2 5f7a 	cmp.w	r2, #16000	; 0x3e80
   15d6e:	d144      	bne.n	15dfa <check_control_input+0xea>
          ( encControl->maxInternalSampleRate     != 16000 ) ) ||
        ( ( encControl->minInternalSampleRate     !=  8000 ) &&
   15d70:	6901      	ldr	r1, [r0, #16]
          ( encControl->maxInternalSampleRate     != 16000 ) ) ||
   15d72:	f5b1 5ffa 	cmp.w	r1, #8000	; 0x1f40
{
   15d76:	b410      	push	{r4}
          ( encControl->maxInternalSampleRate     != 16000 ) ) ||
   15d78:	d006      	beq.n	15d88 <check_control_input+0x78>
        ( ( encControl->minInternalSampleRate     !=  8000 ) &&
   15d7a:	f642 64e0 	movw	r4, #12000	; 0x2ee0
   15d7e:	42a1      	cmp	r1, r4
   15d80:	d002      	beq.n	15d88 <check_control_input+0x78>
          ( encControl->minInternalSampleRate     != 12000 ) &&
   15d82:	f5b1 5f7a 	cmp.w	r1, #16000	; 0x3e80
   15d86:	d132      	bne.n	15dee <check_control_input+0xde>
          ( encControl->minInternalSampleRate     != 16000 ) ) ||
   15d88:	428b      	cmp	r3, r1
   15d8a:	db30      	blt.n	15dee <check_control_input+0xde>
          ( encControl->minInternalSampleRate > encControl->desiredInternalSampleRate ) ||
   15d8c:	4293      	cmp	r3, r2
   15d8e:	dc2e      	bgt.n	15dee <check_control_input+0xde>
          ( encControl->maxInternalSampleRate < encControl->desiredInternalSampleRate ) ||
          ( encControl->minInternalSampleRate > encControl->maxInternalSampleRate ) ) {
        celt_assert( 0 );
        return SILK_ENC_FS_NOT_SUPPORTED;
    }
    if( encControl->payloadSize_ms != 10 &&
   15d90:	6983      	ldr	r3, [r0, #24]
   15d92:	f1a3 020a 	sub.w	r2, r3, #10
   15d96:	2a1e      	cmp	r2, #30
   15d98:	d822      	bhi.n	15de0 <check_control_input+0xd0>
   15d9a:	4b1f      	ldr	r3, [pc, #124]	; (15e18 <check_control_input+0x108>)
   15d9c:	40d3      	lsrs	r3, r2
   15d9e:	07db      	lsls	r3, r3, #31
   15da0:	d520      	bpl.n	15de4 <check_control_input+0xd4>
        encControl->payloadSize_ms != 40 &&
        encControl->payloadSize_ms != 60 ) {
        celt_assert( 0 );
        return SILK_ENC_PACKET_SIZE_NOT_SUPPORTED;
    }
    if( encControl->packetLossPercentage < 0 || encControl->packetLossPercentage > 100 ) {
   15da2:	6a03      	ldr	r3, [r0, #32]
   15da4:	2b64      	cmp	r3, #100	; 0x64
   15da6:	d834      	bhi.n	15e12 <check_control_input+0x102>
        celt_assert( 0 );
        return SILK_ENC_INVALID_LOSS_RATE;
    }
    if( encControl->useDTX < 0 || encControl->useDTX > 1 ) {
   15da8:	6b03      	ldr	r3, [r0, #48]	; 0x30
   15daa:	2b01      	cmp	r3, #1
   15dac:	d828      	bhi.n	15e00 <check_control_input+0xf0>
        celt_assert( 0 );
        return SILK_ENC_INVALID_DTX_SETTING;
    }
    if( encControl->useCBR < 0 || encControl->useCBR > 1 ) {
   15dae:	6b43      	ldr	r3, [r0, #52]	; 0x34
   15db0:	2b01      	cmp	r3, #1
   15db2:	d828      	bhi.n	15e06 <check_control_input+0xf6>
        celt_assert( 0 );
        return SILK_ENC_INVALID_CBR_SETTING;
    }
    if( encControl->useInBandFEC < 0 || encControl->useInBandFEC > 1 ) {
   15db4:	6a83      	ldr	r3, [r0, #40]	; 0x28
   15db6:	2b01      	cmp	r3, #1
   15db8:	d828      	bhi.n	15e0c <check_control_input+0xfc>
        celt_assert( 0 );
        return SILK_ENC_INVALID_INBAND_FEC_SETTING;
    }
    if( encControl->nChannelsAPI < 1 || encControl->nChannelsAPI > ENCODER_NUM_CHANNELS ) {
   15dba:	6803      	ldr	r3, [r0, #0]
   15dbc:	1e5a      	subs	r2, r3, #1
   15dbe:	2a01      	cmp	r2, #1
   15dc0:	d818      	bhi.n	15df4 <check_control_input+0xe4>
        celt_assert( 0 );
        return SILK_ENC_INVALID_NUMBER_OF_CHANNELS_ERROR;
    }
    if( encControl->nChannelsInternal < 1 || encControl->nChannelsInternal > ENCODER_NUM_CHANNELS ) {
   15dc2:	6842      	ldr	r2, [r0, #4]
   15dc4:	1e51      	subs	r1, r2, #1
   15dc6:	2901      	cmp	r1, #1
   15dc8:	d814      	bhi.n	15df4 <check_control_input+0xe4>
        celt_assert( 0 );
        return SILK_ENC_INVALID_NUMBER_OF_CHANNELS_ERROR;
    }
    if( encControl->nChannelsInternal > encControl->nChannelsAPI ) {
   15dca:	4293      	cmp	r3, r2
   15dcc:	db12      	blt.n	15df4 <check_control_input+0xe4>
        celt_assert( 0 );
        return SILK_ENC_INVALID_NUMBER_OF_CHANNELS_ERROR;
    }
    if( encControl->complexity < 0 || encControl->complexity > 10 ) {
   15dce:	6a43      	ldr	r3, [r0, #36]	; 0x24
        celt_assert( 0 );
        return SILK_ENC_INVALID_COMPLEXITY_SETTING;
   15dd0:	2b0b      	cmp	r3, #11
   15dd2:	bf34      	ite	cc
   15dd4:	2000      	movcc	r0, #0
   15dd6:	f06f 0069 	mvncs.w	r0, #105	; 0x69
    }

    return SILK_NO_ERROR;
}
   15dda:	f85d 4b04 	ldr.w	r4, [sp], #4
   15dde:	4770      	bx	lr
        encControl->payloadSize_ms != 40 &&
   15de0:	2b3c      	cmp	r3, #60	; 0x3c
   15de2:	d0de      	beq.n	15da2 <check_control_input+0x92>
        return SILK_ENC_PACKET_SIZE_NOT_SUPPORTED;
   15de4:	f06f 0066 	mvn.w	r0, #102	; 0x66
}
   15de8:	f85d 4b04 	ldr.w	r4, [sp], #4
   15dec:	4770      	bx	lr
        return SILK_ENC_FS_NOT_SUPPORTED;
   15dee:	f06f 0065 	mvn.w	r0, #101	; 0x65
   15df2:	e7f2      	b.n	15dda <check_control_input+0xca>
        return SILK_ENC_INVALID_NUMBER_OF_CHANNELS_ERROR;
   15df4:	f06f 006e 	mvn.w	r0, #110	; 0x6e
   15df8:	e7ef      	b.n	15dda <check_control_input+0xca>
        return SILK_ENC_FS_NOT_SUPPORTED;
   15dfa:	f06f 0065 	mvn.w	r0, #101	; 0x65
}
   15dfe:	4770      	bx	lr
        return SILK_ENC_INVALID_DTX_SETTING;
   15e00:	f06f 006b 	mvn.w	r0, #107	; 0x6b
   15e04:	e7e9      	b.n	15dda <check_control_input+0xca>
        return SILK_ENC_INVALID_CBR_SETTING;
   15e06:	f06f 006c 	mvn.w	r0, #108	; 0x6c
   15e0a:	e7e6      	b.n	15dda <check_control_input+0xca>
        return SILK_ENC_INVALID_INBAND_FEC_SETTING;
   15e0c:	f06f 006a 	mvn.w	r0, #106	; 0x6a
   15e10:	e7e3      	b.n	15dda <check_control_input+0xca>
        return SILK_ENC_INVALID_LOSS_RATE;
   15e12:	f06f 0068 	mvn.w	r0, #104	; 0x68
   15e16:	e7e0      	b.n	15dda <check_control_input+0xca>
   15e18:	40000401 	.word	0x40000401

00015e1c <silk_control_SNR>:
/* Control SNR of redidual quantizer */
opus_int silk_control_SNR(
    silk_encoder_state          *psEncC,                        /* I/O  Pointer to Silk encoder state               */
    opus_int32                  TargetRate_bps                  /* I    Target max bitrate (bps)                    */
)
{
   15e1c:	4602      	mov	r2, r0
    int id;
    int bound;
    const unsigned char *snr_table;

    psEncC->TargetRate_bps = TargetRate_bps;
    if( psEncC->nb_subfr == 2 ) {
   15e1e:	f241 10e4 	movw	r0, #4580	; 0x11e4
{
   15e22:	b430      	push	{r4, r5}
    if( psEncC->nb_subfr == 2 ) {
   15e24:	5810      	ldr	r0, [r2, r0]
    psEncC->TargetRate_bps = TargetRate_bps;
   15e26:	f502 5490 	add.w	r4, r2, #4608	; 0x1200
   15e2a:	f502 538f 	add.w	r3, r2, #4576	; 0x11e0
    if( psEncC->nb_subfr == 2 ) {
   15e2e:	2802      	cmp	r0, #2
   15e30:	681b      	ldr	r3, [r3, #0]
    psEncC->TargetRate_bps = TargetRate_bps;
   15e32:	6021      	str	r1, [r4, #0]
    if( psEncC->nb_subfr == 2 ) {
   15e34:	d108      	bne.n	15e48 <silk_control_SNR+0x2c>
        TargetRate_bps -= 2000 + psEncC->fs_kHz/16;
   15e36:	2b00      	cmp	r3, #0
   15e38:	4618      	mov	r0, r3
   15e3a:	bfb8      	it	lt
   15e3c:	f103 000f 	addlt.w	r0, r3, #15
   15e40:	1100      	asrs	r0, r0, #4
   15e42:	f500 60fa 	add.w	r0, r0, #2000	; 0x7d0
   15e46:	1a09      	subs	r1, r1, r0
    }
    if( psEncC->fs_kHz == 8 ) {
   15e48:	2b08      	cmp	r3, #8
   15e4a:	d025      	beq.n	15e98 <silk_control_SNR+0x7c>
        bound = sizeof(silk_TargetRate_NB_21);
        snr_table = silk_TargetRate_NB_21;
    } else if( psEncC->fs_kHz == 12 ) {
   15e4c:	4814      	ldr	r0, [pc, #80]	; (15ea0 <silk_control_SNR+0x84>)
   15e4e:	4c15      	ldr	r4, [pc, #84]	; (15ea4 <silk_control_SNR+0x88>)
   15e50:	2b0c      	cmp	r3, #12
   15e52:	bf0b      	itete	eq
   15e54:	4604      	moveq	r4, r0
   15e56:	20be      	movne	r0, #190	; 0xbe
   15e58:	209a      	moveq	r0, #154	; 0x9a
   15e5a:	25bf      	movne	r5, #191	; 0xbf
   15e5c:	bf08      	it	eq
   15e5e:	259b      	moveq	r5, #155	; 0x9b
        snr_table = silk_TargetRate_MB_21;
    } else {
        bound = sizeof(silk_TargetRate_WB_21);
        snr_table = silk_TargetRate_WB_21;
    }
    id = (TargetRate_bps+200)/400;
   15e60:	4b11      	ldr	r3, [pc, #68]	; (15ea8 <silk_control_SNR+0x8c>)
   15e62:	31c8      	adds	r1, #200	; 0xc8
   15e64:	fb83 c301 	smull	ip, r3, r3, r1
   15e68:	17c9      	asrs	r1, r1, #31
   15e6a:	ebc1 11e3 	rsb	r1, r1, r3, asr #7
    id = silk_min(id - 10, bound-1);
   15e6e:	f1a1 0308 	sub.w	r3, r1, #8
   15e72:	42ab      	cmp	r3, r5
   15e74:	dc05      	bgt.n	15e82 <silk_control_SNR+0x66>
   15e76:	f1a1 000a 	sub.w	r0, r1, #10
    if( id <= 0 ) {
   15e7a:	2800      	cmp	r0, #0
   15e7c:	dc01      	bgt.n	15e82 <silk_control_SNR+0x66>
        psEncC->SNR_dB_Q7 = 0;
   15e7e:	2300      	movs	r3, #0
   15e80:	e004      	b.n	15e8c <silk_control_SNR+0x70>
    } else {
        psEncC->SNR_dB_Q7 = snr_table[id]*21;
   15e82:	5c23      	ldrb	r3, [r4, r0]
   15e84:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   15e88:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
   15e8c:	f241 216c 	movw	r1, #4716	; 0x126c
    }
    return SILK_NO_ERROR;
}
   15e90:	2000      	movs	r0, #0
   15e92:	5053      	str	r3, [r2, r1]
   15e94:	bc30      	pop	{r4, r5}
   15e96:	4770      	bx	lr
        snr_table = silk_TargetRate_NB_21;
   15e98:	4c04      	ldr	r4, [pc, #16]	; (15eac <silk_control_SNR+0x90>)
   15e9a:	206a      	movs	r0, #106	; 0x6a
        bound = sizeof(silk_TargetRate_NB_21);
   15e9c:	256b      	movs	r5, #107	; 0x6b
   15e9e:	e7df      	b.n	15e60 <silk_control_SNR+0x44>
   15ea0:	0003720c 	.word	0x0003720c
   15ea4:	00037314 	.word	0x00037314
   15ea8:	51eb851f 	.word	0x51eb851f
   15eac:	000372a8 	.word	0x000372a8

00015eb0 <silk_init_encoder>:
/*********************************/
opus_int silk_init_encoder(
    silk_encoder_state_Fxx          *psEnc,                                 /* I/O  Pointer to Silk FIX encoder state                                           */
    int                              arch                                   /* I    Run-time architecture                                                       */
)
{
   15eb0:	b538      	push	{r3, r4, r5, lr}
    opus_int ret = 0;

    /* Clear the entire encoder state */
    silk_memset( psEnc, 0, sizeof( silk_encoder_state_Fxx ) );
   15eb2:	f242 12b8 	movw	r2, #8632	; 0x21b8
{
   15eb6:	460d      	mov	r5, r1
    silk_memset( psEnc, 0, sizeof( silk_encoder_state_Fxx ) );
   15eb8:	2100      	movs	r1, #0
{
   15eba:	4604      	mov	r4, r0
    silk_memset( psEnc, 0, sizeof( silk_encoder_state_Fxx ) );
   15ebc:	f01f f952 	bl	35164 <memset>

    psEnc->sCmn.arch = arch;
   15ec0:	f241 33e4 	movw	r3, #5092	; 0x13e4

    psEnc->sCmn.variable_HP_smth1_Q15 = silk_LSHIFT( silk_lin2log( SILK_FIX_CONST( VARIABLE_HP_MIN_CUTOFF_HZ, 16 ) ) - ( 16 << 7 ), 8 );
   15ec4:	f44f 1070 	mov.w	r0, #3932160	; 0x3c0000
    psEnc->sCmn.arch = arch;
   15ec8:	50e5      	str	r5, [r4, r3]
    psEnc->sCmn.variable_HP_smth1_Q15 = silk_LSHIFT( silk_lin2log( SILK_FIX_CONST( VARIABLE_HP_MIN_CUTOFF_HZ, 16 ) ) - ( 16 << 7 ), 8 );
   15eca:	f001 fd75 	bl	179b8 <silk_lin2log>
    psEnc->sCmn.variable_HP_smth2_Q15 = psEnc->sCmn.variable_HP_smth1_Q15;

    /* Used to deactivate LSF interpolation, pitch prediction */
    psEnc->sCmn.first_frame_after_reset = 1;
   15ece:	f241 2338 	movw	r3, #4664	; 0x1238
    psEnc->sCmn.variable_HP_smth1_Q15 = silk_LSHIFT( silk_lin2log( SILK_FIX_CONST( VARIABLE_HP_MIN_CUTOFF_HZ, 16 ) ) - ( 16 << 7 ), 8 );
   15ed2:	f5a0 6000 	sub.w	r0, r0, #2048	; 0x800
   15ed6:	0200      	lsls	r0, r0, #8
    psEnc->sCmn.first_frame_after_reset = 1;
   15ed8:	2201      	movs	r2, #1
    psEnc->sCmn.variable_HP_smth2_Q15 = psEnc->sCmn.variable_HP_smth1_Q15;
   15eda:	e9c4 0002 	strd	r0, r0, [r4, #8]
    psEnc->sCmn.first_frame_after_reset = 1;
   15ede:	50e2      	str	r2, [r4, r3]

    /* Initialize Silk VAD */
    ret += silk_VAD_Init( &psEnc->sCmn.sVAD );
   15ee0:	f104 0024 	add.w	r0, r4, #36	; 0x24

    return  ret;
}
   15ee4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    ret += silk_VAD_Init( &psEnc->sCmn.sVAD );
   15ee8:	f7fd bcfe 	b.w	138e8 <silk_VAD_Init>

00015eec <silk_setup_resamplers>:

static opus_int silk_setup_resamplers(
    silk_encoder_state_Fxx          *psEnc,             /* I/O                      */
    opus_int                         fs_kHz              /* I                        */
)
{
   15eec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    opus_int   ret = SILK_NO_ERROR;
    SAVE_STACK;

    if( psEnc->sCmn.fs_kHz != fs_kHz || psEnc->sCmn.prev_API_fs_Hz != psEnc->sCmn.API_fs_Hz )
   15ef0:	f500 528f 	add.w	r2, r0, #4576	; 0x11e0
{
   15ef4:	b0d1      	sub	sp, #324	; 0x144
    if( psEnc->sCmn.fs_kHz != fs_kHz || psEnc->sCmn.prev_API_fs_Hz != psEnc->sCmn.API_fs_Hz )
   15ef6:	6816      	ldr	r6, [r2, #0]
   15ef8:	f241 13cc 	movw	r3, #4556	; 0x11cc
   15efc:	428e      	cmp	r6, r1
{
   15efe:	af00      	add	r7, sp, #0
   15f00:	4604      	mov	r4, r0
   15f02:	58c2      	ldr	r2, [r0, r3]
   15f04:	460d      	mov	r5, r1
    if( psEnc->sCmn.fs_kHz != fs_kHz || psEnc->sCmn.prev_API_fs_Hz != psEnc->sCmn.API_fs_Hz )
   15f06:	d06e      	beq.n	15fe6 <silk_setup_resamplers+0xfa>
   15f08:	f504 58b4 	add.w	r8, r4, #5760	; 0x1680
   15f0c:	f108 0810 	add.w	r8, r8, #16
    {
        if( psEnc->sCmn.fs_kHz == 0 ) {
   15f10:	2e00      	cmp	r6, #0
   15f12:	d05b      	beq.n	15fcc <silk_setup_resamplers+0xe0>
#endif
            opus_int32 api_buf_samples;
            opus_int32 old_buf_samples;
            opus_int32 buf_length_ms;

            buf_length_ms = silk_LSHIFT( psEnc->sCmn.nb_subfr * 5, 1 ) + LA_SHAPE_MS;
   15f14:	f241 13e4 	movw	r3, #4580	; 0x11e4
            silk_float2short_array( x_bufFIX, psEnc->x_buf, old_buf_samples );
#endif

            /* Initialize resampler for temporary resampling of x_buf data to API_fs_Hz */
            ALLOC( temp_resampler_state, 1, silk_resampler_state_struct );
            ret += silk_resampler_init( temp_resampler_state, silk_SMULBB( psEnc->sCmn.fs_kHz, 1000 ), psEnc->sCmn.API_fs_Hz, 0 );
   15f18:	b231      	sxth	r1, r6
            buf_length_ms = silk_LSHIFT( psEnc->sCmn.nb_subfr * 5, 1 ) + LA_SHAPE_MS;
   15f1a:	58e3      	ldr	r3, [r4, r3]
            ret += silk_resampler_init( temp_resampler_state, silk_SMULBB( psEnc->sCmn.fs_kHz, 1000 ), psEnc->sCmn.API_fs_Hz, 0 );
   15f1c:	ebc1 1041 	rsb	r0, r1, r1, lsl #5

            /* Calculate number of samples to temporarily upsample */
            api_buf_samples = buf_length_ms * silk_DIV32_16( psEnc->sCmn.API_fs_Hz, 1000 );
   15f20:	f241 1acc 	movw	sl, #4556	; 0x11cc
            ret += silk_resampler_init( temp_resampler_state, silk_SMULBB( psEnc->sCmn.fs_kHz, 1000 ), psEnc->sCmn.API_fs_Hz, 0 );
   15f24:	eb01 0180 	add.w	r1, r1, r0, lsl #2
            buf_length_ms = silk_LSHIFT( psEnc->sCmn.nb_subfr * 5, 1 ) + LA_SHAPE_MS;
   15f28:	eb03 0983 	add.w	r9, r3, r3, lsl #2
            ret += silk_resampler_init( temp_resampler_state, silk_SMULBB( psEnc->sCmn.fs_kHz, 1000 ), psEnc->sCmn.API_fs_Hz, 0 );
   15f2c:	00c9      	lsls	r1, r1, #3
   15f2e:	2300      	movs	r3, #0
   15f30:	f107 0014 	add.w	r0, r7, #20
   15f34:	f002 fdae 	bl	18a94 <silk_resampler_init>
            api_buf_samples = buf_length_ms * silk_DIV32_16( psEnc->sCmn.API_fs_Hz, 1000 );
   15f38:	f854 300a 	ldr.w	r3, [r4, sl]
   15f3c:	492d      	ldr	r1, [pc, #180]	; (15ff4 <silk_setup_resamplers+0x108>)
        } else {
   15f3e:	f8c7 d004 	str.w	sp, [r7, #4]
            api_buf_samples = buf_length_ms * silk_DIV32_16( psEnc->sCmn.API_fs_Hz, 1000 );
   15f42:	17da      	asrs	r2, r3, #31
            buf_length_ms = silk_LSHIFT( psEnc->sCmn.nb_subfr * 5, 1 ) + LA_SHAPE_MS;
   15f44:	ea4f 0949 	mov.w	r9, r9, lsl #1
            api_buf_samples = buf_length_ms * silk_DIV32_16( psEnc->sCmn.API_fs_Hz, 1000 );
   15f48:	fb81 c303 	smull	ip, r3, r1, r3
            buf_length_ms = silk_LSHIFT( psEnc->sCmn.nb_subfr * 5, 1 ) + LA_SHAPE_MS;
   15f4c:	f109 0905 	add.w	r9, r9, #5
            api_buf_samples = buf_length_ms * silk_DIV32_16( psEnc->sCmn.API_fs_Hz, 1000 );
   15f50:	ebc2 13a3 	rsb	r3, r2, r3, asr #6
   15f54:	fb09 f303 	mul.w	r3, r9, r3

            /* Temporary resampling of x_buf data to API_fs_Hz */
            ALLOC( x_buf_API_fs_Hz, api_buf_samples, opus_int16 );
   15f58:	60bb      	str	r3, [r7, #8]
   15f5a:	005b      	lsls	r3, r3, #1
   15f5c:	3308      	adds	r3, #8
   15f5e:	f023 0307 	bic.w	r3, r3, #7
   15f62:	ebad 0d03 	sub.w	sp, sp, r3
            old_buf_samples = buf_length_ms * psEnc->sCmn.fs_kHz;
   15f66:	fb09 f606 	mul.w	r6, r9, r6
            opus_int16 *x_bufFIX = psEnc->x_buf;
   15f6a:	f504 59e0 	add.w	r9, r4, #7168	; 0x1c00
            ALLOC( x_buf_API_fs_Hz, api_buf_samples, opus_int16 );
   15f6e:	46eb      	mov	fp, sp
            opus_int16 *x_bufFIX = psEnc->x_buf;
   15f70:	f109 0910 	add.w	r9, r9, #16
            ret += silk_resampler( temp_resampler_state, x_buf_API_fs_Hz, x_bufFIX, old_buf_samples );
   15f74:	f107 0214 	add.w	r2, r7, #20
   15f78:	4633      	mov	r3, r6
            ret += silk_resampler_init( temp_resampler_state, silk_SMULBB( psEnc->sCmn.fs_kHz, 1000 ), psEnc->sCmn.API_fs_Hz, 0 );
   15f7a:	60f8      	str	r0, [r7, #12]
            ret += silk_resampler( temp_resampler_state, x_buf_API_fs_Hz, x_bufFIX, old_buf_samples );
   15f7c:	4659      	mov	r1, fp
   15f7e:	4610      	mov	r0, r2
   15f80:	464a      	mov	r2, r9
   15f82:	f002 feb7 	bl	18cf4 <silk_resampler>

            /* Initialize the resampler for enc_API.c preparing resampling from API_fs_Hz to fs_kHz */
            ret += silk_resampler_init( &psEnc->sCmn.resampler_state, psEnc->sCmn.API_fs_Hz, silk_SMULBB( fs_kHz, 1000 ), 1 );
   15f86:	b22d      	sxth	r5, r5
            ret += silk_resampler( temp_resampler_state, x_buf_API_fs_Hz, x_bufFIX, old_buf_samples );
   15f88:	68f9      	ldr	r1, [r7, #12]
            ret += silk_resampler_init( &psEnc->sCmn.resampler_state, psEnc->sCmn.API_fs_Hz, silk_SMULBB( fs_kHz, 1000 ), 1 );
   15f8a:	ebc5 1245 	rsb	r2, r5, r5, lsl #5
            ret += silk_resampler( temp_resampler_state, x_buf_API_fs_Hz, x_bufFIX, old_buf_samples );
   15f8e:	4401      	add	r1, r0
            ret += silk_resampler_init( &psEnc->sCmn.resampler_state, psEnc->sCmn.API_fs_Hz, silk_SMULBB( fs_kHz, 1000 ), 1 );
   15f90:	eb05 0282 	add.w	r2, r5, r2, lsl #2
            ret += silk_resampler( temp_resampler_state, x_buf_API_fs_Hz, x_bufFIX, old_buf_samples );
   15f94:	460e      	mov	r6, r1
            ret += silk_resampler_init( &psEnc->sCmn.resampler_state, psEnc->sCmn.API_fs_Hz, silk_SMULBB( fs_kHz, 1000 ), 1 );
   15f96:	00d2      	lsls	r2, r2, #3
   15f98:	f854 100a 	ldr.w	r1, [r4, sl]
   15f9c:	2301      	movs	r3, #1
   15f9e:	4640      	mov	r0, r8
   15fa0:	f002 fd78 	bl	18a94 <silk_resampler_init>

            /* Correct resampler state by resampling buffered data from API_fs_Hz to fs_kHz */
            ret += silk_resampler( &psEnc->sCmn.resampler_state, x_bufFIX, x_buf_API_fs_Hz, api_buf_samples );
   15fa4:	465a      	mov	r2, fp
            ret += silk_resampler_init( &psEnc->sCmn.resampler_state, psEnc->sCmn.API_fs_Hz, silk_SMULBB( fs_kHz, 1000 ), 1 );
   15fa6:	4406      	add	r6, r0
            ret += silk_resampler( &psEnc->sCmn.resampler_state, x_bufFIX, x_buf_API_fs_Hz, api_buf_samples );
   15fa8:	68bb      	ldr	r3, [r7, #8]
   15faa:	4649      	mov	r1, r9
   15fac:	4640      	mov	r0, r8
   15fae:	f002 fea1 	bl	18cf4 <silk_resampler>
   15fb2:	f854 200a 	ldr.w	r2, [r4, sl]
   15fb6:	f8d7 d004 	ldr.w	sp, [r7, #4]
   15fba:	4430      	add	r0, r6
            silk_short2float_array( psEnc->x_buf, x_bufFIX, new_buf_samples);
#endif
        }
    }

    psEnc->sCmn.prev_API_fs_Hz = psEnc->sCmn.API_fs_Hz;
   15fbc:	f241 13d0 	movw	r3, #4560	; 0x11d0

    RESTORE_STACK;
    return ret;
}
   15fc0:	f507 77a2 	add.w	r7, r7, #324	; 0x144
    psEnc->sCmn.prev_API_fs_Hz = psEnc->sCmn.API_fs_Hz;
   15fc4:	50e2      	str	r2, [r4, r3]
}
   15fc6:	46bd      	mov	sp, r7
   15fc8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            ret += silk_resampler_init( &psEnc->sCmn.resampler_state, psEnc->sCmn.API_fs_Hz, fs_kHz * 1000, 1 );
   15fcc:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   15fd0:	4611      	mov	r1, r2
   15fd2:	4640      	mov	r0, r8
   15fd4:	fb03 f205 	mul.w	r2, r3, r5
   15fd8:	2301      	movs	r3, #1
   15fda:	f002 fd5b 	bl	18a94 <silk_resampler_init>
   15fde:	f241 13cc 	movw	r3, #4556	; 0x11cc
   15fe2:	58e2      	ldr	r2, [r4, r3]
   15fe4:	e7ea      	b.n	15fbc <silk_setup_resamplers+0xd0>
    if( psEnc->sCmn.fs_kHz != fs_kHz || psEnc->sCmn.prev_API_fs_Hz != psEnc->sCmn.API_fs_Hz )
   15fe6:	f241 13d0 	movw	r3, #4560	; 0x11d0
   15fea:	58c3      	ldr	r3, [r0, r3]
   15fec:	4293      	cmp	r3, r2
   15fee:	d18b      	bne.n	15f08 <silk_setup_resamplers+0x1c>
    opus_int   ret = SILK_NO_ERROR;
   15ff0:	2000      	movs	r0, #0
   15ff2:	e7e3      	b.n	15fbc <silk_setup_resamplers+0xd0>
   15ff4:	10624dd3 	.word	0x10624dd3

00015ff8 <silk_control_encoder>:
{
   15ff8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if( psEnc->sCmn.controlled_since_last_payload != 0 && psEnc->sCmn.prefillFlag == 0 ) {
   15ffc:	f241 253c 	movw	r5, #4668	; 0x123c
    psEnc->sCmn.useDTX                 = encControl->useDTX;
   16000:	f241 76bc 	movw	r6, #6076	; 0x17bc
    if( psEnc->sCmn.controlled_since_last_payload != 0 && psEnc->sCmn.prefillFlag == 0 ) {
   16004:	5947      	ldr	r7, [r0, r5]
    psEnc->sCmn.useDTX                 = encControl->useDTX;
   16006:	6b0d      	ldr	r5, [r1, #48]	; 0x30
   16008:	5185      	str	r5, [r0, r6]
    psEnc->sCmn.useCBR                 = encControl->useCBR;
   1600a:	f241 2c44 	movw	ip, #4676	; 0x1244
   1600e:	6b4d      	ldr	r5, [r1, #52]	; 0x34
   16010:	f840 500c 	str.w	r5, [r0, ip]
    psEnc->sCmn.API_fs_Hz              = encControl->API_sampleRate;
   16014:	f241 16cc 	movw	r6, #4556	; 0x11cc
   16018:	688d      	ldr	r5, [r1, #8]
   1601a:	5185      	str	r5, [r0, r6]
    psEnc->sCmn.maxInternal_fs_Hz      = encControl->maxInternalSampleRate;
   1601c:	f241 1cd4 	movw	ip, #4564	; 0x11d4
   16020:	68ce      	ldr	r6, [r1, #12]
   16022:	f840 600c 	str.w	r6, [r0, ip]
    psEnc->sCmn.minInternal_fs_Hz      = encControl->minInternalSampleRate;
   16026:	f241 1cd8 	movw	ip, #4568	; 0x11d8
   1602a:	690e      	ldr	r6, [r1, #16]
   1602c:	f840 600c 	str.w	r6, [r0, ip]
    psEnc->sCmn.desiredInternal_fs_Hz  = encControl->desiredInternalSampleRate;
   16030:	f241 1cdc 	movw	ip, #4572	; 0x11dc
   16034:	694e      	ldr	r6, [r1, #20]
   16036:	f840 600c 	str.w	r6, [r0, ip]
    psEnc->sCmn.useInBandFEC           = encControl->useInBandFEC;
   1603a:	f241 7cc8 	movw	ip, #6088	; 0x17c8
   1603e:	6a8e      	ldr	r6, [r1, #40]	; 0x28
   16040:	f840 600c 	str.w	r6, [r0, ip]
    psEnc->sCmn.nChannelsAPI           = encControl->nChannelsAPI;
   16044:	f241 6c78 	movw	ip, #5752	; 0x1678
   16048:	680e      	ldr	r6, [r1, #0]
   1604a:	f840 600c 	str.w	r6, [r0, ip]
    psEnc->sCmn.nChannelsInternal      = encControl->nChannelsInternal;
   1604e:	f241 6c7c 	movw	ip, #5756	; 0x167c
   16052:	684e      	ldr	r6, [r1, #4]
   16054:	f840 600c 	str.w	r6, [r0, ip]
    psEnc->sCmn.allow_bandwidth_switch = allow_bw_switch;
   16058:	f241 16b8 	movw	r6, #4536	; 0x11b8
    psEnc->sCmn.channelNb              = channelNb;
   1605c:	f500 5cb4 	add.w	ip, r0, #5760	; 0x1680
    psEnc->sCmn.allow_bandwidth_switch = allow_bw_switch;
   16060:	5182      	str	r2, [r0, r6]
{
   16062:	4604      	mov	r4, r0
   16064:	9e08      	ldr	r6, [sp, #32]
    psEnc->sCmn.channelNb              = channelNb;
   16066:	f8cc 3000 	str.w	r3, [ip]
    if( psEnc->sCmn.controlled_since_last_payload != 0 && psEnc->sCmn.prefillFlag == 0 ) {
   1606a:	b18f      	cbz	r7, 16090 <silk_control_encoder+0x98>
   1606c:	f241 2348 	movw	r3, #4680	; 0x1248
   16070:	58c7      	ldr	r7, [r0, r3]
   16072:	b96f      	cbnz	r7, 16090 <silk_control_encoder+0x98>
        if( psEnc->sCmn.API_fs_Hz != psEnc->sCmn.prev_API_fs_Hz && psEnc->sCmn.fs_kHz > 0 ) {
   16074:	f241 13d0 	movw	r3, #4560	; 0x11d0
   16078:	58c3      	ldr	r3, [r0, r3]
   1607a:	429d      	cmp	r5, r3
   1607c:	d005      	beq.n	1608a <silk_control_encoder+0x92>
   1607e:	f500 548f 	add.w	r4, r0, #4576	; 0x11e0
   16082:	6821      	ldr	r1, [r4, #0]
   16084:	2900      	cmp	r1, #0
   16086:	f300 81df 	bgt.w	16448 <silk_control_encoder+0x450>
}
   1608a:	4638      	mov	r0, r7
   1608c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    fs_kHz = silk_control_audio_bandwidth( &psEnc->sCmn, encControl );
   16090:	4620      	mov	r0, r4
   16092:	460d      	mov	r5, r1
   16094:	f7fd ffba 	bl	1400c <silk_control_audio_bandwidth>
   16098:	2e00      	cmp	r6, #0
   1609a:	bf08      	it	eq
   1609c:	4606      	moveq	r6, r0
    ret += silk_setup_resamplers( psEnc, fs_kHz );
   1609e:	4631      	mov	r1, r6
   160a0:	4620      	mov	r0, r4
   160a2:	f7ff ff23 	bl	15eec <silk_setup_resamplers>
)
{
    opus_int ret = SILK_NO_ERROR;

    /* Set packet size */
    if( PacketSize_ms != psEnc->sCmn.PacketSize_ms ) {
   160a6:	f241 2304 	movw	r3, #4612	; 0x1204
    ret += silk_setup_fs( psEnc, fs_kHz, encControl->payloadSize_ms );
   160aa:	69a9      	ldr	r1, [r5, #24]
    if( PacketSize_ms != psEnc->sCmn.PacketSize_ms ) {
   160ac:	58e3      	ldr	r3, [r4, r3]
   160ae:	4299      	cmp	r1, r3
    ret += silk_setup_resamplers( psEnc, fs_kHz );
   160b0:	4607      	mov	r7, r0
    if( PacketSize_ms != psEnc->sCmn.PacketSize_ms ) {
   160b2:	f000 809f 	beq.w	161f4 <silk_control_encoder+0x1fc>
        if( ( PacketSize_ms !=  10 ) &&
   160b6:	290a      	cmp	r1, #10
   160b8:	f000 81da 	beq.w	16470 <silk_control_encoder+0x478>
   160bc:	2914      	cmp	r1, #20
   160be:	d008      	beq.n	160d2 <silk_control_encoder+0xda>
            ( PacketSize_ms !=  20 ) &&
   160c0:	2928      	cmp	r1, #40	; 0x28
   160c2:	d006      	beq.n	160d2 <silk_control_encoder+0xda>
            ( PacketSize_ms !=  40 ) &&
   160c4:	293c      	cmp	r1, #60	; 0x3c
   160c6:	d004      	beq.n	160d2 <silk_control_encoder+0xda>
            ( PacketSize_ms !=  60 ) ) {
            ret = SILK_ENC_PACKET_SIZE_NOT_SUPPORTED;
        }
        if( PacketSize_ms <= 10 ) {
   160c8:	290a      	cmp	r1, #10
   160ca:	f1a0 0767 	sub.w	r7, r0, #103	; 0x67
   160ce:	f340 828a 	ble.w	165e6 <silk_control_encoder+0x5ee>
                psEnc->sCmn.pitch_contour_iCDF = silk_pitch_contour_10_ms_NB_iCDF;
            } else {
                psEnc->sCmn.pitch_contour_iCDF = silk_pitch_contour_10_ms_iCDF;
            }
        } else {
            psEnc->sCmn.nFramesPerPacket = silk_DIV32_16( PacketSize_ms, MAX_FRAME_LENGTH_MS );
   160d2:	4adf      	ldr	r2, [pc, #892]	; (16450 <silk_control_encoder+0x458>)
            psEnc->sCmn.nb_subfr = MAX_NB_SUBFR;
            psEnc->sCmn.frame_length = silk_SMULBB( 20, fs_kHz );
   160d4:	b233      	sxth	r3, r6
            psEnc->sCmn.nFramesPerPacket = silk_DIV32_16( PacketSize_ms, MAX_FRAME_LENGTH_MS );
   160d6:	fb82 0201 	smull	r0, r2, r2, r1
   160da:	f241 6c70 	movw	ip, #5744	; 0x1670
   160de:	17c8      	asrs	r0, r1, #31
   160e0:	ebc0 00e2 	rsb	r0, r0, r2, asr #3
            psEnc->sCmn.frame_length = silk_SMULBB( 20, fs_kHz );
   160e4:	eb03 0e83 	add.w	lr, r3, r3, lsl #2
            psEnc->sCmn.pitch_LPC_win_length = silk_SMULBB( FIND_PITCH_LPC_WIN_MS, fs_kHz );
   160e8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
            psEnc->sCmn.nFramesPerPacket = silk_DIV32_16( PacketSize_ms, MAX_FRAME_LENGTH_MS );
   160ec:	f844 000c 	str.w	r0, [r4, ip]
            psEnc->sCmn.pitch_LPC_win_length = silk_SMULBB( FIND_PITCH_LPC_WIN_MS, fs_kHz );
   160f0:	00da      	lsls	r2, r3, #3
   160f2:	f241 10c4 	movw	r0, #4548	; 0x11c4
            psEnc->sCmn.frame_length = silk_SMULBB( 20, fs_kHz );
   160f6:	f241 13e8 	movw	r3, #4584	; 0x11e8
            if( psEnc->sCmn.fs_kHz == 8 ) {
   160fa:	f504 588f 	add.w	r8, r4, #4576	; 0x11e0
            psEnc->sCmn.frame_length = silk_SMULBB( 20, fs_kHz );
   160fe:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
   16102:	f844 e003 	str.w	lr, [r4, r3]
            if( psEnc->sCmn.fs_kHz == 8 ) {
   16106:	f8d8 3000 	ldr.w	r3, [r8]
            psEnc->sCmn.pitch_LPC_win_length = silk_SMULBB( FIND_PITCH_LPC_WIN_MS, fs_kHz );
   1610a:	5022      	str	r2, [r4, r0]
            psEnc->sCmn.nb_subfr = MAX_NB_SUBFR;
   1610c:	f241 12e4 	movw	r2, #4580	; 0x11e4
   16110:	2004      	movs	r0, #4
   16112:	50a0      	str	r0, [r4, r2]
            if( psEnc->sCmn.fs_kHz == 8 ) {
   16114:	2b08      	cmp	r3, #8
                psEnc->sCmn.pitch_contour_iCDF = silk_pitch_contour_NB_iCDF;
   16116:	f241 2250 	movw	r2, #4688	; 0x1250
   1611a:	bf0c      	ite	eq
   1611c:	48cd      	ldreq	r0, [pc, #820]	; (16454 <silk_control_encoder+0x45c>)
            } else {
                psEnc->sCmn.pitch_contour_iCDF = silk_pitch_contour_iCDF;
   1611e:	48ce      	ldrne	r0, [pc, #824]	; (16458 <silk_control_encoder+0x460>)
   16120:	50a0      	str	r0, [r4, r2]
            }
        }
        psEnc->sCmn.PacketSize_ms  = PacketSize_ms;
   16122:	f241 2004 	movw	r0, #4612	; 0x1204
        psEnc->sCmn.TargetRate_bps = 0;         /* trigger new SNR computation */
   16126:	f504 5290 	add.w	r2, r4, #4608	; 0x1200
        psEnc->sCmn.PacketSize_ms  = PacketSize_ms;
   1612a:	5021      	str	r1, [r4, r0]
    }

    /* Set internal sampling frequency */
    celt_assert( fs_kHz == 8 || fs_kHz == 12 || fs_kHz == 16 );
    celt_assert( psEnc->sCmn.nb_subfr == 2 || psEnc->sCmn.nb_subfr == 4 );
    if( psEnc->sCmn.fs_kHz != fs_kHz ) {
   1612c:	429e      	cmp	r6, r3
        psEnc->sCmn.TargetRate_bps = 0;         /* trigger new SNR computation */
   1612e:	f04f 0100 	mov.w	r1, #0
   16132:	6011      	str	r1, [r2, #0]
    if( psEnc->sCmn.fs_kHz != fs_kHz ) {
   16134:	d164      	bne.n	16200 <silk_control_encoder+0x208>
    ret += silk_setup_complexity( &psEnc->sCmn, encControl->complexity  );
   16136:	6a6e      	ldr	r6, [r5, #36]	; 0x24
{
    opus_int ret = 0;

    /* Set encoding complexity */
    celt_assert( Complexity >= 0 && Complexity <= 10 );
    if( Complexity < 1 ) {
   16138:	2e00      	cmp	r6, #0
   1613a:	f504 5091 	add.w	r0, r4, #4640	; 0x1220
   1613e:	eb03 0283 	add.w	r2, r3, r3, lsl #2
   16142:	f300 8100 	bgt.w	16346 <silk_control_encoder+0x34e>
        psEncC->pitchEstimationComplexity       = SILK_PE_MIN_COMPLEX;
        psEncC->pitchEstimationThreshold_Q16    = SILK_FIX_CONST( 0.8, 16 );
        psEncC->pitchEstimationLPCOrder         = 6;
        psEncC->shapingLPCOrder                 = 12;
        psEncC->la_shape                        = 3 * psEncC->fs_kHz;
   16146:	f241 1ef8 	movw	lr, #4600	; 0x11f8
        psEncC->pitchEstimationComplexity       = SILK_PE_MIN_COMPLEX;
   1614a:	f241 2c24 	movw	ip, #4644	; 0x1224
        psEncC->nStatesDelayedDecision          = 1;
        psEncC->useInterpolatedNLSFs            = 0;
   1614e:	f241 2818 	movw	r8, #4632	; 0x1218
        psEncC->la_shape                        = 3 * psEncC->fs_kHz;
   16152:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   16156:	f844 300e 	str.w	r3, [r4, lr]
        psEncC->pitchEstimationThreshold_Q16    = SILK_FIX_CONST( 0.8, 16 );
   1615a:	f241 212c 	movw	r1, #4652	; 0x122c
        psEncC->pitchEstimationComplexity       = SILK_PE_MIN_COMPLEX;
   1615e:	f04f 0e00 	mov.w	lr, #0
   16162:	f844 e00c 	str.w	lr, [r4, ip]
        psEncC->useInterpolatedNLSFs            = 0;
   16166:	f844 e008 	str.w	lr, [r4, r8]
        psEncC->shapingLPCOrder                 = 12;
   1616a:	f241 2c1c 	movw	ip, #4636	; 0x121c
        psEncC->pitchEstimationThreshold_Q16    = SILK_FIX_CONST( 0.8, 16 );
   1616e:	f64c 48cd 	movw	r8, #52429	; 0xcccd
   16172:	f844 8001 	str.w	r8, [r4, r1]
        psEncC->nStatesDelayedDecision          = 1;
   16176:	f241 2114 	movw	r1, #4628	; 0x1214
        psEncC->shapingLPCOrder                 = 12;
   1617a:	f04f 080c 	mov.w	r8, #12
   1617e:	f844 800c 	str.w	r8, [r4, ip]
        psEncC->nStatesDelayedDecision          = 1;
   16182:	f04f 0801 	mov.w	r8, #1
   16186:	f844 8001 	str.w	r8, [r4, r1]
        psEncC->NLSF_MSVQ_Survivors             = 2;
   1618a:	f241 2c34 	movw	ip, #4660	; 0x1234
        psEncC->warping_Q16                     = 0;
   1618e:	f504 5192 	add.w	r1, r4, #4672	; 0x1240
        psEncC->NLSF_MSVQ_Survivors             = 2;
   16192:	f04f 0802 	mov.w	r8, #2
   16196:	f844 800c 	str.w	r8, [r4, ip]
        psEncC->warping_Q16                     = 0;
   1619a:	f04f 0c06 	mov.w	ip, #6
   1619e:	f8c1 e000 	str.w	lr, [r1]
    return (((a) < (b)) ? (a) : (b));
   161a2:	6801      	ldr	r1, [r0, #0]
    psEnc->sCmn.PacketLoss_perc = encControl->packetLossPercentage;
   161a4:	6a28      	ldr	r0, [r5, #32]
   161a6:	4561      	cmp	r1, ip
        psEncC->NLSF_MSVQ_Survivors             = 16;
        psEncC->warping_Q16                     = psEncC->fs_kHz * SILK_FIX_CONST( WARPING_MULTIPLIER, 16 );
    }

    /* Do not allow higher pitch estimation LPC order than predict LPC order */
    psEncC->pitchEstimationLPCOrder = silk_min_int( psEncC->pitchEstimationLPCOrder, psEncC->predictLPCOrder );
   161a8:	f241 2e28 	movw	lr, #4648	; 0x1228
   161ac:	bfa8      	it	ge
   161ae:	4661      	movge	r1, ip
   161b0:	f844 100e 	str.w	r1, [r4, lr]
    psEncC->shapeWinLength          = SUB_FRAME_LENGTH_MS * psEncC->fs_kHz + 2 * psEncC->la_shape;
   161b4:	eb02 0243 	add.w	r2, r2, r3, lsl #1
    psEncC->Complexity              = Complexity;
   161b8:	f241 2110 	movw	r1, #4624	; 0x1210
    psEnc->sCmn.PacketLoss_perc = encControl->packetLossPercentage;
   161bc:	f241 2308 	movw	r3, #4616	; 0x1208
    psEncC->shapeWinLength          = SUB_FRAME_LENGTH_MS * psEncC->fs_kHz + 2 * psEncC->la_shape;
   161c0:	f241 1cfc 	movw	ip, #4604	; 0x11fc
   161c4:	f844 200c 	str.w	r2, [r4, ip]
    psEncC->Complexity              = Complexity;
   161c8:	5066      	str	r6, [r4, r1]
    psEnc->sCmn.PacketLoss_perc = encControl->packetLossPercentage;
   161ca:	50e0      	str	r0, [r4, r3]
    const silk_EncControlStruct *encControl         /* I                        */
)
{
    opus_int   LBRR_in_previous_packet, ret = SILK_NO_ERROR;

    LBRR_in_previous_packet = psEncC->LBRR_enabled;
   161cc:	f241 72cc 	movw	r2, #6092	; 0x17cc
    ret += silk_setup_LBRR( &psEnc->sCmn, encControl );
   161d0:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    LBRR_in_previous_packet = psEncC->LBRR_enabled;
   161d2:	58a1      	ldr	r1, [r4, r2]
    psEncC->LBRR_enabled = encControl->LBRR_coded;
   161d4:	50a3      	str	r3, [r4, r2]
    if( psEncC->LBRR_enabled ) {
   161d6:	b133      	cbz	r3, 161e6 <silk_control_encoder+0x1ee>
        /* Set gain increase for coding LBRR excitation */
        if( LBRR_in_previous_packet == 0 ) {
   161d8:	2900      	cmp	r1, #0
   161da:	f040 80f3 	bne.w	163c4 <silk_control_encoder+0x3cc>
            /* Previous packet did not have LBRR, and was therefore coded at a higher bitrate */
            psEncC->LBRR_GainIncreases = 7;
   161de:	f241 73d0 	movw	r3, #6096	; 0x17d0
   161e2:	2207      	movs	r2, #7
   161e4:	50e2      	str	r2, [r4, r3]
    psEnc->sCmn.controlled_since_last_payload = 1;
   161e6:	f241 233c 	movw	r3, #4668	; 0x123c
   161ea:	2201      	movs	r2, #1
   161ec:	50e2      	str	r2, [r4, r3]
}
   161ee:	4638      	mov	r0, r7
   161f0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   161f4:	f504 588f 	add.w	r8, r4, #4576	; 0x11e0
   161f8:	f8d8 3000 	ldr.w	r3, [r8]
    if( psEnc->sCmn.fs_kHz != fs_kHz ) {
   161fc:	429e      	cmp	r6, r3
   161fe:	d09a      	beq.n	16136 <silk_control_encoder+0x13e>
        silk_memset( &psEnc->sShape,               0, sizeof( psEnc->sShape ) );
   16200:	f504 5ae0 	add.w	sl, r4, #7168	; 0x1c00
   16204:	f04f 0900 	mov.w	r9, #0
        silk_memset( &psEnc->sCmn.sNSQ,            0, sizeof( psEnc->sCmn.sNSQ ) );
   16208:	4649      	mov	r1, r9
   1620a:	f44f 5288 	mov.w	r2, #4352	; 0x1100
        silk_memset( &psEnc->sShape,               0, sizeof( psEnc->sShape ) );
   1620e:	f8ca 9000 	str.w	r9, [sl]
   16212:	f8ca 9004 	str.w	r9, [sl, #4]
   16216:	f8ca 9008 	str.w	r9, [sl, #8]
   1621a:	f8ca 900c 	str.w	r9, [sl, #12]
        silk_memset( &psEnc->sCmn.sNSQ,            0, sizeof( psEnc->sCmn.sNSQ ) );
   1621e:	f104 0094 	add.w	r0, r4, #148	; 0x94
   16222:	f01e ff9f 	bl	35164 <memset>
        silk_memset( psEnc->sCmn.prev_NLSFq_Q15,   0, sizeof( psEnc->sCmn.prev_NLSFq_Q15 ) );
   16226:	f504 508c 	add.w	r0, r4, #4480	; 0x1180
   1622a:	4649      	mov	r1, r9
   1622c:	2220      	movs	r2, #32
   1622e:	3014      	adds	r0, #20
   16230:	f01e ff98 	bl	35164 <memset>
        psEnc->sCmn.inputBufIx                  = 0;
   16234:	f241 606c 	movw	r0, #5740	; 0x166c
        psEnc->sCmn.nFramesEncoded              = 0;
   16238:	f241 6174 	movw	r1, #5748	; 0x1674
        psEnc->sCmn.TargetRate_bps              = 0;     /* trigger new SNR computation */
   1623c:	f504 5290 	add.w	r2, r4, #4608	; 0x1200
        silk_memset( &psEnc->sCmn.sLP.In_LP_State, 0, sizeof( psEnc->sCmn.sLP.In_LP_State ) );
   16240:	f8c4 9010 	str.w	r9, [r4, #16]
   16244:	f8c4 9014 	str.w	r9, [r4, #20]
        psEnc->sCmn.prevLag                     = 100;
   16248:	f504 538e 	add.w	r3, r4, #4544	; 0x11c0
        psEnc->sCmn.inputBufIx                  = 0;
   1624c:	f844 9000 	str.w	r9, [r4, r0]
        psEnc->sCmn.first_frame_after_reset     = 1;
   16250:	f241 2038 	movw	r0, #4664	; 0x1238
        psEnc->sCmn.nFramesEncoded              = 0;
   16254:	f844 9001 	str.w	r9, [r4, r1]
        psEnc->sCmn.TargetRate_bps              = 0;     /* trigger new SNR computation */
   16258:	f8c2 9000 	str.w	r9, [r2]
        psEnc->sCmn.prevLag                     = 100;
   1625c:	2164      	movs	r1, #100	; 0x64
        psEnc->sCmn.first_frame_after_reset     = 1;
   1625e:	2201      	movs	r2, #1
        psEnc->sCmn.prevLag                     = 100;
   16260:	6019      	str	r1, [r3, #0]
        psEnc->sCmn.prevSignalType              = TYPE_NO_VOICE_ACTIVITY;
   16262:	f241 1cbd 	movw	ip, #4541	; 0x11bd
        psEnc->sCmn.first_frame_after_reset     = 1;
   16266:	5022      	str	r2, [r4, r0]
        psEnc->sCmn.sNSQ.lagPrev                = 100;
   16268:	f241 127c 	movw	r2, #4476	; 0x117c
        psEnc->sShape.LastGainIndex             = 10;
   1626c:	230a      	movs	r3, #10
   1626e:	f88a 3000 	strb.w	r3, [sl]
   16272:	f241 10e4 	movw	r0, #4580	; 0x11e4
        psEnc->sCmn.sNSQ.lagPrev                = 100;
   16276:	50a1      	str	r1, [r4, r2]
        psEnc->sCmn.prevSignalType              = TYPE_NO_VOICE_ACTIVITY;
   16278:	f804 900c 	strb.w	r9, [r4, ip]
        psEnc->sCmn.sNSQ.prev_gain_Q16          = 65536;
   1627c:	f241 128c 	movw	r2, #4492	; 0x118c
   16280:	f44f 3180 	mov.w	r1, #65536	; 0x10000
        if( psEnc->sCmn.fs_kHz == 8 ) {
   16284:	2e08      	cmp	r6, #8
   16286:	f854 c000 	ldr.w	ip, [r4, r0]
        psEnc->sCmn.sNSQ.prev_gain_Q16          = 65536;
   1628a:	50a1      	str	r1, [r4, r2]
        psEnc->sCmn.fs_kHz = fs_kHz;
   1628c:	f8c8 6000 	str.w	r6, [r8]
        if( psEnc->sCmn.fs_kHz == 8 ) {
   16290:	f000 813c 	beq.w	1650c <silk_control_encoder+0x514>
            if( psEnc->sCmn.nb_subfr == MAX_NB_SUBFR ) {
   16294:	f1bc 0f04 	cmp.w	ip, #4
                psEnc->sCmn.pitch_contour_iCDF = silk_pitch_contour_iCDF;
   16298:	f241 2350 	movw	r3, #4688	; 0x1250
   1629c:	bf0c      	ite	eq
   1629e:	4a6e      	ldreq	r2, [pc, #440]	; (16458 <silk_control_encoder+0x460>)
                psEnc->sCmn.pitch_contour_iCDF = silk_pitch_contour_10_ms_iCDF;
   162a0:	4a6e      	ldrne	r2, [pc, #440]	; (1645c <silk_control_encoder+0x464>)
   162a2:	50e2      	str	r2, [r4, r3]
            psEnc->sCmn.psNLSF_CB  = &silk_NLSF_CB_NB_MB;
   162a4:	4b6e      	ldr	r3, [pc, #440]	; (16460 <silk_control_encoder+0x468>)
   162a6:	4a6f      	ldr	r2, [pc, #444]	; (16464 <silk_control_encoder+0x46c>)
   162a8:	2e0c      	cmp	r6, #12
   162aa:	bf0a      	itet	eq
   162ac:	461a      	moveq	r2, r3
   162ae:	f04f 0e10 	movne.w	lr, #16
   162b2:	f04f 0e0a 	moveq.w	lr, #10
        psEnc->sCmn.ltp_mem_length = silk_SMULBB( LTP_MEM_LENGTH_MS, fs_kHz );
   162b6:	b233      	sxth	r3, r6
   162b8:	f241 2854 	movw	r8, #4692	; 0x1254
        psEnc->sCmn.max_pitch_lag  = silk_SMULBB( 18, fs_kHz );
   162bc:	00d9      	lsls	r1, r3, #3
   162be:	f504 5091 	add.w	r0, r4, #4640	; 0x1220
   162c2:	f844 2008 	str.w	r2, [r4, r8]
   162c6:	eb01 0903 	add.w	r9, r1, r3
   162ca:	f241 12c8 	movw	r2, #4552	; 0x11c8
   162ce:	f8c0 e000 	str.w	lr, [r0]
        psEnc->sCmn.ltp_mem_length = silk_SMULBB( LTP_MEM_LENGTH_MS, fs_kHz );
   162d2:	eb03 0883 	add.w	r8, r3, r3, lsl #2
        psEnc->sCmn.max_pitch_lag  = silk_SMULBB( 18, fs_kHz );
   162d6:	ea4f 0949 	mov.w	r9, r9, lsl #1
        psEnc->sCmn.ltp_mem_length = silk_SMULBB( LTP_MEM_LENGTH_MS, fs_kHz );
   162da:	f241 1ef0 	movw	lr, #4592	; 0x11f0
        psEnc->sCmn.max_pitch_lag  = silk_SMULBB( 18, fs_kHz );
   162de:	f844 9002 	str.w	r9, [r4, r2]
        psEnc->sCmn.ltp_mem_length = silk_SMULBB( LTP_MEM_LENGTH_MS, fs_kHz );
   162e2:	ea4f 0888 	mov.w	r8, r8, lsl #2
        psEnc->sCmn.la_pitch       = silk_SMULBB( LA_PITCH_MS, fs_kHz );
   162e6:	f241 1af4 	movw	sl, #4596	; 0x11f4
        psEnc->sCmn.subfr_length   = SUB_FRAME_LENGTH_MS * fs_kHz;
   162ea:	f241 19ec 	movw	r9, #4588	; 0x11ec
        psEnc->sCmn.ltp_mem_length = silk_SMULBB( LTP_MEM_LENGTH_MS, fs_kHz );
   162ee:	f844 800e 	str.w	r8, [r4, lr]
        psEnc->sCmn.subfr_length   = SUB_FRAME_LENGTH_MS * fs_kHz;
   162f2:	eb06 0286 	add.w	r2, r6, r6, lsl #2
        psEnc->sCmn.la_pitch       = silk_SMULBB( LA_PITCH_MS, fs_kHz );
   162f6:	ea4f 0e43 	mov.w	lr, r3, lsl #1
        psEnc->sCmn.frame_length   = silk_SMULBB( psEnc->sCmn.subfr_length, psEnc->sCmn.nb_subfr );
   162fa:	f241 18e8 	movw	r8, #4584	; 0x11e8
        if( psEnc->sCmn.nb_subfr == MAX_NB_SUBFR ) {
   162fe:	f1bc 0f04 	cmp.w	ip, #4
        psEnc->sCmn.la_pitch       = silk_SMULBB( LA_PITCH_MS, fs_kHz );
   16302:	f844 e00a 	str.w	lr, [r4, sl]
        psEnc->sCmn.subfr_length   = SUB_FRAME_LENGTH_MS * fs_kHz;
   16306:	f844 2009 	str.w	r2, [r4, r9]
        psEnc->sCmn.frame_length   = silk_SMULBB( psEnc->sCmn.subfr_length, psEnc->sCmn.nb_subfr );
   1630a:	fb12 f20c 	smulbb	r2, r2, ip
            psEnc->sCmn.pitch_LPC_win_length = silk_SMULBB( FIND_PITCH_LPC_WIN_MS, fs_kHz );
   1630e:	bf0c      	ite	eq
   16310:	4473      	addeq	r3, lr
            psEnc->sCmn.pitch_LPC_win_length = silk_SMULBB( FIND_PITCH_LPC_WIN_MS_2_SF, fs_kHz );
   16312:	1acb      	subne	r3, r1, r3
        psEnc->sCmn.frame_length   = silk_SMULBB( psEnc->sCmn.subfr_length, psEnc->sCmn.nb_subfr );
   16314:	f844 2008 	str.w	r2, [r4, r8]
   16318:	f241 12c4 	movw	r2, #4548	; 0x11c4
            psEnc->sCmn.pitch_LPC_win_length = silk_SMULBB( FIND_PITCH_LPC_WIN_MS, fs_kHz );
   1631c:	bf0c      	ite	eq
   1631e:	00db      	lsleq	r3, r3, #3
            psEnc->sCmn.pitch_LPC_win_length = silk_SMULBB( FIND_PITCH_LPC_WIN_MS_2_SF, fs_kHz );
   16320:	005b      	lslne	r3, r3, #1
        if( psEnc->sCmn.fs_kHz == 16 ) {
   16322:	2e10      	cmp	r6, #16
   16324:	50a3      	str	r3, [r4, r2]
            psEnc->sCmn.pitch_lag_low_bits_iCDF = silk_uniform8_iCDF;
   16326:	f241 234c 	movw	r3, #4684	; 0x124c
        if( psEnc->sCmn.fs_kHz == 16 ) {
   1632a:	f000 80fb 	beq.w	16524 <silk_control_encoder+0x52c>
        } else if( psEnc->sCmn.fs_kHz == 12 ) {
   1632e:	2e0c      	cmp	r6, #12
            psEnc->sCmn.pitch_lag_low_bits_iCDF = silk_uniform6_iCDF;
   16330:	bf0c      	ite	eq
   16332:	4a4d      	ldreq	r2, [pc, #308]	; (16468 <silk_control_encoder+0x470>)
            psEnc->sCmn.pitch_lag_low_bits_iCDF = silk_uniform4_iCDF;
   16334:	4a4d      	ldrne	r2, [pc, #308]	; (1646c <silk_control_encoder+0x474>)
   16336:	50e2      	str	r2, [r4, r3]
   16338:	4633      	mov	r3, r6
    ret += silk_setup_complexity( &psEnc->sCmn, encControl->complexity  );
   1633a:	6a6e      	ldr	r6, [r5, #36]	; 0x24
    if( Complexity < 1 ) {
   1633c:	2e00      	cmp	r6, #0
   1633e:	eb03 0283 	add.w	r2, r3, r3, lsl #2
   16342:	f77f af00 	ble.w	16146 <silk_control_encoder+0x14e>
    } else if( Complexity < 2 ) {
   16346:	2e01      	cmp	r6, #1
   16348:	f000 80b5 	beq.w	164b6 <silk_control_encoder+0x4be>
    } else if( Complexity < 3 ) {
   1634c:	2e02      	cmp	r6, #2
   1634e:	d050      	beq.n	163f2 <silk_control_encoder+0x3fa>
    } else if( Complexity < 4 ) {
   16350:	2e03      	cmp	r6, #3
   16352:	f000 80eb 	beq.w	1652c <silk_control_encoder+0x534>
   16356:	f240 31d7 	movw	r1, #983	; 0x3d7
    } else if( Complexity < 6 ) {
   1635a:	2e05      	cmp	r6, #5
   1635c:	fb01 f103 	mul.w	r1, r1, r3
   16360:	f340 8114 	ble.w	1658c <silk_control_encoder+0x594>
    } else if( Complexity < 8 ) {
   16364:	2e07      	cmp	r6, #7
   16366:	f340 8144 	ble.w	165f2 <silk_control_encoder+0x5fa>
        psEncC->pitchEstimationComplexity       = SILK_PE_MAX_COMPLEX;
   1636a:	f241 2324 	movw	r3, #4644	; 0x1224
        psEncC->pitchEstimationThreshold_Q16    = SILK_FIX_CONST( 0.7, 16 );
   1636e:	f241 2c2c 	movw	ip, #4652	; 0x122c
        psEncC->pitchEstimationComplexity       = SILK_PE_MAX_COMPLEX;
   16372:	f04f 0e02 	mov.w	lr, #2
   16376:	f844 e003 	str.w	lr, [r4, r3]
        psEncC->shapingLPCOrder                 = 24;
   1637a:	f241 231c 	movw	r3, #4636	; 0x121c
        psEncC->pitchEstimationThreshold_Q16    = SILK_FIX_CONST( 0.7, 16 );
   1637e:	f24b 3e33 	movw	lr, #45875	; 0xb333
   16382:	f844 e00c 	str.w	lr, [r4, ip]
        psEncC->la_shape                        = 5 * psEncC->fs_kHz;
   16386:	f241 1ef8 	movw	lr, #4600	; 0x11f8
        psEncC->shapingLPCOrder                 = 24;
   1638a:	f04f 0c18 	mov.w	ip, #24
   1638e:	f844 c003 	str.w	ip, [r4, r3]
        psEncC->nStatesDelayedDecision          = MAX_DEL_DEC_STATES;
   16392:	f241 2c14 	movw	ip, #4628	; 0x1214
        psEncC->la_shape                        = 5 * psEncC->fs_kHz;
   16396:	f844 200e 	str.w	r2, [r4, lr]
        psEncC->useInterpolatedNLSFs            = 1;
   1639a:	f241 2318 	movw	r3, #4632	; 0x1218
        psEncC->nStatesDelayedDecision          = MAX_DEL_DEC_STATES;
   1639e:	f04f 0e04 	mov.w	lr, #4
   163a2:	f844 e00c 	str.w	lr, [r4, ip]
        psEncC->useInterpolatedNLSFs            = 1;
   163a6:	f04f 0c01 	mov.w	ip, #1
   163aa:	f844 c003 	str.w	ip, [r4, r3]
        psEncC->NLSF_MSVQ_Survivors             = 16;
   163ae:	f241 2e34 	movw	lr, #4660	; 0x1234
        psEncC->warping_Q16                     = psEncC->fs_kHz * SILK_FIX_CONST( WARPING_MULTIPLIER, 16 );
   163b2:	f504 5392 	add.w	r3, r4, #4672	; 0x1240
        psEncC->NLSF_MSVQ_Survivors             = 16;
   163b6:	f04f 0c10 	mov.w	ip, #16
   163ba:	f844 c00e 	str.w	ip, [r4, lr]
        psEncC->warping_Q16                     = psEncC->fs_kHz * SILK_FIX_CONST( WARPING_MULTIPLIER, 16 );
   163be:	6019      	str	r1, [r3, #0]
   163c0:	4613      	mov	r3, r2
   163c2:	e6ee      	b.n	161a2 <silk_control_encoder+0x1aa>
        } else {
            psEncC->LBRR_GainIncreases = silk_max_int( 7 - silk_SMULWB( (opus_int32)psEncC->PacketLoss_perc, SILK_FIX_CONST( 0.4, 16 ) ), 2 );
   163c4:	f246 6266 	movw	r2, #26214	; 0x6666
   163c8:	b281      	uxth	r1, r0
   163ca:	1403      	asrs	r3, r0, #16
   163cc:	fb02 f101 	mul.w	r1, r2, r1
   163d0:	fb02 f303 	mul.w	r3, r2, r3
   163d4:	eb03 4311 	add.w	r3, r3, r1, lsr #16
   163d8:	f1c3 0307 	rsb	r3, r3, #7
   163dc:	f241 72d0 	movw	r2, #6096	; 0x17d0
    return (((a) > (b)) ? (a) : (b));
   163e0:	2b02      	cmp	r3, #2
   163e2:	bfb8      	it	lt
   163e4:	2302      	movlt	r3, #2
   163e6:	50a3      	str	r3, [r4, r2]
    psEnc->sCmn.controlled_since_last_payload = 1;
   163e8:	f241 233c 	movw	r3, #4668	; 0x123c
   163ec:	2201      	movs	r2, #1
   163ee:	50e2      	str	r2, [r4, r3]
   163f0:	e6fd      	b.n	161ee <silk_control_encoder+0x1f6>
        psEncC->la_shape                        = 3 * psEncC->fs_kHz;
   163f2:	f241 1ef8 	movw	lr, #4600	; 0x11f8
        psEncC->pitchEstimationComplexity       = SILK_PE_MIN_COMPLEX;
   163f6:	f241 2124 	movw	r1, #4644	; 0x1224
        psEncC->useInterpolatedNLSFs            = 0;
   163fa:	f241 2818 	movw	r8, #4632	; 0x1218
        psEncC->la_shape                        = 3 * psEncC->fs_kHz;
   163fe:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   16402:	f844 300e 	str.w	r3, [r4, lr]
        psEncC->pitchEstimationThreshold_Q16    = SILK_FIX_CONST( 0.8, 16 );
   16406:	f241 2c2c 	movw	ip, #4652	; 0x122c
        psEncC->pitchEstimationComplexity       = SILK_PE_MIN_COMPLEX;
   1640a:	f04f 0e00 	mov.w	lr, #0
   1640e:	f844 e001 	str.w	lr, [r4, r1]
        psEncC->useInterpolatedNLSFs            = 0;
   16412:	f844 e008 	str.w	lr, [r4, r8]
        psEncC->shapingLPCOrder                 = 12;
   16416:	f241 211c 	movw	r1, #4636	; 0x121c
        psEncC->pitchEstimationThreshold_Q16    = SILK_FIX_CONST( 0.8, 16 );
   1641a:	f64c 48cd 	movw	r8, #52429	; 0xcccd
   1641e:	f844 800c 	str.w	r8, [r4, ip]
        psEncC->shapingLPCOrder                 = 12;
   16422:	f04f 0c0c 	mov.w	ip, #12
   16426:	f844 c001 	str.w	ip, [r4, r1]
        psEncC->nStatesDelayedDecision          = 2;
   1642a:	f241 2814 	movw	r8, #4628	; 0x1214
        psEncC->NLSF_MSVQ_Survivors             = 2;
   1642e:	f241 2c34 	movw	ip, #4660	; 0x1234
        psEncC->warping_Q16                     = 0;
   16432:	f504 5192 	add.w	r1, r4, #4672	; 0x1240
        psEncC->nStatesDelayedDecision          = 2;
   16436:	f844 6008 	str.w	r6, [r4, r8]
        psEncC->NLSF_MSVQ_Survivors             = 2;
   1643a:	f844 600c 	str.w	r6, [r4, ip]
        psEncC->warping_Q16                     = 0;
   1643e:	f04f 0c06 	mov.w	ip, #6
   16442:	f8c1 e000 	str.w	lr, [r1]
   16446:	e6ac      	b.n	161a2 <silk_control_encoder+0x1aa>
}
   16448:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
            ret += silk_setup_resamplers( psEnc, psEnc->sCmn.fs_kHz );
   1644c:	f7ff bd4e 	b.w	15eec <silk_setup_resamplers>
   16450:	66666667 	.word	0x66666667
   16454:	00036d70 	.word	0x00036d70
   16458:	00036d7c 	.word	0x00036d7c
   1645c:	00036d64 	.word	0x00036d64
   16460:	000363c8 	.word	0x000363c8
   16464:	00036bec 	.word	0x00036bec
   16468:	00036d50 	.word	0x00036d50
   1646c:	00036d44 	.word	0x00036d44
            psEnc->sCmn.nFramesPerPacket = 1;
   16470:	f241 6370 	movw	r3, #5744	; 0x1670
   16474:	2201      	movs	r2, #1
   16476:	50e2      	str	r2, [r4, r3]
            psEnc->sCmn.nb_subfr = PacketSize_ms == 10 ? 2 : 1;
   16478:	f04f 0c02 	mov.w	ip, #2
            psEnc->sCmn.frame_length = silk_SMULBB( PacketSize_ms, fs_kHz );
   1647c:	b233      	sxth	r3, r6
            psEnc->sCmn.pitch_LPC_win_length = silk_SMULBB( FIND_PITCH_LPC_WIN_MS_2_SF, fs_kHz );
   1647e:	ebc3 00c3 	rsb	r0, r3, r3, lsl #3
   16482:	f241 1ec4 	movw	lr, #4548	; 0x11c4
   16486:	0040      	lsls	r0, r0, #1
   16488:	f844 000e 	str.w	r0, [r4, lr]
            if( psEnc->sCmn.fs_kHz == 8 ) {
   1648c:	f504 588f 	add.w	r8, r4, #4576	; 0x11e0
            psEnc->sCmn.frame_length = silk_SMULBB( PacketSize_ms, fs_kHz );
   16490:	f241 10e8 	movw	r0, #4584	; 0x11e8
   16494:	fb11 f203 	smulbb	r2, r1, r3
            if( psEnc->sCmn.fs_kHz == 8 ) {
   16498:	f8d8 3000 	ldr.w	r3, [r8]
            psEnc->sCmn.frame_length = silk_SMULBB( PacketSize_ms, fs_kHz );
   1649c:	5022      	str	r2, [r4, r0]
            psEnc->sCmn.nb_subfr = PacketSize_ms == 10 ? 2 : 1;
   1649e:	f241 12e4 	movw	r2, #4580	; 0x11e4
            if( psEnc->sCmn.fs_kHz == 8 ) {
   164a2:	2b08      	cmp	r3, #8
            psEnc->sCmn.nb_subfr = PacketSize_ms == 10 ? 2 : 1;
   164a4:	f844 c002 	str.w	ip, [r4, r2]
                psEnc->sCmn.pitch_contour_iCDF = silk_pitch_contour_10_ms_NB_iCDF;
   164a8:	f241 2250 	movw	r2, #4688	; 0x1250
   164ac:	bf0c      	ite	eq
   164ae:	4867      	ldreq	r0, [pc, #412]	; (1664c <silk_control_encoder+0x654>)
                psEnc->sCmn.pitch_contour_iCDF = silk_pitch_contour_10_ms_iCDF;
   164b0:	4867      	ldrne	r0, [pc, #412]	; (16650 <silk_control_encoder+0x658>)
   164b2:	50a0      	str	r0, [r4, r2]
   164b4:	e635      	b.n	16122 <silk_control_encoder+0x12a>
        psEncC->pitchEstimationComplexity       = SILK_PE_MID_COMPLEX;
   164b6:	f241 2e24 	movw	lr, #4644	; 0x1224
        psEncC->pitchEstimationThreshold_Q16    = SILK_FIX_CONST( 0.76, 16 );
   164ba:	f241 2c2c 	movw	ip, #4652	; 0x122c
        psEncC->pitchEstimationComplexity       = SILK_PE_MID_COMPLEX;
   164be:	f844 600e 	str.w	r6, [r4, lr]
        psEncC->shapingLPCOrder                 = 14;
   164c2:	f241 231c 	movw	r3, #4636	; 0x121c
        psEncC->pitchEstimationThreshold_Q16    = SILK_FIX_CONST( 0.76, 16 );
   164c6:	f24c 2e8f 	movw	lr, #49807	; 0xc28f
   164ca:	f844 e00c 	str.w	lr, [r4, ip]
        psEncC->la_shape                        = 5 * psEncC->fs_kHz;
   164ce:	f241 11f8 	movw	r1, #4600	; 0x11f8
        psEncC->nStatesDelayedDecision          = 1;
   164d2:	f241 2c14 	movw	ip, #4628	; 0x1214
        psEncC->shapingLPCOrder                 = 14;
   164d6:	f04f 0e0e 	mov.w	lr, #14
   164da:	f844 e003 	str.w	lr, [r4, r3]
        psEncC->useInterpolatedNLSFs            = 0;
   164de:	f241 2e18 	movw	lr, #4632	; 0x1218
        psEncC->la_shape                        = 5 * psEncC->fs_kHz;
   164e2:	5062      	str	r2, [r4, r1]
        psEncC->NLSF_MSVQ_Survivors             = 3;
   164e4:	f241 2334 	movw	r3, #4660	; 0x1234
        psEncC->nStatesDelayedDecision          = 1;
   164e8:	f844 600c 	str.w	r6, [r4, ip]
        psEncC->warping_Q16                     = 0;
   164ec:	f504 5192 	add.w	r1, r4, #4672	; 0x1240
        psEncC->useInterpolatedNLSFs            = 0;
   164f0:	f04f 0c00 	mov.w	ip, #0
   164f4:	f844 c00e 	str.w	ip, [r4, lr]
        psEncC->NLSF_MSVQ_Survivors             = 3;
   164f8:	f04f 0e03 	mov.w	lr, #3
   164fc:	f844 e003 	str.w	lr, [r4, r3]
        psEncC->warping_Q16                     = 0;
   16500:	f8c1 c000 	str.w	ip, [r1]
   16504:	4613      	mov	r3, r2
   16506:	f04f 0c08 	mov.w	ip, #8
   1650a:	e64a      	b.n	161a2 <silk_control_encoder+0x1aa>
                psEnc->sCmn.pitch_contour_iCDF = silk_pitch_contour_10_ms_NB_iCDF;
   1650c:	484f      	ldr	r0, [pc, #316]	; (1664c <silk_control_encoder+0x654>)
   1650e:	4951      	ldr	r1, [pc, #324]	; (16654 <silk_control_encoder+0x65c>)
            psEnc->sCmn.psNLSF_CB  = &silk_NLSF_CB_NB_MB;
   16510:	4a51      	ldr	r2, [pc, #324]	; (16658 <silk_control_encoder+0x660>)
                psEnc->sCmn.pitch_contour_iCDF = silk_pitch_contour_10_ms_NB_iCDF;
   16512:	f1bc 0f04 	cmp.w	ip, #4
   16516:	bf18      	it	ne
   16518:	4601      	movne	r1, r0
   1651a:	f241 2050 	movw	r0, #4688	; 0x1250
            psEnc->sCmn.predictLPCOrder = MIN_LPC_ORDER;
   1651e:	469e      	mov	lr, r3
   16520:	5021      	str	r1, [r4, r0]
   16522:	e6c8      	b.n	162b6 <silk_control_encoder+0x2be>
            psEnc->sCmn.pitch_lag_low_bits_iCDF = silk_uniform8_iCDF;
   16524:	4a4d      	ldr	r2, [pc, #308]	; (1665c <silk_control_encoder+0x664>)
   16526:	50e2      	str	r2, [r4, r3]
   16528:	4633      	mov	r3, r6
   1652a:	e706      	b.n	1633a <silk_control_encoder+0x342>
        psEncC->pitchEstimationComplexity       = SILK_PE_MID_COMPLEX;
   1652c:	f241 2c24 	movw	ip, #4644	; 0x1224
        psEncC->pitchEstimationThreshold_Q16    = SILK_FIX_CONST( 0.76, 16 );
   16530:	f241 212c 	movw	r1, #4652	; 0x122c
        psEncC->pitchEstimationComplexity       = SILK_PE_MID_COMPLEX;
   16534:	f04f 0e01 	mov.w	lr, #1
   16538:	f844 e00c 	str.w	lr, [r4, ip]
        psEncC->shapingLPCOrder                 = 14;
   1653c:	f241 231c 	movw	r3, #4636	; 0x121c
        psEncC->la_shape                        = 5 * psEncC->fs_kHz;
   16540:	f241 1cf8 	movw	ip, #4600	; 0x11f8
        psEncC->pitchEstimationThreshold_Q16    = SILK_FIX_CONST( 0.76, 16 );
   16544:	f24c 2e8f 	movw	lr, #49807	; 0xc28f
   16548:	f844 e001 	str.w	lr, [r4, r1]
        psEncC->nStatesDelayedDecision          = 2;
   1654c:	f241 2114 	movw	r1, #4628	; 0x1214
        psEncC->shapingLPCOrder                 = 14;
   16550:	f04f 0e0e 	mov.w	lr, #14
   16554:	f844 e003 	str.w	lr, [r4, r3]
        psEncC->la_shape                        = 5 * psEncC->fs_kHz;
   16558:	f844 200c 	str.w	r2, [r4, ip]
        psEncC->useInterpolatedNLSFs            = 0;
   1655c:	f241 2e18 	movw	lr, #4632	; 0x1218
        psEncC->nStatesDelayedDecision          = 2;
   16560:	f04f 0c02 	mov.w	ip, #2
   16564:	f844 c001 	str.w	ip, [r4, r1]
        psEncC->NLSF_MSVQ_Survivors             = 4;
   16568:	f241 2334 	movw	r3, #4660	; 0x1234
        psEncC->useInterpolatedNLSFs            = 0;
   1656c:	f04f 0c00 	mov.w	ip, #0
        psEncC->warping_Q16                     = 0;
   16570:	f504 5192 	add.w	r1, r4, #4672	; 0x1240
        psEncC->useInterpolatedNLSFs            = 0;
   16574:	f844 c00e 	str.w	ip, [r4, lr]
        psEncC->NLSF_MSVQ_Survivors             = 4;
   16578:	f04f 0e04 	mov.w	lr, #4
   1657c:	f844 e003 	str.w	lr, [r4, r3]
        psEncC->warping_Q16                     = 0;
   16580:	f8c1 c000 	str.w	ip, [r1]
   16584:	4613      	mov	r3, r2
   16586:	f04f 0c08 	mov.w	ip, #8
   1658a:	e60a      	b.n	161a2 <silk_control_encoder+0x1aa>
        psEncC->pitchEstimationComplexity       = SILK_PE_MID_COMPLEX;
   1658c:	f241 2c24 	movw	ip, #4644	; 0x1224
   16590:	2301      	movs	r3, #1
        psEncC->useInterpolatedNLSFs            = 1;
   16592:	f241 2e18 	movw	lr, #4632	; 0x1218
        psEncC->pitchEstimationComplexity       = SILK_PE_MID_COMPLEX;
   16596:	f844 300c 	str.w	r3, [r4, ip]
        psEncC->pitchEstimationThreshold_Q16    = SILK_FIX_CONST( 0.74, 16 );
   1659a:	f241 2c2c 	movw	ip, #4652	; 0x122c
        psEncC->useInterpolatedNLSFs            = 1;
   1659e:	f844 300e 	str.w	r3, [r4, lr]
        psEncC->shapingLPCOrder                 = 16;
   165a2:	f241 231c 	movw	r3, #4636	; 0x121c
        psEncC->pitchEstimationThreshold_Q16    = SILK_FIX_CONST( 0.74, 16 );
   165a6:	f64b 5e71 	movw	lr, #48497	; 0xbd71
   165aa:	f844 e00c 	str.w	lr, [r4, ip]
        psEncC->la_shape                        = 5 * psEncC->fs_kHz;
   165ae:	f241 1ef8 	movw	lr, #4600	; 0x11f8
        psEncC->shapingLPCOrder                 = 16;
   165b2:	f04f 0c10 	mov.w	ip, #16
   165b6:	f844 c003 	str.w	ip, [r4, r3]
        psEncC->nStatesDelayedDecision          = 2;
   165ba:	f241 2c14 	movw	ip, #4628	; 0x1214
        psEncC->la_shape                        = 5 * psEncC->fs_kHz;
   165be:	f844 200e 	str.w	r2, [r4, lr]
        psEncC->nStatesDelayedDecision          = 2;
   165c2:	f04f 0e02 	mov.w	lr, #2
   165c6:	f844 e00c 	str.w	lr, [r4, ip]
        psEncC->NLSF_MSVQ_Survivors             = 6;
   165ca:	f241 2334 	movw	r3, #4660	; 0x1234
        psEncC->warping_Q16                     = psEncC->fs_kHz * SILK_FIX_CONST( WARPING_MULTIPLIER, 16 );
   165ce:	f504 5c92 	add.w	ip, r4, #4672	; 0x1240
        psEncC->NLSF_MSVQ_Survivors             = 6;
   165d2:	f04f 0e06 	mov.w	lr, #6
   165d6:	f844 e003 	str.w	lr, [r4, r3]
        psEncC->warping_Q16                     = psEncC->fs_kHz * SILK_FIX_CONST( WARPING_MULTIPLIER, 16 );
   165da:	f8cc 1000 	str.w	r1, [ip]
   165de:	4613      	mov	r3, r2
   165e0:	f04f 0c0a 	mov.w	ip, #10
   165e4:	e5dd      	b.n	161a2 <silk_control_encoder+0x1aa>
            psEnc->sCmn.nFramesPerPacket = 1;
   165e6:	f241 6270 	movw	r2, #5744	; 0x1670
   165ea:	2301      	movs	r3, #1
   165ec:	50a3      	str	r3, [r4, r2]
            psEnc->sCmn.nb_subfr = PacketSize_ms == 10 ? 2 : 1;
   165ee:	469c      	mov	ip, r3
   165f0:	e744      	b.n	1647c <silk_control_encoder+0x484>
        psEncC->pitchEstimationComplexity       = SILK_PE_MID_COMPLEX;
   165f2:	f241 2c24 	movw	ip, #4644	; 0x1224
   165f6:	2301      	movs	r3, #1
        psEncC->useInterpolatedNLSFs            = 1;
   165f8:	f241 2e18 	movw	lr, #4632	; 0x1218
        psEncC->pitchEstimationComplexity       = SILK_PE_MID_COMPLEX;
   165fc:	f844 300c 	str.w	r3, [r4, ip]
        psEncC->pitchEstimationThreshold_Q16    = SILK_FIX_CONST( 0.72, 16 );
   16600:	f241 2c2c 	movw	ip, #4652	; 0x122c
        psEncC->useInterpolatedNLSFs            = 1;
   16604:	f844 300e 	str.w	r3, [r4, lr]
        psEncC->shapingLPCOrder                 = 20;
   16608:	f241 231c 	movw	r3, #4636	; 0x121c
        psEncC->pitchEstimationThreshold_Q16    = SILK_FIX_CONST( 0.72, 16 );
   1660c:	f64b 0e52 	movw	lr, #47186	; 0xb852
   16610:	f844 e00c 	str.w	lr, [r4, ip]
        psEncC->la_shape                        = 5 * psEncC->fs_kHz;
   16614:	f241 1ef8 	movw	lr, #4600	; 0x11f8
        psEncC->shapingLPCOrder                 = 20;
   16618:	f04f 0c14 	mov.w	ip, #20
   1661c:	f844 c003 	str.w	ip, [r4, r3]
        psEncC->nStatesDelayedDecision          = 3;
   16620:	f241 2c14 	movw	ip, #4628	; 0x1214
        psEncC->la_shape                        = 5 * psEncC->fs_kHz;
   16624:	f844 200e 	str.w	r2, [r4, lr]
        psEncC->nStatesDelayedDecision          = 3;
   16628:	f04f 0e03 	mov.w	lr, #3
   1662c:	f844 e00c 	str.w	lr, [r4, ip]
        psEncC->NLSF_MSVQ_Survivors             = 8;
   16630:	f241 2334 	movw	r3, #4660	; 0x1234
        psEncC->warping_Q16                     = psEncC->fs_kHz * SILK_FIX_CONST( WARPING_MULTIPLIER, 16 );
   16634:	f504 5c92 	add.w	ip, r4, #4672	; 0x1240
        psEncC->NLSF_MSVQ_Survivors             = 8;
   16638:	f04f 0e08 	mov.w	lr, #8
   1663c:	f844 e003 	str.w	lr, [r4, r3]
        psEncC->warping_Q16                     = psEncC->fs_kHz * SILK_FIX_CONST( WARPING_MULTIPLIER, 16 );
   16640:	f8cc 1000 	str.w	r1, [ip]
   16644:	4613      	mov	r3, r2
   16646:	f04f 0c0c 	mov.w	ip, #12
   1664a:	e5aa      	b.n	161a2 <silk_control_encoder+0x1aa>
   1664c:	00036d60 	.word	0x00036d60
   16650:	00036d64 	.word	0x00036d64
   16654:	00036d70 	.word	0x00036d70
   16658:	000363c8 	.word	0x000363c8
   1665c:	00036d58 	.word	0x00036d58

00016660 <silk_A2NLSF>:
void silk_A2NLSF(
    opus_int16                  *NLSF,              /* O    Normalized Line Spectral Frequencies in Q15 (0..2^15-1) [d] */
    opus_int32                  *a_Q16,             /* I/O  Monic whitening filter coefficients in Q16 [d]              */
    const opus_int              d                   /* I    Filter order (must be even)                                 */
)
{
   16660:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   16664:	b0bb      	sub	sp, #236	; 0xec

    /* Store pointers to array */
    PQ[ 0 ] = P;
    PQ[ 1 ] = Q;

    dd = silk_RSHIFT( d, 1 );
   16666:	ea4f 0862 	mov.w	r8, r2, asr #1
{
   1666a:	9211      	str	r2, [sp, #68]	; 0x44
   1666c:	9117      	str	r1, [sp, #92]	; 0x5c
    P[dd] = silk_LSHIFT( 1, 16 );
   1666e:	ea4f 0288 	mov.w	r2, r8, lsl #2
    PQ[ 0 ] = P;
   16672:	a920      	add	r1, sp, #128	; 0x80
   16674:	911e      	str	r1, [sp, #120]	; 0x78
    P[dd] = silk_LSHIFT( 1, 16 );
   16676:	4411      	add	r1, r2
   16678:	910f      	str	r1, [sp, #60]	; 0x3c
    PQ[ 1 ] = Q;
   1667a:	a92d      	add	r1, sp, #180	; 0xb4
    P[dd] = silk_LSHIFT( 1, 16 );
   1667c:	920e      	str	r2, [sp, #56]	; 0x38
    Q[dd] = silk_LSHIFT( 1, 16 );
   1667e:	188a      	adds	r2, r1, r2
   16680:	9216      	str	r2, [sp, #88]	; 0x58
    P[dd] = silk_LSHIFT( 1, 16 );
   16682:	aa20      	add	r2, sp, #128	; 0x80
   16684:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    for( k = 0; k < dd; k++ ) {
   16688:	f1b8 0f00 	cmp.w	r8, #0
{
   1668c:	9015      	str	r0, [sp, #84]	; 0x54
    PQ[ 1 ] = Q;
   1668e:	911f      	str	r1, [sp, #124]	; 0x7c
    P[dd] = silk_LSHIFT( 1, 16 );
   16690:	f842 3028 	str.w	r3, [r2, r8, lsl #2]
    Q[dd] = silk_LSHIFT( 1, 16 );
   16694:	f841 3028 	str.w	r3, [r1, r8, lsl #2]
    for( k = 0; k < dd; k++ ) {
   16698:	f340 868b 	ble.w	173b2 <silk_A2NLSF+0xd52>
   1669c:	9f17      	ldr	r7, [sp, #92]	; 0x5c
   1669e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   166a0:	18f8      	adds	r0, r7, r3
   166a2:	f1a3 0904 	sub.w	r9, r3, #4
   166a6:	901d      	str	r0, [sp, #116]	; 0x74
   166a8:	eb07 0609 	add.w	r6, r7, r9
   166ac:	ad2d      	add	r5, sp, #180	; 0xb4
   166ae:	ac20      	add	r4, sp, #128	; 0x80
        P[ k ] = -a_Q16[ dd - k - 1 ] - a_Q16[ dd + k ];    /* Q16 */
   166b0:	f850 1d04 	ldr.w	r1, [r0, #-4]!
   166b4:	f856 3f04 	ldr.w	r3, [r6, #4]!
   166b8:	424a      	negs	r2, r1
   166ba:	1ad2      	subs	r2, r2, r3
    for( k = 0; k < dd; k++ ) {
   166bc:	4287      	cmp	r7, r0
        Q[ k ] = -a_Q16[ dd - k - 1 ] + a_Q16[ dd + k ];    /* Q16 */
   166be:	eba3 0301 	sub.w	r3, r3, r1
        P[ k ] = -a_Q16[ dd - k - 1 ] - a_Q16[ dd + k ];    /* Q16 */
   166c2:	f844 2b04 	str.w	r2, [r4], #4
        Q[ k ] = -a_Q16[ dd - k - 1 ] + a_Q16[ dd + k ];    /* Q16 */
   166c6:	f845 3b04 	str.w	r3, [r5], #4
    for( k = 0; k < dd; k++ ) {
   166ca:	d1f1      	bne.n	166b0 <silk_A2NLSF+0x50>
   166cc:	ab2d      	add	r3, sp, #180	; 0xb4
   166ce:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   166d0:	f853 0028 	ldr.w	r0, [r3, r8, lsl #2]
   166d4:	ab20      	add	r3, sp, #128	; 0x80
   166d6:	ac2d      	add	r4, sp, #180	; 0xb4
   166d8:	f853 1028 	ldr.w	r1, [r3, r8, lsl #2]
   166dc:	4413      	add	r3, r2
   166de:	18a2      	adds	r2, r4, r2
        Q[ k - 1 ] += Q[ k ];
   166e0:	f852 4d04 	ldr.w	r4, [r2, #-4]!
        P[ k - 1 ] -= P[ k ];
   166e4:	f853 5d04 	ldr.w	r5, [r3, #-4]!
        Q[ k - 1 ] += Q[ k ];
   166e8:	4420      	add	r0, r4
    for( k = dd; k > 0; k-- ) {
   166ea:	ac20      	add	r4, sp, #128	; 0x80
        P[ k - 1 ] -= P[ k ];
   166ec:	1a69      	subs	r1, r5, r1
    for( k = dd; k > 0; k-- ) {
   166ee:	429c      	cmp	r4, r3
        P[ k - 1 ] -= P[ k ];
   166f0:	6019      	str	r1, [r3, #0]
        Q[ k - 1 ] += Q[ k ];
   166f2:	6010      	str	r0, [r2, #0]
    for( k = dd; k > 0; k-- ) {
   166f4:	d1f4      	bne.n	166e0 <silk_A2NLSF+0x80>
    for( k = 2; k <= dd; k++ ) {
   166f6:	f1b8 0f01 	cmp.w	r8, #1
   166fa:	f340 8660 	ble.w	173be <silk_A2NLSF+0xd5e>
   166fe:	f1b8 0f02 	cmp.w	r8, #2
   16702:	dc57      	bgt.n	167b4 <silk_A2NLSF+0x154>
   16704:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
   16708:	2202      	movs	r2, #2
   1670a:	930d      	str	r3, [sp, #52]	; 0x34
   1670c:	f102 4080 	add.w	r0, r2, #1073741824	; 0x40000000
   16710:	3803      	subs	r0, #3
   16712:	ab20      	add	r3, sp, #128	; 0x80
   16714:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   16718:	3004      	adds	r0, #4
        p[ k - 2 ] -= silk_LSHIFT( p[ k ], 1 );
   1671a:	6803      	ldr	r3, [r0, #0]
   1671c:	6881      	ldr	r1, [r0, #8]
    for( k = 2; k <= dd; k++ ) {
   1671e:	3201      	adds	r2, #1
        p[ k - 2 ] -= silk_LSHIFT( p[ k ], 1 );
   16720:	eba3 0341 	sub.w	r3, r3, r1, lsl #1
    for( k = 2; k <= dd; k++ ) {
   16724:	4590      	cmp	r8, r2
        p[ k - 2 ] -= silk_LSHIFT( p[ k ], 1 );
   16726:	6003      	str	r3, [r0, #0]
    for( k = 2; k <= dd; k++ ) {
   16728:	daf6      	bge.n	16718 <silk_A2NLSF+0xb8>
   1672a:	f1b8 0f02 	cmp.w	r8, #2
   1672e:	f340 85cd 	ble.w	172cc <silk_A2NLSF+0xc6c>
   16732:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
   16736:	9816      	ldr	r0, [sp, #88]	; 0x58
   16738:	2503      	movs	r5, #3
   1673a:	4555      	cmp	r5, sl
   1673c:	ae2d      	add	r6, sp, #180	; 0xb4
   1673e:	f04f 0402 	mov.w	r4, #2
   16742:	f06f 4c40 	mvn.w	ip, #3221225472	; 0xc0000000
   16746:	da33      	bge.n	167b0 <silk_A2NLSF+0x150>
   16748:	45a0      	cmp	r8, r4
   1674a:	dd31      	ble.n	167b0 <silk_A2NLSF+0x150>
   1674c:	e950 7b01 	ldrd	r7, fp, [r0, #-4]
   16750:	4686      	mov	lr, r0
   16752:	4643      	mov	r3, r8
   16754:	9001      	str	r0, [sp, #4]
   16756:	465a      	mov	r2, fp
            p[ n - 2 ] -= p[ n ];
   16758:	e95e 1003 	ldrd	r1, r0, [lr, #-12]
   1675c:	1bcf      	subs	r7, r1, r7
   1675e:	1ed9      	subs	r1, r3, #3
   16760:	1a82      	subs	r2, r0, r2
   16762:	428d      	cmp	r5, r1
   16764:	e94e 7203 	strd	r7, r2, [lr, #-12]
   16768:	f1a3 0302 	sub.w	r3, r3, #2
   1676c:	f1ae 0e08 	sub.w	lr, lr, #8
   16770:	dbf2      	blt.n	16758 <silk_A2NLSF+0xf8>
   16772:	9801      	ldr	r0, [sp, #4]
   16774:	eb03 0e0c 	add.w	lr, r3, ip
   16778:	aa2d      	add	r2, sp, #180	; 0xb4
   1677a:	eb02 0e8e 	add.w	lr, r2, lr, lsl #2
   1677e:	f85e 2d04 	ldr.w	r2, [lr, #-4]!
   16782:	f8de 1008 	ldr.w	r1, [lr, #8]
        for( n = dd; n > k; n-- ) {
   16786:	3b01      	subs	r3, #1
            p[ n - 2 ] -= p[ n ];
   16788:	1a52      	subs	r2, r2, r1
        for( n = dd; n > k; n-- ) {
   1678a:	429c      	cmp	r4, r3
            p[ n - 2 ] -= p[ n ];
   1678c:	f8ce 2000 	str.w	r2, [lr]
        for( n = dd; n > k; n-- ) {
   16790:	dbf5      	blt.n	1677e <silk_A2NLSF+0x11e>
        p[ k - 2 ] -= silk_LSHIFT( p[ k ], 1 );
   16792:	f856 2b04 	ldr.w	r2, [r6], #4
   16796:	6873      	ldr	r3, [r6, #4]
   16798:	eba2 0343 	sub.w	r3, r2, r3, lsl #1
    for( k = 2; k <= dd; k++ ) {
   1679c:	1c62      	adds	r2, r4, #1
   1679e:	4590      	cmp	r8, r2
   167a0:	f105 0501 	add.w	r5, r5, #1
        p[ k - 2 ] -= silk_LSHIFT( p[ k ], 1 );
   167a4:	f846 3c04 	str.w	r3, [r6, #-4]
    for( k = 2; k <= dd; k++ ) {
   167a8:	dd48      	ble.n	1683c <silk_A2NLSF+0x1dc>
   167aa:	4555      	cmp	r5, sl
   167ac:	4614      	mov	r4, r2
   167ae:	dbcb      	blt.n	16748 <silk_A2NLSF+0xe8>
   167b0:	4643      	mov	r3, r8
   167b2:	e7df      	b.n	16774 <silk_A2NLSF+0x114>
   167b4:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
   167b8:	2503      	movs	r5, #3
   167ba:	469a      	mov	sl, r3
   167bc:	4555      	cmp	r5, sl
   167be:	ae20      	add	r6, sp, #128	; 0x80
   167c0:	f04f 0402 	mov.w	r4, #2
   167c4:	930d      	str	r3, [sp, #52]	; 0x34
   167c6:	f06f 4c40 	mvn.w	ip, #3221225472	; 0xc0000000
   167ca:	980f      	ldr	r0, [sp, #60]	; 0x3c
   167cc:	da34      	bge.n	16838 <silk_A2NLSF+0x1d8>
   167ce:	45a0      	cmp	r8, r4
   167d0:	dd32      	ble.n	16838 <silk_A2NLSF+0x1d8>
   167d2:	e950 7b01 	ldrd	r7, fp, [r0, #-4]
    for( k = 0; k < dd; k++ ) {
   167d6:	4686      	mov	lr, r0
   167d8:	4643      	mov	r3, r8
   167da:	9001      	str	r0, [sp, #4]
   167dc:	465a      	mov	r2, fp
            p[ n - 2 ] -= p[ n ];
   167de:	e95e 1003 	ldrd	r1, r0, [lr, #-12]
   167e2:	1bcf      	subs	r7, r1, r7
   167e4:	1ed9      	subs	r1, r3, #3
   167e6:	1a82      	subs	r2, r0, r2
   167e8:	428d      	cmp	r5, r1
   167ea:	e94e 7203 	strd	r7, r2, [lr, #-12]
   167ee:	f1a3 0302 	sub.w	r3, r3, #2
   167f2:	f1ae 0e08 	sub.w	lr, lr, #8
   167f6:	dbf2      	blt.n	167de <silk_A2NLSF+0x17e>
   167f8:	9801      	ldr	r0, [sp, #4]
   167fa:	eb03 0e0c 	add.w	lr, r3, ip
   167fe:	aa20      	add	r2, sp, #128	; 0x80
   16800:	eb02 0e8e 	add.w	lr, r2, lr, lsl #2
   16804:	f85e 2d04 	ldr.w	r2, [lr, #-4]!
   16808:	f8de 1008 	ldr.w	r1, [lr, #8]
        for( n = dd; n > k; n-- ) {
   1680c:	3b01      	subs	r3, #1
            p[ n - 2 ] -= p[ n ];
   1680e:	1a52      	subs	r2, r2, r1
        for( n = dd; n > k; n-- ) {
   16810:	429c      	cmp	r4, r3
            p[ n - 2 ] -= p[ n ];
   16812:	f8ce 2000 	str.w	r2, [lr]
        for( n = dd; n > k; n-- ) {
   16816:	dbf5      	blt.n	16804 <silk_A2NLSF+0x1a4>
        p[ k - 2 ] -= silk_LSHIFT( p[ k ], 1 );
   16818:	f856 2b04 	ldr.w	r2, [r6], #4
   1681c:	6873      	ldr	r3, [r6, #4]
   1681e:	eba2 0343 	sub.w	r3, r2, r3, lsl #1
    for( k = 2; k <= dd; k++ ) {
   16822:	1c62      	adds	r2, r4, #1
   16824:	4590      	cmp	r8, r2
   16826:	f105 0501 	add.w	r5, r5, #1
        p[ k - 2 ] -= silk_LSHIFT( p[ k ], 1 );
   1682a:	f846 3c04 	str.w	r3, [r6, #-4]
    for( k = 2; k <= dd; k++ ) {
   1682e:	f340 852c 	ble.w	1728a <silk_A2NLSF+0xc2a>
   16832:	4555      	cmp	r5, sl
   16834:	4614      	mov	r4, r2
   16836:	dbca      	blt.n	167ce <silk_A2NLSF+0x16e>
    for( k = 0; k < dd; k++ ) {
   16838:	4643      	mov	r3, r8
   1683a:	e7de      	b.n	167fa <silk_A2NLSF+0x19a>
   1683c:	db2a      	blt.n	16894 <silk_A2NLSF+0x234>
   1683e:	3402      	adds	r4, #2
   16840:	ab2d      	add	r3, sp, #180	; 0xb4
   16842:	45a0      	cmp	r8, r4
   16844:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   16848:	dd15      	ble.n	16876 <silk_A2NLSF+0x216>
   1684a:	e953 0102 	ldrd	r0, r1, [r3, #-8]
        p[ k - 2 ] -= silk_LSHIFT( p[ k ], 1 );
   1684e:	e9d3 6500 	ldrd	r6, r5, [r3]
   16852:	4614      	mov	r4, r2
   16854:	3403      	adds	r4, #3
   16856:	eba0 0046 	sub.w	r0, r0, r6, lsl #1
   1685a:	eba1 0145 	sub.w	r1, r1, r5, lsl #1
   1685e:	45a0      	cmp	r8, r4
   16860:	f843 0c08 	str.w	r0, [r3, #-8]
   16864:	f843 1c04 	str.w	r1, [r3, #-4]
   16868:	4630      	mov	r0, r6
   1686a:	4629      	mov	r1, r5
   1686c:	f103 0308 	add.w	r3, r3, #8
   16870:	f102 0202 	add.w	r2, r2, #2
   16874:	dceb      	bgt.n	1684e <silk_A2NLSF+0x1ee>
   16876:	f102 4080 	add.w	r0, r2, #1073741824	; 0x40000000
   1687a:	3803      	subs	r0, #3
   1687c:	ab2d      	add	r3, sp, #180	; 0xb4
   1687e:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   16882:	3004      	adds	r0, #4
   16884:	6803      	ldr	r3, [r0, #0]
   16886:	6881      	ldr	r1, [r0, #8]
    for( k = 2; k <= dd; k++ ) {
   16888:	3201      	adds	r2, #1
        p[ k - 2 ] -= silk_LSHIFT( p[ k ], 1 );
   1688a:	eba3 0341 	sub.w	r3, r3, r1, lsl #1
    for( k = 2; k <= dd; k++ ) {
   1688e:	4590      	cmp	r8, r2
        p[ k - 2 ] -= silk_LSHIFT( p[ k ], 1 );
   16890:	6003      	str	r3, [r0, #0]
    for( k = 2; k <= dd; k++ ) {
   16892:	daf6      	bge.n	16882 <silk_A2NLSF+0x222>
    silk_A2NLSF_init( a_Q16, P, Q, dd );

    /* Find roots, alternating between P and Q */
    p = P;                          /* Pointer to polynomial */

    xlo = silk_LSFCosTab_FIX_Q12[ 0 ]; /* Q12*/
   16894:	4bba      	ldr	r3, [pc, #744]	; (16b80 <silk_A2NLSF+0x520>)
   16896:	9310      	str	r3, [sp, #64]	; 0x40
    y32 = p[ dd ];                                  /* Q16 */
   16898:	aa20      	add	r2, sp, #128	; 0x80
    xlo = silk_LSFCosTab_FIX_Q12[ 0 ]; /* Q12*/
   1689a:	f9b3 3000 	ldrsh.w	r3, [r3]
    y32 = p[ dd ];                                  /* Q16 */
   1689e:	f852 e028 	ldr.w	lr, [r2, r8, lsl #2]
    xlo = silk_LSFCosTab_FIX_Q12[ 0 ]; /* Q12*/
   168a2:	9318      	str	r3, [sp, #96]	; 0x60
    x_Q16 = silk_LSHIFT( x, 4 );
   168a4:	011a      	lsls	r2, r3, #4
   168a6:	13d3      	asrs	r3, r2, #15
   168a8:	3301      	adds	r3, #1
   168aa:	105d      	asrs	r5, r3, #1
    if ( opus_likely( 8 == dd ) )
   168ac:	f1b8 0f08 	cmp.w	r8, #8
    x_Q16 = silk_LSHIFT( x, 4 );
   168b0:	921b      	str	r2, [sp, #108]	; 0x6c
   168b2:	9513      	str	r5, [sp, #76]	; 0x4c
    if ( opus_likely( 8 == dd ) )
   168b4:	f040 8594 	bne.w	173e0 <silk_A2NLSF+0xd80>
        y32 = silk_SMLAWW( p[ 7 ], y32, x_Q16 );
   168b8:	b211      	sxth	r1, r2
   168ba:	fa1f f48e 	uxth.w	r4, lr
        y32 = silk_SMLAWW( p[ 6 ], y32, x_Q16 );
   168be:	e9dd 3226 	ldrd	r3, r2, [sp, #152]	; 0x98
        y32 = silk_SMLAWW( p[ 7 ], y32, x_Q16 );
   168c2:	ea4f 402e 	mov.w	r0, lr, asr #16
   168c6:	fb01 f404 	mul.w	r4, r1, r4
   168ca:	fb01 f000 	mul.w	r0, r1, r0
   168ce:	eb00 4024 	add.w	r0, r0, r4, asr #16
   168d2:	4402      	add	r2, r0
   168d4:	fb05 220e 	mla	r2, r5, lr, r2
        y32 = silk_SMLAWW( p[ 6 ], y32, x_Q16 );
   168d8:	b294      	uxth	r4, r2
   168da:	1410      	asrs	r0, r2, #16
   168dc:	fb01 f404 	mul.w	r4, r1, r4
   168e0:	fb01 f000 	mul.w	r0, r1, r0
   168e4:	eb00 4024 	add.w	r0, r0, r4, asr #16
   168e8:	4418      	add	r0, r3
   168ea:	fb05 0002 	mla	r0, r5, r2, r0
        y32 = silk_SMLAWW( p[ 5 ], y32, x_Q16 );
   168ee:	b284      	uxth	r4, r0
   168f0:	1402      	asrs	r2, r0, #16
   168f2:	fb01 f404 	mul.w	r4, r1, r4
   168f6:	9b25      	ldr	r3, [sp, #148]	; 0x94
   168f8:	fb01 f202 	mul.w	r2, r1, r2
   168fc:	eb02 4224 	add.w	r2, r2, r4, asr #16
   16900:	441a      	add	r2, r3
   16902:	fb05 2000 	mla	r0, r5, r0, r2
        y32 = silk_SMLAWW( p[ 4 ], y32, x_Q16 );
   16906:	b284      	uxth	r4, r0
   16908:	1402      	asrs	r2, r0, #16
   1690a:	fb01 f404 	mul.w	r4, r1, r4
   1690e:	9b24      	ldr	r3, [sp, #144]	; 0x90
   16910:	fb01 f202 	mul.w	r2, r1, r2
   16914:	eb02 4224 	add.w	r2, r2, r4, asr #16
   16918:	441a      	add	r2, r3
   1691a:	fb05 2000 	mla	r0, r5, r0, r2
        y32 = silk_SMLAWW( p[ 3 ], y32, x_Q16 );
   1691e:	b284      	uxth	r4, r0
   16920:	1402      	asrs	r2, r0, #16
   16922:	fb01 f404 	mul.w	r4, r1, r4
   16926:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   16928:	fb01 f202 	mul.w	r2, r1, r2
   1692c:	eb02 4224 	add.w	r2, r2, r4, asr #16
   16930:	441a      	add	r2, r3
   16932:	fb05 2000 	mla	r0, r5, r0, r2
        y32 = silk_SMLAWW( p[ 2 ], y32, x_Q16 );
   16936:	b284      	uxth	r4, r0
   16938:	1402      	asrs	r2, r0, #16
   1693a:	fb01 f404 	mul.w	r4, r1, r4
   1693e:	9b22      	ldr	r3, [sp, #136]	; 0x88
   16940:	fb01 f202 	mul.w	r2, r1, r2
   16944:	eb02 4224 	add.w	r2, r2, r4, asr #16
   16948:	441a      	add	r2, r3
   1694a:	fb05 2000 	mla	r0, r5, r0, r2
        y32 = silk_SMLAWW( p[ 1 ], y32, x_Q16 );
   1694e:	b284      	uxth	r4, r0
   16950:	1402      	asrs	r2, r0, #16
   16952:	fb01 f404 	mul.w	r4, r1, r4
   16956:	9b21      	ldr	r3, [sp, #132]	; 0x84
   16958:	fb01 f202 	mul.w	r2, r1, r2
   1695c:	eb02 4224 	add.w	r2, r2, r4, asr #16
   16960:	441a      	add	r2, r3
   16962:	fb05 2200 	mla	r2, r5, r0, r2
        y32 = silk_SMLAWW( p[ 0 ], y32, x_Q16 );
   16966:	b294      	uxth	r4, r2
   16968:	1410      	asrs	r0, r2, #16
   1696a:	fb01 f404 	mul.w	r4, r1, r4
   1696e:	fb01 f000 	mul.w	r0, r1, r0
   16972:	9b20      	ldr	r3, [sp, #128]	; 0x80
   16974:	eb00 4024 	add.w	r0, r0, r4, asr #16
   16978:	4418      	add	r0, r3
   1697a:	fb05 0c02 	mla	ip, r5, r2, r0
    ylo = silk_A2NLSF_eval_poly( p, xlo, dd );

    if( ylo < 0 ) {
   1697e:	f1bc 0f00 	cmp.w	ip, #0
   16982:	f2c0 84a6 	blt.w	172d2 <silk_A2NLSF+0xc72>
        NLSF[ 0 ] = 0;
        p = Q;                      /* Pointer to polynomial */
        ylo = silk_A2NLSF_eval_poly( p, xlo, dd );
        root_ix = 1;                /* Index of current root */
    } else {
        root_ix = 0;                /* Index of current root */
   16986:	2300      	movs	r3, #0
    p = P;                          /* Pointer to polynomial */
   16988:	af20      	add	r7, sp, #128	; 0x80
        root_ix = 0;                /* Index of current root */
   1698a:	930b      	str	r3, [sp, #44]	; 0x2c
   1698c:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1698e:	9917      	ldr	r1, [sp, #92]	; 0x5c
   16990:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
   16994:	931a      	str	r3, [sp, #104]	; 0x68
                    ylo = silk_A2NLSF_eval_poly( p, xlo, dd );
                    root_ix = 1;                  /* Index of current root */
                } else {
                    root_ix = 0;                  /* Index of current root */
                }
                k = 1;                            /* Reset loop counter */
   16996:	9306      	str	r3, [sp, #24]
   16998:	011b      	lsls	r3, r3, #4
   1699a:	2200      	movs	r2, #0
   1699c:	9307      	str	r3, [sp, #28]
   1699e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   169a0:	9205      	str	r2, [sp, #20]
   169a2:	920a      	str	r2, [sp, #40]	; 0x28
   169a4:	aa2d      	add	r2, sp, #180	; 0xb4
   169a6:	441a      	add	r2, r3
   169a8:	9214      	str	r2, [sp, #80]	; 0x50
   169aa:	aa20      	add	r2, sp, #128	; 0x80
   169ac:	18d3      	adds	r3, r2, r3
   169ae:	9312      	str	r3, [sp, #72]	; 0x48
   169b0:	9b18      	ldr	r3, [sp, #96]	; 0x60
   169b2:	9302      	str	r3, [sp, #8]
   169b4:	4449      	add	r1, r9
   169b6:	2301      	movs	r3, #1
   169b8:	911c      	str	r1, [sp, #112]	; 0x70
   169ba:	9303      	str	r3, [sp, #12]
   169bc:	46f3      	mov	fp, lr
        xhi = silk_LSFCosTab_FIX_Q12[ k ]; /* Q12 */
   169be:	9b06      	ldr	r3, [sp, #24]
   169c0:	9301      	str	r3, [sp, #4]
    if ( opus_likely( 8 == dd ) )
   169c2:	f1b8 0f08 	cmp.w	r8, #8
   169c6:	f040 8136 	bne.w	16c36 <silk_A2NLSF+0x5d6>
        y32 = silk_SMLAWW( p[ 7 ], y32, x_Q16 );
   169ca:	9c07      	ldr	r4, [sp, #28]
        y32 = silk_SMLAWW( p[ 6 ], y32, x_Q16 );
   169cc:	e9d7 3206 	ldrd	r3, r2, [r7, #24]
        y32 = silk_SMLAWW( p[ 7 ], y32, x_Q16 );
   169d0:	b221      	sxth	r1, r4
   169d2:	fa1f f08b 	uxth.w	r0, fp
   169d6:	ea4f 452b 	mov.w	r5, fp, asr #16
   169da:	fb01 f000 	mul.w	r0, r1, r0
   169de:	fb01 f505 	mul.w	r5, r1, r5
   169e2:	13e4      	asrs	r4, r4, #15
   169e4:	eb05 4520 	add.w	r5, r5, r0, asr #16
   169e8:	3401      	adds	r4, #1
   169ea:	1060      	asrs	r0, r4, #1
   169ec:	442a      	add	r2, r5
   169ee:	fb0b 2200 	mla	r2, fp, r0, r2
        y32 = silk_SMLAWW( p[ 6 ], y32, x_Q16 );
   169f2:	b295      	uxth	r5, r2
   169f4:	1414      	asrs	r4, r2, #16
   169f6:	fb01 f505 	mul.w	r5, r1, r5
   169fa:	fb01 f404 	mul.w	r4, r1, r4
   169fe:	eb04 4425 	add.w	r4, r4, r5, asr #16
   16a02:	4423      	add	r3, r4
   16a04:	fb02 3300 	mla	r3, r2, r0, r3
        y32 = silk_SMLAWW( p[ 5 ], y32, x_Q16 );
   16a08:	b29e      	uxth	r6, r3
   16a0a:	141d      	asrs	r5, r3, #16
   16a0c:	fb01 f505 	mul.w	r5, r1, r5
   16a10:	fb01 f606 	mul.w	r6, r1, r6
   16a14:	697a      	ldr	r2, [r7, #20]
   16a16:	eb05 4626 	add.w	r6, r5, r6, asr #16
   16a1a:	4416      	add	r6, r2
   16a1c:	fb03 6200 	mla	r2, r3, r0, r6
        y32 = silk_SMLAWW( p[ 4 ], y32, x_Q16 );
   16a20:	b294      	uxth	r4, r2
   16a22:	ea4f 4e22 	mov.w	lr, r2, asr #16
   16a26:	fb01 f404 	mul.w	r4, r1, r4
   16a2a:	fb01 fe0e 	mul.w	lr, r1, lr
   16a2e:	693b      	ldr	r3, [r7, #16]
   16a30:	eb0e 4424 	add.w	r4, lr, r4, asr #16
   16a34:	441c      	add	r4, r3
   16a36:	fb02 4600 	mla	r6, r2, r0, r4
        y32 = silk_SMLAWW( p[ 3 ], y32, x_Q16 );
   16a3a:	b2b5      	uxth	r5, r6
   16a3c:	1432      	asrs	r2, r6, #16
   16a3e:	fb01 f202 	mul.w	r2, r1, r2
   16a42:	fb01 f505 	mul.w	r5, r1, r5
   16a46:	68fb      	ldr	r3, [r7, #12]
   16a48:	eb02 4525 	add.w	r5, r2, r5, asr #16
   16a4c:	441d      	add	r5, r3
   16a4e:	fb06 5400 	mla	r4, r6, r0, r5
        y32 = silk_SMLAWW( p[ 2 ], y32, x_Q16 );
   16a52:	b2a5      	uxth	r5, r4
   16a54:	1422      	asrs	r2, r4, #16
   16a56:	fb01 f202 	mul.w	r2, r1, r2
   16a5a:	fb01 f505 	mul.w	r5, r1, r5
   16a5e:	68bb      	ldr	r3, [r7, #8]
   16a60:	eb02 4525 	add.w	r5, r2, r5, asr #16
   16a64:	441d      	add	r5, r3
   16a66:	fb04 5500 	mla	r5, r4, r0, r5
        y32 = silk_SMLAWW( p[ 1 ], y32, x_Q16 );
   16a6a:	b2ac      	uxth	r4, r5
   16a6c:	142a      	asrs	r2, r5, #16
   16a6e:	fb01 f404 	mul.w	r4, r1, r4
   16a72:	fb01 f202 	mul.w	r2, r1, r2
   16a76:	687b      	ldr	r3, [r7, #4]
   16a78:	eb02 4224 	add.w	r2, r2, r4, asr #16
   16a7c:	18d4      	adds	r4, r2, r3
   16a7e:	fb05 4500 	mla	r5, r5, r0, r4
        y32 = silk_SMLAWW( p[ 0 ], y32, x_Q16 );
   16a82:	142a      	asrs	r2, r5, #16
   16a84:	b2ab      	uxth	r3, r5
   16a86:	fb01 f303 	mul.w	r3, r1, r3
   16a8a:	fb01 f102 	mul.w	r1, r1, r2
   16a8e:	683a      	ldr	r2, [r7, #0]
   16a90:	eb01 4123 	add.w	r1, r1, r3, asr #16
   16a94:	4411      	add	r1, r2
   16a96:	fb05 1400 	mla	r4, r5, r0, r1
        if( ( ylo <= 0 && yhi >= thr ) || ( ylo >= 0 && yhi <= -thr ) ) {
   16a9a:	f1bc 0f00 	cmp.w	ip, #0
   16a9e:	f340 80ab 	ble.w	16bf8 <silk_A2NLSF+0x598>
   16aa2:	9b05      	ldr	r3, [sp, #20]
   16aa4:	425b      	negs	r3, r3
   16aa6:	42a3      	cmp	r3, r4
   16aa8:	f280 80e5 	bge.w	16c76 <silk_A2NLSF+0x616>
            k++;
   16aac:	9b03      	ldr	r3, [sp, #12]
   16aae:	3301      	adds	r3, #1
            if( k > LSF_COS_TAB_SZ_FIX ) {
   16ab0:	2b80      	cmp	r3, #128	; 0x80
            k++;
   16ab2:	9303      	str	r3, [sp, #12]
            if( k > LSF_COS_TAB_SZ_FIX ) {
   16ab4:	f340 80ad 	ble.w	16c12 <silk_A2NLSF+0x5b2>
                i++;
   16ab8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16aba:	3301      	adds	r3, #1
                if( i > MAX_ITERATIONS_A2NLSF_FIX ) {
   16abc:	2b10      	cmp	r3, #16
                i++;
   16abe:	930a      	str	r3, [sp, #40]	; 0x28
                if( i > MAX_ITERATIONS_A2NLSF_FIX ) {
   16ac0:	f300 8384 	bgt.w	171cc <silk_A2NLSF+0xb6c>
                silk_bwexpander_32( a_Q16, d, 65536 - silk_LSHIFT( 1, i ) );
   16ac4:	9f17      	ldr	r7, [sp, #92]	; 0x5c
   16ac6:	9911      	ldr	r1, [sp, #68]	; 0x44
   16ac8:	2201      	movs	r2, #1
   16aca:	409a      	lsls	r2, r3
   16acc:	f5c2 3280 	rsb	r2, r2, #65536	; 0x10000
   16ad0:	4638      	mov	r0, r7
   16ad2:	f000 fef5 	bl	178c0 <silk_bwexpander_32>
    P[dd] = silk_LSHIFT( 1, 16 );
   16ad6:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   16ad8:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   16adc:	6013      	str	r3, [r2, #0]
    Q[dd] = silk_LSHIFT( 1, 16 );
   16ade:	9a16      	ldr	r2, [sp, #88]	; 0x58
    for( k = 0; k < dd; k++ ) {
   16ae0:	f1b8 0f00 	cmp.w	r8, #0
    Q[dd] = silk_LSHIFT( 1, 16 );
   16ae4:	6013      	str	r3, [r2, #0]
    for( k = 0; k < dd; k++ ) {
   16ae6:	f340 838d 	ble.w	17204 <silk_A2NLSF+0xba4>
   16aea:	e9dd 401c 	ldrd	r4, r0, [sp, #112]	; 0x70
   16aee:	ae2d      	add	r6, sp, #180	; 0xb4
   16af0:	ad20      	add	r5, sp, #128	; 0x80
        P[ k ] = -a_Q16[ dd - k - 1 ] - a_Q16[ dd + k ];    /* Q16 */
   16af2:	f850 1d04 	ldr.w	r1, [r0, #-4]!
   16af6:	f854 3f04 	ldr.w	r3, [r4, #4]!
   16afa:	424a      	negs	r2, r1
   16afc:	1ad2      	subs	r2, r2, r3
    for( k = 0; k < dd; k++ ) {
   16afe:	4287      	cmp	r7, r0
        Q[ k ] = -a_Q16[ dd - k - 1 ] + a_Q16[ dd + k ];    /* Q16 */
   16b00:	eba3 0301 	sub.w	r3, r3, r1
        P[ k ] = -a_Q16[ dd - k - 1 ] - a_Q16[ dd + k ];    /* Q16 */
   16b04:	f845 2b04 	str.w	r2, [r5], #4
        Q[ k ] = -a_Q16[ dd - k - 1 ] + a_Q16[ dd + k ];    /* Q16 */
   16b08:	f846 3b04 	str.w	r3, [r6], #4
    for( k = 0; k < dd; k++ ) {
   16b0c:	d1f1      	bne.n	16af2 <silk_A2NLSF+0x492>
   16b0e:	9a14      	ldr	r2, [sp, #80]	; 0x50
   16b10:	9b12      	ldr	r3, [sp, #72]	; 0x48
   16b12:	6810      	ldr	r0, [r2, #0]
   16b14:	6819      	ldr	r1, [r3, #0]
        Q[ k - 1 ] += Q[ k ];
   16b16:	f852 4d04 	ldr.w	r4, [r2, #-4]!
        P[ k - 1 ] -= P[ k ];
   16b1a:	f853 5d04 	ldr.w	r5, [r3, #-4]!
        Q[ k - 1 ] += Q[ k ];
   16b1e:	4420      	add	r0, r4
    for( k = dd; k > 0; k-- ) {
   16b20:	ac20      	add	r4, sp, #128	; 0x80
        P[ k - 1 ] -= P[ k ];
   16b22:	1a69      	subs	r1, r5, r1
    for( k = dd; k > 0; k-- ) {
   16b24:	429c      	cmp	r4, r3
        P[ k - 1 ] -= P[ k ];
   16b26:	6019      	str	r1, [r3, #0]
        Q[ k - 1 ] += Q[ k ];
   16b28:	6010      	str	r0, [r2, #0]
    for( k = dd; k > 0; k-- ) {
   16b2a:	d1f4      	bne.n	16b16 <silk_A2NLSF+0x4b6>
    for( k = 2; k <= dd; k++ ) {
   16b2c:	f1b8 0f01 	cmp.w	r8, #1
   16b30:	f340 8368 	ble.w	17204 <silk_A2NLSF+0xba4>
   16b34:	f1b8 0f02 	cmp.w	r8, #2
   16b38:	bfd8      	it	le
   16b3a:	2202      	movle	r2, #2
   16b3c:	f300 823b 	bgt.w	16fb6 <silk_A2NLSF+0x956>
   16b40:	f102 4080 	add.w	r0, r2, #1073741824	; 0x40000000
   16b44:	3803      	subs	r0, #3
   16b46:	ab20      	add	r3, sp, #128	; 0x80
   16b48:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   16b4c:	3004      	adds	r0, #4
        p[ k - 2 ] -= silk_LSHIFT( p[ k ], 1 );
   16b4e:	6803      	ldr	r3, [r0, #0]
   16b50:	6881      	ldr	r1, [r0, #8]
    for( k = 2; k <= dd; k++ ) {
   16b52:	3201      	adds	r2, #1
        p[ k - 2 ] -= silk_LSHIFT( p[ k ], 1 );
   16b54:	eba3 0341 	sub.w	r3, r3, r1, lsl #1
    for( k = 2; k <= dd; k++ ) {
   16b58:	4590      	cmp	r8, r2
        p[ k - 2 ] -= silk_LSHIFT( p[ k ], 1 );
   16b5a:	6003      	str	r3, [r0, #0]
    for( k = 2; k <= dd; k++ ) {
   16b5c:	daf6      	bge.n	16b4c <silk_A2NLSF+0x4ec>
   16b5e:	f1b8 0f02 	cmp.w	r8, #2
   16b62:	f340 828c 	ble.w	1707e <silk_A2NLSF+0xa1e>
   16b66:	f8dd e034 	ldr.w	lr, [sp, #52]	; 0x34
   16b6a:	9f14      	ldr	r7, [sp, #80]	; 0x50
   16b6c:	2503      	movs	r5, #3
   16b6e:	4575      	cmp	r5, lr
   16b70:	ae2d      	add	r6, sp, #180	; 0xb4
   16b72:	f04f 0402 	mov.w	r4, #2
   16b76:	f06f 4c40 	mvn.w	ip, #3221225472	; 0xc0000000
   16b7a:	da3b      	bge.n	16bf4 <silk_A2NLSF+0x594>
   16b7c:	e002      	b.n	16b84 <silk_A2NLSF+0x524>
   16b7e:	bf00      	nop
   16b80:	000373d4 	.word	0x000373d4
   16b84:	45a0      	cmp	r8, r4
   16b86:	dd35      	ble.n	16bf4 <silk_A2NLSF+0x594>
   16b88:	e957 9a01 	ldrd	r9, sl, [r7, #-4]
   16b8c:	463a      	mov	r2, r7
   16b8e:	4648      	mov	r0, r9
   16b90:	4643      	mov	r3, r8
   16b92:	46a1      	mov	r9, r4
   16b94:	4654      	mov	r4, sl
   16b96:	46b2      	mov	sl, r6
            p[ n - 2 ] -= p[ n ];
   16b98:	f852 1c08 	ldr.w	r1, [r2, #-8]
   16b9c:	f852 6c0c 	ldr.w	r6, [r2, #-12]
   16ba0:	1b0c      	subs	r4, r1, r4
   16ba2:	1ed9      	subs	r1, r3, #3
   16ba4:	1a30      	subs	r0, r6, r0
   16ba6:	428d      	cmp	r5, r1
   16ba8:	e942 0403 	strd	r0, r4, [r2, #-12]
   16bac:	f1a3 0302 	sub.w	r3, r3, #2
   16bb0:	f1a2 0208 	sub.w	r2, r2, #8
   16bb4:	dbf0      	blt.n	16b98 <silk_A2NLSF+0x538>
   16bb6:	464c      	mov	r4, r9
   16bb8:	4656      	mov	r6, sl
   16bba:	eb03 000c 	add.w	r0, r3, ip
   16bbe:	aa2d      	add	r2, sp, #180	; 0xb4
   16bc0:	eb02 0080 	add.w	r0, r2, r0, lsl #2
   16bc4:	f850 2d04 	ldr.w	r2, [r0, #-4]!
   16bc8:	6881      	ldr	r1, [r0, #8]
        for( n = dd; n > k; n-- ) {
   16bca:	3b01      	subs	r3, #1
            p[ n - 2 ] -= p[ n ];
   16bcc:	1a52      	subs	r2, r2, r1
        for( n = dd; n > k; n-- ) {
   16bce:	429c      	cmp	r4, r3
            p[ n - 2 ] -= p[ n ];
   16bd0:	6002      	str	r2, [r0, #0]
        for( n = dd; n > k; n-- ) {
   16bd2:	dbf7      	blt.n	16bc4 <silk_A2NLSF+0x564>
        p[ k - 2 ] -= silk_LSHIFT( p[ k ], 1 );
   16bd4:	f856 3b04 	ldr.w	r3, [r6], #4
   16bd8:	6872      	ldr	r2, [r6, #4]
   16bda:	eba3 0342 	sub.w	r3, r3, r2, lsl #1
    for( k = 2; k <= dd; k++ ) {
   16bde:	1c62      	adds	r2, r4, #1
   16be0:	4590      	cmp	r8, r2
   16be2:	f105 0501 	add.w	r5, r5, #1
        p[ k - 2 ] -= silk_LSHIFT( p[ k ], 1 );
   16be6:	f846 3c04 	str.w	r3, [r6, #-4]
    for( k = 2; k <= dd; k++ ) {
   16bea:	f340 812e 	ble.w	16e4a <silk_A2NLSF+0x7ea>
   16bee:	4575      	cmp	r5, lr
   16bf0:	4614      	mov	r4, r2
   16bf2:	dbc7      	blt.n	16b84 <silk_A2NLSF+0x524>
   16bf4:	4643      	mov	r3, r8
   16bf6:	e7e0      	b.n	16bba <silk_A2NLSF+0x55a>
        if( ( ylo <= 0 && yhi >= thr ) || ( ylo >= 0 && yhi <= -thr ) ) {
   16bf8:	9b05      	ldr	r3, [sp, #20]
   16bfa:	42a3      	cmp	r3, r4
   16bfc:	dd3b      	ble.n	16c76 <silk_A2NLSF+0x616>
   16bfe:	f1bc 0f00 	cmp.w	ip, #0
   16c02:	f43f af4e 	beq.w	16aa2 <silk_A2NLSF+0x442>
            k++;
   16c06:	9b03      	ldr	r3, [sp, #12]
   16c08:	3301      	adds	r3, #1
            if( k > LSF_COS_TAB_SZ_FIX ) {
   16c0a:	2b80      	cmp	r3, #128	; 0x80
            k++;
   16c0c:	9303      	str	r3, [sp, #12]
            if( k > LSF_COS_TAB_SZ_FIX ) {
   16c0e:	f73f af53 	bgt.w	16ab8 <silk_A2NLSF+0x458>
   16c12:	461a      	mov	r2, r3
   16c14:	9b10      	ldr	r3, [sp, #64]	; 0x40
   16c16:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
   16c1a:	9306      	str	r3, [sp, #24]
   16c1c:	011b      	lsls	r3, r3, #4
   16c1e:	9307      	str	r3, [sp, #28]
            thr = 0;
   16c20:	2300      	movs	r3, #0
            xlo = xhi;
   16c22:	9a01      	ldr	r2, [sp, #4]
            thr = 0;
   16c24:	9305      	str	r3, [sp, #20]
    if ( opus_likely( 8 == dd ) )
   16c26:	f1b8 0f08 	cmp.w	r8, #8
        xhi = silk_LSFCosTab_FIX_Q12[ k ]; /* Q12 */
   16c2a:	9b06      	ldr	r3, [sp, #24]
            xlo = xhi;
   16c2c:	9202      	str	r2, [sp, #8]
            if( k > LSF_COS_TAB_SZ_FIX ) {
   16c2e:	46a4      	mov	ip, r4
        xhi = silk_LSFCosTab_FIX_Q12[ k ]; /* Q12 */
   16c30:	9301      	str	r3, [sp, #4]
    if ( opus_likely( 8 == dd ) )
   16c32:	f43f aeca 	beq.w	169ca <silk_A2NLSF+0x36a>
        for( n = dd - 1; n >= 0; n-- ) {
   16c36:	980d      	ldr	r0, [sp, #52]	; 0x34
   16c38:	2800      	cmp	r0, #0
   16c3a:	f2c0 83b7 	blt.w	173ac <silk_A2NLSF+0xd4c>
            y32 = silk_SMLAWW( p[ n ], y32, x_Q16 );    /* Q16 */
   16c3e:	9b07      	ldr	r3, [sp, #28]
   16c40:	ea4f 3ee3 	mov.w	lr, r3, asr #15
   16c44:	b21e      	sxth	r6, r3
   16c46:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   16c48:	f10e 0e01 	add.w	lr, lr, #1
   16c4c:	ea4f 0e6e 	mov.w	lr, lr, asr #1
   16c50:	18fd      	adds	r5, r7, r3
    y32 = p[ dd ];                                  /* Q16 */
   16c52:	465c      	mov	r4, fp
            y32 = silk_SMLAWW( p[ n ], y32, x_Q16 );    /* Q16 */
   16c54:	b2a2      	uxth	r2, r4
   16c56:	1423      	asrs	r3, r4, #16
   16c58:	f855 1d04 	ldr.w	r1, [r5, #-4]!
   16c5c:	fb06 f202 	mul.w	r2, r6, r2
   16c60:	fb06 f303 	mul.w	r3, r6, r3
   16c64:	eb03 4322 	add.w	r3, r3, r2, asr #16
        for( n = dd - 1; n >= 0; n-- ) {
   16c68:	3801      	subs	r0, #1
            y32 = silk_SMLAWW( p[ n ], y32, x_Q16 );    /* Q16 */
   16c6a:	440b      	add	r3, r1
        for( n = dd - 1; n >= 0; n-- ) {
   16c6c:	1c41      	adds	r1, r0, #1
            y32 = silk_SMLAWW( p[ n ], y32, x_Q16 );    /* Q16 */
   16c6e:	fb04 340e 	mla	r4, r4, lr, r3
        for( n = dd - 1; n >= 0; n-- ) {
   16c72:	d1ef      	bne.n	16c54 <silk_A2NLSF+0x5f4>
   16c74:	e711      	b.n	16a9a <silk_A2NLSF+0x43a>
            if( yhi == 0 ) {
   16c76:	fab4 f384 	clz	r3, r4
   16c7a:	095b      	lsrs	r3, r3, #5
   16c7c:	9305      	str	r3, [sp, #20]
        y32 = silk_SMLAWW( p[ 7 ], y32, x_Q16 );
   16c7e:	ea4f 432b 	mov.w	r3, fp, asr #16
   16c82:	9308      	str	r3, [sp, #32]
   16c84:	9b0e      	ldr	r3, [sp, #56]	; 0x38
                    ffrac = silk_ADD_RSHIFT( ffrac, 128, m );
   16c86:	940c      	str	r4, [sp, #48]	; 0x30
   16c88:	18fb      	adds	r3, r7, r3
   16c8a:	9319      	str	r3, [sp, #100]	; 0x64
            ffrac = -256;
   16c8c:	f06f 03ff 	mvn.w	r3, #255	; 0xff
   16c90:	9304      	str	r3, [sp, #16]
        y32 = silk_SMLAWW( p[ 7 ], y32, x_Q16 );
   16c92:	fa1f f38b 	uxth.w	r3, fp
            for( m = 0; m < BIN_DIV_STEPS_A2NLSF_FIX; m++ ) {
   16c96:	2600      	movs	r6, #0
        y32 = silk_SMLAWW( p[ 7 ], y32, x_Q16 );
   16c98:	9309      	str	r3, [sp, #36]	; 0x24
                    ffrac = silk_ADD_RSHIFT( ffrac, 128, m );
   16c9a:	465d      	mov	r5, fp
                xmid = silk_RSHIFT_ROUND( xlo + xhi, 1 );
   16c9c:	e9dd 2301 	ldrd	r2, r3, [sp, #4]
   16ca0:	4413      	add	r3, r2
   16ca2:	f003 0101 	and.w	r1, r3, #1
   16ca6:	eb01 0163 	add.w	r1, r1, r3, asr #1
    if ( opus_likely( 8 == dd ) )
   16caa:	f1b8 0f08 	cmp.w	r8, #8
    x_Q16 = silk_LSHIFT( x, 4 );
   16cae:	ea4f 1201 	mov.w	r2, r1, lsl #4
    if ( opus_likely( 8 == dd ) )
   16cb2:	f040 8268 	bne.w	17186 <silk_A2NLSF+0xb26>
        y32 = silk_SMLAWW( p[ 7 ], y32, x_Q16 );
   16cb6:	9809      	ldr	r0, [sp, #36]	; 0x24
   16cb8:	b213      	sxth	r3, r2
   16cba:	fb03 f900 	mul.w	r9, r3, r0
   16cbe:	9808      	ldr	r0, [sp, #32]
   16cc0:	fb03 fe00 	mul.w	lr, r3, r0
        y32 = silk_SMLAWW( p[ 6 ], y32, x_Q16 );
   16cc4:	e9d7 0406 	ldrd	r0, r4, [r7, #24]
        y32 = silk_SMLAWW( p[ 7 ], y32, x_Q16 );
   16cc8:	13d2      	asrs	r2, r2, #15
   16cca:	eb0e 4e29 	add.w	lr, lr, r9, asr #16
   16cce:	3201      	adds	r2, #1
   16cd0:	1052      	asrs	r2, r2, #1
   16cd2:	4474      	add	r4, lr
   16cd4:	fb05 4402 	mla	r4, r5, r2, r4
        y32 = silk_SMLAWW( p[ 6 ], y32, x_Q16 );
   16cd8:	fa1f fb84 	uxth.w	fp, r4
   16cdc:	ea4f 4924 	mov.w	r9, r4, asr #16
   16ce0:	fb03 f909 	mul.w	r9, r3, r9
   16ce4:	fb03 fb0b 	mul.w	fp, r3, fp
   16ce8:	eb09 4b2b 	add.w	fp, r9, fp, asr #16
   16cec:	4483      	add	fp, r0
   16cee:	fb04 be02 	mla	lr, r4, r2, fp
        y32 = silk_SMLAWW( p[ 5 ], y32, x_Q16 );
   16cf2:	fa1f fa8e 	uxth.w	sl, lr
   16cf6:	ea4f 442e 	mov.w	r4, lr, asr #16
   16cfa:	fb03 f404 	mul.w	r4, r3, r4
   16cfe:	fb03 fa0a 	mul.w	sl, r3, sl
   16d02:	6978      	ldr	r0, [r7, #20]
   16d04:	eb04 4a2a 	add.w	sl, r4, sl, asr #16
   16d08:	4482      	add	sl, r0
   16d0a:	fb0e ab02 	mla	fp, lr, r2, sl
        y32 = silk_SMLAWW( p[ 4 ], y32, x_Q16 );
   16d0e:	fa1f f98b 	uxth.w	r9, fp
   16d12:	ea4f 442b 	mov.w	r4, fp, asr #16
   16d16:	fb03 f404 	mul.w	r4, r3, r4
   16d1a:	fb03 f909 	mul.w	r9, r3, r9
   16d1e:	6938      	ldr	r0, [r7, #16]
   16d20:	eb04 4929 	add.w	r9, r4, r9, asr #16
   16d24:	4481      	add	r9, r0
   16d26:	fb0b 9a02 	mla	sl, fp, r2, r9
        y32 = silk_SMLAWW( p[ 3 ], y32, x_Q16 );
   16d2a:	fa1f fe8a 	uxth.w	lr, sl
   16d2e:	ea4f 442a 	mov.w	r4, sl, asr #16
   16d32:	fb03 f404 	mul.w	r4, r3, r4
   16d36:	fb03 fe0e 	mul.w	lr, r3, lr
   16d3a:	68f8      	ldr	r0, [r7, #12]
   16d3c:	eb04 4e2e 	add.w	lr, r4, lr, asr #16
   16d40:	4486      	add	lr, r0
   16d42:	fb0a e902 	mla	r9, sl, r2, lr
        y32 = silk_SMLAWW( p[ 2 ], y32, x_Q16 );
   16d46:	fa1f fe89 	uxth.w	lr, r9
   16d4a:	ea4f 4429 	mov.w	r4, r9, asr #16
   16d4e:	fb03 f404 	mul.w	r4, r3, r4
   16d52:	fb03 fe0e 	mul.w	lr, r3, lr
   16d56:	68b8      	ldr	r0, [r7, #8]
   16d58:	eb04 4e2e 	add.w	lr, r4, lr, asr #16
   16d5c:	4486      	add	lr, r0
   16d5e:	fb09 ee02 	mla	lr, r9, r2, lr
        y32 = silk_SMLAWW( p[ 1 ], y32, x_Q16 );
   16d62:	fa1f f98e 	uxth.w	r9, lr
   16d66:	ea4f 442e 	mov.w	r4, lr, asr #16
   16d6a:	fb03 f909 	mul.w	r9, r3, r9
   16d6e:	fb03 f404 	mul.w	r4, r3, r4
   16d72:	6878      	ldr	r0, [r7, #4]
   16d74:	eb04 4429 	add.w	r4, r4, r9, asr #16
   16d78:	4404      	add	r4, r0
   16d7a:	fb0e 4e02 	mla	lr, lr, r2, r4
        y32 = silk_SMLAWW( p[ 0 ], y32, x_Q16 );
   16d7e:	ea4f 442e 	mov.w	r4, lr, asr #16
   16d82:	fa1f f08e 	uxth.w	r0, lr
   16d86:	fb03 f000 	mul.w	r0, r3, r0
   16d8a:	fb03 f304 	mul.w	r3, r3, r4
   16d8e:	683c      	ldr	r4, [r7, #0]
   16d90:	eb03 4320 	add.w	r3, r3, r0, asr #16
   16d94:	4423      	add	r3, r4
   16d96:	fb0e 3202 	mla	r2, lr, r2, r3
                if( ( ylo <= 0 && ymid >= 0 ) || ( ylo >= 0 && ymid <= 0 ) ) {
   16d9a:	f1bc 0f00 	cmp.w	ip, #0
   16d9e:	dd4b      	ble.n	16e38 <silk_A2NLSF+0x7d8>
   16da0:	2a00      	cmp	r2, #0
   16da2:	dd4b      	ble.n	16e3c <silk_A2NLSF+0x7dc>
                    ffrac = silk_ADD_RSHIFT( ffrac, 128, m );
   16da4:	2380      	movs	r3, #128	; 0x80
   16da6:	4694      	mov	ip, r2
   16da8:	9a04      	ldr	r2, [sp, #16]
                    xlo = xmid;
   16daa:	9102      	str	r1, [sp, #8]
                    ffrac = silk_ADD_RSHIFT( ffrac, 128, m );
   16dac:	4133      	asrs	r3, r6
   16dae:	441a      	add	r2, r3
   16db0:	9204      	str	r2, [sp, #16]
            for( m = 0; m < BIN_DIV_STEPS_A2NLSF_FIX; m++ ) {
   16db2:	3601      	adds	r6, #1
   16db4:	2e03      	cmp	r6, #3
   16db6:	f47f af71 	bne.w	16c9c <silk_A2NLSF+0x63c>
            if( silk_abs( ylo ) < 65536 ) {
   16dba:	f50c 437f 	add.w	r3, ip, #65280	; 0xff00
   16dbe:	4ab4      	ldr	r2, [pc, #720]	; (17090 <silk_A2NLSF+0xa30>)
   16dc0:	9c0c      	ldr	r4, [sp, #48]	; 0x30
   16dc2:	33ff      	adds	r3, #255	; 0xff
   16dc4:	4293      	cmp	r3, r2
   16dc6:	ebac 0404 	sub.w	r4, ip, r4
   16dca:	f200 815a 	bhi.w	17082 <silk_A2NLSF+0xa22>
                if( den != 0 ) {
   16dce:	b13c      	cbz	r4, 16de0 <silk_A2NLSF+0x780>
                    ffrac += silk_DIV32( nom, den );
   16dd0:	9a04      	ldr	r2, [sp, #16]
                nom = silk_LSHIFT( ylo, 8 - BIN_DIV_STEPS_A2NLSF_FIX ) + silk_RSHIFT( den, 1 );
   16dd2:	1063      	asrs	r3, r4, #1
   16dd4:	eb03 134c 	add.w	r3, r3, ip, lsl #5
                    ffrac += silk_DIV32( nom, den );
   16dd8:	fb93 f3f4 	sdiv	r3, r3, r4
   16ddc:	441a      	add	r2, r3
   16dde:	9204      	str	r2, [sp, #16]
            NLSF[ root_ix ] = (opus_int16)silk_min_32( silk_LSHIFT( (opus_int32)k, 8 ) + ffrac, silk_int16_MAX );
   16de0:	9b04      	ldr	r3, [sp, #16]
   16de2:	9803      	ldr	r0, [sp, #12]
   16de4:	461a      	mov	r2, r3
   16de6:	eb02 2300 	add.w	r3, r2, r0, lsl #8
    return (((a) < (b)) ? (a) : (b));
   16dea:	f647 72ff 	movw	r2, #32767	; 0x7fff
   16dee:	4293      	cmp	r3, r2
   16df0:	bfa8      	it	ge
   16df2:	4613      	movge	r3, r2
   16df4:	9a15      	ldr	r2, [sp, #84]	; 0x54
   16df6:	4614      	mov	r4, r2
   16df8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   16dfa:	f824 3012 	strh.w	r3, [r4, r2, lsl #1]
            if( root_ix >= d ) {
   16dfe:	9b11      	ldr	r3, [sp, #68]	; 0x44
            root_ix++;        /* Next root */
   16e00:	3201      	adds	r2, #1
            if( root_ix >= d ) {
   16e02:	4619      	mov	r1, r3
   16e04:	4291      	cmp	r1, r2
            root_ix++;        /* Next root */
   16e06:	920b      	str	r2, [sp, #44]	; 0x2c
            if( root_ix >= d ) {
   16e08:	f340 81f9 	ble.w	171fe <silk_A2NLSF+0xb9e>
            p = PQ[ root_ix & 1 ];
   16e0c:	f002 0301 	and.w	r3, r2, #1
   16e10:	a93a      	add	r1, sp, #232	; 0xe8
   16e12:	eb01 0383 	add.w	r3, r1, r3, lsl #2
            ylo = silk_LSHIFT( 1 - ( root_ix & 2 ), 12 );
   16e16:	f002 0c02 	and.w	ip, r2, #2
            p = PQ[ root_ix & 1 ];
   16e1a:	f853 7c70 	ldr.w	r7, [r3, #-112]
   16e1e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
            xlo = silk_LSFCosTab_FIX_Q12[ k - 1 ]; /* Q12*/
   16e20:	1e43      	subs	r3, r0, #1
   16e22:	f857 b002 	ldr.w	fp, [r7, r2]
   16e26:	9a10      	ldr	r2, [sp, #64]	; 0x40
            ylo = silk_LSHIFT( 1 - ( root_ix & 2 ), 12 );
   16e28:	f1cc 0c01 	rsb	ip, ip, #1
            xlo = silk_LSFCosTab_FIX_Q12[ k - 1 ]; /* Q12*/
   16e2c:	f932 3013 	ldrsh.w	r3, [r2, r3, lsl #1]
   16e30:	9302      	str	r3, [sp, #8]
            ylo = silk_LSHIFT( 1 - ( root_ix & 2 ), 12 );
   16e32:	ea4f 3c0c 	mov.w	ip, ip, lsl #12
   16e36:	e5c2      	b.n	169be <silk_A2NLSF+0x35e>
                if( ( ylo <= 0 && ymid >= 0 ) || ( ylo >= 0 && ymid <= 0 ) ) {
   16e38:	2a00      	cmp	r2, #0
   16e3a:	db02      	blt.n	16e42 <silk_A2NLSF+0x7e2>
   16e3c:	920c      	str	r2, [sp, #48]	; 0x30
                    xhi = xmid;
   16e3e:	9101      	str	r1, [sp, #4]
   16e40:	e7b7      	b.n	16db2 <silk_A2NLSF+0x752>
                if( ( ylo <= 0 && ymid >= 0 ) || ( ylo >= 0 && ymid <= 0 ) ) {
   16e42:	f1bc 0f00 	cmp.w	ip, #0
   16e46:	d1ad      	bne.n	16da4 <silk_A2NLSF+0x744>
   16e48:	e7f8      	b.n	16e3c <silk_A2NLSF+0x7dc>
   16e4a:	db2a      	blt.n	16ea2 <silk_A2NLSF+0x842>
   16e4c:	3402      	adds	r4, #2
   16e4e:	ab2d      	add	r3, sp, #180	; 0xb4
   16e50:	45a0      	cmp	r8, r4
   16e52:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   16e56:	dd15      	ble.n	16e84 <silk_A2NLSF+0x824>
   16e58:	e953 0102 	ldrd	r0, r1, [r3, #-8]
        p[ k - 2 ] -= silk_LSHIFT( p[ k ], 1 );
   16e5c:	e9d3 6500 	ldrd	r6, r5, [r3]
   16e60:	4614      	mov	r4, r2
   16e62:	3403      	adds	r4, #3
   16e64:	eba0 0046 	sub.w	r0, r0, r6, lsl #1
   16e68:	eba1 0145 	sub.w	r1, r1, r5, lsl #1
   16e6c:	45a0      	cmp	r8, r4
   16e6e:	f843 0c08 	str.w	r0, [r3, #-8]
   16e72:	f843 1c04 	str.w	r1, [r3, #-4]
   16e76:	4630      	mov	r0, r6
   16e78:	4629      	mov	r1, r5
   16e7a:	f103 0308 	add.w	r3, r3, #8
   16e7e:	f102 0202 	add.w	r2, r2, #2
   16e82:	dceb      	bgt.n	16e5c <silk_A2NLSF+0x7fc>
   16e84:	f102 4080 	add.w	r0, r2, #1073741824	; 0x40000000
   16e88:	3803      	subs	r0, #3
   16e8a:	ab2d      	add	r3, sp, #180	; 0xb4
   16e8c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   16e90:	3004      	adds	r0, #4
   16e92:	6803      	ldr	r3, [r0, #0]
   16e94:	6881      	ldr	r1, [r0, #8]
    for( k = 2; k <= dd; k++ ) {
   16e96:	3201      	adds	r2, #1
        p[ k - 2 ] -= silk_LSHIFT( p[ k ], 1 );
   16e98:	eba3 0341 	sub.w	r3, r3, r1, lsl #1
    for( k = 2; k <= dd; k++ ) {
   16e9c:	4590      	cmp	r8, r2
        p[ k - 2 ] -= silk_LSHIFT( p[ k ], 1 );
   16e9e:	6003      	str	r3, [r0, #0]
    for( k = 2; k <= dd; k++ ) {
   16ea0:	daf6      	bge.n	16e90 <silk_A2NLSF+0x830>
    y32 = p[ dd ];                                  /* Q16 */
   16ea2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    if ( opus_likely( 8 == dd ) )
   16ea4:	f1b8 0f08 	cmp.w	r8, #8
    y32 = p[ dd ];                                  /* Q16 */
   16ea8:	f8d3 b000 	ldr.w	fp, [r3]
    if ( opus_likely( 8 == dd ) )
   16eac:	f040 81ad 	bne.w	1720a <silk_A2NLSF+0xbaa>
        y32 = silk_SMLAWW( p[ 7 ], y32, x_Q16 );
   16eb0:	f9bd 506c 	ldrsh.w	r5, [sp, #108]	; 0x6c
   16eb4:	9813      	ldr	r0, [sp, #76]	; 0x4c
        y32 = silk_SMLAWW( p[ 6 ], y32, x_Q16 );
   16eb6:	e9dd 3226 	ldrd	r3, r2, [sp, #152]	; 0x98
        y32 = silk_SMLAWW( p[ 7 ], y32, x_Q16 );
   16eba:	fa1f f18b 	uxth.w	r1, fp
   16ebe:	ea4f 4c2b 	mov.w	ip, fp, asr #16
   16ec2:	fb05 f101 	mul.w	r1, r5, r1
   16ec6:	fb05 fc0c 	mul.w	ip, r5, ip
   16eca:	eb0c 4c21 	add.w	ip, ip, r1, asr #16
   16ece:	4494      	add	ip, r2
   16ed0:	fb00 cc0b 	mla	ip, r0, fp, ip
        y32 = silk_SMLAWW( p[ 6 ], y32, x_Q16 );
   16ed4:	fa1f f18c 	uxth.w	r1, ip
   16ed8:	ea4f 422c 	mov.w	r2, ip, asr #16
   16edc:	fb05 f101 	mul.w	r1, r5, r1
   16ee0:	fb05 f202 	mul.w	r2, r5, r2
   16ee4:	eb02 4221 	add.w	r2, r2, r1, asr #16
   16ee8:	4413      	add	r3, r2
   16eea:	fb00 3c0c 	mla	ip, r0, ip, r3
        y32 = silk_SMLAWW( p[ 5 ], y32, x_Q16 );
   16eee:	fa1f f18c 	uxth.w	r1, ip
   16ef2:	ea4f 422c 	mov.w	r2, ip, asr #16
   16ef6:	fb05 f101 	mul.w	r1, r5, r1
   16efa:	fb05 f202 	mul.w	r2, r5, r2
   16efe:	9b25      	ldr	r3, [sp, #148]	; 0x94
   16f00:	eb02 4221 	add.w	r2, r2, r1, asr #16
   16f04:	4413      	add	r3, r2
   16f06:	fb00 3c0c 	mla	ip, r0, ip, r3
        y32 = silk_SMLAWW( p[ 4 ], y32, x_Q16 );
   16f0a:	fa1f f18c 	uxth.w	r1, ip
   16f0e:	ea4f 422c 	mov.w	r2, ip, asr #16
   16f12:	fb05 f101 	mul.w	r1, r5, r1
   16f16:	fb05 f202 	mul.w	r2, r5, r2
   16f1a:	9b24      	ldr	r3, [sp, #144]	; 0x90
   16f1c:	eb02 4221 	add.w	r2, r2, r1, asr #16
   16f20:	4413      	add	r3, r2
   16f22:	fb00 3c0c 	mla	ip, r0, ip, r3
        y32 = silk_SMLAWW( p[ 3 ], y32, x_Q16 );
   16f26:	fa1f f18c 	uxth.w	r1, ip
   16f2a:	ea4f 422c 	mov.w	r2, ip, asr #16
   16f2e:	fb05 f101 	mul.w	r1, r5, r1
   16f32:	fb05 f202 	mul.w	r2, r5, r2
   16f36:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   16f38:	eb02 4221 	add.w	r2, r2, r1, asr #16
   16f3c:	4413      	add	r3, r2
   16f3e:	fb00 3c0c 	mla	ip, r0, ip, r3
        y32 = silk_SMLAWW( p[ 2 ], y32, x_Q16 );
   16f42:	fa1f f18c 	uxth.w	r1, ip
   16f46:	ea4f 422c 	mov.w	r2, ip, asr #16
   16f4a:	fb05 f101 	mul.w	r1, r5, r1
   16f4e:	fb05 f202 	mul.w	r2, r5, r2
   16f52:	9b22      	ldr	r3, [sp, #136]	; 0x88
   16f54:	eb02 4221 	add.w	r2, r2, r1, asr #16
   16f58:	4413      	add	r3, r2
   16f5a:	fb00 3c0c 	mla	ip, r0, ip, r3
        y32 = silk_SMLAWW( p[ 1 ], y32, x_Q16 );
   16f5e:	fa1f f18c 	uxth.w	r1, ip
   16f62:	ea4f 422c 	mov.w	r2, ip, asr #16
   16f66:	fb05 f101 	mul.w	r1, r5, r1
   16f6a:	fb05 f202 	mul.w	r2, r5, r2
   16f6e:	9b21      	ldr	r3, [sp, #132]	; 0x84
   16f70:	eb02 4221 	add.w	r2, r2, r1, asr #16
   16f74:	4413      	add	r3, r2
   16f76:	fb00 3c0c 	mla	ip, r0, ip, r3
        y32 = silk_SMLAWW( p[ 0 ], y32, x_Q16 );
   16f7a:	fa1f f18c 	uxth.w	r1, ip
   16f7e:	ea4f 422c 	mov.w	r2, ip, asr #16
   16f82:	fb05 f101 	mul.w	r1, r5, r1
   16f86:	fb05 f202 	mul.w	r2, r5, r2
   16f8a:	9b20      	ldr	r3, [sp, #128]	; 0x80
   16f8c:	eb02 4221 	add.w	r2, r2, r1, asr #16
   16f90:	4413      	add	r3, r2
   16f92:	fb00 3c0c 	mla	ip, r0, ip, r3
                if( ylo < 0 ) {
   16f96:	f1bc 0f00 	cmp.w	ip, #0
   16f9a:	db7b      	blt.n	17094 <silk_A2NLSF+0xa34>
            thr = 0;
   16f9c:	2300      	movs	r3, #0
   16f9e:	9305      	str	r3, [sp, #20]
                    root_ix = 0;                  /* Index of current root */
   16fa0:	930b      	str	r3, [sp, #44]	; 0x2c
                if( ylo < 0 ) {
   16fa2:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   16fa4:	9306      	str	r3, [sp, #24]
   16fa6:	9a18      	ldr	r2, [sp, #96]	; 0x60
   16fa8:	9202      	str	r2, [sp, #8]
   16faa:	011b      	lsls	r3, r3, #4
                k = 1;                            /* Reset loop counter */
   16fac:	2201      	movs	r2, #1
                p = P;                            /* Pointer to polynomial */
   16fae:	af20      	add	r7, sp, #128	; 0x80
                k = 1;                            /* Reset loop counter */
   16fb0:	9203      	str	r2, [sp, #12]
   16fb2:	9307      	str	r3, [sp, #28]
   16fb4:	e503      	b.n	169be <silk_A2NLSF+0x35e>
   16fb6:	f8dd e034 	ldr.w	lr, [sp, #52]	; 0x34
   16fba:	9f12      	ldr	r7, [sp, #72]	; 0x48
    for( k = 2; k <= dd; k++ ) {
   16fbc:	2503      	movs	r5, #3
   16fbe:	4575      	cmp	r5, lr
   16fc0:	ae20      	add	r6, sp, #128	; 0x80
   16fc2:	f04f 0402 	mov.w	r4, #2
   16fc6:	f06f 4c40 	mvn.w	ip, #3221225472	; 0xc0000000
   16fca:	da36      	bge.n	1703a <silk_A2NLSF+0x9da>
   16fcc:	45a0      	cmp	r8, r4
   16fce:	dd34      	ble.n	1703a <silk_A2NLSF+0x9da>
   16fd0:	e957 9a01 	ldrd	r9, sl, [r7, #-4]
    for( k = 0; k < dd; k++ ) {
   16fd4:	463a      	mov	r2, r7
   16fd6:	4648      	mov	r0, r9
   16fd8:	4643      	mov	r3, r8
   16fda:	46a1      	mov	r9, r4
   16fdc:	46b3      	mov	fp, r6
   16fde:	4654      	mov	r4, sl
            p[ n - 2 ] -= p[ n ];
   16fe0:	f852 1c08 	ldr.w	r1, [r2, #-8]
   16fe4:	f852 6c0c 	ldr.w	r6, [r2, #-12]
   16fe8:	1b0c      	subs	r4, r1, r4
   16fea:	1ed9      	subs	r1, r3, #3
   16fec:	1a30      	subs	r0, r6, r0
   16fee:	428d      	cmp	r5, r1
   16ff0:	e942 0403 	strd	r0, r4, [r2, #-12]
   16ff4:	f1a3 0302 	sub.w	r3, r3, #2
   16ff8:	f1a2 0208 	sub.w	r2, r2, #8
   16ffc:	dbf0      	blt.n	16fe0 <silk_A2NLSF+0x980>
   16ffe:	464c      	mov	r4, r9
   17000:	465e      	mov	r6, fp
   17002:	eb03 000c 	add.w	r0, r3, ip
   17006:	aa20      	add	r2, sp, #128	; 0x80
   17008:	eb02 0080 	add.w	r0, r2, r0, lsl #2
   1700c:	f850 2d04 	ldr.w	r2, [r0, #-4]!
   17010:	6881      	ldr	r1, [r0, #8]
        for( n = dd; n > k; n-- ) {
   17012:	3b01      	subs	r3, #1
            p[ n - 2 ] -= p[ n ];
   17014:	1a52      	subs	r2, r2, r1
        for( n = dd; n > k; n-- ) {
   17016:	429c      	cmp	r4, r3
            p[ n - 2 ] -= p[ n ];
   17018:	6002      	str	r2, [r0, #0]
        for( n = dd; n > k; n-- ) {
   1701a:	dbf7      	blt.n	1700c <silk_A2NLSF+0x9ac>
        p[ k - 2 ] -= silk_LSHIFT( p[ k ], 1 );
   1701c:	f856 3b04 	ldr.w	r3, [r6], #4
   17020:	6872      	ldr	r2, [r6, #4]
   17022:	eba3 0342 	sub.w	r3, r3, r2, lsl #1
    for( k = 2; k <= dd; k++ ) {
   17026:	1c62      	adds	r2, r4, #1
   17028:	4590      	cmp	r8, r2
   1702a:	f105 0501 	add.w	r5, r5, #1
        p[ k - 2 ] -= silk_LSHIFT( p[ k ], 1 );
   1702e:	f846 3c04 	str.w	r3, [r6, #-4]
    for( k = 2; k <= dd; k++ ) {
   17032:	dd04      	ble.n	1703e <silk_A2NLSF+0x9de>
   17034:	4575      	cmp	r5, lr
   17036:	4614      	mov	r4, r2
   17038:	dbc8      	blt.n	16fcc <silk_A2NLSF+0x96c>
    for( k = 0; k < dd; k++ ) {
   1703a:	4643      	mov	r3, r8
   1703c:	e7e1      	b.n	17002 <silk_A2NLSF+0x9a2>
   1703e:	f6ff ad92 	blt.w	16b66 <silk_A2NLSF+0x506>
   17042:	3402      	adds	r4, #2
   17044:	ab20      	add	r3, sp, #128	; 0x80
   17046:	45a0      	cmp	r8, r4
   17048:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   1704c:	f77f ad78 	ble.w	16b40 <silk_A2NLSF+0x4e0>
   17050:	e953 0102 	ldrd	r0, r1, [r3, #-8]
        p[ k - 2 ] -= silk_LSHIFT( p[ k ], 1 );
   17054:	e9d3 6500 	ldrd	r6, r5, [r3]
   17058:	4614      	mov	r4, r2
   1705a:	3403      	adds	r4, #3
   1705c:	eba0 0046 	sub.w	r0, r0, r6, lsl #1
   17060:	eba1 0145 	sub.w	r1, r1, r5, lsl #1
   17064:	45a0      	cmp	r8, r4
   17066:	f843 0c08 	str.w	r0, [r3, #-8]
   1706a:	f843 1c04 	str.w	r1, [r3, #-4]
   1706e:	4630      	mov	r0, r6
   17070:	4629      	mov	r1, r5
   17072:	f103 0308 	add.w	r3, r3, #8
   17076:	f102 0202 	add.w	r2, r2, #2
   1707a:	dceb      	bgt.n	17054 <silk_A2NLSF+0x9f4>
   1707c:	e560      	b.n	16b40 <silk_A2NLSF+0x4e0>
    for( k = 2; k <= dd; k++ ) {
   1707e:	2202      	movs	r2, #2
   17080:	e700      	b.n	16e84 <silk_A2NLSF+0x824>
                ffrac += silk_DIV32( ylo, silk_RSHIFT( ylo - yhi, 8 - BIN_DIV_STEPS_A2NLSF_FIX ) );
   17082:	9b04      	ldr	r3, [sp, #16]
   17084:	1164      	asrs	r4, r4, #5
   17086:	fb9c f4f4 	sdiv	r4, ip, r4
   1708a:	4423      	add	r3, r4
   1708c:	9304      	str	r3, [sp, #16]
   1708e:	e6a7      	b.n	16de0 <silk_A2NLSF+0x780>
   17090:	0001fffe 	.word	0x0001fffe
    y32 = p[ dd ];                                  /* Q16 */
   17094:	9b16      	ldr	r3, [sp, #88]	; 0x58
                    NLSF[ 0 ] = 0;
   17096:	9e15      	ldr	r6, [sp, #84]	; 0x54
    y32 = p[ dd ];                                  /* Q16 */
   17098:	f8d3 b000 	ldr.w	fp, [r3]
        y32 = silk_SMLAWW( p[ 3 ], y32, x_Q16 );
   1709c:	9b30      	ldr	r3, [sp, #192]	; 0xc0
                    NLSF[ 0 ] = 0;
   1709e:	f04f 0700 	mov.w	r7, #0
        y32 = silk_SMLAWW( p[ 6 ], y32, x_Q16 );
   170a2:	e9dd 0433 	ldrd	r0, r4, [sp, #204]	; 0xcc
                    NLSF[ 0 ] = 0;
   170a6:	8037      	strh	r7, [r6, #0]
        y32 = silk_SMLAWW( p[ 7 ], y32, x_Q16 );
   170a8:	fa1f f78b 	uxth.w	r7, fp
   170ac:	ea4f 462b 	mov.w	r6, fp, asr #16
   170b0:	fb05 f707 	mul.w	r7, r5, r7
   170b4:	fb05 f606 	mul.w	r6, r5, r6
   170b8:	eb06 4627 	add.w	r6, r6, r7, asr #16
   170bc:	4426      	add	r6, r4
   170be:	9c13      	ldr	r4, [sp, #76]	; 0x4c
   170c0:	fb04 660b 	mla	r6, r4, fp, r6
        y32 = silk_SMLAWW( p[ 6 ], y32, x_Q16 );
   170c4:	b2b7      	uxth	r7, r6
   170c6:	1434      	asrs	r4, r6, #16
   170c8:	fb05 f707 	mul.w	r7, r5, r7
   170cc:	fb05 f404 	mul.w	r4, r5, r4
   170d0:	eb04 4427 	add.w	r4, r4, r7, asr #16
   170d4:	9f13      	ldr	r7, [sp, #76]	; 0x4c
   170d6:	4404      	add	r4, r0
   170d8:	fb07 4606 	mla	r6, r7, r6, r4
        y32 = silk_SMLAWW( p[ 4 ], y32, x_Q16 );
   170dc:	e9dd 2131 	ldrd	r2, r1, [sp, #196]	; 0xc4
        y32 = silk_SMLAWW( p[ 5 ], y32, x_Q16 );
   170e0:	b2b4      	uxth	r4, r6
   170e2:	1430      	asrs	r0, r6, #16
   170e4:	fb05 f404 	mul.w	r4, r5, r4
   170e8:	fb05 f000 	mul.w	r0, r5, r0
   170ec:	eb00 4024 	add.w	r0, r0, r4, asr #16
   170f0:	4408      	add	r0, r1
   170f2:	fb07 0006 	mla	r0, r7, r6, r0
        y32 = silk_SMLAWW( p[ 4 ], y32, x_Q16 );
   170f6:	b284      	uxth	r4, r0
   170f8:	1401      	asrs	r1, r0, #16
   170fa:	fb05 f404 	mul.w	r4, r5, r4
   170fe:	fb05 f101 	mul.w	r1, r5, r1
   17102:	eb01 4124 	add.w	r1, r1, r4, asr #16
   17106:	440a      	add	r2, r1
   17108:	fb07 2000 	mla	r0, r7, r0, r2
        y32 = silk_SMLAWW( p[ 3 ], y32, x_Q16 );
   1710c:	b281      	uxth	r1, r0
   1710e:	1402      	asrs	r2, r0, #16
   17110:	fb05 f101 	mul.w	r1, r5, r1
   17114:	fb05 f202 	mul.w	r2, r5, r2
   17118:	eb02 4221 	add.w	r2, r2, r1, asr #16
   1711c:	4413      	add	r3, r2
   1711e:	fb07 3000 	mla	r0, r7, r0, r3
        y32 = silk_SMLAWW( p[ 2 ], y32, x_Q16 );
   17122:	b286      	uxth	r6, r0
   17124:	1404      	asrs	r4, r0, #16
        y32 = silk_SMLAWW( p[ 1 ], y32, x_Q16 );
   17126:	e9dd 212e 	ldrd	r2, r1, [sp, #184]	; 0xb8
        y32 = silk_SMLAWW( p[ 2 ], y32, x_Q16 );
   1712a:	fb05 f606 	mul.w	r6, r5, r6
   1712e:	fb05 f404 	mul.w	r4, r5, r4
   17132:	eb04 4426 	add.w	r4, r4, r6, asr #16
   17136:	4421      	add	r1, r4
   17138:	fb07 1000 	mla	r0, r7, r0, r1
        y32 = silk_SMLAWW( p[ 1 ], y32, x_Q16 );
   1713c:	b284      	uxth	r4, r0
   1713e:	1401      	asrs	r1, r0, #16
   17140:	fb05 f404 	mul.w	r4, r5, r4
   17144:	fb05 f101 	mul.w	r1, r5, r1
   17148:	eb01 4124 	add.w	r1, r1, r4, asr #16
   1714c:	440a      	add	r2, r1
   1714e:	fb07 2200 	mla	r2, r7, r0, r2
        y32 = silk_SMLAWW( p[ 0 ], y32, x_Q16 );
   17152:	1411      	asrs	r1, r2, #16
   17154:	fa1f fc82 	uxth.w	ip, r2
   17158:	fb05 fc0c 	mul.w	ip, r5, ip
   1715c:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
   1715e:	fb05 f501 	mul.w	r5, r5, r1
   17162:	eb05 4c2c 	add.w	ip, r5, ip, asr #16
                    root_ix = 1;                  /* Index of current root */
   17166:	2101      	movs	r1, #1
        y32 = silk_SMLAWW( p[ 0 ], y32, x_Q16 );
   17168:	4463      	add	r3, ip
                    root_ix = 1;                  /* Index of current root */
   1716a:	910b      	str	r1, [sp, #44]	; 0x2c
        y32 = silk_SMLAWW( p[ 0 ], y32, x_Q16 );
   1716c:	fb07 3c02 	mla	ip, r7, r2, r3
                k = 1;                            /* Reset loop counter */
   17170:	9103      	str	r1, [sp, #12]
        y32 = silk_SMLAWW( p[ 0 ], y32, x_Q16 );
   17172:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   17174:	9a18      	ldr	r2, [sp, #96]	; 0x60
   17176:	9306      	str	r3, [sp, #24]
   17178:	9202      	str	r2, [sp, #8]
   1717a:	011b      	lsls	r3, r3, #4
            thr = 0;
   1717c:	2200      	movs	r2, #0
                    p = Q;                        /* Pointer to polynomial */
   1717e:	af2d      	add	r7, sp, #180	; 0xb4
            thr = 0;
   17180:	9205      	str	r2, [sp, #20]
   17182:	9307      	str	r3, [sp, #28]
   17184:	e41b      	b.n	169be <silk_A2NLSF+0x35e>
        for( n = dd - 1; n >= 0; n-- ) {
   17186:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   17188:	2b00      	cmp	r3, #0
   1718a:	f2c0 810d 	blt.w	173a8 <silk_A2NLSF+0xd48>
            y32 = silk_SMLAWW( p[ n ], y32, x_Q16 );    /* Q16 */
   1718e:	ea4f 3be2 	mov.w	fp, r2, asr #15
   17192:	f10b 0b01 	add.w	fp, fp, #1
   17196:	f8dd a064 	ldr.w	sl, [sp, #100]	; 0x64
   1719a:	fa0f fe82 	sxth.w	lr, r2
   1719e:	ea4f 0b6b 	mov.w	fp, fp, asr #1
    y32 = p[ dd ];                                  /* Q16 */
   171a2:	462a      	mov	r2, r5
            y32 = silk_SMLAWW( p[ n ], y32, x_Q16 );    /* Q16 */
   171a4:	4699      	mov	r9, r3
   171a6:	b294      	uxth	r4, r2
   171a8:	1413      	asrs	r3, r2, #16
   171aa:	fb0e f404 	mul.w	r4, lr, r4
   171ae:	fb0e f303 	mul.w	r3, lr, r3
   171b2:	f85a 0d04 	ldr.w	r0, [sl, #-4]!
   171b6:	eb03 4324 	add.w	r3, r3, r4, asr #16
        for( n = dd - 1; n >= 0; n-- ) {
   171ba:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
            y32 = silk_SMLAWW( p[ n ], y32, x_Q16 );    /* Q16 */
   171be:	4403      	add	r3, r0
        for( n = dd - 1; n >= 0; n-- ) {
   171c0:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
            y32 = silk_SMLAWW( p[ n ], y32, x_Q16 );    /* Q16 */
   171c4:	fb0b 3202 	mla	r2, fp, r2, r3
        for( n = dd - 1; n >= 0; n-- ) {
   171c8:	d1ed      	bne.n	171a6 <silk_A2NLSF+0xb46>
   171ca:	e5e6      	b.n	16d9a <silk_A2NLSF+0x73a>
                    NLSF[ 0 ] = (opus_int16)silk_DIV32_16( 1 << 15, d + 1 );
   171cc:	9a11      	ldr	r2, [sp, #68]	; 0x44
   171ce:	9c15      	ldr	r4, [sp, #84]	; 0x54
   171d0:	1c51      	adds	r1, r2, #1
   171d2:	f44f 4300 	mov.w	r3, #32768	; 0x8000
                    for( k = 1; k < d; k++ ) {
   171d6:	2a01      	cmp	r2, #1
                    NLSF[ 0 ] = (opus_int16)silk_DIV32_16( 1 << 15, d + 1 );
   171d8:	fb93 f3f1 	sdiv	r3, r3, r1
   171dc:	b219      	sxth	r1, r3
   171de:	8021      	strh	r1, [r4, #0]
                    for( k = 1; k < d; k++ ) {
   171e0:	dd0d      	ble.n	171fe <silk_A2NLSF+0xb9e>
   171e2:	1ea0      	subs	r0, r4, #2
   171e4:	eb00 0042 	add.w	r0, r0, r2, lsl #1
   171e8:	460b      	mov	r3, r1
   171ea:	4622      	mov	r2, r4
   171ec:	e001      	b.n	171f2 <silk_A2NLSF+0xb92>
   171ee:	f9b4 1000 	ldrsh.w	r1, [r4]
                        NLSF[ k ] = (opus_int16)silk_ADD16( NLSF[ k-1 ], NLSF[ 0 ] );
   171f2:	440b      	add	r3, r1
   171f4:	b21b      	sxth	r3, r3
   171f6:	f822 3f02 	strh.w	r3, [r2, #2]!
                    for( k = 1; k < d; k++ ) {
   171fa:	4290      	cmp	r0, r2
   171fc:	d1f7      	bne.n	171ee <silk_A2NLSF+0xb8e>
            }
        }
    }
}
   171fe:	b03b      	add	sp, #236	; 0xec
   17200:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    y32 = p[ dd ];                                  /* Q16 */
   17204:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   17206:	f8d3 b000 	ldr.w	fp, [r3]
        for( n = dd - 1; n >= 0; n-- ) {
   1720a:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   1720c:	2c00      	cmp	r4, #0
   1720e:	f2c0 8122 	blt.w	17456 <silk_A2NLSF+0xdf6>
   17212:	f9bd 006c 	ldrsh.w	r0, [sp, #108]	; 0x6c
   17216:	9d12      	ldr	r5, [sp, #72]	; 0x48
   17218:	9e13      	ldr	r6, [sp, #76]	; 0x4c
   1721a:	46dc      	mov	ip, fp
            y32 = silk_SMLAWW( p[ n ], y32, x_Q16 );    /* Q16 */
   1721c:	fa1f f28c 	uxth.w	r2, ip
   17220:	ea4f 432c 	mov.w	r3, ip, asr #16
   17224:	fb00 f202 	mul.w	r2, r0, r2
   17228:	fb00 f303 	mul.w	r3, r0, r3
   1722c:	f855 1d04 	ldr.w	r1, [r5, #-4]!
   17230:	eb03 4322 	add.w	r3, r3, r2, asr #16
        for( n = dd - 1; n >= 0; n-- ) {
   17234:	3c01      	subs	r4, #1
            y32 = silk_SMLAWW( p[ n ], y32, x_Q16 );    /* Q16 */
   17236:	440b      	add	r3, r1
        for( n = dd - 1; n >= 0; n-- ) {
   17238:	1c62      	adds	r2, r4, #1
            y32 = silk_SMLAWW( p[ n ], y32, x_Q16 );    /* Q16 */
   1723a:	fb06 3c0c 	mla	ip, r6, ip, r3
        for( n = dd - 1; n >= 0; n-- ) {
   1723e:	d1ed      	bne.n	1721c <silk_A2NLSF+0xbbc>
                if( ylo < 0 ) {
   17240:	f1bc 0f00 	cmp.w	ip, #0
   17244:	f6bf aeaa 	bge.w	16f9c <silk_A2NLSF+0x93c>
    y32 = p[ dd ];                                  /* Q16 */
   17248:	9b16      	ldr	r3, [sp, #88]	; 0x58
   1724a:	9d14      	ldr	r5, [sp, #80]	; 0x50
   1724c:	f8d3 b000 	ldr.w	fp, [r3]
                    NLSF[ 0 ] = 0;
   17250:	9b15      	ldr	r3, [sp, #84]	; 0x54
    y32 = p[ dd ];                                  /* Q16 */
   17252:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   17254:	9e13      	ldr	r6, [sp, #76]	; 0x4c
                    NLSF[ 0 ] = 0;
   17256:	f04f 0200 	mov.w	r2, #0
   1725a:	801a      	strh	r2, [r3, #0]
    y32 = p[ dd ];                                  /* Q16 */
   1725c:	46dc      	mov	ip, fp
            y32 = silk_SMLAWW( p[ n ], y32, x_Q16 );    /* Q16 */
   1725e:	fa1f f28c 	uxth.w	r2, ip
   17262:	ea4f 432c 	mov.w	r3, ip, asr #16
   17266:	fb00 f202 	mul.w	r2, r0, r2
   1726a:	fb00 f303 	mul.w	r3, r0, r3
   1726e:	f855 1d04 	ldr.w	r1, [r5, #-4]!
   17272:	eb03 4322 	add.w	r3, r3, r2, asr #16
   17276:	440b      	add	r3, r1
        for( n = dd - 1; n >= 0; n-- ) {
   17278:	3c01      	subs	r4, #1
            y32 = silk_SMLAWW( p[ n ], y32, x_Q16 );    /* Q16 */
   1727a:	fb06 3c0c 	mla	ip, r6, ip, r3
        for( n = dd - 1; n >= 0; n-- ) {
   1727e:	1c63      	adds	r3, r4, #1
   17280:	d1ed      	bne.n	1725e <silk_A2NLSF+0xbfe>
                    root_ix = 1;                  /* Index of current root */
   17282:	2301      	movs	r3, #1
   17284:	930b      	str	r3, [sp, #44]	; 0x2c
                k = 1;                            /* Reset loop counter */
   17286:	9303      	str	r3, [sp, #12]
   17288:	e773      	b.n	17172 <silk_A2NLSF+0xb12>
   1728a:	f6ff aa52 	blt.w	16732 <silk_A2NLSF+0xd2>
   1728e:	3402      	adds	r4, #2
   17290:	ab20      	add	r3, sp, #128	; 0x80
   17292:	45a0      	cmp	r8, r4
   17294:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   17298:	f77f aa38 	ble.w	1670c <silk_A2NLSF+0xac>
   1729c:	e953 0102 	ldrd	r0, r1, [r3, #-8]
        p[ k - 2 ] -= silk_LSHIFT( p[ k ], 1 );
   172a0:	e9d3 6500 	ldrd	r6, r5, [r3]
   172a4:	4614      	mov	r4, r2
   172a6:	3403      	adds	r4, #3
   172a8:	eba0 0046 	sub.w	r0, r0, r6, lsl #1
   172ac:	eba1 0145 	sub.w	r1, r1, r5, lsl #1
   172b0:	45a0      	cmp	r8, r4
   172b2:	f843 0c08 	str.w	r0, [r3, #-8]
   172b6:	f843 1c04 	str.w	r1, [r3, #-4]
   172ba:	4630      	mov	r0, r6
   172bc:	4629      	mov	r1, r5
   172be:	f103 0308 	add.w	r3, r3, #8
   172c2:	f102 0202 	add.w	r2, r2, #2
   172c6:	dceb      	bgt.n	172a0 <silk_A2NLSF+0xc40>
   172c8:	f7ff ba20 	b.w	1670c <silk_A2NLSF+0xac>
    for( k = 2; k <= dd; k++ ) {
   172cc:	2202      	movs	r2, #2
   172ce:	f7ff bad2 	b.w	16876 <silk_A2NLSF+0x216>
        y32 = silk_SMLAWW( p[ 7 ], y32, x_Q16 );
   172d2:	e9dd 2e34 	ldrd	r2, lr, [sp, #208]	; 0xd0
   172d6:	fa1f f48e 	uxth.w	r4, lr
   172da:	ea4f 402e 	mov.w	r0, lr, asr #16
   172de:	fb01 f404 	mul.w	r4, r1, r4
   172e2:	fb01 f000 	mul.w	r0, r1, r0
   172e6:	eb00 4024 	add.w	r0, r0, r4, asr #16
   172ea:	4410      	add	r0, r2
   172ec:	fb05 000e 	mla	r0, r5, lr, r0
        y32 = silk_SMLAWW( p[ 6 ], y32, x_Q16 );
   172f0:	b284      	uxth	r4, r0
   172f2:	1402      	asrs	r2, r0, #16
   172f4:	fb01 f404 	mul.w	r4, r1, r4
   172f8:	9b33      	ldr	r3, [sp, #204]	; 0xcc
   172fa:	fb01 f202 	mul.w	r2, r1, r2
   172fe:	eb02 4224 	add.w	r2, r2, r4, asr #16
   17302:	441a      	add	r2, r3
   17304:	fb05 2000 	mla	r0, r5, r0, r2
        y32 = silk_SMLAWW( p[ 5 ], y32, x_Q16 );
   17308:	b284      	uxth	r4, r0
   1730a:	1402      	asrs	r2, r0, #16
   1730c:	fb01 f404 	mul.w	r4, r1, r4
   17310:	fb01 f202 	mul.w	r2, r1, r2
   17314:	9b32      	ldr	r3, [sp, #200]	; 0xc8
   17316:	eb02 4224 	add.w	r2, r2, r4, asr #16
   1731a:	441a      	add	r2, r3
   1731c:	fb05 2000 	mla	r0, r5, r0, r2
        y32 = silk_SMLAWW( p[ 4 ], y32, x_Q16 );
   17320:	b284      	uxth	r4, r0
   17322:	1402      	asrs	r2, r0, #16
   17324:	fb01 f404 	mul.w	r4, r1, r4
   17328:	fb01 f202 	mul.w	r2, r1, r2
   1732c:	9b31      	ldr	r3, [sp, #196]	; 0xc4
   1732e:	eb02 4224 	add.w	r2, r2, r4, asr #16
   17332:	441a      	add	r2, r3
   17334:	fb05 2000 	mla	r0, r5, r0, r2
        y32 = silk_SMLAWW( p[ 3 ], y32, x_Q16 );
   17338:	b284      	uxth	r4, r0
   1733a:	1402      	asrs	r2, r0, #16
   1733c:	fb01 f404 	mul.w	r4, r1, r4
   17340:	fb01 f202 	mul.w	r2, r1, r2
   17344:	9b30      	ldr	r3, [sp, #192]	; 0xc0
   17346:	eb02 4224 	add.w	r2, r2, r4, asr #16
   1734a:	441a      	add	r2, r3
   1734c:	fb05 2000 	mla	r0, r5, r0, r2
        y32 = silk_SMLAWW( p[ 2 ], y32, x_Q16 );
   17350:	b284      	uxth	r4, r0
   17352:	1402      	asrs	r2, r0, #16
   17354:	fb01 f404 	mul.w	r4, r1, r4
   17358:	fb01 f202 	mul.w	r2, r1, r2
   1735c:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
   1735e:	eb02 4224 	add.w	r2, r2, r4, asr #16
   17362:	441a      	add	r2, r3
   17364:	fb05 2000 	mla	r0, r5, r0, r2
        y32 = silk_SMLAWW( p[ 1 ], y32, x_Q16 );
   17368:	b284      	uxth	r4, r0
   1736a:	1402      	asrs	r2, r0, #16
   1736c:	fb01 f404 	mul.w	r4, r1, r4
   17370:	fb01 f202 	mul.w	r2, r1, r2
   17374:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
   17376:	eb02 4224 	add.w	r2, r2, r4, asr #16
   1737a:	441a      	add	r2, r3
   1737c:	fb05 2000 	mla	r0, r5, r0, r2
        y32 = silk_SMLAWW( p[ 0 ], y32, x_Q16 );
   17380:	1403      	asrs	r3, r0, #16
   17382:	b282      	uxth	r2, r0
   17384:	fb01 f202 	mul.w	r2, r1, r2
   17388:	fb01 f103 	mul.w	r1, r1, r3
   1738c:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
   1738e:	eb01 4222 	add.w	r2, r1, r2, asr #16
   17392:	441a      	add	r2, r3
   17394:	fb05 2c00 	mla	ip, r5, r0, r2
        NLSF[ 0 ] = 0;
   17398:	2300      	movs	r3, #0
   1739a:	9a15      	ldr	r2, [sp, #84]	; 0x54
   1739c:	8013      	strh	r3, [r2, #0]
        root_ix = 1;                /* Index of current root */
   1739e:	2301      	movs	r3, #1
        p = Q;                      /* Pointer to polynomial */
   173a0:	af2d      	add	r7, sp, #180	; 0xb4
        root_ix = 1;                /* Index of current root */
   173a2:	930b      	str	r3, [sp, #44]	; 0x2c
   173a4:	f7ff baf2 	b.w	1698c <silk_A2NLSF+0x32c>
    y32 = p[ dd ];                                  /* Q16 */
   173a8:	462a      	mov	r2, r5
   173aa:	e4f6      	b.n	16d9a <silk_A2NLSF+0x73a>
   173ac:	465c      	mov	r4, fp
   173ae:	f7ff bb74 	b.w	16a9a <silk_A2NLSF+0x43a>
   173b2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   173b4:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   173b6:	441a      	add	r2, r3
   173b8:	921d      	str	r2, [sp, #116]	; 0x74
   173ba:	f1a3 0904 	sub.w	r9, r3, #4
    xlo = silk_LSFCosTab_FIX_Q12[ 0 ]; /* Q12*/
   173be:	4b37      	ldr	r3, [pc, #220]	; (1749c <silk_A2NLSF+0xe3c>)
   173c0:	9310      	str	r3, [sp, #64]	; 0x40
   173c2:	f9b3 3000 	ldrsh.w	r3, [r3]
   173c6:	9318      	str	r3, [sp, #96]	; 0x60
    x_Q16 = silk_LSHIFT( x, 4 );
   173c8:	011b      	lsls	r3, r3, #4
   173ca:	931b      	str	r3, [sp, #108]	; 0x6c
   173cc:	13db      	asrs	r3, r3, #15
    y32 = p[ dd ];                                  /* Q16 */
   173ce:	aa20      	add	r2, sp, #128	; 0x80
   173d0:	3301      	adds	r3, #1
   173d2:	105b      	asrs	r3, r3, #1
   173d4:	9313      	str	r3, [sp, #76]	; 0x4c
   173d6:	f852 e028 	ldr.w	lr, [r2, r8, lsl #2]
   173da:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
   173de:	930d      	str	r3, [sp, #52]	; 0x34
        for( n = dd - 1; n >= 0; n-- ) {
   173e0:	980d      	ldr	r0, [sp, #52]	; 0x34
   173e2:	2800      	cmp	r0, #0
   173e4:	db4d      	blt.n	17482 <silk_A2NLSF+0xe22>
   173e6:	f9bd 506c 	ldrsh.w	r5, [sp, #108]	; 0x6c
   173ea:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
   173ec:	9913      	ldr	r1, [sp, #76]	; 0x4c
   173ee:	46f4      	mov	ip, lr
            y32 = silk_SMLAWW( p[ n ], y32, x_Q16 );    /* Q16 */
   173f0:	fa1f f28c 	uxth.w	r2, ip
   173f4:	ea4f 432c 	mov.w	r3, ip, asr #16
   173f8:	fb05 f202 	mul.w	r2, r5, r2
   173fc:	fb05 f303 	mul.w	r3, r5, r3
   17400:	f854 6d04 	ldr.w	r6, [r4, #-4]!
   17404:	eb03 4322 	add.w	r3, r3, r2, asr #16
        for( n = dd - 1; n >= 0; n-- ) {
   17408:	3801      	subs	r0, #1
            y32 = silk_SMLAWW( p[ n ], y32, x_Q16 );    /* Q16 */
   1740a:	4433      	add	r3, r6
        for( n = dd - 1; n >= 0; n-- ) {
   1740c:	1c47      	adds	r7, r0, #1
            y32 = silk_SMLAWW( p[ n ], y32, x_Q16 );    /* Q16 */
   1740e:	fb01 3c0c 	mla	ip, r1, ip, r3
        for( n = dd - 1; n >= 0; n-- ) {
   17412:	d1ed      	bne.n	173f0 <silk_A2NLSF+0xd90>
    if( ylo < 0 ) {
   17414:	f1bc 0f00 	cmp.w	ip, #0
   17418:	f6bf aab5 	bge.w	16986 <silk_A2NLSF+0x326>
    y32 = p[ dd ];                                  /* Q16 */
   1741c:	ab2d      	add	r3, sp, #180	; 0xb4
        NLSF[ 0 ] = 0;
   1741e:	9a15      	ldr	r2, [sp, #84]	; 0x54
    y32 = p[ dd ];                                  /* Q16 */
   17420:	f853 e028 	ldr.w	lr, [r3, r8, lsl #2]
   17424:	9c16      	ldr	r4, [sp, #88]	; 0x58
   17426:	980d      	ldr	r0, [sp, #52]	; 0x34
        NLSF[ 0 ] = 0;
   17428:	2300      	movs	r3, #0
    y32 = p[ dd ];                                  /* Q16 */
   1742a:	46f4      	mov	ip, lr
        NLSF[ 0 ] = 0;
   1742c:	8013      	strh	r3, [r2, #0]
            y32 = silk_SMLAWW( p[ n ], y32, x_Q16 );    /* Q16 */
   1742e:	fa1f f28c 	uxth.w	r2, ip
   17432:	ea4f 432c 	mov.w	r3, ip, asr #16
   17436:	fb05 f202 	mul.w	r2, r5, r2
   1743a:	fb05 f303 	mul.w	r3, r5, r3
   1743e:	f854 1d04 	ldr.w	r1, [r4, #-4]!
   17442:	eb03 4322 	add.w	r3, r3, r2, asr #16
        for( n = dd - 1; n >= 0; n-- ) {
   17446:	3801      	subs	r0, #1
            y32 = silk_SMLAWW( p[ n ], y32, x_Q16 );    /* Q16 */
   17448:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   1744a:	440b      	add	r3, r1
        for( n = dd - 1; n >= 0; n-- ) {
   1744c:	1c46      	adds	r6, r0, #1
            y32 = silk_SMLAWW( p[ n ], y32, x_Q16 );    /* Q16 */
   1744e:	fb02 3c0c 	mla	ip, r2, ip, r3
        for( n = dd - 1; n >= 0; n-- ) {
   17452:	d1ec      	bne.n	1742e <silk_A2NLSF+0xdce>
   17454:	e7a3      	b.n	1739e <silk_A2NLSF+0xd3e>
                if( ylo < 0 ) {
   17456:	f1bb 0f00 	cmp.w	fp, #0
   1745a:	db06      	blt.n	1746a <silk_A2NLSF+0xe0a>
            thr = 0;
   1745c:	2300      	movs	r3, #0
   1745e:	9305      	str	r3, [sp, #20]
                    root_ix = 0;                  /* Index of current root */
   17460:	930b      	str	r3, [sp, #44]	; 0x2c
   17462:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   17464:	9306      	str	r3, [sp, #24]
   17466:	46dc      	mov	ip, fp
   17468:	e59d      	b.n	16fa6 <silk_A2NLSF+0x946>
    y32 = p[ dd ];                                  /* Q16 */
   1746a:	9b16      	ldr	r3, [sp, #88]	; 0x58
   1746c:	f8d3 b000 	ldr.w	fp, [r3]
                    NLSF[ 0 ] = 0;
   17470:	9b15      	ldr	r3, [sp, #84]	; 0x54
   17472:	f04f 0200 	mov.w	r2, #0
   17476:	801a      	strh	r2, [r3, #0]
                    root_ix = 1;                  /* Index of current root */
   17478:	2301      	movs	r3, #1
   1747a:	930b      	str	r3, [sp, #44]	; 0x2c
    y32 = p[ dd ];                                  /* Q16 */
   1747c:	46dc      	mov	ip, fp
                k = 1;                            /* Reset loop counter */
   1747e:	9303      	str	r3, [sp, #12]
   17480:	e677      	b.n	17172 <silk_A2NLSF+0xb12>
    if( ylo < 0 ) {
   17482:	f1be 0f00 	cmp.w	lr, #0
   17486:	db02      	blt.n	1748e <silk_A2NLSF+0xe2e>
   17488:	46f4      	mov	ip, lr
   1748a:	f7ff ba7c 	b.w	16986 <silk_A2NLSF+0x326>
    y32 = p[ dd ];                                  /* Q16 */
   1748e:	ab2d      	add	r3, sp, #180	; 0xb4
   17490:	f853 e028 	ldr.w	lr, [r3, r8, lsl #2]
        NLSF[ 0 ] = 0;
   17494:	2300      	movs	r3, #0
    y32 = p[ dd ];                                  /* Q16 */
   17496:	46f4      	mov	ip, lr
   17498:	e77f      	b.n	1739a <silk_A2NLSF+0xd3a>
   1749a:	bf00      	nop
   1749c:	000373d4 	.word	0x000373d4

000174a0 <silk_ana_filt_bank_1>:
    opus_int32                  *S,                 /* I/O  State vector [2]                                            */
    opus_int16                  *outL,              /* O    Low band [N/2]                                              */
    opus_int16                  *outH,              /* O    High band [N/2]                                             */
    const opus_int32            N                   /* I    Number of input samples                                     */
)
{
   174a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   174a4:	b083      	sub	sp, #12
   174a6:	9c0c      	ldr	r4, [sp, #48]	; 0x30
   174a8:	9101      	str	r1, [sp, #4]
    opus_int      k, N2 = silk_RSHIFT( N, 1 );
   174aa:	1064      	asrs	r4, r4, #1
    opus_int32    in32, X, Y, out_1, out_2;

    /* Internal variables and state are in Q10 format */
    for( k = 0; k < N2; k++ ) {
   174ac:	2c00      	cmp	r4, #0
   174ae:	dd60      	ble.n	17572 <silk_ana_filt_bank_1+0xd2>
   174b0:	3002      	adds	r0, #2
   174b2:	f8d1 9000 	ldr.w	r9, [r1]
   174b6:	f8d1 8004 	ldr.w	r8, [r1, #4]
        /* Convert to Q10 */
        in32 = silk_LSHIFT( (opus_int32)in[ 2 * k ], 10 );

        /* All-pass section for even input sample */
        Y      = silk_SUB32( in32, S[ 0 ] );
        X      = silk_SMLAWB( Y, Y, A_fb1_21 );
   174ba:	f8df b0c8 	ldr.w	fp, [pc, #200]	; 17584 <silk_ana_filt_bank_1+0xe4>
   174be:	eb00 0184 	add.w	r1, r0, r4, lsl #2
   174c2:	9100      	str	r1, [sp, #0]
   174c4:	3b02      	subs	r3, #2
   174c6:	3a02      	subs	r2, #2
        /* Convert to Q10 */
        in32 = silk_LSHIFT( (opus_int32)in[ 2 * k + 1 ], 10 );

        /* All-pass section for odd input sample, and add to output of previous section */
        Y      = silk_SUB32( in32, S[ 1 ] );
        X      = silk_SMULWB( Y, A_fb1_20 );
   174c8:	f642 2a24 	movw	sl, #10788	; 0x2a24
   174cc:	e017      	b.n	174fe <silk_ana_filt_bank_1+0x5e>
        out_2  = silk_ADD32( S[ 1 ], X );
        S[ 1 ] = silk_ADD32( in32, X );

        /* Add/subtract, convert back to int16 and store to output */
        outL[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( silk_ADD32( out_2, out_1 ), 11 ) );
   174ce:	f514 4f00 	cmn.w	r4, #32768	; 0x8000
   174d2:	db51      	blt.n	17578 <silk_ana_filt_bank_1+0xd8>
   174d4:	b224      	sxth	r4, r4
        outH[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( silk_SUB32( out_2, out_1 ), 11 ) );
   174d6:	eba1 010e 	sub.w	r1, r1, lr
   174da:	1289      	asrs	r1, r1, #10
   174dc:	3101      	adds	r1, #1
   174de:	1049      	asrs	r1, r1, #1
   174e0:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
        outL[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( silk_ADD32( out_2, out_1 ), 11 ) );
   174e4:	f822 4f02 	strh.w	r4, [r2, #2]!
        outH[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( silk_SUB32( out_2, out_1 ), 11 ) );
   174e8:	da38      	bge.n	1755c <silk_ana_filt_bank_1+0xbc>
   174ea:	f511 4f00 	cmn.w	r1, #32768	; 0x8000
   174ee:	db45      	blt.n	1757c <silk_ana_filt_bank_1+0xdc>
   174f0:	b209      	sxth	r1, r1
   174f2:	f823 1f02 	strh.w	r1, [r3, #2]!
    for( k = 0; k < N2; k++ ) {
   174f6:	9900      	ldr	r1, [sp, #0]
   174f8:	3004      	adds	r0, #4
   174fa:	4288      	cmp	r0, r1
   174fc:	d036      	beq.n	1756c <silk_ana_filt_bank_1+0xcc>
        in32 = silk_LSHIFT( (opus_int32)in[ 2 * k ], 10 );
   174fe:	f930 cc02 	ldrsh.w	ip, [r0, #-2]
        in32 = silk_LSHIFT( (opus_int32)in[ 2 * k + 1 ], 10 );
   17502:	f9b0 7000 	ldrsh.w	r7, [r0]
        in32 = silk_LSHIFT( (opus_int32)in[ 2 * k ], 10 );
   17506:	ea4f 2c8c 	mov.w	ip, ip, lsl #10
        Y      = silk_SUB32( in32, S[ 0 ] );
   1750a:	ebac 0409 	sub.w	r4, ip, r9
        X      = silk_SMLAWB( Y, Y, A_fb1_21 );
   1750e:	b2a1      	uxth	r1, r4
   17510:	1426      	asrs	r6, r4, #16
        in32 = silk_LSHIFT( (opus_int32)in[ 2 * k + 1 ], 10 );
   17512:	02bf      	lsls	r7, r7, #10
        X      = silk_SMLAWB( Y, Y, A_fb1_21 );
   17514:	fb0b f101 	mul.w	r1, fp, r1
   17518:	fb0b f606 	mul.w	r6, fp, r6
   1751c:	eb06 4621 	add.w	r6, r6, r1, asr #16
        Y      = silk_SUB32( in32, S[ 1 ] );
   17520:	eba7 0108 	sub.w	r1, r7, r8
        X      = silk_SMLAWB( Y, Y, A_fb1_21 );
   17524:	4426      	add	r6, r4
        X      = silk_SMULWB( Y, A_fb1_20 );
   17526:	140d      	asrs	r5, r1, #16
   17528:	b28c      	uxth	r4, r1
   1752a:	fb0a f104 	mul.w	r1, sl, r4
   1752e:	fb0a f505 	mul.w	r5, sl, r5
   17532:	eb05 4511 	add.w	r5, r5, r1, lsr #16
        out_1  = silk_ADD32( S[ 0 ], X );
   17536:	eb06 0e09 	add.w	lr, r6, r9
        out_2  = silk_ADD32( S[ 1 ], X );
   1753a:	eb05 0108 	add.w	r1, r5, r8
        outL[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( silk_ADD32( out_2, out_1 ), 11 ) );
   1753e:	eb01 040e 	add.w	r4, r1, lr
   17542:	12a4      	asrs	r4, r4, #10
   17544:	3401      	adds	r4, #1
   17546:	1064      	asrs	r4, r4, #1
   17548:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
        S[ 0 ] = silk_ADD32( in32, X );
   1754c:	eb06 090c 	add.w	r9, r6, ip
        S[ 1 ] = silk_ADD32( in32, X );
   17550:	eb05 0807 	add.w	r8, r5, r7
        outL[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( silk_ADD32( out_2, out_1 ), 11 ) );
   17554:	dbbb      	blt.n	174ce <silk_ana_filt_bank_1+0x2e>
   17556:	f647 74ff 	movw	r4, #32767	; 0x7fff
   1755a:	e7bc      	b.n	174d6 <silk_ana_filt_bank_1+0x36>
        outH[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( silk_SUB32( out_2, out_1 ), 11 ) );
   1755c:	f647 71ff 	movw	r1, #32767	; 0x7fff
   17560:	f823 1f02 	strh.w	r1, [r3, #2]!
    for( k = 0; k < N2; k++ ) {
   17564:	9900      	ldr	r1, [sp, #0]
   17566:	3004      	adds	r0, #4
   17568:	4288      	cmp	r0, r1
   1756a:	d1c8      	bne.n	174fe <silk_ana_filt_bank_1+0x5e>
   1756c:	9b01      	ldr	r3, [sp, #4]
   1756e:	e9c3 9800 	strd	r9, r8, [r3]
    }
}
   17572:	b003      	add	sp, #12
   17574:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        outL[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( silk_ADD32( out_2, out_1 ), 11 ) );
   17578:	4c01      	ldr	r4, [pc, #4]	; (17580 <silk_ana_filt_bank_1+0xe0>)
   1757a:	e7ac      	b.n	174d6 <silk_ana_filt_bank_1+0x36>
        outH[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( silk_SUB32( out_2, out_1 ), 11 ) );
   1757c:	4900      	ldr	r1, [pc, #0]	; (17580 <silk_ana_filt_bank_1+0xe0>)
   1757e:	e7b8      	b.n	174f2 <silk_ana_filt_bank_1+0x52>
   17580:	ffff8000 	.word	0xffff8000
   17584:	ffffa11e 	.word	0xffffa11e

00017588 <silk_biquad_alt_stride1>:
    const opus_int32            *A_Q28,             /* I     AR coefficients [2]                                        */
    opus_int32                  *S,                 /* I/O   State vector [2]                                           */
    opus_int16                  *out,               /* O     output signal                                              */
    const opus_int32            len                 /* I     signal length (must be even)                               */
)
{
   17588:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1758c:	b087      	sub	sp, #28
    opus_int32 inval, A0_U_Q28, A0_L_Q28, A1_U_Q28, A1_L_Q28, out32_Q14;

    /* Negate A_Q28 values and split in two parts */
    A0_L_Q28 = ( -A_Q28[ 0 ] ) & 0x00003FFF;        /* lower part */
    A0_U_Q28 = silk_RSHIFT( -A_Q28[ 0 ], 14 );      /* upper part */
    A1_L_Q28 = ( -A_Q28[ 1 ] ) & 0x00003FFF;        /* lower part */
   1758e:	e9d2 5200 	ldrd	r5, r2, [r2]
{
   17592:	9c11      	ldr	r4, [sp, #68]	; 0x44
    A0_L_Q28 = ( -A_Q28[ 0 ] ) & 0x00003FFF;        /* lower part */
   17594:	426d      	negs	r5, r5
    A1_L_Q28 = ( -A_Q28[ 1 ] ) & 0x00003FFF;        /* lower part */
   17596:	4252      	negs	r2, r2
    A1_U_Q28 = silk_RSHIFT( -A_Q28[ 1 ], 14 );      /* upper part */

    for( k = 0; k < len; k++ ) {
   17598:	2c00      	cmp	r4, #0
    A0_L_Q28 = ( -A_Q28[ 0 ] ) & 0x00003FFF;        /* lower part */
   1759a:	f3c5 0a0d 	ubfx	sl, r5, #0, #14
    A1_L_Q28 = ( -A_Q28[ 1 ] ) & 0x00003FFF;        /* lower part */
   1759e:	f3c2 0b0d 	ubfx	fp, r2, #0, #14
    for( k = 0; k < len; k++ ) {
   175a2:	dd7c      	ble.n	1769e <silk_biquad_alt_stride1+0x116>
   175a4:	1392      	asrs	r2, r2, #14
   175a6:	b212      	sxth	r2, r2
   175a8:	3802      	subs	r0, #2
   175aa:	e9d3 6700 	ldrd	r6, r7, [r3]
   175ae:	9205      	str	r2, [sp, #20]
   175b0:	9a10      	ldr	r2, [sp, #64]	; 0x40
        S[ 1 ] = silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14, A1_L_Q28 ), 14 );
        S[ 1 ] = silk_SMLAWB( S[ 1 ], out32_Q14, A1_U_Q28 );
        S[ 1 ] = silk_SMLAWB( S[ 1 ], B_Q28[ 2 ], inval );

        /* Scale back to Q0 and saturate */
        out[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT( out32_Q14 + (1<<14) - 1, 14 ) );
   175b2:	9001      	str	r0, [sp, #4]
   175b4:	13ad      	asrs	r5, r5, #14
   175b6:	eb00 0444 	add.w	r4, r0, r4, lsl #1
   175ba:	9403      	str	r4, [sp, #12]
   175bc:	3a02      	subs	r2, #2
   175be:	b22c      	sxth	r4, r5
   175c0:	9404      	str	r4, [sp, #16]
   175c2:	9202      	str	r2, [sp, #8]
   175c4:	4635      	mov	r5, r6
   175c6:	e00b      	b.n	175e0 <silk_biquad_alt_stride1+0x58>
   175c8:	f512 4f00 	cmn.w	r2, #32768	; 0x8000
   175cc:	db65      	blt.n	1769a <silk_biquad_alt_stride1+0x112>
   175ce:	b212      	sxth	r2, r2
   175d0:	9802      	ldr	r0, [sp, #8]
   175d2:	f820 2f02 	strh.w	r2, [r0, #2]!
    for( k = 0; k < len; k++ ) {
   175d6:	9a03      	ldr	r2, [sp, #12]
        out[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT( out32_Q14 + (1<<14) - 1, 14 ) );
   175d8:	9002      	str	r0, [sp, #8]
    for( k = 0; k < len; k++ ) {
   175da:	9801      	ldr	r0, [sp, #4]
   175dc:	4282      	cmp	r2, r0
   175de:	d05e      	beq.n	1769e <silk_biquad_alt_stride1+0x116>
        inval = in[ k ];
   175e0:	9a01      	ldr	r2, [sp, #4]
        out32_Q14 = silk_LSHIFT( silk_SMLAWB( S[ 0 ], B_Q28[ 0 ], inval ), 2 );
   175e2:	680c      	ldr	r4, [r1, #0]
        inval = in[ k ];
   175e4:	f932 cf02 	ldrsh.w	ip, [r2, #2]!
   175e8:	9201      	str	r2, [sp, #4]
        out32_Q14 = silk_LSHIFT( silk_SMLAWB( S[ 0 ], B_Q28[ 0 ], inval ), 2 );
   175ea:	ea4f 4824 	mov.w	r8, r4, asr #16
   175ee:	b2a2      	uxth	r2, r4
   175f0:	fb0c f202 	mul.w	r2, ip, r2
   175f4:	fb0c f808 	mul.w	r8, ip, r8
   175f8:	eb08 4822 	add.w	r8, r8, r2, asr #16
   175fc:	44a8      	add	r8, r5
   175fe:	ea4f 0288 	mov.w	r2, r8, lsl #2
        S[ 0 ] = S[1] + silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14, A0_L_Q28 ), 14 );
   17602:	1416      	asrs	r6, r2, #16
   17604:	fa1f fe82 	uxth.w	lr, r2
   17608:	fb0e f40a 	mul.w	r4, lr, sl
   1760c:	fb06 f50a 	mul.w	r5, r6, sl
   17610:	eb05 4514 	add.w	r5, r5, r4, lsr #16
        S[ 0 ] = silk_SMLAWB( S[ 0 ], out32_Q14, A0_U_Q28 );
   17614:	9c04      	ldr	r4, [sp, #16]
        S[ 1 ] = silk_SMLAWB( S[ 1 ], out32_Q14, A1_U_Q28 );
   17616:	9805      	ldr	r0, [sp, #20]
        S[ 0 ] = S[1] + silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14, A0_L_Q28 ), 14 );
   17618:	136d      	asrs	r5, r5, #13
        S[ 0 ] = silk_SMLAWB( S[ 0 ], out32_Q14, A0_U_Q28 );
   1761a:	fb04 f90e 	mul.w	r9, r4, lr
   1761e:	fb04 f806 	mul.w	r8, r4, r6
        S[ 0 ] = S[1] + silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14, A0_L_Q28 ), 14 );
   17622:	3501      	adds	r5, #1
   17624:	eb07 0765 	add.w	r7, r7, r5, asr #1
        S[ 0 ] = silk_SMLAWB( S[ 0 ], out32_Q14, A0_U_Q28 );
   17628:	eb08 4429 	add.w	r4, r8, r9, asr #16
   1762c:	443c      	add	r4, r7
   1762e:	601c      	str	r4, [r3, #0]
        S[ 0 ] = silk_SMLAWB( S[ 0 ], B_Q28[ 1 ], inval);
   17630:	684d      	ldr	r5, [r1, #4]
        S[ 1 ] = silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14, A1_L_Q28 ), 14 );
   17632:	fb0e f90b 	mul.w	r9, lr, fp
   17636:	fb06 f70b 	mul.w	r7, r6, fp
        S[ 0 ] = silk_SMLAWB( S[ 0 ], B_Q28[ 1 ], inval);
   1763a:	fa1f f885 	uxth.w	r8, r5
        S[ 1 ] = silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14, A1_L_Q28 ), 14 );
   1763e:	eb07 4719 	add.w	r7, r7, r9, lsr #16
        S[ 0 ] = silk_SMLAWB( S[ 0 ], B_Q28[ 1 ], inval);
   17642:	142d      	asrs	r5, r5, #16
   17644:	fb0c f905 	mul.w	r9, ip, r5
   17648:	fb0c f808 	mul.w	r8, ip, r8
        S[ 1 ] = silk_SMLAWB( S[ 1 ], out32_Q14, A1_U_Q28 );
   1764c:	fb00 fe0e 	mul.w	lr, r0, lr
        S[ 1 ] = silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14, A1_L_Q28 ), 14 );
   17650:	137f      	asrs	r7, r7, #13
        S[ 1 ] = silk_SMLAWB( S[ 1 ], out32_Q14, A1_U_Q28 );
   17652:	fb00 f606 	mul.w	r6, r0, r6
        S[ 0 ] = silk_SMLAWB( S[ 0 ], B_Q28[ 1 ], inval);
   17656:	eb09 4828 	add.w	r8, r9, r8, asr #16
        S[ 1 ] = silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14, A1_L_Q28 ), 14 );
   1765a:	3701      	adds	r7, #1
        S[ 1 ] = silk_SMLAWB( S[ 1 ], out32_Q14, A1_U_Q28 );
   1765c:	eb06 4e2e 	add.w	lr, r6, lr, asr #16
        S[ 0 ] = silk_SMLAWB( S[ 0 ], B_Q28[ 1 ], inval);
   17660:	eb08 0504 	add.w	r5, r8, r4
        S[ 1 ] = silk_SMLAWB( S[ 1 ], out32_Q14, A1_U_Q28 );
   17664:	eb0e 0767 	add.w	r7, lr, r7, asr #1
   17668:	e9c3 5700 	strd	r5, r7, [r3]
        S[ 1 ] = silk_SMLAWB( S[ 1 ], B_Q28[ 2 ], inval );
   1766c:	688c      	ldr	r4, [r1, #8]
        out[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT( out32_Q14 + (1<<14) - 1, 14 ) );
   1766e:	f502 527f 	add.w	r2, r2, #16320	; 0x3fc0
        S[ 1 ] = silk_SMLAWB( S[ 1 ], B_Q28[ 2 ], inval );
   17672:	fa1f f984 	uxth.w	r9, r4
   17676:	ea4f 4824 	mov.w	r8, r4, asr #16
   1767a:	fb0c f909 	mul.w	r9, ip, r9
        out[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT( out32_Q14 + (1<<14) - 1, 14 ) );
   1767e:	323f      	adds	r2, #63	; 0x3f
        S[ 1 ] = silk_SMLAWB( S[ 1 ], B_Q28[ 2 ], inval );
   17680:	fb0c fc08 	mul.w	ip, ip, r8
   17684:	eb0c 4c29 	add.w	ip, ip, r9, asr #16
        out[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT( out32_Q14 + (1<<14) - 1, 14 ) );
   17688:	1392      	asrs	r2, r2, #14
        S[ 1 ] = silk_SMLAWB( S[ 1 ], B_Q28[ 2 ], inval );
   1768a:	4467      	add	r7, ip
        out[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT( out32_Q14 + (1<<14) - 1, 14 ) );
   1768c:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
        S[ 1 ] = silk_SMLAWB( S[ 1 ], B_Q28[ 2 ], inval );
   17690:	605f      	str	r7, [r3, #4]
        out[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT( out32_Q14 + (1<<14) - 1, 14 ) );
   17692:	db99      	blt.n	175c8 <silk_biquad_alt_stride1+0x40>
   17694:	f647 72ff 	movw	r2, #32767	; 0x7fff
   17698:	e79a      	b.n	175d0 <silk_biquad_alt_stride1+0x48>
   1769a:	4a02      	ldr	r2, [pc, #8]	; (176a4 <silk_biquad_alt_stride1+0x11c>)
   1769c:	e798      	b.n	175d0 <silk_biquad_alt_stride1+0x48>
    }
}
   1769e:	b007      	add	sp, #28
   176a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   176a4:	ffff8000 	.word	0xffff8000

000176a8 <silk_biquad_alt_stride2_c>:
    const opus_int32            *A_Q28,             /* I     AR coefficients [2]                                        */
    opus_int32                  *S,                 /* I/O   State vector [4]                                           */
    opus_int16                  *out,               /* O     output signal                                              */
    const opus_int32            len                 /* I     signal length (must be even)                               */
)
{
   176a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    opus_int32 A0_U_Q28, A0_L_Q28, A1_U_Q28, A1_L_Q28, out32_Q14[ 2 ];

    /* Negate A_Q28 values and split in two parts */
    A0_L_Q28 = ( -A_Q28[ 0 ] ) & 0x00003FFF;        /* lower part */
    A0_U_Q28 = silk_RSHIFT( -A_Q28[ 0 ], 14 );      /* upper part */
    A1_L_Q28 = ( -A_Q28[ 1 ] ) & 0x00003FFF;        /* lower part */
   176ac:	e9d2 5200 	ldrd	r5, r2, [r2]
{
   176b0:	b08d      	sub	sp, #52	; 0x34
    A0_L_Q28 = ( -A_Q28[ 0 ] ) & 0x00003FFF;        /* lower part */
   176b2:	426d      	negs	r5, r5
{
   176b4:	9c17      	ldr	r4, [sp, #92]	; 0x5c
    A1_L_Q28 = ( -A_Q28[ 1 ] ) & 0x00003FFF;        /* lower part */
   176b6:	4252      	negs	r2, r2
{
   176b8:	4699      	mov	r9, r3
    A0_L_Q28 = ( -A_Q28[ 0 ] ) & 0x00003FFF;        /* lower part */
   176ba:	f3c5 030d 	ubfx	r3, r5, #0, #14
   176be:	9307      	str	r3, [sp, #28]
    A1_U_Q28 = silk_RSHIFT( -A_Q28[ 1 ], 14 );      /* upper part */

    for( k = 0; k < len; k++ ) {
   176c0:	2c00      	cmp	r4, #0
    A1_L_Q28 = ( -A_Q28[ 1 ] ) & 0x00003FFF;        /* lower part */
   176c2:	f3c2 030d 	ubfx	r3, r2, #0, #14
   176c6:	9308      	str	r3, [sp, #32]
    for( k = 0; k < len; k++ ) {
   176c8:	f340 80f4 	ble.w	178b4 <silk_biquad_alt_stride2_c+0x20c>
   176cc:	1393      	asrs	r3, r2, #14
   176ce:	b21b      	sxth	r3, r3
   176d0:	f8d9 2000 	ldr.w	r2, [r9]
   176d4:	9203      	str	r2, [sp, #12]
   176d6:	930b      	str	r3, [sp, #44]	; 0x2c
   176d8:	e9d9 b201 	ldrd	fp, r2, [r9, #4]
   176dc:	9b16      	ldr	r3, [sp, #88]	; 0x58
   176de:	9000      	str	r0, [sp, #0]
   176e0:	13ad      	asrs	r5, r5, #14
   176e2:	eb00 0084 	add.w	r0, r0, r4, lsl #2
   176e6:	3302      	adds	r3, #2
   176e8:	9009      	str	r0, [sp, #36]	; 0x24
   176ea:	b228      	sxth	r0, r5
   176ec:	9301      	str	r3, [sp, #4]
   176ee:	f8d9 600c 	ldr.w	r6, [r9, #12]
   176f2:	900a      	str	r0, [sp, #40]	; 0x28
        S[ 3 ] = silk_SMLAWB( S[ 3 ], out32_Q14[ 1 ], A1_U_Q28 );
        S[ 1 ] = silk_SMLAWB( S[ 1 ], B_Q28[ 2 ], in[ 2 * k + 0 ] );
        S[ 3 ] = silk_SMLAWB( S[ 3 ], B_Q28[ 2 ], in[ 2 * k + 1 ] );

        /* Scale back to Q0 and saturate */
        out[ 2 * k + 0 ] = (opus_int16)silk_SAT16( silk_RSHIFT( out32_Q14[ 0 ] + (1<<14) - 1, 14 ) );
   176f4:	f8cd b010 	str.w	fp, [sp, #16]
   176f8:	4614      	mov	r4, r2
   176fa:	9b00      	ldr	r3, [sp, #0]
   176fc:	e01f      	b.n	1773e <silk_biquad_alt_stride2_c+0x96>
   176fe:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   17702:	f2c0 80d3 	blt.w	178ac <silk_biquad_alt_stride2_c+0x204>
   17706:	b21b      	sxth	r3, r3
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT( out32_Q14[ 1 ] + (1<<14) - 1, 14 ) );
   17708:	9a05      	ldr	r2, [sp, #20]
        out[ 2 * k + 0 ] = (opus_int16)silk_SAT16( silk_RSHIFT( out32_Q14[ 0 ] + (1<<14) - 1, 14 ) );
   1770a:	9801      	ldr	r0, [sp, #4]
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT( out32_Q14[ 1 ] + (1<<14) - 1, 14 ) );
   1770c:	f502 527f 	add.w	r2, r2, #16320	; 0x3fc0
   17710:	323f      	adds	r2, #63	; 0x3f
   17712:	1392      	asrs	r2, r2, #14
   17714:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
        out[ 2 * k + 0 ] = (opus_int16)silk_SAT16( silk_RSHIFT( out32_Q14[ 0 ] + (1<<14) - 1, 14 ) );
   17718:	f820 3c02 	strh.w	r3, [r0, #-2]
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT( out32_Q14[ 1 ] + (1<<14) - 1, 14 ) );
   1771c:	f280 80c3 	bge.w	178a6 <silk_biquad_alt_stride2_c+0x1fe>
   17720:	f512 4f00 	cmn.w	r2, #32768	; 0x8000
   17724:	f2c0 80c4 	blt.w	178b0 <silk_biquad_alt_stride2_c+0x208>
   17728:	b212      	sxth	r2, r2
   1772a:	9b00      	ldr	r3, [sp, #0]
   1772c:	f820 2b04 	strh.w	r2, [r0], #4
    for( k = 0; k < len; k++ ) {
   17730:	9a09      	ldr	r2, [sp, #36]	; 0x24
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT( out32_Q14[ 1 ] + (1<<14) - 1, 14 ) );
   17732:	9001      	str	r0, [sp, #4]
   17734:	3304      	adds	r3, #4
    for( k = 0; k < len; k++ ) {
   17736:	429a      	cmp	r2, r3
   17738:	9300      	str	r3, [sp, #0]
   1773a:	f000 80bb 	beq.w	178b4 <silk_biquad_alt_stride2_c+0x20c>
        out32_Q14[ 0 ] = silk_LSHIFT( silk_SMLAWB( S[ 0 ], B_Q28[ 0 ], in[ 2 * k + 0 ] ), 2 );
   1773e:	680d      	ldr	r5, [r1, #0]
   17740:	f9b3 7000 	ldrsh.w	r7, [r3]
        out32_Q14[ 1 ] = silk_LSHIFT( silk_SMLAWB( S[ 2 ], B_Q28[ 0 ], in[ 2 * k + 1 ] ), 2 );
   17744:	f9b3 e002 	ldrsh.w	lr, [r3, #2]
        out32_Q14[ 0 ] = silk_LSHIFT( silk_SMLAWB( S[ 0 ], B_Q28[ 0 ], in[ 2 * k + 0 ] ), 2 );
   17748:	9803      	ldr	r0, [sp, #12]
   1774a:	142a      	asrs	r2, r5, #16
   1774c:	b2ad      	uxth	r5, r5
   1774e:	fb07 fc05 	mul.w	ip, r7, r5
   17752:	fb02 f307 	mul.w	r3, r2, r7
   17756:	eb03 432c 	add.w	r3, r3, ip, asr #16
   1775a:	4403      	add	r3, r0
   1775c:	0098      	lsls	r0, r3, #2
        out32_Q14[ 1 ] = silk_LSHIFT( silk_SMLAWB( S[ 2 ], B_Q28[ 0 ], in[ 2 * k + 1 ] ), 2 );
   1775e:	fb05 f50e 	mul.w	r5, r5, lr
   17762:	fb02 f20e 	mul.w	r2, r2, lr
        S[ 0 ] = S[ 1 ] + silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14[ 0 ], A0_L_Q28 ), 14 );
   17766:	9002      	str	r0, [sp, #8]
        out32_Q14[ 1 ] = silk_LSHIFT( silk_SMLAWB( S[ 2 ], B_Q28[ 0 ], in[ 2 * k + 1 ] ), 2 );
   17768:	eb02 4225 	add.w	r2, r2, r5, asr #16
        S[ 0 ] = S[ 1 ] + silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14[ 0 ], A0_L_Q28 ), 14 );
   1776c:	ea4f 4b20 	mov.w	fp, r0, asr #16
   17770:	f8bd a008 	ldrh.w	sl, [sp, #8]
   17774:	9807      	ldr	r0, [sp, #28]
        out32_Q14[ 1 ] = silk_LSHIFT( silk_SMLAWB( S[ 2 ], B_Q28[ 0 ], in[ 2 * k + 1 ] ), 2 );
   17776:	4422      	add	r2, r4
   17778:	0093      	lsls	r3, r2, #2
        S[ 2 ] = S[ 3 ] + silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14[ 1 ], A0_L_Q28 ), 14 );
   1777a:	141d      	asrs	r5, r3, #16
   1777c:	fa1f f883 	uxth.w	r8, r3
        S[ 0 ] = S[ 1 ] + silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14[ 0 ], A0_L_Q28 ), 14 );
   17780:	fb0a f200 	mul.w	r2, sl, r0
   17784:	fb0b f400 	mul.w	r4, fp, r0
        S[ 2 ] = S[ 3 ] + silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14[ 1 ], A0_L_Q28 ), 14 );
   17788:	fb05 fc00 	mul.w	ip, r5, r0
        S[ 0 ] = S[ 1 ] + silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14[ 0 ], A0_L_Q28 ), 14 );
   1778c:	eb04 4412 	add.w	r4, r4, r2, lsr #16
        S[ 2 ] = S[ 3 ] + silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14[ 1 ], A0_L_Q28 ), 14 );
   17790:	fb08 f200 	mul.w	r2, r8, r0
   17794:	eb0c 4212 	add.w	r2, ip, r2, lsr #16
        S[ 0 ] = S[ 1 ] + silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14[ 0 ], A0_L_Q28 ), 14 );
   17798:	9804      	ldr	r0, [sp, #16]
        out32_Q14[ 1 ] = silk_LSHIFT( silk_SMLAWB( S[ 2 ], B_Q28[ 0 ], in[ 2 * k + 1 ] ), 2 );
   1779a:	9305      	str	r3, [sp, #20]
        S[ 0 ] = S[ 1 ] + silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14[ 0 ], A0_L_Q28 ), 14 );
   1779c:	1364      	asrs	r4, r4, #13
        S[ 0 ] = silk_SMLAWB( S[ 0 ], out32_Q14[ 0 ], A0_U_Q28 );
   1779e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
        S[ 0 ] = S[ 1 ] + silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14[ 0 ], A0_L_Q28 ), 14 );
   177a0:	3401      	adds	r4, #1
        S[ 2 ] = S[ 3 ] + silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14[ 1 ], A0_L_Q28 ), 14 );
   177a2:	1352      	asrs	r2, r2, #13
        S[ 0 ] = silk_SMLAWB( S[ 0 ], out32_Q14[ 0 ], A0_U_Q28 );
   177a4:	fb03 fc0a 	mul.w	ip, r3, sl
        S[ 0 ] = S[ 1 ] + silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14[ 0 ], A0_L_Q28 ), 14 );
   177a8:	eb00 0064 	add.w	r0, r0, r4, asr #1
        S[ 2 ] = S[ 3 ] + silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14[ 1 ], A0_L_Q28 ), 14 );
   177ac:	3201      	adds	r2, #1
        S[ 0 ] = silk_SMLAWB( S[ 0 ], out32_Q14[ 0 ], A0_U_Q28 );
   177ae:	fb03 f40b 	mul.w	r4, r3, fp
   177b2:	eb04 4c2c 	add.w	ip, r4, ip, asr #16
        S[ 2 ] = S[ 3 ] + silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14[ 1 ], A0_L_Q28 ), 14 );
   177b6:	eb06 0262 	add.w	r2, r6, r2, asr #1
        S[ 2 ] = silk_SMLAWB( S[ 2 ], out32_Q14[ 1 ], A0_U_Q28 );
   177ba:	fb03 f408 	mul.w	r4, r3, r8
   177be:	fb03 f605 	mul.w	r6, r3, r5
   177c2:	eb06 4624 	add.w	r6, r6, r4, asr #16
   177c6:	1993      	adds	r3, r2, r6
        S[ 0 ] = silk_SMLAWB( S[ 0 ], out32_Q14[ 0 ], A0_U_Q28 );
   177c8:	4460      	add	r0, ip
   177ca:	f8c9 0000 	str.w	r0, [r9]
        S[ 2 ] = silk_SMLAWB( S[ 2 ], out32_Q14[ 1 ], A0_U_Q28 );
   177ce:	f8c9 3008 	str.w	r3, [r9, #8]
        S[ 0 ] = silk_SMLAWB( S[ 0 ], B_Q28[ 1 ], in[ 2 * k + 0 ] );
   177d2:	684e      	ldr	r6, [r1, #4]
        S[ 2 ] = silk_SMLAWB( S[ 2 ], out32_Q14[ 1 ], A0_U_Q28 );
   177d4:	9304      	str	r3, [sp, #16]
        S[ 0 ] = silk_SMLAWB( S[ 0 ], B_Q28[ 1 ], in[ 2 * k + 0 ] );
   177d6:	b2b4      	uxth	r4, r6
   177d8:	ea4f 4c26 	mov.w	ip, r6, asr #16
   177dc:	fb07 f404 	mul.w	r4, r7, r4
   177e0:	fb07 fc0c 	mul.w	ip, r7, ip
   177e4:	eb0c 4c24 	add.w	ip, ip, r4, asr #16
   177e8:	eb0c 0300 	add.w	r3, ip, r0
   177ec:	f8c9 3000 	str.w	r3, [r9]
   177f0:	9303      	str	r3, [sp, #12]
        S[ 1 ] = silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14[ 0 ], A1_L_Q28 ), 14 );
   177f2:	9b08      	ldr	r3, [sp, #32]
        S[ 2 ] = silk_SMLAWB( S[ 2 ], B_Q28[ 1 ], in[ 2 * k + 1 ] );
   177f4:	684c      	ldr	r4, [r1, #4]
        S[ 1 ] = silk_SMLAWB( S[ 1 ], out32_Q14[ 0 ], A1_U_Q28 );
   177f6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
        S[ 1 ] = silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14[ 0 ], A1_L_Q28 ), 14 );
   177f8:	fb0a f003 	mul.w	r0, sl, r3
   177fc:	fb0b fc03 	mul.w	ip, fp, r3
   17800:	eb0c 4c10 	add.w	ip, ip, r0, lsr #16
        S[ 3 ] = silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14[ 1 ], A1_L_Q28 ), 14 );
   17804:	fb08 f003 	mul.w	r0, r8, r3
        S[ 2 ] = silk_SMLAWB( S[ 2 ], B_Q28[ 1 ], in[ 2 * k + 1 ] );
   17808:	b2a6      	uxth	r6, r4
        S[ 3 ] = silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14[ 1 ], A1_L_Q28 ), 14 );
   1780a:	9006      	str	r0, [sp, #24]
        S[ 2 ] = silk_SMLAWB( S[ 2 ], B_Q28[ 1 ], in[ 2 * k + 1 ] );
   1780c:	1424      	asrs	r4, r4, #16
   1780e:	fb0e f606 	mul.w	r6, lr, r6
   17812:	fb0e f404 	mul.w	r4, lr, r4
        S[ 3 ] = silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14[ 1 ], A1_L_Q28 ), 14 );
   17816:	9806      	ldr	r0, [sp, #24]
        S[ 1 ] = silk_SMLAWB( S[ 1 ], out32_Q14[ 0 ], A1_U_Q28 );
   17818:	fb02 fa0a 	mul.w	sl, r2, sl
   1781c:	fb02 fb0b 	mul.w	fp, r2, fp
        S[ 2 ] = silk_SMLAWB( S[ 2 ], B_Q28[ 1 ], in[ 2 * k + 1 ] );
   17820:	eb04 4426 	add.w	r4, r4, r6, asr #16
        S[ 1 ] = silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14[ 0 ], A1_L_Q28 ), 14 );
   17824:	ea4f 3c6c 	mov.w	ip, ip, asr #13
        S[ 3 ] = silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14[ 1 ], A1_L_Q28 ), 14 );
   17828:	fb05 f603 	mul.w	r6, r5, r3
        S[ 2 ] = silk_SMLAWB( S[ 2 ], B_Q28[ 1 ], in[ 2 * k + 1 ] );
   1782c:	9b04      	ldr	r3, [sp, #16]
        S[ 3 ] = silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14[ 1 ], A1_L_Q28 ), 14 );
   1782e:	eb06 4610 	add.w	r6, r6, r0, lsr #16
        S[ 1 ] = silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14[ 0 ], A1_L_Q28 ), 14 );
   17832:	f10c 0c01 	add.w	ip, ip, #1
        S[ 1 ] = silk_SMLAWB( S[ 1 ], out32_Q14[ 0 ], A1_U_Q28 );
   17836:	eb0b 4a2a 	add.w	sl, fp, sl, asr #16
        S[ 3 ] = silk_SMLAWB( S[ 3 ], out32_Q14[ 1 ], A1_U_Q28 );
   1783a:	fb02 f505 	mul.w	r5, r2, r5
   1783e:	fb02 f808 	mul.w	r8, r2, r8
        S[ 2 ] = silk_SMLAWB( S[ 2 ], B_Q28[ 1 ], in[ 2 * k + 1 ] );
   17842:	441c      	add	r4, r3
        S[ 1 ] = silk_SMLAWB( S[ 1 ], out32_Q14[ 0 ], A1_U_Q28 );
   17844:	eb0a 006c 	add.w	r0, sl, ip, asr #1
        S[ 3 ] = silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14[ 1 ], A1_L_Q28 ), 14 );
   17848:	1376      	asrs	r6, r6, #13
        S[ 1 ] = silk_SMLAWB( S[ 1 ], out32_Q14[ 0 ], A1_U_Q28 );
   1784a:	e9c9 0401 	strd	r0, r4, [r9, #4]
        S[ 3 ] = silk_SMLAWB( S[ 3 ], out32_Q14[ 1 ], A1_U_Q28 );
   1784e:	eb05 4828 	add.w	r8, r5, r8, asr #16
        S[ 3 ] = silk_RSHIFT_ROUND( silk_SMULWB( out32_Q14[ 1 ], A1_L_Q28 ), 14 );
   17852:	3601      	adds	r6, #1
        S[ 3 ] = silk_SMLAWB( S[ 3 ], out32_Q14[ 1 ], A1_U_Q28 );
   17854:	eb08 0666 	add.w	r6, r8, r6, asr #1
   17858:	f8c9 600c 	str.w	r6, [r9, #12]
        S[ 1 ] = silk_SMLAWB( S[ 1 ], B_Q28[ 2 ], in[ 2 * k + 0 ] );
   1785c:	688a      	ldr	r2, [r1, #8]
   1785e:	b295      	uxth	r5, r2
   17860:	1412      	asrs	r2, r2, #16
   17862:	fb07 f505 	mul.w	r5, r7, r5
   17866:	fb07 f702 	mul.w	r7, r7, r2
   1786a:	eb07 4725 	add.w	r7, r7, r5, asr #16
   1786e:	19c3      	adds	r3, r0, r7
   17870:	f8c9 3004 	str.w	r3, [r9, #4]
        S[ 3 ] = silk_SMLAWB( S[ 3 ], B_Q28[ 2 ], in[ 2 * k + 1 ] );
   17874:	688d      	ldr	r5, [r1, #8]
        S[ 1 ] = silk_SMLAWB( S[ 1 ], B_Q28[ 2 ], in[ 2 * k + 0 ] );
   17876:	9304      	str	r3, [sp, #16]
        out[ 2 * k + 0 ] = (opus_int16)silk_SAT16( silk_RSHIFT( out32_Q14[ 0 ] + (1<<14) - 1, 14 ) );
   17878:	9b02      	ldr	r3, [sp, #8]
        S[ 3 ] = silk_SMLAWB( S[ 3 ], B_Q28[ 2 ], in[ 2 * k + 1 ] );
   1787a:	b2aa      	uxth	r2, r5
        out[ 2 * k + 0 ] = (opus_int16)silk_SAT16( silk_RSHIFT( out32_Q14[ 0 ] + (1<<14) - 1, 14 ) );
   1787c:	f503 537f 	add.w	r3, r3, #16320	; 0x3fc0
        S[ 3 ] = silk_SMLAWB( S[ 3 ], B_Q28[ 2 ], in[ 2 * k + 1 ] );
   17880:	142d      	asrs	r5, r5, #16
   17882:	fb0e f202 	mul.w	r2, lr, r2
        out[ 2 * k + 0 ] = (opus_int16)silk_SAT16( silk_RSHIFT( out32_Q14[ 0 ] + (1<<14) - 1, 14 ) );
   17886:	333f      	adds	r3, #63	; 0x3f
        S[ 3 ] = silk_SMLAWB( S[ 3 ], B_Q28[ 2 ], in[ 2 * k + 1 ] );
   17888:	fb0e fe05 	mul.w	lr, lr, r5
   1788c:	eb0e 4e22 	add.w	lr, lr, r2, asr #16
        out[ 2 * k + 0 ] = (opus_int16)silk_SAT16( silk_RSHIFT( out32_Q14[ 0 ] + (1<<14) - 1, 14 ) );
   17890:	139b      	asrs	r3, r3, #14
        S[ 3 ] = silk_SMLAWB( S[ 3 ], B_Q28[ 2 ], in[ 2 * k + 1 ] );
   17892:	4476      	add	r6, lr
        out[ 2 * k + 0 ] = (opus_int16)silk_SAT16( silk_RSHIFT( out32_Q14[ 0 ] + (1<<14) - 1, 14 ) );
   17894:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
        S[ 3 ] = silk_SMLAWB( S[ 3 ], B_Q28[ 2 ], in[ 2 * k + 1 ] );
   17898:	f8c9 600c 	str.w	r6, [r9, #12]
        out[ 2 * k + 0 ] = (opus_int16)silk_SAT16( silk_RSHIFT( out32_Q14[ 0 ] + (1<<14) - 1, 14 ) );
   1789c:	f6ff af2f 	blt.w	176fe <silk_biquad_alt_stride2_c+0x56>
   178a0:	f647 73ff 	movw	r3, #32767	; 0x7fff
   178a4:	e730      	b.n	17708 <silk_biquad_alt_stride2_c+0x60>
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT( out32_Q14[ 1 ] + (1<<14) - 1, 14 ) );
   178a6:	f647 72ff 	movw	r2, #32767	; 0x7fff
   178aa:	e73e      	b.n	1772a <silk_biquad_alt_stride2_c+0x82>
        out[ 2 * k + 0 ] = (opus_int16)silk_SAT16( silk_RSHIFT( out32_Q14[ 0 ] + (1<<14) - 1, 14 ) );
   178ac:	4b03      	ldr	r3, [pc, #12]	; (178bc <silk_biquad_alt_stride2_c+0x214>)
   178ae:	e72b      	b.n	17708 <silk_biquad_alt_stride2_c+0x60>
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT( out32_Q14[ 1 ] + (1<<14) - 1, 14 ) );
   178b0:	4a02      	ldr	r2, [pc, #8]	; (178bc <silk_biquad_alt_stride2_c+0x214>)
   178b2:	e73a      	b.n	1772a <silk_biquad_alt_stride2_c+0x82>
    }
}
   178b4:	b00d      	add	sp, #52	; 0x34
   178b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   178ba:	bf00      	nop
   178bc:	ffff8000 	.word	0xffff8000

000178c0 <silk_bwexpander_32>:
)
{
    opus_int   i;
    opus_int32 chirp_minus_one_Q16 = chirp_Q16 - 65536;

    for( i = 0; i < d - 1; i++ ) {
   178c0:	2901      	cmp	r1, #1
{
   178c2:	b5f0      	push	{r4, r5, r6, r7, lr}
    for( i = 0; i < d - 1; i++ ) {
   178c4:	dd23      	ble.n	1790e <silk_bwexpander_32+0x4e>
   178c6:	f1a0 0608 	sub.w	r6, r0, #8
   178ca:	f5a2 3780 	sub.w	r7, r2, #65536	; 0x10000
   178ce:	eb06 0681 	add.w	r6, r6, r1, lsl #2
   178d2:	1f05      	subs	r5, r0, #4
        ar[ i ]    = silk_SMULWW( chirp_Q16, ar[ i ] );
   178d4:	f855 3f04 	ldr.w	r3, [r5, #4]!
   178d8:	ea4f 4c22 	mov.w	ip, r2, asr #16
   178dc:	b21c      	sxth	r4, r3
   178de:	fa1f fe82 	uxth.w	lr, r2
   178e2:	13db      	asrs	r3, r3, #15
   178e4:	fb04 fe0e 	mul.w	lr, r4, lr
   178e8:	3301      	adds	r3, #1
   178ea:	fb04 f40c 	mul.w	r4, r4, ip
        chirp_Q16 += silk_RSHIFT_ROUND( silk_MUL( chirp_Q16, chirp_minus_one_Q16 ), 16 );
   178ee:	fb02 fc07 	mul.w	ip, r2, r7
        ar[ i ]    = silk_SMULWW( chirp_Q16, ar[ i ] );
   178f2:	eb04 442e 	add.w	r4, r4, lr, asr #16
   178f6:	105b      	asrs	r3, r3, #1
        chirp_Q16 += silk_RSHIFT_ROUND( silk_MUL( chirp_Q16, chirp_minus_one_Q16 ), 16 );
   178f8:	ea4f 3cec 	mov.w	ip, ip, asr #15
        ar[ i ]    = silk_SMULWW( chirp_Q16, ar[ i ] );
   178fc:	fb02 4303 	mla	r3, r2, r3, r4
    for( i = 0; i < d - 1; i++ ) {
   17900:	42ae      	cmp	r6, r5
        chirp_Q16 += silk_RSHIFT_ROUND( silk_MUL( chirp_Q16, chirp_minus_one_Q16 ), 16 );
   17902:	f10c 0401 	add.w	r4, ip, #1
        ar[ i ]    = silk_SMULWW( chirp_Q16, ar[ i ] );
   17906:	602b      	str	r3, [r5, #0]
        chirp_Q16 += silk_RSHIFT_ROUND( silk_MUL( chirp_Q16, chirp_minus_one_Q16 ), 16 );
   17908:	eb02 0264 	add.w	r2, r2, r4, asr #1
    for( i = 0; i < d - 1; i++ ) {
   1790c:	d1e2      	bne.n	178d4 <silk_bwexpander_32+0x14>
    }
    ar[ d - 1 ] = silk_SMULWW( chirp_Q16, ar[ d - 1 ] );
   1790e:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
   17912:	3901      	subs	r1, #1
   17914:	b295      	uxth	r5, r2
   17916:	f850 3021 	ldr.w	r3, [r0, r1, lsl #2]
   1791a:	1416      	asrs	r6, r2, #16
   1791c:	b21c      	sxth	r4, r3
   1791e:	13db      	asrs	r3, r3, #15
   17920:	fb04 f505 	mul.w	r5, r4, r5
   17924:	3301      	adds	r3, #1
   17926:	fb04 f406 	mul.w	r4, r4, r6
   1792a:	105b      	asrs	r3, r3, #1
   1792c:	eb04 4425 	add.w	r4, r4, r5, asr #16
   17930:	fb02 4203 	mla	r2, r2, r3, r4
   17934:	f840 2021 	str.w	r2, [r0, r1, lsl #2]
}
   17938:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1793a:	bf00      	nop

0001793c <silk_bwexpander>:
    opus_int   i;
    opus_int32 chirp_minus_one_Q16 = chirp_Q16 - 65536;

    /* NB: Dont use silk_SMULWB, instead of silk_RSHIFT_ROUND( silk_MUL(), 16 ), below.  */
    /* Bias in silk_SMULWB can lead to unstable filters                                */
    for( i = 0; i < d - 1; i++ ) {
   1793c:	2901      	cmp	r1, #1
{
   1793e:	b4f0      	push	{r4, r5, r6, r7}
    for( i = 0; i < d - 1; i++ ) {
   17940:	dd15      	ble.n	1796e <silk_bwexpander+0x32>
   17942:	1f06      	subs	r6, r0, #4
   17944:	f5a2 3780 	sub.w	r7, r2, #65536	; 0x10000
   17948:	eb06 0641 	add.w	r6, r6, r1, lsl #1
   1794c:	1e85      	subs	r5, r0, #2
        ar[ i ]    = (opus_int16)silk_RSHIFT_ROUND( silk_MUL( chirp_Q16, ar[ i ]             ), 16 );
   1794e:	f935 3f02 	ldrsh.w	r3, [r5, #2]!
   17952:	fb02 f303 	mul.w	r3, r2, r3
        chirp_Q16 +=             silk_RSHIFT_ROUND( silk_MUL( chirp_Q16, chirp_minus_one_Q16 ), 16 );
   17956:	fb02 f407 	mul.w	r4, r2, r7
        ar[ i ]    = (opus_int16)silk_RSHIFT_ROUND( silk_MUL( chirp_Q16, ar[ i ]             ), 16 );
   1795a:	13db      	asrs	r3, r3, #15
   1795c:	3301      	adds	r3, #1
        chirp_Q16 +=             silk_RSHIFT_ROUND( silk_MUL( chirp_Q16, chirp_minus_one_Q16 ), 16 );
   1795e:	13e4      	asrs	r4, r4, #15
        ar[ i ]    = (opus_int16)silk_RSHIFT_ROUND( silk_MUL( chirp_Q16, ar[ i ]             ), 16 );
   17960:	105b      	asrs	r3, r3, #1
        chirp_Q16 +=             silk_RSHIFT_ROUND( silk_MUL( chirp_Q16, chirp_minus_one_Q16 ), 16 );
   17962:	3401      	adds	r4, #1
    for( i = 0; i < d - 1; i++ ) {
   17964:	42ae      	cmp	r6, r5
        ar[ i ]    = (opus_int16)silk_RSHIFT_ROUND( silk_MUL( chirp_Q16, ar[ i ]             ), 16 );
   17966:	802b      	strh	r3, [r5, #0]
        chirp_Q16 +=             silk_RSHIFT_ROUND( silk_MUL( chirp_Q16, chirp_minus_one_Q16 ), 16 );
   17968:	eb02 0264 	add.w	r2, r2, r4, asr #1
    for( i = 0; i < d - 1; i++ ) {
   1796c:	d1ef      	bne.n	1794e <silk_bwexpander+0x12>
    }
    ar[ d - 1 ] = (opus_int16)silk_RSHIFT_ROUND( silk_MUL( chirp_Q16, ar[ d - 1 ] ), 16 );
   1796e:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
   17972:	3901      	subs	r1, #1
}
   17974:	bcf0      	pop	{r4, r5, r6, r7}
    ar[ d - 1 ] = (opus_int16)silk_RSHIFT_ROUND( silk_MUL( chirp_Q16, ar[ d - 1 ] ), 16 );
   17976:	f930 3011 	ldrsh.w	r3, [r0, r1, lsl #1]
   1797a:	fb02 f303 	mul.w	r3, r2, r3
   1797e:	13db      	asrs	r3, r3, #15
   17980:	3301      	adds	r3, #1
   17982:	105b      	asrs	r3, r3, #1
   17984:	f820 3011 	strh.w	r3, [r0, r1, lsl #1]
}
   17988:	4770      	bx	lr
   1798a:	bf00      	nop

0001798c <silk_inner_prod_aligned_scale>:
    const opus_int              len                 /*    I vector lengths                                              */
)
{
    opus_int   i;
    opus_int32 sum = 0;
    for( i = 0; i < len; i++ ) {
   1798c:	2b00      	cmp	r3, #0
   1798e:	dd11      	ble.n	179b4 <silk_inner_prod_aligned_scale+0x28>
{
   17990:	b470      	push	{r4, r5, r6}
   17992:	1e85      	subs	r5, r0, #2
   17994:	eb05 0343 	add.w	r3, r5, r3, lsl #1
   17998:	3902      	subs	r1, #2
    opus_int32 sum = 0;
   1799a:	2000      	movs	r0, #0
        sum = silk_ADD_RSHIFT32( sum, silk_SMULBB( inVec1[ i ], inVec2[ i ] ), scale );
   1799c:	f835 4f02 	ldrh.w	r4, [r5, #2]!
   179a0:	f831 6f02 	ldrh.w	r6, [r1, #2]!
   179a4:	fb14 f406 	smulbb	r4, r4, r6
   179a8:	4114      	asrs	r4, r2
    for( i = 0; i < len; i++ ) {
   179aa:	42ab      	cmp	r3, r5
        sum = silk_ADD_RSHIFT32( sum, silk_SMULBB( inVec1[ i ], inVec2[ i ] ), scale );
   179ac:	4420      	add	r0, r4
    for( i = 0; i < len; i++ ) {
   179ae:	d1f5      	bne.n	1799c <silk_inner_prod_aligned_scale+0x10>
    }
    return sum;
}
   179b0:	bc70      	pop	{r4, r5, r6}
   179b2:	4770      	bx	lr
    opus_int32 sum = 0;
   179b4:	2000      	movs	r0, #0
}
   179b6:	4770      	bx	lr

000179b8 <silk_lin2log>:
   179b8:	b1c8      	cbz	r0, 179ee <silk_lin2log+0x36>
   179ba:	fab0 f380 	clz	r3, r0
/* Approximation of 128 * log2() (very close inverse of silk_log2lin()) */
/* Convert input to a log scale    */
opus_int32 silk_lin2log(
    const opus_int32            inLin               /* I  input in linear scale                                         */
)
{
   179be:	b410      	push	{r4}
   179c0:	f1c3 041f 	rsb	r4, r3, #31
    * frac_Q7 = silk_ROR32(in, 24 - lzeros) & 0x7f;
   179c4:	f1c3 0318 	rsb	r3, r3, #24
    if( rot == 0 ) {
   179c8:	2b00      	cmp	r3, #0
   179ca:	ea4f 14c4 	mov.w	r4, r4, lsl #7
   179ce:	d111      	bne.n	179f4 <silk_lin2log+0x3c>
   179d0:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   179d4:	f1c0 0380 	rsb	r3, r0, #128	; 0x80
   179d8:	fb00 f203 	mul.w	r2, r0, r3
   179dc:	23b3      	movs	r3, #179	; 0xb3
   179de:	fb03 f302 	mul.w	r3, r3, r2
   179e2:	eb00 4023 	add.w	r0, r0, r3, asr #16
   179e6:	4420      	add	r0, r4

    silk_CLZ_FRAC( inLin, &lz, &frac_Q7 );

    /* Piece-wise parabolic approximation */
    return silk_ADD_LSHIFT32( silk_SMLAWB( frac_Q7, silk_MUL( frac_Q7, 128 - frac_Q7 ), 179 ), 31 - lz, 7 );
}
   179e8:	f85d 4b04 	ldr.w	r4, [sp], #4
   179ec:	4770      	bx	lr
   179ee:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   179f2:	4770      	bx	lr
    } else if( rot < 0 ) {
   179f4:	db10      	blt.n	17a18 <silk_lin2log+0x60>
        return (opus_int32) ((x << (32 - r)) | (x >> r));
   179f6:	fa60 f303 	ror.w	r3, r0, r3
   179fa:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   179fe:	f1c3 0080 	rsb	r0, r3, #128	; 0x80
   17a02:	fb03 f200 	mul.w	r2, r3, r0
   17a06:	20b3      	movs	r0, #179	; 0xb3
   17a08:	fb00 f002 	mul.w	r0, r0, r2
   17a0c:	eb03 4320 	add.w	r3, r3, r0, asr #16
   17a10:	1918      	adds	r0, r3, r4
   17a12:	f85d 4b04 	ldr.w	r4, [sp], #4
   17a16:	4770      	bx	lr
   17a18:	3320      	adds	r3, #32
   17a1a:	fa60 f103 	ror.w	r1, r0, r3
   17a1e:	f001 027f 	and.w	r2, r1, #127	; 0x7f
   17a22:	f1c2 0380 	rsb	r3, r2, #128	; 0x80
   17a26:	fb02 f103 	mul.w	r1, r2, r3
   17a2a:	23b3      	movs	r3, #179	; 0xb3
   17a2c:	fb03 f301 	mul.w	r3, r3, r1
   17a30:	eb02 4223 	add.w	r2, r2, r3, asr #16
   17a34:	1910      	adds	r0, r2, r4
   17a36:	e7d7      	b.n	179e8 <silk_lin2log+0x30>

00017a38 <silk_log2lin>:
    const opus_int32            inLog_Q7            /* I  input on log scale                                            */
)
{
    opus_int32 out, frac_Q7;

    if( inLog_Q7 < 0 ) {
   17a38:	2800      	cmp	r0, #0
   17a3a:	db24      	blt.n	17a86 <silk_log2lin+0x4e>
        return 0;
    } else if ( inLog_Q7 >= 3967 ) {
   17a3c:	f640 737e 	movw	r3, #3966	; 0xf7e
   17a40:	4298      	cmp	r0, r3
   17a42:	dc1d      	bgt.n	17a80 <silk_log2lin+0x48>
        return silk_int32_MAX;
    }

    out = silk_LSHIFT( 1, silk_RSHIFT( inLog_Q7, 7 ) );
    frac_Q7 = inLog_Q7 & 0x7F;
   17a44:	f000 027f 	and.w	r2, r0, #127	; 0x7f
   17a48:	f1c2 0380 	rsb	r3, r2, #128	; 0x80
   17a4c:	b29b      	uxth	r3, r3
   17a4e:	fb02 f303 	mul.w	r3, r2, r3
   17a52:	f06f 01ad 	mvn.w	r1, #173	; 0xad
{
   17a56:	b410      	push	{r4}
   17a58:	fb01 f103 	mul.w	r1, r1, r3
    out = silk_LSHIFT( 1, silk_RSHIFT( inLog_Q7, 7 ) );
   17a5c:	11c4      	asrs	r4, r0, #7
   17a5e:	2301      	movs	r3, #1
   17a60:	40a3      	lsls	r3, r4
    if( inLog_Q7 < 2048 ) {
   17a62:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
   17a66:	eb02 4221 	add.w	r2, r2, r1, asr #16
        /* Piece-wise parabolic approximation */
        out = silk_ADD_RSHIFT32( out, silk_MUL( out, silk_SMLAWB( frac_Q7, silk_SMULBB( frac_Q7, 128 - frac_Q7 ), -174 ) ), 7 );
   17a6a:	bfb5      	itete	lt
   17a6c:	fa02 f004 	lsllt.w	r0, r2, r4
    } else {
        /* Piece-wise parabolic approximation */
        out = silk_MLA( out, silk_RSHIFT( out, 7 ), silk_SMLAWB( frac_Q7, silk_SMULBB( frac_Q7, 128 - frac_Q7 ), -174 ) );
   17a70:	11d8      	asrge	r0, r3, #7
        out = silk_ADD_RSHIFT32( out, silk_MUL( out, silk_SMLAWB( frac_Q7, silk_SMULBB( frac_Q7, 128 - frac_Q7 ), -174 ) ), 7 );
   17a72:	eb03 10e0 	addlt.w	r0, r3, r0, asr #7
        out = silk_MLA( out, silk_RSHIFT( out, 7 ), silk_SMLAWB( frac_Q7, silk_SMULBB( frac_Q7, 128 - frac_Q7 ), -174 ) );
   17a76:	fb02 3000 	mlage	r0, r2, r0, r3
    }
    return out;
}
   17a7a:	f85d 4b04 	ldr.w	r4, [sp], #4
   17a7e:	4770      	bx	lr
        return silk_int32_MAX;
   17a80:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
}
   17a84:	4770      	bx	lr
        return 0;
   17a86:	2000      	movs	r0, #0
   17a88:	4770      	bx	lr
   17a8a:	bf00      	nop

00017a8c <silk_LPC_analysis_filter>:
    const opus_int16            *B,                 /* I    MA prediction coefficients, Q12 [order]                     */
    const opus_int32            len,                /* I    Signal length                                               */
    const opus_int32            d,                  /* I    Filter order                                                */
    int                         arch                /* I    Run-time architecture                                       */
)
{
   17a8c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   17a90:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
    for ( j = 0; j < d; j++ ) {
        out[ j ] = 0;
    }
#else
    (void)arch;
    for( ix = d; ix < len; ix++ ) {
   17a94:	4598      	cmp	r8, r3
   17a96:	da5b      	bge.n	17b50 <silk_LPC_analysis_filter+0xc4>
   17a98:	f108 4900 	add.w	r9, r8, #2147483648	; 0x80000000
   17a9c:	f1a8 0b07 	sub.w	fp, r8, #7
   17aa0:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
   17aa4:	ea4f 0949 	mov.w	r9, r9, lsl #1
   17aa8:	ea4f 045b 	mov.w	r4, fp, lsr #1
   17aac:	f1a1 0a02 	sub.w	sl, r1, #2
   17ab0:	f06f 0b03 	mvn.w	fp, #3
   17ab4:	eb01 0c09 	add.w	ip, r1, r9
   17ab8:	eb0a 0a43 	add.w	sl, sl, r3, lsl #1
   17abc:	4481      	add	r9, r0
   17abe:	ebab 0b84 	sub.w	fp, fp, r4, lsl #2
        in_ptr = &in[ ix - 1 ];

        out32_Q12 = silk_SMULBB( in_ptr[  0 ], B[ 0 ] );
   17ac2:	8815      	ldrh	r5, [r2, #0]
   17ac4:	f8bc 1000 	ldrh.w	r1, [ip]
        /* Allowing wrap around so that two wraps can cancel each other. The rare
           cases where the result wraps around can only be triggered by invalid streams*/
        out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -1 ], B[ 1 ] );
   17ac8:	8854      	ldrh	r4, [r2, #2]
   17aca:	f83c 3c02 	ldrh.w	r3, [ip, #-2]
        out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -2 ], B[ 2 ] );
   17ace:	f83c 6c04 	ldrh.w	r6, [ip, #-4]
        out32_Q12 = silk_SMULBB( in_ptr[  0 ], B[ 0 ] );
   17ad2:	fb11 f105 	smulbb	r1, r1, r5
        out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -2 ], B[ 2 ] );
   17ad6:	8895      	ldrh	r5, [r2, #4]
        out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -1 ], B[ 1 ] );
   17ad8:	fb13 1304 	smlabb	r3, r3, r4, r1
        out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -3 ], B[ 3 ] );
   17adc:	88d4      	ldrh	r4, [r2, #6]
   17ade:	f83c 1c06 	ldrh.w	r1, [ip, #-6]
        out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -2 ], B[ 2 ] );
   17ae2:	fb16 3605 	smlabb	r6, r6, r5, r3
        out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -4 ], B[ 4 ] );
   17ae6:	f83c 3c08 	ldrh.w	r3, [ip, #-8]
   17aea:	8915      	ldrh	r5, [r2, #8]
        out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -3 ], B[ 3 ] );
   17aec:	fb11 6104 	smlabb	r1, r1, r4, r6
        out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -5 ], B[ 5 ] );
   17af0:	f83c 6c0a 	ldrh.w	r6, [ip, #-10]
   17af4:	8954      	ldrh	r4, [r2, #10]
        out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -4 ], B[ 4 ] );
   17af6:	fb13 1305 	smlabb	r3, r3, r5, r1
        for( j = 6; j < d; j += 2 ) {
   17afa:	f1b8 0f06 	cmp.w	r8, #6
        out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -5 ], B[ 5 ] );
   17afe:	fb16 3604 	smlabb	r6, r6, r4, r3
        for( j = 6; j < d; j += 2 ) {
   17b02:	dd13      	ble.n	17b2c <silk_LPC_analysis_filter+0xa0>
   17b04:	4617      	mov	r7, r2
   17b06:	eb0b 0e0c 	add.w	lr, fp, ip
   17b0a:	4665      	mov	r5, ip
            out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -j     ], B[ j     ] );
            out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -j - 1 ], B[ j + 1 ] );
   17b0c:	f835 1c0e 	ldrh.w	r1, [r5, #-14]
   17b10:	89fc      	ldrh	r4, [r7, #14]
   17b12:	f835 3c0c 	ldrh.w	r3, [r5, #-12]
   17b16:	fb11 f104 	smulbb	r1, r1, r4
   17b1a:	89bc      	ldrh	r4, [r7, #12]
   17b1c:	3d04      	subs	r5, #4
   17b1e:	fb13 1304 	smlabb	r3, r3, r4, r1
        for( j = 6; j < d; j += 2 ) {
   17b22:	45ae      	cmp	lr, r5
            out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -j - 1 ], B[ j + 1 ] );
   17b24:	441e      	add	r6, r3
   17b26:	f107 0704 	add.w	r7, r7, #4
        for( j = 6; j < d; j += 2 ) {
   17b2a:	d1ef      	bne.n	17b0c <silk_LPC_analysis_filter+0x80>
        }

        /* Subtract prediction */
        out32_Q12 = silk_SUB32_ovflw( silk_LSHIFT( (opus_int32)in_ptr[ 1 ], 12 ), out32_Q12 );
   17b2c:	f93c 3f02 	ldrsh.w	r3, [ip, #2]!
   17b30:	ebc6 3303 	rsb	r3, r6, r3, lsl #12

        /* Scale to Q0 */
        out32 = silk_RSHIFT_ROUND( out32_Q12, 12 );
   17b34:	12db      	asrs	r3, r3, #11
   17b36:	3301      	adds	r3, #1
   17b38:	105b      	asrs	r3, r3, #1

        /* Saturate output */
        out[ ix ] = (opus_int16)silk_SAT16( out32 );
   17b3a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   17b3e:	da0e      	bge.n	17b5e <silk_LPC_analysis_filter+0xd2>
   17b40:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   17b44:	db0e      	blt.n	17b64 <silk_LPC_analysis_filter+0xd8>
   17b46:	b21b      	sxth	r3, r3
    for( ix = d; ix < len; ix++ ) {
   17b48:	45e2      	cmp	sl, ip
        out[ ix ] = (opus_int16)silk_SAT16( out32 );
   17b4a:	f829 3f02 	strh.w	r3, [r9, #2]!
    for( ix = d; ix < len; ix++ ) {
   17b4e:	d1b8      	bne.n	17ac2 <silk_LPC_analysis_filter+0x36>
    }

    /* Set first d output samples to zero */
    silk_memset( out, 0, d * sizeof( opus_int16 ) );
   17b50:	ea4f 0248 	mov.w	r2, r8, lsl #1
   17b54:	2100      	movs	r1, #0
#endif
}
   17b56:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    silk_memset( out, 0, d * sizeof( opus_int16 ) );
   17b5a:	f01d bb03 	b.w	35164 <memset>
        out[ ix ] = (opus_int16)silk_SAT16( out32 );
   17b5e:	f647 73ff 	movw	r3, #32767	; 0x7fff
   17b62:	e7f1      	b.n	17b48 <silk_LPC_analysis_filter+0xbc>
   17b64:	4b00      	ldr	r3, [pc, #0]	; (17b68 <silk_LPC_analysis_filter+0xdc>)
   17b66:	e7ef      	b.n	17b48 <silk_LPC_analysis_filter+0xbc>
   17b68:	ffff8000 	.word	0xffff8000

00017b6c <silk_LPC_inverse_pred_gain_c>:
/* For input in Q12 domain */
opus_int32 silk_LPC_inverse_pred_gain_c(            /* O   Returns inverse prediction gain in energy domain, Q30        */
    const opus_int16            *A_Q12,             /* I   Prediction coefficients, Q12 [order]                         */
    const opus_int              order               /* I   Prediction order                                             */
)
{
   17b6c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    opus_int   k;
    opus_int32 Atmp_QA[ SILK_MAX_ORDER_LPC ];
    opus_int32 DC_resp = 0;

    /* Increase Q domain of the AR coefficients */
    for( k = 0; k < order; k++ ) {
   17b70:	2900      	cmp	r1, #0
{
   17b72:	b0b3      	sub	sp, #204	; 0xcc
    for( k = 0; k < order; k++ ) {
   17b74:	dd13      	ble.n	17b9e <silk_LPC_inverse_pred_gain_c+0x32>
   17b76:	3802      	subs	r0, #2
   17b78:	eb00 0641 	add.w	r6, r0, r1, lsl #1
   17b7c:	ac1a      	add	r4, sp, #104	; 0x68
    opus_int32 DC_resp = 0;
   17b7e:	2200      	movs	r2, #0
        DC_resp += (opus_int32)A_Q12[ k ];
   17b80:	f930 3f02 	ldrsh.w	r3, [r0, #2]!
        Atmp_QA[ k ] = silk_LSHIFT32( (opus_int32)A_Q12[ k ], QA - 12 );
   17b84:	031d      	lsls	r5, r3, #12
    for( k = 0; k < order; k++ ) {
   17b86:	4286      	cmp	r6, r0
        DC_resp += (opus_int32)A_Q12[ k ];
   17b88:	441a      	add	r2, r3
        Atmp_QA[ k ] = silk_LSHIFT32( (opus_int32)A_Q12[ k ], QA - 12 );
   17b8a:	f844 5b04 	str.w	r5, [r4], #4
    for( k = 0; k < order; k++ ) {
   17b8e:	d1f7      	bne.n	17b80 <silk_LPC_inverse_pred_gain_c+0x14>
    }
    /* If the DC is unstable, we don't even need to do the full calculations */
    if( DC_resp >= 4096 ) {
   17b90:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
   17b94:	db03      	blt.n	17b9e <silk_LPC_inverse_pred_gain_c+0x32>
        return 0;
   17b96:	2000      	movs	r0, #0
        return 0;
    }
    return LPC_inverse_pred_gain_QA_c( Atmp_QA, order );
}
   17b98:	b033      	add	sp, #204	; 0xcc
   17b9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    for( k = order - 1; k > 0; k-- ) {
   17b9e:	1e4a      	subs	r2, r1, #1
   17ba0:	ab32      	add	r3, sp, #200	; 0xc8
   17ba2:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   17ba6:	48cc      	ldr	r0, [pc, #816]	; (17ed8 <silk_LPC_inverse_pred_gain_c+0x36c>)
   17ba8:	f853 6c60 	ldr.w	r6, [r3, #-96]
   17bac:	2a00      	cmp	r2, #0
   17bae:	eb06 0300 	add.w	r3, r6, r0
   17bb2:	f340 820b 	ble.w	17fcc <silk_LPC_inverse_pred_gain_c+0x460>
        if( ( A_QA[ k ] > A_LIMIT ) || ( A_QA[ k ] < -A_LIMIT ) ) {
   17bb6:	4ac9      	ldr	r2, [pc, #804]	; (17edc <silk_LPC_inverse_pred_gain_c+0x370>)
   17bb8:	4293      	cmp	r3, r2
   17bba:	d8ec      	bhi.n	17b96 <silk_LPC_inverse_pred_gain_c+0x2a>
        rc_Q31 = -silk_LSHIFT( A_QA[ k ], 31 - QA );
   17bbc:	01f6      	lsls	r6, r6, #7
   17bbe:	4276      	negs	r6, r6
        rc_mult1_Q30 = silk_SUB32( SILK_FIX_CONST( 1, 30 ), silk_SMMUL( rc_Q31, rc_Q31 ) );
   17bc0:	fb86 4506 	smull	r4, r5, r6, r6
   17bc4:	f1c5 4380 	rsb	r3, r5, #1073741824	; 0x40000000
        if( invGain_Q30 < SILK_FIX_CONST( 1.0f / MAX_PREDICTION_POWER_GAIN, 30 ) ) {
   17bc8:	4cc5      	ldr	r4, [pc, #788]	; (17ee0 <silk_LPC_inverse_pred_gain_c+0x374>)
        invGain_Q30 = silk_LSHIFT( silk_SMMUL( invGain_Q30, rc_mult1_Q30 ), 2 );
   17bca:	f023 0503 	bic.w	r5, r3, #3
        if( invGain_Q30 < SILK_FIX_CONST( 1.0f / MAX_PREDICTION_POWER_GAIN, 30 ) ) {
   17bce:	42a5      	cmp	r5, r4
        invGain_Q30 = silk_LSHIFT( silk_SMMUL( invGain_Q30, rc_mult1_Q30 ), 2 );
   17bd0:	9516      	str	r5, [sp, #88]	; 0x58
        rc_mult1_Q30 = silk_SUB32( SILK_FIX_CONST( 1, 30 ), silk_SMMUL( rc_Q31, rc_Q31 ) );
   17bd2:	46b2      	mov	sl, r6
   17bd4:	ea4f 7be6 	mov.w	fp, r6, asr #31
        if( invGain_Q30 < SILK_FIX_CONST( 1.0f / MAX_PREDICTION_POWER_GAIN, 30 ) ) {
   17bd8:	dddd      	ble.n	17b96 <silk_LPC_inverse_pred_gain_c+0x2a>
   17bda:	910e      	str	r1, [sp, #56]	; 0x38
   17bdc:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
   17be0:	3901      	subs	r1, #1
        if( ( A_QA[ k ] > A_LIMIT ) || ( A_QA[ k ] < -A_LIMIT ) ) {
   17be2:	e9cd 0217 	strd	r0, r2, [sp, #92]	; 0x5c
   17be6:	aa1a      	add	r2, sp, #104	; 0x68
   17be8:	eb02 0281 	add.w	r2, r2, r1, lsl #2
        if( invGain_Q30 < SILK_FIX_CONST( 1.0f / MAX_PREDICTION_POWER_GAIN, 30 ) ) {
   17bec:	9419      	str	r4, [sp, #100]	; 0x64
   17bee:	920f      	str	r2, [sp, #60]	; 0x3c
   17bf0:	4619      	mov	r1, r3
   17bf2:	2900      	cmp	r1, #0
   17bf4:	f000 81a0 	beq.w	17f38 <silk_LPC_inverse_pred_gain_c+0x3cc>
        mult2Q = 32 - silk_CLZ32( silk_abs( rc_mult1_Q30 ) );
   17bf8:	ea81 75e1 	eor.w	r5, r1, r1, asr #31
   17bfc:	eba5 75e1 	sub.w	r5, r5, r1, asr #31
   17c00:	fab5 f585 	clz	r5, r5
   17c04:	f1c5 0320 	rsb	r3, r5, #32
   17c08:	9309      	str	r3, [sp, #36]	; 0x24
   17c0a:	2600      	movs	r6, #0
        rc_mult2 = silk_INVERSE32_varQ( rc_mult1_Q30, mult2Q + 30 );
   17c0c:	1e6b      	subs	r3, r5, #1
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                */
   17c0e:	fa01 f303 	lsl.w	r3, r1, r3
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm    */
   17c12:	141a      	asrs	r2, r3, #16
   17c14:	f06f 4060 	mvn.w	r0, #3758096384	; 0xe0000000
    err_Q32 = silk_LSHIFT( ((opus_int32)1<<29) - silk_SMULWB(b32_nrm, b32_inv), 3 );        /* Q32                        */
   17c18:	b29b      	uxth	r3, r3
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm    */
   17c1a:	fb90 f0f2 	sdiv	r0, r0, r2
    err_Q32 = silk_LSHIFT( ((opus_int32)1<<29) - silk_SMULWB(b32_nrm, b32_inv), 3 );        /* Q32                        */
   17c1e:	b204      	sxth	r4, r0
   17c20:	fb04 f202 	mul.w	r2, r4, r2
   17c24:	fb04 f303 	mul.w	r3, r4, r3
   17c28:	eb02 4323 	add.w	r3, r2, r3, asr #16
   17c2c:	f1c3 5300 	rsb	r3, r3, #536870912	; 0x20000000
   17c30:	00db      	lsls	r3, r3, #3
    result = silk_SMLAWW(result, err_Q32, b32_inv);                             /* Q: 61 - b_headrm            */
   17c32:	b29f      	uxth	r7, r3
   17c34:	141a      	asrs	r2, r3, #16
   17c36:	13c1      	asrs	r1, r0, #15
   17c38:	fb04 f707 	mul.w	r7, r4, r7
   17c3c:	fb04 f202 	mul.w	r2, r4, r2
   17c40:	3101      	adds	r1, #1
   17c42:	eb02 4227 	add.w	r2, r2, r7, asr #16
   17c46:	1049      	asrs	r1, r1, #1
   17c48:	eb02 4200 	add.w	r2, r2, r0, lsl #16
    if( lshift <= 0 ) {
   17c4c:	2e00      	cmp	r6, #0
    result = silk_SMLAWW(result, err_Q32, b32_inv);                             /* Q: 61 - b_headrm            */
   17c4e:	fb03 2101 	mla	r1, r3, r1, r2
    if( lshift <= 0 ) {
   17c52:	f340 817b 	ble.w	17f4c <silk_LPC_inverse_pred_gain_c+0x3e0>
        if( lshift < 32){
   17c56:	2e20      	cmp	r6, #32
            return silk_RSHIFT(result, lshift);
   17c58:	bf14      	ite	ne
   17c5a:	fa41 f306 	asrne.w	r3, r1, r6
        }else{
            /* Avoid undefined result */
            return 0;
   17c5e:	2300      	moveq	r3, #0
   17c60:	930d      	str	r3, [sp, #52]	; 0x34
        for( n = 0; n < (k + 1) >> 1; n++ ) {
   17c62:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   17c64:	1058      	asrs	r0, r3, #1
   17c66:	2800      	cmp	r0, #0
   17c68:	f340 817d 	ble.w	17f66 <silk_LPC_inverse_pred_gain_c+0x3fa>
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp1,
   17c6c:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   17c6e:	f8dd e03c 	ldr.w	lr, [sp, #60]	; 0x3c
   17c72:	f8cd e01c 	str.w	lr, [sp, #28]
   17c76:	4262      	negs	r2, r4
   17c78:	ea4f 79e4 	mov.w	r9, r4, asr #31
   17c7c:	eb69 0349 	sbc.w	r3, r9, r9, lsl #1
   17c80:	07db      	lsls	r3, r3, #31
   17c82:	ea43 0352 	orr.w	r3, r3, r2, lsr #1
   17c86:	07d1      	lsls	r1, r2, #31
   17c88:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
   17c8c:	930b      	str	r3, [sp, #44]	; 0x2c
   17c8e:	46a0      	mov	r8, r4
   17c90:	fb84 3402 	smull	r3, r4, r4, r2
   17c94:	461e      	mov	r6, r3
   17c96:	ab1a      	add	r3, sp, #104	; 0x68
   17c98:	eb03 0380 	add.w	r3, r3, r0, lsl #2
   17c9c:	910a      	str	r1, [sp, #40]	; 0x28
   17c9e:	930c      	str	r3, [sp, #48]	; 0x30
   17ca0:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
   17ca4:	105b      	asrs	r3, r3, #1
   17ca6:	ea4f 0232 	mov.w	r2, r2, rrx
   17caa:	e9cd 2310 	strd	r2, r3, [sp, #64]	; 0x40
   17cae:	4633      	mov	r3, r6
   17cb0:	f1c5 051f 	rsb	r5, r5, #31
   17cb4:	4627      	mov	r7, r4
   17cb6:	1064      	asrs	r4, r4, #1
   17cb8:	ea4f 0333 	mov.w	r3, r3, rrx
   17cbc:	f10d 0c68 	add.w	ip, sp, #104	; 0x68
   17cc0:	e9cd 3414 	strd	r3, r4, [sp, #80]	; 0x50
   17cc4:	f1c5 0320 	rsb	r3, r5, #32
   17cc8:	46e6      	mov	lr, ip
   17cca:	e9cd 6712 	strd	r6, r7, [sp, #72]	; 0x48
   17cce:	9308      	str	r3, [sp, #32]
   17cd0:	46ac      	mov	ip, r5
   17cd2:	e08d      	b.n	17df0 <silk_LPC_inverse_pred_gain_c+0x284>
   17cd4:	2800      	cmp	r0, #0
   17cd6:	f2c0 80f5 	blt.w	17ec4 <silk_LPC_inverse_pred_gain_c+0x358>
   17cda:	f101 4200 	add.w	r2, r1, #2147483648	; 0x80000000
   17cde:	4232      	tst	r2, r6
   17ce0:	f100 8109 	bmi.w	17ef6 <silk_LPC_inverse_pred_gain_c+0x38a>
   17ce4:	17c1      	asrs	r1, r0, #31
   17ce6:	fb00 f309 	mul.w	r3, r0, r9
   17cea:	fb08 3301 	mla	r3, r8, r1, r3
   17cee:	fba0 0108 	umull	r0, r1, r0, r8
   17cf2:	4419      	add	r1, r3
   17cf4:	fa20 f30c 	lsr.w	r3, r0, ip
   17cf8:	9300      	str	r3, [sp, #0]
   17cfa:	9b08      	ldr	r3, [sp, #32]
   17cfc:	9c00      	ldr	r4, [sp, #0]
   17cfe:	fa01 f203 	lsl.w	r2, r1, r3
   17d02:	4314      	orrs	r4, r2
   17d04:	f1bc 0320 	subs.w	r3, ip, #32
   17d08:	9400      	str	r4, [sp, #0]
   17d0a:	d404      	bmi.n	17d16 <silk_LPC_inverse_pred_gain_c+0x1aa>
   17d0c:	fa41 f303 	asr.w	r3, r1, r3
   17d10:	4622      	mov	r2, r4
   17d12:	431a      	orrs	r2, r3
   17d14:	9200      	str	r2, [sp, #0]
   17d16:	fa41 f30c 	asr.w	r3, r1, ip
   17d1a:	9301      	str	r3, [sp, #4]
   17d1c:	e9dd 4500 	ldrd	r4, r5, [sp]
   17d20:	3401      	adds	r4, #1
   17d22:	f145 0500 	adc.w	r5, r5, #0
   17d26:	106d      	asrs	r5, r5, #1
   17d28:	ea4f 0434 	mov.w	r4, r4, rrx
            if( tmp64 > silk_int32_MAX || tmp64 < silk_int32_MIN ) {
   17d2c:	f114 4200 	adds.w	r2, r4, #2147483648	; 0x80000000
   17d30:	f145 0300 	adc.w	r3, r5, #0
   17d34:	2100      	movs	r1, #0
   17d36:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   17d3a:	4299      	cmp	r1, r3
   17d3c:	bf08      	it	eq
   17d3e:	4290      	cmpeq	r0, r2
   17d40:	f4ff af29 	bcc.w	17b96 <silk_LPC_inverse_pred_gain_c+0x2a>
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp2,
   17d44:	17f3      	asrs	r3, r6, #31
   17d46:	fb06 f10b 	mul.w	r1, r6, fp
   17d4a:	fb0a 1103 	mla	r1, sl, r3, r1
   17d4e:	fba6 230a 	umull	r2, r3, r6, sl
   17d52:	440b      	add	r3, r1
   17d54:	0f91      	lsrs	r1, r2, #30
   17d56:	ea41 0183 	orr.w	r1, r1, r3, lsl #2
   17d5a:	179b      	asrs	r3, r3, #30
   17d5c:	9104      	str	r1, [sp, #16]
   17d5e:	9305      	str	r3, [sp, #20]
   17d60:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   17d64:	3001      	adds	r0, #1
   17d66:	f141 0100 	adc.w	r1, r1, #0
   17d6a:	1049      	asrs	r1, r1, #1
   17d6c:	ea4f 0030 	mov.w	r0, r0, rrx
   17d70:	1a3a      	subs	r2, r7, r0
            A_QA[ n ] = ( opus_int32 )tmp64;
   17d72:	f84e 4c04 	str.w	r4, [lr, #-4]
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp2,
   17d76:	f100 80b5 	bmi.w	17ee4 <silk_LPC_inverse_pred_gain_c+0x378>
   17d7a:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
   17d7e:	4238      	tst	r0, r7
   17d80:	f100 80be 	bmi.w	17f00 <silk_LPC_inverse_pred_gain_c+0x394>
   17d84:	17d3      	asrs	r3, r2, #31
   17d86:	fb02 f109 	mul.w	r1, r2, r9
   17d8a:	fb08 1103 	mla	r1, r8, r3, r1
   17d8e:	fba2 2308 	umull	r2, r3, r2, r8
   17d92:	440b      	add	r3, r1
   17d94:	fa22 f10c 	lsr.w	r1, r2, ip
   17d98:	9102      	str	r1, [sp, #8]
   17d9a:	9908      	ldr	r1, [sp, #32]
   17d9c:	9c02      	ldr	r4, [sp, #8]
   17d9e:	fa03 f001 	lsl.w	r0, r3, r1
   17da2:	4304      	orrs	r4, r0
   17da4:	f1bc 0120 	subs.w	r1, ip, #32
   17da8:	9402      	str	r4, [sp, #8]
   17daa:	d404      	bmi.n	17db6 <silk_LPC_inverse_pred_gain_c+0x24a>
   17dac:	fa43 f101 	asr.w	r1, r3, r1
   17db0:	4620      	mov	r0, r4
   17db2:	4308      	orrs	r0, r1
   17db4:	9002      	str	r0, [sp, #8]
   17db6:	fa43 f30c 	asr.w	r3, r3, ip
   17dba:	9303      	str	r3, [sp, #12]
   17dbc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   17dc0:	3201      	adds	r2, #1
   17dc2:	f143 0300 	adc.w	r3, r3, #0
   17dc6:	105e      	asrs	r6, r3, #1
   17dc8:	ea4f 0532 	mov.w	r5, r2, rrx
            if( tmp64 > silk_int32_MAX || tmp64 < silk_int32_MIN ) {
   17dcc:	f115 4000 	adds.w	r0, r5, #2147483648	; 0x80000000
   17dd0:	f146 0100 	adc.w	r1, r6, #0
   17dd4:	2400      	movs	r4, #0
   17dd6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   17dda:	428c      	cmp	r4, r1
   17ddc:	bf08      	it	eq
   17dde:	4283      	cmpeq	r3, r0
   17de0:	f4ff aed9 	bcc.w	17b96 <silk_LPC_inverse_pred_gain_c+0x2a>
            A_QA[ k - n - 1 ] = ( opus_int32 )tmp64;
   17de4:	9b07      	ldr	r3, [sp, #28]
   17de6:	601d      	str	r5, [r3, #0]
        for( n = 0; n < (k + 1) >> 1; n++ ) {
   17de8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   17dea:	459e      	cmp	lr, r3
   17dec:	f000 80bb 	beq.w	17f66 <silk_LPC_inverse_pred_gain_c+0x3fa>
            tmp2 = A_QA[ k - n - 1 ];
   17df0:	9b07      	ldr	r3, [sp, #28]
            tmp1 = A_QA[ n ];
   17df2:	f85e 6b04 	ldr.w	r6, [lr], #4
            tmp2 = A_QA[ k - n - 1 ];
   17df6:	f853 7d04 	ldr.w	r7, [r3, #-4]!
   17dfa:	9307      	str	r3, [sp, #28]
   17dfc:	17fc      	asrs	r4, r7, #31
   17dfe:	fb07 f20b 	mul.w	r2, r7, fp
   17e02:	fb0a 2304 	mla	r3, sl, r4, r2
   17e06:	fba7 010a 	umull	r0, r1, r7, sl
   17e0a:	4419      	add	r1, r3
   17e0c:	0f84      	lsrs	r4, r0, #30
   17e0e:	ea44 0481 	orr.w	r4, r4, r1, lsl #2
   17e12:	1c62      	adds	r2, r4, #1
   17e14:	ea4f 75a1 	mov.w	r5, r1, asr #30
   17e18:	f145 0300 	adc.w	r3, r5, #0
   17e1c:	105b      	asrs	r3, r3, #1
   17e1e:	ea4f 0232 	mov.w	r2, r2, rrx
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp1,
   17e22:	9b09      	ldr	r3, [sp, #36]	; 0x24
   17e24:	2b01      	cmp	r3, #1
   17e26:	4611      	mov	r1, r2
   17e28:	eba6 0002 	sub.w	r0, r6, r2
   17e2c:	f47f af52 	bne.w	17cd4 <silk_LPC_inverse_pred_gain_c+0x168>
   17e30:	2800      	cmp	r0, #0
   17e32:	db6a      	blt.n	17f0a <silk_LPC_inverse_pred_gain_c+0x39e>
   17e34:	f101 4200 	add.w	r2, r1, #2147483648	; 0x80000000
   17e38:	4232      	tst	r2, r6
   17e3a:	d478      	bmi.n	17f2e <silk_LPC_inverse_pred_gain_c+0x3c2>
   17e3c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   17e3e:	fb80 2303 	smull	r2, r3, r0, r3
   17e42:	105d      	asrs	r5, r3, #1
   17e44:	ea4f 0432 	mov.w	r4, r2, rrx
   17e48:	f002 0001 	and.w	r0, r2, #1
   17e4c:	1822      	adds	r2, r4, r0
   17e4e:	f04f 0100 	mov.w	r1, #0
   17e52:	eb45 0301 	adc.w	r3, r5, r1
   17e56:	e9cd 2304 	strd	r2, r3, [sp, #16]
            if( tmp64 > silk_int32_MAX || tmp64 < silk_int32_MIN ) {
   17e5a:	f112 4200 	adds.w	r2, r2, #2147483648	; 0x80000000
   17e5e:	f143 0300 	adc.w	r3, r3, #0
   17e62:	2100      	movs	r1, #0
   17e64:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   17e68:	4299      	cmp	r1, r3
   17e6a:	bf08      	it	eq
   17e6c:	4290      	cmpeq	r0, r2
   17e6e:	f4ff ae92 	bcc.w	17b96 <silk_LPC_inverse_pred_gain_c+0x2a>
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp2,
   17e72:	17f3      	asrs	r3, r6, #31
   17e74:	fb06 f10b 	mul.w	r1, r6, fp
   17e78:	fb0a 1103 	mla	r1, sl, r3, r1
   17e7c:	fba6 230a 	umull	r2, r3, r6, sl
   17e80:	440b      	add	r3, r1
   17e82:	0f94      	lsrs	r4, r2, #30
   17e84:	ea44 0483 	orr.w	r4, r4, r3, lsl #2
   17e88:	1c60      	adds	r0, r4, #1
   17e8a:	ea4f 75a3 	mov.w	r5, r3, asr #30
   17e8e:	f145 0100 	adc.w	r1, r5, #0
   17e92:	1049      	asrs	r1, r1, #1
   17e94:	ea4f 0030 	mov.w	r0, r0, rrx
            A_QA[ n ] = ( opus_int32 )tmp64;
   17e98:	9b04      	ldr	r3, [sp, #16]
   17e9a:	f84e 3c04 	str.w	r3, [lr, #-4]
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp2,
   17e9e:	1a3a      	subs	r2, r7, r0
   17ea0:	d43c      	bmi.n	17f1c <silk_LPC_inverse_pred_gain_c+0x3b0>
   17ea2:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
   17ea6:	4238      	tst	r0, r7
   17ea8:	d44b      	bmi.n	17f42 <silk_LPC_inverse_pred_gain_c+0x3d6>
   17eaa:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   17eac:	fb82 4503 	smull	r4, r5, r2, r3
   17eb0:	1069      	asrs	r1, r5, #1
   17eb2:	ea4f 0034 	mov.w	r0, r4, rrx
   17eb6:	f004 0201 	and.w	r2, r4, #1
   17eba:	2300      	movs	r3, #0
   17ebc:	1815      	adds	r5, r2, r0
   17ebe:	eb43 0601 	adc.w	r6, r3, r1
   17ec2:	e783      	b.n	17dcc <silk_LPC_inverse_pred_gain_c+0x260>
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp1,
   17ec4:	f106 4300 	add.w	r3, r6, #2147483648	; 0x80000000
   17ec8:	420b      	tst	r3, r1
   17eca:	f57f af0b 	bpl.w	17ce4 <silk_LPC_inverse_pred_gain_c+0x178>
   17ece:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   17ed2:	2100      	movs	r1, #0
   17ed4:	e707      	b.n	17ce6 <silk_LPC_inverse_pred_gain_c+0x17a>
   17ed6:	bf00      	nop
   17ed8:	00ffef9e 	.word	0x00ffef9e
   17edc:	01ffdf3c 	.word	0x01ffdf3c
   17ee0:	0001a36d 	.word	0x0001a36d
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp2,
   17ee4:	f107 4700 	add.w	r7, r7, #2147483648	; 0x80000000
   17ee8:	4207      	tst	r7, r0
   17eea:	f57f af4b 	bpl.w	17d84 <silk_LPC_inverse_pred_gain_c+0x218>
   17eee:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
   17ef2:	2300      	movs	r3, #0
   17ef4:	e747      	b.n	17d86 <silk_LPC_inverse_pred_gain_c+0x21a>
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp1,
   17ef6:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
   17efa:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   17efe:	e6f2      	b.n	17ce6 <silk_LPC_inverse_pred_gain_c+0x17a>
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp2,
   17f00:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   17f04:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   17f08:	e73d      	b.n	17d86 <silk_LPC_inverse_pred_gain_c+0x21a>
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp1,
   17f0a:	f106 4300 	add.w	r3, r6, #2147483648	; 0x80000000
   17f0e:	420b      	tst	r3, r1
   17f10:	d594      	bpl.n	17e3c <silk_LPC_inverse_pred_gain_c+0x2d0>
   17f12:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
   17f16:	e9dd 4514 	ldrd	r4, r5, [sp, #80]	; 0x50
   17f1a:	e795      	b.n	17e48 <silk_LPC_inverse_pred_gain_c+0x2dc>
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp2,
   17f1c:	f107 4700 	add.w	r7, r7, #2147483648	; 0x80000000
   17f20:	4207      	tst	r7, r0
   17f22:	d5c2      	bpl.n	17eaa <silk_LPC_inverse_pred_gain_c+0x33e>
   17f24:	e9dd 4512 	ldrd	r4, r5, [sp, #72]	; 0x48
   17f28:	e9dd 0114 	ldrd	r0, r1, [sp, #80]	; 0x50
   17f2c:	e7c3      	b.n	17eb6 <silk_LPC_inverse_pred_gain_c+0x34a>
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp1,
   17f2e:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
   17f32:	e9dd 4510 	ldrd	r4, r5, [sp, #64]	; 0x40
   17f36:	e787      	b.n	17e48 <silk_LPC_inverse_pred_gain_c+0x2dc>
   17f38:	460e      	mov	r6, r1
   17f3a:	231f      	movs	r3, #31
        mult2Q = 32 - silk_CLZ32( silk_abs( rc_mult1_Q30 ) );
   17f3c:	9109      	str	r1, [sp, #36]	; 0x24
   17f3e:	2520      	movs	r5, #32
   17f40:	e665      	b.n	17c0e <silk_LPC_inverse_pred_gain_c+0xa2>
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp2,
   17f42:	e9dd 450a 	ldrd	r4, r5, [sp, #40]	; 0x28
   17f46:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
   17f4a:	e7b4      	b.n	17eb6 <silk_LPC_inverse_pred_gain_c+0x34a>
        return silk_LSHIFT_SAT32(result, -lshift);
   17f4c:	4276      	negs	r6, r6
   17f4e:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   17f52:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
   17f56:	4132      	asrs	r2, r6
   17f58:	4133      	asrs	r3, r6
   17f5a:	429a      	cmp	r2, r3
   17f5c:	dd27      	ble.n	17fae <silk_LPC_inverse_pred_gain_c+0x442>
   17f5e:	4291      	cmp	r1, r2
   17f60:	dd30      	ble.n	17fc4 <silk_LPC_inverse_pred_gain_c+0x458>
   17f62:	4611      	mov	r1, r2
   17f64:	e028      	b.n	17fb8 <silk_LPC_inverse_pred_gain_c+0x44c>
   17f66:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    for( k = order - 1; k > 0; k-- ) {
   17f68:	990e      	ldr	r1, [sp, #56]	; 0x38
   17f6a:	f853 2d04 	ldr.w	r2, [r3, #-4]!
   17f6e:	930f      	str	r3, [sp, #60]	; 0x3c
   17f70:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   17f72:	2902      	cmp	r1, #2
   17f74:	4413      	add	r3, r2
   17f76:	d02c      	beq.n	17fd2 <silk_LPC_inverse_pred_gain_c+0x466>
        if( ( A_QA[ k ] > A_LIMIT ) || ( A_QA[ k ] < -A_LIMIT ) ) {
   17f78:	9918      	ldr	r1, [sp, #96]	; 0x60
   17f7a:	428b      	cmp	r3, r1
   17f7c:	f63f ae0b 	bhi.w	17b96 <silk_LPC_inverse_pred_gain_c+0x2a>
        rc_Q31 = -silk_LSHIFT( A_QA[ k ], 31 - QA );
   17f80:	ea4f 1ac2 	mov.w	sl, r2, lsl #7
   17f84:	f1ca 0a00 	rsb	sl, sl, #0
        rc_mult1_Q30 = silk_SUB32( SILK_FIX_CONST( 1, 30 ), silk_SMMUL( rc_Q31, rc_Q31 ) );
   17f88:	fb8a 230a 	smull	r2, r3, sl, sl
   17f8c:	f1c3 4180 	rsb	r1, r3, #1073741824	; 0x40000000
        invGain_Q30 = silk_LSHIFT( silk_SMMUL( invGain_Q30, rc_mult1_Q30 ), 2 );
   17f90:	9b16      	ldr	r3, [sp, #88]	; 0x58
   17f92:	fb83 2301 	smull	r2, r3, r3, r1
   17f96:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   17f98:	3a01      	subs	r2, #1
   17f9a:	920e      	str	r2, [sp, #56]	; 0x38
        if( invGain_Q30 < SILK_FIX_CONST( 1.0f / MAX_PREDICTION_POWER_GAIN, 30 ) ) {
   17f9c:	9a19      	ldr	r2, [sp, #100]	; 0x64
        invGain_Q30 = silk_LSHIFT( silk_SMMUL( invGain_Q30, rc_mult1_Q30 ), 2 );
   17f9e:	009b      	lsls	r3, r3, #2
        if( invGain_Q30 < SILK_FIX_CONST( 1.0f / MAX_PREDICTION_POWER_GAIN, 30 ) ) {
   17fa0:	4293      	cmp	r3, r2
        invGain_Q30 = silk_LSHIFT( silk_SMMUL( invGain_Q30, rc_mult1_Q30 ), 2 );
   17fa2:	9316      	str	r3, [sp, #88]	; 0x58
        rc_mult1_Q30 = silk_SUB32( SILK_FIX_CONST( 1, 30 ), silk_SMMUL( rc_Q31, rc_Q31 ) );
   17fa4:	ea4f 7bea 	mov.w	fp, sl, asr #31
        if( invGain_Q30 < SILK_FIX_CONST( 1.0f / MAX_PREDICTION_POWER_GAIN, 30 ) ) {
   17fa8:	f73f ae23 	bgt.w	17bf2 <silk_LPC_inverse_pred_gain_c+0x86>
   17fac:	e5f3      	b.n	17b96 <silk_LPC_inverse_pred_gain_c+0x2a>
   17fae:	4299      	cmp	r1, r3
   17fb0:	dc06      	bgt.n	17fc0 <silk_LPC_inverse_pred_gain_c+0x454>
   17fb2:	4291      	cmp	r1, r2
   17fb4:	bfb8      	it	lt
   17fb6:	4611      	movlt	r1, r2
   17fb8:	fa01 f306 	lsl.w	r3, r1, r6
   17fbc:	930d      	str	r3, [sp, #52]	; 0x34
   17fbe:	e650      	b.n	17c62 <silk_LPC_inverse_pred_gain_c+0xf6>
   17fc0:	4619      	mov	r1, r3
   17fc2:	e7f9      	b.n	17fb8 <silk_LPC_inverse_pred_gain_c+0x44c>
   17fc4:	4299      	cmp	r1, r3
   17fc6:	bfb8      	it	lt
   17fc8:	4619      	movlt	r1, r3
   17fca:	e7f5      	b.n	17fb8 <silk_LPC_inverse_pred_gain_c+0x44c>
    invGain_Q30 = SILK_FIX_CONST( 1, 30 );
   17fcc:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   17fd0:	9216      	str	r2, [sp, #88]	; 0x58
    if( ( A_QA[ k ] > A_LIMIT ) || ( A_QA[ k ] < -A_LIMIT ) ) {
   17fd2:	4a0a      	ldr	r2, [pc, #40]	; (17ffc <silk_LPC_inverse_pred_gain_c+0x490>)
   17fd4:	4293      	cmp	r3, r2
   17fd6:	f63f adde 	bhi.w	17b96 <silk_LPC_inverse_pred_gain_c+0x2a>
    rc_Q31 = -silk_LSHIFT( A_QA[ 0 ], 31 - QA );
   17fda:	9b1a      	ldr	r3, [sp, #104]	; 0x68
    if( invGain_Q30 < SILK_FIX_CONST( 1.0f / MAX_PREDICTION_POWER_GAIN, 30 ) ) {
   17fdc:	4c08      	ldr	r4, [pc, #32]	; (18000 <silk_LPC_inverse_pred_gain_c+0x494>)
    rc_Q31 = -silk_LSHIFT( A_QA[ 0 ], 31 - QA );
   17fde:	01da      	lsls	r2, r3, #7
   17fe0:	4252      	negs	r2, r2
    rc_mult1_Q30 = silk_SUB32( SILK_FIX_CONST( 1, 30 ), silk_SMMUL( rc_Q31, rc_Q31 ) );
   17fe2:	fb82 2302 	smull	r2, r3, r2, r2
   17fe6:	f1c3 4080 	rsb	r0, r3, #1073741824	; 0x40000000
    invGain_Q30 = silk_LSHIFT( silk_SMMUL( invGain_Q30, rc_mult1_Q30 ), 2 );
   17fea:	9b16      	ldr	r3, [sp, #88]	; 0x58
   17fec:	fb80 0103 	smull	r0, r1, r0, r3
   17ff0:	0088      	lsls	r0, r1, #2
    if( invGain_Q30 < SILK_FIX_CONST( 1.0f / MAX_PREDICTION_POWER_GAIN, 30 ) ) {
   17ff2:	42a0      	cmp	r0, r4
   17ff4:	f73f add0 	bgt.w	17b98 <silk_LPC_inverse_pred_gain_c+0x2c>
   17ff8:	e5cd      	b.n	17b96 <silk_LPC_inverse_pred_gain_c+0x2a>
   17ffa:	bf00      	nop
   17ffc:	01ffdf3c 	.word	0x01ffdf3c
   18000:	0001a36d 	.word	0x0001a36d

00018004 <silk_NLSF2A>:
    opus_int16                  *a_Q12,             /* O    monic whitening filter coefficients in Q12,  [ d ]          */
    const opus_int16            *NLSF,              /* I    normalized line spectral frequencies in Q15, [ d ]          */
    const opus_int              d,                  /* I    filter order (should be even)                               */
    int                         arch                /* I    Run-time architecture                                       */
)
{
   18004:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   18008:	b0d7      	sub	sp, #348	; 0x15c

    silk_assert( LSF_COS_TAB_SZ_FIX == 128 );
    celt_assert( d==10 || d==16 );

    /* convert LSFs to 2*cos(LSF), using piecewise linear curve from table */
    ordering = d == 16 ? ordering16 : ordering10;
   1800a:	2a10      	cmp	r2, #16
{
   1800c:	9209      	str	r2, [sp, #36]	; 0x24
   1800e:	900b      	str	r0, [sp, #44]	; 0x2c
    ordering = d == 16 ? ordering16 : ordering10;
   18010:	f000 839f 	beq.w	18752 <silk_NLSF2A+0x74e>
    for( k = 0; k < d; k++ ) {
   18014:	2a00      	cmp	r2, #0
   18016:	dd22      	ble.n	1805e <silk_NLSF2A+0x5a>
    ordering = d == 16 ? ordering16 : ordering10;
   18018:	4db0      	ldr	r5, [pc, #704]	; (182dc <silk_NLSF2A+0x2d8>)
   1801a:	4617      	mov	r7, r2
   1801c:	4eb0      	ldr	r6, [pc, #704]	; (182e0 <silk_NLSF2A+0x2dc>)
   1801e:	3902      	subs	r1, #2
   18020:	3d01      	subs	r5, #1
   18022:	2400      	movs	r4, #0
        silk_assert( NLSF[k] >= 0 );

        /* f_int on a scale 0-127 (rounded down) */
        f_int = silk_RSHIFT( NLSF[k], 15 - 7 );
   18024:	f931 0f02 	ldrsh.w	r0, [r1, #2]!
        /* Read start and end value from table */
        cos_val = silk_LSFCosTab_FIX_Q12[ f_int ];                /* Q12 */
        delta   = silk_LSFCosTab_FIX_Q12[ f_int + 1 ] - cos_val;  /* Q12, with a range of 0..200 */

        /* Linear interpolation */
        cos_LSF_QA[ordering[k]] = silk_RSHIFT_ROUND( silk_LSHIFT( cos_val, 8 ) + silk_MUL( delta, f_frac ), 20 - QA ); /* QA */
   18028:	f815 cf01 	ldrb.w	ip, [r5, #1]!
        f_int = silk_RSHIFT( NLSF[k], 15 - 7 );
   1802c:	ea4f 2e20 	mov.w	lr, r0, asr #8
        delta   = silk_LSFCosTab_FIX_Q12[ f_int + 1 ] - cos_val;  /* Q12, with a range of 0..200 */
   18030:	f10e 0301 	add.w	r3, lr, #1
        cos_val = silk_LSFCosTab_FIX_Q12[ f_int ];                /* Q12 */
   18034:	f936 201e 	ldrsh.w	r2, [r6, lr, lsl #1]
        delta   = silk_LSFCosTab_FIX_Q12[ f_int + 1 ] - cos_val;  /* Q12, with a range of 0..200 */
   18038:	f936 3013 	ldrsh.w	r3, [r6, r3, lsl #1]
        f_frac = NLSF[k] - silk_LSHIFT( f_int, 15 - 7 );
   1803c:	eba0 200e 	sub.w	r0, r0, lr, lsl #8
        delta   = silk_LSFCosTab_FIX_Q12[ f_int + 1 ] - cos_val;  /* Q12, with a range of 0..200 */
   18040:	1a9b      	subs	r3, r3, r2
        cos_LSF_QA[ordering[k]] = silk_RSHIFT_ROUND( silk_LSHIFT( cos_val, 8 ) + silk_MUL( delta, f_frac ), 20 - QA ); /* QA */
   18042:	0212      	lsls	r2, r2, #8
   18044:	fb00 2303 	mla	r3, r0, r3, r2
   18048:	10db      	asrs	r3, r3, #3
   1804a:	aa56      	add	r2, sp, #344	; 0x158
   1804c:	3301      	adds	r3, #1
   1804e:	eb02 0c8c 	add.w	ip, r2, ip, lsl #2
    for( k = 0; k < d; k++ ) {
   18052:	3401      	adds	r4, #1
        cos_LSF_QA[ordering[k]] = silk_RSHIFT_ROUND( silk_LSHIFT( cos_val, 8 ) + silk_MUL( delta, f_frac ), 20 - QA ); /* QA */
   18054:	105b      	asrs	r3, r3, #1
    for( k = 0; k < d; k++ ) {
   18056:	42a7      	cmp	r7, r4
        cos_LSF_QA[ordering[k]] = silk_RSHIFT_ROUND( silk_LSHIFT( cos_val, 8 ) + silk_MUL( delta, f_frac ), 20 - QA ); /* QA */
   18058:	f84c 3cc0 	str.w	r3, [ip, #-192]
    for( k = 0; k < d; k++ ) {
   1805c:	dce2      	bgt.n	18024 <silk_NLSF2A+0x20>
   1805e:	e9dd 3126 	ldrd	r3, r1, [sp, #152]	; 0x98
    }

    dd = silk_RSHIFT( d, 1 );
   18062:	9809      	ldr	r0, [sp, #36]	; 0x24
    out[1] = -cLSF[0];
   18064:	425b      	negs	r3, r3
    dd = silk_RSHIFT( d, 1 );
   18066:	1040      	asrs	r0, r0, #1
    out[0] = silk_LSHIFT( 1, QA );
   18068:	f10d 0a30 	add.w	sl, sp, #48	; 0x30
   1806c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   18070:	e9ca 2300 	strd	r2, r3, [sl]
    for( k = 1; k < dd; k++ ) {
   18074:	2801      	cmp	r0, #1
   18076:	f1c1 0300 	rsb	r3, r1, #0
    dd = silk_RSHIFT( d, 1 );
   1807a:	9007      	str	r0, [sp, #28]
   1807c:	9306      	str	r3, [sp, #24]
    for( k = 1; k < dd; k++ ) {
   1807e:	f340 836e 	ble.w	1875e <silk_NLSF2A+0x75a>
   18082:	2301      	movs	r3, #1
   18084:	4698      	mov	r8, r3
   18086:	f8cd a008 	str.w	sl, [sp, #8]
        out[k+1] = silk_LSHIFT( out[k-1], 1 ) - (opus_int32)silk_RSHIFT_ROUND64( silk_SMULL( ftmp, out[k] ), QA );
   1808a:	9e02      	ldr	r6, [sp, #8]
        ftmp = cLSF[2*k];            /* QA*/
   1808c:	ab26      	add	r3, sp, #152	; 0x98
        out[k+1] = silk_LSHIFT( out[k-1], 1 ) - (opus_int32)silk_RSHIFT_ROUND64( silk_SMULL( ftmp, out[k] ), QA );
   1808e:	6830      	ldr	r0, [r6, #0]
        ftmp = cLSF[2*k];            /* QA*/
   18090:	f853 e038 	ldr.w	lr, [r3, r8, lsl #3]
        out[k+1] = silk_LSHIFT( out[k-1], 1 ) - (opus_int32)silk_RSHIFT_ROUND64( silk_SMULL( ftmp, out[k] ), QA );
   18094:	f856 1f04 	ldr.w	r1, [r6, #4]!
   18098:	9602      	str	r6, [sp, #8]
   1809a:	fb8e 4501 	smull	r4, r5, lr, r1
   1809e:	ea4f 3bd4 	mov.w	fp, r4, lsr #15
   180a2:	ea4b 4b45 	orr.w	fp, fp, r5, lsl #17
   180a6:	f11b 0201 	adds.w	r2, fp, #1
   180aa:	ea4f 3ce5 	mov.w	ip, r5, asr #15
   180ae:	f14c 0300 	adc.w	r3, ip, #0
   180b2:	105b      	asrs	r3, r3, #1
   180b4:	ea4f 0232 	mov.w	r2, r2, rrx
   180b8:	ebc2 0240 	rsb	r2, r2, r0, lsl #1
        for( n = k; n > 1; n-- ) {
   180bc:	f1b8 0f01 	cmp.w	r8, #1
        out[k+1] = silk_LSHIFT( out[k-1], 1 ) - (opus_int32)silk_RSHIFT_ROUND64( silk_SMULL( ftmp, out[k] ), QA );
   180c0:	6072      	str	r2, [r6, #4]
        for( n = k; n > 1; n-- ) {
   180c2:	d067      	beq.n	18194 <silk_NLSF2A+0x190>
   180c4:	f1b8 0f03 	cmp.w	r8, #3
   180c8:	f340 8341 	ble.w	1874e <silk_NLSF2A+0x74a>
   180cc:	f1a8 0904 	sub.w	r9, r8, #4
   180d0:	f029 0301 	bic.w	r3, r9, #1
   180d4:	f1a8 0902 	sub.w	r9, r8, #2
   180d8:	eba9 0903 	sub.w	r9, r9, r3
   180dc:	f856 0c04 	ldr.w	r0, [r6, #-4]
   180e0:	f8cd 8014 	str.w	r8, [sp, #20]
   180e4:	4635      	mov	r5, r6
   180e6:	4644      	mov	r4, r8
   180e8:	46cb      	mov	fp, r9
            out[n] += out[n-2] - (opus_int32)silk_RSHIFT_ROUND64( silk_SMULL( ftmp, out[n-1] ), QA );
   180ea:	fb8e 6700 	smull	r6, r7, lr, r0
   180ee:	ea4f 38d6 	mov.w	r8, r6, lsr #15
   180f2:	ea48 4847 	orr.w	r8, r8, r7, lsl #17
   180f6:	f855 cc08 	ldr.w	ip, [r5, #-8]
   180fa:	f118 0201 	adds.w	r2, r8, #1
   180fe:	ea4f 39e7 	mov.w	r9, r7, asr #15
   18102:	f149 0300 	adc.w	r3, r9, #0
   18106:	105b      	asrs	r3, r3, #1
   18108:	ea4f 0232 	mov.w	r2, r2, rrx
   1810c:	fb8e 670c 	smull	r6, r7, lr, ip
   18110:	ebac 0202 	sub.w	r2, ip, r2
   18114:	0bf3      	lsrs	r3, r6, #15
   18116:	4411      	add	r1, r2
   18118:	ea43 4347 	orr.w	r3, r3, r7, lsl #17
   1811c:	f84a 1024 	str.w	r1, [sl, r4, lsl #2]
   18120:	4698      	mov	r8, r3
   18122:	13fb      	asrs	r3, r7, #15
   18124:	f118 0801 	adds.w	r8, r8, #1
   18128:	4699      	mov	r9, r3
   1812a:	f149 0900 	adc.w	r9, r9, #0
   1812e:	f855 3c0c 	ldr.w	r3, [r5, #-12]
   18132:	ea5f 0969 	movs.w	r9, r9, asr #1
   18136:	ea4f 0838 	mov.w	r8, r8, rrx
   1813a:	eba3 0808 	sub.w	r8, r3, r8
   1813e:	3c02      	subs	r4, #2
   18140:	4440      	add	r0, r8
   18142:	455c      	cmp	r4, fp
   18144:	f845 0c04 	str.w	r0, [r5, #-4]
   18148:	4661      	mov	r1, ip
   1814a:	4618      	mov	r0, r3
   1814c:	f1a5 0508 	sub.w	r5, r5, #8
   18150:	d1cb      	bne.n	180ea <silk_NLSF2A+0xe6>
   18152:	f8dd 8014 	ldr.w	r8, [sp, #20]
   18156:	3401      	adds	r4, #1
   18158:	00a4      	lsls	r4, r4, #2
   1815a:	f1a4 0508 	sub.w	r5, r4, #8
   1815e:	4455      	add	r5, sl
   18160:	4454      	add	r4, sl
   18162:	f855 0904 	ldr.w	r0, [r5], #-4
   18166:	f854 6d04 	ldr.w	r6, [r4, #-4]!
   1816a:	fb8e 0100 	smull	r0, r1, lr, r0
   1816e:	ea4f 3bd0 	mov.w	fp, r0, lsr #15
   18172:	ea4b 4b41 	orr.w	fp, fp, r1, lsl #17
   18176:	f11b 0201 	adds.w	r2, fp, #1
   1817a:	ea4f 3ce1 	mov.w	ip, r1, asr #15
   1817e:	f14c 0300 	adc.w	r3, ip, #0
   18182:	6829      	ldr	r1, [r5, #0]
   18184:	105b      	asrs	r3, r3, #1
   18186:	ea4f 0232 	mov.w	r2, r2, rrx
   1818a:	1a8a      	subs	r2, r1, r2
   1818c:	4416      	add	r6, r2
        for( n = k; n > 1; n-- ) {
   1818e:	4555      	cmp	r5, sl
            out[n] += out[n-2] - (opus_int32)silk_RSHIFT_ROUND64( silk_SMULL( ftmp, out[n-1] ), QA );
   18190:	6026      	str	r6, [r4, #0]
        for( n = k; n > 1; n-- ) {
   18192:	d1e6      	bne.n	18162 <silk_NLSF2A+0x15e>
        out[1] -= ftmp;
   18194:	f8da 3004 	ldr.w	r3, [sl, #4]
   18198:	eba3 030e 	sub.w	r3, r3, lr
   1819c:	f8ca 3004 	str.w	r3, [sl, #4]
    for( k = 1; k < dd; k++ ) {
   181a0:	9b07      	ldr	r3, [sp, #28]
   181a2:	f108 0801 	add.w	r8, r8, #1
   181a6:	4543      	cmp	r3, r8
   181a8:	f47f af6f 	bne.w	1808a <silk_NLSF2A+0x86>
    out[1] = -cLSF[0];
   181ac:	9a06      	ldr	r2, [sp, #24]
   181ae:	921a      	str	r2, [sp, #104]	; 0x68
    out[0] = silk_LSHIFT( 1, QA );
   181b0:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   181b4:	f10d 0964 	add.w	r9, sp, #100	; 0x64
   181b8:	aa26      	add	r2, sp, #152	; 0x98
   181ba:	9319      	str	r3, [sp, #100]	; 0x64
    for( k = 1; k < dd; k++ ) {
   181bc:	2301      	movs	r3, #1
   181be:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
   181c2:	9206      	str	r2, [sp, #24]
    out[1] = -cLSF[0];
   181c4:	f8cd 9020 	str.w	r9, [sp, #32]
    for( k = 1; k < dd; k++ ) {
   181c8:	9305      	str	r3, [sp, #20]
        out[k+1] = silk_LSHIFT( out[k-1], 1 ) - (opus_int32)silk_RSHIFT_ROUND64( silk_SMULL( ftmp, out[k] ), QA );
   181ca:	9d08      	ldr	r5, [sp, #32]
        ftmp = cLSF[2*k];            /* QA*/
   181cc:	9b06      	ldr	r3, [sp, #24]
        out[k+1] = silk_LSHIFT( out[k-1], 1 ) - (opus_int32)silk_RSHIFT_ROUND64( silk_SMULL( ftmp, out[k] ), QA );
   181ce:	682c      	ldr	r4, [r5, #0]
        ftmp = cLSF[2*k];            /* QA*/
   181d0:	f8d3 e00c 	ldr.w	lr, [r3, #12]
        out[k+1] = silk_LSHIFT( out[k-1], 1 ) - (opus_int32)silk_RSHIFT_ROUND64( silk_SMULL( ftmp, out[k] ), QA );
   181d4:	f855 cf04 	ldr.w	ip, [r5, #4]!
   181d8:	9508      	str	r5, [sp, #32]
   181da:	fb8e 010c 	smull	r0, r1, lr, ip
   181de:	0bc6      	lsrs	r6, r0, #15
   181e0:	ea46 4641 	orr.w	r6, r6, r1, lsl #17
   181e4:	1c72      	adds	r2, r6, #1
   181e6:	ea4f 37e1 	mov.w	r7, r1, asr #15
   181ea:	f147 0300 	adc.w	r3, r7, #0
        for( n = k; n > 1; n-- ) {
   181ee:	9805      	ldr	r0, [sp, #20]
        out[k+1] = silk_LSHIFT( out[k-1], 1 ) - (opus_int32)silk_RSHIFT_ROUND64( silk_SMULL( ftmp, out[k] ), QA );
   181f0:	105b      	asrs	r3, r3, #1
   181f2:	ea4f 0232 	mov.w	r2, r2, rrx
   181f6:	ebc2 0244 	rsb	r2, r2, r4, lsl #1
        for( n = k; n > 1; n-- ) {
   181fa:	2801      	cmp	r0, #1
        out[k+1] = silk_LSHIFT( out[k-1], 1 ) - (opus_int32)silk_RSHIFT_ROUND64( silk_SMULL( ftmp, out[k] ), QA );
   181fc:	606a      	str	r2, [r5, #4]
        for( n = k; n > 1; n-- ) {
   181fe:	d05e      	beq.n	182be <silk_NLSF2A+0x2ba>
   18200:	2803      	cmp	r0, #3
   18202:	dd3e      	ble.n	18282 <silk_NLSF2A+0x27e>
   18204:	f1a0 0804 	sub.w	r8, r0, #4
   18208:	f028 0301 	bic.w	r3, r8, #1
   1820c:	f855 1c04 	ldr.w	r1, [r5, #-4]
   18210:	f1a0 0802 	sub.w	r8, r0, #2
   18214:	eba8 0803 	sub.w	r8, r8, r3
   18218:	462c      	mov	r4, r5
            out[n] += out[n-2] - (opus_int32)silk_RSHIFT_ROUND64( silk_SMULL( ftmp, out[n-1] ), QA );
   1821a:	fb8e 6701 	smull	r6, r7, lr, r1
   1821e:	0bf3      	lsrs	r3, r6, #15
   18220:	ea43 4347 	orr.w	r3, r3, r7, lsl #17
   18224:	9302      	str	r3, [sp, #8]
   18226:	13fb      	asrs	r3, r7, #15
   18228:	9303      	str	r3, [sp, #12]
   1822a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   1822e:	f854 5c08 	ldr.w	r5, [r4, #-8]
   18232:	3201      	adds	r2, #1
   18234:	fb8e 6705 	smull	r6, r7, lr, r5
   18238:	f143 0300 	adc.w	r3, r3, #0
   1823c:	105b      	asrs	r3, r3, #1
   1823e:	ea4f 0232 	mov.w	r2, r2, rrx
   18242:	0bf3      	lsrs	r3, r6, #15
   18244:	ea43 4347 	orr.w	r3, r3, r7, lsl #17
   18248:	9302      	str	r3, [sp, #8]
   1824a:	13fb      	asrs	r3, r7, #15
   1824c:	9303      	str	r3, [sp, #12]
   1824e:	eba5 0b02 	sub.w	fp, r5, r2
   18252:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   18256:	44dc      	add	ip, fp
   18258:	f849 c020 	str.w	ip, [r9, r0, lsl #2]
   1825c:	3201      	adds	r2, #1
   1825e:	f854 6c0c 	ldr.w	r6, [r4, #-12]
   18262:	f143 0300 	adc.w	r3, r3, #0
   18266:	105b      	asrs	r3, r3, #1
   18268:	ea4f 0232 	mov.w	r2, r2, rrx
   1826c:	1ab2      	subs	r2, r6, r2
   1826e:	3802      	subs	r0, #2
   18270:	4411      	add	r1, r2
   18272:	4540      	cmp	r0, r8
   18274:	f844 1c04 	str.w	r1, [r4, #-4]
   18278:	46ac      	mov	ip, r5
   1827a:	4631      	mov	r1, r6
   1827c:	f1a4 0408 	sub.w	r4, r4, #8
   18280:	d1cb      	bne.n	1821a <silk_NLSF2A+0x216>
   18282:	3001      	adds	r0, #1
   18284:	0080      	lsls	r0, r0, #2
   18286:	f1a0 0508 	sub.w	r5, r0, #8
   1828a:	444d      	add	r5, r9
   1828c:	4448      	add	r0, r9
   1828e:	4629      	mov	r1, r5
   18290:	f851 4904 	ldr.w	r4, [r1], #-4
   18294:	f850 6d04 	ldr.w	r6, [r0, #-4]!
   18298:	fb8e 4504 	smull	r4, r5, lr, r4
   1829c:	0be7      	lsrs	r7, r4, #15
   1829e:	ea47 4745 	orr.w	r7, r7, r5, lsl #17
   182a2:	1c7a      	adds	r2, r7, #1
   182a4:	ea4f 38e5 	mov.w	r8, r5, asr #15
   182a8:	f148 0300 	adc.w	r3, r8, #0
   182ac:	680c      	ldr	r4, [r1, #0]
   182ae:	105b      	asrs	r3, r3, #1
   182b0:	ea4f 0232 	mov.w	r2, r2, rrx
   182b4:	1aa2      	subs	r2, r4, r2
   182b6:	4416      	add	r6, r2
        for( n = k; n > 1; n-- ) {
   182b8:	4549      	cmp	r1, r9
            out[n] += out[n-2] - (opus_int32)silk_RSHIFT_ROUND64( silk_SMULL( ftmp, out[n-1] ), QA );
   182ba:	6006      	str	r6, [r0, #0]
        for( n = k; n > 1; n-- ) {
   182bc:	d1e8      	bne.n	18290 <silk_NLSF2A+0x28c>
        out[1] -= ftmp;
   182be:	9b1a      	ldr	r3, [sp, #104]	; 0x68
    for( k = 1; k < dd; k++ ) {
   182c0:	9a05      	ldr	r2, [sp, #20]
   182c2:	9906      	ldr	r1, [sp, #24]
        out[1] -= ftmp;
   182c4:	eba3 030e 	sub.w	r3, r3, lr
   182c8:	931a      	str	r3, [sp, #104]	; 0x68
    for( k = 1; k < dd; k++ ) {
   182ca:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   182cc:	3201      	adds	r2, #1
   182ce:	3108      	adds	r1, #8
   182d0:	429a      	cmp	r2, r3
   182d2:	9205      	str	r2, [sp, #20]
   182d4:	9106      	str	r1, [sp, #24]
   182d6:	f47f af78 	bne.w	181ca <silk_NLSF2A+0x1c6>
   182da:	e003      	b.n	182e4 <silk_NLSF2A+0x2e0>
   182dc:	000374d8 	.word	0x000374d8
   182e0:	000373d4 	.word	0x000373d4
   182e4:	9b07      	ldr	r3, [sp, #28]
   182e6:	2b02      	cmp	r3, #2
   182e8:	f103 35ff 	add.w	r5, r3, #4294967295	; 0xffffffff
   182ec:	f340 8243 	ble.w	18776 <silk_NLSF2A+0x772>
    silk_NLSF2A_find_poly( Q, &cos_LSF_QA[ 1 ], dd );

    /* convert even and odd polynomials to opus_int32 Q12 filter coefs */
    for( k = 0; k < dd; k++ ) {
        Ptmp = P[ k+1 ] + P[ k ];
        Qtmp = Q[ k+1 ] - Q[ k ];
   182f0:	e9dd 1319 	ldrd	r1, r3, [sp, #100]	; 0x64
        Ptmp = P[ k+1 ] + P[ k ];
   182f4:	e9da 4600 	ldrd	r4, r6, [sl]
        Qtmp = Q[ k+1 ] - Q[ k ];
   182f8:	1a59      	subs	r1, r3, r1
        Ptmp = P[ k+1 ] + P[ k ];
   182fa:	4434      	add	r4, r6

        /* the Ptmp and Qtmp values at this stage need to fit in int32 */
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   182fc:	424f      	negs	r7, r1
        Qtmp = Q[ k+1 ] - Q[ k ];
   182fe:	981b      	ldr	r0, [sp, #108]	; 0x6c
        Ptmp = P[ k+1 ] + P[ k ];
   18300:	f8da 2008 	ldr.w	r2, [sl, #8]
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   18304:	1b3f      	subs	r7, r7, r4
   18306:	973e      	str	r7, [sp, #248]	; 0xf8
        Qtmp = Q[ k+1 ] - Q[ k ];
   18308:	1ac3      	subs	r3, r0, r3
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   1830a:	9f09      	ldr	r7, [sp, #36]	; 0x24
        Ptmp = P[ k+1 ] + P[ k ];
   1830c:	4416      	add	r6, r2
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   1830e:	1b0c      	subs	r4, r1, r4
   18310:	f50d 7cac 	add.w	ip, sp, #344	; 0x158
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   18314:	4259      	negs	r1, r3
   18316:	1b89      	subs	r1, r1, r6
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   18318:	1b9b      	subs	r3, r3, r6
   1831a:	eb0c 0687 	add.w	r6, ip, r7, lsl #2
   1831e:	2d03      	cmp	r5, #3
   18320:	f846 4c64 	str.w	r4, [r6, #-100]
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   18324:	913f      	str	r1, [sp, #252]	; 0xfc
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   18326:	f846 3c68 	str.w	r3, [r6, #-104]
   1832a:	f340 821e 	ble.w	1876a <silk_NLSF2A+0x766>
        Qtmp = Q[ k+1 ] - Q[ k ];
   1832e:	e9dd 341c 	ldrd	r3, r4, [sp, #112]	; 0x70
        Ptmp = P[ k+1 ] + P[ k ];
   18332:	e9da 1603 	ldrd	r1, r6, [sl, #12]
        Qtmp = Q[ k+1 ] - Q[ k ];
   18336:	1a18      	subs	r0, r3, r0
        Ptmp = P[ k+1 ] + P[ k ];
   18338:	440a      	add	r2, r1
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   1833a:	4247      	negs	r7, r0
   1833c:	1abf      	subs	r7, r7, r2
   1833e:	9740      	str	r7, [sp, #256]	; 0x100
        Qtmp = Q[ k+1 ] - Q[ k ];
   18340:	1ae3      	subs	r3, r4, r3
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   18342:	9f09      	ldr	r7, [sp, #36]	; 0x24
        Ptmp = P[ k+1 ] + P[ k ];
   18344:	4431      	add	r1, r6
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   18346:	1a82      	subs	r2, r0, r2
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   18348:	4258      	negs	r0, r3
   1834a:	1a40      	subs	r0, r0, r1
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   1834c:	1a5b      	subs	r3, r3, r1
   1834e:	eb0c 0187 	add.w	r1, ip, r7, lsl #2
   18352:	2d05      	cmp	r5, #5
   18354:	f841 2c6c 	str.w	r2, [r1, #-108]
   18358:	eb0c 0287 	add.w	r2, ip, r7, lsl #2
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   1835c:	9041      	str	r0, [sp, #260]	; 0x104
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   1835e:	f842 3c70 	str.w	r3, [r2, #-112]
   18362:	f340 8205 	ble.w	18770 <silk_NLSF2A+0x76c>
        Qtmp = Q[ k+1 ] - Q[ k ];
   18366:	e9dd 311e 	ldrd	r3, r1, [sp, #120]	; 0x78
        Ptmp = P[ k+1 ] + P[ k ];
   1836a:	e9da 0705 	ldrd	r0, r7, [sl, #20]
        Qtmp = Q[ k+1 ] - Q[ k ];
   1836e:	1b1c      	subs	r4, r3, r4
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   18370:	f1c4 0c00 	rsb	ip, r4, #0
        Ptmp = P[ k+1 ] + P[ k ];
   18374:	1832      	adds	r2, r6, r0
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   18376:	ebac 0602 	sub.w	r6, ip, r2
   1837a:	9642      	str	r6, [sp, #264]	; 0x108
        Qtmp = Q[ k+1 ] - Q[ k ];
   1837c:	1acb      	subs	r3, r1, r3
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   1837e:	9e09      	ldr	r6, [sp, #36]	; 0x24
        Ptmp = P[ k+1 ] + P[ k ];
   18380:	4438      	add	r0, r7
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   18382:	1aa2      	subs	r2, r4, r2
   18384:	f50d 7cac 	add.w	ip, sp, #344	; 0x158
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   18388:	425c      	negs	r4, r3
   1838a:	1a24      	subs	r4, r4, r0
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   1838c:	1a1b      	subs	r3, r3, r0
   1838e:	eb0c 0086 	add.w	r0, ip, r6, lsl #2
   18392:	2d07      	cmp	r5, #7
   18394:	f840 2c74 	str.w	r2, [r0, #-116]
   18398:	eb0c 0286 	add.w	r2, ip, r6, lsl #2
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   1839c:	9443      	str	r4, [sp, #268]	; 0x10c
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   1839e:	f842 3c78 	str.w	r3, [r2, #-120]
   183a2:	f340 81d9 	ble.w	18758 <silk_NLSF2A+0x754>
        Qtmp = Q[ k+1 ] - Q[ k ];
   183a6:	e9dd 3020 	ldrd	r3, r0, [sp, #128]	; 0x80
        Ptmp = P[ k+1 ] + P[ k ];
   183aa:	e9da 4607 	ldrd	r4, r6, [sl, #28]
        Qtmp = Q[ k+1 ] - Q[ k ];
   183ae:	1a59      	subs	r1, r3, r1
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   183b0:	f1c1 0c00 	rsb	ip, r1, #0
        Ptmp = P[ k+1 ] + P[ k ];
   183b4:	193a      	adds	r2, r7, r4
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   183b6:	ebac 0702 	sub.w	r7, ip, r2
   183ba:	9744      	str	r7, [sp, #272]	; 0x110
        Qtmp = Q[ k+1 ] - Q[ k ];
   183bc:	1ac3      	subs	r3, r0, r3
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   183be:	9f09      	ldr	r7, [sp, #36]	; 0x24
        Ptmp = P[ k+1 ] + P[ k ];
   183c0:	4434      	add	r4, r6
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   183c2:	1a8a      	subs	r2, r1, r2
   183c4:	f50d 7cac 	add.w	ip, sp, #344	; 0x158
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   183c8:	4259      	negs	r1, r3
   183ca:	1b09      	subs	r1, r1, r4
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   183cc:	1b1b      	subs	r3, r3, r4
   183ce:	eb0c 0487 	add.w	r4, ip, r7, lsl #2
   183d2:	2d09      	cmp	r5, #9
   183d4:	f844 2c7c 	str.w	r2, [r4, #-124]
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   183d8:	9145      	str	r1, [sp, #276]	; 0x114
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   183da:	f844 3c80 	str.w	r3, [r4, #-128]
   183de:	f340 81cd 	ble.w	1877c <silk_NLSF2A+0x778>
        Qtmp = Q[ k+1 ] - Q[ k ];
   183e2:	e9dd 3122 	ldrd	r3, r1, [sp, #136]	; 0x88
        Ptmp = P[ k+1 ] + P[ k ];
   183e6:	e9da c409 	ldrd	ip, r4, [sl, #36]	; 0x24
        Qtmp = Q[ k+1 ] - Q[ k ];
   183ea:	1a18      	subs	r0, r3, r0
        Ptmp = P[ k+1 ] + P[ k ];
   183ec:	eb06 020c 	add.w	r2, r6, ip
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   183f0:	4247      	negs	r7, r0
   183f2:	1abf      	subs	r7, r7, r2
   183f4:	9746      	str	r7, [sp, #280]	; 0x118
        Qtmp = Q[ k+1 ] - Q[ k ];
   183f6:	1acb      	subs	r3, r1, r3
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   183f8:	9f09      	ldr	r7, [sp, #36]	; 0x24
        Ptmp = P[ k+1 ] + P[ k ];
   183fa:	eb0c 0604 	add.w	r6, ip, r4
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   183fe:	1a82      	subs	r2, r0, r2
   18400:	f50d 7cac 	add.w	ip, sp, #344	; 0x158
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   18404:	4258      	negs	r0, r3
   18406:	1b80      	subs	r0, r0, r6
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   18408:	1b9b      	subs	r3, r3, r6
   1840a:	eb0c 0687 	add.w	r6, ip, r7, lsl #2
   1840e:	2d0b      	cmp	r5, #11
   18410:	f846 2c84 	str.w	r2, [r6, #-132]
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   18414:	9047      	str	r0, [sp, #284]	; 0x11c
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   18416:	f846 3c88 	str.w	r3, [r6, #-136]
   1841a:	f340 81b2 	ble.w	18782 <silk_NLSF2A+0x77e>
        Qtmp = Q[ k+1 ] - Q[ k ];
   1841e:	e9dd 2324 	ldrd	r2, r3, [sp, #144]	; 0x90
        Ptmp = P[ k+1 ] + P[ k ];
   18422:	e9da 500b 	ldrd	r5, r0, [sl, #44]	; 0x2c
        Qtmp = Q[ k+1 ] - Q[ k ];
   18426:	1a51      	subs	r1, r2, r1
   18428:	1a9b      	subs	r3, r3, r2
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   1842a:	424e      	negs	r6, r1
        Ptmp = P[ k+1 ] + P[ k ];
   1842c:	192a      	adds	r2, r5, r4
   1842e:	4428      	add	r0, r5
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   18430:	1ab6      	subs	r6, r6, r2
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   18432:	1a8a      	subs	r2, r1, r2
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   18434:	4259      	negs	r1, r3
   18436:	1a09      	subs	r1, r1, r0
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   18438:	1a18      	subs	r0, r3, r0
   1843a:	eb0c 0387 	add.w	r3, ip, r7, lsl #2
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   1843e:	9648      	str	r6, [sp, #288]	; 0x120
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   18440:	f843 2c8c 	str.w	r2, [r3, #-140]
   18444:	eb0c 0287 	add.w	r2, ip, r7, lsl #2
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   18448:	9149      	str	r1, [sp, #292]	; 0x124
        Ptmp = P[ k+1 ] + P[ k ];
   1844a:	f04f 090c 	mov.w	r9, #12
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   1844e:	f842 0c90 	str.w	r0, [r2, #-144]
        Ptmp = P[ k+1 ] + P[ k ];
   18452:	f109 0201 	add.w	r2, r9, #1
        Qtmp = Q[ k+1 ] - Q[ k ];
   18456:	ab56      	add	r3, sp, #344	; 0x158
   18458:	eb03 0c89 	add.w	ip, r3, r9, lsl #2
   1845c:	eb03 0682 	add.w	r6, r3, r2, lsl #2
   18460:	f85c 1cf4 	ldr.w	r1, [ip, #-244]
   18464:	f856 4cf4 	ldr.w	r4, [r6, #-244]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   18468:	9b09      	ldr	r3, [sp, #36]	; 0x24
        Ptmp = P[ k+1 ] + P[ k ];
   1846a:	f85a 5022 	ldr.w	r5, [sl, r2, lsl #2]
   1846e:	f85a 0029 	ldr.w	r0, [sl, r9, lsl #2]
        Qtmp = Q[ k+1 ] - Q[ k ];
   18472:	1a61      	subs	r1, r4, r1
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   18474:	eba3 0709 	sub.w	r7, r3, r9
   18478:	f50d 78ac 	add.w	r8, sp, #344	; 0x158
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   1847c:	f1c1 0e00 	rsb	lr, r1, #0
        Ptmp = P[ k+1 ] + P[ k ];
   18480:	4428      	add	r0, r5
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   18482:	eb08 0787 	add.w	r7, r8, r7, lsl #2
   18486:	1a09      	subs	r1, r1, r0
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   18488:	ebae 0e00 	sub.w	lr, lr, r0
   1848c:	f84c ec60 	str.w	lr, [ip, #-96]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   18490:	f847 1c64 	str.w	r1, [r7, #-100]
    for( k = 0; k < dd; k++ ) {
   18494:	9907      	ldr	r1, [sp, #28]
   18496:	4291      	cmp	r1, r2
   18498:	f340 8120 	ble.w	186dc <silk_NLSF2A+0x6d8>
        Ptmp = P[ k+1 ] + P[ k ];
   1849c:	f109 0102 	add.w	r1, r9, #2
        Qtmp = Q[ k+1 ] - Q[ k ];
   184a0:	eb08 0781 	add.w	r7, r8, r1, lsl #2
        Ptmp = P[ k+1 ] + P[ k ];
   184a4:	f85a 0021 	ldr.w	r0, [sl, r1, lsl #2]
        Qtmp = Q[ k+1 ] - Q[ k ];
   184a8:	f857 ccf4 	ldr.w	ip, [r7, #-244]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   184ac:	1a9a      	subs	r2, r3, r2
        Qtmp = Q[ k+1 ] - Q[ k ];
   184ae:	ebac 0404 	sub.w	r4, ip, r4
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   184b2:	eb08 0282 	add.w	r2, r8, r2, lsl #2
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   184b6:	f1c4 0e00 	rsb	lr, r4, #0
        Ptmp = P[ k+1 ] + P[ k ];
   184ba:	4405      	add	r5, r0
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   184bc:	ebae 0e05 	sub.w	lr, lr, r5
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   184c0:	1b64      	subs	r4, r4, r5
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   184c2:	f846 ec60 	str.w	lr, [r6, #-96]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   184c6:	f842 4c64 	str.w	r4, [r2, #-100]
    for( k = 0; k < dd; k++ ) {
   184ca:	9a07      	ldr	r2, [sp, #28]
   184cc:	428a      	cmp	r2, r1
   184ce:	f340 8105 	ble.w	186dc <silk_NLSF2A+0x6d8>
        Ptmp = P[ k+1 ] + P[ k ];
   184d2:	f109 0403 	add.w	r4, r9, #3
        Qtmp = Q[ k+1 ] - Q[ k ];
   184d6:	eb08 0684 	add.w	r6, r8, r4, lsl #2
        Ptmp = P[ k+1 ] + P[ k ];
   184da:	f85a 5024 	ldr.w	r5, [sl, r4, lsl #2]
        Qtmp = Q[ k+1 ] - Q[ k ];
   184de:	f856 ecf4 	ldr.w	lr, [r6, #-244]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   184e2:	1a5a      	subs	r2, r3, r1
        Qtmp = Q[ k+1 ] - Q[ k ];
   184e4:	ebae 0c0c 	sub.w	ip, lr, ip
        Ptmp = P[ k+1 ] + P[ k ];
   184e8:	4428      	add	r0, r5
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   184ea:	eb08 0282 	add.w	r2, r8, r2, lsl #2
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   184ee:	f1cc 0100 	rsb	r1, ip, #0
   184f2:	1a09      	subs	r1, r1, r0
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   184f4:	ebac 0000 	sub.w	r0, ip, r0
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   184f8:	f847 1c60 	str.w	r1, [r7, #-96]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   184fc:	f842 0c64 	str.w	r0, [r2, #-100]
    for( k = 0; k < dd; k++ ) {
   18500:	9807      	ldr	r0, [sp, #28]
   18502:	42a0      	cmp	r0, r4
   18504:	f340 80ea 	ble.w	186dc <silk_NLSF2A+0x6d8>
        Ptmp = P[ k+1 ] + P[ k ];
   18508:	f109 0104 	add.w	r1, r9, #4
        Qtmp = Q[ k+1 ] - Q[ k ];
   1850c:	eb08 0781 	add.w	r7, r8, r1, lsl #2
        Ptmp = P[ k+1 ] + P[ k ];
   18510:	f85a 0021 	ldr.w	r0, [sl, r1, lsl #2]
        Qtmp = Q[ k+1 ] - Q[ k ];
   18514:	f857 ccf4 	ldr.w	ip, [r7, #-244]
   18518:	ebac 0e0e 	sub.w	lr, ip, lr
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   1851c:	1b1a      	subs	r2, r3, r4
        Ptmp = P[ k+1 ] + P[ k ];
   1851e:	4405      	add	r5, r0
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   18520:	f1ce 0400 	rsb	r4, lr, #0
   18524:	1b64      	subs	r4, r4, r5
   18526:	f846 4c60 	str.w	r4, [r6, #-96]
    for( k = 0; k < dd; k++ ) {
   1852a:	9c07      	ldr	r4, [sp, #28]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   1852c:	eb08 0282 	add.w	r2, r8, r2, lsl #2
   18530:	ebae 0505 	sub.w	r5, lr, r5
    for( k = 0; k < dd; k++ ) {
   18534:	428c      	cmp	r4, r1
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   18536:	f842 5c64 	str.w	r5, [r2, #-100]
    for( k = 0; k < dd; k++ ) {
   1853a:	f340 80cf 	ble.w	186dc <silk_NLSF2A+0x6d8>
        Ptmp = P[ k+1 ] + P[ k ];
   1853e:	f109 0405 	add.w	r4, r9, #5
        Qtmp = Q[ k+1 ] - Q[ k ];
   18542:	eb08 0684 	add.w	r6, r8, r4, lsl #2
        Ptmp = P[ k+1 ] + P[ k ];
   18546:	f85a 5024 	ldr.w	r5, [sl, r4, lsl #2]
        Qtmp = Q[ k+1 ] - Q[ k ];
   1854a:	f856 ecf4 	ldr.w	lr, [r6, #-244]
   1854e:	ebae 0c0c 	sub.w	ip, lr, ip
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   18552:	1a5a      	subs	r2, r3, r1
        Ptmp = P[ k+1 ] + P[ k ];
   18554:	4428      	add	r0, r5
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   18556:	f1cc 0100 	rsb	r1, ip, #0
   1855a:	1a09      	subs	r1, r1, r0
   1855c:	f847 1c60 	str.w	r1, [r7, #-96]
    for( k = 0; k < dd; k++ ) {
   18560:	9907      	ldr	r1, [sp, #28]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   18562:	eb08 0282 	add.w	r2, r8, r2, lsl #2
   18566:	ebac 0000 	sub.w	r0, ip, r0
    for( k = 0; k < dd; k++ ) {
   1856a:	42a1      	cmp	r1, r4
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   1856c:	f842 0c64 	str.w	r0, [r2, #-100]
    for( k = 0; k < dd; k++ ) {
   18570:	f340 80b4 	ble.w	186dc <silk_NLSF2A+0x6d8>
        Ptmp = P[ k+1 ] + P[ k ];
   18574:	f109 0106 	add.w	r1, r9, #6
        Qtmp = Q[ k+1 ] - Q[ k ];
   18578:	eb08 0781 	add.w	r7, r8, r1, lsl #2
        Ptmp = P[ k+1 ] + P[ k ];
   1857c:	f85a 0021 	ldr.w	r0, [sl, r1, lsl #2]
        Qtmp = Q[ k+1 ] - Q[ k ];
   18580:	f857 ccf4 	ldr.w	ip, [r7, #-244]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   18584:	1b1a      	subs	r2, r3, r4
        Qtmp = Q[ k+1 ] - Q[ k ];
   18586:	ebac 0e0e 	sub.w	lr, ip, lr
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   1858a:	eb08 0282 	add.w	r2, r8, r2, lsl #2
        Ptmp = P[ k+1 ] + P[ k ];
   1858e:	4405      	add	r5, r0
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   18590:	f1ce 0400 	rsb	r4, lr, #0
   18594:	1b64      	subs	r4, r4, r5
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   18596:	ebae 0505 	sub.w	r5, lr, r5
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   1859a:	f846 4c60 	str.w	r4, [r6, #-96]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   1859e:	f842 5c64 	str.w	r5, [r2, #-100]
    for( k = 0; k < dd; k++ ) {
   185a2:	9a07      	ldr	r2, [sp, #28]
   185a4:	428a      	cmp	r2, r1
   185a6:	f340 8099 	ble.w	186dc <silk_NLSF2A+0x6d8>
        Ptmp = P[ k+1 ] + P[ k ];
   185aa:	f109 0407 	add.w	r4, r9, #7
        Qtmp = Q[ k+1 ] - Q[ k ];
   185ae:	eb08 0684 	add.w	r6, r8, r4, lsl #2
        Ptmp = P[ k+1 ] + P[ k ];
   185b2:	f85a 5024 	ldr.w	r5, [sl, r4, lsl #2]
        Qtmp = Q[ k+1 ] - Q[ k ];
   185b6:	f856 ecf4 	ldr.w	lr, [r6, #-244]
   185ba:	ebae 0c0c 	sub.w	ip, lr, ip
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   185be:	1a5a      	subs	r2, r3, r1
        Ptmp = P[ k+1 ] + P[ k ];
   185c0:	4428      	add	r0, r5
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   185c2:	f1cc 0100 	rsb	r1, ip, #0
   185c6:	1a09      	subs	r1, r1, r0
   185c8:	f847 1c60 	str.w	r1, [r7, #-96]
    for( k = 0; k < dd; k++ ) {
   185cc:	9907      	ldr	r1, [sp, #28]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   185ce:	eb08 0282 	add.w	r2, r8, r2, lsl #2
   185d2:	ebac 0000 	sub.w	r0, ip, r0
    for( k = 0; k < dd; k++ ) {
   185d6:	42a1      	cmp	r1, r4
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   185d8:	f842 0c64 	str.w	r0, [r2, #-100]
    for( k = 0; k < dd; k++ ) {
   185dc:	dd7e      	ble.n	186dc <silk_NLSF2A+0x6d8>
        Ptmp = P[ k+1 ] + P[ k ];
   185de:	f109 0108 	add.w	r1, r9, #8
        Qtmp = Q[ k+1 ] - Q[ k ];
   185e2:	eb08 0781 	add.w	r7, r8, r1, lsl #2
        Ptmp = P[ k+1 ] + P[ k ];
   185e6:	f85a 0021 	ldr.w	r0, [sl, r1, lsl #2]
        Qtmp = Q[ k+1 ] - Q[ k ];
   185ea:	f857 ccf4 	ldr.w	ip, [r7, #-244]
   185ee:	ebac 0e0e 	sub.w	lr, ip, lr
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   185f2:	1b1a      	subs	r2, r3, r4
        Ptmp = P[ k+1 ] + P[ k ];
   185f4:	4405      	add	r5, r0
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   185f6:	f1ce 0400 	rsb	r4, lr, #0
   185fa:	1b64      	subs	r4, r4, r5
   185fc:	f846 4c60 	str.w	r4, [r6, #-96]
    for( k = 0; k < dd; k++ ) {
   18600:	9c07      	ldr	r4, [sp, #28]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   18602:	eb08 0282 	add.w	r2, r8, r2, lsl #2
   18606:	ebae 0505 	sub.w	r5, lr, r5
    for( k = 0; k < dd; k++ ) {
   1860a:	428c      	cmp	r4, r1
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   1860c:	f842 5c64 	str.w	r5, [r2, #-100]
    for( k = 0; k < dd; k++ ) {
   18610:	dd64      	ble.n	186dc <silk_NLSF2A+0x6d8>
        Ptmp = P[ k+1 ] + P[ k ];
   18612:	f109 0409 	add.w	r4, r9, #9
        Qtmp = Q[ k+1 ] - Q[ k ];
   18616:	eb08 0684 	add.w	r6, r8, r4, lsl #2
        Ptmp = P[ k+1 ] + P[ k ];
   1861a:	f85a 5024 	ldr.w	r5, [sl, r4, lsl #2]
        Qtmp = Q[ k+1 ] - Q[ k ];
   1861e:	f856 ecf4 	ldr.w	lr, [r6, #-244]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   18622:	1a5a      	subs	r2, r3, r1
        Qtmp = Q[ k+1 ] - Q[ k ];
   18624:	ebae 0c0c 	sub.w	ip, lr, ip
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   18628:	eb08 0282 	add.w	r2, r8, r2, lsl #2
        Ptmp = P[ k+1 ] + P[ k ];
   1862c:	4428      	add	r0, r5
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   1862e:	f1cc 0100 	rsb	r1, ip, #0
   18632:	1a09      	subs	r1, r1, r0
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   18634:	ebac 0000 	sub.w	r0, ip, r0
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   18638:	f847 1c60 	str.w	r1, [r7, #-96]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   1863c:	f842 0c64 	str.w	r0, [r2, #-100]
    for( k = 0; k < dd; k++ ) {
   18640:	9a07      	ldr	r2, [sp, #28]
   18642:	42a2      	cmp	r2, r4
   18644:	dd4a      	ble.n	186dc <silk_NLSF2A+0x6d8>
        Ptmp = P[ k+1 ] + P[ k ];
   18646:	f109 010a 	add.w	r1, r9, #10
        Qtmp = Q[ k+1 ] - Q[ k ];
   1864a:	ea4f 0c81 	mov.w	ip, r1, lsl #2
   1864e:	eb08 020c 	add.w	r2, r8, ip
        Ptmp = P[ k+1 ] + P[ k ];
   18652:	f85a 7021 	ldr.w	r7, [sl, r1, lsl #2]
        Qtmp = Q[ k+1 ] - Q[ k ];
   18656:	f852 0cf4 	ldr.w	r0, [r2, #-244]
   1865a:	eba0 0e0e 	sub.w	lr, r0, lr
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   1865e:	1b1a      	subs	r2, r3, r4
        Ptmp = P[ k+1 ] + P[ k ];
   18660:	443d      	add	r5, r7
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   18662:	f1ce 0400 	rsb	r4, lr, #0
   18666:	1b64      	subs	r4, r4, r5
   18668:	f846 4c60 	str.w	r4, [r6, #-96]
    for( k = 0; k < dd; k++ ) {
   1866c:	9c07      	ldr	r4, [sp, #28]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   1866e:	eb08 0282 	add.w	r2, r8, r2, lsl #2
   18672:	ebae 0505 	sub.w	r5, lr, r5
    for( k = 0; k < dd; k++ ) {
   18676:	428c      	cmp	r4, r1
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   18678:	f842 5c64 	str.w	r5, [r2, #-100]
    for( k = 0; k < dd; k++ ) {
   1867c:	dd2e      	ble.n	186dc <silk_NLSF2A+0x6d8>
        Ptmp = P[ k+1 ] + P[ k ];
   1867e:	f109 020b 	add.w	r2, r9, #11
        Qtmp = Q[ k+1 ] - Q[ k ];
   18682:	eb08 0582 	add.w	r5, r8, r2, lsl #2
        Ptmp = P[ k+1 ] + P[ k ];
   18686:	f85a 4022 	ldr.w	r4, [sl, r2, lsl #2]
        Qtmp = Q[ k+1 ] - Q[ k ];
   1868a:	f855 6cf4 	ldr.w	r6, [r5, #-244]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   1868e:	1a59      	subs	r1, r3, r1
        Qtmp = Q[ k+1 ] - Q[ k ];
   18690:	1a30      	subs	r0, r6, r0
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   18692:	eb08 0181 	add.w	r1, r8, r1, lsl #2
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   18696:	f1c0 0e00 	rsb	lr, r0, #0
        Ptmp = P[ k+1 ] + P[ k ];
   1869a:	4427      	add	r7, r4
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   1869c:	44c4      	add	ip, r8
   1869e:	ebae 0e07 	sub.w	lr, lr, r7
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   186a2:	1bc0      	subs	r0, r0, r7
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   186a4:	f84c ec60 	str.w	lr, [ip, #-96]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   186a8:	f841 0c64 	str.w	r0, [r1, #-100]
    for( k = 0; k < dd; k++ ) {
   186ac:	9907      	ldr	r1, [sp, #28]
   186ae:	4291      	cmp	r1, r2
   186b0:	dd14      	ble.n	186dc <silk_NLSF2A+0x6d8>
        Ptmp = P[ k+1 ] + P[ k ];
   186b2:	f109 030c 	add.w	r3, r9, #12
        Qtmp = Q[ k+1 ] - Q[ k ];
   186b6:	eb08 0183 	add.w	r1, r8, r3, lsl #2
        Ptmp = P[ k+1 ] + P[ k ];
   186ba:	f85a 0023 	ldr.w	r0, [sl, r3, lsl #2]
        Qtmp = Q[ k+1 ] - Q[ k ];
   186be:	f851 1cf4 	ldr.w	r1, [r1, #-244]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   186c2:	9b09      	ldr	r3, [sp, #36]	; 0x24
        Qtmp = Q[ k+1 ] - Q[ k ];
   186c4:	1b8e      	subs	r6, r1, r6
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   186c6:	1a9b      	subs	r3, r3, r2
        Ptmp = P[ k+1 ] + P[ k ];
   186c8:	4404      	add	r4, r0
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   186ca:	4272      	negs	r2, r6
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   186cc:	eb08 0383 	add.w	r3, r8, r3, lsl #2
   186d0:	1b36      	subs	r6, r6, r4
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
   186d2:	1b14      	subs	r4, r2, r4
   186d4:	f845 4c60 	str.w	r4, [r5, #-96]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
   186d8:	f843 6c64 	str.w	r6, [r3, #-100]
    }

    /* Convert int32 coefficients to Q12 int16 coefs */
    silk_LPC_fit( a_Q12, a32_QA1, 12, QA + 1, d );
   186dc:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
   186e0:	9c09      	ldr	r4, [sp, #36]	; 0x24
   186e2:	9400      	str	r4, [sp, #0]
   186e4:	a93e      	add	r1, sp, #248	; 0xf8
   186e6:	2311      	movs	r3, #17
   186e8:	4648      	mov	r0, r9
   186ea:	220c      	movs	r2, #12
   186ec:	f001 ff36 	bl	1a55c <silk_LPC_fit>
   186f0:	4623      	mov	r3, r4
   186f2:	4698      	mov	r8, r3
   186f4:	f1a9 0602 	sub.w	r6, r9, #2

    for( i = 0; silk_LPC_inverse_pred_gain( a_Q12, d, arch ) == 0 && i < MAX_LPC_STABILIZE_ITERATIONS; i++ ) {
   186f8:	4641      	mov	r1, r8
   186fa:	4648      	mov	r0, r9
   186fc:	eb06 0744 	add.w	r7, r6, r4, lsl #1
        /* Prediction coefficients are (too close to) unstable; apply bandwidth expansion   */
        /* on the unscaled coefficients, convert to Q12 and measure again                   */
        silk_bwexpander_32( a32_QA1, d, 65536 - silk_LSHIFT( 2, i ) );
   18700:	2502      	movs	r5, #2
    for( i = 0; silk_LPC_inverse_pred_gain( a_Q12, d, arch ) == 0 && i < MAX_LPC_STABILIZE_ITERATIONS; i++ ) {
   18702:	2400      	movs	r4, #0
   18704:	f7ff fa32 	bl	17b6c <silk_LPC_inverse_pred_gain_c>
   18708:	b9f0      	cbnz	r0, 18748 <silk_NLSF2A+0x744>
   1870a:	2c10      	cmp	r4, #16
   1870c:	d01c      	beq.n	18748 <silk_NLSF2A+0x744>
        silk_bwexpander_32( a32_QA1, d, 65536 - silk_LSHIFT( 2, i ) );
   1870e:	fa05 f204 	lsl.w	r2, r5, r4
   18712:	f5c2 3280 	rsb	r2, r2, #65536	; 0x10000
   18716:	4641      	mov	r1, r8
   18718:	a83e      	add	r0, sp, #248	; 0xf8
   1871a:	f7ff f8d1 	bl	178c0 <silk_bwexpander_32>
        for( k = 0; k < d; k++ ) {
   1871e:	f1b8 0f00 	cmp.w	r8, #0
   18722:	dd0a      	ble.n	1873a <silk_NLSF2A+0x736>
   18724:	a93e      	add	r1, sp, #248	; 0xf8
   18726:	4632      	mov	r2, r6
            a_Q12[ k ] = (opus_int16)silk_RSHIFT_ROUND( a32_QA1[ k ], QA + 1 - 12 );            /* QA+1 -> Q12 */
   18728:	f851 3b04 	ldr.w	r3, [r1], #4
   1872c:	111b      	asrs	r3, r3, #4
   1872e:	3301      	adds	r3, #1
   18730:	105b      	asrs	r3, r3, #1
   18732:	f822 3f02 	strh.w	r3, [r2, #2]!
        for( k = 0; k < d; k++ ) {
   18736:	42ba      	cmp	r2, r7
   18738:	d1f6      	bne.n	18728 <silk_NLSF2A+0x724>
    for( i = 0; silk_LPC_inverse_pred_gain( a_Q12, d, arch ) == 0 && i < MAX_LPC_STABILIZE_ITERATIONS; i++ ) {
   1873a:	4641      	mov	r1, r8
   1873c:	4648      	mov	r0, r9
   1873e:	3401      	adds	r4, #1
   18740:	f7ff fa14 	bl	17b6c <silk_LPC_inverse_pred_gain_c>
   18744:	2800      	cmp	r0, #0
   18746:	d0e0      	beq.n	1870a <silk_NLSF2A+0x706>
        }
    }
}
   18748:	b057      	add	sp, #348	; 0x15c
   1874a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        for( n = k; n > 1; n-- ) {
   1874e:	4644      	mov	r4, r8
   18750:	e501      	b.n	18156 <silk_NLSF2A+0x152>
    ordering = d == 16 ? ordering16 : ordering10;
   18752:	4d0d      	ldr	r5, [pc, #52]	; (18788 <silk_NLSF2A+0x784>)
   18754:	4617      	mov	r7, r2
   18756:	e461      	b.n	1801c <silk_NLSF2A+0x18>
        Ptmp = P[ k+1 ] + P[ k ];
   18758:	f04f 0906 	mov.w	r9, #6
   1875c:	e679      	b.n	18452 <silk_NLSF2A+0x44e>
    out[1] = -cLSF[0];
   1875e:	e9cd 2319 	strd	r2, r3, [sp, #100]	; 0x64
    for( k = 0; k < dd; k++ ) {
   18762:	9b07      	ldr	r3, [sp, #28]
   18764:	2b00      	cmp	r3, #0
   18766:	ddb9      	ble.n	186dc <silk_NLSF2A+0x6d8>
   18768:	e5bc      	b.n	182e4 <silk_NLSF2A+0x2e0>
        Ptmp = P[ k+1 ] + P[ k ];
   1876a:	f04f 0902 	mov.w	r9, #2
   1876e:	e670      	b.n	18452 <silk_NLSF2A+0x44e>
   18770:	f04f 0904 	mov.w	r9, #4
   18774:	e66d      	b.n	18452 <silk_NLSF2A+0x44e>
        for( n = k; n > 1; n-- ) {
   18776:	f04f 0900 	mov.w	r9, #0
   1877a:	e66a      	b.n	18452 <silk_NLSF2A+0x44e>
        Ptmp = P[ k+1 ] + P[ k ];
   1877c:	f04f 0908 	mov.w	r9, #8
   18780:	e667      	b.n	18452 <silk_NLSF2A+0x44e>
   18782:	f04f 090a 	mov.w	r9, #10
   18786:	e664      	b.n	18452 <silk_NLSF2A+0x44e>
   18788:	000374e4 	.word	0x000374e4

0001878c <silk_NLSF_stabilize>:
void silk_NLSF_stabilize(
          opus_int16            *NLSF_Q15,          /* I/O   Unstable/stabilized normalized LSF vector in Q15 [L]       */
    const opus_int16            *NDeltaMin_Q15,     /* I     Min distance vector, NDeltaMin_Q15[L] must be >= 1 [L+1]   */
    const opus_int              L                   /* I     Number of NLSF parameters in the input vector              */
)
{
   1878c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   18790:	4694      	mov	ip, r2
   18792:	b089      	sub	sp, #36	; 0x24
                min_diff_Q15 = diff_Q15;
                I = i;
            }
        }
        /* Last element */
        diff_Q15 = ( 1 << 15 ) - ( NLSF_Q15[L-1] + NDeltaMin_Q15[L] );
   18794:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
   18798:	eb0c 0302 	add.w	r3, ip, r2
   1879c:	9307      	str	r3, [sp, #28]
   1879e:	005b      	lsls	r3, r3, #1
   187a0:	1c9d      	adds	r5, r3, #2
   187a2:	1d1c      	adds	r4, r3, #4
   187a4:	9203      	str	r2, [sp, #12]
   187a6:	18c3      	adds	r3, r0, r3
   187a8:	194a      	adds	r2, r1, r5
   187aa:	9202      	str	r2, [sp, #8]
   187ac:	9301      	str	r3, [sp, #4]
   187ae:	190a      	adds	r2, r1, r4
   187b0:	1c8b      	adds	r3, r1, #2
   187b2:	9506      	str	r5, [sp, #24]
   187b4:	9204      	str	r2, [sp, #16]
   187b6:	f10c 3eff 	add.w	lr, ip, #4294967295	; 0xffffffff
   187ba:	9305      	str	r3, [sp, #20]
   187bc:	f04f 0814 	mov.w	r8, #20
        min_diff_Q15 = NLSF_Q15[0] - NDeltaMin_Q15[0];
   187c0:	f9b0 4000 	ldrsh.w	r4, [r0]
   187c4:	f9b1 9000 	ldrsh.w	r9, [r1]
        for( i = 1; i <= L-1; i++ ) {
   187c8:	f1bc 0f01 	cmp.w	ip, #1
        min_diff_Q15 = NLSF_Q15[0] - NDeltaMin_Q15[0];
   187cc:	eba4 0309 	sub.w	r3, r4, r9
        for( i = 1; i <= L-1; i++ ) {
   187d0:	f340 80e9 	ble.w	189a6 <silk_NLSF_stabilize+0x21a>
   187d4:	f1bc 0f03 	cmp.w	ip, #3
   187d8:	f340 80f1 	ble.w	189be <silk_NLSF_stabilize+0x232>
   187dc:	f04f 0a02 	mov.w	sl, #2
        I = 0;
   187e0:	2700      	movs	r7, #0
        for( i = 1; i <= L-1; i++ ) {
   187e2:	2601      	movs	r6, #1
            diff_Q15 = NLSF_Q15[i] - ( NLSF_Q15[i-1] + NDeltaMin_Q15[i] );
   187e4:	f931 2016 	ldrsh.w	r2, [r1, r6, lsl #1]
   187e8:	f930 b016 	ldrsh.w	fp, [r0, r6, lsl #1]
   187ec:	4422      	add	r2, r4
   187ee:	ebab 0202 	sub.w	r2, fp, r2
            if( diff_Q15 < min_diff_Q15 ) {
   187f2:	429a      	cmp	r2, r3
   187f4:	bfa8      	it	ge
   187f6:	461a      	movge	r2, r3
            diff_Q15 = NLSF_Q15[i] - ( NLSF_Q15[i-1] + NDeltaMin_Q15[i] );
   187f8:	f931 301a 	ldrsh.w	r3, [r1, sl, lsl #1]
   187fc:	f930 401a 	ldrsh.w	r4, [r0, sl, lsl #1]
   18800:	445b      	add	r3, fp
   18802:	eba4 0303 	sub.w	r3, r4, r3
   18806:	4635      	mov	r5, r6
            if( diff_Q15 < min_diff_Q15 ) {
   18808:	bfa8      	it	ge
   1880a:	463e      	movge	r6, r7
   1880c:	4293      	cmp	r3, r2
        for( i = 1; i <= L-1; i++ ) {
   1880e:	4657      	mov	r7, sl
   18810:	f10a 0a02 	add.w	sl, sl, #2
            if( diff_Q15 < min_diff_Q15 ) {
   18814:	bfa4      	itt	ge
   18816:	4637      	movge	r7, r6
   18818:	4613      	movge	r3, r2
   1881a:	45d6      	cmp	lr, sl
   1881c:	f105 0602 	add.w	r6, r5, #2
   18820:	dce0      	bgt.n	187e4 <silk_NLSF_stabilize+0x58>
   18822:	9a03      	ldr	r2, [sp, #12]
   18824:	eb06 0b02 	add.w	fp, r6, r2
   18828:	ea4f 0b4b 	mov.w	fp, fp, lsl #1
   1882c:	eb00 0a0b 	add.w	sl, r0, fp
   18830:	448b      	add	fp, r1
            diff_Q15 = NLSF_Q15[i] - ( NLSF_Q15[i-1] + NDeltaMin_Q15[i] );
   18832:	f93a 2f02 	ldrsh.w	r2, [sl, #2]!
   18836:	f93b 5f02 	ldrsh.w	r5, [fp, #2]!
   1883a:	f93a 4c02 	ldrsh.w	r4, [sl, #-2]
   1883e:	442c      	add	r4, r5
   18840:	1b12      	subs	r2, r2, r4
            if( diff_Q15 < min_diff_Q15 ) {
   18842:	4293      	cmp	r3, r2
   18844:	bfc8      	it	gt
   18846:	4637      	movgt	r7, r6
        for( i = 1; i <= L-1; i++ ) {
   18848:	f106 0601 	add.w	r6, r6, #1
            if( diff_Q15 < min_diff_Q15 ) {
   1884c:	bfc8      	it	gt
   1884e:	4613      	movgt	r3, r2
        for( i = 1; i <= L-1; i++ ) {
   18850:	45b4      	cmp	ip, r6
   18852:	dcee      	bgt.n	18832 <silk_NLSF_stabilize+0xa6>
        diff_Q15 = ( 1 << 15 ) - ( NLSF_Q15[L-1] + NDeltaMin_Q15[L] );
   18854:	9a02      	ldr	r2, [sp, #8]
   18856:	f9b2 4000 	ldrsh.w	r4, [r2]
   1885a:	9a01      	ldr	r2, [sp, #4]
   1885c:	f9b2 2000 	ldrsh.w	r2, [r2]
   18860:	4422      	add	r2, r4
   18862:	f5c2 4200 	rsb	r2, r2, #32768	; 0x8000
        if( diff_Q15 < min_diff_Q15 ) {
   18866:	429a      	cmp	r2, r3
   18868:	bfac      	ite	ge
   1886a:	461a      	movge	r2, r3
   1886c:	4667      	movlt	r7, ip
        }

        /***************************************************/
        /* Now check if the smallest distance non-negative */
        /***************************************************/
        if( min_diff_Q15 >= 0 ) {
   1886e:	2a00      	cmp	r2, #0
   18870:	da56      	bge.n	18920 <silk_NLSF_stabilize+0x194>
            return;
        }

        if( I == 0 ) {
   18872:	2f00      	cmp	r7, #0
   18874:	d157      	bne.n	18926 <silk_NLSF_stabilize+0x19a>
            /* Move away from lower limit */
            NLSF_Q15[0] = NDeltaMin_Q15[0];
   18876:	f8a0 9000 	strh.w	r9, [r0]
    for( loops = 0; loops < MAX_LOOPS; loops++ ) {
   1887a:	f1b8 0801 	subs.w	r8, r8, #1
   1887e:	d19f      	bne.n	187c0 <silk_NLSF_stabilize+0x34>
   18880:	4604      	mov	r4, r0
   18882:	460d      	mov	r5, r1
    if( loops == MAX_LOOPS )
    {
        /* Insertion sort (fast for already almost sorted arrays):   */
        /* Best case:  O(n)   for an already sorted array            */
        /* Worst case: O(n^2) for an inversely sorted array          */
        silk_insertion_sort_increasing_all_values_int16( &NLSF_Q15[0], L );
   18884:	4661      	mov	r1, ip
   18886:	4666      	mov	r6, ip
   18888:	f001 fb32 	bl	19ef0 <silk_insertion_sort_increasing_all_values_int16>

        /* First NLSF should be no less than NDeltaMin[0] */
        NLSF_Q15[0] = silk_max_int( NLSF_Q15[0], NDeltaMin_Q15[0] );
   1888c:	f9b4 2000 	ldrsh.w	r2, [r4]
   18890:	f9b5 3000 	ldrsh.w	r3, [r5]
   18894:	4293      	cmp	r3, r2
   18896:	bfb8      	it	lt
   18898:	4613      	movlt	r3, r2

        /* Keep delta_min distance between the NLSFs */
        for( i = 1; i < L; i++ )
   1889a:	2e01      	cmp	r6, #1
        NLSF_Q15[0] = silk_max_int( NLSF_Q15[0], NDeltaMin_Q15[0] );
   1889c:	8023      	strh	r3, [r4, #0]
        for( i = 1; i < L; i++ )
   1889e:	dd22      	ble.n	188e6 <silk_NLSF_stabilize+0x15a>
   188a0:	9a06      	ldr	r2, [sp, #24]
            NLSF_Q15[i] = silk_max_int( NLSF_Q15[i], silk_ADD_SAT16( NLSF_Q15[i-1], NDeltaMin_Q15[i] ) );
   188a2:	f8df c130 	ldr.w	ip, [pc, #304]	; 189d4 <silk_NLSF_stabilize+0x248>
   188a6:	18a7      	adds	r7, r4, r2
   188a8:	3f02      	subs	r7, #2
   188aa:	4622      	mov	r2, r4
   188ac:	4629      	mov	r1, r5
   188ae:	e00a      	b.n	188c6 <silk_NLSF_stabilize+0x13a>
   188b0:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   188b4:	f2c0 8086 	blt.w	189c4 <silk_NLSF_stabilize+0x238>
   188b8:	b21b      	sxth	r3, r3
   188ba:	4573      	cmp	r3, lr
   188bc:	bfb8      	it	lt
   188be:	4673      	movlt	r3, lr
        for( i = 1; i < L; i++ )
   188c0:	4297      	cmp	r7, r2
            NLSF_Q15[i] = silk_max_int( NLSF_Q15[i], silk_ADD_SAT16( NLSF_Q15[i-1], NDeltaMin_Q15[i] ) );
   188c2:	8013      	strh	r3, [r2, #0]
        for( i = 1; i < L; i++ )
   188c4:	d00f      	beq.n	188e6 <silk_NLSF_stabilize+0x15a>
            NLSF_Q15[i] = silk_max_int( NLSF_Q15[i], silk_ADD_SAT16( NLSF_Q15[i-1], NDeltaMin_Q15[i] ) );
   188c6:	f931 0f02 	ldrsh.w	r0, [r1, #2]!
   188ca:	f932 ef02 	ldrsh.w	lr, [r2, #2]!
   188ce:	4403      	add	r3, r0
   188d0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   188d4:	dbec      	blt.n	188b0 <silk_NLSF_stabilize+0x124>
   188d6:	f647 73ff 	movw	r3, #32767	; 0x7fff
   188da:	4573      	cmp	r3, lr
   188dc:	bfb8      	it	lt
   188de:	4673      	movlt	r3, lr
        for( i = 1; i < L; i++ )
   188e0:	4297      	cmp	r7, r2
            NLSF_Q15[i] = silk_max_int( NLSF_Q15[i], silk_ADD_SAT16( NLSF_Q15[i-1], NDeltaMin_Q15[i] ) );
   188e2:	8013      	strh	r3, [r2, #0]
        for( i = 1; i < L; i++ )
   188e4:	d1ef      	bne.n	188c6 <silk_NLSF_stabilize+0x13a>

        /* Last NLSF should be no higher than 1 - NDeltaMin[L] */
        NLSF_Q15[L-1] = silk_min_int( NLSF_Q15[L-1], (1<<15) - NDeltaMin_Q15[L] );
   188e6:	9b06      	ldr	r3, [sp, #24]
   188e8:	9907      	ldr	r1, [sp, #28]
   188ea:	5eeb      	ldrsh	r3, [r5, r3]
   188ec:	f934 2011 	ldrsh.w	r2, [r4, r1, lsl #1]
   188f0:	f5c3 4300 	rsb	r3, r3, #32768	; 0x8000
    return (((a) < (b)) ? (a) : (b));
   188f4:	4293      	cmp	r3, r2
   188f6:	bfa8      	it	ge
   188f8:	4613      	movge	r3, r2

        /* Keep NDeltaMin distance between the NLSFs */
        for( i = L-2; i >= 0; i-- )
   188fa:	2e01      	cmp	r6, #1
        NLSF_Q15[L-1] = silk_min_int( NLSF_Q15[L-1], (1<<15) - NDeltaMin_Q15[L] );
   188fc:	f824 3011 	strh.w	r3, [r4, r1, lsl #1]
        for( i = L-2; i >= 0; i-- )
   18900:	dd0e      	ble.n	18920 <silk_NLSF_stabilize+0x194>
   18902:	e9dd 0501 	ldrd	r0, r5, [sp, #4]
   18906:	b21b      	sxth	r3, r3
            NLSF_Q15[i] = silk_min_int( NLSF_Q15[i], NLSF_Q15[i+1] - NDeltaMin_Q15[i+1] );
   18908:	f935 1d02 	ldrsh.w	r1, [r5, #-2]!
   1890c:	f930 2d02 	ldrsh.w	r2, [r0, #-2]!
   18910:	1a5b      	subs	r3, r3, r1
   18912:	4293      	cmp	r3, r2
   18914:	bfa8      	it	ge
   18916:	4613      	movge	r3, r2
   18918:	b21b      	sxth	r3, r3
        for( i = L-2; i >= 0; i-- )
   1891a:	42a0      	cmp	r0, r4
            NLSF_Q15[i] = silk_min_int( NLSF_Q15[i], NLSF_Q15[i+1] - NDeltaMin_Q15[i+1] );
   1891c:	8003      	strh	r3, [r0, #0]
        for( i = L-2; i >= 0; i-- )
   1891e:	d1f3      	bne.n	18908 <silk_NLSF_stabilize+0x17c>
    }
}
   18920:	b009      	add	sp, #36	; 0x24
   18922:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        } else if( I == L) {
   18926:	4567      	cmp	r7, ip
   18928:	d038      	beq.n	1899c <silk_NLSF_stabilize+0x210>
            for( k = 0; k < I; k++ ) {
   1892a:	2f00      	cmp	r7, #0
   1892c:	dd4f      	ble.n	189ce <silk_NLSF_stabilize+0x242>
   1892e:	1e8b      	subs	r3, r1, #2
   18930:	007d      	lsls	r5, r7, #1
   18932:	195e      	adds	r6, r3, r5
            min_center_Q15 = 0;
   18934:	2200      	movs	r2, #0
                min_center_Q15 += NDeltaMin_Q15[k];
   18936:	f933 4f02 	ldrsh.w	r4, [r3, #2]!
            for( k = 0; k < I; k++ ) {
   1893a:	429e      	cmp	r6, r3
                min_center_Q15 += NDeltaMin_Q15[k];
   1893c:	4422      	add	r2, r4
            for( k = 0; k < I; k++ ) {
   1893e:	d1fa      	bne.n	18936 <silk_NLSF_stabilize+0x1aa>
            min_center_Q15 += silk_RSHIFT( NDeltaMin_Q15[I], 1 );
   18940:	5f4e      	ldrsh	r6, [r1, r5]
            for( k = L; k > I; k-- ) {
   18942:	4567      	cmp	r7, ip
            min_center_Q15 += silk_RSHIFT( NDeltaMin_Q15[I], 1 );
   18944:	ea4f 0666 	mov.w	r6, r6, asr #1
   18948:	4432      	add	r2, r6
   1894a:	eb01 0905 	add.w	r9, r1, r5
            for( k = L; k > I; k-- ) {
   1894e:	da3b      	bge.n	189c8 <silk_NLSF_stabilize+0x23c>
   18950:	9b05      	ldr	r3, [sp, #20]
   18952:	eb03 0a05 	add.w	sl, r3, r5
   18956:	9b04      	ldr	r3, [sp, #16]
            max_center_Q15 = 1 << 15;
   18958:	f44f 4400 	mov.w	r4, #32768	; 0x8000
                max_center_Q15 -= NDeltaMin_Q15[k];
   1895c:	f933 7d02 	ldrsh.w	r7, [r3, #-2]!
            for( k = L; k > I; k-- ) {
   18960:	459a      	cmp	sl, r3
                max_center_Q15 -= NDeltaMin_Q15[k];
   18962:	eba4 0407 	sub.w	r4, r4, r7
            for( k = L; k > I; k-- ) {
   18966:	d1f9      	bne.n	1895c <silk_NLSF_stabilize+0x1d0>
   18968:	f1a5 0a02 	sub.w	sl, r5, #2
   1896c:	5f43      	ldrsh	r3, [r0, r5]
   1896e:	f930 700a 	ldrsh.w	r7, [r0, sl]
            max_center_Q15 -= silk_RSHIFT( NDeltaMin_Q15[I], 1 );
   18972:	1ba4      	subs	r4, r4, r6
   18974:	441f      	add	r7, r3
   18976:	f007 0301 	and.w	r3, r7, #1
            center_freq_Q15 = (opus_int16)silk_LIMIT_32( silk_RSHIFT_ROUND( (opus_int32)NLSF_Q15[I-1] + (opus_int32)NLSF_Q15[I], 1 ),
   1897a:	42a2      	cmp	r2, r4
   1897c:	4405      	add	r5, r0
   1897e:	eb03 0367 	add.w	r3, r3, r7, asr #1
   18982:	dd12      	ble.n	189aa <silk_NLSF_stabilize+0x21e>
   18984:	429a      	cmp	r2, r3
   18986:	da16      	bge.n	189b6 <silk_NLSF_stabilize+0x22a>
   18988:	b214      	sxth	r4, r2
            NLSF_Q15[I-1] = center_freq_Q15 - silk_RSHIFT( NDeltaMin_Q15[I], 1 );
   1898a:	1ba6      	subs	r6, r4, r6
   1898c:	b2b6      	uxth	r6, r6
   1898e:	f820 600a 	strh.w	r6, [r0, sl]
            NLSF_Q15[I] = NLSF_Q15[I-1] + NDeltaMin_Q15[I];
   18992:	f8b9 3000 	ldrh.w	r3, [r9]
   18996:	441e      	add	r6, r3
   18998:	802e      	strh	r6, [r5, #0]
   1899a:	e76e      	b.n	1887a <silk_NLSF_stabilize+0xee>
            NLSF_Q15[L-1] = ( 1 << 15 ) - NDeltaMin_Q15[L];
   1899c:	9b01      	ldr	r3, [sp, #4]
   1899e:	f5c4 4400 	rsb	r4, r4, #32768	; 0x8000
   189a2:	801c      	strh	r4, [r3, #0]
   189a4:	e769      	b.n	1887a <silk_NLSF_stabilize+0xee>
        I = 0;
   189a6:	2700      	movs	r7, #0
   189a8:	e754      	b.n	18854 <silk_NLSF_stabilize+0xc8>
            center_freq_Q15 = (opus_int16)silk_LIMIT_32( silk_RSHIFT_ROUND( (opus_int32)NLSF_Q15[I-1] + (opus_int32)NLSF_Q15[I], 1 ),
   189aa:	429c      	cmp	r4, r3
   189ac:	db05      	blt.n	189ba <silk_NLSF_stabilize+0x22e>
   189ae:	429a      	cmp	r2, r3
   189b0:	dcea      	bgt.n	18988 <silk_NLSF_stabilize+0x1fc>
   189b2:	b21c      	sxth	r4, r3
   189b4:	e7e9      	b.n	1898a <silk_NLSF_stabilize+0x1fe>
   189b6:	429c      	cmp	r4, r3
   189b8:	ddfb      	ble.n	189b2 <silk_NLSF_stabilize+0x226>
   189ba:	b224      	sxth	r4, r4
   189bc:	e7e5      	b.n	1898a <silk_NLSF_stabilize+0x1fe>
        for( i = 1; i <= L-1; i++ ) {
   189be:	2700      	movs	r7, #0
   189c0:	2601      	movs	r6, #1
   189c2:	e72e      	b.n	18822 <silk_NLSF_stabilize+0x96>
            NLSF_Q15[i] = silk_max_int( NLSF_Q15[i], silk_ADD_SAT16( NLSF_Q15[i-1], NDeltaMin_Q15[i] ) );
   189c4:	4663      	mov	r3, ip
   189c6:	e778      	b.n	188ba <silk_NLSF_stabilize+0x12e>
            max_center_Q15 = 1 << 15;
   189c8:	f44f 4400 	mov.w	r4, #32768	; 0x8000
   189cc:	e7cc      	b.n	18968 <silk_NLSF_stabilize+0x1dc>
            min_center_Q15 = 0;
   189ce:	2200      	movs	r2, #0
   189d0:	007d      	lsls	r5, r7, #1
   189d2:	e7b5      	b.n	18940 <silk_NLSF_stabilize+0x1b4>
   189d4:	ffff8000 	.word	0xffff8000

000189d8 <silk_NLSF_VQ_weights_laroia>:

    celt_assert( D > 0 );
    celt_assert( ( D & 1 ) == 0 );

    /* First value */
    tmp1_int = silk_max_int( pNLSF_Q15[ 0 ], 1 );
   189d8:	f9b1 3000 	ldrsh.w	r3, [r1]
{
   189dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    tmp1_int = silk_DIV32_16( (opus_int32)1 << ( 15 + NLSF_W_Q ), tmp1_int );
    tmp2_int = silk_max_int( pNLSF_Q15[ 1 ] - pNLSF_Q15[ 0 ], 1 );
   189e0:	f9b1 4002 	ldrsh.w	r4, [r1, #2]
   189e4:	1ae4      	subs	r4, r4, r3
    return (((a) > (b)) ? (a) : (b));
   189e6:	2c01      	cmp	r4, #1
   189e8:	bfb8      	it	lt
   189ea:	2401      	movlt	r4, #1
   189ec:	2b01      	cmp	r3, #1
   189ee:	bfb8      	it	lt
   189f0:	2301      	movlt	r3, #1
    tmp2_int = silk_DIV32_16( (opus_int32)1 << ( 15 + NLSF_W_Q ), tmp2_int );
   189f2:	f44f 3700 	mov.w	r7, #131072	; 0x20000
    return (((a) < (b)) ? (a) : (b));
   189f6:	f647 7cff 	movw	ip, #32767	; 0x7fff
   189fa:	fb97 f4f4 	sdiv	r4, r7, r4
    tmp1_int = silk_DIV32_16( (opus_int32)1 << ( 15 + NLSF_W_Q ), tmp1_int );
   189fe:	fb97 f3f3 	sdiv	r3, r7, r3
    pNLSFW_Q_OUT[ 0 ] = (opus_int16)silk_min_int( tmp1_int + tmp2_int, silk_int16_MAX );
   18a02:	4423      	add	r3, r4
   18a04:	4563      	cmp	r3, ip
   18a06:	bfa8      	it	ge
   18a08:	4663      	movge	r3, ip
    silk_assert( pNLSFW_Q_OUT[ 0 ] > 0 );

    /* Main loop */
    for( k = 1; k < D - 1; k += 2 ) {
   18a0a:	2a02      	cmp	r2, #2
    pNLSFW_Q_OUT[ 0 ] = (opus_int16)silk_min_int( tmp1_int + tmp2_int, silk_int16_MAX );
   18a0c:	8003      	strh	r3, [r0, #0]
    for( k = 1; k < D - 1; k += 2 ) {
   18a0e:	dd2c      	ble.n	18a6a <silk_NLSF_VQ_weights_laroia+0x92>
   18a10:	f1a2 0e03 	sub.w	lr, r2, #3
   18a14:	ea4f 035e 	mov.w	r3, lr, lsr #1
   18a18:	f101 0e04 	add.w	lr, r1, #4
   18a1c:	eb0e 0e83 	add.w	lr, lr, r3, lsl #2
   18a20:	460d      	mov	r5, r1
   18a22:	4606      	mov	r6, r0
        tmp1_int = silk_max_int( pNLSF_Q15[ k + 1 ] - pNLSF_Q15[ k ], 1 );
   18a24:	f9b5 3004 	ldrsh.w	r3, [r5, #4]
   18a28:	f9b5 8002 	ldrsh.w	r8, [r5, #2]
   18a2c:	eba3 0308 	sub.w	r3, r3, r8
    return (((a) > (b)) ? (a) : (b));
   18a30:	2b01      	cmp	r3, #1
   18a32:	bfb8      	it	lt
   18a34:	2301      	movlt	r3, #1
        tmp1_int = silk_DIV32_16( (opus_int32)1 << ( 15 + NLSF_W_Q ), tmp1_int );
   18a36:	fb97 f3f3 	sdiv	r3, r7, r3
        pNLSFW_Q_OUT[ k ] = (opus_int16)silk_min_int( tmp1_int + tmp2_int, silk_int16_MAX );
   18a3a:	441c      	add	r4, r3
    return (((a) < (b)) ? (a) : (b));
   18a3c:	4564      	cmp	r4, ip
   18a3e:	bfa8      	it	ge
   18a40:	4664      	movge	r4, ip
   18a42:	8074      	strh	r4, [r6, #2]
        silk_assert( pNLSFW_Q_OUT[ k ] > 0 );

        tmp2_int = silk_max_int( pNLSF_Q15[ k + 2 ] - pNLSF_Q15[ k + 1 ], 1 );
   18a44:	f9b5 4006 	ldrsh.w	r4, [r5, #6]
   18a48:	f935 8f04 	ldrsh.w	r8, [r5, #4]!
   18a4c:	eba4 0408 	sub.w	r4, r4, r8
    return (((a) > (b)) ? (a) : (b));
   18a50:	2c01      	cmp	r4, #1
   18a52:	bfb8      	it	lt
   18a54:	2401      	movlt	r4, #1
        tmp2_int = silk_DIV32_16( (opus_int32)1 << ( 15 + NLSF_W_Q ), tmp2_int );
   18a56:	fb97 f4f4 	sdiv	r4, r7, r4
        pNLSFW_Q_OUT[ k + 1 ] = (opus_int16)silk_min_int( tmp1_int + tmp2_int, silk_int16_MAX );
   18a5a:	4423      	add	r3, r4
    return (((a) < (b)) ? (a) : (b));
   18a5c:	4563      	cmp	r3, ip
   18a5e:	bfa8      	it	ge
   18a60:	4663      	movge	r3, ip
    for( k = 1; k < D - 1; k += 2 ) {
   18a62:	45ae      	cmp	lr, r5
        pNLSFW_Q_OUT[ k + 1 ] = (opus_int16)silk_min_int( tmp1_int + tmp2_int, silk_int16_MAX );
   18a64:	f826 3f04 	strh.w	r3, [r6, #4]!
    for( k = 1; k < D - 1; k += 2 ) {
   18a68:	d1dc      	bne.n	18a24 <silk_NLSF_VQ_weights_laroia+0x4c>
        silk_assert( pNLSFW_Q_OUT[ k + 1 ] > 0 );
    }

    /* Last value */
    tmp1_int = silk_max_int( ( 1 << 15 ) - pNLSF_Q15[ D - 1 ], 1 );
   18a6a:	f102 4200 	add.w	r2, r2, #2147483648	; 0x80000000
   18a6e:	3a01      	subs	r2, #1
    tmp1_int = silk_DIV32_16( (opus_int32)1 << ( 15 + NLSF_W_Q ), tmp1_int );
   18a70:	f44f 3300 	mov.w	r3, #131072	; 0x20000
    tmp1_int = silk_max_int( ( 1 << 15 ) - pNLSF_Q15[ D - 1 ], 1 );
   18a74:	f931 1012 	ldrsh.w	r1, [r1, r2, lsl #1]
   18a78:	f5c1 4100 	rsb	r1, r1, #32768	; 0x8000
    tmp1_int = silk_DIV32_16( (opus_int32)1 << ( 15 + NLSF_W_Q ), tmp1_int );
   18a7c:	fb93 f3f1 	sdiv	r3, r3, r1
   18a80:	f647 71ff 	movw	r1, #32767	; 0x7fff
    pNLSFW_Q_OUT[ D - 1 ] = (opus_int16)silk_min_int( tmp1_int + tmp2_int, silk_int16_MAX );
   18a84:	441c      	add	r4, r3
   18a86:	428c      	cmp	r4, r1
   18a88:	bfa8      	it	ge
   18a8a:	460c      	movge	r4, r1
   18a8c:	f820 4012 	strh.w	r4, [r0, r2, lsl #1]
    silk_assert( pNLSFW_Q_OUT[ D - 1 ] > 0 );
}
   18a90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00018a94 <silk_resampler_init>:
    silk_resampler_state_struct *S,                 /* I/O  Resampler state                                             */
    opus_int32                  Fs_Hz_in,           /* I    Input sampling rate (Hz)                                    */
    opus_int32                  Fs_Hz_out,          /* I    Output sampling rate (Hz)                                   */
    opus_int                    forEnc              /* I    If 1: encoder; if 0: decoder                                */
)
{
   18a94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   18a96:	460c      	mov	r4, r1
   18a98:	4616      	mov	r6, r2
   18a9a:	461f      	mov	r7, r3
    opus_int up2x;

    /* Clear state */
    silk_memset( S, 0, sizeof( silk_resampler_state_struct ) );
   18a9c:	f44f 7296 	mov.w	r2, #300	; 0x12c
   18aa0:	2100      	movs	r1, #0
{
   18aa2:	4605      	mov	r5, r0
    silk_memset( S, 0, sizeof( silk_resampler_state_struct ) );
   18aa4:	f01c fb5e 	bl	35164 <memset>

    /* Input checking */
    if( forEnc ) {
   18aa8:	2f00      	cmp	r7, #0
   18aaa:	f000 8090 	beq.w	18bce <silk_resampler_init+0x13a>
        if( ( Fs_Hz_in  != 8000 && Fs_Hz_in  != 12000 && Fs_Hz_in  != 16000 && Fs_Hz_in  != 24000 && Fs_Hz_in  != 48000 ) ||
   18aae:	f5b4 5ffa 	cmp.w	r4, #8000	; 0x1f40
   18ab2:	d00f      	beq.n	18ad4 <silk_resampler_init+0x40>
   18ab4:	f642 63e0 	movw	r3, #12000	; 0x2ee0
   18ab8:	429c      	cmp	r4, r3
   18aba:	d00b      	beq.n	18ad4 <silk_resampler_init+0x40>
   18abc:	f5b4 5f7a 	cmp.w	r4, #16000	; 0x3e80
   18ac0:	d008      	beq.n	18ad4 <silk_resampler_init+0x40>
   18ac2:	f645 53c0 	movw	r3, #24000	; 0x5dc0
   18ac6:	429c      	cmp	r4, r3
   18ac8:	d004      	beq.n	18ad4 <silk_resampler_init+0x40>
   18aca:	f64b 3380 	movw	r3, #48000	; 0xbb80
   18ace:	429c      	cmp	r4, r3
   18ad0:	f040 80f2 	bne.w	18cb8 <silk_resampler_init+0x224>
   18ad4:	f5b6 5ffa 	cmp.w	r6, #8000	; 0x1f40
   18ad8:	d007      	beq.n	18aea <silk_resampler_init+0x56>
            ( Fs_Hz_out != 8000 && Fs_Hz_out != 12000 && Fs_Hz_out != 16000 ) ) {
   18ada:	f642 63e0 	movw	r3, #12000	; 0x2ee0
   18ade:	429e      	cmp	r6, r3
   18ae0:	d003      	beq.n	18aea <silk_resampler_init+0x56>
   18ae2:	f5b6 5f7a 	cmp.w	r6, #16000	; 0x3e80
   18ae6:	f040 80e7 	bne.w	18cb8 <silk_resampler_init+0x224>
            celt_assert( 0 );
            return -1;
        }
        S->inputDelay = delay_matrix_enc[ rateID( Fs_Hz_in ) ][ rateID( Fs_Hz_out ) ];
   18aea:	f5b4 5f7a 	cmp.w	r4, #16000	; 0x3e80
   18aee:	f645 50c0 	movw	r0, #24000	; 0x5dc0
   18af2:	bfd4      	ite	le
   18af4:	2300      	movle	r3, #0
   18af6:	2301      	movgt	r3, #1
   18af8:	4284      	cmp	r4, r0
   18afa:	bfd4      	ite	le
   18afc:	2200      	movle	r2, #0
   18afe:	2201      	movgt	r2, #1
   18b00:	ebc3 3324 	rsb	r3, r3, r4, asr #12
   18b04:	4113      	asrs	r3, r2
   18b06:	f5b6 5f7a 	cmp.w	r6, #16000	; 0x3e80
   18b0a:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
   18b0e:	4a70      	ldr	r2, [pc, #448]	; (18cd0 <silk_resampler_init+0x23c>)
   18b10:	bfd4      	ite	le
   18b12:	2100      	movle	r1, #0
   18b14:	2101      	movgt	r1, #1
   18b16:	eb03 0343 	add.w	r3, r3, r3, lsl #1
        if( ( Fs_Hz_in  != 8000 && Fs_Hz_in  != 12000 && Fs_Hz_in  != 16000 ) ||
            ( Fs_Hz_out != 8000 && Fs_Hz_out != 12000 && Fs_Hz_out != 16000 && Fs_Hz_out != 24000 && Fs_Hz_out != 48000 ) ) {
            celt_assert( 0 );
            return -1;
        }
        S->inputDelay = delay_matrix_dec[ rateID( Fs_Hz_in ) ][ rateID( Fs_Hz_out ) ];
   18b1a:	4286      	cmp	r6, r0
   18b1c:	bfd4      	ite	le
   18b1e:	2000      	movle	r0, #0
   18b20:	2001      	movgt	r0, #1
   18b22:	ebc1 3126 	rsb	r1, r1, r6, asr #12
   18b26:	4413      	add	r3, r2
   18b28:	fa41 f200 	asr.w	r2, r1, r0
   18b2c:	4413      	add	r3, r2
    }

    S->Fs_in_kHz  = silk_DIV32_16( Fs_Hz_in,  1000 );
   18b2e:	4a69      	ldr	r2, [pc, #420]	; (18cd4 <silk_resampler_init+0x240>)
        S->inputDelay = delay_matrix_dec[ rateID( Fs_Hz_in ) ][ rateID( Fs_Hz_out ) ];
   18b30:	f913 3c01 	ldrsb.w	r3, [r3, #-1]
   18b34:	f8c5 3124 	str.w	r3, [r5, #292]	; 0x124
    S->Fs_in_kHz  = silk_DIV32_16( Fs_Hz_in,  1000 );
   18b38:	fb82 0104 	smull	r0, r1, r2, r4
   18b3c:	17e3      	asrs	r3, r4, #31
   18b3e:	ebc3 13a1 	rsb	r3, r3, r1, asr #6
    S->Fs_out_kHz = silk_DIV32_16( Fs_Hz_out, 1000 );

    /* Number of samples processed per batch */
    S->batchSize = S->Fs_in_kHz * RESAMPLER_MAX_BATCH_SIZE_MS;
   18b42:	eb03 0083 	add.w	r0, r3, r3, lsl #2
    S->Fs_out_kHz = silk_DIV32_16( Fs_Hz_out, 1000 );
   18b46:	fb82 2106 	smull	r2, r1, r2, r6
   18b4a:	17f2      	asrs	r2, r6, #31
    S->batchSize = S->Fs_in_kHz * RESAMPLER_MAX_BATCH_SIZE_MS;
   18b4c:	0040      	lsls	r0, r0, #1
    S->Fs_out_kHz = silk_DIV32_16( Fs_Hz_out, 1000 );
   18b4e:	ebc2 12a1 	rsb	r2, r2, r1, asr #6

    /* Find resampler with the right sampling ratio */
    up2x = 0;
    if( Fs_Hz_out > Fs_Hz_in ) {
   18b52:	42b4      	cmp	r4, r6
    S->Fs_in_kHz  = silk_DIV32_16( Fs_Hz_in,  1000 );
   18b54:	f8c5 311c 	str.w	r3, [r5, #284]	; 0x11c
    S->batchSize = S->Fs_in_kHz * RESAMPLER_MAX_BATCH_SIZE_MS;
   18b58:	f8c5 010c 	str.w	r0, [r5, #268]	; 0x10c
    S->Fs_out_kHz = silk_DIV32_16( Fs_Hz_out, 1000 );
   18b5c:	f8c5 2120 	str.w	r2, [r5, #288]	; 0x120
    if( Fs_Hz_out > Fs_Hz_in ) {
   18b60:	da6a      	bge.n	18c38 <silk_resampler_init+0x1a4>
        /* Upsample */
        if( Fs_Hz_out == silk_MUL( Fs_Hz_in, 2 ) ) {                            /* Fs_out : Fs_in = 2 : 1 */
   18b62:	0063      	lsls	r3, r4, #1
   18b64:	42b3      	cmp	r3, r6
   18b66:	4622      	mov	r2, r4
   18b68:	f000 8091 	beq.w	18c8e <silk_resampler_init+0x1fa>
            /* Special case: directly use 2x upsampler */
            S->resampler_function = USE_silk_resampler_private_up2_HQ_wrapper;
        } else {
            /* Default resampler */
            S->resampler_function = USE_silk_resampler_private_IIR_FIR;
   18b6c:	2102      	movs	r1, #2
   18b6e:	461c      	mov	r4, r3
   18b70:	f8c5 1108 	str.w	r1, [r5, #264]	; 0x108
   18b74:	230f      	movs	r3, #15
        /* Input and output sampling rates are equal: copy */
        S->resampler_function = USE_silk_resampler_copy;
    }

    /* Ratio of input/output samples */
    S->invRatio_Q16 = silk_LSHIFT32( silk_DIV32( silk_LSHIFT32( Fs_Hz_in, 14 + up2x ), Fs_Hz_out ), 2 );
   18b76:	409a      	lsls	r2, r3
   18b78:	fb92 f2f6 	sdiv	r2, r2, r6
   18b7c:	0092      	lsls	r2, r2, #2
    /* Make sure the ratio is rounded up */
    while( silk_SMULWW( S->invRatio_Q16, Fs_Hz_out ) < silk_LSHIFT32( Fs_Hz_in, up2x ) ) {
   18b7e:	b237      	sxth	r7, r6
   18b80:	b291      	uxth	r1, r2
   18b82:	13f6      	asrs	r6, r6, #15
   18b84:	1413      	asrs	r3, r2, #16
   18b86:	fb07 f101 	mul.w	r1, r7, r1
   18b8a:	3601      	adds	r6, #1
   18b8c:	fb07 f303 	mul.w	r3, r7, r3
   18b90:	1076      	asrs	r6, r6, #1
   18b92:	eb03 4321 	add.w	r3, r3, r1, asr #16
   18b96:	fb06 3302 	mla	r3, r6, r2, r3
   18b9a:	42a3      	cmp	r3, r4
    S->invRatio_Q16 = silk_LSHIFT32( silk_DIV32( silk_LSHIFT32( Fs_Hz_in, 14 + up2x ), Fs_Hz_out ), 2 );
   18b9c:	f8c5 2110 	str.w	r2, [r5, #272]	; 0x110
    while( silk_SMULWW( S->invRatio_Q16, Fs_Hz_out ) < silk_LSHIFT32( Fs_Hz_in, up2x ) ) {
   18ba0:	da13      	bge.n	18bca <silk_resampler_init+0x136>
   18ba2:	3201      	adds	r2, #1
   18ba4:	fb02 f006 	mul.w	r0, r2, r6
   18ba8:	b291      	uxth	r1, r2
   18baa:	1413      	asrs	r3, r2, #16
   18bac:	fb07 f101 	mul.w	r1, r7, r1
   18bb0:	fb07 f303 	mul.w	r3, r7, r3
   18bb4:	eb03 4321 	add.w	r3, r3, r1, asr #16
   18bb8:	4403      	add	r3, r0
   18bba:	42a3      	cmp	r3, r4
        S->invRatio_Q16++;
   18bbc:	4611      	mov	r1, r2
   18bbe:	4430      	add	r0, r6
   18bc0:	f102 0201 	add.w	r2, r2, #1
    while( silk_SMULWW( S->invRatio_Q16, Fs_Hz_out ) < silk_LSHIFT32( Fs_Hz_in, up2x ) ) {
   18bc4:	dbf0      	blt.n	18ba8 <silk_resampler_init+0x114>
   18bc6:	f8c5 1110 	str.w	r1, [r5, #272]	; 0x110
    }

    return 0;
   18bca:	2000      	movs	r0, #0
}
   18bcc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if( ( Fs_Hz_in  != 8000 && Fs_Hz_in  != 12000 && Fs_Hz_in  != 16000 ) ||
   18bce:	f5b4 5ffa 	cmp.w	r4, #8000	; 0x1f40
   18bd2:	d006      	beq.n	18be2 <silk_resampler_init+0x14e>
   18bd4:	f642 63e0 	movw	r3, #12000	; 0x2ee0
   18bd8:	429c      	cmp	r4, r3
   18bda:	d002      	beq.n	18be2 <silk_resampler_init+0x14e>
   18bdc:	f5b4 5f7a 	cmp.w	r4, #16000	; 0x3e80
   18be0:	d16a      	bne.n	18cb8 <silk_resampler_init+0x224>
   18be2:	f5b6 5ffa 	cmp.w	r6, #8000	; 0x1f40
   18be6:	d00e      	beq.n	18c06 <silk_resampler_init+0x172>
            ( Fs_Hz_out != 8000 && Fs_Hz_out != 12000 && Fs_Hz_out != 16000 && Fs_Hz_out != 24000 && Fs_Hz_out != 48000 ) ) {
   18be8:	f642 63e0 	movw	r3, #12000	; 0x2ee0
   18bec:	429e      	cmp	r6, r3
   18bee:	d00a      	beq.n	18c06 <silk_resampler_init+0x172>
   18bf0:	f5b6 5f7a 	cmp.w	r6, #16000	; 0x3e80
   18bf4:	d007      	beq.n	18c06 <silk_resampler_init+0x172>
   18bf6:	f645 53c0 	movw	r3, #24000	; 0x5dc0
   18bfa:	429e      	cmp	r6, r3
   18bfc:	d003      	beq.n	18c06 <silk_resampler_init+0x172>
   18bfe:	f64b 3380 	movw	r3, #48000	; 0xbb80
   18c02:	429e      	cmp	r6, r3
   18c04:	d158      	bne.n	18cb8 <silk_resampler_init+0x224>
        S->inputDelay = delay_matrix_dec[ rateID( Fs_Hz_in ) ][ rateID( Fs_Hz_out ) ];
   18c06:	f5b4 5f7a 	cmp.w	r4, #16000	; 0x3e80
   18c0a:	f645 50c0 	movw	r0, #24000	; 0x5dc0
   18c0e:	bfd4      	ite	le
   18c10:	2300      	movle	r3, #0
   18c12:	2301      	movgt	r3, #1
   18c14:	4284      	cmp	r4, r0
   18c16:	bfd4      	ite	le
   18c18:	2200      	movle	r2, #0
   18c1a:	2201      	movgt	r2, #1
   18c1c:	ebc3 3324 	rsb	r3, r3, r4, asr #12
   18c20:	4113      	asrs	r3, r2
   18c22:	f5b6 5f7a 	cmp.w	r6, #16000	; 0x3e80
   18c26:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
   18c2a:	4a2b      	ldr	r2, [pc, #172]	; (18cd8 <silk_resampler_init+0x244>)
   18c2c:	bfd4      	ite	le
   18c2e:	2100      	movle	r1, #0
   18c30:	2101      	movgt	r1, #1
   18c32:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   18c36:	e770      	b.n	18b1a <silk_resampler_init+0x86>
    } else if ( Fs_Hz_out < Fs_Hz_in ) {
   18c38:	dd18      	ble.n	18c6c <silk_resampler_init+0x1d8>
        if( silk_MUL( Fs_Hz_out, 4 ) == silk_MUL( Fs_Hz_in, 3 ) ) {             /* Fs_out : Fs_in = 3 : 4 */
   18c3a:	0063      	lsls	r3, r4, #1
   18c3c:	1918      	adds	r0, r3, r4
   18c3e:	00b1      	lsls	r1, r6, #2
         S->resampler_function = USE_silk_resampler_private_down_FIR;
   18c40:	2203      	movs	r2, #3
        if( silk_MUL( Fs_Hz_out, 4 ) == silk_MUL( Fs_Hz_in, 3 ) ) {             /* Fs_out : Fs_in = 3 : 4 */
   18c42:	4281      	cmp	r1, r0
         S->resampler_function = USE_silk_resampler_private_down_FIR;
   18c44:	f8c5 2108 	str.w	r2, [r5, #264]	; 0x108
        if( silk_MUL( Fs_Hz_out, 4 ) == silk_MUL( Fs_Hz_in, 3 ) ) {             /* Fs_out : Fs_in = 3 : 4 */
   18c48:	d016      	beq.n	18c78 <silk_resampler_init+0x1e4>
        } else if( silk_MUL( Fs_Hz_out, 3 ) == silk_MUL( Fs_Hz_in, 2 ) ) {      /* Fs_out : Fs_in = 2 : 3 */
   18c4a:	0072      	lsls	r2, r6, #1
   18c4c:	1990      	adds	r0, r2, r6
   18c4e:	4298      	cmp	r0, r3
   18c50:	d022      	beq.n	18c98 <silk_resampler_init+0x204>
        } else if( silk_MUL( Fs_Hz_out, 2 ) == Fs_Hz_in ) {                     /* Fs_out : Fs_in = 1 : 2 */
   18c52:	42a2      	cmp	r2, r4
   18c54:	d033      	beq.n	18cbe <silk_resampler_init+0x22a>
        } else if( silk_MUL( Fs_Hz_out, 3 ) == Fs_Hz_in ) {                     /* Fs_out : Fs_in = 1 : 3 */
   18c56:	42a0      	cmp	r0, r4
   18c58:	d02a      	beq.n	18cb0 <silk_resampler_init+0x21c>
        } else if( silk_MUL( Fs_Hz_out, 4 ) == Fs_Hz_in ) {                     /* Fs_out : Fs_in = 1 : 4 */
   18c5a:	42a1      	cmp	r1, r4
   18c5c:	d033      	beq.n	18cc6 <silk_resampler_init+0x232>
        } else if( silk_MUL( Fs_Hz_out, 6 ) == Fs_Hz_in ) {                     /* Fs_out : Fs_in = 1 : 6 */
   18c5e:	ebb4 0f40 	cmp.w	r4, r0, lsl #1
   18c62:	d129      	bne.n	18cb8 <silk_resampler_init+0x224>
            S->FIR_Fracs = 1;
   18c64:	2101      	movs	r1, #1
            S->FIR_Order = RESAMPLER_DOWN_ORDER_FIR2;
   18c66:	2224      	movs	r2, #36	; 0x24
            S->Coefs = silk_Resampler_1_6_COEFS;
   18c68:	4b1c      	ldr	r3, [pc, #112]	; (18cdc <silk_resampler_init+0x248>)
   18c6a:	e018      	b.n	18c9e <silk_resampler_init+0x20a>
        S->resampler_function = USE_silk_resampler_copy;
   18c6c:	2300      	movs	r3, #0
   18c6e:	f8c5 3108 	str.w	r3, [r5, #264]	; 0x108
   18c72:	4622      	mov	r2, r4
   18c74:	230e      	movs	r3, #14
   18c76:	e77e      	b.n	18b76 <silk_resampler_init+0xe2>
            S->Coefs = silk_Resampler_3_4_COEFS;
   18c78:	4b19      	ldr	r3, [pc, #100]	; (18ce0 <silk_resampler_init+0x24c>)
            S->FIR_Fracs = 3;
   18c7a:	f8c5 2118 	str.w	r2, [r5, #280]	; 0x118
            S->FIR_Order = RESAMPLER_DOWN_ORDER_FIR0;
   18c7e:	2112      	movs	r1, #18
            S->Coefs = silk_Resampler_3_4_COEFS;
   18c80:	f8c5 3128 	str.w	r3, [r5, #296]	; 0x128
            S->FIR_Order = RESAMPLER_DOWN_ORDER_FIR0;
   18c84:	f8c5 1114 	str.w	r1, [r5, #276]	; 0x114
   18c88:	4622      	mov	r2, r4
   18c8a:	230e      	movs	r3, #14
   18c8c:	e773      	b.n	18b76 <silk_resampler_init+0xe2>
            S->resampler_function = USE_silk_resampler_private_up2_HQ_wrapper;
   18c8e:	2301      	movs	r3, #1
   18c90:	f8c5 3108 	str.w	r3, [r5, #264]	; 0x108
   18c94:	230e      	movs	r3, #14
   18c96:	e76e      	b.n	18b76 <silk_resampler_init+0xe2>
            S->Coefs = silk_Resampler_2_3_COEFS;
   18c98:	4b12      	ldr	r3, [pc, #72]	; (18ce4 <silk_resampler_init+0x250>)
            S->FIR_Fracs = 2;
   18c9a:	2102      	movs	r1, #2
            S->FIR_Order = RESAMPLER_DOWN_ORDER_FIR0;
   18c9c:	2212      	movs	r2, #18
            S->FIR_Order = RESAMPLER_DOWN_ORDER_FIR2;
   18c9e:	f8c5 2114 	str.w	r2, [r5, #276]	; 0x114
            S->Coefs = silk_Resampler_1_4_COEFS;
   18ca2:	f8c5 3128 	str.w	r3, [r5, #296]	; 0x128
            S->FIR_Fracs = 1;
   18ca6:	f8c5 1118 	str.w	r1, [r5, #280]	; 0x118
   18caa:	4622      	mov	r2, r4
   18cac:	230e      	movs	r3, #14
   18cae:	e762      	b.n	18b76 <silk_resampler_init+0xe2>
            S->FIR_Fracs = 1;
   18cb0:	2101      	movs	r1, #1
            S->FIR_Order = RESAMPLER_DOWN_ORDER_FIR2;
   18cb2:	2224      	movs	r2, #36	; 0x24
            S->Coefs = silk_Resampler_1_3_COEFS;
   18cb4:	4b0c      	ldr	r3, [pc, #48]	; (18ce8 <silk_resampler_init+0x254>)
   18cb6:	e7f2      	b.n	18c9e <silk_resampler_init+0x20a>
            return -1;
   18cb8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   18cbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            S->FIR_Fracs = 1;
   18cbe:	2101      	movs	r1, #1
            S->FIR_Order = RESAMPLER_DOWN_ORDER_FIR1;
   18cc0:	2218      	movs	r2, #24
            S->Coefs = silk_Resampler_1_2_COEFS;
   18cc2:	4b0a      	ldr	r3, [pc, #40]	; (18cec <silk_resampler_init+0x258>)
   18cc4:	e7eb      	b.n	18c9e <silk_resampler_init+0x20a>
            S->FIR_Fracs = 1;
   18cc6:	2101      	movs	r1, #1
            S->FIR_Order = RESAMPLER_DOWN_ORDER_FIR2;
   18cc8:	2224      	movs	r2, #36	; 0x24
            S->Coefs = silk_Resampler_1_4_COEFS;
   18cca:	4b09      	ldr	r3, [pc, #36]	; (18cf0 <silk_resampler_init+0x25c>)
   18ccc:	e7e7      	b.n	18c9e <silk_resampler_init+0x20a>
   18cce:	bf00      	nop
   18cd0:	000375f8 	.word	0x000375f8
   18cd4:	10624dd3 	.word	0x10624dd3
   18cd8:	000375e8 	.word	0x000375e8
   18cdc:	00037674 	.word	0x00037674
   18ce0:	000376d0 	.word	0x000376d0
   18ce4:	0003769c 	.word	0x0003769c
   18ce8:	00037624 	.word	0x00037624
   18cec:	00037608 	.word	0x00037608
   18cf0:	0003764c 	.word	0x0003764c

00018cf4 <silk_resampler>:
    silk_resampler_state_struct *S,                 /* I/O  Resampler state                                             */
    opus_int16                  out[],              /* O    Output signal                                               */
    const opus_int16            in[],               /* I    Input signal                                                */
    opus_int32                  inLen               /* I    Number of input samples                                     */
)
{
   18cf4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   18cf8:	4604      	mov	r4, r0
    /* Need at least 1 ms of input data */
    celt_assert( inLen >= S->Fs_in_kHz );
    /* Delay can't exceed the 1 ms of buffering */
    celt_assert( S->inputDelay <= S->Fs_in_kHz );

    nSamples = S->Fs_in_kHz - S->inputDelay;
   18cfa:	f8d0 0124 	ldr.w	r0, [r0, #292]	; 0x124
   18cfe:	f8d4 511c 	ldr.w	r5, [r4, #284]	; 0x11c
   18d02:	1a2d      	subs	r5, r5, r0
{
   18d04:	4617      	mov	r7, r2

    /* Copy to delay buffer */
    silk_memcpy( &S->delayBuf[ S->inputDelay ], in, nSamples * sizeof( opus_int16 ) );
   18d06:	006d      	lsls	r5, r5, #1
   18d08:	3054      	adds	r0, #84	; 0x54
   18d0a:	462a      	mov	r2, r5
{
   18d0c:	4688      	mov	r8, r1
    silk_memcpy( &S->delayBuf[ S->inputDelay ], in, nSamples * sizeof( opus_int16 ) );
   18d0e:	eb04 0040 	add.w	r0, r4, r0, lsl #1
   18d12:	4639      	mov	r1, r7
{
   18d14:	461e      	mov	r6, r3
    silk_memcpy( &S->delayBuf[ S->inputDelay ], in, nSamples * sizeof( opus_int16 ) );
   18d16:	f7f3 f9f3 	bl	c100 <memcpy>

    switch( S->resampler_function ) {
   18d1a:	f8d4 3108 	ldr.w	r3, [r4, #264]	; 0x108
   18d1e:	2b02      	cmp	r3, #2
   18d20:	443d      	add	r5, r7
   18d22:	f104 09a8 	add.w	r9, r4, #168	; 0xa8
   18d26:	d047      	beq.n	18db8 <silk_resampler+0xc4>
   18d28:	2b03      	cmp	r3, #3
   18d2a:	d032      	beq.n	18d92 <silk_resampler+0x9e>
   18d2c:	2b01      	cmp	r3, #1
   18d2e:	d01d      	beq.n	18d6c <silk_resampler+0x78>
        case USE_silk_resampler_private_down_FIR:
            silk_resampler_private_down_FIR( S, out, S->delayBuf, S->Fs_in_kHz );
            silk_resampler_private_down_FIR( S, &out[ S->Fs_out_kHz ], &in[ nSamples ], inLen - S->Fs_in_kHz );
            break;
        default:
            silk_memcpy( out, S->delayBuf, S->Fs_in_kHz * sizeof( opus_int16 ) );
   18d30:	f8d4 211c 	ldr.w	r2, [r4, #284]	; 0x11c
   18d34:	4649      	mov	r1, r9
   18d36:	0052      	lsls	r2, r2, #1
   18d38:	4640      	mov	r0, r8
   18d3a:	f7f3 f9e1 	bl	c100 <memcpy>
            silk_memcpy( &out[ S->Fs_out_kHz ], &in[ nSamples ], ( inLen - S->Fs_in_kHz ) * sizeof( opus_int16 ) );
   18d3e:	f8d4 211c 	ldr.w	r2, [r4, #284]	; 0x11c
   18d42:	f8d4 0120 	ldr.w	r0, [r4, #288]	; 0x120
   18d46:	1ab2      	subs	r2, r6, r2
   18d48:	4629      	mov	r1, r5
   18d4a:	0052      	lsls	r2, r2, #1
   18d4c:	eb08 0040 	add.w	r0, r8, r0, lsl #1
   18d50:	f7f3 f9d6 	bl	c100 <memcpy>
    }

    /* Copy to delay buffer */
    silk_memcpy( S->delayBuf, &in[ inLen - S->inputDelay ], S->inputDelay * sizeof( opus_int16 ) );
   18d54:	f8d4 2124 	ldr.w	r2, [r4, #292]	; 0x124
   18d58:	1ab1      	subs	r1, r6, r2
   18d5a:	eb07 0141 	add.w	r1, r7, r1, lsl #1
   18d5e:	0052      	lsls	r2, r2, #1
   18d60:	4648      	mov	r0, r9
   18d62:	f7f3 f9cd 	bl	c100 <memcpy>

    return 0;
}
   18d66:	2000      	movs	r0, #0
   18d68:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            silk_resampler_private_up2_HQ_wrapper( S, out, S->delayBuf, S->Fs_in_kHz );
   18d6c:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
   18d70:	464a      	mov	r2, r9
   18d72:	4641      	mov	r1, r8
   18d74:	4620      	mov	r0, r4
   18d76:	f000 feb9 	bl	19aec <silk_resampler_private_up2_HQ_wrapper>
            silk_resampler_private_up2_HQ_wrapper( S, &out[ S->Fs_out_kHz ], &in[ nSamples ], inLen - S->Fs_in_kHz );
   18d7a:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
   18d7e:	f8d4 1120 	ldr.w	r1, [r4, #288]	; 0x120
   18d82:	462a      	mov	r2, r5
   18d84:	1af3      	subs	r3, r6, r3
   18d86:	eb08 0141 	add.w	r1, r8, r1, lsl #1
   18d8a:	4620      	mov	r0, r4
   18d8c:	f000 feae 	bl	19aec <silk_resampler_private_up2_HQ_wrapper>
            break;
   18d90:	e7e0      	b.n	18d54 <silk_resampler+0x60>
            silk_resampler_private_down_FIR( S, out, S->delayBuf, S->Fs_in_kHz );
   18d92:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
   18d96:	464a      	mov	r2, r9
   18d98:	4641      	mov	r1, r8
   18d9a:	4620      	mov	r0, r4
   18d9c:	f000 f96e 	bl	1907c <silk_resampler_private_down_FIR>
            silk_resampler_private_down_FIR( S, &out[ S->Fs_out_kHz ], &in[ nSamples ], inLen - S->Fs_in_kHz );
   18da0:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
   18da4:	f8d4 1120 	ldr.w	r1, [r4, #288]	; 0x120
   18da8:	462a      	mov	r2, r5
   18daa:	1af3      	subs	r3, r6, r3
   18dac:	eb08 0141 	add.w	r1, r8, r1, lsl #1
   18db0:	4620      	mov	r0, r4
   18db2:	f000 f963 	bl	1907c <silk_resampler_private_down_FIR>
            break;
   18db6:	e7cd      	b.n	18d54 <silk_resampler+0x60>
            silk_resampler_private_IIR_FIR( S, out, S->delayBuf, S->Fs_in_kHz );
   18db8:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
   18dbc:	464a      	mov	r2, r9
   18dbe:	4641      	mov	r1, r8
   18dc0:	4620      	mov	r0, r4
   18dc2:	f000 fd15 	bl	197f0 <silk_resampler_private_IIR_FIR>
            silk_resampler_private_IIR_FIR( S, &out[ S->Fs_out_kHz ], &in[ nSamples ], inLen - S->Fs_in_kHz );
   18dc6:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
   18dca:	f8d4 1120 	ldr.w	r1, [r4, #288]	; 0x120
   18dce:	462a      	mov	r2, r5
   18dd0:	1af3      	subs	r3, r6, r3
   18dd2:	eb08 0141 	add.w	r1, r8, r1, lsl #1
   18dd6:	4620      	mov	r0, r4
   18dd8:	f000 fd0a 	bl	197f0 <silk_resampler_private_IIR_FIR>
            break;
   18ddc:	e7ba      	b.n	18d54 <silk_resampler+0x60>
   18dde:	bf00      	nop

00018de0 <silk_resampler_down2_3>:
    opus_int32                  *S,                 /* I/O  State vector [ 6 ]                                          */
    opus_int16                  *out,               /* O    Output signal [ floor(2*inLen/3) ]                          */
    const opus_int16            *in,                /* I    Input signal [ inLen ]                                      */
    opus_int32                  inLen               /* I    Number of input samples                                     */
)
{
   18de0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   18de4:	4606      	mov	r6, r0
   18de6:	f2ad 7dbc 	subw	sp, sp, #1980	; 0x7bc
   18dea:	e9cd 2305 	strd	r2, r3, [sp, #20]
   18dee:	9009      	str	r0, [sp, #36]	; 0x24
    SAVE_STACK;

    ALLOC( buf, RESAMPLER_MAX_BATCH_SIZE_IN + ORDER_FIR, opus_int32 );

    /* Copy buffered samples to start of buffer */
    silk_memcpy( buf, S, ORDER_FIR * sizeof( opus_int32 ) );
   18df0:	68f3      	ldr	r3, [r6, #12]
   18df2:	6800      	ldr	r0, [r0, #0]
   18df4:	68b2      	ldr	r2, [r6, #8]
{
   18df6:	460d      	mov	r5, r1
    silk_memcpy( buf, S, ORDER_FIR * sizeof( opus_int32 ) );
   18df8:	6871      	ldr	r1, [r6, #4]
   18dfa:	ac0a      	add	r4, sp, #40	; 0x28
   18dfc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   18dfe:	f106 0310 	add.w	r3, r6, #16
   18e02:	9308      	str	r3, [sp, #32]
   18e04:	4618      	mov	r0, r3

    /* Iterate over blocks of frameSizeIn input samples */
    while( 1 ) {
        nSamplesIn = silk_min( inLen, RESAMPLER_MAX_BATCH_SIZE_IN );
   18e06:	9e06      	ldr	r6, [sp, #24]

        /* Second-order AR filter (output in Q8) */
        silk_resampler_private_AR2( &S[ ORDER_FIR ], &buf[ ORDER_FIR ], in,
   18e08:	4b57      	ldr	r3, [pc, #348]	; (18f68 <silk_resampler_down2_3+0x188>)
   18e0a:	9a05      	ldr	r2, [sp, #20]
        nSamplesIn = silk_min( inLen, RESAMPLER_MAX_BATCH_SIZE_IN );
   18e0c:	f5b6 7ff0 	cmp.w	r6, #480	; 0x1e0
   18e10:	4634      	mov	r4, r6
   18e12:	bfa8      	it	ge
   18e14:	f44f 74f0 	movge.w	r4, #480	; 0x1e0
        silk_resampler_private_AR2( &S[ ORDER_FIR ], &buf[ ORDER_FIR ], in,
   18e18:	9400      	str	r4, [sp, #0]
   18e1a:	a90e      	add	r1, sp, #56	; 0x38
        nSamplesIn = silk_min( inLen, RESAMPLER_MAX_BATCH_SIZE_IN );
   18e1c:	9407      	str	r4, [sp, #28]
        silk_resampler_private_AR2( &S[ ORDER_FIR ], &buf[ ORDER_FIR ], in,
   18e1e:	f000 f901 	bl	19024 <silk_resampler_private_AR2>
            silk_Resampler_2_3_COEFS_LQ, nSamplesIn );

        /* Interpolate filtered signal */
        buf_ptr = buf;
        counter = nSamplesIn;
        while( counter > 2 ) {
   18e22:	2e02      	cmp	r6, #2
   18e24:	f340 8081 	ble.w	18f2a <silk_resampler_down2_3+0x14a>
   18e28:	e9dd 630a 	ldrd	r6, r3, [sp, #40]	; 0x28
            /* Inner product */
            res_Q6 = silk_SMULWB(         buf_ptr[ 0 ], silk_Resampler_2_3_COEFS_LQ[ 2 ] );
   18e2c:	4a4e      	ldr	r2, [pc, #312]	; (18f68 <silk_resampler_down2_3+0x188>)
        nSamplesIn = silk_min( inLen, RESAMPLER_MAX_BATCH_SIZE_IN );
   18e2e:	9404      	str	r4, [sp, #16]
            res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 1 ], silk_Resampler_2_3_COEFS_LQ[ 3 ] );
            res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 2 ], silk_Resampler_2_3_COEFS_LQ[ 5 ] );
   18e30:	f9b2 100a 	ldrsh.w	r1, [r2, #10]
            res_Q6 = silk_SMULWB(         buf_ptr[ 0 ], silk_Resampler_2_3_COEFS_LQ[ 2 ] );
   18e34:	f9b2 a004 	ldrsh.w	sl, [r2, #4]
            res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 1 ], silk_Resampler_2_3_COEFS_LQ[ 3 ] );
   18e38:	f9b2 9006 	ldrsh.w	r9, [r2, #6]
            res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 2 ], silk_Resampler_2_3_COEFS_LQ[ 5 ] );
   18e3c:	9103      	str	r1, [sp, #12]
   18e3e:	fa1f fb86 	uxth.w	fp, r6
   18e42:	1436      	asrs	r6, r6, #16
   18e44:	ea4f 4e23 	mov.w	lr, r3, asr #16
            res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 3 ], silk_Resampler_2_3_COEFS_LQ[ 4 ] );
   18e48:	f9b2 8008 	ldrsh.w	r8, [r2, #8]
   18e4c:	f105 0c04 	add.w	ip, r5, #4
   18e50:	b29b      	uxth	r3, r3
        buf_ptr = buf;
   18e52:	af0a      	add	r7, sp, #40	; 0x28
   18e54:	4634      	mov	r4, r6
   18e56:	e034      	b.n	18ec2 <silk_resampler_down2_3+0xe2>

            /* Scale down, saturate and store in output array */
            *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q6, 6 ) );
   18e58:	f516 4f00 	cmn.w	r6, #32768	; 0x8000
   18e5c:	db61      	blt.n	18f22 <silk_resampler_down2_3+0x142>
   18e5e:	b232      	sxth	r2, r6

            res_Q6 = silk_SMULWB(         buf_ptr[ 1 ], silk_Resampler_2_3_COEFS_LQ[ 4 ] );
            res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 2 ], silk_Resampler_2_3_COEFS_LQ[ 5 ] );
            res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 3 ], silk_Resampler_2_3_COEFS_LQ[ 3 ] );
            res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 4 ], silk_Resampler_2_3_COEFS_LQ[ 2 ] );
   18e60:	693e      	ldr	r6, [r7, #16]
            *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q6, 6 ) );
   18e62:	f82c 2c04 	strh.w	r2, [ip, #-4]
            res_Q6 = silk_SMULWB(         buf_ptr[ 1 ], silk_Resampler_2_3_COEFS_LQ[ 4 ] );
   18e66:	fb03 f308 	mul.w	r3, r3, r8
   18e6a:	fb0e fe08 	mul.w	lr, lr, r8
   18e6e:	eb0e 4523 	add.w	r5, lr, r3, asr #16
            res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 3 ], silk_Resampler_2_3_COEFS_LQ[ 3 ] );
   18e72:	fb0b f009 	mul.w	r0, fp, r9
            res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 4 ], silk_Resampler_2_3_COEFS_LQ[ 2 ] );
   18e76:	b2b3      	uxth	r3, r6
            res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 3 ], silk_Resampler_2_3_COEFS_LQ[ 3 ] );
   18e78:	fb04 f209 	mul.w	r2, r4, r9
            res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 4 ], silk_Resampler_2_3_COEFS_LQ[ 2 ] );
   18e7c:	ea4f 4e26 	mov.w	lr, r6, asr #16
            res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 3 ], silk_Resampler_2_3_COEFS_LQ[ 3 ] );
   18e80:	eb02 4220 	add.w	r2, r2, r0, asr #16
            res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 2 ], silk_Resampler_2_3_COEFS_LQ[ 5 ] );
   18e84:	4429      	add	r1, r5
            res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 4 ], silk_Resampler_2_3_COEFS_LQ[ 2 ] );
   18e86:	fb0a f003 	mul.w	r0, sl, r3
   18e8a:	fb0a f60e 	mul.w	r6, sl, lr
            res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 3 ], silk_Resampler_2_3_COEFS_LQ[ 3 ] );
   18e8e:	4411      	add	r1, r2
            res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 4 ], silk_Resampler_2_3_COEFS_LQ[ 2 ] );
   18e90:	eb06 4220 	add.w	r2, r6, r0, asr #16
   18e94:	440a      	add	r2, r1

            /* Scale down, saturate and store in output array */
            *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q6, 6 ) );
   18e96:	1152      	asrs	r2, r2, #5
   18e98:	3201      	adds	r2, #1
   18e9a:	1052      	asrs	r2, r2, #1
   18e9c:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
   18ea0:	4665      	mov	r5, ip
   18ea2:	da3b      	bge.n	18f1c <silk_resampler_down2_3+0x13c>
   18ea4:	f512 4f00 	cmn.w	r2, #32768	; 0x8000
   18ea8:	db3d      	blt.n	18f26 <silk_resampler_down2_3+0x146>
   18eaa:	b212      	sxth	r2, r2

            buf_ptr += 3;
            counter -= 3;
   18eac:	9904      	ldr	r1, [sp, #16]
            *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q6, 6 ) );
   18eae:	f82c 2c02 	strh.w	r2, [ip, #-2]
            counter -= 3;
   18eb2:	3903      	subs	r1, #3
        while( counter > 2 ) {
   18eb4:	2902      	cmp	r1, #2
            counter -= 3;
   18eb6:	9104      	str	r1, [sp, #16]
            buf_ptr += 3;
   18eb8:	f107 070c 	add.w	r7, r7, #12
   18ebc:	f10c 0c04 	add.w	ip, ip, #4
        while( counter > 2 ) {
   18ec0:	dd33      	ble.n	18f2a <silk_resampler_down2_3+0x14a>
            res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 3 ], silk_Resampler_2_3_COEFS_LQ[ 4 ] );
   18ec2:	e9d7 0502 	ldrd	r0, r5, [r7, #8]
            res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 1 ], silk_Resampler_2_3_COEFS_LQ[ 3 ] );
   18ec6:	fb0e f109 	mul.w	r1, lr, r9
   18eca:	fb03 f209 	mul.w	r2, r3, r9
   18ece:	eb01 4222 	add.w	r2, r1, r2, asr #16
            res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 2 ], silk_Resampler_2_3_COEFS_LQ[ 5 ] );
   18ed2:	9903      	ldr	r1, [sp, #12]
            res_Q6 = silk_SMULWB(         buf_ptr[ 0 ], silk_Resampler_2_3_COEFS_LQ[ 2 ] );
   18ed4:	fb0a f604 	mul.w	r6, sl, r4
            res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 2 ], silk_Resampler_2_3_COEFS_LQ[ 5 ] );
   18ed8:	b284      	uxth	r4, r0
   18eda:	fb01 f104 	mul.w	r1, r1, r4
   18ede:	9c03      	ldr	r4, [sp, #12]
            res_Q6 = silk_SMULWB(         buf_ptr[ 0 ], silk_Resampler_2_3_COEFS_LQ[ 2 ] );
   18ee0:	fb0a fb0b 	mul.w	fp, sl, fp
            res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 2 ], silk_Resampler_2_3_COEFS_LQ[ 5 ] );
   18ee4:	1400      	asrs	r0, r0, #16
   18ee6:	fb04 f000 	mul.w	r0, r4, r0
            res_Q6 = silk_SMULWB(         buf_ptr[ 0 ], silk_Resampler_2_3_COEFS_LQ[ 2 ] );
   18eea:	eb06 462b 	add.w	r6, r6, fp, asr #16
            res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 3 ], silk_Resampler_2_3_COEFS_LQ[ 4 ] );
   18eee:	142c      	asrs	r4, r5, #16
   18ef0:	fa1f fb85 	uxth.w	fp, r5
            res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 2 ], silk_Resampler_2_3_COEFS_LQ[ 5 ] );
   18ef4:	eb00 4121 	add.w	r1, r0, r1, asr #16
            res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 1 ], silk_Resampler_2_3_COEFS_LQ[ 3 ] );
   18ef8:	4416      	add	r6, r2
            res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 3 ], silk_Resampler_2_3_COEFS_LQ[ 4 ] );
   18efa:	fb0b f508 	mul.w	r5, fp, r8
   18efe:	fb04 f008 	mul.w	r0, r4, r8
            res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 2 ], silk_Resampler_2_3_COEFS_LQ[ 5 ] );
   18f02:	440e      	add	r6, r1
            res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 3 ], silk_Resampler_2_3_COEFS_LQ[ 4 ] );
   18f04:	eb00 4025 	add.w	r0, r0, r5, asr #16
   18f08:	4406      	add	r6, r0
            *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q6, 6 ) );
   18f0a:	1176      	asrs	r6, r6, #5
   18f0c:	3601      	adds	r6, #1
   18f0e:	1076      	asrs	r6, r6, #1
   18f10:	f5b6 4f00 	cmp.w	r6, #32768	; 0x8000
   18f14:	dba0      	blt.n	18e58 <silk_resampler_down2_3+0x78>
   18f16:	f647 72ff 	movw	r2, #32767	; 0x7fff
   18f1a:	e7a1      	b.n	18e60 <silk_resampler_down2_3+0x80>
            *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q6, 6 ) );
   18f1c:	f647 72ff 	movw	r2, #32767	; 0x7fff
   18f20:	e7c4      	b.n	18eac <silk_resampler_down2_3+0xcc>
            *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q6, 6 ) );
   18f22:	4a12      	ldr	r2, [pc, #72]	; (18f6c <silk_resampler_down2_3+0x18c>)
   18f24:	e79c      	b.n	18e60 <silk_resampler_down2_3+0x80>
            *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q6, 6 ) );
   18f26:	4a11      	ldr	r2, [pc, #68]	; (18f6c <silk_resampler_down2_3+0x18c>)
   18f28:	e7c0      	b.n	18eac <silk_resampler_down2_3+0xcc>
        }

        in += nSamplesIn;
        inLen -= nSamplesIn;
   18f2a:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   18f2e:	1ad1      	subs	r1, r2, r3
        in += nSamplesIn;
   18f30:	9a05      	ldr	r2, [sp, #20]
        inLen -= nSamplesIn;
   18f32:	9106      	str	r1, [sp, #24]
        in += nSamplesIn;
   18f34:	4610      	mov	r0, r2
   18f36:	eb00 0243 	add.w	r2, r0, r3, lsl #1
   18f3a:	9205      	str	r2, [sp, #20]
   18f3c:	aa0a      	add	r2, sp, #40	; 0x28
   18f3e:	eb02 0383 	add.w	r3, r2, r3, lsl #2

        if( inLen > 0 ) {
   18f42:	2900      	cmp	r1, #0
            /* More iterations to do; copy last part of filtered signal to beginning of buffer */
            silk_memcpy( buf, &buf[ nSamplesIn ], ORDER_FIR * sizeof( opus_int32 ) );
   18f44:	6818      	ldr	r0, [r3, #0]
   18f46:	6859      	ldr	r1, [r3, #4]
   18f48:	689a      	ldr	r2, [r3, #8]
   18f4a:	68db      	ldr	r3, [r3, #12]
        if( inLen > 0 ) {
   18f4c:	dd03      	ble.n	18f56 <silk_resampler_down2_3+0x176>
            silk_memcpy( buf, &buf[ nSamplesIn ], ORDER_FIR * sizeof( opus_int32 ) );
   18f4e:	ac0a      	add	r4, sp, #40	; 0x28
   18f50:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   18f52:	9808      	ldr	r0, [sp, #32]
        nSamplesIn = silk_min( inLen, RESAMPLER_MAX_BATCH_SIZE_IN );
   18f54:	e757      	b.n	18e06 <silk_resampler_down2_3+0x26>
            break;
        }
    }

    /* Copy last part of filtered signal to the state for the next call */
    silk_memcpy( S, &buf[ nSamplesIn ], ORDER_FIR * sizeof( opus_int32 ) );
   18f56:	9c09      	ldr	r4, [sp, #36]	; 0x24
   18f58:	6020      	str	r0, [r4, #0]
   18f5a:	6061      	str	r1, [r4, #4]
   18f5c:	60a2      	str	r2, [r4, #8]
   18f5e:	60e3      	str	r3, [r4, #12]
    RESTORE_STACK;
}
   18f60:	f20d 7dbc 	addw	sp, sp, #1980	; 0x7bc
   18f64:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   18f68:	000376c4 	.word	0x000376c4
   18f6c:	ffff8000 	.word	0xffff8000

00018f70 <silk_resampler_down2>:
    opus_int32                  *S,                 /* I/O  State vector [ 2 ]                                          */
    opus_int16                  *out,               /* O    Output signal [ floor(len/2) ]                              */
    const opus_int16            *in,                /* I    Input signal [ len ]                                        */
    opus_int32                  inLen               /* I    Number of input samples                                     */
)
{
   18f70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    opus_int32 k, len2 = silk_RSHIFT32( inLen, 1 );
   18f74:	ea4f 0863 	mov.w	r8, r3, asr #1

    celt_assert( silk_resampler_down2_0 > 0 );
    celt_assert( silk_resampler_down2_1 < 0 );

    /* Internal variables and state are in Q10 format */
    for( k = 0; k < len2; k++ ) {
   18f78:	f1b8 0f00 	cmp.w	r8, #0
   18f7c:	dd49      	ble.n	19012 <silk_resampler_down2+0xa2>
   18f7e:	3202      	adds	r2, #2
   18f80:	e9d0 b500 	ldrd	fp, r5, [r0]
        /* Convert to Q10 */
        in32 = silk_LSHIFT( (opus_int32)in[ 2 * k ], 10 );

        /* All-pass section for even input sample */
        Y      = silk_SUB32( in32, S[ 0 ] );
        X      = silk_SMLAWB( Y, Y, silk_resampler_down2_1 );
   18f84:	4b25      	ldr	r3, [pc, #148]	; (1901c <silk_resampler_down2+0xac>)
        out32  = silk_ADD32( out32, S[ 1 ] );
        out32  = silk_ADD32( out32, X );
        S[ 1 ] = silk_ADD32( in32, X );

        /* Add, convert back to int16 and store to output */
        out[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32, 11 ) );
   18f86:	f8df 9098 	ldr.w	r9, [pc, #152]	; 19020 <silk_resampler_down2+0xb0>
   18f8a:	eb02 0888 	add.w	r8, r2, r8, lsl #2
   18f8e:	3902      	subs	r1, #2
        X      = silk_SMULWB( Y, silk_resampler_down2_0 );
   18f90:	f242 6e90 	movw	lr, #9872	; 0x2690
   18f94:	e008      	b.n	18fa8 <silk_resampler_down2+0x38>
        out[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32, 11 ) );
   18f96:	f514 4f00 	cmn.w	r4, #32768	; 0x8000
   18f9a:	db3c      	blt.n	19016 <silk_resampler_down2+0xa6>
   18f9c:	b224      	sxth	r4, r4
   18f9e:	3204      	adds	r2, #4
    for( k = 0; k < len2; k++ ) {
   18fa0:	4590      	cmp	r8, r2
        out[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32, 11 ) );
   18fa2:	f821 4f02 	strh.w	r4, [r1, #2]!
    for( k = 0; k < len2; k++ ) {
   18fa6:	d032      	beq.n	1900e <silk_resampler_down2+0x9e>
        in32 = silk_LSHIFT( (opus_int32)in[ 2 * k ], 10 );
   18fa8:	f932 cc02 	ldrsh.w	ip, [r2, #-2]
        in32 = silk_LSHIFT( (opus_int32)in[ 2 * k + 1 ], 10 );
   18fac:	f9b2 7000 	ldrsh.w	r7, [r2]
        in32 = silk_LSHIFT( (opus_int32)in[ 2 * k ], 10 );
   18fb0:	ea4f 2c8c 	mov.w	ip, ip, lsl #10
        Y      = silk_SUB32( in32, S[ 0 ] );
   18fb4:	ebac 040b 	sub.w	r4, ip, fp
        X      = silk_SMLAWB( Y, Y, silk_resampler_down2_1 );
   18fb8:	fa1f fa84 	uxth.w	sl, r4
   18fbc:	1426      	asrs	r6, r4, #16
   18fbe:	fb03 fa0a 	mul.w	sl, r3, sl
        in32 = silk_LSHIFT( (opus_int32)in[ 2 * k + 1 ], 10 );
   18fc2:	02bf      	lsls	r7, r7, #10
        X      = silk_SMLAWB( Y, Y, silk_resampler_down2_1 );
   18fc4:	fb03 f606 	mul.w	r6, r3, r6
   18fc8:	eb06 462a 	add.w	r6, r6, sl, asr #16
        Y      = silk_SUB32( in32, S[ 1 ] );
   18fcc:	eba7 0a05 	sub.w	sl, r7, r5
        X      = silk_SMLAWB( Y, Y, silk_resampler_down2_1 );
   18fd0:	4426      	add	r6, r4
        X      = silk_SMULWB( Y, silk_resampler_down2_0 );
   18fd2:	fa1f f48a 	uxth.w	r4, sl
   18fd6:	ea4f 4a2a 	mov.w	sl, sl, asr #16
   18fda:	fb0e f404 	mul.w	r4, lr, r4
        out32  = silk_ADD32( S[ 0 ], X );
   18fde:	44b3      	add	fp, r6
        X      = silk_SMULWB( Y, silk_resampler_down2_0 );
   18fe0:	fb0e fa0a 	mul.w	sl, lr, sl
        out32  = silk_ADD32( out32, S[ 1 ] );
   18fe4:	44ab      	add	fp, r5
        X      = silk_SMULWB( Y, silk_resampler_down2_0 );
   18fe6:	eb0a 4514 	add.w	r5, sl, r4, lsr #16
        out32  = silk_ADD32( out32, X );
   18fea:	eb0b 0405 	add.w	r4, fp, r5
        out[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32, 11 ) );
   18fee:	12a4      	asrs	r4, r4, #10
   18ff0:	3401      	adds	r4, #1
   18ff2:	1064      	asrs	r4, r4, #1
   18ff4:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
        S[ 0 ] = silk_ADD32( in32, X );
   18ff8:	eb06 0b0c 	add.w	fp, r6, ip
        S[ 1 ] = silk_ADD32( in32, X );
   18ffc:	443d      	add	r5, r7
        out[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32, 11 ) );
   18ffe:	dbca      	blt.n	18f96 <silk_resampler_down2+0x26>
   19000:	3204      	adds	r2, #4
   19002:	f647 74ff 	movw	r4, #32767	; 0x7fff
    for( k = 0; k < len2; k++ ) {
   19006:	4590      	cmp	r8, r2
        out[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32, 11 ) );
   19008:	f821 4f02 	strh.w	r4, [r1, #2]!
    for( k = 0; k < len2; k++ ) {
   1900c:	d1cc      	bne.n	18fa8 <silk_resampler_down2+0x38>
   1900e:	e9c0 b500 	strd	fp, r5, [r0]
    }
}
   19012:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        out[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32, 11 ) );
   19016:	464c      	mov	r4, r9
   19018:	e7c1      	b.n	18f9e <silk_resampler_down2+0x2e>
   1901a:	bf00      	nop
   1901c:	ffff9b81 	.word	0xffff9b81
   19020:	ffff8000 	.word	0xffff8000

00019024 <silk_resampler_private_AR2>:
    opus_int32                      out_Q8[],       /* O    Output signal               */
    const opus_int16                in[],           /* I    Input signal                */
    const opus_int16                A_Q14[],        /* I    AR coefficients, Q14        */
    opus_int32                      len             /* I    Signal length               */
)
{
   19024:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   19028:	9c06      	ldr	r4, [sp, #24]
    opus_int32    k;
    opus_int32    out32;

    for( k = 0; k < len; k++ ) {
   1902a:	2c00      	cmp	r4, #0
   1902c:	dd23      	ble.n	19076 <silk_resampler_private_AR2+0x52>
   1902e:	3a02      	subs	r2, #2
        out32       = silk_ADD_LSHIFT32( S[ 0 ], (opus_int32)in[ k ], 8 );
        out_Q8[ k ] = out32;
        out32       = silk_LSHIFT( out32, 2 );
        S[ 0 ]      = silk_SMLAWB( S[ 1 ], out32, A_Q14[ 0 ] );
   19030:	f9b3 7000 	ldrsh.w	r7, [r3]
        S[ 1 ]      = silk_SMULWB( out32, A_Q14[ 1 ] );
   19034:	f9b3 6002 	ldrsh.w	r6, [r3, #2]
   19038:	6803      	ldr	r3, [r0, #0]
   1903a:	eb02 0c44 	add.w	ip, r2, r4, lsl #1
   1903e:	3904      	subs	r1, #4
        out32       = silk_ADD_LSHIFT32( S[ 0 ], (opus_int32)in[ k ], 8 );
   19040:	f932 4f02 	ldrsh.w	r4, [r2, #2]!
   19044:	eb03 2404 	add.w	r4, r3, r4, lsl #8
        out_Q8[ k ] = out32;
   19048:	f841 4f04 	str.w	r4, [r1, #4]!
        out32       = silk_LSHIFT( out32, 2 );
   1904c:	00a4      	lsls	r4, r4, #2
        S[ 0 ]      = silk_SMLAWB( S[ 1 ], out32, A_Q14[ 0 ] );
   1904e:	1425      	asrs	r5, r4, #16
   19050:	b2a4      	uxth	r4, r4
   19052:	fb04 f807 	mul.w	r8, r4, r7
   19056:	fb07 fe05 	mul.w	lr, r7, r5
   1905a:	6843      	ldr	r3, [r0, #4]
        S[ 1 ]      = silk_SMULWB( out32, A_Q14[ 1 ] );
   1905c:	fb06 f404 	mul.w	r4, r6, r4
        S[ 0 ]      = silk_SMLAWB( S[ 1 ], out32, A_Q14[ 0 ] );
   19060:	eb0e 4e28 	add.w	lr, lr, r8, asr #16
        S[ 1 ]      = silk_SMULWB( out32, A_Q14[ 1 ] );
   19064:	fb06 f505 	mul.w	r5, r6, r5
   19068:	eb05 4424 	add.w	r4, r5, r4, asr #16
        S[ 0 ]      = silk_SMLAWB( S[ 1 ], out32, A_Q14[ 0 ] );
   1906c:	4473      	add	r3, lr
    for( k = 0; k < len; k++ ) {
   1906e:	4594      	cmp	ip, r2
        S[ 1 ]      = silk_SMULWB( out32, A_Q14[ 1 ] );
   19070:	e9c0 3400 	strd	r3, r4, [r0]
    for( k = 0; k < len; k++ ) {
   19074:	d1e4      	bne.n	19040 <silk_resampler_private_AR2+0x1c>
    }
}
   19076:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1907a:	bf00      	nop

0001907c <silk_resampler_private_down_FIR>:
    void                            *SS,            /* I/O  Resampler state             */
    opus_int16                      out[],          /* O    Output signal               */
    const opus_int16                in[],           /* I    Input signal                */
    opus_int32                      inLen           /* I    Number of input samples     */
)
{
   1907c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   19080:	4606      	mov	r6, r0
   19082:	b091      	sub	sp, #68	; 0x44
   19084:	af02      	add	r7, sp, #8
    opus_int32 max_index_Q16, index_increment_Q16;
    VARDECL( opus_int32, buf );
    const opus_int16 *FIR_Coefs;
    SAVE_STACK;

    ALLOC( buf, S->batchSize + S->FIR_Order, opus_int32 );
   19086:	f8d6 510c 	ldr.w	r5, [r6, #268]	; 0x10c
   1908a:	f8d6 4114 	ldr.w	r4, [r6, #276]	; 0x114
{
   1908e:	61f8      	str	r0, [r7, #28]

    /* Copy buffered samples to start of buffer */
    silk_memcpy( buf, S->sFIR.i32, S->FIR_Order * sizeof( opus_int32 ) );
   19090:	3018      	adds	r0, #24
   19092:	60f8      	str	r0, [r7, #12]
    ALLOC( buf, S->batchSize + S->FIR_Order, opus_int32 );
   19094:	1928      	adds	r0, r5, r4
   19096:	0080      	lsls	r0, r0, #2
   19098:	300a      	adds	r0, #10
   1909a:	f020 0007 	bic.w	r0, r0, #7
   1909e:	ebad 0d00 	sub.w	sp, sp, r0
    silk_memcpy( buf, S->sFIR.i32, S->FIR_Order * sizeof( opus_int32 ) );
   190a2:	00a4      	lsls	r4, r4, #2
    ALLOC( buf, S->batchSize + S->FIR_Order, opus_int32 );
   190a4:	f10d 0a08 	add.w	sl, sp, #8
{
   190a8:	e9c7 2109 	strd	r2, r1, [r7, #36]	; 0x24
    silk_memcpy( buf, S->sFIR.i32, S->FIR_Order * sizeof( opus_int32 ) );
   190ac:	4650      	mov	r0, sl
   190ae:	68f9      	ldr	r1, [r7, #12]
{
   190b0:	623b      	str	r3, [r7, #32]
    silk_memcpy( buf, S->sFIR.i32, S->FIR_Order * sizeof( opus_int32 ) );
   190b2:	4622      	mov	r2, r4
   190b4:	f7f3 f824 	bl	c100 <memcpy>

    FIR_Coefs = &S->Coefs[ 2 ];
   190b8:	f8d6 8128 	ldr.w	r8, [r6, #296]	; 0x128

    /* Iterate over blocks of frameSizeIn input samples */
    index_increment_Q16 = S->invRatio_Q16;
   190bc:	f8d6 3110 	ldr.w	r3, [r6, #272]	; 0x110
   190c0:	62fb      	str	r3, [r7, #44]	; 0x2c
    FIR_Coefs = &S->Coefs[ 2 ];
   190c2:	f108 0304 	add.w	r3, r8, #4
   190c6:	607b      	str	r3, [r7, #4]
   190c8:	4629      	mov	r1, r5
   190ca:	4643      	mov	r3, r8
   190cc:	e01e      	b.n	1910c <silk_resampler_private_down_FIR+0x90>
    switch( FIR_Order ) {
   190ce:	2b24      	cmp	r3, #36	; 0x24
   190d0:	f000 823f 	beq.w	19552 <silk_resampler_private_down_FIR+0x4d6>
   190d4:	2b12      	cmp	r3, #18
   190d6:	f000 810a 	beq.w	192ee <silk_resampler_private_down_FIR+0x272>
        /* Interpolate filtered signal */
        out = silk_resampler_private_down_FIR_INTERPOL( out, buf, FIR_Coefs, S->FIR_Order,
            S->FIR_Fracs, max_index_Q16, index_increment_Q16 );

        in += nSamplesIn;
        inLen -= nSamplesIn;
   190da:	69bb      	ldr	r3, [r7, #24]
   190dc:	6a3a      	ldr	r2, [r7, #32]
   190de:	1ad0      	subs	r0, r2, r3
        in += nSamplesIn;
   190e0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
        inLen -= nSamplesIn;
   190e2:	6238      	str	r0, [r7, #32]
        in += nSamplesIn;
   190e4:	4611      	mov	r1, r2
   190e6:	eb01 0243 	add.w	r2, r1, r3, lsl #1
   190ea:	eb0a 0183 	add.w	r1, sl, r3, lsl #2
   190ee:	697b      	ldr	r3, [r7, #20]
   190f0:	627a      	str	r2, [r7, #36]	; 0x24
   190f2:	009c      	lsls	r4, r3, #2

        if( inLen > 1 ) {
   190f4:	2801      	cmp	r0, #1
            /* More iterations to do; copy last part of filtered signal to beginning of buffer */
            silk_memcpy( buf, &buf[ nSamplesIn ], S->FIR_Order * sizeof( opus_int32 ) );
   190f6:	4622      	mov	r2, r4
        if( inLen > 1 ) {
   190f8:	f340 8370 	ble.w	197dc <silk_resampler_private_down_FIR+0x760>
            silk_memcpy( buf, &buf[ nSamplesIn ], S->FIR_Order * sizeof( opus_int32 ) );
   190fc:	4650      	mov	r0, sl
   190fe:	f7f2 ffff 	bl	c100 <memcpy>
   19102:	69fb      	ldr	r3, [r7, #28]
   19104:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
   19108:	f8d3 3128 	ldr.w	r3, [r3, #296]	; 0x128
        nSamplesIn = silk_min( inLen, S->batchSize );
   1910c:	6a3a      	ldr	r2, [r7, #32]
   1910e:	460d      	mov	r5, r1
   19110:	4291      	cmp	r1, r2
        silk_resampler_private_AR2( S->sIIR, &buf[ S->FIR_Order ], in, S->Coefs, nSamplesIn );
   19112:	eb0a 0104 	add.w	r1, sl, r4
   19116:	69fc      	ldr	r4, [r7, #28]
        nSamplesIn = silk_min( inLen, S->batchSize );
   19118:	bfa8      	it	ge
   1911a:	4615      	movge	r5, r2
        silk_resampler_private_AR2( S->sIIR, &buf[ S->FIR_Order ], in, S->Coefs, nSamplesIn );
   1911c:	9500      	str	r5, [sp, #0]
   1911e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
        nSamplesIn = silk_min( inLen, S->batchSize );
   19120:	61bd      	str	r5, [r7, #24]
        silk_resampler_private_AR2( S->sIIR, &buf[ S->FIR_Order ], in, S->Coefs, nSamplesIn );
   19122:	4620      	mov	r0, r4
   19124:	f7ff ff7e 	bl	19024 <silk_resampler_private_AR2>
        out = silk_resampler_private_down_FIR_INTERPOL( out, buf, FIR_Coefs, S->FIR_Order,
   19128:	f8d4 3114 	ldr.w	r3, [r4, #276]	; 0x114
   1912c:	617b      	str	r3, [r7, #20]
        max_index_Q16 = silk_LSHIFT32( nSamplesIn, 16 );
   1912e:	042a      	lsls	r2, r5, #16
    switch( FIR_Order ) {
   19130:	2b18      	cmp	r3, #24
        max_index_Q16 = silk_LSHIFT32( nSamplesIn, 16 );
   19132:	637a      	str	r2, [r7, #52]	; 0x34
    switch( FIR_Order ) {
   19134:	d1cb      	bne.n	190ce <silk_resampler_private_down_FIR+0x52>
            for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
   19136:	2a00      	cmp	r2, #0
   19138:	ddcf      	ble.n	190da <silk_resampler_private_down_FIR+0x5e>
   1913a:	f04f 0c00 	mov.w	ip, #0
   1913e:	f8d7 b028 	ldr.w	fp, [r7, #40]	; 0x28
   19142:	e00c      	b.n	1915e <silk_resampler_private_down_FIR+0xe2>
                *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q6, 6 ) );
   19144:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   19148:	f2c0 80cf 	blt.w	192ea <silk_resampler_private_down_FIR+0x26e>
   1914c:	b21b      	sxth	r3, r3
            for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
   1914e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
                *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q6, 6 ) );
   19150:	f82b 3b02 	strh.w	r3, [fp], #2
            for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
   19154:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   19156:	4494      	add	ip, r2
   19158:	4563      	cmp	r3, ip
   1915a:	f340 80c3 	ble.w	192e4 <silk_resampler_private_down_FIR+0x268>
                buf_ptr = buf + silk_RSHIFT( index_Q16, 16 );
   1915e:	ea4f 422c 	mov.w	r2, ip, asr #16
   19162:	eb0a 0382 	add.w	r3, sl, r2, lsl #2
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  1 ], buf_ptr[ 22 ] ), FIR_Coefs[  1 ] );
   19166:	e9d3 0416 	ldrd	r0, r4, [r3, #88]	; 0x58
                res_Q6 = silk_SMULWB(         silk_ADD32( buf_ptr[  0 ], buf_ptr[ 23 ] ), FIR_Coefs[  0 ] );
   1916a:	f85a 1022 	ldr.w	r1, [sl, r2, lsl #2]
   1916e:	f9b8 6004 	ldrsh.w	r6, [r8, #4]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  1 ], buf_ptr[ 22 ] ), FIR_Coefs[  1 ] );
   19172:	685a      	ldr	r2, [r3, #4]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  2 ], buf_ptr[ 21 ] ), FIR_Coefs[  2 ] );
   19174:	6d5d      	ldr	r5, [r3, #84]	; 0x54
                res_Q6 = silk_SMULWB(         silk_ADD32( buf_ptr[  0 ], buf_ptr[ 23 ] ), FIR_Coefs[  0 ] );
   19176:	4421      	add	r1, r4
   19178:	fa1f f981 	uxth.w	r9, r1
   1917c:	1409      	asrs	r1, r1, #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  1 ], buf_ptr[ 22 ] ), FIR_Coefs[  1 ] );
   1917e:	eb00 0e02 	add.w	lr, r0, r2
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  2 ], buf_ptr[ 21 ] ), FIR_Coefs[  2 ] );
   19182:	689c      	ldr	r4, [r3, #8]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  1 ], buf_ptr[ 22 ] ), FIR_Coefs[  1 ] );
   19184:	f9b8 2006 	ldrsh.w	r2, [r8, #6]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  3 ], buf_ptr[ 20 ] ), FIR_Coefs[  3 ] );
   19188:	6d18      	ldr	r0, [r3, #80]	; 0x50
                res_Q6 = silk_SMULWB(         silk_ADD32( buf_ptr[  0 ], buf_ptr[ 23 ] ), FIR_Coefs[  0 ] );
   1918a:	fb06 f101 	mul.w	r1, r6, r1
   1918e:	fb06 f909 	mul.w	r9, r6, r9
   19192:	eb01 4929 	add.w	r9, r1, r9, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  1 ], buf_ptr[ 22 ] ), FIR_Coefs[  1 ] );
   19196:	fa1f f18e 	uxth.w	r1, lr
   1919a:	ea4f 4e2e 	mov.w	lr, lr, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  2 ], buf_ptr[ 21 ] ), FIR_Coefs[  2 ] );
   1919e:	442c      	add	r4, r5
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  1 ], buf_ptr[ 22 ] ), FIR_Coefs[  1 ] );
   191a0:	fb02 f101 	mul.w	r1, r2, r1
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  3 ], buf_ptr[ 20 ] ), FIR_Coefs[  3 ] );
   191a4:	68dd      	ldr	r5, [r3, #12]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  2 ], buf_ptr[ 21 ] ), FIR_Coefs[  2 ] );
   191a6:	f9b8 6008 	ldrsh.w	r6, [r8, #8]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  1 ], buf_ptr[ 22 ] ), FIR_Coefs[  1 ] );
   191aa:	fb02 f20e 	mul.w	r2, r2, lr
   191ae:	eb02 4221 	add.w	r2, r2, r1, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  3 ], buf_ptr[ 20 ] ), FIR_Coefs[  3 ] );
   191b2:	4428      	add	r0, r5
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  4 ], buf_ptr[ 19 ] ), FIR_Coefs[  4 ] );
   191b4:	6919      	ldr	r1, [r3, #16]
   191b6:	6cdd      	ldr	r5, [r3, #76]	; 0x4c
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  1 ], buf_ptr[ 22 ] ), FIR_Coefs[  1 ] );
   191b8:	4491      	add	r9, r2
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  2 ], buf_ptr[ 21 ] ), FIR_Coefs[  2 ] );
   191ba:	b2a2      	uxth	r2, r4
   191bc:	1424      	asrs	r4, r4, #16
   191be:	fb06 f404 	mul.w	r4, r6, r4
   191c2:	fb06 f202 	mul.w	r2, r6, r2
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  4 ], buf_ptr[ 19 ] ), FIR_Coefs[  4 ] );
   191c6:	440d      	add	r5, r1
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  2 ], buf_ptr[ 21 ] ), FIR_Coefs[  2 ] );
   191c8:	eb04 4222 	add.w	r2, r4, r2, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  5 ], buf_ptr[ 18 ] ), FIR_Coefs[  5 ] );
   191cc:	6959      	ldr	r1, [r3, #20]
   191ce:	6c9c      	ldr	r4, [r3, #72]	; 0x48
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  3 ], buf_ptr[ 20 ] ), FIR_Coefs[  3 ] );
   191d0:	f9b8 600a 	ldrsh.w	r6, [r8, #10]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  5 ], buf_ptr[ 18 ] ), FIR_Coefs[  5 ] );
   191d4:	eb04 0e01 	add.w	lr, r4, r1
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  3 ], buf_ptr[ 20 ] ), FIR_Coefs[  3 ] );
   191d8:	b281      	uxth	r1, r0
   191da:	1400      	asrs	r0, r0, #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  2 ], buf_ptr[ 21 ] ), FIR_Coefs[  2 ] );
   191dc:	eb02 0409 	add.w	r4, r2, r9
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  3 ], buf_ptr[ 20 ] ), FIR_Coefs[  3 ] );
   191e0:	fb06 f000 	mul.w	r0, r6, r0
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  6 ], buf_ptr[ 17 ] ), FIR_Coefs[  6 ] );
   191e4:	699a      	ldr	r2, [r3, #24]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  3 ], buf_ptr[ 20 ] ), FIR_Coefs[  3 ] );
   191e6:	fb06 f101 	mul.w	r1, r6, r1
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  6 ], buf_ptr[ 17 ] ), FIR_Coefs[  6 ] );
   191ea:	6c5e      	ldr	r6, [r3, #68]	; 0x44
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  3 ], buf_ptr[ 20 ] ), FIR_Coefs[  3 ] );
   191ec:	eb00 4121 	add.w	r1, r0, r1, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  4 ], buf_ptr[ 19 ] ), FIR_Coefs[  4 ] );
   191f0:	f9b8 000c 	ldrsh.w	r0, [r8, #12]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  6 ], buf_ptr[ 17 ] ), FIR_Coefs[  6 ] );
   191f4:	eb06 0902 	add.w	r9, r6, r2
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  3 ], buf_ptr[ 20 ] ), FIR_Coefs[  3 ] );
   191f8:	190a      	adds	r2, r1, r4
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  4 ], buf_ptr[ 19 ] ), FIR_Coefs[  4 ] );
   191fa:	b2ac      	uxth	r4, r5
   191fc:	142d      	asrs	r5, r5, #16
   191fe:	fb00 f404 	mul.w	r4, r0, r4
   19202:	fb00 f505 	mul.w	r5, r0, r5
   19206:	eb05 4524 	add.w	r5, r5, r4, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  5 ], buf_ptr[ 18 ] ), FIR_Coefs[  5 ] );
   1920a:	f9b8 400e 	ldrsh.w	r4, [r8, #14]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  7 ], buf_ptr[ 16 ] ), FIR_Coefs[  7 ] );
   1920e:	6c18      	ldr	r0, [r3, #64]	; 0x40
   19210:	69de      	ldr	r6, [r3, #28]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  4 ], buf_ptr[ 19 ] ), FIR_Coefs[  4 ] );
   19212:	4415      	add	r5, r2
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  5 ], buf_ptr[ 18 ] ), FIR_Coefs[  5 ] );
   19214:	ea4f 412e 	mov.w	r1, lr, asr #16
   19218:	fa1f f28e 	uxth.w	r2, lr
   1921c:	fb04 f202 	mul.w	r2, r4, r2
   19220:	fb04 fe01 	mul.w	lr, r4, r1
   19224:	eb0e 4e22 	add.w	lr, lr, r2, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  8 ], buf_ptr[ 15 ] ), FIR_Coefs[  8 ] );
   19228:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
   1922a:	6a1a      	ldr	r2, [r3, #32]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  7 ], buf_ptr[ 16 ] ), FIR_Coefs[  7 ] );
   1922c:	4406      	add	r6, r0
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  6 ], buf_ptr[ 17 ] ), FIR_Coefs[  6 ] );
   1922e:	f9b8 0010 	ldrsh.w	r0, [r8, #16]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  8 ], buf_ptr[ 15 ] ), FIR_Coefs[  8 ] );
   19232:	4414      	add	r4, r2
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  6 ], buf_ptr[ 17 ] ), FIR_Coefs[  6 ] );
   19234:	fa1f f189 	uxth.w	r1, r9
   19238:	ea4f 4229 	mov.w	r2, r9, asr #16
   1923c:	fb00 f101 	mul.w	r1, r0, r1
   19240:	fb00 f902 	mul.w	r9, r0, r2
   19244:	eb09 4921 	add.w	r9, r9, r1, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  7 ], buf_ptr[ 16 ] ), FIR_Coefs[  7 ] );
   19248:	f9b8 0012 	ldrsh.w	r0, [r8, #18]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  9 ], buf_ptr[ 14 ] ), FIR_Coefs[  9 ] );
   1924c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   1924e:	6a59      	ldr	r1, [r3, #36]	; 0x24
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  5 ], buf_ptr[ 18 ] ), FIR_Coefs[  5 ] );
   19250:	44ae      	add	lr, r5
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  6 ], buf_ptr[ 17 ] ), FIR_Coefs[  6 ] );
   19252:	44ce      	add	lr, r9
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  7 ], buf_ptr[ 16 ] ), FIR_Coefs[  7 ] );
   19254:	fa1f f986 	uxth.w	r9, r6
   19258:	1436      	asrs	r6, r6, #16
   1925a:	fb00 f606 	mul.w	r6, r0, r6
   1925e:	fb00 f909 	mul.w	r9, r0, r9
   19262:	eb06 4929 	add.w	r9, r6, r9, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  8 ], buf_ptr[ 15 ] ), FIR_Coefs[  8 ] );
   19266:	f9b8 6014 	ldrsh.w	r6, [r8, #20]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 10 ], buf_ptr[ 13 ] ), FIR_Coefs[ 10 ] );
   1926a:	6b5d      	ldr	r5, [r3, #52]	; 0x34
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  9 ], buf_ptr[ 14 ] ), FIR_Coefs[  9 ] );
   1926c:	4411      	add	r1, r2
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  7 ], buf_ptr[ 16 ] ), FIR_Coefs[  7 ] );
   1926e:	44ce      	add	lr, r9
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 10 ], buf_ptr[ 13 ] ), FIR_Coefs[ 10 ] );
   19270:	6a9a      	ldr	r2, [r3, #40]	; 0x28
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  8 ], buf_ptr[ 15 ] ), FIR_Coefs[  8 ] );
   19272:	fa1f f984 	uxth.w	r9, r4
   19276:	1424      	asrs	r4, r4, #16
   19278:	fb06 f909 	mul.w	r9, r6, r9
   1927c:	fb06 f404 	mul.w	r4, r6, r4
   19280:	eb04 4629 	add.w	r6, r4, r9, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 10 ], buf_ptr[ 13 ] ), FIR_Coefs[ 10 ] );
   19284:	4415      	add	r5, r2
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  9 ], buf_ptr[ 14 ] ), FIR_Coefs[  9 ] );
   19286:	f9b8 4016 	ldrsh.w	r4, [r8, #22]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 10 ], buf_ptr[ 13 ] ), FIR_Coefs[ 10 ] );
   1928a:	f9b8 0018 	ldrsh.w	r0, [r8, #24]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 11 ], buf_ptr[ 12 ] ), FIR_Coefs[ 11 ] );
   1928e:	e9d3 320b 	ldrd	r3, r2, [r3, #44]	; 0x2c
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  8 ], buf_ptr[ 15 ] ), FIR_Coefs[  8 ] );
   19292:	44b6      	add	lr, r6
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  9 ], buf_ptr[ 14 ] ), FIR_Coefs[  9 ] );
   19294:	b28e      	uxth	r6, r1
   19296:	1409      	asrs	r1, r1, #16
   19298:	fb04 f606 	mul.w	r6, r4, r6
   1929c:	fb04 f101 	mul.w	r1, r4, r1
   192a0:	eb01 4426 	add.w	r4, r1, r6, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 11 ], buf_ptr[ 12 ] ), FIR_Coefs[ 11 ] );
   192a4:	4413      	add	r3, r2
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 10 ], buf_ptr[ 13 ] ), FIR_Coefs[ 10 ] );
   192a6:	b2ae      	uxth	r6, r5
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 11 ], buf_ptr[ 12 ] ), FIR_Coefs[ 11 ] );
   192a8:	f9b8 101a 	ldrsh.w	r1, [r8, #26]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 10 ], buf_ptr[ 13 ] ), FIR_Coefs[ 10 ] );
   192ac:	142d      	asrs	r5, r5, #16
   192ae:	fb00 f906 	mul.w	r9, r0, r6
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  9 ], buf_ptr[ 14 ] ), FIR_Coefs[  9 ] );
   192b2:	44a6      	add	lr, r4
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 10 ], buf_ptr[ 13 ] ), FIR_Coefs[ 10 ] );
   192b4:	fb00 f005 	mul.w	r0, r0, r5
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 11 ], buf_ptr[ 12 ] ), FIR_Coefs[ 11 ] );
   192b8:	b29c      	uxth	r4, r3
   192ba:	141b      	asrs	r3, r3, #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 10 ], buf_ptr[ 13 ] ), FIR_Coefs[ 10 ] );
   192bc:	eb00 4629 	add.w	r6, r0, r9, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 11 ], buf_ptr[ 12 ] ), FIR_Coefs[ 11 ] );
   192c0:	fb01 f404 	mul.w	r4, r1, r4
   192c4:	fb01 f303 	mul.w	r3, r1, r3
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 10 ], buf_ptr[ 13 ] ), FIR_Coefs[ 10 ] );
   192c8:	4476      	add	r6, lr
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 11 ], buf_ptr[ 12 ] ), FIR_Coefs[ 11 ] );
   192ca:	eb03 4324 	add.w	r3, r3, r4, asr #16
   192ce:	4433      	add	r3, r6
                *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q6, 6 ) );
   192d0:	115b      	asrs	r3, r3, #5
   192d2:	3301      	adds	r3, #1
   192d4:	105b      	asrs	r3, r3, #1
   192d6:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   192da:	f6ff af33 	blt.w	19144 <silk_resampler_private_down_FIR+0xc8>
   192de:	f647 73ff 	movw	r3, #32767	; 0x7fff
   192e2:	e734      	b.n	1914e <silk_resampler_private_down_FIR+0xd2>
   192e4:	f8c7 b028 	str.w	fp, [r7, #40]	; 0x28
   192e8:	e6f7      	b.n	190da <silk_resampler_private_down_FIR+0x5e>
   192ea:	4b9e      	ldr	r3, [pc, #632]	; (19564 <silk_resampler_private_down_FIR+0x4e8>)
   192ec:	e72f      	b.n	1914e <silk_resampler_private_down_FIR+0xd2>
            for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
   192ee:	2a00      	cmp	r2, #0
   192f0:	f77f aef3 	ble.w	190da <silk_resampler_private_down_FIR+0x5e>
        out = silk_resampler_private_down_FIR_INTERPOL( out, buf, FIR_Coefs, S->FIR_Order,
   192f4:	69fb      	ldr	r3, [r7, #28]
   192f6:	f8c7 8008 	str.w	r8, [r7, #8]
   192fa:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
   192fe:	f8d7 e004 	ldr.w	lr, [r7, #4]
   19302:	b21a      	sxth	r2, r3
   19304:	3b01      	subs	r3, #1
            for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
   19306:	2500      	movs	r5, #0
   19308:	633a      	str	r2, [r7, #48]	; 0x30
   1930a:	613b      	str	r3, [r7, #16]
   1930c:	e00e      	b.n	1932c <silk_resampler_private_down_FIR+0x2b0>
                *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q6, 6 ) );
   1930e:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   19312:	f2c0 811c 	blt.w	1954e <silk_resampler_private_down_FIR+0x4d2>
   19316:	b21b      	sxth	r3, r3
            for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
   19318:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   1931a:	4415      	add	r5, r2
                *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q6, 6 ) );
   1931c:	6aba      	ldr	r2, [r7, #40]	; 0x28
   1931e:	f822 3b02 	strh.w	r3, [r2], #2
            for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
   19322:	6b7b      	ldr	r3, [r7, #52]	; 0x34
                *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q6, 6 ) );
   19324:	62ba      	str	r2, [r7, #40]	; 0x28
            for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
   19326:	42ab      	cmp	r3, r5
   19328:	f340 8255 	ble.w	197d6 <silk_resampler_private_down_FIR+0x75a>
                interpol_ind = silk_SMULWB( index_Q16 & 0xFFFF, FIR_Fracs );
   1932c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   1932e:	fa1f f885 	uxth.w	r8, r5
   19332:	fb03 f808 	mul.w	r8, r3, r8
                buf_ptr = buf + silk_RSHIFT( index_Q16, 16 );
   19336:	1429      	asrs	r1, r5, #16
                interpol_ind = silk_SMULWB( index_Q16 & 0xFFFF, FIR_Fracs );
   19338:	ea4f 4828 	mov.w	r8, r8, asr #16
                buf_ptr = buf + silk_RSHIFT( index_Q16, 16 );
   1933c:	eb0a 0381 	add.w	r3, sl, r1, lsl #2
                interpol_ptr = &FIR_Coefs[ RESAMPLER_DOWN_ORDER_FIR0 / 2 * interpol_ind ];
   19340:	eb08 02c8 	add.w	r2, r8, r8, lsl #3
   19344:	eb0e 0c42 	add.w	ip, lr, r2, lsl #1
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 1 ], interpol_ptr[ 1 ] );
   19348:	f8d3 9004 	ldr.w	r9, [r3, #4]
   1934c:	f9bc 0002 	ldrsh.w	r0, [ip, #2]
                res_Q6 = silk_SMULWB(         buf_ptr[ 0 ], interpol_ptr[ 0 ] );
   19350:	f85a 6021 	ldr.w	r6, [sl, r1, lsl #2]
   19354:	f93e b012 	ldrsh.w	fp, [lr, r2, lsl #1]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 2 ], interpol_ptr[ 2 ] );
   19358:	6899      	ldr	r1, [r3, #8]
   1935a:	f9bc 2004 	ldrsh.w	r2, [ip, #4]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 1 ], interpol_ptr[ 1 ] );
   1935e:	fa1f f489 	uxth.w	r4, r9
   19362:	ea4f 4929 	mov.w	r9, r9, asr #16
   19366:	fb00 f909 	mul.w	r9, r0, r9
   1936a:	fb00 f404 	mul.w	r4, r0, r4
   1936e:	eb09 4424 	add.w	r4, r9, r4, asr #16
                res_Q6 = silk_SMULWB(         buf_ptr[ 0 ], interpol_ptr[ 0 ] );
   19372:	fa1f f986 	uxth.w	r9, r6
   19376:	1436      	asrs	r6, r6, #16
   19378:	fb0b f909 	mul.w	r9, fp, r9
   1937c:	fb0b fb06 	mul.w	fp, fp, r6
   19380:	eb0b 4929 	add.w	r9, fp, r9, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 1 ], interpol_ptr[ 1 ] );
   19384:	44a1      	add	r9, r4
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 2 ], interpol_ptr[ 2 ] );
   19386:	b28c      	uxth	r4, r1
   19388:	1409      	asrs	r1, r1, #16
   1938a:	fb02 f404 	mul.w	r4, r2, r4
   1938e:	fb02 f201 	mul.w	r2, r2, r1
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 3 ], interpol_ptr[ 3 ] );
   19392:	68de      	ldr	r6, [r3, #12]
   19394:	f9bc 0006 	ldrsh.w	r0, [ip, #6]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 4 ], interpol_ptr[ 4 ] );
   19398:	6919      	ldr	r1, [r3, #16]
   1939a:	f9bc b008 	ldrsh.w	fp, [ip, #8]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 2 ], interpol_ptr[ 2 ] );
   1939e:	eb02 4224 	add.w	r2, r2, r4, asr #16
                interpol_ptr = &FIR_Coefs[ RESAMPLER_DOWN_ORDER_FIR0 / 2 * ( FIR_Fracs - 1 - interpol_ind ) ];
   193a2:	693c      	ldr	r4, [r7, #16]
   193a4:	eba4 0808 	sub.w	r8, r4, r8
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 2 ], interpol_ptr[ 2 ] );
   193a8:	eb02 0409 	add.w	r4, r2, r9
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 3 ], interpol_ptr[ 3 ] );
   193ac:	b2b2      	uxth	r2, r6
   193ae:	1436      	asrs	r6, r6, #16
   193b0:	fb00 f202 	mul.w	r2, r0, r2
   193b4:	fb00 f006 	mul.w	r0, r0, r6
   193b8:	eb00 4022 	add.w	r0, r0, r2, asr #16
   193bc:	1902      	adds	r2, r0, r4
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 4 ], interpol_ptr[ 4 ] );
   193be:	b28c      	uxth	r4, r1
   193c0:	1409      	asrs	r1, r1, #16
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 5 ], interpol_ptr[ 5 ] );
   193c2:	f8d3 9014 	ldr.w	r9, [r3, #20]
   193c6:	f9bc 600a 	ldrsh.w	r6, [ip, #10]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 4 ], interpol_ptr[ 4 ] );
   193ca:	fb0b f404 	mul.w	r4, fp, r4
   193ce:	fb0b f001 	mul.w	r0, fp, r1
   193d2:	eb00 4024 	add.w	r0, r0, r4, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 6 ], interpol_ptr[ 6 ] );
   193d6:	6999      	ldr	r1, [r3, #24]
   193d8:	f9bc b00c 	ldrsh.w	fp, [ip, #12]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 4 ], interpol_ptr[ 4 ] );
   193dc:	4410      	add	r0, r2
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 5 ], interpol_ptr[ 5 ] );
   193de:	fa1f f489 	uxth.w	r4, r9
   193e2:	ea4f 4229 	mov.w	r2, r9, asr #16
   193e6:	fb06 f904 	mul.w	r9, r6, r4
   193ea:	fb06 f602 	mul.w	r6, r6, r2
   193ee:	eb06 4629 	add.w	r6, r6, r9, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 6 ], interpol_ptr[ 6 ] );
   193f2:	fa1f f981 	uxth.w	r9, r1
   193f6:	1409      	asrs	r1, r1, #16
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 7 ], interpol_ptr[ 7 ] );
   193f8:	69da      	ldr	r2, [r3, #28]
   193fa:	f9bc 400e 	ldrsh.w	r4, [ip, #14]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 8 ], interpol_ptr[ 8 ] );
   193fe:	f9bc c010 	ldrsh.w	ip, [ip, #16]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 6 ], interpol_ptr[ 6 ] );
   19402:	fb0b f909 	mul.w	r9, fp, r9
   19406:	fb0b f101 	mul.w	r1, fp, r1
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 5 ], interpol_ptr[ 5 ] );
   1940a:	4406      	add	r6, r0
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 6 ], interpol_ptr[ 6 ] );
   1940c:	eb01 4129 	add.w	r1, r1, r9, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 8 ], interpol_ptr[ 8 ] );
   19410:	6a18      	ldr	r0, [r3, #32]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 17 ], interpol_ptr[ 0 ] );
   19412:	f8d3 b044 	ldr.w	fp, [r3, #68]	; 0x44
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 6 ], interpol_ptr[ 6 ] );
   19416:	4431      	add	r1, r6
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 7 ], interpol_ptr[ 7 ] );
   19418:	fa1f f982 	uxth.w	r9, r2
   1941c:	1416      	asrs	r6, r2, #16
                interpol_ptr = &FIR_Coefs[ RESAMPLER_DOWN_ORDER_FIR0 / 2 * ( FIR_Fracs - 1 - interpol_ind ) ];
   1941e:	eb08 08c8 	add.w	r8, r8, r8, lsl #3
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 7 ], interpol_ptr[ 7 ] );
   19422:	fb04 f209 	mul.w	r2, r4, r9
   19426:	fb04 f406 	mul.w	r4, r4, r6
   1942a:	eb04 4422 	add.w	r4, r4, r2, asr #16
                interpol_ptr = &FIR_Coefs[ RESAMPLER_DOWN_ORDER_FIR0 / 2 * ( FIR_Fracs - 1 - interpol_ind ) ];
   1942e:	eb0e 0648 	add.w	r6, lr, r8, lsl #1
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 8 ], interpol_ptr[ 8 ] );
   19432:	b282      	uxth	r2, r0
   19434:	1400      	asrs	r0, r0, #16
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 17 ], interpol_ptr[ 0 ] );
   19436:	f93e 9018 	ldrsh.w	r9, [lr, r8, lsl #1]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 16 ], interpol_ptr[ 1 ] );
   1943a:	f8d3 8040 	ldr.w	r8, [r3, #64]	; 0x40
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 7 ], interpol_ptr[ 7 ] );
   1943e:	440c      	add	r4, r1
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 8 ], interpol_ptr[ 8 ] );
   19440:	fb0c f102 	mul.w	r1, ip, r2
   19444:	fb0c f200 	mul.w	r2, ip, r0
   19448:	eb02 4221 	add.w	r2, r2, r1, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 17 ], interpol_ptr[ 0 ] );
   1944c:	fa1f f08b 	uxth.w	r0, fp
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 16 ], interpol_ptr[ 1 ] );
   19450:	f9b6 1002 	ldrsh.w	r1, [r6, #2]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 15 ], interpol_ptr[ 2 ] );
   19454:	f8d3 c03c 	ldr.w	ip, [r3, #60]	; 0x3c
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 17 ], interpol_ptr[ 0 ] );
   19458:	ea4f 4b2b 	mov.w	fp, fp, asr #16
   1945c:	fb09 f000 	mul.w	r0, r9, r0
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 8 ], interpol_ptr[ 8 ] );
   19460:	4422      	add	r2, r4
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 17 ], interpol_ptr[ 0 ] );
   19462:	fb09 fb0b 	mul.w	fp, r9, fp
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 16 ], interpol_ptr[ 1 ] );
   19466:	fa1f f488 	uxth.w	r4, r8
   1946a:	ea4f 4828 	mov.w	r8, r8, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 14 ], interpol_ptr[ 3 ] );
   1946e:	f8d3 9038 	ldr.w	r9, [r3, #56]	; 0x38
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 16 ], interpol_ptr[ 1 ] );
   19472:	fb01 f404 	mul.w	r4, r1, r4
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 17 ], interpol_ptr[ 0 ] );
   19476:	eb0b 4b20 	add.w	fp, fp, r0, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 16 ], interpol_ptr[ 1 ] );
   1947a:	fb01 f108 	mul.w	r1, r1, r8
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 15 ], interpol_ptr[ 2 ] );
   1947e:	f9b6 0004 	ldrsh.w	r0, [r6, #4]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 17 ], interpol_ptr[ 0 ] );
   19482:	4493      	add	fp, r2
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 15 ], interpol_ptr[ 2 ] );
   19484:	fa1f f88c 	uxth.w	r8, ip
   19488:	ea4f 422c 	mov.w	r2, ip, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 16 ], interpol_ptr[ 1 ] );
   1948c:	eb01 4124 	add.w	r1, r1, r4, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 14 ], interpol_ptr[ 3 ] );
   19490:	f9b6 c006 	ldrsh.w	ip, [r6, #6]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 13 ], interpol_ptr[ 4 ] );
   19494:	6b5c      	ldr	r4, [r3, #52]	; 0x34
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 15 ], interpol_ptr[ 2 ] );
   19496:	fb00 f808 	mul.w	r8, r0, r8
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 16 ], interpol_ptr[ 1 ] );
   1949a:	4459      	add	r1, fp
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 15 ], interpol_ptr[ 2 ] );
   1949c:	fb00 f002 	mul.w	r0, r0, r2
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 14 ], interpol_ptr[ 3 ] );
   194a0:	fa1f fb89 	uxth.w	fp, r9
   194a4:	ea4f 4929 	mov.w	r9, r9, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 15 ], interpol_ptr[ 2 ] );
   194a8:	eb00 4228 	add.w	r2, r0, r8, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 14 ], interpol_ptr[ 3 ] );
   194ac:	fb0c fb0b 	mul.w	fp, ip, fp
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 13 ], interpol_ptr[ 4 ] );
   194b0:	f9b6 8008 	ldrsh.w	r8, [r6, #8]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 12 ], interpol_ptr[ 5 ] );
   194b4:	6b18      	ldr	r0, [r3, #48]	; 0x30
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 14 ], interpol_ptr[ 3 ] );
   194b6:	fb0c fc09 	mul.w	ip, ip, r9
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 15 ], interpol_ptr[ 2 ] );
   194ba:	440a      	add	r2, r1
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 13 ], interpol_ptr[ 4 ] );
   194bc:	fa1f f984 	uxth.w	r9, r4
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 14 ], interpol_ptr[ 3 ] );
   194c0:	eb0c 4c2b 	add.w	ip, ip, fp, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 13 ], interpol_ptr[ 4 ] );
   194c4:	1424      	asrs	r4, r4, #16
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 12 ], interpol_ptr[ 5 ] );
   194c6:	f9b6 b00a 	ldrsh.w	fp, [r6, #10]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 11 ], interpol_ptr[ 6 ] );
   194ca:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 13 ], interpol_ptr[ 4 ] );
   194cc:	fb08 f909 	mul.w	r9, r8, r9
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 14 ], interpol_ptr[ 3 ] );
   194d0:	4494      	add	ip, r2
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 13 ], interpol_ptr[ 4 ] );
   194d2:	fb08 f404 	mul.w	r4, r8, r4
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[  9 ], interpol_ptr[ 8 ] );
   194d6:	e9d3 3209 	ldrd	r3, r2, [r3, #36]	; 0x24
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 12 ], interpol_ptr[ 5 ] );
   194da:	fa1f f880 	uxth.w	r8, r0
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 13 ], interpol_ptr[ 4 ] );
   194de:	eb04 4429 	add.w	r4, r4, r9, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 12 ], interpol_ptr[ 5 ] );
   194e2:	1400      	asrs	r0, r0, #16
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 11 ], interpol_ptr[ 6 ] );
   194e4:	f9b6 900c 	ldrsh.w	r9, [r6, #12]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 12 ], interpol_ptr[ 5 ] );
   194e8:	fb0b f000 	mul.w	r0, fp, r0
   194ec:	fb0b f808 	mul.w	r8, fp, r8
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 13 ], interpol_ptr[ 4 ] );
   194f0:	4464      	add	r4, ip
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 10 ], interpol_ptr[ 7 ] );
   194f2:	f9b6 b00e 	ldrsh.w	fp, [r6, #14]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[  9 ], interpol_ptr[ 8 ] );
   194f6:	f9b6 6010 	ldrsh.w	r6, [r6, #16]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 11 ], interpol_ptr[ 6 ] );
   194fa:	fa1f fc81 	uxth.w	ip, r1
   194fe:	1409      	asrs	r1, r1, #16
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 12 ], interpol_ptr[ 5 ] );
   19500:	eb00 4828 	add.w	r8, r0, r8, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 11 ], interpol_ptr[ 6 ] );
   19504:	fb09 fc0c 	mul.w	ip, r9, ip
   19508:	fb09 f101 	mul.w	r1, r9, r1
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 10 ], interpol_ptr[ 7 ] );
   1950c:	fa1f f982 	uxth.w	r9, r2
   19510:	1412      	asrs	r2, r2, #16
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[  9 ], interpol_ptr[ 8 ] );
   19512:	b298      	uxth	r0, r3
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 12 ], interpol_ptr[ 5 ] );
   19514:	44a0      	add	r8, r4
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 11 ], interpol_ptr[ 6 ] );
   19516:	eb01 412c 	add.w	r1, r1, ip, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 10 ], interpol_ptr[ 7 ] );
   1951a:	fb0b f909 	mul.w	r9, fp, r9
   1951e:	fb0b f202 	mul.w	r2, fp, r2
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[  9 ], interpol_ptr[ 8 ] );
   19522:	141b      	asrs	r3, r3, #16
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 11 ], interpol_ptr[ 6 ] );
   19524:	4488      	add	r8, r1
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 10 ], interpol_ptr[ 7 ] );
   19526:	eb02 4229 	add.w	r2, r2, r9, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[  9 ], interpol_ptr[ 8 ] );
   1952a:	fb06 f000 	mul.w	r0, r6, r0
   1952e:	fb06 f303 	mul.w	r3, r6, r3
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 10 ], interpol_ptr[ 7 ] );
   19532:	4490      	add	r8, r2
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[  9 ], interpol_ptr[ 8 ] );
   19534:	eb03 4320 	add.w	r3, r3, r0, asr #16
   19538:	4443      	add	r3, r8
                *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q6, 6 ) );
   1953a:	115b      	asrs	r3, r3, #5
   1953c:	3301      	adds	r3, #1
   1953e:	105b      	asrs	r3, r3, #1
   19540:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   19544:	f6ff aee3 	blt.w	1930e <silk_resampler_private_down_FIR+0x292>
   19548:	f647 73ff 	movw	r3, #32767	; 0x7fff
   1954c:	e6e4      	b.n	19318 <silk_resampler_private_down_FIR+0x29c>
   1954e:	4b05      	ldr	r3, [pc, #20]	; (19564 <silk_resampler_private_down_FIR+0x4e8>)
   19550:	e6e2      	b.n	19318 <silk_resampler_private_down_FIR+0x29c>
            for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
   19552:	2a00      	cmp	r2, #0
   19554:	f77f adc1 	ble.w	190da <silk_resampler_private_down_FIR+0x5e>
   19558:	2600      	movs	r6, #0
   1955a:	633e      	str	r6, [r7, #48]	; 0x30
   1955c:	f8d7 b028 	ldr.w	fp, [r7, #40]	; 0x28
   19560:	e011      	b.n	19586 <silk_resampler_private_down_FIR+0x50a>
   19562:	bf00      	nop
   19564:	ffff8000 	.word	0xffff8000
                *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q6, 6 ) );
   19568:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   1956c:	f2c0 8131 	blt.w	197d2 <silk_resampler_private_down_FIR+0x756>
   19570:	b21b      	sxth	r3, r3
            for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
   19572:	e9d7 210b 	ldrd	r2, r1, [r7, #44]	; 0x2c
                *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q6, 6 ) );
   19576:	f82b 3b02 	strh.w	r3, [fp], #2
            for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
   1957a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1957c:	4411      	add	r1, r2
   1957e:	428b      	cmp	r3, r1
   19580:	6339      	str	r1, [r7, #48]	; 0x30
   19582:	f77f aeaf 	ble.w	192e4 <silk_resampler_private_down_FIR+0x268>
                buf_ptr = buf + silk_RSHIFT( index_Q16, 16 );
   19586:	6b3b      	ldr	r3, [r7, #48]	; 0x30
                res_Q6 = silk_SMULWB(         silk_ADD32( buf_ptr[  0 ], buf_ptr[ 35 ] ), FIR_Coefs[  0 ] );
   19588:	f9b8 5004 	ldrsh.w	r5, [r8, #4]
                buf_ptr = buf + silk_RSHIFT( index_Q16, 16 );
   1958c:	141a      	asrs	r2, r3, #16
   1958e:	eb0a 0382 	add.w	r3, sl, r2, lsl #2
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  1 ], buf_ptr[ 34 ] ), FIR_Coefs[  1 ] );
   19592:	e9d3 1022 	ldrd	r1, r0, [r3, #136]	; 0x88
                res_Q6 = silk_SMULWB(         silk_ADD32( buf_ptr[  0 ], buf_ptr[ 35 ] ), FIR_Coefs[  0 ] );
   19596:	f85a 4022 	ldr.w	r4, [sl, r2, lsl #2]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  1 ], buf_ptr[ 34 ] ), FIR_Coefs[  1 ] );
   1959a:	685a      	ldr	r2, [r3, #4]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  5 ], buf_ptr[ 30 ] ), FIR_Coefs[  5 ] );
   1959c:	6f9e      	ldr	r6, [r3, #120]	; 0x78
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  1 ], buf_ptr[ 34 ] ), FIR_Coefs[  1 ] );
   1959e:	eb01 0e02 	add.w	lr, r1, r2
                res_Q6 = silk_SMULWB(         silk_ADD32( buf_ptr[  0 ], buf_ptr[ 35 ] ), FIR_Coefs[  0 ] );
   195a2:	4420      	add	r0, r4
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  2 ], buf_ptr[ 33 ] ), FIR_Coefs[  2 ] );
   195a4:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   195a8:	689c      	ldr	r4, [r3, #8]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  3 ], buf_ptr[ 32 ] ), FIR_Coefs[  3 ] );
   195aa:	68d9      	ldr	r1, [r3, #12]
                res_Q6 = silk_SMULWB(         silk_ADD32( buf_ptr[  0 ], buf_ptr[ 35 ] ), FIR_Coefs[  0 ] );
   195ac:	ea4f 4c20 	mov.w	ip, r0, asr #16
   195b0:	fa1f f980 	uxth.w	r9, r0
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  3 ], buf_ptr[ 32 ] ), FIR_Coefs[  3 ] );
   195b4:	f8d3 0080 	ldr.w	r0, [r3, #128]	; 0x80
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  2 ], buf_ptr[ 33 ] ), FIR_Coefs[  2 ] );
   195b8:	4414      	add	r4, r2
                res_Q6 = silk_SMULWB(         silk_ADD32( buf_ptr[  0 ], buf_ptr[ 35 ] ), FIR_Coefs[  0 ] );
   195ba:	fb05 f909 	mul.w	r9, r5, r9
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  1 ], buf_ptr[ 34 ] ), FIR_Coefs[  1 ] );
   195be:	f9b8 2006 	ldrsh.w	r2, [r8, #6]
                res_Q6 = silk_SMULWB(         silk_ADD32( buf_ptr[  0 ], buf_ptr[ 35 ] ), FIR_Coefs[  0 ] );
   195c2:	fb05 f50c 	mul.w	r5, r5, ip
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  3 ], buf_ptr[ 32 ] ), FIR_Coefs[  3 ] );
   195c6:	4408      	add	r0, r1
                res_Q6 = silk_SMULWB(         silk_ADD32( buf_ptr[  0 ], buf_ptr[ 35 ] ), FIR_Coefs[  0 ] );
   195c8:	eb05 4529 	add.w	r5, r5, r9, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  1 ], buf_ptr[ 34 ] ), FIR_Coefs[  1 ] );
   195cc:	ea4f 412e 	mov.w	r1, lr, asr #16
   195d0:	fa1f f98e 	uxth.w	r9, lr
   195d4:	fb02 f909 	mul.w	r9, r2, r9
   195d8:	fb02 f201 	mul.w	r2, r2, r1
   195dc:	eb02 4929 	add.w	r9, r2, r9, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  4 ], buf_ptr[ 31 ] ), FIR_Coefs[  4 ] );
   195e0:	6fd9      	ldr	r1, [r3, #124]	; 0x7c
   195e2:	691a      	ldr	r2, [r3, #16]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  2 ], buf_ptr[ 33 ] ), FIR_Coefs[  2 ] );
   195e4:	f9b8 c008 	ldrsh.w	ip, [r8, #8]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  4 ], buf_ptr[ 31 ] ), FIR_Coefs[  4 ] );
   195e8:	4411      	add	r1, r2
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  1 ], buf_ptr[ 34 ] ), FIR_Coefs[  1 ] );
   195ea:	eb09 0205 	add.w	r2, r9, r5
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  2 ], buf_ptr[ 33 ] ), FIR_Coefs[  2 ] );
   195ee:	fa1f f984 	uxth.w	r9, r4
   195f2:	1424      	asrs	r4, r4, #16
   195f4:	fb0c f404 	mul.w	r4, ip, r4
   195f8:	fb0c f909 	mul.w	r9, ip, r9
   195fc:	eb04 4929 	add.w	r9, r4, r9, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  3 ], buf_ptr[ 32 ] ), FIR_Coefs[  3 ] );
   19600:	f9b8 400a 	ldrsh.w	r4, [r8, #10]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  4 ], buf_ptr[ 31 ] ), FIR_Coefs[  4 ] );
   19604:	f9b8 c00c 	ldrsh.w	ip, [r8, #12]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  5 ], buf_ptr[ 30 ] ), FIR_Coefs[  5 ] );
   19608:	695d      	ldr	r5, [r3, #20]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  3 ], buf_ptr[ 32 ] ), FIR_Coefs[  3 ] );
   1960a:	fa1f fe80 	uxth.w	lr, r0
   1960e:	1400      	asrs	r0, r0, #16
   19610:	fb04 f000 	mul.w	r0, r4, r0
   19614:	fb04 fe0e 	mul.w	lr, r4, lr
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  2 ], buf_ptr[ 33 ] ), FIR_Coefs[  2 ] );
   19618:	4491      	add	r9, r2
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  3 ], buf_ptr[ 32 ] ), FIR_Coefs[  3 ] );
   1961a:	eb00 4e2e 	add.w	lr, r0, lr, asr #16
   1961e:	eb0e 0009 	add.w	r0, lr, r9
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  4 ], buf_ptr[ 31 ] ), FIR_Coefs[  4 ] );
   19622:	fa1f fe81 	uxth.w	lr, r1
   19626:	1409      	asrs	r1, r1, #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  6 ], buf_ptr[ 29 ] ), FIR_Coefs[  6 ] );
   19628:	699a      	ldr	r2, [r3, #24]
   1962a:	6f5c      	ldr	r4, [r3, #116]	; 0x74
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  5 ], buf_ptr[ 30 ] ), FIR_Coefs[  5 ] );
   1962c:	f9b8 900e 	ldrsh.w	r9, [r8, #14]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  4 ], buf_ptr[ 31 ] ), FIR_Coefs[  4 ] );
   19630:	fb0c fe0e 	mul.w	lr, ip, lr
   19634:	fb0c fc01 	mul.w	ip, ip, r1
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  5 ], buf_ptr[ 30 ] ), FIR_Coefs[  5 ] );
   19638:	442e      	add	r6, r5
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  4 ], buf_ptr[ 31 ] ), FIR_Coefs[  4 ] );
   1963a:	eb0c 4c2e 	add.w	ip, ip, lr, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  7 ], buf_ptr[ 28 ] ), FIR_Coefs[  7 ] );
   1963e:	69d9      	ldr	r1, [r3, #28]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  4 ], buf_ptr[ 31 ] ), FIR_Coefs[  4 ] );
   19640:	eb0c 0e00 	add.w	lr, ip, r0
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  6 ], buf_ptr[ 29 ] ), FIR_Coefs[  6 ] );
   19644:	4414      	add	r4, r2
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  5 ], buf_ptr[ 30 ] ), FIR_Coefs[  5 ] );
   19646:	fa1f fc86 	uxth.w	ip, r6
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  7 ], buf_ptr[ 28 ] ), FIR_Coefs[  7 ] );
   1964a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  6 ], buf_ptr[ 29 ] ), FIR_Coefs[  6 ] );
   1964c:	f9b8 0010 	ldrsh.w	r0, [r8, #16]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  5 ], buf_ptr[ 30 ] ), FIR_Coefs[  5 ] );
   19650:	1435      	asrs	r5, r6, #16
   19652:	fb09 f505 	mul.w	r5, r9, r5
   19656:	fb09 fc0c 	mul.w	ip, r9, ip
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  7 ], buf_ptr[ 28 ] ), FIR_Coefs[  7 ] );
   1965a:	440a      	add	r2, r1
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  5 ], buf_ptr[ 30 ] ), FIR_Coefs[  5 ] );
   1965c:	eb05 4c2c 	add.w	ip, r5, ip, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  8 ], buf_ptr[ 27 ] ), FIR_Coefs[  8 ] );
   19660:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
   19662:	6a1d      	ldr	r5, [r3, #32]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  6 ], buf_ptr[ 29 ] ), FIR_Coefs[  6 ] );
   19664:	fa1f f984 	uxth.w	r9, r4
   19668:	1424      	asrs	r4, r4, #16
   1966a:	fb00 f404 	mul.w	r4, r0, r4
   1966e:	fb00 f909 	mul.w	r9, r0, r9
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  8 ], buf_ptr[ 27 ] ), FIR_Coefs[  8 ] );
   19672:	440d      	add	r5, r1
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  6 ], buf_ptr[ 29 ] ), FIR_Coefs[  6 ] );
   19674:	eb04 4929 	add.w	r9, r4, r9, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  9 ], buf_ptr[ 26 ] ), FIR_Coefs[  9 ] );
   19678:	6a59      	ldr	r1, [r3, #36]	; 0x24
   1967a:	6e9c      	ldr	r4, [r3, #104]	; 0x68
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  7 ], buf_ptr[ 28 ] ), FIR_Coefs[  7 ] );
   1967c:	f9b8 0012 	ldrsh.w	r0, [r8, #18]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  5 ], buf_ptr[ 30 ] ), FIR_Coefs[  5 ] );
   19680:	44f4      	add	ip, lr
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  9 ], buf_ptr[ 26 ] ), FIR_Coefs[  9 ] );
   19682:	eb04 0e01 	add.w	lr, r4, r1
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  6 ], buf_ptr[ 29 ] ), FIR_Coefs[  6 ] );
   19686:	eb09 040c 	add.w	r4, r9, ip
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  7 ], buf_ptr[ 28 ] ), FIR_Coefs[  7 ] );
   1968a:	fa1f f982 	uxth.w	r9, r2
   1968e:	1412      	asrs	r2, r2, #16
   19690:	fb00 f202 	mul.w	r2, r0, r2
   19694:	fb00 f909 	mul.w	r9, r0, r9
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 10 ], buf_ptr[ 25 ] ), FIR_Coefs[ 10 ] );
   19698:	6a99      	ldr	r1, [r3, #40]	; 0x28
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  8 ], buf_ptr[ 27 ] ), FIR_Coefs[  8 ] );
   1969a:	f9b8 0014 	ldrsh.w	r0, [r8, #20]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  7 ], buf_ptr[ 28 ] ), FIR_Coefs[  7 ] );
   1969e:	eb02 4929 	add.w	r9, r2, r9, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 10 ], buf_ptr[ 25 ] ), FIR_Coefs[ 10 ] );
   196a2:	6e5a      	ldr	r2, [r3, #100]	; 0x64
   196a4:	eb02 0c01 	add.w	ip, r2, r1
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  8 ], buf_ptr[ 27 ] ), FIR_Coefs[  8 ] );
   196a8:	b2aa      	uxth	r2, r5
   196aa:	142d      	asrs	r5, r5, #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  9 ], buf_ptr[ 26 ] ), FIR_Coefs[  9 ] );
   196ac:	f9b8 1016 	ldrsh.w	r1, [r8, #22]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 12 ], buf_ptr[ 23 ] ), FIR_Coefs[ 12 ] );
   196b0:	6dde      	ldr	r6, [r3, #92]	; 0x5c
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  7 ], buf_ptr[ 28 ] ), FIR_Coefs[  7 ] );
   196b2:	44a1      	add	r9, r4
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  8 ], buf_ptr[ 27 ] ), FIR_Coefs[  8 ] );
   196b4:	fb00 f202 	mul.w	r2, r0, r2
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 11 ], buf_ptr[ 24 ] ), FIR_Coefs[ 11 ] );
   196b8:	6adc      	ldr	r4, [r3, #44]	; 0x2c
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  8 ], buf_ptr[ 27 ] ), FIR_Coefs[  8 ] );
   196ba:	fb00 f005 	mul.w	r0, r0, r5
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 11 ], buf_ptr[ 24 ] ), FIR_Coefs[ 11 ] );
   196be:	6e1d      	ldr	r5, [r3, #96]	; 0x60
   196c0:	4425      	add	r5, r4
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  9 ], buf_ptr[ 26 ] ), FIR_Coefs[  9 ] );
   196c2:	fa1f f48e 	uxth.w	r4, lr
   196c6:	ea4f 4e2e 	mov.w	lr, lr, asr #16
   196ca:	fb01 f404 	mul.w	r4, r1, r4
   196ce:	fb01 f10e 	mul.w	r1, r1, lr
   196d2:	eb01 4124 	add.w	r1, r1, r4, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  8 ], buf_ptr[ 27 ] ), FIR_Coefs[  8 ] );
   196d6:	eb00 4022 	add.w	r0, r0, r2, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 12 ], buf_ptr[ 23 ] ), FIR_Coefs[ 12 ] );
   196da:	6b1c      	ldr	r4, [r3, #48]	; 0x30
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 10 ], buf_ptr[ 25 ] ), FIR_Coefs[ 10 ] );
   196dc:	f9b8 2018 	ldrsh.w	r2, [r8, #24]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  8 ], buf_ptr[ 27 ] ), FIR_Coefs[  8 ] );
   196e0:	4448      	add	r0, r9
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 12 ], buf_ptr[ 23 ] ), FIR_Coefs[ 12 ] );
   196e2:	4426      	add	r6, r4
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  9 ], buf_ptr[ 26 ] ), FIR_Coefs[  9 ] );
   196e4:	4408      	add	r0, r1
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 13 ], buf_ptr[ 22 ] ), FIR_Coefs[ 13 ] );
   196e6:	6d9c      	ldr	r4, [r3, #88]	; 0x58
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 14 ], buf_ptr[ 21 ] ), FIR_Coefs[ 14 ] );
   196e8:	f9b8 9020 	ldrsh.w	r9, [r8, #32]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 10 ], buf_ptr[ 25 ] ), FIR_Coefs[ 10 ] );
   196ec:	fa1f f18c 	uxth.w	r1, ip
   196f0:	ea4f 4c2c 	mov.w	ip, ip, asr #16
   196f4:	fb02 f101 	mul.w	r1, r2, r1
   196f8:	fb02 f20c 	mul.w	r2, r2, ip
   196fc:	eb02 4221 	add.w	r2, r2, r1, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 13 ], buf_ptr[ 22 ] ), FIR_Coefs[ 13 ] );
   19700:	46a4      	mov	ip, r4
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 11 ], buf_ptr[ 24 ] ), FIR_Coefs[ 11 ] );
   19702:	f9b8 101a 	ldrsh.w	r1, [r8, #26]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 13 ], buf_ptr[ 22 ] ), FIR_Coefs[ 13 ] );
   19706:	6b5c      	ldr	r4, [r3, #52]	; 0x34
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 10 ], buf_ptr[ 25 ] ), FIR_Coefs[ 10 ] );
   19708:	4402      	add	r2, r0
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 11 ], buf_ptr[ 24 ] ), FIR_Coefs[ 11 ] );
   1970a:	b2a8      	uxth	r0, r5
   1970c:	142d      	asrs	r5, r5, #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 13 ], buf_ptr[ 22 ] ), FIR_Coefs[ 13 ] );
   1970e:	eb0c 0e04 	add.w	lr, ip, r4
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 11 ], buf_ptr[ 24 ] ), FIR_Coefs[ 11 ] );
   19712:	fb01 f505 	mul.w	r5, r1, r5
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 14 ], buf_ptr[ 21 ] ), FIR_Coefs[ 14 ] );
   19716:	6d5c      	ldr	r4, [r3, #84]	; 0x54
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 12 ], buf_ptr[ 23 ] ), FIR_Coefs[ 12 ] );
   19718:	f9b8 c01c 	ldrsh.w	ip, [r8, #28]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 11 ], buf_ptr[ 24 ] ), FIR_Coefs[ 11 ] );
   1971c:	fb01 f000 	mul.w	r0, r1, r0
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 14 ], buf_ptr[ 21 ] ), FIR_Coefs[ 14 ] );
   19720:	6b99      	ldr	r1, [r3, #56]	; 0x38
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 11 ], buf_ptr[ 24 ] ), FIR_Coefs[ 11 ] );
   19722:	eb05 4020 	add.w	r0, r5, r0, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 14 ], buf_ptr[ 21 ] ), FIR_Coefs[ 14 ] );
   19726:	4421      	add	r1, r4
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 11 ], buf_ptr[ 24 ] ), FIR_Coefs[ 11 ] );
   19728:	4410      	add	r0, r2
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 12 ], buf_ptr[ 23 ] ), FIR_Coefs[ 12 ] );
   1972a:	1434      	asrs	r4, r6, #16
   1972c:	b2b2      	uxth	r2, r6
   1972e:	fb0c f202 	mul.w	r2, ip, r2
   19732:	fb0c f404 	mul.w	r4, ip, r4
   19736:	eb04 4422 	add.w	r4, r4, r2, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 13 ], buf_ptr[ 22 ] ), FIR_Coefs[ 13 ] );
   1973a:	f9b8 c01e 	ldrsh.w	ip, [r8, #30]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 15 ], buf_ptr[ 20 ] ), FIR_Coefs[ 15 ] );
   1973e:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
   19740:	6d1a      	ldr	r2, [r3, #80]	; 0x50
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 12 ], buf_ptr[ 23 ] ), FIR_Coefs[ 12 ] );
   19742:	4404      	add	r4, r0
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 13 ], buf_ptr[ 22 ] ), FIR_Coefs[ 13 ] );
   19744:	fa1f f08e 	uxth.w	r0, lr
   19748:	ea4f 4e2e 	mov.w	lr, lr, asr #16
   1974c:	fb0c f000 	mul.w	r0, ip, r0
   19750:	fb0c fc0e 	mul.w	ip, ip, lr
   19754:	eb0c 4c20 	add.w	ip, ip, r0, asr #16
   19758:	4464      	add	r4, ip
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 14 ], buf_ptr[ 21 ] ), FIR_Coefs[ 14 ] );
   1975a:	fa1f fc81 	uxth.w	ip, r1
   1975e:	1409      	asrs	r1, r1, #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 15 ], buf_ptr[ 20 ] ), FIR_Coefs[ 15 ] );
   19760:	442a      	add	r2, r5
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 16 ], buf_ptr[ 19 ] ), FIR_Coefs[ 16 ] );
   19762:	6c18      	ldr	r0, [r3, #64]	; 0x40
   19764:	6cdd      	ldr	r5, [r3, #76]	; 0x4c
   19766:	f9b8 e024 	ldrsh.w	lr, [r8, #36]	; 0x24
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 14 ], buf_ptr[ 21 ] ), FIR_Coefs[ 14 ] );
   1976a:	fb09 f101 	mul.w	r1, r9, r1
   1976e:	fb09 fc0c 	mul.w	ip, r9, ip
   19772:	eb01 4c2c 	add.w	ip, r1, ip, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 17 ], buf_ptr[ 18 ] ), FIR_Coefs[ 17 ] );
   19776:	e9d3 3111 	ldrd	r3, r1, [r3, #68]	; 0x44
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 16 ], buf_ptr[ 19 ] ), FIR_Coefs[ 16 ] );
   1977a:	4405      	add	r5, r0
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 15 ], buf_ptr[ 20 ] ), FIR_Coefs[ 15 ] );
   1977c:	f9b8 0022 	ldrsh.w	r0, [r8, #34]	; 0x22
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 14 ], buf_ptr[ 21 ] ), FIR_Coefs[ 14 ] );
   19780:	44a4      	add	ip, r4
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 15 ], buf_ptr[ 20 ] ), FIR_Coefs[ 15 ] );
   19782:	b294      	uxth	r4, r2
   19784:	1412      	asrs	r2, r2, #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 17 ], buf_ptr[ 18 ] ), FIR_Coefs[ 17 ] );
   19786:	4419      	add	r1, r3
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 15 ], buf_ptr[ 20 ] ), FIR_Coefs[ 15 ] );
   19788:	fb00 f904 	mul.w	r9, r0, r4
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 17 ], buf_ptr[ 18 ] ), FIR_Coefs[ 17 ] );
   1978c:	f9b8 3026 	ldrsh.w	r3, [r8, #38]	; 0x26
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 15 ], buf_ptr[ 20 ] ), FIR_Coefs[ 15 ] );
   19790:	fb00 f402 	mul.w	r4, r0, r2
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 16 ], buf_ptr[ 19 ] ), FIR_Coefs[ 16 ] );
   19794:	b2a8      	uxth	r0, r5
   19796:	142d      	asrs	r5, r5, #16
   19798:	fb0e f000 	mul.w	r0, lr, r0
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 17 ], buf_ptr[ 18 ] ), FIR_Coefs[ 17 ] );
   1979c:	b28a      	uxth	r2, r1
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 15 ], buf_ptr[ 20 ] ), FIR_Coefs[ 15 ] );
   1979e:	eb04 4429 	add.w	r4, r4, r9, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 16 ], buf_ptr[ 19 ] ), FIR_Coefs[ 16 ] );
   197a2:	fb0e fe05 	mul.w	lr, lr, r5
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 17 ], buf_ptr[ 18 ] ), FIR_Coefs[ 17 ] );
   197a6:	1409      	asrs	r1, r1, #16
   197a8:	fb03 f202 	mul.w	r2, r3, r2
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 15 ], buf_ptr[ 20 ] ), FIR_Coefs[ 15 ] );
   197ac:	4464      	add	r4, ip
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 16 ], buf_ptr[ 19 ] ), FIR_Coefs[ 16 ] );
   197ae:	eb0e 4e20 	add.w	lr, lr, r0, asr #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 17 ], buf_ptr[ 18 ] ), FIR_Coefs[ 17 ] );
   197b2:	fb03 f301 	mul.w	r3, r3, r1
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 16 ], buf_ptr[ 19 ] ), FIR_Coefs[ 16 ] );
   197b6:	44a6      	add	lr, r4
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 17 ], buf_ptr[ 18 ] ), FIR_Coefs[ 17 ] );
   197b8:	eb03 4322 	add.w	r3, r3, r2, asr #16
   197bc:	4473      	add	r3, lr
                *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q6, 6 ) );
   197be:	115b      	asrs	r3, r3, #5
   197c0:	3301      	adds	r3, #1
   197c2:	105b      	asrs	r3, r3, #1
   197c4:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   197c8:	f6ff aece 	blt.w	19568 <silk_resampler_private_down_FIR+0x4ec>
   197cc:	f647 73ff 	movw	r3, #32767	; 0x7fff
   197d0:	e6cf      	b.n	19572 <silk_resampler_private_down_FIR+0x4f6>
   197d2:	4b06      	ldr	r3, [pc, #24]	; (197ec <silk_resampler_private_down_FIR+0x770>)
   197d4:	e6cd      	b.n	19572 <silk_resampler_private_down_FIR+0x4f6>
   197d6:	f8d7 8008 	ldr.w	r8, [r7, #8]
   197da:	e47e      	b.n	190da <silk_resampler_private_down_FIR+0x5e>
            break;
        }
    }

    /* Copy last part of filtered signal to the state for the next call */
    silk_memcpy( S->sFIR.i32, &buf[ nSamplesIn ], S->FIR_Order * sizeof( opus_int32 ) );
   197dc:	68f8      	ldr	r0, [r7, #12]
   197de:	f7f2 fc8f 	bl	c100 <memcpy>
    RESTORE_STACK;
}
   197e2:	373c      	adds	r7, #60	; 0x3c
   197e4:	46bd      	mov	sp, r7
   197e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   197ea:	bf00      	nop
   197ec:	ffff8000 	.word	0xffff8000

000197f0 <silk_resampler_private_IIR_FIR>:
    void                            *SS,            /* I/O  Resampler state             */
    opus_int16                      out[],          /* O    Output signal               */
    const opus_int16                in[],           /* I    Input signal                */
    opus_int32                      inLen           /* I    Number of input samples     */
)
{
   197f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   197f4:	b089      	sub	sp, #36	; 0x24
   197f6:	4605      	mov	r5, r0
   197f8:	af00      	add	r7, sp, #0
    opus_int32 nSamplesIn;
    opus_int32 max_index_Q16, index_increment_Q16;
    VARDECL( opus_int16, buf );
    SAVE_STACK;

    ALLOC( buf, 2 * S->batchSize + RESAMPLER_ORDER_FIR_12, opus_int16 );
   197fa:	f8d0 610c 	ldr.w	r6, [r0, #268]	; 0x10c

    /* Copy buffered samples to start of buffer */
    silk_memcpy( buf, S->sFIR.i16, RESAMPLER_ORDER_FIR_12 * sizeof( opus_int16 ) );

    /* Iterate over blocks of frameSizeIn input samples */
    index_increment_Q16 = S->invRatio_Q16;
   197fe:	f8d5 5110 	ldr.w	r5, [r5, #272]	; 0x110
   19802:	607d      	str	r5, [r7, #4]
    ALLOC( buf, 2 * S->batchSize + RESAMPLER_ORDER_FIR_12, opus_int16 );
   19804:	00b5      	lsls	r5, r6, #2
   19806:	3518      	adds	r5, #24
   19808:	f025 0507 	bic.w	r5, r5, #7
{
   1980c:	6138      	str	r0, [r7, #16]
    ALLOC( buf, 2 * S->batchSize + RESAMPLER_ORDER_FIR_12, opus_int16 );
   1980e:	ebad 0d05 	sub.w	sp, sp, r5
    silk_memcpy( buf, S->sFIR.i16, RESAMPLER_ORDER_FIR_12 * sizeof( opus_int16 ) );
   19812:	f850 4f18 	ldr.w	r4, [r0, #24]!
   19816:	6038      	str	r0, [r7, #0]
    ALLOC( buf, 2 * S->batchSize + RESAMPLER_ORDER_FIR_12, opus_int16 );
   19818:	466d      	mov	r5, sp
    silk_memcpy( buf, S->sFIR.i16, RESAMPLER_ORDER_FIR_12 * sizeof( opus_int16 ) );
   1981a:	f8d0 e004 	ldr.w	lr, [r0, #4]
   1981e:	f8d0 c008 	ldr.w	ip, [r0, #8]
   19822:	68c0      	ldr	r0, [r0, #12]
   19824:	602c      	str	r4, [r5, #0]
{
   19826:	e9c7 3205 	strd	r3, r2, [r7, #20]
    silk_memcpy( buf, S->sFIR.i16, RESAMPLER_ORDER_FIR_12 * sizeof( opus_int16 ) );
   1982a:	60e8      	str	r0, [r5, #12]
   1982c:	f105 0310 	add.w	r3, r5, #16
   19830:	4c4c      	ldr	r4, [pc, #304]	; (19964 <silk_resampler_private_IIR_FIR+0x174>)
   19832:	6938      	ldr	r0, [r7, #16]
   19834:	f8c5 e004 	str.w	lr, [r5, #4]
{
   19838:	4688      	mov	r8, r1
    silk_memcpy( buf, S->sFIR.i16, RESAMPLER_ORDER_FIR_12 * sizeof( opus_int16 ) );
   1983a:	f8c5 c008 	str.w	ip, [r5, #8]
   1983e:	60bb      	str	r3, [r7, #8]
   19840:	4619      	mov	r1, r3
    while( 1 ) {
        nSamplesIn = silk_min( inLen, S->batchSize );
   19842:	697b      	ldr	r3, [r7, #20]
   19844:	429e      	cmp	r6, r3
   19846:	bfa8      	it	ge
   19848:	461e      	movge	r6, r3

        /* Upsample 2x */
        silk_resampler_private_up2_HQ( S->sIIR, &buf[ RESAMPLER_ORDER_FIR_12 ], in, nSamplesIn );
   1984a:	4633      	mov	r3, r6

        max_index_Q16 = silk_LSHIFT32( nSamplesIn, 16 + 1 );         /* + 1 because 2x upsampling */
   1984c:	ea4f 4b46 	mov.w	fp, r6, lsl #17
        silk_resampler_private_up2_HQ( S->sIIR, &buf[ RESAMPLER_ORDER_FIR_12 ], in, nSamplesIn );
   19850:	f000 f88c 	bl	1996c <silk_resampler_private_up2_HQ>
    for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
   19854:	f1bb 0f00 	cmp.w	fp, #0
   19858:	dd5a      	ble.n	19910 <silk_resampler_private_IIR_FIR+0x120>
   1985a:	687b      	ldr	r3, [r7, #4]
   1985c:	60fe      	str	r6, [r7, #12]
   1985e:	f04f 0a00 	mov.w	sl, #0
   19862:	61fb      	str	r3, [r7, #28]
   19864:	e009      	b.n	1987a <silk_resampler_private_IIR_FIR+0x8a>
        *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q15, 15 ) );
   19866:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   1986a:	db6b      	blt.n	19944 <silk_resampler_private_IIR_FIR+0x154>
   1986c:	b21b      	sxth	r3, r3
    for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
   1986e:	69fa      	ldr	r2, [r7, #28]
        *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q15, 15 ) );
   19870:	f828 3b02 	strh.w	r3, [r8], #2
    for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
   19874:	4492      	add	sl, r2
   19876:	45d3      	cmp	fp, sl
   19878:	dd49      	ble.n	1990e <silk_resampler_private_IIR_FIR+0x11e>
        table_index = silk_SMULWB( index_Q16 & 0xFFFF, 12 );
   1987a:	fa1f f38a 	uxth.w	r3, sl
   1987e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   19882:	0b9b      	lsrs	r3, r3, #14
        buf_ptr = &buf[ index_Q16 >> 16 ];
   19884:	ea4f 412a 	mov.w	r1, sl, asr #16
   19888:	eb05 0241 	add.w	r2, r5, r1, lsl #1
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 1 ], silk_resampler_frac_FIR_12[      table_index ][ 1 ] );
   1988c:	eb04 00c3 	add.w	r0, r4, r3, lsl #3
        res_Q15 = silk_SMULBB(          buf_ptr[ 0 ], silk_resampler_frac_FIR_12[      table_index ][ 0 ] );
   19890:	f834 e033 	ldrh.w	lr, [r4, r3, lsl #3]
   19894:	f835 1011 	ldrh.w	r1, [r5, r1, lsl #1]
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 1 ], silk_resampler_frac_FIR_12[      table_index ][ 1 ] );
   19898:	f8b0 9002 	ldrh.w	r9, [r0, #2]
   1989c:	f8b2 c002 	ldrh.w	ip, [r2, #2]
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 4 ], silk_resampler_frac_FIR_12[ 11 - table_index ][ 3 ] );
   198a0:	8916      	ldrh	r6, [r2, #8]
        res_Q15 = silk_SMULBB(          buf_ptr[ 0 ], silk_resampler_frac_FIR_12[      table_index ][ 0 ] );
   198a2:	fb1e f101 	smulbb	r1, lr, r1
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 1 ], silk_resampler_frac_FIR_12[      table_index ][ 1 ] );
   198a6:	fb19 110c 	smlabb	r1, r9, ip, r1
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 2 ], silk_resampler_frac_FIR_12[      table_index ][ 2 ] );
   198aa:	f8b0 e004 	ldrh.w	lr, [r0, #4]
   198ae:	f8b2 c004 	ldrh.w	ip, [r2, #4]
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 3 ], silk_resampler_frac_FIR_12[      table_index ][ 3 ] );
   198b2:	88c0      	ldrh	r0, [r0, #6]
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 4 ], silk_resampler_frac_FIR_12[ 11 - table_index ][ 3 ] );
   198b4:	f1c3 030b 	rsb	r3, r3, #11
   198b8:	eb04 09c3 	add.w	r9, r4, r3, lsl #3
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 2 ], silk_resampler_frac_FIR_12[      table_index ][ 2 ] );
   198bc:	fb1e 110c 	smlabb	r1, lr, ip, r1
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 3 ], silk_resampler_frac_FIR_12[      table_index ][ 3 ] );
   198c0:	f8b2 e006 	ldrh.w	lr, [r2, #6]
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 4 ], silk_resampler_frac_FIR_12[ 11 - table_index ][ 3 ] );
   198c4:	f8b9 c006 	ldrh.w	ip, [r9, #6]
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 7 ], silk_resampler_frac_FIR_12[ 11 - table_index ][ 0 ] );
   198c8:	f834 3033 	ldrh.w	r3, [r4, r3, lsl #3]
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 3 ], silk_resampler_frac_FIR_12[      table_index ][ 3 ] );
   198cc:	fb10 1e0e 	smlabb	lr, r0, lr, r1
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 5 ], silk_resampler_frac_FIR_12[ 11 - table_index ][ 2 ] );
   198d0:	f8b9 0004 	ldrh.w	r0, [r9, #4]
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 6 ], silk_resampler_frac_FIR_12[ 11 - table_index ][ 1 ] );
   198d4:	f8b9 1002 	ldrh.w	r1, [r9, #2]
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 5 ], silk_resampler_frac_FIR_12[ 11 - table_index ][ 2 ] );
   198d8:	f8b2 900a 	ldrh.w	r9, [r2, #10]
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 4 ], silk_resampler_frac_FIR_12[ 11 - table_index ][ 3 ] );
   198dc:	fb1c ec06 	smlabb	ip, ip, r6, lr
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 6 ], silk_resampler_frac_FIR_12[ 11 - table_index ][ 1 ] );
   198e0:	f8b2 e00c 	ldrh.w	lr, [r2, #12]
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 7 ], silk_resampler_frac_FIR_12[ 11 - table_index ][ 0 ] );
   198e4:	89d2      	ldrh	r2, [r2, #14]
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 5 ], silk_resampler_frac_FIR_12[ 11 - table_index ][ 2 ] );
   198e6:	fb10 c009 	smlabb	r0, r0, r9, ip
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 6 ], silk_resampler_frac_FIR_12[ 11 - table_index ][ 1 ] );
   198ea:	fb11 010e 	smlabb	r1, r1, lr, r0
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 7 ], silk_resampler_frac_FIR_12[ 11 - table_index ][ 0 ] );
   198ee:	fb13 1302 	smlabb	r3, r3, r2, r1
        *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q15, 15 ) );
   198f2:	139b      	asrs	r3, r3, #14
   198f4:	3301      	adds	r3, #1
   198f6:	105b      	asrs	r3, r3, #1
   198f8:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   198fc:	dbb3      	blt.n	19866 <silk_resampler_private_IIR_FIR+0x76>
    for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
   198fe:	69fa      	ldr	r2, [r7, #28]
   19900:	4492      	add	sl, r2
        *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q15, 15 ) );
   19902:	f647 73ff 	movw	r3, #32767	; 0x7fff
    for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
   19906:	45d3      	cmp	fp, sl
        *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q15, 15 ) );
   19908:	f828 3b02 	strh.w	r3, [r8], #2
    for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
   1990c:	dcb5      	bgt.n	1987a <silk_resampler_private_IIR_FIR+0x8a>
   1990e:	68fe      	ldr	r6, [r7, #12]
        out = silk_resampler_private_IIR_FIR_INTERPOL( out, buf, max_index_Q16, index_increment_Q16 );
        in += nSamplesIn;
        inLen -= nSamplesIn;
   19910:	697b      	ldr	r3, [r7, #20]
        in += nSamplesIn;
   19912:	69ba      	ldr	r2, [r7, #24]
        inLen -= nSamplesIn;
   19914:	1b9b      	subs	r3, r3, r6
        in += nSamplesIn;
   19916:	eb02 0246 	add.w	r2, r2, r6, lsl #1

        if( inLen > 0 ) {
   1991a:	2b00      	cmp	r3, #0
        inLen -= nSamplesIn;
   1991c:	617b      	str	r3, [r7, #20]
        in += nSamplesIn;
   1991e:	61ba      	str	r2, [r7, #24]
   19920:	eb05 0686 	add.w	r6, r5, r6, lsl #2
        if( inLen > 0 ) {
   19924:	dd10      	ble.n	19948 <silk_resampler_private_IIR_FIR+0x158>
            /* More iterations to do; copy last part of filtered signal to beginning of buffer */
            silk_memcpy( buf, &buf[ nSamplesIn << 1 ], RESAMPLER_ORDER_FIR_12 * sizeof( opus_int16 ) );
   19926:	68b3      	ldr	r3, [r6, #8]
   19928:	6831      	ldr	r1, [r6, #0]
   1992a:	6872      	ldr	r2, [r6, #4]
   1992c:	68f0      	ldr	r0, [r6, #12]
   1992e:	60ab      	str	r3, [r5, #8]
   19930:	693b      	ldr	r3, [r7, #16]
   19932:	60e8      	str	r0, [r5, #12]
   19934:	6029      	str	r1, [r5, #0]
   19936:	606a      	str	r2, [r5, #4]
   19938:	f8d3 610c 	ldr.w	r6, [r3, #268]	; 0x10c
   1993c:	69ba      	ldr	r2, [r7, #24]
   1993e:	68b9      	ldr	r1, [r7, #8]
   19940:	4618      	mov	r0, r3
        nSamplesIn = silk_min( inLen, S->batchSize );
   19942:	e77e      	b.n	19842 <silk_resampler_private_IIR_FIR+0x52>
        *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q15, 15 ) );
   19944:	4b08      	ldr	r3, [pc, #32]	; (19968 <silk_resampler_private_IIR_FIR+0x178>)
   19946:	e792      	b.n	1986e <silk_resampler_private_IIR_FIR+0x7e>
            break;
        }
    }

    /* Copy last part of filtered signal to the state for the next call */
    silk_memcpy( S->sFIR.i16, &buf[ nSamplesIn << 1 ], RESAMPLER_ORDER_FIR_12 * sizeof( opus_int16 ) );
   19948:	693c      	ldr	r4, [r7, #16]
   1994a:	6830      	ldr	r0, [r6, #0]
   1994c:	61a0      	str	r0, [r4, #24]
   1994e:	6871      	ldr	r1, [r6, #4]
   19950:	6838      	ldr	r0, [r7, #0]
   19952:	68b2      	ldr	r2, [r6, #8]
   19954:	68f3      	ldr	r3, [r6, #12]
   19956:	6041      	str	r1, [r0, #4]
    RESTORE_STACK;
}
   19958:	3724      	adds	r7, #36	; 0x24
    silk_memcpy( S->sFIR.i16, &buf[ nSamplesIn << 1 ], RESAMPLER_ORDER_FIR_12 * sizeof( opus_int16 ) );
   1995a:	6082      	str	r2, [r0, #8]
   1995c:	60c3      	str	r3, [r0, #12]
}
   1995e:	46bd      	mov	sp, r7
   19960:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   19964:	0003770c 	.word	0x0003770c
   19968:	ffff8000 	.word	0xffff8000

0001996c <silk_resampler_private_up2_HQ>:
    opus_int32                      *S,             /* I/O  Resampler state [ 6 ]       */
    opus_int16                      *out,           /* O    Output signal [ 2 * len ]   */
    const opus_int16                *in,            /* I    Input signal [ len ]        */
    opus_int32                      len             /* I    Number of input samples     */
)
{
   1996c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   19970:	b087      	sub	sp, #28
    silk_assert( silk_resampler_up2_hq_1[ 0 ] > 0 );
    silk_assert( silk_resampler_up2_hq_1[ 1 ] > 0 );
    silk_assert( silk_resampler_up2_hq_1[ 2 ] < 0 );

    /* Internal variables and state are in Q10 format */
    for( k = 0; k < len; k++ ) {
   19972:	2b00      	cmp	r3, #0
{
   19974:	9005      	str	r0, [sp, #20]
    for( k = 0; k < len; k++ ) {
   19976:	f340 80ab 	ble.w	19ad0 <silk_resampler_private_up2_HQ+0x164>
   1997a:	eb01 0383 	add.w	r3, r1, r3, lsl #2
   1997e:	6944      	ldr	r4, [r0, #20]
   19980:	9304      	str	r3, [sp, #16]
   19982:	1e93      	subs	r3, r2, #2
   19984:	e9d0 ec00 	ldrd	lr, ip, [r0]
   19988:	e9d0 b902 	ldrd	fp, r9, [r0, #8]
   1998c:	f8d0 8010 	ldr.w	r8, [r0, #16]
        out32_1 = silk_ADD32( S[ 3 ], X );
        S[ 3 ]  = silk_ADD32( in32, X );

        /* Second all-pass section for odd output sample */
        Y       = silk_SUB32( out32_1, S[ 4 ] );
        X       = silk_SMULWB( Y, silk_resampler_up2_hq_1[ 1 ] );
   19990:	e9cd 4301 	strd	r4, r3, [sp, #4]
   19994:	e04a      	b.n	19a2c <silk_resampler_private_up2_HQ+0xc0>
        out[ 2 * k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
   19996:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   1999a:	f2c0 809c 	blt.w	19ad6 <silk_resampler_private_up2_HQ+0x16a>
   1999e:	b21b      	sxth	r3, r3
   199a0:	9303      	str	r3, [sp, #12]
        Y       = silk_SUB32( in32, S[ 3 ] );
   199a2:	eba6 0209 	sub.w	r2, r6, r9
        X       = silk_SMULWB( Y, silk_resampler_up2_hq_1[ 0 ] );
   199a6:	f641 23c6 	movw	r3, #6854	; 0x1ac6
   199aa:	b295      	uxth	r5, r2
   199ac:	1410      	asrs	r0, r2, #16
   199ae:	fb03 f000 	mul.w	r0, r3, r0
   199b2:	fb03 f205 	mul.w	r2, r3, r5
   199b6:	eb00 4012 	add.w	r0, r0, r2, lsr #16
        out32_1 = silk_ADD32( S[ 3 ], X );
   199ba:	eb00 0309 	add.w	r3, r0, r9
        Y       = silk_SUB32( out32_1, S[ 4 ] );
   199be:	eba3 0208 	sub.w	r2, r3, r8
        X       = silk_SMULWB( Y, silk_resampler_up2_hq_1[ 1 ] );
   199c2:	f246 44a9 	movw	r4, #25769	; 0x64a9
   199c6:	b295      	uxth	r5, r2
   199c8:	1412      	asrs	r2, r2, #16
   199ca:	fb04 f505 	mul.w	r5, r4, r5
   199ce:	fb04 f202 	mul.w	r2, r4, r2
   199d2:	eb02 4215 	add.w	r2, r2, r5, lsr #16
        out32_2 = silk_ADD32( S[ 4 ], X );
        S[ 4 ]  = silk_ADD32( out32_1, X );

        /* Third all-pass section for odd output sample */
        Y       = silk_SUB32( out32_2, S[ 5 ] );
   199d6:	9d01      	ldr	r5, [sp, #4]
        X       = silk_SMLAWB( Y, Y, silk_resampler_up2_hq_1[ 2 ] );
   199d8:	4c41      	ldr	r4, [pc, #260]	; (19ae0 <silk_resampler_private_up2_HQ+0x174>)
        out32_2 = silk_ADD32( S[ 4 ], X );
   199da:	eb02 0a08 	add.w	sl, r2, r8
        Y       = silk_SUB32( out32_2, S[ 5 ] );
   199de:	ebaa 0805 	sub.w	r8, sl, r5
        X       = silk_SMLAWB( Y, Y, silk_resampler_up2_hq_1[ 2 ] );
   199e2:	fa1f f588 	uxth.w	r5, r8
   199e6:	ea4f 4728 	mov.w	r7, r8, asr #16
   199ea:	fb04 f707 	mul.w	r7, r4, r7
   199ee:	fb04 f505 	mul.w	r5, r4, r5
   199f2:	eb07 4525 	add.w	r5, r7, r5, asr #16
        out32_1 = silk_ADD32( S[ 5 ], X );
   199f6:	9c01      	ldr	r4, [sp, #4]
        X       = silk_SMLAWB( Y, Y, silk_resampler_up2_hq_1[ 2 ] );
   199f8:	4445      	add	r5, r8
        out32_1 = silk_ADD32( S[ 5 ], X );
   199fa:	442c      	add	r4, r5
        S[ 5 ]  = silk_ADD32( out32_2, X );

        /* Apply gain in Q15, convert back to int16 and store to output */
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
   199fc:	1267      	asrs	r7, r4, #9
   199fe:	3701      	adds	r7, #1
   19a00:	107f      	asrs	r7, r7, #1
        out[ 2 * k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
   19a02:	9c03      	ldr	r4, [sp, #12]
   19a04:	800c      	strh	r4, [r1, #0]
        S[ 4 ]  = silk_ADD32( out32_1, X );
   19a06:	eb02 0803 	add.w	r8, r2, r3
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
   19a0a:	f5b7 4f00 	cmp.w	r7, #32768	; 0x8000
        S[ 5 ]  = silk_ADD32( out32_2, X );
   19a0e:	eb05 030a 	add.w	r3, r5, sl
        S[ 3 ]  = silk_ADD32( in32, X );
   19a12:	eb00 0906 	add.w	r9, r0, r6
        S[ 5 ]  = silk_ADD32( out32_2, X );
   19a16:	9301      	str	r3, [sp, #4]
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
   19a18:	da4a      	bge.n	19ab0 <silk_resampler_private_up2_HQ+0x144>
   19a1a:	f517 4f00 	cmn.w	r7, #32768	; 0x8000
   19a1e:	db5d      	blt.n	19adc <silk_resampler_private_up2_HQ+0x170>
   19a20:	b23f      	sxth	r7, r7
    for( k = 0; k < len; k++ ) {
   19a22:	9b04      	ldr	r3, [sp, #16]
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
   19a24:	804f      	strh	r7, [r1, #2]
   19a26:	3104      	adds	r1, #4
    for( k = 0; k < len; k++ ) {
   19a28:	428b      	cmp	r3, r1
   19a2a:	d048      	beq.n	19abe <silk_resampler_private_up2_HQ+0x152>
        in32 = silk_LSHIFT( (opus_int32)in[ k ], 10 );
   19a2c:	9b02      	ldr	r3, [sp, #8]
   19a2e:	f933 6f02 	ldrsh.w	r6, [r3, #2]!
   19a32:	9302      	str	r3, [sp, #8]
   19a34:	02b6      	lsls	r6, r6, #10
        Y       = silk_SUB32( in32, S[ 0 ] );
   19a36:	eba6 030e 	sub.w	r3, r6, lr
        X       = silk_SMULWB( Y, silk_resampler_up2_hq_0[ 0 ] );
   19a3a:	f240 64d2 	movw	r4, #1746	; 0x6d2
   19a3e:	b29a      	uxth	r2, r3
   19a40:	1418      	asrs	r0, r3, #16
   19a42:	fb04 f000 	mul.w	r0, r4, r0
   19a46:	fb04 f302 	mul.w	r3, r4, r2
   19a4a:	eb00 4013 	add.w	r0, r0, r3, lsr #16
        out32_1 = silk_ADD32( S[ 0 ], X );
   19a4e:	eb00 0a0e 	add.w	sl, r0, lr
        Y       = silk_SUB32( out32_1, S[ 1 ] );
   19a52:	ebaa 030c 	sub.w	r3, sl, ip
        X       = silk_SMULWB( Y, silk_resampler_up2_hq_0[ 1 ] );
   19a56:	f643 248a 	movw	r4, #14986	; 0x3a8a
   19a5a:	b29d      	uxth	r5, r3
   19a5c:	141a      	asrs	r2, r3, #16
   19a5e:	fb04 f202 	mul.w	r2, r4, r2
   19a62:	fb04 f305 	mul.w	r3, r4, r5
   19a66:	eb02 4213 	add.w	r2, r2, r3, lsr #16
        out32_2 = silk_ADD32( S[ 1 ], X );
   19a6a:	eb02 070c 	add.w	r7, r2, ip
        Y       = silk_SUB32( out32_2, S[ 2 ] );
   19a6e:	eba7 0c0b 	sub.w	ip, r7, fp
        X       = silk_SMLAWB( Y, Y, silk_resampler_up2_hq_0[ 2 ] );
   19a72:	4c1c      	ldr	r4, [pc, #112]	; (19ae4 <silk_resampler_private_up2_HQ+0x178>)
   19a74:	fa1f f58c 	uxth.w	r5, ip
   19a78:	ea4f 432c 	mov.w	r3, ip, asr #16
   19a7c:	fb04 f303 	mul.w	r3, r4, r3
   19a80:	fb04 f505 	mul.w	r5, r4, r5
   19a84:	eb03 4525 	add.w	r5, r3, r5, asr #16
   19a88:	4465      	add	r5, ip
        out32_1 = silk_ADD32( S[ 2 ], X );
   19a8a:	eb05 030b 	add.w	r3, r5, fp
        out[ 2 * k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
   19a8e:	125b      	asrs	r3, r3, #9
   19a90:	3301      	adds	r3, #1
   19a92:	105b      	asrs	r3, r3, #1
   19a94:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
        S[ 0 ]  = silk_ADD32( in32, X );
   19a98:	eb00 0e06 	add.w	lr, r0, r6
        S[ 1 ]  = silk_ADD32( out32_1, X );
   19a9c:	eb02 0c0a 	add.w	ip, r2, sl
        S[ 2 ]  = silk_ADD32( out32_2, X );
   19aa0:	eb05 0b07 	add.w	fp, r5, r7
        out[ 2 * k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
   19aa4:	f6ff af77 	blt.w	19996 <silk_resampler_private_up2_HQ+0x2a>
   19aa8:	f647 73ff 	movw	r3, #32767	; 0x7fff
   19aac:	9303      	str	r3, [sp, #12]
   19aae:	e778      	b.n	199a2 <silk_resampler_private_up2_HQ+0x36>
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
   19ab0:	f647 77ff 	movw	r7, #32767	; 0x7fff
    for( k = 0; k < len; k++ ) {
   19ab4:	9b04      	ldr	r3, [sp, #16]
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
   19ab6:	804f      	strh	r7, [r1, #2]
   19ab8:	3104      	adds	r1, #4
    for( k = 0; k < len; k++ ) {
   19aba:	428b      	cmp	r3, r1
   19abc:	d1b6      	bne.n	19a2c <silk_resampler_private_up2_HQ+0xc0>
   19abe:	9b05      	ldr	r3, [sp, #20]
   19ac0:	9c01      	ldr	r4, [sp, #4]
   19ac2:	615c      	str	r4, [r3, #20]
   19ac4:	e9c3 9803 	strd	r9, r8, [r3, #12]
   19ac8:	e9c3 ec00 	strd	lr, ip, [r3]
   19acc:	f8c3 b008 	str.w	fp, [r3, #8]
    }
}
   19ad0:	b007      	add	sp, #28
   19ad2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        out[ 2 * k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
   19ad6:	4b04      	ldr	r3, [pc, #16]	; (19ae8 <silk_resampler_private_up2_HQ+0x17c>)
   19ad8:	9303      	str	r3, [sp, #12]
   19ada:	e762      	b.n	199a2 <silk_resampler_private_up2_HQ+0x36>
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
   19adc:	4f02      	ldr	r7, [pc, #8]	; (19ae8 <silk_resampler_private_up2_HQ+0x17c>)
   19ade:	e7a0      	b.n	19a22 <silk_resampler_private_up2_HQ+0xb6>
   19ae0:	ffffd8f6 	.word	0xffffd8f6
   19ae4:	ffff98ab 	.word	0xffff98ab
   19ae8:	ffff8000 	.word	0xffff8000

00019aec <silk_resampler_private_up2_HQ_wrapper>:
    void                            *SS,            /* I/O  Resampler state (unused)    */
    opus_int16                      *out,           /* O    Output signal [ 2 * len ]   */
    const opus_int16                *in,            /* I    Input signal [ len ]        */
    opus_int32                      len             /* I    Number of input samples     */
)
{
   19aec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   19af0:	b087      	sub	sp, #28
    for( k = 0; k < len; k++ ) {
   19af2:	2b00      	cmp	r3, #0
{
   19af4:	9005      	str	r0, [sp, #20]
    for( k = 0; k < len; k++ ) {
   19af6:	f340 80ab 	ble.w	19c50 <silk_resampler_private_up2_HQ_wrapper+0x164>
   19afa:	eb01 0383 	add.w	r3, r1, r3, lsl #2
   19afe:	6944      	ldr	r4, [r0, #20]
   19b00:	9304      	str	r3, [sp, #16]
   19b02:	1e93      	subs	r3, r2, #2
   19b04:	e9d0 ec00 	ldrd	lr, ip, [r0]
   19b08:	e9d0 b902 	ldrd	fp, r9, [r0, #8]
   19b0c:	f8d0 8010 	ldr.w	r8, [r0, #16]
        X       = silk_SMULWB( Y, silk_resampler_up2_hq_1[ 1 ] );
   19b10:	e9cd 4301 	strd	r4, r3, [sp, #4]
   19b14:	e04a      	b.n	19bac <silk_resampler_private_up2_HQ_wrapper+0xc0>
        out[ 2 * k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
   19b16:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   19b1a:	f2c0 809c 	blt.w	19c56 <silk_resampler_private_up2_HQ_wrapper+0x16a>
   19b1e:	b21b      	sxth	r3, r3
   19b20:	9303      	str	r3, [sp, #12]
        Y       = silk_SUB32( in32, S[ 3 ] );
   19b22:	eba6 0209 	sub.w	r2, r6, r9
        X       = silk_SMULWB( Y, silk_resampler_up2_hq_1[ 0 ] );
   19b26:	f641 23c6 	movw	r3, #6854	; 0x1ac6
   19b2a:	b295      	uxth	r5, r2
   19b2c:	1410      	asrs	r0, r2, #16
   19b2e:	fb03 f000 	mul.w	r0, r3, r0
   19b32:	fb03 f205 	mul.w	r2, r3, r5
   19b36:	eb00 4012 	add.w	r0, r0, r2, lsr #16
        out32_1 = silk_ADD32( S[ 3 ], X );
   19b3a:	eb00 0309 	add.w	r3, r0, r9
        Y       = silk_SUB32( out32_1, S[ 4 ] );
   19b3e:	eba3 0208 	sub.w	r2, r3, r8
        X       = silk_SMULWB( Y, silk_resampler_up2_hq_1[ 1 ] );
   19b42:	f246 44a9 	movw	r4, #25769	; 0x64a9
   19b46:	b295      	uxth	r5, r2
   19b48:	1412      	asrs	r2, r2, #16
   19b4a:	fb04 f505 	mul.w	r5, r4, r5
   19b4e:	fb04 f202 	mul.w	r2, r4, r2
   19b52:	eb02 4215 	add.w	r2, r2, r5, lsr #16
        Y       = silk_SUB32( out32_2, S[ 5 ] );
   19b56:	9d01      	ldr	r5, [sp, #4]
        X       = silk_SMLAWB( Y, Y, silk_resampler_up2_hq_1[ 2 ] );
   19b58:	4c41      	ldr	r4, [pc, #260]	; (19c60 <silk_resampler_private_up2_HQ_wrapper+0x174>)
        out32_2 = silk_ADD32( S[ 4 ], X );
   19b5a:	eb02 0a08 	add.w	sl, r2, r8
        Y       = silk_SUB32( out32_2, S[ 5 ] );
   19b5e:	ebaa 0805 	sub.w	r8, sl, r5
        X       = silk_SMLAWB( Y, Y, silk_resampler_up2_hq_1[ 2 ] );
   19b62:	fa1f f588 	uxth.w	r5, r8
   19b66:	ea4f 4728 	mov.w	r7, r8, asr #16
   19b6a:	fb04 f707 	mul.w	r7, r4, r7
   19b6e:	fb04 f505 	mul.w	r5, r4, r5
   19b72:	eb07 4525 	add.w	r5, r7, r5, asr #16
        out32_1 = silk_ADD32( S[ 5 ], X );
   19b76:	9c01      	ldr	r4, [sp, #4]
        X       = silk_SMLAWB( Y, Y, silk_resampler_up2_hq_1[ 2 ] );
   19b78:	4445      	add	r5, r8
        out32_1 = silk_ADD32( S[ 5 ], X );
   19b7a:	442c      	add	r4, r5
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
   19b7c:	1267      	asrs	r7, r4, #9
   19b7e:	3701      	adds	r7, #1
   19b80:	107f      	asrs	r7, r7, #1
        out[ 2 * k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
   19b82:	9c03      	ldr	r4, [sp, #12]
   19b84:	800c      	strh	r4, [r1, #0]
        S[ 4 ]  = silk_ADD32( out32_1, X );
   19b86:	eb02 0803 	add.w	r8, r2, r3
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
   19b8a:	f5b7 4f00 	cmp.w	r7, #32768	; 0x8000
        S[ 5 ]  = silk_ADD32( out32_2, X );
   19b8e:	eb05 030a 	add.w	r3, r5, sl
        S[ 3 ]  = silk_ADD32( in32, X );
   19b92:	eb00 0906 	add.w	r9, r0, r6
        S[ 5 ]  = silk_ADD32( out32_2, X );
   19b96:	9301      	str	r3, [sp, #4]
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
   19b98:	da4a      	bge.n	19c30 <silk_resampler_private_up2_HQ_wrapper+0x144>
   19b9a:	f517 4f00 	cmn.w	r7, #32768	; 0x8000
   19b9e:	db5d      	blt.n	19c5c <silk_resampler_private_up2_HQ_wrapper+0x170>
   19ba0:	b23f      	sxth	r7, r7
    for( k = 0; k < len; k++ ) {
   19ba2:	9b04      	ldr	r3, [sp, #16]
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
   19ba4:	804f      	strh	r7, [r1, #2]
   19ba6:	3104      	adds	r1, #4
    for( k = 0; k < len; k++ ) {
   19ba8:	428b      	cmp	r3, r1
   19baa:	d048      	beq.n	19c3e <silk_resampler_private_up2_HQ_wrapper+0x152>
        in32 = silk_LSHIFT( (opus_int32)in[ k ], 10 );
   19bac:	9b02      	ldr	r3, [sp, #8]
   19bae:	f933 6f02 	ldrsh.w	r6, [r3, #2]!
   19bb2:	9302      	str	r3, [sp, #8]
   19bb4:	02b6      	lsls	r6, r6, #10
        Y       = silk_SUB32( in32, S[ 0 ] );
   19bb6:	eba6 030e 	sub.w	r3, r6, lr
        X       = silk_SMULWB( Y, silk_resampler_up2_hq_0[ 0 ] );
   19bba:	f240 64d2 	movw	r4, #1746	; 0x6d2
   19bbe:	b29a      	uxth	r2, r3
   19bc0:	1418      	asrs	r0, r3, #16
   19bc2:	fb04 f000 	mul.w	r0, r4, r0
   19bc6:	fb04 f302 	mul.w	r3, r4, r2
   19bca:	eb00 4013 	add.w	r0, r0, r3, lsr #16
        out32_1 = silk_ADD32( S[ 0 ], X );
   19bce:	eb00 0a0e 	add.w	sl, r0, lr
        Y       = silk_SUB32( out32_1, S[ 1 ] );
   19bd2:	ebaa 030c 	sub.w	r3, sl, ip
        X       = silk_SMULWB( Y, silk_resampler_up2_hq_0[ 1 ] );
   19bd6:	f643 248a 	movw	r4, #14986	; 0x3a8a
   19bda:	b29d      	uxth	r5, r3
   19bdc:	141a      	asrs	r2, r3, #16
   19bde:	fb04 f202 	mul.w	r2, r4, r2
   19be2:	fb04 f305 	mul.w	r3, r4, r5
   19be6:	eb02 4213 	add.w	r2, r2, r3, lsr #16
        out32_2 = silk_ADD32( S[ 1 ], X );
   19bea:	eb02 070c 	add.w	r7, r2, ip
        Y       = silk_SUB32( out32_2, S[ 2 ] );
   19bee:	eba7 0c0b 	sub.w	ip, r7, fp
        X       = silk_SMLAWB( Y, Y, silk_resampler_up2_hq_0[ 2 ] );
   19bf2:	4c1c      	ldr	r4, [pc, #112]	; (19c64 <silk_resampler_private_up2_HQ_wrapper+0x178>)
   19bf4:	fa1f f58c 	uxth.w	r5, ip
   19bf8:	ea4f 432c 	mov.w	r3, ip, asr #16
   19bfc:	fb04 f303 	mul.w	r3, r4, r3
   19c00:	fb04 f505 	mul.w	r5, r4, r5
   19c04:	eb03 4525 	add.w	r5, r3, r5, asr #16
   19c08:	4465      	add	r5, ip
        out32_1 = silk_ADD32( S[ 2 ], X );
   19c0a:	eb05 030b 	add.w	r3, r5, fp
        out[ 2 * k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
   19c0e:	125b      	asrs	r3, r3, #9
   19c10:	3301      	adds	r3, #1
   19c12:	105b      	asrs	r3, r3, #1
   19c14:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
        S[ 0 ]  = silk_ADD32( in32, X );
   19c18:	eb00 0e06 	add.w	lr, r0, r6
        S[ 1 ]  = silk_ADD32( out32_1, X );
   19c1c:	eb02 0c0a 	add.w	ip, r2, sl
        S[ 2 ]  = silk_ADD32( out32_2, X );
   19c20:	eb05 0b07 	add.w	fp, r5, r7
        out[ 2 * k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
   19c24:	f6ff af77 	blt.w	19b16 <silk_resampler_private_up2_HQ_wrapper+0x2a>
   19c28:	f647 73ff 	movw	r3, #32767	; 0x7fff
   19c2c:	9303      	str	r3, [sp, #12]
   19c2e:	e778      	b.n	19b22 <silk_resampler_private_up2_HQ_wrapper+0x36>
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
   19c30:	f647 77ff 	movw	r7, #32767	; 0x7fff
    for( k = 0; k < len; k++ ) {
   19c34:	9b04      	ldr	r3, [sp, #16]
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
   19c36:	804f      	strh	r7, [r1, #2]
   19c38:	3104      	adds	r1, #4
    for( k = 0; k < len; k++ ) {
   19c3a:	428b      	cmp	r3, r1
   19c3c:	d1b6      	bne.n	19bac <silk_resampler_private_up2_HQ_wrapper+0xc0>
   19c3e:	9b05      	ldr	r3, [sp, #20]
   19c40:	9c01      	ldr	r4, [sp, #4]
   19c42:	615c      	str	r4, [r3, #20]
   19c44:	e9c3 9803 	strd	r9, r8, [r3, #12]
   19c48:	e9c3 ec00 	strd	lr, ip, [r3]
   19c4c:	f8c3 b008 	str.w	fp, [r3, #8]
    silk_resampler_state_struct *S = (silk_resampler_state_struct *)SS;
    silk_resampler_private_up2_HQ( S->sIIR, out, in, len );
}
   19c50:	b007      	add	sp, #28
   19c52:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        out[ 2 * k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
   19c56:	4b04      	ldr	r3, [pc, #16]	; (19c68 <silk_resampler_private_up2_HQ_wrapper+0x17c>)
   19c58:	9303      	str	r3, [sp, #12]
   19c5a:	e762      	b.n	19b22 <silk_resampler_private_up2_HQ_wrapper+0x36>
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
   19c5c:	4f02      	ldr	r7, [pc, #8]	; (19c68 <silk_resampler_private_up2_HQ_wrapper+0x17c>)
   19c5e:	e7a0      	b.n	19ba2 <silk_resampler_private_up2_HQ_wrapper+0xb6>
   19c60:	ffffd8f6 	.word	0xffffd8f6
   19c64:	ffff98ab 	.word	0xffff98ab
   19c68:	ffff8000 	.word	0xffff8000

00019c6c <silk_sigm_Q15>:
    opus_int                    in_Q5               /* I                                                                */
)
{
    opus_int ind;

    if( in_Q5 < 0 ) {
   19c6c:	2800      	cmp	r0, #0
   19c6e:	db0d      	blt.n	19c8c <silk_sigm_Q15+0x20>
            ind = silk_RSHIFT( in_Q5, 5 );
            return( sigm_LUT_neg_Q15[ ind ] - silk_SMULBB( sigm_LUT_slope_Q10[ ind ], in_Q5 & 0x1F ) );
        }
    } else {
        /* Positive input */
        if( in_Q5 >= 6 * 32 ) {
   19c70:	28bf      	cmp	r0, #191	; 0xbf
   19c72:	dc10      	bgt.n	19c96 <silk_sigm_Q15+0x2a>
            return 32767;        /* clip */
        } else {
            /* Linear interpolation of look up table */
            ind = silk_RSHIFT( in_Q5, 5 );
   19c74:	1142      	asrs	r2, r0, #5
            return( sigm_LUT_pos_Q15[ ind ] + silk_SMULBB( sigm_LUT_slope_Q10[ ind ], in_Q5 & 0x1F ) );
   19c76:	4910      	ldr	r1, [pc, #64]	; (19cb8 <silk_sigm_Q15+0x4c>)
   19c78:	4b10      	ldr	r3, [pc, #64]	; (19cbc <silk_sigm_Q15+0x50>)
   19c7a:	f933 3022 	ldrsh.w	r3, [r3, r2, lsl #2]
   19c7e:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
   19c82:	f000 001f 	and.w	r0, r0, #31
   19c86:	fb00 2003 	mla	r0, r0, r3, r2
   19c8a:	4770      	bx	lr
        if( in_Q5 >= 6 * 32 ) {
   19c8c:	f110 0fbf 	cmn.w	r0, #191	; 0xbf
   19c90:	da04      	bge.n	19c9c <silk_sigm_Q15+0x30>
            return 0;        /* Clip */
   19c92:	2000      	movs	r0, #0
   19c94:	4770      	bx	lr
            return 32767;        /* clip */
   19c96:	f647 70ff 	movw	r0, #32767	; 0x7fff
        }
    }
}
   19c9a:	4770      	bx	lr
        in_Q5 = -in_Q5;
   19c9c:	4240      	negs	r0, r0
            ind = silk_RSHIFT( in_Q5, 5 );
   19c9e:	1142      	asrs	r2, r0, #5
            return( sigm_LUT_neg_Q15[ ind ] - silk_SMULBB( sigm_LUT_slope_Q10[ ind ], in_Q5 & 0x1F ) );
   19ca0:	4907      	ldr	r1, [pc, #28]	; (19cc0 <silk_sigm_Q15+0x54>)
   19ca2:	4b06      	ldr	r3, [pc, #24]	; (19cbc <silk_sigm_Q15+0x50>)
   19ca4:	f933 3022 	ldrsh.w	r3, [r3, r2, lsl #2]
   19ca8:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
   19cac:	f000 001f 	and.w	r0, r0, #31
   19cb0:	fb00 2013 	mls	r0, r0, r3, r2
   19cb4:	4770      	bx	lr
   19cb6:	bf00      	nop
   19cb8:	00037784 	.word	0x00037784
   19cbc:	0003779c 	.word	0x0003779c
   19cc0:	0003776c 	.word	0x0003776c

00019cc4 <silk_insertion_sort_increasing>:
    opus_int32           *a,             /* I/O   Unsorted / Sorted vector               */
    opus_int             *idx,           /* O     Index vector for the sorted elements   */
    const opus_int       L,              /* I     Vector length                          */
    const opus_int       K               /* I     Number of correctly sorted positions   */
)
{
   19cc4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    celt_assert( K >  0 );
    celt_assert( L >  0 );
    celt_assert( L >= K );

    /* Write start indices in index vector */
    for( i = 0; i < K; i++ ) {
   19cc8:	2b00      	cmp	r3, #0
{
   19cca:	b087      	sub	sp, #28
   19ccc:	4689      	mov	r9, r1
    for( i = 0; i < K; i++ ) {
   19cce:	dd2f      	ble.n	19d30 <silk_insertion_sort_increasing+0x6c>
   19cd0:	1f0c      	subs	r4, r1, #4
   19cd2:	2100      	movs	r1, #0
        idx[ i ] = i;
   19cd4:	f844 1f04 	str.w	r1, [r4, #4]!
    for( i = 0; i < K; i++ ) {
   19cd8:	3101      	adds	r1, #1
   19cda:	428b      	cmp	r3, r1
   19cdc:	d1fa      	bne.n	19cd4 <silk_insertion_sort_increasing+0x10>
    }

    /* Sort vector elements by value, increasing order */
    for( i = 1; i < K; i++ ) {
   19cde:	2b01      	cmp	r3, #1
   19ce0:	dd26      	ble.n	19d30 <silk_insertion_sort_increasing+0x6c>
   19ce2:	f04f 0e01 	mov.w	lr, #1
   19ce6:	4611      	mov	r1, r2
   19ce8:	f109 0a04 	add.w	sl, r9, #4
   19cec:	4672      	mov	r2, lr
   19cee:	4680      	mov	r8, r0
   19cf0:	469c      	mov	ip, r3
   19cf2:	468e      	mov	lr, r1
        value = a[ i ];
   19cf4:	f858 3f04 	ldr.w	r3, [r8, #4]!
   19cf8:	4654      	mov	r4, sl
   19cfa:	4641      	mov	r1, r8
        for( j = i - 1; ( j >= 0 ) && ( value < a[ j ] ); j-- ) {
   19cfc:	f851 5c04 	ldr.w	r5, [r1, #-4]
   19d00:	429d      	cmp	r5, r3
   19d02:	460f      	mov	r7, r1
   19d04:	4626      	mov	r6, r4
   19d06:	dd0a      	ble.n	19d1e <silk_insertion_sort_increasing+0x5a>
            a[ j + 1 ]   = a[ j ];       /* Shift value */
   19d08:	600d      	str	r5, [r1, #0]
            idx[ j + 1 ] = idx[ j ];     /* Shift index */
   19d0a:	f854 1c04 	ldr.w	r1, [r4, #-4]
   19d0e:	6021      	str	r1, [r4, #0]
   19d10:	1f39      	subs	r1, r7, #4
        for( j = i - 1; ( j >= 0 ) && ( value < a[ j ] ); j-- ) {
   19d12:	4288      	cmp	r0, r1
   19d14:	f1a6 0404 	sub.w	r4, r6, #4
   19d18:	d1f0      	bne.n	19cfc <silk_insertion_sort_increasing+0x38>
   19d1a:	464e      	mov	r6, r9
   19d1c:	4607      	mov	r7, r0
        }
        a[ j + 1 ]   = value;   /* Write value */
   19d1e:	603b      	str	r3, [r7, #0]
        idx[ j + 1 ] = i;       /* Write index */
   19d20:	6032      	str	r2, [r6, #0]
    for( i = 1; i < K; i++ ) {
   19d22:	3201      	adds	r2, #1
   19d24:	4594      	cmp	ip, r2
   19d26:	f10a 0a04 	add.w	sl, sl, #4
   19d2a:	d1e3      	bne.n	19cf4 <silk_insertion_sort_increasing+0x30>
   19d2c:	4672      	mov	r2, lr
   19d2e:	4663      	mov	r3, ip
    }

    /* If less than L values are asked for, check the remaining values, */
    /* but only spend CPU to ensure that the K first values are correct */
    for( i = K; i < L; i++ ) {
   19d30:	4293      	cmp	r3, r2
   19d32:	da48      	bge.n	19dc6 <silk_insertion_sort_increasing+0x102>
        value = a[ i ];
        if( value < a[ K - 1 ] ) {
   19d34:	f103 4180 	add.w	r1, r3, #1073741824	; 0x40000000
   19d38:	3901      	subs	r1, #1
   19d3a:	0089      	lsls	r1, r1, #2
   19d3c:	eb00 0b01 	add.w	fp, r0, r1
            for( j = K - 2; ( j >= 0 ) && ( value < a[ j ] ); j-- ) {
   19d40:	1e9c      	subs	r4, r3, #2
   19d42:	3104      	adds	r1, #4
   19d44:	eb09 0501 	add.w	r5, r9, r1
   19d48:	9401      	str	r4, [sp, #4]
   19d4a:	1841      	adds	r1, r0, r1
   19d4c:	00a4      	lsls	r4, r4, #2
   19d4e:	f1a0 0a04 	sub.w	sl, r0, #4
   19d52:	9104      	str	r1, [sp, #16]
   19d54:	1901      	adds	r1, r0, r4
   19d56:	4686      	mov	lr, r0
   19d58:	9403      	str	r4, [sp, #12]
   19d5a:	46d8      	mov	r8, fp
   19d5c:	9505      	str	r5, [sp, #20]
   19d5e:	9102      	str	r1, [sp, #8]
   19d60:	eb0a 0a82 	add.w	sl, sl, r2, lsl #2
   19d64:	4618      	mov	r0, r3
   19d66:	e003      	b.n	19d70 <silk_insertion_sort_increasing+0xac>
    for( i = K; i < L; i++ ) {
   19d68:	45c2      	cmp	sl, r8
   19d6a:	f100 0001 	add.w	r0, r0, #1
   19d6e:	d02a      	beq.n	19dc6 <silk_insertion_sort_increasing+0x102>
        value = a[ i ];
   19d70:	f858 5f04 	ldr.w	r5, [r8, #4]!
        if( value < a[ K - 1 ] ) {
   19d74:	f8db 3000 	ldr.w	r3, [fp]
   19d78:	42ab      	cmp	r3, r5
   19d7a:	ddf5      	ble.n	19d68 <silk_insertion_sort_increasing+0xa4>
            for( j = K - 2; ( j >= 0 ) && ( value < a[ j ] ); j-- ) {
   19d7c:	9a01      	ldr	r2, [sp, #4]
   19d7e:	2a00      	cmp	r2, #0
   19d80:	db24      	blt.n	19dcc <silk_insertion_sort_increasing+0x108>
   19d82:	9b02      	ldr	r3, [sp, #8]
   19d84:	6819      	ldr	r1, [r3, #0]
   19d86:	428d      	cmp	r5, r1
   19d88:	da20      	bge.n	19dcc <silk_insertion_sort_increasing+0x108>
   19d8a:	9b03      	ldr	r3, [sp, #12]
   19d8c:	e9dd 4604 	ldrd	r4, r6, [sp, #16]
   19d90:	eb09 0703 	add.w	r7, r9, r3
   19d94:	e003      	b.n	19d9e <silk_insertion_sort_increasing+0xda>
   19d96:	f854 1c08 	ldr.w	r1, [r4, #-8]
   19d9a:	42a9      	cmp	r1, r5
   19d9c:	dd09      	ble.n	19db2 <silk_insertion_sort_increasing+0xee>
                a[ j + 1 ]   = a[ j ];       /* Shift value */
                idx[ j + 1 ] = idx[ j ];     /* Shift index */
   19d9e:	f857 3904 	ldr.w	r3, [r7], #-4
                a[ j + 1 ]   = a[ j ];       /* Shift value */
   19da2:	f844 1d04 	str.w	r1, [r4, #-4]!
            for( j = K - 2; ( j >= 0 ) && ( value < a[ j ] ); j-- ) {
   19da6:	3a01      	subs	r2, #1
                idx[ j + 1 ] = idx[ j ];     /* Shift index */
   19da8:	f846 3d04 	str.w	r3, [r6, #-4]!
            for( j = K - 2; ( j >= 0 ) && ( value < a[ j ] ); j-- ) {
   19dac:	1c53      	adds	r3, r2, #1
   19dae:	4694      	mov	ip, r2
   19db0:	d1f1      	bne.n	19d96 <silk_insertion_sort_increasing+0xd2>
            }
            a[ j + 1 ]   = value;   /* Write value */
   19db2:	f10c 0c01 	add.w	ip, ip, #1
   19db6:	f84e 502c 	str.w	r5, [lr, ip, lsl #2]
            idx[ j + 1 ] = i;       /* Write index */
   19dba:	f849 002c 	str.w	r0, [r9, ip, lsl #2]
    for( i = K; i < L; i++ ) {
   19dbe:	45c2      	cmp	sl, r8
   19dc0:	f100 0001 	add.w	r0, r0, #1
   19dc4:	d1d4      	bne.n	19d70 <silk_insertion_sort_increasing+0xac>
        }
    }
}
   19dc6:	b007      	add	sp, #28
   19dc8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   19dcc:	4694      	mov	ip, r2
            a[ j + 1 ]   = value;   /* Write value */
   19dce:	f10c 0c01 	add.w	ip, ip, #1
   19dd2:	f84e 502c 	str.w	r5, [lr, ip, lsl #2]
            idx[ j + 1 ] = i;       /* Write index */
   19dd6:	f849 002c 	str.w	r0, [r9, ip, lsl #2]
   19dda:	e7f0      	b.n	19dbe <silk_insertion_sort_increasing+0xfa>

00019ddc <silk_insertion_sort_decreasing_int16>:
    opus_int16                  *a,                 /* I/O   Unsorted / Sorted vector                                   */
    opus_int                    *idx,               /* O     Index vector for the sorted elements                       */
    const opus_int              L,                  /* I     Vector length                                              */
    const opus_int              K                   /* I     Number of correctly sorted positions                       */
)
{
   19ddc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    celt_assert( K >  0 );
    celt_assert( L >  0 );
    celt_assert( L >= K );

    /* Write start indices in index vector */
    for( i = 0; i < K; i++ ) {
   19de0:	2b00      	cmp	r3, #0
{
   19de2:	b085      	sub	sp, #20
   19de4:	4689      	mov	r9, r1
    for( i = 0; i < K; i++ ) {
   19de6:	dd2e      	ble.n	19e46 <silk_insertion_sort_decreasing_int16+0x6a>
   19de8:	1f0c      	subs	r4, r1, #4
   19dea:	2100      	movs	r1, #0
        idx[ i ] = i;
   19dec:	f844 1f04 	str.w	r1, [r4, #4]!
    for( i = 0; i < K; i++ ) {
   19df0:	3101      	adds	r1, #1
   19df2:	428b      	cmp	r3, r1
   19df4:	d1fa      	bne.n	19dec <silk_insertion_sort_decreasing_int16+0x10>
    }

    /* Sort vector elements by value, decreasing order */
    for( i = 1; i < K; i++ ) {
   19df6:	2b01      	cmp	r3, #1
   19df8:	dd25      	ble.n	19e46 <silk_insertion_sort_decreasing_int16+0x6a>
   19dfa:	f04f 0e01 	mov.w	lr, #1
   19dfe:	4619      	mov	r1, r3
   19e00:	f109 0a04 	add.w	sl, r9, #4
   19e04:	4673      	mov	r3, lr
   19e06:	4680      	mov	r8, r0
   19e08:	468e      	mov	lr, r1
        value = a[ i ];
   19e0a:	f938 cf02 	ldrsh.w	ip, [r8, #2]!
   19e0e:	4654      	mov	r4, sl
   19e10:	4641      	mov	r1, r8
        for( j = i - 1; ( j >= 0 ) && ( value > a[ j ] ); j-- ) {
   19e12:	f931 5c02 	ldrsh.w	r5, [r1, #-2]
   19e16:	45ac      	cmp	ip, r5
   19e18:	460f      	mov	r7, r1
   19e1a:	4626      	mov	r6, r4
   19e1c:	dd0a      	ble.n	19e34 <silk_insertion_sort_decreasing_int16+0x58>
            a[ j + 1 ]   = a[ j ];     /* Shift value */
   19e1e:	800d      	strh	r5, [r1, #0]
            idx[ j + 1 ] = idx[ j ];   /* Shift index */
   19e20:	f854 1c04 	ldr.w	r1, [r4, #-4]
   19e24:	6021      	str	r1, [r4, #0]
   19e26:	1eb9      	subs	r1, r7, #2
        for( j = i - 1; ( j >= 0 ) && ( value > a[ j ] ); j-- ) {
   19e28:	4288      	cmp	r0, r1
   19e2a:	f1a6 0404 	sub.w	r4, r6, #4
   19e2e:	d1f0      	bne.n	19e12 <silk_insertion_sort_decreasing_int16+0x36>
   19e30:	464e      	mov	r6, r9
   19e32:	4607      	mov	r7, r0
        }
        a[ j + 1 ]   = value;   /* Write value */
   19e34:	f8a7 c000 	strh.w	ip, [r7]
        idx[ j + 1 ] = i;       /* Write index */
   19e38:	6033      	str	r3, [r6, #0]
    for( i = 1; i < K; i++ ) {
   19e3a:	3301      	adds	r3, #1
   19e3c:	459e      	cmp	lr, r3
   19e3e:	f10a 0a04 	add.w	sl, sl, #4
   19e42:	d1e2      	bne.n	19e0a <silk_insertion_sort_decreasing_int16+0x2e>
   19e44:	4673      	mov	r3, lr
    }

    /* If less than L values are asked for, check the remaining values, */
    /* but only spend CPU to ensure that the K first values are correct */
    for( i = K; i < L; i++ ) {
   19e46:	4293      	cmp	r3, r2
   19e48:	da46      	bge.n	19ed8 <silk_insertion_sort_decreasing_int16+0xfc>
        value = a[ i ];
        if( value > a[ K - 1 ] ) {
   19e4a:	f103 4100 	add.w	r1, r3, #2147483648	; 0x80000000
   19e4e:	3901      	subs	r1, #1
   19e50:	0049      	lsls	r1, r1, #1
   19e52:	eb00 0a01 	add.w	sl, r0, r1
            for( j = K - 2; ( j >= 0 ) && ( value > a[ j ] ); j-- ) {
   19e56:	1e8d      	subs	r5, r1, #2
   19e58:	f103 4480 	add.w	r4, r3, #1073741824	; 0x40000000
   19e5c:	3102      	adds	r1, #2
   19e5e:	1841      	adds	r1, r0, r1
   19e60:	3c01      	subs	r4, #1
   19e62:	f1a0 0802 	sub.w	r8, r0, #2
   19e66:	1945      	adds	r5, r0, r5
   19e68:	9103      	str	r1, [sp, #12]
   19e6a:	eb09 0184 	add.w	r1, r9, r4, lsl #2
   19e6e:	46d6      	mov	lr, sl
   19e70:	9501      	str	r5, [sp, #4]
   19e72:	9102      	str	r1, [sp, #8]
   19e74:	eb08 0842 	add.w	r8, r8, r2, lsl #1
   19e78:	f1a3 0b02 	sub.w	fp, r3, #2
   19e7c:	e003      	b.n	19e86 <silk_insertion_sort_decreasing_int16+0xaa>
    for( i = K; i < L; i++ ) {
   19e7e:	45f0      	cmp	r8, lr
   19e80:	f103 0301 	add.w	r3, r3, #1
   19e84:	d028      	beq.n	19ed8 <silk_insertion_sort_decreasing_int16+0xfc>
        value = a[ i ];
   19e86:	f93e 6f02 	ldrsh.w	r6, [lr, #2]!
        if( value > a[ K - 1 ] ) {
   19e8a:	f9ba 2000 	ldrsh.w	r2, [sl]
   19e8e:	42b2      	cmp	r2, r6
   19e90:	daf5      	bge.n	19e7e <silk_insertion_sort_decreasing_int16+0xa2>
            for( j = K - 2; ( j >= 0 ) && ( value > a[ j ] ); j-- ) {
   19e92:	f1bb 0f00 	cmp.w	fp, #0
   19e96:	db22      	blt.n	19ede <silk_insertion_sort_decreasing_int16+0x102>
   19e98:	9a01      	ldr	r2, [sp, #4]
   19e9a:	f9b2 1000 	ldrsh.w	r1, [r2]
   19e9e:	428e      	cmp	r6, r1
   19ea0:	dd1d      	ble.n	19ede <silk_insertion_sort_decreasing_int16+0x102>
   19ea2:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
   19ea6:	465a      	mov	r2, fp
   19ea8:	e003      	b.n	19eb2 <silk_insertion_sort_decreasing_int16+0xd6>
   19eaa:	f935 1c04 	ldrsh.w	r1, [r5, #-4]
   19eae:	428e      	cmp	r6, r1
   19eb0:	dd08      	ble.n	19ec4 <silk_insertion_sort_decreasing_int16+0xe8>
   19eb2:	3a01      	subs	r2, #1
                a[ j + 1 ]   = a[ j ];     /* Shift value */
                idx[ j + 1 ] = idx[ j ];   /* Shift index */
   19eb4:	f854 7d04 	ldr.w	r7, [r4, #-4]!
                a[ j + 1 ]   = a[ j ];     /* Shift value */
   19eb8:	f825 1d02 	strh.w	r1, [r5, #-2]!
            for( j = K - 2; ( j >= 0 ) && ( value > a[ j ] ); j-- ) {
   19ebc:	1c51      	adds	r1, r2, #1
   19ebe:	4694      	mov	ip, r2
                idx[ j + 1 ] = idx[ j ];   /* Shift index */
   19ec0:	6067      	str	r7, [r4, #4]
            for( j = K - 2; ( j >= 0 ) && ( value > a[ j ] ); j-- ) {
   19ec2:	d1f2      	bne.n	19eaa <silk_insertion_sort_decreasing_int16+0xce>
            }
            a[ j + 1 ]   = value;   /* Write value */
   19ec4:	f10c 0c01 	add.w	ip, ip, #1
   19ec8:	f820 601c 	strh.w	r6, [r0, ip, lsl #1]
            idx[ j + 1 ] = i;       /* Write index */
   19ecc:	f849 302c 	str.w	r3, [r9, ip, lsl #2]
    for( i = K; i < L; i++ ) {
   19ed0:	45f0      	cmp	r8, lr
   19ed2:	f103 0301 	add.w	r3, r3, #1
   19ed6:	d1d6      	bne.n	19e86 <silk_insertion_sort_decreasing_int16+0xaa>
        }
    }
}
   19ed8:	b005      	add	sp, #20
   19eda:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            for( j = K - 2; ( j >= 0 ) && ( value > a[ j ] ); j-- ) {
   19ede:	46dc      	mov	ip, fp
            a[ j + 1 ]   = value;   /* Write value */
   19ee0:	f10c 0c01 	add.w	ip, ip, #1
   19ee4:	f820 601c 	strh.w	r6, [r0, ip, lsl #1]
            idx[ j + 1 ] = i;       /* Write index */
   19ee8:	f849 302c 	str.w	r3, [r9, ip, lsl #2]
   19eec:	e7f0      	b.n	19ed0 <silk_insertion_sort_decreasing_int16+0xf4>
   19eee:	bf00      	nop

00019ef0 <silk_insertion_sort_increasing_all_values_int16>:

    /* Safety checks */
    celt_assert( L >  0 );

    /* Sort vector elements by value, increasing order */
    for( i = 1; i < L; i++ ) {
   19ef0:	2901      	cmp	r1, #1
   19ef2:	dd27      	ble.n	19f44 <silk_insertion_sort_increasing_all_values_int16+0x54>
{
   19ef4:	b4f0      	push	{r4, r5, r6, r7}
   19ef6:	f101 3cff 	add.w	ip, r1, #4294967295	; 0xffffffff
   19efa:	1c87      	adds	r7, r0, #2
    for( i = 1; i < L; i++ ) {
   19efc:	2600      	movs	r6, #0
        value = a[ i ];
   19efe:	f937 5b02 	ldrsh.w	r5, [r7], #2
        for( j = i - 1; ( j >= 0 ) && ( value < a[ j ] ); j-- ) {
   19f02:	f937 2c04 	ldrsh.w	r2, [r7, #-4]
   19f06:	4295      	cmp	r5, r2
   19f08:	4633      	mov	r3, r6
   19f0a:	da13      	bge.n	19f34 <silk_insertion_sort_increasing_all_values_int16+0x44>
   19f0c:	4639      	mov	r1, r7
   19f0e:	e003      	b.n	19f18 <silk_insertion_sort_increasing_all_values_int16+0x28>
   19f10:	f931 2c04 	ldrsh.w	r2, [r1, #-4]
   19f14:	4295      	cmp	r5, r2
   19f16:	da05      	bge.n	19f24 <silk_insertion_sort_increasing_all_values_int16+0x34>
   19f18:	3b01      	subs	r3, #1
            a[ j + 1 ] = a[ j ]; /* Shift value */
   19f1a:	f821 2d02 	strh.w	r2, [r1, #-2]!
        for( j = i - 1; ( j >= 0 ) && ( value < a[ j ] ); j-- ) {
   19f1e:	1c5a      	adds	r2, r3, #1
   19f20:	461c      	mov	r4, r3
   19f22:	d1f5      	bne.n	19f10 <silk_insertion_sort_increasing_all_values_int16+0x20>
        }
        a[ j + 1 ] = value; /* Write value */
   19f24:	3401      	adds	r4, #1
   19f26:	3601      	adds	r6, #1
    for( i = 1; i < L; i++ ) {
   19f28:	45b4      	cmp	ip, r6
        a[ j + 1 ] = value; /* Write value */
   19f2a:	f820 5014 	strh.w	r5, [r0, r4, lsl #1]
    for( i = 1; i < L; i++ ) {
   19f2e:	d1e6      	bne.n	19efe <silk_insertion_sort_increasing_all_values_int16+0xe>
    }
}
   19f30:	bcf0      	pop	{r4, r5, r6, r7}
   19f32:	4770      	bx	lr
        for( j = i - 1; ( j >= 0 ) && ( value < a[ j ] ); j-- ) {
   19f34:	4634      	mov	r4, r6
        a[ j + 1 ] = value; /* Write value */
   19f36:	3401      	adds	r4, #1
   19f38:	3601      	adds	r6, #1
    for( i = 1; i < L; i++ ) {
   19f3a:	45b4      	cmp	ip, r6
        a[ j + 1 ] = value; /* Write value */
   19f3c:	f820 5014 	strh.w	r5, [r0, r4, lsl #1]
    for( i = 1; i < L; i++ ) {
   19f40:	d1dd      	bne.n	19efe <silk_insertion_sort_increasing_all_values_int16+0xe>
   19f42:	e7f5      	b.n	19f30 <silk_insertion_sort_increasing_all_values_int16+0x40>
   19f44:	4770      	bx	lr
   19f46:	bf00      	nop

00019f48 <silk_sum_sqr_shift>:
    opus_int32                  *energy,            /* O   Energy of x, after shifting to the right                     */
    opus_int                    *shift,             /* O   Number of bits right shift applied to energy                 */
    const opus_int16            *x,                 /* I   Input vector                                                 */
    opus_int                    len                 /* I   Length of input vector                                       */
)
{
   19f48:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   19f4c:	2b00      	cmp	r3, #0
   19f4e:	d060      	beq.n	1a012 <silk_sum_sqr_shift+0xca>
   19f50:	f103 39ff 	add.w	r9, r3, #4294967295	; 0xffffffff
   19f54:	fab3 f883 	clz	r8, r3

    /* Do a first run with the maximum shift we could have. */
    shft = 31-silk_CLZ32(len);
    /* Let's be conservative with rounding and start with nrg=len. */
    nrg  = len;
    for( i = 0; i < len - 1; i += 2 ) {
   19f58:	f1b9 0f00 	cmp.w	r9, #0
    shft = 31-silk_CLZ32(len);
   19f5c:	f1c8 0c1f 	rsb	ip, r8, #31
   19f60:	f1c8 0822 	rsb	r8, r8, #34	; 0x22
    for( i = 0; i < len - 1; i += 2 ) {
   19f64:	dd59      	ble.n	1a01a <silk_sum_sqr_shift+0xd2>
   19f66:	f1a3 0e02 	sub.w	lr, r3, #2
   19f6a:	ea4f 0e5e 	mov.w	lr, lr, lsr #1
   19f6e:	1d17      	adds	r7, r2, #4
   19f70:	eb07 078e 	add.w	r7, r7, lr, lsl #2
   19f74:	4615      	mov	r5, r2
   19f76:	461e      	mov	r6, r3
        nrg_tmp = silk_SMULBB( x[ i ], x[ i ] );
   19f78:	f9b5 a000 	ldrsh.w	sl, [r5]
        nrg_tmp = silk_SMLABB_ovflw( nrg_tmp, x[ i + 1 ], x[ i + 1 ] );
   19f7c:	f9b5 4002 	ldrsh.w	r4, [r5, #2]
        nrg_tmp = silk_SMULBB( x[ i ], x[ i ] );
   19f80:	fb0a fa0a 	mul.w	sl, sl, sl
        nrg_tmp = silk_SMLABB_ovflw( nrg_tmp, x[ i + 1 ], x[ i + 1 ] );
   19f84:	fb04 a404 	mla	r4, r4, r4, sl
   19f88:	3504      	adds	r5, #4
        nrg = (opus_int32)silk_ADD_RSHIFT_uint( nrg, nrg_tmp, shft );
   19f8a:	fa24 f40c 	lsr.w	r4, r4, ip
    for( i = 0; i < len - 1; i += 2 ) {
   19f8e:	42af      	cmp	r7, r5
        nrg = (opus_int32)silk_ADD_RSHIFT_uint( nrg, nrg_tmp, shft );
   19f90:	4426      	add	r6, r4
    for( i = 0; i < len - 1; i += 2 ) {
   19f92:	d1f1      	bne.n	19f78 <silk_sum_sqr_shift+0x30>
   19f94:	f10e 0e01 	add.w	lr, lr, #1
   19f98:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
    }
    if( i < len ) {
   19f9c:	4573      	cmp	r3, lr
   19f9e:	dd06      	ble.n	19fae <silk_sum_sqr_shift+0x66>
        /* One sample left to process */
        nrg_tmp = silk_SMULBB( x[ i ], x[ i ] );
   19fa0:	f932 401e 	ldrsh.w	r4, [r2, lr, lsl #1]
   19fa4:	fb04 f404 	mul.w	r4, r4, r4
        nrg = (opus_int32)silk_ADD_RSHIFT_uint( nrg, nrg_tmp, shft );
   19fa8:	fa24 fc0c 	lsr.w	ip, r4, ip
   19fac:	4466      	add	r6, ip
   19fae:	fab6 f686 	clz	r6, r6
    }
    silk_assert( nrg >= 0 );
    /* Make sure the result will fit in a 32-bit signed integer with two bits
       of headroom. */
    shft = silk_max_32(0, shft+3 - silk_CLZ32(nrg));
   19fb2:	eba8 0706 	sub.w	r7, r8, r6
    nrg = 0;
    for( i = 0 ; i < len - 1; i += 2 ) {
   19fb6:	f1b9 0f00 	cmp.w	r9, #0
{
    return (((a) > (b)) ? (a) : (b));
}
static OPUS_INLINE opus_int32 silk_max_32(opus_int32 a, opus_int32 b)
{
    return (((a) > (b)) ? (a) : (b));
   19fba:	ea27 77e7 	bic.w	r7, r7, r7, asr #31
   19fbe:	dd30      	ble.n	1a022 <silk_sum_sqr_shift+0xda>
   19fc0:	f1a3 0e02 	sub.w	lr, r3, #2
   19fc4:	ea4f 0e5e 	mov.w	lr, lr, lsr #1
   19fc8:	f102 0804 	add.w	r8, r2, #4
   19fcc:	eb08 088e 	add.w	r8, r8, lr, lsl #2
   19fd0:	4615      	mov	r5, r2
    nrg = 0;
   19fd2:	f04f 0c00 	mov.w	ip, #0
        nrg_tmp = silk_SMULBB( x[ i ], x[ i ] );
   19fd6:	f9b5 6000 	ldrsh.w	r6, [r5]
        nrg_tmp = silk_SMLABB_ovflw( nrg_tmp, x[ i + 1 ], x[ i + 1 ] );
   19fda:	f9b5 4002 	ldrsh.w	r4, [r5, #2]
        nrg_tmp = silk_SMULBB( x[ i ], x[ i ] );
   19fde:	fb06 f606 	mul.w	r6, r6, r6
        nrg_tmp = silk_SMLABB_ovflw( nrg_tmp, x[ i + 1 ], x[ i + 1 ] );
   19fe2:	fb04 6404 	mla	r4, r4, r4, r6
   19fe6:	3504      	adds	r5, #4
        nrg = (opus_int32)silk_ADD_RSHIFT_uint( nrg, nrg_tmp, shft );
   19fe8:	40fc      	lsrs	r4, r7
    for( i = 0 ; i < len - 1; i += 2 ) {
   19fea:	45a8      	cmp	r8, r5
        nrg = (opus_int32)silk_ADD_RSHIFT_uint( nrg, nrg_tmp, shft );
   19fec:	44a4      	add	ip, r4
    for( i = 0 ; i < len - 1; i += 2 ) {
   19fee:	d1f2      	bne.n	19fd6 <silk_sum_sqr_shift+0x8e>
   19ff0:	f10e 0e01 	add.w	lr, lr, #1
   19ff4:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
    }
    if( i < len ) {
   19ff8:	4573      	cmp	r3, lr
   19ffa:	dd05      	ble.n	1a008 <silk_sum_sqr_shift+0xc0>
        /* One sample left to process */
        nrg_tmp = silk_SMULBB( x[ i ], x[ i ] );
   19ffc:	f932 301e 	ldrsh.w	r3, [r2, lr, lsl #1]
   1a000:	fb03 f303 	mul.w	r3, r3, r3
        nrg = (opus_int32)silk_ADD_RSHIFT_uint( nrg, nrg_tmp, shft );
   1a004:	40fb      	lsrs	r3, r7
   1a006:	449c      	add	ip, r3
    }

    silk_assert( nrg >= 0 );

    /* Output arguments */
    *shift  = shft;
   1a008:	600f      	str	r7, [r1, #0]
    *energy = nrg;
   1a00a:	f8c0 c000 	str.w	ip, [r0]
}
   1a00e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1a012:	461f      	mov	r7, r3
    nrg = 0;
   1a014:	469c      	mov	ip, r3
    for( i = 0 ; i < len - 1; i += 2 ) {
   1a016:	469e      	mov	lr, r3
   1a018:	e7ee      	b.n	19ff8 <silk_sum_sqr_shift+0xb0>
    for( i = 0; i < len - 1; i += 2 ) {
   1a01a:	461e      	mov	r6, r3
   1a01c:	f04f 0e00 	mov.w	lr, #0
   1a020:	e7bc      	b.n	19f9c <silk_sum_sqr_shift+0x54>
    nrg = 0;
   1a022:	f04f 0c00 	mov.w	ip, #0
    for( i = 0 ; i < len - 1; i += 2 ) {
   1a026:	46e6      	mov	lr, ip
   1a028:	e7e6      	b.n	19ff8 <silk_sum_sqr_shift+0xb0>
   1a02a:	bf00      	nop

0001a02c <silk_stereo_encode_pred>:
/* Entropy code the mid/side quantization indices */
void silk_stereo_encode_pred(
    ec_enc                      *psRangeEnc,                    /* I/O  Compressor data structure                   */
    opus_int8                   ix[ 2 ][ 3 ]                    /* I    Quantization indices                        */
)
{
   1a02c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1a030:	460c      	mov	r4, r1
    opus_int   n;

    /* Entropy coding */
    n = 5 * ix[ 0 ][ 2 ] + ix[ 1 ][ 2 ];
   1a032:	f991 1002 	ldrsb.w	r1, [r1, #2]
   1a036:	f994 3005 	ldrsb.w	r3, [r4, #5]
    celt_assert( n < 25 );
    ec_enc_icdf( psRangeEnc, n, silk_stereo_pred_joint_iCDF, 8 );
    for( n = 0; n < 2; n++ ) {
        celt_assert( ix[ n ][ 0 ] < 3 );
        celt_assert( ix[ n ][ 1 ] < STEREO_QUANT_SUB_STEPS );
        ec_enc_icdf( psRangeEnc, ix[ n ][ 0 ], silk_uniform3_iCDF, 8 );
   1a03a:	4f14      	ldr	r7, [pc, #80]	; (1a08c <silk_stereo_encode_pred+0x60>)
        ec_enc_icdf( psRangeEnc, ix[ n ][ 1 ], silk_uniform5_iCDF, 8 );
   1a03c:	4e14      	ldr	r6, [pc, #80]	; (1a090 <silk_stereo_encode_pred+0x64>)
    ec_enc_icdf( psRangeEnc, n, silk_stereo_pred_joint_iCDF, 8 );
   1a03e:	4a15      	ldr	r2, [pc, #84]	; (1a094 <silk_stereo_encode_pred+0x68>)
    n = 5 * ix[ 0 ][ 2 ] + ix[ 1 ][ 2 ];
   1a040:	2505      	movs	r5, #5
    ec_enc_icdf( psRangeEnc, n, silk_stereo_pred_joint_iCDF, 8 );
   1a042:	fb05 3101 	mla	r1, r5, r1, r3
{
   1a046:	4605      	mov	r5, r0
    ec_enc_icdf( psRangeEnc, n, silk_stereo_pred_joint_iCDF, 8 );
   1a048:	2308      	movs	r3, #8
   1a04a:	f00f ff19 	bl	29e80 <ec_enc_icdf>
        ec_enc_icdf( psRangeEnc, ix[ n ][ 0 ], silk_uniform3_iCDF, 8 );
   1a04e:	f994 1000 	ldrsb.w	r1, [r4]
   1a052:	4628      	mov	r0, r5
   1a054:	463a      	mov	r2, r7
   1a056:	2308      	movs	r3, #8
   1a058:	f00f ff12 	bl	29e80 <ec_enc_icdf>
        ec_enc_icdf( psRangeEnc, ix[ n ][ 1 ], silk_uniform5_iCDF, 8 );
   1a05c:	f994 1001 	ldrsb.w	r1, [r4, #1]
   1a060:	4628      	mov	r0, r5
   1a062:	4632      	mov	r2, r6
   1a064:	2308      	movs	r3, #8
   1a066:	f00f ff0b 	bl	29e80 <ec_enc_icdf>
        ec_enc_icdf( psRangeEnc, ix[ n ][ 0 ], silk_uniform3_iCDF, 8 );
   1a06a:	463a      	mov	r2, r7
   1a06c:	f994 1003 	ldrsb.w	r1, [r4, #3]
   1a070:	4628      	mov	r0, r5
   1a072:	2308      	movs	r3, #8
   1a074:	f00f ff04 	bl	29e80 <ec_enc_icdf>
        ec_enc_icdf( psRangeEnc, ix[ n ][ 1 ], silk_uniform5_iCDF, 8 );
   1a078:	4632      	mov	r2, r6
   1a07a:	f994 1004 	ldrsb.w	r1, [r4, #4]
   1a07e:	4628      	mov	r0, r5
   1a080:	2308      	movs	r3, #8
    }
}
   1a082:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        ec_enc_icdf( psRangeEnc, ix[ n ][ 1 ], silk_uniform5_iCDF, 8 );
   1a086:	f00f befb 	b.w	29e80 <ec_enc_icdf>
   1a08a:	bf00      	nop
   1a08c:	00036d40 	.word	0x00036d40
   1a090:	00036d48 	.word	0x00036d48
   1a094:	00036cfc 	.word	0x00036cfc

0001a098 <silk_stereo_encode_mid_only>:
    ec_enc                      *psRangeEnc,                    /* I/O  Compressor data structure                   */
    opus_int8                   mid_only_flag
)
{
    /* Encode flag that only mid channel is coded */
    ec_enc_icdf( psRangeEnc, mid_only_flag, silk_stereo_only_code_mid_iCDF, 8 );
   1a098:	2308      	movs	r3, #8
   1a09a:	4a01      	ldr	r2, [pc, #4]	; (1a0a0 <silk_stereo_encode_mid_only+0x8>)
   1a09c:	f00f bef0 	b.w	29e80 <ec_enc_icdf>
   1a0a0:	00036cf8 	.word	0x00036cf8

0001a0a4 <silk_stereo_find_predictor>:
    const opus_int16            y[],                            /* I    Target signal                               */
    opus_int32                  mid_res_amp_Q0[],               /* I/O  Smoothed mid, residual norms                */
    opus_int                    length,                         /* I    Number of samples                           */
    opus_int                    smooth_coef_Q16                 /* I    Smoothing coefficient                       */
)
{
   1a0a4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1a0a8:	b084      	sub	sp, #16
   1a0aa:	4692      	mov	sl, r2
   1a0ac:	4689      	mov	r9, r1
    opus_int   scale, scale1, scale2;
    opus_int32 nrgx, nrgy, corr, pred_Q13, pred2_Q10;

    /* Find  predictor */
    silk_sum_sqr_shift( &nrgx, &scale1, x, length );
   1a0ae:	460a      	mov	r2, r1
{
   1a0b0:	4606      	mov	r6, r0
    silk_sum_sqr_shift( &nrgx, &scale1, x, length );
   1a0b2:	4669      	mov	r1, sp
   1a0b4:	a802      	add	r0, sp, #8
{
   1a0b6:	461d      	mov	r5, r3
    silk_sum_sqr_shift( &nrgx, &scale1, x, length );
   1a0b8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1a0ba:	f7ff ff45 	bl	19f48 <silk_sum_sqr_shift>
    silk_sum_sqr_shift( &nrgy, &scale2, y, length );
   1a0be:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1a0c0:	4652      	mov	r2, sl
   1a0c2:	a901      	add	r1, sp, #4
   1a0c4:	a803      	add	r0, sp, #12
   1a0c6:	f7ff ff3f 	bl	19f48 <silk_sum_sqr_shift>
    scale = silk_max_int( scale1, scale2 );
   1a0ca:	e9dd 7100 	ldrd	r7, r1, [sp]
    return (((a) > (b)) ? (a) : (b));
   1a0ce:	428f      	cmp	r7, r1
   1a0d0:	463a      	mov	r2, r7
   1a0d2:	bfb8      	it	lt
   1a0d4:	460a      	movlt	r2, r1
    scale = scale + ( scale & 1 );          /* make even */
    nrgy = silk_RSHIFT32( nrgy, scale - scale2 );
   1a0d6:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
    scale = scale + ( scale & 1 );          /* make even */
   1a0da:	3201      	adds	r2, #1
   1a0dc:	f022 0801 	bic.w	r8, r2, #1
    nrgx = silk_RSHIFT32( nrgx, scale - scale1 );
   1a0e0:	eba8 0707 	sub.w	r7, r8, r7
   1a0e4:	fa43 f707 	asr.w	r7, r3, r7
    nrgy = silk_RSHIFT32( nrgy, scale - scale2 );
   1a0e8:	eba8 0201 	sub.w	r2, r8, r1
   1a0ec:	2f01      	cmp	r7, #1
   1a0ee:	bfb8      	it	lt
   1a0f0:	2701      	movlt	r7, #1
   1a0f2:	4114      	asrs	r4, r2
    nrgx = silk_max_int( nrgx, 1 );
    corr = silk_inner_prod_aligned_scale( x, y, scale, length );
   1a0f4:	4651      	mov	r1, sl
   1a0f6:	4648      	mov	r0, r9
   1a0f8:	4642      	mov	r2, r8
   1a0fa:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    nrgy = silk_RSHIFT32( nrgy, scale - scale2 );
   1a0fc:	e9cd 7402 	strd	r7, r4, [sp, #8]
    corr = silk_inner_prod_aligned_scale( x, y, scale, length );
   1a100:	f7fd fc44 	bl	1798c <silk_inner_prod_aligned_scale>
    pred_Q13 = silk_DIV32_varQ( corr, nrgx, 13 );
   1a104:	9f02      	ldr	r7, [sp, #8]
   1a106:	2800      	cmp	r0, #0
   1a108:	f000 810f 	beq.w	1a32a <silk_stereo_find_predictor+0x286>
    a_headrm = silk_CLZ32( silk_abs(a32) ) - 1;
   1a10c:	ea80 7ee0 	eor.w	lr, r0, r0, asr #31
   1a110:	ebae 7ee0 	sub.w	lr, lr, r0, asr #31
   1a114:	fabe fe8e 	clz	lr, lr
   1a118:	f10e 31ff 	add.w	r1, lr, #4294967295	; 0xffffffff
    a32_nrm = silk_LSHIFT(a32, a_headrm);                                       /* Q: a_headrm                  */
   1a11c:	fa00 f101 	lsl.w	r1, r0, r1
   1a120:	f10e 0e1c 	add.w	lr, lr, #28
   1a124:	2f00      	cmp	r7, #0
   1a126:	f000 8108 	beq.w	1a33a <silk_stereo_find_predictor+0x296>
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
   1a12a:	ea87 7ae7 	eor.w	sl, r7, r7, asr #31
   1a12e:	ebaa 7ae7 	sub.w	sl, sl, r7, asr #31
   1a132:	faba fa8a 	clz	sl, sl
   1a136:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                  */
   1a13a:	fa07 f20a 	lsl.w	r2, r7, sl
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1a13e:	ea4f 4c22 	mov.w	ip, r2, asr #16
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1a142:	fa1f f981 	uxth.w	r9, r1
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1a146:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
   1a14a:	fb93 f3fc 	sdiv	r3, r3, ip
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1a14e:	fa0f fc83 	sxth.w	ip, r3
   1a152:	140b      	asrs	r3, r1, #16
   1a154:	fb0c f303 	mul.w	r3, ip, r3
   1a158:	fb0c f909 	mul.w	r9, ip, r9
   1a15c:	eb03 4929 	add.w	r9, r3, r9, asr #16
    a32_nrm = silk_SUB32_ovflw(a32_nrm, silk_LSHIFT_ovflw( silk_SMMUL(b32_nrm, result), 3 ));  /* Q: a_headrm   */
   1a160:	fb82 2309 	smull	r2, r3, r2, r9
   1a164:	eba1 01c3 	sub.w	r1, r1, r3, lsl #3
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1a168:	b28b      	uxth	r3, r1
   1a16a:	1409      	asrs	r1, r1, #16
   1a16c:	fb0c f203 	mul.w	r2, ip, r3
    lshift = 29 + a_headrm - b_headrm - Qres;
   1a170:	ebae 0e0a 	sub.w	lr, lr, sl
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1a174:	fb0c f301 	mul.w	r3, ip, r1
   1a178:	eb03 4322 	add.w	r3, r3, r2, asr #16
    if( lshift < 0 ) {
   1a17c:	f1be 020d 	subs.w	r2, lr, #13
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1a180:	444b      	add	r3, r9
    if( lshift < 0 ) {
   1a182:	f100 8101 	bmi.w	1a388 <silk_stereo_find_predictor+0x2e4>
        if( lshift < 32){
   1a186:	2a1f      	cmp	r2, #31
   1a188:	f300 80da 	bgt.w	1a340 <silk_stereo_find_predictor+0x29c>
            return silk_RSHIFT(result, lshift);
   1a18c:	4113      	asrs	r3, r2
    pred_Q13 = silk_LIMIT( pred_Q13, -(1 << 14), 1 << 14 );
   1a18e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
   1a192:	ea4f 4120 	mov.w	r1, r0, asr #16
   1a196:	fa1f fe80 	uxth.w	lr, r0
   1a19a:	ea4f 4227 	mov.w	r2, r7, asr #16
   1a19e:	fa1f fc87 	uxth.w	ip, r7
   1a1a2:	f340 8103 	ble.w	1a3ac <silk_stereo_find_predictor+0x308>
   1a1a6:	0389      	lsls	r1, r1, #14
   1a1a8:	0312      	lsls	r2, r2, #12
   1a1aa:	eb01 0e9e 	add.w	lr, r1, lr, lsr #2
   1a1ae:	eb02 1c1c 	add.w	ip, r2, ip, lsr #4
   1a1b2:	ea4f 1e0e 	mov.w	lr, lr, lsl #4
   1a1b6:	ea4f 1c8c 	mov.w	ip, ip, lsl #6
   1a1ba:	f44f 5380 	mov.w	r3, #4096	; 0x1000
   1a1be:	f44f 4080 	mov.w	r0, #16384	; 0x4000
   1a1c2:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   1a1c4:	4293      	cmp	r3, r2
   1a1c6:	bfb8      	it	lt
   1a1c8:	4613      	movlt	r3, r2
    if( x <= 0 ) {
   1a1ca:	2f00      	cmp	r7, #0
    /* Faster update for signals with large prediction parameters */
    smooth_coef_Q16 = (opus_int)silk_max_int( smooth_coef_Q16, silk_abs( pred2_Q10 ) );

    /* Smoothed mid and residual norms */
    silk_assert( smooth_coef_Q16 < 32768 );
    scale = silk_RSHIFT( scale, 1 );
   1a1cc:	ea4f 0268 	mov.w	r2, r8, asr #1
    mid_res_amp_Q0[ 0 ] = silk_SMLAWB( mid_res_amp_Q0[ 0 ], silk_LSHIFT( silk_SQRT_APPROX( nrgx ), scale ) - mid_res_amp_Q0[ 0 ],
   1a1d0:	f8d5 8000 	ldr.w	r8, [r5]
   1a1d4:	f340 80bd 	ble.w	1a352 <silk_stereo_find_predictor+0x2ae>
   1a1d8:	fab7 f487 	clz	r4, r7
    * frac_Q7 = silk_ROR32(in, 24 - lzeros) & 0x7f;
   1a1dc:	f1c4 0118 	rsb	r1, r4, #24
    if( rot == 0 ) {
   1a1e0:	2900      	cmp	r1, #0
   1a1e2:	d002      	beq.n	1a1ea <silk_stereo_find_predictor+0x146>
        return (opus_int32) ((x << m) | (x >> (32 - m)));
   1a1e4:	bfb8      	it	lt
   1a1e6:	3120      	addlt	r1, #32
        return (opus_int32) ((x << (32 - r)) | (x >> r));
   1a1e8:	41cf      	rors	r7, r1
   1a1ea:	f007 077f 	and.w	r7, r7, #127	; 0x7f
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   1a1ee:	eb07 09c7 	add.w	r9, r7, r7, lsl #3
        y = 32768;
   1a1f2:	f014 0f01 	tst.w	r4, #1
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   1a1f6:	ebc7 07c9 	rsb	r7, r7, r9, lsl #3
        y = 32768;
   1a1fa:	f24b 4186 	movw	r1, #46214	; 0xb486
    y >>= silk_RSHIFT(lz, 1);
   1a1fe:	ea4f 0464 	mov.w	r4, r4, asr #1
        y = 32768;
   1a202:	bf18      	it	ne
   1a204:	f44f 4100 	movne.w	r1, #32768	; 0x8000
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   1a208:	ebc7 0787 	rsb	r7, r7, r7, lsl #2
    y >>= silk_RSHIFT(lz, 1);
   1a20c:	4121      	asrs	r1, r4
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   1a20e:	b2bc      	uxth	r4, r7
   1a210:	fb01 f404 	mul.w	r4, r1, r4
   1a214:	eb01 4124 	add.w	r1, r1, r4, asr #16
   1a218:	fa01 f402 	lsl.w	r4, r1, r2
   1a21c:	eba4 0408 	sub.w	r4, r4, r8
        smooth_coef_Q16 );
    /* Residual energy = nrgy - 2 * pred * corr + pred^2 * nrgx */
    nrgy = silk_SUB_LSHIFT32( nrgy, silk_SMULWB( corr, pred_Q13 ), 3 + 1 );
   1a220:	9f03      	ldr	r7, [sp, #12]
    mid_res_amp_Q0[ 0 ] = silk_SMLAWB( mid_res_amp_Q0[ 0 ], silk_LSHIFT( silk_SQRT_APPROX( nrgx ), scale ) - mid_res_amp_Q0[ 0 ],
   1a222:	b21b      	sxth	r3, r3
   1a224:	1421      	asrs	r1, r4, #16
   1a226:	fa1f f984 	uxth.w	r9, r4
   1a22a:	fb03 f409 	mul.w	r4, r3, r9
   1a22e:	fb03 f101 	mul.w	r1, r3, r1
    nrgy = silk_SUB_LSHIFT32( nrgy, silk_SMULWB( corr, pred_Q13 ), 3 + 1 );
   1a232:	eba7 070e 	sub.w	r7, r7, lr
    mid_res_amp_Q0[ 0 ] = silk_SMLAWB( mid_res_amp_Q0[ 0 ], silk_LSHIFT( silk_SQRT_APPROX( nrgx ), scale ) - mid_res_amp_Q0[ 0 ],
   1a236:	eb01 4124 	add.w	r1, r1, r4, asr #16
    nrgy = silk_ADD_LSHIFT32( nrgy, silk_SMULWB( nrgx, pred2_Q10 ), 6 );
   1a23a:	44bc      	add	ip, r7
    mid_res_amp_Q0[ 0 ] = silk_SMLAWB( mid_res_amp_Q0[ 0 ], silk_LSHIFT( silk_SQRT_APPROX( nrgx ), scale ) - mid_res_amp_Q0[ 0 ],
   1a23c:	4441      	add	r1, r8
    if( x <= 0 ) {
   1a23e:	f1bc 0f00 	cmp.w	ip, #0
   1a242:	6029      	str	r1, [r5, #0]
    mid_res_amp_Q0[ 1 ] = silk_SMLAWB( mid_res_amp_Q0[ 1 ], silk_LSHIFT( silk_SQRT_APPROX( nrgy ), scale ) - mid_res_amp_Q0[ 1 ],
   1a244:	686c      	ldr	r4, [r5, #4]
   1a246:	f340 8086 	ble.w	1a356 <silk_stereo_find_predictor+0x2b2>
   1a24a:	fabc fe8c 	clz	lr, ip
    * frac_Q7 = silk_ROR32(in, 24 - lzeros) & 0x7f;
   1a24e:	f1ce 0718 	rsb	r7, lr, #24
    if( rot == 0 ) {
   1a252:	2f00      	cmp	r7, #0
   1a254:	d003      	beq.n	1a25e <silk_stereo_find_predictor+0x1ba>
        return (opus_int32) ((x << m) | (x >> (32 - m)));
   1a256:	bfb8      	it	lt
   1a258:	3720      	addlt	r7, #32
        return (opus_int32) ((x << (32 - r)) | (x >> r));
   1a25a:	fa6c fc07 	ror.w	ip, ip, r7
   1a25e:	f00c 0c7f 	and.w	ip, ip, #127	; 0x7f
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   1a262:	eb0c 08cc 	add.w	r8, ip, ip, lsl #3
        y = 32768;
   1a266:	f01e 0f01 	tst.w	lr, #1
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   1a26a:	ebcc 0cc8 	rsb	ip, ip, r8, lsl #3
        y = 32768;
   1a26e:	f24b 4786 	movw	r7, #46214	; 0xb486
    y >>= silk_RSHIFT(lz, 1);
   1a272:	ea4f 0e6e 	mov.w	lr, lr, asr #1
        y = 32768;
   1a276:	bf18      	it	ne
   1a278:	f44f 4700 	movne.w	r7, #32768	; 0x8000
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   1a27c:	ebcc 0c8c 	rsb	ip, ip, ip, lsl #2
    y >>= silk_RSHIFT(lz, 1);
   1a280:	fa47 f70e 	asr.w	r7, r7, lr
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   1a284:	fa1f fc8c 	uxth.w	ip, ip
   1a288:	fb07 fc0c 	mul.w	ip, r7, ip
   1a28c:	eb07 4c2c 	add.w	ip, r7, ip, asr #16
   1a290:	fa0c f202 	lsl.w	r2, ip, r2
   1a294:	1b12      	subs	r2, r2, r4
   1a296:	b297      	uxth	r7, r2
   1a298:	1412      	asrs	r2, r2, #16
   1a29a:	fb03 f707 	mul.w	r7, r3, r7
   1a29e:	fb03 f202 	mul.w	r2, r3, r2
   1a2a2:	eb02 4227 	add.w	r2, r2, r7, asr #16
   1a2a6:	4422      	add	r2, r4
        smooth_coef_Q16 );

    /* Ratio of smoothed residual and mid norms */
    *ratio_Q14 = silk_DIV32_varQ( mid_res_amp_Q0[ 1 ], silk_max( mid_res_amp_Q0[ 0 ], 1 ), 14 );
   1a2a8:	2901      	cmp	r1, #1
   1a2aa:	bfb8      	it	lt
   1a2ac:	2101      	movlt	r1, #1
    mid_res_amp_Q0[ 1 ] = silk_SMLAWB( mid_res_amp_Q0[ 1 ], silk_LSHIFT( silk_SQRT_APPROX( nrgy ), scale ) - mid_res_amp_Q0[ 1 ],
   1a2ae:	606a      	str	r2, [r5, #4]
   1a2b0:	2a00      	cmp	r2, #0
   1a2b2:	d04b      	beq.n	1a34c <silk_stereo_find_predictor+0x2a8>
    a_headrm = silk_CLZ32( silk_abs(a32) ) - 1;
   1a2b4:	ea82 77e2 	eor.w	r7, r2, r2, asr #31
   1a2b8:	eba7 77e2 	sub.w	r7, r7, r2, asr #31
   1a2bc:	fab7 f787 	clz	r7, r7
   1a2c0:	1e7c      	subs	r4, r7, #1
   1a2c2:	371c      	adds	r7, #28
   1a2c4:	fab1 fc81 	clz	ip, r1
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
   1a2c8:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
    a32_nrm = silk_LSHIFT(a32, a_headrm);                                       /* Q: a_headrm                  */
   1a2cc:	40a2      	lsls	r2, r4
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                  */
   1a2ce:	fa01 f40c 	lsl.w	r4, r1, ip
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1a2d2:	1421      	asrs	r1, r4, #16
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1a2d4:	b295      	uxth	r5, r2
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1a2d6:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
   1a2da:	fb93 f3f1 	sdiv	r3, r3, r1
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1a2de:	1411      	asrs	r1, r2, #16
   1a2e0:	b21b      	sxth	r3, r3
   1a2e2:	fb03 f505 	mul.w	r5, r3, r5
   1a2e6:	fb03 f101 	mul.w	r1, r3, r1
   1a2ea:	eb01 4125 	add.w	r1, r1, r5, asr #16
    a32_nrm = silk_SUB32_ovflw(a32_nrm, silk_LSHIFT_ovflw( silk_SMMUL(b32_nrm, result), 3 ));  /* Q: a_headrm   */
   1a2ee:	fb84 4501 	smull	r4, r5, r4, r1
   1a2f2:	eba2 02c5 	sub.w	r2, r2, r5, lsl #3
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1a2f6:	b294      	uxth	r4, r2
   1a2f8:	1412      	asrs	r2, r2, #16
   1a2fa:	fb03 f404 	mul.w	r4, r3, r4
   1a2fe:	fb03 f302 	mul.w	r3, r3, r2
   1a302:	eb03 4324 	add.w	r3, r3, r4, asr #16
    lshift = 29 + a_headrm - b_headrm - Qres;
   1a306:	eba7 020c 	sub.w	r2, r7, ip
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1a30a:	440b      	add	r3, r1
    if( lshift < 0 ) {
   1a30c:	f1b2 010e 	subs.w	r1, r2, #14
   1a310:	d423      	bmi.n	1a35a <silk_stereo_find_predictor+0x2b6>
        if( lshift < 32){
   1a312:	291f      	cmp	r1, #31
   1a314:	dc6b      	bgt.n	1a3ee <silk_stereo_find_predictor+0x34a>
            return silk_RSHIFT(result, lshift);
   1a316:	410b      	asrs	r3, r1
    *ratio_Q14 = silk_LIMIT( *ratio_Q14, 0, 32767 );
   1a318:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1a31c:	db2e      	blt.n	1a37c <silk_stereo_find_predictor+0x2d8>
   1a31e:	f647 73ff 	movw	r3, #32767	; 0x7fff
   1a322:	6033      	str	r3, [r6, #0]

    return pred_Q13;
}
   1a324:	b004      	add	sp, #16
   1a326:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1a32a:	211f      	movs	r1, #31
   1a32c:	f04f 0e3c 	mov.w	lr, #60	; 0x3c
    a32_nrm = silk_LSHIFT(a32, a_headrm);                                       /* Q: a_headrm                  */
   1a330:	fa00 f101 	lsl.w	r1, r0, r1
   1a334:	2f00      	cmp	r7, #0
   1a336:	f47f aef8 	bne.w	1a12a <silk_stereo_find_predictor+0x86>
   1a33a:	f04f 0a1f 	mov.w	sl, #31
   1a33e:	e6fc      	b.n	1a13a <silk_stereo_find_predictor+0x96>
        if( lshift < 32){
   1a340:	f04f 0c00 	mov.w	ip, #0
   1a344:	46e6      	mov	lr, ip
   1a346:	4663      	mov	r3, ip
   1a348:	4660      	mov	r0, ip
   1a34a:	e73a      	b.n	1a1c2 <silk_stereo_find_predictor+0x11e>
   1a34c:	273c      	movs	r7, #60	; 0x3c
   1a34e:	241f      	movs	r4, #31
   1a350:	e7b8      	b.n	1a2c4 <silk_stereo_find_predictor+0x220>
    if( x <= 0 ) {
   1a352:	2400      	movs	r4, #0
   1a354:	e762      	b.n	1a21c <silk_stereo_find_predictor+0x178>
   1a356:	2200      	movs	r2, #0
   1a358:	e79c      	b.n	1a294 <silk_stereo_find_predictor+0x1f0>
        return silk_LSHIFT_SAT32(result, -lshift);
   1a35a:	f1c2 020e 	rsb	r2, r2, #14
   1a35e:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
   1a362:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
   1a366:	4111      	asrs	r1, r2
   1a368:	4114      	asrs	r4, r2
   1a36a:	42a1      	cmp	r1, r4
   1a36c:	dd48      	ble.n	1a400 <silk_stereo_find_predictor+0x35c>
   1a36e:	428b      	cmp	r3, r1
   1a370:	dd4e      	ble.n	1a410 <silk_stereo_find_predictor+0x36c>
   1a372:	460b      	mov	r3, r1
   1a374:	4093      	lsls	r3, r2
    *ratio_Q14 = silk_LIMIT( *ratio_Q14, 0, 32767 );
   1a376:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1a37a:	dad0      	bge.n	1a31e <silk_stereo_find_predictor+0x27a>
   1a37c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   1a380:	6033      	str	r3, [r6, #0]
}
   1a382:	b004      	add	sp, #16
   1a384:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1a388:	f1ce 0e0d 	rsb	lr, lr, #13
   1a38c:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   1a390:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
   1a394:	fa42 f20e 	asr.w	r2, r2, lr
   1a398:	fa41 f10e 	asr.w	r1, r1, lr
   1a39c:	428a      	cmp	r2, r1
   1a39e:	dc2b      	bgt.n	1a3f8 <silk_stereo_find_predictor+0x354>
   1a3a0:	428b      	cmp	r3, r1
   1a3a2:	dd31      	ble.n	1a408 <silk_stereo_find_predictor+0x364>
   1a3a4:	460b      	mov	r3, r1
   1a3a6:	fa03 f30e 	lsl.w	r3, r3, lr
   1a3aa:	e6f0      	b.n	1a18e <silk_stereo_find_predictor+0xea>
   1a3ac:	481e      	ldr	r0, [pc, #120]	; (1a428 <silk_stereo_find_predictor+0x384>)
   1a3ae:	4298      	cmp	r0, r3
   1a3b0:	bfb8      	it	lt
   1a3b2:	4618      	movlt	r0, r3
   1a3b4:	fa1f f980 	uxth.w	r9, r0
   1a3b8:	1403      	asrs	r3, r0, #16
   1a3ba:	fb00 f909 	mul.w	r9, r0, r9
   1a3be:	fb00 f303 	mul.w	r3, r0, r3
   1a3c2:	eb03 4329 	add.w	r3, r3, r9, asr #16
   1a3c6:	fb0c f903 	mul.w	r9, ip, r3
   1a3ca:	fb0e fa00 	mul.w	sl, lr, r0
   1a3ce:	fb02 fc03 	mul.w	ip, r2, r3
   1a3d2:	fb01 fe00 	mul.w	lr, r1, r0
   1a3d6:	eb0e 4e2a 	add.w	lr, lr, sl, asr #16
   1a3da:	eb0c 4c29 	add.w	ip, ip, r9, asr #16
   1a3de:	2b00      	cmp	r3, #0
   1a3e0:	ea4f 1e0e 	mov.w	lr, lr, lsl #4
   1a3e4:	ea4f 1c8c 	mov.w	ip, ip, lsl #6
   1a3e8:	bfb8      	it	lt
   1a3ea:	425b      	neglt	r3, r3
   1a3ec:	e6e9      	b.n	1a1c2 <silk_stereo_find_predictor+0x11e>
        if( lshift < 32){
   1a3ee:	2300      	movs	r3, #0
    *ratio_Q14 = silk_LIMIT( *ratio_Q14, 0, 32767 );
   1a3f0:	6033      	str	r3, [r6, #0]
}
   1a3f2:	b004      	add	sp, #16
   1a3f4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        return silk_LSHIFT_SAT32(result, -lshift);
   1a3f8:	4293      	cmp	r3, r2
   1a3fa:	dd0d      	ble.n	1a418 <silk_stereo_find_predictor+0x374>
   1a3fc:	4613      	mov	r3, r2
   1a3fe:	e7d2      	b.n	1a3a6 <silk_stereo_find_predictor+0x302>
   1a400:	42a3      	cmp	r3, r4
   1a402:	dd0d      	ble.n	1a420 <silk_stereo_find_predictor+0x37c>
   1a404:	4623      	mov	r3, r4
   1a406:	e7b5      	b.n	1a374 <silk_stereo_find_predictor+0x2d0>
   1a408:	4293      	cmp	r3, r2
   1a40a:	bfb8      	it	lt
   1a40c:	4613      	movlt	r3, r2
   1a40e:	e7ca      	b.n	1a3a6 <silk_stereo_find_predictor+0x302>
   1a410:	42a3      	cmp	r3, r4
   1a412:	bfb8      	it	lt
   1a414:	4623      	movlt	r3, r4
   1a416:	e7ad      	b.n	1a374 <silk_stereo_find_predictor+0x2d0>
   1a418:	428b      	cmp	r3, r1
   1a41a:	bfb8      	it	lt
   1a41c:	460b      	movlt	r3, r1
   1a41e:	e7c2      	b.n	1a3a6 <silk_stereo_find_predictor+0x302>
   1a420:	428b      	cmp	r3, r1
   1a422:	bfb8      	it	lt
   1a424:	460b      	movlt	r3, r1
   1a426:	e7a5      	b.n	1a374 <silk_stereo_find_predictor+0x2d0>
   1a428:	ffffc000 	.word	0xffffc000

0001a42c <silk_stereo_quant_pred>:
/* Quantize mid/side predictors */
void silk_stereo_quant_pred(
    opus_int32                  pred_Q13[],                     /* I/O  Predictors (out: quantized)                 */
    opus_int8                   ix[ 2 ][ 3 ]                    /* O    Quantization indices                        */
)
{
   1a42c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1a430:	4b48      	ldr	r3, [pc, #288]	; (1a554 <silk_stereo_quant_pred+0x128>)
   1a432:	f9b3 3000 	ldrsh.w	r3, [r3]
   1a436:	b085      	sub	sp, #20
   1a438:	e9cd 3002 	strd	r3, r0, [sp, #8]
    opus_int   i, j, n;
    opus_int32 low_Q13, step_Q13, lvl_Q13, err_min_Q13, err_Q13, quant_pred_Q13 = 0;
   1a43c:	f04f 0800 	mov.w	r8, #0
   1a440:	1d8b      	adds	r3, r1, #6
{
   1a442:	468b      	mov	fp, r1
   1a444:	9301      	str	r3, [sp, #4]
   1a446:	4644      	mov	r4, r8
   1a448:	f8df a108 	ldr.w	sl, [pc, #264]	; 1a554 <silk_stereo_quant_pred+0x128>
   1a44c:	9f02      	ldr	r7, [sp, #8]
   1a44e:	2600      	movs	r6, #0

    /* Quantize */
    for( n = 0; n < 2; n++ ) {
        /* Brute-force search over quantization levels */
        err_min_Q13 = silk_int32_MAX;
   1a450:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
        for( i = 0; i < STEREO_QUANT_TAB_SIZE - 1; i++ ) {
            low_Q13 = silk_stereo_pred_quant_Q13[ i ];
            step_Q13 = silk_SMULWB( silk_stereo_pred_quant_Q13[ i + 1 ] - low_Q13,
   1a454:	f641 1e9a 	movw	lr, #6554	; 0x199a
            low_Q13 = silk_stereo_pred_quant_Q13[ i ];
   1a458:	46b8      	mov	r8, r7
            step_Q13 = silk_SMULWB( silk_stereo_pred_quant_Q13[ i + 1 ] - low_Q13,
   1a45a:	f93a 7f02 	ldrsh.w	r7, [sl, #2]!
                SILK_FIX_CONST( 0.5 / STEREO_QUANT_SUB_STEPS, 16 ) );
            for( j = 0; j < STEREO_QUANT_SUB_STEPS; j++ ) {
                lvl_Q13 = silk_SMLABB( low_Q13, step_Q13, 2 * j + 1 );
                err_Q13 = silk_abs( pred_Q13[ n ] - lvl_Q13 );
   1a45e:	6802      	ldr	r2, [r0, #0]
            step_Q13 = silk_SMULWB( silk_stereo_pred_quant_Q13[ i + 1 ] - low_Q13,
   1a460:	eba7 0508 	sub.w	r5, r7, r8
   1a464:	142b      	asrs	r3, r5, #16
   1a466:	fa1f f985 	uxth.w	r9, r5
   1a46a:	fb0e f509 	mul.w	r5, lr, r9
   1a46e:	fb0e f303 	mul.w	r3, lr, r3
   1a472:	eb03 4325 	add.w	r3, r3, r5, asr #16
                lvl_Q13 = silk_SMLABB( low_Q13, step_Q13, 2 * j + 1 );
   1a476:	005d      	lsls	r5, r3, #1
   1a478:	4443      	add	r3, r8
                err_Q13 = silk_abs( pred_Q13[ n ] - lvl_Q13 );
   1a47a:	1ad2      	subs	r2, r2, r3
   1a47c:	2a00      	cmp	r2, #0
   1a47e:	bfb8      	it	lt
   1a480:	4252      	neglt	r2, r2
                if( err_Q13 < err_min_Q13 ) {
   1a482:	428a      	cmp	r2, r1
                    err_min_Q13 = err_Q13;
                    quant_pred_Q13 = lvl_Q13;
                    ix[ n ][ 0 ] = i;
   1a484:	fa4f fc86 	sxtb.w	ip, r6
   1a488:	f106 0601 	add.w	r6, r6, #1
                if( err_Q13 < err_min_Q13 ) {
   1a48c:	da59      	bge.n	1a542 <silk_stereo_quant_pred+0x116>
                    ix[ n ][ 1 ] = j;
   1a48e:	f04f 0100 	mov.w	r1, #0
                    ix[ n ][ 0 ] = i;
   1a492:	f88b c000 	strb.w	ip, [fp]
                    ix[ n ][ 1 ] = j;
   1a496:	f88b 1001 	strb.w	r1, [fp, #1]
                err_Q13 = silk_abs( pred_Q13[ n ] - lvl_Q13 );
   1a49a:	6801      	ldr	r1, [r0, #0]
                lvl_Q13 = silk_SMLABB( low_Q13, step_Q13, 2 * j + 1 );
   1a49c:	195c      	adds	r4, r3, r5
                err_Q13 = silk_abs( pred_Q13[ n ] - lvl_Q13 );
   1a49e:	1b09      	subs	r1, r1, r4
   1a4a0:	2900      	cmp	r1, #0
   1a4a2:	bfb8      	it	lt
   1a4a4:	4249      	neglt	r1, r1
                lvl_Q13 = silk_SMLABB( low_Q13, step_Q13, 2 * j + 1 );
   1a4a6:	eb04 0905 	add.w	r9, r4, r5
                if( err_Q13 < err_min_Q13 ) {
   1a4aa:	428a      	cmp	r2, r1
                lvl_Q13 = silk_SMLABB( low_Q13, step_Q13, 2 * j + 1 );
   1a4ac:	eb09 0805 	add.w	r8, r9, r5
                if( err_Q13 < err_min_Q13 ) {
   1a4b0:	dd4a      	ble.n	1a548 <silk_stereo_quant_pred+0x11c>
                    ix[ n ][ 1 ] = j;
   1a4b2:	f04f 0301 	mov.w	r3, #1
   1a4b6:	f88b 3001 	strb.w	r3, [fp, #1]
                err_Q13 = silk_abs( pred_Q13[ n ] - lvl_Q13 );
   1a4ba:	6803      	ldr	r3, [r0, #0]
   1a4bc:	eba3 0309 	sub.w	r3, r3, r9
   1a4c0:	2b00      	cmp	r3, #0
   1a4c2:	bfb8      	it	lt
   1a4c4:	425b      	neglt	r3, r3
                if( err_Q13 < err_min_Q13 ) {
   1a4c6:	4299      	cmp	r1, r3
   1a4c8:	dd1f      	ble.n	1a50a <silk_stereo_quant_pred+0xde>
                    ix[ n ][ 1 ] = j;
   1a4ca:	f04f 0202 	mov.w	r2, #2
   1a4ce:	f88b 2001 	strb.w	r2, [fp, #1]
                err_Q13 = silk_abs( pred_Q13[ n ] - lvl_Q13 );
   1a4d2:	6802      	ldr	r2, [r0, #0]
   1a4d4:	eba2 0208 	sub.w	r2, r2, r8
   1a4d8:	2a00      	cmp	r2, #0
   1a4da:	bfb8      	it	lt
   1a4dc:	4252      	neglt	r2, r2
                if( err_Q13 < err_min_Q13 ) {
   1a4de:	4293      	cmp	r3, r2
                lvl_Q13 = silk_SMLABB( low_Q13, step_Q13, 2 * j + 1 );
   1a4e0:	eb05 0408 	add.w	r4, r5, r8
                if( err_Q13 < err_min_Q13 ) {
   1a4e4:	dd32      	ble.n	1a54c <silk_stereo_quant_pred+0x120>
                    ix[ n ][ 1 ] = j;
   1a4e6:	f04f 0303 	mov.w	r3, #3
   1a4ea:	f88b 3001 	strb.w	r3, [fp, #1]
                err_Q13 = silk_abs( pred_Q13[ n ] - lvl_Q13 );
   1a4ee:	6803      	ldr	r3, [r0, #0]
   1a4f0:	1b1b      	subs	r3, r3, r4
   1a4f2:	ea83 71e3 	eor.w	r1, r3, r3, asr #31
   1a4f6:	eba1 71e3 	sub.w	r1, r1, r3, asr #31
                if( err_Q13 < err_min_Q13 ) {
   1a4fa:	428a      	cmp	r2, r1
   1a4fc:	dd28      	ble.n	1a550 <silk_stereo_quant_pred+0x124>
                    ix[ n ][ 1 ] = j;
   1a4fe:	f04f 0304 	mov.w	r3, #4
        for( i = 0; i < STEREO_QUANT_TAB_SIZE - 1; i++ ) {
   1a502:	2e0f      	cmp	r6, #15
                    ix[ n ][ 1 ] = j;
   1a504:	f88b 3001 	strb.w	r3, [fp, #1]
        for( i = 0; i < STEREO_QUANT_TAB_SIZE - 1; i++ ) {
   1a508:	d1a6      	bne.n	1a458 <silk_stereo_quant_pred+0x2c>
                    goto done;
                }
            }
        }
        done:
        ix[ n ][ 2 ]  = silk_DIV32_16( ix[ n ][ 0 ], 3 );
   1a50a:	4b13      	ldr	r3, [pc, #76]	; (1a558 <silk_stereo_quant_pred+0x12c>)
   1a50c:	fb83 230c 	smull	r2, r3, r3, ip
   1a510:	eba3 73ec 	sub.w	r3, r3, ip, asr #31
   1a514:	b25b      	sxtb	r3, r3
        ix[ n ][ 0 ] -= ix[ n ][ 2 ] * 3;
   1a516:	ebc3 1283 	rsb	r2, r3, r3, lsl #6
   1a51a:	eb03 0282 	add.w	r2, r3, r2, lsl #2
   1a51e:	4494      	add	ip, r2
        ix[ n ][ 2 ]  = silk_DIV32_16( ix[ n ][ 0 ], 3 );
   1a520:	f88b 3002 	strb.w	r3, [fp, #2]
        ix[ n ][ 0 ] -= ix[ n ][ 2 ] * 3;
   1a524:	f80b cb03 	strb.w	ip, [fp], #3
    for( n = 0; n < 2; n++ ) {
   1a528:	9b01      	ldr	r3, [sp, #4]
        pred_Q13[ n ] = quant_pred_Q13;
   1a52a:	f840 4b04 	str.w	r4, [r0], #4
    for( n = 0; n < 2; n++ ) {
   1a52e:	455b      	cmp	r3, fp
   1a530:	d18a      	bne.n	1a448 <silk_stereo_quant_pred+0x1c>
    }

    /* Subtract second from first predictor (helps when actually applying these) */
    pred_Q13[ 0 ] -= pred_Q13[ 1 ];
   1a532:	9903      	ldr	r1, [sp, #12]
   1a534:	680b      	ldr	r3, [r1, #0]
   1a536:	684a      	ldr	r2, [r1, #4]
   1a538:	1a9b      	subs	r3, r3, r2
   1a53a:	600b      	str	r3, [r1, #0]
}
   1a53c:	b005      	add	sp, #20
   1a53e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1a542:	f99b c000 	ldrsb.w	ip, [fp]
   1a546:	e7e0      	b.n	1a50a <silk_stereo_quant_pred+0xde>
                lvl_Q13 = silk_SMLABB( low_Q13, step_Q13, 2 * j + 1 );
   1a548:	461c      	mov	r4, r3
   1a54a:	e7de      	b.n	1a50a <silk_stereo_quant_pred+0xde>
   1a54c:	464c      	mov	r4, r9
   1a54e:	e7dc      	b.n	1a50a <silk_stereo_quant_pred+0xde>
   1a550:	4644      	mov	r4, r8
   1a552:	e7da      	b.n	1a50a <silk_stereo_quant_pred+0xde>
   1a554:	00036d18 	.word	0x00036d18
   1a558:	55555556 	.word	0x55555556

0001a55c <silk_LPC_fit>:
    opus_int32                    *a_QIN,             /* I/O  Input signal                                                */
    const opus_int              QOUT,               /* I    Input Q domain                                              */
    const opus_int              QIN,                /* I    Input Q domain                                              */
    const opus_int              d                   /* I    Filter order                                                */
)
{
   1a55c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1a560:	9c0a      	ldr	r4, [sp, #40]	; 0x28
        }
        maxabs = silk_RSHIFT_ROUND( maxabs, QIN - QOUT );

        if( maxabs > silk_int16_MAX ) {
            /* Reduce magnitude of prediction coefficients */
            maxabs = silk_min( maxabs, 163838 );  /* ( silk_int32_MAX >> 14 ) + silk_int16_MAX = 163838 */
   1a562:	f8df 9174 	ldr.w	r9, [pc, #372]	; 1a6d8 <silk_LPC_fit+0x17c>
        maxabs = silk_RSHIFT_ROUND( maxabs, QIN - QOUT );
   1a566:	eba3 0802 	sub.w	r8, r3, r2
{
   1a56a:	4607      	mov	r7, r0
   1a56c:	460d      	mov	r5, r1
        maxabs = silk_RSHIFT_ROUND( maxabs, QIN - QOUT );
   1a56e:	f108 3aff 	add.w	sl, r8, #4294967295	; 0xffffffff
   1a572:	f04f 0b0a 	mov.w	fp, #10
    opus_int    i, k, idx = 0;
   1a576:	2600      	movs	r6, #0
        for( k = 0; k < d; k++ ) {
   1a578:	2c00      	cmp	r4, #0
        maxabs = 0;
   1a57a:	f04f 0200 	mov.w	r2, #0
        for( k = 0; k < d; k++ ) {
   1a57e:	dd0f      	ble.n	1a5a0 <silk_LPC_fit+0x44>
   1a580:	4611      	mov	r1, r2
   1a582:	1f28      	subs	r0, r5, #4
            absval = silk_abs( a_QIN[k] );
   1a584:	f850 3f04 	ldr.w	r3, [r0, #4]!
   1a588:	2b00      	cmp	r3, #0
   1a58a:	bfb8      	it	lt
   1a58c:	425b      	neglt	r3, r3
            if( absval > maxabs ) {
   1a58e:	429a      	cmp	r2, r3
   1a590:	bfb8      	it	lt
   1a592:	460e      	movlt	r6, r1
        for( k = 0; k < d; k++ ) {
   1a594:	f101 0101 	add.w	r1, r1, #1
            if( absval > maxabs ) {
   1a598:	bfb8      	it	lt
   1a59a:	461a      	movlt	r2, r3
        for( k = 0; k < d; k++ ) {
   1a59c:	428c      	cmp	r4, r1
   1a59e:	d1f1      	bne.n	1a584 <silk_LPC_fit+0x28>
        maxabs = silk_RSHIFT_ROUND( maxabs, QIN - QOUT );
   1a5a0:	f1b8 0f01 	cmp.w	r8, #1
   1a5a4:	d04a      	beq.n	1a63c <silk_LPC_fit+0xe0>
   1a5a6:	fa42 f20a 	asr.w	r2, r2, sl
   1a5aa:	3201      	adds	r2, #1
   1a5ac:	1052      	asrs	r2, r2, #1
        if( maxabs > silk_int16_MAX ) {
   1a5ae:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
   1a5b2:	db4a      	blt.n	1a64a <silk_LPC_fit+0xee>
            maxabs = silk_min( maxabs, 163838 );  /* ( silk_int32_MAX >> 14 ) + silk_int16_MAX = 163838 */
   1a5b4:	454a      	cmp	r2, r9
   1a5b6:	bfa8      	it	ge
   1a5b8:	464a      	movge	r2, r9
            chirp_Q16 = SILK_FIX_CONST( 0.999, 16 ) - silk_DIV32( silk_LSHIFT( maxabs - silk_int16_MAX, 14 ),
   1a5ba:	f5a2 43ff 	sub.w	r3, r2, #32640	; 0x7f80
   1a5be:	3b7f      	subs	r3, #127	; 0x7f
   1a5c0:	fb06 2202 	mla	r2, r6, r2, r2
   1a5c4:	039b      	lsls	r3, r3, #14
   1a5c6:	1092      	asrs	r2, r2, #2
   1a5c8:	fb93 f2f2 	sdiv	r2, r3, r2
                                        silk_RSHIFT32( silk_MUL( maxabs, idx + 1), 2 ) );
            silk_bwexpander_32( a_QIN, d, chirp_Q16 );
   1a5cc:	f5c2 427f 	rsb	r2, r2, #65280	; 0xff00
   1a5d0:	32be      	adds	r2, #190	; 0xbe
   1a5d2:	4621      	mov	r1, r4
   1a5d4:	4628      	mov	r0, r5
   1a5d6:	f7fd f973 	bl	178c0 <silk_bwexpander_32>
    for( i = 0; i < 10; i++ ) {
   1a5da:	f1bb 0b01 	subs.w	fp, fp, #1
   1a5de:	d1cb      	bne.n	1a578 <silk_LPC_fit+0x1c>
        }
    }

    if( i == 10 ) {
        /* Reached the last iteration, clip the coefficients */
        for( k = 0; k < d; k++ ) {
   1a5e0:	2c00      	cmp	r4, #0
   1a5e2:	dd29      	ble.n	1a638 <silk_LPC_fit+0xdc>
   1a5e4:	f1b8 0f01 	cmp.w	r8, #1
   1a5e8:	f1a5 0504 	sub.w	r5, r5, #4
   1a5ec:	d052      	beq.n	1a694 <silk_LPC_fit+0x138>
            a_QOUT[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( a_QIN[ k ], QIN - QOUT ) );
   1a5ee:	4e39      	ldr	r6, [pc, #228]	; (1a6d4 <silk_LPC_fit+0x178>)
   1a5f0:	eb05 0484 	add.w	r4, r5, r4, lsl #2
   1a5f4:	3f02      	subs	r7, #2
   1a5f6:	f108 31ff 	add.w	r1, r8, #4294967295	; 0xffffffff
   1a5fa:	e00b      	b.n	1a614 <silk_LPC_fit+0xb8>
   1a5fc:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   1a600:	db45      	blt.n	1a68e <silk_LPC_fit+0x132>
   1a602:	b218      	sxth	r0, r3
   1a604:	461a      	mov	r2, r3
            a_QIN[ k ] = silk_LSHIFT( (opus_int32)a_QOUT[ k ], QIN - QOUT );
   1a606:	fa02 f208 	lsl.w	r2, r2, r8
        for( k = 0; k < d; k++ ) {
   1a60a:	42ac      	cmp	r4, r5
            a_QOUT[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( a_QIN[ k ], QIN - QOUT ) );
   1a60c:	f827 0f02 	strh.w	r0, [r7, #2]!
            a_QIN[ k ] = silk_LSHIFT( (opus_int32)a_QOUT[ k ], QIN - QOUT );
   1a610:	602a      	str	r2, [r5, #0]
        for( k = 0; k < d; k++ ) {
   1a612:	d011      	beq.n	1a638 <silk_LPC_fit+0xdc>
            a_QOUT[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( a_QIN[ k ], QIN - QOUT ) );
   1a614:	f855 3f04 	ldr.w	r3, [r5, #4]!
   1a618:	410b      	asrs	r3, r1
   1a61a:	3301      	adds	r3, #1
   1a61c:	105b      	asrs	r3, r3, #1
   1a61e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1a622:	f647 72ff 	movw	r2, #32767	; 0x7fff
   1a626:	dbe9      	blt.n	1a5fc <silk_LPC_fit+0xa0>
   1a628:	4610      	mov	r0, r2
        for( k = 0; k < d; k++ ) {
   1a62a:	42ac      	cmp	r4, r5
            a_QIN[ k ] = silk_LSHIFT( (opus_int32)a_QOUT[ k ], QIN - QOUT );
   1a62c:	fa02 f208 	lsl.w	r2, r2, r8
            a_QOUT[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( a_QIN[ k ], QIN - QOUT ) );
   1a630:	f827 0f02 	strh.w	r0, [r7, #2]!
            a_QIN[ k ] = silk_LSHIFT( (opus_int32)a_QOUT[ k ], QIN - QOUT );
   1a634:	602a      	str	r2, [r5, #0]
        for( k = 0; k < d; k++ ) {
   1a636:	d1ed      	bne.n	1a614 <silk_LPC_fit+0xb8>
    } else {
        for( k = 0; k < d; k++ ) {
            a_QOUT[ k ] = (opus_int16)silk_RSHIFT_ROUND( a_QIN[ k ], QIN - QOUT );
        }
    }
}
   1a638:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        maxabs = silk_RSHIFT_ROUND( maxabs, QIN - QOUT );
   1a63c:	f002 0301 	and.w	r3, r2, #1
   1a640:	eb03 0262 	add.w	r2, r3, r2, asr #1
        if( maxabs > silk_int16_MAX ) {
   1a644:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
   1a648:	dab4      	bge.n	1a5b4 <silk_LPC_fit+0x58>
        for( k = 0; k < d; k++ ) {
   1a64a:	2c00      	cmp	r4, #0
   1a64c:	ddf4      	ble.n	1a638 <silk_LPC_fit+0xdc>
   1a64e:	3d04      	subs	r5, #4
   1a650:	f1b8 0f01 	cmp.w	r8, #1
   1a654:	eb05 0484 	add.w	r4, r5, r4, lsl #2
   1a658:	f1a7 0702 	sub.w	r7, r7, #2
   1a65c:	d00c      	beq.n	1a678 <silk_LPC_fit+0x11c>
   1a65e:	f108 31ff 	add.w	r1, r8, #4294967295	; 0xffffffff
            a_QOUT[ k ] = (opus_int16)silk_RSHIFT_ROUND( a_QIN[ k ], QIN - QOUT );
   1a662:	f855 3f04 	ldr.w	r3, [r5, #4]!
   1a666:	410b      	asrs	r3, r1
   1a668:	3301      	adds	r3, #1
   1a66a:	105b      	asrs	r3, r3, #1
        for( k = 0; k < d; k++ ) {
   1a66c:	42a5      	cmp	r5, r4
            a_QOUT[ k ] = (opus_int16)silk_RSHIFT_ROUND( a_QIN[ k ], QIN - QOUT );
   1a66e:	f827 3f02 	strh.w	r3, [r7, #2]!
        for( k = 0; k < d; k++ ) {
   1a672:	d1f6      	bne.n	1a662 <silk_LPC_fit+0x106>
}
   1a674:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1a678:	f855 2f04 	ldr.w	r2, [r5, #4]!
            a_QOUT[ k ] = (opus_int16)silk_RSHIFT_ROUND( a_QIN[ k ], QIN - QOUT );
   1a67c:	f002 0301 	and.w	r3, r2, #1
   1a680:	eb03 0362 	add.w	r3, r3, r2, asr #1
        for( k = 0; k < d; k++ ) {
   1a684:	42a5      	cmp	r5, r4
            a_QOUT[ k ] = (opus_int16)silk_RSHIFT_ROUND( a_QIN[ k ], QIN - QOUT );
   1a686:	f827 3f02 	strh.w	r3, [r7, #2]!
        for( k = 0; k < d; k++ ) {
   1a68a:	d1f5      	bne.n	1a678 <silk_LPC_fit+0x11c>
   1a68c:	e7d4      	b.n	1a638 <silk_LPC_fit+0xdc>
            a_QOUT[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( a_QIN[ k ], QIN - QOUT ) );
   1a68e:	4632      	mov	r2, r6
   1a690:	4630      	mov	r0, r6
   1a692:	e7b8      	b.n	1a606 <silk_LPC_fit+0xaa>
   1a694:	490f      	ldr	r1, [pc, #60]	; (1a6d4 <silk_LPC_fit+0x178>)
   1a696:	eb05 0484 	add.w	r4, r5, r4, lsl #2
   1a69a:	3f02      	subs	r7, #2
   1a69c:	e00a      	b.n	1a6b4 <silk_LPC_fit+0x158>
   1a69e:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   1a6a2:	b21b      	sxth	r3, r3
   1a6a4:	db13      	blt.n	1a6ce <silk_LPC_fit+0x172>
   1a6a6:	461a      	mov	r2, r3
            a_QIN[ k ] = silk_LSHIFT( (opus_int32)a_QOUT[ k ], QIN - QOUT );
   1a6a8:	0052      	lsls	r2, r2, #1
        for( k = 0; k < d; k++ ) {
   1a6aa:	42a5      	cmp	r5, r4
            a_QOUT[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( a_QIN[ k ], QIN - QOUT ) );
   1a6ac:	f827 3f02 	strh.w	r3, [r7, #2]!
            a_QIN[ k ] = silk_LSHIFT( (opus_int32)a_QOUT[ k ], QIN - QOUT );
   1a6b0:	602a      	str	r2, [r5, #0]
        for( k = 0; k < d; k++ ) {
   1a6b2:	d0c1      	beq.n	1a638 <silk_LPC_fit+0xdc>
   1a6b4:	f855 2f04 	ldr.w	r2, [r5, #4]!
            a_QOUT[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( a_QIN[ k ], QIN - QOUT ) );
   1a6b8:	f002 0301 	and.w	r3, r2, #1
   1a6bc:	eb03 0362 	add.w	r3, r3, r2, asr #1
   1a6c0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1a6c4:	f647 72ff 	movw	r2, #32767	; 0x7fff
   1a6c8:	dbe9      	blt.n	1a69e <silk_LPC_fit+0x142>
   1a6ca:	4613      	mov	r3, r2
   1a6cc:	e7ec      	b.n	1a6a8 <silk_LPC_fit+0x14c>
   1a6ce:	460a      	mov	r2, r1
   1a6d0:	460b      	mov	r3, r1
   1a6d2:	e7e9      	b.n	1a6a8 <silk_LPC_fit+0x14c>
   1a6d4:	ffff8000 	.word	0xffff8000
   1a6d8:	00027ffe 	.word	0x00027ffe

0001a6dc <silk_LTP_analysis_filter_FIX>:
    const opus_int32                invGains_Q16[ MAX_NB_SUBFR ],           /* I    Inverse quantization gains, one for each subframe                           */
    const opus_int                  subfr_length,                           /* I    Length of each subframe                                                     */
    const opus_int                  nb_subfr,                               /* I    Number of subframes                                                         */
    const opus_int                  pre_length                              /* I    Length of the preceding samples starting at &x[0] for each subframe         */
)
{
   1a6dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1a6e0:	b08b      	sub	sp, #44	; 0x2c
   1a6e2:	e9dd 5415 	ldrd	r5, r4, [sp, #84]	; 0x54
    opus_int     k, i;
    opus_int32   LTP_est;

    x_ptr = x;
    LTP_res_ptr = LTP_res;
    for( k = 0; k < nb_subfr; k++ ) {
   1a6e6:	2c00      	cmp	r4, #0
{
   1a6e8:	9101      	str	r1, [sp, #4]
    for( k = 0; k < nb_subfr; k++ ) {
   1a6ea:	dd78      	ble.n	1a7de <silk_LTP_analysis_filter_FIX+0x102>
        Btmp_Q14[ 2 ] = LTPCoef_Q14[ k * LTP_ORDER + 2 ];
        Btmp_Q14[ 3 ] = LTPCoef_Q14[ k * LTP_ORDER + 3 ];
        Btmp_Q14[ 4 ] = LTPCoef_Q14[ k * LTP_ORDER + 4 ];

        /* LTP analysis FIR filter */
        for( i = 0; i < subfr_length + pre_length; i++ ) {
   1a6ec:	9917      	ldr	r1, [sp, #92]	; 0x5c
   1a6ee:	1869      	adds	r1, r5, r1
            x_lag_ptr++;
        }

        /* Update pointers */
        LTP_res_ptr += subfr_length + pre_length;
        x_ptr       += subfr_length;
   1a6f0:	006d      	lsls	r5, r5, #1
   1a6f2:	9507      	str	r5, [sp, #28]
   1a6f4:	2900      	cmp	r1, #0
        LTP_res_ptr += subfr_length + pre_length;
   1a6f6:	ea4f 0541 	mov.w	r5, r1, lsl #1
   1a6fa:	9506      	str	r5, [sp, #24]
   1a6fc:	dd6f      	ble.n	1a7de <silk_LTP_analysis_filter_FIX+0x102>
   1a6fe:	3b04      	subs	r3, #4
   1a700:	9304      	str	r3, [sp, #16]
   1a702:	eb03 0384 	add.w	r3, r3, r4, lsl #2
   1a706:	9308      	str	r3, [sp, #32]
   1a708:	1e83      	subs	r3, r0, #2
   1a70a:	9302      	str	r3, [sp, #8]
   1a70c:	9b14      	ldr	r3, [sp, #80]	; 0x50
   1a70e:	9203      	str	r2, [sp, #12]
   1a710:	3b04      	subs	r3, #4
   1a712:	9305      	str	r3, [sp, #20]
   1a714:	1eab      	subs	r3, r5, #2
   1a716:	9309      	str	r3, [sp, #36]	; 0x24
            LTP_res_ptr[ i ] = silk_SMULWB( invGains_Q16[ k ], LTP_res_ptr[ i ] );
   1a718:	9b05      	ldr	r3, [sp, #20]
   1a71a:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1a71c:	f853 6f04 	ldr.w	r6, [r3, #4]!
   1a720:	9305      	str	r3, [sp, #20]
        x_lag_ptr = x_ptr - pitchL[ k ];
   1a722:	9b04      	ldr	r3, [sp, #16]
            LTP_res_ptr[ i ] = silk_SMULWB( invGains_Q16[ k ], LTP_res_ptr[ i ] );
   1a724:	9d02      	ldr	r5, [sp, #8]
        x_lag_ptr = x_ptr - pitchL[ k ];
   1a726:	f853 0f04 	ldr.w	r0, [r3, #4]!
   1a72a:	9304      	str	r3, [sp, #16]
        Btmp_Q14[ 0 ] = LTPCoef_Q14[ k * LTP_ORDER ];
   1a72c:	9b03      	ldr	r3, [sp, #12]
   1a72e:	f9b3 b000 	ldrsh.w	fp, [r3]
        Btmp_Q14[ 1 ] = LTPCoef_Q14[ k * LTP_ORDER + 1 ];
   1a732:	f9b3 a002 	ldrsh.w	sl, [r3, #2]
        Btmp_Q14[ 2 ] = LTPCoef_Q14[ k * LTP_ORDER + 2 ];
   1a736:	f9b3 9004 	ldrsh.w	r9, [r3, #4]
        Btmp_Q14[ 3 ] = LTPCoef_Q14[ k * LTP_ORDER + 3 ];
   1a73a:	f9b3 8006 	ldrsh.w	r8, [r3, #6]
        Btmp_Q14[ 4 ] = LTPCoef_Q14[ k * LTP_ORDER + 4 ];
   1a73e:	f9b3 e008 	ldrsh.w	lr, [r3, #8]
        x_lag_ptr = x_ptr - pitchL[ k ];
   1a742:	9b01      	ldr	r3, [sp, #4]
            LTP_res_ptr[ i ] = silk_SMULWB( invGains_Q16[ k ], LTP_res_ptr[ i ] );
   1a744:	ea4f 4c16 	mov.w	ip, r6, lsr #16
        x_lag_ptr = x_ptr - pitchL[ k ];
   1a748:	eba3 0040 	sub.w	r0, r3, r0, lsl #1
            LTP_res_ptr[ i ] = silk_SMULWB( invGains_Q16[ k ], LTP_res_ptr[ i ] );
   1a74c:	b2b6      	uxth	r6, r6
   1a74e:	1e9c      	subs	r4, r3, #2
   1a750:	189f      	adds	r7, r3, r2
   1a752:	e00d      	b.n	1a770 <silk_LTP_analysis_filter_FIX+0x94>
            LTP_res_ptr[ i ] = (opus_int16)silk_SAT16( (opus_int32)x_ptr[ i ] - LTP_est );
   1a754:	f512 4f00 	cmn.w	r2, #32768	; 0x8000
   1a758:	b292      	uxth	r2, r2
   1a75a:	db2d      	blt.n	1a7b8 <silk_LTP_analysis_filter_FIX+0xdc>
   1a75c:	b213      	sxth	r3, r2
            LTP_res_ptr[ i ] = silk_SMULWB( invGains_Q16[ k ], LTP_res_ptr[ i ] );
   1a75e:	fb03 f306 	mul.w	r3, r3, r6
   1a762:	fb1c f202 	smulbb	r2, ip, r2
   1a766:	eb02 4223 	add.w	r2, r2, r3, asr #16
        for( i = 0; i < subfr_length + pre_length; i++ ) {
   1a76a:	42bc      	cmp	r4, r7
            LTP_res_ptr[ i ] = silk_SMULWB( invGains_Q16[ k ], LTP_res_ptr[ i ] );
   1a76c:	802a      	strh	r2, [r5, #0]
        for( i = 0; i < subfr_length + pre_length; i++ ) {
   1a76e:	d027      	beq.n	1a7c0 <silk_LTP_analysis_filter_FIX+0xe4>
            LTP_res_ptr[ i ] = x_ptr[ i ];
   1a770:	f934 3f02 	ldrsh.w	r3, [r4, #2]!
   1a774:	f825 3f02 	strh.w	r3, [r5, #2]!
   1a778:	4601      	mov	r1, r0
   1a77a:	3002      	adds	r0, #2
            LTP_est = silk_SMULBB( x_lag_ptr[ LTP_ORDER / 2 ], Btmp_Q14[ 0 ] );
   1a77c:	888a      	ldrh	r2, [r1, #4]
            LTP_est = silk_SMLABB_ovflw( LTP_est, x_lag_ptr[ 1 ], Btmp_Q14[ 1 ] );
   1a77e:	884b      	ldrh	r3, [r1, #2]
            LTP_est = silk_SMLABB_ovflw( LTP_est, x_lag_ptr[ 0 ], Btmp_Q14[ 2 ] );
   1a780:	8809      	ldrh	r1, [r1, #0]
            LTP_est = silk_SMULBB( x_lag_ptr[ LTP_ORDER / 2 ], Btmp_Q14[ 0 ] );
   1a782:	fb12 f20b 	smulbb	r2, r2, fp
            LTP_est = silk_SMLABB_ovflw( LTP_est, x_lag_ptr[ 1 ], Btmp_Q14[ 1 ] );
   1a786:	fb1a 2303 	smlabb	r3, sl, r3, r2
            LTP_est = silk_SMLABB_ovflw( LTP_est, x_lag_ptr[ 0 ], Btmp_Q14[ 2 ] );
   1a78a:	fb19 3101 	smlabb	r1, r9, r1, r3
            LTP_est = silk_SMLABB_ovflw( LTP_est, x_lag_ptr[ -1 ], Btmp_Q14[ 3 ] );
   1a78e:	f830 3c04 	ldrh.w	r3, [r0, #-4]
            LTP_res_ptr[ i ] = (opus_int16)silk_SAT16( (opus_int32)x_ptr[ i ] - LTP_est );
   1a792:	f9b4 2000 	ldrsh.w	r2, [r4]
            LTP_est = silk_SMLABB_ovflw( LTP_est, x_lag_ptr[ -1 ], Btmp_Q14[ 3 ] );
   1a796:	fb18 1103 	smlabb	r1, r8, r3, r1
            LTP_est = silk_SMLABB_ovflw( LTP_est, x_lag_ptr[ -2 ], Btmp_Q14[ 4 ] );
   1a79a:	f830 3c06 	ldrh.w	r3, [r0, #-6]
   1a79e:	fb1e 1103 	smlabb	r1, lr, r3, r1
            LTP_est = silk_RSHIFT_ROUND( LTP_est, 14 ); /* round and -> Q0*/
   1a7a2:	1349      	asrs	r1, r1, #13
   1a7a4:	3101      	adds	r1, #1
            LTP_res_ptr[ i ] = (opus_int16)silk_SAT16( (opus_int32)x_ptr[ i ] - LTP_est );
   1a7a6:	eba2 0261 	sub.w	r2, r2, r1, asr #1
   1a7aa:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
   1a7ae:	f647 73ff 	movw	r3, #32767	; 0x7fff
   1a7b2:	dbcf      	blt.n	1a754 <silk_LTP_analysis_filter_FIX+0x78>
   1a7b4:	461a      	mov	r2, r3
   1a7b6:	e7d2      	b.n	1a75e <silk_LTP_analysis_filter_FIX+0x82>
   1a7b8:	4b0a      	ldr	r3, [pc, #40]	; (1a7e4 <silk_LTP_analysis_filter_FIX+0x108>)
   1a7ba:	f44f 4200 	mov.w	r2, #32768	; 0x8000
   1a7be:	e7ce      	b.n	1a75e <silk_LTP_analysis_filter_FIX+0x82>
        x_ptr       += subfr_length;
   1a7c0:	9b01      	ldr	r3, [sp, #4]
   1a7c2:	9a07      	ldr	r2, [sp, #28]
   1a7c4:	4413      	add	r3, r2
   1a7c6:	9301      	str	r3, [sp, #4]
   1a7c8:	9b03      	ldr	r3, [sp, #12]
   1a7ca:	9a06      	ldr	r2, [sp, #24]
   1a7cc:	330a      	adds	r3, #10
   1a7ce:	9303      	str	r3, [sp, #12]
   1a7d0:	9b02      	ldr	r3, [sp, #8]
   1a7d2:	4413      	add	r3, r2
   1a7d4:	9302      	str	r3, [sp, #8]
    for( k = 0; k < nb_subfr; k++ ) {
   1a7d6:	9a08      	ldr	r2, [sp, #32]
   1a7d8:	9b04      	ldr	r3, [sp, #16]
   1a7da:	4293      	cmp	r3, r2
   1a7dc:	d19c      	bne.n	1a718 <silk_LTP_analysis_filter_FIX+0x3c>
    }
}
   1a7de:	b00b      	add	sp, #44	; 0x2c
   1a7e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1a7e4:	ffff8000 	.word	0xffff8000

0001a7e8 <silk_LTP_scale_ctrl_FIX>:
    opus_int                        condCoding                              /* I    The type of conditional coding to use                                       */
)
{
    opus_int round_loss;

    if( condCoding == CODE_INDEPENDENTLY ) {
   1a7e8:	b9f2      	cbnz	r2, 1a828 <silk_LTP_scale_ctrl_FIX+0x40>
{
   1a7ea:	b430      	push	{r4, r5}
        /* Only scale if first frame in packet */
        round_loss = psEnc->sCmn.PacketLoss_perc + psEnc->sCmn.nFramesPerPacket;
   1a7ec:	f241 2308 	movw	r3, #4616	; 0x1208
   1a7f0:	f241 6470 	movw	r4, #5744	; 0x1670
   1a7f4:	58c3      	ldr	r3, [r0, r3]
   1a7f6:	5905      	ldr	r5, [r0, r4]
        psEnc->sCmn.indices.LTP_scaleIndex = (opus_int8)silk_LIMIT(
   1a7f8:	f8d1 418c 	ldr.w	r4, [r1, #396]	; 0x18c
        round_loss = psEnc->sCmn.PacketLoss_perc + psEnc->sCmn.nFramesPerPacket;
   1a7fc:	442b      	add	r3, r5
        psEnc->sCmn.indices.LTP_scaleIndex = (opus_int8)silk_LIMIT(
   1a7fe:	fb13 f304 	smulbb	r3, r3, r4
   1a802:	141c      	asrs	r4, r3, #16
   1a804:	b29b      	uxth	r3, r3
   1a806:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   1a80a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   1a80e:	eb04 1404 	add.w	r4, r4, r4, lsl #4
   1a812:	eb03 1303 	add.w	r3, r3, r3, lsl #4
   1a816:	eb04 4313 	add.w	r3, r4, r3, lsr #16
   1a81a:	2b02      	cmp	r3, #2
   1a81c:	dc0d      	bgt.n	1a83a <silk_LTP_scale_ctrl_FIX+0x52>
   1a81e:	2b00      	cmp	r3, #0
   1a820:	db16      	blt.n	1a850 <silk_LTP_scale_ctrl_FIX+0x68>
   1a822:	b25b      	sxtb	r3, r3
   1a824:	461a      	mov	r2, r3
   1a826:	e00a      	b.n	1a83e <silk_LTP_scale_ctrl_FIX+0x56>
            silk_SMULWB( silk_SMULBB( round_loss, psEncCtrl->LTPredCodGain_Q7 ), SILK_FIX_CONST( 0.1, 9 ) ), 0, 2 );
    } else {
        /* Default is minimum scaling */
        psEnc->sCmn.indices.LTP_scaleIndex = 0;
   1a828:	f241 23a1 	movw	r3, #4769	; 0x12a1
   1a82c:	2200      	movs	r2, #0
   1a82e:	54c2      	strb	r2, [r0, r3]
    }
    psEncCtrl->LTP_scale_Q14 = silk_LTPScales_table_Q14[ psEnc->sCmn.indices.LTP_scaleIndex ];
   1a830:	4b08      	ldr	r3, [pc, #32]	; (1a854 <silk_LTP_scale_ctrl_FIX+0x6c>)
   1a832:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
   1a836:	678b      	str	r3, [r1, #120]	; 0x78
   1a838:	4770      	bx	lr
   1a83a:	2202      	movs	r2, #2
        psEnc->sCmn.indices.LTP_scaleIndex = (opus_int8)silk_LIMIT(
   1a83c:	4613      	mov	r3, r2
   1a83e:	f241 24a1 	movw	r4, #4769	; 0x12a1
   1a842:	5503      	strb	r3, [r0, r4]
    psEncCtrl->LTP_scale_Q14 = silk_LTPScales_table_Q14[ psEnc->sCmn.indices.LTP_scaleIndex ];
   1a844:	4b03      	ldr	r3, [pc, #12]	; (1a854 <silk_LTP_scale_ctrl_FIX+0x6c>)
   1a846:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
   1a84a:	678b      	str	r3, [r1, #120]	; 0x78
}
   1a84c:	bc30      	pop	{r4, r5}
   1a84e:	4770      	bx	lr
        psEnc->sCmn.indices.LTP_scaleIndex = (opus_int8)silk_LIMIT(
   1a850:	4613      	mov	r3, r2
   1a852:	e7f4      	b.n	1a83e <silk_LTP_scale_ctrl_FIX+0x56>
   1a854:	00036c6c 	.word	0x00036c6c

0001a858 <silk_corrVector_FIX>:
    const opus_int                  order,                                  /* I    Max lag for correlation                                                     */
    opus_int32                      *Xt,                                    /* O    Pointer to X'*t correlation vector [order]                                  */
    const opus_int                  rshifts,                                /* I    Right shifts of correlations                                                */
    int                             arch                                    /* I    Run-time architecture                                                       */
)
{
   1a858:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1a85c:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
    opus_int         lag, i;
    const opus_int16 *ptr1, *ptr2;
    opus_int32       inner_prod;

    ptr1 = &x[ order - 1 ]; /* Points to first sample of column 0 of X: X[:,0] */
   1a860:	f103 4600 	add.w	r6, r3, #2147483648	; 0x80000000
   1a864:	3e01      	subs	r6, #1
    ptr2 = t;
    /* Calculate X'*t */
    if( rshifts > 0 ) {
   1a866:	f1bc 0f00 	cmp.w	ip, #0
    ptr1 = &x[ order - 1 ]; /* Points to first sample of column 0 of X: X[:,0] */
   1a86a:	eb00 0646 	add.w	r6, r0, r6, lsl #1
    if( rshifts > 0 ) {
   1a86e:	dd2b      	ble.n	1a8c8 <silk_corrVector_FIX+0x70>
        /* Right shifting used */
        for( lag = 0; lag < order; lag++ ) {
   1a870:	2b00      	cmp	r3, #0
   1a872:	dd1f      	ble.n	1a8b4 <silk_corrVector_FIX+0x5c>
   1a874:	9808      	ldr	r0, [sp, #32]
   1a876:	f1a0 0e04 	sub.w	lr, r0, #4
   1a87a:	3e02      	subs	r6, #2
   1a87c:	eb0e 0883 	add.w	r8, lr, r3, lsl #2
   1a880:	ea4f 0942 	mov.w	r9, r2, lsl #1
            inner_prod = 0;
            for( i = 0; i < L; i++ ) {
   1a884:	2a00      	cmp	r2, #0
   1a886:	dd17      	ble.n	1a8b8 <silk_corrVector_FIX+0x60>
   1a888:	1e8d      	subs	r5, r1, #2
   1a88a:	eb06 0709 	add.w	r7, r6, r9
   1a88e:	4630      	mov	r0, r6
            inner_prod = 0;
   1a890:	2400      	movs	r4, #0
                inner_prod = silk_ADD_RSHIFT32( inner_prod, silk_SMULBB( ptr1[ i ], ptr2[i] ), rshifts );
   1a892:	f830 3f02 	ldrh.w	r3, [r0, #2]!
   1a896:	f835 af02 	ldrh.w	sl, [r5, #2]!
   1a89a:	fb13 f30a 	smulbb	r3, r3, sl
   1a89e:	fa43 f30c 	asr.w	r3, r3, ip
            for( i = 0; i < L; i++ ) {
   1a8a2:	4287      	cmp	r7, r0
                inner_prod = silk_ADD_RSHIFT32( inner_prod, silk_SMULBB( ptr1[ i ], ptr2[i] ), rshifts );
   1a8a4:	441c      	add	r4, r3
            for( i = 0; i < L; i++ ) {
   1a8a6:	d1f4      	bne.n	1a892 <silk_corrVector_FIX+0x3a>
            }
            Xt[ lag ] = inner_prod; /* X[:,lag]'*t */
   1a8a8:	f84e 4f04 	str.w	r4, [lr, #4]!
        for( lag = 0; lag < order; lag++ ) {
   1a8ac:	45f0      	cmp	r8, lr
   1a8ae:	f1a6 0602 	sub.w	r6, r6, #2
   1a8b2:	d1e7      	bne.n	1a884 <silk_corrVector_FIX+0x2c>
        for( lag = 0; lag < order; lag++ ) {
            Xt[ lag ] = silk_inner_prod_aligned( ptr1, ptr2, L, arch ); /* X[:,lag]'*t */
            ptr1--; /* Go to next column of X */
        }
    }
}
   1a8b4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            inner_prod = 0;
   1a8b8:	2400      	movs	r4, #0
            Xt[ lag ] = inner_prod; /* X[:,lag]'*t */
   1a8ba:	f84e 4f04 	str.w	r4, [lr, #4]!
        for( lag = 0; lag < order; lag++ ) {
   1a8be:	45f0      	cmp	r8, lr
   1a8c0:	f1a6 0602 	sub.w	r6, r6, #2
   1a8c4:	d1de      	bne.n	1a884 <silk_corrVector_FIX+0x2c>
   1a8c6:	e7f5      	b.n	1a8b4 <silk_corrVector_FIX+0x5c>
        for( lag = 0; lag < order; lag++ ) {
   1a8c8:	2b00      	cmp	r3, #0
   1a8ca:	ddf3      	ble.n	1a8b4 <silk_corrVector_FIX+0x5c>
   1a8cc:	4617      	mov	r7, r2
   1a8ce:	9a08      	ldr	r2, [sp, #32]
   1a8d0:	1f15      	subs	r5, r2, #4
   1a8d2:	4688      	mov	r8, r1
   1a8d4:	eb05 0483 	add.w	r4, r5, r3, lsl #2
            Xt[ lag ] = silk_inner_prod_aligned( ptr1, ptr2, L, arch ); /* X[:,lag]'*t */
   1a8d8:	4630      	mov	r0, r6
   1a8da:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1a8dc:	463a      	mov	r2, r7
   1a8de:	4641      	mov	r1, r8
   1a8e0:	f005 fa36 	bl	1fd50 <silk_inner_prod_aligned>
   1a8e4:	f845 0f04 	str.w	r0, [r5, #4]!
        for( lag = 0; lag < order; lag++ ) {
   1a8e8:	42a5      	cmp	r5, r4
            ptr1--; /* Go to next column of X */
   1a8ea:	f1a6 0602 	sub.w	r6, r6, #2
        for( lag = 0; lag < order; lag++ ) {
   1a8ee:	d1f3      	bne.n	1a8d8 <silk_corrVector_FIX+0x80>
}
   1a8f0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0001a8f4 <silk_corrMatrix_FIX>:
    opus_int32                      *XX,                                    /* O    Pointer to X'*X correlation matrix [ order x order ]                        */
    opus_int32                      *nrg,                                    /* O    Energy of x vector                                                            */
    opus_int                        *rshifts,                               /* O    Right shifts of correlations and energy                                     */
    int                             arch                                    /* I    Run-time architecture                                                       */
)
{
   1a8f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1a8f8:	b08d      	sub	sp, #52	; 0x34
   1a8fa:	e9dd 5616 	ldrd	r5, r6, [sp, #88]	; 0x58
   1a8fe:	9104      	str	r1, [sp, #16]
    opus_int         i, j, lag;
    opus_int32       energy;
    const opus_int16 *ptr1, *ptr2;

    /* Calculate energy to find shift used to fit in 32 bits */
    silk_sum_sqr_shift( nrg, rshifts, x, L + order - 1 );
   1a900:	4411      	add	r1, r2
   1a902:	9200      	str	r2, [sp, #0]
{
   1a904:	4604      	mov	r4, r0
    silk_sum_sqr_shift( nrg, rshifts, x, L + order - 1 );
   1a906:	4602      	mov	r2, r0
{
   1a908:	461f      	mov	r7, r3
    silk_sum_sqr_shift( nrg, rshifts, x, L + order - 1 );
   1a90a:	4628      	mov	r0, r5
   1a90c:	1e4b      	subs	r3, r1, #1
   1a90e:	4631      	mov	r1, r6
   1a910:	f7ff fb1a 	bl	19f48 <silk_sum_sqr_shift>
    energy = *nrg;

    /* Calculate energy of first column (0) of X: X[:,0]'*X[:,0] */
    /* Remove contribution of first order - 1 samples */
    for( i = 0; i < order - 1; i++ ) {
   1a914:	9a00      	ldr	r2, [sp, #0]
    energy = *nrg;
   1a916:	682b      	ldr	r3, [r5, #0]
        energy -= silk_RSHIFT32( silk_SMULBB( x[ i ], x[ i ] ), *rshifts );
   1a918:	6836      	ldr	r6, [r6, #0]
    for( i = 0; i < order - 1; i++ ) {
   1a91a:	f102 3bff 	add.w	fp, r2, #4294967295	; 0xffffffff
   1a91e:	f1bb 0f00 	cmp.w	fp, #0
   1a922:	f340 810b 	ble.w	1ab3c <silk_corrMatrix_FIX+0x248>
   1a926:	1f20      	subs	r0, r4, #4
   1a928:	eb00 0042 	add.w	r0, r0, r2, lsl #1
   1a92c:	1ea1      	subs	r1, r4, #2
        energy -= silk_RSHIFT32( silk_SMULBB( x[ i ], x[ i ] ), *rshifts );
   1a92e:	f931 2f02 	ldrsh.w	r2, [r1, #2]!
   1a932:	fb02 f202 	mul.w	r2, r2, r2
   1a936:	4132      	asrs	r2, r6
    for( i = 0; i < order - 1; i++ ) {
   1a938:	4288      	cmp	r0, r1
        energy -= silk_RSHIFT32( silk_SMULBB( x[ i ], x[ i ] ), *rshifts );
   1a93a:	eba3 0302 	sub.w	r3, r3, r2
    for( i = 0; i < order - 1; i++ ) {
   1a93e:	d1f6      	bne.n	1a92e <silk_corrMatrix_FIX+0x3a>
   1a940:	9900      	ldr	r1, [sp, #0]
    }

    /* Calculate energy of remaining columns of X: X[:,j]'*X[:,j] */
    /* Fill out the diagonal of the correlation matrix */
    matrix_ptr( XX, 0, 0, order ) = energy;
   1a942:	603b      	str	r3, [r7, #0]
    silk_assert( energy >= 0 );
    ptr1 = &x[ order - 1 ]; /* First sample of column 0 of X */
   1a944:	f101 4e00 	add.w	lr, r1, #2147483648	; 0x80000000
   1a948:	f10e 3eff 	add.w	lr, lr, #4294967295	; 0xffffffff
   1a94c:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
   1a950:	eb04 020e 	add.w	r2, r4, lr
   1a954:	f1ae 0c02 	sub.w	ip, lr, #2
    for( j = 1; j < order; j++ ) {
   1a958:	2901      	cmp	r1, #1
   1a95a:	eb04 050c 	add.w	r5, r4, ip
    ptr1 = &x[ order - 1 ]; /* First sample of column 0 of X */
   1a95e:	9202      	str	r2, [sp, #8]
   1a960:	4614      	mov	r4, r2
    for( j = 1; j < order; j++ ) {
   1a962:	f340 808e 	ble.w	1aa82 <silk_corrMatrix_FIX+0x18e>
   1a966:	9804      	ldr	r0, [sp, #16]
   1a968:	f101 0901 	add.w	r9, r1, #1
   1a96c:	0040      	lsls	r0, r0, #1
   1a96e:	1811      	adds	r1, r2, r0
   1a970:	9007      	str	r0, [sp, #28]
   1a972:	ea4f 0089 	mov.w	r0, r9, lsl #2
   1a976:	9109      	str	r1, [sp, #36]	; 0x24
   1a978:	eba2 0e0e 	sub.w	lr, r2, lr
   1a97c:	4688      	mov	r8, r1
   1a97e:	eb07 0c00 	add.w	ip, r7, r0
        energy = silk_SUB32( energy, silk_RSHIFT32( silk_SMULBB( ptr1[ L - j ], ptr1[ L - j ] ), *rshifts ) );
   1a982:	f938 2d02 	ldrsh.w	r2, [r8, #-2]!
        energy = silk_ADD32( energy, silk_RSHIFT32( silk_SMULBB( ptr1[ -j ], ptr1[ -j ] ), *rshifts ) );
   1a986:	f934 1d02 	ldrsh.w	r1, [r4, #-2]!
        energy = silk_SUB32( energy, silk_RSHIFT32( silk_SMULBB( ptr1[ L - j ], ptr1[ L - j ] ), *rshifts ) );
   1a98a:	fb02 f202 	mul.w	r2, r2, r2
   1a98e:	4132      	asrs	r2, r6
        energy = silk_ADD32( energy, silk_RSHIFT32( silk_SMULBB( ptr1[ -j ], ptr1[ -j ] ), *rshifts ) );
   1a990:	fb01 f101 	mul.w	r1, r1, r1
        energy = silk_SUB32( energy, silk_RSHIFT32( silk_SMULBB( ptr1[ L - j ], ptr1[ L - j ] ), *rshifts ) );
   1a994:	1a9a      	subs	r2, r3, r2
        energy = silk_ADD32( energy, silk_RSHIFT32( silk_SMULBB( ptr1[ -j ], ptr1[ -j ] ), *rshifts ) );
   1a996:	fa41 f306 	asr.w	r3, r1, r6
   1a99a:	4413      	add	r3, r2
    for( j = 1; j < order; j++ ) {
   1a99c:	4574      	cmp	r4, lr
        matrix_ptr( XX, j, j, order ) = energy;
   1a99e:	f8cc 3000 	str.w	r3, [ip]
   1a9a2:	4484      	add	ip, r0
    for( j = 1; j < order; j++ ) {
   1a9a4:	d1ed      	bne.n	1a982 <silk_corrMatrix_FIX+0x8e>
        silk_assert( energy >= 0 );
    }

    ptr2 = &x[ order - 2 ]; /* First sample of column 1 of X */
    /* Calculate the remaining elements of the correlation matrix */
    if( *rshifts > 0 ) {
   1a9a6:	2e00      	cmp	r6, #0
   1a9a8:	9b00      	ldr	r3, [sp, #0]
   1a9aa:	dd71      	ble.n	1aa90 <silk_corrMatrix_FIX+0x19c>
   1a9ac:	ea4f 0a43 	mov.w	sl, r3, lsl #1
   1a9b0:	f103 4e80 	add.w	lr, r3, #1073741824	; 0x40000000
   1a9b4:	ea4f 0189 	mov.w	r1, r9, lsl #2
   1a9b8:	9b07      	ldr	r3, [sp, #28]
   1a9ba:	910b      	str	r1, [sp, #44]	; 0x2c
   1a9bc:	1f02      	subs	r2, r0, #4
   1a9be:	9902      	ldr	r1, [sp, #8]
   1a9c0:	9205      	str	r2, [sp, #20]
   1a9c2:	f1ca 0a04 	rsb	sl, sl, #4
   1a9c6:	f10e 3eff 	add.w	lr, lr, #4294967295	; 0xffffffff
   1a9ca:	3b02      	subs	r3, #2
   1a9cc:	3808      	subs	r0, #8
   1a9ce:	18ba      	adds	r2, r7, r2
   1a9d0:	f8cd b000 	str.w	fp, [sp]
   1a9d4:	448a      	add	sl, r1
   1a9d6:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
   1a9da:	900a      	str	r0, [sp, #40]	; 0x28
   1a9dc:	9201      	str	r2, [sp, #4]
   1a9de:	9703      	str	r7, [sp, #12]
   1a9e0:	eb01 0b03 	add.w	fp, r1, r3
        /* Right shifting used */
        for( lag = 1; lag < order; lag++ ) {
            /* Inner product of column 0 and column lag: X[:,0]'*X[:,lag] */
            energy = 0;
            for( i = 0; i < L; i++ ) {
   1a9e4:	9b04      	ldr	r3, [sp, #16]
   1a9e6:	2b00      	cmp	r3, #0
   1a9e8:	dd4e      	ble.n	1aa88 <silk_corrMatrix_FIX+0x194>
   1a9ea:	1eab      	subs	r3, r5, #2
   1a9ec:	9306      	str	r3, [sp, #24]
   1a9ee:	461c      	mov	r4, r3
   1a9f0:	9b02      	ldr	r3, [sp, #8]
   1a9f2:	1e98      	subs	r0, r3, #2
            energy = 0;
   1a9f4:	2300      	movs	r3, #0
                energy += silk_RSHIFT32( silk_SMULBB( ptr1[ i ], ptr2[i] ), *rshifts );
   1a9f6:	f830 2f02 	ldrh.w	r2, [r0, #2]!
   1a9fa:	f834 1f02 	ldrh.w	r1, [r4, #2]!
   1a9fe:	fb12 f201 	smulbb	r2, r2, r1
   1aa02:	4132      	asrs	r2, r6
            for( i = 0; i < L; i++ ) {
   1aa04:	4583      	cmp	fp, r0
                energy += silk_RSHIFT32( silk_SMULBB( ptr1[ i ], ptr2[i] ), *rshifts );
   1aa06:	4413      	add	r3, r2
            for( i = 0; i < L; i++ ) {
   1aa08:	d1f5      	bne.n	1a9f6 <silk_corrMatrix_FIX+0x102>
            }
            /* Calculate remaining off diagonal: X[:,j]'*X[:,j + lag] */
            matrix_ptr( XX, lag, 0, order ) = energy;
   1aa0a:	9a01      	ldr	r2, [sp, #4]
            matrix_ptr( XX, 0, lag, order ) = energy;
            for( j = 1; j < ( order - lag ); j++ ) {
   1aa0c:	9900      	ldr	r1, [sp, #0]
            matrix_ptr( XX, lag, 0, order ) = energy;
   1aa0e:	6013      	str	r3, [r2, #0]
            matrix_ptr( XX, 0, lag, order ) = energy;
   1aa10:	9a03      	ldr	r2, [sp, #12]
   1aa12:	f842 3f04 	str.w	r3, [r2, #4]!
            for( j = 1; j < ( order - lag ); j++ ) {
   1aa16:	2901      	cmp	r1, #1
            matrix_ptr( XX, 0, lag, order ) = energy;
   1aa18:	9203      	str	r2, [sp, #12]
            for( j = 1; j < ( order - lag ); j++ ) {
   1aa1a:	dd25      	ble.n	1aa68 <silk_corrMatrix_FIX+0x174>
   1aa1c:	9907      	ldr	r1, [sp, #28]
   1aa1e:	f8cd b020 	str.w	fp, [sp, #32]
   1aa22:	eb05 0901 	add.w	r9, r5, r1
   1aa26:	9905      	ldr	r1, [sp, #20]
   1aa28:	f8dd c008 	ldr.w	ip, [sp, #8]
   1aa2c:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
   1aa30:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
   1aa34:	188f      	adds	r7, r1, r2
                energy = silk_SUB32( energy, silk_RSHIFT32( silk_SMULBB( ptr1[ L - j ], ptr2[ L - j ] ), *rshifts ) );
   1aa36:	f838 2d02 	ldrh.w	r2, [r8, #-2]!
   1aa3a:	f839 4d02 	ldrh.w	r4, [r9, #-2]!
                energy = silk_ADD32( energy, silk_RSHIFT32( silk_SMULBB( ptr1[ -j ], ptr2[ -j ] ), *rshifts ) );
   1aa3e:	f83c 1d02 	ldrh.w	r1, [ip, #-2]!
   1aa42:	f835 0d02 	ldrh.w	r0, [r5, #-2]!
                energy = silk_SUB32( energy, silk_RSHIFT32( silk_SMULBB( ptr1[ L - j ], ptr2[ L - j ] ), *rshifts ) );
   1aa46:	fb12 f204 	smulbb	r2, r2, r4
   1aa4a:	4132      	asrs	r2, r6
                energy = silk_ADD32( energy, silk_RSHIFT32( silk_SMULBB( ptr1[ -j ], ptr2[ -j ] ), *rshifts ) );
   1aa4c:	fb11 f100 	smulbb	r1, r1, r0
                energy = silk_SUB32( energy, silk_RSHIFT32( silk_SMULBB( ptr1[ L - j ], ptr2[ L - j ] ), *rshifts ) );
   1aa50:	1a9b      	subs	r3, r3, r2
                energy = silk_ADD32( energy, silk_RSHIFT32( silk_SMULBB( ptr1[ -j ], ptr2[ -j ] ), *rshifts ) );
   1aa52:	4131      	asrs	r1, r6
                matrix_ptr( XX, lag + j, j, order ) = energy;
   1aa54:	eb07 020e 	add.w	r2, r7, lr
                energy = silk_ADD32( energy, silk_RSHIFT32( silk_SMULBB( ptr1[ -j ], ptr2[ -j ] ), *rshifts ) );
   1aa58:	440b      	add	r3, r1
            for( j = 1; j < ( order - lag ); j++ ) {
   1aa5a:	45e2      	cmp	sl, ip
                matrix_ptr( XX, lag + j, j, order ) = energy;
   1aa5c:	6053      	str	r3, [r2, #4]
                matrix_ptr( XX, j, lag + j, order ) = energy;
   1aa5e:	607b      	str	r3, [r7, #4]
   1aa60:	445f      	add	r7, fp
            for( j = 1; j < ( order - lag ); j++ ) {
   1aa62:	d1e8      	bne.n	1aa36 <silk_corrMatrix_FIX+0x142>
   1aa64:	f8dd b020 	ldr.w	fp, [sp, #32]
   1aa68:	9b01      	ldr	r3, [sp, #4]
   1aa6a:	9a05      	ldr	r2, [sp, #20]
            }
            ptr2--; /* Update pointer to first sample of next column (lag) in X */
   1aa6c:	9d06      	ldr	r5, [sp, #24]
   1aa6e:	4413      	add	r3, r2
   1aa70:	9301      	str	r3, [sp, #4]
   1aa72:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1aa74:	449e      	add	lr, r3
        for( lag = 1; lag < order; lag++ ) {
   1aa76:	9b00      	ldr	r3, [sp, #0]
   1aa78:	3b01      	subs	r3, #1
   1aa7a:	f10a 0a02 	add.w	sl, sl, #2
   1aa7e:	9300      	str	r3, [sp, #0]
   1aa80:	d1b0      	bne.n	1a9e4 <silk_corrMatrix_FIX+0xf0>
                matrix_ptr( XX, j, lag + j, order ) = energy;
            }
            ptr2--;/* Update pointer to first sample of next column (lag) in X */
        }
    }
}
   1aa82:	b00d      	add	sp, #52	; 0x34
   1aa84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1aa88:	1eaa      	subs	r2, r5, #2
            energy = 0;
   1aa8a:	2300      	movs	r3, #0
   1aa8c:	9206      	str	r2, [sp, #24]
   1aa8e:	e7bc      	b.n	1aa0a <silk_corrMatrix_FIX+0x116>
   1aa90:	f103 4480 	add.w	r4, r3, #1073741824	; 0x40000000
   1aa94:	1f03      	subs	r3, r0, #4
   1aa96:	9305      	str	r3, [sp, #20]
   1aa98:	18fb      	adds	r3, r7, r3
   1aa9a:	9301      	str	r3, [sp, #4]
   1aa9c:	9b02      	ldr	r3, [sp, #8]
   1aa9e:	9703      	str	r7, [sp, #12]
   1aaa0:	3c01      	subs	r4, #1
   1aaa2:	f1a0 0208 	sub.w	r2, r0, #8
   1aaa6:	3302      	adds	r3, #2
   1aaa8:	ea4f 0689 	mov.w	r6, r9, lsl #2
   1aaac:	00a4      	lsls	r4, r4, #2
   1aaae:	9206      	str	r2, [sp, #24]
        for( lag = 1; lag < order; lag++ ) {
   1aab0:	2701      	movs	r7, #1
   1aab2:	9308      	str	r3, [sp, #32]
            energy = silk_inner_prod_aligned( ptr1, ptr2, L, arch );
   1aab4:	f8dd 8008 	ldr.w	r8, [sp, #8]
   1aab8:	9b18      	ldr	r3, [sp, #96]	; 0x60
   1aaba:	9a04      	ldr	r2, [sp, #16]
   1aabc:	4629      	mov	r1, r5
   1aabe:	4640      	mov	r0, r8
   1aac0:	f005 f946 	bl	1fd50 <silk_inner_prod_aligned>
            matrix_ptr( XX, lag, 0, order ) = energy;
   1aac4:	9a01      	ldr	r2, [sp, #4]
            for( j = 1; j < ( order - lag ); j++ ) {
   1aac6:	9900      	ldr	r1, [sp, #0]
            matrix_ptr( XX, lag, 0, order ) = energy;
   1aac8:	6010      	str	r0, [r2, #0]
            matrix_ptr( XX, 0, lag, order ) = energy;
   1aaca:	9a03      	ldr	r2, [sp, #12]
            for( j = 1; j < ( order - lag ); j++ ) {
   1aacc:	1bcb      	subs	r3, r1, r7
            matrix_ptr( XX, 0, lag, order ) = energy;
   1aace:	f842 0f04 	str.w	r0, [r2, #4]!
            for( j = 1; j < ( order - lag ); j++ ) {
   1aad2:	2b01      	cmp	r3, #1
            matrix_ptr( XX, 0, lag, order ) = energy;
   1aad4:	9203      	str	r2, [sp, #12]
            for( j = 1; j < ( order - lag ); j++ ) {
   1aad6:	dd22      	ble.n	1ab1e <silk_corrMatrix_FIX+0x22a>
   1aad8:	9b08      	ldr	r3, [sp, #32]
   1aada:	eba7 0b01 	sub.w	fp, r7, r1
   1aade:	eb03 0b4b 	add.w	fp, r3, fp, lsl #1
   1aae2:	9905      	ldr	r1, [sp, #20]
   1aae4:	9b07      	ldr	r3, [sp, #28]
   1aae6:	eb03 0c05 	add.w	ip, r3, r5
   1aaea:	188b      	adds	r3, r1, r2
   1aaec:	9909      	ldr	r1, [sp, #36]	; 0x24
   1aaee:	46ae      	mov	lr, r5
   1aaf0:	4642      	mov	r2, r8
                energy = silk_SUB32( energy, silk_SMULBB( ptr1[ L - j ], ptr2[ L - j ] ) );
   1aaf2:	f83c 9d02 	ldrh.w	r9, [ip, #-2]!
   1aaf6:	f831 8d02 	ldrh.w	r8, [r1, #-2]!
                energy = silk_SMLABB( energy, ptr1[ -j ], ptr2[ -j ] );
   1aafa:	f832 ad02 	ldrh.w	sl, [r2, #-2]!
                energy = silk_SUB32( energy, silk_SMULBB( ptr1[ L - j ], ptr2[ L - j ] ) );
   1aafe:	fb18 f809 	smulbb	r8, r8, r9
                energy = silk_SMLABB( energy, ptr1[ -j ], ptr2[ -j ] );
   1ab02:	f83e 9d02 	ldrh.w	r9, [lr, #-2]!
                energy = silk_SUB32( energy, silk_SMULBB( ptr1[ L - j ], ptr2[ L - j ] ) );
   1ab06:	eba0 0008 	sub.w	r0, r0, r8
                matrix_ptr( XX, lag + j, j, order ) = energy;
   1ab0a:	eb03 0804 	add.w	r8, r3, r4
                energy = silk_SMLABB( energy, ptr1[ -j ], ptr2[ -j ] );
   1ab0e:	fb1a 0009 	smlabb	r0, sl, r9, r0
            for( j = 1; j < ( order - lag ); j++ ) {
   1ab12:	4593      	cmp	fp, r2
                matrix_ptr( XX, lag + j, j, order ) = energy;
   1ab14:	f8c8 0004 	str.w	r0, [r8, #4]
                matrix_ptr( XX, j, lag + j, order ) = energy;
   1ab18:	6058      	str	r0, [r3, #4]
   1ab1a:	4433      	add	r3, r6
            for( j = 1; j < ( order - lag ); j++ ) {
   1ab1c:	d1e9      	bne.n	1aaf2 <silk_corrMatrix_FIX+0x1fe>
   1ab1e:	9b01      	ldr	r3, [sp, #4]
   1ab20:	9a05      	ldr	r2, [sp, #20]
   1ab22:	4413      	add	r3, r2
   1ab24:	9301      	str	r3, [sp, #4]
   1ab26:	9b06      	ldr	r3, [sp, #24]
   1ab28:	441c      	add	r4, r3
        for( lag = 1; lag < order; lag++ ) {
   1ab2a:	9b00      	ldr	r3, [sp, #0]
   1ab2c:	3701      	adds	r7, #1
   1ab2e:	42bb      	cmp	r3, r7
            ptr2--;/* Update pointer to first sample of next column (lag) in X */
   1ab30:	f1a5 0502 	sub.w	r5, r5, #2
        for( lag = 1; lag < order; lag++ ) {
   1ab34:	d1be      	bne.n	1aab4 <silk_corrMatrix_FIX+0x1c0>
}
   1ab36:	b00d      	add	sp, #52	; 0x34
   1ab38:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1ab3c:	4611      	mov	r1, r2
   1ab3e:	e700      	b.n	1a942 <silk_corrMatrix_FIX+0x4e>

0001ab40 <silk_encode_do_VAD_FIX>:

void silk_encode_do_VAD_FIX(
    silk_encoder_state_FIX          *psEnc,                                 /* I/O  Pointer to Silk FIX encoder state                                           */
    opus_int                        activity                                /* I    Decision of Opus voice activity detector                                    */
)
{
   1ab40:	b538      	push	{r3, r4, r5, lr}
   1ab42:	460d      	mov	r5, r1
    const opus_int activity_threshold = SILK_FIX_CONST( SPEECH_ACTIVITY_DTX_THRES, 8 );

    /****************************/
    /* Voice Activity Detection */
    /****************************/
    silk_VAD_GetSA_Q8( &psEnc->sCmn, psEnc->sCmn.inputBuf + 1, psEnc->sCmn.arch );
   1ab44:	f500 519f 	add.w	r1, r0, #5088	; 0x13e0
   1ab48:	310a      	adds	r1, #10
{
   1ab4a:	4604      	mov	r4, r0
    silk_VAD_GetSA_Q8( &psEnc->sCmn, psEnc->sCmn.inputBuf + 1, psEnc->sCmn.arch );
   1ab4c:	f7f8 ff02 	bl	13954 <silk_VAD_GetSA_Q8_c>
    /* If Opus VAD is inactive and Silk VAD is active: lower Silk VAD to just under the threshold */
    if( activity == VAD_NO_ACTIVITY && psEnc->sCmn.speech_activity_Q8 >= activity_threshold ) {
   1ab50:	b9ed      	cbnz	r5, 1ab8e <silk_encode_do_VAD_FIX+0x4e>
   1ab52:	f241 13b4 	movw	r3, #4532	; 0x11b4
   1ab56:	58e2      	ldr	r2, [r4, r3]
   1ab58:	2a0c      	cmp	r2, #12
   1ab5a:	dd01      	ble.n	1ab60 <silk_encode_do_VAD_FIX+0x20>
        psEnc->sCmn.speech_activity_Q8 = activity_threshold - 1;
   1ab5c:	220c      	movs	r2, #12
   1ab5e:	50e2      	str	r2, [r4, r3]
    /**************************************************/
    /* Convert speech activity into VAD and DTX flags */
    /**************************************************/
    if( psEnc->sCmn.speech_activity_Q8 < activity_threshold ) {
        psEnc->sCmn.indices.signalType = TYPE_NO_VOICE_ACTIVITY;
        psEnc->sCmn.noSpeechCounter++;
   1ab60:	f241 72c4 	movw	r2, #6084	; 0x17c4
        psEnc->sCmn.indices.signalType = TYPE_NO_VOICE_ACTIVITY;
   1ab64:	f241 209d 	movw	r0, #4765	; 0x129d
        psEnc->sCmn.noSpeechCounter++;
   1ab68:	58a3      	ldr	r3, [r4, r2]
   1ab6a:	3301      	adds	r3, #1
        psEnc->sCmn.indices.signalType = TYPE_NO_VOICE_ACTIVITY;
   1ab6c:	2100      	movs	r1, #0
        if( psEnc->sCmn.noSpeechCounter <= NB_SPEECH_FRAMES_BEFORE_DTX ) {
   1ab6e:	2b0a      	cmp	r3, #10
        psEnc->sCmn.noSpeechCounter++;
   1ab70:	50a3      	str	r3, [r4, r2]
        psEnc->sCmn.indices.signalType = TYPE_NO_VOICE_ACTIVITY;
   1ab72:	5421      	strb	r1, [r4, r0]
        if( psEnc->sCmn.noSpeechCounter <= NB_SPEECH_FRAMES_BEFORE_DTX ) {
   1ab74:	dc23      	bgt.n	1abbe <silk_encode_do_VAD_FIX+0x7e>
            psEnc->sCmn.inDTX = 0;
   1ab76:	f504 53be 	add.w	r3, r4, #6080	; 0x17c0
   1ab7a:	6019      	str	r1, [r3, #0]
        } else if( psEnc->sCmn.noSpeechCounter > MAX_CONSECUTIVE_DTX + NB_SPEECH_FRAMES_BEFORE_DTX ) {
            psEnc->sCmn.noSpeechCounter = NB_SPEECH_FRAMES_BEFORE_DTX;
            psEnc->sCmn.inDTX           = 0;
        }
        psEnc->sCmn.VAD_flags[ psEnc->sCmn.nFramesEncoded ] = 0;
   1ab7c:	f241 6374 	movw	r3, #5748	; 0x1674
   1ab80:	f241 2270 	movw	r2, #4720	; 0x1270
   1ab84:	58e3      	ldr	r3, [r4, r3]
   1ab86:	441c      	add	r4, r3
   1ab88:	2300      	movs	r3, #0
   1ab8a:	54a3      	strb	r3, [r4, r2]
        psEnc->sCmn.noSpeechCounter    = 0;
        psEnc->sCmn.inDTX              = 0;
        psEnc->sCmn.indices.signalType = TYPE_UNVOICED;
        psEnc->sCmn.VAD_flags[ psEnc->sCmn.nFramesEncoded ] = 1;
    }
}
   1ab8c:	bd38      	pop	{r3, r4, r5, pc}
    if( psEnc->sCmn.speech_activity_Q8 < activity_threshold ) {
   1ab8e:	f241 12b4 	movw	r2, #4532	; 0x11b4
   1ab92:	f241 6374 	movw	r3, #5748	; 0x1674
   1ab96:	58a2      	ldr	r2, [r4, r2]
   1ab98:	58e3      	ldr	r3, [r4, r3]
   1ab9a:	2a0c      	cmp	r2, #12
   1ab9c:	dde0      	ble.n	1ab60 <silk_encode_do_VAD_FIX+0x20>
        psEnc->sCmn.noSpeechCounter    = 0;
   1ab9e:	f241 71c4 	movw	r1, #6084	; 0x17c4
   1aba2:	2200      	movs	r2, #0
        psEnc->sCmn.inDTX              = 0;
   1aba4:	f504 55be 	add.w	r5, r4, #6080	; 0x17c0
        psEnc->sCmn.noSpeechCounter    = 0;
   1aba8:	5062      	str	r2, [r4, r1]
        psEnc->sCmn.VAD_flags[ psEnc->sCmn.nFramesEncoded ] = 1;
   1abaa:	4423      	add	r3, r4
        psEnc->sCmn.indices.signalType = TYPE_UNVOICED;
   1abac:	f241 209d 	movw	r0, #4765	; 0x129d
        psEnc->sCmn.VAD_flags[ psEnc->sCmn.nFramesEncoded ] = 1;
   1abb0:	f241 2170 	movw	r1, #4720	; 0x1270
        psEnc->sCmn.inDTX              = 0;
   1abb4:	602a      	str	r2, [r5, #0]
        psEnc->sCmn.indices.signalType = TYPE_UNVOICED;
   1abb6:	2201      	movs	r2, #1
   1abb8:	5422      	strb	r2, [r4, r0]
        psEnc->sCmn.VAD_flags[ psEnc->sCmn.nFramesEncoded ] = 1;
   1abba:	545a      	strb	r2, [r3, r1]
}
   1abbc:	bd38      	pop	{r3, r4, r5, pc}
        } else if( psEnc->sCmn.noSpeechCounter > MAX_CONSECUTIVE_DTX + NB_SPEECH_FRAMES_BEFORE_DTX ) {
   1abbe:	2b1e      	cmp	r3, #30
   1abc0:	dddc      	ble.n	1ab7c <silk_encode_do_VAD_FIX+0x3c>
            psEnc->sCmn.inDTX           = 0;
   1abc2:	f504 53be 	add.w	r3, r4, #6080	; 0x17c0
            psEnc->sCmn.noSpeechCounter = NB_SPEECH_FRAMES_BEFORE_DTX;
   1abc6:	200a      	movs	r0, #10
   1abc8:	50a0      	str	r0, [r4, r2]
            psEnc->sCmn.inDTX           = 0;
   1abca:	6019      	str	r1, [r3, #0]
   1abcc:	e7d6      	b.n	1ab7c <silk_encode_do_VAD_FIX+0x3c>
   1abce:	bf00      	nop

0001abd0 <silk_encode_frame_FIX>:
    ec_enc                          *psRangeEnc,                            /* I/O  compressor data structure                                                   */
    opus_int                        condCoding,                             /* I    The type of conditional coding to use                                       */
    opus_int                        maxBits,                                /* I    If > 0: maximum number of output bits                                       */
    opus_int                        useCBR                                  /* I    Flag to force constant-bitrate operation                                    */
)
{
   1abd0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1abd4:	f5ad 5d27 	sub.w	sp, sp, #10688	; 0x29c0
   1abd8:	b08b      	sub	sp, #44	; 0x2c
    SAVE_STACK;

    /* This is totally unnecessary but many compilers (including gcc) are too dumb to realise it */
    LastGainIndex_copy2 = nBits_lower = nBits_upper = gainMult_lower = gainMult_upper = 0;

    psEnc->sCmn.indices.Seed = psEnc->sCmn.frameCounter++ & 3;
   1abda:	f241 2c0c 	movw	ip, #4620	; 0x120c
{
   1abde:	4681      	mov	r9, r0
   1abe0:	af0c      	add	r7, sp, #48	; 0x30
    psEnc->sCmn.indices.Seed = psEnc->sCmn.frameCounter++ & 3;
   1abe2:	f850 000c 	ldr.w	r0, [r0, ip]
{
   1abe6:	663a      	str	r2, [r7, #96]	; 0x60

    /**************************************************************/
    /* Set up Input Pointers, and insert frame in input buffer   */
    /*************************************************************/
    /* start of frame to encode */
    x_frame = psEnc->x_buf + psEnc->sCmn.ltp_mem_length;
   1abe8:	f509 56e0 	add.w	r6, r9, #7168	; 0x1c00
    psEnc->sCmn.indices.Seed = psEnc->sCmn.frameCounter++ & 3;
   1abec:	f241 2ea2 	movw	lr, #4770	; 0x12a2
    x_frame = psEnc->x_buf + psEnc->sCmn.ltp_mem_length;
   1abf0:	f106 0210 	add.w	r2, r6, #16
    psEnc->sCmn.indices.Seed = psEnc->sCmn.frameCounter++ & 3;
   1abf4:	1c44      	adds	r4, r0, #1
    x_frame = psEnc->x_buf + psEnc->sCmn.ltp_mem_length;
   1abf6:	653a      	str	r2, [r7, #80]	; 0x50
    psEnc->sCmn.indices.Seed = psEnc->sCmn.frameCounter++ & 3;
   1abf8:	f000 0003 	and.w	r0, r0, #3
   1abfc:	f849 400c 	str.w	r4, [r9, ip]
{
   1ac00:	667b      	str	r3, [r7, #100]	; 0x64
    psEnc->sCmn.indices.Seed = psEnc->sCmn.frameCounter++ & 3;
   1ac02:	f809 000e 	strb.w	r0, [r9, lr]
    x_frame = psEnc->x_buf + psEnc->sCmn.ltp_mem_length;
   1ac06:	6d3b      	ldr	r3, [r7, #80]	; 0x50
{
   1ac08:	63f9      	str	r1, [r7, #60]	; 0x3c
    x_frame = psEnc->x_buf + psEnc->sCmn.ltp_mem_length;
   1ac0a:	f241 18f0 	movw	r8, #4592	; 0x11f0
   1ac0e:	469c      	mov	ip, r3

    /***************************************/
    /* Ensure smooth bandwidth transitions */
    /***************************************/
    silk_LP_variable_cutoff( &psEnc->sCmn.sLP, psEnc->sCmn.inputBuf + 1, psEnc->sCmn.frame_length );
   1ac10:	f241 1ae8 	movw	sl, #4584	; 0x11e8
    x_frame = psEnc->x_buf + psEnc->sCmn.ltp_mem_length;
   1ac14:	f859 3008 	ldr.w	r3, [r9, r8]
    silk_LP_variable_cutoff( &psEnc->sCmn.sLP, psEnc->sCmn.inputBuf + 1, psEnc->sCmn.frame_length );
   1ac18:	f859 200a 	ldr.w	r2, [r9, sl]
   1ac1c:	f509 559f 	add.w	r5, r9, #5088	; 0x13e0
   1ac20:	350a      	adds	r5, #10

    /*******************************************/
    /* Copy new frame to front of input buffer */
    /*******************************************/
    silk_memcpy( x_frame + LA_SHAPE_MS * psEnc->sCmn.fs_kHz, psEnc->sCmn.inputBuf + 1, psEnc->sCmn.frame_length * sizeof( opus_int16 ) );
   1ac22:	f509 568f 	add.w	r6, r9, #4576	; 0x11e0
    x_frame = psEnc->x_buf + psEnc->sCmn.ltp_mem_length;
   1ac26:	eb0c 0343 	add.w	r3, ip, r3, lsl #1
    silk_LP_variable_cutoff( &psEnc->sCmn.sLP, psEnc->sCmn.inputBuf + 1, psEnc->sCmn.frame_length );
   1ac2a:	4629      	mov	r1, r5
   1ac2c:	f109 0010 	add.w	r0, r9, #16
    opus_int     gain_lock[ MAX_NB_SUBFR ] = {0};
   1ac30:	2400      	movs	r4, #0
    x_frame = psEnc->x_buf + psEnc->sCmn.ltp_mem_length;
   1ac32:	65fb      	str	r3, [r7, #92]	; 0x5c
    silk_memcpy( x_frame + LA_SHAPE_MS * psEnc->sCmn.fs_kHz, psEnc->sCmn.inputBuf + 1, psEnc->sCmn.frame_length * sizeof( opus_int16 ) );
   1ac34:	63be      	str	r6, [r7, #56]	; 0x38
    opus_int     gain_lock[ MAX_NB_SUBFR ] = {0};
   1ac36:	e9c7 441e 	strd	r4, r4, [r7, #120]	; 0x78
   1ac3a:	e9c7 4420 	strd	r4, r4, [r7, #128]	; 0x80
    silk_LP_variable_cutoff( &psEnc->sCmn.sLP, psEnc->sCmn.inputBuf + 1, psEnc->sCmn.frame_length );
   1ac3e:	f7f5 f891 	bl	fd64 <silk_LP_variable_cutoff>
    silk_memcpy( x_frame + LA_SHAPE_MS * psEnc->sCmn.fs_kHz, psEnc->sCmn.inputBuf + 1, psEnc->sCmn.frame_length * sizeof( opus_int16 ) );
   1ac42:	6830      	ldr	r0, [r6, #0]
   1ac44:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   1ac46:	f859 200a 	ldr.w	r2, [r9, sl]
   1ac4a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   1ac4e:	eb03 0040 	add.w	r0, r3, r0, lsl #1
   1ac52:	4629      	mov	r1, r5
   1ac54:	0052      	lsls	r2, r2, #1
   1ac56:	f7f1 fa53 	bl	c100 <memcpy>

    if( !psEnc->sCmn.prefillFlag ) {
   1ac5a:	f241 2348 	movw	r3, #4680	; 0x1248
   1ac5e:	f859 3003 	ldr.w	r3, [r9, r3]
   1ac62:	64fb      	str	r3, [r7, #76]	; 0x4c
   1ac64:	b1d3      	cbz	r3, 1ac9c <silk_encode_frame_FIX+0xcc>
            gainsID = silk_gains_ID( psEnc->sCmn.indices.GainsIndices, psEnc->sCmn.nb_subfr );
        }
    }

    /* Update input buffer */
    silk_memmove( psEnc->x_buf, &psEnc->x_buf[ psEnc->sCmn.frame_length ],
   1ac66:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1ac68:	f859 100a 	ldr.w	r1, [r9, sl]
   1ac6c:	681a      	ldr	r2, [r3, #0]
   1ac6e:	f859 3008 	ldr.w	r3, [r9, r8]
   1ac72:	6d38      	ldr	r0, [r7, #80]	; 0x50
   1ac74:	eb02 0282 	add.w	r2, r2, r2, lsl #2
   1ac78:	441a      	add	r2, r3
   1ac7a:	f601 6108 	addw	r1, r1, #3592	; 0xe08
   1ac7e:	0052      	lsls	r2, r2, #1
   1ac80:	eb09 0141 	add.w	r1, r9, r1, lsl #1
   1ac84:	f01a fa0a 	bl	3509c <memmove>
        ( psEnc->sCmn.ltp_mem_length + LA_SHAPE_MS * psEnc->sCmn.fs_kHz ) * sizeof( opus_int16 ) );

    /* Exit without entropy coding */
    if( psEnc->sCmn.prefillFlag ) {
        /* No payload */
        *pnBytesOut = 0;
   1ac88:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
   1ac8a:	2300      	movs	r3, #0
   1ac8c:	6013      	str	r3, [r2, #0]
    /* Payload size */
    *pnBytesOut = silk_RSHIFT( ec_tell( psRangeEnc ) + 7, 3 );

    RESTORE_STACK;
    return ret;
}
   1ac8e:	f507 5726 	add.w	r7, r7, #10624	; 0x2980
   1ac92:	2000      	movs	r0, #0
   1ac94:	373c      	adds	r7, #60	; 0x3c
   1ac96:	46bd      	mov	sp, r7
   1ac98:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ALLOC( res_pitch,
   1ac9c:	f241 13f4 	movw	r3, #4596	; 0x11f4
   1aca0:	f859 200a 	ldr.w	r2, [r9, sl]
   1aca4:	f859 3003 	ldr.w	r3, [r9, r3]
   1aca8:	f859 4008 	ldr.w	r4, [r9, r8]
    if( !psEnc->sCmn.prefillFlag ) {
   1acac:	f8c7 d014 	str.w	sp, [r7, #20]
        ALLOC( res_pitch,
   1acb0:	4413      	add	r3, r2
   1acb2:	4423      	add	r3, r4
   1acb4:	005b      	lsls	r3, r3, #1
   1acb6:	3308      	adds	r3, #8
        silk_find_pitch_lags_FIX( psEnc, &sEncCtrl, res_pitch, x_frame - psEnc->sCmn.ltp_mem_length, psEnc->sCmn.arch );
   1acb8:	f241 35e4 	movw	r5, #5092	; 0x13e4
        ALLOC( res_pitch,
   1acbc:	f023 0307 	bic.w	r3, r3, #7
   1acc0:	ebad 0d03 	sub.w	sp, sp, r3
        silk_find_pitch_lags_FIX( psEnc, &sEncCtrl, res_pitch, x_frame - psEnc->sCmn.ltp_mem_length, psEnc->sCmn.arch );
   1acc4:	f859 3005 	ldr.w	r3, [r9, r5]
   1acc8:	9300      	str	r3, [sp, #0]
   1acca:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   1accc:	f107 08f8 	add.w	r8, r7, #248	; 0xf8
        res_pitch_frame = res_pitch + psEnc->sCmn.ltp_mem_length;
   1acd0:	0064      	lsls	r4, r4, #1
        ALLOC( res_pitch,
   1acd2:	ae0c      	add	r6, sp, #48	; 0x30
        silk_find_pitch_lags_FIX( psEnc, &sEncCtrl, res_pitch, x_frame - psEnc->sCmn.ltp_mem_length, psEnc->sCmn.arch );
   1acd4:	1b1b      	subs	r3, r3, r4
   1acd6:	4632      	mov	r2, r6
   1acd8:	4641      	mov	r1, r8
   1acda:	4648      	mov	r0, r9
   1acdc:	f000 fee0 	bl	1baa0 <silk_find_pitch_lags_FIX>
        silk_noise_shape_analysis_FIX( psEnc, &sEncCtrl, res_pitch_frame, x_frame, psEnc->sCmn.arch );
   1ace0:	f859 3005 	ldr.w	r3, [r9, r5]
   1ace4:	9300      	str	r3, [sp, #0]
   1ace6:	6dfd      	ldr	r5, [r7, #92]	; 0x5c
        res_pitch_frame = res_pitch + psEnc->sCmn.ltp_mem_length;
   1ace8:	4434      	add	r4, r6
        silk_noise_shape_analysis_FIX( psEnc, &sEncCtrl, res_pitch_frame, x_frame, psEnc->sCmn.arch );
   1acea:	4622      	mov	r2, r4
   1acec:	4641      	mov	r1, r8
   1acee:	462b      	mov	r3, r5
   1acf0:	4648      	mov	r0, r9
   1acf2:	f001 fd27 	bl	1c744 <silk_noise_shape_analysis_FIX>
        silk_find_pred_coefs_FIX( psEnc, &sEncCtrl, res_pitch_frame, x_frame, condCoding );
   1acf6:	4622      	mov	r2, r4
   1acf8:	6e7c      	ldr	r4, [r7, #100]	; 0x64
   1acfa:	9400      	str	r4, [sp, #0]
   1acfc:	462b      	mov	r3, r5
   1acfe:	4641      	mov	r1, r8
   1ad00:	4648      	mov	r0, r9
   1ad02:	f001 f977 	bl	1bff4 <silk_find_pred_coefs_FIX>
        silk_process_gains_FIX( psEnc, &sEncCtrl, condCoding );
   1ad06:	4622      	mov	r2, r4
   1ad08:	4641      	mov	r1, r8
   1ad0a:	4648      	mov	r0, r9
   1ad0c:	f002 fd14 	bl	1d738 <silk_process_gains_FIX>
    silk_nsq_state sNSQ_LBRR;

    /*******************************************/
    /* Control use of inband LBRR              */
    /*******************************************/
    if( psEnc->sCmn.LBRR_enabled && psEnc->sCmn.speech_activity_Q8 > SILK_FIX_CONST( LBRR_SPEECH_ACTIVITY_THRES, 8 ) ) {
   1ad10:	f241 73cc 	movw	r3, #6092	; 0x17cc
   1ad14:	f109 0294 	add.w	r2, r9, #148	; 0x94
   1ad18:	f859 3003 	ldr.w	r3, [r9, r3]
   1ad1c:	62ba      	str	r2, [r7, #40]	; 0x28
   1ad1e:	f509 5294 	add.w	r2, r9, #4736	; 0x1280
   1ad22:	657a      	str	r2, [r7, #84]	; 0x54
   1ad24:	2b00      	cmp	r3, #0
   1ad26:	f000 80bb 	beq.w	1aea0 <silk_encode_frame_FIX+0x2d0>
   1ad2a:	f241 13b4 	movw	r3, #4532	; 0x11b4
   1ad2e:	f859 3003 	ldr.w	r3, [r9, r3]
   1ad32:	2b4d      	cmp	r3, #77	; 0x4d
   1ad34:	f340 80b4 	ble.w	1aea0 <silk_encode_frame_FIX+0x2d0>
    SideInfoIndices *psIndices_LBRR = &psEnc->sCmn.indices_LBRR[ psEnc->sCmn.nFramesEncoded ];
   1ad38:	f241 6374 	movw	r3, #5748	; 0x1674
        psEnc->sCmn.LBRR_flags[ psEnc->sCmn.nFramesEncoded ] = 1;
   1ad3c:	2201      	movs	r2, #1
    SideInfoIndices *psIndices_LBRR = &psEnc->sCmn.indices_LBRR[ psEnc->sCmn.nFramesEncoded ];
   1ad3e:	f859 5003 	ldr.w	r5, [r9, r3]
   1ad42:	ea4f 0ac5 	mov.w	sl, r5, lsl #3
        psEnc->sCmn.LBRR_flags[ psEnc->sCmn.nFramesEncoded ] = 1;
   1ad46:	f205 439c 	addw	r3, r5, #1180	; 0x49c
   1ad4a:	eb09 0383 	add.w	r3, r9, r3, lsl #2
    SideInfoIndices *psIndices_LBRR = &psEnc->sCmn.indices_LBRR[ psEnc->sCmn.nFramesEncoded ];
   1ad4e:	eb0a 0105 	add.w	r1, sl, r5
   1ad52:	eb09 0181 	add.w	r1, r9, r1, lsl #2

        /* Copy noise shaping quantizer state and quantization indices from regular encoding */
        silk_memcpy( &sNSQ_LBRR, &psEnc->sCmn.sNSQ, sizeof( silk_nsq_state ) );
   1ad56:	f507 50c5 	add.w	r0, r7, #6304	; 0x18a0
        psEnc->sCmn.LBRR_flags[ psEnc->sCmn.nFramesEncoded ] = 1;
   1ad5a:	605a      	str	r2, [r3, #4]
    SideInfoIndices *psIndices_LBRR = &psEnc->sCmn.indices_LBRR[ psEnc->sCmn.nFramesEncoded ];
   1ad5c:	f501 5bbe 	add.w	fp, r1, #6080	; 0x17c0
        silk_memcpy( &sNSQ_LBRR, &psEnc->sCmn.sNSQ, sizeof( silk_nsq_state ) );
   1ad60:	f44f 5288 	mov.w	r2, #4352	; 0x1100
   1ad64:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   1ad66:	3018      	adds	r0, #24
   1ad68:	f7f1 f9ca 	bl	c100 <memcpy>
    SideInfoIndices *psIndices_LBRR = &psEnc->sCmn.indices_LBRR[ psEnc->sCmn.nFramesEncoded ];
   1ad6c:	f10b 0b14 	add.w	fp, fp, #20
        silk_memcpy( psIndices_LBRR, &psEnc->sCmn.indices, sizeof( SideInfoIndices ) );
   1ad70:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1ad72:	465a      	mov	r2, fp
   1ad74:	f509 5195 	add.w	r1, r9, #4768	; 0x12a0
   1ad78:	681e      	ldr	r6, [r3, #0]
   1ad7a:	685c      	ldr	r4, [r3, #4]
   1ad7c:	6898      	ldr	r0, [r3, #8]
   1ad7e:	f8d3 c00c 	ldr.w	ip, [r3, #12]
   1ad82:	f8c2 c00c 	str.w	ip, [r2, #12]
   1ad86:	3310      	adds	r3, #16
   1ad88:	428b      	cmp	r3, r1
   1ad8a:	6016      	str	r6, [r2, #0]
   1ad8c:	6054      	str	r4, [r2, #4]
   1ad8e:	6090      	str	r0, [r2, #8]
   1ad90:	f102 0210 	add.w	r2, r2, #16
   1ad94:	d1f0      	bne.n	1ad78 <silk_encode_frame_FIX+0x1a8>
   1ad96:	681b      	ldr	r3, [r3, #0]
   1ad98:	6013      	str	r3, [r2, #0]

        /* Save original gains */
        silk_memcpy( TempGains_Q16, psEncCtrl->Gains_Q16, psEnc->sCmn.nb_subfr * sizeof( opus_int32 ) );
   1ad9a:	f241 13e4 	movw	r3, #4580	; 0x11e4
   1ad9e:	f507 60f7 	add.w	r0, r7, #1976	; 0x7b8
   1ada2:	f859 4003 	ldr.w	r4, [r9, r3]
   1ada6:	6138      	str	r0, [r7, #16]
   1ada8:	00a2      	lsls	r2, r4, #2
   1adaa:	4641      	mov	r1, r8
   1adac:	f7f1 f9a8 	bl	c100 <memcpy>

        if( psEnc->sCmn.nFramesEncoded == 0 || psEnc->sCmn.LBRR_flags[ psEnc->sCmn.nFramesEncoded - 1 ] == 0 ) {
   1adb0:	f241 6374 	movw	r3, #5748	; 0x1674
   1adb4:	f859 3003 	ldr.w	r3, [r9, r3]
   1adb8:	b12b      	cbz	r3, 1adc6 <silk_encode_frame_FIX+0x1f6>
   1adba:	f203 439b 	addw	r3, r3, #1179	; 0x49b
   1adbe:	eb09 0383 	add.w	r3, r9, r3, lsl #2
   1adc2:	685b      	ldr	r3, [r3, #4]
   1adc4:	b9bb      	cbnz	r3, 1adf6 <silk_encode_frame_FIX+0x226>
            /* First frame in packet or previous frame not LBRR coded */
            psEnc->sCmn.LBRRprevLastGainIndex = psEnc->sShape.LastGainIndex;
   1adc6:	f509 51e0 	add.w	r1, r9, #7168	; 0x1c00
   1adca:	f241 12bc 	movw	r2, #4540	; 0x11bc
   1adce:	7809      	ldrb	r1, [r1, #0]
   1add0:	f809 1002 	strb.w	r1, [r9, r2]

            /* Increase Gains to get target LBRR rate */
            psIndices_LBRR->GainsIndices[ 0 ] = psIndices_LBRR->GainsIndices[ 0 ] + psEnc->sCmn.LBRR_GainIncreases;
            psIndices_LBRR->GainsIndices[ 0 ] = silk_min_int( psIndices_LBRR->GainsIndices[ 0 ], N_LEVELS_QGAIN - 1 );
   1add4:	eb0a 0305 	add.w	r3, sl, r5
   1add8:	eb09 0383 	add.w	r3, r9, r3, lsl #2
   1addc:	f241 71d4 	movw	r1, #6100	; 0x17d4
            psIndices_LBRR->GainsIndices[ 0 ] = psIndices_LBRR->GainsIndices[ 0 ] + psEnc->sCmn.LBRR_GainIncreases;
   1ade0:	f241 70d0 	movw	r0, #6096	; 0x17d0
   1ade4:	5c5a      	ldrb	r2, [r3, r1]
   1ade6:	f859 0000 	ldr.w	r0, [r9, r0]
   1adea:	4402      	add	r2, r0
            psIndices_LBRR->GainsIndices[ 0 ] = silk_min_int( psIndices_LBRR->GainsIndices[ 0 ], N_LEVELS_QGAIN - 1 );
   1adec:	b252      	sxtb	r2, r2
   1adee:	2a3f      	cmp	r2, #63	; 0x3f
   1adf0:	bfa8      	it	ge
   1adf2:	223f      	movge	r2, #63	; 0x3f
   1adf4:	545a      	strb	r2, [r3, r1]
        }

        /* Decode to get gains in sync with decoder         */
        /* Overwrite unquantized gains with quantized gains */
        silk_gains_dequant( psEncCtrl->Gains_Q16, psIndices_LBRR->GainsIndices,
   1adf6:	9400      	str	r4, [sp, #0]
   1adf8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   1adfa:	f1a3 0302 	sub.w	r3, r3, #2
   1adfe:	f509 528d 	add.w	r2, r9, #4512	; 0x11a0
   1ae02:	fab3 f383 	clz	r3, r3
   1ae06:	095b      	lsrs	r3, r3, #5
   1ae08:	321c      	adds	r2, #28
   1ae0a:	4659      	mov	r1, fp
   1ae0c:	4640      	mov	r0, r8
   1ae0e:	f7f4 ff01 	bl	fc14 <silk_gains_dequant>
            &psEnc->sCmn.LBRRprevLastGainIndex, condCoding == CODE_CONDITIONALLY, psEnc->sCmn.nb_subfr );

        /*****************************************/
        /* Noise shaping quantization            */
        /*****************************************/
        if( psEnc->sCmn.nStatesDelayedDecision > 1 || psEnc->sCmn.warping_Q16 > 0 ) {
   1ae12:	f241 2314 	movw	r3, #4628	; 0x1214
   1ae16:	f859 3003 	ldr.w	r3, [r9, r3]
   1ae1a:	2b01      	cmp	r3, #1
   1ae1c:	f241 6374 	movw	r3, #5748	; 0x1674
   1ae20:	f300 8447 	bgt.w	1b6b2 <silk_encode_frame_FIX+0xae2>
   1ae24:	f509 5292 	add.w	r2, r9, #4672	; 0x1240
   1ae28:	f859 3003 	ldr.w	r3, [r9, r3]
   1ae2c:	6810      	ldr	r0, [r2, #0]
   1ae2e:	f8d8 1078 	ldr.w	r1, [r8, #120]	; 0x78
   1ae32:	f8d8 217c 	ldr.w	r2, [r8, #380]	; 0x17c
   1ae36:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   1ae3a:	eb09 1383 	add.w	r3, r9, r3, lsl #6
   1ae3e:	2800      	cmp	r0, #0
   1ae40:	f503 53c2 	add.w	r3, r3, #6208	; 0x1840
   1ae44:	f340 8443 	ble.w	1b6ce <silk_encode_frame_FIX+0xafe>
            silk_NSQ_del_dec( &psEnc->sCmn, &sNSQ_LBRR, psIndices_LBRR, x16,
   1ae48:	f108 007c 	add.w	r0, r8, #124	; 0x7c
   1ae4c:	f508 74a6 	add.w	r4, r8, #332	; 0x14c
   1ae50:	f508 75ae 	add.w	r5, r8, #348	; 0x15c
   1ae54:	9300      	str	r3, [sp, #0]
   1ae56:	9008      	str	r0, [sp, #32]
   1ae58:	f508 73b6 	add.w	r3, r8, #364	; 0x16c
   1ae5c:	f108 008c 	add.w	r0, r8, #140	; 0x8c
   1ae60:	9406      	str	r4, [sp, #24]
   1ae62:	9505      	str	r5, [sp, #20]
   1ae64:	f108 0450 	add.w	r4, r8, #80	; 0x50
   1ae68:	f108 0510 	add.w	r5, r8, #16
   1ae6c:	e9cd 0303 	strd	r0, r3, [sp, #12]
   1ae70:	e9cd 5401 	strd	r5, r4, [sp, #4]
   1ae74:	910a      	str	r1, [sp, #40]	; 0x28
   1ae76:	9209      	str	r2, [sp, #36]	; 0x24
   1ae78:	f8cd 801c 	str.w	r8, [sp, #28]
   1ae7c:	f507 51c5 	add.w	r1, r7, #6304	; 0x18a0
   1ae80:	465a      	mov	r2, fp
   1ae82:	3118      	adds	r1, #24
   1ae84:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   1ae86:	4648      	mov	r0, r9
   1ae88:	f7f6 f9d8 	bl	1123c <silk_NSQ_del_dec_c>
                psEncCtrl->AR_Q13, psEncCtrl->HarmShapeGain_Q14, psEncCtrl->Tilt_Q14, psEncCtrl->LF_shp_Q14,
                psEncCtrl->Gains_Q16, psEncCtrl->pitchL, psEncCtrl->Lambda_Q10, psEncCtrl->LTP_scale_Q14, psEnc->sCmn.arch );
        }

        /* Restore original gains */
        silk_memcpy( psEncCtrl->Gains_Q16, TempGains_Q16, psEnc->sCmn.nb_subfr * sizeof( opus_int32 ) );
   1ae8c:	f241 13e4 	movw	r3, #4580	; 0x11e4
   1ae90:	6939      	ldr	r1, [r7, #16]
   1ae92:	f859 4003 	ldr.w	r4, [r9, r3]
   1ae96:	4640      	mov	r0, r8
   1ae98:	00a2      	lsls	r2, r4, #2
   1ae9a:	f7f1 f931 	bl	c100 <memcpy>
   1ae9e:	e006      	b.n	1aeae <silk_encode_frame_FIX+0x2de>
   1aea0:	f241 13e4 	movw	r3, #4580	; 0x11e4
   1aea4:	f507 62f7 	add.w	r2, r7, #1976	; 0x7b8
   1aea8:	f859 4003 	ldr.w	r4, [r9, r3]
   1aeac:	613a      	str	r2, [r7, #16]
        gainsID = silk_gains_ID( psEnc->sCmn.indices.GainsIndices, psEnc->sCmn.nb_subfr );
   1aeae:	4621      	mov	r1, r4
   1aeb0:	6d78      	ldr	r0, [r7, #84]	; 0x54
   1aeb2:	f7f4 ff2f 	bl	fd14 <silk_gains_ID>
        silk_memcpy( &sRangeEnc_copy, psRangeEnc, sizeof( ec_enc ) );
   1aeb6:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   1aeb8:	461c      	mov	r4, r3
   1aeba:	3330      	adds	r3, #48	; 0x30
        gainsID = silk_gains_ID( psEnc->sCmn.indices.GainsIndices, psEnc->sCmn.nb_subfr );
   1aebc:	4605      	mov	r5, r0
        silk_memcpy( &sRangeEnc_copy, psRangeEnc, sizeof( ec_enc ) );
   1aebe:	f107 0c98 	add.w	ip, r7, #152	; 0x98
   1aec2:	61bb      	str	r3, [r7, #24]
   1aec4:	68e3      	ldr	r3, [r4, #12]
   1aec6:	6820      	ldr	r0, [r4, #0]
   1aec8:	6861      	ldr	r1, [r4, #4]
   1aeca:	68a2      	ldr	r2, [r4, #8]
   1aecc:	4666      	mov	r6, ip
   1aece:	c60f      	stmia	r6!, {r0, r1, r2, r3}
   1aed0:	69bb      	ldr	r3, [r7, #24]
   1aed2:	3410      	adds	r4, #16
   1aed4:	429c      	cmp	r4, r3
   1aed6:	46b4      	mov	ip, r6
   1aed8:	d1f4      	bne.n	1aec4 <silk_encode_frame_FIX+0x2f4>
        silk_memcpy( &sNSQ_copy, &psEnc->sCmn.sNSQ, sizeof( silk_nsq_state ) );
   1aeda:	f44f 5288 	mov.w	r2, #4352	; 0x1100
   1aede:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   1aee0:	6938      	ldr	r0, [r7, #16]
   1aee2:	f7f1 f90d 	bl	c100 <memcpy>
        seed_copy = psEnc->sCmn.indices.Seed;
   1aee6:	f241 21a2 	movw	r1, #4770	; 0x12a2
        ec_prevLagIndex_copy = psEnc->sCmn.ec_prevLagIndex;
   1aeea:	f241 628c 	movw	r2, #5772	; 0x168c
        ec_prevSignalType_copy = psEnc->sCmn.ec_prevSignalType;
   1aeee:	f241 6388 	movw	r3, #5768	; 0x1688
        seed_copy = psEnc->sCmn.indices.Seed;
   1aef2:	f919 1001 	ldrsb.w	r1, [r9, r1]
        ec_prevLagIndex_copy = psEnc->sCmn.ec_prevLagIndex;
   1aef6:	f939 2002 	ldrsh.w	r2, [r9, r2]
        ec_prevSignalType_copy = psEnc->sCmn.ec_prevSignalType;
   1aefa:	f859 3003 	ldr.w	r3, [r9, r3]
        seed_copy = psEnc->sCmn.indices.Seed;
   1aefe:	6039      	str	r1, [r7, #0]
        ec_prevLagIndex_copy = psEnc->sCmn.ec_prevLagIndex;
   1af00:	60ba      	str	r2, [r7, #8]
   1af02:	f509 518f 	add.w	r1, r9, #4576	; 0x11e0
        gainsID_upper = -1;
   1af06:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
        ec_prevSignalType_copy = psEnc->sCmn.ec_prevSignalType;
   1af0a:	607b      	str	r3, [r7, #4]
        gainsID_upper = -1;
   1af0c:	2300      	movs	r3, #0
   1af0e:	e9c7 2311 	strd	r2, r3, [r7, #68]	; 0x44
        for( iter = 0; ; iter++ ) {
   1af12:	66bb      	str	r3, [r7, #104]	; 0x68
    LastGainIndex_copy2 = nBits_lower = nBits_upper = gainMult_lower = gainMult_upper = 0;
   1af14:	60fb      	str	r3, [r7, #12]
   1af16:	e9c7 330b 	strd	r3, r3, [r7, #44]	; 0x2c
   1af1a:	637b      	str	r3, [r7, #52]	; 0x34
   1af1c:	643b      	str	r3, [r7, #64]	; 0x40
   1af1e:	1d0b      	adds	r3, r1, #4
   1af20:	61fb      	str	r3, [r7, #28]
                    for ( j = i*psEnc->sCmn.subfr_length; j < (i+1)*psEnc->sCmn.subfr_length; j++ ) {
   1af22:	f101 030c 	add.w	r3, r1, #12
   1af26:	623b      	str	r3, [r7, #32]
        gainMult_Q8 = SILK_FIX_CONST( 1, 8 );
   1af28:	f44f 7380 	mov.w	r3, #256	; 0x100
   1af2c:	66fb      	str	r3, [r7, #108]	; 0x6c
        gainsID_lower = -1;
   1af2e:	65ba      	str	r2, [r7, #88]	; 0x58
   1af30:	4613      	mov	r3, r2
   1af32:	e135      	b.n	1b1a0 <silk_encode_frame_FIX+0x5d0>
            } else if( gainsID == gainsID_upper ) {
   1af34:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   1af36:	429d      	cmp	r5, r3
   1af38:	f000 81ac 	beq.w	1b294 <silk_encode_frame_FIX+0x6c4>
                if( iter > 0 ) {
   1af3c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   1af3e:	2b00      	cmp	r3, #0
   1af40:	f040 81db 	bne.w	1b2fa <silk_encode_frame_FIX+0x72a>
                if( psEnc->sCmn.nStatesDelayedDecision > 1 || psEnc->sCmn.warping_Q16 > 0 ) {
   1af44:	f241 2314 	movw	r3, #4628	; 0x1214
   1af48:	f509 5695 	add.w	r6, r9, #4768	; 0x12a0
   1af4c:	f859 1003 	ldr.w	r1, [r9, r3]
   1af50:	f8d8 2078 	ldr.w	r2, [r8, #120]	; 0x78
   1af54:	f8d8 317c 	ldr.w	r3, [r8, #380]	; 0x17c
   1af58:	2901      	cmp	r1, #1
   1af5a:	f106 0604 	add.w	r6, r6, #4
                    silk_NSQ_del_dec( &psEnc->sCmn, &psEnc->sCmn.sNSQ, &psEnc->sCmn.indices, x_frame, psEnc->sCmn.pulses,
   1af5e:	f108 047c 	add.w	r4, r8, #124	; 0x7c
   1af62:	f508 70a6 	add.w	r0, r8, #332	; 0x14c
                if( psEnc->sCmn.nStatesDelayedDecision > 1 || psEnc->sCmn.warping_Q16 > 0 ) {
   1af66:	dc05      	bgt.n	1af74 <silk_encode_frame_FIX+0x3a4>
   1af68:	f509 5192 	add.w	r1, r9, #4672	; 0x1240
   1af6c:	6809      	ldr	r1, [r1, #0]
   1af6e:	2900      	cmp	r1, #0
   1af70:	f340 8382 	ble.w	1b678 <silk_encode_frame_FIX+0xaa8>
                    silk_NSQ_del_dec( &psEnc->sCmn, &psEnc->sCmn.sNSQ, &psEnc->sCmn.indices, x_frame, psEnc->sCmn.pulses,
   1af74:	920a      	str	r2, [sp, #40]	; 0x28
   1af76:	9408      	str	r4, [sp, #32]
   1af78:	f508 71ae 	add.w	r1, r8, #348	; 0x15c
   1af7c:	f508 72b6 	add.w	r2, r8, #364	; 0x16c
   1af80:	f108 0c8c 	add.w	ip, r8, #140	; 0x8c
   1af84:	f108 0450 	add.w	r4, r8, #80	; 0x50
   1af88:	e9cd 2104 	strd	r2, r1, [sp, #16]
   1af8c:	e9cd 4c02 	strd	r4, ip, [sp, #8]
   1af90:	9309      	str	r3, [sp, #36]	; 0x24
   1af92:	f108 0310 	add.w	r3, r8, #16
   1af96:	9006      	str	r0, [sp, #24]
   1af98:	f8cd 801c 	str.w	r8, [sp, #28]
   1af9c:	9600      	str	r6, [sp, #0]
   1af9e:	9301      	str	r3, [sp, #4]
   1afa0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   1afa2:	6d7a      	ldr	r2, [r7, #84]	; 0x54
   1afa4:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   1afa6:	4648      	mov	r0, r9
   1afa8:	f7f6 f948 	bl	1123c <silk_NSQ_del_dec_c>
                if ( iter == maxIter && !found_lower ) {
   1afac:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   1afae:	2b06      	cmp	r3, #6
   1afb0:	f000 82e2 	beq.w	1b578 <silk_encode_frame_FIX+0x9a8>
                silk_encode_indices( &psEnc->sCmn, psRangeEnc, psEnc->sCmn.nFramesEncoded, 0, condCoding );
   1afb4:	f241 6274 	movw	r2, #5748	; 0x1674
   1afb8:	6e79      	ldr	r1, [r7, #100]	; 0x64
   1afba:	f859 2002 	ldr.w	r2, [r9, r2]
   1afbe:	9100      	str	r1, [sp, #0]
   1afc0:	6e3c      	ldr	r4, [r7, #96]	; 0x60
   1afc2:	2300      	movs	r3, #0
   1afc4:	4621      	mov	r1, r4
   1afc6:	4648      	mov	r0, r9
   1afc8:	f7f4 f91a 	bl	f200 <silk_encode_indices>
                silk_encode_pulses( psRangeEnc, psEnc->sCmn.indices.signalType, psEnc->sCmn.indices.quantOffsetType,
   1afcc:	f241 13e8 	movw	r3, #4584	; 0x11e8
   1afd0:	f241 229e 	movw	r2, #4766	; 0x129e
   1afd4:	f241 219d 	movw	r1, #4765	; 0x129d
   1afd8:	f859 3003 	ldr.w	r3, [r9, r3]
   1afdc:	f919 2002 	ldrsb.w	r2, [r9, r2]
   1afe0:	f919 1001 	ldrsb.w	r1, [r9, r1]
   1afe4:	9300      	str	r3, [sp, #0]
   1afe6:	4620      	mov	r0, r4
   1afe8:	4633      	mov	r3, r6
   1afea:	f7f4 faa1 	bl	f530 <silk_encode_pulses>
   1afee:	69e3      	ldr	r3, [r4, #28]
   1aff0:	6964      	ldr	r4, [r4, #20]
   1aff2:	fab3 f383 	clz	r3, r3
   1aff6:	f1c3 0320 	rsb	r3, r3, #32
   1affa:	1ae4      	subs	r4, r4, r3
                if( useCBR == 0 && iter == 0 && nBits <= maxBits ) {
   1affc:	f507 5327 	add.w	r3, r7, #10688	; 0x29c0
   1b000:	3324      	adds	r3, #36	; 0x24
   1b002:	681b      	ldr	r3, [r3, #0]
   1b004:	2b00      	cmp	r3, #0
   1b006:	f000 832b 	beq.w	1b660 <silk_encode_frame_FIX+0xa90>
            if( nBits > maxBits ) {
   1b00a:	f507 5327 	add.w	r3, r7, #10688	; 0x29c0
   1b00e:	3320      	adds	r3, #32
   1b010:	681b      	ldr	r3, [r3, #0]
   1b012:	42a3      	cmp	r3, r4
   1b014:	f2c0 80d3 	blt.w	1b1be <silk_encode_frame_FIX+0x5ee>
            } else if( nBits < maxBits - 5 ) {
   1b018:	f507 5327 	add.w	r3, r7, #10688	; 0x29c0
   1b01c:	3320      	adds	r3, #32
   1b01e:	681b      	ldr	r3, [r3, #0]
   1b020:	3b05      	subs	r3, #5
   1b022:	42a3      	cmp	r3, r4
   1b024:	f340 8263 	ble.w	1b4ee <silk_encode_frame_FIX+0x91e>
                gainMult_lower = gainMult_Q8;
   1b028:	6efb      	ldr	r3, [r7, #108]	; 0x6c
   1b02a:	62fb      	str	r3, [r7, #44]	; 0x2c
                if( gainsID != gainsID_lower ) {
   1b02c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   1b02e:	429d      	cmp	r5, r3
   1b030:	f040 8189 	bne.w	1b346 <silk_encode_frame_FIX+0x776>
            if( ( found_lower & found_upper ) == 0 ) {
   1b034:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   1b036:	f509 56e0 	add.w	r6, r9, #7168	; 0x1c00
   1b03a:	2b00      	cmp	r3, #0
   1b03c:	f040 81aa 	bne.w	1b394 <silk_encode_frame_FIX+0x7c4>
                    gain_factor_Q16 = silk_log2lin( silk_LSHIFT( nBits - maxBits, 7 ) / psEnc->sCmn.frame_length + SILK_FIX_CONST( 16, 7 ) );
   1b040:	f507 5227 	add.w	r2, r7, #10688	; 0x29c0
   1b044:	3220      	adds	r2, #32
   1b046:	f241 13e8 	movw	r3, #4584	; 0x11e8
   1b04a:	6812      	ldr	r2, [r2, #0]
   1b04c:	f859 3003 	ldr.w	r3, [r9, r3]
   1b050:	1aa0      	subs	r0, r4, r2
   1b052:	01c0      	lsls	r0, r0, #7
   1b054:	fb90 f0f3 	sdiv	r0, r0, r3
   1b058:	f500 6000 	add.w	r0, r0, #2048	; 0x800
   1b05c:	f7fc fcec 	bl	17a38 <silk_log2lin>
                    gainMult_Q8 = silk_SMULWB( gain_factor_Q16, gainMult_Q8 );
   1b060:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
   1b062:	65bd      	str	r5, [r7, #88]	; 0x58
   1b064:	b282      	uxth	r2, r0
   1b066:	1403      	asrs	r3, r0, #16
   1b068:	fb01 f202 	mul.w	r2, r1, r2
   1b06c:	fb13 f301 	smulbb	r3, r3, r1
   1b070:	eb03 4322 	add.w	r3, r3, r2, asr #16
   1b074:	b21b      	sxth	r3, r3
   1b076:	66fb      	str	r3, [r7, #108]	; 0x6c
   1b078:	69fd      	ldr	r5, [r7, #28]
   1b07a:	643c      	str	r4, [r7, #64]	; 0x40
   1b07c:	2301      	movs	r3, #1
   1b07e:	64bb      	str	r3, [r7, #72]	; 0x48
            for( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1b080:	6829      	ldr	r1, [r5, #0]
   1b082:	2900      	cmp	r1, #0
   1b084:	dd73      	ble.n	1b16e <silk_encode_frame_FIX+0x59e>
                if ( gain_lock[i] ) {
   1b086:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   1b088:	2b00      	cmp	r3, #0
   1b08a:	f000 80eb 	beq.w	1b264 <silk_encode_frame_FIX+0x694>
                    tmp = best_gain_mult[i];
   1b08e:	f9b7 3070 	ldrsh.w	r3, [r7, #112]	; 0x70
                sEncCtrl.Gains_Q16[ i ] = silk_LSHIFT_SAT32( silk_SMULWB( sEncCtrl.GainsUnq_Q16[ i ], tmp ), 8 );
   1b092:	f8d8 21b0 	ldr.w	r2, [r8, #432]	; 0x1b0
   1b096:	b290      	uxth	r0, r2
   1b098:	1412      	asrs	r2, r2, #16
   1b09a:	fb03 f000 	mul.w	r0, r3, r0
   1b09e:	fb03 f302 	mul.w	r3, r3, r2
   1b0a2:	eb03 4320 	add.w	r3, r3, r0, asr #16
   1b0a6:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
   1b0aa:	f280 80d9 	bge.w	1b260 <silk_encode_frame_FIX+0x690>
   1b0ae:	f513 0f00 	cmn.w	r3, #8388608	; 0x800000
   1b0b2:	f2c0 825c 	blt.w	1b56e <silk_encode_frame_FIX+0x99e>
   1b0b6:	021b      	lsls	r3, r3, #8
            for( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1b0b8:	2901      	cmp	r1, #1
                sEncCtrl.Gains_Q16[ i ] = silk_LSHIFT_SAT32( silk_SMULWB( sEncCtrl.GainsUnq_Q16[ i ], tmp ), 8 );
   1b0ba:	f8c8 3000 	str.w	r3, [r8]
            for( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1b0be:	d056      	beq.n	1b16e <silk_encode_frame_FIX+0x59e>
                if ( gain_lock[i] ) {
   1b0c0:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
   1b0c2:	2b00      	cmp	r3, #0
   1b0c4:	f000 80e2 	beq.w	1b28c <silk_encode_frame_FIX+0x6bc>
                    tmp = best_gain_mult[i];
   1b0c8:	f9b7 3072 	ldrsh.w	r3, [r7, #114]	; 0x72
                sEncCtrl.Gains_Q16[ i ] = silk_LSHIFT_SAT32( silk_SMULWB( sEncCtrl.GainsUnq_Q16[ i ], tmp ), 8 );
   1b0cc:	f8d8 21b4 	ldr.w	r2, [r8, #436]	; 0x1b4
   1b0d0:	b290      	uxth	r0, r2
   1b0d2:	1412      	asrs	r2, r2, #16
   1b0d4:	fb03 f000 	mul.w	r0, r3, r0
   1b0d8:	fb03 f302 	mul.w	r3, r3, r2
   1b0dc:	eb03 4320 	add.w	r3, r3, r0, asr #16
   1b0e0:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
   1b0e4:	f280 80d4 	bge.w	1b290 <silk_encode_frame_FIX+0x6c0>
   1b0e8:	f513 0f00 	cmn.w	r3, #8388608	; 0x800000
   1b0ec:	f2c0 82a6 	blt.w	1b63c <silk_encode_frame_FIX+0xa6c>
   1b0f0:	021b      	lsls	r3, r3, #8
            for( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1b0f2:	2902      	cmp	r1, #2
                sEncCtrl.Gains_Q16[ i ] = silk_LSHIFT_SAT32( silk_SMULWB( sEncCtrl.GainsUnq_Q16[ i ], tmp ), 8 );
   1b0f4:	f8c8 3004 	str.w	r3, [r8, #4]
            for( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1b0f8:	d039      	beq.n	1b16e <silk_encode_frame_FIX+0x59e>
                if ( gain_lock[i] ) {
   1b0fa:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   1b0fe:	2b00      	cmp	r3, #0
   1b100:	f000 80ef 	beq.w	1b2e2 <silk_encode_frame_FIX+0x712>
                    tmp = best_gain_mult[i];
   1b104:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
                sEncCtrl.Gains_Q16[ i ] = silk_LSHIFT_SAT32( silk_SMULWB( sEncCtrl.GainsUnq_Q16[ i ], tmp ), 8 );
   1b108:	f8d8 21b8 	ldr.w	r2, [r8, #440]	; 0x1b8
   1b10c:	b290      	uxth	r0, r2
   1b10e:	1412      	asrs	r2, r2, #16
   1b110:	fb03 f000 	mul.w	r0, r3, r0
   1b114:	fb03 f302 	mul.w	r3, r3, r2
   1b118:	eb03 4320 	add.w	r3, r3, r0, asr #16
   1b11c:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
   1b120:	f280 80dd 	bge.w	1b2de <silk_encode_frame_FIX+0x70e>
   1b124:	f513 0f00 	cmn.w	r3, #8388608	; 0x800000
   1b128:	f2c0 828b 	blt.w	1b642 <silk_encode_frame_FIX+0xa72>
   1b12c:	021b      	lsls	r3, r3, #8
            for( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1b12e:	2903      	cmp	r1, #3
                sEncCtrl.Gains_Q16[ i ] = silk_LSHIFT_SAT32( silk_SMULWB( sEncCtrl.GainsUnq_Q16[ i ], tmp ), 8 );
   1b130:	f8c8 3008 	str.w	r3, [r8, #8]
            for( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1b134:	d01b      	beq.n	1b16e <silk_encode_frame_FIX+0x59e>
                if ( gain_lock[i] ) {
   1b136:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
   1b13a:	2b00      	cmp	r3, #0
   1b13c:	f000 8132 	beq.w	1b3a4 <silk_encode_frame_FIX+0x7d4>
                    tmp = best_gain_mult[i];
   1b140:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
                sEncCtrl.Gains_Q16[ i ] = silk_LSHIFT_SAT32( silk_SMULWB( sEncCtrl.GainsUnq_Q16[ i ], tmp ), 8 );
   1b144:	f8d8 21bc 	ldr.w	r2, [r8, #444]	; 0x1bc
   1b148:	b290      	uxth	r0, r2
   1b14a:	1412      	asrs	r2, r2, #16
   1b14c:	fb03 f000 	mul.w	r0, r3, r0
   1b150:	fb03 f302 	mul.w	r3, r3, r2
   1b154:	eb03 4320 	add.w	r3, r3, r0, asr #16
   1b158:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
   1b15c:	f280 8120 	bge.w	1b3a0 <silk_encode_frame_FIX+0x7d0>
   1b160:	f513 0f00 	cmn.w	r3, #8388608	; 0x800000
   1b164:	f2c0 8270 	blt.w	1b648 <silk_encode_frame_FIX+0xa78>
   1b168:	021b      	lsls	r3, r3, #8
   1b16a:	f8c8 300c 	str.w	r3, [r8, #12]
            psEnc->sShape.LastGainIndex = sEncCtrl.lastGainIndexPrev;
   1b16e:	f898 31c0 	ldrb.w	r3, [r8, #448]	; 0x1c0
   1b172:	7033      	strb	r3, [r6, #0]
            silk_gains_quant( psEnc->sCmn.indices.GainsIndices, sEncCtrl.Gains_Q16,
   1b174:	9100      	str	r1, [sp, #0]
   1b176:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   1b178:	6d7c      	ldr	r4, [r7, #84]	; 0x54
   1b17a:	f1a3 0302 	sub.w	r3, r3, #2
   1b17e:	fab3 f383 	clz	r3, r3
   1b182:	4632      	mov	r2, r6
   1b184:	095b      	lsrs	r3, r3, #5
   1b186:	4641      	mov	r1, r8
   1b188:	4620      	mov	r0, r4
   1b18a:	f7f4 fcab 	bl	fae4 <silk_gains_quant>
        for( iter = 0; ; iter++ ) {
   1b18e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
            gainsID = silk_gains_ID( psEnc->sCmn.indices.GainsIndices, psEnc->sCmn.nb_subfr );
   1b190:	6829      	ldr	r1, [r5, #0]
        for( iter = 0; ; iter++ ) {
   1b192:	3301      	adds	r3, #1
            gainsID = silk_gains_ID( psEnc->sCmn.indices.GainsIndices, psEnc->sCmn.nb_subfr );
   1b194:	4620      	mov	r0, r4
        for( iter = 0; ; iter++ ) {
   1b196:	66bb      	str	r3, [r7, #104]	; 0x68
            gainsID = silk_gains_ID( psEnc->sCmn.indices.GainsIndices, psEnc->sCmn.nb_subfr );
   1b198:	f7f4 fdbc 	bl	fd14 <silk_gains_ID>
   1b19c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   1b19e:	4605      	mov	r5, r0
            if( gainsID == gainsID_lower ) {
   1b1a0:	429d      	cmp	r5, r3
   1b1a2:	f47f aec7 	bne.w	1af34 <silk_encode_frame_FIX+0x364>
                nBits = nBits_lower;
   1b1a6:	6c3c      	ldr	r4, [r7, #64]	; 0x40
            if( iter == maxIter ) {
   1b1a8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   1b1aa:	2b06      	cmp	r3, #6
   1b1ac:	f000 8211 	beq.w	1b5d2 <silk_encode_frame_FIX+0xa02>
            if( nBits > maxBits ) {
   1b1b0:	f507 5327 	add.w	r3, r7, #10688	; 0x29c0
   1b1b4:	3320      	adds	r3, #32
   1b1b6:	681b      	ldr	r3, [r3, #0]
   1b1b8:	42a3      	cmp	r3, r4
   1b1ba:	f6bf af2d 	bge.w	1b018 <silk_encode_frame_FIX+0x448>
                if( found_lower == 0 && iter >= 2 ) {
   1b1be:	6cba      	ldr	r2, [r7, #72]	; 0x48
   1b1c0:	2a00      	cmp	r2, #0
   1b1c2:	d169      	bne.n	1b298 <silk_encode_frame_FIX+0x6c8>
   1b1c4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   1b1c6:	2b01      	cmp	r3, #1
   1b1c8:	f340 8243 	ble.w	1b652 <silk_encode_frame_FIX+0xa82>
                    sEncCtrl.Lambda_Q10 = silk_ADD_RSHIFT32( sEncCtrl.Lambda_Q10, sEncCtrl.Lambda_Q10, 1 );
   1b1cc:	f8d8 317c 	ldr.w	r3, [r8, #380]	; 0x17c
                    found_upper = 0;
   1b1d0:	64fa      	str	r2, [r7, #76]	; 0x4c
                    sEncCtrl.Lambda_Q10 = silk_ADD_RSHIFT32( sEncCtrl.Lambda_Q10, sEncCtrl.Lambda_Q10, 1 );
   1b1d2:	eb03 0363 	add.w	r3, r3, r3, asr #1
   1b1d6:	f8c8 317c 	str.w	r3, [r8, #380]	; 0x17c
                    gainsID_upper = -1;
   1b1da:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1b1de:	647b      	str	r3, [r7, #68]	; 0x44
                for ( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1b1e0:	f241 13e4 	movw	r3, #4580	; 0x11e4
   1b1e4:	2100      	movs	r1, #0
   1b1e6:	f859 e003 	ldr.w	lr, [r9, r3]
   1b1ea:	f241 24a4 	movw	r4, #4772	; 0x12a4
   1b1ee:	eb09 0503 	add.w	r5, r9, r3
   1b1f2:	4571      	cmp	r1, lr
                        best_gain_mult[i] = gainMult_Q8;
   1b1f4:	f107 0370 	add.w	r3, r7, #112	; 0x70
   1b1f8:	eb09 0c04 	add.w	ip, r9, r4
   1b1fc:	627b      	str	r3, [r7, #36]	; 0x24
                    if ( iter == 0 || (sum < best_sum[i] && !gain_lock[i]) ) {
   1b1fe:	f107 0688 	add.w	r6, r7, #136	; 0x88
                for ( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1b202:	da22      	bge.n	1b24a <silk_encode_frame_FIX+0x67a>
                    for ( j = i*psEnc->sCmn.subfr_length; j < (i+1)*psEnc->sCmn.subfr_length; j++ ) {
   1b204:	6a3b      	ldr	r3, [r7, #32]
   1b206:	681b      	ldr	r3, [r3, #0]
   1b208:	1c48      	adds	r0, r1, #1
   1b20a:	fb03 fa01 	mul.w	sl, r3, r1
   1b20e:	fb03 fb00 	mul.w	fp, r3, r0
   1b212:	45da      	cmp	sl, fp
   1b214:	f280 821b 	bge.w	1b64e <silk_encode_frame_FIX+0xa7e>
   1b218:	44a2      	add	sl, r4
   1b21a:	44ca      	add	sl, r9
   1b21c:	44e3      	add	fp, ip
                    int sum=0;
   1b21e:	2200      	movs	r2, #0
                        sum += abs( psEnc->sCmn.pulses[j] );
   1b220:	f91a 3b01 	ldrsb.w	r3, [sl], #1
   1b224:	2b00      	cmp	r3, #0
   1b226:	bfb8      	it	lt
   1b228:	425b      	neglt	r3, r3
                    for ( j = i*psEnc->sCmn.subfr_length; j < (i+1)*psEnc->sCmn.subfr_length; j++ ) {
   1b22a:	45da      	cmp	sl, fp
                        sum += abs( psEnc->sCmn.pulses[j] );
   1b22c:	441a      	add	r2, r3
                    for ( j = i*psEnc->sCmn.subfr_length; j < (i+1)*psEnc->sCmn.subfr_length; j++ ) {
   1b22e:	d1f7      	bne.n	1b220 <silk_encode_frame_FIX+0x650>
                    if ( iter == 0 || (sum < best_sum[i] && !gain_lock[i]) ) {
   1b230:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   1b232:	b9cb      	cbnz	r3, 1b268 <silk_encode_frame_FIX+0x698>
   1b234:	f107 0a88 	add.w	sl, r7, #136	; 0x88
                        best_gain_mult[i] = gainMult_Q8;
   1b238:	6a7b      	ldr	r3, [r7, #36]	; 0x24
                        best_sum[i] = sum;
   1b23a:	f84a 2021 	str.w	r2, [sl, r1, lsl #2]
                        best_gain_mult[i] = gainMult_Q8;
   1b23e:	6efa      	ldr	r2, [r7, #108]	; 0x6c
   1b240:	f823 2011 	strh.w	r2, [r3, r1, lsl #1]
                    int sum=0;
   1b244:	4601      	mov	r1, r0
                for ( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1b246:	4571      	cmp	r1, lr
   1b248:	dbdc      	blt.n	1b204 <silk_encode_frame_FIX+0x634>
                    if (gainMult_Q8 < 16384) {
   1b24a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
   1b24c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
   1b250:	f2c0 81ee 	blt.w	1b630 <silk_encode_frame_FIX+0xa60>
                        gainMult_Q8 = 32767;
   1b254:	f647 73ff 	movw	r3, #32767	; 0x7fff
   1b258:	66fb      	str	r3, [r7, #108]	; 0x6c
   1b25a:	f509 56e0 	add.w	r6, r9, #7168	; 0x1c00
   1b25e:	e70f      	b.n	1b080 <silk_encode_frame_FIX+0x4b0>
                sEncCtrl.Gains_Q16[ i ] = silk_LSHIFT_SAT32( silk_SMULWB( sEncCtrl.GainsUnq_Q16[ i ], tmp ), 8 );
   1b260:	4bc4      	ldr	r3, [pc, #784]	; (1b574 <silk_encode_frame_FIX+0x9a4>)
   1b262:	e729      	b.n	1b0b8 <silk_encode_frame_FIX+0x4e8>
                    tmp = gainMult_Q8;
   1b264:	6efb      	ldr	r3, [r7, #108]	; 0x6c
   1b266:	e714      	b.n	1b092 <silk_encode_frame_FIX+0x4c2>
                    if ( iter == 0 || (sum < best_sum[i] && !gain_lock[i]) ) {
   1b268:	f856 3021 	ldr.w	r3, [r6, r1, lsl #2]
   1b26c:	4293      	cmp	r3, r2
   1b26e:	46b2      	mov	sl, r6
   1b270:	dd05      	ble.n	1b27e <silk_encode_frame_FIX+0x6ae>
   1b272:	f107 0378 	add.w	r3, r7, #120	; 0x78
   1b276:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   1b27a:	2b00      	cmp	r3, #0
   1b27c:	d0dc      	beq.n	1b238 <silk_encode_frame_FIX+0x668>
                        gain_lock[i] = 1;
   1b27e:	f107 0278 	add.w	r2, r7, #120	; 0x78
   1b282:	2301      	movs	r3, #1
   1b284:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
                    int sum=0;
   1b288:	4601      	mov	r1, r0
   1b28a:	e7dc      	b.n	1b246 <silk_encode_frame_FIX+0x676>
                    tmp = gainMult_Q8;
   1b28c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
   1b28e:	e71d      	b.n	1b0cc <silk_encode_frame_FIX+0x4fc>
                sEncCtrl.Gains_Q16[ i ] = silk_LSHIFT_SAT32( silk_SMULWB( sEncCtrl.GainsUnq_Q16[ i ], tmp ), 8 );
   1b290:	4bb8      	ldr	r3, [pc, #736]	; (1b574 <silk_encode_frame_FIX+0x9a4>)
   1b292:	e72e      	b.n	1b0f2 <silk_encode_frame_FIX+0x522>
                nBits = nBits_upper;
   1b294:	6b7c      	ldr	r4, [r7, #52]	; 0x34
   1b296:	e787      	b.n	1b1a8 <silk_encode_frame_FIX+0x5d8>
                    gainMult_upper = gainMult_Q8;
   1b298:	6efb      	ldr	r3, [r7, #108]	; 0x6c
   1b29a:	6c38      	ldr	r0, [r7, #64]	; 0x40
   1b29c:	633b      	str	r3, [r7, #48]	; 0x30
   1b29e:	647d      	str	r5, [r7, #68]	; 0x44
   1b2a0:	637c      	str	r4, [r7, #52]	; 0x34
   1b2a2:	f509 56e0 	add.w	r6, r9, #7168	; 0x1c00
                gainMult_Q8 = gainMult_lower + silk_DIV32_16( silk_MUL( gainMult_upper - gainMult_lower, maxBits - nBits_lower ), nBits_upper - nBits_lower );
   1b2a6:	f507 5227 	add.w	r2, r7, #10688	; 0x29c0
   1b2aa:	3220      	adds	r2, #32
   1b2ac:	6afd      	ldr	r5, [r7, #44]	; 0x2c
   1b2ae:	6812      	ldr	r2, [r2, #0]
   1b2b0:	1b5b      	subs	r3, r3, r5
   1b2b2:	1a12      	subs	r2, r2, r0
   1b2b4:	b2a9      	uxth	r1, r5
   1b2b6:	fb03 f202 	mul.w	r2, r3, r2
   1b2ba:	1a20      	subs	r0, r4, r0
                if( gainMult_Q8 > silk_ADD_RSHIFT32( gainMult_lower, gainMult_upper - gainMult_lower, 2 ) ) {
   1b2bc:	109b      	asrs	r3, r3, #2
                gainMult_Q8 = gainMult_lower + silk_DIV32_16( silk_MUL( gainMult_upper - gainMult_lower, maxBits - nBits_lower ), nBits_upper - nBits_lower );
   1b2be:	fb92 f2f0 	sdiv	r2, r2, r0
   1b2c2:	440a      	add	r2, r1
   1b2c4:	b210      	sxth	r0, r2
                if( gainMult_Q8 > silk_ADD_RSHIFT32( gainMult_lower, gainMult_upper - gainMult_lower, 2 ) ) {
   1b2c6:	195a      	adds	r2, r3, r5
   1b2c8:	4290      	cmp	r0, r2
                gainMult_Q8 = gainMult_lower + silk_DIV32_16( silk_MUL( gainMult_upper - gainMult_lower, maxBits - nBits_lower ), nBits_upper - nBits_lower );
   1b2ca:	66f8      	str	r0, [r7, #108]	; 0x6c
                if( gainMult_Q8 > silk_ADD_RSHIFT32( gainMult_lower, gainMult_upper - gainMult_lower, 2 ) ) {
   1b2cc:	dd0b      	ble.n	1b2e6 <silk_encode_frame_FIX+0x716>
                    gainMult_Q8 = silk_ADD_RSHIFT32( gainMult_lower, gainMult_upper - gainMult_lower, 2 );
   1b2ce:	440b      	add	r3, r1
                    gainMult_Q8 = silk_SUB_RSHIFT32( gainMult_upper, gainMult_upper - gainMult_lower, 2 );
   1b2d0:	2201      	movs	r2, #1
   1b2d2:	b21b      	sxth	r3, r3
   1b2d4:	64ba      	str	r2, [r7, #72]	; 0x48
   1b2d6:	66fb      	str	r3, [r7, #108]	; 0x6c
   1b2d8:	64fa      	str	r2, [r7, #76]	; 0x4c
   1b2da:	69fd      	ldr	r5, [r7, #28]
   1b2dc:	e6d0      	b.n	1b080 <silk_encode_frame_FIX+0x4b0>
                sEncCtrl.Gains_Q16[ i ] = silk_LSHIFT_SAT32( silk_SMULWB( sEncCtrl.GainsUnq_Q16[ i ], tmp ), 8 );
   1b2de:	4ba5      	ldr	r3, [pc, #660]	; (1b574 <silk_encode_frame_FIX+0x9a4>)
   1b2e0:	e725      	b.n	1b12e <silk_encode_frame_FIX+0x55e>
                    tmp = gainMult_Q8;
   1b2e2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
   1b2e4:	e710      	b.n	1b108 <silk_encode_frame_FIX+0x538>
                if( gainMult_Q8 < silk_SUB_RSHIFT32( gainMult_upper, gainMult_upper - gainMult_lower, 2 ) ) {
   1b2e6:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   1b2e8:	1ad3      	subs	r3, r2, r3
   1b2ea:	6efa      	ldr	r2, [r7, #108]	; 0x6c
   1b2ec:	429a      	cmp	r2, r3
   1b2ee:	dbef      	blt.n	1b2d0 <silk_encode_frame_FIX+0x700>
   1b2f0:	2301      	movs	r3, #1
   1b2f2:	e9c7 3312 	strd	r3, r3, [r7, #72]	; 0x48
   1b2f6:	69fd      	ldr	r5, [r7, #28]
   1b2f8:	e6c2      	b.n	1b080 <silk_encode_frame_FIX+0x4b0>
                    silk_memcpy( psRangeEnc, &sRangeEnc_copy, sizeof( ec_enc ) );
   1b2fa:	6e3e      	ldr	r6, [r7, #96]	; 0x60
   1b2fc:	f107 0c98 	add.w	ip, r7, #152	; 0x98
   1b300:	f107 0ec8 	add.w	lr, r7, #200	; 0xc8
   1b304:	4664      	mov	r4, ip
   1b306:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   1b308:	4574      	cmp	r4, lr
   1b30a:	6030      	str	r0, [r6, #0]
   1b30c:	6071      	str	r1, [r6, #4]
   1b30e:	60b2      	str	r2, [r6, #8]
   1b310:	60f3      	str	r3, [r6, #12]
   1b312:	46a4      	mov	ip, r4
   1b314:	f106 0610 	add.w	r6, r6, #16
   1b318:	d1f4      	bne.n	1b304 <silk_encode_frame_FIX+0x734>
                    silk_memcpy( &psEnc->sCmn.sNSQ, &sNSQ_copy, sizeof( silk_nsq_state ) );
   1b31a:	f44f 5288 	mov.w	r2, #4352	; 0x1100
   1b31e:	6939      	ldr	r1, [r7, #16]
   1b320:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   1b322:	f7f0 feed 	bl	c100 <memcpy>
                    psEnc->sCmn.indices.Seed = seed_copy;
   1b326:	f241 21a2 	movw	r1, #4770	; 0x12a2
                    psEnc->sCmn.ec_prevLagIndex = ec_prevLagIndex_copy;
   1b32a:	f241 628c 	movw	r2, #5772	; 0x168c
                    psEnc->sCmn.indices.Seed = seed_copy;
   1b32e:	6838      	ldr	r0, [r7, #0]
   1b330:	f809 0001 	strb.w	r0, [r9, r1]
                    psEnc->sCmn.ec_prevSignalType = ec_prevSignalType_copy;
   1b334:	f241 6388 	movw	r3, #5768	; 0x1688
                    psEnc->sCmn.ec_prevLagIndex = ec_prevLagIndex_copy;
   1b338:	68b9      	ldr	r1, [r7, #8]
   1b33a:	f829 1002 	strh.w	r1, [r9, r2]
                    psEnc->sCmn.ec_prevSignalType = ec_prevSignalType_copy;
   1b33e:	687a      	ldr	r2, [r7, #4]
   1b340:	f849 2003 	str.w	r2, [r9, r3]
   1b344:	e5fe      	b.n	1af44 <silk_encode_frame_FIX+0x374>
                    silk_memcpy( &sRangeEnc_copy2, psRangeEnc, sizeof( ec_enc ) );
   1b346:	6e3e      	ldr	r6, [r7, #96]	; 0x60
   1b348:	f1a8 0e30 	sub.w	lr, r8, #48	; 0x30
   1b34c:	68f3      	ldr	r3, [r6, #12]
   1b34e:	6830      	ldr	r0, [r6, #0]
   1b350:	6871      	ldr	r1, [r6, #4]
   1b352:	68b2      	ldr	r2, [r6, #8]
   1b354:	46f4      	mov	ip, lr
   1b356:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   1b35a:	69bb      	ldr	r3, [r7, #24]
   1b35c:	3610      	adds	r6, #16
   1b35e:	429e      	cmp	r6, r3
   1b360:	46e6      	mov	lr, ip
   1b362:	d1f3      	bne.n	1b34c <silk_encode_frame_FIX+0x77c>
                    silk_memcpy( ec_buf_copy, psRangeEnc->buf, psRangeEnc->offs );
   1b364:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   1b366:	f507 702f 	add.w	r0, r7, #700	; 0x2bc
   1b36a:	699a      	ldr	r2, [r3, #24]
   1b36c:	6819      	ldr	r1, [r3, #0]
   1b36e:	f7f0 fec7 	bl	c100 <memcpy>
                    LastGainIndex_copy2 = psEnc->sShape.LastGainIndex;
   1b372:	f509 56e0 	add.w	r6, r9, #7168	; 0x1c00
                    silk_memcpy( &sNSQ_copy2, &psEnc->sCmn.sNSQ, sizeof( silk_nsq_state ) );
   1b376:	f507 50c5 	add.w	r0, r7, #6304	; 0x18a0
   1b37a:	f44f 5288 	mov.w	r2, #4352	; 0x1100
   1b37e:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   1b380:	3018      	adds	r0, #24
   1b382:	f7f0 febd 	bl	c100 <memcpy>
                    LastGainIndex_copy2 = psEnc->sShape.LastGainIndex;
   1b386:	f996 3000 	ldrsb.w	r3, [r6]
   1b38a:	60fb      	str	r3, [r7, #12]
            if( ( found_lower & found_upper ) == 0 ) {
   1b38c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   1b38e:	2b00      	cmp	r3, #0
   1b390:	f43f ae56 	beq.w	1b040 <silk_encode_frame_FIX+0x470>
   1b394:	643c      	str	r4, [r7, #64]	; 0x40
   1b396:	4620      	mov	r0, r4
   1b398:	65bd      	str	r5, [r7, #88]	; 0x58
   1b39a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   1b39c:	6b7c      	ldr	r4, [r7, #52]	; 0x34
   1b39e:	e782      	b.n	1b2a6 <silk_encode_frame_FIX+0x6d6>
                sEncCtrl.Gains_Q16[ i ] = silk_LSHIFT_SAT32( silk_SMULWB( sEncCtrl.GainsUnq_Q16[ i ], tmp ), 8 );
   1b3a0:	4b74      	ldr	r3, [pc, #464]	; (1b574 <silk_encode_frame_FIX+0x9a4>)
   1b3a2:	e6e2      	b.n	1b16a <silk_encode_frame_FIX+0x59a>
                    tmp = gainMult_Q8;
   1b3a4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
   1b3a6:	e6cd      	b.n	1b144 <silk_encode_frame_FIX+0x574>
                    silk_memcpy( &sRangeEnc_copy2, psRangeEnc, sizeof( ec_enc ) );
   1b3a8:	f1a8 0530 	sub.w	r5, r8, #48	; 0x30
   1b3ac:	6e3c      	ldr	r4, [r7, #96]	; 0x60
   1b3ae:	46ae      	mov	lr, r5
   1b3b0:	68e3      	ldr	r3, [r4, #12]
   1b3b2:	6820      	ldr	r0, [r4, #0]
   1b3b4:	6861      	ldr	r1, [r4, #4]
   1b3b6:	68a2      	ldr	r2, [r4, #8]
   1b3b8:	46f4      	mov	ip, lr
   1b3ba:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   1b3be:	69bb      	ldr	r3, [r7, #24]
   1b3c0:	3410      	adds	r4, #16
   1b3c2:	429c      	cmp	r4, r3
   1b3c4:	46e6      	mov	lr, ip
   1b3c6:	d1f3      	bne.n	1b3b0 <silk_encode_frame_FIX+0x7e0>
                silk_encode_indices( &psEnc->sCmn, psRangeEnc, psEnc->sCmn.nFramesEncoded, 0, condCoding );
   1b3c8:	f241 6274 	movw	r2, #5748	; 0x1674
   1b3cc:	6e79      	ldr	r1, [r7, #100]	; 0x64
   1b3ce:	f859 2002 	ldr.w	r2, [r9, r2]
   1b3d2:	9100      	str	r1, [sp, #0]
   1b3d4:	6e3c      	ldr	r4, [r7, #96]	; 0x60
   1b3d6:	2300      	movs	r3, #0
   1b3d8:	4621      	mov	r1, r4
   1b3da:	4648      	mov	r0, r9
   1b3dc:	f7f3 ff10 	bl	f200 <silk_encode_indices>
                silk_encode_pulses( psRangeEnc, psEnc->sCmn.indices.signalType, psEnc->sCmn.indices.quantOffsetType,
   1b3e0:	f241 13e8 	movw	r3, #4584	; 0x11e8
   1b3e4:	f241 229e 	movw	r2, #4766	; 0x129e
   1b3e8:	f241 219d 	movw	r1, #4765	; 0x129d
   1b3ec:	f859 3003 	ldr.w	r3, [r9, r3]
   1b3f0:	f919 2002 	ldrsb.w	r2, [r9, r2]
   1b3f4:	f919 1001 	ldrsb.w	r1, [r9, r1]
   1b3f8:	9300      	str	r3, [sp, #0]
   1b3fa:	4620      	mov	r0, r4
   1b3fc:	4633      	mov	r3, r6
   1b3fe:	f7f4 f897 	bl	f530 <silk_encode_pulses>
   1b402:	69e3      	ldr	r3, [r4, #28]
   1b404:	6964      	ldr	r4, [r4, #20]
   1b406:	fab3 f383 	clz	r3, r3
   1b40a:	f1c3 0320 	rsb	r3, r3, #32
   1b40e:	1ae4      	subs	r4, r4, r3
                if ( iter == maxIter && !found_lower && nBits > maxBits ) {
   1b410:	f507 5327 	add.w	r3, r7, #10688	; 0x29c0
   1b414:	3320      	adds	r3, #32
   1b416:	681b      	ldr	r3, [r3, #0]
   1b418:	42a3      	cmp	r3, r4
   1b41a:	da68      	bge.n	1b4ee <silk_encode_frame_FIX+0x91e>
                    silk_memcpy( psRangeEnc, &sRangeEnc_copy2, sizeof( ec_enc ) );
   1b41c:	f8d7 c060 	ldr.w	ip, [r7, #96]	; 0x60
   1b420:	462c      	mov	r4, r5
   1b422:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   1b424:	4544      	cmp	r4, r8
   1b426:	f8cc 0000 	str.w	r0, [ip]
   1b42a:	f8cc 1004 	str.w	r1, [ip, #4]
   1b42e:	f8cc 2008 	str.w	r2, [ip, #8]
   1b432:	f8cc 300c 	str.w	r3, [ip, #12]
   1b436:	4625      	mov	r5, r4
   1b438:	f10c 0c10 	add.w	ip, ip, #16
   1b43c:	d1f0      	bne.n	1b420 <silk_encode_frame_FIX+0x850>
                    psEnc->sShape.LastGainIndex = sEncCtrl.lastGainIndexPrev;
   1b43e:	f509 53e0 	add.w	r3, r9, #7168	; 0x1c00
   1b442:	f998 11c0 	ldrsb.w	r1, [r8, #448]	; 0x1c0
   1b446:	7019      	strb	r1, [r3, #0]
                    for ( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1b448:	f241 13e4 	movw	r3, #4580	; 0x11e4
   1b44c:	f859 2003 	ldr.w	r2, [r9, r3]
   1b450:	2a00      	cmp	r2, #0
   1b452:	dd15      	ble.n	1b480 <silk_encode_frame_FIX+0x8b0>
                        psEnc->sCmn.indices.GainsIndices[ i ] = 4;
   1b454:	6d78      	ldr	r0, [r7, #84]	; 0x54
   1b456:	2304      	movs	r3, #4
                    for ( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1b458:	2a01      	cmp	r2, #1
                        psEnc->sCmn.indices.GainsIndices[ i ] = 4;
   1b45a:	7003      	strb	r3, [r0, #0]
                    for ( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1b45c:	d010      	beq.n	1b480 <silk_encode_frame_FIX+0x8b0>
                        psEnc->sCmn.indices.GainsIndices[ i ] = 4;
   1b45e:	f241 2081 	movw	r0, #4737	; 0x1281
                    for ( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1b462:	2a02      	cmp	r2, #2
                        psEnc->sCmn.indices.GainsIndices[ i ] = 4;
   1b464:	f809 3000 	strb.w	r3, [r9, r0]
                    for ( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1b468:	d00a      	beq.n	1b480 <silk_encode_frame_FIX+0x8b0>
   1b46a:	2a03      	cmp	r2, #3
                        psEnc->sCmn.indices.GainsIndices[ i ] = 4;
   1b46c:	f241 2082 	movw	r0, #4738	; 0x1282
   1b470:	bf18      	it	ne
   1b472:	f241 2283 	movwne	r2, #4739	; 0x1283
   1b476:	f809 3000 	strb.w	r3, [r9, r0]
   1b47a:	bf18      	it	ne
   1b47c:	f809 3002 	strbne.w	r3, [r9, r2]
                    if (condCoding != CODE_CONDITIONALLY) {
   1b480:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   1b482:	2b02      	cmp	r3, #2
                       psEnc->sCmn.indices.GainsIndices[ 0 ] = sEncCtrl.lastGainIndexPrev;
   1b484:	bf18      	it	ne
   1b486:	6d7b      	ldrne	r3, [r7, #84]	; 0x54
                    for ( i = 0; i < psEnc->sCmn.frame_length; i++ ) {
   1b488:	f241 12e8 	movw	r2, #4584	; 0x11e8
                       psEnc->sCmn.indices.GainsIndices[ 0 ] = sEncCtrl.lastGainIndexPrev;
   1b48c:	bf18      	it	ne
   1b48e:	7019      	strbne	r1, [r3, #0]
                    psEnc->sCmn.ec_prevLagIndex = ec_prevLagIndex_copy;
   1b490:	f241 638c 	movw	r3, #5772	; 0x168c
                    for ( i = 0; i < psEnc->sCmn.frame_length; i++ ) {
   1b494:	f859 2002 	ldr.w	r2, [r9, r2]
                    psEnc->sCmn.ec_prevLagIndex = ec_prevLagIndex_copy;
   1b498:	68b9      	ldr	r1, [r7, #8]
   1b49a:	f829 1003 	strh.w	r1, [r9, r3]
                    psEnc->sCmn.ec_prevSignalType = ec_prevSignalType_copy;
   1b49e:	f241 6388 	movw	r3, #5768	; 0x1688
   1b4a2:	6879      	ldr	r1, [r7, #4]
   1b4a4:	f849 1003 	str.w	r1, [r9, r3]
                    for ( i = 0; i < psEnc->sCmn.frame_length; i++ ) {
   1b4a8:	2a00      	cmp	r2, #0
   1b4aa:	dd03      	ble.n	1b4b4 <silk_encode_frame_FIX+0x8e4>
   1b4ac:	2100      	movs	r1, #0
   1b4ae:	4630      	mov	r0, r6
   1b4b0:	f019 fe58 	bl	35164 <memset>
                    silk_encode_indices( &psEnc->sCmn, psRangeEnc, psEnc->sCmn.nFramesEncoded, 0, condCoding );
   1b4b4:	f241 6274 	movw	r2, #5748	; 0x1674
   1b4b8:	6e79      	ldr	r1, [r7, #100]	; 0x64
   1b4ba:	f859 2002 	ldr.w	r2, [r9, r2]
   1b4be:	9100      	str	r1, [sp, #0]
   1b4c0:	6e3c      	ldr	r4, [r7, #96]	; 0x60
   1b4c2:	2300      	movs	r3, #0
   1b4c4:	4621      	mov	r1, r4
   1b4c6:	4648      	mov	r0, r9
   1b4c8:	f7f3 fe9a 	bl	f200 <silk_encode_indices>
                    silk_encode_pulses( psRangeEnc, psEnc->sCmn.indices.signalType, psEnc->sCmn.indices.quantOffsetType,
   1b4cc:	f241 13e8 	movw	r3, #4584	; 0x11e8
   1b4d0:	f241 229e 	movw	r2, #4766	; 0x129e
   1b4d4:	f241 219d 	movw	r1, #4765	; 0x129d
   1b4d8:	f859 3003 	ldr.w	r3, [r9, r3]
   1b4dc:	f919 2002 	ldrsb.w	r2, [r9, r2]
   1b4e0:	f919 1001 	ldrsb.w	r1, [r9, r1]
   1b4e4:	9300      	str	r3, [sp, #0]
   1b4e6:	4620      	mov	r0, r4
   1b4e8:	4633      	mov	r3, r6
   1b4ea:	f7f4 f821 	bl	f530 <silk_encode_pulses>
    silk_memmove( psEnc->x_buf, &psEnc->x_buf[ psEnc->sCmn.frame_length ],
   1b4ee:	6bba      	ldr	r2, [r7, #56]	; 0x38
   1b4f0:	f8d7 d014 	ldr.w	sp, [r7, #20]
   1b4f4:	6812      	ldr	r2, [r2, #0]
   1b4f6:	6d38      	ldr	r0, [r7, #80]	; 0x50
   1b4f8:	f241 13f0 	movw	r3, #4592	; 0x11f0
   1b4fc:	f241 11e8 	movw	r1, #4584	; 0x11e8
   1b500:	f859 3003 	ldr.w	r3, [r9, r3]
   1b504:	f859 1001 	ldr.w	r1, [r9, r1]
   1b508:	eb02 0282 	add.w	r2, r2, r2, lsl #2
   1b50c:	441a      	add	r2, r3
   1b50e:	f241 2348 	movw	r3, #4680	; 0x1248
   1b512:	f601 6108 	addw	r1, r1, #3592	; 0xe08
   1b516:	f859 4003 	ldr.w	r4, [r9, r3]
   1b51a:	0052      	lsls	r2, r2, #1
   1b51c:	eb09 0141 	add.w	r1, r9, r1, lsl #1
   1b520:	f019 fdbc 	bl	3509c <memmove>
    if( psEnc->sCmn.prefillFlag ) {
   1b524:	2c00      	cmp	r4, #0
   1b526:	f47f abaf 	bne.w	1ac88 <silk_encode_frame_FIX+0xb8>
    psEnc->sCmn.prevLag        = sEncCtrl.pitchL[ psEnc->sCmn.nb_subfr - 1 ];
   1b52a:	f241 13e4 	movw	r3, #4580	; 0x11e4
   1b52e:	f509 518e 	add.w	r1, r9, #4544	; 0x11c0
   1b532:	f859 3003 	ldr.w	r3, [r9, r3]
   1b536:	eb08 0383 	add.w	r3, r8, r3, lsl #2
    psEnc->sCmn.prevSignalType = psEnc->sCmn.indices.signalType;
   1b53a:	f241 229d 	movw	r2, #4765	; 0x129d
    psEnc->sCmn.prevLag        = sEncCtrl.pitchL[ psEnc->sCmn.nb_subfr - 1 ];
   1b53e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
   1b540:	600b      	str	r3, [r1, #0]
    psEnc->sCmn.prevSignalType = psEnc->sCmn.indices.signalType;
   1b542:	f241 13bd 	movw	r3, #4541	; 0x11bd
   1b546:	f819 2002 	ldrb.w	r2, [r9, r2]
   1b54a:	f809 2003 	strb.w	r2, [r9, r3]
   1b54e:	6e39      	ldr	r1, [r7, #96]	; 0x60
    psEnc->sCmn.first_frame_after_reset = 0;
   1b550:	f241 2238 	movw	r2, #4664	; 0x1238
   1b554:	69cb      	ldr	r3, [r1, #28]
   1b556:	f849 4002 	str.w	r4, [r9, r2]
   1b55a:	694a      	ldr	r2, [r1, #20]
   1b55c:	fab3 f383 	clz	r3, r3
   1b560:	4413      	add	r3, r2
    *pnBytesOut = silk_RSHIFT( ec_tell( psRangeEnc ) + 7, 3 );
   1b562:	3b19      	subs	r3, #25
   1b564:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
   1b566:	10db      	asrs	r3, r3, #3
   1b568:	6013      	str	r3, [r2, #0]
    return ret;
   1b56a:	f7ff bb90 	b.w	1ac8e <silk_encode_frame_FIX+0xbe>
                sEncCtrl.Gains_Q16[ i ] = silk_LSHIFT_SAT32( silk_SMULWB( sEncCtrl.GainsUnq_Q16[ i ], tmp ), 8 );
   1b56e:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   1b572:	e5a1      	b.n	1b0b8 <silk_encode_frame_FIX+0x4e8>
   1b574:	7fffff00 	.word	0x7fffff00
                if ( iter == maxIter && !found_lower ) {
   1b578:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   1b57a:	2b00      	cmp	r3, #0
   1b57c:	f43f af14 	beq.w	1b3a8 <silk_encode_frame_FIX+0x7d8>
                silk_encode_indices( &psEnc->sCmn, psRangeEnc, psEnc->sCmn.nFramesEncoded, 0, condCoding );
   1b580:	f241 6274 	movw	r2, #5748	; 0x1674
   1b584:	6e79      	ldr	r1, [r7, #100]	; 0x64
   1b586:	f859 2002 	ldr.w	r2, [r9, r2]
   1b58a:	9100      	str	r1, [sp, #0]
   1b58c:	6e3c      	ldr	r4, [r7, #96]	; 0x60
   1b58e:	2300      	movs	r3, #0
   1b590:	4621      	mov	r1, r4
   1b592:	4648      	mov	r0, r9
   1b594:	f7f3 fe34 	bl	f200 <silk_encode_indices>
                silk_encode_pulses( psRangeEnc, psEnc->sCmn.indices.signalType, psEnc->sCmn.indices.quantOffsetType,
   1b598:	f241 13e8 	movw	r3, #4584	; 0x11e8
   1b59c:	f241 229e 	movw	r2, #4766	; 0x129e
   1b5a0:	f241 219d 	movw	r1, #4765	; 0x129d
   1b5a4:	f859 3003 	ldr.w	r3, [r9, r3]
   1b5a8:	f919 2002 	ldrsb.w	r2, [r9, r2]
   1b5ac:	f919 1001 	ldrsb.w	r1, [r9, r1]
   1b5b0:	9300      	str	r3, [sp, #0]
   1b5b2:	4620      	mov	r0, r4
   1b5b4:	4633      	mov	r3, r6
   1b5b6:	f7f3 ffbb 	bl	f530 <silk_encode_pulses>
   1b5ba:	69e3      	ldr	r3, [r4, #28]
   1b5bc:	6964      	ldr	r4, [r4, #20]
   1b5be:	fab3 f383 	clz	r3, r3
   1b5c2:	f1c3 0320 	rsb	r3, r3, #32
   1b5c6:	1ae4      	subs	r4, r4, r3
                if( useCBR == 0 && iter == 0 && nBits <= maxBits ) {
   1b5c8:	f507 5327 	add.w	r3, r7, #10688	; 0x29c0
   1b5cc:	3324      	adds	r3, #36	; 0x24
   1b5ce:	681b      	ldr	r3, [r3, #0]
   1b5d0:	b92b      	cbnz	r3, 1b5de <silk_encode_frame_FIX+0xa0e>
                if( found_lower && ( gainsID == gainsID_lower || nBits > maxBits ) ) {
   1b5d2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   1b5d4:	2b00      	cmp	r3, #0
   1b5d6:	d08a      	beq.n	1b4ee <silk_encode_frame_FIX+0x91e>
   1b5d8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   1b5da:	429d      	cmp	r5, r3
   1b5dc:	d005      	beq.n	1b5ea <silk_encode_frame_FIX+0xa1a>
   1b5de:	f507 5327 	add.w	r3, r7, #10688	; 0x29c0
   1b5e2:	3320      	adds	r3, #32
   1b5e4:	681b      	ldr	r3, [r3, #0]
   1b5e6:	429c      	cmp	r4, r3
   1b5e8:	dd81      	ble.n	1b4ee <silk_encode_frame_FIX+0x91e>
                    silk_memcpy( psRangeEnc, &sRangeEnc_copy2, sizeof( ec_enc ) );
   1b5ea:	f1a8 0530 	sub.w	r5, r8, #48	; 0x30
   1b5ee:	6e3e      	ldr	r6, [r7, #96]	; 0x60
   1b5f0:	46ac      	mov	ip, r5
   1b5f2:	4664      	mov	r4, ip
   1b5f4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   1b5f6:	4544      	cmp	r4, r8
   1b5f8:	6030      	str	r0, [r6, #0]
   1b5fa:	6071      	str	r1, [r6, #4]
   1b5fc:	60b2      	str	r2, [r6, #8]
   1b5fe:	60f3      	str	r3, [r6, #12]
   1b600:	46a4      	mov	ip, r4
   1b602:	f106 0610 	add.w	r6, r6, #16
   1b606:	d1f4      	bne.n	1b5f2 <silk_encode_frame_FIX+0xa22>
                    silk_memcpy( psRangeEnc->buf, ec_buf_copy, sRangeEnc_copy2.offs );
   1b608:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   1b60a:	69aa      	ldr	r2, [r5, #24]
   1b60c:	6818      	ldr	r0, [r3, #0]
   1b60e:	f507 712f 	add.w	r1, r7, #700	; 0x2bc
   1b612:	f7f0 fd75 	bl	c100 <memcpy>
                    silk_memcpy( &psEnc->sCmn.sNSQ, &sNSQ_copy2, sizeof( silk_nsq_state ) );
   1b616:	f507 51c5 	add.w	r1, r7, #6304	; 0x18a0
   1b61a:	f44f 5288 	mov.w	r2, #4352	; 0x1100
   1b61e:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   1b620:	3118      	adds	r1, #24
   1b622:	f7f0 fd6d 	bl	c100 <memcpy>
                    psEnc->sShape.LastGainIndex = LastGainIndex_copy2;
   1b626:	f509 53e0 	add.w	r3, r9, #7168	; 0x1c00
   1b62a:	68fa      	ldr	r2, [r7, #12]
   1b62c:	701a      	strb	r2, [r3, #0]
   1b62e:	e75e      	b.n	1b4ee <silk_encode_frame_FIX+0x91e>
                        gainMult_Q8 *= 2;
   1b630:	005b      	lsls	r3, r3, #1
   1b632:	b21b      	sxth	r3, r3
   1b634:	66fb      	str	r3, [r7, #108]	; 0x6c
   1b636:	f509 56e0 	add.w	r6, r9, #7168	; 0x1c00
   1b63a:	e521      	b.n	1b080 <silk_encode_frame_FIX+0x4b0>
                sEncCtrl.Gains_Q16[ i ] = silk_LSHIFT_SAT32( silk_SMULWB( sEncCtrl.GainsUnq_Q16[ i ], tmp ), 8 );
   1b63c:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   1b640:	e557      	b.n	1b0f2 <silk_encode_frame_FIX+0x522>
   1b642:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   1b646:	e572      	b.n	1b12e <silk_encode_frame_FIX+0x55e>
   1b648:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   1b64c:	e58d      	b.n	1b16a <silk_encode_frame_FIX+0x59a>
                    int sum=0;
   1b64e:	2200      	movs	r2, #0
   1b650:	e5ee      	b.n	1b230 <silk_encode_frame_FIX+0x660>
                    gainMult_upper = gainMult_Q8;
   1b652:	6efb      	ldr	r3, [r7, #108]	; 0x6c
   1b654:	633b      	str	r3, [r7, #48]	; 0x30
                    found_upper = 1;
   1b656:	2301      	movs	r3, #1
                    gainMult_upper = gainMult_Q8;
   1b658:	647d      	str	r5, [r7, #68]	; 0x44
   1b65a:	637c      	str	r4, [r7, #52]	; 0x34
                    found_upper = 1;
   1b65c:	64fb      	str	r3, [r7, #76]	; 0x4c
   1b65e:	e5bf      	b.n	1b1e0 <silk_encode_frame_FIX+0x610>
                if( useCBR == 0 && iter == 0 && nBits <= maxBits ) {
   1b660:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   1b662:	2b00      	cmp	r3, #0
   1b664:	f47f acd1 	bne.w	1b00a <silk_encode_frame_FIX+0x43a>
   1b668:	f507 5327 	add.w	r3, r7, #10688	; 0x29c0
   1b66c:	3320      	adds	r3, #32
   1b66e:	681b      	ldr	r3, [r3, #0]
   1b670:	42a3      	cmp	r3, r4
   1b672:	f6ff ada4 	blt.w	1b1be <silk_encode_frame_FIX+0x5ee>
   1b676:	e73a      	b.n	1b4ee <silk_encode_frame_FIX+0x91e>
                    silk_NSQ( &psEnc->sCmn, &psEnc->sCmn.sNSQ, &psEnc->sCmn.indices, x_frame, psEnc->sCmn.pulses,
   1b678:	920a      	str	r2, [sp, #40]	; 0x28
   1b67a:	9408      	str	r4, [sp, #32]
   1b67c:	f508 71ae 	add.w	r1, r8, #348	; 0x15c
   1b680:	f508 72b6 	add.w	r2, r8, #364	; 0x16c
   1b684:	f108 0c8c 	add.w	ip, r8, #140	; 0x8c
   1b688:	f108 0450 	add.w	r4, r8, #80	; 0x50
   1b68c:	e9cd 2104 	strd	r2, r1, [sp, #16]
   1b690:	e9cd 4c02 	strd	r4, ip, [sp, #8]
   1b694:	9309      	str	r3, [sp, #36]	; 0x24
   1b696:	f108 0310 	add.w	r3, r8, #16
   1b69a:	9006      	str	r0, [sp, #24]
   1b69c:	f8cd 801c 	str.w	r8, [sp, #28]
   1b6a0:	9600      	str	r6, [sp, #0]
   1b6a2:	9301      	str	r3, [sp, #4]
   1b6a4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   1b6a6:	6d7a      	ldr	r2, [r7, #84]	; 0x54
   1b6a8:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   1b6aa:	4648      	mov	r0, r9
   1b6ac:	f7f4 fd2e 	bl	1010c <silk_NSQ_c>
   1b6b0:	e47c      	b.n	1afac <silk_encode_frame_FIX+0x3dc>
   1b6b2:	f859 3003 	ldr.w	r3, [r9, r3]
   1b6b6:	f8d8 217c 	ldr.w	r2, [r8, #380]	; 0x17c
   1b6ba:	f8d8 1078 	ldr.w	r1, [r8, #120]	; 0x78
   1b6be:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   1b6c2:	eb09 1383 	add.w	r3, r9, r3, lsl #6
   1b6c6:	f503 53c2 	add.w	r3, r3, #6208	; 0x1840
   1b6ca:	f7ff bbbd 	b.w	1ae48 <silk_encode_frame_FIX+0x278>
            silk_NSQ( &psEnc->sCmn, &sNSQ_LBRR, psIndices_LBRR, x16,
   1b6ce:	f108 007c 	add.w	r0, r8, #124	; 0x7c
   1b6d2:	f508 74a6 	add.w	r4, r8, #332	; 0x14c
   1b6d6:	f508 75ae 	add.w	r5, r8, #348	; 0x15c
   1b6da:	9300      	str	r3, [sp, #0]
   1b6dc:	9008      	str	r0, [sp, #32]
   1b6de:	f508 73b6 	add.w	r3, r8, #364	; 0x16c
   1b6e2:	f108 008c 	add.w	r0, r8, #140	; 0x8c
   1b6e6:	9406      	str	r4, [sp, #24]
   1b6e8:	9505      	str	r5, [sp, #20]
   1b6ea:	f108 0450 	add.w	r4, r8, #80	; 0x50
   1b6ee:	f108 0510 	add.w	r5, r8, #16
   1b6f2:	e9cd 0303 	strd	r0, r3, [sp, #12]
   1b6f6:	e9cd 5401 	strd	r5, r4, [sp, #4]
   1b6fa:	910a      	str	r1, [sp, #40]	; 0x28
   1b6fc:	9209      	str	r2, [sp, #36]	; 0x24
   1b6fe:	f8cd 801c 	str.w	r8, [sp, #28]
   1b702:	f507 51c5 	add.w	r1, r7, #6304	; 0x18a0
   1b706:	465a      	mov	r2, fp
   1b708:	3118      	adds	r1, #24
   1b70a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   1b70c:	4648      	mov	r0, r9
   1b70e:	f7f4 fcfd 	bl	1010c <silk_NSQ_c>
   1b712:	f7ff bbbb 	b.w	1ae8c <silk_encode_frame_FIX+0x2bc>
   1b716:	bf00      	nop

0001b718 <silk_find_LPC_FIX>:
    silk_encoder_state              *psEncC,                                /* I/O  Encoder state                                                               */
    opus_int16                      NLSF_Q15[],                             /* O    NLSFs                                                                       */
    const opus_int16                x[],                                    /* I    Input signal                                                                */
    const opus_int32                minInvGain_Q30                          /* I    Inverse of max prediction gain                                              */
)
{
   1b718:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1b71c:	4604      	mov	r4, r0
   1b71e:	b0c5      	sub	sp, #276	; 0x114
    opus_int     res_nrg_interp_Q, res_nrg_Q, res_tmp_nrg_Q;
    opus_int16   a_tmp_Q12[ MAX_LPC_ORDER ];
    opus_int16   NLSF0_Q15[ MAX_LPC_ORDER ];
    SAVE_STACK;

    subfr_length = psEncC->subfr_length + psEncC->predictLPCOrder;
   1b720:	f500 5691 	add.w	r6, r0, #4640	; 0x1220

    /* Default: no interpolation */
    psEncC->indices.NLSFInterpCoef_Q2 = 4;

    /* Burg AR analysis for the full frame */
    silk_burg_modified( &res_nrg, &res_nrg_Q, a_Q16, x, minInvGain_Q30, subfr_length, psEncC->nb_subfr, psEncC->predictLPCOrder, psEncC->arch );
   1b724:	f241 3be4 	movw	fp, #5092	; 0x13e4
    subfr_length = psEncC->subfr_length + psEncC->predictLPCOrder;
   1b728:	6835      	ldr	r5, [r6, #0]
    silk_burg_modified( &res_nrg, &res_nrg_Q, a_Q16, x, minInvGain_Q30, subfr_length, psEncC->nb_subfr, psEncC->predictLPCOrder, psEncC->arch );
   1b72a:	f854 c00b 	ldr.w	ip, [r4, fp]
    psEncC->indices.NLSFInterpCoef_Q2 = 4;
   1b72e:	f241 2e9f 	movw	lr, #4767	; 0x129f
    subfr_length = psEncC->subfr_length + psEncC->predictLPCOrder;
   1b732:	f241 10ec 	movw	r0, #4588	; 0x11ec
    psEncC->indices.NLSFInterpCoef_Q2 = 4;
   1b736:	f04f 0804 	mov.w	r8, #4
    subfr_length = psEncC->subfr_length + psEncC->predictLPCOrder;
   1b73a:	5820      	ldr	r0, [r4, r0]
    psEncC->indices.NLSFInterpCoef_Q2 = 4;
   1b73c:	f804 800e 	strb.w	r8, [r4, lr]
    silk_burg_modified( &res_nrg, &res_nrg_Q, a_Q16, x, minInvGain_Q30, subfr_length, psEncC->nb_subfr, psEncC->predictLPCOrder, psEncC->arch );
   1b740:	e9cd 5c03 	strd	r5, ip, [sp, #12]
   1b744:	f241 19e4 	movw	r9, #4580	; 0x11e4
{
   1b748:	af06      	add	r7, sp, #24
   1b74a:	469a      	mov	sl, r3
    subfr_length = psEncC->subfr_length + psEncC->predictLPCOrder;
   1b74c:	4405      	add	r5, r0
    silk_burg_modified( &res_nrg, &res_nrg_Q, a_Q16, x, minInvGain_Q30, subfr_length, psEncC->nb_subfr, psEncC->predictLPCOrder, psEncC->arch );
   1b74e:	f854 3009 	ldr.w	r3, [r4, r9]
   1b752:	9302      	str	r3, [sp, #8]
{
   1b754:	4690      	mov	r8, r2
   1b756:	6179      	str	r1, [r7, #20]
    silk_burg_modified( &res_nrg, &res_nrg_Q, a_Q16, x, minInvGain_Q30, subfr_length, psEncC->nb_subfr, psEncC->predictLPCOrder, psEncC->arch );
   1b758:	4613      	mov	r3, r2
   1b75a:	e9cd a500 	strd	sl, r5, [sp]
   1b75e:	f107 0278 	add.w	r2, r7, #120	; 0x78
   1b762:	f107 0130 	add.w	r1, r7, #48	; 0x30
   1b766:	f107 0028 	add.w	r0, r7, #40	; 0x28
   1b76a:	f002 fb9d 	bl	1dea8 <silk_burg_modified_c>

    if( psEncC->useInterpolatedNLSFs && !psEncC->first_frame_after_reset && psEncC->nb_subfr == MAX_NB_SUBFR ) {
   1b76e:	f241 2318 	movw	r3, #4632	; 0x1218
   1b772:	58e3      	ldr	r3, [r4, r3]
   1b774:	b11b      	cbz	r3, 1b77e <silk_find_LPC_FIX+0x66>
   1b776:	f241 2338 	movw	r3, #4664	; 0x1238
   1b77a:	58e3      	ldr	r3, [r4, r3]
   1b77c:	b14b      	cbz	r3, 1b792 <silk_find_LPC_FIX+0x7a>
                psEncC->indices.NLSFInterpCoef_Q2 = (opus_int8)k;
            }
        }
    }

    if( psEncC->indices.NLSFInterpCoef_Q2 == 4 ) {
   1b77e:	f241 239f 	movw	r3, #4767	; 0x129f
   1b782:	56e3      	ldrsb	r3, [r4, r3]
   1b784:	2b04      	cmp	r3, #4
   1b786:	f000 809e 	beq.w	1b8c6 <silk_find_LPC_FIX+0x1ae>
        silk_A2NLSF( NLSF_Q15, a_Q16, psEncC->predictLPCOrder );
    }

    celt_assert( psEncC->indices.NLSFInterpCoef_Q2 == 4 || ( psEncC->useInterpolatedNLSFs && !psEncC->first_frame_after_reset && psEncC->nb_subfr == MAX_NB_SUBFR ) );
    RESTORE_STACK;
}
   1b78a:	37fc      	adds	r7, #252	; 0xfc
   1b78c:	46bd      	mov	sp, r7
   1b78e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( psEncC->useInterpolatedNLSFs && !psEncC->first_frame_after_reset && psEncC->nb_subfr == MAX_NB_SUBFR ) {
   1b792:	f854 3009 	ldr.w	r3, [r4, r9]
   1b796:	2b04      	cmp	r3, #4
   1b798:	d1f1      	bne.n	1b77e <silk_find_LPC_FIX+0x66>
        silk_burg_modified( &res_tmp_nrg, &res_tmp_nrg_Q, a_tmp_Q16, x + 2 * subfr_length, minInvGain_Q30, subfr_length, 2, psEncC->predictLPCOrder, psEncC->arch );
   1b79a:	f854 300b 	ldr.w	r3, [r4, fp]
   1b79e:	9304      	str	r3, [sp, #16]
   1b7a0:	6833      	ldr	r3, [r6, #0]
   1b7a2:	9303      	str	r3, [sp, #12]
   1b7a4:	2102      	movs	r1, #2
   1b7a6:	ea4f 0985 	mov.w	r9, r5, lsl #2
   1b7aa:	eb08 0309 	add.w	r3, r8, r9
   1b7ae:	f107 02b8 	add.w	r2, r7, #184	; 0xb8
   1b7b2:	9102      	str	r1, [sp, #8]
   1b7b4:	e9cd a500 	strd	sl, r5, [sp]
   1b7b8:	f107 0134 	add.w	r1, r7, #52	; 0x34
   1b7bc:	f107 002c 	add.w	r0, r7, #44	; 0x2c
   1b7c0:	f002 fb72 	bl	1dea8 <silk_burg_modified_c>
        shift = res_tmp_nrg_Q - res_nrg_Q;
   1b7c4:	e9d7 320c 	ldrd	r3, r2, [r7, #48]	; 0x30
        if( shift >= 0 ) {
   1b7c8:	1ad3      	subs	r3, r2, r3
    if( psEncC->useInterpolatedNLSFs && !psEncC->first_frame_after_reset && psEncC->nb_subfr == MAX_NB_SUBFR ) {
   1b7ca:	f8c7 d008 	str.w	sp, [r7, #8]
        if( shift >= 0 ) {
   1b7ce:	f100 8084 	bmi.w	1b8da <silk_find_LPC_FIX+0x1c2>
            if( shift < 32 ) {
   1b7d2:	2b1f      	cmp	r3, #31
   1b7d4:	dc05      	bgt.n	1b7e2 <silk_find_LPC_FIX+0xca>
                res_nrg = res_nrg - silk_RSHIFT( res_tmp_nrg, shift );
   1b7d6:	e9d7 210a 	ldrd	r2, r1, [r7, #40]	; 0x28
   1b7da:	fa41 f303 	asr.w	r3, r1, r3
   1b7de:	1ad2      	subs	r2, r2, r3
   1b7e0:	62ba      	str	r2, [r7, #40]	; 0x28
        silk_A2NLSF( NLSF_Q15, a_tmp_Q16, psEncC->predictLPCOrder );
   1b7e2:	6832      	ldr	r2, [r6, #0]
   1b7e4:	6978      	ldr	r0, [r7, #20]
   1b7e6:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
   1b7ea:	f7fa ff39 	bl	16660 <silk_A2NLSF>
        ALLOC( LPC_res, 2 * subfr_length, opus_int16 );
   1b7ee:	f109 0908 	add.w	r9, r9, #8
                psEncC->indices.NLSFInterpCoef_Q2 = (opus_int8)k;
   1b7f2:	f504 5294 	add.w	r2, r4, #4736	; 0x1280
        ALLOC( LPC_res, 2 * subfr_length, opus_int16 );
   1b7f6:	f029 0907 	bic.w	r9, r9, #7
   1b7fa:	f504 538c 	add.w	r3, r4, #4480	; 0x1180
                psEncC->indices.NLSFInterpCoef_Q2 = (opus_int8)k;
   1b7fe:	321f      	adds	r2, #31
        ALLOC( LPC_res, 2 * subfr_length, opus_int16 );
   1b800:	ebad 0d09 	sub.w	sp, sp, r9
   1b804:	f504 5a9f 	add.w	sl, r4, #5088	; 0x13e0
   1b808:	3314      	adds	r3, #20
                psEncC->indices.NLSFInterpCoef_Q2 = (opus_int8)k;
   1b80a:	60fa      	str	r2, [r7, #12]
        ALLOC( LPC_res, 2 * subfr_length, opus_int16 );
   1b80c:	006a      	lsls	r2, r5, #1
   1b80e:	607c      	str	r4, [r7, #4]
   1b810:	f10d 0b18 	add.w	fp, sp, #24
   1b814:	f10a 0a04 	add.w	sl, sl, #4
   1b818:	613a      	str	r2, [r7, #16]
        for( k = 3; k >= 0; k-- ) {
   1b81a:	f04f 0903 	mov.w	r9, #3
   1b81e:	461c      	mov	r4, r3
            silk_interpolate( NLSF0_Q15, psEncC->prev_NLSFq_Q15, NLSF_Q15, k, psEncC->predictLPCOrder );
   1b820:	6833      	ldr	r3, [r6, #0]
   1b822:	9300      	str	r3, [sp, #0]
   1b824:	697a      	ldr	r2, [r7, #20]
   1b826:	464b      	mov	r3, r9
   1b828:	4621      	mov	r1, r4
   1b82a:	f107 0058 	add.w	r0, r7, #88	; 0x58
   1b82e:	f7f4 fa7f 	bl	fd30 <silk_interpolate>
            silk_NLSF2A( a_tmp_Q12, NLSF0_Q15, psEncC->predictLPCOrder, psEncC->arch );
   1b832:	f8da 3000 	ldr.w	r3, [sl]
   1b836:	6832      	ldr	r2, [r6, #0]
   1b838:	f107 0158 	add.w	r1, r7, #88	; 0x58
   1b83c:	f107 0038 	add.w	r0, r7, #56	; 0x38
   1b840:	f7fc fbe0 	bl	18004 <silk_NLSF2A>
            silk_LPC_analysis_filter( LPC_res, x, a_tmp_Q12, 2 * subfr_length, psEncC->predictLPCOrder, psEncC->arch );
   1b844:	f8da 3000 	ldr.w	r3, [sl]
   1b848:	9301      	str	r3, [sp, #4]
   1b84a:	6833      	ldr	r3, [r6, #0]
   1b84c:	9300      	str	r3, [sp, #0]
   1b84e:	693b      	ldr	r3, [r7, #16]
   1b850:	f107 0238 	add.w	r2, r7, #56	; 0x38
   1b854:	4641      	mov	r1, r8
   1b856:	4658      	mov	r0, fp
   1b858:	f7fc f918 	bl	17a8c <silk_LPC_analysis_filter>
            silk_sum_sqr_shift( &res_nrg0, &rshift0, LPC_res + psEncC->predictLPCOrder,                subfr_length - psEncC->predictLPCOrder );
   1b85c:	6832      	ldr	r2, [r6, #0]
   1b85e:	f107 0120 	add.w	r1, r7, #32
   1b862:	1aab      	subs	r3, r5, r2
   1b864:	f107 0018 	add.w	r0, r7, #24
   1b868:	eb0b 0242 	add.w	r2, fp, r2, lsl #1
   1b86c:	f7fe fb6c 	bl	19f48 <silk_sum_sqr_shift>
            silk_sum_sqr_shift( &res_nrg1, &rshift1, LPC_res + psEncC->predictLPCOrder + subfr_length, subfr_length - psEncC->predictLPCOrder );
   1b870:	6833      	ldr	r3, [r6, #0]
   1b872:	195a      	adds	r2, r3, r5
   1b874:	eb0b 0242 	add.w	r2, fp, r2, lsl #1
   1b878:	1aeb      	subs	r3, r5, r3
   1b87a:	f107 0124 	add.w	r1, r7, #36	; 0x24
   1b87e:	f107 001c 	add.w	r0, r7, #28
   1b882:	f7fe fb61 	bl	19f48 <silk_sum_sqr_shift>
            shift = rshift0 - rshift1;
   1b886:	e9d7 3208 	ldrd	r3, r2, [r7, #32]
            if( shift >= 0 ) {
   1b88a:	ebb3 0c02 	subs.w	ip, r3, r2
   1b88e:	d435      	bmi.n	1b8fc <silk_find_LPC_FIX+0x1e4>
   1b890:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
                res_nrg1         = silk_RSHIFT( res_nrg1, shift );
   1b894:	fa41 f10c 	asr.w	r1, r1, ip
                res_nrg_interp_Q = -rshift0;
   1b898:	425a      	negs	r2, r3
                res_nrg1         = silk_RSHIFT( res_nrg1, shift );
   1b89a:	61f9      	str	r1, [r7, #28]
            shift = res_nrg_interp_Q - res_nrg_Q;
   1b89c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
            res_nrg_interp = silk_ADD32( res_nrg0, res_nrg1 );
   1b89e:	4401      	add	r1, r0
            if( shift >= 0 ) {
   1b8a0:	1ad3      	subs	r3, r2, r3
                if( silk_RSHIFT( res_nrg_interp, shift ) < res_nrg ) {
   1b8a2:	fa41 f003 	asr.w	r0, r1, r3
            if( shift >= 0 ) {
   1b8a6:	d421      	bmi.n	1b8ec <silk_find_LPC_FIX+0x1d4>
                if( silk_RSHIFT( res_nrg_interp, shift ) < res_nrg ) {
   1b8a8:	6abb      	ldr	r3, [r7, #40]	; 0x28
   1b8aa:	4298      	cmp	r0, r3
   1b8ac:	da04      	bge.n	1b8b8 <silk_find_LPC_FIX+0x1a0>
                psEncC->indices.NLSFInterpCoef_Q2 = (opus_int8)k;
   1b8ae:	68fb      	ldr	r3, [r7, #12]
                res_nrg   = res_nrg_interp;
   1b8b0:	62b9      	str	r1, [r7, #40]	; 0x28
                res_nrg_Q = res_nrg_interp_Q;
   1b8b2:	633a      	str	r2, [r7, #48]	; 0x30
                psEncC->indices.NLSFInterpCoef_Q2 = (opus_int8)k;
   1b8b4:	f883 9000 	strb.w	r9, [r3]
        for( k = 3; k >= 0; k-- ) {
   1b8b8:	f119 39ff 	adds.w	r9, r9, #4294967295	; 0xffffffff
   1b8bc:	d2b0      	bcs.n	1b820 <silk_find_LPC_FIX+0x108>
   1b8be:	687c      	ldr	r4, [r7, #4]
   1b8c0:	f8d7 d008 	ldr.w	sp, [r7, #8]
   1b8c4:	e75b      	b.n	1b77e <silk_find_LPC_FIX+0x66>
        silk_A2NLSF( NLSF_Q15, a_Q16, psEncC->predictLPCOrder );
   1b8c6:	f107 0178 	add.w	r1, r7, #120	; 0x78
   1b8ca:	6978      	ldr	r0, [r7, #20]
   1b8cc:	6832      	ldr	r2, [r6, #0]
   1b8ce:	f7fa fec7 	bl	16660 <silk_A2NLSF>
}
   1b8d2:	37fc      	adds	r7, #252	; 0xfc
   1b8d4:	46bd      	mov	sp, r7
   1b8d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            res_nrg   = silk_RSHIFT( res_nrg, -shift ) - res_tmp_nrg;
   1b8da:	6ab9      	ldr	r1, [r7, #40]	; 0x28
            res_nrg_Q = res_tmp_nrg_Q;
   1b8dc:	633a      	str	r2, [r7, #48]	; 0x30
            res_nrg   = silk_RSHIFT( res_nrg, -shift ) - res_tmp_nrg;
   1b8de:	425b      	negs	r3, r3
   1b8e0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   1b8e2:	fa41 f303 	asr.w	r3, r1, r3
   1b8e6:	1a9b      	subs	r3, r3, r2
   1b8e8:	62bb      	str	r3, [r7, #40]	; 0x28
   1b8ea:	e77a      	b.n	1b7e2 <silk_find_LPC_FIX+0xca>
                    if( res_nrg_interp < silk_RSHIFT( res_nrg, -shift ) ) {
   1b8ec:	4258      	negs	r0, r3
                if( -shift < 32 ) {
   1b8ee:	331f      	adds	r3, #31
   1b8f0:	dbe2      	blt.n	1b8b8 <silk_find_LPC_FIX+0x1a0>
                    if( res_nrg_interp < silk_RSHIFT( res_nrg, -shift ) ) {
   1b8f2:	6abb      	ldr	r3, [r7, #40]	; 0x28
   1b8f4:	4103      	asrs	r3, r0
   1b8f6:	428b      	cmp	r3, r1
   1b8f8:	ddde      	ble.n	1b8b8 <silk_find_LPC_FIX+0x1a0>
   1b8fa:	e7d8      	b.n	1b8ae <silk_find_LPC_FIX+0x196>
   1b8fc:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
                res_nrg0         = silk_RSHIFT( res_nrg0, -shift );
   1b900:	f1cc 0c00 	rsb	ip, ip, #0
   1b904:	fa40 f00c 	asr.w	r0, r0, ip
                res_nrg_interp_Q = -rshift1;
   1b908:	4252      	negs	r2, r2
                res_nrg0         = silk_RSHIFT( res_nrg0, -shift );
   1b90a:	61b8      	str	r0, [r7, #24]
   1b90c:	e7c6      	b.n	1b89c <silk_find_LPC_FIX+0x184>
   1b90e:	bf00      	nop

0001b910 <silk_find_LTP_FIX>:
    const opus_int                  lag[ MAX_NB_SUBFR ],                    /* I    LTP lags                                                                    */
    const opus_int                  subfr_length,                           /* I    Subframe length                                                             */
    const opus_int                  nb_subfr,                               /* I    Number of subframes                                                         */
    int                             arch                                    /* I    Run-time architecture                                                       */
)
{
   1b910:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1b914:	b08d      	sub	sp, #52	; 0x34
   1b916:	9c17      	ldr	r4, [sp, #92]	; 0x5c
    opus_int32 *XXLTP_Q17_ptr, *xXLTP_Q17_ptr;
    opus_int32 xx, nrg, temp;

    xXLTP_Q17_ptr = xXLTP_Q17;
    XXLTP_Q17_ptr = XXLTP_Q17;
    for( k = 0; k < nb_subfr; k++ ) {
   1b918:	2c00      	cmp	r4, #0
   1b91a:	f340 80b1 	ble.w	1ba80 <silk_find_LTP_FIX+0x170>
   1b91e:	f1a3 0b04 	sub.w	fp, r3, #4
   1b922:	eb0b 0384 	add.w	r3, fp, r4, lsl #2
   1b926:	9307      	str	r3, [sp, #28]
        for( i = 0; i < LTP_ORDER; i++ ) {
            xXLTP_Q17_ptr[ i ] = (opus_int32)( silk_LSHIFT64( (opus_int64)xXLTP_Q17_ptr[ i ], 17 ) / temp );
        }
#endif
TOC(div)
        r_ptr         += subfr_length;
   1b928:	9b16      	ldr	r3, [sp, #88]	; 0x58
   1b92a:	005b      	lsls	r3, r3, #1
   1b92c:	9305      	str	r3, [sp, #20]
   1b92e:	9b16      	ldr	r3, [sp, #88]	; 0x58
   1b930:	3305      	adds	r3, #5
   1b932:	4692      	mov	sl, r2
   1b934:	f101 0914 	add.w	r9, r1, #20
   1b938:	1f05      	subs	r5, r0, #4
   1b93a:	9306      	str	r3, [sp, #24]
        lag_ptr = r_ptr - ( lag[ k ] + LTP_ORDER / 2 );
   1b93c:	f85b 6f04 	ldr.w	r6, [fp, #4]!
        silk_sum_sqr_shift( &xx, &xx_shifts, r_ptr, subfr_length + LTP_ORDER );                            /* xx in Q( -xx_shifts ) */
   1b940:	9b06      	ldr	r3, [sp, #24]
   1b942:	4652      	mov	r2, sl
   1b944:	a908      	add	r1, sp, #32
   1b946:	a80a      	add	r0, sp, #40	; 0x28
   1b948:	f7fe fafe 	bl	19f48 <silk_sum_sqr_shift>
        lag_ptr = r_ptr - ( lag[ k ] + LTP_ORDER / 2 );
   1b94c:	ebc6 76c6 	rsb	r6, r6, r6, lsl #31
        silk_corrMatrix_FIX( lag_ptr, subfr_length, LTP_ORDER, XXLTP_Q17_ptr, &nrg, &XX_shifts, arch );    /* XXLTP_Q17_ptr and nrg in Q( -XX_shifts ) */
   1b950:	9b18      	ldr	r3, [sp, #96]	; 0x60
   1b952:	9302      	str	r3, [sp, #8]
        lag_ptr = r_ptr - ( lag[ k ] + LTP_ORDER / 2 );
   1b954:	eb0a 0646 	add.w	r6, sl, r6, lsl #1
        silk_corrMatrix_FIX( lag_ptr, subfr_length, LTP_ORDER, XXLTP_Q17_ptr, &nrg, &XX_shifts, arch );    /* XXLTP_Q17_ptr and nrg in Q( -XX_shifts ) */
   1b958:	ab09      	add	r3, sp, #36	; 0x24
   1b95a:	9301      	str	r3, [sp, #4]
        lag_ptr = r_ptr - ( lag[ k ] + LTP_ORDER / 2 );
   1b95c:	3e04      	subs	r6, #4
        silk_corrMatrix_FIX( lag_ptr, subfr_length, LTP_ORDER, XXLTP_Q17_ptr, &nrg, &XX_shifts, arch );    /* XXLTP_Q17_ptr and nrg in Q( -XX_shifts ) */
   1b95e:	ab0b      	add	r3, sp, #44	; 0x2c
   1b960:	1d2c      	adds	r4, r5, #4
   1b962:	9300      	str	r3, [sp, #0]
   1b964:	4630      	mov	r0, r6
   1b966:	2205      	movs	r2, #5
   1b968:	9916      	ldr	r1, [sp, #88]	; 0x58
   1b96a:	4623      	mov	r3, r4
   1b96c:	f7fe ffc2 	bl	1a8f4 <silk_corrMatrix_FIX>
        extra_shifts = xx_shifts - XX_shifts;
   1b970:	e9dd 0708 	ldrd	r0, r7, [sp, #32]
   1b974:	1bc2      	subs	r2, r0, r7
        if( extra_shifts > 0 ) {
   1b976:	2a00      	cmp	r2, #0
   1b978:	f1a9 0114 	sub.w	r1, r9, #20
   1b97c:	f340 8083 	ble.w	1ba86 <silk_find_LTP_FIX+0x176>
   1b980:	f105 0864 	add.w	r8, r5, #100	; 0x64
                XXLTP_Q17_ptr[ i ] = silk_RSHIFT32( XXLTP_Q17_ptr[ i ], extra_shifts );              /* Q( -xX_shifts ) */
   1b984:	f855 3f04 	ldr.w	r3, [r5, #4]!
   1b988:	4113      	asrs	r3, r2
            for( i = 0; i < LTP_ORDER * LTP_ORDER; i++ ) {
   1b98a:	45a8      	cmp	r8, r5
                XXLTP_Q17_ptr[ i ] = silk_RSHIFT32( XXLTP_Q17_ptr[ i ], extra_shifts );              /* Q( -xX_shifts ) */
   1b98c:	602b      	str	r3, [r5, #0]
            for( i = 0; i < LTP_ORDER * LTP_ORDER; i++ ) {
   1b98e:	d1f9      	bne.n	1b984 <silk_find_LTP_FIX+0x74>
            nrg = silk_RSHIFT32( nrg, extra_shifts );                                                /* Q( -xX_shifts ) */
   1b990:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1b992:	fa43 f202 	asr.w	r2, r3, r2
   1b996:	920b      	str	r2, [sp, #44]	; 0x2c
        silk_corrVector_FIX( lag_ptr, r_ptr, subfr_length, LTP_ORDER, xXLTP_Q17_ptr, xX_shifts, arch );    /* xXLTP_Q17_ptr in Q( -xX_shifts ) */
   1b998:	9b18      	ldr	r3, [sp, #96]	; 0x60
   1b99a:	9100      	str	r1, [sp, #0]
   1b99c:	e9cd 0301 	strd	r0, r3, [sp, #4]
   1b9a0:	9a16      	ldr	r2, [sp, #88]	; 0x58
   1b9a2:	4630      	mov	r0, r6
   1b9a4:	2305      	movs	r3, #5
   1b9a6:	4651      	mov	r1, sl
   1b9a8:	f7fe ff56 	bl	1a858 <silk_corrVector_FIX>
        temp = silk_max( temp, xx );
   1b9ac:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
        temp = silk_SMLAWB( 1, nrg, SILK_FIX_CONST( LTP_CORR_INV_MAX, 16 ) );
   1b9b0:	f240 70ae 	movw	r0, #1966	; 0x7ae
   1b9b4:	b299      	uxth	r1, r3
   1b9b6:	141b      	asrs	r3, r3, #16
   1b9b8:	fb00 f603 	mul.w	r6, r0, r3
   1b9bc:	fb00 f101 	mul.w	r1, r0, r1
   1b9c0:	eb06 4311 	add.w	r3, r6, r1, lsr #16
   1b9c4:	1c5e      	adds	r6, r3, #1
        temp = silk_max( temp, xx );
   1b9c6:	4296      	cmp	r6, r2
   1b9c8:	bfb8      	it	lt
   1b9ca:	4616      	movlt	r6, r2
   1b9cc:	17f7      	asrs	r7, r6, #31
   1b9ce:	e000      	b.n	1b9d2 <silk_find_LTP_FIX+0xc2>
   1b9d0:	3404      	adds	r4, #4
            XXLTP_Q17_ptr[ i ] = (opus_int32)( silk_LSHIFT64( (opus_int64)XXLTP_Q17_ptr[ i ], 17 ) / temp );
   1b9d2:	6820      	ldr	r0, [r4, #0]
   1b9d4:	17c3      	asrs	r3, r0, #31
   1b9d6:	0459      	lsls	r1, r3, #17
   1b9d8:	ea41 31d0 	orr.w	r1, r1, r0, lsr #15
   1b9dc:	4632      	mov	r2, r6
   1b9de:	0440      	lsls	r0, r0, #17
   1b9e0:	463b      	mov	r3, r7
   1b9e2:	f7f0 fc77 	bl	c2d4 <__aeabi_ldivmod>
        for( i = 0; i < LTP_ORDER * LTP_ORDER; i++ ) {
   1b9e6:	45a0      	cmp	r8, r4
   1b9e8:	4625      	mov	r5, r4
            XXLTP_Q17_ptr[ i ] = (opus_int32)( silk_LSHIFT64( (opus_int64)XXLTP_Q17_ptr[ i ], 17 ) / temp );
   1b9ea:	6020      	str	r0, [r4, #0]
        for( i = 0; i < LTP_ORDER * LTP_ORDER; i++ ) {
   1b9ec:	d1f0      	bne.n	1b9d0 <silk_find_LTP_FIX+0xc0>
            xXLTP_Q17_ptr[ i ] = (opus_int32)( silk_LSHIFT64( (opus_int64)xXLTP_Q17_ptr[ i ], 17 ) / temp );
   1b9ee:	f859 0c14 	ldr.w	r0, [r9, #-20]
   1b9f2:	17c3      	asrs	r3, r0, #31
   1b9f4:	0459      	lsls	r1, r3, #17
   1b9f6:	ea41 31d0 	orr.w	r1, r1, r0, lsr #15
   1b9fa:	4632      	mov	r2, r6
   1b9fc:	463b      	mov	r3, r7
   1b9fe:	0440      	lsls	r0, r0, #17
   1ba00:	f7f0 fc68 	bl	c2d4 <__aeabi_ldivmod>
   1ba04:	f859 3c10 	ldr.w	r3, [r9, #-16]
   1ba08:	f849 0c14 	str.w	r0, [r9, #-20]
   1ba0c:	17d9      	asrs	r1, r3, #31
   1ba0e:	0449      	lsls	r1, r1, #17
   1ba10:	ea41 31d3 	orr.w	r1, r1, r3, lsr #15
   1ba14:	0458      	lsls	r0, r3, #17
   1ba16:	4632      	mov	r2, r6
   1ba18:	463b      	mov	r3, r7
   1ba1a:	f7f0 fc5b 	bl	c2d4 <__aeabi_ldivmod>
   1ba1e:	f859 3c0c 	ldr.w	r3, [r9, #-12]
   1ba22:	f849 0c10 	str.w	r0, [r9, #-16]
   1ba26:	17d9      	asrs	r1, r3, #31
   1ba28:	0449      	lsls	r1, r1, #17
   1ba2a:	ea41 31d3 	orr.w	r1, r1, r3, lsr #15
   1ba2e:	0458      	lsls	r0, r3, #17
   1ba30:	4632      	mov	r2, r6
   1ba32:	463b      	mov	r3, r7
   1ba34:	f7f0 fc4e 	bl	c2d4 <__aeabi_ldivmod>
   1ba38:	f859 3c08 	ldr.w	r3, [r9, #-8]
   1ba3c:	f849 0c0c 	str.w	r0, [r9, #-12]
   1ba40:	17d9      	asrs	r1, r3, #31
   1ba42:	0449      	lsls	r1, r1, #17
   1ba44:	ea41 31d3 	orr.w	r1, r1, r3, lsr #15
   1ba48:	0458      	lsls	r0, r3, #17
   1ba4a:	4632      	mov	r2, r6
   1ba4c:	463b      	mov	r3, r7
   1ba4e:	f7f0 fc41 	bl	c2d4 <__aeabi_ldivmod>
   1ba52:	f859 4c04 	ldr.w	r4, [r9, #-4]
   1ba56:	f849 0c08 	str.w	r0, [r9, #-8]
   1ba5a:	17e1      	asrs	r1, r4, #31
   1ba5c:	0449      	lsls	r1, r1, #17
   1ba5e:	463b      	mov	r3, r7
   1ba60:	4632      	mov	r2, r6
   1ba62:	ea41 31d4 	orr.w	r1, r1, r4, lsr #15
   1ba66:	0460      	lsls	r0, r4, #17
   1ba68:	f7f0 fc34 	bl	c2d4 <__aeabi_ldivmod>
        r_ptr         += subfr_length;
   1ba6c:	9b05      	ldr	r3, [sp, #20]
            xXLTP_Q17_ptr[ i ] = (opus_int32)( silk_LSHIFT64( (opus_int64)xXLTP_Q17_ptr[ i ], 17 ) / temp );
   1ba6e:	f849 0c04 	str.w	r0, [r9, #-4]
        r_ptr         += subfr_length;
   1ba72:	449a      	add	sl, r3
    for( k = 0; k < nb_subfr; k++ ) {
   1ba74:	9b07      	ldr	r3, [sp, #28]
   1ba76:	459b      	cmp	fp, r3
   1ba78:	f109 0914 	add.w	r9, r9, #20
   1ba7c:	f47f af5e 	bne.w	1b93c <silk_find_LTP_FIX+0x2c>
        XXLTP_Q17_ptr += LTP_ORDER * LTP_ORDER;
        xXLTP_Q17_ptr += LTP_ORDER;
    }
}
   1ba80:	b00d      	add	sp, #52	; 0x34
   1ba82:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        } else if( extra_shifts < 0 ) {
   1ba86:	d102      	bne.n	1ba8e <silk_find_LTP_FIX+0x17e>
   1ba88:	f105 0864 	add.w	r8, r5, #100	; 0x64
   1ba8c:	e784      	b.n	1b998 <silk_find_LTP_FIX+0x88>
            xx = silk_RSHIFT32( xx, -extra_shifts );                                                 /* Q( -xX_shifts ) */
   1ba8e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1ba90:	4252      	negs	r2, r2
   1ba92:	fa43 f202 	asr.w	r2, r3, r2
            xX_shifts = XX_shifts;
   1ba96:	4638      	mov	r0, r7
   1ba98:	f105 0864 	add.w	r8, r5, #100	; 0x64
            xx = silk_RSHIFT32( xx, -extra_shifts );                                                 /* Q( -xX_shifts ) */
   1ba9c:	920a      	str	r2, [sp, #40]	; 0x28
   1ba9e:	e77b      	b.n	1b998 <silk_find_LTP_FIX+0x88>

0001baa0 <silk_find_pitch_lags_FIX>:
    silk_encoder_control_FIX        *psEncCtrl,                             /* I/O  encoder control                                                             */
    opus_int16                      res[],                                  /* O    residual                                                                    */
    const opus_int16                x[],                                    /* I    Speech signal                                                               */
    int                             arch                                    /* I    Run-time architecture                                                       */
)
{
   1baa0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1baa4:	4604      	mov	r4, r0
   1baa6:	b0bf      	sub	sp, #252	; 0xfc
    /* Estimate LPC AR coefficients      */
    /*************************************/

    /* Calculate windowed signal */

    ALLOC( Wsig, psEnc->sCmn.pitch_LPC_win_length, opus_int16 );
   1baa8:	f241 1ac4 	movw	sl, #4548	; 0x11c4
    buf_len = psEnc->sCmn.la_pitch + psEnc->sCmn.frame_length + psEnc->sCmn.ltp_mem_length;
   1baac:	f241 16f4 	movw	r6, #4596	; 0x11f4
   1bab0:	f241 10e8 	movw	r0, #4584	; 0x11e8
    ALLOC( Wsig, psEnc->sCmn.pitch_LPC_win_length, opus_int16 );
   1bab4:	f854 500a 	ldr.w	r5, [r4, sl]
    buf_len = psEnc->sCmn.la_pitch + psEnc->sCmn.frame_length + psEnc->sCmn.ltp_mem_length;
   1bab8:	f854 c006 	ldr.w	ip, [r4, r6]
   1babc:	5820      	ldr	r0, [r4, r0]
   1babe:	f241 1ef0 	movw	lr, #4592	; 0x11f0
    ALLOC( Wsig, psEnc->sCmn.pitch_LPC_win_length, opus_int16 );
   1bac2:	ea4f 0945 	mov.w	r9, r5, lsl #1
    buf_len = psEnc->sCmn.la_pitch + psEnc->sCmn.frame_length + psEnc->sCmn.ltp_mem_length;
   1bac6:	f854 800e 	ldr.w	r8, [r4, lr]
    ALLOC( Wsig, psEnc->sCmn.pitch_LPC_win_length, opus_int16 );
   1baca:	f109 0908 	add.w	r9, r9, #8
    buf_len = psEnc->sCmn.la_pitch + psEnc->sCmn.frame_length + psEnc->sCmn.ltp_mem_length;
   1bace:	eb0c 0e00 	add.w	lr, ip, r0
   1bad2:	eb0e 0008 	add.w	r0, lr, r8
    ALLOC( Wsig, psEnc->sCmn.pitch_LPC_win_length, opus_int16 );
   1bad6:	f029 0907 	bic.w	r9, r9, #7
{
   1bada:	af08      	add	r7, sp, #32

    /* First LA_LTP samples */
    x_ptr = x + buf_len - psEnc->sCmn.pitch_LPC_win_length;
   1badc:	1b45      	subs	r5, r0, r5
    ALLOC( Wsig, psEnc->sCmn.pitch_LPC_win_length, opus_int16 );
   1bade:	ebad 0d09 	sub.w	sp, sp, r9
   1bae2:	f10d 0920 	add.w	r9, sp, #32
    x_ptr = x + buf_len - psEnc->sCmn.pitch_LPC_win_length;
   1bae6:	eb03 0545 	add.w	r5, r3, r5, lsl #1
    buf_len = psEnc->sCmn.la_pitch + psEnc->sCmn.frame_length + psEnc->sCmn.ltp_mem_length;
   1baea:	60f8      	str	r0, [r7, #12]
{
   1baec:	607b      	str	r3, [r7, #4]
   1baee:	60ba      	str	r2, [r7, #8]
    Wsig_ptr  = Wsig;
    silk_apply_sine_window( Wsig_ptr, x_ptr, 1, psEnc->sCmn.la_pitch );
   1baf0:	4663      	mov	r3, ip
   1baf2:	4648      	mov	r0, r9
   1baf4:	2201      	movs	r2, #1
{
   1baf6:	468b      	mov	fp, r1
    silk_apply_sine_window( Wsig_ptr, x_ptr, 1, psEnc->sCmn.la_pitch );
   1baf8:	4629      	mov	r1, r5
   1bafa:	f002 f93d 	bl	1dd78 <silk_apply_sine_window>

    /* Middle un - windowed samples */
    Wsig_ptr  += psEnc->sCmn.la_pitch;
   1bafe:	59a3      	ldr	r3, [r4, r6]
    x_ptr += psEnc->sCmn.la_pitch;
    silk_memcpy( Wsig_ptr, x_ptr, ( psEnc->sCmn.pitch_LPC_win_length - silk_LSHIFT( psEnc->sCmn.la_pitch, 1 ) ) * sizeof( opus_int16 ) );
   1bb00:	f854 600a 	ldr.w	r6, [r4, sl]
    Wsig_ptr  += psEnc->sCmn.la_pitch;
   1bb04:	603b      	str	r3, [r7, #0]
   1bb06:	ea4f 0843 	mov.w	r8, r3, lsl #1
    silk_memcpy( Wsig_ptr, x_ptr, ( psEnc->sCmn.pitch_LPC_win_length - silk_LSHIFT( psEnc->sCmn.la_pitch, 1 ) ) * sizeof( opus_int16 ) );
   1bb0a:	eba6 0608 	sub.w	r6, r6, r8
    x_ptr += psEnc->sCmn.la_pitch;
   1bb0e:	4445      	add	r5, r8
    silk_memcpy( Wsig_ptr, x_ptr, ( psEnc->sCmn.pitch_LPC_win_length - silk_LSHIFT( psEnc->sCmn.la_pitch, 1 ) ) * sizeof( opus_int16 ) );
   1bb10:	0076      	lsls	r6, r6, #1
    Wsig_ptr  += psEnc->sCmn.la_pitch;
   1bb12:	44c8      	add	r8, r9
    silk_memcpy( Wsig_ptr, x_ptr, ( psEnc->sCmn.pitch_LPC_win_length - silk_LSHIFT( psEnc->sCmn.la_pitch, 1 ) ) * sizeof( opus_int16 ) );
   1bb14:	4629      	mov	r1, r5
   1bb16:	4632      	mov	r2, r6
   1bb18:	4640      	mov	r0, r8
   1bb1a:	f7f0 faf1 	bl	c100 <memcpy>

    /* Last LA_LTP samples */
    Wsig_ptr  += psEnc->sCmn.pitch_LPC_win_length - silk_LSHIFT( psEnc->sCmn.la_pitch, 1 );
    x_ptr += psEnc->sCmn.pitch_LPC_win_length - silk_LSHIFT( psEnc->sCmn.la_pitch, 1 );
    silk_apply_sine_window( Wsig_ptr, x_ptr, 2, psEnc->sCmn.la_pitch );
   1bb1e:	19a9      	adds	r1, r5, r6

    /* Calculate autocorrelation sequence */
    silk_autocorr( auto_corr, &scale, Wsig, psEnc->sCmn.pitch_LPC_win_length, psEnc->sCmn.pitchEstimationLPCOrder + 1, arch );
   1bb20:	f241 2528 	movw	r5, #4648	; 0x1228
    silk_apply_sine_window( Wsig_ptr, x_ptr, 2, psEnc->sCmn.la_pitch );
   1bb24:	683b      	ldr	r3, [r7, #0]
   1bb26:	eb08 0006 	add.w	r0, r8, r6
   1bb2a:	2202      	movs	r2, #2
   1bb2c:	f002 f924 	bl	1dd78 <silk_apply_sine_window>
    silk_autocorr( auto_corr, &scale, Wsig, psEnc->sCmn.pitch_LPC_win_length, psEnc->sCmn.pitchEstimationLPCOrder + 1, arch );
   1bb30:	5961      	ldr	r1, [r4, r5]
   1bb32:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
   1bb36:	f854 300a 	ldr.w	r3, [r4, sl]
   1bb3a:	9201      	str	r2, [sp, #4]
   1bb3c:	3101      	adds	r1, #1
   1bb3e:	464a      	mov	r2, r9
   1bb40:	9100      	str	r1, [sp, #0]
   1bb42:	f107 0094 	add.w	r0, r7, #148	; 0x94
   1bb46:	f107 0110 	add.w	r1, r7, #16
   1bb4a:	f002 f997 	bl	1de7c <silk_autocorr>

    /* Add white noise, as fraction of energy */
    auto_corr[ 0 ] = silk_SMLAWB( auto_corr[ 0 ], auto_corr[ 0 ], SILK_FIX_CONST( FIND_PITCH_WHITE_NOISE_FRACTION, 16 ) ) + 1;
   1bb4e:	f8d7 0094 	ldr.w	r0, [r7, #148]	; 0x94

    /* Calculate the reflection coefficients using schur */
    res_nrg = silk_schur( rc_Q15, auto_corr, psEnc->sCmn.pitchEstimationLPCOrder );
   1bb52:	5962      	ldr	r2, [r4, r5]
    auto_corr[ 0 ] = silk_SMLAWB( auto_corr[ 0 ], auto_corr[ 0 ], SILK_FIX_CONST( FIND_PITCH_WHITE_NOISE_FRACTION, 16 ) ) + 1;
   1bb54:	1403      	asrs	r3, r0, #16
   1bb56:	b281      	uxth	r1, r0
   1bb58:	eb03 1343 	add.w	r3, r3, r3, lsl #5
   1bb5c:	eb01 1141 	add.w	r1, r1, r1, lsl #5
   1bb60:	005b      	lsls	r3, r3, #1
   1bb62:	eb03 33d1 	add.w	r3, r3, r1, lsr #15
   1bb66:	4403      	add	r3, r0
   1bb68:	3301      	adds	r3, #1
    res_nrg = silk_schur( rc_Q15, auto_corr, psEnc->sCmn.pitchEstimationLPCOrder );
   1bb6a:	f107 0194 	add.w	r1, r7, #148	; 0x94
   1bb6e:	f107 0014 	add.w	r0, r7, #20
    auto_corr[ 0 ] = silk_SMLAWB( auto_corr[ 0 ], auto_corr[ 0 ], SILK_FIX_CONST( FIND_PITCH_WHITE_NOISE_FRACTION, 16 ) ) + 1;
   1bb72:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
    res_nrg = silk_schur( rc_Q15, auto_corr, psEnc->sCmn.pitchEstimationLPCOrder );
   1bb76:	f004 fa07 	bl	1ff88 <silk_schur>

    /* Prediction gain */
    psEncCtrl->predGain_Q16 = silk_DIV32_varQ( auto_corr[ 0 ], silk_max_int( res_nrg, 1 ), 16 );
   1bb7a:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
    return (((a) > (b)) ? (a) : (b));
   1bb7e:	2801      	cmp	r0, #1
   1bb80:	bfb8      	it	lt
   1bb82:	2001      	movlt	r0, #1
   1bb84:	2a00      	cmp	r2, #0
   1bb86:	f000 8090 	beq.w	1bcaa <silk_find_pitch_lags_FIX+0x20a>
    a_headrm = silk_CLZ32( silk_abs(a32) ) - 1;
   1bb8a:	ea82 75e2 	eor.w	r5, r2, r2, asr #31
   1bb8e:	eba5 75e2 	sub.w	r5, r5, r2, asr #31
   1bb92:	fab5 f585 	clz	r5, r5
   1bb96:	1e6b      	subs	r3, r5, #1
   1bb98:	351c      	adds	r5, #28
   1bb9a:	fab0 fc80 	clz	ip, r0
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
   1bb9e:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
    a32_nrm = silk_LSHIFT(a32, a_headrm);                                       /* Q: a_headrm                  */
   1bba2:	409a      	lsls	r2, r3
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                  */
   1bba4:	fa00 f00c 	lsl.w	r0, r0, ip
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1bba8:	1401      	asrs	r1, r0, #16
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1bbaa:	1416      	asrs	r6, r2, #16
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1bbac:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
   1bbb0:	fb93 f3f1 	sdiv	r3, r3, r1
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1bbb4:	b291      	uxth	r1, r2
   1bbb6:	b21b      	sxth	r3, r3
   1bbb8:	fb03 f101 	mul.w	r1, r3, r1
   1bbbc:	fb03 f606 	mul.w	r6, r3, r6
   1bbc0:	eb06 4621 	add.w	r6, r6, r1, asr #16
    a32_nrm = silk_SUB32_ovflw(a32_nrm, silk_LSHIFT_ovflw( silk_SMMUL(b32_nrm, result), 3 ));  /* Q: a_headrm   */
   1bbc4:	fb80 0106 	smull	r0, r1, r0, r6
   1bbc8:	eba2 02c1 	sub.w	r2, r2, r1, lsl #3
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1bbcc:	b291      	uxth	r1, r2
   1bbce:	1412      	asrs	r2, r2, #16
   1bbd0:	fb03 f101 	mul.w	r1, r3, r1
    lshift = 29 + a_headrm - b_headrm - Qres;
   1bbd4:	eba5 050c 	sub.w	r5, r5, ip
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1bbd8:	fb03 f302 	mul.w	r3, r3, r2
   1bbdc:	eb03 4321 	add.w	r3, r3, r1, asr #16
    if( lshift < 0 ) {
   1bbe0:	f1b5 0210 	subs.w	r2, r5, #16
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1bbe4:	4433      	add	r3, r6
    if( lshift < 0 ) {
   1bbe6:	f100 80d7 	bmi.w	1bd98 <silk_find_pitch_lags_FIX+0x2f8>
        if( lshift < 32){
   1bbea:	2a1f      	cmp	r2, #31
            return silk_RSHIFT(result, lshift);
   1bbec:	bfd4      	ite	le
   1bbee:	4113      	asrle	r3, r2
            return 0;
   1bbf0:	2300      	movgt	r3, #0

    /* Convert reflection coefficients to prediction coefficients */
    silk_k2a( A_Q24, rc_Q15, psEnc->sCmn.pitchEstimationLPCOrder );
   1bbf2:	f241 2528 	movw	r5, #4648	; 0x1228
   1bbf6:	f107 0114 	add.w	r1, r7, #20
    psEncCtrl->predGain_Q16 = silk_DIV32_varQ( auto_corr[ 0 ], silk_max_int( res_nrg, 1 ), 16 );
   1bbfa:	f8cb 3188 	str.w	r3, [fp, #392]	; 0x188
    silk_k2a( A_Q24, rc_Q15, psEnc->sCmn.pitchEstimationLPCOrder );
   1bbfe:	5962      	ldr	r2, [r4, r5]
   1bc00:	f107 0054 	add.w	r0, r7, #84	; 0x54
   1bc04:	f002 fed8 	bl	1e9b8 <silk_k2a>

    /* Convert From 32 bit Q24 to 16 bit Q12 coefs */
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1bc08:	5961      	ldr	r1, [r4, r5]
   1bc0a:	2900      	cmp	r1, #0
   1bc0c:	dd18      	ble.n	1bc40 <silk_find_pitch_lags_FIX+0x1a0>
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1bc0e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1bc10:	131b      	asrs	r3, r3, #12
   1bc12:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1bc16:	db4b      	blt.n	1bcb0 <silk_find_pitch_lags_FIX+0x210>
   1bc18:	f647 73ff 	movw	r3, #32767	; 0x7fff
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1bc1c:	2901      	cmp	r1, #1
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1bc1e:	86bb      	strh	r3, [r7, #52]	; 0x34
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1bc20:	d00e      	beq.n	1bc40 <silk_find_pitch_lags_FIX+0x1a0>
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1bc22:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   1bc24:	131b      	asrs	r3, r3, #12
   1bc26:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1bc2a:	f280 80a4 	bge.w	1bd76 <silk_find_pitch_lags_FIX+0x2d6>
   1bc2e:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   1bc32:	f2c0 8140 	blt.w	1beb6 <silk_find_pitch_lags_FIX+0x416>
   1bc36:	b21b      	sxth	r3, r3
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1bc38:	2902      	cmp	r1, #2
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1bc3a:	86fb      	strh	r3, [r7, #54]	; 0x36
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1bc3c:	f040 80a1 	bne.w	1bd82 <silk_find_pitch_lags_FIX+0x2e2>
    }

    /* Do BWE */
    silk_bwexpander( A_Q12, psEnc->sCmn.pitchEstimationLPCOrder, SILK_FIX_CONST( FIND_PITCH_BANDWIDTH_EXPANSION, 16 ) );
   1bc40:	f107 0034 	add.w	r0, r7, #52	; 0x34
   1bc44:	f64f 5271 	movw	r2, #64881	; 0xfd71

    /*****************************************/
    /* LPC analysis filtering                */
    /*****************************************/
    silk_LPC_analysis_filter( res, x, A_Q12, buf_len, psEnc->sCmn.pitchEstimationLPCOrder, psEnc->sCmn.arch );
   1bc48:	f241 36e4 	movw	r6, #5092	; 0x13e4
   1bc4c:	f241 2828 	movw	r8, #4648	; 0x1228
    silk_bwexpander( A_Q12, psEnc->sCmn.pitchEstimationLPCOrder, SILK_FIX_CONST( FIND_PITCH_BANDWIDTH_EXPANSION, 16 ) );
   1bc50:	f7fb fe74 	bl	1793c <silk_bwexpander>
    silk_LPC_analysis_filter( res, x, A_Q12, buf_len, psEnc->sCmn.pitchEstimationLPCOrder, psEnc->sCmn.arch );
   1bc54:	f8d7 a008 	ldr.w	sl, [r7, #8]
   1bc58:	59a3      	ldr	r3, [r4, r6]
   1bc5a:	f854 0008 	ldr.w	r0, [r4, r8]
   1bc5e:	6879      	ldr	r1, [r7, #4]
   1bc60:	9301      	str	r3, [sp, #4]

    if( psEnc->sCmn.indices.signalType != TYPE_NO_VOICE_ACTIVITY && psEnc->sCmn.first_frame_after_reset == 0 ) {
   1bc62:	f241 259d 	movw	r5, #4765	; 0x129d
    silk_LPC_analysis_filter( res, x, A_Q12, buf_len, psEnc->sCmn.pitchEstimationLPCOrder, psEnc->sCmn.arch );
   1bc66:	68fb      	ldr	r3, [r7, #12]
   1bc68:	9000      	str	r0, [sp, #0]
   1bc6a:	f107 0234 	add.w	r2, r7, #52	; 0x34
   1bc6e:	4650      	mov	r0, sl
   1bc70:	f7fb ff0c 	bl	17a8c <silk_LPC_analysis_filter>
    if( psEnc->sCmn.indices.signalType != TYPE_NO_VOICE_ACTIVITY && psEnc->sCmn.first_frame_after_reset == 0 ) {
   1bc74:	5763      	ldrsb	r3, [r4, r5]
   1bc76:	f10b 017c 	add.w	r1, fp, #124	; 0x7c
   1bc7a:	b11b      	cbz	r3, 1bc84 <silk_find_pitch_lags_FIX+0x1e4>
   1bc7c:	f241 2338 	movw	r3, #4664	; 0x1238
   1bc80:	58e3      	ldr	r3, [r4, r3]
   1bc82:	b1db      	cbz	r3, 1bcbc <silk_find_pitch_lags_FIX+0x21c>
        } else {
            psEnc->sCmn.indices.signalType = TYPE_UNVOICED;
        }
    } else {
        silk_memset( psEncCtrl->pitchL, 0, sizeof( psEncCtrl->pitchL ) );
        psEnc->sCmn.indices.lagIndex = 0;
   1bc84:	f241 259a 	movw	r5, #4762	; 0x129a
        psEnc->sCmn.indices.contourIndex = 0;
   1bc88:	f241 209c 	movw	r0, #4764	; 0x129c
        psEnc->LTPCorr_Q15 = 0;
   1bc8c:	f242 12b0 	movw	r2, #8624	; 0x21b0
        silk_memset( psEncCtrl->pitchL, 0, sizeof( psEncCtrl->pitchL ) );
   1bc90:	2300      	movs	r3, #0
    }
    RESTORE_STACK;
}
   1bc92:	37dc      	adds	r7, #220	; 0xdc
        silk_memset( psEncCtrl->pitchL, 0, sizeof( psEncCtrl->pitchL ) );
   1bc94:	f8cb 307c 	str.w	r3, [fp, #124]	; 0x7c
   1bc98:	604b      	str	r3, [r1, #4]
   1bc9a:	608b      	str	r3, [r1, #8]
   1bc9c:	60cb      	str	r3, [r1, #12]
        psEnc->sCmn.indices.lagIndex = 0;
   1bc9e:	5363      	strh	r3, [r4, r5]
        psEnc->sCmn.indices.contourIndex = 0;
   1bca0:	5423      	strb	r3, [r4, r0]
        psEnc->LTPCorr_Q15 = 0;
   1bca2:	50a3      	str	r3, [r4, r2]
}
   1bca4:	46bd      	mov	sp, r7
   1bca6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1bcaa:	253c      	movs	r5, #60	; 0x3c
   1bcac:	231f      	movs	r3, #31
   1bcae:	e774      	b.n	1bb9a <silk_find_pitch_lags_FIX+0xfa>
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1bcb0:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   1bcb4:	f2c0 80f8 	blt.w	1bea8 <silk_find_pitch_lags_FIX+0x408>
   1bcb8:	b21b      	sxth	r3, r3
   1bcba:	e7af      	b.n	1bc1c <silk_find_pitch_lags_FIX+0x17c>
        thrhld_Q13 = silk_SMLAWB( thrhld_Q13, SILK_FIX_CONST( -0.1,   21  ), psEnc->sCmn.speech_activity_Q8 );
   1bcbc:	f241 13b4 	movw	r3, #4532	; 0x11b4
        thrhld_Q13 = silk_SMLABB( thrhld_Q13, SILK_FIX_CONST( -0.004, 13 ), psEnc->sCmn.pitchEstimationLPCOrder );
   1bcc0:	f854 2008 	ldr.w	r2, [r4, r8]
        thrhld_Q13 = silk_SMLAWB( thrhld_Q13, SILK_FIX_CONST( -0.1,   21  ), psEnc->sCmn.speech_activity_Q8 );
   1bcc4:	5ee3      	ldrsh	r3, [r4, r3]
        if( silk_pitch_analysis_core( res, psEncCtrl->pitchL, &psEnc->sCmn.indices.lagIndex, &psEnc->sCmn.indices.contourIndex,
   1bcc6:	59a0      	ldr	r0, [r4, r6]
   1bcc8:	9007      	str	r0, [sp, #28]
        thrhld_Q13 = silk_SMLABB( thrhld_Q13, SILK_FIX_CONST( -0.004, 13 ), psEnc->sCmn.pitchEstimationLPCOrder );
   1bcca:	f64f 7ee0 	movw	lr, #65504	; 0xffe0
   1bcce:	f241 3c33 	movw	ip, #4915	; 0x1333
   1bcd2:	fb12 cc0e 	smlabb	ip, r2, lr, ip
        thrhld_Q13 = silk_SMLAWB( thrhld_Q13, SILK_FIX_CONST( -0.1,   21  ), psEnc->sCmn.speech_activity_Q8 );
   1bcd6:	f64c 46ce 	movw	r6, #52430	; 0xccce
        thrhld_Q13 = silk_SMLABB( thrhld_Q13, SILK_FIX_CONST( -0.15,  13 ), silk_RSHIFT( psEnc->sCmn.prevSignalType, 1 ) );
   1bcda:	f241 10bd 	movw	r0, #4541	; 0x11bd
        thrhld_Q13 = silk_SMLAWB( thrhld_Q13, SILK_FIX_CONST( -0.1,   14 ), psEnc->sCmn.input_tilt_Q15 );
   1bcde:	f241 2268 	movw	r2, #4712	; 0x1268
        thrhld_Q13 = silk_SMLAWB( thrhld_Q13, SILK_FIX_CONST( -0.1,   21  ), psEnc->sCmn.speech_activity_Q8 );
   1bce2:	fb06 f603 	mul.w	r6, r6, r3
        thrhld_Q13 = silk_SMLAWB( thrhld_Q13, SILK_FIX_CONST( -0.1,   14 ), psEnc->sCmn.input_tilt_Q15 );
   1bce6:	5ea2      	ldrsh	r2, [r4, r2]
        thrhld_Q13 = silk_SMLABB( thrhld_Q13, SILK_FIX_CONST( -0.15,  13 ), silk_RSHIFT( psEnc->sCmn.prevSignalType, 1 ) );
   1bce8:	5620      	ldrsb	r0, [r4, r0]
        thrhld_Q13 = silk_SMLAWB( thrhld_Q13, SILK_FIX_CONST( -0.1,   21  ), psEnc->sCmn.speech_activity_Q8 );
   1bcea:	1436      	asrs	r6, r6, #16
   1bcec:	f64f 7efc 	movw	lr, #65532	; 0xfffc
   1bcf0:	fb13 630e 	smlabb	r3, r3, lr, r6
        thrhld_Q13 = silk_SMLABB( thrhld_Q13, SILK_FIX_CONST( -0.15,  13 ), silk_RSHIFT( psEnc->sCmn.prevSignalType, 1 ) );
   1bcf4:	f8df e2f8 	ldr.w	lr, [pc, #760]	; 1bff0 <silk_find_pitch_lags_FIX+0x550>
        thrhld_Q13 = silk_SMLAWB( thrhld_Q13, SILK_FIX_CONST( -0.1,   14 ), psEnc->sCmn.input_tilt_Q15 );
   1bcf8:	f64f 169b 	movw	r6, #63899	; 0xf99b
        thrhld_Q13 = silk_SMLAWB( thrhld_Q13, SILK_FIX_CONST( -0.1,   21  ), psEnc->sCmn.speech_activity_Q8 );
   1bcfc:	4463      	add	r3, ip
        thrhld_Q13 = silk_SMLABB( thrhld_Q13, SILK_FIX_CONST( -0.15,  13 ), silk_RSHIFT( psEnc->sCmn.prevSignalType, 1 ) );
   1bcfe:	1040      	asrs	r0, r0, #1
        thrhld_Q13 = silk_SMLAWB( thrhld_Q13, SILK_FIX_CONST( -0.1,   14 ), psEnc->sCmn.input_tilt_Q15 );
   1bd00:	fb06 f602 	mul.w	r6, r6, r2
        thrhld_Q13 = silk_SMLABB( thrhld_Q13, SILK_FIX_CONST( -0.15,  13 ), silk_RSHIFT( psEnc->sCmn.prevSignalType, 1 ) );
   1bd04:	fb0e 3300 	mla	r3, lr, r0, r3
        thrhld_Q13 = silk_SMLAWB( thrhld_Q13, SILK_FIX_CONST( -0.1,   14 ), psEnc->sCmn.input_tilt_Q15 );
   1bd08:	ebc2 4226 	rsb	r2, r2, r6, asr #16
        if( silk_pitch_analysis_core( res, psEncCtrl->pitchL, &psEnc->sCmn.indices.lagIndex, &psEnc->sCmn.indices.contourIndex,
   1bd0c:	f241 2e24 	movw	lr, #4644	; 0x1224
   1bd10:	f504 508f 	add.w	r0, r4, #4576	; 0x11e0
        thrhld_Q13 = silk_SMLAWB( thrhld_Q13, SILK_FIX_CONST( -0.1,   14 ), psEnc->sCmn.input_tilt_Q15 );
   1bd14:	4413      	add	r3, r2
        if( silk_pitch_analysis_core( res, psEncCtrl->pitchL, &psEnc->sCmn.indices.lagIndex, &psEnc->sCmn.indices.contourIndex,
   1bd16:	f241 262c 	movw	r6, #4652	; 0x122c
   1bd1a:	f241 1ce4 	movw	ip, #4580	; 0x11e4
   1bd1e:	f504 528e 	add.w	r2, r4, #4544	; 0x11c0
   1bd22:	f303 030f 	ssat	r3, #16, r3
   1bd26:	f854 900e 	ldr.w	r9, [r4, lr]
   1bd2a:	f8d0 8000 	ldr.w	r8, [r0]
   1bd2e:	f854 e006 	ldr.w	lr, [r4, r6]
   1bd32:	6812      	ldr	r2, [r2, #0]
   1bd34:	f854 c00c 	ldr.w	ip, [r4, ip]
   1bd38:	9303      	str	r3, [sp, #12]
   1bd3a:	f504 5606 	add.w	r6, r4, #8576	; 0x2180
   1bd3e:	f504 5394 	add.w	r3, r4, #4736	; 0x1280
   1bd42:	9201      	str	r2, [sp, #4]
   1bd44:	3630      	adds	r6, #48	; 0x30
   1bd46:	461a      	mov	r2, r3
   1bd48:	4650      	mov	r0, sl
   1bd4a:	f8cd c018 	str.w	ip, [sp, #24]
   1bd4e:	f8cd 9014 	str.w	r9, [sp, #20]
   1bd52:	f8cd 8010 	str.w	r8, [sp, #16]
   1bd56:	f8cd e008 	str.w	lr, [sp, #8]
   1bd5a:	9600      	str	r6, [sp, #0]
   1bd5c:	331c      	adds	r3, #28
   1bd5e:	321a      	adds	r2, #26
   1bd60:	f002 fec0 	bl	1eae4 <silk_pitch_analysis_core>
   1bd64:	2800      	cmp	r0, #0
   1bd66:	f040 80ac 	bne.w	1bec2 <silk_find_pitch_lags_FIX+0x422>
            psEnc->sCmn.indices.signalType = TYPE_VOICED;
   1bd6a:	2302      	movs	r3, #2
}
   1bd6c:	37dc      	adds	r7, #220	; 0xdc
            psEnc->sCmn.indices.signalType = TYPE_VOICED;
   1bd6e:	5563      	strb	r3, [r4, r5]
}
   1bd70:	46bd      	mov	sp, r7
   1bd72:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1bd76:	f647 73ff 	movw	r3, #32767	; 0x7fff
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1bd7a:	2902      	cmp	r1, #2
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1bd7c:	86fb      	strh	r3, [r7, #54]	; 0x36
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1bd7e:	f43f af5f 	beq.w	1bc40 <silk_find_pitch_lags_FIX+0x1a0>
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1bd82:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   1bd84:	131b      	asrs	r3, r3, #12
   1bd86:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1bd8a:	da16      	bge.n	1bdba <silk_find_pitch_lags_FIX+0x31a>
   1bd8c:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   1bd90:	f2c0 809d 	blt.w	1bece <silk_find_pitch_lags_FIX+0x42e>
   1bd94:	b21b      	sxth	r3, r3
   1bd96:	e012      	b.n	1bdbe <silk_find_pitch_lags_FIX+0x31e>
        return silk_LSHIFT_SAT32(result, -lshift);
   1bd98:	f1c5 0510 	rsb	r5, r5, #16
   1bd9c:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   1bda0:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
   1bda4:	412a      	asrs	r2, r5
   1bda6:	4129      	asrs	r1, r5
   1bda8:	428a      	cmp	r2, r1
   1bdaa:	f300 8086 	bgt.w	1beba <silk_find_pitch_lags_FIX+0x41a>
   1bdae:	428b      	cmp	r3, r1
   1bdb0:	f340 80a1 	ble.w	1bef6 <silk_find_pitch_lags_FIX+0x456>
   1bdb4:	460b      	mov	r3, r1
   1bdb6:	40ab      	lsls	r3, r5
   1bdb8:	e71b      	b.n	1bbf2 <silk_find_pitch_lags_FIX+0x152>
   1bdba:	f647 73ff 	movw	r3, #32767	; 0x7fff
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1bdbe:	2903      	cmp	r1, #3
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1bdc0:	873b      	strh	r3, [r7, #56]	; 0x38
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1bdc2:	f43f af3d 	beq.w	1bc40 <silk_find_pitch_lags_FIX+0x1a0>
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1bdc6:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   1bdc8:	131b      	asrs	r3, r3, #12
   1bdca:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1bdce:	da04      	bge.n	1bdda <silk_find_pitch_lags_FIX+0x33a>
   1bdd0:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   1bdd4:	db7d      	blt.n	1bed2 <silk_find_pitch_lags_FIX+0x432>
   1bdd6:	b21b      	sxth	r3, r3
   1bdd8:	e001      	b.n	1bdde <silk_find_pitch_lags_FIX+0x33e>
   1bdda:	f647 73ff 	movw	r3, #32767	; 0x7fff
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1bdde:	2904      	cmp	r1, #4
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1bde0:	877b      	strh	r3, [r7, #58]	; 0x3a
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1bde2:	f43f af2d 	beq.w	1bc40 <silk_find_pitch_lags_FIX+0x1a0>
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1bde6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   1bde8:	131b      	asrs	r3, r3, #12
   1bdea:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1bdee:	da04      	bge.n	1bdfa <silk_find_pitch_lags_FIX+0x35a>
   1bdf0:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   1bdf4:	db6f      	blt.n	1bed6 <silk_find_pitch_lags_FIX+0x436>
   1bdf6:	b21b      	sxth	r3, r3
   1bdf8:	e001      	b.n	1bdfe <silk_find_pitch_lags_FIX+0x35e>
   1bdfa:	f647 73ff 	movw	r3, #32767	; 0x7fff
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1bdfe:	2905      	cmp	r1, #5
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1be00:	87bb      	strh	r3, [r7, #60]	; 0x3c
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1be02:	f43f af1d 	beq.w	1bc40 <silk_find_pitch_lags_FIX+0x1a0>
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1be06:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   1be08:	131b      	asrs	r3, r3, #12
   1be0a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1be0e:	db4d      	blt.n	1beac <silk_find_pitch_lags_FIX+0x40c>
   1be10:	f647 73ff 	movw	r3, #32767	; 0x7fff
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1be14:	2906      	cmp	r1, #6
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1be16:	87fb      	strh	r3, [r7, #62]	; 0x3e
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1be18:	f43f af12 	beq.w	1bc40 <silk_find_pitch_lags_FIX+0x1a0>
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1be1c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
   1be1e:	131b      	asrs	r3, r3, #12
   1be20:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1be24:	da59      	bge.n	1beda <silk_find_pitch_lags_FIX+0x43a>
   1be26:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   1be2a:	db7e      	blt.n	1bf2a <silk_find_pitch_lags_FIX+0x48a>
   1be2c:	b21b      	sxth	r3, r3
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1be2e:	2907      	cmp	r1, #7
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1be30:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1be34:	f43f af04 	beq.w	1bc40 <silk_find_pitch_lags_FIX+0x1a0>
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1be38:	6f3b      	ldr	r3, [r7, #112]	; 0x70
   1be3a:	131b      	asrs	r3, r3, #12
   1be3c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1be40:	da4e      	bge.n	1bee0 <silk_find_pitch_lags_FIX+0x440>
   1be42:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   1be46:	f2c0 8084 	blt.w	1bf52 <silk_find_pitch_lags_FIX+0x4b2>
   1be4a:	b21b      	sxth	r3, r3
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1be4c:	2908      	cmp	r1, #8
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1be4e:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1be52:	f43f aef5 	beq.w	1bc40 <silk_find_pitch_lags_FIX+0x1a0>
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1be56:	6f7b      	ldr	r3, [r7, #116]	; 0x74
   1be58:	131b      	asrs	r3, r3, #12
   1be5a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1be5e:	da42      	bge.n	1bee6 <silk_find_pitch_lags_FIX+0x446>
   1be60:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   1be64:	f2c0 8089 	blt.w	1bf7a <silk_find_pitch_lags_FIX+0x4da>
   1be68:	b21b      	sxth	r3, r3
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1be6a:	2909      	cmp	r1, #9
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1be6c:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1be70:	f43f aee6 	beq.w	1bc40 <silk_find_pitch_lags_FIX+0x1a0>
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1be74:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   1be76:	131b      	asrs	r3, r3, #12
   1be78:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1be7c:	da36      	bge.n	1beec <silk_find_pitch_lags_FIX+0x44c>
   1be7e:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   1be82:	f2c0 809d 	blt.w	1bfc0 <silk_find_pitch_lags_FIX+0x520>
   1be86:	b21b      	sxth	r3, r3
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1be88:	290a      	cmp	r1, #10
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1be8a:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1be8e:	f43f aed7 	beq.w	1bc40 <silk_find_pitch_lags_FIX+0x1a0>
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1be92:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
   1be94:	131b      	asrs	r3, r3, #12
   1be96:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1be9a:	da34      	bge.n	1bf06 <silk_find_pitch_lags_FIX+0x466>
   1be9c:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   1bea0:	f2c0 8095 	blt.w	1bfce <silk_find_pitch_lags_FIX+0x52e>
   1bea4:	b21b      	sxth	r3, r3
   1bea6:	e030      	b.n	1bf0a <silk_find_pitch_lags_FIX+0x46a>
   1bea8:	4b50      	ldr	r3, [pc, #320]	; (1bfec <silk_find_pitch_lags_FIX+0x54c>)
   1beaa:	e6b7      	b.n	1bc1c <silk_find_pitch_lags_FIX+0x17c>
   1beac:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   1beb0:	db1f      	blt.n	1bef2 <silk_find_pitch_lags_FIX+0x452>
   1beb2:	b21b      	sxth	r3, r3
   1beb4:	e7ae      	b.n	1be14 <silk_find_pitch_lags_FIX+0x374>
   1beb6:	4b4d      	ldr	r3, [pc, #308]	; (1bfec <silk_find_pitch_lags_FIX+0x54c>)
   1beb8:	e75f      	b.n	1bd7a <silk_find_pitch_lags_FIX+0x2da>
   1beba:	4293      	cmp	r3, r2
   1bebc:	dd1f      	ble.n	1befe <silk_find_pitch_lags_FIX+0x45e>
   1bebe:	4613      	mov	r3, r2
   1bec0:	e779      	b.n	1bdb6 <silk_find_pitch_lags_FIX+0x316>
            psEnc->sCmn.indices.signalType = TYPE_UNVOICED;
   1bec2:	2301      	movs	r3, #1
}
   1bec4:	37dc      	adds	r7, #220	; 0xdc
            psEnc->sCmn.indices.signalType = TYPE_UNVOICED;
   1bec6:	5563      	strb	r3, [r4, r5]
}
   1bec8:	46bd      	mov	sp, r7
   1beca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1bece:	4b47      	ldr	r3, [pc, #284]	; (1bfec <silk_find_pitch_lags_FIX+0x54c>)
   1bed0:	e775      	b.n	1bdbe <silk_find_pitch_lags_FIX+0x31e>
   1bed2:	4b46      	ldr	r3, [pc, #280]	; (1bfec <silk_find_pitch_lags_FIX+0x54c>)
   1bed4:	e783      	b.n	1bdde <silk_find_pitch_lags_FIX+0x33e>
   1bed6:	4b45      	ldr	r3, [pc, #276]	; (1bfec <silk_find_pitch_lags_FIX+0x54c>)
   1bed8:	e791      	b.n	1bdfe <silk_find_pitch_lags_FIX+0x35e>
   1beda:	f647 73ff 	movw	r3, #32767	; 0x7fff
   1bede:	e7a6      	b.n	1be2e <silk_find_pitch_lags_FIX+0x38e>
   1bee0:	f647 73ff 	movw	r3, #32767	; 0x7fff
   1bee4:	e7b2      	b.n	1be4c <silk_find_pitch_lags_FIX+0x3ac>
   1bee6:	f647 73ff 	movw	r3, #32767	; 0x7fff
   1beea:	e7be      	b.n	1be6a <silk_find_pitch_lags_FIX+0x3ca>
   1beec:	f647 73ff 	movw	r3, #32767	; 0x7fff
   1bef0:	e7ca      	b.n	1be88 <silk_find_pitch_lags_FIX+0x3e8>
   1bef2:	4b3e      	ldr	r3, [pc, #248]	; (1bfec <silk_find_pitch_lags_FIX+0x54c>)
   1bef4:	e78e      	b.n	1be14 <silk_find_pitch_lags_FIX+0x374>
   1bef6:	4293      	cmp	r3, r2
   1bef8:	bfb8      	it	lt
   1befa:	4613      	movlt	r3, r2
   1befc:	e75b      	b.n	1bdb6 <silk_find_pitch_lags_FIX+0x316>
   1befe:	428b      	cmp	r3, r1
   1bf00:	bfb8      	it	lt
   1bf02:	460b      	movlt	r3, r1
   1bf04:	e757      	b.n	1bdb6 <silk_find_pitch_lags_FIX+0x316>
   1bf06:	f647 73ff 	movw	r3, #32767	; 0x7fff
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1bf0a:	290b      	cmp	r1, #11
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1bf0c:	f8a7 3048 	strh.w	r3, [r7, #72]	; 0x48
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1bf10:	f43f ae96 	beq.w	1bc40 <silk_find_pitch_lags_FIX+0x1a0>
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1bf14:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   1bf18:	131b      	asrs	r3, r3, #12
   1bf1a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1bf1e:	da06      	bge.n	1bf2e <silk_find_pitch_lags_FIX+0x48e>
   1bf20:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   1bf24:	db55      	blt.n	1bfd2 <silk_find_pitch_lags_FIX+0x532>
   1bf26:	b21b      	sxth	r3, r3
   1bf28:	e003      	b.n	1bf32 <silk_find_pitch_lags_FIX+0x492>
   1bf2a:	4b30      	ldr	r3, [pc, #192]	; (1bfec <silk_find_pitch_lags_FIX+0x54c>)
   1bf2c:	e77f      	b.n	1be2e <silk_find_pitch_lags_FIX+0x38e>
   1bf2e:	f647 73ff 	movw	r3, #32767	; 0x7fff
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1bf32:	290c      	cmp	r1, #12
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1bf34:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1bf38:	f43f ae82 	beq.w	1bc40 <silk_find_pitch_lags_FIX+0x1a0>
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1bf3c:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
   1bf40:	131b      	asrs	r3, r3, #12
   1bf42:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1bf46:	da06      	bge.n	1bf56 <silk_find_pitch_lags_FIX+0x4b6>
   1bf48:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   1bf4c:	db43      	blt.n	1bfd6 <silk_find_pitch_lags_FIX+0x536>
   1bf4e:	b21b      	sxth	r3, r3
   1bf50:	e003      	b.n	1bf5a <silk_find_pitch_lags_FIX+0x4ba>
   1bf52:	4b26      	ldr	r3, [pc, #152]	; (1bfec <silk_find_pitch_lags_FIX+0x54c>)
   1bf54:	e77a      	b.n	1be4c <silk_find_pitch_lags_FIX+0x3ac>
   1bf56:	f647 73ff 	movw	r3, #32767	; 0x7fff
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1bf5a:	290d      	cmp	r1, #13
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1bf5c:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1bf60:	f43f ae6e 	beq.w	1bc40 <silk_find_pitch_lags_FIX+0x1a0>
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1bf64:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
   1bf68:	131b      	asrs	r3, r3, #12
   1bf6a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1bf6e:	da06      	bge.n	1bf7e <silk_find_pitch_lags_FIX+0x4de>
   1bf70:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   1bf74:	db31      	blt.n	1bfda <silk_find_pitch_lags_FIX+0x53a>
   1bf76:	b21b      	sxth	r3, r3
   1bf78:	e003      	b.n	1bf82 <silk_find_pitch_lags_FIX+0x4e2>
   1bf7a:	4b1c      	ldr	r3, [pc, #112]	; (1bfec <silk_find_pitch_lags_FIX+0x54c>)
   1bf7c:	e775      	b.n	1be6a <silk_find_pitch_lags_FIX+0x3ca>
   1bf7e:	f647 73ff 	movw	r3, #32767	; 0x7fff
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1bf82:	290e      	cmp	r1, #14
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1bf84:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1bf88:	f43f ae5a 	beq.w	1bc40 <silk_find_pitch_lags_FIX+0x1a0>
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1bf8c:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
   1bf90:	131b      	asrs	r3, r3, #12
   1bf92:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1bf96:	db15      	blt.n	1bfc4 <silk_find_pitch_lags_FIX+0x524>
   1bf98:	f647 73ff 	movw	r3, #32767	; 0x7fff
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1bf9c:	290f      	cmp	r1, #15
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1bf9e:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
    for( i = 0; i < psEnc->sCmn.pitchEstimationLPCOrder; i++ ) {
   1bfa2:	f43f ae4d 	beq.w	1bc40 <silk_find_pitch_lags_FIX+0x1a0>
        A_Q12[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT( A_Q24[ i ], 12 ) );
   1bfa6:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
   1bfaa:	131b      	asrs	r3, r3, #12
   1bfac:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1bfb0:	da15      	bge.n	1bfde <silk_find_pitch_lags_FIX+0x53e>
   1bfb2:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   1bfb6:	db17      	blt.n	1bfe8 <silk_find_pitch_lags_FIX+0x548>
   1bfb8:	b21b      	sxth	r3, r3
   1bfba:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
   1bfbe:	e63f      	b.n	1bc40 <silk_find_pitch_lags_FIX+0x1a0>
   1bfc0:	4b0a      	ldr	r3, [pc, #40]	; (1bfec <silk_find_pitch_lags_FIX+0x54c>)
   1bfc2:	e761      	b.n	1be88 <silk_find_pitch_lags_FIX+0x3e8>
   1bfc4:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   1bfc8:	db0c      	blt.n	1bfe4 <silk_find_pitch_lags_FIX+0x544>
   1bfca:	b21b      	sxth	r3, r3
   1bfcc:	e7e6      	b.n	1bf9c <silk_find_pitch_lags_FIX+0x4fc>
   1bfce:	4b07      	ldr	r3, [pc, #28]	; (1bfec <silk_find_pitch_lags_FIX+0x54c>)
   1bfd0:	e79b      	b.n	1bf0a <silk_find_pitch_lags_FIX+0x46a>
   1bfd2:	4b06      	ldr	r3, [pc, #24]	; (1bfec <silk_find_pitch_lags_FIX+0x54c>)
   1bfd4:	e7ad      	b.n	1bf32 <silk_find_pitch_lags_FIX+0x492>
   1bfd6:	4b05      	ldr	r3, [pc, #20]	; (1bfec <silk_find_pitch_lags_FIX+0x54c>)
   1bfd8:	e7bf      	b.n	1bf5a <silk_find_pitch_lags_FIX+0x4ba>
   1bfda:	4b04      	ldr	r3, [pc, #16]	; (1bfec <silk_find_pitch_lags_FIX+0x54c>)
   1bfdc:	e7d1      	b.n	1bf82 <silk_find_pitch_lags_FIX+0x4e2>
   1bfde:	f647 73ff 	movw	r3, #32767	; 0x7fff
   1bfe2:	e7ea      	b.n	1bfba <silk_find_pitch_lags_FIX+0x51a>
   1bfe4:	4b01      	ldr	r3, [pc, #4]	; (1bfec <silk_find_pitch_lags_FIX+0x54c>)
   1bfe6:	e7d9      	b.n	1bf9c <silk_find_pitch_lags_FIX+0x4fc>
   1bfe8:	4b00      	ldr	r3, [pc, #0]	; (1bfec <silk_find_pitch_lags_FIX+0x54c>)
   1bfea:	e7e6      	b.n	1bfba <silk_find_pitch_lags_FIX+0x51a>
   1bfec:	ffff8000 	.word	0xffff8000
   1bff0:	fffffb34 	.word	0xfffffb34

0001bff4 <silk_find_pred_coefs_FIX>:
    silk_encoder_control_FIX        *psEncCtrl,                             /* I/O  encoder control                                                             */
    const opus_int16                res_pitch[],                            /* I    Residual from pitch analysis                                                */
    const opus_int16                x[],                                    /* I    Speech signal                                                               */
    opus_int                        condCoding                              /* I    The type of conditional coding to use                                       */
)
{
   1bff4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1bff8:	4604      	mov	r4, r0
   1bffa:	b09d      	sub	sp, #116	; 0x74
    opus_int32       min_gain_Q16, minInvGain_Q30;
    SAVE_STACK;

    /* weighting for weighted least squares */
    min_gain_Q16 = silk_int32_MAX >> 6;
    for( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1bffc:	f241 10e4 	movw	r0, #4580	; 0x11e4
{
   1c000:	4688      	mov	r8, r1
    for( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1c002:	5821      	ldr	r1, [r4, r0]
{
   1c004:	af06      	add	r7, sp, #24
    for( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1c006:	2900      	cmp	r1, #0
{
   1c008:	60fb      	str	r3, [r7, #12]
    for( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1c00a:	f340 8154 	ble.w	1c2b6 <silk_find_pred_coefs_FIX+0x2c2>
        min_gain_Q16 = silk_min( min_gain_Q16, psEncCtrl->Gains_Q16[ i ] );
   1c00e:	f8d8 3000 	ldr.w	r3, [r8]
   1c012:	f06f 407e 	mvn.w	r0, #4261412864	; 0xfe000000
   1c016:	4298      	cmp	r0, r3
   1c018:	bfa8      	it	ge
   1c01a:	4618      	movge	r0, r3
    for( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1c01c:	2901      	cmp	r1, #1
   1c01e:	d012      	beq.n	1c046 <silk_find_pred_coefs_FIX+0x52>
        min_gain_Q16 = silk_min( min_gain_Q16, psEncCtrl->Gains_Q16[ i ] );
   1c020:	f8d8 5004 	ldr.w	r5, [r8, #4]
   1c024:	42a8      	cmp	r0, r5
   1c026:	bfa8      	it	ge
   1c028:	4628      	movge	r0, r5
    for( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1c02a:	2902      	cmp	r1, #2
   1c02c:	d00b      	beq.n	1c046 <silk_find_pred_coefs_FIX+0x52>
        min_gain_Q16 = silk_min( min_gain_Q16, psEncCtrl->Gains_Q16[ i ] );
   1c02e:	f8d8 5008 	ldr.w	r5, [r8, #8]
   1c032:	42a8      	cmp	r0, r5
   1c034:	bfa8      	it	ge
   1c036:	4628      	movge	r0, r5
    for( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1c038:	2903      	cmp	r1, #3
   1c03a:	d004      	beq.n	1c046 <silk_find_pred_coefs_FIX+0x52>
        min_gain_Q16 = silk_min( min_gain_Q16, psEncCtrl->Gains_Q16[ i ] );
   1c03c:	f8d8 500c 	ldr.w	r5, [r8, #12]
   1c040:	42a8      	cmp	r0, r5
   1c042:	bfa8      	it	ge
   1c044:	4628      	movge	r0, r5
   1c046:	ea80 75e0 	eor.w	r5, r0, r0, asr #31
   1c04a:	eba5 75e0 	sub.w	r5, r5, r0, asr #31
   1c04e:	2800      	cmp	r0, #0
   1c050:	f040 81ce 	bne.w	1c3f0 <silk_find_pred_coefs_FIX+0x3fc>
   1c054:	261f      	movs	r6, #31
   1c056:	f04f 0e3c 	mov.w	lr, #60	; 0x3c
    a32_nrm = silk_LSHIFT(a32, a_headrm);                                       /* Q: a_headrm                  */
   1c05a:	fa00 f606 	lsl.w	r6, r0, r6
   1c05e:	2b00      	cmp	r3, #0
   1c060:	f000 81d1 	beq.w	1c406 <silk_find_pred_coefs_FIX+0x412>
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
   1c064:	ea83 7ce3 	eor.w	ip, r3, r3, asr #31
   1c068:	ebac 7ce3 	sub.w	ip, ip, r3, asr #31
   1c06c:	fabc fc8c 	clz	ip, ip
   1c070:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                  */
   1c074:	fa03 fa0c 	lsl.w	sl, r3, ip
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1c078:	ea4f 492a 	mov.w	r9, sl, asr #16
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1c07c:	fa1f fb86 	uxth.w	fp, r6
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1c080:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
   1c084:	fb93 f3f9 	sdiv	r3, r3, r9
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1c088:	ea4f 4926 	mov.w	r9, r6, asr #16
   1c08c:	b21b      	sxth	r3, r3
   1c08e:	fb03 fb0b 	mul.w	fp, r3, fp
   1c092:	fb03 f909 	mul.w	r9, r3, r9
   1c096:	eb09 492b 	add.w	r9, r9, fp, asr #16
    a32_nrm = silk_SUB32_ovflw(a32_nrm, silk_LSHIFT_ovflw( silk_SMMUL(b32_nrm, result), 3 ));  /* Q: a_headrm   */
   1c09a:	fb89 ab0a 	smull	sl, fp, r9, sl
   1c09e:	eba6 06cb 	sub.w	r6, r6, fp, lsl #3
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1c0a2:	fa1f fa86 	uxth.w	sl, r6
   1c0a6:	1436      	asrs	r6, r6, #16
   1c0a8:	fb03 fa0a 	mul.w	sl, r3, sl
   1c0ac:	fb03 f306 	mul.w	r3, r3, r6
    lshift = 29 + a_headrm - b_headrm - Qres;
   1c0b0:	ebae 0c0c 	sub.w	ip, lr, ip
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1c0b4:	eb03 432a 	add.w	r3, r3, sl, asr #16
   1c0b8:	444b      	add	r3, r9
    if( lshift < 0 ) {
   1c0ba:	f1bc 090e 	subs.w	r9, ip, #14
   1c0be:	f100 8205 	bmi.w	1c4cc <silk_find_pred_coefs_FIX+0x4d8>
        if( lshift < 32){
   1c0c2:	f1b9 0f1f 	cmp.w	r9, #31
   1c0c6:	f300 8225 	bgt.w	1c514 <silk_find_pred_coefs_FIX+0x520>
            return silk_RSHIFT(result, lshift);
   1c0ca:	fa43 f309 	asr.w	r3, r3, r9
   1c0ce:	2b64      	cmp	r3, #100	; 0x64
   1c0d0:	bfb8      	it	lt
   1c0d2:	2364      	movlt	r3, #100	; 0x64
   1c0d4:	f44f 3680 	mov.w	r6, #65536	; 0x10000
   1c0d8:	fb96 f6f3 	sdiv	r6, r6, r3
    }
    for( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1c0dc:	2901      	cmp	r1, #1
        silk_assert( psEncCtrl->Gains_Q16[ i ] > 0 );
        /* Invert and normalize gains, and ensure that maximum invGains_Q16 is within range of a 16 bit int */
        invGains_Q16[ i ] = silk_DIV32_varQ( min_gain_Q16, psEncCtrl->Gains_Q16[ i ], 16 - 2 );

        /* Limit inverse */
        invGains_Q16[ i ] = silk_max( invGains_Q16[ i ], 100 );
   1c0de:	61bb      	str	r3, [r7, #24]

        /* Square the inverted gains */
        silk_assert( invGains_Q16[ i ] == silk_SAT16( invGains_Q16[ i ] ) );

        /* Invert the inverted and normalized gains */
        local_gains[ i ] = silk_DIV32( ( (opus_int32)1 << 16 ), invGains_Q16[ i ] );
   1c0e0:	62be      	str	r6, [r7, #40]	; 0x28
    for( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1c0e2:	f000 80e8 	beq.w	1c2b6 <silk_find_pred_coefs_FIX+0x2c2>
        invGains_Q16[ i ] = silk_DIV32_varQ( min_gain_Q16, psEncCtrl->Gains_Q16[ i ], 16 - 2 );
   1c0e6:	f8d8 3004 	ldr.w	r3, [r8, #4]
   1c0ea:	2800      	cmp	r0, #0
   1c0ec:	f000 81ea 	beq.w	1c4c4 <silk_find_pred_coefs_FIX+0x4d0>
   1c0f0:	fab5 f985 	clz	r9, r5
   1c0f4:	f109 36ff 	add.w	r6, r9, #4294967295	; 0xffffffff
   1c0f8:	f109 091c 	add.w	r9, r9, #28
    a32_nrm = silk_LSHIFT(a32, a_headrm);                                       /* Q: a_headrm                  */
   1c0fc:	fa00 f606 	lsl.w	r6, r0, r6
   1c100:	2b00      	cmp	r3, #0
   1c102:	f000 81dc 	beq.w	1c4be <silk_find_pred_coefs_FIX+0x4ca>
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
   1c106:	ea83 7ce3 	eor.w	ip, r3, r3, asr #31
   1c10a:	ebac 7ce3 	sub.w	ip, ip, r3, asr #31
   1c10e:	fabc fc8c 	clz	ip, ip
   1c112:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                  */
   1c116:	fa03 fa0c 	lsl.w	sl, r3, ip
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1c11a:	ea4f 4e2a 	mov.w	lr, sl, asr #16
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1c11e:	fa1f fb86 	uxth.w	fp, r6
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1c122:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
   1c126:	fb93 f3fe 	sdiv	r3, r3, lr
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1c12a:	ea4f 4e26 	mov.w	lr, r6, asr #16
   1c12e:	b21b      	sxth	r3, r3
   1c130:	fb03 fb0b 	mul.w	fp, r3, fp
   1c134:	fb03 fe0e 	mul.w	lr, r3, lr
   1c138:	eb0e 4e2b 	add.w	lr, lr, fp, asr #16
    a32_nrm = silk_SUB32_ovflw(a32_nrm, silk_LSHIFT_ovflw( silk_SMMUL(b32_nrm, result), 3 ));  /* Q: a_headrm   */
   1c13c:	fb8e ab0a 	smull	sl, fp, lr, sl
   1c140:	eba6 06cb 	sub.w	r6, r6, fp, lsl #3
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1c144:	fa1f fa86 	uxth.w	sl, r6
   1c148:	1436      	asrs	r6, r6, #16
   1c14a:	fb03 fa0a 	mul.w	sl, r3, sl
   1c14e:	fb03 f306 	mul.w	r3, r3, r6
    lshift = 29 + a_headrm - b_headrm - Qres;
   1c152:	eba9 0c0c 	sub.w	ip, r9, ip
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1c156:	eb03 432a 	add.w	r3, r3, sl, asr #16
   1c15a:	4473      	add	r3, lr
    if( lshift < 0 ) {
   1c15c:	f1bc 0e0e 	subs.w	lr, ip, #14
   1c160:	f100 81dc 	bmi.w	1c51c <silk_find_pred_coefs_FIX+0x528>
        if( lshift < 32){
   1c164:	f1be 0f1f 	cmp.w	lr, #31
   1c168:	f300 8277 	bgt.w	1c65a <silk_find_pred_coefs_FIX+0x666>
            return silk_RSHIFT(result, lshift);
   1c16c:	fa43 f30e 	asr.w	r3, r3, lr
   1c170:	2b64      	cmp	r3, #100	; 0x64
   1c172:	bfb8      	it	lt
   1c174:	2364      	movlt	r3, #100	; 0x64
   1c176:	f44f 3680 	mov.w	r6, #65536	; 0x10000
   1c17a:	fb96 f6f3 	sdiv	r6, r6, r3
    for( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1c17e:	2902      	cmp	r1, #2
        invGains_Q16[ i ] = silk_max( invGains_Q16[ i ], 100 );
   1c180:	61fb      	str	r3, [r7, #28]
        local_gains[ i ] = silk_DIV32( ( (opus_int32)1 << 16 ), invGains_Q16[ i ] );
   1c182:	62fe      	str	r6, [r7, #44]	; 0x2c
    for( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1c184:	f000 8097 	beq.w	1c2b6 <silk_find_pred_coefs_FIX+0x2c2>
        invGains_Q16[ i ] = silk_DIV32_varQ( min_gain_Q16, psEncCtrl->Gains_Q16[ i ], 16 - 2 );
   1c188:	f8d8 3008 	ldr.w	r3, [r8, #8]
   1c18c:	2800      	cmp	r0, #0
   1c18e:	f000 81bd 	beq.w	1c50c <silk_find_pred_coefs_FIX+0x518>
   1c192:	fab5 f985 	clz	r9, r5
   1c196:	f109 36ff 	add.w	r6, r9, #4294967295	; 0xffffffff
   1c19a:	f109 091c 	add.w	r9, r9, #28
    a32_nrm = silk_LSHIFT(a32, a_headrm);                                       /* Q: a_headrm                  */
   1c19e:	fa00 f606 	lsl.w	r6, r0, r6
   1c1a2:	2b00      	cmp	r3, #0
   1c1a4:	f000 81af 	beq.w	1c506 <silk_find_pred_coefs_FIX+0x512>
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
   1c1a8:	ea83 7ce3 	eor.w	ip, r3, r3, asr #31
   1c1ac:	ebac 7ce3 	sub.w	ip, ip, r3, asr #31
   1c1b0:	fabc fc8c 	clz	ip, ip
   1c1b4:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                  */
   1c1b8:	fa03 fa0c 	lsl.w	sl, r3, ip
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1c1bc:	ea4f 4e2a 	mov.w	lr, sl, asr #16
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1c1c0:	fa1f fb86 	uxth.w	fp, r6
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1c1c4:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
   1c1c8:	fb93 f3fe 	sdiv	r3, r3, lr
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1c1cc:	ea4f 4e26 	mov.w	lr, r6, asr #16
   1c1d0:	b21b      	sxth	r3, r3
   1c1d2:	fb03 fb0b 	mul.w	fp, r3, fp
   1c1d6:	fb03 fe0e 	mul.w	lr, r3, lr
   1c1da:	eb0e 4e2b 	add.w	lr, lr, fp, asr #16
    a32_nrm = silk_SUB32_ovflw(a32_nrm, silk_LSHIFT_ovflw( silk_SMMUL(b32_nrm, result), 3 ));  /* Q: a_headrm   */
   1c1de:	fb8e ab0a 	smull	sl, fp, lr, sl
   1c1e2:	eba6 06cb 	sub.w	r6, r6, fp, lsl #3
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1c1e6:	fa1f fa86 	uxth.w	sl, r6
   1c1ea:	1436      	asrs	r6, r6, #16
   1c1ec:	fb03 fa0a 	mul.w	sl, r3, sl
   1c1f0:	fb03 f306 	mul.w	r3, r3, r6
    lshift = 29 + a_headrm - b_headrm - Qres;
   1c1f4:	eba9 0c0c 	sub.w	ip, r9, ip
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1c1f8:	eb03 432a 	add.w	r3, r3, sl, asr #16
   1c1fc:	4473      	add	r3, lr
    if( lshift < 0 ) {
   1c1fe:	f1bc 0e0e 	subs.w	lr, ip, #14
   1c202:	f100 822e 	bmi.w	1c662 <silk_find_pred_coefs_FIX+0x66e>
        if( lshift < 32){
   1c206:	f1be 0f1f 	cmp.w	lr, #31
   1c20a:	f300 8210 	bgt.w	1c62e <silk_find_pred_coefs_FIX+0x63a>
            return silk_RSHIFT(result, lshift);
   1c20e:	fa43 f30e 	asr.w	r3, r3, lr
   1c212:	2b64      	cmp	r3, #100	; 0x64
   1c214:	bfb8      	it	lt
   1c216:	2364      	movlt	r3, #100	; 0x64
   1c218:	f44f 3680 	mov.w	r6, #65536	; 0x10000
   1c21c:	fb96 f6f3 	sdiv	r6, r6, r3
    for( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1c220:	2903      	cmp	r1, #3
        invGains_Q16[ i ] = silk_max( invGains_Q16[ i ], 100 );
   1c222:	623b      	str	r3, [r7, #32]
        local_gains[ i ] = silk_DIV32( ( (opus_int32)1 << 16 ), invGains_Q16[ i ] );
   1c224:	633e      	str	r6, [r7, #48]	; 0x30
    for( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1c226:	d046      	beq.n	1c2b6 <silk_find_pred_coefs_FIX+0x2c2>
        invGains_Q16[ i ] = silk_DIV32_varQ( min_gain_Q16, psEncCtrl->Gains_Q16[ i ], 16 - 2 );
   1c228:	f8d8 600c 	ldr.w	r6, [r8, #12]
   1c22c:	2800      	cmp	r0, #0
   1c22e:	f000 8211 	beq.w	1c654 <silk_find_pred_coefs_FIX+0x660>
   1c232:	fab5 f585 	clz	r5, r5
   1c236:	1e6b      	subs	r3, r5, #1
   1c238:	351c      	adds	r5, #28
    a32_nrm = silk_LSHIFT(a32, a_headrm);                                       /* Q: a_headrm                  */
   1c23a:	4098      	lsls	r0, r3
   1c23c:	2e00      	cmp	r6, #0
   1c23e:	f000 8206 	beq.w	1c64e <silk_find_pred_coefs_FIX+0x65a>
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
   1c242:	ea86 7ce6 	eor.w	ip, r6, r6, asr #31
   1c246:	ebac 7ce6 	sub.w	ip, ip, r6, asr #31
   1c24a:	fabc fc8c 	clz	ip, ip
   1c24e:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                  */
   1c252:	fa06 fa0c 	lsl.w	sl, r6, ip
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1c256:	ea4f 4e2a 	mov.w	lr, sl, asr #16
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1c25a:	b286      	uxth	r6, r0
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1c25c:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
   1c260:	fb93 f3fe 	sdiv	r3, r3, lr
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1c264:	fa0f fe83 	sxth.w	lr, r3
   1c268:	1403      	asrs	r3, r0, #16
   1c26a:	fb0e f303 	mul.w	r3, lr, r3
   1c26e:	fb0e f606 	mul.w	r6, lr, r6
   1c272:	eb03 4626 	add.w	r6, r3, r6, asr #16
    a32_nrm = silk_SUB32_ovflw(a32_nrm, silk_LSHIFT_ovflw( silk_SMMUL(b32_nrm, result), 3 ));  /* Q: a_headrm   */
   1c276:	fb8a ab06 	smull	sl, fp, sl, r6
   1c27a:	eba0 00cb 	sub.w	r0, r0, fp, lsl #3
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1c27e:	b283      	uxth	r3, r0
   1c280:	1400      	asrs	r0, r0, #16
   1c282:	fb0e f903 	mul.w	r9, lr, r3
    lshift = 29 + a_headrm - b_headrm - Qres;
   1c286:	eba5 050c 	sub.w	r5, r5, ip
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1c28a:	fb0e f300 	mul.w	r3, lr, r0
   1c28e:	eb03 4329 	add.w	r3, r3, r9, asr #16
    if( lshift < 0 ) {
   1c292:	f1b5 000e 	subs.w	r0, r5, #14
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1c296:	4433      	add	r3, r6
    if( lshift < 0 ) {
   1c298:	f100 81f3 	bmi.w	1c682 <silk_find_pred_coefs_FIX+0x68e>
        if( lshift < 32){
   1c29c:	281f      	cmp	r0, #31
   1c29e:	f300 821c 	bgt.w	1c6da <silk_find_pred_coefs_FIX+0x6e6>
            return silk_RSHIFT(result, lshift);
   1c2a2:	4103      	asrs	r3, r0
   1c2a4:	2b64      	cmp	r3, #100	; 0x64
   1c2a6:	bfb8      	it	lt
   1c2a8:	2364      	movlt	r3, #100	; 0x64
   1c2aa:	f44f 3080 	mov.w	r0, #65536	; 0x10000
   1c2ae:	fb90 f0f3 	sdiv	r0, r0, r3
        invGains_Q16[ i ] = silk_max( invGains_Q16[ i ], 100 );
   1c2b2:	627b      	str	r3, [r7, #36]	; 0x24
        local_gains[ i ] = silk_DIV32( ( (opus_int32)1 << 16 ), invGains_Q16[ i ] );
   1c2b4:	6378      	str	r0, [r7, #52]	; 0x34
    }

    ALLOC( LPC_in_pre,
   1c2b6:	f241 13e8 	movw	r3, #4584	; 0x11e8
   1c2ba:	f504 5b91 	add.w	fp, r4, #4640	; 0x1220
   1c2be:	58e0      	ldr	r0, [r4, r3]
   1c2c0:	f8db 5000 	ldr.w	r5, [fp]
   1c2c4:	fb01 0005 	mla	r0, r1, r5, r0
   1c2c8:	0040      	lsls	r0, r0, #1
           psEnc->sCmn.nb_subfr * psEnc->sCmn.predictLPCOrder
               + psEnc->sCmn.frame_length, opus_int16 );
    if( psEnc->sCmn.indices.signalType == TYPE_VOICED ) {
   1c2ca:	f241 239d 	movw	r3, #4765	; 0x129d
    ALLOC( LPC_in_pre,
   1c2ce:	3008      	adds	r0, #8
   1c2d0:	f020 0007 	bic.w	r0, r0, #7
    if( psEnc->sCmn.indices.signalType == TYPE_VOICED ) {
   1c2d4:	56e3      	ldrsb	r3, [r4, r3]
    ALLOC( LPC_in_pre,
   1c2d6:	ebad 0d00 	sub.w	sp, sp, r0
   1c2da:	a806      	add	r0, sp, #24
   1c2dc:	6178      	str	r0, [r7, #20]
    if( psEnc->sCmn.indices.signalType == TYPE_VOICED ) {
   1c2de:	2b02      	cmp	r3, #2
   1c2e0:	f108 0050 	add.w	r0, r8, #80	; 0x50
   1c2e4:	6138      	str	r0, [r7, #16]
   1c2e6:	f000 8136 	beq.w	1c556 <silk_find_pred_coefs_FIX+0x562>
    } else {
        /************/
        /* UNVOICED */
        /************/
        /* Create signal with prepended subframes, scaled by inverse gains */
        x_ptr     = x - psEnc->sCmn.predictLPCOrder;
   1c2ea:	68fb      	ldr	r3, [r7, #12]
        x_pre_ptr = LPC_in_pre;
        for( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1c2ec:	2900      	cmp	r1, #0
        x_ptr     = x - psEnc->sCmn.predictLPCOrder;
   1c2ee:	eba3 0645 	sub.w	r6, r3, r5, lsl #1
        for( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1c2f2:	dd25      	ble.n	1c340 <silk_find_pred_coefs_FIX+0x34c>
   1c2f4:	f241 13ec 	movw	r3, #4588	; 0x11ec
   1c2f8:	f504 528f 	add.w	r2, r4, #4576	; 0x11e0
   1c2fc:	58e3      	ldr	r3, [r4, r3]
        x_pre_ptr = LPC_in_pre;
   1c2fe:	f8d7 9014 	ldr.w	r9, [r7, #20]
   1c302:	60fc      	str	r4, [r7, #12]
   1c304:	4692      	mov	sl, r2
   1c306:	320c      	adds	r2, #12
   1c308:	442b      	add	r3, r5
   1c30a:	f10a 0a04 	add.w	sl, sl, #4
        for( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1c30e:	2500      	movs	r5, #0
   1c310:	4614      	mov	r4, r2
            silk_scale_copy_vector16( x_pre_ptr, x_ptr, invGains_Q16[ i ],
   1c312:	f107 0218 	add.w	r2, r7, #24
   1c316:	4631      	mov	r1, r6
   1c318:	f852 2025 	ldr.w	r2, [r2, r5, lsl #2]
   1c31c:	4648      	mov	r0, r9
   1c31e:	f003 fcff 	bl	1fd20 <silk_scale_copy_vector16>
                psEnc->sCmn.subfr_length + psEnc->sCmn.predictLPCOrder );
            x_pre_ptr += psEnc->sCmn.subfr_length + psEnc->sCmn.predictLPCOrder;
   1c322:	6822      	ldr	r2, [r4, #0]
   1c324:	f8db 3000 	ldr.w	r3, [fp]
        for( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1c328:	f8da 1000 	ldr.w	r1, [sl]
   1c32c:	3501      	adds	r5, #1
            x_pre_ptr += psEnc->sCmn.subfr_length + psEnc->sCmn.predictLPCOrder;
   1c32e:	4413      	add	r3, r2
        for( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1c330:	42a9      	cmp	r1, r5
            x_ptr     += psEnc->sCmn.subfr_length;
   1c332:	eb06 0642 	add.w	r6, r6, r2, lsl #1
            x_pre_ptr += psEnc->sCmn.subfr_length + psEnc->sCmn.predictLPCOrder;
   1c336:	eb09 0943 	add.w	r9, r9, r3, lsl #1
        for( i = 0; i < psEnc->sCmn.nb_subfr; i++ ) {
   1c33a:	dcea      	bgt.n	1c312 <silk_find_pred_coefs_FIX+0x31e>
   1c33c:	e9d7 4003 	ldrd	r4, r0, [r7, #12]
        }

        silk_memset( psEncCtrl->LTPCoef_Q14, 0, psEnc->sCmn.nb_subfr * LTP_ORDER * sizeof( opus_int16 ) );
   1c340:	eb01 0181 	add.w	r1, r1, r1, lsl #2
   1c344:	004a      	lsls	r2, r1, #1
   1c346:	2100      	movs	r1, #0
   1c348:	f018 ff0c 	bl	35164 <memset>
        psEncCtrl->LTPredCodGain_Q7 = 0;
        psEnc->sCmn.sum_log_gain_Q7 = 0;
   1c34c:	f241 2230 	movw	r2, #4656	; 0x1230
        psEncCtrl->LTPredCodGain_Q7 = 0;
   1c350:	2300      	movs	r3, #0
   1c352:	f8c8 318c 	str.w	r3, [r8, #396]	; 0x18c
        psEnc->sCmn.sum_log_gain_Q7 = 0;
   1c356:	50a3      	str	r3, [r4, r2]
    }

    /* Limit on total predictive coding gain */
    if( psEnc->sCmn.first_frame_after_reset ) {
   1c358:	f241 2338 	movw	r3, #4664	; 0x1238
   1c35c:	58e3      	ldr	r3, [r4, r3]
   1c35e:	2b00      	cmp	r3, #0
   1c360:	d054      	beq.n	1c40c <silk_find_pred_coefs_FIX+0x418>
        minInvGain_Q30 = SILK_FIX_CONST( 1.0f / MAX_PREDICTION_POWER_GAIN_AFTER_RESET, 30 );
   1c362:	4bd4      	ldr	r3, [pc, #848]	; (1c6b4 <silk_find_pred_coefs_FIX+0x6c0>)
            silk_SMULWW( SILK_FIX_CONST( MAX_PREDICTION_POWER_GAIN, 0 ),
                silk_SMLAWB( SILK_FIX_CONST( 0.25, 18 ), SILK_FIX_CONST( 0.75, 18 ), psEncCtrl->coding_quality_Q14 ) ), 14 );
    }

    /* LPC_in_pre contains the LTP-filtered input for voiced, and the unfiltered input for unvoiced */
    silk_find_LPC_FIX( &psEnc->sCmn, NLSF_Q15, LPC_in_pre, minInvGain_Q30 );
   1c364:	f8d7 a014 	ldr.w	sl, [r7, #20]

    /* Quantize LSFs */
    silk_process_NLSFs( &psEnc->sCmn, psEncCtrl->PredCoef_Q12, NLSF_Q15, psEnc->sCmn.prev_NLSFq_Q15 );
   1c368:	f241 1694 	movw	r6, #4500	; 0x1194
   1c36c:	eb04 0906 	add.w	r9, r4, r6
   1c370:	f108 0510 	add.w	r5, r8, #16
    silk_find_LPC_FIX( &psEnc->sCmn, NLSF_Q15, LPC_in_pre, minInvGain_Q30 );
   1c374:	f107 0138 	add.w	r1, r7, #56	; 0x38
   1c378:	4652      	mov	r2, sl
   1c37a:	4620      	mov	r0, r4
   1c37c:	f7ff f9cc 	bl	1b718 <silk_find_LPC_FIX>
    silk_process_NLSFs( &psEnc->sCmn, psEncCtrl->PredCoef_Q12, NLSF_Q15, psEnc->sCmn.prev_NLSFq_Q15 );
   1c380:	464b      	mov	r3, r9
   1c382:	f107 0238 	add.w	r2, r7, #56	; 0x38
   1c386:	4629      	mov	r1, r5
   1c388:	4620      	mov	r0, r4
   1c38a:	f7f8 fefd 	bl	15188 <silk_process_NLSFs>

    /* Calculate residual energy using quantized LPC coefficients */
    silk_residual_energy_FIX( psEncCtrl->ResNrg, psEncCtrl->ResNrgQ, LPC_in_pre, psEncCtrl->PredCoef_Q12, local_gains,
   1c38e:	f241 32e4 	movw	r2, #5092	; 0x13e4
   1c392:	f241 13e4 	movw	r3, #4580	; 0x11e4
   1c396:	58a2      	ldr	r2, [r4, r2]
   1c398:	9204      	str	r2, [sp, #16]
   1c39a:	f8db 2000 	ldr.w	r2, [fp]
   1c39e:	9203      	str	r2, [sp, #12]
   1c3a0:	58e3      	ldr	r3, [r4, r3]
   1c3a2:	9302      	str	r3, [sp, #8]
   1c3a4:	f241 13ec 	movw	r3, #4588	; 0x11ec
   1c3a8:	f107 0128 	add.w	r1, r7, #40	; 0x28
   1c3ac:	58e3      	ldr	r3, [r4, r3]
   1c3ae:	9301      	str	r3, [sp, #4]
   1c3b0:	4652      	mov	r2, sl
   1c3b2:	462b      	mov	r3, r5
   1c3b4:	9100      	str	r1, [sp, #0]
   1c3b6:	f508 70c8 	add.w	r0, r8, #400	; 0x190
   1c3ba:	f508 71d0 	add.w	r1, r8, #416	; 0x1a0
        psEnc->sCmn.subfr_length, psEnc->sCmn.nb_subfr, psEnc->sCmn.predictLPCOrder, psEnc->sCmn.arch );

    /* Copy to prediction struct for use in next frame for interpolation */
    silk_memcpy( psEnc->sCmn.prev_NLSFq_Q15, NLSF_Q15, sizeof( psEnc->sCmn.prev_NLSFq_Q15 ) );
   1c3be:	f107 0538 	add.w	r5, r7, #56	; 0x38
    silk_residual_energy_FIX( psEncCtrl->ResNrg, psEncCtrl->ResNrgQ, LPC_in_pre, psEncCtrl->PredCoef_Q12, local_gains,
   1c3c2:	f001 fb55 	bl	1da70 <silk_residual_energy_FIX>
    silk_memcpy( psEnc->sCmn.prev_NLSFq_Q15, NLSF_Q15, sizeof( psEnc->sCmn.prev_NLSFq_Q15 ) );
   1c3c6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   1c3c8:	51a0      	str	r0, [r4, r6]
   1c3ca:	f8c9 1004 	str.w	r1, [r9, #4]
   1c3ce:	f8c9 2008 	str.w	r2, [r9, #8]
   1c3d2:	f8c9 300c 	str.w	r3, [r9, #12]
   1c3d6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    RESTORE_STACK;
}
   1c3d8:	375c      	adds	r7, #92	; 0x5c
    silk_memcpy( psEnc->sCmn.prev_NLSFq_Q15, NLSF_Q15, sizeof( psEnc->sCmn.prev_NLSFq_Q15 ) );
   1c3da:	f8c9 0010 	str.w	r0, [r9, #16]
   1c3de:	f8c9 1014 	str.w	r1, [r9, #20]
   1c3e2:	f8c9 2018 	str.w	r2, [r9, #24]
   1c3e6:	f8c9 301c 	str.w	r3, [r9, #28]
}
   1c3ea:	46bd      	mov	sp, r7
   1c3ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1c3f0:	fab5 fe85 	clz	lr, r5
   1c3f4:	f10e 36ff 	add.w	r6, lr, #4294967295	; 0xffffffff
    a32_nrm = silk_LSHIFT(a32, a_headrm);                                       /* Q: a_headrm                  */
   1c3f8:	fa00 f606 	lsl.w	r6, r0, r6
   1c3fc:	f10e 0e1c 	add.w	lr, lr, #28
   1c400:	2b00      	cmp	r3, #0
   1c402:	f47f ae2f 	bne.w	1c064 <silk_find_pred_coefs_FIX+0x70>
   1c406:	f04f 0c1f 	mov.w	ip, #31
   1c40a:	e633      	b.n	1c074 <silk_find_pred_coefs_FIX+0x80>
        minInvGain_Q30 = silk_log2lin( silk_SMLAWB( 16 << 7, (opus_int32)psEncCtrl->LTPredCodGain_Q7, SILK_FIX_CONST( 1.0 / 3, 16 ) ) );      /* Q16 */
   1c40c:	f8d8 018c 	ldr.w	r0, [r8, #396]	; 0x18c
   1c410:	f245 5355 	movw	r3, #21845	; 0x5555
   1c414:	b282      	uxth	r2, r0
   1c416:	1400      	asrs	r0, r0, #16
   1c418:	fb03 f202 	mul.w	r2, r3, r2
   1c41c:	fb03 f300 	mul.w	r3, r3, r0
   1c420:	eb03 4012 	add.w	r0, r3, r2, lsr #16
   1c424:	f500 6000 	add.w	r0, r0, #2048	; 0x800
   1c428:	f7fb fb06 	bl	17a38 <silk_log2lin>
            silk_SMULWW( SILK_FIX_CONST( MAX_PREDICTION_POWER_GAIN, 0 ),
   1c42c:	f8d8 3184 	ldr.w	r3, [r8, #388]	; 0x184
   1c430:	f44f 3180 	mov.w	r1, #65536	; 0x10000
   1c434:	2203      	movs	r2, #3
   1c436:	fb13 1202 	smlabb	r2, r3, r2, r1
   1c43a:	13d2      	asrs	r2, r2, #15
   1c43c:	f242 7110 	movw	r1, #10000	; 0x2710
   1c440:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   1c444:	3201      	adds	r2, #1
   1c446:	fb13 f301 	smulbb	r3, r3, r1
   1c44a:	1052      	asrs	r2, r2, #1
   1c44c:	141b      	asrs	r3, r3, #16
        minInvGain_Q30 = silk_DIV32_varQ( minInvGain_Q30,
   1c44e:	fb01 3202 	mla	r2, r1, r2, r3
   1c452:	2800      	cmp	r0, #0
   1c454:	f040 80dc 	bne.w	1c610 <silk_find_pred_coefs_FIX+0x61c>
   1c458:	231f      	movs	r3, #31
   1c45a:	253c      	movs	r5, #60	; 0x3c
   1c45c:	4098      	lsls	r0, r3
   1c45e:	2a00      	cmp	r2, #0
   1c460:	f000 80e2 	beq.w	1c628 <silk_find_pred_coefs_FIX+0x634>
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
   1c464:	ea82 7ce2 	eor.w	ip, r2, r2, asr #31
   1c468:	ebac 7ce2 	sub.w	ip, ip, r2, asr #31
   1c46c:	fabc fc8c 	clz	ip, ip
   1c470:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                  */
   1c474:	fa02 f20c 	lsl.w	r2, r2, ip
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1c478:	1411      	asrs	r1, r2, #16
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1c47a:	b286      	uxth	r6, r0
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1c47c:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
   1c480:	fb93 f3f1 	sdiv	r3, r3, r1
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1c484:	b219      	sxth	r1, r3
   1c486:	1403      	asrs	r3, r0, #16
   1c488:	fb01 f303 	mul.w	r3, r1, r3
   1c48c:	fb01 f606 	mul.w	r6, r1, r6
   1c490:	eb03 4626 	add.w	r6, r3, r6, asr #16
    a32_nrm = silk_SUB32_ovflw(a32_nrm, silk_LSHIFT_ovflw( silk_SMMUL(b32_nrm, result), 3 ));  /* Q: a_headrm   */
   1c494:	fb82 2306 	smull	r2, r3, r2, r6
   1c498:	eba0 00c3 	sub.w	r0, r0, r3, lsl #3
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1c49c:	b283      	uxth	r3, r0
   1c49e:	1400      	asrs	r0, r0, #16
   1c4a0:	fb01 f203 	mul.w	r2, r1, r3
    lshift = 29 + a_headrm - b_headrm - Qres;
   1c4a4:	eba5 050c 	sub.w	r5, r5, ip
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1c4a8:	fb01 f300 	mul.w	r3, r1, r0
   1c4ac:	eb03 4322 	add.w	r3, r3, r2, asr #16
    if( lshift < 0 ) {
   1c4b0:	f1b5 020e 	subs.w	r2, r5, #14
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1c4b4:	4433      	add	r3, r6
    if( lshift < 0 ) {
   1c4b6:	f100 80ff 	bmi.w	1c6b8 <silk_find_pred_coefs_FIX+0x6c4>
            return silk_RSHIFT(result, lshift);
   1c4ba:	4113      	asrs	r3, r2
   1c4bc:	e752      	b.n	1c364 <silk_find_pred_coefs_FIX+0x370>
   1c4be:	f04f 0c1f 	mov.w	ip, #31
   1c4c2:	e628      	b.n	1c116 <silk_find_pred_coefs_FIX+0x122>
   1c4c4:	f04f 093c 	mov.w	r9, #60	; 0x3c
   1c4c8:	261f      	movs	r6, #31
   1c4ca:	e617      	b.n	1c0fc <silk_find_pred_coefs_FIX+0x108>
        return silk_LSHIFT_SAT32(result, -lshift);
   1c4cc:	f1cc 0c0e 	rsb	ip, ip, #14
   1c4d0:	f04f 4900 	mov.w	r9, #2147483648	; 0x80000000
   1c4d4:	f06f 4600 	mvn.w	r6, #2147483648	; 0x80000000
   1c4d8:	fa49 f90c 	asr.w	r9, r9, ip
   1c4dc:	fa46 f60c 	asr.w	r6, r6, ip
   1c4e0:	454e      	cmp	r6, r9
   1c4e2:	f2c0 80a8 	blt.w	1c636 <silk_find_pred_coefs_FIX+0x642>
   1c4e6:	429e      	cmp	r6, r3
   1c4e8:	f2c0 810e 	blt.w	1c708 <silk_find_pred_coefs_FIX+0x714>
   1c4ec:	454b      	cmp	r3, r9
   1c4ee:	bfb8      	it	lt
   1c4f0:	464b      	movlt	r3, r9
   1c4f2:	fa03 f30c 	lsl.w	r3, r3, ip
   1c4f6:	2b64      	cmp	r3, #100	; 0x64
   1c4f8:	bfb8      	it	lt
   1c4fa:	2364      	movlt	r3, #100	; 0x64
   1c4fc:	f44f 3680 	mov.w	r6, #65536	; 0x10000
   1c500:	fb96 f6f3 	sdiv	r6, r6, r3
   1c504:	e5ea      	b.n	1c0dc <silk_find_pred_coefs_FIX+0xe8>
   1c506:	f04f 0c1f 	mov.w	ip, #31
   1c50a:	e655      	b.n	1c1b8 <silk_find_pred_coefs_FIX+0x1c4>
   1c50c:	f04f 093c 	mov.w	r9, #60	; 0x3c
   1c510:	261f      	movs	r6, #31
   1c512:	e644      	b.n	1c19e <silk_find_pred_coefs_FIX+0x1aa>
        if( lshift < 32){
   1c514:	f240 268f 	movw	r6, #655	; 0x28f
   1c518:	2364      	movs	r3, #100	; 0x64
   1c51a:	e5df      	b.n	1c0dc <silk_find_pred_coefs_FIX+0xe8>
        return silk_LSHIFT_SAT32(result, -lshift);
   1c51c:	f1cc 0c0e 	rsb	ip, ip, #14
   1c520:	f04f 4e00 	mov.w	lr, #2147483648	; 0x80000000
   1c524:	f06f 4600 	mvn.w	r6, #2147483648	; 0x80000000
   1c528:	fa4e fe0c 	asr.w	lr, lr, ip
   1c52c:	fa46 f60c 	asr.w	r6, r6, ip
   1c530:	4576      	cmp	r6, lr
   1c532:	f2c0 8086 	blt.w	1c642 <silk_find_pred_coefs_FIX+0x64e>
   1c536:	429e      	cmp	r6, r3
   1c538:	f2c0 80ee 	blt.w	1c718 <silk_find_pred_coefs_FIX+0x724>
   1c53c:	4573      	cmp	r3, lr
   1c53e:	bfb8      	it	lt
   1c540:	4673      	movlt	r3, lr
   1c542:	fa03 f30c 	lsl.w	r3, r3, ip
   1c546:	2b64      	cmp	r3, #100	; 0x64
   1c548:	bfb8      	it	lt
   1c54a:	2364      	movlt	r3, #100	; 0x64
   1c54c:	f44f 3680 	mov.w	r6, #65536	; 0x10000
   1c550:	fb96 f6f3 	sdiv	r6, r6, r3
   1c554:	e613      	b.n	1c17e <silk_find_pred_coefs_FIX+0x18a>
        ALLOC( xXLTP_Q17, psEnc->sCmn.nb_subfr * LTP_ORDER, opus_int32 );
   1c556:	eb01 0381 	add.w	r3, r1, r1, lsl #2
   1c55a:	0098      	lsls	r0, r3, #2
        ALLOC( XXLTP_Q17, psEnc->sCmn.nb_subfr * LTP_ORDER * LTP_ORDER, opus_int32 );
   1c55c:	4403      	add	r3, r0
   1c55e:	009b      	lsls	r3, r3, #2
        ALLOC( xXLTP_Q17, psEnc->sCmn.nb_subfr * LTP_ORDER, opus_int32 );
   1c560:	300a      	adds	r0, #10
   1c562:	f020 0007 	bic.w	r0, r0, #7
        ALLOC( XXLTP_Q17, psEnc->sCmn.nb_subfr * LTP_ORDER * LTP_ORDER, opus_int32 );
   1c566:	330a      	adds	r3, #10
    if( psEnc->sCmn.indices.signalType == TYPE_VOICED ) {
   1c568:	f8c7 d008 	str.w	sp, [r7, #8]
        silk_find_LTP_FIX( XXLTP_Q17, xXLTP_Q17, res_pitch,
   1c56c:	f241 36e4 	movw	r6, #5092	; 0x13e4
        ALLOC( xXLTP_Q17, psEnc->sCmn.nb_subfr * LTP_ORDER, opus_int32 );
   1c570:	ebad 0d00 	sub.w	sp, sp, r0
        ALLOC( XXLTP_Q17, psEnc->sCmn.nb_subfr * LTP_ORDER * LTP_ORDER, opus_int32 );
   1c574:	f023 0307 	bic.w	r3, r3, #7
        ALLOC( xXLTP_Q17, psEnc->sCmn.nb_subfr * LTP_ORDER, opus_int32 );
   1c578:	ad06      	add	r5, sp, #24
        ALLOC( XXLTP_Q17, psEnc->sCmn.nb_subfr * LTP_ORDER * LTP_ORDER, opus_int32 );
   1c57a:	ebad 0d03 	sub.w	sp, sp, r3
        silk_find_LTP_FIX( XXLTP_Q17, xXLTP_Q17, res_pitch,
   1c57e:	f241 19ec 	movw	r9, #4588	; 0x11ec
   1c582:	59a3      	ldr	r3, [r4, r6]
   1c584:	9302      	str	r3, [sp, #8]
   1c586:	9101      	str	r1, [sp, #4]
   1c588:	f854 3009 	ldr.w	r3, [r4, r9]
   1c58c:	9300      	str	r3, [sp, #0]
            psEncCtrl->pitchL, psEnc->sCmn.subfr_length, psEnc->sCmn.nb_subfr, psEnc->sCmn.arch );
   1c58e:	f108 0a7c 	add.w	sl, r8, #124	; 0x7c
        ALLOC( XXLTP_Q17, psEnc->sCmn.nb_subfr * LTP_ORDER * LTP_ORDER, opus_int32 );
   1c592:	ab06      	add	r3, sp, #24
        silk_find_LTP_FIX( XXLTP_Q17, xXLTP_Q17, res_pitch,
   1c594:	4618      	mov	r0, r3
   1c596:	4629      	mov	r1, r5
   1c598:	603b      	str	r3, [r7, #0]
   1c59a:	607d      	str	r5, [r7, #4]
   1c59c:	4653      	mov	r3, sl
   1c59e:	f7ff f9b7 	bl	1b910 <silk_find_LTP_FIX>
        silk_quant_LTP_gains( psEncCtrl->LTPCoef_Q14, psEnc->sCmn.indices.LTPIndex, &psEnc->sCmn.indices.PERIndex,
   1c5a2:	f241 15e4 	movw	r5, #4580	; 0x11e4
   1c5a6:	59a3      	ldr	r3, [r4, r6]
   1c5a8:	9305      	str	r3, [sp, #20]
   1c5aa:	5963      	ldr	r3, [r4, r5]
   1c5ac:	9304      	str	r3, [sp, #16]
   1c5ae:	f854 3009 	ldr.w	r3, [r4, r9]
   1c5b2:	9303      	str	r3, [sp, #12]
   1c5b4:	6838      	ldr	r0, [r7, #0]
   1c5b6:	9001      	str	r0, [sp, #4]
   1c5b8:	6878      	ldr	r0, [r7, #4]
   1c5ba:	9002      	str	r0, [sp, #8]
   1c5bc:	f508 72c6 	add.w	r2, r8, #396	; 0x18c
   1c5c0:	9200      	str	r2, [sp, #0]
   1c5c2:	693e      	ldr	r6, [r7, #16]
   1c5c4:	465b      	mov	r3, fp
   1c5c6:	f504 5194 	add.w	r1, r4, #4736	; 0x1280
   1c5ca:	3310      	adds	r3, #16
   1c5cc:	3104      	adds	r1, #4
   1c5ce:	f504 5295 	add.w	r2, r4, #4768	; 0x12a0
   1c5d2:	4630      	mov	r0, r6
   1c5d4:	f7f7 fdaa 	bl	1412c <silk_quant_LTP_gains>
        silk_LTP_scale_ctrl_FIX( psEnc, psEncCtrl, condCoding );
   1c5d8:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
   1c5dc:	4641      	mov	r1, r8
   1c5de:	4620      	mov	r0, r4
   1c5e0:	f7fe f902 	bl	1a7e8 <silk_LTP_scale_ctrl_FIX>
        silk_LTP_analysis_filter_FIX( LPC_in_pre, x - psEnc->sCmn.predictLPCOrder, psEncCtrl->LTPCoef_Q14,
   1c5e4:	f8db 1000 	ldr.w	r1, [fp]
   1c5e8:	9103      	str	r1, [sp, #12]
   1c5ea:	5963      	ldr	r3, [r4, r5]
   1c5ec:	9302      	str	r3, [sp, #8]
   1c5ee:	f854 3009 	ldr.w	r3, [r4, r9]
   1c5f2:	9301      	str	r3, [sp, #4]
   1c5f4:	68f8      	ldr	r0, [r7, #12]
   1c5f6:	eba0 0141 	sub.w	r1, r0, r1, lsl #1
   1c5fa:	f107 0018 	add.w	r0, r7, #24
   1c5fe:	9000      	str	r0, [sp, #0]
   1c600:	4653      	mov	r3, sl
   1c602:	4632      	mov	r2, r6
   1c604:	6978      	ldr	r0, [r7, #20]
   1c606:	f7fe f869 	bl	1a6dc <silk_LTP_analysis_filter_FIX>
   1c60a:	f8d7 d008 	ldr.w	sp, [r7, #8]
   1c60e:	e6a3      	b.n	1c358 <silk_find_pred_coefs_FIX+0x364>
    a_headrm = silk_CLZ32( silk_abs(a32) ) - 1;
   1c610:	ea80 75e0 	eor.w	r5, r0, r0, asr #31
   1c614:	eba5 75e0 	sub.w	r5, r5, r0, asr #31
   1c618:	fab5 f585 	clz	r5, r5
   1c61c:	1e6b      	subs	r3, r5, #1
    a32_nrm = silk_LSHIFT(a32, a_headrm);                                       /* Q: a_headrm                  */
   1c61e:	4098      	lsls	r0, r3
   1c620:	351c      	adds	r5, #28
   1c622:	2a00      	cmp	r2, #0
   1c624:	f47f af1e 	bne.w	1c464 <silk_find_pred_coefs_FIX+0x470>
   1c628:	f04f 0c1f 	mov.w	ip, #31
   1c62c:	e722      	b.n	1c474 <silk_find_pred_coefs_FIX+0x480>
        if( lshift < 32){
   1c62e:	f240 268f 	movw	r6, #655	; 0x28f
   1c632:	2364      	movs	r3, #100	; 0x64
   1c634:	e5f4      	b.n	1c220 <silk_find_pred_coefs_FIX+0x22c>
        return silk_LSHIFT_SAT32(result, -lshift);
   1c636:	4599      	cmp	r9, r3
   1c638:	db68      	blt.n	1c70c <silk_find_pred_coefs_FIX+0x718>
   1c63a:	42b3      	cmp	r3, r6
   1c63c:	bfb8      	it	lt
   1c63e:	4633      	movlt	r3, r6
   1c640:	e757      	b.n	1c4f2 <silk_find_pred_coefs_FIX+0x4fe>
   1c642:	459e      	cmp	lr, r3
   1c644:	db6a      	blt.n	1c71c <silk_find_pred_coefs_FIX+0x728>
   1c646:	42b3      	cmp	r3, r6
   1c648:	bfb8      	it	lt
   1c64a:	4633      	movlt	r3, r6
   1c64c:	e779      	b.n	1c542 <silk_find_pred_coefs_FIX+0x54e>
   1c64e:	f04f 0c1f 	mov.w	ip, #31
   1c652:	e5fe      	b.n	1c252 <silk_find_pred_coefs_FIX+0x25e>
   1c654:	253c      	movs	r5, #60	; 0x3c
   1c656:	231f      	movs	r3, #31
   1c658:	e5ef      	b.n	1c23a <silk_find_pred_coefs_FIX+0x246>
        if( lshift < 32){
   1c65a:	f240 268f 	movw	r6, #655	; 0x28f
   1c65e:	2364      	movs	r3, #100	; 0x64
   1c660:	e58d      	b.n	1c17e <silk_find_pred_coefs_FIX+0x18a>
        return silk_LSHIFT_SAT32(result, -lshift);
   1c662:	f1cc 0c0e 	rsb	ip, ip, #14
   1c666:	f04f 4e00 	mov.w	lr, #2147483648	; 0x80000000
   1c66a:	f06f 4600 	mvn.w	r6, #2147483648	; 0x80000000
   1c66e:	fa4e fe0c 	asr.w	lr, lr, ip
   1c672:	fa46 f60c 	asr.w	r6, r6, ip
   1c676:	4576      	cmp	r6, lr
   1c678:	da33      	bge.n	1c6e2 <silk_find_pred_coefs_FIX+0x6ee>
   1c67a:	459e      	cmp	lr, r3
   1c67c:	da52      	bge.n	1c724 <silk_find_pred_coefs_FIX+0x730>
   1c67e:	4673      	mov	r3, lr
   1c680:	e034      	b.n	1c6ec <silk_find_pred_coefs_FIX+0x6f8>
   1c682:	f1c5 050e 	rsb	r5, r5, #14
   1c686:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
   1c68a:	f06f 4600 	mvn.w	r6, #2147483648	; 0x80000000
   1c68e:	4128      	asrs	r0, r5
   1c690:	412e      	asrs	r6, r5
   1c692:	42b0      	cmp	r0, r6
   1c694:	dd34      	ble.n	1c700 <silk_find_pred_coefs_FIX+0x70c>
   1c696:	4283      	cmp	r3, r0
   1c698:	dc48      	bgt.n	1c72c <silk_find_pred_coefs_FIX+0x738>
   1c69a:	42b3      	cmp	r3, r6
   1c69c:	bfb8      	it	lt
   1c69e:	4633      	movlt	r3, r6
   1c6a0:	40ab      	lsls	r3, r5
   1c6a2:	2b64      	cmp	r3, #100	; 0x64
   1c6a4:	bfb8      	it	lt
   1c6a6:	2364      	movlt	r3, #100	; 0x64
   1c6a8:	f44f 3080 	mov.w	r0, #65536	; 0x10000
   1c6ac:	fb90 f0f3 	sdiv	r0, r0, r3
   1c6b0:	e5ff      	b.n	1c2b2 <silk_find_pred_coefs_FIX+0x2be>
   1c6b2:	bf00      	nop
   1c6b4:	00a3d70a 	.word	0x00a3d70a
   1c6b8:	f1c5 050e 	rsb	r5, r5, #14
   1c6bc:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   1c6c0:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
   1c6c4:	412a      	asrs	r2, r5
   1c6c6:	4129      	asrs	r1, r5
   1c6c8:	428a      	cmp	r2, r1
   1c6ca:	dd21      	ble.n	1c710 <silk_find_pred_coefs_FIX+0x71c>
   1c6cc:	4293      	cmp	r3, r2
   1c6ce:	dc33      	bgt.n	1c738 <silk_find_pred_coefs_FIX+0x744>
   1c6d0:	428b      	cmp	r3, r1
   1c6d2:	bfb8      	it	lt
   1c6d4:	460b      	movlt	r3, r1
   1c6d6:	40ab      	lsls	r3, r5
   1c6d8:	e644      	b.n	1c364 <silk_find_pred_coefs_FIX+0x370>
        if( lshift < 32){
   1c6da:	f240 208f 	movw	r0, #655	; 0x28f
   1c6de:	2364      	movs	r3, #100	; 0x64
   1c6e0:	e5e7      	b.n	1c2b2 <silk_find_pred_coefs_FIX+0x2be>
        return silk_LSHIFT_SAT32(result, -lshift);
   1c6e2:	429e      	cmp	r6, r3
   1c6e4:	db1c      	blt.n	1c720 <silk_find_pred_coefs_FIX+0x72c>
   1c6e6:	4573      	cmp	r3, lr
   1c6e8:	bfb8      	it	lt
   1c6ea:	4673      	movlt	r3, lr
   1c6ec:	fa03 f30c 	lsl.w	r3, r3, ip
   1c6f0:	2b64      	cmp	r3, #100	; 0x64
   1c6f2:	bfb8      	it	lt
   1c6f4:	2364      	movlt	r3, #100	; 0x64
   1c6f6:	f44f 3680 	mov.w	r6, #65536	; 0x10000
   1c6fa:	fb96 f6f3 	sdiv	r6, r6, r3
   1c6fe:	e58f      	b.n	1c220 <silk_find_pred_coefs_FIX+0x22c>
   1c700:	42b3      	cmp	r3, r6
   1c702:	dd15      	ble.n	1c730 <silk_find_pred_coefs_FIX+0x73c>
   1c704:	4633      	mov	r3, r6
   1c706:	e7cb      	b.n	1c6a0 <silk_find_pred_coefs_FIX+0x6ac>
   1c708:	4633      	mov	r3, r6
   1c70a:	e6f2      	b.n	1c4f2 <silk_find_pred_coefs_FIX+0x4fe>
   1c70c:	464b      	mov	r3, r9
   1c70e:	e6f0      	b.n	1c4f2 <silk_find_pred_coefs_FIX+0x4fe>
   1c710:	428b      	cmp	r3, r1
   1c712:	dd13      	ble.n	1c73c <silk_find_pred_coefs_FIX+0x748>
   1c714:	460b      	mov	r3, r1
   1c716:	e7de      	b.n	1c6d6 <silk_find_pred_coefs_FIX+0x6e2>
   1c718:	4633      	mov	r3, r6
   1c71a:	e712      	b.n	1c542 <silk_find_pred_coefs_FIX+0x54e>
   1c71c:	4673      	mov	r3, lr
   1c71e:	e710      	b.n	1c542 <silk_find_pred_coefs_FIX+0x54e>
   1c720:	4633      	mov	r3, r6
   1c722:	e7e3      	b.n	1c6ec <silk_find_pred_coefs_FIX+0x6f8>
   1c724:	42b3      	cmp	r3, r6
   1c726:	bfb8      	it	lt
   1c728:	4633      	movlt	r3, r6
   1c72a:	e7df      	b.n	1c6ec <silk_find_pred_coefs_FIX+0x6f8>
   1c72c:	4603      	mov	r3, r0
   1c72e:	e7b7      	b.n	1c6a0 <silk_find_pred_coefs_FIX+0x6ac>
   1c730:	4283      	cmp	r3, r0
   1c732:	bfb8      	it	lt
   1c734:	4603      	movlt	r3, r0
   1c736:	e7b3      	b.n	1c6a0 <silk_find_pred_coefs_FIX+0x6ac>
   1c738:	4613      	mov	r3, r2
   1c73a:	e7cc      	b.n	1c6d6 <silk_find_pred_coefs_FIX+0x6e2>
   1c73c:	4293      	cmp	r3, r2
   1c73e:	bfb8      	it	lt
   1c740:	4613      	movlt	r3, r2
   1c742:	e7c8      	b.n	1c6d6 <silk_find_pred_coefs_FIX+0x6e2>

0001c744 <silk_noise_shape_analysis_FIX>:
    silk_encoder_control_FIX        *psEncCtrl,                             /* I/O  Encoder control FIX                                                         */
    const opus_int16                *pitch_res,                             /* I    LPC residual from pitch analysis                                            */
    const opus_int16                *x,                                     /* I    Input signal [ frame_length + la_shape ]                                    */
    int                              arch                                   /* I    Run-time architecture                                                       */
)
{
   1c744:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1c748:	b0ed      	sub	sp, #436	; 0x1b4
   1c74a:	4606      	mov	r6, r0
   1c74c:	af02      	add	r7, sp, #8
    x_ptr = x - psEnc->sCmn.la_shape;

    /****************/
    /* GAIN CONTROL */
    /****************/
    SNR_adj_dB_Q7 = psEnc->sCmn.SNR_dB_Q7;
   1c74e:	f241 2c6c 	movw	ip, #4716	; 0x126c

    /* Input quality is the average of the quality in the lowest two VAD bands */
    psEncCtrl->input_quality_Q14 = ( opus_int )silk_RSHIFT( (opus_int32)psEnc->sCmn.input_quality_bands_Q15[ 0 ]
   1c752:	f241 205c 	movw	r0, #4700	; 0x125c
   1c756:	f241 2458 	movw	r4, #4696	; 0x1258
    SNR_adj_dB_Q7 = psEnc->sCmn.SNR_dB_Q7;
   1c75a:	f856 800c 	ldr.w	r8, [r6, ip]
    psEncCtrl->input_quality_Q14 = ( opus_int )silk_RSHIFT( (opus_int32)psEnc->sCmn.input_quality_bands_Q15[ 0 ]
   1c75e:	5934      	ldr	r4, [r6, r4]
   1c760:	63be      	str	r6, [r7, #56]	; 0x38
   1c762:	5836      	ldr	r6, [r6, r0]
{
   1c764:	6379      	str	r1, [r7, #52]	; 0x34
   1c766:	468c      	mov	ip, r1
    x_ptr = x - psEnc->sCmn.la_shape;
   1c768:	f241 15f8 	movw	r5, #4600	; 0x11f8
    psEncCtrl->input_quality_Q14 = ( opus_int )silk_RSHIFT( (opus_int32)psEnc->sCmn.input_quality_bands_Q15[ 0 ]
   1c76c:	19a1      	adds	r1, r4, r6
    x_ptr = x - psEnc->sCmn.la_shape;
   1c76e:	6bbc      	ldr	r4, [r7, #56]	; 0x38
        + psEnc->sCmn.input_quality_bands_Q15[ 1 ], 2 );

    /* Coding quality level, between 0.0_Q0 and 1.0_Q0, but in Q14 */
    psEncCtrl->coding_quality_Q14 = silk_RSHIFT( silk_sigm_Q15( silk_RSHIFT_ROUND( SNR_adj_dB_Q7 -
   1c770:	f5a8 6020 	sub.w	r0, r8, #2560	; 0xa00
    x_ptr = x - psEnc->sCmn.la_shape;
   1c774:	5964      	ldr	r4, [r4, r5]
    psEncCtrl->coding_quality_Q14 = silk_RSHIFT( silk_sigm_Q15( silk_RSHIFT_ROUND( SNR_adj_dB_Q7 -
   1c776:	10c0      	asrs	r0, r0, #3
    psEncCtrl->input_quality_Q14 = ( opus_int )silk_RSHIFT( (opus_int32)psEnc->sCmn.input_quality_bands_Q15[ 0 ]
   1c778:	1089      	asrs	r1, r1, #2
    psEncCtrl->coding_quality_Q14 = silk_RSHIFT( silk_sigm_Q15( silk_RSHIFT_ROUND( SNR_adj_dB_Q7 -
   1c77a:	3001      	adds	r0, #1
    x_ptr = x - psEnc->sCmn.la_shape;
   1c77c:	eba3 0344 	sub.w	r3, r3, r4, lsl #1
    psEncCtrl->input_quality_Q14 = ( opus_int )silk_RSHIFT( (opus_int32)psEnc->sCmn.input_quality_bands_Q15[ 0 ]
   1c780:	f8cc 1180 	str.w	r1, [ip, #384]	; 0x180
    psEncCtrl->coding_quality_Q14 = silk_RSHIFT( silk_sigm_Q15( silk_RSHIFT_ROUND( SNR_adj_dB_Q7 -
   1c784:	1040      	asrs	r0, r0, #1
    opus_int     k, i, nSamples, nSegs, Qnrg, b_Q14, warping_Q16, scale = 0;
   1c786:	2100      	movs	r1, #0
    psEncCtrl->input_quality_Q14 = ( opus_int )silk_RSHIFT( (opus_int32)psEnc->sCmn.input_quality_bands_Q15[ 0 ]
   1c788:	4665      	mov	r5, ip
    x_ptr = x - psEnc->sCmn.la_shape;
   1c78a:	633b      	str	r3, [r7, #48]	; 0x30
    opus_int     k, i, nSamples, nSegs, Qnrg, b_Q14, warping_Q16, scale = 0;
   1c78c:	67f9      	str	r1, [r7, #124]	; 0x7c
{
   1c78e:	4616      	mov	r6, r2
    psEncCtrl->coding_quality_Q14 = silk_RSHIFT( silk_sigm_Q15( silk_RSHIFT_ROUND( SNR_adj_dB_Q7 -
   1c790:	f7fd fa6c 	bl	19c6c <silk_sigm_Q15>
        SILK_FIX_CONST( 20.0, 7 ), 4 ) ), 1 );

    /* Reduce coding SNR during low speech activity */
    if( psEnc->sCmn.useCBR == 0 ) {
   1c794:	f241 2344 	movw	r3, #4676	; 0x1244
   1c798:	6bb9      	ldr	r1, [r7, #56]	; 0x38
   1c79a:	58cb      	ldr	r3, [r1, r3]
    psEncCtrl->coding_quality_Q14 = silk_RSHIFT( silk_sigm_Q15( silk_RSHIFT_ROUND( SNR_adj_dB_Q7 -
   1c79c:	1040      	asrs	r0, r0, #1
   1c79e:	f8c5 0184 	str.w	r0, [r5, #388]	; 0x184
    if( psEnc->sCmn.useCBR == 0 ) {
   1c7a2:	bb4b      	cbnz	r3, 1c7f8 <silk_noise_shape_analysis_FIX+0xb4>
        b_Q8 = SILK_FIX_CONST( 1.0, 8 ) - psEnc->sCmn.speech_activity_Q8;
   1c7a4:	f241 13b4 	movw	r3, #4532	; 0x11b4
        b_Q8 = silk_SMULWB( silk_LSHIFT( b_Q8, 8 ), b_Q8 );
        SNR_adj_dB_Q7 = silk_SMLAWB( SNR_adj_dB_Q7,
   1c7a8:	f8d5 2180 	ldr.w	r2, [r5, #384]	; 0x180
        b_Q8 = SILK_FIX_CONST( 1.0, 8 ) - psEnc->sCmn.speech_activity_Q8;
   1c7ac:	58cb      	ldr	r3, [r1, r3]
   1c7ae:	f5c3 7380 	rsb	r3, r3, #256	; 0x100
        b_Q8 = silk_SMULWB( silk_LSHIFT( b_Q8, 8 ), b_Q8 );
   1c7b2:	0219      	lsls	r1, r3, #8
   1c7b4:	b28c      	uxth	r4, r1
   1c7b6:	b21b      	sxth	r3, r3
   1c7b8:	1409      	asrs	r1, r1, #16
   1c7ba:	fb03 f404 	mul.w	r4, r3, r4
   1c7be:	fb03 f301 	mul.w	r3, r3, r1
   1c7c2:	eb03 4324 	add.w	r3, r3, r4, asr #16
        SNR_adj_dB_Q7 = silk_SMLAWB( SNR_adj_dB_Q7,
   1c7c6:	f502 4280 	add.w	r2, r2, #16384	; 0x4000
   1c7ca:	b294      	uxth	r4, r2
   1c7cc:	b21b      	sxth	r3, r3
   1c7ce:	b201      	sxth	r1, r0
   1c7d0:	fb01 f104 	mul.w	r1, r1, r4
   1c7d4:	ebc3 7343 	rsb	r3, r3, r3, lsl #29
   1c7d8:	fb12 f220 	smultb	r2, r2, r0
   1c7dc:	00db      	lsls	r3, r3, #3
   1c7de:	eb02 4221 	add.w	r2, r2, r1, asr #16
   1c7e2:	b212      	sxth	r2, r2
   1c7e4:	b299      	uxth	r1, r3
   1c7e6:	141b      	asrs	r3, r3, #16
   1c7e8:	fb02 f101 	mul.w	r1, r2, r1
   1c7ec:	fb02 f303 	mul.w	r3, r2, r3
   1c7f0:	eb03 4321 	add.w	r3, r3, r1, asr #16
   1c7f4:	6bb9      	ldr	r1, [r7, #56]	; 0x38
   1c7f6:	4498      	add	r8, r3
            silk_SMULBB( SILK_FIX_CONST( -BG_SNR_DECR_dB, 7 ) >> ( 4 + 1 ), b_Q8 ),                                       /* Q11*/
            silk_SMULWB( SILK_FIX_CONST( 1.0, 14 ) + psEncCtrl->input_quality_Q14, psEncCtrl->coding_quality_Q14 ) );     /* Q12*/
    }

    if( psEnc->sCmn.indices.signalType == TYPE_VOICED ) {
   1c7f8:	f241 239d 	movw	r3, #4765	; 0x129d
   1c7fc:	f241 12e4 	movw	r2, #4580	; 0x11e4
   1c800:	56cb      	ldrsb	r3, [r1, r3]
   1c802:	588a      	ldr	r2, [r1, r2]
   1c804:	2b02      	cmp	r3, #2
   1c806:	4608      	mov	r0, r1
   1c808:	f000 875d 	beq.w	1d6c6 <silk_noise_shape_analysis_FIX+0xf82>
        /* Reduce gains for periodic signals */
        SNR_adj_dB_Q7 = silk_SMLAWB( SNR_adj_dB_Q7, SILK_FIX_CONST( HARM_SNR_INCR_dB, 8 ), psEnc->LTPCorr_Q15 );
    } else {
        /* For unvoiced signals and low-quality input, adjust the quality slower than SNR_dB setting */
        SNR_adj_dB_Q7 = silk_SMLAWB( SNR_adj_dB_Q7,
   1c80c:	f241 236c 	movw	r3, #4716	; 0x126c
   1c810:	460d      	mov	r5, r1
   1c812:	5ec9      	ldrsh	r1, [r1, r3]
   1c814:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1c816:	f246 6066 	movw	r0, #26214	; 0x6666
   1c81a:	fb11 f000 	smulbb	r0, r1, r0
   1c81e:	1400      	asrs	r0, r0, #16
   1c820:	f64f 74fe 	movw	r4, #65534	; 0xfffe
   1c824:	f8d3 3180 	ldr.w	r3, [r3, #384]	; 0x180
   1c828:	fb11 0104 	smlabb	r1, r1, r4, r0
   1c82c:	f501 6140 	add.w	r1, r1, #3072	; 0xc00
        /* Sparseness measure, based on relative fluctuations of energy per 2 milliseconds */
        nSamples = silk_LSHIFT( psEnc->sCmn.fs_kHz, 1 );
        energy_variation_Q7 = 0;
        log_energy_prev_Q7  = 0;
        pitch_res_ptr = pitch_res;
        nSegs = silk_SMULBB( SUB_FRAME_LENGTH_MS, psEnc->sCmn.nb_subfr ) / 2;
   1c830:	b212      	sxth	r2, r2
        SNR_adj_dB_Q7 = silk_SMLAWB( SNR_adj_dB_Q7,
   1c832:	f5c3 4380 	rsb	r3, r3, #16384	; 0x4000
        nSamples = silk_LSHIFT( psEnc->sCmn.fs_kHz, 1 );
   1c836:	f505 548f 	add.w	r4, r5, #4576	; 0x11e0
        SNR_adj_dB_Q7 = silk_SMLAWB( SNR_adj_dB_Q7,
   1c83a:	b288      	uxth	r0, r1
   1c83c:	b21b      	sxth	r3, r3
        nSegs = silk_SMULBB( SUB_FRAME_LENGTH_MS, psEnc->sCmn.nb_subfr ) / 2;
   1c83e:	eb02 0282 	add.w	r2, r2, r2, lsl #2
        SNR_adj_dB_Q7 = silk_SMLAWB( SNR_adj_dB_Q7,
   1c842:	1409      	asrs	r1, r1, #16
   1c844:	fb03 f000 	mul.w	r0, r3, r0
        nSegs = silk_SMULBB( SUB_FRAME_LENGTH_MS, psEnc->sCmn.nb_subfr ) / 2;
   1c848:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
        SNR_adj_dB_Q7 = silk_SMLAWB( SNR_adj_dB_Q7,
   1c84c:	fb03 f301 	mul.w	r3, r3, r1
        nSamples = silk_LSHIFT( psEnc->sCmn.fs_kHz, 1 );
   1c850:	623c      	str	r4, [r7, #32]
        nSegs = silk_SMULBB( SUB_FRAME_LENGTH_MS, psEnc->sCmn.nb_subfr ) / 2;
   1c852:	1055      	asrs	r5, r2, #1
        nSamples = silk_LSHIFT( psEnc->sCmn.fs_kHz, 1 );
   1c854:	6824      	ldr	r4, [r4, #0]
        SNR_adj_dB_Q7 = silk_SMLAWB( SNR_adj_dB_Q7,
   1c856:	eb03 4320 	add.w	r3, r3, r0, asr #16
   1c85a:	4443      	add	r3, r8
        for( k = 0; k < nSegs; k++ ) {
   1c85c:	2d00      	cmp	r5, #0
        SNR_adj_dB_Q7 = silk_SMLAWB( SNR_adj_dB_Q7,
   1c85e:	607b      	str	r3, [r7, #4]
        nSamples = silk_LSHIFT( psEnc->sCmn.fs_kHz, 1 );
   1c860:	ea4f 0944 	mov.w	r9, r4, lsl #1
        for( k = 0; k < nSegs; k++ ) {
   1c864:	f340 8761 	ble.w	1d72a <silk_noise_shape_analysis_FIX+0xfe6>
            silk_sum_sqr_shift( &nrg, &scale, pitch_res_ptr, nSamples );
   1c868:	f107 0180 	add.w	r1, r7, #128	; 0x80
   1c86c:	4688      	mov	r8, r1
   1c86e:	4608      	mov	r0, r1
   1c870:	464b      	mov	r3, r9
   1c872:	4632      	mov	r2, r6
   1c874:	f107 017c 	add.w	r1, r7, #124	; 0x7c
   1c878:	f7fd fb66 	bl	19f48 <silk_sum_sqr_shift>
            nrg += silk_RSHIFT( nSamples, scale );           /* Q(-scale)*/
   1c87c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
   1c87e:	f8d8 2000 	ldr.w	r2, [r8]
   1c882:	fa49 f303 	asr.w	r3, r9, r3
   1c886:	4641      	mov	r1, r8
   1c888:	4413      	add	r3, r2

            log_energy_Q7 = silk_lin2log( nrg );
   1c88a:	4618      	mov	r0, r3
            nrg += silk_RSHIFT( nSamples, scale );           /* Q(-scale)*/
   1c88c:	6279      	str	r1, [r7, #36]	; 0x24
   1c88e:	600b      	str	r3, [r1, #0]
            log_energy_Q7 = silk_lin2log( nrg );
   1c890:	f7fb f892 	bl	179b8 <silk_lin2log>
            if( k > 0 ) {
                energy_variation_Q7 += silk_abs( log_energy_Q7 - log_energy_prev_Q7 );
            }
            log_energy_prev_Q7 = log_energy_Q7;
            pitch_res_ptr += nSamples;
   1c894:	ea4f 0b84 	mov.w	fp, r4, lsl #2
        for( k = 0; k < nSegs; k++ ) {
   1c898:	f04f 0800 	mov.w	r8, #0
   1c89c:	f8c7 b074 	str.w	fp, [r7, #116]	; 0x74
        energy_variation_Q7 = 0;
   1c8a0:	46c2      	mov	sl, r8
            log_energy_Q7 = silk_lin2log( nrg );
   1c8a2:	4604      	mov	r4, r0
   1c8a4:	f8d7 b024 	ldr.w	fp, [r7, #36]	; 0x24
   1c8a8:	e012      	b.n	1c8d0 <silk_noise_shape_analysis_FIX+0x18c>
            silk_sum_sqr_shift( &nrg, &scale, pitch_res_ptr, nSamples );
   1c8aa:	f7fd fb4d 	bl	19f48 <silk_sum_sqr_shift>
            nrg += silk_RSHIFT( nSamples, scale );           /* Q(-scale)*/
   1c8ae:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
   1c8b0:	f8db 2000 	ldr.w	r2, [fp]
   1c8b4:	fa49 f303 	asr.w	r3, r9, r3
   1c8b8:	4413      	add	r3, r2
            log_energy_Q7 = silk_lin2log( nrg );
   1c8ba:	4618      	mov	r0, r3
            nrg += silk_RSHIFT( nSamples, scale );           /* Q(-scale)*/
   1c8bc:	f8cb 3000 	str.w	r3, [fp]
            log_energy_Q7 = silk_lin2log( nrg );
   1c8c0:	f7fb f87a 	bl	179b8 <silk_lin2log>
                energy_variation_Q7 += silk_abs( log_energy_Q7 - log_energy_prev_Q7 );
   1c8c4:	1b04      	subs	r4, r0, r4
   1c8c6:	2c00      	cmp	r4, #0
   1c8c8:	bfb8      	it	lt
   1c8ca:	4264      	neglt	r4, r4
   1c8cc:	44a2      	add	sl, r4
            log_energy_Q7 = silk_lin2log( nrg );
   1c8ce:	4604      	mov	r4, r0
            pitch_res_ptr += nSamples;
   1c8d0:	6f7a      	ldr	r2, [r7, #116]	; 0x74
        for( k = 0; k < nSegs; k++ ) {
   1c8d2:	f108 0801 	add.w	r8, r8, #1
            pitch_res_ptr += nSamples;
   1c8d6:	4416      	add	r6, r2
        for( k = 0; k < nSegs; k++ ) {
   1c8d8:	4545      	cmp	r5, r8
            silk_sum_sqr_shift( &nrg, &scale, pitch_res_ptr, nSamples );
   1c8da:	464b      	mov	r3, r9
   1c8dc:	f107 017c 	add.w	r1, r7, #124	; 0x7c
   1c8e0:	4658      	mov	r0, fp
   1c8e2:	4632      	mov	r2, r6
        for( k = 0; k < nSegs; k++ ) {
   1c8e4:	d1e1      	bne.n	1c8aa <silk_noise_shape_analysis_FIX+0x166>
        }

        /* Set quantization offset depending on sparseness measure */
        if( energy_variation_Q7 > SILK_FIX_CONST( ENERGY_VARIATION_THRESHOLD_QNT_OFFSET, 7 ) * (nSegs-1) ) {
   1c8e6:	3d01      	subs	r5, #1
   1c8e8:	234d      	movs	r3, #77	; 0x4d
   1c8ea:	fb03 f305 	mul.w	r3, r3, r5
   1c8ee:	4553      	cmp	r3, sl
            psEnc->sCmn.indices.quantOffsetType = 0;
   1c8f0:	f241 229e 	movw	r2, #4766	; 0x129e
        } else {
            psEnc->sCmn.indices.quantOffsetType = 1;
   1c8f4:	6bb8      	ldr	r0, [r7, #56]	; 0x38
            psEnc->sCmn.indices.quantOffsetType = 0;
   1c8f6:	bfb4      	ite	lt
   1c8f8:	2100      	movlt	r1, #0
            psEnc->sCmn.indices.quantOffsetType = 1;
   1c8fa:	2101      	movge	r1, #1
   1c8fc:	f241 13e4 	movw	r3, #4580	; 0x11e4
   1c900:	5481      	strb	r1, [r0, r2]
   1c902:	58c2      	ldr	r2, [r0, r3]

    /*******************************/
    /* Control bandwidth expansion */
    /*******************************/
    /* More BWE for signals with high prediction gain */
    strength_Q16 = silk_SMULWB( psEncCtrl->predGain_Q16, SILK_FIX_CONST( FIND_PITCH_WHITE_NOISE_FRACTION, 16 ) );
   1c904:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1c906:	f8d3 0188 	ldr.w	r0, [r3, #392]	; 0x188
   1c90a:	1403      	asrs	r3, r0, #16
   1c90c:	eb03 1343 	add.w	r3, r3, r3, lsl #5
   1c910:	b280      	uxth	r0, r0
   1c912:	005b      	lsls	r3, r3, #1
   1c914:	eb00 1040 	add.w	r0, r0, r0, lsl #5
   1c918:	eb03 31d0 	add.w	r1, r3, r0, lsr #15
    BWExp_Q16 = silk_DIV32_varQ( SILK_FIX_CONST( BANDWIDTH_EXPANSION, 16 ),
        silk_SMLAWW( SILK_FIX_CONST( 1.0, 16 ), strength_Q16, strength_Q16 ), 16 );
   1c91c:	b20b      	sxth	r3, r1
   1c91e:	b288      	uxth	r0, r1
   1c920:	140d      	asrs	r5, r1, #16
   1c922:	fb03 f400 	mul.w	r4, r3, r0
   1c926:	fb03 f005 	mul.w	r0, r3, r5
   1c92a:	13cb      	asrs	r3, r1, #15
   1c92c:	eb00 4024 	add.w	r0, r0, r4, asr #16
   1c930:	3301      	adds	r3, #1
   1c932:	f500 3080 	add.w	r0, r0, #65536	; 0x10000
   1c936:	105b      	asrs	r3, r3, #1
    BWExp_Q16 = silk_DIV32_varQ( SILK_FIX_CONST( BANDWIDTH_EXPANSION, 16 ),
   1c938:	fb01 0303 	mla	r3, r1, r3, r0
   1c93c:	2b00      	cmp	r3, #0
   1c93e:	f000 85cc 	beq.w	1d4da <silk_noise_shape_analysis_FIX+0xd96>
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
   1c942:	ea83 70e3 	eor.w	r0, r3, r3, asr #31
   1c946:	eba0 70e3 	sub.w	r0, r0, r3, asr #31
   1c94a:	fab0 f080 	clz	r0, r0
   1c94e:	3801      	subs	r0, #1
   1c950:	f1c0 041c 	rsb	r4, r0, #28
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                  */
   1c954:	fa03 f000 	lsl.w	r0, r3, r0
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1c958:	1401      	asrs	r1, r0, #16
   1c95a:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1c95e:	f647 0552 	movw	r5, #30802	; 0x7852
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1c962:	fb93 f3f1 	sdiv	r3, r3, r1
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1c966:	b21b      	sxth	r3, r3
   1c968:	fb13 f505 	smulbb	r5, r3, r5
    a32_nrm = silk_SUB32_ovflw(a32_nrm, silk_LSHIFT_ovflw( silk_SMMUL(b32_nrm, result), 3 ));  /* Q: a_headrm   */
   1c96c:	4ece      	ldr	r6, [pc, #824]	; (1cca8 <silk_noise_shape_analysis_FIX+0x564>)
   1c96e:	fb80 0105 	smull	r0, r1, r0, r5
   1c972:	eba6 01c1 	sub.w	r1, r6, r1, lsl #3
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1c976:	b288      	uxth	r0, r1
   1c978:	1409      	asrs	r1, r1, #16
   1c97a:	fb03 f000 	mul.w	r0, r3, r0
   1c97e:	fb03 f301 	mul.w	r3, r3, r1
   1c982:	eb03 4320 	add.w	r3, r3, r0, asr #16
    if( lshift < 0 ) {
   1c986:	2c00      	cmp	r4, #0
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1c988:	442b      	add	r3, r5
    if( lshift < 0 ) {
   1c98a:	f2c0 85bb 	blt.w	1d504 <silk_noise_shape_analysis_FIX+0xdc0>
            return silk_RSHIFT(result, lshift);
   1c98e:	4123      	asrs	r3, r4
   1c990:	613b      	str	r3, [r7, #16]

    if( psEnc->sCmn.warping_Q16 > 0 ) {
   1c992:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1c994:	f503 5392 	add.w	r3, r3, #4672	; 0x1240
   1c998:	65bb      	str	r3, [r7, #88]	; 0x58
   1c99a:	6818      	ldr	r0, [r3, #0]
   1c99c:	2800      	cmp	r0, #0
   1c99e:	f340 85a9 	ble.w	1d4f4 <silk_noise_shape_analysis_FIX+0xdb0>
        /* Slightly more warping in analysis will move quantization noise up in frequency, where it's better masked */
        warping_Q16 = silk_SMLAWB( psEnc->sCmn.warping_Q16, (opus_int32)psEncCtrl->coding_quality_Q14, SILK_FIX_CONST( 0.01, 18 ) );
   1c9a2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1c9a4:	f8d3 1184 	ldr.w	r1, [r3, #388]	; 0x184
   1c9a8:	f640 233d 	movw	r3, #2621	; 0xa3d
   1c9ac:	b28c      	uxth	r4, r1
   1c9ae:	1409      	asrs	r1, r1, #16
   1c9b0:	fb03 f404 	mul.w	r4, r3, r4
   1c9b4:	fb03 f301 	mul.w	r3, r3, r1
   1c9b8:	eb03 4314 	add.w	r3, r3, r4, lsr #16
   1c9bc:	4403      	add	r3, r0
   1c9be:	60fb      	str	r3, [r7, #12]
    }

    /********************************************/
    /* Compute noise shaping AR coefs and gains */
    /********************************************/
    ALLOC( x_windowed, psEnc->sCmn.shapeWinLength, opus_int16 );
   1c9c0:	f241 13fc 	movw	r3, #4604	; 0x11fc
   1c9c4:	6bb9      	ldr	r1, [r7, #56]	; 0x38
   1c9c6:	58cd      	ldr	r5, [r1, r3]
   1c9c8:	006b      	lsls	r3, r5, #1
   1c9ca:	3308      	adds	r3, #8
   1c9cc:	f023 0307 	bic.w	r3, r3, #7
   1c9d0:	ebad 0d03 	sub.w	sp, sp, r3
   1c9d4:	ab02      	add	r3, sp, #8
    for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1c9d6:	2a00      	cmp	r2, #0
    ALLOC( x_windowed, psEnc->sCmn.shapeWinLength, opus_int16 );
   1c9d8:	663b      	str	r3, [r7, #96]	; 0x60
    for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1c9da:	f340 83ef 	ble.w	1d1bc <silk_noise_shape_analysis_FIX+0xa78>
    lambda_Q16 = -lambda_Q16;
   1c9de:	68f8      	ldr	r0, [r7, #12]
   1c9e0:	4242      	negs	r2, r0
    nom_Q16  = silk_SMLAWB( SILK_FIX_CONST( 1.0, 16 ), -(opus_int32)lambda_Q16, lambda_Q16 );
   1c9e2:	fa0f f980 	sxth.w	r9, r0
   1c9e6:	1413      	asrs	r3, r2, #16
    lambda_Q16 = -lambda_Q16;
   1c9e8:	667a      	str	r2, [r7, #100]	; 0x64
    nom_Q16  = silk_SMLAWB( SILK_FIX_CONST( 1.0, 16 ), -(opus_int32)lambda_Q16, lambda_Q16 );
   1c9ea:	fb09 f303 	mul.w	r3, r9, r3
   1c9ee:	b292      	uxth	r2, r2
   1c9f0:	f501 508f 	add.w	r0, r1, #4576	; 0x11e0
   1c9f4:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
   1c9f8:	fb09 f202 	mul.w	r2, r9, r2
   1c9fc:	eb03 4222 	add.w	r2, r3, r2, asr #16
   1ca00:	4603      	mov	r3, r0
    a_headrm = silk_CLZ32( silk_abs(a32) ) - 1;
   1ca02:	2a00      	cmp	r2, #0
   1ca04:	f103 031c 	add.w	r3, r3, #28
   1ca08:	617a      	str	r2, [r7, #20]
   1ca0a:	62bb      	str	r3, [r7, #40]	; 0x28
   1ca0c:	bfb8      	it	lt
   1ca0e:	4252      	neglt	r2, r2
   1ca10:	1d03      	adds	r3, r0, #4
   1ca12:	f501 5490 	add.w	r4, r1, #4608	; 0x1200
   1ca16:	603a      	str	r2, [r7, #0]
   1ca18:	61fb      	str	r3, [r7, #28]
   1ca1a:	f100 020c 	add.w	r2, r0, #12
   1ca1e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1ca20:	61ba      	str	r2, [r7, #24]
   1ca22:	f104 021c 	add.w	r2, r4, #28
   1ca26:	66fa      	str	r2, [r7, #108]	; 0x6c
   1ca28:	461a      	mov	r2, r3
   1ca2a:	3b04      	subs	r3, #4
   1ca2c:	647b      	str	r3, [r7, #68]	; 0x44
    for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1ca2e:	2300      	movs	r3, #0
   1ca30:	328c      	adds	r2, #140	; 0x8c
   1ca32:	62fb      	str	r3, [r7, #44]	; 0x2c
   1ca34:	f107 0380 	add.w	r3, r7, #128	; 0x80
   1ca38:	657a      	str	r2, [r7, #84]	; 0x54
   1ca3a:	627b      	str	r3, [r7, #36]	; 0x24
   1ca3c:	f107 08e4 	add.w	r8, r7, #228	; 0xe4
        /* Apply window: sine slope followed by flat part followed by cosine slope */
        opus_int shift, slope_part, flat_part;
        flat_part = psEnc->sCmn.fs_kHz * 3;
   1ca40:	6a3b      	ldr	r3, [r7, #32]
        slope_part = silk_RSHIFT( psEnc->sCmn.shapeWinLength - flat_part, 1 );

        silk_apply_sine_window( x_windowed, x_ptr, 1, slope_part );
   1ca42:	6b3e      	ldr	r6, [r7, #48]	; 0x30
        flat_part = psEnc->sCmn.fs_kHz * 3;
   1ca44:	681c      	ldr	r4, [r3, #0]
        silk_apply_sine_window( x_windowed, x_ptr, 1, slope_part );
   1ca46:	f8d7 a060 	ldr.w	sl, [r7, #96]	; 0x60
        flat_part = psEnc->sCmn.fs_kHz * 3;
   1ca4a:	eb04 0444 	add.w	r4, r4, r4, lsl #1
        slope_part = silk_RSHIFT( psEnc->sCmn.shapeWinLength - flat_part, 1 );
   1ca4e:	1b2d      	subs	r5, r5, r4
   1ca50:	106d      	asrs	r5, r5, #1
        silk_apply_sine_window( x_windowed, x_ptr, 1, slope_part );
   1ca52:	462b      	mov	r3, r5
   1ca54:	2201      	movs	r2, #1
   1ca56:	4631      	mov	r1, r6
   1ca58:	4650      	mov	r0, sl
   1ca5a:	f001 f98d 	bl	1dd78 <silk_apply_sine_window>
        shift = slope_part;
        silk_memcpy( x_windowed + shift, x_ptr + shift, flat_part * sizeof(opus_int16) );
   1ca5e:	0068      	lsls	r0, r5, #1
   1ca60:	1831      	adds	r1, r6, r0
   1ca62:	0062      	lsls	r2, r4, #1
   1ca64:	4450      	add	r0, sl
   1ca66:	f8c7 a060 	str.w	sl, [r7, #96]	; 0x60
   1ca6a:	f7ef fb49 	bl	c100 <memcpy>
        shift += flat_part;
        silk_apply_sine_window( x_windowed + shift, x_ptr + shift, 2, slope_part );
   1ca6e:	462b      	mov	r3, r5
        shift += flat_part;
   1ca70:	1960      	adds	r0, r4, r5
        silk_apply_sine_window( x_windowed + shift, x_ptr + shift, 2, slope_part );
   1ca72:	6e3d      	ldr	r5, [r7, #96]	; 0x60
   1ca74:	0040      	lsls	r0, r0, #1
   1ca76:	1831      	adds	r1, r6, r0
   1ca78:	2202      	movs	r2, #2
   1ca7a:	4428      	add	r0, r5
   1ca7c:	f001 f97c 	bl	1dd78 <silk_apply_sine_window>

        /* Update pointer: next LPC analysis block */
        x_ptr += psEnc->sCmn.subfr_length;
   1ca80:	69bb      	ldr	r3, [r7, #24]
   1ca82:	681a      	ldr	r2, [r3, #0]

        if( psEnc->sCmn.warping_Q16 > 0 ) {
   1ca84:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   1ca86:	681b      	ldr	r3, [r3, #0]
   1ca88:	2b00      	cmp	r3, #0
            /* Calculate warped auto correlation */
            silk_warped_autocorrelation_FIX( auto_corr, &scale, x_windowed, warping_Q16, psEnc->sCmn.shapeWinLength, psEnc->sCmn.shapingLPCOrder, arch );
   1ca8a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
        x_ptr += psEnc->sCmn.subfr_length;
   1ca8c:	eb06 0242 	add.w	r2, r6, r2, lsl #1
   1ca90:	633a      	str	r2, [r7, #48]	; 0x30
            silk_warped_autocorrelation_FIX( auto_corr, &scale, x_windowed, warping_Q16, psEnc->sCmn.shapeWinLength, psEnc->sCmn.shapingLPCOrder, arch );
   1ca92:	681a      	ldr	r2, [r3, #0]
   1ca94:	6abb      	ldr	r3, [r7, #40]	; 0x28
   1ca96:	681b      	ldr	r3, [r3, #0]
        if( psEnc->sCmn.warping_Q16 > 0 ) {
   1ca98:	f340 835f 	ble.w	1d15a <silk_noise_shape_analysis_FIX+0xa16>
            silk_warped_autocorrelation_FIX( auto_corr, &scale, x_windowed, warping_Q16, psEnc->sCmn.shapeWinLength, psEnc->sCmn.shapingLPCOrder, arch );
   1ca9c:	e9cd 3200 	strd	r3, r2, [sp]
   1caa0:	f107 017c 	add.w	r1, r7, #124	; 0x7c
   1caa4:	68fb      	ldr	r3, [r7, #12]
   1caa6:	462a      	mov	r2, r5
   1caa8:	f507 70a2 	add.w	r0, r7, #324	; 0x144
   1caac:	f001 f870 	bl	1db90 <silk_warped_autocorrelation_FIX_c>
            /* Calculate regular auto correlation */
            silk_autocorr( auto_corr, &scale, x_windowed, psEnc->sCmn.shapeWinLength, psEnc->sCmn.shapingLPCOrder + 1, arch );
        }

        /* Add white noise, as a fraction of energy */
        auto_corr[0] = silk_ADD32( auto_corr[0], silk_max_32( silk_SMULWB( silk_RSHIFT( auto_corr[ 0 ], 4 ),
   1cab0:	f8d7 1144 	ldr.w	r1, [r7, #324]	; 0x144
            SILK_FIX_CONST( SHAPE_WHITE_NOISE_FRACTION, 20 ) ), 1 ) );

        /* Calculate the reflection coefficients using schur */
        nrg = silk_schur64( refl_coef_Q16, auto_corr, psEnc->sCmn.shapingLPCOrder );
   1cab4:	6efc      	ldr	r4, [r7, #108]	; 0x6c
        auto_corr[0] = silk_ADD32( auto_corr[0], silk_max_32( silk_SMULWB( silk_RSHIFT( auto_corr[ 0 ], 4 ),
   1cab6:	f3c1 100f 	ubfx	r0, r1, #4, #16
   1caba:	150b      	asrs	r3, r1, #20
   1cabc:	ebc0 1040 	rsb	r0, r0, r0, lsl #5
   1cac0:	ebc3 1343 	rsb	r3, r3, r3, lsl #5
   1cac4:	eb03 4320 	add.w	r3, r3, r0, asr #16
   1cac8:	2b01      	cmp	r3, #1
   1caca:	bfac      	ite	ge
   1cacc:	18cb      	addge	r3, r1, r3
   1cace:	1c4b      	addlt	r3, r1, #1
        nrg = silk_schur64( refl_coef_Q16, auto_corr, psEnc->sCmn.shapingLPCOrder );
   1cad0:	6822      	ldr	r2, [r4, #0]
        auto_corr[0] = silk_ADD32( auto_corr[0], silk_max_32( silk_SMULWB( silk_RSHIFT( auto_corr[ 0 ], 4 ),
   1cad2:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144
        nrg = silk_schur64( refl_coef_Q16, auto_corr, psEnc->sCmn.shapingLPCOrder );
   1cad6:	f507 71a2 	add.w	r1, r7, #324	; 0x144
   1cada:	f107 0084 	add.w	r0, r7, #132	; 0x84
   1cade:	f003 f969 	bl	1fdb4 <silk_schur64>
        silk_assert( nrg >= 0 );

        /* Convert reflection coefficients to prediction coefficients */
        silk_k2a_Q16( AR_Q24, refl_coef_Q16, psEnc->sCmn.shapingLPCOrder );
   1cae2:	6822      	ldr	r2, [r4, #0]
        nrg = silk_schur64( refl_coef_Q16, auto_corr, psEnc->sCmn.shapingLPCOrder );
   1cae4:	6a7c      	ldr	r4, [r7, #36]	; 0x24
        silk_k2a_Q16( AR_Q24, refl_coef_Q16, psEnc->sCmn.shapingLPCOrder );
   1cae6:	f107 0184 	add.w	r1, r7, #132	; 0x84
        nrg = silk_schur64( refl_coef_Q16, auto_corr, psEnc->sCmn.shapingLPCOrder );
   1caea:	6020      	str	r0, [r4, #0]
        silk_k2a_Q16( AR_Q24, refl_coef_Q16, psEnc->sCmn.shapingLPCOrder );
   1caec:	4640      	mov	r0, r8
   1caee:	f001 ffa7 	bl	1ea40 <silk_k2a_Q16>

        Qnrg = -scale;          /* range: -12...30*/
   1caf2:	6ff9      	ldr	r1, [r7, #124]	; 0x7c
   1caf4:	424a      	negs	r2, r1
        silk_assert( Qnrg >= -12 );
        silk_assert( Qnrg <=  30 );

        /* Make sure that Qnrg is an even number */
        if( Qnrg & 1 ) {
   1caf6:	07d0      	lsls	r0, r2, #31
   1caf8:	f100 831a 	bmi.w	1d130 <silk_noise_shape_analysis_FIX+0x9ec>
   1cafc:	6823      	ldr	r3, [r4, #0]
    if( x <= 0 ) {
   1cafe:	2b00      	cmp	r3, #0
   1cb00:	f340 831f 	ble.w	1d142 <silk_noise_shape_analysis_FIX+0x9fe>
   1cb04:	fab3 f083 	clz	r0, r3
    * frac_Q7 = silk_ROR32(in, 24 - lzeros) & 0x7f;
   1cb08:	f1c0 0118 	rsb	r1, r0, #24
    if( rot == 0 ) {
   1cb0c:	2900      	cmp	r1, #0
   1cb0e:	d002      	beq.n	1cb16 <silk_noise_shape_analysis_FIX+0x3d2>
        return (opus_int32) ((x << m) | (x >> (32 - m)));
   1cb10:	bfb8      	it	lt
   1cb12:	3120      	addlt	r1, #32
        return (opus_int32) ((x << (32 - r)) | (x >> r));
   1cb14:	41cb      	rors	r3, r1
   1cb16:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   1cb1a:	eb03 04c3 	add.w	r4, r3, r3, lsl #3
        y = 32768;
   1cb1e:	f010 0f01 	tst.w	r0, #1
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   1cb22:	ebc3 03c4 	rsb	r3, r3, r4, lsl #3
        y = 32768;
   1cb26:	f24b 4186 	movw	r1, #46214	; 0xb486
    y >>= silk_RSHIFT(lz, 1);
   1cb2a:	ea4f 0060 	mov.w	r0, r0, asr #1
        y = 32768;
   1cb2e:	bf18      	it	ne
   1cb30:	f44f 4100 	movne.w	r1, #32768	; 0x8000
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   1cb34:	ebc3 0383 	rsb	r3, r3, r3, lsl #2
    y >>= silk_RSHIFT(lz, 1);
   1cb38:	4101      	asrs	r1, r0
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   1cb3a:	b29b      	uxth	r3, r3
   1cb3c:	fb01 f303 	mul.w	r3, r1, r3
   1cb40:	eb01 4323 	add.w	r3, r1, r3, asr #16
            Qnrg -= 1;
            nrg >>= 1;
        }

        tmp32 = silk_SQRT_APPROX( nrg );
        Qnrg >>= 1;             /* range: -6...15*/
   1cb44:	1052      	asrs	r2, r2, #1

        psEncCtrl->Gains_Q16[ k ] = silk_LSHIFT_SAT32( tmp32, 16 - Qnrg );
   1cb46:	f1c2 0210 	rsb	r2, r2, #16
   1cb4a:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
   1cb4e:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   1cb52:	4111      	asrs	r1, r2
   1cb54:	4110      	asrs	r0, r2
   1cb56:	4281      	cmp	r1, r0
   1cb58:	f340 82e0 	ble.w	1d11c <silk_noise_shape_analysis_FIX+0x9d8>
   1cb5c:	4299      	cmp	r1, r3
   1cb5e:	f280 8329 	bge.w	1d1b4 <silk_noise_shape_analysis_FIX+0xa70>
   1cb62:	460b      	mov	r3, r1

        if( psEnc->sCmn.warping_Q16 > 0 ) {
   1cb64:	6db9      	ldr	r1, [r7, #88]	; 0x58
        psEncCtrl->Gains_Q16[ k ] = silk_LSHIFT_SAT32( tmp32, 16 - Qnrg );
   1cb66:	4093      	lsls	r3, r2
        if( psEnc->sCmn.warping_Q16 > 0 ) {
   1cb68:	6808      	ldr	r0, [r1, #0]
        psEncCtrl->Gains_Q16[ k ] = silk_LSHIFT_SAT32( tmp32, 16 - Qnrg );
   1cb6a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   1cb6c:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
   1cb6e:	6809      	ldr	r1, [r1, #0]
   1cb70:	f842 3f04 	str.w	r3, [r2, #4]!
        if( psEnc->sCmn.warping_Q16 > 0 ) {
   1cb74:	2800      	cmp	r0, #0
        psEncCtrl->Gains_Q16[ k ] = silk_LSHIFT_SAT32( tmp32, 16 - Qnrg );
   1cb76:	647a      	str	r2, [r7, #68]	; 0x44
        if( psEnc->sCmn.warping_Q16 > 0 ) {
   1cb78:	dd6d      	ble.n	1cc56 <silk_noise_shape_analysis_FIX+0x512>
    gain_Q24 = coefs_Q24[ order - 1 ];
   1cb7a:	f101 4280 	add.w	r2, r1, #1073741824	; 0x40000000
   1cb7e:	3a01      	subs	r2, #1
    for( i = order - 2; i >= 0; i-- ) {
   1cb80:	2901      	cmp	r1, #1
    gain_Q24 = coefs_Q24[ order - 1 ];
   1cb82:	eb08 0582 	add.w	r5, r8, r2, lsl #2
   1cb86:	f858 0022 	ldr.w	r0, [r8, r2, lsl #2]
    for( i = order - 2; i >= 0; i-- ) {
   1cb8a:	dd0e      	ble.n	1cbaa <silk_noise_shape_analysis_FIX+0x466>
   1cb8c:	f9b7 6064 	ldrsh.w	r6, [r7, #100]	; 0x64
        gain_Q24 = silk_SMLAWB( coefs_Q24[ i ], gain_Q24, lambda_Q16 );
   1cb90:	f855 4d04 	ldr.w	r4, [r5, #-4]!
   1cb94:	b282      	uxth	r2, r0
   1cb96:	1400      	asrs	r0, r0, #16
   1cb98:	fb06 f202 	mul.w	r2, r6, r2
   1cb9c:	fb06 f000 	mul.w	r0, r6, r0
   1cba0:	eb00 4022 	add.w	r0, r0, r2, asr #16
    for( i = order - 2; i >= 0; i-- ) {
   1cba4:	45a8      	cmp	r8, r5
        gain_Q24 = silk_SMLAWB( coefs_Q24[ i ], gain_Q24, lambda_Q16 );
   1cba6:	4420      	add	r0, r4
    for( i = order - 2; i >= 0; i-- ) {
   1cba8:	d1f2      	bne.n	1cb90 <silk_noise_shape_analysis_FIX+0x44c>
    gain_Q24  = silk_SMLAWB( SILK_FIX_CONST( 1.0, 24 ), gain_Q24, -lambda_Q16 );
   1cbaa:	6e7a      	ldr	r2, [r7, #100]	; 0x64
   1cbac:	4252      	negs	r2, r2
   1cbae:	b212      	sxth	r2, r2
   1cbb0:	b284      	uxth	r4, r0
   1cbb2:	1400      	asrs	r0, r0, #16
   1cbb4:	fb02 f404 	mul.w	r4, r2, r4
   1cbb8:	fb02 f000 	mul.w	r0, r2, r0
   1cbbc:	eb00 4024 	add.w	r0, r0, r4, asr #16
   1cbc0:	f110 7280 	adds.w	r2, r0, #16777216	; 0x1000000
   1cbc4:	f000 82ee 	beq.w	1d1a4 <silk_noise_shape_analysis_FIX+0xa60>
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
   1cbc8:	ea82 70e2 	eor.w	r0, r2, r2, asr #31
   1cbcc:	eba0 70e2 	sub.w	r0, r0, r2, asr #31
   1cbd0:	fab0 f080 	clz	r0, r0
   1cbd4:	3801      	subs	r0, #1
   1cbd6:	f1c0 0e15 	rsb	lr, r0, #21
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                */
   1cbda:	4082      	lsls	r2, r0
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm    */
   1cbdc:	1410      	asrs	r0, r2, #16
   1cbde:	f06f 4560 	mvn.w	r5, #3758096384	; 0xe0000000
    err_Q32 = silk_LSHIFT( ((opus_int32)1<<29) - silk_SMULWB(b32_nrm, b32_inv), 3 );        /* Q32                        */
   1cbe2:	b292      	uxth	r2, r2
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm    */
   1cbe4:	fb95 f5f0 	sdiv	r5, r5, r0
    err_Q32 = silk_LSHIFT( ((opus_int32)1<<29) - silk_SMULWB(b32_nrm, b32_inv), 3 );        /* Q32                        */
   1cbe8:	b22e      	sxth	r6, r5
   1cbea:	fb06 f202 	mul.w	r2, r6, r2
   1cbee:	fb06 f000 	mul.w	r0, r6, r0
   1cbf2:	eb00 4022 	add.w	r0, r0, r2, asr #16
   1cbf6:	f1c0 5000 	rsb	r0, r0, #536870912	; 0x20000000
   1cbfa:	00c0      	lsls	r0, r0, #3
    result = silk_SMLAWW(result, err_Q32, b32_inv);                             /* Q: 61 - b_headrm            */
   1cbfc:	fa1f fc80 	uxth.w	ip, r0
   1cc00:	1402      	asrs	r2, r0, #16
   1cc02:	13ec      	asrs	r4, r5, #15
   1cc04:	fb06 fc0c 	mul.w	ip, r6, ip
   1cc08:	fb06 f202 	mul.w	r2, r6, r2
   1cc0c:	3401      	adds	r4, #1
   1cc0e:	eb02 422c 	add.w	r2, r2, ip, asr #16
   1cc12:	1064      	asrs	r4, r4, #1
   1cc14:	eb02 4205 	add.w	r2, r2, r5, lsl #16
    if( lshift <= 0 ) {
   1cc18:	f1be 0f00 	cmp.w	lr, #0
    result = silk_SMLAWW(result, err_Q32, b32_inv);                             /* Q: 61 - b_headrm            */
   1cc1c:	fb00 2404 	mla	r4, r0, r4, r2
    if( lshift <= 0 ) {
   1cc20:	f340 8429 	ble.w	1d476 <silk_noise_shape_analysis_FIX+0xd32>
            return silk_RSHIFT(result, lshift);
   1cc24:	fa44 fe0e 	asr.w	lr, r4, lr
   1cc28:	ea4f 32ee 	mov.w	r2, lr, asr #15
   1cc2c:	3201      	adds	r2, #1
            /* Adjust gain for warping */
            gain_mult_Q16 = warped_gain( AR_Q24, warping_Q16, psEnc->sCmn.shapingLPCOrder );
            silk_assert( psEncCtrl->Gains_Q16[ k ] > 0 );
            if( psEncCtrl->Gains_Q16[ k ] < SILK_FIX_CONST( 0.25, 16 ) ) {
   1cc2e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
   1cc32:	ea4f 0262 	mov.w	r2, r2, asr #1
   1cc36:	fa0f fe8e 	sxth.w	lr, lr
   1cc3a:	f280 829b 	bge.w	1d174 <silk_noise_shape_analysis_FIX+0xa30>
                psEncCtrl->Gains_Q16[ k ] = silk_SMULWW( psEncCtrl->Gains_Q16[ k ], gain_mult_Q16 );
   1cc3e:	b298      	uxth	r0, r3
   1cc40:	141c      	asrs	r4, r3, #16
   1cc42:	fb0e f000 	mul.w	r0, lr, r0
   1cc46:	fb0e fe04 	mul.w	lr, lr, r4
   1cc4a:	eb0e 4e20 	add.w	lr, lr, r0, asr #16
   1cc4e:	fb02 e303 	mla	r3, r2, r3, lr
   1cc52:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   1cc54:	6013      	str	r3, [r2, #0]
            }
            silk_assert( psEncCtrl->Gains_Q16[ k ] > 0 );
        }

        /* Bandwidth expansion */
        silk_bwexpander_32( AR_Q24, psEnc->sCmn.shapingLPCOrder, BWExp_Q16 );
   1cc56:	693a      	ldr	r2, [r7, #16]
   1cc58:	4640      	mov	r0, r8
   1cc5a:	f7fa fe31 	bl	178c0 <silk_bwexpander_32>

        if( psEnc->sCmn.warping_Q16 > 0 ) {
   1cc5e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   1cc60:	681b      	ldr	r3, [r3, #0]
   1cc62:	2b00      	cmp	r3, #0
            /* Convert to monic warped prediction coefficients and limit absolute values */
            limit_warped_coefs( AR_Q24, warping_Q16, SILK_FIX_CONST( 3.999, 24 ), psEnc->sCmn.shapingLPCOrder );
   1cc64:	6efb      	ldr	r3, [r7, #108]	; 0x6c
        if( psEnc->sCmn.warping_Q16 > 0 ) {
   1cc66:	f340 8250 	ble.w	1d10a <silk_noise_shape_analysis_FIX+0x9c6>
            limit_warped_coefs( AR_Q24, warping_Q16, SILK_FIX_CONST( 3.999, 24 ), psEnc->sCmn.shapingLPCOrder );
   1cc6a:	681e      	ldr	r6, [r3, #0]
    for( i = order - 1; i > 0; i-- ) {
   1cc6c:	1e73      	subs	r3, r6, #1
   1cc6e:	2b00      	cmp	r3, #0
   1cc70:	653b      	str	r3, [r7, #80]	; 0x50
   1cc72:	ea4f 0586 	mov.w	r5, r6, lsl #2
   1cc76:	dd19      	ble.n	1ccac <silk_noise_shape_analysis_FIX+0x568>
   1cc78:	f507 73d4 	add.w	r3, r7, #424	; 0x1a8
   1cc7c:	442b      	add	r3, r5
   1cc7e:	1f28      	subs	r0, r5, #4
   1cc80:	f853 2cc8 	ldr.w	r2, [r3, #-200]
   1cc84:	f9b7 4064 	ldrsh.w	r4, [r7, #100]	; 0x64
   1cc88:	4440      	add	r0, r8
        coefs_Q24[ i - 1 ] = silk_SMLAWB( coefs_Q24[ i - 1 ], coefs_Q24[ i ], lambda_Q16 );
   1cc8a:	b293      	uxth	r3, r2
   1cc8c:	1412      	asrs	r2, r2, #16
   1cc8e:	f850 1d04 	ldr.w	r1, [r0, #-4]!
   1cc92:	fb04 f303 	mul.w	r3, r4, r3
   1cc96:	fb04 f202 	mul.w	r2, r4, r2
   1cc9a:	eb02 4223 	add.w	r2, r2, r3, asr #16
   1cc9e:	440a      	add	r2, r1
    for( i = order - 1; i > 0; i-- ) {
   1cca0:	4580      	cmp	r8, r0
        coefs_Q24[ i - 1 ] = silk_SMLAWB( coefs_Q24[ i - 1 ], coefs_Q24[ i ], lambda_Q16 );
   1cca2:	6002      	str	r2, [r0, #0]
    for( i = order - 1; i > 0; i-- ) {
   1cca4:	d1f1      	bne.n	1cc8a <silk_noise_shape_analysis_FIX+0x546>
   1cca6:	e001      	b.n	1ccac <silk_noise_shape_analysis_FIX+0x568>
   1cca8:	78520000 	.word	0x78520000
    den_Q24  = silk_SMLAWB( SILK_FIX_CONST( 1.0, 24 ), coefs_Q24[ 0 ], lambda_Q16 );
   1ccac:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
   1ccb0:	b291      	uxth	r1, r2
   1ccb2:	1412      	asrs	r2, r2, #16
   1ccb4:	fb09 f301 	mul.w	r3, r9, r1
   1ccb8:	fb09 f202 	mul.w	r2, r9, r2
   1ccbc:	eb02 4223 	add.w	r2, r2, r3, asr #16
   1ccc0:	697b      	ldr	r3, [r7, #20]
   1ccc2:	f102 7280 	add.w	r2, r2, #16777216	; 0x1000000
   1ccc6:	2b00      	cmp	r3, #0
   1ccc8:	f000 83c7 	beq.w	1d45a <silk_noise_shape_analysis_FIX+0xd16>
   1cccc:	683b      	ldr	r3, [r7, #0]
   1ccce:	fab3 f183 	clz	r1, r3
   1ccd2:	1e4b      	subs	r3, r1, #1
   1ccd4:	311c      	adds	r1, #28
   1ccd6:	65f9      	str	r1, [r7, #92]	; 0x5c
    a32_nrm = silk_LSHIFT(a32, a_headrm);                                       /* Q: a_headrm                  */
   1ccd8:	6979      	ldr	r1, [r7, #20]
   1ccda:	fa01 f303 	lsl.w	r3, r1, r3
   1ccde:	66bb      	str	r3, [r7, #104]	; 0x68
   1cce0:	2a00      	cmp	r2, #0
   1cce2:	f000 83c4 	beq.w	1d46e <silk_noise_shape_analysis_FIX+0xd2a>
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
   1cce6:	ea82 71e2 	eor.w	r1, r2, r2, asr #31
   1ccea:	eba1 71e2 	sub.w	r1, r1, r2, asr #31
   1ccee:	fab1 f181 	clz	r1, r1
   1ccf2:	f101 3cff 	add.w	ip, r1, #4294967295	; 0xffffffff
   1ccf6:	4619      	mov	r1, r3
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                  */
   1ccf8:	fa02 f20c 	lsl.w	r2, r2, ip
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1ccfc:	1413      	asrs	r3, r2, #16
   1ccfe:	f06f 4060 	mvn.w	r0, #3758096384	; 0xe0000000
   1cd02:	fb90 f0f3 	sdiv	r0, r0, r3
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1cd06:	140b      	asrs	r3, r1, #16
   1cd08:	b28c      	uxth	r4, r1
   1cd0a:	b200      	sxth	r0, r0
   1cd0c:	4619      	mov	r1, r3
   1cd0e:	64bc      	str	r4, [r7, #72]	; 0x48
   1cd10:	64fb      	str	r3, [r7, #76]	; 0x4c
   1cd12:	fb04 f300 	mul.w	r3, r4, r0
   1cd16:	460c      	mov	r4, r1
   1cd18:	fb00 f404 	mul.w	r4, r0, r4
   1cd1c:	eb04 4423 	add.w	r4, r4, r3, asr #16
    a32_nrm = silk_SUB32_ovflw(a32_nrm, silk_LSHIFT_ovflw( silk_SMMUL(b32_nrm, result), 3 ));  /* Q: a_headrm   */
   1cd20:	6eb9      	ldr	r1, [r7, #104]	; 0x68
   1cd22:	fb82 2304 	smull	r2, r3, r2, r4
   1cd26:	eba1 03c3 	sub.w	r3, r1, r3, lsl #3
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1cd2a:	b29a      	uxth	r2, r3
   1cd2c:	141b      	asrs	r3, r3, #16
   1cd2e:	fb00 f202 	mul.w	r2, r0, r2
   1cd32:	fb00 f003 	mul.w	r0, r0, r3
    lshift = 29 + a_headrm - b_headrm - Qres;
   1cd36:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   1cd38:	eba3 010c 	sub.w	r1, r3, ip
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1cd3c:	eb00 4022 	add.w	r0, r0, r2, asr #16
    if( lshift < 0 ) {
   1cd40:	f1b1 0218 	subs.w	r2, r1, #24
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1cd44:	4420      	add	r0, r4
    if( lshift < 0 ) {
   1cd46:	f100 83b9 	bmi.w	1d4bc <silk_noise_shape_analysis_FIX+0xd78>
        if( lshift < 32){
   1cd4a:	2a1f      	cmp	r2, #31
            return silk_RSHIFT(result, lshift);
   1cd4c:	bfd4      	ite	le
   1cd4e:	fa40 f202 	asrle.w	r2, r0, r2
            return 0;
   1cd52:	2200      	movgt	r2, #0
    for( i = 0; i < order; i++ ) {
   1cd54:	2e00      	cmp	r6, #0
   1cd56:	dd17      	ble.n	1cd88 <silk_noise_shape_analysis_FIX+0x644>
        coefs_Q24[ i ] = silk_SMULWW( gain_Q16, coefs_Q24[ i ] );
   1cd58:	ea4f 4a22 	mov.w	sl, r2, asr #16
   1cd5c:	fa1f fe82 	uxth.w	lr, r2
   1cd60:	4644      	mov	r4, r8
   1cd62:	eb05 0c08 	add.w	ip, r5, r8
   1cd66:	6823      	ldr	r3, [r4, #0]
   1cd68:	b219      	sxth	r1, r3
   1cd6a:	13db      	asrs	r3, r3, #15
   1cd6c:	fb0e f001 	mul.w	r0, lr, r1
   1cd70:	3301      	adds	r3, #1
   1cd72:	fb01 f10a 	mul.w	r1, r1, sl
   1cd76:	105b      	asrs	r3, r3, #1
   1cd78:	eb01 4120 	add.w	r1, r1, r0, asr #16
   1cd7c:	fb02 1303 	mla	r3, r2, r3, r1
   1cd80:	f844 3b04 	str.w	r3, [r4], #4
    for( i = 0; i < order; i++ ) {
   1cd84:	45a4      	cmp	ip, r4
   1cd86:	d1ee      	bne.n	1cd66 <silk_noise_shape_analysis_FIX+0x622>
   1cd88:	1f2b      	subs	r3, r5, #4
   1cd8a:	f107 01e0 	add.w	r1, r7, #224	; 0xe0
   1cd8e:	4429      	add	r1, r5
   1cd90:	4443      	add	r3, r8
   1cd92:	63f9      	str	r1, [r7, #60]	; 0x3c
   1cd94:	643b      	str	r3, [r7, #64]	; 0x40
    opus_int   i, iter, ind = 0;
   1cd96:	f240 3133 	movw	r1, #819	; 0x333
   1cd9a:	2300      	movs	r3, #0
   1cd9c:	e9c7 311c 	strd	r3, r1, [r7, #112]	; 0x70
   1cda0:	4445      	add	r5, r8
   1cda2:	f8c7 8008 	str.w	r8, [r7, #8]
        for( i = 0; i < order; i++ ) {
   1cda6:	2e00      	cmp	r6, #0
   1cda8:	f340 813e 	ble.w	1d028 <silk_noise_shape_analysis_FIX+0x8e4>
   1cdac:	f8d7 e070 	ldr.w	lr, [r7, #112]	; 0x70
   1cdb0:	46c4      	mov	ip, r8
        maxabs_Q24 = -1;
   1cdb2:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
        for( i = 0; i < order; i++ ) {
   1cdb6:	2100      	movs	r1, #0
            tmp = silk_abs_int32( coefs_Q24[ i ] );
   1cdb8:	f85c 0b04 	ldr.w	r0, [ip], #4
   1cdbc:	ea80 73e0 	eor.w	r3, r0, r0, asr #31
   1cdc0:	eb03 73d0 	add.w	r3, r3, r0, lsr #31
            if( tmp > maxabs_Q24 ) {
   1cdc4:	42a3      	cmp	r3, r4
   1cdc6:	bfc8      	it	gt
   1cdc8:	468e      	movgt	lr, r1
        for( i = 0; i < order; i++ ) {
   1cdca:	f101 0101 	add.w	r1, r1, #1
            if( tmp > maxabs_Q24 ) {
   1cdce:	bfc8      	it	gt
   1cdd0:	461c      	movgt	r4, r3
        for( i = 0; i < order; i++ ) {
   1cdd2:	428e      	cmp	r6, r1
   1cdd4:	d1f0      	bne.n	1cdb8 <silk_noise_shape_analysis_FIX+0x674>
        if( maxabs_Q20 <= limit_Q20 ) {
   1cdd6:	4bd3      	ldr	r3, [pc, #844]	; (1d124 <silk_noise_shape_analysis_FIX+0x9e0>)
   1cdd8:	f8c7 e070 	str.w	lr, [r7, #112]	; 0x70
        maxabs_Q20 = silk_RSHIFT(maxabs_Q24, 4);
   1cddc:	1124      	asrs	r4, r4, #4
        if( maxabs_Q20 <= limit_Q20 ) {
   1cdde:	429c      	cmp	r4, r3
   1cde0:	f340 8122 	ble.w	1d028 <silk_noise_shape_analysis_FIX+0x8e4>
        for( i = 1; i < order; i++ ) {
   1cde4:	2e01      	cmp	r6, #1
   1cde6:	d017      	beq.n	1ce18 <silk_noise_shape_analysis_FIX+0x6d4>
   1cde8:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
   1cdec:	f8d7 c03c 	ldr.w	ip, [r7, #60]	; 0x3c
   1cdf0:	46c6      	mov	lr, r8
   1cdf2:	4692      	mov	sl, r2
            coefs_Q24[ i - 1 ] = silk_SMLAWB( coefs_Q24[ i - 1 ], coefs_Q24[ i ], lambda_Q16 );
   1cdf4:	f8de 2004 	ldr.w	r2, [lr, #4]
   1cdf8:	fa1f fb82 	uxth.w	fp, r2
   1cdfc:	1410      	asrs	r0, r2, #16
   1cdfe:	fb09 fb0b 	mul.w	fp, r9, fp
   1ce02:	fb09 f000 	mul.w	r0, r9, r0
   1ce06:	eb00 402b 	add.w	r0, r0, fp, asr #16
   1ce0a:	4403      	add	r3, r0
   1ce0c:	f84e 3b04 	str.w	r3, [lr], #4
        for( i = 1; i < order; i++ ) {
   1ce10:	45f4      	cmp	ip, lr
   1ce12:	4613      	mov	r3, r2
   1ce14:	d1ee      	bne.n	1cdf4 <silk_noise_shape_analysis_FIX+0x6b0>
   1ce16:	4652      	mov	r2, sl
   1ce18:	2a00      	cmp	r2, #0
   1ce1a:	f000 8138 	beq.w	1d08e <silk_noise_shape_analysis_FIX+0x94a>
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
   1ce1e:	ea82 73e2 	eor.w	r3, r2, r2, asr #31
   1ce22:	eba3 73e2 	sub.w	r3, r3, r2, asr #31
   1ce26:	fab3 f383 	clz	r3, r3
   1ce2a:	3b01      	subs	r3, #1
   1ce2c:	f1c3 0e1d 	rsb	lr, r3, #29
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                */
   1ce30:	409a      	lsls	r2, r3
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm    */
   1ce32:	1410      	asrs	r0, r2, #16
   1ce34:	f06f 4c60 	mvn.w	ip, #3758096384	; 0xe0000000
    err_Q32 = silk_LSHIFT( ((opus_int32)1<<29) - silk_SMULWB(b32_nrm, b32_inv), 3 );        /* Q32                        */
   1ce38:	b292      	uxth	r2, r2
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm    */
   1ce3a:	fb9c fcf0 	sdiv	ip, ip, r0
    err_Q32 = silk_LSHIFT( ((opus_int32)1<<29) - silk_SMULWB(b32_nrm, b32_inv), 3 );        /* Q32                        */
   1ce3e:	fa0f fa8c 	sxth.w	sl, ip
   1ce42:	fb0a f202 	mul.w	r2, sl, r2
   1ce46:	fb0a f000 	mul.w	r0, sl, r0
   1ce4a:	eb00 4022 	add.w	r0, r0, r2, asr #16
   1ce4e:	f1c0 5300 	rsb	r3, r0, #536870912	; 0x20000000
   1ce52:	00db      	lsls	r3, r3, #3
    result = silk_SMLAWW(result, err_Q32, b32_inv);                             /* Q: 61 - b_headrm            */
   1ce54:	fa1f fb83 	uxth.w	fp, r3
   1ce58:	141a      	asrs	r2, r3, #16
   1ce5a:	ea4f 30ec 	mov.w	r0, ip, asr #15
   1ce5e:	fb0a fb0b 	mul.w	fp, sl, fp
   1ce62:	fb0a f202 	mul.w	r2, sl, r2
   1ce66:	3001      	adds	r0, #1
   1ce68:	eb02 422b 	add.w	r2, r2, fp, asr #16
   1ce6c:	1040      	asrs	r0, r0, #1
   1ce6e:	eb02 420c 	add.w	r2, r2, ip, lsl #16
    if( lshift <= 0 ) {
   1ce72:	f1be 0f00 	cmp.w	lr, #0
    result = silk_SMLAWW(result, err_Q32, b32_inv);                             /* Q: 61 - b_headrm            */
   1ce76:	fb03 2000 	mla	r0, r3, r0, r2
    if( lshift <= 0 ) {
   1ce7a:	f340 810c 	ble.w	1d096 <silk_noise_shape_analysis_FIX+0x952>
            return silk_RSHIFT(result, lshift);
   1ce7e:	fa40 fe0e 	asr.w	lr, r0, lr
            coefs_Q24[ i ] = silk_SMULWW( gain_Q16, coefs_Q24[ i ] );
   1ce82:	ea4f 4b2e 	mov.w	fp, lr, asr #16
   1ce86:	fa1f fa8e 	uxth.w	sl, lr
   1ce8a:	46c4      	mov	ip, r8
   1ce8c:	f8dc 3000 	ldr.w	r3, [ip]
   1ce90:	b21a      	sxth	r2, r3
   1ce92:	13db      	asrs	r3, r3, #15
   1ce94:	fb0a f002 	mul.w	r0, sl, r2
   1ce98:	3301      	adds	r3, #1
   1ce9a:	fb02 f20b 	mul.w	r2, r2, fp
   1ce9e:	105b      	asrs	r3, r3, #1
   1cea0:	eb02 4220 	add.w	r2, r2, r0, asr #16
   1cea4:	fb0e 2303 	mla	r3, lr, r3, r2
   1cea8:	f84c 3b04 	str.w	r3, [ip], #4
        for( i = 0; i < order; i++ ) {
   1ceac:	4565      	cmp	r5, ip
   1ceae:	d1ed      	bne.n	1ce8c <silk_noise_shape_analysis_FIX+0x748>
            silk_SMULWB( maxabs_Q20 - limit_Q20, silk_SMLABB( SILK_FIX_CONST( 0.8, 10 ), SILK_FIX_CONST( 0.1, 10 ), iter ) ),
   1ceb0:	489d      	ldr	r0, [pc, #628]	; (1d128 <silk_noise_shape_analysis_FIX+0x9e4>)
   1ceb2:	6f7a      	ldr	r2, [r7, #116]	; 0x74
   1ceb4:	1820      	adds	r0, r4, r0
   1ceb6:	b283      	uxth	r3, r0
   1ceb8:	1400      	asrs	r0, r0, #16
   1ceba:	fb02 f303 	mul.w	r3, r2, r3
   1cebe:	fb02 f000 	mul.w	r0, r2, r0
        chirp_Q16 = SILK_FIX_CONST( 0.99, 16 ) - silk_DIV32_varQ(
   1cec2:	6f3a      	ldr	r2, [r7, #112]	; 0x70
   1cec4:	eb10 4023 	adds.w	r0, r0, r3, asr #16
   1cec8:	fb02 4204 	mla	r2, r2, r4, r4
   1cecc:	f000 80db 	beq.w	1d086 <silk_noise_shape_analysis_FIX+0x942>
   1ced0:	fab0 f380 	clz	r3, r0
   1ced4:	f103 0b1c 	add.w	fp, r3, #28
   1ced8:	3b01      	subs	r3, #1
   1ceda:	fab2 fe82 	clz	lr, r2
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
   1cede:	f10e 3eff 	add.w	lr, lr, #4294967295	; 0xffffffff
    a32_nrm = silk_LSHIFT(a32, a_headrm);                                       /* Q: a_headrm                  */
   1cee2:	4098      	lsls	r0, r3
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                  */
   1cee4:	fa02 f20e 	lsl.w	r2, r2, lr
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1cee8:	ea4f 4c22 	mov.w	ip, r2, asr #16
   1ceec:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1cef0:	ea4f 4a20 	mov.w	sl, r0, asr #16
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1cef4:	fb93 fcfc 	sdiv	ip, r3, ip
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1cef8:	b283      	uxth	r3, r0
   1cefa:	fa0f fc8c 	sxth.w	ip, ip
   1cefe:	fb0c f303 	mul.w	r3, ip, r3
   1cf02:	fb0c fa0a 	mul.w	sl, ip, sl
   1cf06:	eb0a 4a23 	add.w	sl, sl, r3, asr #16
    a32_nrm = silk_SUB32_ovflw(a32_nrm, silk_LSHIFT_ovflw( silk_SMMUL(b32_nrm, result), 3 ));  /* Q: a_headrm   */
   1cf0a:	fb82 230a 	smull	r2, r3, r2, sl
   1cf0e:	eba0 00c3 	sub.w	r0, r0, r3, lsl #3
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1cf12:	b283      	uxth	r3, r0
   1cf14:	1400      	asrs	r0, r0, #16
   1cf16:	fb0c f303 	mul.w	r3, ip, r3
   1cf1a:	fb0c f000 	mul.w	r0, ip, r0
    lshift = 29 + a_headrm - b_headrm - Qres;
   1cf1e:	ebab 0e0e 	sub.w	lr, fp, lr
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1cf22:	eb00 4023 	add.w	r0, r0, r3, asr #16
    if( lshift < 0 ) {
   1cf26:	f1be 0216 	subs.w	r2, lr, #22
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1cf2a:	4450      	add	r0, sl
    if( lshift < 0 ) {
   1cf2c:	f100 80c0 	bmi.w	1d0b0 <silk_noise_shape_analysis_FIX+0x96c>
        if( lshift < 32){
   1cf30:	2a1f      	cmp	r2, #31
            return silk_RSHIFT(result, lshift);
   1cf32:	bfdd      	ittte	le
   1cf34:	fa40 f202 	asrle.w	r2, r0, r2
   1cf38:	f5c2 427d 	rsble	r2, r2, #64768	; 0xfd00
   1cf3c:	3271      	addle	r2, #113	; 0x71
        if( lshift < 32){
   1cf3e:	f64f 5271 	movwgt	r2, #64881	; 0xfd71
        silk_bwexpander_32( coefs_Q24, order, chirp_Q16 );
   1cf42:	4640      	mov	r0, r8
   1cf44:	f7fa fcbc 	bl	178c0 <silk_bwexpander_32>
        for( i = order - 1; i > 0; i-- ) {
   1cf48:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   1cf4a:	2b00      	cmp	r3, #0
   1cf4c:	dd12      	ble.n	1cf74 <silk_noise_shape_analysis_FIX+0x830>
   1cf4e:	f855 3c04 	ldr.w	r3, [r5, #-4]
   1cf52:	f9b7 0064 	ldrsh.w	r0, [r7, #100]	; 0x64
   1cf56:	6c39      	ldr	r1, [r7, #64]	; 0x40
            coefs_Q24[ i - 1 ] = silk_SMLAWB( coefs_Q24[ i - 1 ], coefs_Q24[ i ], lambda_Q16 );
   1cf58:	f851 4d04 	ldr.w	r4, [r1, #-4]!
   1cf5c:	b29a      	uxth	r2, r3
   1cf5e:	141b      	asrs	r3, r3, #16
   1cf60:	fb00 f202 	mul.w	r2, r0, r2
   1cf64:	fb00 f303 	mul.w	r3, r0, r3
   1cf68:	eb03 4322 	add.w	r3, r3, r2, asr #16
   1cf6c:	4423      	add	r3, r4
        for( i = order - 1; i > 0; i-- ) {
   1cf6e:	4541      	cmp	r1, r8
            coefs_Q24[ i - 1 ] = silk_SMLAWB( coefs_Q24[ i - 1 ], coefs_Q24[ i ], lambda_Q16 );
   1cf70:	600b      	str	r3, [r1, #0]
        for( i = order - 1; i > 0; i-- ) {
   1cf72:	d1f1      	bne.n	1cf58 <silk_noise_shape_analysis_FIX+0x814>
        den_Q24  = silk_SMLAWB( SILK_FIX_CONST( 1.0, 24 ), coefs_Q24[ 0 ], lambda_Q16 );
   1cf74:	f8d7 00e4 	ldr.w	r0, [r7, #228]	; 0xe4
   1cf78:	b282      	uxth	r2, r0
   1cf7a:	1400      	asrs	r0, r0, #16
   1cf7c:	fb09 f302 	mul.w	r3, r9, r2
   1cf80:	fb09 f000 	mul.w	r0, r9, r0
   1cf84:	eb00 4023 	add.w	r0, r0, r3, asr #16
   1cf88:	f110 7080 	adds.w	r0, r0, #16777216	; 0x1000000
   1cf8c:	d079      	beq.n	1d082 <silk_noise_shape_analysis_FIX+0x93e>
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
   1cf8e:	ea80 74e0 	eor.w	r4, r0, r0, asr #31
   1cf92:	eba4 74e0 	sub.w	r4, r4, r0, asr #31
   1cf96:	fab4 f484 	clz	r4, r4
   1cf9a:	3c01      	subs	r4, #1
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                  */
   1cf9c:	40a0      	lsls	r0, r4
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1cf9e:	1402      	asrs	r2, r0, #16
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1cfa0:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1cfa2:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
   1cfa6:	fb93 f3f2 	sdiv	r3, r3, r2
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1cfaa:	6cba      	ldr	r2, [r7, #72]	; 0x48
   1cfac:	b21b      	sxth	r3, r3
   1cfae:	fb03 f202 	mul.w	r2, r3, r2
   1cfb2:	fb03 fc01 	mul.w	ip, r3, r1
   1cfb6:	eb0c 4c22 	add.w	ip, ip, r2, asr #16
    a32_nrm = silk_SUB32_ovflw(a32_nrm, silk_LSHIFT_ovflw( silk_SMMUL(b32_nrm, result), 3 ));  /* Q: a_headrm   */
   1cfba:	6eba      	ldr	r2, [r7, #104]	; 0x68
   1cfbc:	fb80 010c 	smull	r0, r1, r0, ip
   1cfc0:	eba2 01c1 	sub.w	r1, r2, r1, lsl #3
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1cfc4:	b28a      	uxth	r2, r1
   1cfc6:	1409      	asrs	r1, r1, #16
   1cfc8:	fb03 f202 	mul.w	r2, r3, r2
   1cfcc:	fb03 f301 	mul.w	r3, r3, r1
    lshift = 29 + a_headrm - b_headrm - Qres;
   1cfd0:	6df9      	ldr	r1, [r7, #92]	; 0x5c
   1cfd2:	1b0c      	subs	r4, r1, r4
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1cfd4:	eb03 4322 	add.w	r3, r3, r2, asr #16
    if( lshift < 0 ) {
   1cfd8:	f1b4 0218 	subs.w	r2, r4, #24
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1cfdc:	4463      	add	r3, ip
    if( lshift < 0 ) {
   1cfde:	d47f      	bmi.n	1d0e0 <silk_noise_shape_analysis_FIX+0x99c>
        if( lshift < 32){
   1cfe0:	2a1f      	cmp	r2, #31
            return silk_RSHIFT(result, lshift);
   1cfe2:	bfd4      	ite	le
   1cfe4:	fa43 f202 	asrle.w	r2, r3, r2
            return 0;
   1cfe8:	2200      	movgt	r2, #0
            coefs_Q24[ i ] = silk_SMULWW( gain_Q16, coefs_Q24[ i ] );
   1cfea:	ea4f 4e22 	mov.w	lr, r2, asr #16
   1cfee:	fa1f fc82 	uxth.w	ip, r2
   1cff2:	4644      	mov	r4, r8
   1cff4:	6823      	ldr	r3, [r4, #0]
   1cff6:	b219      	sxth	r1, r3
   1cff8:	13db      	asrs	r3, r3, #15
   1cffa:	fb0c f001 	mul.w	r0, ip, r1
   1cffe:	3301      	adds	r3, #1
   1d000:	fb01 f10e 	mul.w	r1, r1, lr
   1d004:	105b      	asrs	r3, r3, #1
   1d006:	eb01 4120 	add.w	r1, r1, r0, asr #16
   1d00a:	fb02 1303 	mla	r3, r2, r3, r1
   1d00e:	f844 3b04 	str.w	r3, [r4], #4
        for( i = 0; i < order; i++ ) {
   1d012:	42a5      	cmp	r5, r4
   1d014:	d1ee      	bne.n	1cff4 <silk_noise_shape_analysis_FIX+0x8b0>
   1d016:	6f7b      	ldr	r3, [r7, #116]	; 0x74
   1d018:	3366      	adds	r3, #102	; 0x66
   1d01a:	4619      	mov	r1, r3
   1d01c:	677b      	str	r3, [r7, #116]	; 0x74
    for( iter = 0; iter < 10; iter++ ) {
   1d01e:	f240 732f 	movw	r3, #1839	; 0x72f
   1d022:	4299      	cmp	r1, r3
   1d024:	f47f aebf 	bne.w	1cda6 <silk_noise_shape_analysis_FIX+0x662>

            /* Convert from Q24 to Q13 and store in int16 */
            for( i = 0; i < psEnc->sCmn.shapingLPCOrder; i++ ) {
   1d028:	6efb      	ldr	r3, [r7, #108]	; 0x6c
   1d02a:	6819      	ldr	r1, [r3, #0]
   1d02c:	2900      	cmp	r1, #0
   1d02e:	dd1a      	ble.n	1d066 <silk_noise_shape_analysis_FIX+0x922>
   1d030:	eb08 0181 	add.w	r1, r8, r1, lsl #2
   1d034:	6d7a      	ldr	r2, [r7, #84]	; 0x54
   1d036:	68b8      	ldr	r0, [r7, #8]
   1d038:	e007      	b.n	1d04a <silk_noise_shape_analysis_FIX+0x906>
                psEncCtrl->AR_Q13[ k * MAX_SHAPE_LPC_ORDER + i ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( AR_Q24[ i ], 11 ) );
   1d03a:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   1d03e:	db62      	blt.n	1d106 <silk_noise_shape_analysis_FIX+0x9c2>
   1d040:	b21b      	sxth	r3, r3
            for( i = 0; i < psEnc->sCmn.shapingLPCOrder; i++ ) {
   1d042:	4281      	cmp	r1, r0
                psEncCtrl->AR_Q13[ k * MAX_SHAPE_LPC_ORDER + i ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( AR_Q24[ i ], 11 ) );
   1d044:	f822 3b02 	strh.w	r3, [r2], #2
            for( i = 0; i < psEnc->sCmn.shapingLPCOrder; i++ ) {
   1d048:	d00d      	beq.n	1d066 <silk_noise_shape_analysis_FIX+0x922>
                psEncCtrl->AR_Q13[ k * MAX_SHAPE_LPC_ORDER + i ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( AR_Q24[ i ], 11 ) );
   1d04a:	f850 3b04 	ldr.w	r3, [r0], #4
   1d04e:	129b      	asrs	r3, r3, #10
   1d050:	3301      	adds	r3, #1
   1d052:	105b      	asrs	r3, r3, #1
   1d054:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1d058:	dbef      	blt.n	1d03a <silk_noise_shape_analysis_FIX+0x8f6>
   1d05a:	f647 73ff 	movw	r3, #32767	; 0x7fff
            for( i = 0; i < psEnc->sCmn.shapingLPCOrder; i++ ) {
   1d05e:	4281      	cmp	r1, r0
                psEncCtrl->AR_Q13[ k * MAX_SHAPE_LPC_ORDER + i ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( AR_Q24[ i ], 11 ) );
   1d060:	f822 3b02 	strh.w	r3, [r2], #2
            for( i = 0; i < psEnc->sCmn.shapingLPCOrder; i++ ) {
   1d064:	d1f1      	bne.n	1d04a <silk_noise_shape_analysis_FIX+0x906>
    for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1d066:	69fb      	ldr	r3, [r7, #28]
   1d068:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   1d06a:	6d79      	ldr	r1, [r7, #84]	; 0x54
   1d06c:	681b      	ldr	r3, [r3, #0]
   1d06e:	3201      	adds	r2, #1
   1d070:	3130      	adds	r1, #48	; 0x30
   1d072:	4293      	cmp	r3, r2
   1d074:	62fa      	str	r2, [r7, #44]	; 0x2c
   1d076:	6579      	str	r1, [r7, #84]	; 0x54
   1d078:	f340 80a0 	ble.w	1d1bc <silk_noise_shape_analysis_FIX+0xa78>
   1d07c:	6abb      	ldr	r3, [r7, #40]	; 0x28
   1d07e:	681d      	ldr	r5, [r3, #0]
   1d080:	e4de      	b.n	1ca40 <silk_noise_shape_analysis_FIX+0x2fc>
   1d082:	241f      	movs	r4, #31
   1d084:	e78a      	b.n	1cf9c <silk_noise_shape_analysis_FIX+0x858>
   1d086:	231f      	movs	r3, #31
   1d088:	f04f 0b3c 	mov.w	fp, #60	; 0x3c
   1d08c:	e725      	b.n	1ceda <silk_noise_shape_analysis_FIX+0x796>
   1d08e:	f06f 0e01 	mvn.w	lr, #1
   1d092:	231f      	movs	r3, #31
   1d094:	e6cc      	b.n	1ce30 <silk_noise_shape_analysis_FIX+0x6ec>
        return silk_LSHIFT_SAT32(result, -lshift);
   1d096:	f1ce 0e00 	rsb	lr, lr, #0
   1d09a:	f06f 4a00 	mvn.w	sl, #2147483648	; 0x80000000
   1d09e:	fa4a fa0e 	asr.w	sl, sl, lr
   1d0a2:	4550      	cmp	r0, sl
   1d0a4:	f340 81fe 	ble.w	1d4a4 <silk_noise_shape_analysis_FIX+0xd60>
   1d0a8:	4650      	mov	r0, sl
   1d0aa:	fa00 fe0e 	lsl.w	lr, r0, lr
   1d0ae:	e6e8      	b.n	1ce82 <silk_noise_shape_analysis_FIX+0x73e>
        return silk_LSHIFT_SAT32(result, -lshift);
   1d0b0:	f1ce 0e16 	rsb	lr, lr, #22
   1d0b4:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   1d0b8:	f06f 4a00 	mvn.w	sl, #2147483648	; 0x80000000
   1d0bc:	fa42 f20e 	asr.w	r2, r2, lr
   1d0c0:	fa4a fa0e 	asr.w	sl, sl, lr
   1d0c4:	4552      	cmp	r2, sl
   1d0c6:	dd43      	ble.n	1d150 <silk_noise_shape_analysis_FIX+0xa0c>
   1d0c8:	4290      	cmp	r0, r2
   1d0ca:	dc03      	bgt.n	1d0d4 <silk_noise_shape_analysis_FIX+0x990>
   1d0cc:	4550      	cmp	r0, sl
   1d0ce:	4602      	mov	r2, r0
   1d0d0:	bfb8      	it	lt
   1d0d2:	4652      	movlt	r2, sl
   1d0d4:	fa02 f20e 	lsl.w	r2, r2, lr
   1d0d8:	f5c2 427d 	rsb	r2, r2, #64768	; 0xfd00
   1d0dc:	3271      	adds	r2, #113	; 0x71
   1d0de:	e730      	b.n	1cf42 <silk_noise_shape_analysis_FIX+0x7fe>
   1d0e0:	f1c4 0418 	rsb	r4, r4, #24
   1d0e4:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   1d0e8:	f06f 4c00 	mvn.w	ip, #2147483648	; 0x80000000
   1d0ec:	4122      	asrs	r2, r4
   1d0ee:	fa4c fc04 	asr.w	ip, ip, r4
   1d0f2:	4562      	cmp	r2, ip
   1d0f4:	dd27      	ble.n	1d146 <silk_noise_shape_analysis_FIX+0xa02>
   1d0f6:	4293      	cmp	r3, r2
   1d0f8:	dc03      	bgt.n	1d102 <silk_noise_shape_analysis_FIX+0x9be>
   1d0fa:	4563      	cmp	r3, ip
   1d0fc:	bfb8      	it	lt
   1d0fe:	4663      	movlt	r3, ip
   1d100:	461a      	mov	r2, r3
   1d102:	40a2      	lsls	r2, r4
   1d104:	e771      	b.n	1cfea <silk_noise_shape_analysis_FIX+0x8a6>
                psEncCtrl->AR_Q13[ k * MAX_SHAPE_LPC_ORDER + i ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( AR_Q24[ i ], 11 ) );
   1d106:	4b09      	ldr	r3, [pc, #36]	; (1d12c <silk_noise_shape_analysis_FIX+0x9e8>)
   1d108:	e79b      	b.n	1d042 <silk_noise_shape_analysis_FIX+0x8fe>
            }
        } else {
            silk_LPC_fit( &psEncCtrl->AR_Q13[ k * MAX_SHAPE_LPC_ORDER ], AR_Q24, 13, 24, psEnc->sCmn.shapingLPCOrder );
   1d10a:	681b      	ldr	r3, [r3, #0]
   1d10c:	9300      	str	r3, [sp, #0]
   1d10e:	220d      	movs	r2, #13
   1d110:	2318      	movs	r3, #24
   1d112:	4641      	mov	r1, r8
   1d114:	6d78      	ldr	r0, [r7, #84]	; 0x54
   1d116:	f7fd fa21 	bl	1a55c <silk_LPC_fit>
   1d11a:	e7a4      	b.n	1d066 <silk_noise_shape_analysis_FIX+0x922>
        psEncCtrl->Gains_Q16[ k ] = silk_LSHIFT_SAT32( tmp32, 16 - Qnrg );
   1d11c:	4298      	cmp	r0, r3
   1d11e:	da45      	bge.n	1d1ac <silk_noise_shape_analysis_FIX+0xa68>
   1d120:	4603      	mov	r3, r0
   1d122:	e51f      	b.n	1cb64 <silk_noise_shape_analysis_FIX+0x420>
   1d124:	003ffbe7 	.word	0x003ffbe7
   1d128:	ffc00419 	.word	0xffc00419
   1d12c:	ffff8000 	.word	0xffff8000
            nrg >>= 1;
   1d130:	6a78      	ldr	r0, [r7, #36]	; 0x24
   1d132:	6803      	ldr	r3, [r0, #0]
   1d134:	105b      	asrs	r3, r3, #1
    if( x <= 0 ) {
   1d136:	2b00      	cmp	r3, #0
   1d138:	ea6f 0201 	mvn.w	r2, r1
   1d13c:	6003      	str	r3, [r0, #0]
   1d13e:	f73f ace1 	bgt.w	1cb04 <silk_noise_shape_analysis_FIX+0x3c0>
        return 0;
   1d142:	2300      	movs	r3, #0
   1d144:	e4fe      	b.n	1cb44 <silk_noise_shape_analysis_FIX+0x400>
        return silk_LSHIFT_SAT32(result, -lshift);
   1d146:	4563      	cmp	r3, ip
   1d148:	f340 81b4 	ble.w	1d4b4 <silk_noise_shape_analysis_FIX+0xd70>
   1d14c:	4662      	mov	r2, ip
   1d14e:	e7d8      	b.n	1d102 <silk_noise_shape_analysis_FIX+0x9be>
   1d150:	4550      	cmp	r0, sl
   1d152:	f340 81a3 	ble.w	1d49c <silk_noise_shape_analysis_FIX+0xd58>
   1d156:	4652      	mov	r2, sl
   1d158:	e7bc      	b.n	1d0d4 <silk_noise_shape_analysis_FIX+0x990>
            silk_autocorr( auto_corr, &scale, x_windowed, psEnc->sCmn.shapeWinLength, psEnc->sCmn.shapingLPCOrder + 1, arch );
   1d15a:	f8d7 11d0 	ldr.w	r1, [r7, #464]	; 0x1d0
   1d15e:	9101      	str	r1, [sp, #4]
   1d160:	3201      	adds	r2, #1
   1d162:	9200      	str	r2, [sp, #0]
   1d164:	f107 017c 	add.w	r1, r7, #124	; 0x7c
   1d168:	6e3a      	ldr	r2, [r7, #96]	; 0x60
   1d16a:	f507 70a2 	add.w	r0, r7, #324	; 0x144
   1d16e:	f000 fe85 	bl	1de7c <silk_autocorr>
   1d172:	e49d      	b.n	1cab0 <silk_noise_shape_analysis_FIX+0x36c>
                psEncCtrl->Gains_Q16[ k ] = silk_SMULWW( silk_RSHIFT_ROUND( psEncCtrl->Gains_Q16[ k ], 1 ), gain_mult_Q16 );
   1d174:	f003 0001 	and.w	r0, r3, #1
   1d178:	eb00 0363 	add.w	r3, r0, r3, asr #1
   1d17c:	b298      	uxth	r0, r3
   1d17e:	141c      	asrs	r4, r3, #16
   1d180:	fb0e f000 	mul.w	r0, lr, r0
   1d184:	fb0e fe04 	mul.w	lr, lr, r4
   1d188:	eb0e 4e20 	add.w	lr, lr, r0, asr #16
                if ( psEncCtrl->Gains_Q16[ k ] >= ( silk_int32_MAX >> 1 ) ) {
   1d18c:	48db      	ldr	r0, [pc, #876]	; (1d4fc <silk_noise_shape_analysis_FIX+0xdb8>)
                psEncCtrl->Gains_Q16[ k ] = silk_SMULWW( silk_RSHIFT_ROUND( psEncCtrl->Gains_Q16[ k ], 1 ), gain_mult_Q16 );
   1d18e:	fb02 e303 	mla	r3, r2, r3, lr
   1d192:	6c7a      	ldr	r2, [r7, #68]	; 0x44
                if ( psEncCtrl->Gains_Q16[ k ] >= ( silk_int32_MAX >> 1 ) ) {
   1d194:	4283      	cmp	r3, r0
                psEncCtrl->Gains_Q16[ k ] = silk_SMULWW( silk_RSHIFT_ROUND( psEncCtrl->Gains_Q16[ k ], 1 ), gain_mult_Q16 );
   1d196:	6013      	str	r3, [r2, #0]
                    psEncCtrl->Gains_Q16[ k ] = silk_int32_MAX;
   1d198:	bfcc      	ite	gt
   1d19a:	f06f 4300 	mvngt.w	r3, #2147483648	; 0x80000000
                    psEncCtrl->Gains_Q16[ k ] = silk_LSHIFT32( psEncCtrl->Gains_Q16[ k ], 1 );
   1d19e:	005b      	lslle	r3, r3, #1
   1d1a0:	6013      	str	r3, [r2, #0]
   1d1a2:	e558      	b.n	1cc56 <silk_noise_shape_analysis_FIX+0x512>
   1d1a4:	f06f 0e09 	mvn.w	lr, #9
   1d1a8:	201f      	movs	r0, #31
   1d1aa:	e516      	b.n	1cbda <silk_noise_shape_analysis_FIX+0x496>
        psEncCtrl->Gains_Q16[ k ] = silk_LSHIFT_SAT32( tmp32, 16 - Qnrg );
   1d1ac:	428b      	cmp	r3, r1
   1d1ae:	bfb8      	it	lt
   1d1b0:	460b      	movlt	r3, r1
   1d1b2:	e4d7      	b.n	1cb64 <silk_noise_shape_analysis_FIX+0x420>
   1d1b4:	4283      	cmp	r3, r0
   1d1b6:	bfb8      	it	lt
   1d1b8:	4603      	movlt	r3, r0
   1d1ba:	e4d3      	b.n	1cb64 <silk_noise_shape_analysis_FIX+0x420>

    /*****************/
    /* Gain tweaking */
    /*****************/
    /* Increase gains during low speech activity and put lower limit on gains */
    gain_mult_Q16 = silk_log2lin( -silk_SMLAWB( -SILK_FIX_CONST( 16.0, 7 ), SNR_adj_dB_Q7, SILK_FIX_CONST( 0.16, 16 ) ) );
   1d1bc:	687b      	ldr	r3, [r7, #4]
   1d1be:	b298      	uxth	r0, r3
   1d1c0:	ea4f 4823 	mov.w	r8, r3, asr #16
   1d1c4:	f642 03f6 	movw	r3, #10486	; 0x28f6
   1d1c8:	fb03 f000 	mul.w	r0, r3, r0
   1d1cc:	fb03 f308 	mul.w	r3, r3, r8
   1d1d0:	eb03 4010 	add.w	r0, r3, r0, lsr #16
   1d1d4:	f5c0 6000 	rsb	r0, r0, #2048	; 0x800
   1d1d8:	f7fa fc2e 	bl	17a38 <silk_log2lin>
   1d1dc:	4605      	mov	r5, r0
    gain_add_Q16  = silk_log2lin(  silk_SMLAWB(  SILK_FIX_CONST( 16.0, 7 ), SILK_FIX_CONST( MIN_QGAIN_DB, 7 ), SILK_FIX_CONST( 0.16, 16 ) ) );
   1d1de:	f640 0028 	movw	r0, #2088	; 0x828
   1d1e2:	f7fa fc29 	bl	17a38 <silk_log2lin>
    silk_assert( gain_mult_Q16 > 0 );
    for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1d1e6:	f241 13e4 	movw	r3, #4580	; 0x11e4
   1d1ea:	6bba      	ldr	r2, [r7, #56]	; 0x38
   1d1ec:	f852 9003 	ldr.w	r9, [r2, r3]
   1d1f0:	f1b9 0f00 	cmp.w	r9, #0
   1d1f4:	dd4e      	ble.n	1d294 <silk_noise_shape_analysis_FIX+0xb50>
        psEncCtrl->Gains_Q16[ k ] = silk_SMULWW( psEncCtrl->Gains_Q16[ k ], gain_mult_Q16 );
   1d1f6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   1d1f8:	6813      	ldr	r3, [r2, #0]
   1d1fa:	b22c      	sxth	r4, r5
   1d1fc:	b29e      	uxth	r6, r3
   1d1fe:	13e9      	asrs	r1, r5, #15
   1d200:	141d      	asrs	r5, r3, #16
   1d202:	fb04 f606 	mul.w	r6, r4, r6
   1d206:	3101      	adds	r1, #1
   1d208:	fb04 f505 	mul.w	r5, r4, r5
   1d20c:	1049      	asrs	r1, r1, #1
   1d20e:	eb05 4526 	add.w	r5, r5, r6, asr #16
   1d212:	fb03 5301 	mla	r3, r3, r1, r5
        silk_assert( psEncCtrl->Gains_Q16[ k ] >= 0 );
        psEncCtrl->Gains_Q16[ k ] = silk_ADD_POS_SAT32( psEncCtrl->Gains_Q16[ k ], gain_add_Q16 );
   1d216:	181b      	adds	r3, r3, r0
   1d218:	bf48      	it	mi
   1d21a:	f06f 4300 	mvnmi.w	r3, #2147483648	; 0x80000000
    for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1d21e:	f1b9 0f01 	cmp.w	r9, #1
        psEncCtrl->Gains_Q16[ k ] = silk_ADD_POS_SAT32( psEncCtrl->Gains_Q16[ k ], gain_add_Q16 );
   1d222:	6013      	str	r3, [r2, #0]
    for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1d224:	d036      	beq.n	1d294 <silk_noise_shape_analysis_FIX+0xb50>
        psEncCtrl->Gains_Q16[ k ] = silk_SMULWW( psEncCtrl->Gains_Q16[ k ], gain_mult_Q16 );
   1d226:	6853      	ldr	r3, [r2, #4]
   1d228:	b29e      	uxth	r6, r3
   1d22a:	141d      	asrs	r5, r3, #16
   1d22c:	fb04 f606 	mul.w	r6, r4, r6
   1d230:	fb04 f505 	mul.w	r5, r4, r5
   1d234:	eb05 4526 	add.w	r5, r5, r6, asr #16
   1d238:	fb03 5301 	mla	r3, r3, r1, r5
        psEncCtrl->Gains_Q16[ k ] = silk_ADD_POS_SAT32( psEncCtrl->Gains_Q16[ k ], gain_add_Q16 );
   1d23c:	181b      	adds	r3, r3, r0
   1d23e:	bf48      	it	mi
   1d240:	f06f 4300 	mvnmi.w	r3, #2147483648	; 0x80000000
    for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1d244:	f1b9 0f02 	cmp.w	r9, #2
        psEncCtrl->Gains_Q16[ k ] = silk_ADD_POS_SAT32( psEncCtrl->Gains_Q16[ k ], gain_add_Q16 );
   1d248:	6053      	str	r3, [r2, #4]
    for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1d24a:	d023      	beq.n	1d294 <silk_noise_shape_analysis_FIX+0xb50>
        psEncCtrl->Gains_Q16[ k ] = silk_SMULWW( psEncCtrl->Gains_Q16[ k ], gain_mult_Q16 );
   1d24c:	6893      	ldr	r3, [r2, #8]
   1d24e:	b29e      	uxth	r6, r3
   1d250:	141d      	asrs	r5, r3, #16
   1d252:	fb04 f606 	mul.w	r6, r4, r6
   1d256:	fb04 f505 	mul.w	r5, r4, r5
   1d25a:	eb05 4526 	add.w	r5, r5, r6, asr #16
   1d25e:	fb03 5301 	mla	r3, r3, r1, r5
        psEncCtrl->Gains_Q16[ k ] = silk_ADD_POS_SAT32( psEncCtrl->Gains_Q16[ k ], gain_add_Q16 );
   1d262:	181b      	adds	r3, r3, r0
   1d264:	bf48      	it	mi
   1d266:	f06f 4300 	mvnmi.w	r3, #2147483648	; 0x80000000
    for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1d26a:	f1b9 0f03 	cmp.w	r9, #3
        psEncCtrl->Gains_Q16[ k ] = silk_ADD_POS_SAT32( psEncCtrl->Gains_Q16[ k ], gain_add_Q16 );
   1d26e:	6093      	str	r3, [r2, #8]
    for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1d270:	d010      	beq.n	1d294 <silk_noise_shape_analysis_FIX+0xb50>
        psEncCtrl->Gains_Q16[ k ] = silk_SMULWW( psEncCtrl->Gains_Q16[ k ], gain_mult_Q16 );
   1d272:	68d5      	ldr	r5, [r2, #12]
   1d274:	b2ab      	uxth	r3, r5
   1d276:	ea4f 4c25 	mov.w	ip, r5, asr #16
   1d27a:	fb04 f603 	mul.w	r6, r4, r3
   1d27e:	fb04 f30c 	mul.w	r3, r4, ip
   1d282:	eb03 4326 	add.w	r3, r3, r6, asr #16
   1d286:	fb05 3301 	mla	r3, r5, r1, r3
        psEncCtrl->Gains_Q16[ k ] = silk_ADD_POS_SAT32( psEncCtrl->Gains_Q16[ k ], gain_add_Q16 );
   1d28a:	1818      	adds	r0, r3, r0
   1d28c:	bf48      	it	mi
   1d28e:	f06f 4000 	mvnmi.w	r0, #2147483648	; 0x80000000
   1d292:	60d0      	str	r0, [r2, #12]

    /************************************************/
    /* Control low-frequency shaping and noise tilt */
    /************************************************/
    /* Less low frequency shaping for noisy inputs */
    strength_Q16 = silk_MUL( SILK_FIX_CONST( LOW_FREQ_SHAPING, 4 ), silk_SMLAWB( SILK_FIX_CONST( 1.0, 12 ),
   1d294:	6bb8      	ldr	r0, [r7, #56]	; 0x38
        SILK_FIX_CONST( LOW_QUALITY_LOW_FREQ_SHAPING_DECR, 13 ), psEnc->sCmn.input_quality_bands_Q15[ 0 ] - SILK_FIX_CONST( 1.0, 15 ) ) );
    strength_Q16 = silk_RSHIFT( silk_MUL( strength_Q16, psEnc->sCmn.speech_activity_Q8 ), 8 );
   1d296:	f241 11b4 	movw	r1, #4532	; 0x11b4
    strength_Q16 = silk_MUL( SILK_FIX_CONST( LOW_FREQ_SHAPING, 4 ), silk_SMLAWB( SILK_FIX_CONST( 1.0, 12 ),
   1d29a:	f241 2358 	movw	r3, #4696	; 0x1258
    strength_Q16 = silk_RSHIFT( silk_MUL( strength_Q16, psEnc->sCmn.speech_activity_Q8 ), 8 );
   1d29e:	5844      	ldr	r4, [r0, r1]
    strength_Q16 = silk_MUL( SILK_FIX_CONST( LOW_FREQ_SHAPING, 4 ), silk_SMLAWB( SILK_FIX_CONST( 1.0, 12 ),
   1d2a0:	58c3      	ldr	r3, [r0, r3]
   1d2a2:	6a39      	ldr	r1, [r7, #32]
   1d2a4:	f5a3 4300 	sub.w	r3, r3, #32768	; 0x8000
   1d2a8:	680d      	ldr	r5, [r1, #0]
    if( psEnc->sCmn.indices.signalType == TYPE_VOICED ) {
   1d2aa:	f241 219d 	movw	r1, #4765	; 0x129d
    strength_Q16 = silk_MUL( SILK_FIX_CONST( LOW_FREQ_SHAPING, 4 ), silk_SMLAWB( SILK_FIX_CONST( 1.0, 12 ),
   1d2ae:	f343 130b 	sbfx	r3, r3, #4, #12
    if( psEnc->sCmn.indices.signalType == TYPE_VOICED ) {
   1d2b2:	5641      	ldrsb	r1, [r0, r1]
    strength_Q16 = silk_MUL( SILK_FIX_CONST( LOW_FREQ_SHAPING, 4 ), silk_SMLAWB( SILK_FIX_CONST( 1.0, 12 ),
   1d2b4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
   1d2b8:	019b      	lsls	r3, r3, #6
    strength_Q16 = silk_RSHIFT( silk_MUL( strength_Q16, psEnc->sCmn.speech_activity_Q8 ), 8 );
   1d2ba:	fb04 f303 	mul.w	r3, r4, r3
    if( psEnc->sCmn.indices.signalType == TYPE_VOICED ) {
   1d2be:	2902      	cmp	r1, #2
    strength_Q16 = silk_RSHIFT( silk_MUL( strength_Q16, psEnc->sCmn.speech_activity_Q8 ), 8 );
   1d2c0:	ea4f 2023 	mov.w	r0, r3, asr #8
    if( psEnc->sCmn.indices.signalType == TYPE_VOICED ) {
   1d2c4:	f000 812f 	beq.w	1d526 <silk_noise_shape_analysis_FIX+0xde2>
            silk_SMULWB( SILK_FIX_CONST( 1.0, 16 ) - SILK_FIX_CONST( HP_NOISE_COEF, 16 ),
                silk_SMULWB( SILK_FIX_CONST( HARM_HP_NOISE_COEF, 24 ), psEnc->sCmn.speech_activity_Q8 ) );
    } else {
        b_Q14 = silk_DIV32_16( 21299, psEnc->sCmn.fs_kHz ); /* 1.3_Q0 = 21299_Q14*/
        /* Pack two coefficients in one int32 */
        psEncCtrl->LF_shp_Q14[ 0 ]  = silk_LSHIFT( SILK_FIX_CONST( 1.0, 14 ) - b_Q14 -
   1d2c8:	f649 119a 	movw	r1, #39322	; 0x999a
        b_Q14 = silk_DIV32_16( 21299, psEnc->sCmn.fs_kHz ); /* 1.3_Q0 = 21299_Q14*/
   1d2cc:	f245 3433 	movw	r4, #21299	; 0x5333
   1d2d0:	fb94 f5f5 	sdiv	r5, r4, r5
        psEncCtrl->LF_shp_Q14[ 0 ]  = silk_LSHIFT( SILK_FIX_CONST( 1.0, 14 ) - b_Q14 -
   1d2d4:	fb01 f105 	mul.w	r1, r1, r5
   1d2d8:	161c      	asrs	r4, r3, #24
   1d2da:	1409      	asrs	r1, r1, #16
   1d2dc:	b280      	uxth	r0, r0
   1d2de:	fb01 f000 	mul.w	r0, r1, r0
   1d2e2:	fb01 f104 	mul.w	r1, r1, r4
   1d2e6:	eb01 4120 	add.w	r1, r1, r0, asr #16
            silk_SMULWB( strength_Q16, silk_SMULWB( SILK_FIX_CONST( 0.6, 16 ), b_Q14 ) ), 16 );
        psEncCtrl->LF_shp_Q14[ 0 ] |= (opus_uint16)( b_Q14 - SILK_FIX_CONST( 1.0, 14 ) );
   1d2ea:	f5a5 4380 	sub.w	r3, r5, #16384	; 0x4000
        psEncCtrl->LF_shp_Q14[ 0 ]  = silk_LSHIFT( SILK_FIX_CONST( 1.0, 14 ) - b_Q14 -
   1d2ee:	f5c5 4080 	rsb	r0, r5, #16384	; 0x4000
   1d2f2:	1a41      	subs	r1, r0, r1
        psEncCtrl->LF_shp_Q14[ 0 ] |= (opus_uint16)( b_Q14 - SILK_FIX_CONST( 1.0, 14 ) );
   1d2f4:	b29b      	uxth	r3, r3
   1d2f6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   1d2fa:	6b79      	ldr	r1, [r7, #52]	; 0x34
        for( k = 1; k < psEnc->sCmn.nb_subfr; k++ ) {
   1d2fc:	f1b9 0f01 	cmp.w	r9, #1
        psEncCtrl->LF_shp_Q14[ 0 ] |= (opus_uint16)( b_Q14 - SILK_FIX_CONST( 1.0, 14 ) );
   1d300:	f8c1 314c 	str.w	r3, [r1, #332]	; 0x14c
        for( k = 1; k < psEnc->sCmn.nb_subfr; k++ ) {
   1d304:	dd0b      	ble.n	1d31e <silk_noise_shape_analysis_FIX+0xbda>
   1d306:	f1b9 0f02 	cmp.w	r9, #2
            psEncCtrl->LF_shp_Q14[ k ] = psEncCtrl->LF_shp_Q14[ 0 ];
   1d30a:	f8c1 3150 	str.w	r3, [r1, #336]	; 0x150
        for( k = 1; k < psEnc->sCmn.nb_subfr; k++ ) {
   1d30e:	d006      	beq.n	1d31e <silk_noise_shape_analysis_FIX+0xbda>
   1d310:	f1b9 0f03 	cmp.w	r9, #3
            psEncCtrl->LF_shp_Q14[ k ] = psEncCtrl->LF_shp_Q14[ 0 ];
   1d314:	f8c1 3154 	str.w	r3, [r1, #340]	; 0x154
        for( k = 1; k < psEnc->sCmn.nb_subfr; k++ ) {
   1d318:	d001      	beq.n	1d31e <silk_noise_shape_analysis_FIX+0xbda>
            psEncCtrl->LF_shp_Q14[ k ] = psEncCtrl->LF_shp_Q14[ 0 ];
   1d31a:	f8c1 3158 	str.w	r3, [r1, #344]	; 0x158
    if( x <= 0 ) {
   1d31e:	f8df 81e0 	ldr.w	r8, [pc, #480]	; 1d500 <silk_noise_shape_analysis_FIX+0xdbc>

        /* Less harmonic noise shaping for less periodic signals */
        HarmShapeGain_Q16 = silk_SMULWB( silk_LSHIFT( HarmShapeGain_Q16, 1 ),
            silk_SQRT_APPROX( silk_LSHIFT( psEnc->LTPCorr_Q15, 15 ) ) );
    } else {
        HarmShapeGain_Q16 = 0;
   1d322:	2200      	movs	r2, #0
   1d324:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1d326:	f503 5ee0 	add.w	lr, r3, #7168	; 0x1c00
   1d32a:	e9de 5002 	ldrd	r5, r0, [lr, #8]
    /*************************/
    /* Smooth over subframes */
    /*************************/
    for( k = 0; k < MAX_NB_SUBFR; k++ ) {
        psShapeSt->HarmShapeGain_smth_Q16 =
            silk_SMLAWB( psShapeSt->HarmShapeGain_smth_Q16, HarmShapeGain_Q16 - psShapeSt->HarmShapeGain_smth_Q16, SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d32e:	1b51      	subs	r1, r2, r5
   1d330:	f246 6366 	movw	r3, #26214	; 0x6666
   1d334:	fa1f fc81 	uxth.w	ip, r1
   1d338:	1409      	asrs	r1, r1, #16
        psShapeSt->Tilt_smth_Q16 =
            silk_SMLAWB( psShapeSt->Tilt_smth_Q16,          Tilt_Q16          - psShapeSt->Tilt_smth_Q16,          SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d33a:	eba8 0400 	sub.w	r4, r8, r0
            silk_SMLAWB( psShapeSt->HarmShapeGain_smth_Q16, HarmShapeGain_Q16 - psShapeSt->HarmShapeGain_smth_Q16, SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d33e:	fb03 fc0c 	mul.w	ip, r3, ip
   1d342:	fb03 f101 	mul.w	r1, r3, r1
   1d346:	eb01 411c 	add.w	r1, r1, ip, lsr #16
            silk_SMLAWB( psShapeSt->Tilt_smth_Q16,          Tilt_Q16          - psShapeSt->Tilt_smth_Q16,          SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d34a:	b2a6      	uxth	r6, r4
   1d34c:	1424      	asrs	r4, r4, #16
            silk_SMLAWB( psShapeSt->HarmShapeGain_smth_Q16, HarmShapeGain_Q16 - psShapeSt->HarmShapeGain_smth_Q16, SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d34e:	eb01 0c05 	add.w	ip, r1, r5
            silk_SMLAWB( psShapeSt->Tilt_smth_Q16,          Tilt_Q16          - psShapeSt->Tilt_smth_Q16,          SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d352:	fb03 f606 	mul.w	r6, r3, r6
   1d356:	fb03 f404 	mul.w	r4, r3, r4
            silk_SMLAWB( psShapeSt->HarmShapeGain_smth_Q16, HarmShapeGain_Q16 - psShapeSt->HarmShapeGain_smth_Q16, SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d35a:	eba2 010c 	sub.w	r1, r2, ip
            silk_SMLAWB( psShapeSt->Tilt_smth_Q16,          Tilt_Q16          - psShapeSt->Tilt_smth_Q16,          SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d35e:	eb04 4416 	add.w	r4, r4, r6, lsr #16
   1d362:	4404      	add	r4, r0
            silk_SMLAWB( psShapeSt->HarmShapeGain_smth_Q16, HarmShapeGain_Q16 - psShapeSt->HarmShapeGain_smth_Q16, SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d364:	b28e      	uxth	r6, r1
   1d366:	1409      	asrs	r1, r1, #16
            silk_SMLAWB( psShapeSt->Tilt_smth_Q16,          Tilt_Q16          - psShapeSt->Tilt_smth_Q16,          SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d368:	eba8 0004 	sub.w	r0, r8, r4
            silk_SMLAWB( psShapeSt->HarmShapeGain_smth_Q16, HarmShapeGain_Q16 - psShapeSt->HarmShapeGain_smth_Q16, SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d36c:	fb03 f606 	mul.w	r6, r3, r6
   1d370:	fb03 f101 	mul.w	r1, r3, r1
   1d374:	eb01 4116 	add.w	r1, r1, r6, lsr #16
            silk_SMLAWB( psShapeSt->Tilt_smth_Q16,          Tilt_Q16          - psShapeSt->Tilt_smth_Q16,          SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d378:	b285      	uxth	r5, r0
   1d37a:	1400      	asrs	r0, r0, #16
            silk_SMLAWB( psShapeSt->HarmShapeGain_smth_Q16, HarmShapeGain_Q16 - psShapeSt->HarmShapeGain_smth_Q16, SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d37c:	eb01 060c 	add.w	r6, r1, ip
            silk_SMLAWB( psShapeSt->Tilt_smth_Q16,          Tilt_Q16          - psShapeSt->Tilt_smth_Q16,          SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d380:	fb03 f505 	mul.w	r5, r3, r5
   1d384:	fb03 f000 	mul.w	r0, r3, r0
   1d388:	eb00 4015 	add.w	r0, r0, r5, lsr #16
            silk_SMLAWB( psShapeSt->HarmShapeGain_smth_Q16, HarmShapeGain_Q16 - psShapeSt->HarmShapeGain_smth_Q16, SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d38c:	1b95      	subs	r5, r2, r6
            silk_SMLAWB( psShapeSt->Tilt_smth_Q16,          Tilt_Q16          - psShapeSt->Tilt_smth_Q16,          SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d38e:	4420      	add	r0, r4
            silk_SMLAWB( psShapeSt->HarmShapeGain_smth_Q16, HarmShapeGain_Q16 - psShapeSt->HarmShapeGain_smth_Q16, SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d390:	fa1f f985 	uxth.w	r9, r5
   1d394:	142d      	asrs	r5, r5, #16
            silk_SMLAWB( psShapeSt->Tilt_smth_Q16,          Tilt_Q16          - psShapeSt->Tilt_smth_Q16,          SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d396:	eba8 0100 	sub.w	r1, r8, r0
            silk_SMLAWB( psShapeSt->HarmShapeGain_smth_Q16, HarmShapeGain_Q16 - psShapeSt->HarmShapeGain_smth_Q16, SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d39a:	fb03 f909 	mul.w	r9, r3, r9
   1d39e:	fb03 f505 	mul.w	r5, r3, r5
   1d3a2:	eb05 4519 	add.w	r5, r5, r9, lsr #16
            silk_SMLAWB( psShapeSt->Tilt_smth_Q16,          Tilt_Q16          - psShapeSt->Tilt_smth_Q16,          SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d3a6:	fa1f f981 	uxth.w	r9, r1
   1d3aa:	1409      	asrs	r1, r1, #16
            silk_SMLAWB( psShapeSt->HarmShapeGain_smth_Q16, HarmShapeGain_Q16 - psShapeSt->HarmShapeGain_smth_Q16, SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d3ac:	4435      	add	r5, r6
            silk_SMLAWB( psShapeSt->Tilt_smth_Q16,          Tilt_Q16          - psShapeSt->Tilt_smth_Q16,          SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d3ae:	fb03 f909 	mul.w	r9, r3, r9
   1d3b2:	fb03 f101 	mul.w	r1, r3, r1
            silk_SMLAWB( psShapeSt->HarmShapeGain_smth_Q16, HarmShapeGain_Q16 - psShapeSt->HarmShapeGain_smth_Q16, SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d3b6:	1b52      	subs	r2, r2, r5
            silk_SMLAWB( psShapeSt->Tilt_smth_Q16,          Tilt_Q16          - psShapeSt->Tilt_smth_Q16,          SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d3b8:	eb01 4119 	add.w	r1, r1, r9, lsr #16
   1d3bc:	4401      	add	r1, r0
            silk_SMLAWB( psShapeSt->HarmShapeGain_smth_Q16, HarmShapeGain_Q16 - psShapeSt->HarmShapeGain_smth_Q16, SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d3be:	fa1f f982 	uxth.w	r9, r2
   1d3c2:	1412      	asrs	r2, r2, #16
            silk_SMLAWB( psShapeSt->Tilt_smth_Q16,          Tilt_Q16          - psShapeSt->Tilt_smth_Q16,          SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d3c4:	eba8 0801 	sub.w	r8, r8, r1
            silk_SMLAWB( psShapeSt->HarmShapeGain_smth_Q16, HarmShapeGain_Q16 - psShapeSt->HarmShapeGain_smth_Q16, SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d3c8:	fb03 f909 	mul.w	r9, r3, r9
   1d3cc:	fb03 f202 	mul.w	r2, r3, r2
   1d3d0:	eb02 4219 	add.w	r2, r2, r9, lsr #16
            silk_SMLAWB( psShapeSt->Tilt_smth_Q16,          Tilt_Q16          - psShapeSt->Tilt_smth_Q16,          SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d3d4:	fa1f f988 	uxth.w	r9, r8
   1d3d8:	ea4f 4828 	mov.w	r8, r8, asr #16
   1d3dc:	fb03 f909 	mul.w	r9, r3, r9
   1d3e0:	fb03 f308 	mul.w	r3, r3, r8
   1d3e4:	eb03 4319 	add.w	r3, r3, r9, lsr #16
            silk_SMLAWB( psShapeSt->HarmShapeGain_smth_Q16, HarmShapeGain_Q16 - psShapeSt->HarmShapeGain_smth_Q16, SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d3e8:	442a      	add	r2, r5
            silk_SMLAWB( psShapeSt->Tilt_smth_Q16,          Tilt_Q16          - psShapeSt->Tilt_smth_Q16,          SILK_FIX_CONST( SUBFR_SMTH_COEF, 16 ) );
   1d3ea:	440b      	add	r3, r1

        psEncCtrl->HarmShapeGain_Q14[ k ] = ( opus_int )silk_RSHIFT_ROUND( psShapeSt->HarmShapeGain_smth_Q16, 2 );
        psEncCtrl->Tilt_Q14[ k ]          = ( opus_int )silk_RSHIFT_ROUND( psShapeSt->Tilt_smth_Q16,          2 );
   1d3ec:	1064      	asrs	r4, r4, #1
   1d3ee:	1040      	asrs	r0, r0, #1
   1d3f0:	1049      	asrs	r1, r1, #1
   1d3f2:	f104 0801 	add.w	r8, r4, #1
   1d3f6:	1c44      	adds	r4, r0, #1
   1d3f8:	1c48      	adds	r0, r1, #1
        psEncCtrl->HarmShapeGain_Q14[ k ] = ( opus_int )silk_RSHIFT_ROUND( psShapeSt->HarmShapeGain_smth_Q16, 2 );
   1d3fa:	1051      	asrs	r1, r2, #1
   1d3fc:	3101      	adds	r1, #1
   1d3fe:	106d      	asrs	r5, r5, #1
   1d400:	ea4f 0961 	mov.w	r9, r1, asr #1
   1d404:	3501      	adds	r5, #1
        psEncCtrl->Tilt_Q14[ k ]          = ( opus_int )silk_RSHIFT_ROUND( psShapeSt->Tilt_smth_Q16,          2 );
   1d406:	1059      	asrs	r1, r3, #1
        psEncCtrl->HarmShapeGain_Q14[ k ] = ( opus_int )silk_RSHIFT_ROUND( psShapeSt->HarmShapeGain_smth_Q16, 2 );
   1d408:	ea4f 0c6c 	mov.w	ip, ip, asr #1
   1d40c:	1076      	asrs	r6, r6, #1
   1d40e:	ea4f 0a65 	mov.w	sl, r5, asr #1
   1d412:	f10c 0c01 	add.w	ip, ip, #1
   1d416:	6b7d      	ldr	r5, [r7, #52]	; 0x34
   1d418:	3601      	adds	r6, #1
        psEncCtrl->Tilt_Q14[ k ]          = ( opus_int )silk_RSHIFT_ROUND( psShapeSt->Tilt_smth_Q16,          2 );
   1d41a:	3101      	adds	r1, #1
        psEncCtrl->HarmShapeGain_Q14[ k ] = ( opus_int )silk_RSHIFT_ROUND( psShapeSt->HarmShapeGain_smth_Q16, 2 );
   1d41c:	ea4f 0c6c 	mov.w	ip, ip, asr #1
   1d420:	1076      	asrs	r6, r6, #1
        psEncCtrl->Tilt_Q14[ k ]          = ( opus_int )silk_RSHIFT_ROUND( psShapeSt->Tilt_smth_Q16,          2 );
   1d422:	ea4f 0868 	mov.w	r8, r8, asr #1
   1d426:	1064      	asrs	r4, r4, #1
   1d428:	1040      	asrs	r0, r0, #1
   1d42a:	1049      	asrs	r1, r1, #1
    }
    RESTORE_STACK;
}
   1d42c:	f507 77d6 	add.w	r7, r7, #428	; 0x1ac
        psEncCtrl->HarmShapeGain_Q14[ k ] = ( opus_int )silk_RSHIFT_ROUND( psShapeSt->HarmShapeGain_smth_Q16, 2 );
   1d430:	f8c5 c16c 	str.w	ip, [r5, #364]	; 0x16c
   1d434:	f8c5 6170 	str.w	r6, [r5, #368]	; 0x170
   1d438:	f8c5 a174 	str.w	sl, [r5, #372]	; 0x174
   1d43c:	f8c5 9178 	str.w	r9, [r5, #376]	; 0x178
        psEncCtrl->Tilt_Q14[ k ]          = ( opus_int )silk_RSHIFT_ROUND( psShapeSt->Tilt_smth_Q16,          2 );
   1d440:	f8c5 815c 	str.w	r8, [r5, #348]	; 0x15c
   1d444:	f8c5 4160 	str.w	r4, [r5, #352]	; 0x160
   1d448:	f8c5 0164 	str.w	r0, [r5, #356]	; 0x164
   1d44c:	f8c5 1168 	str.w	r1, [r5, #360]	; 0x168
   1d450:	e9ce 2302 	strd	r2, r3, [lr, #8]
}
   1d454:	46bd      	mov	sp, r7
   1d456:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1d45a:	233c      	movs	r3, #60	; 0x3c
    a32_nrm = silk_LSHIFT(a32, a_headrm);                                       /* Q: a_headrm                  */
   1d45c:	6979      	ldr	r1, [r7, #20]
   1d45e:	65fb      	str	r3, [r7, #92]	; 0x5c
   1d460:	231f      	movs	r3, #31
   1d462:	fa01 f303 	lsl.w	r3, r1, r3
   1d466:	66bb      	str	r3, [r7, #104]	; 0x68
   1d468:	2a00      	cmp	r2, #0
   1d46a:	f47f ac3c 	bne.w	1cce6 <silk_noise_shape_analysis_FIX+0x5a2>
   1d46e:	f04f 0c1f 	mov.w	ip, #31
   1d472:	4619      	mov	r1, r3
   1d474:	e440      	b.n	1ccf8 <silk_noise_shape_analysis_FIX+0x5b4>
        return silk_LSHIFT_SAT32(result, -lshift);
   1d476:	f1ce 0e00 	rsb	lr, lr, #0
   1d47a:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
   1d47e:	fa42 f20e 	asr.w	r2, r2, lr
   1d482:	4294      	cmp	r4, r2
   1d484:	dc2e      	bgt.n	1d4e4 <silk_noise_shape_analysis_FIX+0xda0>
   1d486:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   1d48a:	fa42 f20e 	asr.w	r2, r2, lr
   1d48e:	4294      	cmp	r4, r2
   1d490:	bfb8      	it	lt
   1d492:	4614      	movlt	r4, r2
   1d494:	fa04 fe0e 	lsl.w	lr, r4, lr
   1d498:	f7ff bbc6 	b.w	1cc28 <silk_noise_shape_analysis_FIX+0x4e4>
        return silk_LSHIFT_SAT32(result, -lshift);
   1d49c:	4282      	cmp	r2, r0
   1d49e:	bfb8      	it	lt
   1d4a0:	4602      	movlt	r2, r0
   1d4a2:	e617      	b.n	1d0d4 <silk_noise_shape_analysis_FIX+0x990>
        return silk_LSHIFT_SAT32(result, -lshift);
   1d4a4:	f04f 4a00 	mov.w	sl, #2147483648	; 0x80000000
   1d4a8:	fa4a fa0e 	asr.w	sl, sl, lr
   1d4ac:	4550      	cmp	r0, sl
   1d4ae:	bfb8      	it	lt
   1d4b0:	4650      	movlt	r0, sl
   1d4b2:	e5fa      	b.n	1d0aa <silk_noise_shape_analysis_FIX+0x966>
        return silk_LSHIFT_SAT32(result, -lshift);
   1d4b4:	429a      	cmp	r2, r3
   1d4b6:	bfb8      	it	lt
   1d4b8:	461a      	movlt	r2, r3
   1d4ba:	e622      	b.n	1d102 <silk_noise_shape_analysis_FIX+0x9be>
   1d4bc:	f1c1 0118 	rsb	r1, r1, #24
   1d4c0:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   1d4c4:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
   1d4c8:	410a      	asrs	r2, r1
   1d4ca:	410b      	asrs	r3, r1
   1d4cc:	429a      	cmp	r2, r3
   1d4ce:	dd0b      	ble.n	1d4e8 <silk_noise_shape_analysis_FIX+0xda4>
   1d4d0:	4290      	cmp	r0, r2
   1d4d2:	f340 810a 	ble.w	1d6ea <silk_noise_shape_analysis_FIX+0xfa6>
   1d4d6:	408a      	lsls	r2, r1
   1d4d8:	e43c      	b.n	1cd54 <silk_noise_shape_analysis_FIX+0x610>
   1d4da:	f06f 0402 	mvn.w	r4, #2
   1d4de:	201f      	movs	r0, #31
   1d4e0:	f7ff ba38 	b.w	1c954 <silk_noise_shape_analysis_FIX+0x210>
        return silk_LSHIFT_SAT32(result, -lshift);
   1d4e4:	4614      	mov	r4, r2
   1d4e6:	e7d5      	b.n	1d494 <silk_noise_shape_analysis_FIX+0xd50>
        return silk_LSHIFT_SAT32(result, -lshift);
   1d4e8:	4298      	cmp	r0, r3
   1d4ea:	f340 8105 	ble.w	1d6f8 <silk_noise_shape_analysis_FIX+0xfb4>
   1d4ee:	461a      	mov	r2, r3
   1d4f0:	408a      	lsls	r2, r1
   1d4f2:	e42f      	b.n	1cd54 <silk_noise_shape_analysis_FIX+0x610>
        warping_Q16 = 0;
   1d4f4:	2300      	movs	r3, #0
   1d4f6:	60fb      	str	r3, [r7, #12]
   1d4f8:	f7ff ba62 	b.w	1c9c0 <silk_noise_shape_analysis_FIX+0x27c>
   1d4fc:	3ffffffe 	.word	0x3ffffffe
   1d500:	ffffc000 	.word	0xffffc000
   1d504:	4264      	negs	r4, r4
   1d506:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
   1d50a:	4121      	asrs	r1, r4
   1d50c:	428b      	cmp	r3, r1
   1d50e:	f300 80ea 	bgt.w	1d6e6 <silk_noise_shape_analysis_FIX+0xfa2>
   1d512:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
   1d516:	4121      	asrs	r1, r4
   1d518:	428b      	cmp	r3, r1
   1d51a:	bfb8      	it	lt
   1d51c:	460b      	movlt	r3, r1
   1d51e:	40a3      	lsls	r3, r4
   1d520:	613b      	str	r3, [r7, #16]
   1d522:	f7ff ba36 	b.w	1c992 <silk_noise_shape_analysis_FIX+0x24e>
        for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1d526:	f1b9 0f00 	cmp.w	r9, #0
        opus_int fs_kHz_inv = silk_DIV32_16( SILK_FIX_CONST( 0.2, 14 ), psEnc->sCmn.fs_kHz );
   1d52a:	f640 46cd 	movw	r6, #3277	; 0xccd
   1d52e:	fb96 f6f5 	sdiv	r6, r6, r5
        for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1d532:	dd6c      	ble.n	1d60e <silk_noise_shape_analysis_FIX+0xeca>
            b_Q14 = fs_kHz_inv + silk_DIV32_16( SILK_FIX_CONST( 3.0, 14 ), psEncCtrl->pitchL[ k ] );
   1d534:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   1d536:	f44f 4540 	mov.w	r5, #49152	; 0xc000
   1d53a:	6fd1      	ldr	r1, [r2, #124]	; 0x7c
   1d53c:	fb95 f1f1 	sdiv	r1, r5, r1
   1d540:	eb01 0c06 	add.w	ip, r1, r6
   1d544:	b280      	uxth	r0, r0
            psEncCtrl->LF_shp_Q14[ k ]  = silk_LSHIFT( SILK_FIX_CONST( 1.0, 14 ) - b_Q14 - silk_SMULWB( strength_Q16, b_Q14 ), 16 );
   1d546:	1619      	asrs	r1, r3, #24
   1d548:	fa0f f38c 	sxth.w	r3, ip
   1d54c:	fb00 fe03 	mul.w	lr, r0, r3
   1d550:	fb03 f301 	mul.w	r3, r3, r1
   1d554:	eb03 4e2e 	add.w	lr, r3, lr, asr #16
   1d558:	f5cc 4880 	rsb	r8, ip, #16384	; 0x4000
            psEncCtrl->LF_shp_Q14[ k ] |= (opus_uint16)( b_Q14 - SILK_FIX_CONST( 1.0, 14 ) );
   1d55c:	f5ac 4380 	sub.w	r3, ip, #16384	; 0x4000
            psEncCtrl->LF_shp_Q14[ k ]  = silk_LSHIFT( SILK_FIX_CONST( 1.0, 14 ) - b_Q14 - silk_SMULWB( strength_Q16, b_Q14 ), 16 );
   1d560:	eba8 0e0e 	sub.w	lr, r8, lr
            psEncCtrl->LF_shp_Q14[ k ] |= (opus_uint16)( b_Q14 - SILK_FIX_CONST( 1.0, 14 ) );
   1d564:	b29b      	uxth	r3, r3
   1d566:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
        for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1d56a:	f1b9 0f01 	cmp.w	r9, #1
            psEncCtrl->LF_shp_Q14[ k ] |= (opus_uint16)( b_Q14 - SILK_FIX_CONST( 1.0, 14 ) );
   1d56e:	f8c2 314c 	str.w	r3, [r2, #332]	; 0x14c
        for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1d572:	d04c      	beq.n	1d60e <silk_noise_shape_analysis_FIX+0xeca>
            b_Q14 = fs_kHz_inv + silk_DIV32_16( SILK_FIX_CONST( 3.0, 14 ), psEncCtrl->pitchL[ k ] );
   1d574:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
   1d578:	fb95 f3f3 	sdiv	r3, r5, r3
   1d57c:	4433      	add	r3, r6
            psEncCtrl->LF_shp_Q14[ k ]  = silk_LSHIFT( SILK_FIX_CONST( 1.0, 14 ) - b_Q14 - silk_SMULWB( strength_Q16, b_Q14 ), 16 );
   1d57e:	fa0f fc83 	sxth.w	ip, r3
   1d582:	fb00 fe0c 	mul.w	lr, r0, ip
   1d586:	fb0c fc01 	mul.w	ip, ip, r1
   1d58a:	eb0c 4c2e 	add.w	ip, ip, lr, asr #16
   1d58e:	f5c3 4e80 	rsb	lr, r3, #16384	; 0x4000
            psEncCtrl->LF_shp_Q14[ k ] |= (opus_uint16)( b_Q14 - SILK_FIX_CONST( 1.0, 14 ) );
   1d592:	f5a3 4380 	sub.w	r3, r3, #16384	; 0x4000
            psEncCtrl->LF_shp_Q14[ k ]  = silk_LSHIFT( SILK_FIX_CONST( 1.0, 14 ) - b_Q14 - silk_SMULWB( strength_Q16, b_Q14 ), 16 );
   1d596:	ebae 0c0c 	sub.w	ip, lr, ip
            psEncCtrl->LF_shp_Q14[ k ] |= (opus_uint16)( b_Q14 - SILK_FIX_CONST( 1.0, 14 ) );
   1d59a:	b29b      	uxth	r3, r3
   1d59c:	ea43 430c 	orr.w	r3, r3, ip, lsl #16
        for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1d5a0:	f1b9 0f02 	cmp.w	r9, #2
            psEncCtrl->LF_shp_Q14[ k ] |= (opus_uint16)( b_Q14 - SILK_FIX_CONST( 1.0, 14 ) );
   1d5a4:	f8c2 3150 	str.w	r3, [r2, #336]	; 0x150
        for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1d5a8:	d031      	beq.n	1d60e <silk_noise_shape_analysis_FIX+0xeca>
            b_Q14 = fs_kHz_inv + silk_DIV32_16( SILK_FIX_CONST( 3.0, 14 ), psEncCtrl->pitchL[ k ] );
   1d5aa:	f8d2 3084 	ldr.w	r3, [r2, #132]	; 0x84
   1d5ae:	fb95 f3f3 	sdiv	r3, r5, r3
   1d5b2:	4433      	add	r3, r6
            psEncCtrl->LF_shp_Q14[ k ]  = silk_LSHIFT( SILK_FIX_CONST( 1.0, 14 ) - b_Q14 - silk_SMULWB( strength_Q16, b_Q14 ), 16 );
   1d5b4:	fa0f fc83 	sxth.w	ip, r3
   1d5b8:	fb00 fe0c 	mul.w	lr, r0, ip
   1d5bc:	fb0c fc01 	mul.w	ip, ip, r1
   1d5c0:	eb0c 4c2e 	add.w	ip, ip, lr, asr #16
   1d5c4:	f5c3 4e80 	rsb	lr, r3, #16384	; 0x4000
            psEncCtrl->LF_shp_Q14[ k ] |= (opus_uint16)( b_Q14 - SILK_FIX_CONST( 1.0, 14 ) );
   1d5c8:	f5a3 4380 	sub.w	r3, r3, #16384	; 0x4000
            psEncCtrl->LF_shp_Q14[ k ]  = silk_LSHIFT( SILK_FIX_CONST( 1.0, 14 ) - b_Q14 - silk_SMULWB( strength_Q16, b_Q14 ), 16 );
   1d5cc:	ebae 0c0c 	sub.w	ip, lr, ip
            psEncCtrl->LF_shp_Q14[ k ] |= (opus_uint16)( b_Q14 - SILK_FIX_CONST( 1.0, 14 ) );
   1d5d0:	b29b      	uxth	r3, r3
   1d5d2:	ea43 430c 	orr.w	r3, r3, ip, lsl #16
        for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1d5d6:	f1b9 0f03 	cmp.w	r9, #3
            psEncCtrl->LF_shp_Q14[ k ] |= (opus_uint16)( b_Q14 - SILK_FIX_CONST( 1.0, 14 ) );
   1d5da:	f8c2 3154 	str.w	r3, [r2, #340]	; 0x154
        for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1d5de:	d016      	beq.n	1d60e <silk_noise_shape_analysis_FIX+0xeca>
            b_Q14 = fs_kHz_inv + silk_DIV32_16( SILK_FIX_CONST( 3.0, 14 ), psEncCtrl->pitchL[ k ] );
   1d5e0:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
   1d5e4:	fb95 f3f3 	sdiv	r3, r5, r3
   1d5e8:	441e      	add	r6, r3
            psEncCtrl->LF_shp_Q14[ k ]  = silk_LSHIFT( SILK_FIX_CONST( 1.0, 14 ) - b_Q14 - silk_SMULWB( strength_Q16, b_Q14 ), 16 );
   1d5ea:	b233      	sxth	r3, r6
   1d5ec:	fb00 f003 	mul.w	r0, r0, r3
   1d5f0:	fb03 f301 	mul.w	r3, r3, r1
   1d5f4:	eb03 4020 	add.w	r0, r3, r0, asr #16
   1d5f8:	f5c6 4280 	rsb	r2, r6, #16384	; 0x4000
            psEncCtrl->LF_shp_Q14[ k ] |= (opus_uint16)( b_Q14 - SILK_FIX_CONST( 1.0, 14 ) );
   1d5fc:	f5a6 4380 	sub.w	r3, r6, #16384	; 0x4000
            psEncCtrl->LF_shp_Q14[ k ]  = silk_LSHIFT( SILK_FIX_CONST( 1.0, 14 ) - b_Q14 - silk_SMULWB( strength_Q16, b_Q14 ), 16 );
   1d600:	1a10      	subs	r0, r2, r0
            psEncCtrl->LF_shp_Q14[ k ] |= (opus_uint16)( b_Q14 - SILK_FIX_CONST( 1.0, 14 ) );
   1d602:	b29b      	uxth	r3, r3
   1d604:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   1d606:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
   1d60a:	f8c2 3158 	str.w	r3, [r2, #344]	; 0x158
            silk_SMULWB( SILK_FIX_CONST( 1.0, 16 ) - SILK_FIX_CONST( HP_NOISE_COEF, 16 ),
   1d60e:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   1d612:	eb04 0343 	add.w	r3, r4, r3, lsl #1
   1d616:	b220      	sxth	r0, r4
   1d618:	f649 129a 	movw	r2, #39322	; 0x999a
   1d61c:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
   1d620:	fb02 f200 	mul.w	r2, r2, r0
        HarmShapeGain_Q16 = silk_SMULWB( silk_LSHIFT( HarmShapeGain_Q16, 1 ),
   1d624:	f242 11b0 	movw	r1, #8624	; 0x21b0
            silk_SMULWB( SILK_FIX_CONST( 1.0, 16 ) - SILK_FIX_CONST( HP_NOISE_COEF, 16 ),
   1d628:	eb03 4322 	add.w	r3, r3, r2, asr #16
        HarmShapeGain_Q16 = silk_SMULWB( silk_LSHIFT( HarmShapeGain_Q16, 1 ),
   1d62c:	6bba      	ldr	r2, [r7, #56]	; 0x38
   1d62e:	5854      	ldr	r4, [r2, r1]
        HarmShapeGain_Q16 = silk_SMLAWB( SILK_FIX_CONST( HARMONIC_SHAPING, 16 ),
   1d630:	6b7a      	ldr	r2, [r7, #52]	; 0x34
        Tilt_Q16 = - SILK_FIX_CONST( HP_NOISE_COEF, 16 ) -
   1d632:	4940      	ldr	r1, [pc, #256]	; (1d734 <silk_noise_shape_analysis_FIX+0xff0>)
        HarmShapeGain_Q16 = silk_SMLAWB( SILK_FIX_CONST( HARMONIC_SHAPING, 16 ),
   1d634:	f8d2 5184 	ldr.w	r5, [r2, #388]	; 0x184
   1d638:	f8d2 2180 	ldr.w	r2, [r2, #384]	; 0x180
            silk_SMULWB( SILK_FIX_CONST( 1.0, 16 ) - SILK_FIX_CONST( HP_NOISE_COEF, 16 ),
   1d63c:	b21b      	sxth	r3, r3
        HarmShapeGain_Q16 = silk_SMULWB( silk_LSHIFT( HarmShapeGain_Q16, 1 ),
   1d63e:	03e4      	lsls	r4, r4, #15
            silk_SMULWB( SILK_FIX_CONST( 1.0, 16 ) - SILK_FIX_CONST( HP_NOISE_COEF, 16 ),
   1d640:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    if( x <= 0 ) {
   1d644:	2c00      	cmp	r4, #0
        Tilt_Q16 = - SILK_FIX_CONST( HP_NOISE_COEF, 16 ) -
   1d646:	eba1 08a3 	sub.w	r8, r1, r3, asr #2
   1d64a:	dd6c      	ble.n	1d726 <silk_noise_shape_analysis_FIX+0xfe2>
   1d64c:	fab4 f084 	clz	r0, r4
    * frac_Q7 = silk_ROR32(in, 24 - lzeros) & 0x7f;
   1d650:	f1c0 0118 	rsb	r1, r0, #24
    if( rot == 0 ) {
   1d654:	2900      	cmp	r1, #0
   1d656:	d155      	bne.n	1d704 <silk_noise_shape_analysis_FIX+0xfc0>
        HarmShapeGain_Q16 = silk_SMLAWB( SILK_FIX_CONST( HARMONIC_SHAPING, 16 ),
   1d658:	012d      	lsls	r5, r5, #4
   1d65a:	426c      	negs	r4, r5
   1d65c:	f5c5 2580 	rsb	r5, r5, #262144	; 0x40000
   1d660:	b213      	sxth	r3, r2
   1d662:	b2a4      	uxth	r4, r4
   1d664:	142a      	asrs	r2, r5, #16
   1d666:	fb03 f404 	mul.w	r4, r3, r4
   1d66a:	fb03 f302 	mul.w	r3, r3, r2
   1d66e:	eb03 4324 	add.w	r3, r3, r4, asr #16
   1d672:	425d      	negs	r5, r3
   1d674:	f5c3 3380 	rsb	r3, r3, #65536	; 0x10000
   1d678:	141a      	asrs	r2, r3, #16
   1d67a:	b2ad      	uxth	r5, r5
   1d67c:	f243 3333 	movw	r3, #13107	; 0x3333
        y = 32768;
   1d680:	f010 0f01 	tst.w	r0, #1
   1d684:	fb03 f505 	mul.w	r5, r3, r5
   1d688:	f24b 4486 	movw	r4, #46214	; 0xb486
   1d68c:	fb03 f302 	mul.w	r3, r3, r2
    y >>= silk_RSHIFT(lz, 1);
   1d690:	ea4f 0060 	mov.w	r0, r0, asr #1
        y = 32768;
   1d694:	bf0c      	ite	eq
   1d696:	4622      	moveq	r2, r4
   1d698:	f44f 4200 	movne.w	r2, #32768	; 0x8000
   1d69c:	eb03 4315 	add.w	r3, r3, r5, lsr #16
    y >>= silk_RSHIFT(lz, 1);
   1d6a0:	4102      	asrs	r2, r0
   1d6a2:	f503 4399 	add.w	r3, r3, #19584	; 0x4c80
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   1d6a6:	fb01 f102 	mul.w	r1, r1, r2
   1d6aa:	334d      	adds	r3, #77	; 0x4d
   1d6ac:	eb02 4221 	add.w	r2, r2, r1, asr #16
        HarmShapeGain_Q16 = silk_SMULWB( silk_LSHIFT( HarmShapeGain_Q16, 1 ),
   1d6b0:	005b      	lsls	r3, r3, #1
   1d6b2:	b212      	sxth	r2, r2
   1d6b4:	b299      	uxth	r1, r3
   1d6b6:	141b      	asrs	r3, r3, #16
   1d6b8:	fb02 f101 	mul.w	r1, r2, r1
   1d6bc:	fb02 f303 	mul.w	r3, r2, r3
   1d6c0:	eb03 4221 	add.w	r2, r3, r1, asr #16
   1d6c4:	e62e      	b.n	1d324 <silk_noise_shape_analysis_FIX+0xbe0>
        SNR_adj_dB_Q7 = silk_SMLAWB( SNR_adj_dB_Q7, SILK_FIX_CONST( HARM_SNR_INCR_dB, 8 ), psEnc->LTPCorr_Q15 );
   1d6c6:	f242 11b0 	movw	r1, #8624	; 0x21b0
   1d6ca:	4604      	mov	r4, r0
        psEnc->sCmn.indices.quantOffsetType = 0;
   1d6cc:	f241 239e 	movw	r3, #4766	; 0x129e
        SNR_adj_dB_Q7 = silk_SMLAWB( SNR_adj_dB_Q7, SILK_FIX_CONST( HARM_SNR_INCR_dB, 8 ), psEnc->LTPCorr_Q15 );
   1d6d0:	5e40      	ldrsh	r0, [r0, r1]
        psEnc->sCmn.indices.quantOffsetType = 0;
   1d6d2:	2100      	movs	r1, #0
        SNR_adj_dB_Q7 = silk_SMLAWB( SNR_adj_dB_Q7, SILK_FIX_CONST( HARM_SNR_INCR_dB, 8 ), psEnc->LTPCorr_Q15 );
   1d6d4:	eb08 10e0 	add.w	r0, r8, r0, asr #7
        psEnc->sCmn.indices.quantOffsetType = 0;
   1d6d8:	54e1      	strb	r1, [r4, r3]
   1d6da:	f504 538f 	add.w	r3, r4, #4576	; 0x11e0
        SNR_adj_dB_Q7 = silk_SMLAWB( SNR_adj_dB_Q7, SILK_FIX_CONST( HARM_SNR_INCR_dB, 8 ), psEnc->LTPCorr_Q15 );
   1d6de:	6078      	str	r0, [r7, #4]
   1d6e0:	623b      	str	r3, [r7, #32]
   1d6e2:	f7ff b90f 	b.w	1c904 <silk_noise_shape_analysis_FIX+0x1c0>
        return silk_LSHIFT_SAT32(result, -lshift);
   1d6e6:	460b      	mov	r3, r1
   1d6e8:	e719      	b.n	1d51e <silk_noise_shape_analysis_FIX+0xdda>
   1d6ea:	4298      	cmp	r0, r3
   1d6ec:	4602      	mov	r2, r0
   1d6ee:	bfb8      	it	lt
   1d6f0:	461a      	movlt	r2, r3
   1d6f2:	408a      	lsls	r2, r1
   1d6f4:	f7ff bb2e 	b.w	1cd54 <silk_noise_shape_analysis_FIX+0x610>
   1d6f8:	4282      	cmp	r2, r0
   1d6fa:	bfb8      	it	lt
   1d6fc:	4602      	movlt	r2, r0
   1d6fe:	408a      	lsls	r2, r1
   1d700:	f7ff bb28 	b.w	1cd54 <silk_noise_shape_analysis_FIX+0x610>
        return (opus_int32) ((x << m) | (x >> (32 - m)));
   1d704:	bfb6      	itet	lt
   1d706:	f101 0320 	addlt.w	r3, r1, #32
        return (opus_int32) ((x << (32 - r)) | (x >> r));
   1d70a:	fa64 f301 	rorge.w	r3, r4, r1
        return (opus_int32) ((x << m) | (x >> (32 - m)));
   1d70e:	fa64 f303 	rorlt.w	r3, r4, r3
   1d712:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   1d716:	eb03 01c3 	add.w	r1, r3, r3, lsl #3
   1d71a:	ebc3 03c1 	rsb	r3, r3, r1, lsl #3
   1d71e:	ebc3 0383 	rsb	r3, r3, r3, lsl #2
   1d722:	b299      	uxth	r1, r3
   1d724:	e798      	b.n	1d658 <silk_noise_shape_analysis_FIX+0xf14>
    if( x <= 0 ) {
   1d726:	2200      	movs	r2, #0
   1d728:	e5fc      	b.n	1d324 <silk_noise_shape_analysis_FIX+0xbe0>
        energy_variation_Q7 = 0;
   1d72a:	f04f 0a00 	mov.w	sl, #0
   1d72e:	f7ff b8da 	b.w	1c8e6 <silk_noise_shape_analysis_FIX+0x1a2>
   1d732:	bf00      	nop
   1d734:	ffffc000 	.word	0xffffc000

0001d738 <silk_process_gains_FIX>:
void silk_process_gains_FIX(
    silk_encoder_state_FIX          *psEnc,                                 /* I/O  Encoder state                                                               */
    silk_encoder_control_FIX        *psEncCtrl,                             /* I/O  Encoder control                                                             */
    opus_int                        condCoding                              /* I    The type of conditional coding to use                                       */
)
{
   1d738:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    silk_shape_state_FIX *psShapeSt = &psEnc->sShape;
    opus_int     k;
    opus_int32   s_Q16, InvMaxSqrVal_Q16, gain, gain_squared, ResNrg, ResNrgPart, quant_offset_Q10;

    /* Gain reduction when LTP coding gain is high */
    if( psEnc->sCmn.indices.signalType == TYPE_VOICED ) {
   1d73c:	f241 239d 	movw	r3, #4765	; 0x129d
{
   1d740:	b085      	sub	sp, #20
    if( psEnc->sCmn.indices.signalType == TYPE_VOICED ) {
   1d742:	56c3      	ldrsb	r3, [r0, r3]
{
   1d744:	9202      	str	r2, [sp, #8]
    if( psEnc->sCmn.indices.signalType == TYPE_VOICED ) {
   1d746:	2b02      	cmp	r3, #2
{
   1d748:	4680      	mov	r8, r0
   1d74a:	4689      	mov	r9, r1
    if( psEnc->sCmn.indices.signalType == TYPE_VOICED ) {
   1d74c:	f000 8134 	beq.w	1d9b8 <silk_process_gains_FIX+0x280>
        }
    }

    /* Limit the quantized signal */
    /* InvMaxSqrVal = pow( 2.0f, 0.33f * ( 21.0f - SNR_dB ) ) / subfr_length; */
    InvMaxSqrVal_Q16 = silk_DIV32_16( silk_log2lin(
   1d750:	f241 236c 	movw	r3, #4716	; 0x126c
   1d754:	f245 427b 	movw	r2, #21627	; 0x547b
   1d758:	f858 3003 	ldr.w	r3, [r8, r3]
   1d75c:	f5c3 530a 	rsb	r3, r3, #8832	; 0x2280
   1d760:	333e      	adds	r3, #62	; 0x3e
   1d762:	b298      	uxth	r0, r3
   1d764:	141b      	asrs	r3, r3, #16
   1d766:	fb02 f303 	mul.w	r3, r2, r3
   1d76a:	fb02 f000 	mul.w	r0, r2, r0
   1d76e:	eb03 4010 	add.w	r0, r3, r0, lsr #16
   1d772:	f7fa f961 	bl	17a38 <silk_log2lin>
        silk_SMULWB( SILK_FIX_CONST( 21 + 16 / 0.33, 7 ) - psEnc->sCmn.SNR_dB_Q7, SILK_FIX_CONST( 0.33, 16 ) ) ), psEnc->sCmn.subfr_length );

    for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1d776:	f241 12e4 	movw	r2, #4580	; 0x11e4
    InvMaxSqrVal_Q16 = silk_DIV32_16( silk_log2lin(
   1d77a:	f241 13ec 	movw	r3, #4588	; 0x11ec
    for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1d77e:	f858 2002 	ldr.w	r2, [r8, r2]
    InvMaxSqrVal_Q16 = silk_DIV32_16( silk_log2lin(
   1d782:	f858 3003 	ldr.w	r3, [r8, r3]
   1d786:	fb90 f0f3 	sdiv	r0, r0, r3
    for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1d78a:	2a00      	cmp	r2, #0
   1d78c:	f340 8164 	ble.w	1da58 <silk_process_gains_FIX+0x320>
        /* Soft limit on ratio residual energy and squared gains */
        ResNrg     = psEncCtrl->ResNrg[ k ];
        ResNrgPart = silk_SMULWW( ResNrg, InvMaxSqrVal_Q16 );
   1d790:	ea4f 3ce0 	mov.w	ip, r0, asr #15
   1d794:	0092      	lsls	r2, r2, #2
   1d796:	f10c 0c01 	add.w	ip, ip, #1
   1d79a:	ea4f 0c6c 	mov.w	ip, ip, asr #1
   1d79e:	b200      	sxth	r0, r0
   1d7a0:	eb09 0e02 	add.w	lr, r9, r2
   1d7a4:	464d      	mov	r5, r9
        y = 32768;
   1d7a6:	f24b 4b86 	movw	fp, #46214	; 0xb486
                ResNrgPart = silk_LSHIFT( ResNrgPart, -psEncCtrl->ResNrgQ[ k ] );
            }
        }
        gain = psEncCtrl->Gains_Q16[ k ];
        gain_squared = silk_ADD_SAT32( ResNrgPart, silk_SMMUL( gain, gain ) );
        if( gain_squared < silk_int16_MAX ) {
   1d7aa:	f647 7afe 	movw	sl, #32766	; 0x7ffe
   1d7ae:	9203      	str	r2, [sp, #12]
        ResNrg     = psEncCtrl->ResNrg[ k ];
   1d7b0:	f8d5 6190 	ldr.w	r6, [r5, #400]	; 0x190
        if( psEncCtrl->ResNrgQ[ k ] > 0 ) {
   1d7b4:	f8d5 31a0 	ldr.w	r3, [r5, #416]	; 0x1a0
        ResNrgPart = silk_SMULWW( ResNrg, InvMaxSqrVal_Q16 );
   1d7b8:	b2b1      	uxth	r1, r6
   1d7ba:	1434      	asrs	r4, r6, #16
   1d7bc:	fb00 f101 	mul.w	r1, r0, r1
   1d7c0:	fb00 f404 	mul.w	r4, r0, r4
   1d7c4:	eb04 4421 	add.w	r4, r4, r1, asr #16
        if( psEncCtrl->ResNrgQ[ k ] > 0 ) {
   1d7c8:	2b00      	cmp	r3, #0
        ResNrgPart = silk_SMULWW( ResNrg, InvMaxSqrVal_Q16 );
   1d7ca:	fb06 460c 	mla	r6, r6, ip, r4
        if( psEncCtrl->ResNrgQ[ k ] > 0 ) {
   1d7ce:	f340 80ce 	ble.w	1d96e <silk_process_gains_FIX+0x236>
            ResNrgPart = silk_RSHIFT_ROUND( ResNrgPart, psEncCtrl->ResNrgQ[ k ] );
   1d7d2:	2b01      	cmp	r3, #1
   1d7d4:	f000 80d7 	beq.w	1d986 <silk_process_gains_FIX+0x24e>
   1d7d8:	1e5c      	subs	r4, r3, #1
   1d7da:	fa46 f404 	asr.w	r4, r6, r4
   1d7de:	3401      	adds	r4, #1
   1d7e0:	1064      	asrs	r4, r4, #1
   1d7e2:	4623      	mov	r3, r4
        gain = psEncCtrl->Gains_Q16[ k ];
   1d7e4:	6829      	ldr	r1, [r5, #0]
        gain_squared = silk_ADD_SAT32( ResNrgPart, silk_SMMUL( gain, gain ) );
   1d7e6:	fb81 6701 	smull	r6, r7, r1, r1
   1d7ea:	42fb      	cmn	r3, r7
   1d7ec:	f100 80b8 	bmi.w	1d960 <silk_process_gains_FIX+0x228>
   1d7f0:	423c      	tst	r4, r7
   1d7f2:	d422      	bmi.n	1d83a <silk_process_gains_FIX+0x102>
   1d7f4:	443c      	add	r4, r7
        if( gain_squared < silk_int16_MAX ) {
   1d7f6:	4554      	cmp	r4, sl
   1d7f8:	dd1f      	ble.n	1d83a <silk_process_gains_FIX+0x102>
   1d7fa:	fab4 f184 	clz	r1, r4
    * frac_Q7 = silk_ROR32(in, 24 - lzeros) & 0x7f;
   1d7fe:	f1c1 0318 	rsb	r3, r1, #24
        return (opus_int32) ((x << (32 - r)) | (x >> r));
   1d802:	41dc      	rors	r4, r3
   1d804:	f004 047f 	and.w	r4, r4, #127	; 0x7f
   1d808:	eb04 03c4 	add.w	r3, r4, r4, lsl #3
   1d80c:	ebc4 04c3 	rsb	r4, r4, r3, lsl #3
   1d810:	ebc4 0484 	rsb	r4, r4, r4, lsl #2
    if( lz & 1 ) {
   1d814:	07ca      	lsls	r2, r1, #31
   1d816:	b2a4      	uxth	r4, r4
   1d818:	ea4f 0361 	mov.w	r3, r1, asr #1
   1d81c:	f100 811e 	bmi.w	1da5c <silk_process_gains_FIX+0x324>
   1d820:	fa4b f303 	asr.w	r3, fp, r3
   1d824:	fb04 f403 	mul.w	r4, r4, r3
   1d828:	eb03 4424 	add.w	r4, r3, r4, asr #16
   1d82c:	f647 73ff 	movw	r3, #32767	; 0x7fff
   1d830:	429c      	cmp	r4, r3
   1d832:	bfa8      	it	ge
   1d834:	461c      	movge	r4, r3
   1d836:	0424      	lsls	r4, r4, #16
   1d838:	e097      	b.n	1d96a <silk_process_gains_FIX+0x232>
            /* recalculate with higher precision */
            gain_squared = silk_SMLAWW( silk_LSHIFT( ResNrgPart, 16 ), gain, gain );
   1d83a:	b20c      	sxth	r4, r1
   1d83c:	b28f      	uxth	r7, r1
   1d83e:	140e      	asrs	r6, r1, #16
   1d840:	fb04 f707 	mul.w	r7, r4, r7
   1d844:	fb04 f606 	mul.w	r6, r4, r6
   1d848:	13cc      	asrs	r4, r1, #15
   1d84a:	eb06 4627 	add.w	r6, r6, r7, asr #16
   1d84e:	3401      	adds	r4, #1
   1d850:	eb06 4603 	add.w	r6, r6, r3, lsl #16
   1d854:	1063      	asrs	r3, r4, #1
   1d856:	fb01 6303 	mla	r3, r1, r3, r6
    if( x <= 0 ) {
   1d85a:	2b00      	cmp	r3, #0
   1d85c:	f340 8099 	ble.w	1d992 <silk_process_gains_FIX+0x25a>
   1d860:	fab3 f183 	clz	r1, r3
    * frac_Q7 = silk_ROR32(in, 24 - lzeros) & 0x7f;
   1d864:	f1c1 0418 	rsb	r4, r1, #24
    if( rot == 0 ) {
   1d868:	2c00      	cmp	r4, #0
   1d86a:	d002      	beq.n	1d872 <silk_process_gains_FIX+0x13a>
        return (opus_int32) ((x << m) | (x >> (32 - m)));
   1d86c:	bfb8      	it	lt
   1d86e:	3420      	addlt	r4, #32
        return (opus_int32) ((x << (32 - r)) | (x >> r));
   1d870:	41e3      	rors	r3, r4
   1d872:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   1d876:	eb03 04c3 	add.w	r4, r3, r3, lsl #3
        y = 32768;
   1d87a:	f011 0f01 	tst.w	r1, #1
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   1d87e:	ebc3 03c4 	rsb	r3, r3, r4, lsl #3
   1d882:	ebc3 0383 	rsb	r3, r3, r3, lsl #2
    y >>= silk_RSHIFT(lz, 1);
   1d886:	ea4f 0461 	mov.w	r4, r1, asr #1
        y = 32768;
   1d88a:	bf0c      	ite	eq
   1d88c:	4659      	moveq	r1, fp
   1d88e:	f44f 4100 	movne.w	r1, #32768	; 0x8000
    y >>= silk_RSHIFT(lz, 1);
   1d892:	4121      	asrs	r1, r4
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   1d894:	b29b      	uxth	r3, r3
   1d896:	fb01 f303 	mul.w	r3, r1, r3
   1d89a:	eb01 4323 	add.w	r3, r1, r3, asr #16
   1d89e:	021b      	lsls	r3, r3, #8
            silk_assert( gain_squared > 0 );
            gain = silk_SQRT_APPROX( gain_squared );                    /* Q8   */
            gain = silk_min( gain, silk_int32_MAX >> 8 );
            psEncCtrl->Gains_Q16[ k ] = silk_LSHIFT_SAT32( gain, 8 );   /* Q16  */
   1d8a0:	602b      	str	r3, [r5, #0]
   1d8a2:	3504      	adds	r5, #4
    for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1d8a4:	45ae      	cmp	lr, r5
   1d8a6:	d183      	bne.n	1d7b0 <silk_process_gains_FIX+0x78>
   1d8a8:	9a03      	ldr	r2, [sp, #12]
            psEncCtrl->Gains_Q16[ k ] = silk_LSHIFT_SAT32( gain, 16 );  /* Q16  */
        }
    }

    /* Save unquantized gains and gain Index */
    silk_memcpy( psEncCtrl->GainsUnq_Q16, psEncCtrl->Gains_Q16, psEnc->sCmn.nb_subfr * sizeof( opus_int32 ) );
   1d8aa:	4649      	mov	r1, r9
   1d8ac:	f509 70d8 	add.w	r0, r9, #432	; 0x1b0
   1d8b0:	f7ee fc26 	bl	c100 <memcpy>
    psEncCtrl->lastGainIndexPrev = psShapeSt->LastGainIndex;
   1d8b4:	f508 52e0 	add.w	r2, r8, #7168	; 0x1c00

    /* Quantize gains */
    silk_gains_quant( psEnc->sCmn.indices.GainsIndices, psEncCtrl->Gains_Q16,
   1d8b8:	f241 13e4 	movw	r3, #4580	; 0x11e4
    psEncCtrl->lastGainIndexPrev = psShapeSt->LastGainIndex;
   1d8bc:	7811      	ldrb	r1, [r2, #0]
   1d8be:	f889 11c0 	strb.w	r1, [r9, #448]	; 0x1c0
    silk_gains_quant( psEnc->sCmn.indices.GainsIndices, psEncCtrl->Gains_Q16,
   1d8c2:	f858 3003 	ldr.w	r3, [r8, r3]
   1d8c6:	9300      	str	r3, [sp, #0]
   1d8c8:	9b02      	ldr	r3, [sp, #8]
   1d8ca:	f1a3 0302 	sub.w	r3, r3, #2
   1d8ce:	fab3 f383 	clz	r3, r3
   1d8d2:	095b      	lsrs	r3, r3, #5
   1d8d4:	4649      	mov	r1, r9
   1d8d6:	f508 5094 	add.w	r0, r8, #4736	; 0x1280
   1d8da:	f7f2 f903 	bl	fae4 <silk_gains_quant>
        &psShapeSt->LastGainIndex, condCoding == CODE_CONDITIONALLY, psEnc->sCmn.nb_subfr );

    /* Set quantizer offset for voiced signals. Larger offset when LTP coding gain is low or tilt is high (ie low-pass) */
    if( psEnc->sCmn.indices.signalType == TYPE_VOICED ) {
   1d8de:	f241 239d 	movw	r3, #4765	; 0x129d
   1d8e2:	f918 1003 	ldrsb.w	r1, [r8, r3]
   1d8e6:	2902      	cmp	r1, #2
   1d8e8:	d055      	beq.n	1d996 <silk_process_gains_FIX+0x25e>
   1d8ea:	f241 239e 	movw	r3, #4766	; 0x129e
   1d8ee:	f918 4003 	ldrsb.w	r4, [r8, r3]
            psEnc->sCmn.indices.quantOffsetType = 1;
        }
    }

    /* Quantizer boundary adjustment */
    quant_offset_Q10 = silk_Quantization_Offsets_Q10[ psEnc->sCmn.indices.signalType >> 1 ][ psEnc->sCmn.indices.quantOffsetType ];
   1d8f2:	4d5d      	ldr	r5, [pc, #372]	; (1da68 <silk_process_gains_FIX+0x330>)
    psEncCtrl->Lambda_Q10 = SILK_FIX_CONST( LAMBDA_OFFSET, 10 )
                          + silk_SMULBB( SILK_FIX_CONST( LAMBDA_DELAYED_DECISIONS, 10 ), psEnc->sCmn.nStatesDelayedDecision )
                          + silk_SMULWB( SILK_FIX_CONST( LAMBDA_SPEECH_ACT,        18 ), psEnc->sCmn.speech_activity_Q8     )
                          + silk_SMULWB( SILK_FIX_CONST( LAMBDA_INPUT_QUALITY,     12 ), psEncCtrl->input_quality_Q14       )
   1d8f4:	f9b9 0180 	ldrsh.w	r0, [r9, #384]	; 0x180
                          + silk_SMULWB( SILK_FIX_CONST( LAMBDA_SPEECH_ACT,        18 ), psEnc->sCmn.speech_activity_Q8     )
   1d8f8:	f241 13b4 	movw	r3, #4532	; 0x11b4
                          + silk_SMULBB( SILK_FIX_CONST( LAMBDA_DELAYED_DECISIONS, 10 ), psEnc->sCmn.nStatesDelayedDecision )
   1d8fc:	f241 2214 	movw	r2, #4628	; 0x1214
                          + silk_SMULWB( SILK_FIX_CONST( LAMBDA_SPEECH_ACT,        18 ), psEnc->sCmn.speech_activity_Q8     )
   1d900:	f938 3003 	ldrsh.w	r3, [r8, r3]
                          + silk_SMULBB( SILK_FIX_CONST( LAMBDA_DELAYED_DECISIONS, 10 ), psEnc->sCmn.nStatesDelayedDecision )
   1d904:	f858 2002 	ldr.w	r2, [r8, r2]
    quant_offset_Q10 = silk_Quantization_Offsets_Q10[ psEnc->sCmn.indices.signalType >> 1 ][ psEnc->sCmn.indices.quantOffsetType ];
   1d908:	f021 0101 	bic.w	r1, r1, #1
   1d90c:	4421      	add	r1, r4
                          + silk_SMULWB( SILK_FIX_CONST( LAMBDA_SPEECH_ACT,        18 ), psEnc->sCmn.speech_activity_Q8     )
   1d90e:	f243 3434 	movw	r4, #13108	; 0x3334
   1d912:	fb13 f404 	smulbb	r4, r3, r4
   1d916:	ebc3 4324 	rsb	r3, r3, r4, asr #16
                          + silk_SMULBB( SILK_FIX_CONST( LAMBDA_DELAYED_DECISIONS, 10 ), psEnc->sCmn.nStatesDelayedDecision )
   1d91a:	f64f 74ce 	movw	r4, #65486	; 0xffce
    quant_offset_Q10 = silk_Quantization_Offsets_Q10[ psEnc->sCmn.indices.signalType >> 1 ][ psEnc->sCmn.indices.quantOffsetType ];
   1d91e:	f935 5011 	ldrsh.w	r5, [r5, r1, lsl #1]
                          + silk_SMULWB( SILK_FIX_CONST( LAMBDA_CODING_QUALITY,    12 ), psEncCtrl->coding_quality_Q14      )
   1d922:	f9b9 1184 	ldrsh.w	r1, [r9, #388]	; 0x184
                          + silk_SMULBB( SILK_FIX_CONST( LAMBDA_DELAYED_DECISIONS, 10 ), psEnc->sCmn.nStatesDelayedDecision )
   1d926:	fb12 3304 	smlabb	r3, r2, r4, r3
                          + silk_SMULWB( SILK_FIX_CONST( LAMBDA_INPUT_QUALITY,     12 ), psEncCtrl->input_quality_Q14       )
   1d92a:	f64f 6267 	movw	r2, #65127	; 0xfe67
   1d92e:	fb02 f200 	mul.w	r2, r2, r0
                          + silk_SMULWB( SILK_FIX_CONST( LAMBDA_CODING_QUALITY,    12 ), psEncCtrl->coding_quality_Q14      )
   1d932:	f64f 44ce 	movw	r4, #64718	; 0xfcce
                          + silk_SMULWB( SILK_FIX_CONST( LAMBDA_INPUT_QUALITY,     12 ), psEncCtrl->input_quality_Q14       )
   1d936:	ebc0 4022 	rsb	r0, r0, r2, asr #16
                          + silk_SMULWB( SILK_FIX_CONST( LAMBDA_CODING_QUALITY,    12 ), psEncCtrl->coding_quality_Q14      )
   1d93a:	fb04 f401 	mul.w	r4, r4, r1
                          + silk_SMULWB( SILK_FIX_CONST( LAMBDA_SPEECH_ACT,        18 ), psEnc->sCmn.speech_activity_Q8     )
   1d93e:	f203 43cd 	addw	r3, r3, #1229	; 0x4cd
                          + silk_SMULWB( SILK_FIX_CONST( LAMBDA_INPUT_QUALITY,     12 ), psEncCtrl->input_quality_Q14       )
   1d942:	4403      	add	r3, r0
                          + silk_SMULWB( SILK_FIX_CONST( LAMBDA_CODING_QUALITY,    12 ), psEncCtrl->coding_quality_Q14      )
   1d944:	ebc1 4124 	rsb	r1, r1, r4, asr #16
                          + silk_SMULWB( SILK_FIX_CONST( LAMBDA_QUANT_OFFSET,      16 ), quant_offset_Q10                   );
   1d948:	f64c 42cd 	movw	r2, #52429	; 0xcccd
   1d94c:	fb02 f205 	mul.w	r2, r2, r5
                          + silk_SMULWB( SILK_FIX_CONST( LAMBDA_CODING_QUALITY,    12 ), psEncCtrl->coding_quality_Q14      )
   1d950:	440b      	add	r3, r1
                          + silk_SMULWB( SILK_FIX_CONST( LAMBDA_QUANT_OFFSET,      16 ), quant_offset_Q10                   );
   1d952:	eb03 4322 	add.w	r3, r3, r2, asr #16
    psEncCtrl->Lambda_Q10 = SILK_FIX_CONST( LAMBDA_OFFSET, 10 )
   1d956:	f8c9 317c 	str.w	r3, [r9, #380]	; 0x17c

    silk_assert( psEncCtrl->Lambda_Q10 > 0 );
    silk_assert( psEncCtrl->Lambda_Q10 < SILK_FIX_CONST( 2, 10 ) );
}
   1d95a:	b005      	add	sp, #20
   1d95c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        gain_squared = silk_ADD_SAT32( ResNrgPart, silk_SMMUL( gain, gain ) );
   1d960:	ea54 0207 	orrs.w	r2, r4, r7
   1d964:	f53f af46 	bmi.w	1d7f4 <silk_process_gains_FIX+0xbc>
   1d968:	4c40      	ldr	r4, [pc, #256]	; (1da6c <silk_process_gains_FIX+0x334>)
            psEncCtrl->Gains_Q16[ k ] = silk_LSHIFT_SAT32( gain, 16 );  /* Q16  */
   1d96a:	602c      	str	r4, [r5, #0]
   1d96c:	e799      	b.n	1d8a2 <silk_process_gains_FIX+0x16a>
            if( ResNrgPart >= silk_RSHIFT( silk_int32_MAX, -psEncCtrl->ResNrgQ[ k ] ) ) {
   1d96e:	425b      	negs	r3, r3
   1d970:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
   1d974:	4119      	asrs	r1, r3
   1d976:	42b1      	cmp	r1, r6
                ResNrgPart = silk_LSHIFT( ResNrgPart, -psEncCtrl->ResNrgQ[ k ] );
   1d978:	bfcc      	ite	gt
   1d97a:	fa06 f303 	lslgt.w	r3, r6, r3
   1d97e:	f06f 4300 	mvnle.w	r3, #2147483648	; 0x80000000
                ResNrgPart = silk_int32_MAX;
   1d982:	461c      	mov	r4, r3
   1d984:	e72e      	b.n	1d7e4 <silk_process_gains_FIX+0xac>
            ResNrgPart = silk_RSHIFT_ROUND( ResNrgPart, psEncCtrl->ResNrgQ[ k ] );
   1d986:	f006 0101 	and.w	r1, r6, #1
   1d98a:	eb01 0466 	add.w	r4, r1, r6, asr #1
   1d98e:	4623      	mov	r3, r4
   1d990:	e728      	b.n	1d7e4 <silk_process_gains_FIX+0xac>
    if( x <= 0 ) {
   1d992:	2300      	movs	r3, #0
   1d994:	e784      	b.n	1d8a0 <silk_process_gains_FIX+0x168>
        if( psEncCtrl->LTPredCodGain_Q7 + silk_RSHIFT( psEnc->sCmn.input_tilt_Q15, 8 ) > SILK_FIX_CONST( 1.0, 7 ) ) {
   1d996:	f241 2268 	movw	r2, #4712	; 0x1268
   1d99a:	f8d9 318c 	ldr.w	r3, [r9, #396]	; 0x18c
   1d99e:	f858 2002 	ldr.w	r2, [r8, r2]
   1d9a2:	eb03 2322 	add.w	r3, r3, r2, asr #8
   1d9a6:	2b80      	cmp	r3, #128	; 0x80
            psEnc->sCmn.indices.quantOffsetType = 0;
   1d9a8:	f241 239e 	movw	r3, #4766	; 0x129e
   1d9ac:	bfcc      	ite	gt
   1d9ae:	2400      	movgt	r4, #0
            psEnc->sCmn.indices.quantOffsetType = 1;
   1d9b0:	2401      	movle	r4, #1
   1d9b2:	f808 4003 	strb.w	r4, [r8, r3]
   1d9b6:	e79c      	b.n	1d8f2 <silk_process_gains_FIX+0x1ba>
        s_Q16 = -silk_sigm_Q15( silk_RSHIFT_ROUND( psEncCtrl->LTPredCodGain_Q7 - SILK_FIX_CONST( 12.0, 7 ), 4 ) );
   1d9b8:	f8d1 318c 	ldr.w	r3, [r1, #396]	; 0x18c
   1d9bc:	f5a3 60c0 	sub.w	r0, r3, #1536	; 0x600
   1d9c0:	10c0      	asrs	r0, r0, #3
   1d9c2:	3001      	adds	r0, #1
   1d9c4:	1040      	asrs	r0, r0, #1
   1d9c6:	f7fc f951 	bl	19c6c <silk_sigm_Q15>
        for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1d9ca:	f241 13e4 	movw	r3, #4580	; 0x11e4
        s_Q16 = -silk_sigm_Q15( silk_RSHIFT_ROUND( psEncCtrl->LTPredCodGain_Q7 - SILK_FIX_CONST( 12.0, 7 ), 4 ) );
   1d9ce:	4240      	negs	r0, r0
        for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1d9d0:	f858 2003 	ldr.w	r2, [r8, r3]
   1d9d4:	2a00      	cmp	r2, #0
   1d9d6:	f77f aebb 	ble.w	1d750 <silk_process_gains_FIX+0x18>
            psEncCtrl->Gains_Q16[ k ] = silk_SMLAWB( psEncCtrl->Gains_Q16[ k ], psEncCtrl->Gains_Q16[ k ], s_Q16 );
   1d9da:	f8d9 1000 	ldr.w	r1, [r9]
   1d9de:	b200      	sxth	r0, r0
   1d9e0:	b28c      	uxth	r4, r1
   1d9e2:	140b      	asrs	r3, r1, #16
   1d9e4:	fb00 f404 	mul.w	r4, r0, r4
   1d9e8:	fb00 f303 	mul.w	r3, r0, r3
   1d9ec:	eb03 4324 	add.w	r3, r3, r4, asr #16
   1d9f0:	440b      	add	r3, r1
        for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1d9f2:	2a01      	cmp	r2, #1
            psEncCtrl->Gains_Q16[ k ] = silk_SMLAWB( psEncCtrl->Gains_Q16[ k ], psEncCtrl->Gains_Q16[ k ], s_Q16 );
   1d9f4:	f8c9 3000 	str.w	r3, [r9]
        for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1d9f8:	f43f aeaa 	beq.w	1d750 <silk_process_gains_FIX+0x18>
            psEncCtrl->Gains_Q16[ k ] = silk_SMLAWB( psEncCtrl->Gains_Q16[ k ], psEncCtrl->Gains_Q16[ k ], s_Q16 );
   1d9fc:	f8d9 1004 	ldr.w	r1, [r9, #4]
   1da00:	b28c      	uxth	r4, r1
   1da02:	140b      	asrs	r3, r1, #16
   1da04:	fb00 f404 	mul.w	r4, r0, r4
   1da08:	fb00 f303 	mul.w	r3, r0, r3
   1da0c:	eb03 4324 	add.w	r3, r3, r4, asr #16
   1da10:	440b      	add	r3, r1
        for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1da12:	2a02      	cmp	r2, #2
            psEncCtrl->Gains_Q16[ k ] = silk_SMLAWB( psEncCtrl->Gains_Q16[ k ], psEncCtrl->Gains_Q16[ k ], s_Q16 );
   1da14:	f8c9 3004 	str.w	r3, [r9, #4]
        for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1da18:	f43f ae9a 	beq.w	1d750 <silk_process_gains_FIX+0x18>
            psEncCtrl->Gains_Q16[ k ] = silk_SMLAWB( psEncCtrl->Gains_Q16[ k ], psEncCtrl->Gains_Q16[ k ], s_Q16 );
   1da1c:	f8d9 1008 	ldr.w	r1, [r9, #8]
   1da20:	b28c      	uxth	r4, r1
   1da22:	140b      	asrs	r3, r1, #16
   1da24:	fb00 f404 	mul.w	r4, r0, r4
   1da28:	fb00 f303 	mul.w	r3, r0, r3
   1da2c:	eb03 4324 	add.w	r3, r3, r4, asr #16
   1da30:	440b      	add	r3, r1
        for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1da32:	2a03      	cmp	r2, #3
            psEncCtrl->Gains_Q16[ k ] = silk_SMLAWB( psEncCtrl->Gains_Q16[ k ], psEncCtrl->Gains_Q16[ k ], s_Q16 );
   1da34:	f8c9 3008 	str.w	r3, [r9, #8]
        for( k = 0; k < psEnc->sCmn.nb_subfr; k++ ) {
   1da38:	f43f ae8a 	beq.w	1d750 <silk_process_gains_FIX+0x18>
            psEncCtrl->Gains_Q16[ k ] = silk_SMLAWB( psEncCtrl->Gains_Q16[ k ], psEncCtrl->Gains_Q16[ k ], s_Q16 );
   1da3c:	f8d9 200c 	ldr.w	r2, [r9, #12]
   1da40:	b293      	uxth	r3, r2
   1da42:	1414      	asrs	r4, r2, #16
   1da44:	fb00 f103 	mul.w	r1, r0, r3
   1da48:	fb00 f304 	mul.w	r3, r0, r4
   1da4c:	eb03 4321 	add.w	r3, r3, r1, asr #16
   1da50:	4413      	add	r3, r2
   1da52:	f8c9 300c 	str.w	r3, [r9, #12]
   1da56:	e67b      	b.n	1d750 <silk_process_gains_FIX+0x18>
   1da58:	0092      	lsls	r2, r2, #2
   1da5a:	e726      	b.n	1d8aa <silk_process_gains_FIX+0x172>
   1da5c:	f44f 4200 	mov.w	r2, #32768	; 0x8000
   1da60:	fa42 f303 	asr.w	r3, r2, r3
   1da64:	e6de      	b.n	1d824 <silk_process_gains_FIX+0xec>
   1da66:	bf00      	nop
   1da68:	00036c88 	.word	0x00036c88
   1da6c:	7fff0000 	.word	0x7fff0000

0001da70 <silk_residual_energy_FIX>:
    const opus_int                  subfr_length,                           /* I    Subframe length                                                             */
    const opus_int                  nb_subfr,                               /* I    Number of subframes                                                         */
    const opus_int                  LPC_order,                              /* I    LPC order                                                                   */
          int                       arch                                    /* I    Run-time architecture                                                       */
)
{
   1da70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1da74:	b08b      	sub	sp, #44	; 0x2c
   1da76:	af02      	add	r7, sp, #8
   1da78:	4690      	mov	r8, r2
    const opus_int16 *x_ptr;
    opus_int32       tmp32;
    SAVE_STACK;

    x_ptr  = x;
    offset = LPC_order + subfr_length;
   1da7a:	6d7c      	ldr	r4, [r7, #84]	; 0x54
{
   1da7c:	f8d7 904c 	ldr.w	r9, [r7, #76]	; 0x4c
    offset = LPC_order + subfr_length;
   1da80:	eb04 0509 	add.w	r5, r4, r9

    /* Filter input to create the LPC residual for each frame half, and measure subframe energies */
    ALLOC( LPC_res, ( MAX_NB_SUBFR >> 1 ) * offset, opus_int16 );
   1da84:	ea4f 0a85 	mov.w	sl, r5, lsl #2
   1da88:	f10a 0408 	add.w	r4, sl, #8
   1da8c:	f024 0407 	bic.w	r4, r4, #7
   1da90:	ebad 0d04 	sub.w	sp, sp, r4
    celt_assert( ( nb_subfr >> 1 ) * ( MAX_NB_SUBFR >> 1 ) == nb_subfr );
    for( i = 0; i < nb_subfr >> 1; i++ ) {
   1da94:	6d3c      	ldr	r4, [r7, #80]	; 0x50
   1da96:	1064      	asrs	r4, r4, #1
    ALLOC( LPC_res, ( MAX_NB_SUBFR >> 1 ) * offset, opus_int16 );
   1da98:	006a      	lsls	r2, r5, #1
    for( i = 0; i < nb_subfr >> 1; i++ ) {
   1da9a:	2c00      	cmp	r4, #0
{
   1da9c:	e9c7 1000 	strd	r1, r0, [r7]
    ALLOC( LPC_res, ( MAX_NB_SUBFR >> 1 ) * offset, opus_int16 );
   1daa0:	617a      	str	r2, [r7, #20]
    for( i = 0; i < nb_subfr >> 1; i++ ) {
   1daa2:	dd6e      	ble.n	1db82 <silk_residual_energy_FIX+0x112>
        /* Calculate half frame LPC residual signal including preceding samples */
        silk_LPC_analysis_filter( LPC_res, x_ptr, a_Q12[ i ], ( MAX_NB_SUBFR >> 1 ) * offset, LPC_order, arch );

        /* Point to first subframe of the just calculated LPC residual signal */
        LPC_res_ptr = LPC_res + LPC_order;
   1daa4:	6d7e      	ldr	r6, [r7, #84]	; 0x54
   1daa6:	f10d 0b08 	add.w	fp, sp, #8
   1daaa:	eb0b 0546 	add.w	r5, fp, r6, lsl #1
   1daae:	461e      	mov	r6, r3
   1dab0:	eb01 03c4 	add.w	r3, r1, r4, lsl #3
   1dab4:	60fb      	str	r3, [r7, #12]
   1dab6:	462b      	mov	r3, r5
   1dab8:	4413      	add	r3, r2
   1daba:	613d      	str	r5, [r7, #16]
   1dabc:	60bb      	str	r3, [r7, #8]
   1dabe:	4605      	mov	r5, r0
   1dac0:	460c      	mov	r4, r1
        silk_LPC_analysis_filter( LPC_res, x_ptr, a_Q12[ i ], ( MAX_NB_SUBFR >> 1 ) * offset, LPC_order, arch );
   1dac2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   1dac4:	9301      	str	r3, [sp, #4]
   1dac6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1dac8:	9300      	str	r3, [sp, #0]
   1daca:	4632      	mov	r2, r6
   1dacc:	4641      	mov	r1, r8
   1dace:	697b      	ldr	r3, [r7, #20]
   1dad0:	4658      	mov	r0, fp
   1dad2:	f7f9 ffdb 	bl	17a8c <silk_LPC_analysis_filter>
        for( j = 0; j < ( MAX_NB_SUBFR >> 1 ); j++ ) {
            /* Measure subframe energy */
            silk_sum_sqr_shift( &nrgs[ i * ( MAX_NB_SUBFR >> 1 ) + j ], &rshift, LPC_res_ptr, subfr_length );
   1dad6:	4628      	mov	r0, r5
   1dad8:	464b      	mov	r3, r9
   1dada:	693a      	ldr	r2, [r7, #16]
   1dadc:	f107 011c 	add.w	r1, r7, #28
   1dae0:	f7fc fa32 	bl	19f48 <silk_sum_sqr_shift>

            /* Set Q values for the measured energy */
            nrgsQ[ i * ( MAX_NB_SUBFR >> 1 ) + j ] = -rshift;
   1dae4:	69fb      	ldr	r3, [r7, #28]
            silk_sum_sqr_shift( &nrgs[ i * ( MAX_NB_SUBFR >> 1 ) + j ], &rshift, LPC_res_ptr, subfr_length );
   1dae6:	68ba      	ldr	r2, [r7, #8]
            nrgsQ[ i * ( MAX_NB_SUBFR >> 1 ) + j ] = -rshift;
   1dae8:	425b      	negs	r3, r3
   1daea:	6023      	str	r3, [r4, #0]
            silk_sum_sqr_shift( &nrgs[ i * ( MAX_NB_SUBFR >> 1 ) + j ], &rshift, LPC_res_ptr, subfr_length );
   1daec:	1d28      	adds	r0, r5, #4
   1daee:	464b      	mov	r3, r9
   1daf0:	f107 011c 	add.w	r1, r7, #28
   1daf4:	f7fc fa28 	bl	19f48 <silk_sum_sqr_shift>
            nrgsQ[ i * ( MAX_NB_SUBFR >> 1 ) + j ] = -rshift;
   1daf8:	69fb      	ldr	r3, [r7, #28]
   1dafa:	425b      	negs	r3, r3
   1dafc:	6063      	str	r3, [r4, #4]
    for( i = 0; i < nb_subfr >> 1; i++ ) {
   1dafe:	68fb      	ldr	r3, [r7, #12]
   1db00:	3408      	adds	r4, #8
   1db02:	429c      	cmp	r4, r3
   1db04:	f106 0620 	add.w	r6, r6, #32

            /* Move to next subframe */
            LPC_res_ptr += offset;
        }
        /* Move to next frame half */
        x_ptr += ( MAX_NB_SUBFR >> 1 ) * offset;
   1db08:	44d0      	add	r8, sl
   1db0a:	f105 0508 	add.w	r5, r5, #8
    for( i = 0; i < nb_subfr >> 1; i++ ) {
   1db0e:	d1d8      	bne.n	1dac2 <silk_residual_energy_FIX+0x52>
   1db10:	687b      	ldr	r3, [r7, #4]
   1db12:	1f1c      	subs	r4, r3, #4
   1db14:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   1db16:	eb04 0683 	add.w	r6, r4, r3, lsl #2
   1db1a:	683b      	ldr	r3, [r7, #0]
   1db1c:	1f1d      	subs	r5, r3, #4
   1db1e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   1db20:	f1a3 0c04 	sub.w	ip, r3, #4
   1db24:	e024      	b.n	1db70 <silk_residual_energy_FIX+0x100>
   1db26:	f100 3eff 	add.w	lr, r0, #4294967295	; 0xffffffff

    /* Apply the squared subframe gains */
    for( i = 0; i < nb_subfr; i++ ) {
        /* Fully upscale gains and energies */
        lz1 = silk_CLZ32( nrgs[  i ] ) - 1;
        lz2 = silk_CLZ32( gains[ i ] ) - 1;
   1db2a:	f85c 3f04 	ldr.w	r3, [ip, #4]!
   1db2e:	221f      	movs	r2, #31
   1db30:	203e      	movs	r0, #62	; 0x3e
   1db32:	fab3 f883 	clz	r8, r3
   1db36:	b113      	cbz	r3, 1db3e <silk_residual_energy_FIX+0xce>
   1db38:	f108 32ff 	add.w	r2, r8, #4294967295	; 0xffffffff
   1db3c:	0050      	lsls	r0, r2, #1

        /* Find squared gains */
        tmp32 = silk_SMMUL( tmp32, tmp32 ); /* Q( 2 * lz2 - 32 )*/

        /* Scale energies */
        nrgs[ i ] = silk_SMMUL( tmp32, silk_LSHIFT32( nrgs[ i ], lz1 ) ); /* Q( nrgsQ[ i ] + lz1 + 2 * lz2 - 32 - 32 )*/
   1db3e:	fa01 f10e 	lsl.w	r1, r1, lr
        tmp32 = silk_LSHIFT32( gains[ i ], lz2 );
   1db42:	4093      	lsls	r3, r2
        tmp32 = silk_SMMUL( tmp32, tmp32 ); /* Q( 2 * lz2 - 32 )*/
   1db44:	fb83 ab03 	smull	sl, fp, r3, r3
        nrgs[ i ] = silk_SMMUL( tmp32, silk_LSHIFT32( nrgs[ i ], lz1 ) ); /* Q( nrgsQ[ i ] + lz1 + 2 * lz2 - 32 - 32 )*/
   1db48:	ea4f 79e1 	mov.w	r9, r1, asr #31
        nrgsQ[ i ] += lz1 + 2 * lz2 - 32 - 32;
   1db4c:	f855 8f04 	ldr.w	r8, [r5, #4]!
   1db50:	4470      	add	r0, lr
        nrgs[ i ] = silk_SMMUL( tmp32, silk_LSHIFT32( nrgs[ i ], lz1 ) ); /* Q( nrgsQ[ i ] + lz1 + 2 * lz2 - 32 - 32 )*/
   1db52:	fb0b f209 	mul.w	r2, fp, r9
        tmp32 = silk_SMMUL( tmp32, tmp32 ); /* Q( 2 * lz2 - 32 )*/
   1db56:	ea4f 7eeb 	mov.w	lr, fp, asr #31
        nrgs[ i ] = silk_SMMUL( tmp32, silk_LSHIFT32( nrgs[ i ], lz1 ) ); /* Q( nrgsQ[ i ] + lz1 + 2 * lz2 - 32 - 32 )*/
   1db5a:	fb01 2e0e 	mla	lr, r1, lr, r2
        nrgsQ[ i ] += lz1 + 2 * lz2 - 32 - 32;
   1db5e:	3840      	subs	r0, #64	; 0x40
        nrgs[ i ] = silk_SMMUL( tmp32, silk_LSHIFT32( nrgs[ i ], lz1 ) ); /* Q( nrgsQ[ i ] + lz1 + 2 * lz2 - 32 - 32 )*/
   1db60:	fbab 2301 	umull	r2, r3, fp, r1
   1db64:	4473      	add	r3, lr
        nrgsQ[ i ] += lz1 + 2 * lz2 - 32 - 32;
   1db66:	4440      	add	r0, r8
    for( i = 0; i < nb_subfr; i++ ) {
   1db68:	42a6      	cmp	r6, r4
        nrgs[ i ] = silk_SMMUL( tmp32, silk_LSHIFT32( nrgs[ i ], lz1 ) ); /* Q( nrgsQ[ i ] + lz1 + 2 * lz2 - 32 - 32 )*/
   1db6a:	6023      	str	r3, [r4, #0]
        nrgsQ[ i ] += lz1 + 2 * lz2 - 32 - 32;
   1db6c:	6028      	str	r0, [r5, #0]
    for( i = 0; i < nb_subfr; i++ ) {
   1db6e:	d00b      	beq.n	1db88 <silk_residual_energy_FIX+0x118>
        lz1 = silk_CLZ32( nrgs[  i ] ) - 1;
   1db70:	f854 1f04 	ldr.w	r1, [r4, #4]!
   1db74:	fab1 f081 	clz	r0, r1
   1db78:	2900      	cmp	r1, #0
   1db7a:	d1d4      	bne.n	1db26 <silk_residual_energy_FIX+0xb6>
   1db7c:	f04f 0e1f 	mov.w	lr, #31
   1db80:	e7d3      	b.n	1db2a <silk_residual_energy_FIX+0xba>
    for( i = 0; i < nb_subfr; i++ ) {
   1db82:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   1db84:	2b00      	cmp	r3, #0
   1db86:	dcc3      	bgt.n	1db10 <silk_residual_energy_FIX+0xa0>
    }
    RESTORE_STACK;
}
   1db88:	3724      	adds	r7, #36	; 0x24
   1db8a:	46bd      	mov	sp, r7
   1db8c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0001db90 <silk_warped_autocorrelation_FIX_c>:
    const opus_int16                *input,                                 /* I    Input data to correlate                                                     */
    const opus_int                  warping_Q16,                            /* I    Warping coefficient                                                         */
    const opus_int                  length,                                 /* I    Length of input                                                             */
    const opus_int                  order                                   /* I    Correlation order (even)                                                    */
)
{
   1db90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1db94:	b0d7      	sub	sp, #348	; 0x15c
    opus_int   n, i, lsh;
    opus_int32 tmp1_QS, tmp2_QS;
    opus_int32 state_QS[ MAX_SHAPE_LPC_ORDER + 1 ] = { 0 };
   1db96:	f10d 0b2c 	add.w	fp, sp, #44	; 0x2c
{
   1db9a:	e9cd 1008 	strd	r1, r0, [sp, #32]
   1db9e:	9c60      	ldr	r4, [sp, #384]	; 0x180
    opus_int32 state_QS[ MAX_SHAPE_LPC_ORDER + 1 ] = { 0 };
   1dba0:	2100      	movs	r1, #0
{
   1dba2:	4615      	mov	r5, r2
    opus_int32 state_QS[ MAX_SHAPE_LPC_ORDER + 1 ] = { 0 };
   1dba4:	4658      	mov	r0, fp
   1dba6:	2264      	movs	r2, #100	; 0x64
{
   1dba8:	469a      	mov	sl, r3
    opus_int32 state_QS[ MAX_SHAPE_LPC_ORDER + 1 ] = { 0 };
   1dbaa:	f017 fadb 	bl	35164 <memset>
    opus_int64 corr_QC[  MAX_SHAPE_LPC_ORDER + 1 ] = { 0 };
   1dbae:	a824      	add	r0, sp, #144	; 0x90
   1dbb0:	22c8      	movs	r2, #200	; 0xc8
   1dbb2:	2100      	movs	r1, #0
   1dbb4:	f017 fad6 	bl	35164 <memset>
    /* Order must be even */
    celt_assert( ( order & 1 ) == 0 );
    silk_assert( 2 * QS - QC >= 0 );

    /* Loop over samples */
    for( n = 0; n < length; n++ ) {
   1dbb8:	2c00      	cmp	r4, #0
   1dbba:	f340 80c5 	ble.w	1dd48 <silk_warped_autocorrelation_FIX_c+0x1b8>
   1dbbe:	9b61      	ldr	r3, [sp, #388]	; 0x184
   1dbc0:	1e5a      	subs	r2, r3, #1
   1dbc2:	1eab      	subs	r3, r5, #2
   1dbc4:	9304      	str	r3, [sp, #16]
   1dbc6:	eb03 0344 	add.w	r3, r3, r4, lsl #1
   1dbca:	0852      	lsrs	r2, r2, #1
   1dbcc:	9305      	str	r3, [sp, #20]
   1dbce:	ab28      	add	r3, sp, #160	; 0xa0
   1dbd0:	eb03 1302 	add.w	r3, r3, r2, lsl #4
   1dbd4:	9307      	str	r3, [sp, #28]
            tmp1_QS = silk_SMLAWB( state_QS[ i + 1 ], state_QS[ i + 2 ] - tmp2_QS, warping_Q16 );
            state_QS[ i + 1 ]  = tmp2_QS;
            corr_QC[  i + 1 ] += silk_RSHIFT64( silk_SMULL( tmp2_QS, state_QS[ 0 ] ), 2 * QS - QC );
        }
        state_QS[ order ] = tmp1_QS;
        corr_QC[  order ] += silk_RSHIFT64( silk_SMULL( tmp1_QS, state_QS[ 0 ] ), 2 * QS - QC );
   1dbd6:	9b61      	ldr	r3, [sp, #388]	; 0x184
   1dbd8:	aa56      	add	r2, sp, #344	; 0x158
   1dbda:	fa0f fa8a 	sxth.w	sl, sl
   1dbde:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   1dbe2:	9306      	str	r3, [sp, #24]
   1dbe4:	f8cd a004 	str.w	sl, [sp, #4]
        tmp1_QS = silk_LSHIFT32( (opus_int32)input[ n ], QS );
   1dbe8:	9b04      	ldr	r3, [sp, #16]
   1dbea:	f933 0f02 	ldrsh.w	r0, [r3, #2]!
   1dbee:	9304      	str	r3, [sp, #16]
        for( i = 0; i < order; i += 2 ) {
   1dbf0:	9b61      	ldr	r3, [sp, #388]	; 0x184
   1dbf2:	2b00      	cmp	r3, #0
        tmp1_QS = silk_LSHIFT32( (opus_int32)input[ n ], QS );
   1dbf4:	ea4f 3240 	mov.w	r2, r0, lsl #13
        for( i = 0; i < order; i += 2 ) {
   1dbf8:	dd53      	ble.n	1dca2 <silk_warped_autocorrelation_FIX_c+0x112>
   1dbfa:	f8db 9000 	ldr.w	r9, [fp]
   1dbfe:	f8dd c01c 	ldr.w	ip, [sp, #28]
   1dc02:	46d8      	mov	r8, fp
   1dc04:	f10d 0e90 	add.w	lr, sp, #144	; 0x90
   1dc08:	464c      	mov	r4, r9
            tmp2_QS = silk_SMLAWB( state_QS[ i ], state_QS[ i + 1 ] - tmp1_QS, warping_Q16 );
   1dc0a:	f8d8 5004 	ldr.w	r5, [r8, #4]
   1dc0e:	9b01      	ldr	r3, [sp, #4]
            state_QS[ i ]  = tmp1_QS;
   1dc10:	f8c8 2000 	str.w	r2, [r8]
            tmp2_QS = silk_SMLAWB( state_QS[ i ], state_QS[ i + 1 ] - tmp1_QS, warping_Q16 );
   1dc14:	1aa9      	subs	r1, r5, r2
   1dc16:	b288      	uxth	r0, r1
   1dc18:	140e      	asrs	r6, r1, #16
   1dc1a:	fb03 f000 	mul.w	r0, r3, r0
   1dc1e:	fb03 f606 	mul.w	r6, r3, r6
   1dc22:	eb06 4620 	add.w	r6, r6, r0, asr #16
   1dc26:	4426      	add	r6, r4
            corr_QC[  i ] += silk_RSHIFT64( silk_SMULL( tmp1_QS, state_QS[ 0 ] ), 2 * QS - QC );
   1dc28:	f8db 3000 	ldr.w	r3, [fp]
            state_QS[ i + 1 ]  = tmp2_QS;
   1dc2c:	f8c8 6004 	str.w	r6, [r8, #4]
            corr_QC[  i + 1 ] += silk_RSHIFT64( silk_SMULL( tmp2_QS, state_QS[ 0 ] ), 2 * QS - QC );
   1dc30:	f8db 0000 	ldr.w	r0, [fp]
            tmp1_QS = silk_SMLAWB( state_QS[ i + 1 ], state_QS[ i + 2 ] - tmp2_QS, warping_Q16 );
   1dc34:	f8d8 4008 	ldr.w	r4, [r8, #8]
            corr_QC[  i + 1 ] += silk_RSHIFT64( silk_SMULL( tmp2_QS, state_QS[ 0 ] ), 2 * QS - QC );
   1dc38:	fb86 0100 	smull	r0, r1, r6, r0
            corr_QC[  i ] += silk_RSHIFT64( silk_SMULL( tmp1_QS, state_QS[ 0 ] ), 2 * QS - QC );
   1dc3c:	fb82 2303 	smull	r2, r3, r2, r3
            corr_QC[  i + 1 ] += silk_RSHIFT64( silk_SMULL( tmp2_QS, state_QS[ 0 ] ), 2 * QS - QC );
   1dc40:	e9cd 0102 	strd	r0, r1, [sp, #8]
   1dc44:	ea4f 4910 	mov.w	r9, r0, lsr #16
            tmp1_QS = silk_SMLAWB( state_QS[ i + 1 ], state_QS[ i + 2 ] - tmp2_QS, warping_Q16 );
   1dc48:	1ba0      	subs	r0, r4, r6
            corr_QC[  i + 1 ] += silk_RSHIFT64( silk_SMULL( tmp2_QS, state_QS[ 0 ] ), 2 * QS - QC );
   1dc4a:	9903      	ldr	r1, [sp, #12]
            tmp1_QS = silk_SMLAWB( state_QS[ i + 1 ], state_QS[ i + 2 ] - tmp2_QS, warping_Q16 );
   1dc4c:	b286      	uxth	r6, r0
   1dc4e:	1407      	asrs	r7, r0, #16
            corr_QC[  i ] += silk_RSHIFT64( silk_SMULL( tmp1_QS, state_QS[ 0 ] ), 2 * QS - QC );
   1dc50:	0c10      	lsrs	r0, r2, #16
            tmp1_QS = silk_SMLAWB( state_QS[ i + 1 ], state_QS[ i + 2 ] - tmp2_QS, warping_Q16 );
   1dc52:	9a01      	ldr	r2, [sp, #4]
            corr_QC[  i + 1 ] += silk_RSHIFT64( silk_SMULL( tmp2_QS, state_QS[ 0 ] ), 2 * QS - QC );
   1dc54:	ea49 4901 	orr.w	r9, r9, r1, lsl #16
   1dc58:	ea4f 4a21 	mov.w	sl, r1, asr #16
            corr_QC[  i ] += silk_RSHIFT64( silk_SMULL( tmp1_QS, state_QS[ 0 ] ), 2 * QS - QC );
   1dc5c:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
   1dc60:	1419      	asrs	r1, r3, #16
            tmp1_QS = silk_SMLAWB( state_QS[ i + 1 ], state_QS[ i + 2 ] - tmp2_QS, warping_Q16 );
   1dc62:	4613      	mov	r3, r2
   1dc64:	fb03 f306 	mul.w	r3, r3, r6
   1dc68:	fb02 f207 	mul.w	r2, r2, r7
            corr_QC[  i + 1 ] += silk_RSHIFT64( silk_SMULL( tmp2_QS, state_QS[ 0 ] ), 2 * QS - QC );
   1dc6c:	e9de 6702 	ldrd	r6, r7, [lr, #8]
   1dc70:	eb16 0609 	adds.w	r6, r6, r9
   1dc74:	eb47 070a 	adc.w	r7, r7, sl
            corr_QC[  i ] += silk_RSHIFT64( silk_SMULL( tmp1_QS, state_QS[ 0 ] ), 2 * QS - QC );
   1dc78:	e9de 9a00 	ldrd	r9, sl, [lr]
   1dc7c:	eb19 0900 	adds.w	r9, r9, r0
   1dc80:	eb4a 0a01 	adc.w	sl, sl, r1
   1dc84:	4648      	mov	r0, r9
   1dc86:	4651      	mov	r1, sl
            corr_QC[  i + 1 ] += silk_RSHIFT64( silk_SMULL( tmp2_QS, state_QS[ 0 ] ), 2 * QS - QC );
   1dc88:	e9ce 6702 	strd	r6, r7, [lr, #8]
            corr_QC[  i ] += silk_RSHIFT64( silk_SMULL( tmp1_QS, state_QS[ 0 ] ), 2 * QS - QC );
   1dc8c:	e9ce 0100 	strd	r0, r1, [lr]
   1dc90:	f10e 0e10 	add.w	lr, lr, #16
            tmp1_QS = silk_SMLAWB( state_QS[ i + 1 ], state_QS[ i + 2 ] - tmp2_QS, warping_Q16 );
   1dc94:	eb02 4223 	add.w	r2, r2, r3, asr #16
        for( i = 0; i < order; i += 2 ) {
   1dc98:	45f4      	cmp	ip, lr
            tmp1_QS = silk_SMLAWB( state_QS[ i + 1 ], state_QS[ i + 2 ] - tmp2_QS, warping_Q16 );
   1dc9a:	442a      	add	r2, r5
   1dc9c:	f108 0808 	add.w	r8, r8, #8
        for( i = 0; i < order; i += 2 ) {
   1dca0:	d1b3      	bne.n	1dc0a <silk_warped_autocorrelation_FIX_c+0x7a>
        state_QS[ order ] = tmp1_QS;
   1dca2:	9b61      	ldr	r3, [sp, #388]	; 0x184
   1dca4:	f84b 2023 	str.w	r2, [fp, r3, lsl #2]
        corr_QC[  order ] += silk_RSHIFT64( silk_SMULL( tmp1_QS, state_QS[ 0 ] ), 2 * QS - QC );
   1dca8:	9b06      	ldr	r3, [sp, #24]
   1dcaa:	f8db 0000 	ldr.w	r0, [fp]
   1dcae:	e953 4532 	ldrd	r4, r5, [r3, #-200]	; 0xc8
   1dcb2:	fb82 0100 	smull	r0, r1, r2, r0
   1dcb6:	0c06      	lsrs	r6, r0, #16
   1dcb8:	ea46 4601 	orr.w	r6, r6, r1, lsl #16
   1dcbc:	140f      	asrs	r7, r1, #16
   1dcbe:	19a1      	adds	r1, r4, r6
   1dcc0:	eb45 0207 	adc.w	r2, r5, r7
   1dcc4:	e943 1232 	strd	r1, r2, [r3, #-200]	; 0xc8
    for( n = 0; n < length; n++ ) {
   1dcc8:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   1dccc:	4293      	cmp	r3, r2
   1dcce:	d18b      	bne.n	1dbe8 <silk_warped_autocorrelation_FIX_c+0x58>
   1dcd0:	e9dd 2324 	ldrd	r2, r3, [sp, #144]	; 0x90
    if (in_upper == 0) {
   1dcd4:	b393      	cbz	r3, 1dd3c <silk_warped_autocorrelation_FIX_c+0x1ac>
   1dcd6:	fab3 f383 	clz	r3, r3
   1dcda:	3b23      	subs	r3, #35	; 0x23
    }

    lsh = silk_CLZ64( corr_QC[ 0 ] ) - 35;
    lsh = silk_LIMIT( lsh, -12 - QC, 30 - QC );
   1dcdc:	f06f 0015 	mvn.w	r0, #21
   1dce0:	4298      	cmp	r0, r3
   1dce2:	bfb8      	it	lt
   1dce4:	4618      	movlt	r0, r3
    *scale = -( QC + lsh );
   1dce6:	f06f 0209 	mvn.w	r2, #9
   1dcea:	9908      	ldr	r1, [sp, #32]
   1dcec:	1a12      	subs	r2, r2, r0
    silk_assert( *scale >= -30 && *scale <= 12 );
    if( lsh >= 0 ) {
   1dcee:	2b00      	cmp	r3, #0
    *scale = -( QC + lsh );
   1dcf0:	600a      	str	r2, [r1, #0]
    if( lsh >= 0 ) {
   1dcf2:	da2e      	bge.n	1dd52 <silk_warped_autocorrelation_FIX_c+0x1c2>
        for( i = 0; i < order + 1; i++ ) {
            corr[ i ] = (opus_int32)silk_CHECK_FIT32( silk_LSHIFT64( corr_QC[ i ], lsh ) );
        }
    } else {
        for( i = 0; i < order + 1; i++ ) {
   1dcf4:	9b61      	ldr	r3, [sp, #388]	; 0x184
   1dcf6:	2b00      	cmp	r3, #0
   1dcf8:	db1d      	blt.n	1dd36 <silk_warped_autocorrelation_FIX_c+0x1a6>
   1dcfa:	9909      	ldr	r1, [sp, #36]	; 0x24
   1dcfc:	461c      	mov	r4, r3
   1dcfe:	4240      	negs	r0, r0
   1dd00:	eb01 0384 	add.w	r3, r1, r4, lsl #2
   1dd04:	aa24      	add	r2, sp, #144	; 0x90
   1dd06:	1f0c      	subs	r4, r1, #4
   1dd08:	f1c0 0c20 	rsb	ip, r0, #32
            corr[ i ] = (opus_int32)silk_CHECK_FIT32( silk_RSHIFT64( corr_QC[ i ], -lsh ) );
   1dd0c:	e9d2 1600 	ldrd	r1, r6, [r2]
   1dd10:	f1b0 0520 	subs.w	r5, r0, #32
   1dd14:	fa21 f100 	lsr.w	r1, r1, r0
   1dd18:	fa06 f70c 	lsl.w	r7, r6, ip
   1dd1c:	f104 0404 	add.w	r4, r4, #4
   1dd20:	ea41 0107 	orr.w	r1, r1, r7
   1dd24:	bf5c      	itt	pl
   1dd26:	fa46 f505 	asrpl.w	r5, r6, r5
   1dd2a:	4329      	orrpl	r1, r5
        for( i = 0; i < order + 1; i++ ) {
   1dd2c:	42a3      	cmp	r3, r4
   1dd2e:	f102 0208 	add.w	r2, r2, #8
            corr[ i ] = (opus_int32)silk_CHECK_FIT32( silk_RSHIFT64( corr_QC[ i ], -lsh ) );
   1dd32:	6021      	str	r1, [r4, #0]
        for( i = 0; i < order + 1; i++ ) {
   1dd34:	d1ea      	bne.n	1dd0c <silk_warped_autocorrelation_FIX_c+0x17c>
        }
    }
    silk_assert( corr_QC[ 0 ] >= 0 ); /* If breaking, decrease QC*/
}
   1dd36:	b057      	add	sp, #348	; 0x15c
   1dd38:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1dd3c:	b122      	cbz	r2, 1dd48 <silk_warped_autocorrelation_FIX_c+0x1b8>
   1dd3e:	fab2 f382 	clz	r3, r2
   1dd42:	3b03      	subs	r3, #3
    lsh = silk_LIMIT( lsh, -12 - QC, 30 - QC );
   1dd44:	2b14      	cmp	r3, #20
   1dd46:	ddc9      	ble.n	1dcdc <silk_warped_autocorrelation_FIX_c+0x14c>
    *scale = -( QC + lsh );
   1dd48:	9a08      	ldr	r2, [sp, #32]
   1dd4a:	f06f 031d 	mvn.w	r3, #29
   1dd4e:	6013      	str	r3, [r2, #0]
    lsh = silk_LIMIT( lsh, -12 - QC, 30 - QC );
   1dd50:	2014      	movs	r0, #20
        for( i = 0; i < order + 1; i++ ) {
   1dd52:	9b61      	ldr	r3, [sp, #388]	; 0x184
   1dd54:	2b00      	cmp	r3, #0
   1dd56:	dbee      	blt.n	1dd36 <silk_warped_autocorrelation_FIX_c+0x1a6>
   1dd58:	461c      	mov	r4, r3
   1dd5a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1dd5c:	a924      	add	r1, sp, #144	; 0x90
   1dd5e:	eb03 0484 	add.w	r4, r3, r4, lsl #2
   1dd62:	1f1a      	subs	r2, r3, #4
            corr[ i ] = (opus_int32)silk_CHECK_FIT32( silk_LSHIFT64( corr_QC[ i ], lsh ) );
   1dd64:	f851 3b08 	ldr.w	r3, [r1], #8
   1dd68:	4083      	lsls	r3, r0
   1dd6a:	f842 3f04 	str.w	r3, [r2, #4]!
        for( i = 0; i < order + 1; i++ ) {
   1dd6e:	4294      	cmp	r4, r2
   1dd70:	d1f8      	bne.n	1dd64 <silk_warped_autocorrelation_FIX_c+0x1d4>
}
   1dd72:	b057      	add	sp, #348	; 0x15c
   1dd74:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0001dd78 <silk_apply_sine_window>:
    opus_int16                  px_win[],           /* O    Pointer to windowed signal                                  */
    const opus_int16            px[],               /* I    Pointer to input signal                                     */
    const opus_int              win_type,           /* I    Selects a window type                                       */
    const opus_int              length              /* I    Window length, multiple of 4                                */
)
{
   1dd78:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1dd7c:	461e      	mov	r6, r3
    /* Length must be in a range from 16 to 120 and a multiple of 4 */
    celt_assert( length >= 16 && length <= 120 );
    celt_assert( ( length & 3 ) == 0 );

    /* Frequency */
    k = ( length >> 2 ) - 4;
   1dd7e:	109b      	asrs	r3, r3, #2
    celt_assert( k >= 0 && k <= 26 );
    f_Q16 = (opus_int)freq_table_Q16[ k ];
   1dd80:	3b04      	subs	r3, #4
   1dd82:	4c3d      	ldr	r4, [pc, #244]	; (1de78 <silk_apply_sine_window+0x100>)
   1dd84:	f934 4013 	ldrsh.w	r4, [r4, r3, lsl #1]

    /* Factor used for cosine approximation */
    c_Q16 = silk_SMULWB( (opus_int32)f_Q16, -f_Q16 );
   1dd88:	4267      	negs	r7, r4
   1dd8a:	b23f      	sxth	r7, r7
   1dd8c:	b2a3      	uxth	r3, r4
   1dd8e:	1425      	asrs	r5, r4, #16
   1dd90:	fb07 f303 	mul.w	r3, r7, r3
   1dd94:	fb07 f505 	mul.w	r5, r7, r5
    silk_assert( c_Q16 >= -32768 );

    /* initialize state */
    if( win_type == 1 ) {
   1dd98:	2a01      	cmp	r2, #1
    c_Q16 = silk_SMULWB( (opus_int32)f_Q16, -f_Q16 );
   1dd9a:	eb05 4523 	add.w	r5, r5, r3, asr #16
    if( win_type == 1 ) {
   1dd9e:	d066      	beq.n	1de6e <silk_apply_sine_window+0xf6>
        S1_Q16 = f_Q16 + silk_RSHIFT( length, 3 );
    } else {
        /* start from 1 */
        S0_Q16 = ( (opus_int32)1 << 16 );
        /* approximation of cos(f) */
        S1_Q16 = ( (opus_int32)1 << 16 ) + silk_RSHIFT( c_Q16, 1 ) + silk_RSHIFT( length, 4 );
   1dda0:	106c      	asrs	r4, r5, #1
   1dda2:	f504 3480 	add.w	r4, r4, #65536	; 0x10000
   1dda6:	eb04 1426 	add.w	r4, r4, r6, asr #4
        S0_Q16 = ( (opus_int32)1 << 16 );
   1ddaa:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    }

    /* Uses the recursive equation:   sin(n*f) = 2 * cos(f) * sin((n-1)*f) - sin((n-2)*f)    */
    /* 4 samples at a time */
    for( k = 0; k < length; k += 4 ) {
   1ddae:	2e00      	cmp	r6, #0
   1ddb0:	dd5b      	ble.n	1de6a <silk_apply_sine_window+0xf2>
   1ddb2:	3e01      	subs	r6, #1
   1ddb4:	08b6      	lsrs	r6, r6, #2
   1ddb6:	f101 0208 	add.w	r2, r1, #8
   1ddba:	b22d      	sxth	r5, r5
   1ddbc:	eb02 06c6 	add.w	r6, r2, r6, lsl #3
        px_win[ k ]     = (opus_int16)silk_SMULWB( silk_RSHIFT( S0_Q16 + S1_Q16, 1 ), px[ k ] );
   1ddc0:	f9b1 c000 	ldrsh.w	ip, [r1]
   1ddc4:	191a      	adds	r2, r3, r4
   1ddc6:	f3c2 074f 	ubfx	r7, r2, #1, #16
   1ddca:	1452      	asrs	r2, r2, #17
   1ddcc:	fb0c f707 	mul.w	r7, ip, r7
   1ddd0:	fb12 f20c 	smulbb	r2, r2, ip
   1ddd4:	eb02 4227 	add.w	r2, r2, r7, asr #16
        px_win[ k + 1 ] = (opus_int16)silk_SMULWB( S1_Q16, px[ k + 1] );
   1ddd8:	fa1f fc84 	uxth.w	ip, r4
   1dddc:	1427      	asrs	r7, r4, #16
        px_win[ k ]     = (opus_int16)silk_SMULWB( silk_RSHIFT( S0_Q16 + S1_Q16, 1 ), px[ k ] );
   1ddde:	8002      	strh	r2, [r0, #0]
        S0_Q16 = silk_SMULWB( S1_Q16, c_Q16 ) + silk_LSHIFT( S1_Q16, 1 ) - S0_Q16 + 1;
   1dde0:	fb05 f80c 	mul.w	r8, r5, ip
   1dde4:	fb05 f207 	mul.w	r2, r5, r7
   1dde8:	eb02 4228 	add.w	r2, r2, r8, asr #16
        px_win[ k + 1 ] = (opus_int16)silk_SMULWB( S1_Q16, px[ k + 1] );
   1ddec:	f9b1 e002 	ldrsh.w	lr, [r1, #2]
        S0_Q16 = silk_SMULWB( S1_Q16, c_Q16 ) + silk_LSHIFT( S1_Q16, 1 ) - S0_Q16 + 1;
   1ddf0:	eb02 0244 	add.w	r2, r2, r4, lsl #1
   1ddf4:	1ad3      	subs	r3, r2, r3
   1ddf6:	3301      	adds	r3, #1
        px_win[ k + 1 ] = (opus_int16)silk_SMULWB( S1_Q16, px[ k + 1] );
   1ddf8:	fb0c fc0e 	mul.w	ip, ip, lr
   1ddfc:	fb17 f70e 	smulbb	r7, r7, lr
   1de00:	eb07 472c 	add.w	r7, r7, ip, asr #16
        S0_Q16 = silk_min( S0_Q16, ( (opus_int32)1 << 16 ) );
   1de04:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
   1de08:	bfa8      	it	ge
   1de0a:	f44f 3380 	movge.w	r3, #65536	; 0x10000
        px_win[ k + 1 ] = (opus_int16)silk_SMULWB( S1_Q16, px[ k + 1] );
   1de0e:	8047      	strh	r7, [r0, #2]

        px_win[ k + 2 ] = (opus_int16)silk_SMULWB( silk_RSHIFT( S0_Q16 + S1_Q16, 1 ), px[ k + 2] );
   1de10:	f9b1 c004 	ldrsh.w	ip, [r1, #4]
   1de14:	191a      	adds	r2, r3, r4
   1de16:	f3c2 074f 	ubfx	r7, r2, #1, #16
   1de1a:	1452      	asrs	r2, r2, #17
   1de1c:	fb0c f707 	mul.w	r7, ip, r7
   1de20:	fb12 f20c 	smulbb	r2, r2, ip
   1de24:	eb02 4227 	add.w	r2, r2, r7, asr #16
        px_win[ k + 3 ] = (opus_int16)silk_SMULWB( S0_Q16, px[ k + 3 ] );
   1de28:	fa1f fc83 	uxth.w	ip, r3
   1de2c:	141f      	asrs	r7, r3, #16
        px_win[ k + 2 ] = (opus_int16)silk_SMULWB( silk_RSHIFT( S0_Q16 + S1_Q16, 1 ), px[ k + 2] );
   1de2e:	8082      	strh	r2, [r0, #4]
        S1_Q16 = silk_SMULWB( S0_Q16, c_Q16 ) + silk_LSHIFT( S0_Q16, 1 ) - S1_Q16;
   1de30:	fb05 f80c 	mul.w	r8, r5, ip
   1de34:	fb05 f207 	mul.w	r2, r5, r7
   1de38:	eb02 4228 	add.w	r2, r2, r8, asr #16
        px_win[ k + 3 ] = (opus_int16)silk_SMULWB( S0_Q16, px[ k + 3 ] );
   1de3c:	f9b1 e006 	ldrsh.w	lr, [r1, #6]
        S1_Q16 = silk_SMULWB( S0_Q16, c_Q16 ) + silk_LSHIFT( S0_Q16, 1 ) - S1_Q16;
   1de40:	eb02 0243 	add.w	r2, r2, r3, lsl #1
   1de44:	1b14      	subs	r4, r2, r4
        S1_Q16 = silk_min( S1_Q16, ( (opus_int32)1 << 16 ) );
   1de46:	f5b4 3f80 	cmp.w	r4, #65536	; 0x10000
        px_win[ k + 3 ] = (opus_int16)silk_SMULWB( S0_Q16, px[ k + 3 ] );
   1de4a:	fb0c fc0e 	mul.w	ip, ip, lr
   1de4e:	fb17 f70e 	smulbb	r7, r7, lr
   1de52:	f101 0108 	add.w	r1, r1, #8
   1de56:	eb07 472c 	add.w	r7, r7, ip, asr #16
        S1_Q16 = silk_min( S1_Q16, ( (opus_int32)1 << 16 ) );
   1de5a:	bfa8      	it	ge
   1de5c:	f44f 3480 	movge.w	r4, #65536	; 0x10000
    for( k = 0; k < length; k += 4 ) {
   1de60:	428e      	cmp	r6, r1
        px_win[ k + 3 ] = (opus_int16)silk_SMULWB( S0_Q16, px[ k + 3 ] );
   1de62:	80c7      	strh	r7, [r0, #6]
   1de64:	f100 0008 	add.w	r0, r0, #8
    for( k = 0; k < length; k += 4 ) {
   1de68:	d1aa      	bne.n	1ddc0 <silk_apply_sine_window+0x48>
    }
}
   1de6a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        S1_Q16 = f_Q16 + silk_RSHIFT( length, 3 );
   1de6e:	eb04 04e6 	add.w	r4, r4, r6, asr #3
        S0_Q16 = 0;
   1de72:	2300      	movs	r3, #0
   1de74:	e79b      	b.n	1ddae <silk_apply_sine_window+0x36>
   1de76:	bf00      	nop
   1de78:	000377b4 	.word	0x000377b4

0001de7c <silk_autocorr>:
    const opus_int16            *inputData,         /* I    Input data to correlate                                     */
    const opus_int              inputDataSize,      /* I    Length of input                                             */
    const opus_int              correlationCount,   /* I    Number of correlation taps to compute                       */
    int                         arch                /* I    Run-time architecture                                       */
)
{
   1de7c:	b570      	push	{r4, r5, r6, lr}
   1de7e:	b084      	sub	sp, #16
   1de80:	e9dd 4508 	ldrd	r4, r5, [sp, #32]
    return (((a) < (b)) ? (a) : (b));
   1de84:	429c      	cmp	r4, r3
   1de86:	bfa8      	it	ge
   1de88:	461c      	movge	r4, r3
    opus_int   corrCount;
    corrCount = silk_min_int( inputDataSize, correlationCount );
    *scale = _celt_autocorr(inputData, results, NULL, 0, corrCount-1, inputDataSize, arch);
   1de8a:	9502      	str	r5, [sp, #8]
   1de8c:	3c01      	subs	r4, #1
{
   1de8e:	461d      	mov	r5, r3
    *scale = _celt_autocorr(inputData, results, NULL, 0, corrCount-1, inputDataSize, arch);
   1de90:	2300      	movs	r3, #0
{
   1de92:	460e      	mov	r6, r1
    *scale = _celt_autocorr(inputData, results, NULL, 0, corrCount-1, inputDataSize, arch);
   1de94:	9501      	str	r5, [sp, #4]
   1de96:	4601      	mov	r1, r0
   1de98:	9400      	str	r4, [sp, #0]
   1de9a:	4610      	mov	r0, r2
   1de9c:	461a      	mov	r2, r3
   1de9e:	f00e fdc3 	bl	2ca28 <_celt_autocorr>
   1dea2:	6030      	str	r0, [r6, #0]
}
   1dea4:	b004      	add	sp, #16
   1dea6:	bd70      	pop	{r4, r5, r6, pc}

0001dea8 <silk_burg_modified_c>:
    const opus_int              subfr_length,       /* I    Input signal subframe length (incl. D preceding samples)    */
    const opus_int              nb_subfr,           /* I    Number of subframes stacked in x                            */
    const opus_int              D,                  /* I    Order                                                       */
    int                         arch                /* I    Run-time architecture                                       */
)
{
   1dea8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1deac:	f5ad 7d33 	sub.w	sp, sp, #716	; 0x2cc
   1deb0:	e9cd 011c 	strd	r0, r1, [sp, #112]	; 0x70
   1deb4:	9fbd      	ldr	r7, [sp, #756]	; 0x2f4
   1deb6:	9318      	str	r3, [sp, #96]	; 0x60
    opus_int64       C0_64;

    celt_assert( subfr_length * nb_subfr <= MAX_FRAME_SIZE );

    /* Compute autocorrelations, added over subframes */
    C0_64 = silk_inner_prod16_aligned_64( x, x, subfr_length*nb_subfr, arch );
   1deb8:	4619      	mov	r1, r3
   1deba:	4618      	mov	r0, r3
   1debc:	9bbe      	ldr	r3, [sp, #760]	; 0x2f8
{
   1debe:	921f      	str	r2, [sp, #124]	; 0x7c
    C0_64 = silk_inner_prod16_aligned_64( x, x, subfr_length*nb_subfr, arch );
   1dec0:	fb03 f207 	mul.w	r2, r3, r7
   1dec4:	f001 ff5a 	bl	1fd7c <silk_inner_prod16_aligned_64_c>
   1dec8:	2900      	cmp	r1, #0
   1deca:	f040 8095 	bne.w	1dff8 <silk_burg_modified_c+0x150>
   1dece:	2800      	cmp	r0, #0
   1ded0:	f040 8225 	bne.w	1e31e <silk_burg_modified_c+0x476>
    lz = silk_CLZ64(C0_64);
    rshifts = 32 + 1 + N_BITS_HEAD_ROOM - lz;
    if (rshifts > MAX_RSHIFTS) rshifts = MAX_RSHIFTS;
    if (rshifts < MIN_RSHIFTS) rshifts = MIN_RSHIFTS;
   1ded4:	2110      	movs	r1, #16
   1ded6:	f06f 030f 	mvn.w	r3, #15
   1deda:	e9cd 1316 	strd	r1, r3, [sp, #88]	; 0x58

    if (rshifts > 0) {
        C0 = (opus_int32)silk_RSHIFT64(C0_64, rshifts );
    } else {
        C0 = silk_LSHIFT32((opus_int32)C0_64, -rshifts );
   1dede:	9b16      	ldr	r3, [sp, #88]	; 0x58
    }

    CAb[ 0 ] = CAf[ 0 ] = C0 + silk_SMMUL( SILK_FIX_CONST( FIND_LPC_COND_FAC, 32 ), C0 ) + 1;                                /* Q(-rshifts) */
   1dee0:	f24a 74c6 	movw	r4, #42950	; 0xa7c6
        C0 = silk_LSHIFT32((opus_int32)C0_64, -rshifts );
   1dee4:	fa00 f303 	lsl.w	r3, r0, r3
    CAb[ 0 ] = CAf[ 0 ] = C0 + silk_SMMUL( SILK_FIX_CONST( FIND_LPC_COND_FAC, 32 ), C0 ) + 1;                                /* Q(-rshifts) */
   1dee8:	fb83 5604 	smull	r5, r6, r3, r4
   1deec:	199c      	adds	r4, r3, r6
    silk_memset( C_first_row, 0, SILK_MAX_ORDER_LPC * sizeof( opus_int32 ) );
   1deee:	a820      	add	r0, sp, #128	; 0x80
    CAb[ 0 ] = CAf[ 0 ] = C0 + silk_SMMUL( SILK_FIX_CONST( FIND_LPC_COND_FAC, 32 ), C0 ) + 1;                                /* Q(-rshifts) */
   1def0:	3401      	adds	r4, #1
    silk_memset( C_first_row, 0, SILK_MAX_ORDER_LPC * sizeof( opus_int32 ) );
   1def2:	2260      	movs	r2, #96	; 0x60
   1def4:	2100      	movs	r1, #0
        C0 = silk_LSHIFT32((opus_int32)C0_64, -rshifts );
   1def6:	931b      	str	r3, [sp, #108]	; 0x6c
    silk_memset( C_first_row, 0, SILK_MAX_ORDER_LPC * sizeof( opus_int32 ) );
   1def8:	9008      	str	r0, [sp, #32]
    CAb[ 0 ] = CAf[ 0 ] = C0 + silk_SMMUL( SILK_FIX_CONST( FIND_LPC_COND_FAC, 32 ), C0 ) + 1;                                /* Q(-rshifts) */
   1defa:	9480      	str	r4, [sp, #512]	; 0x200
   1defc:	9499      	str	r4, [sp, #612]	; 0x264
   1defe:	961e      	str	r6, [sp, #120]	; 0x78
    silk_memset( C_first_row, 0, SILK_MAX_ORDER_LPC * sizeof( opus_int32 ) );
   1df00:	f017 f930 	bl	35164 <memset>
                C_first_row[ n - 1 ] += (opus_int32)silk_RSHIFT64(
                    silk_inner_prod16_aligned_64( x_ptr, x_ptr + n, subfr_length - n, arch ), rshifts );
            }
        }
    } else {
        for( s = 0; s < nb_subfr; s++ ) {
   1df04:	9bbe      	ldr	r3, [sp, #760]	; 0x2f8
   1df06:	2b00      	cmp	r3, #0
   1df08:	dd66      	ble.n	1dfd8 <silk_burg_modified_c+0x130>
   1df0a:	9bbf      	ldr	r3, [sp, #764]	; 0x2fc
   1df0c:	9abf      	ldr	r2, [sp, #764]	; 0x2fc
   1df0e:	9818      	ldr	r0, [sp, #96]	; 0x60
   1df10:	9407      	str	r4, [sp, #28]
   1df12:	1bdb      	subs	r3, r3, r7
   1df14:	005b      	lsls	r3, r3, #1
   1df16:	9303      	str	r3, [sp, #12]
   1df18:	3302      	adds	r3, #2
   1df1a:	1aba      	subs	r2, r7, r2
   1df1c:	9305      	str	r3, [sp, #20]
   1df1e:	9bbf      	ldr	r3, [sp, #764]	; 0x2fc
   1df20:	9204      	str	r2, [sp, #16]
   1df22:	eb00 0642 	add.w	r6, r0, r2, lsl #1
   1df26:	aa68      	add	r2, sp, #416	; 0x1a0
   1df28:	eb02 0883 	add.w	r8, r2, r3, lsl #2
   1df2c:	2300      	movs	r3, #0
   1df2e:	9302      	str	r3, [sp, #8]
   1df30:	1c7b      	adds	r3, r7, #1
   1df32:	9306      	str	r3, [sp, #24]
   1df34:	9bbf      	ldr	r3, [sp, #764]	; 0x2fc
   1df36:	0079      	lsls	r1, r7, #1
   1df38:	1e85      	subs	r5, r0, #2
   1df3a:	3301      	adds	r3, #1
   1df3c:	910c      	str	r1, [sp, #48]	; 0x30
   1df3e:	440d      	add	r5, r1
   1df40:	461c      	mov	r4, r3
            int i;
            opus_int32 d;
            x_ptr = x + s * subfr_length;
            celt_pitch_xcorr(x_ptr, x_ptr + 1, xcorr, subfr_length - D, D, arch );
   1df42:	9bc0      	ldr	r3, [sp, #768]	; 0x300
   1df44:	9905      	ldr	r1, [sp, #20]
   1df46:	9803      	ldr	r0, [sp, #12]
   1df48:	9301      	str	r3, [sp, #4]
   1df4a:	9bbf      	ldr	r3, [sp, #764]	; 0x2fc
   1df4c:	9300      	str	r3, [sp, #0]
   1df4e:	aa68      	add	r2, sp, #416	; 0x1a0
   1df50:	9b04      	ldr	r3, [sp, #16]
   1df52:	4431      	add	r1, r6
   1df54:	4430      	add	r0, r6
   1df56:	f00e f817 	bl	2bf88 <celt_pitch_xcorr_c>
            for( n = 1; n < D + 1; n++ ) {
   1df5a:	9bbf      	ldr	r3, [sp, #764]	; 0x2fc
   1df5c:	2b00      	cmp	r3, #0
   1df5e:	dd31      	ble.n	1dfc4 <silk_burg_modified_c+0x11c>
   1df60:	461a      	mov	r2, r3
   1df62:	9b06      	ldr	r3, [sp, #24]
   1df64:	46b2      	mov	sl, r6
   1df66:	eba3 0902 	sub.w	r9, r3, r2
   1df6a:	f50d 7ed0 	add.w	lr, sp, #416	; 0x1a0
   1df6e:	f04f 0c01 	mov.w	ip, #1
               for ( i = n + subfr_length - D, d = 0; i < subfr_length; i++ )
   1df72:	454f      	cmp	r7, r9
   1df74:	f340 83d5 	ble.w	1e722 <silk_burg_modified_c+0x87a>
   1df78:	4631      	mov	r1, r6
   1df7a:	4653      	mov	r3, sl
   1df7c:	2200      	movs	r2, #0
                  d = MAC16_16( d, x_ptr[ i ], x_ptr[ i - n ] );
   1df7e:	f833 bf02 	ldrh.w	fp, [r3, #2]!
   1df82:	f931 0b02 	ldrsh.w	r0, [r1], #2
               for ( i = n + subfr_length - D, d = 0; i < subfr_length; i++ )
   1df86:	429d      	cmp	r5, r3
                  d = MAC16_16( d, x_ptr[ i ], x_ptr[ i - n ] );
   1df88:	fb1b 2200 	smlabb	r2, fp, r0, r2
               for ( i = n + subfr_length - D, d = 0; i < subfr_length; i++ )
   1df8c:	d1f7      	bne.n	1df7e <silk_burg_modified_c+0xd6>
               xcorr[ n - 1 ] += d;
   1df8e:	f8de 3000 	ldr.w	r3, [lr]
            for( n = 1; n < D + 1; n++ ) {
   1df92:	f10c 0c01 	add.w	ip, ip, #1
               xcorr[ n - 1 ] += d;
   1df96:	441a      	add	r2, r3
            for( n = 1; n < D + 1; n++ ) {
   1df98:	45a4      	cmp	ip, r4
   1df9a:	f109 0901 	add.w	r9, r9, #1
   1df9e:	f10a 0a02 	add.w	sl, sl, #2
               xcorr[ n - 1 ] += d;
   1dfa2:	f84e 2b04 	str.w	r2, [lr], #4
            for( n = 1; n < D + 1; n++ ) {
   1dfa6:	d1e4      	bne.n	1df72 <silk_burg_modified_c+0xca>
   1dfa8:	f8dd c058 	ldr.w	ip, [sp, #88]	; 0x58
   1dfac:	a81f      	add	r0, sp, #124	; 0x7c
   1dfae:	a968      	add	r1, sp, #416	; 0x1a0
            }
            for( n = 1; n < D + 1; n++ ) {
                C_first_row[ n - 1 ] += silk_LSHIFT32( xcorr[ n - 1 ], -rshifts );
   1dfb0:	f851 2b04 	ldr.w	r2, [r1], #4
   1dfb4:	f850 3f04 	ldr.w	r3, [r0, #4]!
   1dfb8:	fa02 f20c 	lsl.w	r2, r2, ip
   1dfbc:	4413      	add	r3, r2
            for( n = 1; n < D + 1; n++ ) {
   1dfbe:	4588      	cmp	r8, r1
                C_first_row[ n - 1 ] += silk_LSHIFT32( xcorr[ n - 1 ], -rshifts );
   1dfc0:	6003      	str	r3, [r0, #0]
            for( n = 1; n < D + 1; n++ ) {
   1dfc2:	d1f5      	bne.n	1dfb0 <silk_burg_modified_c+0x108>
   1dfc4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
        for( s = 0; s < nb_subfr; s++ ) {
   1dfc6:	9b02      	ldr	r3, [sp, #8]
   1dfc8:	4416      	add	r6, r2
   1dfca:	4415      	add	r5, r2
   1dfcc:	9abe      	ldr	r2, [sp, #760]	; 0x2f8
   1dfce:	3301      	adds	r3, #1
   1dfd0:	429a      	cmp	r2, r3
   1dfd2:	9302      	str	r3, [sp, #8]
   1dfd4:	d1b5      	bne.n	1df42 <silk_burg_modified_c+0x9a>
   1dfd6:	9c07      	ldr	r4, [sp, #28]
            }
        }
    }
    silk_memcpy( C_last_row, C_first_row, SILK_MAX_ORDER_LPC * sizeof( opus_int32 ) );
   1dfd8:	9908      	ldr	r1, [sp, #32]
   1dfda:	ab38      	add	r3, sp, #224	; 0xe0
   1dfdc:	4618      	mov	r0, r3
   1dfde:	2260      	movs	r2, #96	; 0x60
   1dfe0:	9309      	str	r3, [sp, #36]	; 0x24
   1dfe2:	f7ee f88d 	bl	c100 <memcpy>
    /* Initialize */
    CAb[ 0 ] = CAf[ 0 ] = C0 + silk_SMMUL( SILK_FIX_CONST( FIND_LPC_COND_FAC, 32 ), C0 ) + 1;                                /* Q(-rshifts) */

    invGain_Q30 = (opus_int32)1 << 30;
    reached_max_gain = 0;
    for( n = 0; n < D; n++ ) {
   1dfe6:	9bbf      	ldr	r3, [sp, #764]	; 0x2fc
    CAb[ 0 ] = CAf[ 0 ] = C0 + silk_SMMUL( SILK_FIX_CONST( FIND_LPC_COND_FAC, 32 ), C0 ) + 1;                                /* Q(-rshifts) */
   1dfe8:	9480      	str	r4, [sp, #512]	; 0x200
    for( n = 0; n < D; n++ ) {
   1dfea:	2b00      	cmp	r3, #0
    CAb[ 0 ] = CAf[ 0 ] = C0 + silk_SMMUL( SILK_FIX_CONST( FIND_LPC_COND_FAC, 32 ), C0 ) + 1;                                /* Q(-rshifts) */
   1dfec:	9499      	str	r4, [sp, #612]	; 0x264
    for( n = 0; n < D; n++ ) {
   1dfee:	f340 84db 	ble.w	1e9a8 <silk_burg_modified_c+0xb00>
   1dff2:	007b      	lsls	r3, r7, #1
   1dff4:	930c      	str	r3, [sp, #48]	; 0x30
   1dff6:	e073      	b.n	1e0e0 <silk_burg_modified_c+0x238>
   1dff8:	fab1 f381 	clz	r3, r1
   1dffc:	f1c3 0324 	rsb	r3, r3, #36	; 0x24
    if (rshifts > MAX_RSHIFTS) rshifts = MAX_RSHIFTS;
   1e000:	2b07      	cmp	r3, #7
   1e002:	9317      	str	r3, [sp, #92]	; 0x5c
   1e004:	f340 8190 	ble.w	1e328 <silk_burg_modified_c+0x480>
   1e008:	f06f 0406 	mvn.w	r4, #6
   1e00c:	2307      	movs	r3, #7
   1e00e:	e9cd 4316 	strd	r4, r3, [sp, #88]	; 0x58
        C0 = (opus_int32)silk_RSHIFT64(C0_64, rshifts );
   1e012:	f1c3 0920 	rsb	r9, r3, #32
   1e016:	fa01 f209 	lsl.w	r2, r1, r9
   1e01a:	40d8      	lsrs	r0, r3
   1e01c:	3b20      	subs	r3, #32
   1e01e:	ea40 0002 	orr.w	r0, r0, r2
   1e022:	bf5c      	itt	pl
   1e024:	fa41 f303 	asrpl.w	r3, r1, r3
   1e028:	4318      	orrpl	r0, r3
    CAb[ 0 ] = CAf[ 0 ] = C0 + silk_SMMUL( SILK_FIX_CONST( FIND_LPC_COND_FAC, 32 ), C0 ) + 1;                                /* Q(-rshifts) */
   1e02a:	f24a 74c6 	movw	r4, #42950	; 0xa7c6
   1e02e:	fb80 5604 	smull	r5, r6, r0, r4
   1e032:	1984      	adds	r4, r0, r6
        C0 = (opus_int32)silk_RSHIFT64(C0_64, rshifts );
   1e034:	901b      	str	r0, [sp, #108]	; 0x6c
    CAb[ 0 ] = CAf[ 0 ] = C0 + silk_SMMUL( SILK_FIX_CONST( FIND_LPC_COND_FAC, 32 ), C0 ) + 1;                                /* Q(-rshifts) */
   1e036:	3401      	adds	r4, #1
    silk_memset( C_first_row, 0, SILK_MAX_ORDER_LPC * sizeof( opus_int32 ) );
   1e038:	a820      	add	r0, sp, #128	; 0x80
   1e03a:	2260      	movs	r2, #96	; 0x60
   1e03c:	2100      	movs	r1, #0
   1e03e:	9008      	str	r0, [sp, #32]
    CAb[ 0 ] = CAf[ 0 ] = C0 + silk_SMMUL( SILK_FIX_CONST( FIND_LPC_COND_FAC, 32 ), C0 ) + 1;                                /* Q(-rshifts) */
   1e040:	9480      	str	r4, [sp, #512]	; 0x200
   1e042:	9499      	str	r4, [sp, #612]	; 0x264
   1e044:	961e      	str	r6, [sp, #120]	; 0x78
    silk_memset( C_first_row, 0, SILK_MAX_ORDER_LPC * sizeof( opus_int32 ) );
   1e046:	f017 f88d 	bl	35164 <memset>
        for( s = 0; s < nb_subfr; s++ ) {
   1e04a:	9bbe      	ldr	r3, [sp, #760]	; 0x2f8
   1e04c:	2b00      	cmp	r3, #0
   1e04e:	ddc3      	ble.n	1dfd8 <silk_burg_modified_c+0x130>
   1e050:	9bbf      	ldr	r3, [sp, #764]	; 0x2fc
   1e052:	2b00      	cmp	r3, #0
   1e054:	f340 84a8 	ble.w	1e9a8 <silk_burg_modified_c+0xb00>
   1e058:	007b      	lsls	r3, r7, #1
   1e05a:	930c      	str	r3, [sp, #48]	; 0x30
   1e05c:	1e7b      	subs	r3, r7, #1
   1e05e:	9304      	str	r3, [sp, #16]
   1e060:	9b18      	ldr	r3, [sp, #96]	; 0x60
   1e062:	9e17      	ldr	r6, [sp, #92]	; 0x5c
   1e064:	9405      	str	r4, [sp, #20]
   1e066:	f103 0a02 	add.w	sl, r3, #2
   1e06a:	9bbf      	ldr	r3, [sp, #764]	; 0x2fc
   1e06c:	005b      	lsls	r3, r3, #1
   1e06e:	9303      	str	r3, [sp, #12]
   1e070:	2300      	movs	r3, #0
   1e072:	9302      	str	r3, [sp, #8]
   1e074:	9b03      	ldr	r3, [sp, #12]
   1e076:	f8dd b010 	ldr.w	fp, [sp, #16]
   1e07a:	f1aa 0802 	sub.w	r8, sl, #2
   1e07e:	ad1f      	add	r5, sp, #124	; 0x7c
   1e080:	eb0a 0703 	add.w	r7, sl, r3
   1e084:	4654      	mov	r4, sl
                C_first_row[ n - 1 ] += (opus_int32)silk_RSHIFT64(
   1e086:	465a      	mov	r2, fp
   1e088:	4621      	mov	r1, r4
   1e08a:	4640      	mov	r0, r8
   1e08c:	f001 fe76 	bl	1fd7c <silk_inner_prod16_aligned_64_c>
   1e090:	3504      	adds	r5, #4
   1e092:	f1b6 0320 	subs.w	r3, r6, #32
   1e096:	fa20 f006 	lsr.w	r0, r0, r6
   1e09a:	fa01 f209 	lsl.w	r2, r1, r9
   1e09e:	bf58      	it	pl
   1e0a0:	fa41 f303 	asrpl.w	r3, r1, r3
   1e0a4:	ea40 0002 	orr.w	r0, r0, r2
   1e0a8:	bf58      	it	pl
   1e0aa:	4318      	orrpl	r0, r3
   1e0ac:	682b      	ldr	r3, [r5, #0]
   1e0ae:	3402      	adds	r4, #2
   1e0b0:	4418      	add	r0, r3
            for( n = 1; n < D + 1; n++ ) {
   1e0b2:	42a7      	cmp	r7, r4
   1e0b4:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
                C_first_row[ n - 1 ] += (opus_int32)silk_RSHIFT64(
   1e0b8:	6028      	str	r0, [r5, #0]
            for( n = 1; n < D + 1; n++ ) {
   1e0ba:	d1e4      	bne.n	1e086 <silk_burg_modified_c+0x1de>
   1e0bc:	9a0c      	ldr	r2, [sp, #48]	; 0x30
        for( s = 0; s < nb_subfr; s++ ) {
   1e0be:	9b02      	ldr	r3, [sp, #8]
   1e0c0:	4492      	add	sl, r2
   1e0c2:	9abe      	ldr	r2, [sp, #760]	; 0x2f8
   1e0c4:	3301      	adds	r3, #1
   1e0c6:	429a      	cmp	r2, r3
   1e0c8:	9302      	str	r3, [sp, #8]
   1e0ca:	d1d3      	bne.n	1e074 <silk_burg_modified_c+0x1cc>
    silk_memcpy( C_last_row, C_first_row, SILK_MAX_ORDER_LPC * sizeof( opus_int32 ) );
   1e0cc:	ab38      	add	r3, sp, #224	; 0xe0
   1e0ce:	9c05      	ldr	r4, [sp, #20]
   1e0d0:	9908      	ldr	r1, [sp, #32]
   1e0d2:	9309      	str	r3, [sp, #36]	; 0x24
   1e0d4:	4618      	mov	r0, r3
   1e0d6:	2260      	movs	r2, #96	; 0x60
   1e0d8:	f7ee f812 	bl	c100 <memcpy>
    CAb[ 0 ] = CAf[ 0 ] = C0 + silk_SMMUL( SILK_FIX_CONST( FIND_LPC_COND_FAC, 32 ), C0 ) + 1;                                /* Q(-rshifts) */
   1e0dc:	9480      	str	r4, [sp, #512]	; 0x200
   1e0de:	9499      	str	r4, [sp, #612]	; 0x264
    a_headrm = silk_CLZ32( silk_abs(a32) ) - 1;
   1e0e0:	9bbc      	ldr	r3, [sp, #752]	; 0x2f0
   1e0e2:	2b00      	cmp	r3, #0
   1e0e4:	bfb8      	it	lt
   1e0e6:	425b      	neglt	r3, r3
   1e0e8:	fab3 f383 	clz	r3, r3
   1e0ec:	9319      	str	r3, [sp, #100]	; 0x64
   1e0ee:	3b01      	subs	r3, #1
   1e0f0:	931a      	str	r3, [sp, #104]	; 0x68
            for( n = 1; n < D + 1; n++ ) {
   1e0f2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1e0f4:	9315      	str	r3, [sp, #84]	; 0x54
    invGain_Q30 = (opus_int32)1 << 30;
   1e0f6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   1e0fa:	9314      	str	r3, [sp, #80]	; 0x50
   1e0fc:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   1e0fe:	f1c3 0310 	rsb	r3, r3, #16
   1e102:	9313      	str	r3, [sp, #76]	; 0x4c
        /* Update first row of correlation matrix (without first element) */
        /* Update last row of correlation matrix (without last element, stored in reversed order) */
        /* Update C * Af */
        /* Update C * flipud(Af) (stored in reversed order) */
        if( rshifts > -2 ) {
   1e104:	9b17      	ldr	r3, [sp, #92]	; 0x5c
            for( n = 1; n < D + 1; n++ ) {
   1e106:	2200      	movs	r2, #0
        if( rshifts > -2 ) {
   1e108:	3301      	adds	r3, #1
            for( n = 1; n < D + 1; n++ ) {
   1e10a:	920a      	str	r2, [sp, #40]	; 0x28
    for( n = 0; n < D; n++ ) {
   1e10c:	9207      	str	r2, [sp, #28]
            for( n = 1; n < D + 1; n++ ) {
   1e10e:	4625      	mov	r5, r4
            for( s = 0; s < nb_subfr; s++ ) {
   1e110:	9bbe      	ldr	r3, [sp, #760]	; 0x2f8
        if( rshifts > -2 ) {
   1e112:	f2c0 8251 	blt.w	1e5b8 <silk_burg_modified_c+0x710>
            for( s = 0; s < nb_subfr; s++ ) {
   1e116:	2b00      	cmp	r3, #0
   1e118:	f340 80a9 	ble.w	1e26e <silk_burg_modified_c+0x3c6>
   1e11c:	9b15      	ldr	r3, [sp, #84]	; 0x54
   1e11e:	f8dd a060 	ldr.w	sl, [sp, #96]	; 0x60
   1e122:	1e9a      	subs	r2, r3, #2
   1e124:	9212      	str	r2, [sp, #72]	; 0x48
   1e126:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   1e128:	f1c2 0207 	rsb	r2, r2, #7
   1e12c:	9211      	str	r2, [sp, #68]	; 0x44
   1e12e:	2200      	movs	r2, #0
   1e130:	920b      	str	r2, [sp, #44]	; 0x2c
   1e132:	aa7f      	add	r2, sp, #508	; 0x1fc
   1e134:	920d      	str	r2, [sp, #52]	; 0x34
   1e136:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   1e138:	3202      	adds	r2, #2
   1e13a:	920f      	str	r2, [sp, #60]	; 0x3c
   1e13c:	3b04      	subs	r3, #4
   1e13e:	aa98      	add	r2, sp, #608	; 0x260
   1e140:	9210      	str	r2, [sp, #64]	; 0x40
   1e142:	930e      	str	r3, [sp, #56]	; 0x38
                x_ptr = x + s * subfr_length;
                x1  = -silk_LSHIFT32( (opus_int32)x_ptr[ n ],                    16 - rshifts );        /* Q(16-rshifts) */
   1e144:	990a      	ldr	r1, [sp, #40]	; 0x28
                x2  = -silk_LSHIFT32( (opus_int32)x_ptr[ subfr_length - n - 1 ], 16 - rshifts );        /* Q(16-rshifts) */
   1e146:	9812      	ldr	r0, [sp, #72]	; 0x48
                x1  = -silk_LSHIFT32( (opus_int32)x_ptr[ n ],                    16 - rshifts );        /* Q(16-rshifts) */
   1e148:	f93a 7001 	ldrsh.w	r7, [sl, r1]
                x2  = -silk_LSHIFT32( (opus_int32)x_ptr[ subfr_length - n - 1 ], 16 - rshifts );        /* Q(16-rshifts) */
   1e14c:	f93a 6000 	ldrsh.w	r6, [sl, r0]
                x1  = -silk_LSHIFT32( (opus_int32)x_ptr[ n ],                    16 - rshifts );        /* Q(16-rshifts) */
   1e150:	9b13      	ldr	r3, [sp, #76]	; 0x4c
                tmp1 = silk_LSHIFT32( (opus_int32)x_ptr[ n ],                    QA - 16 );             /* Q(QA-16) */
                tmp2 = silk_LSHIFT32( (opus_int32)x_ptr[ subfr_length - n - 1 ], QA - 16 );             /* Q(QA-16) */
                for( k = 0; k < n; k++ ) {
   1e152:	9c07      	ldr	r4, [sp, #28]
                x1  = -silk_LSHIFT32( (opus_int32)x_ptr[ n ],                    16 - rshifts );        /* Q(16-rshifts) */
   1e154:	fa07 f203 	lsl.w	r2, r7, r3
                x2  = -silk_LSHIFT32( (opus_int32)x_ptr[ subfr_length - n - 1 ], 16 - rshifts );        /* Q(16-rshifts) */
   1e158:	fa06 f303 	lsl.w	r3, r6, r3
                x1  = -silk_LSHIFT32( (opus_int32)x_ptr[ n ],                    16 - rshifts );        /* Q(16-rshifts) */
   1e15c:	4252      	negs	r2, r2
                tmp1 = silk_LSHIFT32( (opus_int32)x_ptr[ n ],                    QA - 16 );             /* Q(QA-16) */
   1e15e:	027f      	lsls	r7, r7, #9
                x2  = -silk_LSHIFT32( (opus_int32)x_ptr[ subfr_length - n - 1 ], 16 - rshifts );        /* Q(16-rshifts) */
   1e160:	425b      	negs	r3, r3
                tmp2 = silk_LSHIFT32( (opus_int32)x_ptr[ subfr_length - n - 1 ], QA - 16 );             /* Q(QA-16) */
   1e162:	0276      	lsls	r6, r6, #9
                for( k = 0; k < n; k++ ) {
   1e164:	2c00      	cmp	r4, #0
   1e166:	d048      	beq.n	1e1fa <silk_burg_modified_c+0x352>
                    C_first_row[ k ] = silk_SMLAWB( C_first_row[ k ], x1, x_ptr[ n - k - 1 ]            ); /* Q( -rshifts ) */
   1e168:	1414      	asrs	r4, r2, #16
   1e16a:	b292      	uxth	r2, r2
   1e16c:	9205      	str	r2, [sp, #20]
                    C_last_row[ k ]  = silk_SMLAWB( C_last_row[ k ],  x2, x_ptr[ subfr_length - n + k ] ); /* Q( -rshifts ) */
   1e16e:	141a      	asrs	r2, r3, #16
   1e170:	b29b      	uxth	r3, r3
   1e172:	9306      	str	r3, [sp, #24]
   1e174:	eb00 030a 	add.w	r3, r0, sl
   1e178:	eb01 0e0a 	add.w	lr, r1, sl
   1e17c:	f8cd a008 	str.w	sl, [sp, #8]
                    C_first_row[ k ] = silk_SMLAWB( C_first_row[ k ], x1, x_ptr[ n - k - 1 ]            ); /* Q( -rshifts ) */
   1e180:	9403      	str	r4, [sp, #12]
                    C_last_row[ k ]  = silk_SMLAWB( C_last_row[ k ],  x2, x_ptr[ subfr_length - n + k ] ); /* Q( -rshifts ) */
   1e182:	9204      	str	r2, [sp, #16]
   1e184:	f10d 087c 	add.w	r8, sp, #124	; 0x7c
   1e188:	f10d 0cdc 	add.w	ip, sp, #220	; 0xdc
   1e18c:	f50d 79a0 	add.w	r9, sp, #320	; 0x140
   1e190:	469a      	mov	sl, r3
                    C_first_row[ k ] = silk_SMLAWB( C_first_row[ k ], x1, x_ptr[ n - k - 1 ]            ); /* Q( -rshifts ) */
   1e192:	f93e 3d02 	ldrsh.w	r3, [lr, #-2]!
   1e196:	9805      	ldr	r0, [sp, #20]
   1e198:	9c03      	ldr	r4, [sp, #12]
   1e19a:	f858 1f04 	ldr.w	r1, [r8, #4]!
                    C_last_row[ k ]  = silk_SMLAWB( C_last_row[ k ],  x2, x_ptr[ subfr_length - n + k ] ); /* Q( -rshifts ) */
   1e19e:	f93a 5f02 	ldrsh.w	r5, [sl, #2]!
                    Atmp_QA = Af_QA[ k ];
   1e1a2:	f859 2b04 	ldr.w	r2, [r9], #4
                    C_last_row[ k ]  = silk_SMLAWB( C_last_row[ k ],  x2, x_ptr[ subfr_length - n + k ] ); /* Q( -rshifts ) */
   1e1a6:	f85c bf04 	ldr.w	fp, [ip, #4]!
                    C_first_row[ k ] = silk_SMLAWB( C_first_row[ k ], x1, x_ptr[ n - k - 1 ]            ); /* Q( -rshifts ) */
   1e1aa:	fb03 f404 	mul.w	r4, r3, r4
   1e1ae:	fb00 f003 	mul.w	r0, r0, r3
   1e1b2:	eb04 4020 	add.w	r0, r4, r0, asr #16
   1e1b6:	4408      	add	r0, r1
                    C_last_row[ k ]  = silk_SMLAWB( C_last_row[ k ],  x2, x_ptr[ subfr_length - n + k ] ); /* Q( -rshifts ) */
   1e1b8:	9906      	ldr	r1, [sp, #24]
                    C_first_row[ k ] = silk_SMLAWB( C_first_row[ k ], x1, x_ptr[ n - k - 1 ]            ); /* Q( -rshifts ) */
   1e1ba:	f8c8 0000 	str.w	r0, [r8]
                    C_last_row[ k ]  = silk_SMLAWB( C_last_row[ k ],  x2, x_ptr[ subfr_length - n + k ] ); /* Q( -rshifts ) */
   1e1be:	fb01 f405 	mul.w	r4, r1, r5
   1e1c2:	9904      	ldr	r1, [sp, #16]
   1e1c4:	fb05 f101 	mul.w	r1, r5, r1
   1e1c8:	eb01 4124 	add.w	r1, r1, r4, asr #16
                    tmp1 = silk_SMLAWB( tmp1, Atmp_QA, x_ptr[ n - k - 1 ]            );                 /* Q(QA-16) */
   1e1cc:	1414      	asrs	r4, r2, #16
   1e1ce:	b292      	uxth	r2, r2
   1e1d0:	fb02 f003 	mul.w	r0, r2, r3
   1e1d4:	fb04 f303 	mul.w	r3, r4, r3
   1e1d8:	eb03 4320 	add.w	r3, r3, r0, asr #16
   1e1dc:	441f      	add	r7, r3
                for( k = 0; k < n; k++ ) {
   1e1de:	9b02      	ldr	r3, [sp, #8]
                    tmp2 = silk_SMLAWB( tmp2, Atmp_QA, x_ptr[ subfr_length - n + k ] );                 /* Q(QA-16) */
   1e1e0:	fb02 f205 	mul.w	r2, r2, r5
   1e1e4:	fb04 f505 	mul.w	r5, r4, r5
                    C_last_row[ k ]  = silk_SMLAWB( C_last_row[ k ],  x2, x_ptr[ subfr_length - n + k ] ); /* Q( -rshifts ) */
   1e1e8:	4459      	add	r1, fp
                    tmp2 = silk_SMLAWB( tmp2, Atmp_QA, x_ptr[ subfr_length - n + k ] );                 /* Q(QA-16) */
   1e1ea:	eb05 4222 	add.w	r2, r5, r2, asr #16
                for( k = 0; k < n; k++ ) {
   1e1ee:	4573      	cmp	r3, lr
                    C_last_row[ k ]  = silk_SMLAWB( C_last_row[ k ],  x2, x_ptr[ subfr_length - n + k ] ); /* Q( -rshifts ) */
   1e1f0:	f8cc 1000 	str.w	r1, [ip]
                    tmp2 = silk_SMLAWB( tmp2, Atmp_QA, x_ptr[ subfr_length - n + k ] );                 /* Q(QA-16) */
   1e1f4:	4416      	add	r6, r2
                for( k = 0; k < n; k++ ) {
   1e1f6:	d1cc      	bne.n	1e192 <silk_burg_modified_c+0x2ea>
   1e1f8:	469a      	mov	sl, r3
                }
                tmp1 = silk_LSHIFT32( -tmp1, 32 - QA - rshifts );                                       /* Q(16-rshifts) */
   1e1fa:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1e1fc:	f8dd c034 	ldr.w	ip, [sp, #52]	; 0x34
   1e200:	9c10      	ldr	r4, [sp, #64]	; 0x40
   1e202:	427f      	negs	r7, r7
                tmp2 = silk_LSHIFT32( -tmp2, 32 - QA - rshifts );                                       /* Q(16-rshifts) */
   1e204:	4276      	negs	r6, r6
                tmp1 = silk_LSHIFT32( -tmp1, 32 - QA - rshifts );                                       /* Q(16-rshifts) */
   1e206:	409f      	lsls	r7, r3
                tmp2 = silk_LSHIFT32( -tmp2, 32 - QA - rshifts );                                       /* Q(16-rshifts) */
   1e208:	409e      	lsls	r6, r3
   1e20a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1e20c:	eb03 050a 	add.w	r5, r3, sl
   1e210:	9b0e      	ldr	r3, [sp, #56]	; 0x38
                for( k = 0; k <= n; k++ ) {
                    CAf[ k ] = silk_SMLAWB( CAf[ k ], tmp1, x_ptr[ n - k ]                    );        /* Q( -rshift ) */
   1e212:	ea4f 4927 	mov.w	r9, r7, asr #16
                    CAb[ k ] = silk_SMLAWB( CAb[ k ], tmp2, x_ptr[ subfr_length - n + k - 1 ] );        /* Q( -rshift ) */
   1e216:	ea4f 4826 	mov.w	r8, r6, asr #16
   1e21a:	b2bf      	uxth	r7, r7
   1e21c:	b2b6      	uxth	r6, r6
   1e21e:	eb03 0e0a 	add.w	lr, r3, sl
                    CAf[ k ] = silk_SMLAWB( CAf[ k ], tmp1, x_ptr[ n - k ]                    );        /* Q( -rshift ) */
   1e222:	f935 2d02 	ldrsh.w	r2, [r5, #-2]!
   1e226:	f85c 1f04 	ldr.w	r1, [ip, #4]!
                    CAb[ k ] = silk_SMLAWB( CAb[ k ], tmp2, x_ptr[ subfr_length - n + k - 1 ] );        /* Q( -rshift ) */
   1e22a:	f93e 3f02 	ldrsh.w	r3, [lr, #2]!
                    CAf[ k ] = silk_SMLAWB( CAf[ k ], tmp1, x_ptr[ n - k ]                    );        /* Q( -rshift ) */
   1e22e:	fb07 f002 	mul.w	r0, r7, r2
   1e232:	fb02 f209 	mul.w	r2, r2, r9
   1e236:	eb02 4220 	add.w	r2, r2, r0, asr #16
   1e23a:	440a      	add	r2, r1
                    CAb[ k ] = silk_SMLAWB( CAb[ k ], tmp2, x_ptr[ subfr_length - n + k - 1 ] );        /* Q( -rshift ) */
   1e23c:	fb06 f103 	mul.w	r1, r6, r3
   1e240:	fb03 f308 	mul.w	r3, r3, r8
   1e244:	eb03 4321 	add.w	r3, r3, r1, asr #16
   1e248:	f854 1f04 	ldr.w	r1, [r4, #4]!
                    CAf[ k ] = silk_SMLAWB( CAf[ k ], tmp1, x_ptr[ n - k ]                    );        /* Q( -rshift ) */
   1e24c:	f8cc 2000 	str.w	r2, [ip]
                    CAb[ k ] = silk_SMLAWB( CAb[ k ], tmp2, x_ptr[ subfr_length - n + k - 1 ] );        /* Q( -rshift ) */
   1e250:	440b      	add	r3, r1
                for( k = 0; k <= n; k++ ) {
   1e252:	45aa      	cmp	sl, r5
                    CAb[ k ] = silk_SMLAWB( CAb[ k ], tmp2, x_ptr[ subfr_length - n + k - 1 ] );        /* Q( -rshift ) */
   1e254:	6023      	str	r3, [r4, #0]
                for( k = 0; k <= n; k++ ) {
   1e256:	d1e4      	bne.n	1e222 <silk_burg_modified_c+0x37a>
   1e258:	9a0c      	ldr	r2, [sp, #48]	; 0x30
            for( s = 0; s < nb_subfr; s++ ) {
   1e25a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1e25c:	9c99      	ldr	r4, [sp, #612]	; 0x264
   1e25e:	9d80      	ldr	r5, [sp, #512]	; 0x200
   1e260:	4492      	add	sl, r2
   1e262:	9abe      	ldr	r2, [sp, #760]	; 0x2f8
   1e264:	3301      	adds	r3, #1
   1e266:	429a      	cmp	r2, r3
   1e268:	930b      	str	r3, [sp, #44]	; 0x2c
   1e26a:	f47f af6b 	bne.w	1e144 <silk_burg_modified_c+0x29c>
                }
            }
        }

        /* Calculate nominator and denominator for the next order reflection (parcor) coefficient */
        tmp1 = C_first_row[ n ];                                                                        /* Q( -rshifts ) */
   1e26e:	9b08      	ldr	r3, [sp, #32]
        tmp2 = C_last_row[ n ];                                                                         /* Q( -rshifts ) */
   1e270:	9a09      	ldr	r2, [sp, #36]	; 0x24
        tmp1 = C_first_row[ n ];                                                                        /* Q( -rshifts ) */
   1e272:	4619      	mov	r1, r3
   1e274:	9b07      	ldr	r3, [sp, #28]
   1e276:	f851 8023 	ldr.w	r8, [r1, r3, lsl #2]
        tmp2 = C_last_row[ n ];                                                                         /* Q( -rshifts ) */
   1e27a:	4611      	mov	r1, r2
        num  = 0;                                                                                       /* Q( -rshifts ) */
        nrg  = silk_ADD32( CAb[ 0 ], CAf[ 0 ] );                                                        /* Q( 1-rshifts ) */
   1e27c:	eb04 0b05 	add.w	fp, r4, r5
        tmp2 = C_last_row[ n ];                                                                         /* Q( -rshifts ) */
   1e280:	f851 e023 	ldr.w	lr, [r1, r3, lsl #2]
        for( k = 0; k < n; k++ ) {
   1e284:	2b00      	cmp	r3, #0
   1e286:	f000 8299 	beq.w	1e7bc <silk_burg_modified_c+0x914>
   1e28a:	f103 4580 	add.w	r5, r3, #1073741824	; 0x40000000
   1e28e:	f50d 7a19 	add.w	sl, sp, #612	; 0x264
   1e292:	3d01      	subs	r5, #1
   1e294:	af80      	add	r7, sp, #512	; 0x200
        num  = 0;                                                                                       /* Q( -rshifts ) */
   1e296:	4658      	mov	r0, fp
   1e298:	00ad      	lsls	r5, r5, #2
   1e29a:	46d3      	mov	fp, sl
   1e29c:	f50d 79a0 	add.w	r9, sp, #320	; 0x140
   1e2a0:	f04f 0c00 	mov.w	ip, #0
   1e2a4:	f8cd 8008 	str.w	r8, [sp, #8]
   1e2a8:	46ba      	mov	sl, r7
   1e2aa:	e027      	b.n	1e2fc <silk_burg_modified_c+0x454>
   1e2ac:	f1c3 0107 	rsb	r1, r3, #7
            lz = silk_min( 32 - QA, lz );
            Atmp1 = silk_LSHIFT32( Atmp_QA, lz );                                                       /* Q( QA + lz ) */

            tmp1 = silk_ADD_LSHIFT32( tmp1, silk_SMMUL( C_last_row[  n - k - 1 ], Atmp1 ), 32 - QA - lz );  /* Q( -rshifts ) */
            tmp2 = silk_ADD_LSHIFT32( tmp2, silk_SMMUL( C_first_row[ n - k - 1 ], Atmp1 ), 32 - QA - lz );  /* Q( -rshifts ) */
            num  = silk_ADD_LSHIFT32( num,  silk_SMMUL( CAb[ n - k ],             Atmp1 ), 32 - QA - lz );  /* Q( -rshifts ) */
   1e2b0:	ac99      	add	r4, sp, #612	; 0x264
   1e2b2:	442c      	add	r4, r5
            Atmp1 = silk_LSHIFT32( Atmp_QA, lz );                                                       /* Q( QA + lz ) */
   1e2b4:	409a      	lsls	r2, r3
            num  = silk_ADD_LSHIFT32( num,  silk_SMMUL( CAb[ n - k ],             Atmp1 ), 32 - QA - lz );  /* Q( -rshifts ) */
   1e2b6:	6867      	ldr	r7, [r4, #4]
            tmp1 = silk_ADD_LSHIFT32( tmp1, silk_SMMUL( C_last_row[  n - k - 1 ], Atmp1 ), 32 - QA - lz );  /* Q( -rshifts ) */
   1e2b8:	9b09      	ldr	r3, [sp, #36]	; 0x24
            nrg  = silk_ADD_LSHIFT32( nrg,  silk_SMMUL( silk_ADD32( CAb[ k + 1 ], CAf[ k + 1 ] ),
   1e2ba:	f85b 4f04 	ldr.w	r4, [fp, #4]!
   1e2be:	f85a 6f04 	ldr.w	r6, [sl, #4]!
            num  = silk_ADD_LSHIFT32( num,  silk_SMMUL( CAb[ n - k ],             Atmp1 ), 32 - QA - lz );  /* Q( -rshifts ) */
   1e2c2:	fb82 7807 	smull	r7, r8, r2, r7
            nrg  = silk_ADD_LSHIFT32( nrg,  silk_SMMUL( silk_ADD32( CAb[ k + 1 ], CAf[ k + 1 ] ),
   1e2c6:	4426      	add	r6, r4
            num  = silk_ADD_LSHIFT32( num,  silk_SMMUL( CAb[ n - k ],             Atmp1 ), 32 - QA - lz );  /* Q( -rshifts ) */
   1e2c8:	4647      	mov	r7, r8
            tmp1 = silk_ADD_LSHIFT32( tmp1, silk_SMMUL( C_last_row[  n - k - 1 ], Atmp1 ), 32 - QA - lz );  /* Q( -rshifts ) */
   1e2ca:	595c      	ldr	r4, [r3, r5]
            tmp2 = silk_ADD_LSHIFT32( tmp2, silk_SMMUL( C_first_row[ n - k - 1 ], Atmp1 ), 32 - QA - lz );  /* Q( -rshifts ) */
   1e2cc:	9b08      	ldr	r3, [sp, #32]
            num  = silk_ADD_LSHIFT32( num,  silk_SMMUL( CAb[ n - k ],             Atmp1 ), 32 - QA - lz );  /* Q( -rshifts ) */
   1e2ce:	408f      	lsls	r7, r1
            tmp2 = silk_ADD_LSHIFT32( tmp2, silk_SMMUL( C_first_row[ n - k - 1 ], Atmp1 ), 32 - QA - lz );  /* Q( -rshifts ) */
   1e2d0:	595b      	ldr	r3, [r3, r5]
            num  = silk_ADD_LSHIFT32( num,  silk_SMMUL( CAb[ n - k ],             Atmp1 ), 32 - QA - lz );  /* Q( -rshifts ) */
   1e2d2:	44bc      	add	ip, r7
            nrg  = silk_ADD_LSHIFT32( nrg,  silk_SMMUL( silk_ADD32( CAb[ k + 1 ], CAf[ k + 1 ] ),
   1e2d4:	fb86 6702 	smull	r6, r7, r6, r2
   1e2d8:	fa07 f601 	lsl.w	r6, r7, r1
   1e2dc:	4430      	add	r0, r6
            tmp1 = silk_ADD_LSHIFT32( tmp1, silk_SMMUL( C_last_row[  n - k - 1 ], Atmp1 ), 32 - QA - lz );  /* Q( -rshifts ) */
   1e2de:	fb82 6704 	smull	r6, r7, r2, r4
            tmp2 = silk_ADD_LSHIFT32( tmp2, silk_SMMUL( C_first_row[ n - k - 1 ], Atmp1 ), 32 - QA - lz );  /* Q( -rshifts ) */
   1e2e2:	fb82 2303 	smull	r2, r3, r2, r3
            tmp1 = silk_ADD_LSHIFT32( tmp1, silk_SMMUL( C_last_row[  n - k - 1 ], Atmp1 ), 32 - QA - lz );  /* Q( -rshifts ) */
   1e2e6:	fa07 f401 	lsl.w	r4, r7, r1
            tmp2 = silk_ADD_LSHIFT32( tmp2, silk_SMMUL( C_first_row[ n - k - 1 ], Atmp1 ), 32 - QA - lz );  /* Q( -rshifts ) */
   1e2ea:	fa03 f101 	lsl.w	r1, r3, r1
            tmp1 = silk_ADD_LSHIFT32( tmp1, silk_SMMUL( C_last_row[  n - k - 1 ], Atmp1 ), 32 - QA - lz );  /* Q( -rshifts ) */
   1e2ee:	9b02      	ldr	r3, [sp, #8]
   1e2f0:	3d04      	subs	r5, #4
   1e2f2:	4423      	add	r3, r4
        for( k = 0; k < n; k++ ) {
   1e2f4:	1d2a      	adds	r2, r5, #4
            tmp1 = silk_ADD_LSHIFT32( tmp1, silk_SMMUL( C_last_row[  n - k - 1 ], Atmp1 ), 32 - QA - lz );  /* Q( -rshifts ) */
   1e2f6:	9302      	str	r3, [sp, #8]
            tmp2 = silk_ADD_LSHIFT32( tmp2, silk_SMMUL( C_first_row[ n - k - 1 ], Atmp1 ), 32 - QA - lz );  /* Q( -rshifts ) */
   1e2f8:	448e      	add	lr, r1
        for( k = 0; k < n; k++ ) {
   1e2fa:	d01f      	beq.n	1e33c <silk_burg_modified_c+0x494>
            Atmp_QA = Af_QA[ k ];
   1e2fc:	f859 2b04 	ldr.w	r2, [r9], #4
            lz = silk_CLZ32( silk_abs( Atmp_QA ) ) - 1;
   1e300:	ea82 73e2 	eor.w	r3, r2, r2, asr #31
   1e304:	eba3 73e2 	sub.w	r3, r3, r2, asr #31
   1e308:	fab3 f383 	clz	r3, r3
   1e30c:	3b01      	subs	r3, #1
   1e30e:	2b07      	cmp	r3, #7
   1e310:	bfa8      	it	ge
   1e312:	2307      	movge	r3, #7
   1e314:	2a00      	cmp	r2, #0
   1e316:	d1c9      	bne.n	1e2ac <silk_burg_modified_c+0x404>
   1e318:	2307      	movs	r3, #7
   1e31a:	4611      	mov	r1, r2
   1e31c:	e7c8      	b.n	1e2b0 <silk_burg_modified_c+0x408>
   1e31e:	fab0 f380 	clz	r3, r0
   1e322:	f1c3 0304 	rsb	r3, r3, #4
   1e326:	9317      	str	r3, [sp, #92]	; 0x5c
    if (rshifts < MIN_RSHIFTS) rshifts = MIN_RSHIFTS;
   1e328:	f113 0f10 	cmn.w	r3, #16
   1e32c:	f6ff add2 	blt.w	1ded4 <silk_burg_modified_c+0x2c>
   1e330:	425a      	negs	r2, r3
    if (rshifts > 0) {
   1e332:	2b00      	cmp	r3, #0
   1e334:	9216      	str	r2, [sp, #88]	; 0x58
   1e336:	f77f add2 	ble.w	1dede <silk_burg_modified_c+0x36>
   1e33a:	e66a      	b.n	1e012 <silk_burg_modified_c+0x16a>
   1e33c:	4698      	mov	r8, r3
   1e33e:	9b07      	ldr	r3, [sp, #28]
   1e340:	4683      	mov	fp, r0
                                                                                Atmp1 ), 32 - QA - lz );    /* Q( 1-rshifts ) */
        }
        CAf[ n + 1 ] = tmp1;                                                                            /* Q( -rshifts ) */
   1e342:	f103 0a01 	add.w	sl, r3, #1
        CAb[ n + 1 ] = tmp2;                                                                            /* Q( -rshifts ) */
        num = silk_ADD32( num, tmp2 );                                                                  /* Q( -rshifts ) */
   1e346:	eb0e 040c 	add.w	r4, lr, ip
        CAf[ n + 1 ] = tmp1;                                                                            /* Q( -rshifts ) */
   1e34a:	ab80      	add	r3, sp, #512	; 0x200
        num = silk_LSHIFT32( -num, 1 );                                                                 /* Q( 1-rshifts ) */
   1e34c:	4264      	negs	r4, r4
   1e34e:	0064      	lsls	r4, r4, #1
        CAf[ n + 1 ] = tmp1;                                                                            /* Q( -rshifts ) */
   1e350:	f843 802a 	str.w	r8, [r3, sl, lsl #2]
        CAb[ n + 1 ] = tmp2;                                                                            /* Q( -rshifts ) */
   1e354:	ab99      	add	r3, sp, #612	; 0x264

        /* Calculate the next order reflection (parcor) coefficient */
        if( silk_abs( num ) < nrg ) {
   1e356:	ea84 71e4 	eor.w	r1, r4, r4, asr #31
   1e35a:	eba1 71e4 	sub.w	r1, r1, r4, asr #31
        CAb[ n + 1 ] = tmp2;                                                                            /* Q( -rshifts ) */
   1e35e:	f843 e02a 	str.w	lr, [r3, sl, lsl #2]
   1e362:	9b14      	ldr	r3, [sp, #80]	; 0x50
   1e364:	f8cd a010 	str.w	sl, [sp, #16]
        if( silk_abs( num ) < nrg ) {
   1e368:	4559      	cmp	r1, fp
   1e36a:	ea4f 76e3 	mov.w	r6, r3, asr #31
   1e36e:	f280 81ce 	bge.w	1e70e <silk_burg_modified_c+0x866>
   1e372:	2c00      	cmp	r4, #0
   1e374:	f000 81df 	beq.w	1e736 <silk_burg_modified_c+0x88e>
   1e378:	fab1 f181 	clz	r1, r1
   1e37c:	1e4d      	subs	r5, r1, #1
   1e37e:	fa04 f505 	lsl.w	r5, r4, r5
   1e382:	f101 061c 	add.w	r6, r1, #28
   1e386:	142b      	asrs	r3, r5, #16
   1e388:	b2af      	uxth	r7, r5
   1e38a:	f1bb 0f00 	cmp.w	fp, #0
   1e38e:	f000 81d0 	beq.w	1e732 <silk_burg_modified_c+0x88a>
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
   1e392:	ea8b 70eb 	eor.w	r0, fp, fp, asr #31
   1e396:	eba0 70eb 	sub.w	r0, r0, fp, asr #31
   1e39a:	fab0 f080 	clz	r0, r0
   1e39e:	3801      	subs	r0, #1
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                  */
   1e3a0:	fa0b f200 	lsl.w	r2, fp, r0
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1e3a4:	ea4f 4c22 	mov.w	ip, r2, asr #16
   1e3a8:	f06f 4160 	mvn.w	r1, #3758096384	; 0xe0000000
   1e3ac:	fb91 f1fc 	sdiv	r1, r1, ip
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1e3b0:	b209      	sxth	r1, r1
   1e3b2:	fb03 f301 	mul.w	r3, r3, r1
   1e3b6:	fb07 f701 	mul.w	r7, r7, r1
   1e3ba:	eb03 4727 	add.w	r7, r3, r7, asr #16
    a32_nrm = silk_SUB32_ovflw(a32_nrm, silk_LSHIFT_ovflw( silk_SMMUL(b32_nrm, result), 3 ));  /* Q: a_headrm   */
   1e3be:	fb82 2307 	smull	r2, r3, r2, r7
   1e3c2:	eba5 05c3 	sub.w	r5, r5, r3, lsl #3
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1e3c6:	b2ab      	uxth	r3, r5
   1e3c8:	142d      	asrs	r5, r5, #16
   1e3ca:	fb01 f303 	mul.w	r3, r1, r3
   1e3ce:	fb01 f505 	mul.w	r5, r1, r5
    lshift = 29 + a_headrm - b_headrm - Qres;
   1e3d2:	1a30      	subs	r0, r6, r0
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1e3d4:	eb05 4323 	add.w	r3, r5, r3, asr #16
    if( lshift < 0 ) {
   1e3d8:	f1b0 021f 	subs.w	r2, r0, #31
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1e3dc:	443b      	add	r3, r7
    if( lshift < 0 ) {
   1e3de:	f100 81db 	bmi.w	1e798 <silk_burg_modified_c+0x8f0>
            return silk_RSHIFT(result, lshift);
   1e3e2:	4113      	asrs	r3, r2
   1e3e4:	fb83 0103 	smull	r0, r1, r3, r3
   1e3e8:	9a14      	ldr	r2, [sp, #80]	; 0x50
   1e3ea:	f1c1 4080 	rsb	r0, r1, #1073741824	; 0x40000000
   1e3ee:	fb80 0102 	smull	r0, r1, r0, r2
   1e3f2:	008a      	lsls	r2, r1, #2
   1e3f4:	4698      	mov	r8, r3
   1e3f6:	ea4f 79e3 	mov.w	r9, r3, asr #31
        }

        /* Update inverse prediction gain */
        tmp1 = ( (opus_int32)1 << 30 ) - silk_SMMUL( rc_Q31, rc_Q31 );
        tmp1 = silk_LSHIFT( silk_SMMUL( invGain_Q30, tmp1 ), 2 );
        if( tmp1 <= minInvGain_Q30 ) {
   1e3fa:	99bc      	ldr	r1, [sp, #752]	; 0x2f0
   1e3fc:	4291      	cmp	r1, r2
   1e3fe:	ea4f 0b6a 	mov.w	fp, sl, asr #1
   1e402:	f2c0 817b 	blt.w	1e6fc <silk_burg_modified_c+0x854>
   1e406:	460b      	mov	r3, r1
   1e408:	2900      	cmp	r1, #0
   1e40a:	f000 818f 	beq.w	1e72c <silk_burg_modified_c+0x884>
   1e40e:	e9dd 3019 	ldrd	r3, r0, [sp, #100]	; 0x64
   1e412:	f103 071c 	add.w	r7, r3, #28
   1e416:	460b      	mov	r3, r1
    a32_nrm = silk_LSHIFT(a32, a_headrm);                                       /* Q: a_headrm                  */
   1e418:	fa03 f000 	lsl.w	r0, r3, r0
   1e41c:	9b14      	ldr	r3, [sp, #80]	; 0x50
   1e41e:	2b00      	cmp	r3, #0
   1e420:	f000 8181 	beq.w	1e726 <silk_burg_modified_c+0x87e>
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
   1e424:	2b00      	cmp	r3, #0
   1e426:	bfb8      	it	lt
   1e428:	425b      	neglt	r3, r3
   1e42a:	fab3 f583 	clz	r5, r3
   1e42e:	9a14      	ldr	r2, [sp, #80]	; 0x50
   1e430:	3d01      	subs	r5, #1
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                  */
   1e432:	40aa      	lsls	r2, r5
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1e434:	1411      	asrs	r1, r2, #16
   1e436:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1e43a:	1406      	asrs	r6, r0, #16
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1e43c:	fb93 f1f1 	sdiv	r1, r3, r1
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1e440:	b283      	uxth	r3, r0
   1e442:	b209      	sxth	r1, r1
   1e444:	fb01 f303 	mul.w	r3, r1, r3
   1e448:	fb01 f606 	mul.w	r6, r1, r6
   1e44c:	eb06 4623 	add.w	r6, r6, r3, asr #16
    a32_nrm = silk_SUB32_ovflw(a32_nrm, silk_LSHIFT_ovflw( silk_SMMUL(b32_nrm, result), 3 ));  /* Q: a_headrm   */
   1e450:	fb82 2306 	smull	r2, r3, r2, r6
   1e454:	eba0 00c3 	sub.w	r0, r0, r3, lsl #3
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1e458:	b283      	uxth	r3, r0
   1e45a:	1400      	asrs	r0, r0, #16
   1e45c:	fb01 f303 	mul.w	r3, r1, r3
   1e460:	fb01 f000 	mul.w	r0, r1, r0
    lshift = 29 + a_headrm - b_headrm - Qres;
   1e464:	1b7d      	subs	r5, r7, r5
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1e466:	eb00 4023 	add.w	r0, r0, r3, asr #16
    if( lshift < 0 ) {
   1e46a:	f1b5 031e 	subs.w	r3, r5, #30
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1e46e:	4406      	add	r6, r0
    if( lshift < 0 ) {
   1e470:	f100 816e 	bmi.w	1e750 <silk_burg_modified_c+0x8a8>
            return silk_RSHIFT(result, lshift);
   1e474:	fa46 f303 	asr.w	r3, r6, r3
            /* Max prediction gain exceeded; set reflection coefficient such that max prediction gain is exactly hit */
            tmp2 = ( (opus_int32)1 << 30 ) - silk_DIV32_varQ( minInvGain_Q30, invGain_Q30, 30 );            /* Q30 */
   1e478:	f1c3 4380 	rsb	r3, r3, #1073741824	; 0x40000000
    if( x <= 0 ) {
   1e47c:	2b00      	cmp	r3, #0
   1e47e:	f340 817c 	ble.w	1e77a <silk_burg_modified_c+0x8d2>
   1e482:	fab3 f083 	clz	r0, r3
    * frac_Q7 = silk_ROR32(in, 24 - lzeros) & 0x7f;
   1e486:	f1c0 0218 	rsb	r2, r0, #24
    if( rot == 0 ) {
   1e48a:	2a00      	cmp	r2, #0
   1e48c:	f000 8194 	beq.w	1e7b8 <silk_burg_modified_c+0x910>
        return (opus_int32) ((x << m) | (x >> (32 - m)));
   1e490:	bfb8      	it	lt
   1e492:	3220      	addlt	r2, #32
        return (opus_int32) ((x << (32 - r)) | (x >> r));
   1e494:	fa63 f202 	ror.w	r2, r3, r2
   1e498:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   1e49c:	eb02 05c2 	add.w	r5, r2, r2, lsl #3
        y = 32768;
   1e4a0:	f010 0f01 	tst.w	r0, #1
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   1e4a4:	ebc2 02c5 	rsb	r2, r2, r5, lsl #3
        y = 32768;
   1e4a8:	f24b 4186 	movw	r1, #46214	; 0xb486
    y >>= silk_RSHIFT(lz, 1);
   1e4ac:	ea4f 0060 	mov.w	r0, r0, asr #1
        y = 32768;
   1e4b0:	bf18      	it	ne
   1e4b2:	f44f 4100 	movne.w	r1, #32768	; 0x8000
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   1e4b6:	ebc2 0282 	rsb	r2, r2, r2, lsl #2
    y >>= silk_RSHIFT(lz, 1);
   1e4ba:	4101      	asrs	r1, r0
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
   1e4bc:	b292      	uxth	r2, r2
   1e4be:	fb01 f202 	mul.w	r2, r1, r2
   1e4c2:	eb01 4122 	add.w	r1, r1, r2, asr #16
            rc_Q31 = silk_SQRT_APPROX( tmp2 );                                                  /* Q15 */
            if( rc_Q31 > 0 ) {
                /* Newton-Raphson iteration */
                rc_Q31 = silk_RSHIFT32( rc_Q31 + silk_DIV32( tmp2, rc_Q31 ), 1 );                       /* Q15 */
   1e4c6:	fb93 f3f1 	sdiv	r3, r3, r1
   1e4ca:	440b      	add	r3, r1
   1e4cc:	ea4f 0863 	mov.w	r8, r3, asr #1
                rc_Q31 = silk_LSHIFT32( rc_Q31, 16 );                                                   /* Q31 */
   1e4d0:	ea4f 4808 	mov.w	r8, r8, lsl #16
                if( num < 0 ) {
   1e4d4:	2c00      	cmp	r4, #0
                    /* Ensure adjusted reflection coefficients has the original sign */
                    rc_Q31 = -rc_Q31;
   1e4d6:	bfb8      	it	lt
   1e4d8:	f1c8 0800 	rsblt	r8, r8, #0
   1e4dc:	ea4f 13a8 	mov.w	r3, r8, asr #6
   1e4e0:	9302      	str	r3, [sp, #8]
        } else {
            invGain_Q30 = tmp1;
        }

        /* Update the AR coefficients */
        for( k = 0; k < (n + 1) >> 1; k++ ) {
   1e4e2:	f1bb 0f00 	cmp.w	fp, #0
   1e4e6:	f000 81cd 	beq.w	1e884 <silk_burg_modified_c+0x9dc>
   1e4ea:	9bbc      	ldr	r3, [sp, #752]	; 0x2f0
   1e4ec:	9314      	str	r3, [sp, #80]	; 0x50
            reached_max_gain = 1;
   1e4ee:	2301      	movs	r3, #1
   1e4f0:	ea4f 79e8 	mov.w	r9, r8, asr #31
   1e4f4:	9303      	str	r3, [sp, #12]
   1e4f6:	ea4f 0e8a 	mov.w	lr, sl, lsl #2
   1e4fa:	ab4e      	add	r3, sp, #312	; 0x138
   1e4fc:	eb03 010e 	add.w	r1, r3, lr
   1e500:	ac4f      	add	r4, sp, #316	; 0x13c
   1e502:	2000      	movs	r0, #0
            tmp1 = Af_QA[ k ];                                                                  /* QA */
            tmp2 = Af_QA[ n - k - 1 ];                                                          /* QA */
   1e504:	680b      	ldr	r3, [r1, #0]
            tmp1 = Af_QA[ k ];                                                                  /* QA */
   1e506:	f854 2f04 	ldr.w	r2, [r4, #4]!
            Af_QA[ k ]         = silk_ADD_LSHIFT32( tmp1, silk_SMMUL( tmp2, rc_Q31 ), 1 );      /* QA */
   1e50a:	17df      	asrs	r7, r3, #31
   1e50c:	fb03 fc09 	mul.w	ip, r3, r9
   1e510:	fb08 cc07 	mla	ip, r8, r7, ip
   1e514:	fba3 6708 	umull	r6, r7, r3, r8
            Af_QA[ n - k - 1 ] = silk_ADD_LSHIFT32( tmp2, silk_SMMUL( tmp1, rc_Q31 ), 1 );      /* QA */
   1e518:	fb02 f509 	mul.w	r5, r2, r9
            Af_QA[ k ]         = silk_ADD_LSHIFT32( tmp1, silk_SMMUL( tmp2, rc_Q31 ), 1 );      /* QA */
   1e51c:	44bc      	add	ip, r7
            Af_QA[ n - k - 1 ] = silk_ADD_LSHIFT32( tmp2, silk_SMMUL( tmp1, rc_Q31 ), 1 );      /* QA */
   1e51e:	17d7      	asrs	r7, r2, #31
   1e520:	fb08 5507 	mla	r5, r8, r7, r5
   1e524:	fba2 6708 	umull	r6, r7, r2, r8
   1e528:	443d      	add	r5, r7
        for( k = 0; k < (n + 1) >> 1; k++ ) {
   1e52a:	3001      	adds	r0, #1
            Af_QA[ k ]         = silk_ADD_LSHIFT32( tmp1, silk_SMMUL( tmp2, rc_Q31 ), 1 );      /* QA */
   1e52c:	eb02 024c 	add.w	r2, r2, ip, lsl #1
            Af_QA[ n - k - 1 ] = silk_ADD_LSHIFT32( tmp2, silk_SMMUL( tmp1, rc_Q31 ), 1 );      /* QA */
   1e530:	eb03 0345 	add.w	r3, r3, r5, lsl #1
        for( k = 0; k < (n + 1) >> 1; k++ ) {
   1e534:	4558      	cmp	r0, fp
            Af_QA[ k ]         = silk_ADD_LSHIFT32( tmp1, silk_SMMUL( tmp2, rc_Q31 ), 1 );      /* QA */
   1e536:	6022      	str	r2, [r4, #0]
            Af_QA[ n - k - 1 ] = silk_ADD_LSHIFT32( tmp2, silk_SMMUL( tmp1, rc_Q31 ), 1 );      /* QA */
   1e538:	f841 3904 	str.w	r3, [r1], #-4
        for( k = 0; k < (n + 1) >> 1; k++ ) {
   1e53c:	dbe2      	blt.n	1e504 <silk_burg_modified_c+0x65c>
        }
        Af_QA[ n ] = silk_RSHIFT32( rc_Q31, 31 - QA );                                          /* QA */
   1e53e:	ab50      	add	r3, sp, #320	; 0x140
   1e540:	4473      	add	r3, lr
   1e542:	9a02      	ldr	r2, [sp, #8]
   1e544:	f843 2c04 	str.w	r2, [r3, #-4]

        if( reached_max_gain ) {
   1e548:	9b03      	ldr	r3, [sp, #12]
   1e54a:	2b00      	cmp	r3, #0
   1e54c:	f040 8231 	bne.w	1e9b2 <silk_burg_modified_c+0xb0a>
   1e550:	ab9a      	add	r3, sp, #616	; 0x268
   1e552:	eb03 010e 	add.w	r1, r3, lr
   1e556:	a87f      	add	r0, sp, #508	; 0x1fc
        }

        /* Update C * Af and C * Ab */
        for( k = 0; k <= n + 1; k++ ) {
            tmp1 = CAf[ k ];                                                                    /* Q( -rshifts ) */
            tmp2 = CAb[ n - k + 1 ];                                                            /* Q( -rshifts ) */
   1e558:	f851 3d04 	ldr.w	r3, [r1, #-4]!
            tmp1 = CAf[ k ];                                                                    /* Q( -rshifts ) */
   1e55c:	f850 2f04 	ldr.w	r2, [r0, #4]!
            CAf[ k ]         = silk_ADD_LSHIFT32( tmp1, silk_SMMUL( tmp2, rc_Q31 ), 1 );        /* Q( -rshifts ) */
   1e560:	17dd      	asrs	r5, r3, #31
   1e562:	fb03 f709 	mul.w	r7, r3, r9
   1e566:	fb08 7705 	mla	r7, r8, r5, r7
   1e56a:	fba3 4508 	umull	r4, r5, r3, r8
            CAb[ n - k + 1 ] = silk_ADD_LSHIFT32( tmp2, silk_SMMUL( tmp1, rc_Q31 ), 1 );        /* Q( -rshifts ) */
   1e56e:	fb02 f609 	mul.w	r6, r2, r9
            CAf[ k ]         = silk_ADD_LSHIFT32( tmp1, silk_SMMUL( tmp2, rc_Q31 ), 1 );        /* Q( -rshifts ) */
   1e572:	442f      	add	r7, r5
            CAb[ n - k + 1 ] = silk_ADD_LSHIFT32( tmp2, silk_SMMUL( tmp1, rc_Q31 ), 1 );        /* Q( -rshifts ) */
   1e574:	17d5      	asrs	r5, r2, #31
   1e576:	fb08 6605 	mla	r6, r8, r5, r6
   1e57a:	fba2 4508 	umull	r4, r5, r2, r8
   1e57e:	1974      	adds	r4, r6, r5
   1e580:	eb03 0344 	add.w	r3, r3, r4, lsl #1
   1e584:	600b      	str	r3, [r1, #0]
        for( k = 0; k <= n + 1; k++ ) {
   1e586:	ab99      	add	r3, sp, #612	; 0x264
            CAf[ k ]         = silk_ADD_LSHIFT32( tmp1, silk_SMMUL( tmp2, rc_Q31 ), 1 );        /* Q( -rshifts ) */
   1e588:	eb02 0247 	add.w	r2, r2, r7, lsl #1
        for( k = 0; k <= n + 1; k++ ) {
   1e58c:	4299      	cmp	r1, r3
            CAf[ k ]         = silk_ADD_LSHIFT32( tmp1, silk_SMMUL( tmp2, rc_Q31 ), 1 );        /* Q( -rshifts ) */
   1e58e:	6002      	str	r2, [r0, #0]
        for( k = 0; k <= n + 1; k++ ) {
   1e590:	d1e2      	bne.n	1e558 <silk_burg_modified_c+0x6b0>
   1e592:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1e594:	9d80      	ldr	r5, [sp, #512]	; 0x200
   1e596:	3302      	adds	r3, #2
   1e598:	930a      	str	r3, [sp, #40]	; 0x28
   1e59a:	9b15      	ldr	r3, [sp, #84]	; 0x54
   1e59c:	3b02      	subs	r3, #2
   1e59e:	9315      	str	r3, [sp, #84]	; 0x54
    for( n = 0; n < D; n++ ) {
   1e5a0:	9bbf      	ldr	r3, [sp, #764]	; 0x2fc
   1e5a2:	459a      	cmp	sl, r3
   1e5a4:	f000 811f 	beq.w	1e7e6 <silk_burg_modified_c+0x93e>
        if( rshifts > -2 ) {
   1e5a8:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   1e5aa:	f8cd a01c 	str.w	sl, [sp, #28]
   1e5ae:	3301      	adds	r3, #1
   1e5b0:	9c99      	ldr	r4, [sp, #612]	; 0x264
            for( s = 0; s < nb_subfr; s++ ) {
   1e5b2:	9bbe      	ldr	r3, [sp, #760]	; 0x2f8
        if( rshifts > -2 ) {
   1e5b4:	f6bf adaf 	bge.w	1e116 <silk_burg_modified_c+0x26e>
            for( s = 0; s < nb_subfr; s++ ) {
   1e5b8:	2b00      	cmp	r3, #0
   1e5ba:	f77f ae58 	ble.w	1e26e <silk_burg_modified_c+0x3c6>
   1e5be:	9b15      	ldr	r3, [sp, #84]	; 0x54
   1e5c0:	f8dd b060 	ldr.w	fp, [sp, #96]	; 0x60
   1e5c4:	1e9a      	subs	r2, r3, #2
   1e5c6:	920b      	str	r2, [sp, #44]	; 0x2c
   1e5c8:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   1e5ca:	43d2      	mvns	r2, r2
   1e5cc:	9211      	str	r2, [sp, #68]	; 0x44
   1e5ce:	2200      	movs	r2, #0
   1e5d0:	9206      	str	r2, [sp, #24]
   1e5d2:	aa7f      	add	r2, sp, #508	; 0x1fc
   1e5d4:	920d      	str	r2, [sp, #52]	; 0x34
   1e5d6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   1e5d8:	3202      	adds	r2, #2
   1e5da:	920f      	str	r2, [sp, #60]	; 0x3c
   1e5dc:	3b04      	subs	r3, #4
   1e5de:	aa98      	add	r2, sp, #608	; 0x260
   1e5e0:	9210      	str	r2, [sp, #64]	; 0x40
   1e5e2:	930e      	str	r3, [sp, #56]	; 0x38
                x1  = -silk_LSHIFT32( (opus_int32)x_ptr[ n ],                    -rshifts );            /* Q( -rshifts ) */
   1e5e4:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   1e5e6:	9a16      	ldr	r2, [sp, #88]	; 0x58
   1e5e8:	f93b 0004 	ldrsh.w	r0, [fp, r4]
                x2  = -silk_LSHIFT32( (opus_int32)x_ptr[ subfr_length - n - 1 ], -rshifts );            /* Q( -rshifts ) */
   1e5ec:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
                x1  = -silk_LSHIFT32( (opus_int32)x_ptr[ n ],                    -rshifts );            /* Q( -rshifts ) */
   1e5ee:	fa00 f302 	lsl.w	r3, r0, r2
                x2  = -silk_LSHIFT32( (opus_int32)x_ptr[ subfr_length - n - 1 ], -rshifts );            /* Q( -rshifts ) */
   1e5f2:	f93b 1005 	ldrsh.w	r1, [fp, r5]
                x1  = -silk_LSHIFT32( (opus_int32)x_ptr[ n ],                    -rshifts );            /* Q( -rshifts ) */
   1e5f6:	425b      	negs	r3, r3
   1e5f8:	9303      	str	r3, [sp, #12]
                for( k = 0; k < n; k++ ) {
   1e5fa:	9b07      	ldr	r3, [sp, #28]
                x2  = -silk_LSHIFT32( (opus_int32)x_ptr[ subfr_length - n - 1 ], -rshifts );            /* Q( -rshifts ) */
   1e5fc:	fa01 fa02 	lsl.w	sl, r1, r2
                tmp1 = silk_LSHIFT32( (opus_int32)x_ptr[ n ],                    17 );                  /* Q17 */
   1e600:	0440      	lsls	r0, r0, #17
                x2  = -silk_LSHIFT32( (opus_int32)x_ptr[ subfr_length - n - 1 ], -rshifts );            /* Q( -rshifts ) */
   1e602:	f1ca 0a00 	rsb	sl, sl, #0
                tmp2 = silk_LSHIFT32( (opus_int32)x_ptr[ subfr_length - n - 1 ], 17 );                  /* Q17 */
   1e606:	0449      	lsls	r1, r1, #17
                for( k = 0; k < n; k++ ) {
   1e608:	b34b      	cbz	r3, 1e65e <silk_burg_modified_c+0x7b6>
   1e60a:	9f08      	ldr	r7, [sp, #32]
   1e60c:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
   1e610:	9102      	str	r1, [sp, #8]
   1e612:	eb04 060b 	add.w	r6, r4, fp
   1e616:	eb05 080b 	add.w	r8, r5, fp
   1e61a:	2200      	movs	r2, #0
                    Atmp1 = silk_RSHIFT_ROUND( Af_QA[ k ], QA - 17 );                                   /* Q17 */
   1e61c:	ab50      	add	r3, sp, #320	; 0x140
                    C_first_row[ k ] = silk_MLA( C_first_row[ k ], x1, x_ptr[ n - k - 1 ]            ); /* Q( -rshifts ) */
   1e61e:	f936 ed02 	ldrsh.w	lr, [r6, #-2]!
                    Atmp1 = silk_RSHIFT_ROUND( Af_QA[ k ], QA - 17 );                                   /* Q17 */
   1e622:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
                    C_first_row[ k ] = silk_MLA( C_first_row[ k ], x1, x_ptr[ n - k - 1 ]            ); /* Q( -rshifts ) */
   1e626:	6839      	ldr	r1, [r7, #0]
   1e628:	9c03      	ldr	r4, [sp, #12]
                    C_last_row[ k ]  = silk_MLA( C_last_row[ k ],  x2, x_ptr[ subfr_length - n + k ] ); /* Q( -rshifts ) */
   1e62a:	f859 5022 	ldr.w	r5, [r9, r2, lsl #2]
   1e62e:	f938 cf02 	ldrsh.w	ip, [r8, #2]!
                    Atmp1 = silk_RSHIFT_ROUND( Af_QA[ k ], QA - 17 );                                   /* Q17 */
   1e632:	11db      	asrs	r3, r3, #7
                    C_first_row[ k ] = silk_MLA( C_first_row[ k ], x1, x_ptr[ n - k - 1 ]            ); /* Q( -rshifts ) */
   1e634:	fb04 140e 	mla	r4, r4, lr, r1
                    Atmp1 = silk_RSHIFT_ROUND( Af_QA[ k ], QA - 17 );                                   /* Q17 */
   1e638:	3301      	adds	r3, #1
                    tmp2 = silk_MLA_ovflw( tmp2, x_ptr[ subfr_length - n + k ], Atmp1 );                      /* Q17 */
   1e63a:	9902      	ldr	r1, [sp, #8]
                    C_first_row[ k ] = silk_MLA( C_first_row[ k ], x1, x_ptr[ n - k - 1 ]            ); /* Q( -rshifts ) */
   1e63c:	f847 4b04 	str.w	r4, [r7], #4
                    Atmp1 = silk_RSHIFT_ROUND( Af_QA[ k ], QA - 17 );                                   /* Q17 */
   1e640:	105b      	asrs	r3, r3, #1
                    C_last_row[ k ]  = silk_MLA( C_last_row[ k ],  x2, x_ptr[ subfr_length - n + k ] ); /* Q( -rshifts ) */
   1e642:	fb0a 550c 	mla	r5, sl, ip, r5
                    tmp1 = silk_MLA_ovflw( tmp1, x_ptr[ n - k - 1 ],            Atmp1 );                      /* Q17 */
   1e646:	fb03 000e 	mla	r0, r3, lr, r0
                for( k = 0; k < n; k++ ) {
   1e64a:	45b3      	cmp	fp, r6
                    tmp2 = silk_MLA_ovflw( tmp2, x_ptr[ subfr_length - n + k ], Atmp1 );                      /* Q17 */
   1e64c:	fb03 130c 	mla	r3, r3, ip, r1
                    C_last_row[ k ]  = silk_MLA( C_last_row[ k ],  x2, x_ptr[ subfr_length - n + k ] ); /* Q( -rshifts ) */
   1e650:	f849 5022 	str.w	r5, [r9, r2, lsl #2]
                    tmp2 = silk_MLA_ovflw( tmp2, x_ptr[ subfr_length - n + k ], Atmp1 );                      /* Q17 */
   1e654:	9302      	str	r3, [sp, #8]
                for( k = 0; k < n; k++ ) {
   1e656:	f102 0201 	add.w	r2, r2, #1
   1e65a:	d1df      	bne.n	1e61c <silk_burg_modified_c+0x774>
   1e65c:	4619      	mov	r1, r3
                tmp1 = -tmp1;                                                                           /* Q17 */
   1e65e:	4240      	negs	r0, r0
                tmp2 = -tmp2;                                                                           /* Q17 */
   1e660:	4249      	negs	r1, r1
                    CAf[ k ] = silk_SMLAWW( CAf[ k ], tmp1,
   1e662:	1403      	asrs	r3, r0, #16
   1e664:	9303      	str	r3, [sp, #12]
                    CAb[ k ] = silk_SMLAWW( CAb[ k ], tmp2,
   1e666:	140b      	asrs	r3, r1, #16
   1e668:	9304      	str	r3, [sp, #16]
   1e66a:	b28b      	uxth	r3, r1
   1e66c:	9305      	str	r3, [sp, #20]
   1e66e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1e670:	f8dd e034 	ldr.w	lr, [sp, #52]	; 0x34
   1e674:	9f10      	ldr	r7, [sp, #64]	; 0x40
   1e676:	9d11      	ldr	r5, [sp, #68]	; 0x44
   1e678:	eb03 0c0b 	add.w	ip, r3, fp
   1e67c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1e67e:	fa1f fa80 	uxth.w	sl, r0
   1e682:	eb03 080b 	add.w	r8, r3, fp
                    CAf[ k ] = silk_SMLAWW( CAf[ k ], tmp1,
   1e686:	f93c 2d02 	ldrsh.w	r2, [ip, #-2]!
   1e68a:	9e03      	ldr	r6, [sp, #12]
                    CAb[ k ] = silk_SMLAWW( CAb[ k ], tmp2,
   1e68c:	f938 3f02 	ldrsh.w	r3, [r8, #2]!
                    CAf[ k ] = silk_SMLAWW( CAf[ k ], tmp1,
   1e690:	40aa      	lsls	r2, r5
   1e692:	fa0f f982 	sxth.w	r9, r2
   1e696:	fb0a f409 	mul.w	r4, sl, r9
   1e69a:	fb09 f906 	mul.w	r9, r9, r6
   1e69e:	eb09 4924 	add.w	r9, r9, r4, asr #16
   1e6a2:	13d2      	asrs	r2, r2, #15
   1e6a4:	f85e 4f04 	ldr.w	r4, [lr, #4]!
                    CAb[ k ] = silk_SMLAWW( CAb[ k ], tmp2,
   1e6a8:	f857 6f04 	ldr.w	r6, [r7, #4]!
                    CAf[ k ] = silk_SMLAWW( CAf[ k ], tmp1,
   1e6ac:	3201      	adds	r2, #1
   1e6ae:	44a1      	add	r9, r4
   1e6b0:	1052      	asrs	r2, r2, #1
   1e6b2:	fb00 9202 	mla	r2, r0, r2, r9
                    CAb[ k ] = silk_SMLAWW( CAb[ k ], tmp2,
   1e6b6:	40ab      	lsls	r3, r5
                    CAf[ k ] = silk_SMLAWW( CAf[ k ], tmp1,
   1e6b8:	9202      	str	r2, [sp, #8]
                    CAb[ k ] = silk_SMLAWW( CAb[ k ], tmp2,
   1e6ba:	9a05      	ldr	r2, [sp, #20]
   1e6bc:	b21c      	sxth	r4, r3
   1e6be:	fb02 f904 	mul.w	r9, r2, r4
   1e6c2:	9a04      	ldr	r2, [sp, #16]
   1e6c4:	13db      	asrs	r3, r3, #15
   1e6c6:	fb04 f402 	mul.w	r4, r4, r2
   1e6ca:	3301      	adds	r3, #1
   1e6cc:	eb04 4429 	add.w	r4, r4, r9, asr #16
   1e6d0:	105b      	asrs	r3, r3, #1
   1e6d2:	4434      	add	r4, r6
   1e6d4:	fb01 4403 	mla	r4, r1, r3, r4
                for( k = 0; k <= n; k++ ) {
   1e6d8:	45e3      	cmp	fp, ip
                    CAf[ k ] = silk_SMLAWW( CAf[ k ], tmp1,
   1e6da:	9b02      	ldr	r3, [sp, #8]
   1e6dc:	f8ce 3000 	str.w	r3, [lr]
                    CAb[ k ] = silk_SMLAWW( CAb[ k ], tmp2,
   1e6e0:	603c      	str	r4, [r7, #0]
                for( k = 0; k <= n; k++ ) {
   1e6e2:	d1d0      	bne.n	1e686 <silk_burg_modified_c+0x7de>
   1e6e4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
            for( s = 0; s < nb_subfr; s++ ) {
   1e6e6:	9b06      	ldr	r3, [sp, #24]
   1e6e8:	9c99      	ldr	r4, [sp, #612]	; 0x264
   1e6ea:	9d80      	ldr	r5, [sp, #512]	; 0x200
   1e6ec:	4493      	add	fp, r2
   1e6ee:	9abe      	ldr	r2, [sp, #760]	; 0x2f8
   1e6f0:	3301      	adds	r3, #1
   1e6f2:	429a      	cmp	r2, r3
   1e6f4:	9306      	str	r3, [sp, #24]
   1e6f6:	f47f af75 	bne.w	1e5e4 <silk_burg_modified_c+0x73c>
   1e6fa:	e5b8      	b.n	1e26e <silk_burg_modified_c+0x3c6>
   1e6fc:	119b      	asrs	r3, r3, #6
   1e6fe:	9302      	str	r3, [sp, #8]
        for( k = 0; k < (n + 1) >> 1; k++ ) {
   1e700:	f1bb 0f00 	cmp.w	fp, #0
   1e704:	d066      	beq.n	1e7d4 <silk_burg_modified_c+0x92c>
   1e706:	2300      	movs	r3, #0
   1e708:	9214      	str	r2, [sp, #80]	; 0x50
   1e70a:	9303      	str	r3, [sp, #12]
   1e70c:	e6f3      	b.n	1e4f6 <silk_burg_modified_c+0x64e>
            rc_Q31 = ( num > 0 ) ? silk_int32_MAX : silk_int32_MIN;
   1e70e:	2c00      	cmp	r4, #0
   1e710:	dd16      	ble.n	1e740 <silk_burg_modified_c+0x898>
   1e712:	00b2      	lsls	r2, r6, #2
   1e714:	f06f 4800 	mvn.w	r8, #2147483648	; 0x80000000
   1e718:	f04f 0900 	mov.w	r9, #0
   1e71c:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
   1e720:	e66b      	b.n	1e3fa <silk_burg_modified_c+0x552>
               for ( i = n + subfr_length - D, d = 0; i < subfr_length; i++ )
   1e722:	2200      	movs	r2, #0
   1e724:	e433      	b.n	1df8e <silk_burg_modified_c+0xe6>
   1e726:	251f      	movs	r5, #31
   1e728:	461a      	mov	r2, r3
   1e72a:	e682      	b.n	1e432 <silk_burg_modified_c+0x58a>
   1e72c:	273c      	movs	r7, #60	; 0x3c
   1e72e:	201f      	movs	r0, #31
   1e730:	e672      	b.n	1e418 <silk_burg_modified_c+0x570>
   1e732:	201f      	movs	r0, #31
   1e734:	e634      	b.n	1e3a0 <silk_burg_modified_c+0x4f8>
   1e736:	263c      	movs	r6, #60	; 0x3c
   1e738:	4627      	mov	r7, r4
   1e73a:	4623      	mov	r3, r4
   1e73c:	4625      	mov	r5, r4
   1e73e:	e624      	b.n	1e38a <silk_burg_modified_c+0x4e2>
   1e740:	2200      	movs	r2, #0
   1e742:	f04f 4800 	mov.w	r8, #2147483648	; 0x80000000
   1e746:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
            rc_Q31 = ( num > 0 ) ? silk_int32_MAX : silk_int32_MIN;
   1e74a:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   1e74e:	e654      	b.n	1e3fa <silk_burg_modified_c+0x552>
        return silk_LSHIFT_SAT32(result, -lshift);
   1e750:	f1c5 051e 	rsb	r5, r5, #30
   1e754:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   1e758:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
   1e75c:	412b      	asrs	r3, r5
   1e75e:	412a      	asrs	r2, r5
   1e760:	4293      	cmp	r3, r2
   1e762:	dd32      	ble.n	1e7ca <silk_burg_modified_c+0x922>
   1e764:	429e      	cmp	r6, r3
   1e766:	f340 80f4 	ble.w	1e952 <silk_burg_modified_c+0xaaa>
   1e76a:	461e      	mov	r6, r3
   1e76c:	fa06 f305 	lsl.w	r3, r6, r5
            tmp2 = ( (opus_int32)1 << 30 ) - silk_DIV32_varQ( minInvGain_Q30, invGain_Q30, 30 );            /* Q30 */
   1e770:	f1c3 4380 	rsb	r3, r3, #1073741824	; 0x40000000
    if( x <= 0 ) {
   1e774:	2b00      	cmp	r3, #0
   1e776:	f73f ae84 	bgt.w	1e482 <silk_burg_modified_c+0x5da>
        for( k = 0; k < (n + 1) >> 1; k++ ) {
   1e77a:	f1bb 0f00 	cmp.w	fp, #0
   1e77e:	f000 810c 	beq.w	1e99a <silk_burg_modified_c+0xaf2>
   1e782:	9bbc      	ldr	r3, [sp, #752]	; 0x2f0
   1e784:	9314      	str	r3, [sp, #80]	; 0x50
   1e786:	2300      	movs	r3, #0
   1e788:	9302      	str	r3, [sp, #8]
            reached_max_gain = 1;
   1e78a:	2301      	movs	r3, #1
        for( k = 0; k < (n + 1) >> 1; k++ ) {
   1e78c:	f04f 0800 	mov.w	r8, #0
   1e790:	f04f 0900 	mov.w	r9, #0
            reached_max_gain = 1;
   1e794:	9303      	str	r3, [sp, #12]
   1e796:	e6ae      	b.n	1e4f6 <silk_burg_modified_c+0x64e>
        return silk_LSHIFT_SAT32(result, -lshift);
   1e798:	f1c0 001f 	rsb	r0, r0, #31
   1e79c:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   1e7a0:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
   1e7a4:	4102      	asrs	r2, r0
   1e7a6:	4101      	asrs	r1, r0
   1e7a8:	428a      	cmp	r2, r1
   1e7aa:	dd09      	ble.n	1e7c0 <silk_burg_modified_c+0x918>
   1e7ac:	4293      	cmp	r3, r2
   1e7ae:	f340 80c8 	ble.w	1e942 <silk_burg_modified_c+0xa9a>
   1e7b2:	4613      	mov	r3, r2
   1e7b4:	4083      	lsls	r3, r0
   1e7b6:	e615      	b.n	1e3e4 <silk_burg_modified_c+0x53c>
    if( rot == 0 ) {
   1e7b8:	461a      	mov	r2, r3
   1e7ba:	e66d      	b.n	1e498 <silk_burg_modified_c+0x5f0>
   1e7bc:	469c      	mov	ip, r3
   1e7be:	e5c0      	b.n	1e342 <silk_burg_modified_c+0x49a>
   1e7c0:	428b      	cmp	r3, r1
   1e7c2:	f340 80ca 	ble.w	1e95a <silk_burg_modified_c+0xab2>
   1e7c6:	460b      	mov	r3, r1
   1e7c8:	e7f4      	b.n	1e7b4 <silk_burg_modified_c+0x90c>
   1e7ca:	4296      	cmp	r6, r2
   1e7cc:	f340 80bd 	ble.w	1e94a <silk_burg_modified_c+0xaa2>
   1e7d0:	4616      	mov	r6, r2
   1e7d2:	e7cb      	b.n	1e76c <silk_burg_modified_c+0x8c4>
        Af_QA[ n ] = silk_RSHIFT32( rc_Q31, 31 - QA );                                          /* QA */
   1e7d4:	ea4f 0e8a 	mov.w	lr, sl, lsl #2
   1e7d8:	ab50      	add	r3, sp, #320	; 0x140
   1e7da:	4473      	add	r3, lr
   1e7dc:	9214      	str	r2, [sp, #80]	; 0x50
   1e7de:	9a02      	ldr	r2, [sp, #8]
   1e7e0:	f843 2c04 	str.w	r2, [r3, #-4]
   1e7e4:	e6b4      	b.n	1e550 <silk_burg_modified_c+0x6a8>
   1e7e6:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1e7e8:	f1a3 0c04 	sub.w	ip, r3, #4
   1e7ec:	4673      	mov	r3, lr
   1e7ee:	4463      	add	r3, ip
   1e7f0:	469a      	mov	sl, r3
   1e7f2:	f50d 7ea0 	add.w	lr, sp, #320	; 0x140
   1e7f6:	f50d 7800 	add.w	r8, sp, #512	; 0x200
        *res_nrg = silk_LSHIFT( silk_SMMUL( invGain_Q30, C0 ), 2 );
        *res_nrg_Q = -rshifts;
    } else {
        /* Return residual energy */
        nrg  = CAf[ 0 ];                                                                            /* Q( -rshifts ) */
        tmp1 = (opus_int32)1 << 16;                                                                             /* Q16 */
   1e7fa:	f44f 3280 	mov.w	r2, #65536	; 0x10000
        for( k = 0; k < D; k++ ) {
            Atmp1 = silk_RSHIFT_ROUND( Af_QA[ k ], QA - 16 );                                       /* Q16 */
   1e7fe:	f85e 3b04 	ldr.w	r3, [lr], #4
            nrg  = silk_SMLAWW( nrg, CAf[ k + 1 ], Atmp1 );                                         /* Q( -rshifts ) */
   1e802:	f858 4f04 	ldr.w	r4, [r8, #4]!
            Atmp1 = silk_RSHIFT_ROUND( Af_QA[ k ], QA - 16 );                                       /* Q16 */
   1e806:	121b      	asrs	r3, r3, #8
   1e808:	3301      	adds	r3, #1
   1e80a:	1058      	asrs	r0, r3, #1
            nrg  = silk_SMLAWW( nrg, CAf[ k + 1 ], Atmp1 );                                         /* Q( -rshifts ) */
   1e80c:	b207      	sxth	r7, r0
            tmp1 = silk_SMLAWW( tmp1, Atmp1, Atmp1 );                                               /* Q16 */
   1e80e:	1459      	asrs	r1, r3, #17
   1e810:	fb07 f901 	mul.w	r9, r7, r1
            nrg  = silk_SMLAWW( nrg, CAf[ k + 1 ], Atmp1 );                                         /* Q( -rshifts ) */
   1e814:	fa1f fb84 	uxth.w	fp, r4
   1e818:	1426      	asrs	r6, r4, #16
            tmp1 = silk_SMLAWW( tmp1, Atmp1, Atmp1 );                                               /* Q16 */
   1e81a:	b281      	uxth	r1, r0
            nrg  = silk_SMLAWW( nrg, CAf[ k + 1 ], Atmp1 );                                         /* Q( -rshifts ) */
   1e81c:	fb07 fb0b 	mul.w	fp, r7, fp
   1e820:	fb07 f606 	mul.w	r6, r7, r6
            tmp1 = silk_SMLAWW( tmp1, Atmp1, Atmp1 );                                               /* Q16 */
   1e824:	fb07 f101 	mul.w	r1, r7, r1
            A_Q16[ k ] = -Atmp1;
   1e828:	4247      	negs	r7, r0
            nrg  = silk_SMLAWW( nrg, CAf[ k + 1 ], Atmp1 );                                         /* Q( -rshifts ) */
   1e82a:	141b      	asrs	r3, r3, #16
            A_Q16[ k ] = -Atmp1;
   1e82c:	f84c 7f04 	str.w	r7, [ip, #4]!
            nrg  = silk_SMLAWW( nrg, CAf[ k + 1 ], Atmp1 );                                         /* Q( -rshifts ) */
   1e830:	eb06 462b 	add.w	r6, r6, fp, asr #16
   1e834:	3301      	adds	r3, #1
            tmp1 = silk_SMLAWW( tmp1, Atmp1, Atmp1 );                                               /* Q16 */
   1e836:	eb09 4121 	add.w	r1, r9, r1, asr #16
            nrg  = silk_SMLAWW( nrg, CAf[ k + 1 ], Atmp1 );                                         /* Q( -rshifts ) */
   1e83a:	105b      	asrs	r3, r3, #1
   1e83c:	4435      	add	r5, r6
            tmp1 = silk_SMLAWW( tmp1, Atmp1, Atmp1 );                                               /* Q16 */
   1e83e:	4411      	add	r1, r2
        for( k = 0; k < D; k++ ) {
   1e840:	45d4      	cmp	ip, sl
            nrg  = silk_SMLAWW( nrg, CAf[ k + 1 ], Atmp1 );                                         /* Q( -rshifts ) */
   1e842:	fb03 5504 	mla	r5, r3, r4, r5
            tmp1 = silk_SMLAWW( tmp1, Atmp1, Atmp1 );                                               /* Q16 */
   1e846:	fb00 1203 	mla	r2, r0, r3, r1
        for( k = 0; k < D; k++ ) {
   1e84a:	d1d8      	bne.n	1e7fe <silk_burg_modified_c+0x956>
   1e84c:	4252      	negs	r2, r2
   1e84e:	b211      	sxth	r1, r2
   1e850:	13d3      	asrs	r3, r2, #15
   1e852:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   1e854:	b290      	uxth	r0, r2
   1e856:	1412      	asrs	r2, r2, #16
   1e858:	3301      	adds	r3, #1
   1e85a:	fb01 f000 	mul.w	r0, r1, r0
   1e85e:	fb01 f202 	mul.w	r2, r1, r2
   1e862:	105b      	asrs	r3, r3, #1
   1e864:	eb02 4220 	add.w	r2, r2, r0, asr #16
        }
        *res_nrg = silk_SMLAWW( nrg, silk_SMMUL( SILK_FIX_CONST( FIND_LPC_COND_FAC, 32 ), C0 ), -tmp1 );/* Q( -rshifts ) */
   1e868:	4415      	add	r5, r2
   1e86a:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   1e86c:	fb03 5502 	mla	r5, r3, r2, r5
   1e870:	9b1c      	ldr	r3, [sp, #112]	; 0x70
   1e872:	601d      	str	r5, [r3, #0]
        *res_nrg_Q = -rshifts;
   1e874:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   1e876:	461a      	mov	r2, r3
   1e878:	9b16      	ldr	r3, [sp, #88]	; 0x58
   1e87a:	6013      	str	r3, [r2, #0]
    }
}
   1e87c:	f50d 7d33 	add.w	sp, sp, #716	; 0x2cc
   1e880:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1e884:	469e      	mov	lr, r3
        Af_QA[ n ] = silk_RSHIFT32( rc_Q31, 31 - QA );                                          /* QA */
   1e886:	aa50      	add	r2, sp, #320	; 0x140
   1e888:	9b07      	ldr	r3, [sp, #28]
   1e88a:	f842 e023 	str.w	lr, [r2, r3, lsl #2]
        CAf[ n + 1 ] = tmp1;                                                                            /* Q( -rshifts ) */
   1e88e:	f04f 0a01 	mov.w	sl, #1
            for( k = n + 1; k < D; k++ ) {
   1e892:	9bbf      	ldr	r3, [sp, #764]	; 0x2fc
   1e894:	459a      	cmp	sl, r3
   1e896:	da09      	bge.n	1e8ac <silk_burg_modified_c+0xa04>
                Af_QA[ k ] = 0;
   1e898:	461a      	mov	r2, r3
   1e89a:	9b04      	ldr	r3, [sp, #16]
   1e89c:	a950      	add	r1, sp, #320	; 0x140
   1e89e:	1ad2      	subs	r2, r2, r3
   1e8a0:	eb01 0083 	add.w	r0, r1, r3, lsl #2
   1e8a4:	0092      	lsls	r2, r2, #2
   1e8a6:	2100      	movs	r1, #0
   1e8a8:	f016 fc5c 	bl	35164 <memset>
   1e8ac:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1e8ae:	f1a3 0c04 	sub.w	ip, r3, #4
   1e8b2:	9bbf      	ldr	r3, [sp, #764]	; 0x2fc
   1e8b4:	aa50      	add	r2, sp, #320	; 0x140
   1e8b6:	eb0c 0183 	add.w	r1, ip, r3, lsl #2
            A_Q16[ k ] = -silk_RSHIFT_ROUND( Af_QA[ k ], QA - 16 );
   1e8ba:	f852 3b04 	ldr.w	r3, [r2], #4
   1e8be:	121b      	asrs	r3, r3, #8
   1e8c0:	3301      	adds	r3, #1
   1e8c2:	105b      	asrs	r3, r3, #1
   1e8c4:	425b      	negs	r3, r3
   1e8c6:	f84c 3f04 	str.w	r3, [ip, #4]!
        for( k = 0; k < D; k++ ) {
   1e8ca:	4561      	cmp	r1, ip
   1e8cc:	d1f5      	bne.n	1e8ba <silk_burg_modified_c+0xa12>
        if( rshifts > 0 ) {
   1e8ce:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   1e8d0:	2b00      	cmp	r3, #0
            for( s = 0; s < nb_subfr; s++ ) {
   1e8d2:	9bbe      	ldr	r3, [sp, #760]	; 0x2f8
        if( rshifts > 0 ) {
   1e8d4:	dd45      	ble.n	1e962 <silk_burg_modified_c+0xaba>
            for( s = 0; s < nb_subfr; s++ ) {
   1e8d6:	2b00      	cmp	r3, #0
   1e8d8:	dd24      	ble.n	1e924 <silk_burg_modified_c+0xa7c>
   1e8da:	9e17      	ldr	r6, [sp, #92]	; 0x5c
   1e8dc:	9c18      	ldr	r4, [sp, #96]	; 0x60
   1e8de:	9f1b      	ldr	r7, [sp, #108]	; 0x6c
   1e8e0:	f8dd a2fc 	ldr.w	sl, [sp, #764]	; 0x2fc
   1e8e4:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
   1e8e8:	4698      	mov	r8, r3
   1e8ea:	2500      	movs	r5, #0
   1e8ec:	f1c6 0920 	rsb	r9, r6, #32
                C0 -= (opus_int32)silk_RSHIFT64( silk_inner_prod16_aligned_64( x_ptr, x_ptr, D, arch ), rshifts );
   1e8f0:	4652      	mov	r2, sl
   1e8f2:	4621      	mov	r1, r4
   1e8f4:	4620      	mov	r0, r4
   1e8f6:	f001 fa41 	bl	1fd7c <silk_inner_prod16_aligned_64_c>
   1e8fa:	f1b6 0320 	subs.w	r3, r6, #32
   1e8fe:	fa20 f006 	lsr.w	r0, r0, r6
   1e902:	fa01 f209 	lsl.w	r2, r1, r9
   1e906:	ea40 0002 	orr.w	r0, r0, r2
   1e90a:	bf58      	it	pl
   1e90c:	fa41 f303 	asrpl.w	r3, r1, r3
            for( s = 0; s < nb_subfr; s++ ) {
   1e910:	f105 0501 	add.w	r5, r5, #1
                C0 -= (opus_int32)silk_RSHIFT64( silk_inner_prod16_aligned_64( x_ptr, x_ptr, D, arch ), rshifts );
   1e914:	bf58      	it	pl
   1e916:	4318      	orrpl	r0, r3
            for( s = 0; s < nb_subfr; s++ ) {
   1e918:	45a8      	cmp	r8, r5
   1e91a:	445c      	add	r4, fp
                C0 -= (opus_int32)silk_RSHIFT64( silk_inner_prod16_aligned_64( x_ptr, x_ptr, D, arch ), rshifts );
   1e91c:	eba7 0700 	sub.w	r7, r7, r0
            for( s = 0; s < nb_subfr; s++ ) {
   1e920:	d1e6      	bne.n	1e8f0 <silk_burg_modified_c+0xa48>
   1e922:	971b      	str	r7, [sp, #108]	; 0x6c
        *res_nrg = silk_LSHIFT( silk_SMMUL( invGain_Q30, C0 ), 2 );
   1e924:	9bbc      	ldr	r3, [sp, #752]	; 0x2f0
   1e926:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   1e928:	fb83 2302 	smull	r2, r3, r3, r2
   1e92c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
   1e92e:	009b      	lsls	r3, r3, #2
   1e930:	6013      	str	r3, [r2, #0]
        *res_nrg_Q = -rshifts;
   1e932:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   1e934:	461a      	mov	r2, r3
   1e936:	9b16      	ldr	r3, [sp, #88]	; 0x58
   1e938:	6013      	str	r3, [r2, #0]
}
   1e93a:	f50d 7d33 	add.w	sp, sp, #716	; 0x2cc
   1e93e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1e942:	428b      	cmp	r3, r1
   1e944:	bfb8      	it	lt
   1e946:	460b      	movlt	r3, r1
   1e948:	e734      	b.n	1e7b4 <silk_burg_modified_c+0x90c>
   1e94a:	429e      	cmp	r6, r3
   1e94c:	bfb8      	it	lt
   1e94e:	461e      	movlt	r6, r3
   1e950:	e70c      	b.n	1e76c <silk_burg_modified_c+0x8c4>
   1e952:	4296      	cmp	r6, r2
   1e954:	bfb8      	it	lt
   1e956:	4616      	movlt	r6, r2
   1e958:	e708      	b.n	1e76c <silk_burg_modified_c+0x8c4>
   1e95a:	4293      	cmp	r3, r2
   1e95c:	bfb8      	it	lt
   1e95e:	4613      	movlt	r3, r2
   1e960:	e728      	b.n	1e7b4 <silk_burg_modified_c+0x90c>
            for( s = 0; s < nb_subfr; s++ ) {
   1e962:	2b00      	cmp	r3, #0
   1e964:	ddde      	ble.n	1e924 <silk_burg_modified_c+0xa7c>
   1e966:	9c18      	ldr	r4, [sp, #96]	; 0x60
   1e968:	9f16      	ldr	r7, [sp, #88]	; 0x58
   1e96a:	9e1b      	ldr	r6, [sp, #108]	; 0x6c
   1e96c:	f8dd 92fc 	ldr.w	r9, [sp, #764]	; 0x2fc
   1e970:	f8dd a300 	ldr.w	sl, [sp, #768]	; 0x300
   1e974:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
   1e978:	4698      	mov	r8, r3
   1e97a:	2500      	movs	r5, #0
                C0 -= silk_LSHIFT32( silk_inner_prod_aligned( x_ptr, x_ptr, D, arch), -rshifts);
   1e97c:	4621      	mov	r1, r4
   1e97e:	4620      	mov	r0, r4
   1e980:	4653      	mov	r3, sl
   1e982:	464a      	mov	r2, r9
   1e984:	f001 f9e4 	bl	1fd50 <silk_inner_prod_aligned>
            for( s = 0; s < nb_subfr; s++ ) {
   1e988:	3501      	adds	r5, #1
                C0 -= silk_LSHIFT32( silk_inner_prod_aligned( x_ptr, x_ptr, D, arch), -rshifts);
   1e98a:	40b8      	lsls	r0, r7
            for( s = 0; s < nb_subfr; s++ ) {
   1e98c:	45a8      	cmp	r8, r5
                C0 -= silk_LSHIFT32( silk_inner_prod_aligned( x_ptr, x_ptr, D, arch), -rshifts);
   1e98e:	eba6 0600 	sub.w	r6, r6, r0
   1e992:	445c      	add	r4, fp
            for( s = 0; s < nb_subfr; s++ ) {
   1e994:	d1f2      	bne.n	1e97c <silk_burg_modified_c+0xad4>
   1e996:	961b      	str	r6, [sp, #108]	; 0x6c
   1e998:	e7c4      	b.n	1e924 <silk_burg_modified_c+0xa7c>
        Af_QA[ n ] = silk_RSHIFT32( rc_Q31, 31 - QA );                                          /* QA */
   1e99a:	9b07      	ldr	r3, [sp, #28]
   1e99c:	aa50      	add	r2, sp, #320	; 0x140
        CAf[ n + 1 ] = tmp1;                                                                            /* Q( -rshifts ) */
   1e99e:	f04f 0a01 	mov.w	sl, #1
        Af_QA[ n ] = silk_RSHIFT32( rc_Q31, 31 - QA );                                          /* QA */
   1e9a2:	f842 b023 	str.w	fp, [r2, r3, lsl #2]
   1e9a6:	e774      	b.n	1e892 <silk_burg_modified_c+0x9ea>
    for( n = 0; n < D; n++ ) {
   1e9a8:	4625      	mov	r5, r4
   1e9aa:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1e9ae:	2200      	movs	r2, #0
   1e9b0:	e75a      	b.n	1e868 <silk_burg_modified_c+0x9c0>
   1e9b2:	9b14      	ldr	r3, [sp, #80]	; 0x50
   1e9b4:	93bc      	str	r3, [sp, #752]	; 0x2f0
   1e9b6:	e76c      	b.n	1e892 <silk_burg_modified_c+0x9ea>

0001e9b8 <silk_k2a>:
)
{
    opus_int   k, n;
    opus_int32 rc, tmp1, tmp2;

    for( k = 0; k < order; k++ ) {
   1e9b8:	2a00      	cmp	r2, #0
   1e9ba:	dd40      	ble.n	1ea3e <silk_k2a+0x86>
{
   1e9bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1e9c0:	b083      	sub	sp, #12
   1e9c2:	eb00 0382 	add.w	r3, r0, r2, lsl #2
        rc = rc_Q15[ k ];
   1e9c6:	f9b1 c000 	ldrsh.w	ip, [r1]
   1e9ca:	9301      	str	r3, [sp, #4]
   1e9cc:	4682      	mov	sl, r0
   1e9ce:	f04f 0b02 	mov.w	fp, #2
            tmp1 = A_Q24[ n ];
            tmp2 = A_Q24[ k - n - 1 ];
            A_Q24[ n ]         = silk_SMLAWB( tmp1, silk_LSHIFT( tmp2, 1 ), rc );
            A_Q24[ k - n - 1 ] = silk_SMLAWB( tmp2, silk_LSHIFT( tmp1, 1 ), rc );
        }
        A_Q24[ k ] = -silk_LSHIFT( (opus_int32)rc_Q15[ k ], 9 );
   1e9d2:	ea4f 2c4c 	mov.w	ip, ip, lsl #9
   1e9d6:	f1cc 0300 	rsb	r3, ip, #0
   1e9da:	f84a 3b04 	str.w	r3, [sl], #4
    for( k = 0; k < order; k++ ) {
   1e9de:	9b01      	ldr	r3, [sp, #4]
   1e9e0:	4553      	cmp	r3, sl
   1e9e2:	d029      	beq.n	1ea38 <silk_k2a+0x80>
   1e9e4:	f1a0 0e04 	sub.w	lr, r0, #4
        for( n = 0; n < (k + 1) >> 1; n++ ) {
   1e9e8:	ea4f 096b 	mov.w	r9, fp, asr #1
        rc = rc_Q15[ k ];
   1e9ec:	f931 cf02 	ldrsh.w	ip, [r1, #2]!
   1e9f0:	eb0e 0989 	add.w	r9, lr, r9, lsl #2
        for( n = 0; n < (k + 1) >> 1; n++ ) {
   1e9f4:	46d0      	mov	r8, sl
            tmp1 = A_Q24[ n ];
   1e9f6:	f85e 4f04 	ldr.w	r4, [lr, #4]!
            tmp2 = A_Q24[ k - n - 1 ];
   1e9fa:	f858 5d04 	ldr.w	r5, [r8, #-4]!
            A_Q24[ k - n - 1 ] = silk_SMLAWB( tmp2, silk_LSHIFT( tmp1, 1 ), rc );
   1e9fe:	0063      	lsls	r3, r4, #1
            A_Q24[ n ]         = silk_SMLAWB( tmp1, silk_LSHIFT( tmp2, 1 ), rc );
   1ea00:	006a      	lsls	r2, r5, #1
            A_Q24[ k - n - 1 ] = silk_SMLAWB( tmp2, silk_LSHIFT( tmp1, 1 ), rc );
   1ea02:	b29f      	uxth	r7, r3
            A_Q24[ n ]         = silk_SMLAWB( tmp1, silk_LSHIFT( tmp2, 1 ), rc );
   1ea04:	b296      	uxth	r6, r2
            A_Q24[ k - n - 1 ] = silk_SMLAWB( tmp2, silk_LSHIFT( tmp1, 1 ), rc );
   1ea06:	141b      	asrs	r3, r3, #16
            A_Q24[ n ]         = silk_SMLAWB( tmp1, silk_LSHIFT( tmp2, 1 ), rc );
   1ea08:	1412      	asrs	r2, r2, #16
            A_Q24[ k - n - 1 ] = silk_SMLAWB( tmp2, silk_LSHIFT( tmp1, 1 ), rc );
   1ea0a:	fb0c f707 	mul.w	r7, ip, r7
   1ea0e:	fb0c f303 	mul.w	r3, ip, r3
            A_Q24[ n ]         = silk_SMLAWB( tmp1, silk_LSHIFT( tmp2, 1 ), rc );
   1ea12:	fb0c f606 	mul.w	r6, ip, r6
   1ea16:	fb0c f202 	mul.w	r2, ip, r2
            A_Q24[ k - n - 1 ] = silk_SMLAWB( tmp2, silk_LSHIFT( tmp1, 1 ), rc );
   1ea1a:	eb03 4327 	add.w	r3, r3, r7, asr #16
            A_Q24[ n ]         = silk_SMLAWB( tmp1, silk_LSHIFT( tmp2, 1 ), rc );
   1ea1e:	eb02 4226 	add.w	r2, r2, r6, asr #16
            A_Q24[ k - n - 1 ] = silk_SMLAWB( tmp2, silk_LSHIFT( tmp1, 1 ), rc );
   1ea22:	442b      	add	r3, r5
            A_Q24[ n ]         = silk_SMLAWB( tmp1, silk_LSHIFT( tmp2, 1 ), rc );
   1ea24:	4422      	add	r2, r4
        for( n = 0; n < (k + 1) >> 1; n++ ) {
   1ea26:	45ce      	cmp	lr, r9
            A_Q24[ n ]         = silk_SMLAWB( tmp1, silk_LSHIFT( tmp2, 1 ), rc );
   1ea28:	f8ce 2000 	str.w	r2, [lr]
            A_Q24[ k - n - 1 ] = silk_SMLAWB( tmp2, silk_LSHIFT( tmp1, 1 ), rc );
   1ea2c:	f8c8 3000 	str.w	r3, [r8]
        for( n = 0; n < (k + 1) >> 1; n++ ) {
   1ea30:	d1e1      	bne.n	1e9f6 <silk_k2a+0x3e>
   1ea32:	f10b 0b01 	add.w	fp, fp, #1
   1ea36:	e7cc      	b.n	1e9d2 <silk_k2a+0x1a>
    }
}
   1ea38:	b003      	add	sp, #12
   1ea3a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1ea3e:	4770      	bx	lr

0001ea40 <silk_k2a_Q16>:
void silk_k2a_Q16(
    opus_int32                  *A_Q24,             /* O    Prediction coefficients [order] Q24                         */
    const opus_int32            *rc_Q16,            /* I    Reflection coefficients [order] Q16                         */
    const opus_int32            order               /* I    Prediction order                                            */
)
{
   1ea40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1ea44:	b083      	sub	sp, #12
    opus_int   k, n;
    opus_int32 rc, tmp1, tmp2;

    for( k = 0; k < order; k++ ) {
   1ea46:	2a00      	cmp	r2, #0
{
   1ea48:	9000      	str	r0, [sp, #0]
    for( k = 0; k < order; k++ ) {
   1ea4a:	dd47      	ble.n	1eadc <silk_k2a_Q16+0x9c>
   1ea4c:	468b      	mov	fp, r1
        rc = rc_Q16[ k ];
   1ea4e:	4681      	mov	r9, r0
   1ea50:	f8db 1000 	ldr.w	r1, [fp]
            tmp1 = A_Q24[ n ];
            tmp2 = A_Q24[ k - n - 1 ];
            A_Q24[ n ]         = silk_SMLAWW( tmp1, tmp2, rc );
            A_Q24[ k - n - 1 ] = silk_SMLAWW( tmp2, tmp1, rc );
        }
        A_Q24[ k ] = -silk_LSHIFT( rc, 8 );
   1ea54:	0209      	lsls	r1, r1, #8
   1ea56:	4249      	negs	r1, r1
   1ea58:	eb00 0282 	add.w	r2, r0, r2, lsl #2
   1ea5c:	f849 1b04 	str.w	r1, [r9], #4
   1ea60:	4613      	mov	r3, r2
    for( k = 0; k < order; k++ ) {
   1ea62:	454b      	cmp	r3, r9
   1ea64:	9201      	str	r2, [sp, #4]
        rc = rc_Q16[ k ];
   1ea66:	f04f 0a02 	mov.w	sl, #2
    for( k = 0; k < order; k++ ) {
   1ea6a:	d037      	beq.n	1eadc <silk_k2a_Q16+0x9c>
        rc = rc_Q16[ k ];
   1ea6c:	f85b 1f04 	ldr.w	r1, [fp, #4]!
   1ea70:	9b00      	ldr	r3, [sp, #0]
            A_Q24[ n ]         = silk_SMLAWW( tmp1, tmp2, rc );
   1ea72:	ea4f 3ee1 	mov.w	lr, r1, asr #15
   1ea76:	f10e 0e01 	add.w	lr, lr, #1
   1ea7a:	1f1e      	subs	r6, r3, #4
        for( n = 0; n < (k + 1) >> 1; n++ ) {
   1ea7c:	ea4f 086a 	mov.w	r8, sl, asr #1
            A_Q24[ n ]         = silk_SMLAWW( tmp1, tmp2, rc );
   1ea80:	ea4f 0e6e 	mov.w	lr, lr, asr #1
   1ea84:	b20f      	sxth	r7, r1
   1ea86:	eb06 0888 	add.w	r8, r6, r8, lsl #2
   1ea8a:	46cc      	mov	ip, r9
            tmp2 = A_Q24[ k - n - 1 ];
   1ea8c:	f85c 0d04 	ldr.w	r0, [ip, #-4]!
            tmp1 = A_Q24[ n ];
   1ea90:	f856 2f04 	ldr.w	r2, [r6, #4]!
            A_Q24[ n ]         = silk_SMLAWW( tmp1, tmp2, rc );
   1ea94:	b283      	uxth	r3, r0
   1ea96:	1404      	asrs	r4, r0, #16
   1ea98:	fb07 f303 	mul.w	r3, r7, r3
   1ea9c:	fb07 f404 	mul.w	r4, r7, r4
   1eaa0:	eb04 4423 	add.w	r4, r4, r3, asr #16
            A_Q24[ k - n - 1 ] = silk_SMLAWW( tmp2, tmp1, rc );
   1eaa4:	b295      	uxth	r5, r2
   1eaa6:	1413      	asrs	r3, r2, #16
   1eaa8:	fb07 f505 	mul.w	r5, r7, r5
   1eaac:	fb07 f303 	mul.w	r3, r7, r3
   1eab0:	eb03 4325 	add.w	r3, r3, r5, asr #16
   1eab4:	4403      	add	r3, r0
            A_Q24[ n ]         = silk_SMLAWW( tmp1, tmp2, rc );
   1eab6:	4414      	add	r4, r2
   1eab8:	fb00 400e 	mla	r0, r0, lr, r4
            A_Q24[ k - n - 1 ] = silk_SMLAWW( tmp2, tmp1, rc );
   1eabc:	fb02 330e 	mla	r3, r2, lr, r3
        for( n = 0; n < (k + 1) >> 1; n++ ) {
   1eac0:	4546      	cmp	r6, r8
            A_Q24[ n ]         = silk_SMLAWW( tmp1, tmp2, rc );
   1eac2:	6030      	str	r0, [r6, #0]
            A_Q24[ k - n - 1 ] = silk_SMLAWW( tmp2, tmp1, rc );
   1eac4:	f8cc 3000 	str.w	r3, [ip]
        for( n = 0; n < (k + 1) >> 1; n++ ) {
   1eac8:	d1e0      	bne.n	1ea8c <silk_k2a_Q16+0x4c>
        A_Q24[ k ] = -silk_LSHIFT( rc, 8 );
   1eaca:	0209      	lsls	r1, r1, #8
   1eacc:	4249      	negs	r1, r1
   1eace:	9b01      	ldr	r3, [sp, #4]
   1ead0:	f849 1b04 	str.w	r1, [r9], #4
    for( k = 0; k < order; k++ ) {
   1ead4:	454b      	cmp	r3, r9
   1ead6:	f10a 0a01 	add.w	sl, sl, #1
   1eada:	d1c7      	bne.n	1ea6c <silk_k2a_Q16+0x2c>
    }
}
   1eadc:	b003      	add	sp, #12
   1eade:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1eae2:	bf00      	nop

0001eae4 <silk_pitch_analysis_core>:
    const opus_int              Fs_kHz,             /* I    Sample frequency (kHz)                                      */
    const opus_int              complexity,         /* I    Complexity setting, 0-2, where 2 is highest                 */
    const opus_int              nb_subfr,           /* I    number of 5 ms subframes                                    */
    int                         arch                /* I    Run-time architecture                                       */
)
{
   1eae4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1eae8:	f5ad 7d79 	sub.w	sp, sp, #996	; 0x3e4
   1eaec:	af02      	add	r7, sp, #8
   1eaee:	e9c7 3207 	strd	r3, r2, [r7, #28]

    silk_assert( search_thres1_Q16 >= 0 && search_thres1_Q16 <= (1<<16) );
    silk_assert( search_thres2_Q13 >= 0 && search_thres2_Q13 <= (1<<13) );

    /* Set up frame lengths max / min lag for the sampling frequency */
    frame_length      = ( PE_LTP_MEM_LENGTH_MS + nb_subfr * PE_SUBFR_LENGTH_MS ) * Fs_kHz;
   1eaf2:	f8d7 4418 	ldr.w	r4, [r7, #1048]	; 0x418
   1eaf6:	f8d7 5418 	ldr.w	r5, [r7, #1048]	; 0x418
{
   1eafa:	6479      	str	r1, [r7, #68]	; 0x44
    frame_length      = ( PE_LTP_MEM_LENGTH_MS + nb_subfr * PE_SUBFR_LENGTH_MS ) * Fs_kHz;
   1eafc:	00a4      	lsls	r4, r4, #2
   1eafe:	eb04 0905 	add.w	r9, r4, r5
{
   1eb02:	4605      	mov	r5, r0
    frame_length      = ( PE_LTP_MEM_LENGTH_MS + nb_subfr * PE_SUBFR_LENGTH_MS ) * Fs_kHz;
   1eb04:	f8d7 0410 	ldr.w	r0, [r7, #1040]	; 0x410
   1eb08:	637c      	str	r4, [r7, #52]	; 0x34
   1eb0a:	f109 0914 	add.w	r9, r9, #20
   1eb0e:	fb00 f409 	mul.w	r4, r0, r9
    sf_length         = PE_SUBFR_LENGTH_MS * Fs_kHz;
    min_lag           = PE_MIN_LAG_MS * Fs_kHz;
    max_lag           = PE_MAX_LAG_MS * Fs_kHz - 1;

    /* Downscale input if necessary */
    silk_sum_sqr_shift( &energy, &shift, frame_unscaled, frame_length );
   1eb12:	4623      	mov	r3, r4
   1eb14:	462a      	mov	r2, r5
   1eb16:	f107 0170 	add.w	r1, r7, #112	; 0x70
   1eb1a:	f107 006c 	add.w	r0, r7, #108	; 0x6c
   1eb1e:	f7fb fa13 	bl	19f48 <silk_sum_sqr_shift>
    shift += 3 - silk_CLZ32( energy );        /* at least two bits headroom */
   1eb22:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    frame_length_4kHz = ( PE_LTP_MEM_LENGTH_MS + nb_subfr * PE_SUBFR_LENGTH_MS ) * 4;
   1eb24:	ea4f 0889 	mov.w	r8, r9, lsl #2
    frame_length_8kHz = ( PE_LTP_MEM_LENGTH_MS + nb_subfr * PE_SUBFR_LENGTH_MS ) * 8;
   1eb28:	ea4f 09c9 	mov.w	r9, r9, lsl #3
   1eb2c:	2b00      	cmp	r3, #0
   1eb2e:	f000 846e 	beq.w	1f40e <silk_pitch_analysis_core+0x92a>
   1eb32:	fab3 f383 	clz	r3, r3
   1eb36:	f1c3 0303 	rsb	r3, r3, #3
    ALLOC( frame_scaled, frame_length, opus_int16 );
   1eb3a:	0060      	lsls	r0, r4, #1
    shift += 3 - silk_CLZ32( energy );        /* at least two bits headroom */
   1eb3c:	6f39      	ldr	r1, [r7, #112]	; 0x70
    ALLOC( frame_scaled, frame_length, opus_int16 );
   1eb3e:	f100 0208 	add.w	r2, r0, #8
   1eb42:	f022 0207 	bic.w	r2, r2, #7
    shift += 3 - silk_CLZ32( energy );        /* at least two bits headroom */
   1eb46:	440b      	add	r3, r1
    ALLOC( frame_scaled, frame_length, opus_int16 );
   1eb48:	ebad 0d02 	sub.w	sp, sp, r2
   1eb4c:	a902      	add	r1, sp, #8
    if( shift > 0 ) {
   1eb4e:	2b00      	cmp	r3, #0
    ALLOC( frame_scaled, frame_length, opus_int16 );
   1eb50:	6439      	str	r1, [r7, #64]	; 0x40
    shift += 3 - silk_CLZ32( energy );        /* at least two bits headroom */
   1eb52:	673b      	str	r3, [r7, #112]	; 0x70
    if( shift > 0 ) {
   1eb54:	f340 84a4 	ble.w	1f4a0 <silk_pitch_analysis_core+0x9bc>
        shift = silk_RSHIFT( shift + 1, 1 );
   1eb58:	3301      	adds	r3, #1
   1eb5a:	105a      	asrs	r2, r3, #1
        for( i = 0; i < frame_length; i++ ) {
   1eb5c:	2c00      	cmp	r4, #0
        shift = silk_RSHIFT( shift + 1, 1 );
   1eb5e:	673a      	str	r2, [r7, #112]	; 0x70
        for( i = 0; i < frame_length; i++ ) {
   1eb60:	dd0a      	ble.n	1eb78 <silk_pitch_analysis_core+0x94>
   1eb62:	3d02      	subs	r5, #2
   1eb64:	4428      	add	r0, r5
   1eb66:	f10d 0106 	add.w	r1, sp, #6
            frame_scaled[ i ] = silk_RSHIFT( frame_unscaled[ i ], shift );
   1eb6a:	f935 3f02 	ldrsh.w	r3, [r5, #2]!
   1eb6e:	4113      	asrs	r3, r2
        for( i = 0; i < frame_length; i++ ) {
   1eb70:	42a8      	cmp	r0, r5
            frame_scaled[ i ] = silk_RSHIFT( frame_unscaled[ i ], shift );
   1eb72:	f821 3f02 	strh.w	r3, [r1, #2]!
        for( i = 0; i < frame_length; i++ ) {
   1eb76:	d1f8      	bne.n	1eb6a <silk_pitch_analysis_core+0x86>
        frame = frame_scaled;
    } else {
        frame = frame_unscaled;
    }

    ALLOC( frame_8kHz_buf, ( Fs_kHz == 8 ) ? 1 : frame_length_8kHz, opus_int16 );
   1eb78:	f8d7 3410 	ldr.w	r3, [r7, #1040]	; 0x410
   1eb7c:	2b08      	cmp	r3, #8
   1eb7e:	d00e      	beq.n	1eb9e <silk_pitch_analysis_core+0xba>
   1eb80:	ea4f 0349 	mov.w	r3, r9, lsl #1
   1eb84:	3308      	adds	r3, #8
   1eb86:	ebad 0d03 	sub.w	sp, sp, r3
   1eb8a:	ab02      	add	r3, sp, #8
   1eb8c:	653b      	str	r3, [r7, #80]	; 0x50
    /* Resample from input sampled at Fs_kHz to 8 kHz */
    if( Fs_kHz == 16 ) {
   1eb8e:	f8d7 3410 	ldr.w	r3, [r7, #1040]	; 0x410
   1eb92:	2b10      	cmp	r3, #16
   1eb94:	f000 86f9 	beq.w	1f98a <silk_pitch_analysis_core+0xea6>
        silk_memset( filt_state, 0, 2 * sizeof( opus_int32 ) );
        silk_resampler_down2( filt_state, frame_8kHz_buf, frame, frame_length );
        frame_8kHz = frame_8kHz_buf;
    } else if( Fs_kHz == 12 ) {
   1eb98:	2b0c      	cmp	r3, #12
   1eb9a:	f000 8703 	beq.w	1f9a4 <silk_pitch_analysis_core+0xec0>
        silk_memset( filt_state, 0, 6 * sizeof( opus_int32 ) );
        silk_resampler_down2_3( filt_state, frame_8kHz_buf, frame, frame_length );
        frame_8kHz = frame_8kHz_buf;
    } else {
        celt_assert( Fs_kHz == 8 );
        frame_8kHz = frame;
   1eb9e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1eba0:	653b      	str	r3, [r7, #80]	; 0x50
   1eba2:	f107 0574 	add.w	r5, r7, #116	; 0x74
    }

    /* Decimate again to 4 kHz */
    silk_memset( filt_state, 0, 2 * sizeof( opus_int32 ) );/* Set state to zero */
    ALLOC( frame_4kHz, frame_length_4kHz, opus_int16 );
   1eba6:	ea4f 0648 	mov.w	r6, r8, lsl #1
   1ebaa:	f106 0308 	add.w	r3, r6, #8
   1ebae:	ebad 0d03 	sub.w	sp, sp, r3
    silk_memset( filt_state, 0, 2 * sizeof( opus_int32 ) );/* Set state to zero */
   1ebb2:	2200      	movs	r2, #0
    ALLOC( frame_4kHz, frame_length_4kHz, opus_int16 );
   1ebb4:	f10d 0a08 	add.w	sl, sp, #8
    silk_memset( filt_state, 0, 2 * sizeof( opus_int32 ) );/* Set state to zero */
   1ebb8:	e9c5 2200 	strd	r2, r2, [r5]
    silk_resampler_down2( filt_state, frame_4kHz, frame_8kHz, frame_length_8kHz );
   1ebbc:	464b      	mov	r3, r9
   1ebbe:	4651      	mov	r1, sl
   1ebc0:	4628      	mov	r0, r5
   1ebc2:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   1ebc4:	f7fa f9d4 	bl	18f70 <silk_resampler_down2>

    /* Low-pass filter */
    for( i = frame_length_4kHz - 1; i > 0; i-- ) {
   1ebc8:	f1b8 0f01 	cmp.w	r8, #1
   1ebcc:	dd20      	ble.n	1ec10 <silk_pitch_analysis_core+0x12c>
   1ebce:	4456      	add	r6, sl
   1ebd0:	f108 4200 	add.w	r2, r8, #2147483648	; 0x80000000
   1ebd4:	3a01      	subs	r2, #1
   1ebd6:	f936 3c02 	ldrsh.w	r3, [r6, #-2]
        frame_4kHz[ i ] = silk_ADD_SAT16( frame_4kHz[ i ], frame_4kHz[ i - 1 ] );
   1ebda:	49b5      	ldr	r1, [pc, #724]	; (1eeb0 <silk_pitch_analysis_core+0x3cc>)
   1ebdc:	eb0a 0242 	add.w	r2, sl, r2, lsl #1
   1ebe0:	e009      	b.n	1ebf6 <silk_pitch_analysis_core+0x112>
   1ebe2:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
   1ebe6:	f2c0 8100 	blt.w	1edea <silk_pitch_analysis_core+0x306>
   1ebea:	b21b      	sxth	r3, r3
   1ebec:	f822 3902 	strh.w	r3, [r2], #-2
    for( i = frame_length_4kHz - 1; i > 0; i-- ) {
   1ebf0:	4592      	cmp	sl, r2
   1ebf2:	4603      	mov	r3, r0
   1ebf4:	d00c      	beq.n	1ec10 <silk_pitch_analysis_core+0x12c>
        frame_4kHz[ i ] = silk_ADD_SAT16( frame_4kHz[ i ], frame_4kHz[ i - 1 ] );
   1ebf6:	f932 0c02 	ldrsh.w	r0, [r2, #-2]
   1ebfa:	4403      	add	r3, r0
   1ebfc:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1ec00:	dbef      	blt.n	1ebe2 <silk_pitch_analysis_core+0xfe>
   1ec02:	f647 73ff 	movw	r3, #32767	; 0x7fff
   1ec06:	f822 3902 	strh.w	r3, [r2], #-2
    for( i = frame_length_4kHz - 1; i > 0; i-- ) {
   1ec0a:	4592      	cmp	sl, r2
   1ec0c:	4603      	mov	r3, r0
   1ec0e:	d1f2      	bne.n	1ebf6 <silk_pitch_analysis_core+0x112>


    /******************************************************************************
    * FIRST STAGE, operating in 4 khz
    ******************************************************************************/
    ALLOC( C, nb_subfr * CSTRIDE_8KHZ, opus_int16 );
   1ec10:	f8d7 3418 	ldr.w	r3, [r7, #1048]	; 0x418
   1ec14:	f8d7 2418 	ldr.w	r2, [r7, #1048]	; 0x418
   1ec18:	015b      	lsls	r3, r3, #5
   1ec1a:	64bb      	str	r3, [r7, #72]	; 0x48
   1ec1c:	4413      	add	r3, r2
   1ec1e:	00db      	lsls	r3, r3, #3
   1ec20:	64fb      	str	r3, [r7, #76]	; 0x4c
   1ec22:	3308      	adds	r3, #8
   1ec24:	ebad 0d03 	sub.w	sp, sp, r3
    ALLOC( xcorr32, MAX_LAG_4KHZ-MIN_LAG_4KHZ+1, opus_int32 );
    silk_memset( C, 0, (nb_subfr >> 1) * CSTRIDE_4KHZ * sizeof( opus_int16 ) );
   1ec28:	1055      	asrs	r5, r2, #1
    ALLOC( C, nb_subfr * CSTRIDE_8KHZ, opus_int16 );
   1ec2a:	ab02      	add	r3, sp, #8
    silk_memset( C, 0, (nb_subfr >> 1) * CSTRIDE_4KHZ * sizeof( opus_int16 ) );
   1ec2c:	eb05 1285 	add.w	r2, r5, r5, lsl #6
   1ec30:	4618      	mov	r0, r3
   1ec32:	0052      	lsls	r2, r2, #1
   1ec34:	2100      	movs	r1, #0
    ALLOC( C, nb_subfr * CSTRIDE_8KHZ, opus_int16 );
   1ec36:	461c      	mov	r4, r3
   1ec38:	667b      	str	r3, [r7, #100]	; 0x64
    silk_memset( C, 0, (nb_subfr >> 1) * CSTRIDE_4KHZ * sizeof( opus_int16 ) );
   1ec3a:	f016 fa93 	bl	35164 <memset>
    target_ptr = &frame_4kHz[ silk_LSHIFT( SF_LENGTH_4KHZ, 2 ) ];
    for( k = 0; k < nb_subfr >> 1; k++ ) {
   1ec3e:	2d00      	cmp	r5, #0
    target_ptr = &frame_4kHz[ silk_LSHIFT( SF_LENGTH_4KHZ, 2 ) ];
   1ec40:	f10a 03a0 	add.w	r3, sl, #160	; 0xa0
    for( k = 0; k < nb_subfr >> 1; k++ ) {
   1ec44:	f340 80f5 	ble.w	1ee32 <silk_pitch_analysis_core+0x34e>
   1ec48:	eb05 0585 	add.w	r5, r5, r5, lsl #2
   1ec4c:	eb03 1505 	add.w	r5, r3, r5, lsl #4
   1ec50:	f1a5 0210 	sub.w	r2, r5, #16
   1ec54:	65ba      	str	r2, [r7, #88]	; 0x58
   1ec56:	f10a 0a90 	add.w	sl, sl, #144	; 0x90
   1ec5a:	663c      	str	r4, [r7, #96]	; 0x60
   1ec5c:	f507 7be4 	add.w	fp, r7, #456	; 0x1c8

        /* Check that we are within range of the array */
        celt_assert( basis_ptr >= frame_4kHz );
        celt_assert( basis_ptr + SF_LENGTH_8KHZ <= frame_4kHz + frame_length_4kHz );

        celt_pitch_xcorr( target_ptr, target_ptr - MAX_LAG_4KHZ, xcorr32, SF_LENGTH_8KHZ, MAX_LAG_4KHZ - MIN_LAG_4KHZ + 1, arch );
   1ec60:	f8d7 241c 	ldr.w	r2, [r7, #1052]	; 0x41c
   1ec64:	9201      	str	r2, [sp, #4]
   1ec66:	f10a 0410 	add.w	r4, sl, #16
   1ec6a:	2341      	movs	r3, #65	; 0x41
   1ec6c:	9300      	str	r3, [sp, #0]
   1ec6e:	465a      	mov	r2, fp
   1ec70:	2328      	movs	r3, #40	; 0x28
   1ec72:	f1aa 0180 	sub.w	r1, sl, #128	; 0x80
   1ec76:	4620      	mov	r0, r4
   1ec78:	f00d f986 	bl	2bf88 <celt_pitch_xcorr_c>

        /* Calculate first vector products before loop */
        cross_corr = xcorr32[ MAX_LAG_4KHZ - MIN_LAG_4KHZ ];
        normalizer = silk_inner_prod_aligned( target_ptr, target_ptr, SF_LENGTH_8KHZ, arch );
   1ec7c:	4621      	mov	r1, r4
   1ec7e:	f8d7 341c 	ldr.w	r3, [r7, #1052]	; 0x41c
        cross_corr = xcorr32[ MAX_LAG_4KHZ - MIN_LAG_4KHZ ];
   1ec82:	f8db 6100 	ldr.w	r6, [fp, #256]	; 0x100
        normalizer = silk_inner_prod_aligned( target_ptr, target_ptr, SF_LENGTH_8KHZ, arch );
   1ec86:	2228      	movs	r2, #40	; 0x28
   1ec88:	4620      	mov	r0, r4
   1ec8a:	f001 f861 	bl	1fd50 <silk_inner_prod_aligned>
        normalizer = silk_ADD32( normalizer, silk_inner_prod_aligned( basis_ptr,  basis_ptr, SF_LENGTH_8KHZ, arch ) );
   1ec8e:	f8d7 341c 	ldr.w	r3, [r7, #1052]	; 0x41c
        normalizer = silk_inner_prod_aligned( target_ptr, target_ptr, SF_LENGTH_8KHZ, arch );
   1ec92:	4605      	mov	r5, r0
        normalizer = silk_ADD32( normalizer, silk_inner_prod_aligned( basis_ptr,  basis_ptr, SF_LENGTH_8KHZ, arch ) );
   1ec94:	2228      	movs	r2, #40	; 0x28
   1ec96:	4651      	mov	r1, sl
   1ec98:	4650      	mov	r0, sl
   1ec9a:	f001 f859 	bl	1fd50 <silk_inner_prod_aligned>
   1ec9e:	4428      	add	r0, r5
        normalizer = silk_ADD32( normalizer, silk_SMULBB( SF_LENGTH_8KHZ, 4000 ) );
   1eca0:	f500 3c1c 	add.w	ip, r0, #159744	; 0x27000
   1eca4:	f50c 7c80 	add.w	ip, ip, #256	; 0x100
   1eca8:	2e00      	cmp	r6, #0
   1ecaa:	f000 8398 	beq.w	1f3de <silk_pitch_analysis_core+0x8fa>
    a_headrm = silk_CLZ32( silk_abs(a32) ) - 1;
   1ecae:	ea86 70e6 	eor.w	r0, r6, r6, asr #31
   1ecb2:	eba0 70e6 	sub.w	r0, r0, r6, asr #31
   1ecb6:	fab0 f080 	clz	r0, r0
   1ecba:	1e43      	subs	r3, r0, #1
   1ecbc:	301c      	adds	r0, #28
    a32_nrm = silk_LSHIFT(a32, a_headrm);                                       /* Q: a_headrm                  */
   1ecbe:	409e      	lsls	r6, r3
   1ecc0:	f1bc 0f00 	cmp.w	ip, #0
   1ecc4:	f000 8389 	beq.w	1f3da <silk_pitch_analysis_core+0x8f6>
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
   1ecc8:	ea8c 75ec 	eor.w	r5, ip, ip, asr #31
   1eccc:	eba5 75ec 	sub.w	r5, r5, ip, asr #31
   1ecd0:	fab5 f585 	clz	r5, r5
   1ecd4:	3d01      	subs	r5, #1
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                  */
   1ecd6:	fa0c f205 	lsl.w	r2, ip, r5
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1ecda:	1411      	asrs	r1, r2, #16
   1ecdc:	f06f 4460 	mvn.w	r4, #3758096384	; 0xe0000000
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1ece0:	b2b3      	uxth	r3, r6
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1ece2:	fb94 f1f1 	sdiv	r1, r4, r1
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1ece6:	1434      	asrs	r4, r6, #16
   1ece8:	b209      	sxth	r1, r1
   1ecea:	fb01 f303 	mul.w	r3, r1, r3
   1ecee:	fb01 f404 	mul.w	r4, r1, r4
   1ecf2:	eb04 4423 	add.w	r4, r4, r3, asr #16
    a32_nrm = silk_SUB32_ovflw(a32_nrm, silk_LSHIFT_ovflw( silk_SMMUL(b32_nrm, result), 3 ));  /* Q: a_headrm   */
   1ecf6:	fb82 2304 	smull	r2, r3, r2, r4
   1ecfa:	eba6 03c3 	sub.w	r3, r6, r3, lsl #3
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1ecfe:	b29a      	uxth	r2, r3
   1ed00:	141b      	asrs	r3, r3, #16
   1ed02:	fb01 f202 	mul.w	r2, r1, r2
   1ed06:	fb01 f303 	mul.w	r3, r1, r3
    lshift = 29 + a_headrm - b_headrm - Qres;
   1ed0a:	1b40      	subs	r0, r0, r5
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1ed0c:	eb03 4322 	add.w	r3, r3, r2, asr #16
    if( lshift < 0 ) {
   1ed10:	f1b0 020e 	subs.w	r2, r0, #14
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1ed14:	4423      	add	r3, r4
    if( lshift < 0 ) {
   1ed16:	f100 8365 	bmi.w	1f3e4 <silk_pitch_analysis_core+0x900>
        if( lshift < 32){
   1ed1a:	2a1f      	cmp	r2, #31
            return silk_RSHIFT(result, lshift);
   1ed1c:	bfda      	itte	le
   1ed1e:	4113      	asrle	r3, r2
   1ed20:	b21b      	sxthle	r3, r3
        if( lshift < 32){
   1ed22:	2300      	movgt	r3, #0

        matrix_ptr( C, k, 0, CSTRIDE_4KHZ ) =
   1ed24:	6e39      	ldr	r1, [r7, #96]	; 0x60
   1ed26:	f10a 0250 	add.w	r2, sl, #80	; 0x50
   1ed2a:	65fa      	str	r2, [r7, #92]	; 0x5c
   1ed2c:	4691      	mov	r9, r2
   1ed2e:	800b      	strh	r3, [r1, #0]
   1ed30:	f507 7e32 	add.w	lr, r7, #712	; 0x2c8
   1ed34:	4688      	mov	r8, r1
        return silk_LSHIFT_SAT32(result, -lshift);
   1ed36:	4662      	mov	r2, ip
   1ed38:	e041      	b.n	1edbe <silk_pitch_analysis_core+0x2da>
    a_headrm = silk_CLZ32( silk_abs(a32) ) - 1;
   1ed3a:	ea83 74e3 	eor.w	r4, r3, r3, asr #31
   1ed3e:	eba4 74e3 	sub.w	r4, r4, r3, asr #31
   1ed42:	fab4 f484 	clz	r4, r4
   1ed46:	f104 3cff 	add.w	ip, r4, #4294967295	; 0xffffffff
    a32_nrm = silk_LSHIFT(a32, a_headrm);                                       /* Q: a_headrm                  */
   1ed4a:	fa03 fc0c 	lsl.w	ip, r3, ip
   1ed4e:	341c      	adds	r4, #28
   1ed50:	2a00      	cmp	r2, #0
   1ed52:	d048      	beq.n	1ede6 <silk_pitch_analysis_core+0x302>
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
   1ed54:	ea82 76e2 	eor.w	r6, r2, r2, asr #31
   1ed58:	eba6 76e2 	sub.w	r6, r6, r2, asr #31
   1ed5c:	fab6 f686 	clz	r6, r6
   1ed60:	3e01      	subs	r6, #1
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                  */
   1ed62:	fa02 f006 	lsl.w	r0, r2, r6
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1ed66:	1403      	asrs	r3, r0, #16
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1ed68:	fa1f f18c 	uxth.w	r1, ip
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1ed6c:	f06f 4560 	mvn.w	r5, #3758096384	; 0xe0000000
   1ed70:	fb95 f3f3 	sdiv	r3, r5, r3
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1ed74:	ea4f 452c 	mov.w	r5, ip, asr #16
   1ed78:	b21b      	sxth	r3, r3
   1ed7a:	fb03 f101 	mul.w	r1, r3, r1
   1ed7e:	fb03 f505 	mul.w	r5, r3, r5
   1ed82:	eb05 4521 	add.w	r5, r5, r1, asr #16
    a32_nrm = silk_SUB32_ovflw(a32_nrm, silk_LSHIFT_ovflw( silk_SMMUL(b32_nrm, result), 3 ));  /* Q: a_headrm   */
   1ed86:	fb85 0100 	smull	r0, r1, r5, r0
   1ed8a:	ebac 0cc1 	sub.w	ip, ip, r1, lsl #3
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1ed8e:	fa1f f18c 	uxth.w	r1, ip
   1ed92:	ea4f 4c2c 	mov.w	ip, ip, asr #16
   1ed96:	fb03 f101 	mul.w	r1, r3, r1
    lshift = 29 + a_headrm - b_headrm - Qres;
   1ed9a:	1ba4      	subs	r4, r4, r6
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1ed9c:	fb03 f30c 	mul.w	r3, r3, ip
   1eda0:	eb03 4321 	add.w	r3, r3, r1, asr #16
    if( lshift < 0 ) {
   1eda4:	f1b4 010e 	subs.w	r1, r4, #14
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1eda8:	442b      	add	r3, r5
    if( lshift < 0 ) {
   1edaa:	d420      	bmi.n	1edee <silk_pitch_analysis_core+0x30a>
        if( lshift < 32){
   1edac:	291f      	cmp	r1, #31
            return silk_RSHIFT(result, lshift);
   1edae:	bfda      	itte	le
   1edb0:	410b      	asrle	r3, r1
   1edb2:	b21b      	sxthle	r3, r3
        if( lshift < 32){
   1edb4:	2300      	movgt	r3, #0
            (opus_int16)silk_DIV32_varQ( cross_corr, normalizer, 13 + 1 );                      /* Q13 */

        /* From now on normalizer is computed recursively */
        for( d = MIN_LAG_4KHZ + 1; d <= MAX_LAG_4KHZ; d++ ) {
   1edb6:	45f3      	cmp	fp, lr
            /* Add contribution of new sample and remove contribution from oldest sample */
            normalizer = silk_ADD32( normalizer,
                silk_SMULBB( basis_ptr[ 0 ], basis_ptr[ 0 ] ) -
                silk_SMULBB( basis_ptr[ SF_LENGTH_8KHZ ], basis_ptr[ SF_LENGTH_8KHZ ] ) );

            matrix_ptr( C, k, d - MIN_LAG_4KHZ, CSTRIDE_4KHZ) =
   1edb8:	f828 3f02 	strh.w	r3, [r8, #2]!
        for( d = MIN_LAG_4KHZ + 1; d <= MAX_LAG_4KHZ; d++ ) {
   1edbc:	d02c      	beq.n	1ee18 <silk_pitch_analysis_core+0x334>
            normalizer = silk_ADD32( normalizer,
   1edbe:	f93a 0d02 	ldrsh.w	r0, [sl, #-2]!
   1edc2:	f939 1d02 	ldrsh.w	r1, [r9, #-2]!
            cross_corr = xcorr32[ MAX_LAG_4KHZ - d ];
   1edc6:	f85e 3d04 	ldr.w	r3, [lr, #-4]!
            normalizer = silk_ADD32( normalizer,
   1edca:	fb00 f000 	mul.w	r0, r0, r0
   1edce:	fb01 0111 	mls	r1, r1, r1, r0
   1edd2:	440a      	add	r2, r1
   1edd4:	2b00      	cmp	r3, #0
   1edd6:	d1b0      	bne.n	1ed3a <silk_pitch_analysis_core+0x256>
   1edd8:	f04f 0c1f 	mov.w	ip, #31
   1eddc:	243c      	movs	r4, #60	; 0x3c
    a32_nrm = silk_LSHIFT(a32, a_headrm);                                       /* Q: a_headrm                  */
   1edde:	fa03 fc0c 	lsl.w	ip, r3, ip
   1ede2:	2a00      	cmp	r2, #0
   1ede4:	d1b6      	bne.n	1ed54 <silk_pitch_analysis_core+0x270>
   1ede6:	261f      	movs	r6, #31
   1ede8:	e7bb      	b.n	1ed62 <silk_pitch_analysis_core+0x27e>
        frame_4kHz[ i ] = silk_ADD_SAT16( frame_4kHz[ i ], frame_4kHz[ i - 1 ] );
   1edea:	460b      	mov	r3, r1
   1edec:	e6fe      	b.n	1ebec <silk_pitch_analysis_core+0x108>
        return silk_LSHIFT_SAT32(result, -lshift);
   1edee:	f1c4 040e 	rsb	r4, r4, #14
   1edf2:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
   1edf6:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   1edfa:	4121      	asrs	r1, r4
   1edfc:	4120      	asrs	r0, r4
   1edfe:	4288      	cmp	r0, r1
   1ee00:	f280 82df 	bge.w	1f3c2 <silk_pitch_analysis_core+0x8de>
   1ee04:	4299      	cmp	r1, r3
   1ee06:	f280 82e0 	bge.w	1f3ca <silk_pitch_analysis_core+0x8e6>
   1ee0a:	460b      	mov	r3, r1
   1ee0c:	40a3      	lsls	r3, r4
   1ee0e:	b21b      	sxth	r3, r3
        for( d = MIN_LAG_4KHZ + 1; d <= MAX_LAG_4KHZ; d++ ) {
   1ee10:	45f3      	cmp	fp, lr
            matrix_ptr( C, k, d - MIN_LAG_4KHZ, CSTRIDE_4KHZ) =
   1ee12:	f828 3f02 	strh.w	r3, [r8, #2]!
        for( d = MIN_LAG_4KHZ + 1; d <= MAX_LAG_4KHZ; d++ ) {
   1ee16:	d1d2      	bne.n	1edbe <silk_pitch_analysis_core+0x2da>
   1ee18:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   1ee1a:	3382      	adds	r3, #130	; 0x82
   1ee1c:	663b      	str	r3, [r7, #96]	; 0x60
    for( k = 0; k < nb_subfr >> 1; k++ ) {
   1ee1e:	e9d7 3a16 	ldrd	r3, sl, [r7, #88]	; 0x58
   1ee22:	459a      	cmp	sl, r3
   1ee24:	f47f af1c 	bne.w	1ec60 <silk_pitch_analysis_core+0x17c>
        /* Update target pointer */
        target_ptr += SF_LENGTH_8KHZ;
    }

    /* Combine two subframes into single correlation measure and apply short-lag bias */
    if( nb_subfr == PE_MAX_NB_SUBFR ) {
   1ee28:	f8d7 3418 	ldr.w	r3, [r7, #1048]	; 0x418
   1ee2c:	2b04      	cmp	r3, #4
   1ee2e:	f000 833f 	beq.w	1f4b0 <silk_pitch_analysis_core+0x9cc>
   1ee32:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   1ee34:	491f      	ldr	r1, [pc, #124]	; (1eeb4 <silk_pitch_analysis_core+0x3d0>)
   1ee36:	f103 0082 	add.w	r0, r3, #130	; 0x82
            C[ i - MIN_LAG_4KHZ ] = (opus_int16)sum;                                            /* Q14 */
        }
    } else {
        /* Only short-lag bias */
        for( i = MAX_LAG_4KHZ; i >= MIN_LAG_4KHZ; i-- ) {
            sum = silk_LSHIFT( (opus_int32)C[ i - MIN_LAG_4KHZ ], 1 );                          /* Q14 */
   1ee3a:	f930 3d02 	ldrsh.w	r3, [r0, #-2]!
   1ee3e:	005a      	lsls	r2, r3, #1
            sum = silk_SMLAWB( sum, sum, silk_LSHIFT( -i, 4 ) );                                /* Q14 */
   1ee40:	b294      	uxth	r4, r2
   1ee42:	1413      	asrs	r3, r2, #16
   1ee44:	fb01 f404 	mul.w	r4, r1, r4
   1ee48:	fb01 f303 	mul.w	r3, r1, r3
   1ee4c:	eb03 4324 	add.w	r3, r3, r4, asr #16
   1ee50:	3110      	adds	r1, #16
   1ee52:	4413      	add	r3, r2
        for( i = MAX_LAG_4KHZ; i >= MIN_LAG_4KHZ; i-- ) {
   1ee54:	f111 0f70 	cmn.w	r1, #112	; 0x70
            C[ i - MIN_LAG_4KHZ ] = (opus_int16)sum;                                            /* Q14 */
   1ee58:	8003      	strh	r3, [r0, #0]
        for( i = MAX_LAG_4KHZ; i >= MIN_LAG_4KHZ; i-- ) {
   1ee5a:	d1ee      	bne.n	1ee3a <silk_pitch_analysis_core+0x356>
        }
    }

    /* Sort */
    length_d_srch = silk_ADD_LSHIFT32( 4, complexity, 1 );
   1ee5c:	f8d7 3414 	ldr.w	r3, [r7, #1044]	; 0x414
    celt_assert( 3 * length_d_srch <= PE_D_SRCH_LENGTH );
    silk_insertion_sort_decreasing_int16( C, d_srch, CSTRIDE_4KHZ,
   1ee60:	6e7d      	ldr	r5, [r7, #100]	; 0x64
    length_d_srch = silk_ADD_LSHIFT32( 4, complexity, 1 );
   1ee62:	005c      	lsls	r4, r3, #1
   1ee64:	3404      	adds	r4, #4
    silk_insertion_sort_decreasing_int16( C, d_srch, CSTRIDE_4KHZ,
   1ee66:	4623      	mov	r3, r4
   1ee68:	2241      	movs	r2, #65	; 0x41
   1ee6a:	f507 71b4 	add.w	r1, r7, #360	; 0x168
   1ee6e:	4628      	mov	r0, r5
   1ee70:	f7fa ffb4 	bl	19ddc <silk_insertion_sort_decreasing_int16>
                                          length_d_srch );

    /* Escape if correlation is very low already here */
    Cmax = (opus_int)C[ 0 ];                                                    /* Q14 */
   1ee74:	f9b5 3000 	ldrsh.w	r3, [r5]
    if( Cmax < SILK_FIX_CONST( 0.2, 14 ) ) {
   1ee78:	f640 42cc 	movw	r2, #3276	; 0xccc
   1ee7c:	4293      	cmp	r3, r2
   1ee7e:	f340 82fc 	ble.w	1f47a <silk_pitch_analysis_core+0x996>
        *contourIndex = 0;
        RESTORE_STACK;
        return 1;
    }

    threshold = silk_SMULWB( search_thres1_Q16, Cmax );
   1ee82:	f8d7 2408 	ldr.w	r2, [r7, #1032]	; 0x408
   1ee86:	f8d7 1408 	ldr.w	r1, [r7, #1032]	; 0x408
   1ee8a:	b292      	uxth	r2, r2
   1ee8c:	1408      	asrs	r0, r1, #16
   1ee8e:	fb03 f202 	mul.w	r2, r3, r2
   1ee92:	fb03 f000 	mul.w	r0, r3, r0
    for( i = 0; i < length_d_srch; i++ ) {
   1ee96:	2c00      	cmp	r4, #0
    threshold = silk_SMULWB( search_thres1_Q16, Cmax );
   1ee98:	eb00 4022 	add.w	r0, r0, r2, asr #16
    for( i = 0; i < length_d_srch; i++ ) {
   1ee9c:	f340 870b 	ble.w	1fcb6 <silk_pitch_analysis_core+0x11d2>
        /* Convert to 8 kHz indices for the sorted correlation that exceeds the threshold */
        if( C[ i ] > threshold ) {
   1eea0:	4283      	cmp	r3, r0
   1eea2:	f340 8708 	ble.w	1fcb6 <silk_pitch_analysis_core+0x11d2>
   1eea6:	f507 72b2 	add.w	r2, r7, #356	; 0x164
   1eeaa:	6e79      	ldr	r1, [r7, #100]	; 0x64
    for( i = 0; i < length_d_srch; i++ ) {
   1eeac:	2500      	movs	r5, #0
   1eeae:	e008      	b.n	1eec2 <silk_pitch_analysis_core+0x3de>
   1eeb0:	ffff8000 	.word	0xffff8000
   1eeb4:	fffffb80 	.word	0xfffffb80
        if( C[ i ] > threshold ) {
   1eeb8:	f931 3f02 	ldrsh.w	r3, [r1, #2]!
   1eebc:	4283      	cmp	r3, r0
   1eebe:	f340 8549 	ble.w	1f954 <silk_pitch_analysis_core+0xe70>
            d_srch[ i ] = silk_LSHIFT( d_srch[ i ] + MIN_LAG_4KHZ, 1 );
   1eec2:	f852 3f04 	ldr.w	r3, [r2, #4]!
    for( i = 0; i < length_d_srch; i++ ) {
   1eec6:	3501      	adds	r5, #1
            d_srch[ i ] = silk_LSHIFT( d_srch[ i ] + MIN_LAG_4KHZ, 1 );
   1eec8:	3308      	adds	r3, #8
   1eeca:	005b      	lsls	r3, r3, #1
    for( i = 0; i < length_d_srch; i++ ) {
   1eecc:	42a5      	cmp	r5, r4
            d_srch[ i ] = silk_LSHIFT( d_srch[ i ] + MIN_LAG_4KHZ, 1 );
   1eece:	6013      	str	r3, [r2, #0]
    for( i = 0; i < length_d_srch; i++ ) {
   1eed0:	d1f2      	bne.n	1eeb8 <silk_pitch_analysis_core+0x3d4>
   1eed2:	f507 7333 	add.w	r3, r7, #716	; 0x2cc
   1eed6:	4618      	mov	r0, r3
   1eed8:	f44f 7286 	mov.w	r2, #268	; 0x10c
   1eedc:	2100      	movs	r1, #0
   1eede:	657b      	str	r3, [r7, #84]	; 0x54
   1eee0:	f016 f940 	bl	35164 <memset>
   1eee4:	f507 73b4 	add.w	r3, r7, #360	; 0x168
    ALLOC( d_comp, D_COMP_STRIDE, opus_int16 );
    for( i = D_COMP_MIN; i < D_COMP_MAX; i++ ) {
        d_comp[ i - D_COMP_MIN ] = 0;
    }
    for( i = 0; i < length_d_srch; i++ ) {
        d_comp[ d_srch[ i ] - D_COMP_MIN ] = 1;
   1eee8:	6d78      	ldr	r0, [r7, #84]	; 0x54
   1eeea:	eb03 0484 	add.w	r4, r3, r4, lsl #2
   1eeee:	461a      	mov	r2, r3
   1eef0:	2101      	movs	r1, #1
   1eef2:	f852 3b04 	ldr.w	r3, [r2], #4
   1eef6:	3b0d      	subs	r3, #13
    for( i = 0; i < length_d_srch; i++ ) {
   1eef8:	4294      	cmp	r4, r2
        d_comp[ d_srch[ i ] - D_COMP_MIN ] = 1;
   1eefa:	f820 1013 	strh.w	r1, [r0, r3, lsl #1]
    for( i = 0; i < length_d_srch; i++ ) {
   1eefe:	d1f8      	bne.n	1eef2 <silk_pitch_analysis_core+0x40e>
   1ef00:	6d7a      	ldr	r2, [r7, #84]	; 0x54
   1ef02:	f9b2 310a 	ldrsh.w	r3, [r2, #266]	; 0x10a
   1ef06:	f9b2 4108 	ldrsh.w	r4, [r2, #264]	; 0x108
   1ef0a:	4611      	mov	r1, r2
   1ef0c:	b29b      	uxth	r3, r3
    }

    /* Convolution */
    for( i = D_COMP_MAX - 1; i >= MIN_LAG_8KHZ; i-- ) {
   1ef0e:	2092      	movs	r0, #146	; 0x92
        d_comp[ i - D_COMP_MIN ] +=
            d_comp[ i - 1 - D_COMP_MIN ] + d_comp[ i - 2 - D_COMP_MIN ];
   1ef10:	f9b1 6106 	ldrsh.w	r6, [r1, #262]	; 0x106
   1ef14:	b2a2      	uxth	r2, r4
        d_comp[ i - D_COMP_MIN ] +=
   1ef16:	189d      	adds	r5, r3, r2
            d_comp[ i - 1 - D_COMP_MIN ] + d_comp[ i - 2 - D_COMP_MIN ];
   1ef18:	f9b1 4104 	ldrsh.w	r4, [r1, #260]	; 0x104
   1ef1c:	b2b3      	uxth	r3, r6
        d_comp[ i - D_COMP_MIN ] +=
   1ef1e:	441d      	add	r5, r3
   1ef20:	f8a1 510a 	strh.w	r5, [r1, #266]	; 0x10a
   1ef24:	4422      	add	r2, r4
   1ef26:	f1a0 0511 	sub.w	r5, r0, #17
   1ef2a:	3802      	subs	r0, #2
   1ef2c:	441a      	add	r2, r3
   1ef2e:	2810      	cmp	r0, #16
   1ef30:	f8a1 2108 	strh.w	r2, [r1, #264]	; 0x108
   1ef34:	f1a1 0104 	sub.w	r1, r1, #4
   1ef38:	d1ea      	bne.n	1ef10 <silk_pitch_analysis_core+0x42c>
   1ef3a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1ef3c:	f507 7034 	add.w	r0, r7, #720	; 0x2d0
   1ef40:	f103 0b04 	add.w	fp, r3, #4
   1ef44:	4604      	mov	r4, r0
   1ef46:	ebab 0545 	sub.w	r5, fp, r5, lsl #1
   1ef4a:	4622      	mov	r2, r4
   1ef4c:	f834 1d02 	ldrh.w	r1, [r4, #-2]!
   1ef50:	8813      	ldrh	r3, [r2, #0]
   1ef52:	8852      	ldrh	r2, [r2, #2]
   1ef54:	4413      	add	r3, r2
   1ef56:	440b      	add	r3, r1
    for( i = D_COMP_MAX - 1; i >= MIN_LAG_8KHZ; i-- ) {
   1ef58:	42a5      	cmp	r5, r4
        d_comp[ i - D_COMP_MIN ] +=
   1ef5a:	80a3      	strh	r3, [r4, #4]
    for( i = D_COMP_MAX - 1; i >= MIN_LAG_8KHZ; i-- ) {
   1ef5c:	d1f5      	bne.n	1ef4a <silk_pitch_analysis_core+0x466>
   1ef5e:	6d7a      	ldr	r2, [r7, #84]	; 0x54
   1ef60:	f207 23d2 	addw	r3, r7, #722	; 0x2d2
   1ef64:	f502 7483 	add.w	r4, r2, #262	; 0x106
    }

    length_d_srch = 0;
   1ef68:	f04f 0a00 	mov.w	sl, #0
    for( i = MIN_LAG_8KHZ; i < MAX_LAG_8KHZ + 1; i++ ) {
   1ef6c:	2210      	movs	r2, #16
        if( d_comp[ i + 1 - D_COMP_MIN ] > 0 ) {
   1ef6e:	f933 1f02 	ldrsh.w	r1, [r3, #2]!
   1ef72:	2900      	cmp	r1, #0
   1ef74:	dd05      	ble.n	1ef82 <silk_pitch_analysis_core+0x49e>
            d_srch[ length_d_srch ] = i;
   1ef76:	f507 71b4 	add.w	r1, r7, #360	; 0x168
   1ef7a:	f841 202a 	str.w	r2, [r1, sl, lsl #2]
            length_d_srch++;
   1ef7e:	f10a 0a01 	add.w	sl, sl, #1
    for( i = MIN_LAG_8KHZ; i < MAX_LAG_8KHZ + 1; i++ ) {
   1ef82:	429c      	cmp	r4, r3
   1ef84:	f102 0201 	add.w	r2, r2, #1
   1ef88:	d1f1      	bne.n	1ef6e <silk_pitch_analysis_core+0x48a>
   1ef8a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1ef8c:	f9b3 610a 	ldrsh.w	r6, [r3, #266]	; 0x10a
   1ef90:	f9b3 8108 	ldrsh.w	r8, [r3, #264]	; 0x108
   1ef94:	f9b3 e106 	ldrsh.w	lr, [r3, #262]	; 0x106
   1ef98:	461c      	mov	r4, r3
   1ef9a:	b2b6      	uxth	r6, r6
        }
    }

    /* Convolution */
    for( i = D_COMP_MAX - 1; i >= MIN_LAG_8KHZ; i-- ) {
   1ef9c:	f04f 0c92 	mov.w	ip, #146	; 0x92
        d_comp[ i - D_COMP_MIN ] += d_comp[ i - 1 - D_COMP_MIN ]
            + d_comp[ i - 2 - D_COMP_MIN ] + d_comp[ i - 3 - D_COMP_MIN ];
   1efa0:	fa1f f28e 	uxth.w	r2, lr
   1efa4:	eb02 0308 	add.w	r3, r2, r8
   1efa8:	f9b4 5104 	ldrsh.w	r5, [r4, #260]	; 0x104
   1efac:	f9b4 8102 	ldrsh.w	r8, [r4, #258]	; 0x102
   1efb0:	f9b4 e100 	ldrsh.w	lr, [r4, #256]	; 0x100
   1efb4:	b29b      	uxth	r3, r3
        d_comp[ i - D_COMP_MIN ] += d_comp[ i - 1 - D_COMP_MIN ]
   1efb6:	4631      	mov	r1, r6
   1efb8:	4419      	add	r1, r3
            + d_comp[ i - 2 - D_COMP_MIN ] + d_comp[ i - 3 - D_COMP_MIN ];
   1efba:	b2ae      	uxth	r6, r5
        d_comp[ i - D_COMP_MIN ] += d_comp[ i - 1 - D_COMP_MIN ]
   1efbc:	4431      	add	r1, r6
            + d_comp[ i - 2 - D_COMP_MIN ] + d_comp[ i - 3 - D_COMP_MIN ];
   1efbe:	fa1f f588 	uxth.w	r5, r8
        d_comp[ i - D_COMP_MIN ] += d_comp[ i - 1 - D_COMP_MIN ]
   1efc2:	4472      	add	r2, lr
   1efc4:	f8a4 110a 	strh.w	r1, [r4, #266]	; 0x10a
   1efc8:	4432      	add	r2, r6
   1efca:	442b      	add	r3, r5
   1efcc:	f1ac 0112 	sub.w	r1, ip, #18
   1efd0:	f1ac 0c03 	sub.w	ip, ip, #3
   1efd4:	4433      	add	r3, r6
   1efd6:	442a      	add	r2, r5
   1efd8:	f1bc 0f11 	cmp.w	ip, #17
   1efdc:	f8a4 3108 	strh.w	r3, [r4, #264]	; 0x108
   1efe0:	f8a4 2106 	strh.w	r2, [r4, #262]	; 0x106
   1efe4:	f1a4 0406 	sub.w	r4, r4, #6
   1efe8:	d1da      	bne.n	1efa0 <silk_pitch_analysis_core+0x4bc>
   1efea:	ebab 0241 	sub.w	r2, fp, r1, lsl #1
   1efee:	4606      	mov	r6, r0
   1eff0:	4631      	mov	r1, r6
   1eff2:	f836 4d02 	ldrh.w	r4, [r6, #-2]!
   1eff6:	888b      	ldrh	r3, [r1, #4]
   1eff8:	884d      	ldrh	r5, [r1, #2]
   1effa:	8809      	ldrh	r1, [r1, #0]
   1effc:	442b      	add	r3, r5
   1effe:	440b      	add	r3, r1
   1f000:	4423      	add	r3, r4
    for( i = D_COMP_MAX - 1; i >= MIN_LAG_8KHZ; i-- ) {
   1f002:	42b2      	cmp	r2, r6
        d_comp[ i - D_COMP_MIN ] += d_comp[ i - 1 - D_COMP_MIN ]
   1f004:	80f3      	strh	r3, [r6, #6]
    for( i = D_COMP_MAX - 1; i >= MIN_LAG_8KHZ; i-- ) {
   1f006:	d1f3      	bne.n	1eff0 <silk_pitch_analysis_core+0x50c>
   1f008:	6d7c      	ldr	r4, [r7, #84]	; 0x54
    }

    length_d_comp = 0;
   1f00a:	f04f 0900 	mov.w	r9, #0
   1f00e:	f504 7185 	add.w	r1, r4, #266	; 0x10a
    for( i = MIN_LAG_8KHZ; i < D_COMP_MAX; i++ ) {
   1f012:	2310      	movs	r3, #16
        if( d_comp[ i - D_COMP_MIN ] > 0 ) {
   1f014:	f930 2f02 	ldrsh.w	r2, [r0, #2]!
   1f018:	2a00      	cmp	r2, #0
   1f01a:	dd04      	ble.n	1f026 <silk_pitch_analysis_core+0x542>
            d_comp[ length_d_comp ] = i - 2;
   1f01c:	1e9a      	subs	r2, r3, #2
   1f01e:	f824 2019 	strh.w	r2, [r4, r9, lsl #1]
            length_d_comp++;
   1f022:	f109 0901 	add.w	r9, r9, #1
    for( i = MIN_LAG_8KHZ; i < D_COMP_MAX; i++ ) {
   1f026:	4281      	cmp	r1, r0
   1f028:	f103 0301 	add.w	r3, r3, #1
   1f02c:	d1f2      	bne.n	1f014 <silk_pitch_analysis_core+0x530>
    /*********************************************************************************
    * Find energy of each subframe projected onto its history, for a range of delays
    *********************************************************************************/
    silk_memset( C, 0, nb_subfr * CSTRIDE_8KHZ * sizeof( opus_int16 ) );

    target_ptr = &frame_8kHz[ PE_LTP_MEM_LENGTH_MS * 8 ];
   1f02e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    silk_memset( C, 0, nb_subfr * CSTRIDE_8KHZ * sizeof( opus_int16 ) );
   1f030:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   1f032:	6e78      	ldr	r0, [r7, #100]	; 0x64
   1f034:	2100      	movs	r1, #0
    target_ptr = &frame_8kHz[ PE_LTP_MEM_LENGTH_MS * 8 ];
   1f036:	f503 7ba0 	add.w	fp, r3, #320	; 0x140
    silk_memset( C, 0, nb_subfr * CSTRIDE_8KHZ * sizeof( opus_int16 ) );
   1f03a:	f016 f893 	bl	35164 <memset>
    for( k = 0; k < nb_subfr; k++ ) {
   1f03e:	f8d7 3418 	ldr.w	r3, [r7, #1048]	; 0x418
   1f042:	2b00      	cmp	r3, #0
   1f044:	f340 8088 	ble.w	1f158 <silk_pitch_analysis_core+0x674>
   1f048:	2300      	movs	r3, #0
   1f04a:	65bb      	str	r3, [r7, #88]	; 0x58
   1f04c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1f04e:	e9c7 a913 	strd	sl, r9, [r7, #76]	; 0x4c
   1f052:	eb03 0349 	add.w	r3, r3, r9, lsl #1
   1f056:	f8d7 941c 	ldr.w	r9, [r7, #1052]	; 0x41c
   1f05a:	663b      	str	r3, [r7, #96]	; 0x60

        /* Check that we are within range of the array */
        celt_assert( target_ptr >= frame_8kHz );
        celt_assert( target_ptr + SF_LENGTH_8KHZ <= frame_8kHz + frame_length_8kHz );

        energy_target = silk_ADD32( silk_inner_prod_aligned( target_ptr, target_ptr, SF_LENGTH_8KHZ, arch ), 1 );
   1f05c:	464b      	mov	r3, r9
   1f05e:	2228      	movs	r2, #40	; 0x28
   1f060:	4659      	mov	r1, fp
   1f062:	4658      	mov	r0, fp
   1f064:	f000 fe74 	bl	1fd50 <silk_inner_prod_aligned>
   1f068:	1c43      	adds	r3, r0, #1
   1f06a:	65fb      	str	r3, [r7, #92]	; 0x5c
        for( j = 0; j < length_d_comp; j++ ) {
   1f06c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   1f06e:	2b00      	cmp	r3, #0
   1f070:	d067      	beq.n	1f142 <silk_pitch_analysis_core+0x65e>
   1f072:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   1f074:	6d7e      	ldr	r6, [r7, #84]	; 0x54
   1f076:	eb03 1a43 	add.w	sl, r3, r3, lsl #5
   1f07a:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
   1f07e:	e007      	b.n	1f090 <silk_pitch_analysis_core+0x5ac>
                    (opus_int16)silk_DIV32_varQ( cross_corr,
                                                 silk_ADD32( energy_target,
                                                             energy_basis ),
                                                 13 + 1 );                                      /* Q13 */
            } else {
                matrix_ptr( C, k, d - ( MIN_LAG_8KHZ - 2 ), CSTRIDE_8KHZ ) = 0;
   1f080:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   1f082:	f04f 0200 	mov.w	r2, #0
   1f086:	f823 2014 	strh.w	r2, [r3, r4, lsl #1]
        for( j = 0; j < length_d_comp; j++ ) {
   1f08a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   1f08c:	42b3      	cmp	r3, r6
   1f08e:	d058      	beq.n	1f142 <silk_pitch_analysis_core+0x65e>
            d = d_comp[ j ];
   1f090:	f936 4b02 	ldrsh.w	r4, [r6], #2
            basis_ptr = target_ptr - d;
   1f094:	ebab 0544 	sub.w	r5, fp, r4, lsl #1
            cross_corr = silk_inner_prod_aligned( target_ptr, basis_ptr, SF_LENGTH_8KHZ, arch );
   1f098:	4629      	mov	r1, r5
   1f09a:	464b      	mov	r3, r9
   1f09c:	2228      	movs	r2, #40	; 0x28
   1f09e:	4658      	mov	r0, fp
   1f0a0:	f000 fe56 	bl	1fd50 <silk_inner_prod_aligned>
   1f0a4:	3c0e      	subs	r4, #14
            if( cross_corr > 0 ) {
   1f0a6:	f1b0 0800 	subs.w	r8, r0, #0
   1f0aa:	4454      	add	r4, sl
   1f0ac:	dde8      	ble.n	1f080 <silk_pitch_analysis_core+0x59c>
                energy_basis = silk_inner_prod_aligned( basis_ptr, basis_ptr, SF_LENGTH_8KHZ, arch );
   1f0ae:	464b      	mov	r3, r9
   1f0b0:	2228      	movs	r2, #40	; 0x28
   1f0b2:	4629      	mov	r1, r5
   1f0b4:	4628      	mov	r0, r5
   1f0b6:	f000 fe4b 	bl	1fd50 <silk_inner_prod_aligned>
   1f0ba:	fab8 f288 	clz	r2, r8
    a_headrm = silk_CLZ32( silk_abs(a32) ) - 1;
   1f0be:	1e53      	subs	r3, r2, #1
    a32_nrm = silk_LSHIFT(a32, a_headrm);                                       /* Q: a_headrm                  */
   1f0c0:	fa08 f803 	lsl.w	r8, r8, r3
   1f0c4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   1f0c6:	1818      	adds	r0, r3, r0
   1f0c8:	f000 81ad 	beq.w	1f426 <silk_pitch_analysis_core+0x942>
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
   1f0cc:	ea80 7ce0 	eor.w	ip, r0, r0, asr #31
   1f0d0:	ebac 7ce0 	sub.w	ip, ip, r0, asr #31
   1f0d4:	fabc fc8c 	clz	ip, ip
   1f0d8:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                  */
   1f0dc:	fa00 f00c 	lsl.w	r0, r0, ip
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1f0e0:	1403      	asrs	r3, r0, #16
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1f0e2:	fa1f f188 	uxth.w	r1, r8
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1f0e6:	f06f 4560 	mvn.w	r5, #3758096384	; 0xe0000000
   1f0ea:	fb95 f3f3 	sdiv	r3, r5, r3
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1f0ee:	ea4f 4528 	mov.w	r5, r8, asr #16
   1f0f2:	b21b      	sxth	r3, r3
   1f0f4:	fb03 f101 	mul.w	r1, r3, r1
   1f0f8:	fb03 f505 	mul.w	r5, r3, r5
   1f0fc:	eb05 4521 	add.w	r5, r5, r1, asr #16
    a32_nrm = silk_SUB32_ovflw(a32_nrm, silk_LSHIFT_ovflw( silk_SMMUL(b32_nrm, result), 3 ));  /* Q: a_headrm   */
   1f100:	fb80 0105 	smull	r0, r1, r0, r5
   1f104:	eba8 08c1 	sub.w	r8, r8, r1, lsl #3
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1f108:	fa1f f188 	uxth.w	r1, r8
    lshift = 29 + a_headrm - b_headrm - Qres;
   1f10c:	321c      	adds	r2, #28
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1f10e:	ea4f 4828 	mov.w	r8, r8, asr #16
   1f112:	fb03 f101 	mul.w	r1, r3, r1
    lshift = 29 + a_headrm - b_headrm - Qres;
   1f116:	eba2 020c 	sub.w	r2, r2, ip
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1f11a:	fb03 f308 	mul.w	r3, r3, r8
   1f11e:	eb03 4321 	add.w	r3, r3, r1, asr #16
    if( lshift < 0 ) {
   1f122:	f1b2 010e 	subs.w	r1, r2, #14
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1f126:	442b      	add	r3, r5
    if( lshift < 0 ) {
   1f128:	f100 8180 	bmi.w	1f42c <silk_pitch_analysis_core+0x948>
        if( lshift < 32){
   1f12c:	291f      	cmp	r1, #31
            return silk_RSHIFT(result, lshift);
   1f12e:	bfda      	itte	le
   1f130:	410b      	asrle	r3, r1
   1f132:	b21b      	sxthle	r3, r3
        if( lshift < 32){
   1f134:	2300      	movgt	r3, #0
                matrix_ptr( C, k, d - ( MIN_LAG_8KHZ - 2 ), CSTRIDE_8KHZ ) =
   1f136:	6e7a      	ldr	r2, [r7, #100]	; 0x64
   1f138:	f822 3014 	strh.w	r3, [r2, r4, lsl #1]
        for( j = 0; j < length_d_comp; j++ ) {
   1f13c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   1f13e:	42b3      	cmp	r3, r6
   1f140:	d1a6      	bne.n	1f090 <silk_pitch_analysis_core+0x5ac>
    for( k = 0; k < nb_subfr; k++ ) {
   1f142:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   1f144:	f8d7 2418 	ldr.w	r2, [r7, #1048]	; 0x418
   1f148:	3301      	adds	r3, #1
   1f14a:	429a      	cmp	r2, r3
   1f14c:	65bb      	str	r3, [r7, #88]	; 0x58
            }
        }
        target_ptr += SF_LENGTH_8KHZ;
   1f14e:	f10b 0b50 	add.w	fp, fp, #80	; 0x50
    for( k = 0; k < nb_subfr; k++ ) {
   1f152:	d183      	bne.n	1f05c <silk_pitch_analysis_core+0x578>
   1f154:	f8d7 a04c 	ldr.w	sl, [r7, #76]	; 0x4c
    CCmax_b = silk_int32_MIN;

    CBimax = 0; /* To avoid returning undefined lag values */
    lag = -1;   /* To check if lag with strong enough correlation has been found */

    if( prevLag > 0 ) {
   1f158:	f8d7 3404 	ldr.w	r3, [r7, #1028]	; 0x404
   1f15c:	2b00      	cmp	r3, #0
   1f15e:	f340 8410 	ble.w	1f982 <silk_pitch_analysis_core+0xe9e>
        if( Fs_kHz == 12 ) {
   1f162:	f8d7 3410 	ldr.w	r3, [r7, #1040]	; 0x410
   1f166:	2b0c      	cmp	r3, #12
   1f168:	f000 84f6 	beq.w	1fb58 <silk_pitch_analysis_core+0x1074>
            prevLag = silk_DIV32_16( silk_LSHIFT( prevLag, 1 ), 3 );
        } else if( Fs_kHz == 16 ) {
   1f16c:	2b10      	cmp	r3, #16
   1f16e:	d104      	bne.n	1f17a <silk_pitch_analysis_core+0x696>
            prevLag = silk_RSHIFT( prevLag, 1 );
   1f170:	f8d7 3404 	ldr.w	r3, [r7, #1028]	; 0x404
   1f174:	105b      	asrs	r3, r3, #1
   1f176:	f8c7 3404 	str.w	r3, [r7, #1028]	; 0x404
        }
        prevLag_log2_Q7 = silk_lin2log( (opus_int32)prevLag );
   1f17a:	f8d7 0404 	ldr.w	r0, [r7, #1028]	; 0x404
   1f17e:	f7f8 fc1b 	bl	179b8 <silk_lin2log>
   1f182:	63f8      	str	r0, [r7, #60]	; 0x3c
    } else {
        prevLag_log2_Q7 = 0;
    }
    silk_assert( search_thres2_Q13 == silk_SAT16( search_thres2_Q13 ) );
    /* Set up stage 2 codebook based on number of subframes */
    if( nb_subfr == PE_MAX_NB_SUBFR ) {
   1f184:	f8d7 3418 	ldr.w	r3, [r7, #1048]	; 0x418
   1f188:	2b04      	cmp	r3, #4
   1f18a:	f000 83ef 	beq.w	1f96c <silk_pitch_analysis_core+0xe88>
            nb_cbk_search = PE_NB_CBKS_STAGE2_EXT;
        } else {
            nb_cbk_search = PE_NB_CBKS_STAGE2;
        }
    } else {
        cbk_size       = PE_NB_CBKS_STAGE2_10MS;
   1f18e:	2503      	movs	r5, #3
        Lag_CB_ptr     = &silk_CB_lags_stage2_10_ms[ 0 ][ 0 ];
   1f190:	4bc5      	ldr	r3, [pc, #788]	; (1f4a8 <silk_pitch_analysis_core+0x9c4>)
        nb_cbk_search  = PE_NB_CBKS_STAGE2_10MS;
   1f192:	657d      	str	r5, [r7, #84]	; 0x54
        Lag_CB_ptr     = &silk_CB_lags_stage2_10_ms[ 0 ][ 0 ];
   1f194:	65bb      	str	r3, [r7, #88]	; 0x58
    }

    for( k = 0; k < length_d_srch; k++ ) {
   1f196:	f1ba 0f00 	cmp.w	sl, #0
   1f19a:	f000 816e 	beq.w	1f47a <silk_pitch_analysis_core+0x996>

        /* Bias towards shorter lags */
        lag_log2_Q7 = silk_lin2log( d ); /* Q7 */
        silk_assert( lag_log2_Q7 == silk_SAT16( lag_log2_Q7 ) );
        silk_assert( nb_subfr * SILK_FIX_CONST( PE_SHORTLAG_BIAS, 13 ) == silk_SAT16( nb_subfr * SILK_FIX_CONST( PE_SHORTLAG_BIAS, 13 ) ) );
        CCmax_new_b = CCmax_new - silk_RSHIFT( silk_SMULBB( nb_subfr * SILK_FIX_CONST( PE_SHORTLAG_BIAS, 13 ), lag_log2_Q7 ), 7 ); /* Q13 */
   1f19e:	f8d7 3418 	ldr.w	r3, [r7, #1048]	; 0x418
   1f1a2:	f8d7 2418 	ldr.w	r2, [r7, #1048]	; 0x418
   1f1a6:	f8d7 1418 	ldr.w	r1, [r7, #1048]	; 0x418
   1f1aa:	005b      	lsls	r3, r3, #1
   1f1ac:	61bb      	str	r3, [r7, #24]
   1f1ae:	18d3      	adds	r3, r2, r3
   1f1b0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   1f1b4:	6cba      	ldr	r2, [r7, #72]	; 0x48
   1f1b6:	ebc3 1383 	rsb	r3, r3, r3, lsl #6
   1f1ba:	440a      	add	r2, r1
   1f1bc:	005b      	lsls	r3, r3, #1
   1f1be:	4616      	mov	r6, r2
   1f1c0:	b21b      	sxth	r3, r3
    CCmax_b = silk_int32_MIN;
   1f1c2:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   1f1c6:	653a      	str	r2, [r7, #80]	; 0x50
        CCmax_new_b = CCmax_new - silk_RSHIFT( silk_SMULBB( nb_subfr * SILK_FIX_CONST( PE_SHORTLAG_BIAS, 13 ), lag_log2_Q7 ), 7 ); /* Q13 */
   1f1c8:	65fb      	str	r3, [r7, #92]	; 0x5c
    CCmax   = silk_int32_MIN;
   1f1ca:	62fa      	str	r2, [r7, #44]	; 0x2c
            prev_lag_bias_Q13 = silk_DIV32( silk_MUL( prev_lag_bias_Q13, delta_lag_log2_sqr_Q7 ), delta_lag_log2_sqr_Q7 + SILK_FIX_CONST( 0.5, 7 ) );
            CCmax_new_b -= prev_lag_bias_Q13; /* Q13 */
        }

        if( CCmax_new_b > CCmax_b                                   &&  /* Find maximum biased correlation                  */
            CCmax_new > silk_SMULBB( nb_subfr, search_thres2_Q13 )  &&  /* Correlation needs to be high enough to be voiced */
   1f1cc:	f8d7 3418 	ldr.w	r3, [r7, #1048]	; 0x418
   1f1d0:	f8d7 240c 	ldr.w	r2, [r7, #1036]	; 0x40c
   1f1d4:	fb13 f302 	smulbb	r3, r3, r2
   1f1d8:	63bb      	str	r3, [r7, #56]	; 0x38
    lag = -1;   /* To check if lag with strong enough correlation has been found */
   1f1da:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1f1de:	64bb      	str	r3, [r7, #72]	; 0x48
   1f1e0:	e9d7 3215 	ldrd	r3, r2, [r7, #84]	; 0x54
   1f1e4:	f507 7bb4 	add.w	fp, r7, #360	; 0x168
    CBimax = 0; /* To avoid returning undefined lag values */
   1f1e8:	2100      	movs	r1, #0
   1f1ea:	eb0b 008a 	add.w	r0, fp, sl, lsl #2
   1f1ee:	6339      	str	r1, [r7, #48]	; 0x30
   1f1f0:	f8d7 a064 	ldr.w	sl, [r7, #100]	; 0x64
   1f1f4:	64f8      	str	r0, [r7, #76]	; 0x4c
   1f1f6:	00b6      	lsls	r6, r6, #2
            CC[ j ] = 0;
   1f1f8:	4689      	mov	r9, r1
   1f1fa:	eb03 0802 	add.w	r8, r3, r2
   1f1fe:	f8c7 b064 	str.w	fp, [r7, #100]	; 0x64
        d = d_srch[ k ];
   1f202:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   1f204:	f8d7 e058 	ldr.w	lr, [r7, #88]	; 0x58
   1f208:	f853 4b04 	ldr.w	r4, [r3], #4
   1f20c:	667b      	str	r3, [r7, #100]	; 0x64
   1f20e:	f107 0b88 	add.w	fp, r7, #136	; 0x88
            for( i = 0; i < nb_subfr; i++ ) {
   1f212:	f8d7 3418 	ldr.w	r3, [r7, #1048]	; 0x418
            CC[ j ] = 0;
   1f216:	f84b 9f04 	str.w	r9, [fp, #4]!
            for( i = 0; i < nb_subfr; i++ ) {
   1f21a:	2b00      	cmp	r3, #0
   1f21c:	dd10      	ble.n	1f240 <silk_pitch_analysis_core+0x75c>
   1f21e:	2100      	movs	r1, #0
   1f220:	468c      	mov	ip, r1
   1f222:	4670      	mov	r0, lr
                d_subfr = d + matrix_ptr( Lag_CB_ptr, i, j, cbk_size );
   1f224:	f990 2000 	ldrsb.w	r2, [r0]
                    + (opus_int32)matrix_ptr( C, i,
   1f228:	1863      	adds	r3, r4, r1
   1f22a:	4413      	add	r3, r2
   1f22c:	3b0e      	subs	r3, #14
   1f22e:	3184      	adds	r1, #132	; 0x84
   1f230:	f93a 3013 	ldrsh.w	r3, [sl, r3, lsl #1]
            for( i = 0; i < nb_subfr; i++ ) {
   1f234:	428e      	cmp	r6, r1
   1f236:	4428      	add	r0, r5
                    + (opus_int32)matrix_ptr( C, i,
   1f238:	449c      	add	ip, r3
            for( i = 0; i < nb_subfr; i++ ) {
   1f23a:	d1f3      	bne.n	1f224 <silk_pitch_analysis_core+0x740>
   1f23c:	f8cb c000 	str.w	ip, [fp]
   1f240:	f10e 0e01 	add.w	lr, lr, #1
        for( j = 0; j < nb_cbk_search; j++ ) {
   1f244:	45f0      	cmp	r8, lr
   1f246:	d1e4      	bne.n	1f212 <silk_pitch_analysis_core+0x72e>
            if( CC[ i ] > CCmax_new ) {
   1f248:	e9d7 3223 	ldrd	r3, r2, [r7, #140]	; 0x8c
   1f24c:	4293      	cmp	r3, r2
   1f24e:	f2c0 8101 	blt.w	1f454 <silk_pitch_analysis_core+0x970>
   1f252:	f8d7 b094 	ldr.w	fp, [r7, #148]	; 0x94
   1f256:	461a      	mov	r2, r3
   1f258:	4593      	cmp	fp, r2
   1f25a:	f04f 0300 	mov.w	r3, #0
   1f25e:	f340 8100 	ble.w	1f462 <silk_pitch_analysis_core+0x97e>
        for( i = 0; i < nb_cbk_search; i++ ) {
   1f262:	2302      	movs	r3, #2
   1f264:	6d7a      	ldr	r2, [r7, #84]	; 0x54
   1f266:	2a03      	cmp	r2, #3
   1f268:	d039      	beq.n	1f2de <silk_pitch_analysis_core+0x7fa>
            if( CC[ i ] > CCmax_new ) {
   1f26a:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
   1f26e:	f8d7 109c 	ldr.w	r1, [r7, #156]	; 0x9c
   1f272:	4593      	cmp	fp, r2
   1f274:	bfac      	ite	ge
   1f276:	465a      	movge	r2, fp
        for( i = 0; i < nb_cbk_search; i++ ) {
   1f278:	2303      	movlt	r3, #3
            if( CC[ i ] > CCmax_new ) {
   1f27a:	428a      	cmp	r2, r1
   1f27c:	bfa8      	it	ge
   1f27e:	4611      	movge	r1, r2
   1f280:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
        for( i = 0; i < nb_cbk_search; i++ ) {
   1f284:	bfb8      	it	lt
   1f286:	2304      	movlt	r3, #4
            if( CC[ i ] > CCmax_new ) {
   1f288:	4291      	cmp	r1, r2
   1f28a:	bfa8      	it	ge
   1f28c:	460a      	movge	r2, r1
   1f28e:	f8d7 10a4 	ldr.w	r1, [r7, #164]	; 0xa4
        for( i = 0; i < nb_cbk_search; i++ ) {
   1f292:	bfb8      	it	lt
   1f294:	2305      	movlt	r3, #5
            if( CC[ i ] > CCmax_new ) {
   1f296:	428a      	cmp	r2, r1
   1f298:	bfa8      	it	ge
   1f29a:	4611      	movge	r1, r2
   1f29c:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
        for( i = 0; i < nb_cbk_search; i++ ) {
   1f2a0:	bfb8      	it	lt
   1f2a2:	2306      	movlt	r3, #6
            if( CC[ i ] > CCmax_new ) {
   1f2a4:	4291      	cmp	r1, r2
   1f2a6:	bfa8      	it	ge
   1f2a8:	460a      	movge	r2, r1
   1f2aa:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
        for( i = 0; i < nb_cbk_search; i++ ) {
   1f2ae:	bfb8      	it	lt
   1f2b0:	2307      	movlt	r3, #7
            if( CC[ i ] > CCmax_new ) {
   1f2b2:	428a      	cmp	r2, r1
   1f2b4:	bfa8      	it	ge
   1f2b6:	4611      	movge	r1, r2
   1f2b8:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
        for( i = 0; i < nb_cbk_search; i++ ) {
   1f2bc:	bfb8      	it	lt
   1f2be:	2308      	movlt	r3, #8
            if( CC[ i ] > CCmax_new ) {
   1f2c0:	4291      	cmp	r1, r2
   1f2c2:	bfa8      	it	ge
   1f2c4:	460a      	movge	r2, r1
        for( i = 0; i < nb_cbk_search; i++ ) {
   1f2c6:	6d79      	ldr	r1, [r7, #84]	; 0x54
   1f2c8:	bfb8      	it	lt
   1f2ca:	2309      	movlt	r3, #9
   1f2cc:	290b      	cmp	r1, #11
   1f2ce:	f040 80d2 	bne.w	1f476 <silk_pitch_analysis_core+0x992>
            if( CC[ i ] > CCmax_new ) {
   1f2d2:	f8d7 b0b4 	ldr.w	fp, [r7, #180]	; 0xb4
   1f2d6:	455a      	cmp	r2, fp
   1f2d8:	f280 80cd 	bge.w	1f476 <silk_pitch_analysis_core+0x992>
        for( i = 0; i < nb_cbk_search; i++ ) {
   1f2dc:	230a      	movs	r3, #10
        lag_log2_Q7 = silk_lin2log( d ); /* Q7 */
   1f2de:	4620      	mov	r0, r4
   1f2e0:	663b      	str	r3, [r7, #96]	; 0x60
   1f2e2:	f7f8 fb69 	bl	179b8 <silk_lin2log>
        CCmax_new_b = CCmax_new - silk_RSHIFT( silk_SMULBB( nb_subfr * SILK_FIX_CONST( PE_SHORTLAG_BIAS, 13 ), lag_log2_Q7 ), 7 ); /* Q13 */
   1f2e6:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
        if( prevLag > 0 ) {
   1f2e8:	f8d7 2404 	ldr.w	r2, [r7, #1028]	; 0x404
        CCmax_new_b = CCmax_new - silk_RSHIFT( silk_SMULBB( nb_subfr * SILK_FIX_CONST( PE_SHORTLAG_BIAS, 13 ), lag_log2_Q7 ), 7 ); /* Q13 */
   1f2ec:	fb10 fc03 	smulbb	ip, r0, r3
        if( prevLag > 0 ) {
   1f2f0:	2a00      	cmp	r2, #0
        CCmax_new_b = CCmax_new - silk_RSHIFT( silk_SMULBB( nb_subfr * SILK_FIX_CONST( PE_SHORTLAG_BIAS, 13 ), lag_log2_Q7 ), 7 ); /* Q13 */
   1f2f2:	ebab 1cec 	sub.w	ip, fp, ip, asr #7
        if( prevLag > 0 ) {
   1f2f6:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   1f2f8:	dd12      	ble.n	1f320 <silk_pitch_analysis_core+0x83c>
            prev_lag_bias_Q13 = silk_RSHIFT( silk_SMULBB( nb_subfr * SILK_FIX_CONST( PE_PREVLAG_BIAS, 13 ), *LTPCorr_Q15 ), 15 ); /* Q13 */
   1f2fa:	f8d7 2400 	ldr.w	r2, [r7, #1024]	; 0x400
            delta_lag_log2_sqr_Q7 = lag_log2_Q7 - prevLag_log2_Q7;
   1f2fe:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
            prev_lag_bias_Q13 = silk_RSHIFT( silk_SMULBB( nb_subfr * SILK_FIX_CONST( PE_PREVLAG_BIAS, 13 ), *LTPCorr_Q15 ), 15 ); /* Q13 */
   1f300:	6812      	ldr	r2, [r2, #0]
            delta_lag_log2_sqr_Q7 = lag_log2_Q7 - prevLag_log2_Q7;
   1f302:	1a41      	subs	r1, r0, r1
            prev_lag_bias_Q13 = silk_RSHIFT( silk_SMULBB( nb_subfr * SILK_FIX_CONST( PE_PREVLAG_BIAS, 13 ), *LTPCorr_Q15 ), 15 ); /* Q13 */
   1f304:	6df8      	ldr	r0, [r7, #92]	; 0x5c
            delta_lag_log2_sqr_Q7 = silk_RSHIFT( silk_SMULBB( delta_lag_log2_sqr_Q7, delta_lag_log2_sqr_Q7 ), 7 );
   1f306:	fb11 f101 	smulbb	r1, r1, r1
            prev_lag_bias_Q13 = silk_RSHIFT( silk_SMULBB( nb_subfr * SILK_FIX_CONST( PE_PREVLAG_BIAS, 13 ), *LTPCorr_Q15 ), 15 ); /* Q13 */
   1f30a:	fb12 f200 	smulbb	r2, r2, r0
            delta_lag_log2_sqr_Q7 = silk_RSHIFT( silk_SMULBB( delta_lag_log2_sqr_Q7, delta_lag_log2_sqr_Q7 ), 7 );
   1f30e:	11c9      	asrs	r1, r1, #7
            prev_lag_bias_Q13 = silk_RSHIFT( silk_SMULBB( nb_subfr * SILK_FIX_CONST( PE_PREVLAG_BIAS, 13 ), *LTPCorr_Q15 ), 15 ); /* Q13 */
   1f310:	13d2      	asrs	r2, r2, #15
            prev_lag_bias_Q13 = silk_DIV32( silk_MUL( prev_lag_bias_Q13, delta_lag_log2_sqr_Q7 ), delta_lag_log2_sqr_Q7 + SILK_FIX_CONST( 0.5, 7 ) );
   1f312:	fb01 f202 	mul.w	r2, r1, r2
   1f316:	3140      	adds	r1, #64	; 0x40
   1f318:	fb92 f1f1 	sdiv	r1, r2, r1
            CCmax_new_b -= prev_lag_bias_Q13; /* Q13 */
   1f31c:	ebac 0c01 	sub.w	ip, ip, r1
        if( CCmax_new_b > CCmax_b                                   &&  /* Find maximum biased correlation                  */
   1f320:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   1f322:	4594      	cmp	ip, r2
   1f324:	dd0c      	ble.n	1f340 <silk_pitch_analysis_core+0x85c>
   1f326:	6bba      	ldr	r2, [r7, #56]	; 0x38
   1f328:	455a      	cmp	r2, fp
   1f32a:	da09      	bge.n	1f340 <silk_pitch_analysis_core+0x85c>
            CCmax_new > silk_SMULBB( nb_subfr, search_thres2_Q13 )  &&  /* Correlation needs to be high enough to be voiced */
   1f32c:	4a5f      	ldr	r2, [pc, #380]	; (1f4ac <silk_pitch_analysis_core+0x9c8>)
   1f32e:	56d2      	ldrsb	r2, [r2, r3]
   1f330:	2a10      	cmp	r2, #16
   1f332:	dc05      	bgt.n	1f340 <silk_pitch_analysis_core+0x85c>
   1f334:	f8c7 c050 	str.w	ip, [r7, #80]	; 0x50
   1f338:	f8c7 b02c 	str.w	fp, [r7, #44]	; 0x2c
            silk_CB_lags_stage2[ 0 ][ CBimax_new ] <= MIN_LAG_8KHZ      /* Lag must be in range                             */
         ) {
            CCmax_b = CCmax_new_b;
            CCmax   = CCmax_new;
            lag     = d;
   1f33c:	64bc      	str	r4, [r7, #72]	; 0x48
   1f33e:	633b      	str	r3, [r7, #48]	; 0x30
    for( k = 0; k < length_d_srch; k++ ) {
   1f340:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   1f342:	6e7a      	ldr	r2, [r7, #100]	; 0x64
   1f344:	4293      	cmp	r3, r2
   1f346:	f47f af5c 	bne.w	1f202 <silk_pitch_analysis_core+0x71e>
            CBimax  = CBimax_new;
        }
    }

    if( lag == -1 ) {
   1f34a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   1f34c:	3301      	adds	r3, #1
   1f34e:	f000 8094 	beq.w	1f47a <silk_pitch_analysis_core+0x996>
        RESTORE_STACK;
        return 1;
    }

    /* Output normalized correlation */
    *LTPCorr_Q15 = (opus_int)silk_LSHIFT( silk_DIV32_16( CCmax, nb_subfr ), 2 );
   1f352:	f8d7 2418 	ldr.w	r2, [r7, #1048]	; 0x418
   1f356:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1f358:	fb93 f3f2 	sdiv	r3, r3, r2
   1f35c:	f8d7 2400 	ldr.w	r2, [r7, #1024]	; 0x400
   1f360:	009b      	lsls	r3, r3, #2
   1f362:	6013      	str	r3, [r2, #0]
    silk_assert( *LTPCorr_Q15 >= 0 );

    if( Fs_kHz > 8 ) {
   1f364:	f8d7 3410 	ldr.w	r3, [r7, #1040]	; 0x410
   1f368:	2b08      	cmp	r3, #8
   1f36a:	f300 80bd 	bgt.w	1f4e8 <silk_pitch_analysis_core+0xa04>
        }
        *lagIndex = (opus_int16)( lag_new - min_lag);
        *contourIndex = (opus_int8)CBimax;
    } else {        /* Fs_kHz == 8 */
        /* Save Lags */
        for( k = 0; k < nb_subfr; k++ ) {
   1f36e:	f8d7 3418 	ldr.w	r3, [r7, #1048]	; 0x418
   1f372:	2b00      	cmp	r3, #0
   1f374:	dd17      	ble.n	1f3a6 <silk_pitch_analysis_core+0x8c2>
   1f376:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   1f378:	6b3c      	ldr	r4, [r7, #48]	; 0x30
   1f37a:	1f19      	subs	r1, r3, #4
   1f37c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1f37e:	440b      	add	r3, r1
   1f380:	4618      	mov	r0, r3
   1f382:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   1f384:	4423      	add	r3, r4
   1f386:	6cbc      	ldr	r4, [r7, #72]	; 0x48
   1f388:	461a      	mov	r2, r3
            pitch_out[ k ] = lag + matrix_ptr( Lag_CB_ptr, k, CBimax, cbk_size );
   1f38a:	f992 3000 	ldrsb.w	r3, [r2]
   1f38e:	4423      	add	r3, r4
            pitch_out[ k ] = silk_LIMIT( pitch_out[ k ], MIN_LAG_8KHZ, PE_MAX_LAG_MS * 8 );
   1f390:	2b10      	cmp	r3, #16
   1f392:	bfb8      	it	lt
   1f394:	2310      	movlt	r3, #16
   1f396:	2b90      	cmp	r3, #144	; 0x90
   1f398:	bfa8      	it	ge
   1f39a:	2390      	movge	r3, #144	; 0x90
   1f39c:	f841 3f04 	str.w	r3, [r1, #4]!
        for( k = 0; k < nb_subfr; k++ ) {
   1f3a0:	4288      	cmp	r0, r1
   1f3a2:	442a      	add	r2, r5
   1f3a4:	d1f1      	bne.n	1f38a <silk_pitch_analysis_core+0x8a6>
        }
        *lagIndex = (opus_int16)( lag - MIN_LAG_8KHZ );
   1f3a6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   1f3a8:	6a3a      	ldr	r2, [r7, #32]
   1f3aa:	3b10      	subs	r3, #16
   1f3ac:	8013      	strh	r3, [r2, #0]
        *contourIndex = (opus_int8)CBimax;
   1f3ae:	69fb      	ldr	r3, [r7, #28]
   1f3b0:	461a      	mov	r2, r3
   1f3b2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   1f3b4:	7013      	strb	r3, [r2, #0]
    }
    celt_assert( *lagIndex >= 0 );
    /* return as voiced */
    RESTORE_STACK;
    return 0;
   1f3b6:	2000      	movs	r0, #0
}
   1f3b8:	f507 7777 	add.w	r7, r7, #988	; 0x3dc
   1f3bc:	46bd      	mov	sp, r7
   1f3be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return silk_LSHIFT_SAT32(result, -lshift);
   1f3c2:	4298      	cmp	r0, r3
   1f3c4:	da05      	bge.n	1f3d2 <silk_pitch_analysis_core+0x8ee>
   1f3c6:	4603      	mov	r3, r0
   1f3c8:	e520      	b.n	1ee0c <silk_pitch_analysis_core+0x328>
   1f3ca:	4283      	cmp	r3, r0
   1f3cc:	bfb8      	it	lt
   1f3ce:	4603      	movlt	r3, r0
   1f3d0:	e51c      	b.n	1ee0c <silk_pitch_analysis_core+0x328>
   1f3d2:	428b      	cmp	r3, r1
   1f3d4:	bfb8      	it	lt
   1f3d6:	460b      	movlt	r3, r1
   1f3d8:	e518      	b.n	1ee0c <silk_pitch_analysis_core+0x328>
   1f3da:	251f      	movs	r5, #31
   1f3dc:	e47b      	b.n	1ecd6 <silk_pitch_analysis_core+0x1f2>
   1f3de:	203c      	movs	r0, #60	; 0x3c
   1f3e0:	231f      	movs	r3, #31
   1f3e2:	e46c      	b.n	1ecbe <silk_pitch_analysis_core+0x1da>
   1f3e4:	f1c0 000e 	rsb	r0, r0, #14
   1f3e8:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   1f3ec:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
   1f3f0:	4102      	asrs	r2, r0
   1f3f2:	4101      	asrs	r1, r0
   1f3f4:	428a      	cmp	r2, r1
   1f3f6:	dd06      	ble.n	1f406 <silk_pitch_analysis_core+0x922>
   1f3f8:	4293      	cmp	r3, r2
   1f3fa:	dd0c      	ble.n	1f416 <silk_pitch_analysis_core+0x932>
   1f3fc:	4613      	mov	r3, r2
   1f3fe:	fa03 f000 	lsl.w	r0, r3, r0
   1f402:	b203      	sxth	r3, r0
   1f404:	e48e      	b.n	1ed24 <silk_pitch_analysis_core+0x240>
   1f406:	428b      	cmp	r3, r1
   1f408:	dd09      	ble.n	1f41e <silk_pitch_analysis_core+0x93a>
   1f40a:	460b      	mov	r3, r1
   1f40c:	e7f7      	b.n	1f3fe <silk_pitch_analysis_core+0x91a>
   1f40e:	f06f 031c 	mvn.w	r3, #28
   1f412:	f7ff bb92 	b.w	1eb3a <silk_pitch_analysis_core+0x56>
   1f416:	428b      	cmp	r3, r1
   1f418:	bfb8      	it	lt
   1f41a:	460b      	movlt	r3, r1
   1f41c:	e7ef      	b.n	1f3fe <silk_pitch_analysis_core+0x91a>
   1f41e:	4293      	cmp	r3, r2
   1f420:	bfb8      	it	lt
   1f422:	4613      	movlt	r3, r2
   1f424:	e7eb      	b.n	1f3fe <silk_pitch_analysis_core+0x91a>
   1f426:	f04f 0c1f 	mov.w	ip, #31
   1f42a:	e657      	b.n	1f0dc <silk_pitch_analysis_core+0x5f8>
   1f42c:	f1c2 020e 	rsb	r2, r2, #14
   1f430:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
   1f434:	f06f 4500 	mvn.w	r5, #2147483648	; 0x80000000
   1f438:	4111      	asrs	r1, r2
   1f43a:	4115      	asrs	r5, r2
   1f43c:	42a9      	cmp	r1, r5
   1f43e:	dd05      	ble.n	1f44c <silk_pitch_analysis_core+0x968>
   1f440:	428b      	cmp	r3, r1
   1f442:	dd10      	ble.n	1f466 <silk_pitch_analysis_core+0x982>
   1f444:	460b      	mov	r3, r1
   1f446:	4093      	lsls	r3, r2
   1f448:	b21b      	sxth	r3, r3
   1f44a:	e674      	b.n	1f136 <silk_pitch_analysis_core+0x652>
   1f44c:	42ab      	cmp	r3, r5
   1f44e:	dd0e      	ble.n	1f46e <silk_pitch_analysis_core+0x98a>
   1f450:	462b      	mov	r3, r5
   1f452:	e7f8      	b.n	1f446 <silk_pitch_analysis_core+0x962>
            if( CC[ i ] > CCmax_new ) {
   1f454:	f8d7 b094 	ldr.w	fp, [r7, #148]	; 0x94
   1f458:	4593      	cmp	fp, r2
        for( i = 0; i < nb_cbk_search; i++ ) {
   1f45a:	f04f 0301 	mov.w	r3, #1
            if( CC[ i ] > CCmax_new ) {
   1f45e:	f73f af00 	bgt.w	1f262 <silk_pitch_analysis_core+0x77e>
   1f462:	4693      	mov	fp, r2
   1f464:	e6fe      	b.n	1f264 <silk_pitch_analysis_core+0x780>
   1f466:	42ab      	cmp	r3, r5
   1f468:	bfb8      	it	lt
   1f46a:	462b      	movlt	r3, r5
   1f46c:	e7eb      	b.n	1f446 <silk_pitch_analysis_core+0x962>
   1f46e:	428b      	cmp	r3, r1
   1f470:	bfb8      	it	lt
   1f472:	460b      	movlt	r3, r1
   1f474:	e7e7      	b.n	1f446 <silk_pitch_analysis_core+0x962>
        for( i = 0; i < nb_cbk_search; i++ ) {
   1f476:	4693      	mov	fp, r2
   1f478:	e731      	b.n	1f2de <silk_pitch_analysis_core+0x7fa>
        silk_memset( pitch_out, 0, nb_subfr * sizeof( opus_int ) );
   1f47a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   1f47c:	6c78      	ldr	r0, [r7, #68]	; 0x44
   1f47e:	2100      	movs	r1, #0
   1f480:	f015 fe70 	bl	35164 <memset>
        *LTPCorr_Q15  = 0;
   1f484:	f8d7 2400 	ldr.w	r2, [r7, #1024]	; 0x400
   1f488:	2300      	movs	r3, #0
   1f48a:	6013      	str	r3, [r2, #0]
        *lagIndex     = 0;
   1f48c:	6a3a      	ldr	r2, [r7, #32]
   1f48e:	8013      	strh	r3, [r2, #0]
        *contourIndex = 0;
   1f490:	69fa      	ldr	r2, [r7, #28]
        return 1;
   1f492:	2001      	movs	r0, #1
}
   1f494:	f507 7777 	add.w	r7, r7, #988	; 0x3dc
        *contourIndex = 0;
   1f498:	7013      	strb	r3, [r2, #0]
}
   1f49a:	46bd      	mov	sp, r7
   1f49c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        frame = frame_unscaled;
   1f4a0:	643d      	str	r5, [r7, #64]	; 0x40
   1f4a2:	f7ff bb69 	b.w	1eb78 <silk_pitch_analysis_core+0x94>
   1f4a6:	bf00      	nop
   1f4a8:	00037520 	.word	0x00037520
   1f4ac:	000374f4 	.word	0x000374f4
   1f4b0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
    if( nb_subfr == PE_MAX_NB_SUBFR ) {
   1f4b2:	490c      	ldr	r1, [pc, #48]	; (1f4e4 <silk_pitch_analysis_core+0xa00>)
   1f4b4:	f103 0082 	add.w	r0, r3, #130	; 0x82
   1f4b8:	f503 7482 	add.w	r4, r3, #260	; 0x104
            sum = (opus_int32)matrix_ptr( C, 0, i - MIN_LAG_4KHZ, CSTRIDE_4KHZ )
   1f4bc:	f930 3d02 	ldrsh.w	r3, [r0, #-2]!
                + (opus_int32)matrix_ptr( C, 1, i - MIN_LAG_4KHZ, CSTRIDE_4KHZ );               /* Q14 */
   1f4c0:	f934 2d02 	ldrsh.w	r2, [r4, #-2]!
            sum = (opus_int32)matrix_ptr( C, 0, i - MIN_LAG_4KHZ, CSTRIDE_4KHZ )
   1f4c4:	441a      	add	r2, r3
            sum = silk_SMLAWB( sum, sum, silk_LSHIFT( -i, 4 ) );                                /* Q14 */
   1f4c6:	b295      	uxth	r5, r2
   1f4c8:	1413      	asrs	r3, r2, #16
   1f4ca:	fb01 f505 	mul.w	r5, r1, r5
   1f4ce:	fb01 f303 	mul.w	r3, r1, r3
   1f4d2:	eb03 4325 	add.w	r3, r3, r5, asr #16
   1f4d6:	3110      	adds	r1, #16
   1f4d8:	4413      	add	r3, r2
        for( i = MAX_LAG_4KHZ; i >= MIN_LAG_4KHZ; i-- ) {
   1f4da:	f111 0f70 	cmn.w	r1, #112	; 0x70
            C[ i - MIN_LAG_4KHZ ] = (opus_int16)sum;                                            /* Q14 */
   1f4de:	8003      	strh	r3, [r0, #0]
        for( i = MAX_LAG_4KHZ; i >= MIN_LAG_4KHZ; i-- ) {
   1f4e0:	d1ec      	bne.n	1f4bc <silk_pitch_analysis_core+0x9d8>
   1f4e2:	e4bb      	b.n	1ee5c <silk_pitch_analysis_core+0x378>
   1f4e4:	fffffb80 	.word	0xfffffb80
        if( Fs_kHz == 12 ) {
   1f4e8:	2b0c      	cmp	r3, #12
   1f4ea:	f000 8341 	beq.w	1fb70 <silk_pitch_analysis_core+0x108c>
        } else if( Fs_kHz == 16 ) {
   1f4ee:	2b10      	cmp	r3, #16
   1f4f0:	f000 8269 	beq.w	1f9c6 <silk_pitch_analysis_core+0xee2>
    max_lag           = PE_MAX_LAG_MS * Fs_kHz - 1;
   1f4f4:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
   1f4f8:	005b      	lsls	r3, r3, #1
   1f4fa:	1e59      	subs	r1, r3, #1
   1f4fc:	64fb      	str	r3, [r7, #76]	; 0x4c
    min_lag           = PE_MIN_LAG_MS * Fs_kHz;
   1f4fe:	f8d7 3410 	ldr.w	r3, [r7, #1040]	; 0x410
            lag = silk_SMULBB( lag, 3 );
   1f502:	f9b7 2048 	ldrsh.w	r2, [r7, #72]	; 0x48
    max_lag           = PE_MAX_LAG_MS * Fs_kHz - 1;
   1f506:	64b9      	str	r1, [r7, #72]	; 0x48
    min_lag           = PE_MIN_LAG_MS * Fs_kHz;
   1f508:	005c      	lsls	r4, r3, #1
            lag = silk_SMULBB( lag, 3 );
   1f50a:	eb02 0242 	add.w	r2, r2, r2, lsl #1
        lag = silk_LIMIT_int( lag, min_lag, max_lag );
   1f50e:	428c      	cmp	r4, r1
    min_lag           = PE_MIN_LAG_MS * Fs_kHz;
   1f510:	65bc      	str	r4, [r7, #88]	; 0x58
            lag = silk_SMULBB( lag, 3 );
   1f512:	4613      	mov	r3, r2
        lag = silk_LIMIT_int( lag, min_lag, max_lag );
   1f514:	f340 8265 	ble.w	1f9e2 <silk_pitch_analysis_core+0xefe>
   1f518:	4294      	cmp	r4, r2
   1f51a:	f2c0 83d7 	blt.w	1fccc <silk_pitch_analysis_core+0x11e8>
   1f51e:	428a      	cmp	r2, r1
   1f520:	bfb8      	it	lt
   1f522:	460b      	movlt	r3, r1
   1f524:	663b      	str	r3, [r7, #96]	; 0x60
   1f526:	4621      	mov	r1, r4
        start_lag = silk_max_int( lag - 2, min_lag );
   1f528:	1e9a      	subs	r2, r3, #2
    return (((a) > (b)) ? (a) : (b));
   1f52a:	428a      	cmp	r2, r1
   1f52c:	bfb8      	it	lt
   1f52e:	460a      	movlt	r2, r1
   1f530:	637a      	str	r2, [r7, #52]	; 0x34
    return (((a) < (b)) ? (a) : (b));
   1f532:	6cba      	ldr	r2, [r7, #72]	; 0x48
   1f534:	4618      	mov	r0, r3
        end_lag   = silk_min_int( lag + 2, max_lag );
   1f536:	3302      	adds	r3, #2
   1f538:	4293      	cmp	r3, r2
   1f53a:	bfa8      	it	ge
   1f53c:	4613      	movge	r3, r2
   1f53e:	60bb      	str	r3, [r7, #8]
        for( k = 0; k < nb_subfr; k++ ) {
   1f540:	f8d7 3418 	ldr.w	r3, [r7, #1048]	; 0x418
   1f544:	2b00      	cmp	r3, #0
   1f546:	dd26      	ble.n	1f596 <silk_pitch_analysis_core+0xab2>
            pitch_out[ k ] = lag + 2 * silk_CB_lags_stage2[ k ][ CBimax_old ];
   1f548:	4ab8      	ldr	r2, [pc, #736]	; (1f82c <silk_pitch_analysis_core+0xd48>)
   1f54a:	6b3e      	ldr	r6, [r7, #48]	; 0x30
   1f54c:	6c7d      	ldr	r5, [r7, #68]	; 0x44
   1f54e:	5791      	ldrsb	r1, [r2, r6]
   1f550:	2302      	movs	r3, #2
   1f552:	fb13 0101 	smlabb	r1, r3, r1, r0
   1f556:	6029      	str	r1, [r5, #0]
        for( k = 0; k < nb_subfr; k++ ) {
   1f558:	f8d7 1418 	ldr.w	r1, [r7, #1048]	; 0x418
   1f55c:	2901      	cmp	r1, #1
   1f55e:	d01a      	beq.n	1f596 <silk_pitch_analysis_core+0xab2>
            pitch_out[ k ] = lag + 2 * silk_CB_lags_stage2[ k ][ CBimax_old ];
   1f560:	4432      	add	r2, r6
   1f562:	f992 100b 	ldrsb.w	r1, [r2, #11]
   1f566:	fb13 0101 	smlabb	r1, r3, r1, r0
   1f56a:	6069      	str	r1, [r5, #4]
        for( k = 0; k < nb_subfr; k++ ) {
   1f56c:	f8d7 1418 	ldr.w	r1, [r7, #1048]	; 0x418
   1f570:	4299      	cmp	r1, r3
   1f572:	d010      	beq.n	1f596 <silk_pitch_analysis_core+0xab2>
            pitch_out[ k ] = lag + 2 * silk_CB_lags_stage2[ k ][ CBimax_old ];
   1f574:	f992 1016 	ldrsb.w	r1, [r2, #22]
   1f578:	fb13 0101 	smlabb	r1, r3, r1, r0
   1f57c:	60a9      	str	r1, [r5, #8]
        for( k = 0; k < nb_subfr; k++ ) {
   1f57e:	f8d7 1418 	ldr.w	r1, [r7, #1048]	; 0x418
   1f582:	2903      	cmp	r1, #3
   1f584:	d007      	beq.n	1f596 <silk_pitch_analysis_core+0xab2>
            pitch_out[ k ] = lag + 2 * silk_CB_lags_stage2[ k ][ CBimax_old ];
   1f586:	f992 2021 	ldrsb.w	r2, [r2, #33]	; 0x21
        if( nb_subfr == PE_MAX_NB_SUBFR ) {
   1f58a:	2904      	cmp	r1, #4
            pitch_out[ k ] = lag + 2 * silk_CB_lags_stage2[ k ][ CBimax_old ];
   1f58c:	fb13 0302 	smlabb	r3, r3, r2, r0
   1f590:	60eb      	str	r3, [r5, #12]
        if( nb_subfr == PE_MAX_NB_SUBFR ) {
   1f592:	f000 8357 	beq.w	1fc44 <silk_pitch_analysis_core+0x1160>
        ALLOC( energies_st3, nb_subfr * nb_cbk_search, silk_pe_stage3_vals );
   1f596:	69bb      	ldr	r3, [r7, #24]
   1f598:	f8d7 2418 	ldr.w	r2, [r7, #1048]	; 0x418
   1f59c:	f8c7 d00c 	str.w	sp, [r7, #12]
   1f5a0:	189a      	adds	r2, r3, r2
   1f5a2:	0113      	lsls	r3, r2, #4
   1f5a4:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   1f5a8:	009b      	lsls	r3, r3, #2
   1f5aa:	3308      	adds	r3, #8
   1f5ac:	ebad 0d03 	sub.w	sp, sp, r3
    sf_length         = PE_SUBFR_LENGTH_MS * Fs_kHz;
   1f5b0:	f8d7 2410 	ldr.w	r2, [r7, #1040]	; 0x410
        ALLOC( energies_st3, nb_subfr * nb_cbk_search, silk_pe_stage3_vals );
   1f5b4:	a902      	add	r1, sp, #8
        ALLOC( cross_corr_st3, nb_subfr * nb_cbk_search, silk_pe_stage3_vals );
   1f5b6:	ebad 0d03 	sub.w	sp, sp, r3
        cbk_size      = PE_NB_CBKS_STAGE3_10MS;
    }
    ALLOC( scratch_mem, SCRATCH_SIZE, opus_int32 );
    ALLOC( xcorr32, SCRATCH_SIZE, opus_int32 );

    target_ptr = &frame[ silk_LSHIFT( sf_length, 2 ) ]; /* Pointer to middle of frame */
   1f5ba:	6c3b      	ldr	r3, [r7, #64]	; 0x40
        ALLOC( energies_st3, nb_subfr * nb_cbk_search, silk_pe_stage3_vals );
   1f5bc:	62b9      	str	r1, [r7, #40]	; 0x28
    sf_length         = PE_SUBFR_LENGTH_MS * Fs_kHz;
   1f5be:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    target_ptr = &frame[ silk_LSHIFT( sf_length, 2 ) ]; /* Pointer to middle of frame */
   1f5c2:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   1f5c6:	617b      	str	r3, [r7, #20]
        ALLOC( cross_corr_st3, nb_subfr * nb_cbk_search, silk_pe_stage3_vals );
   1f5c8:	ab02      	add	r3, sp, #8
   1f5ca:	627b      	str	r3, [r7, #36]	; 0x24
    for( k = 0; k < nb_subfr; k++ ) {
   1f5cc:	f8d7 3418 	ldr.w	r3, [r7, #1048]	; 0x418
    sf_length         = PE_SUBFR_LENGTH_MS * Fs_kHz;
   1f5d0:	63fa      	str	r2, [r7, #60]	; 0x3c
    for( k = 0; k < nb_subfr; k++ ) {
   1f5d2:	2b00      	cmp	r3, #0
        nb_cbk_search = PE_NB_CBKS_STAGE3_10MS;
   1f5d4:	f04f 0b0c 	mov.w	fp, #12
    for( k = 0; k < nb_subfr; k++ ) {
   1f5d8:	f340 8387 	ble.w	1fcea <silk_pitch_analysis_core+0x1206>
        Lag_CB_ptr    = &silk_CB_lags_stage3_10_ms[ 0 ][ 0 ];
   1f5dc:	4b94      	ldr	r3, [pc, #592]	; (1f830 <silk_pitch_analysis_core+0xd4c>)
   1f5de:	62fb      	str	r3, [r7, #44]	; 0x2c
        Lag_range_ptr = &silk_Lag_range_stage3_10_ms[ 0 ][ 0 ];
   1f5e0:	4b94      	ldr	r3, [pc, #592]	; (1f834 <silk_pitch_analysis_core+0xd50>)
        cbk_size      = PE_NB_CBKS_STAGE3_10MS;
   1f5e2:	f8c7 b050 	str.w	fp, [r7, #80]	; 0x50
   1f5e6:	69b9      	ldr	r1, [r7, #24]
                silk_assert( idx + j < lag_counter );
                matrix_ptr( cross_corr_st3, k, i, nb_cbk_search )[ j ] =
                    scratch_mem[ idx + j ];
            }
        }
        target_ptr += sf_length;
   1f5e8:	f8d7 9014 	ldr.w	r9, [r7, #20]
   1f5ec:	f8c7 b030 	str.w	fp, [r7, #48]	; 0x30
   1f5f0:	3101      	adds	r1, #1
   1f5f2:	1c58      	adds	r0, r3, #1
   1f5f4:	eb0b 028b 	add.w	r2, fp, fp, lsl #2
   1f5f8:	440b      	add	r3, r1
   1f5fa:	613b      	str	r3, [r7, #16]
   1f5fc:	0093      	lsls	r3, r2, #2
   1f5fe:	63bb      	str	r3, [r7, #56]	; 0x38
        celt_pitch_xcorr( target_ptr, target_ptr - start_lag - lag_high, xcorr32, sf_length, lag_high - lag_low + 1, arch );
   1f600:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1f602:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   1f604:	6078      	str	r0, [r7, #4]
   1f606:	005b      	lsls	r3, r3, #1
   1f608:	61bb      	str	r3, [r7, #24]
        target_ptr += sf_length;
   1f60a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1f60c:	657a      	str	r2, [r7, #84]	; 0x54
   1f60e:	005b      	lsls	r3, r3, #1
   1f610:	65fb      	str	r3, [r7, #92]	; 0x5c
   1f612:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1f614:	603b      	str	r3, [r7, #0]
   1f616:	4680      	mov	r8, r0
   1f618:	643b      	str	r3, [r7, #64]	; 0x40
   1f61a:	f507 7488 	add.w	r4, r7, #272	; 0x110
   1f61e:	f107 05b8 	add.w	r5, r7, #184	; 0xb8
        lag_high = matrix_ptr( Lag_range_ptr, k, 1, 2 );
   1f622:	f998 a000 	ldrsb.w	sl, [r8]
        lag_low  = matrix_ptr( Lag_range_ptr, k, 0, 2 );
   1f626:	f918 bc01 	ldrsb.w	fp, [r8, #-1]
        celt_pitch_xcorr( target_ptr, target_ptr - start_lag - lag_high, xcorr32, sf_length, lag_high - lag_low + 1, arch );
   1f62a:	f8d7 341c 	ldr.w	r3, [r7, #1052]	; 0x41c
   1f62e:	9301      	str	r3, [sp, #4]
   1f630:	69ba      	ldr	r2, [r7, #24]
   1f632:	ebaa 060b 	sub.w	r6, sl, fp
   1f636:	1c73      	adds	r3, r6, #1
   1f638:	eb02 014a 	add.w	r1, r2, sl, lsl #1
   1f63c:	9300      	str	r3, [sp, #0]
   1f63e:	eba9 0101 	sub.w	r1, r9, r1
   1f642:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1f644:	4622      	mov	r2, r4
   1f646:	4648      	mov	r0, r9
   1f648:	f00c fc9e 	bl	2bf88 <celt_pitch_xcorr_c>
        for( j = lag_low; j <= lag_high; j++ ) {
   1f64c:	45d3      	cmp	fp, sl
   1f64e:	dc0a      	bgt.n	1f666 <silk_pitch_analysis_core+0xb82>
   1f650:	eb04 0386 	add.w	r3, r4, r6, lsl #2
   1f654:	3304      	adds	r3, #4
   1f656:	f107 02b8 	add.w	r2, r7, #184	; 0xb8
            scratch_mem[ lag_counter ] = xcorr32[ lag_high - j ];
   1f65a:	f853 1d04 	ldr.w	r1, [r3, #-4]!
   1f65e:	f842 1b04 	str.w	r1, [r2], #4
        for( j = lag_low; j <= lag_high; j++ ) {
   1f662:	429c      	cmp	r4, r3
   1f664:	d1f9      	bne.n	1f65a <silk_pitch_analysis_core+0xb76>
        for( i = 0; i < nb_cbk_search; i++ ) {
   1f666:	6b3b      	ldr	r3, [r7, #48]	; 0x30
        delta = matrix_ptr( Lag_range_ptr, k, 0, 2 );
   1f668:	f918 ec01 	ldrsb.w	lr, [r8, #-1]
        for( i = 0; i < nb_cbk_search; i++ ) {
   1f66c:	2b00      	cmp	r3, #0
   1f66e:	dd22      	ble.n	1f6b6 <silk_pitch_analysis_core+0xbd2>
   1f670:	6c39      	ldr	r1, [r7, #64]	; 0x40
   1f672:	6d7a      	ldr	r2, [r7, #84]	; 0x54
   1f674:	eb03 0a01 	add.w	sl, r3, r1
            idx = matrix_ptr( Lag_CB_ptr, k, i, cbk_size ) - delta;
   1f678:	f911 0b01 	ldrsb.w	r0, [r1], #1
   1f67c:	eba0 000e 	sub.w	r0, r0, lr
                    scratch_mem[ idx + j ];
   1f680:	1c43      	adds	r3, r0, #1
   1f682:	f100 0c02 	add.w	ip, r0, #2
                matrix_ptr( cross_corr_st3, k, i, nb_cbk_search )[ j ] =
   1f686:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
   1f68a:	667b      	str	r3, [r7, #100]	; 0x64
                    scratch_mem[ idx + j ];
   1f68c:	1cc6      	adds	r6, r0, #3
                matrix_ptr( cross_corr_st3, k, i, nb_cbk_search )[ j ] =
   1f68e:	f855 302c 	ldr.w	r3, [r5, ip, lsl #2]
   1f692:	6093      	str	r3, [r2, #8]
                    scratch_mem[ idx + j ];
   1f694:	f100 0c04 	add.w	ip, r0, #4
                matrix_ptr( cross_corr_st3, k, i, nb_cbk_search )[ j ] =
   1f698:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   1f69a:	6053      	str	r3, [r2, #4]
   1f69c:	f855 6026 	ldr.w	r6, [r5, r6, lsl #2]
   1f6a0:	f855 3020 	ldr.w	r3, [r5, r0, lsl #2]
   1f6a4:	f855 002c 	ldr.w	r0, [r5, ip, lsl #2]
   1f6a8:	6013      	str	r3, [r2, #0]
        for( i = 0; i < nb_cbk_search; i++ ) {
   1f6aa:	458a      	cmp	sl, r1
                matrix_ptr( cross_corr_st3, k, i, nb_cbk_search )[ j ] =
   1f6ac:	e9c2 6003 	strd	r6, r0, [r2, #12]
   1f6b0:	f102 0214 	add.w	r2, r2, #20
        for( i = 0; i < nb_cbk_search; i++ ) {
   1f6b4:	d1e0      	bne.n	1f678 <silk_pitch_analysis_core+0xb94>
        target_ptr += sf_length;
   1f6b6:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   1f6b8:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   1f6ba:	4499      	add	r9, r3
   1f6bc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1f6be:	4413      	add	r3, r2
   1f6c0:	643b      	str	r3, [r7, #64]	; 0x40
   1f6c2:	6bba      	ldr	r2, [r7, #56]	; 0x38
   1f6c4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1f6c6:	4413      	add	r3, r2
   1f6c8:	657b      	str	r3, [r7, #84]	; 0x54
    for( k = 0; k < nb_subfr; k++ ) {
   1f6ca:	693b      	ldr	r3, [r7, #16]
   1f6cc:	f108 0802 	add.w	r8, r8, #2
   1f6d0:	4543      	cmp	r3, r8
   1f6d2:	d1a6      	bne.n	1f622 <silk_pitch_analysis_core+0xb3e>
   1f6d4:	f8d7 b030 	ldr.w	fp, [r7, #48]	; 0x30
   1f6d8:	f8c7 b064 	str.w	fp, [r7, #100]	; 0x64
   1f6dc:	e9d7 b500 	ldrd	fp, r5, [r7]
   1f6e0:	f8d7 a028 	ldr.w	sl, [r7, #40]	; 0x28
   1f6e4:	f8d7 9014 	ldr.w	r9, [r7, #20]
   1f6e8:	f8c7 8040 	str.w	r8, [r7, #64]	; 0x40
    target_ptr = &frame[ silk_LSHIFT( sf_length, 2 ) ];
    for( k = 0; k < nb_subfr; k++ ) {
        lag_counter = 0;

        /* Calculate the energy for first lag */
        basis_ptr = target_ptr - ( start_lag + matrix_ptr( Lag_range_ptr, k, 0, 2 ) );
   1f6ec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1f6ee:	f915 1c01 	ldrsb.w	r1, [r5, #-1]
        energy = silk_inner_prod_aligned( basis_ptr, basis_ptr, sf_length, arch );
   1f6f2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
        basis_ptr = target_ptr - ( start_lag + matrix_ptr( Lag_range_ptr, k, 0, 2 ) );
   1f6f4:	4419      	add	r1, r3
   1f6f6:	eba9 0641 	sub.w	r6, r9, r1, lsl #1
        energy = silk_inner_prod_aligned( basis_ptr, basis_ptr, sf_length, arch );
   1f6fa:	f8d7 341c 	ldr.w	r3, [r7, #1052]	; 0x41c
   1f6fe:	4631      	mov	r1, r6
   1f700:	4630      	mov	r0, r6
   1f702:	f000 fb25 	bl	1fd50 <silk_inner_prod_aligned>
        silk_assert( energy >= 0 );
        scratch_mem[ lag_counter ] = energy;
        lag_counter++;

        lag_diff = ( matrix_ptr( Lag_range_ptr, k, 1, 2 ) -  matrix_ptr( Lag_range_ptr, k, 0, 2 ) + 1 );
   1f706:	f915 cc01 	ldrsb.w	ip, [r5, #-1]
   1f70a:	f995 3000 	ldrsb.w	r3, [r5]
        scratch_mem[ lag_counter ] = energy;
   1f70e:	6020      	str	r0, [r4, #0]
        lag_diff = ( matrix_ptr( Lag_range_ptr, k, 1, 2 ) -  matrix_ptr( Lag_range_ptr, k, 0, 2 ) + 1 );
   1f710:	eba3 030c 	sub.w	r3, r3, ip
        for( i = 1; i < lag_diff; i++ ) {
   1f714:	2b00      	cmp	r3, #0
   1f716:	dd19      	ble.n	1f74c <silk_pitch_analysis_core+0xc68>
   1f718:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
   1f71a:	eba2 0343 	sub.w	r3, r2, r3, lsl #1
   1f71e:	46b6      	mov	lr, r6
   1f720:	eb06 0803 	add.w	r8, r6, r3
   1f724:	18b1      	adds	r1, r6, r2
   1f726:	4626      	mov	r6, r4
            /* remove part outside new window */
            energy -= silk_SMULBB( basis_ptr[ sf_length - i ], basis_ptr[ sf_length - i ] );
   1f728:	f931 3d02 	ldrsh.w	r3, [r1, #-2]!
            silk_assert( energy >= 0 );

            /* add part that comes into window */
            energy = silk_ADD_SAT32( energy, silk_SMULBB( basis_ptr[ -i ], basis_ptr[ -i ] ) );
   1f72c:	f93e 2d02 	ldrsh.w	r2, [lr, #-2]!
            energy -= silk_SMULBB( basis_ptr[ sf_length - i ], basis_ptr[ sf_length - i ] );
   1f730:	fb03 0313 	mls	r3, r3, r3, r0
            energy = silk_ADD_SAT32( energy, silk_SMULBB( basis_ptr[ -i ], basis_ptr[ -i ] ) );
   1f734:	fb02 f202 	mul.w	r2, r2, r2
   1f738:	1898      	adds	r0, r3, r2
   1f73a:	d503      	bpl.n	1f744 <silk_pitch_analysis_core+0xc60>
   1f73c:	4313      	orrs	r3, r2
   1f73e:	bf58      	it	pl
   1f740:	f06f 4000 	mvnpl.w	r0, #2147483648	; 0x80000000
        for( i = 1; i < lag_diff; i++ ) {
   1f744:	4588      	cmp	r8, r1
            silk_assert( energy >= 0 );
            silk_assert( lag_counter < SCRATCH_SIZE );
            scratch_mem[ lag_counter ] = energy;
   1f746:	f846 0f04 	str.w	r0, [r6, #4]!
        for( i = 1; i < lag_diff; i++ ) {
   1f74a:	d1ed      	bne.n	1f728 <silk_pitch_analysis_core+0xc44>
            lag_counter++;
        }

        delta = matrix_ptr( Lag_range_ptr, k, 0, 2 );
        for( i = 0; i < nb_cbk_search; i++ ) {
   1f74c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   1f74e:	2b00      	cmp	r3, #0
   1f750:	dd24      	ble.n	1f79c <silk_pitch_analysis_core+0xcb8>
   1f752:	eb03 080b 	add.w	r8, r3, fp
   1f756:	4652      	mov	r2, sl
   1f758:	4659      	mov	r1, fp
   1f75a:	657d      	str	r5, [r7, #84]	; 0x54
            /* Fill out the 3 dim array that stores the correlations for    */
            /* each code_book vector for each start lag                     */
            idx = matrix_ptr( Lag_CB_ptr, k, i, cbk_size ) - delta;
   1f75c:	f911 eb01 	ldrsb.w	lr, [r1], #1
   1f760:	ebae 0e0c 	sub.w	lr, lr, ip
            for( j = 0; j < PE_NB_STAGE3_LAGS; j++ ) {
                silk_assert( idx + j < SCRATCH_SIZE );
                silk_assert( idx + j < lag_counter );
                matrix_ptr( energies_st3, k, i, nb_cbk_search )[ j ] =
                    scratch_mem[ idx + j ];
   1f764:	f10e 0301 	add.w	r3, lr, #1
   1f768:	f10e 0602 	add.w	r6, lr, #2
                matrix_ptr( energies_st3, k, i, nb_cbk_search )[ j ] =
   1f76c:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
   1f770:	6053      	str	r3, [r2, #4]
                    scratch_mem[ idx + j ];
   1f772:	f10e 0003 	add.w	r0, lr, #3
   1f776:	f10e 0304 	add.w	r3, lr, #4
                matrix_ptr( energies_st3, k, i, nb_cbk_search )[ j ] =
   1f77a:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
   1f77e:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
   1f782:	f854 502e 	ldr.w	r5, [r4, lr, lsl #2]
   1f786:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
   1f78a:	6015      	str	r5, [r2, #0]
        for( i = 0; i < nb_cbk_search; i++ ) {
   1f78c:	4588      	cmp	r8, r1
                matrix_ptr( energies_st3, k, i, nb_cbk_search )[ j ] =
   1f78e:	e9c2 6002 	strd	r6, r0, [r2, #8]
   1f792:	6113      	str	r3, [r2, #16]
   1f794:	f102 0214 	add.w	r2, r2, #20
        for( i = 0; i < nb_cbk_search; i++ ) {
   1f798:	d1e0      	bne.n	1f75c <silk_pitch_analysis_core+0xc78>
   1f79a:	6d7d      	ldr	r5, [r7, #84]	; 0x54
                silk_assert(
                    matrix_ptr( energies_st3, k, i, nb_cbk_search )[ j ] >= 0 );
            }
        }
        target_ptr += sf_length;
   1f79c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   1f79e:	4499      	add	r9, r3
   1f7a0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   1f7a2:	449b      	add	fp, r3
   1f7a4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1f7a6:	449a      	add	sl, r3
    for( k = 0; k < nb_subfr; k++ ) {
   1f7a8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1f7aa:	3502      	adds	r5, #2
   1f7ac:	42ab      	cmp	r3, r5
   1f7ae:	d19d      	bne.n	1f6ec <silk_pitch_analysis_core+0xc08>
   1f7b0:	f8d7 b064 	ldr.w	fp, [r7, #100]	; 0x64
   1f7b4:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
        energy_target = silk_ADD32( silk_inner_prod_aligned( target_ptr, target_ptr, nb_subfr * sf_length, arch ), 1 );
   1f7b6:	f8d7 1418 	ldr.w	r1, [r7, #1048]	; 0x418
   1f7ba:	f8d7 341c 	ldr.w	r3, [r7, #1052]	; 0x41c
        contour_bias_Q15 = silk_DIV32_16( SILK_FIX_CONST( PE_FLATCONTOUR_BIAS, 15 ), lag );
   1f7be:	6e3d      	ldr	r5, [r7, #96]	; 0x60
        energy_target = silk_ADD32( silk_inner_prod_aligned( target_ptr, target_ptr, nb_subfr * sf_length, arch ), 1 );
   1f7c0:	fb02 f201 	mul.w	r2, r2, r1
   1f7c4:	6979      	ldr	r1, [r7, #20]
   1f7c6:	4608      	mov	r0, r1
        contour_bias_Q15 = silk_DIV32_16( SILK_FIX_CONST( PE_FLATCONTOUR_BIAS, 15 ), lag );
   1f7c8:	f240 6466 	movw	r4, #1638	; 0x666
   1f7cc:	fb94 f4f5 	sdiv	r4, r4, r5
   1f7d0:	643c      	str	r4, [r7, #64]	; 0x40
        energy_target = silk_ADD32( silk_inner_prod_aligned( target_ptr, target_ptr, nb_subfr * sf_length, arch ), 1 );
   1f7d2:	f000 fabd 	bl	1fd50 <silk_inner_prod_aligned>
   1f7d6:	1c43      	adds	r3, r0, #1
   1f7d8:	65fb      	str	r3, [r7, #92]	; 0x5c
        for( d = start_lag; d <= end_lag; d++ ) {
   1f7da:	6b79      	ldr	r1, [r7, #52]	; 0x34
   1f7dc:	68bb      	ldr	r3, [r7, #8]
   1f7de:	428b      	cmp	r3, r1
   1f7e0:	f2c0 8280 	blt.w	1fce4 <silk_pitch_analysis_core+0x1200>
   1f7e4:	f8d7 e06c 	ldr.w	lr, [r7, #108]	; 0x6c
   1f7e8:	6579      	str	r1, [r7, #84]	; 0x54
                    cross_corr = silk_ADD32( cross_corr,
   1f7ea:	ea4f 004b 	mov.w	r0, fp, lsl #1
   1f7ee:	3301      	adds	r3, #1
   1f7f0:	2200      	movs	r2, #0
        CCmax = silk_int32_MIN;
   1f7f2:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
   1f7f6:	61bb      	str	r3, [r7, #24]
   1f7f8:	4676      	mov	r6, lr
                    cross_corr = silk_ADD32( cross_corr,
   1f7fa:	eb00 030b 	add.w	r3, r0, fp
   1f7fe:	f8d7 e418 	ldr.w	lr, [r7, #1048]	; 0x418
   1f802:	633b      	str	r3, [r7, #48]	; 0x30
   1f804:	63b8      	str	r0, [r7, #56]	; 0x38
        CCmax = silk_int32_MIN;
   1f806:	667c      	str	r4, [r7, #100]	; 0x64
        CBimax    = 0;                                      /* to avoid undefined lag */
   1f808:	63fa      	str	r2, [r7, #60]	; 0x3c
   1f80a:	460b      	mov	r3, r1
   1f80c:	6b79      	ldr	r1, [r7, #52]	; 0x34
            for( j = 0; j < nb_cbk_search; j++ ) {
   1f80e:	f1bb 0f00 	cmp.w	fp, #0
   1f812:	eba3 0301 	sub.w	r3, r3, r1
   1f816:	f340 810f 	ble.w	1fa38 <silk_pitch_analysis_core+0xf54>
                    cross_corr = silk_ADD32( cross_corr,
   1f81a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   1f81c:	009b      	lsls	r3, r3, #2
   1f81e:	eb02 0a03 	add.w	sl, r2, r3
                    energy     = silk_ADD32( energy,
   1f822:	6aba      	ldr	r2, [r7, #40]	; 0x28
            for( j = 0; j < nb_cbk_search; j++ ) {
   1f824:	2500      	movs	r5, #0
                    energy     = silk_ADD32( energy,
   1f826:	eb02 0c03 	add.w	ip, r2, r3
   1f82a:	e055      	b.n	1f8d8 <silk_pitch_analysis_core+0xdf4>
   1f82c:	000374f4 	.word	0x000374f4
   1f830:	000375b0 	.word	0x000375b0
   1f834:	000375e0 	.word	0x000375e0
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
   1f838:	ea86 74e6 	eor.w	r4, r6, r6, asr #31
   1f83c:	eba4 74e6 	sub.w	r4, r4, r6, asr #31
   1f840:	fab4 f484 	clz	r4, r4
   1f844:	3c01      	subs	r4, #1
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                  */
   1f846:	fa06 f804 	lsl.w	r8, r6, r4
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1f84a:	ea4f 4128 	mov.w	r1, r8, asr #16
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1f84e:	fa1f f983 	uxth.w	r9, r3
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1f852:	f06f 4060 	mvn.w	r0, #3758096384	; 0xe0000000
   1f856:	fb90 f1f1 	sdiv	r1, r0, r1
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1f85a:	1418      	asrs	r0, r3, #16
   1f85c:	b209      	sxth	r1, r1
   1f85e:	fb01 f909 	mul.w	r9, r1, r9
   1f862:	fb01 f000 	mul.w	r0, r1, r0
   1f866:	eb00 4029 	add.w	r0, r0, r9, asr #16
    a32_nrm = silk_SUB32_ovflw(a32_nrm, silk_LSHIFT_ovflw( silk_SMMUL(b32_nrm, result), 3 ));  /* Q: a_headrm   */
   1f86a:	fb88 8900 	smull	r8, r9, r8, r0
   1f86e:	eba3 03c9 	sub.w	r3, r3, r9, lsl #3
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1f872:	fa1f f883 	uxth.w	r8, r3
   1f876:	141b      	asrs	r3, r3, #16
   1f878:	fb01 f303 	mul.w	r3, r1, r3
   1f87c:	fb01 f808 	mul.w	r8, r1, r8
   1f880:	eb03 4828 	add.w	r8, r3, r8, asr #16
    lshift = 29 + a_headrm - b_headrm - Qres;
   1f884:	321c      	adds	r2, #28
   1f886:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1f888:	f647 71ff 	movw	r1, #32767	; 0x7fff
   1f88c:	1b12      	subs	r2, r2, r4
   1f88e:	fb03 1315 	mls	r3, r3, r5, r1
    if( lshift < 0 ) {
   1f892:	f1b2 010e 	subs.w	r1, r2, #14
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1f896:	4440      	add	r0, r8
   1f898:	b21b      	sxth	r3, r3
    if( lshift < 0 ) {
   1f89a:	f100 80af 	bmi.w	1f9fc <silk_pitch_analysis_core+0xf18>
        if( lshift < 32){
   1f89e:	291f      	cmp	r1, #31
   1f8a0:	f300 80aa 	bgt.w	1f9f8 <silk_pitch_analysis_core+0xf14>
            return silk_RSHIFT(result, lshift);
   1f8a4:	4108      	asrs	r0, r1
   1f8a6:	b282      	uxth	r2, r0
   1f8a8:	1400      	asrs	r0, r0, #16
   1f8aa:	fb03 f202 	mul.w	r2, r3, r2
   1f8ae:	fb03 f000 	mul.w	r0, r3, r0
   1f8b2:	eb00 4222 	add.w	r2, r0, r2, asr #16
                if( CCmax_new > CCmax && ( d + silk_CB_lags_stage3[ 0 ][ j ] ) <= max_lag ) {
   1f8b6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   1f8b8:	429a      	cmp	r2, r3
   1f8ba:	dd09      	ble.n	1f8d0 <silk_pitch_analysis_core+0xdec>
   1f8bc:	4baf      	ldr	r3, [pc, #700]	; (1fb7c <silk_pitch_analysis_core+0x1098>)
   1f8be:	6d79      	ldr	r1, [r7, #84]	; 0x54
   1f8c0:	575b      	ldrsb	r3, [r3, r5]
   1f8c2:	6cb8      	ldr	r0, [r7, #72]	; 0x48
   1f8c4:	440b      	add	r3, r1
   1f8c6:	4283      	cmp	r3, r0
   1f8c8:	bfdc      	itt	le
   1f8ca:	e9c7 1218 	strdle	r1, r2, [r7, #96]	; 0x60
   1f8ce:	63fd      	strle	r5, [r7, #60]	; 0x3c
            for( j = 0; j < nb_cbk_search; j++ ) {
   1f8d0:	3501      	adds	r5, #1
   1f8d2:	45ab      	cmp	fp, r5
   1f8d4:	f340 80af 	ble.w	1fa36 <silk_pitch_analysis_core+0xf52>
                for( k = 0; k < nb_subfr; k++ ) {
   1f8d8:	f1be 0f00 	cmp.w	lr, #0
   1f8dc:	f340 80a8 	ble.w	1fa30 <silk_pitch_analysis_core+0xf4c>
                    cross_corr = silk_ADD32( cross_corr,
   1f8e0:	eb05 0385 	add.w	r3, r5, r5, lsl #2
                    energy     = silk_ADD32( energy,
   1f8e4:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
   1f8e6:	f85c 6023 	ldr.w	r6, [ip, r3, lsl #2]
                    cross_corr = silk_ADD32( cross_corr,
   1f8ea:	f85a 3023 	ldr.w	r3, [sl, r3, lsl #2]
                for( k = 0; k < nb_subfr; k++ ) {
   1f8ee:	f1be 0f01 	cmp.w	lr, #1
                    energy     = silk_ADD32( energy,
   1f8f2:	4416      	add	r6, r2
                for( k = 0; k < nb_subfr; k++ ) {
   1f8f4:	d023      	beq.n	1f93e <silk_pitch_analysis_core+0xe5a>
                    cross_corr = silk_ADD32( cross_corr,
   1f8f6:	eb0b 0205 	add.w	r2, fp, r5
   1f8fa:	eb02 0282 	add.w	r2, r2, r2, lsl #2
                for( k = 0; k < nb_subfr; k++ ) {
   1f8fe:	f1be 0f02 	cmp.w	lr, #2
                    cross_corr = silk_ADD32( cross_corr,
   1f902:	f85a 1022 	ldr.w	r1, [sl, r2, lsl #2]
                    energy     = silk_ADD32( energy,
   1f906:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
                    cross_corr = silk_ADD32( cross_corr,
   1f90a:	440b      	add	r3, r1
                    energy     = silk_ADD32( energy,
   1f90c:	4416      	add	r6, r2
                for( k = 0; k < nb_subfr; k++ ) {
   1f90e:	d016      	beq.n	1f93e <silk_pitch_analysis_core+0xe5a>
                    cross_corr = silk_ADD32( cross_corr,
   1f910:	6bba      	ldr	r2, [r7, #56]	; 0x38
   1f912:	18aa      	adds	r2, r5, r2
   1f914:	eb02 0282 	add.w	r2, r2, r2, lsl #2
                for( k = 0; k < nb_subfr; k++ ) {
   1f918:	f1be 0f04 	cmp.w	lr, #4
                    cross_corr = silk_ADD32( cross_corr,
   1f91c:	f85a 1022 	ldr.w	r1, [sl, r2, lsl #2]
                    energy     = silk_ADD32( energy,
   1f920:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
                    cross_corr = silk_ADD32( cross_corr,
   1f924:	440b      	add	r3, r1
                    energy     = silk_ADD32( energy,
   1f926:	4416      	add	r6, r2
                for( k = 0; k < nb_subfr; k++ ) {
   1f928:	d109      	bne.n	1f93e <silk_pitch_analysis_core+0xe5a>
                    cross_corr = silk_ADD32( cross_corr,
   1f92a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   1f92c:	18aa      	adds	r2, r5, r2
   1f92e:	eb02 0282 	add.w	r2, r2, r2, lsl #2
   1f932:	f85a 1022 	ldr.w	r1, [sl, r2, lsl #2]
                    energy     = silk_ADD32( energy,
   1f936:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
                    cross_corr = silk_ADD32( cross_corr,
   1f93a:	440b      	add	r3, r1
                    energy     = silk_ADD32( energy,
   1f93c:	4416      	add	r6, r2
                if( cross_corr > 0 ) {
   1f93e:	2b00      	cmp	r3, #0
   1f940:	dd5a      	ble.n	1f9f8 <silk_pitch_analysis_core+0xf14>
   1f942:	fab3 f283 	clz	r2, r3
    a_headrm = silk_CLZ32( silk_abs(a32) ) - 1;
   1f946:	1e51      	subs	r1, r2, #1
    a32_nrm = silk_LSHIFT(a32, a_headrm);                                       /* Q: a_headrm                  */
   1f948:	408b      	lsls	r3, r1
   1f94a:	2e00      	cmp	r6, #0
   1f94c:	f47f af74 	bne.w	1f838 <silk_pitch_analysis_core+0xd54>
   1f950:	241f      	movs	r4, #31
   1f952:	e778      	b.n	1f846 <silk_pitch_analysis_core+0xd62>
   1f954:	f507 7333 	add.w	r3, r7, #716	; 0x2cc
   1f958:	4618      	mov	r0, r3
   1f95a:	f44f 7286 	mov.w	r2, #268	; 0x10c
   1f95e:	2100      	movs	r1, #0
   1f960:	657b      	str	r3, [r7, #84]	; 0x54
        if( C[ i ] > threshold ) {
   1f962:	462c      	mov	r4, r5
   1f964:	f015 fbfe 	bl	35164 <memset>
   1f968:	f7ff babc 	b.w	1eee4 <silk_pitch_analysis_core+0x400>
        if( Fs_kHz == 8 && complexity > SILK_PE_MIN_COMPLEX ) {
   1f96c:	f8d7 3410 	ldr.w	r3, [r7, #1040]	; 0x410
   1f970:	2b08      	cmp	r3, #8
   1f972:	f000 8195 	beq.w	1fca0 <silk_pitch_analysis_core+0x11bc>
        Lag_CB_ptr = &silk_CB_lags_stage2[ 0 ][ 0 ];
   1f976:	4b82      	ldr	r3, [pc, #520]	; (1fb80 <silk_pitch_analysis_core+0x109c>)
   1f978:	65bb      	str	r3, [r7, #88]	; 0x58
            nb_cbk_search = PE_NB_CBKS_STAGE2;
   1f97a:	2303      	movs	r3, #3
        cbk_size   = PE_NB_CBKS_STAGE2_EXT;
   1f97c:	250b      	movs	r5, #11
            nb_cbk_search = PE_NB_CBKS_STAGE2;
   1f97e:	657b      	str	r3, [r7, #84]	; 0x54
   1f980:	e409      	b.n	1f196 <silk_pitch_analysis_core+0x6b2>
        prevLag_log2_Q7 = 0;
   1f982:	2300      	movs	r3, #0
   1f984:	63fb      	str	r3, [r7, #60]	; 0x3c
   1f986:	f7ff bbfd 	b.w	1f184 <silk_pitch_analysis_core+0x6a0>
        silk_memset( filt_state, 0, 2 * sizeof( opus_int32 ) );
   1f98a:	f107 0574 	add.w	r5, r7, #116	; 0x74
        silk_resampler_down2( filt_state, frame_8kHz_buf, frame, frame_length );
   1f98e:	4623      	mov	r3, r4
        silk_memset( filt_state, 0, 2 * sizeof( opus_int32 ) );
   1f990:	2400      	movs	r4, #0
        silk_resampler_down2( filt_state, frame_8kHz_buf, frame, frame_length );
   1f992:	4628      	mov	r0, r5
   1f994:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   1f996:	6d39      	ldr	r1, [r7, #80]	; 0x50
        silk_memset( filt_state, 0, 2 * sizeof( opus_int32 ) );
   1f998:	e9c5 4400 	strd	r4, r4, [r5]
        silk_resampler_down2( filt_state, frame_8kHz_buf, frame, frame_length );
   1f99c:	f7f9 fae8 	bl	18f70 <silk_resampler_down2>
   1f9a0:	f7ff b901 	b.w	1eba6 <silk_pitch_analysis_core+0xc2>
        silk_memset( filt_state, 0, 6 * sizeof( opus_int32 ) );
   1f9a4:	f107 0574 	add.w	r5, r7, #116	; 0x74
        silk_resampler_down2_3( filt_state, frame_8kHz_buf, frame, frame_length );
   1f9a8:	4623      	mov	r3, r4
        silk_memset( filt_state, 0, 6 * sizeof( opus_int32 ) );
   1f9aa:	2400      	movs	r4, #0
        silk_resampler_down2_3( filt_state, frame_8kHz_buf, frame, frame_length );
   1f9ac:	4628      	mov	r0, r5
   1f9ae:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   1f9b0:	6d39      	ldr	r1, [r7, #80]	; 0x50
        silk_memset( filt_state, 0, 6 * sizeof( opus_int32 ) );
   1f9b2:	e9c5 4400 	strd	r4, r4, [r5]
   1f9b6:	e9c5 4402 	strd	r4, r4, [r5, #8]
   1f9ba:	e9c5 4404 	strd	r4, r4, [r5, #16]
        silk_resampler_down2_3( filt_state, frame_8kHz_buf, frame, frame_length );
   1f9be:	f7f9 fa0f 	bl	18de0 <silk_resampler_down2_3>
   1f9c2:	f7ff b8f0 	b.w	1eba6 <silk_pitch_analysis_core+0xc2>
            lag = silk_LSHIFT( lag, 1 );
   1f9c6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   1f9c8:	005b      	lsls	r3, r3, #1
    max_lag           = PE_MAX_LAG_MS * Fs_kHz - 1;
   1f9ca:	f8d7 2410 	ldr.w	r2, [r7, #1040]	; 0x410
   1f9ce:	eb02 02c2 	add.w	r2, r2, r2, lsl #3
   1f9d2:	0052      	lsls	r2, r2, #1
   1f9d4:	64fa      	str	r2, [r7, #76]	; 0x4c
   1f9d6:	3a01      	subs	r2, #1
   1f9d8:	64ba      	str	r2, [r7, #72]	; 0x48
    min_lag           = PE_MIN_LAG_MS * Fs_kHz;
   1f9da:	f8d7 2410 	ldr.w	r2, [r7, #1040]	; 0x410
   1f9de:	0052      	lsls	r2, r2, #1
   1f9e0:	65ba      	str	r2, [r7, #88]	; 0x58
        lag = silk_LIMIT_int( lag, min_lag, max_lag );
   1f9e2:	6cba      	ldr	r2, [r7, #72]	; 0x48
   1f9e4:	4293      	cmp	r3, r2
   1f9e6:	f300 8157 	bgt.w	1fc98 <silk_pitch_analysis_core+0x11b4>
   1f9ea:	6dba      	ldr	r2, [r7, #88]	; 0x58
   1f9ec:	4293      	cmp	r3, r2
   1f9ee:	bfb8      	it	lt
   1f9f0:	4613      	movlt	r3, r2
   1f9f2:	663b      	str	r3, [r7, #96]	; 0x60
   1f9f4:	4611      	mov	r1, r2
   1f9f6:	e597      	b.n	1f528 <silk_pitch_analysis_core+0xa44>
                    CCmax_new = 0;
   1f9f8:	2200      	movs	r2, #0
   1f9fa:	e75c      	b.n	1f8b6 <silk_pitch_analysis_core+0xdd2>
        return silk_LSHIFT_SAT32(result, -lshift);
   1f9fc:	f1c2 020e 	rsb	r2, r2, #14
   1fa00:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
   1fa04:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
   1fa08:	4111      	asrs	r1, r2
   1fa0a:	4114      	asrs	r4, r2
   1fa0c:	42a1      	cmp	r1, r4
   1fa0e:	f340 8097 	ble.w	1fb40 <silk_pitch_analysis_core+0x105c>
   1fa12:	4288      	cmp	r0, r1
   1fa14:	f340 8098 	ble.w	1fb48 <silk_pitch_analysis_core+0x1064>
   1fa18:	4608      	mov	r0, r1
   1fa1a:	fa00 f202 	lsl.w	r2, r0, r2
   1fa1e:	b291      	uxth	r1, r2
   1fa20:	1412      	asrs	r2, r2, #16
   1fa22:	fb03 f101 	mul.w	r1, r3, r1
   1fa26:	fb03 f202 	mul.w	r2, r3, r2
   1fa2a:	eb02 4221 	add.w	r2, r2, r1, asr #16
   1fa2e:	e742      	b.n	1f8b6 <silk_pitch_analysis_core+0xdd2>
                energy     = energy_target;
   1fa30:	6dfe      	ldr	r6, [r7, #92]	; 0x5c
                    CCmax_new = 0;
   1fa32:	2200      	movs	r2, #0
   1fa34:	e73f      	b.n	1f8b6 <silk_pitch_analysis_core+0xdd2>
   1fa36:	2201      	movs	r2, #1
        for( d = start_lag; d <= end_lag; d++ ) {
   1fa38:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1fa3a:	69b9      	ldr	r1, [r7, #24]
   1fa3c:	3301      	adds	r3, #1
   1fa3e:	428b      	cmp	r3, r1
   1fa40:	657b      	str	r3, [r7, #84]	; 0x54
   1fa42:	f47f aee3 	bne.w	1f80c <silk_pitch_analysis_core+0xd28>
   1fa46:	46b6      	mov	lr, r6
   1fa48:	2a00      	cmp	r2, #0
   1fa4a:	f040 815c 	bne.w	1fd06 <silk_pitch_analysis_core+0x1222>
   1fa4e:	f997 203c 	ldrsb.w	r2, [r7, #60]	; 0x3c
        for( k = 0; k < nb_subfr; k++ ) {
   1fa52:	f8d7 3418 	ldr.w	r3, [r7, #1048]	; 0x418
   1fa56:	2b00      	cmp	r3, #0
   1fa58:	dd63      	ble.n	1fb22 <silk_pitch_analysis_core+0x103e>
   1fa5a:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
   1fa5c:	6db8      	ldr	r0, [r7, #88]	; 0x58
            pitch_out[ k ] = lag_new + matrix_ptr( Lag_CB_ptr, k, CBimax, cbk_size );
   1fa5e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1fa60:	4281      	cmp	r1, r0
   1fa62:	f2c0 8091 	blt.w	1fb88 <silk_pitch_analysis_core+0x10a4>
   1fa66:	6bfc      	ldr	r4, [r7, #60]	; 0x3c
   1fa68:	571b      	ldrsb	r3, [r3, r4]
   1fa6a:	6e3c      	ldr	r4, [r7, #96]	; 0x60
   1fa6c:	4423      	add	r3, r4
            pitch_out[ k ] = silk_LIMIT( pitch_out[ k ], min_lag, PE_MAX_LAG_MS * Fs_kHz );
   1fa6e:	428b      	cmp	r3, r1
   1fa70:	f300 8110 	bgt.w	1fc94 <silk_pitch_analysis_core+0x11b0>
   1fa74:	4283      	cmp	r3, r0
   1fa76:	bfb8      	it	lt
   1fa78:	4603      	movlt	r3, r0
   1fa7a:	6c79      	ldr	r1, [r7, #68]	; 0x44
   1fa7c:	600b      	str	r3, [r1, #0]
        for( k = 0; k < nb_subfr; k++ ) {
   1fa7e:	f8d7 3418 	ldr.w	r3, [r7, #1048]	; 0x418
   1fa82:	2b01      	cmp	r3, #1
   1fa84:	d04d      	beq.n	1fb22 <silk_pitch_analysis_core+0x103e>
            pitch_out[ k ] = lag_new + matrix_ptr( Lag_CB_ptr, k, CBimax, cbk_size );
   1fa86:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
   1fa88:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1fa8a:	6e38      	ldr	r0, [r7, #96]	; 0x60
   1fa8c:	440b      	add	r3, r1
   1fa8e:	6d39      	ldr	r1, [r7, #80]	; 0x50
   1fa90:	5659      	ldrsb	r1, [r3, r1]
   1fa92:	4401      	add	r1, r0
            pitch_out[ k ] = silk_LIMIT( pitch_out[ k ], min_lag, PE_MAX_LAG_MS * Fs_kHz );
   1fa94:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
   1fa96:	4288      	cmp	r0, r1
   1fa98:	f2c0 812c 	blt.w	1fcf4 <silk_pitch_analysis_core+0x1210>
   1fa9c:	6db8      	ldr	r0, [r7, #88]	; 0x58
   1fa9e:	4281      	cmp	r1, r0
   1faa0:	bfb8      	it	lt
   1faa2:	4601      	movlt	r1, r0
   1faa4:	6c78      	ldr	r0, [r7, #68]	; 0x44
   1faa6:	6041      	str	r1, [r0, #4]
        for( k = 0; k < nb_subfr; k++ ) {
   1faa8:	f8d7 1418 	ldr.w	r1, [r7, #1048]	; 0x418
   1faac:	2902      	cmp	r1, #2
   1faae:	d038      	beq.n	1fb22 <silk_pitch_analysis_core+0x103e>
            pitch_out[ k ] = lag_new + matrix_ptr( Lag_CB_ptr, k, CBimax, cbk_size );
   1fab0:	6d38      	ldr	r0, [r7, #80]	; 0x50
   1fab2:	6e3c      	ldr	r4, [r7, #96]	; 0x60
   1fab4:	f913 1010 	ldrsb.w	r1, [r3, r0, lsl #1]
   1fab8:	4421      	add	r1, r4
            pitch_out[ k ] = silk_LIMIT( pitch_out[ k ], min_lag, PE_MAX_LAG_MS * Fs_kHz );
   1faba:	6cfc      	ldr	r4, [r7, #76]	; 0x4c
   1fabc:	42a1      	cmp	r1, r4
            pitch_out[ k ] = lag_new + matrix_ptr( Lag_CB_ptr, k, CBimax, cbk_size );
   1fabe:	ea4f 0040 	mov.w	r0, r0, lsl #1
            pitch_out[ k ] = silk_LIMIT( pitch_out[ k ], min_lag, PE_MAX_LAG_MS * Fs_kHz );
   1fac2:	f300 8119 	bgt.w	1fcf8 <silk_pitch_analysis_core+0x1214>
   1fac6:	6dbc      	ldr	r4, [r7, #88]	; 0x58
   1fac8:	42a1      	cmp	r1, r4
   1faca:	bfb8      	it	lt
   1facc:	4621      	movlt	r1, r4
   1face:	6c7c      	ldr	r4, [r7, #68]	; 0x44
   1fad0:	60a1      	str	r1, [r4, #8]
        for( k = 0; k < nb_subfr; k++ ) {
   1fad2:	f8d7 1418 	ldr.w	r1, [r7, #1048]	; 0x418
   1fad6:	2903      	cmp	r1, #3
   1fad8:	d023      	beq.n	1fb22 <silk_pitch_analysis_core+0x103e>
            pitch_out[ k ] = lag_new + matrix_ptr( Lag_CB_ptr, k, CBimax, cbk_size );
   1fada:	6d39      	ldr	r1, [r7, #80]	; 0x50
   1fadc:	6e3c      	ldr	r4, [r7, #96]	; 0x60
   1fade:	4408      	add	r0, r1
   1fae0:	5619      	ldrsb	r1, [r3, r0]
   1fae2:	4421      	add	r1, r4
            pitch_out[ k ] = silk_LIMIT( pitch_out[ k ], min_lag, PE_MAX_LAG_MS * Fs_kHz );
   1fae4:	6cfc      	ldr	r4, [r7, #76]	; 0x4c
   1fae6:	42a1      	cmp	r1, r4
   1fae8:	f300 80f6 	bgt.w	1fcd8 <silk_pitch_analysis_core+0x11f4>
   1faec:	6dbc      	ldr	r4, [r7, #88]	; 0x58
   1faee:	42a1      	cmp	r1, r4
   1faf0:	bfb8      	it	lt
   1faf2:	4621      	movlt	r1, r4
   1faf4:	6c7c      	ldr	r4, [r7, #68]	; 0x44
   1faf6:	60e1      	str	r1, [r4, #12]
        for( k = 0; k < nb_subfr; k++ ) {
   1faf8:	f8d7 1418 	ldr.w	r1, [r7, #1048]	; 0x418
   1fafc:	2904      	cmp	r1, #4
   1fafe:	d010      	beq.n	1fb22 <silk_pitch_analysis_core+0x103e>
            pitch_out[ k ] = lag_new + matrix_ptr( Lag_CB_ptr, k, CBimax, cbk_size );
   1fb00:	6d39      	ldr	r1, [r7, #80]	; 0x50
   1fb02:	440b      	add	r3, r1
   1fb04:	6e39      	ldr	r1, [r7, #96]	; 0x60
   1fb06:	561b      	ldrsb	r3, [r3, r0]
   1fb08:	440b      	add	r3, r1
            pitch_out[ k ] = silk_LIMIT( pitch_out[ k ], min_lag, PE_MAX_LAG_MS * Fs_kHz );
   1fb0a:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
   1fb0c:	4299      	cmp	r1, r3
   1fb0e:	db04      	blt.n	1fb1a <silk_pitch_analysis_core+0x1036>
   1fb10:	6db9      	ldr	r1, [r7, #88]	; 0x58
   1fb12:	428b      	cmp	r3, r1
   1fb14:	bfb8      	it	lt
   1fb16:	460b      	movlt	r3, r1
   1fb18:	64fb      	str	r3, [r7, #76]	; 0x4c
   1fb1a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   1fb1c:	4619      	mov	r1, r3
   1fb1e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   1fb20:	610b      	str	r3, [r1, #16]
        *lagIndex = (opus_int16)( lag_new - min_lag);
   1fb22:	6db9      	ldr	r1, [r7, #88]	; 0x58
   1fb24:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   1fb26:	1a5b      	subs	r3, r3, r1
   1fb28:	6a39      	ldr	r1, [r7, #32]
   1fb2a:	800b      	strh	r3, [r1, #0]
        *contourIndex = (opus_int8)CBimax;
   1fb2c:	69fb      	ldr	r3, [r7, #28]
   1fb2e:	701a      	strb	r2, [r3, #0]
   1fb30:	f8d7 d00c 	ldr.w	sp, [r7, #12]
    return 0;
   1fb34:	2000      	movs	r0, #0
}
   1fb36:	f507 7777 	add.w	r7, r7, #988	; 0x3dc
   1fb3a:	46bd      	mov	sp, r7
   1fb3c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1fb40:	42a0      	cmp	r0, r4
   1fb42:	dd05      	ble.n	1fb50 <silk_pitch_analysis_core+0x106c>
   1fb44:	4620      	mov	r0, r4
   1fb46:	e768      	b.n	1fa1a <silk_pitch_analysis_core+0xf36>
   1fb48:	42a0      	cmp	r0, r4
   1fb4a:	bfb8      	it	lt
   1fb4c:	4620      	movlt	r0, r4
   1fb4e:	e764      	b.n	1fa1a <silk_pitch_analysis_core+0xf36>
   1fb50:	4288      	cmp	r0, r1
   1fb52:	bfb8      	it	lt
   1fb54:	4608      	movlt	r0, r1
   1fb56:	e760      	b.n	1fa1a <silk_pitch_analysis_core+0xf36>
            prevLag = silk_DIV32_16( silk_LSHIFT( prevLag, 1 ), 3 );
   1fb58:	f8d7 2404 	ldr.w	r2, [r7, #1028]	; 0x404
   1fb5c:	4b09      	ldr	r3, [pc, #36]	; (1fb84 <silk_pitch_analysis_core+0x10a0>)
   1fb5e:	0052      	lsls	r2, r2, #1
   1fb60:	fb83 1302 	smull	r1, r3, r3, r2
   1fb64:	eba3 73e2 	sub.w	r3, r3, r2, asr #31
   1fb68:	f8c7 3404 	str.w	r3, [r7, #1028]	; 0x404
   1fb6c:	f7ff bb05 	b.w	1f17a <silk_pitch_analysis_core+0x696>
            lag = silk_RSHIFT( silk_SMULBB( lag, 3 ), 1 );
   1fb70:	f9b7 3048 	ldrsh.w	r3, [r7, #72]	; 0x48
   1fb74:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   1fb78:	105b      	asrs	r3, r3, #1
   1fb7a:	e726      	b.n	1f9ca <silk_pitch_analysis_core+0xee6>
   1fb7c:	00037528 	.word	0x00037528
   1fb80:	000374f4 	.word	0x000374f4
   1fb84:	55555556 	.word	0x55555556
            pitch_out[ k ] = lag_new + matrix_ptr( Lag_CB_ptr, k, CBimax, cbk_size );
   1fb88:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
   1fb8a:	565b      	ldrsb	r3, [r3, r1]
   1fb8c:	6e39      	ldr	r1, [r7, #96]	; 0x60
   1fb8e:	440b      	add	r3, r1
            pitch_out[ k ] = silk_LIMIT( pitch_out[ k ], min_lag, PE_MAX_LAG_MS * Fs_kHz );
   1fb90:	6db9      	ldr	r1, [r7, #88]	; 0x58
   1fb92:	428b      	cmp	r3, r1
   1fb94:	f300 809e 	bgt.w	1fcd4 <silk_pitch_analysis_core+0x11f0>
   1fb98:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
   1fb9a:	428b      	cmp	r3, r1
   1fb9c:	bfb8      	it	lt
   1fb9e:	460b      	movlt	r3, r1
   1fba0:	6c79      	ldr	r1, [r7, #68]	; 0x44
   1fba2:	600b      	str	r3, [r1, #0]
        for( k = 0; k < nb_subfr; k++ ) {
   1fba4:	f8d7 3418 	ldr.w	r3, [r7, #1048]	; 0x418
   1fba8:	2b01      	cmp	r3, #1
   1fbaa:	d0ba      	beq.n	1fb22 <silk_pitch_analysis_core+0x103e>
            pitch_out[ k ] = lag_new + matrix_ptr( Lag_CB_ptr, k, CBimax, cbk_size );
   1fbac:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
   1fbae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1fbb0:	6e38      	ldr	r0, [r7, #96]	; 0x60
   1fbb2:	440b      	add	r3, r1
   1fbb4:	6d39      	ldr	r1, [r7, #80]	; 0x50
   1fbb6:	5659      	ldrsb	r1, [r3, r1]
   1fbb8:	4401      	add	r1, r0
            pitch_out[ k ] = silk_LIMIT( pitch_out[ k ], min_lag, PE_MAX_LAG_MS * Fs_kHz );
   1fbba:	6db8      	ldr	r0, [r7, #88]	; 0x58
   1fbbc:	4281      	cmp	r1, r0
   1fbbe:	f300 808f 	bgt.w	1fce0 <silk_pitch_analysis_core+0x11fc>
   1fbc2:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
   1fbc4:	4281      	cmp	r1, r0
   1fbc6:	bfb8      	it	lt
   1fbc8:	4601      	movlt	r1, r0
   1fbca:	6c78      	ldr	r0, [r7, #68]	; 0x44
   1fbcc:	6041      	str	r1, [r0, #4]
        for( k = 0; k < nb_subfr; k++ ) {
   1fbce:	f8d7 1418 	ldr.w	r1, [r7, #1048]	; 0x418
   1fbd2:	2902      	cmp	r1, #2
   1fbd4:	d0a5      	beq.n	1fb22 <silk_pitch_analysis_core+0x103e>
            pitch_out[ k ] = lag_new + matrix_ptr( Lag_CB_ptr, k, CBimax, cbk_size );
   1fbd6:	6d38      	ldr	r0, [r7, #80]	; 0x50
   1fbd8:	6e3c      	ldr	r4, [r7, #96]	; 0x60
   1fbda:	f913 1010 	ldrsb.w	r1, [r3, r0, lsl #1]
   1fbde:	4421      	add	r1, r4
            pitch_out[ k ] = silk_LIMIT( pitch_out[ k ], min_lag, PE_MAX_LAG_MS * Fs_kHz );
   1fbe0:	6dbc      	ldr	r4, [r7, #88]	; 0x58
   1fbe2:	42a1      	cmp	r1, r4
            pitch_out[ k ] = lag_new + matrix_ptr( Lag_CB_ptr, k, CBimax, cbk_size );
   1fbe4:	ea4f 0040 	mov.w	r0, r0, lsl #1
            pitch_out[ k ] = silk_LIMIT( pitch_out[ k ], min_lag, PE_MAX_LAG_MS * Fs_kHz );
   1fbe8:	dc78      	bgt.n	1fcdc <silk_pitch_analysis_core+0x11f8>
   1fbea:	6cfc      	ldr	r4, [r7, #76]	; 0x4c
   1fbec:	42a1      	cmp	r1, r4
   1fbee:	bfb8      	it	lt
   1fbf0:	4621      	movlt	r1, r4
   1fbf2:	6c7c      	ldr	r4, [r7, #68]	; 0x44
   1fbf4:	60a1      	str	r1, [r4, #8]
        for( k = 0; k < nb_subfr; k++ ) {
   1fbf6:	f8d7 1418 	ldr.w	r1, [r7, #1048]	; 0x418
   1fbfa:	2903      	cmp	r1, #3
   1fbfc:	d091      	beq.n	1fb22 <silk_pitch_analysis_core+0x103e>
            pitch_out[ k ] = lag_new + matrix_ptr( Lag_CB_ptr, k, CBimax, cbk_size );
   1fbfe:	6d39      	ldr	r1, [r7, #80]	; 0x50
   1fc00:	6e3c      	ldr	r4, [r7, #96]	; 0x60
   1fc02:	4408      	add	r0, r1
   1fc04:	5619      	ldrsb	r1, [r3, r0]
   1fc06:	4421      	add	r1, r4
            pitch_out[ k ] = silk_LIMIT( pitch_out[ k ], min_lag, PE_MAX_LAG_MS * Fs_kHz );
   1fc08:	6dbc      	ldr	r4, [r7, #88]	; 0x58
   1fc0a:	42a1      	cmp	r1, r4
   1fc0c:	dc76      	bgt.n	1fcfc <silk_pitch_analysis_core+0x1218>
   1fc0e:	6cfc      	ldr	r4, [r7, #76]	; 0x4c
   1fc10:	42a1      	cmp	r1, r4
   1fc12:	bfb8      	it	lt
   1fc14:	4621      	movlt	r1, r4
   1fc16:	6c7c      	ldr	r4, [r7, #68]	; 0x44
   1fc18:	60e1      	str	r1, [r4, #12]
        for( k = 0; k < nb_subfr; k++ ) {
   1fc1a:	f8d7 1418 	ldr.w	r1, [r7, #1048]	; 0x418
   1fc1e:	2904      	cmp	r1, #4
   1fc20:	f43f af7f 	beq.w	1fb22 <silk_pitch_analysis_core+0x103e>
            pitch_out[ k ] = lag_new + matrix_ptr( Lag_CB_ptr, k, CBimax, cbk_size );
   1fc24:	6d39      	ldr	r1, [r7, #80]	; 0x50
   1fc26:	440b      	add	r3, r1
   1fc28:	6e39      	ldr	r1, [r7, #96]	; 0x60
   1fc2a:	561b      	ldrsb	r3, [r3, r0]
   1fc2c:	440b      	add	r3, r1
            pitch_out[ k ] = silk_LIMIT( pitch_out[ k ], min_lag, PE_MAX_LAG_MS * Fs_kHz );
   1fc2e:	6db9      	ldr	r1, [r7, #88]	; 0x58
   1fc30:	4299      	cmp	r1, r3
   1fc32:	db65      	blt.n	1fd00 <silk_pitch_analysis_core+0x121c>
   1fc34:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
   1fc36:	4299      	cmp	r1, r3
   1fc38:	bfb8      	it	lt
   1fc3a:	4619      	movlt	r1, r3
   1fc3c:	460b      	mov	r3, r1
   1fc3e:	4621      	mov	r1, r4
   1fc40:	610b      	str	r3, [r1, #16]
   1fc42:	e76e      	b.n	1fb22 <silk_pitch_analysis_core+0x103e>
            nb_cbk_search   = (opus_int)silk_nb_cbk_searchs_stage3[ complexity ];
   1fc44:	4b31      	ldr	r3, [pc, #196]	; (1fd0c <silk_pitch_analysis_core+0x1228>)
   1fc46:	f8d7 1414 	ldr.w	r1, [r7, #1044]	; 0x414
        ALLOC( energies_st3, nb_subfr * nb_cbk_search, silk_pe_stage3_vals );
   1fc4a:	f8c7 d00c 	str.w	sp, [r7, #12]
            nb_cbk_search   = (opus_int)silk_nb_cbk_searchs_stage3[ complexity ];
   1fc4e:	f913 b001 	ldrsb.w	fp, [r3, r1]
        Lag_CB_ptr    = &silk_CB_lags_stage3[ 0 ][ 0 ];
   1fc52:	4b2f      	ldr	r3, [pc, #188]	; (1fd10 <silk_pitch_analysis_core+0x122c>)
   1fc54:	62fb      	str	r3, [r7, #44]	; 0x2c
        ALLOC( energies_st3, nb_subfr * nb_cbk_search, silk_pe_stage3_vals );
   1fc56:	ea4f 130b 	mov.w	r3, fp, lsl #4
   1fc5a:	eb03 038b 	add.w	r3, r3, fp, lsl #2
   1fc5e:	009b      	lsls	r3, r3, #2
   1fc60:	3308      	adds	r3, #8
   1fc62:	ebad 0d03 	sub.w	sp, sp, r3
    sf_length         = PE_SUBFR_LENGTH_MS * Fs_kHz;
   1fc66:	f8d7 1410 	ldr.w	r1, [r7, #1040]	; 0x410
        Lag_range_ptr = &silk_Lag_range_stage3[ complexity ][ 0 ][ 0 ];
   1fc6a:	4a2a      	ldr	r2, [pc, #168]	; (1fd14 <silk_pitch_analysis_core+0x1230>)
        ALLOC( energies_st3, nb_subfr * nb_cbk_search, silk_pe_stage3_vals );
   1fc6c:	a802      	add	r0, sp, #8
        ALLOC( cross_corr_st3, nb_subfr * nb_cbk_search, silk_pe_stage3_vals );
   1fc6e:	ebad 0d03 	sub.w	sp, sp, r3
    target_ptr = &frame[ silk_LSHIFT( sf_length, 2 ) ]; /* Pointer to middle of frame */
   1fc72:	6c3b      	ldr	r3, [r7, #64]	; 0x40
        ALLOC( energies_st3, nb_subfr * nb_cbk_search, silk_pe_stage3_vals );
   1fc74:	62b8      	str	r0, [r7, #40]	; 0x28
    sf_length         = PE_SUBFR_LENGTH_MS * Fs_kHz;
   1fc76:	eb01 0181 	add.w	r1, r1, r1, lsl #2
    target_ptr = &frame[ silk_LSHIFT( sf_length, 2 ) ]; /* Pointer to middle of frame */
   1fc7a:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
   1fc7e:	617b      	str	r3, [r7, #20]
        ALLOC( cross_corr_st3, nb_subfr * nb_cbk_search, silk_pe_stage3_vals );
   1fc80:	ab02      	add	r3, sp, #8
   1fc82:	627b      	str	r3, [r7, #36]	; 0x24
        Lag_range_ptr = &silk_Lag_range_stage3[ complexity ][ 0 ][ 0 ];
   1fc84:	f8d7 3414 	ldr.w	r3, [r7, #1044]	; 0x414
    sf_length         = PE_SUBFR_LENGTH_MS * Fs_kHz;
   1fc88:	63f9      	str	r1, [r7, #60]	; 0x3c
        Lag_range_ptr = &silk_Lag_range_stage3[ complexity ][ 0 ][ 0 ];
   1fc8a:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
        cbk_size      = PE_NB_CBKS_STAGE3_MAX;
   1fc8e:	2222      	movs	r2, #34	; 0x22
   1fc90:	653a      	str	r2, [r7, #80]	; 0x50
   1fc92:	e4a8      	b.n	1f5e6 <silk_pitch_analysis_core+0xb02>
   1fc94:	460b      	mov	r3, r1
   1fc96:	e6f0      	b.n	1fa7a <silk_pitch_analysis_core+0xf96>
   1fc98:	4613      	mov	r3, r2
   1fc9a:	663a      	str	r2, [r7, #96]	; 0x60
   1fc9c:	6db9      	ldr	r1, [r7, #88]	; 0x58
   1fc9e:	e443      	b.n	1f528 <silk_pitch_analysis_core+0xa44>
        if( Fs_kHz == 8 && complexity > SILK_PE_MIN_COMPLEX ) {
   1fca0:	f8d7 3414 	ldr.w	r3, [r7, #1044]	; 0x414
   1fca4:	2b00      	cmp	r3, #0
   1fca6:	f77f ae66 	ble.w	1f976 <silk_pitch_analysis_core+0xe92>
        Lag_CB_ptr = &silk_CB_lags_stage2[ 0 ][ 0 ];
   1fcaa:	4b1b      	ldr	r3, [pc, #108]	; (1fd18 <silk_pitch_analysis_core+0x1234>)
        cbk_size   = PE_NB_CBKS_STAGE2_EXT;
   1fcac:	250b      	movs	r5, #11
            nb_cbk_search = PE_NB_CBKS_STAGE2_EXT;
   1fcae:	e9c7 5315 	strd	r5, r3, [r7, #84]	; 0x54
   1fcb2:	f7ff ba70 	b.w	1f196 <silk_pitch_analysis_core+0x6b2>
   1fcb6:	f507 7333 	add.w	r3, r7, #716	; 0x2cc
   1fcba:	4618      	mov	r0, r3
   1fcbc:	f44f 7286 	mov.w	r2, #268	; 0x10c
   1fcc0:	2100      	movs	r1, #0
   1fcc2:	657b      	str	r3, [r7, #84]	; 0x54
   1fcc4:	f015 fa4e 	bl	35164 <memset>
   1fcc8:	f7ff b91a 	b.w	1ef00 <silk_pitch_analysis_core+0x41c>
   1fccc:	4623      	mov	r3, r4
   1fcce:	663c      	str	r4, [r7, #96]	; 0x60
   1fcd0:	4621      	mov	r1, r4
   1fcd2:	e429      	b.n	1f528 <silk_pitch_analysis_core+0xa44>
   1fcd4:	460b      	mov	r3, r1
   1fcd6:	e763      	b.n	1fba0 <silk_pitch_analysis_core+0x10bc>
   1fcd8:	4621      	mov	r1, r4
   1fcda:	e70b      	b.n	1faf4 <silk_pitch_analysis_core+0x1010>
   1fcdc:	4621      	mov	r1, r4
   1fcde:	e788      	b.n	1fbf2 <silk_pitch_analysis_core+0x110e>
   1fce0:	4601      	mov	r1, r0
   1fce2:	e772      	b.n	1fbca <silk_pitch_analysis_core+0x10e6>
        for( d = start_lag; d <= end_lag; d++ ) {
   1fce4:	2200      	movs	r2, #0
        CBimax    = 0;                                      /* to avoid undefined lag */
   1fce6:	63fa      	str	r2, [r7, #60]	; 0x3c
   1fce8:	e6b3      	b.n	1fa52 <silk_pitch_analysis_core+0xf6e>
        Lag_CB_ptr    = &silk_CB_lags_stage3_10_ms[ 0 ][ 0 ];
   1fcea:	4b0c      	ldr	r3, [pc, #48]	; (1fd1c <silk_pitch_analysis_core+0x1238>)
        cbk_size      = PE_NB_CBKS_STAGE3_10MS;
   1fcec:	f8c7 b050 	str.w	fp, [r7, #80]	; 0x50
        Lag_CB_ptr    = &silk_CB_lags_stage3_10_ms[ 0 ][ 0 ];
   1fcf0:	62fb      	str	r3, [r7, #44]	; 0x2c
   1fcf2:	e560      	b.n	1f7b6 <silk_pitch_analysis_core+0xcd2>
   1fcf4:	4601      	mov	r1, r0
   1fcf6:	e6d5      	b.n	1faa4 <silk_pitch_analysis_core+0xfc0>
   1fcf8:	4621      	mov	r1, r4
   1fcfa:	e6e8      	b.n	1face <silk_pitch_analysis_core+0xfea>
   1fcfc:	4621      	mov	r1, r4
   1fcfe:	e78a      	b.n	1fc16 <silk_pitch_analysis_core+0x1132>
   1fd00:	460b      	mov	r3, r1
   1fd02:	4621      	mov	r1, r4
   1fd04:	e79c      	b.n	1fc40 <silk_pitch_analysis_core+0x115c>
   1fd06:	66fe      	str	r6, [r7, #108]	; 0x6c
   1fd08:	e6a1      	b.n	1fa4e <silk_pitch_analysis_core+0xf6a>
   1fd0a:	bf00      	nop
   1fd0c:	000375e4 	.word	0x000375e4
   1fd10:	00037528 	.word	0x00037528
   1fd14:	000375c8 	.word	0x000375c8
   1fd18:	000374f4 	.word	0x000374f4
   1fd1c:	000375b0 	.word	0x000375b0

0001fd20 <silk_scale_copy_vector16>:
)
{
    opus_int  i;
    opus_int32 tmp32;

    for( i = 0; i < dataSize; i++ ) {
   1fd20:	2b00      	cmp	r3, #0
   1fd22:	dd14      	ble.n	1fd4e <silk_scale_copy_vector16+0x2e>
   1fd24:	3902      	subs	r1, #2
{
   1fd26:	b470      	push	{r4, r5, r6}
   1fd28:	eb01 0343 	add.w	r3, r1, r3, lsl #1
        tmp32 = silk_SMULWB( gain_Q16, data_in[ i ] );
   1fd2c:	1416      	asrs	r6, r2, #16
   1fd2e:	3802      	subs	r0, #2
   1fd30:	b292      	uxth	r2, r2
   1fd32:	f931 4f02 	ldrsh.w	r4, [r1, #2]!
   1fd36:	fb02 f504 	mul.w	r5, r2, r4
   1fd3a:	fb04 f406 	mul.w	r4, r4, r6
   1fd3e:	eb04 4425 	add.w	r4, r4, r5, asr #16
    for( i = 0; i < dataSize; i++ ) {
   1fd42:	428b      	cmp	r3, r1
        data_out[ i ] = (opus_int16)silk_CHECK_FIT16( tmp32 );
   1fd44:	f820 4f02 	strh.w	r4, [r0, #2]!
    for( i = 0; i < dataSize; i++ ) {
   1fd48:	d1f3      	bne.n	1fd32 <silk_scale_copy_vector16+0x12>
    }
}
   1fd4a:	bc70      	pop	{r4, r5, r6}
   1fd4c:	4770      	bx	lr
   1fd4e:	4770      	bx	lr

0001fd50 <silk_inner_prod_aligned>:
static OPUS_INLINE opus_val32 celt_inner_prod_c(const opus_val16 *x,
      const opus_val16 *y, int N)
{
   int i;
   opus_val32 xy=0;
   for (i=0;i<N;i++)
   1fd50:	2a00      	cmp	r2, #0
   1fd52:	dd10      	ble.n	1fd76 <silk_inner_prod_aligned+0x26>
   1fd54:	eb00 0242 	add.w	r2, r0, r2, lsl #1
    const opus_int16 *const     inVec1,             /*    I input vector 1                                              */
    const opus_int16 *const     inVec2,             /*    I input vector 2                                              */
    const opus_int              len,                /*    I vector lengths                                              */
    int                         arch                /*    I Run-time architecture                                       */
)
{
   1fd58:	b430      	push	{r4, r5}
   1fd5a:	1e83      	subs	r3, r0, #2
   1fd5c:	1e95      	subs	r5, r2, #2
   1fd5e:	3902      	subs	r1, #2
   opus_val32 xy=0;
   1fd60:	2000      	movs	r0, #0
      xy = MAC16_16(xy, x[i], y[i]);
   1fd62:	f833 4f02 	ldrh.w	r4, [r3, #2]!
   1fd66:	f831 2f02 	ldrh.w	r2, [r1, #2]!
   for (i=0;i<N;i++)
   1fd6a:	429d      	cmp	r5, r3
      xy = MAC16_16(xy, x[i], y[i]);
   1fd6c:	fb14 0002 	smlabb	r0, r4, r2, r0
   for (i=0;i<N;i++)
   1fd70:	d1f7      	bne.n	1fd62 <silk_inner_prod_aligned+0x12>
    for( i = 0; i < len; i++ ) {
        sum = silk_SMLABB( sum, inVec1[ i ], inVec2[ i ] );
    }
    return sum;
#endif
}
   1fd72:	bc30      	pop	{r4, r5}
   1fd74:	4770      	bx	lr
   opus_val32 xy=0;
   1fd76:	2000      	movs	r0, #0
   1fd78:	4770      	bx	lr
   1fd7a:	bf00      	nop

0001fd7c <silk_inner_prod16_aligned_64_c>:
    const opus_int              len                 /*    I vector lengths                                              */
)
{
    opus_int   i;
    opus_int64 sum = 0;
    for( i = 0; i < len; i++ ) {
   1fd7c:	2a00      	cmp	r2, #0
{
   1fd7e:	b470      	push	{r4, r5, r6}
    for( i = 0; i < len; i++ ) {
   1fd80:	dd11      	ble.n	1fda6 <silk_inner_prod16_aligned_64_c+0x2a>
   1fd82:	1e83      	subs	r3, r0, #2
   1fd84:	eb03 0242 	add.w	r2, r3, r2, lsl #1
   1fd88:	3902      	subs	r1, #2
    opus_int64 sum = 0;
   1fd8a:	2400      	movs	r4, #0
   1fd8c:	2500      	movs	r5, #0
        sum = silk_SMLALBB( sum, inVec1[ i ], inVec2[ i ] );
   1fd8e:	f833 6f02 	ldrh.w	r6, [r3, #2]!
   1fd92:	f831 0f02 	ldrh.w	r0, [r1, #2]!
    for( i = 0; i < len; i++ ) {
   1fd96:	429a      	cmp	r2, r3
        sum = silk_SMLALBB( sum, inVec1[ i ], inVec2[ i ] );
   1fd98:	fbc6 4580 	smlalbb	r4, r5, r6, r0
    for( i = 0; i < len; i++ ) {
   1fd9c:	d1f7      	bne.n	1fd8e <silk_inner_prod16_aligned_64_c+0x12>
    }
    return sum;
}
   1fd9e:	4620      	mov	r0, r4
   1fda0:	4629      	mov	r1, r5
   1fda2:	bc70      	pop	{r4, r5, r6}
   1fda4:	4770      	bx	lr
    opus_int64 sum = 0;
   1fda6:	2400      	movs	r4, #0
   1fda8:	2500      	movs	r5, #0
}
   1fdaa:	4620      	mov	r0, r4
   1fdac:	4629      	mov	r1, r5
   1fdae:	bc70      	pop	{r4, r5, r6}
   1fdb0:	4770      	bx	lr
   1fdb2:	bf00      	nop

0001fdb4 <silk_schur64>:
opus_int32 silk_schur64(                            /* O    returns residual energy                                     */
    opus_int32                  rc_Q16[],           /* O    Reflection coefficients [order] Q16                         */
    const opus_int32            c[],                /* I    Correlations [order+1]                                      */
    opus_int32                  order               /* I    Prediction order                                            */
)
{
   1fdb4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    opus_int32 Ctmp1_Q30, Ctmp2_Q30, rc_tmp_Q31;

    celt_assert( order >= 0 && order <= SILK_MAX_ORDER_LPC );

    /* Check for invalid input */
    if( c[ 0 ] <= 0 ) {
   1fdb8:	680b      	ldr	r3, [r1, #0]
{
   1fdba:	b0b5      	sub	sp, #212	; 0xd4
    if( c[ 0 ] <= 0 ) {
   1fdbc:	2b00      	cmp	r3, #0
{
   1fdbe:	9001      	str	r0, [sp, #4]
    if( c[ 0 ] <= 0 ) {
   1fdc0:	f340 80d3 	ble.w	1ff6a <silk_schur64+0x1b6>
   1fdc4:	3904      	subs	r1, #4
   1fdc6:	a802      	add	r0, sp, #8
        silk_memset( rc_Q16, 0, order * sizeof( opus_int32 ) );
        return 0;
    }

    k = 0;
   1fdc8:	2300      	movs	r3, #0
    do {
        C[ k ][ 0 ] = C[ k ][ 1 ] = c[ k ];
   1fdca:	ad02      	add	r5, sp, #8
   1fdcc:	f851 4f04 	ldr.w	r4, [r1, #4]!
   1fdd0:	6044      	str	r4, [r0, #4]
   1fdd2:	f845 4033 	str.w	r4, [r5, r3, lsl #3]
    } while( ++k <= order );
   1fdd6:	3301      	adds	r3, #1
   1fdd8:	4293      	cmp	r3, r2
   1fdda:	f100 0008 	add.w	r0, r0, #8
   1fdde:	ddf4      	ble.n	1fdca <silk_schur64+0x16>

    for( k = 0; k < order; k++ ) {
   1fde0:	2a00      	cmp	r2, #0
   1fde2:	9c03      	ldr	r4, [sp, #12]
   1fde4:	f340 8099 	ble.w	1ff1a <silk_schur64+0x166>
        /* Check that we won't be getting an unstable rc, otherwise stop here. */
        if (silk_abs_int32(C[ k + 1 ][ 0 ]) >= C[ 0 ][ 1 ]) {
   1fde8:	9b04      	ldr	r3, [sp, #16]
   1fdea:	ea83 71e3 	eor.w	r1, r3, r3, asr #31
   1fdee:	eb01 71d3 	add.w	r1, r1, r3, lsr #31
   1fdf2:	42a1      	cmp	r1, r4
   1fdf4:	f280 80c1 	bge.w	1ff7a <silk_schur64+0x1c6>
   1fdf8:	9901      	ldr	r1, [sp, #4]
   1fdfa:	f04f 0c01 	mov.w	ip, #1
   1fdfe:	f1a1 0a04 	sub.w	sl, r1, #4
   1fe02:	a902      	add	r1, sp, #8
   1fe04:	eb01 05c2 	add.w	r5, r1, r2, lsl #3
   1fe08:	468e      	mov	lr, r1
   1fe0a:	eb02 010c 	add.w	r1, r2, ip
   1fe0e:	46a9      	mov	r9, r5
   1fe10:	9100      	str	r1, [sp, #0]
   1fe12:	461d      	mov	r5, r3
           k++;
           break;
        }

        /* Get reflection coefficient: divide two Q30 values and get result in Q31 */
        rc_tmp_Q31 = silk_DIV32_varQ( -C[ k + 1 ][ 0 ], C[ 0 ][ 1 ], 31 );
   1fe14:	f1c5 0800 	rsb	r8, r5, #0
   1fe18:	2d00      	cmp	r5, #0
   1fe1a:	f000 8087 	beq.w	1ff2c <silk_schur64+0x178>
    a_headrm = silk_CLZ32( silk_abs(a32) ) - 1;
   1fe1e:	2d00      	cmp	r5, #0
   1fe20:	bfb8      	it	lt
   1fe22:	426d      	neglt	r5, r5
   1fe24:	fab5 f585 	clz	r5, r5
   1fe28:	1e6b      	subs	r3, r5, #1
   1fe2a:	351c      	adds	r5, #28
    a32_nrm = silk_LSHIFT(a32, a_headrm);                                       /* Q: a_headrm                  */
   1fe2c:	fa08 f803 	lsl.w	r8, r8, r3
   1fe30:	2c00      	cmp	r4, #0
   1fe32:	d079      	beq.n	1ff28 <silk_schur64+0x174>
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
   1fe34:	ea84 77e4 	eor.w	r7, r4, r4, asr #31
   1fe38:	eba7 77e4 	sub.w	r7, r7, r4, asr #31
   1fe3c:	fab7 f787 	clz	r7, r7
   1fe40:	3f01      	subs	r7, #1
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                  */
   1fe42:	fa04 f007 	lsl.w	r0, r4, r7
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1fe46:	1403      	asrs	r3, r0, #16
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1fe48:	fa1f f188 	uxth.w	r1, r8
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm        */
   1fe4c:	f06f 4660 	mvn.w	r6, #3758096384	; 0xe0000000
   1fe50:	fb96 f3f3 	sdiv	r3, r6, r3
    result = silk_SMULWB(a32_nrm, b32_inv);                                     /* Q: 29 + a_headrm - b_headrm  */
   1fe54:	ea4f 4628 	mov.w	r6, r8, asr #16
   1fe58:	b21b      	sxth	r3, r3
   1fe5a:	fb03 f101 	mul.w	r1, r3, r1
   1fe5e:	fb03 f606 	mul.w	r6, r3, r6
   1fe62:	eb06 4621 	add.w	r6, r6, r1, asr #16
    a32_nrm = silk_SUB32_ovflw(a32_nrm, silk_LSHIFT_ovflw( silk_SMMUL(b32_nrm, result), 3 ));  /* Q: a_headrm   */
   1fe66:	fb80 0106 	smull	r0, r1, r0, r6
   1fe6a:	eba8 08c1 	sub.w	r8, r8, r1, lsl #3
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1fe6e:	fa1f f188 	uxth.w	r1, r8
   1fe72:	ea4f 4828 	mov.w	r8, r8, asr #16
   1fe76:	fb03 f101 	mul.w	r1, r3, r1
    lshift = 29 + a_headrm - b_headrm - Qres;
   1fe7a:	1bed      	subs	r5, r5, r7
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1fe7c:	fb03 f308 	mul.w	r3, r3, r8
   1fe80:	eb03 4321 	add.w	r3, r3, r1, asr #16
    if( lshift < 0 ) {
   1fe84:	f1b5 011f 	subs.w	r1, r5, #31
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
   1fe88:	4433      	add	r3, r6
    if( lshift < 0 ) {
   1fe8a:	d452      	bmi.n	1ff32 <silk_schur64+0x17e>
            return silk_RSHIFT(result, lshift);
   1fe8c:	fa43 f101 	asr.w	r1, r3, r1

        /* Save the output */
        rc_Q16[ k ] = silk_RSHIFT_ROUND( rc_tmp_Q31, 15 );

        /* Update correlations */
        for( n = 0; n < order - k; n++ ) {
   1fe90:	9800      	ldr	r0, [sp, #0]
        rc_Q16[ k ] = silk_RSHIFT_ROUND( rc_tmp_Q31, 15 );
   1fe92:	138b      	asrs	r3, r1, #14
   1fe94:	3301      	adds	r3, #1
        for( n = 0; n < order - k; n++ ) {
   1fe96:	eba0 000c 	sub.w	r0, r0, ip
        rc_Q16[ k ] = silk_RSHIFT_ROUND( rc_tmp_Q31, 15 );
   1fe9a:	105b      	asrs	r3, r3, #1
        for( n = 0; n < order - k; n++ ) {
   1fe9c:	2800      	cmp	r0, #0
        rc_Q16[ k ] = silk_RSHIFT_ROUND( rc_tmp_Q31, 15 );
   1fe9e:	f84a 3f04 	str.w	r3, [sl, #4]!
   1fea2:	46e3      	mov	fp, ip
        for( n = 0; n < order - k; n++ ) {
   1fea4:	dd14      	ble.n	1fed0 <silk_schur64+0x11c>
   1fea6:	ab02      	add	r3, sp, #8
   1fea8:	46f0      	mov	r8, lr
            Ctmp1_Q30 = C[ n + k + 1 ][ 0 ];
   1feaa:	f8d8 0008 	ldr.w	r0, [r8, #8]
            Ctmp2_Q30 = C[ n ][ 1 ];
   1feae:	685d      	ldr	r5, [r3, #4]

            /* Multiply and add the highest int32 */
            C[ n + k + 1 ][ 0 ] = Ctmp1_Q30 + silk_SMMUL( silk_LSHIFT( Ctmp2_Q30, 1 ), rc_tmp_Q31 );
            C[ n ][ 1 ]         = Ctmp2_Q30 + silk_SMMUL( silk_LSHIFT( Ctmp1_Q30, 1 ), rc_tmp_Q31 );
   1feb0:	0046      	lsls	r6, r0, #1
            C[ n + k + 1 ][ 0 ] = Ctmp1_Q30 + silk_SMMUL( silk_LSHIFT( Ctmp2_Q30, 1 ), rc_tmp_Q31 );
   1feb2:	006c      	lsls	r4, r5, #1
            C[ n ][ 1 ]         = Ctmp2_Q30 + silk_SMMUL( silk_LSHIFT( Ctmp1_Q30, 1 ), rc_tmp_Q31 );
   1feb4:	fb86 6701 	smull	r6, r7, r6, r1
   1feb8:	19ee      	adds	r6, r5, r7
            C[ n + k + 1 ][ 0 ] = Ctmp1_Q30 + silk_SMMUL( silk_LSHIFT( Ctmp2_Q30, 1 ), rc_tmp_Q31 );
   1feba:	fb84 4501 	smull	r4, r5, r4, r1
   1febe:	4428      	add	r0, r5
   1fec0:	f848 0f08 	str.w	r0, [r8, #8]!
   1fec4:	3308      	adds	r3, #8
            C[ n ][ 1 ]         = Ctmp2_Q30 + silk_SMMUL( silk_LSHIFT( Ctmp1_Q30, 1 ), rc_tmp_Q31 );
   1fec6:	f843 6c04 	str.w	r6, [r3, #-4]
        for( n = 0; n < order - k; n++ ) {
   1feca:	454b      	cmp	r3, r9
   1fecc:	d1ed      	bne.n	1feaa <silk_schur64+0xf6>
   1fece:	9c03      	ldr	r4, [sp, #12]
    for( k = 0; k < order; k++ ) {
   1fed0:	4594      	cmp	ip, r2
   1fed2:	d022      	beq.n	1ff1a <silk_schur64+0x166>
        if (silk_abs_int32(C[ k + 1 ][ 0 ]) >= C[ 0 ][ 1 ]) {
   1fed4:	f8de 5010 	ldr.w	r5, [lr, #16]
   1fed8:	ea85 71e5 	eor.w	r1, r5, r5, asr #31
   1fedc:	eb01 71d5 	add.w	r1, r1, r5, lsr #31
   1fee0:	42a1      	cmp	r1, r4
   1fee2:	f10c 0c01 	add.w	ip, ip, #1
   1fee6:	f1a9 0908 	sub.w	r9, r9, #8
   1feea:	f10e 0e08 	add.w	lr, lr, #8
   1feee:	db91      	blt.n	1fe14 <silk_schur64+0x60>
   1fef0:	9901      	ldr	r1, [sp, #4]
   1fef2:	462b      	mov	r3, r5
   1fef4:	eb01 008b 	add.w	r0, r1, fp, lsl #2
           if ( C[ k + 1 ][ 0 ] > 0 ) {
   1fef8:	2b00      	cmp	r3, #0
              rc_Q16[ k ] = -SILK_FIX_CONST( .99f, 16 );
   1fefa:	bfcc      	ite	gt
   1fefc:	4b21      	ldrgt	r3, [pc, #132]	; (1ff84 <silk_schur64+0x1d0>)
              rc_Q16[ k ] = SILK_FIX_CONST( .99f, 16 );
   1fefe:	f64f 5371 	movwle	r3, #64881	; 0xfd71
        }
    }

    for(; k < order; k++ ) {
   1ff02:	4562      	cmp	r2, ip
              rc_Q16[ k ] = SILK_FIX_CONST( .99f, 16 );
   1ff04:	6003      	str	r3, [r0, #0]
    for(; k < order; k++ ) {
   1ff06:	dd08      	ble.n	1ff1a <silk_schur64+0x166>
   1ff08:	9b01      	ldr	r3, [sp, #4]
       rc_Q16[ k ] = 0;
   1ff0a:	eba2 020c 	sub.w	r2, r2, ip
   1ff0e:	0092      	lsls	r2, r2, #2
   1ff10:	eb03 008c 	add.w	r0, r3, ip, lsl #2
   1ff14:	2100      	movs	r1, #0
   1ff16:	f015 f925 	bl	35164 <memset>
    return (((a) > (b)) ? (a) : (b));
   1ff1a:	2c01      	cmp	r4, #1
   1ff1c:	4620      	mov	r0, r4
   1ff1e:	bfb8      	it	lt
   1ff20:	2001      	movlt	r0, #1
    }

    return silk_max_32( 1, C[ 0 ][ 1 ] );
}
   1ff22:	b035      	add	sp, #212	; 0xd4
   1ff24:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1ff28:	271f      	movs	r7, #31
   1ff2a:	e78a      	b.n	1fe42 <silk_schur64+0x8e>
   1ff2c:	253c      	movs	r5, #60	; 0x3c
   1ff2e:	231f      	movs	r3, #31
   1ff30:	e77c      	b.n	1fe2c <silk_schur64+0x78>
        return silk_LSHIFT_SAT32(result, -lshift);
   1ff32:	f1c5 051f 	rsb	r5, r5, #31
   1ff36:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
   1ff3a:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   1ff3e:	4129      	asrs	r1, r5
   1ff40:	4128      	asrs	r0, r5
   1ff42:	4281      	cmp	r1, r0
   1ff44:	dd03      	ble.n	1ff4e <silk_schur64+0x19a>
   1ff46:	428b      	cmp	r3, r1
   1ff48:	dd0b      	ble.n	1ff62 <silk_schur64+0x1ae>
   1ff4a:	460b      	mov	r3, r1
   1ff4c:	e004      	b.n	1ff58 <silk_schur64+0x1a4>
   1ff4e:	4283      	cmp	r3, r0
   1ff50:	dc05      	bgt.n	1ff5e <silk_schur64+0x1aa>
   1ff52:	428b      	cmp	r3, r1
   1ff54:	bfb8      	it	lt
   1ff56:	460b      	movlt	r3, r1
   1ff58:	fa03 f105 	lsl.w	r1, r3, r5
   1ff5c:	e798      	b.n	1fe90 <silk_schur64+0xdc>
   1ff5e:	4603      	mov	r3, r0
   1ff60:	e7fa      	b.n	1ff58 <silk_schur64+0x1a4>
   1ff62:	4283      	cmp	r3, r0
   1ff64:	bfb8      	it	lt
   1ff66:	4603      	movlt	r3, r0
   1ff68:	e7f6      	b.n	1ff58 <silk_schur64+0x1a4>
        silk_memset( rc_Q16, 0, order * sizeof( opus_int32 ) );
   1ff6a:	0092      	lsls	r2, r2, #2
   1ff6c:	2100      	movs	r1, #0
   1ff6e:	f015 f8f9 	bl	35164 <memset>
        return 0;
   1ff72:	2000      	movs	r0, #0
}
   1ff74:	b035      	add	sp, #212	; 0xd4
   1ff76:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (silk_abs_int32(C[ k + 1 ][ 0 ]) >= C[ 0 ][ 1 ]) {
   1ff7a:	9801      	ldr	r0, [sp, #4]
   1ff7c:	f04f 0c01 	mov.w	ip, #1
   1ff80:	e7ba      	b.n	1fef8 <silk_schur64+0x144>
   1ff82:	bf00      	nop
   1ff84:	ffff028f 	.word	0xffff028f

0001ff88 <silk_schur>:
opus_int32 silk_schur(                              /* O    Returns residual energy                                     */
    opus_int16                  *rc_Q15,            /* O    reflection coefficients [order] Q15                         */
    const opus_int32            *c,                 /* I    correlations [order+1]                                      */
    const opus_int32            order               /* I    prediction order                                            */
)
{
   1ff88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    opus_int32    Ctmp1, Ctmp2, rc_tmp_Q15;

    celt_assert( order >= 0 && order <= SILK_MAX_ORDER_LPC );

    /* Get number of leading zeros */
    lz = silk_CLZ32( c[ 0 ] );
   1ff8c:	680b      	ldr	r3, [r1, #0]
{
   1ff8e:	b0b7      	sub	sp, #220	; 0xdc
   1ff90:	9003      	str	r0, [sp, #12]
   1ff92:	2b00      	cmp	r3, #0
   1ff94:	f000 8099 	beq.w	200ca <silk_schur+0x142>
   1ff98:	fab3 f383 	clz	r3, r3

    /* Copy correlations and adjust level to Q30 */
    k = 0;
    if( lz < 2 ) {
   1ff9c:	2b01      	cmp	r3, #1
   1ff9e:	f340 80a9 	ble.w	200f4 <silk_schur+0x16c>
        /* lz must be 1, so shift one to the right */
        do {
            C[ k ][ 0 ] = C[ k ][ 1 ] = silk_RSHIFT( c[ k ], 1 );
        } while( ++k <= order );
    } else if( lz > 2 ) {
   1ffa2:	2b02      	cmp	r3, #2
   1ffa4:	f040 80bf 	bne.w	20126 <silk_schur+0x19e>
   1ffa8:	f10d 0b10 	add.w	fp, sp, #16
   1ffac:	1f0b      	subs	r3, r1, #4
   1ffae:	4658      	mov	r0, fp
    k = 0;
   1ffb0:	2100      	movs	r1, #0
            C[ k ][ 0 ] = C[ k ][ 1 ] = silk_LSHIFT( c[ k ], lz );
        } while( ++k <= order );
    } else {
        /* No need to shift */
        do {
            C[ k ][ 0 ] = C[ k ][ 1 ] = c[ k ];
   1ffb2:	f853 4f04 	ldr.w	r4, [r3, #4]!
   1ffb6:	6044      	str	r4, [r0, #4]
   1ffb8:	f84b 4031 	str.w	r4, [fp, r1, lsl #3]
        } while( ++k <= order );
   1ffbc:	3101      	adds	r1, #1
   1ffbe:	4291      	cmp	r1, r2
   1ffc0:	f100 0008 	add.w	r0, r0, #8
   1ffc4:	ddf5      	ble.n	1ffb2 <silk_schur+0x2a>
    }

    for( k = 0; k < order; k++ ) {
   1ffc6:	2a00      	cmp	r2, #0
   1ffc8:	9c05      	ldr	r4, [sp, #20]
   1ffca:	dd77      	ble.n	200bc <silk_schur+0x134>
        /* Check that we won't be getting an unstable rc, otherwise stop here. */
        if (silk_abs_int32(C[ k + 1 ][ 0 ]) >= C[ 0 ][ 1 ]) {
   1ffcc:	9b06      	ldr	r3, [sp, #24]
   1ffce:	ea83 71e3 	eor.w	r1, r3, r3, asr #31
   1ffd2:	eb01 71d3 	add.w	r1, r1, r3, lsr #31
   1ffd6:	42a1      	cmp	r1, r4
   1ffd8:	f280 80a1 	bge.w	2011e <silk_schur+0x196>
   1ffdc:	9903      	ldr	r1, [sp, #12]
   1ffde:	f8cd b008 	str.w	fp, [sp, #8]
   1ffe2:	f04f 0a01 	mov.w	sl, #1
   1ffe6:	3902      	subs	r1, #2
   1ffe8:	eb02 050a 	add.w	r5, r2, sl
   1ffec:	eb0b 09c2 	add.w	r9, fp, r2, lsl #3
   1fff0:	4658      	mov	r0, fp
   1fff2:	9500      	str	r5, [sp, #0]
   1fff4:	468b      	mov	fp, r1
           k++;
           break;
        }

        /* Get reflection coefficient */
        rc_tmp_Q15 = -silk_DIV32_16( C[ k + 1 ][ 0 ], silk_max_32( silk_RSHIFT( C[ 0 ][ 1 ], 15 ), 1 ) );
   1fff6:	ea4f 3ce4 	mov.w	ip, r4, asr #15

        /* Clip (shouldn't happen for properly conditioned inputs) */
        rc_tmp_Q15 = silk_SAT16( rc_tmp_Q15 );
   1fffa:	494c      	ldr	r1, [pc, #304]	; (2012c <silk_schur+0x1a4>)
   1fffc:	f1bc 0f01 	cmp.w	ip, #1
   20000:	bfb8      	it	lt
   20002:	f04f 0c01 	movlt.w	ip, #1
        rc_tmp_Q15 = -silk_DIV32_16( C[ k + 1 ][ 0 ], silk_max_32( silk_RSHIFT( C[ 0 ][ 1 ], 15 ), 1 ) );
   20006:	fb93 f3fc 	sdiv	r3, r3, ip
        rc_tmp_Q15 = silk_SAT16( rc_tmp_Q15 );
   2000a:	428b      	cmp	r3, r1
   2000c:	db6f      	blt.n	200ee <silk_schur+0x166>
        rc_tmp_Q15 = -silk_DIV32_16( C[ k + 1 ][ 0 ], silk_max_32( silk_RSHIFT( C[ 0 ][ 1 ], 15 ), 1 ) );
   2000e:	425b      	negs	r3, r3
        rc_tmp_Q15 = silk_SAT16( rc_tmp_Q15 );
   20010:	3901      	subs	r1, #1
   20012:	428b      	cmp	r3, r1
   20014:	bfb8      	it	lt
   20016:	460b      	movlt	r3, r1
   20018:	fa0f fc83 	sxth.w	ip, r3

        /* Store */
        rc_Q15[ k ] = (opus_int16)rc_tmp_Q15;

        /* Update correlations */
        for( n = 0; n < order - k; n++ ) {
   2001c:	9b00      	ldr	r3, [sp, #0]
        rc_Q15[ k ] = (opus_int16)rc_tmp_Q15;
   2001e:	f82b cf02 	strh.w	ip, [fp, #2]!
        for( n = 0; n < order - k; n++ ) {
   20022:	eba3 030a 	sub.w	r3, r3, sl
   20026:	2b00      	cmp	r3, #0
   20028:	f8cd a004 	str.w	sl, [sp, #4]
   2002c:	dd23      	ble.n	20076 <silk_schur+0xee>
   2002e:	f8dd e008 	ldr.w	lr, [sp, #8]
   20032:	4680      	mov	r8, r0
            Ctmp1 = C[ n + k + 1 ][ 0 ];
            Ctmp2 = C[ n ][ 1 ];
   20034:	f8de 5004 	ldr.w	r5, [lr, #4]
            Ctmp1 = C[ n + k + 1 ][ 0 ];
   20038:	f8d8 4008 	ldr.w	r4, [r8, #8]
            C[ n + k + 1 ][ 0 ] = silk_SMLAWB( Ctmp1, silk_LSHIFT( Ctmp2, 1 ), rc_tmp_Q15 );
   2003c:	0069      	lsls	r1, r5, #1
            C[ n ][ 1 ]         = silk_SMLAWB( Ctmp2, silk_LSHIFT( Ctmp1, 1 ), rc_tmp_Q15 );
   2003e:	0063      	lsls	r3, r4, #1
   20040:	b29f      	uxth	r7, r3
            C[ n + k + 1 ][ 0 ] = silk_SMLAWB( Ctmp1, silk_LSHIFT( Ctmp2, 1 ), rc_tmp_Q15 );
   20042:	b28e      	uxth	r6, r1
            C[ n ][ 1 ]         = silk_SMLAWB( Ctmp2, silk_LSHIFT( Ctmp1, 1 ), rc_tmp_Q15 );
   20044:	141b      	asrs	r3, r3, #16
            C[ n + k + 1 ][ 0 ] = silk_SMLAWB( Ctmp1, silk_LSHIFT( Ctmp2, 1 ), rc_tmp_Q15 );
   20046:	1409      	asrs	r1, r1, #16
            C[ n ][ 1 ]         = silk_SMLAWB( Ctmp2, silk_LSHIFT( Ctmp1, 1 ), rc_tmp_Q15 );
   20048:	fb0c f707 	mul.w	r7, ip, r7
   2004c:	fb0c f303 	mul.w	r3, ip, r3
            C[ n + k + 1 ][ 0 ] = silk_SMLAWB( Ctmp1, silk_LSHIFT( Ctmp2, 1 ), rc_tmp_Q15 );
   20050:	fb0c f606 	mul.w	r6, ip, r6
   20054:	fb0c f101 	mul.w	r1, ip, r1
            C[ n ][ 1 ]         = silk_SMLAWB( Ctmp2, silk_LSHIFT( Ctmp1, 1 ), rc_tmp_Q15 );
   20058:	eb03 4327 	add.w	r3, r3, r7, asr #16
            C[ n + k + 1 ][ 0 ] = silk_SMLAWB( Ctmp1, silk_LSHIFT( Ctmp2, 1 ), rc_tmp_Q15 );
   2005c:	eb01 4126 	add.w	r1, r1, r6, asr #16
            C[ n ][ 1 ]         = silk_SMLAWB( Ctmp2, silk_LSHIFT( Ctmp1, 1 ), rc_tmp_Q15 );
   20060:	442b      	add	r3, r5
            C[ n + k + 1 ][ 0 ] = silk_SMLAWB( Ctmp1, silk_LSHIFT( Ctmp2, 1 ), rc_tmp_Q15 );
   20062:	4421      	add	r1, r4
   20064:	f848 1f08 	str.w	r1, [r8, #8]!
   20068:	f10e 0e08 	add.w	lr, lr, #8
            C[ n ][ 1 ]         = silk_SMLAWB( Ctmp2, silk_LSHIFT( Ctmp1, 1 ), rc_tmp_Q15 );
   2006c:	f84e 3c04 	str.w	r3, [lr, #-4]
        for( n = 0; n < order - k; n++ ) {
   20070:	45ce      	cmp	lr, r9
   20072:	d1df      	bne.n	20034 <silk_schur+0xac>
   20074:	9c05      	ldr	r4, [sp, #20]
    for( k = 0; k < order; k++ ) {
   20076:	4552      	cmp	r2, sl
   20078:	d020      	beq.n	200bc <silk_schur+0x134>
        if (silk_abs_int32(C[ k + 1 ][ 0 ]) >= C[ 0 ][ 1 ]) {
   2007a:	6903      	ldr	r3, [r0, #16]
   2007c:	ea83 71e3 	eor.w	r1, r3, r3, asr #31
   20080:	eb01 71d3 	add.w	r1, r1, r3, lsr #31
   20084:	42a1      	cmp	r1, r4
   20086:	f10a 0a01 	add.w	sl, sl, #1
   2008a:	f1a9 0908 	sub.w	r9, r9, #8
   2008e:	f100 0008 	add.w	r0, r0, #8
   20092:	dbb0      	blt.n	1fff6 <silk_schur+0x6e>
   20094:	9903      	ldr	r1, [sp, #12]
   20096:	9801      	ldr	r0, [sp, #4]
   20098:	eb01 0140 	add.w	r1, r1, r0, lsl #1
           if ( C[ k + 1 ][ 0 ] > 0 ) {
   2009c:	2b00      	cmp	r3, #0
   2009e:	dd3a      	ble.n	20116 <silk_schur+0x18e>
              rc_Q15[ k ] = -SILK_FIX_CONST( .99f, 15 );
   200a0:	f248 1348 	movw	r3, #33096	; 0x8148
   200a4:	800b      	strh	r3, [r1, #0]
        }
    }

    for(; k < order; k++ ) {
   200a6:	4552      	cmp	r2, sl
   200a8:	dd08      	ble.n	200bc <silk_schur+0x134>
   200aa:	9803      	ldr	r0, [sp, #12]
       rc_Q15[ k ] = 0;
   200ac:	eba2 020a 	sub.w	r2, r2, sl
   200b0:	0052      	lsls	r2, r2, #1
   200b2:	eb00 004a 	add.w	r0, r0, sl, lsl #1
   200b6:	2100      	movs	r1, #0
   200b8:	f015 f854 	bl	35164 <memset>
    }

    /* return residual energy */
    return silk_max_32( 1, C[ 0 ][ 1 ] );
}
   200bc:	2c01      	cmp	r4, #1
   200be:	4620      	mov	r0, r4
   200c0:	bfb8      	it	lt
   200c2:	2001      	movlt	r0, #1
   200c4:	b037      	add	sp, #220	; 0xdc
   200c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   200ca:	251e      	movs	r5, #30
   200cc:	f10d 0b10 	add.w	fp, sp, #16
   200d0:	1f0b      	subs	r3, r1, #4
   200d2:	465c      	mov	r4, fp
    k = 0;
   200d4:	2000      	movs	r0, #0
            C[ k ][ 0 ] = C[ k ][ 1 ] = silk_LSHIFT( c[ k ], lz );
   200d6:	f853 1f04 	ldr.w	r1, [r3, #4]!
   200da:	40a9      	lsls	r1, r5
   200dc:	6061      	str	r1, [r4, #4]
   200de:	f84b 1030 	str.w	r1, [fp, r0, lsl #3]
        } while( ++k <= order );
   200e2:	3001      	adds	r0, #1
   200e4:	4282      	cmp	r2, r0
   200e6:	f104 0408 	add.w	r4, r4, #8
   200ea:	daf4      	bge.n	200d6 <silk_schur+0x14e>
   200ec:	e76b      	b.n	1ffc6 <silk_schur+0x3e>
   200ee:	f647 7cff 	movw	ip, #32767	; 0x7fff
   200f2:	e793      	b.n	2001c <silk_schur+0x94>
   200f4:	f10d 0b10 	add.w	fp, sp, #16
   200f8:	1f0b      	subs	r3, r1, #4
   200fa:	465c      	mov	r4, fp
    k = 0;
   200fc:	2000      	movs	r0, #0
            C[ k ][ 0 ] = C[ k ][ 1 ] = silk_RSHIFT( c[ k ], 1 );
   200fe:	f853 1f04 	ldr.w	r1, [r3, #4]!
   20102:	1049      	asrs	r1, r1, #1
   20104:	6061      	str	r1, [r4, #4]
   20106:	f84b 1030 	str.w	r1, [fp, r0, lsl #3]
        } while( ++k <= order );
   2010a:	3001      	adds	r0, #1
   2010c:	4282      	cmp	r2, r0
   2010e:	f104 0408 	add.w	r4, r4, #8
   20112:	daf4      	bge.n	200fe <silk_schur+0x176>
   20114:	e757      	b.n	1ffc6 <silk_schur+0x3e>
              rc_Q15[ k ] = SILK_FIX_CONST( .99f, 15 );
   20116:	f647 63b8 	movw	r3, #32440	; 0x7eb8
   2011a:	800b      	strh	r3, [r1, #0]
   2011c:	e7c3      	b.n	200a6 <silk_schur+0x11e>
        if (silk_abs_int32(C[ k + 1 ][ 0 ]) >= C[ 0 ][ 1 ]) {
   2011e:	9903      	ldr	r1, [sp, #12]
   20120:	f04f 0a01 	mov.w	sl, #1
   20124:	e7ba      	b.n	2009c <silk_schur+0x114>
   20126:	1e9d      	subs	r5, r3, #2
   20128:	e7d0      	b.n	200cc <silk_schur+0x144>
   2012a:	bf00      	nop
   2012c:	ffff8001 	.word	0xffff8001

00020130 <intensity_stereo.isra.2>:
#endif
   w[0] = VSHR32(Ex, shift);
   w[1] = VSHR32(Ey, shift);
}

static void intensity_stereo(const CELTMode *m, celt_norm * OPUS_RESTRICT X, const celt_norm * OPUS_RESTRICT Y, const celt_ener *bandE, int bandID, int N)
   20130:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   20134:	e9dd 4908 	ldrd	r4, r9, [sp, #32]
   int j;
   opus_val16 a1, a2;
   opus_val16 left, right;
   opus_val16 norm;
#ifdef FIXED_POINT
   int shift = celt_zlog2(MAX32(bandE[i], bandE[i+m->nbEBands]))-13;
   20138:	4420      	add	r0, r4
   2013a:	f853 5024 	ldr.w	r5, [r3, r4, lsl #2]
   2013e:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
   20142:	42a8      	cmp	r0, r5
   20144:	4603      	mov	r3, r0
   20146:	bfb8      	it	lt
   20148:	462b      	movlt	r3, r5


/** Integer log in base2. Defined for zero, but not for negative numbers */
static OPUS_INLINE opus_int16 celt_zlog2(opus_val32 x)
{
   return x <= 0 ? 0 : celt_ilog2(x);
   2014a:	2b00      	cmp	r3, #0
static void intensity_stereo(const CELTMode *m, celt_norm * OPUS_RESTRICT X, const celt_norm * OPUS_RESTRICT Y, const celt_ener *bandE, int bandID, int N)
   2014c:	460c      	mov	r4, r1
   2014e:	4690      	mov	r8, r2
   20150:	dd39      	ble.n	201c6 <intensity_stereo.isra.2+0x96>
   return EC_ILOG(x)-1;
   20152:	fab3 f383 	clz	r3, r3
   20156:	f1c3 031f 	rsb	r3, r3, #31
   int shift = celt_zlog2(MAX32(bandE[i], bandE[i+m->nbEBands]))-13;
   2015a:	b29b      	uxth	r3, r3
   2015c:	f1a3 070d 	sub.w	r7, r3, #13
#endif
   left = VSHR32(bandE[i],shift);
   20160:	2f00      	cmp	r7, #0
   20162:	dd37      	ble.n	201d4 <intensity_stereo.isra.2+0xa4>
   20164:	413d      	asrs	r5, r7
   right = VSHR32(bandE[i+m->nbEBands],shift);
   20166:	fa40 f707 	asr.w	r7, r0, r7
   left = VSHR32(bandE[i],shift);
   2016a:	b22d      	sxth	r5, r5
   right = VSHR32(bandE[i+m->nbEBands],shift);
   2016c:	b23f      	sxth	r7, r7
   norm = EPSILON + celt_sqrt(EPSILON+MULT16_16(left,left)+MULT16_16(right,right));
   2016e:	2001      	movs	r0, #1
   20170:	fb05 0005 	mla	r0, r5, r5, r0
   20174:	fb07 0007 	mla	r0, r7, r7, r0
   20178:	f00b f97e 	bl	2b478 <celt_sqrt>
   a1 = DIV32_16(SHL32(EXTEND32(left),14),norm);
   a2 = DIV32_16(SHL32(EXTEND32(right),14),norm);
   for (j=0;j<N;j++)
   2017c:	f1b9 0f00 	cmp.w	r9, #0
   norm = EPSILON + celt_sqrt(EPSILON+MULT16_16(left,left)+MULT16_16(right,right));
   20180:	f100 0001 	add.w	r0, r0, #1
   a1 = DIV32_16(SHL32(EXTEND32(left),14),norm);
   20184:	b200      	sxth	r0, r0
   20186:	ea4f 3585 	mov.w	r5, r5, lsl #14
   a2 = DIV32_16(SHL32(EXTEND32(right),14),norm);
   2018a:	ea4f 3687 	mov.w	r6, r7, lsl #14
   a1 = DIV32_16(SHL32(EXTEND32(left),14),norm);
   2018e:	fb95 f5f0 	sdiv	r5, r5, r0
   a2 = DIV32_16(SHL32(EXTEND32(right),14),norm);
   20192:	fb96 f6f0 	sdiv	r6, r6, r0
   a1 = DIV32_16(SHL32(EXTEND32(left),14),norm);
   20196:	b22d      	sxth	r5, r5
   a2 = DIV32_16(SHL32(EXTEND32(right),14),norm);
   20198:	b236      	sxth	r6, r6
   for (j=0;j<N;j++)
   2019a:	dd12      	ble.n	201c2 <intensity_stereo.isra.2+0x92>
   2019c:	eb04 0949 	add.w	r9, r4, r9, lsl #1
   201a0:	f1a9 0902 	sub.w	r9, r9, #2
   201a4:	1ea1      	subs	r1, r4, #2
   201a6:	f1a8 0802 	sub.w	r8, r8, #2
   {
      celt_norm r, l;
      l = X[j];
      r = Y[j];
      X[j] = EXTRACT16(SHR32(MAC16_16(MULT16_16(a1, l), a2, r), 14));
   201aa:	f838 0f02 	ldrh.w	r0, [r8, #2]!
   201ae:	f831 3f02 	ldrh.w	r3, [r1, #2]!
   201b2:	fb10 f006 	smulbb	r0, r0, r6
   201b6:	fb13 0305 	smlabb	r3, r3, r5, r0
   201ba:	139b      	asrs	r3, r3, #14
   for (j=0;j<N;j++)
   201bc:	4589      	cmp	r9, r1
      X[j] = EXTRACT16(SHR32(MAC16_16(MULT16_16(a1, l), a2, r), 14));
   201be:	800b      	strh	r3, [r1, #0]
   for (j=0;j<N;j++)
   201c0:	d1f3      	bne.n	201aa <intensity_stereo.isra.2+0x7a>
      /* Side is not encoded, no need to calculate */
   }
}
   201c2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   return x <= 0 ? 0 : celt_ilog2(x);
   201c6:	270d      	movs	r7, #13
   left = VSHR32(bandE[i],shift);
   201c8:	40bd      	lsls	r5, r7
   right = VSHR32(bandE[i+m->nbEBands],shift);
   201ca:	fa00 f707 	lsl.w	r7, r0, r7
   left = VSHR32(bandE[i],shift);
   201ce:	b22d      	sxth	r5, r5
   right = VSHR32(bandE[i+m->nbEBands],shift);
   201d0:	b23f      	sxth	r7, r7
   201d2:	e7cc      	b.n	2016e <intensity_stereo.isra.2+0x3e>
   201d4:	f1c3 070d 	rsb	r7, r3, #13
   201d8:	e7f6      	b.n	201c8 <intensity_stereo.isra.2+0x98>
   201da:	bf00      	nop

000201dc <quant_partition>:
   split in 8 parts. */
static unsigned quant_partition(struct band_ctx *ctx, celt_norm *X,
      int N, int b, int B, celt_norm *lowband,
      int LM,
      opus_val16 gain, int fill)
{
   201dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   201e0:	4604      	mov	r4, r0
   201e2:	b091      	sub	sp, #68	; 0x44
   int i;
   int spread;
   ec_ctx *ec;

   encode = ctx->encode;
   m = ctx->m;
   201e4:	6880      	ldr	r0, [r0, #8]
{
   201e6:	9e1c      	ldr	r6, [sp, #112]	; 0x70
   i = ctx->i;
   spread = ctx->spread;
   ec = ctx->ec;

   /* If we need 1.5 more bit than we can produce, split the band in two. */
   cache = m->cache.bits + m->cache.index[(LM+1)*m->nbEBands+i];
   201e8:	f8d0 9008 	ldr.w	r9, [r0, #8]
   spread = ctx->spread;
   201ec:	6965      	ldr	r5, [r4, #20]
   i = ctx->i;
   201ee:	f8d4 e00c 	ldr.w	lr, [r4, #12]
   spread = ctx->spread;
   201f2:	950a      	str	r5, [sp, #40]	; 0x28
   cache = m->cache.bits + m->cache.index[(LM+1)*m->nbEBands+i];
   201f4:	fb06 9a09 	mla	sl, r6, r9, r9
{
   201f8:	9d1a      	ldr	r5, [sp, #104]	; 0x68
   201fa:	9506      	str	r5, [sp, #24]
   cache = m->cache.bits + m->cache.index[(LM+1)*m->nbEBands+i];
   201fc:	44f2      	add	sl, lr
{
   201fe:	9d1b      	ldr	r5, [sp, #108]	; 0x6c
   20200:	9509      	str	r5, [sp, #36]	; 0x24
   20202:	4689      	mov	r9, r1
   cache = m->cache.bits + m->cache.index[(LM+1)*m->nbEBands+i];
   20204:	6d81      	ldr	r1, [r0, #88]	; 0x58
{
   20206:	f9bd 5074 	ldrsh.w	r5, [sp, #116]	; 0x74
   cache = m->cache.bits + m->cache.index[(LM+1)*m->nbEBands+i];
   2020a:	f931 a01a 	ldrsh.w	sl, [r1, sl, lsl #1]
   2020e:	f8d0 c05c 	ldr.w	ip, [r0, #92]	; 0x5c
{
   20212:	9508      	str	r5, [sp, #32]
   20214:	9d1e      	ldr	r5, [sp, #120]	; 0x78
   20216:	9507      	str	r5, [sp, #28]
   20218:	461d      	mov	r5, r3
   if (LM != -1 && b > cache[cache[0]]+12 && N>2)
   2021a:	1c73      	adds	r3, r6, #1
{
   2021c:	4611      	mov	r1, r2
   encode = ctx->encode;
   2021e:	f8d4 8000 	ldr.w	r8, [r4]
   ec = ctx->ec;
   20222:	69e7      	ldr	r7, [r4, #28]
   20224:	f81c 200a 	ldrb.w	r2, [ip, sl]
   cache = m->cache.bits + m->cache.index[(LM+1)*m->nbEBands+i];
   20228:	eb0c 0b0a 	add.w	fp, ip, sl
   if (LM != -1 && b > cache[cache[0]]+12 && N>2)
   2022c:	f000 8102 	beq.w	20434 <quant_partition+0x258>
   20230:	f81b 3002 	ldrb.w	r3, [fp, r2]
   20234:	330c      	adds	r3, #12
   20236:	42ab      	cmp	r3, r5
   20238:	f280 80fc 	bge.w	20434 <quant_partition+0x258>
   2023c:	2902      	cmp	r1, #2
   2023e:	f340 80f9 	ble.w	20434 <quant_partition+0x258>
      int qalloc;
      struct split_ctx sctx;
      celt_norm *next_lowband2=NULL;
      opus_int32 rebalance;

      N >>= 1;
   20242:	104a      	asrs	r2, r1, #1
      Y = X+N;
      LM -= 1;
      if (B==1)
   20244:	9b06      	ldr	r3, [sp, #24]
      N >>= 1;
   20246:	920c      	str	r2, [sp, #48]	; 0x30
      Y = X+N;
   20248:	0052      	lsls	r2, r2, #1
   2024a:	920d      	str	r2, [sp, #52]	; 0x34
      LM -= 1;
   2024c:	1e71      	subs	r1, r6, #1
      Y = X+N;
   2024e:	444a      	add	r2, r9
      if (B==1)
   20250:	2b01      	cmp	r3, #1
      LM -= 1;
   20252:	910a      	str	r1, [sp, #40]	; 0x28
      Y = X+N;
   20254:	920e      	str	r2, [sp, #56]	; 0x38
      if (B==1)
   20256:	d103      	bne.n	20260 <quant_partition+0x84>
         fill = (fill&1)|(fill<<1);
   20258:	9b07      	ldr	r3, [sp, #28]
   2025a:	f363 035f 	bfi	r3, r3, #1, #31
   2025e:	9307      	str	r3, [sp, #28]
   pulse_cap = m->logN[i]+LM*(1<<BITRES);
   20260:	6b03      	ldr	r3, [r0, #48]	; 0x30
   20262:	f933 001e 	ldrsh.w	r0, [r3, lr, lsl #1]
   20266:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   20268:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
   int N2 = 2*N-1;
   2026c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   offset = (pulse_cap>>1) - (stereo&&N==2 ? QTHETA_OFFSET_TWOPHASE : QTHETA_OFFSET);
   2026e:	1046      	asrs	r6, r0, #1
   int N2 = 2*N-1;
   20270:	1e59      	subs	r1, r3, #1
      B = (B+1)>>1;
   20272:	9b06      	ldr	r3, [sp, #24]
   offset = (pulse_cap>>1) - (stereo&&N==2 ? QTHETA_OFFSET_TWOPHASE : QTHETA_OFFSET);
   20274:	3e04      	subs	r6, #4
   qb = celt_sudiv(b+N2*offset, N2);
   20276:	fb01 5606 	mla	r6, r1, r6, r5
      B = (B+1)>>1;
   2027a:	3301      	adds	r3, #1
   2027c:	105b      	asrs	r3, r3, #1
}

static OPUS_INLINE opus_int32 celt_sudiv(opus_int32 n, opus_int32 d) {
   celt_sig_assert(d>0);
#ifdef USE_SMALL_DIV_TABLE
   if (n<0)
   2027e:	2e00      	cmp	r6, #0
   20280:	930b      	str	r3, [sp, #44]	; 0x2c
   20282:	f2c0 823c 	blt.w	206fe <quant_partition+0x522>
   if (d>256)
   20286:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
   2028a:	f340 8307 	ble.w	2089c <quant_partition+0x6c0>
      return n/d;
   2028e:	fbb6 f1f1 	udiv	r1, r6, r1
   qb = IMIN(b-pulse_cap-(4<<BITRES), qb);
   20292:	1a28      	subs	r0, r5, r0
   20294:	f1a0 031f 	sub.w	r3, r0, #31
   20298:	428b      	cmp	r3, r1
   2029a:	bfd8      	it	le
   2029c:	f1a0 0120 	suble.w	r1, r0, #32
   if (qb<(1<<BITRES>>1)) {
   202a0:	2903      	cmp	r1, #3
   202a2:	f340 818d 	ble.w	205c0 <quant_partition+0x3e4>
   qb = IMIN(8<<BITRES, qb);
   202a6:	2940      	cmp	r1, #64	; 0x40
   202a8:	bfa8      	it	ge
   202aa:	2140      	movge	r1, #64	; 0x40
      qn = exp2_table8[qb&0x7]>>(14-(qb>>BITRES));
   202ac:	f001 0207 	and.w	r2, r1, #7
   202b0:	4bc0      	ldr	r3, [pc, #768]	; (205b4 <quant_partition+0x3d8>)
   202b2:	10c9      	asrs	r1, r1, #3
   202b4:	f933 6012 	ldrsh.w	r6, [r3, r2, lsl #1]
   202b8:	f1c1 030e 	rsb	r3, r1, #14
   202bc:	411e      	asrs	r6, r3
      qn = (qn+1)>>1<<1;
   202be:	3601      	adds	r6, #1
   202c0:	f026 0601 	bic.w	r6, r6, #1
   if (encode)
   202c4:	f1b8 0f00 	cmp.w	r8, #0
   202c8:	f040 8237 	bne.w	2073a <quant_partition+0x55e>
   tell = ec_tell_frac(ec);
   202cc:	4638      	mov	r0, r7
   202ce:	f009 fa2d 	bl	2972c <ec_tell_frac>
      } else if (B0>1 || stereo) {
   202d2:	9b06      	ldr	r3, [sp, #24]
   202d4:	2b01      	cmp	r3, #1
   tell = ec_tell_frac(ec);
   202d6:	4682      	mov	sl, r0
      } else if (B0>1 || stereo) {
   202d8:	f340 8307 	ble.w	208ea <quant_partition+0x70e>
            itheta = ec_dec_uint(ec, qn+1);
   202dc:	1c71      	adds	r1, r6, #1
   202de:	4638      	mov	r0, r7
   202e0:	f009 fb0e 	bl	29900 <ec_dec_uint>
   202e4:	ea4f 3b80 	mov.w	fp, r0, lsl #14
   if (d>256)
   202e8:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
   202ec:	f240 8328 	bls.w	20940 <quant_partition+0x764>
      return n/d;
   202f0:	fbbb f6f6 	udiv	r6, fp, r6
      itheta = celt_udiv((opus_int32)itheta*16384, qn);
   202f4:	46b3      	mov	fp, r6
   qalloc = ec_tell_frac(ec) - tell;
   202f6:	4638      	mov	r0, r7
   202f8:	f009 fa18 	bl	2972c <ec_tell_frac>
   202fc:	eba0 0a0a 	sub.w	sl, r0, sl
   *b -= qalloc;
   20300:	eba5 050a 	sub.w	r5, r5, sl
   if (itheta == 0)
   20304:	f1bb 0f00 	cmp.w	fp, #0
   20308:	f000 8169 	beq.w	205de <quant_partition+0x402>
   } else if (itheta == 16384)
   2030c:	f5bb 4f80 	cmp.w	fp, #16384	; 0x4000
   20310:	f000 8341 	beq.w	20996 <quant_partition+0x7ba>
      iside = bitexact_cos((opus_int16)(16384-itheta));
   20314:	f5cb 4080 	rsb	r0, fp, #16384	; 0x4000
   tmp = (4096+((opus_int32)(x)*(x)))>>13;
   20318:	f44f 5380 	mov.w	r3, #4096	; 0x1000
      iside = bitexact_cos((opus_int16)(16384-itheta));
   2031c:	b200      	sxth	r0, r0
      imid = bitexact_cos((opus_int16)itheta);
   2031e:	fa0f f18b 	sxth.w	r1, fp
   tmp = (4096+((opus_int32)(x)*(x)))>>13;
   20322:	fb00 3000 	mla	r0, r0, r0, r3
   20326:	fb01 3101 	mla	r1, r1, r1, r3
   2032a:	1340      	asrs	r0, r0, #13
   2032c:	1349      	asrs	r1, r1, #13
   x2 = (32767-x2) + FRAC_MUL16(x2, (-7651 + FRAC_MUL16(x2, (8277 + FRAC_MUL16(-626, x2)))));
   2032e:	f44f 4680 	mov.w	r6, #16384	; 0x4000
   x2 = tmp;
   20332:	b207      	sxth	r7, r0
   20334:	fa0f fc81 	sxth.w	ip, r1
   x2 = (32767-x2) + FRAC_MUL16(x2, (-7651 + FRAC_MUL16(x2, (8277 + FRAC_MUL16(-626, x2)))));
   20338:	f64f 538e 	movw	r3, #64910	; 0xfd8e
   2033c:	fb17 6203 	smlabb	r2, r7, r3, r6
   20340:	f242 0e55 	movw	lr, #8277	; 0x2055
   20344:	fb1c 6303 	smlabb	r3, ip, r3, r6
   20348:	eb0e 33e3 	add.w	r3, lr, r3, asr #15
   2034c:	eb0e 32e2 	add.w	r2, lr, r2, asr #15
   20350:	b29b      	uxth	r3, r3
   20352:	fb0c f303 	mul.w	r3, ip, r3
   20356:	b292      	uxth	r2, r2
   20358:	fb07 f202 	mul.w	r2, r7, r2
   2035c:	4433      	add	r3, r6
   2035e:	4432      	add	r2, r6
   20360:	13db      	asrs	r3, r3, #15
   20362:	13d2      	asrs	r2, r2, #15
   20364:	f5a3 53ef 	sub.w	r3, r3, #7648	; 0x1de0
   20368:	f5a2 52ef 	sub.w	r2, r2, #7648	; 0x1de0
   2036c:	3b03      	subs	r3, #3
   2036e:	fb1c 6303 	smlabb	r3, ip, r3, r6
   return 1+x2;
   20372:	f5c1 4100 	rsb	r1, r1, #32768	; 0x8000
   x2 = (32767-x2) + FRAC_MUL16(x2, (-7651 + FRAC_MUL16(x2, (8277 + FRAC_MUL16(-626, x2)))));
   20376:	3a03      	subs	r2, #3
   return 1+x2;
   20378:	f5c0 4000 	rsb	r0, r0, #32768	; 0x8000
   x2 = (32767-x2) + FRAC_MUL16(x2, (-7651 + FRAC_MUL16(x2, (8277 + FRAC_MUL16(-626, x2)))));
   2037c:	fb17 6202 	smlabb	r2, r7, r2, r6
   return 1+x2;
   20380:	eb01 33e3 	add.w	r3, r1, r3, asr #15
   20384:	b21b      	sxth	r3, r3
   20386:	eb00 32e2 	add.w	r2, r0, r2, asr #15
   lc=EC_ILOG(icos);
   2038a:	930f      	str	r3, [sp, #60]	; 0x3c
   return 1+x2;
   2038c:	b212      	sxth	r2, r2
   lc=EC_ILOG(icos);
   2038e:	fab3 f183 	clz	r1, r3
   ls=EC_ILOG(isin);
   20392:	fab2 f782 	clz	r7, r2
   lc=EC_ILOG(icos);
   20396:	460b      	mov	r3, r1
   icos<<=15-lc;
   20398:	f1a1 0c11 	sub.w	ip, r1, #17
   2039c:	990f      	ldr	r1, [sp, #60]	; 0x3c
   isin<<=15-ls;
   2039e:	f1a7 0011 	sub.w	r0, r7, #17
   203a2:	fa02 f000 	lsl.w	r0, r2, r0
   icos<<=15-lc;
   203a6:	fa01 fc0c 	lsl.w	ip, r1, ip
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
   203aa:	fa0f fc8c 	sxth.w	ip, ip
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
   203ae:	b200      	sxth	r0, r0
   203b0:	f24f 58db 	movw	r8, #62939	; 0xf5db
   203b4:	fb10 6e08 	smlabb	lr, r0, r8, r6
   203b8:	f641 61fc 	movw	r1, #7932	; 0x1efc
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
   203bc:	fb1c 6808 	smlabb	r8, ip, r8, r6
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
   203c0:	eb01 3eee 	add.w	lr, r1, lr, asr #15
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
   203c4:	eb01 31e8 	add.w	r1, r1, r8, asr #15
   return (ls-lc)*(1<<11)
   203c8:	1bdf      	subs	r7, r3, r7
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
   203ca:	fa1f fe8e 	uxth.w	lr, lr
      delta = FRAC_MUL16((N-1)<<7,bitexact_log2tan(iside,imid));
   203ce:	9b0c      	ldr	r3, [sp, #48]	; 0x30
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
   203d0:	b289      	uxth	r1, r1
   203d2:	fb0c f101 	mul.w	r1, ip, r1
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
   203d6:	fb00 f00e 	mul.w	r0, r0, lr
   return (ls-lc)*(1<<11)
   203da:	02ff      	lsls	r7, r7, #11
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
   203dc:	eb01 0c06 	add.w	ip, r1, r6
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
   203e0:	4430      	add	r0, r6
      delta = FRAC_MUL16((N-1)<<7,bitexact_log2tan(iside,imid));
   203e2:	1e59      	subs	r1, r3, #1
   203e4:	9b08      	ldr	r3, [sp, #32]
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
   203e6:	eb07 30e0 	add.w	r0, r7, r0, asr #15
   203ea:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
   203ec:	fb02 6203 	mla	r2, r2, r3, r6
   203f0:	fb07 6303 	mla	r3, r7, r3, r6
   203f4:	f342 37cf 	sbfx	r7, r2, #15, #16
      mid = (1.f/32768)*imid;
      side = (1.f/32768)*iside;
#endif

      /* Give more bits to low-energy MDCTs than they would otherwise deserve */
      if (B0>1 && (itheta&0x3fff))
   203f8:	9a06      	ldr	r2, [sp, #24]
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
   203fa:	eba0 30ec 	sub.w	r0, r0, ip, asr #15
      delta = FRAC_MUL16((N-1)<<7,bitexact_log2tan(iside,imid));
   203fe:	01c9      	lsls	r1, r1, #7
   20400:	f343 33cf 	sbfx	r3, r3, #15, #16
   20404:	fb11 6000 	smlabb	r0, r1, r0, r6
      if (B0>1 && (itheta&0x3fff))
   20408:	2a01      	cmp	r2, #1
   2040a:	930f      	str	r3, [sp, #60]	; 0x3c
      delta = FRAC_MUL16((N-1)<<7,bitexact_log2tan(iside,imid));
   2040c:	ea4f 33e0 	mov.w	r3, r0, asr #15
      if (B0>1 && (itheta&0x3fff))
   20410:	f340 80f9 	ble.w	20606 <quant_partition+0x42a>
   20414:	f3cb 020d 	ubfx	r2, fp, #0, #14
   20418:	2a00      	cmp	r2, #0
   2041a:	f000 80f4 	beq.w	20606 <quant_partition+0x42a>
      {
         if (itheta > 8192)
   2041e:	f5bb 5f00 	cmp.w	fp, #8192	; 0x2000
   20422:	f340 82cb 	ble.w	209bc <quant_partition+0x7e0>
            /* Rough approximation for pre-echo masking */
            delta -= delta>>(4-LM);
   20426:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   20428:	f1c2 0204 	rsb	r2, r2, #4
   2042c:	fa43 f202 	asr.w	r2, r3, r2
   20430:	1a9b      	subs	r3, r3, r2
   20432:	e0e8      	b.n	20606 <quant_partition+0x42a>
   lo = 0;
   hi = cache[0];
   bits--;
   for (i=0;i<LOG_MAX_PSEUDO;i++)
   {
      int mid = (lo+hi+1)>>1;
   20434:	1c56      	adds	r6, r2, #1
   20436:	1076      	asrs	r6, r6, #1
   bits--;
   20438:	1e68      	subs	r0, r5, #1
      /* OPT: Make sure this is implemented with a conditional move */
      if ((int)cache[mid] >= bits)
   2043a:	f81b 3006 	ldrb.w	r3, [fp, r6]
   2043e:	4283      	cmp	r3, r0
      int mid = (lo+hi+1)>>1;
   20440:	bfb6      	itet	lt
   20442:	4633      	movlt	r3, r6
   lo = 0;
   20444:	2300      	movge	r3, #0
   hi = cache[0];
   20446:	4616      	movlt	r6, r2
      int mid = (lo+hi+1)>>1;
   20448:	199a      	adds	r2, r3, r6
   2044a:	3201      	adds	r2, #1
   2044c:	1052      	asrs	r2, r2, #1
      if ((int)cache[mid] >= bits)
   2044e:	f81b c002 	ldrb.w	ip, [fp, r2]
   20452:	4584      	cmp	ip, r0
      int mid = (lo+hi+1)>>1;
   20454:	bfbc      	itt	lt
   20456:	4613      	movlt	r3, r2
      if ((int)cache[mid] >= bits)
   20458:	4632      	movlt	r2, r6
      int mid = (lo+hi+1)>>1;
   2045a:	189e      	adds	r6, r3, r2
   2045c:	3601      	adds	r6, #1
   2045e:	1076      	asrs	r6, r6, #1
      if ((int)cache[mid] >= bits)
   20460:	f81b c006 	ldrb.w	ip, [fp, r6]
   20464:	4560      	cmp	r0, ip
      int mid = (lo+hi+1)>>1;
   20466:	bfc4      	itt	gt
   20468:	4633      	movgt	r3, r6
      if ((int)cache[mid] >= bits)
   2046a:	4616      	movgt	r6, r2
      int mid = (lo+hi+1)>>1;
   2046c:	199a      	adds	r2, r3, r6
   2046e:	3201      	adds	r2, #1
   20470:	1052      	asrs	r2, r2, #1
      if ((int)cache[mid] >= bits)
   20472:	f81b c002 	ldrb.w	ip, [fp, r2]
   20476:	4560      	cmp	r0, ip
      int mid = (lo+hi+1)>>1;
   20478:	bfc4      	itt	gt
   2047a:	4613      	movgt	r3, r2
      if ((int)cache[mid] >= bits)
   2047c:	4632      	movgt	r2, r6
      int mid = (lo+hi+1)>>1;
   2047e:	18d6      	adds	r6, r2, r3
   20480:	3601      	adds	r6, #1
   20482:	1076      	asrs	r6, r6, #1
      if ((int)cache[mid] >= bits)
   20484:	f81b c006 	ldrb.w	ip, [fp, r6]
   20488:	4560      	cmp	r0, ip
      int mid = (lo+hi+1)>>1;
   2048a:	bfc4      	itt	gt
   2048c:	4633      	movgt	r3, r6
      if ((int)cache[mid] >= bits)
   2048e:	4616      	movgt	r6, r2
      int mid = (lo+hi+1)>>1;
   20490:	18f2      	adds	r2, r6, r3
   20492:	3201      	adds	r2, #1
   20494:	1052      	asrs	r2, r2, #1
      if ((int)cache[mid] >= bits)
   20496:	f81b c002 	ldrb.w	ip, [fp, r2]
   2049a:	4560      	cmp	r0, ip
      int mid = (lo+hi+1)>>1;
   2049c:	bfc4      	itt	gt
   2049e:	4613      	movgt	r3, r2
      if ((int)cache[mid] >= bits)
   204a0:	4632      	movgt	r2, r6
   204a2:	4694      	mov	ip, r2
   204a4:	f81b 6002 	ldrb.w	r6, [fp, r2]
   204a8:	1a36      	subs	r6, r6, r0
         hi = mid;
      else
         lo = mid;
   }
   if (bits- (lo == 0 ? -1 : (int)cache[lo]) <= (int)cache[hi]-bits)
   204aa:	bb83      	cbnz	r3, 2050e <quant_partition+0x332>
   204ac:	42b5      	cmp	r5, r6
   204ae:	dc34      	bgt.n	2051a <quant_partition+0x33e>
            cm = alg_unquant(X, N, K, spread, B, ec, gain);
         }
      } else {
         /* If there's no pulse, fill the band anyway */
         int j;
         if (ctx->resynth)
   204b0:	6867      	ldr	r7, [r4, #4]
   204b2:	2f00      	cmp	r7, #0
   204b4:	d079      	beq.n	205aa <quant_partition+0x3ce>
         {
            unsigned cm_mask;
            /* B can be as large as 16, so this shift might overflow an int on a
               16-bit platform; use a long to get defined behavior.*/
            cm_mask = (unsigned)(1UL<<B)-1;
   204b6:	9b06      	ldr	r3, [sp, #24]
   204b8:	2701      	movs	r7, #1
   204ba:	409f      	lsls	r7, r3
            fill &= cm_mask;
            if (!fill)
   204bc:	9b07      	ldr	r3, [sp, #28]
            cm_mask = (unsigned)(1UL<<B)-1;
   204be:	3f01      	subs	r7, #1
            if (!fill)
   204c0:	ea13 0b07 	ands.w	fp, r3, r7
   204c4:	d062      	beq.n	2058c <quant_partition+0x3b0>
            {
               OPUS_CLEAR(X, N);
            } else {
               if (lowband == NULL)
   204c6:	9b09      	ldr	r3, [sp, #36]	; 0x24
   204c8:	2b00      	cmp	r3, #0
   204ca:	f000 8250 	beq.w	2096e <quant_partition+0x792>
                     X[j] = (celt_norm)((opus_int32)ctx->seed>>20);
                  }
                  cm = cm_mask;
               } else {
                  /* Folded spectrum */
                  for (j=0;j<N;j++)
   204ce:	2900      	cmp	r1, #0
   204d0:	dd14      	ble.n	204fc <quant_partition+0x320>
   204d2:	1e9a      	subs	r2, r3, #2
   return 1664525 * seed + 1013904223;
   204d4:	4f38      	ldr	r7, [pc, #224]	; (205b8 <quant_partition+0x3dc>)
   204d6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   204d8:	4e38      	ldr	r6, [pc, #224]	; (205bc <quant_partition+0x3e0>)
   204da:	eb02 0c41 	add.w	ip, r2, r1, lsl #1
   204de:	f1a9 0002 	sub.w	r0, r9, #2
   204e2:	fb07 6303 	mla	r3, r7, r3, r6
                  {
                     opus_val16 tmp;
                     ctx->seed = celt_lcg_rand(ctx->seed);
                     /* About 48 dB below the "normal" folding level */
                     tmp = QCONST16(1.0f/256, 10);
                     tmp = (ctx->seed)&0x8000 ? tmp : -tmp;
   204e6:	f413 4f00 	tst.w	r3, #32768	; 0x8000
                     X[j] = lowband[j]+tmp;
   204ea:	f832 5f02 	ldrh.w	r5, [r2, #2]!
                     tmp = (ctx->seed)&0x8000 ? tmp : -tmp;
   204ee:	d056      	beq.n	2059e <quant_partition+0x3c2>
                     X[j] = lowband[j]+tmp;
   204f0:	3504      	adds	r5, #4
                  for (j=0;j<N;j++)
   204f2:	4594      	cmp	ip, r2
                     X[j] = lowband[j]+tmp;
   204f4:	f820 5f02 	strh.w	r5, [r0, #2]!
                  for (j=0;j<N;j++)
   204f8:	d1f3      	bne.n	204e2 <quant_partition+0x306>
   204fa:	62a3      	str	r3, [r4, #40]	; 0x28
                  }
                  cm = fill;
               }
               renormalise_vector(X, N, gain, ctx->arch);
   204fc:	4648      	mov	r0, r9
   204fe:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   20500:	9a08      	ldr	r2, [sp, #32]
   20502:	f00e fc33 	bl	2ed6c <renormalise_vector>
         }
      }
   }

   return cm;
}
   20506:	4658      	mov	r0, fp
   20508:	b011      	add	sp, #68	; 0x44
   2050a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2050e:	f81b 5003 	ldrb.w	r5, [fp, r3]
   20512:	1b40      	subs	r0, r0, r5
   20514:	42b0      	cmp	r0, r6
   20516:	f340 82bb 	ble.w	20a90 <quant_partition+0x8b4>
{
   const unsigned char *cache;

   LM++;
   cache = m->cache.bits + m->cache.index[LM*m->nbEBands+band];
   return pulses == 0 ? 0 : cache[pulses]+1;
   2051a:	2a00      	cmp	r2, #0
   2051c:	d0c8      	beq.n	204b0 <quant_partition+0x2d4>
   2051e:	f81b 000c 	ldrb.w	r0, [fp, ip]
      ctx->remaining_bits -= curr_bits;
   20522:	6a23      	ldr	r3, [r4, #32]
   20524:	e005      	b.n	20532 <quant_partition+0x356>
         ctx->remaining_bits += curr_bits;
   20526:	4403      	add	r3, r0
   20528:	3a01      	subs	r2, #1
   2052a:	6223      	str	r3, [r4, #32]
   2052c:	d0c0      	beq.n	204b0 <quant_partition+0x2d4>
   2052e:	f81b 0002 	ldrb.w	r0, [fp, r2]
   20532:	3001      	adds	r0, #1
      ctx->remaining_bits -= curr_bits;
   20534:	1a1b      	subs	r3, r3, r0
      while (ctx->remaining_bits < 0 && q > 0)
   20536:	2b00      	cmp	r3, #0
      ctx->remaining_bits -= curr_bits;
   20538:	6223      	str	r3, [r4, #32]
      while (ctx->remaining_bits < 0 && q > 0)
   2053a:	dbf4      	blt.n	20526 <quant_partition+0x34a>
   return i<8 ? i : (8 + (i&7)) << ((i>>3)-1);
   2053c:	2a07      	cmp	r2, #7
   2053e:	dd06      	ble.n	2054e <quant_partition+0x372>
   20540:	f002 0307 	and.w	r3, r2, #7
   20544:	10d2      	asrs	r2, r2, #3
   20546:	3308      	adds	r3, #8
   20548:	3a01      	subs	r2, #1
   2054a:	fa03 f202 	lsl.w	r2, r3, r2
         if (encode)
   2054e:	f1b8 0f00 	cmp.w	r8, #0
   20552:	d00f      	beq.n	20574 <quant_partition+0x398>
            cm = alg_quant(X, N, K, spread, B, ec, gain, ctx->resynth, ctx->arch);
   20554:	9b08      	ldr	r3, [sp, #32]
   20556:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
   20558:	6864      	ldr	r4, [r4, #4]
   2055a:	e9cd 731b 	strd	r7, r3, [sp, #108]	; 0x6c
   2055e:	9b06      	ldr	r3, [sp, #24]
   20560:	931a      	str	r3, [sp, #104]	; 0x68
   20562:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   20564:	4648      	mov	r0, r9
   20566:	e9cd 451d 	strd	r4, r5, [sp, #116]	; 0x74
}
   2056a:	b011      	add	sp, #68	; 0x44
   2056c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            cm = alg_quant(X, N, K, spread, B, ec, gain, ctx->resynth, ctx->arch);
   20570:	f00e b818 	b.w	2e5a4 <alg_quant>
            cm = alg_unquant(X, N, K, spread, B, ec, gain);
   20574:	9b08      	ldr	r3, [sp, #32]
   20576:	e9cd 731b 	strd	r7, r3, [sp, #108]	; 0x6c
   2057a:	9b06      	ldr	r3, [sp, #24]
   2057c:	931a      	str	r3, [sp, #104]	; 0x68
   2057e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   20580:	4648      	mov	r0, r9
}
   20582:	b011      	add	sp, #68	; 0x44
   20584:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            cm = alg_unquant(X, N, K, spread, B, ec, gain);
   20588:	f00e ba7c 	b.w	2ea84 <alg_unquant>
               OPUS_CLEAR(X, N);
   2058c:	004a      	lsls	r2, r1, #1
   2058e:	4648      	mov	r0, r9
   20590:	4659      	mov	r1, fp
   20592:	f014 fde7 	bl	35164 <memset>
}
   20596:	4658      	mov	r0, fp
   20598:	b011      	add	sp, #68	; 0x44
   2059a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                     X[j] = lowband[j]+tmp;
   2059e:	3d04      	subs	r5, #4
                  for (j=0;j<N;j++)
   205a0:	4562      	cmp	r2, ip
                     X[j] = lowband[j]+tmp;
   205a2:	f820 5f02 	strh.w	r5, [r0, #2]!
                  for (j=0;j<N;j++)
   205a6:	d19c      	bne.n	204e2 <quant_partition+0x306>
   205a8:	e7a7      	b.n	204fa <quant_partition+0x31e>
   unsigned cm=0;
   205aa:	46bb      	mov	fp, r7
}
   205ac:	4658      	mov	r0, fp
   205ae:	b011      	add	sp, #68	; 0x44
   205b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   205b4:	0003780c 	.word	0x0003780c
   205b8:	0019660d 	.word	0x0019660d
   205bc:	3c6ef35f 	.word	0x3c6ef35f
   if (encode)
   205c0:	f1b8 0f00 	cmp.w	r8, #0
   205c4:	f040 8219 	bne.w	209fa <quant_partition+0x81e>
   tell = ec_tell_frac(ec);
   205c8:	4638      	mov	r0, r7
   205ca:	f009 f8af 	bl	2972c <ec_tell_frac>
   205ce:	4682      	mov	sl, r0
   qalloc = ec_tell_frac(ec) - tell;
   205d0:	4638      	mov	r0, r7
   205d2:	f009 f8ab 	bl	2972c <ec_tell_frac>
   205d6:	eba0 0a0a 	sub.w	sl, r0, sl
   *b -= qalloc;
   205da:	eba5 050a 	sub.w	r5, r5, sl
      *fill &= (1<<B)-1;
   205de:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   205e0:	9908      	ldr	r1, [sp, #32]
   205e2:	2301      	movs	r3, #1
   205e4:	4093      	lsls	r3, r2
   205e6:	f647 7bff 	movw	fp, #32767	; 0x7fff
   205ea:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   205ee:	fb11 2b0b 	smlabb	fp, r1, fp, r2
   205f2:	9a07      	ldr	r2, [sp, #28]
   205f4:	3b01      	subs	r3, #1
   205f6:	401a      	ands	r2, r3
   205f8:	f34b 33cf 	sbfx	r3, fp, #15, #16
   205fc:	2700      	movs	r7, #0
   205fe:	930f      	str	r3, [sp, #60]	; 0x3c
      delta = -16384;
   20600:	4bcd      	ldr	r3, [pc, #820]	; (20938 <quant_partition+0x75c>)
      *fill &= (1<<B)-1;
   20602:	9207      	str	r2, [sp, #28]
   20604:	46bb      	mov	fp, r7
      mbits = IMAX(0, IMIN(b, (b-delta)/2));
   20606:	1aeb      	subs	r3, r5, r3
   20608:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
   2060c:	105e      	asrs	r6, r3, #1
   2060e:	42ae      	cmp	r6, r5
      ctx->remaining_bits -= qalloc;
   20610:	6a20      	ldr	r0, [r4, #32]
      if (lowband)
   20612:	9b09      	ldr	r3, [sp, #36]	; 0x24
      mbits = IMAX(0, IMIN(b, (b-delta)/2));
   20614:	bfa8      	it	ge
   20616:	462e      	movge	r6, r5
   20618:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
      ctx->remaining_bits -= qalloc;
   2061c:	eba0 080a 	sub.w	r8, r0, sl
      sbits = b-mbits;
   20620:	1bad      	subs	r5, r5, r6
      ctx->remaining_bits -= qalloc;
   20622:	f8c4 8020 	str.w	r8, [r4, #32]
      if (lowband)
   20626:	2b00      	cmp	r3, #0
   20628:	f000 814f 	beq.w	208ca <quant_partition+0x6ee>
         next_lowband2 = lowband+N; /* >32-bit split case */
   2062c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   2062e:	441a      	add	r2, r3
   20630:	9208      	str	r2, [sp, #32]
   20632:	9b06      	ldr	r3, [sp, #24]
   20634:	990b      	ldr	r1, [sp, #44]	; 0x2c
   20636:	105b      	asrs	r3, r3, #1
   20638:	9306      	str	r3, [sp, #24]
   2063a:	9b07      	ldr	r3, [sp, #28]
      if (mbits >= sbits)
   2063c:	42ae      	cmp	r6, r5
   2063e:	fa43 fa01 	asr.w	sl, r3, r1
   20642:	db2c      	blt.n	2069e <quant_partition+0x4c2>
         cm = quant_partition(ctx, X, N, mbits, B, lowband, LM,
   20644:	9304      	str	r3, [sp, #16]
   20646:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   20648:	9303      	str	r3, [sp, #12]
   2064a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   2064c:	9302      	str	r3, [sp, #8]
   2064e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   20650:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   20652:	e9cd 1300 	strd	r1, r3, [sp]
   20656:	4620      	mov	r0, r4
   20658:	4633      	mov	r3, r6
   2065a:	4649      	mov	r1, r9
   2065c:	f7ff fdbe 	bl	201dc <quant_partition>
         rebalance = mbits - (rebalance-ctx->remaining_bits);
   20660:	6a23      	ldr	r3, [r4, #32]
   20662:	eba8 0303 	sub.w	r3, r8, r3
   20666:	1af6      	subs	r6, r6, r3
         if (rebalance > 3<<BITRES && itheta!=0)
   20668:	2e18      	cmp	r6, #24
         cm = quant_partition(ctx, X, N, mbits, B, lowband, LM,
   2066a:	4681      	mov	r9, r0
         if (rebalance > 3<<BITRES && itheta!=0)
   2066c:	dd04      	ble.n	20678 <quant_partition+0x49c>
   2066e:	f1bb 0f00 	cmp.w	fp, #0
   20672:	d001      	beq.n	20678 <quant_partition+0x49c>
            sbits += rebalance - (3<<BITRES);
   20674:	3e18      	subs	r6, #24
   20676:	4435      	add	r5, r6
         cm |= quant_partition(ctx, Y, N, sbits, B, next_lowband2, LM,
   20678:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   2067a:	9302      	str	r3, [sp, #8]
   2067c:	9b08      	ldr	r3, [sp, #32]
   2067e:	9301      	str	r3, [sp, #4]
   20680:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   20682:	9300      	str	r3, [sp, #0]
   20684:	e9cd 7a03 	strd	r7, sl, [sp, #12]
   20688:	462b      	mov	r3, r5
   2068a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   2068c:	990e      	ldr	r1, [sp, #56]	; 0x38
   2068e:	4620      	mov	r0, r4
   20690:	f7ff fda4 	bl	201dc <quant_partition>
               MULT16_16_P15(gain,side), fill>>B)<<(B0>>1);
   20694:	9b06      	ldr	r3, [sp, #24]
   20696:	4098      	lsls	r0, r3
         cm |= quant_partition(ctx, Y, N, sbits, B, next_lowband2, LM,
   20698:	ea40 0b09 	orr.w	fp, r0, r9
   2069c:	e77b      	b.n	20596 <quant_partition+0x3ba>
         cm = quant_partition(ctx, Y, N, sbits, B, next_lowband2, LM,
   2069e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   206a0:	9302      	str	r3, [sp, #8]
   206a2:	9b08      	ldr	r3, [sp, #32]
   206a4:	9301      	str	r3, [sp, #4]
   206a6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   206a8:	9300      	str	r3, [sp, #0]
   206aa:	e9cd 7a03 	strd	r7, sl, [sp, #12]
   206ae:	462b      	mov	r3, r5
   206b0:	990e      	ldr	r1, [sp, #56]	; 0x38
   206b2:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   206b4:	4620      	mov	r0, r4
   206b6:	f7ff fd91 	bl	201dc <quant_partition>
         rebalance = sbits - (rebalance-ctx->remaining_bits);
   206ba:	6a23      	ldr	r3, [r4, #32]
   206bc:	eba8 0803 	sub.w	r8, r8, r3
   206c0:	eba5 0508 	sub.w	r5, r5, r8
         cm = quant_partition(ctx, Y, N, sbits, B, next_lowband2, LM,
   206c4:	9b06      	ldr	r3, [sp, #24]
         if (rebalance > 3<<BITRES && itheta!=16384)
   206c6:	2d18      	cmp	r5, #24
         cm = quant_partition(ctx, Y, N, sbits, B, next_lowband2, LM,
   206c8:	fa00 f703 	lsl.w	r7, r0, r3
         if (rebalance > 3<<BITRES && itheta!=16384)
   206cc:	dd04      	ble.n	206d8 <quant_partition+0x4fc>
   206ce:	f5bb 4f80 	cmp.w	fp, #16384	; 0x4000
            mbits += rebalance - (3<<BITRES);
   206d2:	bf1c      	itt	ne
   206d4:	3d18      	subne	r5, #24
   206d6:	1976      	addne	r6, r6, r5
         cm |= quant_partition(ctx, X, N, mbits, B, lowband, LM,
   206d8:	9b07      	ldr	r3, [sp, #28]
   206da:	9304      	str	r3, [sp, #16]
   206dc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   206de:	9303      	str	r3, [sp, #12]
   206e0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   206e2:	9302      	str	r3, [sp, #8]
   206e4:	9b09      	ldr	r3, [sp, #36]	; 0x24
   206e6:	9301      	str	r3, [sp, #4]
   206e8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   206ea:	9300      	str	r3, [sp, #0]
   206ec:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   206ee:	4633      	mov	r3, r6
   206f0:	4649      	mov	r1, r9
   206f2:	4620      	mov	r0, r4
   206f4:	f7ff fd72 	bl	201dc <quant_partition>
   206f8:	ea47 0b00 	orr.w	fp, r7, r0
   {
   206fc:	e74b      	b.n	20596 <quant_partition+0x3ba>
   if (d>256)
   206fe:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
      return -(opus_int32)celt_udiv(-n, d);
   20702:	f1c6 0600 	rsb	r6, r6, #0
   if (d>256)
   20706:	f300 80e2 	bgt.w	208ce <quant_partition+0x6f2>
      t = EC_ILOG(d&-d);
   2070a:	424b      	negs	r3, r1
   2070c:	400b      	ands	r3, r1
   2070e:	fab3 f383 	clz	r3, r3
   20712:	f1c3 0320 	rsb	r3, r3, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   20716:	fa21 fc03 	lsr.w	ip, r1, r3
   2071a:	4a88      	ldr	r2, [pc, #544]	; (2093c <quant_partition+0x760>)
   2071c:	3b01      	subs	r3, #1
   2071e:	f852 202c 	ldr.w	r2, [r2, ip, lsl #2]
   20722:	fa26 f303 	lsr.w	r3, r6, r3
   20726:	fba3 2302 	umull	r2, r3, r3, r2
      return q+(n-q*d >= d);
   2072a:	fb01 6613 	mls	r6, r1, r3, r6
   2072e:	428e      	cmp	r6, r1
   20730:	bf34      	ite	cc
   20732:	4619      	movcc	r1, r3
   20734:	1c59      	addcs	r1, r3, #1
      return -(opus_int32)celt_udiv(-n, d);
   20736:	4249      	negs	r1, r1
   20738:	e5ab      	b.n	20292 <quant_partition+0xb6>
      itheta = stereo_itheta(X, Y, stereo, N, ctx->arch);
   2073a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   2073c:	9300      	str	r3, [sp, #0]
   2073e:	2200      	movs	r2, #0
   20740:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   20742:	990e      	ldr	r1, [sp, #56]	; 0x38
   20744:	4648      	mov	r0, r9
   20746:	f00e fb55 	bl	2edf4 <stereo_itheta>
   2074a:	4680      	mov	r8, r0
   tell = ec_tell_frac(ec);
   2074c:	4638      	mov	r0, r7
   2074e:	f008 ffed 	bl	2972c <ec_tell_frac>
            itheta = (itheta*(opus_int32)qn+8192)>>14;
   20752:	fb06 f808 	mul.w	r8, r6, r8
            if (!stereo && ctx->avoid_split_noise && itheta > 0 && itheta < qn)
   20756:	6ba3      	ldr	r3, [r4, #56]	; 0x38
            itheta = (itheta*(opus_int32)qn+8192)>>14;
   20758:	f508 5800 	add.w	r8, r8, #8192	; 0x2000
   tell = ec_tell_frac(ec);
   2075c:	4682      	mov	sl, r0
            itheta = (itheta*(opus_int32)qn+8192)>>14;
   2075e:	ea4f 38a8 	mov.w	r8, r8, asr #14
            if (!stereo && ctx->avoid_split_noise && itheta > 0 && itheta < qn)
   20762:	2b00      	cmp	r3, #0
   20764:	f000 80b6 	beq.w	208d4 <quant_partition+0x6f8>
   20768:	f1b8 0f00 	cmp.w	r8, #0
   2076c:	f340 8130 	ble.w	209d0 <quant_partition+0x7f4>
   20770:	45b0      	cmp	r8, r6
               int unquantized = celt_udiv((opus_int32)itheta*16384, qn);
   20772:	ea4f 3b88 	mov.w	fp, r8, lsl #14
            if (!stereo && ctx->avoid_split_noise && itheta > 0 && itheta < qn)
   20776:	f280 80af 	bge.w	208d8 <quant_partition+0x6fc>
   if (d>256)
   2077a:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
   2077e:	f240 8170 	bls.w	20a62 <quant_partition+0x886>
      return n/d;
   20782:	fbbb f3f6 	udiv	r3, fp, r6
   tmp = (4096+((opus_int32)(x)*(x)))>>13;
   20786:	f44f 5280 	mov.w	r2, #4096	; 0x1000
               iside = bitexact_cos((opus_int16)(16384-unquantized));
   2078a:	f5c3 4e80 	rsb	lr, r3, #16384	; 0x4000
               imid = bitexact_cos((opus_int16)unquantized);
   2078e:	b21b      	sxth	r3, r3
   tmp = (4096+((opus_int32)(x)*(x)))>>13;
   20790:	fb03 2303 	mla	r3, r3, r3, r2
               iside = bitexact_cos((opus_int16)(16384-unquantized));
   20794:	fa0f fe8e 	sxth.w	lr, lr
   tmp = (4096+((opus_int32)(x)*(x)))>>13;
   20798:	fb0e 2e0e 	mla	lr, lr, lr, r2
   2079c:	135b      	asrs	r3, r3, #13
   2079e:	4618      	mov	r0, r3
   207a0:	ea4f 3e6e 	mov.w	lr, lr, asr #13
   x2 = tmp;
   207a4:	fa0f f18e 	sxth.w	r1, lr
   207a8:	900f      	str	r0, [sp, #60]	; 0x3c
   x2 = (32767-x2) + FRAC_MUL16(x2, (-7651 + FRAC_MUL16(x2, (8277 + FRAC_MUL16(-626, x2)))));
   207aa:	f64f 538e 	movw	r3, #64910	; 0xfd8e
   207ae:	f44f 4c80 	mov.w	ip, #16384	; 0x4000
   207b2:	fb11 c203 	smlabb	r2, r1, r3, ip
   x2 = tmp;
   207b6:	f9bd 003c 	ldrsh.w	r0, [sp, #60]	; 0x3c
   x2 = (32767-x2) + FRAC_MUL16(x2, (-7651 + FRAC_MUL16(x2, (8277 + FRAC_MUL16(-626, x2)))));
   207ba:	f242 0c55 	movw	ip, #8277	; 0x2055
   207be:	eb0c 32e2 	add.w	r2, ip, r2, asr #15
   207c2:	f44f 4c80 	mov.w	ip, #16384	; 0x4000
   207c6:	fb10 c303 	smlabb	r3, r0, r3, ip
   207ca:	f242 0c55 	movw	ip, #8277	; 0x2055
   207ce:	eb0c 33e3 	add.w	r3, ip, r3, asr #15
   207d2:	b292      	uxth	r2, r2
   207d4:	b29b      	uxth	r3, r3
   207d6:	fb01 f202 	mul.w	r2, r1, r2
   207da:	fb00 f303 	mul.w	r3, r0, r3
   207de:	f502 4280 	add.w	r2, r2, #16384	; 0x4000
   207e2:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
   207e6:	13d2      	asrs	r2, r2, #15
   207e8:	13db      	asrs	r3, r3, #15
   207ea:	f5a2 52ef 	sub.w	r2, r2, #7648	; 0x1de0
   207ee:	f5a3 53ef 	sub.w	r3, r3, #7648	; 0x1de0
   207f2:	f44f 4c80 	mov.w	ip, #16384	; 0x4000
   207f6:	3b03      	subs	r3, #3
   207f8:	3a03      	subs	r2, #3
   207fa:	fb11 c202 	smlabb	r2, r1, r2, ip
   207fe:	fb10 c003 	smlabb	r0, r0, r3, ip
   return 1+x2;
   20802:	f5ce 4e00 	rsb	lr, lr, #32768	; 0x8000
   20806:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   20808:	eb0e 3ee2 	add.w	lr, lr, r2, asr #15
   2080c:	fa0f f28e 	sxth.w	r2, lr
   20810:	f5c3 4300 	rsb	r3, r3, #32768	; 0x8000
   ls=EC_ILOG(isin);
   20814:	fab2 f182 	clz	r1, r2
   return 1+x2;
   20818:	eb03 33e0 	add.w	r3, r3, r0, asr #15
   2081c:	b21b      	sxth	r3, r3
   isin<<=15-ls;
   2081e:	f1a1 0011 	sub.w	r0, r1, #17
   20822:	910f      	str	r1, [sp, #60]	; 0x3c
   20824:	4082      	lsls	r2, r0
   lc=EC_ILOG(icos);
   20826:	fab3 f183 	clz	r1, r3
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
   2082a:	b212      	sxth	r2, r2
   icos<<=15-lc;
   2082c:	f1a1 0011 	sub.w	r0, r1, #17
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
   20830:	f24f 5edb 	movw	lr, #62939	; 0xf5db
   icos<<=15-lc;
   20834:	4083      	lsls	r3, r0
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
   20836:	fb12 c00e 	smlabb	r0, r2, lr, ip
   2083a:	f641 6cfc 	movw	ip, #7932	; 0x1efc
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
   2083e:	b21b      	sxth	r3, r3
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
   20840:	eb0c 30e0 	add.w	r0, ip, r0, asr #15
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
   20844:	f44f 4c80 	mov.w	ip, #16384	; 0x4000
   20848:	fb13 ce0e 	smlabb	lr, r3, lr, ip
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
   2084c:	b280      	uxth	r0, r0
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
   2084e:	f641 6cfc 	movw	ip, #7932	; 0x1efc
   20852:	eb0c 3eee 	add.w	lr, ip, lr, asr #15
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
   20856:	fb02 f000 	mul.w	r0, r2, r0
   return (ls-lc)*(1<<11)
   2085a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
   2085c:	fa1f fe8e 	uxth.w	lr, lr
   return (ls-lc)*(1<<11)
   20860:	1a8a      	subs	r2, r1, r2
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
   20862:	fb03 fe0e 	mul.w	lr, r3, lr
               delta = FRAC_MUL16((N-1)<<7,bitexact_log2tan(iside,imid));
   20866:	9b0c      	ldr	r3, [sp, #48]	; 0x30
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
   20868:	f500 4080 	add.w	r0, r0, #16384	; 0x4000
   return (ls-lc)*(1<<11)
   2086c:	02d2      	lsls	r2, r2, #11
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
   2086e:	eb02 32e0 	add.w	r2, r2, r0, asr #15
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
   20872:	f50e 4180 	add.w	r1, lr, #16384	; 0x4000
               delta = FRAC_MUL16((N-1)<<7,bitexact_log2tan(iside,imid));
   20876:	3b01      	subs	r3, #1
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
   20878:	eba2 32e1 	sub.w	r2, r2, r1, asr #15
               delta = FRAC_MUL16((N-1)<<7,bitexact_log2tan(iside,imid));
   2087c:	01db      	lsls	r3, r3, #7
   2087e:	f44f 4c80 	mov.w	ip, #16384	; 0x4000
   20882:	fb13 c302 	smlabb	r3, r3, r2, ip
   20886:	13db      	asrs	r3, r3, #15
               if (delta > *b)
   20888:	42ab      	cmp	r3, r5
   2088a:	f300 80e6 	bgt.w	20a5a <quant_partition+0x87e>
               else if (delta < -*b)
   2088e:	426a      	negs	r2, r5
   20890:	4293      	cmp	r3, r2
   20892:	da21      	bge.n	208d8 <quant_partition+0x6fc>
                  itheta = 0;
   20894:	f04f 0800 	mov.w	r8, #0
   20898:	46c3      	mov	fp, r8
   2089a:	e01d      	b.n	208d8 <quant_partition+0x6fc>
      t = EC_ILOG(d&-d);
   2089c:	424b      	negs	r3, r1
   2089e:	400b      	ands	r3, r1
   208a0:	fab3 f383 	clz	r3, r3
   208a4:	f1c3 0320 	rsb	r3, r3, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   208a8:	fa21 fc03 	lsr.w	ip, r1, r3
   208ac:	4a23      	ldr	r2, [pc, #140]	; (2093c <quant_partition+0x760>)
   208ae:	3b01      	subs	r3, #1
   208b0:	f852 202c 	ldr.w	r2, [r2, ip, lsl #2]
   208b4:	fa26 f303 	lsr.w	r3, r6, r3
   208b8:	fba3 2302 	umull	r2, r3, r3, r2
      return q+(n-q*d >= d);
   208bc:	fb01 6613 	mls	r6, r1, r3, r6
   208c0:	428e      	cmp	r6, r1
   208c2:	bf34      	ite	cc
   208c4:	4619      	movcc	r1, r3
   208c6:	1c59      	addcs	r1, r3, #1
   208c8:	e4e3      	b.n	20292 <quant_partition+0xb6>
      celt_norm *next_lowband2=NULL;
   208ca:	9308      	str	r3, [sp, #32]
   208cc:	e6b1      	b.n	20632 <quant_partition+0x456>
      return n/d;
   208ce:	fbb6 f1f1 	udiv	r1, r6, r1
   208d2:	e730      	b.n	20736 <quant_partition+0x55a>
   208d4:	ea4f 3b88 	mov.w	fp, r8, lsl #14
      } else if (B0>1 || stereo) {
   208d8:	9b06      	ldr	r3, [sp, #24]
   208da:	2b01      	cmp	r3, #1
   208dc:	dd7d      	ble.n	209da <quant_partition+0x7fe>
            ec_enc_uint(ec, itheta, qn+1);
   208de:	4641      	mov	r1, r8
   208e0:	1c72      	adds	r2, r6, #1
   208e2:	4638      	mov	r0, r7
   208e4:	f009 fb3e 	bl	29f64 <ec_enc_uint>
   208e8:	e4fe      	b.n	202e8 <quant_partition+0x10c>
         ft = ((qn>>1)+1)*((qn>>1)+1);
   208ea:	ea4f 0866 	mov.w	r8, r6, asr #1
   208ee:	f108 0301 	add.w	r3, r8, #1
   208f2:	fb03 fb03 	mul.w	fp, r3, r3
            fm = ec_decode(ec, ft);
   208f6:	4659      	mov	r1, fp
   208f8:	4638      	mov	r0, r7
         ft = ((qn>>1)+1)*((qn>>1)+1);
   208fa:	930f      	str	r3, [sp, #60]	; 0x3c
            fm = ec_decode(ec, ft);
   208fc:	f008 ff32 	bl	29764 <ec_decode>
            if (fm < ((qn>>1)*((qn>>1) + 1)>>1))
   20900:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   20902:	fb08 f803 	mul.w	r8, r8, r3
   20906:	ebb0 0f68 	cmp.w	r0, r8, asr #1
   2090a:	f280 8091 	bge.w	20a30 <quant_partition+0x854>
               itheta = (isqrt32(8*(opus_uint32)fm + 1) - 1)>>1;
   2090e:	00c0      	lsls	r0, r0, #3
   20910:	3001      	adds	r0, #1
   20912:	f00a fc21 	bl	2b158 <isqrt32>
   20916:	3801      	subs	r0, #1
   20918:	ea4f 0850 	mov.w	r8, r0, lsr #1
               fs = itheta + 1;
   2091c:	f108 0201 	add.w	r2, r8, #1
               fl = itheta*(itheta + 1)>>1;
   20920:	fb02 f108 	mul.w	r1, r2, r8
   20924:	1049      	asrs	r1, r1, #1
            ec_dec_update(ec, fl, fl+fs, ft);
   20926:	465b      	mov	r3, fp
   20928:	440a      	add	r2, r1
   2092a:	4638      	mov	r0, r7
   2092c:	f008 ff48 	bl	297c0 <ec_dec_update>
   20930:	ea4f 3b88 	mov.w	fp, r8, lsl #14
   20934:	e4d8      	b.n	202e8 <quant_partition+0x10c>
   20936:	bf00      	nop
   20938:	ffffc000 	.word	0xffffc000
   2093c:	00038e98 	.word	0x00038e98
      t = EC_ILOG(d&-d);
   20940:	4273      	negs	r3, r6
   20942:	4033      	ands	r3, r6
   20944:	fab3 f383 	clz	r3, r3
   20948:	f1c3 0320 	rsb	r3, r3, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   2094c:	fa26 f003 	lsr.w	r0, r6, r3
   20950:	4951      	ldr	r1, [pc, #324]	; (20a98 <quant_partition+0x8bc>)
   20952:	1e5a      	subs	r2, r3, #1
   20954:	f851 3020 	ldr.w	r3, [r1, r0, lsl #2]
   20958:	fa2b f202 	lsr.w	r2, fp, r2
   2095c:	fba2 0103 	umull	r0, r1, r2, r3
      return q+(n-q*d >= d);
   20960:	fb06 b211 	mls	r2, r6, r1, fp
   20964:	42b2      	cmp	r2, r6
   20966:	bf34      	ite	cc
   20968:	460e      	movcc	r6, r1
   2096a:	1c4e      	addcs	r6, r1, #1
   2096c:	e4c2      	b.n	202f4 <quant_partition+0x118>
                  for (j=0;j<N;j++)
   2096e:	2900      	cmp	r1, #0
   20970:	dd5c      	ble.n	20a2c <quant_partition+0x850>
   20972:	f1a9 0302 	sub.w	r3, r9, #2
   20976:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   return 1664525 * seed + 1013904223;
   20978:	f8df c124 	ldr.w	ip, [pc, #292]	; 20aa0 <quant_partition+0x8c4>
   2097c:	4e47      	ldr	r6, [pc, #284]	; (20a9c <quant_partition+0x8c0>)
   2097e:	eb03 0541 	add.w	r5, r3, r1, lsl #1
   20982:	fb0c 6202 	mla	r2, ip, r2, r6
                     X[j] = (celt_norm)((opus_int32)ctx->seed>>20);
   20986:	1510      	asrs	r0, r2, #20
   20988:	f823 0f02 	strh.w	r0, [r3, #2]!
                  for (j=0;j<N;j++)
   2098c:	429d      	cmp	r5, r3
   2098e:	d1f8      	bne.n	20982 <quant_partition+0x7a6>
   20990:	62a2      	str	r2, [r4, #40]	; 0x28
   20992:	46bb      	mov	fp, r7
   20994:	e5b2      	b.n	204fc <quant_partition+0x320>
      *fill &= ((1<<B)-1)<<B;
   20996:	990b      	ldr	r1, [sp, #44]	; 0x2c
   20998:	2301      	movs	r3, #1
   2099a:	408b      	lsls	r3, r1
   2099c:	3b01      	subs	r3, #1
   2099e:	408b      	lsls	r3, r1
   209a0:	9908      	ldr	r1, [sp, #32]
   209a2:	f647 72ff 	movw	r2, #32767	; 0x7fff
   209a6:	fb11 b202 	smlabb	r2, r1, r2, fp
   209aa:	9907      	ldr	r1, [sp, #28]
   209ac:	f342 37cf 	sbfx	r7, r2, #15, #16
   209b0:	4019      	ands	r1, r3
   209b2:	2200      	movs	r2, #0
   209b4:	9107      	str	r1, [sp, #28]
      delta = 16384;
   209b6:	465b      	mov	r3, fp
      *fill &= ((1<<B)-1)<<B;
   209b8:	920f      	str	r2, [sp, #60]	; 0x3c
   209ba:	e624      	b.n	20606 <quant_partition+0x42a>
            delta = IMIN(0, delta + (N<<BITRES>>(5-LM)));
   209bc:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   209be:	990a      	ldr	r1, [sp, #40]	; 0x28
   209c0:	00d2      	lsls	r2, r2, #3
   209c2:	f1c1 0105 	rsb	r1, r1, #5
   209c6:	410a      	asrs	r2, r1
   209c8:	4413      	add	r3, r2
   209ca:	ea03 73e3 	and.w	r3, r3, r3, asr #31
   209ce:	e61a      	b.n	20606 <quant_partition+0x42a>
      } else if (B0>1 || stereo) {
   209d0:	9b06      	ldr	r3, [sp, #24]
   209d2:	2b01      	cmp	r3, #1
   209d4:	ea4f 3b88 	mov.w	fp, r8, lsl #14
   209d8:	dc81      	bgt.n	208de <quant_partition+0x702>
         ft = ((qn>>1)+1)*((qn>>1)+1);
   209da:	1072      	asrs	r2, r6, #1
   209dc:	1c53      	adds	r3, r2, #1
            fs = itheta <= (qn>>1) ? itheta + 1 : qn + 1 - itheta;
   209de:	4590      	cmp	r8, r2
         ft = ((qn>>1)+1)*((qn>>1)+1);
   209e0:	fb03 f303 	mul.w	r3, r3, r3
            fs = itheta <= (qn>>1) ? itheta + 1 : qn + 1 - itheta;
   209e4:	dc17      	bgt.n	20a16 <quant_partition+0x83a>
   209e6:	f108 0201 	add.w	r2, r8, #1
            fl = itheta <= (qn>>1) ? itheta*(itheta + 1)>>1 :
   209ea:	fb02 f108 	mul.w	r1, r2, r8
   209ee:	1049      	asrs	r1, r1, #1
            ec_encode(ec, fl, fl+fs, ft);
   209f0:	440a      	add	r2, r1
   209f2:	4638      	mov	r0, r7
   209f4:	f009 f8da 	bl	29bac <ec_encode>
   209f8:	e476      	b.n	202e8 <quant_partition+0x10c>
      itheta = stereo_itheta(X, Y, stereo, N, ctx->arch);
   209fa:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   209fc:	9300      	str	r3, [sp, #0]
   209fe:	2200      	movs	r2, #0
   20a00:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   20a02:	990e      	ldr	r1, [sp, #56]	; 0x38
   20a04:	4648      	mov	r0, r9
   20a06:	f00e f9f5 	bl	2edf4 <stereo_itheta>
   20a0a:	4683      	mov	fp, r0
   tell = ec_tell_frac(ec);
   20a0c:	4638      	mov	r0, r7
   20a0e:	f008 fe8d 	bl	2972c <ec_tell_frac>
   20a12:	4682      	mov	sl, r0
   20a14:	e46f      	b.n	202f6 <quant_partition+0x11a>
            fs = itheta <= (qn>>1) ? itheta + 1 : qn + 1 - itheta;
   20a16:	1c72      	adds	r2, r6, #1
             ft - ((qn + 1 - itheta)*(qn + 2 - itheta)>>1);
   20a18:	1cb1      	adds	r1, r6, #2
            fs = itheta <= (qn>>1) ? itheta + 1 : qn + 1 - itheta;
   20a1a:	eba2 0208 	sub.w	r2, r2, r8
             ft - ((qn + 1 - itheta)*(qn + 2 - itheta)>>1);
   20a1e:	eba1 0108 	sub.w	r1, r1, r8
   20a22:	fb02 f101 	mul.w	r1, r2, r1
            fl = itheta <= (qn>>1) ? itheta*(itheta + 1)>>1 :
   20a26:	eba3 0161 	sub.w	r1, r3, r1, asr #1
   20a2a:	e7e1      	b.n	209f0 <quant_partition+0x814>
                  for (j=0;j<N;j++)
   20a2c:	46bb      	mov	fp, r7
   20a2e:	e565      	b.n	204fc <quant_partition+0x320>
                - isqrt32(8*(opus_uint32)(ft - fm - 1) + 1))>>1;
   20a30:	ebab 0000 	sub.w	r0, fp, r0
   20a34:	00c0      	lsls	r0, r0, #3
   20a36:	3807      	subs	r0, #7
   20a38:	f00a fb8e 	bl	2b158 <isqrt32>
               itheta = (2*(qn + 1)
   20a3c:	1c72      	adds	r2, r6, #1
                - isqrt32(8*(opus_uint32)(ft - fm - 1) + 1))>>1;
   20a3e:	ebc0 0042 	rsb	r0, r0, r2, lsl #1
   20a42:	ea4f 0850 	mov.w	r8, r0, lsr #1
               fl = ft - ((qn + 1 - itheta)*(qn + 2 - itheta)>>1);
   20a46:	1cb1      	adds	r1, r6, #2
               fs = qn + 1 - itheta;
   20a48:	eba2 0208 	sub.w	r2, r2, r8
               fl = ft - ((qn + 1 - itheta)*(qn + 2 - itheta)>>1);
   20a4c:	eba1 0108 	sub.w	r1, r1, r8
   20a50:	fb02 f101 	mul.w	r1, r2, r1
   20a54:	ebab 0161 	sub.w	r1, fp, r1, asr #1
   20a58:	e765      	b.n	20926 <quant_partition+0x74a>
               if (delta > *b)
   20a5a:	46b0      	mov	r8, r6
   20a5c:	ea4f 3b86 	mov.w	fp, r6, lsl #14
   20a60:	e73a      	b.n	208d8 <quant_partition+0x6fc>
      t = EC_ILOG(d&-d);
   20a62:	4273      	negs	r3, r6
   20a64:	4033      	ands	r3, r6
   20a66:	fab3 f383 	clz	r3, r3
   20a6a:	f1c3 0320 	rsb	r3, r3, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   20a6e:	fa26 f003 	lsr.w	r0, r6, r3
   20a72:	4909      	ldr	r1, [pc, #36]	; (20a98 <quant_partition+0x8bc>)
   20a74:	1e5a      	subs	r2, r3, #1
   20a76:	f851 3020 	ldr.w	r3, [r1, r0, lsl #2]
   20a7a:	fa2b f202 	lsr.w	r2, fp, r2
   20a7e:	fba2 0103 	umull	r0, r1, r2, r3
      return q+(n-q*d >= d);
   20a82:	fb06 b211 	mls	r2, r6, r1, fp
   20a86:	42b2      	cmp	r2, r6
   20a88:	bf34      	ite	cc
   20a8a:	460b      	movcc	r3, r1
   20a8c:	1c4b      	addcs	r3, r1, #1
   20a8e:	e67a      	b.n	20786 <quant_partition+0x5aa>
   if (bits- (lo == 0 ? -1 : (int)cache[lo]) <= (int)cache[hi]-bits)
   20a90:	461a      	mov	r2, r3
   20a92:	469c      	mov	ip, r3
   20a94:	e543      	b.n	2051e <quant_partition+0x342>
   20a96:	bf00      	nop
   20a98:	00038e98 	.word	0x00038e98
   20a9c:	3c6ef35f 	.word	0x3c6ef35f
   20aa0:	0019660d 	.word	0x0019660d

00020aa4 <quant_band>:
/* This function is responsible for encoding and decoding a band for the mono case. */
static unsigned quant_band(struct band_ctx *ctx, celt_norm *X,
      int N, int b, int B, celt_norm *lowband,
      int LM, celt_norm *lowband_out,
      opus_val16 gain, celt_norm *lowband_scratch, int fill)
{
   20aa4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   20aa8:	b095      	sub	sp, #84	; 0x54
   20aaa:	af06      	add	r7, sp, #24
   unsigned cm=0;
   int k;
   int encode;
   int tf_change;

   encode = ctx->encode;
   20aac:	6804      	ldr	r4, [r0, #0]
{
   20aae:	60bb      	str	r3, [r7, #8]
   if (d>256)
   20ab0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   20ab2:	6138      	str	r0, [r7, #16]
   tf_change = ctx->tf_change;
   20ab4:	6980      	ldr	r0, [r0, #24]
   20ab6:	6278      	str	r0, [r7, #36]	; 0x24
   20ab8:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
{
   20abc:	f9b7 0070 	ldrsh.w	r0, [r7, #112]	; 0x70
   encode = ctx->encode;
   20ac0:	623c      	str	r4, [r7, #32]
{
   20ac2:	f8d7 9064 	ldr.w	r9, [r7, #100]	; 0x64
   20ac6:	6078      	str	r0, [r7, #4]
   20ac8:	468a      	mov	sl, r1
   20aca:	61fa      	str	r2, [r7, #28]
   20acc:	f240 8192 	bls.w	20df4 <quant_band+0x350>
      return n/d;
   20ad0:	4613      	mov	r3, r2
   20ad2:	6e3a      	ldr	r2, [r7, #96]	; 0x60
   20ad4:	fbb3 f3f2 	udiv	r3, r3, r2
   20ad8:	60fb      	str	r3, [r7, #12]
   20ada:	469b      	mov	fp, r3
   longBlocks = B0==1;

   N_B = celt_udiv(N_B, B);

   /* Special case for one sample */
   if (N==1)
   20adc:	69fb      	ldr	r3, [r7, #28]
   20ade:	2b01      	cmp	r3, #1
   20ae0:	f000 81a8 	beq.w	20e34 <quant_band+0x390>
   {
      return quant_band_n1(ctx, X, NULL, b, lowband_out);
   }

   if (tf_change>0)
   20ae4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   20ae6:	2b00      	cmp	r3, #0
   20ae8:	f340 8246 	ble.w	20f78 <quant_band+0x4d4>
      recombine = tf_change;
   /* Band recombining to increase frequency resolution */

   if (lowband_scratch && lowband && (recombine || ((N_B&1) == 0 && tf_change<0) || B0>1))
   20aec:	6f7b      	ldr	r3, [r7, #116]	; 0x74
   20aee:	b153      	cbz	r3, 20b06 <quant_band+0x62>
   20af0:	f1b9 0f00 	cmp.w	r9, #0
   20af4:	d007      	beq.n	20b06 <quant_band+0x62>
   20af6:	4618      	mov	r0, r3
   {
      OPUS_COPY(lowband_scratch, lowband, N);
   20af8:	69fb      	ldr	r3, [r7, #28]
   20afa:	4649      	mov	r1, r9
   20afc:	005a      	lsls	r2, r3, #1
   20afe:	f7eb faff 	bl	c100 <memcpy>
   20b02:	f8d7 9074 	ldr.w	r9, [r7, #116]	; 0x74
      lowband = lowband_scratch;
   }

   for (k=0;k<recombine;k++)
   20b06:	2300      	movs	r3, #0
   20b08:	62bb      	str	r3, [r7, #40]	; 0x28
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
   20b0a:	f645 2b82 	movw	fp, #23170	; 0x5a82
   20b0e:	46d6      	mov	lr, sl
   {
      static const unsigned char bit_interleave_table[16]={
            0,1,1,1,2,3,3,3,2,3,3,3,2,3,3,3
      };
      if (encode)
   20b10:	6a3b      	ldr	r3, [r7, #32]
   20b12:	2b00      	cmp	r3, #0
   20b14:	f040 81e6 	bne.w	20ee4 <quant_band+0x440>
         haar1(X, N>>k, 1<<k);
      if (lowband)
   20b18:	f1b9 0f00 	cmp.w	r9, #0
   20b1c:	d04c      	beq.n	20bb8 <quant_band+0x114>
         haar1(lowband, N>>k, 1<<k);
   20b1e:	69fb      	ldr	r3, [r7, #28]
   20b20:	4619      	mov	r1, r3
   20b22:	6abb      	ldr	r3, [r7, #40]	; 0x28
   20b24:	2201      	movs	r2, #1
   20b26:	fa41 fc03 	asr.w	ip, r1, r3
   20b2a:	fa02 f303 	lsl.w	r3, r2, r3
   for (i=0;i<stride;i++)
   20b2e:	2b00      	cmp	r3, #0
         haar1(lowband, N>>k, 1<<k);
   20b30:	633b      	str	r3, [r7, #48]	; 0x30
   N0 >>= 1;
   20b32:	fa4c fc02 	asr.w	ip, ip, r2
   for (i=0;i<stride;i++)
   20b36:	dd3f      	ble.n	20bb8 <quant_band+0x114>
   20b38:	6abb      	ldr	r3, [r7, #40]	; 0x28
   20b3a:	2202      	movs	r2, #2
   20b3c:	f1bc 0f00 	cmp.w	ip, #0
   20b40:	fa02 fa03 	lsl.w	sl, r2, r3
   20b44:	dd38      	ble.n	20bb8 <quant_band+0x114>
   20b46:	ea4f 034a 	mov.w	r3, sl, lsl #1
   20b4a:	61bb      	str	r3, [r7, #24]
   20b4c:	6abb      	ldr	r3, [r7, #40]	; 0x28
      for (j=0;j<N0;j++)
   20b4e:	f8c7 e014 	str.w	lr, [r7, #20]
   20b52:	2102      	movs	r1, #2
   20b54:	2201      	movs	r2, #1
   20b56:	fa01 fa03 	lsl.w	sl, r1, r3
   20b5a:	f8d7 e018 	ldr.w	lr, [r7, #24]
   20b5e:	f8c7 9034 	str.w	r9, [r7, #52]	; 0x34
   20b62:	fa02 f303 	lsl.w	r3, r2, r3
   20b66:	62fb      	str	r3, [r7, #44]	; 0x2c
   20b68:	f04f 0800 	mov.w	r8, #0
   for (i=0;i<stride;i++)
   20b6c:	6afd      	ldr	r5, [r7, #44]	; 0x2c
   20b6e:	6b78      	ldr	r0, [r7, #52]	; 0x34
      for (j=0;j<N0;j++)
   20b70:	2400      	movs	r4, #0
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
   20b72:	eb05 0208 	add.w	r2, r5, r8
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
   20b76:	8803      	ldrh	r3, [r0, #0]
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
   20b78:	f839 6012 	ldrh.w	r6, [r9, r2, lsl #1]
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
   20b7c:	fb13 f30b 	smulbb	r3, r3, fp
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
   20b80:	fb16 f60b 	smulbb	r6, r6, fp
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
   20b84:	1999      	adds	r1, r3, r6
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
   20b86:	1b9b      	subs	r3, r3, r6
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
   20b88:	f501 4180 	add.w	r1, r1, #16384	; 0x4000
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
   20b8c:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
      for (j=0;j<N0;j++)
   20b90:	3401      	adds	r4, #1
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
   20b92:	13c9      	asrs	r1, r1, #15
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
   20b94:	13db      	asrs	r3, r3, #15
      for (j=0;j<N0;j++)
   20b96:	4564      	cmp	r4, ip
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
   20b98:	8001      	strh	r1, [r0, #0]
   20b9a:	4455      	add	r5, sl
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
   20b9c:	f829 3012 	strh.w	r3, [r9, r2, lsl #1]
   20ba0:	4470      	add	r0, lr
      for (j=0;j<N0;j++)
   20ba2:	d1e6      	bne.n	20b72 <quant_band+0xce>
   20ba4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   20ba6:	3302      	adds	r3, #2
   20ba8:	637b      	str	r3, [r7, #52]	; 0x34
   for (i=0;i<stride;i++)
   20baa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   20bac:	f108 0801 	add.w	r8, r8, #1
   20bb0:	4598      	cmp	r8, r3
   20bb2:	dbdb      	blt.n	20b6c <quant_band+0xc8>
   20bb4:	f8d7 e014 	ldr.w	lr, [r7, #20]
      fill = bit_interleave_table[fill&0xF]|bit_interleave_table[fill>>4]<<2;
   20bb8:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   20bba:	6fba      	ldr	r2, [r7, #120]	; 0x78
   20bbc:	49c6      	ldr	r1, [pc, #792]	; (20ed8 <quant_band+0x434>)
   20bbe:	f003 030f 	and.w	r3, r3, #15
   20bc2:	1112      	asrs	r2, r2, #4
   20bc4:	5ccb      	ldrb	r3, [r1, r3]
   20bc6:	5c8a      	ldrb	r2, [r1, r2]
   for (k=0;k<recombine;k++)
   20bc8:	6ab9      	ldr	r1, [r7, #40]	; 0x28
      fill = bit_interleave_table[fill&0xF]|bit_interleave_table[fill>>4]<<2;
   20bca:	ea43 0382 	orr.w	r3, r3, r2, lsl #2
   20bce:	67bb      	str	r3, [r7, #120]	; 0x78
   for (k=0;k<recombine;k++)
   20bd0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   20bd2:	3101      	adds	r1, #1
   20bd4:	428b      	cmp	r3, r1
   20bd6:	62b9      	str	r1, [r7, #40]	; 0x28
   20bd8:	d19a      	bne.n	20b10 <quant_band+0x6c>
   20bda:	68fb      	ldr	r3, [r7, #12]
   20bdc:	4619      	mov	r1, r3
   20bde:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   20be0:	fa01 fb03 	lsl.w	fp, r1, r3
   20be4:	f00b 0201 	and.w	r2, fp, #1
   20be8:	637a      	str	r2, [r7, #52]	; 0x34
   20bea:	6e3a      	ldr	r2, [r7, #96]	; 0x60
   20bec:	fa42 f303 	asr.w	r3, r2, r3
   20bf0:	46f2      	mov	sl, lr
   20bf2:	633b      	str	r3, [r7, #48]	; 0x30
   }
   B>>=recombine;
   N_B<<=recombine;

   /* Increasing the time resolution */
   while ((N_B&1) == 0 && tf_change<0)
   20bf4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   20bf6:	2b00      	cmp	r3, #0
   20bf8:	f040 83a4 	bne.w	21344 <quant_band+0x8a0>
   20bfc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   20bfe:	2b00      	cmp	r3, #0
   20c00:	da57      	bge.n	20cb2 <quant_band+0x20e>
   20c02:	2300      	movs	r3, #0
   20c04:	637b      	str	r3, [r7, #52]	; 0x34
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
   20c06:	f645 2582 	movw	r5, #23170	; 0x5a82
   20c0a:	f8c7 a02c 	str.w	sl, [r7, #44]	; 0x2c
   20c0e:	f8c7 9064 	str.w	r9, [r7, #100]	; 0x64
   {
      if (encode)
   20c12:	6a3b      	ldr	r3, [r7, #32]
   20c14:	ea4f 0b6b 	mov.w	fp, fp, asr #1
   20c18:	2b00      	cmp	r3, #0
   20c1a:	f040 812b 	bne.w	20e74 <quant_band+0x3d0>
         haar1(X, N_B, B);
      if (lowband)
   20c1e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   20c20:	2b00      	cmp	r3, #0
   20c22:	f000 8123 	beq.w	20e6c <quant_band+0x3c8>
   for (i=0;i<stride;i++)
   20c26:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   20c28:	2b00      	cmp	r3, #0
   20c2a:	f340 8120 	ble.w	20e6e <quant_band+0x3ca>
   20c2e:	f1bb 0f00 	cmp.w	fp, #0
   20c32:	ea4f 0a43 	mov.w	sl, r3, lsl #1
   20c36:	dd27      	ble.n	20c88 <quant_band+0x1e4>
   20c38:	f8d7 8064 	ldr.w	r8, [r7, #100]	; 0x64
   20c3c:	ea4f 0c83 	mov.w	ip, r3, lsl #2
   20c40:	ea4f 0e4a 	mov.w	lr, sl, lsl #1
      for (j=0;j<N0;j++)
   20c44:	f04f 0900 	mov.w	r9, #0
   20c48:	eb0a 0408 	add.w	r4, sl, r8
   20c4c:	4640      	mov	r0, r8
   20c4e:	2600      	movs	r6, #0
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
   20c50:	8803      	ldrh	r3, [r0, #0]
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
   20c52:	8821      	ldrh	r1, [r4, #0]
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
   20c54:	fb13 f305 	smulbb	r3, r3, r5
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
   20c58:	fb11 f105 	smulbb	r1, r1, r5
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
   20c5c:	185a      	adds	r2, r3, r1
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
   20c5e:	1a5b      	subs	r3, r3, r1
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
   20c60:	f502 4280 	add.w	r2, r2, #16384	; 0x4000
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
   20c64:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
      for (j=0;j<N0;j++)
   20c68:	3601      	adds	r6, #1
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
   20c6a:	13d2      	asrs	r2, r2, #15
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
   20c6c:	13db      	asrs	r3, r3, #15
      for (j=0;j<N0;j++)
   20c6e:	455e      	cmp	r6, fp
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
   20c70:	8002      	strh	r2, [r0, #0]
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
   20c72:	8023      	strh	r3, [r4, #0]
   20c74:	4470      	add	r0, lr
   20c76:	4464      	add	r4, ip
      for (j=0;j<N0;j++)
   20c78:	d1ea      	bne.n	20c50 <quant_band+0x1ac>
   for (i=0;i<stride;i++)
   20c7a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   20c7c:	f109 0901 	add.w	r9, r9, #1
   20c80:	4599      	cmp	r9, r3
   20c82:	f108 0802 	add.w	r8, r8, #2
   20c86:	dbdf      	blt.n	20c48 <quant_band+0x1a4>
         haar1(lowband, N_B, B);
      fill |= fill<<B;
   20c88:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   20c8a:	6fbb      	ldr	r3, [r7, #120]	; 0x78
      B <<= 1;
   20c8c:	f8c7 a030 	str.w	sl, [r7, #48]	; 0x30
      fill |= fill<<B;
   20c90:	4093      	lsls	r3, r2
   20c92:	6fba      	ldr	r2, [r7, #120]	; 0x78
   20c94:	431a      	orrs	r2, r3
      N_B >>= 1;
      time_divide++;
   20c96:	6b7b      	ldr	r3, [r7, #52]	; 0x34
      fill |= fill<<B;
   20c98:	67ba      	str	r2, [r7, #120]	; 0x78
      time_divide++;
   20c9a:	3301      	adds	r3, #1
   while ((N_B&1) == 0 && tf_change<0)
   20c9c:	f01b 0f01 	tst.w	fp, #1
      time_divide++;
   20ca0:	637b      	str	r3, [r7, #52]	; 0x34
   while ((N_B&1) == 0 && tf_change<0)
   20ca2:	d102      	bne.n	20caa <quant_band+0x206>
   20ca4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   20ca6:	42d3      	cmn	r3, r2
   20ca8:	d4b3      	bmi.n	20c12 <quant_band+0x16e>
   20caa:	f8d7 a02c 	ldr.w	sl, [r7, #44]	; 0x2c
   20cae:	f8d7 9064 	ldr.w	r9, [r7, #100]	; 0x64
   }
   B0=B;
   N_B0 = N_B;

   /* Reorganize the samples in time order instead of frequency order */
   if (B0>1)
   20cb2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   20cb4:	2b01      	cmp	r3, #1
   20cb6:	f340 81be 	ble.w	21036 <quant_band+0x592>
   {
      if (encode)
   20cba:	6a3b      	ldr	r3, [r7, #32]
   20cbc:	2b00      	cmp	r3, #0
   20cbe:	f040 8181 	bne.w	20fc4 <quant_band+0x520>
         deinterleave_hadamard(X, N_B>>recombine, B0<<recombine, longBlocks);
      if (lowband)
   20cc2:	f1b9 0f00 	cmp.w	r9, #0
   20cc6:	d044      	beq.n	20d52 <quant_band+0x2ae>
         deinterleave_hadamard(lowband, N_B>>recombine, B0<<recombine, longBlocks);
   20cc8:	6abb      	ldr	r3, [r7, #40]	; 0x28
   20cca:	6b3a      	ldr	r2, [r7, #48]	; 0x30
{
   20ccc:	f8c7 d024 	str.w	sp, [r7, #36]	; 0x24
         deinterleave_hadamard(lowband, N_B>>recombine, B0<<recombine, longBlocks);
   20cd0:	fa4b f603 	asr.w	r6, fp, r3
   20cd4:	fa02 f103 	lsl.w	r1, r2, r3
   N = N0*stride;
   20cd8:	fb01 f806 	mul.w	r8, r1, r6
   ALLOC(tmp, N, celt_norm);
   20cdc:	ea4f 0848 	mov.w	r8, r8, lsl #1
   20ce0:	f108 0308 	add.w	r3, r8, #8
   20ce4:	f023 0307 	bic.w	r3, r3, #7
   20ce8:	ebad 0d03 	sub.w	sp, sp, r3
   if (hadamard)
   20cec:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   20cee:	2b01      	cmp	r3, #1
   ALLOC(tmp, N, celt_norm);
   20cf0:	f10d 0c18 	add.w	ip, sp, #24
   if (hadamard)
   20cf4:	f040 8276 	bne.w	211e4 <quant_band+0x740>
      const int *ordery = ordery_table+stride-2;
   20cf8:	f101 4580 	add.w	r5, r1, #1073741824	; 0x40000000
   20cfc:	3d02      	subs	r5, #2
      for (i=0;i<stride;i++)
   20cfe:	2900      	cmp	r1, #0
      const int *ordery = ordery_table+stride-2;
   20d00:	ea4f 0585 	mov.w	r5, r5, lsl #2
      for (i=0;i<stride;i++)
   20d04:	f340 8284 	ble.w	21210 <quant_band+0x76c>
   20d08:	2e00      	cmp	r6, #0
   20d0a:	f340 8281 	ble.w	21210 <quant_band+0x76c>
   20d0e:	4b73      	ldr	r3, [pc, #460]	; (20edc <quant_band+0x438>)
   20d10:	0049      	lsls	r1, r1, #1
   20d12:	eb01 0e09 	add.w	lr, r1, r9
   20d16:	441d      	add	r5, r3
   20d18:	464c      	mov	r4, r9
            tmp[ordery[i]*N0+j] = X[j*stride+i];
   20d1a:	f855 3f04 	ldr.w	r3, [r5, #4]!
   20d1e:	62fc      	str	r4, [r7, #44]	; 0x2c
   20d20:	fb03 f306 	mul.w	r3, r3, r6
   20d24:	18f0      	adds	r0, r6, r3
   20d26:	eb0c 0040 	add.w	r0, ip, r0, lsl #1
   20d2a:	eb0c 0343 	add.w	r3, ip, r3, lsl #1
   20d2e:	4622      	mov	r2, r4
   20d30:	8814      	ldrh	r4, [r2, #0]
   20d32:	f823 4b02 	strh.w	r4, [r3], #2
         for (j=0;j<N0;j++)
   20d36:	4298      	cmp	r0, r3
   20d38:	440a      	add	r2, r1
   20d3a:	d1f9      	bne.n	20d30 <quant_band+0x28c>
   20d3c:	6afc      	ldr	r4, [r7, #44]	; 0x2c
   20d3e:	3402      	adds	r4, #2
      for (i=0;i<stride;i++)
   20d40:	45a6      	cmp	lr, r4
   20d42:	d1ea      	bne.n	20d1a <quant_band+0x276>
   OPUS_COPY(X, tmp, N);
   20d44:	4642      	mov	r2, r8
   20d46:	4661      	mov	r1, ip
   20d48:	4648      	mov	r0, r9
   20d4a:	f7eb f9d9 	bl	c100 <memcpy>
   20d4e:	f8d7 d024 	ldr.w	sp, [r7, #36]	; 0x24
   }

   cm = quant_partition(ctx, X, N, b, B, lowband, LM, gain, fill);
   20d52:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   20d54:	9304      	str	r3, [sp, #16]
   20d56:	687b      	ldr	r3, [r7, #4]
   20d58:	9303      	str	r3, [sp, #12]
   20d5a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   20d5c:	e9cd 9301 	strd	r9, r3, [sp, #4]
   20d60:	6b3c      	ldr	r4, [r7, #48]	; 0x30
   20d62:	9400      	str	r4, [sp, #0]
   20d64:	693d      	ldr	r5, [r7, #16]
   20d66:	68bb      	ldr	r3, [r7, #8]
   20d68:	69fa      	ldr	r2, [r7, #28]
   20d6a:	4651      	mov	r1, sl
   20d6c:	4628      	mov	r0, r5
   20d6e:	f7ff fa35 	bl	201dc <quant_partition>

   /* This code is used by the decoder and by the resynthesis-enabled encoder */
   if (ctx->resynth)
   20d72:	686b      	ldr	r3, [r5, #4]
   cm = quant_partition(ctx, X, N, b, B, lowband, LM, gain, fill);
   20d74:	6278      	str	r0, [r7, #36]	; 0x24
   if (ctx->resynth)
   20d76:	2b00      	cmp	r3, #0
   20d78:	d074      	beq.n	20e64 <quant_band+0x3c0>
   {
      /* Undo the sample reorganization going from time order to frequency order */
      if (B0>1)
         interleave_hadamard(X, N_B>>recombine, B0<<recombine, longBlocks);
   20d7a:	6abb      	ldr	r3, [r7, #40]	; 0x28
{
   20d7c:	f8c7 d02c 	str.w	sp, [r7, #44]	; 0x2c
         interleave_hadamard(X, N_B>>recombine, B0<<recombine, longBlocks);
   20d80:	fa4b f503 	asr.w	r5, fp, r3
   20d84:	fa04 f103 	lsl.w	r1, r4, r3
   N = N0*stride;
   20d88:	fb01 f905 	mul.w	r9, r1, r5
   ALLOC(tmp, N, celt_norm);
   20d8c:	ea4f 0949 	mov.w	r9, r9, lsl #1
   20d90:	f109 0308 	add.w	r3, r9, #8
   20d94:	f023 0307 	bic.w	r3, r3, #7
   20d98:	ebad 0d03 	sub.w	sp, sp, r3
   if (hadamard)
   20d9c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   20d9e:	2b01      	cmp	r3, #1
   ALLOC(tmp, N, celt_norm);
   20da0:	f10d 0e18 	add.w	lr, sp, #24
   if (hadamard)
   20da4:	f040 8251 	bne.w	2124a <quant_band+0x7a6>
      const int *ordery = ordery_table+stride-2;
   20da8:	f101 4c80 	add.w	ip, r1, #1073741824	; 0x40000000
   20dac:	f1ac 0c02 	sub.w	ip, ip, #2
      for (i=0;i<stride;i++)
   20db0:	2900      	cmp	r1, #0
      const int *ordery = ordery_table+stride-2;
   20db2:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
      for (i=0;i<stride;i++)
   20db6:	f340 825d 	ble.w	21274 <quant_band+0x7d0>
   20dba:	2d00      	cmp	r5, #0
   20dbc:	f340 825a 	ble.w	21274 <quant_band+0x7d0>
   20dc0:	4b46      	ldr	r3, [pc, #280]	; (20edc <quant_band+0x438>)
   20dc2:	0049      	lsls	r1, r1, #1
   20dc4:	eb01 080e 	add.w	r8, r1, lr
   20dc8:	449c      	add	ip, r3
   20dca:	4676      	mov	r6, lr
            tmp[j*stride+i] = X[ordery[i]*N0+j];
   20dcc:	f85c 3f04 	ldr.w	r3, [ip, #4]!
   20dd0:	fb03 f305 	mul.w	r3, r3, r5
   20dd4:	18e8      	adds	r0, r5, r3
   20dd6:	eb0a 0040 	add.w	r0, sl, r0, lsl #1
   20dda:	eb0a 0343 	add.w	r3, sl, r3, lsl #1
   20dde:	4632      	mov	r2, r6
   20de0:	f933 4b02 	ldrsh.w	r4, [r3], #2
   20de4:	8014      	strh	r4, [r2, #0]
         for (j=0;j<N0;j++)
   20de6:	4298      	cmp	r0, r3
   20de8:	440a      	add	r2, r1
   20dea:	d1f9      	bne.n	20de0 <quant_band+0x33c>
   20dec:	3602      	adds	r6, #2
      for (i=0;i<stride;i++)
   20dee:	45b0      	cmp	r8, r6
   20df0:	d1ec      	bne.n	20dcc <quant_band+0x328>
   20df2:	e23f      	b.n	21274 <quant_band+0x7d0>
   20df4:	461a      	mov	r2, r3
      t = EC_ILOG(d&-d);
   20df6:	425b      	negs	r3, r3
   20df8:	4013      	ands	r3, r2
   20dfa:	fab3 f383 	clz	r3, r3
   20dfe:	f1c3 0320 	rsb	r3, r3, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   20e02:	fa22 f003 	lsr.w	r0, r2, r3
   20e06:	4936      	ldr	r1, [pc, #216]	; (20ee0 <quant_band+0x43c>)
   20e08:	1e5a      	subs	r2, r3, #1
   20e0a:	f851 3020 	ldr.w	r3, [r1, r0, lsl #2]
   20e0e:	69f9      	ldr	r1, [r7, #28]
   20e10:	fa21 f202 	lsr.w	r2, r1, r2
   20e14:	fba2 4503 	umull	r4, r5, r2, r3
      return q+(n-q*d >= d);
   20e18:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   20e1a:	fb03 1215 	mls	r2, r3, r5, r1
   20e1e:	6e39      	ldr	r1, [r7, #96]	; 0x60
   20e20:	462b      	mov	r3, r5
   20e22:	4291      	cmp	r1, r2
   20e24:	bf98      	it	ls
   20e26:	3301      	addls	r3, #1
   20e28:	60fb      	str	r3, [r7, #12]
   20e2a:	469b      	mov	fp, r3
   if (N==1)
   20e2c:	69fb      	ldr	r3, [r7, #28]
   20e2e:	2b01      	cmp	r3, #1
   20e30:	f47f ae58 	bne.w	20ae4 <quant_band+0x40>
      if (ctx->remaining_bits>=1<<BITRES)
   20e34:	693a      	ldr	r2, [r7, #16]
   ec = ctx->ec;
   20e36:	e9d2 0307 	ldrd	r0, r3, [r2, #28]
      if (ctx->remaining_bits>=1<<BITRES)
   20e3a:	2b07      	cmp	r3, #7
   20e3c:	f300 8227 	bgt.w	2128e <quant_band+0x7ea>
      if (ctx->resynth)
   20e40:	6853      	ldr	r3, [r2, #4]
   20e42:	b11b      	cbz	r3, 20e4c <quant_band+0x3a8>
         x[0] = sign ? -NORM_SCALING : NORM_SCALING;
   20e44:	f44f 4380 	mov.w	r3, #16384	; 0x4000
   20e48:	f8aa 3000 	strh.w	r3, [sl]
   if (lowband_out)
   20e4c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
   20e4e:	2b00      	cmp	r3, #0
   20e50:	f000 8233 	beq.w	212ba <quant_band+0x816>
   20e54:	461a      	mov	r2, r3
      lowband_out[0] = SHR16(X[0],4);
   20e56:	f9ba 3000 	ldrsh.w	r3, [sl]
   20e5a:	111b      	asrs	r3, r3, #4
   20e5c:	8013      	strh	r3, [r2, #0]
      return quant_band_n1(ctx, X, NULL, b, lowband_out);
   20e5e:	2301      	movs	r3, #1
   20e60:	627b      	str	r3, [r7, #36]	; 0x24
   20e62:	4618      	mov	r0, r3
            lowband_out[j] = MULT16_16_Q15(n,X[j]);
      }
      cm &= (1<<B)-1;
   }
   return cm;
}
   20e64:	373c      	adds	r7, #60	; 0x3c
   20e66:	46bd      	mov	sp, r7
   20e68:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   20e6c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   20e6e:	ea4f 0a43 	mov.w	sl, r3, lsl #1
   20e72:	e709      	b.n	20c88 <quant_band+0x1e4>
   for (i=0;i<stride;i++)
   20e74:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   20e76:	2b00      	cmp	r3, #0
   20e78:	ddf9      	ble.n	20e6e <quant_band+0x3ca>
   20e7a:	f1bb 0f00 	cmp.w	fp, #0
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
   20e7e:	ea4f 0a43 	mov.w	sl, r3, lsl #1
   20e82:	f77f af01 	ble.w	20c88 <quant_band+0x1e4>
   20e86:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   20e88:	ea4f 0c83 	mov.w	ip, r3, lsl #2
   20e8c:	4696      	mov	lr, r2
   20e8e:	eb02 080a 	add.w	r8, r2, sl
   20e92:	eb0a 000e 	add.w	r0, sl, lr
   while ((N_B&1) == 0 && tf_change<0)
   20e96:	4671      	mov	r1, lr
      for (j=0;j<N0;j++)
   20e98:	2400      	movs	r4, #0
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
   20e9a:	880b      	ldrh	r3, [r1, #0]
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
   20e9c:	8806      	ldrh	r6, [r0, #0]
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
   20e9e:	fb13 f305 	smulbb	r3, r3, r5
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
   20ea2:	fb16 f605 	smulbb	r6, r6, r5
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
   20ea6:	199a      	adds	r2, r3, r6
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
   20ea8:	1b9b      	subs	r3, r3, r6
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
   20eaa:	f502 4280 	add.w	r2, r2, #16384	; 0x4000
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
   20eae:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
      for (j=0;j<N0;j++)
   20eb2:	3401      	adds	r4, #1
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
   20eb4:	13d2      	asrs	r2, r2, #15
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
   20eb6:	13db      	asrs	r3, r3, #15
      for (j=0;j<N0;j++)
   20eb8:	455c      	cmp	r4, fp
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
   20eba:	800a      	strh	r2, [r1, #0]
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
   20ebc:	8003      	strh	r3, [r0, #0]
   20ebe:	4461      	add	r1, ip
   20ec0:	4460      	add	r0, ip
      for (j=0;j<N0;j++)
   20ec2:	d1ea      	bne.n	20e9a <quant_band+0x3f6>
   20ec4:	f10e 0e02 	add.w	lr, lr, #2
   for (i=0;i<stride;i++)
   20ec8:	45f0      	cmp	r8, lr
   20eca:	d1e2      	bne.n	20e92 <quant_band+0x3ee>
      if (lowband)
   20ecc:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   20ece:	2b00      	cmp	r3, #0
   20ed0:	f43f aeda 	beq.w	20c88 <quant_band+0x1e4>
   20ed4:	4698      	mov	r8, r3
   20ed6:	e6b3      	b.n	20c40 <quant_band+0x19c>
   20ed8:	000377fc 	.word	0x000377fc
   20edc:	00037818 	.word	0x00037818
   20ee0:	00038e98 	.word	0x00038e98
         haar1(X, N>>k, 1<<k);
   20ee4:	69fb      	ldr	r3, [r7, #28]
   20ee6:	4619      	mov	r1, r3
   20ee8:	6abb      	ldr	r3, [r7, #40]	; 0x28
   20eea:	fa41 fc03 	asr.w	ip, r1, r3
   20eee:	2101      	movs	r1, #1
   20ef0:	fa01 f203 	lsl.w	r2, r1, r3
   for (i=0;i<stride;i++)
   20ef4:	2a00      	cmp	r2, #0
         haar1(X, N>>k, 1<<k);
   20ef6:	633a      	str	r2, [r7, #48]	; 0x30
   N0 >>= 1;
   20ef8:	fa4c fc01 	asr.w	ip, ip, r1
   for (i=0;i<stride;i++)
   20efc:	f77f ae5c 	ble.w	20bb8 <quant_band+0x114>
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
   20f00:	2202      	movs	r2, #2
   20f02:	f1bc 0f00 	cmp.w	ip, #0
   20f06:	fa02 fa03 	lsl.w	sl, r2, r3
   20f0a:	f77f ae55 	ble.w	20bb8 <quant_band+0x114>
   20f0e:	fa0a f301 	lsl.w	r3, sl, r1
   20f12:	f8c7 9064 	str.w	r9, [r7, #100]	; 0x64
   20f16:	f8c7 e034 	str.w	lr, [r7, #52]	; 0x34
   20f1a:	61bb      	str	r3, [r7, #24]
   for (i=0;i<stride;i++)
   20f1c:	f04f 0800 	mov.w	r8, #0
   20f20:	4699      	mov	r9, r3
   for (k=0;k<recombine;k++)
   20f22:	e9d7 500c 	ldrd	r5, r0, [r7, #48]	; 0x30
      for (j=0;j<N0;j++)
   20f26:	2400      	movs	r4, #0
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
   20f28:	eb05 0208 	add.w	r2, r5, r8
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
   20f2c:	8803      	ldrh	r3, [r0, #0]
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
   20f2e:	f83e 6012 	ldrh.w	r6, [lr, r2, lsl #1]
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
   20f32:	fb13 f30b 	smulbb	r3, r3, fp
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
   20f36:	fb16 f60b 	smulbb	r6, r6, fp
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
   20f3a:	1999      	adds	r1, r3, r6
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
   20f3c:	1b9b      	subs	r3, r3, r6
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
   20f3e:	f501 4180 	add.w	r1, r1, #16384	; 0x4000
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
   20f42:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
      for (j=0;j<N0;j++)
   20f46:	3401      	adds	r4, #1
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
   20f48:	13c9      	asrs	r1, r1, #15
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
   20f4a:	13db      	asrs	r3, r3, #15
      for (j=0;j<N0;j++)
   20f4c:	45a4      	cmp	ip, r4
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
   20f4e:	8001      	strh	r1, [r0, #0]
   20f50:	4455      	add	r5, sl
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
   20f52:	f82e 3012 	strh.w	r3, [lr, r2, lsl #1]
   20f56:	4448      	add	r0, r9
      for (j=0;j<N0;j++)
   20f58:	d1e6      	bne.n	20f28 <quant_band+0x484>
   20f5a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   20f5c:	3302      	adds	r3, #2
   20f5e:	637b      	str	r3, [r7, #52]	; 0x34
   for (i=0;i<stride;i++)
   20f60:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   20f62:	f108 0801 	add.w	r8, r8, #1
   20f66:	4543      	cmp	r3, r8
   20f68:	d1db      	bne.n	20f22 <quant_band+0x47e>
   20f6a:	f8d7 9064 	ldr.w	r9, [r7, #100]	; 0x64
      if (lowband)
   20f6e:	f1b9 0f00 	cmp.w	r9, #0
   20f72:	f47f adeb 	bne.w	20b4c <quant_band+0xa8>
   20f76:	e61f      	b.n	20bb8 <quant_band+0x114>
   20f78:	f00b 0301 	and.w	r3, fp, #1
   20f7c:	637b      	str	r3, [r7, #52]	; 0x34
   if (lowband_scratch && lowband && (recombine || ((N_B&1) == 0 && tf_change<0) || B0>1))
   20f7e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
   20f80:	2b00      	cmp	r3, #0
   20f82:	f000 81a6 	beq.w	212d2 <quant_band+0x82e>
   20f86:	f1b9 0f00 	cmp.w	r9, #0
   20f8a:	f000 817b 	beq.w	21284 <quant_band+0x7e0>
   20f8e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   20f90:	2b00      	cmp	r3, #0
   20f92:	f040 8145 	bne.w	21220 <quant_band+0x77c>
   20f96:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   20f98:	2b00      	cmp	r3, #0
   20f9a:	f040 81c6 	bne.w	2132a <quant_band+0x886>
   20f9e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   20fa0:	2b01      	cmp	r3, #1
   20fa2:	dd45      	ble.n	21030 <quant_band+0x58c>
      OPUS_COPY(lowband_scratch, lowband, N);
   20fa4:	69fb      	ldr	r3, [r7, #28]
   20fa6:	6f78      	ldr	r0, [r7, #116]	; 0x74
   20fa8:	4649      	mov	r1, r9
   20faa:	005a      	lsls	r2, r3, #1
   20fac:	f7eb f8a8 	bl	c100 <memcpy>
   while ((N_B&1) == 0 && tf_change<0)
   20fb0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   20fb2:	62bb      	str	r3, [r7, #40]	; 0x28
   20fb4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   20fb6:	633b      	str	r3, [r7, #48]	; 0x30
      if (encode)
   20fb8:	6a3b      	ldr	r3, [r7, #32]
   while ((N_B&1) == 0 && tf_change<0)
   20fba:	f8d7 9074 	ldr.w	r9, [r7, #116]	; 0x74
      if (encode)
   20fbe:	2b00      	cmp	r3, #0
   20fc0:	f43f ae7f 	beq.w	20cc2 <quant_band+0x21e>
         deinterleave_hadamard(X, N_B>>recombine, B0<<recombine, longBlocks);
   20fc4:	6abb      	ldr	r3, [r7, #40]	; 0x28
   20fc6:	6b3a      	ldr	r2, [r7, #48]	; 0x30
{
   20fc8:	f8c7 d024 	str.w	sp, [r7, #36]	; 0x24
         deinterleave_hadamard(X, N_B>>recombine, B0<<recombine, longBlocks);
   20fcc:	fa4b f403 	asr.w	r4, fp, r3
   20fd0:	fa02 f103 	lsl.w	r1, r2, r3
   N = N0*stride;
   20fd4:	fb01 f804 	mul.w	r8, r1, r4
   ALLOC(tmp, N, celt_norm);
   20fd8:	ea4f 0848 	mov.w	r8, r8, lsl #1
   20fdc:	f108 0308 	add.w	r3, r8, #8
   20fe0:	f023 0307 	bic.w	r3, r3, #7
   20fe4:	ebad 0d03 	sub.w	sp, sp, r3
   if (hadamard)
   20fe8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   20fea:	2b01      	cmp	r3, #1
   ALLOC(tmp, N, celt_norm);
   20fec:	f10d 0e18 	add.w	lr, sp, #24
   if (hadamard)
   20ff0:	f000 8174 	beq.w	212dc <quant_band+0x838>
      for (i=0;i<stride;i++)
   20ff4:	2900      	cmp	r1, #0
   20ff6:	dd13      	ble.n	21020 <quant_band+0x57c>
   20ff8:	2c00      	cmp	r4, #0
   20ffa:	dd11      	ble.n	21020 <quant_band+0x57c>
   20ffc:	0049      	lsls	r1, r1, #1
   20ffe:	0064      	lsls	r4, r4, #1
   21000:	eb01 060a 	add.w	r6, r1, sl
   21004:	4655      	mov	r5, sl
   21006:	4673      	mov	r3, lr
   21008:	eb04 0c03 	add.w	ip, r4, r3
            tmp[ordery[i]*N0+j] = X[j*stride+i];
   2100c:	462a      	mov	r2, r5
            tmp[i*N0+j] = X[j*stride+i];
   2100e:	8810      	ldrh	r0, [r2, #0]
   21010:	f823 0b02 	strh.w	r0, [r3], #2
         for (j=0;j<N0;j++)
   21014:	459c      	cmp	ip, r3
   21016:	440a      	add	r2, r1
   21018:	d1f9      	bne.n	2100e <quant_band+0x56a>
   2101a:	3502      	adds	r5, #2
      for (i=0;i<stride;i++)
   2101c:	42ae      	cmp	r6, r5
   2101e:	d1f3      	bne.n	21008 <quant_band+0x564>
   OPUS_COPY(X, tmp, N);
   21020:	4642      	mov	r2, r8
   21022:	4671      	mov	r1, lr
   21024:	4650      	mov	r0, sl
   21026:	f7eb f86b 	bl	c100 <memcpy>
   2102a:	f8d7 d024 	ldr.w	sp, [r7, #36]	; 0x24
   2102e:	e648      	b.n	20cc2 <quant_band+0x21e>
   while ((N_B&1) == 0 && tf_change<0)
   21030:	633b      	str	r3, [r7, #48]	; 0x30
   21032:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   21034:	62bb      	str	r3, [r7, #40]	; 0x28
   cm = quant_partition(ctx, X, N, b, B, lowband, LM, gain, fill);
   21036:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   21038:	9304      	str	r3, [sp, #16]
   2103a:	687b      	ldr	r3, [r7, #4]
   2103c:	9303      	str	r3, [sp, #12]
   2103e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   21040:	e9cd 9301 	strd	r9, r3, [sp, #4]
   21044:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   21046:	9300      	str	r3, [sp, #0]
   21048:	693c      	ldr	r4, [r7, #16]
   2104a:	68bb      	ldr	r3, [r7, #8]
   2104c:	69fa      	ldr	r2, [r7, #28]
   2104e:	4651      	mov	r1, sl
   21050:	4620      	mov	r0, r4
   21052:	f7ff f8c3 	bl	201dc <quant_partition>
   if (ctx->resynth)
   21056:	6863      	ldr	r3, [r4, #4]
   cm = quant_partition(ctx, X, N, b, B, lowband, LM, gain, fill);
   21058:	6278      	str	r0, [r7, #36]	; 0x24
   if (ctx->resynth)
   2105a:	2b00      	cmp	r3, #0
   2105c:	f43f af02 	beq.w	20e64 <quant_band+0x3c0>
      for (k=0;k<time_divide;k++)
   21060:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   21062:	2b00      	cmp	r3, #0
   21064:	d04a      	beq.n	210fc <quant_band+0x658>
   21066:	2300      	movs	r3, #0
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
   21068:	f8c7 b020 	str.w	fp, [r7, #32]
   2106c:	f8d7 b030 	ldr.w	fp, [r7, #48]	; 0x30
      for (k=0;k<time_divide;k++)
   21070:	62fb      	str	r3, [r7, #44]	; 0x2c
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
   21072:	f645 2c82 	movw	ip, #23170	; 0x5a82
   21076:	f8c7 a018 	str.w	sl, [r7, #24]
         N_B <<= 1;
   2107a:	6a3b      	ldr	r3, [r7, #32]
         cm |= cm>>B;
   2107c:	6a79      	ldr	r1, [r7, #36]	; 0x24
         B >>= 1;
   2107e:	ea4f 0b6b 	mov.w	fp, fp, asr #1
         N_B <<= 1;
   21082:	005a      	lsls	r2, r3, #1
         cm |= cm>>B;
   21084:	fa21 f30b 	lsr.w	r3, r1, fp
   21088:	430b      	orrs	r3, r1
   for (i=0;i<stride;i++)
   2108a:	f1bb 0f00 	cmp.w	fp, #0
         N_B <<= 1;
   2108e:	623a      	str	r2, [r7, #32]
         cm |= cm>>B;
   21090:	627b      	str	r3, [r7, #36]	; 0x24
   N0 >>= 1;
   21092:	ea4f 0e62 	mov.w	lr, r2, asr #1
   for (i=0;i<stride;i++)
   21096:	dd27      	ble.n	210e8 <quant_band+0x644>
   21098:	f1be 0f00 	cmp.w	lr, #0
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
   2109c:	ea4f 094b 	mov.w	r9, fp, lsl #1
   210a0:	dd22      	ble.n	210e8 <quant_band+0x644>
   210a2:	69bb      	ldr	r3, [r7, #24]
   210a4:	ea4f 068b 	mov.w	r6, fp, lsl #2
   210a8:	4698      	mov	r8, r3
   210aa:	eb09 0a03 	add.w	sl, r9, r3
   210ae:	eb09 0008 	add.w	r0, r9, r8
      for (k=0;k<time_divide;k++)
   210b2:	4641      	mov	r1, r8
      for (j=0;j<N0;j++)
   210b4:	2400      	movs	r4, #0
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
   210b6:	880b      	ldrh	r3, [r1, #0]
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
   210b8:	8805      	ldrh	r5, [r0, #0]
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
   210ba:	fb13 f30c 	smulbb	r3, r3, ip
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
   210be:	fb15 f50c 	smulbb	r5, r5, ip
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
   210c2:	195a      	adds	r2, r3, r5
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
   210c4:	1b5b      	subs	r3, r3, r5
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
   210c6:	f502 4280 	add.w	r2, r2, #16384	; 0x4000
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
   210ca:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
      for (j=0;j<N0;j++)
   210ce:	3401      	adds	r4, #1
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
   210d0:	13d2      	asrs	r2, r2, #15
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
   210d2:	13db      	asrs	r3, r3, #15
      for (j=0;j<N0;j++)
   210d4:	45a6      	cmp	lr, r4
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
   210d6:	800a      	strh	r2, [r1, #0]
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
   210d8:	8003      	strh	r3, [r0, #0]
   210da:	4431      	add	r1, r6
   210dc:	4430      	add	r0, r6
      for (j=0;j<N0;j++)
   210de:	d1ea      	bne.n	210b6 <quant_band+0x612>
   210e0:	f108 0802 	add.w	r8, r8, #2
   for (i=0;i<stride;i++)
   210e4:	45c2      	cmp	sl, r8
   210e6:	d1e2      	bne.n	210ae <quant_band+0x60a>
      for (k=0;k<time_divide;k++)
   210e8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   210ea:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   210ec:	3301      	adds	r3, #1
   210ee:	4293      	cmp	r3, r2
   210f0:	62fb      	str	r3, [r7, #44]	; 0x2c
   210f2:	d1c2      	bne.n	2107a <quant_band+0x5d6>
   210f4:	f8d7 a018 	ldr.w	sl, [r7, #24]
   210f8:	f8c7 b030 	str.w	fp, [r7, #48]	; 0x30
      for (k=0;k<recombine;k++)
   210fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
   210fe:	2b00      	cmp	r3, #0
   21100:	d04b      	beq.n	2119a <quant_band+0x6f6>
   21102:	2300      	movs	r3, #0
   21104:	623b      	str	r3, [r7, #32]
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
   21106:	f645 2b82 	movw	fp, #23170	; 0x5a82
         haar1(X, N0>>k, 1<<k);
   2110a:	69fb      	ldr	r3, [r7, #28]
         cm = bit_deinterleave_table[cm];
   2110c:	6a78      	ldr	r0, [r7, #36]	; 0x24
         haar1(X, N0>>k, 1<<k);
   2110e:	4619      	mov	r1, r3
   21110:	6a3b      	ldr	r3, [r7, #32]
   21112:	fa41 fe03 	asr.w	lr, r1, r3
   21116:	2101      	movs	r1, #1
   21118:	fa01 f203 	lsl.w	r2, r1, r3
         cm = bit_deinterleave_table[cm];
   2111c:	49a4      	ldr	r1, [pc, #656]	; (213b0 <quant_band+0x90c>)
         haar1(X, N0>>k, 1<<k);
   2111e:	62fa      	str	r2, [r7, #44]	; 0x2c
         cm = bit_deinterleave_table[cm];
   21120:	5c09      	ldrb	r1, [r1, r0]
   21122:	6279      	str	r1, [r7, #36]	; 0x24
   for (i=0;i<stride;i++)
   21124:	2a00      	cmp	r2, #0
   N0 >>= 1;
   21126:	ea4f 0e6e 	mov.w	lr, lr, asr #1
   for (i=0;i<stride;i++)
   2112a:	dd2f      	ble.n	2118c <quant_band+0x6e8>
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
   2112c:	2202      	movs	r2, #2
   2112e:	f1be 0f00 	cmp.w	lr, #0
   21132:	fa02 f803 	lsl.w	r8, r2, r3
   21136:	dd29      	ble.n	2118c <quant_band+0x6e8>
   21138:	f8c7 a034 	str.w	sl, [r7, #52]	; 0x34
   2113c:	ea4f 0948 	mov.w	r9, r8, lsl #1
   for (i=0;i<stride;i++)
   21140:	f04f 0c00 	mov.w	ip, #0
      for (k=0;k<recombine;k++)
   21144:	6afd      	ldr	r5, [r7, #44]	; 0x2c
   21146:	6b78      	ldr	r0, [r7, #52]	; 0x34
      for (j=0;j<N0;j++)
   21148:	2400      	movs	r4, #0
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
   2114a:	eb05 020c 	add.w	r2, r5, ip
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
   2114e:	8803      	ldrh	r3, [r0, #0]
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
   21150:	f83a 6012 	ldrh.w	r6, [sl, r2, lsl #1]
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
   21154:	fb13 f30b 	smulbb	r3, r3, fp
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
   21158:	fb16 f60b 	smulbb	r6, r6, fp
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
   2115c:	1999      	adds	r1, r3, r6
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
   2115e:	1b9b      	subs	r3, r3, r6
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
   21160:	f501 4180 	add.w	r1, r1, #16384	; 0x4000
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
   21164:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
      for (j=0;j<N0;j++)
   21168:	3401      	adds	r4, #1
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
   2116a:	13c9      	asrs	r1, r1, #15
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
   2116c:	13db      	asrs	r3, r3, #15
      for (j=0;j<N0;j++)
   2116e:	45a6      	cmp	lr, r4
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
   21170:	8001      	strh	r1, [r0, #0]
   21172:	4445      	add	r5, r8
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
   21174:	f82a 3012 	strh.w	r3, [sl, r2, lsl #1]
   21178:	4448      	add	r0, r9
      for (j=0;j<N0;j++)
   2117a:	d1e6      	bne.n	2114a <quant_band+0x6a6>
   2117c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   2117e:	3302      	adds	r3, #2
   21180:	637b      	str	r3, [r7, #52]	; 0x34
   for (i=0;i<stride;i++)
   21182:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   21184:	f10c 0c01 	add.w	ip, ip, #1
   21188:	4563      	cmp	r3, ip
   2118a:	d1db      	bne.n	21144 <quant_band+0x6a0>
      for (k=0;k<recombine;k++)
   2118c:	6a3b      	ldr	r3, [r7, #32]
   2118e:	6aba      	ldr	r2, [r7, #40]	; 0x28
   21190:	3301      	adds	r3, #1
   21192:	429a      	cmp	r2, r3
   21194:	623b      	str	r3, [r7, #32]
   21196:	d1b8      	bne.n	2110a <quant_band+0x666>
   21198:	4613      	mov	r3, r2
      B<<=recombine;
   2119a:	6b3c      	ldr	r4, [r7, #48]	; 0x30
   2119c:	409c      	lsls	r4, r3
      if (lowband_out)
   2119e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
   211a0:	b1ab      	cbz	r3, 211ce <quant_band+0x72a>
         n = celt_sqrt(SHL32(EXTEND32(N0),22));
   211a2:	69fd      	ldr	r5, [r7, #28]
   211a4:	05a8      	lsls	r0, r5, #22
   211a6:	f00a f967 	bl	2b478 <celt_sqrt>
         for (j=0;j<N0;j++)
   211aa:	2d00      	cmp	r5, #0
         n = celt_sqrt(SHL32(EXTEND32(N0),22));
   211ac:	b200      	sxth	r0, r0
         for (j=0;j<N0;j++)
   211ae:	dd0e      	ble.n	211ce <quant_band+0x72a>
   211b0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
   211b2:	f1aa 0202 	sub.w	r2, sl, #2
   211b6:	eb02 0545 	add.w	r5, r2, r5, lsl #1
   211ba:	1e99      	subs	r1, r3, #2
            lowband_out[j] = MULT16_16_Q15(n,X[j]);
   211bc:	f832 3f02 	ldrh.w	r3, [r2, #2]!
   211c0:	fb13 f300 	smulbb	r3, r3, r0
   211c4:	13db      	asrs	r3, r3, #15
         for (j=0;j<N0;j++)
   211c6:	4295      	cmp	r5, r2
            lowband_out[j] = MULT16_16_Q15(n,X[j]);
   211c8:	f821 3f02 	strh.w	r3, [r1, #2]!
         for (j=0;j<N0;j++)
   211cc:	d1f6      	bne.n	211bc <quant_band+0x718>
      cm &= (1<<B)-1;
   211ce:	2301      	movs	r3, #1
   211d0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   211d2:	40a3      	lsls	r3, r4
   211d4:	3b01      	subs	r3, #1
   211d6:	401a      	ands	r2, r3
   211d8:	627a      	str	r2, [r7, #36]	; 0x24
   211da:	4610      	mov	r0, r2
}
   211dc:	373c      	adds	r7, #60	; 0x3c
   211de:	46bd      	mov	sp, r7
   211e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      for (i=0;i<stride;i++)
   211e4:	2900      	cmp	r1, #0
   211e6:	dd13      	ble.n	21210 <quant_band+0x76c>
   211e8:	2e00      	cmp	r6, #0
   211ea:	dd11      	ble.n	21210 <quant_band+0x76c>
   211ec:	0049      	lsls	r1, r1, #1
   211ee:	0075      	lsls	r5, r6, #1
   211f0:	464c      	mov	r4, r9
   211f2:	eb01 0609 	add.w	r6, r1, r9
   211f6:	4663      	mov	r3, ip
   211f8:	eb05 0e03 	add.w	lr, r5, r3
            tmp[ordery[i]*N0+j] = X[j*stride+i];
   211fc:	4622      	mov	r2, r4
            tmp[i*N0+j] = X[j*stride+i];
   211fe:	8810      	ldrh	r0, [r2, #0]
   21200:	f823 0b02 	strh.w	r0, [r3], #2
         for (j=0;j<N0;j++)
   21204:	459e      	cmp	lr, r3
   21206:	440a      	add	r2, r1
   21208:	d1f9      	bne.n	211fe <quant_band+0x75a>
   2120a:	3402      	adds	r4, #2
      for (i=0;i<stride;i++)
   2120c:	42a6      	cmp	r6, r4
   2120e:	d1f3      	bne.n	211f8 <quant_band+0x754>
   OPUS_COPY(X, tmp, N);
   21210:	4642      	mov	r2, r8
   21212:	4661      	mov	r1, ip
   21214:	4648      	mov	r0, r9
   21216:	f7ea ff73 	bl	c100 <memcpy>
   2121a:	f8d7 d024 	ldr.w	sp, [r7, #36]	; 0x24
   2121e:	e598      	b.n	20d52 <quant_band+0x2ae>
   if (lowband_scratch && lowband && (recombine || ((N_B&1) == 0 && tf_change<0) || B0>1))
   21220:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   21222:	2b01      	cmp	r3, #1
   21224:	f340 8091 	ble.w	2134a <quant_band+0x8a6>
      OPUS_COPY(lowband_scratch, lowband, N);
   21228:	69fb      	ldr	r3, [r7, #28]
   2122a:	6f78      	ldr	r0, [r7, #116]	; 0x74
   2122c:	005a      	lsls	r2, r3, #1
   2122e:	4649      	mov	r1, r9
   21230:	f7ea ff66 	bl	c100 <memcpy>
      if (encode)
   21234:	6a3b      	ldr	r3, [r7, #32]
   21236:	2b00      	cmp	r3, #0
   21238:	f040 80a1 	bne.w	2137e <quant_band+0x8da>
   int time_divide=0;
   2123c:	637b      	str	r3, [r7, #52]	; 0x34
      if (encode)
   2123e:	62bb      	str	r3, [r7, #40]	; 0x28
   B>>=recombine;
   21240:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   21242:	633b      	str	r3, [r7, #48]	; 0x30
      if (encode)
   21244:	f8d7 9074 	ldr.w	r9, [r7, #116]	; 0x74
   21248:	e53e      	b.n	20cc8 <quant_band+0x224>
      for (i=0;i<stride;i++)
   2124a:	2900      	cmp	r1, #0
   2124c:	dd12      	ble.n	21274 <quant_band+0x7d0>
   2124e:	2d00      	cmp	r5, #0
   21250:	dd10      	ble.n	21274 <quant_band+0x7d0>
   21252:	0048      	lsls	r0, r1, #1
   21254:	006e      	lsls	r6, r5, #1
   21256:	eb00 0c0e 	add.w	ip, r0, lr
   2125a:	4653      	mov	r3, sl
   2125c:	4675      	mov	r5, lr
   2125e:	18f4      	adds	r4, r6, r3
            tmp[j*stride+i] = X[ordery[i]*N0+j];
   21260:	462a      	mov	r2, r5
            tmp[j*stride+i] = X[i*N0+j];
   21262:	f933 1b02 	ldrsh.w	r1, [r3], #2
   21266:	8011      	strh	r1, [r2, #0]
         for (j=0;j<N0;j++)
   21268:	429c      	cmp	r4, r3
   2126a:	4402      	add	r2, r0
   2126c:	d1f9      	bne.n	21262 <quant_band+0x7be>
   2126e:	3502      	adds	r5, #2
      for (i=0;i<stride;i++)
   21270:	45ac      	cmp	ip, r5
   21272:	d1f4      	bne.n	2125e <quant_band+0x7ba>
   OPUS_COPY(X, tmp, N);
   21274:	464a      	mov	r2, r9
   21276:	4671      	mov	r1, lr
   21278:	4650      	mov	r0, sl
   2127a:	f7ea ff41 	bl	c100 <memcpy>
   2127e:	f8d7 d02c 	ldr.w	sp, [r7, #44]	; 0x2c
   21282:	e6ed      	b.n	21060 <quant_band+0x5bc>
   if (lowband_scratch && lowband && (recombine || ((N_B&1) == 0 && tf_change<0) || B0>1))
   21284:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   21286:	633b      	str	r3, [r7, #48]	; 0x30
   21288:	f8c7 9028 	str.w	r9, [r7, #40]	; 0x28
   2128c:	e4b2      	b.n	20bf4 <quant_band+0x150>
         if (encode)
   2128e:	6a3b      	ldr	r3, [r7, #32]
   21290:	b1d3      	cbz	r3, 212c8 <quant_band+0x824>
            sign = x[0]<0;
   21292:	f8ba 4000 	ldrh.w	r4, [sl]
            ec_enc_bits(ec, sign, 1);
   21296:	69fa      	ldr	r2, [r7, #28]
            sign = x[0]<0;
   21298:	0be4      	lsrs	r4, r4, #15
            ec_enc_bits(ec, sign, 1);
   2129a:	4621      	mov	r1, r4
   2129c:	f008 feba 	bl	2a014 <ec_enc_bits>
         ctx->remaining_bits -= 1<<BITRES;
   212a0:	6939      	ldr	r1, [r7, #16]
   212a2:	6a0b      	ldr	r3, [r1, #32]
      if (ctx->resynth)
   212a4:	684a      	ldr	r2, [r1, #4]
         ctx->remaining_bits -= 1<<BITRES;
   212a6:	3b08      	subs	r3, #8
   212a8:	620b      	str	r3, [r1, #32]
      if (ctx->resynth)
   212aa:	2a00      	cmp	r2, #0
   212ac:	f43f adce 	beq.w	20e4c <quant_band+0x3a8>
         x[0] = sign ? -NORM_SCALING : NORM_SCALING;
   212b0:	2c00      	cmp	r4, #0
   212b2:	f43f adc7 	beq.w	20e44 <quant_band+0x3a0>
   212b6:	4b3f      	ldr	r3, [pc, #252]	; (213b4 <quant_band+0x910>)
   212b8:	e5c6      	b.n	20e48 <quant_band+0x3a4>
      return quant_band_n1(ctx, X, NULL, b, lowband_out);
   212ba:	2301      	movs	r3, #1
   212bc:	627b      	str	r3, [r7, #36]	; 0x24
   212be:	4618      	mov	r0, r3
}
   212c0:	373c      	adds	r7, #60	; 0x3c
   212c2:	46bd      	mov	sp, r7
   212c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            sign = ec_dec_bits(ec, 1);
   212c8:	69f9      	ldr	r1, [r7, #28]
   212ca:	f008 fc35 	bl	29b38 <ec_dec_bits>
   212ce:	4604      	mov	r4, r0
   212d0:	e7e6      	b.n	212a0 <quant_band+0x7fc>
   if (lowband_scratch && lowband && (recombine || ((N_B&1) == 0 && tf_change<0) || B0>1))
   212d2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   212d4:	633b      	str	r3, [r7, #48]	; 0x30
   212d6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
   212d8:	62bb      	str	r3, [r7, #40]	; 0x28
   212da:	e48b      	b.n	20bf4 <quant_band+0x150>
      const int *ordery = ordery_table+stride-2;
   212dc:	f101 4680 	add.w	r6, r1, #1073741824	; 0x40000000
   212e0:	3e02      	subs	r6, #2
      for (i=0;i<stride;i++)
   212e2:	2900      	cmp	r1, #0
      const int *ordery = ordery_table+stride-2;
   212e4:	ea4f 0686 	mov.w	r6, r6, lsl #2
      for (i=0;i<stride;i++)
   212e8:	f77f ae9a 	ble.w	21020 <quant_band+0x57c>
   212ec:	2c00      	cmp	r4, #0
   212ee:	f77f ae97 	ble.w	21020 <quant_band+0x57c>
   212f2:	4b31      	ldr	r3, [pc, #196]	; (213b8 <quant_band+0x914>)
   212f4:	0049      	lsls	r1, r1, #1
   212f6:	eb01 0c0a 	add.w	ip, r1, sl
   212fa:	441e      	add	r6, r3
   212fc:	4655      	mov	r5, sl
            tmp[ordery[i]*N0+j] = X[j*stride+i];
   212fe:	f856 3f04 	ldr.w	r3, [r6, #4]!
   21302:	62fc      	str	r4, [r7, #44]	; 0x2c
   21304:	fb03 f304 	mul.w	r3, r3, r4
   21308:	18e0      	adds	r0, r4, r3
   2130a:	eb0e 0040 	add.w	r0, lr, r0, lsl #1
   2130e:	eb0e 0343 	add.w	r3, lr, r3, lsl #1
   21312:	462a      	mov	r2, r5
   21314:	8814      	ldrh	r4, [r2, #0]
   21316:	f823 4b02 	strh.w	r4, [r3], #2
         for (j=0;j<N0;j++)
   2131a:	4298      	cmp	r0, r3
   2131c:	440a      	add	r2, r1
   2131e:	d1f9      	bne.n	21314 <quant_band+0x870>
   21320:	3502      	adds	r5, #2
      for (i=0;i<stride;i++)
   21322:	45ac      	cmp	ip, r5
   21324:	6afc      	ldr	r4, [r7, #44]	; 0x2c
   21326:	d1ea      	bne.n	212fe <quant_band+0x85a>
   21328:	e67a      	b.n	21020 <quant_band+0x57c>
      OPUS_COPY(lowband_scratch, lowband, N);
   2132a:	69fb      	ldr	r3, [r7, #28]
   2132c:	6f78      	ldr	r0, [r7, #116]	; 0x74
   2132e:	4649      	mov	r1, r9
   21330:	005a      	lsls	r2, r3, #1
   21332:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   21334:	62bb      	str	r3, [r7, #40]	; 0x28
   21336:	f7ea fee3 	bl	c100 <memcpy>
   2133a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   2133c:	f8d7 9074 	ldr.w	r9, [r7, #116]	; 0x74
   21340:	633b      	str	r3, [r7, #48]	; 0x30
   21342:	e45e      	b.n	20c02 <quant_band+0x15e>
   int time_divide=0;
   21344:	2300      	movs	r3, #0
   21346:	637b      	str	r3, [r7, #52]	; 0x34
   21348:	e4b3      	b.n	20cb2 <quant_band+0x20e>
   cm = quant_partition(ctx, X, N, b, B, lowband, LM, gain, fill);
   2134a:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   2134c:	9304      	str	r3, [sp, #16]
   2134e:	687b      	ldr	r3, [r7, #4]
   21350:	9303      	str	r3, [sp, #12]
   21352:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   21354:	e9cd 9301 	strd	r9, r3, [sp, #4]
   21358:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   2135a:	9300      	str	r3, [sp, #0]
   2135c:	693c      	ldr	r4, [r7, #16]
   2135e:	68bb      	ldr	r3, [r7, #8]
   21360:	69fa      	ldr	r2, [r7, #28]
   21362:	4651      	mov	r1, sl
   21364:	4620      	mov	r0, r4
   21366:	f7fe ff39 	bl	201dc <quant_partition>
   if (ctx->resynth)
   2136a:	6863      	ldr	r3, [r4, #4]
   cm = quant_partition(ctx, X, N, b, B, lowband, LM, gain, fill);
   2136c:	6278      	str	r0, [r7, #36]	; 0x24
   if (ctx->resynth)
   2136e:	2b00      	cmp	r3, #0
   21370:	f43f ad78 	beq.w	20e64 <quant_band+0x3c0>
   B>>=recombine;
   21374:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   21376:	633b      	str	r3, [r7, #48]	; 0x30
   if (ctx->resynth)
   21378:	2300      	movs	r3, #0
   2137a:	62bb      	str	r3, [r7, #40]	; 0x28
   2137c:	e70d      	b.n	2119a <quant_band+0x6f6>
   N = N0*stride;
   2137e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
{
   21380:	f8c7 d024 	str.w	sp, [r7, #36]	; 0x24
   N = N0*stride;
   21384:	fb0b f803 	mul.w	r8, fp, r3
   ALLOC(tmp, N, celt_norm);
   21388:	ea4f 0848 	mov.w	r8, r8, lsl #1
   2138c:	f108 0308 	add.w	r3, r8, #8
   21390:	f023 0307 	bic.w	r3, r3, #7
   int time_divide=0;
   21394:	2200      	movs	r2, #0
   ALLOC(tmp, N, celt_norm);
   21396:	ebad 0d03 	sub.w	sp, sp, r3
         deinterleave_hadamard(X, N_B>>recombine, B0<<recombine, longBlocks);
   2139a:	6e39      	ldr	r1, [r7, #96]	; 0x60
   int time_divide=0;
   2139c:	637a      	str	r2, [r7, #52]	; 0x34
   ALLOC(tmp, N, celt_norm);
   2139e:	f10d 0e18 	add.w	lr, sp, #24
   213a2:	62ba      	str	r2, [r7, #40]	; 0x28
         deinterleave_hadamard(X, N_B>>recombine, B0<<recombine, longBlocks);
   213a4:	465c      	mov	r4, fp
   ALLOC(tmp, N, celt_norm);
   213a6:	f8d7 9074 	ldr.w	r9, [r7, #116]	; 0x74
   B>>=recombine;
   213aa:	6339      	str	r1, [r7, #48]	; 0x30
   213ac:	e624      	b.n	20ff8 <quant_band+0x554>
   213ae:	bf00      	nop
   213b0:	000377ec 	.word	0x000377ec
   213b4:	ffffc000 	.word	0xffffc000
   213b8:	00037818 	.word	0x00037818

000213bc <quant_band_stereo>:
/* This function is responsible for encoding and decoding a band for the stereo case. */
static unsigned quant_band_stereo(struct band_ctx *ctx, celt_norm *X, celt_norm *Y,
      int N, int b, int B, celt_norm *lowband,
      int LM, celt_norm *lowband_out,
      celt_norm *lowband_scratch, int fill)
{
   213bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   213c0:	469a      	mov	sl, r3
   213c2:	b091      	sub	sp, #68	; 0x44
   struct split_ctx sctx;
   int orig_fill;
   int encode;
   ec_ctx *ec;

   encode = ctx->encode;
   213c4:	6803      	ldr	r3, [r0, #0]
{
   213c6:	9109      	str	r1, [sp, #36]	; 0x24
   ec = ctx->ec;

   /* Special case for one sample */
   if (N==1)
   213c8:	f1ba 0f01 	cmp.w	sl, #1
{
   213cc:	4604      	mov	r4, r0
   213ce:	4693      	mov	fp, r2
   encode = ctx->encode;
   213d0:	9308      	str	r3, [sp, #32]
   ec = ctx->ec;
   213d2:	f8d0 801c 	ldr.w	r8, [r0, #28]
   if (N==1)
   213d6:	f000 81ac 	beq.w	21732 <quant_band_stereo+0x376>
   i = ctx->i;
   213da:	e9d0 9302 	ldrd	r9, r3, [r0, #8]
   213de:	4619      	mov	r1, r3
   213e0:	930a      	str	r3, [sp, #40]	; 0x28
   pulse_cap = m->logN[i]+LM*(1<<BITRES);
   213e2:	f8d9 3030 	ldr.w	r3, [r9, #48]	; 0x30
   intensity = ctx->intensity;
   213e6:	6902      	ldr	r2, [r0, #16]
   pulse_cap = m->logN[i]+LM*(1<<BITRES);
   213e8:	f933 3011 	ldrsh.w	r3, [r3, r1, lsl #1]
   bandE = ctx->bandE;
   213ec:	6a41      	ldr	r1, [r0, #36]	; 0x24
   213ee:	910d      	str	r1, [sp, #52]	; 0x34
   pulse_cap = m->logN[i]+LM*(1<<BITRES);
   213f0:	991d      	ldr	r1, [sp, #116]	; 0x74
   offset = (pulse_cap>>1) - (stereo&&N==2 ? QTHETA_OFFSET_TWOPHASE : QTHETA_OFFSET);
   213f2:	f1ba 0f02 	cmp.w	sl, #2
   pulse_cap = m->logN[i]+LM*(1<<BITRES);
   213f6:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
   offset = (pulse_cap>>1) - (stereo&&N==2 ? QTHETA_OFFSET_TWOPHASE : QTHETA_OFFSET);
   213fa:	ea4f 0063 	mov.w	r0, r3, asr #1
   213fe:	f000 814c 	beq.w	2169a <quant_band_stereo+0x2de>
   int N2 = 2*N-1;
   21402:	ea4f 054a 	mov.w	r5, sl, lsl #1
   21406:	1e69      	subs	r1, r5, #1
   qb = celt_sudiv(b+N2*offset, N2);
   21408:	9d1a      	ldr	r5, [sp, #104]	; 0x68
   offset = (pulse_cap>>1) - (stereo&&N==2 ? QTHETA_OFFSET_TWOPHASE : QTHETA_OFFSET);
   2140a:	3804      	subs	r0, #4
   qb = celt_sudiv(b+N2*offset, N2);
   2140c:	fb01 5000 	mla	r0, r1, r0, r5
   if (n<0)
   21410:	2800      	cmp	r0, #0
   21412:	460d      	mov	r5, r1
   21414:	f2c0 843f 	blt.w	21c96 <quant_band_stereo+0x8da>
   if (d>256)
   21418:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
   else
      return celt_udiv(n, d);
   2141c:	4606      	mov	r6, r0
   if (d>256)
   2141e:	f240 8144 	bls.w	216aa <quant_band_stereo+0x2ee>
      return n/d;
   21422:	fbb0 f5f1 	udiv	r5, r0, r1
   qb = IMIN(b-pulse_cap-(4<<BITRES), qb);
   21426:	991a      	ldr	r1, [sp, #104]	; 0x68
   21428:	1acb      	subs	r3, r1, r3
   2142a:	f1a3 011f 	sub.w	r1, r3, #31
   2142e:	42a9      	cmp	r1, r5
   21430:	bfd8      	it	le
   21432:	f1a3 0520 	suble.w	r5, r3, #32
   if (qb<(1<<BITRES>>1)) {
   21436:	2d03      	cmp	r5, #3
   21438:	f340 814e 	ble.w	216d8 <quant_band_stereo+0x31c>
   qb = IMIN(8<<BITRES, qb);
   2143c:	2d40      	cmp	r5, #64	; 0x40
   2143e:	bfa8      	it	ge
   21440:	2540      	movge	r5, #64	; 0x40
      qn = exp2_table8[qb&0x7]>>(14-(qb>>BITRES));
   21442:	f005 0107 	and.w	r1, r5, #7
   21446:	4bc0      	ldr	r3, [pc, #768]	; (21748 <quant_band_stereo+0x38c>)
   21448:	10ed      	asrs	r5, r5, #3
   2144a:	f933 7011 	ldrsh.w	r7, [r3, r1, lsl #1]
   if (stereo && i>=intensity)
   2144e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
      qn = exp2_table8[qb&0x7]>>(14-(qb>>BITRES));
   21450:	f1c5 050e 	rsb	r5, r5, #14
   21454:	fa47 f505 	asr.w	r5, r7, r5
      qn = (qn+1)>>1<<1;
   21458:	1c6f      	adds	r7, r5, #1
   if (stereo && i>=intensity)
   2145a:	4293      	cmp	r3, r2
      qn = (qn+1)>>1<<1;
   2145c:	f027 0501 	bic.w	r5, r7, #1
   if (stereo && i>=intensity)
   21460:	f280 813a 	bge.w	216d8 <quant_band_stereo+0x31c>
   if (encode)
   21464:	9b08      	ldr	r3, [sp, #32]
   21466:	2b00      	cmp	r3, #0
   21468:	f040 8336 	bne.w	21ad8 <quant_band_stereo+0x71c>
   tell = ec_tell_frac(ec);
   2146c:	4640      	mov	r0, r8
   2146e:	f008 f95d 	bl	2972c <ec_tell_frac>
      if (stereo && N>2)
   21472:	f1ba 0f02 	cmp.w	sl, #2
   tell = ec_tell_frac(ec);
   21476:	900b      	str	r0, [sp, #44]	; 0x2c
      if (stereo && N>2)
   21478:	f300 84f6 	bgt.w	21e68 <quant_band_stereo+0xaac>
            itheta = ec_dec_uint(ec, qn+1);
   2147c:	1c69      	adds	r1, r5, #1
   2147e:	4640      	mov	r0, r8
   21480:	f008 fa3e 	bl	29900 <ec_dec_uint>
   21484:	4606      	mov	r6, r0
   if (d>256)
   21486:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
      itheta = celt_udiv((opus_int32)itheta*16384, qn);
   2148a:	ea4f 3686 	mov.w	r6, r6, lsl #14
   2148e:	f240 830c 	bls.w	21aaa <quant_band_stereo+0x6ee>
      return n/d;
   21492:	fbb6 f5f5 	udiv	r5, r6, r5
      if (encode && stereo)
   21496:	9b08      	ldr	r3, [sp, #32]
      itheta = celt_udiv((opus_int32)itheta*16384, qn);
   21498:	950c      	str	r5, [sp, #48]	; 0x30
      if (encode && stereo)
   2149a:	2b00      	cmp	r3, #0
   2149c:	f000 82dd 	beq.w	21a5a <quant_band_stereo+0x69e>
         if (itheta==0)
   214a0:	2d00      	cmp	r5, #0
   214a2:	f000 84cb 	beq.w	21e3c <quant_band_stereo+0xa80>
   for (j=0;j<N;j++)
   214a6:	f1ba 0f00 	cmp.w	sl, #0
   214aa:	dd17      	ble.n	214dc <quant_band_stereo+0x120>
   214ac:	9b09      	ldr	r3, [sp, #36]	; 0x24
   214ae:	1e99      	subs	r1, r3, #2
   214b0:	eb01 0c4a 	add.w	ip, r1, sl, lsl #1
   214b4:	f1ab 0602 	sub.w	r6, fp, #2
      l = MULT16_16(QCONST16(.70710678f, 15), X[j]);
   214b8:	f645 2782 	movw	r7, #23170	; 0x5a82
   214bc:	f831 3f02 	ldrh.w	r3, [r1, #2]!
      r = MULT16_16(QCONST16(.70710678f, 15), Y[j]);
   214c0:	f836 2f02 	ldrh.w	r2, [r6, #2]!
      l = MULT16_16(QCONST16(.70710678f, 15), X[j]);
   214c4:	fb13 f007 	smulbb	r0, r3, r7
      r = MULT16_16(QCONST16(.70710678f, 15), Y[j]);
   214c8:	fb12 f307 	smulbb	r3, r2, r7
      X[j] = EXTRACT16(SHR32(ADD32(l, r), 15));
   214cc:	18c2      	adds	r2, r0, r3
      Y[j] = EXTRACT16(SHR32(SUB32(r, l), 15));
   214ce:	1a1b      	subs	r3, r3, r0
      X[j] = EXTRACT16(SHR32(ADD32(l, r), 15));
   214d0:	13d2      	asrs	r2, r2, #15
      Y[j] = EXTRACT16(SHR32(SUB32(r, l), 15));
   214d2:	13db      	asrs	r3, r3, #15
   for (j=0;j<N;j++)
   214d4:	458c      	cmp	ip, r1
      X[j] = EXTRACT16(SHR32(ADD32(l, r), 15));
   214d6:	800a      	strh	r2, [r1, #0]
      Y[j] = EXTRACT16(SHR32(SUB32(r, l), 15));
   214d8:	8033      	strh	r3, [r6, #0]
   for (j=0;j<N;j++)
   214da:	d1ef      	bne.n	214bc <quant_band_stereo+0x100>
   qalloc = ec_tell_frac(ec) - tell;
   214dc:	4640      	mov	r0, r8
   214de:	f008 f925 	bl	2972c <ec_tell_frac>
   214e2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   214e4:	1ac3      	subs	r3, r0, r3
   214e6:	930a      	str	r3, [sp, #40]	; 0x28
   *b -= qalloc;
   214e8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   214ea:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   } else if (itheta == 16384)
   214ec:	f5b5 4f80 	cmp.w	r5, #16384	; 0x4000
   *b -= qalloc;
   214f0:	eba3 0702 	sub.w	r7, r3, r2
   } else if (itheta == 16384)
   214f4:	f000 82c1 	beq.w	21a7a <quant_band_stereo+0x6be>
      iside = bitexact_cos((opus_int16)(16384-itheta));
   214f8:	f5c5 4180 	rsb	r1, r5, #16384	; 0x4000
   tmp = (4096+((opus_int32)(x)*(x)))>>13;
   214fc:	f44f 5380 	mov.w	r3, #4096	; 0x1000
      iside = bitexact_cos((opus_int16)(16384-itheta));
   21500:	b209      	sxth	r1, r1
   tmp = (4096+((opus_int32)(x)*(x)))>>13;
   21502:	fb01 3101 	mla	r1, r1, r1, r3
      imid = bitexact_cos((opus_int16)itheta);
   21506:	fa0f fe85 	sxth.w	lr, r5
   tmp = (4096+((opus_int32)(x)*(x)))>>13;
   2150a:	1349      	asrs	r1, r1, #13
   2150c:	fb0e 3e0e 	mla	lr, lr, lr, r3
   x2 = (32767-x2) + FRAC_MUL16(x2, (-7651 + FRAC_MUL16(x2, (8277 + FRAC_MUL16(-626, x2)))));
   21510:	f44f 4c80 	mov.w	ip, #16384	; 0x4000
   x2 = tmp;
   21514:	fa0f f981 	sxth.w	r9, r1
   tmp = (4096+((opus_int32)(x)*(x)))>>13;
   21518:	ea4f 3e6e 	mov.w	lr, lr, asr #13
   x2 = (32767-x2) + FRAC_MUL16(x2, (-7651 + FRAC_MUL16(x2, (8277 + FRAC_MUL16(-626, x2)))));
   2151c:	f64f 538e 	movw	r3, #64910	; 0xfd8e
   x2 = tmp;
   21520:	fa0f f68e 	sxth.w	r6, lr
   x2 = (32767-x2) + FRAC_MUL16(x2, (-7651 + FRAC_MUL16(x2, (8277 + FRAC_MUL16(-626, x2)))));
   21524:	fb19 c203 	smlabb	r2, r9, r3, ip
   tmp = (4096+((opus_int32)(x)*(x)))>>13;
   21528:	4608      	mov	r0, r1
   x2 = (32767-x2) + FRAC_MUL16(x2, (-7651 + FRAC_MUL16(x2, (8277 + FRAC_MUL16(-626, x2)))));
   2152a:	f242 0155 	movw	r1, #8277	; 0x2055
   2152e:	fb16 c303 	smlabb	r3, r6, r3, ip
   21532:	eb01 32e2 	add.w	r2, r1, r2, asr #15
   21536:	eb01 33e3 	add.w	r3, r1, r3, asr #15
   2153a:	b292      	uxth	r2, r2
   2153c:	fb09 f202 	mul.w	r2, r9, r2
   21540:	b29b      	uxth	r3, r3
   21542:	4462      	add	r2, ip
   21544:	fb06 f303 	mul.w	r3, r6, r3
   21548:	4463      	add	r3, ip
   2154a:	13d2      	asrs	r2, r2, #15
   2154c:	f5a2 52ef 	sub.w	r2, r2, #7648	; 0x1de0
   21550:	13db      	asrs	r3, r3, #15
   21552:	3a03      	subs	r2, #3
   21554:	f5a3 53ef 	sub.w	r3, r3, #7648	; 0x1de0
   return 1+x2;
   21558:	f5c0 4100 	rsb	r1, r0, #32768	; 0x8000
   x2 = (32767-x2) + FRAC_MUL16(x2, (-7651 + FRAC_MUL16(x2, (8277 + FRAC_MUL16(-626, x2)))));
   2155c:	fb19 c202 	smlabb	r2, r9, r2, ip
   21560:	3b03      	subs	r3, #3
   21562:	fb16 c303 	smlabb	r3, r6, r3, ip
   return 1+x2;
   21566:	eb01 32e2 	add.w	r2, r1, r2, asr #15
   2156a:	f5ce 4600 	rsb	r6, lr, #32768	; 0x8000
   2156e:	b212      	sxth	r2, r2
   21570:	eb06 36e3 	add.w	r6, r6, r3, asr #15
   21574:	b236      	sxth	r6, r6
   ls=EC_ILOG(isin);
   21576:	fab2 f382 	clz	r3, r2
   isin<<=15-ls;
   2157a:	930d      	str	r3, [sp, #52]	; 0x34
   2157c:	f1a3 0111 	sub.w	r1, r3, #17
   lc=EC_ILOG(icos);
   21580:	fab6 f386 	clz	r3, r6
   icos<<=15-lc;
   21584:	f1a3 0e11 	sub.w	lr, r3, #17
   isin<<=15-ls;
   21588:	fa02 f101 	lsl.w	r1, r2, r1
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
   2158c:	f24f 59db 	movw	r9, #62939	; 0xf5db
   icos<<=15-lc;
   21590:	fa06 fe0e 	lsl.w	lr, r6, lr
   lc=EC_ILOG(icos);
   21594:	4618      	mov	r0, r3
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
   21596:	b209      	sxth	r1, r1
   21598:	464b      	mov	r3, r9
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
   2159a:	fa0f fe8e 	sxth.w	lr, lr
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
   2159e:	fb11 c909 	smlabb	r9, r1, r9, ip
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
   215a2:	fb1e c303 	smlabb	r3, lr, r3, ip
   isin<<=15-ls;
   215a6:	920b      	str	r2, [sp, #44]	; 0x2c
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
   215a8:	f641 62fc 	movw	r2, #7932	; 0x1efc
   215ac:	eb02 39e9 	add.w	r9, r2, r9, asr #15
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
   215b0:	eb02 32e3 	add.w	r2, r2, r3, asr #15
   return (ls-lc)*(1<<11)
   215b4:	4603      	mov	r3, r0
   215b6:	980d      	ldr	r0, [sp, #52]	; 0x34
      imid = bitexact_cos((opus_int16)itheta);
   215b8:	960d      	str	r6, [sp, #52]	; 0x34
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
   215ba:	fa1f f989 	uxth.w	r9, r9
   215be:	fb01 f109 	mul.w	r1, r1, r9
   return (ls-lc)*(1<<11)
   215c2:	1a1b      	subs	r3, r3, r0
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
   215c4:	b292      	uxth	r2, r2
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
   215c6:	4461      	add	r1, ip
   return (ls-lc)*(1<<11)
   215c8:	02db      	lsls	r3, r3, #11
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
   215ca:	fb0e f202 	mul.w	r2, lr, r2
   215ce:	4462      	add	r2, ip
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
   215d0:	eb03 31e1 	add.w	r1, r3, r1, asr #15
      delta = FRAC_MUL16((N-1)<<7,bitexact_log2tan(iside,imid));
   215d4:	f10a 33ff 	add.w	r3, sl, #4294967295	; 0xffffffff
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
   215d8:	eba1 31e2 	sub.w	r1, r1, r2, asr #15
      delta = FRAC_MUL16((N-1)<<7,bitexact_log2tan(iside,imid));
   215dc:	01db      	lsls	r3, r3, #7
   215de:	fb13 cc01 	smlabb	ip, r3, r1, ip
#endif

   /* This is a special case for N=2 that only works for stereo and takes
      advantage of the fact that mid and side are orthogonal to encode
      the side with just one bit. */
   if (N==2)
   215e2:	f1ba 0f02 	cmp.w	sl, #2
      delta = FRAC_MUL16((N-1)<<7,bitexact_log2tan(iside,imid));
   215e6:	ea4f 33ec 	mov.w	r3, ip, asr #15
      iside = bitexact_cos((opus_int16)(16384-itheta));
   215ea:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
   215ee:	6a22      	ldr	r2, [r4, #32]
   if (N==2)
   215f0:	f000 83ea 	beq.w	21dc8 <quant_band_stereo+0xa0c>
   215f4:	2100      	movs	r1, #0
   215f6:	9108      	str	r1, [sp, #32]
      }
   } else {
      /* "Normal" split code */
      opus_int32 rebalance;

      mbits = IMAX(0, IMIN(b, (b-delta)/2));
   215f8:	1afd      	subs	r5, r7, r3
   215fa:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
   215fe:	106d      	asrs	r5, r5, #1
   21600:	42bd      	cmp	r5, r7
   21602:	bfa8      	it	ge
   21604:	463d      	movge	r5, r7
      sbits = b-mbits;
      ctx->remaining_bits -= qalloc;
   21606:	9b0a      	ldr	r3, [sp, #40]	; 0x28
      mbits = IMAX(0, IMIN(b, (b-delta)/2));
   21608:	ea25 75e5 	bic.w	r5, r5, r5, asr #31
      sbits = b-mbits;
   2160c:	eba7 0805 	sub.w	r8, r7, r5
      ctx->remaining_bits -= qalloc;
   21610:	1ad7      	subs	r7, r2, r3
   21612:	9b20      	ldr	r3, [sp, #128]	; 0x80
   21614:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   21616:	6227      	str	r7, [r4, #32]
   21618:	4113      	asrs	r3, r2

      rebalance = ctx->remaining_bits;
      if (mbits >= sbits)
   2161a:	4545      	cmp	r5, r8
   2161c:	930a      	str	r3, [sp, #40]	; 0x28
   2161e:	f2c0 8108 	blt.w	21832 <quant_band_stereo+0x476>
      {
         /* In stereo mode, we do not apply a scaling to the mid because we need the normalized
            mid for folding later. */
         cm = quant_band(ctx, X, N, mbits, B, lowband, LM, lowband_out, Q15ONE,
   21622:	9a20      	ldr	r2, [sp, #128]	; 0x80
   21624:	9206      	str	r2, [sp, #24]
   21626:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   21628:	9205      	str	r2, [sp, #20]
   2162a:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   2162c:	9203      	str	r2, [sp, #12]
   2162e:	9a1d      	ldr	r2, [sp, #116]	; 0x74
   21630:	9202      	str	r2, [sp, #8]
   21632:	9a1c      	ldr	r2, [sp, #112]	; 0x70
   21634:	9201      	str	r2, [sp, #4]
   21636:	f647 73ff 	movw	r3, #32767	; 0x7fff
   2163a:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   2163c:	9200      	str	r2, [sp, #0]
   2163e:	9304      	str	r3, [sp, #16]
   21640:	4652      	mov	r2, sl
   21642:	462b      	mov	r3, r5
   21644:	9909      	ldr	r1, [sp, #36]	; 0x24
   21646:	4620      	mov	r0, r4
   21648:	f7ff fa2c 	bl	20aa4 <quant_band>
               lowband_scratch, fill);
         rebalance = mbits - (rebalance-ctx->remaining_bits);
   2164c:	6a23      	ldr	r3, [r4, #32]
         cm = quant_band(ctx, X, N, mbits, B, lowband, LM, lowband_out, Q15ONE,
   2164e:	900b      	str	r0, [sp, #44]	; 0x2c
         rebalance = mbits - (rebalance-ctx->remaining_bits);
   21650:	1aff      	subs	r7, r7, r3
   21652:	1bed      	subs	r5, r5, r7
         if (rebalance > 3<<BITRES && itheta!=0)
   21654:	2d18      	cmp	r5, #24
   21656:	dd03      	ble.n	21660 <quant_band_stereo+0x2a4>
   21658:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   2165a:	b10b      	cbz	r3, 21660 <quant_band_stereo+0x2a4>
            sbits += rebalance - (3<<BITRES);
   2165c:	3d18      	subs	r5, #24
   2165e:	44a8      	add	r8, r5

         /* For a stereo split, the high bits of fill are always zero, so no
            folding will be done to the side. */
         cm |= quant_band(ctx, Y, N, sbits, B, NULL, LM, NULL, side, NULL, fill>>B);
   21660:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   21662:	9306      	str	r3, [sp, #24]
   21664:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   21666:	9302      	str	r3, [sp, #8]
   21668:	2200      	movs	r2, #0
   2166a:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
   2166c:	9300      	str	r3, [sp, #0]
   2166e:	9205      	str	r2, [sp, #20]
   21670:	4643      	mov	r3, r8
   21672:	9203      	str	r2, [sp, #12]
   21674:	9201      	str	r2, [sp, #4]
   21676:	f8cd 9010 	str.w	r9, [sp, #16]
   2167a:	4652      	mov	r2, sl
   2167c:	4659      	mov	r1, fp
   2167e:	4620      	mov	r0, r4
   21680:	f7ff fa10 	bl	20aa4 <quant_band>
   21684:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   21686:	ea43 0800 	orr.w	r8, r3, r0
      }
   }


   /* This code is used by the decoder and by the resynthesis-enabled encoder */
   if (ctx->resynth)
   2168a:	6863      	ldr	r3, [r4, #4]
   2168c:	2b00      	cmp	r3, #0
   2168e:	f040 810c 	bne.w	218aa <quant_band_stereo+0x4ee>
         for (j=0;j<N;j++)
            Y[j] = -Y[j];
      }
   }
   return cm;
}
   21692:	4640      	mov	r0, r8
   21694:	b011      	add	sp, #68	; 0x44
   21696:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   if (n<0)
   2169a:	991a      	ldr	r1, [sp, #104]	; 0x68
   offset = (pulse_cap>>1) - (stereo&&N==2 ? QTHETA_OFFSET_TWOPHASE : QTHETA_OFFSET);
   2169c:	f1a0 0610 	sub.w	r6, r0, #16
   216a0:	eb11 0646 	adds.w	r6, r1, r6, lsl #1
   216a4:	f100 80a2 	bmi.w	217ec <quant_band_stereo+0x430>
      return celt_udiv(n, d);
   216a8:	4655      	mov	r5, sl
      t = EC_ILOG(d&-d);
   216aa:	4268      	negs	r0, r5
   216ac:	4028      	ands	r0, r5
   216ae:	fab0 f080 	clz	r0, r0
   216b2:	f1c0 0020 	rsb	r0, r0, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   216b6:	fa25 f700 	lsr.w	r7, r5, r0
   216ba:	4924      	ldr	r1, [pc, #144]	; (2174c <quant_band_stereo+0x390>)
   216bc:	3801      	subs	r0, #1
   216be:	f851 1027 	ldr.w	r1, [r1, r7, lsl #2]
   216c2:	fa26 f000 	lsr.w	r0, r6, r0
   216c6:	fba0 0101 	umull	r0, r1, r0, r1
      return q+(n-q*d >= d);
   216ca:	fb05 6611 	mls	r6, r5, r1, r6
   216ce:	42b5      	cmp	r5, r6
   216d0:	bf8c      	ite	hi
   216d2:	460d      	movhi	r5, r1
   216d4:	1c4d      	addls	r5, r1, #1
   216d6:	e6a6      	b.n	21426 <quant_band_stereo+0x6a>
   if (encode)
   216d8:	9d08      	ldr	r5, [sp, #32]
   216da:	2d00      	cmp	r5, #0
   216dc:	f040 822c 	bne.w	21b38 <quant_band_stereo+0x77c>
   tell = ec_tell_frac(ec);
   216e0:	4640      	mov	r0, r8
   216e2:	f008 f823 	bl	2972c <ec_tell_frac>
   216e6:	4606      	mov	r6, r0
      if (*b>2<<BITRES && ctx->remaining_bits > 2<<BITRES)
   216e8:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   216ea:	2b10      	cmp	r3, #16
   216ec:	dc70      	bgt.n	217d0 <quant_band_stereo+0x414>
         inv = 0;
   216ee:	2300      	movs	r3, #0
   216f0:	9308      	str	r3, [sp, #32]
      if (ctx->disable_inv)
   216f2:	6b63      	ldr	r3, [r4, #52]	; 0x34
   qalloc = ec_tell_frac(ec) - tell;
   216f4:	4640      	mov	r0, r8
      if (ctx->disable_inv)
   216f6:	2b00      	cmp	r3, #0
   216f8:	f040 82d6 	bne.w	21ca8 <quant_band_stereo+0x8ec>
   qalloc = ec_tell_frac(ec) - tell;
   216fc:	f008 f816 	bl	2972c <ec_tell_frac>
   21700:	1b83      	subs	r3, r0, r6
   21702:	930a      	str	r3, [sp, #40]	; 0x28
   *b -= qalloc;
   21704:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   21706:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   21708:	1a9f      	subs	r7, r3, r2
   if (N==2)
   2170a:	f1ba 0f02 	cmp.w	sl, #2
   2170e:	6a22      	ldr	r2, [r4, #32]
   21710:	f000 82da 	beq.w	21cc8 <quant_band_stereo+0x90c>
      *fill &= (1<<B)-1;
   21714:	991b      	ldr	r1, [sp, #108]	; 0x6c
   21716:	2301      	movs	r3, #1
   21718:	408b      	lsls	r3, r1
   2171a:	9920      	ldr	r1, [sp, #128]	; 0x80
   2171c:	3b01      	subs	r3, #1
   2171e:	4019      	ands	r1, r3
      imid = 32767;
   21720:	f647 76ff 	movw	r6, #32767	; 0x7fff
   side = iside;
   21724:	f04f 0900 	mov.w	r9, #0
      *fill &= (1<<B)-1;
   21728:	9120      	str	r1, [sp, #128]	; 0x80
   2172a:	e9cd 960c 	strd	r9, r6, [sp, #48]	; 0x30
      delta = -16384;
   2172e:	4b08      	ldr	r3, [pc, #32]	; (21750 <quant_band_stereo+0x394>)
   21730:	e762      	b.n	215f8 <quant_band_stereo+0x23c>
   stereo = Y != NULL;
   21732:	1c15      	adds	r5, r2, #0
   21734:	bf18      	it	ne
   21736:	2501      	movne	r5, #1
   21738:	461a      	mov	r2, r3
   2173a:	bb23      	cbnz	r3, 21786 <quant_band_stereo+0x3ca>
   2173c:	460f      	mov	r7, r1
   2173e:	6a03      	ldr	r3, [r0, #32]
         x[0] = sign ? -NORM_SCALING : NORM_SCALING;
   21740:	4e03      	ldr	r6, [pc, #12]	; (21750 <quant_band_stereo+0x394>)
   21742:	4691      	mov	r9, r2
   21744:	e017      	b.n	21776 <quant_band_stereo+0x3ba>
   21746:	bf00      	nop
   21748:	0003780c 	.word	0x0003780c
   2174c:	00038e98 	.word	0x00038e98
   21750:	ffffc000 	.word	0xffffc000
            sign = ec_dec_bits(ec, 1);
   21754:	2101      	movs	r1, #1
   21756:	4640      	mov	r0, r8
   21758:	f008 f9ee 	bl	29b38 <ec_dec_bits>
         ctx->remaining_bits -= 1<<BITRES;
   2175c:	6a23      	ldr	r3, [r4, #32]
      if (ctx->resynth)
   2175e:	6862      	ldr	r2, [r4, #4]
         ctx->remaining_bits -= 1<<BITRES;
   21760:	3b08      	subs	r3, #8
   21762:	6223      	str	r3, [r4, #32]
      if (ctx->resynth)
   21764:	b112      	cbz	r2, 2176c <quant_band_stereo+0x3b0>
         x[0] = sign ? -NORM_SCALING : NORM_SCALING;
   21766:	b158      	cbz	r0, 21780 <quant_band_stereo+0x3c4>
   21768:	4632      	mov	r2, r6
   2176a:	803a      	strh	r2, [r7, #0]
   } while (++c<1+stereo);
   2176c:	454d      	cmp	r5, r9
   2176e:	465f      	mov	r7, fp
   21770:	dd4f      	ble.n	21812 <quant_band_stereo+0x456>
   21772:	f04f 0901 	mov.w	r9, #1
      if (ctx->remaining_bits>=1<<BITRES)
   21776:	2b07      	cmp	r3, #7
   21778:	dcec      	bgt.n	21754 <quant_band_stereo+0x398>
      if (ctx->resynth)
   2177a:	6862      	ldr	r2, [r4, #4]
   2177c:	2a00      	cmp	r2, #0
   2177e:	d0f5      	beq.n	2176c <quant_band_stereo+0x3b0>
         x[0] = sign ? -NORM_SCALING : NORM_SCALING;
   21780:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   21784:	e7f1      	b.n	2176a <quant_band_stereo+0x3ae>
   21786:	460e      	mov	r6, r1
   c=0; do {
   21788:	2700      	movs	r7, #0
   2178a:	6a03      	ldr	r3, [r0, #32]
         x[0] = sign ? -NORM_SCALING : NORM_SCALING;
   2178c:	f8df a3a4 	ldr.w	sl, [pc, #932]	; 21b34 <quant_band_stereo+0x778>
   21790:	e008      	b.n	217a4 <quant_band_stereo+0x3e8>
      if (ctx->resynth)
   21792:	6862      	ldr	r2, [r4, #4]
   21794:	b112      	cbz	r2, 2179c <quant_band_stereo+0x3e0>
         x[0] = sign ? -NORM_SCALING : NORM_SCALING;
   21796:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   2179a:	8032      	strh	r2, [r6, #0]
   } while (++c<1+stereo);
   2179c:	42bd      	cmp	r5, r7
   2179e:	465e      	mov	r6, fp
   217a0:	dd37      	ble.n	21812 <quant_band_stereo+0x456>
   217a2:	2701      	movs	r7, #1
      if (ctx->remaining_bits>=1<<BITRES)
   217a4:	2b07      	cmp	r3, #7
            ec_enc_bits(ec, sign, 1);
   217a6:	f04f 0201 	mov.w	r2, #1
   217aa:	4640      	mov	r0, r8
      if (ctx->remaining_bits>=1<<BITRES)
   217ac:	ddf1      	ble.n	21792 <quant_band_stereo+0x3d6>
            sign = x[0]<0;
   217ae:	f9b6 9000 	ldrsh.w	r9, [r6]
            ec_enc_bits(ec, sign, 1);
   217b2:	ea4f 71d9 	mov.w	r1, r9, lsr #31
   217b6:	f008 fc2d 	bl	2a014 <ec_enc_bits>
         ctx->remaining_bits -= 1<<BITRES;
   217ba:	6a23      	ldr	r3, [r4, #32]
      if (ctx->resynth)
   217bc:	6862      	ldr	r2, [r4, #4]
         ctx->remaining_bits -= 1<<BITRES;
   217be:	3b08      	subs	r3, #8
   217c0:	6223      	str	r3, [r4, #32]
      if (ctx->resynth)
   217c2:	2a00      	cmp	r2, #0
   217c4:	d0ea      	beq.n	2179c <quant_band_stereo+0x3e0>
         x[0] = sign ? -NORM_SCALING : NORM_SCALING;
   217c6:	f1b9 0f00 	cmp.w	r9, #0
   217ca:	dae4      	bge.n	21796 <quant_band_stereo+0x3da>
   217cc:	4652      	mov	r2, sl
   217ce:	e7e4      	b.n	2179a <quant_band_stereo+0x3de>
      if (*b>2<<BITRES && ctx->remaining_bits > 2<<BITRES)
   217d0:	6a23      	ldr	r3, [r4, #32]
   217d2:	2b10      	cmp	r3, #16
   217d4:	dd8b      	ble.n	216ee <quant_band_stereo+0x332>
         if (encode)
   217d6:	9b08      	ldr	r3, [sp, #32]
   217d8:	2b00      	cmp	r3, #0
   217da:	f000 8380 	beq.w	21ede <quant_band_stereo+0xb22>
            ec_enc_bit_logp(ec, inv, 2);
   217de:	2202      	movs	r2, #2
   217e0:	4629      	mov	r1, r5
   217e2:	4640      	mov	r0, r8
   217e4:	9508      	str	r5, [sp, #32]
   217e6:	f008 fadf 	bl	29da8 <ec_enc_bit_logp>
   217ea:	e782      	b.n	216f2 <quant_band_stereo+0x336>
      return -(opus_int32)celt_udiv(-n, d);
   217ec:	4276      	negs	r6, r6
   217ee:	2101      	movs	r1, #1
   217f0:	2700      	movs	r7, #0
   217f2:	4655      	mov	r5, sl
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   217f4:	48cd      	ldr	r0, [pc, #820]	; (21b2c <quant_band_stereo+0x770>)
   217f6:	f850 7027 	ldr.w	r7, [r0, r7, lsl #2]
   217fa:	fa26 f001 	lsr.w	r0, r6, r1
   217fe:	fba0 0107 	umull	r0, r1, r0, r7
      return q+(n-q*d >= d);
   21802:	fb05 6611 	mls	r6, r5, r1, r6
   21806:	42b5      	cmp	r5, r6
   21808:	bf8c      	ite	hi
   2180a:	460d      	movhi	r5, r1
   2180c:	1c4d      	addls	r5, r1, #1
      return -(opus_int32)celt_udiv(-n, d);
   2180e:	426d      	negs	r5, r5
   21810:	e609      	b.n	21426 <quant_band_stereo+0x6a>
   if (lowband_out)
   21812:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   21814:	2b00      	cmp	r3, #0
   21816:	f000 8306 	beq.w	21e26 <quant_band_stereo+0xa6a>
   2181a:	461a      	mov	r2, r3
      lowband_out[0] = SHR16(X[0],4);
   2181c:	9b09      	ldr	r3, [sp, #36]	; 0x24
   2181e:	f9b3 3000 	ldrsh.w	r3, [r3]
      return quant_band_n1(ctx, X, Y, b, lowband_out);
   21822:	f04f 0801 	mov.w	r8, #1
      lowband_out[0] = SHR16(X[0],4);
   21826:	111b      	asrs	r3, r3, #4
}
   21828:	4640      	mov	r0, r8
      lowband_out[0] = SHR16(X[0],4);
   2182a:	8013      	strh	r3, [r2, #0]
}
   2182c:	b011      	add	sp, #68	; 0x44
   2182e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   21832:	461a      	mov	r2, r3
         cm = quant_band(ctx, Y, N, sbits, B, NULL, LM, NULL, side, NULL, fill>>B);
   21834:	9206      	str	r2, [sp, #24]
   21836:	9a1d      	ldr	r2, [sp, #116]	; 0x74
   21838:	9202      	str	r2, [sp, #8]
   2183a:	2300      	movs	r3, #0
   2183c:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   2183e:	f8cd 9010 	str.w	r9, [sp, #16]
   21842:	9200      	str	r2, [sp, #0]
   21844:	9305      	str	r3, [sp, #20]
   21846:	9303      	str	r3, [sp, #12]
   21848:	9301      	str	r3, [sp, #4]
   2184a:	4652      	mov	r2, sl
   2184c:	4643      	mov	r3, r8
   2184e:	4659      	mov	r1, fp
   21850:	4620      	mov	r0, r4
   21852:	f7ff f927 	bl	20aa4 <quant_band>
   21856:	4681      	mov	r9, r0
         rebalance = sbits - (rebalance-ctx->remaining_bits);
   21858:	6a20      	ldr	r0, [r4, #32]
   2185a:	1a3f      	subs	r7, r7, r0
   2185c:	eba8 0807 	sub.w	r8, r8, r7
         if (rebalance > 3<<BITRES && itheta!=16384)
   21860:	f1b8 0f18 	cmp.w	r8, #24
   21864:	dd06      	ble.n	21874 <quant_band_stereo+0x4b8>
   21866:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   21868:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
            mbits += rebalance - (3<<BITRES);
   2186c:	bf1c      	itt	ne
   2186e:	f1a8 0818 	subne.w	r8, r8, #24
   21872:	4445      	addne	r5, r8
         cm |= quant_band(ctx, X, N, mbits, B, lowband, LM, lowband_out, Q15ONE,
   21874:	9b20      	ldr	r3, [sp, #128]	; 0x80
   21876:	9306      	str	r3, [sp, #24]
   21878:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   2187a:	9305      	str	r3, [sp, #20]
   2187c:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   2187e:	9303      	str	r3, [sp, #12]
   21880:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   21882:	9302      	str	r3, [sp, #8]
   21884:	9b1c      	ldr	r3, [sp, #112]	; 0x70
   21886:	9301      	str	r3, [sp, #4]
   21888:	f647 72ff 	movw	r2, #32767	; 0x7fff
   2188c:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
   2188e:	9300      	str	r3, [sp, #0]
   21890:	9204      	str	r2, [sp, #16]
   21892:	462b      	mov	r3, r5
   21894:	4652      	mov	r2, sl
   21896:	9909      	ldr	r1, [sp, #36]	; 0x24
   21898:	4620      	mov	r0, r4
   2189a:	f7ff f903 	bl	20aa4 <quant_band>
   if (ctx->resynth)
   2189e:	6863      	ldr	r3, [r4, #4]
         cm |= quant_band(ctx, X, N, mbits, B, lowband, LM, lowband_out, Q15ONE,
   218a0:	ea49 0800 	orr.w	r8, r9, r0
   if (ctx->resynth)
   218a4:	2b00      	cmp	r3, #0
   218a6:	f43f aef4 	beq.w	21692 <quant_band_stereo+0x2d6>
   for (i=0;i<N;i++)
   218aa:	f1ba 0f00 	cmp.w	sl, #0
   218ae:	f340 838f 	ble.w	21fd0 <quant_band_stereo+0xc14>
   218b2:	9b09      	ldr	r3, [sp, #36]	; 0x24
   218b4:	f1ab 0202 	sub.w	r2, fp, #2
   opus_val32 xy02=0;
   218b8:	2000      	movs	r0, #0
   218ba:	eb02 074a 	add.w	r7, r2, sl, lsl #1
   opus_val32 xy01=0;
   218be:	4601      	mov	r1, r0
   218c0:	1e9c      	subs	r4, r3, #2
      xy01 = MAC16_16(xy01, x[i], y01[i]);
   218c2:	f932 3f02 	ldrsh.w	r3, [r2, #2]!
   218c6:	f834 5f02 	ldrh.w	r5, [r4, #2]!
   for (i=0;i<N;i++)
   218ca:	4297      	cmp	r7, r2
      xy02 = MAC16_16(xy02, x[i], y02[i]);
   218cc:	fb03 0003 	mla	r0, r3, r3, r0
      xy01 = MAC16_16(xy01, x[i], y01[i]);
   218d0:	fb13 1105 	smlabb	r1, r3, r5, r1
   for (i=0;i<N;i++)
   218d4:	d1f5      	bne.n	218c2 <quant_band_stereo+0x506>
   218d6:	b28b      	uxth	r3, r1
   218d8:	fb06 f303 	mul.w	r3, r6, r3
   218dc:	1409      	asrs	r1, r1, #16
   218de:	13db      	asrs	r3, r3, #15
   218e0:	fb06 f101 	mul.w	r1, r6, r1
   218e4:	eb03 0141 	add.w	r1, r3, r1, lsl #1
   218e8:	0049      	lsls	r1, r1, #1
   mid2 = SHR16(mid, 1);
   218ea:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   if (Er < QCONST32(6e-4f, 28) || El < QCONST32(6e-4f, 28))
   218ec:	4a90      	ldr	r2, [pc, #576]	; (21b30 <quant_band_stereo+0x774>)
   mid2 = SHR16(mid, 1);
   218ee:	105b      	asrs	r3, r3, #1
   El = MULT16_16(mid2, mid2) + side - 2*xp;
   218f0:	fb03 0303 	mla	r3, r3, r3, r0
   Er = MULT16_16(mid2, mid2) + side + 2*xp;
   218f4:	185c      	adds	r4, r3, r1
   if (Er < QCONST32(6e-4f, 28) || El < QCONST32(6e-4f, 28))
   218f6:	4294      	cmp	r4, r2
   218f8:	dd03      	ble.n	21902 <quant_band_stereo+0x546>
   El = MULT16_16(mid2, mid2) + side - 2*xp;
   218fa:	1a5b      	subs	r3, r3, r1
   if (Er < QCONST32(6e-4f, 28) || El < QCONST32(6e-4f, 28))
   218fc:	4293      	cmp	r3, r2
   218fe:	f300 82f4 	bgt.w	21eea <quant_band_stereo+0xb2e>
      OPUS_COPY(Y, X, N);
   21902:	9909      	ldr	r1, [sp, #36]	; 0x24
   21904:	ea4f 024a 	mov.w	r2, sl, lsl #1
   21908:	4658      	mov	r0, fp
   2190a:	f7ea fbf9 	bl	c100 <memcpy>
      if (inv)
   2190e:	9b08      	ldr	r3, [sp, #32]
   21910:	2b00      	cmp	r3, #0
   21912:	f43f aebe 	beq.w	21692 <quant_band_stereo+0x2d6>
         for (j=0;j<N;j++)
   21916:	f1ba 0f00 	cmp.w	sl, #0
   2191a:	f77f aeba 	ble.w	21692 <quant_band_stereo+0x2d6>
   2191e:	ea4f 015b 	mov.w	r1, fp, lsr #1
   21922:	4249      	negs	r1, r1
   21924:	f1ba 0f00 	cmp.w	sl, #0
   21928:	f001 0103 	and.w	r1, r1, #3
   2192c:	f10a 33ff 	add.w	r3, sl, #4294967295	; 0xffffffff
   21930:	f101 0203 	add.w	r2, r1, #3
   21934:	bfd6      	itet	le
   21936:	2300      	movle	r3, #0
   21938:	4650      	movgt	r0, sl
   2193a:	2001      	movle	r0, #1
   2193c:	429a      	cmp	r2, r3
   2193e:	f200 834d 	bhi.w	21fdc <quant_band_stereo+0xc20>
   21942:	2900      	cmp	r1, #0
   21944:	f000 8272 	beq.w	21e2c <quant_band_stereo+0xa70>
            Y[j] = -Y[j];
   21948:	f8bb 3000 	ldrh.w	r3, [fp]
   2194c:	2901      	cmp	r1, #1
   2194e:	f1c3 0300 	rsb	r3, r3, #0
   21952:	f8ab 3000 	strh.w	r3, [fp]
   21956:	f000 8269 	beq.w	21e2c <quant_band_stereo+0xa70>
   2195a:	f8bb 3002 	ldrh.w	r3, [fp, #2]
   2195e:	2903      	cmp	r1, #3
   21960:	f1c3 0300 	rsb	r3, r3, #0
   21964:	f8ab 3002 	strh.w	r3, [fp, #2]
   21968:	f040 8335 	bne.w	21fd6 <quant_band_stereo+0xc1a>
   2196c:	f8bb 3004 	ldrh.w	r3, [fp, #4]
   21970:	425b      	negs	r3, r3
   21972:	f8ab 3004 	strh.w	r3, [fp, #4]
         for (j=0;j<N;j++)
   21976:	468e      	mov	lr, r1
   21978:	1a43      	subs	r3, r0, r1
   2197a:	eb0b 0141 	add.w	r1, fp, r1, lsl #1
   2197e:	9308      	str	r3, [sp, #32]
   21980:	ea4f 0993 	mov.w	r9, r3, lsr #2
   21984:	f1a1 0608 	sub.w	r6, r1, #8
   21988:	2500      	movs	r5, #0
            Y[j] = -Y[j];
   2198a:	f856 3f08 	ldr.w	r3, [r6, #8]!
   2198e:	6872      	ldr	r2, [r6, #4]
   21990:	2000      	movs	r0, #0
   21992:	f1c2 0c00 	rsb	ip, r2, #0
   21996:	4604      	mov	r4, r0
   21998:	425f      	negs	r7, r3
   2199a:	f3c2 420f 	ubfx	r2, r2, #16, #16
   2199e:	f3c3 430f 	ubfx	r3, r3, #16, #16
   219a2:	4252      	negs	r2, r2
   219a4:	f36c 040f 	bfi	r4, ip, #0, #16
   219a8:	f367 000f 	bfi	r0, r7, #0, #16
   219ac:	425b      	negs	r3, r3
   219ae:	3501      	adds	r5, #1
   219b0:	f362 441f 	bfi	r4, r2, #16, #16
   219b4:	f363 401f 	bfi	r0, r3, #16, #16
   219b8:	45a9      	cmp	r9, r5
   219ba:	e9c1 0400 	strd	r0, r4, [r1]
   219be:	f101 0108 	add.w	r1, r1, #8
   219c2:	d8e2      	bhi.n	2198a <quant_band_stereo+0x5ce>
   219c4:	9a08      	ldr	r2, [sp, #32]
   219c6:	f022 0303 	bic.w	r3, r2, #3
   219ca:	4293      	cmp	r3, r2
   219cc:	449e      	add	lr, r3
   219ce:	f43f ae60 	beq.w	21692 <quant_band_stereo+0x2d6>
   219d2:	f83b 301e 	ldrh.w	r3, [fp, lr, lsl #1]
         for (j=0;j<N;j++)
   219d6:	f10e 0201 	add.w	r2, lr, #1
            Y[j] = -Y[j];
   219da:	425b      	negs	r3, r3
         for (j=0;j<N;j++)
   219dc:	4552      	cmp	r2, sl
            Y[j] = -Y[j];
   219de:	f82b 301e 	strh.w	r3, [fp, lr, lsl #1]
   219e2:	ea4f 034e 	mov.w	r3, lr, lsl #1
         for (j=0;j<N;j++)
   219e6:	f6bf ae54 	bge.w	21692 <quant_band_stereo+0x2d6>
            Y[j] = -Y[j];
   219ea:	1c9a      	adds	r2, r3, #2
         for (j=0;j<N;j++)
   219ec:	f10e 0102 	add.w	r1, lr, #2
            Y[j] = -Y[j];
   219f0:	f83b 0002 	ldrh.w	r0, [fp, r2]
         for (j=0;j<N;j++)
   219f4:	458a      	cmp	sl, r1
            Y[j] = -Y[j];
   219f6:	f1c0 0000 	rsb	r0, r0, #0
   219fa:	f82b 0002 	strh.w	r0, [fp, r2]
         for (j=0;j<N;j++)
   219fe:	f77f ae48 	ble.w	21692 <quant_band_stereo+0x2d6>
            Y[j] = -Y[j];
   21a02:	1d1a      	adds	r2, r3, #4
         for (j=0;j<N;j++)
   21a04:	f10e 0103 	add.w	r1, lr, #3
            Y[j] = -Y[j];
   21a08:	f83b 0002 	ldrh.w	r0, [fp, r2]
         for (j=0;j<N;j++)
   21a0c:	458a      	cmp	sl, r1
            Y[j] = -Y[j];
   21a0e:	f1c0 0000 	rsb	r0, r0, #0
   21a12:	f82b 0002 	strh.w	r0, [fp, r2]
         for (j=0;j<N;j++)
   21a16:	f77f ae3c 	ble.w	21692 <quant_band_stereo+0x2d6>
            Y[j] = -Y[j];
   21a1a:	1d9a      	adds	r2, r3, #6
         for (j=0;j<N;j++)
   21a1c:	f10e 0104 	add.w	r1, lr, #4
            Y[j] = -Y[j];
   21a20:	f83b 0002 	ldrh.w	r0, [fp, r2]
         for (j=0;j<N;j++)
   21a24:	458a      	cmp	sl, r1
            Y[j] = -Y[j];
   21a26:	f1c0 0000 	rsb	r0, r0, #0
   21a2a:	f82b 0002 	strh.w	r0, [fp, r2]
         for (j=0;j<N;j++)
   21a2e:	f77f ae30 	ble.w	21692 <quant_band_stereo+0x2d6>
            Y[j] = -Y[j];
   21a32:	f103 0208 	add.w	r2, r3, #8
         for (j=0;j<N;j++)
   21a36:	f10e 0e05 	add.w	lr, lr, #5
            Y[j] = -Y[j];
   21a3a:	f83b 1002 	ldrh.w	r1, [fp, r2]
         for (j=0;j<N;j++)
   21a3e:	45f2      	cmp	sl, lr
            Y[j] = -Y[j];
   21a40:	f1c1 0100 	rsb	r1, r1, #0
   21a44:	f82b 1002 	strh.w	r1, [fp, r2]
         for (j=0;j<N;j++)
   21a48:	f77f ae23 	ble.w	21692 <quant_band_stereo+0x2d6>
            Y[j] = -Y[j];
   21a4c:	330a      	adds	r3, #10
   21a4e:	f83b 2003 	ldrh.w	r2, [fp, r3]
   21a52:	4252      	negs	r2, r2
   21a54:	f82b 2003 	strh.w	r2, [fp, r3]
   21a58:	e61b      	b.n	21692 <quant_band_stereo+0x2d6>
   qalloc = ec_tell_frac(ec) - tell;
   21a5a:	4640      	mov	r0, r8
   21a5c:	f007 fe66 	bl	2972c <ec_tell_frac>
   21a60:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   21a62:	1ac3      	subs	r3, r0, r3
   21a64:	930a      	str	r3, [sp, #40]	; 0x28
   *b -= qalloc;
   21a66:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   21a68:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   21a6a:	1a9f      	subs	r7, r3, r2
   if (itheta == 0)
   21a6c:	2d00      	cmp	r5, #0
   21a6e:	f43f ae4c 	beq.w	2170a <quant_band_stereo+0x34e>
   } else if (itheta == 16384)
   21a72:	f5b5 4f80 	cmp.w	r5, #16384	; 0x4000
   21a76:	f47f ad3f 	bne.w	214f8 <quant_band_stereo+0x13c>
      *fill &= ((1<<B)-1)<<B;
   21a7a:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
   21a7c:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   21a7e:	2101      	movs	r1, #1
   21a80:	fa01 f303 	lsl.w	r3, r1, r3
   21a84:	3b01      	subs	r3, #1
   21a86:	4093      	lsls	r3, r2
   21a88:	9a20      	ldr	r2, [sp, #128]	; 0x80
   if (N==2)
   21a8a:	f1ba 0f02 	cmp.w	sl, #2
      *fill &= ((1<<B)-1)<<B;
   21a8e:	ea03 0302 	and.w	r3, r3, r2
   21a92:	6a22      	ldr	r2, [r4, #32]
   if (N==2)
   21a94:	f000 827c 	beq.w	21f90 <quant_band_stereo+0xbd4>
      imid = 0;
   21a98:	2100      	movs	r1, #0
      *fill &= ((1<<B)-1)<<B;
   21a9a:	9320      	str	r3, [sp, #128]	; 0x80
      imid = 0;
   21a9c:	9108      	str	r1, [sp, #32]
      delta = 16384;
   21a9e:	462b      	mov	r3, r5
   if (N==2)
   21aa0:	460e      	mov	r6, r1
   21aa2:	910d      	str	r1, [sp, #52]	; 0x34
   21aa4:	f647 79ff 	movw	r9, #32767	; 0x7fff
   21aa8:	e5a6      	b.n	215f8 <quant_band_stereo+0x23c>
      t = EC_ILOG(d&-d);
   21aaa:	426a      	negs	r2, r5
   21aac:	402a      	ands	r2, r5
   21aae:	fab2 f282 	clz	r2, r2
   21ab2:	f1c2 0220 	rsb	r2, r2, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   21ab6:	fa25 f102 	lsr.w	r1, r5, r2
   21aba:	4b1c      	ldr	r3, [pc, #112]	; (21b2c <quant_band_stereo+0x770>)
   21abc:	3a01      	subs	r2, #1
   21abe:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   21ac2:	fa26 f202 	lsr.w	r2, r6, r2
   21ac6:	fba2 2303 	umull	r2, r3, r2, r3
      return q+(n-q*d >= d);
   21aca:	fb05 6613 	mls	r6, r5, r3, r6
   21ace:	42b5      	cmp	r5, r6
   21ad0:	bf8c      	ite	hi
   21ad2:	461d      	movhi	r5, r3
   21ad4:	1c5d      	addls	r5, r3, #1
   21ad6:	e4de      	b.n	21496 <quant_band_stereo+0xda>
      itheta = stereo_itheta(X, Y, stereo, N, ctx->arch);
   21ad8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   21ada:	9300      	str	r3, [sp, #0]
   21adc:	2201      	movs	r2, #1
   21ade:	4653      	mov	r3, sl
   21ae0:	4659      	mov	r1, fp
   21ae2:	9809      	ldr	r0, [sp, #36]	; 0x24
   21ae4:	f00d f986 	bl	2edf4 <stereo_itheta>
   21ae8:	4606      	mov	r6, r0
   tell = ec_tell_frac(ec);
   21aea:	4640      	mov	r0, r8
   21aec:	f007 fe1e 	bl	2972c <ec_tell_frac>
         if (!stereo || ctx->theta_round == 0)
   21af0:	6b22      	ldr	r2, [r4, #48]	; 0x30
   tell = ec_tell_frac(ec);
   21af2:	900b      	str	r0, [sp, #44]	; 0x2c
   21af4:	fb05 f306 	mul.w	r3, r5, r6
         if (!stereo || ctx->theta_round == 0)
   21af8:	2a00      	cmp	r2, #0
   21afa:	f040 8151 	bne.w	21da0 <quant_band_stereo+0x9e4>
            itheta = (itheta*(opus_int32)qn+8192)>>14;
   21afe:	f503 5600 	add.w	r6, r3, #8192	; 0x2000
   21b02:	13b6      	asrs	r6, r6, #14
      if (stereo && N>2)
   21b04:	f1ba 0f02 	cmp.w	sl, #2
   21b08:	f340 8143 	ble.w	21d92 <quant_band_stereo+0x9d6>
         int x0 = qn/2;
   21b0c:	107f      	asrs	r7, r7, #1
         int ft = p0*(x0+1) + x0;
   21b0e:	1c7a      	adds	r2, r7, #1
   21b10:	eb02 0242 	add.w	r2, r2, r2, lsl #1
            ec_encode(ec,x<=x0?p0*x:(x-1-x0)+(x0+1)*p0,x<=x0?p0*(x+1):(x-x0)+(x0+1)*p0,ft);
   21b14:	42b7      	cmp	r7, r6
         int ft = p0*(x0+1) + x0;
   21b16:	eb07 0302 	add.w	r3, r7, r2
            ec_encode(ec,x<=x0?p0*x:(x-1-x0)+(x0+1)*p0,x<=x0?p0*(x+1):(x-x0)+(x0+1)*p0,ft);
   21b1a:	f2c0 8189 	blt.w	21e30 <quant_band_stereo+0xa74>
   21b1e:	eb06 0146 	add.w	r1, r6, r6, lsl #1
   21b22:	1cca      	adds	r2, r1, #3
   21b24:	4640      	mov	r0, r8
   21b26:	f008 f841 	bl	29bac <ec_encode>
   21b2a:	e4ac      	b.n	21486 <quant_band_stereo+0xca>
   21b2c:	00038e98 	.word	0x00038e98
   21b30:	00027524 	.word	0x00027524
   21b34:	ffffc000 	.word	0xffffc000
      itheta = stereo_itheta(X, Y, stereo, N, ctx->arch);
   21b38:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   21b3a:	9300      	str	r3, [sp, #0]
   21b3c:	2201      	movs	r2, #1
   21b3e:	4653      	mov	r3, sl
   21b40:	4659      	mov	r1, fp
   21b42:	9809      	ldr	r0, [sp, #36]	; 0x24
   21b44:	f00d f956 	bl	2edf4 <stereo_itheta>
   21b48:	4605      	mov	r5, r0
   tell = ec_tell_frac(ec);
   21b4a:	4640      	mov	r0, r8
   21b4c:	f007 fdee 	bl	2972c <ec_tell_frac>
         inv = itheta > 8192 && !ctx->disable_inv;
   21b50:	f5b5 5f00 	cmp.w	r5, #8192	; 0x2000
   tell = ec_tell_frac(ec);
   21b54:	4606      	mov	r6, r0
         inv = itheta > 8192 && !ctx->disable_inv;
   21b56:	f340 81b5 	ble.w	21ec4 <quant_band_stereo+0xb08>
   21b5a:	6b63      	ldr	r3, [r4, #52]	; 0x34
   21b5c:	930b      	str	r3, [sp, #44]	; 0x2c
   21b5e:	2b00      	cmp	r3, #0
   21b60:	f040 81b0 	bne.w	21ec4 <quant_band_stereo+0xb08>
            for (j=0;j<N;j++)
   21b64:	f1ba 0f00 	cmp.w	sl, #0
   21b68:	f340 8093 	ble.w	21c92 <quant_band_stereo+0x8d6>
   21b6c:	ea4f 015b 	mov.w	r1, fp, lsr #1
   21b70:	4249      	negs	r1, r1
   21b72:	f001 0103 	and.w	r1, r1, #3
   21b76:	1cca      	adds	r2, r1, #3
   21b78:	f10a 33ff 	add.w	r3, sl, #4294967295	; 0xffffffff
   21b7c:	429a      	cmp	r2, r3
   21b7e:	f200 8237 	bhi.w	21ff0 <quant_band_stereo+0xc34>
   21b82:	b1b9      	cbz	r1, 21bb4 <quant_band_stereo+0x7f8>
               Y[j] = -Y[j];
   21b84:	f8bb 3000 	ldrh.w	r3, [fp]
   21b88:	2901      	cmp	r1, #1
   21b8a:	f1c3 0300 	rsb	r3, r3, #0
   21b8e:	f8ab 3000 	strh.w	r3, [fp]
   21b92:	f000 8228 	beq.w	21fe6 <quant_band_stereo+0xc2a>
   21b96:	f8bb 3002 	ldrh.w	r3, [fp, #2]
   21b9a:	2903      	cmp	r1, #3
   21b9c:	f1c3 0300 	rsb	r3, r3, #0
   21ba0:	f8ab 3002 	strh.w	r3, [fp, #2]
   21ba4:	f040 8221 	bne.w	21fea <quant_band_stereo+0xc2e>
   21ba8:	f8bb 3004 	ldrh.w	r3, [fp, #4]
            for (j=0;j<N;j++)
   21bac:	910b      	str	r1, [sp, #44]	; 0x2c
               Y[j] = -Y[j];
   21bae:	425b      	negs	r3, r3
   21bb0:	f8ab 3004 	strh.w	r3, [fp, #4]
   21bb4:	ebaa 0301 	sub.w	r3, sl, r1
   21bb8:	930c      	str	r3, [sp, #48]	; 0x30
   21bba:	eb0b 0141 	add.w	r1, fp, r1, lsl #1
   21bbe:	089b      	lsrs	r3, r3, #2
            for (j=0;j<N;j++)
   21bc0:	e9cd 840e 	strd	r8, r4, [sp, #56]	; 0x38
   21bc4:	f1a1 0708 	sub.w	r7, r1, #8
   21bc8:	f04f 0c00 	mov.w	ip, #0
   21bcc:	461c      	mov	r4, r3
               Y[j] = -Y[j];
   21bce:	f857 3f08 	ldr.w	r3, [r7, #8]!
   21bd2:	687a      	ldr	r2, [r7, #4]
   21bd4:	2000      	movs	r0, #0
   21bd6:	f1c2 0800 	rsb	r8, r2, #0
   21bda:	4605      	mov	r5, r0
   21bdc:	f1c3 0e00 	rsb	lr, r3, #0
   21be0:	f3c2 420f 	ubfx	r2, r2, #16, #16
   21be4:	f3c3 430f 	ubfx	r3, r3, #16, #16
   21be8:	4252      	negs	r2, r2
   21bea:	f368 050f 	bfi	r5, r8, #0, #16
   21bee:	f36e 000f 	bfi	r0, lr, #0, #16
   21bf2:	425b      	negs	r3, r3
   21bf4:	f10c 0c01 	add.w	ip, ip, #1
   21bf8:	f362 451f 	bfi	r5, r2, #16, #16
   21bfc:	f363 401f 	bfi	r0, r3, #16, #16
   21c00:	45a4      	cmp	ip, r4
   21c02:	e9c1 0500 	strd	r0, r5, [r1]
   21c06:	f101 0108 	add.w	r1, r1, #8
   21c0a:	d3e0      	bcc.n	21bce <quant_band_stereo+0x812>
   21c0c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   21c0e:	990b      	ldr	r1, [sp, #44]	; 0x2c
   21c10:	f022 0303 	bic.w	r3, r2, #3
   21c14:	4293      	cmp	r3, r2
   21c16:	e9dd 840e 	ldrd	r8, r4, [sp, #56]	; 0x38
   21c1a:	4419      	add	r1, r3
   21c1c:	d039      	beq.n	21c92 <quant_band_stereo+0x8d6>
   21c1e:	f83b 2011 	ldrh.w	r2, [fp, r1, lsl #1]
            for (j=0;j<N;j++)
   21c22:	1c4b      	adds	r3, r1, #1
               Y[j] = -Y[j];
   21c24:	4252      	negs	r2, r2
            for (j=0;j<N;j++)
   21c26:	459a      	cmp	sl, r3
               Y[j] = -Y[j];
   21c28:	f82b 2011 	strh.w	r2, [fp, r1, lsl #1]
   21c2c:	ea4f 0541 	mov.w	r5, r1, lsl #1
            for (j=0;j<N;j++)
   21c30:	dd2f      	ble.n	21c92 <quant_band_stereo+0x8d6>
               Y[j] = -Y[j];
   21c32:	1caa      	adds	r2, r5, #2
            for (j=0;j<N;j++)
   21c34:	1c59      	adds	r1, r3, #1
               Y[j] = -Y[j];
   21c36:	f83b 0002 	ldrh.w	r0, [fp, r2]
            for (j=0;j<N;j++)
   21c3a:	458a      	cmp	sl, r1
               Y[j] = -Y[j];
   21c3c:	f1c0 0000 	rsb	r0, r0, #0
   21c40:	f82b 0002 	strh.w	r0, [fp, r2]
            for (j=0;j<N;j++)
   21c44:	dd25      	ble.n	21c92 <quant_band_stereo+0x8d6>
               Y[j] = -Y[j];
   21c46:	1d2a      	adds	r2, r5, #4
            for (j=0;j<N;j++)
   21c48:	1c99      	adds	r1, r3, #2
               Y[j] = -Y[j];
   21c4a:	f83b 0002 	ldrh.w	r0, [fp, r2]
            for (j=0;j<N;j++)
   21c4e:	458a      	cmp	sl, r1
               Y[j] = -Y[j];
   21c50:	f1c0 0000 	rsb	r0, r0, #0
   21c54:	f82b 0002 	strh.w	r0, [fp, r2]
            for (j=0;j<N;j++)
   21c58:	dd1b      	ble.n	21c92 <quant_band_stereo+0x8d6>
               Y[j] = -Y[j];
   21c5a:	1daa      	adds	r2, r5, #6
            for (j=0;j<N;j++)
   21c5c:	1cd9      	adds	r1, r3, #3
               Y[j] = -Y[j];
   21c5e:	f83b 0002 	ldrh.w	r0, [fp, r2]
            for (j=0;j<N;j++)
   21c62:	458a      	cmp	sl, r1
               Y[j] = -Y[j];
   21c64:	f1c0 0000 	rsb	r0, r0, #0
   21c68:	f82b 0002 	strh.w	r0, [fp, r2]
            for (j=0;j<N;j++)
   21c6c:	dd11      	ble.n	21c92 <quant_band_stereo+0x8d6>
               Y[j] = -Y[j];
   21c6e:	f105 0208 	add.w	r2, r5, #8
            for (j=0;j<N;j++)
   21c72:	3304      	adds	r3, #4
               Y[j] = -Y[j];
   21c74:	f83b 1002 	ldrh.w	r1, [fp, r2]
            for (j=0;j<N;j++)
   21c78:	459a      	cmp	sl, r3
               Y[j] = -Y[j];
   21c7a:	f1c1 0100 	rsb	r1, r1, #0
   21c7e:	f82b 1002 	strh.w	r1, [fp, r2]
            for (j=0;j<N;j++)
   21c82:	dd06      	ble.n	21c92 <quant_band_stereo+0x8d6>
               Y[j] = -Y[j];
   21c84:	f105 020a 	add.w	r2, r5, #10
   21c88:	f83b 3002 	ldrh.w	r3, [fp, r2]
   21c8c:	425b      	negs	r3, r3
   21c8e:	f82b 3002 	strh.w	r3, [fp, r2]
         inv = itheta > 8192 && !ctx->disable_inv;
   21c92:	2501      	movs	r5, #1
   21c94:	e117      	b.n	21ec6 <quant_band_stereo+0xb0a>
   if (d>256)
   21c96:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
      return -(opus_int32)celt_udiv(-n, d);
   21c9a:	f1c0 0600 	rsb	r6, r0, #0
   if (d>256)
   21c9e:	f240 8187 	bls.w	21fb0 <quant_band_stereo+0xbf4>
      return n/d;
   21ca2:	fbb6 f5f1 	udiv	r5, r6, r1
   21ca6:	e5b2      	b.n	2180e <quant_band_stereo+0x452>
   qalloc = ec_tell_frac(ec) - tell;
   21ca8:	f007 fd40 	bl	2972c <ec_tell_frac>
   21cac:	1b83      	subs	r3, r0, r6
   21cae:	930a      	str	r3, [sp, #40]	; 0x28
   *b -= qalloc;
   21cb0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   21cb2:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   if (N==2)
   21cb4:	f1ba 0f02 	cmp.w	sl, #2
   *b -= qalloc;
   21cb8:	eba3 0702 	sub.w	r7, r3, r2
         inv = 0;
   21cbc:	f04f 0300 	mov.w	r3, #0
   21cc0:	9308      	str	r3, [sp, #32]
   21cc2:	6a22      	ldr	r2, [r4, #32]
   if (N==2)
   21cc4:	f47f ad26 	bne.w	21714 <quant_band_stereo+0x358>
      iside = 0;
   21cc8:	2300      	movs	r3, #0
   21cca:	930b      	str	r3, [sp, #44]	; 0x2c
      imid = 32767;
   21ccc:	f647 76ff 	movw	r6, #32767	; 0x7fff
      ctx->remaining_bits -= qalloc+sbits;
   21cd0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   21cd2:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
   21cd6:	f8cd b028 	str.w	fp, [sp, #40]	; 0x28
   21cda:	1ad0      	subs	r0, r2, r3
   21cdc:	f64f 73ff 	movw	r3, #65535	; 0xffff
   21ce0:	6220      	str	r0, [r4, #32]
   21ce2:	2501      	movs	r5, #1
   21ce4:	930c      	str	r3, [sp, #48]	; 0x30
      cm = quant_band(ctx, x2, N, mbits, B, lowband, LM, lowband_out, Q15ONE,
   21ce6:	9b20      	ldr	r3, [sp, #128]	; 0x80
   21ce8:	9306      	str	r3, [sp, #24]
   21cea:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   21cec:	9305      	str	r3, [sp, #20]
   21cee:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   21cf0:	9303      	str	r3, [sp, #12]
   21cf2:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   21cf4:	9302      	str	r3, [sp, #8]
   21cf6:	9b1c      	ldr	r3, [sp, #112]	; 0x70
   21cf8:	9301      	str	r3, [sp, #4]
   21cfa:	f647 72ff 	movw	r2, #32767	; 0x7fff
   21cfe:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
   21d00:	9300      	str	r3, [sp, #0]
   21d02:	9204      	str	r2, [sp, #16]
   21d04:	463b      	mov	r3, r7
   21d06:	2202      	movs	r2, #2
   21d08:	4649      	mov	r1, r9
   21d0a:	4620      	mov	r0, r4
   21d0c:	f7fe feca 	bl	20aa4 <quant_band>
      y2[0] = -sign*x2[1];
   21d10:	f8b9 3002 	ldrh.w	r3, [r9, #2]
   21d14:	990c      	ldr	r1, [sp, #48]	; 0x30
      if (ctx->resynth)
   21d16:	6862      	ldr	r2, [r4, #4]
      y2[0] = -sign*x2[1];
   21d18:	fb13 f301 	smulbb	r3, r3, r1
   21d1c:	990a      	ldr	r1, [sp, #40]	; 0x28
   21d1e:	800b      	strh	r3, [r1, #0]
      y2[1] = sign*x2[0];
   21d20:	f8b9 3000 	ldrh.w	r3, [r9]
   21d24:	fb13 f505 	smulbb	r5, r3, r5
      cm = quant_band(ctx, x2, N, mbits, B, lowband, LM, lowband_out, Q15ONE,
   21d28:	4680      	mov	r8, r0
      y2[1] = sign*x2[0];
   21d2a:	804d      	strh	r5, [r1, #2]
      if (ctx->resynth)
   21d2c:	2a00      	cmp	r2, #0
   21d2e:	f43f acb0 	beq.w	21692 <quant_band_stereo+0x2d6>
         X[0] = MULT16_16_Q15(mid, X[0]);
   21d32:	9909      	ldr	r1, [sp, #36]	; 0x24
         Y[0] = MULT16_16_Q15(side, Y[0]);
   21d34:	980b      	ldr	r0, [sp, #44]	; 0x2c
         X[0] = MULT16_16_Q15(mid, X[0]);
   21d36:	f9b1 2000 	ldrsh.w	r2, [r1]
         X[1] = MULT16_16_Q15(mid, X[1]);
   21d3a:	f9b1 3002 	ldrsh.w	r3, [r1, #2]
         X[0] = MULT16_16_Q15(mid, X[0]);
   21d3e:	fb06 f202 	mul.w	r2, r6, r2
         X[1] = MULT16_16_Q15(mid, X[1]);
   21d42:	fb06 f603 	mul.w	r6, r6, r3
   21d46:	13f6      	asrs	r6, r6, #15
         X[0] = MULT16_16_Q15(mid, X[0]);
   21d48:	13d3      	asrs	r3, r2, #15
   21d4a:	800b      	strh	r3, [r1, #0]
         X[1] = MULT16_16_Q15(mid, X[1]);
   21d4c:	804e      	strh	r6, [r1, #2]
         Y[1] = MULT16_16_Q15(side, Y[1]);
   21d4e:	f9bb 2002 	ldrsh.w	r2, [fp, #2]
         Y[0] = MULT16_16_Q15(side, Y[0]);
   21d52:	f9bb 3000 	ldrsh.w	r3, [fp]
         Y[1] = MULT16_16_Q15(side, Y[1]);
   21d56:	fb00 f702 	mul.w	r7, r0, r2
         Y[0] = MULT16_16_Q15(side, Y[0]);
   21d5a:	fb00 f303 	mul.w	r3, r0, r3
   21d5e:	13db      	asrs	r3, r3, #15
         Y[1] = MULT16_16_Q15(side, Y[1]);
   21d60:	13ff      	asrs	r7, r7, #15
         Y[0] = MULT16_16_Q15(side, Y[0]);
   21d62:	f8ab 3000 	strh.w	r3, [fp]
         Y[1] = MULT16_16_Q15(side, Y[1]);
   21d66:	f8ab 7002 	strh.w	r7, [fp, #2]
         X[0] = SUB16(tmp,Y[0]);
   21d6a:	880a      	ldrh	r2, [r1, #0]
   21d6c:	1ad3      	subs	r3, r2, r3
   21d6e:	800b      	strh	r3, [r1, #0]
         Y[0] = ADD16(tmp,Y[0]);
   21d70:	f8bb 3000 	ldrh.w	r3, [fp]
         X[0] = SUB16(tmp,Y[0]);
   21d74:	4608      	mov	r0, r1
         Y[0] = ADD16(tmp,Y[0]);
   21d76:	441a      	add	r2, r3
   21d78:	f8ab 2000 	strh.w	r2, [fp]
         X[1] = SUB16(tmp,Y[1]);
   21d7c:	8843      	ldrh	r3, [r0, #2]
   21d7e:	f8bb 1002 	ldrh.w	r1, [fp, #2]
   21d82:	1a5a      	subs	r2, r3, r1
   21d84:	8042      	strh	r2, [r0, #2]
         Y[1] = ADD16(tmp,Y[1]);
   21d86:	f8bb 2002 	ldrh.w	r2, [fp, #2]
   21d8a:	4413      	add	r3, r2
   21d8c:	f8ab 3002 	strh.w	r3, [fp, #2]
   21d90:	e5bd      	b.n	2190e <quant_band_stereo+0x552>
            ec_enc_uint(ec, itheta, qn+1);
   21d92:	1c6a      	adds	r2, r5, #1
   21d94:	4631      	mov	r1, r6
   21d96:	4640      	mov	r0, r8
   21d98:	f008 f8e4 	bl	29f64 <ec_enc_uint>
   21d9c:	f7ff bb73 	b.w	21486 <quant_band_stereo+0xca>
            int bias = itheta > 8192 ? 32767/qn : -32767/qn;
   21da0:	f5b6 5f00 	cmp.w	r6, #8192	; 0x2000
   21da4:	bfcc      	ite	gt
   21da6:	f647 76ff 	movwgt	r6, #32767	; 0x7fff
   21daa:	4e98      	ldrle	r6, [pc, #608]	; (2200c <quant_band_stereo+0xc50>)
   21dac:	fb96 f6f5 	sdiv	r6, r6, r5
            down = IMIN(qn-1, IMAX(0, (itheta*(opus_int32)qn + bias)>>14));
   21db0:	441e      	add	r6, r3
   21db2:	13b6      	asrs	r6, r6, #14
   21db4:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
   21db8:	42ae      	cmp	r6, r5
   21dba:	bfa8      	it	ge
   21dbc:	f105 36ff 	addge.w	r6, r5, #4294967295	; 0xffffffff
            if (ctx->theta_round < 0)
   21dc0:	2a00      	cmp	r2, #0
               itheta = down+1;
   21dc2:	bfa8      	it	ge
   21dc4:	3601      	addge	r6, #1
   21dc6:	e69d      	b.n	21b04 <quant_band_stereo+0x748>
      if (itheta != 0 && itheta != 16384)
   21dc8:	2d00      	cmp	r5, #0
   21dca:	f000 810a 	beq.w	21fe2 <quant_band_stereo+0xc26>
      ctx->remaining_bits -= qalloc+sbits;
   21dce:	980a      	ldr	r0, [sp, #40]	; 0x28
   21dd0:	3008      	adds	r0, #8
   21dd2:	1a10      	subs	r0, r2, r0
      x2 = c ? Y : X;
   21dd4:	f5b5 5f00 	cmp.w	r5, #8192	; 0x2000
      ctx->remaining_bits -= qalloc+sbits;
   21dd8:	6220      	str	r0, [r4, #32]
      mbits -= sbits;
   21dda:	f1a7 0708 	sub.w	r7, r7, #8
      x2 = c ? Y : X;
   21dde:	f340 810f 	ble.w	22000 <quant_band_stereo+0xc44>
   21de2:	9b09      	ldr	r3, [sp, #36]	; 0x24
   21de4:	930a      	str	r3, [sp, #40]	; 0x28
   21de6:	46d9      	mov	r9, fp
         if (encode)
   21de8:	9b08      	ldr	r3, [sp, #32]
   21dea:	2b00      	cmp	r3, #0
   21dec:	d058      	beq.n	21ea0 <quant_band_stereo+0xae4>
            sign = x2[0]*y2[1] - x2[1]*y2[0] < 0;
   21dee:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   21df0:	f8b9 5000 	ldrh.w	r5, [r9]
   21df4:	8851      	ldrh	r1, [r2, #2]
   21df6:	f8b9 3002 	ldrh.w	r3, [r9, #2]
   21dfa:	8812      	ldrh	r2, [r2, #0]
   21dfc:	fb15 f501 	smulbb	r5, r5, r1
   21e00:	fb13 f302 	smulbb	r3, r3, r2
   21e04:	1aed      	subs	r5, r5, r3
   21e06:	0fed      	lsrs	r5, r5, #31
            ec_enc_bits(ec, sign, 1);
   21e08:	4629      	mov	r1, r5
   21e0a:	006d      	lsls	r5, r5, #1
   21e0c:	f1c5 0501 	rsb	r5, r5, #1
   21e10:	4640      	mov	r0, r8
   21e12:	2201      	movs	r2, #1
   21e14:	f008 f8fe 	bl	2a014 <ec_enc_bits>
   21e18:	426b      	negs	r3, r5
   21e1a:	b29b      	uxth	r3, r3
   21e1c:	930c      	str	r3, [sp, #48]	; 0x30
   21e1e:	2300      	movs	r3, #0
   21e20:	b2ad      	uxth	r5, r5
   21e22:	9308      	str	r3, [sp, #32]
   21e24:	e75f      	b.n	21ce6 <quant_band_stereo+0x92a>
      return quant_band_n1(ctx, X, Y, b, lowband_out);
   21e26:	f04f 0801 	mov.w	r8, #1
   21e2a:	e432      	b.n	21692 <quant_band_stereo+0x2d6>
         for (j=0;j<N;j++)
   21e2c:	468e      	mov	lr, r1
   21e2e:	e5a3      	b.n	21978 <quant_band_stereo+0x5bc>
            ec_encode(ec,x<=x0?p0*x:(x-1-x0)+(x0+1)*p0,x<=x0?p0*(x+1):(x-x0)+(x0+1)*p0,ft);
   21e30:	1e71      	subs	r1, r6, #1
   21e32:	1bc9      	subs	r1, r1, r7
   21e34:	1bf7      	subs	r7, r6, r7
   21e36:	4411      	add	r1, r2
   21e38:	443a      	add	r2, r7
   21e3a:	e673      	b.n	21b24 <quant_band_stereo+0x768>
            intensity_stereo(m, X, Y, bandE, i, N);
   21e3c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   21e3e:	f8d9 0008 	ldr.w	r0, [r9, #8]
   21e42:	9909      	ldr	r1, [sp, #36]	; 0x24
   21e44:	9300      	str	r3, [sp, #0]
   21e46:	465a      	mov	r2, fp
   21e48:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   21e4a:	f8cd a004 	str.w	sl, [sp, #4]
   21e4e:	f7fe f96f 	bl	20130 <intensity_stereo.isra.2>
   qalloc = ec_tell_frac(ec) - tell;
   21e52:	4640      	mov	r0, r8
   21e54:	f007 fc6a 	bl	2972c <ec_tell_frac>
   21e58:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   int inv=0;
   21e5a:	9508      	str	r5, [sp, #32]
   qalloc = ec_tell_frac(ec) - tell;
   21e5c:	1ac3      	subs	r3, r0, r3
   21e5e:	930a      	str	r3, [sp, #40]	; 0x28
   *b -= qalloc;
   21e60:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   21e62:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   21e64:	1a9f      	subs	r7, r3, r2
   21e66:	e450      	b.n	2170a <quant_band_stereo+0x34e>
         int x0 = qn/2;
   21e68:	107f      	asrs	r7, r7, #1
         int ft = p0*(x0+1) + x0;
   21e6a:	1c7e      	adds	r6, r7, #1
   21e6c:	eb06 0246 	add.w	r2, r6, r6, lsl #1
   21e70:	18bb      	adds	r3, r7, r2
            fs=ec_decode(ec,ft);
   21e72:	4619      	mov	r1, r3
   21e74:	4640      	mov	r0, r8
         int ft = p0*(x0+1) + x0;
   21e76:	920e      	str	r2, [sp, #56]	; 0x38
            fs=ec_decode(ec,ft);
   21e78:	930c      	str	r3, [sp, #48]	; 0x30
   21e7a:	f007 fc73 	bl	29764 <ec_decode>
            if (fs<(x0+1)*p0)
   21e7e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   21e80:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   21e82:	4282      	cmp	r2, r0
   21e84:	dc18      	bgt.n	21eb8 <quant_band_stereo+0xafc>
               x=x0+1+(fs-(x0+1)*p0);
   21e86:	1a80      	subs	r0, r0, r2
   21e88:	4406      	add	r6, r0
            ec_dec_update(ec,x<=x0?p0*x:(x-1-x0)+(x0+1)*p0,x<=x0?p0*(x+1):(x-x0)+(x0+1)*p0,ft);
   21e8a:	42b7      	cmp	r7, r6
   21e8c:	f2c0 809a 	blt.w	21fc4 <quant_band_stereo+0xc08>
   21e90:	eb06 0146 	add.w	r1, r6, r6, lsl #1
   21e94:	1cca      	adds	r2, r1, #3
   21e96:	4640      	mov	r0, r8
   21e98:	f007 fc92 	bl	297c0 <ec_dec_update>
   21e9c:	f7ff baf3 	b.w	21486 <quant_band_stereo+0xca>
            sign = ec_dec_bits(ec, 1);
   21ea0:	4640      	mov	r0, r8
   21ea2:	2101      	movs	r1, #1
   21ea4:	f007 fe48 	bl	29b38 <ec_dec_bits>
   21ea8:	0045      	lsls	r5, r0, #1
   21eaa:	f1c5 0501 	rsb	r5, r5, #1
   21eae:	426b      	negs	r3, r5
   21eb0:	b29b      	uxth	r3, r3
   21eb2:	930c      	str	r3, [sp, #48]	; 0x30
   21eb4:	b2ad      	uxth	r5, r5
   21eb6:	e716      	b.n	21ce6 <quant_band_stereo+0x92a>
               x=fs/p0;
   21eb8:	4e55      	ldr	r6, [pc, #340]	; (22010 <quant_band_stereo+0xc54>)
   21eba:	fb86 1600 	smull	r1, r6, r6, r0
   21ebe:	eba6 76e0 	sub.w	r6, r6, r0, asr #31
   21ec2:	e7e2      	b.n	21e8a <quant_band_stereo+0xace>
         inv = itheta > 8192 && !ctx->disable_inv;
   21ec4:	2500      	movs	r5, #0
         intensity_stereo(m, X, Y, bandE, i, N);
   21ec6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   21ec8:	f8d9 0008 	ldr.w	r0, [r9, #8]
   21ecc:	9909      	ldr	r1, [sp, #36]	; 0x24
   21ece:	9300      	str	r3, [sp, #0]
   21ed0:	f8cd a004 	str.w	sl, [sp, #4]
   21ed4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   21ed6:	465a      	mov	r2, fp
   21ed8:	f7fe f92a 	bl	20130 <intensity_stereo.isra.2>
   21edc:	e404      	b.n	216e8 <quant_band_stereo+0x32c>
            inv = ec_dec_bit_logp(ec, 2);
   21ede:	2102      	movs	r1, #2
   21ee0:	4640      	mov	r0, r8
   21ee2:	f007 fcbd 	bl	29860 <ec_dec_bit_logp>
   21ee6:	9008      	str	r0, [sp, #32]
   21ee8:	e403      	b.n	216f2 <quant_band_stereo+0x336>
   return EC_ILOG(x)-1;
   21eea:	fab3 fc83 	clz	ip, r3
   kl = celt_ilog2(El)>>1;
   21eee:	f1cc 0c1f 	rsb	ip, ip, #31
   21ef2:	ea4f 056c 	mov.w	r5, ip, asr #1
   t = VSHR32(El, (kl-7)<<1);
   21ef6:	1fe8      	subs	r0, r5, #7
   21ef8:	0040      	lsls	r0, r0, #1
   lgain = celt_rsqrt_norm(t);
   21efa:	fa43 f000 	asr.w	r0, r3, r0
   21efe:	f009 fa89 	bl	2b414 <celt_rsqrt_norm>
   21f02:	fab4 f784 	clz	r7, r4
   kr = celt_ilog2(Er)>>1;
   21f06:	f1c7 071f 	rsb	r7, r7, #31
   21f0a:	107f      	asrs	r7, r7, #1
   lgain = celt_rsqrt_norm(t);
   21f0c:	4681      	mov	r9, r0
   t = VSHR32(Er, (kr-7)<<1);
   21f0e:	1ff8      	subs	r0, r7, #7
   21f10:	0040      	lsls	r0, r0, #1
   rgain = celt_rsqrt_norm(t);
   21f12:	fa44 f000 	asr.w	r0, r4, r0
   21f16:	f009 fa7d 	bl	2b414 <celt_rsqrt_norm>
   for (j=0;j<N;j++)
   21f1a:	f1ba 0f00 	cmp.w	sl, #0
   21f1e:	f77f abb8 	ble.w	21692 <quant_band_stereo+0x2d6>
   21f22:	9b09      	ldr	r3, [sp, #36]	; 0x24
   21f24:	f8cd b028 	str.w	fp, [sp, #40]	; 0x28
      X[j] = EXTRACT16(PSHR32(MULT16_16(lgain, SUB16(l,r)), kl+1));
   21f28:	f105 0c01 	add.w	ip, r5, #1
   21f2c:	f04f 0e01 	mov.w	lr, #1
   21f30:	1e9c      	subs	r4, r3, #2
      Y[j] = EXTRACT16(PSHR32(MULT16_16(rgain, ADD16(l,r)), kr+1));
   21f32:	3701      	adds	r7, #1
      X[j] = EXTRACT16(PSHR32(MULT16_16(lgain, SUB16(l,r)), kl+1));
   21f34:	fa0e f30c 	lsl.w	r3, lr, ip
   21f38:	105b      	asrs	r3, r3, #1
      Y[j] = EXTRACT16(PSHR32(MULT16_16(rgain, ADD16(l,r)), kr+1));
   21f3a:	fa0e fe07 	lsl.w	lr, lr, r7
   21f3e:	eb04 024a 	add.w	r2, r4, sl, lsl #1
   21f42:	f1ab 0502 	sub.w	r5, fp, #2
   21f46:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
   21f4a:	ea4f 0e6e 	mov.w	lr, lr, asr #1
   21f4e:	4698      	mov	r8, r3
   21f50:	4693      	mov	fp, r2
      l = MULT16_16_P15(mid, X[j]);
   21f52:	f934 3f02 	ldrsh.w	r3, [r4, #2]!
      X[j] = EXTRACT16(PSHR32(MULT16_16(lgain, SUB16(l,r)), kl+1));
   21f56:	f835 1f02 	ldrh.w	r1, [r5, #2]!
      l = MULT16_16_P15(mid, X[j]);
   21f5a:	fb06 f303 	mul.w	r3, r6, r3
   21f5e:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
      X[j] = EXTRACT16(PSHR32(MULT16_16(lgain, SUB16(l,r)), kl+1));
   21f62:	f3c3 33cf 	ubfx	r3, r3, #15, #16
   21f66:	1a5a      	subs	r2, r3, r1
      Y[j] = EXTRACT16(PSHR32(MULT16_16(rgain, ADD16(l,r)), kr+1));
   21f68:	440b      	add	r3, r1
      X[j] = EXTRACT16(PSHR32(MULT16_16(lgain, SUB16(l,r)), kl+1));
   21f6a:	fb19 8202 	smlabb	r2, r9, r2, r8
      Y[j] = EXTRACT16(PSHR32(MULT16_16(rgain, ADD16(l,r)), kr+1));
   21f6e:	fb10 e303 	smlabb	r3, r0, r3, lr
      X[j] = EXTRACT16(PSHR32(MULT16_16(lgain, SUB16(l,r)), kl+1));
   21f72:	fa42 f20c 	asr.w	r2, r2, ip
      Y[j] = EXTRACT16(PSHR32(MULT16_16(rgain, ADD16(l,r)), kr+1));
   21f76:	413b      	asrs	r3, r7
   for (j=0;j<N;j++)
   21f78:	45a3      	cmp	fp, r4
      X[j] = EXTRACT16(PSHR32(MULT16_16(lgain, SUB16(l,r)), kl+1));
   21f7a:	8022      	strh	r2, [r4, #0]
      Y[j] = EXTRACT16(PSHR32(MULT16_16(rgain, ADD16(l,r)), kr+1));
   21f7c:	802b      	strh	r3, [r5, #0]
   for (j=0;j<N;j++)
   21f7e:	d1e8      	bne.n	21f52 <quant_band_stereo+0xb96>
      if (inv)
   21f80:	9b08      	ldr	r3, [sp, #32]
   21f82:	e9dd 8b09 	ldrd	r8, fp, [sp, #36]	; 0x24
   21f86:	2b00      	cmp	r3, #0
   21f88:	f47f acc9 	bne.w	2191e <quant_band_stereo+0x562>
   21f8c:	f7ff bb81 	b.w	21692 <quant_band_stereo+0x2d6>
      ctx->remaining_bits -= qalloc+sbits;
   21f90:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   21f92:	1ad3      	subs	r3, r2, r3
   21f94:	6223      	str	r3, [r4, #32]
   21f96:	9b09      	ldr	r3, [sp, #36]	; 0x24
   21f98:	930a      	str	r3, [sp, #40]	; 0x28
   21f9a:	2600      	movs	r6, #0
   21f9c:	f647 73ff 	movw	r3, #32767	; 0x7fff
   21fa0:	f64f 72ff 	movw	r2, #65535	; 0xffff
   21fa4:	9608      	str	r6, [sp, #32]
   21fa6:	460d      	mov	r5, r1
   21fa8:	46d9      	mov	r9, fp
   21faa:	e9cd 320b 	strd	r3, r2, [sp, #44]	; 0x2c
   21fae:	e69a      	b.n	21ce6 <quant_band_stereo+0x92a>
   21fb0:	4249      	negs	r1, r1
   21fb2:	4029      	ands	r1, r5
   21fb4:	fab1 f181 	clz	r1, r1
   21fb8:	f1c1 0120 	rsb	r1, r1, #32
   21fbc:	fa25 f701 	lsr.w	r7, r5, r1
   21fc0:	3901      	subs	r1, #1
   21fc2:	e417      	b.n	217f4 <quant_band_stereo+0x438>
            ec_dec_update(ec,x<=x0?p0*x:(x-1-x0)+(x0+1)*p0,x<=x0?p0*(x+1):(x-x0)+(x0+1)*p0,ft);
   21fc4:	1e71      	subs	r1, r6, #1
   21fc6:	1bc9      	subs	r1, r1, r7
   21fc8:	1bf7      	subs	r7, r6, r7
   21fca:	4411      	add	r1, r2
   21fcc:	443a      	add	r2, r7
   21fce:	e762      	b.n	21e96 <quant_band_stereo+0xada>
   21fd0:	2100      	movs	r1, #0
   opus_val32 xy02=0;
   21fd2:	4608      	mov	r0, r1
   21fd4:	e489      	b.n	218ea <quant_band_stereo+0x52e>
         for (j=0;j<N;j++)
   21fd6:	f04f 0e02 	mov.w	lr, #2
   21fda:	e4cd      	b.n	21978 <quant_band_stereo+0x5bc>
   21fdc:	f04f 0e00 	mov.w	lr, #0
   21fe0:	e4f7      	b.n	219d2 <quant_band_stereo+0x616>
   21fe2:	9508      	str	r5, [sp, #32]
   21fe4:	e674      	b.n	21cd0 <quant_band_stereo+0x914>
            for (j=0;j<N;j++)
   21fe6:	910b      	str	r1, [sp, #44]	; 0x2c
   21fe8:	e5e4      	b.n	21bb4 <quant_band_stereo+0x7f8>
   21fea:	2302      	movs	r3, #2
   21fec:	930b      	str	r3, [sp, #44]	; 0x2c
   21fee:	e5e1      	b.n	21bb4 <quant_band_stereo+0x7f8>
               Y[j] = -Y[j];
   21ff0:	f8bb 3000 	ldrh.w	r3, [fp]
   21ff4:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   21ff6:	425b      	negs	r3, r3
   21ff8:	f8ab 3000 	strh.w	r3, [fp]
            for (j=0;j<N;j++)
   21ffc:	2301      	movs	r3, #1
   21ffe:	e618      	b.n	21c32 <quant_band_stereo+0x876>
      x2 = c ? Y : X;
   22000:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
   22004:	f8cd b028 	str.w	fp, [sp, #40]	; 0x28
   22008:	e6ee      	b.n	21de8 <quant_band_stereo+0xa2c>
   2200a:	bf00      	nop
   2200c:	ffff8001 	.word	0xffff8001
   22010:	55555556 	.word	0x55555556

00022014 <hysteresis_decision>:
{
   22014:	b4f0      	push	{r4, r5, r6, r7}
   for (i=0;i<N;i++)
   22016:	2b00      	cmp	r3, #0
{
   22018:	9f04      	ldr	r7, [sp, #16]
   for (i=0;i<N;i++)
   2201a:	dd29      	ble.n	22070 <hysteresis_decision+0x5c>
      if (val < thresholds[i])
   2201c:	f9b1 4000 	ldrsh.w	r4, [r1]
   22020:	4284      	cmp	r4, r0
   22022:	dc25      	bgt.n	22070 <hysteresis_decision+0x5c>
   22024:	460d      	mov	r5, r1
   for (i=0;i<N;i++)
   22026:	2400      	movs	r4, #0
   22028:	e003      	b.n	22032 <hysteresis_decision+0x1e>
      if (val < thresholds[i])
   2202a:	f935 6f02 	ldrsh.w	r6, [r5, #2]!
   2202e:	4286      	cmp	r6, r0
   22030:	dc02      	bgt.n	22038 <hysteresis_decision+0x24>
   for (i=0;i<N;i++)
   22032:	3401      	adds	r4, #1
   22034:	42a3      	cmp	r3, r4
   22036:	d1f8      	bne.n	2202a <hysteresis_decision+0x16>
   if (i>prev && val < thresholds[prev]+hysteresis[prev])
   22038:	42a7      	cmp	r7, r4
   2203a:	da0a      	bge.n	22052 <hysteresis_decision+0x3e>
   2203c:	f931 3017 	ldrsh.w	r3, [r1, r7, lsl #1]
   22040:	f932 2017 	ldrsh.w	r2, [r2, r7, lsl #1]
   22044:	4413      	add	r3, r2
   22046:	4298      	cmp	r0, r3
   22048:	bfa8      	it	ge
   2204a:	4627      	movge	r7, r4
}
   2204c:	4638      	mov	r0, r7
   2204e:	bcf0      	pop	{r4, r5, r6, r7}
   22050:	4770      	bx	lr
   if (i<prev && val > thresholds[prev-1]-hysteresis[prev-1])
   22052:	dd0f      	ble.n	22074 <hysteresis_decision+0x60>
   22054:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
   22058:	3b01      	subs	r3, #1
   2205a:	f931 1013 	ldrsh.w	r1, [r1, r3, lsl #1]
   2205e:	f932 3013 	ldrsh.w	r3, [r2, r3, lsl #1]
   22062:	1acb      	subs	r3, r1, r3
   22064:	4298      	cmp	r0, r3
   22066:	bfd8      	it	le
   22068:	4627      	movle	r7, r4
}
   2206a:	4638      	mov	r0, r7
   2206c:	bcf0      	pop	{r4, r5, r6, r7}
   2206e:	4770      	bx	lr
   for (i=0;i<N;i++)
   22070:	2400      	movs	r4, #0
   22072:	e7e1      	b.n	22038 <hysteresis_decision+0x24>
   22074:	4627      	mov	r7, r4
   22076:	e7e9      	b.n	2204c <hysteresis_decision+0x38>

00022078 <compute_band_energies>:
{
   22078:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2207c:	b089      	sub	sp, #36	; 0x24
   N = m->shortMdctSize<<LM;
   2207e:	6a44      	ldr	r4, [r0, #36]	; 0x24
{
   22080:	9f13      	ldr	r7, [sp, #76]	; 0x4c
   const opus_int16 *eBands = m->eBands;
   22082:	6985      	ldr	r5, [r0, #24]
   22084:	9506      	str	r5, [sp, #24]
   N = m->shortMdctSize<<LM;
   22086:	40bc      	lsls	r4, r7
   22088:	2b00      	cmp	r3, #0
   2208a:	9407      	str	r4, [sp, #28]
   2208c:	dd6f      	ble.n	2216e <compute_band_energies+0xf6>
   2208e:	e9cd 2103 	strd	r2, r1, [sp, #12]
   22092:	eb05 0343 	add.w	r3, r5, r3, lsl #1
   22096:	2200      	movs	r2, #0
   22098:	4681      	mov	r9, r0
   2209a:	9201      	str	r2, [sp, #4]
   2209c:	9302      	str	r3, [sp, #8]
   c=0; do {
   2209e:	4692      	mov	sl, r2
         maxval = celt_maxabs32(&X[c*N+(eBands[i]<<LM)], (eBands[i+1]-eBands[i])<<LM);
   220a0:	f8dd 8018 	ldr.w	r8, [sp, #24]
      for (i=0;i<end;i++)
   220a4:	2600      	movs	r6, #0
         maxval = celt_maxabs32(&X[c*N+(eBands[i]<<LM)], (eBands[i+1]-eBands[i])<<LM);
   220a6:	f9b8 0000 	ldrsh.w	r0, [r8]
   220aa:	f938 cf02 	ldrsh.w	ip, [r8, #2]!
   220ae:	9b01      	ldr	r3, [sp, #4]
   220b0:	fa00 f507 	lsl.w	r5, r0, r7
   220b4:	ebac 0000 	sub.w	r0, ip, r0
   220b8:	40b8      	lsls	r0, r7
   220ba:	195c      	adds	r4, r3, r5
   for (i=0;i<len;i++)
   220bc:	2800      	cmp	r0, #0
   220be:	ea4f 0484 	mov.w	r4, r4, lsl #2
   220c2:	ea4f 0e46 	mov.w	lr, r6, lsl #1
   220c6:	dd55      	ble.n	22174 <compute_band_energies+0xfc>
   220c8:	9b04      	ldr	r3, [sp, #16]
   220ca:	441c      	add	r4, r3
   opus_val32 minval = 0;
   220cc:	2300      	movs	r3, #0
   220ce:	eb04 0080 	add.w	r0, r4, r0, lsl #2
   for (i=0;i<len;i++)
   220d2:	4622      	mov	r2, r4
   opus_val32 maxval = 0;
   220d4:	469b      	mov	fp, r3
      maxval = MAX32(maxval, x[i]);
   220d6:	f852 1b04 	ldr.w	r1, [r2], #4
   220da:	458b      	cmp	fp, r1
   220dc:	bfb8      	it	lt
   220de:	468b      	movlt	fp, r1
      minval = MIN32(minval, x[i]);
   220e0:	428b      	cmp	r3, r1
   220e2:	bfa8      	it	ge
   220e4:	460b      	movge	r3, r1
   for (i=0;i<len;i++)
   220e6:	4290      	cmp	r0, r2
   220e8:	d1f5      	bne.n	220d6 <compute_band_energies+0x5e>
   return MAX32(maxval, -minval);
   220ea:	425b      	negs	r3, r3
   220ec:	459b      	cmp	fp, r3
   220ee:	bfb8      	it	lt
   220f0:	469b      	movlt	fp, r3
         if (maxval > 0)
   220f2:	f1bb 0f00 	cmp.w	fp, #0
   220f6:	dd3d      	ble.n	22174 <compute_band_energies+0xfc>
            int shift = celt_ilog2(maxval) - 14 + (((m->logN[i]>>BITRES)+LM+1)>>1);
   220f8:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
   return EC_ILOG(x)-1;
   220fc:	fabb fb8b 	clz	fp, fp
   22100:	f932 200e 	ldrsh.w	r2, [r2, lr]
   22104:	f1cb 0b1f 	rsb	fp, fp, #31
   22108:	fa1f fb8b 	uxth.w	fp, fp
   2210c:	eb07 02e2 	add.w	r2, r7, r2, asr #3
   22110:	f1ab 0b0e 	sub.w	fp, fp, #14
   22114:	3201      	adds	r2, #1
   22116:	eb0b 0b62 	add.w	fp, fp, r2, asr #1
            if (shift>0)
   2211a:	f1bb 0f00 	cmp.w	fp, #0
   2211e:	fa0c fc07 	lsl.w	ip, ip, r7
   22122:	dd31      	ble.n	22188 <compute_band_energies+0x110>
         opus_val32 sum = 0;
   22124:	2000      	movs	r0, #0
                  sum = MAC16_16(sum, EXTRACT16(SHR32(X[j+c*N],shift)),
   22126:	f854 3b04 	ldr.w	r3, [r4], #4
               } while (++j<eBands[i+1]<<LM);
   2212a:	3501      	adds	r5, #1
                  sum = MAC16_16(sum, EXTRACT16(SHR32(X[j+c*N],shift)),
   2212c:	fa43 f30b 	asr.w	r3, r3, fp
   22130:	b21b      	sxth	r3, r3
               } while (++j<eBands[i+1]<<LM);
   22132:	4565      	cmp	r5, ip
                  sum = MAC16_16(sum, EXTRACT16(SHR32(X[j+c*N],shift)),
   22134:	fb03 0003 	mla	r0, r3, r3, r0
               } while (++j<eBands[i+1]<<LM);
   22138:	dbf5      	blt.n	22126 <compute_band_energies+0xae>
            bandE[i+c*m->nbEBands] = EPSILON+VSHR32(EXTEND32(celt_sqrt(sum)),-shift);
   2213a:	f009 f99d 	bl	2b478 <celt_sqrt>
   2213e:	fa00 f00b 	lsl.w	r0, r0, fp
   22142:	3001      	adds	r0, #1
   22144:	f8d9 3008 	ldr.w	r3, [r9, #8]
   22148:	9a03      	ldr	r2, [sp, #12]
   2214a:	fb03 630a 	mla	r3, r3, sl, r6
   2214e:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
      for (i=0;i<end;i++)
   22152:	9b02      	ldr	r3, [sp, #8]
   22154:	4543      	cmp	r3, r8
   22156:	f106 0601 	add.w	r6, r6, #1
   2215a:	d1a4      	bne.n	220a6 <compute_band_energies+0x2e>
   2215c:	9b01      	ldr	r3, [sp, #4]
   2215e:	9a07      	ldr	r2, [sp, #28]
   22160:	4413      	add	r3, r2
   22162:	9301      	str	r3, [sp, #4]
   } while (++c<C);
   22164:	9b12      	ldr	r3, [sp, #72]	; 0x48
   22166:	f10a 0a01 	add.w	sl, sl, #1
   2216a:	459a      	cmp	sl, r3
   2216c:	db98      	blt.n	220a0 <compute_band_energies+0x28>
}
   2216e:	b009      	add	sp, #36	; 0x24
   22170:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            bandE[i+c*m->nbEBands] = EPSILON;
   22174:	f8d9 3008 	ldr.w	r3, [r9, #8]
   22178:	9a03      	ldr	r2, [sp, #12]
   2217a:	fb03 630a 	mla	r3, r3, sl, r6
   2217e:	4611      	mov	r1, r2
   22180:	2201      	movs	r2, #1
   22182:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
   22186:	e7e4      	b.n	22152 <compute_band_energies+0xda>
   22188:	f1cb 0300 	rsb	r3, fp, #0
         opus_val32 sum = 0;
   2218c:	2000      	movs	r0, #0
                  sum = MAC16_16(sum, EXTRACT16(SHL32(X[j+c*N],-shift)),
   2218e:	f854 2b04 	ldr.w	r2, [r4], #4
               } while (++j<eBands[i+1]<<LM);
   22192:	3501      	adds	r5, #1
                  sum = MAC16_16(sum, EXTRACT16(SHL32(X[j+c*N],-shift)),
   22194:	409a      	lsls	r2, r3
   22196:	b212      	sxth	r2, r2
               } while (++j<eBands[i+1]<<LM);
   22198:	4565      	cmp	r5, ip
                  sum = MAC16_16(sum, EXTRACT16(SHL32(X[j+c*N],-shift)),
   2219a:	fb02 0002 	mla	r0, r2, r2, r0
               } while (++j<eBands[i+1]<<LM);
   2219e:	dbf6      	blt.n	2218e <compute_band_energies+0x116>
   221a0:	9305      	str	r3, [sp, #20]
            bandE[i+c*m->nbEBands] = EPSILON+VSHR32(EXTEND32(celt_sqrt(sum)),-shift);
   221a2:	f1bb 0f00 	cmp.w	fp, #0
   221a6:	d0c8      	beq.n	2213a <compute_band_energies+0xc2>
   221a8:	f009 f966 	bl	2b478 <celt_sqrt>
   221ac:	9b05      	ldr	r3, [sp, #20]
   221ae:	4118      	asrs	r0, r3
   221b0:	3001      	adds	r0, #1
   221b2:	e7c7      	b.n	22144 <compute_band_energies+0xcc>

000221b4 <normalise_bands>:
{
   221b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   221b8:	b087      	sub	sp, #28
   221ba:	4607      	mov	r7, r0
   221bc:	9c12      	ldr	r4, [sp, #72]	; 0x48
   N = M*m->shortMdctSize;
   221be:	6a40      	ldr	r0, [r0, #36]	; 0x24
   const opus_int16 *eBands = m->eBands;
   221c0:	69bd      	ldr	r5, [r7, #24]
{
   221c2:	9303      	str	r3, [sp, #12]
   221c4:	e9cd 1201 	strd	r1, r2, [sp, #4]
   N = M*m->shortMdctSize;
   221c8:	2600      	movs	r6, #0
   221ca:	fb00 f304 	mul.w	r3, r0, r4
   const opus_int16 *eBands = m->eBands;
   221ce:	9504      	str	r5, [sp, #16]
   N = M*m->shortMdctSize;
   221d0:	9305      	str	r3, [sp, #20]
   c=0; do {
   221d2:	4635      	mov	r5, r6
   221d4:	f8dd b010 	ldr.w	fp, [sp, #16]
      i=0; do {
   221d8:	f04f 0900 	mov.w	r9, #0
         shift = celt_zlog2(bandE[i+c*m->nbEBands])-13;
   221dc:	68bb      	ldr	r3, [r7, #8]
   221de:	9a03      	ldr	r2, [sp, #12]
   221e0:	fb03 9305 	mla	r3, r3, r5, r9
   221e4:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
   return x <= 0 ? 0 : celt_ilog2(x);
   221e8:	2800      	cmp	r0, #0
   221ea:	dd5a      	ble.n	222a2 <normalise_bands+0xee>
   return EC_ILOG(x)-1;
   221ec:	fab0 f880 	clz	r8, r0
   221f0:	f1c8 081f 	rsb	r8, r8, #31
   221f4:	fa1f f888 	uxth.w	r8, r8
   221f8:	f1a8 0a0d 	sub.w	sl, r8, #13
         E = VSHR32(bandE[i+c*m->nbEBands], shift);
   221fc:	f1ba 0f00 	cmp.w	sl, #0
   22200:	dd57      	ble.n	222b2 <normalise_bands+0xfe>
   22202:	fa40 f00a 	asr.w	r0, r0, sl
   22206:	b200      	sxth	r0, r0
         g = EXTRACT16(celt_rcp(SHL32(E,3)));
   22208:	00c0      	lsls	r0, r0, #3
   2220a:	f009 f9ef 	bl	2b5ec <celt_rcp>
         j=M*eBands[i]; do {
   2220e:	f9bb 2000 	ldrsh.w	r2, [fp]
         } while (++j<M*eBands[i+1]);
   22212:	f93b cf02 	ldrsh.w	ip, [fp, #2]!
   22216:	f1ba 0f01 	cmp.w	sl, #1
         g = EXTRACT16(celt_rcp(SHL32(E,3)));
   2221a:	b200      	sxth	r0, r0
         j=M*eBands[i]; do {
   2221c:	fb04 f202 	mul.w	r2, r4, r2
         } while (++j<M*eBands[i+1]);
   22220:	fb04 fc0c 	mul.w	ip, r4, ip
   22224:	dd22      	ble.n	2226c <normalise_bands+0xb8>
   22226:	9b01      	ldr	r3, [sp, #4]
   22228:	18b1      	adds	r1, r6, r2
   2222a:	eb03 0e81 	add.w	lr, r3, r1, lsl #2
   2222e:	9b02      	ldr	r3, [sp, #8]
   22230:	f1a8 080e 	sub.w	r8, r8, #14
   22234:	eb03 0141 	add.w	r1, r3, r1, lsl #1
   22238:	f85e 3b04 	ldr.w	r3, [lr], #4
            X[j+c*N] = MULT16_16_Q15(VSHR32(freq[j+c*N],shift-1),g);
   2223c:	fa43 f308 	asr.w	r3, r3, r8
   22240:	fb13 f300 	smulbb	r3, r3, r0
         } while (++j<M*eBands[i+1]);
   22244:	3201      	adds	r2, #1
            X[j+c*N] = MULT16_16_Q15(VSHR32(freq[j+c*N],shift-1),g);
   22246:	13db      	asrs	r3, r3, #15
         } while (++j<M*eBands[i+1]);
   22248:	4594      	cmp	ip, r2
            X[j+c*N] = MULT16_16_Q15(VSHR32(freq[j+c*N],shift-1),g);
   2224a:	f821 3b02 	strh.w	r3, [r1], #2
         } while (++j<M*eBands[i+1]);
   2224e:	dcf3      	bgt.n	22238 <normalise_bands+0x84>
      } while (++i<end);
   22250:	9b10      	ldr	r3, [sp, #64]	; 0x40
   22252:	f109 0901 	add.w	r9, r9, #1
   22256:	4599      	cmp	r9, r3
   22258:	dbc0      	blt.n	221dc <normalise_bands+0x28>
   2225a:	9b05      	ldr	r3, [sp, #20]
   2225c:	441e      	add	r6, r3
   } while (++c<C);
   2225e:	9b11      	ldr	r3, [sp, #68]	; 0x44
   22260:	3501      	adds	r5, #1
   22262:	429d      	cmp	r5, r3
   22264:	dbb6      	blt.n	221d4 <normalise_bands+0x20>
}
   22266:	b007      	add	sp, #28
   22268:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2226c:	9901      	ldr	r1, [sp, #4]
   2226e:	eb06 0e02 	add.w	lr, r6, r2
   22272:	eb01 088e 	add.w	r8, r1, lr, lsl #2
   22276:	9902      	ldr	r1, [sp, #8]
   22278:	f1ca 0301 	rsb	r3, sl, #1
   2227c:	eb01 0e4e 	add.w	lr, r1, lr, lsl #1
   22280:	f858 1b04 	ldr.w	r1, [r8], #4
            X[j+c*N] = MULT16_16_Q15(VSHR32(freq[j+c*N],shift-1),g);
   22284:	4099      	lsls	r1, r3
   22286:	fb11 f100 	smulbb	r1, r1, r0
         } while (++j<M*eBands[i+1]);
   2228a:	3201      	adds	r2, #1
            X[j+c*N] = MULT16_16_Q15(VSHR32(freq[j+c*N],shift-1),g);
   2228c:	13c9      	asrs	r1, r1, #15
         } while (++j<M*eBands[i+1]);
   2228e:	4594      	cmp	ip, r2
            X[j+c*N] = MULT16_16_Q15(VSHR32(freq[j+c*N],shift-1),g);
   22290:	f82e 1b02 	strh.w	r1, [lr], #2
         } while (++j<M*eBands[i+1]);
   22294:	dcf4      	bgt.n	22280 <normalise_bands+0xcc>
      } while (++i<end);
   22296:	9b10      	ldr	r3, [sp, #64]	; 0x40
   22298:	f109 0901 	add.w	r9, r9, #1
   2229c:	4599      	cmp	r9, r3
   2229e:	db9d      	blt.n	221dc <normalise_bands+0x28>
   222a0:	e7db      	b.n	2225a <normalise_bands+0xa6>
   return x <= 0 ? 0 : celt_ilog2(x);
   222a2:	220d      	movs	r2, #13
         shift = celt_zlog2(bandE[i+c*m->nbEBands])-13;
   222a4:	f06f 0a0c 	mvn.w	sl, #12
   222a8:	f04f 0800 	mov.w	r8, #0
         E = VSHR32(bandE[i+c*m->nbEBands], shift);
   222ac:	4090      	lsls	r0, r2
   222ae:	b200      	sxth	r0, r0
   222b0:	e7aa      	b.n	22208 <normalise_bands+0x54>
   222b2:	f1c8 020d 	rsb	r2, r8, #13
   222b6:	e7f9      	b.n	222ac <normalise_bands+0xf8>

000222b8 <spreading_decision>:
{
   222b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   222bc:	b08d      	sub	sp, #52	; 0x34
   const opus_int16 * OPUS_RESTRICT eBands = m->eBands;
   222be:	6985      	ldr	r5, [r0, #24]
   if (M*(eBands[end]-eBands[end-1]) <= 8)
   222c0:	9e19      	ldr	r6, [sp, #100]	; 0x64
   const opus_int16 * OPUS_RESTRICT eBands = m->eBands;
   222c2:	9508      	str	r5, [sp, #32]
   if (M*(eBands[end]-eBands[end-1]) <= 8)
   222c4:	f935 4016 	ldrsh.w	r4, [r5, r6, lsl #1]
{
   222c8:	9105      	str	r1, [sp, #20]
   if (M*(eBands[end]-eBands[end-1]) <= 8)
   222ca:	eb05 0546 	add.w	r5, r5, r6, lsl #1
{
   222ce:	460e      	mov	r6, r1
   if (M*(eBands[end]-eBands[end-1]) <= 8)
   222d0:	f935 1c02 	ldrsh.w	r1, [r5, #-2]
{
   222d4:	9f1b      	ldr	r7, [sp, #108]	; 0x6c
   if (M*(eBands[end]-eBands[end-1]) <= 8)
   222d6:	9502      	str	r5, [sp, #8]
   222d8:	1a61      	subs	r1, r4, r1
   222da:	fb07 f101 	mul.w	r1, r7, r1
   222de:	2908      	cmp	r1, #8
{
   222e0:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
   if (M*(eBands[end]-eBands[end-1]) <= 8)
   222e4:	f340 80f8 	ble.w	224d8 <spreading_decision+0x220>
   222e8:	6a43      	ldr	r3, [r0, #36]	; 0x24
   222ea:	fb03 f307 	mul.w	r3, r3, r7
   N0 = M*m->shortMdctSize;
   222ee:	f04f 0a00 	mov.w	sl, #0
   222f2:	9309      	str	r3, [sp, #36]	; 0x24
   222f4:	1eb3      	subs	r3, r6, #2
   int hf_sum=0;
   222f6:	f8cd a010 	str.w	sl, [sp, #16]
   int sum = 0, nbBands=0;
   222fa:	46d6      	mov	lr, sl
   222fc:	f8cd a004 	str.w	sl, [sp, #4]
   c=0; do {
   22300:	f8cd a01c 	str.w	sl, [sp, #28]
   22304:	9306      	str	r3, [sp, #24]
      for (i=0;i<end;i++)
   22306:	9b19      	ldr	r3, [sp, #100]	; 0x64
   22308:	2b00      	cmp	r3, #0
   2230a:	dd63      	ble.n	223d4 <spreading_decision+0x11c>
   2230c:	f10a 4300 	add.w	r3, sl, #2147483648	; 0x80000000
   22310:	3b01      	subs	r3, #1
   22312:	9e08      	ldr	r6, [sp, #32]
   22314:	9303      	str	r3, [sp, #12]
   22316:	f04f 0c00 	mov.w	ip, #0
         const celt_norm * OPUS_RESTRICT x = X+M*eBands[i]+c*N0;
   2231a:	f9b6 8000 	ldrsh.w	r8, [r6]
         N = M*(eBands[i+1]-eBands[i]);
   2231e:	f936 2f02 	ldrsh.w	r2, [r6, #2]!
   22322:	eba2 0208 	sub.w	r2, r2, r8
   22326:	fb07 f202 	mul.w	r2, r7, r2
         if (N<=8)
   2232a:	2a08      	cmp	r2, #8
   2232c:	dd4d      	ble.n	223ca <spreading_decision+0x112>
   2232e:	9b03      	ldr	r3, [sp, #12]
   22330:	fb07 f808 	mul.w	r8, r7, r8
   22334:	eb08 090a 	add.w	r9, r8, sl
   22338:	4498      	add	r8, r3
   2233a:	9b06      	ldr	r3, [sp, #24]
   2233c:	4491      	add	r9, r2
   2233e:	eb03 0949 	add.w	r9, r3, r9, lsl #1
   22342:	9b05      	ldr	r3, [sp, #20]
         int tcount[3] = {0,0,0};
   22344:	2500      	movs	r5, #0
   22346:	eb03 0848 	add.w	r8, r3, r8, lsl #1
   2234a:	462c      	mov	r4, r5
   2234c:	4629      	mov	r1, r5
   2234e:	fa0f fb82 	sxth.w	fp, r2
            x2N = MULT16_16(MULT16_16_Q15(x[j], x[j]), N);
   22352:	f938 3f02 	ldrsh.w	r3, [r8, #2]!
   22356:	fb03 f303 	mul.w	r3, r3, r3
   2235a:	13db      	asrs	r3, r3, #15
   2235c:	fb13 f30b 	smulbb	r3, r3, fp
            if (x2N < QCONST16(0.25f,13))
   22360:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
   22364:	da09      	bge.n	2237a <spreading_decision+0xc2>
            if (x2N < QCONST16(0.0625f,13))
   22366:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
               tcount[0]++;
   2236a:	f101 0101 	add.w	r1, r1, #1
            if (x2N < QCONST16(0.0625f,13))
   2236e:	da04      	bge.n	2237a <spreading_decision+0xc2>
            if (x2N < QCONST16(0.015625f,13))
   22370:	2b7f      	cmp	r3, #127	; 0x7f
               tcount[1]++;
   22372:	f104 0401 	add.w	r4, r4, #1
               tcount[2]++;
   22376:	bfd8      	it	le
   22378:	3501      	addle	r5, #1
         for (j=0;j<N;j++)
   2237a:	45c8      	cmp	r8, r9
   2237c:	d1e9      	bne.n	22352 <spreading_decision+0x9a>
         if (i>m->nbEBands-4)
   2237e:	6883      	ldr	r3, [r0, #8]
   22380:	3b03      	subs	r3, #3
   22382:	4563      	cmp	r3, ip
   22384:	dc0b      	bgt.n	2239e <spreading_decision+0xe6>
            hf_sum += celt_udiv(32*(tcount[1]+tcount[0]), N);
   22386:	1863      	adds	r3, r4, r1
   if (d>256)
   22388:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
   2238c:	ea4f 1b43 	mov.w	fp, r3, lsl #5
   22390:	f340 8084 	ble.w	2249c <spreading_decision+0x1e4>
      return n/d;
   22394:	fbbb f8f2 	udiv	r8, fp, r2
   22398:	9b04      	ldr	r3, [sp, #16]
   2239a:	4443      	add	r3, r8
   2239c:	9304      	str	r3, [sp, #16]
         tmp = (2*tcount[2] >= N) + (2*tcount[1] >= N) + (2*tcount[0] >= N);
   2239e:	ebb2 0f45 	cmp.w	r2, r5, lsl #1
   223a2:	bfd4      	ite	le
   223a4:	2301      	movle	r3, #1
   223a6:	2300      	movgt	r3, #0
   223a8:	0064      	lsls	r4, r4, #1
   223aa:	4294      	cmp	r4, r2
   223ac:	bfb4      	ite	lt
   223ae:	461c      	movlt	r4, r3
   223b0:	1c5c      	addge	r4, r3, #1
         sum += tmp*spread_weight[i];
   223b2:	9b1c      	ldr	r3, [sp, #112]	; 0x70
         tmp = (2*tcount[2] >= N) + (2*tcount[1] >= N) + (2*tcount[0] >= N);
   223b4:	0049      	lsls	r1, r1, #1
         sum += tmp*spread_weight[i];
   223b6:	f853 502c 	ldr.w	r5, [r3, ip, lsl #2]
   223ba:	9b01      	ldr	r3, [sp, #4]
         tmp = (2*tcount[2] >= N) + (2*tcount[1] >= N) + (2*tcount[0] >= N);
   223bc:	4291      	cmp	r1, r2
   223be:	bfa8      	it	ge
   223c0:	3401      	addge	r4, #1
         sum += tmp*spread_weight[i];
   223c2:	fb05 3304 	mla	r3, r5, r4, r3
   223c6:	9301      	str	r3, [sp, #4]
         nbBands+=spread_weight[i];
   223c8:	44ae      	add	lr, r5
      for (i=0;i<end;i++)
   223ca:	9b02      	ldr	r3, [sp, #8]
   223cc:	42b3      	cmp	r3, r6
   223ce:	f10c 0c01 	add.w	ip, ip, #1
   223d2:	d1a2      	bne.n	2231a <spreading_decision+0x62>
   223d4:	9a09      	ldr	r2, [sp, #36]	; 0x24
   } while (++c<C);
   223d6:	9b07      	ldr	r3, [sp, #28]
   223d8:	4492      	add	sl, r2
   223da:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   223dc:	3301      	adds	r3, #1
   223de:	4293      	cmp	r3, r2
   223e0:	9307      	str	r3, [sp, #28]
   223e2:	db90      	blt.n	22306 <spreading_decision+0x4e>
   if (update_hf)
   223e4:	9b18      	ldr	r3, [sp, #96]	; 0x60
   223e6:	b313      	cbz	r3, 2242e <spreading_decision+0x176>
      if (hf_sum)
   223e8:	9b04      	ldr	r3, [sp, #16]
   223ea:	b173      	cbz	r3, 2240a <spreading_decision+0x152>
         hf_sum = celt_udiv(hf_sum, C*(4-m->nbEBands+end));
   223ec:	6881      	ldr	r1, [r0, #8]
   223ee:	9a19      	ldr	r2, [sp, #100]	; 0x64
   223f0:	f1c1 0104 	rsb	r1, r1, #4
   223f4:	4411      	add	r1, r2
   223f6:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   223f8:	fb02 f101 	mul.w	r1, r2, r1
   if (d>256)
   223fc:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
   22400:	f240 8085 	bls.w	2250e <spreading_decision+0x256>
      return n/d;
   22404:	fbb3 f1f1 	udiv	r1, r3, r1
   22408:	9104      	str	r1, [sp, #16]
      *hf_average = (*hf_average+hf_sum)>>1;
   2240a:	9b16      	ldr	r3, [sp, #88]	; 0x58
   2240c:	9a04      	ldr	r2, [sp, #16]
   2240e:	681b      	ldr	r3, [r3, #0]
   22410:	441a      	add	r2, r3
   22412:	1053      	asrs	r3, r2, #1
   22414:	9a16      	ldr	r2, [sp, #88]	; 0x58
   22416:	6013      	str	r3, [r2, #0]
      if (*tapset_decision==2)
   22418:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   2241a:	6812      	ldr	r2, [r2, #0]
   2241c:	2a02      	cmp	r2, #2
   2241e:	d05f      	beq.n	224e0 <spreading_decision+0x228>
      else if (*tapset_decision==0)
   22420:	b902      	cbnz	r2, 22424 <spreading_decision+0x16c>
         hf_sum -= 4;
   22422:	3b04      	subs	r3, #4
      if (hf_sum > 22)
   22424:	2b16      	cmp	r3, #22
   22426:	dd61      	ble.n	224ec <spreading_decision+0x234>
         *tapset_decision=2;
   22428:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   2242a:	2302      	movs	r3, #2
   2242c:	6013      	str	r3, [r2, #0]
   sum = celt_udiv((opus_int32)sum<<8, nbBands);
   2242e:	9b01      	ldr	r3, [sp, #4]
   if (d>256)
   22430:	f5be 7f80 	cmp.w	lr, #256	; 0x100
   22434:	ea4f 2103 	mov.w	r1, r3, lsl #8
   22438:	d84b      	bhi.n	224d2 <spreading_decision+0x21a>
      t = EC_ILOG(d&-d);
   2243a:	f1ce 0300 	rsb	r3, lr, #0
   2243e:	ea03 030e 	and.w	r3, r3, lr
   22442:	fab3 f383 	clz	r3, r3
   22446:	f1c3 0320 	rsb	r3, r3, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   2244a:	fa2e f403 	lsr.w	r4, lr, r3
   2244e:	483c      	ldr	r0, [pc, #240]	; (22540 <spreading_decision+0x288>)
   22450:	1e5a      	subs	r2, r3, #1
   22452:	f850 3024 	ldr.w	r3, [r0, r4, lsl #2]
   22456:	fa21 f202 	lsr.w	r2, r1, r2
   2245a:	fba2 2303 	umull	r2, r3, r2, r3
      return q+(n-q*d >= d);
   2245e:	fb0e 1113 	mls	r1, lr, r3, r1
   22462:	458e      	cmp	lr, r1
   22464:	bf98      	it	ls
   22466:	3301      	addls	r3, #1
   sum = (sum+*average)>>1;
   22468:	990a      	ldr	r1, [sp, #40]	; 0x28
   2246a:	680a      	ldr	r2, [r1, #0]
   2246c:	4413      	add	r3, r2
   sum = (3*sum + (((3-last_decision)<<7) + 64) + 2)>>2;
   2246e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   sum = (sum+*average)>>1;
   22470:	105b      	asrs	r3, r3, #1
   sum = (3*sum + (((3-last_decision)<<7) + 64) + 2)>>2;
   22472:	f1c2 0203 	rsb	r2, r2, #3
   22476:	eb03 0043 	add.w	r0, r3, r3, lsl #1
   2247a:	eb00 10c2 	add.w	r0, r0, r2, lsl #7
   2247e:	3042      	adds	r0, #66	; 0x42
   22480:	1080      	asrs	r0, r0, #2
   if (sum < 80)
   22482:	284f      	cmp	r0, #79	; 0x4f
   *average = sum;
   22484:	600b      	str	r3, [r1, #0]
   if (sum < 80)
   22486:	dd2d      	ble.n	224e4 <spreading_decision+0x22c>
   } else if (sum < 256)
   22488:	28ff      	cmp	r0, #255	; 0xff
   2248a:	dd3c      	ble.n	22506 <spreading_decision+0x24e>
   } else if (sum < 384)
   2248c:	f5b0 7fc0 	cmp.w	r0, #384	; 0x180
   22490:	bfac      	ite	ge
   22492:	2000      	movge	r0, #0
   22494:	2001      	movlt	r0, #1
}
   22496:	b00d      	add	sp, #52	; 0x34
   22498:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      t = EC_ILOG(d&-d);
   2249c:	f1c2 0800 	rsb	r8, r2, #0
   224a0:	ea08 0802 	and.w	r8, r8, r2
   224a4:	fab8 f888 	clz	r8, r8
   224a8:	f1c8 0820 	rsb	r8, r8, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   224ac:	fa22 f908 	lsr.w	r9, r2, r8
   224b0:	4b23      	ldr	r3, [pc, #140]	; (22540 <spreading_decision+0x288>)
   224b2:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
   224b6:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   224ba:	fa2b f808 	lsr.w	r8, fp, r8
   224be:	fba8 8909 	umull	r8, r9, r8, r9
      return q+(n-q*d >= d);
   224c2:	fb02 b319 	mls	r3, r2, r9, fp
   224c6:	429a      	cmp	r2, r3
   224c8:	bf8c      	ite	hi
   224ca:	46c8      	movhi	r8, r9
   224cc:	f109 0801 	addls.w	r8, r9, #1
   224d0:	e762      	b.n	22398 <spreading_decision+0xe0>
      return n/d;
   224d2:	fbb1 f3fe 	udiv	r3, r1, lr
   224d6:	e7c7      	b.n	22468 <spreading_decision+0x1b0>
      return SPREAD_NONE;
   224d8:	2000      	movs	r0, #0
}
   224da:	b00d      	add	sp, #52	; 0x34
   224dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
         hf_sum += 4;
   224e0:	3304      	adds	r3, #4
   224e2:	e79f      	b.n	22424 <spreading_decision+0x16c>
      decision = SPREAD_AGGRESSIVE;
   224e4:	2003      	movs	r0, #3
}
   224e6:	b00d      	add	sp, #52	; 0x34
   224e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      else if (hf_sum > 18)
   224ec:	2b12      	cmp	r3, #18
         *tapset_decision=0;
   224ee:	9a17      	ldr	r2, [sp, #92]	; 0x5c
         *tapset_decision=1;
   224f0:	bfcc      	ite	gt
   224f2:	2301      	movgt	r3, #1
         *tapset_decision=0;
   224f4:	2300      	movle	r3, #0
   224f6:	6013      	str	r3, [r2, #0]
   sum = celt_udiv((opus_int32)sum<<8, nbBands);
   224f8:	9b01      	ldr	r3, [sp, #4]
   if (d>256)
   224fa:	f5be 7f80 	cmp.w	lr, #256	; 0x100
   224fe:	ea4f 2103 	mov.w	r1, r3, lsl #8
   22502:	d99a      	bls.n	2243a <spreading_decision+0x182>
   22504:	e7e5      	b.n	224d2 <spreading_decision+0x21a>
      decision = SPREAD_NORMAL;
   22506:	2002      	movs	r0, #2
}
   22508:	b00d      	add	sp, #52	; 0x34
   2250a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      t = EC_ILOG(d&-d);
   2250e:	424b      	negs	r3, r1
   22510:	400b      	ands	r3, r1
   22512:	fab3 f383 	clz	r3, r3
   22516:	f1c3 0320 	rsb	r3, r3, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   2251a:	fa21 f403 	lsr.w	r4, r1, r3
   2251e:	4808      	ldr	r0, [pc, #32]	; (22540 <spreading_decision+0x288>)
   22520:	1e5a      	subs	r2, r3, #1
   22522:	f850 3024 	ldr.w	r3, [r0, r4, lsl #2]
   22526:	9804      	ldr	r0, [sp, #16]
   22528:	fa20 f202 	lsr.w	r2, r0, r2
   2252c:	fba2 3403 	umull	r3, r4, r2, r3
      return q+(n-q*d >= d);
   22530:	fb01 0214 	mls	r2, r1, r4, r0
   22534:	4291      	cmp	r1, r2
   22536:	bf8c      	ite	hi
   22538:	4621      	movhi	r1, r4
   2253a:	1c61      	addls	r1, r4, #1
   2253c:	e764      	b.n	22408 <spreading_decision+0x150>
   2253e:	bf00      	nop
   22540:	00038e98 	.word	0x00038e98

00022544 <haar1>:
   for (i=0;i<stride;i++)
   22544:	2a00      	cmp	r2, #0
   22546:	dd2e      	ble.n	225a6 <haar1+0x62>
   22548:	1049      	asrs	r1, r1, #1
   2254a:	2900      	cmp	r1, #0
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
   2254c:	ea4f 0c42 	mov.w	ip, r2, lsl #1
   22550:	dd29      	ble.n	225a6 <haar1+0x62>
{
   22552:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   22556:	0096      	lsls	r6, r2, #2
   22558:	eb00 0e0c 	add.w	lr, r0, ip
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
   2255c:	f645 2782 	movw	r7, #23170	; 0x5a82
   22560:	eb0c 0400 	add.w	r4, ip, r0
{
   22564:	4602      	mov	r2, r0
      for (j=0;j<N0;j++)
   22566:	2500      	movs	r5, #0
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
   22568:	8813      	ldrh	r3, [r2, #0]
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
   2256a:	f8b4 9000 	ldrh.w	r9, [r4]
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
   2256e:	fb13 f307 	smulbb	r3, r3, r7
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
   22572:	fb19 f907 	smulbb	r9, r9, r7
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
   22576:	eb03 0809 	add.w	r8, r3, r9
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
   2257a:	eba3 0309 	sub.w	r3, r3, r9
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
   2257e:	f508 4880 	add.w	r8, r8, #16384	; 0x4000
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
   22582:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
      for (j=0;j<N0;j++)
   22586:	3501      	adds	r5, #1
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
   22588:	ea4f 38e8 	mov.w	r8, r8, asr #15
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
   2258c:	13db      	asrs	r3, r3, #15
      for (j=0;j<N0;j++)
   2258e:	42a9      	cmp	r1, r5
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
   22590:	f8a2 8000 	strh.w	r8, [r2]
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
   22594:	8023      	strh	r3, [r4, #0]
   22596:	4432      	add	r2, r6
   22598:	4434      	add	r4, r6
      for (j=0;j<N0;j++)
   2259a:	d1e5      	bne.n	22568 <haar1+0x24>
   2259c:	3002      	adds	r0, #2
   for (i=0;i<stride;i++)
   2259e:	4586      	cmp	lr, r0
   225a0:	d1de      	bne.n	22560 <haar1+0x1c>
}
   225a2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   225a6:	4770      	bx	lr

000225a8 <quant_all_bands>:
      celt_norm *X_, celt_norm *Y_, unsigned char *collapse_masks,
      const celt_ener *bandE, int *pulses, int shortBlocks, int spread,
      int dual_stereo, int intensity, int *tf_res, opus_int32 total_bits,
      opus_int32 balance, ec_ctx *ec, int LM, int codedBands,
      opus_uint32 *seed, int complexity, int arch, int disable_inv)
{
   225a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   225ac:	f2ad 6df4 	subw	sp, sp, #1780	; 0x6f4
   225b0:	af08      	add	r7, sp, #32
   225b2:	469a      	mov	sl, r3
   celt_norm *lowband_scratch;
   int B;
   int M;
   int lowband_offset;
   int update_lowband = 1;
   int C = Y_ != NULL ? 2 : 1;
   225b4:	f8d7 36fc 	ldr.w	r3, [r7, #1788]	; 0x6fc
   const opus_int16 * OPUS_RESTRICT eBands = m->eBands;
   225b8:	698c      	ldr	r4, [r1, #24]
   225ba:	677c      	str	r4, [r7, #116]	; 0x74
{
   225bc:	f8d7 672c 	ldr.w	r6, [r7, #1836]	; 0x72c
   225c0:	f8d7 470c 	ldr.w	r4, [r7, #1804]	; 0x70c
   int C = Y_ != NULL ? 2 : 1;
   225c4:	2b00      	cmp	r3, #0
   225c6:	f001 8122 	beq.w	2380e <quant_all_bands+0x1266>
   int norm_offset;
   int theta_rdo = encode && Y_!=NULL && !dual_stereo && complexity>=8;
   225ca:	2800      	cmp	r0, #0
   225cc:	f040 8229 	bne.w	22a22 <quant_all_bands+0x47a>
   int C = Y_ != NULL ? 2 : 1;
   225d0:	2302      	movs	r3, #2
   225d2:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
#ifdef RESYNTH
   int resynth = 1;
#else
   int resynth = !encode || theta_rdo;
   225d6:	2301      	movs	r3, #1
   int theta_rdo = encode && Y_!=NULL && !dual_stereo && complexity>=8;
   225d8:	6438      	str	r0, [r7, #64]	; 0x40
   int resynth = !encode || theta_rdo;
   225da:	67bb      	str	r3, [r7, #120]	; 0x78
#endif
   struct band_ctx ctx;
   SAVE_STACK;

   M = 1<<LM;
   B = shortBlocks ? M : 1;
   225dc:	2c00      	cmp	r4, #0
   225de:	f000 8233 	beq.w	22a48 <quant_all_bands+0x4a0>
   M = 1<<LM;
   225e2:	2401      	movs	r4, #1
   225e4:	fa04 f306 	lsl.w	r3, r4, r6
   225e8:	42a3      	cmp	r3, r4
   225ea:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
   225ee:	bfd4      	ite	le
   225f0:	f04f 0c00 	movle.w	ip, #0
   225f4:	f04f 0c01 	movgt.w	ip, #1
   norm_offset = M*eBands[start];
   225f8:	6f7d      	ldr	r5, [r7, #116]	; 0x74
   /* No need to allocate norm for the last band because we don't need an
      output in that band. */
   ALLOC(_norm, C*(M*eBands[m->nbEBands-1]-norm_offset), celt_norm);
   225fa:	688c      	ldr	r4, [r1, #8]
   norm_offset = M*eBands[start];
   225fc:	f935 5012 	ldrsh.w	r5, [r5, r2, lsl #1]
   ALLOC(_norm, C*(M*eBands[m->nbEBands-1]-norm_offset), celt_norm);
   22600:	f104 4400 	add.w	r4, r4, #2147483648	; 0x80000000
   norm_offset = M*eBands[start];
   22604:	fa05 f306 	lsl.w	r3, r5, r6
   ALLOC(_norm, C*(M*eBands[m->nbEBands-1]-norm_offset), celt_norm);
   22608:	3c01      	subs	r4, #1
   2260a:	6f7d      	ldr	r5, [r7, #116]	; 0x74
   norm_offset = M*eBands[start];
   2260c:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
   ALLOC(_norm, C*(M*eBands[m->nbEBands-1]-norm_offset), celt_norm);
   22610:	f935 e014 	ldrsh.w	lr, [r5, r4, lsl #1]
   22614:	f8d7 50a4 	ldr.w	r5, [r7, #164]	; 0xa4
   22618:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
   2261c:	fa0e f906 	lsl.w	r9, lr, r6
   22620:	eba9 0505 	sub.w	r5, r9, r5
   22624:	fb03 f805 	mul.w	r8, r3, r5
   22628:	ea4f 0848 	mov.w	r8, r8, lsl #1
   2262c:	f108 0808 	add.w	r8, r8, #8
   22630:	f028 0807 	bic.w	r8, r8, #7
   22634:	ebad 0d08 	sub.w	sp, sp, r8
   22638:	ab08      	add	r3, sp, #32
   2263a:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
   norm_offset = M*eBands[start];
   2263e:	0053      	lsls	r3, r2, #1
   22640:	63fb      	str	r3, [r7, #60]	; 0x3c
   norm = _norm;
   norm2 = norm + M*eBands[m->nbEBands-1]-norm_offset;
   22642:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
   22646:	eb03 0845 	add.w	r8, r3, r5, lsl #1
   norm_offset = M*eBands[start];
   2264a:	6f7d      	ldr	r5, [r7, #116]	; 0x74
   norm2 = norm + M*eBands[m->nbEBands-1]-norm_offset;
   2264c:	f8c7 8060 	str.w	r8, [r7, #96]	; 0x60
   norm_offset = M*eBands[start];
   22650:	0053      	lsls	r3, r2, #1
   22652:	18eb      	adds	r3, r5, r3
   ALLOC(_norm, C*(M*eBands[m->nbEBands-1]-norm_offset), celt_norm);
   22654:	0064      	lsls	r4, r4, #1
   norm_offset = M*eBands[start];
   22656:	657b      	str	r3, [r7, #84]	; 0x54

   /* For decoding, we can use the last band as scratch space because we don't need that
      scratch space for the last band and we don't care about the data there until we're
      decoding the last band. */
   if (encode && resynth)
   22658:	2800      	cmp	r0, #0
   2265a:	f000 87cf 	beq.w	235fc <quant_all_bands+0x1054>
   2265e:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   22660:	2b00      	cmp	r3, #0
   22662:	f000 87cb 	beq.w	235fc <quant_all_bands+0x1054>
      resynth_alloc = M*(eBands[m->nbEBands]-eBands[m->nbEBands-1]);
   22666:	442c      	add	r4, r5
   22668:	f9b4 4002 	ldrsh.w	r4, [r4, #2]
   2266c:	eba4 040e 	sub.w	r4, r4, lr
   22670:	40b4      	lsls	r4, r6
   else
      resynth_alloc = ALLOC_NONE;
   ALLOC(_lowband_scratch, resynth_alloc, celt_norm);
   22672:	0064      	lsls	r4, r4, #1
   22674:	3408      	adds	r4, #8
   22676:	f024 0507 	bic.w	r5, r4, #7
   2267a:	ebad 0d05 	sub.w	sp, sp, r5
   2267e:	ab08      	add	r3, sp, #32
   22680:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
   if (encode && resynth)
      lowband_scratch = _lowband_scratch;
   else
      lowband_scratch = X_+M*eBands[m->nbEBands-1];
   ALLOC(X_save, resynth_alloc, celt_norm);
   22684:	f024 0407 	bic.w	r4, r4, #7
   22688:	ebad 0d04 	sub.w	sp, sp, r4
   2268c:	ab08      	add	r3, sp, #32
   ALLOC(Y_save, resynth_alloc, celt_norm);
   2268e:	ebad 0d04 	sub.w	sp, sp, r4
   ALLOC(X_save, resynth_alloc, celt_norm);
   22692:	63bb      	str	r3, [r7, #56]	; 0x38
   ALLOC(Y_save, resynth_alloc, celt_norm);
   22694:	ab08      	add	r3, sp, #32
   ALLOC(X_save2, resynth_alloc, celt_norm);
   22696:	ebad 0d04 	sub.w	sp, sp, r4
   ALLOC(Y_save, resynth_alloc, celt_norm);
   2269a:	637b      	str	r3, [r7, #52]	; 0x34
   ALLOC(X_save2, resynth_alloc, celt_norm);
   2269c:	ab08      	add	r3, sp, #32
   ALLOC(Y_save2, resynth_alloc, celt_norm);
   2269e:	ebad 0d04 	sub.w	sp, sp, r4
   ALLOC(X_save2, resynth_alloc, celt_norm);
   226a2:	633b      	str	r3, [r7, #48]	; 0x30
   ALLOC(Y_save2, resynth_alloc, celt_norm);
   226a4:	ab08      	add	r3, sp, #32
   226a6:	62fb      	str	r3, [r7, #44]	; 0x2c
   ctx.bandE = bandE;
   ctx.ec = ec;
   ctx.encode = encode;
   ctx.intensity = intensity;
   ctx.m = m;
   ctx.seed = *seed;
   226a8:	f8d7 3734 	ldr.w	r3, [r7, #1844]	; 0x734
   ctx.encode = encode;
   226ac:	f8c7 0120 	str.w	r0, [r7, #288]	; 0x120
   ALLOC(norm_save2, resynth_alloc, celt_norm);
   226b0:	ebad 0d04 	sub.w	sp, sp, r4
   ctx.seed = *seed;
   226b4:	681c      	ldr	r4, [r3, #0]
   ctx.bandE = bandE;
   226b6:	f8d7 3704 	ldr.w	r3, [r7, #1796]	; 0x704
   226ba:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144
   ALLOC(norm_save2, resynth_alloc, celt_norm);
   226be:	ab08      	add	r3, sp, #32
   226c0:	62bb      	str	r3, [r7, #40]	; 0x28
   ctx.ec = ec;
   226c2:	f8d7 3728 	ldr.w	r3, [r7, #1832]	; 0x728
   226c6:	f8c7 313c 	str.w	r3, [r7, #316]	; 0x13c
   ctx.intensity = intensity;
   226ca:	f8d7 3718 	ldr.w	r3, [r7, #1816]	; 0x718
   226ce:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
   ctx.spread = spread;
   226d2:	f8d7 3710 	ldr.w	r3, [r7, #1808]	; 0x710
   226d6:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
   ctx.arch = arch;
   226da:	f8d7 373c 	ldr.w	r3, [r7, #1852]	; 0x73c
   226de:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
   ctx.disable_inv = disable_inv;
   226e2:	f8d7 3740 	ldr.w	r3, [r7, #1856]	; 0x740
   226e6:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
   ctx.resynth = resynth;
   ctx.theta_round = 0;
   226ea:	2000      	movs	r0, #0
   ctx.resynth = resynth;
   226ec:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   ctx.m = m;
   226ee:	f8c7 1128 	str.w	r1, [r7, #296]	; 0x128
   /* Avoid injecting noise in the first band on transients. */
   ctx.avoid_split_noise = B > 1;
   for (i=start;i<end;i++)
   226f2:	4552      	cmp	r2, sl
   ctx.resynth = resynth;
   226f4:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
   ctx.avoid_split_noise = B > 1;
   226f8:	f8c7 c158 	str.w	ip, [r7, #344]	; 0x158
   ctx.seed = *seed;
   226fc:	f8c7 4148 	str.w	r4, [r7, #328]	; 0x148
   ctx.theta_round = 0;
   22700:	f8c7 0150 	str.w	r0, [r7, #336]	; 0x150
   for (i=start;i<end;i++)
   22704:	f280 827f 	bge.w	22c06 <quant_all_bands+0x65e>
   22708:	6739      	str	r1, [r7, #112]	; 0x70
         } while (++fold_i<fold_end);
      }
      /* Otherwise, we'll be using the LCG to fold, so all blocks will (almost
         always) be non-zero. */
      else
         x_cm = y_cm = (1<<B)-1;
   2270a:	f8d7 10a0 	ldr.w	r1, [r7, #160]	; 0xa0
   2270e:	f8c7 a05c 	str.w	sl, [r7, #92]	; 0x5c
   22712:	4655      	mov	r5, sl
   22714:	f04f 0a01 	mov.w	sl, #1
   22718:	fa0a f301 	lsl.w	r3, sl, r1
   2271c:	1e59      	subs	r1, r3, #1
   2271e:	65b9      	str	r1, [r7, #88]	; 0x58
   22720:	1e6b      	subs	r3, r5, #1
   n1 = M*(eBands[start+1]-eBands[start]);
   22722:	eb02 010a 	add.w	r1, r2, sl
   22726:	f8c7 1080 	str.w	r1, [r7, #128]	; 0x80
   2272a:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
   2272e:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
   22730:	f8d7 3718 	ldr.w	r3, [r7, #1816]	; 0x718
   22734:	67fa      	str	r2, [r7, #124]	; 0x7c
   22736:	1c8c      	adds	r4, r1, #2
   22738:	429a      	cmp	r2, r3
   n2 = M*(eBands[start+2]-eBands[start+1]);
   2273a:	f101 0104 	add.w	r1, r1, #4
   n1 = M*(eBands[start+1]-eBands[start]);
   2273e:	627c      	str	r4, [r7, #36]	; 0x24
   n2 = M*(eBands[start+2]-eBands[start+1]);
   22740:	6239      	str	r1, [r7, #32]
   22742:	f2c0 8285 	blt.w	22c50 <quant_all_bands+0x6a8>
   22746:	4690      	mov	r8, r2
         x_cm = y_cm = (1<<B)-1;
   22748:	f8c7 00b4 	str.w	r0, [r7, #180]	; 0xb4
   2274c:	f8d7 00b8 	ldr.w	r0, [r7, #184]	; 0xb8
   22750:	f8d7 4700 	ldr.w	r4, [r7, #1792]	; 0x700
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
                     effective_lowband != -1 ? norm+effective_lowband : NULL, LM,
                     last?NULL:norm+M*eBands[i]-norm_offset, lowband_scratch, x_cm|y_cm);
            }
         } else {
            x_cm = quant_band(&ctx, X, N, b, B,
   22754:	f8d7 b724 	ldr.w	fp, [r7, #1828]	; 0x724
   22758:	f108 0201 	add.w	r2, r8, #1
   2275c:	4601      	mov	r1, r0
   2275e:	fb01 f102 	mul.w	r1, r1, r2
   22762:	64f9      	str	r1, [r7, #76]	; 0x4c
   22764:	1861      	adds	r1, r4, r1
   22766:	f8c7 1084 	str.w	r1, [r7, #132]	; 0x84
   2276a:	f8d7 1708 	ldr.w	r1, [r7, #1800]	; 0x708
   2276e:	66ba      	str	r2, [r7, #104]	; 0x68
   22770:	ea4f 0388 	mov.w	r3, r8, lsl #2
   22774:	1f1a      	subs	r2, r3, #4
   22776:	18cb      	adds	r3, r1, r3
   22778:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
   2277c:	f8d7 371c 	ldr.w	r3, [r7, #1820]	; 0x71c
   22780:	4413      	add	r3, r2
   22782:	66fb      	str	r3, [r7, #108]	; 0x6c
   22784:	6f7b      	ldr	r3, [r7, #116]	; 0x74
   22786:	eb03 0348 	add.w	r3, r3, r8, lsl #1
   2278a:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
   2278e:	f8d7 3730 	ldr.w	r3, [r7, #1840]	; 0x730
   22792:	eba3 0308 	sub.w	r3, r3, r8
   22796:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
   2279a:	fb08 f300 	mul.w	r3, r8, r0
   2279e:	653b      	str	r3, [r7, #80]	; 0x50
   227a0:	4644      	mov	r4, r8
   227a2:	e0fc      	b.n	2299e <quant_all_bands+0x3f6>
         curr_balance = celt_sudiv(balance, IMIN(3, codedBands-i));
   227a4:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
   227a8:	2b03      	cmp	r3, #3
   227aa:	bfa8      	it	ge
   227ac:	2303      	movge	r3, #3
   if (n<0)
   227ae:	f1bb 0f00 	cmp.w	fp, #0
   227b2:	f2c0 8217 	blt.w	22be4 <quant_all_bands+0x63c>
   if (d>256)
   227b6:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
   227ba:	f240 822e 	bls.w	22c1a <quant_all_bands+0x672>
      return n/d;
   227be:	fbbb f3f3 	udiv	r3, fp, r3
         b = IMAX(0, IMIN(16383, IMIN(remaining_bits+1,pulses[i]+curr_balance)));
   227c2:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
   227c6:	f643 70ff 	movw	r0, #16383	; 0x3fff
   227ca:	6809      	ldr	r1, [r1, #0]
   227cc:	4282      	cmp	r2, r0
   227ce:	440b      	add	r3, r1
   227d0:	bfa8      	it	ge
   227d2:	4602      	movge	r2, r0
   227d4:	4293      	cmp	r3, r2
   227d6:	bfa8      	it	ge
   227d8:	4613      	movge	r3, r2
   227da:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   227de:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
      if (resynth && (M*eBands[i]-N >= M*eBands[start] || i==start+1) && (update_lowband || lowband_offset==0))
   227e2:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   227e4:	2b00      	cmp	r3, #0
   227e6:	f000 8115 	beq.w	22a14 <quant_all_bands+0x46c>
   227ea:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
   227ee:	6d7a      	ldr	r2, [r7, #84]	; 0x54
   227f0:	f933 3c02 	ldrsh.w	r3, [r3, #-2]
   227f4:	f9b2 2000 	ldrsh.w	r2, [r2]
   227f8:	40b3      	lsls	r3, r6
   227fa:	1b5b      	subs	r3, r3, r5
   227fc:	40b2      	lsls	r2, r6
   227fe:	429a      	cmp	r2, r3
   22800:	f340 81d2 	ble.w	22ba8 <quant_all_bands+0x600>
   22804:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   22808:	42a3      	cmp	r3, r4
   2280a:	f000 87ba 	beq.w	23782 <quant_all_bands+0x11da>
      if (i>=m->effEBands)
   2280e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
      tf_change = tf_res[i];
   22810:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
      if (i>=m->effEBands)
   22812:	68da      	ldr	r2, [r3, #12]
      tf_change = tf_res[i];
   22814:	f851 3f04 	ldr.w	r3, [r1, #4]!
   22818:	66f9      	str	r1, [r7, #108]	; 0x6c
      if (i>=m->effEBands)
   2281a:	42a2      	cmp	r2, r4
      ctx.tf_change = tf_change;
   2281c:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
      if (i>=m->effEBands)
   22820:	f300 8117 	bgt.w	22a52 <quant_all_bands+0x4aa>
         X=norm;
   22824:	f8d7 109c 	ldr.w	r1, [r7, #156]	; 0x9c
   22828:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
   2282c:	f8d7 06fc 	ldr.w	r0, [r7, #1788]	; 0x6fc
   22830:	667a      	str	r2, [r7, #100]	; 0x64
   22832:	468c      	mov	ip, r1
   22834:	2800      	cmp	r0, #0
   22836:	bf18      	it	ne
   22838:	4694      	movne	ip, r2
   2283a:	2200      	movs	r2, #0
   2283c:	f8c7 c09c 	str.w	ip, [r7, #156]	; 0x9c
   22840:	f8c7 20ac 	str.w	r2, [r7, #172]	; 0xac
      if (last && !theta_rdo)
   22844:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
   22848:	42a2      	cmp	r2, r4
   2284a:	f001 8012 	beq.w	23872 <quant_all_bands+0x12ca>
      if (lowband_offset != 0 && (spread!=SPREAD_AGGRESSIVE || B>1 || tf_change<0))
   2284e:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
   22852:	b162      	cbz	r2, 2286e <quant_all_bands+0x2c6>
   22854:	f8d7 2710 	ldr.w	r2, [r7, #1808]	; 0x710
   22858:	2a03      	cmp	r2, #3
   2285a:	f040 80ff 	bne.w	22a5c <quant_all_bands+0x4b4>
   2285e:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
   22862:	2a01      	cmp	r2, #1
   22864:	f300 80fa 	bgt.w	22a5c <quant_all_bands+0x4b4>
   22868:	2b00      	cmp	r3, #0
   2286a:	f2c0 80f7 	blt.w	22a5c <quant_all_bands+0x4b4>
      if (dual_stereo && i==intensity)
   2286e:	f8d7 3714 	ldr.w	r3, [r7, #1812]	; 0x714
   22872:	2b00      	cmp	r3, #0
   22874:	f000 815b 	beq.w	22b2e <quant_all_bands+0x586>
   22878:	f8d7 3718 	ldr.w	r3, [r7, #1816]	; 0x718
   2287c:	42a3      	cmp	r3, r4
   2287e:	f001 8049 	beq.w	23914 <quant_all_bands+0x136c>
         x_cm = quant_band(&ctx, X, N, b/2, B,
   22882:	6dba      	ldr	r2, [r7, #88]	; 0x58
   22884:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
   22888:	64ba      	str	r2, [r7, #72]	; 0x48
   2288a:	ea4f 0a63 	mov.w	sl, r3, asr #1
   2288e:	f06f 0901 	mvn.w	r9, #1
   22892:	4613      	mov	r3, r2
      int effective_lowband=-1;
   22894:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
         x_cm = quant_band(&ctx, X, N, b/2, B,
   22898:	2200      	movs	r2, #0
   2289a:	f8d7 10a8 	ldr.w	r1, [r7, #168]	; 0xa8
   2289e:	42a1      	cmp	r1, r4
   228a0:	f001 804f 	beq.w	23942 <quant_all_bands+0x139a>
   228a4:	9306      	str	r3, [sp, #24]
   228a6:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
   228aa:	f647 71ff 	movw	r1, #32767	; 0x7fff
   228ae:	e9cd 1304 	strd	r1, r3, [sp, #16]
               last?NULL:norm+M*eBands[i]-norm_offset, Q15ONE, lowband_scratch, x_cm);
   228b2:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
   228b6:	f8d7 10a4 	ldr.w	r1, [r7, #164]	; 0xa4
   228ba:	f933 3c02 	ldrsh.w	r3, [r3, #-2]
         x_cm = quant_band(&ctx, X, N, b/2, B,
   228be:	9201      	str	r2, [sp, #4]
               last?NULL:norm+M*eBands[i]-norm_offset, Q15ONE, lowband_scratch, x_cm);
   228c0:	40b3      	lsls	r3, r6
   228c2:	1a5b      	subs	r3, r3, r1
         x_cm = quant_band(&ctx, X, N, b/2, B,
   228c4:	f8d7 10b0 	ldr.w	r1, [r7, #176]	; 0xb0
   228c8:	9602      	str	r6, [sp, #8]
   228ca:	eb01 0343 	add.w	r3, r1, r3, lsl #1
   228ce:	9303      	str	r3, [sp, #12]
   228d0:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
   228d4:	9300      	str	r3, [sp, #0]
   228d6:	6e79      	ldr	r1, [r7, #100]	; 0x64
   228d8:	4653      	mov	r3, sl
   228da:	462a      	mov	r2, r5
   228dc:	f507 7090 	add.w	r0, r7, #288	; 0x120
   228e0:	f7fe f8e0 	bl	20aa4 <quant_band>
         y_cm = quant_band(&ctx, Y, N, b/2, B,
   228e4:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
         x_cm = quant_band(&ctx, X, N, b/2, B,
   228e8:	4604      	mov	r4, r0
         y_cm = quant_band(&ctx, Y, N, b/2, B,
   228ea:	f000 8194 	beq.w	22c16 <quant_all_bands+0x66e>
   228ee:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   228f0:	eb03 0209 	add.w	r2, r3, r9
               last?NULL:norm2+M*eBands[i]-norm_offset, Q15ONE, lowband_scratch, y_cm);
   228f4:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
   228f8:	f8d7 10a4 	ldr.w	r1, [r7, #164]	; 0xa4
   228fc:	f933 3c02 	ldrsh.w	r3, [r3, #-2]
   22900:	40b3      	lsls	r3, r6
   22902:	1a5b      	subs	r3, r3, r1
         y_cm = quant_band(&ctx, Y, N, b/2, B,
   22904:	6e39      	ldr	r1, [r7, #96]	; 0x60
   22906:	eb01 0343 	add.w	r3, r1, r3, lsl #1
   2290a:	6cb9      	ldr	r1, [r7, #72]	; 0x48
   2290c:	9106      	str	r1, [sp, #24]
   2290e:	f647 70ff 	movw	r0, #32767	; 0x7fff
   22912:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
   22916:	9105      	str	r1, [sp, #20]
   22918:	e9cd 6302 	strd	r6, r3, [sp, #8]
   2291c:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
   22920:	9201      	str	r2, [sp, #4]
   22922:	9300      	str	r3, [sp, #0]
   22924:	9004      	str	r0, [sp, #16]
   22926:	4653      	mov	r3, sl
   22928:	f8d7 109c 	ldr.w	r1, [r7, #156]	; 0x9c
   2292c:	462a      	mov	r2, r5
   2292e:	f507 7090 	add.w	r0, r7, #288	; 0x120
   22932:	f7fe f8b7 	bl	20aa4 <quant_band>
                  effective_lowband != -1 ? norm+effective_lowband : NULL, LM,
                  last?NULL:norm+M*eBands[i]-norm_offset, Q15ONE, lowband_scratch, x_cm|y_cm);
         }
         y_cm = x_cm;
      }
      collapse_masks[i*C+0] = (unsigned char)x_cm;
   22936:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
      collapse_masks[i*C+C-1] = (unsigned char)y_cm;
      balance += pulses[i] + tell;

      /* Update the folding position only as long as we have 1 bit/sample depth. */
      update_lowband = b>(N<<BITRES);
   2293a:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
      collapse_masks[i*C+0] = (unsigned char)x_cm;
   2293e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
      update_lowband = b>(N<<BITRES);
   22940:	ebb1 0fc5 	cmp.w	r1, r5, lsl #3
      collapse_masks[i*C+0] = (unsigned char)x_cm;
   22944:	eba2 0303 	sub.w	r3, r2, r3
   22948:	6d39      	ldr	r1, [r7, #80]	; 0x50
   2294a:	545c      	strb	r4, [r3, r1]
      balance += pulses[i] + tell;
   2294c:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
      collapse_masks[i*C+C-1] = (unsigned char)y_cm;
   22950:	f802 0c01 	strb.w	r0, [r2, #-1]
      balance += pulses[i] + tell;
   22954:	f851 3b04 	ldr.w	r3, [r1], #4
   22958:	f8c7 1088 	str.w	r1, [r7, #136]	; 0x88
      /* We only need to avoid noise on a split for the first band. After that, we
         have folding. */
      ctx.avoid_split_noise = 0;
   2295c:	f04f 0100 	mov.w	r1, #0
   22960:	f8c7 1158 	str.w	r1, [r7, #344]	; 0x158
      balance += pulses[i] + tell;
   22964:	f8d7 1098 	ldr.w	r1, [r7, #152]	; 0x98
   22968:	440b      	add	r3, r1
   2296a:	f8d7 108c 	ldr.w	r1, [r7, #140]	; 0x8c
   2296e:	f101 31ff 	add.w	r1, r1, #4294967295	; 0xffffffff
   22972:	f8c7 108c 	str.w	r1, [r7, #140]	; 0x8c
   22976:	f8d7 10b8 	ldr.w	r1, [r7, #184]	; 0xb8
   2297a:	440a      	add	r2, r1
   2297c:	f8c7 2084 	str.w	r2, [r7, #132]	; 0x84
   for (i=start;i<end;i++)
   22980:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
      balance += pulses[i] + tell;
   22982:	449b      	add	fp, r3
      collapse_masks[i*C+C-1] = (unsigned char)y_cm;
   22984:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   for (i=start;i<end;i++)
   22986:	4611      	mov	r1, r2
      update_lowband = b>(N<<BITRES);
   22988:	bfcc      	ite	gt
   2298a:	f04f 0a01 	movgt.w	sl, #1
   2298e:	f04f 0a00 	movle.w	sl, #0
   for (i=start;i<end;i++)
   22992:	4299      	cmp	r1, r3
      collapse_masks[i*C+C-1] = (unsigned char)y_cm;
   22994:	461c      	mov	r4, r3
   for (i=start;i<end;i++)
   22996:	f340 8134 	ble.w	22c02 <quant_all_bands+0x65a>
   2299a:	3301      	adds	r3, #1
   2299c:	66bb      	str	r3, [r7, #104]	; 0x68
      X = X_+M*eBands[i];
   2299e:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
   229a2:	f932 3b02 	ldrsh.w	r3, [r2], #2
   229a6:	f8c7 20bc 	str.w	r2, [r7, #188]	; 0xbc
      if (Y_!=NULL)
   229aa:	f8d7 26fc 	ldr.w	r2, [r7, #1788]	; 0x6fc
      ctx.i = i;
   229ae:	f8c7 412c 	str.w	r4, [r7, #300]	; 0x12c
      X = X_+M*eBands[i];
   229b2:	fa03 f806 	lsl.w	r8, r3, r6
   229b6:	ea4f 0848 	mov.w	r8, r8, lsl #1
      if (Y_!=NULL)
   229ba:	2a00      	cmp	r2, #0
   229bc:	f000 80f1 	beq.w	22ba2 <quant_all_bands+0x5fa>
         Y = Y_+M*eBands[i];
   229c0:	4442      	add	r2, r8
   229c2:	f8c7 209c 	str.w	r2, [r7, #156]	; 0x9c
      N = M*eBands[i+1]-M*eBands[i];
   229c6:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
      tell = ec_tell_frac(ec);
   229ca:	f8d7 0728 	ldr.w	r0, [r7, #1832]	; 0x728
      N = M*eBands[i+1]-M*eBands[i];
   229ce:	f9b2 5000 	ldrsh.w	r5, [r2]
   229d2:	1aed      	subs	r5, r5, r3
      tell = ec_tell_frac(ec);
   229d4:	f006 feaa 	bl	2972c <ec_tell_frac>
      if (i != start)
   229d8:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
      tell = ec_tell_frac(ec);
   229da:	f8c7 0098 	str.w	r0, [r7, #152]	; 0x98
      if (i != start)
   229de:	42a3      	cmp	r3, r4
         balance -= tell;
   229e0:	bf1c      	itt	ne
   229e2:	4603      	movne	r3, r0
   229e4:	ebab 0b03 	subne.w	fp, fp, r3
      remaining_bits = total_bits-tell-1;
   229e8:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
   229ec:	f8d7 3720 	ldr.w	r3, [r7, #1824]	; 0x720
   229f0:	1a9a      	subs	r2, r3, r2
   229f2:	1e53      	subs	r3, r2, #1
      ctx.remaining_bits = remaining_bits;
   229f4:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
      if (i <= codedBands-1)
   229f8:	f8d7 3730 	ldr.w	r3, [r7, #1840]	; 0x730
   229fc:	42a3      	cmp	r3, r4
      N = M*eBands[i+1]-M*eBands[i];
   229fe:	fa05 f506 	lsl.w	r5, r5, r6
      if (i <= codedBands-1)
   22a02:	f73f aecf 	bgt.w	227a4 <quant_all_bands+0x1fc>
         b = 0;
   22a06:	2300      	movs	r3, #0
   22a08:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
      if (resynth && (M*eBands[i]-N >= M*eBands[start] || i==start+1) && (update_lowband || lowband_offset==0))
   22a0c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   22a0e:	2b00      	cmp	r3, #0
   22a10:	f47f aeeb 	bne.w	227ea <quant_all_bands+0x242>
      if (i == start+1)
   22a14:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   22a18:	42a3      	cmp	r3, r4
   22a1a:	f47f aef8 	bne.w	2280e <quant_all_bands+0x266>
   22a1e:	f000 bebd 	b.w	2379c <quant_all_bands+0x11f4>
   int theta_rdo = encode && Y_!=NULL && !dual_stereo && complexity>=8;
   22a22:	f8d7 3714 	ldr.w	r3, [r7, #1812]	; 0x714
   22a26:	2b00      	cmp	r3, #0
   22a28:	f040 8708 	bne.w	2383c <quant_all_bands+0x1294>
   22a2c:	f8d7 3738 	ldr.w	r3, [r7, #1848]	; 0x738
   22a30:	2b07      	cmp	r3, #7
   22a32:	f340 8715 	ble.w	23860 <quant_all_bands+0x12b8>
   22a36:	2301      	movs	r3, #1
   22a38:	643b      	str	r3, [r7, #64]	; 0x40
   int resynth = !encode || theta_rdo;
   22a3a:	67bb      	str	r3, [r7, #120]	; 0x78
   int C = Y_ != NULL ? 2 : 1;
   22a3c:	2302      	movs	r3, #2
   22a3e:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
   B = shortBlocks ? M : 1;
   22a42:	2c00      	cmp	r4, #0
   22a44:	f47f adcd 	bne.w	225e2 <quant_all_bands+0x3a>
   22a48:	2301      	movs	r3, #1
   22a4a:	46a4      	mov	ip, r4
   22a4c:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
   22a50:	e5d2      	b.n	225f8 <quant_all_bands+0x50>
      X = X_+M*eBands[i];
   22a52:	f8d7 26f8 	ldr.w	r2, [r7, #1784]	; 0x6f8
   22a56:	4442      	add	r2, r8
   22a58:	667a      	str	r2, [r7, #100]	; 0x64
   22a5a:	e6f3      	b.n	22844 <quant_all_bands+0x29c>
         effective_lowband = IMAX(0, M*eBands[lowband_offset]-norm_offset-N);
   22a5c:	6f7a      	ldr	r2, [r7, #116]	; 0x74
   22a5e:	f8d7 00b4 	ldr.w	r0, [r7, #180]	; 0xb4
   22a62:	f8d7 10a4 	ldr.w	r1, [r7, #164]	; 0xa4
   22a66:	f932 8010 	ldrsh.w	r8, [r2, r0, lsl #1]
   22a6a:	fa08 f806 	lsl.w	r8, r8, r6
   22a6e:	eba8 0801 	sub.w	r8, r8, r1
   22a72:	eba8 0805 	sub.w	r8, r8, r5
   22a76:	ea28 78e8 	bic.w	r8, r8, r8, asr #31
   22a7a:	ea4f 0c40 	mov.w	ip, r0, lsl #1
   22a7e:	eb01 0e08 	add.w	lr, r1, r8
   22a82:	eb02 010c 	add.w	r1, r2, ip
   22a86:	e000      	b.n	22a8a <quant_all_bands+0x4e2>
         while(M*eBands[--fold_start] > effective_lowband+norm_offset);
   22a88:	4618      	mov	r0, r3
   22a8a:	f931 2d02 	ldrsh.w	r2, [r1, #-2]!
   22a8e:	40b2      	lsls	r2, r6
   22a90:	4572      	cmp	r2, lr
   22a92:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   22a96:	dcf7      	bgt.n	22a88 <quant_all_bands+0x4e0>
   22a98:	6f7a      	ldr	r2, [r7, #116]	; 0x74
   22a9a:	f1ac 0c02 	sub.w	ip, ip, #2
   22a9e:	4494      	add	ip, r2
         fold_end = lowband_offset-1;
   22aa0:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
         while(++fold_end < i && M*eBands[fold_end] < effective_lowband+norm_offset+N);
   22aa4:	44ae      	add	lr, r5
         fold_end = lowband_offset-1;
   22aa6:	3a01      	subs	r2, #1
   22aa8:	e004      	b.n	22ab4 <quant_all_bands+0x50c>
         while(++fold_end < i && M*eBands[fold_end] < effective_lowband+norm_offset+N);
   22aaa:	f93c 1f02 	ldrsh.w	r1, [ip, #2]!
   22aae:	40b1      	lsls	r1, r6
   22ab0:	4571      	cmp	r1, lr
   22ab2:	da02      	bge.n	22aba <quant_all_bands+0x512>
   22ab4:	3201      	adds	r2, #1
   22ab6:	42a2      	cmp	r2, r4
   22ab8:	dbf7      	blt.n	22aaa <quant_all_bands+0x502>
   22aba:	f8d7 10b8 	ldr.w	r1, [r7, #184]	; 0xb8
         while(M*eBands[--fold_start] > effective_lowband+norm_offset);
   22abe:	647d      	str	r5, [r7, #68]	; 0x44
   22ac0:	fb00 f001 	mul.w	r0, r0, r1
   22ac4:	f8d7 1700 	ldr.w	r1, [r7, #1792]	; 0x700
   22ac8:	f8d7 50b8 	ldr.w	r5, [r7, #184]	; 0xb8
   22acc:	64bc      	str	r4, [r7, #72]	; 0x48
   22ace:	eb01 0900 	add.w	r9, r1, r0
   22ad2:	f8d7 10b8 	ldr.w	r1, [r7, #184]	; 0xb8
   22ad6:	f04f 0c00 	mov.w	ip, #0
   22ada:	1a41      	subs	r1, r0, r1
   22adc:	468a      	mov	sl, r1
   22ade:	46e6      	mov	lr, ip
   22ae0:	4649      	mov	r1, r9
           x_cm |= collapse_masks[fold_i*C+0];
   22ae2:	eba1 0900 	sub.w	r9, r1, r0
           y_cm |= collapse_masks[fold_i*C+C-1];
   22ae6:	f811 4c01 	ldrb.w	r4, [r1, #-1]
           x_cm |= collapse_masks[fold_i*C+0];
   22aea:	f819 900a 	ldrb.w	r9, [r9, sl]
           y_cm |= collapse_masks[fold_i*C+C-1];
   22aee:	3301      	adds	r3, #1
         } while (++fold_i<fold_end);
   22af0:	4293      	cmp	r3, r2
           x_cm |= collapse_masks[fold_i*C+0];
   22af2:	ea4e 0e09 	orr.w	lr, lr, r9
           y_cm |= collapse_masks[fold_i*C+C-1];
   22af6:	ea4c 0c04 	orr.w	ip, ip, r4
   22afa:	4429      	add	r1, r5
         } while (++fold_i<fold_end);
   22afc:	dbf1      	blt.n	22ae2 <quant_all_bands+0x53a>
      if (dual_stereo && i==intensity)
   22afe:	f8d7 3714 	ldr.w	r3, [r7, #1812]	; 0x714
   22b02:	e9d7 5411 	ldrd	r5, r4, [r7, #68]	; 0x44
   22b06:	2b00      	cmp	r3, #0
   22b08:	d05b      	beq.n	22bc2 <quant_all_bands+0x61a>
   22b0a:	f8d7 3718 	ldr.w	r3, [r7, #1816]	; 0x718
   22b0e:	42a3      	cmp	r3, r4
   22b10:	f000 8705 	beq.w	2391e <quant_all_bands+0x1376>
         x_cm = quant_band(&ctx, X, N, b/2, B,
   22b14:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
   22b18:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
   22b1c:	f8c7 c048 	str.w	ip, [r7, #72]	; 0x48
               effective_lowband != -1 ? norm+effective_lowband : NULL, LM,
   22b20:	ea4f 0948 	mov.w	r9, r8, lsl #1
   22b24:	4673      	mov	r3, lr
         x_cm = quant_band(&ctx, X, N, b/2, B,
   22b26:	444a      	add	r2, r9
   22b28:	ea4f 0a61 	mov.w	sl, r1, asr #1
   22b2c:	e6b5      	b.n	2289a <quant_all_bands+0x2f2>
         if (Y!=NULL)
   22b2e:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
   22b32:	2b00      	cmp	r3, #0
   22b34:	f000 867d 	beq.w	23832 <quant_all_bands+0x128a>
               ctx.theta_round = 0;
   22b38:	f8d7 3714 	ldr.w	r3, [r7, #1812]	; 0x714
         x_cm = y_cm = (1<<B)-1;
   22b3c:	f8d7 e058 	ldr.w	lr, [r7, #88]	; 0x58
               ctx.theta_round = 0;
   22b40:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
   22b44:	461a      	mov	r2, r3
         x_cm = y_cm = (1<<B)-1;
   22b46:	46f4      	mov	ip, lr
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
   22b48:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   22b4c:	42a3      	cmp	r3, r4
   22b4e:	f000 8717 	beq.w	23980 <quant_all_bands+0x13d8>
                     last?NULL:norm+M*eBands[i]-norm_offset, lowband_scratch, x_cm|y_cm);
   22b52:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
   22b56:	f8d7 10a4 	ldr.w	r1, [r7, #164]	; 0xa4
   22b5a:	f933 3c02 	ldrsh.w	r3, [r3, #-2]
   22b5e:	40b3      	lsls	r3, r6
   22b60:	1a5b      	subs	r3, r3, r1
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
   22b62:	f8d7 10b0 	ldr.w	r1, [r7, #176]	; 0xb0
   22b66:	eb01 0343 	add.w	r3, r1, r3, lsl #1
                     last?NULL:norm+M*eBands[i]-norm_offset, lowband_scratch, x_cm|y_cm);
   22b6a:	ea4c 010e 	orr.w	r1, ip, lr
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
   22b6e:	9106      	str	r1, [sp, #24]
   22b70:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
   22b74:	e9cd 3104 	strd	r3, r1, [sp, #16]
   22b78:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
   22b7c:	9301      	str	r3, [sp, #4]
   22b7e:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
   22b82:	9300      	str	r3, [sp, #0]
   22b84:	e9cd 2602 	strd	r2, r6, [sp, #8]
   22b88:	462b      	mov	r3, r5
   22b8a:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
   22b8e:	6e79      	ldr	r1, [r7, #100]	; 0x64
   22b90:	f507 7090 	add.w	r0, r7, #288	; 0x120
   22b94:	f7fe fc12 	bl	213bc <quant_band_stereo>
   22b98:	2300      	movs	r3, #0
   22b9a:	4604      	mov	r4, r0
   22b9c:	f8c7 3714 	str.w	r3, [r7, #1812]	; 0x714
   22ba0:	e6c9      	b.n	22936 <quant_all_bands+0x38e>
         Y = NULL;
   22ba2:	f8c7 209c 	str.w	r2, [r7, #156]	; 0x9c
   22ba6:	e70e      	b.n	229c6 <quant_all_bands+0x41e>
      if (resynth && (M*eBands[i]-N >= M*eBands[start] || i==start+1) && (update_lowband || lowband_offset==0))
   22ba8:	f1ba 0f00 	cmp.w	sl, #0
   22bac:	f000 85cc 	beq.w	23748 <quant_all_bands+0x11a0>
      if (i == start+1)
   22bb0:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
      if (resynth && (M*eBands[i]-N >= M*eBands[start] || i==start+1) && (update_lowband || lowband_offset==0))
   22bb4:	f8c7 40b4 	str.w	r4, [r7, #180]	; 0xb4
      if (i == start+1)
   22bb8:	42a3      	cmp	r3, r4
   22bba:	f47f ae28 	bne.w	2280e <quant_all_bands+0x266>
   22bbe:	f000 bded 	b.w	2379c <quant_all_bands+0x11f4>
         if (Y!=NULL)
   22bc2:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
   22bc6:	2b00      	cmp	r3, #0
   22bc8:	f000 855d 	beq.w	23686 <quant_all_bands+0x10de>
               ctx.theta_round = 0;
   22bcc:	2300      	movs	r3, #0
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
   22bce:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
               ctx.theta_round = 0;
   22bd2:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
   22bd6:	bf16      	itet	ne
   22bd8:	f8d7 30b0 	ldrne.w	r3, [r7, #176]	; 0xb0
   22bdc:	2200      	moveq	r2, #0
   22bde:	eb03 0248 	addne.w	r2, r3, r8, lsl #1
   22be2:	e7b1      	b.n	22b48 <quant_all_bands+0x5a0>
   if (d>256)
   22be4:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
      return -(opus_int32)celt_udiv(-n, d);
   22be8:	f1cb 0c00 	rsb	ip, fp, #0
   if (d>256)
   22bec:	f240 857d 	bls.w	236ea <quant_all_bands+0x1142>
      return n/d;
   22bf0:	fbbc f3f3 	udiv	r3, ip, r3
      return -(opus_int32)celt_udiv(-n, d);
   22bf4:	425b      	negs	r3, r3
   22bf6:	e5e4      	b.n	227c2 <quant_all_bands+0x21a>
   22bf8:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   22bfa:	429c      	cmp	r4, r3
   22bfc:	46a0      	mov	r8, r4
   22bfe:	f6ff ada5 	blt.w	2274c <quant_all_bands+0x1a4>
   22c02:	f8d7 4148 	ldr.w	r4, [r7, #328]	; 0x148
   }
   *seed = ctx.seed;
   22c06:	f8d7 3734 	ldr.w	r3, [r7, #1844]	; 0x734

   RESTORE_STACK;
}
   22c0a:	f207 67d4 	addw	r7, r7, #1748	; 0x6d4
   *seed = ctx.seed;
   22c0e:	601c      	str	r4, [r3, #0]
}
   22c10:	46bd      	mov	sp, r7
   22c12:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
         y_cm = quant_band(&ctx, Y, N, b/2, B,
   22c16:	2200      	movs	r2, #0
   22c18:	e66c      	b.n	228f4 <quant_all_bands+0x34c>
      t = EC_ILOG(d&-d);
   22c1a:	4259      	negs	r1, r3
   22c1c:	4019      	ands	r1, r3
   22c1e:	fab1 f181 	clz	r1, r1
   22c22:	f1c1 0120 	rsb	r1, r1, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   22c26:	fa23 fc01 	lsr.w	ip, r3, r1
   22c2a:	1e48      	subs	r0, r1, #1
   22c2c:	49d7      	ldr	r1, [pc, #860]	; (22f8c <quant_all_bands+0x9e4>)
   22c2e:	f851 102c 	ldr.w	r1, [r1, ip, lsl #2]
   22c32:	fa2b f000 	lsr.w	r0, fp, r0
   22c36:	fba0 0101 	umull	r0, r1, r0, r1
      return q+(n-q*d >= d);
   22c3a:	e9c7 0124 	strd	r0, r1, [r7, #144]	; 0x90
   22c3e:	fb03 b011 	mls	r0, r3, r1, fp
   22c42:	f8d7 1094 	ldr.w	r1, [r7, #148]	; 0x94
   22c46:	4298      	cmp	r0, r3
   22c48:	bf28      	it	cs
   22c4a:	3101      	addcs	r1, #1
   22c4c:	460b      	mov	r3, r1
   22c4e:	e5b8      	b.n	227c2 <quant_all_bands+0x21a>
   22c50:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   lowband_offset = 0;
   22c54:	f8c7 00b4 	str.w	r0, [r7, #180]	; 0xb4
   22c58:	f8d7 00b8 	ldr.w	r0, [r7, #184]	; 0xb8
   22c5c:	461d      	mov	r5, r3
   22c5e:	4603      	mov	r3, r0
   22c60:	fb05 f303 	mul.w	r3, r5, r3
   22c64:	4614      	mov	r4, r2
   22c66:	f8d7 571c 	ldr.w	r5, [r7, #1820]	; 0x71c
   22c6a:	64fb      	str	r3, [r7, #76]	; 0x4c
   22c6c:	0092      	lsls	r2, r2, #2
   22c6e:	1f11      	subs	r1, r2, #4
   22c70:	1869      	adds	r1, r5, r1
   22c72:	66b9      	str	r1, [r7, #104]	; 0x68
   22c74:	f8d7 1708 	ldr.w	r1, [r7, #1800]	; 0x708
   22c78:	188a      	adds	r2, r1, r2
   22c7a:	f8c7 2088 	str.w	r2, [r7, #136]	; 0x88
   22c7e:	f8d7 2700 	ldr.w	r2, [r7, #1792]	; 0x700
   22c82:	441a      	add	r2, r3
   22c84:	66fa      	str	r2, [r7, #108]	; 0x6c
   22c86:	f8d7 3718 	ldr.w	r3, [r7, #1816]	; 0x718
   22c8a:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
   22c8c:	4293      	cmp	r3, r2
   22c8e:	bfa8      	it	ge
   22c90:	4613      	movge	r3, r2
   22c92:	653b      	str	r3, [r7, #80]	; 0x50
   22c94:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   22c96:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
   22c9a:	f8d7 3730 	ldr.w	r3, [r7, #1840]	; 0x730
   22c9e:	1b1b      	subs	r3, r3, r4
   22ca0:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
   22ca4:	4623      	mov	r3, r4
   22ca6:	fb00 f303 	mul.w	r3, r0, r3
   22caa:	64bb      	str	r3, [r7, #72]	; 0x48
   22cac:	e0ef      	b.n	22e8e <quant_all_bands+0x8e6>
         curr_balance = celt_sudiv(balance, IMIN(3, codedBands-i));
   22cae:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
   if (n<0)
   22cb2:	f8d7 3724 	ldr.w	r3, [r7, #1828]	; 0x724
   22cb6:	2903      	cmp	r1, #3
   22cb8:	bfa8      	it	ge
   22cba:	2103      	movge	r1, #3
   22cbc:	2b00      	cmp	r3, #0
   22cbe:	f2c0 8475 	blt.w	235ac <quant_all_bands+0x1004>
   if (d>256)
   22cc2:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
   22cc6:	f240 847e 	bls.w	235c6 <quant_all_bands+0x101e>
      return n/d;
   22cca:	fbb3 f1f1 	udiv	r1, r3, r1
         b = IMAX(0, IMIN(16383, IMIN(remaining_bits+1,pulses[i]+curr_balance)));
   22cce:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
   22cd2:	681b      	ldr	r3, [r3, #0]
   22cd4:	4419      	add	r1, r3
   22cd6:	4288      	cmp	r0, r1
   22cd8:	4603      	mov	r3, r0
   22cda:	bfa8      	it	ge
   22cdc:	460b      	movge	r3, r1
   22cde:	f383 030e 	usat	r3, #14, r3
   22ce2:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
      if (resynth && (M*eBands[i]-N >= M*eBands[start] || i==start+1) && (update_lowband || lowband_offset==0))
   22ce6:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   22ce8:	2b00      	cmp	r3, #0
   22cea:	f000 810c 	beq.w	22f06 <quant_all_bands+0x95e>
   22cee:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
   22cf2:	6d7a      	ldr	r2, [r7, #84]	; 0x54
   22cf4:	f933 3c02 	ldrsh.w	r3, [r3, #-2]
   22cf8:	f9b2 2000 	ldrsh.w	r2, [r2]
   22cfc:	40b3      	lsls	r3, r6
   22cfe:	eba3 030b 	sub.w	r3, r3, fp
   22d02:	40b2      	lsls	r2, r6
   22d04:	4293      	cmp	r3, r2
   22d06:	f280 81e9 	bge.w	230dc <quant_all_bands+0xb34>
   22d0a:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   22d0e:	429c      	cmp	r4, r3
   22d10:	f000 8571 	beq.w	237f6 <quant_all_bands+0x124e>
      if (i>=m->effEBands)
   22d14:	6f3b      	ldr	r3, [r7, #112]	; 0x70
      tf_change = tf_res[i];
   22d16:	6eb9      	ldr	r1, [r7, #104]	; 0x68
      if (i>=m->effEBands)
   22d18:	68da      	ldr	r2, [r3, #12]
      tf_change = tf_res[i];
   22d1a:	f851 3f04 	ldr.w	r3, [r1, #4]!
   22d1e:	66b9      	str	r1, [r7, #104]	; 0x68
      if (i>=m->effEBands)
   22d20:	42a2      	cmp	r2, r4
      ctx.tf_change = tf_change;
   22d22:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
      if (i>=m->effEBands)
   22d26:	f340 811f 	ble.w	22f68 <quant_all_bands+0x9c0>
      X = X_+M*eBands[i];
   22d2a:	f8d7 26f8 	ldr.w	r2, [r7, #1784]	; 0x6f8
   22d2e:	442a      	add	r2, r5
   22d30:	667a      	str	r2, [r7, #100]	; 0x64
      if (last && !theta_rdo)
   22d32:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
   22d36:	4294      	cmp	r4, r2
   22d38:	f000 85a5 	beq.w	23886 <quant_all_bands+0x12de>
      if (lowband_offset != 0 && (spread!=SPREAD_AGGRESSIVE || B>1 || tf_change<0))
   22d3c:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
   22d40:	b162      	cbz	r2, 22d5c <quant_all_bands+0x7b4>
   22d42:	f8d7 2710 	ldr.w	r2, [r7, #1808]	; 0x710
   22d46:	2a03      	cmp	r2, #3
   22d48:	f040 8122 	bne.w	22f90 <quant_all_bands+0x9e8>
   22d4c:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
   22d50:	2a01      	cmp	r2, #1
   22d52:	f300 811d 	bgt.w	22f90 <quant_all_bands+0x9e8>
   22d56:	2b00      	cmp	r3, #0
   22d58:	f2c0 811a 	blt.w	22f90 <quant_all_bands+0x9e8>
      if (dual_stereo && i==intensity)
   22d5c:	f8d7 3714 	ldr.w	r3, [r7, #1812]	; 0x714
   22d60:	2b00      	cmp	r3, #0
   22d62:	f000 817a 	beq.w	2305a <quant_all_bands+0xab2>
   22d66:	f8d7 3718 	ldr.w	r3, [r7, #1816]	; 0x718
   22d6a:	429c      	cmp	r4, r3
   22d6c:	f000 85bb 	beq.w	238e6 <quant_all_bands+0x133e>
         x_cm = quant_band(&ctx, X, N, b/2, B,
   22d70:	6dba      	ldr	r2, [r7, #88]	; 0x58
   22d72:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
   22d76:	f8c7 208c 	str.w	r2, [r7, #140]	; 0x8c
   22d7a:	105d      	asrs	r5, r3, #1
   22d7c:	f06f 0a01 	mvn.w	sl, #1
   22d80:	4613      	mov	r3, r2
      int effective_lowband=-1;
   22d82:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
         x_cm = quant_band(&ctx, X, N, b/2, B,
   22d86:	2200      	movs	r2, #0
   22d88:	f8d7 10a8 	ldr.w	r1, [r7, #168]	; 0xa8
   22d8c:	428c      	cmp	r4, r1
   22d8e:	f000 858a 	beq.w	238a6 <quant_all_bands+0x12fe>
   22d92:	9306      	str	r3, [sp, #24]
   22d94:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
   22d98:	f647 71ff 	movw	r1, #32767	; 0x7fff
   22d9c:	e9cd 1304 	strd	r1, r3, [sp, #16]
               last?NULL:norm+M*eBands[i]-norm_offset, Q15ONE, lowband_scratch, x_cm);
   22da0:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
   22da4:	f8d7 10a4 	ldr.w	r1, [r7, #164]	; 0xa4
   22da8:	f933 3c02 	ldrsh.w	r3, [r3, #-2]
         x_cm = quant_band(&ctx, X, N, b/2, B,
   22dac:	9201      	str	r2, [sp, #4]
               last?NULL:norm+M*eBands[i]-norm_offset, Q15ONE, lowband_scratch, x_cm);
   22dae:	40b3      	lsls	r3, r6
   22db0:	1a5b      	subs	r3, r3, r1
         x_cm = quant_band(&ctx, X, N, b/2, B,
   22db2:	f8d7 10b0 	ldr.w	r1, [r7, #176]	; 0xb0
   22db6:	9602      	str	r6, [sp, #8]
   22db8:	eb01 0343 	add.w	r3, r1, r3, lsl #1
   22dbc:	9303      	str	r3, [sp, #12]
   22dbe:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
   22dc2:	9300      	str	r3, [sp, #0]
   22dc4:	6e79      	ldr	r1, [r7, #100]	; 0x64
   22dc6:	462b      	mov	r3, r5
   22dc8:	465a      	mov	r2, fp
   22dca:	f507 7090 	add.w	r0, r7, #288	; 0x120
   22dce:	f7fd fe69 	bl	20aa4 <quant_band>
         y_cm = quant_band(&ctx, Y, N, b/2, B,
   22dd2:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
         x_cm = quant_band(&ctx, X, N, b/2, B,
   22dd6:	4681      	mov	r9, r0
         y_cm = quant_band(&ctx, Y, N, b/2, B,
   22dd8:	f000 83f3 	beq.w	235c2 <quant_all_bands+0x101a>
   22ddc:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   22dde:	eb03 020a 	add.w	r2, r3, sl
               last?NULL:norm2+M*eBands[i]-norm_offset, Q15ONE, lowband_scratch, y_cm);
   22de2:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
   22de6:	f8d7 10a4 	ldr.w	r1, [r7, #164]	; 0xa4
   22dea:	f933 3c02 	ldrsh.w	r3, [r3, #-2]
   22dee:	40b3      	lsls	r3, r6
   22df0:	1a5b      	subs	r3, r3, r1
         y_cm = quant_band(&ctx, Y, N, b/2, B,
   22df2:	6e39      	ldr	r1, [r7, #96]	; 0x60
   22df4:	eb01 0343 	add.w	r3, r1, r3, lsl #1
   22df8:	f8d7 108c 	ldr.w	r1, [r7, #140]	; 0x8c
   22dfc:	9106      	str	r1, [sp, #24]
   22dfe:	f647 70ff 	movw	r0, #32767	; 0x7fff
   22e02:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
   22e06:	9105      	str	r1, [sp, #20]
   22e08:	e9cd 6302 	strd	r6, r3, [sp, #8]
   22e0c:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
   22e10:	9201      	str	r2, [sp, #4]
   22e12:	9300      	str	r3, [sp, #0]
   22e14:	9004      	str	r0, [sp, #16]
   22e16:	462b      	mov	r3, r5
   22e18:	f8d7 109c 	ldr.w	r1, [r7, #156]	; 0x9c
   22e1c:	465a      	mov	r2, fp
   22e1e:	f507 7090 	add.w	r0, r7, #288	; 0x120
   22e22:	f7fd fe3f 	bl	20aa4 <quant_band>
      collapse_masks[i*C+0] = (unsigned char)x_cm;
   22e26:	6efa      	ldr	r2, [r7, #108]	; 0x6c
      update_lowband = b>(N<<BITRES);
   22e28:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
      collapse_masks[i*C+0] = (unsigned char)x_cm;
   22e2c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
      update_lowband = b>(N<<BITRES);
   22e2e:	ebb1 0fcb 	cmp.w	r1, fp, lsl #3
      collapse_masks[i*C+0] = (unsigned char)x_cm;
   22e32:	eba2 0303 	sub.w	r3, r2, r3
   22e36:	6cb9      	ldr	r1, [r7, #72]	; 0x48
   22e38:	f803 9001 	strb.w	r9, [r3, r1]
      balance += pulses[i] + tell;
   22e3c:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
      collapse_masks[i*C+C-1] = (unsigned char)y_cm;
   22e40:	f802 0c01 	strb.w	r0, [r2, #-1]
      balance += pulses[i] + tell;
   22e44:	f851 3b04 	ldr.w	r3, [r1], #4
   22e48:	f8c7 1088 	str.w	r1, [r7, #136]	; 0x88
      ctx.avoid_split_noise = 0;
   22e4c:	f04f 0100 	mov.w	r1, #0
   22e50:	f8c7 1158 	str.w	r1, [r7, #344]	; 0x158
      balance += pulses[i] + tell;
   22e54:	f8d7 1098 	ldr.w	r1, [r7, #152]	; 0x98
   22e58:	440b      	add	r3, r1
   22e5a:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
   22e5e:	f101 31ff 	add.w	r1, r1, #4294967295	; 0xffffffff
   22e62:	f8c7 1084 	str.w	r1, [r7, #132]	; 0x84
   22e66:	f8d7 10b8 	ldr.w	r1, [r7, #184]	; 0xb8
   22e6a:	440a      	add	r2, r1
   22e6c:	66fa      	str	r2, [r7, #108]	; 0x6c
   22e6e:	f8d7 2724 	ldr.w	r2, [r7, #1828]	; 0x724
   22e72:	441a      	add	r2, r3
   for (i=start;i<end;i++)
   22e74:	6d3b      	ldr	r3, [r7, #80]	; 0x50
      balance += pulses[i] + tell;
   22e76:	f8c7 2724 	str.w	r2, [r7, #1828]	; 0x724
      collapse_masks[i*C+C-1] = (unsigned char)y_cm;
   22e7a:	f104 0401 	add.w	r4, r4, #1
      update_lowband = b>(N<<BITRES);
   22e7e:	bfcc      	ite	gt
   22e80:	f04f 0a01 	movgt.w	sl, #1
   22e84:	f04f 0a00 	movle.w	sl, #0
   for (i=start;i<end;i++)
   22e88:	42a3      	cmp	r3, r4
   22e8a:	f77f aeb5 	ble.w	22bf8 <quant_all_bands+0x650>
      X = X_+M*eBands[i];
   22e8e:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
   22e92:	f933 2b02 	ldrsh.w	r2, [r3], #2
   22e96:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
      if (Y_!=NULL)
   22e9a:	f8d7 36fc 	ldr.w	r3, [r7, #1788]	; 0x6fc
      ctx.i = i;
   22e9e:	f8c7 412c 	str.w	r4, [r7, #300]	; 0x12c
      X = X_+M*eBands[i];
   22ea2:	fa02 f506 	lsl.w	r5, r2, r6
   22ea6:	006d      	lsls	r5, r5, #1
      if (Y_!=NULL)
   22ea8:	2b00      	cmp	r3, #0
   22eaa:	f000 8114 	beq.w	230d6 <quant_all_bands+0xb2e>
         Y = Y_+M*eBands[i];
   22eae:	442b      	add	r3, r5
   22eb0:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
      N = M*eBands[i+1]-M*eBands[i];
   22eb4:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
      tell = ec_tell_frac(ec);
   22eb8:	f8d7 0728 	ldr.w	r0, [r7, #1832]	; 0x728
      N = M*eBands[i+1]-M*eBands[i];
   22ebc:	f9b3 3000 	ldrsh.w	r3, [r3]
   22ec0:	1a9b      	subs	r3, r3, r2
   22ec2:	fa03 fb06 	lsl.w	fp, r3, r6
      tell = ec_tell_frac(ec);
   22ec6:	f006 fc31 	bl	2972c <ec_tell_frac>
      if (i != start)
   22eca:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
      tell = ec_tell_frac(ec);
   22ecc:	f8c7 0098 	str.w	r0, [r7, #152]	; 0x98
      if (i != start)
   22ed0:	429c      	cmp	r4, r3
   22ed2:	d004      	beq.n	22ede <quant_all_bands+0x936>
         balance -= tell;
   22ed4:	f8d7 3724 	ldr.w	r3, [r7, #1828]	; 0x724
   22ed8:	1a1b      	subs	r3, r3, r0
   22eda:	f8c7 3724 	str.w	r3, [r7, #1828]	; 0x724
      remaining_bits = total_bits-tell-1;
   22ede:	f8d7 3720 	ldr.w	r3, [r7, #1824]	; 0x720
   22ee2:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
   22ee6:	1a98      	subs	r0, r3, r2
   22ee8:	1e43      	subs	r3, r0, #1
      ctx.remaining_bits = remaining_bits;
   22eea:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
      if (i <= codedBands-1)
   22eee:	f8d7 3730 	ldr.w	r3, [r7, #1840]	; 0x730
   22ef2:	429c      	cmp	r4, r3
   22ef4:	f6ff aedb 	blt.w	22cae <quant_all_bands+0x706>
         b = 0;
   22ef8:	2300      	movs	r3, #0
   22efa:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
      if (resynth && (M*eBands[i]-N >= M*eBands[start] || i==start+1) && (update_lowband || lowband_offset==0))
   22efe:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   22f00:	2b00      	cmp	r3, #0
   22f02:	f47f aef4 	bne.w	22cee <quant_all_bands+0x746>
      if (i == start+1)
   22f06:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   22f0a:	429c      	cmp	r4, r3
   22f0c:	f47f af02 	bne.w	22d14 <quant_all_bands+0x76c>
         special_hybrid_folding(m, norm, norm2, start, M, dual_stereo);
   22f10:	6f3b      	ldr	r3, [r7, #112]	; 0x70
   n2 = M*(eBands[start+2]-eBands[start+1]);
   22f12:	6a38      	ldr	r0, [r7, #32]
         special_hybrid_folding(m, norm, norm2, start, M, dual_stereo);
   22f14:	699a      	ldr	r2, [r3, #24]
   n1 = M*(eBands[start+1]-eBands[start]);
   22f16:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   22f18:	5ed1      	ldrsh	r1, [r2, r3]
   22f1a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   22f1c:	5ed3      	ldrsh	r3, [r2, r3]
   n2 = M*(eBands[start+2]-eBands[start+1]);
   22f1e:	5e12      	ldrsh	r2, [r2, r0]
   n1 = M*(eBands[start+1]-eBands[start]);
   22f20:	1acb      	subs	r3, r1, r3
   n2 = M*(eBands[start+2]-eBands[start+1]);
   22f22:	1a52      	subs	r2, r2, r1
   n1 = M*(eBands[start+1]-eBands[start]);
   22f24:	40b3      	lsls	r3, r6
   n2 = M*(eBands[start+2]-eBands[start+1]);
   22f26:	40b2      	lsls	r2, r6
   OPUS_COPY(&norm[n1], &norm[2*n1 - n2], n2-n1);
   22f28:	ea4f 0943 	mov.w	r9, r3, lsl #1
   22f2c:	1ad3      	subs	r3, r2, r3
   22f2e:	ea4f 0843 	mov.w	r8, r3, lsl #1
   22f32:	eba9 0202 	sub.w	r2, r9, r2
   22f36:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
   22f3a:	ea4f 0a42 	mov.w	sl, r2, lsl #1
   22f3e:	eb03 010a 	add.w	r1, r3, sl
   22f42:	eb03 0009 	add.w	r0, r3, r9
   22f46:	4642      	mov	r2, r8
   22f48:	f7e9 f8da 	bl	c100 <memcpy>
   if (dual_stereo)
   22f4c:	f8d7 3714 	ldr.w	r3, [r7, #1812]	; 0x714
   22f50:	2b00      	cmp	r3, #0
   22f52:	f43f aedf 	beq.w	22d14 <quant_all_bands+0x76c>
      OPUS_COPY(&norm2[n1], &norm2[2*n1 - n2], n2-n1);
   22f56:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   22f58:	4642      	mov	r2, r8
   22f5a:	eb03 010a 	add.w	r1, r3, sl
   22f5e:	eb03 0009 	add.w	r0, r3, r9
   22f62:	f7e9 f8cd 	bl	c100 <memcpy>
   22f66:	e6d5      	b.n	22d14 <quant_all_bands+0x76c>
            Y = norm;
   22f68:	f8d7 109c 	ldr.w	r1, [r7, #156]	; 0x9c
   22f6c:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
   22f70:	f8d7 06fc 	ldr.w	r0, [r7, #1788]	; 0x6fc
   22f74:	667a      	str	r2, [r7, #100]	; 0x64
   22f76:	460d      	mov	r5, r1
   22f78:	2800      	cmp	r0, #0
   22f7a:	bf18      	it	ne
   22f7c:	4615      	movne	r5, r2
   22f7e:	2200      	movs	r2, #0
   22f80:	f8c7 509c 	str.w	r5, [r7, #156]	; 0x9c
   22f84:	f8c7 20ac 	str.w	r2, [r7, #172]	; 0xac
   22f88:	e6d3      	b.n	22d32 <quant_all_bands+0x78a>
   22f8a:	bf00      	nop
   22f8c:	00038e98 	.word	0x00038e98
         effective_lowband = IMAX(0, M*eBands[lowband_offset]-norm_offset-N);
   22f90:	6f7a      	ldr	r2, [r7, #116]	; 0x74
   22f92:	f8d7 00b4 	ldr.w	r0, [r7, #180]	; 0xb4
   22f96:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
   22f9a:	f932 8010 	ldrsh.w	r8, [r2, r0, lsl #1]
   22f9e:	fa08 f806 	lsl.w	r8, r8, r6
   22fa2:	eba8 0803 	sub.w	r8, r8, r3
   22fa6:	eba8 080b 	sub.w	r8, r8, fp
   22faa:	ea28 78e8 	bic.w	r8, r8, r8, asr #31
   22fae:	0041      	lsls	r1, r0, #1
   22fb0:	eb03 0508 	add.w	r5, r3, r8
   22fb4:	eb02 0c01 	add.w	ip, r2, r1
         while(M*eBands[--fold_start] > effective_lowband+norm_offset);
   22fb8:	e000      	b.n	22fbc <quant_all_bands+0xa14>
   22fba:	4618      	mov	r0, r3
   22fbc:	f93c 2d02 	ldrsh.w	r2, [ip, #-2]!
   22fc0:	40b2      	lsls	r2, r6
   22fc2:	42aa      	cmp	r2, r5
   22fc4:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   22fc8:	dcf7      	bgt.n	22fba <quant_all_bands+0xa12>
   22fca:	6f7a      	ldr	r2, [r7, #116]	; 0x74
   22fcc:	3902      	subs	r1, #2
   22fce:	4411      	add	r1, r2
         fold_end = lowband_offset-1;
   22fd0:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
         while(++fold_end < i && M*eBands[fold_end] < effective_lowband+norm_offset+N);
   22fd4:	445d      	add	r5, fp
         fold_end = lowband_offset-1;
   22fd6:	3a01      	subs	r2, #1
         while(++fold_end < i && M*eBands[fold_end] < effective_lowband+norm_offset+N);
   22fd8:	e005      	b.n	22fe6 <quant_all_bands+0xa3e>
   22fda:	f931 cf02 	ldrsh.w	ip, [r1, #2]!
   22fde:	fa0c fc06 	lsl.w	ip, ip, r6
   22fe2:	45ac      	cmp	ip, r5
   22fe4:	da02      	bge.n	22fec <quant_all_bands+0xa44>
   22fe6:	3201      	adds	r2, #1
   22fe8:	4294      	cmp	r4, r2
   22fea:	dcf6      	bgt.n	22fda <quant_all_bands+0xa32>
   22fec:	f8d7 50b8 	ldr.w	r5, [r7, #184]	; 0xb8
         while(M*eBands[--fold_start] > effective_lowband+norm_offset);
   22ff0:	647c      	str	r4, [r7, #68]	; 0x44
   22ff2:	2100      	movs	r1, #0
   22ff4:	f8c7 108c 	str.w	r1, [r7, #140]	; 0x8c
   22ff8:	f8d7 1700 	ldr.w	r1, [r7, #1792]	; 0x700
   22ffc:	fb05 f000 	mul.w	r0, r5, r0
   23000:	eb01 0e00 	add.w	lr, r1, r0
   23004:	eba0 0a05 	sub.w	sl, r0, r5
   23008:	4629      	mov	r1, r5
   2300a:	2500      	movs	r5, #0
   2300c:	460c      	mov	r4, r1
   2300e:	46ac      	mov	ip, r5
   23010:	4671      	mov	r1, lr
           x_cm |= collapse_masks[fold_i*C+0];
   23012:	eba1 0900 	sub.w	r9, r1, r0
           y_cm |= collapse_masks[fold_i*C+C-1];
   23016:	f811 ec01 	ldrb.w	lr, [r1, #-1]
           x_cm |= collapse_masks[fold_i*C+0];
   2301a:	f819 900a 	ldrb.w	r9, [r9, sl]
           y_cm |= collapse_masks[fold_i*C+C-1];
   2301e:	3301      	adds	r3, #1
         } while (++fold_i<fold_end);
   23020:	4293      	cmp	r3, r2
           x_cm |= collapse_masks[fold_i*C+0];
   23022:	ea4c 0c09 	orr.w	ip, ip, r9
           y_cm |= collapse_masks[fold_i*C+C-1];
   23026:	ea45 050e 	orr.w	r5, r5, lr
   2302a:	4421      	add	r1, r4
         } while (++fold_i<fold_end);
   2302c:	dbf1      	blt.n	23012 <quant_all_bands+0xa6a>
      if (dual_stereo && i==intensity)
   2302e:	f8d7 3714 	ldr.w	r3, [r7, #1812]	; 0x714
   23032:	f8c7 508c 	str.w	r5, [r7, #140]	; 0x8c
   23036:	6c7c      	ldr	r4, [r7, #68]	; 0x44
   23038:	2b00      	cmp	r3, #0
   2303a:	d05b      	beq.n	230f4 <quant_all_bands+0xb4c>
   2303c:	f8d7 3718 	ldr.w	r3, [r7, #1816]	; 0x718
   23040:	429c      	cmp	r4, r3
   23042:	f000 8456 	beq.w	238f2 <quant_all_bands+0x134a>
         x_cm = quant_band(&ctx, X, N, b/2, B,
   23046:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
   2304a:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
               effective_lowband != -1 ? norm+effective_lowband : NULL, LM,
   2304e:	ea4f 0a48 	mov.w	sl, r8, lsl #1
   23052:	4663      	mov	r3, ip
         x_cm = quant_band(&ctx, X, N, b/2, B,
   23054:	4452      	add	r2, sl
   23056:	104d      	asrs	r5, r1, #1
   23058:	e696      	b.n	22d88 <quant_all_bands+0x7e0>
         if (Y!=NULL)
   2305a:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
   2305e:	2b00      	cmp	r3, #0
   23060:	f000 83e1 	beq.w	23826 <quant_all_bands+0x127e>
            if (theta_rdo && i < intensity)
   23064:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   23066:	2a00      	cmp	r2, #0
   23068:	f040 82d1 	bne.w	2360e <quant_all_bands+0x1066>
         x_cm = y_cm = (1<<B)-1;
   2306c:	f8d7 c058 	ldr.w	ip, [r7, #88]	; 0x58
               ctx.theta_round = 0;
   23070:	f8c7 2150 	str.w	r2, [r7, #336]	; 0x150
         x_cm = y_cm = (1<<B)-1;
   23074:	f8c7 c08c 	str.w	ip, [r7, #140]	; 0x8c
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
   23078:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   2307c:	429c      	cmp	r4, r3
   2307e:	f000 8482 	beq.w	23986 <quant_all_bands+0x13de>
                     last?NULL:norm+M*eBands[i]-norm_offset, lowband_scratch, x_cm|y_cm);
   23082:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
   23086:	f8d7 10a4 	ldr.w	r1, [r7, #164]	; 0xa4
   2308a:	f933 3c02 	ldrsh.w	r3, [r3, #-2]
   2308e:	40b3      	lsls	r3, r6
   23090:	1a5b      	subs	r3, r3, r1
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
   23092:	f8d7 10b0 	ldr.w	r1, [r7, #176]	; 0xb0
   23096:	eb01 0343 	add.w	r3, r1, r3, lsl #1
                     last?NULL:norm+M*eBands[i]-norm_offset, lowband_scratch, x_cm|y_cm);
   2309a:	f8d7 108c 	ldr.w	r1, [r7, #140]	; 0x8c
   2309e:	ea41 050c 	orr.w	r5, r1, ip
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
   230a2:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
   230a6:	9506      	str	r5, [sp, #24]
   230a8:	e9cd 3104 	strd	r3, r1, [sp, #16]
   230ac:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
   230b0:	9301      	str	r3, [sp, #4]
   230b2:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
   230b6:	9300      	str	r3, [sp, #0]
   230b8:	e9cd 2602 	strd	r2, r6, [sp, #8]
   230bc:	465b      	mov	r3, fp
   230be:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
   230c2:	6e79      	ldr	r1, [r7, #100]	; 0x64
   230c4:	f507 7090 	add.w	r0, r7, #288	; 0x120
   230c8:	f7fe f978 	bl	213bc <quant_band_stereo>
   230cc:	2300      	movs	r3, #0
   230ce:	4681      	mov	r9, r0
   230d0:	f8c7 3714 	str.w	r3, [r7, #1812]	; 0x714
   230d4:	e6a7      	b.n	22e26 <quant_all_bands+0x87e>
         Y = NULL;
   230d6:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
   230da:	e6eb      	b.n	22eb4 <quant_all_bands+0x90c>
      if (resynth && (M*eBands[i]-N >= M*eBands[start] || i==start+1) && (update_lowband || lowband_offset==0))
   230dc:	f1ba 0f00 	cmp.w	sl, #0
   230e0:	f000 8340 	beq.w	23764 <quant_all_bands+0x11bc>
      if (i == start+1)
   230e4:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   230e8:	f8c7 40b4 	str.w	r4, [r7, #180]	; 0xb4
   230ec:	429c      	cmp	r4, r3
   230ee:	f47f ae11 	bne.w	22d14 <quant_all_bands+0x76c>
   230f2:	e70d      	b.n	22f10 <quant_all_bands+0x968>
         if (Y!=NULL)
   230f4:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
   230f8:	2b00      	cmp	r3, #0
   230fa:	f000 828f 	beq.w	2361c <quant_all_bands+0x1074>
            if (theta_rdo && i < intensity)
   230fe:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   23100:	2b00      	cmp	r3, #0
   23102:	f000 8248 	beq.w	23596 <quant_all_bands+0xfee>
               compute_channel_weights(bandE[i], bandE[i+m->nbEBands], w);
   23106:	6f3b      	ldr	r3, [r7, #112]	; 0x70
   23108:	f8d7 2704 	ldr.w	r2, [r7, #1796]	; 0x704
   2310c:	689b      	ldr	r3, [r3, #8]
   2310e:	f8d7 1704 	ldr.w	r1, [r7, #1796]	; 0x704
   23112:	f852 2024 	ldr.w	r2, [r2, r4, lsl #2]
   23116:	4423      	add	r3, r4
   minE = MIN32(Ex, Ey);
   23118:	4610      	mov	r0, r2
               compute_channel_weights(bandE[i], bandE[i+m->nbEBands], w);
   2311a:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
   Ex = ADD32(Ex, minE/3);
   2311e:	4bb4      	ldr	r3, [pc, #720]	; (233f0 <quant_all_bands+0xe48>)
   minE = MIN32(Ex, Ey);
   23120:	428a      	cmp	r2, r1
   23122:	bfa8      	it	ge
   23124:	4608      	movge	r0, r1
   Ex = ADD32(Ex, minE/3);
   23126:	fb83 5300 	smull	r5, r3, r3, r0
   2312a:	eba3 73e0 	sub.w	r3, r3, r0, asr #31
   Ey = ADD32(Ey, minE/3);
   2312e:	4419      	add	r1, r3
   Ex = ADD32(Ex, minE/3);
   23130:	441a      	add	r2, r3
   shift = celt_ilog2(EPSILON+MAX32(Ex, Ey))-14;
   23132:	428a      	cmp	r2, r1
   23134:	4613      	mov	r3, r2
   23136:	bfb8      	it	lt
   23138:	460b      	movlt	r3, r1
   2313a:	3301      	adds	r3, #1
   return EC_ILOG(x)-1;
   2313c:	fab3 f383 	clz	r3, r3
   23140:	f1c3 031f 	rsb	r3, r3, #31
   23144:	f1a3 000e 	sub.w	r0, r3, #14
   w[0] = VSHR32(Ex, shift);
   23148:	2800      	cmp	r0, #0
   2314a:	f340 837f 	ble.w	2384c <quant_all_bands+0x12a4>
   2314e:	4102      	asrs	r2, r0
   23150:	b213      	sxth	r3, r2
   w[1] = VSHR32(Ey, shift);
   23152:	4101      	asrs	r1, r0
   w[0] = VSHR32(Ex, shift);
   23154:	647b      	str	r3, [r7, #68]	; 0x44
   w[1] = VSHR32(Ey, shift);
   23156:	b20b      	sxth	r3, r1
   23158:	61fb      	str	r3, [r7, #28]
               ec_save = *ec;
   2315a:	f8d7 9728 	ldr.w	r9, [r7, #1832]	; 0x728
   2315e:	f8d7 5728 	ldr.w	r5, [r7, #1832]	; 0x728
   23162:	e8b9 000f 	ldmia.w	r9!, {r0, r1, r2, r3}
   23166:	f107 0ec0 	add.w	lr, r7, #192	; 0xc0
   2316a:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
   2316e:	e8b9 000f 	ldmia.w	r9!, {r0, r1, r2, r3}
   23172:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
   23176:	e899 000f 	ldmia.w	r9, {r0, r1, r2, r3}
               ctx_save = ctx;
   2317a:	f507 7990 	add.w	r9, r7, #288	; 0x120
               ec_save = *ec;
   2317e:	e88e 000f 	stmia.w	lr, {r0, r1, r2, r3}
               ctx_save = ctx;
   23182:	e8b9 000f 	ldmia.w	r9!, {r0, r1, r2, r3}
               ec_save = *ec;
   23186:	682d      	ldr	r5, [r5, #0]
   23188:	617d      	str	r5, [r7, #20]
               ctx_save = ctx;
   2318a:	f507 7eae 	add.w	lr, r7, #348	; 0x15c
               ec_save = *ec;
   2318e:	f8d7 5728 	ldr.w	r5, [r7, #1832]	; 0x728
               ctx_save = ctx;
   23192:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
   23196:	e8b9 000f 	ldmia.w	r9!, {r0, r1, r2, r3}
   2319a:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
   2319e:	e8b9 000f 	ldmia.w	r9!, {r0, r1, r2, r3}
   231a2:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
               ec_save = *ec;
   231a6:	686d      	ldr	r5, [r5, #4]
   231a8:	613d      	str	r5, [r7, #16]
               ctx_save = ctx;
   231aa:	e899 0007 	ldmia.w	r9, {r0, r1, r2}
               ec_save = *ec;
   231ae:	f8d7 5728 	ldr.w	r5, [r7, #1832]	; 0x728
   231b2:	69ad      	ldr	r5, [r5, #24]
   231b4:	60fd      	str	r5, [r7, #12]
               ctx_save = ctx;
   231b6:	e88e 0007 	stmia.w	lr, {r0, r1, r2}
               OPUS_COPY(X_save, X, N);
   231ba:	6e79      	ldr	r1, [r7, #100]	; 0x64
               cm = x_cm|y_cm;
   231bc:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
               OPUS_COPY(X_save, X, N);
   231c0:	6bb8      	ldr	r0, [r7, #56]	; 0x38
   231c2:	ea4f 0a4b 	mov.w	sl, fp, lsl #1
               cm = x_cm|y_cm;
   231c6:	ea43 030c 	orr.w	r3, r3, ip
               OPUS_COPY(X_save, X, N);
   231ca:	4652      	mov	r2, sl
               cm = x_cm|y_cm;
   231cc:	61bb      	str	r3, [r7, #24]
               OPUS_COPY(X_save, X, N);
   231ce:	f7e8 ff97 	bl	c100 <memcpy>
               OPUS_COPY(Y_save, Y, N);
   231d2:	4652      	mov	r2, sl
   231d4:	f8d7 109c 	ldr.w	r1, [r7, #156]	; 0x9c
   231d8:	6b78      	ldr	r0, [r7, #52]	; 0x34
   231da:	f7e8 ff91 	bl	c100 <memcpy>
               ctx.theta_round = -1;
   231de:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
   231e2:	4598      	cmp	r8, r3
               ctx.theta_round = -1;
   231e4:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
   231e8:	bf16      	itet	ne
   231ea:	f8d7 30b0 	ldrne.w	r3, [r7, #176]	; 0xb0
   231ee:	2300      	moveq	r3, #0
   231f0:	eb03 0348 	addne.w	r3, r3, r8, lsl #1
   231f4:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
   231f8:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   231fc:	429c      	cmp	r4, r3
   231fe:	f000 8412 	beq.w	23a26 <quant_all_bands+0x147e>
                     last?NULL:norm+M*eBands[i]-norm_offset, lowband_scratch, cm);
   23202:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
   23206:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
   2320a:	f933 3c02 	ldrsh.w	r3, [r3, #-2]
   2320e:	40b3      	lsls	r3, r6
   23210:	1a9b      	subs	r3, r3, r2
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
   23212:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
   23216:	eb02 0343 	add.w	r3, r2, r3, lsl #1
   2321a:	69ba      	ldr	r2, [r7, #24]
   2321c:	9206      	str	r2, [sp, #24]
   2321e:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
   23222:	6e7d      	ldr	r5, [r7, #100]	; 0x64
   23224:	9603      	str	r6, [sp, #12]
   23226:	e9cd 3204 	strd	r3, r2, [sp, #16]
   2322a:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
   2322e:	9302      	str	r3, [sp, #8]
   23230:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
   23234:	9301      	str	r3, [sp, #4]
   23236:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
   2323a:	9300      	str	r3, [sp, #0]
   2323c:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
   23240:	465b      	mov	r3, fp
   23242:	4629      	mov	r1, r5
   23244:	f507 7090 	add.w	r0, r7, #288	; 0x120
   23248:	f7fe f8b8 	bl	213bc <quant_band_stereo>
   for (i=0;i<N;i++)
   2324c:	f1bb 0f00 	cmp.w	fp, #0
   23250:	6078      	str	r0, [r7, #4]
   23252:	f340 8325 	ble.w	238a0 <quant_all_bands+0x12f8>
   23256:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   23258:	1ea8      	subs	r0, r5, #2
   2325a:	1e9a      	subs	r2, r3, #2
   2325c:	eb02 080a 	add.w	r8, r2, sl
   23260:	4613      	mov	r3, r2
   23262:	4605      	mov	r5, r0
   opus_val32 xy=0;
   23264:	2100      	movs	r1, #0
      xy = MAC16_16(xy, x[i], y[i]);
   23266:	f833 ef02 	ldrh.w	lr, [r3, #2]!
   2326a:	f835 cf02 	ldrh.w	ip, [r5, #2]!
   for (i=0;i<N;i++)
   2326e:	4543      	cmp	r3, r8
      xy = MAC16_16(xy, x[i], y[i]);
   23270:	fb1e 110c 	smlabb	r1, lr, ip, r1
   for (i=0;i<N;i++)
   23274:	d1f7      	bne.n	23266 <quant_all_bands+0xcbe>
               dist0 = MULT16_32_Q15(w[0], celt_inner_prod(X_save, X, N, arch)) + MULT16_32_Q15(w[1], celt_inner_prod(Y_save, Y, N, arch));
   23276:	ea4f 4e21 	mov.w	lr, r1, asr #16
   2327a:	6c79      	ldr	r1, [r7, #68]	; 0x44
   2327c:	fb01 fe0e 	mul.w	lr, r1, lr
   23280:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
   opus_val32 xy=0;
   23284:	2100      	movs	r1, #0
      xy = MAC16_16(xy, x[i], y[i]);
   23286:	f832 cf02 	ldrh.w	ip, [r2, #2]!
   2328a:	f830 5f02 	ldrh.w	r5, [r0, #2]!
   for (i=0;i<N;i++)
   2328e:	4293      	cmp	r3, r2
      xy = MAC16_16(xy, x[i], y[i]);
   23290:	fb1c 1105 	smlabb	r1, ip, r5, r1
   for (i=0;i<N;i++)
   23294:	d1f7      	bne.n	23286 <quant_all_bands+0xcde>
   23296:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   23298:	fa1f f981 	uxth.w	r9, r1
   2329c:	fb03 f909 	mul.w	r9, r3, r9
   232a0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   232a2:	1e9a      	subs	r2, r3, #2
   232a4:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
   232a8:	1e98      	subs	r0, r3, #2
   232aa:	eb0e 39e9 	add.w	r9, lr, r9, asr #15
   232ae:	eb02 080a 	add.w	r8, r2, sl
   232b2:	4613      	mov	r3, r2
   232b4:	4605      	mov	r5, r0
   232b6:	2100      	movs	r1, #0
      xy = MAC16_16(xy, x[i], y[i]);
   232b8:	f833 ef02 	ldrh.w	lr, [r3, #2]!
   232bc:	f835 cf02 	ldrh.w	ip, [r5, #2]!
   for (i=0;i<N;i++)
   232c0:	4543      	cmp	r3, r8
      xy = MAC16_16(xy, x[i], y[i]);
   232c2:	fb1e 110c 	smlabb	r1, lr, ip, r1
   for (i=0;i<N;i++)
   232c6:	d1f7      	bne.n	232b8 <quant_all_bands+0xd10>
   232c8:	ea4f 4e21 	mov.w	lr, r1, asr #16
   232cc:	69f9      	ldr	r1, [r7, #28]
   232ce:	fb01 fe0e 	mul.w	lr, r1, lr
   232d2:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
   opus_val32 xy=0;
   232d6:	2100      	movs	r1, #0
      xy = MAC16_16(xy, x[i], y[i]);
   232d8:	f832 5f02 	ldrh.w	r5, [r2, #2]!
   232dc:	f830 cf02 	ldrh.w	ip, [r0, #2]!
   for (i=0;i<N;i++)
   232e0:	4293      	cmp	r3, r2
      xy = MAC16_16(xy, x[i], y[i]);
   232e2:	fb1c 1105 	smlabb	r1, ip, r5, r1
   for (i=0;i<N;i++)
   232e6:	d1f7      	bne.n	232d8 <quant_all_bands+0xd30>
   232e8:	69fa      	ldr	r2, [r7, #28]
   232ea:	b28b      	uxth	r3, r1
   232ec:	fb02 f303 	mul.w	r3, r2, r3
   232f0:	eb0e 3ee3 	add.w	lr, lr, r3, asr #15
   232f4:	eb0e 0309 	add.w	r3, lr, r9
   232f8:	60bb      	str	r3, [r7, #8]
               ec_save2 = *ec;
   232fa:	f8d7 c728 	ldr.w	ip, [r7, #1832]	; 0x728
   232fe:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   23302:	f107 05f0 	add.w	r5, r7, #240	; 0xf0
   23306:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   23308:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   2330c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   2330e:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
               ctx_save2 = ctx;
   23312:	f507 7c90 	add.w	ip, r7, #288	; 0x120
               ec_save2 = *ec;
   23316:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
               ctx_save2 = ctx;
   2331a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   2331e:	f507 75cc 	add.w	r5, r7, #408	; 0x198
   23322:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   23324:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   23328:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   2332a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   2332e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   23330:	e89c 0007 	ldmia.w	ip, {r0, r1, r2}
   23334:	e885 0007 	stmia.w	r5, {r0, r1, r2}
               OPUS_COPY(X_save2, X, N);
   23338:	4652      	mov	r2, sl
   2333a:	6e79      	ldr	r1, [r7, #100]	; 0x64
   2333c:	6b38      	ldr	r0, [r7, #48]	; 0x30
   2333e:	f7e8 fedf 	bl	c100 <memcpy>
               OPUS_COPY(Y_save2, Y, N);
   23342:	4652      	mov	r2, sl
   23344:	f8d7 109c 	ldr.w	r1, [r7, #156]	; 0x9c
   23348:	6af8      	ldr	r0, [r7, #44]	; 0x2c
   2334a:	f7e8 fed9 	bl	c100 <memcpy>
               if (!last)
   2334e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   23352:	429c      	cmp	r4, r3
   23354:	d00f      	beq.n	23376 <quant_all_bands+0xdce>
                  OPUS_COPY(norm_save2, norm+M*eBands[i]-norm_offset, N);
   23356:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
   2335a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   2335c:	f933 1c02 	ldrsh.w	r1, [r3, #-2]
   23360:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
   23364:	40b1      	lsls	r1, r6
   23366:	1ac9      	subs	r1, r1, r3
   23368:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
   2336c:	4652      	mov	r2, sl
   2336e:	eb03 0141 	add.w	r1, r3, r1, lsl #1
   23372:	f7e8 fec5 	bl	c100 <memcpy>
               bytes_buf = ec_save.buf+nstart_bytes;
   23376:	68fb      	ldr	r3, [r7, #12]
   23378:	6979      	ldr	r1, [r7, #20]
               save_bytes = nend_bytes-nstart_bytes;
   2337a:	693a      	ldr	r2, [r7, #16]
               bytes_buf = ec_save.buf+nstart_bytes;
   2337c:	4419      	add	r1, r3
               save_bytes = nend_bytes-nstart_bytes;
   2337e:	1ad3      	subs	r3, r2, r3
               OPUS_COPY(bytes_save, bytes_buf, save_bytes);
   23380:	461a      	mov	r2, r3
   23382:	f507 70ea 	add.w	r0, r7, #468	; 0x1d4
               *ec = ec_save;
   23386:	f107 05c0 	add.w	r5, r7, #192	; 0xc0
               bytes_buf = ec_save.buf+nstart_bytes;
   2338a:	60f9      	str	r1, [r7, #12]
               save_bytes = nend_bytes-nstart_bytes;
   2338c:	617b      	str	r3, [r7, #20]
               OPUS_COPY(bytes_save, bytes_buf, save_bytes);
   2338e:	f7e8 feb7 	bl	c100 <memcpy>
               *ec = ec_save;
   23392:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   23394:	f8d7 c728 	ldr.w	ip, [r7, #1832]	; 0x728
   23398:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   2339c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   2339e:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   233a2:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
               ctx = ctx_save;
   233a6:	f507 75ae 	add.w	r5, r7, #348	; 0x15c
               *ec = ec_save;
   233aa:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
               ctx = ctx_save;
   233ae:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   233b0:	f507 7c90 	add.w	ip, r7, #288	; 0x120
   233b4:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   233b8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   233ba:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   233be:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   233c0:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   233c4:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
   233c8:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
               OPUS_COPY(X, X_save, N);
   233cc:	4652      	mov	r2, sl
   233ce:	6bb9      	ldr	r1, [r7, #56]	; 0x38
   233d0:	6e78      	ldr	r0, [r7, #100]	; 0x64
   233d2:	f7e8 fe95 	bl	c100 <memcpy>
               OPUS_COPY(Y, Y_save, N);
   233d6:	4652      	mov	r2, sl
   233d8:	6b79      	ldr	r1, [r7, #52]	; 0x34
   233da:	f8d7 009c 	ldr.w	r0, [r7, #156]	; 0x9c
   233de:	f7e8 fe8f 	bl	c100 <memcpy>
               if (i == start+1)
   233e2:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   233e6:	429c      	cmp	r4, r3
   233e8:	f000 8322 	beq.w	23a30 <quant_all_bands+0x1488>
   233ec:	e002      	b.n	233f4 <quant_all_bands+0xe4c>
   233ee:	bf00      	nop
   233f0:	55555556 	.word	0x55555556
               ctx.theta_round = 1;
   233f4:	2301      	movs	r3, #1
   233f6:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
   233fa:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   233fe:	429c      	cmp	r4, r3
   23400:	f000 8314 	beq.w	23a2c <quant_all_bands+0x1484>
                     last?NULL:norm+M*eBands[i]-norm_offset, lowband_scratch, cm);
   23404:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
   23408:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
   2340c:	f933 3c02 	ldrsh.w	r3, [r3, #-2]
   23410:	40b3      	lsls	r3, r6
   23412:	1a9b      	subs	r3, r3, r2
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
   23414:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
   23418:	eb02 0343 	add.w	r3, r2, r3, lsl #1
   2341c:	69ba      	ldr	r2, [r7, #24]
   2341e:	9206      	str	r2, [sp, #24]
   23420:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
   23424:	6e7d      	ldr	r5, [r7, #100]	; 0x64
   23426:	9603      	str	r6, [sp, #12]
   23428:	e9cd 3204 	strd	r3, r2, [sp, #16]
   2342c:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
   23430:	9302      	str	r3, [sp, #8]
   23432:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
   23436:	9301      	str	r3, [sp, #4]
   23438:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
   2343c:	9300      	str	r3, [sp, #0]
   2343e:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
   23442:	465b      	mov	r3, fp
   23444:	4629      	mov	r1, r5
   23446:	f507 7090 	add.w	r0, r7, #288	; 0x120
   2344a:	f7fd ffb7 	bl	213bc <quant_band_stereo>
   2344e:	f1bb 0f00 	cmp.w	fp, #0
   23452:	4681      	mov	r9, r0
   23454:	f340 8221 	ble.w	2389a <quant_all_bands+0x12f2>
   23458:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   2345a:	1ea8      	subs	r0, r5, #2
   2345c:	1e9a      	subs	r2, r3, #2
   2345e:	eb02 080a 	add.w	r8, r2, sl
   23462:	4613      	mov	r3, r2
   23464:	4605      	mov	r5, r0
   opus_val32 xy=0;
   23466:	2100      	movs	r1, #0
      xy = MAC16_16(xy, x[i], y[i]);
   23468:	f833 ef02 	ldrh.w	lr, [r3, #2]!
   2346c:	f835 cf02 	ldrh.w	ip, [r5, #2]!
   for (i=0;i<N;i++)
   23470:	4543      	cmp	r3, r8
      xy = MAC16_16(xy, x[i], y[i]);
   23472:	fb1e 110c 	smlabb	r1, lr, ip, r1
   for (i=0;i<N;i++)
   23476:	d1f7      	bne.n	23468 <quant_all_bands+0xec0>
               dist1 = MULT16_32_Q15(w[0], celt_inner_prod(X_save, X, N, arch)) + MULT16_32_Q15(w[1], celt_inner_prod(Y_save, Y, N, arch));
   23478:	ea4f 4e21 	mov.w	lr, r1, asr #16
   2347c:	6c79      	ldr	r1, [r7, #68]	; 0x44
   2347e:	fb01 fe0e 	mul.w	lr, r1, lr
   23482:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
   opus_val32 xy=0;
   23486:	2100      	movs	r1, #0
      xy = MAC16_16(xy, x[i], y[i]);
   23488:	f832 cf02 	ldrh.w	ip, [r2, #2]!
   2348c:	f830 5f02 	ldrh.w	r5, [r0, #2]!
   for (i=0;i<N;i++)
   23490:	4293      	cmp	r3, r2
      xy = MAC16_16(xy, x[i], y[i]);
   23492:	fb1c 1105 	smlabb	r1, ip, r5, r1
   for (i=0;i<N;i++)
   23496:	d1f7      	bne.n	23488 <quant_all_bands+0xee0>
   23498:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   2349a:	b289      	uxth	r1, r1
   2349c:	fb03 f301 	mul.w	r3, r3, r1
   234a0:	4619      	mov	r1, r3
   234a2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   234a4:	1e9a      	subs	r2, r3, #2
   234a6:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
   234aa:	1e98      	subs	r0, r3, #2
   234ac:	eb0e 33e1 	add.w	r3, lr, r1, asr #15
   234b0:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
   234b4:	eb02 080a 	add.w	r8, r2, sl
   234b8:	4613      	mov	r3, r2
   234ba:	4605      	mov	r5, r0
   234bc:	2100      	movs	r1, #0
      xy = MAC16_16(xy, x[i], y[i]);
   234be:	f833 ef02 	ldrh.w	lr, [r3, #2]!
   234c2:	f835 cf02 	ldrh.w	ip, [r5, #2]!
   for (i=0;i<N;i++)
   234c6:	4543      	cmp	r3, r8
      xy = MAC16_16(xy, x[i], y[i]);
   234c8:	fb1e 110c 	smlabb	r1, lr, ip, r1
   for (i=0;i<N;i++)
   234cc:	d1f7      	bne.n	234be <quant_all_bands+0xf16>
   234ce:	ea4f 4e21 	mov.w	lr, r1, asr #16
   234d2:	69f9      	ldr	r1, [r7, #28]
   234d4:	fb01 fe0e 	mul.w	lr, r1, lr
   234d8:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
   opus_val32 xy=0;
   234dc:	2100      	movs	r1, #0
      xy = MAC16_16(xy, x[i], y[i]);
   234de:	f832 cf02 	ldrh.w	ip, [r2, #2]!
   234e2:	f830 5f02 	ldrh.w	r5, [r0, #2]!
   for (i=0;i<N;i++)
   234e6:	4293      	cmp	r3, r2
      xy = MAC16_16(xy, x[i], y[i]);
   234e8:	fb1c 1105 	smlabb	r1, ip, r5, r1
   for (i=0;i<N;i++)
   234ec:	d1f7      	bne.n	234de <quant_all_bands+0xf36>
   234ee:	69fa      	ldr	r2, [r7, #28]
   234f0:	b28b      	uxth	r3, r1
   234f2:	fb02 f203 	mul.w	r2, r2, r3
   234f6:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
   234fa:	eb0e 3ee2 	add.w	lr, lr, r2, asr #15
   234fe:	449e      	add	lr, r3
               if (dist0 >= dist1) {
   23500:	68bb      	ldr	r3, [r7, #8]
   23502:	4573      	cmp	r3, lr
   23504:	f2c0 80b9 	blt.w	2367a <quant_all_bands+0x10d2>
                  *ec = ec_save2;
   23508:	f107 05f0 	add.w	r5, r7, #240	; 0xf0
   2350c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   2350e:	f8d7 c728 	ldr.w	ip, [r7, #1832]	; 0x728
   23512:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   23516:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   23518:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   2351c:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
                  ctx = ctx_save2;
   23520:	f507 75cc 	add.w	r5, r7, #408	; 0x198
                  *ec = ec_save2;
   23524:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
                  ctx = ctx_save2;
   23528:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   2352a:	f507 7c90 	add.w	ip, r7, #288	; 0x120
   2352e:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   23532:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   23534:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   23538:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   2353a:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   2353e:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
   23542:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
                  OPUS_COPY(X, X_save2, N);
   23546:	4652      	mov	r2, sl
   23548:	6b39      	ldr	r1, [r7, #48]	; 0x30
   2354a:	6e78      	ldr	r0, [r7, #100]	; 0x64
   2354c:	f7e8 fdd8 	bl	c100 <memcpy>
                  OPUS_COPY(Y, Y_save2, N);
   23550:	4652      	mov	r2, sl
   23552:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   23554:	f8d7 009c 	ldr.w	r0, [r7, #156]	; 0x9c
   23558:	f7e8 fdd2 	bl	c100 <memcpy>
                  if (!last)
   2355c:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   23560:	429c      	cmp	r4, r3
   23562:	d00f      	beq.n	23584 <quant_all_bands+0xfdc>
                     OPUS_COPY(norm+M*eBands[i]-norm_offset, norm_save2, N);
   23564:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
   23568:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   2356a:	f933 0c02 	ldrsh.w	r0, [r3, #-2]
   2356e:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
   23572:	40b0      	lsls	r0, r6
   23574:	1ac0      	subs	r0, r0, r3
   23576:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
   2357a:	4652      	mov	r2, sl
   2357c:	eb03 0040 	add.w	r0, r3, r0, lsl #1
   23580:	f7e8 fdbe 	bl	c100 <memcpy>
                  OPUS_COPY(bytes_buf, bytes_save, save_bytes);
   23584:	697a      	ldr	r2, [r7, #20]
   23586:	68f8      	ldr	r0, [r7, #12]
   23588:	f507 71ea 	add.w	r1, r7, #468	; 0x1d4
   2358c:	f7e8 fdb8 	bl	c100 <memcpy>
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
   23590:	f8d7 9004 	ldr.w	r9, [r7, #4]
   23594:	e071      	b.n	2367a <quant_all_bands+0x10d2>
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
   23596:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
               ctx.theta_round = 0;
   2359a:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
   2359e:	bf16      	itet	ne
   235a0:	f8d7 30b0 	ldrne.w	r3, [r7, #176]	; 0xb0
   235a4:	461a      	moveq	r2, r3
   235a6:	eb03 0248 	addne.w	r2, r3, r8, lsl #1
   235aa:	e565      	b.n	23078 <quant_all_bands+0xad0>
   if (d>256)
   235ac:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
      return -(opus_int32)celt_udiv(-n, d);
   235b0:	f1c3 0c00 	rsb	ip, r3, #0
   if (d>256)
   235b4:	f240 80b1 	bls.w	2371a <quant_all_bands+0x1172>
      return n/d;
   235b8:	fbbc f1f1 	udiv	r1, ip, r1
      return -(opus_int32)celt_udiv(-n, d);
   235bc:	4249      	negs	r1, r1
   235be:	f7ff bb86 	b.w	22cce <quant_all_bands+0x726>
         y_cm = quant_band(&ctx, Y, N, b/2, B,
   235c2:	2200      	movs	r2, #0
   235c4:	e40d      	b.n	22de2 <quant_all_bands+0x83a>
      t = EC_ILOG(d&-d);
   235c6:	424b      	negs	r3, r1
   235c8:	400b      	ands	r3, r1
   235ca:	fab3 f383 	clz	r3, r3
   235ce:	f1c3 0320 	rsb	r3, r3, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   235d2:	fa21 fc03 	lsr.w	ip, r1, r3
   235d6:	1e5a      	subs	r2, r3, #1
   235d8:	4bcd      	ldr	r3, [pc, #820]	; (23910 <quant_all_bands+0x1368>)
   235da:	f853 c02c 	ldr.w	ip, [r3, ip, lsl #2]
   235de:	f8d7 3724 	ldr.w	r3, [r7, #1828]	; 0x724
   235e2:	fa23 f202 	lsr.w	r2, r3, r2
   235e6:	fba2 890c 	umull	r8, r9, r2, ip
      return q+(n-q*d >= d);
   235ea:	fb01 3219 	mls	r2, r1, r9, r3
   235ee:	428a      	cmp	r2, r1
   235f0:	bf34      	ite	cc
   235f2:	4649      	movcc	r1, r9
   235f4:	f109 0101 	addcs.w	r1, r9, #1
   235f8:	f7ff bb69 	b.w	22cce <quant_all_bands+0x726>
      lowband_scratch = X_+M*eBands[m->nbEBands-1];
   235fc:	f8d7 36f8 	ldr.w	r3, [r7, #1784]	; 0x6f8
   23600:	eb03 0349 	add.w	r3, r3, r9, lsl #1
   23604:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
   23608:	240a      	movs	r4, #10
   2360a:	f7ff b83b 	b.w	22684 <quant_all_bands+0xdc>
         x_cm = y_cm = (1<<B)-1;
   2360e:	f8d7 c058 	ldr.w	ip, [r7, #88]	; 0x58
   23612:	f8c7 c08c 	str.w	ip, [r7, #140]	; 0x8c
      int effective_lowband=-1;
   23616:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
   2361a:	e574      	b.n	23106 <quant_all_bands+0xb5e>
            x_cm = quant_band(&ctx, X, N, b, B,
   2361c:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
   23620:	eb03 0248 	add.w	r2, r3, r8, lsl #1
   23624:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   23628:	429c      	cmp	r4, r3
   2362a:	f000 81fa 	beq.w	23a22 <quant_all_bands+0x147a>
                  last?NULL:norm+M*eBands[i]-norm_offset, Q15ONE, lowband_scratch, x_cm|y_cm);
   2362e:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
   23632:	f8d7 10a4 	ldr.w	r1, [r7, #164]	; 0xa4
   23636:	f933 3c02 	ldrsh.w	r3, [r3, #-2]
   2363a:	40b3      	lsls	r3, r6
   2363c:	1a5b      	subs	r3, r3, r1
            x_cm = quant_band(&ctx, X, N, b, B,
   2363e:	f8d7 10b0 	ldr.w	r1, [r7, #176]	; 0xb0
   23642:	eb01 0343 	add.w	r3, r1, r3, lsl #1
                  last?NULL:norm+M*eBands[i]-norm_offset, Q15ONE, lowband_scratch, x_cm|y_cm);
   23646:	f8d7 108c 	ldr.w	r1, [r7, #140]	; 0x8c
            x_cm = quant_band(&ctx, X, N, b, B,
   2364a:	9201      	str	r2, [sp, #4]
                  last?NULL:norm+M*eBands[i]-norm_offset, Q15ONE, lowband_scratch, x_cm|y_cm);
   2364c:	ea4c 0501 	orr.w	r5, ip, r1
            x_cm = quant_band(&ctx, X, N, b, B,
   23650:	f647 70ff 	movw	r0, #32767	; 0x7fff
   23654:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
   23658:	9105      	str	r1, [sp, #20]
   2365a:	e9cd 6302 	strd	r6, r3, [sp, #8]
   2365e:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
   23662:	9300      	str	r3, [sp, #0]
   23664:	9004      	str	r0, [sp, #16]
   23666:	9506      	str	r5, [sp, #24]
   23668:	6e79      	ldr	r1, [r7, #100]	; 0x64
   2366a:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
   2366e:	465a      	mov	r2, fp
   23670:	f507 7090 	add.w	r0, r7, #288	; 0x120
   23674:	f7fd fa16 	bl	20aa4 <quant_band>
   23678:	4681      	mov	r9, r0
   2367a:	2300      	movs	r3, #0
   2367c:	4648      	mov	r0, r9
   2367e:	f8c7 3714 	str.w	r3, [r7, #1812]	; 0x714
   23682:	f7ff bbd0 	b.w	22e26 <quant_all_bands+0x87e>
   23686:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
   2368a:	eb03 0248 	add.w	r2, r3, r8, lsl #1
   2368e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   23692:	42a3      	cmp	r3, r4
   23694:	f000 817a 	beq.w	2398c <quant_all_bands+0x13e4>
                  last?NULL:norm+M*eBands[i]-norm_offset, Q15ONE, lowband_scratch, x_cm|y_cm);
   23698:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
   2369c:	f8d7 10a4 	ldr.w	r1, [r7, #164]	; 0xa4
   236a0:	f933 3c02 	ldrsh.w	r3, [r3, #-2]
   236a4:	40b3      	lsls	r3, r6
   236a6:	1a5b      	subs	r3, r3, r1
            x_cm = quant_band(&ctx, X, N, b, B,
   236a8:	f8d7 10b0 	ldr.w	r1, [r7, #176]	; 0xb0
   236ac:	eb01 0343 	add.w	r3, r1, r3, lsl #1
                  last?NULL:norm+M*eBands[i]-norm_offset, Q15ONE, lowband_scratch, x_cm|y_cm);
   236b0:	ea4e 010c 	orr.w	r1, lr, ip
            x_cm = quant_band(&ctx, X, N, b, B,
   236b4:	f647 70ff 	movw	r0, #32767	; 0x7fff
   236b8:	9106      	str	r1, [sp, #24]
   236ba:	e9cd 6302 	strd	r6, r3, [sp, #8]
   236be:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
   236c2:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
   236c6:	9105      	str	r1, [sp, #20]
   236c8:	9201      	str	r2, [sp, #4]
   236ca:	9300      	str	r3, [sp, #0]
   236cc:	9004      	str	r0, [sp, #16]
   236ce:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
   236d2:	6e79      	ldr	r1, [r7, #100]	; 0x64
   236d4:	462a      	mov	r2, r5
   236d6:	f507 7090 	add.w	r0, r7, #288	; 0x120
   236da:	f7fd f9e3 	bl	20aa4 <quant_band>
   236de:	2300      	movs	r3, #0
   236e0:	4604      	mov	r4, r0
   236e2:	f8c7 3714 	str.w	r3, [r7, #1812]	; 0x714
   236e6:	f7ff b926 	b.w	22936 <quant_all_bands+0x38e>
      t = EC_ILOG(d&-d);
   236ea:	4259      	negs	r1, r3
   236ec:	4019      	ands	r1, r3
   236ee:	fab1 f181 	clz	r1, r1
   236f2:	f1c1 0120 	rsb	r1, r1, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   236f6:	fa23 fe01 	lsr.w	lr, r3, r1
   236fa:	4885      	ldr	r0, [pc, #532]	; (23910 <quant_all_bands+0x1368>)
   236fc:	3901      	subs	r1, #1
   236fe:	f850 002e 	ldr.w	r0, [r0, lr, lsl #2]
   23702:	fa2c f101 	lsr.w	r1, ip, r1
   23706:	fba1 0100 	umull	r0, r1, r1, r0
      return q+(n-q*d >= d);
   2370a:	fb03 cc11 	mls	ip, r3, r1, ip
   2370e:	459c      	cmp	ip, r3
   23710:	bf34      	ite	cc
   23712:	460b      	movcc	r3, r1
   23714:	1c4b      	addcs	r3, r1, #1
   23716:	f7ff ba6d 	b.w	22bf4 <quant_all_bands+0x64c>
      t = EC_ILOG(d&-d);
   2371a:	424b      	negs	r3, r1
   2371c:	400b      	ands	r3, r1
   2371e:	fab3 f383 	clz	r3, r3
   23722:	f1c3 0320 	rsb	r3, r3, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   23726:	fa21 fe03 	lsr.w	lr, r1, r3
   2372a:	4a79      	ldr	r2, [pc, #484]	; (23910 <quant_all_bands+0x1368>)
   2372c:	3b01      	subs	r3, #1
   2372e:	f852 202e 	ldr.w	r2, [r2, lr, lsl #2]
   23732:	fa2c f303 	lsr.w	r3, ip, r3
   23736:	fba3 2302 	umull	r2, r3, r3, r2
      return q+(n-q*d >= d);
   2373a:	fb01 cc13 	mls	ip, r1, r3, ip
   2373e:	458c      	cmp	ip, r1
   23740:	bf34      	ite	cc
   23742:	4619      	movcc	r1, r3
   23744:	1c59      	addcs	r1, r3, #1
   23746:	e739      	b.n	235bc <quant_all_bands+0x1014>
      if (resynth && (M*eBands[i]-N >= M*eBands[start] || i==start+1) && (update_lowband || lowband_offset==0))
   23748:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
   2374c:	461a      	mov	r2, r3
   2374e:	2b00      	cmp	r3, #0
   23750:	bf08      	it	eq
   23752:	4622      	moveq	r2, r4
      if (i == start+1)
   23754:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
      if (resynth && (M*eBands[i]-N >= M*eBands[start] || i==start+1) && (update_lowband || lowband_offset==0))
   23758:	f8c7 20b4 	str.w	r2, [r7, #180]	; 0xb4
      if (i == start+1)
   2375c:	42a3      	cmp	r3, r4
   2375e:	f47f a856 	bne.w	2280e <quant_all_bands+0x266>
   23762:	e01b      	b.n	2379c <quant_all_bands+0x11f4>
   23764:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
   23768:	461a      	mov	r2, r3
   2376a:	2b00      	cmp	r3, #0
   2376c:	bf08      	it	eq
   2376e:	4622      	moveq	r2, r4
   23770:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   23774:	f8c7 20b4 	str.w	r2, [r7, #180]	; 0xb4
   23778:	429c      	cmp	r4, r3
   2377a:	f47f aacb 	bne.w	22d14 <quant_all_bands+0x76c>
   2377e:	f7ff bbc7 	b.w	22f10 <quant_all_bands+0x968>
      if (resynth && (M*eBands[i]-N >= M*eBands[start] || i==start+1) && (update_lowband || lowband_offset==0))
   23782:	f1ba 0f00 	cmp.w	sl, #0
   23786:	f040 80d9 	bne.w	2393c <quant_all_bands+0x1394>
   2378a:	4619      	mov	r1, r3
   2378c:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
   23790:	461a      	mov	r2, r3
   23792:	2b00      	cmp	r3, #0
   23794:	bf08      	it	eq
   23796:	460a      	moveq	r2, r1
   23798:	f8c7 20b4 	str.w	r2, [r7, #180]	; 0xb4
         special_hybrid_folding(m, norm, norm2, start, M, dual_stereo);
   2379c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
   n2 = M*(eBands[start+2]-eBands[start+1]);
   2379e:	6a38      	ldr	r0, [r7, #32]
         special_hybrid_folding(m, norm, norm2, start, M, dual_stereo);
   237a0:	699a      	ldr	r2, [r3, #24]
   n1 = M*(eBands[start+1]-eBands[start]);
   237a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   237a4:	5ed1      	ldrsh	r1, [r2, r3]
   237a6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   237a8:	5ed3      	ldrsh	r3, [r2, r3]
   n2 = M*(eBands[start+2]-eBands[start+1]);
   237aa:	5e12      	ldrsh	r2, [r2, r0]
   n1 = M*(eBands[start+1]-eBands[start]);
   237ac:	1acb      	subs	r3, r1, r3
   n2 = M*(eBands[start+2]-eBands[start+1]);
   237ae:	1a52      	subs	r2, r2, r1
   n1 = M*(eBands[start+1]-eBands[start]);
   237b0:	40b3      	lsls	r3, r6
   n2 = M*(eBands[start+2]-eBands[start+1]);
   237b2:	40b2      	lsls	r2, r6
   OPUS_COPY(&norm[n1], &norm[2*n1 - n2], n2-n1);
   237b4:	ea4f 0a43 	mov.w	sl, r3, lsl #1
   237b8:	1ad3      	subs	r3, r2, r3
   237ba:	ea4f 0943 	mov.w	r9, r3, lsl #1
   237be:	ebaa 0202 	sub.w	r2, sl, r2
   237c2:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
   237c6:	0052      	lsls	r2, r2, #1
   237c8:	1899      	adds	r1, r3, r2
   237ca:	667a      	str	r2, [r7, #100]	; 0x64
   237cc:	eb03 000a 	add.w	r0, r3, sl
   237d0:	464a      	mov	r2, r9
   237d2:	f7e8 fc95 	bl	c100 <memcpy>
   if (dual_stereo)
   237d6:	f8d7 3714 	ldr.w	r3, [r7, #1812]	; 0x714
   237da:	2b00      	cmp	r3, #0
   237dc:	f43f a817 	beq.w	2280e <quant_all_bands+0x266>
      OPUS_COPY(&norm2[n1], &norm2[2*n1 - n2], n2-n1);
   237e0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   237e2:	4619      	mov	r1, r3
   237e4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   237e6:	464a      	mov	r2, r9
   237e8:	4419      	add	r1, r3
   237ea:	eb03 000a 	add.w	r0, r3, sl
   237ee:	f7e8 fc87 	bl	c100 <memcpy>
   237f2:	f7ff b80c 	b.w	2280e <quant_all_bands+0x266>
      if (resynth && (M*eBands[i]-N >= M*eBands[start] || i==start+1) && (update_lowband || lowband_offset==0))
   237f6:	f1ba 0f00 	cmp.w	sl, #0
   237fa:	d104      	bne.n	23806 <quant_all_bands+0x125e>
   237fc:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
   23800:	2b00      	cmp	r3, #0
   23802:	f47f ab80 	bne.w	22f06 <quant_all_bands+0x95e>
   23806:	f8c7 40b4 	str.w	r4, [r7, #180]	; 0xb4
   2380a:	f7ff bb81 	b.w	22f10 <quant_all_bands+0x968>
   int theta_rdo = encode && Y_!=NULL && !dual_stereo && complexity>=8;
   2380e:	fab0 f380 	clz	r3, r0
   23812:	095b      	lsrs	r3, r3, #5
   23814:	67bb      	str	r3, [r7, #120]	; 0x78
   int C = Y_ != NULL ? 2 : 1;
   23816:	2301      	movs	r3, #1
   23818:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
   int resynth = !encode || theta_rdo;
   2381c:	f8d7 36fc 	ldr.w	r3, [r7, #1788]	; 0x6fc
   23820:	643b      	str	r3, [r7, #64]	; 0x40
   23822:	f7fe bedb 	b.w	225dc <quant_all_bands+0x34>
         x_cm = y_cm = (1<<B)-1;
   23826:	6dbd      	ldr	r5, [r7, #88]	; 0x58
   23828:	f8c7 508c 	str.w	r5, [r7, #140]	; 0x8c
   2382c:	461a      	mov	r2, r3
   2382e:	46ac      	mov	ip, r5
   23830:	e6f8      	b.n	23624 <quant_all_bands+0x107c>
   23832:	f8d7 c058 	ldr.w	ip, [r7, #88]	; 0x58
            x_cm = quant_band(&ctx, X, N, b, B,
   23836:	461a      	mov	r2, r3
         x_cm = y_cm = (1<<B)-1;
   23838:	46e6      	mov	lr, ip
   2383a:	e728      	b.n	2368e <quant_all_bands+0x10e6>
   2383c:	2300      	movs	r3, #0
   2383e:	643b      	str	r3, [r7, #64]	; 0x40
   int resynth = !encode || theta_rdo;
   23840:	67bb      	str	r3, [r7, #120]	; 0x78
   int C = Y_ != NULL ? 2 : 1;
   23842:	2302      	movs	r3, #2
   23844:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
   23848:	f7fe bec8 	b.w	225dc <quant_all_bands+0x34>
   w[0] = VSHR32(Ex, shift);
   2384c:	f1c3 030e 	rsb	r3, r3, #14
   23850:	409a      	lsls	r2, r3
   w[1] = VSHR32(Ey, shift);
   23852:	fa01 f303 	lsl.w	r3, r1, r3
   w[0] = VSHR32(Ex, shift);
   23856:	b212      	sxth	r2, r2
   w[1] = VSHR32(Ey, shift);
   23858:	b21b      	sxth	r3, r3
   w[0] = VSHR32(Ex, shift);
   2385a:	647a      	str	r2, [r7, #68]	; 0x44
   w[1] = VSHR32(Ey, shift);
   2385c:	61fb      	str	r3, [r7, #28]
   2385e:	e47c      	b.n	2315a <quant_all_bands+0xbb2>
   23860:	f8d7 3714 	ldr.w	r3, [r7, #1812]	; 0x714
   23864:	643b      	str	r3, [r7, #64]	; 0x40
   int resynth = !encode || theta_rdo;
   23866:	67bb      	str	r3, [r7, #120]	; 0x78
   int C = Y_ != NULL ? 2 : 1;
   23868:	2302      	movs	r3, #2
   2386a:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
   2386e:	f7fe beb5 	b.w	225dc <quant_all_bands+0x34>
         lowband_scratch = NULL;
   23872:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   23874:	2a00      	cmp	r2, #0
   23876:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
   2387a:	bf08      	it	eq
   2387c:	2200      	moveq	r2, #0
   2387e:	f8c7 20ac 	str.w	r2, [r7, #172]	; 0xac
   23882:	f7fe bfe4 	b.w	2284e <quant_all_bands+0x2a6>
   23886:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   23888:	2a00      	cmp	r2, #0
   2388a:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
   2388e:	bf08      	it	eq
   23890:	2200      	moveq	r2, #0
   23892:	f8c7 20ac 	str.w	r2, [r7, #172]	; 0xac
   23896:	f7ff ba51 	b.w	22d3c <quant_all_bands+0x794>
   2389a:	f04f 0e00 	mov.w	lr, #0
   2389e:	e62f      	b.n	23500 <quant_all_bands+0xf58>
   238a0:	2300      	movs	r3, #0
   238a2:	60bb      	str	r3, [r7, #8]
   238a4:	e529      	b.n	232fa <quant_all_bands+0xd52>
         x_cm = quant_band(&ctx, X, N, b/2, B,
   238a6:	9306      	str	r3, [sp, #24]
   238a8:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
   238ac:	9305      	str	r3, [sp, #20]
   238ae:	2300      	movs	r3, #0
   238b0:	f647 70ff 	movw	r0, #32767	; 0x7fff
   238b4:	e9cd 6302 	strd	r6, r3, [sp, #8]
   238b8:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
   238bc:	9201      	str	r2, [sp, #4]
   238be:	9300      	str	r3, [sp, #0]
   238c0:	9004      	str	r0, [sp, #16]
   238c2:	6e79      	ldr	r1, [r7, #100]	; 0x64
   238c4:	462b      	mov	r3, r5
   238c6:	465a      	mov	r2, fp
   238c8:	f507 7090 	add.w	r0, r7, #288	; 0x120
   238cc:	f7fd f8ea 	bl	20aa4 <quant_band>
         y_cm = quant_band(&ctx, Y, N, b/2, B,
   238d0:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
         x_cm = quant_band(&ctx, X, N, b/2, B,
   238d4:	4681      	mov	r9, r0
         y_cm = quant_band(&ctx, Y, N, b/2, B,
   238d6:	f000 80c3 	beq.w	23a60 <quant_all_bands+0x14b8>
   238da:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   238dc:	eb03 020a 	add.w	r2, r3, sl
   238e0:	2300      	movs	r3, #0
   238e2:	f7ff ba89 	b.w	22df8 <quant_all_bands+0x850>
         x_cm = y_cm = (1<<B)-1;
   238e6:	6dbd      	ldr	r5, [r7, #88]	; 0x58
   238e8:	f8c7 508c 	str.w	r5, [r7, #140]	; 0x8c
   238ec:	46ac      	mov	ip, r5
      int effective_lowband=-1;
   238ee:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
         if (resynth)
   238f2:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   238f4:	2b00      	cmp	r3, #0
   238f6:	d14b      	bne.n	23990 <quant_all_bands+0x13e8>
         if (Y!=NULL)
   238f8:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
   238fc:	2b00      	cmp	r3, #0
   238fe:	f47f abfe 	bne.w	230fe <quant_all_bands+0xb56>
            x_cm = quant_band(&ctx, X, N, b, B,
   23902:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
   23906:	f47f ae89 	bne.w	2361c <quant_all_bands+0x1074>
   2390a:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
   2390e:	e689      	b.n	23624 <quant_all_bands+0x107c>
   23910:	00038e98 	.word	0x00038e98
         x_cm = y_cm = (1<<B)-1;
   23914:	f8d7 c058 	ldr.w	ip, [r7, #88]	; 0x58
      int effective_lowband=-1;
   23918:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
         x_cm = y_cm = (1<<B)-1;
   2391c:	46e6      	mov	lr, ip
         if (resynth)
   2391e:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   23920:	2b00      	cmp	r3, #0
   23922:	d15b      	bne.n	239dc <quant_all_bands+0x1434>
         if (Y!=NULL)
   23924:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
   23928:	2b00      	cmp	r3, #0
   2392a:	f47f a94f 	bne.w	22bcc <quant_all_bands+0x624>
            x_cm = quant_band(&ctx, X, N, b, B,
   2392e:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
   23932:	f47f aea8 	bne.w	23686 <quant_all_bands+0x10de>
   23936:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
   2393a:	e6a8      	b.n	2368e <quant_all_bands+0x10e6>
      if (resynth && (M*eBands[i]-N >= M*eBands[start] || i==start+1) && (update_lowband || lowband_offset==0))
   2393c:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
   23940:	e72c      	b.n	2379c <quant_all_bands+0x11f4>
         x_cm = quant_band(&ctx, X, N, b/2, B,
   23942:	9306      	str	r3, [sp, #24]
   23944:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
   23948:	9305      	str	r3, [sp, #20]
   2394a:	2300      	movs	r3, #0
   2394c:	f647 70ff 	movw	r0, #32767	; 0x7fff
   23950:	e9cd 6302 	strd	r6, r3, [sp, #8]
   23954:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
   23958:	9201      	str	r2, [sp, #4]
   2395a:	9300      	str	r3, [sp, #0]
   2395c:	9004      	str	r0, [sp, #16]
   2395e:	6e79      	ldr	r1, [r7, #100]	; 0x64
   23960:	4653      	mov	r3, sl
   23962:	462a      	mov	r2, r5
   23964:	f507 7090 	add.w	r0, r7, #288	; 0x120
   23968:	f7fd f89c 	bl	20aa4 <quant_band>
         y_cm = quant_band(&ctx, Y, N, b/2, B,
   2396c:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
         x_cm = quant_band(&ctx, X, N, b/2, B,
   23970:	4604      	mov	r4, r0
         y_cm = quant_band(&ctx, Y, N, b/2, B,
   23972:	d079      	beq.n	23a68 <quant_all_bands+0x14c0>
   23974:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   23976:	eb03 0209 	add.w	r2, r3, r9
   2397a:	2300      	movs	r3, #0
   2397c:	f7fe bfc5 	b.w	2290a <quant_all_bands+0x362>
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
   23980:	2300      	movs	r3, #0
   23982:	f7ff b8f2 	b.w	22b6a <quant_all_bands+0x5c2>
   23986:	2300      	movs	r3, #0
   23988:	f7ff bb87 	b.w	2309a <quant_all_bands+0xaf2>
            x_cm = quant_band(&ctx, X, N, b, B,
   2398c:	2300      	movs	r3, #0
   2398e:	e68f      	b.n	236b0 <quant_all_bands+0x1108>
            for (j=0;j<M*eBands[i]-norm_offset;j++)
   23990:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
   23994:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
   23998:	f933 3c02 	ldrsh.w	r3, [r3, #-2]
   2399c:	40b3      	lsls	r3, r6
   2399e:	1a9b      	subs	r3, r3, r2
   239a0:	2b00      	cmp	r3, #0
   239a2:	dda9      	ble.n	238f8 <quant_all_bands+0x1350>
   239a4:	f8d7 10b0 	ldr.w	r1, [r7, #176]	; 0xb0
   239a8:	f8d7 508c 	ldr.w	r5, [r7, #140]	; 0x8c
   239ac:	f8d7 90bc 	ldr.w	r9, [r7, #188]	; 0xbc
   239b0:	1e88      	subs	r0, r1, #2
   239b2:	6e39      	ldr	r1, [r7, #96]	; 0x60
   239b4:	f1a1 0e02 	sub.w	lr, r1, #2
   239b8:	2100      	movs	r1, #0
               norm[j] = HALF32(norm[j]+norm2[j]);
   239ba:	f930 3f02 	ldrsh.w	r3, [r0, #2]!
   239be:	f93e af02 	ldrsh.w	sl, [lr, #2]!
   239c2:	4453      	add	r3, sl
   239c4:	105b      	asrs	r3, r3, #1
   239c6:	8003      	strh	r3, [r0, #0]
            for (j=0;j<M*eBands[i]-norm_offset;j++)
   239c8:	f939 3c02 	ldrsh.w	r3, [r9, #-2]
   239cc:	40b3      	lsls	r3, r6
   239ce:	3101      	adds	r1, #1
   239d0:	1a9b      	subs	r3, r3, r2
   239d2:	428b      	cmp	r3, r1
   239d4:	dcf1      	bgt.n	239ba <quant_all_bands+0x1412>
   239d6:	f8c7 508c 	str.w	r5, [r7, #140]	; 0x8c
   239da:	e78d      	b.n	238f8 <quant_all_bands+0x1350>
   239dc:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
   239e0:	f8d7 10a4 	ldr.w	r1, [r7, #164]	; 0xa4
   239e4:	f932 3c02 	ldrsh.w	r3, [r2, #-2]
   239e8:	40b3      	lsls	r3, r6
   239ea:	1a5b      	subs	r3, r3, r1
   239ec:	2b00      	cmp	r3, #0
   239ee:	dd99      	ble.n	23924 <quant_all_bands+0x137c>
   239f0:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
   239f4:	1e98      	subs	r0, r3, #2
   239f6:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   239f8:	2100      	movs	r1, #0
   239fa:	f1a3 0902 	sub.w	r9, r3, #2
   239fe:	4692      	mov	sl, r2
               norm[j] = HALF32(norm[j]+norm2[j]);
   23a00:	f930 2f02 	ldrsh.w	r2, [r0, #2]!
   23a04:	f939 3f02 	ldrsh.w	r3, [r9, #2]!
   23a08:	4413      	add	r3, r2
   23a0a:	105b      	asrs	r3, r3, #1
   23a0c:	8003      	strh	r3, [r0, #0]
            for (j=0;j<M*eBands[i]-norm_offset;j++)
   23a0e:	f93a 3c02 	ldrsh.w	r3, [sl, #-2]
   23a12:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
   23a16:	40b3      	lsls	r3, r6
   23a18:	3101      	adds	r1, #1
   23a1a:	1a9b      	subs	r3, r3, r2
   23a1c:	428b      	cmp	r3, r1
   23a1e:	dcef      	bgt.n	23a00 <quant_all_bands+0x1458>
   23a20:	e780      	b.n	23924 <quant_all_bands+0x137c>
            x_cm = quant_band(&ctx, X, N, b, B,
   23a22:	2300      	movs	r3, #0
   23a24:	e60f      	b.n	23646 <quant_all_bands+0x109e>
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
   23a26:	2300      	movs	r3, #0
   23a28:	f7ff bbf7 	b.w	2321a <quant_all_bands+0xc72>
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
   23a2c:	2300      	movs	r3, #0
   23a2e:	e4f5      	b.n	2341c <quant_all_bands+0xe74>
                  special_hybrid_folding(m, norm, norm2, start, M, dual_stereo);
   23a30:	6f3b      	ldr	r3, [r7, #112]	; 0x70
   n2 = M*(eBands[start+2]-eBands[start+1]);
   23a32:	6a38      	ldr	r0, [r7, #32]
                  special_hybrid_folding(m, norm, norm2, start, M, dual_stereo);
   23a34:	699a      	ldr	r2, [r3, #24]
   n1 = M*(eBands[start+1]-eBands[start]);
   23a36:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   OPUS_COPY(&norm[n1], &norm[2*n1 - n2], n2-n1);
   23a38:	f8d7 50b0 	ldr.w	r5, [r7, #176]	; 0xb0
   n1 = M*(eBands[start+1]-eBands[start]);
   23a3c:	5ed1      	ldrsh	r1, [r2, r3]
   23a3e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   23a40:	5ed3      	ldrsh	r3, [r2, r3]
   n2 = M*(eBands[start+2]-eBands[start+1]);
   23a42:	5e12      	ldrsh	r2, [r2, r0]
   n1 = M*(eBands[start+1]-eBands[start]);
   23a44:	1acb      	subs	r3, r1, r3
   23a46:	40b3      	lsls	r3, r6
   n2 = M*(eBands[start+2]-eBands[start+1]);
   23a48:	1a52      	subs	r2, r2, r1
   23a4a:	40b2      	lsls	r2, r6
   OPUS_COPY(&norm[n1], &norm[2*n1 - n2], n2-n1);
   23a4c:	0058      	lsls	r0, r3, #1
   23a4e:	1ad3      	subs	r3, r2, r3
   23a50:	1a82      	subs	r2, r0, r2
   23a52:	eb05 0142 	add.w	r1, r5, r2, lsl #1
   23a56:	4428      	add	r0, r5
   23a58:	005a      	lsls	r2, r3, #1
   23a5a:	f7e8 fb51 	bl	c100 <memcpy>
   23a5e:	e4c9      	b.n	233f4 <quant_all_bands+0xe4c>
         y_cm = quant_band(&ctx, Y, N, b/2, B,
   23a60:	2200      	movs	r2, #0
   23a62:	4613      	mov	r3, r2
   23a64:	f7ff b9c8 	b.w	22df8 <quant_all_bands+0x850>
   23a68:	2200      	movs	r2, #0
   23a6a:	4613      	mov	r3, r2
   23a6c:	f7fe bf4d 	b.w	2290a <quant_all_bands+0x362>

00023a70 <resampling_factor>:


int resampling_factor(opus_int32 rate)
{
   int ret;
   switch (rate)
   23a70:	f5b0 5f7a 	cmp.w	r0, #16000	; 0x3e80
   23a74:	d019      	beq.n	23aaa <resampling_factor+0x3a>
   23a76:	dc08      	bgt.n	23a8a <resampling_factor+0x1a>
   23a78:	f5b0 5ffa 	cmp.w	r0, #8000	; 0x1f40
   23a7c:	d013      	beq.n	23aa6 <resampling_factor+0x36>
   23a7e:	f642 63e0 	movw	r3, #12000	; 0x2ee0
   23a82:	4298      	cmp	r0, r3
   23a84:	d10b      	bne.n	23a9e <resampling_factor+0x2e>
      break;
   case 16000:
      ret = 3;
      break;
   case 12000:
      ret = 4;
   23a86:	2004      	movs	r0, #4
      break;
   23a88:	4770      	bx	lr
   switch (rate)
   23a8a:	f645 53c0 	movw	r3, #24000	; 0x5dc0
   23a8e:	4298      	cmp	r0, r3
   23a90:	d007      	beq.n	23aa2 <resampling_factor+0x32>
   23a92:	f64b 3380 	movw	r3, #48000	; 0xbb80
   23a96:	4298      	cmp	r0, r3
   23a98:	d101      	bne.n	23a9e <resampling_factor+0x2e>
      ret = 1;
   23a9a:	2001      	movs	r0, #1
#endif
      ret = 0;
      break;
   }
   return ret;
}
   23a9c:	4770      	bx	lr
      ret = 0;
   23a9e:	2000      	movs	r0, #0
      break;
   23aa0:	4770      	bx	lr
      ret = 2;
   23aa2:	2002      	movs	r0, #2
   23aa4:	4770      	bx	lr
      ret = 6;
   23aa6:	2006      	movs	r0, #6
      break;
   23aa8:	4770      	bx	lr
      ret = 3;
   23aaa:	2003      	movs	r0, #3
      break;
   23aac:	4770      	bx	lr
   23aae:	bf00      	nop

00023ab0 <comb_filter>:

#ifndef OVERRIDE_comb_filter
void comb_filter(opus_val32 *y, opus_val32 *x, int T0, int T1, int N,
      opus_val16 g0, opus_val16 g1, int tapset0, int tapset1,
      const opus_val16 *window, int overlap, int arch)
{
   23ab0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   23ab4:	b095      	sub	sp, #84	; 0x54
   23ab6:	e9dd b623 	ldrd	fp, r6, [sp, #140]	; 0x8c
   23aba:	9c1e      	ldr	r4, [sp, #120]	; 0x78
   23abc:	f9bd 507c 	ldrsh.w	r5, [sp, #124]	; 0x7c
   23ac0:	9413      	str	r4, [sp, #76]	; 0x4c
   23ac2:	f9bd 4080 	ldrsh.w	r4, [sp, #128]	; 0x80
   23ac6:	940b      	str	r4, [sp, #44]	; 0x2c
   23ac8:	e9dd 7a21 	ldrd	r7, sl, [sp, #132]	; 0x84
   23acc:	960c      	str	r6, [sp, #48]	; 0x30
   23ace:	9200      	str	r2, [sp, #0]
   23ad0:	e9cd 100d 	strd	r1, r0, [sp, #52]	; 0x34
   static const opus_val16 gains[3][3] = {
         {QCONST16(0.3066406250f, 15), QCONST16(0.2170410156f, 15), QCONST16(0.1296386719f, 15)},
         {QCONST16(0.4638671875f, 15), QCONST16(0.2680664062f, 15), QCONST16(0.f, 15)},
         {QCONST16(0.7998046875f, 15), QCONST16(0.1000976562f, 15), QCONST16(0.f, 15)}};

   if (g0==0 && g1==0)
   23ad4:	b955      	cbnz	r5, 23aec <comb_filter+0x3c>
   23ad6:	b94c      	cbnz	r4, 23aec <comb_filter+0x3c>
   {
      /* OPT: Happens to work without the OPUS_MOVE(), but only because the current encoder already copies x to y */
      if (x!=y)
   23ad8:	4281      	cmp	r1, r0
   23ada:	f000 827e 	beq.w	23fda <comb_filter+0x52a>
         OPUS_MOVE(y, x, N);
   23ade:	9c13      	ldr	r4, [sp, #76]	; 0x4c
   23ae0:	00a2      	lsls	r2, r4, #2
      return;
   }

   /* Compute the part with the constant filter. */
   comb_filter_const(y+i, x+i, T1, N-i, g10, g11, g12, arch);
}
   23ae2:	b015      	add	sp, #84	; 0x54
   23ae4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
         OPUS_MOVE(y+overlap, x+overlap, N-overlap);
   23ae8:	f011 bad8 	b.w	3509c <memmove>
   g00 = MULT16_16_P15(g0, gains[tapset0][0]);
   23aec:	4c8f      	ldr	r4, [pc, #572]	; (23d2c <comb_filter+0x27c>)
   g10 = MULT16_16_P15(g1, gains[tapset1][0]);
   23aee:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   T1 = IMAX(T1, COMBFILTER_MINPERIOD);
   23af0:	2b0f      	cmp	r3, #15
   g00 = MULT16_16_P15(g0, gains[tapset0][0]);
   23af2:	eb07 0c47 	add.w	ip, r7, r7, lsl #1
   T1 = IMAX(T1, COMBFILTER_MINPERIOD);
   23af6:	bfb8      	it	lt
   23af8:	230f      	movlt	r3, #15
   g00 = MULT16_16_P15(g0, gains[tapset0][0]);
   23afa:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
   g10 = MULT16_16_P15(g1, gains[tapset1][0]);
   23afe:	eb0a 004a 	add.w	r0, sl, sl, lsl #1
   g00 = MULT16_16_P15(g0, gains[tapset0][0]);
   23b02:	eb04 0e0c 	add.w	lr, r4, ip
   g10 = MULT16_16_P15(g1, gains[tapset1][0]);
   23b06:	0040      	lsls	r0, r0, #1
   x1 = x[-T1+1];
   23b08:	ebc3 7183 	rsb	r1, r3, r3, lsl #30
   g10 = MULT16_16_P15(g1, gains[tapset1][0]);
   23b0c:	eb04 0900 	add.w	r9, r4, r0
   x1 = x[-T1+1];
   23b10:	0089      	lsls	r1, r1, #2
   23b12:	460e      	mov	r6, r1
   g01 = MULT16_16_P15(g0, gains[tapset0][1]);
   23b14:	f8be 8002 	ldrh.w	r8, [lr, #2]
   g00 = MULT16_16_P15(g0, gains[tapset0][0]);
   23b18:	f834 c00c 	ldrh.w	ip, [r4, ip]
   T1 = IMAX(T1, COMBFILTER_MINPERIOD);
   23b1c:	9303      	str	r3, [sp, #12]
   g00 = MULT16_16_P15(g0, gains[tapset0][0]);
   23b1e:	f44f 4180 	mov.w	r1, #16384	; 0x4000
   x1 = x[-T1+1];
   23b22:	1d33      	adds	r3, r6, #4
   g10 = MULT16_16_P15(g1, gains[tapset1][0]);
   23b24:	5a24      	ldrh	r4, [r4, r0]
   g02 = MULT16_16_P15(g0, gains[tapset0][2]);
   23b26:	f8be e004 	ldrh.w	lr, [lr, #4]
   g11 = MULT16_16_P15(g1, gains[tapset1][1]);
   23b2a:	f8b9 0002 	ldrh.w	r0, [r9, #2]
   x1 = x[-T1+1];
   23b2e:	930f      	str	r3, [sp, #60]	; 0x3c
   g01 = MULT16_16_P15(g0, gains[tapset0][1]);
   23b30:	fb15 1808 	smlabb	r8, r5, r8, r1
   x3 = x[-T1-1];
   23b34:	1f33      	subs	r3, r6, #4
   g12 = MULT16_16_P15(g1, gains[tapset1][2]);
   23b36:	f8b9 9004 	ldrh.w	r9, [r9, #4]
   x4 = x[-T1-2];
   23b3a:	9612      	str	r6, [sp, #72]	; 0x48
   23b3c:	3e08      	subs	r6, #8
   g11 = MULT16_16_P15(g1, gains[tapset1][1]);
   23b3e:	fb12 1000 	smlabb	r0, r2, r0, r1
   x4 = x[-T1-2];
   23b42:	9611      	str	r6, [sp, #68]	; 0x44
   g02 = MULT16_16_P15(g0, gains[tapset0][2]);
   23b44:	fb15 1e0e 	smlabb	lr, r5, lr, r1
   g01 = MULT16_16_P15(g0, gains[tapset0][1]);
   23b48:	f348 36cf 	sbfx	r6, r8, #15, #16
   g10 = MULT16_16_P15(g1, gains[tapset1][0]);
   23b4c:	fb12 1404 	smlabb	r4, r2, r4, r1
   g00 = MULT16_16_P15(g0, gains[tapset0][0]);
   23b50:	fb15 1c0c 	smlabb	ip, r5, ip, r1
   g11 = MULT16_16_P15(g1, gains[tapset1][1]);
   23b54:	f340 30cf 	sbfx	r0, r0, #15, #16
   g12 = MULT16_16_P15(g1, gains[tapset1][2]);
   23b58:	fb12 1109 	smlabb	r1, r2, r9, r1
   g01 = MULT16_16_P15(g0, gains[tapset0][1]);
   23b5c:	9608      	str	r6, [sp, #32]
   g02 = MULT16_16_P15(g0, gains[tapset0][2]);
   23b5e:	f34e 36cf 	sbfx	r6, lr, #15, #16
   23b62:	9609      	str	r6, [sp, #36]	; 0x24
   g11 = MULT16_16_P15(g1, gains[tapset1][1]);
   23b64:	9001      	str	r0, [sp, #4]
   g00 = MULT16_16_P15(g0, gains[tapset0][0]);
   23b66:	f34c 36cf 	sbfx	r6, ip, #15, #16
   g12 = MULT16_16_P15(g1, gains[tapset1][2]);
   23b6a:	f341 30cf 	sbfx	r0, r1, #15, #16
   x3 = x[-T1-1];
   23b6e:	9310      	str	r3, [sp, #64]	; 0x40
   g00 = MULT16_16_P15(g0, gains[tapset0][0]);
   23b70:	9607      	str	r6, [sp, #28]
   g10 = MULT16_16_P15(g1, gains[tapset1][0]);
   23b72:	4613      	mov	r3, r2
   23b74:	f344 36cf 	sbfx	r6, r4, #15, #16
   T0 = IMAX(T0, COMBFILTER_MINPERIOD);
   23b78:	9a00      	ldr	r2, [sp, #0]
   x1 = x[-T1+1];
   23b7a:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
   g12 = MULT16_16_P15(g1, gains[tapset1][2]);
   23b7c:	9000      	str	r0, [sp, #0]
   x1 = x[-T1+1];
   23b7e:	980d      	ldr	r0, [sp, #52]	; 0x34
   g10 = MULT16_16_P15(g1, gains[tapset1][0]);
   23b80:	9606      	str	r6, [sp, #24]
   x1 = x[-T1+1];
   23b82:	5906      	ldr	r6, [r0, r4]
   x3 = x[-T1-1];
   23b84:	9c10      	ldr	r4, [sp, #64]	; 0x40
   x2 = x[-T1  ];
   23b86:	9912      	ldr	r1, [sp, #72]	; 0x48
   x3 = x[-T1-1];
   23b88:	f850 9004 	ldr.w	r9, [r0, r4]
   x4 = x[-T1-2];
   23b8c:	9c11      	ldr	r4, [sp, #68]	; 0x44
   x1 = x[-T1+1];
   23b8e:	9602      	str	r6, [sp, #8]
   T0 = IMAX(T0, COMBFILTER_MINPERIOD);
   23b90:	2a0f      	cmp	r2, #15
   23b92:	bfb8      	it	lt
   23b94:	220f      	movlt	r2, #15
   if (g0==g1 && T0==T1 && tapset0==tapset1)
   23b96:	429d      	cmp	r5, r3
   x4 = x[-T1-2];
   23b98:	5904      	ldr	r4, [r0, r4]
   x2 = x[-T1  ];
   23b9a:	f850 8001 	ldr.w	r8, [r0, r1]
   if (g0==g1 && T0==T1 && tapset0==tapset1)
   23b9e:	f000 821f 	beq.w	23fe0 <comb_filter+0x530>
   for (i=0;i<overlap;i++)
   23ba2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   23ba4:	2b00      	cmp	r3, #0
   23ba6:	f340 8226 	ble.w	23ff6 <comb_filter+0x546>
   23baa:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   23bac:	ebc2 7282 	rsb	r2, r2, r2, lsl #30
   23bb0:	eb03 0e82 	add.w	lr, r3, r2, lsl #2
   23bb4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   23bb6:	f1ab 0a02 	sub.w	sl, fp, #2
   23bba:	eb0a 0242 	add.w	r2, sl, r2, lsl #1
   23bbe:	920a      	str	r2, [sp, #40]	; 0x28
   23bc0:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   23bc2:	189a      	adds	r2, r3, r2
   23bc4:	3b04      	subs	r3, #4
   23bc6:	9304      	str	r3, [sp, #16]
   23bc8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   23bca:	9205      	str	r2, [sp, #20]
   23bcc:	3b04      	subs	r3, #4
   23bce:	9303      	str	r3, [sp, #12]
   23bd0:	46d4      	mov	ip, sl
   23bd2:	e003      	b.n	23bdc <comb_filter+0x12c>
   23bd4:	46c1      	mov	r9, r8
   23bd6:	f8dd 8008 	ldr.w	r8, [sp, #8]
      x1=x0;
   23bda:	9702      	str	r7, [sp, #8]
      f = MULT16_16_Q15(window[i],window[i]);
   23bdc:	f93c 3f02 	ldrsh.w	r3, [ip, #2]!
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g00),x[i-T0])
   23be0:	9a04      	ldr	r2, [sp, #16]
   23be2:	f8de 1000 	ldr.w	r1, [lr]
   23be6:	f852 af04 	ldr.w	sl, [r2, #4]!
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g01),ADD32(x[i-T0+1],x[i-T0-1]))
   23bea:	f85e 6f04 	ldr.w	r6, [lr, #4]!
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g00),x[i-T0])
   23bee:	9204      	str	r2, [sp, #16]
      f = MULT16_16_Q15(window[i],window[i]);
   23bf0:	fb03 f303 	mul.w	r3, r3, r3
   23bf4:	13db      	asrs	r3, r3, #15
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g00),x[i-T0])
   23bf6:	f5c3 40ff 	rsb	r0, r3, #32640	; 0x7f80
   23bfa:	9a07      	ldr	r2, [sp, #28]
   23bfc:	307f      	adds	r0, #127	; 0x7f
   23bfe:	b200      	sxth	r0, r0
   23c00:	fb00 f702 	mul.w	r7, r0, r2
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g01),ADD32(x[i-T0+1],x[i-T0-1]))
   23c04:	f85e 2c08 	ldr.w	r2, [lr, #-8]
   23c08:	eb06 0b02 	add.w	fp, r6, r2
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g02),ADD32(x[i-T0+2],x[i-T0-2]))
   23c0c:	f85e 2c0c 	ldr.w	r2, [lr, #-12]
   23c10:	f8de 6004 	ldr.w	r6, [lr, #4]
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g00),x[i-T0])
   23c14:	f347 37cf 	sbfx	r7, r7, #15, #16
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g02),ADD32(x[i-T0+2],x[i-T0-2]))
   23c18:	4416      	add	r6, r2
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g00),x[i-T0])
   23c1a:	b28d      	uxth	r5, r1
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g01),ADD32(x[i-T0+1],x[i-T0-1]))
   23c1c:	9a08      	ldr	r2, [sp, #32]
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g00),x[i-T0])
   23c1e:	1409      	asrs	r1, r1, #16
   23c20:	fb07 f505 	mul.w	r5, r7, r5
   23c24:	fb07 f101 	mul.w	r1, r7, r1
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g02),ADD32(x[i-T0+2],x[i-T0-2]))
   23c28:	9f09      	ldr	r7, [sp, #36]	; 0x24
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g00),x[i-T0])
   23c2a:	13ed      	asrs	r5, r5, #15
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g01),ADD32(x[i-T0+1],x[i-T0-1]))
   23c2c:	fb00 f202 	mul.w	r2, r0, r2
   23c30:	f342 32cf 	sbfx	r2, r2, #15, #16
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g02),ADD32(x[i-T0+2],x[i-T0-2]))
   23c34:	fb00 f007 	mul.w	r0, r0, r7
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g00),x[i-T0])
   23c38:	eb05 0141 	add.w	r1, r5, r1, lsl #1
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g01),ADD32(x[i-T0+1],x[i-T0-1]))
   23c3c:	fa1f f58b 	uxth.w	r5, fp
   23c40:	ea4f 4b2b 	mov.w	fp, fp, asr #16
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g02),ADD32(x[i-T0+2],x[i-T0-2]))
   23c44:	f340 30cf 	sbfx	r0, r0, #15, #16
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g01),ADD32(x[i-T0+1],x[i-T0-1]))
   23c48:	fb02 f505 	mul.w	r5, r2, r5
   23c4c:	fb02 fb0b 	mul.w	fp, r2, fp
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g02),ADD32(x[i-T0+2],x[i-T0-2]))
   23c50:	b2b2      	uxth	r2, r6
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g01),ADD32(x[i-T0+1],x[i-T0-1]))
   23c52:	13ef      	asrs	r7, r5, #15
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g02),ADD32(x[i-T0+2],x[i-T0-2]))
   23c54:	fb00 f202 	mul.w	r2, r0, r2
   23c58:	1436      	asrs	r6, r6, #16
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g00),x[i-T0])
   23c5a:	4451      	add	r1, sl
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g02),ADD32(x[i-T0+2],x[i-T0-2]))
   23c5c:	13d2      	asrs	r2, r2, #15
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g01),ADD32(x[i-T0+1],x[i-T0-1]))
   23c5e:	eb07 0a4b 	add.w	sl, r7, fp, lsl #1
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g02),ADD32(x[i-T0+2],x[i-T0-2]))
   23c62:	fb00 f606 	mul.w	r6, r0, r6
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g01),ADD32(x[i-T0+1],x[i-T0-1]))
   23c66:	448a      	add	sl, r1
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g02),ADD32(x[i-T0+2],x[i-T0-2]))
   23c68:	eb02 0646 	add.w	r6, r2, r6, lsl #1
               + MULT16_32_Q15(MULT16_16_Q15(f,g12),ADD32(x0,x4));
   23c6c:	9900      	ldr	r1, [sp, #0]
               + MULT16_32_Q15(MULT16_16_Q15(f,g10),x2)
   23c6e:	9d06      	ldr	r5, [sp, #24]
               + MULT16_32_Q15(MULT16_16_Q15(f,g11),ADD32(x1,x3))
   23c70:	9a01      	ldr	r2, [sp, #4]
      x0=x[i-T1+2];
   23c72:	9805      	ldr	r0, [sp, #20]
      f = MULT16_16_Q15(window[i],window[i]);
   23c74:	b21b      	sxth	r3, r3
               + MULT16_32_Q15(MULT16_16_Q15(f,g10),x2)
   23c76:	fb03 f505 	mul.w	r5, r3, r5
               + MULT16_32_Q15(MULT16_16_Q15(f,g11),ADD32(x1,x3))
   23c7a:	fb03 f202 	mul.w	r2, r3, r2
               + MULT16_32_Q15(MULT16_16_Q15(f,g12),ADD32(x0,x4));
   23c7e:	fb03 f301 	mul.w	r3, r3, r1
               + MULT16_32_Q15(MULT16_16_Q15(f,g11),ADD32(x1,x3))
   23c82:	9902      	ldr	r1, [sp, #8]
      x0=x[i-T1+2];
   23c84:	f850 7f04 	ldr.w	r7, [r0, #4]!
   23c88:	9005      	str	r0, [sp, #20]
               + MULT16_32_Q15(MULT16_16_Q15(f,g10),x2)
   23c8a:	f345 35cf 	sbfx	r5, r5, #15, #16
   23c8e:	fa1f fb88 	uxth.w	fp, r8
   23c92:	fb05 fb0b 	mul.w	fp, r5, fp
               + MULT16_32_Q15(MULT16_16_Q15(f,g11),ADD32(x1,x3))
   23c96:	4449      	add	r1, r9
               + MULT16_32_Q15(MULT16_16_Q15(f,g10),x2)
   23c98:	ea4f 4028 	mov.w	r0, r8, asr #16
   23c9c:	fb05 f500 	mul.w	r5, r5, r0
               + MULT16_32_Q15(MULT16_16_Q15(f,g12),ADD32(x0,x4));
   23ca0:	443c      	add	r4, r7
               + MULT16_32_Q15(MULT16_16_Q15(f,g11),ADD32(x1,x3))
   23ca2:	f342 32cf 	sbfx	r2, r2, #15, #16
   23ca6:	b288      	uxth	r0, r1
               + MULT16_32_Q15(MULT16_16_Q15(f,g10),x2)
   23ca8:	ea4f 3beb 	mov.w	fp, fp, asr #15
               + MULT16_32_Q15(MULT16_16_Q15(f,g12),ADD32(x0,x4));
   23cac:	f343 33cf 	sbfx	r3, r3, #15, #16
               + MULT16_32_Q15(MULT16_16_Q15(f,g10),x2)
   23cb0:	eb0b 0b45 	add.w	fp, fp, r5, lsl #1
               + MULT16_32_Q15(MULT16_16_Q15(f,g11),ADD32(x1,x3))
   23cb4:	fb02 f000 	mul.w	r0, r2, r0
               + MULT16_32_Q15(MULT16_16_Q15(f,g12),ADD32(x0,x4));
   23cb8:	b2a5      	uxth	r5, r4
               + MULT16_32_Q15(MULT16_16_Q15(f,g11),ADD32(x1,x3))
   23cba:	1409      	asrs	r1, r1, #16
               + MULT16_32_Q15(MULT16_16_Q15(f,g12),ADD32(x0,x4));
   23cbc:	fb03 f505 	mul.w	r5, r3, r5
   23cc0:	1424      	asrs	r4, r4, #16
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g02),ADD32(x[i-T0+2],x[i-T0-2]))
   23cc2:	4456      	add	r6, sl
               + MULT16_32_Q15(MULT16_16_Q15(f,g11),ADD32(x1,x3))
   23cc4:	13c0      	asrs	r0, r0, #15
   23cc6:	fb02 f101 	mul.w	r1, r2, r1
               + MULT16_32_Q15(MULT16_16_Q15(f,g12),ADD32(x0,x4));
   23cca:	fb03 f304 	mul.w	r3, r3, r4
               + MULT16_32_Q15(MULT16_16_Q15(f,g10),x2)
   23cce:	445e      	add	r6, fp
               + MULT16_32_Q15(MULT16_16_Q15(f,g11),ADD32(x1,x3))
   23cd0:	eb00 0141 	add.w	r1, r0, r1, lsl #1
               + MULT16_32_Q15(MULT16_16_Q15(f,g12),ADD32(x0,x4));
   23cd4:	13ed      	asrs	r5, r5, #15
   23cd6:	eb05 0343 	add.w	r3, r5, r3, lsl #1
               + MULT16_32_Q15(MULT16_16_Q15(f,g11),ADD32(x1,x3))
   23cda:	440e      	add	r6, r1
               + MULT16_32_Q15(MULT16_16_Q15(f,g12),ADD32(x0,x4));
   23cdc:	441e      	add	r6, r3
      y[i] = SATURATE(y[i], SIG_SAT);
   23cde:	4b14      	ldr	r3, [pc, #80]	; (23d30 <comb_filter+0x280>)
   23ce0:	429e      	cmp	r6, r3
   23ce2:	bfb8      	it	lt
   23ce4:	461e      	movlt	r6, r3
   23ce6:	4b13      	ldr	r3, [pc, #76]	; (23d34 <comb_filter+0x284>)
   23ce8:	429e      	cmp	r6, r3
   23cea:	bfa8      	it	ge
   23cec:	461e      	movge	r6, r3
   23cee:	9b03      	ldr	r3, [sp, #12]
   23cf0:	f843 6f04 	str.w	r6, [r3, #4]!
   23cf4:	9303      	str	r3, [sp, #12]
   for (i=0;i<overlap;i++)
   23cf6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   23cf8:	4563      	cmp	r3, ip
   23cfa:	464c      	mov	r4, r9
   23cfc:	f47f af6a 	bne.w	23bd4 <comb_filter+0x124>
   23d00:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   if (g1==0)
   23d02:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   23d04:	b9c3      	cbnz	r3, 23d38 <comb_filter+0x288>
      if (x!=y)
   23d06:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   23d08:	9c0e      	ldr	r4, [sp, #56]	; 0x38
   23d0a:	42a3      	cmp	r3, r4
   23d0c:	f000 8165 	beq.w	23fda <comb_filter+0x52a>
         OPUS_MOVE(y+overlap, x+overlap, N-overlap);
   23d10:	990c      	ldr	r1, [sp, #48]	; 0x30
   23d12:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   23d14:	0088      	lsls	r0, r1, #2
   23d16:	4403      	add	r3, r0
   23d18:	1a52      	subs	r2, r2, r1
   23d1a:	4404      	add	r4, r0
   23d1c:	0092      	lsls	r2, r2, #2
   23d1e:	4619      	mov	r1, r3
   23d20:	4620      	mov	r0, r4
}
   23d22:	b015      	add	sp, #84	; 0x54
   23d24:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
         OPUS_MOVE(y+overlap, x+overlap, N-overlap);
   23d28:	f011 b9b8 	b.w	3509c <memmove>
   23d2c:	000378b4 	.word	0x000378b4
   23d30:	ee1e5d00 	.word	0xee1e5d00
   23d34:	11e1a300 	.word	0x11e1a300
   comb_filter_const(y+i, x+i, T1, N-i, g10, g11, g12, arch);
   23d38:	990d      	ldr	r1, [sp, #52]	; 0x34
   x2 = SHL32(x[-T], 1);
   23d3a:	9d12      	ldr	r5, [sp, #72]	; 0x48
   x1 = SHL32(x[-T+1], 1);
   23d3c:	980f      	ldr	r0, [sp, #60]	; 0x3c
   comb_filter_const(y+i, x+i, T1, N-i, g10, g11, g12, arch);
   23d3e:	0093      	lsls	r3, r2, #2
   23d40:	4419      	add	r1, r3
   23d42:	4688      	mov	r8, r1
   23d44:	9913      	ldr	r1, [sp, #76]	; 0x4c
   x1 = SHL32(x[-T+1], 1);
   23d46:	f858 0000 	ldr.w	r0, [r8, r0]
   x2 = SHL32(x[-T], 1);
   23d4a:	f858 7005 	ldr.w	r7, [r8, r5]
   comb_filter_const(y+i, x+i, T1, N-i, g10, g11, g12, arch);
   23d4e:	1a8a      	subs	r2, r1, r2
   x4 = SHL32(x[-T-2], 1);
   23d50:	9911      	ldr	r1, [sp, #68]	; 0x44
   23d52:	f858 4001 	ldr.w	r4, [r8, r1]
   x3 = SHL32(x[-T-1], 1);
   23d56:	9910      	ldr	r1, [sp, #64]	; 0x40
   23d58:	f858 1001 	ldr.w	r1, [r8, r1]
   for (i=0;i<N-4;i+=5)
   23d5c:	3a04      	subs	r2, #4
   x4 = SHL32(x[-T-2], 1);
   23d5e:	ea4f 0b44 	mov.w	fp, r4, lsl #1
   x3 = SHL32(x[-T-1], 1);
   23d62:	004c      	lsls	r4, r1, #1
   comb_filter_const(y+i, x+i, T1, N-i, g10, g11, g12, arch);
   23d64:	990e      	ldr	r1, [sp, #56]	; 0x38
   for (i=0;i<N-4;i+=5)
   23d66:	9209      	str	r2, [sp, #36]	; 0x24
   23d68:	2a00      	cmp	r2, #0
   x1 = SHL32(x[-T+1], 1);
   23d6a:	ea4f 0040 	mov.w	r0, r0, lsl #1
   comb_filter_const(y+i, x+i, T1, N-i, g10, g11, g12, arch);
   23d6e:	4419      	add	r1, r3
   x2 = SHL32(x[-T], 1);
   23d70:	ea4f 0e47 	mov.w	lr, r7, lsl #1
   23d74:	eb08 0905 	add.w	r9, r8, r5
   for (i=0;i<N-4;i+=5)
   23d78:	f340 812f 	ble.w	23fda <comb_filter+0x52a>
   23d7c:	2300      	movs	r3, #0
   23d7e:	9308      	str	r3, [sp, #32]
   23d80:	f8dd a018 	ldr.w	sl, [sp, #24]
   23d84:	9104      	str	r1, [sp, #16]
   23d86:	fa1f f38e 	uxth.w	r3, lr
   23d8a:	9305      	str	r3, [sp, #20]
   23d8c:	9402      	str	r4, [sp, #8]
      x0=SHL32(x[i-T+2],1);
   23d8e:	f8d9 1008 	ldr.w	r1, [r9, #8]
      t = MAC16_32_Q16(t, g11, ADD32(x1,x3));
   23d92:	9b02      	ldr	r3, [sp, #8]
   23d94:	9e01      	ldr	r6, [sp, #4]
      t = MAC16_32_Q16(x[i], g10, x2);
   23d96:	f8d8 2000 	ldr.w	r2, [r8]
      x0=SHL32(x[i-T+2],1);
   23d9a:	004d      	lsls	r5, r1, #1
      t = MAC16_32_Q16(t, g12, ADD32(x0,x4));
   23d9c:	b2a9      	uxth	r1, r5
   23d9e:	460c      	mov	r4, r1
   23da0:	9406      	str	r4, [sp, #24]
      t = MAC16_32_Q16(t, g11, ADD32(x1,x3));
   23da2:	1819      	adds	r1, r3, r0
      t = MAC16_32_Q16(t, g12, ADD32(x0,x4));
   23da4:	445c      	add	r4, fp
   23da6:	9b00      	ldr	r3, [sp, #0]
   23da8:	9503      	str	r5, [sp, #12]
      t = MAC16_32_Q16(x[i], g10, x2);
   23daa:	fa1f fc8e 	uxth.w	ip, lr
      t = MAC16_32_Q16(t, g11, ADD32(x1,x3));
   23dae:	b28f      	uxth	r7, r1
      t = MAC16_32_Q16(t, g12, ADD32(x0,x4));
   23db0:	b2a4      	uxth	r4, r4
      t = MAC16_32_Q16(t, g11, ADD32(x1,x3));
   23db2:	fb06 f707 	mul.w	r7, r6, r7
      t = MAC16_32_Q16(t, g12, ADD32(x0,x4));
   23db6:	fb03 f404 	mul.w	r4, r3, r4
      t = MAC16_32_Q16(x[i], g10, x2);
   23dba:	fb0a fc0c 	mul.w	ip, sl, ip
      t = MAC16_32_Q16(t, g11, ADD32(x1,x3));
   23dbe:	9b01      	ldr	r3, [sp, #4]
      t = MAC16_32_Q16(x[i], g10, x2);
   23dc0:	ea4f 4c2c 	mov.w	ip, ip, asr #16
   23dc4:	ea4f 462e 	mov.w	r6, lr, asr #16
      t = MAC16_32_Q16(t, g11, ADD32(x1,x3));
   23dc8:	1409      	asrs	r1, r1, #16
   23dca:	143f      	asrs	r7, r7, #16
   23dcc:	fb11 7703 	smlabb	r7, r1, r3, r7
      t = MAC16_32_Q16(t, g12, ADD32(x0,x4));
   23dd0:	44ab      	add	fp, r5
   23dd2:	9900      	ldr	r1, [sp, #0]
      y[i] = t;
   23dd4:	9d04      	ldr	r5, [sp, #16]
      t = MAC16_32_Q16(x[i], g10, x2);
   23dd6:	fb16 c60a 	smlabb	r6, r6, sl, ip
      t = MAC16_32_Q16(t, g12, ADD32(x0,x4));
   23dda:	1424      	asrs	r4, r4, #16
      t = MAC16_32_Q16(x[i], g10, x2);
   23ddc:	4416      	add	r6, r2
      t = MAC16_32_Q16(t, g12, ADD32(x0,x4));
   23dde:	ea4f 4b2b 	mov.w	fp, fp, asr #16
   23de2:	fb1b 4b01 	smlabb	fp, fp, r1, r4
      t = MAC16_32_Q16(t, g11, ADD32(x1,x3));
   23de6:	443e      	add	r6, r7
      t = SATURATE(t, SIG_SAT);
   23de8:	4984      	ldr	r1, [pc, #528]	; (23ffc <comb_filter+0x54c>)
      y[i] = t;
   23dea:	4c85      	ldr	r4, [pc, #532]	; (24000 <comb_filter+0x550>)
      t = MAC16_32_Q16(t, g12, ADD32(x0,x4));
   23dec:	445e      	add	r6, fp
      t = SATURATE(t, SIG_SAT);
   23dee:	428e      	cmp	r6, r1
   23df0:	bfb8      	it	lt
   23df2:	460e      	movlt	r6, r1
      y[i] = t;
   23df4:	42a6      	cmp	r6, r4
   23df6:	bfa8      	it	ge
   23df8:	4626      	movge	r6, r4
   23dfa:	602e      	str	r6, [r5, #0]
      x4=SHL32(x[i-T+3],1);
   23dfc:	f8d9 100c 	ldr.w	r1, [r9, #12]
      t = MAC16_32_Q16(x[i+1], g10, x1);
   23e00:	f8d8 2004 	ldr.w	r2, [r8, #4]
      t = MAC16_32_Q16(t, g11, ADD32(x0,x2));
   23e04:	e9dd 4605 	ldrd	r4, r6, [sp, #20]
      x4=SHL32(x[i-T+3],1);
   23e08:	ea4f 0b41 	mov.w	fp, r1, lsl #1
      t = MAC16_32_Q16(t, g12, ADD32(x4,x3));
   23e0c:	fa1f f78b 	uxth.w	r7, fp
   23e10:	4639      	mov	r1, r7
      t = MAC16_32_Q16(t, g11, ADD32(x0,x2));
   23e12:	4434      	add	r4, r6
      t = MAC16_32_Q16(x[i+1], g10, x1);
   23e14:	b287      	uxth	r7, r0
      t = MAC16_32_Q16(t, g12, ADD32(x4,x3));
   23e16:	9e02      	ldr	r6, [sp, #8]
   23e18:	9107      	str	r1, [sp, #28]
      t = MAC16_32_Q16(x[i+1], g10, x1);
   23e1a:	fb0a f707 	mul.w	r7, sl, r7
      t = MAC16_32_Q16(t, g11, ADD32(x0,x2));
   23e1e:	b2a4      	uxth	r4, r4
      t = MAC16_32_Q16(t, g12, ADD32(x4,x3));
   23e20:	4431      	add	r1, r6
      t = MAC16_32_Q16(x[i+1], g10, x1);
   23e22:	143f      	asrs	r7, r7, #16
      t = MAC16_32_Q16(t, g11, ADD32(x0,x2));
   23e24:	fb03 f404 	mul.w	r4, r3, r4
      t = MAC16_32_Q16(x[i+1], g10, x1);
   23e28:	1406      	asrs	r6, r0, #16
      t = MAC16_32_Q16(t, g12, ADD32(x4,x3));
   23e2a:	9b00      	ldr	r3, [sp, #0]
      t = MAC16_32_Q16(x[i+1], g10, x1);
   23e2c:	fb16 760a 	smlabb	r6, r6, sl, r7
      t = MAC16_32_Q16(t, g12, ADD32(x4,x3));
   23e30:	b289      	uxth	r1, r1
      t = MAC16_32_Q16(t, g11, ADD32(x0,x2));
   23e32:	9f03      	ldr	r7, [sp, #12]
      t = MAC16_32_Q16(t, g12, ADD32(x4,x3));
   23e34:	fb03 f101 	mul.w	r1, r3, r1
   23e38:	9b02      	ldr	r3, [sp, #8]
      t = MAC16_32_Q16(t, g11, ADD32(x0,x2));
   23e3a:	eb07 0c0e 	add.w	ip, r7, lr
   23e3e:	9f01      	ldr	r7, [sp, #4]
   23e40:	ea4f 4c2c 	mov.w	ip, ip, asr #16
      t = MAC16_32_Q16(x[i+1], g10, x1);
   23e44:	4416      	add	r6, r2
      t = MAC16_32_Q16(t, g12, ADD32(x4,x3));
   23e46:	445b      	add	r3, fp
   23e48:	9a00      	ldr	r2, [sp, #0]
      t = MAC16_32_Q16(t, g11, ADD32(x0,x2));
   23e4a:	1424      	asrs	r4, r4, #16
   23e4c:	fb1c 4407 	smlabb	r4, ip, r7, r4
      t = MAC16_32_Q16(t, g12, ADD32(x4,x3));
   23e50:	1409      	asrs	r1, r1, #16
   23e52:	141b      	asrs	r3, r3, #16
   23e54:	fb13 1302 	smlabb	r3, r3, r2, r1
      t = MAC16_32_Q16(t, g11, ADD32(x0,x2));
   23e58:	4426      	add	r6, r4
      t = SATURATE(t, SIG_SAT);
   23e5a:	4968      	ldr	r1, [pc, #416]	; (23ffc <comb_filter+0x54c>)
      y[i+1] = t;
   23e5c:	4c68      	ldr	r4, [pc, #416]	; (24000 <comb_filter+0x550>)
      t = MAC16_32_Q16(x[i+2], g10, x0);
   23e5e:	f8bd 200c 	ldrh.w	r2, [sp, #12]
      t = MAC16_32_Q16(t, g12, ADD32(x4,x3));
   23e62:	4433      	add	r3, r6
      t = SATURATE(t, SIG_SAT);
   23e64:	428b      	cmp	r3, r1
   23e66:	bfb8      	it	lt
   23e68:	460b      	movlt	r3, r1
      y[i+1] = t;
   23e6a:	42a3      	cmp	r3, r4
   23e6c:	bfa8      	it	ge
   23e6e:	4623      	movge	r3, r4
   23e70:	606b      	str	r3, [r5, #4]
      x3=SHL32(x[i-T+4],1);
   23e72:	f8d9 3010 	ldr.w	r3, [r9, #16]
      t = MAC16_32_Q16(t, g11, ADD32(x4,x1));
   23e76:	9d07      	ldr	r5, [sp, #28]
      x3=SHL32(x[i-T+4],1);
   23e78:	005b      	lsls	r3, r3, #1
   23e7a:	9302      	str	r3, [sp, #8]
      t = MAC16_32_Q16(t, g11, ADD32(x1,x3));
   23e7c:	b281      	uxth	r1, r0
      t = MAC16_32_Q16(t, g12, ADD32(x3,x2));
   23e7e:	f8bd 4008 	ldrh.w	r4, [sp, #8]
      t = MAC16_32_Q16(t, g11, ADD32(x4,x1));
   23e82:	eb01 0c05 	add.w	ip, r1, r5
      t = MAC16_32_Q16(t, g12, ADD32(x3,x2));
   23e86:	9d05      	ldr	r5, [sp, #20]
      t = MAC16_32_Q16(x[i+2], g10, x0);
   23e88:	fb0a f202 	mul.w	r2, sl, r2
      t = MAC16_32_Q16(t, g12, ADD32(x3,x2));
   23e8c:	192f      	adds	r7, r5, r4
      t = MAC16_32_Q16(x[i+2], g10, x0);
   23e8e:	1416      	asrs	r6, r2, #16
   23e90:	9d03      	ldr	r5, [sp, #12]
      t = MAC16_32_Q16(t, g11, ADD32(x4,x1));
   23e92:	9a01      	ldr	r2, [sp, #4]
   23e94:	fa1f fc8c 	uxth.w	ip, ip
   23e98:	fb02 fc0c 	mul.w	ip, r2, ip
      t = MAC16_32_Q16(t, g12, ADD32(x3,x2));
   23e9c:	eb03 020e 	add.w	r2, r3, lr
      t = MAC16_32_Q16(x[i+2], g10, x0);
   23ea0:	ea4f 4e25 	mov.w	lr, r5, asr #16
      t = MAC16_32_Q16(t, g12, ADD32(x3,x2));
   23ea4:	9b00      	ldr	r3, [sp, #0]
      t = MAC16_32_Q16(x[i+2], g10, x0);
   23ea6:	fb1e 6e0a 	smlabb	lr, lr, sl, r6
   23eaa:	f8d8 6008 	ldr.w	r6, [r8, #8]
      t = MAC16_32_Q16(t, g12, ADD32(x3,x2));
   23eae:	b2bf      	uxth	r7, r7
   23eb0:	fb03 f707 	mul.w	r7, r3, r7
      t = MAC16_32_Q16(x[i+2], g10, x0);
   23eb4:	44b6      	add	lr, r6
      t = MAC16_32_Q16(t, g11, ADD32(x4,x1));
   23eb6:	9b01      	ldr	r3, [sp, #4]
   23eb8:	eb0b 0600 	add.w	r6, fp, r0
   23ebc:	1436      	asrs	r6, r6, #16
   23ebe:	ea4f 4c2c 	mov.w	ip, ip, asr #16
   23ec2:	fb16 cc03 	smlabb	ip, r6, r3, ip
      t = MAC16_32_Q16(t, g12, ADD32(x3,x2));
   23ec6:	9e00      	ldr	r6, [sp, #0]
   23ec8:	143f      	asrs	r7, r7, #16
   23eca:	1412      	asrs	r2, r2, #16
   23ecc:	fb12 7206 	smlabb	r2, r2, r6, r7
      t = MAC16_32_Q16(t, g11, ADD32(x4,x1));
   23ed0:	44e6      	add	lr, ip
      t = SATURATE(t, SIG_SAT);
   23ed2:	4e4a      	ldr	r6, [pc, #296]	; (23ffc <comb_filter+0x54c>)
      y[i+2] = t;
   23ed4:	4f4a      	ldr	r7, [pc, #296]	; (24000 <comb_filter+0x550>)
      t = MAC16_32_Q16(t, g12, ADD32(x3,x2));
   23ed6:	4472      	add	r2, lr
      t = SATURATE(t, SIG_SAT);
   23ed8:	42b2      	cmp	r2, r6
   23eda:	bfb8      	it	lt
   23edc:	4632      	movlt	r2, r6
      y[i+2] = t;
   23ede:	42ba      	cmp	r2, r7
   23ee0:	9e04      	ldr	r6, [sp, #16]
   23ee2:	bfa8      	it	ge
   23ee4:	463a      	movge	r2, r7
   23ee6:	60b2      	str	r2, [r6, #8]
      x2=SHL32(x[i-T+5],1);
   23ee8:	f8d9 2014 	ldr.w	r2, [r9, #20]
      t = MAC16_32_Q16(x[i+3], g10, x4);
   23eec:	f8d8 600c 	ldr.w	r6, [r8, #12]
      x2=SHL32(x[i-T+5],1);
   23ef0:	ea4f 0e42 	mov.w	lr, r2, lsl #1
      t = MAC16_32_Q16(t, g11, ADD32(x3,x0));
   23ef4:	9a06      	ldr	r2, [sp, #24]
   23ef6:	4414      	add	r4, r2
   23ef8:	b2a4      	uxth	r4, r4
      t = MAC16_32_Q16(t, g11, ADD32(x4,x1));
   23efa:	461d      	mov	r5, r3
      t = MAC16_32_Q16(t, g11, ADD32(x3,x0));
   23efc:	fb03 f404 	mul.w	r4, r3, r4
   23f00:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
      t = MAC16_32_Q16(t, g12, ADD32(x2,x1));
   23f04:	fa1f fc8e 	uxth.w	ip, lr
      t = MAC16_32_Q16(t, g11, ADD32(x3,x0));
   23f08:	441a      	add	r2, r3
      t = MAC16_32_Q16(x[i+3], g10, x4);
   23f0a:	fa1f f78b 	uxth.w	r7, fp
      t = MAC16_32_Q16(t, g12, ADD32(x2,x1));
   23f0e:	9b00      	ldr	r3, [sp, #0]
   23f10:	f8cd c014 	str.w	ip, [sp, #20]
   23f14:	4461      	add	r1, ip
      t = MAC16_32_Q16(t, g11, ADD32(x3,x0));
   23f16:	1412      	asrs	r2, r2, #16
      t = MAC16_32_Q16(x[i+3], g10, x4);
   23f18:	fb0a f707 	mul.w	r7, sl, r7
      t = MAC16_32_Q16(t, g11, ADD32(x3,x0));
   23f1c:	1424      	asrs	r4, r4, #16
   23f1e:	fb12 4405 	smlabb	r4, r2, r5, r4
      t = MAC16_32_Q16(x[i+3], g10, x4);
   23f22:	143f      	asrs	r7, r7, #16
   23f24:	ea4f 422b 	mov.w	r2, fp, asr #16
      t = MAC16_32_Q16(t, g12, ADD32(x2,x1));
   23f28:	b289      	uxth	r1, r1
   23f2a:	fb03 f101 	mul.w	r1, r3, r1
      t = MAC16_32_Q16(x[i+3], g10, x4);
   23f2e:	fb12 770a 	smlabb	r7, r2, sl, r7
      t = MAC16_32_Q16(t, g12, ADD32(x2,x1));
   23f32:	4470      	add	r0, lr
      t = MAC16_32_Q16(x[i+3], g10, x4);
   23f34:	4437      	add	r7, r6
      t = MAC16_32_Q16(t, g12, ADD32(x2,x1));
   23f36:	1409      	asrs	r1, r1, #16
   23f38:	1400      	asrs	r0, r0, #16
   23f3a:	fb10 1003 	smlabb	r0, r0, r3, r1
      t = MAC16_32_Q16(t, g11, ADD32(x3,x0));
   23f3e:	443c      	add	r4, r7
      t = SATURATE(t, SIG_SAT);
   23f40:	492e      	ldr	r1, [pc, #184]	; (23ffc <comb_filter+0x54c>)
      y[i+3] = t;
   23f42:	4f2f      	ldr	r7, [pc, #188]	; (24000 <comb_filter+0x550>)
   23f44:	9b04      	ldr	r3, [sp, #16]
      t = MAC16_32_Q16(t, g12, ADD32(x1,x0));
   23f46:	9a06      	ldr	r2, [sp, #24]
      t = MAC16_32_Q16(t, g11, ADD32(x2,x4));
   23f48:	9d01      	ldr	r5, [sp, #4]
      t = MAC16_32_Q16(x[i+4], g10, x3);
   23f4a:	f8bd 6008 	ldrh.w	r6, [sp, #8]
      t = MAC16_32_Q16(t, g12, ADD32(x2,x1));
   23f4e:	4404      	add	r4, r0
      t = SATURATE(t, SIG_SAT);
   23f50:	428c      	cmp	r4, r1
   23f52:	bfb8      	it	lt
   23f54:	460c      	movlt	r4, r1
      y[i+3] = t;
   23f56:	42bc      	cmp	r4, r7
   23f58:	bfa8      	it	ge
   23f5a:	463c      	movge	r4, r7
   23f5c:	60dc      	str	r4, [r3, #12]
      x1=SHL32(x[i-T+6],1);
   23f5e:	f8d9 0018 	ldr.w	r0, [r9, #24]
      t = MAC16_32_Q16(t, g11, ADD32(x2,x4));
   23f62:	9c07      	ldr	r4, [sp, #28]
      x1=SHL32(x[i-T+6],1);
   23f64:	0040      	lsls	r0, r0, #1
      t = MAC16_32_Q16(t, g11, ADD32(x2,x4));
   23f66:	4464      	add	r4, ip
      t = MAC16_32_Q16(t, g12, ADD32(x1,x0));
   23f68:	1811      	adds	r1, r2, r0
      t = MAC16_32_Q16(t, g11, ADD32(x2,x4));
   23f6a:	b2a4      	uxth	r4, r4
      t = MAC16_32_Q16(x[i+4], g10, x3);
   23f6c:	9a02      	ldr	r2, [sp, #8]
      t = MAC16_32_Q16(t, g11, ADD32(x2,x4));
   23f6e:	fb05 f404 	mul.w	r4, r5, r4
   23f72:	eb0b 070e 	add.w	r7, fp, lr
      t = MAC16_32_Q16(x[i+4], g10, x3);
   23f76:	ea4f 4c22 	mov.w	ip, r2, asr #16
      t = MAC16_32_Q16(t, g11, ADD32(x2,x4));
   23f7a:	143f      	asrs	r7, r7, #16
      t = MAC16_32_Q16(x[i+4], g10, x3);
   23f7c:	fb0a f606 	mul.w	r6, sl, r6
      t = MAC16_32_Q16(t, g11, ADD32(x2,x4));
   23f80:	1424      	asrs	r4, r4, #16
      t = MAC16_32_Q16(t, g12, ADD32(x1,x0));
   23f82:	9a00      	ldr	r2, [sp, #0]
      t = MAC16_32_Q16(t, g11, ADD32(x2,x4));
   23f84:	fb17 4405 	smlabb	r4, r7, r5, r4
      t = MAC16_32_Q16(t, g12, ADD32(x1,x0));
   23f88:	b289      	uxth	r1, r1
      t = MAC16_32_Q16(x[i+4], g10, x3);
   23f8a:	f8d8 5010 	ldr.w	r5, [r8, #16]
      y[i+4] = t;
   23f8e:	4f1c      	ldr	r7, [pc, #112]	; (24000 <comb_filter+0x550>)
      t = MAC16_32_Q16(x[i+4], g10, x3);
   23f90:	1436      	asrs	r6, r6, #16
      t = MAC16_32_Q16(t, g12, ADD32(x1,x0));
   23f92:	fb02 f201 	mul.w	r2, r2, r1
      t = MAC16_32_Q16(x[i+4], g10, x3);
   23f96:	fb1c 660a 	smlabb	r6, ip, sl, r6
      t = MAC16_32_Q16(t, g12, ADD32(x1,x0));
   23f9a:	9903      	ldr	r1, [sp, #12]
      t = MAC16_32_Q16(x[i+4], g10, x3);
   23f9c:	442e      	add	r6, r5
      t = MAC16_32_Q16(t, g11, ADD32(x2,x4));
   23f9e:	4426      	add	r6, r4
      t = MAC16_32_Q16(t, g12, ADD32(x1,x0));
   23fa0:	4401      	add	r1, r0
   23fa2:	9c00      	ldr	r4, [sp, #0]
   23fa4:	1412      	asrs	r2, r2, #16
   23fa6:	1409      	asrs	r1, r1, #16
   23fa8:	fb11 2104 	smlabb	r1, r1, r4, r2
      t = SATURATE(t, SIG_SAT);
   23fac:	4a13      	ldr	r2, [pc, #76]	; (23ffc <comb_filter+0x54c>)
   for (i=0;i<N-4;i+=5)
   23fae:	9c08      	ldr	r4, [sp, #32]
      t = MAC16_32_Q16(t, g12, ADD32(x1,x0));
   23fb0:	440e      	add	r6, r1
      t = SATURATE(t, SIG_SAT);
   23fb2:	4296      	cmp	r6, r2
   23fb4:	bfb8      	it	lt
   23fb6:	4616      	movlt	r6, r2
   23fb8:	f103 0214 	add.w	r2, r3, #20
   23fbc:	9204      	str	r2, [sp, #16]
   for (i=0;i<N-4;i+=5)
   23fbe:	9a09      	ldr	r2, [sp, #36]	; 0x24
   23fc0:	3405      	adds	r4, #5
      y[i+4] = t;
   23fc2:	42be      	cmp	r6, r7
   23fc4:	bfa8      	it	ge
   23fc6:	463e      	movge	r6, r7
   for (i=0;i<N-4;i+=5)
   23fc8:	4294      	cmp	r4, r2
   23fca:	9408      	str	r4, [sp, #32]
   23fcc:	f108 0814 	add.w	r8, r8, #20
      y[i+4] = t;
   23fd0:	611e      	str	r6, [r3, #16]
   23fd2:	f109 0914 	add.w	r9, r9, #20
   for (i=0;i<N-4;i+=5)
   23fd6:	f6ff aeda 	blt.w	23d8e <comb_filter+0x2de>
}
   23fda:	b015      	add	sp, #84	; 0x54
   23fdc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   if (g0==g1 && T0==T1 && tapset0==tapset1)
   23fe0:	9b03      	ldr	r3, [sp, #12]
   23fe2:	429a      	cmp	r2, r3
   23fe4:	f47f addd 	bne.w	23ba2 <comb_filter+0xf2>
   23fe8:	4557      	cmp	r7, sl
   23fea:	f47f adda 	bne.w	23ba2 <comb_filter+0xf2>
      overlap=0;
   23fee:	2300      	movs	r3, #0
   23ff0:	930c      	str	r3, [sp, #48]	; 0x30
   for (i=0;i<overlap;i++)
   23ff2:	461a      	mov	r2, r3
   23ff4:	e685      	b.n	23d02 <comb_filter+0x252>
   23ff6:	2200      	movs	r2, #0
   23ff8:	e683      	b.n	23d02 <comb_filter+0x252>
   23ffa:	bf00      	nop
   23ffc:	ee1e5d00 	.word	0xee1e5d00
   24000:	11e1a300 	.word	0x11e1a300

00024004 <init_caps>:
      {0, -2, 0, -3,    3, 0, 1,-1}, /* 20 ms */
};


void init_caps(const CELTMode *m,int *cap,int LM,int C)
{
   24004:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   int i;
   for (i=0;i<m->nbEBands;i++)
   24008:	6884      	ldr	r4, [r0, #8]
   2400a:	2c00      	cmp	r4, #0
   2400c:	dd20      	ble.n	24050 <init_caps+0x4c>
   {
      int N;
      N=(m->eBands[i+1]-m->eBands[i])<<LM;
      cap[i] = (m->cache.caps[m->nbEBands*(2*LM+C-1)+i]+64)*C*N>>2;
   2400e:	eb03 0c42 	add.w	ip, r3, r2, lsl #1
   24012:	f8d0 e060 	ldr.w	lr, [r0, #96]	; 0x60
   24016:	6987      	ldr	r7, [r0, #24]
   24018:	3904      	subs	r1, #4
   2401a:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
   for (i=0;i<m->nbEBands;i++)
   2401e:	2600      	movs	r6, #0
      cap[i] = (m->cache.caps[m->nbEBands*(2*LM+C-1)+i]+64)*C*N>>2;
   24020:	fb04 e40c 	mla	r4, r4, ip, lr
      N=(m->eBands[i+1]-m->eBands[i])<<LM;
   24024:	f9b7 8000 	ldrsh.w	r8, [r7]
      cap[i] = (m->cache.caps[m->nbEBands*(2*LM+C-1)+i]+64)*C*N>>2;
   24028:	5da5      	ldrb	r5, [r4, r6]
      N=(m->eBands[i+1]-m->eBands[i])<<LM;
   2402a:	f9b7 4002 	ldrsh.w	r4, [r7, #2]
      cap[i] = (m->cache.caps[m->nbEBands*(2*LM+C-1)+i]+64)*C*N>>2;
   2402e:	3540      	adds	r5, #64	; 0x40
      N=(m->eBands[i+1]-m->eBands[i])<<LM;
   24030:	eba4 0408 	sub.w	r4, r4, r8
      cap[i] = (m->cache.caps[m->nbEBands*(2*LM+C-1)+i]+64)*C*N>>2;
   24034:	fb03 f505 	mul.w	r5, r3, r5
      N=(m->eBands[i+1]-m->eBands[i])<<LM;
   24038:	4094      	lsls	r4, r2
      cap[i] = (m->cache.caps[m->nbEBands*(2*LM+C-1)+i]+64)*C*N>>2;
   2403a:	fb04 f405 	mul.w	r4, r4, r5
   2403e:	10a4      	asrs	r4, r4, #2
   24040:	f841 4f04 	str.w	r4, [r1, #4]!
   for (i=0;i<m->nbEBands;i++)
   24044:	6884      	ldr	r4, [r0, #8]
   24046:	3601      	adds	r6, #1
   24048:	42b4      	cmp	r4, r6
   2404a:	f107 0702 	add.w	r7, r7, #2
   2404e:	dce7      	bgt.n	24020 <init_caps+0x1c>
   }
}
   24050:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00024054 <opus_strerror>:
      "corrupted stream",
      "request not implemented",
      "invalid state",
      "memory allocation failed"
   };
   if (error > 0 || error < -7)
   24054:	1dc3      	adds	r3, r0, #7
   24056:	2b07      	cmp	r3, #7
      return "unknown error";
   else
      return error_strings[-error];
   24058:	bf9d      	ittte	ls
   2405a:	4240      	negls	r0, r0
   2405c:	4b02      	ldrls	r3, [pc, #8]	; (24068 <opus_strerror+0x14>)
   2405e:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
      return "unknown error";
   24062:	4802      	ldrhi	r0, [pc, #8]	; (2406c <opus_strerror+0x18>)
}
   24064:	4770      	bx	lr
   24066:	bf00      	nop
   24068:	00037894 	.word	0x00037894
   2406c:	000378c8 	.word	0x000378c8

00024070 <compute_mdcts>:
/** Apply window and compute the MDCT for all sub-frames and
    all channels in a frame */
static void compute_mdcts(const CELTMode *mode, int shortBlocks, celt_sig * OPUS_RESTRICT in,
                          celt_sig * OPUS_RESTRICT out, int C, int CC, int LM, int upsample,
                          int arch)
{
   24070:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   24074:	b08f      	sub	sp, #60	; 0x3c
   24076:	4607      	mov	r7, r0
   24078:	930b      	str	r3, [sp, #44]	; 0x2c
   const int overlap = mode->overlap;
   2407a:	f8d0 a004 	ldr.w	sl, [r0, #4]
   2407e:	6a43      	ldr	r3, [r0, #36]	; 0x24
   24080:	69c0      	ldr	r0, [r0, #28]
   24082:	9004      	str	r0, [sp, #16]
   int N;
   int B;
   int shift;
   int i, b, c;
   if (shortBlocks)
   24084:	f1b1 0800 	subs.w	r8, r1, #0
{
   24088:	981a      	ldr	r0, [sp, #104]	; 0x68
   if (shortBlocks)
   2408a:	d06d      	beq.n	24168 <compute_mdcts+0xf8>
   }
   c=0; do {
      for (b=0;b<B;b++)
      {
         /* Interleaving the sub-frames while doing the MDCTs */
         clt_mdct_forward(&mode->mdct, in+c*(B*N+overlap)+b*N,
   2408c:	fb08 f103 	mul.w	r1, r8, r3
   24090:	e9cd 110c 	strd	r1, r1, [sp, #48]	; 0x30
   24094:	4451      	add	r1, sl
   24096:	dd36      	ble.n	24106 <compute_mdcts+0x96>
   24098:	ea4f 0983 	mov.w	r9, r3, lsl #2
   2409c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   2409e:	9206      	str	r2, [sp, #24]
   240a0:	009b      	lsls	r3, r3, #2
   240a2:	9309      	str	r3, [sp, #36]	; 0x24
   240a4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   240a6:	9305      	str	r3, [sp, #20]
   240a8:	ea4f 0388 	mov.w	r3, r8, lsl #2
   240ac:	9308      	str	r3, [sp, #32]
   c=0; do {
   240ae:	2300      	movs	r3, #0
   240b0:	0089      	lsls	r1, r1, #2
   240b2:	9307      	str	r3, [sp, #28]
   240b4:	463b      	mov	r3, r7
   240b6:	f107 0b38 	add.w	fp, r7, #56	; 0x38
   240ba:	910a      	str	r1, [sp, #40]	; 0x28
   240bc:	4657      	mov	r7, sl
   240be:	469a      	mov	sl, r3
   240c0:	9b08      	ldr	r3, [sp, #32]
   240c2:	9c05      	ldr	r4, [sp, #20]
   240c4:	9d06      	ldr	r5, [sp, #24]
   240c6:	191e      	adds	r6, r3, r4
         clt_mdct_forward(&mode->mdct, in+c*(B*N+overlap)+b*N,
   240c8:	9a1c      	ldr	r2, [sp, #112]	; 0x70
   240ca:	f8da 3034 	ldr.w	r3, [sl, #52]	; 0x34
   240ce:	e9cd 8202 	strd	r8, r2, [sp, #8]
   240d2:	9a04      	ldr	r2, [sp, #16]
   240d4:	4629      	mov	r1, r5
   240d6:	e9cd 7200 	strd	r7, r2, [sp]
   240da:	4658      	mov	r0, fp
   240dc:	4622      	mov	r2, r4
   240de:	3404      	adds	r4, #4
   240e0:	f007 fac2 	bl	2b668 <clt_mdct_forward_c>
      for (b=0;b<B;b++)
   240e4:	42a6      	cmp	r6, r4
   240e6:	444d      	add	r5, r9
   240e8:	d1ee      	bne.n	240c8 <compute_mdcts+0x58>
   240ea:	9a06      	ldr	r2, [sp, #24]
   240ec:	990a      	ldr	r1, [sp, #40]	; 0x28
                          &out[b+c*N*B], mode->window, overlap, shift, B,
                          arch);
      }
   } while (++c<CC);
   240ee:	9b07      	ldr	r3, [sp, #28]
   240f0:	440a      	add	r2, r1
   240f2:	9206      	str	r2, [sp, #24]
   240f4:	9909      	ldr	r1, [sp, #36]	; 0x24
   240f6:	9a05      	ldr	r2, [sp, #20]
   240f8:	440a      	add	r2, r1
   240fa:	9205      	str	r2, [sp, #20]
   240fc:	9a19      	ldr	r2, [sp, #100]	; 0x64
   240fe:	3301      	adds	r3, #1
   24100:	4293      	cmp	r3, r2
   24102:	9307      	str	r3, [sp, #28]
   24104:	dbdc      	blt.n	240c0 <compute_mdcts+0x50>
   if (CC==2&&C==1)
   24106:	9b19      	ldr	r3, [sp, #100]	; 0x64
   24108:	2b02      	cmp	r3, #2
   2410a:	d038      	beq.n	2417e <compute_mdcts+0x10e>
   {
      for (i=0;i<B*N;i++)
         out[i] = ADD32(HALF32(out[i]), HALF32(out[B*N+i]));
   }
   if (upsample != 1)
   2410c:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
   2410e:	2b01      	cmp	r3, #1
   24110:	d027      	beq.n	24162 <compute_mdcts+0xf2>
      c=0; do
      {
         int bound = B*N/upsample;
         for (i=0;i<bound;i++)
            out[c*B*N+i] *= upsample;
         OPUS_CLEAR(&out[c*B*N+bound], B*N-bound);
   24112:	9a0d      	ldr	r2, [sp, #52]	; 0x34
      c=0; do
   24114:	f8dd b060 	ldr.w	fp, [sp, #96]	; 0x60
   24118:	4619      	mov	r1, r3
         int bound = B*N/upsample;
   2411a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   2411c:	fb93 f5f1 	sdiv	r5, r3, r1
         OPUS_CLEAR(&out[c*B*N+bound], B*N-bound);
   24120:	1b56      	subs	r6, r2, r5
   24122:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   24124:	ebc5 7785 	rsb	r7, r5, r5, lsl #30
   24128:	00b6      	lsls	r6, r6, #2
   2412a:	eb02 0485 	add.w	r4, r2, r5, lsl #2
   2412e:	ea4f 0883 	mov.w	r8, r3, lsl #2
   24132:	00bf      	lsls	r7, r7, #2
      c=0; do
   24134:	f04f 0900 	mov.w	r9, #0
   24138:	468a      	mov	sl, r1
         for (i=0;i<bound;i++)
   2413a:	2d00      	cmp	r5, #0
   2413c:	dd07      	ble.n	2414e <compute_mdcts+0xde>
   2413e:	193b      	adds	r3, r7, r4
            out[c*B*N+i] *= upsample;
   24140:	681a      	ldr	r2, [r3, #0]
   24142:	fb0a f202 	mul.w	r2, sl, r2
   24146:	f843 2b04 	str.w	r2, [r3], #4
         for (i=0;i<bound;i++)
   2414a:	42a3      	cmp	r3, r4
   2414c:	d1f8      	bne.n	24140 <compute_mdcts+0xd0>
         OPUS_CLEAR(&out[c*B*N+bound], B*N-bound);
   2414e:	4620      	mov	r0, r4
      } while (++c<C);
   24150:	f109 0901 	add.w	r9, r9, #1
         OPUS_CLEAR(&out[c*B*N+bound], B*N-bound);
   24154:	4632      	mov	r2, r6
   24156:	2100      	movs	r1, #0
   24158:	f011 f804 	bl	35164 <memset>
      } while (++c<C);
   2415c:	45cb      	cmp	fp, r9
   2415e:	4444      	add	r4, r8
   24160:	dceb      	bgt.n	2413a <compute_mdcts+0xca>
   }
}
   24162:	b00f      	add	sp, #60	; 0x3c
   24164:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      shift = mode->maxLM-LM;
   24168:	9904      	ldr	r1, [sp, #16]
      N = mode->shortMdctSize<<LM;
   2416a:	4083      	lsls	r3, r0
      shift = mode->maxLM-LM;
   2416c:	1a09      	subs	r1, r1, r0
   2416e:	9104      	str	r1, [sp, #16]
   24170:	930d      	str	r3, [sp, #52]	; 0x34
         clt_mdct_forward(&mode->mdct, in+c*(B*N+overlap)+b*N,
   24172:	eb0a 0103 	add.w	r1, sl, r3
   24176:	930c      	str	r3, [sp, #48]	; 0x30
      B = 1;
   24178:	f04f 0801 	mov.w	r8, #1
   2417c:	e78c      	b.n	24098 <compute_mdcts+0x28>
   if (CC==2&&C==1)
   2417e:	9b18      	ldr	r3, [sp, #96]	; 0x60
   24180:	2b01      	cmp	r3, #1
   24182:	d1c3      	bne.n	2410c <compute_mdcts+0x9c>
      for (i=0;i<B*N;i++)
   24184:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   24186:	2b00      	cmp	r3, #0
   24188:	ddc0      	ble.n	2410c <compute_mdcts+0x9c>
   2418a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   2418c:	f103 4080 	add.w	r0, r3, #1073741824	; 0x40000000
   24190:	3801      	subs	r0, #1
   24192:	1f11      	subs	r1, r2, #4
   24194:	eb02 0080 	add.w	r0, r2, r0, lsl #2
   24198:	eb01 0483 	add.w	r4, r1, r3, lsl #2
         out[i] = ADD32(HALF32(out[i]), HALF32(out[B*N+i]));
   2419c:	f850 3f04 	ldr.w	r3, [r0, #4]!
   241a0:	f851 2f04 	ldr.w	r2, [r1, #4]!
   241a4:	105b      	asrs	r3, r3, #1
   241a6:	eb03 0362 	add.w	r3, r3, r2, asr #1
      for (i=0;i<B*N;i++)
   241aa:	428c      	cmp	r4, r1
         out[i] = ADD32(HALF32(out[i]), HALF32(out[B*N+i]));
   241ac:	600b      	str	r3, [r1, #0]
      for (i=0;i<B*N;i++)
   241ae:	d1f5      	bne.n	2419c <compute_mdcts+0x12c>
   241b0:	e7ac      	b.n	2410c <compute_mdcts+0x9c>
   241b2:	bf00      	nop

000241b4 <dynalloc_analysis.isra.5>:
      return t2;
   else
      return t0;
}

static opus_val16 dynalloc_analysis(const opus_val16 *bandLogE, const opus_val16 *bandLogE2,
   241b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   241b8:	b09b      	sub	sp, #108	; 0x6c
   241ba:	af00      	add	r7, sp, #0
   opus_int32 tot_boost=0;
   opus_val16 maxDepth;
   VARDECL(opus_val16, follower);
   VARDECL(opus_val16, noise_floor);
   SAVE_STACK;
   ALLOC(follower, C*nbEBands, opus_val16);
   241bc:	4615      	mov	r5, r2
   241be:	f8d7 6094 	ldr.w	r6, [r7, #148]	; 0x94
static opus_val16 dynalloc_analysis(const opus_val16 *bandLogE, const opus_val16 *bandLogE2,
   241c2:	637a      	str	r2, [r7, #52]	; 0x34
   ALLOC(follower, C*nbEBands, opus_val16);
   241c4:	fb05 f506 	mul.w	r5, r5, r6
   241c8:	006d      	lsls	r5, r5, #1
   241ca:	3508      	adds	r5, #8
   241cc:	f025 0507 	bic.w	r5, r5, #7
   241d0:	ebad 0d05 	sub.w	sp, sp, r5
static opus_val16 dynalloc_analysis(const opus_val16 *bandLogE, const opus_val16 *bandLogE2,
   241d4:	65f8      	str	r0, [r7, #92]	; 0x5c
   241d6:	64b9      	str	r1, [r7, #72]	; 0x48
   ALLOC(follower, C*nbEBands, opus_val16);
   241d8:	f8c7 d03c 	str.w	sp, [r7, #60]	; 0x3c
   ALLOC(noise_floor, C*nbEBands, opus_val16);
   OPUS_CLEAR(offsets, nbEBands);
   241dc:	0092      	lsls	r2, r2, #2
   ALLOC(noise_floor, C*nbEBands, opus_val16);
   241de:	ebad 0d05 	sub.w	sp, sp, r5
   OPUS_CLEAR(offsets, nbEBands);
   241e2:	f8d7 0098 	ldr.w	r0, [r7, #152]	; 0x98
static opus_val16 dynalloc_analysis(const opus_val16 *bandLogE, const opus_val16 *bandLogE2,
   241e6:	64fb      	str	r3, [r7, #76]	; 0x4c
   OPUS_CLEAR(offsets, nbEBands);
   241e8:	2100      	movs	r1, #0
static opus_val16 dynalloc_analysis(const opus_val16 *bandLogE, const opus_val16 *bandLogE2,
   241ea:	f8d7 40a0 	ldr.w	r4, [r7, #160]	; 0xa0
   ALLOC(noise_floor, C*nbEBands, opus_val16);
   241ee:	f8c7 d064 	str.w	sp, [r7, #100]	; 0x64
   OPUS_CLEAR(offsets, nbEBands);
   241f2:	f010 ffb7 	bl	35164 <memset>
   /* Dynamic allocation code */
   maxDepth=-QCONST16(31.9f, DB_SHIFT);
   for (i=0;i<end;i++)
   241f6:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
   241fa:	2b00      	cmp	r3, #0
   241fc:	f340 85c3 	ble.w	24d86 <dynalloc_analysis.isra.5+0xbd2>
   {
      /* Noise floor must take into account eMeans, the depth, the width of the bands
         and the preemphasis filter (approx. square of bark band ID) */
      noise_floor[i] = MULT16_16(QCONST16(0.0625f, DB_SHIFT),logN[i])
            +QCONST16(.5f,DB_SHIFT)+SHL16(9-lsb_depth,DB_SHIFT)-SHL16(eMeans[i],6)
   24200:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
   24204:	4dd4      	ldr	r5, [pc, #848]	; (24558 <dynalloc_analysis.isra.5+0x3a4>)
   24206:	f1c3 0609 	rsb	r6, r3, #9
   2420a:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
   2420e:	005b      	lsls	r3, r3, #1
   24210:	f1a3 0c02 	sub.w	ip, r3, #2
   24214:	653b      	str	r3, [r7, #80]	; 0x50
   24216:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   24218:	02b6      	lsls	r6, r6, #10
   2421a:	44a4      	add	ip, r4
   2421c:	f406 467c 	and.w	r6, r6, #64512	; 0xfc00
   24220:	3c02      	subs	r4, #2
   24222:	f1a3 0e02 	sub.w	lr, r3, #2
   24226:	2005      	movs	r0, #5
      noise_floor[i] = MULT16_16(QCONST16(0.0625f, DB_SHIFT),logN[i])
   24228:	f934 3f02 	ldrsh.w	r3, [r4, #2]!
            +QCONST16(.5f,DB_SHIFT)+SHL16(9-lsb_depth,DB_SHIFT)-SHL16(eMeans[i],6)
   2422c:	f915 1b01 	ldrsb.w	r1, [r5], #1
            +MULT16_16(QCONST16(.0062,DB_SHIFT),(i+5)*(i+5));
   24230:	fb10 f200 	smulbb	r2, r0, r0
            +QCONST16(.5f,DB_SHIFT)+SHL16(9-lsb_depth,DB_SHIFT)-SHL16(eMeans[i],6)
   24234:	3308      	adds	r3, #8
            +MULT16_16(QCONST16(.0062,DB_SHIFT),(i+5)*(i+5));
   24236:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   2423a:	eb06 1383 	add.w	r3, r6, r3, lsl #6
   2423e:	eb03 0342 	add.w	r3, r3, r2, lsl #1
            +QCONST16(.5f,DB_SHIFT)+SHL16(9-lsb_depth,DB_SHIFT)-SHL16(eMeans[i],6)
   24242:	b28a      	uxth	r2, r1
   24244:	3001      	adds	r0, #1
            +MULT16_16(QCONST16(.0062,DB_SHIFT),(i+5)*(i+5));
   24246:	eba3 1382 	sub.w	r3, r3, r2, lsl #6
   for (i=0;i<end;i++)
   2424a:	4564      	cmp	r4, ip
   2424c:	b280      	uxth	r0, r0
      noise_floor[i] = MULT16_16(QCONST16(0.0625f, DB_SHIFT),logN[i])
   2424e:	f82e 3f02 	strh.w	r3, [lr, #2]!
   for (i=0;i<end;i++)
   24252:	d1e9      	bne.n	24228 <dynalloc_analysis.isra.5+0x74>
   24254:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   24256:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   maxDepth=-QCONST16(31.9f, DB_SHIFT);
   24258:	f8df b300 	ldr.w	fp, [pc, #768]	; 2455c <dynalloc_analysis.isra.5+0x3a8>
   2425c:	3b02      	subs	r3, #2
   2425e:	617b      	str	r3, [r7, #20]
   24260:	469c      	mov	ip, r3
            +QCONST16(.5f,DB_SHIFT)+SHL16(9-lsb_depth,DB_SHIFT)-SHL16(eMeans[i],6)
   24262:	461e      	mov	r6, r3
   24264:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   24266:	3a02      	subs	r2, #2
   24268:	63ba      	str	r2, [r7, #56]	; 0x38
   2426a:	189c      	adds	r4, r3, r2
   2426c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   2426e:	e9d7 e824 	ldrd	lr, r8, [r7, #144]	; 0x90
   24272:	0050      	lsls	r0, r2, #1
   24274:	6478      	str	r0, [r7, #68]	; 0x44
   }
   c=0;do
   24276:	2500      	movs	r5, #0
   24278:	4699      	mov	r9, r3
   {
      for (i=0;i<end;i++)
   2427a:	f1be 0f00 	cmp.w	lr, #0
   2427e:	dd11      	ble.n	242a4 <dynalloc_analysis.isra.5+0xf0>
   24280:	f1a9 0202 	sub.w	r2, r9, #2
   24284:	4631      	mov	r1, r6
   24286:	46da      	mov	sl, fp
         maxDepth = MAX16(maxDepth, bandLogE[c*nbEBands+i]-noise_floor[i]);
   24288:	f932 bf02 	ldrsh.w	fp, [r2, #2]!
   2428c:	f931 3f02 	ldrsh.w	r3, [r1, #2]!
   24290:	eba3 0b0b 	sub.w	fp, r3, fp
   24294:	45d3      	cmp	fp, sl
   24296:	bfb8      	it	lt
   24298:	46d3      	movlt	fp, sl
      for (i=0;i<end;i++)
   2429a:	42a2      	cmp	r2, r4
         maxDepth = MAX16(maxDepth, bandLogE[c*nbEBands+i]-noise_floor[i]);
   2429c:	fa0f fa8b 	sxth.w	sl, fp
      for (i=0;i<end;i++)
   242a0:	d1f2      	bne.n	24288 <dynalloc_analysis.isra.5+0xd4>
   242a2:	46d3      	mov	fp, sl
   } while (++c<C);
   242a4:	3501      	adds	r5, #1
   242a6:	45a8      	cmp	r8, r5
   242a8:	4406      	add	r6, r0
   242aa:	dce6      	bgt.n	2427a <dynalloc_analysis.isra.5+0xc6>
   {
      /* Compute a really simple masking model to avoid taking into account completely masked
         bands when computing the spreading decision. */
      VARDECL(opus_val16, mask);
      VARDECL(opus_val16, sig);
      ALLOC(mask, nbEBands, opus_val16);
   242ac:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   242ae:	3308      	adds	r3, #8
   242b0:	f023 0307 	bic.w	r3, r3, #7
   {
   242b4:	46e9      	mov	r9, sp
      ALLOC(mask, nbEBands, opus_val16);
   242b6:	ebad 0d03 	sub.w	sp, sp, r3
   242ba:	466c      	mov	r4, sp
      ALLOC(sig, nbEBands, opus_val16);
   242bc:	ebad 0d03 	sub.w	sp, sp, r3
      for (i=0;i<end;i++)
   242c0:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
   242c4:	2b00      	cmp	r3, #0
      ALLOC(sig, nbEBands, opus_val16);
   242c6:	46e8      	mov	r8, sp
      for (i=0;i<end;i++)
   242c8:	f340 8562 	ble.w	24d90 <dynalloc_analysis.isra.5+0xbdc>
   242cc:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
   242ce:	6e79      	ldr	r1, [r7, #100]	; 0x64
   242d0:	4613      	mov	r3, r2
   242d2:	430b      	orrs	r3, r1
   242d4:	4323      	orrs	r3, r4
   242d6:	075b      	lsls	r3, r3, #29
   242d8:	4608      	mov	r0, r1
   242da:	f040 8532 	bne.w	24d42 <dynalloc_analysis.isra.5+0xb8e>
   242de:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
   242e2:	2b04      	cmp	r3, #4
   242e4:	f240 852d 	bls.w	24d42 <dynalloc_analysis.isra.5+0xb8e>
         mask[i] = bandLogE[i]-noise_floor[i];
   242e8:	4613      	mov	r3, r2
   242ea:	6816      	ldr	r6, [r2, #0]
   242ec:	680a      	ldr	r2, [r1, #0]
   242ee:	6859      	ldr	r1, [r3, #4]
   242f0:	6843      	ldr	r3, [r0, #4]
   242f2:	1ab5      	subs	r5, r6, r2
   242f4:	2000      	movs	r0, #0
   242f6:	f3c2 420f 	ubfx	r2, r2, #16, #16
   242fa:	ebc2 4616 	rsb	r6, r2, r6, lsr #16
   242fe:	4602      	mov	r2, r0
   24300:	f365 000f 	bfi	r0, r5, #0, #16
   24304:	f366 401f 	bfi	r0, r6, #16, #16
   24308:	1acd      	subs	r5, r1, r3
   2430a:	f8d7 6090 	ldr.w	r6, [r7, #144]	; 0x90
   2430e:	f3c3 430f 	ubfx	r3, r3, #16, #16
   24312:	ebc3 4111 	rsb	r1, r3, r1, lsr #16
   24316:	f365 020f 	bfi	r2, r5, #0, #16
   2431a:	f361 421f 	bfi	r2, r1, #16, #16
   2431e:	08b1      	lsrs	r1, r6, #2
   24320:	2901      	cmp	r1, #1
   24322:	e9c4 0200 	strd	r0, r2, [r4]
   24326:	f000 809c 	beq.w	24462 <dynalloc_analysis.isra.5+0x2ae>
   2432a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   2432c:	6e7e      	ldr	r6, [r7, #100]	; 0x64
   2432e:	f8d3 c008 	ldr.w	ip, [r3, #8]
   24332:	68b2      	ldr	r2, [r6, #8]
   24334:	68dd      	ldr	r5, [r3, #12]
   24336:	68f3      	ldr	r3, [r6, #12]
   24338:	2000      	movs	r0, #0
   2433a:	ebac 0602 	sub.w	r6, ip, r2
   2433e:	f3c2 420f 	ubfx	r2, r2, #16, #16
   24342:	ebc2 421c 	rsb	r2, r2, ip, lsr #16
   24346:	4684      	mov	ip, r0
   24348:	f366 000f 	bfi	r0, r6, #0, #16
   2434c:	f362 401f 	bfi	r0, r2, #16, #16
   24350:	1aea      	subs	r2, r5, r3
   24352:	f3c3 430f 	ubfx	r3, r3, #16, #16
   24356:	f362 0c0f 	bfi	ip, r2, #0, #16
   2435a:	ebc3 4315 	rsb	r3, r3, r5, lsr #16
   2435e:	f363 4c1f 	bfi	ip, r3, #16, #16
   24362:	2902      	cmp	r1, #2
   24364:	e9c4 0c02 	strd	r0, ip, [r4, #8]
   24368:	d07b      	beq.n	24462 <dynalloc_analysis.isra.5+0x2ae>
   2436a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   2436c:	6e7e      	ldr	r6, [r7, #100]	; 0x64
   2436e:	f8d3 c010 	ldr.w	ip, [r3, #16]
   24372:	6932      	ldr	r2, [r6, #16]
   24374:	695d      	ldr	r5, [r3, #20]
   24376:	6973      	ldr	r3, [r6, #20]
   24378:	2000      	movs	r0, #0
   2437a:	ebac 0602 	sub.w	r6, ip, r2
   2437e:	f3c2 420f 	ubfx	r2, r2, #16, #16
   24382:	ebc2 421c 	rsb	r2, r2, ip, lsr #16
   24386:	4684      	mov	ip, r0
   24388:	f366 000f 	bfi	r0, r6, #0, #16
   2438c:	f362 401f 	bfi	r0, r2, #16, #16
   24390:	1aea      	subs	r2, r5, r3
   24392:	f3c3 430f 	ubfx	r3, r3, #16, #16
   24396:	f362 0c0f 	bfi	ip, r2, #0, #16
   2439a:	ebc3 4315 	rsb	r3, r3, r5, lsr #16
   2439e:	f363 4c1f 	bfi	ip, r3, #16, #16
   243a2:	2903      	cmp	r1, #3
   243a4:	e9c4 0c04 	strd	r0, ip, [r4, #16]
   243a8:	d05b      	beq.n	24462 <dynalloc_analysis.isra.5+0x2ae>
   243aa:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   243ac:	6e7e      	ldr	r6, [r7, #100]	; 0x64
   243ae:	f8d3 c018 	ldr.w	ip, [r3, #24]
   243b2:	69b2      	ldr	r2, [r6, #24]
   243b4:	69dd      	ldr	r5, [r3, #28]
   243b6:	69f3      	ldr	r3, [r6, #28]
   243b8:	2000      	movs	r0, #0
   243ba:	ebac 0602 	sub.w	r6, ip, r2
   243be:	f3c2 420f 	ubfx	r2, r2, #16, #16
   243c2:	ebc2 421c 	rsb	r2, r2, ip, lsr #16
   243c6:	4684      	mov	ip, r0
   243c8:	f366 000f 	bfi	r0, r6, #0, #16
   243cc:	f362 401f 	bfi	r0, r2, #16, #16
   243d0:	1aea      	subs	r2, r5, r3
   243d2:	f3c3 430f 	ubfx	r3, r3, #16, #16
   243d6:	f362 0c0f 	bfi	ip, r2, #0, #16
   243da:	ebc3 4315 	rsb	r3, r3, r5, lsr #16
   243de:	f363 4c1f 	bfi	ip, r3, #16, #16
   243e2:	2904      	cmp	r1, #4
   243e4:	e9c4 0c06 	strd	r0, ip, [r4, #24]
   243e8:	d03b      	beq.n	24462 <dynalloc_analysis.isra.5+0x2ae>
   243ea:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   243ec:	6e7e      	ldr	r6, [r7, #100]	; 0x64
   243ee:	f8d3 c020 	ldr.w	ip, [r3, #32]
   243f2:	6a32      	ldr	r2, [r6, #32]
   243f4:	6a5d      	ldr	r5, [r3, #36]	; 0x24
   243f6:	6a73      	ldr	r3, [r6, #36]	; 0x24
   243f8:	2000      	movs	r0, #0
   243fa:	ebac 0602 	sub.w	r6, ip, r2
   243fe:	f3c2 420f 	ubfx	r2, r2, #16, #16
   24402:	ebc2 421c 	rsb	r2, r2, ip, lsr #16
   24406:	4684      	mov	ip, r0
   24408:	f366 000f 	bfi	r0, r6, #0, #16
   2440c:	f362 401f 	bfi	r0, r2, #16, #16
   24410:	1aea      	subs	r2, r5, r3
   24412:	f3c3 430f 	ubfx	r3, r3, #16, #16
   24416:	f362 0c0f 	bfi	ip, r2, #0, #16
   2441a:	ebc3 4315 	rsb	r3, r3, r5, lsr #16
   2441e:	f363 4c1f 	bfi	ip, r3, #16, #16
   24422:	2905      	cmp	r1, #5
   24424:	e9c4 0c08 	strd	r0, ip, [r4, #32]
   24428:	d01b      	beq.n	24462 <dynalloc_analysis.isra.5+0x2ae>
   2442a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   2442c:	6e79      	ldr	r1, [r7, #100]	; 0x64
   2442e:	6a9e      	ldr	r6, [r3, #40]	; 0x28
   24430:	6a8a      	ldr	r2, [r1, #40]	; 0x28
   24432:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
   24434:	6acb      	ldr	r3, [r1, #44]	; 0x2c
   24436:	1ab5      	subs	r5, r6, r2
   24438:	2100      	movs	r1, #0
   2443a:	f3c2 420f 	ubfx	r2, r2, #16, #16
   2443e:	ebc2 4216 	rsb	r2, r2, r6, lsr #16
   24442:	460e      	mov	r6, r1
   24444:	f365 010f 	bfi	r1, r5, #0, #16
   24448:	f362 411f 	bfi	r1, r2, #16, #16
   2444c:	1ac2      	subs	r2, r0, r3
   2444e:	f3c3 430f 	ubfx	r3, r3, #16, #16
   24452:	f362 060f 	bfi	r6, r2, #0, #16
   24456:	ebc3 4010 	rsb	r0, r3, r0, lsr #16
   2445a:	f360 461f 	bfi	r6, r0, #16, #16
   2445e:	e9c4 160a 	strd	r1, r6, [r4, #40]	; 0x28
   24462:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
   24466:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
   2446a:	f023 0303 	bic.w	r3, r3, #3
   2446e:	4293      	cmp	r3, r2
   24470:	d021      	beq.n	244b6 <dynalloc_analysis.isra.5+0x302>
   24472:	6dfd      	ldr	r5, [r7, #92]	; 0x5c
   24474:	6e78      	ldr	r0, [r7, #100]	; 0x64
   24476:	4616      	mov	r6, r2
   24478:	f830 1013 	ldrh.w	r1, [r0, r3, lsl #1]
   2447c:	f835 2013 	ldrh.w	r2, [r5, r3, lsl #1]
   24480:	1a52      	subs	r2, r2, r1
      for (i=0;i<end;i++)
   24482:	1c59      	adds	r1, r3, #1
   24484:	428e      	cmp	r6, r1
         mask[i] = bandLogE[i]-noise_floor[i];
   24486:	f824 2013 	strh.w	r2, [r4, r3, lsl #1]
   2448a:	ea4f 0243 	mov.w	r2, r3, lsl #1
      for (i=0;i<end;i++)
   2448e:	dd12      	ble.n	244b6 <dynalloc_analysis.isra.5+0x302>
         mask[i] = bandLogE[i]-noise_floor[i];
   24490:	442a      	add	r2, r5
   24492:	4606      	mov	r6, r0
   24494:	f830 5011 	ldrh.w	r5, [r0, r1, lsl #1]
   24498:	8850      	ldrh	r0, [r2, #2]
   2449a:	1b40      	subs	r0, r0, r5
   2449c:	f824 0011 	strh.w	r0, [r4, r1, lsl #1]
      for (i=0;i<end;i++)
   244a0:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
   244a4:	3302      	adds	r3, #2
   244a6:	4299      	cmp	r1, r3
   244a8:	dd05      	ble.n	244b6 <dynalloc_analysis.isra.5+0x302>
         mask[i] = bandLogE[i]-noise_floor[i];
   244aa:	8892      	ldrh	r2, [r2, #4]
   244ac:	f836 1013 	ldrh.w	r1, [r6, r3, lsl #1]
   244b0:	1a52      	subs	r2, r2, r1
   244b2:	f824 2013 	strh.w	r2, [r4, r3, lsl #1]
      if (C==2)
   244b6:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
   244ba:	2b02      	cmp	r3, #2
   244bc:	f000 81ff 	beq.w	248be <dynalloc_analysis.isra.5+0x70a>
      {
         for (i=0;i<end;i++)
            mask[i] = MAX16(mask[i], bandLogE[nbEBands+i]-noise_floor[i]);
      }
      OPUS_COPY(sig, mask, end);
   244c0:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   244c2:	4621      	mov	r1, r4
   244c4:	4640      	mov	r0, r8
   244c6:	f7e7 fe1b 	bl	c100 <memcpy>
      for (i=1;i<end;i++)
   244ca:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
   244ce:	2b01      	cmp	r3, #1
   244d0:	dd1d      	ble.n	2450e <dynalloc_analysis.isra.5+0x35a>
   244d2:	6bba      	ldr	r2, [r7, #56]	; 0x38
   244d4:	f9b4 3000 	ldrsh.w	r3, [r4]
   244d8:	4621      	mov	r1, r4
   244da:	18a5      	adds	r5, r4, r2
         mask[i] = MAX16(mask[i], mask[i-1] - QCONST16(2.f, DB_SHIFT));
   244dc:	f931 2f02 	ldrsh.w	r2, [r1, #2]!
   244e0:	f5a3 6000 	sub.w	r0, r3, #2048	; 0x800
   244e4:	f2a3 73ff 	subw	r3, r3, #2047	; 0x7ff
   244e8:	4293      	cmp	r3, r2
   244ea:	dd0c      	ble.n	24506 <dynalloc_analysis.isra.5+0x352>
   244ec:	b202      	sxth	r2, r0
      for (i=1;i<end;i++)
   244ee:	42a9      	cmp	r1, r5
         mask[i] = MAX16(mask[i], mask[i-1] - QCONST16(2.f, DB_SHIFT));
   244f0:	800a      	strh	r2, [r1, #0]
      for (i=1;i<end;i++)
   244f2:	d00a      	beq.n	2450a <dynalloc_analysis.isra.5+0x356>
      for (i=0;i<end;i++)
   244f4:	4613      	mov	r3, r2
         mask[i] = MAX16(mask[i], mask[i-1] - QCONST16(2.f, DB_SHIFT));
   244f6:	f931 2f02 	ldrsh.w	r2, [r1, #2]!
   244fa:	f5a3 6000 	sub.w	r0, r3, #2048	; 0x800
   244fe:	f2a3 73ff 	subw	r3, r3, #2047	; 0x7ff
   24502:	4293      	cmp	r3, r2
   24504:	dcf2      	bgt.n	244ec <dynalloc_analysis.isra.5+0x338>
      for (i=1;i<end;i++)
   24506:	42a9      	cmp	r1, r5
   24508:	d1f4      	bne.n	244f4 <dynalloc_analysis.isra.5+0x340>
   2450a:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
      for (i=end-2;i>=0;i--)
   2450e:	3b02      	subs	r3, #2
   24510:	663b      	str	r3, [r7, #96]	; 0x60
   24512:	d425      	bmi.n	24560 <dynalloc_analysis.isra.5+0x3ac>
   24514:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   24516:	18a3      	adds	r3, r4, r2
   24518:	3a04      	subs	r2, #4
   2451a:	4422      	add	r2, r4
   2451c:	f933 3c02 	ldrsh.w	r3, [r3, #-2]
         mask[i] = MAX16(mask[i], mask[i+1] - QCONST16(3.f, DB_SHIFT));
   24520:	f932 1902 	ldrsh.w	r1, [r2], #-2
   24524:	f5a3 6040 	sub.w	r0, r3, #3072	; 0xc00
   24528:	f6a3 33ff 	subw	r3, r3, #3071	; 0xbff
   2452c:	428b      	cmp	r3, r1
   2452e:	f1a4 0502 	sub.w	r5, r4, #2
   24532:	dd0c      	ble.n	2454e <dynalloc_analysis.isra.5+0x39a>
   24534:	b201      	sxth	r1, r0
      for (i=end-2;i>=0;i--)
   24536:	42aa      	cmp	r2, r5
         mask[i] = MAX16(mask[i], mask[i+1] - QCONST16(3.f, DB_SHIFT));
   24538:	8051      	strh	r1, [r2, #2]
      for (i=end-2;i>=0;i--)
   2453a:	d011      	beq.n	24560 <dynalloc_analysis.isra.5+0x3ac>
      for (i=0;i<end;i++)
   2453c:	460b      	mov	r3, r1
         mask[i] = MAX16(mask[i], mask[i+1] - QCONST16(3.f, DB_SHIFT));
   2453e:	f932 1902 	ldrsh.w	r1, [r2], #-2
   24542:	f5a3 6040 	sub.w	r0, r3, #3072	; 0xc00
   24546:	f6a3 33ff 	subw	r3, r3, #3071	; 0xbff
   2454a:	428b      	cmp	r3, r1
   2454c:	dcf2      	bgt.n	24534 <dynalloc_analysis.isra.5+0x380>
      for (i=end-2;i>=0;i--)
   2454e:	42aa      	cmp	r2, r5
         mask[i] = MAX16(mask[i], mask[i+1] - QCONST16(3.f, DB_SHIFT));
   24550:	8051      	strh	r1, [r2, #2]
      for (i=end-2;i>=0;i--)
   24552:	d1f3      	bne.n	2453c <dynalloc_analysis.isra.5+0x388>
   24554:	e004      	b.n	24560 <dynalloc_analysis.isra.5+0x3ac>
   24556:	bf00      	nop
   24558:	0003b424 	.word	0x0003b424
   2455c:	ffff8066 	.word	0xffff8066
      for (i=0;i<end;i++)
   24560:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
   24564:	2b00      	cmp	r3, #0
   24566:	dd2b      	ble.n	245c0 <dynalloc_analysis.isra.5+0x40c>
   24568:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   2456a:	eb08 0c03 	add.w	ip, r8, r3
   2456e:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
   24572:	f5bb 5f40 	cmp.w	fp, #12288	; 0x3000
      {
         /* Compute SMR: Mask is never more than 72 dB below the peak and never below the noise floor.*/
         opus_val16 smr = sig[i]-MAX16(MAX16(0, maxDepth-QCONST16(12.f, DB_SHIFT)), mask[i]);
   24576:	f5ab 5540 	sub.w	r5, fp, #12288	; 0x3000
   2457a:	f1a4 0102 	sub.w	r1, r4, #2
   2457e:	bfb8      	it	lt
   24580:	2500      	movlt	r5, #0
   24582:	f1a8 0002 	sub.w	r0, r8, #2
   24586:	1f1c      	subs	r4, r3, #4
         /* FIXME: Use PSHR16() instead */
         int shift = -PSHR32(MAX16(-QCONST16(5.f, DB_SHIFT), MIN16(0, smr)), DB_SHIFT);
#else
         int shift = IMIN(5, IMAX(0, -(int)floor(.5f + smr)));
#endif
         spread_weight[i] = 32 >> shift;
   24588:	f04f 0e01 	mov.w	lr, #1
   2458c:	2620      	movs	r6, #32
         opus_val16 smr = sig[i]-MAX16(MAX16(0, maxDepth-QCONST16(12.f, DB_SHIFT)), mask[i]);
   2458e:	f931 3f02 	ldrsh.w	r3, [r1, #2]!
   24592:	f830 2f02 	ldrh.w	r2, [r0, #2]!
   24596:	42ab      	cmp	r3, r5
   24598:	bfac      	ite	ge
   2459a:	1ad2      	subge	r2, r2, r3
   2459c:	1b52      	sublt	r2, r2, r5
   2459e:	b212      	sxth	r2, r2
         int shift = -PSHR32(MAX16(-QCONST16(5.f, DB_SHIFT), MIN16(0, smr)), DB_SHIFT);
   245a0:	ea02 73e2 	and.w	r3, r2, r2, asr #31
   245a4:	f503 7300 	add.w	r3, r3, #512	; 0x200
   245a8:	129b      	asrs	r3, r3, #10
   245aa:	425b      	negs	r3, r3
   245ac:	f512 5fa0 	cmn.w	r2, #5120	; 0x1400
         spread_weight[i] = 32 >> shift;
   245b0:	fa46 f303 	asr.w	r3, r6, r3
         int shift = -PSHR32(MAX16(-QCONST16(5.f, DB_SHIFT), MIN16(0, smr)), DB_SHIFT);
   245b4:	f2c0 817d 	blt.w	248b2 <dynalloc_analysis.isra.5+0x6fe>
      for (i=0;i<end;i++)
   245b8:	4560      	cmp	r0, ip
         spread_weight[i] = 32 >> shift;
   245ba:	f844 3f04 	str.w	r3, [r4, #4]!
      for (i=0;i<end;i++)
   245be:	d1e6      	bne.n	2458e <dynalloc_analysis.isra.5+0x3da>
      /*for (i=0;i<end;i++)
         printf("%d ", spread_weight[i]);
      printf("\n");*/
   }
   /* Make sure that dynamic allocation can't make us bust the budget */
   if (effectiveBytes > 50 && LM>=1 && !lfe)
   245c0:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
   245c4:	2b32      	cmp	r3, #50	; 0x32
   245c6:	46cd      	mov	sp, r9
   245c8:	f340 8152 	ble.w	24870 <dynalloc_analysis.isra.5+0x6bc>
   245cc:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
   245d0:	2b00      	cmp	r3, #0
   245d2:	f000 814d 	beq.w	24870 <dynalloc_analysis.isra.5+0x6bc>
   245d6:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
   245da:	2b00      	cmp	r3, #0
   245dc:	f040 8148 	bne.w	24870 <dynalloc_analysis.isra.5+0x6bc>
            f[i] = MAX16(f[i], median_of_5(&bandLogE2[c*nbEBands+i-2])-offset);
         tmp = median_of_3(&bandLogE2[c*nbEBands])-offset;
         f[0] = MAX16(f[0], tmp);
         f[1] = MAX16(f[1], tmp);
         tmp = median_of_3(&bandLogE2[c*nbEBands+end-3])-offset;
         f[end-2] = MAX16(f[end-2], tmp);
   245e0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   245e2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
   245e4:	6e79      	ldr	r1, [r7, #100]	; 0x64
   245e6:	f8d7 e048 	ldr.w	lr, [r7, #72]	; 0x48
   245ea:	3b04      	subs	r3, #4
   245ec:	18d3      	adds	r3, r2, r3
   245ee:	61fb      	str	r3, [r7, #28]
   245f0:	4613      	mov	r3, r2
   245f2:	3a02      	subs	r2, #2
   245f4:	657a      	str	r2, [r7, #84]	; 0x54
   245f6:	6bba      	ldr	r2, [r7, #56]	; 0x38
   245f8:	4413      	add	r3, r2
   245fa:	61bb      	str	r3, [r7, #24]
   245fc:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
   24600:	3b01      	subs	r3, #1
   24602:	4411      	add	r1, r2
   24604:	60fb      	str	r3, [r7, #12]
   24606:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
   2460a:	6139      	str	r1, [r7, #16]
      c=0;do
   2460c:	f8d7 10c0 	ldr.w	r1, [r7, #192]	; 0xc0
   24610:	6339      	str	r1, [r7, #48]	; 0x30
   24612:	3b04      	subs	r3, #4
   24614:	e9c7 b301 	strd	fp, r3, [r7, #4]
         f[end-1] = MAX16(f[end-1], tmp);
   24618:	65b9      	str	r1, [r7, #88]	; 0x58
   2461a:	46f3      	mov	fp, lr
   2461c:	460d      	mov	r5, r1
   2461e:	6d7a      	ldr	r2, [r7, #84]	; 0x54
         f[0] = bandLogE2[c*nbEBands];
   24620:	f9bb 3000 	ldrsh.w	r3, [fp]
   24624:	643b      	str	r3, [r7, #64]	; 0x40
   24626:	1c94      	adds	r4, r2, #2
   24628:	4611      	mov	r1, r2
         for (i=1;i<end;i++)
   2462a:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
         f[0] = bandLogE2[c*nbEBands];
   2462e:	804b      	strh	r3, [r1, #2]
         for (i=1;i<end;i++)
   24630:	2a01      	cmp	r2, #1
   24632:	627c      	str	r4, [r7, #36]	; 0x24
   24634:	dd54      	ble.n	246e0 <dynalloc_analysis.isra.5+0x52c>
   24636:	2a03      	cmp	r2, #3
   24638:	f340 83dd 	ble.w	24df6 <dynalloc_analysis.isra.5+0xc42>
   2463c:	f8d7 e00c 	ldr.w	lr, [r7, #12]
         f[0] = bandLogE2[c*nbEBands];
   24640:	469c      	mov	ip, r3
   24642:	461a      	mov	r2, r3
         for (i=1;i<end;i++)
   24644:	2002      	movs	r0, #2
   24646:	2301      	movs	r3, #1
            if (bandLogE2[c*nbEBands+i] > bandLogE2[c*nbEBands+i-1]+QCONST16(.5f,DB_SHIFT))
   24648:	f93b 1013 	ldrsh.w	r1, [fp, r3, lsl #1]
            f[i] = MIN16(f[i-1]+QCONST16(1.5f,DB_SHIFT), bandLogE2[c*nbEBands+i]);
   2464c:	f502 62c0 	add.w	r2, r2, #1536	; 0x600
   24650:	428a      	cmp	r2, r1
   24652:	bfa8      	it	ge
   24654:	460a      	movge	r2, r1
            if (bandLogE2[c*nbEBands+i] > bandLogE2[c*nbEBands+i-1]+QCONST16(.5f,DB_SHIFT))
   24656:	f50c 7900 	add.w	r9, ip, #512	; 0x200
   2465a:	f93b c010 	ldrsh.w	ip, [fp, r0, lsl #1]
            f[i] = MIN16(f[i-1]+QCONST16(1.5f,DB_SHIFT), bandLogE2[c*nbEBands+i]);
   2465e:	4690      	mov	r8, r2
   24660:	f502 62c0 	add.w	r2, r2, #1536	; 0x600
   24664:	461e      	mov	r6, r3
            if (bandLogE2[c*nbEBands+i] > bandLogE2[c*nbEBands+i-1]+QCONST16(.5f,DB_SHIFT))
   24666:	4589      	cmp	r9, r1
   24668:	bfa8      	it	ge
   2466a:	462b      	movge	r3, r5
            f[i] = MIN16(f[i-1]+QCONST16(1.5f,DB_SHIFT), bandLogE2[c*nbEBands+i]);
   2466c:	4562      	cmp	r2, ip
   2466e:	bfa8      	it	ge
   24670:	4662      	movge	r2, ip
            if (bandLogE2[c*nbEBands+i] > bandLogE2[c*nbEBands+i-1]+QCONST16(.5f,DB_SHIFT))
   24672:	f501 7100 	add.w	r1, r1, #512	; 0x200
            f[i] = MIN16(f[i-1]+QCONST16(1.5f,DB_SHIFT), bandLogE2[c*nbEBands+i]);
   24676:	b212      	sxth	r2, r2
            if (bandLogE2[c*nbEBands+i] > bandLogE2[c*nbEBands+i-1]+QCONST16(.5f,DB_SHIFT))
   24678:	4561      	cmp	r1, ip
   2467a:	bfb4      	ite	lt
   2467c:	4605      	movlt	r5, r0
   2467e:	461d      	movge	r5, r3
            f[i] = MIN16(f[i-1]+QCONST16(1.5f,DB_SHIFT), bandLogE2[c*nbEBands+i]);
   24680:	f824 8016 	strh.w	r8, [r4, r6, lsl #1]
   24684:	f824 2010 	strh.w	r2, [r4, r0, lsl #1]
   24688:	3002      	adds	r0, #2
   2468a:	4586      	cmp	lr, r0
   2468c:	f106 0302 	add.w	r3, r6, #2
   24690:	dcda      	bgt.n	24648 <dynalloc_analysis.isra.5+0x494>
   24692:	f8d7 e090 	ldr.w	lr, [r7, #144]	; 0x90
   24696:	6dba      	ldr	r2, [r7, #88]	; 0x58
   24698:	eb02 0c03 	add.w	ip, r2, r3
   2469c:	f10c 4c00 	add.w	ip, ip, #2147483648	; 0x80000000
   246a0:	f103 4600 	add.w	r6, r3, #2147483648	; 0x80000000
   246a4:	6cba      	ldr	r2, [r7, #72]	; 0x48
   246a6:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
   246aa:	3e01      	subs	r6, #1
   246ac:	eb02 0c4c 	add.w	ip, r2, ip, lsl #1
   246b0:	eb04 0646 	add.w	r6, r4, r6, lsl #1
            if (bandLogE2[c*nbEBands+i] > bandLogE2[c*nbEBands+i-1]+QCONST16(.5f,DB_SHIFT))
   246b4:	f93c 0f02 	ldrsh.w	r0, [ip, #2]!
            f[i] = MIN16(f[i-1]+QCONST16(1.5f,DB_SHIFT), bandLogE2[c*nbEBands+i]);
   246b8:	f9b6 2000 	ldrsh.w	r2, [r6]
            if (bandLogE2[c*nbEBands+i] > bandLogE2[c*nbEBands+i-1]+QCONST16(.5f,DB_SHIFT))
   246bc:	f93c 1c02 	ldrsh.w	r1, [ip, #-2]
            f[i] = MIN16(f[i-1]+QCONST16(1.5f,DB_SHIFT), bandLogE2[c*nbEBands+i]);
   246c0:	f502 62c0 	add.w	r2, r2, #1536	; 0x600
            if (bandLogE2[c*nbEBands+i] > bandLogE2[c*nbEBands+i-1]+QCONST16(.5f,DB_SHIFT))
   246c4:	f501 7100 	add.w	r1, r1, #512	; 0x200
   246c8:	4281      	cmp	r1, r0
   246ca:	bfb8      	it	lt
   246cc:	461d      	movlt	r5, r3
            f[i] = MIN16(f[i-1]+QCONST16(1.5f,DB_SHIFT), bandLogE2[c*nbEBands+i]);
   246ce:	4282      	cmp	r2, r0
         for (i=1;i<end;i++)
   246d0:	f103 0301 	add.w	r3, r3, #1
            f[i] = MIN16(f[i-1]+QCONST16(1.5f,DB_SHIFT), bandLogE2[c*nbEBands+i]);
   246d4:	bfa8      	it	ge
   246d6:	4602      	movge	r2, r0
         for (i=1;i<end;i++)
   246d8:	459e      	cmp	lr, r3
            f[i] = MIN16(f[i-1]+QCONST16(1.5f,DB_SHIFT), bandLogE2[c*nbEBands+i]);
   246da:	f826 2f02 	strh.w	r2, [r6, #2]!
         for (i=1;i<end;i++)
   246de:	dce9      	bgt.n	246b4 <dynalloc_analysis.isra.5+0x500>
         for (i=last-1;i>=0;i--)
   246e0:	1e6e      	subs	r6, r5, #1
   246e2:	b1e5      	cbz	r5, 2471e <dynalloc_analysis.isra.5+0x56a>
   246e4:	6dba      	ldr	r2, [r7, #88]	; 0x58
   246e6:	18ab      	adds	r3, r5, r2
   246e8:	4416      	add	r6, r2
   246ea:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
   246ec:	f932 3013 	ldrsh.w	r3, [r2, r3, lsl #1]
   246f0:	6cba      	ldr	r2, [r7, #72]	; 0x48
   246f2:	3601      	adds	r6, #1
   246f4:	eb02 0646 	add.w	r6, r2, r6, lsl #1
   246f8:	eb04 0045 	add.w	r0, r4, r5, lsl #1
   246fc:	461a      	mov	r2, r3
            f[i] = MIN16(f[i], MIN16(f[i+1]+QCONST16(2.f,DB_SHIFT), bandLogE2[c*nbEBands+i]));
   246fe:	f936 3d02 	ldrsh.w	r3, [r6, #-2]!
   24702:	f930 1d02 	ldrsh.w	r1, [r0, #-2]!
   24706:	428b      	cmp	r3, r1
   24708:	f502 6200 	add.w	r2, r2, #2048	; 0x800
   2470c:	bfa8      	it	ge
   2470e:	460b      	movge	r3, r1
   24710:	4293      	cmp	r3, r2
   24712:	bfa8      	it	ge
   24714:	4613      	movge	r3, r2
   24716:	b21a      	sxth	r2, r3
         for (i=last-1;i>=0;i--)
   24718:	42a0      	cmp	r0, r4
            f[i] = MIN16(f[i], MIN16(f[i+1]+QCONST16(2.f,DB_SHIFT), bandLogE2[c*nbEBands+i]));
   2471a:	8002      	strh	r2, [r0, #0]
         for (i=last-1;i>=0;i--)
   2471c:	d1ef      	bne.n	246fe <dynalloc_analysis.isra.5+0x54a>
         for (i=2;i<end-2;i++)
   2471e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   24720:	2b02      	cmp	r3, #2
   24722:	f340 8329 	ble.w	24d78 <dynalloc_analysis.isra.5+0xbc4>
   24726:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
   2472a:	2b07      	cmp	r3, #7
   2472c:	f340 835a 	ble.w	24de4 <dynalloc_analysis.isra.5+0xc30>
   24730:	f9bb 0002 	ldrsh.w	r0, [fp, #2]
   24734:	f9bb 2004 	ldrsh.w	r2, [fp, #4]
   24738:	f8c7 50c0 	str.w	r5, [r7, #192]	; 0xc0
   2473c:	62f8      	str	r0, [r7, #44]	; 0x2c
   2473e:	62ba      	str	r2, [r7, #40]	; 0x28
   24740:	f9bb 3006 	ldrsh.w	r3, [fp, #6]
   24744:	f8c7 b020 	str.w	fp, [r7, #32]
   24748:	465e      	mov	r6, fp
   2474a:	f04f 0e02 	mov.w	lr, #2
   2474e:	68bd      	ldr	r5, [r7, #8]
   24750:	e06c      	b.n	2482c <dynalloc_analysis.isra.5+0x678>
      if (t1 < t3)
   24752:	4541      	cmp	r1, r8
   24754:	f340 82d7 	ble.w	24d06 <dynalloc_analysis.isra.5+0xb52>
         return MIN16(t2, t3);
   24758:	4291      	cmp	r1, r2
   2475a:	bfa8      	it	ge
   2475c:	4611      	movge	r1, r2
   2475e:	b209      	sxth	r1, r1
            f[i] = MAX16(f[i], median_of_5(&bandLogE2[c*nbEBands+i-2])-offset);
   24760:	f5a1 6180 	sub.w	r1, r1, #1024	; 0x400
   24764:	4549      	cmp	r1, r9
   24766:	bfa8      	it	ge
   24768:	fa0f f981 	sxthge.w	r9, r1
   if (x[0] > x[1])
   2476c:	f9b6 1002 	ldrsh.w	r1, [r6, #2]
            f[i] = MAX16(f[i], median_of_5(&bandLogE2[c*nbEBands+i-2])-offset);
   24770:	f8a4 9004 	strh.w	r9, [r4, #4]
   if (x[0] > x[1])
   24774:	428a      	cmp	r2, r1
            f[i] = MAX16(f[i], median_of_5(&bandLogE2[c*nbEBands+i-2])-offset);
   24776:	f9b4 9006 	ldrsh.w	r9, [r4, #6]
   if (x[0] > x[1])
   2477a:	da02      	bge.n	24782 <dynalloc_analysis.isra.5+0x5ce>
   2477c:	4608      	mov	r0, r1
   2477e:	4611      	mov	r1, r2
   24780:	4602      	mov	r2, r0
   if (x[3] > x[4])
   24782:	f9b6 800a 	ldrsh.w	r8, [r6, #10]
   24786:	45c4      	cmp	ip, r8
   24788:	bfcb      	itete	gt
   2478a:	46c2      	movgt	sl, r8
   2478c:	46e2      	movle	sl, ip
   2478e:	4660      	movgt	r0, ip
   24790:	4640      	movle	r0, r8
   if (t0 > t3)
   24792:	458a      	cmp	sl, r1
   24794:	db03      	blt.n	2479e <dynalloc_analysis.isra.5+0x5ea>
   24796:	4683      	mov	fp, r0
   24798:	4651      	mov	r1, sl
   2479a:	4610      	mov	r0, r2
   2479c:	465a      	mov	r2, fp
   if (t2 > t1)
   2479e:	4283      	cmp	r3, r0
   247a0:	f340 80a5 	ble.w	248ee <dynalloc_analysis.isra.5+0x73a>
      if (t1 < t3)
   247a4:	4281      	cmp	r1, r0
   247a6:	f340 82b3 	ble.w	24d10 <dynalloc_analysis.isra.5+0xb5c>
         return MIN16(t2, t3);
   247aa:	4299      	cmp	r1, r3
   247ac:	bfa8      	it	ge
   247ae:	4619      	movge	r1, r3
   247b0:	b20a      	sxth	r2, r1
            f[i] = MAX16(f[i], median_of_5(&bandLogE2[c*nbEBands+i-2])-offset);
   247b2:	f5a2 6280 	sub.w	r2, r2, #1024	; 0x400
   247b6:	4591      	cmp	r9, r2
   247b8:	bfd8      	it	le
   247ba:	fa0f f982 	sxthle.w	r9, r2
   if (x[0] > x[1])
   247be:	f9b6 2004 	ldrsh.w	r2, [r6, #4]
            f[i] = MAX16(f[i], median_of_5(&bandLogE2[c*nbEBands+i-2])-offset);
   247c2:	f8a4 9006 	strh.w	r9, [r4, #6]
   if (x[0] > x[1])
   247c6:	4293      	cmp	r3, r2
            f[i] = MAX16(f[i], median_of_5(&bandLogE2[c*nbEBands+i-2])-offset);
   247c8:	f9b4 a008 	ldrsh.w	sl, [r4, #8]
   if (x[0] > x[1])
   247cc:	da02      	bge.n	247d4 <dynalloc_analysis.isra.5+0x620>
   247ce:	4611      	mov	r1, r2
   247d0:	461a      	mov	r2, r3
   247d2:	460b      	mov	r3, r1
   if (x[3] > x[4])
   247d4:	f9b6 900c 	ldrsh.w	r9, [r6, #12]
   247d8:	45c8      	cmp	r8, r9
   247da:	bfcb      	itete	gt
   247dc:	4648      	movgt	r0, r9
   247de:	4640      	movle	r0, r8
   247e0:	4641      	movgt	r1, r8
   247e2:	4649      	movle	r1, r9
   if (t0 > t3)
   247e4:	4290      	cmp	r0, r2
   247e6:	db03      	blt.n	247f0 <dynalloc_analysis.isra.5+0x63c>
   247e8:	468b      	mov	fp, r1
   247ea:	4602      	mov	r2, r0
   247ec:	4619      	mov	r1, r3
   247ee:	465b      	mov	r3, fp
   if (t2 > t1)
   247f0:	458c      	cmp	ip, r1
   247f2:	f340 8084 	ble.w	248fe <dynalloc_analysis.isra.5+0x74a>
      if (t1 < t3)
   247f6:	428a      	cmp	r2, r1
   247f8:	f340 828f 	ble.w	24d1a <dynalloc_analysis.isra.5+0xb66>
         return MIN16(t2, t3);
   247fc:	4562      	cmp	r2, ip
   247fe:	bfa8      	it	ge
   24800:	4662      	movge	r2, ip
   24802:	b213      	sxth	r3, r2
            f[i] = MAX16(f[i], median_of_5(&bandLogE2[c*nbEBands+i-2])-offset);
   24804:	f5a3 6380 	sub.w	r3, r3, #1024	; 0x400
   24808:	459a      	cmp	sl, r3
   2480a:	f300 8084 	bgt.w	24916 <dynalloc_analysis.isra.5+0x762>
   2480e:	4672      	mov	r2, lr
   24810:	3204      	adds	r2, #4
   24812:	4295      	cmp	r5, r2
   24814:	8123      	strh	r3, [r4, #8]
   24816:	f106 0606 	add.w	r6, r6, #6
   2481a:	f104 0406 	add.w	r4, r4, #6
   2481e:	f10e 0e03 	add.w	lr, lr, #3
   24822:	f340 8083 	ble.w	2492c <dynalloc_analysis.isra.5+0x778>
   if (x[3] > x[4])
   24826:	4660      	mov	r0, ip
   24828:	4642      	mov	r2, r8
   2482a:	464b      	mov	r3, r9
   if (x[0] > x[1])
   2482c:	f9b6 1000 	ldrsh.w	r1, [r6]
            f[i] = MAX16(f[i], median_of_5(&bandLogE2[c*nbEBands+i-2])-offset);
   24830:	f9b4 9004 	ldrsh.w	r9, [r4, #4]
   if (x[0] > x[1])
   24834:	4281      	cmp	r1, r0
   24836:	dd02      	ble.n	2483e <dynalloc_analysis.isra.5+0x68a>
   24838:	468c      	mov	ip, r1
   2483a:	4601      	mov	r1, r0
   2483c:	4660      	mov	r0, ip
   if (x[3] > x[4])
   2483e:	f9b6 c008 	ldrsh.w	ip, [r6, #8]
   24842:	459c      	cmp	ip, r3
   24844:	bfb5      	itete	lt
   24846:	46e2      	movlt	sl, ip
   24848:	469a      	movge	sl, r3
   2484a:	4698      	movlt	r8, r3
   2484c:	46e0      	movge	r8, ip
   if (t0 > t3)
   2484e:	458a      	cmp	sl, r1
   24850:	db03      	blt.n	2485a <dynalloc_analysis.isra.5+0x6a6>
   24852:	46c3      	mov	fp, r8
   24854:	4651      	mov	r1, sl
   24856:	4680      	mov	r8, r0
   24858:	4658      	mov	r0, fp
   if (t2 > t1)
   2485a:	4590      	cmp	r8, r2
   2485c:	f6ff af79 	blt.w	24752 <dynalloc_analysis.isra.5+0x59e>
      if (t2 < t3)
   24860:	4291      	cmp	r1, r2
   24862:	f300 825f 	bgt.w	24d24 <dynalloc_analysis.isra.5+0xb70>
         return MIN16(t2, t4);
   24866:	4290      	cmp	r0, r2
   24868:	bfa8      	it	ge
   2486a:	4610      	movge	r0, r2
   2486c:	b201      	sxth	r1, r0
   2486e:	e777      	b.n	24760 <dynalloc_analysis.isra.5+0x5ac>
            offsets[i] = boost;
            tot_boost += boost_bits;
         }
      }
   } else {
      for (i=start;i<end;i++)
   24870:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
   24874:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   24876:	4293      	cmp	r3, r2
   24878:	dd12      	ble.n	248a0 <dynalloc_analysis.isra.5+0x6ec>
   2487a:	f102 4680 	add.w	r6, r2, #1073741824	; 0x40000000
   2487e:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
   24882:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
   24886:	3e01      	subs	r6, #1
   24888:	eb02 0686 	add.w	r6, r2, r6, lsl #2
   2488c:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
   24890:	3b04      	subs	r3, #4
   24892:	eb03 0382 	add.w	r3, r3, r2, lsl #2
         importance[i] = 13;
   24896:	220d      	movs	r2, #13
   24898:	f846 2f04 	str.w	r2, [r6, #4]!
      for (i=start;i<end;i++)
   2489c:	429e      	cmp	r6, r3
   2489e:	d1fb      	bne.n	24898 <dynalloc_analysis.isra.5+0x6e4>
   opus_int32 tot_boost=0;
   248a0:	2300      	movs	r3, #0
   }
   *tot_boost_ = tot_boost;
   248a2:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
   RESTORE_STACK;
   return maxDepth;
}
   248a6:	4658      	mov	r0, fp
   248a8:	376c      	adds	r7, #108	; 0x6c
   *tot_boost_ = tot_boost;
   248aa:	6013      	str	r3, [r2, #0]
}
   248ac:	46bd      	mov	sp, r7
   248ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      for (i=0;i<end;i++)
   248b2:	4560      	cmp	r0, ip
         spread_weight[i] = 32 >> shift;
   248b4:	f844 ef04 	str.w	lr, [r4, #4]!
      for (i=0;i<end;i++)
   248b8:	f47f ae69 	bne.w	2458e <dynalloc_analysis.isra.5+0x3da>
   248bc:	e680      	b.n	245c0 <dynalloc_analysis.isra.5+0x40c>
   248be:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   248c0:	6bba      	ldr	r2, [r7, #56]	; 0x38
   248c2:	1e9e      	subs	r6, r3, #2
   248c4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   248c6:	441e      	add	r6, r3
   248c8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   248ca:	1ea0      	subs	r0, r4, #2
   248cc:	1e9d      	subs	r5, r3, #2
   248ce:	eb03 0c02 	add.w	ip, r3, r2
            mask[i] = MAX16(mask[i], bandLogE[nbEBands+i]-noise_floor[i]);
   248d2:	f935 3f02 	ldrsh.w	r3, [r5, #2]!
   248d6:	f936 2f02 	ldrsh.w	r2, [r6, #2]!
   248da:	f930 1f02 	ldrsh.w	r1, [r0, #2]!
   248de:	1ad3      	subs	r3, r2, r3
   248e0:	428b      	cmp	r3, r1
   248e2:	bfb8      	it	lt
   248e4:	460b      	movlt	r3, r1
         for (i=0;i<end;i++)
   248e6:	4565      	cmp	r5, ip
            mask[i] = MAX16(mask[i], bandLogE[nbEBands+i]-noise_floor[i]);
   248e8:	8003      	strh	r3, [r0, #0]
         for (i=0;i<end;i++)
   248ea:	d1f2      	bne.n	248d2 <dynalloc_analysis.isra.5+0x71e>
   248ec:	e5e8      	b.n	244c0 <dynalloc_analysis.isra.5+0x30c>
      if (t2 < t3)
   248ee:	428b      	cmp	r3, r1
   248f0:	f2c0 8222 	blt.w	24d38 <dynalloc_analysis.isra.5+0xb84>
         return MIN16(t2, t4);
   248f4:	429a      	cmp	r2, r3
   248f6:	bfa8      	it	ge
   248f8:	461a      	movge	r2, r3
   248fa:	b212      	sxth	r2, r2
   248fc:	e759      	b.n	247b2 <dynalloc_analysis.isra.5+0x5fe>
      if (t2 < t3)
   248fe:	4594      	cmp	ip, r2
   24900:	f2c0 8215 	blt.w	24d2e <dynalloc_analysis.isra.5+0xb7a>
         return MIN16(t2, t4);
   24904:	4563      	cmp	r3, ip
   24906:	bfa8      	it	ge
   24908:	4663      	movge	r3, ip
   2490a:	b21b      	sxth	r3, r3
            f[i] = MAX16(f[i], median_of_5(&bandLogE2[c*nbEBands+i-2])-offset);
   2490c:	f5a3 6380 	sub.w	r3, r3, #1024	; 0x400
   24910:	459a      	cmp	sl, r3
   24912:	f77f af7c 	ble.w	2480e <dynalloc_analysis.isra.5+0x65a>
   24916:	4673      	mov	r3, lr
   24918:	3304      	adds	r3, #4
   2491a:	429d      	cmp	r5, r3
   2491c:	f104 0406 	add.w	r4, r4, #6
   24920:	f106 0606 	add.w	r6, r6, #6
   24924:	f10e 0e03 	add.w	lr, lr, #3
   24928:	f73f af7d 	bgt.w	24826 <dynalloc_analysis.isra.5+0x672>
   2492c:	f8d7 b020 	ldr.w	fp, [r7, #32]
   24930:	f8d7 50c0 	ldr.w	r5, [r7, #192]	; 0xc0
   24934:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   24936:	eb0e 0403 	add.w	r4, lr, r3
   2493a:	f104 4800 	add.w	r8, r4, #2147483648	; 0x80000000
   2493e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   24940:	f1a8 0803 	sub.w	r8, r8, #3
   24944:	f10e 4c00 	add.w	ip, lr, #2147483648	; 0x80000000
   24948:	eb03 0848 	add.w	r8, r3, r8, lsl #1
   2494c:	eb03 0444 	add.w	r4, r3, r4, lsl #1
   24950:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   24952:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
   24956:	eb03 0c4c 	add.w	ip, r3, ip, lsl #1
   t2 = x[2];
   2495a:	f934 9b02 	ldrsh.w	r9, [r4], #2
   if (x[0] > x[1])
   2495e:	f938 3f02 	ldrsh.w	r3, [r8, #2]!
   24962:	f934 0c04 	ldrsh.w	r0, [r4, #-4]
            f[i] = MAX16(f[i], median_of_5(&bandLogE2[c*nbEBands+i-2])-offset);
   24966:	f93c 2f02 	ldrsh.w	r2, [ip, #2]!
   if (x[0] > x[1])
   2496a:	4298      	cmp	r0, r3
   2496c:	da02      	bge.n	24974 <dynalloc_analysis.isra.5+0x7c0>
   2496e:	4619      	mov	r1, r3
   24970:	4603      	mov	r3, r0
   24972:	4608      	mov	r0, r1
   if (x[3] > x[4])
   24974:	f9b4 6000 	ldrsh.w	r6, [r4]
   24978:	f9b4 1002 	ldrsh.w	r1, [r4, #2]
   2497c:	42b1      	cmp	r1, r6
   2497e:	da02      	bge.n	24986 <dynalloc_analysis.isra.5+0x7d2>
   24980:	46b2      	mov	sl, r6
   24982:	460e      	mov	r6, r1
   24984:	4651      	mov	r1, sl
   if (t0 > t3)
   24986:	429e      	cmp	r6, r3
   24988:	db03      	blt.n	24992 <dynalloc_analysis.isra.5+0x7de>
   2498a:	468a      	mov	sl, r1
   2498c:	4633      	mov	r3, r6
   2498e:	4601      	mov	r1, r0
   24990:	4650      	mov	r0, sl
   if (t2 > t1)
   24992:	4549      	cmp	r1, r9
   24994:	f2c0 81aa 	blt.w	24cec <dynalloc_analysis.isra.5+0xb38>
      if (t2 < t3)
   24998:	454b      	cmp	r3, r9
   2499a:	f300 81aa 	bgt.w	24cf2 <dynalloc_analysis.isra.5+0xb3e>
         return MIN16(t2, t4);
   2499e:	4548      	cmp	r0, r9
   249a0:	4603      	mov	r3, r0
   249a2:	bfa8      	it	ge
   249a4:	464b      	movge	r3, r9
   249a6:	b21b      	sxth	r3, r3
            f[i] = MAX16(f[i], median_of_5(&bandLogE2[c*nbEBands+i-2])-offset);
   249a8:	f5a3 6380 	sub.w	r3, r3, #1024	; 0x400
   249ac:	429a      	cmp	r2, r3
         for (i=2;i<end-2;i++)
   249ae:	f10e 0e01 	add.w	lr, lr, #1
            f[i] = MAX16(f[i], median_of_5(&bandLogE2[c*nbEBands+i-2])-offset);
   249b2:	f300 8196 	bgt.w	24ce2 <dynalloc_analysis.isra.5+0xb2e>
   249b6:	f8ac 3000 	strh.w	r3, [ip]
         for (i=2;i<end-2;i++)
   249ba:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   249bc:	4573      	cmp	r3, lr
   249be:	dccc      	bgt.n	2495a <dynalloc_analysis.isra.5+0x7a6>
   if (x[0] > x[1])
   249c0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   249c2:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   249c4:	429a      	cmp	r2, r3
   249c6:	dd01      	ble.n	249cc <dynalloc_analysis.isra.5+0x818>
   249c8:	643b      	str	r3, [r7, #64]	; 0x40
   249ca:	4613      	mov	r3, r2
   if (t1 < t2)
   249cc:	6aba      	ldr	r2, [r7, #40]	; 0x28
   249ce:	429a      	cmp	r2, r3
   249d0:	dc04      	bgt.n	249dc <dynalloc_analysis.isra.5+0x828>
   249d2:	6c39      	ldr	r1, [r7, #64]	; 0x40
   249d4:	428a      	cmp	r2, r1
   249d6:	bfb8      	it	lt
   249d8:	460a      	movlt	r2, r1
   249da:	b213      	sxth	r3, r2
         f[0] = MAX16(f[0], tmp);
   249dc:	6d7e      	ldr	r6, [r7, #84]	; 0x54
   249de:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   249e0:	f9b6 1002 	ldrsh.w	r1, [r6, #2]
         f[1] = MAX16(f[1], tmp);
   249e4:	f9b6 4004 	ldrsh.w	r4, [r6, #4]
         tmp = median_of_3(&bandLogE2[c*nbEBands])-offset;
   249e8:	f5a3 6380 	sub.w	r3, r3, #1024	; 0x400
   249ec:	b21b      	sxth	r3, r3
         f[0] = MAX16(f[0], tmp);
   249ee:	4299      	cmp	r1, r3
   249f0:	445a      	add	r2, fp
   249f2:	bfb8      	it	lt
   249f4:	4619      	movlt	r1, r3
   if (x[0] > x[1])
   249f6:	f932 0c06 	ldrsh.w	r0, [r2, #-6]
         f[0] = MAX16(f[0], tmp);
   249fa:	8071      	strh	r1, [r6, #2]
   if (x[0] > x[1])
   249fc:	f932 1c04 	ldrsh.w	r1, [r2, #-4]
         f[1] = MAX16(f[1], tmp);
   24a00:	42a3      	cmp	r3, r4
   24a02:	bfb8      	it	lt
   24a04:	4623      	movlt	r3, r4
   if (x[0] > x[1])
   24a06:	4288      	cmp	r0, r1
         f[1] = MAX16(f[1], tmp);
   24a08:	80b3      	strh	r3, [r6, #4]
   if (x[0] > x[1])
   24a0a:	dd02      	ble.n	24a12 <dynalloc_analysis.isra.5+0x85e>
   24a0c:	4603      	mov	r3, r0
   24a0e:	4608      	mov	r0, r1
   24a10:	4619      	mov	r1, r3
   t2 = x[2];
   24a12:	f932 3c02 	ldrsh.w	r3, [r2, #-2]
   if (t1 < t2)
   24a16:	428b      	cmp	r3, r1
   24a18:	dc03      	bgt.n	24a22 <dynalloc_analysis.isra.5+0x86e>
   24a1a:	4283      	cmp	r3, r0
   24a1c:	bfb8      	it	lt
   24a1e:	4603      	movlt	r3, r0
   24a20:	4619      	mov	r1, r3
         f[end-2] = MAX16(f[end-2], tmp);
   24a22:	6dba      	ldr	r2, [r7, #88]	; 0x58
   24a24:	69f8      	ldr	r0, [r7, #28]
         tmp = median_of_3(&bandLogE2[c*nbEBands+end-3])-offset;
   24a26:	f5a1 6180 	sub.w	r1, r1, #1024	; 0x400
         f[end-2] = MAX16(f[end-2], tmp);
   24a2a:	f930 3012 	ldrsh.w	r3, [r0, r2, lsl #1]
         tmp = median_of_3(&bandLogE2[c*nbEBands+end-3])-offset;
   24a2e:	b209      	sxth	r1, r1
         f[end-2] = MAX16(f[end-2], tmp);
   24a30:	428b      	cmp	r3, r1
   24a32:	bfb8      	it	lt
   24a34:	460b      	movlt	r3, r1
   24a36:	f820 3012 	strh.w	r3, [r0, r2, lsl #1]
         f[end-1] = MAX16(f[end-1], tmp);
   24a3a:	69b8      	ldr	r0, [r7, #24]
   24a3c:	f930 3012 	ldrsh.w	r3, [r0, r2, lsl #1]
   24a40:	4299      	cmp	r1, r3
   24a42:	bfb8      	it	lt
   24a44:	4619      	movlt	r1, r3
         for (i=0;i<end;i++)
   24a46:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
         f[end-1] = MAX16(f[end-1], tmp);
   24a4a:	f820 1012 	strh.w	r1, [r0, r2, lsl #1]
         for (i=0;i<end;i++)
   24a4e:	2b00      	cmp	r3, #0
   24a50:	dd0d      	ble.n	24a6e <dynalloc_analysis.isra.5+0x8ba>
   24a52:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   24a54:	6d79      	ldr	r1, [r7, #84]	; 0x54
   24a56:	693c      	ldr	r4, [r7, #16]
   24a58:	1e98      	subs	r0, r3, #2
            f[i] = MAX16(f[i], noise_floor[i]);
   24a5a:	f930 3f02 	ldrsh.w	r3, [r0, #2]!
   24a5e:	f931 2f02 	ldrsh.w	r2, [r1, #2]!
   24a62:	4293      	cmp	r3, r2
   24a64:	bfb8      	it	lt
   24a66:	4613      	movlt	r3, r2
         for (i=0;i<end;i++)
   24a68:	42a0      	cmp	r0, r4
            f[i] = MAX16(f[i], noise_floor[i]);
   24a6a:	800b      	strh	r3, [r1, #0]
         for (i=0;i<end;i++)
   24a6c:	d1f5      	bne.n	24a5a <dynalloc_analysis.isra.5+0x8a6>
   24a6e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   24a70:	6d79      	ldr	r1, [r7, #84]	; 0x54
      } while (++c<C);
   24a72:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   24a74:	4411      	add	r1, r2
   24a76:	4493      	add	fp, r2
   24a78:	6579      	str	r1, [r7, #84]	; 0x54
   24a7a:	6dba      	ldr	r2, [r7, #88]	; 0x58
   24a7c:	6b79      	ldr	r1, [r7, #52]	; 0x34
   24a7e:	440a      	add	r2, r1
   24a80:	65ba      	str	r2, [r7, #88]	; 0x58
   24a82:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
   24a86:	3301      	adds	r3, #1
   24a88:	429a      	cmp	r2, r3
   24a8a:	633b      	str	r3, [r7, #48]	; 0x30
   24a8c:	f73f adc7 	bgt.w	2461e <dynalloc_analysis.isra.5+0x46a>
      if (C==2)
   24a90:	2a02      	cmp	r2, #2
   24a92:	f8d7 b004 	ldr.w	fp, [r7, #4]
         for (i=start;i<end;i++)
   24a96:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
      if (C==2)
   24a9a:	f000 8210 	beq.w	24ebe <dynalloc_analysis.isra.5+0xd0a>
         for (i=start;i<end;i++)
   24a9e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   24aa0:	4293      	cmp	r3, r2
   24aa2:	f340 8084 	ble.w	24bae <dynalloc_analysis.isra.5+0x9fa>
   24aa6:	f102 4100 	add.w	r1, r2, #2147483648	; 0x80000000
   24aaa:	697b      	ldr	r3, [r7, #20]
   24aac:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   24aae:	4413      	add	r3, r2
   24ab0:	3901      	subs	r1, #1
   24ab2:	461c      	mov	r4, r3
   24ab4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   24ab6:	0048      	lsls	r0, r1, #1
   24ab8:	4403      	add	r3, r0
   24aba:	461d      	mov	r5, r3
   24abc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   24abe:	4418      	add	r0, r3
            follower[i] = MAX16(0, bandLogE[i]-follower[i]);
   24ac0:	f935 3f02 	ldrsh.w	r3, [r5, #2]!
   24ac4:	f930 2f02 	ldrsh.w	r2, [r0, #2]!
   24ac8:	1a9b      	subs	r3, r3, r2
   24aca:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
         for (i=start;i<end;i++)
   24ace:	42a5      	cmp	r5, r4
            follower[i] = MAX16(0, bandLogE[i]-follower[i]);
   24ad0:	8003      	strh	r3, [r0, #0]
         for (i=start;i<end;i++)
   24ad2:	d1f5      	bne.n	24ac0 <dynalloc_analysis.isra.5+0x90c>
   24ad4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   24ad6:	005d      	lsls	r5, r3, #1
   24ad8:	461c      	mov	r4, r3
   24ada:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
   24ade:	f8d7 6090 	ldr.w	r6, [r7, #144]	; 0x90
   24ae2:	0049      	lsls	r1, r1, #1
   24ae4:	1858      	adds	r0, r3, r1
   24ae6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   24ae8:	4419      	add	r1, r3
         follower[i] = MAX16(follower[i], surround_dynalloc[i]);
   24aea:	f930 3f02 	ldrsh.w	r3, [r0, #2]!
   24aee:	f931 2f02 	ldrsh.w	r2, [r1, #2]!
      for (i=start;i<end;i++)
   24af2:	3401      	adds	r4, #1
         follower[i] = MAX16(follower[i], surround_dynalloc[i]);
   24af4:	4293      	cmp	r3, r2
   24af6:	bfb8      	it	lt
   24af8:	4613      	movlt	r3, r2
      for (i=start;i<end;i++)
   24afa:	42a6      	cmp	r6, r4
         follower[i] = MAX16(follower[i], surround_dynalloc[i]);
   24afc:	800b      	strh	r3, [r1, #0]
      for (i=start;i<end;i++)
   24afe:	dcf4      	bgt.n	24aea <dynalloc_analysis.isra.5+0x936>
   24b00:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   24b02:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
   if (integer>14)
      return 0x7f000000;
   else if (integer < -15)
      return 0;
   frac = celt_exp2_frac(x-SHL16(integer,10));
   return VSHR32(EXTEND32(frac), -integer-2);
   24b04:	f8c7 b064 	str.w	fp, [r7, #100]	; 0x64
   24b08:	1eaa      	subs	r2, r5, #2
   24b0a:	f103 4680 	add.w	r6, r3, #1073741824	; 0x40000000
   24b0e:	188c      	adds	r4, r1, r2
   24b10:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
   24b14:	3e01      	subs	r6, #1
   24b16:	eb02 0686 	add.w	r6, r2, r6, lsl #2
   24b1a:	461d      	mov	r5, r3
   return ADD16(D0, MULT16_16_Q15(frac, ADD16(D1, MULT16_16_Q15(frac, ADD16(D2 , MULT16_16_Q15(D3,frac))))));
   24b1c:	f242 79dc 	movw	r9, #10204	; 0x27dc
   24b20:	f643 18e3 	movw	r8, #14819	; 0x39e3
   24b24:	f645 1e14 	movw	lr, #22804	; 0x5914
   24b28:	f643 7aff 	movw	sl, #16383	; 0x3fff
   return VSHR32(EXTEND32(frac), -integer-2);
   24b2c:	f06f 0001 	mvn.w	r0, #1
   24b30:	e013      	b.n	24b5a <dynalloc_analysis.isra.5+0x9a6>
   24b32:	fa43 f10c 	asr.w	r1, r3, ip
   24b36:	eb01 0b41 	add.w	fp, r1, r1, lsl #1
   24b3a:	eb01 018b 	add.w	r1, r1, fp, lsl #2
   24b3e:	f1bc 0f00 	cmp.w	ip, #0
   24b42:	f501 4100 	add.w	r1, r1, #32768	; 0x8000
   24b46:	f340 8143 	ble.w	24dd0 <dynalloc_analysis.isra.5+0xc1c>
   24b4a:	140b      	asrs	r3, r1, #16
         importance[i] = PSHR32(13*celt_exp2(MIN16(follower[i], QCONST16(4.f, DB_SHIFT))), 16);
   24b4c:	f846 3f04 	str.w	r3, [r6, #4]!
      for (i=start;i<end;i++)
   24b50:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
   24b54:	3501      	adds	r5, #1
   24b56:	42ab      	cmp	r3, r5
   24b58:	dd27      	ble.n	24baa <dynalloc_analysis.isra.5+0x9f6>
         importance[i] = PSHR32(13*celt_exp2(MIN16(follower[i], QCONST16(4.f, DB_SHIFT))), 16);
   24b5a:	f934 3f02 	ldrsh.w	r3, [r4, #2]!
   24b5e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   24b62:	bfa8      	it	ge
   24b64:	f44f 5380 	movge.w	r3, #4096	; 0x1000
   integer = SHR16(x,10);
   24b68:	129a      	asrs	r2, r3, #10
   frac = celt_exp2_frac(x-SHL16(integer,10));
   24b6a:	b291      	uxth	r1, r2
   24b6c:	eba3 2381 	sub.w	r3, r3, r1, lsl #10
   frac = SHL16(x, 4);
   24b70:	f343 030b 	sbfx	r3, r3, #0, #12
   24b74:	011b      	lsls	r3, r3, #4
   return ADD16(D0, MULT16_16_Q15(frac, ADD16(D1, MULT16_16_Q15(frac, ADD16(D2 , MULT16_16_Q15(D3,frac))))));
   24b76:	fb13 f109 	smulbb	r1, r3, r9
   24b7a:	eb08 31e1 	add.w	r1, r8, r1, asr #15
   24b7e:	fb11 f103 	smulbb	r1, r1, r3
   24b82:	eb0e 31e1 	add.w	r1, lr, r1, asr #15
   24b86:	fb11 f303 	smulbb	r3, r1, r3
   24b8a:	eb0a 33e3 	add.w	r3, sl, r3, asr #15
   else if (integer < -15)
   24b8e:	f112 0f0f 	cmn.w	r2, #15
   return VSHR32(EXTEND32(frac), -integer-2);
   24b92:	eba0 0c02 	sub.w	ip, r0, r2
   return ADD16(D0, MULT16_16_Q15(frac, ADD16(D1, MULT16_16_Q15(frac, ADD16(D2 , MULT16_16_Q15(D3,frac))))));
   24b96:	b21b      	sxth	r3, r3
   else if (integer < -15)
   24b98:	dacb      	bge.n	24b32 <dynalloc_analysis.isra.5+0x97e>
   24b9a:	2300      	movs	r3, #0
   24b9c:	f846 3f04 	str.w	r3, [r6, #4]!
      for (i=start;i<end;i++)
   24ba0:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
   24ba4:	3501      	adds	r5, #1
   24ba6:	42ab      	cmp	r3, r5
   24ba8:	dcd7      	bgt.n	24b5a <dynalloc_analysis.isra.5+0x9a6>
   24baa:	f8d7 b064 	ldr.w	fp, [r7, #100]	; 0x64
      if ((!vbr || constrained_vbr)&&!isTransient)
   24bae:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   24bb2:	b123      	cbz	r3, 24bbe <dynalloc_analysis.isra.5+0xa0a>
   24bb4:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
   24bb8:	2b00      	cmp	r3, #0
   24bba:	f000 80d4 	beq.w	24d66 <dynalloc_analysis.isra.5+0xbb2>
   24bbe:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
   24bc2:	2b00      	cmp	r3, #0
   24bc4:	f040 80cf 	bne.w	24d66 <dynalloc_analysis.isra.5+0xbb2>
         for (i=start;i<end;i++)
   24bc8:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
   24bcc:	461a      	mov	r2, r3
   24bce:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   24bd0:	429a      	cmp	r2, r3
   24bd2:	4619      	mov	r1, r3
   24bd4:	f77f ae64 	ble.w	248a0 <dynalloc_analysis.isra.5+0x6ec>
   24bd8:	005d      	lsls	r5, r3, #1
   24bda:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   24bdc:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
   24be0:	1eaa      	subs	r2, r5, #2
   24be2:	441a      	add	r2, r3
            follower[i] = HALF16(follower[i]);
   24be4:	f932 3f02 	ldrsh.w	r3, [r2, #2]!
         for (i=start;i<end;i++)
   24be8:	3101      	adds	r1, #1
            follower[i] = HALF16(follower[i]);
   24bea:	105b      	asrs	r3, r3, #1
         for (i=start;i<end;i++)
   24bec:	4288      	cmp	r0, r1
            follower[i] = HALF16(follower[i]);
   24bee:	8013      	strh	r3, [r2, #0]
         for (i=start;i<end;i++)
   24bf0:	d1f8      	bne.n	24be4 <dynalloc_analysis.isra.5+0xa30>
   24bf2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   24bf4:	2b07      	cmp	r3, #7
   24bf6:	f340 80d2 	ble.w	24d9e <dynalloc_analysis.isra.5+0xbea>
   24bfa:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
   24bfc:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
         if (i>=12)
   24c00:	2b0b      	cmp	r3, #11
   24c02:	dd04      	ble.n	24c0e <dynalloc_analysis.isra.5+0xa5a>
            follower[i] = HALF16(follower[i]);
   24c04:	f931 2013 	ldrsh.w	r2, [r1, r3, lsl #1]
   24c08:	1052      	asrs	r2, r2, #1
   24c0a:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
      for (i=start;i<end;i++)
   24c0e:	3301      	adds	r3, #1
   24c10:	4298      	cmp	r0, r3
   24c12:	dcf5      	bgt.n	24c00 <dynalloc_analysis.isra.5+0xa4c>
               && (tot_boost+boost_bits)>>BITRES>>3 > 2*effectiveBytes/3)
   24c14:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
   24c18:	4bcb      	ldr	r3, [pc, #812]	; (24f48 <dynalloc_analysis.isra.5+0xd94>)
   24c1a:	0050      	lsls	r0, r2, #1
   24c1c:	fba3 3000 	umull	r3, r0, r3, r0
   24c20:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
   24c24:	0840      	lsrs	r0, r0, #1
   24c26:	2b00      	cmp	r3, #0
   24c28:	f000 80e8 	beq.w	24dfc <dynalloc_analysis.isra.5+0xc48>
   24c2c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
   24c30:	2b00      	cmp	r3, #0
   24c32:	f040 81e3 	bne.w	24ffc <dynalloc_analysis.isra.5+0xe48>
   24c36:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   24c3a:	2b00      	cmp	r3, #0
   24c3c:	f000 8253 	beq.w	250e6 <dynalloc_analysis.isra.5+0xf32>
   24c40:	6cfc      	ldr	r4, [r7, #76]	; 0x4c
   24c42:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   24c46:	4ec1      	ldr	r6, [pc, #772]	; (24f4c <dynalloc_analysis.isra.5+0xd98>)
               && (tot_boost+boost_bits)>>BITRES>>3 > 2*effectiveBytes/3)
   24c48:	f8c7 b064 	str.w	fp, [r7, #100]	; 0x64
   24c4c:	f104 4280 	add.w	r2, r4, #1073741824	; 0x40000000
   24c50:	3a01      	subs	r2, #1
   24c52:	eb03 0282 	add.w	r2, r3, r2, lsl #2
   24c56:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   24c58:	f8d7 8094 	ldr.w	r8, [r7, #148]	; 0x94
   24c5c:	f8d7 90b4 	ldr.w	r9, [r7, #180]	; 0xb4
   24c60:	f1a5 0c02 	sub.w	ip, r5, #2
   24c64:	4463      	add	r3, ip
   24c66:	469c      	mov	ip, r3
   24c68:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
   24c6c:	441d      	add	r5, r3
   24c6e:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
   24c72:	e019      	b.n	24ca8 <dynalloc_analysis.isra.5+0xaf4>
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   24c74:	fb01 fa00 	mul.w	sl, r1, r0
   24c78:	fb86 be0a 	smull	fp, lr, r6, sl
            boost = (int)SHR32(EXTEND32(follower[i])*8,DB_SHIFT);
   24c7c:	11c0      	asrs	r0, r0, #7
         } else if (width > 48) {
   24c7e:	2930      	cmp	r1, #48	; 0x30
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   24c80:	ebae 7eea 	sub.w	lr, lr, sl, asr #31
            boost_bits = (boost*width<<BITRES)/8;
   24c84:	fb01 fa00 	mul.w	sl, r1, r0
         } else if (width > 48) {
   24c88:	f300 8227 	bgt.w	250da <dynalloc_analysis.isra.5+0xf26>
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   24c8c:	ea4f 20ae 	mov.w	r0, lr, asr #10
            boost_bits = boost*6<<BITRES;
   24c90:	eb00 0140 	add.w	r1, r0, r0, lsl #1
   24c94:	0109      	lsls	r1, r1, #4
   24c96:	440b      	add	r3, r1
      for (i=start;i<end;i++)
   24c98:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
            offsets[i] = boost;
   24c9c:	f842 0f04 	str.w	r0, [r2, #4]!
      for (i=start;i<end;i++)
   24ca0:	3401      	adds	r4, #1
   24ca2:	42a1      	cmp	r1, r4
   24ca4:	f340 838b 	ble.w	253be <dynalloc_analysis.isra.5+0x120a>
   24ca8:	4628      	mov	r0, r5
         width = C*(eBands[i+1]-eBands[i])<<LM;
   24caa:	f9b5 1002 	ldrsh.w	r1, [r5, #2]
   24cae:	f9b0 e000 	ldrsh.w	lr, [r0]
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   24cb2:	f93c 0f02 	ldrsh.w	r0, [ip, #2]!
         width = C*(eBands[i+1]-eBands[i])<<LM;
   24cb6:	eba1 010e 	sub.w	r1, r1, lr
   24cba:	fb08 f101 	mul.w	r1, r8, r1
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   24cbe:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
         width = C*(eBands[i+1]-eBands[i])<<LM;
   24cc2:	fa01 f109 	lsl.w	r1, r1, r9
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   24cc6:	bfa8      	it	ge
   24cc8:	f44f 5080 	movge.w	r0, #4096	; 0x1000
         if (width<6)
   24ccc:	2905      	cmp	r1, #5
         width = C*(eBands[i+1]-eBands[i])<<LM;
   24cce:	f105 0502 	add.w	r5, r5, #2
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   24cd2:	f8ac 0000 	strh.w	r0, [ip]
         if (width<6)
   24cd6:	dccd      	bgt.n	24c74 <dynalloc_analysis.isra.5+0xac0>
            boost = (int)SHR32(EXTEND32(follower[i]),DB_SHIFT);
   24cd8:	1280      	asrs	r0, r0, #10
            boost_bits = boost*width<<BITRES;
   24cda:	fb01 f100 	mul.w	r1, r1, r0
   24cde:	00c9      	lsls	r1, r1, #3
   24ce0:	e7d9      	b.n	24c96 <dynalloc_analysis.isra.5+0xae2>
         for (i=2;i<end-2;i++)
   24ce2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   24ce4:	4573      	cmp	r3, lr
   24ce6:	f73f ae38 	bgt.w	2495a <dynalloc_analysis.isra.5+0x7a6>
   24cea:	e669      	b.n	249c0 <dynalloc_analysis.isra.5+0x80c>
      if (t1 < t3)
   24cec:	428b      	cmp	r3, r1
   24cee:	dc05      	bgt.n	24cfc <dynalloc_analysis.isra.5+0xb48>
         return MIN16(t4, t1);
   24cf0:	4603      	mov	r3, r0
   24cf2:	428b      	cmp	r3, r1
   24cf4:	bfa8      	it	ge
   24cf6:	460b      	movge	r3, r1
   24cf8:	b21b      	sxth	r3, r3
   24cfa:	e655      	b.n	249a8 <dynalloc_analysis.isra.5+0x7f4>
         return MIN16(t2, t3);
   24cfc:	454b      	cmp	r3, r9
   24cfe:	bfa8      	it	ge
   24d00:	464b      	movge	r3, r9
   24d02:	b21b      	sxth	r3, r3
   24d04:	e650      	b.n	249a8 <dynalloc_analysis.isra.5+0x7f4>
         return MIN16(t4, t1);
   24d06:	4540      	cmp	r0, r8
   24d08:	bfa8      	it	ge
   24d0a:	4640      	movge	r0, r8
   24d0c:	b201      	sxth	r1, r0
   24d0e:	e527      	b.n	24760 <dynalloc_analysis.isra.5+0x5ac>
   24d10:	4282      	cmp	r2, r0
   24d12:	bfa8      	it	ge
   24d14:	4602      	movge	r2, r0
   24d16:	b212      	sxth	r2, r2
   24d18:	e54b      	b.n	247b2 <dynalloc_analysis.isra.5+0x5fe>
   24d1a:	428b      	cmp	r3, r1
   24d1c:	bfa8      	it	ge
   24d1e:	460b      	movge	r3, r1
   24d20:	b21b      	sxth	r3, r3
   24d22:	e56f      	b.n	24804 <dynalloc_analysis.isra.5+0x650>
         return MIN16(t1, t3);
   24d24:	4541      	cmp	r1, r8
   24d26:	bfa8      	it	ge
   24d28:	4641      	movge	r1, r8
   24d2a:	b209      	sxth	r1, r1
   24d2c:	e518      	b.n	24760 <dynalloc_analysis.isra.5+0x5ac>
   24d2e:	428a      	cmp	r2, r1
   24d30:	bfa8      	it	ge
   24d32:	460a      	movge	r2, r1
   24d34:	b213      	sxth	r3, r2
   24d36:	e565      	b.n	24804 <dynalloc_analysis.isra.5+0x650>
   24d38:	4281      	cmp	r1, r0
   24d3a:	bfa8      	it	ge
   24d3c:	4601      	movge	r1, r0
   24d3e:	b20a      	sxth	r2, r1
   24d40:	e537      	b.n	247b2 <dynalloc_analysis.isra.5+0x5fe>
   24d42:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   24d44:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   24d46:	1e98      	subs	r0, r3, #2
   24d48:	697b      	ldr	r3, [r7, #20]
   24d4a:	1ea1      	subs	r1, r4, #2
   24d4c:	189d      	adds	r5, r3, r2
         mask[i] = bandLogE[i]-noise_floor[i];
   24d4e:	f83c 3f02 	ldrh.w	r3, [ip, #2]!
   24d52:	f830 2f02 	ldrh.w	r2, [r0, #2]!
      for (i=0;i<end;i++)
   24d56:	45ac      	cmp	ip, r5
         mask[i] = bandLogE[i]-noise_floor[i];
   24d58:	eba3 0302 	sub.w	r3, r3, r2
   24d5c:	f821 3f02 	strh.w	r3, [r1, #2]!
      for (i=0;i<end;i++)
   24d60:	d1f5      	bne.n	24d4e <dynalloc_analysis.isra.5+0xb9a>
   24d62:	f7ff bba8 	b.w	244b6 <dynalloc_analysis.isra.5+0x302>
      for (i=start;i<end;i++)
   24d66:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
   24d6a:	4619      	mov	r1, r3
   24d6c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   24d6e:	4299      	cmp	r1, r3
   24d70:	f77f ad96 	ble.w	248a0 <dynalloc_analysis.isra.5+0x6ec>
   24d74:	005d      	lsls	r5, r3, #1
   24d76:	e73c      	b.n	24bf2 <dynalloc_analysis.isra.5+0xa3e>
   24d78:	f9bb 3002 	ldrsh.w	r3, [fp, #2]
   24d7c:	62fb      	str	r3, [r7, #44]	; 0x2c
   24d7e:	f9bb 3004 	ldrsh.w	r3, [fp, #4]
   24d82:	62bb      	str	r3, [r7, #40]	; 0x28
   24d84:	e61c      	b.n	249c0 <dynalloc_analysis.isra.5+0x80c>
   24d86:	005b      	lsls	r3, r3, #1
   24d88:	653b      	str	r3, [r7, #80]	; 0x50
   24d8a:	461a      	mov	r2, r3
   24d8c:	f7ff ba63 	b.w	24256 <dynalloc_analysis.isra.5+0xa2>
      OPUS_COPY(sig, mask, end);
   24d90:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   24d92:	4621      	mov	r1, r4
   24d94:	4640      	mov	r0, r8
   24d96:	f7e7 f9b3 	bl	c100 <memcpy>
   24d9a:	f7ff bbb6 	b.w	2450a <dynalloc_analysis.isra.5+0x356>
   24d9e:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
   24da2:	1e58      	subs	r0, r3, #1
   24da4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   24da6:	1ea9      	subs	r1, r5, #2
   24da8:	2807      	cmp	r0, #7
   24daa:	4419      	add	r1, r3
         for (i=start;i<end;i++)
   24dac:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   24dae:	bfa8      	it	ge
   24db0:	2007      	movge	r0, #7
            follower[i] *= 2;
   24db2:	f831 2f02 	ldrh.w	r2, [r1, #2]!
      for (i=start;i<end;i++)
   24db6:	3301      	adds	r3, #1
            follower[i] *= 2;
   24db8:	0052      	lsls	r2, r2, #1
      for (i=start;i<end;i++)
   24dba:	4283      	cmp	r3, r0
            follower[i] *= 2;
   24dbc:	800a      	strh	r2, [r1, #0]
      for (i=start;i<end;i++)
   24dbe:	ddf8      	ble.n	24db2 <dynalloc_analysis.isra.5+0xbfe>
   24dc0:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
   24dc4:	429a      	cmp	r2, r3
   24dc6:	f77f af25 	ble.w	24c14 <dynalloc_analysis.isra.5+0xa60>
   24dca:	4610      	mov	r0, r2
   24dcc:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
   24dce:	e717      	b.n	24c00 <dynalloc_analysis.isra.5+0xa4c>
   return VSHR32(EXTEND32(frac), -integer-2);
   24dd0:	3202      	adds	r2, #2
   24dd2:	4093      	lsls	r3, r2
   24dd4:	eb03 0243 	add.w	r2, r3, r3, lsl #1
   24dd8:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   24ddc:	f503 4300 	add.w	r3, r3, #32768	; 0x8000
   24de0:	141b      	asrs	r3, r3, #16
   24de2:	e6b3      	b.n	24b4c <dynalloc_analysis.isra.5+0x998>
   24de4:	f9bb 3002 	ldrsh.w	r3, [fp, #2]
   24de8:	62fb      	str	r3, [r7, #44]	; 0x2c
   24dea:	f9bb 3004 	ldrsh.w	r3, [fp, #4]
   24dee:	62bb      	str	r3, [r7, #40]	; 0x28
         for (i=2;i<end-2;i++)
   24df0:	f04f 0e02 	mov.w	lr, #2
   24df4:	e59e      	b.n	24934 <dynalloc_analysis.isra.5+0x780>
         for (i=1;i<end;i++)
   24df6:	2301      	movs	r3, #1
   24df8:	4696      	mov	lr, r2
   24dfa:	e44c      	b.n	24696 <dynalloc_analysis.isra.5+0x4e2>
   24dfc:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
   24e00:	2b00      	cmp	r3, #0
   24e02:	f000 80a5 	beq.w	24f50 <dynalloc_analysis.isra.5+0xd9c>
   24e06:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   24e0a:	2b00      	cmp	r3, #0
   24e0c:	f000 827d 	beq.w	2530a <dynalloc_analysis.isra.5+0x1156>
   24e10:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   24e12:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   24e16:	f8df e134 	ldr.w	lr, [pc, #308]	; 24f4c <dynalloc_analysis.isra.5+0xd98>
               && (tot_boost+boost_bits)>>BITRES>>3 > 2*effectiveBytes/3)
   24e1a:	f8d7 10a4 	ldr.w	r1, [r7, #164]	; 0xa4
   24e1e:	6678      	str	r0, [r7, #100]	; 0x64
   24e20:	f103 4c80 	add.w	ip, r3, #1073741824	; 0x40000000
   24e24:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
   24e28:	eb02 0c8c 	add.w	ip, r2, ip, lsl #2
   24e2c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
   24e2e:	f8d7 90b4 	ldr.w	r9, [r7, #180]	; 0xb4
   24e32:	1eae      	subs	r6, r5, #2
   24e34:	4432      	add	r2, r6
   24e36:	4616      	mov	r6, r2
   24e38:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
   24e3c:	442a      	add	r2, r5
   24e3e:	461d      	mov	r5, r3
   24e40:	e01f      	b.n	24e82 <dynalloc_analysis.isra.5+0xcce>
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   24e42:	fb03 fa04 	mul.w	sl, r3, r4
   24e46:	fb8e 080a 	smull	r0, r8, lr, sl
            boost = (int)SHR32(EXTEND32(follower[i])*8,DB_SHIFT);
   24e4a:	11e4      	asrs	r4, r4, #7
         } else if (width > 48) {
   24e4c:	2b30      	cmp	r3, #48	; 0x30
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   24e4e:	eba8 78ea 	sub.w	r8, r8, sl, asr #31
            boost_bits = (boost*width<<BITRES)/8;
   24e52:	fb03 fa04 	mul.w	sl, r3, r4
         } else if (width > 48) {
   24e56:	f300 8130 	bgt.w	250ba <dynalloc_analysis.isra.5+0xf06>
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   24e5a:	ea4f 24a8 	mov.w	r4, r8, asr #10
            boost_bits = boost*6<<BITRES;
   24e5e:	eb04 0344 	add.w	r3, r4, r4, lsl #1
   24e62:	011b      	lsls	r3, r3, #4
               && (tot_boost+boost_bits)>>BITRES>>3 > 2*effectiveBytes/3)
   24e64:	6e78      	ldr	r0, [r7, #100]	; 0x64
   24e66:	440b      	add	r3, r1
   24e68:	ebb0 1fa3 	cmp.w	r0, r3, asr #6
   24e6c:	f2c0 811b 	blt.w	250a6 <dynalloc_analysis.isra.5+0xef2>
      for (i=start;i<end;i++)
   24e70:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
            offsets[i] = boost;
   24e74:	f84c 4f04 	str.w	r4, [ip, #4]!
      for (i=start;i<end;i++)
   24e78:	3501      	adds	r5, #1
   24e7a:	42a8      	cmp	r0, r5
   24e7c:	4619      	mov	r1, r3
   24e7e:	f77f ad10 	ble.w	248a2 <dynalloc_analysis.isra.5+0x6ee>
   24e82:	4614      	mov	r4, r2
         width = C*(eBands[i+1]-eBands[i])<<LM;
   24e84:	f9b2 3002 	ldrsh.w	r3, [r2, #2]
   24e88:	f9b4 8000 	ldrsh.w	r8, [r4]
   24e8c:	f8d7 0094 	ldr.w	r0, [r7, #148]	; 0x94
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   24e90:	f936 4f02 	ldrsh.w	r4, [r6, #2]!
         width = C*(eBands[i+1]-eBands[i])<<LM;
   24e94:	eba3 0308 	sub.w	r3, r3, r8
   24e98:	fb00 f303 	mul.w	r3, r0, r3
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   24e9c:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
         width = C*(eBands[i+1]-eBands[i])<<LM;
   24ea0:	fa03 f309 	lsl.w	r3, r3, r9
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   24ea4:	bfa8      	it	ge
   24ea6:	f44f 5480 	movge.w	r4, #4096	; 0x1000
         if (width<6)
   24eaa:	2b05      	cmp	r3, #5
         width = C*(eBands[i+1]-eBands[i])<<LM;
   24eac:	f102 0202 	add.w	r2, r2, #2
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   24eb0:	8034      	strh	r4, [r6, #0]
         if (width<6)
   24eb2:	dcc6      	bgt.n	24e42 <dynalloc_analysis.isra.5+0xc8e>
            boost = (int)SHR32(EXTEND32(follower[i]),DB_SHIFT);
   24eb4:	12a4      	asrs	r4, r4, #10
            boost_bits = boost*width<<BITRES;
   24eb6:	fb03 f304 	mul.w	r3, r3, r4
   24eba:	00db      	lsls	r3, r3, #3
   24ebc:	e7d2      	b.n	24e64 <dynalloc_analysis.isra.5+0xcb0>
         for (i=start;i<end;i++)
   24ebe:	4619      	mov	r1, r3
   24ec0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   24ec2:	4299      	cmp	r1, r3
   24ec4:	f77f ae73 	ble.w	24bae <dynalloc_analysis.isra.5+0x9fa>
   24ec8:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   24eca:	4694      	mov	ip, r2
   24ecc:	449c      	add	ip, r3
   24ece:	005d      	lsls	r5, r3, #1
   24ed0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   24ed2:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
   24ed4:	469e      	mov	lr, r3
   24ed6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   24ed8:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
   24edc:	1eac      	subs	r4, r5, #2
   24ede:	eb03 060c 	add.w	r6, r3, ip
   24ee2:	eb02 0804 	add.w	r8, r2, r4
   24ee6:	449e      	add	lr, r3
   24ee8:	4494      	add	ip, r2
   24eea:	441c      	add	r4, r3
            follower[nbEBands+i] = MAX16(follower[nbEBands+i], follower[         i]-QCONST16(4.f,DB_SHIFT));
   24eec:	f934 2f02 	ldrsh.w	r2, [r4, #2]!
   24ef0:	f936 3b02 	ldrsh.w	r3, [r6], #2
   24ef4:	f6a2 71ff 	subw	r1, r2, #4095	; 0xfff
   24ef8:	428b      	cmp	r3, r1
   24efa:	bfbc      	itt	lt
   24efc:	f5a2 5380 	sublt.w	r3, r2, #4096	; 0x1000
   24f00:	b21b      	sxthlt	r3, r3
   24f02:	f826 3c02 	strh.w	r3, [r6, #-2]
            follower[         i] = MAX16(follower[         i], follower[nbEBands+i]-QCONST16(4.f,DB_SHIFT));
   24f06:	f9b4 2000 	ldrsh.w	r2, [r4]
   24f0a:	f6a3 71ff 	subw	r1, r3, #4095	; 0xfff
   24f0e:	428a      	cmp	r2, r1
   24f10:	bfbc      	itt	lt
   24f12:	f5a3 5380 	sublt.w	r3, r3, #4096	; 0x1000
   24f16:	b21a      	sxthlt	r2, r3
   24f18:	8022      	strh	r2, [r4, #0]
            follower[i] = HALF16(MAX16(0, bandLogE[i]-follower[i]) + MAX16(0, bandLogE[nbEBands+i]-follower[nbEBands+i]));
   24f1a:	f938 3f02 	ldrsh.w	r3, [r8, #2]!
   24f1e:	f936 0c02 	ldrsh.w	r0, [r6, #-2]
   24f22:	f93c 1b02 	ldrsh.w	r1, [ip], #2
   24f26:	1a9b      	subs	r3, r3, r2
   24f28:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   24f2c:	1a0a      	subs	r2, r1, r0
   24f2e:	2a00      	cmp	r2, #0
   24f30:	bfa8      	it	ge
   24f32:	189b      	addge	r3, r3, r2
   24f34:	105b      	asrs	r3, r3, #1
         for (i=start;i<end;i++)
   24f36:	4574      	cmp	r4, lr
            follower[i] = HALF16(MAX16(0, bandLogE[i]-follower[i]) + MAX16(0, bandLogE[nbEBands+i]-follower[nbEBands+i]));
   24f38:	8023      	strh	r3, [r4, #0]
         for (i=start;i<end;i++)
   24f3a:	d1d7      	bne.n	24eec <dynalloc_analysis.isra.5+0xd38>
   24f3c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   24f3e:	f103 4100 	add.w	r1, r3, #2147483648	; 0x80000000
   24f42:	3901      	subs	r1, #1
   24f44:	461c      	mov	r4, r3
   24f46:	e5c8      	b.n	24ada <dynalloc_analysis.isra.5+0x926>
   24f48:	aaaaaaab 	.word	0xaaaaaaab
   24f4c:	2aaaaaab 	.word	0x2aaaaaab
   24f50:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   24f54:	2b00      	cmp	r3, #0
   24f56:	f000 817d 	beq.w	25254 <dynalloc_analysis.isra.5+0x10a0>
   24f5a:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
   24f5c:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   24f60:	f8df e464 	ldr.w	lr, [pc, #1124]	; 253c8 <dynalloc_analysis.isra.5+0x1214>
               && (tot_boost+boost_bits)>>BITRES>>3 > 2*effectiveBytes/3)
   24f64:	f8d7 a0b4 	ldr.w	sl, [r7, #180]	; 0xb4
   24f68:	f100 4280 	add.w	r2, r0, #1073741824	; 0x40000000
   24f6c:	3a01      	subs	r2, #1
   24f6e:	eb03 0282 	add.w	r2, r3, r2, lsl #2
   24f72:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   24f74:	f1a5 0c02 	sub.w	ip, r5, #2
   24f78:	4463      	add	r3, ip
   24f7a:	469c      	mov	ip, r3
   24f7c:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
   24f80:	4680      	mov	r8, r0
   24f82:	1959      	adds	r1, r3, r5
   24f84:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
   24f88:	e00a      	b.n	24fa0 <dynalloc_analysis.isra.5+0xdec>
            boost_bits = boost*width<<BITRES;
   24f8a:	00ed      	lsls	r5, r5, #3
      for (i=start;i<end;i++)
   24f8c:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
            offsets[i] = boost;
   24f90:	f842 6f04 	str.w	r6, [r2, #4]!
      for (i=start;i<end;i++)
   24f94:	f108 0801 	add.w	r8, r8, #1
   24f98:	4540      	cmp	r0, r8
   24f9a:	442b      	add	r3, r5
   24f9c:	f77f ac81 	ble.w	248a2 <dynalloc_analysis.isra.5+0x6ee>
   24fa0:	460c      	mov	r4, r1
         width = C*(eBands[i+1]-eBands[i])<<LM;
   24fa2:	f9b1 0002 	ldrsh.w	r0, [r1, #2]
   24fa6:	f9b4 5000 	ldrsh.w	r5, [r4]
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   24faa:	f93c 4f02 	ldrsh.w	r4, [ip, #2]!
         width = C*(eBands[i+1]-eBands[i])<<LM;
   24fae:	1b40      	subs	r0, r0, r5
   24fb0:	f8d7 5094 	ldr.w	r5, [r7, #148]	; 0x94
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   24fb4:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
         width = C*(eBands[i+1]-eBands[i])<<LM;
   24fb8:	fb05 f000 	mul.w	r0, r5, r0
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   24fbc:	bfa8      	it	ge
   24fbe:	f44f 5480 	movge.w	r4, #4096	; 0x1000
         width = C*(eBands[i+1]-eBands[i])<<LM;
   24fc2:	fa00 f00a 	lsl.w	r0, r0, sl
            boost = (int)SHR32(EXTEND32(follower[i]),DB_SHIFT);
   24fc6:	12a6      	asrs	r6, r4, #10
         if (width<6)
   24fc8:	2805      	cmp	r0, #5
         width = C*(eBands[i+1]-eBands[i])<<LM;
   24fca:	f101 0102 	add.w	r1, r1, #2
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   24fce:	f8ac 4000 	strh.w	r4, [ip]
            boost_bits = boost*width<<BITRES;
   24fd2:	fb00 f506 	mul.w	r5, r0, r6
         if (width<6)
   24fd6:	ddd8      	ble.n	24f8a <dynalloc_analysis.isra.5+0xdd6>
            boost = (int)SHR32(EXTEND32(follower[i])*8,DB_SHIFT);
   24fd8:	11e6      	asrs	r6, r4, #7
            boost_bits = (boost*width<<BITRES)/8;
   24fda:	fb00 f506 	mul.w	r5, r0, r6
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   24fde:	fb00 f404 	mul.w	r4, r0, r4
            boost_bits = (boost*width<<BITRES)/8;
   24fe2:	667d      	str	r5, [r7, #100]	; 0x64
         } else if (width > 48) {
   24fe4:	2830      	cmp	r0, #48	; 0x30
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   24fe6:	fb8e 5904 	smull	r5, r9, lr, r4
   24fea:	eba9 74e4 	sub.w	r4, r9, r4, asr #31
         } else if (width > 48) {
   24fee:	dd6a      	ble.n	250c6 <dynalloc_analysis.isra.5+0xf12>
            boost_bits = (boost*width<<BITRES)/8;
   24ff0:	6e78      	ldr	r0, [r7, #100]	; 0x64
   24ff2:	00c5      	lsls	r5, r0, #3
   24ff4:	bf48      	it	mi
   24ff6:	3507      	addmi	r5, #7
   24ff8:	10ed      	asrs	r5, r5, #3
   24ffa:	e7c7      	b.n	24f8c <dynalloc_analysis.isra.5+0xdd8>
   24ffc:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   25000:	2b00      	cmp	r3, #0
   25002:	f000 80cc 	beq.w	2519e <dynalloc_analysis.isra.5+0xfea>
   25006:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
   25008:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   2500c:	f8df e3b8 	ldr.w	lr, [pc, #952]	; 253c8 <dynalloc_analysis.isra.5+0x1214>
               && (tot_boost+boost_bits)>>BITRES>>3 > 2*effectiveBytes/3)
   25010:	f8d7 a0b4 	ldr.w	sl, [r7, #180]	; 0xb4
   25014:	f100 4280 	add.w	r2, r0, #1073741824	; 0x40000000
   25018:	3a01      	subs	r2, #1
   2501a:	eb03 0282 	add.w	r2, r3, r2, lsl #2
   2501e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   25020:	f1a5 0c02 	sub.w	ip, r5, #2
   25024:	4463      	add	r3, ip
   25026:	469c      	mov	ip, r3
   25028:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
   2502c:	4680      	mov	r8, r0
   2502e:	1959      	adds	r1, r3, r5
   25030:	2300      	movs	r3, #0
   25032:	e00a      	b.n	2504a <dynalloc_analysis.isra.5+0xe96>
            boost_bits = boost*width<<BITRES;
   25034:	00ed      	lsls	r5, r5, #3
      for (i=start;i<end;i++)
   25036:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
            offsets[i] = boost;
   2503a:	f842 6f04 	str.w	r6, [r2, #4]!
      for (i=start;i<end;i++)
   2503e:	f108 0801 	add.w	r8, r8, #1
   25042:	4540      	cmp	r0, r8
   25044:	442b      	add	r3, r5
   25046:	f77f ac2c 	ble.w	248a2 <dynalloc_analysis.isra.5+0x6ee>
   2504a:	460c      	mov	r4, r1
         width = C*(eBands[i+1]-eBands[i])<<LM;
   2504c:	f9b1 0002 	ldrsh.w	r0, [r1, #2]
   25050:	f9b4 5000 	ldrsh.w	r5, [r4]
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   25054:	f93c 4f02 	ldrsh.w	r4, [ip, #2]!
         width = C*(eBands[i+1]-eBands[i])<<LM;
   25058:	1b40      	subs	r0, r0, r5
   2505a:	f8d7 5094 	ldr.w	r5, [r7, #148]	; 0x94
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   2505e:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
         width = C*(eBands[i+1]-eBands[i])<<LM;
   25062:	fb05 f000 	mul.w	r0, r5, r0
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   25066:	bfa8      	it	ge
   25068:	f44f 5480 	movge.w	r4, #4096	; 0x1000
         width = C*(eBands[i+1]-eBands[i])<<LM;
   2506c:	fa00 f00a 	lsl.w	r0, r0, sl
            boost = (int)SHR32(EXTEND32(follower[i]),DB_SHIFT);
   25070:	12a6      	asrs	r6, r4, #10
         if (width<6)
   25072:	2805      	cmp	r0, #5
         width = C*(eBands[i+1]-eBands[i])<<LM;
   25074:	f101 0102 	add.w	r1, r1, #2
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   25078:	f8ac 4000 	strh.w	r4, [ip]
            boost_bits = boost*width<<BITRES;
   2507c:	fb00 f506 	mul.w	r5, r0, r6
         if (width<6)
   25080:	ddd8      	ble.n	25034 <dynalloc_analysis.isra.5+0xe80>
            boost = (int)SHR32(EXTEND32(follower[i])*8,DB_SHIFT);
   25082:	11e6      	asrs	r6, r4, #7
            boost_bits = (boost*width<<BITRES)/8;
   25084:	fb00 f506 	mul.w	r5, r0, r6
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   25088:	fb00 f404 	mul.w	r4, r0, r4
            boost_bits = (boost*width<<BITRES)/8;
   2508c:	667d      	str	r5, [r7, #100]	; 0x64
         } else if (width > 48) {
   2508e:	2830      	cmp	r0, #48	; 0x30
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   25090:	fb8e 5904 	smull	r5, r9, lr, r4
   25094:	eba9 74e4 	sub.w	r4, r9, r4, asr #31
         } else if (width > 48) {
   25098:	dd1a      	ble.n	250d0 <dynalloc_analysis.isra.5+0xf1c>
            boost_bits = (boost*width<<BITRES)/8;
   2509a:	6e78      	ldr	r0, [r7, #100]	; 0x64
   2509c:	00c5      	lsls	r5, r0, #3
   2509e:	bf48      	it	mi
   250a0:	3507      	addmi	r5, #7
   250a2:	10ed      	asrs	r5, r5, #3
   250a4:	e7c7      	b.n	25036 <dynalloc_analysis.isra.5+0xe82>
   250a6:	64fd      	str	r5, [r7, #76]	; 0x4c
            opus_int32 cap = ((2*effectiveBytes/3)<<BITRES<<3);
   250a8:	0183      	lsls	r3, r0, #6
            offsets[i] = cap-tot_boost;
   250aa:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
   250ae:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
   250b0:	1a59      	subs	r1, r3, r1
   250b2:	f842 1020 	str.w	r1, [r2, r0, lsl #2]
   250b6:	f7ff bbf4 	b.w	248a2 <dynalloc_analysis.isra.5+0x6ee>
            boost_bits = (boost*width<<BITRES)/8;
   250ba:	ea5f 03ca 	movs.w	r3, sl, lsl #3
   250be:	bf48      	it	mi
   250c0:	3307      	addmi	r3, #7
   250c2:	10db      	asrs	r3, r3, #3
   250c4:	e6ce      	b.n	24e64 <dynalloc_analysis.isra.5+0xcb0>
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   250c6:	12a6      	asrs	r6, r4, #10
            boost_bits = boost*6<<BITRES;
   250c8:	eb06 0546 	add.w	r5, r6, r6, lsl #1
   250cc:	012d      	lsls	r5, r5, #4
   250ce:	e75d      	b.n	24f8c <dynalloc_analysis.isra.5+0xdd8>
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   250d0:	12a6      	asrs	r6, r4, #10
            boost_bits = boost*6<<BITRES;
   250d2:	eb06 0546 	add.w	r5, r6, r6, lsl #1
   250d6:	012d      	lsls	r5, r5, #4
   250d8:	e7ad      	b.n	25036 <dynalloc_analysis.isra.5+0xe82>
            boost_bits = (boost*width<<BITRES)/8;
   250da:	ea5f 01ca 	movs.w	r1, sl, lsl #3
   250de:	bf48      	it	mi
   250e0:	3107      	addmi	r1, #7
   250e2:	10c9      	asrs	r1, r1, #3
   250e4:	e5d7      	b.n	24c96 <dynalloc_analysis.isra.5+0xae2>
   250e6:	4619      	mov	r1, r3
   250e8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   250ea:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   250ee:	f8df 92d8 	ldr.w	r9, [pc, #728]	; 253c8 <dynalloc_analysis.isra.5+0x1214>
   250f2:	f103 4c80 	add.w	ip, r3, #1073741824	; 0x40000000
   250f6:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
   250fa:	eb02 0c8c 	add.w	ip, r2, ip, lsl #2
   250fe:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
   25100:	1eae      	subs	r6, r5, #2
   25102:	4432      	add	r2, r6
   25104:	4616      	mov	r6, r2
   25106:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
   2510a:	442a      	add	r2, r5
               && (tot_boost+boost_bits)>>BITRES>>3 > 2*effectiveBytes/3)
   2510c:	4696      	mov	lr, r2
   2510e:	4698      	mov	r8, r3
   25110:	e00e      	b.n	25130 <dynalloc_analysis.isra.5+0xf7c>
            boost_bits = boost*width<<BITRES;
   25112:	00e3      	lsls	r3, r4, #3
   25114:	440b      	add	r3, r1
               && (tot_boost+boost_bits)>>BITRES>>3 > 2*effectiveBytes/3)
   25116:	ebb0 1fa3 	cmp.w	r0, r3, asr #6
   2511a:	db3d      	blt.n	25198 <dynalloc_analysis.isra.5+0xfe4>
            offsets[i] = boost;
   2511c:	f84c 2f04 	str.w	r2, [ip, #4]!
      for (i=start;i<end;i++)
   25120:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
   25124:	f108 0801 	add.w	r8, r8, #1
   25128:	4542      	cmp	r2, r8
   2512a:	4619      	mov	r1, r3
   2512c:	f77f abb9 	ble.w	248a2 <dynalloc_analysis.isra.5+0x6ee>
   25130:	4672      	mov	r2, lr
         width = C*(eBands[i+1]-eBands[i])<<LM;
   25132:	f9be 3002 	ldrsh.w	r3, [lr, #2]
   25136:	f9b2 2000 	ldrsh.w	r2, [r2]
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   2513a:	f936 5f02 	ldrsh.w	r5, [r6, #2]!
         width = C*(eBands[i+1]-eBands[i])<<LM;
   2513e:	1a9b      	subs	r3, r3, r2
   25140:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
   25144:	fb02 f303 	mul.w	r3, r2, r3
   25148:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   2514c:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
         width = C*(eBands[i+1]-eBands[i])<<LM;
   25150:	fa03 f302 	lsl.w	r3, r3, r2
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   25154:	bfa8      	it	ge
   25156:	f44f 5580 	movge.w	r5, #4096	; 0x1000
            boost = (int)SHR32(EXTEND32(follower[i]),DB_SHIFT);
   2515a:	12aa      	asrs	r2, r5, #10
         if (width<6)
   2515c:	2b05      	cmp	r3, #5
         width = C*(eBands[i+1]-eBands[i])<<LM;
   2515e:	f10e 0e02 	add.w	lr, lr, #2
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   25162:	8035      	strh	r5, [r6, #0]
            boost_bits = boost*width<<BITRES;
   25164:	fb03 f402 	mul.w	r4, r3, r2
         if (width<6)
   25168:	ddd3      	ble.n	25112 <dynalloc_analysis.isra.5+0xf5e>
            boost = (int)SHR32(EXTEND32(follower[i])*8,DB_SHIFT);
   2516a:	11ea      	asrs	r2, r5, #7
            boost_bits = (boost*width<<BITRES)/8;
   2516c:	fb03 f402 	mul.w	r4, r3, r2
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   25170:	fb03 f505 	mul.w	r5, r3, r5
            boost_bits = (boost*width<<BITRES)/8;
   25174:	667c      	str	r4, [r7, #100]	; 0x64
         } else if (width > 48) {
   25176:	2b30      	cmp	r3, #48	; 0x30
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   25178:	fb89 4a05 	smull	r4, sl, r9, r5
   2517c:	ebaa 75e5 	sub.w	r5, sl, r5, asr #31
         } else if (width > 48) {
   25180:	dd05      	ble.n	2518e <dynalloc_analysis.isra.5+0xfda>
            boost_bits = (boost*width<<BITRES)/8;
   25182:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   25184:	00db      	lsls	r3, r3, #3
   25186:	bf48      	it	mi
   25188:	3307      	addmi	r3, #7
   2518a:	10db      	asrs	r3, r3, #3
   2518c:	e7c2      	b.n	25114 <dynalloc_analysis.isra.5+0xf60>
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   2518e:	12aa      	asrs	r2, r5, #10
            boost_bits = boost*6<<BITRES;
   25190:	eb02 0342 	add.w	r3, r2, r2, lsl #1
   25194:	011b      	lsls	r3, r3, #4
   25196:	e7bd      	b.n	25114 <dynalloc_analysis.isra.5+0xf60>
   25198:	f8c7 804c 	str.w	r8, [r7, #76]	; 0x4c
   2519c:	e784      	b.n	250a8 <dynalloc_analysis.isra.5+0xef4>
   2519e:	4619      	mov	r1, r3
   251a0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   251a2:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   251a6:	f8df e220 	ldr.w	lr, [pc, #544]	; 253c8 <dynalloc_analysis.isra.5+0x1214>
               && (tot_boost+boost_bits)>>BITRES>>3 > 2*effectiveBytes/3)
   251aa:	6678      	str	r0, [r7, #100]	; 0x64
   251ac:	f103 4c80 	add.w	ip, r3, #1073741824	; 0x40000000
   251b0:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
   251b4:	eb02 0c8c 	add.w	ip, r2, ip, lsl #2
   251b8:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
   251ba:	f8d7 90b4 	ldr.w	r9, [r7, #180]	; 0xb4
   251be:	1eae      	subs	r6, r5, #2
   251c0:	4432      	add	r2, r6
   251c2:	4616      	mov	r6, r2
   251c4:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
   251c8:	442a      	add	r2, r5
   251ca:	461d      	mov	r5, r3
   251cc:	e01e      	b.n	2520c <dynalloc_analysis.isra.5+0x1058>
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   251ce:	fb03 fa04 	mul.w	sl, r3, r4
   251d2:	fb8e 080a 	smull	r0, r8, lr, sl
            boost = (int)SHR32(EXTEND32(follower[i])*8,DB_SHIFT);
   251d6:	11e4      	asrs	r4, r4, #7
         } else if (width > 48) {
   251d8:	2b30      	cmp	r3, #48	; 0x30
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   251da:	eba8 78ea 	sub.w	r8, r8, sl, asr #31
            boost_bits = (boost*width<<BITRES)/8;
   251de:	fb03 fa04 	mul.w	sl, r3, r4
         } else if (width > 48) {
   251e2:	dc31      	bgt.n	25248 <dynalloc_analysis.isra.5+0x1094>
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   251e4:	ea4f 24a8 	mov.w	r4, r8, asr #10
            boost_bits = boost*6<<BITRES;
   251e8:	eb04 0344 	add.w	r3, r4, r4, lsl #1
   251ec:	011b      	lsls	r3, r3, #4
               && (tot_boost+boost_bits)>>BITRES>>3 > 2*effectiveBytes/3)
   251ee:	6e78      	ldr	r0, [r7, #100]	; 0x64
   251f0:	440b      	add	r3, r1
   251f2:	ebb0 1fa3 	cmp.w	r0, r3, asr #6
   251f6:	f6ff af56 	blt.w	250a6 <dynalloc_analysis.isra.5+0xef2>
      for (i=start;i<end;i++)
   251fa:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
            offsets[i] = boost;
   251fe:	f84c 4f04 	str.w	r4, [ip, #4]!
      for (i=start;i<end;i++)
   25202:	3501      	adds	r5, #1
   25204:	42a8      	cmp	r0, r5
   25206:	4619      	mov	r1, r3
   25208:	f77f ab4b 	ble.w	248a2 <dynalloc_analysis.isra.5+0x6ee>
   2520c:	4614      	mov	r4, r2
         width = C*(eBands[i+1]-eBands[i])<<LM;
   2520e:	f9b2 3002 	ldrsh.w	r3, [r2, #2]
   25212:	f9b4 8000 	ldrsh.w	r8, [r4]
   25216:	f8d7 0094 	ldr.w	r0, [r7, #148]	; 0x94
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   2521a:	f936 4f02 	ldrsh.w	r4, [r6, #2]!
         width = C*(eBands[i+1]-eBands[i])<<LM;
   2521e:	eba3 0308 	sub.w	r3, r3, r8
   25222:	fb00 f303 	mul.w	r3, r0, r3
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   25226:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
         width = C*(eBands[i+1]-eBands[i])<<LM;
   2522a:	fa03 f309 	lsl.w	r3, r3, r9
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   2522e:	bfa8      	it	ge
   25230:	f44f 5480 	movge.w	r4, #4096	; 0x1000
         if (width<6)
   25234:	2b05      	cmp	r3, #5
         width = C*(eBands[i+1]-eBands[i])<<LM;
   25236:	f102 0202 	add.w	r2, r2, #2
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   2523a:	8034      	strh	r4, [r6, #0]
         if (width<6)
   2523c:	dcc7      	bgt.n	251ce <dynalloc_analysis.isra.5+0x101a>
            boost = (int)SHR32(EXTEND32(follower[i]),DB_SHIFT);
   2523e:	12a4      	asrs	r4, r4, #10
            boost_bits = boost*width<<BITRES;
   25240:	fb03 f304 	mul.w	r3, r3, r4
   25244:	00db      	lsls	r3, r3, #3
   25246:	e7d2      	b.n	251ee <dynalloc_analysis.isra.5+0x103a>
            boost_bits = (boost*width<<BITRES)/8;
   25248:	ea5f 03ca 	movs.w	r3, sl, lsl #3
   2524c:	bf48      	it	mi
   2524e:	3307      	addmi	r3, #7
   25250:	10db      	asrs	r3, r3, #3
   25252:	e7cc      	b.n	251ee <dynalloc_analysis.isra.5+0x103a>
   25254:	4619      	mov	r1, r3
   25256:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   25258:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   2525c:	f8df e168 	ldr.w	lr, [pc, #360]	; 253c8 <dynalloc_analysis.isra.5+0x1214>
               && (tot_boost+boost_bits)>>BITRES>>3 > 2*effectiveBytes/3)
   25260:	6678      	str	r0, [r7, #100]	; 0x64
   25262:	f103 4c80 	add.w	ip, r3, #1073741824	; 0x40000000
   25266:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
   2526a:	eb02 0c8c 	add.w	ip, r2, ip, lsl #2
   2526e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
   25270:	f8d7 90b4 	ldr.w	r9, [r7, #180]	; 0xb4
   25274:	1eae      	subs	r6, r5, #2
   25276:	4432      	add	r2, r6
   25278:	4616      	mov	r6, r2
   2527a:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
   2527e:	442a      	add	r2, r5
   25280:	461d      	mov	r5, r3
   25282:	e01e      	b.n	252c2 <dynalloc_analysis.isra.5+0x110e>
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   25284:	fb03 fa04 	mul.w	sl, r3, r4
   25288:	fb8e 080a 	smull	r0, r8, lr, sl
            boost = (int)SHR32(EXTEND32(follower[i])*8,DB_SHIFT);
   2528c:	11e4      	asrs	r4, r4, #7
         } else if (width > 48) {
   2528e:	2b30      	cmp	r3, #48	; 0x30
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   25290:	eba8 78ea 	sub.w	r8, r8, sl, asr #31
            boost_bits = (boost*width<<BITRES)/8;
   25294:	fb03 fa04 	mul.w	sl, r3, r4
         } else if (width > 48) {
   25298:	dc31      	bgt.n	252fe <dynalloc_analysis.isra.5+0x114a>
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   2529a:	ea4f 24a8 	mov.w	r4, r8, asr #10
            boost_bits = boost*6<<BITRES;
   2529e:	eb04 0344 	add.w	r3, r4, r4, lsl #1
   252a2:	011b      	lsls	r3, r3, #4
               && (tot_boost+boost_bits)>>BITRES>>3 > 2*effectiveBytes/3)
   252a4:	6e78      	ldr	r0, [r7, #100]	; 0x64
   252a6:	440b      	add	r3, r1
   252a8:	ebb0 1fa3 	cmp.w	r0, r3, asr #6
   252ac:	f6ff aefb 	blt.w	250a6 <dynalloc_analysis.isra.5+0xef2>
      for (i=start;i<end;i++)
   252b0:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
            offsets[i] = boost;
   252b4:	f84c 4f04 	str.w	r4, [ip, #4]!
      for (i=start;i<end;i++)
   252b8:	3501      	adds	r5, #1
   252ba:	42a8      	cmp	r0, r5
   252bc:	4619      	mov	r1, r3
   252be:	f77f aaf0 	ble.w	248a2 <dynalloc_analysis.isra.5+0x6ee>
   252c2:	4614      	mov	r4, r2
         width = C*(eBands[i+1]-eBands[i])<<LM;
   252c4:	f9b2 3002 	ldrsh.w	r3, [r2, #2]
   252c8:	f9b4 8000 	ldrsh.w	r8, [r4]
   252cc:	f8d7 0094 	ldr.w	r0, [r7, #148]	; 0x94
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   252d0:	f936 4f02 	ldrsh.w	r4, [r6, #2]!
         width = C*(eBands[i+1]-eBands[i])<<LM;
   252d4:	eba3 0308 	sub.w	r3, r3, r8
   252d8:	fb00 f303 	mul.w	r3, r0, r3
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   252dc:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
         width = C*(eBands[i+1]-eBands[i])<<LM;
   252e0:	fa03 f309 	lsl.w	r3, r3, r9
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   252e4:	bfa8      	it	ge
   252e6:	f44f 5480 	movge.w	r4, #4096	; 0x1000
         if (width<6)
   252ea:	2b05      	cmp	r3, #5
         width = C*(eBands[i+1]-eBands[i])<<LM;
   252ec:	f102 0202 	add.w	r2, r2, #2
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   252f0:	8034      	strh	r4, [r6, #0]
         if (width<6)
   252f2:	dcc7      	bgt.n	25284 <dynalloc_analysis.isra.5+0x10d0>
            boost = (int)SHR32(EXTEND32(follower[i]),DB_SHIFT);
   252f4:	12a4      	asrs	r4, r4, #10
            boost_bits = boost*width<<BITRES;
   252f6:	fb03 f304 	mul.w	r3, r3, r4
   252fa:	00db      	lsls	r3, r3, #3
   252fc:	e7d2      	b.n	252a4 <dynalloc_analysis.isra.5+0x10f0>
            boost_bits = (boost*width<<BITRES)/8;
   252fe:	ea5f 03ca 	movs.w	r3, sl, lsl #3
   25302:	bf48      	it	mi
   25304:	3307      	addmi	r3, #7
   25306:	10db      	asrs	r3, r3, #3
   25308:	e7cc      	b.n	252a4 <dynalloc_analysis.isra.5+0x10f0>
   2530a:	4619      	mov	r1, r3
   2530c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   2530e:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   25312:	f8df 90b4 	ldr.w	r9, [pc, #180]	; 253c8 <dynalloc_analysis.isra.5+0x1214>
   25316:	f103 4c80 	add.w	ip, r3, #1073741824	; 0x40000000
   2531a:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
   2531e:	eb02 0c8c 	add.w	ip, r2, ip, lsl #2
   25322:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
   25324:	1eae      	subs	r6, r5, #2
   25326:	4432      	add	r2, r6
   25328:	4616      	mov	r6, r2
   2532a:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
   2532e:	442a      	add	r2, r5
               && (tot_boost+boost_bits)>>BITRES>>3 > 2*effectiveBytes/3)
   25330:	4696      	mov	lr, r2
   25332:	4698      	mov	r8, r3
   25334:	e00f      	b.n	25356 <dynalloc_analysis.isra.5+0x11a2>
            boost_bits = boost*width<<BITRES;
   25336:	00e3      	lsls	r3, r4, #3
   25338:	440b      	add	r3, r1
               && (tot_boost+boost_bits)>>BITRES>>3 > 2*effectiveBytes/3)
   2533a:	ebb0 1fa3 	cmp.w	r0, r3, asr #6
   2533e:	f6ff af2b 	blt.w	25198 <dynalloc_analysis.isra.5+0xfe4>
            offsets[i] = boost;
   25342:	f84c 2f04 	str.w	r2, [ip, #4]!
      for (i=start;i<end;i++)
   25346:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
   2534a:	f108 0801 	add.w	r8, r8, #1
   2534e:	4542      	cmp	r2, r8
   25350:	4619      	mov	r1, r3
   25352:	f77f aaa6 	ble.w	248a2 <dynalloc_analysis.isra.5+0x6ee>
   25356:	4672      	mov	r2, lr
         width = C*(eBands[i+1]-eBands[i])<<LM;
   25358:	f9be 3002 	ldrsh.w	r3, [lr, #2]
   2535c:	f9b2 2000 	ldrsh.w	r2, [r2]
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   25360:	f936 5f02 	ldrsh.w	r5, [r6, #2]!
         width = C*(eBands[i+1]-eBands[i])<<LM;
   25364:	1a9b      	subs	r3, r3, r2
   25366:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
   2536a:	fb02 f303 	mul.w	r3, r2, r3
   2536e:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   25372:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
         width = C*(eBands[i+1]-eBands[i])<<LM;
   25376:	fa03 f302 	lsl.w	r3, r3, r2
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   2537a:	bfa8      	it	ge
   2537c:	f44f 5580 	movge.w	r5, #4096	; 0x1000
            boost = (int)SHR32(EXTEND32(follower[i]),DB_SHIFT);
   25380:	12aa      	asrs	r2, r5, #10
         if (width<6)
   25382:	2b05      	cmp	r3, #5
         width = C*(eBands[i+1]-eBands[i])<<LM;
   25384:	f10e 0e02 	add.w	lr, lr, #2
         follower[i] = MIN16(follower[i], QCONST16(4, DB_SHIFT));
   25388:	8035      	strh	r5, [r6, #0]
            boost_bits = boost*width<<BITRES;
   2538a:	fb02 f403 	mul.w	r4, r2, r3
         if (width<6)
   2538e:	ddd2      	ble.n	25336 <dynalloc_analysis.isra.5+0x1182>
            boost = (int)SHR32(EXTEND32(follower[i])*8,DB_SHIFT);
   25390:	11ea      	asrs	r2, r5, #7
            boost_bits = (boost*width<<BITRES)/8;
   25392:	fb02 f403 	mul.w	r4, r2, r3
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   25396:	fb05 f503 	mul.w	r5, r5, r3
            boost_bits = (boost*width<<BITRES)/8;
   2539a:	667c      	str	r4, [r7, #100]	; 0x64
         } else if (width > 48) {
   2539c:	2b30      	cmp	r3, #48	; 0x30
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   2539e:	fb89 4a05 	smull	r4, sl, r9, r5
   253a2:	ebaa 75e5 	sub.w	r5, sl, r5, asr #31
         } else if (width > 48) {
   253a6:	dd05      	ble.n	253b4 <dynalloc_analysis.isra.5+0x1200>
            boost_bits = (boost*width<<BITRES)/8;
   253a8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   253aa:	00db      	lsls	r3, r3, #3
   253ac:	bf48      	it	mi
   253ae:	3307      	addmi	r3, #7
   253b0:	10db      	asrs	r3, r3, #3
   253b2:	e7c1      	b.n	25338 <dynalloc_analysis.isra.5+0x1184>
            boost = (int)SHR32(EXTEND32(follower[i])*width/6,DB_SHIFT);
   253b4:	12aa      	asrs	r2, r5, #10
            boost_bits = boost*6<<BITRES;
   253b6:	eb02 0342 	add.w	r3, r2, r2, lsl #1
   253ba:	011b      	lsls	r3, r3, #4
   253bc:	e7bc      	b.n	25338 <dynalloc_analysis.isra.5+0x1184>
   253be:	f8d7 b064 	ldr.w	fp, [r7, #100]	; 0x64
   253c2:	f7ff ba6e 	b.w	248a2 <dynalloc_analysis.isra.5+0x6ee>
   253c6:	bf00      	nop
   253c8:	2aaaaaab 	.word	0x2aaaaaab

000253cc <celt_encoder_get_size>:
{
   253cc:	b510      	push	{r4, lr}
   CELTMode *mode = opus_custom_mode_create(48000, 960, NULL);
   253ce:	2200      	movs	r2, #0
{
   253d0:	4604      	mov	r4, r0
   CELTMode *mode = opus_custom_mode_create(48000, 960, NULL);
   253d2:	f44f 7170 	mov.w	r1, #960	; 0x3c0
   253d6:	f64b 3080 	movw	r0, #48000	; 0xbb80
   253da:	f006 fb65 	bl	2baa8 <opus_custom_mode_create>
         + 4*channels*mode->nbEBands*sizeof(opus_val16);  /* opus_val16 oldBandE[channels*mode->nbEBands]; */
   253de:	e9d0 1001 	ldrd	r1, r0, [r0, #4]
         + channels*COMBFILTER_MAXPERIOD*sizeof(celt_sig) /* celt_sig prefilter_mem[channels*COMBFILTER_MAXPERIOD]; */
   253e2:	02a3      	lsls	r3, r4, #10
         + 4*channels*mode->nbEBands*sizeof(opus_val16);  /* opus_val16 oldBandE[channels*mode->nbEBands]; */
   253e4:	00a2      	lsls	r2, r4, #2
   253e6:	333d      	adds	r3, #61	; 0x3d
   253e8:	fb01 3404 	mla	r4, r1, r4, r3
   253ec:	fb00 f002 	mul.w	r0, r0, r2
   253f0:	eb00 0044 	add.w	r0, r0, r4, lsl #1
}
   253f4:	0040      	lsls	r0, r0, #1
   253f6:	bd10      	pop	{r4, pc}

000253f8 <celt_preemphasis>:
{
   253f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   253fc:	b083      	sub	sp, #12
   253fe:	e9dd 470d 	ldrd	r4, r7, [sp, #52]	; 0x34
   if (coef[1] == 0 && upsample == 1 && !clip)
   25402:	f9b4 c002 	ldrsh.w	ip, [r4, #2]
   coef0 = coef[0];
   25406:	f9b4 6000 	ldrsh.w	r6, [r4]
   m = *mem;
   2540a:	683d      	ldr	r5, [r7, #0]
{
   2540c:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
   25410:	4683      	mov	fp, r0
   25412:	460c      	mov	r4, r1
   25414:	4690      	mov	r8, r2
   if (coef[1] == 0 && upsample == 1 && !clip)
   25416:	f1bc 0f00 	cmp.w	ip, #0
   2541a:	d134      	bne.n	25486 <celt_preemphasis+0x8e>
   2541c:	f1ba 0f01 	cmp.w	sl, #1
   25420:	d037      	beq.n	25492 <celt_preemphasis+0x9a>
   Nu = N/upsample;
   25422:	fb92 f9fa 	sdiv	r9, r2, sl
      OPUS_CLEAR(inp, N);
   25426:	ea4f 0288 	mov.w	r2, r8, lsl #2
   2542a:	2100      	movs	r1, #0
   2542c:	4620      	mov	r0, r4
   2542e:	9301      	str	r3, [sp, #4]
   25430:	f00f fe98 	bl	35164 <memset>
   25434:	9b01      	ldr	r3, [sp, #4]
   for (i=0;i<Nu;i++)
   25436:	f1b9 0f00 	cmp.w	r9, #0
   2543a:	dd0e      	ble.n	2545a <celt_preemphasis+0x62>
   2543c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   25440:	4658      	mov	r0, fp
   25442:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
   25446:	4621      	mov	r1, r4
   25448:	2200      	movs	r2, #0
   2544a:	3201      	adds	r2, #1
      inp[i*upsample] = SCALEIN(pcmp[CC*i]);
   2544c:	f9b0 3000 	ldrsh.w	r3, [r0]
   25450:	600b      	str	r3, [r1, #0]
   for (i=0;i<Nu;i++)
   25452:	454a      	cmp	r2, r9
   25454:	4460      	add	r0, ip
   25456:	4451      	add	r1, sl
   25458:	d1f7      	bne.n	2544a <celt_preemphasis+0x52>
      for (i=0;i<N;i++)
   2545a:	f1b8 0f00 	cmp.w	r8, #0
   2545e:	dd0e      	ble.n	2547e <celt_preemphasis+0x86>
   25460:	1f21      	subs	r1, r4, #4
   25462:	eb01 0888 	add.w	r8, r1, r8, lsl #2
         x = inp[i];
   25466:	f851 3f04 	ldr.w	r3, [r1, #4]!
   2546a:	b21b      	sxth	r3, r3
         inp[i] = SHL32(x, SIG_SHIFT) - m;
   2546c:	ebc5 3503 	rsb	r5, r5, r3, lsl #12
      for (i=0;i<N;i++)
   25470:	4588      	cmp	r8, r1
         m = SHR32(MULT16_16(coef0, x), 15-SIG_SHIFT);
   25472:	fb03 f306 	mul.w	r3, r3, r6
         inp[i] = SHL32(x, SIG_SHIFT) - m;
   25476:	600d      	str	r5, [r1, #0]
         m = SHR32(MULT16_16(coef0, x), 15-SIG_SHIFT);
   25478:	ea4f 05e3 	mov.w	r5, r3, asr #3
      for (i=0;i<N;i++)
   2547c:	d1f3      	bne.n	25466 <celt_preemphasis+0x6e>
   *mem = m;
   2547e:	603d      	str	r5, [r7, #0]
}
   25480:	b003      	add	sp, #12
   25482:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   if (upsample!=1)
   25486:	f1ba 0f01 	cmp.w	sl, #1
   Nu = N/upsample;
   2548a:	fb92 f9fa 	sdiv	r9, r2, sl
   if (upsample!=1)
   2548e:	d0d2      	beq.n	25436 <celt_preemphasis+0x3e>
   25490:	e7c9      	b.n	25426 <celt_preemphasis+0x2e>
   if (coef[1] == 0 && upsample == 1 && !clip)
   25492:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   25494:	b9aa      	cbnz	r2, 254c2 <celt_preemphasis+0xca>
      for (i=0;i<N;i++)
   25496:	f1b8 0f00 	cmp.w	r8, #0
   2549a:	ddf0      	ble.n	2547e <celt_preemphasis+0x86>
   2549c:	3904      	subs	r1, #4
   2549e:	eb01 0888 	add.w	r8, r1, r8, lsl #2
   254a2:	ea4f 0c43 	mov.w	ip, r3, lsl #1
         x = SCALEIN(pcmp[CC*i]);
   254a6:	f9b0 2000 	ldrsh.w	r2, [r0]
         inp[i] = SHL32(x, SIG_SHIFT) - m;
   254aa:	ebc5 3502 	rsb	r5, r5, r2, lsl #12
   254ae:	f841 5f04 	str.w	r5, [r1, #4]!
         m = SHR32(MULT16_16(coef0, x), 15-SIG_SHIFT);
   254b2:	fb02 f306 	mul.w	r3, r2, r6
      for (i=0;i<N;i++)
   254b6:	4588      	cmp	r8, r1
         m = SHR32(MULT16_16(coef0, x), 15-SIG_SHIFT);
   254b8:	ea4f 05e3 	mov.w	r5, r3, asr #3
   254bc:	4460      	add	r0, ip
      for (i=0;i<N;i++)
   254be:	d1f2      	bne.n	254a6 <celt_preemphasis+0xae>
   254c0:	e7dd      	b.n	2547e <celt_preemphasis+0x86>
   254c2:	46c1      	mov	r9, r8
   254c4:	e7b7      	b.n	25436 <celt_preemphasis+0x3e>
   254c6:	bf00      	nop

000254c8 <celt_encode_with_ec>:

   return target;
}

int celt_encode_with_ec(CELTEncoder * OPUS_RESTRICT st, const opus_val16 * pcm, int frame_size, unsigned char *compressed, int nbCompressedBytes, ec_enc *enc)
{
   254c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   254cc:	b0fd      	sub	sp, #500	; 0x1f4
   int weak_transient = 0;
   int enable_tf_analysis;
   VARDECL(opus_val16, surround_dynalloc);
   ALLOC_STACK;

   mode = st->mode;
   254ce:	6804      	ldr	r4, [r0, #0]
   const int CC = st->channels;
   254d0:	6845      	ldr	r5, [r0, #4]
   nbEBands = mode->nbEBands;
   overlap = mode->overlap;
   254d2:	f8d4 9004 	ldr.w	r9, [r4, #4]
{
   254d6:	af14      	add	r7, sp, #80	; 0x50
   const int CC = st->channels;
   254d8:	f8c7 5108 	str.w	r5, [r7, #264]	; 0x108
   nbEBands = mode->nbEBands;
   254dc:	68a5      	ldr	r5, [r4, #8]
   254de:	f8c7 511c 	str.w	r5, [r7, #284]	; 0x11c
   eBands = mode->eBands;
   254e2:	69a5      	ldr	r5, [r4, #24]
   254e4:	f8c7 50c8 	str.w	r5, [r7, #200]	; 0xc8
   const int C = st->stream_channels;
   254e8:	6885      	ldr	r5, [r0, #8]
{
   254ea:	f8d7 e1c8 	ldr.w	lr, [r7, #456]	; 0x1c8
   const int C = st->stream_channels;
   254ee:	f8c7 5114 	str.w	r5, [r7, #276]	; 0x114
   start = st->start;
   254f2:	6a05      	ldr	r5, [r0, #32]
   254f4:	f8c7 5120 	str.w	r5, [r7, #288]	; 0x120
   end = st->end;
   254f8:	6a45      	ldr	r5, [r0, #36]	; 0x24
   254fa:	f8c7 5124 	str.w	r5, [r7, #292]	; 0x124
   hybrid = start != 0;
   tf_estimate = 0;
   if (nbCompressedBytes<2 || pcm==NULL)
   254fe:	f1be 0f01 	cmp.w	lr, #1
   int dual_stereo=0;
   25502:	f04f 0500 	mov.w	r5, #0
   mode = st->mode;
   25506:	f8c7 4100 	str.w	r4, [r7, #256]	; 0x100
   int dual_stereo=0;
   2550a:	f8c7 5134 	str.w	r5, [r7, #308]	; 0x134
   if (nbCompressedBytes<2 || pcm==NULL)
   2550e:	dd19      	ble.n	25544 <celt_encode_with_ec+0x7c>
   25510:	b1c1      	cbz	r1, 25544 <celt_encode_with_ec+0x7c>
   {
      RESTORE_STACK;
      return OPUS_BAD_ARG;
   }

   frame_size *= st->upsample;
   25512:	69c6      	ldr	r6, [r0, #28]
   25514:	f8c7 612c 	str.w	r6, [r7, #300]	; 0x12c
   for (LM=0;LM<=mode->maxLM;LM++)
   25518:	f8d4 c01c 	ldr.w	ip, [r4, #28]
   2551c:	4626      	mov	r6, r4
   frame_size *= st->upsample;
   2551e:	f8d7 412c 	ldr.w	r4, [r7, #300]	; 0x12c
   for (LM=0;LM<=mode->maxLM;LM++)
   25522:	45ac      	cmp	ip, r5
   frame_size *= st->upsample;
   25524:	fb04 f402 	mul.w	r4, r4, r2
   for (LM=0;LM<=mode->maxLM;LM++)
   25528:	db0c      	blt.n	25544 <celt_encode_with_ec+0x7c>
      if (mode->shortMdctSize<<LM==frame_size)
   2552a:	6a72      	ldr	r2, [r6, #36]	; 0x24
   2552c:	4294      	cmp	r4, r2
   2552e:	f003 813a 	beq.w	287a6 <celt_encode_with_ec+0x32de>
   25532:	4676      	mov	r6, lr
   25534:	e001      	b.n	2553a <celt_encode_with_ec+0x72>
   25536:	45a6      	cmp	lr, r4
   25538:	d00e      	beq.n	25558 <celt_encode_with_ec+0x90>
   for (LM=0;LM<=mode->maxLM;LM++)
   2553a:	3501      	adds	r5, #1
   2553c:	4565      	cmp	r5, ip
      if (mode->shortMdctSize<<LM==frame_size)
   2553e:	fa02 fe05 	lsl.w	lr, r2, r5
   for (LM=0;LM<=mode->maxLM;LM++)
   25542:	ddf8      	ble.n	25536 <celt_encode_with_ec+0x6e>
      return OPUS_BAD_ARG;
   25544:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   25548:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
   2554c:	4618      	mov	r0, r3
   RESTORE_STACK;
   if (ec_get_error(enc))
      return OPUS_INTERNAL_ERROR;
   else
      return nbCompressedBytes;
}
   2554e:	f507 77d2 	add.w	r7, r7, #420	; 0x1a4
   25552:	46bd      	mov	sp, r7
   25554:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   25558:	462a      	mov	r2, r5
   2555a:	f8c7 510c 	str.w	r5, [r7, #268]	; 0x10c
   2555e:	f04f 0c01 	mov.w	ip, #1
   25562:	f44f 75c8 	mov.w	r5, #400	; 0x190
   25566:	4115      	asrs	r5, r2
   25568:	f8c7 e0f0 	str.w	lr, [r7, #240]	; 0xf0
   2556c:	46b6      	mov	lr, r6
   2556e:	4616      	mov	r6, r2
   25570:	fa0c f202 	lsl.w	r2, ip, r2
   25574:	677a      	str	r2, [r7, #116]	; 0x74
   25576:	f1c6 0203 	rsb	r2, r6, #3
   2557a:	3d32      	subs	r5, #50	; 0x32
   2557c:	66ba      	str	r2, [r7, #104]	; 0x68
   prefilter_mem = st->in_mem+CC*(overlap);
   2557e:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
   oldLogE = oldBandE + CC*nbEBands;
   25582:	f8d7 611c 	ldr.w	r6, [r7, #284]	; 0x11c
   25586:	f8c7 012c 	str.w	r0, [r7, #300]	; 0x12c
   2558a:	469b      	mov	fp, r3
   2558c:	4688      	mov	r8, r1
   prefilter_mem = st->in_mem+CC*(overlap);
   2558e:	fb09 f302 	mul.w	r3, r9, r2
   oldBandE = (opus_val16*)(st->in_mem+CC*(overlap+COMBFILTER_MAXPERIOD));
   25592:	0291      	lsls	r1, r2, #10
   oldLogE = oldBandE + CC*nbEBands;
   25594:	fb06 f202 	mul.w	r2, r6, r2
   prefilter_mem = st->in_mem+CC*(overlap);
   25598:	30f4      	adds	r0, #244	; 0xf4
   oldBandE = (opus_val16*)(st->in_mem+CC*(overlap+COMBFILTER_MAXPERIOD));
   2559a:	f8c7 1080 	str.w	r1, [r7, #128]	; 0x80
   oldLogE = oldBandE + CC*nbEBands;
   2559e:	f8c7 20bc 	str.w	r2, [r7, #188]	; 0xbc
   oldBandE = (opus_val16*)(st->in_mem+CC*(overlap+COMBFILTER_MAXPERIOD));
   255a2:	1859      	adds	r1, r3, r1
   oldLogE = oldBandE + CC*nbEBands;
   255a4:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
   oldBandE = (opus_val16*)(st->in_mem+CC*(overlap+COMBFILTER_MAXPERIOD));
   255a8:	6739      	str	r1, [r7, #112]	; 0x70
   255aa:	eb00 0181 	add.w	r1, r0, r1, lsl #2
   255ae:	460e      	mov	r6, r1
   255b0:	f8c7 1110 	str.w	r1, [r7, #272]	; 0x110
   oldLogE = oldBandE + CC*nbEBands;
   255b4:	0051      	lsls	r1, r2, #1
   255b6:	4632      	mov	r2, r6
   255b8:	440a      	add	r2, r1
   255ba:	f8c7 20f8 	str.w	r2, [r7, #248]	; 0xf8
   oldLogE2 = oldLogE + CC*nbEBands;
   255be:	440a      	add	r2, r1
   255c0:	4616      	mov	r6, r2
   prefilter_mem = st->in_mem+CC*(overlap);
   255c2:	f8c7 008c 	str.w	r0, [r7, #140]	; 0x8c
   oldLogE2 = oldLogE + CC*nbEBands;
   255c6:	f8c7 20f4 	str.w	r2, [r7, #244]	; 0xf4
   prefilter_mem = st->in_mem+CC*(overlap);
   255ca:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   255ce:	f240 42fb 	movw	r2, #1275	; 0x4fb
   energyError = oldLogE2 + CC*nbEBands;
   255d2:	4633      	mov	r3, r6
   255d4:	440b      	add	r3, r1
   255d6:	4596      	cmp	lr, r2
   255d8:	67fb      	str	r3, [r7, #124]	; 0x7c
   255da:	4673      	mov	r3, lr
   255dc:	bfa8      	it	ge
   255de:	4613      	movge	r3, r2
   255e0:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
   if (enc==NULL)
   255e4:	f8d7 31cc 	ldr.w	r3, [r7, #460]	; 0x1cc
   oldLogE = oldBandE + CC*nbEBands;
   255e8:	f8c7 10c4 	str.w	r1, [r7, #196]	; 0xc4
   prefilter_mem = st->in_mem+CC*(overlap);
   255ec:	f8c7 00dc 	str.w	r0, [r7, #220]	; 0xdc
   if (enc==NULL)
   255f0:	2b00      	cmp	r3, #0
   255f2:	f001 86ef 	beq.w	273d4 <celt_encode_with_ec+0x1f0c>
   255f6:	4618      	mov	r0, r3
      tell0_frac=ec_tell_frac(enc);
   255f8:	f004 f898 	bl	2972c <ec_tell_frac>
  return _this->nbits_total-EC_ILOG(_this->rng);
   255fc:	f8d7 31cc 	ldr.w	r3, [r7, #460]	; 0x1cc
   25600:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
   25604:	69db      	ldr	r3, [r3, #28]
   25606:	6951      	ldr	r1, [r2, #20]
   25608:	63b8      	str	r0, [r7, #56]	; 0x38
   2560a:	fab3 f383 	clz	r3, r3
   2560e:	f1c3 0320 	rsb	r3, r3, #32
   25612:	1acb      	subs	r3, r1, r3
   if (st->vbr && st->bitrate!=OPUS_BITRATE_MAX)
   25614:	f8d7 012c 	ldr.w	r0, [r7, #300]	; 0x12c
   25618:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
      nbFilledBytes=(tell+4)>>3;
   2561c:	f103 0a04 	add.w	sl, r3, #4
   nbAvailableBytes = nbCompressedBytes - nbFilledBytes;
   25620:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
   if (st->vbr && st->bitrate!=OPUS_BITRATE_MAX)
   25624:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
      nbFilledBytes=(tell+4)>>3;
   25626:	ea4f 0aea 	mov.w	sl, sl, asr #3
   nbAvailableBytes = nbCompressedBytes - nbFilledBytes;
   2562a:	eba3 030a 	sub.w	r3, r3, sl
   2562e:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
   if (st->vbr && st->bitrate!=OPUS_BITRATE_MAX)
   25632:	2a00      	cmp	r2, #0
   25634:	f002 81a5 	beq.w	27982 <celt_encode_with_ec+0x24ba>
   25638:	6a82      	ldr	r2, [r0, #40]	; 0x28
   2563a:	1c51      	adds	r1, r2, #1
   2563c:	fb02 f404 	mul.w	r4, r2, r4
   25640:	f001 86df 	beq.w	27402 <celt_encode_with_ec+0x1f3a>
   equiv_rate = ((opus_int32)nbCompressedBytes*8*50 >> (3-LM)) - (40*C+20)*((400>>LM) - 50);
   25644:	f8d7 1114 	ldr.w	r1, [r7, #276]	; 0x114
   25648:	008b      	lsls	r3, r1, #2
   2564a:	1859      	adds	r1, r3, r1
   2564c:	00c9      	lsls	r1, r1, #3
   2564e:	f101 0014 	add.w	r0, r1, #20
   25652:	f8d7 10e8 	ldr.w	r1, [r7, #232]	; 0xe8
   25656:	623b      	str	r3, [r7, #32]
   25658:	f44f 73c8 	mov.w	r3, #400	; 0x190
   2565c:	fb03 f301 	mul.w	r3, r3, r1
   25660:	fb05 f500 	mul.w	r5, r5, r0
   25664:	63f8      	str	r0, [r7, #60]	; 0x3c
      opus_int32 den=mode->Fs>>BITRES;
   25666:	f8d7 1100 	ldr.w	r1, [r7, #256]	; 0x100
   equiv_rate = ((opus_int32)nbCompressedBytes*8*50 >> (3-LM)) - (40*C+20)*((400>>LM) - 50);
   2566a:	6eb8      	ldr	r0, [r7, #104]	; 0x68
      opus_int32 den=mode->Fs>>BITRES;
   2566c:	6809      	ldr	r1, [r1, #0]
   equiv_rate = ((opus_int32)nbCompressedBytes*8*50 >> (3-LM)) - (40*C+20)*((400>>LM) - 50);
   2566e:	4103      	asrs	r3, r0
   25670:	1b5b      	subs	r3, r3, r5
      vbr_rate=(st->bitrate*frame_size+(den>>1))/den;
   25672:	eb04 1421 	add.w	r4, r4, r1, asr #4
   equiv_rate = ((opus_int32)nbCompressedBytes*8*50 >> (3-LM)) - (40*C+20)*((400>>LM) - 50);
   25676:	67bb      	str	r3, [r7, #120]	; 0x78
      opus_int32 den=mode->Fs>>BITRES;
   25678:	10c9      	asrs	r1, r1, #3
      vbr_rate=(st->bitrate*frame_size+(den>>1))/den;
   2567a:	fb94 f3f1 	sdiv	r3, r4, r1
   2567e:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
      effectiveBytes = vbr_rate>>(3+BITRES);
   25682:	119b      	asrs	r3, r3, #6
   25684:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
      equiv_rate = IMIN(equiv_rate, st->bitrate - (40*C+20)*((400>>LM) - 50));
   25688:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   2568a:	1b55      	subs	r5, r2, r5
   2568c:	42ab      	cmp	r3, r5
   2568e:	bfa8      	it	ge
   25690:	462b      	movge	r3, r5
   25692:	67bb      	str	r3, [r7, #120]	; 0x78
   if (enc==NULL)
   25694:	f8d7 31cc 	ldr.w	r3, [r7, #460]	; 0x1cc
   25698:	2b00      	cmp	r3, #0
   2569a:	f001 86f7 	beq.w	2748c <celt_encode_with_ec+0x1fc4>
   if (vbr_rate>0)
   2569e:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
   256a2:	2a00      	cmp	r2, #0
   256a4:	dd24      	ble.n	256f0 <celt_encode_with_ec+0x228>
      if (st->constrained_vbr)
   256a6:	f8d7 112c 	ldr.w	r1, [r7, #300]	; 0x12c
   256aa:	6b4b      	ldr	r3, [r1, #52]	; 0x34
   256ac:	b303      	cbz	r3, 256f0 <celt_encode_with_ec+0x228>
         max_allowed = IMIN(IMAX(tell==1?2:0,
   256ae:	f8d1 30d0 	ldr.w	r3, [r1, #208]	; 0xd0
   256b2:	f8d7 10b0 	ldr.w	r1, [r7, #176]	; 0xb0
   256b6:	ebc3 0442 	rsb	r4, r3, r2, lsl #1
   256ba:	2901      	cmp	r1, #1
   256bc:	ea4f 14a4 	mov.w	r4, r4, asr #6
   256c0:	bf14      	ite	ne
   256c2:	2300      	movne	r3, #0
   256c4:	2302      	moveq	r3, #2
   256c6:	429c      	cmp	r4, r3
   256c8:	bfb8      	it	lt
   256ca:	461c      	movlt	r4, r3
   256cc:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
   256d0:	429c      	cmp	r4, r3
   256d2:	bfa8      	it	ge
   256d4:	461c      	movge	r4, r3
         if(max_allowed < nbAvailableBytes)
   256d6:	429c      	cmp	r4, r3
   256d8:	da0a      	bge.n	256f0 <celt_encode_with_ec+0x228>
            nbCompressedBytes = nbFilledBytes+max_allowed;
   256da:	eb0a 0304 	add.w	r3, sl, r4
            ec_enc_shrink(enc, nbCompressedBytes);
   256de:	4619      	mov	r1, r3
   256e0:	f8d7 01cc 	ldr.w	r0, [r7, #460]	; 0x1cc
            nbCompressedBytes = nbFilledBytes+max_allowed;
   256e4:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
            ec_enc_shrink(enc, nbCompressedBytes);
   256e8:	f004 fd00 	bl	2a0ec <ec_enc_shrink>
   256ec:	f8c7 40b8 	str.w	r4, [r7, #184]	; 0xb8
   ALLOC(in, CC*(N+overlap), celt_sig);
   256f0:	f8d7 00f0 	ldr.w	r0, [r7, #240]	; 0xf0
   256f4:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
   256f8:	f8c7 d050 	str.w	sp, [r7, #80]	; 0x50
   256fc:	eb09 0300 	add.w	r3, r9, r0
   25700:	fb02 f103 	mul.w	r1, r2, r3
   25704:	0089      	lsls	r1, r1, #2
   25706:	310a      	adds	r1, #10
   25708:	f021 0107 	bic.w	r1, r1, #7
   2570c:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
   25710:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
   25714:	ebad 0d01 	sub.w	sp, sp, r1
   25718:	68da      	ldr	r2, [r3, #12]
   sample_max=MAX32(st->overlap_max, celt_maxabs16(pcm, C*(N-overlap)/st->upsample));
   2571a:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
   ALLOC(in, CC*(N+overlap), celt_sig);
   2571e:	a914      	add	r1, sp, #80	; 0x50
   25720:	f8c7 1104 	str.w	r1, [r7, #260]	; 0x104
   sample_max=MAX32(st->overlap_max, celt_maxabs16(pcm, C*(N-overlap)/st->upsample));
   25724:	f8d7 1114 	ldr.w	r1, [r7, #276]	; 0x114
   25728:	f8d3 c01c 	ldr.w	ip, [r3, #28]
   2572c:	f8d3 60e0 	ldr.w	r6, [r3, #224]	; 0xe0
   25730:	eba0 0309 	sub.w	r3, r0, r9
   25734:	fb01 f303 	mul.w	r3, r1, r3
   25738:	f8d7 1124 	ldr.w	r1, [r7, #292]	; 0x124
   2573c:	fb93 f3fc 	sdiv	r3, r3, ip
   25740:	428a      	cmp	r2, r1
   25742:	bfa8      	it	ge
   25744:	460a      	movge	r2, r1
   25746:	f8c7 20e4 	str.w	r2, [r7, #228]	; 0xe4
   total_bits = nbCompressedBytes*8;
   2574a:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
   for (i=0;i<len;i++)
   2574e:	2b00      	cmp	r3, #0
   25750:	ea4f 02c2 	mov.w	r2, r2, lsl #3
   25754:	f8c7 20e0 	str.w	r2, [r7, #224]	; 0xe0
   25758:	ea4f 0343 	mov.w	r3, r3, lsl #1
   2575c:	f342 875c 	ble.w	28618 <celt_encode_with_ec+0x3150>
   25760:	f1a8 0502 	sub.w	r5, r8, #2
   opus_val16 maxval = 0;
   25764:	2400      	movs	r4, #0
   25766:	eb05 0e03 	add.w	lr, r5, r3
   2576a:	462a      	mov	r2, r5
   opus_val16 minval = 0;
   2576c:	4620      	mov	r0, r4
      maxval = MAX16(maxval, x[i]);
   2576e:	f932 1f02 	ldrsh.w	r1, [r2, #2]!
   25772:	428c      	cmp	r4, r1
   25774:	bfb8      	it	lt
   25776:	460c      	movlt	r4, r1
      minval = MIN16(minval, x[i]);
   25778:	4288      	cmp	r0, r1
   2577a:	bfa8      	it	ge
   2577c:	4608      	movge	r0, r1
   for (i=0;i<len;i++)
   2577e:	4596      	cmp	lr, r2
   25780:	d1f5      	bne.n	2576e <celt_encode_with_ec+0x2a6>
   sample_max=MAX32(st->overlap_max, celt_maxabs16(pcm, C*(N-overlap)/st->upsample));
   25782:	4240      	negs	r0, r0
   25784:	42a0      	cmp	r0, r4
   25786:	bfb8      	it	lt
   25788:	4620      	movlt	r0, r4
   2578a:	4286      	cmp	r6, r0
   2578c:	dc10      	bgt.n	257b0 <celt_encode_with_ec+0x2e8>
   opus_val16 minval = 0;
   2578e:	2100      	movs	r1, #0
   25790:	18ec      	adds	r4, r5, r3
   opus_val16 maxval = 0;
   25792:	4608      	mov	r0, r1
      maxval = MAX16(maxval, x[i]);
   25794:	f935 2f02 	ldrsh.w	r2, [r5, #2]!
   25798:	4290      	cmp	r0, r2
   2579a:	bfb8      	it	lt
   2579c:	4610      	movlt	r0, r2
      minval = MIN16(minval, x[i]);
   2579e:	4291      	cmp	r1, r2
   257a0:	bfa8      	it	ge
   257a2:	4611      	movge	r1, r2
   for (i=0;i<len;i++)
   257a4:	42ac      	cmp	r4, r5
   257a6:	d1f5      	bne.n	25794 <celt_encode_with_ec+0x2cc>
   257a8:	424e      	negs	r6, r1
   257aa:	4286      	cmp	r6, r0
   257ac:	bfb8      	it	lt
   257ae:	4606      	movlt	r6, r0
   st->overlap_max=celt_maxabs16(pcm+C*(N-overlap)/st->upsample, C*overlap/st->upsample);
   257b0:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
   257b4:	fb09 f202 	mul.w	r2, r9, r2
   257b8:	fb92 f2fc 	sdiv	r2, r2, ip
   257bc:	2a00      	cmp	r2, #0
   257be:	f342 8728 	ble.w	28612 <celt_encode_with_ec+0x314a>
   257c2:	eb08 0042 	add.w	r0, r8, r2, lsl #1
   opus_val16 minval = 0;
   257c6:	2200      	movs	r2, #0
   257c8:	4418      	add	r0, r3
   opus_val16 maxval = 0;
   257ca:	4614      	mov	r4, r2
   257cc:	4443      	add	r3, r8
      maxval = MAX16(maxval, x[i]);
   257ce:	f933 1b02 	ldrsh.w	r1, [r3], #2
   257d2:	428c      	cmp	r4, r1
   257d4:	bfb8      	it	lt
   257d6:	460c      	movlt	r4, r1
      minval = MIN16(minval, x[i]);
   257d8:	428a      	cmp	r2, r1
   257da:	bfa8      	it	ge
   257dc:	460a      	movge	r2, r1
   for (i=0;i<len;i++)
   257de:	4298      	cmp	r0, r3
   257e0:	d1f5      	bne.n	257ce <celt_encode_with_ec+0x306>
   257e2:	4252      	negs	r2, r2
   257e4:	4294      	cmp	r4, r2
   257e6:	bfb8      	it	lt
   257e8:	4614      	movlt	r4, r2
   257ea:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
   257ee:	f8c3 40e0 	str.w	r4, [r3, #224]	; 0xe0
   if (tell==1)
   257f2:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
   257f6:	2b01      	cmp	r3, #1
   257f8:	f002 80e6 	beq.w	279c8 <celt_encode_with_ec+0x2500>
      silence=0;
   257fc:	2300      	movs	r3, #0
   257fe:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
   25802:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
   25806:	eb03 0689 	add.w	r6, r3, r9, lsl #2
   2580a:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
   2580e:	f103 0910 	add.w	r9, r3, #16
   25812:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
   25816:	009b      	lsls	r3, r3, #2
   25818:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
   2581c:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
   c=0; do {
   25820:	2400      	movs	r4, #0
   25822:	f103 05c0 	add.w	r5, r3, #192	; 0xc0
   25826:	46cb      	mov	fp, r9
      celt_preemphasis(pcm+c, in+c*(N+overlap)+overlap, N, CC, st->upsample,
   25828:	46a2      	mov	sl, r4
   2582a:	4663      	mov	r3, ip
   2582c:	f8c7 4128 	str.w	r4, [r7, #296]	; 0x128
   25830:	f8d7 9108 	ldr.w	r9, [r7, #264]	; 0x108
   25834:	e000      	b.n	25838 <celt_encode_with_ec+0x370>
   25836:	69db      	ldr	r3, [r3, #28]
   25838:	e9cd 5a02 	strd	r5, sl, [sp, #8]
   2583c:	e9cd 3b00 	strd	r3, fp, [sp]
   } while (++c<CC);
   25840:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
      celt_preemphasis(pcm+c, in+c*(N+overlap)+overlap, N, CC, st->upsample,
   25844:	f8d7 20f0 	ldr.w	r2, [r7, #240]	; 0xf0
   25848:	f8d7 4118 	ldr.w	r4, [r7, #280]	; 0x118
   } while (++c<CC);
   2584c:	3301      	adds	r3, #1
   2584e:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
      celt_preemphasis(pcm+c, in+c*(N+overlap)+overlap, N, CC, st->upsample,
   25852:	4631      	mov	r1, r6
   25854:	464b      	mov	r3, r9
   25856:	4640      	mov	r0, r8
   25858:	f7ff fdce 	bl	253f8 <celt_preemphasis>
   } while (++c<CC);
   2585c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
   25860:	4599      	cmp	r9, r3
   25862:	f105 0504 	add.w	r5, r5, #4
   25866:	4426      	add	r6, r4
   25868:	f108 0802 	add.w	r8, r8, #2
   2586c:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
   25870:	dce1      	bgt.n	25836 <celt_encode_with_ec+0x36e>
            && st->complexity >= 5;
   25872:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   25874:	2b00      	cmp	r3, #0
   25876:	f000 8381 	beq.w	25f7c <celt_encode_with_ec+0xab4>
      enabled = ((st->lfe&&nbAvailableBytes>3) || nbAvailableBytes>12*C) && !hybrid && !silence && !st->disable_pf
   2587a:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
   2587e:	2b03      	cmp	r3, #3
   25880:	f340 837c 	ble.w	25f7c <celt_encode_with_ec+0xab4>
   25884:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
   25888:	b923      	cbnz	r3, 25894 <celt_encode_with_ec+0x3cc>
   2588a:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
   2588e:	2b00      	cmp	r3, #0
   25890:	f002 81aa 	beq.w	27be8 <celt_encode_with_ec+0x2720>
   25894:	f8d7 112c 	ldr.w	r1, [r7, #300]	; 0x12c
            && st->complexity >= 5;
   25898:	2400      	movs	r4, #0
   ALLOC(_pre, CC*(N+COMBFILTER_MAXPERIOD), celt_sig);
   2589a:	f8d7 00f0 	ldr.w	r0, [r7, #240]	; 0xf0
   2589e:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
   mode = st->mode;
   258a2:	680a      	ldr	r2, [r1, #0]
{
   258a4:	f8c7 d088 	str.w	sp, [r7, #136]	; 0x88
   ALLOC(_pre, CC*(N+COMBFILTER_MAXPERIOD), celt_sig);
   258a8:	f500 6880 	add.w	r8, r0, #1024	; 0x400
   258ac:	fb08 f303 	mul.w	r3, r8, r3
   258b0:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
   258b4:	009b      	lsls	r3, r3, #2
   258b6:	330a      	adds	r3, #10
   258b8:	f023 0307 	bic.w	r3, r3, #7
   258bc:	ebad 0d03 	sub.w	sp, sp, r3
   overlap = mode->overlap;
   258c0:	f8d2 b004 	ldr.w	fp, [r2, #4]
      prefilter_tapset = st->tapset_decision;
   258c4:	6e49      	ldr	r1, [r1, #100]	; 0x64
   mode = st->mode;
   258c6:	f8c7 20d8 	str.w	r2, [r7, #216]	; 0xd8
   ALLOC(_pre, CC*(N+COMBFILTER_MAXPERIOD), celt_sig);
   258ca:	ab14      	add	r3, sp, #80	; 0x50
   pre[1] = _pre + (N+COMBFILTER_MAXPERIOD);
   258cc:	ea4f 0288 	mov.w	r2, r8, lsl #2
      prefilter_tapset = st->tapset_decision;
   258d0:	f8c7 10ac 	str.w	r1, [r7, #172]	; 0xac
   pre[0] = _pre;
   258d4:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
   pre[1] = _pre + (N+COMBFILTER_MAXPERIOD);
   258d8:	1899      	adds	r1, r3, r2
   258da:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
   258de:	f8c7 1170 	str.w	r1, [r7, #368]	; 0x170
   258e2:	ea4f 058b 	mov.w	r5, fp, lsl #2
   258e6:	4458      	add	r0, fp
   258e8:	f8c7 50cc 	str.w	r5, [r7, #204]	; 0xcc
      OPUS_COPY(pre[c]+COMBFILTER_MAXPERIOD, in+c*(N+overlap)+overlap, N);
   258ec:	f5a2 5280 	sub.w	r2, r2, #4096	; 0x1000
   258f0:	195e      	adds	r6, r3, r5
   258f2:	f8d7 50dc 	ldr.w	r5, [r7, #220]	; 0xdc
   258f6:	f8c7 009c 	str.w	r0, [r7, #156]	; 0x9c
   258fa:	f8c7 20d4 	str.w	r2, [r7, #212]	; 0xd4
   258fe:	ea4f 0980 	mov.w	r9, r0, lsl #2
   c=0; do {
   25902:	f04f 0a00 	mov.w	sl, #0
      OPUS_COPY(pre[c], prefilter_mem+c*COMBFILTER_MAXPERIOD, COMBFILTER_MAXPERIOD);
   25906:	f507 73b6 	add.w	r3, r7, #364	; 0x16c
   2590a:	4629      	mov	r1, r5
   2590c:	f853 002a 	ldr.w	r0, [r3, sl, lsl #2]
   25910:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   25914:	f7e6 fbf4 	bl	c100 <memcpy>
      OPUS_COPY(pre[c]+COMBFILTER_MAXPERIOD, in+c*(N+overlap)+overlap, N);
   25918:	f507 73b6 	add.w	r3, r7, #364	; 0x16c
   2591c:	4631      	mov	r1, r6
   2591e:	f853 002a 	ldr.w	r0, [r3, sl, lsl #2]
   25922:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
   25926:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
   2592a:	f7e6 fbe9 	bl	c100 <memcpy>
   } while (++c<CC);
   2592e:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
   25932:	f10a 0a01 	add.w	sl, sl, #1
   25936:	4553      	cmp	r3, sl
   25938:	f505 5580 	add.w	r5, r5, #4096	; 0x1000
   2593c:	444e      	add	r6, r9
   2593e:	dce2      	bgt.n	25906 <celt_encode_with_ec+0x43e>
   25940:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
   25944:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   25946:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
   if (enabled)
   2594a:	2c00      	cmp	r4, #0
   2594c:	f041 8703 	bne.w	27756 <celt_encode_with_ec+0x228e>
      pitch_index = COMBFILTER_MINPERIOD;
   25950:	f507 73d0 	add.w	r3, r7, #416	; 0x1a0
   25954:	220f      	movs	r2, #15
   25956:	f843 2d68 	str.w	r2, [r3, #-104]!
   2595a:	667b      	str	r3, [r7, #100]	; 0x64
   if (abs(pitch_index-st->prefilter_period)*10>pitch_index)
   2595c:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
   25960:	6e99      	ldr	r1, [r3, #104]	; 0x68
   25962:	1a53      	subs	r3, r2, r1
   25964:	2b00      	cmp	r3, #0
   25966:	bfb8      	it	lt
   25968:	425b      	neglt	r3, r3
   2596a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   2596e:	005b      	lsls	r3, r3, #1
   25970:	4293      	cmp	r3, r2
   25972:	f243 3534 	movw	r5, #13108	; 0x3334
   25976:	f644 43ce 	movw	r3, #19662	; 0x4cce
   2597a:	f641 129a 	movw	r2, #6554	; 0x199a
   2597e:	bfd4      	ite	le
   25980:	462b      	movle	r3, r5
   25982:	462a      	movgt	r2, r5
   if (nbAvailableBytes<25)
   25984:	f8d7 50b8 	ldr.w	r5, [r7, #184]	; 0xb8
   if (abs(pitch_index-st->prefilter_period)*10>pitch_index)
   25988:	f244 0601 	movw	r6, #16385	; 0x4001
   2598c:	f242 6067 	movw	r0, #9831	; 0x2667
   25990:	bfc8      	it	gt
   25992:	4630      	movgt	r0, r6
   if (nbAvailableBytes<25)
   25994:	2d18      	cmp	r5, #24
   25996:	f340 859d 	ble.w	264d4 <celt_encode_with_ec+0x100c>
   if (nbAvailableBytes<35)
   2599a:	2d22      	cmp	r5, #34	; 0x22
   2599c:	f340 8599 	ble.w	264d2 <celt_encode_with_ec+0x100a>
   if (st->prefilter_gain > QCONST16(.4f,15))
   259a0:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
   259a4:	f9b3 306c 	ldrsh.w	r3, [r3, #108]	; 0x6c
   259a8:	f243 3033 	movw	r0, #13107	; 0x3333
   259ac:	4283      	cmp	r3, r0
   259ae:	dd0a      	ble.n	259c6 <celt_encode_with_ec+0x4fe>
   if (st->prefilter_gain > QCONST16(.55f,15))
   259b0:	f244 6066 	movw	r0, #18022	; 0x4666
      pf_threshold -= QCONST16(.1f,15);
   259b4:	b292      	uxth	r2, r2
   if (st->prefilter_gain > QCONST16(.55f,15))
   259b6:	4283      	cmp	r3, r0
      pf_threshold -= QCONST16(.1f,15);
   259b8:	bfca      	itet	gt
   259ba:	f5a2 52cc 	subgt.w	r2, r2, #6528	; 0x1980
      pf_threshold -= QCONST16(.1f,15);
   259be:	f6a2 42cd 	subwle	r2, r2, #3277	; 0xccd
      pf_threshold -= QCONST16(.1f,15);
   259c2:	3a1a      	subgt	r2, #26
   259c4:	b212      	sxth	r2, r2
   pf_threshold = MAX16(pf_threshold, QCONST16(.2f,15));
   259c6:	f641 159a 	movw	r5, #6554	; 0x199a
   259ca:	42aa      	cmp	r2, r5
   259cc:	bfb8      	it	lt
   259ce:	462a      	movlt	r2, r5
   if (gain1<pf_threshold)
   259d0:	b212      	sxth	r2, r2
   259d2:	42a2      	cmp	r2, r4
   259d4:	f300 8575 	bgt.w	264c2 <celt_encode_with_ec+0xffa>
      if (ABS16(gain1-st->prefilter_gain)<QCONST16(.1f,15))
   259d8:	1ae2      	subs	r2, r4, r3
   259da:	f602 42cc 	addw	r2, r2, #3276	; 0xccc
   259de:	f641 1098 	movw	r0, #6552	; 0x1998
   259e2:	4282      	cmp	r2, r0
   259e4:	bf98      	it	ls
   259e6:	461c      	movls	r4, r3
      qg = ((gain1+1536)>>10)/3-1;
   259e8:	f504 62c0 	add.w	r2, r4, #1536	; 0x600
   259ec:	4caf      	ldr	r4, [pc, #700]	; (25cac <celt_encode_with_ec+0x7e4>)
   259ee:	1290      	asrs	r0, r2, #10
   259f0:	fb84 4000 	smull	r4, r0, r4, r0
   259f4:	eba0 72e2 	sub.w	r2, r0, r2, asr #31
   259f8:	3a01      	subs	r2, #1
   259fa:	f382 0203 	usat	r2, #3, r2
   259fe:	663a      	str	r2, [r7, #96]	; 0x60
      gain1 = QCONST16(0.09375f,15)*(qg+1);
   25a00:	3201      	adds	r2, #1
   25a02:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   25a06:	0292      	lsls	r2, r2, #10
   25a08:	b292      	uxth	r2, r2
   25a0a:	4250      	negs	r0, r2
   25a0c:	b212      	sxth	r2, r2
   25a0e:	b200      	sxth	r0, r0
   25a10:	64fa      	str	r2, [r7, #76]	; 0x4c
      pf_on = 1;
   25a12:	2201      	movs	r2, #1
   25a14:	f8c7 0098 	str.w	r0, [r7, #152]	; 0x98
   25a18:	657a      	str	r2, [r7, #84]	; 0x54
         OPUS_MOVE(prefilter_mem+c*COMBFILTER_MAXPERIOD, prefilter_mem+c*COMBFILTER_MAXPERIOD+N, COMBFILTER_MAXPERIOD-N);
   25a1a:	f8d7 00f0 	ldr.w	r0, [r7, #240]	; 0xf0
         comb_filter(in+c*(N+overlap)+overlap, pre[c]+COMBFILTER_MAXPERIOD,
   25a1e:	f8d7 812c 	ldr.w	r8, [r7, #300]	; 0x12c
         OPUS_MOVE(prefilter_mem+c*COMBFILTER_MAXPERIOD, prefilter_mem+c*COMBFILTER_MAXPERIOD+N, COMBFILTER_MAXPERIOD-N);
   25a22:	f5c0 6280 	rsb	r2, r0, #1024	; 0x400
   25a26:	0092      	lsls	r2, r2, #2
   c=0; do {
   25a28:	f04f 0900 	mov.w	r9, #0
         OPUS_MOVE(prefilter_mem+c*COMBFILTER_MAXPERIOD, prefilter_mem+c*COMBFILTER_MAXPERIOD+N, COMBFILTER_MAXPERIOD-N);
   25a2c:	f8c7 20a4 	str.w	r2, [r7, #164]	; 0xa4
         comb_filter(in+c*(N+overlap)+overlap, pre[c]+COMBFILTER_MAXPERIOD,
   25a30:	4682      	mov	sl, r0
   25a32:	461c      	mov	r4, r3
      st->prefilter_period=IMAX(st->prefilter_period, COMBFILTER_MINPERIOD);
   25a34:	460a      	mov	r2, r1
   25a36:	290f      	cmp	r1, #15
         OPUS_MOVE(prefilter_mem+c*COMBFILTER_MAXPERIOD, prefilter_mem+c*COMBFILTER_MAXPERIOD+N, COMBFILTER_MAXPERIOD-N);
   25a38:	ea4f 2389 	mov.w	r3, r9, lsl #10
      OPUS_COPY(in+c*(N+overlap), st->in_mem+c*(overlap), overlap);
   25a3c:	f8d7 108c 	ldr.w	r1, [r7, #140]	; 0x8c
         OPUS_MOVE(prefilter_mem+c*COMBFILTER_MAXPERIOD, prefilter_mem+c*COMBFILTER_MAXPERIOD+N, COMBFILTER_MAXPERIOD-N);
   25a40:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
      OPUS_COPY(in+c*(N+overlap), st->in_mem+c*(overlap), overlap);
   25a44:	fb09 f30b 	mul.w	r3, r9, fp
   25a48:	eb01 0183 	add.w	r1, r1, r3, lsl #2
      int offset = mode->shortMdctSize-overlap;
   25a4c:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
      OPUS_COPY(in+c*(N+overlap), st->in_mem+c*(overlap), overlap);
   25a50:	f8c7 10b4 	str.w	r1, [r7, #180]	; 0xb4
      st->prefilter_period=IMAX(st->prefilter_period, COMBFILTER_MINPERIOD);
   25a54:	bfb8      	it	lt
   25a56:	220f      	movlt	r2, #15
      int offset = mode->shortMdctSize-overlap;
   25a58:	6a5d      	ldr	r5, [r3, #36]	; 0x24
      OPUS_COPY(in+c*(N+overlap), st->in_mem+c*(overlap), overlap);
   25a5a:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
      st->prefilter_period=IMAX(st->prefilter_period, COMBFILTER_MINPERIOD);
   25a5e:	f8c7 20ec 	str.w	r2, [r7, #236]	; 0xec
   25a62:	f8c8 2068 	str.w	r2, [r8, #104]	; 0x68
      OPUS_COPY(in+c*(N+overlap), st->in_mem+c*(overlap), overlap);
   25a66:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
   25a6a:	fb03 f609 	mul.w	r6, r3, r9
   25a6e:	eb02 0086 	add.w	r0, r2, r6, lsl #2
   25a72:	ea4f 0389 	mov.w	r3, r9, lsl #2
   25a76:	f8d7 20cc 	ldr.w	r2, [r7, #204]	; 0xcc
   25a7a:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
   25a7e:	f7e6 fb3f 	bl	c100 <memcpy>
   25a82:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
   25a86:	f8d8 0070 	ldr.w	r0, [r8, #112]	; 0x70
   25a8a:	f507 72d0 	add.w	r2, r7, #416	; 0x1a0
   25a8e:	18d3      	adds	r3, r2, r3
   25a90:	4264      	negs	r4, r4
      int offset = mode->shortMdctSize-overlap;
   25a92:	eba5 050b 	sub.w	r5, r5, fp
   25a96:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
   25a9a:	b224      	sxth	r4, r4
   25a9c:	f853 1c34 	ldr.w	r1, [r3, #-52]
      if (offset)
   25aa0:	2d00      	cmp	r5, #0
   25aa2:	f040 83de 	bne.w	26262 <celt_encode_with_ec+0xd9a>
      comb_filter(in+c*(N+overlap)+overlap+offset, pre[c]+COMBFILTER_MAXPERIOD+offset,
   25aa6:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
   25aaa:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
   25aae:	e9cd b206 	strd	fp, r2, [sp, #24]
   25ab2:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
   25ab6:	6b52      	ldr	r2, [r2, #52]	; 0x34
   25ab8:	9205      	str	r2, [sp, #20]
   25aba:	ebaa 0205 	sub.w	r2, sl, r5
   25abe:	9200      	str	r2, [sp, #0]
   25ac0:	f505 6c80 	add.w	ip, r5, #1024	; 0x400
   25ac4:	eb05 0e0b 	add.w	lr, r5, fp
   25ac8:	f8d7 50ac 	ldr.w	r5, [r7, #172]	; 0xac
   25acc:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
   25ad0:	e9cd 0503 	strd	r0, r5, [sp, #12]
   25ad4:	f8d7 0098 	ldr.w	r0, [r7, #152]	; 0x98
   25ad8:	e9cd 4001 	strd	r4, r0, [sp, #4]
   25adc:	f8d7 4104 	ldr.w	r4, [r7, #260]	; 0x104
   25ae0:	44b6      	add	lr, r6
   25ae2:	eb04 008e 	add.w	r0, r4, lr, lsl #2
   25ae6:	eb01 018c 	add.w	r1, r1, ip, lsl #2
   25aea:	f7fd ffe1 	bl	23ab0 <comb_filter>
      OPUS_COPY(st->in_mem+c*(overlap), in+c*(N+overlap)+N, overlap);
   25aee:	eb0a 0106 	add.w	r1, sl, r6
   25af2:	eb04 0181 	add.w	r1, r4, r1, lsl #2
   25af6:	f8d7 20cc 	ldr.w	r2, [r7, #204]	; 0xcc
   25afa:	f8d7 00b4 	ldr.w	r0, [r7, #180]	; 0xb4
   25afe:	f7e6 faff 	bl	c100 <memcpy>
         OPUS_MOVE(prefilter_mem+c*COMBFILTER_MAXPERIOD, prefilter_mem+c*COMBFILTER_MAXPERIOD+N, COMBFILTER_MAXPERIOD-N);
   25b02:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
         OPUS_COPY(prefilter_mem+c*COMBFILTER_MAXPERIOD, pre[c]+N, COMBFILTER_MAXPERIOD);
   25b06:	f8d7 4128 	ldr.w	r4, [r7, #296]	; 0x128
         OPUS_MOVE(prefilter_mem+c*COMBFILTER_MAXPERIOD, prefilter_mem+c*COMBFILTER_MAXPERIOD+N, COMBFILTER_MAXPERIOD-N);
   25b0a:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
   25b0e:	eb0a 0103 	add.w	r1, sl, r3
   25b12:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
         OPUS_COPY(prefilter_mem+c*COMBFILTER_MAXPERIOD, pre[c]+N, COMBFILTER_MAXPERIOD);
   25b16:	f507 70d0 	add.w	r0, r7, #416	; 0x1a0
         OPUS_MOVE(prefilter_mem+c*COMBFILTER_MAXPERIOD, prefilter_mem+c*COMBFILTER_MAXPERIOD+N, COMBFILTER_MAXPERIOD-N);
   25b1a:	eb03 0181 	add.w	r1, r3, r1, lsl #2
      if (N>COMBFILTER_MAXPERIOD)
   25b1e:	f5ba 6f80 	cmp.w	sl, #1024	; 0x400
   25b22:	eb03 3309 	add.w	r3, r3, r9, lsl #12
         OPUS_COPY(prefilter_mem+c*COMBFILTER_MAXPERIOD, pre[c]+N, COMBFILTER_MAXPERIOD);
   25b26:	4404      	add	r4, r0
         OPUS_MOVE(prefilter_mem+c*COMBFILTER_MAXPERIOD, prefilter_mem+c*COMBFILTER_MAXPERIOD+N, COMBFILTER_MAXPERIOD-N);
   25b28:	4618      	mov	r0, r3
      if (N>COMBFILTER_MAXPERIOD)
   25b2a:	dd19      	ble.n	25b60 <celt_encode_with_ec+0x698>
         OPUS_COPY(prefilter_mem+c*COMBFILTER_MAXPERIOD, pre[c]+N, COMBFILTER_MAXPERIOD);
   25b2c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
   25b30:	f854 1c34 	ldr.w	r1, [r4, #-52]
   25b34:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   25b38:	4419      	add	r1, r3
   25b3a:	f7e6 fae1 	bl	c100 <memcpy>
   } while (++c<CC);
   25b3e:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
   25b42:	f109 0901 	add.w	r9, r9, #1
   25b46:	454b      	cmp	r3, r9
   25b48:	dd29      	ble.n	25b9e <celt_encode_with_ec+0x6d6>
   25b4a:	f8d8 3048 	ldr.w	r3, [r8, #72]	; 0x48
   25b4e:	f8d8 1068 	ldr.w	r1, [r8, #104]	; 0x68
   25b52:	f9b8 406c 	ldrsh.w	r4, [r8, #108]	; 0x6c
   25b56:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
   25b5a:	f04f 0901 	mov.w	r9, #1
   25b5e:	e769      	b.n	25a34 <celt_encode_with_ec+0x56c>
         OPUS_MOVE(prefilter_mem+c*COMBFILTER_MAXPERIOD, prefilter_mem+c*COMBFILTER_MAXPERIOD+N, COMBFILTER_MAXPERIOD-N);
   25b60:	f00f fa9c 	bl	3509c <memmove>
         OPUS_COPY(prefilter_mem+c*COMBFILTER_MAXPERIOD+COMBFILTER_MAXPERIOD-N, pre[c]+COMBFILTER_MAXPERIOD, N);
   25b64:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
   25b68:	f507 72d0 	add.w	r2, r7, #416	; 0x1a0
   25b6c:	4413      	add	r3, r2
   25b6e:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
   25b72:	f853 1c34 	ldr.w	r1, [r3, #-52]
   25b76:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
   25b7a:	f502 6080 	add.w	r0, r2, #1024	; 0x400
   25b7e:	eba0 000a 	sub.w	r0, r0, sl
   25b82:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   25b86:	f501 5180 	add.w	r1, r1, #4096	; 0x1000
   25b8a:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
   25b8e:	f7e6 fab7 	bl	c100 <memcpy>
   } while (++c<CC);
   25b92:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
   25b96:	f109 0901 	add.w	r9, r9, #1
   25b9a:	454b      	cmp	r3, r9
   25b9c:	dcd5      	bgt.n	25b4a <celt_encode_with_ec+0x682>
   *pitch = pitch_index;
   25b9e:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
   25ba2:	66fb      	str	r3, [r7, #108]	; 0x6c
      if (pf_on==0)
   25ba4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   25ba6:	f8d7 d088 	ldr.w	sp, [r7, #136]	; 0x88
   25baa:	2b00      	cmp	r3, #0
   25bac:	f041 8633 	bne.w	27816 <celt_encode_with_ec+0x234e>
         if(!hybrid && tell+16<=total_bits)
   25bb0:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
   25bb4:	b96b      	cbnz	r3, 25bd2 <celt_encode_with_ec+0x70a>
   25bb6:	f8d7 10b0 	ldr.w	r1, [r7, #176]	; 0xb0
   25bba:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
   25bbe:	310f      	adds	r1, #15
   25bc0:	4299      	cmp	r1, r3
   25bc2:	da06      	bge.n	25bd2 <celt_encode_with_ec+0x70a>
            ec_enc_bit_logp(enc, 0, 1);
   25bc4:	2201      	movs	r2, #1
   25bc6:	f8d7 1120 	ldr.w	r1, [r7, #288]	; 0x120
   25bca:	f8d7 01cc 	ldr.w	r0, [r7, #460]	; 0x1cc
   25bce:	f004 f8eb 	bl	29da8 <ec_enc_bit_logp>
   if (st->complexity >= 1 && !st->lfe)
   25bd2:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
   25bd6:	6993      	ldr	r3, [r2, #24]
   25bd8:	2b00      	cmp	r3, #0
   25bda:	f341 8464 	ble.w	274a6 <celt_encode_with_ec+0x1fde>
   25bde:	4613      	mov	r3, r2
   25be0:	6c12      	ldr	r2, [r2, #64]	; 0x40
   25be2:	f8c7 2094 	str.w	r2, [r7, #148]	; 0x94
   25be6:	2a00      	cmp	r2, #0
   25be8:	f041 8646 	bne.w	27878 <celt_encode_with_ec+0x23b0>
   25bec:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
   25bf0:	0056      	lsls	r6, r2, #1
      int allow_weak_transients = hybrid && effectiveBytes<15 && st->silk_info.signalType != 2;
   25bf2:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
   25bf6:	2a00      	cmp	r2, #0
   25bf8:	f041 8762 	bne.w	27ac0 <celt_encode_with_ec+0x25f8>
   ALLOC(tmp, len, opus_val16);
   25bfc:	f106 0308 	add.w	r3, r6, #8
   25c00:	f023 0307 	bic.w	r3, r3, #7
{
   25c04:	f8c7 d088 	str.w	sp, [r7, #136]	; 0x88
   ALLOC(tmp, len, opus_val16);
   25c08:	ebad 0d03 	sub.w	sp, sp, r3
   25c0c:	2300      	movs	r3, #0
   25c0e:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
   25c12:	2308      	movs	r3, #8
   25c14:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
   int forward_shift = 4;
   25c18:	2304      	movs	r3, #4
   ALLOC(tmp, len, opus_val16);
   25c1a:	f10d 0850 	add.w	r8, sp, #80	; 0x50
   int forward_shift = 4;
   25c1e:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
   len2=len/2;
   25c22:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
   25c26:	eb03 71d3 	add.w	r1, r3, r3, lsr #31
   for (c=0;c<C;c++)
   25c2a:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
   len2=len/2;
   25c2e:	1048      	asrs	r0, r1, #1
   for (c=0;c<C;c++)
   25c30:	2b00      	cmp	r3, #0
   len2=len/2;
   25c32:	f8c7 00d0 	str.w	r0, [r7, #208]	; 0xd0
   for (c=0;c<C;c++)
   25c36:	f342 861d 	ble.w	28874 <celt_encode_with_ec+0x33ac>
      unmask = 64*unmask*4/(6*(len2-17));
   25c3a:	f1a0 0311 	sub.w	r3, r0, #17
   25c3e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   25c42:	0042      	lsls	r2, r0, #1
   25c44:	005b      	lsls	r3, r3, #1
   25c46:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
   25c4a:	eb08 0302 	add.w	r3, r8, r2
   25c4e:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
      for (i=len2-1;i>=0;i--)
   25c52:	1e43      	subs	r3, r0, #1
   25c54:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
      norm = SHL32(EXTEND32(len2),6+14)/ADD32(EPSILON,SHR32(mean,1));
   25c58:	0503      	lsls	r3, r0, #20
   25c5a:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
   25c5e:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
   int tf_chan = 0;
   25c62:	2400      	movs	r4, #0
   25c64:	3e02      	subs	r6, #2
   25c66:	f1a2 0a02 	sub.w	sl, r2, #2
      mean = MULT16_16(celt_sqrt(mean), celt_sqrt(MULT16_16(maxE,len2>>1)));
   25c6a:	f341 018f 	sbfx	r1, r1, #2, #16
   25c6e:	3b04      	subs	r3, #4
   int tf_chan = 0;
   25c70:	f8c7 409c 	str.w	r4, [r7, #156]	; 0x9c
   25c74:	4446      	add	r6, r8
      mean = MULT16_16(celt_sqrt(mean), celt_sqrt(MULT16_16(maxE,len2>>1)));
   25c76:	f8c7 10cc 	str.w	r1, [r7, #204]	; 0xcc
   25c7a:	44c2      	add	sl, r8
   for (c=0;c<C;c++)
   25c7c:	f8c7 40fc 	str.w	r4, [r7, #252]	; 0xfc
   opus_int32 mask_metric = 0;
   25c80:	f8c7 40dc 	str.w	r4, [r7, #220]	; 0xdc
      for (i=12;i<len2-5;i+=4)
   25c84:	f1a0 0905 	sub.w	r9, r0, #5
   25c88:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
      for (i=0;i<len;i++)
   25c8c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
   25c90:	2b00      	cmp	r3, #0
   25c92:	f341 8667 	ble.w	27964 <celt_encode_with_ec+0x249c>
   25c96:	f1a8 0c02 	sub.w	ip, r8, #2
      mem1=0;
   25c9a:	f04f 0b00 	mov.w	fp, #0
   25c9e:	46e6      	mov	lr, ip
      for (i=0;i<len;i++)
   25ca0:	4664      	mov	r4, ip
      mem0=0;
   25ca2:	4659      	mov	r1, fp
      for (i=0;i<len;i++)
   25ca4:	f8d7 5128 	ldr.w	r5, [r7, #296]	; 0x128
   25ca8:	e00b      	b.n	25cc2 <celt_encode_with_ec+0x7fa>
   25caa:	bf00      	nop
   25cac:	55555556 	.word	0x55555556
         tmp[i] = SROUND16(y, 2);
   25cb0:	4ac6      	ldr	r2, [pc, #792]	; (25fcc <celt_encode_with_ec+0xb04>)
   25cb2:	4293      	cmp	r3, r2
   25cb4:	f2c0 8160 	blt.w	25f78 <celt_encode_with_ec+0xab0>
   25cb8:	b21b      	sxth	r3, r3
   25cba:	f824 3f02 	strh.w	r3, [r4, #2]!
      for (i=0;i<len;i++)
   25cbe:	42a6      	cmp	r6, r4
   25cc0:	d013      	beq.n	25cea <celt_encode_with_ec+0x822>
         x = SHR32(in[i+c*len],SIG_SHIFT);
   25cc2:	f855 2f04 	ldr.w	r2, [r5, #4]!
   25cc6:	1312      	asrs	r2, r2, #12
         y = ADD32(mem0, x);
   25cc8:	1850      	adds	r0, r2, r1
         tmp[i] = SROUND16(y, 2);
   25cca:	1c83      	adds	r3, r0, #2
   25ccc:	109b      	asrs	r3, r3, #2
         mem0 = mem1 + y - SHL32(x,1);
   25cce:	4483      	add	fp, r0
         tmp[i] = SROUND16(y, 2);
   25cd0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
         mem0 = mem1 + y - SHL32(x,1);
   25cd4:	ebab 0142 	sub.w	r1, fp, r2, lsl #1
         mem1 = x - SHR32(y,1);
   25cd8:	eba2 0b60 	sub.w	fp, r2, r0, asr #1
         tmp[i] = SROUND16(y, 2);
   25cdc:	dbe8      	blt.n	25cb0 <celt_encode_with_ec+0x7e8>
   25cde:	f647 73ff 	movw	r3, #32767	; 0x7fff
   25ce2:	f824 3f02 	strh.w	r3, [r4, #2]!
      for (i=0;i<len;i++)
   25ce6:	42a6      	cmp	r6, r4
   25ce8:	d1eb      	bne.n	25cc2 <celt_encode_with_ec+0x7fa>
   opus_val16 minval = 0;
   25cea:	2200      	movs	r2, #0
      OPUS_CLEAR(tmp, 12);
   25cec:	f8c8 2000 	str.w	r2, [r8]
   25cf0:	f8c8 2004 	str.w	r2, [r8, #4]
   25cf4:	f8c8 2008 	str.w	r2, [r8, #8]
   25cf8:	f8c8 200c 	str.w	r2, [r8, #12]
   25cfc:	f8c8 2010 	str.w	r2, [r8, #16]
   25d00:	f8c8 2014 	str.w	r2, [r8, #20]
   opus_val16 maxval = 0;
   25d04:	4610      	mov	r0, r2
   25d06:	4663      	mov	r3, ip
      maxval = MAX16(maxval, x[i]);
   25d08:	f933 1f02 	ldrsh.w	r1, [r3, #2]!
   25d0c:	4288      	cmp	r0, r1
   25d0e:	bfb8      	it	lt
   25d10:	4608      	movlt	r0, r1
      minval = MIN16(minval, x[i]);
   25d12:	428a      	cmp	r2, r1
   25d14:	bfa8      	it	ge
   25d16:	460a      	movge	r2, r1
   for (i=0;i<len;i++)
   25d18:	429e      	cmp	r6, r3
   25d1a:	d1f5      	bne.n	25d08 <celt_encode_with_ec+0x840>
   return MAX32(EXTEND32(maxval),-EXTEND32(minval));
   25d1c:	4252      	negs	r2, r2
   25d1e:	4282      	cmp	r2, r0
   25d20:	bfb8      	it	lt
   25d22:	4602      	movlt	r2, r0
         shift = 14-celt_ilog2(MAX16(1, celt_maxabs16(tmp, len)));
   25d24:	2a00      	cmp	r2, #0
   25d26:	f040 8134 	bne.w	25f92 <celt_encode_with_ec+0xaca>
   25d2a:	230e      	movs	r3, #14
               tmp[i] = SHL16(tmp[i], shift);
   25d2c:	f83c 2f02 	ldrh.w	r2, [ip, #2]!
   25d30:	409a      	lsls	r2, r3
            for (i=0;i<len;i++)
   25d32:	4566      	cmp	r6, ip
               tmp[i] = SHL16(tmp[i], shift);
   25d34:	f8ac 2000 	strh.w	r2, [ip]
            for (i=0;i<len;i++)
   25d38:	d1f8      	bne.n	25d2c <celt_encode_with_ec+0x864>
      for (i=0;i<len2;i++)
   25d3a:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
   25d3e:	2b00      	cmp	r3, #0
   25d40:	f340 8141 	ble.w	25fc6 <celt_encode_with_ec+0xafe>
   25d44:	2200      	movs	r2, #0
   25d46:	f8d7 c0a4 	ldr.w	ip, [r7, #164]	; 0xa4
   25d4a:	f8d7 e098 	ldr.w	lr, [r7, #152]	; 0x98
   25d4e:	4610      	mov	r0, r2
   25d50:	f1a8 0402 	sub.w	r4, r8, #2
   25d54:	f108 0102 	add.w	r1, r8, #2
         opus_val16 x2 = PSHR32(MULT16_16(tmp[2*i],tmp[2*i]) + MULT16_16(tmp[2*i+1],tmp[2*i+1]),16);
   25d58:	f931 5c02 	ldrsh.w	r5, [r1, #-2]
   25d5c:	f931 3b04 	ldrsh.w	r3, [r1], #4
   25d60:	fb03 f303 	mul.w	r3, r3, r3
   25d64:	fb05 3505 	mla	r5, r5, r5, r3
   25d68:	f505 4500 	add.w	r5, r5, #32768	; 0x8000
         mean += x2;
   25d6c:	142d      	asrs	r5, r5, #16
         tmp[i] = mem0 + PSHR32(x2-mem0,forward_shift);
   25d6e:	1aab      	subs	r3, r5, r2
   25d70:	4473      	add	r3, lr
   25d72:	fa43 f30c 	asr.w	r3, r3, ip
   25d76:	441a      	add	r2, r3
   25d78:	b212      	sxth	r2, r2
   25d7a:	f824 2f02 	strh.w	r2, [r4, #2]!
      for (i=0;i<len2;i++)
   25d7e:	45a2      	cmp	sl, r4
         mean += x2;
   25d80:	4428      	add	r0, r5
      for (i=0;i<len2;i++)
   25d82:	d1e9      	bne.n	25d58 <celt_encode_with_ec+0x890>
      for (i=len2-1;i>=0;i--)
   25d84:	f8d7 10d8 	ldr.w	r1, [r7, #216]	; 0xd8
   25d88:	2900      	cmp	r1, #0
      maxE=0;
   25d8a:	f04f 0400 	mov.w	r4, #0
      for (i=len2-1;i>=0;i--)
   25d8e:	db16      	blt.n	25dbe <celt_encode_with_ec+0x8f6>
   25d90:	f8d7 50b4 	ldr.w	r5, [r7, #180]	; 0xb4
      mem0=0;
   25d94:	4623      	mov	r3, r4
         tmp[i] = mem0 + PSHR32(tmp[i]-mem0,3);
   25d96:	f935 2d02 	ldrsh.w	r2, [r5, #-2]!
   25d9a:	1ad2      	subs	r2, r2, r3
   25d9c:	3204      	adds	r2, #4
   25d9e:	eb03 03e2 	add.w	r3, r3, r2, asr #3
   25da2:	b21a      	sxth	r2, r3
         maxE = MAX16(maxE, mem0);
   25da4:	4294      	cmp	r4, r2
      for (i=len2-1;i>=0;i--)
   25da6:	f101 31ff 	add.w	r1, r1, #4294967295	; 0xffffffff
         mem0 = tmp[i];
   25daa:	4613      	mov	r3, r2
         tmp[i] = mem0 + PSHR32(tmp[i]-mem0,3);
   25dac:	802a      	strh	r2, [r5, #0]
         maxE = MAX16(maxE, mem0);
   25dae:	bfb8      	it	lt
   25db0:	4614      	movlt	r4, r2
      for (i=len2-1;i>=0;i--)
   25db2:	1c4a      	adds	r2, r1, #1
   25db4:	d1ef      	bne.n	25d96 <celt_encode_with_ec+0x8ce>
   25db6:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
   25dba:	fb03 f404 	mul.w	r4, r3, r4
      mean = MULT16_16(celt_sqrt(mean), celt_sqrt(MULT16_16(maxE,len2>>1)));
   25dbe:	f005 fb5b 	bl	2b478 <celt_sqrt>
   25dc2:	4605      	mov	r5, r0
   25dc4:	4620      	mov	r0, r4
   25dc6:	f005 fb57 	bl	2b478 <celt_sqrt>
   25dca:	fb15 f000 	smulbb	r0, r5, r0
      norm = SHL32(EXTEND32(len2),6+14)/ADD32(EPSILON,SHR32(mean,1));
   25dce:	1040      	asrs	r0, r0, #1
      for (i=12;i<len2-5;i+=4)
   25dd0:	f1b9 0f0c 	cmp.w	r9, #12
      norm = SHL32(EXTEND32(len2),6+14)/ADD32(EPSILON,SHR32(mean,1));
   25dd4:	f100 0001 	add.w	r0, r0, #1
   25dd8:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
   25ddc:	fb93 f0f0 	sdiv	r0, r3, r0
      for (i=12;i<len2-5;i+=4)
   25de0:	dd25      	ble.n	25e2e <celt_encode_with_ec+0x966>
         id = MAX32(0,MIN32(127,MULT16_32_Q15(tmp[i]+EPSILON,norm))); /* Do not round to nearest */
   25de2:	1405      	asrs	r5, r0, #16
      unmask=0;
   25de4:	2400      	movs	r4, #0
   25de6:	b280      	uxth	r0, r0
      for (i=12;i<len2-5;i+=4)
   25de8:	210c      	movs	r1, #12
         id = MAX32(0,MIN32(127,MULT16_32_Q15(tmp[i]+EPSILON,norm))); /* Do not round to nearest */
   25dea:	f838 3011 	ldrh.w	r3, [r8, r1, lsl #1]
   25dee:	3301      	adds	r3, #1
   25df0:	b21b      	sxth	r3, r3
   25df2:	fb00 f203 	mul.w	r2, r0, r3
   25df6:	13d2      	asrs	r2, r2, #15
   25df8:	fb05 f303 	mul.w	r3, r5, r3
   25dfc:	eb02 0343 	add.w	r3, r2, r3, lsl #1
         unmask += inv_table[id];
   25e00:	f383 0307 	usat	r3, #7, r3
   25e04:	4a72      	ldr	r2, [pc, #456]	; (25fd0 <celt_encode_with_ec+0xb08>)
      for (i=12;i<len2-5;i+=4)
   25e06:	3104      	adds	r1, #4
         unmask += inv_table[id];
   25e08:	5cd3      	ldrb	r3, [r2, r3]
      for (i=12;i<len2-5;i+=4)
   25e0a:	4549      	cmp	r1, r9
         unmask += inv_table[id];
   25e0c:	441c      	add	r4, r3
      for (i=12;i<len2-5;i+=4)
   25e0e:	dbec      	blt.n	25dea <celt_encode_with_ec+0x922>
   25e10:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
   25e14:	0224      	lsls	r4, r4, #8
   25e16:	fb94 f4f3 	sdiv	r4, r4, r3
      if (unmask>mask_metric)
   25e1a:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
   25e1e:	42a3      	cmp	r3, r4
   25e20:	da05      	bge.n	25e2e <celt_encode_with_ec+0x966>
   25e22:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
   25e26:	f8c7 40dc 	str.w	r4, [r7, #220]	; 0xdc
   25e2a:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
   25e2e:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
   25e32:	f8d7 1118 	ldr.w	r1, [r7, #280]	; 0x118
   for (c=0;c<C;c++)
   25e36:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
   25e3a:	440a      	add	r2, r1
   25e3c:	f8c7 2128 	str.w	r2, [r7, #296]	; 0x128
   25e40:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
   25e44:	3301      	adds	r3, #1
   25e46:	429a      	cmp	r2, r3
   25e48:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
   25e4c:	f47f af1e 	bne.w	25c8c <celt_encode_with_ec+0x7c4>
   25e50:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
   is_transient = mask_metric>200;
   25e54:	2bc8      	cmp	r3, #200	; 0xc8
   25e56:	461a      	mov	r2, r3
   25e58:	bfd4      	ite	le
   25e5a:	2200      	movle	r2, #0
   25e5c:	2201      	movgt	r2, #1
   25e5e:	f8c7 2118 	str.w	r2, [r7, #280]	; 0x118
   if (allow_weak_transients && is_transient && mask_metric<600) {
   25e62:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
   25e66:	eb03 0443 	add.w	r4, r3, r3, lsl #1
   25e6a:	eb04 04c4 	add.w	r4, r4, r4, lsl #3
   25e6e:	b14a      	cbz	r2, 25e84 <celt_encode_with_ec+0x9bc>
   25e70:	2bc8      	cmp	r3, #200	; 0xc8
   25e72:	f342 84f8 	ble.w	28866 <celt_encode_with_ec+0x339e>
   25e76:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
   25e7a:	f282 8513 	bge.w	288a4 <celt_encode_with_ec+0x33dc>
      is_transient = 0;
   25e7e:	2300      	movs	r3, #0
   25e80:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
   tf_max = MAX16(0,celt_sqrt(27*mask_metric)-42);
   25e84:	4620      	mov	r0, r4
   25e86:	f005 faf7 	bl	2b478 <celt_sqrt>
   25e8a:	2829      	cmp	r0, #41	; 0x29
   25e8c:	dd16      	ble.n	25ebc <celt_encode_with_ec+0x9f4>
   25e8e:	4620      	mov	r0, r4
   25e90:	f005 faf2 	bl	2b478 <celt_sqrt>
   25e94:	f1a0 032a 	sub.w	r3, r0, #42	; 0x2a
   25e98:	b21b      	sxth	r3, r3
   25e9a:	2ba3      	cmp	r3, #163	; 0xa3
   25e9c:	bfa8      	it	ge
   25e9e:	23a3      	movge	r3, #163	; 0xa3
   25ea0:	ebc3 02c3 	rsb	r2, r3, r3, lsl #3
   25ea4:	eb03 1302 	add.w	r3, r3, r2, lsl #4
   25ea8:	4a4a      	ldr	r2, [pc, #296]	; (25fd4 <celt_encode_with_ec+0xb0c>)
   25eaa:	039b      	lsls	r3, r3, #14
   25eac:	4293      	cmp	r3, r2
   25eae:	bfac      	ite	ge
   25eb0:	ebc2 0203 	rsbge	r2, r2, r3
   25eb4:	ebc2 0202 	rsblt	r2, r2, r2
   25eb8:	f8c7 2094 	str.w	r2, [r7, #148]	; 0x94
   *tf_estimate = celt_sqrt(MAX32(0, SHL32(MULT16_16(QCONST16(0.0069,14),MIN16(163,tf_max)),14)-QCONST32(0.139,28)));
   25ebc:	f8d7 0094 	ldr.w	r0, [r7, #148]	; 0x94
   25ec0:	f005 fada 	bl	2b478 <celt_sqrt>
   25ec4:	b203      	sxth	r3, r0
   25ec6:	f8d7 d088 	ldr.w	sp, [r7, #136]	; 0x88
   25eca:	f8d7 612c 	ldr.w	r6, [r7, #300]	; 0x12c
   25ece:	65bb      	str	r3, [r7, #88]	; 0x58
   25ed0:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	; 0x80
   25ed4:	f8d7 1114 	ldr.w	r1, [r7, #276]	; 0x114
   25ed8:	6cb4      	ldr	r4, [r6, #72]	; 0x48
   25eda:	1a9b      	subs	r3, r3, r2
   25edc:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
   25ee0:	fb02 f201 	mul.w	r2, r2, r1
   25ee4:	f8c7 20c0 	str.w	r2, [r7, #192]	; 0xc0
   25ee8:	0052      	lsls	r2, r2, #1
   25eea:	f8c7 2088 	str.w	r2, [r7, #136]	; 0x88
   25eee:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
   25ef2:	69f1      	ldr	r1, [r6, #28]
   25ef4:	0095      	lsls	r5, r2, #2
   if (LM>0 && ec_tell(enc)+3<=total_bits)
   25ef6:	f8d7 210c 	ldr.w	r2, [r7, #268]	; 0x10c
   25efa:	009b      	lsls	r3, r3, #2
   25efc:	2a00      	cmp	r2, #0
   25efe:	d06b      	beq.n	25fd8 <celt_encode_with_ec+0xb10>
   25f00:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
   25f04:	f8d7 01cc 	ldr.w	r0, [r7, #460]	; 0x1cc
   25f08:	69d2      	ldr	r2, [r2, #28]
   25f0a:	6940      	ldr	r0, [r0, #20]
   25f0c:	fab2 f282 	clz	r2, r2
   25f10:	4402      	add	r2, r0
   25f12:	f8d7 00e0 	ldr.w	r0, [r7, #224]	; 0xe0
   25f16:	3a1e      	subs	r2, #30
   25f18:	4282      	cmp	r2, r0
   25f1a:	da5d      	bge.n	25fd8 <celt_encode_with_ec+0xb10>
      if (isTransient)
   25f1c:	f8d7 2118 	ldr.w	r2, [r7, #280]	; 0x118
   25f20:	2a00      	cmp	r2, #0
   25f22:	f001 85ec 	beq.w	27afe <celt_encode_with_ec+0x2636>
   ALLOC(freq, CC*N, celt_sig); /**< Interleaved signal MDCTs */
   25f26:	330a      	adds	r3, #10
   25f28:	f023 0307 	bic.w	r3, r3, #7
   25f2c:	ebad 0d03 	sub.w	sp, sp, r3
   ALLOC(bandE,nbEBands*CC, celt_ener);
   25f30:	f105 020a 	add.w	r2, r5, #10
   ALLOC(bandLogE,nbEBands*CC, opus_val16);
   25f34:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
   ALLOC(bandE,nbEBands*CC, celt_ener);
   25f38:	f022 0207 	bic.w	r2, r2, #7
   ALLOC(freq, CC*N, celt_sig); /**< Interleaved signal MDCTs */
   25f3c:	a814      	add	r0, sp, #80	; 0x50
   ALLOC(bandLogE,nbEBands*CC, opus_val16);
   25f3e:	3308      	adds	r3, #8
   ALLOC(bandE,nbEBands*CC, celt_ener);
   25f40:	ebad 0d02 	sub.w	sp, sp, r2
   25f44:	aa14      	add	r2, sp, #80	; 0x50
   ALLOC(bandLogE,nbEBands*CC, opus_val16);
   25f46:	f023 0307 	bic.w	r3, r3, #7
   ALLOC(bandE,nbEBands*CC, celt_ener);
   25f4a:	f8c7 20d4 	str.w	r2, [r7, #212]	; 0xd4
   ALLOC(bandLogE,nbEBands*CC, opus_val16);
   25f4e:	ebad 0d03 	sub.w	sp, sp, r3
   secondMdct = shortBlocks && st->complexity>=8;
   25f52:	6f7a      	ldr	r2, [r7, #116]	; 0x74
   ALLOC(freq, CC*N, celt_sig); /**< Interleaved signal MDCTs */
   25f54:	f8c7 00dc 	str.w	r0, [r7, #220]	; 0xdc
   ALLOC(bandLogE,nbEBands*CC, opus_val16);
   25f58:	ab14      	add	r3, sp, #80	; 0x50
   25f5a:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
   secondMdct = shortBlocks && st->complexity>=8;
   25f5e:	2a00      	cmp	r2, #0
   25f60:	f002 8787 	beq.w	28e72 <celt_encode_with_ec+0x39aa>
   25f64:	69b3      	ldr	r3, [r6, #24]
   25f66:	2b07      	cmp	r3, #7
   25f68:	f301 871e 	bgt.w	27da8 <celt_encode_with_ec+0x28e0>
   int transient_got_disabled=0;
   25f6c:	2300      	movs	r3, #0
   25f6e:	f8c7 20b0 	str.w	r2, [r7, #176]	; 0xb0
   25f72:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
   25f76:	e052      	b.n	2601e <celt_encode_with_ec+0xb56>
         tmp[i] = SROUND16(y, 2);
   25f78:	4b14      	ldr	r3, [pc, #80]	; (25fcc <celt_encode_with_ec+0xb04>)
   25f7a:	e69e      	b.n	25cba <celt_encode_with_ec+0x7f2>
      enabled = ((st->lfe&&nbAvailableBytes>3) || nbAvailableBytes>12*C) && !hybrid && !silence && !st->disable_pf
   25f7c:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
   25f80:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
   25f84:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   25f88:	ebb2 0f83 	cmp.w	r2, r3, lsl #2
   25f8c:	f77f ac82 	ble.w	25894 <celt_encode_with_ec+0x3cc>
   25f90:	e478      	b.n	25884 <celt_encode_with_ec+0x3bc>
         shift = 14-celt_ilog2(MAX16(1, celt_maxabs16(tmp, len)));
   25f92:	2200      	movs	r2, #0
   25f94:	4610      	mov	r0, r2
      maxval = MAX16(maxval, x[i]);
   25f96:	f93e 1f02 	ldrsh.w	r1, [lr, #2]!
   25f9a:	4288      	cmp	r0, r1
   25f9c:	bfb8      	it	lt
   25f9e:	4608      	movlt	r0, r1
      minval = MIN16(minval, x[i]);
   25fa0:	428a      	cmp	r2, r1
   25fa2:	bfa8      	it	ge
   25fa4:	460a      	movge	r2, r1
   for (i=0;i<len;i++)
   25fa6:	4573      	cmp	r3, lr
   25fa8:	d1f5      	bne.n	25f96 <celt_encode_with_ec+0xace>
   return MAX32(EXTEND32(maxval),-EXTEND32(minval));
   25faa:	4253      	negs	r3, r2
   25fac:	4298      	cmp	r0, r3
   25fae:	bfb8      	it	lt
   25fb0:	4618      	movlt	r0, r3
   return EC_ILOG(x)-1;
   25fb2:	fab0 f380 	clz	r3, r0
         if (shift!=0)
   25fb6:	3b11      	subs	r3, #17
   25fb8:	f47f aeb8 	bne.w	25d2c <celt_encode_with_ec+0x864>
      for (i=0;i<len2;i++)
   25fbc:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
   25fc0:	2b00      	cmp	r3, #0
   25fc2:	f73f aebf 	bgt.w	25d44 <celt_encode_with_ec+0x87c>
   25fc6:	2000      	movs	r0, #0
   25fc8:	e6dc      	b.n	25d84 <celt_encode_with_ec+0x8bc>
   25fca:	bf00      	nop
   25fcc:	ffff8001 	.word	0xffff8001
   25fd0:	000379e8 	.word	0x000379e8
   25fd4:	02395810 	.word	0x02395810
      transient_got_disabled=1;
   25fd8:	2201      	movs	r2, #1
   25fda:	f8c7 2094 	str.w	r2, [r7, #148]	; 0x94
   ALLOC(freq, CC*N, celt_sig); /**< Interleaved signal MDCTs */
   25fde:	330a      	adds	r3, #10
   25fe0:	f023 0207 	bic.w	r2, r3, #7
   25fe4:	ebad 0d02 	sub.w	sp, sp, r2
   ALLOC(bandLogE,nbEBands*CC, opus_val16);
   25fe8:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
   ALLOC(bandE,nbEBands*CC, celt_ener);
   25fec:	f105 030a 	add.w	r3, r5, #10
   25ff0:	f023 0307 	bic.w	r3, r3, #7
   ALLOC(bandLogE,nbEBands*CC, opus_val16);
   25ff4:	3208      	adds	r2, #8
   ALLOC(freq, CC*N, celt_sig); /**< Interleaved signal MDCTs */
   25ff6:	a814      	add	r0, sp, #80	; 0x50
   ALLOC(bandLogE,nbEBands*CC, opus_val16);
   25ff8:	f022 0207 	bic.w	r2, r2, #7
   ALLOC(bandE,nbEBands*CC, celt_ener);
   25ffc:	ebad 0d03 	sub.w	sp, sp, r3
   26000:	ab14      	add	r3, sp, #80	; 0x50
   ALLOC(bandLogE,nbEBands*CC, opus_val16);
   26002:	ebad 0d02 	sub.w	sp, sp, r2
   ALLOC(bandE,nbEBands*CC, celt_ener);
   26006:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
   ALLOC(bandLogE,nbEBands*CC, opus_val16);
   2600a:	aa14      	add	r2, sp, #80	; 0x50
   2600c:	2300      	movs	r3, #0
   ALLOC(freq, CC*N, celt_sig); /**< Interleaved signal MDCTs */
   2600e:	f8c7 00dc 	str.w	r0, [r7, #220]	; 0xdc
   ALLOC(bandLogE,nbEBands*CC, opus_val16);
   26012:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
   26016:	f8c7 20d8 	str.w	r2, [r7, #216]	; 0xd8
   2601a:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
   ALLOC(bandLogE2, C*nbEBands, opus_val16);
   2601e:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
   26022:	3308      	adds	r3, #8
   26024:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
   26028:	f023 0307 	bic.w	r3, r3, #7
   2602c:	ebad 0d03 	sub.w	sp, sp, r3
   26030:	ab14      	add	r3, sp, #80	; 0x50
   26032:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
   26036:	2300      	movs	r3, #0
   26038:	65fb      	str	r3, [r7, #92]	; 0x5c
   compute_mdcts(mode, shortBlocks, in, freq, C, CC, LM, st->upsample, st->arch);
   2603a:	e9cd 1403 	strd	r1, r4, [sp, #12]
   2603e:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
   26042:	9302      	str	r3, [sp, #8]
   26044:	f8d7 4108 	ldr.w	r4, [r7, #264]	; 0x108
   26048:	9401      	str	r4, [sp, #4]
   2604a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
   2604e:	9300      	str	r3, [sp, #0]
   26050:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
   26054:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
   26058:	f8d7 10b0 	ldr.w	r1, [r7, #176]	; 0xb0
   2605c:	f8d7 0100 	ldr.w	r0, [r7, #256]	; 0x100
   26060:	f7fe f806 	bl	24070 <compute_mdcts>
   if (CC==2&&C==1)
   26064:	2c02      	cmp	r4, #2
   26066:	d108      	bne.n	2607a <celt_encode_with_ec+0xbb2>
      tf_chan = 0;
   26068:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
   2606c:	2b01      	cmp	r3, #1
   2606e:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
   26072:	bf08      	it	eq
   26074:	2300      	moveq	r3, #0
   26076:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
   compute_band_energies(mode, freq, bandE, effEnd, C, LM, st->arch);
   2607a:	f8d7 412c 	ldr.w	r4, [r7, #300]	; 0x12c
   2607e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   26080:	9302      	str	r3, [sp, #8]
   26082:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
   26086:	9301      	str	r3, [sp, #4]
   26088:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
   2608c:	9300      	str	r3, [sp, #0]
   2608e:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
   26092:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
   26096:	f8d7 10dc 	ldr.w	r1, [r7, #220]	; 0xdc
   2609a:	f8d7 0100 	ldr.w	r0, [r7, #256]	; 0x100
   2609e:	f7fb ffeb 	bl	22078 <compute_band_energies>
   if (st->lfe)
   260a2:	6c23      	ldr	r3, [r4, #64]	; 0x40
   260a4:	b1fb      	cbz	r3, 260e6 <celt_encode_with_ec+0xc1e>
      for (i=2;i<end;i++)
   260a6:	f8d7 5124 	ldr.w	r5, [r7, #292]	; 0x124
   260aa:	2d02      	cmp	r5, #2
   260ac:	dd1b      	ble.n	260e6 <celt_encode_with_ec+0xc1e>
   260ae:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
   260b2:	f852 4b04 	ldr.w	r4, [r2], #4
         bandE[i] = IMIN(bandE[i], MULT16_32_Q15(QCONST16(1e-4f,15),bandE[0]));
   260b6:	b2a3      	uxth	r3, r4
   260b8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   260bc:	1424      	asrs	r4, r4, #16
   260be:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   260c2:	13d8      	asrs	r0, r3, #15
   260c4:	eb00 0044 	add.w	r0, r0, r4, lsl #1
      for (i=2;i<end;i++)
   260c8:	2102      	movs	r1, #2
         bandE[i] = IMIN(bandE[i], MULT16_32_Q15(QCONST16(1e-4f,15),bandE[0]));
   260ca:	462c      	mov	r4, r5
   260cc:	f852 3f04 	ldr.w	r3, [r2, #4]!
   260d0:	4283      	cmp	r3, r0
   260d2:	bfa8      	it	ge
   260d4:	4603      	movge	r3, r0
         bandE[i] = MAX32(bandE[i], EPSILON);
   260d6:	2b01      	cmp	r3, #1
      for (i=2;i<end;i++)
   260d8:	f101 0101 	add.w	r1, r1, #1
         bandE[i] = MAX32(bandE[i], EPSILON);
   260dc:	bfb8      	it	lt
   260de:	2301      	movlt	r3, #1
      for (i=2;i<end;i++)
   260e0:	428c      	cmp	r4, r1
         bandE[i] = MAX32(bandE[i], EPSILON);
   260e2:	6013      	str	r3, [r2, #0]
      for (i=2;i<end;i++)
   260e4:	d1f2      	bne.n	260cc <celt_encode_with_ec+0xc04>
   amp2Log2(mode, effEnd, end, bandE, bandLogE, C);
   260e6:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
   260ea:	9301      	str	r3, [sp, #4]
   260ec:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
   260f0:	9300      	str	r3, [sp, #0]
   260f2:	f8d7 4124 	ldr.w	r4, [r7, #292]	; 0x124
   260f6:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
   260fa:	f8d7 10e4 	ldr.w	r1, [r7, #228]	; 0xe4
   260fe:	f8d7 0100 	ldr.w	r0, [r7, #256]	; 0x100
   26102:	4622      	mov	r2, r4
   26104:	f007 f9b8 	bl	2d478 <amp2Log2>
   ALLOC(surround_dynalloc, C*nbEBands, opus_val16);
   26108:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   2610c:	f023 0307 	bic.w	r3, r3, #7
   26110:	ebad 0d03 	sub.w	sp, sp, r3
   OPUS_CLEAR(surround_dynalloc, end);
   26114:	0063      	lsls	r3, r4, #1
   ALLOC(surround_dynalloc, C*nbEBands, opus_val16);
   26116:	a814      	add	r0, sp, #80	; 0x50
   OPUS_CLEAR(surround_dynalloc, end);
   26118:	461a      	mov	r2, r3
   2611a:	2100      	movs	r1, #0
   2611c:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
   ALLOC(surround_dynalloc, C*nbEBands, opus_val16);
   26120:	f8c7 0098 	str.w	r0, [r7, #152]	; 0x98
   OPUS_CLEAR(surround_dynalloc, end);
   26124:	f00f f81e 	bl	35164 <memset>
   if (!hybrid&&st->energy_mask&&!st->lfe)
   26128:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
   2612c:	2b00      	cmp	r3, #0
   2612e:	f040 80c4 	bne.w	262ba <celt_encode_with_ec+0xdf2>
   26132:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
   26136:	f8d3 10ec 	ldr.w	r1, [r3, #236]	; 0xec
   2613a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
   2613c:	f8c7 10a4 	str.w	r1, [r7, #164]	; 0xa4
   26140:	f8c7 20b4 	str.w	r2, [r7, #180]	; 0xb4
   26144:	2900      	cmp	r1, #0
   26146:	f000 80bd 	beq.w	262c4 <celt_encode_with_ec+0xdfc>
   2614a:	2a00      	cmp	r2, #0
   2614c:	f041 8479 	bne.w	27a42 <celt_encode_with_ec+0x257a>
      mask_end = IMAX(2,st->lastCodedBands);
   26150:	6dda      	ldr	r2, [r3, #92]	; 0x5c
   26152:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
   26156:	647a      	str	r2, [r7, #68]	; 0x44
   26158:	2a02      	cmp	r2, #2
   2615a:	bfb8      	it	lt
   2615c:	2202      	movlt	r2, #2
   2615e:	1e53      	subs	r3, r2, #1
   26160:	fb00 f303 	mul.w	r3, r0, r3
   26164:	fb02 3303 	mla	r3, r2, r3, r3
   26168:	fb02 f303 	mul.w	r3, r2, r3
      for (c=0;c<C;c++)
   2616c:	2800      	cmp	r0, #0
      mask_end = IMAX(2,st->lastCodedBands);
   2616e:	64ba      	str	r2, [r7, #72]	; 0x48
   26170:	633b      	str	r3, [r7, #48]	; 0x30
      for (c=0;c<C;c++)
   26172:	f342 8444 	ble.w	289fe <celt_encode_with_ec+0x3536>
   26176:	b293      	uxth	r3, r2
   26178:	f1c3 0101 	rsb	r1, r3, #1
   2617c:	3a03      	subs	r2, #3
   2617e:	f1c3 0303 	rsb	r3, r3, #3
   26182:	b29b      	uxth	r3, r3
   26184:	f022 0201 	bic.w	r2, r2, #1
   26188:	637b      	str	r3, [r7, #52]	; 0x34
   2618a:	1c93      	adds	r3, r2, #2
   2618c:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
   26190:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
            mask = MAX16(MIN16(st->energy_mask[nbEBands*c+i],
   26194:	f8df b350 	ldr.w	fp, [pc, #848]	; 264e8 <celt_encode_with_ec+0x1020>
      for (c=0;c<C;c++)
   26198:	663b      	str	r3, [r7, #96]	; 0x60
   2619a:	b289      	uxth	r1, r1
   2619c:	6439      	str	r1, [r7, #64]	; 0x40
      int count=0;
   2619e:	469c      	mov	ip, r3
      for (c=0;c<C;c++)
   261a0:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
      opus_val32 mask_avg=0;
   261a4:	4619      	mov	r1, r3
   261a6:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   261a8:	2a02      	cmp	r2, #2
   261aa:	f342 82cf 	ble.w	2874c <celt_encode_with_ec+0x3284>
   261ae:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
   261b2:	f8d7 00d0 	ldr.w	r0, [r7, #208]	; 0xd0
   261b6:	f8d7 e034 	ldr.w	lr, [r7, #52]	; 0x34
   261ba:	f102 0802 	add.w	r8, r2, #2
   261be:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
         for(i=0;i<mask_end;i++)
   261c2:	2500      	movs	r5, #0
   261c4:	f9b2 6000 	ldrsh.w	r6, [r2]
   261c8:	eb08 0840 	add.w	r8, r8, r0, lsl #1
   261cc:	4691      	mov	r9, r2
   261ce:	46aa      	mov	sl, r5
   261d0:	e041      	b.n	26256 <celt_encode_with_ec+0xd8e>
            mask = MAX16(MIN16(st->energy_mask[nbEBands*c+i],
   261d2:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
   261d6:	4614      	mov	r4, r2
   261d8:	bfa8      	it	ge
   261da:	f44f 7480 	movge.w	r4, #256	; 0x100
            if (mask > 0)
   261de:	2a00      	cmp	r2, #0
   261e0:	dd00      	ble.n	261e4 <celt_encode_with_ec+0xd1c>
   261e2:	1064      	asrs	r4, r4, #1
            mask_avg += MULT16_16(mask, eBands[i+1]-eBands[i]);
   261e4:	f9b9 0002 	ldrsh.w	r0, [r9, #2]
            mask = MAX16(MIN16(st->energy_mask[nbEBands*c+i],
   261e8:	f9b8 2000 	ldrsh.w	r2, [r8]
   261ec:	f8c7 2128 	str.w	r2, [r7, #296]	; 0x128
            mask_avg += MULT16_16(mask, eBands[i+1]-eBands[i]);
   261f0:	b282      	uxth	r2, r0
   261f2:	1b95      	subs	r5, r2, r6
   261f4:	b22d      	sxth	r5, r5
   261f6:	fb04 1105 	mla	r1, r4, r5, r1
            diff += MULT16_16(mask, 1+2*i-mask_end);
   261fa:	f1ae 0502 	sub.w	r5, lr, #2
   261fe:	b22d      	sxth	r5, r5
   26200:	fb04 3305 	mla	r3, r4, r5, r3
            mask = MAX16(MIN16(st->energy_mask[nbEBands*c+i],
   26204:	f8d7 4128 	ldr.w	r4, [r7, #296]	; 0x128
            count += eBands[i+1]-eBands[i];
   26208:	1b86      	subs	r6, r0, r6
            mask = MAX16(MIN16(st->energy_mask[nbEBands*c+i],
   2620a:	455c      	cmp	r4, fp
            count += eBands[i+1]-eBands[i];
   2620c:	44b4      	add	ip, r6
            mask = MAX16(MIN16(st->energy_mask[nbEBands*c+i],
   2620e:	4625      	mov	r5, r4
   26210:	f2c1 8518 	blt.w	27c44 <celt_encode_with_ec+0x277c>
   26214:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
   26218:	bfa8      	it	ge
   2621a:	f44f 7580 	movge.w	r5, #256	; 0x100
            if (mask > 0)
   2621e:	2c00      	cmp	r4, #0
   26220:	dd00      	ble.n	26224 <celt_encode_with_ec+0xd5c>
   26222:	106d      	asrs	r5, r5, #1
            mask_avg += MULT16_16(mask, eBands[i+1]-eBands[i]);
   26224:	f939 6f04 	ldrsh.w	r6, [r9, #4]!
   26228:	1ab2      	subs	r2, r6, r2
   2622a:	b212      	sxth	r2, r2
   2622c:	fb05 1102 	mla	r1, r5, r2, r1
   26230:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
   26234:	f10a 0a02 	add.w	sl, sl, #2
            diff += MULT16_16(mask, 1+2*i-mask_end);
   26238:	fa0f f48e 	sxth.w	r4, lr
            count += eBands[i+1]-eBands[i];
   2623c:	1a30      	subs	r0, r6, r0
   2623e:	f10e 0e04 	add.w	lr, lr, #4
   26242:	4552      	cmp	r2, sl
   26244:	f108 0804 	add.w	r8, r8, #4
   26248:	4484      	add	ip, r0
            diff += MULT16_16(mask, 1+2*i-mask_end);
   2624a:	fb05 3304 	mla	r3, r5, r4, r3
   2624e:	fa1f fe8e 	uxth.w	lr, lr
   26252:	f001 84fa 	beq.w	27c4a <celt_encode_with_ec+0x2782>
            mask = MAX16(MIN16(st->energy_mask[nbEBands*c+i],
   26256:	f938 2c02 	ldrsh.w	r2, [r8, #-2]
   2625a:	455a      	cmp	r2, fp
   2625c:	dab9      	bge.n	261d2 <celt_encode_with_ec+0xd0a>
   2625e:	4c9f      	ldr	r4, [pc, #636]	; (264dc <celt_encode_with_ec+0x1014>)
   26260:	e7c0      	b.n	261e4 <celt_encode_with_ec+0xd1c>
         comb_filter(in+c*(N+overlap)+overlap, pre[c]+COMBFILTER_MAXPERIOD,
   26262:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
   26266:	9207      	str	r2, [sp, #28]
   26268:	2200      	movs	r2, #0
   2626a:	e9cd 0003 	strd	r0, r0, [sp, #12]
   2626e:	e9cd 4401 	strd	r4, r4, [sp, #4]
   26272:	e9cd 2205 	strd	r2, r2, [sp, #20]
   26276:	9500      	str	r5, [sp, #0]
   26278:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
   2627c:	eb06 030b 	add.w	r3, r6, fp
   26280:	eb02 0083 	add.w	r0, r2, r3, lsl #2
   26284:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
   26288:	f501 5180 	add.w	r1, r1, #4096	; 0x1000
   2628c:	461a      	mov	r2, r3
   2628e:	f7fd fc0f 	bl	23ab0 <comb_filter>
   26292:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
   26296:	f8b8 406c 	ldrh.w	r4, [r8, #108]	; 0x6c
   2629a:	f853 1c34 	ldr.w	r1, [r3, #-52]
   2629e:	f8d8 3068 	ldr.w	r3, [r8, #104]	; 0x68
   262a2:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
   262a6:	4264      	negs	r4, r4
   262a8:	f8d8 3048 	ldr.w	r3, [r8, #72]	; 0x48
   262ac:	f8d8 0070 	ldr.w	r0, [r8, #112]	; 0x70
   262b0:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
   262b4:	b224      	sxth	r4, r4
   262b6:	f7ff bbf6 	b.w	25aa6 <celt_encode_with_ec+0x5de>
   262ba:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
   262be:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   262c0:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
   if (!st->lfe)
   262c4:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
   262c8:	2b00      	cmp	r3, #0
   262ca:	f041 82cf 	bne.w	2786c <celt_encode_with_ec+0x23a4>
   262ce:	e9c7 330a 	strd	r3, r3, [r7, #40]	; 0x28
      opus_val16 offset = shortBlocks?HALF16(SHL16(LM, DB_SHIFT)):0;
   262d2:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
   262d6:	2b00      	cmp	r3, #0
   262d8:	f001 835f 	beq.w	2799a <celt_encode_with_ec+0x24d2>
   262dc:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
   262e0:	f343 0405 	sbfx	r4, r3, #0, #6
   262e4:	0264      	lsls	r4, r4, #9
   262e6:	f8d7 6124 	ldr.w	r6, [r7, #292]	; 0x124
   262ea:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
      for(i=start;i<end;i++)
   262ee:	42b3      	cmp	r3, r6
   262f0:	eba6 0e03 	sub.w	lr, r6, r3
   262f4:	4631      	mov	r1, r6
   262f6:	f282 824e 	bge.w	28796 <celt_encode_with_ec+0x32ce>
   262fa:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
   262fe:	2a02      	cmp	r2, #2
   26300:	f002 819e 	beq.w	28640 <celt_encode_with_ec+0x3178>
   26304:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
   26308:	4619      	mov	r1, r3
   2630a:	eb02 0543 	add.w	r5, r2, r3, lsl #1
      opus_val16 follow=-QCONST16(10.0f,DB_SHIFT);
   2630e:	4b74      	ldr	r3, [pc, #464]	; (264e0 <celt_encode_with_ec+0x1018>)
   26310:	3d02      	subs	r5, #2
      opus_val32 frame_avg=0;
   26312:	2000      	movs	r0, #0
   26314:	46b4      	mov	ip, r6
         follow = MAX16(follow-QCONST16(1.f, DB_SHIFT), bandLogE[i]-offset);
   26316:	f935 2f02 	ldrsh.w	r2, [r5, #2]!
   2631a:	f5a3 6680 	sub.w	r6, r3, #1024	; 0x400
   2631e:	1b13      	subs	r3, r2, r4
   26320:	42b3      	cmp	r3, r6
   26322:	bfb8      	it	lt
   26324:	4633      	movlt	r3, r6
      for(i=start;i<end;i++)
   26326:	3101      	adds	r1, #1
         follow = MAX16(follow-QCONST16(1.f, DB_SHIFT), bandLogE[i]-offset);
   26328:	b21b      	sxth	r3, r3
      for(i=start;i<end;i++)
   2632a:	458c      	cmp	ip, r1
         frame_avg += follow;
   2632c:	4418      	add	r0, r3
      for(i=start;i<end;i++)
   2632e:	d1f2      	bne.n	26316 <celt_encode_with_ec+0xe4e>
   26330:	fb90 f3fe 	sdiv	r3, r0, lr
   26334:	b29b      	uxth	r3, r3
      temporal_vbr = SUB16(frame_avg,st->spec_avg);
   26336:	f8d7 012c 	ldr.w	r0, [r7, #300]	; 0x12c
      temporal_vbr = MIN16(QCONST16(3.f, DB_SHIFT), MAX16(-QCONST16(1.5f, DB_SHIFT), temporal_vbr));
   2633a:	496a      	ldr	r1, [pc, #424]	; (264e4 <celt_encode_with_ec+0x101c>)
      temporal_vbr = SUB16(frame_avg,st->spec_avg);
   2633c:	f8b0 20f0 	ldrh.w	r2, [r0, #240]	; 0xf0
   26340:	1a9b      	subs	r3, r3, r2
      temporal_vbr = MIN16(QCONST16(3.f, DB_SHIFT), MAX16(-QCONST16(1.5f, DB_SHIFT), temporal_vbr));
   26342:	b21b      	sxth	r3, r3
   26344:	428b      	cmp	r3, r1
   26346:	bfb8      	it	lt
   26348:	460b      	movlt	r3, r1
   2634a:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
   2634e:	4619      	mov	r1, r3
   26350:	bfa8      	it	ge
   26352:	f44f 6140 	movge.w	r1, #3072	; 0xc00
      st->spec_avg += MULT16_16_Q15(QCONST16(.02f, 15), temporal_vbr);
   26356:	eb01 1381 	add.w	r3, r1, r1, lsl #6
   2635a:	eb01 0343 	add.w	r3, r1, r3, lsl #1
   2635e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   26362:	eb02 33e3 	add.w	r3, r2, r3, asr #15
   26366:	f8a0 30f0 	strh.w	r3, [r0, #240]	; 0xf0
   2636a:	2300      	movs	r3, #0
   2636c:	6379      	str	r1, [r7, #52]	; 0x34
   2636e:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
   if (!secondMdct)
   26372:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   26374:	2b00      	cmp	r3, #0
   26376:	f001 81e4 	beq.w	27742 <celt_encode_with_ec+0x227a>
   2637a:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
   2637e:	3b01      	subs	r3, #1
   26380:	663b      	str	r3, [r7, #96]	; 0x60
   if (LM>0 && ec_tell(enc)+3<=total_bits && !isTransient && st->complexity>=5 && !st->lfe && !hybrid)
   26382:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
   26386:	b1cb      	cbz	r3, 263bc <celt_encode_with_ec+0xef4>
   26388:	f8d7 31cc 	ldr.w	r3, [r7, #460]	; 0x1cc
   2638c:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
   26390:	69db      	ldr	r3, [r3, #28]
   26392:	6952      	ldr	r2, [r2, #20]
   26394:	fab3 f383 	clz	r3, r3
   26398:	4413      	add	r3, r2
   2639a:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
   2639e:	3b1e      	subs	r3, #30
   263a0:	4293      	cmp	r3, r2
   263a2:	da0b      	bge.n	263bc <celt_encode_with_ec+0xef4>
   263a4:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
   263a8:	2b00      	cmp	r3, #0
   263aa:	f001 83ac 	beq.w	27b06 <celt_encode_with_ec+0x263e>
      ec_enc_bit_logp(enc, isTransient, 3);
   263ae:	2203      	movs	r2, #3
   263b0:	f8d7 1118 	ldr.w	r1, [r7, #280]	; 0x118
   263b4:	f8d7 01cc 	ldr.w	r0, [r7, #460]	; 0x1cc
   263b8:	f003 fcf6 	bl	29da8 <ec_enc_bit_logp>
   ALLOC(X, C*N, celt_norm);         /**< Interleaved normalised MDCTs */
   263bc:	f8d7 4114 	ldr.w	r4, [r7, #276]	; 0x114
   263c0:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
   normalise_bands(mode, freq, X, bandE, effEnd, C, M);
   263c4:	f8d7 10dc 	ldr.w	r1, [r7, #220]	; 0xdc
   ALLOC(X, C*N, celt_norm);         /**< Interleaved normalised MDCTs */
   263c8:	461a      	mov	r2, r3
   263ca:	4623      	mov	r3, r4
   263cc:	fb02 f303 	mul.w	r3, r2, r3
   263d0:	005b      	lsls	r3, r3, #1
   263d2:	3308      	adds	r3, #8
   263d4:	f023 0307 	bic.w	r3, r3, #7
   263d8:	ebad 0d03 	sub.w	sp, sp, r3
   normalise_bands(mode, freq, X, bandE, effEnd, C, M);
   263dc:	6f7b      	ldr	r3, [r7, #116]	; 0x74
   ALLOC(X, C*N, celt_norm);         /**< Interleaved normalised MDCTs */
   263de:	aa14      	add	r2, sp, #80	; 0x50
   263e0:	f8c7 20b4 	str.w	r2, [r7, #180]	; 0xb4
   normalise_bands(mode, freq, X, bandE, effEnd, C, M);
   263e4:	e9cd 4301 	strd	r4, r3, [sp, #4]
   263e8:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
   263ec:	9300      	str	r3, [sp, #0]
   263ee:	f8d7 5100 	ldr.w	r5, [r7, #256]	; 0x100
   263f2:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
   263f6:	4628      	mov	r0, r5
   263f8:	f7fb fedc 	bl	221b4 <normalise_bands>
   263fc:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
   enable_tf_analysis = effectiveBytes>=15*C && !hybrid && st->complexity>=2 && !st->lfe;
   26400:	ebc4 1304 	rsb	r3, r4, r4, lsl #4
   26404:	0094      	lsls	r4, r2, #2
   26406:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
   2640a:	4293      	cmp	r3, r2
   2640c:	dc6e      	bgt.n	264ec <celt_encode_with_ec+0x1024>
   2640e:	f8d7 112c 	ldr.w	r1, [r7, #300]	; 0x12c
   26412:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
   26416:	f8d5 8030 	ldr.w	r8, [r5, #48]	; 0x30
   2641a:	f8d1 e03c 	ldr.w	lr, [r1, #60]	; 0x3c
   2641e:	6ac8      	ldr	r0, [r1, #44]	; 0x2c
   26420:	6b4d      	ldr	r5, [r1, #52]	; 0x34
   26422:	6c0e      	ldr	r6, [r1, #64]	; 0x40
   26424:	2b00      	cmp	r3, #0
   26426:	f041 8114 	bne.w	27652 <celt_encode_with_ec+0x218a>
   2642a:	6989      	ldr	r1, [r1, #24]
   2642c:	2901      	cmp	r1, #1
   2642e:	dd02      	ble.n	26436 <celt_encode_with_ec+0xf6e>
   26430:	2e00      	cmp	r6, #0
   26432:	f001 8595 	beq.w	27f60 <celt_encode_with_ec+0x2a98>
   ALLOC(offsets, nbEBands, int);
   26436:	f104 030a 	add.w	r3, r4, #10
   2643a:	f023 0407 	bic.w	r4, r3, #7
   2643e:	ebad 0d04 	sub.w	sp, sp, r4
   26442:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
   26446:	ab14      	add	r3, sp, #80	; 0x50
   ALLOC(importance, nbEBands, int);
   26448:	ebad 0d04 	sub.w	sp, sp, r4
   2644c:	f10d 0c50 	add.w	ip, sp, #80	; 0x50
   ALLOC(spread_weight, nbEBands, int);
   26450:	ebad 0d04 	sub.w	sp, sp, r4
   26454:	aa14      	add	r2, sp, #80	; 0x50
   ALLOC(offsets, nbEBands, int);
   26456:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
   ALLOC(spread_weight, nbEBands, int);
   2645a:	643a      	str	r2, [r7, #64]	; 0x40
   maxDepth = dynalloc_analysis(bandLogE, bandLogE2, nbEBands, start, end, C, offsets,
   2645c:	f8d7 10cc 	ldr.w	r1, [r7, #204]	; 0xcc
   26460:	f8cd c038 	str.w	ip, [sp, #56]	; 0x38
   26464:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
   26468:	e9cd 630c 	strd	r6, r3, [sp, #48]	; 0x30
   2646c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   2646e:	930b      	str	r3, [sp, #44]	; 0x2c
   26470:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   26474:	930a      	str	r3, [sp, #40]	; 0x28
   26476:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
   2647a:	9309      	str	r3, [sp, #36]	; 0x24
   2647c:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
   26480:	9006      	str	r0, [sp, #24]
   26482:	e9cd 5307 	strd	r5, r3, [sp, #28]
   26486:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
   2648a:	f8cd e00c 	str.w	lr, [sp, #12]
   2648e:	e9cd 8304 	strd	r8, r3, [sp, #16]
   26492:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
   26496:	9302      	str	r3, [sp, #8]
   26498:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
   2649c:	9301      	str	r3, [sp, #4]
   2649e:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
   264a2:	9300      	str	r3, [sp, #0]
   264a4:	920f      	str	r2, [sp, #60]	; 0x3c
   264a6:	2300      	movs	r3, #0
   264a8:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
   264ac:	f8d7 00d8 	ldr.w	r0, [r7, #216]	; 0xd8
   264b0:	f7fd fe80 	bl	241b4 <dynalloc_analysis.isra.5>
   ALLOC(tf_res, nbEBands, int);
   264b4:	ebad 0d04 	sub.w	sp, sp, r4
   264b8:	ab14      	add	r3, sp, #80	; 0x50
   maxDepth = dynalloc_analysis(bandLogE, bandLogE2, nbEBands, start, end, C, offsets,
   264ba:	6478      	str	r0, [r7, #68]	; 0x44
   ALLOC(tf_res, nbEBands, int);
   264bc:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
   264c0:	e062      	b.n	26588 <celt_encode_with_ec+0x10c0>
   if (gain1<pf_threshold)
   264c2:	2200      	movs	r2, #0
   264c4:	f8c7 2098 	str.w	r2, [r7, #152]	; 0x98
      qg = 0;
   264c8:	663a      	str	r2, [r7, #96]	; 0x60
      pf_on = 0;
   264ca:	657a      	str	r2, [r7, #84]	; 0x54
      gain1 = 0;
   264cc:	64fa      	str	r2, [r7, #76]	; 0x4c
   264ce:	f7ff baa4 	b.w	25a1a <celt_encode_with_ec+0x552>
   if (nbAvailableBytes<35)
   264d2:	4603      	mov	r3, r0
      pf_threshold += QCONST16(.1f,15);
   264d4:	461a      	mov	r2, r3
   264d6:	f7ff ba63 	b.w	259a0 <celt_encode_with_ec+0x4d8>
   264da:	bf00      	nop
   264dc:	fffff800 	.word	0xfffff800
   264e0:	ffffd800 	.word	0xffffd800
   264e4:	fffffa00 	.word	0xfffffa00
   264e8:	fffff801 	.word	0xfffff801
   ALLOC(offsets, nbEBands, int);
   264ec:	f104 030a 	add.w	r3, r4, #10
   264f0:	f023 0407 	bic.w	r4, r3, #7
   264f4:	ebad 0d04 	sub.w	sp, sp, r4
   264f8:	a814      	add	r0, sp, #80	; 0x50
   ALLOC(importance, nbEBands, int);
   264fa:	ebad 0d04 	sub.w	sp, sp, r4
   ALLOC(offsets, nbEBands, int);
   264fe:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
   ALLOC(importance, nbEBands, int);
   26502:	ab14      	add	r3, sp, #80	; 0x50
   ALLOC(spread_weight, nbEBands, int);
   26504:	ebad 0d04 	sub.w	sp, sp, r4
   26508:	aa14      	add	r2, sp, #80	; 0x50
   ALLOC(offsets, nbEBands, int);
   2650a:	f8c7 00a4 	str.w	r0, [r7, #164]	; 0xa4
   ALLOC(spread_weight, nbEBands, int);
   2650e:	643a      	str	r2, [r7, #64]	; 0x40
   maxDepth = dynalloc_analysis(bandLogE, bandLogE2, nbEBands, start, end, C, offsets,
   26510:	930e      	str	r3, [sp, #56]	; 0x38
   26512:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
   26516:	930d      	str	r3, [sp, #52]	; 0x34
   26518:	920f      	str	r2, [sp, #60]	; 0x3c
   2651a:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
   2651e:	6c13      	ldr	r3, [r2, #64]	; 0x40
   26520:	930c      	str	r3, [sp, #48]	; 0x30
   26522:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   26524:	930b      	str	r3, [sp, #44]	; 0x2c
   26526:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   2652a:	930a      	str	r3, [sp, #40]	; 0x28
   2652c:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
   26530:	9309      	str	r3, [sp, #36]	; 0x24
   26532:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
   26536:	9308      	str	r3, [sp, #32]
   26538:	6b53      	ldr	r3, [r2, #52]	; 0x34
   2653a:	9307      	str	r3, [sp, #28]
   2653c:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   2653e:	9306      	str	r3, [sp, #24]
   26540:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
   26544:	9305      	str	r3, [sp, #20]
   26546:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
   2654a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   2654c:	9304      	str	r3, [sp, #16]
   2654e:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
   26550:	9303      	str	r3, [sp, #12]
   26552:	f8d7 10cc 	ldr.w	r1, [r7, #204]	; 0xcc
   26556:	9002      	str	r0, [sp, #8]
   26558:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
   2655c:	9301      	str	r3, [sp, #4]
   2655e:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
   26562:	9300      	str	r3, [sp, #0]
   26564:	f8d7 5120 	ldr.w	r5, [r7, #288]	; 0x120
   26568:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
   2656c:	f8d7 00d8 	ldr.w	r0, [r7, #216]	; 0xd8
   26570:	462b      	mov	r3, r5
   26572:	f7fd fe1f 	bl	241b4 <dynalloc_analysis.isra.5>
   ALLOC(tf_res, nbEBands, int);
   26576:	ebad 0d04 	sub.w	sp, sp, r4
   2657a:	ab14      	add	r3, sp, #80	; 0x50
   maxDepth = dynalloc_analysis(bandLogE, bandLogE2, nbEBands, start, end, C, offsets,
   2657c:	6478      	str	r0, [r7, #68]	; 0x44
   ALLOC(tf_res, nbEBands, int);
   2657e:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
   } else if (hybrid && weak_transient)
   26582:	2d00      	cmp	r5, #0
   26584:	f041 80a9 	bne.w	276da <celt_encode_with_ec+0x2212>
      for (i=0;i<end;i++)
   26588:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
   2658c:	2b00      	cmp	r3, #0
   2658e:	f342 8116 	ble.w	287be <celt_encode_with_ec+0x32f6>
   26592:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
      for (i=0;i<end;i++)
   26596:	f8d7 1124 	ldr.w	r1, [r7, #292]	; 0x124
   2659a:	f8d7 0118 	ldr.w	r0, [r7, #280]	; 0x118
   2659e:	1f1a      	subs	r2, r3, #4
   265a0:	2300      	movs	r3, #0
      for (i=0;i<end;i++)
   265a2:	3301      	adds	r3, #1
   265a4:	4299      	cmp	r1, r3
         tf_res[i] = isTransient;
   265a6:	f842 0f04 	str.w	r0, [r2, #4]!
      for (i=0;i<end;i++)
   265aa:	d1fa      	bne.n	265a2 <celt_encode_with_ec+0x10da>
      tf_select=0;
   265ac:	2300      	movs	r3, #0
   265ae:	f8d7 1124 	ldr.w	r1, [r7, #292]	; 0x124
   265b2:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
   ALLOC(error, C*nbEBands, opus_val16);
   265b6:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   265ba:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
   265be:	f023 0307 	bic.w	r3, r3, #7
   265c2:	ebad 0d03 	sub.w	sp, sp, r3
   265c6:	ab14      	add	r3, sp, #80	; 0x50
   265c8:	428a      	cmp	r2, r1
   265ca:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
   265ce:	da3b      	bge.n	26648 <celt_encode_with_ec+0x1180>
   265d0:	f8d7 0084 	ldr.w	r0, [r7, #132]	; 0x84
   265d4:	f8d7 4110 	ldr.w	r4, [r7, #272]	; 0x110
         if (ABS32(SUB32(bandLogE[i+c*nbEBands], oldBandE[i+c*nbEBands])) < QCONST16(2.f, DB_SHIFT))
   265d8:	f8d7 b114 	ldr.w	fp, [r7, #276]	; 0x114
   265dc:	0053      	lsls	r3, r2, #1
   265de:	eba3 0a00 	sub.w	sl, r3, r0
   265e2:	eba2 0901 	sub.w	r9, r2, r1
   265e6:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
   265e8:	ebaa 0a04 	sub.w	sl, sl, r4
   265ec:	4492      	add	sl, r2
   265ee:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
   265f2:	3b02      	subs	r3, #2
   265f4:	eb02 0c03 	add.w	ip, r2, r3
   265f8:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
   265fc:	ea4f 0949 	mov.w	r9, r9, lsl #1
   26600:	ea4f 0843 	mov.w	r8, r3, lsl #1
   26604:	1905      	adds	r5, r0, r4
   c=0;
   26606:	f04f 0e00 	mov.w	lr, #0
         if (ABS32(SUB32(bandLogE[i+c*nbEBands], oldBandE[i+c*nbEBands])) < QCONST16(2.f, DB_SHIFT))
   2660a:	f640 76fe 	movw	r6, #4094	; 0xffe
   2660e:	eb09 0105 	add.w	r1, r9, r5
   26612:	eb0a 0405 	add.w	r4, sl, r5
   c=0;
   26616:	4660      	mov	r0, ip
         if (ABS32(SUB32(bandLogE[i+c*nbEBands], oldBandE[i+c*nbEBands])) < QCONST16(2.f, DB_SHIFT))
   26618:	f930 2f02 	ldrsh.w	r2, [r0, #2]!
   2661c:	f931 3b02 	ldrsh.w	r3, [r1], #2
   26620:	1ad3      	subs	r3, r2, r3
   26622:	f203 73ff 	addw	r3, r3, #2047	; 0x7ff
   26626:	42b3      	cmp	r3, r6
   26628:	d804      	bhi.n	26634 <celt_encode_with_ec+0x116c>
            bandLogE[i+c*nbEBands] -= MULT16_16_Q15(energyError[i+c*nbEBands], QCONST16(0.25f, 15));
   2662a:	f9b4 3000 	ldrsh.w	r3, [r4]
   2662e:	eba2 02a3 	sub.w	r2, r2, r3, asr #2
   26632:	8002      	strh	r2, [r0, #0]
      for (i=start;i<end;i++)
   26634:	428d      	cmp	r5, r1
   26636:	f104 0402 	add.w	r4, r4, #2
   2663a:	d1ed      	bne.n	26618 <celt_encode_with_ec+0x1150>
   } while (++c < C);
   2663c:	f10e 0e01 	add.w	lr, lr, #1
   26640:	45f3      	cmp	fp, lr
   26642:	4445      	add	r5, r8
   26644:	44c4      	add	ip, r8
   26646:	dce2      	bgt.n	2660e <celt_encode_with_ec+0x1146>
   quant_coarse_energy(mode, start, end, effEnd, bandLogE,
   26648:	f8d7 112c 	ldr.w	r1, [r7, #300]	; 0x12c
   2664c:	6c0b      	ldr	r3, [r1, #64]	; 0x40
   2664e:	930c      	str	r3, [sp, #48]	; 0x30
   26650:	6b8b      	ldr	r3, [r1, #56]	; 0x38
   26652:	930b      	str	r3, [sp, #44]	; 0x2c
   26654:	698a      	ldr	r2, [r1, #24]
   26656:	460b      	mov	r3, r1
   26658:	2a03      	cmp	r2, #3
   2665a:	bfd4      	ite	le
   2665c:	2200      	movle	r2, #0
   2665e:	2201      	movgt	r2, #1
   26660:	3354      	adds	r3, #84	; 0x54
   26662:	e9cd 3209 	strd	r3, r2, [sp, #36]	; 0x24
   26666:	68cb      	ldr	r3, [r1, #12]
   26668:	9308      	str	r3, [sp, #32]
   2666a:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
   2666e:	9307      	str	r3, [sp, #28]
   26670:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
   26674:	9306      	str	r3, [sp, #24]
   26676:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
   2667a:	9305      	str	r3, [sp, #20]
   2667c:	f8d7 31cc 	ldr.w	r3, [r7, #460]	; 0x1cc
   26680:	9304      	str	r3, [sp, #16]
   26682:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
   26686:	9303      	str	r3, [sp, #12]
   26688:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
   2668c:	9302      	str	r3, [sp, #8]
   2668e:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
   26692:	9301      	str	r3, [sp, #4]
   26694:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
   26698:	9300      	str	r3, [sp, #0]
   2669a:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
   2669e:	f8d7 2124 	ldr.w	r2, [r7, #292]	; 0x124
   266a2:	f8d7 1120 	ldr.w	r1, [r7, #288]	; 0x120
   266a6:	f8d7 0100 	ldr.w	r0, [r7, #256]	; 0x100
   266aa:	f006 fc09 	bl	2cec0 <quant_coarse_energy>
   266ae:	f8d7 31cc 	ldr.w	r3, [r7, #460]	; 0x1cc
   266b2:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
   266b6:	69db      	ldr	r3, [r3, #28]
   266b8:	6951      	ldr	r1, [r2, #20]
   budget = enc->storage*8;
   266ba:	6852      	ldr	r2, [r2, #4]
   266bc:	fab3 f383 	clz	r3, r3
   266c0:	f1c3 0320 	rsb	r3, r3, #32
   266c4:	00d4      	lsls	r4, r2, #3
   logp = isTransient ? 2 : 4;
   266c6:	f8d7 2118 	ldr.w	r2, [r7, #280]	; 0x118
   266ca:	1ac9      	subs	r1, r1, r3
   tell = ec_tell(enc);
   266cc:	460b      	mov	r3, r1
   logp = isTransient ? 2 : 4;
   266ce:	2a00      	cmp	r2, #0
   266d0:	f000 866d 	beq.w	273ae <celt_encode_with_ec+0x1ee6>
   tf_select_rsv = LM>0 && tell+logp+1 <= budget;
   266d4:	f8d7 010c 	ldr.w	r0, [r7, #268]	; 0x10c
   logp = isTransient ? 2 : 4;
   266d8:	2502      	movs	r5, #2
   266da:	462a      	mov	r2, r5
   tf_select_rsv = LM>0 && tell+logp+1 <= budget;
   266dc:	2800      	cmp	r0, #0
   266de:	f000 866d 	beq.w	273bc <celt_encode_with_ec+0x1ef4>
   for (i=start;i<end;i++)
   266e2:	f8d7 6120 	ldr.w	r6, [r7, #288]	; 0x120
   tf_select_rsv = LM>0 && tell+logp+1 <= budget;
   266e6:	1c48      	adds	r0, r1, #1
   266e8:	4428      	add	r0, r5
   for (i=start;i<end;i++)
   266ea:	46b4      	mov	ip, r6
   266ec:	f8d7 6124 	ldr.w	r6, [r7, #292]	; 0x124
   tf_select_rsv = LM>0 && tell+logp+1 <= budget;
   266f0:	4284      	cmp	r4, r0
   266f2:	bf34      	ite	cc
   266f4:	f04f 0800 	movcc.w	r8, #0
   266f8:	f04f 0801 	movcs.w	r8, #1
   for (i=start;i<end;i++)
   266fc:	45b4      	cmp	ip, r6
   budget -= tf_select_rsv;
   266fe:	eba4 0508 	sub.w	r5, r4, r8
   for (i=start;i<end;i++)
   26702:	f282 801d 	bge.w	28740 <celt_encode_with_ec+0x3278>
   26706:	f8d7 1118 	ldr.w	r1, [r7, #280]	; 0x118
   tf_select_rsv = LM>0 && tell+logp+1 <= budget;
   2670a:	f8c7 8128 	str.w	r8, [r7, #296]	; 0x128
   2670e:	2900      	cmp	r1, #0
   26710:	f04f 0600 	mov.w	r6, #0
   26714:	4631      	mov	r1, r6
   26716:	46b0      	mov	r8, r6
   26718:	bf14      	ite	ne
   2671a:	f04f 0904 	movne.w	r9, #4
   2671e:	f04f 0905 	moveq.w	r9, #5
   26722:	f8d7 4120 	ldr.w	r4, [r7, #288]	; 0x120
   26726:	f8d7 b124 	ldr.w	fp, [r7, #292]	; 0x124
   2672a:	f8d7 a0cc 	ldr.w	sl, [r7, #204]	; 0xcc
   2672e:	f8d7 61cc 	ldr.w	r6, [r7, #460]	; 0x1cc
   26732:	469c      	mov	ip, r3
   26734:	e005      	b.n	26742 <celt_encode_with_ec+0x127a>
         tf_res[i] = curr;
   26736:	f84a 1024 	str.w	r1, [sl, r4, lsl #2]
   for (i=start;i<end;i++)
   2673a:	3401      	adds	r4, #1
   2673c:	45a3      	cmp	fp, r4
      logp = isTransient ? 4 : 5;
   2673e:	464a      	mov	r2, r9
   for (i=start;i<end;i++)
   26740:	dd19      	ble.n	26776 <celt_encode_with_ec+0x12ae>
      if (tell+logp<=budget)
   26742:	eb02 000c 	add.w	r0, r2, ip
   26746:	42a8      	cmp	r0, r5
   26748:	d8f5      	bhi.n	26736 <celt_encode_with_ec+0x126e>
         ec_enc_bit_logp(enc, tf_res[i] ^ curr, logp);
   2674a:	f85a 0024 	ldr.w	r0, [sl, r4, lsl #2]
   2674e:	4041      	eors	r1, r0
   26750:	4630      	mov	r0, r6
   26752:	f003 fb29 	bl	29da8 <ec_enc_bit_logp>
   26756:	69f0      	ldr	r0, [r6, #28]
   26758:	6972      	ldr	r2, [r6, #20]
         curr = tf_res[i];
   2675a:	f85a 1024 	ldr.w	r1, [sl, r4, lsl #2]
   2675e:	fab0 fc80 	clz	ip, r0
   for (i=start;i<end;i++)
   26762:	3401      	adds	r4, #1
   26764:	f1cc 0c20 	rsb	ip, ip, #32
   26768:	45a3      	cmp	fp, r4
   2676a:	eba2 0c0c 	sub.w	ip, r2, ip
         tf_changed |= curr;
   2676e:	ea48 0801 	orr.w	r8, r8, r1
      logp = isTransient ? 4 : 5;
   26772:	464a      	mov	r2, r9
   for (i=start;i<end;i++)
   26774:	dce5      	bgt.n	26742 <celt_encode_with_ec+0x127a>
   26776:	4646      	mov	r6, r8
   26778:	f8d7 8128 	ldr.w	r8, [r7, #296]	; 0x128
   if (tf_select_rsv &&
   2677c:	f1b8 0f00 	cmp.w	r8, #0
   26780:	f000 85ff 	beq.w	27382 <celt_encode_with_ec+0x1eba>
         tf_select_table[LM][4*isTransient+0+tf_changed]!=
   26784:	f8d7 210c 	ldr.w	r2, [r7, #268]	; 0x10c
   26788:	4b6e      	ldr	r3, [pc, #440]	; (26944 <celt_encode_with_ec+0x147c>)
   2678a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   2678e:	f8d7 2118 	ldr.w	r2, [r7, #280]	; 0x118
   26792:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   26796:	1999      	adds	r1, r3, r6
   if (tf_select_rsv &&
   26798:	579a      	ldrsb	r2, [r3, r6]
   2679a:	f991 3002 	ldrsb.w	r3, [r1, #2]
   2679e:	429a      	cmp	r2, r3
   267a0:	f000 85ef 	beq.w	27382 <celt_encode_with_ec+0x1eba>
      ec_enc_bit_logp(enc, tf_select, 1);
   267a4:	2201      	movs	r2, #1
   267a6:	f8d7 10ec 	ldr.w	r1, [r7, #236]	; 0xec
   267aa:	f8d7 01cc 	ldr.w	r0, [r7, #460]	; 0x1cc
   267ae:	f003 fafb 	bl	29da8 <ec_enc_bit_logp>
   267b2:	f8d7 31cc 	ldr.w	r3, [r7, #460]	; 0x1cc
   267b6:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
   267ba:	69db      	ldr	r3, [r3, #28]
   267bc:	6951      	ldr	r1, [r2, #20]
   for (i=start;i<end;i++)
   267be:	f8d7 4124 	ldr.w	r4, [r7, #292]	; 0x124
   267c2:	fab3 f383 	clz	r3, r3
   267c6:	f1c3 0320 	rsb	r3, r3, #32
   267ca:	1ac9      	subs	r1, r1, r3
   267cc:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
   267d0:	42a3      	cmp	r3, r4
   267d2:	da1c      	bge.n	2680e <celt_encode_with_ec+0x1346>
      tf_res[i] = tf_select_table[LM][4*isTransient+2*tf_select+tf_res[i]];
   267d4:	f8d7 5118 	ldr.w	r5, [r7, #280]	; 0x118
   267d8:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
   267dc:	4859      	ldr	r0, [pc, #356]	; (26944 <celt_encode_with_ec+0x147c>)
   267de:	eb02 0245 	add.w	r2, r2, r5, lsl #1
   267e2:	f8d7 510c 	ldr.w	r5, [r7, #268]	; 0x10c
   267e6:	eb00 00c5 	add.w	r0, r0, r5, lsl #3
   267ea:	f8d7 50cc 	ldr.w	r5, [r7, #204]	; 0xcc
   267ee:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   267f2:	3b01      	subs	r3, #1
   267f4:	eb05 0484 	add.w	r4, r5, r4, lsl #2
   267f8:	eb00 0042 	add.w	r0, r0, r2, lsl #1
   267fc:	eb05 0383 	add.w	r3, r5, r3, lsl #2
   26800:	3c04      	subs	r4, #4
   26802:	f853 2f04 	ldr.w	r2, [r3, #4]!
   26806:	5682      	ldrsb	r2, [r0, r2]
   26808:	601a      	str	r2, [r3, #0]
   for (i=start;i<end;i++)
   2680a:	429c      	cmp	r4, r3
   2680c:	d1f9      	bne.n	26802 <celt_encode_with_ec+0x133a>
   if (ec_tell(enc)+4<=total_bits)
   2680e:	f8d7 00e0 	ldr.w	r0, [r7, #224]	; 0xe0
   26812:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
   26816:	1ccb      	adds	r3, r1, #3
   26818:	4298      	cmp	r0, r3
   2681a:	6c11      	ldr	r1, [r2, #64]	; 0x40
   2681c:	dd0f      	ble.n	2683e <celt_encode_with_ec+0x1376>
      if (st->lfe)
   2681e:	2900      	cmp	r1, #0
   26820:	f001 80be 	beq.w	279a0 <celt_encode_with_ec+0x24d8>
         st->tapset_decision = 0;
   26824:	2300      	movs	r3, #0
         st->spread_decision = SPREAD_NORMAL;
   26826:	2102      	movs	r1, #2
         st->tapset_decision = 0;
   26828:	6653      	str	r3, [r2, #100]	; 0x64
         st->spread_decision = SPREAD_NORMAL;
   2682a:	6511      	str	r1, [r2, #80]	; 0x50
      ec_enc_icdf(enc, st->spread_decision, spread_icdf, 5);
   2682c:	2305      	movs	r3, #5
   2682e:	4a46      	ldr	r2, [pc, #280]	; (26948 <celt_encode_with_ec+0x1480>)
   26830:	f8d7 01cc 	ldr.w	r0, [r7, #460]	; 0x1cc
   26834:	f003 fb24 	bl	29e80 <ec_enc_icdf>
   26838:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
   2683c:	6c19      	ldr	r1, [r3, #64]	; 0x40
   if (st->lfe)
   2683e:	b169      	cbz	r1, 2685c <celt_encode_with_ec+0x1394>
      offsets[0] = IMIN(8, effectiveBytes/3);
   26840:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
   26844:	2a1a      	cmp	r2, #26
   26846:	f301 80a5 	bgt.w	27994 <celt_encode_with_ec+0x24cc>
   2684a:	4b40      	ldr	r3, [pc, #256]	; (2694c <celt_encode_with_ec+0x1484>)
   2684c:	4611      	mov	r1, r2
   2684e:	fb83 1301 	smull	r1, r3, r3, r1
   26852:	eba3 73e2 	sub.w	r3, r3, r2, asr #31
   26856:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
   2685a:	6013      	str	r3, [r2, #0]
   ALLOC(cap, nbEBands, int);
   2685c:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
   init_caps(mode,cap,LM,C);
   26860:	f8d7 210c 	ldr.w	r2, [r7, #268]	; 0x10c
   26864:	f8d7 0100 	ldr.w	r0, [r7, #256]	; 0x100
   ALLOC(cap, nbEBands, int);
   26868:	f023 0307 	bic.w	r3, r3, #7
   2686c:	ebad 0d03 	sub.w	sp, sp, r3
   26870:	ab14      	add	r3, sp, #80	; 0x50
   init_caps(mode,cap,LM,C);
   26872:	4619      	mov	r1, r3
   ALLOC(cap, nbEBands, int);
   26874:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
   26878:	461c      	mov	r4, r3
   init_caps(mode,cap,LM,C);
   2687a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
   2687e:	f7fd fbc1 	bl	24004 <init_caps>
   tell = ec_tell_frac(enc);
   26882:	f8d7 01cc 	ldr.w	r0, [r7, #460]	; 0x1cc
   26886:	f002 ff51 	bl	2972c <ec_tell_frac>
   total_bits<<=BITRES;
   2688a:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
   for (i=start;i<end;i++)
   2688e:	f8d7 1124 	ldr.w	r1, [r7, #292]	; 0x124
   total_bits<<=BITRES;
   26892:	00d2      	lsls	r2, r2, #3
   26894:	f8c7 20ec 	str.w	r2, [r7, #236]	; 0xec
   for (i=start;i<end;i++)
   26898:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
   2689c:	428a      	cmp	r2, r1
   tell = ec_tell_frac(enc);
   2689e:	4682      	mov	sl, r0
   for (i=start;i<end;i++)
   268a0:	f281 86c8 	bge.w	28634 <celt_encode_with_ec+0x316c>
   268a4:	f8d7 10c8 	ldr.w	r1, [r7, #200]	; 0xc8
   268a8:	f8d7 0084 	ldr.w	r0, [r7, #132]	; 0x84
   268ac:	0093      	lsls	r3, r2, #2
   268ae:	eb01 0242 	add.w	r2, r1, r2, lsl #1
   268b2:	f8c7 2104 	str.w	r2, [r7, #260]	; 0x104
   268b6:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
   268ba:	4605      	mov	r5, r0
   268bc:	441a      	add	r2, r3
   268be:	440d      	add	r5, r1
   268c0:	f8c7 2128 	str.w	r2, [r7, #296]	; 0x128
   268c4:	4423      	add	r3, r4
   dynalloc_logp = 6;
   268c6:	2206      	movs	r2, #6
   total_boost = 0;
   268c8:	4650      	mov	r0, sl
   268ca:	f8c7 50e4 	str.w	r5, [r7, #228]	; 0xe4
   dynalloc_logp = 6;
   268ce:	f8c7 20fc 	str.w	r2, [r7, #252]	; 0xfc
   total_boost = 0;
   268d2:	f04f 0b00 	mov.w	fp, #0
   268d6:	469a      	mov	sl, r3
   268d8:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
      for (j = 0; tell+(dynalloc_loop_logp<<BITRES) < total_bits-total_boost
   268dc:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
      width = C*(eBands[i+1]-eBands[i])<<LM;
   268e0:	f9b3 1000 	ldrsh.w	r1, [r3]
      for (j = 0; tell+(dynalloc_loop_logp<<BITRES) < total_bits-total_boost
   268e4:	eba2 090b 	sub.w	r9, r2, fp
      width = C*(eBands[i+1]-eBands[i])<<LM;
   268e8:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
   268ec:	1a52      	subs	r2, r2, r1
   268ee:	f8d7 1114 	ldr.w	r1, [r7, #276]	; 0x114
   268f2:	fb01 f202 	mul.w	r2, r1, r2
   268f6:	f8d7 110c 	ldr.w	r1, [r7, #268]	; 0x10c
   268fa:	408a      	lsls	r2, r1
      quanta = IMIN(width<<BITRES, IMAX(6<<BITRES, width));
   268fc:	2a30      	cmp	r2, #48	; 0x30
      for (j = 0; tell+(dynalloc_loop_logp<<BITRES) < total_bits-total_boost
   268fe:	f8d7 10fc 	ldr.w	r1, [r7, #252]	; 0xfc
      quanta = IMIN(width<<BITRES, IMAX(6<<BITRES, width));
   26902:	4616      	mov	r6, r2
   26904:	ea4f 02c2 	mov.w	r2, r2, lsl #3
   26908:	bfb8      	it	lt
   2690a:	2630      	movlt	r6, #48	; 0x30
   2690c:	4296      	cmp	r6, r2
      for (j = 0; tell+(dynalloc_loop_logp<<BITRES) < total_bits-total_boost
   2690e:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
   26912:	f103 0302 	add.w	r3, r3, #2
      quanta = IMIN(width<<BITRES, IMAX(6<<BITRES, width));
   26916:	bfa8      	it	ge
   26918:	4616      	movge	r6, r2
      for (j = 0; tell+(dynalloc_loop_logp<<BITRES) < total_bits-total_boost
   2691a:	4589      	cmp	r9, r1
   2691c:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
   26920:	f340 8537 	ble.w	27392 <celt_encode_with_ec+0x1eca>
            && boost < cap[i]; j++)
   26924:	f8da 2000 	ldr.w	r2, [sl]
   26928:	2a00      	cmp	r2, #0
   2692a:	f340 8532 	ble.w	27392 <celt_encode_with_ec+0x1eca>
   2692e:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
   26932:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
   26936:	eb0b 0406 	add.w	r4, fp, r6
      for (j = 0; tell+(dynalloc_loop_logp<<BITRES) < total_bits-total_boost
   2693a:	2500      	movs	r5, #0
   2693c:	1b1c      	subs	r4, r3, r4
      boost = 0;
   2693e:	46a8      	mov	r8, r5
            && boost < cap[i]; j++)
   26940:	46b1      	mov	r9, r6
   26942:	e013      	b.n	2696c <celt_encode_with_ec+0x14a4>
   26944:	00037970 	.word	0x00037970
   26948:	00037a68 	.word	0x00037a68
   2694c:	55555556 	.word	0x55555556
      for (j = 0; tell+(dynalloc_loop_logp<<BITRES) < total_bits-total_boost
   26950:	42a1      	cmp	r1, r4
         boost += quanta;
   26952:	44c8      	add	r8, r9
         total_boost += quanta;
   26954:	44cb      	add	fp, r9
            && boost < cap[i]; j++)
   26956:	f105 0501 	add.w	r5, r5, #1
   2695a:	eba4 0409 	sub.w	r4, r4, r9
      for (j = 0; tell+(dynalloc_loop_logp<<BITRES) < total_bits-total_boost
   2695e:	f280 84d1 	bge.w	27304 <celt_encode_with_ec+0x1e3c>
            && boost < cap[i]; j++)
   26962:	f8da 1000 	ldr.w	r1, [sl]
   26966:	4541      	cmp	r1, r8
   26968:	f340 84cc 	ble.w	27304 <celt_encode_with_ec+0x1e3c>
         flag = j<offsets[i];
   2696c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
         ec_enc_bit_logp(enc, flag, dynalloc_loop_logp);
   26970:	f8d7 01cc 	ldr.w	r0, [r7, #460]	; 0x1cc
         flag = j<offsets[i];
   26974:	681e      	ldr	r6, [r3, #0]
         ec_enc_bit_logp(enc, flag, dynalloc_loop_logp);
   26976:	42ae      	cmp	r6, r5
   26978:	bfd4      	ite	le
   2697a:	2100      	movle	r1, #0
   2697c:	2101      	movgt	r1, #1
   2697e:	f003 fa13 	bl	29da8 <ec_enc_bit_logp>
         tell = ec_tell_frac(enc);
   26982:	f8d7 01cc 	ldr.w	r0, [r7, #460]	; 0x1cc
   26986:	f002 fed1 	bl	2972c <ec_tell_frac>
         if (!flag)
   2698a:	42ae      	cmp	r6, r5
      for (j = 0; tell+(dynalloc_loop_logp<<BITRES) < total_bits-total_boost
   2698c:	f100 0108 	add.w	r1, r0, #8
   26990:	4626      	mov	r6, r4
         dynalloc_loop_logp = 1;
   26992:	f04f 0201 	mov.w	r2, #1
         if (!flag)
   26996:	dcdb      	bgt.n	26950 <celt_encode_with_ec+0x1488>
   26998:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
   2699c:	eba3 090b 	sub.w	r9, r3, fp
      if (j)
   269a0:	b13d      	cbz	r5, 269b2 <celt_encode_with_ec+0x14ea>
         dynalloc_logp = IMAX(2, dynalloc_logp-1);
   269a2:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
   269a6:	2a03      	cmp	r2, #3
   269a8:	bfb8      	it	lt
   269aa:	2203      	movlt	r2, #3
   269ac:	1e53      	subs	r3, r2, #1
   269ae:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
      offsets[i] = boost;
   269b2:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
   for (i=start;i<end;i++)
   269b6:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
      offsets[i] = boost;
   269ba:	f843 8b04 	str.w	r8, [r3], #4
   269be:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
   for (i=start;i<end;i++)
   269c2:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
   269c6:	4293      	cmp	r3, r2
   269c8:	f10a 0a04 	add.w	sl, sl, #4
   269cc:	d184      	bne.n	268d8 <celt_encode_with_ec+0x1410>
   269ce:	4682      	mov	sl, r0
   if (C==2)
   269d0:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
   269d4:	2b02      	cmp	r3, #2
   269d6:	f000 8571 	beq.w	274bc <celt_encode_with_ec+0x1ff4>
   if (tell+(6<<BITRES) <= total_bits - total_boost)
   269da:	f10a 032f 	add.w	r3, sl, #47	; 0x2f
   269de:	454b      	cmp	r3, r9
   269e0:	f280 84e0 	bge.w	273a4 <celt_encode_with_ec+0x1edc>
      if (start > 0 || st->lfe)
   269e4:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
   269e8:	2b00      	cmp	r3, #0
   269ea:	f341 8596 	ble.w	2851a <celt_encode_with_ec+0x3052>
         st->stereo_saving = 0;
   269ee:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
   269f2:	2300      	movs	r3, #0
   269f4:	f8a2 30e4 	strh.w	r3, [r2, #228]	; 0xe4
         alloc_trim = 5;
   269f8:	2305      	movs	r3, #5
   269fa:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
   269fe:	4619      	mov	r1, r3
      ec_enc_icdf(enc, alloc_trim, trim_icdf, 7);
   26a00:	2307      	movs	r3, #7
   26a02:	4a93      	ldr	r2, [pc, #588]	; (26c50 <celt_encode_with_ec+0x1788>)
   26a04:	f8d7 01cc 	ldr.w	r0, [r7, #460]	; 0x1cc
   26a08:	f003 fa3a 	bl	29e80 <ec_enc_icdf>
      tell = ec_tell_frac(enc);
   26a0c:	f8d7 01cc 	ldr.w	r0, [r7, #460]	; 0x1cc
   26a10:	f002 fe8c 	bl	2972c <ec_tell_frac>
   26a14:	4682      	mov	sl, r0
   if (vbr_rate>0)
   26a16:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
   26a1a:	2a00      	cmp	r2, #0
   26a1c:	f340 80f0 	ble.w	26c00 <celt_encode_with_ec+0x1738>
     nbCompressedBytes = IMIN(nbCompressedBytes,1275>>(3-LM));
   26a20:	6eb9      	ldr	r1, [r7, #104]	; 0x68
     int lm_diff = mode->maxLM - LM;
   26a22:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
     nbCompressedBytes = IMIN(nbCompressedBytes,1275>>(3-LM));
   26a26:	f240 48fb 	movw	r8, #1275	; 0x4fb
   26a2a:	fa48 f801 	asr.w	r8, r8, r1
   26a2e:	f8d7 10e8 	ldr.w	r1, [r7, #232]	; 0xe8
     int lm_diff = mode->maxLM - LM;
   26a32:	69dc      	ldr	r4, [r3, #28]
   26a34:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
     nbCompressedBytes = IMIN(nbCompressedBytes,1275>>(3-LM));
   26a38:	4588      	cmp	r8, r1
   26a3a:	bfa8      	it	ge
   26a3c:	4688      	movge	r8, r1
     int lm_diff = mode->maxLM - LM;
   26a3e:	f8d7 110c 	ldr.w	r1, [r7, #268]	; 0x10c
   26a42:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   26a44:	eba4 0901 	sub.w	r9, r4, r1
     if (!hybrid)
   26a48:	f8d7 1120 	ldr.w	r1, [r7, #288]	; 0x120
   26a4c:	2900      	cmp	r1, #0
   26a4e:	f040 8727 	bne.w	278a0 <celt_encode_with_ec+0x23d8>
        base_target = vbr_rate - ((40*C+20)<<BITRES);
   26a52:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
   26a54:	eba2 06c1 	sub.w	r6, r2, r1, lsl #3
     if (st->constrained_vbr)
   26a58:	2b00      	cmp	r3, #0
   26a5a:	f042 8219 	bne.w	28e90 <celt_encode_with_ec+0x39c8>
        target = compute_vbr(mode, &st->analysis, base_target, LM, equiv_rate,
   26a5e:	f8d7 112c 	ldr.w	r1, [r7, #300]	; 0x12c
   26a62:	f8d7 0100 	ldr.w	r0, [r7, #256]	; 0x100
   26a66:	6dca      	ldr	r2, [r1, #92]	; 0x5c
   26a68:	f8d0 e008 	ldr.w	lr, [r0, #8]
   26a6c:	f8d0 c018 	ldr.w	ip, [r0, #24]
   26a70:	f8d7 0138 	ldr.w	r0, [r7, #312]	; 0x138
   26a74:	f8c7 0104 	str.w	r0, [r7, #260]	; 0x104
   coded_bands = lastCodedBands ? lastCodedBands : nbEBands;
   26a78:	2a00      	cmp	r2, #0
   26a7a:	bf08      	it	eq
   26a7c:	4672      	moveq	r2, lr
        target = compute_vbr(mode, &st->analysis, base_target, LM, equiv_rate,
   26a7e:	6c08      	ldr	r0, [r1, #64]	; 0x40
   26a80:	f8c7 00fc 	str.w	r0, [r7, #252]	; 0xfc
           st->lfe, st->energy_mask!=NULL, surround_masking,
   26a84:	f8d1 50ec 	ldr.w	r5, [r1, #236]	; 0xec
   coded_bins = eBands[coded_bands]<<LM;
   26a88:	f8d7 010c 	ldr.w	r0, [r7, #268]	; 0x10c
   26a8c:	f93c 1012 	ldrsh.w	r1, [ip, r2, lsl #1]
   26a90:	4081      	lsls	r1, r0
   26a92:	f8c7 10ec 	str.w	r1, [r7, #236]	; 0xec
   if (C==2)
   26a96:	f8d7 1114 	ldr.w	r1, [r7, #276]	; 0x114
   26a9a:	2902      	cmp	r1, #2
   26a9c:	f001 8607 	beq.w	286ae <celt_encode_with_ec+0x31e6>
   26aa0:	4632      	mov	r2, r6
   target += tot_boost-(19<<LM);
   26aa2:	2113      	movs	r1, #19
   26aa4:	4081      	lsls	r1, r0
   26aa6:	f8d7 0104 	ldr.w	r0, [r7, #260]	; 0x104
   26aaa:	1a41      	subs	r1, r0, r1
   26aac:	4411      	add	r1, r2
   target += (opus_int32)SHL32(MULT16_32_Q15(tf_estimate-tf_calibration, target),1);
   26aae:	6dba      	ldr	r2, [r7, #88]	; 0x58
   26ab0:	f46f 7034 	mvn.w	r0, #720	; 0x2d0
   26ab4:	1810      	adds	r0, r2, r0
   26ab6:	b28c      	uxth	r4, r1
   26ab8:	b202      	sxth	r2, r0
   26aba:	fb02 f204 	mul.w	r2, r2, r4
   26abe:	fb11 f020 	smultb	r0, r1, r0
   26ac2:	13d2      	asrs	r2, r2, #15
   26ac4:	eb02 0040 	add.w	r0, r2, r0, lsl #1
   26ac8:	eb01 0140 	add.w	r1, r1, r0, lsl #1
   if (has_surround_mask&&!lfe)
   26acc:	b18d      	cbz	r5, 26af2 <celt_encode_with_ec+0x162a>
   26ace:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
   26ad2:	b972      	cbnz	r2, 26af2 <celt_encode_with_ec+0x162a>
      opus_int32 surround_target = target + (opus_int32)SHR32(MULT16_16(surround_masking,coded_bins<<BITRES), DB_SHIFT);
   26ad4:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
   26ad8:	6af8      	ldr	r0, [r7, #44]	; 0x2c
   26ada:	00d2      	lsls	r2, r2, #3
   26adc:	fb12 f200 	smulbb	r2, r2, r0
   26ae0:	eb01 22a2 	add.w	r2, r1, r2, asr #10
      target = IMAX(target/4, surround_target);
   26ae4:	2900      	cmp	r1, #0
   26ae6:	bfb8      	it	lt
   26ae8:	3103      	addlt	r1, #3
   26aea:	1089      	asrs	r1, r1, #2
   26aec:	4291      	cmp	r1, r2
   26aee:	bfb8      	it	lt
   26af0:	4611      	movlt	r1, r2
      bins = eBands[nbEBands-2]<<LM;
   26af2:	f10e 4200 	add.w	r2, lr, #2147483648	; 0x80000000
   26af6:	3a02      	subs	r2, #2
   26af8:	f8d7 410c 	ldr.w	r4, [r7, #268]	; 0x10c
   26afc:	f93c 2012 	ldrsh.w	r2, [ip, r2, lsl #1]
   26b00:	40a2      	lsls	r2, r4
      floor_depth = (opus_int32)SHR32(MULT16_16((C*bins<<BITRES),maxDepth), DB_SHIFT);
   26b02:	f8d7 4114 	ldr.w	r4, [r7, #276]	; 0x114
   26b06:	fb04 f202 	mul.w	r2, r4, r2
   26b0a:	6c7c      	ldr	r4, [r7, #68]	; 0x44
   26b0c:	00d2      	lsls	r2, r2, #3
   26b0e:	fb12 f204 	smulbb	r2, r2, r4
   26b12:	1292      	asrs	r2, r2, #10
      floor_depth = IMAX(floor_depth, target>>2);
   26b14:	1088      	asrs	r0, r1, #2
   26b16:	4282      	cmp	r2, r0
   26b18:	bfb8      	it	lt
   26b1a:	4602      	movlt	r2, r0
      target = IMIN(target, floor_depth);
   26b1c:	4291      	cmp	r1, r2
   26b1e:	bfa8      	it	ge
   26b20:	4611      	movge	r1, r2
   if ((!has_surround_mask||lfe) && constrained_vbr)
   26b22:	2d00      	cmp	r5, #0
   26b24:	f000 8799 	beq.w	27a5a <celt_encode_with_ec+0x2592>
   26b28:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
   26b2c:	b112      	cbz	r2, 26b34 <celt_encode_with_ec+0x166c>
   26b2e:	2b00      	cmp	r3, #0
   26b30:	f041 8778 	bne.w	28a24 <celt_encode_with_ec+0x355c>
     min_allowed = ((tell+total_boost+(1<<(BITRES+3))-1)>>(BITRES+3)) + 2;
   26b34:	eb0a 020b 	add.w	r2, sl, fp
   26b38:	323f      	adds	r2, #63	; 0x3f
     if(silence)
   26b3a:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
     min_allowed = ((tell+total_boost+(1<<(BITRES+3))-1)>>(BITRES+3)) + 2;
   26b3e:	1192      	asrs	r2, r2, #6
   target = IMIN(2*base_target, target);
   26b40:	0076      	lsls	r6, r6, #1
     min_allowed = ((tell+total_boost+(1<<(BITRES+3))-1)>>(BITRES+3)) + 2;
   26b42:	3202      	adds	r2, #2
     target=target+tell;
   26b44:	428e      	cmp	r6, r1
   26b46:	bfd4      	ite	le
   26b48:	eb0a 0106 	addle.w	r1, sl, r6
   26b4c:	4451      	addgt	r1, sl
     if(silence)
   26b4e:	2800      	cmp	r0, #0
   26b50:	f040 86ea 	bne.w	27928 <celt_encode_with_ec+0x2460>
     nbAvailableBytes = (target+(1<<(BITRES+2)))>>(BITRES+3);
   26b54:	f101 0620 	add.w	r6, r1, #32
   26b58:	11b6      	asrs	r6, r6, #6
     nbAvailableBytes = IMAX(min_allowed,nbAvailableBytes);
   26b5a:	42b2      	cmp	r2, r6
   26b5c:	bfb8      	it	lt
   26b5e:	4632      	movlt	r2, r6
     nbAvailableBytes = IMIN(nbCompressedBytes,nbAvailableBytes);
   26b60:	4542      	cmp	r2, r8
   26b62:	bfa8      	it	ge
   26b64:	4642      	movge	r2, r8
   26b66:	4616      	mov	r6, r2
     delta = target - vbr_rate;
   26b68:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
   26b6c:	1a8c      	subs	r4, r1, r2
     if (st->vbr_count < 970)
   26b6e:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
   26b72:	f8d2 20dc 	ldr.w	r2, [r2, #220]	; 0xdc
   26b76:	f240 31c9 	movw	r1, #969	; 0x3c9
   26b7a:	428a      	cmp	r2, r1
     target=nbAvailableBytes<<(BITRES+3);
   26b7c:	ea4f 1586 	mov.w	r5, r6, lsl #6
     if (st->vbr_count < 970)
   26b80:	f340 86e1 	ble.w	27946 <celt_encode_with_ec+0x247e>
        alpha = QCONST16(.001f,15);
   26b84:	2021      	movs	r0, #33	; 0x21
     if (st->constrained_vbr)
   26b86:	b363      	cbz	r3, 26be2 <celt_encode_with_ec+0x171a>
        st->vbr_drift += (opus_int32)MULT16_32_Q15(alpha,(delta*(1<<lm_diff))-st->vbr_offset-st->vbr_drift);
   26b88:	f8d7 112c 	ldr.w	r1, [r7, #300]	; 0x12c
   26b8c:	2301      	movs	r3, #1
   26b8e:	f8d1 20d8 	ldr.w	r2, [r1, #216]	; 0xd8
   26b92:	f8d1 10d4 	ldr.w	r1, [r1, #212]	; 0xd4
   26b96:	fa03 f309 	lsl.w	r3, r3, r9
   26b9a:	fb13 f304 	smulbb	r3, r3, r4
   26b9e:	1a9b      	subs	r3, r3, r2
   26ba0:	fa04 f409 	lsl.w	r4, r4, r9
   26ba4:	1aa4      	subs	r4, r4, r2
   26ba6:	1a5b      	subs	r3, r3, r1
   26ba8:	1a64      	subs	r4, r4, r1
   26baa:	b29b      	uxth	r3, r3
   26bac:	fb00 f303 	mul.w	r3, r0, r3
   26bb0:	1424      	asrs	r4, r4, #16
   26bb2:	fb00 f404 	mul.w	r4, r0, r4
   26bb6:	13db      	asrs	r3, r3, #15
        st->vbr_reservoir += target - vbr_rate;
   26bb8:	f8d7 012c 	ldr.w	r0, [r7, #300]	; 0x12c
        st->vbr_drift += (opus_int32)MULT16_32_Q15(alpha,(delta*(1<<lm_diff))-st->vbr_offset-st->vbr_drift);
   26bbc:	eb03 0244 	add.w	r2, r3, r4, lsl #1
        st->vbr_reservoir += target - vbr_rate;
   26bc0:	f8d7 40a0 	ldr.w	r4, [r7, #160]	; 0xa0
   26bc4:	f8d0 30d0 	ldr.w	r3, [r0, #208]	; 0xd0
   26bc8:	1b2d      	subs	r5, r5, r4
        st->vbr_drift += (opus_int32)MULT16_32_Q15(alpha,(delta*(1<<lm_diff))-st->vbr_offset-st->vbr_drift);
   26bca:	440a      	add	r2, r1
        st->vbr_reservoir += target - vbr_rate;
   26bcc:	442b      	add	r3, r5
        st->vbr_offset = -st->vbr_drift;
   26bce:	4251      	negs	r1, r2
     if (st->constrained_vbr && st->vbr_reservoir < 0)
   26bd0:	2b00      	cmp	r3, #0
        st->vbr_reservoir += target - vbr_rate;
   26bd2:	f8c0 30d0 	str.w	r3, [r0, #208]	; 0xd0
        st->vbr_drift += (opus_int32)MULT16_32_Q15(alpha,(delta*(1<<lm_diff))-st->vbr_offset-st->vbr_drift);
   26bd6:	f8c0 20d4 	str.w	r2, [r0, #212]	; 0xd4
        st->vbr_offset = -st->vbr_drift;
   26bda:	f8c0 10d8 	str.w	r1, [r0, #216]	; 0xd8
     if (st->constrained_vbr && st->vbr_reservoir < 0)
   26bde:	f2c1 8559 	blt.w	28694 <celt_encode_with_ec+0x31cc>
     nbCompressedBytes = IMIN(nbCompressedBytes,nbAvailableBytes);
   26be2:	4546      	cmp	r6, r8
   26be4:	4633      	mov	r3, r6
   26be6:	bfa8      	it	ge
   26be8:	4643      	movge	r3, r8
   26bea:	461c      	mov	r4, r3
     ec_enc_shrink(enc, nbCompressedBytes);
   26bec:	4619      	mov	r1, r3
   26bee:	f8d7 01cc 	ldr.w	r0, [r7, #460]	; 0x1cc
     nbCompressedBytes = IMIN(nbCompressedBytes,nbAvailableBytes);
   26bf2:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
     ec_enc_shrink(enc, nbCompressedBytes);
   26bf6:	f003 fa79 	bl	2a0ec <ec_enc_shrink>
   26bfa:	00e3      	lsls	r3, r4, #3
   26bfc:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
   ALLOC(fine_quant, nbEBands, int);
   26c00:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
   bits = (((opus_int32)nbCompressedBytes*8)<<BITRES) - ec_tell_frac(enc) - 1;
   26c04:	f8d7 01cc 	ldr.w	r0, [r7, #460]	; 0x1cc
   ALLOC(fine_quant, nbEBands, int);
   26c08:	f023 0407 	bic.w	r4, r3, #7
   26c0c:	ebad 0d04 	sub.w	sp, sp, r4
   26c10:	ad14      	add	r5, sp, #80	; 0x50
   ALLOC(pulses, nbEBands, int);
   26c12:	ebad 0d04 	sub.w	sp, sp, r4
   26c16:	f10d 0950 	add.w	r9, sp, #80	; 0x50
   ALLOC(fine_priority, nbEBands, int);
   26c1a:	ebad 0d04 	sub.w	sp, sp, r4
   bits = (((opus_int32)nbCompressedBytes*8)<<BITRES) - ec_tell_frac(enc) - 1;
   26c1e:	f002 fd85 	bl	2972c <ec_tell_frac>
   26c22:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
   26c26:	ea4f 1b83 	mov.w	fp, r3, lsl #6
   anti_collapse_rsv = isTransient&&LM>=2&&bits>=((LM+2)<<BITRES) ? (1<<BITRES) : 0;
   26c2a:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
   bits = (((opus_int32)nbCompressedBytes*8)<<BITRES) - ec_tell_frac(enc) - 1;
   26c2e:	43c2      	mvns	r2, r0
   26c30:	445a      	add	r2, fp
   ALLOC(fine_priority, nbEBands, int);
   26c32:	f10d 0a50 	add.w	sl, sp, #80	; 0x50
   anti_collapse_rsv = isTransient&&LM>=2&&bits>=((LM+2)<<BITRES) ? (1<<BITRES) : 0;
   26c36:	2b00      	cmp	r3, #0
   26c38:	f000 83b2 	beq.w	273a0 <celt_encode_with_ec+0x1ed8>
   26c3c:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
   26c40:	2b01      	cmp	r3, #1
   26c42:	dd07      	ble.n	26c54 <celt_encode_with_ec+0x178c>
   26c44:	3302      	adds	r3, #2
   26c46:	ebb2 0fc3 	cmp.w	r2, r3, lsl #3
   26c4a:	f280 8701 	bge.w	27a50 <celt_encode_with_ec+0x2588>
   26c4e:	e001      	b.n	26c54 <celt_encode_with_ec+0x178c>
   26c50:	00037a70 	.word	0x00037a70
   26c54:	f04f 0800 	mov.w	r8, #0
   if (st->lfe)
   26c58:	f8d7 112c 	ldr.w	r1, [r7, #300]	; 0x12c
   26c5c:	6c0b      	ldr	r3, [r1, #64]	; 0x40
      signalBandwidth = 1;
   26c5e:	2b00      	cmp	r3, #0
   26c60:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   26c62:	bf18      	it	ne
   26c64:	2301      	movne	r3, #1
   codedBands = clt_compute_allocation(mode, start, end, offsets, cap,
   26c66:	930e      	str	r3, [sp, #56]	; 0x38
   26c68:	6dcb      	ldr	r3, [r1, #92]	; 0x5c
   26c6a:	930d      	str	r3, [sp, #52]	; 0x34
   26c6c:	f8d7 41cc 	ldr.w	r4, [r7, #460]	; 0x1cc
   26c70:	f8c7 112c 	str.w	r1, [r7, #300]	; 0x12c
   26c74:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
   26c78:	940b      	str	r4, [sp, #44]	; 0x2c
   26c7a:	f8d7 410c 	ldr.w	r4, [r7, #268]	; 0x10c
   26c7e:	940a      	str	r4, [sp, #40]	; 0x28
   26c80:	f8d7 4114 	ldr.w	r4, [r7, #276]	; 0x114
   26c84:	e9cd a408 	strd	sl, r4, [sp, #32]
   26c88:	f507 74b6 	add.w	r4, r7, #364	; 0x16c
   26c8c:	e9cd 9506 	strd	r9, r5, [sp, #24]
   26c90:	e9cd 2404 	strd	r2, r4, [sp, #16]
   26c94:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
   26c98:	9201      	str	r2, [sp, #4]
   26c9a:	f507 709a 	add.w	r0, r7, #308	; 0x134
   26c9e:	31e8      	adds	r1, #232	; 0xe8
   26ca0:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
   26ca4:	9200      	str	r2, [sp, #0]
   26ca6:	e9cd 1002 	strd	r1, r0, [sp, #8]
   26caa:	2601      	movs	r6, #1
   26cac:	960c      	str	r6, [sp, #48]	; 0x30
   26cae:	f8d7 2124 	ldr.w	r2, [r7, #292]	; 0x124
   26cb2:	f8d7 1120 	ldr.w	r1, [r7, #288]	; 0x120
   26cb6:	f8d7 0100 	ldr.w	r0, [r7, #256]	; 0x100
   26cba:	f006 fca5 	bl	2d608 <clt_compute_allocation>
   if (st->lastCodedBands)
   26cbe:	f8d7 112c 	ldr.w	r1, [r7, #300]	; 0x12c
   26cc2:	6dca      	ldr	r2, [r1, #92]	; 0x5c
   codedBands = clt_compute_allocation(mode, start, end, offsets, cap,
   26cc4:	4606      	mov	r6, r0
   if (st->lastCodedBands)
   26cc6:	2a00      	cmp	r2, #0
   26cc8:	f000 8367 	beq.w	2739a <celt_encode_with_ec+0x1ed2>
      st->lastCodedBands = IMIN(st->lastCodedBands+1,IMAX(st->lastCodedBands-1,codedBands));
   26ccc:	1e53      	subs	r3, r2, #1
   26cce:	4283      	cmp	r3, r0
   26cd0:	f102 0201 	add.w	r2, r2, #1
   26cd4:	bfb8      	it	lt
   26cd6:	4603      	movlt	r3, r0
   26cd8:	4293      	cmp	r3, r2
   26cda:	bfa8      	it	ge
   26cdc:	4613      	movge	r3, r2
   26cde:	460a      	mov	r2, r1
   quant_fine_energy(mode, start, end, oldBandE, error, fine_quant, enc, C);
   26ce0:	f8d7 4114 	ldr.w	r4, [r7, #276]	; 0x114
   26ce4:	65d3      	str	r3, [r2, #92]	; 0x5c
   26ce6:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
   26cea:	9403      	str	r4, [sp, #12]
   26cec:	f8d7 11cc 	ldr.w	r1, [r7, #460]	; 0x1cc
   26cf0:	e9cd 5101 	strd	r5, r1, [sp, #4]
   26cf4:	f8d7 10dc 	ldr.w	r1, [r7, #220]	; 0xdc
   26cf8:	9100      	str	r1, [sp, #0]
   26cfa:	f8d7 1120 	ldr.w	r1, [r7, #288]	; 0x120
   26cfe:	f8d7 2124 	ldr.w	r2, [r7, #292]	; 0x124
   26d02:	f8d7 0100 	ldr.w	r0, [r7, #256]	; 0x100
   26d06:	f006 faf9 	bl	2d2fc <quant_fine_energy>
   ALLOC(collapse_masks, C*nbEBands, unsigned char);
   26d0a:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
   quant_all_bands(1, mode, start, end, X, C==2 ? X+N : NULL, collapse_masks,
   26d0e:	f8d7 012c 	ldr.w	r0, [r7, #300]	; 0x12c
   26d12:	2c02      	cmp	r4, #2
   ALLOC(collapse_masks, C*nbEBands, unsigned char);
   26d14:	f103 0307 	add.w	r3, r3, #7
   quant_all_bands(1, mode, start, end, X, C==2 ? X+N : NULL, collapse_masks,
   26d18:	bf08      	it	eq
   26d1a:	f8d7 10f0 	ldreq.w	r1, [r7, #240]	; 0xf0
   26d1e:	4622      	mov	r2, r4
   ALLOC(collapse_masks, C*nbEBands, unsigned char);
   26d20:	f023 0307 	bic.w	r3, r3, #7
   quant_all_bands(1, mode, start, end, X, C==2 ? X+N : NULL, collapse_masks,
   26d24:	bf08      	it	eq
   26d26:	f8d7 20b4 	ldreq.w	r2, [r7, #180]	; 0xb4
   ALLOC(collapse_masks, C*nbEBands, unsigned char);
   26d2a:	ebad 0d03 	sub.w	sp, sp, r3
   quant_all_bands(1, mode, start, end, X, C==2 ? X+N : NULL, collapse_masks,
   26d2e:	bf08      	it	eq
   26d30:	eb02 0141 	addeq.w	r1, r2, r1, lsl #1
   26d34:	6c42      	ldr	r2, [r0, #68]	; 0x44
   26d36:	9212      	str	r2, [sp, #72]	; 0x48
   26d38:	6c82      	ldr	r2, [r0, #72]	; 0x48
   26d3a:	9211      	str	r2, [sp, #68]	; 0x44
   26d3c:	6982      	ldr	r2, [r0, #24]
   26d3e:	9210      	str	r2, [sp, #64]	; 0x40
   26d40:	960e      	str	r6, [sp, #56]	; 0x38
   26d42:	f8d7 410c 	ldr.w	r4, [r7, #268]	; 0x10c
   26d46:	940d      	str	r4, [sp, #52]	; 0x34
   26d48:	4602      	mov	r2, r0
   26d4a:	f8d7 41cc 	ldr.w	r4, [r7, #460]	; 0x1cc
   26d4e:	940c      	str	r4, [sp, #48]	; 0x30
   26d50:	f102 024c 	add.w	r2, r2, #76	; 0x4c
   26d54:	920f      	str	r2, [sp, #60]	; 0x3c
   26d56:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
         dual_stereo, st->intensity, tf_res, nbCompressedBytes*(8<<BITRES)-anti_collapse_rsv,
   26d5a:	ebab 0408 	sub.w	r4, fp, r8
   quant_all_bands(1, mode, start, end, X, C==2 ? X+N : NULL, collapse_masks,
   26d5e:	e9cd 420a 	strd	r4, r2, [sp, #40]	; 0x28
   26d62:	f8d7 20cc 	ldr.w	r2, [r7, #204]	; 0xcc
   26d66:	9209      	str	r2, [sp, #36]	; 0x24
   26d68:	f8d0 20e8 	ldr.w	r2, [r0, #232]	; 0xe8
   26d6c:	9208      	str	r2, [sp, #32]
   26d6e:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
   26d72:	9207      	str	r2, [sp, #28]
   26d74:	6d02      	ldr	r2, [r0, #80]	; 0x50
   26d76:	9206      	str	r2, [sp, #24]
   26d78:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
   26d7c:	e9cd 9204 	strd	r9, r2, [sp, #16]
   26d80:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
   26d84:	bf18      	it	ne
   26d86:	2100      	movne	r1, #0
   ALLOC(collapse_masks, C*nbEBands, unsigned char);
   26d88:	ab14      	add	r3, sp, #80	; 0x50
   quant_all_bands(1, mode, start, end, X, C==2 ? X+N : NULL, collapse_masks,
   26d8a:	e9cd 3202 	strd	r3, r2, [sp, #8]
   26d8e:	9101      	str	r1, [sp, #4]
   26d90:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
   26d94:	9300      	str	r3, [sp, #0]
   26d96:	4604      	mov	r4, r0
   26d98:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
   26d9c:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
   26da0:	f8d7 1100 	ldr.w	r1, [r7, #256]	; 0x100
   26da4:	2001      	movs	r0, #1
   26da6:	f7fb fbff 	bl	225a8 <quant_all_bands>
   if (anti_collapse_rsv > 0)
   26daa:	f1b8 0f00 	cmp.w	r8, #0
   26dae:	d009      	beq.n	26dc4 <celt_encode_with_ec+0x18fc>
      anti_collapse_on = st->consec_transient<2;
   26db0:	6f61      	ldr	r1, [r4, #116]	; 0x74
      ec_enc_bits(enc, anti_collapse_on, 1);
   26db2:	f8d7 01cc 	ldr.w	r0, [r7, #460]	; 0x1cc
   26db6:	2201      	movs	r2, #1
   26db8:	4291      	cmp	r1, r2
   26dba:	bfcc      	ite	gt
   26dbc:	2100      	movgt	r1, #0
   26dbe:	2101      	movle	r1, #1
   26dc0:	f003 f928 	bl	2a014 <ec_enc_bits>
   26dc4:	f8d7 31cc 	ldr.w	r3, [r7, #460]	; 0x1cc
   26dc8:	69da      	ldr	r2, [r3, #28]
   quant_energy_finalise(mode, start, end, oldBandE, error, fine_quant, fine_priority, nbCompressedBytes*8-ec_tell(enc), enc, C);
   26dca:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
   26dce:	9305      	str	r3, [sp, #20]
   26dd0:	f8d7 11cc 	ldr.w	r1, [r7, #460]	; 0x1cc
   26dd4:	9104      	str	r1, [sp, #16]
   26dd6:	f8d7 11cc 	ldr.w	r1, [r7, #460]	; 0x1cc
   26dda:	fab2 f282 	clz	r2, r2
   26dde:	694b      	ldr	r3, [r1, #20]
   26de0:	f8cd a008 	str.w	sl, [sp, #8]
   26de4:	f1c2 0220 	rsb	r2, r2, #32
   26de8:	1a9b      	subs	r3, r3, r2
   26dea:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
   26dee:	f8d7 0100 	ldr.w	r0, [r7, #256]	; 0x100
   26df2:	9501      	str	r5, [sp, #4]
   26df4:	1ad3      	subs	r3, r2, r3
   26df6:	9303      	str	r3, [sp, #12]
   26df8:	f8d7 50dc 	ldr.w	r5, [r7, #220]	; 0xdc
   26dfc:	9500      	str	r5, [sp, #0]
   26dfe:	f8d7 6124 	ldr.w	r6, [r7, #292]	; 0x124
   26e02:	f8d7 4120 	ldr.w	r4, [r7, #288]	; 0x120
   26e06:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
   26e0a:	4632      	mov	r2, r6
   26e0c:	4621      	mov	r1, r4
   26e0e:	f006 facd 	bl	2d3ac <quant_energy_finalise>
   OPUS_CLEAR(energyError, nbEBands*CC);
   26e12:	f8d7 a07c 	ldr.w	sl, [r7, #124]	; 0x7c
   26e16:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
   26e1a:	2100      	movs	r1, #0
   26e1c:	4650      	mov	r0, sl
   26e1e:	f00e f9a1 	bl	35164 <memset>
   26e22:	42b4      	cmp	r4, r6
   26e24:	4631      	mov	r1, r6
   26e26:	da29      	bge.n	26e7c <celt_encode_with_ec+0x19b4>
   26e28:	0066      	lsls	r6, r4, #1
   26e2a:	4652      	mov	r2, sl
   26e2c:	4432      	add	r2, r6
   26e2e:	4435      	add	r5, r6
   26e30:	4616      	mov	r6, r2
   26e32:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
   c=0;
   26e36:	f8d7 9114 	ldr.w	r9, [r7, #276]	; 0x114
   26e3a:	eba1 0804 	sub.w	r8, r1, r4
         energyError[i+c*nbEBands] = MAX16(-QCONST16(0.5f, 15), MIN16(QCONST16(0.5f, 15), error[i+c*nbEBands]));
   26e3e:	4c50      	ldr	r4, [pc, #320]	; (26f80 <celt_encode_with_ec+0x1ab8>)
   26e40:	ea4f 0848 	mov.w	r8, r8, lsl #1
   26e44:	ea4f 0e42 	mov.w	lr, r2, lsl #1
   c=0;
   26e48:	f04f 0c00 	mov.w	ip, #0
   26e4c:	eb08 0005 	add.w	r0, r8, r5
   26e50:	4631      	mov	r1, r6
   26e52:	462a      	mov	r2, r5
         energyError[i+c*nbEBands] = MAX16(-QCONST16(0.5f, 15), MIN16(QCONST16(0.5f, 15), error[i+c*nbEBands]));
   26e54:	f932 3b02 	ldrsh.w	r3, [r2], #2
   26e58:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
   26e5c:	bfa8      	it	ge
   26e5e:	f44f 4380 	movge.w	r3, #16384	; 0x4000
   26e62:	42a3      	cmp	r3, r4
   26e64:	bfb8      	it	lt
   26e66:	4623      	movlt	r3, r4
      for (i=start;i<end;i++)
   26e68:	4290      	cmp	r0, r2
         energyError[i+c*nbEBands] = MAX16(-QCONST16(0.5f, 15), MIN16(QCONST16(0.5f, 15), error[i+c*nbEBands]));
   26e6a:	f821 3b02 	strh.w	r3, [r1], #2
      for (i=start;i<end;i++)
   26e6e:	d1f1      	bne.n	26e54 <celt_encode_with_ec+0x198c>
   } while (++c < C);
   26e70:	f10c 0c01 	add.w	ip, ip, #1
   26e74:	45e1      	cmp	r9, ip
   26e76:	4475      	add	r5, lr
   26e78:	4476      	add	r6, lr
   26e7a:	dce7      	bgt.n	26e4c <celt_encode_with_ec+0x1984>
   if (silence)
   26e7c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
   26e80:	2b00      	cmp	r3, #0
   26e82:	f000 8283 	beq.w	2738c <celt_encode_with_ec+0x1ec4>
      for (i=0;i<C*nbEBands;i++)
   26e86:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
   26e8a:	2b00      	cmp	r3, #0
   26e8c:	f340 827e 	ble.w	2738c <celt_encode_with_ec+0x1ec4>
   26e90:	3b01      	subs	r3, #1
   26e92:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
   26e96:	2b04      	cmp	r3, #4
   26e98:	f3c2 0140 	ubfx	r1, r2, #1, #1
   26e9c:	f241 85a6 	bls.w	289ec <celt_encode_with_ec+0x3524>
   26ea0:	2900      	cmp	r1, #0
   26ea2:	f001 83f2 	beq.w	2868a <celt_encode_with_ec+0x31c2>
         oldBandE[i] = -QCONST16(28.f,DB_SHIFT);
   26ea6:	6f38      	ldr	r0, [r7, #112]	; 0x70
   26ea8:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
   26eac:	f44f 4310 	mov.w	r3, #36864	; 0x9000
   26eb0:	f822 3020 	strh.w	r3, [r2, r0, lsl #2]
   26eb4:	4603      	mov	r3, r0
   26eb6:	005c      	lsls	r4, r3, #1
   26eb8:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
   26ebc:	f104 027a 	add.w	r2, r4, #122	; 0x7a
   26ec0:	440a      	add	r2, r1
   26ec2:	1a59      	subs	r1, r3, r1
   26ec4:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
   26ec8:	084d      	lsrs	r5, r1, #1
   26eca:	eb03 0242 	add.w	r2, r3, r2, lsl #1
   26ece:	f04f 2090 	mov.w	r0, #2415955968	; 0x90009000
      for (i=0;i<C*nbEBands;i++)
   26ed2:	2300      	movs	r3, #0
   26ed4:	3301      	adds	r3, #1
   26ed6:	42ab      	cmp	r3, r5
         oldBandE[i] = -QCONST16(28.f,DB_SHIFT);
   26ed8:	f842 0b04 	str.w	r0, [r2], #4
   26edc:	d3fa      	bcc.n	26ed4 <celt_encode_with_ec+0x1a0c>
   26ede:	f021 0201 	bic.w	r2, r1, #1
   26ee2:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
   26ee6:	428a      	cmp	r2, r1
   26ee8:	4413      	add	r3, r2
   26eea:	d01c      	beq.n	26f26 <celt_encode_with_ec+0x1a5e>
      for (i=0;i<C*nbEBands;i++)
   26eec:	f8d7 50c0 	ldr.w	r5, [r7, #192]	; 0xc0
         oldBandE[i] = -QCONST16(28.f,DB_SHIFT);
   26ef0:	f8d7 2110 	ldr.w	r2, [r7, #272]	; 0x110
      for (i=0;i<C*nbEBands;i++)
   26ef4:	1c58      	adds	r0, r3, #1
         oldBandE[i] = -QCONST16(28.f,DB_SHIFT);
   26ef6:	f44f 4110 	mov.w	r1, #36864	; 0x9000
      for (i=0;i<C*nbEBands;i++)
   26efa:	42a8      	cmp	r0, r5
         oldBandE[i] = -QCONST16(28.f,DB_SHIFT);
   26efc:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
   26f00:	ea4f 0243 	mov.w	r2, r3, lsl #1
      for (i=0;i<C*nbEBands;i++)
   26f04:	da0f      	bge.n	26f26 <celt_encode_with_ec+0x1a5e>
         oldBandE[i] = -QCONST16(28.f,DB_SHIFT);
   26f06:	f8d7 0110 	ldr.w	r0, [r7, #272]	; 0x110
   26f0a:	4402      	add	r2, r0
      for (i=0;i<C*nbEBands;i++)
   26f0c:	1c98      	adds	r0, r3, #2
   26f0e:	42a8      	cmp	r0, r5
         oldBandE[i] = -QCONST16(28.f,DB_SHIFT);
   26f10:	8051      	strh	r1, [r2, #2]
      for (i=0;i<C*nbEBands;i++)
   26f12:	da08      	bge.n	26f26 <celt_encode_with_ec+0x1a5e>
   26f14:	1cd8      	adds	r0, r3, #3
   26f16:	42a8      	cmp	r0, r5
         oldBandE[i] = -QCONST16(28.f,DB_SHIFT);
   26f18:	8091      	strh	r1, [r2, #4]
      for (i=0;i<C*nbEBands;i++)
   26f1a:	da04      	bge.n	26f26 <celt_encode_with_ec+0x1a5e>
   26f1c:	3304      	adds	r3, #4
   26f1e:	42ab      	cmp	r3, r5
         oldBandE[i] = -QCONST16(28.f,DB_SHIFT);
   26f20:	80d1      	strh	r1, [r2, #6]
      for (i=0;i<C*nbEBands;i++)
   26f22:	da00      	bge.n	26f26 <celt_encode_with_ec+0x1a5e>
         oldBandE[i] = -QCONST16(28.f,DB_SHIFT);
   26f24:	8111      	strh	r1, [r2, #8]
   st->prefilter_period = pitch_index;
   26f26:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
   26f2a:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
   26f2c:	6699      	str	r1, [r3, #104]	; 0x68
   st->prefilter_tapset = prefilter_tapset;
   26f2e:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
   st->prefilter_gain = gain1;
   26f32:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
   26f34:	f8a3 106c 	strh.w	r1, [r3, #108]	; 0x6c
   st->prefilter_tapset = prefilter_tapset;
   26f38:	671a      	str	r2, [r3, #112]	; 0x70
   if (CC==2&&C==1) {
   26f3a:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
   26f3e:	2b02      	cmp	r3, #2
   26f40:	f000 8367 	beq.w	27612 <celt_encode_with_ec+0x214a>
   if (!isTransient)
   26f44:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
   26f48:	2b00      	cmp	r3, #0
   26f4a:	f000 8371 	beq.w	27630 <celt_encode_with_ec+0x2168>
      for (i=0;i<CC*nbEBands;i++)
   26f4e:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
   26f52:	2b00      	cmp	r3, #0
   26f54:	dd16      	ble.n	26f84 <celt_encode_with_ec+0x1abc>
   26f56:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
   26f5a:	1e98      	subs	r0, r3, #2
   26f5c:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
   26f60:	4418      	add	r0, r3
   26f62:	1e99      	subs	r1, r3, #2
   26f64:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
   26f68:	1e9a      	subs	r2, r3, #2
         oldLogE[i] = MIN16(oldLogE[i], oldBandE[i]);
   26f6a:	f931 3f02 	ldrsh.w	r3, [r1, #2]!
   26f6e:	f932 5f02 	ldrsh.w	r5, [r2, #2]!
   26f72:	42ab      	cmp	r3, r5
   26f74:	bfa8      	it	ge
   26f76:	462b      	movge	r3, r5
      for (i=0;i<CC*nbEBands;i++)
   26f78:	4288      	cmp	r0, r1
         oldLogE[i] = MIN16(oldLogE[i], oldBandE[i]);
   26f7a:	8013      	strh	r3, [r2, #0]
      for (i=0;i<CC*nbEBands;i++)
   26f7c:	d1f5      	bne.n	26f6a <celt_encode_with_ec+0x1aa2>
   26f7e:	e001      	b.n	26f84 <celt_encode_with_ec+0x1abc>
   26f80:	ffffc000 	.word	0xffffc000
   26f84:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
   26f88:	4423      	add	r3, r4
   26f8a:	461a      	mov	r2, r3
   26f8c:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
   26f90:	f102 017c 	add.w	r1, r2, #124	; 0x7c
   26f94:	4423      	add	r3, r4
   26f96:	327a      	adds	r2, #122	; 0x7a
   26f98:	f8c7 20fc 	str.w	r2, [r7, #252]	; 0xfc
   26f9c:	f103 027a 	add.w	r2, r3, #122	; 0x7a
   26fa0:	337c      	adds	r3, #124	; 0x7c
   26fa2:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
   26fa6:	f104 037a 	add.w	r3, r4, #122	; 0x7a
      for (i=0;i<C*nbEBands;i++)
   26faa:	2500      	movs	r5, #0
   26fac:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
   26fb0:	f104 037c 	add.w	r3, r4, #124	; 0x7c
   26fb4:	f8c7 5128 	str.w	r5, [r7, #296]	; 0x128
   26fb8:	f8c7 110c 	str.w	r1, [r7, #268]	; 0x10c
   26fbc:	f8c7 2104 	str.w	r2, [r7, #260]	; 0x104
   26fc0:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
      for (i=0;i<start;i++)
   26fc4:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
   26fc8:	2b00      	cmp	r3, #0
   26fca:	f340 80a7 	ble.w	2711c <celt_encode_with_ec+0x1c54>
         oldBandE[c*nbEBands+i]=0;
   26fce:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
   26fd2:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
   26fd6:	f8d7 10ec 	ldr.w	r1, [r7, #236]	; 0xec
   26fda:	f8d7 6100 	ldr.w	r6, [r7, #256]	; 0x100
   26fde:	fb03 f302 	mul.w	r3, r3, r2
   26fe2:	f8d7 210c 	ldr.w	r2, [r7, #268]	; 0x10c
   26fe6:	eb02 0803 	add.w	r8, r2, r3
   26fea:	f8d7 20f0 	ldr.w	r2, [r7, #240]	; 0xf0
   26fee:	eb01 0903 	add.w	r9, r1, r3
   26ff2:	18d0      	adds	r0, r2, r3
   26ff4:	f8d7 1104 	ldr.w	r1, [r7, #260]	; 0x104
   26ff8:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
   26ffc:	ea4f 0848 	mov.w	r8, r8, lsl #1
   27000:	0044      	lsls	r4, r0, #1
   27002:	4544      	cmp	r4, r8
   27004:	eb02 0b03 	add.w	fp, r2, r3
   27008:	4419      	add	r1, r3
   2700a:	441e      	add	r6, r3
   2700c:	ea4f 0e4b 	mov.w	lr, fp, lsl #1
   27010:	bfb4      	ite	lt
   27012:	f04f 0c00 	movlt.w	ip, #0
   27016:	f04f 0c01 	movge.w	ip, #1
   2701a:	ea4f 0949 	mov.w	r9, r9, lsl #1
   2701e:	ea4f 0a41 	mov.w	sl, r1, lsl #1
   27022:	0076      	lsls	r6, r6, #1
   27024:	45f1      	cmp	r9, lr
   27026:	bfd8      	it	le
   27028:	f04c 0c01 	orrle.w	ip, ip, #1
   2702c:	45c2      	cmp	sl, r8
   2702e:	bfb8      	it	lt
   27030:	45b6      	cmplt	lr, r6
   27032:	bfac      	ite	ge
   27034:	f04f 0e01 	movge.w	lr, #1
   27038:	f04f 0e00 	movlt.w	lr, #0
   2703c:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
   27040:	ea0c 0e0e 	and.w	lr, ip, lr
   27044:	2a0c      	cmp	r2, #12
   27046:	bf94      	ite	ls
   27048:	f04f 0e00 	movls.w	lr, #0
   2704c:	f00e 0e01 	andhi.w	lr, lr, #1
   27050:	f1be 0f00 	cmp.w	lr, #0
   27054:	f000 8177 	beq.w	27346 <celt_encode_with_ec+0x1e7e>
   27058:	42b4      	cmp	r4, r6
   2705a:	bfb4      	ite	lt
   2705c:	2600      	movlt	r6, #0
   2705e:	2601      	movge	r6, #1
   27060:	45d1      	cmp	r9, sl
   27062:	bfd8      	it	le
   27064:	f046 0601 	orrle.w	r6, r6, #1
   27068:	2e00      	cmp	r6, #0
   2706a:	f000 816c 	beq.w	27346 <celt_encode_with_ec+0x1e7e>
   2706e:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
   27072:	4414      	add	r4, r2
   27074:	f3c4 0440 	ubfx	r4, r4, #1, #1
   27078:	2c00      	cmp	r4, #0
   2707a:	f000 8148 	beq.w	2730e <celt_encode_with_ec+0x1e46>
   2707e:	f8d7 2110 	ldr.w	r2, [r7, #272]	; 0x110
   27082:	f822 5013 	strh.w	r5, [r2, r3, lsl #1]
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
   27086:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
   2708a:	f44f 4610 	mov.w	r6, #36864	; 0x9000
   2708e:	f822 6013 	strh.w	r6, [r2, r3, lsl #1]
   27092:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
   27096:	f822 6013 	strh.w	r6, [r2, r3, lsl #1]
      for (i=0;i<start;i++)
   2709a:	2601      	movs	r6, #1
   2709c:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
   270a0:	eb0b 0e04 	add.w	lr, fp, r4
   270a4:	eba2 0c04 	sub.w	ip, r2, r4
   270a8:	4420      	add	r0, r4
   270aa:	4421      	add	r1, r4
   270ac:	f8d7 412c 	ldr.w	r4, [r7, #300]	; 0x12c
   270b0:	ea4f 085c 	mov.w	r8, ip, lsr #1
   270b4:	eb04 024e 	add.w	r2, r4, lr, lsl #1
   270b8:	eb04 0040 	add.w	r0, r4, r0, lsl #1
   270bc:	eb04 0141 	add.w	r1, r4, r1, lsl #1
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
   270c0:	f04f 2e90 	mov.w	lr, #2415955968	; 0x90009000
      for (i=0;i<start;i++)
   270c4:	2400      	movs	r4, #0
   270c6:	3401      	adds	r4, #1
   270c8:	4544      	cmp	r4, r8
         oldBandE[c*nbEBands+i]=0;
   270ca:	f840 5b04 	str.w	r5, [r0], #4
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
   270ce:	f842 eb04 	str.w	lr, [r2], #4
   270d2:	f841 eb04 	str.w	lr, [r1], #4
   270d6:	d3f6      	bcc.n	270c6 <celt_encode_with_ec+0x1bfe>
   270d8:	f02c 0201 	bic.w	r2, ip, #1
   270dc:	4562      	cmp	r2, ip
   270de:	4416      	add	r6, r2
   270e0:	d01c      	beq.n	2711c <celt_encode_with_ec+0x1c54>
         oldBandE[c*nbEBands+i]=0;
   270e2:	199a      	adds	r2, r3, r6
   270e4:	f8d7 4110 	ldr.w	r4, [r7, #272]	; 0x110
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
   270e8:	f8d7 10f8 	ldr.w	r1, [r7, #248]	; 0xf8
         oldBandE[c*nbEBands+i]=0;
   270ec:	f824 5012 	strh.w	r5, [r4, r2, lsl #1]
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
   270f0:	f8d7 40f4 	ldr.w	r4, [r7, #244]	; 0xf4
   270f4:	f44f 4c10 	mov.w	ip, #36864	; 0x9000
   270f8:	f824 c012 	strh.w	ip, [r4, r2, lsl #1]
   270fc:	f821 c012 	strh.w	ip, [r1, r2, lsl #1]
      for (i=0;i<start;i++)
   27100:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
   27104:	3601      	adds	r6, #1
   27106:	42b2      	cmp	r2, r6
   27108:	dd08      	ble.n	2711c <celt_encode_with_ec+0x1c54>
         oldBandE[c*nbEBands+i]=0;
   2710a:	441e      	add	r6, r3
   2710c:	f8d7 0110 	ldr.w	r0, [r7, #272]	; 0x110
   27110:	f820 5016 	strh.w	r5, [r0, r6, lsl #1]
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
   27114:	f824 c016 	strh.w	ip, [r4, r6, lsl #1]
   27118:	f821 c016 	strh.w	ip, [r1, r6, lsl #1]
      for (i=end;i<nbEBands;i++)
   2711c:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
   27120:	f8d7 2124 	ldr.w	r2, [r7, #292]	; 0x124
   27124:	4293      	cmp	r3, r2
   27126:	f340 80b3 	ble.w	27290 <celt_encode_with_ec+0x1dc8>
         oldBandE[c*nbEBands+i]=0;
   2712a:	f8d7 1128 	ldr.w	r1, [r7, #296]	; 0x128
   2712e:	f8d7 40fc 	ldr.w	r4, [r7, #252]	; 0xfc
   27132:	fb03 fc01 	mul.w	ip, r3, r1
   27136:	461a      	mov	r2, r3
   27138:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
   2713c:	f8d7 110c 	ldr.w	r1, [r7, #268]	; 0x10c
   27140:	eb0c 0003 	add.w	r0, ip, r3
   27144:	eb04 0b00 	add.w	fp, r4, r0
   27148:	f8d7 40ec 	ldr.w	r4, [r7, #236]	; 0xec
   2714c:	eb01 0e00 	add.w	lr, r1, r0
   27150:	eb04 0800 	add.w	r8, r4, r0
   27154:	f8d7 10f0 	ldr.w	r1, [r7, #240]	; 0xf0
   27158:	f8d7 4104 	ldr.w	r4, [r7, #260]	; 0x104
   2715c:	180b      	adds	r3, r1, r0
   2715e:	1821      	adds	r1, r4, r0
   27160:	f8d7 4100 	ldr.w	r4, [r7, #256]	; 0x100
   27164:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
   27168:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
   2716c:	005b      	lsls	r3, r3, #1
   2716e:	4573      	cmp	r3, lr
   27170:	eb04 0600 	add.w	r6, r4, r0
   27174:	bfb8      	it	lt
   27176:	f04f 0900 	movlt.w	r9, #0
   2717a:	ea4f 044b 	mov.w	r4, fp, lsl #1
   2717e:	bfa8      	it	ge
   27180:	f04f 0901 	movge.w	r9, #1
   27184:	ea4f 0a41 	mov.w	sl, r1, lsl #1
   27188:	ea4f 0848 	mov.w	r8, r8, lsl #1
   2718c:	0076      	lsls	r6, r6, #1
   2718e:	45a0      	cmp	r8, r4
   27190:	bfd8      	it	le
   27192:	f049 0901 	orrle.w	r9, r9, #1
   27196:	f8c7 10e4 	str.w	r1, [r7, #228]	; 0xe4
   2719a:	45f2      	cmp	sl, lr
   2719c:	bfb8      	it	lt
   2719e:	42b4      	cmplt	r4, r6
   271a0:	f8d7 1124 	ldr.w	r1, [r7, #292]	; 0x124
   271a4:	bfac      	ite	ge
   271a6:	2401      	movge	r4, #1
   271a8:	2400      	movlt	r4, #0
   271aa:	4696      	mov	lr, r2
   271ac:	ea09 0404 	and.w	r4, r9, r4
   271b0:	ebae 0e01 	sub.w	lr, lr, r1
   271b4:	f1be 0f0c 	cmp.w	lr, #12
   271b8:	bf94      	ite	ls
   271ba:	2400      	movls	r4, #0
   271bc:	f004 0401 	andhi.w	r4, r4, #1
   271c0:	2c00      	cmp	r4, #0
   271c2:	f000 80a6 	beq.w	27312 <celt_encode_with_ec+0x1e4a>
   271c6:	42b3      	cmp	r3, r6
   271c8:	bfb4      	ite	lt
   271ca:	2600      	movlt	r6, #0
   271cc:	2601      	movge	r6, #1
   271ce:	45d0      	cmp	r8, sl
   271d0:	bfd8      	it	le
   271d2:	f046 0601 	orrle.w	r6, r6, #1
   271d6:	2e00      	cmp	r6, #0
   271d8:	f000 809b 	beq.w	27312 <celt_encode_with_ec+0x1e4a>
   271dc:	f8d7 412c 	ldr.w	r4, [r7, #300]	; 0x12c
   271e0:	4423      	add	r3, r4
   271e2:	f3c3 0340 	ubfx	r3, r3, #1, #1
   271e6:	2b00      	cmp	r3, #0
   271e8:	f000 808f 	beq.w	2730a <celt_encode_with_ec+0x1e42>
   271ec:	f8d7 6110 	ldr.w	r6, [r7, #272]	; 0x110
   271f0:	f826 5010 	strh.w	r5, [r6, r0, lsl #1]
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
   271f4:	f8d7 60f4 	ldr.w	r6, [r7, #244]	; 0xf4
   271f8:	f44f 4410 	mov.w	r4, #36864	; 0x9000
   271fc:	f826 4010 	strh.w	r4, [r6, r0, lsl #1]
   27200:	f8d7 60f8 	ldr.w	r6, [r7, #248]	; 0xf8
   27204:	f826 4010 	strh.w	r4, [r6, r0, lsl #1]
      for (i=end;i<nbEBands;i++)
   27208:	1c48      	adds	r0, r1, #1
   2720a:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
   2720e:	441a      	add	r2, r3
   27210:	4611      	mov	r1, r2
   27212:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
   27216:	ebae 0e03 	sub.w	lr, lr, r3
   2721a:	441a      	add	r2, r3
   2721c:	449b      	add	fp, r3
   2721e:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
   27222:	ea4f 065e 	mov.w	r6, lr, lsr #1
   27226:	eb03 0141 	add.w	r1, r3, r1, lsl #1
   2722a:	eb03 0242 	add.w	r2, r3, r2, lsl #1
   2722e:	eb03 0b4b 	add.w	fp, r3, fp, lsl #1
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
   27232:	f04f 2490 	mov.w	r4, #2415955968	; 0x90009000
         oldBandE[c*nbEBands+i]=0;
   27236:	2300      	movs	r3, #0
   27238:	3301      	adds	r3, #1
   2723a:	42b3      	cmp	r3, r6
   2723c:	f841 5b04 	str.w	r5, [r1], #4
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
   27240:	f84b 4b04 	str.w	r4, [fp], #4
   27244:	f842 4b04 	str.w	r4, [r2], #4
   27248:	d3f6      	bcc.n	27238 <celt_encode_with_ec+0x1d70>
   2724a:	f02e 0301 	bic.w	r3, lr, #1
   2724e:	4573      	cmp	r3, lr
   27250:	4418      	add	r0, r3
   27252:	d01d      	beq.n	27290 <celt_encode_with_ec+0x1dc8>
         oldBandE[c*nbEBands+i]=0;
   27254:	eb0c 0300 	add.w	r3, ip, r0
   27258:	f8d7 4110 	ldr.w	r4, [r7, #272]	; 0x110
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
   2725c:	f8d7 60f8 	ldr.w	r6, [r7, #248]	; 0xf8
         oldBandE[c*nbEBands+i]=0;
   27260:	f824 5013 	strh.w	r5, [r4, r3, lsl #1]
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
   27264:	f8d7 40f4 	ldr.w	r4, [r7, #244]	; 0xf4
   27268:	f44f 4210 	mov.w	r2, #36864	; 0x9000
   2726c:	f824 2013 	strh.w	r2, [r4, r3, lsl #1]
   27270:	f826 2013 	strh.w	r2, [r6, r3, lsl #1]
      for (i=end;i<nbEBands;i++)
   27274:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
   27278:	3001      	adds	r0, #1
   2727a:	4283      	cmp	r3, r0
   2727c:	dd08      	ble.n	27290 <celt_encode_with_ec+0x1dc8>
         oldBandE[c*nbEBands+i]=0;
   2727e:	4460      	add	r0, ip
   27280:	f8d7 1110 	ldr.w	r1, [r7, #272]	; 0x110
   27284:	f821 5010 	strh.w	r5, [r1, r0, lsl #1]
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
   27288:	f824 2010 	strh.w	r2, [r4, r0, lsl #1]
   2728c:	f826 2010 	strh.w	r2, [r6, r0, lsl #1]
   } while (++c<CC);
   27290:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
   27294:	2201      	movs	r2, #1
   27296:	2b00      	cmp	r3, #0
   27298:	f8c7 2128 	str.w	r2, [r7, #296]	; 0x128
   2729c:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
   272a0:	bf0c      	ite	eq
   272a2:	2301      	moveq	r3, #1
   272a4:	2302      	movne	r3, #2
   272a6:	429a      	cmp	r2, r3
   272a8:	f73f ae8c 	bgt.w	26fc4 <celt_encode_with_ec+0x1afc>
   if (isTransient || transient_got_disabled)
   272ac:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
   272b0:	b913      	cbnz	r3, 272b8 <celt_encode_with_ec+0x1df0>
   272b2:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
   272b6:	b12b      	cbz	r3, 272c4 <celt_encode_with_ec+0x1dfc>
      st->consec_transient++;
   272b8:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
   272bc:	6f5b      	ldr	r3, [r3, #116]	; 0x74
   272be:	3301      	adds	r3, #1
   272c0:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
   st->rng = enc->rng;
   272c4:	f8d7 31cc 	ldr.w	r3, [r7, #460]	; 0x1cc
   272c8:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
   272cc:	f8d7 0094 	ldr.w	r0, [r7, #148]	; 0x94
   272d0:	69db      	ldr	r3, [r3, #28]
   272d2:	6750      	str	r0, [r2, #116]	; 0x74
   272d4:	64d3      	str	r3, [r2, #76]	; 0x4c
   ec_enc_done(enc);
   272d6:	f8d7 01cc 	ldr.w	r0, [r7, #460]	; 0x1cc
   272da:	f002 ff15 	bl	2a108 <ec_enc_done>
   if (ec_get_error(enc))
   272de:	f8d7 31cc 	ldr.w	r3, [r7, #460]	; 0x1cc
   272e2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   272e4:	f8d7 d050 	ldr.w	sp, [r7, #80]	; 0x50
      return OPUS_INTERNAL_ERROR;
   272e8:	2b00      	cmp	r3, #0
   272ea:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
   272ee:	bf18      	it	ne
   272f0:	f06f 0302 	mvnne.w	r3, #2
   272f4:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
   272f8:	4618      	mov	r0, r3
}
   272fa:	f507 77d2 	add.w	r7, r7, #420	; 0x1a4
   272fe:	46bd      	mov	sp, r7
   27300:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   27304:	46b1      	mov	r9, r6
   27306:	f7ff bb4b 	b.w	269a0 <celt_encode_with_ec+0x14d8>
   2730a:	4608      	mov	r0, r1
   2730c:	e77d      	b.n	2720a <celt_encode_with_ec+0x1d42>
      for (i=0;i<start;i++)
   2730e:	4626      	mov	r6, r4
   27310:	e6c4      	b.n	2709c <celt_encode_with_ec+0x1bd4>
   27312:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
   27316:	f8d7 10f8 	ldr.w	r1, [r7, #248]	; 0xf8
   2731a:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
   2731e:	449c      	add	ip, r3
   27320:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
   27324:	0040      	lsls	r0, r0, #1
   27326:	eb03 0c4c 	add.w	ip, r3, ip, lsl #1
   2732a:	4402      	add	r2, r0
   2732c:	4403      	add	r3, r0
   2732e:	4408      	add	r0, r1
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
   27330:	f44f 4110 	mov.w	r1, #36864	; 0x9000
         oldBandE[c*nbEBands+i]=0;
   27334:	f823 5b02 	strh.w	r5, [r3], #2
      for (i=end;i<nbEBands;i++)
   27338:	4563      	cmp	r3, ip
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
   2733a:	f822 1b02 	strh.w	r1, [r2], #2
   2733e:	f820 1b02 	strh.w	r1, [r0], #2
      for (i=end;i<nbEBands;i++)
   27342:	d1f7      	bne.n	27334 <celt_encode_with_ec+0x1e6c>
   27344:	e7a4      	b.n	27290 <celt_encode_with_ec+0x1dc8>
   27346:	f8d7 1120 	ldr.w	r1, [r7, #288]	; 0x120
   2734a:	f8d7 40f8 	ldr.w	r4, [r7, #248]	; 0xf8
   2734e:	f103 4200 	add.w	r2, r3, #2147483648	; 0x80000000
   27352:	1858      	adds	r0, r3, r1
   27354:	3a01      	subs	r2, #1
   27356:	f8d7 10f4 	ldr.w	r1, [r7, #244]	; 0xf4
   2735a:	0052      	lsls	r2, r2, #1
   2735c:	4411      	add	r1, r2
   2735e:	4422      	add	r2, r4
   27360:	f8d7 4110 	ldr.w	r4, [r7, #272]	; 0x110
   27364:	eb04 0040 	add.w	r0, r4, r0, lsl #1
   27368:	eb04 0343 	add.w	r3, r4, r3, lsl #1
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
   2736c:	f44f 4410 	mov.w	r4, #36864	; 0x9000
         oldBandE[c*nbEBands+i]=0;
   27370:	f823 5b02 	strh.w	r5, [r3], #2
      for (i=0;i<start;i++)
   27374:	4298      	cmp	r0, r3
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
   27376:	f821 4f02 	strh.w	r4, [r1, #2]!
   2737a:	f822 4f02 	strh.w	r4, [r2, #2]!
      for (i=0;i<start;i++)
   2737e:	d1f7      	bne.n	27370 <celt_encode_with_ec+0x1ea8>
   27380:	e6cc      	b.n	2711c <celt_encode_with_ec+0x1c54>
      tf_select = 0;
   27382:	2300      	movs	r3, #0
   27384:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
   27388:	f7ff ba13 	b.w	267b2 <celt_encode_with_ec+0x12ea>
   2738c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
   2738e:	005c      	lsls	r4, r3, #1
   27390:	e5c9      	b.n	26f26 <celt_encode_with_ec+0x1a5e>
      boost = 0;
   27392:	f04f 0800 	mov.w	r8, #0
   27396:	f7ff bb0c 	b.w	269b2 <celt_encode_with_ec+0x14ea>
      st->lastCodedBands = codedBands;
   2739a:	4603      	mov	r3, r0
   2739c:	460a      	mov	r2, r1
   2739e:	e49f      	b.n	26ce0 <celt_encode_with_ec+0x1818>
   273a0:	4698      	mov	r8, r3
   273a2:	e459      	b.n	26c58 <celt_encode_with_ec+0x1790>
   alloc_trim = 5;
   273a4:	2305      	movs	r3, #5
   273a6:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
   273aa:	f7ff bb34 	b.w	26a16 <celt_encode_with_ec+0x154e>
   tf_select_rsv = LM>0 && tell+logp+1 <= budget;
   273ae:	f8d7 010c 	ldr.w	r0, [r7, #268]	; 0x10c
   logp = isTransient ? 2 : 4;
   273b2:	2504      	movs	r5, #4
   273b4:	462a      	mov	r2, r5
   tf_select_rsv = LM>0 && tell+logp+1 <= budget;
   273b6:	2800      	cmp	r0, #0
   273b8:	f47f a993 	bne.w	266e2 <celt_encode_with_ec+0x121a>
   for (i=start;i<end;i++)
   273bc:	f8d7 0120 	ldr.w	r0, [r7, #288]	; 0x120
   273c0:	f8d7 5124 	ldr.w	r5, [r7, #292]	; 0x124
   273c4:	42a8      	cmp	r0, r5
   273c6:	f6bf aa22 	bge.w	2680e <celt_encode_with_ec+0x1346>
   budget -= tf_select_rsv;
   273ca:	4625      	mov	r5, r4
   tf_select_rsv = LM>0 && tell+logp+1 <= budget;
   273cc:	f8d7 810c 	ldr.w	r8, [r7, #268]	; 0x10c
   273d0:	f7ff b999 	b.w	26706 <celt_encode_with_ec+0x123e>
   273d4:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
   273d8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   if (st->vbr && st->bitrate!=OPUS_BITRATE_MAX)
   273da:	f8d3 a02c 	ldr.w	sl, [r3, #44]	; 0x2c
      tell0_frac=tell=1;
   273de:	2301      	movs	r3, #1
   273e0:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
   273e4:	63bb      	str	r3, [r7, #56]	; 0x38
   nbAvailableBytes = nbCompressedBytes - nbFilledBytes;
   273e6:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
   273ea:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
   273ee:	fb02 f404 	mul.w	r4, r2, r4
   if (st->vbr && st->bitrate!=OPUS_BITRATE_MAX)
   273f2:	f1ba 0f00 	cmp.w	sl, #0
   273f6:	d009      	beq.n	2740c <celt_encode_with_ec+0x1f44>
   273f8:	1c51      	adds	r1, r2, #1
      nbFilledBytes=0;
   273fa:	f8d7 a1cc 	ldr.w	sl, [r7, #460]	; 0x1cc
   if (st->vbr && st->bitrate!=OPUS_BITRATE_MAX)
   273fe:	f47e a921 	bne.w	25644 <celt_encode_with_ec+0x17c>
      if (tell>1)
   27402:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
   27406:	2b01      	cmp	r3, #1
         tmp += tell;
   27408:	bfc8      	it	gt
   2740a:	18e4      	addgt	r4, r4, r3
      if (st->bitrate!=OPUS_BITRATE_MAX)
   2740c:	1c53      	adds	r3, r2, #1
   2740e:	d019      	beq.n	27444 <celt_encode_with_ec+0x1f7c>
         nbCompressedBytes = IMAX(2, IMIN(nbCompressedBytes,
   27410:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
   27414:	6819      	ldr	r1, [r3, #0]
   27416:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
   2741a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   2741c:	eb04 0481 	add.w	r4, r4, r1, lsl #2
   27420:	00c9      	lsls	r1, r1, #3
   27422:	fb94 f1f1 	sdiv	r1, r4, r1
   27426:	2b00      	cmp	r3, #0
   27428:	bf0c      	ite	eq
   2742a:	460b      	moveq	r3, r1
   2742c:	1e4b      	subne	r3, r1, #1
   2742e:	f8d7 10e8 	ldr.w	r1, [r7, #232]	; 0xe8
   27432:	4299      	cmp	r1, r3
   27434:	bfa8      	it	ge
   27436:	4619      	movge	r1, r3
   27438:	2902      	cmp	r1, #2
   2743a:	460b      	mov	r3, r1
   2743c:	bfb8      	it	lt
   2743e:	2302      	movlt	r3, #2
   27440:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
   equiv_rate = ((opus_int32)nbCompressedBytes*8*50 >> (3-LM)) - (40*C+20)*((400>>LM) - 50);
   27444:	f8d7 1114 	ldr.w	r1, [r7, #276]	; 0x114
   27448:	f8d7 00e8 	ldr.w	r0, [r7, #232]	; 0xe8
   2744c:	008b      	lsls	r3, r1, #2
   2744e:	1859      	adds	r1, r3, r1
   27450:	00c9      	lsls	r1, r1, #3
   27452:	3114      	adds	r1, #20
   27454:	fb05 f501 	mul.w	r5, r5, r1
   27458:	623b      	str	r3, [r7, #32]
   2745a:	63f9      	str	r1, [r7, #60]	; 0x3c
   2745c:	f44f 73c8 	mov.w	r3, #400	; 0x190
   27460:	6eb9      	ldr	r1, [r7, #104]	; 0x68
   27462:	fb03 f300 	mul.w	r3, r3, r0
   27466:	410b      	asrs	r3, r1
   27468:	1b5b      	subs	r3, r3, r5
   2746a:	67bb      	str	r3, [r7, #120]	; 0x78
      effectiveBytes = nbCompressedBytes - nbFilledBytes;
   2746c:	eba0 030a 	sub.w	r3, r0, sl
   27470:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
   if (st->bitrate != OPUS_BITRATE_MAX)
   27474:	1c56      	adds	r6, r2, #1
      vbr_rate = 0;
   27476:	f04f 0300 	mov.w	r3, #0
   2747a:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
   if (st->bitrate != OPUS_BITRATE_MAX)
   2747e:	f47e a903 	bne.w	25688 <celt_encode_with_ec+0x1c0>
   if (enc==NULL)
   27482:	f8d7 31cc 	ldr.w	r3, [r7, #460]	; 0x1cc
   27486:	2b00      	cmp	r3, #0
   27488:	f47e a909 	bne.w	2569e <celt_encode_with_ec+0x1d6>
      ec_enc_init(&_enc, compressed, nbCompressedBytes);
   2748c:	4659      	mov	r1, fp
   2748e:	f507 709e 	add.w	r0, r7, #316	; 0x13c
   27492:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
   27496:	f002 fb73 	bl	29b80 <ec_enc_init>
      enc = &_enc;
   2749a:	f507 739e 	add.w	r3, r7, #316	; 0x13c
   2749e:	f8c7 31cc 	str.w	r3, [r7, #460]	; 0x1cc
   274a2:	f7fe b8fc 	b.w	2569e <celt_encode_with_ec+0x1d6>
   int weak_transient = 0;
   274a6:	2300      	movs	r3, #0
   274a8:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
   tf_estimate = 0;
   274ac:	65bb      	str	r3, [r7, #88]	; 0x58
   int tf_chan = 0;
   274ae:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
   isTransient = 0;
   274b2:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
   274b6:	4616      	mov	r6, r2
   274b8:	f7fe bd0a 	b.w	25ed0 <celt_encode_with_ec+0xa08>
      if (LM!=0)
   274bc:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
   274c0:	2b00      	cmp	r3, #0
   274c2:	f000 8085 	beq.w	275d0 <celt_encode_with_ec+0x2108>
         dual_stereo = stereo_analysis(mode, X, LM, N);
   274c6:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
   274ca:	f8c7 b0fc 	str.w	fp, [r7, #252]	; 0xfc
   274ce:	6992      	ldr	r2, [r2, #24]
   274d0:	f8c7 2104 	str.w	r2, [r7, #260]	; 0x104
   274d4:	f102 001a 	add.w	r0, r2, #26
   274d8:	4690      	mov	r8, r2
   274da:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
   274de:	f8c7 a0ec 	str.w	sl, [r7, #236]	; 0xec
   opus_val32 sumLR = EPSILON, sumMS = EPSILON;
   274e2:	2601      	movs	r6, #1
   274e4:	1e91      	subs	r1, r2, #2
   274e6:	f8c7 90e4 	str.w	r9, [r7, #228]	; 0xe4
   274ea:	46b4      	mov	ip, r6
   274ec:	f8c7 1128 	str.w	r1, [r7, #296]	; 0x128
   274f0:	4692      	mov	sl, r2
   274f2:	4683      	mov	fp, r0
   274f4:	4699      	mov	r9, r3
      for (j=m->eBands[i]<<LM;j<m->eBands[i+1]<<LM;j++)
   274f6:	f9b8 5000 	ldrsh.w	r5, [r8]
   274fa:	f938 ef02 	ldrsh.w	lr, [r8, #2]!
   274fe:	fa05 f509 	lsl.w	r5, r5, r9
   27502:	fa0e fe09 	lsl.w	lr, lr, r9
   27506:	45ae      	cmp	lr, r5
   27508:	dd25      	ble.n	27556 <celt_encode_with_ec+0x208e>
   2750a:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
   2750e:	f105 4400 	add.w	r4, r5, #2147483648	; 0x80000000
   27512:	441d      	add	r5, r3
   27514:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
   27518:	3c01      	subs	r4, #1
   2751a:	eb03 0e4e 	add.w	lr, r3, lr, lsl #1
   2751e:	eb0a 0444 	add.w	r4, sl, r4, lsl #1
   27522:	eb0a 0545 	add.w	r5, sl, r5, lsl #1
         L = EXTEND32(X[j]);
   27526:	f934 3f02 	ldrsh.w	r3, [r4, #2]!
         R = EXTEND32(X[N0+j]);
   2752a:	f935 1b02 	ldrsh.w	r1, [r5], #2
         M = ADD32(L, R);
   2752e:	185a      	adds	r2, r3, r1
         S = SUB32(L, R);
   27530:	1a58      	subs	r0, r3, r1
         sumMS = ADD32(sumMS, ADD32(ABS32(M), ABS32(S)));
   27532:	2a00      	cmp	r2, #0
   27534:	bfb8      	it	lt
   27536:	4252      	neglt	r2, r2
   27538:	2800      	cmp	r0, #0
   2753a:	bfb8      	it	lt
   2753c:	4240      	neglt	r0, r0
         sumLR = ADD32(sumLR, ADD32(ABS32(L), ABS32(R)));
   2753e:	2b00      	cmp	r3, #0
   27540:	bfb8      	it	lt
   27542:	425b      	neglt	r3, r3
   27544:	2900      	cmp	r1, #0
   27546:	bfb8      	it	lt
   27548:	4249      	neglt	r1, r1
         sumMS = ADD32(sumMS, ADD32(ABS32(M), ABS32(S)));
   2754a:	4402      	add	r2, r0
         sumLR = ADD32(sumLR, ADD32(ABS32(L), ABS32(R)));
   2754c:	440b      	add	r3, r1
      for (j=m->eBands[i]<<LM;j<m->eBands[i+1]<<LM;j++)
   2754e:	45a6      	cmp	lr, r4
         sumMS = ADD32(sumMS, ADD32(ABS32(M), ABS32(S)));
   27550:	4416      	add	r6, r2
         sumLR = ADD32(sumLR, ADD32(ABS32(L), ABS32(R)));
   27552:	449c      	add	ip, r3
      for (j=m->eBands[i]<<LM;j<m->eBands[i+1]<<LM;j++)
   27554:	d1e7      	bne.n	27526 <celt_encode_with_ec+0x205e>
   for (i=0;i<13;i++)
   27556:	45c3      	cmp	fp, r8
   27558:	d1cd      	bne.n	274f6 <celt_encode_with_ec+0x202e>
   return MULT16_32_Q15((m->eBands[13]<<(LM+1))+thetas, sumMS)
   2755a:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
   if (LM<=1)
   2755e:	f8d7 210c 	ldr.w	r2, [r7, #268]	; 0x10c
   return MULT16_32_Q15((m->eBands[13]<<(LM+1))+thetas, sumMS)
   27562:	f9b3 001a 	ldrsh.w	r0, [r3, #26]
   27566:	f8d7 b0fc 	ldr.w	fp, [r7, #252]	; 0xfc
   2756a:	f8d7 a0ec 	ldr.w	sl, [r7, #236]	; 0xec
   2756e:	f8d7 90e4 	ldr.w	r9, [r7, #228]	; 0xe4
   sumMS = MULT16_32_Q15(QCONST16(0.707107f, 15), sumMS);
   27572:	f645 2182 	movw	r1, #23170	; 0x5a82
   27576:	b2b3      	uxth	r3, r6
   if (LM<=1)
   27578:	2a01      	cmp	r2, #1
   sumMS = MULT16_32_Q15(QCONST16(0.707107f, 15), sumMS);
   2757a:	fb01 f303 	mul.w	r3, r1, r3
   return MULT16_32_Q15((m->eBands[13]<<(LM+1))+thetas, sumMS)
   2757e:	f102 0201 	add.w	r2, r2, #1
   sumMS = MULT16_32_Q15(QCONST16(0.707107f, 15), sumMS);
   27582:	ea4f 4626 	mov.w	r6, r6, asr #16
   return MULT16_32_Q15((m->eBands[13]<<(LM+1))+thetas, sumMS)
   27586:	fa00 f002 	lsl.w	r0, r0, r2
   sumMS = MULT16_32_Q15(QCONST16(0.707107f, 15), sumMS);
   2758a:	fb16 f601 	smulbb	r6, r6, r1
   2758e:	ea4f 33e3 	mov.w	r3, r3, asr #15
   if (LM<=1)
   27592:	bf0c      	ite	eq
   27594:	2105      	moveq	r1, #5
   27596:	210d      	movne	r1, #13
   sumMS = MULT16_32_Q15(QCONST16(0.707107f, 15), sumMS);
   27598:	eb03 0446 	add.w	r4, r3, r6, lsl #1
   return MULT16_32_Q15((m->eBands[13]<<(LM+1))+thetas, sumMS)
   2759c:	4401      	add	r1, r0
   2759e:	b20a      	sxth	r2, r1
   275a0:	b2a3      	uxth	r3, r4
   275a2:	fb02 f303 	mul.w	r3, r2, r3
   275a6:	fb14 f121 	smultb	r1, r4, r1
         > MULT16_32_Q15(m->eBands[13]<<(LM+1), sumLR);
   275aa:	b202      	sxth	r2, r0
   275ac:	fa1f f48c 	uxth.w	r4, ip
   275b0:	fb02 f204 	mul.w	r2, r2, r4
   return MULT16_32_Q15((m->eBands[13]<<(LM+1))+thetas, sumMS)
   275b4:	13db      	asrs	r3, r3, #15
         > MULT16_32_Q15(m->eBands[13]<<(LM+1), sumLR);
   275b6:	fb1c fc20 	smultb	ip, ip, r0
   275ba:	13d2      	asrs	r2, r2, #15
   return MULT16_32_Q15((m->eBands[13]<<(LM+1))+thetas, sumMS)
   275bc:	eb03 0341 	add.w	r3, r3, r1, lsl #1
         > MULT16_32_Q15(m->eBands[13]<<(LM+1), sumLR);
   275c0:	eb02 0c4c 	add.w	ip, r2, ip, lsl #1
   275c4:	4563      	cmp	r3, ip
   275c6:	bfd4      	ite	le
   275c8:	2300      	movle	r3, #0
   275ca:	2301      	movgt	r3, #1
         dual_stereo = stereo_analysis(mode, X, LM, N);
   275cc:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
      st->intensity = hysteresis_decision((opus_val16)(equiv_rate/1000),
   275d0:	f8d7 412c 	ldr.w	r4, [r7, #300]	; 0x12c
   275d4:	4bae      	ldr	r3, [pc, #696]	; (27890 <celt_encode_with_ec+0x23c8>)
   275d6:	f8d4 20e8 	ldr.w	r2, [r4, #232]	; 0xe8
   275da:	9200      	str	r2, [sp, #0]
   275dc:	6fba      	ldr	r2, [r7, #120]	; 0x78
   275de:	4611      	mov	r1, r2
   275e0:	fb83 1301 	smull	r1, r3, r3, r1
   275e4:	17d0      	asrs	r0, r2, #31
   275e6:	ebc0 10a3 	rsb	r0, r0, r3, asr #6
   275ea:	b200      	sxth	r0, r0
   275ec:	2315      	movs	r3, #21
   275ee:	4aa9      	ldr	r2, [pc, #676]	; (27894 <celt_encode_with_ec+0x23cc>)
   275f0:	49a9      	ldr	r1, [pc, #676]	; (27898 <celt_encode_with_ec+0x23d0>)
   275f2:	f7fa fd0f 	bl	22014 <hysteresis_decision>
      st->intensity = IMIN(end,IMAX(start, st->intensity));
   275f6:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
   275fa:	4298      	cmp	r0, r3
   275fc:	bfb8      	it	lt
   275fe:	4618      	movlt	r0, r3
   27600:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
   27604:	4298      	cmp	r0, r3
   27606:	bfa8      	it	ge
   27608:	4618      	movge	r0, r3
   2760a:	f8c4 00e8 	str.w	r0, [r4, #232]	; 0xe8
   2760e:	f7ff b9e4 	b.w	269da <celt_encode_with_ec+0x1512>
   if (CC==2&&C==1) {
   27612:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
   27616:	2b01      	cmp	r3, #1
   27618:	f47f ac94 	bne.w	26f44 <celt_encode_with_ec+0x1a7c>
      OPUS_COPY(&oldBandE[nbEBands], oldBandE, nbEBands);
   2761c:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
   27620:	005a      	lsls	r2, r3, #1
   27622:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
   27626:	1898      	adds	r0, r3, r2
   27628:	4619      	mov	r1, r3
   2762a:	f7e4 fd69 	bl	c100 <memcpy>
   2762e:	e489      	b.n	26f44 <celt_encode_with_ec+0x1a7c>
      OPUS_COPY(oldLogE2, oldLogE, CC*nbEBands);
   27630:	f8d7 60c4 	ldr.w	r6, [r7, #196]	; 0xc4
   27634:	f8d7 50f8 	ldr.w	r5, [r7, #248]	; 0xf8
   27638:	f8d7 00f4 	ldr.w	r0, [r7, #244]	; 0xf4
   2763c:	4632      	mov	r2, r6
   2763e:	4629      	mov	r1, r5
   27640:	f7e4 fd5e 	bl	c100 <memcpy>
      OPUS_COPY(oldLogE, oldBandE, CC*nbEBands);
   27644:	4632      	mov	r2, r6
   27646:	f8d7 1110 	ldr.w	r1, [r7, #272]	; 0x110
   2764a:	4628      	mov	r0, r5
   2764c:	f7e4 fd58 	bl	c100 <memcpy>
   27650:	e498      	b.n	26f84 <celt_encode_with_ec+0x1abc>
   ALLOC(offsets, nbEBands, int);
   27652:	f104 030a 	add.w	r3, r4, #10
   27656:	f023 0407 	bic.w	r4, r3, #7
   2765a:	ebad 0d04 	sub.w	sp, sp, r4
   2765e:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
   27662:	ab14      	add	r3, sp, #80	; 0x50
   ALLOC(importance, nbEBands, int);
   27664:	ebad 0d04 	sub.w	sp, sp, r4
   27668:	f10d 0c50 	add.w	ip, sp, #80	; 0x50
   ALLOC(spread_weight, nbEBands, int);
   2766c:	ebad 0d04 	sub.w	sp, sp, r4
   27670:	a914      	add	r1, sp, #80	; 0x50
   27672:	6439      	str	r1, [r7, #64]	; 0x40
   ALLOC(offsets, nbEBands, int);
   27674:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
   maxDepth = dynalloc_analysis(bandLogE, bandLogE2, nbEBands, start, end, C, offsets,
   27678:	f8d7 10cc 	ldr.w	r1, [r7, #204]	; 0xcc
   2767c:	f8cd c038 	str.w	ip, [sp, #56]	; 0x38
   27680:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
   27684:	e9cd 620c 	strd	r6, r2, [sp, #48]	; 0x30
   27688:	6e7a      	ldr	r2, [r7, #100]	; 0x64
   2768a:	920b      	str	r2, [sp, #44]	; 0x2c
   2768c:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
   27690:	920a      	str	r2, [sp, #40]	; 0x28
   27692:	f8d7 210c 	ldr.w	r2, [r7, #268]	; 0x10c
   27696:	9209      	str	r2, [sp, #36]	; 0x24
   27698:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
   2769c:	9006      	str	r0, [sp, #24]
   2769e:	e9cd 5207 	strd	r5, r2, [sp, #28]
   276a2:	f8d7 2118 	ldr.w	r2, [r7, #280]	; 0x118
   276a6:	e9cd 3e02 	strd	r3, lr, [sp, #8]
   276aa:	e9cd 8204 	strd	r8, r2, [sp, #16]
   276ae:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
   276b2:	9201      	str	r2, [sp, #4]
   276b4:	f8d7 2124 	ldr.w	r2, [r7, #292]	; 0x124
   276b8:	9200      	str	r2, [sp, #0]
   276ba:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   276bc:	930f      	str	r3, [sp, #60]	; 0x3c
   276be:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
   276c2:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
   276c6:	f8d7 00d8 	ldr.w	r0, [r7, #216]	; 0xd8
   276ca:	f7fc fd73 	bl	241b4 <dynalloc_analysis.isra.5>
   ALLOC(tf_res, nbEBands, int);
   276ce:	ebad 0d04 	sub.w	sp, sp, r4
   276d2:	ab14      	add	r3, sp, #80	; 0x50
   maxDepth = dynalloc_analysis(bandLogE, bandLogE2, nbEBands, start, end, C, offsets,
   276d4:	6478      	str	r0, [r7, #68]	; 0x44
   ALLOC(tf_res, nbEBands, int);
   276d6:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
   } else if (hybrid && weak_transient)
   276da:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
   276de:	b183      	cbz	r3, 27702 <celt_encode_with_ec+0x223a>
      for (i=0;i<end;i++)
   276e0:	f8d7 0124 	ldr.w	r0, [r7, #292]	; 0x124
   276e4:	2800      	cmp	r0, #0
   276e6:	f341 8194 	ble.w	28a12 <celt_encode_with_ec+0x354a>
   276ea:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
         tf_res[i] = 1;
   276ee:	2101      	movs	r1, #1
   276f0:	1f1a      	subs	r2, r3, #4
      for (i=0;i<end;i++)
   276f2:	2300      	movs	r3, #0
   276f4:	3301      	adds	r3, #1
   276f6:	4298      	cmp	r0, r3
         tf_res[i] = 1;
   276f8:	f842 1f04 	str.w	r1, [r2, #4]!
      for (i=0;i<end;i++)
   276fc:	d1fa      	bne.n	276f4 <celt_encode_with_ec+0x222c>
   276fe:	f7fe bf55 	b.w	265ac <celt_encode_with_ec+0x10e4>
   } else if (hybrid && effectiveBytes<15 && st->silk_info.signalType != 2)
   27702:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   27706:	2b0e      	cmp	r3, #14
   27708:	f300 827c 	bgt.w	27c04 <celt_encode_with_ec+0x273c>
   2770c:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
   27710:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
   27714:	2b02      	cmp	r3, #2
   27716:	f000 8275 	beq.w	27c04 <celt_encode_with_ec+0x273c>
      for (i=0;i<end;i++)
   2771a:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
   2771e:	2b00      	cmp	r3, #0
   27720:	f341 829e 	ble.w	28c60 <celt_encode_with_ec+0x3798>
   27724:	f8d7 10ec 	ldr.w	r1, [r7, #236]	; 0xec
   27728:	f8d7 00cc 	ldr.w	r0, [r7, #204]	; 0xcc
   2772c:	009a      	lsls	r2, r3, #2
   2772e:	f00d fd19 	bl	35164 <memset>
         tf_res[i] = 0;
   27732:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
   27736:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
   2773a:	f8d7 1124 	ldr.w	r1, [r7, #292]	; 0x124
   2773e:	f7fe bf3a 	b.w	265b6 <celt_encode_with_ec+0x10ee>
      OPUS_COPY(bandLogE2, bandLogE, C*nbEBands);
   27742:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
   27746:	f8d7 10d8 	ldr.w	r1, [r7, #216]	; 0xd8
   2774a:	f8d7 00cc 	ldr.w	r0, [r7, #204]	; 0xcc
   2774e:	f7e4 fcd7 	bl	c100 <memcpy>
   27752:	f7fe be12 	b.w	2637a <celt_encode_with_ec+0xeb2>
      ALLOC(pitch_buf, (COMBFILTER_MAXPERIOD+N)>>1, opus_val16);
   27756:	f028 0301 	bic.w	r3, r8, #1
   2775a:	3308      	adds	r3, #8
   2775c:	f023 0307 	bic.w	r3, r3, #7
   {
   27760:	466d      	mov	r5, sp
      ALLOC(pitch_buf, (COMBFILTER_MAXPERIOD+N)>>1, opus_val16);
   27762:	ebad 0d03 	sub.w	sp, sp, r3
      pitch_downsample(pre, pitch_buf, COMBFILTER_MAXPERIOD+N, CC, st->arch);
   27766:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
   2776a:	9300      	str	r3, [sp, #0]
      ALLOC(pitch_buf, (COMBFILTER_MAXPERIOD+N)>>1, opus_val16);
   2776c:	ac14      	add	r4, sp, #80	; 0x50
      pitch_downsample(pre, pitch_buf, COMBFILTER_MAXPERIOD+N, CC, st->arch);
   2776e:	4642      	mov	r2, r8
   27770:	4621      	mov	r1, r4
   27772:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
   27776:	f507 70b6 	add.w	r0, r7, #364	; 0x16c
   2777a:	f004 fab1 	bl	2bce0 <pitch_downsample>
      pitch_search(pitch_buf+(COMBFILTER_MAXPERIOD>>1), pitch_buf, N,
   2777e:	f8d7 612c 	ldr.w	r6, [r7, #300]	; 0x12c
   27782:	f507 729c 	add.w	r2, r7, #312	; 0x138
   27786:	6cb3      	ldr	r3, [r6, #72]	; 0x48
   27788:	9301      	str	r3, [sp, #4]
   2778a:	667a      	str	r2, [r7, #100]	; 0x64
   2778c:	9200      	str	r2, [sp, #0]
   2778e:	f8d7 80f0 	ldr.w	r8, [r7, #240]	; 0xf0
   27792:	4621      	mov	r1, r4
   27794:	f504 6080 	add.w	r0, r4, #1024	; 0x400
   27798:	f240 33d3 	movw	r3, #979	; 0x3d3
   2779c:	4642      	mov	r2, r8
   2779e:	f004 fd11 	bl	2c1c4 <pitch_search>
      pitch_index = COMBFILTER_MAXPERIOD-pitch_index;
   277a2:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
      gain1 = remove_doubling(pitch_buf, COMBFILTER_MAXPERIOD, COMBFILTER_MINPERIOD,
   277a6:	6cb2      	ldr	r2, [r6, #72]	; 0x48
      pitch_index = COMBFILTER_MAXPERIOD-pitch_index;
   277a8:	f5c3 6380 	rsb	r3, r3, #1024	; 0x400
   277ac:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
      gain1 = remove_doubling(pitch_buf, COMBFILTER_MAXPERIOD, COMBFILTER_MINPERIOD,
   277b0:	9203      	str	r2, [sp, #12]
   277b2:	f9b6 306c 	ldrsh.w	r3, [r6, #108]	; 0x6c
   277b6:	9302      	str	r3, [sp, #8]
   277b8:	6eb3      	ldr	r3, [r6, #104]	; 0x68
   277ba:	9301      	str	r3, [sp, #4]
   277bc:	6e7a      	ldr	r2, [r7, #100]	; 0x64
   277be:	9200      	str	r2, [sp, #0]
   277c0:	4620      	mov	r0, r4
   277c2:	4643      	mov	r3, r8
   277c4:	220f      	movs	r2, #15
   277c6:	f44f 6180 	mov.w	r1, #1024	; 0x400
   277ca:	f004 fe6f 	bl	2c4ac <remove_doubling>
      if (pitch_index > COMBFILTER_MAXPERIOD-2)
   277ce:	f8d7 2138 	ldr.w	r2, [r7, #312]	; 0x138
   277d2:	f240 33fe 	movw	r3, #1022	; 0x3fe
   277d6:	429a      	cmp	r2, r3
         pitch_index = COMBFILTER_MAXPERIOD-2;
   277d8:	bfc8      	it	gt
   277da:	f8c7 3138 	strgt.w	r3, [r7, #312]	; 0x138
      if (st->loss_rate>2)
   277de:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
   277e2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
      gain1 = MULT16_16_Q15(QCONST16(.7f,15),gain1);
   277e4:	f645 149a 	movw	r4, #22938	; 0x599a
   277e8:	fb10 f404 	smulbb	r4, r0, r4
      if (st->loss_rate>2)
   277ec:	2b02      	cmp	r3, #2
      gain1 = MULT16_16_Q15(QCONST16(.7f,15),gain1);
   277ee:	ea4f 34e4 	mov.w	r4, r4, asr #15
      if (st->loss_rate>2)
   277f2:	dd06      	ble.n	27802 <celt_encode_with_ec+0x233a>
      if (st->loss_rate>4)
   277f4:	2b04      	cmp	r3, #4
   277f6:	f341 8348 	ble.w	28e8a <celt_encode_with_ec+0x39c2>
      if (st->loss_rate>8)
   277fa:	2b08      	cmp	r3, #8
         gain1 = HALF32(gain1);
   277fc:	bfd4      	ite	le
   277fe:	10a4      	asrle	r4, r4, #2
         gain1 = 0;
   27800:	2400      	movgt	r4, #0
   27802:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
   27806:	f8d7 2138 	ldr.w	r2, [r7, #312]	; 0x138
   2780a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   2780c:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
   27810:	46ad      	mov	sp, r5
   27812:	f7fe b8a3 	b.w	2595c <celt_encode_with_ec+0x494>
         pitch_index += 1;
   27816:	6efb      	ldr	r3, [r7, #108]	; 0x6c
         ec_enc_bit_logp(enc, 1, 1);
   27818:	f8d7 01cc 	ldr.w	r0, [r7, #460]	; 0x1cc
         pitch_index += 1;
   2781c:	1c5c      	adds	r4, r3, #1
         octave = EC_ILOG(pitch_index)-5;
   2781e:	fab4 f684 	clz	r6, r4
         ec_enc_bit_logp(enc, 1, 1);
   27822:	2201      	movs	r2, #1
         octave = EC_ILOG(pitch_index)-5;
   27824:	f1c6 051b 	rsb	r5, r6, #27
         ec_enc_bit_logp(enc, 1, 1);
   27828:	4611      	mov	r1, r2
   2782a:	f002 fabd 	bl	29da8 <ec_enc_bit_logp>
         ec_enc_uint(enc, octave, 6);
   2782e:	4629      	mov	r1, r5
   27830:	f8d7 01cc 	ldr.w	r0, [r7, #460]	; 0x1cc
   27834:	2206      	movs	r2, #6
   27836:	f002 fb95 	bl	29f64 <ec_enc_uint>
         ec_enc_bits(enc, pitch_index-(16<<octave), 4+octave);
   2783a:	2110      	movs	r1, #16
   2783c:	40a9      	lsls	r1, r5
   2783e:	f1c6 021f 	rsb	r2, r6, #31
   27842:	1a61      	subs	r1, r4, r1
   27844:	f8d7 01cc 	ldr.w	r0, [r7, #460]	; 0x1cc
   27848:	f002 fbe4 	bl	2a014 <ec_enc_bits>
         ec_enc_bits(enc, qg, 3);
   2784c:	6e39      	ldr	r1, [r7, #96]	; 0x60
   2784e:	f8d7 01cc 	ldr.w	r0, [r7, #460]	; 0x1cc
   27852:	2203      	movs	r2, #3
   27854:	f002 fbde 	bl	2a014 <ec_enc_bits>
         ec_enc_icdf(enc, prefilter_tapset, tapset_icdf, 2);
   27858:	2302      	movs	r3, #2
   2785a:	4a10      	ldr	r2, [pc, #64]	; (2789c <celt_encode_with_ec+0x23d4>)
   2785c:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
   27860:	f8d7 01cc 	ldr.w	r0, [r7, #460]	; 0x1cc
   27864:	f002 fb0c 	bl	29e80 <ec_enc_icdf>
   27868:	f7fe b9b3 	b.w	25bd2 <celt_encode_with_ec+0x70a>
   2786c:	2300      	movs	r3, #0
   2786e:	e9c7 330a 	strd	r3, r3, [r7, #40]	; 0x28
   opus_val16 temporal_vbr=0;
   27872:	637b      	str	r3, [r7, #52]	; 0x34
   27874:	f7fe bd7d 	b.w	26372 <celt_encode_with_ec+0xeaa>
   int weak_transient = 0;
   27878:	2300      	movs	r3, #0
   2787a:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
   tf_estimate = 0;
   2787e:	65bb      	str	r3, [r7, #88]	; 0x58
   int tf_chan = 0;
   27880:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
   isTransient = 0;
   27884:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
   27888:	f8d7 612c 	ldr.w	r6, [r7, #300]	; 0x12c
   2788c:	f7fe bb20 	b.w	25ed0 <celt_encode_with_ec+0xa08>
   27890:	10624dd3 	.word	0x10624dd3
   27894:	00037990 	.word	0x00037990
   27898:	000379bc 	.word	0x000379bc
   2789c:	00037a6c 	.word	0x00037a6c
        base_target = IMAX(0, vbr_rate - ((9*C+4)<<BITRES));
   278a0:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
   278a4:	eb02 01c2 	add.w	r1, r2, r2, lsl #3
   278a8:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
   278ac:	3104      	adds	r1, #4
   278ae:	eba2 00c1 	sub.w	r0, r2, r1, lsl #3
   278b2:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
     if (st->constrained_vbr)
   278b6:	b133      	cbz	r3, 278c6 <celt_encode_with_ec+0x23fe>
        base_target += (st->vbr_offset>>lm_diff);
   278b8:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
   278bc:	f8d2 20d8 	ldr.w	r2, [r2, #216]	; 0xd8
   278c0:	fa42 f209 	asr.w	r2, r2, r9
   278c4:	4410      	add	r0, r2
        if (st->silk_info.offset < 100) target += 12 << BITRES >> (3-LM);
   278c6:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
   278ca:	f8d2 20bc 	ldr.w	r2, [r2, #188]	; 0xbc
   278ce:	2a63      	cmp	r2, #99	; 0x63
   278d0:	f300 8182 	bgt.w	27bd8 <celt_encode_with_ec+0x2710>
   278d4:	6eb9      	ldr	r1, [r7, #104]	; 0x68
   278d6:	2260      	movs	r2, #96	; 0x60
   278d8:	410a      	asrs	r2, r1
   278da:	4410      	add	r0, r2
        target += (opus_int32)MULT16_16_Q14(tf_estimate-QCONST16(.25f,14), (50<<BITRES));
   278dc:	6dbc      	ldr	r4, [r7, #88]	; 0x58
   278de:	f5a4 5180 	sub.w	r1, r4, #4096	; 0x1000
   278e2:	b209      	sxth	r1, r1
   278e4:	eb01 0181 	add.w	r1, r1, r1, lsl #2
        if (tf_estimate > QCONST16(.7f,14))
   278e8:	f642 42cd 	movw	r2, #11469	; 0x2ccd
        target += (opus_int32)MULT16_16_Q14(tf_estimate-QCONST16(.25f,14), (50<<BITRES));
   278ec:	eb01 0181 	add.w	r1, r1, r1, lsl #2
        if (tf_estimate > QCONST16(.7f,14))
   278f0:	4294      	cmp	r4, r2
        target += (opus_int32)MULT16_16_Q14(tf_estimate-QCONST16(.25f,14), (50<<BITRES));
   278f2:	eb00 21a1 	add.w	r1, r0, r1, asr #10
        if (tf_estimate > QCONST16(.7f,14))
   278f6:	dd04      	ble.n	27902 <celt_encode_with_ec+0x243a>
           target = IMAX(target, 50<<BITRES);
   278f8:	f5b1 7fc8 	cmp.w	r1, #400	; 0x190
   278fc:	bfb8      	it	lt
   278fe:	f44f 71c8 	movlt.w	r1, #400	; 0x190
        min_allowed = IMAX(min_allowed, (tell0_frac+(37<<BITRES)+total_boost+(1<<(BITRES+3))-1)>>(BITRES+3));
   27902:	6bb8      	ldr	r0, [r7, #56]	; 0x38
     min_allowed = ((tell+total_boost+(1<<(BITRES+3))-1)>>(BITRES+3)) + 2;
   27904:	eb0a 020b 	add.w	r2, sl, fp
        min_allowed = IMAX(min_allowed, (tell0_frac+(37<<BITRES)+total_boost+(1<<(BITRES+3))-1)>>(BITRES+3));
   27908:	4458      	add	r0, fp
     min_allowed = ((tell+total_boost+(1<<(BITRES+3))-1)>>(BITRES+3)) + 2;
   2790a:	323f      	adds	r2, #63	; 0x3f
   2790c:	1192      	asrs	r2, r2, #6
        min_allowed = IMAX(min_allowed, (tell0_frac+(37<<BITRES)+total_boost+(1<<(BITRES+3))-1)>>(BITRES+3));
   2790e:	f200 1067 	addw	r0, r0, #359	; 0x167
   27912:	1180      	asrs	r0, r0, #6
     min_allowed = ((tell+total_boost+(1<<(BITRES+3))-1)>>(BITRES+3)) + 2;
   27914:	3202      	adds	r2, #2
        min_allowed = IMAX(min_allowed, (tell0_frac+(37<<BITRES)+total_boost+(1<<(BITRES+3))-1)>>(BITRES+3));
   27916:	4282      	cmp	r2, r0
   27918:	bfb8      	it	lt
   2791a:	4602      	movlt	r2, r0
     if(silence)
   2791c:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
     target=target+tell;
   27920:	4451      	add	r1, sl
     if(silence)
   27922:	2800      	cmp	r0, #0
   27924:	f43f a916 	beq.w	26b54 <celt_encode_with_ec+0x168c>
     if (st->vbr_count < 970)
   27928:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
   2792c:	f8d2 20dc 	ldr.w	r2, [r2, #220]	; 0xdc
   27930:	f240 31c9 	movw	r1, #969	; 0x3c9
   27934:	428a      	cmp	r2, r1
       target = 2*8<<BITRES;
   27936:	f04f 0580 	mov.w	r5, #128	; 0x80
       delta = 0;
   2793a:	f04f 0400 	mov.w	r4, #0
       nbAvailableBytes = 2;
   2793e:	f04f 0602 	mov.w	r6, #2
     if (st->vbr_count < 970)
   27942:	f73f a91f 	bgt.w	26b84 <celt_encode_with_ec+0x16bc>
        st->vbr_count++;
   27946:	f8d7 112c 	ldr.w	r1, [r7, #300]	; 0x12c
   2794a:	1c53      	adds	r3, r2, #1
        alpha = celt_rcp(SHL32(EXTEND32(st->vbr_count+20),16));
   2794c:	3215      	adds	r2, #21
        st->vbr_count++;
   2794e:	f8c1 30dc 	str.w	r3, [r1, #220]	; 0xdc
        alpha = celt_rcp(SHL32(EXTEND32(st->vbr_count+20),16));
   27952:	0410      	lsls	r0, r2, #16
   27954:	f003 fe4a 	bl	2b5ec <celt_rcp>
   27958:	f8d7 112c 	ldr.w	r1, [r7, #300]	; 0x12c
   2795c:	b200      	sxth	r0, r0
   2795e:	6b4b      	ldr	r3, [r1, #52]	; 0x34
   27960:	f7ff b911 	b.w	26b86 <celt_encode_with_ec+0x16be>
      OPUS_CLEAR(tmp, 12);
   27964:	2300      	movs	r3, #0
   27966:	f8c8 3000 	str.w	r3, [r8]
   2796a:	f8c8 3004 	str.w	r3, [r8, #4]
   2796e:	f8c8 3008 	str.w	r3, [r8, #8]
   27972:	f8c8 300c 	str.w	r3, [r8, #12]
   27976:	f8c8 3010 	str.w	r3, [r8, #16]
   2797a:	f8c8 3014 	str.w	r3, [r8, #20]
   2797e:	f7fe b9dc 	b.w	25d3a <celt_encode_with_ec+0x872>
      if (tell>1)
   27982:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
   27986:	6a82      	ldr	r2, [r0, #40]	; 0x28
   27988:	2b01      	cmp	r3, #1
   2798a:	fb02 f404 	mul.w	r4, r2, r4
         tmp += tell;
   2798e:	bfc8      	it	gt
   27990:	18e4      	addgt	r4, r4, r3
   27992:	e53b      	b.n	2740c <celt_encode_with_ec+0x1f44>
      offsets[0] = IMIN(8, effectiveBytes/3);
   27994:	2308      	movs	r3, #8
   27996:	f7fe bf5e 	b.w	26856 <celt_encode_with_ec+0x138e>
   2799a:	461c      	mov	r4, r3
   2799c:	f7fe bca3 	b.w	262e6 <celt_encode_with_ec+0xe1e>
   279a0:	6993      	ldr	r3, [r2, #24]
      } else if (hybrid)
   279a2:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
   279a6:	2a00      	cmp	r2, #0
   279a8:	f000 8134 	beq.w	27c14 <celt_encode_with_ec+0x274c>
         if (st->complexity == 0)
   279ac:	2b00      	cmp	r3, #0
   279ae:	f000 813a 	beq.w	27c26 <celt_encode_with_ec+0x275e>
         else if (isTransient)
   279b2:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
   279b6:	2b00      	cmp	r3, #0
   279b8:	f000 8784 	beq.w	288c4 <celt_encode_with_ec+0x33fc>
            st->spread_decision = SPREAD_NORMAL;
   279bc:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
   279c0:	2102      	movs	r1, #2
   279c2:	6519      	str	r1, [r3, #80]	; 0x50
   279c4:	f7fe bf32 	b.w	2682c <celt_encode_with_ec+0x1364>
   sample_max=MAX32(sample_max, st->overlap_max);
   279c8:	42a6      	cmp	r6, r4
   279ca:	bfb8      	it	lt
   279cc:	4626      	movlt	r6, r4
      ec_enc_bit_logp(enc, silence, 15);
   279ce:	fab6 f186 	clz	r1, r6
   279d2:	0949      	lsrs	r1, r1, #5
   279d4:	220f      	movs	r2, #15
   279d6:	f8d7 01cc 	ldr.w	r0, [r7, #460]	; 0x1cc
   279da:	f002 f9e5 	bl	29da8 <ec_enc_bit_logp>
   if (silence)
   279de:	2e00      	cmp	r6, #0
   279e0:	f040 8127 	bne.w	27c32 <celt_encode_with_ec+0x276a>
      if (vbr_rate>0)
   279e4:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
   279e8:	2b00      	cmp	r3, #0
   279ea:	dd12      	ble.n	27a12 <celt_encode_with_ec+0x254a>
         effectiveBytes=nbCompressedBytes=IMIN(nbCompressedBytes, nbFilledBytes+2);
   279ec:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
   279f0:	f10a 0301 	add.w	r3, sl, #1
   279f4:	4293      	cmp	r3, r2
   279f6:	f2c0 875c 	blt.w	288b2 <celt_encode_with_ec+0x33ea>
         ec_enc_shrink(enc, nbCompressedBytes);
   279fa:	f8d7 40e8 	ldr.w	r4, [r7, #232]	; 0xe8
   279fe:	f8d7 01cc 	ldr.w	r0, [r7, #460]	; 0x1cc
   27a02:	4621      	mov	r1, r4
   27a04:	f002 fb72 	bl	2a0ec <ec_enc_shrink>
         nbAvailableBytes=2;
   27a08:	2302      	movs	r3, #2
         effectiveBytes=nbCompressedBytes=IMIN(nbCompressedBytes, nbFilledBytes+2);
   27a0a:	f8c7 40a8 	str.w	r4, [r7, #168]	; 0xa8
         nbAvailableBytes=2;
   27a0e:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
   27a12:	f8d7 31cc 	ldr.w	r3, [r7, #460]	; 0x1cc
   27a16:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
   27a1a:	69db      	ldr	r3, [r3, #28]
   27a1c:	f8d2 c01c 	ldr.w	ip, [r2, #28]
      enc->nbits_total+=tell-ec_tell(enc);
   27a20:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
   27a24:	f8d7 11cc 	ldr.w	r1, [r7, #460]	; 0x1cc
      tell = nbCompressedBytes*8;
   27a28:	f8c7 20b0 	str.w	r2, [r7, #176]	; 0xb0
   27a2c:	fab3 f383 	clz	r3, r3
   27a30:	f1c3 0320 	rsb	r3, r3, #32
      enc->nbits_total+=tell-ec_tell(enc);
   27a34:	4413      	add	r3, r2
   27a36:	614b      	str	r3, [r1, #20]
   silence = (sample_max==0);
   27a38:	2301      	movs	r3, #1
   27a3a:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
   27a3e:	f7fd bee0 	b.w	25802 <celt_encode_with_ec+0x33a>
   opus_val16 surround_masking=0;
   27a42:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
   opus_val16 temporal_vbr=0;
   27a46:	637b      	str	r3, [r7, #52]	; 0x34
   opus_val16 surround_trim = 0;
   27a48:	e9c7 330a 	strd	r3, r3, [r7, #40]	; 0x28
   27a4c:	f7fe bc91 	b.w	26372 <celt_encode_with_ec+0xeaa>
   27a50:	3a08      	subs	r2, #8
   anti_collapse_rsv = isTransient&&LM>=2&&bits>=((LM+2)<<BITRES) ? (1<<BITRES) : 0;
   27a52:	f04f 0808 	mov.w	r8, #8
   27a56:	f7ff b8ff 	b.w	26c58 <celt_encode_with_ec+0x1790>
   if ((!has_surround_mask||lfe) && constrained_vbr)
   27a5a:	b163      	cbz	r3, 27a76 <celt_encode_with_ec+0x25ae>
      target = base_target + (opus_int32)MULT16_32_Q15(QCONST16(0.67f, 15), target-base_target);
   27a5c:	1b89      	subs	r1, r1, r6
   27a5e:	b28a      	uxth	r2, r1
   27a60:	f245 50c3 	movw	r0, #21955	; 0x55c3
   27a64:	1409      	asrs	r1, r1, #16
   27a66:	fb00 f202 	mul.w	r2, r0, r2
   27a6a:	13d2      	asrs	r2, r2, #15
   27a6c:	fb00 f101 	mul.w	r1, r0, r1
   27a70:	eb02 0141 	add.w	r1, r2, r1, lsl #1
   27a74:	4431      	add	r1, r6
   if (!has_surround_mask && tf_estimate < QCONST16(.2f, 14))
   27a76:	6db8      	ldr	r0, [r7, #88]	; 0x58
   27a78:	f640 42cc 	movw	r2, #3276	; 0xccc
   27a7c:	4290      	cmp	r0, r2
   27a7e:	f73f a859 	bgt.w	26b34 <celt_encode_with_ec+0x166c>
      amount = MULT16_16_Q15(QCONST16(.0000031f, 30), IMAX(0, IMIN(32000, 96000-bitrate)));
   27a82:	6fba      	ldr	r2, [r7, #120]	; 0x78
   27a84:	f5c2 32bb 	rsb	r2, r2, #95744	; 0x17600
   27a88:	f502 7280 	add.w	r2, r2, #256	; 0x100
   27a8c:	2a00      	cmp	r2, #0
   27a8e:	f6ff a851 	blt.w	26b34 <celt_encode_with_ec+0x166c>
   27a92:	f5b2 4ffa 	cmp.w	r2, #32000	; 0x7d00
   27a96:	ea4f 4521 	mov.w	r5, r1, asr #16
   27a9a:	b28c      	uxth	r4, r1
   27a9c:	f340 8744 	ble.w	28928 <celt_encode_with_ec+0x3460>
   27aa0:	6b78      	ldr	r0, [r7, #52]	; 0x34
   27aa2:	f640 42b2 	movw	r2, #3250	; 0xcb2
   27aa6:	fb10 f202 	smulbb	r2, r0, r2
   27aaa:	1292      	asrs	r2, r2, #10
   27aac:	fb04 f002 	mul.w	r0, r4, r2
   27ab0:	13c0      	asrs	r0, r0, #15
   27ab2:	fb05 f202 	mul.w	r2, r5, r2
   27ab6:	eb00 0242 	add.w	r2, r0, r2, lsl #1
   27aba:	4411      	add	r1, r2
   27abc:	f7ff b83a 	b.w	26b34 <celt_encode_with_ec+0x166c>
      int allow_weak_transients = hybrid && effectiveBytes<15 && st->silk_info.signalType != 2;
   27ac0:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
   27ac4:	2a0e      	cmp	r2, #14
   27ac6:	f73e a899 	bgt.w	25bfc <celt_encode_with_ec+0x734>
   27aca:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
   27ace:	2b02      	cmp	r3, #2
   27ad0:	f43e a894 	beq.w	25bfc <celt_encode_with_ec+0x734>
   ALLOC(tmp, len, opus_val16);
   27ad4:	f106 0308 	add.w	r3, r6, #8
   27ad8:	f023 0307 	bic.w	r3, r3, #7
{
   27adc:	f8c7 d088 	str.w	sp, [r7, #136]	; 0x88
   ALLOC(tmp, len, opus_val16);
   27ae0:	ebad 0d03 	sub.w	sp, sp, r3
   27ae4:	2310      	movs	r3, #16
   27ae6:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
      int allow_weak_transients = hybrid && effectiveBytes<15 && st->silk_info.signalType != 2;
   27aea:	2301      	movs	r3, #1
   27aec:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
      forward_shift = 5;
   27af0:	2305      	movs	r3, #5
   ALLOC(tmp, len, opus_val16);
   27af2:	f10d 0850 	add.w	r8, sp, #80	; 0x50
      forward_shift = 5;
   27af6:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
   27afa:	f7fe b892 	b.w	25c22 <celt_encode_with_ec+0x75a>
   int transient_got_disabled=0;
   27afe:	f8c7 2094 	str.w	r2, [r7, #148]	; 0x94
   27b02:	f7fe ba6c 	b.w	25fde <celt_encode_with_ec+0xb16>
   if (LM>0 && ec_tell(enc)+3<=total_bits && !isTransient && st->complexity>=5 && !st->lfe && !hybrid)
   27b06:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
   27b0a:	699b      	ldr	r3, [r3, #24]
   27b0c:	2b04      	cmp	r3, #4
   27b0e:	f77e ac4e 	ble.w	263ae <celt_encode_with_ec+0xee6>
   27b12:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
   27b16:	2b00      	cmp	r3, #0
   27b18:	f47e ac49 	bne.w	263ae <celt_encode_with_ec+0xee6>
   27b1c:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
   27b20:	2b00      	cmp	r3, #0
   27b22:	f47e ac44 	bne.w	263ae <celt_encode_with_ec+0xee6>
   27b26:	6f3a      	ldr	r2, [r7, #112]	; 0x70
   27b28:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
   27b2c:	f933 3022 	ldrsh.w	r3, [r3, r2, lsl #2]
   if (C==1)
   27b30:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
   27b34:	2a01      	cmp	r2, #1
   27b36:	f001 8098 	beq.w	28c6a <celt_encode_with_ec+0x37a2>
      spread_old[start] = MAX16(oldE[start],oldE[start+nbEBands]);
   27b3a:	f8d7 1110 	ldr.w	r1, [r7, #272]	; 0x110
   27b3e:	f8d7 011c 	ldr.w	r0, [r7, #284]	; 0x11c
   27b42:	f931 2010 	ldrsh.w	r2, [r1, r0, lsl #1]
   27b46:	ea4f 0c40 	mov.w	ip, r0, lsl #1
   27b4a:	460c      	mov	r4, r1
   27b4c:	eb01 060c 	add.w	r6, r1, ip
      for (i=start+1;i<end;i++)
   27b50:	f8d7 1124 	ldr.w	r1, [r7, #292]	; 0x124
      spread_old[start] = MAX16(oldE[start],oldE[start+nbEBands]);
   27b54:	4293      	cmp	r3, r2
   27b56:	bfb8      	it	lt
   27b58:	4613      	movlt	r3, r2
      for (i=start+1;i<end;i++)
   27b5a:	2901      	cmp	r1, #1
      spread_old[start] = MAX16(oldE[start],oldE[start+nbEBands]);
   27b5c:	f8a7 316c 	strh.w	r3, [r7, #364]	; 0x16c
      for (i=start+1;i<end;i++)
   27b60:	f340 86fa 	ble.w	28958 <celt_encode_with_ec+0x3490>
   27b64:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
   27b68:	1e88      	subs	r0, r1, #2
   27b6a:	eb04 0e00 	add.w	lr, r4, r0
   27b6e:	f507 75b6 	add.w	r5, r7, #364	; 0x16c
   27b72:	461a      	mov	r2, r3
         spread_old[i] = MAX16(spread_old[i-1]-QCONST16(1.0f, DB_SHIFT),
   27b74:	f936 3f02 	ldrsh.w	r3, [r6, #2]!
   27b78:	f934 1f02 	ldrsh.w	r1, [r4, #2]!
   27b7c:	428b      	cmp	r3, r1
   27b7e:	f5a2 6280 	sub.w	r2, r2, #1024	; 0x400
   27b82:	bfb8      	it	lt
   27b84:	460b      	movlt	r3, r1
   27b86:	4293      	cmp	r3, r2
   27b88:	bfb8      	it	lt
   27b8a:	4613      	movlt	r3, r2
   27b8c:	b21a      	sxth	r2, r3
      for (i=start+1;i<end;i++)
   27b8e:	45a6      	cmp	lr, r4
         spread_old[i] = MAX16(spread_old[i-1]-QCONST16(1.0f, DB_SHIFT),
   27b90:	f825 2f02 	strh.w	r2, [r5, #2]!
      for (i=start+1;i<end;i++)
   27b94:	d1ee      	bne.n	27b74 <celt_encode_with_ec+0x26ac>
   for (i=end-2;i>=start;i--)
   27b96:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
   27b9a:	2b01      	cmp	r3, #1
   27b9c:	f340 86dc 	ble.w	28958 <celt_encode_with_ec+0x3490>
   27ba0:	f507 73b6 	add.w	r3, r7, #364	; 0x16c
   27ba4:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
   27ba8:	4418      	add	r0, r3
   27baa:	f507 73d0 	add.w	r3, r7, #416	; 0x1a0
   27bae:	4413      	add	r3, r2
   27bb0:	f933 3c36 	ldrsh.w	r3, [r3, #-54]
      spread_old[i] = MAX16(spread_old[i], spread_old[i+1]-QCONST16(1.0f, DB_SHIFT));
   27bb4:	f930 2d02 	ldrsh.w	r2, [r0, #-2]!
   27bb8:	f5a3 6180 	sub.w	r1, r3, #1024	; 0x400
   27bbc:	f2a3 33ff 	subw	r3, r3, #1023	; 0x3ff
   27bc0:	429a      	cmp	r2, r3
   27bc2:	f280 8708 	bge.w	289d6 <celt_encode_with_ec+0x350e>
   for (i=end-2;i>=start;i--)
   27bc6:	f507 73b6 	add.w	r3, r7, #364	; 0x16c
      spread_old[i] = MAX16(spread_old[i], spread_old[i+1]-QCONST16(1.0f, DB_SHIFT));
   27bca:	b20a      	sxth	r2, r1
   for (i=end-2;i>=start;i--)
   27bcc:	4283      	cmp	r3, r0
      spread_old[i] = MAX16(spread_old[i], spread_old[i+1]-QCONST16(1.0f, DB_SHIFT));
   27bce:	8002      	strh	r2, [r0, #0]
   for (i=end-2;i>=start;i--)
   27bd0:	f000 86c2 	beq.w	28958 <celt_encode_with_ec+0x3490>
   opus_val16 temporal_vbr=0;
   27bd4:	4613      	mov	r3, r2
   27bd6:	e7ed      	b.n	27bb4 <celt_encode_with_ec+0x26ec>
        if (st->silk_info.offset > 100) target -= 18 << BITRES >> (3-LM);
   27bd8:	2a64      	cmp	r2, #100	; 0x64
   27bda:	f43f ae7f 	beq.w	278dc <celt_encode_with_ec+0x2414>
   27bde:	6eb9      	ldr	r1, [r7, #104]	; 0x68
   27be0:	2290      	movs	r2, #144	; 0x90
   27be2:	410a      	asrs	r2, r1
   27be4:	1a80      	subs	r0, r0, r2
   27be6:	e679      	b.n	278dc <celt_encode_with_ec+0x2414>
      enabled = ((st->lfe&&nbAvailableBytes>3) || nbAvailableBytes>12*C) && !hybrid && !silence && !st->disable_pf
   27be8:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
   27bec:	6953      	ldr	r3, [r2, #20]
   27bee:	2b00      	cmp	r3, #0
   27bf0:	f040 85d4 	bne.w	2879c <celt_encode_with_ec+0x32d4>
            && st->complexity >= 5;
   27bf4:	6994      	ldr	r4, [r2, #24]
   27bf6:	2c04      	cmp	r4, #4
   27bf8:	bfd4      	ite	le
   27bfa:	2400      	movle	r4, #0
   27bfc:	2401      	movgt	r4, #1
   27bfe:	4611      	mov	r1, r2
   27c00:	f7fd be4b 	b.w	2589a <celt_encode_with_ec+0x3d2>
      for (i=0;i<end;i++)
   27c04:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
   27c08:	2b00      	cmp	r3, #0
   27c0a:	f73e acc2 	bgt.w	26592 <celt_encode_with_ec+0x10ca>
   27c0e:	4619      	mov	r1, r3
   27c10:	f7fe bcd1 	b.w	265b6 <celt_encode_with_ec+0x10ee>
      } else if (shortBlocks || st->complexity < 3 || nbAvailableBytes < 10*C)
   27c14:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
   27c18:	b912      	cbnz	r2, 27c20 <celt_encode_with_ec+0x2758>
   27c1a:	2b02      	cmp	r3, #2
   27c1c:	f300 8658 	bgt.w	288d0 <celt_encode_with_ec+0x3408>
         if (st->complexity == 0)
   27c20:	2b00      	cmp	r3, #0
   27c22:	f47f aecb 	bne.w	279bc <celt_encode_with_ec+0x24f4>
            st->spread_decision = SPREAD_NONE;
   27c26:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
   27c2a:	2300      	movs	r3, #0
   27c2c:	6513      	str	r3, [r2, #80]	; 0x50
   27c2e:	f7fe bdfd 	b.w	2682c <celt_encode_with_ec+0x1364>
   27c32:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
   27c36:	f8d3 c01c 	ldr.w	ip, [r3, #28]
   silence = (sample_max==0);
   27c3a:	2300      	movs	r3, #0
   27c3c:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
   27c40:	f7fd bddf 	b.w	25802 <celt_encode_with_ec+0x33a>
            mask = MAX16(MIN16(st->energy_mask[nbEBands*c+i],
   27c44:	4dc5      	ldr	r5, [pc, #788]	; (27f5c <celt_encode_with_ec+0x2a94>)
   27c46:	f7fe baed 	b.w	26224 <celt_encode_with_ec+0xd5c>
   27c4a:	4655      	mov	r5, sl
   27c4c:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
   27c50:	f8d7 00a4 	ldr.w	r0, [r7, #164]	; 0xa4
   27c54:	f8d7 8048 	ldr.w	r8, [r7, #72]	; 0x48
   27c58:	f8d7 9040 	ldr.w	r9, [r7, #64]	; 0x40
   27c5c:	eb05 0e02 	add.w	lr, r5, r2
   27c60:	eb00 0e4e 	add.w	lr, r0, lr, lsl #1
   27c64:	f8d7 00c8 	ldr.w	r0, [r7, #200]	; 0xc8
   27c68:	006a      	lsls	r2, r5, #1
   27c6a:	1886      	adds	r6, r0, r2
   27c6c:	e01b      	b.n	27ca6 <celt_encode_with_ec+0x27de>
   27c6e:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
   27c72:	4604      	mov	r4, r0
   27c74:	bfa8      	it	ge
   27c76:	f44f 7480 	movge.w	r4, #256	; 0x100
            if (mask > 0)
   27c7a:	2800      	cmp	r0, #0
   27c7c:	dd00      	ble.n	27c80 <celt_encode_with_ec+0x27b8>
   27c7e:	1064      	asrs	r4, r4, #1
            mask_avg += MULT16_16(mask, eBands[i+1]-eBands[i]);
   27c80:	f9b6 a002 	ldrsh.w	sl, [r6, #2]
   27c84:	f936 0b02 	ldrsh.w	r0, [r6], #2
            diff += MULT16_16(mask, 1+2*i-mask_end);
   27c88:	444a      	add	r2, r9
            mask_avg += MULT16_16(mask, eBands[i+1]-eBands[i]);
   27c8a:	ebaa 0000 	sub.w	r0, sl, r0
         for(i=0;i<mask_end;i++)
   27c8e:	3501      	adds	r5, #1
            diff += MULT16_16(mask, 1+2*i-mask_end);
   27c90:	b212      	sxth	r2, r2
            mask_avg += MULT16_16(mask, eBands[i+1]-eBands[i]);
   27c92:	fa0f fa80 	sxth.w	sl, r0
         for(i=0;i<mask_end;i++)
   27c96:	45a8      	cmp	r8, r5
            diff += MULT16_16(mask, 1+2*i-mask_end);
   27c98:	fb04 3302 	mla	r3, r4, r2, r3
            count += eBands[i+1]-eBands[i];
   27c9c:	4484      	add	ip, r0
            mask_avg += MULT16_16(mask, eBands[i+1]-eBands[i]);
   27c9e:	fb04 110a 	mla	r1, r4, sl, r1
         for(i=0;i<mask_end;i++)
   27ca2:	dd06      	ble.n	27cb2 <celt_encode_with_ec+0x27ea>
   27ca4:	006a      	lsls	r2, r5, #1
            mask = MAX16(MIN16(st->energy_mask[nbEBands*c+i],
   27ca6:	f93e 0b02 	ldrsh.w	r0, [lr], #2
   27caa:	4558      	cmp	r0, fp
   27cac:	dadf      	bge.n	27c6e <celt_encode_with_ec+0x27a6>
   27cae:	4cab      	ldr	r4, [pc, #684]	; (27f5c <celt_encode_with_ec+0x2a94>)
   27cb0:	e7e6      	b.n	27c80 <celt_encode_with_ec+0x27b8>
   27cb2:	f8d7 00d0 	ldr.w	r0, [r7, #208]	; 0xd0
   27cb6:	f8d7 411c 	ldr.w	r4, [r7, #284]	; 0x11c
      for (c=0;c<C;c++)
   27cba:	6e3a      	ldr	r2, [r7, #96]	; 0x60
   27cbc:	4420      	add	r0, r4
   27cbe:	f8c7 00d0 	str.w	r0, [r7, #208]	; 0xd0
   27cc2:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
   27cc6:	3201      	adds	r2, #1
   27cc8:	4290      	cmp	r0, r2
   27cca:	663a      	str	r2, [r7, #96]	; 0x60
   27ccc:	f47e aa6b 	bne.w	261a6 <celt_encode_with_ec+0xcde>
   27cd0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   27cd4:	005b      	lsls	r3, r3, #1
   27cd6:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   27cd8:	fb93 f3f2 	sdiv	r3, r3, r2
   27cdc:	ea4f 0e63 	mov.w	lr, r3, asr #1
   27ce0:	f1be 0f20 	cmp.w	lr, #32
   27ce4:	f06f 031f 	mvn.w	r3, #31
   27ce8:	bfa8      	it	ge
   27cea:	f04f 0e20 	movge.w	lr, #32
   27cee:	459e      	cmp	lr, r3
   27cf0:	6cbd      	ldr	r5, [r7, #72]	; 0x48
   27cf2:	fa0f fc8c 	sxth.w	ip, ip
   27cf6:	bfb8      	it	lt
   27cf8:	469e      	movlt	lr, r3
      for (midband=0;eBands[midband+1] < eBands[mask_end]/2;midband++);
   27cfa:	f8d7 00c8 	ldr.w	r0, [r7, #200]	; 0xc8
      mask_avg = DIV32_16(mask_avg,count);
   27cfe:	fb91 f9fc 	sdiv	r9, r1, ip
      for (midband=0;eBands[midband+1] < eBands[mask_end]/2;midband++);
   27d02:	f930 3015 	ldrsh.w	r3, [r0, r5, lsl #1]
   27d06:	f9b0 2002 	ldrsh.w	r2, [r0, #2]
   27d0a:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
   27d0e:	1059      	asrs	r1, r3, #1
      mask_avg = DIV32_16(mask_avg,count);
   27d10:	fa0f fa89 	sxth.w	sl, r9
      for (midband=0;eBands[midband+1] < eBands[mask_end]/2;midband++);
   27d14:	428a      	cmp	r2, r1
      mask_avg += QCONST16(.2f, DB_SHIFT);
   27d16:	f10a 04cd 	add.w	r4, sl, #205	; 0xcd
      for (midband=0;eBands[midband+1] < eBands[mask_end]/2;midband++);
   27d1a:	ea4f 0845 	mov.w	r8, r5, lsl #1
   27d1e:	f280 8675 	bge.w	28a0c <celt_encode_with_ec+0x3544>
   27d22:	1c82      	adds	r2, r0, #2
   27d24:	2300      	movs	r3, #0
   27d26:	f932 0f02 	ldrsh.w	r0, [r2, #2]!
   27d2a:	4288      	cmp	r0, r1
   27d2c:	f103 0301 	add.w	r3, r3, #1
   27d30:	dbf9      	blt.n	27d26 <celt_encode_with_ec+0x285e>
   27d32:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
   27d36:	2a02      	cmp	r2, #2
   27d38:	f000 8556 	beq.w	287e8 <celt_encode_with_ec+0x3320>
   27d3c:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
   27d40:	f8d7 0098 	ldr.w	r0, [r7, #152]	; 0x98
   27d44:	fb03 431e 	mls	r3, r3, lr, r4
   27d48:	1e91      	subs	r1, r2, #2
   27d4a:	f8d7 40b4 	ldr.w	r4, [r7, #180]	; 0xb4
   27d4e:	b29b      	uxth	r3, r3
   27d50:	eb01 0608 	add.w	r6, r1, r8
   27d54:	fa1f f58e 	uxth.w	r5, lr
         unmask = MIN16(unmask, QCONST16(.0f, DB_SHIFT));
   27d58:	f931 2f02 	ldrsh.w	r2, [r1, #2]!
         unmask -= lin;
   27d5c:	2a00      	cmp	r2, #0
   27d5e:	bfd4      	ite	le
   27d60:	ebc3 0202 	rsble	r2, r3, r2
   27d64:	425a      	neggt	r2, r3
   27d66:	b292      	uxth	r2, r2
         if (unmask > QCONST16(.25f, DB_SHIFT))
   27d68:	fa0f fc82 	sxth.w	ip, r2
   27d6c:	442b      	add	r3, r5
   27d6e:	f5bc 7f80 	cmp.w	ip, #256	; 0x100
   27d72:	b29b      	uxth	r3, r3
   27d74:	dd03      	ble.n	27d7e <celt_encode_with_ec+0x28b6>
            surround_dynalloc[i] = unmask - QCONST16(.25f, DB_SHIFT);
   27d76:	f5a2 7280 	sub.w	r2, r2, #256	; 0x100
   27d7a:	8002      	strh	r2, [r0, #0]
            count_dynalloc++;
   27d7c:	3401      	adds	r4, #1
      for(i=0;i<mask_end;i++)
   27d7e:	428e      	cmp	r6, r1
   27d80:	f100 0002 	add.w	r0, r0, #2
   27d84:	d1e8      	bne.n	27d58 <celt_encode_with_ec+0x2890>
   27d86:	f8c7 40b4 	str.w	r4, [r7, #180]	; 0xb4
   27d8a:	4623      	mov	r3, r4
      if (count_dynalloc>=3)
   27d8c:	2b02      	cmp	r3, #2
   27d8e:	f300 84e0 	bgt.w	28752 <celt_encode_with_ec+0x328a>
   27d92:	ea4f 1e8e 	mov.w	lr, lr, lsl #6
   27d96:	fa0f f38e 	sxth.w	r3, lr
   27d9a:	f509 71cd 	add.w	r1, r9, #410	; 0x19a
   27d9e:	62bb      	str	r3, [r7, #40]	; 0x28
   27da0:	b20b      	sxth	r3, r1
   27da2:	62fb      	str	r3, [r7, #44]	; 0x2c
   27da4:	f7fe ba95 	b.w	262d2 <celt_encode_with_ec+0xe0a>
   ALLOC(bandLogE2, C*nbEBands, opus_val16);
   27da8:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
   27dac:	3308      	adds	r3, #8
   27dae:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
   27db2:	f023 0307 	bic.w	r3, r3, #7
   27db6:	ebad 0d03 	sub.w	sp, sp, r3
      compute_mdcts(mode, 0, in, freq, C, CC, LM, st->upsample, st->arch);
   27dba:	e9cd 1403 	strd	r1, r4, [sp, #12]
   27dbe:	f8d7 510c 	ldr.w	r5, [r7, #268]	; 0x10c
   27dc2:	9502      	str	r5, [sp, #8]
   27dc4:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
   27dc8:	9201      	str	r2, [sp, #4]
   27dca:	f8d7 4114 	ldr.w	r4, [r7, #276]	; 0x114
   27dce:	9400      	str	r4, [sp, #0]
   27dd0:	f8d7 6100 	ldr.w	r6, [r7, #256]	; 0x100
   27dd4:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
   27dd8:	4603      	mov	r3, r0
   27dda:	4682      	mov	sl, r0
   27ddc:	2100      	movs	r1, #0
   27dde:	4630      	mov	r0, r6
   27de0:	f7fc f946 	bl	24070 <compute_mdcts>
      compute_band_energies(mode, freq, bandE, effEnd, C, LM, st->arch);
   27de4:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
   27de8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   27dea:	9400      	str	r4, [sp, #0]
   27dec:	e9cd 5301 	strd	r5, r3, [sp, #4]
   27df0:	f8d7 90e4 	ldr.w	r9, [r7, #228]	; 0xe4
   27df4:	f8d7 80d4 	ldr.w	r8, [r7, #212]	; 0xd4
   ALLOC(bandLogE2, C*nbEBands, opus_val16);
   27df8:	ad14      	add	r5, sp, #80	; 0x50
      compute_band_energies(mode, freq, bandE, effEnd, C, LM, st->arch);
   27dfa:	464b      	mov	r3, r9
   27dfc:	4642      	mov	r2, r8
   27dfe:	4651      	mov	r1, sl
   27e00:	4630      	mov	r0, r6
   ALLOC(bandLogE2, C*nbEBands, opus_val16);
   27e02:	f8c7 50cc 	str.w	r5, [r7, #204]	; 0xcc
      compute_band_energies(mode, freq, bandE, effEnd, C, LM, st->arch);
   27e06:	f7fa f937 	bl	22078 <compute_band_energies>
      amp2Log2(mode, effEnd, end, bandE, bandLogE2, C);
   27e0a:	e9cd 5400 	strd	r5, r4, [sp]
   27e0e:	4643      	mov	r3, r8
   27e10:	f8d7 2124 	ldr.w	r2, [r7, #292]	; 0x124
   27e14:	4649      	mov	r1, r9
   27e16:	4630      	mov	r0, r6
   27e18:	f005 fb2e 	bl	2d478 <amp2Log2>
      for (i=0;i<C*nbEBands;i++)
   27e1c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
   27e20:	2b00      	cmp	r3, #0
   27e22:	f340 851b 	ble.w	2885c <celt_encode_with_ec+0x3394>
   27e26:	f8d7 40cc 	ldr.w	r4, [r7, #204]	; 0xcc
   27e2a:	0862      	lsrs	r2, r4, #1
   27e2c:	4618      	mov	r0, r3
   27e2e:	4252      	negs	r2, r2
         bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   27e30:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
   27e34:	f002 0203 	and.w	r2, r2, #3
   27e38:	f343 0305 	sbfx	r3, r3, #0, #6
   27e3c:	1cd1      	adds	r1, r2, #3
   27e3e:	3801      	subs	r0, #1
   27e40:	025b      	lsls	r3, r3, #9
   27e42:	4281      	cmp	r1, r0
   27e44:	b29b      	uxth	r3, r3
   27e46:	f200 85d6 	bhi.w	289f6 <celt_encode_with_ec+0x352e>
   27e4a:	2a00      	cmp	r2, #0
   27e4c:	f000 84c9 	beq.w	287e2 <celt_encode_with_ec+0x331a>
   27e50:	8821      	ldrh	r1, [r4, #0]
   27e52:	2a01      	cmp	r2, #1
   27e54:	4419      	add	r1, r3
   27e56:	8021      	strh	r1, [r4, #0]
   27e58:	f000 84bf 	beq.w	287da <celt_encode_with_ec+0x3312>
   27e5c:	8861      	ldrh	r1, [r4, #2]
   27e5e:	2a03      	cmp	r2, #3
   27e60:	4419      	add	r1, r3
   27e62:	8061      	strh	r1, [r4, #2]
   27e64:	f040 85be 	bne.w	289e4 <celt_encode_with_ec+0x351c>
   27e68:	88a1      	ldrh	r1, [r4, #4]
   27e6a:	4419      	add	r1, r3
   27e6c:	80a1      	strh	r1, [r4, #4]
      for (i=0;i<C*nbEBands;i++)
   27e6e:	f04f 0b03 	mov.w	fp, #3
   27e72:	f8d7 10c0 	ldr.w	r1, [r7, #192]	; 0xc0
   27e76:	eba1 0a02 	sub.w	sl, r1, r2
   27e7a:	f8d7 10cc 	ldr.w	r1, [r7, #204]	; 0xcc
   27e7e:	eb01 0242 	add.w	r2, r1, r2, lsl #1
   27e82:	ea4f 099a 	mov.w	r9, sl, lsr #2
   27e86:	f1a2 0c08 	sub.w	ip, r2, #8
   27e8a:	2600      	movs	r6, #0
         bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   27e8c:	f85c 0f08 	ldr.w	r0, [ip, #8]!
   27e90:	f8dc 4004 	ldr.w	r4, [ip, #4]
   27e94:	2100      	movs	r1, #0
   27e96:	eb03 0804 	add.w	r8, r3, r4
   27e9a:	460d      	mov	r5, r1
   27e9c:	eb03 0e00 	add.w	lr, r3, r0
   27ea0:	eb03 4414 	add.w	r4, r3, r4, lsr #16
   27ea4:	f368 050f 	bfi	r5, r8, #0, #16
   27ea8:	f36e 010f 	bfi	r1, lr, #0, #16
   27eac:	eb03 4010 	add.w	r0, r3, r0, lsr #16
   27eb0:	3601      	adds	r6, #1
   27eb2:	f364 451f 	bfi	r5, r4, #16, #16
   27eb6:	f360 411f 	bfi	r1, r0, #16, #16
   27eba:	454e      	cmp	r6, r9
   27ebc:	e9c2 1500 	strd	r1, r5, [r2]
   27ec0:	f102 0208 	add.w	r2, r2, #8
   27ec4:	d3e2      	bcc.n	27e8c <celt_encode_with_ec+0x29c4>
   27ec6:	f02a 0203 	bic.w	r2, sl, #3
   27eca:	4552      	cmp	r2, sl
   27ecc:	4493      	add	fp, r2
   27ece:	d035      	beq.n	27f3c <celt_encode_with_ec+0x2a74>
   27ed0:	f8d7 40cc 	ldr.w	r4, [r7, #204]	; 0xcc
      for (i=0;i<C*nbEBands;i++)
   27ed4:	f8d7 60c0 	ldr.w	r6, [r7, #192]	; 0xc0
         bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   27ed8:	f834 201b 	ldrh.w	r2, [r4, fp, lsl #1]
      for (i=0;i<C*nbEBands;i++)
   27edc:	f10b 0101 	add.w	r1, fp, #1
         bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   27ee0:	441a      	add	r2, r3
      for (i=0;i<C*nbEBands;i++)
   27ee2:	42b1      	cmp	r1, r6
         bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   27ee4:	f824 201b 	strh.w	r2, [r4, fp, lsl #1]
      for (i=0;i<C*nbEBands;i++)
   27ee8:	da28      	bge.n	27f3c <celt_encode_with_ec+0x2a74>
         bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   27eea:	f834 0011 	ldrh.w	r0, [r4, r1, lsl #1]
      for (i=0;i<C*nbEBands;i++)
   27eee:	f10b 0202 	add.w	r2, fp, #2
         bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   27ef2:	4418      	add	r0, r3
      for (i=0;i<C*nbEBands;i++)
   27ef4:	42b2      	cmp	r2, r6
         bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   27ef6:	f824 0011 	strh.w	r0, [r4, r1, lsl #1]
      for (i=0;i<C*nbEBands;i++)
   27efa:	da1f      	bge.n	27f3c <celt_encode_with_ec+0x2a74>
         bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   27efc:	f834 1012 	ldrh.w	r1, [r4, r2, lsl #1]
      for (i=0;i<C*nbEBands;i++)
   27f00:	f10b 0003 	add.w	r0, fp, #3
         bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   27f04:	4419      	add	r1, r3
      for (i=0;i<C*nbEBands;i++)
   27f06:	42b0      	cmp	r0, r6
         bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   27f08:	f824 1012 	strh.w	r1, [r4, r2, lsl #1]
      for (i=0;i<C*nbEBands;i++)
   27f0c:	da16      	bge.n	27f3c <celt_encode_with_ec+0x2a74>
         bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   27f0e:	f834 1010 	ldrh.w	r1, [r4, r0, lsl #1]
      for (i=0;i<C*nbEBands;i++)
   27f12:	f10b 0204 	add.w	r2, fp, #4
         bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   27f16:	4419      	add	r1, r3
      for (i=0;i<C*nbEBands;i++)
   27f18:	42b2      	cmp	r2, r6
         bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   27f1a:	f824 1010 	strh.w	r1, [r4, r0, lsl #1]
      for (i=0;i<C*nbEBands;i++)
   27f1e:	da0d      	bge.n	27f3c <celt_encode_with_ec+0x2a74>
         bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   27f20:	f834 1012 	ldrh.w	r1, [r4, r2, lsl #1]
      for (i=0;i<C*nbEBands;i++)
   27f24:	f10b 0b05 	add.w	fp, fp, #5
         bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   27f28:	4419      	add	r1, r3
      for (i=0;i<C*nbEBands;i++)
   27f2a:	45b3      	cmp	fp, r6
         bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   27f2c:	f824 1012 	strh.w	r1, [r4, r2, lsl #1]
      for (i=0;i<C*nbEBands;i++)
   27f30:	da04      	bge.n	27f3c <celt_encode_with_ec+0x2a74>
         bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   27f32:	f834 201b 	ldrh.w	r2, [r4, fp, lsl #1]
   27f36:	4413      	add	r3, r2
   27f38:	f824 301b 	strh.w	r3, [r4, fp, lsl #1]
   27f3c:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
   27f40:	69d9      	ldr	r1, [r3, #28]
   27f42:	6c9c      	ldr	r4, [r3, #72]	; 0x48
   ALLOC(bandLogE2, C*nbEBands, opus_val16);
   27f44:	6f7b      	ldr	r3, [r7, #116]	; 0x74
   27f46:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
   secondMdct = shortBlocks && st->complexity>=8;
   27f4a:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
   27f4e:	65fb      	str	r3, [r7, #92]	; 0x5c
   int transient_got_disabled=0;
   27f50:	2300      	movs	r3, #0
   27f52:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
   27f56:	f7fe b870 	b.w	2603a <celt_encode_with_ec+0xb72>
   27f5a:	bf00      	nop
   27f5c:	fffff800 	.word	0xfffff800
   ALLOC(offsets, nbEBands, int);
   27f60:	f104 030a 	add.w	r3, r4, #10
   27f64:	f023 0407 	bic.w	r4, r3, #7
   27f68:	ebad 0d04 	sub.w	sp, sp, r4
   27f6c:	ae14      	add	r6, sp, #80	; 0x50
   ALLOC(importance, nbEBands, int);
   27f6e:	ebad 0d04 	sub.w	sp, sp, r4
   ALLOC(offsets, nbEBands, int);
   27f72:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
   ALLOC(importance, nbEBands, int);
   27f76:	ab14      	add	r3, sp, #80	; 0x50
   ALLOC(spread_weight, nbEBands, int);
   27f78:	ebad 0d04 	sub.w	sp, sp, r4
   27f7c:	a914      	add	r1, sp, #80	; 0x50
   ALLOC(offsets, nbEBands, int);
   27f7e:	f8c7 60a4 	str.w	r6, [r7, #164]	; 0xa4
   ALLOC(importance, nbEBands, int);
   27f82:	633b      	str	r3, [r7, #48]	; 0x30
   ALLOC(spread_weight, nbEBands, int);
   27f84:	6439      	str	r1, [r7, #64]	; 0x40
   27f86:	460a      	mov	r2, r1
   maxDepth = dynalloc_analysis(bandLogE, bandLogE2, nbEBands, start, end, C, offsets,
   27f88:	f8d7 10cc 	ldr.w	r1, [r7, #204]	; 0xcc
   27f8c:	930e      	str	r3, [sp, #56]	; 0x38
   27f8e:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
   27f92:	930d      	str	r3, [sp, #52]	; 0x34
   27f94:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
   27f98:	930c      	str	r3, [sp, #48]	; 0x30
   27f9a:	6e7e      	ldr	r6, [r7, #100]	; 0x64
   27f9c:	960b      	str	r6, [sp, #44]	; 0x2c
   27f9e:	f8d7 60a8 	ldr.w	r6, [r7, #168]	; 0xa8
   27fa2:	960a      	str	r6, [sp, #40]	; 0x28
   27fa4:	f8d7 610c 	ldr.w	r6, [r7, #268]	; 0x10c
   27fa8:	9609      	str	r6, [sp, #36]	; 0x24
   27faa:	f8d7 60c8 	ldr.w	r6, [r7, #200]	; 0xc8
   27fae:	9006      	str	r0, [sp, #24]
   27fb0:	e9cd 5607 	strd	r5, r6, [sp, #28]
   27fb4:	f8d7 0118 	ldr.w	r0, [r7, #280]	; 0x118
   27fb8:	f8cd e00c 	str.w	lr, [sp, #12]
   27fbc:	e9cd 8004 	strd	r8, r0, [sp, #16]
   27fc0:	f8d7 60a4 	ldr.w	r6, [r7, #164]	; 0xa4
   27fc4:	9602      	str	r6, [sp, #8]
   27fc6:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
   27fca:	9001      	str	r0, [sp, #4]
   27fcc:	f8d7 0124 	ldr.w	r0, [r7, #292]	; 0x124
   27fd0:	9000      	str	r0, [sp, #0]
   27fd2:	920f      	str	r2, [sp, #60]	; 0x3c
   27fd4:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
   27fd8:	f8d7 00d8 	ldr.w	r0, [r7, #216]	; 0xd8
   27fdc:	f7fc f8ea 	bl	241b4 <dynalloc_analysis.isra.5>
   ALLOC(tf_res, nbEBands, int);
   27fe0:	ebad 0d04 	sub.w	sp, sp, r4
   27fe4:	f10d 0353 	add.w	r3, sp, #83	; 0x53
   bias = MULT16_16_Q14(QCONST16(.04f,15), MAX16(-QCONST16(.25f,14), QCONST16(.5f,14)-tf_estimate));
   27fe8:	6dba      	ldr	r2, [r7, #88]	; 0x58
      lambda = IMAX(80, 20480/effectiveBytes + 2);
   27fea:	f8d7 60a8 	ldr.w	r6, [r7, #168]	; 0xa8
   maxDepth = dynalloc_analysis(bandLogE, bandLogE2, nbEBands, start, end, C, offsets,
   27fee:	6478      	str	r0, [r7, #68]	; 0x44
   ALLOC(tf_res, nbEBands, int);
   27ff0:	0899      	lsrs	r1, r3, #2
      lambda = IMAX(80, 20480/effectiveBytes + 2);
   27ff2:	f44f 43a0 	mov.w	r3, #20480	; 0x5000
   27ff6:	fb93 f3f6 	sdiv	r3, r3, r6
   27ffa:	2b4e      	cmp	r3, #78	; 0x4e
   27ffc:	bfb8      	it	lt
   27ffe:	234e      	movlt	r3, #78	; 0x4e
   bias = MULT16_16_Q14(QCONST16(.04f,15), MAX16(-QCONST16(.25f,14), QCONST16(.5f,14)-tf_estimate));
   28000:	f5c2 5200 	rsb	r2, r2, #8192	; 0x2000
   ALLOC(tf_res, nbEBands, int);
   28004:	6079      	str	r1, [r7, #4]
      lambda = IMAX(80, 20480/effectiveBytes + 2);
   28006:	3302      	adds	r3, #2
   ALLOC(tf_res, nbEBands, int);
   28008:	0089      	lsls	r1, r1, #2
   bias = MULT16_16_Q14(QCONST16(.04f,15), MAX16(-QCONST16(.25f,14), QCONST16(.5f,14)-tf_estimate));
   2800a:	f512 5f80 	cmn.w	r2, #4096	; 0x1000
   ALLOC(tf_res, nbEBands, int);
   2800e:	f8c7 10cc 	str.w	r1, [r7, #204]	; 0xcc
      lambda = IMAX(80, 20480/effectiveBytes + 2);
   28012:	627b      	str	r3, [r7, #36]	; 0x24
{
   28014:	f8c7 d014 	str.w	sp, [r7, #20]
   bias = MULT16_16_Q14(QCONST16(.04f,15), MAX16(-QCONST16(.25f,14), QCONST16(.5f,14)-tf_estimate));
   28018:	f280 82f2 	bge.w	28600 <celt_encode_with_ec+0x3138>
   2801c:	4999      	ldr	r1, [pc, #612]	; (28284 <celt_encode_with_ec+0x2dbc>)
   ALLOC(tmp, (m->eBands[len]-m->eBands[len-1])<<LM, celt_norm);
   2801e:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
   28022:	f8d7 40e4 	ldr.w	r4, [r7, #228]	; 0xe4
   28026:	699a      	ldr	r2, [r3, #24]
   28028:	0063      	lsls	r3, r4, #1
   2802a:	18d0      	adds	r0, r2, r3
   2802c:	667b      	str	r3, [r7, #100]	; 0x64
   2802e:	f930 0c02 	ldrsh.w	r0, [r0, #-2]
   28032:	f932 3014 	ldrsh.w	r3, [r2, r4, lsl #1]
   28036:	1a1b      	subs	r3, r3, r0
   28038:	f8d7 010c 	ldr.w	r0, [r7, #268]	; 0x10c
   2803c:	4083      	lsls	r3, r0
   ALLOC(metric, len, int);
   2803e:	00a0      	lsls	r0, r4, #2
   28040:	6138      	str	r0, [r7, #16]
   ALLOC(tmp, (m->eBands[len]-m->eBands[len-1])<<LM, celt_norm);
   28042:	005b      	lsls	r3, r3, #1
   ALLOC(metric, len, int);
   28044:	300a      	adds	r0, #10
   28046:	f020 0007 	bic.w	r0, r0, #7
   ALLOC(tmp, (m->eBands[len]-m->eBands[len-1])<<LM, celt_norm);
   2804a:	3308      	adds	r3, #8
   2804c:	f023 0307 	bic.w	r3, r3, #7
   ALLOC(metric, len, int);
   28050:	ebad 0d00 	sub.w	sp, sp, r0
   28054:	ad14      	add	r5, sp, #80	; 0x50
   ALLOC(tmp, (m->eBands[len]-m->eBands[len-1])<<LM, celt_norm);
   28056:	ebad 0d03 	sub.w	sp, sp, r3
   2805a:	f10d 0b50 	add.w	fp, sp, #80	; 0x50
   ALLOC(tmp_1, (m->eBands[len]-m->eBands[len-1])<<LM, celt_norm);
   2805e:	ebad 0d03 	sub.w	sp, sp, r3
   28062:	ab14      	add	r3, sp, #80	; 0x50
   ALLOC(path0, len, int);
   28064:	ebad 0d00 	sub.w	sp, sp, r0
   ALLOC(tmp_1, (m->eBands[len]-m->eBands[len-1])<<LM, celt_norm);
   28068:	60fb      	str	r3, [r7, #12]
   ALLOC(path0, len, int);
   2806a:	ab14      	add	r3, sp, #80	; 0x50
   ALLOC(path1, len, int);
   2806c:	ebad 0d00 	sub.w	sp, sp, r0
   ALLOC(path0, len, int);
   28070:	61fb      	str	r3, [r7, #28]
   for (i=0;i<len;i++)
   28072:	2c00      	cmp	r4, #0
   ALLOC(path1, len, int);
   28074:	ab14      	add	r3, sp, #80	; 0x50
   ALLOC(metric, len, int);
   28076:	f8c7 5098 	str.w	r5, [r7, #152]	; 0x98
   ALLOC(path1, len, int);
   2807a:	61bb      	str	r3, [r7, #24]
   for (i=0;i<len;i++)
   2807c:	f340 8113 	ble.w	282a6 <celt_encode_with_ec+0x2dde>
   L1 = MAC16_32_Q15(L1, LM*bias, L1);
   28080:	f8d7 410c 	ldr.w	r4, [r7, #268]	; 0x10c
   28084:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
      OPUS_COPY(tmp, &X[tf_chan*N0 + (m->eBands[i]<<LM)], N);
   28088:	f8d7 509c 	ldr.w	r5, [r7, #156]	; 0x9c
   2808c:	f8d7 60f0 	ldr.w	r6, [r7, #240]	; 0xf0
   28090:	f8c7 b128 	str.w	fp, [r7, #296]	; 0x128
   L1 = MAC16_32_Q15(L1, LM*bias, L1);
   28094:	b289      	uxth	r1, r1
   28096:	2b00      	cmp	r3, #0
         L1 = l1_metric(tmp_1, N, LM+1, bias);
   28098:	f104 0301 	add.w	r3, r4, #1
   L1 = MAC16_32_Q15(L1, LM*bias, L1);
   2809c:	fb13 f301 	smulbb	r3, r3, r1
   280a0:	bf14      	ite	ne
   280a2:	4620      	movne	r0, r4
   280a4:	2000      	moveq	r0, #0
   280a6:	fb10 f001 	smulbb	r0, r0, r1
   280aa:	b21b      	sxth	r3, r3
   280ac:	f8c7 1104 	str.w	r1, [r7, #260]	; 0x104
      if (narrow && (metric[i]==0 || metric[i]==-2*LM))
   280b0:	ebc4 71c4 	rsb	r1, r4, r4, lsl #31
   L1 = MAC16_32_Q15(L1, LM*bias, L1);
   280b4:	603b      	str	r3, [r7, #0]
      if (narrow && (metric[i]==0 || metric[i]==-2*LM))
   280b6:	004b      	lsls	r3, r1, #1
   280b8:	60bb      	str	r3, [r7, #8]
   280ba:	2300      	movs	r3, #0
      OPUS_COPY(tmp, &X[tf_chan*N0 + (m->eBands[i]<<LM)], N);
   280bc:	fb06 f505 	mul.w	r5, r6, r5
   L1 = MAC16_32_Q15(L1, LM*bias, L1);
   280c0:	b200      	sxth	r0, r0
      if (narrow && (metric[i]==0 || metric[i]==-2*LM))
   280c2:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
   280c6:	f1ab 0902 	sub.w	r9, fp, #2
   280ca:	1e63      	subs	r3, r4, #1
      OPUS_COPY(tmp, &X[tf_chan*N0 + (m->eBands[i]<<LM)], N);
   280cc:	65fd      	str	r5, [r7, #92]	; 0x5c
   L1 = MAC16_32_Q15(L1, LM*bias, L1);
   280ce:	64b8      	str	r0, [r7, #72]	; 0x48
   280d0:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
   280d4:	46a2      	mov	sl, r4
   280d6:	46cb      	mov	fp, r9
      N = (m->eBands[i+1]-m->eBands[i])<<LM;
   280d8:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
      OPUS_COPY(tmp, &X[tf_chan*N0 + (m->eBands[i]<<LM)], N);
   280dc:	f8d7 0128 	ldr.w	r0, [r7, #296]	; 0x128
      N = (m->eBands[i+1]-m->eBands[i])<<LM;
   280e0:	1c99      	adds	r1, r3, #2
   280e2:	5ed3      	ldrsh	r3, [r2, r3]
   280e4:	5e52      	ldrsh	r2, [r2, r1]
   280e6:	f8c7 109c 	str.w	r1, [r7, #156]	; 0x9c
   280ea:	1ad2      	subs	r2, r2, r3
      OPUS_COPY(tmp, &X[tf_chan*N0 + (m->eBands[i]<<LM)], N);
   280ec:	fa03 f10a 	lsl.w	r1, r3, sl
   280f0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
      N = (m->eBands[i+1]-m->eBands[i])<<LM;
   280f2:	f8c7 20fc 	str.w	r2, [r7, #252]	; 0xfc
   280f6:	fa02 f90a 	lsl.w	r9, r2, sl
      OPUS_COPY(tmp, &X[tf_chan*N0 + (m->eBands[i]<<LM)], N);
   280fa:	4419      	add	r1, r3
   280fc:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
   28100:	ea4f 0549 	mov.w	r5, r9, lsl #1
   28104:	eb03 0141 	add.w	r1, r3, r1, lsl #1
   28108:	462a      	mov	r2, r5
   2810a:	f7e3 fff9 	bl	c100 <memcpy>
   for (i=0;i<N;i++)
   2810e:	f1b9 0f00 	cmp.w	r9, #0
   28112:	f340 81ff 	ble.w	28514 <celt_encode_with_ec+0x304c>
   28116:	4659      	mov	r1, fp
   28118:	eb0b 0405 	add.w	r4, fp, r5
   L1 = 0;
   2811c:	2000      	movs	r0, #0
      L1 += EXTEND32(ABS16(tmp[i]));
   2811e:	f931 3f02 	ldrsh.w	r3, [r1, #2]!
   28122:	2b00      	cmp	r3, #0
   28124:	bfb8      	it	lt
   28126:	425b      	neglt	r3, r3
   for (i=0;i<N;i++)
   28128:	428c      	cmp	r4, r1
      L1 += EXTEND32(ABS16(tmp[i]));
   2812a:	4418      	add	r0, r3
   for (i=0;i<N;i++)
   2812c:	d1f7      	bne.n	2811e <celt_encode_with_ec+0x2c56>
   2812e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   28130:	f3c0 020e 	ubfx	r2, r0, #0, #15
   28134:	fb03 f202 	mul.w	r2, r3, r2
   28138:	13d2      	asrs	r2, r2, #15
   2813a:	ea4f 38e0 	mov.w	r8, r0, asr #15
   2813e:	fb13 2808 	smlabb	r8, r3, r8, r2
   28142:	4480      	add	r8, r0
      if (isTransient && !narrow)
   28144:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
   28148:	2b00      	cmp	r3, #0
   2814a:	d079      	beq.n	28240 <celt_encode_with_ec+0x2d78>
   2814c:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
   28150:	2b01      	cmp	r3, #1
   28152:	d14a      	bne.n	281ea <celt_encode_with_ec+0x2d22>
      int best_level=0;
   28154:	2300      	movs	r3, #0
   28156:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
      for (k=0;k<LM+!(isTransient||narrow);k++)
   2815a:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
   2815e:	445d      	add	r5, fp
            best_level = -1;
   28160:	2100      	movs	r1, #0
      for (k=0;k<LM+!(isTransient||narrow);k++)
   28162:	2b00      	cmp	r3, #0
   28164:	d138      	bne.n	281d8 <celt_encode_with_ec+0x2d10>
   28166:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
   2816a:	2b01      	cmp	r3, #1
   2816c:	bf0c      	ite	eq
   2816e:	4652      	moveq	r2, sl
   28170:	f10a 0201 	addne.w	r2, sl, #1
   28174:	4291      	cmp	r1, r2
   28176:	da7f      	bge.n	28278 <celt_encode_with_ec+0x2db0>
   28178:	1c4e      	adds	r6, r1, #1
   2817a:	4634      	mov	r4, r6
         haar1(tmp, N>>k, 1<<k);
   2817c:	2301      	movs	r3, #1
   2817e:	fa03 f201 	lsl.w	r2, r3, r1
   28182:	f8d7 0128 	ldr.w	r0, [r7, #296]	; 0x128
   28186:	fa49 f101 	asr.w	r1, r9, r1
   2818a:	f7fa f9db 	bl	22544 <haar1>
   2818e:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
   for (i=0;i<N;i++)
   28192:	f1b9 0f00 	cmp.w	r9, #0
   28196:	fb14 f403 	smulbb	r4, r4, r3
   2819a:	b224      	sxth	r4, r4
   2819c:	dd23      	ble.n	281e6 <celt_encode_with_ec+0x2d1e>
   2819e:	4659      	mov	r1, fp
   L1 = 0;
   281a0:	2000      	movs	r0, #0
      L1 += EXTEND32(ABS16(tmp[i]));
   281a2:	f931 3f02 	ldrsh.w	r3, [r1, #2]!
   281a6:	2b00      	cmp	r3, #0
   281a8:	bfb8      	it	lt
   281aa:	425b      	neglt	r3, r3
   for (i=0;i<N;i++)
   281ac:	428d      	cmp	r5, r1
      L1 += EXTEND32(ABS16(tmp[i]));
   281ae:	4418      	add	r0, r3
   for (i=0;i<N;i++)
   281b0:	d1f7      	bne.n	281a2 <celt_encode_with_ec+0x2cda>
   281b2:	f3c0 010e 	ubfx	r1, r0, #0, #15
   281b6:	fb04 f101 	mul.w	r1, r4, r1
   281ba:	13c2      	asrs	r2, r0, #15
   281bc:	13c9      	asrs	r1, r1, #15
   281be:	fb12 1404 	smlabb	r4, r2, r4, r1
   281c2:	4420      	add	r0, r4
      for (k=0;k<LM+!(isTransient||narrow);k++)
   281c4:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
         if (L1 < best_L1)
   281c8:	4580      	cmp	r8, r0
   281ca:	bfc4      	itt	gt
   281cc:	4680      	movgt	r8, r0
            best_level = k+1;
   281ce:	f8c7 60ec 	strgt.w	r6, [r7, #236]	; 0xec
   281d2:	4631      	mov	r1, r6
      for (k=0;k<LM+!(isTransient||narrow);k++)
   281d4:	2b00      	cmp	r3, #0
   281d6:	d0c6      	beq.n	28166 <celt_encode_with_ec+0x2c9e>
   281d8:	4551      	cmp	r1, sl
   281da:	da34      	bge.n	28246 <celt_encode_with_ec+0x2d7e>
   281dc:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
   281e0:	1c4e      	adds	r6, r1, #1
   281e2:	1a5c      	subs	r4, r3, r1
   281e4:	e7ca      	b.n	2817c <celt_encode_with_ec+0x2cb4>
   for (i=0;i<N;i++)
   281e6:	2000      	movs	r0, #0
   281e8:	e7ec      	b.n	281c4 <celt_encode_with_ec+0x2cfc>
         OPUS_COPY(tmp_1, tmp, N);
   281ea:	68fc      	ldr	r4, [r7, #12]
   281ec:	f8d7 1128 	ldr.w	r1, [r7, #296]	; 0x128
   281f0:	462a      	mov	r2, r5
   281f2:	4620      	mov	r0, r4
   281f4:	f7e3 ff84 	bl	c100 <memcpy>
         haar1(tmp_1, N>>LM, 1<<LM);
   281f8:	6f7a      	ldr	r2, [r7, #116]	; 0x74
   281fa:	fa49 f10a 	asr.w	r1, r9, sl
   281fe:	4620      	mov	r0, r4
   28200:	f7fa f9a0 	bl	22544 <haar1>
   for (i=0;i<N;i++)
   28204:	f1b9 0f00 	cmp.w	r9, #0
   28208:	f340 833e 	ble.w	28888 <celt_encode_with_ec+0x33c0>
   2820c:	1ea1      	subs	r1, r4, #2
   2820e:	194c      	adds	r4, r1, r5
   L1 = 0;
   28210:	2000      	movs	r0, #0
      L1 += EXTEND32(ABS16(tmp[i]));
   28212:	f931 3f02 	ldrsh.w	r3, [r1, #2]!
   28216:	2b00      	cmp	r3, #0
   28218:	bfb8      	it	lt
   2821a:	425b      	neglt	r3, r3
   for (i=0;i<N;i++)
   2821c:	428c      	cmp	r4, r1
      L1 += EXTEND32(ABS16(tmp[i]));
   2821e:	4418      	add	r0, r3
   for (i=0;i<N;i++)
   28220:	d1f7      	bne.n	28212 <celt_encode_with_ec+0x2d4a>
   28222:	683b      	ldr	r3, [r7, #0]
   28224:	f3c0 020e 	ubfx	r2, r0, #0, #15
   28228:	fb03 f202 	mul.w	r2, r3, r2
   2822c:	13d1      	asrs	r1, r2, #15
   2822e:	13c2      	asrs	r2, r0, #15
   28230:	fb13 1202 	smlabb	r2, r3, r2, r1
   28234:	4410      	add	r0, r2
         if (L1<best_L1)
   28236:	4580      	cmp	r8, r0
   28238:	dd8c      	ble.n	28154 <celt_encode_with_ec+0x2c8c>
   2823a:	4680      	mov	r8, r0
            best_level = -1;
   2823c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   28240:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
   28244:	e789      	b.n	2815a <celt_encode_with_ec+0x2c92>
         metric[i] = 2*best_level;
   28246:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
   2824a:	005b      	lsls	r3, r3, #1
   2824c:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
   28250:	f8d7 10dc 	ldr.w	r1, [r7, #220]	; 0xdc
   28254:	f842 3011 	str.w	r3, [r2, r1, lsl #1]
      if (narrow && (metric[i]==0 || metric[i]==-2*LM))
   28258:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
   2825c:	2a01      	cmp	r2, #1
   2825e:	d013      	beq.n	28288 <celt_encode_with_ec+0x2dc0>
   for (i=0;i<len;i++)
   28260:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   28262:	4619      	mov	r1, r3
   28264:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
   28268:	4299      	cmp	r1, r3
   2826a:	d01c      	beq.n	282a6 <celt_encode_with_ec+0x2dde>
   2826c:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
   28270:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
   28274:	699a      	ldr	r2, [r3, #24]
   28276:	e72f      	b.n	280d8 <celt_encode_with_ec+0x2c10>
         metric[i] = -2*best_level;
   28278:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
   2827c:	ebc3 73c3 	rsb	r3, r3, r3, lsl #31
   28280:	005b      	lsls	r3, r3, #1
   28282:	e7e3      	b.n	2824c <celt_encode_with_ec+0x2d84>
   28284:	fffffeb8 	.word	0xfffffeb8
      if (narrow && (metric[i]==0 || metric[i]==-2*LM))
   28288:	b113      	cbz	r3, 28290 <celt_encode_with_ec+0x2dc8>
   2828a:	68ba      	ldr	r2, [r7, #8]
   2828c:	429a      	cmp	r2, r3
   2828e:	d1e7      	bne.n	28260 <celt_encode_with_ec+0x2d98>
         metric[i]-=1;
   28290:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
   28294:	3b01      	subs	r3, #1
   28296:	f842 3011 	str.w	r3, [r2, r1, lsl #1]
   for (i=0;i<len;i++)
   2829a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   2829c:	4619      	mov	r1, r3
   2829e:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
   282a2:	4299      	cmp	r1, r3
   282a4:	d1e2      	bne.n	2826c <celt_encode_with_ec+0x2da4>
      cost0 = importance[0]*abs(metric[0]-2*tf_select_table[LM][4*isTransient+2*sel+0]);
   282a6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   282a8:	f8d7 0118 	ldr.w	r0, [r7, #280]	; 0x118
   282ac:	681a      	ldr	r2, [r3, #0]
   282ae:	f8c7 2128 	str.w	r2, [r7, #296]	; 0x128
   282b2:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
   282b6:	4cdb      	ldr	r4, [pc, #876]	; (28624 <celt_encode_with_ec+0x315c>)
   282b8:	6812      	ldr	r2, [r2, #0]
   282ba:	f8c7 2104 	str.w	r2, [r7, #260]	; 0x104
   282be:	0041      	lsls	r1, r0, #1
   282c0:	2800      	cmp	r0, #0
   282c2:	f8d7 010c 	ldr.w	r0, [r7, #268]	; 0x10c
   282c6:	693a      	ldr	r2, [r7, #16]
   282c8:	f8c7 10d0 	str.w	r1, [r7, #208]	; 0xd0
   282cc:	eb01 0b80 	add.w	fp, r1, r0, lsl #2
   282d0:	6a79      	ldr	r1, [r7, #36]	; 0x24
   282d2:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
   282d6:	f1a2 0204 	sub.w	r2, r2, #4
   282da:	4608      	mov	r0, r1
   282dc:	eb03 0a02 	add.w	sl, r3, r2
   282e0:	bf18      	it	ne
   282e2:	2000      	movne	r0, #0
   for (sel=0;sel<2;sel++)
   282e4:	2300      	movs	r3, #0
   282e6:	667c      	str	r4, [r7, #100]	; 0x64
   282e8:	f8c7 20dc 	str.w	r2, [r7, #220]	; 0xdc
   282ec:	eb04 0b4b 	add.w	fp, r4, fp, lsl #1
   282f0:	f8c7 00ec 	str.w	r0, [r7, #236]	; 0xec
   282f4:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
   282f8:	65fa      	str	r2, [r7, #92]	; 0x5c
   282fa:	460e      	mov	r6, r1
      cost0 = importance[0]*abs(metric[0]-2*tf_select_table[LM][4*isTransient+2*sel+0]);
   282fc:	f99b 8000 	ldrsb.w	r8, [fp]
   28300:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
      cost1 = importance[0]*abs(metric[0]-2*tf_select_table[LM][4*isTransient+2*sel+1]) + (isTransient ? 0 : lambda);
   28304:	f99b 9001 	ldrsb.w	r9, [fp, #1]
   28308:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
      cost0 = importance[0]*abs(metric[0]-2*tf_select_table[LM][4*isTransient+2*sel+0]);
   2830c:	ea4f 0848 	mov.w	r8, r8, lsl #1
   28310:	eba3 0008 	sub.w	r0, r3, r8
      cost1 = importance[0]*abs(metric[0]-2*tf_select_table[LM][4*isTransient+2*sel+1]) + (isTransient ? 0 : lambda);
   28314:	ea4f 0949 	mov.w	r9, r9, lsl #1
   28318:	eba3 0109 	sub.w	r1, r3, r9
      cost0 = importance[0]*abs(metric[0]-2*tf_select_table[LM][4*isTransient+2*sel+0]);
   2831c:	2800      	cmp	r0, #0
   2831e:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
   28322:	bfb8      	it	lt
   28324:	4240      	neglt	r0, r0
      cost1 = importance[0]*abs(metric[0]-2*tf_select_table[LM][4*isTransient+2*sel+1]) + (isTransient ? 0 : lambda);
   28326:	2900      	cmp	r1, #0
   28328:	bfb8      	it	lt
   2832a:	4249      	neglt	r1, r1
      cost0 = importance[0]*abs(metric[0]-2*tf_select_table[LM][4*isTransient+2*sel+0]);
   2832c:	fb03 f000 	mul.w	r0, r3, r0
      cost1 = importance[0]*abs(metric[0]-2*tf_select_table[LM][4*isTransient+2*sel+1]) + (isTransient ? 0 : lambda);
   28330:	fb03 2101 	mla	r1, r3, r1, r2
      for (i=1;i<len;i++)
   28334:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
   28338:	2b01      	cmp	r3, #1
   2833a:	dd25      	ble.n	28388 <celt_encode_with_ec+0x2ec0>
   2833c:	f8d7 5098 	ldr.w	r5, [r7, #152]	; 0x98
   28340:	6b3c      	ldr	r4, [r7, #48]	; 0x30
         cost0 = curr0 + importance[i]*abs(metric[i]-2*tf_select_table[LM][4*isTransient+2*sel+0]);
   28342:	f855 3f04 	ldr.w	r3, [r5, #4]!
   28346:	f854 2f04 	ldr.w	r2, [r4, #4]!
   2834a:	eba3 0c08 	sub.w	ip, r3, r8
   2834e:	f1bc 0f00 	cmp.w	ip, #0
         cost1 = curr1 + importance[i]*abs(metric[i]-2*tf_select_table[LM][4*isTransient+2*sel+1]);
   28352:	eba3 0309 	sub.w	r3, r3, r9
         cost0 = curr0 + importance[i]*abs(metric[i]-2*tf_select_table[LM][4*isTransient+2*sel+0]);
   28356:	bfb8      	it	lt
   28358:	f1cc 0c00 	rsblt	ip, ip, #0
         cost1 = curr1 + importance[i]*abs(metric[i]-2*tf_select_table[LM][4*isTransient+2*sel+1]);
   2835c:	2b00      	cmp	r3, #0
   2835e:	bfb8      	it	lt
   28360:	425b      	neglt	r3, r3
         cost0 = curr0 + importance[i]*abs(metric[i]-2*tf_select_table[LM][4*isTransient+2*sel+0]);
   28362:	fb02 fc0c 	mul.w	ip, r2, ip
         cost1 = curr1 + importance[i]*abs(metric[i]-2*tf_select_table[LM][4*isTransient+2*sel+1]);
   28366:	fb02 f303 	mul.w	r3, r2, r3
         curr1 = IMIN(cost0 + lambda, cost1);
   2836a:	eb06 0e00 	add.w	lr, r6, r0
         curr0 = IMIN(cost0, cost1 + lambda);
   2836e:	1872      	adds	r2, r6, r1
         cost0 = curr0 + importance[i]*abs(metric[i]-2*tf_select_table[LM][4*isTransient+2*sel+0]);
   28370:	4282      	cmp	r2, r0
   28372:	bfd4      	ite	le
   28374:	eb0c 0002 	addle.w	r0, ip, r2
   28378:	4460      	addgt	r0, ip
         cost1 = curr1 + importance[i]*abs(metric[i]-2*tf_select_table[LM][4*isTransient+2*sel+1]);
   2837a:	458e      	cmp	lr, r1
   2837c:	bfd4      	ite	le
   2837e:	eb03 010e 	addle.w	r1, r3, lr
   28382:	1859      	addgt	r1, r3, r1
      for (i=1;i<len;i++)
   28384:	45a2      	cmp	sl, r4
   28386:	d1dc      	bne.n	28342 <celt_encode_with_ec+0x2e7a>
      cost0 = IMIN(cost0, cost1);
   28388:	4281      	cmp	r1, r0
   2838a:	bfa8      	it	ge
   2838c:	4601      	movge	r1, r0
      selcost[sel]=cost0;
   2838e:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
   28392:	f507 70b6 	add.w	r0, r7, #364	; 0x16c
   28396:	f10b 0b02 	add.w	fp, fp, #2
   2839a:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
   for (sel=0;sel<2;sel++)
   2839e:	2b00      	cmp	r3, #0
   283a0:	f000 80b4 	beq.w	2850c <celt_encode_with_ec+0x3044>
   if (selcost[1]<selcost[0] && isTransient)
   283a4:	f8d7 2170 	ldr.w	r2, [r7, #368]	; 0x170
   283a8:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
   283ac:	6dfe      	ldr	r6, [r7, #92]	; 0x5c
   283ae:	429a      	cmp	r2, r3
   283b0:	f280 8120 	bge.w	285f4 <celt_encode_with_ec+0x312c>
   283b4:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
   283b8:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
      tf_select=1;
   283bc:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
   283c0:	4611      	mov	r1, r2
   283c2:	4419      	add	r1, r3
   283c4:	f8c7 10d0 	str.w	r1, [r7, #208]	; 0xd0
   cost0 = importance[0]*abs(metric[0]-2*tf_select_table[LM][4*isTransient+2*tf_select+0]);
   283c8:	f8d7 210c 	ldr.w	r2, [r7, #268]	; 0x10c
   283cc:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   283ce:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   283d2:	eb03 0241 	add.w	r2, r3, r1, lsl #1
   283d6:	f913 9011 	ldrsb.w	r9, [r3, r1, lsl #1]
   cost1 = importance[0]*abs(metric[0]-2*tf_select_table[LM][4*isTransient+2*tf_select+1]) + (isTransient ? 0 : lambda);
   283da:	f992 a001 	ldrsb.w	sl, [r2, #1]
   283de:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
   283e2:	f8d7 1128 	ldr.w	r1, [r7, #296]	; 0x128
   283e6:	ea4f 0a4a 	mov.w	sl, sl, lsl #1
   283ea:	eba2 030a 	sub.w	r3, r2, sl
   cost0 = importance[0]*abs(metric[0]-2*tf_select_table[LM][4*isTransient+2*tf_select+0]);
   283ee:	ea4f 0949 	mov.w	r9, r9, lsl #1
   283f2:	eba2 0209 	sub.w	r2, r2, r9
   cost1 = importance[0]*abs(metric[0]-2*tf_select_table[LM][4*isTransient+2*tf_select+1]) + (isTransient ? 0 : lambda);
   283f6:	2b00      	cmp	r3, #0
   283f8:	bfb8      	it	lt
   283fa:	425b      	neglt	r3, r3
   cost0 = importance[0]*abs(metric[0]-2*tf_select_table[LM][4*isTransient+2*tf_select+0]);
   283fc:	2a00      	cmp	r2, #0
   283fe:	bfb8      	it	lt
   28400:	4252      	neglt	r2, r2
   cost1 = importance[0]*abs(metric[0]-2*tf_select_table[LM][4*isTransient+2*tf_select+1]) + (isTransient ? 0 : lambda);
   28402:	fb01 f303 	mul.w	r3, r1, r3
   cost0 = importance[0]*abs(metric[0]-2*tf_select_table[LM][4*isTransient+2*tf_select+0]);
   28406:	fb01 f202 	mul.w	r2, r1, r2
   cost1 = importance[0]*abs(metric[0]-2*tf_select_table[LM][4*isTransient+2*tf_select+1]) + (isTransient ? 0 : lambda);
   2840a:	f8d7 1118 	ldr.w	r1, [r7, #280]	; 0x118
   2840e:	b909      	cbnz	r1, 28414 <celt_encode_with_ec+0x2f4c>
   28410:	6a79      	ldr	r1, [r7, #36]	; 0x24
   28412:	440b      	add	r3, r1
   for (i=1;i<len;i++)
   28414:	f8d7 10e4 	ldr.w	r1, [r7, #228]	; 0xe4
   28418:	2901      	cmp	r1, #1
   2841a:	dd3f      	ble.n	2849c <celt_encode_with_ec+0x2fd4>
   2841c:	69b8      	ldr	r0, [r7, #24]
   2841e:	f8d7 40dc 	ldr.w	r4, [r7, #220]	; 0xdc
   28422:	f8c7 9128 	str.w	r9, [r7, #296]	; 0x128
   28426:	f8d7 1098 	ldr.w	r1, [r7, #152]	; 0x98
   2842a:	f8d7 e01c 	ldr.w	lr, [r7, #28]
   2842e:	f8d7 c024 	ldr.w	ip, [r7, #36]	; 0x24
   28432:	f8d7 909c 	ldr.w	r9, [r7, #156]	; 0x9c
   28436:	f8c7 6104 	str.w	r6, [r7, #260]	; 0x104
   2843a:	4605      	mov	r5, r0
   2843c:	eb00 0b04 	add.w	fp, r0, r4
      from1 = cost1 + lambda;
   28440:	eb0c 0403 	add.w	r4, ip, r3
      if (from0 < from1)
   28444:	4294      	cmp	r4, r2
      from0 = cost0 + lambda;
   28446:	eb0c 0002 	add.w	r0, ip, r2
      if (from0 < from1)
   2844a:	bfca      	itet	gt
   2844c:	4614      	movgt	r4, r2
         path0[i]= 1;
   2844e:	f04f 0801 	movle.w	r8, #1
         path0[i]= 0;
   28452:	f04f 0800 	movgt.w	r8, #0
      if (from0 < from1)
   28456:	4298      	cmp	r0, r3
   28458:	bfa8      	it	ge
   2845a:	4618      	movge	r0, r3
      cost0 = curr0 + importance[i]*abs(metric[i]-2*tf_select_table[LM][4*isTransient+2*tf_select+0]);
   2845c:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
   28460:	f851 3f04 	ldr.w	r3, [r1, #4]!
   28464:	f84e 8f04 	str.w	r8, [lr, #4]!
   28468:	eba3 0202 	sub.w	r2, r3, r2
         path1[i]= 1;
   2846c:	f04f 0601 	mov.w	r6, #1
         path1[i]= 0;
   28470:	bfb8      	it	lt
   28472:	2600      	movlt	r6, #0
      cost1 = curr1 + importance[i]*abs(metric[i]-2*tf_select_table[LM][4*isTransient+2*tf_select+1]);
   28474:	eba3 030a 	sub.w	r3, r3, sl
      cost0 = curr0 + importance[i]*abs(metric[i]-2*tf_select_table[LM][4*isTransient+2*tf_select+0]);
   28478:	2a00      	cmp	r2, #0
   2847a:	f845 6f04 	str.w	r6, [r5, #4]!
   2847e:	bfb8      	it	lt
   28480:	4252      	neglt	r2, r2
   28482:	f859 6f04 	ldr.w	r6, [r9, #4]!
      cost1 = curr1 + importance[i]*abs(metric[i]-2*tf_select_table[LM][4*isTransient+2*tf_select+1]);
   28486:	2b00      	cmp	r3, #0
   28488:	bfb8      	it	lt
   2848a:	425b      	neglt	r3, r3
   for (i=1;i<len;i++)
   2848c:	45ab      	cmp	fp, r5
      cost0 = curr0 + importance[i]*abs(metric[i]-2*tf_select_table[LM][4*isTransient+2*tf_select+0]);
   2848e:	fb06 4202 	mla	r2, r6, r2, r4
      cost1 = curr1 + importance[i]*abs(metric[i]-2*tf_select_table[LM][4*isTransient+2*tf_select+1]);
   28492:	fb06 0303 	mla	r3, r6, r3, r0
   for (i=1;i<len;i++)
   28496:	d1d3      	bne.n	28440 <celt_encode_with_ec+0x2f78>
   28498:	f8d7 6104 	ldr.w	r6, [r7, #260]	; 0x104
   tf_res[len-1] = cost0 < cost1 ? 0 : 1;
   2849c:	6878      	ldr	r0, [r7, #4]
   2849e:	4293      	cmp	r3, r2
   284a0:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
   284a4:	bfcc      	ite	gt
   284a6:	2300      	movgt	r3, #0
   284a8:	2301      	movle	r3, #1
   284aa:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
   284ae:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
   284b2:	4413      	add	r3, r2
   for (i=len-2;i>=0;i--)
   284b4:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
   284b8:	2a01      	cmp	r2, #1
   284ba:	dd0a      	ble.n	284d2 <celt_encode_with_ec+0x300a>
   284bc:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
      if (tf_res[i+1] == 1)
   284c0:	f853 2904 	ldr.w	r2, [r3], #-4
   284c4:	2a01      	cmp	r2, #1
         tf_res[i] = path1[i+1];
   284c6:	bf0c      	ite	eq
   284c8:	5982      	ldreq	r2, [r0, r6]
         tf_res[i] = path0[i+1];
   284ca:	598a      	ldrne	r2, [r1, r6]
   284cc:	601a      	str	r2, [r3, #0]
   for (i=len-2;i>=0;i--)
   284ce:	3e04      	subs	r6, #4
   284d0:	d1f6      	bne.n	284c0 <celt_encode_with_ec+0x2ff8>
      for (i=effEnd;i<end;i++)
   284d2:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
   284d6:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
   284da:	f8d7 d014 	ldr.w	sp, [r7, #20]
   284de:	4293      	cmp	r3, r2
   284e0:	f77f ab95 	ble.w	27c0e <celt_encode_with_ec+0x2746>
   284e4:	461c      	mov	r4, r3
   284e6:	f8d7 50cc 	ldr.w	r5, [r7, #204]	; 0xcc
   284ea:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
   284ee:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
   284f2:	442b      	add	r3, r5
   284f4:	1e50      	subs	r0, r2, #1
   284f6:	3201      	adds	r2, #1
         tf_res[i] = tf_res[effEnd-1];
   284f8:	f855 1020 	ldr.w	r1, [r5, r0, lsl #2]
   284fc:	f843 1f04 	str.w	r1, [r3, #4]!
      for (i=effEnd;i<end;i++)
   28500:	4294      	cmp	r4, r2
   28502:	d1f8      	bne.n	284f6 <celt_encode_with_ec+0x302e>
   28504:	f8d7 1124 	ldr.w	r1, [r7, #292]	; 0x124
   28508:	f7fe b855 	b.w	265b6 <celt_encode_with_ec+0x10ee>
   for (sel=0;sel<2;sel++)
   2850c:	2301      	movs	r3, #1
   2850e:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
   28512:	e6f3      	b.n	282fc <celt_encode_with_ec+0x2e34>
   for (i=0;i<N;i++)
   28514:	f04f 0800 	mov.w	r8, #0
   28518:	e614      	b.n	28144 <celt_encode_with_ec+0x2c7c>
      if (start > 0 || st->lfe)
   2851a:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
   2851e:	f8d3 e040 	ldr.w	lr, [r3, #64]	; 0x40
   28522:	f1be 0f00 	cmp.w	lr, #0
   28526:	f47e aa62 	bne.w	269ee <celt_encode_with_ec+0x1526>
   if (equiv_rate < 64000) {
   2852a:	6fba      	ldr	r2, [r7, #120]	; 0x78
   2852c:	f5b2 4f7a 	cmp.w	r2, #64000	; 0xfa00
   28530:	f2c0 820b 	blt.w	2894a <celt_encode_with_ec+0x3482>
   } else if (equiv_rate < 80000) {
   28534:	4b3c      	ldr	r3, [pc, #240]	; (28628 <celt_encode_with_ec+0x3160>)
   28536:	429a      	cmp	r2, r3
   28538:	f300 838c 	bgt.w	28c54 <celt_encode_with_ec+0x378c>
      opus_int32 frac = (equiv_rate-64000) >> 10;
   2853c:	f5a2 487a 	sub.w	r8, r2, #64000	; 0xfa00
   28540:	ea4f 28a8 	mov.w	r8, r8, asr #10
      trim = QCONST16(4.f, 8) + QCONST16(1.f/16.f, 8)*frac;
   28544:	f108 0840 	add.w	r8, r8, #64	; 0x40
   28548:	ea4f 1808 	mov.w	r8, r8, lsl #4
   2854c:	fa1f f888 	uxth.w	r8, r8
   if (C==2)
   28550:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
   28554:	2b02      	cmp	r3, #2
   28556:	f000 8274 	beq.w	28a42 <celt_encode_with_ec+0x357a>
   opus_val32 diff=0;
   2855a:	6e3c      	ldr	r4, [r7, #96]	; 0x60
   2855c:	f8d7 5114 	ldr.w	r5, [r7, #276]	; 0x114
   28560:	f8d7 6100 	ldr.w	r6, [r7, #256]	; 0x100
   28564:	f8d7 0124 	ldr.w	r0, [r7, #292]	; 0x124
   28568:	f8d7 c0d8 	ldr.w	ip, [r7, #216]	; 0xd8
   2856c:	2100      	movs	r1, #0
      for (i=0;i<end-1;i++)
   2856e:	2c00      	cmp	r4, #0
   28570:	dd0d      	ble.n	2858e <celt_encode_with_ec+0x30c6>
         diff += bandLogE[i+c*m->nbEBands]*(opus_int32)(2+2*i-end);
   28572:	68b3      	ldr	r3, [r6, #8]
   28574:	fb03 f30e 	mul.w	r3, r3, lr
   28578:	eb0c 0243 	add.w	r2, ip, r3, lsl #1
   2857c:	f1c0 0302 	rsb	r3, r0, #2
   28580:	f932 9b02 	ldrsh.w	r9, [r2], #2
   28584:	fb03 1109 	mla	r1, r3, r9, r1
   28588:	3302      	adds	r3, #2
      for (i=0;i<end-1;i++)
   2858a:	4298      	cmp	r0, r3
   2858c:	d1f8      	bne.n	28580 <celt_encode_with_ec+0x30b8>
   } while (++c<C);
   2858e:	f10e 0e01 	add.w	lr, lr, #1
   28592:	4575      	cmp	r5, lr
   28594:	dceb      	bgt.n	2856e <celt_encode_with_ec+0x30a6>
   diff /= C*(end-1);
   28596:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
   2859a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   trim -= MAX32(-QCONST16(2.f, 8), MIN32(QCONST16(2.f, 8), SHR32(diff+QCONST16(1.f, DB_SHIFT),DB_SHIFT-8)/6 ));
   2859c:	4823      	ldr	r0, [pc, #140]	; (2862c <celt_encode_with_ec+0x3164>)
   diff /= C*(end-1);
   2859e:	fb03 f302 	mul.w	r3, r3, r2
   285a2:	fb91 f3f3 	sdiv	r3, r1, r3
   trim -= MAX32(-QCONST16(2.f, 8), MIN32(QCONST16(2.f, 8), SHR32(diff+QCONST16(1.f, DB_SHIFT),DB_SHIFT-8)/6 ));
   285a6:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   285aa:	109a      	asrs	r2, r3, #2
   285ac:	4282      	cmp	r2, r0
   285ae:	f2c0 8236 	blt.w	28a1e <celt_encode_with_ec+0x3556>
   285b2:	f640 4105 	movw	r1, #3077	; 0xc05
   285b6:	428a      	cmp	r2, r1
   285b8:	f300 834f 	bgt.w	28c5a <celt_encode_with_ec+0x3792>
   285bc:	491c      	ldr	r1, [pc, #112]	; (28630 <celt_encode_with_ec+0x3168>)
   285be:	fb81 1202 	smull	r1, r2, r1, r2
   285c2:	eba2 73e3 	sub.w	r3, r2, r3, asr #31
   285c6:	b29b      	uxth	r3, r3
   trim -= SHR16(surround_trim, DB_SHIFT-8);
   285c8:	6aba      	ldr	r2, [r7, #40]	; 0x28
   trim -= MAX32(-QCONST16(2.f, 8), MIN32(QCONST16(2.f, 8), SHR32(diff+QCONST16(1.f, DB_SHIFT),DB_SHIFT-8)/6 ));
   285ca:	eba8 0303 	sub.w	r3, r8, r3
   trim -= SHR16(surround_trim, DB_SHIFT-8);
   285ce:	eba3 02a2 	sub.w	r2, r3, r2, asr #2
   trim -= 2*SHR16(tf_estimate, 14-8);
   285d2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   285d4:	119b      	asrs	r3, r3, #6
   285d6:	eba2 0343 	sub.w	r3, r2, r3, lsl #1
   trim_index = PSHR32(trim, 8);
   285da:	b21b      	sxth	r3, r3
   285dc:	3380      	adds	r3, #128	; 0x80
   285de:	121b      	asrs	r3, r3, #8
   trim_index = IMAX(0, IMIN(10, trim_index));
   285e0:	2b0a      	cmp	r3, #10
   285e2:	bfa8      	it	ge
   285e4:	230a      	movge	r3, #10
   285e6:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   285ea:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
   285ee:	4619      	mov	r1, r3
   285f0:	f7fe ba06 	b.w	26a00 <celt_encode_with_ec+0x1538>
   tf_select = 0;
   285f4:	2300      	movs	r3, #0
   285f6:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
   285fa:	f8d7 10d0 	ldr.w	r1, [r7, #208]	; 0xd0
   285fe:	e6e3      	b.n	283c8 <celt_encode_with_ec+0x2f00>
   bias = MULT16_16_Q14(QCONST16(.04f,15), MAX16(-QCONST16(.25f,14), QCONST16(.5f,14)-tf_estimate));
   28600:	b212      	sxth	r2, r2
   28602:	eb02 0182 	add.w	r1, r2, r2, lsl #2
   28606:	eb02 01c1 	add.w	r1, r2, r1, lsl #3
   2860a:	ebc2 1241 	rsb	r2, r2, r1, lsl #5
   2860e:	1391      	asrs	r1, r2, #14
   28610:	e505      	b.n	2801e <celt_encode_with_ec+0x2b56>
   for (i=0;i<len;i++)
   28612:	2400      	movs	r4, #0
   28614:	f7fd b8e9 	b.w	257ea <celt_encode_with_ec+0x322>
   sample_max=MAX32(st->overlap_max, celt_maxabs16(pcm, C*(N-overlap)/st->upsample));
   28618:	2e00      	cmp	r6, #0
   2861a:	bfd8      	it	le
   2861c:	2600      	movle	r6, #0
   2861e:	f7fd b8c7 	b.w	257b0 <celt_encode_with_ec+0x2e8>
   28622:	bf00      	nop
   28624:	00037970 	.word	0x00037970
   28628:	0001387f 	.word	0x0001387f
   2862c:	fffff3fb 	.word	0xfffff3fb
   28630:	2aaaaaab 	.word	0x2aaaaaab
   for (i=start;i<end;i++)
   28634:	f8d7 90ec 	ldr.w	r9, [r7, #236]	; 0xec
   total_boost = 0;
   28638:	f04f 0b00 	mov.w	fp, #0
   2863c:	f7fe b9c8 	b.w	269d0 <celt_encode_with_ec+0x1508>
   28640:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
   28644:	461d      	mov	r5, r3
   28646:	eb02 0c43 	add.w	ip, r2, r3, lsl #1
   2864a:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
   2864e:	195e      	adds	r6, r3, r5
      opus_val16 follow=-QCONST16(10.0f,DB_SHIFT);
   28650:	4bdd      	ldr	r3, [pc, #884]	; (289c8 <celt_encode_with_ec+0x3500>)
   28652:	f1ac 0c02 	sub.w	ip, ip, #2
   28656:	eb02 0646 	add.w	r6, r2, r6, lsl #1
      opus_val32 frame_avg=0;
   2865a:	2000      	movs	r0, #0
         follow = MAX16(follow-QCONST16(1.f, DB_SHIFT), bandLogE[i]-offset);
   2865c:	f93c 2f02 	ldrsh.w	r2, [ip, #2]!
            follow = MAX16(follow, bandLogE[i+nbEBands]-offset);
   28660:	f936 8b02 	ldrsh.w	r8, [r6], #2
         follow = MAX16(follow-QCONST16(1.f, DB_SHIFT), bandLogE[i]-offset);
   28664:	f5a3 6980 	sub.w	r9, r3, #1024	; 0x400
   28668:	1b13      	subs	r3, r2, r4
   2866a:	454b      	cmp	r3, r9
   2866c:	bfb8      	it	lt
   2866e:	464b      	movlt	r3, r9
            follow = MAX16(follow, bandLogE[i+nbEBands]-offset);
   28670:	b21b      	sxth	r3, r3
   28672:	eba8 0204 	sub.w	r2, r8, r4
   28676:	4293      	cmp	r3, r2
   28678:	bfb8      	it	lt
   2867a:	4613      	movlt	r3, r2
      for(i=start;i<end;i++)
   2867c:	3501      	adds	r5, #1
            follow = MAX16(follow, bandLogE[i+nbEBands]-offset);
   2867e:	b21b      	sxth	r3, r3
      for(i=start;i<end;i++)
   28680:	42a9      	cmp	r1, r5
         frame_avg += follow;
   28682:	4418      	add	r0, r3
      for(i=start;i<end;i++)
   28684:	d1ea      	bne.n	2865c <celt_encode_with_ec+0x3194>
   28686:	f7fd be53 	b.w	26330 <celt_encode_with_ec+0xe68>
      for (i=0;i<C*nbEBands;i++)
   2868a:	f8c7 1090 	str.w	r1, [r7, #144]	; 0x90
   2868e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
   28690:	f7fe bc11 	b.w	26eb6 <celt_encode_with_ec+0x19ee>
        nbAvailableBytes += silence?0:adjust;
   28694:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
   28698:	b912      	cbnz	r2, 286a0 <celt_encode_with_ec+0x31d8>
        int adjust = (-st->vbr_reservoir)/(8<<BITRES);
   2869a:	425b      	negs	r3, r3
   2869c:	eb06 16a3 	add.w	r6, r6, r3, asr #6
        st->vbr_reservoir = 0;
   286a0:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
   286a4:	2300      	movs	r3, #0
   286a6:	f8c2 30d0 	str.w	r3, [r2, #208]	; 0xd0
   286aa:	f7fe ba9a 	b.w	26be2 <celt_encode_with_ec+0x171a>
        target = compute_vbr(mode, &st->analysis, base_target, LM, equiv_rate,
   286ae:	f8d7 112c 	ldr.w	r1, [r7, #300]	; 0x12c
   286b2:	f8d1 40e8 	ldr.w	r4, [r1, #232]	; 0xe8
      coded_bins += eBands[IMIN(intensity, coded_bands)]<<LM;
   286b6:	4294      	cmp	r4, r2
   286b8:	f280 80cd 	bge.w	28856 <celt_encode_with_ec+0x338e>
   286bc:	4601      	mov	r1, r0
   286be:	f93c 0014 	ldrsh.w	r0, [ip, r4, lsl #1]
   286c2:	4088      	lsls	r0, r1
   286c4:	f8d7 112c 	ldr.w	r1, [r7, #300]	; 0x12c
      stereo_saving = MIN16(stereo_saving, QCONST16(1.f, 8));
   286c8:	f9b1 10e4 	ldrsh.w	r1, [r1, #228]	; 0xe4
   286cc:	f8c7 10e8 	str.w	r1, [r7, #232]	; 0xe8
      coded_stereo_bands = IMIN(intensity, coded_bands);
   286d0:	42a2      	cmp	r2, r4
   286d2:	bfa8      	it	ge
   286d4:	4622      	movge	r2, r4
      coded_stereo_dof = (eBands[coded_stereo_bands]<<LM)-coded_stereo_bands;
   286d6:	f8d7 110c 	ldr.w	r1, [r7, #268]	; 0x10c
   286da:	f93c 4012 	ldrsh.w	r4, [ip, r2, lsl #1]
   286de:	408c      	lsls	r4, r1
      coded_bins += eBands[IMIN(intensity, coded_bands)]<<LM;
   286e0:	f8d7 10ec 	ldr.w	r1, [r7, #236]	; 0xec
      coded_stereo_dof = (eBands[coded_stereo_bands]<<LM)-coded_stereo_bands;
   286e4:	1aa4      	subs	r4, r4, r2
      coded_bins += eBands[IMIN(intensity, coded_bands)]<<LM;
   286e6:	4401      	add	r1, r0
      max_frac = DIV32_16(MULT16_16(QCONST16(0.8f, 15), coded_stereo_dof), coded_bins);
   286e8:	f246 6066 	movw	r0, #26214	; 0x6666
   286ec:	fb14 f000 	smulbb	r0, r4, r0
   286f0:	b20a      	sxth	r2, r1
      coded_bins += eBands[IMIN(intensity, coded_bands)]<<LM;
   286f2:	f8c7 10ec 	str.w	r1, [r7, #236]	; 0xec
      max_frac = DIV32_16(MULT16_16(QCONST16(0.8f, 15), coded_stereo_dof), coded_bins);
   286f6:	fb90 f2f2 	sdiv	r2, r0, r2
      stereo_saving = MIN16(stereo_saving, QCONST16(1.f, 8));
   286fa:	f8d7 10e8 	ldr.w	r1, [r7, #232]	; 0xe8
      max_frac = DIV32_16(MULT16_16(QCONST16(0.8f, 15), coded_stereo_dof), coded_bins);
   286fe:	f8c7 20e8 	str.w	r2, [r7, #232]	; 0xe8
      target -= (opus_int32)MIN32(MULT16_32_Q15(max_frac,target),
   28702:	f9b7 00e8 	ldrsh.w	r0, [r7, #232]	; 0xe8
   28706:	b2b2      	uxth	r2, r6
      stereo_saving = MIN16(stereo_saving, QCONST16(1.f, 8));
   28708:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
      target -= (opus_int32)MIN32(MULT16_32_Q15(max_frac,target),
   2870c:	fb00 f002 	mul.w	r0, r0, r2
      stereo_saving = MIN16(stereo_saving, QCONST16(1.f, 8));
   28710:	bfa8      	it	ge
   28712:	f44f 7180 	movge.w	r1, #256	; 0x100
      target -= (opus_int32)MIN32(MULT16_32_Q15(max_frac,target),
   28716:	4602      	mov	r2, r0
   28718:	f8d7 00e8 	ldr.w	r0, [r7, #232]	; 0xe8
   2871c:	00e4      	lsls	r4, r4, #3
   2871e:	391a      	subs	r1, #26
   28720:	13d2      	asrs	r2, r2, #15
   28722:	fb11 f104 	smulbb	r1, r1, r4
   28726:	fb16 f020 	smultb	r0, r6, r0
   2872a:	eb02 0040 	add.w	r0, r2, r0, lsl #1
   2872e:	1209      	asrs	r1, r1, #8
   28730:	4288      	cmp	r0, r1
   28732:	bfd4      	ite	le
   28734:	1a32      	suble	r2, r6, r0
   28736:	1a72      	subgt	r2, r6, r1
   28738:	f8d7 010c 	ldr.w	r0, [r7, #268]	; 0x10c
   2873c:	f7fe b9b1 	b.w	26aa2 <celt_encode_with_ec+0x15da>
   if (tf_select_rsv &&
   28740:	4284      	cmp	r4, r0
   28742:	f4fe a864 	bcc.w	2680e <celt_encode_with_ec+0x1346>
   curr = tf_changed = 0;
   28746:	2600      	movs	r6, #0
   28748:	f7fe b81c 	b.w	26784 <celt_encode_with_ec+0x12bc>
            mask = MAX16(MIN16(st->energy_mask[nbEBands*c+i],
   2874c:	2500      	movs	r5, #0
   2874e:	f7ff ba7d 	b.w	27c4c <celt_encode_with_ec+0x2784>
         mask_avg += QCONST16(.25f, DB_SHIFT);
   28752:	f20a 1acd 	addw	sl, sl, #461	; 0x1cd
         if (mask_avg>0)
   28756:	f1ba 0f00 	cmp.w	sl, #0
   2875a:	f300 8097 	bgt.w	2888c <celt_encode_with_ec+0x33c4>
   2875e:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
   28762:	f1a8 0202 	sub.w	r2, r8, #2
   28766:	441a      	add	r2, r3
               surround_dynalloc[i] = MAX16(0, surround_dynalloc[i]-QCONST16(.25f, DB_SHIFT));
   28768:	2400      	movs	r4, #0
   2876a:	3b02      	subs	r3, #2
   2876c:	f933 1f02 	ldrsh.w	r1, [r3, #2]!
   28770:	29ff      	cmp	r1, #255	; 0xff
   28772:	f5a1 7080 	sub.w	r0, r1, #256	; 0x100
   28776:	f340 8129 	ble.w	289cc <celt_encode_with_ec+0x3504>
            for(i=0;i<mask_end;i++)
   2877a:	429a      	cmp	r2, r3
               surround_dynalloc[i] = MAX16(0, surround_dynalloc[i]-QCONST16(.25f, DB_SHIFT));
   2877c:	8018      	strh	r0, [r3, #0]
            for(i=0;i<mask_end;i++)
   2877e:	d1f5      	bne.n	2876c <celt_encode_with_ec+0x32a4>
   28780:	ea4f 1e8e 	mov.w	lr, lr, lsl #6
   28784:	fa0f f38e 	sxth.w	r3, lr
   28788:	f209 219a 	addw	r1, r9, #666	; 0x29a
   2878c:	62bb      	str	r3, [r7, #40]	; 0x28
   2878e:	b20b      	sxth	r3, r1
   28790:	62fb      	str	r3, [r7, #44]	; 0x2c
   28792:	f7fd bd9e 	b.w	262d2 <celt_encode_with_ec+0xe0a>
      for(i=start;i<end;i++)
   28796:	2300      	movs	r3, #0
   28798:	f7fd bdcd 	b.w	26336 <celt_encode_with_ec+0xe6e>
            && st->complexity >= 5;
   2879c:	f8d7 4090 	ldr.w	r4, [r7, #144]	; 0x90
   287a0:	4611      	mov	r1, r2
   287a2:	f7fd b87a 	b.w	2589a <celt_encode_with_ec+0x3d2>
      if (mode->shortMdctSize<<LM==frame_size)
   287a6:	2201      	movs	r2, #1
   287a8:	677a      	str	r2, [r7, #116]	; 0x74
   287aa:	2203      	movs	r2, #3
   for (LM=0;LM<=mode->maxLM;LM++)
   287ac:	f8c7 510c 	str.w	r5, [r7, #268]	; 0x10c
      if (mode->shortMdctSize<<LM==frame_size)
   287b0:	f8c7 40f0 	str.w	r4, [r7, #240]	; 0xf0
   287b4:	f44f 75af 	mov.w	r5, #350	; 0x15e
   287b8:	66ba      	str	r2, [r7, #104]	; 0x68
   287ba:	f7fc bee0 	b.w	2557e <celt_encode_with_ec+0xb6>
   ALLOC(error, C*nbEBands, opus_val16);
   287be:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   287c2:	f023 0307 	bic.w	r3, r3, #7
   287c6:	ebad 0d03 	sub.w	sp, sp, r3
   287ca:	ab14      	add	r3, sp, #80	; 0x50
   287cc:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
      tf_select=0;
   287d0:	2300      	movs	r3, #0
   287d2:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
   287d6:	f7fd bf37 	b.w	26648 <celt_encode_with_ec+0x1180>
      for (i=0;i<C*nbEBands;i++)
   287da:	f8d7 b118 	ldr.w	fp, [r7, #280]	; 0x118
   287de:	f7ff bb48 	b.w	27e72 <celt_encode_with_ec+0x29aa>
   287e2:	4693      	mov	fp, r2
   287e4:	f7ff bb45 	b.w	27e72 <celt_encode_with_ec+0x29aa>
   287e8:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
   287ec:	f8d7 c0b4 	ldr.w	ip, [r7, #180]	; 0xb4
   287f0:	f102 4000 	add.w	r0, r2, #2147483648	; 0x80000000
   287f4:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
   287f8:	fb03 431e 	mls	r3, r3, lr, r4
   287fc:	3801      	subs	r0, #1
   287fe:	1e91      	subs	r1, r2, #2
   28800:	f8d7 4098 	ldr.w	r4, [r7, #152]	; 0x98
   28804:	b29b      	uxth	r3, r3
   28806:	eb02 0040 	add.w	r0, r2, r0, lsl #1
   2880a:	eb01 0608 	add.w	r6, r1, r8
   2880e:	fa1f f58e 	uxth.w	r5, lr
            unmask = MAX16(st->energy_mask[i], st->energy_mask[nbEBands+i]);
   28812:	f930 2f02 	ldrsh.w	r2, [r0, #2]!
   28816:	f931 bf02 	ldrsh.w	fp, [r1, #2]!
   2881a:	455a      	cmp	r2, fp
   2881c:	bfb8      	it	lt
   2881e:	465a      	movlt	r2, fp
         unmask -= lin;
   28820:	2a00      	cmp	r2, #0
   28822:	bfd4      	ite	le
   28824:	ebc3 0202 	rsble	r2, r3, r2
   28828:	425a      	neggt	r2, r3
   2882a:	b292      	uxth	r2, r2
         if (unmask > QCONST16(.25f, DB_SHIFT))
   2882c:	fa0f fb82 	sxth.w	fp, r2
   28830:	442b      	add	r3, r5
   28832:	f5bb 7f80 	cmp.w	fp, #256	; 0x100
   28836:	b29b      	uxth	r3, r3
   28838:	dd04      	ble.n	28844 <celt_encode_with_ec+0x337c>
            surround_dynalloc[i] = unmask - QCONST16(.25f, DB_SHIFT);
   2883a:	f5a2 7280 	sub.w	r2, r2, #256	; 0x100
   2883e:	8022      	strh	r2, [r4, #0]
            count_dynalloc++;
   28840:	f10c 0c01 	add.w	ip, ip, #1
      for(i=0;i<mask_end;i++)
   28844:	428e      	cmp	r6, r1
   28846:	f104 0402 	add.w	r4, r4, #2
   2884a:	d1e2      	bne.n	28812 <celt_encode_with_ec+0x334a>
   2884c:	f8c7 c0b4 	str.w	ip, [r7, #180]	; 0xb4
   28850:	4663      	mov	r3, ip
   28852:	f7ff ba9b 	b.w	27d8c <celt_encode_with_ec+0x28c4>
      coded_bins += eBands[IMIN(intensity, coded_bands)]<<LM;
   28856:	f8d7 00ec 	ldr.w	r0, [r7, #236]	; 0xec
   2885a:	e735      	b.n	286c8 <celt_encode_with_ec+0x3200>
   2885c:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
   28860:	69d9      	ldr	r1, [r3, #28]
   28862:	f7ff bb6e 	b.w	27f42 <celt_encode_with_ec+0x2a7a>
   *weak_transient = 0;
   28866:	2300      	movs	r3, #0
   28868:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
   if (allow_weak_transients && is_transient && mask_metric<600) {
   2886c:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
   28870:	f7fd bb08 	b.w	25e84 <celt_encode_with_ec+0x9bc>
   for (c=0;c<C;c++)
   28874:	2300      	movs	r3, #0
   28876:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
   *weak_transient = 0;
   2887a:	461c      	mov	r4, r3
   is_transient = mask_metric>200;
   2887c:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
   int tf_chan = 0;
   28880:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
   28884:	f7fd bafe 	b.w	25e84 <celt_encode_with_ec+0x9bc>
   for (i=0;i<N;i++)
   28888:	2000      	movs	r0, #0
   2888a:	e4d4      	b.n	28236 <celt_encode_with_ec+0x2d6e>
            OPUS_CLEAR(surround_dynalloc, mask_end);
   2888c:	4642      	mov	r2, r8
   2888e:	2100      	movs	r1, #0
   28890:	f8d7 0098 	ldr.w	r0, [r7, #152]	; 0x98
   28894:	f00c fc66 	bl	35164 <memset>
   28898:	24cd      	movs	r4, #205	; 0xcd
   2889a:	2300      	movs	r3, #0
   2889c:	e9c7 340a 	strd	r3, r4, [r7, #40]	; 0x28
   288a0:	f7fd bd17 	b.w	262d2 <celt_encode_with_ec+0xe0a>
   *weak_transient = 0;
   288a4:	2300      	movs	r3, #0
   is_transient = mask_metric>200;
   288a6:	f8c7 2118 	str.w	r2, [r7, #280]	; 0x118
   *weak_transient = 0;
   288aa:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
   288ae:	f7fd bae9 	b.w	25e84 <celt_encode_with_ec+0x9bc>
         effectiveBytes=nbCompressedBytes=IMIN(nbCompressedBytes, nbFilledBytes+2);
   288b2:	f10a 0302 	add.w	r3, sl, #2
   288b6:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
   288ba:	00db      	lsls	r3, r3, #3
   288bc:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
   288c0:	f7ff b89b 	b.w	279fa <celt_encode_with_ec+0x2532>
            st->spread_decision = SPREAD_AGGRESSIVE;
   288c4:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
   288c8:	2103      	movs	r1, #3
   288ca:	6519      	str	r1, [r3, #80]	; 0x50
   288cc:	f7fd bfae 	b.w	2682c <celt_encode_with_ec+0x1364>
      } else if (shortBlocks || st->complexity < 3 || nbAvailableBytes < 10*C)
   288d0:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
   288d4:	6a3b      	ldr	r3, [r7, #32]
   288d6:	4413      	add	r3, r2
   288d8:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
   288dc:	ebb2 0f43 	cmp.w	r2, r3, lsl #1
   288e0:	f6ff a86c 	blt.w	279bc <celt_encode_with_ec+0x24f4>
            st->spread_decision = spreading_decision(mode, X,
   288e4:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
   288e8:	6c39      	ldr	r1, [r7, #64]	; 0x40
   288ea:	6d13      	ldr	r3, [r2, #80]	; 0x50
   288ec:	9106      	str	r1, [sp, #24]
   288ee:	6f7c      	ldr	r4, [r7, #116]	; 0x74
   288f0:	9405      	str	r4, [sp, #20]
   288f2:	f8d7 4114 	ldr.w	r4, [r7, #276]	; 0x114
   288f6:	9404      	str	r4, [sp, #16]
   288f8:	f8d7 40e4 	ldr.w	r4, [r7, #228]	; 0xe4
   288fc:	9403      	str	r4, [sp, #12]
   288fe:	6d7c      	ldr	r4, [r7, #84]	; 0x54
   28900:	f102 0164 	add.w	r1, r2, #100	; 0x64
   28904:	e9cd 1401 	strd	r1, r4, [sp, #4]
   28908:	4610      	mov	r0, r2
   2890a:	3260      	adds	r2, #96	; 0x60
   2890c:	9200      	str	r2, [sp, #0]
   2890e:	4604      	mov	r4, r0
   28910:	f100 0258 	add.w	r2, r0, #88	; 0x58
   28914:	f8d7 10b4 	ldr.w	r1, [r7, #180]	; 0xb4
   28918:	f8d7 0100 	ldr.w	r0, [r7, #256]	; 0x100
   2891c:	f7f9 fccc 	bl	222b8 <spreading_decision>
   28920:	4601      	mov	r1, r0
   28922:	6521      	str	r1, [r4, #80]	; 0x50
   28924:	f7fd bf82 	b.w	2682c <celt_encode_with_ec+0x1364>
      amount = MULT16_16_Q15(QCONST16(.0000031f, 30), IMAX(0, IMIN(32000, 96000-bitrate)));
   28928:	6fba      	ldr	r2, [r7, #120]	; 0x78
   2892a:	f5c2 42ee 	rsb	r2, r2, #30464	; 0x7700
   2892e:	b212      	sxth	r2, r2
   28930:	eb02 0042 	add.w	r0, r2, r2, lsl #1
   28934:	eb02 0080 	add.w	r0, r2, r0, lsl #2
   28938:	eb02 2200 	add.w	r2, r2, r0, lsl #8
   2893c:	6b78      	ldr	r0, [r7, #52]	; 0x34
   2893e:	13d2      	asrs	r2, r2, #15
   28940:	fb00 f002 	mul.w	r0, r0, r2
   28944:	4602      	mov	r2, r0
   28946:	f7ff b8b0 	b.w	27aaa <celt_encode_with_ec+0x25e2>
   if (equiv_rate < 64000) {
   2894a:	f44f 6880 	mov.w	r8, #1024	; 0x400
   2894e:	e5ff      	b.n	28550 <celt_encode_with_ec+0x3088>
   28950:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
   28954:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   28958:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
   2895c:	f507 73b4 	add.w	r3, r7, #360	; 0x168
   28960:	189d      	adds	r5, r3, r2
   28962:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
   c=0; do {
   28966:	2600      	movs	r6, #0
   opus_val32 mean_diff=0;
   28968:	4630      	mov	r0, r6
   2896a:	f103 0e02 	add.w	lr, r3, #2
      for (i=IMAX(2,start);i<end-1;i++)
   2896e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   28970:	2b02      	cmp	r3, #2
   28972:	dd12      	ble.n	2899a <celt_encode_with_ec+0x34d2>
   28974:	f507 71b7 	add.w	r1, r7, #366	; 0x16e
   28978:	4674      	mov	r4, lr
         x2 = MAX16(0, spread_old[i]);
   2897a:	f931 3f02 	ldrsh.w	r3, [r1, #2]!
         x1 = MAX16(0, newE[i + c*nbEBands]);
   2897e:	f934 2f02 	ldrsh.w	r2, [r4, #2]!
         mean_diff = ADD32(mean_diff, EXTEND32(MAX16(0, SUB16(x1, x2))));
   28982:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   28986:	2a00      	cmp	r2, #0
   28988:	bfac      	ite	ge
   2898a:	ebc3 0302 	rsbge	r3, r3, r2
   2898e:	425b      	neglt	r3, r3
   28990:	2b00      	cmp	r3, #0
   28992:	bfa8      	it	ge
   28994:	18c0      	addge	r0, r0, r3
      for (i=IMAX(2,start);i<end-1;i++)
   28996:	428d      	cmp	r5, r1
   28998:	d1ef      	bne.n	2897a <celt_encode_with_ec+0x34b2>
   } while (++c<C);
   2899a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
   2899e:	3601      	adds	r6, #1
   289a0:	42b3      	cmp	r3, r6
   289a2:	44e6      	add	lr, ip
   289a4:	dce3      	bgt.n	2896e <celt_encode_with_ec+0x34a6>
   289a6:	461a      	mov	r2, r3
   mean_diff = DIV32(mean_diff, C*(end-1-IMAX(2,start)));
   289a8:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
   289ac:	3b03      	subs	r3, #3
   289ae:	fb02 f303 	mul.w	r3, r2, r3
   289b2:	fb90 f0f3 	sdiv	r0, r0, r3
      if (patch_transient_decision(bandLogE, oldBandE, nbEBands, start, end, C))
   289b6:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
   289ba:	f300 8177 	bgt.w	28cac <celt_encode_with_ec+0x37e4>
   289be:	2300      	movs	r3, #0
   289c0:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
   289c4:	f7fd bcf3 	b.w	263ae <celt_encode_with_ec+0xee6>
   289c8:	ffffd800 	.word	0xffffd800
            for(i=0;i<mask_end;i++)
   289cc:	429a      	cmp	r2, r3
               surround_dynalloc[i] = MAX16(0, surround_dynalloc[i]-QCONST16(.25f, DB_SHIFT));
   289ce:	801c      	strh	r4, [r3, #0]
            for(i=0;i<mask_end;i++)
   289d0:	f47f aecc 	bne.w	2876c <celt_encode_with_ec+0x32a4>
   289d4:	e6d4      	b.n	28780 <celt_encode_with_ec+0x32b8>
   for (i=end-2;i>=start;i--)
   289d6:	f507 73b6 	add.w	r3, r7, #364	; 0x16c
   289da:	4283      	cmp	r3, r0
   289dc:	d0bc      	beq.n	28958 <celt_encode_with_ec+0x3490>
   opus_val16 temporal_vbr=0;
   289de:	4613      	mov	r3, r2
   289e0:	f7ff b8e8 	b.w	27bb4 <celt_encode_with_ec+0x26ec>
      for (i=0;i<C*nbEBands;i++)
   289e4:	f04f 0b02 	mov.w	fp, #2
   289e8:	f7ff ba43 	b.w	27e72 <celt_encode_with_ec+0x29aa>
   289ec:	6f3b      	ldr	r3, [r7, #112]	; 0x70
   289ee:	005c      	lsls	r4, r3, #1
      for (i=0;i<C*nbEBands;i++)
   289f0:	2300      	movs	r3, #0
   289f2:	f7fe ba7b 	b.w	26eec <celt_encode_with_ec+0x1a24>
      for (i=0;i<C*nbEBands;i++)
   289f6:	f04f 0b00 	mov.w	fp, #0
   289fa:	f7ff ba69 	b.w	27ed0 <celt_encode_with_ec+0x2a08>
      for (c=0;c<C;c++)
   289fe:	f8d7 1120 	ldr.w	r1, [r7, #288]	; 0x120
   28a02:	4615      	mov	r5, r2
   28a04:	468e      	mov	lr, r1
   28a06:	468c      	mov	ip, r1
   28a08:	f7ff b977 	b.w	27cfa <celt_encode_with_ec+0x2832>
      for (midband=0;eBands[midband+1] < eBands[mask_end]/2;midband++);
   28a0c:	2300      	movs	r3, #0
   28a0e:	f7ff b990 	b.w	27d32 <celt_encode_with_ec+0x286a>
      tf_select=0;
   28a12:	2300      	movs	r3, #0
   28a14:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
   28a18:	4601      	mov	r1, r0
   28a1a:	f7fd bdcc 	b.w	265b6 <celt_encode_with_ec+0x10ee>
   trim -= MAX32(-QCONST16(2.f, 8), MIN32(QCONST16(2.f, 8), SHR32(diff+QCONST16(1.f, DB_SHIFT),DB_SHIFT-8)/6 ));
   28a1e:	f44f 437e 	mov.w	r3, #65024	; 0xfe00
   28a22:	e5d1      	b.n	285c8 <celt_encode_with_ec+0x3100>
      target = base_target + (opus_int32)MULT16_32_Q15(QCONST16(0.67f, 15), target-base_target);
   28a24:	1b89      	subs	r1, r1, r6
   28a26:	b28a      	uxth	r2, r1
   28a28:	f245 50c3 	movw	r0, #21955	; 0x55c3
   28a2c:	1409      	asrs	r1, r1, #16
   28a2e:	fb00 f202 	mul.w	r2, r0, r2
   28a32:	13d2      	asrs	r2, r2, #15
   28a34:	fb00 f101 	mul.w	r1, r0, r1
   28a38:	eb02 0141 	add.w	r1, r2, r1, lsl #1
   28a3c:	4431      	add	r1, r6
   28a3e:	f7fe b879 	b.w	26b34 <celt_encode_with_ec+0x166c>
         partial = celt_inner_prod(&X[m->eBands[i]<<LM], &X[N0+(m->eBands[i]<<LM)],
   28a42:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
   28a46:	f8d7 90b4 	ldr.w	r9, [r7, #180]	; 0xb4
   28a4a:	699b      	ldr	r3, [r3, #24]
   28a4c:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
      opus_val16 sum = 0; /* Q10 */
   28a50:	2200      	movs	r2, #0
   28a52:	f103 0a10 	add.w	sl, r3, #16
         partial = celt_inner_prod(&X[m->eBands[i]<<LM], &X[N0+(m->eBands[i]<<LM)],
   28a56:	469c      	mov	ip, r3
   28a58:	f9bc 3000 	ldrsh.w	r3, [ip]
   28a5c:	f8d7 410c 	ldr.w	r4, [r7, #268]	; 0x10c
   28a60:	f93c 0f02 	ldrsh.w	r0, [ip, #2]!
   28a64:	fa03 f104 	lsl.w	r1, r3, r4
   28a68:	1ac0      	subs	r0, r0, r3
   28a6a:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
   28a6e:	40a0      	lsls	r0, r4
   28a70:	18cb      	adds	r3, r1, r3
   28a72:	2800      	cmp	r0, #0
   28a74:	ea4f 0343 	mov.w	r3, r3, lsl #1
   28a78:	ea4f 0141 	mov.w	r1, r1, lsl #1
   28a7c:	b296      	uxth	r6, r2
   28a7e:	dd10      	ble.n	28aa2 <celt_encode_with_ec+0x35da>
   28a80:	1e8a      	subs	r2, r1, #2
   28a82:	444b      	add	r3, r9
   28a84:	444a      	add	r2, r9
   28a86:	eb03 0040 	add.w	r0, r3, r0, lsl #1
   opus_val32 xy=0;
   28a8a:	2100      	movs	r1, #0
      xy = MAC16_16(xy, x[i], y[i]);
   28a8c:	f933 4b02 	ldrsh.w	r4, [r3], #2
   28a90:	f832 5f02 	ldrh.w	r5, [r2, #2]!
   for (i=0;i<N;i++)
   28a94:	4298      	cmp	r0, r3
      xy = MAC16_16(xy, x[i], y[i]);
   28a96:	fb15 1104 	smlabb	r1, r5, r4, r1
   for (i=0;i<N;i++)
   28a9a:	d1f7      	bne.n	28a8c <celt_encode_with_ec+0x35c4>
   28a9c:	eb06 42a1 	add.w	r2, r6, r1, asr #18
   28aa0:	b212      	sxth	r2, r2
      for (i=0;i<8;i++)
   28aa2:	45e2      	cmp	sl, ip
   28aa4:	d1d8      	bne.n	28a58 <celt_encode_with_ec+0x3590>
      sum = MIN16(QCONST16(1.f, 10), ABS16(sum));
   28aa6:	10d2      	asrs	r2, r2, #3
         alloc_trim = alloc_trim_analysis(mode, X, bandLogE,
   28aa8:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
      sum = MIN16(QCONST16(1.f, 10), ABS16(sum));
   28aac:	ea82 76e2 	eor.w	r6, r2, r2, asr #31
   28ab0:	eba6 76e2 	sub.w	r6, r6, r2, asr #31
         alloc_trim = alloc_trim_analysis(mode, X, bandLogE,
   28ab4:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
      sum = MIN16(QCONST16(1.f, 10), ABS16(sum));
   28ab8:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
   28abc:	bfa8      	it	ge
   28abe:	f44f 6680 	movge.w	r6, #1024	; 0x400
      for (i=8;i<intensity;i++)
   28ac2:	2b08      	cmp	r3, #8
      sum = MIN16(QCONST16(1.f, 10), ABS16(sum));
   28ac4:	fa0f f986 	sxth.w	r9, r6
      for (i=8;i<intensity;i++)
   28ac8:	dd33      	ble.n	28b32 <celt_encode_with_ec+0x366a>
   28aca:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
   28ace:	46d4      	mov	ip, sl
   28ad0:	eb02 0a43 	add.w	sl, r2, r3, lsl #1
         partial = celt_inner_prod(&X[m->eBands[i]<<LM], &X[N0+(m->eBands[i]<<LM)],
   28ad4:	f9bc 3000 	ldrsh.w	r3, [ip]
   28ad8:	f8d7 110c 	ldr.w	r1, [r7, #268]	; 0x10c
   28adc:	f93c 5f02 	ldrsh.w	r5, [ip, #2]!
   28ae0:	fa03 f201 	lsl.w	r2, r3, r1
   28ae4:	1aed      	subs	r5, r5, r3
   28ae6:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
   28aea:	408d      	lsls	r5, r1
   28aec:	18d3      	adds	r3, r2, r3
   28aee:	2d00      	cmp	r5, #0
   28af0:	ea4f 0343 	mov.w	r3, r3, lsl #1
   28af4:	ea4f 0142 	mov.w	r1, r2, lsl #1
   28af8:	f340 80aa 	ble.w	28c50 <celt_encode_with_ec+0x3788>
   28afc:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
   28b00:	3902      	subs	r1, #2
   28b02:	4413      	add	r3, r2
   28b04:	4411      	add	r1, r2
   28b06:	eb03 0545 	add.w	r5, r3, r5, lsl #1
   opus_val32 xy=0;
   28b0a:	2200      	movs	r2, #0
      xy = MAC16_16(xy, x[i], y[i]);
   28b0c:	f933 0b02 	ldrsh.w	r0, [r3], #2
   28b10:	f831 4f02 	ldrh.w	r4, [r1, #2]!
   for (i=0;i<N;i++)
   28b14:	429d      	cmp	r5, r3
      xy = MAC16_16(xy, x[i], y[i]);
   28b16:	fb14 2200 	smlabb	r2, r4, r0, r2
   for (i=0;i<N;i++)
   28b1a:	d1f7      	bne.n	28b0c <celt_encode_with_ec+0x3644>
   28b1c:	1493      	asrs	r3, r2, #18
   28b1e:	2b00      	cmp	r3, #0
   28b20:	bfb8      	it	lt
   28b22:	425b      	neglt	r3, r3
         minXC = MIN16(minXC, ABS16(EXTRACT16(SHR32(partial, 18))));
   28b24:	4599      	cmp	r9, r3
   28b26:	bfa8      	it	ge
   28b28:	4699      	movge	r9, r3
      for (i=8;i<intensity;i++)
   28b2a:	45e2      	cmp	sl, ip
         minXC = MIN16(minXC, ABS16(EXTRACT16(SHR32(partial, 18))));
   28b2c:	fa0f f989 	sxth.w	r9, r9
      for (i=8;i<intensity;i++)
   28b30:	d1d0      	bne.n	28ad4 <celt_encode_with_ec+0x360c>
      logXC = celt_log2(QCONST32(1.001f, 20)-MULT16_16(sum, sum));
   28b32:	4bdc      	ldr	r3, [pc, #880]	; (28ea4 <celt_encode_with_ec+0x39dc>)
   28b34:	fb06 3616 	mls	r6, r6, r6, r3
   return EC_ILOG(x)-1;
   28b38:	fab6 f086 	clz	r0, r6
   28b3c:	f1c0 031f 	rsb	r3, r0, #31
   28b40:	b29b      	uxth	r3, r3
   n = VSHR32(x,i-15)-32768-16384;
   28b42:	2b0f      	cmp	r3, #15
   28b44:	bf8b      	itete	hi
   28b46:	3b0f      	subhi	r3, #15
   28b48:	f1c3 030f 	rsbls	r3, r3, #15
   28b4c:	fa46 f303 	asrhi.w	r3, r6, r3
   28b50:	fa06 f303 	lslls.w	r3, r6, r3
   28b54:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
   28b58:	b21b      	sxth	r3, r3
   frac = ADD16(C[0], MULT16_16_Q15(n, ADD16(C[1], MULT16_16_Q15(n, ADD16(C[2], MULT16_16_Q15(n, ADD16(C[3], MULT16_16_Q15(n, C[4]))))))));
   28b5a:	f64f 2287 	movw	r2, #64135	; 0xfa87
   28b5e:	fb13 f202 	smulbb	r2, r3, r2
   28b62:	13d2      	asrs	r2, r2, #15
   28b64:	f602 12f1 	addw	r2, r2, #2545	; 0x9f1
   28b68:	b292      	uxth	r2, r2
   28b6a:	fb03 f202 	mul.w	r2, r3, r2
   28b6e:	f64e 319f 	movw	r1, #60319	; 0xeb9f
   28b72:	eb01 31e2 	add.w	r1, r1, r2, asr #15
   28b76:	fb11 f103 	smulbb	r1, r1, r3
   28b7a:	f643 5282 	movw	r2, #15746	; 0x3d82
   28b7e:	eb02 32e1 	add.w	r2, r2, r1, asr #15
   28b82:	b292      	uxth	r2, r2
   28b84:	fb03 f302 	mul.w	r3, r3, r2
      logXC2 = MAX16(HALF16(logXC), celt_log2(QCONST32(1.001f, 20)-MULT16_16(minXC, minXC)));
   28b88:	4ac6      	ldr	r2, [pc, #792]	; (28ea4 <celt_encode_with_ec+0x39dc>)
   28b8a:	13db      	asrs	r3, r3, #15
   28b8c:	fb09 2919 	mls	r9, r9, r9, r2
   28b90:	f5a3 53d4 	sub.w	r3, r3, #6784	; 0x1a80
   28b94:	3b09      	subs	r3, #9
   return EC_ILOG(x)-1;
   28b96:	fab9 f189 	clz	r1, r9
   return SHL16(i-13,DB_SHIFT)+SHR16(frac,14-DB_SHIFT);
   28b9a:	f343 140b 	sbfx	r4, r3, #4, #12
   return EC_ILOG(x)-1;
   28b9e:	f1c1 031f 	rsb	r3, r1, #31
   28ba2:	b29b      	uxth	r3, r3
   n = VSHR32(x,i-15)-32768-16384;
   28ba4:	2b0f      	cmp	r3, #15
   28ba6:	bf8b      	itete	hi
   28ba8:	3b0f      	subhi	r3, #15
   28baa:	f1c3 030f 	rsbls	r3, r3, #15
   28bae:	fa49 f303 	asrhi.w	r3, r9, r3
   28bb2:	fa09 f303 	lslls.w	r3, r9, r3
   28bb6:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
   28bba:	b21b      	sxth	r3, r3
   frac = ADD16(C[0], MULT16_16_Q15(n, ADD16(C[1], MULT16_16_Q15(n, ADD16(C[2], MULT16_16_Q15(n, ADD16(C[3], MULT16_16_Q15(n, C[4]))))))));
   28bbc:	f64f 2287 	movw	r2, #64135	; 0xfa87
   28bc0:	fb13 f202 	smulbb	r2, r3, r2
   28bc4:	13d2      	asrs	r2, r2, #15
   28bc6:	f602 12f1 	addw	r2, r2, #2545	; 0x9f1
   return SHL16(i-13,DB_SHIFT)+SHR16(frac,14-DB_SHIFT);
   28bca:	f1c0 0012 	rsb	r0, r0, #18
   frac = ADD16(C[0], MULT16_16_Q15(n, ADD16(C[1], MULT16_16_Q15(n, ADD16(C[2], MULT16_16_Q15(n, ADD16(C[3], MULT16_16_Q15(n, C[4]))))))));
   28bce:	b292      	uxth	r2, r2
   28bd0:	fb03 f202 	mul.w	r2, r3, r2
   return SHL16(i-13,DB_SHIFT)+SHR16(frac,14-DB_SHIFT);
   28bd4:	eb04 2480 	add.w	r4, r4, r0, lsl #10
   frac = ADD16(C[0], MULT16_16_Q15(n, ADD16(C[1], MULT16_16_Q15(n, ADD16(C[2], MULT16_16_Q15(n, ADD16(C[3], MULT16_16_Q15(n, C[4]))))))));
   28bd8:	f64e 309f 	movw	r0, #60319	; 0xeb9f
   28bdc:	eb00 30e2 	add.w	r0, r0, r2, asr #15
   28be0:	fb10 f003 	smulbb	r0, r0, r3
   28be4:	f643 5282 	movw	r2, #15746	; 0x3d82
   28be8:	eb02 32e0 	add.w	r2, r2, r0, asr #15
   28bec:	b292      	uxth	r2, r2
   28bee:	fb03 f302 	mul.w	r3, r3, r2
   28bf2:	13db      	asrs	r3, r3, #15
   28bf4:	f5a3 53d4 	sub.w	r3, r3, #6784	; 0x1a80
   28bf8:	3b09      	subs	r3, #9
   return SHL16(i-13,DB_SHIFT)+SHR16(frac,14-DB_SHIFT);
   28bfa:	f1c1 0112 	rsb	r1, r1, #18
   28bfe:	f343 130b 	sbfx	r3, r3, #4, #12
   28c02:	b224      	sxth	r4, r4
   28c04:	eb03 2381 	add.w	r3, r3, r1, lsl #10
   28c08:	1065      	asrs	r5, r4, #1
      logXC2 = PSHR32(logXC2-QCONST16(6.f, DB_SHIFT),DB_SHIFT-8);
   28c0a:	b21b      	sxth	r3, r3
   28c0c:	42ab      	cmp	r3, r5
   28c0e:	bfb8      	it	lt
   28c10:	462b      	movlt	r3, r5
      *stereo_saving = MIN16(*stereo_saving + QCONST16(0.25f, 8), -HALF16(logXC2));
   28c12:	f8d7 012c 	ldr.w	r0, [r7, #300]	; 0x12c
      trim += MAX16(-QCONST16(4.f, 8), MULT16_16_Q15(QCONST16(.75f,15),logXC));
   28c16:	49a4      	ldr	r1, [pc, #656]	; (28ea8 <celt_encode_with_ec+0x39e0>)
      *stereo_saving = MIN16(*stereo_saving + QCONST16(0.25f, 8), -HALF16(logXC2));
   28c18:	f9b0 20e4 	ldrsh.w	r2, [r0, #228]	; 0xe4
      logXC = PSHR32(logXC-QCONST16(6.f, DB_SHIFT),DB_SHIFT-8);
   28c1c:	f5a4 54bf 	sub.w	r4, r4, #6112	; 0x17e0
      logXC2 = PSHR32(logXC2-QCONST16(6.f, DB_SHIFT),DB_SHIFT-8);
   28c20:	f5a3 53bf 	sub.w	r3, r3, #6112	; 0x17e0
      logXC = PSHR32(logXC-QCONST16(6.f, DB_SHIFT),DB_SHIFT-8);
   28c24:	3c1e      	subs	r4, #30
      logXC2 = PSHR32(logXC2-QCONST16(6.f, DB_SHIFT),DB_SHIFT-8);
   28c26:	3b1e      	subs	r3, #30
      logXC = PSHR32(logXC-QCONST16(6.f, DB_SHIFT),DB_SHIFT-8);
   28c28:	10a4      	asrs	r4, r4, #2
      *stereo_saving = MIN16(*stereo_saving + QCONST16(0.25f, 8), -HALF16(logXC2));
   28c2a:	10db      	asrs	r3, r3, #3
   28c2c:	425b      	negs	r3, r3
   28c2e:	3240      	adds	r2, #64	; 0x40
      trim += MAX16(-QCONST16(4.f, 8), MULT16_16_Q15(QCONST16(.75f,15),logXC));
   28c30:	eb04 0444 	add.w	r4, r4, r4, lsl #1
      *stereo_saving = MIN16(*stereo_saving + QCONST16(0.25f, 8), -HALF16(logXC2));
   28c34:	4293      	cmp	r3, r2
      trim += MAX16(-QCONST16(4.f, 8), MULT16_16_Q15(QCONST16(.75f,15),logXC));
   28c36:	ea4f 04a4 	mov.w	r4, r4, asr #2
      *stereo_saving = MIN16(*stereo_saving + QCONST16(0.25f, 8), -HALF16(logXC2));
   28c3a:	bfa8      	it	ge
   28c3c:	4613      	movge	r3, r2
      trim += MAX16(-QCONST16(4.f, 8), MULT16_16_Q15(QCONST16(.75f,15),logXC));
   28c3e:	428c      	cmp	r4, r1
   28c40:	bfac      	ite	ge
   28c42:	44a0      	addge	r8, r4
   28c44:	4488      	addlt	r8, r1
      *stereo_saving = MIN16(*stereo_saving + QCONST16(0.25f, 8), -HALF16(logXC2));
   28c46:	f8a0 30e4 	strh.w	r3, [r0, #228]	; 0xe4
      trim += MAX16(-QCONST16(4.f, 8), MULT16_16_Q15(QCONST16(.75f,15),logXC));
   28c4a:	fa1f f888 	uxth.w	r8, r8
   28c4e:	e484      	b.n	2855a <celt_encode_with_ec+0x3092>
   28c50:	2300      	movs	r3, #0
   28c52:	e767      	b.n	28b24 <celt_encode_with_ec+0x365c>
   } else if (equiv_rate < 80000) {
   28c54:	f44f 68a0 	mov.w	r8, #1280	; 0x500
   28c58:	e47a      	b.n	28550 <celt_encode_with_ec+0x3088>
   trim -= MAX32(-QCONST16(2.f, 8), MIN32(QCONST16(2.f, 8), SHR32(diff+QCONST16(1.f, DB_SHIFT),DB_SHIFT-8)/6 ));
   28c5a:	f44f 7300 	mov.w	r3, #512	; 0x200
   28c5e:	e4b3      	b.n	285c8 <celt_encode_with_ec+0x3100>
      for (i=0;i<end;i++)
   28c60:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
   28c64:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
   28c68:	e44c      	b.n	28504 <celt_encode_with_ec+0x303c>
      for (i=start+1;i<end;i++)
   28c6a:	f8d7 2124 	ldr.w	r2, [r7, #292]	; 0x124
      spread_old[start] = oldE[start];
   28c6e:	f8a7 316c 	strh.w	r3, [r7, #364]	; 0x16c
      for (i=start+1;i<end;i++)
   28c72:	2a01      	cmp	r2, #1
   28c74:	f77f ae6c 	ble.w	28950 <celt_encode_with_ec+0x3488>
   28c78:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
   28c7c:	1e90      	subs	r0, r2, #2
   28c7e:	f8d7 2110 	ldr.w	r2, [r7, #272]	; 0x110
   28c82:	f507 71b6 	add.w	r1, r7, #364	; 0x16c
   28c86:	1814      	adds	r4, r2, r0
         spread_old[i] = MAX16(spread_old[i-1]-QCONST16(1.0f, DB_SHIFT), oldE[i]);
   28c88:	f932 5f02 	ldrsh.w	r5, [r2, #2]!
   28c8c:	f5a3 6380 	sub.w	r3, r3, #1024	; 0x400
   28c90:	42ab      	cmp	r3, r5
   28c92:	bfb8      	it	lt
   28c94:	462b      	movlt	r3, r5
   28c96:	b21b      	sxth	r3, r3
      for (i=start+1;i<end;i++)
   28c98:	4294      	cmp	r4, r2
         spread_old[i] = MAX16(spread_old[i-1]-QCONST16(1.0f, DB_SHIFT), oldE[i]);
   28c9a:	f821 3f02 	strh.w	r3, [r1, #2]!
      for (i=start+1;i<end;i++)
   28c9e:	d1f3      	bne.n	28c88 <celt_encode_with_ec+0x37c0>
   28ca0:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
   28ca4:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   28ca8:	f7fe bf75 	b.w	27b96 <celt_encode_with_ec+0x26ce>
         compute_mdcts(mode, shortBlocks, in, freq, C, CC, LM, st->upsample, st->arch);
   28cac:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
   28cb0:	6c93      	ldr	r3, [r2, #72]	; 0x48
   28cb2:	9304      	str	r3, [sp, #16]
   28cb4:	69d3      	ldr	r3, [r2, #28]
   28cb6:	9303      	str	r3, [sp, #12]
   28cb8:	f8d7 510c 	ldr.w	r5, [r7, #268]	; 0x10c
   28cbc:	4614      	mov	r4, r2
   28cbe:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
   28cc2:	9502      	str	r5, [sp, #8]
   28cc4:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
   28cc8:	9301      	str	r3, [sp, #4]
   28cca:	f8d7 6114 	ldr.w	r6, [r7, #276]	; 0x114
   28cce:	9600      	str	r6, [sp, #0]
   28cd0:	f8d7 8100 	ldr.w	r8, [r7, #256]	; 0x100
   28cd4:	f8d7 a0dc 	ldr.w	sl, [r7, #220]	; 0xdc
   28cd8:	6f79      	ldr	r1, [r7, #116]	; 0x74
   28cda:	4653      	mov	r3, sl
   28cdc:	4640      	mov	r0, r8
   28cde:	f7fb f9c7 	bl	24070 <compute_mdcts>
         compute_band_energies(mode, freq, bandE, effEnd, C, LM, st->arch);
   28ce2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   28ce4:	9302      	str	r3, [sp, #8]
   28ce6:	e9cd 6500 	strd	r6, r5, [sp]
   28cea:	462c      	mov	r4, r5
   28cec:	f8d7 90e4 	ldr.w	r9, [r7, #228]	; 0xe4
   28cf0:	f8d7 50d4 	ldr.w	r5, [r7, #212]	; 0xd4
   28cf4:	464b      	mov	r3, r9
   28cf6:	462a      	mov	r2, r5
   28cf8:	4651      	mov	r1, sl
   28cfa:	4640      	mov	r0, r8
   28cfc:	f7f9 f9bc 	bl	22078 <compute_band_energies>
         amp2Log2(mode, effEnd, end, bandE, bandLogE, C);
   28d00:	9601      	str	r6, [sp, #4]
   28d02:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
   28d06:	9200      	str	r2, [sp, #0]
   28d08:	4649      	mov	r1, r9
   28d0a:	462b      	mov	r3, r5
   28d0c:	f8d7 2124 	ldr.w	r2, [r7, #292]	; 0x124
   28d10:	4640      	mov	r0, r8
   28d12:	f004 fbb1 	bl	2d478 <amp2Log2>
         for (i=0;i<C*nbEBands;i++)
   28d16:	f8d7 10c0 	ldr.w	r1, [r7, #192]	; 0xc0
   28d1a:	2900      	cmp	r1, #0
   28d1c:	f340 808b 	ble.w	28e36 <celt_encode_with_ec+0x396e>
   28d20:	f8d7 00cc 	ldr.w	r0, [r7, #204]	; 0xcc
   28d24:	0843      	lsrs	r3, r0, #1
   28d26:	425b      	negs	r3, r3
   28d28:	f003 0303 	and.w	r3, r3, #3
            bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   28d2c:	f344 0c05 	sbfx	ip, r4, #0, #6
   28d30:	1cda      	adds	r2, r3, #3
   28d32:	3901      	subs	r1, #1
   28d34:	ea4f 2c4c 	mov.w	ip, ip, lsl #9
   28d38:	428a      	cmp	r2, r1
   28d3a:	fa1f fc8c 	uxth.w	ip, ip
   28d3e:	f200 80a1 	bhi.w	28e84 <celt_encode_with_ec+0x39bc>
   28d42:	2b00      	cmp	r3, #0
   28d44:	f000 809c 	beq.w	28e80 <celt_encode_with_ec+0x39b8>
   28d48:	8802      	ldrh	r2, [r0, #0]
   28d4a:	2b01      	cmp	r3, #1
   28d4c:	4462      	add	r2, ip
   28d4e:	8002      	strh	r2, [r0, #0]
   28d50:	f000 8096 	beq.w	28e80 <celt_encode_with_ec+0x39b8>
   28d54:	8842      	ldrh	r2, [r0, #2]
   28d56:	2b03      	cmp	r3, #3
   28d58:	4462      	add	r2, ip
   28d5a:	8042      	strh	r2, [r0, #2]
   28d5c:	f040 8086 	bne.w	28e6c <celt_encode_with_ec+0x39a4>
   28d60:	8882      	ldrh	r2, [r0, #4]
   28d62:	4462      	add	r2, ip
   28d64:	8082      	strh	r2, [r0, #4]
         for (i=0;i<C*nbEBands;i++)
   28d66:	4698      	mov	r8, r3
   28d68:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
   28d6c:	eba2 0a03 	sub.w	sl, r2, r3
   28d70:	f8d7 20cc 	ldr.w	r2, [r7, #204]	; 0xcc
   28d74:	eb02 0343 	add.w	r3, r2, r3, lsl #1
   28d78:	ea4f 0b9a 	mov.w	fp, sl, lsr #2
   28d7c:	f1a3 0e08 	sub.w	lr, r3, #8
   28d80:	f04f 0900 	mov.w	r9, #0
            bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   28d84:	f85e 1f08 	ldr.w	r1, [lr, #8]!
   28d88:	f8de 0004 	ldr.w	r0, [lr, #4]
   28d8c:	2200      	movs	r2, #0
   28d8e:	eb0c 0600 	add.w	r6, ip, r0
   28d92:	4614      	mov	r4, r2
   28d94:	eb0c 0501 	add.w	r5, ip, r1
   28d98:	eb0c 4010 	add.w	r0, ip, r0, lsr #16
   28d9c:	f366 040f 	bfi	r4, r6, #0, #16
   28da0:	f365 020f 	bfi	r2, r5, #0, #16
   28da4:	eb0c 4111 	add.w	r1, ip, r1, lsr #16
   28da8:	f109 0901 	add.w	r9, r9, #1
   28dac:	f360 441f 	bfi	r4, r0, #16, #16
   28db0:	f361 421f 	bfi	r2, r1, #16, #16
   28db4:	45d9      	cmp	r9, fp
   28db6:	e9c3 2400 	strd	r2, r4, [r3]
   28dba:	f103 0308 	add.w	r3, r3, #8
   28dbe:	d3e1      	bcc.n	28d84 <celt_encode_with_ec+0x38bc>
   28dc0:	f02a 0303 	bic.w	r3, sl, #3
   28dc4:	4553      	cmp	r3, sl
   28dc6:	4498      	add	r8, r3
   28dc8:	d035      	beq.n	28e36 <celt_encode_with_ec+0x396e>
   28dca:	f8d7 00cc 	ldr.w	r0, [r7, #204]	; 0xcc
         for (i=0;i<C*nbEBands;i++)
   28dce:	f8d7 50c0 	ldr.w	r5, [r7, #192]	; 0xc0
            bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   28dd2:	f830 3018 	ldrh.w	r3, [r0, r8, lsl #1]
         for (i=0;i<C*nbEBands;i++)
   28dd6:	f108 0201 	add.w	r2, r8, #1
            bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   28dda:	4463      	add	r3, ip
         for (i=0;i<C*nbEBands;i++)
   28ddc:	42aa      	cmp	r2, r5
            bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   28dde:	f820 3018 	strh.w	r3, [r0, r8, lsl #1]
         for (i=0;i<C*nbEBands;i++)
   28de2:	da28      	bge.n	28e36 <celt_encode_with_ec+0x396e>
            bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   28de4:	f830 1012 	ldrh.w	r1, [r0, r2, lsl #1]
         for (i=0;i<C*nbEBands;i++)
   28de8:	f108 0302 	add.w	r3, r8, #2
            bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   28dec:	4461      	add	r1, ip
         for (i=0;i<C*nbEBands;i++)
   28dee:	42ab      	cmp	r3, r5
            bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   28df0:	f820 1012 	strh.w	r1, [r0, r2, lsl #1]
         for (i=0;i<C*nbEBands;i++)
   28df4:	da1f      	bge.n	28e36 <celt_encode_with_ec+0x396e>
            bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   28df6:	f830 1013 	ldrh.w	r1, [r0, r3, lsl #1]
         for (i=0;i<C*nbEBands;i++)
   28dfa:	f108 0203 	add.w	r2, r8, #3
            bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   28dfe:	4461      	add	r1, ip
         for (i=0;i<C*nbEBands;i++)
   28e00:	42aa      	cmp	r2, r5
            bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   28e02:	f820 1013 	strh.w	r1, [r0, r3, lsl #1]
         for (i=0;i<C*nbEBands;i++)
   28e06:	da16      	bge.n	28e36 <celt_encode_with_ec+0x396e>
            bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   28e08:	f830 1012 	ldrh.w	r1, [r0, r2, lsl #1]
         for (i=0;i<C*nbEBands;i++)
   28e0c:	f108 0304 	add.w	r3, r8, #4
            bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   28e10:	4461      	add	r1, ip
         for (i=0;i<C*nbEBands;i++)
   28e12:	42ab      	cmp	r3, r5
            bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   28e14:	f820 1012 	strh.w	r1, [r0, r2, lsl #1]
         for (i=0;i<C*nbEBands;i++)
   28e18:	da0d      	bge.n	28e36 <celt_encode_with_ec+0x396e>
            bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   28e1a:	f830 2013 	ldrh.w	r2, [r0, r3, lsl #1]
         for (i=0;i<C*nbEBands;i++)
   28e1e:	f108 0805 	add.w	r8, r8, #5
            bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   28e22:	4462      	add	r2, ip
         for (i=0;i<C*nbEBands;i++)
   28e24:	45a8      	cmp	r8, r5
            bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   28e26:	f820 2013 	strh.w	r2, [r0, r3, lsl #1]
         for (i=0;i<C*nbEBands;i++)
   28e2a:	da04      	bge.n	28e36 <celt_encode_with_ec+0x396e>
            bandLogE2[i] += HALF16(SHL16(LM, DB_SHIFT));
   28e2c:	f830 3018 	ldrh.w	r3, [r0, r8, lsl #1]
   28e30:	449c      	add	ip, r3
   28e32:	f820 c018 	strh.w	ip, [r0, r8, lsl #1]
   28e36:	f8d7 31cc 	ldr.w	r3, [r7, #460]	; 0x1cc
   28e3a:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
   28e3e:	69db      	ldr	r3, [r3, #28]
   28e40:	6952      	ldr	r2, [r2, #20]
   28e42:	fab3 f383 	clz	r3, r3
   28e46:	4413      	add	r3, r2
   if (LM>0 && ec_tell(enc)+3<=total_bits)
   28e48:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
   28e4c:	3b1e      	subs	r3, #30
   28e4e:	4293      	cmp	r3, r2
   28e50:	6f7b      	ldr	r3, [r7, #116]	; 0x74
   28e52:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
   28e56:	f640 43cd 	movw	r3, #3277	; 0xccd
   28e5a:	65bb      	str	r3, [r7, #88]	; 0x58
   28e5c:	f04f 0301 	mov.w	r3, #1
   28e60:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
   28e64:	f6bd aaaa 	bge.w	263bc <celt_encode_with_ec+0xef4>
   28e68:	f7fd baa1 	b.w	263ae <celt_encode_with_ec+0xee6>
         for (i=0;i<C*nbEBands;i++)
   28e6c:	f04f 0802 	mov.w	r8, #2
   28e70:	e77a      	b.n	28d68 <celt_encode_with_ec+0x38a0>
         shortBlocks = M;
   28e72:	6f7b      	ldr	r3, [r7, #116]	; 0x74
   28e74:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
   int transient_got_disabled=0;
   28e78:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
   28e7c:	f7fd b8cf 	b.w	2601e <celt_encode_with_ec+0xb56>
         for (i=0;i<C*nbEBands;i++)
   28e80:	4698      	mov	r8, r3
   28e82:	e771      	b.n	28d68 <celt_encode_with_ec+0x38a0>
   28e84:	f04f 0800 	mov.w	r8, #0
   28e88:	e79f      	b.n	28dca <celt_encode_with_ec+0x3902>
         gain1 = HALF32(gain1);
   28e8a:	1064      	asrs	r4, r4, #1
   28e8c:	f7fe bcb9 	b.w	27802 <celt_encode_with_ec+0x233a>
        base_target += (st->vbr_offset>>lm_diff);
   28e90:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
   28e94:	f8d2 20d8 	ldr.w	r2, [r2, #216]	; 0xd8
   28e98:	fa42 f209 	asr.w	r2, r2, r9
   28e9c:	4416      	add	r6, r2
   28e9e:	f7fd bdde 	b.w	26a5e <celt_encode_with_ec+0x1596>
   28ea2:	bf00      	nop
   28ea4:	00100419 	.word	0x00100419
   28ea8:	fffffc00 	.word	0xfffffc00

00028eac <opus_custom_encoder_ctl>:
#endif

#endif /* CUSTOM_MODES */

int opus_custom_encoder_ctl(CELTEncoder * OPUS_RESTRICT st, int request, ...)
{
   28eac:	b40e      	push	{r1, r2, r3}
   28eae:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   28eb2:	b082      	sub	sp, #8
   28eb4:	ab09      	add	r3, sp, #36	; 0x24
   va_list ap;

   va_start(ap, request);
   switch (request)
   28eb6:	f640 71cf 	movw	r1, #4047	; 0xfcf
{
   28eba:	f853 2b04 	ldr.w	r2, [r3], #4
   va_start(ap, request);
   28ebe:	9301      	str	r3, [sp, #4]
   switch (request)
   28ec0:	428a      	cmp	r2, r1
{
   28ec2:	4604      	mov	r4, r0
   switch (request)
   28ec4:	f000 819a 	beq.w	291fc <opus_custom_encoder_ctl+0x350>
   28ec8:	f5b2 6f7d 	cmp.w	r2, #4048	; 0xfd0
   28ecc:	da1f      	bge.n	28f0e <opus_custom_encoder_ctl+0x62>
   28ece:	f640 71b4 	movw	r1, #4020	; 0xfb4
   28ed2:	428a      	cmp	r2, r1
   28ed4:	f000 8199 	beq.w	2920a <opus_custom_encoder_ctl+0x35e>
   28ed8:	dd46      	ble.n	28f68 <opus_custom_encoder_ctl+0xbc>
   28eda:	f640 71c4 	movw	r1, #4036	; 0xfc4
   28ede:	428a      	cmp	r2, r1
   28ee0:	f000 80cc 	beq.w	2907c <opus_custom_encoder_ctl+0x1d0>
   28ee4:	f300 8087 	bgt.w	28ff6 <opus_custom_encoder_ctl+0x14a>
   28ee8:	f640 71bc 	movw	r1, #4028	; 0xfbc
   28eec:	428a      	cmp	r2, r1
   28eee:	f000 80fb 	beq.w	290e8 <opus_custom_encoder_ctl+0x23c>
   28ef2:	f640 71bf 	movw	r1, #4031	; 0xfbf
   28ef6:	428a      	cmp	r2, r1
   28ef8:	f040 80ca 	bne.w	29090 <opus_custom_encoder_ctl+0x1e4>
         *value=st->mode;
      }
      break;
      case OPUS_GET_FINAL_RANGE_REQUEST:
      {
         opus_uint32 * value = va_arg(ap, opus_uint32 *);
   28efc:	681a      	ldr	r2, [r3, #0]
   28efe:	3304      	adds	r3, #4
   28f00:	9301      	str	r3, [sp, #4]
         if (value==0)
   28f02:	2a00      	cmp	r2, #0
   28f04:	f000 818b 	beq.w	2921e <opus_custom_encoder_ctl+0x372>
            goto bad_arg;
         *value=st->rng;
   28f08:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
   28f0a:	6013      	str	r3, [r2, #0]
      }
      break;
   28f0c:	e0ad      	b.n	2906a <opus_custom_encoder_ctl+0x1be>
   switch (request)
   28f0e:	f242 711f 	movw	r1, #10015	; 0x271f
   28f12:	428a      	cmp	r2, r1
   28f14:	f000 817c 	beq.w	29210 <opus_custom_encoder_ctl+0x364>
   28f18:	dd3e      	ble.n	28f98 <opus_custom_encoder_ctl+0xec>
   28f1a:	f242 7128 	movw	r1, #10024	; 0x2728
   28f1e:	428a      	cmp	r2, r1
   28f20:	f000 80a9 	beq.w	29076 <opus_custom_encoder_ctl+0x1ca>
   28f24:	dc53      	bgt.n	28fce <opus_custom_encoder_ctl+0x122>
   28f26:	f242 7120 	movw	r1, #10016	; 0x2720
   28f2a:	428a      	cmp	r2, r1
   28f2c:	f000 8163 	beq.w	291f6 <opus_custom_encoder_ctl+0x34a>
   28f30:	f242 7126 	movw	r1, #10022	; 0x2726
   28f34:	428a      	cmp	r2, r1
   28f36:	f040 80ab 	bne.w	29090 <opus_custom_encoder_ctl+0x1e4>
         AnalysisInfo *info = va_arg(ap, AnalysisInfo *);
   28f3a:	681a      	ldr	r2, [r3, #0]
   28f3c:	3304      	adds	r3, #4
   28f3e:	9301      	str	r3, [sp, #4]
         if (info)
   28f40:	2a00      	cmp	r2, #0
   28f42:	f000 8092 	beq.w	2906a <opus_custom_encoder_ctl+0x1be>
            OPUS_COPY(&st->analysis, info, 1);
   28f46:	4613      	mov	r3, r2
   28f48:	3478      	adds	r4, #120	; 0x78
   28f4a:	3240      	adds	r2, #64	; 0x40
   28f4c:	681d      	ldr	r5, [r3, #0]
   28f4e:	6858      	ldr	r0, [r3, #4]
   28f50:	6899      	ldr	r1, [r3, #8]
   28f52:	68de      	ldr	r6, [r3, #12]
   28f54:	60e6      	str	r6, [r4, #12]
   28f56:	3310      	adds	r3, #16
   28f58:	4293      	cmp	r3, r2
   28f5a:	6025      	str	r5, [r4, #0]
   28f5c:	6060      	str	r0, [r4, #4]
   28f5e:	60a1      	str	r1, [r4, #8]
   28f60:	f104 0410 	add.w	r4, r4, #16
   28f64:	d1f2      	bne.n	28f4c <opus_custom_encoder_ctl+0xa0>
   28f66:	e080      	b.n	2906a <opus_custom_encoder_ctl+0x1be>
   switch (request)
   28f68:	f640 71a6 	movw	r1, #4006	; 0xfa6
   28f6c:	428a      	cmp	r2, r1
   28f6e:	f000 80af 	beq.w	290d0 <opus_custom_encoder_ctl+0x224>
   28f72:	dd50      	ble.n	29016 <opus_custom_encoder_ctl+0x16a>
   28f74:	f640 71aa 	movw	r1, #4010	; 0xfaa
   28f78:	428a      	cmp	r2, r1
   28f7a:	f000 80a1 	beq.w	290c0 <opus_custom_encoder_ctl+0x214>
   28f7e:	f640 71ae 	movw	r1, #4014	; 0xfae
   28f82:	428a      	cmp	r2, r1
   28f84:	f040 8084 	bne.w	29090 <opus_custom_encoder_ctl+0x1e4>
         int value = va_arg(ap, opus_int32);
   28f88:	681a      	ldr	r2, [r3, #0]
   28f8a:	3304      	adds	r3, #4
         if (value<0 || value>100)
   28f8c:	2a64      	cmp	r2, #100	; 0x64
         int value = va_arg(ap, opus_int32);
   28f8e:	9301      	str	r3, [sp, #4]
         if (value<0 || value>100)
   28f90:	f200 8145 	bhi.w	2921e <opus_custom_encoder_ctl+0x372>
         st->loss_rate = value;
   28f94:	6382      	str	r2, [r0, #56]	; 0x38
      break;
   28f96:	e068      	b.n	2906a <opus_custom_encoder_ctl+0x1be>
   switch (request)
   28f98:	f242 7118 	movw	r1, #10008	; 0x2718
   28f9c:	428a      	cmp	r2, r1
   28f9e:	f000 809a 	beq.w	290d6 <opus_custom_encoder_ctl+0x22a>
   28fa2:	dd4e      	ble.n	29042 <opus_custom_encoder_ctl+0x196>
   28fa4:	f242 711a 	movw	r1, #10010	; 0x271a
   28fa8:	428a      	cmp	r2, r1
   28faa:	d07c      	beq.n	290a6 <opus_custom_encoder_ctl+0x1fa>
   28fac:	f242 711c 	movw	r1, #10012	; 0x271c
   28fb0:	428a      	cmp	r2, r1
   28fb2:	d16d      	bne.n	29090 <opus_custom_encoder_ctl+0x1e4>
         opus_int32 value = va_arg(ap, opus_int32);
   28fb4:	681a      	ldr	r2, [r3, #0]
   28fb6:	3304      	adds	r3, #4
         if (value<1 || value>st->mode->nbEBands)
   28fb8:	2a00      	cmp	r2, #0
         opus_int32 value = va_arg(ap, opus_int32);
   28fba:	9301      	str	r3, [sp, #4]
         if (value<1 || value>st->mode->nbEBands)
   28fbc:	f340 812f 	ble.w	2921e <opus_custom_encoder_ctl+0x372>
   28fc0:	6803      	ldr	r3, [r0, #0]
   28fc2:	689b      	ldr	r3, [r3, #8]
   28fc4:	4293      	cmp	r3, r2
   28fc6:	f2c0 812a 	blt.w	2921e <opus_custom_encoder_ctl+0x372>
         st->end = value;
   28fca:	6242      	str	r2, [r0, #36]	; 0x24
      break;
   28fcc:	e04d      	b.n	2906a <opus_custom_encoder_ctl+0x1be>
   switch (request)
   28fce:	f242 712a 	movw	r1, #10026	; 0x272a
   28fd2:	428a      	cmp	r2, r1
   28fd4:	d063      	beq.n	2909e <opus_custom_encoder_ctl+0x1f2>
   28fd6:	f242 712c 	movw	r1, #10028	; 0x272c
   28fda:	428a      	cmp	r2, r1
   28fdc:	d158      	bne.n	29090 <opus_custom_encoder_ctl+0x1e4>
         SILKInfo *info = va_arg(ap, SILKInfo *);
   28fde:	681a      	ldr	r2, [r3, #0]
   28fe0:	3304      	adds	r3, #4
   28fe2:	9301      	str	r3, [sp, #4]
         if (info)
   28fe4:	2a00      	cmp	r2, #0
   28fe6:	d040      	beq.n	2906a <opus_custom_encoder_ctl+0x1be>
            OPUS_COPY(&st->silk_info, info, 1);
   28fe8:	6813      	ldr	r3, [r2, #0]
   28fea:	6852      	ldr	r2, [r2, #4]
   28fec:	f8c0 20bc 	str.w	r2, [r0, #188]	; 0xbc
   28ff0:	f8c0 30b8 	str.w	r3, [r0, #184]	; 0xb8
   28ff4:	e039      	b.n	2906a <opus_custom_encoder_ctl+0x1be>
   switch (request)
   28ff6:	f640 71c5 	movw	r1, #4037	; 0xfc5
   28ffa:	428a      	cmp	r2, r1
   28ffc:	d04b      	beq.n	29096 <opus_custom_encoder_ctl+0x1ea>
   28ffe:	f640 71ce 	movw	r1, #4046	; 0xfce
   29002:	428a      	cmp	r2, r1
   29004:	d144      	bne.n	29090 <opus_custom_encoder_ctl+0x1e4>
          opus_int32 value = va_arg(ap, opus_int32);
   29006:	681a      	ldr	r2, [r3, #0]
   29008:	3304      	adds	r3, #4
          if(value<0 || value>1)
   2900a:	2a01      	cmp	r2, #1
          opus_int32 value = va_arg(ap, opus_int32);
   2900c:	9301      	str	r3, [sp, #4]
          if(value<0 || value>1)
   2900e:	f200 8106 	bhi.w	2921e <opus_custom_encoder_ctl+0x372>
          st->disable_inv = value;
   29012:	6442      	str	r2, [r0, #68]	; 0x44
      break;
   29014:	e029      	b.n	2906a <opus_custom_encoder_ctl+0x1be>
   switch (request)
   29016:	f640 71a2 	movw	r1, #4002	; 0xfa2
   2901a:	428a      	cmp	r2, r1
   2901c:	d138      	bne.n	29090 <opus_custom_encoder_ctl+0x1e4>
         opus_int32 value = va_arg(ap, opus_int32);
   2901e:	6819      	ldr	r1, [r3, #0]
   29020:	3304      	adds	r3, #4
         if (value<=500 && value!=OPUS_BITRATE_MAX)
   29022:	f5b1 7ffa 	cmp.w	r1, #500	; 0x1f4
         opus_int32 value = va_arg(ap, opus_int32);
   29026:	9301      	str	r3, [sp, #4]
         if (value<=500 && value!=OPUS_BITRATE_MAX)
   29028:	dc02      	bgt.n	29030 <opus_custom_encoder_ctl+0x184>
   2902a:	1c4b      	adds	r3, r1, #1
   2902c:	f040 80f7 	bne.w	2921e <opus_custom_encoder_ctl+0x372>
         value = IMIN(value, 260000*st->channels);
   29030:	6863      	ldr	r3, [r4, #4]
   29032:	4a86      	ldr	r2, [pc, #536]	; (2924c <opus_custom_encoder_ctl+0x3a0>)
   29034:	fb02 f303 	mul.w	r3, r2, r3
   29038:	428b      	cmp	r3, r1
   2903a:	bfa8      	it	ge
   2903c:	460b      	movge	r3, r1
         st->bitrate = value;
   2903e:	62a3      	str	r3, [r4, #40]	; 0x28
      break;
   29040:	e013      	b.n	2906a <opus_custom_encoder_ctl+0x1be>
   switch (request)
   29042:	f242 7112 	movw	r1, #10002	; 0x2712
   29046:	428a      	cmp	r2, r1
   29048:	d122      	bne.n	29090 <opus_custom_encoder_ctl+0x1e4>
         int value = va_arg(ap, opus_int32);
   2904a:	681a      	ldr	r2, [r3, #0]
   2904c:	3304      	adds	r3, #4
         if (value<0 || value>2)
   2904e:	2a02      	cmp	r2, #2
         int value = va_arg(ap, opus_int32);
   29050:	9301      	str	r3, [sp, #4]
         if (value<0 || value>2)
   29052:	f200 80e4 	bhi.w	2921e <opus_custom_encoder_ctl+0x372>
         st->force_intra = value==0;
   29056:	fab2 f382 	clz	r3, r2
         st->disable_pf = value<=1;
   2905a:	2a01      	cmp	r2, #1
         st->force_intra = value==0;
   2905c:	ea4f 1353 	mov.w	r3, r3, lsr #5
         st->disable_pf = value<=1;
   29060:	bfcc      	ite	gt
   29062:	2200      	movgt	r2, #0
   29064:	2201      	movle	r2, #1
         st->force_intra = value==0;
   29066:	60c3      	str	r3, [r0, #12]
         st->disable_pf = value<=1;
   29068:	6142      	str	r2, [r0, #20]
      break;
      default:
         goto bad_request;
   }
   va_end(ap);
   return OPUS_OK;
   2906a:	2000      	movs	r0, #0
   va_end(ap);
   return OPUS_BAD_ARG;
bad_request:
   va_end(ap);
   return OPUS_UNIMPLEMENTED;
}
   2906c:	b002      	add	sp, #8
   2906e:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
   29072:	b003      	add	sp, #12
   29074:	4770      	bx	lr
          st->lfe = value;
   29076:	681b      	ldr	r3, [r3, #0]
   29078:	6403      	str	r3, [r0, #64]	; 0x40
      break;
   2907a:	e7f6      	b.n	2906a <opus_custom_encoder_ctl+0x1be>
          opus_int32 value = va_arg(ap, opus_int32);
   2907c:	681a      	ldr	r2, [r3, #0]
          if (value<8 || value>24)
   2907e:	f1a2 0108 	sub.w	r1, r2, #8
          opus_int32 value = va_arg(ap, opus_int32);
   29082:	3304      	adds	r3, #4
          if (value<8 || value>24)
   29084:	2910      	cmp	r1, #16
          opus_int32 value = va_arg(ap, opus_int32);
   29086:	9301      	str	r3, [sp, #4]
          if (value<8 || value>24)
   29088:	f200 80c9 	bhi.w	2921e <opus_custom_encoder_ctl+0x372>
          st->lsb_depth=value;
   2908c:	63c2      	str	r2, [r0, #60]	; 0x3c
      break;
   2908e:	e7ec      	b.n	2906a <opus_custom_encoder_ctl+0x1be>
   return OPUS_UNIMPLEMENTED;
   29090:	f06f 0004 	mvn.w	r0, #4
   29094:	e7ea      	b.n	2906c <opus_custom_encoder_ctl+0x1c0>
          *value=st->lsb_depth;
   29096:	681b      	ldr	r3, [r3, #0]
   29098:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
   2909a:	601a      	str	r2, [r3, #0]
      break;
   2909c:	e7e5      	b.n	2906a <opus_custom_encoder_ctl+0x1be>
          opus_val16 *value = va_arg(ap, opus_val16*);
   2909e:	681b      	ldr	r3, [r3, #0]
          st->energy_mask = value;
   290a0:	f8c0 30ec 	str.w	r3, [r0, #236]	; 0xec
      break;
   290a4:	e7e1      	b.n	2906a <opus_custom_encoder_ctl+0x1be>
         opus_int32 value = va_arg(ap, opus_int32);
   290a6:	681a      	ldr	r2, [r3, #0]
   290a8:	3304      	adds	r3, #4
         if (value<0 || value>=st->mode->nbEBands)
   290aa:	2a00      	cmp	r2, #0
         opus_int32 value = va_arg(ap, opus_int32);
   290ac:	9301      	str	r3, [sp, #4]
         if (value<0 || value>=st->mode->nbEBands)
   290ae:	f2c0 80b6 	blt.w	2921e <opus_custom_encoder_ctl+0x372>
   290b2:	6803      	ldr	r3, [r0, #0]
   290b4:	689b      	ldr	r3, [r3, #8]
   290b6:	4293      	cmp	r3, r2
   290b8:	f340 80b1 	ble.w	2921e <opus_custom_encoder_ctl+0x372>
         st->start = value;
   290bc:	6202      	str	r2, [r0, #32]
      break;
   290be:	e7d4      	b.n	2906a <opus_custom_encoder_ctl+0x1be>
         int value = va_arg(ap, opus_int32);
   290c0:	681a      	ldr	r2, [r3, #0]
   290c2:	3304      	adds	r3, #4
         if (value<0 || value>10)
   290c4:	2a0a      	cmp	r2, #10
         int value = va_arg(ap, opus_int32);
   290c6:	9301      	str	r3, [sp, #4]
         if (value<0 || value>10)
   290c8:	f200 80a9 	bhi.w	2921e <opus_custom_encoder_ctl+0x372>
         st->complexity = value;
   290cc:	6182      	str	r2, [r0, #24]
      break;
   290ce:	e7cc      	b.n	2906a <opus_custom_encoder_ctl+0x1be>
         st->vbr = value;
   290d0:	681b      	ldr	r3, [r3, #0]
   290d2:	62c3      	str	r3, [r0, #44]	; 0x2c
      break;
   290d4:	e7c9      	b.n	2906a <opus_custom_encoder_ctl+0x1be>
         opus_int32 value = va_arg(ap, opus_int32);
   290d6:	681a      	ldr	r2, [r3, #0]
         if (value<1 || value>2)
   290d8:	1e51      	subs	r1, r2, #1
         opus_int32 value = va_arg(ap, opus_int32);
   290da:	3304      	adds	r3, #4
         if (value<1 || value>2)
   290dc:	2901      	cmp	r1, #1
         opus_int32 value = va_arg(ap, opus_int32);
   290de:	9301      	str	r3, [sp, #4]
         if (value<1 || value>2)
   290e0:	f200 809d 	bhi.w	2921e <opus_custom_encoder_ctl+0x372>
         st->stream_channels = value;
   290e4:	6082      	str	r2, [r0, #8]
      break;
   290e6:	e7c0      	b.n	2906a <opus_custom_encoder_ctl+0x1be>
         oldBandE = (opus_val16*)(st->in_mem+st->channels*(st->mode->overlap+COMBFILTER_MAXPERIOD));
   290e8:	4607      	mov	r7, r0
   290ea:	6846      	ldr	r6, [r0, #4]
   290ec:	f857 9bf4 	ldr.w	r9, [r7], #244
         oldLogE = oldBandE + st->channels*st->mode->nbEBands;
   290f0:	e9d9 5301 	ldrd	r5, r3, [r9, #4]
         oldBandE = (opus_val16*)(st->in_mem+st->channels*(st->mode->overlap+COMBFILTER_MAXPERIOD));
   290f4:	f505 6580 	add.w	r5, r5, #1024	; 0x400
   290f8:	fb06 f505 	mul.w	r5, r6, r5
         + 4*channels*mode->nbEBands*sizeof(opus_val16);  /* opus_val16 oldBandE[channels*mode->nbEBands]; */
   290fc:	00b2      	lsls	r2, r6, #2
   290fe:	fb03 f202 	mul.w	r2, r3, r2
   29102:	f105 013d 	add.w	r1, r5, #61	; 0x3d
   29106:	eb02 0241 	add.w	r2, r2, r1, lsl #1
   2910a:	0052      	lsls	r2, r2, #1
         OPUS_CLEAR((char*)&st->ENCODER_RESET_START,
   2910c:	3a4c      	subs	r2, #76	; 0x4c
   2910e:	2100      	movs	r1, #0
   29110:	304c      	adds	r0, #76	; 0x4c
         oldLogE = oldBandE + st->channels*st->mode->nbEBands;
   29112:	fb03 f806 	mul.w	r8, r3, r6
         OPUS_CLEAR((char*)&st->ENCODER_RESET_START,
   29116:	f00c f825 	bl	35164 <memset>
         for (i=0;i<st->channels*st->mode->nbEBands;i++)
   2911a:	f8d9 3008 	ldr.w	r3, [r9, #8]
         oldLogE = oldBandE + st->channels*st->mode->nbEBands;
   2911e:	ea4f 0e48 	mov.w	lr, r8, lsl #1
         for (i=0;i<st->channels*st->mode->nbEBands;i++)
   29122:	fb03 f606 	mul.w	r6, r3, r6
         oldLogE = oldBandE + st->channels*st->mode->nbEBands;
   29126:	eb0e 0085 	add.w	r0, lr, r5, lsl #2
         for (i=0;i<st->channels*st->mode->nbEBands;i++)
   2912a:	2e00      	cmp	r6, #0
         oldLogE = oldBandE + st->channels*st->mode->nbEBands;
   2912c:	eb07 0c00 	add.w	ip, r7, r0
         for (i=0;i<st->channels*st->mode->nbEBands;i++)
   29130:	dd54      	ble.n	291dc <opus_custom_encoder_ctl+0x330>
   29132:	006d      	lsls	r5, r5, #1
   29134:	f108 097c 	add.w	r9, r8, #124	; 0x7c
   29138:	eb08 0105 	add.w	r1, r8, r5
   2913c:	eb01 0309 	add.w	r3, r1, r9
   29140:	f108 027a 	add.w	r2, r8, #122	; 0x7a
   29144:	005b      	lsls	r3, r3, #1
   29146:	4411      	add	r1, r2
   29148:	442a      	add	r2, r5
   2914a:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
   2914e:	444d      	add	r5, r9
   29150:	ea4f 0341 	mov.w	r3, r1, lsl #1
   29154:	bfd4      	ite	le
   29156:	f04f 0901 	movle.w	r9, #1
   2915a:	f04f 0900 	movgt.w	r9, #0
   2915e:	ebb3 0f45 	cmp.w	r3, r5, lsl #1
   29162:	bfb4      	ite	lt
   29164:	464d      	movlt	r5, r9
   29166:	f049 0501 	orrge.w	r5, r9, #1
   2916a:	2d00      	cmp	r5, #0
   2916c:	d05c      	beq.n	29228 <opus_custom_encoder_ctl+0x37c>
   2916e:	2e0f      	cmp	r6, #15
   29170:	d95a      	bls.n	29228 <opus_custom_encoder_ctl+0x37c>
   29172:	4423      	add	r3, r4
   29174:	f3c3 0340 	ubfx	r3, r3, #1, #1
   29178:	2b00      	cmp	r3, #0
   2917a:	d053      	beq.n	29224 <opus_custom_encoder_ctl+0x378>
            oldLogE[i]=oldLogE2[i]=-QCONST16(28.f,DB_SHIFT);
   2917c:	f44f 4910 	mov.w	r9, #36864	; 0x9000
   29180:	f82c 9018 	strh.w	r9, [ip, r8, lsl #1]
   29184:	f827 9000 	strh.w	r9, [r7, r0]
         for (i=0;i<st->channels*st->mode->nbEBands;i++)
   29188:	2501      	movs	r5, #1
   2918a:	4419      	add	r1, r3
   2918c:	441a      	add	r2, r3
   2918e:	1af7      	subs	r7, r6, r3
   29190:	eb04 0141 	add.w	r1, r4, r1, lsl #1
   29194:	eb04 0242 	add.w	r2, r4, r2, lsl #1
   29198:	ea4f 0857 	mov.w	r8, r7, lsr #1
   2919c:	2300      	movs	r3, #0
            oldLogE[i]=oldLogE2[i]=-QCONST16(28.f,DB_SHIFT);
   2919e:	f04f 2090 	mov.w	r0, #2415955968	; 0x90009000
   291a2:	3301      	adds	r3, #1
   291a4:	4598      	cmp	r8, r3
   291a6:	f841 0b04 	str.w	r0, [r1], #4
   291aa:	f842 0b04 	str.w	r0, [r2], #4
   291ae:	d8f8      	bhi.n	291a2 <opus_custom_encoder_ctl+0x2f6>
   291b0:	f027 0301 	bic.w	r3, r7, #1
   291b4:	429f      	cmp	r7, r3
   291b6:	441d      	add	r5, r3
   291b8:	d010      	beq.n	291dc <opus_custom_encoder_ctl+0x330>
         for (i=0;i<st->channels*st->mode->nbEBands;i++)
   291ba:	1c6a      	adds	r2, r5, #1
            oldLogE[i]=oldLogE2[i]=-QCONST16(28.f,DB_SHIFT);
   291bc:	44e6      	add	lr, ip
   291be:	f44f 4310 	mov.w	r3, #36864	; 0x9000
         for (i=0;i<st->channels*st->mode->nbEBands;i++)
   291c2:	4296      	cmp	r6, r2
            oldLogE[i]=oldLogE2[i]=-QCONST16(28.f,DB_SHIFT);
   291c4:	f82e 3015 	strh.w	r3, [lr, r5, lsl #1]
   291c8:	f82c 3015 	strh.w	r3, [ip, r5, lsl #1]
   291cc:	ea4f 0545 	mov.w	r5, r5, lsl #1
         for (i=0;i<st->channels*st->mode->nbEBands;i++)
   291d0:	dd04      	ble.n	291dc <opus_custom_encoder_ctl+0x330>
            oldLogE[i]=oldLogE2[i]=-QCONST16(28.f,DB_SHIFT);
   291d2:	3502      	adds	r5, #2
   291d4:	f82e 3005 	strh.w	r3, [lr, r5]
   291d8:	f82c 3005 	strh.w	r3, [ip, r5]
         st->vbr_offset = 0;
   291dc:	2300      	movs	r3, #0
         st->delayedIntra = 1;
   291de:	2001      	movs	r0, #1
         st->spread_decision = SPREAD_NORMAL;
   291e0:	2102      	movs	r1, #2
         st->tonal_average = 256;
   291e2:	f44f 7280 	mov.w	r2, #256	; 0x100
         st->vbr_offset = 0;
   291e6:	f8c4 30d8 	str.w	r3, [r4, #216]	; 0xd8
         st->tapset_decision = 0;
   291ea:	e9c4 3318 	strd	r3, r3, [r4, #96]	; 0x60
         st->spread_decision = SPREAD_NORMAL;
   291ee:	e9c4 1014 	strd	r1, r0, [r4, #80]	; 0x50
         st->tonal_average = 256;
   291f2:	65a2      	str	r2, [r4, #88]	; 0x58
      break;
   291f4:	e739      	b.n	2906a <opus_custom_encoder_ctl+0x1be>
         st->signalling = value;
   291f6:	681b      	ldr	r3, [r3, #0]
   291f8:	6303      	str	r3, [r0, #48]	; 0x30
      break;
   291fa:	e736      	b.n	2906a <opus_custom_encoder_ctl+0x1be>
          opus_int32 *value = va_arg(ap, opus_int32*);
   291fc:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   291fe:	3304      	adds	r3, #4
   29200:	9301      	str	r3, [sp, #4]
          if (!value)
   29202:	b162      	cbz	r2, 2921e <opus_custom_encoder_ctl+0x372>
          *value = st->disable_inv;
   29204:	6c43      	ldr	r3, [r0, #68]	; 0x44
   29206:	6013      	str	r3, [r2, #0]
      break;
   29208:	e72f      	b.n	2906a <opus_custom_encoder_ctl+0x1be>
         st->constrained_vbr = value;
   2920a:	681b      	ldr	r3, [r3, #0]
   2920c:	6343      	str	r3, [r0, #52]	; 0x34
      break;
   2920e:	e72c      	b.n	2906a <opus_custom_encoder_ctl+0x1be>
         const CELTMode ** value = va_arg(ap, const CELTMode**);
   29210:	681a      	ldr	r2, [r3, #0]
   29212:	3304      	adds	r3, #4
   29214:	9301      	str	r3, [sp, #4]
         if (value==0)
   29216:	b112      	cbz	r2, 2921e <opus_custom_encoder_ctl+0x372>
         *value=st->mode;
   29218:	6803      	ldr	r3, [r0, #0]
   2921a:	6013      	str	r3, [r2, #0]
      break;
   2921c:	e725      	b.n	2906a <opus_custom_encoder_ctl+0x1be>
   return OPUS_BAD_ARG;
   2921e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   29222:	e723      	b.n	2906c <opus_custom_encoder_ctl+0x1c0>
         for (i=0;i<st->channels*st->mode->nbEBands;i++)
   29224:	461d      	mov	r5, r3
   29226:	e7b0      	b.n	2918a <opus_custom_encoder_ctl+0x2de>
   29228:	eb0c 0346 	add.w	r3, ip, r6, lsl #1
   2922c:	f1ae 0202 	sub.w	r2, lr, #2
   29230:	4462      	add	r2, ip
   29232:	3b02      	subs	r3, #2
   29234:	f1ac 0c02 	sub.w	ip, ip, #2
            oldLogE[i]=oldLogE2[i]=-QCONST16(28.f,DB_SHIFT);
   29238:	f44f 4110 	mov.w	r1, #36864	; 0x9000
   2923c:	f822 1f02 	strh.w	r1, [r2, #2]!
   29240:	f82c 1f02 	strh.w	r1, [ip, #2]!
         for (i=0;i<st->channels*st->mode->nbEBands;i++)
   29244:	459c      	cmp	ip, r3
   29246:	d1f9      	bne.n	2923c <opus_custom_encoder_ctl+0x390>
   29248:	e7c8      	b.n	291dc <opus_custom_encoder_ctl+0x330>
   2924a:	bf00      	nop
   2924c:	0003f7a0 	.word	0x0003f7a0

00029250 <celt_encoder_init>:
{
   29250:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   29254:	4615      	mov	r5, r2
   29256:	4604      	mov	r4, r0
   29258:	4688      	mov	r8, r1
           opus_custom_mode_create(48000, 960, NULL), channels, arch);
   2925a:	2200      	movs	r2, #0
   2925c:	f44f 7170 	mov.w	r1, #960	; 0x3c0
   29260:	f64b 3080 	movw	r0, #48000	; 0xbb80
{
   29264:	4699      	mov	r9, r3
           opus_custom_mode_create(48000, 960, NULL), channels, arch);
   29266:	f002 fc1f 	bl	2baa8 <opus_custom_mode_create>
   if (channels < 0 || channels > 2)
   2926a:	2d02      	cmp	r5, #2
   2926c:	d839      	bhi.n	292e2 <celt_encoder_init+0x92>
   if (st==NULL || mode==NULL)
   2926e:	2c00      	cmp	r4, #0
   29270:	d034      	beq.n	292dc <celt_encoder_init+0x8c>
   29272:	4607      	mov	r7, r0
   29274:	b390      	cbz	r0, 292dc <celt_encoder_init+0x8c>
         + 4*channels*mode->nbEBands*sizeof(opus_val16);  /* opus_val16 oldBandE[channels*mode->nbEBands]; */
   29276:	e9d0 1301 	ldrd	r1, r3, [r0, #4]
         + channels*COMBFILTER_MAXPERIOD*sizeof(celt_sig) /* celt_sig prefilter_mem[channels*COMBFILTER_MAXPERIOD]; */
   2927a:	02aa      	lsls	r2, r5, #10
         + 4*channels*mode->nbEBands*sizeof(opus_val16);  /* opus_val16 oldBandE[channels*mode->nbEBands]; */
   2927c:	00a8      	lsls	r0, r5, #2
   2927e:	323d      	adds	r2, #61	; 0x3d
   29280:	fb03 f300 	mul.w	r3, r3, r0
   29284:	fb01 2205 	mla	r2, r1, r5, r2
   29288:	eb03 0242 	add.w	r2, r3, r2, lsl #1
   OPUS_CLEAR((char*)st, opus_custom_encoder_get_size(mode, channels));
   2928c:	0052      	lsls	r2, r2, #1
   2928e:	2100      	movs	r1, #0
   29290:	4620      	mov	r0, r4
   29292:	f00b ff67 	bl	35164 <memset>
   st->end = st->mode->effEBands;
   29296:	68fa      	ldr	r2, [r7, #12]
   29298:	6262      	str	r2, [r4, #36]	; 0x24
   st->upsample = 1;
   2929a:	2301      	movs	r3, #1
   st->start = 0;
   2929c:	2600      	movs	r6, #0
   st->lsb_depth=24;
   2929e:	2218      	movs	r2, #24
   st->bitrate = OPUS_BITRATE_MAX;
   292a0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   st->complexity = 5;
   292a4:	2105      	movs	r1, #5
   st->upsample = 1;
   292a6:	61e3      	str	r3, [r4, #28]
   st->constrained_vbr = 1;
   292a8:	e9c4 330c 	strd	r3, r3, [r4, #48]	; 0x30
   st->clip = 1;
   292ac:	6123      	str	r3, [r4, #16]
   st->bitrate = OPUS_BITRATE_MAX;
   292ae:	62a0      	str	r0, [r4, #40]	; 0x28
   st->complexity = 5;
   292b0:	61a1      	str	r1, [r4, #24]
   st->lsb_depth=24;
   292b2:	63e2      	str	r2, [r4, #60]	; 0x3c
   opus_custom_encoder_ctl(st, OPUS_RESET_STATE);
   292b4:	f640 71bc 	movw	r1, #4028	; 0xfbc
   st->mode = mode;
   292b8:	6027      	str	r7, [r4, #0]
   st->stream_channels = st->channels = channels;
   292ba:	e9c4 5501 	strd	r5, r5, [r4, #4]
   st->arch = arch;
   292be:	f8c4 9048 	str.w	r9, [r4, #72]	; 0x48
   st->start = 0;
   292c2:	6226      	str	r6, [r4, #32]
   st->vbr = 0;
   292c4:	62e6      	str	r6, [r4, #44]	; 0x2c
   st->force_intra  = 0;
   292c6:	60e6      	str	r6, [r4, #12]
   opus_custom_encoder_ctl(st, OPUS_RESET_STATE);
   292c8:	4620      	mov	r0, r4
   292ca:	f7ff fdef 	bl	28eac <opus_custom_encoder_ctl>
   st->upsample = resampling_factor(sampling_rate);
   292ce:	4640      	mov	r0, r8
   292d0:	f7fa fbce 	bl	23a70 <resampling_factor>
   292d4:	61e0      	str	r0, [r4, #28]
}
   292d6:	4630      	mov	r0, r6
   292d8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      return OPUS_ALLOC_FAIL;
   292dc:	f06f 0606 	mvn.w	r6, #6
   292e0:	e7f9      	b.n	292d6 <celt_encoder_init+0x86>
      return OPUS_BAD_ARG;
   292e2:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   292e6:	e7f6      	b.n	292d6 <celt_encoder_init+0x86>

000292e8 <encode_pulses>:
  }
  while(j>0);
  return i;
}

void encode_pulses(const int *_y,int _n,int _k,ec_enc *_enc){
   292e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  j=_n-1;
   292ec:	1e4e      	subs	r6, r1, #1
   292ee:	f101 4980 	add.w	r9, r1, #1073741824	; 0x40000000
  i=_y[j]<0;
   292f2:	f850 5026 	ldr.w	r5, [r0, r6, lsl #2]
   292f6:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 293ac <encode_pulses+0xc4>
   292fa:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
   292fe:	ea4f 0989 	mov.w	r9, r9, lsl #2
  k=abs(_y[j]);
   29302:	2d00      	cmp	r5, #0
void encode_pulses(const int *_y,int _n,int _k,ec_enc *_enc){
   29304:	468a      	mov	sl, r1
   29306:	469b      	mov	fp, r3
  i=_y[j]<0;
   29308:	ea4f 71d5 	mov.w	r1, r5, lsr #31
   2930c:	eb00 0c09 	add.w	ip, r0, r9
  k=abs(_y[j]);
   29310:	bfb8      	it	lt
   29312:	426d      	neglt	r5, r5
   29314:	2402      	movs	r4, #2
    i+=CELT_PVQ_U(_n-j,k);
   29316:	42ac      	cmp	r4, r5
   29318:	4623      	mov	r3, r4
   2931a:	bfa8      	it	ge
   2931c:	462b      	movge	r3, r5
   2931e:	42ac      	cmp	r4, r5
   29320:	f858 0023 	ldr.w	r0, [r8, r3, lsl #2]
    k+=abs(_y[j]);
   29324:	f85c 7d04 	ldr.w	r7, [ip, #-4]!
    i+=CELT_PVQ_U(_n-j,k);
   29328:	bfd4      	ite	le
   2932a:	00ab      	lslle	r3, r5, #2
   2932c:	00a3      	lslgt	r3, r4, #2
    k+=abs(_y[j]);
   2932e:	ea87 7ee7 	eor.w	lr, r7, r7, asr #31
    i+=CELT_PVQ_U(_n-j,k);
   29332:	58c3      	ldr	r3, [r0, r3]
    k+=abs(_y[j]);
   29334:	ebae 7ee7 	sub.w	lr, lr, r7, asr #31
    if(_y[j]<0)i+=CELT_PVQ_U(_n-j,k+1);
   29338:	2f00      	cmp	r7, #0
    j--;
   2933a:	f106 36ff 	add.w	r6, r6, #4294967295	; 0xffffffff
    i+=CELT_PVQ_U(_n-j,k);
   2933e:	4419      	add	r1, r3
    k+=abs(_y[j]);
   29340:	4475      	add	r5, lr
    if(_y[j]<0)i+=CELT_PVQ_U(_n-j,k+1);
   29342:	da0d      	bge.n	29360 <encode_pulses+0x78>
   29344:	1c6b      	adds	r3, r5, #1
   29346:	42ac      	cmp	r4, r5
   29348:	bfd4      	ite	le
   2934a:	4627      	movle	r7, r4
   2934c:	461f      	movgt	r7, r3
   2934e:	429c      	cmp	r4, r3
   29350:	ea4f 0084 	mov.w	r0, r4, lsl #2
   29354:	f858 7027 	ldr.w	r7, [r8, r7, lsl #2]
   29358:	bfd8      	it	le
   2935a:	0098      	lslle	r0, r3, #2
   2935c:	583b      	ldr	r3, [r7, r0]
   2935e:	4419      	add	r1, r3
  while(j>0);
   29360:	2e00      	cmp	r6, #0
   29362:	f104 0401 	add.w	r4, r4, #1
   29366:	dcd6      	bgt.n	29316 <encode_pulses+0x2e>
  celt_assert(_k>0);
  ec_enc_uint(_enc,icwrs(_n,_y),CELT_PVQ_V(_n,_k));
   29368:	4592      	cmp	sl, r2
   2936a:	4653      	mov	r3, sl
   2936c:	bfa8      	it	ge
   2936e:	4613      	movge	r3, r2
   29370:	4592      	cmp	sl, r2
   29372:	f102 0001 	add.w	r0, r2, #1
   29376:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
   2937a:	dd12      	ble.n	293a2 <encode_pulses+0xba>
   2937c:	444b      	add	r3, r9
   2937e:	4604      	mov	r4, r0
   29380:	685a      	ldr	r2, [r3, #4]
   29382:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
   29386:	4582      	cmp	sl, r0
   29388:	bfd4      	ite	le
   2938a:	ea4f 0980 	movle.w	r9, r0, lsl #2
   2938e:	f109 0904 	addgt.w	r9, r9, #4
   29392:	4658      	mov	r0, fp
   29394:	f853 3009 	ldr.w	r3, [r3, r9]
}
   29398:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  ec_enc_uint(_enc,icwrs(_n,_y),CELT_PVQ_V(_n,_k));
   2939c:	441a      	add	r2, r3
   2939e:	f000 bde1 	b.w	29f64 <ec_enc_uint>
   293a2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
   293a6:	4654      	mov	r4, sl
   293a8:	e7eb      	b.n	29382 <encode_pulses+0x9a>
   293aa:	bf00      	nop
   293ac:	00038e5c 	.word	0x00038e5c

000293b0 <decode_pulses>:
  *_y=val;
  yy=MAC16_16(yy,val,val);
  return yy;
}

opus_val32 decode_pulses(int *_y,int _n,int _k,ec_dec *_dec){
   293b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  return cwrsi(_n,_k,ec_dec_uint(_dec,CELT_PVQ_V(_n,_k)),_y);
   293b4:	428a      	cmp	r2, r1
opus_val32 decode_pulses(int *_y,int _n,int _k,ec_dec *_dec){
   293b6:	4614      	mov	r4, r2
  return cwrsi(_n,_k,ec_dec_uint(_dec,CELT_PVQ_V(_n,_k)),_y);
   293b8:	f8df 836c 	ldr.w	r8, [pc, #876]	; 29728 <decode_pulses+0x378>
   293bc:	bfa8      	it	ge
   293be:	460a      	movge	r2, r1
opus_val32 decode_pulses(int *_y,int _n,int _k,ec_dec *_dec){
   293c0:	460d      	mov	r5, r1
  return cwrsi(_n,_k,ec_dec_uint(_dec,CELT_PVQ_V(_n,_k)),_y);
   293c2:	f858 2022 	ldr.w	r2, [r8, r2, lsl #2]
   293c6:	428c      	cmp	r4, r1
   293c8:	f104 0901 	add.w	r9, r4, #1
   293cc:	bfb5      	itete	lt
   293ce:	f852 1021 	ldrlt.w	r1, [r2, r1, lsl #2]
   293d2:	f852 1024 	ldrge.w	r1, [r2, r4, lsl #2]
   293d6:	464a      	movlt	r2, r9
   293d8:	462a      	movge	r2, r5
opus_val32 decode_pulses(int *_y,int _n,int _k,ec_dec *_dec){
   293da:	b083      	sub	sp, #12
  return cwrsi(_n,_k,ec_dec_uint(_dec,CELT_PVQ_V(_n,_k)),_y);
   293dc:	454d      	cmp	r5, r9
opus_val32 decode_pulses(int *_y,int _n,int _k,ec_dec *_dec){
   293de:	9000      	str	r0, [sp, #0]
  return cwrsi(_n,_k,ec_dec_uint(_dec,CELT_PVQ_V(_n,_k)),_y);
   293e0:	f858 0022 	ldr.w	r0, [r8, r2, lsl #2]
   293e4:	bfd4      	ite	le
   293e6:	ea4f 0289 	movle.w	r2, r9, lsl #2
   293ea:	00aa      	lslgt	r2, r5, #2
   293ec:	5882      	ldr	r2, [r0, r2]
   293ee:	4618      	mov	r0, r3
   293f0:	4411      	add	r1, r2
   293f2:	f000 fa85 	bl	29900 <ec_dec_uint>
  while(_n>2){
   293f6:	2d02      	cmp	r5, #2
   293f8:	f340 8185 	ble.w	29706 <decode_pulses+0x356>
   293fc:	f8dd e000 	ldr.w	lr, [sp]
   29400:	00ab      	lsls	r3, r5, #2
    if(_k>=_n){
   29402:	42a5      	cmp	r5, r4
   29404:	9301      	str	r3, [sp, #4]
  opus_val32  yy=0;
   29406:	f04f 0b00 	mov.w	fp, #0
   2940a:	f10e 0e04 	add.w	lr, lr, #4
   2940e:	f105 31ff 	add.w	r1, r5, #4294967295	; 0xffffffff
   29412:	fa1f fc84 	uxth.w	ip, r4
    if(_k>=_n){
   29416:	f300 80b5 	bgt.w	29584 <decode_pulses+0x1d4>
      row=CELT_PVQ_U_ROW[_n];
   2941a:	f858 7003 	ldr.w	r7, [r8, r3]
      p=row[_k+1];
   2941e:	f857 2029 	ldr.w	r2, [r7, r9, lsl #2]
      s=-(_i>=p);
   29422:	4282      	cmp	r2, r0
   29424:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   29428:	bf88      	it	hi
   2942a:	2600      	movhi	r6, #0
      _i-=p&s;
   2942c:	ea06 0a02 	and.w	sl, r6, r2
      if(q>_i){
   29430:	58fa      	ldr	r2, [r7, r3]
      _i-=p&s;
   29432:	eba0 000a 	sub.w	r0, r0, sl
      if(q>_i){
   29436:	4290      	cmp	r0, r2
   29438:	eb0c 0a06 	add.w	sl, ip, r6
      p=row[_k+1];
   2943c:	ea4f 0989 	mov.w	r9, r9, lsl #2
   29440:	fa1f fa8a 	uxth.w	sl, sl
   29444:	b236      	sxth	r6, r6
      if(q>_i){
   29446:	d272      	bcs.n	2952e <decode_pulses+0x17e>
   29448:	eb08 0203 	add.w	r2, r8, r3
        do p=CELT_PVQ_U_ROW[--_k][_n];
   2944c:	f852 4c04 	ldr.w	r4, [r2, #-4]
   29450:	58e7      	ldr	r7, [r4, r3]
        while(p>_i);
   29452:	4287      	cmp	r7, r0
   29454:	f240 814a 	bls.w	296ec <decode_pulses+0x33c>
        do p=CELT_PVQ_U_ROW[--_k][_n];
   29458:	f852 4c08 	ldr.w	r4, [r2, #-8]
   2945c:	58e7      	ldr	r7, [r4, r3]
        while(p>_i);
   2945e:	42b8      	cmp	r0, r7
   29460:	f101 34ff 	add.w	r4, r1, #4294967295	; 0xffffffff
   29464:	d272      	bcs.n	2954c <decode_pulses+0x19c>
        do p=CELT_PVQ_U_ROW[--_k][_n];
   29466:	f852 4c0c 	ldr.w	r4, [r2, #-12]
   2946a:	58e7      	ldr	r7, [r4, r3]
        while(p>_i);
   2946c:	42b8      	cmp	r0, r7
   2946e:	f1a5 0403 	sub.w	r4, r5, #3
   29472:	d26b      	bcs.n	2954c <decode_pulses+0x19c>
        do p=CELT_PVQ_U_ROW[--_k][_n];
   29474:	f852 4c10 	ldr.w	r4, [r2, #-16]
   29478:	58e7      	ldr	r7, [r4, r3]
        while(p>_i);
   2947a:	42b8      	cmp	r0, r7
   2947c:	f1a5 0404 	sub.w	r4, r5, #4
   29480:	d264      	bcs.n	2954c <decode_pulses+0x19c>
        do p=CELT_PVQ_U_ROW[--_k][_n];
   29482:	f852 4c14 	ldr.w	r4, [r2, #-20]
   29486:	58e7      	ldr	r7, [r4, r3]
        while(p>_i);
   29488:	42b8      	cmp	r0, r7
   2948a:	f1a5 0405 	sub.w	r4, r5, #5
   2948e:	d25d      	bcs.n	2954c <decode_pulses+0x19c>
        do p=CELT_PVQ_U_ROW[--_k][_n];
   29490:	f852 4c18 	ldr.w	r4, [r2, #-24]
   29494:	58e7      	ldr	r7, [r4, r3]
        while(p>_i);
   29496:	42b8      	cmp	r0, r7
   29498:	f1a5 0406 	sub.w	r4, r5, #6
   2949c:	d256      	bcs.n	2954c <decode_pulses+0x19c>
        do p=CELT_PVQ_U_ROW[--_k][_n];
   2949e:	f852 4c1c 	ldr.w	r4, [r2, #-28]
   294a2:	58e7      	ldr	r7, [r4, r3]
        while(p>_i);
   294a4:	42b8      	cmp	r0, r7
   294a6:	f1a5 0407 	sub.w	r4, r5, #7
   294aa:	d24f      	bcs.n	2954c <decode_pulses+0x19c>
        do p=CELT_PVQ_U_ROW[--_k][_n];
   294ac:	f852 4c20 	ldr.w	r4, [r2, #-32]
   294b0:	58e7      	ldr	r7, [r4, r3]
        while(p>_i);
   294b2:	42b8      	cmp	r0, r7
   294b4:	f1a5 0408 	sub.w	r4, r5, #8
   294b8:	f080 812a 	bcs.w	29710 <decode_pulses+0x360>
        do p=CELT_PVQ_U_ROW[--_k][_n];
   294bc:	f852 4c24 	ldr.w	r4, [r2, #-36]
   294c0:	58e7      	ldr	r7, [r4, r3]
        while(p>_i);
   294c2:	42b8      	cmp	r0, r7
   294c4:	f1a1 0408 	sub.w	r4, r1, #8
   294c8:	d240      	bcs.n	2954c <decode_pulses+0x19c>
        do p=CELT_PVQ_U_ROW[--_k][_n];
   294ca:	f852 4c28 	ldr.w	r4, [r2, #-40]
   294ce:	58e7      	ldr	r7, [r4, r3]
        while(p>_i);
   294d0:	42b8      	cmp	r0, r7
   294d2:	f1a1 0409 	sub.w	r4, r1, #9
   294d6:	d239      	bcs.n	2954c <decode_pulses+0x19c>
        do p=CELT_PVQ_U_ROW[--_k][_n];
   294d8:	f852 4c2c 	ldr.w	r4, [r2, #-44]
   294dc:	58e7      	ldr	r7, [r4, r3]
        while(p>_i);
   294de:	42b8      	cmp	r0, r7
   294e0:	f1a1 040a 	sub.w	r4, r1, #10
   294e4:	d232      	bcs.n	2954c <decode_pulses+0x19c>
        do p=CELT_PVQ_U_ROW[--_k][_n];
   294e6:	f852 4c30 	ldr.w	r4, [r2, #-48]
   294ea:	58e7      	ldr	r7, [r4, r3]
        while(p>_i);
   294ec:	42b8      	cmp	r0, r7
   294ee:	f1a1 040b 	sub.w	r4, r1, #11
   294f2:	d22b      	bcs.n	2954c <decode_pulses+0x19c>
        do p=CELT_PVQ_U_ROW[--_k][_n];
   294f4:	f852 4c34 	ldr.w	r4, [r2, #-52]
   294f8:	58e7      	ldr	r7, [r4, r3]
        while(p>_i);
   294fa:	42b8      	cmp	r0, r7
   294fc:	f1a1 040c 	sub.w	r4, r1, #12
   29500:	d224      	bcs.n	2954c <decode_pulses+0x19c>
        do p=CELT_PVQ_U_ROW[--_k][_n];
   29502:	f852 4c38 	ldr.w	r4, [r2, #-56]
   29506:	58e7      	ldr	r7, [r4, r3]
        while(p>_i);
   29508:	42b8      	cmp	r0, r7
   2950a:	f1a1 040d 	sub.w	r4, r1, #13
   2950e:	d21d      	bcs.n	2954c <decode_pulses+0x19c>
   29510:	f1a1 040e 	sub.w	r4, r1, #14
   29514:	fa1f fc84 	uxth.w	ip, r4
   29518:	ebaa 0a0c 	sub.w	sl, sl, ip
        do p=CELT_PVQ_U_ROW[--_k][_n];
   2951c:	f852 2c3c 	ldr.w	r2, [r2, #-60]
   29520:	ea86 060a 	eor.w	r6, r6, sl
   29524:	b236      	sxth	r6, r6
   29526:	58d7      	ldr	r7, [r2, r3]
   29528:	fb06 bb06 	mla	fp, r6, r6, fp
   2952c:	e017      	b.n	2955e <decode_pulses+0x1ae>
      else for(p=row[_k];p>_i;p=row[_k])_k--;
   2952e:	f1a9 0904 	sub.w	r9, r9, #4
   29532:	eb07 0209 	add.w	r2, r7, r9
   29536:	f857 7009 	ldr.w	r7, [r7, r9]
   2953a:	42b8      	cmp	r0, r7
   2953c:	f080 80e1 	bcs.w	29702 <decode_pulses+0x352>
   29540:	f852 7d04 	ldr.w	r7, [r2, #-4]!
   29544:	42b8      	cmp	r0, r7
   29546:	f104 34ff 	add.w	r4, r4, #4294967295	; 0xffffffff
   2954a:	d3f9      	bcc.n	29540 <decode_pulses+0x190>
   2954c:	fa1f fc84 	uxth.w	ip, r4
   29550:	ebaa 0a0c 	sub.w	sl, sl, ip
   29554:	ea86 060a 	eor.w	r6, r6, sl
   29558:	b236      	sxth	r6, r6
   2955a:	fb06 bb06 	mla	fp, r6, r6, fp
      _i-=p;
   2955e:	1bc0      	subs	r0, r0, r7
      *_y++=val;
   29560:	f84e 6c04 	str.w	r6, [lr, #-4]
  while(_n>2){
   29564:	2902      	cmp	r1, #2
   29566:	f1a3 0304 	sub.w	r3, r3, #4
   2956a:	460d      	mov	r5, r1
   2956c:	d01e      	beq.n	295ac <decode_pulses+0x1fc>
    if(_k>=_n){
   2956e:	42a5      	cmp	r5, r4
   29570:	f104 0901 	add.w	r9, r4, #1
   29574:	f10e 0e04 	add.w	lr, lr, #4
   29578:	f105 31ff 	add.w	r1, r5, #4294967295	; 0xffffffff
   2957c:	fa1f fc84 	uxth.w	ip, r4
   29580:	f77f af4b 	ble.w	2941a <decode_pulses+0x6a>
      p=CELT_PVQ_U_ROW[_k][_n];
   29584:	f858 2024 	ldr.w	r2, [r8, r4, lsl #2]
      q=CELT_PVQ_U_ROW[_k+1][_n];
   29588:	f858 5029 	ldr.w	r5, [r8, r9, lsl #2]
      p=CELT_PVQ_U_ROW[_k][_n];
   2958c:	58d2      	ldr	r2, [r2, r3]
      q=CELT_PVQ_U_ROW[_k+1][_n];
   2958e:	58ee      	ldr	r6, [r5, r3]
      if(p<=_i&&_i<q){
   29590:	4282      	cmp	r2, r0
   29592:	d833      	bhi.n	295fc <decode_pulses+0x24c>
   29594:	4286      	cmp	r6, r0
   29596:	d931      	bls.n	295fc <decode_pulses+0x24c>
        _i-=p;
   29598:	1a80      	subs	r0, r0, r2
  while(_n>2){
   2959a:	2902      	cmp	r1, #2
        *_y++=0;
   2959c:	f04f 0200 	mov.w	r2, #0
   295a0:	f84e 2c04 	str.w	r2, [lr, #-4]
   295a4:	f1a3 0304 	sub.w	r3, r3, #4
   295a8:	460d      	mov	r5, r1
  while(_n>2){
   295aa:	d1e0      	bne.n	2956e <decode_pulses+0x1be>
   295ac:	9b01      	ldr	r3, [sp, #4]
   295ae:	9a00      	ldr	r2, [sp, #0]
   295b0:	3b08      	subs	r3, #8
   295b2:	441a      	add	r2, r3
   295b4:	9200      	str	r2, [sp, #0]
  p=2*_k+1;
   295b6:	0064      	lsls	r4, r4, #1
   295b8:	3401      	adds	r4, #1
  s=-(_i>=p);
   295ba:	4284      	cmp	r4, r0
   295bc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   295c0:	bf88      	it	hi
   295c2:	2200      	movhi	r2, #0
  _i-=p&s;
   295c4:	4014      	ands	r4, r2
   295c6:	1b00      	subs	r0, r0, r4
  _k=(_i+1)>>1;
   295c8:	1c41      	adds	r1, r0, #1
  if(_k)_i-=2*_k-1;
   295ca:	084b      	lsrs	r3, r1, #1
   295cc:	bf18      	it	ne
   295ce:	eba1 0043 	subne.w	r0, r1, r3, lsl #1
  val=(k0-_k+s)^s;
   295d2:	4494      	add	ip, r2
   295d4:	b29b      	uxth	r3, r3
   295d6:	ebac 0c03 	sub.w	ip, ip, r3
  s=-(int)_i;
   295da:	4240      	negs	r0, r0
  val=(k0-_k+s)^s;
   295dc:	ea82 020c 	eor.w	r2, r2, ip
  val=(_k+s)^s;
   295e0:	4403      	add	r3, r0
  val=(k0-_k+s)^s;
   295e2:	b212      	sxth	r2, r2
  val=(_k+s)^s;
   295e4:	4058      	eors	r0, r3
   295e6:	b203      	sxth	r3, r0
  *_y++=val;
   295e8:	9900      	ldr	r1, [sp, #0]
  yy=MAC16_16(yy,val,val);
   295ea:	fb02 bb02 	mla	fp, r2, r2, fp
}
   295ee:	fb03 b003 	mla	r0, r3, r3, fp
  *_y++=val;
   295f2:	600a      	str	r2, [r1, #0]
  *_y=val;
   295f4:	604b      	str	r3, [r1, #4]
}
   295f6:	b003      	add	sp, #12
   295f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        do p=CELT_PVQ_U_ROW[--_k][_n];
   295fc:	1e67      	subs	r7, r4, #1
        s=-(_i>=q);
   295fe:	4286      	cmp	r6, r0
        do p=CELT_PVQ_U_ROW[--_k][_n];
   29600:	f858 5027 	ldr.w	r5, [r8, r7, lsl #2]
        s=-(_i>=q);
   29604:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   29608:	bf88      	it	hi
   2960a:	2200      	movhi	r2, #0
        _i-=q&s;
   2960c:	4016      	ands	r6, r2
        do p=CELT_PVQ_U_ROW[--_k][_n];
   2960e:	58ed      	ldr	r5, [r5, r3]
        _i-=q&s;
   29610:	1b80      	subs	r0, r0, r6
        while(p>_i);
   29612:	42a8      	cmp	r0, r5
   29614:	d268      	bcs.n	296e8 <decode_pulses+0x338>
        do p=CELT_PVQ_U_ROW[--_k][_n];
   29616:	1ea6      	subs	r6, r4, #2
   29618:	f858 5026 	ldr.w	r5, [r8, r6, lsl #2]
   2961c:	58ed      	ldr	r5, [r5, r3]
        while(p>_i);
   2961e:	42a8      	cmp	r0, r5
   29620:	d253      	bcs.n	296ca <decode_pulses+0x31a>
        do p=CELT_PVQ_U_ROW[--_k][_n];
   29622:	1ee6      	subs	r6, r4, #3
   29624:	f858 5026 	ldr.w	r5, [r8, r6, lsl #2]
   29628:	58ed      	ldr	r5, [r5, r3]
        while(p>_i);
   2962a:	42a8      	cmp	r0, r5
   2962c:	d24d      	bcs.n	296ca <decode_pulses+0x31a>
        do p=CELT_PVQ_U_ROW[--_k][_n];
   2962e:	1f26      	subs	r6, r4, #4
   29630:	f858 5026 	ldr.w	r5, [r8, r6, lsl #2]
   29634:	58ed      	ldr	r5, [r5, r3]
        while(p>_i);
   29636:	42a8      	cmp	r0, r5
   29638:	d247      	bcs.n	296ca <decode_pulses+0x31a>
        do p=CELT_PVQ_U_ROW[--_k][_n];
   2963a:	1f66      	subs	r6, r4, #5
   2963c:	f858 5026 	ldr.w	r5, [r8, r6, lsl #2]
   29640:	58ed      	ldr	r5, [r5, r3]
        while(p>_i);
   29642:	42a8      	cmp	r0, r5
   29644:	d241      	bcs.n	296ca <decode_pulses+0x31a>
        do p=CELT_PVQ_U_ROW[--_k][_n];
   29646:	1fa6      	subs	r6, r4, #6
   29648:	f858 5026 	ldr.w	r5, [r8, r6, lsl #2]
   2964c:	58ed      	ldr	r5, [r5, r3]
        while(p>_i);
   2964e:	42a8      	cmp	r0, r5
   29650:	d23b      	bcs.n	296ca <decode_pulses+0x31a>
        do p=CELT_PVQ_U_ROW[--_k][_n];
   29652:	1fe6      	subs	r6, r4, #7
   29654:	f858 5026 	ldr.w	r5, [r8, r6, lsl #2]
   29658:	58ed      	ldr	r5, [r5, r3]
        while(p>_i);
   2965a:	42a8      	cmp	r0, r5
   2965c:	d235      	bcs.n	296ca <decode_pulses+0x31a>
        do p=CELT_PVQ_U_ROW[--_k][_n];
   2965e:	f1a4 0608 	sub.w	r6, r4, #8
   29662:	f858 5026 	ldr.w	r5, [r8, r6, lsl #2]
   29666:	58ed      	ldr	r5, [r5, r3]
        while(p>_i);
   29668:	42a8      	cmp	r0, r5
   2966a:	d22e      	bcs.n	296ca <decode_pulses+0x31a>
        do p=CELT_PVQ_U_ROW[--_k][_n];
   2966c:	f1a4 0609 	sub.w	r6, r4, #9
   29670:	f858 5026 	ldr.w	r5, [r8, r6, lsl #2]
   29674:	58ed      	ldr	r5, [r5, r3]
        while(p>_i);
   29676:	42a8      	cmp	r0, r5
   29678:	d227      	bcs.n	296ca <decode_pulses+0x31a>
        do p=CELT_PVQ_U_ROW[--_k][_n];
   2967a:	f1a4 060a 	sub.w	r6, r4, #10
   2967e:	f858 5026 	ldr.w	r5, [r8, r6, lsl #2]
   29682:	58ed      	ldr	r5, [r5, r3]
        while(p>_i);
   29684:	42a8      	cmp	r0, r5
   29686:	d220      	bcs.n	296ca <decode_pulses+0x31a>
        do p=CELT_PVQ_U_ROW[--_k][_n];
   29688:	f1a4 060b 	sub.w	r6, r4, #11
   2968c:	f858 5026 	ldr.w	r5, [r8, r6, lsl #2]
   29690:	58ed      	ldr	r5, [r5, r3]
        while(p>_i);
   29692:	42a8      	cmp	r0, r5
   29694:	d219      	bcs.n	296ca <decode_pulses+0x31a>
        do p=CELT_PVQ_U_ROW[--_k][_n];
   29696:	f1a4 060c 	sub.w	r6, r4, #12
   2969a:	f858 5026 	ldr.w	r5, [r8, r6, lsl #2]
   2969e:	58ed      	ldr	r5, [r5, r3]
        while(p>_i);
   296a0:	42a8      	cmp	r0, r5
   296a2:	d212      	bcs.n	296ca <decode_pulses+0x31a>
        do p=CELT_PVQ_U_ROW[--_k][_n];
   296a4:	f1a4 060d 	sub.w	r6, r4, #13
   296a8:	f858 5026 	ldr.w	r5, [r8, r6, lsl #2]
   296ac:	58ed      	ldr	r5, [r5, r3]
        while(p>_i);
   296ae:	42a8      	cmp	r0, r5
   296b0:	d20b      	bcs.n	296ca <decode_pulses+0x31a>
        do p=CELT_PVQ_U_ROW[--_k][_n];
   296b2:	f1a4 060e 	sub.w	r6, r4, #14
   296b6:	f858 5026 	ldr.w	r5, [r8, r6, lsl #2]
   296ba:	58ed      	ldr	r5, [r5, r3]
        while(p>_i);
   296bc:	42a8      	cmp	r0, r5
   296be:	d204      	bcs.n	296ca <decode_pulses+0x31a>
        do p=CELT_PVQ_U_ROW[--_k][_n];
   296c0:	3c0f      	subs	r4, #15
   296c2:	f858 5024 	ldr.w	r5, [r8, r4, lsl #2]
   296c6:	58ed      	ldr	r5, [r5, r3]
   296c8:	e000      	b.n	296cc <decode_pulses+0x31c>
   296ca:	4634      	mov	r4, r6
        val=(k0-_k+s)^s;
   296cc:	eb0c 0602 	add.w	r6, ip, r2
   296d0:	fa1f fc84 	uxth.w	ip, r4
   296d4:	eba6 060c 	sub.w	r6, r6, ip
   296d8:	4072      	eors	r2, r6
   296da:	b212      	sxth	r2, r2
        _i-=p;
   296dc:	1b40      	subs	r0, r0, r5
        *_y++=val;
   296de:	f84e 2c04 	str.w	r2, [lr, #-4]
        yy=MAC16_16(yy,val,val);
   296e2:	fb02 bb02 	mla	fp, r2, r2, fp
   296e6:	e73d      	b.n	29564 <decode_pulses+0x1b4>
        do p=CELT_PVQ_U_ROW[--_k][_n];
   296e8:	463c      	mov	r4, r7
   296ea:	e7ef      	b.n	296cc <decode_pulses+0x31c>
   296ec:	fa1f fc81 	uxth.w	ip, r1
   296f0:	ebaa 0a0c 	sub.w	sl, sl, ip
   296f4:	ea86 060a 	eor.w	r6, r6, sl
   296f8:	b236      	sxth	r6, r6
   296fa:	fb06 bb06 	mla	fp, r6, r6, fp
        while(p>_i);
   296fe:	460c      	mov	r4, r1
   29700:	e72d      	b.n	2955e <decode_pulses+0x1ae>
      else for(p=row[_k];p>_i;p=row[_k])_k--;
   29702:	2600      	movs	r6, #0
   29704:	e72b      	b.n	2955e <decode_pulses+0x1ae>
   29706:	fa1f fc84 	uxth.w	ip, r4
  opus_val32  yy=0;
   2970a:	f04f 0b00 	mov.w	fp, #0
   2970e:	e752      	b.n	295b6 <decode_pulses+0x206>
   29710:	f1a1 0c07 	sub.w	ip, r1, #7
   29714:	fa1f fc8c 	uxth.w	ip, ip
   29718:	ebaa 0a0c 	sub.w	sl, sl, ip
   2971c:	ea86 060a 	eor.w	r6, r6, sl
   29720:	b236      	sxth	r6, r6
   29722:	fb06 bb06 	mla	fp, r6, r6, fp
   29726:	e71a      	b.n	2955e <decode_pulses+0x1ae>
   29728:	00038e5c 	.word	0x00038e5c

0002972c <ec_tell_frac>:
  opus_uint32 nbits;
  opus_uint32 r;
  int         l;
  unsigned    b;
  nbits=_this->nbits_total<<BITRES;
  l=EC_ILOG(_this->rng);
   2972c:	69c2      	ldr	r2, [r0, #28]
  nbits=_this->nbits_total<<BITRES;
   2972e:	6940      	ldr	r0, [r0, #20]
  l=EC_ILOG(_this->rng);
   29730:	fab2 f382 	clz	r3, r2
  r=_this->rng>>(l-16);
   29734:	f1c3 0110 	rsb	r1, r3, #16
   29738:	40ca      	lsrs	r2, r1
  b = (r>>12)-8;
   2973a:	0b11      	lsrs	r1, r2, #12
opus_uint32 ec_tell_frac(ec_ctx *_this){
   2973c:	b410      	push	{r4}
  b = (r>>12)-8;
   2973e:	3908      	subs	r1, #8
  b += r>correction[b];
   29740:	4c07      	ldr	r4, [pc, #28]	; (29760 <ec_tell_frac+0x34>)
  l=EC_ILOG(_this->rng);
   29742:	f1c3 0320 	rsb	r3, r3, #32
  l = (l<<3)+b;
   29746:	00db      	lsls	r3, r3, #3
  return nbits-l;
   29748:	ebc3 03c0 	rsb	r3, r3, r0, lsl #3
  b += r>correction[b];
   2974c:	f854 0021 	ldr.w	r0, [r4, r1, lsl #2]
}
   29750:	f85d 4b04 	ldr.w	r4, [sp], #4
  return nbits-l;
   29754:	1a5b      	subs	r3, r3, r1
}
   29756:	4290      	cmp	r0, r2
   29758:	bf2c      	ite	cs
   2975a:	4618      	movcs	r0, r3
   2975c:	1e58      	subcc	r0, r3, #1
   2975e:	4770      	bx	lr
   29760:	0003909c 	.word	0x0003909c

00029764 <ec_decode>:
   if (d>256)
   29764:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
  _this->error=0;
  /*Normalize the interval.*/
  ec_dec_normalize(_this);
}

unsigned ec_decode(ec_dec *_this,unsigned _ft){
   29768:	b470      	push	{r4, r5, r6}
  unsigned s;
  _this->ext=celt_udiv(_this->rng,_ft);
   2976a:	69c4      	ldr	r4, [r0, #28]
   2976c:	d822      	bhi.n	297b4 <ec_decode+0x50>
      t = EC_ILOG(d&-d);
   2976e:	424a      	negs	r2, r1
   29770:	400a      	ands	r2, r1
   29772:	fab2 f282 	clz	r2, r2
   29776:	f1c2 0220 	rsb	r2, r2, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   2977a:	fa21 f502 	lsr.w	r5, r1, r2
   2977e:	4b0f      	ldr	r3, [pc, #60]	; (297bc <ec_decode+0x58>)
   29780:	3a01      	subs	r2, #1
   29782:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
   29786:	fa24 f202 	lsr.w	r2, r4, r2
   2978a:	fba2 5603 	umull	r5, r6, r2, r3
      return q+(n-q*d >= d);
   2978e:	fb01 4216 	mls	r2, r1, r6, r4
   29792:	4291      	cmp	r1, r2
   29794:	bf8c      	ite	hi
   29796:	4632      	movhi	r2, r6
   29798:	1c72      	addls	r2, r6, #1
  s=(unsigned)(_this->val/_this->ext);
  return _ft-EC_MINI(s+1,_ft);
   2979a:	1e4c      	subs	r4, r1, #1
  s=(unsigned)(_this->val/_this->ext);
   2979c:	6a03      	ldr	r3, [r0, #32]
   2979e:	fbb3 f3f2 	udiv	r3, r3, r2
  return _ft-EC_MINI(s+1,_ft);
   297a2:	1ae4      	subs	r4, r4, r3
   297a4:	3301      	adds	r3, #1
  _this->ext=celt_udiv(_this->rng,_ft);
   297a6:	6242      	str	r2, [r0, #36]	; 0x24
}
   297a8:	428b      	cmp	r3, r1
   297aa:	bf94      	ite	ls
   297ac:	4620      	movls	r0, r4
   297ae:	2000      	movhi	r0, #0
   297b0:	bc70      	pop	{r4, r5, r6}
   297b2:	4770      	bx	lr
      return n/d;
   297b4:	fbb4 f2f1 	udiv	r2, r4, r1
   297b8:	e7ef      	b.n	2979a <ec_decode+0x36>
   297ba:	bf00      	nop
   297bc:	00038e98 	.word	0x00038e98

000297c0 <ec_dec_update>:
   _this->ext=_this->rng>>_bits;
   s=(unsigned)(_this->val/_this->ext);
   return (1U<<_bits)-EC_MINI(s+1U,1U<<_bits);
}

void ec_dec_update(ec_dec *_this,unsigned _fl,unsigned _fh,unsigned _ft){
   297c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  opus_uint32 s;
  s=IMUL32(_this->ext,_ft-_fh);
  _this->val-=s;
   297c4:	e9d0 4508 	ldrd	r4, r5, [r0, #32]
  s=IMUL32(_this->ext,_ft-_fh);
   297c8:	1a9b      	subs	r3, r3, r2
   297ca:	fb05 f303 	mul.w	r3, r5, r3
  _this->val-=s;
   297ce:	1ae4      	subs	r4, r4, r3
   297d0:	6204      	str	r4, [r0, #32]
  _this->rng=_fl>0?IMUL32(_this->ext,_fh-_fl):_this->rng-s;
   297d2:	2900      	cmp	r1, #0
   297d4:	d13f      	bne.n	29856 <ec_dec_update+0x96>
   297d6:	69c2      	ldr	r2, [r0, #28]
   297d8:	1ad2      	subs	r2, r2, r3
  while(_this->rng<=EC_CODE_BOT){
   297da:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
  _this->rng=_fl>0?IMUL32(_this->ext,_fh-_fl):_this->rng-s;
   297de:	61c2      	str	r2, [r0, #28]
  while(_this->rng<=EC_CODE_BOT){
   297e0:	d837      	bhi.n	29852 <ec_dec_update+0x92>
   297e2:	6941      	ldr	r1, [r0, #20]
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
   297e4:	f8d0 e004 	ldr.w	lr, [r0, #4]
   297e8:	6a86      	ldr	r6, [r0, #40]	; 0x28
   297ea:	6985      	ldr	r5, [r0, #24]
   297ec:	3108      	adds	r1, #8
    _this->rem=ec_read_byte(_this);
   297ee:	f04f 0800 	mov.w	r8, #0
    sym=(sym<<EC_SYM_BITS|_this->rem)>>(EC_SYM_BITS-EC_CODE_EXTRA);
   297f2:	0233      	lsls	r3, r6, #8
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
   297f4:	ea4f 2c04 	mov.w	ip, r4, lsl #8
   297f8:	ea6f 0363 	mvn.w	r3, r3, asr #1
    _this->rng<<=EC_SYM_BITS;
   297fc:	0212      	lsls	r2, r2, #8
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
   297fe:	45ae      	cmp	lr, r5
   29800:	f105 0701 	add.w	r7, r5, #1
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
   29804:	fa5c f483 	uxtab	r4, ip, r3
    _this->rng<<=EC_SYM_BITS;
   29808:	61c2      	str	r2, [r0, #28]
    _this->nbits_total+=EC_SYM_BITS;
   2980a:	6141      	str	r1, [r0, #20]
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
   2980c:	d914      	bls.n	29838 <ec_dec_update+0x78>
   2980e:	6803      	ldr	r3, [r0, #0]
   29810:	6187      	str	r7, [r0, #24]
   29812:	5d5b      	ldrb	r3, [r3, r5]
    _this->rem=ec_read_byte(_this);
   29814:	6283      	str	r3, [r0, #40]	; 0x28
    sym=(sym<<EC_SYM_BITS|_this->rem)>>(EC_SYM_BITS-EC_CODE_EXTRA);
   29816:	ea43 2406 	orr.w	r4, r3, r6, lsl #8
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
   2981a:	ea6f 0464 	mvn.w	r4, r4, asr #1
   2981e:	fa5c f484 	uxtab	r4, ip, r4
   29822:	f024 4400 	bic.w	r4, r4, #2147483648	; 0x80000000
  while(_this->rng<=EC_CODE_BOT){
   29826:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
   2982a:	f101 0108 	add.w	r1, r1, #8
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
   2982e:	6204      	str	r4, [r0, #32]
  while(_this->rng<=EC_CODE_BOT){
   29830:	d80f      	bhi.n	29852 <ec_dec_update+0x92>
   29832:	463d      	mov	r5, r7
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
   29834:	461e      	mov	r6, r3
   29836:	e7dc      	b.n	297f2 <ec_dec_update+0x32>
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
   29838:	f024 4400 	bic.w	r4, r4, #2147483648	; 0x80000000
  while(_this->rng<=EC_CODE_BOT){
   2983c:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
   29840:	6204      	str	r4, [r0, #32]
    _this->rem=ec_read_byte(_this);
   29842:	f8c0 8028 	str.w	r8, [r0, #40]	; 0x28
   29846:	f101 0108 	add.w	r1, r1, #8
  while(_this->rng<=EC_CODE_BOT){
   2984a:	d802      	bhi.n	29852 <ec_dec_update+0x92>
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
   2984c:	2300      	movs	r3, #0
   2984e:	461e      	mov	r6, r3
   29850:	e7cf      	b.n	297f2 <ec_dec_update+0x32>
  ec_dec_normalize(_this);
}
   29852:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  _this->rng=_fl>0?IMUL32(_this->ext,_fh-_fl):_this->rng-s;
   29856:	1a52      	subs	r2, r2, r1
   29858:	fb05 f202 	mul.w	r2, r5, r2
   2985c:	e7bd      	b.n	297da <ec_dec_update+0x1a>
   2985e:	bf00      	nop

00029860 <ec_dec_bit_logp>:
  opus_uint32 r;
  opus_uint32 d;
  opus_uint32 s;
  int         ret;
  r=_this->rng;
  d=_this->val;
   29860:	e9d0 2307 	ldrd	r2, r3, [r0, #28]
  s=r>>_logp;
   29864:	fa22 f101 	lsr.w	r1, r2, r1
  ret=d<s;
   29868:	428b      	cmp	r3, r1
int ec_dec_bit_logp(ec_dec *_this,unsigned _logp){
   2986a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  ret=d<s;
   2986e:	bf34      	ite	cc
   29870:	f04f 0901 	movcc.w	r9, #1
   29874:	f04f 0900 	movcs.w	r9, #0
  if(!ret)_this->val=d-s;
   29878:	d302      	bcc.n	29880 <ec_dec_bit_logp+0x20>
   2987a:	1a5b      	subs	r3, r3, r1
   2987c:	6203      	str	r3, [r0, #32]
  _this->rng=ret?s:r-s;
   2987e:	1a51      	subs	r1, r2, r1
  while(_this->rng<=EC_CODE_BOT){
   29880:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
  _this->rng=ret?s:r-s;
   29884:	61c1      	str	r1, [r0, #28]
  while(_this->rng<=EC_CODE_BOT){
   29886:	d837      	bhi.n	298f8 <ec_dec_bit_logp+0x98>
   29888:	6944      	ldr	r4, [r0, #20]
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
   2988a:	f8d0 e004 	ldr.w	lr, [r0, #4]
   2988e:	6a86      	ldr	r6, [r0, #40]	; 0x28
   29890:	6985      	ldr	r5, [r0, #24]
   29892:	3408      	adds	r4, #8
    _this->rem=ec_read_byte(_this);
   29894:	f04f 0800 	mov.w	r8, #0
    sym=(sym<<EC_SYM_BITS|_this->rem)>>(EC_SYM_BITS-EC_CODE_EXTRA);
   29898:	0232      	lsls	r2, r6, #8
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
   2989a:	ea4f 2c03 	mov.w	ip, r3, lsl #8
   2989e:	ea6f 0262 	mvn.w	r2, r2, asr #1
    _this->rng<<=EC_SYM_BITS;
   298a2:	0209      	lsls	r1, r1, #8
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
   298a4:	45ae      	cmp	lr, r5
   298a6:	f105 0701 	add.w	r7, r5, #1
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
   298aa:	fa5c f382 	uxtab	r3, ip, r2
    _this->rng<<=EC_SYM_BITS;
   298ae:	61c1      	str	r1, [r0, #28]
    _this->nbits_total+=EC_SYM_BITS;
   298b0:	6144      	str	r4, [r0, #20]
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
   298b2:	d914      	bls.n	298de <ec_dec_bit_logp+0x7e>
   298b4:	6803      	ldr	r3, [r0, #0]
   298b6:	6187      	str	r7, [r0, #24]
   298b8:	5d5a      	ldrb	r2, [r3, r5]
    _this->rem=ec_read_byte(_this);
   298ba:	6282      	str	r2, [r0, #40]	; 0x28
    sym=(sym<<EC_SYM_BITS|_this->rem)>>(EC_SYM_BITS-EC_CODE_EXTRA);
   298bc:	ea42 2306 	orr.w	r3, r2, r6, lsl #8
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
   298c0:	ea6f 0363 	mvn.w	r3, r3, asr #1
   298c4:	fa5c f383 	uxtab	r3, ip, r3
   298c8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  while(_this->rng<=EC_CODE_BOT){
   298cc:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
   298d0:	f104 0408 	add.w	r4, r4, #8
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
   298d4:	6203      	str	r3, [r0, #32]
  while(_this->rng<=EC_CODE_BOT){
   298d6:	d80f      	bhi.n	298f8 <ec_dec_bit_logp+0x98>
   298d8:	463d      	mov	r5, r7
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
   298da:	4616      	mov	r6, r2
   298dc:	e7dc      	b.n	29898 <ec_dec_bit_logp+0x38>
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
   298de:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  while(_this->rng<=EC_CODE_BOT){
   298e2:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
   298e6:	6203      	str	r3, [r0, #32]
    _this->rem=ec_read_byte(_this);
   298e8:	f8c0 8028 	str.w	r8, [r0, #40]	; 0x28
   298ec:	f104 0408 	add.w	r4, r4, #8
  while(_this->rng<=EC_CODE_BOT){
   298f0:	d802      	bhi.n	298f8 <ec_dec_bit_logp+0x98>
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
   298f2:	2200      	movs	r2, #0
   298f4:	4616      	mov	r6, r2
   298f6:	e7cf      	b.n	29898 <ec_dec_bit_logp+0x38>
  ec_dec_normalize(_this);
  return ret;
}
   298f8:	4648      	mov	r0, r9
   298fa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   298fe:	bf00      	nop

00029900 <ec_dec_uint>:
  _this->rng=t-s;
  ec_dec_normalize(_this);
  return ret;
}

opus_uint32 ec_dec_uint(ec_dec *_this,opus_uint32 _ft){
   29900:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  unsigned ft;
  unsigned s;
  int      ftb;
  /*In order to optimize EC_ILOG(), it is undefined for the value 0.*/
  celt_assert(_ft>1);
  _ft--;
   29904:	f101 3eff 	add.w	lr, r1, #4294967295	; 0xffffffff
  ftb=EC_ILOG(_ft);
   29908:	fabe f68e 	clz	r6, lr
   2990c:	f1c6 0220 	rsb	r2, r6, #32
  if(ftb>EC_UINT_BITS){
   29910:	2a08      	cmp	r2, #8
opus_uint32 ec_dec_uint(ec_dec *_this,opus_uint32 _ft){
   29912:	b083      	sub	sp, #12
   29914:	4603      	mov	r3, r0
   29916:	69c5      	ldr	r5, [r0, #28]
  if(ftb>EC_UINT_BITS){
   29918:	dd65      	ble.n	299e6 <ec_dec_uint+0xe6>
    opus_uint32 t;
    ftb-=EC_UINT_BITS;
   2991a:	f1c6 0618 	rsb	r6, r6, #24
    ft=(unsigned)(_ft>>ftb)+1;
   2991e:	fa2e f406 	lsr.w	r4, lr, r6
   29922:	1c67      	adds	r7, r4, #1
   if (d>256)
   29924:	f5b7 7f80 	cmp.w	r7, #256	; 0x100
   29928:	f200 80b6 	bhi.w	29a98 <ec_dec_uint+0x198>
      t = EC_ILOG(d&-d);
   2992c:	ea27 0204 	bic.w	r2, r7, r4
   29930:	fab2 f282 	clz	r2, r2
   29934:	f1c2 0220 	rsb	r2, r2, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   29938:	497e      	ldr	r1, [pc, #504]	; (29b34 <ec_dec_uint+0x234>)
   2993a:	fa27 fc02 	lsr.w	ip, r7, r2
   2993e:	1e50      	subs	r0, r2, #1
   29940:	f851 202c 	ldr.w	r2, [r1, ip, lsl #2]
   29944:	fa25 f000 	lsr.w	r0, r5, r0
   29948:	fba0 0102 	umull	r0, r1, r0, r2
      return q+(n-q*d >= d);
   2994c:	fb07 5211 	mls	r2, r7, r1, r5
   29950:	4297      	cmp	r7, r2
   29952:	bf98      	it	ls
   29954:	3101      	addls	r1, #1
  s=(unsigned)(_this->val/_this->ext);
   29956:	6a1a      	ldr	r2, [r3, #32]
   29958:	fbb2 f0f1 	udiv	r0, r2, r1
  return _ft-EC_MINI(s+1,_ft);
   2995c:	f100 0c01 	add.w	ip, r0, #1
   29960:	4567      	cmp	r7, ip
   29962:	bf38      	it	cc
   29964:	4620      	movcc	r0, r4
  s=IMUL32(_this->ext,_ft-_fh);
   29966:	fb00 f701 	mul.w	r7, r0, r1
  _this->val-=s;
   2996a:	1bd2      	subs	r2, r2, r7
  _this->rng=_fl>0?IMUL32(_this->ext,_fh-_fl):_this->rng-s;
   2996c:	1a20      	subs	r0, r4, r0
  _this->val-=s;
   2996e:	e9c3 2108 	strd	r2, r1, [r3, #32]
  _this->rng=_fl>0?IMUL32(_this->ext,_fh-_fl):_this->rng-s;
   29972:	bf08      	it	eq
   29974:	1be9      	subeq	r1, r5, r7
  while(_this->rng<=EC_CODE_BOT){
   29976:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
  _this->rng=_fl>0?IMUL32(_this->ext,_fh-_fl):_this->rng-s;
   2997a:	9001      	str	r0, [sp, #4]
   2997c:	61d9      	str	r1, [r3, #28]
   2997e:	f8d3 c014 	ldr.w	ip, [r3, #20]
  while(_this->rng<=EC_CODE_BOT){
   29982:	f200 80aa 	bhi.w	29ada <ec_dec_uint+0x1da>
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
   29986:	f8d3 9004 	ldr.w	r9, [r3, #4]
   2998a:	6a9d      	ldr	r5, [r3, #40]	; 0x28
   2998c:	699c      	ldr	r4, [r3, #24]
   2998e:	f10c 0008 	add.w	r0, ip, #8
    _this->rem=ec_read_byte(_this);
   29992:	f04f 0a00 	mov.w	sl, #0
    sym=(sym<<EC_SYM_BITS|_this->rem)>>(EC_SYM_BITS-EC_CODE_EXTRA);
   29996:	ea4f 2c05 	mov.w	ip, r5, lsl #8
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
   2999a:	ea6f 0c6c 	mvn.w	ip, ip, asr #1
   2999e:	ea4f 2802 	mov.w	r8, r2, lsl #8
    _this->rng<<=EC_SYM_BITS;
   299a2:	0209      	lsls	r1, r1, #8
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
   299a4:	45a1      	cmp	r9, r4
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
   299a6:	fa58 f28c 	uxtab	r2, r8, ip
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
   299aa:	f104 0701 	add.w	r7, r4, #1
    _this->rng<<=EC_SYM_BITS;
   299ae:	61d9      	str	r1, [r3, #28]
    _this->nbits_total+=EC_SYM_BITS;
   299b0:	6158      	str	r0, [r3, #20]
   299b2:	4684      	mov	ip, r0
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
   299b4:	f240 8083 	bls.w	29abe <ec_dec_uint+0x1be>
   299b8:	681a      	ldr	r2, [r3, #0]
   299ba:	619f      	str	r7, [r3, #24]
   299bc:	f812 b004 	ldrb.w	fp, [r2, r4]
    _this->rem=ec_read_byte(_this);
   299c0:	f8c3 b028 	str.w	fp, [r3, #40]	; 0x28
    sym=(sym<<EC_SYM_BITS|_this->rem)>>(EC_SYM_BITS-EC_CODE_EXTRA);
   299c4:	ea4b 2205 	orr.w	r2, fp, r5, lsl #8
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
   299c8:	ea6f 0262 	mvn.w	r2, r2, asr #1
   299cc:	fa58 f282 	uxtab	r2, r8, r2
   299d0:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
  while(_this->rng<=EC_CODE_BOT){
   299d4:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
   299d8:	f100 0008 	add.w	r0, r0, #8
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
   299dc:	621a      	str	r2, [r3, #32]
  while(_this->rng<=EC_CODE_BOT){
   299de:	d87c      	bhi.n	29ada <ec_dec_uint+0x1da>
   299e0:	463c      	mov	r4, r7
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
   299e2:	465d      	mov	r5, fp
   299e4:	e7d7      	b.n	29996 <ec_dec_uint+0x96>
   if (d>256)
   299e6:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
   299ea:	d858      	bhi.n	29a9e <ec_dec_uint+0x19e>
      t = EC_ILOG(d&-d);
   299ec:	424e      	negs	r6, r1
   299ee:	400e      	ands	r6, r1
   299f0:	fab6 f686 	clz	r6, r6
   299f4:	f1c6 0620 	rsb	r6, r6, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   299f8:	fa21 f006 	lsr.w	r0, r1, r6
   299fc:	4a4d      	ldr	r2, [pc, #308]	; (29b34 <ec_dec_uint+0x234>)
   299fe:	3e01      	subs	r6, #1
   29a00:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
   29a04:	fa25 f606 	lsr.w	r6, r5, r6
   29a08:	fba6 6702 	umull	r6, r7, r6, r2
      return q+(n-q*d >= d);
   29a0c:	fb01 5417 	mls	r4, r1, r7, r5
   29a10:	42a1      	cmp	r1, r4
   29a12:	bf8c      	ite	hi
   29a14:	463c      	movhi	r4, r7
   29a16:	1c7c      	addls	r4, r7, #1
  s=(unsigned)(_this->val/_this->ext);
   29a18:	6a1a      	ldr	r2, [r3, #32]
   29a1a:	fbb2 f0f4 	udiv	r0, r2, r4
  return _ft-EC_MINI(s+1,_ft);
   29a1e:	1c46      	adds	r6, r0, #1
   29a20:	42b1      	cmp	r1, r6
   29a22:	bf38      	it	cc
   29a24:	4670      	movcc	r0, lr
  s=IMUL32(_this->ext,_ft-_fh);
   29a26:	fb00 f104 	mul.w	r1, r0, r4
  _this->val-=s;
   29a2a:	1a52      	subs	r2, r2, r1
  _this->rng=_fl>0?IMUL32(_this->ext,_fh-_fl):_this->rng-s;
   29a2c:	ebbe 0000 	subs.w	r0, lr, r0
  _this->val-=s;
   29a30:	e9c3 2408 	strd	r2, r4, [r3, #32]
  _this->rng=_fl>0?IMUL32(_this->ext,_fh-_fl):_this->rng-s;
   29a34:	bf08      	it	eq
   29a36:	1a6c      	subeq	r4, r5, r1
  while(_this->rng<=EC_CODE_BOT){
   29a38:	f5b4 0f00 	cmp.w	r4, #8388608	; 0x800000
  _this->rng=_fl>0?IMUL32(_this->ext,_fh-_fl):_this->rng-s;
   29a3c:	61dc      	str	r4, [r3, #28]
  while(_this->rng<=EC_CODE_BOT){
   29a3e:	d876      	bhi.n	29b2e <ec_dec_uint+0x22e>
   29a40:	695d      	ldr	r5, [r3, #20]
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
   29a42:	f8d3 8004 	ldr.w	r8, [r3, #4]
   29a46:	6a9f      	ldr	r7, [r3, #40]	; 0x28
   29a48:	699e      	ldr	r6, [r3, #24]
   29a4a:	3508      	adds	r5, #8
    _this->rem=ec_read_byte(_this);
   29a4c:	f04f 0900 	mov.w	r9, #0
    sym=(sym<<EC_SYM_BITS|_this->rem)>>(EC_SYM_BITS-EC_CODE_EXTRA);
   29a50:	0239      	lsls	r1, r7, #8
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
   29a52:	ea4f 2e02 	mov.w	lr, r2, lsl #8
   29a56:	ea6f 0161 	mvn.w	r1, r1, asr #1
    _this->rng<<=EC_SYM_BITS;
   29a5a:	0224      	lsls	r4, r4, #8
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
   29a5c:	45b0      	cmp	r8, r6
   29a5e:	f106 0c01 	add.w	ip, r6, #1
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
   29a62:	fa5e f281 	uxtab	r2, lr, r1
    _this->rng<<=EC_SYM_BITS;
   29a66:	61dc      	str	r4, [r3, #28]
    _this->nbits_total+=EC_SYM_BITS;
   29a68:	615d      	str	r5, [r3, #20]
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
   29a6a:	d91b      	bls.n	29aa4 <ec_dec_uint+0x1a4>
   29a6c:	6819      	ldr	r1, [r3, #0]
   29a6e:	f8c3 c018 	str.w	ip, [r3, #24]
   29a72:	5d89      	ldrb	r1, [r1, r6]
    _this->rem=ec_read_byte(_this);
   29a74:	6299      	str	r1, [r3, #40]	; 0x28
    sym=(sym<<EC_SYM_BITS|_this->rem)>>(EC_SYM_BITS-EC_CODE_EXTRA);
   29a76:	ea41 2207 	orr.w	r2, r1, r7, lsl #8
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
   29a7a:	ea6f 0262 	mvn.w	r2, r2, asr #1
   29a7e:	fa5e f282 	uxtab	r2, lr, r2
   29a82:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
  while(_this->rng<=EC_CODE_BOT){
   29a86:	f5b4 0f00 	cmp.w	r4, #8388608	; 0x800000
   29a8a:	f105 0508 	add.w	r5, r5, #8
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
   29a8e:	621a      	str	r2, [r3, #32]
  while(_this->rng<=EC_CODE_BOT){
   29a90:	d84d      	bhi.n	29b2e <ec_dec_uint+0x22e>
   29a92:	4666      	mov	r6, ip
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
   29a94:	460f      	mov	r7, r1
   29a96:	e7db      	b.n	29a50 <ec_dec_uint+0x150>
      return n/d;
   29a98:	fbb5 f1f7 	udiv	r1, r5, r7
   29a9c:	e75b      	b.n	29956 <ec_dec_uint+0x56>
   29a9e:	fbb5 f4f1 	udiv	r4, r5, r1
   29aa2:	e7b9      	b.n	29a18 <ec_dec_uint+0x118>
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
   29aa4:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
  while(_this->rng<=EC_CODE_BOT){
   29aa8:	f5b4 0f00 	cmp.w	r4, #8388608	; 0x800000
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
   29aac:	621a      	str	r2, [r3, #32]
    _this->rem=ec_read_byte(_this);
   29aae:	f8c3 9028 	str.w	r9, [r3, #40]	; 0x28
   29ab2:	f105 0508 	add.w	r5, r5, #8
  while(_this->rng<=EC_CODE_BOT){
   29ab6:	d83a      	bhi.n	29b2e <ec_dec_uint+0x22e>
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
   29ab8:	2100      	movs	r1, #0
   29aba:	460f      	mov	r7, r1
   29abc:	e7c8      	b.n	29a50 <ec_dec_uint+0x150>
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
   29abe:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
  while(_this->rng<=EC_CODE_BOT){
   29ac2:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
   29ac6:	621a      	str	r2, [r3, #32]
    _this->rem=ec_read_byte(_this);
   29ac8:	f8c3 a028 	str.w	sl, [r3, #40]	; 0x28
   29acc:	f100 0008 	add.w	r0, r0, #8
  while(_this->rng<=EC_CODE_BOT){
   29ad0:	d803      	bhi.n	29ada <ec_dec_uint+0x1da>
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
   29ad2:	f04f 0b00 	mov.w	fp, #0
   29ad6:	465d      	mov	r5, fp
   29ad8:	e75d      	b.n	29996 <ec_dec_uint+0x96>

opus_uint32 ec_dec_bits(ec_dec *_this,unsigned _bits){
  ec_window   window;
  int         available;
  opus_uint32 ret;
  window=_this->end_window;
   29ada:	e9d3 5203 	ldrd	r5, r2, [r3, #12]
    t=(opus_uint32)s<<ftb|ec_dec_bits(_this,ftb);
   29ade:	9f01      	ldr	r7, [sp, #4]
  available=_this->nend_bits;
  if((unsigned)available<_bits){
   29ae0:	4296      	cmp	r6, r2
    t=(opus_uint32)s<<ftb|ec_dec_bits(_this,ftb);
   29ae2:	fa07 f706 	lsl.w	r7, r7, r6
  if((unsigned)available<_bits){
   29ae6:	d90f      	bls.n	29b08 <ec_dec_uint+0x208>
   29ae8:	e9d3 0101 	ldrd	r0, r1, [r3, #4]
   _this->buf[_this->storage-++(_this->end_offs)]:0;
   29aec:	4288      	cmp	r0, r1
   29aee:	d908      	bls.n	29b02 <ec_dec_uint+0x202>
   29af0:	3101      	adds	r1, #1
   29af2:	eba0 0801 	sub.w	r8, r0, r1
   29af6:	681c      	ldr	r4, [r3, #0]
   29af8:	6099      	str	r1, [r3, #8]
   29afa:	f814 4008 	ldrb.w	r4, [r4, r8]
   29afe:	4094      	lsls	r4, r2
   29b00:	4325      	orrs	r5, r4
    do{
      window|=(ec_window)ec_read_byte_from_end(_this)<<available;
      available+=EC_SYM_BITS;
   29b02:	3208      	adds	r2, #8
    }
    while(available<=EC_WINDOW_SIZE-EC_SYM_BITS);
   29b04:	2a18      	cmp	r2, #24
   29b06:	ddf1      	ble.n	29aec <ec_dec_uint+0x1ec>
  }
  ret=(opus_uint32)window&(((opus_uint32)1<<_bits)-1U);
   29b08:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   29b0c:	40b0      	lsls	r0, r6
   29b0e:	ea25 0000 	bic.w	r0, r5, r0
    t=(opus_uint32)s<<ftb|ec_dec_bits(_this,ftb);
   29b12:	4338      	orrs	r0, r7
  window>>=_bits;
  available-=_bits;
   29b14:	1b92      	subs	r2, r2, r6
  _this->end_window=window;
  _this->nend_bits=available;
  _this->nbits_total+=_bits;
   29b16:	eb0c 0406 	add.w	r4, ip, r6
    if(t<=_ft)return t;
   29b1a:	4586      	cmp	lr, r0
  window>>=_bits;
   29b1c:	fa25 f606 	lsr.w	r6, r5, r6
  _this->nbits_total+=_bits;
   29b20:	e9c3 2404 	strd	r2, r4, [r3, #16]
  _this->end_window=window;
   29b24:	60de      	str	r6, [r3, #12]
    if(t<=_ft)return t;
   29b26:	d202      	bcs.n	29b2e <ec_dec_uint+0x22e>
    _this->error=1;
   29b28:	2201      	movs	r2, #1
    return _ft;
   29b2a:	4670      	mov	r0, lr
    _this->error=1;
   29b2c:	62da      	str	r2, [r3, #44]	; 0x2c
}
   29b2e:	b003      	add	sp, #12
   29b30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   29b34:	00038e98 	.word	0x00038e98

00029b38 <ec_dec_bits>:
opus_uint32 ec_dec_bits(ec_dec *_this,unsigned _bits){
   29b38:	b4f0      	push	{r4, r5, r6, r7}
  window=_this->end_window;
   29b3a:	e9d0 6303 	ldrd	r6, r3, [r0, #12]
  if((unsigned)available<_bits){
   29b3e:	428b      	cmp	r3, r1
opus_uint32 ec_dec_bits(ec_dec *_this,unsigned _bits){
   29b40:	4602      	mov	r2, r0
  if((unsigned)available<_bits){
   29b42:	d20d      	bcs.n	29b60 <ec_dec_bits+0x28>
   29b44:	e9d0 0401 	ldrd	r0, r4, [r0, #4]
   _this->buf[_this->storage-++(_this->end_offs)]:0;
   29b48:	42a0      	cmp	r0, r4
   29b4a:	d906      	bls.n	29b5a <ec_dec_bits+0x22>
   29b4c:	3401      	adds	r4, #1
   29b4e:	1b05      	subs	r5, r0, r4
   29b50:	6817      	ldr	r7, [r2, #0]
   29b52:	6094      	str	r4, [r2, #8]
   29b54:	5d7d      	ldrb	r5, [r7, r5]
   29b56:	409d      	lsls	r5, r3
   29b58:	432e      	orrs	r6, r5
      available+=EC_SYM_BITS;
   29b5a:	3308      	adds	r3, #8
    while(available<=EC_WINDOW_SIZE-EC_SYM_BITS);
   29b5c:	2b18      	cmp	r3, #24
   29b5e:	ddf3      	ble.n	29b48 <ec_dec_bits+0x10>
  _this->nbits_total+=_bits;
   29b60:	6954      	ldr	r4, [r2, #20]
  ret=(opus_uint32)window&(((opus_uint32)1<<_bits)-1U);
   29b62:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  _this->nbits_total+=_bits;
   29b66:	440c      	add	r4, r1
  available-=_bits;
   29b68:	1a5b      	subs	r3, r3, r1
  ret=(opus_uint32)window&(((opus_uint32)1<<_bits)-1U);
   29b6a:	4088      	lsls	r0, r1
  window>>=_bits;
   29b6c:	fa26 f101 	lsr.w	r1, r6, r1
  return ret;
}
   29b70:	ea26 0000 	bic.w	r0, r6, r0
  _this->nbits_total+=_bits;
   29b74:	e9c2 3404 	strd	r3, r4, [r2, #16]
  _this->end_window=window;
   29b78:	60d1      	str	r1, [r2, #12]
}
   29b7a:	bcf0      	pop	{r4, r5, r6, r7}
   29b7c:	4770      	bx	lr
   29b7e:	bf00      	nop

00029b80 <ec_enc_init>:
    _this->rng<<=EC_SYM_BITS;
    _this->nbits_total+=EC_SYM_BITS;
  }
}

void ec_enc_init(ec_enc *_this,unsigned char *_buf,opus_uint32 _size){
   29b80:	b470      	push	{r4, r5, r6}
  _this->buf=_buf;
  _this->end_offs=0;
   29b82:	2300      	movs	r3, #0
  _this->end_window=0;
  _this->nend_bits=0;
  /*This is the offset from which ec_tell() will subtract partial bits.*/
  _this->nbits_total=EC_CODE_BITS+1;
   29b84:	2621      	movs	r6, #33	; 0x21
  _this->offs=0;
  _this->rng=EC_CODE_TOP;
   29b86:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
  _this->rem=-1;
   29b8a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  _this->nbits_total=EC_CODE_BITS+1;
   29b8e:	6146      	str	r6, [r0, #20]
  _this->rng=EC_CODE_TOP;
   29b90:	61c5      	str	r5, [r0, #28]
  _this->rem=-1;
   29b92:	6284      	str	r4, [r0, #40]	; 0x28
  _this->buf=_buf;
   29b94:	6001      	str	r1, [r0, #0]
  _this->val=0;
  _this->ext=0;
  _this->storage=_size;
   29b96:	6042      	str	r2, [r0, #4]
  _this->end_window=0;
   29b98:	e9c0 3302 	strd	r3, r3, [r0, #8]
  _this->nend_bits=0;
   29b9c:	6103      	str	r3, [r0, #16]
  _this->offs=0;
   29b9e:	6183      	str	r3, [r0, #24]
  _this->ext=0;
   29ba0:	e9c0 3308 	strd	r3, r3, [r0, #32]
  _this->error=0;
   29ba4:	62c3      	str	r3, [r0, #44]	; 0x2c
}
   29ba6:	bc70      	pop	{r4, r5, r6}
   29ba8:	4770      	bx	lr
   29baa:	bf00      	nop

00029bac <ec_encode>:
   if (d>256)
   29bac:	f5b3 7f80 	cmp.w	r3, #256	; 0x100

void ec_encode(ec_enc *_this,unsigned _fl,unsigned _fh,unsigned _ft){
   29bb0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  opus_uint32 r;
  r=celt_udiv(_this->rng,_ft);
   29bb4:	69c6      	ldr	r6, [r0, #28]
   29bb6:	d962      	bls.n	29c7e <ec_encode+0xd2>
      return n/d;
   29bb8:	fbb6 f4f3 	udiv	r4, r6, r3
  if(_fl>0){
   29bbc:	2900      	cmp	r1, #0
   29bbe:	d177      	bne.n	29cb0 <ec_encode+0x104>
    _this->val+=_this->rng-IMUL32(r,(_ft-_fl));
    _this->rng=IMUL32(r,(_fh-_fl));
  }
  else _this->rng-=IMUL32(r,(_ft-_fh));
   29bc0:	1a9b      	subs	r3, r3, r2
   29bc2:	fb04 6313 	mls	r3, r4, r3, r6
  while(_this->rng<=EC_CODE_BOT){
   29bc6:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
   29bca:	61c3      	str	r3, [r0, #28]
   29bcc:	d84e      	bhi.n	29c6c <ec_encode+0xc0>
   29bce:	6a03      	ldr	r3, [r0, #32]
      do _this->error|=ec_write_byte(_this,sym);
   29bd0:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    ec_enc_carry_out(_this,(int)(_this->val>>EC_CODE_SHIFT));
   29bd4:	0ddc      	lsrs	r4, r3, #23
  if(_c!=EC_SYM_MAX){
   29bd6:	2cff      	cmp	r4, #255	; 0xff
   29bd8:	d04a      	beq.n	29c70 <ec_encode+0xc4>
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
   29bda:	6a83      	ldr	r3, [r0, #40]	; 0x28
   29bdc:	2b00      	cmp	r3, #0
    carry=_c>>EC_SYM_BITS;
   29bde:	ea4f 2e24 	mov.w	lr, r4, asr #8
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
   29be2:	db0e      	blt.n	29c02 <ec_encode+0x56>
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29be4:	e9d0 7101 	ldrd	r7, r1, [r0, #4]
   29be8:	6982      	ldr	r2, [r0, #24]
   29bea:	4411      	add	r1, r2
   29bec:	42b9      	cmp	r1, r7
   29bee:	d243      	bcs.n	29c78 <ec_encode+0xcc>
  _this->buf[_this->offs++]=(unsigned char)_value;
   29bf0:	6801      	ldr	r1, [r0, #0]
   29bf2:	1c56      	adds	r6, r2, #1
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
   29bf4:	4473      	add	r3, lr
  _this->buf[_this->offs++]=(unsigned char)_value;
   29bf6:	6186      	str	r6, [r0, #24]
   29bf8:	548b      	strb	r3, [r1, r2]
  return 0;
   29bfa:	2200      	movs	r2, #0
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
   29bfc:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   29bfe:	4313      	orrs	r3, r2
   29c00:	62c3      	str	r3, [r0, #44]	; 0x2c
    if(_this->ext>0){
   29c02:	6a43      	ldr	r3, [r0, #36]	; 0x24
   29c04:	b313      	cbz	r3, 29c4c <ec_encode+0xa0>
   29c06:	e9d0 7101 	ldrd	r7, r1, [r0, #4]
   29c0a:	6982      	ldr	r2, [r0, #24]
      sym=(EC_SYM_MAX+carry)&EC_SYM_MAX;
   29c0c:	f10e 0eff 	add.w	lr, lr, #255	; 0xff
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29c10:	1856      	adds	r6, r2, r1
   29c12:	42be      	cmp	r6, r7
  _this->buf[_this->offs++]=(unsigned char)_value;
   29c14:	f102 0c01 	add.w	ip, r2, #1
      while(--(_this->ext)>0);
   29c18:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29c1c:	d212      	bcs.n	29c44 <ec_encode+0x98>
  _this->buf[_this->offs++]=(unsigned char)_value;
   29c1e:	6803      	ldr	r3, [r0, #0]
   29c20:	f8c0 c018 	str.w	ip, [r0, #24]
   29c24:	f803 e002 	strb.w	lr, [r3, r2]
      while(--(_this->ext)>0);
   29c28:	6a43      	ldr	r3, [r0, #36]	; 0x24
   29c2a:	3b01      	subs	r3, #1
   29c2c:	6243      	str	r3, [r0, #36]	; 0x24
   29c2e:	b16b      	cbz	r3, 29c4c <ec_encode+0xa0>
   29c30:	e9d0 7101 	ldrd	r7, r1, [r0, #4]
   29c34:	6982      	ldr	r2, [r0, #24]
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29c36:	1856      	adds	r6, r2, r1
   29c38:	42be      	cmp	r6, r7
  _this->buf[_this->offs++]=(unsigned char)_value;
   29c3a:	f102 0c01 	add.w	ip, r2, #1
      while(--(_this->ext)>0);
   29c3e:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29c42:	d3ec      	bcc.n	29c1e <ec_encode+0x72>
      do _this->error|=ec_write_byte(_this,sym);
   29c44:	62c5      	str	r5, [r0, #44]	; 0x2c
      while(--(_this->ext)>0);
   29c46:	6243      	str	r3, [r0, #36]	; 0x24
   29c48:	2b00      	cmp	r3, #0
   29c4a:	d1e1      	bne.n	29c10 <ec_encode+0x64>
    _this->rem=_c&EC_SYM_MAX;
   29c4c:	b2e4      	uxtb	r4, r4
   29c4e:	6a03      	ldr	r3, [r0, #32]
   29c50:	6284      	str	r4, [r0, #40]	; 0x28
    _this->rng<<=EC_SYM_BITS;
   29c52:	69c2      	ldr	r2, [r0, #28]
    _this->nbits_total+=EC_SYM_BITS;
   29c54:	6941      	ldr	r1, [r0, #20]
    _this->rng<<=EC_SYM_BITS;
   29c56:	0212      	lsls	r2, r2, #8
    _this->val=(_this->val<<EC_SYM_BITS)&(EC_CODE_TOP-1);
   29c58:	021b      	lsls	r3, r3, #8
   29c5a:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    _this->nbits_total+=EC_SYM_BITS;
   29c5e:	3108      	adds	r1, #8
  while(_this->rng<=EC_CODE_BOT){
   29c60:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
    _this->rng<<=EC_SYM_BITS;
   29c64:	e9c0 2307 	strd	r2, r3, [r0, #28]
    _this->nbits_total+=EC_SYM_BITS;
   29c68:	6141      	str	r1, [r0, #20]
  while(_this->rng<=EC_CODE_BOT){
   29c6a:	d9b3      	bls.n	29bd4 <ec_encode+0x28>
  ec_enc_normalize(_this);
}
   29c6c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else _this->ext++;
   29c70:	6a42      	ldr	r2, [r0, #36]	; 0x24
   29c72:	3201      	adds	r2, #1
   29c74:	6242      	str	r2, [r0, #36]	; 0x24
   29c76:	e7ec      	b.n	29c52 <ec_encode+0xa6>
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29c78:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   29c7c:	e7be      	b.n	29bfc <ec_encode+0x50>
      t = EC_ILOG(d&-d);
   29c7e:	425c      	negs	r4, r3
   29c80:	401c      	ands	r4, r3
   29c82:	fab4 f484 	clz	r4, r4
   29c86:	f1c4 0420 	rsb	r4, r4, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   29c8a:	fa23 f704 	lsr.w	r7, r3, r4
   29c8e:	4d0d      	ldr	r5, [pc, #52]	; (29cc4 <ec_encode+0x118>)
   29c90:	3c01      	subs	r4, #1
   29c92:	f855 5027 	ldr.w	r5, [r5, r7, lsl #2]
   29c96:	fa26 f404 	lsr.w	r4, r6, r4
   29c9a:	fba4 7805 	umull	r7, r8, r4, r5
      return q+(n-q*d >= d);
   29c9e:	fb03 6418 	mls	r4, r3, r8, r6
   29ca2:	42a3      	cmp	r3, r4
   29ca4:	bf8c      	ite	hi
   29ca6:	4644      	movhi	r4, r8
   29ca8:	f108 0401 	addls.w	r4, r8, #1
  if(_fl>0){
   29cac:	2900      	cmp	r1, #0
   29cae:	d087      	beq.n	29bc0 <ec_encode+0x14>
    _this->val+=_this->rng-IMUL32(r,(_ft-_fl));
   29cb0:	6a07      	ldr	r7, [r0, #32]
   29cb2:	1a5d      	subs	r5, r3, r1
   29cb4:	443e      	add	r6, r7
    _this->rng=IMUL32(r,(_fh-_fl));
   29cb6:	1a53      	subs	r3, r2, r1
    _this->val+=_this->rng-IMUL32(r,(_ft-_fl));
   29cb8:	fb04 6615 	mls	r6, r4, r5, r6
    _this->rng=IMUL32(r,(_fh-_fl));
   29cbc:	fb04 f303 	mul.w	r3, r4, r3
    _this->val+=_this->rng-IMUL32(r,(_ft-_fl));
   29cc0:	6206      	str	r6, [r0, #32]
   29cc2:	e780      	b.n	29bc6 <ec_encode+0x1a>
   29cc4:	00038e98 	.word	0x00038e98

00029cc8 <ec_encode_bin>:

void ec_encode_bin(ec_enc *_this,unsigned _fl,unsigned _fh,unsigned _bits){
   29cc8:	b5f0      	push	{r4, r5, r6, r7, lr}
  opus_uint32 r;
  r=_this->rng>>_bits;
   29cca:	69c6      	ldr	r6, [r0, #28]
   29ccc:	2401      	movs	r4, #1
   29cce:	fa26 f503 	lsr.w	r5, r6, r3
   29cd2:	409c      	lsls	r4, r3
  if(_fl>0){
   29cd4:	2900      	cmp	r1, #0
   29cd6:	d15d      	bne.n	29d94 <ec_encode_bin+0xcc>
    _this->val+=_this->rng-IMUL32(r,((1U<<_bits)-_fl));
    _this->rng=IMUL32(r,(_fh-_fl));
  }
  else _this->rng-=IMUL32(r,((1U<<_bits)-_fh));
   29cd8:	1aa4      	subs	r4, r4, r2
   29cda:	fb05 6414 	mls	r4, r5, r4, r6
  while(_this->rng<=EC_CODE_BOT){
   29cde:	f5b4 0f00 	cmp.w	r4, #8388608	; 0x800000
   29ce2:	61c4      	str	r4, [r0, #28]
   29ce4:	d84e      	bhi.n	29d84 <ec_encode_bin+0xbc>
   29ce6:	6a03      	ldr	r3, [r0, #32]
      do _this->error|=ec_write_byte(_this,sym);
   29ce8:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    ec_enc_carry_out(_this,(int)(_this->val>>EC_CODE_SHIFT));
   29cec:	0ddc      	lsrs	r4, r3, #23
  if(_c!=EC_SYM_MAX){
   29cee:	2cff      	cmp	r4, #255	; 0xff
   29cf0:	d049      	beq.n	29d86 <ec_encode_bin+0xbe>
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
   29cf2:	6a83      	ldr	r3, [r0, #40]	; 0x28
   29cf4:	2b00      	cmp	r3, #0
    carry=_c>>EC_SYM_BITS;
   29cf6:	ea4f 2e24 	mov.w	lr, r4, asr #8
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
   29cfa:	db0e      	blt.n	29d1a <ec_encode_bin+0x52>
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29cfc:	e9d0 7101 	ldrd	r7, r1, [r0, #4]
   29d00:	6982      	ldr	r2, [r0, #24]
   29d02:	4411      	add	r1, r2
   29d04:	42b9      	cmp	r1, r7
   29d06:	d242      	bcs.n	29d8e <ec_encode_bin+0xc6>
  _this->buf[_this->offs++]=(unsigned char)_value;
   29d08:	6801      	ldr	r1, [r0, #0]
   29d0a:	1c56      	adds	r6, r2, #1
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
   29d0c:	4473      	add	r3, lr
  _this->buf[_this->offs++]=(unsigned char)_value;
   29d0e:	6186      	str	r6, [r0, #24]
   29d10:	548b      	strb	r3, [r1, r2]
  return 0;
   29d12:	2200      	movs	r2, #0
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
   29d14:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   29d16:	4313      	orrs	r3, r2
   29d18:	62c3      	str	r3, [r0, #44]	; 0x2c
    if(_this->ext>0){
   29d1a:	6a43      	ldr	r3, [r0, #36]	; 0x24
   29d1c:	b313      	cbz	r3, 29d64 <ec_encode_bin+0x9c>
   29d1e:	e9d0 7101 	ldrd	r7, r1, [r0, #4]
   29d22:	6982      	ldr	r2, [r0, #24]
      sym=(EC_SYM_MAX+carry)&EC_SYM_MAX;
   29d24:	f10e 0eff 	add.w	lr, lr, #255	; 0xff
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29d28:	1856      	adds	r6, r2, r1
   29d2a:	42be      	cmp	r6, r7
  _this->buf[_this->offs++]=(unsigned char)_value;
   29d2c:	f102 0c01 	add.w	ip, r2, #1
      while(--(_this->ext)>0);
   29d30:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29d34:	d212      	bcs.n	29d5c <ec_encode_bin+0x94>
  _this->buf[_this->offs++]=(unsigned char)_value;
   29d36:	6803      	ldr	r3, [r0, #0]
   29d38:	f8c0 c018 	str.w	ip, [r0, #24]
   29d3c:	f803 e002 	strb.w	lr, [r3, r2]
      while(--(_this->ext)>0);
   29d40:	6a43      	ldr	r3, [r0, #36]	; 0x24
   29d42:	3b01      	subs	r3, #1
   29d44:	6243      	str	r3, [r0, #36]	; 0x24
   29d46:	b16b      	cbz	r3, 29d64 <ec_encode_bin+0x9c>
   29d48:	e9d0 7101 	ldrd	r7, r1, [r0, #4]
   29d4c:	6982      	ldr	r2, [r0, #24]
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29d4e:	1856      	adds	r6, r2, r1
   29d50:	42be      	cmp	r6, r7
  _this->buf[_this->offs++]=(unsigned char)_value;
   29d52:	f102 0c01 	add.w	ip, r2, #1
      while(--(_this->ext)>0);
   29d56:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29d5a:	d3ec      	bcc.n	29d36 <ec_encode_bin+0x6e>
      do _this->error|=ec_write_byte(_this,sym);
   29d5c:	62c5      	str	r5, [r0, #44]	; 0x2c
      while(--(_this->ext)>0);
   29d5e:	6243      	str	r3, [r0, #36]	; 0x24
   29d60:	2b00      	cmp	r3, #0
   29d62:	d1e1      	bne.n	29d28 <ec_encode_bin+0x60>
    _this->rem=_c&EC_SYM_MAX;
   29d64:	b2e4      	uxtb	r4, r4
   29d66:	6a03      	ldr	r3, [r0, #32]
   29d68:	6284      	str	r4, [r0, #40]	; 0x28
    _this->rng<<=EC_SYM_BITS;
   29d6a:	69c2      	ldr	r2, [r0, #28]
    _this->nbits_total+=EC_SYM_BITS;
   29d6c:	6941      	ldr	r1, [r0, #20]
    _this->rng<<=EC_SYM_BITS;
   29d6e:	0212      	lsls	r2, r2, #8
    _this->val=(_this->val<<EC_SYM_BITS)&(EC_CODE_TOP-1);
   29d70:	021b      	lsls	r3, r3, #8
   29d72:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    _this->nbits_total+=EC_SYM_BITS;
   29d76:	3108      	adds	r1, #8
  while(_this->rng<=EC_CODE_BOT){
   29d78:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
    _this->rng<<=EC_SYM_BITS;
   29d7c:	e9c0 2307 	strd	r2, r3, [r0, #28]
    _this->nbits_total+=EC_SYM_BITS;
   29d80:	6141      	str	r1, [r0, #20]
  while(_this->rng<=EC_CODE_BOT){
   29d82:	d9b3      	bls.n	29cec <ec_encode_bin+0x24>
  ec_enc_normalize(_this);
}
   29d84:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else _this->ext++;
   29d86:	6a42      	ldr	r2, [r0, #36]	; 0x24
   29d88:	3201      	adds	r2, #1
   29d8a:	6242      	str	r2, [r0, #36]	; 0x24
   29d8c:	e7ed      	b.n	29d6a <ec_encode_bin+0xa2>
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29d8e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   29d92:	e7bf      	b.n	29d14 <ec_encode_bin+0x4c>
    _this->val+=_this->rng-IMUL32(r,((1U<<_bits)-_fl));
   29d94:	6a07      	ldr	r7, [r0, #32]
   29d96:	1a63      	subs	r3, r4, r1
   29d98:	443e      	add	r6, r7
    _this->rng=IMUL32(r,(_fh-_fl));
   29d9a:	1a54      	subs	r4, r2, r1
    _this->val+=_this->rng-IMUL32(r,((1U<<_bits)-_fl));
   29d9c:	fb05 6313 	mls	r3, r5, r3, r6
    _this->rng=IMUL32(r,(_fh-_fl));
   29da0:	fb05 f404 	mul.w	r4, r5, r4
    _this->val+=_this->rng-IMUL32(r,((1U<<_bits)-_fl));
   29da4:	6203      	str	r3, [r0, #32]
   29da6:	e79a      	b.n	29cde <ec_encode_bin+0x16>

00029da8 <ec_enc_bit_logp>:

/*The probability of having a "one" is 1/(1<<_logp).*/
void ec_enc_bit_logp(ec_enc *_this,int _val,unsigned _logp){
   29da8:	b5f0      	push	{r4, r5, r6, r7, lr}
  opus_uint32 r;
  opus_uint32 s;
  opus_uint32 l;
  r=_this->rng;
  l=_this->val;
   29daa:	e9d0 4307 	ldrd	r4, r3, [r0, #28]
  s=r>>_logp;
   29dae:	fa24 f202 	lsr.w	r2, r4, r2
  r-=s;
   29db2:	1aa4      	subs	r4, r4, r2
  if(_val)_this->val=l+r;
   29db4:	b111      	cbz	r1, 29dbc <ec_enc_bit_logp+0x14>
   29db6:	4423      	add	r3, r4
   29db8:	6203      	str	r3, [r0, #32]
  _this->rng=_val?s:r;
   29dba:	4614      	mov	r4, r2
  while(_this->rng<=EC_CODE_BOT){
   29dbc:	f5b4 0f00 	cmp.w	r4, #8388608	; 0x800000
  _this->rng=_val?s:r;
   29dc0:	61c4      	str	r4, [r0, #28]
  while(_this->rng<=EC_CODE_BOT){
   29dc2:	d855      	bhi.n	29e70 <ec_enc_bit_logp+0xc8>
      do _this->error|=ec_write_byte(_this,sym);
   29dc4:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    ec_enc_carry_out(_this,(int)(_this->val>>EC_CODE_SHIFT));
   29dc8:	ea4f 5ed3 	mov.w	lr, r3, lsr #23
  if(_c!=EC_SYM_MAX){
   29dcc:	f1be 0fff 	cmp.w	lr, #255	; 0xff
   29dd0:	d04f      	beq.n	29e72 <ec_enc_bit_logp+0xca>
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
   29dd2:	6a83      	ldr	r3, [r0, #40]	; 0x28
   29dd4:	2b00      	cmp	r3, #0
    carry=_c>>EC_SYM_BITS;
   29dd6:	ea4f 272e 	mov.w	r7, lr, asr #8
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
   29dda:	db11      	blt.n	29e00 <ec_enc_bit_logp+0x58>
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29ddc:	e9d0 4201 	ldrd	r4, r2, [r0, #4]
   29de0:	f8d0 c018 	ldr.w	ip, [r0, #24]
   29de4:	4462      	add	r2, ip
   29de6:	42a2      	cmp	r2, r4
   29de8:	d247      	bcs.n	29e7a <ec_enc_bit_logp+0xd2>
  _this->buf[_this->offs++]=(unsigned char)_value;
   29dea:	6802      	ldr	r2, [r0, #0]
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
   29dec:	443b      	add	r3, r7
  _this->buf[_this->offs++]=(unsigned char)_value;
   29dee:	f10c 0101 	add.w	r1, ip, #1
   29df2:	6181      	str	r1, [r0, #24]
   29df4:	f802 300c 	strb.w	r3, [r2, ip]
  return 0;
   29df8:	2200      	movs	r2, #0
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
   29dfa:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   29dfc:	4313      	orrs	r3, r2
   29dfe:	62c3      	str	r3, [r0, #44]	; 0x2c
    if(_this->ext>0){
   29e00:	6a43      	ldr	r3, [r0, #36]	; 0x24
   29e02:	b323      	cbz	r3, 29e4e <ec_enc_bit_logp+0xa6>
   29e04:	e9d0 4201 	ldrd	r4, r2, [r0, #4]
   29e08:	f8d0 c018 	ldr.w	ip, [r0, #24]
      sym=(EC_SYM_MAX+carry)&EC_SYM_MAX;
   29e0c:	37ff      	adds	r7, #255	; 0xff
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29e0e:	eb0c 0102 	add.w	r1, ip, r2
   29e12:	42a1      	cmp	r1, r4
  _this->buf[_this->offs++]=(unsigned char)_value;
   29e14:	f10c 0601 	add.w	r6, ip, #1
      while(--(_this->ext)>0);
   29e18:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29e1c:	d213      	bcs.n	29e46 <ec_enc_bit_logp+0x9e>
  _this->buf[_this->offs++]=(unsigned char)_value;
   29e1e:	6803      	ldr	r3, [r0, #0]
   29e20:	6186      	str	r6, [r0, #24]
   29e22:	f803 700c 	strb.w	r7, [r3, ip]
      while(--(_this->ext)>0);
   29e26:	6a43      	ldr	r3, [r0, #36]	; 0x24
   29e28:	3b01      	subs	r3, #1
   29e2a:	6243      	str	r3, [r0, #36]	; 0x24
   29e2c:	b17b      	cbz	r3, 29e4e <ec_enc_bit_logp+0xa6>
   29e2e:	e9d0 4201 	ldrd	r4, r2, [r0, #4]
   29e32:	f8d0 c018 	ldr.w	ip, [r0, #24]
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29e36:	eb0c 0102 	add.w	r1, ip, r2
   29e3a:	42a1      	cmp	r1, r4
  _this->buf[_this->offs++]=(unsigned char)_value;
   29e3c:	f10c 0601 	add.w	r6, ip, #1
      while(--(_this->ext)>0);
   29e40:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29e44:	d3eb      	bcc.n	29e1e <ec_enc_bit_logp+0x76>
      do _this->error|=ec_write_byte(_this,sym);
   29e46:	62c5      	str	r5, [r0, #44]	; 0x2c
      while(--(_this->ext)>0);
   29e48:	6243      	str	r3, [r0, #36]	; 0x24
   29e4a:	2b00      	cmp	r3, #0
   29e4c:	d1df      	bne.n	29e0e <ec_enc_bit_logp+0x66>
    _this->rem=_c&EC_SYM_MAX;
   29e4e:	fa5f f38e 	uxtb.w	r3, lr
   29e52:	6283      	str	r3, [r0, #40]	; 0x28
   29e54:	6a03      	ldr	r3, [r0, #32]
    _this->rng<<=EC_SYM_BITS;
   29e56:	69c2      	ldr	r2, [r0, #28]
    _this->nbits_total+=EC_SYM_BITS;
   29e58:	6941      	ldr	r1, [r0, #20]
    _this->rng<<=EC_SYM_BITS;
   29e5a:	0212      	lsls	r2, r2, #8
    _this->val=(_this->val<<EC_SYM_BITS)&(EC_CODE_TOP-1);
   29e5c:	021b      	lsls	r3, r3, #8
   29e5e:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    _this->nbits_total+=EC_SYM_BITS;
   29e62:	3108      	adds	r1, #8
  while(_this->rng<=EC_CODE_BOT){
   29e64:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
    _this->rng<<=EC_SYM_BITS;
   29e68:	e9c0 2307 	strd	r2, r3, [r0, #28]
    _this->nbits_total+=EC_SYM_BITS;
   29e6c:	6141      	str	r1, [r0, #20]
  while(_this->rng<=EC_CODE_BOT){
   29e6e:	d9ab      	bls.n	29dc8 <ec_enc_bit_logp+0x20>
  ec_enc_normalize(_this);
}
   29e70:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else _this->ext++;
   29e72:	6a42      	ldr	r2, [r0, #36]	; 0x24
   29e74:	3201      	adds	r2, #1
   29e76:	6242      	str	r2, [r0, #36]	; 0x24
   29e78:	e7ed      	b.n	29e56 <ec_enc_bit_logp+0xae>
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29e7a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   29e7e:	e7bc      	b.n	29dfa <ec_enc_bit_logp+0x52>

00029e80 <ec_enc_icdf>:

void ec_enc_icdf(ec_enc *_this,int _s,const unsigned char *_icdf,unsigned _ftb){
   29e80:	b5f0      	push	{r4, r5, r6, r7, lr}
  opus_uint32 r;
  r=_this->rng>>_ftb;
   29e82:	69c4      	ldr	r4, [r0, #28]
  if(_s>0){
   29e84:	2900      	cmp	r1, #0
  r=_this->rng>>_ftb;
   29e86:	fa24 f303 	lsr.w	r3, r4, r3
  if(_s>0){
   29e8a:	dd66      	ble.n	29f5a <ec_enc_icdf+0xda>
    _this->val+=_this->rng-IMUL32(r,_icdf[_s-1]);
   29e8c:	1e4e      	subs	r6, r1, #1
   29e8e:	6a07      	ldr	r7, [r0, #32]
   29e90:	5d95      	ldrb	r5, [r2, r6]
   29e92:	443c      	add	r4, r7
   29e94:	fb03 4415 	mls	r4, r3, r5, r4
   29e98:	6204      	str	r4, [r0, #32]
    _this->rng=IMUL32(r,_icdf[_s-1]-_icdf[_s]);
   29e9a:	5d94      	ldrb	r4, [r2, r6]
   29e9c:	5c52      	ldrb	r2, [r2, r1]
   29e9e:	1aa2      	subs	r2, r4, r2
   29ea0:	fb03 f302 	mul.w	r3, r3, r2
   29ea4:	61c3      	str	r3, [r0, #28]
  while(_this->rng<=EC_CODE_BOT){
   29ea6:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
   29eaa:	d84e      	bhi.n	29f4a <ec_enc_icdf+0xca>
   29eac:	6a03      	ldr	r3, [r0, #32]
      do _this->error|=ec_write_byte(_this,sym);
   29eae:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    ec_enc_carry_out(_this,(int)(_this->val>>EC_CODE_SHIFT));
   29eb2:	0ddc      	lsrs	r4, r3, #23
  if(_c!=EC_SYM_MAX){
   29eb4:	2cff      	cmp	r4, #255	; 0xff
   29eb6:	d049      	beq.n	29f4c <ec_enc_icdf+0xcc>
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
   29eb8:	6a83      	ldr	r3, [r0, #40]	; 0x28
   29eba:	2b00      	cmp	r3, #0
    carry=_c>>EC_SYM_BITS;
   29ebc:	ea4f 2e24 	mov.w	lr, r4, asr #8
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
   29ec0:	db0e      	blt.n	29ee0 <ec_enc_icdf+0x60>
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29ec2:	e9d0 7101 	ldrd	r7, r1, [r0, #4]
   29ec6:	6982      	ldr	r2, [r0, #24]
   29ec8:	4411      	add	r1, r2
   29eca:	42b9      	cmp	r1, r7
   29ecc:	d242      	bcs.n	29f54 <ec_enc_icdf+0xd4>
  _this->buf[_this->offs++]=(unsigned char)_value;
   29ece:	6801      	ldr	r1, [r0, #0]
   29ed0:	1c56      	adds	r6, r2, #1
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
   29ed2:	4473      	add	r3, lr
  _this->buf[_this->offs++]=(unsigned char)_value;
   29ed4:	6186      	str	r6, [r0, #24]
   29ed6:	548b      	strb	r3, [r1, r2]
  return 0;
   29ed8:	2200      	movs	r2, #0
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
   29eda:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   29edc:	4313      	orrs	r3, r2
   29ede:	62c3      	str	r3, [r0, #44]	; 0x2c
    if(_this->ext>0){
   29ee0:	6a43      	ldr	r3, [r0, #36]	; 0x24
   29ee2:	b313      	cbz	r3, 29f2a <ec_enc_icdf+0xaa>
   29ee4:	e9d0 7101 	ldrd	r7, r1, [r0, #4]
   29ee8:	6982      	ldr	r2, [r0, #24]
      sym=(EC_SYM_MAX+carry)&EC_SYM_MAX;
   29eea:	f10e 0eff 	add.w	lr, lr, #255	; 0xff
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29eee:	1856      	adds	r6, r2, r1
   29ef0:	42be      	cmp	r6, r7
  _this->buf[_this->offs++]=(unsigned char)_value;
   29ef2:	f102 0c01 	add.w	ip, r2, #1
      while(--(_this->ext)>0);
   29ef6:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29efa:	d212      	bcs.n	29f22 <ec_enc_icdf+0xa2>
  _this->buf[_this->offs++]=(unsigned char)_value;
   29efc:	6803      	ldr	r3, [r0, #0]
   29efe:	f8c0 c018 	str.w	ip, [r0, #24]
   29f02:	f803 e002 	strb.w	lr, [r3, r2]
      while(--(_this->ext)>0);
   29f06:	6a43      	ldr	r3, [r0, #36]	; 0x24
   29f08:	3b01      	subs	r3, #1
   29f0a:	6243      	str	r3, [r0, #36]	; 0x24
   29f0c:	b16b      	cbz	r3, 29f2a <ec_enc_icdf+0xaa>
   29f0e:	e9d0 7101 	ldrd	r7, r1, [r0, #4]
   29f12:	6982      	ldr	r2, [r0, #24]
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29f14:	1856      	adds	r6, r2, r1
   29f16:	42be      	cmp	r6, r7
  _this->buf[_this->offs++]=(unsigned char)_value;
   29f18:	f102 0c01 	add.w	ip, r2, #1
      while(--(_this->ext)>0);
   29f1c:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29f20:	d3ec      	bcc.n	29efc <ec_enc_icdf+0x7c>
      do _this->error|=ec_write_byte(_this,sym);
   29f22:	62c5      	str	r5, [r0, #44]	; 0x2c
      while(--(_this->ext)>0);
   29f24:	6243      	str	r3, [r0, #36]	; 0x24
   29f26:	2b00      	cmp	r3, #0
   29f28:	d1e1      	bne.n	29eee <ec_enc_icdf+0x6e>
    _this->rem=_c&EC_SYM_MAX;
   29f2a:	b2e4      	uxtb	r4, r4
   29f2c:	6a03      	ldr	r3, [r0, #32]
   29f2e:	6284      	str	r4, [r0, #40]	; 0x28
    _this->rng<<=EC_SYM_BITS;
   29f30:	69c2      	ldr	r2, [r0, #28]
    _this->nbits_total+=EC_SYM_BITS;
   29f32:	6941      	ldr	r1, [r0, #20]
    _this->rng<<=EC_SYM_BITS;
   29f34:	0212      	lsls	r2, r2, #8
    _this->val=(_this->val<<EC_SYM_BITS)&(EC_CODE_TOP-1);
   29f36:	021b      	lsls	r3, r3, #8
   29f38:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    _this->nbits_total+=EC_SYM_BITS;
   29f3c:	3108      	adds	r1, #8
  while(_this->rng<=EC_CODE_BOT){
   29f3e:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
    _this->rng<<=EC_SYM_BITS;
   29f42:	e9c0 2307 	strd	r2, r3, [r0, #28]
    _this->nbits_total+=EC_SYM_BITS;
   29f46:	6141      	str	r1, [r0, #20]
  while(_this->rng<=EC_CODE_BOT){
   29f48:	d9b3      	bls.n	29eb2 <ec_enc_icdf+0x32>
  }
  else _this->rng-=IMUL32(r,_icdf[_s]);
  ec_enc_normalize(_this);
}
   29f4a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else _this->ext++;
   29f4c:	6a42      	ldr	r2, [r0, #36]	; 0x24
   29f4e:	3201      	adds	r2, #1
   29f50:	6242      	str	r2, [r0, #36]	; 0x24
   29f52:	e7ed      	b.n	29f30 <ec_enc_icdf+0xb0>
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29f54:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   29f58:	e7bf      	b.n	29eda <ec_enc_icdf+0x5a>
  else _this->rng-=IMUL32(r,_icdf[_s]);
   29f5a:	5c52      	ldrb	r2, [r2, r1]
   29f5c:	fb03 4312 	mls	r3, r3, r2, r4
   29f60:	61c3      	str	r3, [r0, #28]
   29f62:	e7a0      	b.n	29ea6 <ec_enc_icdf+0x26>

00029f64 <ec_enc_uint>:

void ec_enc_uint(ec_enc *_this,opus_uint32 _fl,opus_uint32 _ft){
   29f64:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  unsigned  ft;
  unsigned  fl;
  int       ftb;
  /*In order to optimize EC_ILOG(), it is undefined for the value 0.*/
  celt_assert(_ft>1);
  _ft--;
   29f68:	1e57      	subs	r7, r2, #1
  ftb=EC_ILOG(_ft);
   29f6a:	fab7 f587 	clz	r5, r7
   29f6e:	f1c5 0320 	rsb	r3, r5, #32
  if(ftb>EC_UINT_BITS){
   29f72:	2b08      	cmp	r3, #8
void ec_enc_uint(ec_enc *_this,opus_uint32 _fl,opus_uint32 _ft){
   29f74:	460e      	mov	r6, r1
  if(ftb>EC_UINT_BITS){
   29f76:	dc05      	bgt.n	29f84 <ec_enc_uint+0x20>
    ft=(_ft>>ftb)+1;
    fl=(unsigned)(_fl>>ftb);
    ec_encode(_this,fl,fl+1,ft);
    ec_enc_bits(_this,_fl&(((opus_uint32)1<<ftb)-1U),ftb);
  }
  else ec_encode(_this,_fl,_fl+1,_ft+1);
   29f78:	4613      	mov	r3, r2
}
   29f7a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  else ec_encode(_this,_fl,_fl+1,_ft+1);
   29f7e:	1c4a      	adds	r2, r1, #1
   29f80:	f7ff be14 	b.w	29bac <ec_encode>
    ftb-=EC_UINT_BITS;
   29f84:	f1c5 0518 	rsb	r5, r5, #24
    fl=(unsigned)(_fl>>ftb);
   29f88:	40e9      	lsrs	r1, r5
    ft=(_ft>>ftb)+1;
   29f8a:	fa27 f305 	lsr.w	r3, r7, r5
    ec_encode(_this,fl,fl+1,ft);
   29f8e:	1c4a      	adds	r2, r1, #1
   29f90:	3301      	adds	r3, #1
   29f92:	4604      	mov	r4, r0
   29f94:	f7ff fe0a 	bl	29bac <ec_encode>

void ec_enc_bits(ec_enc *_this,opus_uint32 _fl,unsigned _bits){
  ec_window window;
  int       used;
  window=_this->end_window;
   29f98:	e9d0 0303 	ldrd	r0, r3, [r0, #12]
    ec_enc_bits(_this,_fl&(((opus_uint32)1<<ftb)-1U),ftb);
   29f9c:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
  used=_this->nend_bits;
  celt_assert(_bits>0);
  if(used+_bits>EC_WINDOW_SIZE){
   29fa0:	1959      	adds	r1, r3, r5
    ec_enc_bits(_this,_fl&(((opus_uint32)1<<ftb)-1U),ftb);
   29fa2:	fa07 f205 	lsl.w	r2, r7, r5
  if(used+_bits>EC_WINDOW_SIZE){
   29fa6:	2920      	cmp	r1, #32
    ec_enc_bits(_this,_fl&(((opus_uint32)1<<ftb)-1U),ftb);
   29fa8:	ea26 0202 	bic.w	r2, r6, r2
  if(used+_bits>EC_WINDOW_SIZE){
   29fac:	d927      	bls.n	29ffe <ec_enc_uint+0x9a>
   29fae:	e9d4 1601 	ldrd	r1, r6, [r4, #4]
   29fb2:	f8d4 e018 	ldr.w	lr, [r4, #24]
    do{
      _this->error|=ec_write_byte_at_end(_this,(unsigned)window&EC_SYM_MAX);
   29fb6:	46b9      	mov	r9, r7
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29fb8:	eb06 0c0e 	add.w	ip, r6, lr
  _this->buf[_this->storage-++(_this->end_offs)]=(unsigned char)_value;
   29fbc:	1c77      	adds	r7, r6, #1
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29fbe:	458c      	cmp	ip, r1
  _this->buf[_this->storage-++(_this->end_offs)]=(unsigned char)_value;
   29fc0:	eba1 0807 	sub.w	r8, r1, r7
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29fc4:	d213      	bcs.n	29fee <ec_enc_uint+0x8a>
  _this->buf[_this->storage-++(_this->end_offs)]=(unsigned char)_value;
   29fc6:	6821      	ldr	r1, [r4, #0]
   29fc8:	60a7      	str	r7, [r4, #8]
      window>>=EC_SYM_BITS;
      used-=EC_SYM_BITS;
   29fca:	3b08      	subs	r3, #8
    }
    while(used>=EC_SYM_BITS);
   29fcc:	2b07      	cmp	r3, #7
  _this->buf[_this->storage-++(_this->end_offs)]=(unsigned char)_value;
   29fce:	f801 0008 	strb.w	r0, [r1, r8]
      window>>=EC_SYM_BITS;
   29fd2:	ea4f 2010 	mov.w	r0, r0, lsr #8
    while(used>=EC_SYM_BITS);
   29fd6:	dd11      	ble.n	29ffc <ec_enc_uint+0x98>
   29fd8:	e9d4 1601 	ldrd	r1, r6, [r4, #4]
   29fdc:	f8d4 e018 	ldr.w	lr, [r4, #24]
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29fe0:	eb06 0c0e 	add.w	ip, r6, lr
  _this->buf[_this->storage-++(_this->end_offs)]=(unsigned char)_value;
   29fe4:	1c77      	adds	r7, r6, #1
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29fe6:	458c      	cmp	ip, r1
  _this->buf[_this->storage-++(_this->end_offs)]=(unsigned char)_value;
   29fe8:	eba1 0807 	sub.w	r8, r1, r7
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   29fec:	d3eb      	bcc.n	29fc6 <ec_enc_uint+0x62>
      used-=EC_SYM_BITS;
   29fee:	3b08      	subs	r3, #8
    while(used>=EC_SYM_BITS);
   29ff0:	2b07      	cmp	r3, #7
      _this->error|=ec_write_byte_at_end(_this,(unsigned)window&EC_SYM_MAX);
   29ff2:	f8c4 902c 	str.w	r9, [r4, #44]	; 0x2c
      window>>=EC_SYM_BITS;
   29ff6:	ea4f 2010 	mov.w	r0, r0, lsr #8
    while(used>=EC_SYM_BITS);
   29ffa:	dcdd      	bgt.n	29fb8 <ec_enc_uint+0x54>
   29ffc:	1959      	adds	r1, r3, r5
  }
  window|=(ec_window)_fl<<used;
  used+=_bits;
  _this->end_window=window;
  _this->nend_bits=used;
  _this->nbits_total+=_bits;
   29ffe:	6966      	ldr	r6, [r4, #20]
  _this->nend_bits=used;
   2a000:	6121      	str	r1, [r4, #16]
  window|=(ec_window)_fl<<used;
   2a002:	fa02 f303 	lsl.w	r3, r2, r3
   2a006:	4318      	orrs	r0, r3
  _this->nbits_total+=_bits;
   2a008:	4435      	add	r5, r6
  _this->end_window=window;
   2a00a:	60e0      	str	r0, [r4, #12]
  _this->nbits_total+=_bits;
   2a00c:	6165      	str	r5, [r4, #20]
}
   2a00e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2a012:	bf00      	nop

0002a014 <ec_enc_bits>:
void ec_enc_bits(ec_enc *_this,opus_uint32 _fl,unsigned _bits){
   2a014:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  window=_this->end_window;
   2a018:	e9d0 4303 	ldrd	r4, r3, [r0, #12]
  if(used+_bits>EC_WINDOW_SIZE){
   2a01c:	189d      	adds	r5, r3, r2
   2a01e:	2d20      	cmp	r5, #32
void ec_enc_bits(ec_enc *_this,opus_uint32 _fl,unsigned _bits){
   2a020:	4690      	mov	r8, r2
  if(used+_bits>EC_WINDOW_SIZE){
   2a022:	d927      	bls.n	2a074 <ec_enc_bits+0x60>
   2a024:	e9d0 5601 	ldrd	r5, r6, [r0, #4]
   2a028:	6982      	ldr	r2, [r0, #24]
      _this->error|=ec_write_byte_at_end(_this,(unsigned)window&EC_SYM_MAX);
   2a02a:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   2a02e:	eb06 0c02 	add.w	ip, r6, r2
  _this->buf[_this->storage-++(_this->end_offs)]=(unsigned char)_value;
   2a032:	1c77      	adds	r7, r6, #1
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   2a034:	45ac      	cmp	ip, r5
  _this->buf[_this->storage-++(_this->end_offs)]=(unsigned char)_value;
   2a036:	eba5 0e07 	sub.w	lr, r5, r7
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   2a03a:	d212      	bcs.n	2a062 <ec_enc_bits+0x4e>
  _this->buf[_this->storage-++(_this->end_offs)]=(unsigned char)_value;
   2a03c:	6802      	ldr	r2, [r0, #0]
   2a03e:	6087      	str	r7, [r0, #8]
      used-=EC_SYM_BITS;
   2a040:	3b08      	subs	r3, #8
    while(used>=EC_SYM_BITS);
   2a042:	2b07      	cmp	r3, #7
  _this->buf[_this->storage-++(_this->end_offs)]=(unsigned char)_value;
   2a044:	f802 400e 	strb.w	r4, [r2, lr]
      window>>=EC_SYM_BITS;
   2a048:	ea4f 2414 	mov.w	r4, r4, lsr #8
    while(used>=EC_SYM_BITS);
   2a04c:	dd10      	ble.n	2a070 <ec_enc_bits+0x5c>
   2a04e:	e9d0 5601 	ldrd	r5, r6, [r0, #4]
   2a052:	6982      	ldr	r2, [r0, #24]
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   2a054:	eb06 0c02 	add.w	ip, r6, r2
  _this->buf[_this->storage-++(_this->end_offs)]=(unsigned char)_value;
   2a058:	1c77      	adds	r7, r6, #1
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   2a05a:	45ac      	cmp	ip, r5
  _this->buf[_this->storage-++(_this->end_offs)]=(unsigned char)_value;
   2a05c:	eba5 0e07 	sub.w	lr, r5, r7
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   2a060:	d3ec      	bcc.n	2a03c <ec_enc_bits+0x28>
      used-=EC_SYM_BITS;
   2a062:	3b08      	subs	r3, #8
    while(used>=EC_SYM_BITS);
   2a064:	2b07      	cmp	r3, #7
      _this->error|=ec_write_byte_at_end(_this,(unsigned)window&EC_SYM_MAX);
   2a066:	f8c0 902c 	str.w	r9, [r0, #44]	; 0x2c
      window>>=EC_SYM_BITS;
   2a06a:	ea4f 2414 	mov.w	r4, r4, lsr #8
    while(used>=EC_SYM_BITS);
   2a06e:	dcde      	bgt.n	2a02e <ec_enc_bits+0x1a>
   2a070:	eb03 0508 	add.w	r5, r3, r8
  _this->nbits_total+=_bits;
   2a074:	6942      	ldr	r2, [r0, #20]
  _this->nend_bits=used;
   2a076:	6105      	str	r5, [r0, #16]
  window|=(ec_window)_fl<<used;
   2a078:	fa01 f303 	lsl.w	r3, r1, r3
   2a07c:	431c      	orrs	r4, r3
  _this->nbits_total+=_bits;
   2a07e:	4442      	add	r2, r8
  _this->end_window=window;
   2a080:	60c4      	str	r4, [r0, #12]
  _this->nbits_total+=_bits;
   2a082:	6142      	str	r2, [r0, #20]
}
   2a084:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0002a088 <ec_enc_patch_initial_bits>:
void ec_enc_patch_initial_bits(ec_enc *_this,unsigned _val,unsigned _nbits){
  int      shift;
  unsigned mask;
  celt_assert(_nbits<=EC_SYM_BITS);
  shift=EC_SYM_BITS-_nbits;
  mask=((1<<_nbits)-1)<<shift;
   2a088:	2301      	movs	r3, #1
void ec_enc_patch_initial_bits(ec_enc *_this,unsigned _val,unsigned _nbits){
   2a08a:	b470      	push	{r4, r5, r6}
  mask=((1<<_nbits)-1)<<shift;
   2a08c:	4093      	lsls	r3, r2
  if(_this->offs>0){
   2a08e:	6985      	ldr	r5, [r0, #24]
  mask=((1<<_nbits)-1)<<shift;
   2a090:	3b01      	subs	r3, #1
  shift=EC_SYM_BITS-_nbits;
   2a092:	f1c2 0608 	rsb	r6, r2, #8
  mask=((1<<_nbits)-1)<<shift;
   2a096:	40b3      	lsls	r3, r6
  if(_this->offs>0){
   2a098:	b9ad      	cbnz	r5, 2a0c6 <ec_enc_patch_initial_bits+0x3e>
    /*The first byte has been finalized.*/
    _this->buf[0]=(unsigned char)((_this->buf[0]&~mask)|_val<<shift);
  }
  else if(_this->rem>=0){
   2a09a:	6a84      	ldr	r4, [r0, #40]	; 0x28
   2a09c:	2c00      	cmp	r4, #0
   2a09e:	db06      	blt.n	2a0ae <ec_enc_patch_initial_bits+0x26>
    /*The first byte is still awaiting carry propagation.*/
    _this->rem=(_this->rem&~mask)|_val<<shift;
   2a0a0:	ea24 0303 	bic.w	r3, r4, r3
   2a0a4:	40b1      	lsls	r1, r6
   2a0a6:	430b      	orrs	r3, r1
   2a0a8:	6283      	str	r3, [r0, #40]	; 0x28
    _this->val=(_this->val&~((opus_uint32)mask<<EC_CODE_SHIFT))|
     (opus_uint32)_val<<(EC_CODE_SHIFT+shift);
  }
  /*The encoder hasn't even encoded _nbits of data yet.*/
  else _this->error=-1;
}
   2a0aa:	bc70      	pop	{r4, r5, r6}
   2a0ac:	4770      	bx	lr
  else if(_this->rng<=(EC_CODE_TOP>>_nbits)){
   2a0ae:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
   2a0b2:	69c4      	ldr	r4, [r0, #28]
   2a0b4:	fa25 f202 	lsr.w	r2, r5, r2
   2a0b8:	4294      	cmp	r4, r2
   2a0ba:	d90d      	bls.n	2a0d8 <ec_enc_patch_initial_bits+0x50>
  else _this->error=-1;
   2a0bc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2a0c0:	62c3      	str	r3, [r0, #44]	; 0x2c
}
   2a0c2:	bc70      	pop	{r4, r5, r6}
   2a0c4:	4770      	bx	lr
    _this->buf[0]=(unsigned char)((_this->buf[0]&~mask)|_val<<shift);
   2a0c6:	6805      	ldr	r5, [r0, #0]
   2a0c8:	7828      	ldrb	r0, [r5, #0]
   2a0ca:	40b1      	lsls	r1, r6
   2a0cc:	ea20 0303 	bic.w	r3, r0, r3
   2a0d0:	430b      	orrs	r3, r1
   2a0d2:	702b      	strb	r3, [r5, #0]
}
   2a0d4:	bc70      	pop	{r4, r5, r6}
   2a0d6:	4770      	bx	lr
    _this->val=(_this->val&~((opus_uint32)mask<<EC_CODE_SHIFT))|
   2a0d8:	6a04      	ldr	r4, [r0, #32]
     (opus_uint32)_val<<(EC_CODE_SHIFT+shift);
   2a0da:	f106 0217 	add.w	r2, r6, #23
   2a0de:	4091      	lsls	r1, r2
    _this->val=(_this->val&~((opus_uint32)mask<<EC_CODE_SHIFT))|
   2a0e0:	ea24 53c3 	bic.w	r3, r4, r3, lsl #23
   2a0e4:	4319      	orrs	r1, r3
   2a0e6:	6201      	str	r1, [r0, #32]
   2a0e8:	e7df      	b.n	2a0aa <ec_enc_patch_initial_bits+0x22>
   2a0ea:	bf00      	nop

0002a0ec <ec_enc_shrink>:

void ec_enc_shrink(ec_enc *_this,opus_uint32 _size){
   2a0ec:	b538      	push	{r3, r4, r5, lr}
   2a0ee:	460d      	mov	r5, r1
  celt_assert(_this->offs+_this->end_offs<=_size);
  OPUS_MOVE(_this->buf+_size-_this->end_offs,
   2a0f0:	e9d0 1201 	ldrd	r1, r2, [r0, #4]
   2a0f4:	6803      	ldr	r3, [r0, #0]
void ec_enc_shrink(ec_enc *_this,opus_uint32 _size){
   2a0f6:	4604      	mov	r4, r0
  OPUS_MOVE(_this->buf+_size-_this->end_offs,
   2a0f8:	1a89      	subs	r1, r1, r2
   2a0fa:	1aa8      	subs	r0, r5, r2
   2a0fc:	4419      	add	r1, r3
   2a0fe:	4418      	add	r0, r3
   2a100:	f00a ffcc 	bl	3509c <memmove>
   _this->buf+_this->storage-_this->end_offs,_this->end_offs);
  _this->storage=_size;
   2a104:	6065      	str	r5, [r4, #4]
}
   2a106:	bd38      	pop	{r3, r4, r5, pc}

0002a108 <ec_enc_done>:
  int         l;
  /*We output the minimum number of bits that ensures that the symbols encoded
     thus far will be decoded correctly regardless of the bits that follow.*/
  l=EC_CODE_BITS-EC_ILOG(_this->rng);
  msk=(EC_CODE_TOP-1)>>l;
  end=(_this->val+msk)&~msk;
   2a108:	e9d0 3207 	ldrd	r3, r2, [r0, #28]
void ec_enc_done(ec_enc *_this){
   2a10c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  l=EC_CODE_BITS-EC_ILOG(_this->rng);
   2a110:	fab3 f683 	clz	r6, r3
  msk=(EC_CODE_TOP-1)>>l;
   2a114:	f06f 4500 	mvn.w	r5, #2147483648	; 0x80000000
   2a118:	40f5      	lsrs	r5, r6
  end=(_this->val+msk)&~msk;
   2a11a:	1951      	adds	r1, r2, r5
  if((end|msk)>=_this->val+_this->rng){
   2a11c:	4413      	add	r3, r2
   2a11e:	ea41 0405 	orr.w	r4, r1, r5
   2a122:	429c      	cmp	r4, r3
void ec_enc_done(ec_enc *_this){
   2a124:	b082      	sub	sp, #8
  if((end|msk)>=_this->val+_this->rng){
   2a126:	d206      	bcs.n	2a136 <ec_enc_done+0x2e>
  end=(_this->val+msk)&~msk;
   2a128:	ea21 0505 	bic.w	r5, r1, r5
   2a12c:	6a87      	ldr	r7, [r0, #40]	; 0x28
    l++;
    msk>>=1;
    end=(_this->val+msk)&~msk;
  }
  while(l>0){
   2a12e:	2e00      	cmp	r6, #0
   2a130:	d05b      	beq.n	2a1ea <ec_enc_done+0xe2>
  l=EC_CODE_BITS-EC_ILOG(_this->rng);
   2a132:	46b1      	mov	r9, r6
   2a134:	e006      	b.n	2a144 <ec_enc_done+0x3c>
    msk>>=1;
   2a136:	086d      	lsrs	r5, r5, #1
    end=(_this->val+msk)&~msk;
   2a138:	442a      	add	r2, r5
    l++;
   2a13a:	3601      	adds	r6, #1
   2a13c:	6a87      	ldr	r7, [r0, #40]	; 0x28
    end=(_this->val+msk)&~msk;
   2a13e:	ea22 0505 	bic.w	r5, r2, r5
    l++;
   2a142:	46b1      	mov	r9, r6
      do _this->error|=ec_write_byte(_this,sym);
   2a144:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
    ec_enc_carry_out(_this,(int)(end>>EC_CODE_SHIFT));
   2a148:	ea4f 5cd5 	mov.w	ip, r5, lsr #23
  if(_c!=EC_SYM_MAX){
   2a14c:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
   2a150:	f000 8088 	beq.w	2a264 <ec_enc_done+0x15c>
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
   2a154:	2f00      	cmp	r7, #0
    carry=_c>>EC_SYM_BITS;
   2a156:	ea4f 2e2c 	mov.w	lr, ip, asr #8
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
   2a15a:	db0f      	blt.n	2a17c <ec_enc_done+0x74>
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   2a15c:	e9d0 4101 	ldrd	r4, r1, [r0, #4]
   2a160:	6982      	ldr	r2, [r0, #24]
   2a162:	4411      	add	r1, r2
   2a164:	42a1      	cmp	r1, r4
   2a166:	f080 8081 	bcs.w	2a26c <ec_enc_done+0x164>
  _this->buf[_this->offs++]=(unsigned char)_value;
   2a16a:	6803      	ldr	r3, [r0, #0]
   2a16c:	1c51      	adds	r1, r2, #1
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
   2a16e:	4477      	add	r7, lr
  _this->buf[_this->offs++]=(unsigned char)_value;
   2a170:	6181      	str	r1, [r0, #24]
   2a172:	549f      	strb	r7, [r3, r2]
  return 0;
   2a174:	2200      	movs	r2, #0
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
   2a176:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   2a178:	4313      	orrs	r3, r2
   2a17a:	62c3      	str	r3, [r0, #44]	; 0x2c
    if(_this->ext>0){
   2a17c:	6a43      	ldr	r3, [r0, #36]	; 0x24
   2a17e:	b31b      	cbz	r3, 2a1c8 <ec_enc_done+0xc0>
   2a180:	e9d0 4101 	ldrd	r4, r1, [r0, #4]
   2a184:	6982      	ldr	r2, [r0, #24]
      sym=(EC_SYM_MAX+carry)&EC_SYM_MAX;
   2a186:	f10e 0eff 	add.w	lr, lr, #255	; 0xff
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   2a18a:	1857      	adds	r7, r2, r1
   2a18c:	42a7      	cmp	r7, r4
  _this->buf[_this->offs++]=(unsigned char)_value;
   2a18e:	f102 0a01 	add.w	sl, r2, #1
      while(--(_this->ext)>0);
   2a192:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   2a196:	d212      	bcs.n	2a1be <ec_enc_done+0xb6>
  _this->buf[_this->offs++]=(unsigned char)_value;
   2a198:	6803      	ldr	r3, [r0, #0]
   2a19a:	f8c0 a018 	str.w	sl, [r0, #24]
   2a19e:	f803 e002 	strb.w	lr, [r3, r2]
      while(--(_this->ext)>0);
   2a1a2:	6a43      	ldr	r3, [r0, #36]	; 0x24
   2a1a4:	3b01      	subs	r3, #1
   2a1a6:	6243      	str	r3, [r0, #36]	; 0x24
   2a1a8:	b173      	cbz	r3, 2a1c8 <ec_enc_done+0xc0>
   2a1aa:	e9d0 4101 	ldrd	r4, r1, [r0, #4]
   2a1ae:	6982      	ldr	r2, [r0, #24]
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   2a1b0:	1857      	adds	r7, r2, r1
   2a1b2:	42a7      	cmp	r7, r4
  _this->buf[_this->offs++]=(unsigned char)_value;
   2a1b4:	f102 0a01 	add.w	sl, r2, #1
      while(--(_this->ext)>0);
   2a1b8:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   2a1bc:	d3ec      	bcc.n	2a198 <ec_enc_done+0x90>
      do _this->error|=ec_write_byte(_this,sym);
   2a1be:	f8c0 802c 	str.w	r8, [r0, #44]	; 0x2c
      while(--(_this->ext)>0);
   2a1c2:	6243      	str	r3, [r0, #36]	; 0x24
   2a1c4:	2b00      	cmp	r3, #0
   2a1c6:	d1e0      	bne.n	2a18a <ec_enc_done+0x82>
    _this->rem=_c&EC_SYM_MAX;
   2a1c8:	fa5f f78c 	uxtb.w	r7, ip
   2a1cc:	6287      	str	r7, [r0, #40]	; 0x28
    end=(end<<EC_SYM_BITS)&(EC_CODE_TOP-1);
    l-=EC_SYM_BITS;
   2a1ce:	3e08      	subs	r6, #8
    end=(end<<EC_SYM_BITS)&(EC_CODE_TOP-1);
   2a1d0:	022d      	lsls	r5, r5, #8
  while(l>0){
   2a1d2:	2e00      	cmp	r6, #0
    end=(end<<EC_SYM_BITS)&(EC_CODE_TOP-1);
   2a1d4:	f025 4500 	bic.w	r5, r5, #2147483648	; 0x80000000
  while(l>0){
   2a1d8:	dcb6      	bgt.n	2a148 <ec_enc_done+0x40>
   2a1da:	f109 36ff 	add.w	r6, r9, #4294967295	; 0xffffffff
   2a1de:	f026 0607 	bic.w	r6, r6, #7
   2a1e2:	f1a9 0908 	sub.w	r9, r9, #8
   2a1e6:	eba9 0606 	sub.w	r6, r9, r6
  }
  /*If we have a buffered byte flush it into the output buffer.*/
  if(_this->rem>=0||_this->ext>0)ec_enc_carry_out(_this,0);
   2a1ea:	2f00      	cmp	r7, #0
   2a1ec:	da41      	bge.n	2a272 <ec_enc_done+0x16a>
   2a1ee:	6a43      	ldr	r3, [r0, #36]	; 0x24
   2a1f0:	2b00      	cmp	r3, #0
   2a1f2:	d14e      	bne.n	2a292 <ec_enc_done+0x18a>
  /*If we have buffered extra bits, flush them as well.*/
  window=_this->end_window;
   2a1f4:	e9d0 5703 	ldrd	r5, r7, [r0, #12]
  used=_this->nend_bits;
  while(used>=EC_SYM_BITS){
   2a1f8:	2f07      	cmp	r7, #7
   2a1fa:	dd75      	ble.n	2a2e8 <ec_enc_done+0x1e0>
   2a1fc:	e9d0 4101 	ldrd	r4, r1, [r0, #4]
   2a200:	6982      	ldr	r2, [r0, #24]
   2a202:	463b      	mov	r3, r7
    _this->error|=ec_write_byte_at_end(_this,(unsigned)window&EC_SYM_MAX);
   2a204:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   2a208:	eb01 0e02 	add.w	lr, r1, r2
  _this->buf[_this->storage-++(_this->end_offs)]=(unsigned char)_value;
   2a20c:	f101 0c01 	add.w	ip, r1, #1
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   2a210:	45a6      	cmp	lr, r4
  _this->buf[_this->storage-++(_this->end_offs)]=(unsigned char)_value;
   2a212:	eba4 080c 	sub.w	r8, r4, ip
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   2a216:	d215      	bcs.n	2a244 <ec_enc_done+0x13c>
  _this->buf[_this->storage-++(_this->end_offs)]=(unsigned char)_value;
   2a218:	6802      	ldr	r2, [r0, #0]
   2a21a:	f8c0 c008 	str.w	ip, [r0, #8]
    window>>=EC_SYM_BITS;
    used-=EC_SYM_BITS;
   2a21e:	3b08      	subs	r3, #8
  _this->buf[_this->storage-++(_this->end_offs)]=(unsigned char)_value;
   2a220:	f802 5008 	strb.w	r5, [r2, r8]
  while(used>=EC_SYM_BITS){
   2a224:	2b07      	cmp	r3, #7
    window>>=EC_SYM_BITS;
   2a226:	ea4f 2515 	mov.w	r5, r5, lsr #8
    _this->error|=ec_write_byte_at_end(_this,(unsigned)window&EC_SYM_MAX);
   2a22a:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
  while(used>=EC_SYM_BITS){
   2a22c:	dd13      	ble.n	2a256 <ec_enc_done+0x14e>
   2a22e:	e9d0 4101 	ldrd	r4, r1, [r0, #4]
   2a232:	6982      	ldr	r2, [r0, #24]
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   2a234:	eb01 0e02 	add.w	lr, r1, r2
  _this->buf[_this->storage-++(_this->end_offs)]=(unsigned char)_value;
   2a238:	f101 0c01 	add.w	ip, r1, #1
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   2a23c:	45a6      	cmp	lr, r4
  _this->buf[_this->storage-++(_this->end_offs)]=(unsigned char)_value;
   2a23e:	eba4 080c 	sub.w	r8, r4, ip
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   2a242:	d3e9      	bcc.n	2a218 <ec_enc_done+0x110>
    used-=EC_SYM_BITS;
   2a244:	3b08      	subs	r3, #8
  while(used>=EC_SYM_BITS){
   2a246:	2b07      	cmp	r3, #7
    _this->error|=ec_write_byte_at_end(_this,(unsigned)window&EC_SYM_MAX);
   2a248:	f8c0 902c 	str.w	r9, [r0, #44]	; 0x2c
    window>>=EC_SYM_BITS;
   2a24c:	ea4f 2515 	mov.w	r5, r5, lsr #8
  while(used>=EC_SYM_BITS){
   2a250:	dcda      	bgt.n	2a208 <ec_enc_done+0x100>
    _this->error|=ec_write_byte_at_end(_this,(unsigned)window&EC_SYM_MAX);
   2a252:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   2a256:	f007 0707 	and.w	r7, r7, #7
  }
  /*Clear any excess space and add any remaining extra bits to the last byte.*/
  if(!_this->error){
   2a25a:	2900      	cmp	r1, #0
   2a25c:	d047      	beq.n	2a2ee <ec_enc_done+0x1e6>
        }
        _this->buf[_this->storage-_this->end_offs-1]|=(unsigned char)window;
      }
    }
  }
}
   2a25e:	b002      	add	sp, #8
   2a260:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  else _this->ext++;
   2a264:	6a43      	ldr	r3, [r0, #36]	; 0x24
   2a266:	3301      	adds	r3, #1
   2a268:	6243      	str	r3, [r0, #36]	; 0x24
   2a26a:	e7b0      	b.n	2a1ce <ec_enc_done+0xc6>
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   2a26c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2a270:	e781      	b.n	2a176 <ec_enc_done+0x6e>
   2a272:	e9d0 4101 	ldrd	r4, r1, [r0, #4]
   2a276:	6982      	ldr	r2, [r0, #24]
   2a278:	4411      	add	r1, r2
   2a27a:	42a1      	cmp	r1, r4
   2a27c:	d263      	bcs.n	2a346 <ec_enc_done+0x23e>
  _this->buf[_this->offs++]=(unsigned char)_value;
   2a27e:	6803      	ldr	r3, [r0, #0]
   2a280:	1c51      	adds	r1, r2, #1
   2a282:	6181      	str	r1, [r0, #24]
   2a284:	549f      	strb	r7, [r3, r2]
  return 0;
   2a286:	2100      	movs	r1, #0
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
   2a288:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
    if(_this->ext>0){
   2a28a:	6a43      	ldr	r3, [r0, #36]	; 0x24
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
   2a28c:	430a      	orrs	r2, r1
   2a28e:	62c2      	str	r2, [r0, #44]	; 0x2c
    if(_this->ext>0){
   2a290:	b323      	cbz	r3, 2a2dc <ec_enc_done+0x1d4>
   2a292:	e9d0 4101 	ldrd	r4, r1, [r0, #4]
   2a296:	6982      	ldr	r2, [r0, #24]
      do _this->error|=ec_write_byte(_this,sym);
   2a298:	f04f 3eff 	mov.w	lr, #4294967295	; 0xffffffff
  _this->buf[_this->offs++]=(unsigned char)_value;
   2a29c:	f04f 0cff 	mov.w	ip, #255	; 0xff
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   2a2a0:	1855      	adds	r5, r2, r1
   2a2a2:	42a5      	cmp	r5, r4
  _this->buf[_this->offs++]=(unsigned char)_value;
   2a2a4:	f102 0701 	add.w	r7, r2, #1
      while(--(_this->ext)>0);
   2a2a8:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   2a2ac:	d211      	bcs.n	2a2d2 <ec_enc_done+0x1ca>
  _this->buf[_this->offs++]=(unsigned char)_value;
   2a2ae:	6803      	ldr	r3, [r0, #0]
   2a2b0:	6187      	str	r7, [r0, #24]
   2a2b2:	f803 c002 	strb.w	ip, [r3, r2]
      while(--(_this->ext)>0);
   2a2b6:	6a43      	ldr	r3, [r0, #36]	; 0x24
   2a2b8:	3b01      	subs	r3, #1
   2a2ba:	6243      	str	r3, [r0, #36]	; 0x24
   2a2bc:	b173      	cbz	r3, 2a2dc <ec_enc_done+0x1d4>
   2a2be:	e9d0 4101 	ldrd	r4, r1, [r0, #4]
   2a2c2:	6982      	ldr	r2, [r0, #24]
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   2a2c4:	1855      	adds	r5, r2, r1
   2a2c6:	42a5      	cmp	r5, r4
  _this->buf[_this->offs++]=(unsigned char)_value;
   2a2c8:	f102 0701 	add.w	r7, r2, #1
      while(--(_this->ext)>0);
   2a2cc:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   2a2d0:	d3ed      	bcc.n	2a2ae <ec_enc_done+0x1a6>
      do _this->error|=ec_write_byte(_this,sym);
   2a2d2:	f8c0 e02c 	str.w	lr, [r0, #44]	; 0x2c
      while(--(_this->ext)>0);
   2a2d6:	6243      	str	r3, [r0, #36]	; 0x24
   2a2d8:	2b00      	cmp	r3, #0
   2a2da:	d1e1      	bne.n	2a2a0 <ec_enc_done+0x198>
  window=_this->end_window;
   2a2dc:	e9d0 5703 	ldrd	r5, r7, [r0, #12]
    _this->rem=_c&EC_SYM_MAX;
   2a2e0:	2300      	movs	r3, #0
  while(used>=EC_SYM_BITS){
   2a2e2:	2f07      	cmp	r7, #7
    _this->rem=_c&EC_SYM_MAX;
   2a2e4:	6283      	str	r3, [r0, #40]	; 0x28
  while(used>=EC_SYM_BITS){
   2a2e6:	dc89      	bgt.n	2a1fc <ec_enc_done+0xf4>
   2a2e8:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
  if(!_this->error){
   2a2ea:	2900      	cmp	r1, #0
   2a2ec:	d1b7      	bne.n	2a25e <ec_enc_done+0x156>
   2a2ee:	4604      	mov	r4, r0
    OPUS_CLEAR(_this->buf+_this->offs,
   2a2f0:	6980      	ldr	r0, [r0, #24]
   2a2f2:	6823      	ldr	r3, [r4, #0]
   2a2f4:	9301      	str	r3, [sp, #4]
   2a2f6:	6863      	ldr	r3, [r4, #4]
   2a2f8:	68a2      	ldr	r2, [r4, #8]
   2a2fa:	eba3 0c00 	sub.w	ip, r3, r0
   2a2fe:	9b01      	ldr	r3, [sp, #4]
   2a300:	ebac 0202 	sub.w	r2, ip, r2
   2a304:	4418      	add	r0, r3
   2a306:	f00a ff2d 	bl	35164 <memset>
    if(used>0){
   2a30a:	2f00      	cmp	r7, #0
   2a30c:	dda7      	ble.n	2a25e <ec_enc_done+0x156>
      if(_this->end_offs>=_this->storage)_this->error=-1;
   2a30e:	e9d4 3201 	ldrd	r3, r2, [r4, #4]
   2a312:	429a      	cmp	r2, r3
   2a314:	d21a      	bcs.n	2a34c <ec_enc_done+0x244>
        if(_this->offs+_this->end_offs>=_this->storage&&l<used){
   2a316:	69a1      	ldr	r1, [r4, #24]
   2a318:	4411      	add	r1, r2
   2a31a:	428b      	cmp	r3, r1
   2a31c:	d80a      	bhi.n	2a334 <ec_enc_done+0x22c>
        l=-l;
   2a31e:	4276      	negs	r6, r6
        if(_this->offs+_this->end_offs>=_this->storage&&l<used){
   2a320:	42be      	cmp	r6, r7
   2a322:	da07      	bge.n	2a334 <ec_enc_done+0x22c>
          window&=(1<<l)-1;
   2a324:	2101      	movs	r1, #1
   2a326:	fa01 f606 	lsl.w	r6, r1, r6
   2a32a:	1e71      	subs	r1, r6, #1
          _this->error=-1;
   2a32c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
          window&=(1<<l)-1;
   2a330:	400d      	ands	r5, r1
          _this->error=-1;
   2a332:	62e0      	str	r0, [r4, #44]	; 0x2c
        _this->buf[_this->storage-_this->end_offs-1]|=(unsigned char)window;
   2a334:	3b01      	subs	r3, #1
   2a336:	1a9b      	subs	r3, r3, r2
   2a338:	6821      	ldr	r1, [r4, #0]
   2a33a:	5cca      	ldrb	r2, [r1, r3]
   2a33c:	4315      	orrs	r5, r2
   2a33e:	54cd      	strb	r5, [r1, r3]
}
   2a340:	b002      	add	sp, #8
   2a342:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
   2a346:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   2a34a:	e79d      	b.n	2a288 <ec_enc_done+0x180>
      if(_this->end_offs>=_this->storage)_this->error=-1;
   2a34c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2a350:	62e3      	str	r3, [r4, #44]	; 0x2c
}
   2a352:	b002      	add	sp, #8
   2a354:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0002a358 <opus_fft_impl>:
}

#endif /* CUSTOM_MODES */

void opus_fft_impl(const kiss_fft_state *st,kiss_fft_cpx *fout)
{
   2a358:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

    fstride[0] = 1;
    L=0;
    do {
       p = st->factors[2*L];
       m = st->factors[2*L+1];
   2a35c:	f9b0 2012 	ldrsh.w	r2, [r0, #18]
    shift = st->shift>0 ? st->shift : 0;
   2a360:	68c4      	ldr	r4, [r0, #12]
{
   2a362:	b0b5      	sub	sp, #212	; 0xd4
    fstride[0] = 1;
   2a364:	2301      	movs	r3, #1
{
   2a366:	4605      	mov	r5, r0
   2a368:	9029      	str	r0, [sp, #164]	; 0xa4
   2a36a:	912a      	str	r1, [sp, #168]	; 0xa8
       p = st->factors[2*L];
   2a36c:	f9b0 0010 	ldrsh.w	r0, [r0, #16]
   2a370:	902d      	str	r0, [sp, #180]	; 0xb4
    shift = st->shift>0 ? st->shift : 0;
   2a372:	ea24 71e4 	bic.w	r1, r4, r4, asr #31
       fstride[L+1] = fstride[L]*p;
       L++;
    } while(m!=1);
   2a376:	429a      	cmp	r2, r3
    fstride[0] = 1;
   2a378:	e9cd 132b 	strd	r1, r3, [sp, #172]	; 0xac
    } while(m!=1);
   2a37c:	f000 8667 	beq.w	2b04e <opus_fft_impl+0xcf6>
       fstride[L+1] = fstride[L]*p;
   2a380:	8aab      	ldrh	r3, [r5, #20]
       m = st->factors[2*L+1];
   2a382:	f9b5 2016 	ldrsh.w	r2, [r5, #22]
       fstride[L+1] = fstride[L]*p;
   2a386:	fb13 f300 	smulbb	r3, r3, r0
    } while(m!=1);
   2a38a:	2a01      	cmp	r2, #1
       fstride[L+1] = fstride[L]*p;
   2a38c:	932e      	str	r3, [sp, #184]	; 0xb8
    } while(m!=1);
   2a38e:	f000 8663 	beq.w	2b058 <opus_fft_impl+0xd00>
       p = st->factors[2*L];
   2a392:	f9b5 1018 	ldrsh.w	r1, [r5, #24]
       m = st->factors[2*L+1];
   2a396:	f9b5 201a 	ldrsh.w	r2, [r5, #26]
       fstride[L+1] = fstride[L]*p;
   2a39a:	fb03 f301 	mul.w	r3, r3, r1
    } while(m!=1);
   2a39e:	2a01      	cmp	r2, #1
       fstride[L+1] = fstride[L]*p;
   2a3a0:	932f      	str	r3, [sp, #188]	; 0xbc
    } while(m!=1);
   2a3a2:	f000 8671 	beq.w	2b088 <opus_fft_impl+0xd30>
       p = st->factors[2*L];
   2a3a6:	f9b5 101c 	ldrsh.w	r1, [r5, #28]
       m = st->factors[2*L+1];
   2a3aa:	f9b5 201e 	ldrsh.w	r2, [r5, #30]
       fstride[L+1] = fstride[L]*p;
   2a3ae:	fb03 f301 	mul.w	r3, r3, r1
    } while(m!=1);
   2a3b2:	2a01      	cmp	r2, #1
       fstride[L+1] = fstride[L]*p;
   2a3b4:	9330      	str	r3, [sp, #192]	; 0xc0
    } while(m!=1);
   2a3b6:	f000 866d 	beq.w	2b094 <opus_fft_impl+0xd3c>
       p = st->factors[2*L];
   2a3ba:	f9b5 1020 	ldrsh.w	r1, [r5, #32]
       m = st->factors[2*L+1];
   2a3be:	f9b5 2022 	ldrsh.w	r2, [r5, #34]	; 0x22
       fstride[L+1] = fstride[L]*p;
   2a3c2:	fb03 f301 	mul.w	r3, r3, r1
    } while(m!=1);
   2a3c6:	2a01      	cmp	r2, #1
       fstride[L+1] = fstride[L]*p;
   2a3c8:	9331      	str	r3, [sp, #196]	; 0xc4
    } while(m!=1);
   2a3ca:	f000 863a 	beq.w	2b042 <opus_fft_impl+0xcea>
       p = st->factors[2*L];
   2a3ce:	f9b5 1024 	ldrsh.w	r1, [r5, #36]	; 0x24
       m = st->factors[2*L+1];
   2a3d2:	f9b5 2026 	ldrsh.w	r2, [r5, #38]	; 0x26
       fstride[L+1] = fstride[L]*p;
   2a3d6:	fb03 f301 	mul.w	r3, r3, r1
    } while(m!=1);
   2a3da:	2a01      	cmp	r2, #1
       fstride[L+1] = fstride[L]*p;
   2a3dc:	9332      	str	r3, [sp, #200]	; 0xc8
    } while(m!=1);
   2a3de:	f000 865f 	beq.w	2b0a0 <opus_fft_impl+0xd48>
       p = st->factors[2*L];
   2a3e2:	f9b5 2028 	ldrsh.w	r2, [r5, #40]	; 0x28
       fstride[L+1] = fstride[L]*p;
   2a3e6:	fb03 f302 	mul.w	r3, r3, r2
   2a3ea:	9333      	str	r3, [sp, #204]	; 0xcc
   2a3ec:	2306      	movs	r3, #6
   2a3ee:	931c      	str	r3, [sp, #112]	; 0x70
   2a3f0:	2207      	movs	r2, #7
   2a3f2:	462b      	mov	r3, r5
    m = st->factors[2*L-1];
   2a3f4:	eb03 0282 	add.w	r2, r3, r2, lsl #2
   2a3f8:	f9b2 200e 	ldrsh.w	r2, [r2, #14]
   2a3fc:	9210      	str	r2, [sp, #64]	; 0x40
   2a3fe:	9a1c      	ldr	r2, [sp, #112]	; 0x70
   2a400:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   2a404:	931d      	str	r3, [sp, #116]	; 0x74
   2a406:	4613      	mov	r3, r2
    for (i=L-1;i>=0;i--)
    {
       if (i!=0)
   2a408:	2b00      	cmp	r3, #0
   2a40a:	f000 862a 	beq.w	2b062 <opus_fft_impl+0xd0a>
          m2 = st->factors[2*i-1];
       else
          m2 = 1;
       switch (st->factors[2*i])
   2a40e:	9a1d      	ldr	r2, [sp, #116]	; 0x74
   2a410:	f9b2 3010 	ldrsh.w	r3, [r2, #16]
          m2 = st->factors[2*i-1];
   2a414:	f9b2 200e 	ldrsh.w	r2, [r2, #14]
   2a418:	921f      	str	r2, [sp, #124]	; 0x7c
       switch (st->factors[2*i])
   2a41a:	3b02      	subs	r3, #2
   2a41c:	2b03      	cmp	r3, #3
   2a41e:	f200 8349 	bhi.w	2aab4 <opus_fft_impl+0x75c>
   2a422:	e8df f013 	tbh	[pc, r3, lsl #1]
   2a426:	0004      	.short	0x0004
   2a428:	035304b4 	.word	0x035304b4
   2a42c:	00af      	.short	0x00af
          m2 = st->factors[2*i-1];
   2a42e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   2a430:	9310      	str	r3, [sp, #64]	; 0x40
       {
       case 2:
          kf_bfly2(fout, m, fstride[i]);
   2a432:	9b1c      	ldr	r3, [sp, #112]	; 0x70
   2a434:	aa2c      	add	r2, sp, #176	; 0xb0
   2a436:	f852 9023 	ldr.w	r9, [r2, r3, lsl #2]
      for (i=0;i<N;i++)
   2a43a:	f1b9 0f00 	cmp.w	r9, #0
   2a43e:	f340 8094 	ble.w	2a56a <opus_fft_impl+0x212>
   2a442:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
   2a444:	f04f 0e00 	mov.w	lr, #0
   2a448:	f103 0440 	add.w	r4, r3, #64	; 0x40
         t.r = S_MUL(SUB32_ovflw(Fout2[3].i, Fout2[3].r), tw);
   2a44c:	e954 7102 	ldrd	r7, r1, [r4, #-8]
   2a450:	b2bd      	uxth	r5, r7
   2a452:	b28b      	uxth	r3, r1
         t.r = S_MUL(ADD32_ovflw(Fout2[1].r, Fout2[1].i), tw);
   2a454:	e954 6206 	ldrd	r6, r2, [r4, #-24]
         t.i = S_MUL(NEG32_ovflw(ADD32_ovflw(Fout2[3].i, Fout2[3].r)), tw);
   2a458:	1958      	adds	r0, r3, r5
         t.r = S_MUL(SUB32_ovflw(Fout2[3].i, Fout2[3].r), tw);
   2a45a:	1b5b      	subs	r3, r3, r5
         t.i = S_MUL(NEG32_ovflw(ADD32_ovflw(Fout2[3].i, Fout2[3].r)), tw);
   2a45c:	4240      	negs	r0, r0
   2a45e:	19cd      	adds	r5, r1, r7
         t.r = S_MUL(SUB32_ovflw(Fout2[3].i, Fout2[3].r), tw);
   2a460:	b29b      	uxth	r3, r3
   2a462:	1bc9      	subs	r1, r1, r7
         t.i = S_MUL(NEG32_ovflw(ADD32_ovflw(Fout2[3].i, Fout2[3].r)), tw);
   2a464:	f645 2782 	movw	r7, #23170	; 0x5a82
         t.r = S_MUL(SUB32_ovflw(Fout2[3].i, Fout2[3].r), tw);
   2a468:	fb07 f303 	mul.w	r3, r7, r3
         t.i = S_MUL(NEG32_ovflw(ADD32_ovflw(Fout2[3].i, Fout2[3].r)), tw);
   2a46c:	b280      	uxth	r0, r0
   2a46e:	426d      	negs	r5, r5
         t.r = S_MUL(SUB32_ovflw(Fout2[3].i, Fout2[3].r), tw);
   2a470:	1409      	asrs	r1, r1, #16
         t.r = S_MUL(ADD32_ovflw(Fout2[1].r, Fout2[1].i), tw);
   2a472:	fa1f f886 	uxth.w	r8, r6
   2a476:	fa1f fc82 	uxth.w	ip, r2
         t.r = S_MUL(SUB32_ovflw(Fout2[3].i, Fout2[3].r), tw);
   2a47a:	fb07 f101 	mul.w	r1, r7, r1
         t.i = S_MUL(NEG32_ovflw(ADD32_ovflw(Fout2[3].i, Fout2[3].r)), tw);
   2a47e:	fb07 f000 	mul.w	r0, r7, r0
   2a482:	142d      	asrs	r5, r5, #16
         t.r = S_MUL(SUB32_ovflw(Fout2[3].i, Fout2[3].r), tw);
   2a484:	13db      	asrs	r3, r3, #15
   2a486:	eb03 0341 	add.w	r3, r3, r1, lsl #1
         t.i = S_MUL(NEG32_ovflw(ADD32_ovflw(Fout2[3].i, Fout2[3].r)), tw);
   2a48a:	fb07 f505 	mul.w	r5, r7, r5
         t.i = S_MUL(SUB32_ovflw(Fout2[1].i, Fout2[1].r), tw);
   2a48e:	ebac 0108 	sub.w	r1, ip, r8
         t.r = S_MUL(ADD32_ovflw(Fout2[1].r, Fout2[1].i), tw);
   2a492:	eb08 070c 	add.w	r7, r8, ip
         t.i = S_MUL(NEG32_ovflw(ADD32_ovflw(Fout2[3].i, Fout2[3].r)), tw);
   2a496:	13c0      	asrs	r0, r0, #15
   2a498:	eb00 0045 	add.w	r0, r0, r5, lsl #1
         t.r = S_MUL(ADD32_ovflw(Fout2[1].r, Fout2[1].i), tw);
   2a49c:	eb06 0c02 	add.w	ip, r6, r2
   2a4a0:	f645 2582 	movw	r5, #23170	; 0x5a82
         t.i = S_MUL(SUB32_ovflw(Fout2[1].i, Fout2[1].r), tw);
   2a4a4:	1b92      	subs	r2, r2, r6
         t.r = S_MUL(ADD32_ovflw(Fout2[1].r, Fout2[1].i), tw);
   2a4a6:	b2bf      	uxth	r7, r7
         t.i = S_MUL(SUB32_ovflw(Fout2[1].i, Fout2[1].r), tw);
   2a4a8:	b289      	uxth	r1, r1
         t.r = S_MUL(ADD32_ovflw(Fout2[1].r, Fout2[1].i), tw);
   2a4aa:	fb05 f707 	mul.w	r7, r5, r7
         t.i = S_MUL(SUB32_ovflw(Fout2[1].i, Fout2[1].r), tw);
   2a4ae:	fb05 f101 	mul.w	r1, r5, r1
         t.r = S_MUL(ADD32_ovflw(Fout2[1].r, Fout2[1].i), tw);
   2a4b2:	ea4f 462c 	mov.w	r6, ip, asr #16
         t.i = S_MUL(SUB32_ovflw(Fout2[1].i, Fout2[1].r), tw);
   2a4b6:	1412      	asrs	r2, r2, #16
         C_SUB( Fout2[3] ,  Fout[3] , t );
   2a4b8:	f854 ac24 	ldr.w	sl, [r4, #-36]
         t.r = S_MUL(ADD32_ovflw(Fout2[1].r, Fout2[1].i), tw);
   2a4bc:	fb05 f606 	mul.w	r6, r5, r6
         t.i = S_MUL(SUB32_ovflw(Fout2[1].i, Fout2[1].r), tw);
   2a4c0:	13c9      	asrs	r1, r1, #15
   2a4c2:	fb05 f202 	mul.w	r2, r5, r2
         t.r = S_MUL(ADD32_ovflw(Fout2[1].r, Fout2[1].i), tw);
   2a4c6:	13ff      	asrs	r7, r7, #15
         t.i = S_MUL(SUB32_ovflw(Fout2[1].i, Fout2[1].r), tw);
   2a4c8:	eb01 0242 	add.w	r2, r1, r2, lsl #1
         t.r = S_MUL(ADD32_ovflw(Fout2[1].r, Fout2[1].i), tw);
   2a4cc:	eb07 0746 	add.w	r7, r7, r6, lsl #1
         C_SUB( Fout2[3] ,  Fout[3] , t );
   2a4d0:	f854 1c28 	ldr.w	r1, [r4, #-40]
         t = Fout2[0];
   2a4d4:	f854 5c1c 	ldr.w	r5, [r4, #-28]
         C_SUB( Fout2[1] ,  Fout[1] , t );
   2a4d8:	e954 c60e 	ldrd	ip, r6, [r4, #-56]	; 0x38
         C_SUB( Fout2[3] ,  Fout[3] , t );
   2a4dc:	ebaa 0800 	sub.w	r8, sl, r0
         C_ADDTO( Fout[3] ,  t );
   2a4e0:	4450      	add	r0, sl
   2a4e2:	f844 0c24 	str.w	r0, [r4, #-36]
         C_SUB( Fout2[3] ,  Fout[3] , t );
   2a4e6:	1ac8      	subs	r0, r1, r3
   2a4e8:	f844 0c08 	str.w	r0, [r4, #-8]
         C_ADDTO( Fout[3] ,  t );
   2a4ec:	4419      	add	r1, r3
         C_SUB( Fout2[0] ,  Fout[0] , t );
   2a4ee:	f854 0c3c 	ldr.w	r0, [r4, #-60]
         C_ADDTO( Fout[3] ,  t );
   2a4f2:	f844 1c28 	str.w	r1, [r4, #-40]
         C_SUB( Fout2[1] ,  Fout[1] , t );
   2a4f6:	ebac 0307 	sub.w	r3, ip, r7
   2a4fa:	f844 3c18 	str.w	r3, [r4, #-24]
         C_ADDTO( Fout[1] ,  t );
   2a4fe:	18b3      	adds	r3, r6, r2
         C_SUB( Fout2[0] ,  Fout[0] , t );
   2a500:	f854 1c40 	ldr.w	r1, [r4, #-64]
         C_ADDTO( Fout[1] ,  t );
   2a504:	f844 3c34 	str.w	r3, [r4, #-52]
   2a508:	4467      	add	r7, ip
         C_SUB( Fout2[0] ,  Fout[0] , t );
   2a50a:	1b43      	subs	r3, r0, r5
   2a50c:	f854 cc20 	ldr.w	ip, [r4, #-32]
         C_ADDTO( Fout[1] ,  t );
   2a510:	f844 7c38 	str.w	r7, [r4, #-56]
         C_ADDTO( Fout[0] ,  t );
   2a514:	4428      	add	r0, r5
         C_SUB( Fout2[1] ,  Fout[1] , t );
   2a516:	1ab7      	subs	r7, r6, r2
         C_SUB( Fout2[2] ,  Fout[2] , t );
   2a518:	f854 5c0c 	ldr.w	r5, [r4, #-12]
         t.i = -Fout2[2].r;
   2a51c:	f854 6c10 	ldr.w	r6, [r4, #-16]
         C_SUB( Fout2[2] ,  Fout[2] , t );
   2a520:	f854 2c2c 	ldr.w	r2, [r4, #-44]
         C_SUB( Fout2[0] ,  Fout[0] , t );
   2a524:	f844 3c1c 	str.w	r3, [r4, #-28]
         C_SUB( Fout2[2] ,  Fout[2] , t );
   2a528:	f854 3c30 	ldr.w	r3, [r4, #-48]
         C_ADDTO( Fout[0] ,  t );
   2a52c:	f844 0c3c 	str.w	r0, [r4, #-60]
      for (i=0;i<N;i++)
   2a530:	f10e 0e01 	add.w	lr, lr, #1
         C_SUB( Fout2[0] ,  Fout[0] , t );
   2a534:	eba1 000c 	sub.w	r0, r1, ip
         C_SUB( Fout2[1] ,  Fout[1] , t );
   2a538:	f844 7c14 	str.w	r7, [r4, #-20]
         C_SUB( Fout2[0] ,  Fout[0] , t );
   2a53c:	f844 0c20 	str.w	r0, [r4, #-32]
         C_SUB( Fout2[2] ,  Fout[2] , t );
   2a540:	18b7      	adds	r7, r6, r2
   2a542:	1b58      	subs	r0, r3, r5
         C_ADDTO( Fout[0] ,  t );
   2a544:	4461      	add	r1, ip
         C_ADDTO( Fout[2] ,  t );
   2a546:	1b92      	subs	r2, r2, r6
   2a548:	442b      	add	r3, r5
      for (i=0;i<N;i++)
   2a54a:	45f1      	cmp	r9, lr
         C_SUB( Fout2[3] ,  Fout[3] , t );
   2a54c:	f844 8c04 	str.w	r8, [r4, #-4]
         C_ADDTO( Fout[0] ,  t );
   2a550:	f844 1c40 	str.w	r1, [r4, #-64]
         C_ADDTO( Fout[2] ,  t );
   2a554:	f844 2c2c 	str.w	r2, [r4, #-44]
         C_SUB( Fout2[2] ,  Fout[2] , t );
   2a558:	e944 0704 	strd	r0, r7, [r4, #-16]
         C_ADDTO( Fout[2] ,  t );
   2a55c:	f844 3c30 	str.w	r3, [r4, #-48]
   2a560:	f104 0440 	add.w	r4, r4, #64	; 0x40
      for (i=0;i<N;i++)
   2a564:	f47f af72 	bne.w	2a44c <opus_fft_impl+0xf4>
   2a568:	9b1c      	ldr	r3, [sp, #112]	; 0x70
   2a56a:	9a1d      	ldr	r2, [sp, #116]	; 0x74
    for (i=L-1;i>=0;i--)
   2a56c:	3b01      	subs	r3, #1
   2a56e:	3a04      	subs	r2, #4
   2a570:	921d      	str	r2, [sp, #116]	; 0x74
   2a572:	1c5a      	adds	r2, r3, #1
   2a574:	931c      	str	r3, [sp, #112]	; 0x70
   2a576:	f47f af47 	bne.w	2a408 <opus_fft_impl+0xb0>
          break;
 #endif
       }
       m = m2;
    }
}
   2a57a:	b035      	add	sp, #212	; 0xd4
   2a57c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          m2 = 1;
   2a580:	2301      	movs	r3, #1
   2a582:	931f      	str	r3, [sp, #124]	; 0x7c
          kf_bfly5(fout,fstride[i]<<shift,st,m, fstride[i], m2);
   2a584:	9b1c      	ldr	r3, [sp, #112]	; 0x70
   2a586:	992b      	ldr	r1, [sp, #172]	; 0xac
   2a588:	aa2c      	add	r2, sp, #176	; 0xb0
   2a58a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
   2a58e:	9b29      	ldr	r3, [sp, #164]	; 0xa4
   2a590:	9222      	str	r2, [sp, #136]	; 0x88
   2a592:	6b58      	ldr	r0, [r3, #52]	; 0x34
   for (i=0;i<N;i++)
   2a594:	2a00      	cmp	r2, #0
          kf_bfly5(fout,fstride[i]<<shift,st,m, fstride[i], m2);
   2a596:	4613      	mov	r3, r2
   2a598:	fa03 f301 	lsl.w	r3, r3, r1
   for (i=0;i<N;i++)
   2a59c:	f340 828a 	ble.w	2aab4 <opus_fft_impl+0x75c>
      Fout3=Fout0+3*m;
   2a5a0:	9a10      	ldr	r2, [sp, #64]	; 0x40
   2a5a2:	eb02 0442 	add.w	r4, r2, r2, lsl #1
   2a5a6:	2a00      	cmp	r2, #0
   2a5a8:	ea4f 04c4 	mov.w	r4, r4, lsl #3
      Fout1=Fout0+m;
   2a5ac:	ea4f 06c2 	mov.w	r6, r2, lsl #3
      Fout2=Fout0+2*m;
   2a5b0:	ea4f 1502 	mov.w	r5, r2, lsl #4
      Fout4=Fout0+4*m;
   2a5b4:	ea4f 1142 	mov.w	r1, r2, lsl #5
   2a5b8:	f340 827c 	ble.w	2aab4 <opus_fft_impl+0x75c>
   2a5bc:	3002      	adds	r0, #2
   2a5be:	eb02 0782 	add.w	r7, r2, r2, lsl #2
   2a5c2:	9028      	str	r0, [sp, #160]	; 0xa0
   2a5c4:	460a      	mov	r2, r1
   2a5c6:	982a      	ldr	r0, [sp, #168]	; 0xa8
   2a5c8:	9121      	str	r1, [sp, #132]	; 0x84
   2a5ca:	3208      	adds	r2, #8
   2a5cc:	eb03 0143 	add.w	r1, r3, r3, lsl #1
   2a5d0:	1882      	adds	r2, r0, r2
   2a5d2:	921e      	str	r2, [sp, #120]	; 0x78
   2a5d4:	008a      	lsls	r2, r1, #2
   2a5d6:	921b      	str	r2, [sp, #108]	; 0x6c
   2a5d8:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   2a5da:	00ff      	lsls	r7, r7, #3
   2a5dc:	00d2      	lsls	r2, r2, #3
   2a5de:	9724      	str	r7, [sp, #144]	; 0x90
   2a5e0:	9223      	str	r2, [sp, #140]	; 0x8c
   2a5e2:	9f21      	ldr	r7, [sp, #132]	; 0x84
   2a5e4:	009a      	lsls	r2, r3, #2
   2a5e6:	921a      	str	r2, [sp, #104]	; 0x68
   2a5e8:	00da      	lsls	r2, r3, #3
   2a5ea:	011b      	lsls	r3, r3, #4
   2a5ec:	1bf6      	subs	r6, r6, r7
   2a5ee:	1bed      	subs	r5, r5, r7
   2a5f0:	1be4      	subs	r4, r4, r7
   2a5f2:	9318      	str	r3, [sp, #96]	; 0x60
   for (i=0;i<N;i++)
   2a5f4:	2300      	movs	r3, #0
   2a5f6:	9625      	str	r6, [sp, #148]	; 0x94
   2a5f8:	9526      	str	r5, [sp, #152]	; 0x98
   2a5fa:	9427      	str	r4, [sp, #156]	; 0x9c
   2a5fc:	9219      	str	r2, [sp, #100]	; 0x64
   2a5fe:	9320      	str	r3, [sp, #128]	; 0x80
   2a600:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   2a602:	9a21      	ldr	r2, [sp, #132]	; 0x84
   2a604:	9924      	ldr	r1, [sp, #144]	; 0x90
   2a606:	9302      	str	r3, [sp, #8]
   2a608:	1a9a      	subs	r2, r3, r2
   2a60a:	9201      	str	r2, [sp, #4]
   2a60c:	188a      	adds	r2, r1, r2
   2a60e:	9217      	str	r2, [sp, #92]	; 0x5c
   2a610:	9a25      	ldr	r2, [sp, #148]	; 0x94
   2a612:	441a      	add	r2, r3
   2a614:	9209      	str	r2, [sp, #36]	; 0x24
   2a616:	9a26      	ldr	r2, [sp, #152]	; 0x98
   2a618:	441a      	add	r2, r3
   2a61a:	9208      	str	r2, [sp, #32]
   2a61c:	9a27      	ldr	r2, [sp, #156]	; 0x9c
   2a61e:	441a      	add	r2, r3
   2a620:	9207      	str	r2, [sp, #28]
   2a622:	9a28      	ldr	r2, [sp, #160]	; 0xa0
   2a624:	9206      	str	r2, [sp, #24]
   2a626:	e9cd 2203 	strd	r2, r2, [sp, #12]
   2a62a:	9205      	str	r2, [sp, #20]
         C_MUL(scratch[4] ,*Fout4, tw[4*u*fstride]);
   2a62c:	9802      	ldr	r0, [sp, #8]
         C_MUL(scratch[1] ,*Fout1, tw[u*fstride]);
   2a62e:	9b09      	ldr	r3, [sp, #36]	; 0x24
         C_MUL(scratch[4] ,*Fout4, tw[4*u*fstride]);
   2a630:	e950 a402 	ldrd	sl, r4, [r0, #-8]
   2a634:	940e      	str	r4, [sp, #56]	; 0x38
         C_MUL(scratch[2] ,*Fout2, tw[2*u*fstride]);
   2a636:	9c08      	ldr	r4, [sp, #32]
         C_MUL(scratch[1] ,*Fout1, tw[u*fstride]);
   2a638:	f853 2c08 	ldr.w	r2, [r3, #-8]
         C_MUL(scratch[2] ,*Fout2, tw[2*u*fstride]);
   2a63c:	f854 6c08 	ldr.w	r6, [r4, #-8]
   2a640:	960d      	str	r6, [sp, #52]	; 0x34
         C_MUL(scratch[3] ,*Fout3, tw[3*u*fstride]);
   2a642:	9e07      	ldr	r6, [sp, #28]
         C_MUL(scratch[2] ,*Fout2, tw[2*u*fstride]);
   2a644:	f854 7c04 	ldr.w	r7, [r4, #-4]
         C_MUL(scratch[3] ,*Fout3, tw[3*u*fstride]);
   2a648:	f856 0c04 	ldr.w	r0, [r6, #-4]
         C_MUL(scratch[2] ,*Fout2, tw[2*u*fstride]);
   2a64c:	970f      	str	r7, [sp, #60]	; 0x3c
         C_MUL(scratch[3] ,*Fout3, tw[3*u*fstride]);
   2a64e:	9011      	str	r0, [sp, #68]	; 0x44
         C_MUL(scratch[1] ,*Fout1, tw[u*fstride]);
   2a650:	9f06      	ldr	r7, [sp, #24]
         C_MUL(scratch[4] ,*Fout4, tw[4*u*fstride]);
   2a652:	9803      	ldr	r0, [sp, #12]
         C_MUL(scratch[3] ,*Fout3, tw[3*u*fstride]);
   2a654:	f856 1c08 	ldr.w	r1, [r6, #-8]
         C_MUL(scratch[2] ,*Fout2, tw[2*u*fstride]);
   2a658:	9e05      	ldr	r6, [sp, #20]
         C_MUL(scratch[1] ,*Fout1, tw[u*fstride]);
   2a65a:	f937 cc02 	ldrsh.w	ip, [r7, #-2]
         C_MUL(scratch[4] ,*Fout4, tw[4*u*fstride]);
   2a65e:	f9b0 4000 	ldrsh.w	r4, [r0]
         C_MUL(scratch[1] ,*Fout1, tw[u*fstride]);
   2a662:	f853 5c04 	ldr.w	r5, [r3, #-4]
         C_MUL(scratch[4] ,*Fout4, tw[4*u*fstride]);
   2a666:	f930 3c02 	ldrsh.w	r3, [r0, #-2]
         C_MUL(scratch[3] ,*Fout3, tw[3*u*fstride]);
   2a66a:	9804      	ldr	r0, [sp, #16]
         C_MUL(scratch[2] ,*Fout2, tw[2*u*fstride]);
   2a66c:	f9b6 e000 	ldrsh.w	lr, [r6]
         C_MUL(scratch[3] ,*Fout3, tw[3*u*fstride]);
   2a670:	9110      	str	r1, [sp, #64]	; 0x40
   2a672:	fa1f f982 	uxth.w	r9, r2
         C_MUL(scratch[1] ,*Fout1, tw[u*fstride]);
   2a676:	f9b7 1000 	ldrsh.w	r1, [r7]
         C_MUL(scratch[2] ,*Fout2, tw[2*u*fstride]);
   2a67a:	f8cd e028 	str.w	lr, [sp, #40]	; 0x28
         C_MUL(scratch[1] ,*Fout1, tw[u*fstride]);
   2a67e:	ea4f 4822 	mov.w	r8, r2, asr #16
         C_MUL(scratch[3] ,*Fout3, tw[3*u*fstride]);
   2a682:	f930 ec02 	ldrsh.w	lr, [r0, #-2]
   2a686:	f8cd e02c 	str.w	lr, [sp, #44]	; 0x2c
         C_MUL(scratch[1] ,*Fout1, tw[u*fstride]);
   2a68a:	fb09 f70c 	mul.w	r7, r9, ip
   2a68e:	b2a8      	uxth	r0, r5
   2a690:	fb08 fe0c 	mul.w	lr, r8, ip
   2a694:	142d      	asrs	r5, r5, #16
   2a696:	13ff      	asrs	r7, r7, #15
   2a698:	fb05 f20c 	mul.w	r2, r5, ip
   2a69c:	eb07 0e4e 	add.w	lr, r7, lr, lsl #1
   2a6a0:	fb01 f909 	mul.w	r9, r1, r9
   2a6a4:	fb00 f701 	mul.w	r7, r0, r1
   2a6a8:	fb01 f808 	mul.w	r8, r1, r8
   2a6ac:	fb05 f101 	mul.w	r1, r5, r1
         C_MUL(scratch[3] ,*Fout3, tw[3*u*fstride]);
   2a6b0:	9d04      	ldr	r5, [sp, #16]
         C_MUL(scratch[2] ,*Fout2, tw[2*u*fstride]);
   2a6b2:	f936 bc02 	ldrsh.w	fp, [r6, #-2]
         C_MUL(scratch[1] ,*Fout1, tw[u*fstride]);
   2a6b6:	fb00 f60c 	mul.w	r6, r0, ip
   2a6ba:	ea4f 39e9 	mov.w	r9, r9, asr #15
         C_MUL(scratch[3] ,*Fout3, tw[3*u*fstride]);
   2a6be:	f9b5 c000 	ldrsh.w	ip, [r5]
   2a6c2:	f8cd c030 	str.w	ip, [sp, #48]	; 0x30
         C_MUL(scratch[1] ,*Fout1, tw[u*fstride]);
   2a6c6:	13ff      	asrs	r7, r7, #15
   2a6c8:	13f0      	asrs	r0, r6, #15
   2a6ca:	eb00 0642 	add.w	r6, r0, r2, lsl #1
   2a6ce:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   2a6d0:	eb09 0848 	add.w	r8, r9, r8, lsl #1
   2a6d4:	fa1f fc8a 	uxth.w	ip, sl
   2a6d8:	eb07 0141 	add.w	r1, r7, r1, lsl #1
   2a6dc:	ebae 0701 	sub.w	r7, lr, r1
         C_MUL(scratch[4] ,*Fout4, tw[4*u*fstride]);
   2a6e0:	ea4f 422a 	mov.w	r2, sl, asr #16
         C_MUL(scratch[1] ,*Fout1, tw[u*fstride]);
   2a6e4:	eb08 0e06 	add.w	lr, r8, r6
         C_MUL(scratch[4] ,*Fout4, tw[4*u*fstride]);
   2a6e8:	fb0c f103 	mul.w	r1, ip, r3
   2a6ec:	b2a8      	uxth	r0, r5
         C_MUL(scratch[1] ,*Fout1, tw[u*fstride]);
   2a6ee:	f8cd e038 	str.w	lr, [sp, #56]	; 0x38
         C_MUL(scratch[4] ,*Fout4, tw[4*u*fstride]);
   2a6f2:	13c9      	asrs	r1, r1, #15
   2a6f4:	fb02 fe03 	mul.w	lr, r2, r3
   2a6f8:	142d      	asrs	r5, r5, #16
   2a6fa:	eb01 0e4e 	add.w	lr, r1, lr, lsl #1
   2a6fe:	fb04 fc0c 	mul.w	ip, r4, ip
   2a702:	fb00 f104 	mul.w	r1, r0, r4
   2a706:	fb00 f003 	mul.w	r0, r0, r3
   2a70a:	fb04 f202 	mul.w	r2, r4, r2
   2a70e:	fb05 f303 	mul.w	r3, r5, r3
   2a712:	fb05 f404 	mul.w	r4, r5, r4
   2a716:	ea4f 3cec 	mov.w	ip, ip, asr #15
   2a71a:	13c9      	asrs	r1, r1, #15
   2a71c:	13c0      	asrs	r0, r0, #15
   2a71e:	eb0c 0c42 	add.w	ip, ip, r2, lsl #1
   2a722:	eb00 0043 	add.w	r0, r0, r3, lsl #1
   2a726:	eb01 0144 	add.w	r1, r1, r4, lsl #1
   2a72a:	ebae 0101 	sub.w	r1, lr, r1
   2a72e:	eb0c 0e00 	add.w	lr, ip, r0
   2a732:	f8dd c044 	ldr.w	ip, [sp, #68]	; 0x44
   2a736:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
   2a73a:	f8dd 903c 	ldr.w	r9, [sp, #60]	; 0x3c
   2a73e:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
   2a742:	f8cd e040 	str.w	lr, [sp, #64]	; 0x40
   2a746:	fa1f f08c 	uxth.w	r0, ip
   2a74a:	900f      	str	r0, [sp, #60]	; 0x3c
         C_ADD( scratch[7],scratch[1],scratch[4]);
   2a74c:	1878      	adds	r0, r7, r1
   2a74e:	fa1f f68a 	uxth.w	r6, sl
         C_SUB( scratch[10],scratch[1],scratch[4]);
   2a752:	1a79      	subs	r1, r7, r1
         C_MUL(scratch[2] ,*Fout2, tw[2*u*fstride]);
   2a754:	4655      	mov	r5, sl
   2a756:	b287      	uxth	r7, r0
   2a758:	4682      	mov	sl, r0
   2a75a:	980a      	ldr	r0, [sp, #40]	; 0x28
         C_SUB( scratch[10],scratch[1],scratch[4]);
   2a75c:	9112      	str	r1, [sp, #72]	; 0x48
   2a75e:	fa1f f289 	uxth.w	r2, r9
         scratch[5].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,ya.r), S_MUL(scratch[8].r,yb.r)));
   2a762:	f8cd a044 	str.w	sl, [sp, #68]	; 0x44
   2a766:	4651      	mov	r1, sl
         C_MUL(scratch[2] ,*Fout2, tw[2*u*fstride]);
   2a768:	fb02 fa00 	mul.w	sl, r2, r0
   2a76c:	fa1f f488 	uxth.w	r4, r8
   2a770:	fb06 fe0b 	mul.w	lr, r6, fp
         C_MUL(scratch[3] ,*Fout3, tw[3*u*fstride]);
   2a774:	4643      	mov	r3, r8
         C_MUL(scratch[2] ,*Fout2, tw[2*u*fstride]);
   2a776:	fb00 f606 	mul.w	r6, r0, r6
         C_MUL(scratch[3] ,*Fout3, tw[3*u*fstride]);
   2a77a:	ea4f 482c 	mov.w	r8, ip, asr #16
         C_MUL(scratch[2] ,*Fout2, tw[2*u*fstride]);
   2a77e:	ea4f 3aea 	mov.w	sl, sl, asr #15
         scratch[11].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,yb.r), S_MUL(scratch[8].r,ya.r)));
   2a782:	48ce      	ldr	r0, [pc, #824]	; (2aabc <opus_fft_impl+0x764>)
         C_MUL(scratch[2] ,*Fout2, tw[2*u*fstride]);
   2a784:	f8cd a04c 	str.w	sl, [sp, #76]	; 0x4c
         scratch[5].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,ya.r), S_MUL(scratch[8].r,yb.r)));
   2a788:	f242 7c8e 	movw	ip, #10126	; 0x278e
         C_MUL(scratch[2] ,*Fout2, tw[2*u*fstride]);
   2a78c:	fb02 f20b 	mul.w	r2, r2, fp
         C_MUL(scratch[3] ,*Fout3, tw[3*u*fstride]);
   2a790:	141b      	asrs	r3, r3, #16
         scratch[5].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,ya.r), S_MUL(scratch[8].r,yb.r)));
   2a792:	fb0c fc07 	mul.w	ip, ip, r7
   2a796:	1409      	asrs	r1, r1, #16
   2a798:	f242 7a8e 	movw	sl, #10126	; 0x278e
         C_MUL(scratch[3] ,*Fout3, tw[3*u*fstride]);
   2a79c:	930d      	str	r3, [sp, #52]	; 0x34
         scratch[5].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,ya.r), S_MUL(scratch[8].r,yb.r)));
   2a79e:	fb0a fa01 	mul.w	sl, sl, r1
         C_MUL(scratch[2] ,*Fout2, tw[2*u*fstride]);
   2a7a2:	13d3      	asrs	r3, r2, #15
         scratch[11].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,yb.r), S_MUL(scratch[8].r,ya.r)));
   2a7a4:	fb00 f707 	mul.w	r7, r0, r7
         C_MUL(scratch[3] ,*Fout3, tw[3*u*fstride]);
   2a7a8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   2a7aa:	980c      	ldr	r0, [sp, #48]	; 0x30
         C_MUL(scratch[2] ,*Fout2, tw[2*u*fstride]);
   2a7ac:	9314      	str	r3, [sp, #80]	; 0x50
         scratch[5].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,ya.r), S_MUL(scratch[8].r,yb.r)));
   2a7ae:	ea4f 3cec 	mov.w	ip, ip, asr #15
   2a7b2:	eb0c 0c4a 	add.w	ip, ip, sl, lsl #1
   2a7b6:	f8cd c054 	str.w	ip, [sp, #84]	; 0x54
         C_MUL(scratch[3] ,*Fout3, tw[3*u*fstride]);
   2a7ba:	4682      	mov	sl, r0
   2a7bc:	fb04 fc02 	mul.w	ip, r4, r2
   2a7c0:	fb00 f404 	mul.w	r4, r0, r4
   2a7c4:	980f      	ldr	r0, [sp, #60]	; 0x3c
         C_MUL(scratch[2] ,*Fout2, tw[2*u*fstride]);
   2a7c6:	9b14      	ldr	r3, [sp, #80]	; 0x50
         C_MUL(scratch[3] ,*Fout3, tw[3*u*fstride]);
   2a7c8:	fb00 fa0a 	mul.w	sl, r0, sl
   2a7cc:	fb00 f002 	mul.w	r0, r0, r2
         scratch[11].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,yb.r), S_MUL(scratch[8].r,ya.r)));
   2a7d0:	4aba      	ldr	r2, [pc, #744]	; (2aabc <opus_fft_impl+0x764>)
   2a7d2:	13ff      	asrs	r7, r7, #15
   2a7d4:	fb02 f101 	mul.w	r1, r2, r1
   2a7d8:	eb07 0741 	add.w	r7, r7, r1, lsl #1
         C_MUL(scratch[2] ,*Fout2, tw[2*u*fstride]);
   2a7dc:	990a      	ldr	r1, [sp, #40]	; 0x28
         scratch[11].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,yb.r), S_MUL(scratch[8].r,ya.r)));
   2a7de:	9716      	str	r7, [sp, #88]	; 0x58
         C_MUL(scratch[2] ,*Fout2, tw[2*u*fstride]);
   2a7e0:	142d      	asrs	r5, r5, #16
   2a7e2:	fb05 f70b 	mul.w	r7, r5, fp
   2a7e6:	13f6      	asrs	r6, r6, #15
   2a7e8:	fb01 f505 	mul.w	r5, r1, r5
   2a7ec:	eb06 0545 	add.w	r5, r6, r5, lsl #1
   2a7f0:	ea4f 4929 	mov.w	r9, r9, asr #16
   2a7f4:	9e13      	ldr	r6, [sp, #76]	; 0x4c
   2a7f6:	fb09 f101 	mul.w	r1, r9, r1
   2a7fa:	ea4f 3eee 	mov.w	lr, lr, asr #15
   2a7fe:	fb09 f90b 	mul.w	r9, r9, fp
   2a802:	eb06 0141 	add.w	r1, r6, r1, lsl #1
   2a806:	eb03 0949 	add.w	r9, r3, r9, lsl #1
   2a80a:	eb0e 0e47 	add.w	lr, lr, r7, lsl #1
   2a80e:	eb05 0b09 	add.w	fp, r5, r9
   2a812:	ebae 0e01 	sub.w	lr, lr, r1
         C_MUL(scratch[3] ,*Fout3, tw[3*u*fstride]);
   2a816:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   2a818:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   2a81a:	990c      	ldr	r1, [sp, #48]	; 0x30
         scratch[5].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,ya.r), S_MUL(scratch[8].r,yb.r)));
   2a81c:	4fa7      	ldr	r7, [pc, #668]	; (2aabc <opus_fft_impl+0x764>)
         C_MUL(scratch[3] ,*Fout3, tw[3*u*fstride]);
   2a81e:	fb03 f205 	mul.w	r2, r3, r5
   2a822:	ea4f 3cec 	mov.w	ip, ip, asr #15
   2a826:	fb01 f303 	mul.w	r3, r1, r3
   2a82a:	ea4f 3aea 	mov.w	sl, sl, asr #15
   2a82e:	fb08 f101 	mul.w	r1, r8, r1
   2a832:	eb0a 0a41 	add.w	sl, sl, r1, lsl #1
   2a836:	eb0c 0c42 	add.w	ip, ip, r2, lsl #1
   2a83a:	ebac 0c0a 	sub.w	ip, ip, sl
   2a83e:	fb08 f805 	mul.w	r8, r8, r5
   2a842:	13e4      	asrs	r4, r4, #15
   2a844:	13c0      	asrs	r0, r0, #15
   2a846:	eb04 0343 	add.w	r3, r4, r3, lsl #1
   2a84a:	eb00 0948 	add.w	r9, r0, r8, lsl #1
         C_ADD( scratch[8],scratch[2],scratch[3]);
   2a84e:	eb0e 000c 	add.w	r0, lr, ip
         C_ADD( scratch[7],scratch[1],scratch[4]);
   2a852:	9c10      	ldr	r4, [sp, #64]	; 0x40
   2a854:	990e      	ldr	r1, [sp, #56]	; 0x38
         C_MUL(scratch[3] ,*Fout3, tw[3*u*fstride]);
   2a856:	4499      	add	r9, r3
   2a858:	b283      	uxth	r3, r0
         C_SUB( scratch[9],scratch[2],scratch[3]);
   2a85a:	ebae 0e0c 	sub.w	lr, lr, ip
         scratch[5].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,ya.r), S_MUL(scratch[8].r,yb.r)));
   2a85e:	fb07 fc03 	mul.w	ip, r7, r3
         C_ADD( scratch[7],scratch[1],scratch[4]);
   2a862:	190d      	adds	r5, r1, r4
         C_SUB( scratch[10],scratch[1],scratch[4]);
   2a864:	1b0a      	subs	r2, r1, r4
         scratch[5].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,ya.r), S_MUL(scratch[8].r,yb.r)));
   2a866:	ea4f 37ec 	mov.w	r7, ip, asr #15
   2a86a:	1401      	asrs	r1, r0, #16
   2a86c:	f8dd c048 	ldr.w	ip, [sp, #72]	; 0x48
   2a870:	910a      	str	r1, [sp, #40]	; 0x28
         scratch[11].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,yb.r), S_MUL(scratch[8].r,ya.r)));
   2a872:	f242 718e 	movw	r1, #10126	; 0x278e
         C_ADD( scratch[8],scratch[2],scratch[3]);
   2a876:	eb0b 0609 	add.w	r6, fp, r9
         scratch[11].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,yb.r), S_MUL(scratch[8].r,ya.r)));
   2a87a:	fb01 f303 	mul.w	r3, r1, r3
         C_SUB( scratch[9],scratch[2],scratch[3]);
   2a87e:	ebab 0909 	sub.w	r9, fp, r9
         scratch[6].r =  ADD32_ovflw(S_MUL(scratch[10].i,ya.i), S_MUL(scratch[9].i,yb.i));
   2a882:	1411      	asrs	r1, r2, #16
   2a884:	fa1f fb82 	uxth.w	fp, r2
         scratch[6].i = NEG32_ovflw(ADD32_ovflw(S_MUL(scratch[10].r,ya.i), S_MUL(scratch[9].r,yb.i)));
   2a888:	4662      	mov	r2, ip
         scratch[6].r =  ADD32_ovflw(S_MUL(scratch[10].i,ya.i), S_MUL(scratch[9].i,yb.i));
   2a88a:	910f      	str	r1, [sp, #60]	; 0x3c
         scratch[6].i = NEG32_ovflw(ADD32_ovflw(S_MUL(scratch[10].r,ya.i), S_MUL(scratch[9].r,yb.i)));
   2a88c:	1412      	asrs	r2, r2, #16
   2a88e:	fa1f f18c 	uxth.w	r1, ip
   2a892:	920b      	str	r2, [sp, #44]	; 0x2c
   2a894:	9110      	str	r1, [sp, #64]	; 0x40
         Fout0->r = ADD32_ovflw(Fout0->r, ADD32_ovflw(scratch[7].r, scratch[8].r));
   2a896:	9911      	ldr	r1, [sp, #68]	; 0x44
   2a898:	1842      	adds	r2, r0, r1
   2a89a:	9211      	str	r2, [sp, #68]	; 0x44
         scratch[5].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,ya.r), S_MUL(scratch[8].r,yb.r)));
   2a89c:	980a      	ldr	r0, [sp, #40]	; 0x28
   2a89e:	4a87      	ldr	r2, [pc, #540]	; (2aabc <opus_fft_impl+0x764>)
         scratch[11].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,yb.r), S_MUL(scratch[8].r,ya.r)));
   2a8a0:	f242 718e 	movw	r1, #10126	; 0x278e
         scratch[5].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,ya.r), S_MUL(scratch[8].r,yb.r)));
   2a8a4:	fb02 fc00 	mul.w	ip, r2, r0
         scratch[11].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,yb.r), S_MUL(scratch[8].r,ya.r)));
   2a8a8:	460a      	mov	r2, r1
   2a8aa:	fb01 f100 	mul.w	r1, r1, r0
         scratch[5].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,ya.r), S_MUL(scratch[8].r,yb.r)));
   2a8ae:	9815      	ldr	r0, [sp, #84]	; 0x54
   2a8b0:	eb07 0c4c 	add.w	ip, r7, ip, lsl #1
   2a8b4:	fa1f fa85 	uxth.w	sl, r5
         scratch[11].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,yb.r), S_MUL(scratch[8].r,ya.r)));
   2a8b8:	13db      	asrs	r3, r3, #15
         scratch[5].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,ya.r), S_MUL(scratch[8].r,yb.r)));
   2a8ba:	4484      	add	ip, r0
         scratch[5].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,ya.r), S_MUL(scratch[8].i,yb.r)));
   2a8bc:	1428      	asrs	r0, r5, #16
   2a8be:	900e      	str	r0, [sp, #56]	; 0x38
         scratch[11].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,yb.r), S_MUL(scratch[8].r,ya.r)));
   2a8c0:	eb03 0141 	add.w	r1, r3, r1, lsl #1
         scratch[5].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,ya.r), S_MUL(scratch[8].i,yb.r)));
   2a8c4:	4610      	mov	r0, r2
   2a8c6:	fb02 f30a 	mul.w	r3, r2, sl
         scratch[11].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,yb.r), S_MUL(scratch[8].i,ya.r)));
   2a8ca:	4a7c      	ldr	r2, [pc, #496]	; (2aabc <opus_fft_impl+0x764>)
         scratch[5].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,ya.r), S_MUL(scratch[8].i,yb.r)));
   2a8cc:	13db      	asrs	r3, r3, #15
   2a8ce:	9312      	str	r3, [sp, #72]	; 0x48
         scratch[11].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,yb.r), S_MUL(scratch[8].i,ya.r)));
   2a8d0:	fb02 fa0a 	mul.w	sl, r2, sl
         scratch[11].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,yb.r), S_MUL(scratch[8].r,ya.r)));
   2a8d4:	9b16      	ldr	r3, [sp, #88]	; 0x58
         Fout0->r = ADD32_ovflw(Fout0->r, ADD32_ovflw(scratch[7].r, scratch[8].r));
   2a8d6:	9a01      	ldr	r2, [sp, #4]
         scratch[11].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,yb.r), S_MUL(scratch[8].r,ya.r)));
   2a8d8:	4419      	add	r1, r3
         scratch[0] = *Fout0;
   2a8da:	e952 3202 	ldrd	r3, r2, [r2, #-8]
   2a8de:	920a      	str	r2, [sp, #40]	; 0x28
         scratch[5].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,ya.r), S_MUL(scratch[8].i,yb.r)));
   2a8e0:	4a76      	ldr	r2, [pc, #472]	; (2aabc <opus_fft_impl+0x764>)
   2a8e2:	b2b4      	uxth	r4, r6
   2a8e4:	fa1f f78e 	uxth.w	r7, lr
         scratch[6].i = NEG32_ovflw(ADD32_ovflw(S_MUL(scratch[10].r,ya.i), S_MUL(scratch[9].r,yb.i)));
   2a8e8:	ea4f 4e2e 	mov.w	lr, lr, asr #16
   2a8ec:	f8cd e030 	str.w	lr, [sp, #48]	; 0x30
         scratch[5].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,ya.r), S_MUL(scratch[8].i,yb.r)));
   2a8f0:	fb02 fe04 	mul.w	lr, r2, r4
         scratch[11].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,yb.r), S_MUL(scratch[8].i,ya.r)));
   2a8f4:	fb00 f404 	mul.w	r4, r0, r4
         Fout0->r = ADD32_ovflw(Fout0->r, ADD32_ovflw(scratch[7].r, scratch[8].r));
   2a8f8:	9811      	ldr	r0, [sp, #68]	; 0x44
         scratch[5].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,ya.r), S_MUL(scratch[8].r,yb.r)));
   2a8fa:	449c      	add	ip, r3
         scratch[11].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,yb.r), S_MUL(scratch[8].r,ya.r)));
   2a8fc:	18ca      	adds	r2, r1, r3
         Fout0->r = ADD32_ovflw(Fout0->r, ADD32_ovflw(scratch[7].r, scratch[8].r));
   2a8fe:	4418      	add	r0, r3
         scratch[12].r = SUB32_ovflw(S_MUL(scratch[9].i,ya.i), S_MUL(scratch[10].i,yb.i));
   2a900:	496f      	ldr	r1, [pc, #444]	; (2aac0 <opus_fft_impl+0x768>)
         scratch[6].r =  ADD32_ovflw(S_MUL(scratch[10].i,ya.i), S_MUL(scratch[9].i,yb.i));
   2a902:	4b70      	ldr	r3, [pc, #448]	; (2aac4 <opus_fft_impl+0x76c>)
         scratch[11].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,yb.r), S_MUL(scratch[8].r,ya.r)));
   2a904:	920d      	str	r2, [sp, #52]	; 0x34
         scratch[11].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,yb.r), S_MUL(scratch[8].i,ya.r)));
   2a906:	13e4      	asrs	r4, r4, #15
         scratch[12].r = SUB32_ovflw(S_MUL(scratch[9].i,ya.i), S_MUL(scratch[10].i,yb.i));
   2a908:	460a      	mov	r2, r1
         scratch[11].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,yb.r), S_MUL(scratch[8].i,ya.r)));
   2a90a:	9413      	str	r4, [sp, #76]	; 0x4c
         scratch[6].r =  ADD32_ovflw(S_MUL(scratch[10].i,ya.i), S_MUL(scratch[9].i,yb.i));
   2a90c:	fb03 f40b 	mul.w	r4, r3, fp
         scratch[12].r = SUB32_ovflw(S_MUL(scratch[9].i,ya.i), S_MUL(scratch[10].i,yb.i));
   2a910:	fb01 fb0b 	mul.w	fp, r1, fp
         Fout0->i = ADD32_ovflw(Fout0->i, ADD32_ovflw(scratch[7].i, scratch[8].i));
   2a914:	990a      	ldr	r1, [sp, #40]	; 0x28
   2a916:	4435      	add	r5, r6
   2a918:	440d      	add	r5, r1
   2a91a:	9511      	str	r5, [sp, #68]	; 0x44
         scratch[6].r =  ADD32_ovflw(S_MUL(scratch[10].i,ya.i), S_MUL(scratch[9].i,yb.i));
   2a91c:	990f      	ldr	r1, [sp, #60]	; 0x3c
         Fout0->r = ADD32_ovflw(Fout0->r, ADD32_ovflw(scratch[7].r, scratch[8].r));
   2a91e:	9d01      	ldr	r5, [sp, #4]
   2a920:	f845 0c08 	str.w	r0, [r5, #-8]
         scratch[6].r =  ADD32_ovflw(S_MUL(scratch[10].i,ya.i), S_MUL(scratch[9].i,yb.i));
   2a924:	461d      	mov	r5, r3
   2a926:	460b      	mov	r3, r1
   2a928:	fa1f f889 	uxth.w	r8, r9
   2a92c:	fb05 f303 	mul.w	r3, r5, r3
   2a930:	13e4      	asrs	r4, r4, #15
         scratch[12].r = SUB32_ovflw(S_MUL(scratch[9].i,ya.i), S_MUL(scratch[10].i,yb.i));
   2a932:	4610      	mov	r0, r2
         scratch[6].r =  ADD32_ovflw(S_MUL(scratch[10].i,ya.i), S_MUL(scratch[9].i,yb.i));
   2a934:	ea4f 4929 	mov.w	r9, r9, asr #16
   2a938:	eb04 0443 	add.w	r4, r4, r3, lsl #1
   2a93c:	fb02 f308 	mul.w	r3, r2, r8
         scratch[12].r = SUB32_ovflw(S_MUL(scratch[9].i,ya.i), S_MUL(scratch[10].i,yb.i));
   2a940:	460a      	mov	r2, r1
   2a942:	fb05 f808 	mul.w	r8, r5, r8
   2a946:	fb00 f202 	mul.w	r2, r0, r2
         scratch[6].r =  ADD32_ovflw(S_MUL(scratch[10].i,ya.i), S_MUL(scratch[9].i,yb.i));
   2a94a:	13db      	asrs	r3, r3, #15
   2a94c:	fb00 f009 	mul.w	r0, r0, r9
         scratch[6].i = NEG32_ovflw(ADD32_ovflw(S_MUL(scratch[10].r,ya.i), S_MUL(scratch[9].r,yb.i)));
   2a950:	9910      	ldr	r1, [sp, #64]	; 0x40
         scratch[6].r =  ADD32_ovflw(S_MUL(scratch[10].i,ya.i), S_MUL(scratch[9].i,yb.i));
   2a952:	eb03 0340 	add.w	r3, r3, r0, lsl #1
         scratch[12].r = SUB32_ovflw(S_MUL(scratch[9].i,ya.i), S_MUL(scratch[10].i,yb.i));
   2a956:	fb05 f909 	mul.w	r9, r5, r9
         scratch[12].i = SUB32_ovflw(S_MUL(scratch[10].r,yb.i), S_MUL(scratch[9].r,ya.i));
   2a95a:	4859      	ldr	r0, [pc, #356]	; (2aac0 <opus_fft_impl+0x768>)
         scratch[12].r = SUB32_ovflw(S_MUL(scratch[9].i,ya.i), S_MUL(scratch[10].i,yb.i));
   2a95c:	ea4f 3beb 	mov.w	fp, fp, asr #15
   2a960:	ea4f 38e8 	mov.w	r8, r8, asr #15
         scratch[6].r =  ADD32_ovflw(S_MUL(scratch[10].i,ya.i), S_MUL(scratch[9].i,yb.i));
   2a964:	441c      	add	r4, r3
         scratch[12].r = SUB32_ovflw(S_MUL(scratch[9].i,ya.i), S_MUL(scratch[10].i,yb.i));
   2a966:	eb08 0849 	add.w	r8, r8, r9, lsl #1
         scratch[6].i = NEG32_ovflw(ADD32_ovflw(S_MUL(scratch[10].r,ya.i), S_MUL(scratch[9].r,yb.i)));
   2a96a:	462b      	mov	r3, r5
         scratch[12].r = SUB32_ovflw(S_MUL(scratch[9].i,ya.i), S_MUL(scratch[10].i,yb.i));
   2a96c:	eb0b 0242 	add.w	r2, fp, r2, lsl #1
   2a970:	eba8 0202 	sub.w	r2, r8, r2
         scratch[6].i = NEG32_ovflw(ADD32_ovflw(S_MUL(scratch[10].r,ya.i), S_MUL(scratch[9].r,yb.i)));
   2a974:	fb05 f901 	mul.w	r9, r5, r1
   2a978:	fb00 f807 	mul.w	r8, r0, r7
         scratch[12].i = SUB32_ovflw(S_MUL(scratch[10].r,yb.i), S_MUL(scratch[9].r,ya.i));
   2a97c:	fb00 f501 	mul.w	r5, r0, r1
   2a980:	fb03 f707 	mul.w	r7, r3, r7
         C_SUB(*Fout1,scratch[5],scratch[6]);
   2a984:	ebac 0104 	sub.w	r1, ip, r4
         C_ADD(*Fout4,scratch[5],scratch[6]);
   2a988:	eb04 030c 	add.w	r3, r4, ip
         scratch[5].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,ya.r), S_MUL(scratch[8].i,yb.r)));
   2a98c:	9c0e      	ldr	r4, [sp, #56]	; 0x38
   2a98e:	9812      	ldr	r0, [sp, #72]	; 0x48
         C_SUB(*Fout1,scratch[5],scratch[6]);
   2a990:	910f      	str	r1, [sp, #60]	; 0x3c
         scratch[5].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,ya.r), S_MUL(scratch[8].i,yb.r)));
   2a992:	f242 7c8e 	movw	ip, #10126	; 0x278e
   2a996:	fb0c fb04 	mul.w	fp, ip, r4
   2a99a:	eb00 0b4b 	add.w	fp, r0, fp, lsl #1
         scratch[11].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,yb.r), S_MUL(scratch[8].i,ya.r)));
   2a99e:	4847      	ldr	r0, [pc, #284]	; (2aabc <opus_fft_impl+0x764>)
         C_ADD(*Fout4,scratch[5],scratch[6]);
   2a9a0:	9310      	str	r3, [sp, #64]	; 0x40
         scratch[5].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,ya.r), S_MUL(scratch[8].i,yb.r)));
   2a9a2:	4661      	mov	r1, ip
         scratch[11].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,yb.r), S_MUL(scratch[8].i,ya.r)));
   2a9a4:	4603      	mov	r3, r0
         scratch[5].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,ya.r), S_MUL(scratch[8].i,yb.r)));
   2a9a6:	1436      	asrs	r6, r6, #16
   2a9a8:	fb03 fc06 	mul.w	ip, r3, r6
         scratch[11].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,yb.r), S_MUL(scratch[8].i,ya.r)));
   2a9ac:	fb00 f004 	mul.w	r0, r0, r4
         scratch[6].i = NEG32_ovflw(ADD32_ovflw(S_MUL(scratch[10].r,ya.i), S_MUL(scratch[9].r,yb.i)));
   2a9b0:	4b44      	ldr	r3, [pc, #272]	; (2aac4 <opus_fft_impl+0x76c>)
         scratch[11].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,yb.r), S_MUL(scratch[8].i,ya.r)));
   2a9b2:	9c13      	ldr	r4, [sp, #76]	; 0x4c
   2a9b4:	fb01 f606 	mul.w	r6, r1, r6
         scratch[6].i = NEG32_ovflw(ADD32_ovflw(S_MUL(scratch[10].r,ya.i), S_MUL(scratch[9].r,yb.i)));
   2a9b8:	990b      	ldr	r1, [sp, #44]	; 0x2c
         scratch[5].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,ya.r), S_MUL(scratch[8].i,yb.r)));
   2a9ba:	ea4f 3eee 	mov.w	lr, lr, asr #15
   2a9be:	eb0e 0e4c 	add.w	lr, lr, ip, lsl #1
         scratch[11].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,yb.r), S_MUL(scratch[8].i,ya.r)));
   2a9c2:	eb04 0646 	add.w	r6, r4, r6, lsl #1
         scratch[6].i = NEG32_ovflw(ADD32_ovflw(S_MUL(scratch[10].r,ya.i), S_MUL(scratch[9].r,yb.i)));
   2a9c6:	fb03 fc01 	mul.w	ip, r3, r1
   2a9ca:	9c0c      	ldr	r4, [sp, #48]	; 0x30
   2a9cc:	493c      	ldr	r1, [pc, #240]	; (2aac0 <opus_fft_impl+0x768>)
   2a9ce:	ea4f 39e9 	mov.w	r9, r9, asr #15
   2a9d2:	eb09 094c 	add.w	r9, r9, ip, lsl #1
   2a9d6:	fb01 fc04 	mul.w	ip, r1, r4
         scratch[12].i = SUB32_ovflw(S_MUL(scratch[10].r,yb.i), S_MUL(scratch[9].r,ya.i));
   2a9da:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
         scratch[11].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,yb.r), S_MUL(scratch[8].i,ya.r)));
   2a9dc:	ea4f 3aea 	mov.w	sl, sl, asr #15
   2a9e0:	eb0a 0040 	add.w	r0, sl, r0, lsl #1
         scratch[12].i = SUB32_ovflw(S_MUL(scratch[10].r,yb.i), S_MUL(scratch[9].r,ya.i));
   2a9e4:	fb01 fa04 	mul.w	sl, r1, r4
         scratch[5].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,ya.r), S_MUL(scratch[8].i,yb.r)));
   2a9e8:	990a      	ldr	r1, [sp, #40]	; 0x28
         scratch[12].i = SUB32_ovflw(S_MUL(scratch[10].r,yb.i), S_MUL(scratch[9].r,ya.i));
   2a9ea:	9c0c      	ldr	r4, [sp, #48]	; 0x30
         scratch[5].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,ya.r), S_MUL(scratch[8].i,yb.r)));
   2a9ec:	44de      	add	lr, fp
         scratch[11].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,yb.r), S_MUL(scratch[8].i,ya.r)));
   2a9ee:	4406      	add	r6, r0
         scratch[6].i = NEG32_ovflw(ADD32_ovflw(S_MUL(scratch[10].r,ya.i), S_MUL(scratch[9].r,yb.i)));
   2a9f0:	ea4f 38e8 	mov.w	r8, r8, asr #15
         scratch[5].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,ya.r), S_MUL(scratch[8].i,yb.r)));
   2a9f4:	448e      	add	lr, r1
         scratch[11].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,yb.r), S_MUL(scratch[8].i,ya.r)));
   2a9f6:	440e      	add	r6, r1
         scratch[6].i = NEG32_ovflw(ADD32_ovflw(S_MUL(scratch[10].r,ya.i), S_MUL(scratch[9].r,yb.i)));
   2a9f8:	eb08 084c 	add.w	r8, r8, ip, lsl #1
         Fout0->i = ADD32_ovflw(Fout0->i, ADD32_ovflw(scratch[7].i, scratch[8].i));
   2a9fc:	9901      	ldr	r1, [sp, #4]
         scratch[12].i = SUB32_ovflw(S_MUL(scratch[10].r,yb.i), S_MUL(scratch[9].r,ya.i));
   2a9fe:	fb03 fb04 	mul.w	fp, r3, r4
         scratch[6].i = NEG32_ovflw(ADD32_ovflw(S_MUL(scratch[10].r,ya.i), S_MUL(scratch[9].r,yb.i)));
   2aa02:	44c1      	add	r9, r8
         Fout0->i = ADD32_ovflw(Fout0->i, ADD32_ovflw(scratch[7].i, scratch[8].i));
   2aa04:	9c11      	ldr	r4, [sp, #68]	; 0x44
         C_SUB(*Fout1,scratch[5],scratch[6]);
   2aa06:	9b09      	ldr	r3, [sp, #36]	; 0x24
         Fout0->i = ADD32_ovflw(Fout0->i, ADD32_ovflw(scratch[7].i, scratch[8].i));
   2aa08:	f841 4c04 	str.w	r4, [r1, #-4]
         C_SUB(*Fout1,scratch[5],scratch[6]);
   2aa0c:	eb0e 0009 	add.w	r0, lr, r9
   2aa10:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
   2aa12:	f843 4c08 	str.w	r4, [r3, #-8]
   2aa16:	f843 0c04 	str.w	r0, [r3, #-4]
         C_ADD(*Fout2,scratch[11],scratch[12]);
   2aa1a:	990d      	ldr	r1, [sp, #52]	; 0x34
   2aa1c:	981a      	ldr	r0, [sp, #104]	; 0x68
         C_SUB(*Fout1,scratch[5],scratch[6]);
   2aa1e:	461c      	mov	r4, r3
         C_SUB(*Fout3,scratch[11],scratch[12]);
   2aa20:	9b0d      	ldr	r3, [sp, #52]	; 0x34
         scratch[12].i = SUB32_ovflw(S_MUL(scratch[10].r,yb.i), S_MUL(scratch[9].r,ya.i));
   2aa22:	13ed      	asrs	r5, r5, #15
   2aa24:	13ff      	asrs	r7, r7, #15
         C_ADD(*Fout2,scratch[11],scratch[12]);
   2aa26:	eb01 0c02 	add.w	ip, r1, r2
         scratch[12].i = SUB32_ovflw(S_MUL(scratch[10].r,yb.i), S_MUL(scratch[9].r,ya.i));
   2aa2a:	eb07 074b 	add.w	r7, r7, fp, lsl #1
         C_SUB(*Fout3,scratch[11],scratch[12]);
   2aa2e:	1a99      	subs	r1, r3, r2
         scratch[12].i = SUB32_ovflw(S_MUL(scratch[10].r,yb.i), S_MUL(scratch[9].r,ya.i));
   2aa30:	eb05 054a 	add.w	r5, r5, sl, lsl #1
         C_ADD(*Fout4,scratch[5],scratch[6]);
   2aa34:	9a02      	ldr	r2, [sp, #8]
   2aa36:	9b10      	ldr	r3, [sp, #64]	; 0x40
         scratch[12].i = SUB32_ovflw(S_MUL(scratch[10].r,yb.i), S_MUL(scratch[9].r,ya.i));
   2aa38:	1bed      	subs	r5, r5, r7
         C_ADD(*Fout4,scratch[5],scratch[6]);
   2aa3a:	ebae 0709 	sub.w	r7, lr, r9
   2aa3e:	e942 3702 	strd	r3, r7, [r2, #-8]
   2aa42:	9f06      	ldr	r7, [sp, #24]
   2aa44:	4407      	add	r7, r0
   2aa46:	9706      	str	r7, [sp, #24]
   2aa48:	9818      	ldr	r0, [sp, #96]	; 0x60
   2aa4a:	9f03      	ldr	r7, [sp, #12]
   2aa4c:	1838      	adds	r0, r7, r0
         C_ADD(*Fout2,scratch[11],scratch[12]);
   2aa4e:	1973      	adds	r3, r6, r5
   2aa50:	9003      	str	r0, [sp, #12]
         C_SUB(*Fout3,scratch[11],scratch[12]);
   2aa52:	1b75      	subs	r5, r6, r5
   2aa54:	9819      	ldr	r0, [sp, #100]	; 0x64
   2aa56:	9e05      	ldr	r6, [sp, #20]
   2aa58:	9f04      	ldr	r7, [sp, #16]
   2aa5a:	1830      	adds	r0, r6, r0
   2aa5c:	9005      	str	r0, [sp, #20]
   2aa5e:	981b      	ldr	r0, [sp, #108]	; 0x6c
   2aa60:	4407      	add	r7, r0
   2aa62:	9801      	ldr	r0, [sp, #4]
   2aa64:	9704      	str	r7, [sp, #16]
   2aa66:	f102 0e08 	add.w	lr, r2, #8
         C_ADD(*Fout2,scratch[11],scratch[12]);
   2aa6a:	9a08      	ldr	r2, [sp, #32]
   2aa6c:	f8cd e008 	str.w	lr, [sp, #8]
   2aa70:	3008      	adds	r0, #8
   2aa72:	9001      	str	r0, [sp, #4]
   2aa74:	f842 3c04 	str.w	r3, [r2, #-4]
   2aa78:	4620      	mov	r0, r4
         C_SUB(*Fout3,scratch[11],scratch[12]);
   2aa7a:	9b07      	ldr	r3, [sp, #28]
         C_ADD(*Fout2,scratch[11],scratch[12]);
   2aa7c:	f842 cc08 	str.w	ip, [r2, #-8]
   2aa80:	3008      	adds	r0, #8
   2aa82:	3308      	adds	r3, #8
   2aa84:	9009      	str	r0, [sp, #36]	; 0x24
         C_SUB(*Fout3,scratch[11],scratch[12]);
   2aa86:	f843 1c10 	str.w	r1, [r3, #-16]
   2aa8a:	f843 5c0c 	str.w	r5, [r3, #-12]
   2aa8e:	9307      	str	r3, [sp, #28]
      for ( u=0; u<m; ++u ) {
   2aa90:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   2aa92:	4611      	mov	r1, r2
   2aa94:	3108      	adds	r1, #8
   2aa96:	4573      	cmp	r3, lr
   2aa98:	9108      	str	r1, [sp, #32]
   2aa9a:	f47f adc7 	bne.w	2a62c <opus_fft_impl+0x2d4>
   2aa9e:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   2aaa0:	9923      	ldr	r1, [sp, #140]	; 0x8c
   for (i=0;i<N;i++)
   2aaa2:	9b20      	ldr	r3, [sp, #128]	; 0x80
   2aaa4:	440a      	add	r2, r1
   2aaa6:	921e      	str	r2, [sp, #120]	; 0x78
   2aaa8:	9a22      	ldr	r2, [sp, #136]	; 0x88
   2aaaa:	3301      	adds	r3, #1
   2aaac:	429a      	cmp	r2, r3
   2aaae:	9320      	str	r3, [sp, #128]	; 0x80
   2aab0:	f47f ada6 	bne.w	2a600 <opus_fft_impl+0x2a8>
      Fout4=Fout0+4*m;
   2aab4:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   2aab6:	9310      	str	r3, [sp, #64]	; 0x40
   2aab8:	e556      	b.n	2a568 <opus_fft_impl+0x210>
   2aaba:	bf00      	nop
   2aabc:	ffff9872 	.word	0xffff9872
   2aac0:	ffffb4c3 	.word	0xffffb4c3
   2aac4:	ffff8644 	.word	0xffff8644
          m2 = 1;
   2aac8:	2301      	movs	r3, #1
   2aaca:	931f      	str	r3, [sp, #124]	; 0x7c
          kf_bfly4(fout,fstride[i]<<shift,st,m, fstride[i], m2);
   2aacc:	9b1c      	ldr	r3, [sp, #112]	; 0x70
   2aace:	aa2c      	add	r2, sp, #176	; 0xb0
   2aad0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   2aad4:	931a      	str	r3, [sp, #104]	; 0x68
   if (m==1)
   2aad6:	9b10      	ldr	r3, [sp, #64]	; 0x40
   2aad8:	2b01      	cmp	r3, #1
   2aada:	f000 826c 	beq.w	2afb6 <opus_fft_impl+0xc5e>
   2aade:	4618      	mov	r0, r3
      const int m3=3*m;
   2aae0:	eb03 0243 	add.w	r2, r3, r3, lsl #1
      for (i=0;i<N;i++)
   2aae4:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   2aae6:	2b00      	cmp	r3, #0
   2aae8:	dde4      	ble.n	2aab4 <opus_fft_impl+0x75c>
          kf_bfly4(fout,fstride[i]<<shift,st,m, fstride[i], m2);
   2aaea:	992b      	ldr	r1, [sp, #172]	; 0xac
   2aaec:	408b      	lsls	r3, r1
            tw3 += fstride*3;
   2aaee:	eb03 0143 	add.w	r1, r3, r3, lsl #1
            C_MUL(scratch[2],Fout[m3] , *tw3 );
   2aaf2:	ea4f 09c2 	mov.w	r9, r2, lsl #3
            tw3 += fstride*3;
   2aaf6:	008a      	lsls	r2, r1, #2
   2aaf8:	9217      	str	r2, [sp, #92]	; 0x5c
            tw1 += fstride;
   2aafa:	009a      	lsls	r2, r3, #2
            tw2 += fstride*2;
   2aafc:	00db      	lsls	r3, r3, #3
   2aafe:	9316      	str	r3, [sp, #88]	; 0x58
         tw3 = tw2 = tw1 = st->twiddles;
   2ab00:	9b29      	ldr	r3, [sp, #164]	; 0xa4
            tw1 += fstride;
   2ab02:	9215      	str	r2, [sp, #84]	; 0x54
         tw3 = tw2 = tw1 = st->twiddles;
   2ab04:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   2ab06:	931b      	str	r3, [sp, #108]	; 0x6c
            C_MUL(scratch[0],Fout[m] , *tw1 );
   2ab08:	00c2      	lsls	r2, r0, #3
   2ab0a:	2800      	cmp	r0, #0
   2ab0c:	9213      	str	r2, [sp, #76]	; 0x4c
            C_MUL(scratch[1],Fout[m2] , *tw2 );
   2ab0e:	ea4f 1800 	mov.w	r8, r0, lsl #4
   2ab12:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   2ab14:	ddcf      	ble.n	2aab6 <opus_fft_impl+0x75e>
   2ab16:	00db      	lsls	r3, r3, #3
   2ab18:	931e      	str	r3, [sp, #120]	; 0x78
   2ab1a:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
   2ab1c:	3308      	adds	r3, #8
   2ab1e:	9318      	str	r3, [sp, #96]	; 0x60
      for (i=0;i<N;i++)
   2ab20:	2300      	movs	r3, #0
   2ab22:	9319      	str	r3, [sp, #100]	; 0x64
   2ab24:	e9cd 8907 	strd	r8, r9, [sp, #28]
   2ab28:	f1a2 0308 	sub.w	r3, r2, #8
   2ab2c:	9320      	str	r3, [sp, #128]	; 0x80
   2ab2e:	1f13      	subs	r3, r2, #4
   2ab30:	9321      	str	r3, [sp, #132]	; 0x84
   2ab32:	9f18      	ldr	r7, [sp, #96]	; 0x60
   2ab34:	9b20      	ldr	r3, [sp, #128]	; 0x80
   2ab36:	443b      	add	r3, r7
   2ab38:	9306      	str	r3, [sp, #24]
   2ab3a:	9b21      	ldr	r3, [sp, #132]	; 0x84
   2ab3c:	443b      	add	r3, r7
   2ab3e:	9305      	str	r3, [sp, #20]
   2ab40:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   2ab42:	443b      	add	r3, r7
   2ab44:	9314      	str	r3, [sp, #80]	; 0x50
         tw3 = tw2 = tw1 = st->twiddles;
   2ab46:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
   2ab48:	e9cd 3303 	strd	r3, r3, [sp, #12]
   2ab4c:	e9cd 7301 	strd	r7, r3, [sp, #4]
   2ab50:	9913      	ldr	r1, [sp, #76]	; 0x4c
   2ab52:	9c05      	ldr	r4, [sp, #20]
   2ab54:	9806      	ldr	r0, [sp, #24]
            C_MUL(scratch[2],Fout[m3] , *tw3 );
   2ab56:	9e08      	ldr	r6, [sp, #32]
            C_MUL(scratch[1],Fout[m2] , *tw2 );
   2ab58:	9d07      	ldr	r5, [sp, #28]
   2ab5a:	eba4 0b01 	sub.w	fp, r4, r1
   2ab5e:	1a43      	subs	r3, r0, r1
            C_MUL(scratch[2],Fout[m3] , *tw3 );
   2ab60:	f85b 7006 	ldr.w	r7, [fp, r6]
            C_MUL(scratch[1],Fout[m2] , *tw2 );
   2ab64:	5959      	ldr	r1, [r3, r5]
   2ab66:	f85b e005 	ldr.w	lr, [fp, r5]
            C_MUL(scratch[2],Fout[m3] , *tw3 );
   2ab6a:	970d      	str	r7, [sp, #52]	; 0x34
            C_MUL(scratch[0],Fout[m] , *tw1 );
   2ab6c:	6845      	ldr	r5, [r0, #4]
            C_MUL(scratch[1],Fout[m2] , *tw2 );
   2ab6e:	9f03      	ldr	r7, [sp, #12]
            C_MUL(scratch[0],Fout[m] , *tw1 );
   2ab70:	950c      	str	r5, [sp, #48]	; 0x30
            C_MUL(scratch[2],Fout[m3] , *tw3 );
   2ab72:	9d04      	ldr	r5, [sp, #16]
            C_MUL(scratch[1],Fout[m2] , *tw2 );
   2ab74:	f9b7 2000 	ldrsh.w	r2, [r7]
            C_MUL(scratch[2],Fout[m3] , *tw3 );
   2ab78:	f853 8006 	ldr.w	r8, [r3, r6]
   2ab7c:	930b      	str	r3, [sp, #44]	; 0x2c
            C_MUL(scratch[0],Fout[m] , *tw1 );
   2ab7e:	f854 3c04 	ldr.w	r3, [r4, #-4]
            C_MUL(scratch[1],Fout[m2] , *tw2 );
   2ab82:	f9b7 4002 	ldrsh.w	r4, [r7, #2]
            C_MUL(scratch[2],Fout[m3] , *tw3 );
   2ab86:	f9b5 9000 	ldrsh.w	r9, [r5]
            C_MUL(scratch[0],Fout[m] , *tw1 );
   2ab8a:	9309      	str	r3, [sp, #36]	; 0x24
   2ab8c:	fa1f fc81 	uxth.w	ip, r1
   2ab90:	9b02      	ldr	r3, [sp, #8]
            C_MUL(scratch[2],Fout[m3] , *tw3 );
   2ab92:	f9b5 6002 	ldrsh.w	r6, [r5, #2]
            C_MUL(scratch[0],Fout[m] , *tw1 );
   2ab96:	f9b3 a002 	ldrsh.w	sl, [r3, #2]
            C_MUL(scratch[1],Fout[m2] , *tw2 );
   2ab9a:	fb0c f002 	mul.w	r0, ip, r2
   2ab9e:	1409      	asrs	r1, r1, #16
   2aba0:	fb04 fc0c 	mul.w	ip, r4, ip
            C_MUL(scratch[2],Fout[m3] , *tw3 );
   2aba4:	464f      	mov	r7, r9
            C_MUL(scratch[1],Fout[m2] , *tw2 );
   2aba6:	fb01 f502 	mul.w	r5, r1, r2
            C_MUL(scratch[0],Fout[m] , *tw1 );
   2abaa:	f9b3 9000 	ldrsh.w	r9, [r3]
            C_MUL(scratch[2],Fout[m3] , *tw3 );
   2abae:	970a      	str	r7, [sp, #40]	; 0x28
   2abb0:	fa1f f38e 	uxth.w	r3, lr
            C_MUL(scratch[1],Fout[m2] , *tw2 );
   2abb4:	ea4f 3cec 	mov.w	ip, ip, asr #15
   2abb8:	fb04 f101 	mul.w	r1, r4, r1
   2abbc:	ea4f 4e2e 	mov.w	lr, lr, asr #16
   2abc0:	13c0      	asrs	r0, r0, #15
   2abc2:	eb0c 0141 	add.w	r1, ip, r1, lsl #1
   2abc6:	fb03 fc04 	mul.w	ip, r3, r4
   2abca:	eb00 0545 	add.w	r5, r0, r5, lsl #1
   2abce:	fb03 f302 	mul.w	r3, r3, r2
   2abd2:	fb0e f004 	mul.w	r0, lr, r4
   2abd6:	fb0e f202 	mul.w	r2, lr, r2
   2abda:	ea4f 3cec 	mov.w	ip, ip, asr #15
   2abde:	fa1f fe88 	uxth.w	lr, r8
   2abe2:	eb0c 0440 	add.w	r4, ip, r0, lsl #1
   2abe6:	13db      	asrs	r3, r3, #15
            C_MUL(scratch[2],Fout[m3] , *tw3 );
   2abe8:	fb0e f007 	mul.w	r0, lr, r7
            C_MUL(scratch[1],Fout[m2] , *tw2 );
   2abec:	eb03 0342 	add.w	r3, r3, r2, lsl #1
            C_MUL(scratch[2],Fout[m3] , *tw3 );
   2abf0:	13c2      	asrs	r2, r0, #15
            C_MUL(scratch[1],Fout[m2] , *tw2 );
   2abf2:	1b28      	subs	r0, r5, r4
            C_SUB( scratch[5] , *Fout, scratch[1] );
   2abf4:	9d01      	ldr	r5, [sp, #4]
            C_MUL(scratch[2],Fout[m3] , *tw3 );
   2abf6:	9211      	str	r2, [sp, #68]	; 0x44
            C_SUB( scratch[5] , *Fout, scratch[1] );
   2abf8:	f855 4c08 	ldr.w	r4, [r5, #-8]
   2abfc:	4627      	mov	r7, r4
   2abfe:	9c09      	ldr	r4, [sp, #36]	; 0x24
            C_MUL(scratch[2],Fout[m3] , *tw3 );
   2ac00:	fb06 fe0e 	mul.w	lr, r6, lr
   2ac04:	ea4f 3cee 	mov.w	ip, lr, asr #15
            C_MUL(scratch[1],Fout[m2] , *tw2 );
   2ac08:	4419      	add	r1, r3
   2ac0a:	f8dd e034 	ldr.w	lr, [sp, #52]	; 0x34
            C_MUL(scratch[2],Fout[m3] , *tw3 );
   2ac0e:	f8cd c048 	str.w	ip, [sp, #72]	; 0x48
            C_MUL(scratch[0],Fout[m] , *tw1 );
   2ac12:	1423      	asrs	r3, r4, #16
            C_MUL(scratch[1],Fout[m2] , *tw2 );
   2ac14:	910d      	str	r1, [sp, #52]	; 0x34
            C_MUL(scratch[0],Fout[m] , *tw1 );
   2ac16:	9309      	str	r3, [sp, #36]	; 0x24
            C_ADDTO(*Fout, scratch[1]);
   2ac18:	19c1      	adds	r1, r0, r7
   2ac1a:	f8dd c030 	ldr.w	ip, [sp, #48]	; 0x30
   2ac1e:	970c      	str	r7, [sp, #48]	; 0x30
            C_MUL(scratch[2],Fout[m3] , *tw3 );
   2ac20:	9f0a      	ldr	r7, [sp, #40]	; 0x28
   2ac22:	fa1f f28e 	uxth.w	r2, lr
   2ac26:	b2a5      	uxth	r5, r4
            C_ADDTO(*Fout, scratch[1]);
   2ac28:	460c      	mov	r4, r1
   2ac2a:	940e      	str	r4, [sp, #56]	; 0x38
            C_MUL(scratch[2],Fout[m3] , *tw3 );
   2ac2c:	fb02 f106 	mul.w	r1, r2, r6
   2ac30:	fb02 f207 	mul.w	r2, r2, r7
            C_ADDTO(*Fout, scratch[1]);
   2ac34:	4627      	mov	r7, r4
   2ac36:	9c01      	ldr	r4, [sp, #4]
   2ac38:	f844 7c08 	str.w	r7, [r4, #-8]
            C_MUL(scratch[0],Fout[m] , *tw1 );
   2ac3c:	fb05 f709 	mul.w	r7, r5, r9
   2ac40:	fa1f f38c 	uxth.w	r3, ip
   2ac44:	13ff      	asrs	r7, r7, #15
   2ac46:	970f      	str	r7, [sp, #60]	; 0x3c
   2ac48:	fb03 f70a 	mul.w	r7, r3, sl
   2ac4c:	13ff      	asrs	r7, r7, #15
   2ac4e:	9710      	str	r7, [sp, #64]	; 0x40
            C_SUB( scratch[5] , *Fout, scratch[1] );
   2ac50:	9f0c      	ldr	r7, [sp, #48]	; 0x30
            C_MUL(scratch[2],Fout[m3] , *tw3 );
   2ac52:	9c0a      	ldr	r4, [sp, #40]	; 0x28
            C_SUB( scratch[5] , *Fout, scratch[1] );
   2ac54:	1a38      	subs	r0, r7, r0
            C_MUL(scratch[2],Fout[m3] , *tw3 );
   2ac56:	ea4f 4828 	mov.w	r8, r8, asr #16
   2ac5a:	9f11      	ldr	r7, [sp, #68]	; 0x44
            C_SUB( scratch[5] , *Fout, scratch[1] );
   2ac5c:	900c      	str	r0, [sp, #48]	; 0x30
            C_MUL(scratch[2],Fout[m3] , *tw3 );
   2ac5e:	ea4f 4e2e 	mov.w	lr, lr, asr #16
   2ac62:	fb08 f004 	mul.w	r0, r8, r4
   2ac66:	13c9      	asrs	r1, r1, #15
   2ac68:	13d2      	asrs	r2, r2, #15
   2ac6a:	fb06 f808 	mul.w	r8, r6, r8
   2ac6e:	fb0e f606 	mul.w	r6, lr, r6
   2ac72:	fb0e fe04 	mul.w	lr, lr, r4
   2ac76:	eb07 0040 	add.w	r0, r7, r0, lsl #1
   2ac7a:	eb02 0e4e 	add.w	lr, r2, lr, lsl #1
   2ac7e:	eb01 0646 	add.w	r6, r1, r6, lsl #1
            C_MUL(scratch[0],Fout[m] , *tw1 );
   2ac82:	9a09      	ldr	r2, [sp, #36]	; 0x24
            C_MUL(scratch[2],Fout[m3] , *tw3 );
   2ac84:	9f12      	ldr	r7, [sp, #72]	; 0x48
   2ac86:	1b86      	subs	r6, r0, r6
            C_MUL(scratch[0],Fout[m] , *tw1 );
   2ac88:	980f      	ldr	r0, [sp, #60]	; 0x3c
   2ac8a:	fb02 f109 	mul.w	r1, r2, r9
   2ac8e:	ea4f 4c2c 	mov.w	ip, ip, asr #16
   2ac92:	fb0a f402 	mul.w	r4, sl, r2
   2ac96:	fb0a f505 	mul.w	r5, sl, r5
   2ac9a:	fb0c f20a 	mul.w	r2, ip, sl
   2ac9e:	eb00 0a41 	add.w	sl, r0, r1, lsl #1
   2aca2:	9910      	ldr	r1, [sp, #64]	; 0x40
   2aca4:	fb03 f309 	mul.w	r3, r3, r9
   2aca8:	13db      	asrs	r3, r3, #15
   2acaa:	fb0c fc09 	mul.w	ip, ip, r9
   2acae:	eb01 0942 	add.w	r9, r1, r2, lsl #1
   2acb2:	eb03 0c4c 	add.w	ip, r3, ip, lsl #1
            C_SUB( scratch[5] , *Fout, scratch[1] );
   2acb6:	9a01      	ldr	r2, [sp, #4]
            C_SUB( Fout[m2], *Fout, scratch[3] );
   2acb8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
            C_SUB( scratch[5] , *Fout, scratch[1] );
   2acba:	f852 1c04 	ldr.w	r1, [r2, #-4]
            C_MUL(scratch[0],Fout[m] , *tw1 );
   2acbe:	ebaa 0a09 	sub.w	sl, sl, r9
            C_ADD( scratch[3] , scratch[0] , scratch[2] );
   2acc2:	eb0a 0906 	add.w	r9, sl, r6
            C_MUL(scratch[0],Fout[m] , *tw1 );
   2acc6:	13ed      	asrs	r5, r5, #15
            C_MUL(scratch[2],Fout[m3] , *tw3 );
   2acc8:	eb07 0848 	add.w	r8, r7, r8, lsl #1
            C_ADDTO(*Fout, scratch[1]);
   2accc:	9f0d      	ldr	r7, [sp, #52]	; 0x34
            C_MUL(scratch[0],Fout[m] , *tw1 );
   2acce:	eb05 0444 	add.w	r4, r5, r4, lsl #1
            C_SUB( Fout[m2], *Fout, scratch[3] );
   2acd2:	eba3 0309 	sub.w	r3, r3, r9
            C_MUL(scratch[0],Fout[m] , *tw1 );
   2acd6:	4464      	add	r4, ip
            C_MUL(scratch[2],Fout[m3] , *tw3 );
   2acd8:	44f0      	add	r8, lr
            C_SUB( Fout[m2], *Fout, scratch[3] );
   2acda:	9309      	str	r3, [sp, #36]	; 0x24
            C_ADDTO(*Fout, scratch[1]);
   2acdc:	463a      	mov	r2, r7
   2acde:	9b01      	ldr	r3, [sp, #4]
   2ace0:	440a      	add	r2, r1
            C_ADD( scratch[3] , scratch[0] , scratch[2] );
   2ace2:	eb04 0508 	add.w	r5, r4, r8
            C_ADDTO(*Fout, scratch[1]);
   2ace6:	f843 2c04 	str.w	r2, [r3, #-4]
            C_SUB( Fout[m2], *Fout, scratch[3] );
   2acea:	1b50      	subs	r0, r2, r5
   2acec:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   2acee:	9b09      	ldr	r3, [sp, #36]	; 0x24
   2acf0:	4694      	mov	ip, r2
   2acf2:	9a07      	ldr	r2, [sp, #28]
   2acf4:	f84c 3002 	str.w	r3, [ip, r2]
   2acf8:	f84b 0002 	str.w	r0, [fp, r2]
            C_ADDTO( *Fout , scratch[3] );
   2acfc:	9801      	ldr	r0, [sp, #4]
            C_SUB( Fout[m2], *Fout, scratch[3] );
   2acfe:	4696      	mov	lr, r2
            C_ADDTO( *Fout , scratch[3] );
   2ad00:	f850 3c08 	ldr.w	r3, [r0, #-8]
   2ad04:	f850 2c04 	ldr.w	r2, [r0, #-4]
            C_SUB( scratch[5] , *Fout, scratch[1] );
   2ad08:	1bc9      	subs	r1, r1, r7
            C_ADDTO( *Fout , scratch[3] );
   2ad0a:	4415      	add	r5, r2
            C_SUB( scratch[4] , scratch[0] , scratch[2] );
   2ad0c:	ebaa 0606 	sub.w	r6, sl, r6
            C_ADDTO( *Fout , scratch[3] );
   2ad10:	444b      	add	r3, r9
   2ad12:	f840 3c08 	str.w	r3, [r0, #-8]
            Fout[m].i = SUB32_ovflw(scratch[5].i, scratch[4].r);
   2ad16:	1b8a      	subs	r2, r1, r6
            C_ADDTO( *Fout , scratch[3] );
   2ad18:	f840 5c04 	str.w	r5, [r0, #-4]
            Fout[m3].i = ADD32_ovflw(scratch[5].i, scratch[4].r);
   2ad1c:	440e      	add	r6, r1
            tw2 += fstride*2;
   2ad1e:	9f03      	ldr	r7, [sp, #12]
   2ad20:	9916      	ldr	r1, [sp, #88]	; 0x58
            tw1 += fstride;
   2ad22:	9b02      	ldr	r3, [sp, #8]
            tw2 += fstride*2;
   2ad24:	440f      	add	r7, r1
   2ad26:	9703      	str	r7, [sp, #12]
            tw3 += fstride*3;
   2ad28:	9917      	ldr	r1, [sp, #92]	; 0x5c
   2ad2a:	9f04      	ldr	r7, [sp, #16]
   2ad2c:	3008      	adds	r0, #8
   2ad2e:	440f      	add	r7, r1
            C_SUB( scratch[4] , scratch[0] , scratch[2] );
   2ad30:	eba4 0808 	sub.w	r8, r4, r8
   2ad34:	9001      	str	r0, [sp, #4]
            Fout[m].r = ADD32_ovflw(scratch[5].r, scratch[4].i);
   2ad36:	9c0c      	ldr	r4, [sp, #48]	; 0x30
            Fout[m].i = SUB32_ovflw(scratch[5].i, scratch[4].r);
   2ad38:	9806      	ldr	r0, [sp, #24]
            tw3 += fstride*3;
   2ad3a:	9704      	str	r7, [sp, #16]
            tw1 += fstride;
   2ad3c:	9f15      	ldr	r7, [sp, #84]	; 0x54
            Fout[m].r = ADD32_ovflw(scratch[5].r, scratch[4].i);
   2ad3e:	9905      	ldr	r1, [sp, #20]
   2ad40:	eb04 0508 	add.w	r5, r4, r8
            tw1 += fstride;
   2ad44:	19df      	adds	r7, r3, r7
   2ad46:	f100 0308 	add.w	r3, r0, #8
            Fout[m].r = ADD32_ovflw(scratch[5].r, scratch[4].i);
   2ad4a:	f841 5c04 	str.w	r5, [r1, #-4]
   2ad4e:	9306      	str	r3, [sp, #24]
            Fout[m].i = SUB32_ovflw(scratch[5].i, scratch[4].r);
   2ad50:	6042      	str	r2, [r0, #4]
         for (j=0;j<m;j++)
   2ad52:	9b14      	ldr	r3, [sp, #80]	; 0x50
   2ad54:	9801      	ldr	r0, [sp, #4]
            Fout[m3].r = SUB32_ovflw(scratch[5].r, scratch[4].i);
   2ad56:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
            tw1 += fstride;
   2ad58:	9702      	str	r7, [sp, #8]
   2ad5a:	f101 0508 	add.w	r5, r1, #8
            Fout[m3].r = SUB32_ovflw(scratch[5].r, scratch[4].i);
   2ad5e:	9908      	ldr	r1, [sp, #32]
   2ad60:	9505      	str	r5, [sp, #20]
   2ad62:	eba4 0408 	sub.w	r4, r4, r8
         for (j=0;j<m;j++)
   2ad66:	4283      	cmp	r3, r0
            Fout[m3].r = SUB32_ovflw(scratch[5].r, scratch[4].i);
   2ad68:	5054      	str	r4, [r2, r1]
            Fout[m3].i = ADD32_ovflw(scratch[5].i, scratch[4].r);
   2ad6a:	f84b 6001 	str.w	r6, [fp, r1]
         for (j=0;j<m;j++)
   2ad6e:	f47f aeef 	bne.w	2ab50 <opus_fft_impl+0x7f8>
   2ad72:	9a18      	ldr	r2, [sp, #96]	; 0x60
   2ad74:	991e      	ldr	r1, [sp, #120]	; 0x78
      for (i=0;i<N;i++)
   2ad76:	9b19      	ldr	r3, [sp, #100]	; 0x64
   2ad78:	440a      	add	r2, r1
   2ad7a:	9218      	str	r2, [sp, #96]	; 0x60
   2ad7c:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   2ad7e:	3301      	adds	r3, #1
   2ad80:	429a      	cmp	r2, r3
   2ad82:	9319      	str	r3, [sp, #100]	; 0x64
   2ad84:	f47f aed5 	bne.w	2ab32 <opus_fft_impl+0x7da>
   2ad88:	e694      	b.n	2aab4 <opus_fft_impl+0x75c>
          m2 = 1;
   2ad8a:	2301      	movs	r3, #1
   2ad8c:	931f      	str	r3, [sp, #124]	; 0x7c
          kf_bfly3(fout,fstride[i]<<shift,st,m, fstride[i], m2);
   2ad8e:	9b1c      	ldr	r3, [sp, #112]	; 0x70
   2ad90:	992b      	ldr	r1, [sp, #172]	; 0xac
   2ad92:	aa2c      	add	r2, sp, #176	; 0xb0
   2ad94:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
   2ad98:	9212      	str	r2, [sp, #72]	; 0x48
   2ad9a:	4613      	mov	r3, r2
   for (i=0;i<N;i++)
   2ad9c:	2a00      	cmp	r2, #0
          kf_bfly3(fout,fstride[i]<<shift,st,m, fstride[i], m2);
   2ad9e:	fa03 f301 	lsl.w	r3, r3, r1
   for (i=0;i<N;i++)
   2ada2:	f77f ae87 	ble.w	2aab4 <opus_fft_impl+0x75c>
         C_MUL(scratch[1],Fout[m] , *tw1);
   2ada6:	9810      	ldr	r0, [sp, #64]	; 0x40
      tw1=tw2=st->twiddles;
   2ada8:	9929      	ldr	r1, [sp, #164]	; 0xa4
         C_MUL(scratch[1],Fout[m] , *tw1);
   2adaa:	00c2      	lsls	r2, r0, #3
      tw1=tw2=st->twiddles;
   2adac:	6b49      	ldr	r1, [r1, #52]	; 0x34
         C_MUL(scratch[1],Fout[m] , *tw1);
   2adae:	920c      	str	r2, [sp, #48]	; 0x30
      tw1=tw2=st->twiddles;
   2adb0:	9113      	str	r1, [sp, #76]	; 0x4c
   2adb2:	f1a2 0108 	sub.w	r1, r2, #8
   2adb6:	3a04      	subs	r2, #4
   2adb8:	9216      	str	r2, [sp, #88]	; 0x58
         tw1 += fstride;
   2adba:	009a      	lsls	r2, r3, #2
         tw2 += fstride*2;
   2adbc:	00db      	lsls	r3, r3, #3
   2adbe:	930e      	str	r3, [sp, #56]	; 0x38
   2adc0:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   2adc2:	9115      	str	r1, [sp, #84]	; 0x54
   2adc4:	00db      	lsls	r3, r3, #3
   2adc6:	9314      	str	r3, [sp, #80]	; 0x50
   2adc8:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
         tw1 += fstride;
   2adca:	920d      	str	r2, [sp, #52]	; 0x34
   2adcc:	3308      	adds	r3, #8
         C_MUL(scratch[2],Fout[m2] , *tw2);
   2adce:	ea4f 1800 	mov.w	r8, r0, lsl #4
   2add2:	930f      	str	r3, [sp, #60]	; 0x3c
   for (i=0;i<N;i++)
   2add4:	2300      	movs	r3, #0
   2add6:	9311      	str	r3, [sp, #68]	; 0x44
   2add8:	f8cd 8010 	str.w	r8, [sp, #16]
   2addc:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
   2adde:	9b15      	ldr	r3, [sp, #84]	; 0x54
   2ade0:	9a16      	ldr	r2, [sp, #88]	; 0x58
      k=m;
   2ade2:	9403      	str	r4, [sp, #12]
   2ade4:	eb03 0804 	add.w	r8, r3, r4
      tw1=tw2=st->twiddles;
   2ade8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   2adea:	eb02 0904 	add.w	r9, r2, r4
   2adee:	e9cd 3301 	strd	r3, r3, [sp, #4]
      k=m;
   2adf2:	9b10      	ldr	r3, [sp, #64]	; 0x40
   2adf4:	9306      	str	r3, [sp, #24]
   2adf6:	46cb      	mov	fp, r9
   2adf8:	46c2      	mov	sl, r8
   2adfa:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   2adfc:	f85b 4c04 	ldr.w	r4, [fp, #-4]
         C_MUL(scratch[1],Fout[m] , *tw1);
   2ae00:	9e01      	ldr	r6, [sp, #4]
   2ae02:	ebaa 0302 	sub.w	r3, sl, r2
   2ae06:	ebab 0002 	sub.w	r0, fp, r2
         C_MUL(scratch[2],Fout[m2] , *tw2);
   2ae0a:	930b      	str	r3, [sp, #44]	; 0x2c
   2ae0c:	461a      	mov	r2, r3
   2ae0e:	9b04      	ldr	r3, [sp, #16]
   2ae10:	900a      	str	r0, [sp, #40]	; 0x28
   2ae12:	58d1      	ldr	r1, [r2, r3]
   2ae14:	58c2      	ldr	r2, [r0, r3]
   2ae16:	9802      	ldr	r0, [sp, #8]
         C_MUL(scratch[1],Fout[m] , *tw1);
   2ae18:	f9b6 9000 	ldrsh.w	r9, [r6]
         C_MUL(scratch[2],Fout[m2] , *tw2);
   2ae1c:	f9b0 3000 	ldrsh.w	r3, [r0]
   2ae20:	f9b0 c002 	ldrsh.w	ip, [r0, #2]
         C_MUL(scratch[1],Fout[m] , *tw1);
   2ae24:	f9b6 0002 	ldrsh.w	r0, [r6, #2]
   2ae28:	b2a5      	uxth	r5, r4
   2ae2a:	f85b 4c04 	ldr.w	r4, [fp, #-4]
   2ae2e:	b28f      	uxth	r7, r1
         C_MUL(scratch[2],Fout[m2] , *tw2);
   2ae30:	1409      	asrs	r1, r1, #16
   2ae32:	9109      	str	r1, [sp, #36]	; 0x24
   2ae34:	fb01 fe03 	mul.w	lr, r1, r3
         C_MUL(scratch[1],Fout[m] , *tw1);
   2ae38:	1421      	asrs	r1, r4, #16
   2ae3a:	f8da 4004 	ldr.w	r4, [sl, #4]
   2ae3e:	9105      	str	r1, [sp, #20]
   2ae40:	b2a4      	uxth	r4, r4
         C_MUL(scratch[2],Fout[m2] , *tw2);
   2ae42:	fb07 f803 	mul.w	r8, r7, r3
   2ae46:	9408      	str	r4, [sp, #32]
         C_MUL(scratch[1],Fout[m] , *tw1);
   2ae48:	f8da 4004 	ldr.w	r4, [sl, #4]
         C_MUL(scratch[2],Fout[m2] , *tw2);
   2ae4c:	9909      	ldr	r1, [sp, #36]	; 0x24
   2ae4e:	b296      	uxth	r6, r2
   2ae50:	ea4f 38e8 	mov.w	r8, r8, asr #15
   2ae54:	eb08 084e 	add.w	r8, r8, lr, lsl #1
   2ae58:	1412      	asrs	r2, r2, #16
   2ae5a:	fb06 fe0c 	mul.w	lr, r6, ip
         C_MUL(scratch[1],Fout[m] , *tw1);
   2ae5e:	1424      	asrs	r4, r4, #16
         C_MUL(scratch[2],Fout[m2] , *tw2);
   2ae60:	fb0c f707 	mul.w	r7, ip, r7
         C_MUL(scratch[1],Fout[m] , *tw1);
   2ae64:	9407      	str	r4, [sp, #28]
         C_MUL(scratch[2],Fout[m2] , *tw2);
   2ae66:	ea4f 3eee 	mov.w	lr, lr, asr #15
   2ae6a:	fb06 f603 	mul.w	r6, r6, r3
   2ae6e:	13ff      	asrs	r7, r7, #15
   2ae70:	fb0c f101 	mul.w	r1, ip, r1
   2ae74:	fb02 fc0c 	mul.w	ip, r2, ip
   2ae78:	fb02 f203 	mul.w	r2, r2, r3
         C_MUL(scratch[1],Fout[m] , *tw1);
   2ae7c:	9b08      	ldr	r3, [sp, #32]
   2ae7e:	9c07      	ldr	r4, [sp, #28]
         C_MUL(scratch[2],Fout[m2] , *tw2);
   2ae80:	eb07 0141 	add.w	r1, r7, r1, lsl #1
   2ae84:	eb0e 0c4c 	add.w	ip, lr, ip, lsl #1
         C_MUL(scratch[1],Fout[m] , *tw1);
   2ae88:	9f05      	ldr	r7, [sp, #20]
         C_MUL(scratch[2],Fout[m2] , *tw2);
   2ae8a:	eba8 0c0c 	sub.w	ip, r8, ip
         C_MUL(scratch[1],Fout[m] , *tw1);
   2ae8e:	fb03 fe00 	mul.w	lr, r3, r0
   2ae92:	fb07 f809 	mul.w	r8, r7, r9
         C_MUL(scratch[2],Fout[m2] , *tw2);
   2ae96:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
         C_MUL(scratch[1],Fout[m] , *tw1);
   2ae9a:	fb04 f700 	mul.w	r7, r4, r0
   2ae9e:	fb05 fc09 	mul.w	ip, r5, r9
         C_MUL(scratch[2],Fout[m2] , *tw2);
   2aea2:	13f6      	asrs	r6, r6, #15
         C_MUL(scratch[1],Fout[m] , *tw1);
   2aea4:	ea4f 3eee 	mov.w	lr, lr, asr #15
   2aea8:	eb0e 0e47 	add.w	lr, lr, r7, lsl #1
         C_MUL(scratch[2],Fout[m2] , *tw2);
   2aeac:	eb06 0642 	add.w	r6, r6, r2, lsl #1
         C_MUL(scratch[1],Fout[m] , *tw1);
   2aeb0:	9f05      	ldr	r7, [sp, #20]
         Fout[m].r = SUB32_ovflw(Fout->r, HALF_OF(scratch[3].r));
   2aeb2:	9a03      	ldr	r2, [sp, #12]
         C_MUL(scratch[1],Fout[m] , *tw1);
   2aeb4:	ea4f 3cec 	mov.w	ip, ip, asr #15
   2aeb8:	fb03 f309 	mul.w	r3, r3, r9
   2aebc:	eb0c 0c48 	add.w	ip, ip, r8, lsl #1
   2aec0:	fb04 f909 	mul.w	r9, r4, r9
         C_ADD(scratch[3],scratch[1],scratch[2]);
   2aec4:	9c09      	ldr	r4, [sp, #36]	; 0x24
         C_MUL(scratch[1],Fout[m] , *tw1);
   2aec6:	fb00 f505 	mul.w	r5, r0, r5
   2aeca:	ebac 0c0e 	sub.w	ip, ip, lr
   2aece:	fb00 f007 	mul.w	r0, r0, r7
         Fout[m].r = SUB32_ovflw(Fout->r, HALF_OF(scratch[3].r));
   2aed2:	f852 7c08 	ldr.w	r7, [r2, #-8]
         C_ADD(scratch[3],scratch[1],scratch[2]);
   2aed6:	eb0c 0e04 	add.w	lr, ip, r4
         C_MUL(scratch[1],Fout[m] , *tw1);
   2aeda:	13ed      	asrs	r5, r5, #15
         Fout[m].r = SUB32_ovflw(Fout->r, HALF_OF(scratch[3].r));
   2aedc:	eba7 026e 	sub.w	r2, r7, lr, asr #1
         C_MUL(scratch[1],Fout[m] , *tw1);
   2aee0:	eb05 0540 	add.w	r5, r5, r0, lsl #1
   2aee4:	13db      	asrs	r3, r3, #15
         Fout[m].i = SUB32_ovflw(Fout->i, HALF_OF(scratch[3].i));
   2aee6:	9803      	ldr	r0, [sp, #12]
         Fout[m].r = SUB32_ovflw(Fout->r, HALF_OF(scratch[3].r));
   2aee8:	f84b 2c04 	str.w	r2, [fp, #-4]
         C_MUL(scratch[1],Fout[m] , *tw1);
   2aeec:	eb03 0349 	add.w	r3, r3, r9, lsl #1
   2aef0:	441d      	add	r5, r3
         C_MUL(scratch[2],Fout[m2] , *tw2);
   2aef2:	440e      	add	r6, r1
         Fout[m].i = SUB32_ovflw(Fout->i, HALF_OF(scratch[3].i));
   2aef4:	f850 3c04 	ldr.w	r3, [r0, #-4]
         C_ADD(scratch[3],scratch[1],scratch[2]);
   2aef8:	eb05 0806 	add.w	r8, r5, r6
         Fout[m].i = SUB32_ovflw(Fout->i, HALF_OF(scratch[3].i));
   2aefc:	eba3 0368 	sub.w	r3, r3, r8, asr #1
   2af00:	f8ca 3004 	str.w	r3, [sl, #4]
         C_ADDTO(*Fout,scratch[3]);
   2af04:	f850 3c08 	ldr.w	r3, [r0, #-8]
   2af08:	f850 1c04 	ldr.w	r1, [r0, #-4]
   2af0c:	4473      	add	r3, lr
   2af0e:	4441      	add	r1, r8
   2af10:	f840 1c04 	str.w	r1, [r0, #-4]
   2af14:	f840 3c08 	str.w	r3, [r0, #-8]
         C_SUB(scratch[0],scratch[1],scratch[2]);
   2af18:	1bae      	subs	r6, r5, r6
         C_ADDTO(*Fout,scratch[3]);
   2af1a:	4605      	mov	r5, r0
         C_MULBYSCALAR( scratch[0] , epi3.i );
   2af1c:	4865      	ldr	r0, [pc, #404]	; (2b0b4 <opus_fft_impl+0xd5c>)
         Fout[m2].r = ADD32_ovflw(Fout[m].r, scratch[0].i);
   2af1e:	f85b 3c04 	ldr.w	r3, [fp, #-4]
   2af22:	9904      	ldr	r1, [sp, #16]
         C_MULBYSCALAR( scratch[0] , epi3.i );
   2af24:	b2b2      	uxth	r2, r6
   2af26:	fb00 f202 	mul.w	r2, r0, r2
   2af2a:	1436      	asrs	r6, r6, #16
   2af2c:	13d2      	asrs	r2, r2, #15
   2af2e:	fb00 f606 	mul.w	r6, r0, r6
   2af32:	eb02 0646 	add.w	r6, r2, r6, lsl #1
         Fout[m2].r = ADD32_ovflw(Fout[m].r, scratch[0].i);
   2af36:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
         C_SUB(scratch[0],scratch[1],scratch[2]);
   2af38:	ebac 0c04 	sub.w	ip, ip, r4
         Fout[m2].r = ADD32_ovflw(Fout[m].r, scratch[0].i);
   2af3c:	4614      	mov	r4, r2
   2af3e:	4433      	add	r3, r6
   2af40:	5063      	str	r3, [r4, r1]
         C_MULBYSCALAR( scratch[0] , epi3.i );
   2af42:	fa1f f28c 	uxth.w	r2, ip
   2af46:	fb00 f202 	mul.w	r2, r0, r2
   2af4a:	ea4f 4c2c 	mov.w	ip, ip, asr #16
         Fout[m2].i = SUB32_ovflw(Fout[m].i, scratch[0].r);
   2af4e:	f8da 3004 	ldr.w	r3, [sl, #4]
         C_MULBYSCALAR( scratch[0] , epi3.i );
   2af52:	13d2      	asrs	r2, r2, #15
   2af54:	fb00 fc0c 	mul.w	ip, r0, ip
   2af58:	eb02 0c4c 	add.w	ip, r2, ip, lsl #1
         Fout[m2].i = SUB32_ovflw(Fout[m].i, scratch[0].r);
   2af5c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
         tw2 += fstride*2;
   2af5e:	9802      	ldr	r0, [sp, #8]
         Fout[m2].i = SUB32_ovflw(Fout[m].i, scratch[0].r);
   2af60:	eba3 030c 	sub.w	r3, r3, ip
   2af64:	5053      	str	r3, [r2, r1]
         Fout[m].r = SUB32_ovflw(Fout[m].r, scratch[0].i);
   2af66:	f85b 3c04 	ldr.w	r3, [fp, #-4]
         tw2 += fstride*2;
   2af6a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
         Fout[m].r = SUB32_ovflw(Fout[m].r, scratch[0].i);
   2af6c:	1b9e      	subs	r6, r3, r6
   2af6e:	f84b 6c04 	str.w	r6, [fp, #-4]
         Fout[m].i = ADD32_ovflw(Fout[m].i, scratch[0].r);
   2af72:	f8da 3004 	ldr.w	r3, [sl, #4]
         tw1 += fstride;
   2af76:	9e01      	ldr	r6, [sp, #4]
         Fout[m].i = ADD32_ovflw(Fout[m].i, scratch[0].r);
   2af78:	4463      	add	r3, ip
         tw2 += fstride*2;
   2af7a:	1882      	adds	r2, r0, r2
         Fout[m].i = ADD32_ovflw(Fout[m].i, scratch[0].r);
   2af7c:	f8ca 3004 	str.w	r3, [sl, #4]
         tw2 += fstride*2;
   2af80:	9202      	str	r2, [sp, #8]
      } while(--k);
   2af82:	9b06      	ldr	r3, [sp, #24]
         tw1 += fstride;
   2af84:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   2af86:	3508      	adds	r5, #8
   2af88:	18b2      	adds	r2, r6, r2
      } while(--k);
   2af8a:	3b01      	subs	r3, #1
         tw1 += fstride;
   2af8c:	9201      	str	r2, [sp, #4]
   2af8e:	9503      	str	r5, [sp, #12]
   2af90:	f10b 0b08 	add.w	fp, fp, #8
   2af94:	f10a 0a08 	add.w	sl, sl, #8
      } while(--k);
   2af98:	9306      	str	r3, [sp, #24]
   2af9a:	f47f af2e 	bne.w	2adfa <opus_fft_impl+0xaa2>
   2af9e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   2afa0:	9914      	ldr	r1, [sp, #80]	; 0x50
   for (i=0;i<N;i++)
   2afa2:	9b11      	ldr	r3, [sp, #68]	; 0x44
   2afa4:	440a      	add	r2, r1
   2afa6:	920f      	str	r2, [sp, #60]	; 0x3c
   2afa8:	9a12      	ldr	r2, [sp, #72]	; 0x48
   2afaa:	3301      	adds	r3, #1
   2afac:	429a      	cmp	r2, r3
   2afae:	9311      	str	r3, [sp, #68]	; 0x44
   2afb0:	f47f af14 	bne.w	2addc <opus_fft_impl+0xa84>
   2afb4:	e57e      	b.n	2aab4 <opus_fft_impl+0x75c>
      for (i=0;i<N;i++)
   2afb6:	9d1a      	ldr	r5, [sp, #104]	; 0x68
   2afb8:	2d00      	cmp	r5, #0
   2afba:	f77f ad7b 	ble.w	2aab4 <opus_fft_impl+0x75c>
   2afbe:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
   2afc0:	f04f 0e00 	mov.w	lr, #0
   2afc4:	3320      	adds	r3, #32
         C_SUB( scratch0 , *Fout, Fout[2] );
   2afc6:	f853 6c10 	ldr.w	r6, [r3, #-16]
         C_ADD( scratch1 , Fout[1] , Fout[3] );
   2afca:	f853 9c18 	ldr.w	r9, [r3, #-24]
         C_SUB( scratch0 , *Fout, Fout[2] );
   2afce:	f853 1c20 	ldr.w	r1, [r3, #-32]
         C_ADD( scratch1 , Fout[1] , Fout[3] );
   2afd2:	f853 0c08 	ldr.w	r0, [r3, #-8]
   2afd6:	f853 4c14 	ldr.w	r4, [r3, #-20]
   2afda:	f853 8c04 	ldr.w	r8, [r3, #-4]
         C_SUB( scratch0 , *Fout, Fout[2] );
   2afde:	f853 7c0c 	ldr.w	r7, [r3, #-12]
   2afe2:	f853 2c1c 	ldr.w	r2, [r3, #-28]
   2afe6:	eba1 0c06 	sub.w	ip, r1, r6
         C_ADDTO(*Fout, Fout[2]);
   2afea:	4431      	add	r1, r6
         C_ADD( scratch1 , Fout[1] , Fout[3] );
   2afec:	eb09 0600 	add.w	r6, r9, r0
         C_SUB( scratch1 , Fout[1] , Fout[3] );
   2aff0:	eba9 0000 	sub.w	r0, r9, r0
         C_SUB( Fout[2], *Fout, scratch1 );
   2aff4:	eba1 0906 	sub.w	r9, r1, r6
         C_ADDTO( *Fout , scratch1 );
   2aff8:	4431      	add	r1, r6
         C_SUB( scratch1 , Fout[1] , Fout[3] );
   2affa:	eba4 0608 	sub.w	r6, r4, r8
         C_ADDTO( *Fout , scratch1 );
   2affe:	f843 1c20 	str.w	r1, [r3, #-32]
         C_ADD( scratch1 , Fout[1] , Fout[3] );
   2b002:	eb04 0108 	add.w	r1, r4, r8
         Fout[1].r = ADD32_ovflw(scratch0.r, scratch1.i);
   2b006:	eb0c 0406 	add.w	r4, ip, r6
   2b00a:	f843 4c18 	str.w	r4, [r3, #-24]
      for (i=0;i<N;i++)
   2b00e:	f10e 0e01 	add.w	lr, lr, #1
         C_ADDTO(*Fout, Fout[2]);
   2b012:	19d4      	adds	r4, r2, r7
         C_SUB( scratch0 , *Fout, Fout[2] );
   2b014:	1bd2      	subs	r2, r2, r7
         Fout[3].r = SUB32_ovflw(scratch0.r, scratch1.i);
   2b016:	ebac 0606 	sub.w	r6, ip, r6
         C_SUB( Fout[2], *Fout, scratch1 );
   2b01a:	1a67      	subs	r7, r4, r1
      for (i=0;i<N;i++)
   2b01c:	4575      	cmp	r5, lr
         C_ADDTO( *Fout , scratch1 );
   2b01e:	4421      	add	r1, r4
         Fout[1].i = SUB32_ovflw(scratch0.i, scratch1.r);
   2b020:	eba2 0400 	sub.w	r4, r2, r0
         Fout[3].i = ADD32_ovflw(scratch0.i, scratch1.r);
   2b024:	4402      	add	r2, r0
         C_SUB( Fout[2], *Fout, scratch1 );
   2b026:	f843 9c10 	str.w	r9, [r3, #-16]
   2b02a:	e943 7603 	strd	r7, r6, [r3, #-12]
         C_ADDTO( *Fout , scratch1 );
   2b02e:	f843 1c1c 	str.w	r1, [r3, #-28]
         Fout[1].i = SUB32_ovflw(scratch0.i, scratch1.r);
   2b032:	f843 4c14 	str.w	r4, [r3, #-20]
         Fout[3].i = ADD32_ovflw(scratch0.i, scratch1.r);
   2b036:	f843 2c04 	str.w	r2, [r3, #-4]
   2b03a:	f103 0320 	add.w	r3, r3, #32
      for (i=0;i<N;i++)
   2b03e:	d1c2      	bne.n	2afc6 <opus_fft_impl+0xc6e>
   2b040:	e538      	b.n	2aab4 <opus_fft_impl+0x75c>
       fstride[L+1] = fstride[L]*p;
   2b042:	2304      	movs	r3, #4
   2b044:	931c      	str	r3, [sp, #112]	; 0x70
   2b046:	2205      	movs	r2, #5
   2b048:	462b      	mov	r3, r5
   2b04a:	f7ff b9d3 	b.w	2a3f4 <opus_fft_impl+0x9c>
    L=0;
   2b04e:	2300      	movs	r3, #0
   2b050:	931c      	str	r3, [sp, #112]	; 0x70
   2b052:	462b      	mov	r3, r5
   2b054:	f7ff b9ce 	b.w	2a3f4 <opus_fft_impl+0x9c>
       fstride[L+1] = fstride[L]*p;
   2b058:	921c      	str	r2, [sp, #112]	; 0x70
   2b05a:	462b      	mov	r3, r5
   2b05c:	2202      	movs	r2, #2
   2b05e:	f7ff b9c9 	b.w	2a3f4 <opus_fft_impl+0x9c>
       switch (st->factors[2*i])
   2b062:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   2b064:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
   2b068:	3b02      	subs	r3, #2
   2b06a:	2b03      	cmp	r3, #3
   2b06c:	f63f aa85 	bhi.w	2a57a <opus_fft_impl+0x222>
   2b070:	a201      	add	r2, pc, #4	; (adr r2, 2b078 <opus_fft_impl+0xd20>)
   2b072:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   2b076:	bf00      	nop
   2b078:	0002b0ad 	.word	0x0002b0ad
   2b07c:	0002ad8b 	.word	0x0002ad8b
   2b080:	0002aac9 	.word	0x0002aac9
   2b084:	0002a581 	.word	0x0002a581
       fstride[L+1] = fstride[L]*p;
   2b088:	2302      	movs	r3, #2
   2b08a:	931c      	str	r3, [sp, #112]	; 0x70
   2b08c:	2203      	movs	r2, #3
   2b08e:	462b      	mov	r3, r5
   2b090:	f7ff b9b0 	b.w	2a3f4 <opus_fft_impl+0x9c>
   2b094:	2303      	movs	r3, #3
   2b096:	931c      	str	r3, [sp, #112]	; 0x70
   2b098:	2204      	movs	r2, #4
   2b09a:	462b      	mov	r3, r5
   2b09c:	f7ff b9aa 	b.w	2a3f4 <opus_fft_impl+0x9c>
   2b0a0:	2305      	movs	r3, #5
   2b0a2:	931c      	str	r3, [sp, #112]	; 0x70
   2b0a4:	2206      	movs	r2, #6
   2b0a6:	462b      	mov	r3, r5
   2b0a8:	f7ff b9a4 	b.w	2a3f4 <opus_fft_impl+0x9c>
          m2 = 1;
   2b0ac:	2301      	movs	r3, #1
   2b0ae:	9310      	str	r3, [sp, #64]	; 0x40
   2b0b0:	f7ff b9bf 	b.w	2a432 <opus_fft_impl+0xda>
   2b0b4:	ffff9126 	.word	0xffff9126

0002b0b8 <ec_laplace_encode>:
   ft = 32768 - LAPLACE_MINP*(2*LAPLACE_NMIN) - fs0;
   return ft*(opus_int32)(16384-decay)>>15;
}

void ec_laplace_encode(ec_enc *enc, int *value, unsigned fs, int decay)
{
   2b0b8:	b5f0      	push	{r4, r5, r6, r7, lr}
   unsigned fl;
   int val = *value;
   2b0ba:	680d      	ldr	r5, [r1, #0]
   fl = 0;
   if (val)
   2b0bc:	b3b5      	cbz	r5, 2b12c <ec_laplace_encode+0x74>
   ft = 32768 - LAPLACE_MINP*(2*LAPLACE_NMIN) - fs0;
   2b0be:	f5c2 47ff 	rsb	r7, r2, #32640	; 0x7f80
   2b0c2:	3760      	adds	r7, #96	; 0x60
   return ft*(opus_int32)(16384-decay)>>15;
   2b0c4:	f5c3 4480 	rsb	r4, r3, #16384	; 0x4000
   {
      int s;
      int i;
      s = -(val<0);
   2b0c8:	0fee      	lsrs	r6, r5, #31
   return ft*(opus_int32)(16384-decay)>>15;
   2b0ca:	fb04 f407 	mul.w	r4, r4, r7
   2b0ce:	1bad      	subs	r5, r5, r6
      s = -(val<0);
   2b0d0:	4277      	negs	r7, r6
      val = (val+s)^s;
      fl = fs;
      fs = ec_laplace_get_freq1(fs, decay);
      /* Search the decaying part of the PDF.*/
      for (i=1; fs > 0 && i < val; i++)
   2b0d2:	0be4      	lsrs	r4, r4, #15
      val = (val+s)^s;
   2b0d4:	ea85 0507 	eor.w	r5, r5, r7
      for (i=1; fs > 0 && i < val; i++)
   2b0d8:	d03b      	beq.n	2b152 <ec_laplace_encode+0x9a>
   2b0da:	2d01      	cmp	r5, #1
   2b0dc:	dd2d      	ble.n	2b13a <ec_laplace_encode+0x82>
   2b0de:	f04f 0e01 	mov.w	lr, #1
   2b0e2:	e001      	b.n	2b0e8 <ec_laplace_encode+0x30>
   2b0e4:	4575      	cmp	r5, lr
   2b0e6:	d028      	beq.n	2b13a <ec_laplace_encode+0x82>
      {
         fs *= 2;
   2b0e8:	0064      	lsls	r4, r4, #1
         fl += fs+2*LAPLACE_MINP;
   2b0ea:	f104 0c02 	add.w	ip, r4, #2
         fs = (fs*(opus_int32)decay)>>15;
   2b0ee:	fb03 f404 	mul.w	r4, r3, r4
      for (i=1; fs > 0 && i < val; i++)
   2b0f2:	0be4      	lsrs	r4, r4, #15
   2b0f4:	f10e 0e01 	add.w	lr, lr, #1
         fl += fs+2*LAPLACE_MINP;
   2b0f8:	4462      	add	r2, ip
      for (i=1; fs > 0 && i < val; i++)
   2b0fa:	d1f3      	bne.n	2b0e4 <ec_laplace_encode+0x2c>
      /* Everything beyond that has probability LAPLACE_MINP. */
      if (!fs)
      {
         int di;
         int ndi_max;
         ndi_max = (32768-fl+LAPLACE_MINP-1)>>LAPLACE_LOG_MINP;
   2b0fc:	f5c2 4300 	rsb	r3, r2, #32768	; 0x8000
         ndi_max = (ndi_max-s)>>1;
   2b100:	4433      	add	r3, r6
   2b102:	105b      	asrs	r3, r3, #1
         di = IMIN(val - i, ndi_max - 1);
   2b104:	eba5 050e 	sub.w	r5, r5, lr
   2b108:	3b01      	subs	r3, #1
   2b10a:	42ab      	cmp	r3, r5
   2b10c:	bfa8      	it	ge
   2b10e:	462b      	movge	r3, r5
         fl += (2*di+1+s)*LAPLACE_MINP;
   2b110:	ebc6 0543 	rsb	r5, r6, r3, lsl #1
   2b114:	3501      	adds	r5, #1
         fs = IMIN(LAPLACE_MINP, 32768-fl);
         *value = (i+di+s)^s;
   2b116:	449e      	add	lr, r3
         fl += (2*di+1+s)*LAPLACE_MINP;
   2b118:	4415      	add	r5, r2
         fs = IMIN(LAPLACE_MINP, 32768-fl);
   2b11a:	f5c5 4200 	rsb	r2, r5, #32768	; 0x8000
         *value = (i+di+s)^s;
   2b11e:	ebae 0606 	sub.w	r6, lr, r6
   2b122:	4077      	eors	r7, r6
         fs = IMIN(LAPLACE_MINP, 32768-fl);
   2b124:	2a01      	cmp	r2, #1
         *value = (i+di+s)^s;
   2b126:	600f      	str	r7, [r1, #0]
         fs = IMIN(LAPLACE_MINP, 32768-fl);
   2b128:	bf28      	it	cs
   2b12a:	2201      	movcs	r2, #1
         fl += fs&~s;
      }
      celt_assert(fl+fs<=32768);
      celt_assert(fs>0);
   }
   ec_encode_bin(enc, fl, fl+fs, 15);
   2b12c:	442a      	add	r2, r5
   2b12e:	4629      	mov	r1, r5
   2b130:	230f      	movs	r3, #15
}
   2b132:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   ec_encode_bin(enc, fl, fl+fs, 15);
   2b136:	f7fe bdc7 	b.w	29cc8 <ec_encode_bin>
         fs += LAPLACE_MINP;
   2b13a:	3401      	adds	r4, #1
         fl += fs&~s;
   2b13c:	1e75      	subs	r5, r6, #1
   2b13e:	4025      	ands	r5, r4
   2b140:	4415      	add	r5, r2
         fs += LAPLACE_MINP;
   2b142:	4622      	mov	r2, r4
   ec_encode_bin(enc, fl, fl+fs, 15);
   2b144:	442a      	add	r2, r5
   2b146:	4629      	mov	r1, r5
   2b148:	230f      	movs	r3, #15
}
   2b14a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   ec_encode_bin(enc, fl, fl+fs, 15);
   2b14e:	f7fe bdbb 	b.w	29cc8 <ec_encode_bin>
      for (i=1; fs > 0 && i < val; i++)
   2b152:	f04f 0e01 	mov.w	lr, #1
   2b156:	e7d1      	b.n	2b0fc <ec_laplace_encode+0x44>

0002b158 <isqrt32>:
  /*Uses the second method from
     http://www.azillionmonkeys.com/qed/sqroot.html
    The main idea is to search for the largest binary digit b such that
     (g+b)*(g+b) <= _val, and add it to the solution g.*/
  g=0;
  bshift=(EC_ILOG(_val)-1)>>1;
   2b158:	fab0 f280 	clz	r2, r0
   2b15c:	f1c2 021f 	rsb	r2, r2, #31
   2b160:	1052      	asrs	r2, r2, #1
  b=1U<<bshift;
   2b162:	2101      	movs	r1, #1
   2b164:	4091      	lsls	r1, r2
unsigned isqrt32(opus_uint32 _val){
   2b166:	4603      	mov	r3, r0
  do{
    opus_uint32 t;
    t=(((opus_uint32)g<<1)+b)<<bshift;
   2b168:	fa01 f002 	lsl.w	r0, r1, r2
    if(t<=_val){
   2b16c:	4298      	cmp	r0, r3
unsigned isqrt32(opus_uint32 _val){
   2b16e:	b470      	push	{r4, r5, r6}
      g+=b;
      _val-=t;
   2b170:	bf96      	itet	ls
   2b172:	1a1b      	subls	r3, r3, r0
  g=0;
   2b174:	2000      	movhi	r0, #0
      g+=b;
   2b176:	4608      	movls	r0, r1
    }
    b>>=1;
    bshift--;
  }
  while(bshift>=0);
   2b178:	1e56      	subs	r6, r2, #1
    b>>=1;
   2b17a:	ea4f 0551 	mov.w	r5, r1, lsr #1
  while(bshift>=0);
   2b17e:	f100 80be 	bmi.w	2b2fe <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
   2b182:	eb05 0440 	add.w	r4, r5, r0, lsl #1
   2b186:	40b4      	lsls	r4, r6
    if(t<=_val){
   2b188:	42a3      	cmp	r3, r4
      g+=b;
   2b18a:	bf28      	it	cs
   2b18c:	1940      	addcs	r0, r0, r5
    bshift--;
   2b18e:	f1a2 0502 	sub.w	r5, r2, #2
      _val-=t;
   2b192:	bf28      	it	cs
   2b194:	1b1b      	subcs	r3, r3, r4
  while(bshift>=0);
   2b196:	1c6c      	adds	r4, r5, #1
    b>>=1;
   2b198:	ea4f 0691 	mov.w	r6, r1, lsr #2
  while(bshift>=0);
   2b19c:	f000 80af 	beq.w	2b2fe <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
   2b1a0:	eb06 0440 	add.w	r4, r6, r0, lsl #1
   2b1a4:	40ac      	lsls	r4, r5
    if(t<=_val){
   2b1a6:	42a3      	cmp	r3, r4
    bshift--;
   2b1a8:	f1a2 0503 	sub.w	r5, r2, #3
      g+=b;
   2b1ac:	bf24      	itt	cs
   2b1ae:	1980      	addcs	r0, r0, r6
      _val-=t;
   2b1b0:	1b1b      	subcs	r3, r3, r4
  while(bshift>=0);
   2b1b2:	1c6c      	adds	r4, r5, #1
    b>>=1;
   2b1b4:	ea4f 06d1 	mov.w	r6, r1, lsr #3
  while(bshift>=0);
   2b1b8:	f000 80a1 	beq.w	2b2fe <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
   2b1bc:	eb06 0440 	add.w	r4, r6, r0, lsl #1
   2b1c0:	40ac      	lsls	r4, r5
    if(t<=_val){
   2b1c2:	42a3      	cmp	r3, r4
    bshift--;
   2b1c4:	f1a2 0504 	sub.w	r5, r2, #4
      g+=b;
   2b1c8:	bf24      	itt	cs
   2b1ca:	1980      	addcs	r0, r0, r6
      _val-=t;
   2b1cc:	1b1b      	subcs	r3, r3, r4
  while(bshift>=0);
   2b1ce:	1c6c      	adds	r4, r5, #1
    b>>=1;
   2b1d0:	ea4f 1611 	mov.w	r6, r1, lsr #4
  while(bshift>=0);
   2b1d4:	f000 8093 	beq.w	2b2fe <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
   2b1d8:	eb06 0440 	add.w	r4, r6, r0, lsl #1
   2b1dc:	40ac      	lsls	r4, r5
    if(t<=_val){
   2b1de:	42a3      	cmp	r3, r4
    bshift--;
   2b1e0:	f1a2 0505 	sub.w	r5, r2, #5
      g+=b;
   2b1e4:	bf24      	itt	cs
   2b1e6:	1980      	addcs	r0, r0, r6
      _val-=t;
   2b1e8:	1b1b      	subcs	r3, r3, r4
  while(bshift>=0);
   2b1ea:	1c6c      	adds	r4, r5, #1
    b>>=1;
   2b1ec:	ea4f 1651 	mov.w	r6, r1, lsr #5
  while(bshift>=0);
   2b1f0:	f000 8085 	beq.w	2b2fe <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
   2b1f4:	eb06 0440 	add.w	r4, r6, r0, lsl #1
   2b1f8:	40ac      	lsls	r4, r5
    if(t<=_val){
   2b1fa:	42a3      	cmp	r3, r4
    bshift--;
   2b1fc:	f1a2 0506 	sub.w	r5, r2, #6
      g+=b;
   2b200:	bf24      	itt	cs
   2b202:	1980      	addcs	r0, r0, r6
      _val-=t;
   2b204:	1b1b      	subcs	r3, r3, r4
  while(bshift>=0);
   2b206:	1c6c      	adds	r4, r5, #1
    b>>=1;
   2b208:	ea4f 1691 	mov.w	r6, r1, lsr #6
  while(bshift>=0);
   2b20c:	d077      	beq.n	2b2fe <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
   2b20e:	eb06 0440 	add.w	r4, r6, r0, lsl #1
   2b212:	40ac      	lsls	r4, r5
    if(t<=_val){
   2b214:	42a3      	cmp	r3, r4
    bshift--;
   2b216:	f1a2 0507 	sub.w	r5, r2, #7
      g+=b;
   2b21a:	bf24      	itt	cs
   2b21c:	1980      	addcs	r0, r0, r6
      _val-=t;
   2b21e:	1b1b      	subcs	r3, r3, r4
  while(bshift>=0);
   2b220:	1c6c      	adds	r4, r5, #1
    b>>=1;
   2b222:	ea4f 16d1 	mov.w	r6, r1, lsr #7
  while(bshift>=0);
   2b226:	d06a      	beq.n	2b2fe <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
   2b228:	eb06 0440 	add.w	r4, r6, r0, lsl #1
   2b22c:	40ac      	lsls	r4, r5
    if(t<=_val){
   2b22e:	42a3      	cmp	r3, r4
    bshift--;
   2b230:	f1a2 0508 	sub.w	r5, r2, #8
      g+=b;
   2b234:	bf24      	itt	cs
   2b236:	1980      	addcs	r0, r0, r6
      _val-=t;
   2b238:	1b1b      	subcs	r3, r3, r4
  while(bshift>=0);
   2b23a:	1c6c      	adds	r4, r5, #1
    b>>=1;
   2b23c:	ea4f 2611 	mov.w	r6, r1, lsr #8
  while(bshift>=0);
   2b240:	d05d      	beq.n	2b2fe <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
   2b242:	eb06 0440 	add.w	r4, r6, r0, lsl #1
   2b246:	40ac      	lsls	r4, r5
    if(t<=_val){
   2b248:	42a3      	cmp	r3, r4
    bshift--;
   2b24a:	f1a2 0509 	sub.w	r5, r2, #9
      g+=b;
   2b24e:	bf24      	itt	cs
   2b250:	1980      	addcs	r0, r0, r6
      _val-=t;
   2b252:	1b1b      	subcs	r3, r3, r4
  while(bshift>=0);
   2b254:	1c6c      	adds	r4, r5, #1
    b>>=1;
   2b256:	ea4f 2651 	mov.w	r6, r1, lsr #9
  while(bshift>=0);
   2b25a:	d050      	beq.n	2b2fe <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
   2b25c:	eb06 0440 	add.w	r4, r6, r0, lsl #1
   2b260:	40ac      	lsls	r4, r5
    if(t<=_val){
   2b262:	42a3      	cmp	r3, r4
    bshift--;
   2b264:	f1a2 050a 	sub.w	r5, r2, #10
      g+=b;
   2b268:	bf24      	itt	cs
   2b26a:	1980      	addcs	r0, r0, r6
      _val-=t;
   2b26c:	1b1b      	subcs	r3, r3, r4
  while(bshift>=0);
   2b26e:	1c6c      	adds	r4, r5, #1
    b>>=1;
   2b270:	ea4f 2691 	mov.w	r6, r1, lsr #10
  while(bshift>=0);
   2b274:	d043      	beq.n	2b2fe <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
   2b276:	eb06 0440 	add.w	r4, r6, r0, lsl #1
   2b27a:	40ac      	lsls	r4, r5
    if(t<=_val){
   2b27c:	42a3      	cmp	r3, r4
    bshift--;
   2b27e:	f1a2 050b 	sub.w	r5, r2, #11
      g+=b;
   2b282:	bf24      	itt	cs
   2b284:	1980      	addcs	r0, r0, r6
      _val-=t;
   2b286:	1b1b      	subcs	r3, r3, r4
  while(bshift>=0);
   2b288:	1c6c      	adds	r4, r5, #1
    b>>=1;
   2b28a:	ea4f 26d1 	mov.w	r6, r1, lsr #11
  while(bshift>=0);
   2b28e:	d036      	beq.n	2b2fe <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
   2b290:	eb06 0440 	add.w	r4, r6, r0, lsl #1
   2b294:	40ac      	lsls	r4, r5
    if(t<=_val){
   2b296:	42a3      	cmp	r3, r4
    bshift--;
   2b298:	f1a2 050c 	sub.w	r5, r2, #12
      g+=b;
   2b29c:	bf24      	itt	cs
   2b29e:	1980      	addcs	r0, r0, r6
      _val-=t;
   2b2a0:	1b1b      	subcs	r3, r3, r4
  while(bshift>=0);
   2b2a2:	1c6c      	adds	r4, r5, #1
    b>>=1;
   2b2a4:	ea4f 3611 	mov.w	r6, r1, lsr #12
  while(bshift>=0);
   2b2a8:	d029      	beq.n	2b2fe <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
   2b2aa:	eb06 0440 	add.w	r4, r6, r0, lsl #1
   2b2ae:	40ac      	lsls	r4, r5
    if(t<=_val){
   2b2b0:	42a3      	cmp	r3, r4
    bshift--;
   2b2b2:	f1a2 050d 	sub.w	r5, r2, #13
      g+=b;
   2b2b6:	bf24      	itt	cs
   2b2b8:	1980      	addcs	r0, r0, r6
      _val-=t;
   2b2ba:	1b1b      	subcs	r3, r3, r4
  while(bshift>=0);
   2b2bc:	1c6c      	adds	r4, r5, #1
    b>>=1;
   2b2be:	ea4f 3651 	mov.w	r6, r1, lsr #13
  while(bshift>=0);
   2b2c2:	d01c      	beq.n	2b2fe <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
   2b2c4:	eb06 0440 	add.w	r4, r6, r0, lsl #1
   2b2c8:	40ac      	lsls	r4, r5
    if(t<=_val){
   2b2ca:	42a3      	cmp	r3, r4
    bshift--;
   2b2cc:	f1a2 050e 	sub.w	r5, r2, #14
      g+=b;
   2b2d0:	bf24      	itt	cs
   2b2d2:	1980      	addcs	r0, r0, r6
      _val-=t;
   2b2d4:	1b1b      	subcs	r3, r3, r4
  while(bshift>=0);
   2b2d6:	1c6c      	adds	r4, r5, #1
    b>>=1;
   2b2d8:	ea4f 3691 	mov.w	r6, r1, lsr #14
  while(bshift>=0);
   2b2dc:	d00f      	beq.n	2b2fe <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
   2b2de:	eb06 0440 	add.w	r4, r6, r0, lsl #1
   2b2e2:	40ac      	lsls	r4, r5
    if(t<=_val){
   2b2e4:	42a3      	cmp	r3, r4
      g+=b;
   2b2e6:	bf24      	itt	cs
   2b2e8:	1980      	addcs	r0, r0, r6
      _val-=t;
   2b2ea:	1b1b      	subcs	r3, r3, r4
  while(bshift>=0);
   2b2ec:	2a0f      	cmp	r2, #15
    b>>=1;
   2b2ee:	ea4f 31d1 	mov.w	r1, r1, lsr #15
  while(bshift>=0);
   2b2f2:	d104      	bne.n	2b2fe <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
   2b2f4:	eb01 0240 	add.w	r2, r1, r0, lsl #1
    if(t<=_val){
   2b2f8:	429a      	cmp	r2, r3
      g+=b;
   2b2fa:	bf98      	it	ls
   2b2fc:	1840      	addls	r0, r0, r1
  return g;
}
   2b2fe:	bc70      	pop	{r4, r5, r6}
   2b300:	4770      	bx	lr
   2b302:	bf00      	nop

0002b304 <frac_div32>:
   return EC_ILOG(x)-1;
   2b304:	fab1 f381 	clz	r3, r1

opus_val32 frac_div32(opus_val32 a, opus_val32 b)
{
   opus_val16 rcp;
   opus_val32 result, rem;
   int shift = celt_ilog2(b)-29;
   2b308:	f1c3 031f 	rsb	r3, r3, #31
   2b30c:	f1a3 021d 	sub.w	r2, r3, #29
   a = VSHR32(a,shift);
   2b310:	2a00      	cmp	r2, #0
{
   2b312:	b4f0      	push	{r4, r5, r6, r7}
   a = VSHR32(a,shift);
   2b314:	dd70      	ble.n	2b3f8 <frac_div32+0xf4>
   2b316:	fa40 f502 	asr.w	r5, r0, r2
   b = VSHR32(b,shift);
   2b31a:	4111      	asrs	r1, r2
   /* 16-bit reciprocal */
   rcp = ROUND16(celt_rcp(ROUND16(b,16)),3);
   2b31c:	f501 4400 	add.w	r4, r1, #32768	; 0x8000
   2b320:	1424      	asrs	r4, r4, #16
   2b322:	fab4 f684 	clz	r6, r4
   2b326:	f1c6 061f 	rsb	r6, r6, #31
   opus_val16 n;
   opus_val16 r;
   celt_sig_assert(x>0);
   i = celt_ilog2(x);
   /* n is Q15 with range [0,1). */
   n = VSHR32(x,i-15)-32768;
   2b32a:	2e0f      	cmp	r6, #15
   2b32c:	bfcb      	itete	gt
   2b32e:	f1a6 030f 	subgt.w	r3, r6, #15
   2b332:	f1c6 030f 	rsble	r3, r6, #15
   2b336:	411c      	asrgt	r4, r3
   2b338:	409c      	lslle	r4, r3
   2b33a:	f5a4 4400 	sub.w	r4, r4, #32768	; 0x8000
   2b33e:	b224      	sxth	r4, r4
   /* Start with a linear approximation:
      r = 1.8823529411764706-0.9411764705882353*n.
      The coefficients and the result are Q14 in the range [15420,30840].*/
   r = ADD16(30840, MULT16_16_Q15(-15420, n));
   2b340:	f24c 30c4 	movw	r0, #50116	; 0xc3c4
   2b344:	fb14 f000 	smulbb	r0, r4, r0
   2b348:	f3c0 30cf 	ubfx	r0, r0, #15, #16
   2b34c:	f500 42f0 	add.w	r2, r0, #30720	; 0x7800
   2b350:	3278      	adds	r2, #120	; 0x78
   2b352:	b292      	uxth	r2, r2
   2b354:	b213      	sxth	r3, r2
   /* Perform two Newton iterations:
      r -= r*((r*n)-1.Q15)
         = r*((r*n)+(r-1.Q15)). */
   r = SUB16(r, MULT16_16_Q15(r,
   2b356:	fb04 f703 	mul.w	r7, r4, r3
   2b35a:	f5a0 60f1 	sub.w	r0, r0, #1928	; 0x788
   2b35e:	eb00 30e7 	add.w	r0, r0, r7, asr #15
   2b362:	fb10 f003 	smulbb	r0, r0, r3
   2b366:	eba2 32e0 	sub.w	r2, r2, r0, asr #15
   2b36a:	b292      	uxth	r2, r2
   2b36c:	b210      	sxth	r0, r2
             ADD16(MULT16_16_Q15(r, n), ADD16(r, -32768))));
   /* We subtract an extra 1 in the second iteration to avoid overflow; it also
       neatly compensates for truncation error in the rest of the process. */
   r = SUB16(r, ADD16(1, MULT16_16_Q15(r,
   2b36e:	fb04 f400 	mul.w	r4, r4, r0
   2b372:	f5a2 4300 	sub.w	r3, r2, #32768	; 0x8000
   2b376:	eb03 33e4 	add.w	r3, r3, r4, asr #15
   2b37a:	fb13 f400 	smulbb	r4, r3, r0
   2b37e:	1e53      	subs	r3, r2, #1
             ADD16(MULT16_16_Q15(r, n), ADD16(r, -32768)))));
   /* r is now the Q15 solution to 2/(n+1), with a maximum relative error
       of 7.05346E-5, a (relative) RMSE of 2.14418E-5, and a peak absolute
       error of 1.24665/32768. */
   return VSHR32(EXTEND32(r),i-16);
   2b380:	2e10      	cmp	r6, #16
   r = SUB16(r, ADD16(1, MULT16_16_Q15(r,
   2b382:	eba3 33e4 	sub.w	r3, r3, r4, asr #15
   2b386:	b21b      	sxth	r3, r3
   return VSHR32(EXTEND32(r),i-16);
   2b388:	bfcb      	itete	gt
   2b38a:	3e10      	subgt	r6, #16
   2b38c:	f1c6 0610 	rsble	r6, r6, #16
   2b390:	4133      	asrgt	r3, r6
   2b392:	40b3      	lslle	r3, r6
   rcp = ROUND16(celt_rcp(ROUND16(b,16)),3);
   2b394:	3304      	adds	r3, #4
   result = MULT16_32_Q15(rcp, a);
   2b396:	f343 03cf 	sbfx	r3, r3, #3, #16
   2b39a:	b2aa      	uxth	r2, r5
   2b39c:	1428      	asrs	r0, r5, #16
   2b39e:	fb03 f202 	mul.w	r2, r3, r2
   2b3a2:	fb03 f000 	mul.w	r0, r3, r0
   2b3a6:	13d2      	asrs	r2, r2, #15
   2b3a8:	eb02 0240 	add.w	r2, r2, r0, lsl #1
   rem = PSHR32(a,2)-MULT32_32_Q31(result, b);
   2b3ac:	1416      	asrs	r6, r2, #16
   2b3ae:	140c      	asrs	r4, r1, #16
   2b3b0:	fb04 f006 	mul.w	r0, r4, r6
   2b3b4:	b289      	uxth	r1, r1
   2b3b6:	fb06 f101 	mul.w	r1, r6, r1
   2b3ba:	0040      	lsls	r0, r0, #1
   2b3bc:	b296      	uxth	r6, r2
   2b3be:	eb00 30e1 	add.w	r0, r0, r1, asr #15
   2b3c2:	fb04 f406 	mul.w	r4, r4, r6
   2b3c6:	3502      	adds	r5, #2
   2b3c8:	eb00 30e4 	add.w	r0, r0, r4, asr #15
   2b3cc:	ebc0 00a5 	rsb	r0, r0, r5, asr #2
   result = ADD32(result, SHL32(MULT16_32_Q15(rcp, rem),2));
   2b3d0:	b281      	uxth	r1, r0
   2b3d2:	fb03 f101 	mul.w	r1, r3, r1
   2b3d6:	1400      	asrs	r0, r0, #16
   2b3d8:	13c9      	asrs	r1, r1, #15
   2b3da:	fb03 f000 	mul.w	r0, r3, r0
   2b3de:	eb01 0040 	add.w	r0, r1, r0, lsl #1
   2b3e2:	eb02 0280 	add.w	r2, r2, r0, lsl #2
   if (result >= 536870912)       /*  2^29 */
   2b3e6:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
   2b3ea:	da0b      	bge.n	2b404 <frac_div32+0x100>
   else if (result <= -536870912) /* -2^29 */
   2b3ec:	f1b2 4f60 	cmp.w	r2, #3758096384	; 0xe0000000
   2b3f0:	dd0c      	ble.n	2b40c <frac_div32+0x108>
      return SHL32(result, 2);
   2b3f2:	0090      	lsls	r0, r2, #2
}
   2b3f4:	bcf0      	pop	{r4, r5, r6, r7}
   2b3f6:	4770      	bx	lr
   a = VSHR32(a,shift);
   2b3f8:	f1c3 031d 	rsb	r3, r3, #29
   2b3fc:	fa00 f503 	lsl.w	r5, r0, r3
   b = VSHR32(b,shift);
   2b400:	4099      	lsls	r1, r3
   2b402:	e78b      	b.n	2b31c <frac_div32+0x18>
      return 2147483647;          /*  2^31 - 1 */
   2b404:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
}
   2b408:	bcf0      	pop	{r4, r5, r6, r7}
   2b40a:	4770      	bx	lr
      return -2147483647;         /* -2^31 */
   2b40c:	4800      	ldr	r0, [pc, #0]	; (2b410 <frac_div32+0x10c>)
   2b40e:	e7f1      	b.n	2b3f4 <frac_div32+0xf0>
   2b410:	80000001 	.word	0x80000001

0002b414 <celt_rsqrt_norm>:
   n = x-32768;
   2b414:	f5a0 4300 	sub.w	r3, r0, #32768	; 0x8000
   2b418:	b21b      	sxth	r3, r3
   r = ADD16(23557, MULT16_16_Q15(n, ADD16(-13490, MULT16_16_Q15(n, 6713))));
   2b41a:	ebc3 1103 	rsb	r1, r3, r3, lsl #4
   2b41e:	ebc3 1181 	rsb	r1, r3, r1, lsl #6
   2b422:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
   2b426:	13c9      	asrs	r1, r1, #15
   2b428:	f5a1 5152 	sub.w	r1, r1, #13440	; 0x3480
   2b42c:	3932      	subs	r1, #50	; 0x32
   2b42e:	fb11 f103 	smulbb	r1, r1, r3
   2b432:	f645 4005 	movw	r0, #23557	; 0x5c05
   2b436:	eb00 31e1 	add.w	r1, r0, r1, asr #15
   2b43a:	b289      	uxth	r1, r1
{
   2b43c:	b410      	push	{r4}
   r = ADD16(23557, MULT16_16_Q15(n, ADD16(-13490, MULT16_16_Q15(n, 6713))));
   2b43e:	b20c      	sxth	r4, r1
   r2 = MULT16_16_Q15(r, r);
   2b440:	fb04 f204 	mul.w	r2, r4, r4
   2b444:	13d2      	asrs	r2, r2, #15
   y = SHL16(SUB16(ADD16(MULT16_16_Q15(r2, n), r2), 16384), 1);
   2b446:	fb12 f003 	smulbb	r0, r2, r3
   2b44a:	f5a2 4380 	sub.w	r3, r2, #16384	; 0x4000
   2b44e:	eb03 33e0 	add.w	r3, r3, r0, asr #15
   2b452:	f343 030e 	sbfx	r3, r3, #0, #15
   2b456:	005b      	lsls	r3, r3, #1
   return ADD16(r, MULT16_16_Q15(r, MULT16_16_Q15(y,
   2b458:	eb03 0243 	add.w	r2, r3, r3, lsl #1
   2b45c:	10d2      	asrs	r2, r2, #3
   2b45e:	f5a2 4280 	sub.w	r2, r2, #16384	; 0x4000
   2b462:	fb12 f303 	smulbb	r3, r2, r3
   2b466:	13db      	asrs	r3, r3, #15
   2b468:	fb04 f303 	mul.w	r3, r4, r3
   2b46c:	eb01 33e3 	add.w	r3, r1, r3, asr #15
}
   2b470:	b218      	sxth	r0, r3
   2b472:	f85d 4b04 	ldr.w	r4, [sp], #4
   2b476:	4770      	bx	lr

0002b478 <celt_sqrt>:
   if (x==0)
   2b478:	b3a8      	cbz	r0, 2b4e6 <celt_sqrt+0x6e>
   else if (x>=1073741824)
   2b47a:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
   2b47e:	da33      	bge.n	2b4e8 <celt_sqrt+0x70>
   2b480:	fab0 f180 	clz	r1, r0
   k = (celt_ilog2(x)>>1)-7;
   2b484:	f1c1 011f 	rsb	r1, r1, #31
   2b488:	1049      	asrs	r1, r1, #1
{
   2b48a:	b410      	push	{r4}
   k = (celt_ilog2(x)>>1)-7;
   2b48c:	1fcc      	subs	r4, r1, #7
   x = VSHR32(x, 2*k);
   2b48e:	2c00      	cmp	r4, #0
   2b490:	dd2d      	ble.n	2b4ee <celt_sqrt+0x76>
   2b492:	0063      	lsls	r3, r4, #1
   2b494:	4118      	asrs	r0, r3
   n = x-32768;
   2b496:	f5a0 4300 	sub.w	r3, r0, #32768	; 0x8000
   2b49a:	b21b      	sxth	r3, r3
   rt = ADD16(C[0], MULT16_16_Q15(n, ADD16(C[1], MULT16_16_Q15(n, ADD16(C[2],
   2b49c:	f64f 5268 	movw	r2, #64872	; 0xfd68
   2b4a0:	fb13 f202 	smulbb	r2, r3, r2
   2b4a4:	13d2      	asrs	r2, r2, #15
   2b4a6:	f202 62a3 	addw	r2, r2, #1699	; 0x6a3
   2b4aa:	b292      	uxth	r2, r2
   2b4ac:	fb03 f202 	mul.w	r2, r3, r2
   2b4b0:	13d2      	asrs	r2, r2, #15
   2b4b2:	f6a2 32c3 	subw	r2, r2, #3011	; 0xbc3
   2b4b6:	fb12 f203 	smulbb	r2, r2, r3
   2b4ba:	f642 5029 	movw	r0, #11561	; 0x2d29
   2b4be:	eb00 30e2 	add.w	r0, r0, r2, asr #15
   2b4c2:	b280      	uxth	r0, r0
   rt = VSHR32(rt,7-k);
   2b4c4:	f1c4 0407 	rsb	r4, r4, #7
   rt = ADD16(C[0], MULT16_16_Q15(n, ADD16(C[1], MULT16_16_Q15(n, ADD16(C[2],
   2b4c8:	fb03 f300 	mul.w	r3, r3, r0
   2b4cc:	f645 2087 	movw	r0, #23175	; 0x5a87
   rt = VSHR32(rt,7-k);
   2b4d0:	2c00      	cmp	r4, #0
   rt = ADD16(C[0], MULT16_16_Q15(n, ADD16(C[1], MULT16_16_Q15(n, ADD16(C[2],
   2b4d2:	eb00 30e3 	add.w	r0, r0, r3, asr #15
   2b4d6:	b200      	sxth	r0, r0
   rt = VSHR32(rt,7-k);
   2b4d8:	bfd6      	itet	le
   2b4da:	390e      	suble	r1, #14
   2b4dc:	4120      	asrgt	r0, r4
   2b4de:	4088      	lslle	r0, r1
}
   2b4e0:	f85d 4b04 	ldr.w	r4, [sp], #4
   2b4e4:	4770      	bx	lr
   2b4e6:	4770      	bx	lr
      return 32767;
   2b4e8:	f647 70ff 	movw	r0, #32767	; 0x7fff
   2b4ec:	4770      	bx	lr
   x = VSHR32(x, 2*k);
   2b4ee:	ebc4 73c4 	rsb	r3, r4, r4, lsl #31
   2b4f2:	005b      	lsls	r3, r3, #1
   2b4f4:	4098      	lsls	r0, r3
   2b4f6:	e7ce      	b.n	2b496 <celt_sqrt+0x1e>

0002b4f8 <celt_cos_norm>:
   x = x&0x0001ffff;
   2b4f8:	f3c0 0310 	ubfx	r3, r0, #0, #17
   if (x>SHL32(EXTEND32(1), 16))
   2b4fc:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
   2b500:	dd34      	ble.n	2b56c <celt_cos_norm+0x74>
      x = SUB32(SHL32(EXTEND32(1), 17),x);
   2b502:	f5c3 3300 	rsb	r3, r3, #131072	; 0x20000
   if (x&0x00007fff)
   2b506:	f3c3 000e 	ubfx	r0, r3, #0, #15
   2b50a:	2800      	cmp	r0, #0
   2b50c:	d067      	beq.n	2b5de <celt_cos_norm+0xe6>
      if (x<SHL32(EXTEND32(1), 15))
   2b50e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
{
   2b512:	b410      	push	{r4}
      if (x<SHL32(EXTEND32(1), 15))
   2b514:	db37      	blt.n	2b586 <celt_cos_norm+0x8e>
         return NEG16(_celt_cos_pi_2(EXTRACT16(65536-x)));
   2b516:	425b      	negs	r3, r3
   x2 = MULT16_16_P15(x,x);
   2b518:	f44f 4080 	mov.w	r0, #16384	; 0x4000
         return NEG16(_celt_cos_pi_2(EXTRACT16(65536-x)));
   2b51c:	b21b      	sxth	r3, r3
   x2 = MULT16_16_P15(x,x);
   2b51e:	fb03 0303 	mla	r3, r3, r3, r0
   2b522:	13db      	asrs	r3, r3, #15
   2b524:	b219      	sxth	r1, r3
   return ADD16(1,MIN16(32766,ADD32(SUB16(L1,x2), MULT16_16_P15(x2, ADD32(L2, MULT16_16_P15(x2, ADD32(L3, MULT16_16_P15(L4, x2
   2b526:	f64f 528e 	movw	r2, #64910	; 0xfd8e
   2b52a:	fb11 0402 	smlabb	r4, r1, r2, r0
   2b52e:	f242 0255 	movw	r2, #8277	; 0x2055
   2b532:	eb02 32e4 	add.w	r2, r2, r4, asr #15
   2b536:	b292      	uxth	r2, r2
   2b538:	fb01 f202 	mul.w	r2, r1, r2
   2b53c:	4402      	add	r2, r0
   2b53e:	13d2      	asrs	r2, r2, #15
   2b540:	f5a2 52ef 	sub.w	r2, r2, #7648	; 0x1de0
   2b544:	3a03      	subs	r2, #3
   2b546:	fb11 0202 	smlabb	r2, r1, r2, r0
   2b54a:	f5c1 41ff 	rsb	r1, r1, #32640	; 0x7f80
   2b54e:	13d2      	asrs	r2, r2, #15
   2b550:	317f      	adds	r1, #127	; 0x7f
   2b552:	f647 70fe 	movw	r0, #32766	; 0x7ffe
   2b556:	4411      	add	r1, r2
   2b558:	4281      	cmp	r1, r0
   2b55a:	bfdb      	ittet	le
   2b55c:	1a9b      	suble	r3, r3, r2
   2b55e:	f5a3 4300 	suble.w	r3, r3, #32768	; 0x8000
   2b562:	4820      	ldrgt	r0, [pc, #128]	; (2b5e4 <celt_cos_norm+0xec>)
   2b564:	b218      	sxthle	r0, r3
}
   2b566:	f85d 4b04 	ldr.w	r4, [sp], #4
   2b56a:	4770      	bx	lr
   if (x&0x00007fff)
   2b56c:	f3c0 020e 	ubfx	r2, r0, #0, #15
   2b570:	2a00      	cmp	r2, #0
   2b572:	d1cc      	bne.n	2b50e <celt_cos_norm+0x16>
      if (x&0x0000ffff)
   2b574:	b280      	uxth	r0, r0
   2b576:	bb98      	cbnz	r0, 2b5e0 <celt_cos_norm+0xe8>
         return -32767;
   2b578:	4a1a      	ldr	r2, [pc, #104]	; (2b5e4 <celt_cos_norm+0xec>)
   2b57a:	f647 70ff 	movw	r0, #32767	; 0x7fff
   2b57e:	2b00      	cmp	r3, #0
   2b580:	bf18      	it	ne
   2b582:	4610      	movne	r0, r2
   2b584:	4770      	bx	lr
   x2 = MULT16_16_P15(x,x);
   2b586:	fb03 f303 	mul.w	r3, r3, r3
   2b58a:	f503 4280 	add.w	r2, r3, #16384	; 0x4000
   return ADD16(1,MIN16(32766,ADD32(SUB16(L1,x2), MULT16_16_P15(x2, ADD32(L2, MULT16_16_P15(x2, ADD32(L3, MULT16_16_P15(L4, x2
   2b58e:	4b16      	ldr	r3, [pc, #88]	; (2b5e8 <celt_cos_norm+0xf0>)
   x2 = MULT16_16_P15(x,x);
   2b590:	13d2      	asrs	r2, r2, #15
   return ADD16(1,MIN16(32766,ADD32(SUB16(L1,x2), MULT16_16_P15(x2, ADD32(L2, MULT16_16_P15(x2, ADD32(L3, MULT16_16_P15(L4, x2
   2b592:	fb03 f302 	mul.w	r3, r3, r2
   2b596:	f503 4180 	add.w	r1, r3, #16384	; 0x4000
   2b59a:	f242 0355 	movw	r3, #8277	; 0x2055
   2b59e:	eb03 33e1 	add.w	r3, r3, r1, asr #15
   2b5a2:	b29b      	uxth	r3, r3
   2b5a4:	fb02 f303 	mul.w	r3, r2, r3
   2b5a8:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
   2b5ac:	13db      	asrs	r3, r3, #15
   2b5ae:	f5a3 53ef 	sub.w	r3, r3, #7648	; 0x1de0
   2b5b2:	3b03      	subs	r3, #3
   2b5b4:	b219      	sxth	r1, r3
   2b5b6:	fb02 f101 	mul.w	r1, r2, r1
   2b5ba:	f501 4180 	add.w	r1, r1, #16384	; 0x4000
   2b5be:	f647 70ff 	movw	r0, #32767	; 0x7fff
   2b5c2:	13c9      	asrs	r1, r1, #15
   2b5c4:	1a83      	subs	r3, r0, r2
   2b5c6:	440b      	add	r3, r1
   2b5c8:	f647 74fe 	movw	r4, #32766	; 0x7ffe
   2b5cc:	42a3      	cmp	r3, r4
   2b5ce:	dcca      	bgt.n	2b566 <celt_cos_norm+0x6e>
   2b5d0:	f5c2 4000 	rsb	r0, r2, #32768	; 0x8000
   2b5d4:	4408      	add	r0, r1
   2b5d6:	b200      	sxth	r0, r0
}
   2b5d8:	f85d 4b04 	ldr.w	r4, [sp], #4
   2b5dc:	4770      	bx	lr
   2b5de:	4770      	bx	lr
         return 0;
   2b5e0:	4610      	mov	r0, r2
}
   2b5e2:	4770      	bx	lr
   2b5e4:	ffff8001 	.word	0xffff8001
   2b5e8:	fffffd8e 	.word	0xfffffd8e

0002b5ec <celt_rcp>:
{
   2b5ec:	b430      	push	{r4, r5}
   2b5ee:	fab0 f480 	clz	r4, r0
   2b5f2:	f1c4 041f 	rsb	r4, r4, #31
   n = VSHR32(x,i-15)-32768;
   2b5f6:	2c0f      	cmp	r4, #15
   2b5f8:	bfcb      	itete	gt
   2b5fa:	f1a4 020f 	subgt.w	r2, r4, #15
   2b5fe:	f1c4 020f 	rsble	r2, r4, #15
   2b602:	fa40 f202 	asrgt.w	r2, r0, r2
   2b606:	fa00 f202 	lslle.w	r2, r0, r2
   2b60a:	f5a2 4200 	sub.w	r2, r2, #32768	; 0x8000
   2b60e:	b212      	sxth	r2, r2
   r = ADD16(30840, MULT16_16_Q15(-15420, n));
   2b610:	f24c 31c4 	movw	r1, #50116	; 0xc3c4
   2b614:	fb12 f101 	smulbb	r1, r2, r1
   2b618:	f3c1 31cf 	ubfx	r1, r1, #15, #16
   2b61c:	f501 43f0 	add.w	r3, r1, #30720	; 0x7800
   2b620:	3378      	adds	r3, #120	; 0x78
   2b622:	b29b      	uxth	r3, r3
   2b624:	b218      	sxth	r0, r3
   r = SUB16(r, MULT16_16_Q15(r,
   2b626:	fb02 f500 	mul.w	r5, r2, r0
   2b62a:	f5a1 61f1 	sub.w	r1, r1, #1928	; 0x788
   2b62e:	eb01 31e5 	add.w	r1, r1, r5, asr #15
   2b632:	fb11 f100 	smulbb	r1, r1, r0
   2b636:	eba3 33e1 	sub.w	r3, r3, r1, asr #15
   2b63a:	b29b      	uxth	r3, r3
   2b63c:	b219      	sxth	r1, r3
   r = SUB16(r, ADD16(1, MULT16_16_Q15(r,
   2b63e:	fb02 f201 	mul.w	r2, r2, r1
   2b642:	f5a3 4000 	sub.w	r0, r3, #32768	; 0x8000
   2b646:	eb00 30e2 	add.w	r0, r0, r2, asr #15
   2b64a:	fb10 f201 	smulbb	r2, r0, r1
   2b64e:	1e58      	subs	r0, r3, #1
   return VSHR32(EXTEND32(r),i-16);
   2b650:	2c10      	cmp	r4, #16
   r = SUB16(r, ADD16(1, MULT16_16_Q15(r,
   2b652:	eba0 30e2 	sub.w	r0, r0, r2, asr #15
   2b656:	b200      	sxth	r0, r0
   return VSHR32(EXTEND32(r),i-16);
   2b658:	bfcb      	itete	gt
   2b65a:	3c10      	subgt	r4, #16
   2b65c:	f1c4 0410 	rsble	r4, r4, #16
   2b660:	4120      	asrgt	r0, r4
   2b662:	40a0      	lslle	r0, r4
}
   2b664:	bc30      	pop	{r4, r5}
   2b666:	4770      	bx	lr

0002b668 <clt_mdct_forward_c>:

/* Forward MDCT trashes the input array */
#ifndef OVERRIDE_clt_mdct_forward
void clt_mdct_forward_c(const mdct_lookup *l, kiss_fft_scalar *in, kiss_fft_scalar * OPUS_RESTRICT out,
      const opus_val16 *window, int overlap, int shift, int stride, int arch)
{
   2b668:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2b66c:	b095      	sub	sp, #84	; 0x54
   2b66e:	af00      	add	r7, sp, #0
#endif
   SAVE_STACK;
   (void)arch;
   scale = st->scale;

   N = l->n;
   2b670:	6806      	ldr	r6, [r0, #0]
{
   2b672:	f8d7 c07c 	ldr.w	ip, [r7, #124]	; 0x7c
   2b676:	633b      	str	r3, [r7, #48]	; 0x30
   const kiss_fft_state *st = l->kfft[shift];
   2b678:	f10c 0402 	add.w	r4, ip, #2
   trig = l->trig;
   for (i=0;i<shift;i++)
   2b67c:	f1bc 0f00 	cmp.w	ip, #0
   const kiss_fft_state *st = l->kfft[shift];
   2b680:	f850 4024 	ldr.w	r4, [r0, r4, lsl #2]
   2b684:	62bc      	str	r4, [r7, #40]	; 0x28
   int scale_shift = st->scale_shift-1;
   2b686:	4625      	mov	r5, r4
   2b688:	68a4      	ldr	r4, [r4, #8]
   scale = st->scale;
   2b68a:	f9b5 5004 	ldrsh.w	r5, [r5, #4]
   trig = l->trig;
   2b68e:	6980      	ldr	r0, [r0, #24]
   scale = st->scale;
   2b690:	613d      	str	r5, [r7, #16]
   int scale_shift = st->scale_shift-1;
   2b692:	f104 33ff 	add.w	r3, r4, #4294967295	; 0xffffffff
   trig = l->trig;
   2b696:	6238      	str	r0, [r7, #32]
{
   2b698:	60ba      	str	r2, [r7, #8]
   int scale_shift = st->scale_shift-1;
   2b69a:	643b      	str	r3, [r7, #64]	; 0x40
   for (i=0;i<shift;i++)
   2b69c:	dd09      	ble.n	2b6b2 <clt_mdct_forward_c+0x4a>
   2b69e:	2300      	movs	r3, #0
   2b6a0:	4602      	mov	r2, r0
   2b6a2:	4665      	mov	r5, ip
   2b6a4:	3301      	adds	r3, #1
   {
      N >>= 1;
   2b6a6:	1076      	asrs	r6, r6, #1
   for (i=0;i<shift;i++)
   2b6a8:	429d      	cmp	r5, r3
      trig += N;
   2b6aa:	eb02 0246 	add.w	r2, r2, r6, lsl #1
   for (i=0;i<shift;i++)
   2b6ae:	d1f9      	bne.n	2b6a4 <clt_mdct_forward_c+0x3c>
   2b6b0:	623a      	str	r2, [r7, #32]

   /* Consider the input to be composed of four blocks: [a, b, c, d] */
   /* Window, shuffle, fold */
   {
      /* Temp pointers to make it really clear to the compiler what we're doing */
      const kiss_fft_scalar * OPUS_RESTRICT xp1 = in+(overlap>>1);
   2b6b2:	6fbc      	ldr	r4, [r7, #120]	; 0x78
   N4 = N>>2;
   2b6b4:	10b0      	asrs	r0, r6, #2
   N2 = N>>1;
   2b6b6:	1075      	asrs	r5, r6, #1
      const kiss_fft_scalar * OPUS_RESTRICT xp1 = in+(overlap>>1);
   2b6b8:	ea4f 0a64 	mov.w	sl, r4, asr #1
   N4 = N>>2;
   2b6bc:	64b8      	str	r0, [r7, #72]	; 0x48
   ALLOC(f2, N4, kiss_fft_cpx);
   2b6be:	00c0      	lsls	r0, r0, #3
   2b6c0:	4604      	mov	r4, r0
   ALLOC(f, N2, kiss_fft_scalar);
   2b6c2:	00ab      	lsls	r3, r5, #2
   ALLOC(f2, N4, kiss_fft_cpx);
   2b6c4:	61b8      	str	r0, [r7, #24]
      const kiss_fft_scalar * OPUS_RESTRICT xp2 = in+N2-1+(overlap>>1);
   2b6c6:	f10a 4080 	add.w	r0, sl, #1073741824	; 0x40000000
   ALLOC(f, N2, kiss_fft_scalar);
   2b6ca:	61fb      	str	r3, [r7, #28]
      const kiss_fft_scalar * OPUS_RESTRICT xp2 = in+N2-1+(overlap>>1);
   2b6cc:	3801      	subs	r0, #1
   ALLOC(f, N2, kiss_fft_scalar);
   2b6ce:	330a      	adds	r3, #10
   2b6d0:	f023 0307 	bic.w	r3, r3, #7
      const kiss_fft_scalar * OPUS_RESTRICT xp2 = in+N2-1+(overlap>>1);
   2b6d4:	4428      	add	r0, r5
   ALLOC(f, N2, kiss_fft_scalar);
   2b6d6:	ebad 0d03 	sub.w	sp, sp, r3
   ALLOC(f2, N4, kiss_fft_cpx);
   2b6da:	f104 0208 	add.w	r2, r4, #8
      kiss_fft_scalar * OPUS_RESTRICT yp = f;
      const opus_val16 * OPUS_RESTRICT wp1 = window+(overlap>>1);
   2b6de:	ea4f 034a 	mov.w	r3, sl, lsl #1
      const kiss_fft_scalar * OPUS_RESTRICT xp2 = in+N2-1+(overlap>>1);
   2b6e2:	eb01 0080 	add.w	r0, r1, r0, lsl #2
      const opus_val16 * OPUS_RESTRICT wp2 = window+(overlap>>1)-1;
      for(i=0;i<((overlap+3)>>2);i++)
   2b6e6:	6fbc      	ldr	r4, [r7, #120]	; 0x78
   N2 = N>>1;
   2b6e8:	60fd      	str	r5, [r7, #12]
      const kiss_fft_scalar * OPUS_RESTRICT xp1 = in+(overlap>>1);
   2b6ea:	eb01 0a8a 	add.w	sl, r1, sl, lsl #2
      const opus_val16 * OPUS_RESTRICT wp2 = window+(overlap>>1)-1;
   2b6ee:	6b39      	ldr	r1, [r7, #48]	; 0x30
      const kiss_fft_scalar * OPUS_RESTRICT xp2 = in+N2-1+(overlap>>1);
   2b6f0:	64f8      	str	r0, [r7, #76]	; 0x4c
   ALLOC(f, N2, kiss_fft_scalar);
   2b6f2:	46ee      	mov	lr, sp
   ALLOC(f2, N4, kiss_fft_cpx);
   2b6f4:	ebad 0d02 	sub.w	sp, sp, r2
      const opus_val16 * OPUS_RESTRICT wp2 = window+(overlap>>1)-1;
   2b6f8:	1e9a      	subs	r2, r3, #2
   2b6fa:	188e      	adds	r6, r1, r2
      for(i=0;i<((overlap+3)>>2);i++)
   2b6fc:	3403      	adds	r4, #3
   2b6fe:	10a4      	asrs	r4, r4, #2
      const opus_val16 * OPUS_RESTRICT wp2 = window+(overlap>>1)-1;
   2b700:	63be      	str	r6, [r7, #56]	; 0x38
      const opus_val16 * OPUS_RESTRICT wp1 = window+(overlap>>1);
   2b702:	18ce      	adds	r6, r1, r3
   2b704:	63fe      	str	r6, [r7, #60]	; 0x3c
      for(i=0;i<((overlap+3)>>2);i++)
   2b706:	2c00      	cmp	r4, #0
   ALLOC(f, N2, kiss_fft_scalar);
   2b708:	f105 36ff 	add.w	r6, r5, #4294967295	; 0xffffffff
   2b70c:	f8c7 e024 	str.w	lr, [r7, #36]	; 0x24
      for(i=0;i<((overlap+3)>>2);i++)
   2b710:	62fc      	str	r4, [r7, #44]	; 0x2c
   ALLOC(f2, N4, kiss_fft_cpx);
   2b712:	f8c7 d044 	str.w	sp, [r7, #68]	; 0x44
   ALLOC(f, N2, kiss_fft_scalar);
   2b716:	617e      	str	r6, [r7, #20]
      for(i=0;i<((overlap+3)>>2);i++)
   2b718:	f340 81b5 	ble.w	2ba86 <clt_mdct_forward_c+0x41e>
   2b71c:	00e1      	lsls	r1, r4, #3
   2b71e:	f101 0308 	add.w	r3, r1, #8
   2b722:	6079      	str	r1, [r7, #4]
   2b724:	4671      	mov	r1, lr
   2b726:	18cc      	adds	r4, r1, r3
   2b728:	69fb      	ldr	r3, [r7, #28]
   2b72a:	637c      	str	r4, [r7, #52]	; 0x34
      {
         /* Real part arranged as -d-cR, Imag part arranged as -b+aR*/
         *yp++ = MULT16_32_Q15(*wp2, xp1[N2]) + MULT16_32_Q15(*wp1,*xp2);
         *yp++ = MULT16_32_Q15(*wp1, *xp1)    - MULT16_32_Q15(*wp2, xp2[-N2]);
   2b72c:	ebc5 7985 	rsb	r9, r5, r5, lsl #30
   2b730:	f04f 0c00 	mov.w	ip, #0
   2b734:	4453      	add	r3, sl
   2b736:	eb00 0989 	add.w	r9, r0, r9, lsl #2
      for(i=0;i<((overlap+3)>>2);i++)
   2b73a:	46e0      	mov	r8, ip
   2b73c:	f10e 0e08 	add.w	lr, lr, #8
   2b740:	469b      	mov	fp, r3
         *yp++ = MULT16_32_Q15(*wp2, xp1[N2]) + MULT16_32_Q15(*wp1,*xp2);
   2b742:	6bb8      	ldr	r0, [r7, #56]	; 0x38
   2b744:	f85b 2038 	ldr.w	r2, [fp, r8, lsl #3]
   2b748:	f930 400c 	ldrsh.w	r4, [r0, ip]
   2b74c:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
   2b74e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   2b750:	f930 5028 	ldrsh.w	r5, [r0, r8, lsl #2]
   2b754:	f853 301c 	ldr.w	r3, [r3, ip, lsl #1]
         *yp++ = MULT16_32_Q15(*wp1, *xp1)    - MULT16_32_Q15(*wp2, xp2[-N2]);
   2b758:	f85a 1038 	ldr.w	r1, [sl, r8, lsl #3]
   2b75c:	f859 601c 	ldr.w	r6, [r9, ip, lsl #1]
         *yp++ = MULT16_32_Q15(*wp2, xp1[N2]) + MULT16_32_Q15(*wp1,*xp2);
   2b760:	b290      	uxth	r0, r2
   2b762:	fb04 f000 	mul.w	r0, r4, r0
   2b766:	1412      	asrs	r2, r2, #16
   2b768:	fb04 f202 	mul.w	r2, r4, r2
   2b76c:	13c0      	asrs	r0, r0, #15
   2b76e:	eb00 0042 	add.w	r0, r0, r2, lsl #1
   2b772:	b29a      	uxth	r2, r3
   2b774:	fb05 f202 	mul.w	r2, r5, r2
   2b778:	141b      	asrs	r3, r3, #16
   2b77a:	fb05 f303 	mul.w	r3, r5, r3
   2b77e:	13d2      	asrs	r2, r2, #15
   2b780:	eb02 0243 	add.w	r2, r2, r3, lsl #1
         *yp++ = MULT16_32_Q15(*wp1, *xp1)    - MULT16_32_Q15(*wp2, xp2[-N2]);
   2b784:	b28b      	uxth	r3, r1
   2b786:	1409      	asrs	r1, r1, #16
   2b788:	fb05 f303 	mul.w	r3, r5, r3
   2b78c:	fb05 f501 	mul.w	r5, r5, r1
   2b790:	b2b1      	uxth	r1, r6
   2b792:	fb04 f101 	mul.w	r1, r4, r1
   2b796:	1436      	asrs	r6, r6, #16
   2b798:	13db      	asrs	r3, r3, #15
   2b79a:	13c9      	asrs	r1, r1, #15
   2b79c:	fb04 f406 	mul.w	r4, r4, r6
   2b7a0:	eb03 0345 	add.w	r3, r3, r5, lsl #1
   2b7a4:	eb01 0444 	add.w	r4, r1, r4, lsl #1
   2b7a8:	1b1c      	subs	r4, r3, r4
         *yp++ = MULT16_32_Q15(*wp2, xp1[N2]) + MULT16_32_Q15(*wp1,*xp2);
   2b7aa:	4402      	add	r2, r0
      for(i=0;i<((overlap+3)>>2);i++)
   2b7ac:	6b7b      	ldr	r3, [r7, #52]	; 0x34
         *yp++ = MULT16_32_Q15(*wp1, *xp1)    - MULT16_32_Q15(*wp2, xp2[-N2]);
   2b7ae:	e94e 2402 	strd	r2, r4, [lr, #-8]
   2b7b2:	f10e 0e08 	add.w	lr, lr, #8
      for(i=0;i<((overlap+3)>>2);i++)
   2b7b6:	4573      	cmp	r3, lr
   2b7b8:	f108 0801 	add.w	r8, r8, #1
   2b7bc:	f1ac 0c04 	sub.w	ip, ip, #4
   2b7c0:	d1bf      	bne.n	2b742 <clt_mdct_forward_c+0xda>
   2b7c2:	6879      	ldr	r1, [r7, #4]
   2b7c4:	6a78      	ldr	r0, [r7, #36]	; 0x24
   2b7c6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   2b7c8:	448a      	add	sl, r1
   2b7ca:	eb00 0801 	add.w	r8, r0, r1
   2b7ce:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
   2b7d0:	ebc2 7342 	rsb	r3, r2, r2, lsl #29
   2b7d4:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
   2b7d8:	64fb      	str	r3, [r7, #76]	; 0x4c
   2b7da:	4694      	mov	ip, r2
   2b7dc:	4611      	mov	r1, r2
         wp1+=2;
         wp2-=2;
      }
      wp1 = window;
      wp2 = window+overlap-1;
      for(;i<N4-((overlap+3)>>2);i++)
   2b7de:	6cba      	ldr	r2, [r7, #72]	; 0x48
      wp2 = window+overlap-1;
   2b7e0:	6fbb      	ldr	r3, [r7, #120]	; 0x78
      for(;i<N4-((overlap+3)>>2);i++)
   2b7e2:	1a51      	subs	r1, r2, r1
      wp2 = window+overlap-1;
   2b7e4:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
   2b7e8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   2b7ea:	3b01      	subs	r3, #1
   2b7ec:	eb02 0343 	add.w	r3, r2, r3, lsl #1
      for(;i<N4-((overlap+3)>>2);i++)
   2b7f0:	4561      	cmp	r1, ip
      wp2 = window+overlap-1;
   2b7f2:	63fb      	str	r3, [r7, #60]	; 0x3c
      for(;i<N4-((overlap+3)>>2);i++)
   2b7f4:	dd22      	ble.n	2b83c <clt_mdct_forward_c+0x1d4>
   2b7f6:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   2b7f8:	ebcc 704c 	rsb	r0, ip, ip, lsl #29
   2b7fc:	eb0a 00c0 	add.w	r0, sl, r0, lsl #3
   2b800:	f108 0308 	add.w	r3, r8, #8
   2b804:	3a08      	subs	r2, #8
   2b806:	4664      	mov	r4, ip
      {
         /* Real part arranged as a-bR, Imag part arranged as -c-dR */
         *yp++ = *xp2;
         *yp++ = *xp1;
   2b808:	f850 503c 	ldr.w	r5, [r0, ip, lsl #3]
         *yp++ = *xp2;
   2b80c:	6896      	ldr	r6, [r2, #8]
   2b80e:	f843 6c08 	str.w	r6, [r3, #-8]
      for(;i<N4-((overlap+3)>>2);i++)
   2b812:	f10c 0c01 	add.w	ip, ip, #1
   2b816:	4561      	cmp	r1, ip
         *yp++ = *xp1;
   2b818:	f843 5c04 	str.w	r5, [r3, #-4]
   2b81c:	f1a2 0208 	sub.w	r2, r2, #8
   2b820:	f103 0308 	add.w	r3, r3, #8
      for(;i<N4-((overlap+3)>>2);i++)
   2b824:	d1f0      	bne.n	2b808 <clt_mdct_forward_c+0x1a0>
   2b826:	ebac 0404 	sub.w	r4, ip, r4
   2b82a:	00e3      	lsls	r3, r4, #3
   2b82c:	4498      	add	r8, r3
   2b82e:	449a      	add	sl, r3
   2b830:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   2b832:	ebc4 7444 	rsb	r4, r4, r4, lsl #29
   2b836:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
   2b83a:	64fb      	str	r3, [r7, #76]	; 0x4c
         xp1+=2;
         xp2-=2;
      }
      for(;i<N4;i++)
   2b83c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   2b83e:	4563      	cmp	r3, ip
   2b840:	f340 8126 	ble.w	2ba90 <clt_mdct_forward_c+0x428>
      {
         /* Real part arranged as a-bR, Imag part arranged as -c-dR */
         *yp++ =  -MULT16_32_Q15(*wp1, xp1[-N2]) + MULT16_32_Q15(*wp2, *xp2);
   2b844:	68fa      	ldr	r2, [r7, #12]
   2b846:	69f9      	ldr	r1, [r7, #28]
   2b848:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
   2b84a:	ebcc 734c 	rsb	r3, ip, ip, lsl #29
   2b84e:	ebc2 7982 	rsb	r9, r2, r2, lsl #30
   2b852:	00da      	lsls	r2, r3, #3
   2b854:	eb02 0989 	add.w	r9, r2, r9, lsl #2
   2b858:	44d1      	add	r9, sl
   2b85a:	4492      	add	sl, r2
   2b85c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   2b85e:	ebcc 738c 	rsb	r3, ip, ip, lsl #30
   2b862:	4401      	add	r1, r0
   2b864:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   2b868:	f108 0808 	add.w	r8, r8, #8
   2b86c:	468b      	mov	fp, r1
   2b86e:	63bb      	str	r3, [r7, #56]	; 0x38
   2b870:	f04f 0e00 	mov.w	lr, #0
   2b874:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   2b876:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
   2b878:	f853 201e 	ldr.w	r2, [r3, lr, lsl #1]
   2b87c:	f930 500e 	ldrsh.w	r5, [r0, lr]
   2b880:	6bb8      	ldr	r0, [r7, #56]	; 0x38
   2b882:	f859 303c 	ldr.w	r3, [r9, ip, lsl #3]
   2b886:	f930 402c 	ldrsh.w	r4, [r0, ip, lsl #2]
         *yp++ = MULT16_32_Q15(*wp2, *xp1)     + MULT16_32_Q15(*wp1, xp2[N2]);
   2b88a:	f85a 103c 	ldr.w	r1, [sl, ip, lsl #3]
   2b88e:	f85b 601e 	ldr.w	r6, [fp, lr, lsl #1]
         *yp++ =  -MULT16_32_Q15(*wp1, xp1[-N2]) + MULT16_32_Q15(*wp2, *xp2);
   2b892:	b290      	uxth	r0, r2
   2b894:	fb05 f000 	mul.w	r0, r5, r0
   2b898:	1412      	asrs	r2, r2, #16
   2b89a:	fb05 f202 	mul.w	r2, r5, r2
   2b89e:	13c0      	asrs	r0, r0, #15
   2b8a0:	eb00 0042 	add.w	r0, r0, r2, lsl #1
   2b8a4:	b29a      	uxth	r2, r3
   2b8a6:	fb04 f202 	mul.w	r2, r4, r2
   2b8aa:	141b      	asrs	r3, r3, #16
   2b8ac:	fb04 f303 	mul.w	r3, r4, r3
   2b8b0:	13d2      	asrs	r2, r2, #15
   2b8b2:	eb02 0243 	add.w	r2, r2, r3, lsl #1
         *yp++ = MULT16_32_Q15(*wp2, *xp1)     + MULT16_32_Q15(*wp1, xp2[N2]);
   2b8b6:	b28b      	uxth	r3, r1
   2b8b8:	1409      	asrs	r1, r1, #16
   2b8ba:	fb05 f303 	mul.w	r3, r5, r3
   2b8be:	fb05 f501 	mul.w	r5, r5, r1
   2b8c2:	b2b1      	uxth	r1, r6
   2b8c4:	fb04 f101 	mul.w	r1, r4, r1
   2b8c8:	1436      	asrs	r6, r6, #16
   2b8ca:	13db      	asrs	r3, r3, #15
   2b8cc:	13c9      	asrs	r1, r1, #15
   2b8ce:	fb04 f406 	mul.w	r4, r4, r6
   2b8d2:	eb03 0345 	add.w	r3, r3, r5, lsl #1
   2b8d6:	eb01 0444 	add.w	r4, r1, r4, lsl #1
   2b8da:	441c      	add	r4, r3
      for(;i<N4;i++)
   2b8dc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
         *yp++ = MULT16_32_Q15(*wp2, *xp1)     + MULT16_32_Q15(*wp1, xp2[N2]);
   2b8de:	f848 4c04 	str.w	r4, [r8, #-4]
      for(;i<N4;i++)
   2b8e2:	f10c 0c01 	add.w	ip, ip, #1
         *yp++ =  -MULT16_32_Q15(*wp1, xp1[-N2]) + MULT16_32_Q15(*wp2, *xp2);
   2b8e6:	1a82      	subs	r2, r0, r2
      for(;i<N4;i++)
   2b8e8:	4563      	cmp	r3, ip
         *yp++ =  -MULT16_32_Q15(*wp1, xp1[-N2]) + MULT16_32_Q15(*wp2, *xp2);
   2b8ea:	f848 2c08 	str.w	r2, [r8, #-8]
   2b8ee:	f1ae 0e04 	sub.w	lr, lr, #4
   2b8f2:	f108 0808 	add.w	r8, r8, #8
      for(;i<N4;i++)
   2b8f6:	d1bd      	bne.n	2b874 <clt_mdct_forward_c+0x20c>
   2b8f8:	f103 4200 	add.w	r2, r3, #2147483648	; 0x80000000
   2b8fc:	6a39      	ldr	r1, [r7, #32]
   2b8fe:	6a78      	ldr	r0, [r7, #36]	; 0x24
   2b900:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2b902:	f8d7 c010 	ldr.w	ip, [r7, #16]
   2b906:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   2b908:	3a01      	subs	r2, #1
   2b90a:	eb01 0242 	add.w	r2, r1, r2, lsl #1
   2b90e:	f100 0e08 	add.w	lr, r0, #8
         yi = S_MUL(im,t0)  +  S_MUL(re,t1);
         yc.r = yr;
         yc.i = yi;
         yc.r = PSHR32(MULT16_32_Q16(scale, yc.r), scale_shift);
         yc.i = PSHR32(MULT16_32_Q16(scale, yc.i), scale_shift);
         f2[st->bitrev[i]] = yc;
   2b912:	4693      	mov	fp, r2
   2b914:	637a      	str	r2, [r7, #52]	; 0x34
         yc.r = PSHR32(MULT16_32_Q16(scale, yc.r), scale_shift);
   2b916:	6c38      	ldr	r0, [r7, #64]	; 0x40
   2b918:	69ba      	ldr	r2, [r7, #24]
   2b91a:	f8c7 b048 	str.w	fp, [r7, #72]	; 0x48
   2b91e:	f04f 0901 	mov.w	r9, #1
   2b922:	3902      	subs	r1, #2
   2b924:	fa09 f900 	lsl.w	r9, r9, r0
   2b928:	4472      	add	r2, lr
   2b92a:	63b9      	str	r1, [r7, #56]	; 0x38
   2b92c:	ea4f 0969 	mov.w	r9, r9, asr #1
   2b930:	63fa      	str	r2, [r7, #60]	; 0x3c
         f2[st->bitrev[i]] = yc;
   2b932:	64f9      	str	r1, [r7, #76]	; 0x4c
   2b934:	f1a3 0a02 	sub.w	sl, r3, #2
         yr = S_MUL(re,t0)  -  S_MUL(im,t1);
   2b938:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
         f2[st->bitrev[i]] = yc;
   2b93a:	f93a 8f02 	ldrsh.w	r8, [sl, #2]!
         yr = S_MUL(re,t0)  -  S_MUL(im,t1);
   2b93e:	f931 6f02 	ldrsh.w	r6, [r1, #2]!
   2b942:	64f9      	str	r1, [r7, #76]	; 0x4c
         im = *yp++;
   2b944:	e95e 2302 	ldrd	r2, r3, [lr, #-8]
         yr = S_MUL(re,t0)  -  S_MUL(im,t1);
   2b948:	6cb9      	ldr	r1, [r7, #72]	; 0x48
   2b94a:	b294      	uxth	r4, r2
   2b94c:	f931 0f02 	ldrsh.w	r0, [r1, #2]!
   2b950:	64b9      	str	r1, [r7, #72]	; 0x48
   2b952:	fb04 f506 	mul.w	r5, r4, r6
   2b956:	1412      	asrs	r2, r2, #16
   2b958:	fb02 fb06 	mul.w	fp, r2, r6
   2b95c:	b299      	uxth	r1, r3
   2b95e:	13ed      	asrs	r5, r5, #15
         yi = S_MUL(im,t0)  +  S_MUL(re,t1);
   2b960:	fb04 f400 	mul.w	r4, r4, r0
         yr = S_MUL(re,t0)  -  S_MUL(im,t1);
   2b964:	141b      	asrs	r3, r3, #16
   2b966:	eb05 054b 	add.w	r5, r5, fp, lsl #1
   2b96a:	fb01 fb00 	mul.w	fp, r1, r0
         yi = S_MUL(im,t0)  +  S_MUL(re,t1);
   2b96e:	fb01 f106 	mul.w	r1, r1, r6
   2b972:	13e4      	asrs	r4, r4, #15
   2b974:	fb00 f202 	mul.w	r2, r0, r2
         yr = S_MUL(re,t0)  -  S_MUL(im,t1);
   2b978:	ea4f 3beb 	mov.w	fp, fp, asr #15
   2b97c:	fb03 f000 	mul.w	r0, r3, r0
         yi = S_MUL(im,t0)  +  S_MUL(re,t1);
   2b980:	13c9      	asrs	r1, r1, #15
   2b982:	fb03 f306 	mul.w	r3, r3, r6
   2b986:	eb01 0143 	add.w	r1, r1, r3, lsl #1
   2b98a:	eb04 0242 	add.w	r2, r4, r2, lsl #1
         yr = S_MUL(re,t0)  -  S_MUL(im,t1);
   2b98e:	eb0b 0b40 	add.w	fp, fp, r0, lsl #1
         yi = S_MUL(im,t0)  +  S_MUL(re,t1);
   2b992:	440a      	add	r2, r1
         yr = S_MUL(re,t0)  -  S_MUL(im,t1);
   2b994:	eba5 0b0b 	sub.w	fp, r5, fp
         yc.r = PSHR32(MULT16_32_Q16(scale, yc.r), scale_shift);
   2b998:	fa1f f08b 	uxth.w	r0, fp
         yc.i = PSHR32(MULT16_32_Q16(scale, yc.i), scale_shift);
   2b99c:	b296      	uxth	r6, r2
         yc.r = PSHR32(MULT16_32_Q16(scale, yc.r), scale_shift);
   2b99e:	ea4f 4b2b 	mov.w	fp, fp, asr #16
         yc.i = PSHR32(MULT16_32_Q16(scale, yc.i), scale_shift);
   2b9a2:	1412      	asrs	r2, r2, #16
         yc.r = PSHR32(MULT16_32_Q16(scale, yc.r), scale_shift);
   2b9a4:	fb0c f000 	mul.w	r0, ip, r0
         f2[st->bitrev[i]] = yc;
   2b9a8:	6c79      	ldr	r1, [r7, #68]	; 0x44
         yc.r = PSHR32(MULT16_32_Q16(scale, yc.r), scale_shift);
   2b9aa:	6c3c      	ldr	r4, [r7, #64]	; 0x40
   2b9ac:	fb0c fb0b 	mul.w	fp, ip, fp
         yc.i = PSHR32(MULT16_32_Q16(scale, yc.i), scale_shift);
   2b9b0:	fb0c f606 	mul.w	r6, ip, r6
   2b9b4:	fb0c f202 	mul.w	r2, ip, r2
         yc.r = PSHR32(MULT16_32_Q16(scale, yc.r), scale_shift);
   2b9b8:	eb0b 4b20 	add.w	fp, fp, r0, asr #16
         yc.i = PSHR32(MULT16_32_Q16(scale, yc.i), scale_shift);
   2b9bc:	eb02 4226 	add.w	r2, r2, r6, asr #16
         f2[st->bitrev[i]] = yc;
   2b9c0:	eb01 03c8 	add.w	r3, r1, r8, lsl #3
         yc.r = PSHR32(MULT16_32_Q16(scale, yc.r), scale_shift);
   2b9c4:	44cb      	add	fp, r9
         yc.i = PSHR32(MULT16_32_Q16(scale, yc.i), scale_shift);
   2b9c6:	444a      	add	r2, r9
         yc.r = PSHR32(MULT16_32_Q16(scale, yc.r), scale_shift);
   2b9c8:	fa4b f004 	asr.w	r0, fp, r4
         yc.i = PSHR32(MULT16_32_Q16(scale, yc.i), scale_shift);
   2b9cc:	4122      	asrs	r2, r4
         f2[st->bitrev[i]] = yc;
   2b9ce:	f841 0038 	str.w	r0, [r1, r8, lsl #3]
   2b9d2:	605a      	str	r2, [r3, #4]
      for(i=0;i<N4;i++)
   2b9d4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   2b9d6:	f10e 0e08 	add.w	lr, lr, #8
   2b9da:	4573      	cmp	r3, lr
   2b9dc:	d1ac      	bne.n	2b938 <clt_mdct_forward_c+0x2d0>
      }
   }

   /* N/4 complex FFT, does not downscale anymore */
   opus_fft_impl(st, f2);
   2b9de:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   2b9e0:	460c      	mov	r4, r1
   2b9e2:	f7fe fcb9 	bl	2a358 <opus_fft_impl>
   /* Post-rotate */
   {
      /* Temp pointers to make it really clear to the compiler what we're doing */
      const kiss_fft_cpx * OPUS_RESTRICT fp = f2;
      kiss_fft_scalar * OPUS_RESTRICT yp1 = out;
      kiss_fft_scalar * OPUS_RESTRICT yp2 = out+stride*(N2-1);
   2b9e6:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   2b9ea:	697a      	ldr	r2, [r7, #20]
         yr = S_MUL(fp->i,t[N4+i]) - S_MUL(fp->r,t[i]);
         yi = S_MUL(fp->r,t[N4+i]) + S_MUL(fp->i,t[i]);
         *yp1 = yr;
         *yp2 = yi;
         fp++;
         yp1 += 2*stride;
   2b9ec:	ea4f 09c3 	mov.w	r9, r3, lsl #3
      kiss_fft_scalar * OPUS_RESTRICT yp2 = out+stride*(N2-1);
   2b9f0:	fb03 f802 	mul.w	r8, r3, r2
         yp2 -= 2*stride;
   2b9f4:	f1c9 0a00 	rsb	sl, r9, #0
   2b9f8:	69ba      	ldr	r2, [r7, #24]
      kiss_fft_scalar * OPUS_RESTRICT yp2 = out+stride*(N2-1);
   2b9fa:	68bb      	ldr	r3, [r7, #8]
   2b9fc:	e9c7 a912 	strd	sl, r9, [r7, #72]	; 0x48
   2ba00:	f104 0e08 	add.w	lr, r4, #8
   2ba04:	e9d7 ba0d 	ldrd	fp, sl, [r7, #52]	; 0x34
   2ba08:	4472      	add	r2, lr
   2ba0a:	eb03 0888 	add.w	r8, r3, r8, lsl #2
   2ba0e:	647a      	str	r2, [r7, #68]	; 0x44
   2ba10:	4699      	mov	r9, r3
         yr = S_MUL(fp->i,t[N4+i]) - S_MUL(fp->r,t[i]);
   2ba12:	e95e 4502 	ldrd	r4, r5, [lr, #-8]
   2ba16:	f93b 6f02 	ldrsh.w	r6, [fp, #2]!
   2ba1a:	f93a 1f02 	ldrsh.w	r1, [sl, #2]!
   2ba1e:	b2aa      	uxth	r2, r5
   2ba20:	fb02 f006 	mul.w	r0, r2, r6
   2ba24:	142d      	asrs	r5, r5, #16
   2ba26:	b2a3      	uxth	r3, r4
   2ba28:	fb05 fc06 	mul.w	ip, r5, r6
   2ba2c:	13c0      	asrs	r0, r0, #15
   2ba2e:	1424      	asrs	r4, r4, #16
   2ba30:	eb00 004c 	add.w	r0, r0, ip, lsl #1
   2ba34:	fb03 fc01 	mul.w	ip, r3, r1
         yi = S_MUL(fp->r,t[N4+i]) + S_MUL(fp->i,t[i]);
   2ba38:	fb03 f306 	mul.w	r3, r3, r6
   2ba3c:	fb02 f201 	mul.w	r2, r2, r1
   2ba40:	fb01 f505 	mul.w	r5, r1, r5
   2ba44:	13db      	asrs	r3, r3, #15
         yr = S_MUL(fp->i,t[N4+i]) - S_MUL(fp->r,t[i]);
   2ba46:	fb04 f101 	mul.w	r1, r4, r1
   2ba4a:	ea4f 3cec 	mov.w	ip, ip, asr #15
         yi = S_MUL(fp->r,t[N4+i]) + S_MUL(fp->i,t[i]);
   2ba4e:	fb04 f406 	mul.w	r4, r4, r6
   2ba52:	eb03 0444 	add.w	r4, r3, r4, lsl #1
         yr = S_MUL(fp->i,t[N4+i]) - S_MUL(fp->r,t[i]);
   2ba56:	eb0c 0141 	add.w	r1, ip, r1, lsl #1
         yp1 += 2*stride;
   2ba5a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
         yi = S_MUL(fp->r,t[N4+i]) + S_MUL(fp->i,t[i]);
   2ba5c:	13d2      	asrs	r2, r2, #15
         yr = S_MUL(fp->i,t[N4+i]) - S_MUL(fp->r,t[i]);
   2ba5e:	1a41      	subs	r1, r0, r1
         *yp1 = yr;
   2ba60:	f8c9 1000 	str.w	r1, [r9]
         yi = S_MUL(fp->r,t[N4+i]) + S_MUL(fp->i,t[i]);
   2ba64:	eb02 0245 	add.w	r2, r2, r5, lsl #1
         yp1 += 2*stride;
   2ba68:	4499      	add	r9, r3
         yp2 -= 2*stride;
   2ba6a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
         yi = S_MUL(fp->r,t[N4+i]) + S_MUL(fp->i,t[i]);
   2ba6c:	4422      	add	r2, r4
         *yp2 = yi;
   2ba6e:	f8c8 2000 	str.w	r2, [r8]
         yp2 -= 2*stride;
   2ba72:	4498      	add	r8, r3
      for(i=0;i<N4;i++)
   2ba74:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   2ba76:	f10e 0e08 	add.w	lr, lr, #8
   2ba7a:	4573      	cmp	r3, lr
   2ba7c:	d1c9      	bne.n	2ba12 <clt_mdct_forward_c+0x3aa>
      }
   }
   RESTORE_STACK;
}
   2ba7e:	3754      	adds	r7, #84	; 0x54
   2ba80:	46bd      	mov	sp, r7
   2ba82:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2ba86:	46f0      	mov	r8, lr
      for(i=0;i<((overlap+3)>>2);i++)
   2ba88:	f04f 0c00 	mov.w	ip, #0
   2ba8c:	4621      	mov	r1, r4
   2ba8e:	e6a6      	b.n	2b7de <clt_mdct_forward_c+0x176>
      for(i=0;i<N4;i++)
   2ba90:	2b00      	cmp	r3, #0
   2ba92:	f73f af31 	bgt.w	2b8f8 <clt_mdct_forward_c+0x290>
   opus_fft_impl(st, f2);
   2ba96:	6c79      	ldr	r1, [r7, #68]	; 0x44
   2ba98:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   2ba9a:	f7fe fc5d 	bl	2a358 <opus_fft_impl>
}
   2ba9e:	3754      	adds	r7, #84	; 0x54
   2baa0:	46bd      	mov	sp, r7
   2baa2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2baa6:	bf00      	nop

0002baa8 <opus_custom_mode_create>:
   for (i=0;i<TOTAL_MODES;i++)
   {
      int j;
      for (j=0;j<4;j++)
      {
         if (Fs == static_mode_list[i]->Fs &&
   2baa8:	f64b 3380 	movw	r3, #48000	; 0xbb80
   2baac:	4298      	cmp	r0, r3
   2baae:	d005      	beq.n	2babc <opus_custom_mode_create+0x14>
      }
   }
#endif /* CUSTOM_MODES_ONLY */

#ifndef CUSTOM_MODES
   if (error)
   2bab0:	b112      	cbz	r2, 2bab8 <opus_custom_mode_create+0x10>
      *error = OPUS_BAD_ARG;
   2bab2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2bab6:	6013      	str	r3, [r2, #0]
   return NULL;
   2bab8:	2000      	movs	r0, #0
   2baba:	4770      	bx	lr
         if (Fs == static_mode_list[i]->Fs &&
   2babc:	f5b1 7f70 	cmp.w	r1, #960	; 0x3c0
   2bac0:	d00b      	beq.n	2bada <opus_custom_mode_create+0x32>
               (frame_size<<j) == static_mode_list[i]->shortMdctSize*static_mode_list[i]->nbShortMdcts)
   2bac2:	004b      	lsls	r3, r1, #1
         if (Fs == static_mode_list[i]->Fs &&
   2bac4:	f5b3 7f70 	cmp.w	r3, #960	; 0x3c0
   2bac8:	d007      	beq.n	2bada <opus_custom_mode_create+0x32>
               (frame_size<<j) == static_mode_list[i]->shortMdctSize*static_mode_list[i]->nbShortMdcts)
   2baca:	008b      	lsls	r3, r1, #2
         if (Fs == static_mode_list[i]->Fs &&
   2bacc:	f5b3 7f70 	cmp.w	r3, #960	; 0x3c0
   2bad0:	d003      	beq.n	2bada <opus_custom_mode_create+0x32>
               (frame_size<<j) == static_mode_list[i]->shortMdctSize*static_mode_list[i]->nbShortMdcts)
   2bad2:	00c9      	lsls	r1, r1, #3
         if (Fs == static_mode_list[i]->Fs &&
   2bad4:	f5b1 7f70 	cmp.w	r1, #960	; 0x3c0
   2bad8:	d1ea      	bne.n	2bab0 <opus_custom_mode_create+0x8>
            if (error)
   2bada:	b11a      	cbz	r2, 2bae4 <opus_custom_mode_create+0x3c>
               *error = OPUS_OK;
   2badc:	2300      	movs	r3, #0
   2bade:	6013      	str	r3, [r2, #0]
            return (CELTMode*)static_mode_list[i];
   2bae0:	4801      	ldr	r0, [pc, #4]	; (2bae8 <opus_custom_mode_create+0x40>)
   2bae2:	4770      	bx	lr
   2bae4:	4800      	ldr	r0, [pc, #0]	; (2bae8 <opus_custom_mode_create+0x40>)
   2bae6:	4770      	bx	lr
   2bae8:	0003b288 	.word	0x0003b288

0002baec <find_best_pitch>:
                            int max_pitch, int *best_pitch
#ifdef FIXED_POINT
                            , int yshift, opus_val32 maxcorr
#endif
                            )
{
   2baec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2baf0:	b08b      	sub	sp, #44	; 0x2c
   2baf2:	e9dd 8515 	ldrd	r8, r5, [sp, #84]	; 0x54
   2baf6:	fab5 f585 	clz	r5, r5
   opus_val16 best_num[2];
   opus_val32 best_den[2];
#ifdef FIXED_POINT
   int xshift;

   xshift = celt_ilog2(maxcorr)-14;
   2bafa:	f1c5 051f 	rsb	r5, r5, #31
   2bafe:	f1a5 070e 	sub.w	r7, r5, #14
   2bb02:	9706      	str	r7, [sp, #24]

   best_num[0] = -1;
   best_num[1] = -1;
   best_den[0] = 0;
   best_den[1] = 0;
   best_pitch[0] = 0;
   2bb04:	9f14      	ldr	r7, [sp, #80]	; 0x50
   2bb06:	2600      	movs	r6, #0
   best_pitch[1] = 1;
   2bb08:	2401      	movs	r4, #1
   for (j=0;j<len;j++)
   2bb0a:	2a00      	cmp	r2, #0
   best_pitch[1] = 1;
   2bb0c:	e9c7 6400 	strd	r6, r4, [r7]
   for (j=0;j<len;j++)
   2bb10:	dd0b      	ble.n	2bb2a <find_best_pitch+0x3e>
   2bb12:	1e8f      	subs	r7, r1, #2
   2bb14:	eb07 0c42 	add.w	ip, r7, r2, lsl #1
      Syy = ADD32(Syy, SHR32(MULT16_16(y[j],y[j]), yshift));
   2bb18:	f937 6f02 	ldrsh.w	r6, [r7, #2]!
   2bb1c:	fb06 f606 	mul.w	r6, r6, r6
   2bb20:	fa46 f608 	asr.w	r6, r6, r8
   for (j=0;j<len;j++)
   2bb24:	45bc      	cmp	ip, r7
      Syy = ADD32(Syy, SHR32(MULT16_16(y[j],y[j]), yshift));
   2bb26:	4434      	add	r4, r6
   for (j=0;j<len;j++)
   2bb28:	d1f6      	bne.n	2bb18 <find_best_pitch+0x2c>
   for (i=0;i<max_pitch;i++)
   2bb2a:	2b00      	cmp	r3, #0
   2bb2c:	f340 8086 	ble.w	2bc3c <find_best_pitch+0x150>
   2bb30:	f102 4a00 	add.w	sl, r2, #2147483648	; 0x80000000
   2bb34:	3804      	subs	r0, #4
   2bb36:	eb00 0383 	add.w	r3, r0, r3, lsl #2
   2bb3a:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
   best_den[1] = 0;
   2bb3e:	2200      	movs	r2, #0
   best_num[1] = -1;
   2bb40:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   2bb44:	eb01 0a4a 	add.w	sl, r1, sl, lsl #1
   2bb48:	9307      	str	r3, [sp, #28]
   2bb4a:	1e8b      	subs	r3, r1, #2
   {
      if (xcorr[i]>0)
      {
         opus_val16 num;
         opus_val32 xcorr16;
         xcorr16 = EXTRACT16(VSHR32(xcorr[i], xshift));
   2bb4c:	f1c5 010e 	rsb	r1, r5, #14
   best_den[1] = 0;
   2bb50:	9208      	str	r2, [sp, #32]
   best_num[1] = -1;
   2bb52:	9602      	str	r6, [sp, #8]
         xcorr16 = EXTRACT16(VSHR32(xcorr[i], xshift));
   2bb54:	9109      	str	r1, [sp, #36]	; 0x24
   best_den[0] = 0;
   2bb56:	9203      	str	r2, [sp, #12]
   for (i=0;i<max_pitch;i++)
   2bb58:	4693      	mov	fp, r2
   best_num[0] = -1;
   2bb5a:	9604      	str	r6, [sp, #16]
   2bb5c:	4699      	mov	r9, r3
   2bb5e:	9001      	str	r0, [sp, #4]
   2bb60:	e021      	b.n	2bba6 <find_best_pitch+0xba>
         {
            if (MULT16_32_Q15(num,best_den[0]) > MULT16_32_Q15(best_num[0],Syy))
            {
               best_num[1] = best_num[0];
               best_den[1] = best_den[0];
               best_pitch[1] = best_pitch[0];
   2bb62:	9914      	ldr	r1, [sp, #80]	; 0x50
   2bb64:	9804      	ldr	r0, [sp, #16]
   2bb66:	680a      	ldr	r2, [r1, #0]
   2bb68:	604a      	str	r2, [r1, #4]
   2bb6a:	9a03      	ldr	r2, [sp, #12]
   2bb6c:	9208      	str	r2, [sp, #32]
   2bb6e:	e9cd 4303 	strd	r4, r3, [sp, #12]
   2bb72:	9002      	str	r0, [sp, #8]
               best_num[0] = num;
               best_den[0] = Syy;
               best_pitch[0] = i;
   2bb74:	f8c1 b000 	str.w	fp, [r1]
               best_den[1] = Syy;
               best_pitch[1] = i;
            }
         }
      }
      Syy += SHR32(MULT16_16(y[i+len],y[i+len]),yshift) - SHR32(MULT16_16(y[i],y[i]),yshift);
   2bb78:	f93a 3f02 	ldrsh.w	r3, [sl, #2]!
   2bb7c:	f939 2f02 	ldrsh.w	r2, [r9, #2]!
   2bb80:	fb03 f303 	mul.w	r3, r3, r3
   2bb84:	fb02 f202 	mul.w	r2, r2, r2
   2bb88:	fa43 f308 	asr.w	r3, r3, r8
   2bb8c:	fa42 f208 	asr.w	r2, r2, r8
   2bb90:	1a9a      	subs	r2, r3, r2
   2bb92:	4414      	add	r4, r2
   for (i=0;i<max_pitch;i++)
   2bb94:	9b07      	ldr	r3, [sp, #28]
   2bb96:	9a01      	ldr	r2, [sp, #4]
      Syy = MAX32(1, Syy);
   2bb98:	2c01      	cmp	r4, #1
   2bb9a:	bfb8      	it	lt
   2bb9c:	2401      	movlt	r4, #1
   for (i=0;i<max_pitch;i++)
   2bb9e:	4293      	cmp	r3, r2
   2bba0:	f10b 0b01 	add.w	fp, fp, #1
   2bba4:	d04a      	beq.n	2bc3c <find_best_pitch+0x150>
      if (xcorr[i]>0)
   2bba6:	9b01      	ldr	r3, [sp, #4]
         xcorr16 = EXTRACT16(VSHR32(xcorr[i], xshift));
   2bba8:	9906      	ldr	r1, [sp, #24]
      if (xcorr[i]>0)
   2bbaa:	f853 2f04 	ldr.w	r2, [r3, #4]!
   2bbae:	9301      	str	r3, [sp, #4]
   2bbb0:	2a00      	cmp	r2, #0
         xcorr16 = EXTRACT16(VSHR32(xcorr[i], xshift));
   2bbb2:	fa42 f301 	asr.w	r3, r2, r1
      if (xcorr[i]>0)
   2bbb6:	dddf      	ble.n	2bb78 <find_best_pitch+0x8c>
         xcorr16 = EXTRACT16(VSHR32(xcorr[i], xshift));
   2bbb8:	2900      	cmp	r1, #0
   2bbba:	bfd8      	it	le
   2bbbc:	9b09      	ldrle	r3, [sp, #36]	; 0x24
         if (MULT16_32_Q15(num,best_den[1]) > MULT16_32_Q15(best_num[1],Syy))
   2bbbe:	9802      	ldr	r0, [sp, #8]
   2bbc0:	9e08      	ldr	r6, [sp, #32]
            if (MULT16_32_Q15(num,best_den[0]) > MULT16_32_Q15(best_num[0],Syy))
   2bbc2:	f8dd c00c 	ldr.w	ip, [sp, #12]
         xcorr16 = EXTRACT16(VSHR32(xcorr[i], xshift));
   2bbc6:	bfd8      	it	le
   2bbc8:	fa02 f303 	lslle.w	r3, r2, r3
   2bbcc:	b2a2      	uxth	r2, r4
         if (MULT16_32_Q15(num,best_den[1]) > MULT16_32_Q15(best_num[1],Syy))
   2bbce:	fb02 f700 	mul.w	r7, r2, r0
            if (MULT16_32_Q15(num,best_den[0]) > MULT16_32_Q15(best_num[0],Syy))
   2bbd2:	9804      	ldr	r0, [sp, #16]
         if (MULT16_32_Q15(num,best_den[1]) > MULT16_32_Q15(best_num[1],Syy))
   2bbd4:	b2b1      	uxth	r1, r6
   2bbd6:	ea4f 4e26 	mov.w	lr, r6, asr #16
         xcorr16 = EXTRACT16(VSHR32(xcorr[i], xshift));
   2bbda:	b21b      	sxth	r3, r3
         if (MULT16_32_Q15(num,best_den[1]) > MULT16_32_Q15(best_num[1],Syy))
   2bbdc:	1426      	asrs	r6, r4, #16
            if (MULT16_32_Q15(num,best_den[0]) > MULT16_32_Q15(best_num[0],Syy))
   2bbde:	fb02 f200 	mul.w	r2, r2, r0
         num = MULT16_16_Q15(xcorr16,xcorr16);
   2bbe2:	fb03 f303 	mul.w	r3, r3, r3
            if (MULT16_32_Q15(num,best_den[0]) > MULT16_32_Q15(best_num[0],Syy))
   2bbe6:	fb00 f006 	mul.w	r0, r0, r6
         num = MULT16_16_Q15(xcorr16,xcorr16);
   2bbea:	f343 33cf 	sbfx	r3, r3, #15, #16
            if (MULT16_32_Q15(num,best_den[0]) > MULT16_32_Q15(best_num[0],Syy))
   2bbee:	9005      	str	r0, [sp, #20]
         if (MULT16_32_Q15(num,best_den[1]) > MULT16_32_Q15(best_num[1],Syy))
   2bbf0:	9802      	ldr	r0, [sp, #8]
   2bbf2:	fb03 f101 	mul.w	r1, r3, r1
            if (MULT16_32_Q15(num,best_den[0]) > MULT16_32_Q15(best_num[0],Syy))
   2bbf6:	fa1f f58c 	uxth.w	r5, ip
         if (MULT16_32_Q15(num,best_den[1]) > MULT16_32_Q15(best_num[1],Syy))
   2bbfa:	13ff      	asrs	r7, r7, #15
   2bbfc:	13c9      	asrs	r1, r1, #15
   2bbfe:	fb03 fe0e 	mul.w	lr, r3, lr
   2bc02:	fb06 f600 	mul.w	r6, r6, r0
   2bc06:	eb07 0646 	add.w	r6, r7, r6, lsl #1
            if (MULT16_32_Q15(num,best_den[0]) > MULT16_32_Q15(best_num[0],Syy))
   2bc0a:	ea4f 4c2c 	mov.w	ip, ip, asr #16
   2bc0e:	fb03 f505 	mul.w	r5, r3, r5
         if (MULT16_32_Q15(num,best_den[1]) > MULT16_32_Q15(best_num[1],Syy))
   2bc12:	eb01 014e 	add.w	r1, r1, lr, lsl #1
            if (MULT16_32_Q15(num,best_den[0]) > MULT16_32_Q15(best_num[0],Syy))
   2bc16:	9f05      	ldr	r7, [sp, #20]
   2bc18:	fb03 fc0c 	mul.w	ip, r3, ip
   2bc1c:	13ed      	asrs	r5, r5, #15
   2bc1e:	13d2      	asrs	r2, r2, #15
         if (MULT16_32_Q15(num,best_den[1]) > MULT16_32_Q15(best_num[1],Syy))
   2bc20:	42b1      	cmp	r1, r6
            if (MULT16_32_Q15(num,best_den[0]) > MULT16_32_Q15(best_num[0],Syy))
   2bc22:	eb05 054c 	add.w	r5, r5, ip, lsl #1
   2bc26:	eb02 0247 	add.w	r2, r2, r7, lsl #1
         if (MULT16_32_Q15(num,best_den[1]) > MULT16_32_Q15(best_num[1],Syy))
   2bc2a:	dda5      	ble.n	2bb78 <find_best_pitch+0x8c>
            if (MULT16_32_Q15(num,best_den[0]) > MULT16_32_Q15(best_num[0],Syy))
   2bc2c:	4295      	cmp	r5, r2
   2bc2e:	dc98      	bgt.n	2bb62 <find_best_pitch+0x76>
               best_pitch[1] = i;
   2bc30:	9a14      	ldr	r2, [sp, #80]	; 0x50
               best_num[1] = num;
   2bc32:	9302      	str	r3, [sp, #8]
               best_pitch[1] = i;
   2bc34:	f8c2 b004 	str.w	fp, [r2, #4]
   2bc38:	9408      	str	r4, [sp, #32]
   2bc3a:	e79d      	b.n	2bb78 <find_best_pitch+0x8c>
   }
}
   2bc3c:	b00b      	add	sp, #44	; 0x2c
   2bc3e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2bc42:	bf00      	nop

0002bc44 <compute_pitch_gain.part.1>:

   RESTORE_STACK;
}

#ifdef FIXED_POINT
static opus_val16 compute_pitch_gain(opus_val32 xy, opus_val32 xx, opus_val32 yy)
   2bc44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2bc46:	fab1 f781 	clz	r7, r1
   int sx, sy, shift;
   opus_val32 g;
   opus_val16 den;
   if (xy == 0 || xx == 0 || yy == 0)
      return 0;
   sx = celt_ilog2(xx)-14;
   2bc4a:	f1c7 071f 	rsb	r7, r7, #31
   2bc4e:	f1a7 0c0e 	sub.w	ip, r7, #14
   2bc52:	fab2 f682 	clz	r6, r2
   sy = celt_ilog2(yy)-14;
   shift = sx + sy;
   x2y2 = SHR32(MULT16_16(VSHR32(xx, sx), VSHR32(yy, sy)), 14);
   2bc56:	f1bc 0f00 	cmp.w	ip, #0
   sy = celt_ilog2(yy)-14;
   2bc5a:	f1c6 061f 	rsb	r6, r6, #31
   2bc5e:	f1a6 030e 	sub.w	r3, r6, #14
   x2y2 = SHR32(MULT16_16(VSHR32(xx, sx), VSHR32(yy, sy)), 14);
   2bc62:	bfd6      	itet	le
   2bc64:	f1c7 070e 	rsble	r7, r7, #14
   2bc68:	fa41 f10c 	asrgt.w	r1, r1, ip
   2bc6c:	40b9      	lslle	r1, r7
   2bc6e:	2b00      	cmp	r3, #0
   2bc70:	bfd8      	it	le
   2bc72:	f1c6 060e 	rsble	r6, r6, #14
   shift = sx + sy;
   2bc76:	eb0c 0403 	add.w	r4, ip, r3
   x2y2 = SHR32(MULT16_16(VSHR32(xx, sx), VSHR32(yy, sy)), 14);
   2bc7a:	bfcc      	ite	gt
   2bc7c:	fa42 f303 	asrgt.w	r3, r2, r3
   2bc80:	fa02 f306 	lslle.w	r3, r2, r6
   2bc84:	b209      	sxth	r1, r1
   2bc86:	b21b      	sxth	r3, r3
   2bc88:	fb03 f301 	mul.w	r3, r3, r1
   if (shift & 1) {
   2bc8c:	07e2      	lsls	r2, r4, #31
static opus_val16 compute_pitch_gain(opus_val32 xy, opus_val32 xx, opus_val32 yy)
   2bc8e:	4605      	mov	r5, r0
   x2y2 = SHR32(MULT16_16(VSHR32(xx, sx), VSHR32(yy, sy)), 14);
   2bc90:	ea4f 30a3 	mov.w	r0, r3, asr #14
   if (shift & 1) {
   2bc94:	d507      	bpl.n	2bca6 <compute_pitch_gain.part.1+0x62>
      if (x2y2 < 32768)
   2bc96:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
      {
         x2y2 <<= 1;
   2bc9a:	bfb9      	ittee	lt
   2bc9c:	0040      	lsllt	r0, r0, #1
         shift--;
   2bc9e:	f104 34ff 	addlt.w	r4, r4, #4294967295	; 0xffffffff
      } else {
         x2y2 >>= 1;
   2bca2:	13d8      	asrge	r0, r3, #15
         shift++;
   2bca4:	3401      	addge	r4, #1
      }
   }
   den = celt_rsqrt_norm(x2y2);
   2bca6:	f7ff fbb5 	bl	2b414 <celt_rsqrt_norm>
   g = MULT16_32_Q15(den, xy);
   2bcaa:	b2ab      	uxth	r3, r5
   g = VSHR32(g, (shift>>1)-1);
   2bcac:	1064      	asrs	r4, r4, #1
   g = MULT16_32_Q15(den, xy);
   2bcae:	fb00 f303 	mul.w	r3, r0, r3
   2bcb2:	142d      	asrs	r5, r5, #16
   g = VSHR32(g, (shift>>1)-1);
   2bcb4:	2c01      	cmp	r4, #1
   g = MULT16_32_Q15(den, xy);
   2bcb6:	ea4f 33e3 	mov.w	r3, r3, asr #15
   2bcba:	fb00 f005 	mul.w	r0, r0, r5
   2bcbe:	eb03 0040 	add.w	r0, r3, r0, lsl #1
   g = VSHR32(g, (shift>>1)-1);
   2bcc2:	bfcb      	itete	gt
   2bcc4:	f104 34ff 	addgt.w	r4, r4, #4294967295	; 0xffffffff
   2bcc8:	f1c4 0401 	rsble	r4, r4, #1
   2bccc:	4120      	asrgt	r0, r4
   2bcce:	40a0      	lslle	r0, r4
   return EXTRACT16(MIN32(g, Q15ONE));
   2bcd0:	f647 73ff 	movw	r3, #32767	; 0x7fff
   2bcd4:	4298      	cmp	r0, r3
   2bcd6:	bfa8      	it	ge
   2bcd8:	4618      	movge	r0, r3
}
   2bcda:	b200      	sxth	r0, r0
   2bcdc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2bcde:	bf00      	nop

0002bce0 <pitch_downsample>:
{
   2bce0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   for (i=0;i<len;i++)
   2bce4:	f1b2 0800 	subs.w	r8, r2, #0
   2bce8:	b08d      	sub	sp, #52	; 0x34
   2bcea:	460d      	mov	r5, r1
   2bcec:	4699      	mov	r9, r3
   opus_val32 maxabs = celt_maxabs32(x[0], len);
   2bcee:	6807      	ldr	r7, [r0, #0]
   2bcf0:	f340 8144 	ble.w	2bf7c <pitch_downsample+0x29c>
   2bcf4:	ea4f 0288 	mov.w	r2, r8, lsl #2
   2bcf8:	3a04      	subs	r2, #4
   opus_val32 minval = 0;
   2bcfa:	f04f 0c00 	mov.w	ip, #0
   2bcfe:	18bc      	adds	r4, r7, r2
   opus_val32 maxval = 0;
   2bd00:	46e6      	mov	lr, ip
   2bd02:	1f3b      	subs	r3, r7, #4
      maxval = MAX32(maxval, x[i]);
   2bd04:	f853 1f04 	ldr.w	r1, [r3, #4]!
   2bd08:	458e      	cmp	lr, r1
   2bd0a:	bfb8      	it	lt
   2bd0c:	468e      	movlt	lr, r1
      minval = MIN32(minval, x[i]);
   2bd0e:	458c      	cmp	ip, r1
   2bd10:	bfa8      	it	ge
   2bd12:	468c      	movge	ip, r1
   for (i=0;i<len;i++)
   2bd14:	429c      	cmp	r4, r3
   2bd16:	d1f5      	bne.n	2bd04 <pitch_downsample+0x24>
   return MAX32(maxval, -minval);
   2bd18:	f1cc 0c00 	rsb	ip, ip, #0
   2bd1c:	45f4      	cmp	ip, lr
   2bd1e:	bfb8      	it	lt
   2bd20:	46f4      	movlt	ip, lr
   if (C==2)
   2bd22:	f1b9 0f02 	cmp.w	r9, #2
   2bd26:	f000 80de 	beq.w	2bee6 <pitch_downsample+0x206>
   if (maxabs<1)
   2bd2a:	f1bc 0f00 	cmp.w	ip, #0
   2bd2e:	f340 811b 	ble.w	2bf68 <pitch_downsample+0x288>
   return EC_ILOG(x)-1;
   2bd32:	fabc f18c 	clz	r1, ip
   2bd36:	f1c1 011f 	rsb	r1, r1, #31
   shift = celt_ilog2(maxabs)-10;
   2bd3a:	b289      	uxth	r1, r1
   2bd3c:	390a      	subs	r1, #10
   if (C==2)
   2bd3e:	f1b9 0f02 	cmp.w	r9, #2
   2bd42:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
   2bd46:	f000 80cc 	beq.w	2bee2 <pitch_downsample+0x202>
   2bd4a:	e9d7 3200 	ldrd	r3, r2, [r7]
   2bd4e:	eb03 0e62 	add.w	lr, r3, r2, asr #1
   2bd52:	ea4f 0e6e 	mov.w	lr, lr, asr #1
   for (i=1;i<len>>1;i++)
   2bd56:	ea4f 0468 	mov.w	r4, r8, asr #1
   2bd5a:	fa4e fe01 	asr.w	lr, lr, r1
   2bd5e:	2c01      	cmp	r4, #1
   2bd60:	fa0f fe8e 	sxth.w	lr, lr
   2bd64:	f340 8102 	ble.w	2bf6c <pitch_downsample+0x28c>
   2bd68:	eb07 0ac4 	add.w	sl, r7, r4, lsl #3
   2bd6c:	4693      	mov	fp, r2
   2bd6e:	f1aa 0a08 	sub.w	sl, sl, #8
   2bd72:	46a8      	mov	r8, r5
   2bd74:	46ac      	mov	ip, r5
      x_lp[i] = SHR32(HALF32(HALF32(x[0][(2*i-1)]+x[0][(2*i+1)])+x[0][2*i]), shift);
   2bd76:	68fb      	ldr	r3, [r7, #12]
   2bd78:	f857 2f08 	ldr.w	r2, [r7, #8]!
   2bd7c:	449b      	add	fp, r3
   2bd7e:	eb02 026b 	add.w	r2, r2, fp, asr #1
   2bd82:	1052      	asrs	r2, r2, #1
   2bd84:	410a      	asrs	r2, r1
   for (i=1;i<len>>1;i++)
   2bd86:	45ba      	cmp	sl, r7
   2bd88:	469b      	mov	fp, r3
      x_lp[i] = SHR32(HALF32(HALF32(x[0][(2*i-1)]+x[0][(2*i+1)])+x[0][2*i]), shift);
   2bd8a:	f82c 2f02 	strh.w	r2, [ip, #2]!
   for (i=1;i<len>>1;i++)
   2bd8e:	d1f2      	bne.n	2bd76 <pitch_downsample+0x96>
   if (C==2)
   2bd90:	f1b9 0f02 	cmp.w	r9, #2
   x_lp[0] = SHR32(HALF32(HALF32(x[0][1])+x[0][0]), shift);
   2bd94:	f8a5 e000 	strh.w	lr, [r5]
   if (C==2)
   2bd98:	f000 80c1 	beq.w	2bf1e <pitch_downsample+0x23e>
   _celt_autocorr(x_lp, ac, NULL, 0,
   2bd9c:	9a16      	ldr	r2, [sp, #88]	; 0x58
   2bd9e:	2704      	movs	r7, #4
   2bda0:	2300      	movs	r3, #0
   2bda2:	e9cd 4201 	strd	r4, r2, [sp, #4]
   2bda6:	a907      	add	r1, sp, #28
   2bda8:	461a      	mov	r2, r3
   2bdaa:	9700      	str	r7, [sp, #0]
   2bdac:	4628      	mov	r0, r5
   2bdae:	f000 fe3b 	bl	2ca28 <_celt_autocorr>
      ac[i] -= MULT16_32_Q15(2*i*i, ac[i]);
   2bdb2:	f8dd e028 	ldr.w	lr, [sp, #40]	; 0x28
   2bdb6:	980b      	ldr	r0, [sp, #44]	; 0x2c
   2bdb8:	e9dd c608 	ldrd	ip, r6, [sp, #32]
   2bdbc:	ea4f 432e 	mov.w	r3, lr, asr #16
   2bdc0:	fa1f f28e 	uxth.w	r2, lr
   2bdc4:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
   2bdc8:	eb02 02c2 	add.w	r2, r2, r2, lsl #3
   2bdcc:	009b      	lsls	r3, r3, #2
   2bdce:	f3cc 3881 	ubfx	r8, ip, #14, #2
   2bdd2:	eb03 3392 	add.w	r3, r3, r2, lsr #14
   _celt_lpc(lpc, ac, 4);
   2bdd6:	463a      	mov	r2, r7
      ac[i] -= MULT16_32_Q15(2*i*i, ac[i]);
   2bdd8:	ea4f 472c 	mov.w	r7, ip, asr #16
   2bddc:	eb08 0787 	add.w	r7, r8, r7, lsl #2
   2bde0:	ebae 0303 	sub.w	r3, lr, r3
   2bde4:	ebac 0707 	sub.w	r7, ip, r7
   2bde8:	f3c6 3e03 	ubfx	lr, r6, #12, #4
   2bdec:	ea4f 4c26 	mov.w	ip, r6, asr #16
   2bdf0:	eb0e 1e0c 	add.w	lr, lr, ip, lsl #4
   2bdf4:	eba6 0e0e 	sub.w	lr, r6, lr
   2bdf8:	ea4f 4820 	mov.w	r8, r0, asr #16
   ac[0] += SHR32(ac[0],13);
   2bdfc:	9e07      	ldr	r6, [sp, #28]
      ac[i] -= MULT16_32_Q15(2*i*i, ac[i]);
   2bdfe:	930a      	str	r3, [sp, #40]	; 0x28
   2be00:	f3c0 2c85 	ubfx	ip, r0, #10, #6
   2be04:	eb0c 1c88 	add.w	ip, ip, r8, lsl #6
   2be08:	eba0 030c 	sub.w	r3, r0, ip
   _celt_lpc(lpc, ac, 4);
   2be0c:	a907      	add	r1, sp, #28
   2be0e:	a805      	add	r0, sp, #20
   ac[0] += SHR32(ac[0],13);
   2be10:	eb06 3666 	add.w	r6, r6, r6, asr #13
      ac[i] -= MULT16_32_Q15(2*i*i, ac[i]);
   2be14:	e9cd 7e08 	strd	r7, lr, [sp, #32]
   2be18:	930b      	str	r3, [sp, #44]	; 0x2c
   ac[0] += SHR32(ac[0],13);
   2be1a:	9607      	str	r6, [sp, #28]
   _celt_lpc(lpc, ac, 4);
   2be1c:	f000 fd4e 	bl	2c8bc <_celt_lpc>
      lpc[i] = MULT16_16_Q15(lpc[i], tmp);
   2be20:	f8bd 7014 	ldrh.w	r7, [sp, #20]
   2be24:	f8bd c016 	ldrh.w	ip, [sp, #22]
   2be28:	f8bd e018 	ldrh.w	lr, [sp, #24]
   2be2c:	f8bd 301a 	ldrh.w	r3, [sp, #26]
   2be30:	f246 71ac 	movw	r1, #26540	; 0x67ac
   2be34:	f645 524d 	movw	r2, #23885	; 0x5d4d
   2be38:	f247 3032 	movw	r0, #29490	; 0x7332
   2be3c:	fb1c fc01 	smulbb	ip, ip, r1
   2be40:	fb1e fe02 	smulbb	lr, lr, r2
   2be44:	fb17 f700 	smulbb	r7, r7, r0
   2be48:	f245 32f8 	movw	r2, #21496	; 0x53f8
   lpc2[1] = lpc[1] + MULT16_16_Q15(c1,lpc[0]);
   2be4c:	f246 6966 	movw	r9, #26214	; 0x6666
      lpc[i] = MULT16_16_Q15(lpc[i], tmp);
   2be50:	13ff      	asrs	r7, r7, #15
   2be52:	ea4f 3cec 	mov.w	ip, ip, asr #15
   2be56:	ea4f 3eee 	mov.w	lr, lr, asr #15
   2be5a:	fb13 f302 	smulbb	r3, r3, r2
   lpc2[1] = lpc[1] + MULT16_16_Q15(c1,lpc[0]);
   2be5e:	fb09 f107 	mul.w	r1, r9, r7
   lpc2[2] = lpc[2] + MULT16_16_Q15(c1,lpc[1]);
   2be62:	fb09 f20c 	mul.w	r2, r9, ip
   lpc2[3] = lpc[3] + MULT16_16_Q15(c1,lpc[2]);
   2be66:	fb09 fa0e 	mul.w	sl, r9, lr
      lpc[i] = MULT16_16_Q15(lpc[i], tmp);
   2be6a:	13db      	asrs	r3, r3, #15
   lpc2[0] = lpc[0] + QCONST16(.8f,SIG_SHIFT);
   2be6c:	f607 47cd 	addw	r7, r7, #3277	; 0xccd
   lpc2[1] = lpc[1] + MULT16_16_Q15(c1,lpc[0]);
   2be70:	eb0c 3ce1 	add.w	ip, ip, r1, asr #15
   lpc2[2] = lpc[2] + MULT16_16_Q15(c1,lpc[1]);
   2be74:	eb0e 3ee2 	add.w	lr, lr, r2, asr #15
   lpc2[3] = lpc[3] + MULT16_16_Q15(c1,lpc[2]);
   2be78:	eb03 3aea 	add.w	sl, r3, sl, asr #15
   lpc2[4] = MULT16_16_Q15(c1,lpc[3]);
   2be7c:	fb09 f903 	mul.w	r9, r9, r3
   for (i=0;i<N;i++)
   2be80:	2c00      	cmp	r4, #0
   lpc2[0] = lpc[0] + QCONST16(.8f,SIG_SHIFT);
   2be82:	b23f      	sxth	r7, r7
   lpc2[1] = lpc[1] + MULT16_16_Q15(c1,lpc[0]);
   2be84:	fa0f fc8c 	sxth.w	ip, ip
   lpc2[2] = lpc[2] + MULT16_16_Q15(c1,lpc[1]);
   2be88:	fa0f fe8e 	sxth.w	lr, lr
   lpc2[3] = lpc[3] + MULT16_16_Q15(c1,lpc[2]);
   2be8c:	fa0f fa8a 	sxth.w	sl, sl
   lpc2[4] = MULT16_16_Q15(c1,lpc[3]);
   2be90:	ea4f 39e9 	mov.w	r9, r9, asr #15
   for (i=0;i<N;i++)
   2be94:	dd22      	ble.n	2bedc <pitch_downsample+0x1fc>
   mem4=0;
   2be96:	f04f 0b00 	mov.w	fp, #0
   2be9a:	1ea9      	subs	r1, r5, #2
   2be9c:	eb01 0844 	add.w	r8, r1, r4, lsl #1
   mem3=0;
   2bea0:	465a      	mov	r2, fp
   mem2=0;
   2bea2:	465e      	mov	r6, fp
   mem1=0;
   2bea4:	465d      	mov	r5, fp
   mem0=0;
   2bea6:	465c      	mov	r4, fp
   2bea8:	e003      	b.n	2beb2 <pitch_downsample+0x1d2>
   for (i=0;i<N;i++)
   2beaa:	4632      	mov	r2, r6
   2beac:	462e      	mov	r6, r5
   2beae:	4625      	mov	r5, r4
      mem0 = x[i];
   2beb0:	4604      	mov	r4, r0
      opus_val32 sum = SHL32(EXTEND32(x[i]), SIG_SHIFT);
   2beb2:	f931 0f02 	ldrsh.w	r0, [r1, #2]!
      sum = MAC16_16(sum,num0,mem0);
   2beb6:	fb07 f304 	mul.w	r3, r7, r4
   2beba:	eb03 3300 	add.w	r3, r3, r0, lsl #12
      sum = MAC16_16(sum,num1,mem1);
   2bebe:	fb0c 3305 	mla	r3, ip, r5, r3
      sum = MAC16_16(sum,num2,mem2);
   2bec2:	fb0e 3306 	mla	r3, lr, r6, r3
      sum = MAC16_16(sum,num3,mem3);
   2bec6:	fb0a 3302 	mla	r3, sl, r2, r3
      sum = MAC16_16(sum,num4,mem4);
   2beca:	fb0b 3309 	mla	r3, fp, r9, r3
      x[i] = ROUND16(sum, SIG_SHIFT);
   2bece:	f503 6300 	add.w	r3, r3, #2048	; 0x800
   2bed2:	131b      	asrs	r3, r3, #12
   for (i=0;i<N;i++)
   2bed4:	4588      	cmp	r8, r1
      x[i] = ROUND16(sum, SIG_SHIFT);
   2bed6:	800b      	strh	r3, [r1, #0]
   2bed8:	4693      	mov	fp, r2
   for (i=0;i<N;i++)
   2beda:	d1e6      	bne.n	2beaa <pitch_downsample+0x1ca>
}
   2bedc:	b00d      	add	sp, #52	; 0x34
   2bede:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2bee2:	3101      	adds	r1, #1
   2bee4:	e731      	b.n	2bd4a <pitch_downsample+0x6a>
      opus_val32 maxabs_1 = celt_maxabs32(x[1], len);
   2bee6:	6843      	ldr	r3, [r0, #4]
   opus_val32 minval = 0;
   2bee8:	2400      	movs	r4, #0
   2beea:	441a      	add	r2, r3
   opus_val32 maxval = 0;
   2beec:	46a6      	mov	lr, r4
   2beee:	3b04      	subs	r3, #4
      maxval = MAX32(maxval, x[i]);
   2bef0:	f853 1f04 	ldr.w	r1, [r3, #4]!
   2bef4:	458e      	cmp	lr, r1
   2bef6:	bfb8      	it	lt
   2bef8:	468e      	movlt	lr, r1
      minval = MIN32(minval, x[i]);
   2befa:	428c      	cmp	r4, r1
   2befc:	bfa8      	it	ge
   2befe:	460c      	movge	r4, r1
   for (i=0;i<len;i++)
   2bf00:	429a      	cmp	r2, r3
   2bf02:	d1f5      	bne.n	2bef0 <pitch_downsample+0x210>
   2bf04:	45f4      	cmp	ip, lr
   2bf06:	bfb8      	it	lt
   2bf08:	46f4      	movlt	ip, lr
   2bf0a:	4264      	negs	r4, r4
   2bf0c:	45a4      	cmp	ip, r4
   2bf0e:	bfb8      	it	lt
   2bf10:	46a4      	movlt	ip, r4
   if (maxabs<1)
   2bf12:	f1bc 0f00 	cmp.w	ip, #0
   2bf16:	f73f af0c 	bgt.w	2bd32 <pitch_downsample+0x52>
   2bf1a:	2101      	movs	r1, #1
   2bf1c:	e715      	b.n	2bd4a <pitch_downsample+0x6a>
         x_lp[i] += SHR32(HALF32(HALF32(x[1][(2*i-1)]+x[1][(2*i+1)])+x[1][2*i]), shift);
   2bf1e:	6847      	ldr	r7, [r0, #4]
   2bf20:	f1a5 0c02 	sub.w	ip, r5, #2
   2bf24:	687e      	ldr	r6, [r7, #4]
   2bf26:	463a      	mov	r2, r7
   2bf28:	eb0c 0c44 	add.w	ip, ip, r4, lsl #1
   2bf2c:	68d0      	ldr	r0, [r2, #12]
   2bf2e:	f852 3f08 	ldr.w	r3, [r2, #8]!
   2bf32:	f838 ef02 	ldrh.w	lr, [r8, #2]!
   2bf36:	eb00 0906 	add.w	r9, r0, r6
   2bf3a:	eb03 0369 	add.w	r3, r3, r9, asr #1
   2bf3e:	105b      	asrs	r3, r3, #1
   2bf40:	410b      	asrs	r3, r1
   2bf42:	4473      	add	r3, lr
      for (i=1;i<len>>1;i++)
   2bf44:	45c4      	cmp	ip, r8
   2bf46:	4606      	mov	r6, r0
         x_lp[i] += SHR32(HALF32(HALF32(x[1][(2*i-1)]+x[1][(2*i+1)])+x[1][2*i]), shift);
   2bf48:	f8a8 3000 	strh.w	r3, [r8]
      for (i=1;i<len>>1;i++)
   2bf4c:	d1ee      	bne.n	2bf2c <pitch_downsample+0x24c>
   2bf4e:	f9b5 e000 	ldrsh.w	lr, [r5]
      x_lp[0] += SHR32(HALF32(HALF32(x[1][1])+x[1][0]), shift);
   2bf52:	e9d7 3200 	ldrd	r3, r2, [r7]
   2bf56:	eb03 0362 	add.w	r3, r3, r2, asr #1
   2bf5a:	105b      	asrs	r3, r3, #1
   2bf5c:	fa43 f101 	asr.w	r1, r3, r1
   2bf60:	448e      	add	lr, r1
   2bf62:	f8a5 e000 	strh.w	lr, [r5]
   2bf66:	e719      	b.n	2bd9c <pitch_downsample+0xbc>
      shift=0;
   2bf68:	2100      	movs	r1, #0
   2bf6a:	e6ee      	b.n	2bd4a <pitch_downsample+0x6a>
   if (C==2)
   2bf6c:	f1b9 0f02 	cmp.w	r9, #2
   x_lp[0] = SHR32(HALF32(HALF32(x[0][1])+x[0][0]), shift);
   2bf70:	f8a5 e000 	strh.w	lr, [r5]
   if (C==2)
   2bf74:	f47f af12 	bne.w	2bd9c <pitch_downsample+0xbc>
   2bf78:	6847      	ldr	r7, [r0, #4]
   2bf7a:	e7ea      	b.n	2bf52 <pitch_downsample+0x272>
      shift=0;
   2bf7c:	f1a3 0102 	sub.w	r1, r3, #2
   2bf80:	fab1 f181 	clz	r1, r1
   2bf84:	0949      	lsrs	r1, r1, #5
   2bf86:	e6e0      	b.n	2bd4a <pitch_downsample+0x6a>

0002bf88 <celt_pitch_xcorr_c>:
{
   2bf88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2bf8c:	b091      	sub	sp, #68	; 0x44
   2bf8e:	e9cd 120d 	strd	r1, r2, [sp, #52]	; 0x34
   for (i=0;i<max_pitch-3;i+=4)
   2bf92:	9c1a      	ldr	r4, [sp, #104]	; 0x68
{
   2bf94:	9006      	str	r0, [sp, #24]
   for (i=0;i<max_pitch-3;i+=4)
   2bf96:	2c03      	cmp	r4, #3
{
   2bf98:	9301      	str	r3, [sp, #4]
   for (i=0;i<max_pitch-3;i+=4)
   2bf9a:	f340 810e 	ble.w	2c1ba <celt_pitch_xcorr_c+0x232>
   2bf9e:	3b04      	subs	r3, #4
   2bfa0:	4605      	mov	r5, r0
   2bfa2:	089b      	lsrs	r3, r3, #2
   2bfa4:	460f      	mov	r7, r1
   2bfa6:	4694      	mov	ip, r2
   2bfa8:	f105 0110 	add.w	r1, r5, #16
   2bfac:	1c5a      	adds	r2, r3, #1
   2bfae:	00d6      	lsls	r6, r2, #3
   2bfb0:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
   2bfb4:	1f20      	subs	r0, r4, #4
   2bfb6:	9300      	str	r3, [sp, #0]
   2bfb8:	0094      	lsls	r4, r2, #2
   2bfba:	19ab      	adds	r3, r5, r6
   2bfbc:	463a      	mov	r2, r7
   2bfbe:	930c      	str	r3, [sp, #48]	; 0x30
   2bfc0:	1c63      	adds	r3, r4, #1
   2bfc2:	0880      	lsrs	r0, r0, #2
   2bfc4:	320e      	adds	r2, #14
   2bfc6:	9308      	str	r3, [sp, #32]
   2bfc8:	1ca3      	adds	r3, r4, #2
   2bfca:	9309      	str	r3, [sp, #36]	; 0x24
   2bfcc:	eb02 03c0 	add.w	r3, r2, r0, lsl #3
   2bfd0:	9307      	str	r3, [sp, #28]
   2bfd2:	1dbb      	adds	r3, r7, #6
   2bfd4:	9302      	str	r3, [sp, #8]
   opus_val32 maxcorr=1;
   2bfd6:	2301      	movs	r3, #1
   2bfd8:	960a      	str	r6, [sp, #40]	; 0x28
   2bfda:	940b      	str	r4, [sp, #44]	; 0x2c
   2bfdc:	900f      	str	r0, [sp, #60]	; 0x3c
   2bfde:	f8cd c010 	str.w	ip, [sp, #16]
   2bfe2:	9303      	str	r3, [sp, #12]
   for (j=0;j<len-3;j+=4)
   2bfe4:	9901      	ldr	r1, [sp, #4]
   2bfe6:	9a02      	ldr	r2, [sp, #8]
   2bfe8:	2903      	cmp	r1, #3
   2bfea:	4613      	mov	r3, r2
   y_0=*y++;
   2bfec:	f932 cc06 	ldrsh.w	ip, [r2, #-6]
   y_1=*y++;
   2bff0:	f932 9c04 	ldrsh.w	r9, [r2, #-4]
   y_2=*y++;
   2bff4:	f932 8c02 	ldrsh.w	r8, [r2, #-2]
   for (j=0;j<len-3;j+=4)
   2bff8:	f340 80cf 	ble.w	2c19a <celt_pitch_xcorr_c+0x212>
   2bffc:	f102 0308 	add.w	r3, r2, #8
   2c000:	9305      	str	r3, [sp, #20]
   2c002:	461f      	mov	r7, r3
   2c004:	9b06      	ldr	r3, [sp, #24]
      opus_val32 sum[4]={0,0,0,0};
   2c006:	2000      	movs	r0, #0
   2c008:	4604      	mov	r4, r0
   2c00a:	4605      	mov	r5, r0
   2c00c:	4682      	mov	sl, r0
   2c00e:	f103 0608 	add.w	r6, r3, #8
      tmp = *x++;
   2c012:	f936 bc08 	ldrsh.w	fp, [r6, #-8]
      tmp=*x++;
   2c016:	f936 3c06 	ldrsh.w	r3, [r6, #-6]
      sum[3] = MAC16_16(sum[3],tmp,y_3);
   2c01a:	f937 ec08 	ldrsh.w	lr, [r7, #-8]
      tmp=*x++;
   2c01e:	f936 1c04 	ldrsh.w	r1, [r6, #-4]
      tmp=*x++;
   2c022:	f936 2c02 	ldrsh.w	r2, [r6, #-2]
      sum[0] = MAC16_16(sum[0],tmp,y_0);
   2c026:	fb0b aa0c 	mla	sl, fp, ip, sl
      y_0=*y++;
   2c02a:	f937 cc06 	ldrsh.w	ip, [r7, #-6]
      sum[1] = MAC16_16(sum[1],tmp,y_1);
   2c02e:	fb0b 5509 	mla	r5, fp, r9, r5
      sum[2] = MAC16_16(sum[2],tmp,y_2);
   2c032:	fb0b 4408 	mla	r4, fp, r8, r4
      sum[0] = MAC16_16(sum[0],tmp,y_1);
   2c036:	fb09 aa03 	mla	sl, r9, r3, sl
      sum[3] = MAC16_16(sum[3],tmp,y_3);
   2c03a:	fb0b 0b0e 	mla	fp, fp, lr, r0
      y_1=*y++;
   2c03e:	f937 9c04 	ldrsh.w	r9, [r7, #-4]
      sum[1] = MAC16_16(sum[1],tmp,y_2);
   2c042:	fb08 5503 	mla	r5, r8, r3, r5
      sum[0] = MAC16_16(sum[0],tmp,y_2);
   2c046:	fb08 aa01 	mla	sl, r8, r1, sl
      sum[2] = MAC16_16(sum[2],tmp,y_3);
   2c04a:	fb0e 4403 	mla	r4, lr, r3, r4
      y_2=*y++;
   2c04e:	f937 8c02 	ldrsh.w	r8, [r7, #-2]
      sum[3] = MAC16_16(sum[3],tmp,y_0);
   2c052:	fb03 b30c 	mla	r3, r3, ip, fp
      sum[3] = MAC16_16(sum[3],tmp,y_1);
   2c056:	fb01 3309 	mla	r3, r1, r9, r3
      sum[3] = MAC16_16(sum[3],tmp,y_2);
   2c05a:	fb02 3008 	mla	r0, r2, r8, r3
   for (j=0;j<len-3;j+=4)
   2c05e:	9b00      	ldr	r3, [sp, #0]
   2c060:	3608      	adds	r6, #8
      sum[1] = MAC16_16(sum[1],tmp,y_3);
   2c062:	fb0e 5501 	mla	r5, lr, r1, r5
      sum[2] = MAC16_16(sum[2],tmp,y_0);
   2c066:	fb0c 4401 	mla	r4, ip, r1, r4
   for (j=0;j<len-3;j+=4)
   2c06a:	42b3      	cmp	r3, r6
      sum[0] = MAC16_16(sum[0],tmp,y_3);
   2c06c:	fb0e aa02 	mla	sl, lr, r2, sl
      sum[1] = MAC16_16(sum[1],tmp,y_0);
   2c070:	fb0c 5502 	mla	r5, ip, r2, r5
      sum[2] = MAC16_16(sum[2],tmp,y_1);
   2c074:	fb09 4402 	mla	r4, r9, r2, r4
   2c078:	f107 0708 	add.w	r7, r7, #8
   for (j=0;j<len-3;j+=4)
   2c07c:	d1c9      	bne.n	2c012 <celt_pitch_xcorr_c+0x8a>
   2c07e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   2c080:	9b02      	ldr	r3, [sp, #8]
   2c082:	e9dd 7608 	ldrd	r7, r6, [sp, #32]
   2c086:	4413      	add	r3, r2
      tmp=*x++;
   2c088:	e9dd b20b 	ldrd	fp, r2, [sp, #44]	; 0x2c
   if (j++<len)
   2c08c:	9901      	ldr	r1, [sp, #4]
   2c08e:	4559      	cmp	r1, fp
   2c090:	dd0e      	ble.n	2c0b0 <celt_pitch_xcorr_c+0x128>
      opus_val16 tmp = *x++;
   2c092:	f9b2 1000 	ldrsh.w	r1, [r2]
      sum[3] = MAC16_16(sum[3],tmp,y_3);
   2c096:	f9b3 e000 	ldrsh.w	lr, [r3]
      sum[0] = MAC16_16(sum[0],tmp,y_0);
   2c09a:	fb01 aa0c 	mla	sl, r1, ip, sl
      sum[1] = MAC16_16(sum[1],tmp,y_1);
   2c09e:	fb01 5509 	mla	r5, r1, r9, r5
      sum[2] = MAC16_16(sum[2],tmp,y_2);
   2c0a2:	fb01 4408 	mla	r4, r1, r8, r4
      sum[3] = MAC16_16(sum[3],tmp,y_3);
   2c0a6:	fb01 000e 	mla	r0, r1, lr, r0
   2c0aa:	9901      	ldr	r1, [sp, #4]
      opus_val16 tmp = *x++;
   2c0ac:	3202      	adds	r2, #2
      y_3=*y++;
   2c0ae:	3302      	adds	r3, #2
   if (j++<len)
   2c0b0:	42b9      	cmp	r1, r7
   2c0b2:	dd0e      	ble.n	2c0d2 <celt_pitch_xcorr_c+0x14a>
      opus_val16 tmp=*x++;
   2c0b4:	f9b2 1000 	ldrsh.w	r1, [r2]
      y_0=*y++;
   2c0b8:	f9b3 c000 	ldrsh.w	ip, [r3]
      sum[0] = MAC16_16(sum[0],tmp,y_1);
   2c0bc:	fb01 aa09 	mla	sl, r1, r9, sl
      sum[1] = MAC16_16(sum[1],tmp,y_2);
   2c0c0:	fb01 5508 	mla	r5, r1, r8, r5
      sum[2] = MAC16_16(sum[2],tmp,y_3);
   2c0c4:	fb0e 4401 	mla	r4, lr, r1, r4
      sum[3] = MAC16_16(sum[3],tmp,y_0);
   2c0c8:	fb01 000c 	mla	r0, r1, ip, r0
   2c0cc:	9901      	ldr	r1, [sp, #4]
      opus_val16 tmp=*x++;
   2c0ce:	3202      	adds	r2, #2
      y_0=*y++;
   2c0d0:	3302      	adds	r3, #2
   if (j<len)
   2c0d2:	42b1      	cmp	r1, r6
   2c0d4:	dd0a      	ble.n	2c0ec <celt_pitch_xcorr_c+0x164>
      opus_val16 tmp=*x++;
   2c0d6:	f9b2 2000 	ldrsh.w	r2, [r2]
      sum[3] = MAC16_16(sum[3],tmp,y_1);
   2c0da:	881b      	ldrh	r3, [r3, #0]
      sum[0] = MAC16_16(sum[0],tmp,y_2);
   2c0dc:	fb02 aa08 	mla	sl, r2, r8, sl
      sum[1] = MAC16_16(sum[1],tmp,y_3);
   2c0e0:	fb0e 5502 	mla	r5, lr, r2, r5
      sum[2] = MAC16_16(sum[2],tmp,y_0);
   2c0e4:	fb02 440c 	mla	r4, r2, ip, r4
      sum[3] = MAC16_16(sum[3],tmp,y_1);
   2c0e8:	fb12 0003 	smlabb	r0, r2, r3, r0
   2c0ec:	9a03      	ldr	r2, [sp, #12]
   2c0ee:	4582      	cmp	sl, r0
   2c0f0:	4653      	mov	r3, sl
   2c0f2:	bfb8      	it	lt
   2c0f4:	4603      	movlt	r3, r0
   2c0f6:	4293      	cmp	r3, r2
   2c0f8:	bfb8      	it	lt
   2c0fa:	4613      	movlt	r3, r2
   2c0fc:	42ab      	cmp	r3, r5
      xcorr[i]=sum[0];
   2c0fe:	9a04      	ldr	r2, [sp, #16]
   2c100:	bfb8      	it	lt
   2c102:	462b      	movlt	r3, r5
      maxcorr = MAX32(maxcorr, sum[0]);
   2c104:	42a3      	cmp	r3, r4
      xcorr[i]=sum[0];
   2c106:	f8c2 a000 	str.w	sl, [r2]
      maxcorr = MAX32(maxcorr, sum[0]);
   2c10a:	bfb8      	it	lt
   2c10c:	4623      	movlt	r3, r4
      xcorr[i+1]=sum[1];
   2c10e:	6055      	str	r5, [r2, #4]
      xcorr[i+3]=sum[3];
   2c110:	e9c2 4002 	strd	r4, r0, [r2, #8]
   2c114:	3210      	adds	r2, #16
      maxcorr = MAX32(maxcorr, sum[0]);
   2c116:	9303      	str	r3, [sp, #12]
   2c118:	9204      	str	r2, [sp, #16]
   2c11a:	9b05      	ldr	r3, [sp, #20]
   for (i=0;i<max_pitch-3;i+=4)
   2c11c:	9a07      	ldr	r2, [sp, #28]
   2c11e:	9302      	str	r3, [sp, #8]
   2c120:	429a      	cmp	r2, r3
   2c122:	f47f af5f 	bne.w	2bfe4 <celt_pitch_xcorr_c+0x5c>
   2c126:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
   2c128:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   2c12a:	3701      	adds	r7, #1
   2c12c:	00bf      	lsls	r7, r7, #2
   for (;i<max_pitch;i++)
   2c12e:	42bb      	cmp	r3, r7
   2c130:	dd2f      	ble.n	2c192 <celt_pitch_xcorr_c+0x20a>
   2c132:	4619      	mov	r1, r3
   2c134:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   2c136:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   2c138:	f8dd e00c 	ldr.w	lr, [sp, #12]
   2c13c:	f107 4c00 	add.w	ip, r7, #2147483648	; 0x80000000
   2c140:	eb03 0681 	add.w	r6, r3, r1, lsl #2
   2c144:	eb03 0787 	add.w	r7, r3, r7, lsl #2
   2c148:	9901      	ldr	r1, [sp, #4]
   2c14a:	9b06      	ldr	r3, [sp, #24]
   2c14c:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
   2c150:	eb03 0541 	add.w	r5, r3, r1, lsl #1
   2c154:	eb02 0c4c 	add.w	ip, r2, ip, lsl #1
   2c158:	3d02      	subs	r5, #2
   2c15a:	4699      	mov	r9, r3
   2c15c:	4688      	mov	r8, r1
   for (i=0;i<N;i++)
   2c15e:	f1b8 0f00 	cmp.w	r8, #0
   2c162:	dd28      	ble.n	2c1b6 <celt_pitch_xcorr_c+0x22e>
   2c164:	f1a9 0302 	sub.w	r3, r9, #2
   2c168:	4661      	mov	r1, ip
   opus_val32 xy=0;
   2c16a:	2200      	movs	r2, #0
      xy = MAC16_16(xy, x[i], y[i]);
   2c16c:	f833 4f02 	ldrh.w	r4, [r3, #2]!
   2c170:	f831 0f02 	ldrh.w	r0, [r1, #2]!
   for (i=0;i<N;i++)
   2c174:	429d      	cmp	r5, r3
      xy = MAC16_16(xy, x[i], y[i]);
   2c176:	fb14 2200 	smlabb	r2, r4, r0, r2
   for (i=0;i<N;i++)
   2c17a:	d1f7      	bne.n	2c16c <celt_pitch_xcorr_c+0x1e4>
      xcorr[i] = sum;
   2c17c:	f847 2b04 	str.w	r2, [r7], #4
      maxcorr = MAX32(maxcorr, sum);
   2c180:	4596      	cmp	lr, r2
   2c182:	bfb8      	it	lt
   2c184:	4696      	movlt	lr, r2
   for (;i<max_pitch;i++)
   2c186:	42be      	cmp	r6, r7
   2c188:	f10c 0c02 	add.w	ip, ip, #2
   2c18c:	d1e7      	bne.n	2c15e <celt_pitch_xcorr_c+0x1d6>
   2c18e:	f8cd e00c 	str.w	lr, [sp, #12]
}
   2c192:	9803      	ldr	r0, [sp, #12]
   2c194:	b011      	add	sp, #68	; 0x44
   2c196:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   for (j=0;j<len-3;j+=4)
   2c19a:	f04f 0e00 	mov.w	lr, #0
   2c19e:	f103 0108 	add.w	r1, r3, #8
      opus_val32 sum[4]={0,0,0,0};
   2c1a2:	4670      	mov	r0, lr
   2c1a4:	4674      	mov	r4, lr
   2c1a6:	4675      	mov	r5, lr
   2c1a8:	46f2      	mov	sl, lr
   2c1aa:	46f3      	mov	fp, lr
   2c1ac:	9a06      	ldr	r2, [sp, #24]
   2c1ae:	9105      	str	r1, [sp, #20]
   2c1b0:	2602      	movs	r6, #2
   2c1b2:	2701      	movs	r7, #1
   2c1b4:	e76a      	b.n	2c08c <celt_pitch_xcorr_c+0x104>
   opus_val32 xy=0;
   2c1b6:	2200      	movs	r2, #0
   2c1b8:	e7e0      	b.n	2c17c <celt_pitch_xcorr_c+0x1f4>
   opus_val32 maxcorr=1;
   2c1ba:	2301      	movs	r3, #1
   2c1bc:	9303      	str	r3, [sp, #12]
   for (i=0;i<max_pitch-3;i+=4)
   2c1be:	2700      	movs	r7, #0
   2c1c0:	4623      	mov	r3, r4
   2c1c2:	e7b4      	b.n	2c12e <celt_pitch_xcorr_c+0x1a6>

0002c1c4 <pitch_search>:
{
   2c1c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2c1c8:	b08f      	sub	sp, #60	; 0x3c
   ALLOC(x_lp4, len>>2, opus_val16);
   2c1ca:	1096      	asrs	r6, r2, #2
{
   2c1cc:	af04      	add	r7, sp, #16
   lag = len+max_pitch;
   2c1ce:	eb02 0c03 	add.w	ip, r2, r3
{
   2c1d2:	469a      	mov	sl, r3
   ALLOC(y_lp4, lag>>2, opus_val16);
   2c1d4:	ea4f 0cac 	mov.w	ip, ip, asr #2
   ALLOC(x_lp4, len>>2, opus_val16);
   2c1d8:	0073      	lsls	r3, r6, #1
   ALLOC(xcorr, max_pitch>>1, opus_val32);
   2c1da:	ea4f 046a 	mov.w	r4, sl, asr #1
{
   2c1de:	61ba      	str	r2, [r7, #24]
   ALLOC(x_lp4, len>>2, opus_val16);
   2c1e0:	60bb      	str	r3, [r7, #8]
   2c1e2:	f103 0208 	add.w	r2, r3, #8
   ALLOC(y_lp4, lag>>2, opus_val16);
   2c1e6:	ea4f 034c 	mov.w	r3, ip, lsl #1
   ALLOC(x_lp4, len>>2, opus_val16);
   2c1ea:	f022 0207 	bic.w	r2, r2, #7
   ALLOC(y_lp4, lag>>2, opus_val16);
   2c1ee:	61fb      	str	r3, [r7, #28]
   ALLOC(xcorr, max_pitch>>1, opus_val32);
   2c1f0:	613c      	str	r4, [r7, #16]
   ALLOC(y_lp4, lag>>2, opus_val16);
   2c1f2:	3308      	adds	r3, #8
   ALLOC(xcorr, max_pitch>>1, opus_val32);
   2c1f4:	00a4      	lsls	r4, r4, #2
   ALLOC(x_lp4, len>>2, opus_val16);
   2c1f6:	ebad 0d02 	sub.w	sp, sp, r2
   ALLOC(y_lp4, lag>>2, opus_val16);
   2c1fa:	f023 0307 	bic.w	r3, r3, #7
   ALLOC(xcorr, max_pitch>>1, opus_val32);
   2c1fe:	f104 020a 	add.w	r2, r4, #10
   ALLOC(x_lp4, len>>2, opus_val16);
   2c202:	ad04      	add	r5, sp, #16
   ALLOC(xcorr, max_pitch>>1, opus_val32);
   2c204:	f022 0207 	bic.w	r2, r2, #7
   ALLOC(y_lp4, lag>>2, opus_val16);
   2c208:	ebad 0d03 	sub.w	sp, sp, r3
   ALLOC(xcorr, max_pitch>>1, opus_val32);
   2c20c:	617c      	str	r4, [r7, #20]
   ALLOC(y_lp4, lag>>2, opus_val16);
   2c20e:	f10d 0910 	add.w	r9, sp, #16
   int best_pitch[2]={0,0};
   2c212:	2400      	movs	r4, #0
   ALLOC(xcorr, max_pitch>>1, opus_val32);
   2c214:	ebad 0d02 	sub.w	sp, sp, r2
   2c218:	ab04      	add	r3, sp, #16
   for (j=0;j<len>>2;j++)
   2c21a:	42a6      	cmp	r6, r4
{
   2c21c:	4680      	mov	r8, r0
   2c21e:	468b      	mov	fp, r1
   ALLOC(xcorr, max_pitch>>1, opus_val32);
   2c220:	60fb      	str	r3, [r7, #12]
   int best_pitch[2]={0,0};
   2c222:	e9c7 4408 	strd	r4, r4, [r7, #32]
   for (j=0;j<len>>2;j++)
   2c226:	f340 812f 	ble.w	2c488 <pitch_search+0x2c4>
   2c22a:	1eaa      	subs	r2, r5, #2
   2c22c:	4613      	mov	r3, r2
      x_lp4[j] = x_lp[2*j];
   2c22e:	f838 1024 	ldrh.w	r1, [r8, r4, lsl #2]
   2c232:	f823 1f02 	strh.w	r1, [r3, #2]!
   for (j=0;j<len>>2;j++)
   2c236:	3401      	adds	r4, #1
   2c238:	42a6      	cmp	r6, r4
   2c23a:	d1f8      	bne.n	2c22e <pitch_search+0x6a>
   for (j=0;j<lag>>2;j++)
   2c23c:	f1bc 0f00 	cmp.w	ip, #0
   2c240:	dd0e      	ble.n	2c260 <pitch_search+0x9c>
   2c242:	f1a9 0202 	sub.w	r2, r9, #2
   2c246:	4611      	mov	r1, r2
   for (j=0;j<len>>2;j++)
   2c248:	2300      	movs	r3, #0
      y_lp4[j] = y[2*j];
   2c24a:	f83b 0023 	ldrh.w	r0, [fp, r3, lsl #2]
   2c24e:	f821 0f02 	strh.w	r0, [r1, #2]!
   for (j=0;j<lag>>2;j++)
   2c252:	3301      	adds	r3, #1
   2c254:	459c      	cmp	ip, r3
   2c256:	dcf8      	bgt.n	2c24a <pitch_search+0x86>
   for (i=0;i<len;i++)
   2c258:	2e00      	cmp	r6, #0
   2c25a:	f340 8121 	ble.w	2c4a0 <pitch_search+0x2dc>
   2c25e:	1eaa      	subs	r2, r5, #2
   for (j=0;j<len>>2;j++)
   2c260:	2000      	movs	r0, #0
   2c262:	4614      	mov	r4, r2
   2c264:	4686      	mov	lr, r0
   2c266:	4603      	mov	r3, r0
      maxval = MAX16(maxval, x[i]);
   2c268:	f934 2f02 	ldrsh.w	r2, [r4, #2]!
   2c26c:	4596      	cmp	lr, r2
   for (i=0;i<len;i++)
   2c26e:	f103 0301 	add.w	r3, r3, #1
      maxval = MAX16(maxval, x[i]);
   2c272:	bfb8      	it	lt
   2c274:	4696      	movlt	lr, r2
      minval = MIN16(minval, x[i]);
   2c276:	4290      	cmp	r0, r2
   2c278:	bfa8      	it	ge
   2c27a:	4610      	movge	r0, r2
   for (i=0;i<len;i++)
   2c27c:	429e      	cmp	r6, r3
   2c27e:	dcf3      	bgt.n	2c268 <pitch_search+0xa4>
   2c280:	f1be 0f01 	cmp.w	lr, #1
   2c284:	f1c0 0100 	rsb	r1, r0, #0
   2c288:	bfb8      	it	lt
   2c28a:	f04f 0e01 	movlt.w	lr, #1
   2c28e:	4571      	cmp	r1, lr
   2c290:	bfb8      	it	lt
   2c292:	4671      	movlt	r1, lr
   2c294:	f1bc 0f00 	cmp.w	ip, #0
   2c298:	f340 8104 	ble.w	2c4a4 <pitch_search+0x2e0>
   2c29c:	f1a9 0202 	sub.w	r2, r9, #2
   2c2a0:	69fb      	ldr	r3, [r7, #28]
   2c2a2:	f1a3 0e02 	sub.w	lr, r3, #2
   opus_val16 minval = 0;
   2c2a6:	2300      	movs	r3, #0
   2c2a8:	44ce      	add	lr, r9
   opus_val16 maxval = 0;
   2c2aa:	461c      	mov	r4, r3
      maxval = MAX16(maxval, x[i]);
   2c2ac:	f932 0f02 	ldrsh.w	r0, [r2, #2]!
   2c2b0:	4284      	cmp	r4, r0
   2c2b2:	bfb8      	it	lt
   2c2b4:	4604      	movlt	r4, r0
      minval = MIN16(minval, x[i]);
   2c2b6:	4283      	cmp	r3, r0
   2c2b8:	bfa8      	it	ge
   2c2ba:	4603      	movge	r3, r0
   for (i=0;i<len;i++)
   2c2bc:	4596      	cmp	lr, r2
   2c2be:	d1f5      	bne.n	2c2ac <pitch_search+0xe8>
   2c2c0:	425b      	negs	r3, r3
   shift = celt_ilog2(MAX32(1, MAX32(xmax, ymax)))-11;
   2c2c2:	42a3      	cmp	r3, r4
   2c2c4:	bfb8      	it	lt
   2c2c6:	4623      	movlt	r3, r4
   2c2c8:	428b      	cmp	r3, r1
   2c2ca:	bfb8      	it	lt
   2c2cc:	460b      	movlt	r3, r1
   return EC_ILOG(x)-1;
   2c2ce:	fab3 f483 	clz	r4, r3
   2c2d2:	f1c4 041f 	rsb	r4, r4, #31
   2c2d6:	b2a4      	uxth	r4, r4
   2c2d8:	3c0b      	subs	r4, #11
   if (shift>0)
   2c2da:	2c00      	cmp	r4, #0
   2c2dc:	f340 80cd 	ble.w	2c47a <pitch_search+0x2b6>
      for (j=0;j<len>>2;j++)
   2c2e0:	2e00      	cmp	r6, #0
   2c2e2:	dd09      	ble.n	2c2f8 <pitch_search+0x134>
   2c2e4:	68bb      	ldr	r3, [r7, #8]
   2c2e6:	1e99      	subs	r1, r3, #2
   2c2e8:	4429      	add	r1, r5
   2c2ea:	1eab      	subs	r3, r5, #2
         x_lp4[j] = SHR16(x_lp4[j], shift);
   2c2ec:	f933 2f02 	ldrsh.w	r2, [r3, #2]!
   2c2f0:	4122      	asrs	r2, r4
      for (j=0;j<len>>2;j++)
   2c2f2:	4299      	cmp	r1, r3
         x_lp4[j] = SHR16(x_lp4[j], shift);
   2c2f4:	801a      	strh	r2, [r3, #0]
      for (j=0;j<len>>2;j++)
   2c2f6:	d1f9      	bne.n	2c2ec <pitch_search+0x128>
      for (j=0;j<lag>>2;j++)
   2c2f8:	f1bc 0f00 	cmp.w	ip, #0
   2c2fc:	dd0a      	ble.n	2c314 <pitch_search+0x150>
   2c2fe:	69fb      	ldr	r3, [r7, #28]
   2c300:	1e99      	subs	r1, r3, #2
   2c302:	4449      	add	r1, r9
   2c304:	f1a9 0302 	sub.w	r3, r9, #2
         y_lp4[j] = SHR16(y_lp4[j], shift);
   2c308:	f933 2f02 	ldrsh.w	r2, [r3, #2]!
   2c30c:	4122      	asrs	r2, r4
      for (j=0;j<lag>>2;j++)
   2c30e:	4299      	cmp	r1, r3
         y_lp4[j] = SHR16(y_lp4[j], shift);
   2c310:	801a      	strh	r2, [r3, #0]
      for (j=0;j<lag>>2;j++)
   2c312:	d1f9      	bne.n	2c308 <pitch_search+0x144>
      shift *= 2;
   2c314:	0063      	lsls	r3, r4, #1
   2c316:	607b      	str	r3, [r7, #4]
   2c318:	3301      	adds	r3, #1
   2c31a:	60bb      	str	r3, [r7, #8]
   maxcorr =
   2c31c:	68fc      	ldr	r4, [r7, #12]
   2c31e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   2c320:	9301      	str	r3, [sp, #4]
   celt_pitch_xcorr(x_lp4, y_lp4, xcorr, len>>2, max_pitch>>2, arch);
   2c322:	ea4f 0aaa 	mov.w	sl, sl, asr #2
   maxcorr =
   2c326:	4628      	mov	r0, r5
   2c328:	4633      	mov	r3, r6
   2c32a:	4622      	mov	r2, r4
   2c32c:	4649      	mov	r1, r9
   2c32e:	f8cd a000 	str.w	sl, [sp]
   2c332:	f7ff fe29 	bl	2bf88 <celt_pitch_xcorr_c>
   find_best_pitch(xcorr, y_lp4, len>>2, max_pitch>>2, best_pitch
   2c336:	2500      	movs	r5, #0
   2c338:	9002      	str	r0, [sp, #8]
   2c33a:	f107 0020 	add.w	r0, r7, #32
   2c33e:	4653      	mov	r3, sl
   2c340:	4632      	mov	r2, r6
   2c342:	9000      	str	r0, [sp, #0]
   2c344:	4649      	mov	r1, r9
   2c346:	9501      	str	r5, [sp, #4]
   2c348:	4620      	mov	r0, r4
   2c34a:	f7ff fbcf 	bl	2baec <find_best_pitch>
   2c34e:	69bb      	ldr	r3, [r7, #24]
   2c350:	105a      	asrs	r2, r3, #1
   for (i=0;i<max_pitch>>1;i++)
   2c352:	693b      	ldr	r3, [r7, #16]
   2c354:	42ab      	cmp	r3, r5
   2c356:	f340 809f 	ble.w	2c498 <pitch_search+0x2d4>
      if (abs(i-2*best_pitch[0])>2 && abs(i-2*best_pitch[1])>2)
   2c35a:	e9d7 1008 	ldrd	r1, r0, [r7, #32]
   2c35e:	697b      	ldr	r3, [r7, #20]
      xcorr[i] = 0;
   2c360:	61fd      	str	r5, [r7, #28]
      if (abs(i-2*best_pitch[0])>2 && abs(i-2*best_pitch[1])>2)
   2c362:	0049      	lsls	r1, r1, #1
   2c364:	3b04      	subs	r3, #4
   2c366:	f1a8 0602 	sub.w	r6, r8, #2
   2c36a:	18e3      	adds	r3, r4, r3
   2c36c:	f1c1 0800 	rsb	r8, r1, #0
   2c370:	eba1 0140 	sub.w	r1, r1, r0, lsl #1
   2c374:	f1a4 0e04 	sub.w	lr, r4, #4
   2c378:	f1ab 0902 	sub.w	r9, fp, #2
   maxcorr=1;
   2c37c:	687c      	ldr	r4, [r7, #4]
   2c37e:	617e      	str	r6, [r7, #20]
   2c380:	f8c7 b004 	str.w	fp, [r7, #4]
      if (abs(i-2*best_pitch[0])>2 && abs(i-2*best_pitch[1])>2)
   2c384:	61b9      	str	r1, [r7, #24]
   2c386:	eb06 0c42 	add.w	ip, r6, r2, lsl #1
   maxcorr=1;
   2c38a:	f04f 0a01 	mov.w	sl, #1
   2c38e:	469b      	mov	fp, r3
      if (abs(i-2*best_pitch[0])>2 && abs(i-2*best_pitch[1])>2)
   2c390:	ea88 73e8 	eor.w	r3, r8, r8, asr #31
   2c394:	eba3 73e8 	sub.w	r3, r3, r8, asr #31
      xcorr[i] = 0;
   2c398:	69f9      	ldr	r1, [r7, #28]
   2c39a:	f84e 1f04 	str.w	r1, [lr, #4]!
      if (abs(i-2*best_pitch[0])>2 && abs(i-2*best_pitch[1])>2)
   2c39e:	2b02      	cmp	r3, #2
   2c3a0:	dd06      	ble.n	2c3b0 <pitch_search+0x1ec>
   2c3a2:	69bb      	ldr	r3, [r7, #24]
   2c3a4:	4443      	add	r3, r8
   2c3a6:	2b00      	cmp	r3, #0
   2c3a8:	bfb8      	it	lt
   2c3aa:	425b      	neglt	r3, r3
   2c3ac:	2b02      	cmp	r3, #2
   2c3ae:	dc15      	bgt.n	2c3dc <pitch_search+0x218>
      for (j=0;j<len>>1;j++)
   2c3b0:	2a00      	cmp	r2, #0
   2c3b2:	dd5f      	ble.n	2c474 <pitch_search+0x2b0>
   2c3b4:	6978      	ldr	r0, [r7, #20]
   2c3b6:	464e      	mov	r6, r9
   2c3b8:	2500      	movs	r5, #0
         sum += SHR32(MULT16_16(x_lp[j],y[i+j]), shift);
   2c3ba:	f830 3f02 	ldrh.w	r3, [r0, #2]!
   2c3be:	f836 1f02 	ldrh.w	r1, [r6, #2]!
   2c3c2:	fb13 f301 	smulbb	r3, r3, r1
   2c3c6:	4123      	asrs	r3, r4
      for (j=0;j<len>>1;j++)
   2c3c8:	4584      	cmp	ip, r0
         sum += SHR32(MULT16_16(x_lp[j],y[i+j]), shift);
   2c3ca:	441d      	add	r5, r3
      for (j=0;j<len>>1;j++)
   2c3cc:	d1f5      	bne.n	2c3ba <pitch_search+0x1f6>
   2c3ce:	ea45 73e5 	orr.w	r3, r5, r5, asr #31
      maxcorr = MAX32(maxcorr, sum);
   2c3d2:	45aa      	cmp	sl, r5
      xcorr[i] = MAX32(-1, sum);
   2c3d4:	f8ce 3000 	str.w	r3, [lr]
      maxcorr = MAX32(maxcorr, sum);
   2c3d8:	bfb8      	it	lt
   2c3da:	46aa      	movlt	sl, r5
   for (i=0;i<max_pitch>>1;i++)
   2c3dc:	45f3      	cmp	fp, lr
   2c3de:	f108 0801 	add.w	r8, r8, #1
   2c3e2:	f109 0902 	add.w	r9, r9, #2
   2c3e6:	d1d3      	bne.n	2c390 <pitch_search+0x1cc>
   2c3e8:	f8d7 b004 	ldr.w	fp, [r7, #4]
   2c3ec:	693c      	ldr	r4, [r7, #16]
   find_best_pitch(xcorr, y, len>>1, max_pitch>>1, best_pitch
   2c3ee:	68bb      	ldr	r3, [r7, #8]
   2c3f0:	68fd      	ldr	r5, [r7, #12]
   2c3f2:	9301      	str	r3, [sp, #4]
   2c3f4:	f107 0320 	add.w	r3, r7, #32
   2c3f8:	9300      	str	r3, [sp, #0]
   2c3fa:	4659      	mov	r1, fp
   2c3fc:	f8cd a008 	str.w	sl, [sp, #8]
   2c400:	4623      	mov	r3, r4
   2c402:	4628      	mov	r0, r5
   2c404:	f7ff fb72 	bl	2baec <find_best_pitch>
   if (best_pitch[0]>0 && best_pitch[0]<(max_pitch>>1)-1)
   2c408:	6a39      	ldr	r1, [r7, #32]
   2c40a:	2900      	cmp	r1, #0
   2c40c:	dd29      	ble.n	2c462 <pitch_search+0x29e>
   ALLOC(xcorr, max_pitch>>1, opus_val32);
   2c40e:	1e63      	subs	r3, r4, #1
   if (best_pitch[0]>0 && best_pitch[0]<(max_pitch>>1)-1)
   2c410:	428b      	cmp	r3, r1
   2c412:	dd26      	ble.n	2c462 <pitch_search+0x29e>
   2c414:	eb05 0381 	add.w	r3, r5, r1, lsl #2
      b = xcorr[best_pitch[0]];
   2c418:	f855 6021 	ldr.w	r6, [r5, r1, lsl #2]
      a = xcorr[best_pitch[0]-1];
   2c41c:	f853 2c04 	ldr.w	r2, [r3, #-4]
      c = xcorr[best_pitch[0]+1];
   2c420:	685d      	ldr	r5, [r3, #4]
      if ((c-a) > MULT16_32_Q15(QCONST16(.7f,15),b-a))
   2c422:	1ab0      	subs	r0, r6, r2
   2c424:	b283      	uxth	r3, r0
   2c426:	f645 149a 	movw	r4, #22938	; 0x599a
   2c42a:	1400      	asrs	r0, r0, #16
   2c42c:	fb04 f303 	mul.w	r3, r4, r3
   2c430:	fb04 f000 	mul.w	r0, r4, r0
   2c434:	13db      	asrs	r3, r3, #15
   2c436:	eb03 0340 	add.w	r3, r3, r0, lsl #1
   2c43a:	1aa8      	subs	r0, r5, r2
   2c43c:	4298      	cmp	r0, r3
   2c43e:	dc21      	bgt.n	2c484 <pitch_search+0x2c0>
      else if ((a-c) > MULT16_32_Q15(QCONST16(.7f,15),b-c))
   2c440:	1b76      	subs	r6, r6, r5
   2c442:	b2b0      	uxth	r0, r6
   2c444:	fb04 f000 	mul.w	r0, r4, r0
   2c448:	1436      	asrs	r6, r6, #16
   2c44a:	13c0      	asrs	r0, r0, #15
   2c44c:	fb04 f406 	mul.w	r4, r4, r6
   2c450:	1b53      	subs	r3, r2, r5
   2c452:	eb00 0444 	add.w	r4, r0, r4, lsl #1
   2c456:	42a3      	cmp	r3, r4
   2c458:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2c45c:	bfd8      	it	le
   2c45e:	2300      	movle	r3, #0
   2c460:	e000      	b.n	2c464 <pitch_search+0x2a0>
      offset = 0;
   2c462:	2300      	movs	r3, #0
   *pitch = 2*best_pitch[0]-offset;
   2c464:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   2c466:	ebc3 0341 	rsb	r3, r3, r1, lsl #1
}
   2c46a:	372c      	adds	r7, #44	; 0x2c
   *pitch = 2*best_pitch[0]-offset;
   2c46c:	6013      	str	r3, [r2, #0]
}
   2c46e:	46bd      	mov	sp, r7
   2c470:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      for (j=0;j<len>>1;j++)
   2c474:	2300      	movs	r3, #0
   2c476:	461d      	mov	r5, r3
   2c478:	e7ab      	b.n	2c3d2 <pitch_search+0x20e>
      shift = 0;
   2c47a:	2300      	movs	r3, #0
   2c47c:	2201      	movs	r2, #1
   2c47e:	e9c7 3201 	strd	r3, r2, [r7, #4]
   2c482:	e74b      	b.n	2c31c <pitch_search+0x158>
         offset = 1;
   2c484:	2301      	movs	r3, #1
   2c486:	e7ed      	b.n	2c464 <pitch_search+0x2a0>
   for (j=0;j<lag>>2;j++)
   2c488:	f1bc 0f00 	cmp.w	ip, #0
   2c48c:	f73f aed9 	bgt.w	2c242 <pitch_search+0x7e>
   2c490:	2301      	movs	r3, #1
      shift = 0;
   2c492:	607c      	str	r4, [r7, #4]
   for (j=0;j<lag>>2;j++)
   2c494:	60bb      	str	r3, [r7, #8]
   2c496:	e741      	b.n	2c31c <pitch_search+0x158>
   maxcorr=1;
   2c498:	f04f 0a01 	mov.w	sl, #1
   2c49c:	461c      	mov	r4, r3
   2c49e:	e7a6      	b.n	2c3ee <pitch_search+0x22a>
   for (i=0;i<len;i++)
   2c4a0:	2101      	movs	r1, #1
   2c4a2:	e6fd      	b.n	2c2a0 <pitch_search+0xdc>
   2c4a4:	2400      	movs	r4, #0
   2c4a6:	4623      	mov	r3, r4
   2c4a8:	e70b      	b.n	2c2c2 <pitch_search+0xfe>
   2c4aa:	bf00      	nop

0002c4ac <remove_doubling>:
#endif

static const int second_check[16] = {0, 0, 3, 2, 3, 2, 5, 2, 3, 2, 3, 2, 5, 2, 3, 2};
opus_val16 remove_doubling(opus_val16 *x, int maxperiod, int minperiod,
      int N, int *T0_, int prev_period, opus_val16 prev_gain, int arch)
{
   2c4ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2c4b0:	b09d      	sub	sp, #116	; 0x74
   2c4b2:	af00      	add	r7, sp, #0
   SAVE_STACK;

   minperiod0 = minperiod;
   maxperiod /= 2;
   minperiod /= 2;
   *T0_ /= 2;
   2c4b4:	e9d7 5426 	ldrd	r5, r4, [r7, #152]	; 0x98
   2c4b8:	682d      	ldr	r5, [r5, #0]
{
   2c4ba:	f9b7 60a0 	ldrsh.w	r6, [r7, #160]	; 0xa0
   2c4be:	60fa      	str	r2, [r7, #12]
   prev_period /= 2;
   N /= 2;
   2c4c0:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
   2c4c4:	105b      	asrs	r3, r3, #1
   maxperiod /= 2;
   2c4c6:	eb01 71d1 	add.w	r1, r1, r1, lsr #31
   *T0_ /= 2;
   2c4ca:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
   minperiod /= 2;
   2c4ce:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
   maxperiod /= 2;
   2c4d2:	1049      	asrs	r1, r1, #1
{
   2c4d4:	627e      	str	r6, [r7, #36]	; 0x24
   prev_period /= 2;
   2c4d6:	eb04 74d4 	add.w	r4, r4, r4, lsr #31
   *T0_ /= 2;
   2c4da:	106e      	asrs	r6, r5, #1
   N /= 2;
   2c4dc:	653b      	str	r3, [r7, #80]	; 0x50
   minperiod /= 2;
   2c4de:	1053      	asrs	r3, r2, #1
   x += maxperiod;
   2c4e0:	eb00 0041 	add.w	r0, r0, r1, lsl #1
   minperiod /= 2;
   2c4e4:	64fb      	str	r3, [r7, #76]	; 0x4c
   if (*T0_>=maxperiod)
   2c4e6:	428e      	cmp	r6, r1
   prev_period /= 2;
   2c4e8:	ea4f 0364 	mov.w	r3, r4, asr #1
   maxperiod /= 2;
   2c4ec:	6239      	str	r1, [r7, #32]
   *T0_ /= 2;
   2c4ee:	65be      	str	r6, [r7, #88]	; 0x58
   x += maxperiod;
   2c4f0:	6578      	str	r0, [r7, #84]	; 0x54
   prev_period /= 2;
   2c4f2:	63fb      	str	r3, [r7, #60]	; 0x3c
   if (*T0_>=maxperiod)
   2c4f4:	f280 8180 	bge.w	2c7f8 <remove_doubling+0x34c>
   *T0_ /= 2;
   2c4f8:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
   2c4fc:	601e      	str	r6, [r3, #0]
   2c4fe:	460b      	mov	r3, r1
      *T0_=maxperiod-1;

   T = T0 = *T0_;
   ALLOC(yy_lookup, maxperiod+1, opus_val32);
   2c500:	009b      	lsls	r3, r3, #2
   2c502:	330e      	adds	r3, #14
   2c504:	f023 0307 	bic.w	r3, r3, #7
   2c508:	ebad 0d03 	sub.w	sp, sp, r3
   dual_inner_prod(x, x, x-T0, N, &xx, &xy, arch);
   2c50c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   2c50e:	005a      	lsls	r2, r3, #1
   for (i=0;i<N;i++)
   2c510:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   2c512:	647a      	str	r2, [r7, #68]	; 0x44
   2c514:	2b00      	cmp	r3, #0
   ALLOC(yy_lookup, maxperiod+1, opus_val32);
   2c516:	46e8      	mov	r8, sp
   2c518:	f340 81a9 	ble.w	2c86e <remove_doubling+0x3c2>
   2c51c:	ea4f 0943 	mov.w	r9, r3, lsl #1
   2c520:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   2c522:	f1a9 0002 	sub.w	r0, r9, #2
   2c526:	1a99      	subs	r1, r3, r2
   opus_val32 xy02=0;
   2c528:	2500      	movs	r5, #0
   2c52a:	4418      	add	r0, r3
   2c52c:	3902      	subs	r1, #2
   opus_val32 xy01=0;
   2c52e:	462c      	mov	r4, r5
   2c530:	1e9a      	subs	r2, r3, #2
      xy01 = MAC16_16(xy01, x[i], y01[i]);
   2c532:	f932 3f02 	ldrsh.w	r3, [r2, #2]!
      xy02 = MAC16_16(xy02, x[i], y02[i]);
   2c536:	f831 6f02 	ldrh.w	r6, [r1, #2]!
   for (i=0;i<N;i++)
   2c53a:	4290      	cmp	r0, r2
      xy01 = MAC16_16(xy01, x[i], y01[i]);
   2c53c:	fb03 4403 	mla	r4, r3, r3, r4
      xy02 = MAC16_16(xy02, x[i], y02[i]);
   2c540:	fb13 5506 	smlabb	r5, r3, r6, r5
   for (i=0;i<N;i++)
   2c544:	d1f5      	bne.n	2c532 <remove_doubling+0x86>
   yy_lookup[0] = xx;
   yy=xx;
   for (i=1;i<=maxperiod;i++)
   2c546:	6a3b      	ldr	r3, [r7, #32]
   2c548:	64bc      	str	r4, [r7, #72]	; 0x48
   2c54a:	2b00      	cmp	r3, #0
   2c54c:	637d      	str	r5, [r7, #52]	; 0x34
   yy_lookup[0] = xx;
   2c54e:	f8c8 4000 	str.w	r4, [r8]
   for (i=1;i<=maxperiod;i++)
   2c552:	dd17      	ble.n	2c584 <remove_doubling+0xd8>
   2c554:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   opus_val32 xy01=0;
   2c556:	f8d7 c020 	ldr.w	ip, [r7, #32]
   2c55a:	461e      	mov	r6, r3
   2c55c:	eb03 0509 	add.w	r5, r3, r9
   2c560:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   2c562:	4644      	mov	r4, r8
   2c564:	2101      	movs	r1, #1
   {
      yy = yy+MULT16_16(x[-i],x[-i])-MULT16_16(x[N-i],x[N-i]);
   2c566:	f936 2d02 	ldrsh.w	r2, [r6, #-2]!
   2c56a:	f935 0d02 	ldrsh.w	r0, [r5, #-2]!
   2c56e:	fb02 3202 	mla	r2, r2, r2, r3
   2c572:	fb00 2310 	mls	r3, r0, r0, r2
   for (i=1;i<=maxperiod;i++)
   2c576:	3101      	adds	r1, #1
      yy_lookup[i] = MAX32(0, yy);
   2c578:	ea23 72e3 	bic.w	r2, r3, r3, asr #31
   for (i=1;i<=maxperiod;i++)
   2c57c:	458c      	cmp	ip, r1
      yy_lookup[i] = MAX32(0, yy);
   2c57e:	f844 2f04 	str.w	r2, [r4, #4]!
   for (i=1;i<=maxperiod;i++)
   2c582:	daf0      	bge.n	2c566 <remove_doubling+0xba>
   }
   yy = yy_lookup[T0];
   2c584:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   if (xy == 0 || xx == 0 || yy == 0)
   2c586:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   yy = yy_lookup[T0];
   2c588:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
   2c58c:	613b      	str	r3, [r7, #16]
   if (xy == 0 || xx == 0 || yy == 0)
   2c58e:	b11a      	cbz	r2, 2c598 <remove_doubling+0xec>
   2c590:	6cba      	ldr	r2, [r7, #72]	; 0x48
   2c592:	2a00      	cmp	r2, #0
   2c594:	f040 8139 	bne.w	2c80a <remove_doubling+0x35e>
   2c598:	617a      	str	r2, [r7, #20]
   2c59a:	61fa      	str	r2, [r7, #28]
   2c59c:	63ba      	str	r2, [r7, #56]	; 0x38
      return 0;
   2c59e:	633a      	str	r2, [r7, #48]	; 0x30
      else
         cont = 0;
      thresh = MAX16(QCONST16(.3f,15), MULT16_16_Q15(QCONST16(.7f,15),g0)-cont);
      /* Bias against very high pitch (very short period) to avoid false-positives
         due to short-term correlation */
      if (T1<3*minperiod)
   2c5a0:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
   2c5a2:	6d78      	ldr	r0, [r7, #84]	; 0x54
   2c5a4:	f1a9 0302 	sub.w	r3, r9, #2
   2c5a8:	004a      	lsls	r2, r1, #1
   2c5aa:	60bb      	str	r3, [r7, #8]
   2c5ac:	eb00 0903 	add.w	r9, r0, r3
   2c5b0:	1853      	adds	r3, r2, r1
   2c5b2:	643b      	str	r3, [r7, #64]	; 0x40
         cont = HALF16(prev_gain);
   2c5b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
      if (T1<3*minperiod)
   2c5b6:	61ba      	str	r2, [r7, #24]
         cont = HALF16(prev_gain);
   2c5b8:	105b      	asrs	r3, r3, #1
   2c5ba:	607b      	str	r3, [r7, #4]
         thresh = MAX16(QCONST16(.4f,15), MULT16_16_Q15(QCONST16(.85f,15),g0)-cont);
      else if (T1<2*minperiod)
   2c5bc:	693b      	ldr	r3, [r7, #16]
   2c5be:	62fb      	str	r3, [r7, #44]	; 0x2c
   T = T0 = *T0_;
   2c5c0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   2c5c2:	62bb      	str	r3, [r7, #40]	; 0x28
      else if (T1<2*minperiod)
   2c5c4:	221d      	movs	r2, #29
   for (k=2;k<=15;k++)
   2c5c6:	2602      	movs	r6, #2
   2c5c8:	0075      	lsls	r5, r6, #1
      t = EC_ILOG(d&-d);
   2c5ca:	f1c2 0220 	rsb	r2, r2, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   2c5ce:	fa25 f302 	lsr.w	r3, r5, r2
   2c5d2:	49b8      	ldr	r1, [pc, #736]	; (2c8b4 <remove_doubling+0x408>)
   2c5d4:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
   2c5d8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   2c5da:	3a01      	subs	r2, #1
   2c5dc:	199c      	adds	r4, r3, r6
   2c5de:	fa24 fa02 	lsr.w	sl, r4, r2
   2c5e2:	fbaa ab01 	umull	sl, fp, sl, r1
      return q+(n-q*d >= d);
   2c5e6:	fb05 441b 	mls	r4, r5, fp, r4
      if (T1 < minperiod)
   2c5ea:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   2c5ec:	42ac      	cmp	r4, r5
   2c5ee:	bf34      	ite	cc
   2c5f0:	465c      	movcc	r4, fp
   2c5f2:	f10b 0401 	addcs.w	r4, fp, #1
   2c5f6:	42a3      	cmp	r3, r4
   2c5f8:	f300 809e 	bgt.w	2c738 <remove_doubling+0x28c>
      if (k==2)
   2c5fc:	2e02      	cmp	r6, #2
   2c5fe:	f000 8142 	beq.w	2c886 <remove_doubling+0x3da>
         T1b = celt_udiv(2*second_check[k]*T0+k, 2*k);
   2c602:	4bad      	ldr	r3, [pc, #692]	; (2c8b8 <remove_doubling+0x40c>)
   2c604:	6db8      	ldr	r0, [r7, #88]	; 0x58
   2c606:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
   2c60a:	005b      	lsls	r3, r3, #1
   2c60c:	fb00 6303 	mla	r3, r0, r3, r6
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   2c610:	fa23 f002 	lsr.w	r0, r3, r2
   2c614:	fba0 0101 	umull	r0, r1, r0, r1
      return q+(n-q*d >= d);
   2c618:	fb05 3311 	mls	r3, r5, r1, r3
   2c61c:	42ab      	cmp	r3, r5
   2c61e:	bf34      	ite	cc
   2c620:	460b      	movcc	r3, r1
   2c622:	1c4b      	addcs	r3, r1, #1
   2c624:	f858 1023 	ldr.w	r1, [r8, r3, lsl #2]
   2c628:	f858 2024 	ldr.w	r2, [r8, r4, lsl #2]
   2c62c:	4411      	add	r1, r2
   2c62e:	1049      	asrs	r1, r1, #1
   2c630:	65f9      	str	r1, [r7, #92]	; 0x5c
   for (i=0;i<N;i++)
   2c632:	6d39      	ldr	r1, [r7, #80]	; 0x50
      dual_inner_prod(x, &x[-T1], &x[-T1b], N, &xy, &xy2, arch);
   2c634:	ebc3 73c3 	rsb	r3, r3, r3, lsl #31
   2c638:	ebc4 72c4 	rsb	r2, r4, r4, lsl #31
   2c63c:	2900      	cmp	r1, #0
   2c63e:	ea4f 0343 	mov.w	r3, r3, lsl #1
   2c642:	ea4f 0242 	mov.w	r2, r2, lsl #1
   2c646:	f340 80d3 	ble.w	2c7f0 <remove_doubling+0x344>
   2c64a:	6d79      	ldr	r1, [r7, #84]	; 0x54
   2c64c:	3a02      	subs	r2, #2
   2c64e:	3b02      	subs	r3, #2
   opus_val32 xy02=0;
   2c650:	f04f 0e00 	mov.w	lr, #0
   2c654:	440a      	add	r2, r1
   2c656:	440b      	add	r3, r1
   opus_val32 xy01=0;
   2c658:	4670      	mov	r0, lr
   2c65a:	3902      	subs	r1, #2
      xy01 = MAC16_16(xy01, x[i], y01[i]);
   2c65c:	f931 cf02 	ldrsh.w	ip, [r1, #2]!
   2c660:	f832 bf02 	ldrh.w	fp, [r2, #2]!
      xy02 = MAC16_16(xy02, x[i], y02[i]);
   2c664:	f833 af02 	ldrh.w	sl, [r3, #2]!
   for (i=0;i<N;i++)
   2c668:	4589      	cmp	r9, r1
      xy01 = MAC16_16(xy01, x[i], y01[i]);
   2c66a:	fb1c 000b 	smlabb	r0, ip, fp, r0
      xy02 = MAC16_16(xy02, x[i], y02[i]);
   2c66e:	fb1c ee0a 	smlabb	lr, ip, sl, lr
   for (i=0;i<N;i++)
   2c672:	d1f3      	bne.n	2c65c <remove_doubling+0x1b0>
      xy = HALF32(xy + xy2);
   2c674:	4470      	add	r0, lr
   if (xy == 0 || xx == 0 || yy == 0)
   2c676:	ea5f 0a60 	movs.w	sl, r0, asr #1
   2c67a:	d052      	beq.n	2c722 <remove_doubling+0x276>
   2c67c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   2c67e:	b10b      	cbz	r3, 2c684 <remove_doubling+0x1d8>
   2c680:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   2c682:	bb33      	cbnz	r3, 2c6d2 <remove_doubling+0x226>
   2c684:	4618      	mov	r0, r3
      if (abs(T1-prev_period)<=1)
   2c686:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   2c688:	1ae3      	subs	r3, r4, r3
   2c68a:	1c5a      	adds	r2, r3, #1
   2c68c:	2a02      	cmp	r2, #2
   2c68e:	d82a      	bhi.n	2c6e6 <remove_doubling+0x23a>
   2c690:	6a79      	ldr	r1, [r7, #36]	; 0x24
   2c692:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   2c694:	460a      	mov	r2, r1
   2c696:	1a5b      	subs	r3, r3, r1
      if (T1<3*minperiod)
   2c698:	6c39      	ldr	r1, [r7, #64]	; 0x40
   2c69a:	42a1      	cmp	r1, r4
   2c69c:	dd34      	ble.n	2c708 <remove_doubling+0x25c>
         thresh = MAX16(QCONST16(.4f,15), MULT16_16_Q15(QCONST16(.85f,15),g0)-cont);
   2c69e:	69fb      	ldr	r3, [r7, #28]
   2c6a0:	1a9b      	subs	r3, r3, r2
   2c6a2:	f243 3233 	movw	r2, #13107	; 0x3333
   2c6a6:	4293      	cmp	r3, r2
   2c6a8:	bfb8      	it	lt
   2c6aa:	4613      	movlt	r3, r2
   2c6ac:	b21b      	sxth	r3, r3
         thresh = MAX16(QCONST16(.5f,15), MULT16_16_Q15(QCONST16(.9f,15),g0)-cont);
      if (g1 > thresh)
   2c6ae:	4283      	cmp	r3, r0
   2c6b0:	da04      	bge.n	2c6bc <remove_doubling+0x210>
   2c6b2:	e9c7 0a0c 	strd	r0, sl, [r7, #48]	; 0x30
   2c6b6:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   2c6b8:	62fb      	str	r3, [r7, #44]	; 0x2c
   2c6ba:	62bc      	str	r4, [r7, #40]	; 0x28
   for (k=2;k<=15;k++)
   2c6bc:	3601      	adds	r6, #1
   2c6be:	2e10      	cmp	r6, #16
   2c6c0:	d03a      	beq.n	2c738 <remove_doubling+0x28c>
   2c6c2:	3502      	adds	r5, #2
   2c6c4:	ebc6 73c6 	rsb	r3, r6, r6, lsl #31
   2c6c8:	ea05 0543 	and.w	r5, r5, r3, lsl #1
   2c6cc:	fab5 f285 	clz	r2, r5
   2c6d0:	e77a      	b.n	2c5c8 <remove_doubling+0x11c>
   2c6d2:	461a      	mov	r2, r3
   2c6d4:	6cb9      	ldr	r1, [r7, #72]	; 0x48
   2c6d6:	4650      	mov	r0, sl
   2c6d8:	f7ff fab4 	bl	2bc44 <compute_pitch_gain.part.1>
      if (abs(T1-prev_period)<=1)
   2c6dc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   2c6de:	1ae3      	subs	r3, r4, r3
   2c6e0:	1c5a      	adds	r2, r3, #1
   2c6e2:	2a02      	cmp	r2, #2
   2c6e4:	d9d4      	bls.n	2c690 <remove_doubling+0x1e4>
      else if (abs(T1-prev_period)<=2 && 5*k*k < T0)
   2c6e6:	3302      	adds	r3, #2
   2c6e8:	2b04      	cmp	r3, #4
   2c6ea:	d817      	bhi.n	2c71c <remove_doubling+0x270>
   2c6ec:	eb06 0386 	add.w	r3, r6, r6, lsl #2
   2c6f0:	6dba      	ldr	r2, [r7, #88]	; 0x58
   2c6f2:	fb06 f303 	mul.w	r3, r6, r3
   2c6f6:	4293      	cmp	r3, r2
   2c6f8:	da10      	bge.n	2c71c <remove_doubling+0x270>
   2c6fa:	6879      	ldr	r1, [r7, #4]
   2c6fc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   2c6fe:	460a      	mov	r2, r1
   2c700:	1a5b      	subs	r3, r3, r1
      if (T1<3*minperiod)
   2c702:	6c39      	ldr	r1, [r7, #64]	; 0x40
   2c704:	42a1      	cmp	r1, r4
   2c706:	dcca      	bgt.n	2c69e <remove_doubling+0x1f2>
      else if (T1<2*minperiod)
   2c708:	69b9      	ldr	r1, [r7, #24]
   2c70a:	42a1      	cmp	r1, r4
   2c70c:	dc0b      	bgt.n	2c726 <remove_doubling+0x27a>
      thresh = MAX16(QCONST16(.3f,15), MULT16_16_Q15(QCONST16(.7f,15),g0)-cont);
   2c70e:	f242 6266 	movw	r2, #9830	; 0x2666
   2c712:	4293      	cmp	r3, r2
   2c714:	bfb8      	it	lt
   2c716:	4613      	movlt	r3, r2
   2c718:	b21b      	sxth	r3, r3
   2c71a:	e7c8      	b.n	2c6ae <remove_doubling+0x202>
   2c71c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   2c71e:	2200      	movs	r2, #0
   2c720:	e7ba      	b.n	2c698 <remove_doubling+0x1ec>
      return 0;
   2c722:	4650      	mov	r0, sl
   2c724:	e7af      	b.n	2c686 <remove_doubling+0x1da>
         thresh = MAX16(QCONST16(.5f,15), MULT16_16_Q15(QCONST16(.9f,15),g0)-cont);
   2c726:	697b      	ldr	r3, [r7, #20]
   2c728:	1a9b      	subs	r3, r3, r2
   2c72a:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
   2c72e:	bfb8      	it	lt
   2c730:	f44f 4380 	movlt.w	r3, #16384	; 0x4000
   2c734:	b21b      	sxth	r3, r3
   2c736:	e7ba      	b.n	2c6ae <remove_doubling+0x202>
         best_yy = yy;
         T = T1;
         g = g1;
      }
   }
   best_xy = MAX32(0, best_xy);
   2c738:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   2c73a:	ea23 70e3 	bic.w	r0, r3, r3, asr #31
   if (best_yy <= best_xy)
   2c73e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   2c740:	4298      	cmp	r0, r3
   2c742:	db6f      	blt.n	2c824 <remove_doubling+0x378>
   2c744:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2c746:	68ba      	ldr	r2, [r7, #8]
   2c748:	f8d7 9050 	ldr.w	r9, [r7, #80]	; 0x50
   2c74c:	ebc3 75c3 	rsb	r5, r3, r3, lsl #31
   2c750:	005e      	lsls	r6, r3, #1
   2c752:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   2c754:	4690      	mov	r8, r2
   2c756:	f1a3 0c06 	sub.w	ip, r3, #6
   2c75a:	4498      	add	r8, r3
   2c75c:	eb03 0545 	add.w	r5, r3, r5, lsl #1
   2c760:	ebac 0c06 	sub.w	ip, ip, r6
   2c764:	f107 0e64 	add.w	lr, r7, #100	; 0x64
   2c768:	469a      	mov	sl, r3
   for (i=0;i<N;i++)
   2c76a:	f1b9 0f00 	cmp.w	r9, #0
   2c76e:	dd52      	ble.n	2c816 <remove_doubling+0x36a>
   2c770:	f1aa 0302 	sub.w	r3, sl, #2
   2c774:	4629      	mov	r1, r5
   opus_val32 xy=0;
   2c776:	2200      	movs	r2, #0
      xy = MAC16_16(xy, x[i], y[i]);
   2c778:	f833 4f02 	ldrh.w	r4, [r3, #2]!
   2c77c:	f831 0f02 	ldrh.w	r0, [r1, #2]!
   for (i=0;i<N;i++)
   2c780:	4598      	cmp	r8, r3
      xy = MAC16_16(xy, x[i], y[i]);
   2c782:	fb14 2200 	smlabb	r2, r4, r0, r2
   for (i=0;i<N;i++)
   2c786:	d1f7      	bne.n	2c778 <remove_doubling+0x2cc>
   2c788:	3d02      	subs	r5, #2
      pg = Q15ONE;
   else
      pg = SHR32(frac_div32(best_xy,best_yy+1),16);

   for (k=0;k<3;k++)
   2c78a:	45ac      	cmp	ip, r5
      xcorr[k] = celt_inner_prod(x, x-(T+k-1), N, arch);
   2c78c:	f84e 2b04 	str.w	r2, [lr], #4
   for (k=0;k<3;k++)
   2c790:	d1eb      	bne.n	2c76a <remove_doubling+0x2be>
   if ((xcorr[2]-xcorr[0]) > MULT16_32_Q15(QCONST16(.7f,15),xcorr[1]-xcorr[0]))
   2c792:	e9d7 1419 	ldrd	r1, r4, [r7, #100]	; 0x64
   2c796:	1a62      	subs	r2, r4, r1
   2c798:	b293      	uxth	r3, r2
   2c79a:	f645 109a 	movw	r0, #22938	; 0x599a
   2c79e:	6efd      	ldr	r5, [r7, #108]	; 0x6c
   2c7a0:	1412      	asrs	r2, r2, #16
   2c7a2:	fb00 f303 	mul.w	r3, r0, r3
   2c7a6:	fb00 f202 	mul.w	r2, r0, r2
   2c7aa:	13db      	asrs	r3, r3, #15
   2c7ac:	eb03 0342 	add.w	r3, r3, r2, lsl #1
   2c7b0:	1a6a      	subs	r2, r5, r1
   2c7b2:	429a      	cmp	r2, r3
   2c7b4:	dc27      	bgt.n	2c806 <remove_doubling+0x35a>
      offset = 1;
   else if ((xcorr[0]-xcorr[2]) > MULT16_32_Q15(QCONST16(.7f,15),xcorr[1]-xcorr[2]))
   2c7b6:	1b64      	subs	r4, r4, r5
   2c7b8:	b2a2      	uxth	r2, r4
   2c7ba:	fb00 f202 	mul.w	r2, r0, r2
   2c7be:	1424      	asrs	r4, r4, #16
   2c7c0:	13d2      	asrs	r2, r2, #15
   2c7c2:	fb00 f004 	mul.w	r0, r0, r4
   2c7c6:	1b4b      	subs	r3, r1, r5
   2c7c8:	eb02 0040 	add.w	r0, r2, r0, lsl #1
   2c7cc:	4283      	cmp	r3, r0
   2c7ce:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2c7d2:	bfd8      	it	le
   2c7d4:	2300      	movle	r3, #0
      offset = -1;
   else
      offset = 0;
   if (pg > g)
      pg = g;
   *T0_ = 2*T+offset;
   2c7d6:	441e      	add	r6, r3
   2c7d8:	68fb      	ldr	r3, [r7, #12]

   if (*T0_<minperiod0)
      *T0_=minperiod0;
   RESTORE_STACK;
   return pg;
}
   2c7da:	6b38      	ldr	r0, [r7, #48]	; 0x30
   2c7dc:	429e      	cmp	r6, r3
   2c7de:	bfb8      	it	lt
   2c7e0:	461e      	movlt	r6, r3
   2c7e2:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
   2c7e6:	3774      	adds	r7, #116	; 0x74
   2c7e8:	601e      	str	r6, [r3, #0]
   2c7ea:	46bd      	mov	sp, r7
   2c7ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      xy = HALF32(xy + xy2);
   2c7f0:	f04f 0a00 	mov.w	sl, #0
      return 0;
   2c7f4:	4650      	mov	r0, sl
   2c7f6:	e746      	b.n	2c686 <remove_doubling+0x1da>
      *T0_=maxperiod-1;
   2c7f8:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
   2c7fc:	1e4b      	subs	r3, r1, #1
   2c7fe:	65bb      	str	r3, [r7, #88]	; 0x58
   2c800:	6013      	str	r3, [r2, #0]
   2c802:	6a3b      	ldr	r3, [r7, #32]
   2c804:	e67c      	b.n	2c500 <remove_doubling+0x54>
      offset = 1;
   2c806:	2301      	movs	r3, #1
   2c808:	e7e5      	b.n	2c7d6 <remove_doubling+0x32a>
   if (xy == 0 || xx == 0 || yy == 0)
   2c80a:	b9bb      	cbnz	r3, 2c83c <remove_doubling+0x390>
   2c80c:	617b      	str	r3, [r7, #20]
   2c80e:	61fb      	str	r3, [r7, #28]
   2c810:	63bb      	str	r3, [r7, #56]	; 0x38
      return 0;
   2c812:	633b      	str	r3, [r7, #48]	; 0x30
   2c814:	e6c4      	b.n	2c5a0 <remove_doubling+0xf4>
   2c816:	3d02      	subs	r5, #2
   opus_val32 xy=0;
   2c818:	2200      	movs	r2, #0
   for (k=0;k<3;k++)
   2c81a:	45ac      	cmp	ip, r5
      xcorr[k] = celt_inner_prod(x, x-(T+k-1), N, arch);
   2c81c:	f84e 2b04 	str.w	r2, [lr], #4
   for (k=0;k<3;k++)
   2c820:	d1a3      	bne.n	2c76a <remove_doubling+0x2be>
   2c822:	e7b6      	b.n	2c792 <remove_doubling+0x2e6>
      pg = SHR32(frac_div32(best_xy,best_yy+1),16);
   2c824:	4619      	mov	r1, r3
   2c826:	3101      	adds	r1, #1
   2c828:	f7fe fd6c 	bl	2b304 <frac_div32>
   2c82c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   2c82e:	1400      	asrs	r0, r0, #16
   2c830:	4298      	cmp	r0, r3
   2c832:	bfa8      	it	ge
   2c834:	4618      	movge	r0, r3
   2c836:	b203      	sxth	r3, r0
   2c838:	633b      	str	r3, [r7, #48]	; 0x30
   2c83a:	e783      	b.n	2c744 <remove_doubling+0x298>
   2c83c:	4611      	mov	r1, r2
   2c83e:	6b78      	ldr	r0, [r7, #52]	; 0x34
   2c840:	461a      	mov	r2, r3
   2c842:	f7ff f9ff 	bl	2bc44 <compute_pitch_gain.part.1>
   2c846:	f645 119a 	movw	r1, #22938	; 0x599a
   2c84a:	f646 42cd 	movw	r2, #27853	; 0x6ccd
   2c84e:	f247 3333 	movw	r3, #29491	; 0x7333
   2c852:	fb10 f101 	smulbb	r1, r0, r1
   2c856:	fb10 f202 	smulbb	r2, r0, r2
   2c85a:	fb10 f303 	smulbb	r3, r0, r3
   2c85e:	13c9      	asrs	r1, r1, #15
   2c860:	13d2      	asrs	r2, r2, #15
   2c862:	13db      	asrs	r3, r3, #15
   2c864:	6338      	str	r0, [r7, #48]	; 0x30
   2c866:	63b9      	str	r1, [r7, #56]	; 0x38
   2c868:	61fa      	str	r2, [r7, #28]
   2c86a:	617b      	str	r3, [r7, #20]
   2c86c:	e698      	b.n	2c5a0 <remove_doubling+0xf4>
   for (i=1;i<=maxperiod;i++)
   2c86e:	6a3b      	ldr	r3, [r7, #32]
   yy_lookup[0] = xx;
   2c870:	2000      	movs	r0, #0
   for (i=1;i<=maxperiod;i++)
   2c872:	4283      	cmp	r3, r0
   yy_lookup[0] = xx;
   2c874:	f8c8 0000 	str.w	r0, [r8]
   for (i=1;i<=maxperiod;i++)
   2c878:	dd0e      	ble.n	2c898 <remove_doubling+0x3ec>
   2c87a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   opus_val32 xy02=0;
   2c87c:	6378      	str	r0, [r7, #52]	; 0x34
   opus_val32 xy01=0;
   2c87e:	64b8      	str	r0, [r7, #72]	; 0x48
   2c880:	ea4f 0943 	mov.w	r9, r3, lsl #1
   2c884:	e666      	b.n	2c554 <remove_doubling+0xa8>
         if (T1+T0>maxperiod)
   2c886:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   2c888:	6a3a      	ldr	r2, [r7, #32]
   2c88a:	18e3      	adds	r3, r4, r3
   2c88c:	4293      	cmp	r3, r2
   2c88e:	f77f aec9 	ble.w	2c624 <remove_doubling+0x178>
   2c892:	6939      	ldr	r1, [r7, #16]
   2c894:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   2c896:	e6c7      	b.n	2c628 <remove_doubling+0x17c>
   yy = yy_lookup[T0];
   2c898:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   2c89a:	6178      	str	r0, [r7, #20]
   2c89c:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
   2c8a0:	613b      	str	r3, [r7, #16]
   2c8a2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   2c8a4:	61f8      	str	r0, [r7, #28]
   2c8a6:	63b8      	str	r0, [r7, #56]	; 0x38
   2c8a8:	64b8      	str	r0, [r7, #72]	; 0x48
      return 0;
   2c8aa:	e9c7 000c 	strd	r0, r0, [r7, #48]	; 0x30
   2c8ae:	ea4f 0943 	mov.w	r9, r3, lsl #1
   2c8b2:	e675      	b.n	2c5a0 <remove_doubling+0xf4>
   2c8b4:	00038e98 	.word	0x00038e98
   2c8b8:	0003b3dc 	.word	0x0003b3dc

0002c8bc <_celt_lpc>:
void _celt_lpc(
      opus_val16       *_lpc, /* out: [0...p-1] LPC coefficients      */
const opus_val32 *ac,  /* in:  [0...p] autocorrelation values  */
int          p
)
{
   2c8bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2c8c0:	b09d      	sub	sp, #116	; 0x74
   int i, j;
   opus_val32 r;
   opus_val32 error = ac[0];
   2c8c2:	680f      	ldr	r7, [r1, #0]
{
   2c8c4:	9102      	str	r1, [sp, #8]
   2c8c6:	460d      	mov	r5, r1
   2c8c8:	4614      	mov	r4, r2
   2c8ca:	9201      	str	r2, [sp, #4]
   2c8cc:	9003      	str	r0, [sp, #12]
   opus_val32 lpc[LPC_ORDER];
#else
   float *lpc = _lpc;
#endif

   OPUS_CLEAR(lpc, p);
   2c8ce:	0092      	lsls	r2, r2, #2
   2c8d0:	a804      	add	r0, sp, #16
   2c8d2:	2100      	movs	r1, #0
   2c8d4:	f008 fc46 	bl	35164 <memset>
   if (ac[0] != 0)
   2c8d8:	2f00      	cmp	r7, #0
   2c8da:	f000 808c 	beq.w	2c9f6 <_celt_lpc+0x13a>
   {
      for (i = 0; i < p; i++) {
   2c8de:	2c00      	cmp	r4, #0
   2c8e0:	f340 808c 	ble.w	2c9fc <_celt_lpc+0x140>
   2c8e4:	f105 0804 	add.w	r8, r5, #4
   2c8e8:	f04f 0900 	mov.w	r9, #0
   2c8ec:	f8cd 8000 	str.w	r8, [sp]
         /* Sum up this iteration's reflection coefficient */
         opus_val32 rr = 0;
   2c8f0:	4648      	mov	r0, r9
      for (i = 0; i < p; i++) {
   2c8f2:	ac04      	add	r4, sp, #16
   2c8f4:	4642      	mov	r2, r8
         for (j = 0; j < i; j++)
            rr += MULT32_32_Q31(lpc[j],ac[i - j]);
         rr += SHR32(ac[i + 1],3);
   2c8f6:	f852 3b04 	ldr.w	r3, [r2], #4
   2c8fa:	9200      	str	r2, [sp, #0]
   2c8fc:	eb00 00e3 	add.w	r0, r0, r3, asr #3
         r = -frac_div32(SHL32(rr,3), error);
   2c900:	00c0      	lsls	r0, r0, #3
   2c902:	4639      	mov	r1, r7
   2c904:	f7fe fcfe 	bl	2b304 <frac_div32>
         /*  Update LPC coefficients and total error */
         lpc[i] = SHR32(r,3);
   2c908:	46a2      	mov	sl, r4
         r = -frac_div32(SHL32(rr,3), error);
   2c90a:	4240      	negs	r0, r0
         for (j = 0; j < (i+1)>>1; j++)
   2c90c:	f109 0901 	add.w	r9, r9, #1
         lpc[i] = SHR32(r,3);
   2c910:	10c3      	asrs	r3, r0, #3
         for (j = 0; j < (i+1)>>1; j++)
   2c912:	ea5f 0b69 	movs.w	fp, r9, asr #1
   2c916:	ea4f 4620 	mov.w	r6, r0, asr #16
         lpc[i] = SHR32(r,3);
   2c91a:	f84a 3b04 	str.w	r3, [sl], #4
   2c91e:	b280      	uxth	r0, r0
         for (j = 0; j < (i+1)>>1; j++)
   2c920:	d02b      	beq.n	2c97a <_celt_lpc+0xbe>
   2c922:	ab04      	add	r3, sp, #16
   2c924:	f1a4 0e04 	sub.w	lr, r4, #4
   2c928:	eb03 0b8b 	add.w	fp, r3, fp, lsl #2
   2c92c:	469c      	mov	ip, r3
         {
            opus_val32 tmp1, tmp2;
            tmp1 = lpc[j];
            tmp2 = lpc[i-1-j];
   2c92e:	f8de 1000 	ldr.w	r1, [lr]
            tmp1 = lpc[j];
   2c932:	f8dc 3000 	ldr.w	r3, [ip]
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
   2c936:	140d      	asrs	r5, r1, #16
   2c938:	fb06 f405 	mul.w	r4, r6, r5
   2c93c:	b28a      	uxth	r2, r1
   2c93e:	0064      	lsls	r4, r4, #1
   2c940:	fb06 f202 	mul.w	r2, r6, r2
   2c944:	fb00 f505 	mul.w	r5, r0, r5
   2c948:	eb04 32e2 	add.w	r2, r4, r2, asr #15
   2c94c:	eb02 32e5 	add.w	r2, r2, r5, asr #15
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
   2c950:	141c      	asrs	r4, r3, #16
   2c952:	b29d      	uxth	r5, r3
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
   2c954:	441a      	add	r2, r3
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
   2c956:	fb06 f304 	mul.w	r3, r6, r4
   2c95a:	fb06 f505 	mul.w	r5, r6, r5
   2c95e:	005b      	lsls	r3, r3, #1
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
   2c960:	f84c 2b04 	str.w	r2, [ip], #4
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
   2c964:	eb03 33e5 	add.w	r3, r3, r5, asr #15
   2c968:	fb00 f404 	mul.w	r4, r0, r4
   2c96c:	eb03 33e4 	add.w	r3, r3, r4, asr #15
   2c970:	440b      	add	r3, r1
         for (j = 0; j < (i+1)>>1; j++)
   2c972:	45e3      	cmp	fp, ip
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
   2c974:	f84e 3904 	str.w	r3, [lr], #-4
         for (j = 0; j < (i+1)>>1; j++)
   2c978:	d1d9      	bne.n	2c92e <_celt_lpc+0x72>
         }

         error = error - MULT32_32_Q31(MULT32_32_Q31(r,r),error);
   2c97a:	fb00 f006 	mul.w	r0, r0, r6
   2c97e:	13c0      	asrs	r0, r0, #15
   2c980:	fb06 0206 	mla	r2, r6, r6, r0
   2c984:	1439      	asrs	r1, r7, #16
   2c986:	f342 32cf 	sbfx	r2, r2, #15, #16
   2c98a:	fb06 0606 	mla	r6, r6, r6, r0
   2c98e:	fb01 f302 	mul.w	r3, r1, r2
   2c992:	b2b8      	uxth	r0, r7
   2c994:	0076      	lsls	r6, r6, #1
   2c996:	b2b6      	uxth	r6, r6
   2c998:	005b      	lsls	r3, r3, #1
   2c99a:	fb02 f200 	mul.w	r2, r2, r0
   2c99e:	fb01 f106 	mul.w	r1, r1, r6
   2c9a2:	eb03 36e2 	add.w	r6, r3, r2, asr #15
         /* Bail out once we get 30 dB gain */
#ifdef FIXED_POINT
         if (error<SHR32(ac[0],10))
   2c9a6:	9b02      	ldr	r3, [sp, #8]
         error = error - MULT32_32_Q31(MULT32_32_Q31(r,r),error);
   2c9a8:	eb06 36e1 	add.w	r6, r6, r1, asr #15
         if (error<SHR32(ac[0],10))
   2c9ac:	681b      	ldr	r3, [r3, #0]
         error = error - MULT32_32_Q31(MULT32_32_Q31(r,r),error);
   2c9ae:	1bbf      	subs	r7, r7, r6
         if (error<SHR32(ac[0],10))
   2c9b0:	ebb7 2fa3 	cmp.w	r7, r3, asr #10
   2c9b4:	db25      	blt.n	2ca02 <_celt_lpc+0x146>
      for (i = 0; i < p; i++) {
   2c9b6:	9b01      	ldr	r3, [sp, #4]
   2c9b8:	4599      	cmp	r9, r3
   2c9ba:	d022      	beq.n	2ca02 <_celt_lpc+0x146>
   2c9bc:	9e00      	ldr	r6, [sp, #0]
   2c9be:	f10d 0c10 	add.w	ip, sp, #16
         opus_val32 rr = 0;
   2c9c2:	2000      	movs	r0, #0
            rr += MULT32_32_Q31(lpc[j],ac[i - j]);
   2c9c4:	f856 5d04 	ldr.w	r5, [r6, #-4]!
   2c9c8:	f85c 1b04 	ldr.w	r1, [ip], #4
   2c9cc:	142a      	asrs	r2, r5, #16
   2c9ce:	140c      	asrs	r4, r1, #16
   2c9d0:	fb02 f304 	mul.w	r3, r2, r4
   2c9d4:	b2ad      	uxth	r5, r5
   2c9d6:	b289      	uxth	r1, r1
   2c9d8:	fb04 f405 	mul.w	r4, r4, r5
   2c9dc:	005b      	lsls	r3, r3, #1
   2c9de:	eb03 33e4 	add.w	r3, r3, r4, asr #15
   2c9e2:	fb02 f201 	mul.w	r2, r2, r1
   2c9e6:	eb03 33e2 	add.w	r3, r3, r2, asr #15
         for (j = 0; j < i; j++)
   2c9ea:	45b0      	cmp	r8, r6
            rr += MULT32_32_Q31(lpc[j],ac[i - j]);
   2c9ec:	4418      	add	r0, r3
         for (j = 0; j < i; j++)
   2c9ee:	d1e9      	bne.n	2c9c4 <_celt_lpc+0x108>
   2c9f0:	4654      	mov	r4, sl
   2c9f2:	9a00      	ldr	r2, [sp, #0]
   2c9f4:	e77f      	b.n	2c8f6 <_celt_lpc+0x3a>
            break;
#endif
      }
   }
#ifdef FIXED_POINT
   for (i=0;i<p;i++)
   2c9f6:	9b01      	ldr	r3, [sp, #4]
   2c9f8:	2b00      	cmp	r3, #0
   2c9fa:	dc02      	bgt.n	2ca02 <_celt_lpc+0x146>
      _lpc[i] = ROUND16(lpc[i],16);
#endif
}
   2c9fc:	b01d      	add	sp, #116	; 0x74
   2c9fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2ca02:	9b03      	ldr	r3, [sp, #12]
         for (j = 0; j < (i+1)>>1; j++)
   2ca04:	9c01      	ldr	r4, [sp, #4]
   2ca06:	aa04      	add	r2, sp, #16
   2ca08:	1e98      	subs	r0, r3, #2
   2ca0a:	2100      	movs	r1, #0
      _lpc[i] = ROUND16(lpc[i],16);
   2ca0c:	f852 3b04 	ldr.w	r3, [r2], #4
   for (i=0;i<p;i++)
   2ca10:	3101      	adds	r1, #1
      _lpc[i] = ROUND16(lpc[i],16);
   2ca12:	f503 4300 	add.w	r3, r3, #32768	; 0x8000
   2ca16:	141b      	asrs	r3, r3, #16
   for (i=0;i<p;i++)
   2ca18:	428c      	cmp	r4, r1
      _lpc[i] = ROUND16(lpc[i],16);
   2ca1a:	f820 3f02 	strh.w	r3, [r0, #2]!
   for (i=0;i<p;i++)
   2ca1e:	dcf5      	bgt.n	2ca0c <_celt_lpc+0x150>
}
   2ca20:	b01d      	add	sp, #116	; 0x74
   2ca22:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2ca26:	bf00      	nop

0002ca28 <_celt_autocorr>:
                   int          overlap,
                   int          lag,
                   int          n,
                   int          arch
                  )
{
   2ca28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2ca2c:	b085      	sub	sp, #20
   2ca2e:	af02      	add	r7, sp, #8
   2ca30:	4691      	mov	r9, r2
   2ca32:	6b7d      	ldr	r5, [r7, #52]	; 0x34
   opus_val32 d;
   int i, k;
   int fastN=n-lag;
   2ca34:	6b3a      	ldr	r2, [r7, #48]	; 0x30
{
   2ca36:	6079      	str	r1, [r7, #4]
   int shift;
   const opus_val16 *xptr;
   VARDECL(opus_val16, xx);
   SAVE_STACK;
   ALLOC(xx, n, opus_val16);
   2ca38:	006c      	lsls	r4, r5, #1
   2ca3a:	f104 0608 	add.w	r6, r4, #8
   2ca3e:	f026 0607 	bic.w	r6, r6, #7
   2ca42:	ebad 0d06 	sub.w	sp, sp, r6
{
   2ca46:	4680      	mov	r8, r0
   ALLOC(xx, n, opus_val16);
   2ca48:	ae02      	add	r6, sp, #8
   int fastN=n-lag;
   2ca4a:	eba5 0b02 	sub.w	fp, r5, r2
   celt_assert(n>0);
   celt_assert(overlap>=0);
   if (overlap == 0)
   2ca4e:	b34b      	cbz	r3, 2caa4 <_celt_autocorr+0x7c>
   {
      xptr = x;
   } else {
      for (i=0;i<n;i++)
   2ca50:	2d00      	cmp	r5, #0
   2ca52:	469a      	mov	sl, r3
   2ca54:	dd04      	ble.n	2ca60 <_celt_autocorr+0x38>
   2ca56:	4601      	mov	r1, r0
   2ca58:	4622      	mov	r2, r4
   2ca5a:	4630      	mov	r0, r6
   2ca5c:	f7df fb50 	bl	c100 <memcpy>
         xx[i] = x[i];
      for (i=0;i<overlap;i++)
   2ca60:	f1ba 0f00 	cmp.w	sl, #0
   2ca64:	dd1d      	ble.n	2caa2 <_celt_autocorr+0x7a>
   2ca66:	f1a8 0002 	sub.w	r0, r8, #2
   2ca6a:	f1a4 0c02 	sub.w	ip, r4, #2
   2ca6e:	f1a9 0902 	sub.w	r9, r9, #2
   2ca72:	eb00 0a4a 	add.w	sl, r0, sl, lsl #1
   2ca76:	44a0      	add	r8, r4
   2ca78:	44b4      	add	ip, r6
   2ca7a:	f1a6 0e02 	sub.w	lr, r6, #2
      {
         xx[i] = MULT16_16_Q15(x[i],window[i]);
   2ca7e:	f939 1f02 	ldrsh.w	r1, [r9, #2]!
   2ca82:	f830 2f02 	ldrh.w	r2, [r0, #2]!
         xx[n-i-1] = MULT16_16_Q15(x[n-i-1],window[i]);
   2ca86:	f838 3d02 	ldrh.w	r3, [r8, #-2]!
         xx[i] = MULT16_16_Q15(x[i],window[i]);
   2ca8a:	fb12 f201 	smulbb	r2, r2, r1
         xx[n-i-1] = MULT16_16_Q15(x[n-i-1],window[i]);
   2ca8e:	fb13 f301 	smulbb	r3, r3, r1
         xx[i] = MULT16_16_Q15(x[i],window[i]);
   2ca92:	13d2      	asrs	r2, r2, #15
         xx[n-i-1] = MULT16_16_Q15(x[n-i-1],window[i]);
   2ca94:	13db      	asrs	r3, r3, #15
      for (i=0;i<overlap;i++)
   2ca96:	4582      	cmp	sl, r0
         xx[i] = MULT16_16_Q15(x[i],window[i]);
   2ca98:	f82e 2f02 	strh.w	r2, [lr, #2]!
         xx[n-i-1] = MULT16_16_Q15(x[n-i-1],window[i]);
   2ca9c:	f82c 3902 	strh.w	r3, [ip], #-2
      for (i=0;i<overlap;i++)
   2caa0:	d1ed      	bne.n	2ca7e <_celt_autocorr+0x56>
   ALLOC(xx, n, opus_val16);
   2caa2:	46b0      	mov	r8, r6
   }
   shift=0;
#ifdef FIXED_POINT
   {
      opus_val32 ac0;
      ac0 = 1+(n<<7);
   2caa4:	01e9      	lsls	r1, r5, #7
      if (n&1) ac0 += SHR32(MULT16_16(xptr[0],xptr[0]),9);
   2caa6:	f015 0001 	ands.w	r0, r5, #1
      ac0 = 1+(n<<7);
   2caaa:	f101 0101 	add.w	r1, r1, #1
      if (n&1) ac0 += SHR32(MULT16_16(xptr[0],xptr[0]),9);
   2caae:	d005      	beq.n	2cabc <_celt_autocorr+0x94>
   2cab0:	f9b8 3000 	ldrsh.w	r3, [r8]
   2cab4:	fb03 f303 	mul.w	r3, r3, r3
   2cab8:	eb01 2163 	add.w	r1, r1, r3, asr #9
      for(i=(n&1);i<n;i+=2)
   2cabc:	42a8      	cmp	r0, r5
   2cabe:	da1c      	bge.n	2cafa <_celt_autocorr+0xd2>
   2cac0:	f105 3cff 	add.w	ip, r5, #4294967295	; 0xffffffff
   2cac4:	ebac 0c00 	sub.w	ip, ip, r0
   2cac8:	f02c 0c01 	bic.w	ip, ip, #1
   2cacc:	eb0c 0300 	add.w	r3, ip, r0
   2cad0:	f108 0c04 	add.w	ip, r8, #4
   2cad4:	eb08 0040 	add.w	r0, r8, r0, lsl #1
   2cad8:	eb0c 0c43 	add.w	ip, ip, r3, lsl #1
      {
         ac0 += SHR32(MULT16_16(xptr[i],xptr[i]),9);
   2cadc:	f9b0 2000 	ldrsh.w	r2, [r0]
         ac0 += SHR32(MULT16_16(xptr[i+1],xptr[i+1]),9);
   2cae0:	f9b0 3002 	ldrsh.w	r3, [r0, #2]
         ac0 += SHR32(MULT16_16(xptr[i],xptr[i]),9);
   2cae4:	fb02 f202 	mul.w	r2, r2, r2
   2cae8:	3004      	adds	r0, #4
   2caea:	eb01 2262 	add.w	r2, r1, r2, asr #9
         ac0 += SHR32(MULT16_16(xptr[i+1],xptr[i+1]),9);
   2caee:	fb03 f303 	mul.w	r3, r3, r3
      for(i=(n&1);i<n;i+=2)
   2caf2:	4584      	cmp	ip, r0
         ac0 += SHR32(MULT16_16(xptr[i+1],xptr[i+1]),9);
   2caf4:	eb02 2163 	add.w	r1, r2, r3, asr #9
      for(i=(n&1);i<n;i+=2)
   2caf8:	d1f0      	bne.n	2cadc <_celt_autocorr+0xb4>
   return EC_ILOG(x)-1;
   2cafa:	fab1 f181 	clz	r1, r1
      }

      shift = celt_ilog2(ac0)-30+10;
   2cafe:	f1c1 000b 	rsb	r0, r1, #11
      shift = (shift)/2;
   2cb02:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
   2cb06:	ea4f 0960 	mov.w	r9, r0, asr #1
   2cb0a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
      if (shift>0)
   2cb0c:	f1b9 0f00 	cmp.w	r9, #0
   2cb10:	f103 0c01 	add.w	ip, r3, #1
   2cb14:	f340 8092 	ble.w	2cc3c <_celt_autocorr+0x214>
      {
         for(i=0;i<n;i++)
   2cb18:	2d00      	cmp	r5, #0
   2cb1a:	dd11      	ble.n	2cb40 <_celt_autocorr+0x118>
            xx[i] = PSHR32(xptr[i], shift);
   2cb1c:	2001      	movs	r0, #1
   2cb1e:	fa00 f009 	lsl.w	r0, r0, r9
   2cb22:	1ea1      	subs	r1, r4, #2
   2cb24:	4441      	add	r1, r8
   2cb26:	1040      	asrs	r0, r0, #1
   2cb28:	f1a8 0802 	sub.w	r8, r8, #2
   2cb2c:	1eb2      	subs	r2, r6, #2
   2cb2e:	f938 3f02 	ldrsh.w	r3, [r8, #2]!
   2cb32:	4403      	add	r3, r0
   2cb34:	fa43 f309 	asr.w	r3, r3, r9
         for(i=0;i<n;i++)
   2cb38:	4541      	cmp	r1, r8
            xx[i] = PSHR32(xptr[i], shift);
   2cb3a:	f822 3f02 	strh.w	r3, [r2, #2]!
         for(i=0;i<n;i++)
   2cb3e:	d1f6      	bne.n	2cb2e <_celt_autocorr+0x106>
         xptr = xx;
      } else
         shift = 0;
   }
#endif
   celt_pitch_xcorr(xptr, xptr, ac, fastN, lag+1, arch);
   2cb40:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   2cb42:	687a      	ldr	r2, [r7, #4]
   2cb44:	e9cd c300 	strd	ip, r3, [sp]
   2cb48:	4631      	mov	r1, r6
   2cb4a:	465b      	mov	r3, fp
   2cb4c:	4630      	mov	r0, r6
   2cb4e:	f7ff fa1b 	bl	2bf88 <celt_pitch_xcorr_c>
   for (k=0;k<=lag;k++)
   2cb52:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   2cb54:	2b00      	cmp	r3, #0
   2cb56:	ea4f 0049 	mov.w	r0, r9, lsl #1
   2cb5a:	db7e      	blt.n	2cc5a <_celt_autocorr+0x232>
   2cb5c:	f10b 4a00 	add.w	sl, fp, #2147483648	; 0x80000000
   2cb60:	687b      	ldr	r3, [r7, #4]
   2cb62:	6038      	str	r0, [r7, #0]
   2cb64:	f1a4 0e02 	sub.w	lr, r4, #2
   2cb68:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
   2cb6c:	6b38      	ldr	r0, [r7, #48]	; 0x30
   2cb6e:	46d8      	mov	r8, fp
   2cb70:	44b6      	add	lr, r6
   2cb72:	eb06 0a4a 	add.w	sl, r6, sl, lsl #1
   2cb76:	f1a3 0b04 	sub.w	fp, r3, #4
   2cb7a:	f04f 0900 	mov.w	r9, #0
   {
      for (i = k+fastN, d = 0; i < n; i++)
   2cb7e:	4545      	cmp	r5, r8
   2cb80:	dd38      	ble.n	2cbf4 <_celt_autocorr+0x1cc>
   2cb82:	eba8 0209 	sub.w	r2, r8, r9
   2cb86:	eb06 0242 	add.w	r2, r6, r2, lsl #1
   2cb8a:	4653      	mov	r3, sl
   2cb8c:	2100      	movs	r1, #0
         d = MAC16_16(d, xptr[i], xptr[i-k]);
   2cb8e:	f833 cf02 	ldrh.w	ip, [r3, #2]!
   2cb92:	f932 4b02 	ldrsh.w	r4, [r2], #2
      for (i = k+fastN, d = 0; i < n; i++)
   2cb96:	459e      	cmp	lr, r3
         d = MAC16_16(d, xptr[i], xptr[i-k]);
   2cb98:	fb1c 1104 	smlabb	r1, ip, r4, r1
      for (i = k+fastN, d = 0; i < n; i++)
   2cb9c:	d1f7      	bne.n	2cb8e <_celt_autocorr+0x166>
      ac[k] += d;
   2cb9e:	f85b 3f04 	ldr.w	r3, [fp, #4]!
   for (k=0;k<=lag;k++)
   2cba2:	f109 0901 	add.w	r9, r9, #1
      ac[k] += d;
   2cba6:	4419      	add	r1, r3
   for (k=0;k<=lag;k++)
   2cba8:	4548      	cmp	r0, r9
   2cbaa:	f108 0801 	add.w	r8, r8, #1
   2cbae:	f10a 0a02 	add.w	sl, sl, #2
      ac[k] += d;
   2cbb2:	f8cb 1000 	str.w	r1, [fp]
   for (k=0;k<=lag;k++)
   2cbb6:	dae2      	bge.n	2cb7e <_celt_autocorr+0x156>
   2cbb8:	e9d7 0300 	ldrd	r0, r3, [r7]
   2cbbc:	681b      	ldr	r3, [r3, #0]
   }
#ifdef FIXED_POINT
   shift = 2*shift;
   if (shift<=0)
   2cbbe:	2800      	cmp	r0, #0
   2cbc0:	d037      	beq.n	2cc32 <_celt_autocorr+0x20a>
      ac[0] += SHL32((opus_int32)1, -shift);
   if (ac[0] < 268435456)
   2cbc2:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
   2cbc6:	da17      	bge.n	2cbf8 <_celt_autocorr+0x1d0>
   {
      int shift2 = 29 - EC_ILOG(ac[0]);
   2cbc8:	fab3 f383 	clz	r3, r3
   2cbcc:	1ed9      	subs	r1, r3, #3
      for (i=0;i<=lag;i++)
   2cbce:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   2cbd0:	2b00      	cmp	r3, #0
   2cbd2:	db0a      	blt.n	2cbea <_celt_autocorr+0x1c2>
   2cbd4:	461c      	mov	r4, r3
   2cbd6:	687b      	ldr	r3, [r7, #4]
   2cbd8:	eb03 0484 	add.w	r4, r3, r4, lsl #2
   2cbdc:	3b04      	subs	r3, #4
         ac[i] = SHL32(ac[i], shift2);
   2cbde:	f853 2f04 	ldr.w	r2, [r3, #4]!
   2cbe2:	408a      	lsls	r2, r1
      for (i=0;i<=lag;i++)
   2cbe4:	42a3      	cmp	r3, r4
         ac[i] = SHL32(ac[i], shift2);
   2cbe6:	601a      	str	r2, [r3, #0]
      for (i=0;i<=lag;i++)
   2cbe8:	d1f9      	bne.n	2cbde <_celt_autocorr+0x1b6>
      shift -= shift2;
   2cbea:	1a40      	subs	r0, r0, r1
   }
#endif

   RESTORE_STACK;
   return shift;
}
   2cbec:	370c      	adds	r7, #12
   2cbee:	46bd      	mov	sp, r7
   2cbf0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      for (i = k+fastN, d = 0; i < n; i++)
   2cbf4:	2100      	movs	r1, #0
   2cbf6:	e7d2      	b.n	2cb9e <_celt_autocorr+0x176>
   } else if (ac[0] >= 536870912)
   2cbf8:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   2cbfc:	dbf6      	blt.n	2cbec <_celt_autocorr+0x1c4>
      int shift2=1;
   2cbfe:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
      for (i=0;i<=lag;i++)
   2cc02:	6b3b      	ldr	r3, [r7, #48]	; 0x30
      int shift2=1;
   2cc04:	bfac      	ite	ge
   2cc06:	2102      	movge	r1, #2
   2cc08:	2101      	movlt	r1, #1
      for (i=0;i<=lag;i++)
   2cc0a:	2b00      	cmp	r3, #0
   2cc0c:	db0a      	blt.n	2cc24 <_celt_autocorr+0x1fc>
   2cc0e:	461c      	mov	r4, r3
   2cc10:	687b      	ldr	r3, [r7, #4]
   2cc12:	eb03 0484 	add.w	r4, r3, r4, lsl #2
   2cc16:	3b04      	subs	r3, #4
         ac[i] = SHR32(ac[i], shift2);
   2cc18:	f853 2f04 	ldr.w	r2, [r3, #4]!
   2cc1c:	410a      	asrs	r2, r1
      for (i=0;i<=lag;i++)
   2cc1e:	429c      	cmp	r4, r3
         ac[i] = SHR32(ac[i], shift2);
   2cc20:	601a      	str	r2, [r3, #0]
      for (i=0;i<=lag;i++)
   2cc22:	d1f9      	bne.n	2cc18 <_celt_autocorr+0x1f0>
      shift += shift2;
   2cc24:	4408      	add	r0, r1
}
   2cc26:	370c      	adds	r7, #12
   2cc28:	46bd      	mov	sp, r7
   2cc2a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2cc2e:	687b      	ldr	r3, [r7, #4]
   2cc30:	681b      	ldr	r3, [r3, #0]
      ac[0] += SHL32((opus_int32)1, -shift);
   2cc32:	687a      	ldr	r2, [r7, #4]
   2cc34:	3301      	adds	r3, #1
   2cc36:	6013      	str	r3, [r2, #0]
   2cc38:	2000      	movs	r0, #0
   2cc3a:	e7c2      	b.n	2cbc2 <_celt_autocorr+0x19a>
   celt_pitch_xcorr(xptr, xptr, ac, fastN, lag+1, arch);
   2cc3c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   2cc3e:	687a      	ldr	r2, [r7, #4]
   2cc40:	e9cd c300 	strd	ip, r3, [sp]
   2cc44:	4641      	mov	r1, r8
   2cc46:	465b      	mov	r3, fp
   2cc48:	4640      	mov	r0, r8
   2cc4a:	f7ff f99d 	bl	2bf88 <celt_pitch_xcorr_c>
   for (k=0;k<=lag;k++)
   2cc4e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   2cc50:	2b00      	cmp	r3, #0
   2cc52:	dbec      	blt.n	2cc2e <_celt_autocorr+0x206>
   2cc54:	4646      	mov	r6, r8
   2cc56:	2000      	movs	r0, #0
   2cc58:	e780      	b.n	2cb5c <_celt_autocorr+0x134>
   2cc5a:	687b      	ldr	r3, [r7, #4]
   2cc5c:	681b      	ldr	r3, [r3, #0]
   2cc5e:	e7b0      	b.n	2cbc2 <_celt_autocorr+0x19a>

0002cc60 <quant_coarse_energy_impl.isra.3>:
      }
   } while (++c<C);
   return MIN32(200,SHR32(dist,2*DB_SHIFT-6));
}

static int quant_coarse_energy_impl(const CELTMode *m, int start, int end,
   2cc60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2cc64:	b091      	sub	sp, #68	; 0x44
   2cc66:	e9dd 6521 	ldrd	r6, r5, [sp, #132]	; 0x84
   2cc6a:	9c1c      	ldr	r4, [sp, #112]	; 0x70
   2cc6c:	9305      	str	r3, [sp, #20]
   int badness = 0;
   opus_val32 prev[2] = {0,0};
   opus_val16 coef;
   opus_val16 beta;

   if (tell+3 <= budget)
   2cc6e:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
static int quant_coarse_energy_impl(const CELTMode *m, int start, int end,
   2cc70:	f9bd 708c 	ldrsh.w	r7, [sp, #140]	; 0x8c
   2cc74:	9706      	str	r7, [sp, #24]
   if (tell+3 <= budget)
   2cc76:	3402      	adds	r4, #2
   opus_val32 prev[2] = {0,0};
   2cc78:	2700      	movs	r7, #0
   if (tell+3 <= budget)
   2cc7a:	429c      	cmp	r4, r3
static int quant_coarse_energy_impl(const CELTMode *m, int start, int end,
   2cc7c:	f8dd b07c 	ldr.w	fp, [sp, #124]	; 0x7c
   2cc80:	9007      	str	r0, [sp, #28]
   2cc82:	9102      	str	r1, [sp, #8]
   2cc84:	920a      	str	r2, [sp, #40]	; 0x28
   opus_val32 prev[2] = {0,0};
   2cc86:	e9cd 770e 	strd	r7, r7, [sp, #56]	; 0x38
   if (tell+3 <= budget)
   2cc8a:	f2c0 8105 	blt.w	2ce98 <quant_coarse_energy_impl.isra.3+0x238>
      ec_enc_bit_logp(enc, intra, 3);
   if (intra)
   2cc8e:	2d00      	cmp	r5, #0
   2cc90:	f040 80fc 	bne.w	2ce8c <quant_coarse_energy_impl.isra.3+0x22c>
   {
      coef = 0;
      beta = beta_intra;
   } else {
      beta = beta_coef[LM];
   2cc94:	4a83      	ldr	r2, [pc, #524]	; (2cea4 <quant_coarse_energy_impl.isra.3+0x244>)
      coef = pred_coef[LM];
   2cc96:	4b84      	ldr	r3, [pc, #528]	; (2cea8 <quant_coarse_energy_impl.isra.3+0x248>)
      beta = beta_coef[LM];
   2cc98:	f932 2016 	ldrsh.w	r2, [r2, r6, lsl #1]
      coef = pred_coef[LM];
   2cc9c:	f933 3016 	ldrsh.w	r3, [r3, r6, lsl #1]
      beta = beta_coef[LM];
   2cca0:	9203      	str	r2, [sp, #12]
      coef = pred_coef[LM];
   2cca2:	9304      	str	r3, [sp, #16]
   }

   /* Encode at a fixed coarse resolution */
   for (i=start;i<end;i++)
   2cca4:	990a      	ldr	r1, [sp, #40]	; 0x28
   2cca6:	9a02      	ldr	r2, [sp, #8]
   2cca8:	4291      	cmp	r1, r2
   2ccaa:	f340 80e5 	ble.w	2ce78 <quant_coarse_energy_impl.isra.3+0x218>
         }
         qi0 = qi;
         /* If we don't have enough bits to encode all the energy, just assume
             something safe. */
         tell = ec_tell(enc);
         bits_left = budget-tell-3*C*(end-i);
   2ccae:	9b20      	ldr	r3, [sp, #128]	; 0x80
   2ccb0:	eb03 0043 	add.w	r0, r3, r3, lsl #1
   2ccb4:	1a8b      	subs	r3, r1, r2
   2ccb6:	f04f 0a00 	mov.w	sl, #0
   2ccba:	9907      	ldr	r1, [sp, #28]
   2ccbc:	900b      	str	r0, [sp, #44]	; 0x2c
   2ccbe:	fb00 f303 	mul.w	r3, r0, r3
   int badness = 0;
   2ccc2:	e9cd a300 	strd	sl, r3, [sp]
   2ccc6:	f8d1 c000 	ldr.w	ip, [r1]
         bits_left = budget-tell-3*C*(end-i);
   2ccca:	4690      	mov	r8, r2
   2cccc:	4656      	mov	r6, sl
         if (lfe && i>=2)
            qi = IMIN(qi, 0);
         if (budget-tell >= 15)
         {
            int pi;
            pi = 2*IMIN(i,20);
   2ccce:	4643      	mov	r3, r8
   2ccd0:	2b14      	cmp	r3, #20
   2ccd2:	bfa8      	it	ge
   2ccd4:	2314      	movge	r3, #20
   2ccd6:	005b      	lsls	r3, r3, #1
            ec_laplace_encode(enc, &qi,
                  prob_model[pi]<<7, prob_model[pi+1]<<6);
   2ccd8:	991d      	ldr	r1, [sp, #116]	; 0x74
   2ccda:	1c5a      	adds	r2, r3, #1
   2ccdc:	188a      	adds	r2, r1, r2
   2ccde:	18cb      	adds	r3, r1, r3
   2cce0:	9209      	str	r2, [sp, #36]	; 0x24
   2cce2:	9308      	str	r3, [sp, #32]
      c=0;
   2cce4:	f04f 0900 	mov.w	r9, #0
         x = eBands[i+c*m->nbEBands];
   2cce8:	fb0c 8309 	mla	r3, ip, r9, r8
         oldE = MAX16(-QCONST16(9.f,DB_SHIFT), oldEBands[i+c*m->nbEBands]);
   2ccec:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   2ccee:	4c6f      	ldr	r4, [pc, #444]	; (2ceac <quant_coarse_energy_impl.isra.3+0x24c>)
   2ccf0:	f932 2013 	ldrsh.w	r2, [r2, r3, lsl #1]
         f = SHL32(EXTEND32(x),7) - PSHR32(MULT16_16(coef,oldE), 8) - prev[c];
   2ccf4:	9d04      	ldr	r5, [sp, #16]
         x = eBands[i+c*m->nbEBands];
   2ccf6:	9905      	ldr	r1, [sp, #20]
         oldE = MAX16(-QCONST16(9.f,DB_SHIFT), oldEBands[i+c*m->nbEBands]);
   2ccf8:	4294      	cmp	r4, r2
   2ccfa:	bfb8      	it	lt
   2ccfc:	4614      	movlt	r4, r2
         f = SHL32(EXTEND32(x),7) - PSHR32(MULT16_16(coef,oldE), 8) - prev[c];
   2ccfe:	2080      	movs	r0, #128	; 0x80
   2cd00:	fb14 0405 	smlabb	r4, r4, r5, r0
         x = eBands[i+c*m->nbEBands];
   2cd04:	f931 1013 	ldrsh.w	r1, [r1, r3, lsl #1]
         decay_bound = EXTRACT16(MAX32(-QCONST16(28.f,DB_SHIFT),
   2cd08:	9806      	ldr	r0, [sp, #24]
         f = SHL32(EXTEND32(x),7) - PSHR32(MULT16_16(coef,oldE), 8) - prev[c];
   2cd0a:	1224      	asrs	r4, r4, #8
   2cd0c:	ebc4 1ec1 	rsb	lr, r4, r1, lsl #7
   2cd10:	ebae 0a06 	sub.w	sl, lr, r6
         decay_bound = EXTRACT16(MAX32(-QCONST16(28.f,DB_SHIFT),
   2cd14:	1a12      	subs	r2, r2, r0
         qi = (f+QCONST32(.5f,DB_SHIFT+7))>>(DB_SHIFT+7);
   2cd16:	f50a 3580 	add.w	r5, sl, #65536	; 0x10000
         decay_bound = EXTRACT16(MAX32(-QCONST16(28.f,DB_SHIFT),
   2cd1a:	f512 4fe0 	cmn.w	r2, #28672	; 0x7000
         qi = (f+QCONST32(.5f,DB_SHIFT+7))>>(DB_SHIFT+7);
   2cd1e:	ea4f 4565 	mov.w	r5, r5, asr #17
         oldE = MAX16(-QCONST16(9.f,DB_SHIFT), oldEBands[i+c*m->nbEBands]);
   2cd22:	981a      	ldr	r0, [sp, #104]	; 0x68
         decay_bound = EXTRACT16(MAX32(-QCONST16(28.f,DB_SHIFT),
   2cd24:	bfb8      	it	lt
   2cd26:	4a62      	ldrlt	r2, [pc, #392]	; (2ceb0 <quant_coarse_energy_impl.isra.3+0x250>)
         qi = (f+QCONST32(.5f,DB_SHIFT+7))>>(DB_SHIFT+7);
   2cd28:	950d      	str	r5, [sp, #52]	; 0x34
         x = eBands[i+c*m->nbEBands];
   2cd2a:	ea4f 0343 	mov.w	r3, r3, lsl #1
         decay_bound = EXTRACT16(MAX32(-QCONST16(28.f,DB_SHIFT),
   2cd2e:	bfa8      	it	ge
   2cd30:	b212      	sxthge	r2, r2
         if (qi < 0 && x < decay_bound)
   2cd32:	2d00      	cmp	r5, #0
         oldE = MAX16(-QCONST16(9.f,DB_SHIFT), oldEBands[i+c*m->nbEBands]);
   2cd34:	4418      	add	r0, r3
         if (qi < 0 && x < decay_bound)
   2cd36:	db79      	blt.n	2ce2c <quant_coarse_energy_impl.isra.3+0x1cc>
  return _this->nbits_total-EC_ILOG(_this->rng);
   2cd38:	f8db 101c 	ldr.w	r1, [fp, #28]
   2cd3c:	f8db 2014 	ldr.w	r2, [fp, #20]
   2cd40:	fab1 f181 	clz	r1, r1
   2cd44:	f1c1 0120 	rsb	r1, r1, #32
   2cd48:	1a52      	subs	r2, r2, r1
         bits_left = budget-tell-3*C*(end-i);
   2cd4a:	991b      	ldr	r1, [sp, #108]	; 0x6c
   2cd4c:	1a8a      	subs	r2, r1, r2
   2cd4e:	9901      	ldr	r1, [sp, #4]
   2cd50:	1a57      	subs	r7, r2, r1
         if (i!=start && bits_left < 30)
   2cd52:	9902      	ldr	r1, [sp, #8]
   2cd54:	4541      	cmp	r1, r8
               qi = IMIN(1, qi);
   2cd56:	4629      	mov	r1, r5
         if (i!=start && bits_left < 30)
   2cd58:	d00c      	beq.n	2cd74 <quant_coarse_energy_impl.isra.3+0x114>
   2cd5a:	2f1d      	cmp	r7, #29
   2cd5c:	dc0a      	bgt.n	2cd74 <quant_coarse_energy_impl.isra.3+0x114>
            if (bits_left < 24)
   2cd5e:	2f17      	cmp	r7, #23
   2cd60:	dc03      	bgt.n	2cd6a <quant_coarse_energy_impl.isra.3+0x10a>
               qi = IMIN(1, qi);
   2cd62:	2d01      	cmp	r5, #1
   2cd64:	bfa8      	it	ge
   2cd66:	2101      	movge	r1, #1
   2cd68:	910d      	str	r1, [sp, #52]	; 0x34
            if (bits_left < 16)
   2cd6a:	2f0f      	cmp	r7, #15
               qi = IMAX(-1, qi);
   2cd6c:	bfdc      	itt	le
   2cd6e:	ea41 71e1 	orrle.w	r1, r1, r1, asr #31
   2cd72:	910d      	strle	r1, [sp, #52]	; 0x34
         if (lfe && i>=2)
   2cd74:	9f24      	ldr	r7, [sp, #144]	; 0x90
   2cd76:	b12f      	cbz	r7, 2cd84 <quant_coarse_energy_impl.isra.3+0x124>
   2cd78:	f1b8 0f01 	cmp.w	r8, #1
            qi = IMIN(qi, 0);
   2cd7c:	bfc4      	itt	gt
   2cd7e:	ea01 71e1 	andgt.w	r1, r1, r1, asr #31
   2cd82:	910d      	strgt	r1, [sp, #52]	; 0x34
         if (budget-tell >= 15)
   2cd84:	2a0e      	cmp	r2, #14
   2cd86:	dc5b      	bgt.n	2ce40 <quant_coarse_energy_impl.isra.3+0x1e0>
         }
         else if(budget-tell >= 2)
   2cd88:	2a01      	cmp	r2, #1
   2cd8a:	dd64      	ble.n	2ce56 <quant_coarse_energy_impl.isra.3+0x1f6>
         {
            qi = IMAX(-1, IMIN(qi, 1));
   2cd8c:	2901      	cmp	r1, #1
   2cd8e:	4608      	mov	r0, r1
   2cd90:	bfa8      	it	ge
   2cd92:	2001      	movge	r0, #1
   2cd94:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
            ec_enc_icdf(enc, 2*qi^-(qi<0), small_energy_icdf, 2);
   2cd98:	0043      	lsls	r3, r0, #1
   2cd9a:	ea83 71e1 	eor.w	r1, r3, r1, asr #31
            qi = IMAX(-1, IMIN(qi, 1));
   2cd9e:	900d      	str	r0, [sp, #52]	; 0x34
            ec_enc_icdf(enc, 2*qi^-(qi<0), small_energy_icdf, 2);
   2cda0:	2302      	movs	r3, #2
   2cda2:	4a44      	ldr	r2, [pc, #272]	; (2ceb4 <quant_coarse_energy_impl.isra.3+0x254>)
   2cda4:	4658      	mov	r0, fp
   2cda6:	f7fd f86b 	bl	29e80 <ec_enc_icdf>
   2cdaa:	9b07      	ldr	r3, [sp, #28]
   2cdac:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   2cdae:	f8d3 c000 	ldr.w	ip, [r3]
   2cdb2:	991a      	ldr	r1, [sp, #104]	; 0x68
   2cdb4:	fb0c 8309 	mla	r3, ip, r9, r8
   2cdb8:	0297      	lsls	r7, r2, #10
   2cdba:	005b      	lsls	r3, r3, #1
   2cdbc:	18c8      	adds	r0, r1, r3
   2cdbe:	f407 4e7c 	and.w	lr, r7, #64512	; 0xfc00
   2cdc2:	0451      	lsls	r1, r2, #17
   2cdc4:	f347 270f 	sbfx	r7, r7, #8, #16
            qi = -1;
         error[i+c*m->nbEBands] = PSHR32(f,7) - SHL16(qi,DB_SHIFT);
         badness += abs(qi0-qi);
         q = (opus_val32)SHL32(EXTEND32(qi),DB_SHIFT);

         tmp = PSHR32(MULT16_16(coef,oldE),8) + prev[c] + SHL32(q,7);
   2cdc8:	4434      	add	r4, r6
   2cdca:	440c      	add	r4, r1
#ifdef FIXED_POINT
         tmp = MAX32(-QCONST32(28.f, DB_SHIFT+7), tmp);
#endif
         oldEBands[i+c*m->nbEBands] = PSHR32(tmp, 7);
         prev[c] = prev[c] + SHL32(q,7) - MULT16_16(beta,PSHR32(q,8));
   2cdcc:	440e      	add	r6, r1
         tmp = MAX32(-QCONST32(28.f, DB_SHIFT+7), tmp);
   2cdce:	493a      	ldr	r1, [pc, #232]	; (2ceb8 <quant_coarse_energy_impl.isra.3+0x258>)
   2cdd0:	428c      	cmp	r4, r1
   2cdd2:	bfb8      	it	lt
   2cdd4:	460c      	movlt	r4, r1
         prev[c] = prev[c] + SHL32(q,7) - MULT16_16(beta,PSHR32(q,8));
   2cdd6:	9903      	ldr	r1, [sp, #12]
         badness += abs(qi0-qi);
   2cdd8:	1aad      	subs	r5, r5, r2
         prev[c] = prev[c] + SHL32(q,7) - MULT16_16(beta,PSHR32(q,8));
   2cdda:	aa0e      	add	r2, sp, #56	; 0x38
   2cddc:	fb07 6611 	mls	r6, r7, r1, r6
   2cde0:	f842 6029 	str.w	r6, [r2, r9, lsl #2]
         error[i+c*m->nbEBands] = PSHR32(f,7) - SHL16(qi,DB_SHIFT);
   2cde4:	f10a 0140 	add.w	r1, sl, #64	; 0x40
   2cde8:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   2cdea:	ebce 1ee1 	rsb	lr, lr, r1, asr #7
         badness += abs(qi0-qi);
   2cdee:	2d00      	cmp	r5, #0
         error[i+c*m->nbEBands] = PSHR32(f,7) - SHL16(qi,DB_SHIFT);
   2cdf0:	f822 e003 	strh.w	lr, [r2, r3]
         badness += abs(qi0-qi);
   2cdf4:	9b00      	ldr	r3, [sp, #0]
   2cdf6:	bfb8      	it	lt
   2cdf8:	426d      	neglt	r5, r5
   2cdfa:	442b      	add	r3, r5
   2cdfc:	9300      	str	r3, [sp, #0]
      } while (++c < C);
   2cdfe:	9b20      	ldr	r3, [sp, #128]	; 0x80
         oldEBands[i+c*m->nbEBands] = PSHR32(tmp, 7);
   2ce00:	3440      	adds	r4, #64	; 0x40
      } while (++c < C);
   2ce02:	f109 0901 	add.w	r9, r9, #1
         oldEBands[i+c*m->nbEBands] = PSHR32(tmp, 7);
   2ce06:	11e4      	asrs	r4, r4, #7
      } while (++c < C);
   2ce08:	454b      	cmp	r3, r9
         oldEBands[i+c*m->nbEBands] = PSHR32(tmp, 7);
   2ce0a:	8004      	strh	r4, [r0, #0]
      } while (++c < C);
   2ce0c:	dd03      	ble.n	2ce16 <quant_coarse_energy_impl.isra.3+0x1b6>
   2ce0e:	ab0e      	add	r3, sp, #56	; 0x38
   2ce10:	f853 6029 	ldr.w	r6, [r3, r9, lsl #2]
   2ce14:	e768      	b.n	2cce8 <quant_coarse_energy_impl.isra.3+0x88>
   2ce16:	9b01      	ldr	r3, [sp, #4]
   2ce18:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   2ce1a:	1a9b      	subs	r3, r3, r2
   2ce1c:	9301      	str	r3, [sp, #4]
   for (i=start;i<end;i++)
   2ce1e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   2ce20:	f108 0801 	add.w	r8, r8, #1
   2ce24:	4543      	cmp	r3, r8
   2ce26:	d029      	beq.n	2ce7c <quant_coarse_energy_impl.isra.3+0x21c>
   2ce28:	9e0e      	ldr	r6, [sp, #56]	; 0x38
   2ce2a:	e750      	b.n	2ccce <quant_coarse_energy_impl.isra.3+0x6e>
         if (qi < 0 && x < decay_bound)
   2ce2c:	4291      	cmp	r1, r2
   2ce2e:	da83      	bge.n	2cd38 <quant_coarse_energy_impl.isra.3+0xd8>
            qi += (int)SHR16(SUB16(decay_bound,x), DB_SHIFT);
   2ce30:	1a52      	subs	r2, r2, r1
   2ce32:	eb05 25a2 	add.w	r5, r5, r2, asr #10
            if (qi > 0)
   2ce36:	2d00      	cmp	r5, #0
               qi = 0;
   2ce38:	bfc8      	it	gt
   2ce3a:	2500      	movgt	r5, #0
   2ce3c:	950d      	str	r5, [sp, #52]	; 0x34
   2ce3e:	e77b      	b.n	2cd38 <quant_coarse_energy_impl.isra.3+0xd8>
                  prob_model[pi]<<7, prob_model[pi+1]<<6);
   2ce40:	9b09      	ldr	r3, [sp, #36]	; 0x24
   2ce42:	9a08      	ldr	r2, [sp, #32]
   2ce44:	781b      	ldrb	r3, [r3, #0]
   2ce46:	7812      	ldrb	r2, [r2, #0]
            ec_laplace_encode(enc, &qi,
   2ce48:	019b      	lsls	r3, r3, #6
   2ce4a:	01d2      	lsls	r2, r2, #7
   2ce4c:	a90d      	add	r1, sp, #52	; 0x34
   2ce4e:	4658      	mov	r0, fp
   2ce50:	f7fe f932 	bl	2b0b8 <ec_laplace_encode>
   2ce54:	e7a9      	b.n	2cdaa <quant_coarse_energy_impl.isra.3+0x14a>
         else if(budget-tell >= 1)
   2ce56:	d007      	beq.n	2ce68 <quant_coarse_energy_impl.isra.3+0x208>
   2ce58:	f06f 0703 	mvn.w	r7, #3
   2ce5c:	4917      	ldr	r1, [pc, #92]	; (2cebc <quant_coarse_energy_impl.isra.3+0x25c>)
   2ce5e:	f44f 4e7c 	mov.w	lr, #64512	; 0xfc00
   2ce62:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2ce66:	e7af      	b.n	2cdc8 <quant_coarse_energy_impl.isra.3+0x168>
            qi = IMIN(0, qi);
   2ce68:	ea01 73e1 	and.w	r3, r1, r1, asr #31
            ec_enc_bit_logp(enc, -qi, 1);
   2ce6c:	4259      	negs	r1, r3
   2ce6e:	4658      	mov	r0, fp
            qi = IMIN(0, qi);
   2ce70:	930d      	str	r3, [sp, #52]	; 0x34
            ec_enc_bit_logp(enc, -qi, 1);
   2ce72:	f7fc ff99 	bl	29da8 <ec_enc_bit_logp>
   2ce76:	e798      	b.n	2cdaa <quant_coarse_energy_impl.isra.3+0x14a>
   int badness = 0;
   2ce78:	2300      	movs	r3, #0
   2ce7a:	9300      	str	r3, [sp, #0]
   }
   return lfe ? 0 : badness;
   2ce7c:	9b24      	ldr	r3, [sp, #144]	; 0x90
}
   2ce7e:	9800      	ldr	r0, [sp, #0]
   return lfe ? 0 : badness;
   2ce80:	2b00      	cmp	r3, #0
}
   2ce82:	bf18      	it	ne
   2ce84:	2000      	movne	r0, #0
   2ce86:	b011      	add	sp, #68	; 0x44
   2ce88:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      coef = 0;
   2ce8c:	f241 3233 	movw	r2, #4915	; 0x1333
   2ce90:	2300      	movs	r3, #0
   2ce92:	e9cd 2303 	strd	r2, r3, [sp, #12]
   2ce96:	e705      	b.n	2cca4 <quant_coarse_energy_impl.isra.3+0x44>
      ec_enc_bit_logp(enc, intra, 3);
   2ce98:	2203      	movs	r2, #3
   2ce9a:	4629      	mov	r1, r5
   2ce9c:	4658      	mov	r0, fp
   2ce9e:	f7fc ff83 	bl	29da8 <ec_enc_bit_logp>
   2cea2:	e6f4      	b.n	2cc8e <quant_coarse_energy_impl.isra.3+0x2e>
   2cea4:	0003b41c 	.word	0x0003b41c
   2cea8:	0003b590 	.word	0x0003b590
   2ceac:	ffffdc00 	.word	0xffffdc00
   2ceb0:	ffff9000 	.word	0xffff9000
   2ceb4:	0003b598 	.word	0x0003b598
   2ceb8:	ffc80000 	.word	0xffc80000
   2cebc:	fffe0000 	.word	0xfffe0000

0002cec0 <quant_coarse_energy>:

void quant_coarse_energy(const CELTMode *m, int start, int end, int effEnd,
      const opus_val16 *eBands, opus_val16 *oldEBands, opus_uint32 budget,
      opus_val16 *error, ec_enc *enc, int C, int LM, int nbAvailableBytes,
      int force_intra, opus_val32 *delayedIntra, int two_pass, int loss_rate, int lfe)
{
   2cec0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2cec4:	b0b3      	sub	sp, #204	; 0xcc
   2cec6:	af0c      	add	r7, sp, #48	; 0x30
   2cec8:	f8d7 40e4 	ldr.w	r4, [r7, #228]	; 0xe4
   2cecc:	6379      	str	r1, [r7, #52]	; 0x34
   2cece:	61ba      	str	r2, [r7, #24]
   2ced0:	1a51      	subs	r1, r2, r1
   int badness1=0;
   opus_int32 intra_bias;
   opus_val32 new_distortion;
   SAVE_STACK;

   intra = force_intra || (!two_pass && *delayedIntra>2*C*(end-start) && nbAvailableBytes > (end-start)*C);
   2ced2:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
   2ced6:	6824      	ldr	r4, [r4, #0]
   2ced8:	60fc      	str	r4, [r7, #12]
{
   2ceda:	f8d7 80d0 	ldr.w	r8, [r7, #208]	; 0xd0
   2cede:	6338      	str	r0, [r7, #48]	; 0x30
   2cee0:	62b9      	str	r1, [r7, #40]	; 0x28
   intra = force_intra || (!two_pass && *delayedIntra>2*C*(end-start) && nbAvailableBytes > (end-start)*C);
   2cee2:	2a00      	cmp	r2, #0
   2cee4:	f040 80eb 	bne.w	2d0be <quant_coarse_energy+0x1fe>
   2cee8:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
   2ceec:	2a00      	cmp	r2, #0
   2ceee:	f000 8178 	beq.w	2d1e2 <quant_coarse_energy+0x322>
   2cef2:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
   2cef6:	f8d7 10c0 	ldr.w	r1, [r7, #192]	; 0xc0
   2cefa:	6b7c      	ldr	r4, [r7, #52]	; 0x34
   c=0; do {
   2cefc:	f8c7 80d0 	str.w	r8, [r7, #208]	; 0xd0
   2cf00:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   2cf04:	eba2 0a0c 	sub.w	sl, r2, ip
   intra_bias = (opus_int32)((budget**delayedIntra*loss_rate)/(C*512));
   new_distortion = loss_distortion(eBands, oldEBands, start, effEnd, m->nbEBands, C);
   2cf08:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   c=0; do {
   2cf0a:	f8d7 80d4 	ldr.w	r8, [r7, #212]	; 0xd4
   new_distortion = loss_distortion(eBands, oldEBands, start, effEnd, m->nbEBands, C);
   2cf0e:	6892      	ldr	r2, [r2, #8]
   2cf10:	62fa      	str	r2, [r7, #44]	; 0x2c
   2cf12:	ebaa 0a01 	sub.w	sl, sl, r1
   2cf16:	f8d7 10c0 	ldr.w	r1, [r7, #192]	; 0xc0
   2cf1a:	eba4 0903 	sub.w	r9, r4, r3
   opus_val32 dist = 0;
   2cf1e:	2600      	movs	r6, #0
   2cf20:	eb0a 0a44 	add.w	sl, sl, r4, lsl #1
   2cf24:	448c      	add	ip, r1
   2cf26:	ea4f 0b42 	mov.w	fp, r2, lsl #1
   2cf2a:	ea4f 0949 	mov.w	r9, r9, lsl #1
   c=0; do {
   2cf2e:	46b6      	mov	lr, r6
      for (i=start;i<end;i++)
   2cf30:	429c      	cmp	r4, r3
   2cf32:	da0e      	bge.n	2cf52 <quant_coarse_energy+0x92>
   2cf34:	eb09 000c 	add.w	r0, r9, ip
   2cf38:	eb0a 050c 	add.w	r5, sl, ip
         opus_val16 d = SUB16(SHR16(eBands[i+c*len], 3), SHR16(oldEBands[i+c*len], 3));
   2cf3c:	f935 2b02 	ldrsh.w	r2, [r5], #2
   2cf40:	f930 1b02 	ldrsh.w	r1, [r0], #2
   2cf44:	10d2      	asrs	r2, r2, #3
   2cf46:	ebc2 02e1 	rsb	r2, r2, r1, asr #3
      for (i=start;i<end;i++)
   2cf4a:	4584      	cmp	ip, r0
         dist = MAC16_16(dist, d,d);
   2cf4c:	fb02 6602 	mla	r6, r2, r2, r6
      for (i=start;i<end;i++)
   2cf50:	d1f4      	bne.n	2cf3c <quant_coarse_energy+0x7c>
   } while (++c<C);
   2cf52:	f10e 0e01 	add.w	lr, lr, #1
   2cf56:	45f0      	cmp	r8, lr
   2cf58:	44dc      	add	ip, fp
   2cf5a:	dce9      	bgt.n	2cf30 <quant_coarse_energy+0x70>
   2cf5c:	f8d7 80d0 	ldr.w	r8, [r7, #208]	; 0xd0
   2cf60:	637c      	str	r4, [r7, #52]	; 0x34
   2cf62:	f8d8 301c 	ldr.w	r3, [r8, #28]
   2cf66:	f8d8 2014 	ldr.w	r2, [r8, #20]
   2cf6a:	fab3 f383 	clz	r3, r3
   2cf6e:	f1c3 0320 	rsb	r3, r3, #32
   2cf72:	1ad3      	subs	r3, r2, r3
   return MIN32(200,SHR32(dist,2*DB_SHIFT-6));
   2cf74:	ea4f 3ba6 	mov.w	fp, r6, asr #14

   tell = ec_tell(enc);
   if (tell+3 > budget)
   2cf78:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
   2cf7c:	627b      	str	r3, [r7, #36]	; 0x24
   return MIN32(200,SHR32(dist,2*DB_SHIFT-6));
   2cf7e:	f1bb 0fc8 	cmp.w	fp, #200	; 0xc8
   if (tell+3 > budget)
   2cf82:	f103 0303 	add.w	r3, r3, #3
   return MIN32(200,SHR32(dist,2*DB_SHIFT-6));
   2cf86:	bfa8      	it	ge
   2cf88:	f04f 0bc8 	movge.w	fp, #200	; 0xc8
   if (tell+3 > budget)
   2cf8c:	4293      	cmp	r3, r2
   2cf8e:	d904      	bls.n	2cf9a <quant_coarse_energy+0xda>
      two_pass = intra = 0;
   2cf90:	2300      	movs	r3, #0
   2cf92:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
   2cf96:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8

   max_decay = QCONST16(16.f,DB_SHIFT);
   if (end-start>10)
   2cf9a:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2cf9c:	2b0a      	cmp	r3, #10
   2cf9e:	f340 8092 	ble.w	2d0c6 <quant_coarse_energy+0x206>
   {
#ifdef FIXED_POINT
      max_decay = MIN32(max_decay, SHL32(EXTEND32(nbAvailableBytes),DB_SHIFT-3));
   2cfa2:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
   2cfa6:	ea4f 19c3 	mov.w	r9, r3, lsl #7
   2cfaa:	f5b9 4f80 	cmp.w	r9, #16384	; 0x4000
   2cfae:	bfa8      	it	ge
   2cfb0:	f44f 4980 	movge.w	r9, #16384	; 0x4000
   2cfb4:	fa0f f989 	sxth.w	r9, r9
      max_decay = MIN32(max_decay, .125f*nbAvailableBytes);
#endif
   }
   if (lfe)
      max_decay = QCONST16(3.f,DB_SHIFT);
   enc_start_state = *enc;
   2cfb8:	4646      	mov	r6, r8
   2cfba:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   2cfbc:	f107 0538 	add.w	r5, r7, #56	; 0x38
   2cfc0:	c50f      	stmia	r5!, {r0, r1, r2, r3}

   ALLOC(oldEBands_intra, C*m->nbEBands, opus_val16);
   2cfc2:	f8d7 40d4 	ldr.w	r4, [r7, #212]	; 0xd4
   enc_start_state = *enc;
   2cfc6:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   ALLOC(oldEBands_intra, C*m->nbEBands, opus_val16);
   2cfc8:	46a4      	mov	ip, r4
   2cfca:	6afc      	ldr	r4, [r7, #44]	; 0x2c
   2cfcc:	fb0c fc04 	mul.w	ip, ip, r4
   enc_start_state = *enc;
   2cfd0:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   ALLOC(oldEBands_intra, C*m->nbEBands, opus_val16);
   2cfd2:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
   enc_start_state = *enc;
   2cfd6:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
   ALLOC(oldEBands_intra, C*m->nbEBands, opus_val16);
   2cfda:	f10c 0608 	add.w	r6, ip, #8
   2cfde:	f026 0e07 	bic.w	lr, r6, #7
   2cfe2:	ebad 0d0e 	sub.w	sp, sp, lr
      max_decay = QCONST16(3.f,DB_SHIFT);
   2cfe6:	f8d7 60f0 	ldr.w	r6, [r7, #240]	; 0xf0
   ALLOC(oldEBands_intra, C*m->nbEBands, opus_val16);
   2cfea:	ac0c      	add	r4, sp, #48	; 0x30
   enc_start_state = *enc;
   2cfec:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
      max_decay = QCONST16(3.f,DB_SHIFT);
   2cff0:	2e00      	cmp	r6, #0
   ALLOC(error_intra, C*m->nbEBands, opus_val16);
   2cff2:	ebad 0d0e 	sub.w	sp, sp, lr
   OPUS_COPY(oldEBands_intra, oldEBands, C*m->nbEBands);
   2cff6:	4662      	mov	r2, ip
   2cff8:	4620      	mov	r0, r4
   2cffa:	f8d7 10c4 	ldr.w	r1, [r7, #196]	; 0xc4
   ALLOC(oldEBands_intra, C*m->nbEBands, opus_val16);
   2cffe:	62fc      	str	r4, [r7, #44]	; 0x2c
      max_decay = QCONST16(3.f,DB_SHIFT);
   2d000:	bf18      	it	ne
   2d002:	f44f 6940 	movne.w	r9, #3072	; 0xc00
   enc_start_state = *enc;
   2d006:	f8d8 5018 	ldr.w	r5, [r8, #24]
   OPUS_COPY(oldEBands_intra, oldEBands, C*m->nbEBands);
   2d00a:	f7df f879 	bl	c100 <memcpy>
   ALLOC(error_intra, C*m->nbEBands, opus_val16);
   2d00e:	aa0c      	add	r2, sp, #48	; 0x30
   2d010:	62ba      	str	r2, [r7, #40]	; 0x28
   2d012:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
   2d016:	2354      	movs	r3, #84	; 0x54
   2d018:	fb03 f302 	mul.w	r3, r3, r2
   2d01c:	61fb      	str	r3, [r7, #28]
   2d01e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   2d020:	3308      	adds	r3, #8
   2d022:	623b      	str	r3, [r7, #32]

   if (two_pass || intra)
   2d024:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
   2d028:	2b00      	cmp	r3, #0
   2d02a:	f040 80ee 	bne.w	2d20a <quant_coarse_energy+0x34a>
   2d02e:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
   2d032:	2b00      	cmp	r3, #0
   2d034:	d04a      	beq.n	2d0cc <quant_coarse_energy+0x20c>
   {
      badness1 = quant_coarse_energy_impl(m, start, end, eBands, oldEBands_intra, budget,
   2d036:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
   2d03a:	930a      	str	r3, [sp, #40]	; 0x28
            tell, e_prob_model[LM][1], error_intra, enc, C, LM, 1, max_decay, lfe);
   2d03c:	69fb      	ldr	r3, [r7, #28]
   2d03e:	4dac      	ldr	r5, [pc, #688]	; (2d2f0 <quant_coarse_energy+0x430>)
      badness1 = quant_coarse_energy_impl(m, start, end, eBands, oldEBands_intra, budget,
   2d040:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
            tell, e_prob_model[LM][1], error_intra, enc, C, LM, 1, max_decay, lfe);
   2d044:	442b      	add	r3, r5
   2d046:	461d      	mov	r5, r3
      badness1 = quant_coarse_energy_impl(m, start, end, eBands, oldEBands_intra, budget,
   2d048:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
   2d04c:	9307      	str	r3, [sp, #28]
   2d04e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
   2d052:	e9cd 8305 	strd	r8, r3, [sp, #20]
   2d056:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2d058:	9304      	str	r3, [sp, #16]
   2d05a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   2d05c:	9302      	str	r3, [sp, #8]
   2d05e:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
   2d062:	9301      	str	r3, [sp, #4]
   2d064:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   2d066:	9300      	str	r3, [sp, #0]
   2d068:	f04f 0c01 	mov.w	ip, #1
   2d06c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
   2d070:	69ba      	ldr	r2, [r7, #24]
   2d072:	6b79      	ldr	r1, [r7, #52]	; 0x34
   2d074:	6a38      	ldr	r0, [r7, #32]
   2d076:	9503      	str	r5, [sp, #12]
   2d078:	f8cd c020 	str.w	ip, [sp, #32]
   2d07c:	f7ff fdf0 	bl	2cc60 <quant_coarse_energy_impl.isra.3>
         OPUS_COPY(oldEBands, oldEBands_intra, C*m->nbEBands);
         OPUS_COPY(error, error_intra, C*m->nbEBands);
         intra = 1;
      }
   } else {
      OPUS_COPY(oldEBands, oldEBands_intra, C*m->nbEBands);
   2d080:	6b3c      	ldr	r4, [r7, #48]	; 0x30
   2d082:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
   2d086:	68a3      	ldr	r3, [r4, #8]
   2d088:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   2d08a:	f8d7 00c4 	ldr.w	r0, [r7, #196]	; 0xc4
   2d08e:	fb03 f302 	mul.w	r3, r3, r2
   2d092:	005a      	lsls	r2, r3, #1
   2d094:	f7df f834 	bl	c100 <memcpy>
      OPUS_COPY(error, error_intra, C*m->nbEBands);
   2d098:	68a2      	ldr	r2, [r4, #8]
   2d09a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
   2d09e:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   2d0a0:	f8d7 00cc 	ldr.w	r0, [r7, #204]	; 0xcc
   2d0a4:	fb02 f203 	mul.w	r2, r2, r3
   2d0a8:	0052      	lsls	r2, r2, #1
   2d0aa:	f7df f829 	bl	c100 <memcpy>
   }

   if (intra)
      *delayedIntra = new_distortion;
   2d0ae:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
   else
      *delayedIntra = ADD32(MULT16_32_Q15(MULT16_16_Q15(pred_coef[LM], pred_coef[LM]),*delayedIntra),
            new_distortion);

   RESTORE_STACK;
}
   2d0b2:	379c      	adds	r7, #156	; 0x9c
      *delayedIntra = new_distortion;
   2d0b4:	f8c3 b000 	str.w	fp, [r3]
}
   2d0b8:	46bd      	mov	sp, r7
   2d0ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   intra = force_intra || (!two_pass && *delayedIntra>2*C*(end-start) && nbAvailableBytes > (end-start)*C);
   2d0be:	2201      	movs	r2, #1
   2d0c0:	f8c7 20e0 	str.w	r2, [r7, #224]	; 0xe0
   2d0c4:	e715      	b.n	2cef2 <quant_coarse_energy+0x32>
   max_decay = QCONST16(16.f,DB_SHIFT);
   2d0c6:	f44f 4980 	mov.w	r9, #16384	; 0x4000
   2d0ca:	e775      	b.n	2cfb8 <quant_coarse_energy+0xf8>
   2d0cc:	4b89      	ldr	r3, [pc, #548]	; (2d2f4 <quant_coarse_energy+0x434>)
   2d0ce:	617b      	str	r3, [r7, #20]
      tell_intra = ec_tell_frac(enc);
   2d0d0:	4640      	mov	r0, r8
   2d0d2:	f7fc fb2b 	bl	2972c <ec_tell_frac>
      enc_intra_state = *enc;
   2d0d6:	46c2      	mov	sl, r8
      tell_intra = ec_tell_frac(enc);
   2d0d8:	6038      	str	r0, [r7, #0]
      enc_intra_state = *enc;
   2d0da:	e8ba 000f 	ldmia.w	sl!, {r0, r1, r2, r3}
   2d0de:	f107 0c68 	add.w	ip, r7, #104	; 0x68
   2d0e2:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   2d0e6:	e8ba 000f 	ldmia.w	sl!, {r0, r1, r2, r3}
      if (save_bytes == 0)
   2d0ea:	f8d8 4018 	ldr.w	r4, [r8, #24]
      intra_buf = ec_get_buffer(&enc_intra_state) + nstart_bytes;
   2d0ee:	f8d8 6000 	ldr.w	r6, [r8]
   {
   2d0f2:	f8c7 d010 	str.w	sp, [r7, #16]
      if (save_bytes == 0)
   2d0f6:	1b64      	subs	r4, r4, r5
      enc_intra_state = *enc;
   2d0f8:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
      if (save_bytes == 0)
   2d0fc:	bf18      	it	ne
   2d0fe:	46a6      	movne	lr, r4
      enc_intra_state = *enc;
   2d100:	e89a 000f 	ldmia.w	sl, {r0, r1, r2, r3}
      if (save_bytes == 0)
   2d104:	bf08      	it	eq
   2d106:	f04f 0e01 	moveq.w	lr, #1
      ALLOC(intra_bits, save_bytes, unsigned char);
   2d10a:	f10e 0e07 	add.w	lr, lr, #7
   2d10e:	f02e 0e07 	bic.w	lr, lr, #7
   2d112:	ebad 0d0e 	sub.w	sp, sp, lr
      intra_buf = ec_get_buffer(&enc_intra_state) + nstart_bytes;
   2d116:	4435      	add	r5, r6
      ALLOC(intra_bits, save_bytes, unsigned char);
   2d118:	ae0c      	add	r6, sp, #48	; 0x30
      enc_intra_state = *enc;
   2d11a:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
      OPUS_COPY(intra_bits, intra_buf, nintra_bytes - nstart_bytes);
   2d11e:	4622      	mov	r2, r4
   2d120:	4630      	mov	r0, r6
   2d122:	4629      	mov	r1, r5
      if (save_bytes == 0)
   2d124:	60bc      	str	r4, [r7, #8]
      ALLOC(intra_bits, save_bytes, unsigned char);
   2d126:	607e      	str	r6, [r7, #4]
      OPUS_COPY(intra_bits, intra_buf, nintra_bytes - nstart_bytes);
   2d128:	f7de ffea 	bl	c100 <memcpy>
      *enc = enc_start_state;
   2d12c:	f107 0c38 	add.w	ip, r7, #56	; 0x38
   2d130:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   2d134:	46c6      	mov	lr, r8
   2d136:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
   2d13a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   2d13e:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
   2d142:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
   2d146:	e88a 000f 	stmia.w	sl, {r0, r1, r2, r3}
      badness2 = quant_coarse_energy_impl(m, start, end, eBands, oldEBands, budget,
   2d14a:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
            tell, e_prob_model[LM][intra], error, enc, C, LM, 0, max_decay, lfe);
   2d14e:	697c      	ldr	r4, [r7, #20]
   2d150:	69fe      	ldr	r6, [r7, #28]
      badness2 = quant_coarse_energy_impl(m, start, end, eBands, oldEBands, budget,
   2d152:	e9cd 9309 	strd	r9, r3, [sp, #36]	; 0x24
   2d156:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
   2d15a:	9307      	str	r3, [sp, #28]
   2d15c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
   2d160:	e9cd 8305 	strd	r8, r3, [sp, #20]
   2d164:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
            tell, e_prob_model[LM][intra], error, enc, C, LM, 0, max_decay, lfe);
   2d168:	4434      	add	r4, r6
      badness2 = quant_coarse_energy_impl(m, start, end, eBands, oldEBands, budget,
   2d16a:	e9cd 4303 	strd	r4, r3, [sp, #12]
   2d16e:	f04f 0e00 	mov.w	lr, #0
   2d172:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
   2d176:	69ba      	ldr	r2, [r7, #24]
   2d178:	6b79      	ldr	r1, [r7, #52]	; 0x34
   2d17a:	6a38      	ldr	r0, [r7, #32]
   2d17c:	f8cd e020 	str.w	lr, [sp, #32]
   2d180:	6a7c      	ldr	r4, [r7, #36]	; 0x24
   2d182:	9402      	str	r4, [sp, #8]
   2d184:	f8d7 40c8 	ldr.w	r4, [r7, #200]	; 0xc8
   2d188:	9401      	str	r4, [sp, #4]
   2d18a:	f8d7 40c4 	ldr.w	r4, [r7, #196]	; 0xc4
   2d18e:	9400      	str	r4, [sp, #0]
   2d190:	f7ff fd66 	bl	2cc60 <quant_coarse_energy_impl.isra.3>
      if (two_pass && (badness1 < badness2 || (badness1 == badness2 && ((opus_int32)ec_tell_frac(enc))+intra_bias > tell_intra)))
   2d194:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
   2d198:	b123      	cbz	r3, 2d1a4 <quant_coarse_energy+0x2e4>
   2d19a:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
   2d19e:	4298      	cmp	r0, r3
   2d1a0:	dc7a      	bgt.n	2d298 <quant_coarse_energy+0x3d8>
   2d1a2:	d063      	beq.n	2d26c <quant_coarse_energy+0x3ac>
      *delayedIntra = ADD32(MULT16_32_Q15(MULT16_16_Q15(pred_coef[LM], pred_coef[LM]),*delayedIntra),
   2d1a4:	4b54      	ldr	r3, [pc, #336]	; (2d2f8 <quant_coarse_energy+0x438>)
   2d1a6:	f8d7 10d8 	ldr.w	r1, [r7, #216]	; 0xd8
   2d1aa:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
   2d1ae:	f933 3011 	ldrsh.w	r3, [r3, r1, lsl #1]
   2d1b2:	6812      	ldr	r2, [r2, #0]
   2d1b4:	f8d7 d010 	ldr.w	sp, [r7, #16]
   2d1b8:	fb03 f303 	mul.w	r3, r3, r3
   2d1bc:	f343 33cf 	sbfx	r3, r3, #15, #16
   2d1c0:	b296      	uxth	r6, r2
   2d1c2:	fb03 f606 	mul.w	r6, r3, r6
   2d1c6:	1412      	asrs	r2, r2, #16
   2d1c8:	fb03 f302 	mul.w	r3, r3, r2
   2d1cc:	13f6      	asrs	r6, r6, #15
   2d1ce:	eb06 0643 	add.w	r6, r6, r3, lsl #1
   2d1d2:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
   2d1d6:	445e      	add	r6, fp
}
   2d1d8:	379c      	adds	r7, #156	; 0x9c
      *delayedIntra = ADD32(MULT16_32_Q15(MULT16_16_Q15(pred_coef[LM], pred_coef[LM]),*delayedIntra),
   2d1da:	601e      	str	r6, [r3, #0]
}
   2d1dc:	46bd      	mov	sp, r7
   2d1de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   intra = force_intra || (!two_pass && *delayedIntra>2*C*(end-start) && nbAvailableBytes > (end-start)*C);
   2d1e2:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
   2d1e6:	0052      	lsls	r2, r2, #1
   2d1e8:	fb01 f202 	mul.w	r2, r1, r2
   2d1ec:	42a2      	cmp	r2, r4
   2d1ee:	da38      	bge.n	2d262 <quant_coarse_energy+0x3a2>
   2d1f0:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
   2d1f4:	fb01 f202 	mul.w	r2, r1, r2
   2d1f8:	f8d7 10dc 	ldr.w	r1, [r7, #220]	; 0xdc
   2d1fc:	428a      	cmp	r2, r1
   2d1fe:	bfac      	ite	ge
   2d200:	2200      	movge	r2, #0
   2d202:	2201      	movlt	r2, #1
   2d204:	f8c7 20e0 	str.w	r2, [r7, #224]	; 0xe0
   2d208:	e673      	b.n	2cef2 <quant_coarse_energy+0x32>
      badness1 = quant_coarse_energy_impl(m, start, end, eBands, oldEBands_intra, budget,
   2d20a:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
            tell, e_prob_model[LM][1], error_intra, enc, C, LM, 1, max_decay, lfe);
   2d20e:	4a39      	ldr	r2, [pc, #228]	; (2d2f4 <quant_coarse_energy+0x434>)
   2d210:	617a      	str	r2, [r7, #20]
      badness1 = quant_coarse_energy_impl(m, start, end, eBands, oldEBands_intra, budget,
   2d212:	930a      	str	r3, [sp, #40]	; 0x28
            tell, e_prob_model[LM][1], error_intra, enc, C, LM, 1, max_decay, lfe);
   2d214:	69fb      	ldr	r3, [r7, #28]
      badness1 = quant_coarse_energy_impl(m, start, end, eBands, oldEBands_intra, budget,
   2d216:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
   2d21a:	f8d7 10d8 	ldr.w	r1, [r7, #216]	; 0xd8
   2d21e:	9107      	str	r1, [sp, #28]
   2d220:	f8d7 10d4 	ldr.w	r1, [r7, #212]	; 0xd4
   2d224:	e9cd 8105 	strd	r8, r1, [sp, #20]
   2d228:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   2d22a:	9104      	str	r1, [sp, #16]
   2d22c:	6a79      	ldr	r1, [r7, #36]	; 0x24
   2d22e:	9102      	str	r1, [sp, #8]
   2d230:	f8d7 10c8 	ldr.w	r1, [r7, #200]	; 0xc8
   2d234:	9101      	str	r1, [sp, #4]
            tell, e_prob_model[LM][1], error_intra, enc, C, LM, 1, max_decay, lfe);
   2d236:	332a      	adds	r3, #42	; 0x2a
      badness1 = quant_coarse_energy_impl(m, start, end, eBands, oldEBands_intra, budget,
   2d238:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   2d23a:	9100      	str	r1, [sp, #0]
            tell, e_prob_model[LM][1], error_intra, enc, C, LM, 1, max_decay, lfe);
   2d23c:	4413      	add	r3, r2
      badness1 = quant_coarse_energy_impl(m, start, end, eBands, oldEBands_intra, budget,
   2d23e:	2201      	movs	r2, #1
   2d240:	9303      	str	r3, [sp, #12]
   2d242:	9208      	str	r2, [sp, #32]
   2d244:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
   2d248:	69ba      	ldr	r2, [r7, #24]
   2d24a:	6b79      	ldr	r1, [r7, #52]	; 0x34
   2d24c:	6a38      	ldr	r0, [r7, #32]
   2d24e:	f7ff fd07 	bl	2cc60 <quant_coarse_energy_impl.isra.3>
   if (!intra)
   2d252:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
   2d256:	2b00      	cmp	r3, #0
   2d258:	f47f af12 	bne.w	2d080 <quant_coarse_energy+0x1c0>
      badness1 = quant_coarse_energy_impl(m, start, end, eBands, oldEBands_intra, budget,
   2d25c:	f8c7 00e0 	str.w	r0, [r7, #224]	; 0xe0
   2d260:	e736      	b.n	2d0d0 <quant_coarse_energy+0x210>
   intra = force_intra || (!two_pass && *delayedIntra>2*C*(end-start) && nbAvailableBytes > (end-start)*C);
   2d262:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
   2d266:	f8c7 20e0 	str.w	r2, [r7, #224]	; 0xe0
   2d26a:	e642      	b.n	2cef2 <quant_coarse_energy+0x32>
      if (two_pass && (badness1 < badness2 || (badness1 == badness2 && ((opus_int32)ec_tell_frac(enc))+intra_bias > tell_intra)))
   2d26c:	4640      	mov	r0, r8
   2d26e:	f7fc fa5d 	bl	2972c <ec_tell_frac>
   intra_bias = (opus_int32)((budget**delayedIntra*loss_rate)/(C*512));
   2d272:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
   2d276:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
   2d27a:	fb03 f302 	mul.w	r3, r3, r2
   2d27e:	68fa      	ldr	r2, [r7, #12]
   2d280:	fb02 f203 	mul.w	r2, r2, r3
   2d284:	4613      	mov	r3, r2
   2d286:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
   2d28a:	0252      	lsls	r2, r2, #9
   2d28c:	fbb3 f3f2 	udiv	r3, r3, r2
      if (two_pass && (badness1 < badness2 || (badness1 == badness2 && ((opus_int32)ec_tell_frac(enc))+intra_bias > tell_intra)))
   2d290:	683a      	ldr	r2, [r7, #0]
   2d292:	4403      	add	r3, r0
   2d294:	4293      	cmp	r3, r2
   2d296:	dd85      	ble.n	2d1a4 <quant_coarse_energy+0x2e4>
         *enc = enc_intra_state;
   2d298:	f107 0468 	add.w	r4, r7, #104	; 0x68
   2d29c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   2d29e:	e8a8 000f 	stmia.w	r8!, {r0, r1, r2, r3}
   2d2a2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   2d2a4:	e8a8 000f 	stmia.w	r8!, {r0, r1, r2, r3}
   2d2a8:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
   2d2ac:	e888 000f 	stmia.w	r8, {r0, r1, r2, r3}
         OPUS_COPY(intra_buf, intra_bits, nintra_bytes - nstart_bytes);
   2d2b0:	e9d7 1201 	ldrd	r1, r2, [r7, #4]
   2d2b4:	4628      	mov	r0, r5
   2d2b6:	f7de ff23 	bl	c100 <memcpy>
         OPUS_COPY(oldEBands, oldEBands_intra, C*m->nbEBands);
   2d2ba:	6b3c      	ldr	r4, [r7, #48]	; 0x30
   2d2bc:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
   2d2c0:	68a3      	ldr	r3, [r4, #8]
   2d2c2:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   2d2c4:	f8d7 00c4 	ldr.w	r0, [r7, #196]	; 0xc4
   2d2c8:	fb03 f302 	mul.w	r3, r3, r2
   2d2cc:	005a      	lsls	r2, r3, #1
   2d2ce:	f7de ff17 	bl	c100 <memcpy>
         OPUS_COPY(error, error_intra, C*m->nbEBands);
   2d2d2:	68a2      	ldr	r2, [r4, #8]
   2d2d4:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
   2d2d8:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   2d2da:	f8d7 00cc 	ldr.w	r0, [r7, #204]	; 0xcc
   2d2de:	fb02 f203 	mul.w	r2, r2, r3
   2d2e2:	0052      	lsls	r2, r2, #1
   2d2e4:	f7de ff0c 	bl	c100 <memcpy>
   2d2e8:	f8d7 d010 	ldr.w	sp, [r7, #16]
   2d2ec:	e6df      	b.n	2d0ae <quant_coarse_energy+0x1ee>
   2d2ee:	bf00      	nop
   2d2f0:	0003b46a 	.word	0x0003b46a
   2d2f4:	0003b440 	.word	0x0003b440
   2d2f8:	0003b590 	.word	0x0003b590

0002d2fc <quant_fine_energy>:

void quant_fine_energy(const CELTMode *m, int start, int end, opus_val16 *oldEBands, opus_val16 *error, int *fine_quant, ec_enc *enc, int C)
{
   2d2fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   int i, c;

   /* Encode finer resolution */
   for (i=start;i<end;i++)
   2d300:	4291      	cmp	r1, r2
{
   2d302:	b083      	sub	sp, #12
   2d304:	4682      	mov	sl, r0
   2d306:	e9dd 600c 	ldrd	r6, r0, [sp, #48]	; 0x30
   for (i=start;i<end;i++)
   2d30a:	da4c      	bge.n	2d3a6 <quant_fine_energy+0xaa>
   2d30c:	460f      	mov	r7, r1
   2d30e:	1f04      	subs	r4, r0, #4
   2d310:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
   2d314:	469b      	mov	fp, r3
   2d316:	3901      	subs	r1, #1
   2d318:	eb04 0382 	add.w	r3, r4, r2, lsl #2
   2d31c:	eb00 0881 	add.w	r8, r0, r1, lsl #2
   2d320:	9301      	str	r3, [sp, #4]
   {
      opus_int16 frac = 1<<fine_quant[i];
   2d322:	f858 2f04 	ldr.w	r2, [r8, #4]!
      if (fine_quant[i] <= 0)
   2d326:	2a00      	cmp	r2, #0
   2d328:	dd38      	ble.n	2d39c <quant_fine_energy+0xa0>
      opus_int16 frac = 1<<fine_quant[i];
   2d32a:	2301      	movs	r3, #1
   2d32c:	fa03 f902 	lsl.w	r9, r3, r2
   2d330:	fa0f f989 	sxth.w	r9, r9
         q2 = (error[i+c*m->nbEBands]+QCONST16(.5f,DB_SHIFT))>>(DB_SHIFT-fine_quant[i]);
#else
         q2 = (int)floor((error[i+c*m->nbEBands]+.5f)*frac);
#endif
         if (q2 > frac-1)
            q2 = frac-1;
   2d334:	f109 33ff 	add.w	r3, r9, #4294967295	; 0xffffffff
   2d338:	f8da 0008 	ldr.w	r0, [sl, #8]
   2d33c:	9300      	str	r3, [sp, #0]
      c=0;
   2d33e:	2500      	movs	r5, #0
         q2 = (error[i+c*m->nbEBands]+QCONST16(.5f,DB_SHIFT))>>(DB_SHIFT-fine_quant[i]);
   2d340:	fb00 7005 	mla	r0, r0, r5, r7
   2d344:	f1c2 010a 	rsb	r1, r2, #10
   2d348:	f936 4010 	ldrsh.w	r4, [r6, r0, lsl #1]
            q2 = frac-1;
   2d34c:	9b00      	ldr	r3, [sp, #0]
         if (q2<0)
            q2 = 0;
         ec_enc_bits(enc, q2, fine_quant[i]);
   2d34e:	980e      	ldr	r0, [sp, #56]	; 0x38
         q2 = (error[i+c*m->nbEBands]+QCONST16(.5f,DB_SHIFT))>>(DB_SHIFT-fine_quant[i]);
   2d350:	f504 7400 	add.w	r4, r4, #512	; 0x200
   2d354:	410c      	asrs	r4, r1
            q2 = frac-1;
   2d356:	454c      	cmp	r4, r9
   2d358:	bfa8      	it	ge
   2d35a:	461c      	movge	r4, r3
         ec_enc_bits(enc, q2, fine_quant[i]);
   2d35c:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
   2d360:	4621      	mov	r1, r4
   2d362:	f7fc fe57 	bl	2a014 <ec_enc_bits>
#ifdef FIXED_POINT
         offset = SUB16(SHR32(SHL32(EXTEND32(q2),DB_SHIFT)+QCONST16(.5f,DB_SHIFT),fine_quant[i]),QCONST16(.5f,DB_SHIFT));
#else
         offset = (q2+.5f)*(1<<(14-fine_quant[i]))*(1.f/16384) - .5f;
#endif
         oldEBands[i+c*m->nbEBands] += offset;
   2d366:	f8da 0008 	ldr.w	r0, [sl, #8]
         offset = SUB16(SHR32(SHL32(EXTEND32(q2),DB_SHIFT)+QCONST16(.5f,DB_SHIFT),fine_quant[i]),QCONST16(.5f,DB_SHIFT));
   2d36a:	f8d8 2000 	ldr.w	r2, [r8]
         error[i+c*m->nbEBands] -= offset;
         /*printf ("%f ", error[i] - offset);*/
      } while (++c < C);
   2d36e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
         offset = SUB16(SHR32(SHL32(EXTEND32(q2),DB_SHIFT)+QCONST16(.5f,DB_SHIFT),fine_quant[i]),QCONST16(.5f,DB_SHIFT));
   2d370:	02a1      	lsls	r1, r4, #10
         oldEBands[i+c*m->nbEBands] += offset;
   2d372:	fb05 7c00 	mla	ip, r5, r0, r7
         offset = SUB16(SHR32(SHL32(EXTEND32(q2),DB_SHIFT)+QCONST16(.5f,DB_SHIFT),fine_quant[i]),QCONST16(.5f,DB_SHIFT));
   2d376:	f501 7100 	add.w	r1, r1, #512	; 0x200
   2d37a:	4111      	asrs	r1, r2
         oldEBands[i+c*m->nbEBands] += offset;
   2d37c:	f83b e01c 	ldrh.w	lr, [fp, ip, lsl #1]
         offset = SUB16(SHR32(SHL32(EXTEND32(q2),DB_SHIFT)+QCONST16(.5f,DB_SHIFT),fine_quant[i]),QCONST16(.5f,DB_SHIFT));
   2d380:	f5a1 7100 	sub.w	r1, r1, #512	; 0x200
   2d384:	b289      	uxth	r1, r1
         oldEBands[i+c*m->nbEBands] += offset;
   2d386:	448e      	add	lr, r1
   2d388:	f82b e01c 	strh.w	lr, [fp, ip, lsl #1]
         error[i+c*m->nbEBands] -= offset;
   2d38c:	f836 401c 	ldrh.w	r4, [r6, ip, lsl #1]
      } while (++c < C);
   2d390:	3501      	adds	r5, #1
         error[i+c*m->nbEBands] -= offset;
   2d392:	1a61      	subs	r1, r4, r1
      } while (++c < C);
   2d394:	429d      	cmp	r5, r3
         error[i+c*m->nbEBands] -= offset;
   2d396:	f826 101c 	strh.w	r1, [r6, ip, lsl #1]
      } while (++c < C);
   2d39a:	dbd1      	blt.n	2d340 <quant_fine_energy+0x44>
   for (i=start;i<end;i++)
   2d39c:	9b01      	ldr	r3, [sp, #4]
   2d39e:	4598      	cmp	r8, r3
   2d3a0:	f107 0701 	add.w	r7, r7, #1
   2d3a4:	d1bd      	bne.n	2d322 <quant_fine_energy+0x26>
   }
}
   2d3a6:	b003      	add	sp, #12
   2d3a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0002d3ac <quant_energy_finalise>:

void quant_energy_finalise(const CELTMode *m, int start, int end, opus_val16 *oldEBands, opus_val16 *error, int *fine_quant, int *fine_priority, int bits_left, ec_enc *enc, int C)
{
   2d3ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2d3b0:	b087      	sub	sp, #28
   2d3b2:	f101 4480 	add.w	r4, r1, #1073741824	; 0x40000000
   2d3b6:	9104      	str	r1, [sp, #16]
   2d3b8:	e9dd 7110 	ldrd	r7, r1, [sp, #64]	; 0x40
   2d3bc:	3c01      	subs	r4, #1
   2d3be:	469b      	mov	fp, r3
   2d3c0:	e9cd 0201 	strd	r0, r2, [sp, #4]
   2d3c4:	eb01 0384 	add.w	r3, r1, r4, lsl #2
   2d3c8:	9305      	str	r3, [sp, #20]
   2d3ca:	f8dd 804c 	ldr.w	r8, [sp, #76]	; 0x4c
   2d3ce:	f8dd a054 	ldr.w	sl, [sp, #84]	; 0x54
   int i, prio, c;

   /* Use up the remaining bits */
   for (prio=0;prio<2;prio++)
   2d3d2:	2300      	movs	r3, #0
   2d3d4:	9303      	str	r3, [sp, #12]
   {
      for (i=start;i<end && bits_left>=C ;i++)
   2d3d6:	9b04      	ldr	r3, [sp, #16]
   2d3d8:	4293      	cmp	r3, r2
   2d3da:	da43      	bge.n	2d464 <quant_energy_finalise+0xb8>
   2d3dc:	45c2      	cmp	sl, r8
   2d3de:	dc41      	bgt.n	2d464 <quant_energy_finalise+0xb8>
   2d3e0:	461e      	mov	r6, r3
   2d3e2:	f8dd 9014 	ldr.w	r9, [sp, #20]
   2d3e6:	e005      	b.n	2d3f4 <quant_energy_finalise+0x48>
   2d3e8:	9b02      	ldr	r3, [sp, #8]
   2d3ea:	3601      	adds	r6, #1
   2d3ec:	42b3      	cmp	r3, r6
   2d3ee:	d039      	beq.n	2d464 <quant_energy_finalise+0xb8>
   2d3f0:	45d0      	cmp	r8, sl
   2d3f2:	db37      	blt.n	2d464 <quant_energy_finalise+0xb8>
      {
         if (fine_quant[i] >= MAX_FINE_BITS || fine_priority[i]!=prio)
   2d3f4:	f859 2f04 	ldr.w	r2, [r9, #4]!
   2d3f8:	2a07      	cmp	r2, #7
   2d3fa:	dcf5      	bgt.n	2d3e8 <quant_energy_finalise+0x3c>
   2d3fc:	9b12      	ldr	r3, [sp, #72]	; 0x48
   2d3fe:	f853 2026 	ldr.w	r2, [r3, r6, lsl #2]
   2d402:	9b03      	ldr	r3, [sp, #12]
   2d404:	429a      	cmp	r2, r3
   2d406:	d1ef      	bne.n	2d3e8 <quant_energy_finalise+0x3c>
   2d408:	9b01      	ldr	r3, [sp, #4]
   2d40a:	6899      	ldr	r1, [r3, #8]
            continue;
         c=0;
   2d40c:	2500      	movs	r5, #0
         do {
            int q2;
            opus_val16 offset;
            q2 = error[i+c*m->nbEBands]<0 ? 0 : 1;
   2d40e:	fb01 6105 	mla	r1, r1, r5, r6
            ec_enc_bits(enc, q2, 1);
   2d412:	2201      	movs	r2, #1
            q2 = error[i+c*m->nbEBands]<0 ? 0 : 1;
   2d414:	f837 4011 	ldrh.w	r4, [r7, r1, lsl #1]
            ec_enc_bits(enc, q2, 1);
   2d418:	9814      	ldr	r0, [sp, #80]	; 0x50
            q2 = error[i+c*m->nbEBands]<0 ? 0 : 1;
   2d41a:	43e4      	mvns	r4, r4
   2d41c:	f3c4 34c0 	ubfx	r4, r4, #15, #1
            ec_enc_bits(enc, q2, 1);
   2d420:	4621      	mov	r1, r4
   2d422:	f7fc fdf7 	bl	2a014 <ec_enc_bits>
#ifdef FIXED_POINT
            offset = SHR16(SHL16(q2,DB_SHIFT)-QCONST16(.5f,DB_SHIFT),fine_quant[i]+1);
#else
            offset = (q2-.5f)*(1<<(14-fine_quant[i]-1))*(1.f/16384);
#endif
            oldEBands[i+c*m->nbEBands] += offset;
   2d426:	9b01      	ldr	r3, [sp, #4]
            offset = SHR16(SHL16(q2,DB_SHIFT)-QCONST16(.5f,DB_SHIFT),fine_quant[i]+1);
   2d428:	f8d9 0000 	ldr.w	r0, [r9]
            oldEBands[i+c*m->nbEBands] += offset;
   2d42c:	6899      	ldr	r1, [r3, #8]
            offset = SHR16(SHL16(q2,DB_SHIFT)-QCONST16(.5f,DB_SHIFT),fine_quant[i]+1);
   2d42e:	02a4      	lsls	r4, r4, #10
            oldEBands[i+c*m->nbEBands] += offset;
   2d430:	fb05 6201 	mla	r2, r5, r1, r6
            offset = SHR16(SHL16(q2,DB_SHIFT)-QCONST16(.5f,DB_SHIFT),fine_quant[i]+1);
   2d434:	3001      	adds	r0, #1
   2d436:	f5a4 7400 	sub.w	r4, r4, #512	; 0x200
   2d43a:	4104      	asrs	r4, r0
            oldEBands[i+c*m->nbEBands] += offset;
   2d43c:	f83b 0012 	ldrh.w	r0, [fp, r2, lsl #1]
   2d440:	b2a4      	uxth	r4, r4
   2d442:	4420      	add	r0, r4
   2d444:	f82b 0012 	strh.w	r0, [fp, r2, lsl #1]
            error[i+c*m->nbEBands] -= offset;
   2d448:	f837 0012 	ldrh.w	r0, [r7, r2, lsl #1]
            bits_left--;
         } while (++c < C);
   2d44c:	3501      	adds	r5, #1
            error[i+c*m->nbEBands] -= offset;
   2d44e:	1b04      	subs	r4, r0, r4
         } while (++c < C);
   2d450:	45aa      	cmp	sl, r5
            bits_left--;
   2d452:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
            error[i+c*m->nbEBands] -= offset;
   2d456:	f827 4012 	strh.w	r4, [r7, r2, lsl #1]
         } while (++c < C);
   2d45a:	dcd8      	bgt.n	2d40e <quant_energy_finalise+0x62>
      for (i=start;i<end && bits_left>=C ;i++)
   2d45c:	9b02      	ldr	r3, [sp, #8]
   2d45e:	3601      	adds	r6, #1
   2d460:	42b3      	cmp	r3, r6
   2d462:	d1c5      	bne.n	2d3f0 <quant_energy_finalise+0x44>
   for (prio=0;prio<2;prio++)
   2d464:	9b03      	ldr	r3, [sp, #12]
   2d466:	b91b      	cbnz	r3, 2d470 <quant_energy_finalise+0xc4>
   2d468:	2301      	movs	r3, #1
   2d46a:	9303      	str	r3, [sp, #12]
   2d46c:	9a02      	ldr	r2, [sp, #8]
   2d46e:	e7b2      	b.n	2d3d6 <quant_energy_finalise+0x2a>
      }
   }
}
   2d470:	b007      	add	sp, #28
   2d472:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2d476:	bf00      	nop

0002d478 <amp2Log2>:
   }
}

void amp2Log2(const CELTMode *m, int effEnd, int end,
      celt_ener *bandE, opus_val16 *bandLogE, int C)
{
   2d478:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2d47c:	b087      	sub	sp, #28
   2d47e:	4688      	mov	r8, r1
   2d480:	9203      	str	r2, [sp, #12]
   2d482:	3a01      	subs	r2, #1
   2d484:	9305      	str	r3, [sp, #20]
   2d486:	1a53      	subs	r3, r2, r1
   2d488:	9304      	str	r3, [sp, #16]
   2d48a:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
   2d48e:	9002      	str	r0, [sp, #8]
   int c, i;
   c=0;
   2d490:	2300      	movs	r3, #0
   2d492:	9301      	str	r3, [sp, #4]
   frac = ADD16(C[0], MULT16_16_Q15(n, ADD16(C[1], MULT16_16_Q15(n, ADD16(C[2], MULT16_16_Q15(n, ADD16(C[3], MULT16_16_Q15(n, C[4]))))))));
   2d494:	f64f 2b87 	movw	fp, #64135	; 0xfa87
   2d498:	f64e 3a9f 	movw	sl, #60319	; 0xeb9f
   2d49c:	f643 5e82 	movw	lr, #15746	; 0x3d82
   do {
      for (i=0;i<effEnd;i++)
   2d4a0:	f1b8 0f00 	cmp.w	r8, #0
   2d4a4:	dd51      	ble.n	2d54a <amp2Log2+0xd2>
      {
         bandLogE[i+c*m->nbEBands] =
               celt_log2(bandE[i+c*m->nbEBands])
   2d4a6:	9b02      	ldr	r3, [sp, #8]
   2d4a8:	4f56      	ldr	r7, [pc, #344]	; (2d604 <amp2Log2+0x18c>)
   2d4aa:	689d      	ldr	r5, [r3, #8]
   2d4ac:	9b01      	ldr	r3, [sp, #4]
   2d4ae:	fb05 f503 	mul.w	r5, r5, r3
   2d4b2:	f105 4600 	add.w	r6, r5, #2147483648	; 0x80000000
   2d4b6:	9b05      	ldr	r3, [sp, #20]
   2d4b8:	eb05 0c08 	add.w	ip, r5, r8
   2d4bc:	3e01      	subs	r6, #1
   2d4be:	eb09 0646 	add.w	r6, r9, r6, lsl #1
   2d4c2:	eb03 0c8c 	add.w	ip, r3, ip, lsl #2
   2d4c6:	eb03 0585 	add.w	r5, r3, r5, lsl #2
   2d4ca:	f855 1b04 	ldr.w	r1, [r5], #4
   return EC_ILOG(x)-1;
   2d4ce:	fab1 f281 	clz	r2, r1
   2d4d2:	f1c2 001f 	rsb	r0, r2, #31
   2d4d6:	b280      	uxth	r0, r0
   n = VSHR32(x,i-15)-32768-16384;
   2d4d8:	f1a0 030f 	sub.w	r3, r0, #15
   2d4dc:	fa41 f303 	asr.w	r3, r1, r3
   2d4e0:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
   2d4e4:	f1c0 040f 	rsb	r4, r0, #15
   if (x==0)
   2d4e8:	2900      	cmp	r1, #0
   2d4ea:	f000 8086 	beq.w	2d5fa <amp2Log2+0x182>
   n = VSHR32(x,i-15)-32768-16384;
   2d4ee:	280f      	cmp	r0, #15
   2d4f0:	bf9c      	itt	ls
   2d4f2:	fa01 f304 	lslls.w	r3, r1, r4
   2d4f6:	f503 4380 	addls.w	r3, r3, #16384	; 0x4000
   2d4fa:	b21b      	sxth	r3, r3
   frac = ADD16(C[0], MULT16_16_Q15(n, ADD16(C[1], MULT16_16_Q15(n, ADD16(C[2], MULT16_16_Q15(n, ADD16(C[3], MULT16_16_Q15(n, C[4]))))))));
   2d4fc:	fb13 f10b 	smulbb	r1, r3, fp
   2d500:	13c9      	asrs	r1, r1, #15
   2d502:	f601 11f1 	addw	r1, r1, #2545	; 0x9f1
   2d506:	b289      	uxth	r1, r1
   2d508:	fb03 f101 	mul.w	r1, r3, r1
   2d50c:	eb0a 31e1 	add.w	r1, sl, r1, asr #15
   2d510:	fb11 f103 	smulbb	r1, r1, r3
   2d514:	eb0e 31e1 	add.w	r1, lr, r1, asr #15
   2d518:	b289      	uxth	r1, r1
   2d51a:	fb03 f301 	mul.w	r3, r3, r1
   2d51e:	13db      	asrs	r3, r3, #15
   2d520:	f5a3 53d4 	sub.w	r3, r3, #6784	; 0x1a80
   2d524:	3b09      	subs	r3, #9
   return SHL16(i-13,DB_SHIFT)+SHR16(frac,14-DB_SHIFT);
   2d526:	f1c2 0212 	rsb	r2, r2, #18
   2d52a:	f343 130b 	sbfx	r3, r3, #4, #12
   2d52e:	eb03 2382 	add.w	r3, r3, r2, lsl #10
   2d532:	b29b      	uxth	r3, r3
               - SHL16((opus_val16)eMeans[i],6);
   2d534:	f917 2b01 	ldrsb.w	r2, [r7], #1
   2d538:	b292      	uxth	r2, r2
   2d53a:	0192      	lsls	r2, r2, #6
#ifdef FIXED_POINT
         /* Compensate for bandE[] being Q12 but celt_log2() taking a Q14 input. */
         bandLogE[i+c*m->nbEBands] += QCONST16(2.f, DB_SHIFT);
   2d53c:	f5c2 6200 	rsb	r2, r2, #2048	; 0x800
   2d540:	4413      	add	r3, r2
      for (i=0;i<effEnd;i++)
   2d542:	45ac      	cmp	ip, r5
         bandLogE[i+c*m->nbEBands] += QCONST16(2.f, DB_SHIFT);
   2d544:	f826 3f02 	strh.w	r3, [r6, #2]!
      for (i=0;i<effEnd;i++)
   2d548:	d1bf      	bne.n	2d4ca <amp2Log2+0x52>
#endif
      }
      for (i=effEnd;i<end;i++)
   2d54a:	9803      	ldr	r0, [sp, #12]
   2d54c:	4580      	cmp	r8, r0
   2d54e:	da48      	bge.n	2d5e2 <amp2Log2+0x16a>
         bandLogE[c*m->nbEBands+i] = -QCONST16(14.f,DB_SHIFT);
   2d550:	9b02      	ldr	r3, [sp, #8]
   2d552:	6899      	ldr	r1, [r3, #8]
   2d554:	9b01      	ldr	r3, [sp, #4]
   2d556:	eba0 0608 	sub.w	r6, r0, r8
   2d55a:	fb01 f103 	mul.w	r1, r1, r3
   2d55e:	9804      	ldr	r0, [sp, #16]
   2d560:	eb01 0208 	add.w	r2, r1, r8
   2d564:	eb09 0342 	add.w	r3, r9, r2, lsl #1
   2d568:	2804      	cmp	r0, #4
   2d56a:	f3c3 0340 	ubfx	r3, r3, #1, #1
   2d56e:	d947      	bls.n	2d600 <amp2Log2+0x188>
   2d570:	2b00      	cmp	r3, #0
   2d572:	d040      	beq.n	2d5f6 <amp2Log2+0x17e>
   2d574:	f44f 4048 	mov.w	r0, #51200	; 0xc800
   2d578:	f829 0012 	strh.w	r0, [r9, r2, lsl #1]
      for (i=effEnd;i<end;i++)
   2d57c:	f108 0001 	add.w	r0, r8, #1
   2d580:	1af6      	subs	r6, r6, r3
   2d582:	4413      	add	r3, r2
   2d584:	eb09 0343 	add.w	r3, r9, r3, lsl #1
   2d588:	0875      	lsrs	r5, r6, #1
         bandLogE[c*m->nbEBands+i] = -QCONST16(14.f,DB_SHIFT);
   2d58a:	2200      	movs	r2, #0
   2d58c:	f04f 24c8 	mov.w	r4, #3355494400	; 0xc800c800
   2d590:	3201      	adds	r2, #1
   2d592:	4295      	cmp	r5, r2
   2d594:	f843 4b04 	str.w	r4, [r3], #4
   2d598:	d8fa      	bhi.n	2d590 <amp2Log2+0x118>
   2d59a:	f026 0301 	bic.w	r3, r6, #1
   2d59e:	42b3      	cmp	r3, r6
   2d5a0:	4418      	add	r0, r3
   2d5a2:	d01e      	beq.n	2d5e2 <amp2Log2+0x16a>
      for (i=effEnd;i<end;i++)
   2d5a4:	9d03      	ldr	r5, [sp, #12]
         bandLogE[c*m->nbEBands+i] = -QCONST16(14.f,DB_SHIFT);
   2d5a6:	180c      	adds	r4, r1, r0
      for (i=effEnd;i<end;i++)
   2d5a8:	1c42      	adds	r2, r0, #1
         bandLogE[c*m->nbEBands+i] = -QCONST16(14.f,DB_SHIFT);
   2d5aa:	f44f 4348 	mov.w	r3, #51200	; 0xc800
      for (i=effEnd;i<end;i++)
   2d5ae:	42aa      	cmp	r2, r5
         bandLogE[c*m->nbEBands+i] = -QCONST16(14.f,DB_SHIFT);
   2d5b0:	f829 3014 	strh.w	r3, [r9, r4, lsl #1]
      for (i=effEnd;i<end;i++)
   2d5b4:	da15      	bge.n	2d5e2 <amp2Log2+0x16a>
         bandLogE[c*m->nbEBands+i] = -QCONST16(14.f,DB_SHIFT);
   2d5b6:	440a      	add	r2, r1
      for (i=effEnd;i<end;i++)
   2d5b8:	1c84      	adds	r4, r0, #2
   2d5ba:	42ac      	cmp	r4, r5
         bandLogE[c*m->nbEBands+i] = -QCONST16(14.f,DB_SHIFT);
   2d5bc:	f829 3012 	strh.w	r3, [r9, r2, lsl #1]
      for (i=effEnd;i<end;i++)
   2d5c0:	da0f      	bge.n	2d5e2 <amp2Log2+0x16a>
         bandLogE[c*m->nbEBands+i] = -QCONST16(14.f,DB_SHIFT);
   2d5c2:	440c      	add	r4, r1
      for (i=effEnd;i<end;i++)
   2d5c4:	1cc2      	adds	r2, r0, #3
   2d5c6:	4295      	cmp	r5, r2
         bandLogE[c*m->nbEBands+i] = -QCONST16(14.f,DB_SHIFT);
   2d5c8:	f829 3014 	strh.w	r3, [r9, r4, lsl #1]
      for (i=effEnd;i<end;i++)
   2d5cc:	dd09      	ble.n	2d5e2 <amp2Log2+0x16a>
   2d5ce:	3004      	adds	r0, #4
   2d5d0:	4285      	cmp	r5, r0
         bandLogE[c*m->nbEBands+i] = -QCONST16(14.f,DB_SHIFT);
   2d5d2:	440a      	add	r2, r1
   2d5d4:	bfc8      	it	gt
   2d5d6:	1840      	addgt	r0, r0, r1
   2d5d8:	f829 3012 	strh.w	r3, [r9, r2, lsl #1]
   2d5dc:	bfc8      	it	gt
   2d5de:	f829 3010 	strhgt.w	r3, [r9, r0, lsl #1]
   } while (++c < C);
   2d5e2:	9b01      	ldr	r3, [sp, #4]
   2d5e4:	9a11      	ldr	r2, [sp, #68]	; 0x44
   2d5e6:	3301      	adds	r3, #1
   2d5e8:	4293      	cmp	r3, r2
   2d5ea:	9301      	str	r3, [sp, #4]
   2d5ec:	f6ff af58 	blt.w	2d4a0 <amp2Log2+0x28>
}
   2d5f0:	b007      	add	sp, #28
   2d5f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
         bandLogE[c*m->nbEBands+i] = -QCONST16(14.f,DB_SHIFT);
   2d5f6:	4640      	mov	r0, r8
   2d5f8:	e7c2      	b.n	2d580 <amp2Log2+0x108>
   if (x==0)
   2d5fa:	f248 0301 	movw	r3, #32769	; 0x8001
   2d5fe:	e799      	b.n	2d534 <amp2Log2+0xbc>
   2d600:	4640      	mov	r0, r8
   2d602:	e7cf      	b.n	2d5a4 <amp2Log2+0x12c>
   2d604:	0003b424 	.word	0x0003b424

0002d608 <clt_compute_allocation>:
   return codedBands;
}

int clt_compute_allocation(const CELTMode *m, int start, int end, const int *offsets, const int *cap, int alloc_trim, int *intensity, int *dual_stereo,
      opus_int32 total, opus_int32 *balance, int *pulses, int *ebits, int *fine_priority, int C, int LM, ec_ctx *ec, int encode, int prev, int signalBandwidth)
{
   2d608:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2d60c:	b09d      	sub	sp, #116	; 0x74
   2d60e:	af00      	add	r7, sp, #0
   2d610:	4682      	mov	sl, r0
   2d612:	f8d7 00a8 	ldr.w	r0, [r7, #168]	; 0xa8
   2d616:	633b      	str	r3, [r7, #48]	; 0x30

   total = IMAX(total, 0);
   len = m->nbEBands;
   skip_start = start;
   /* Reserve a bit to signal the end of manually skipped bands. */
   skip_rsv = total >= 1<<BITRES ? 1<<BITRES : 0;
   2d618:	2807      	cmp	r0, #7
   total = IMAX(total, 0);
   2d61a:	ea20 73e0 	bic.w	r3, r0, r0, asr #31
   2d61e:	65fb      	str	r3, [r7, #92]	; 0x5c
   2d620:	bfc5      	ittet	gt
   2d622:	3b08      	subgt	r3, #8
   2d624:	65fb      	strgt	r3, [r7, #92]	; 0x5c
   skip_rsv = total >= 1<<BITRES ? 1<<BITRES : 0;
   2d626:	2300      	movle	r3, #0
   2d628:	2308      	movgt	r3, #8
   2d62a:	60bb      	str	r3, [r7, #8]
   total -= skip_rsv;
   /* Reserve bits for the intensity and dual stereo parameters. */
   intensity_rsv = dual_stereo_rsv = 0;
   if (C==2)
   2d62c:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
   len = m->nbEBands;
   2d630:	f8da 4008 	ldr.w	r4, [sl, #8]
   2d634:	62fc      	str	r4, [r7, #44]	; 0x2c
   if (C==2)
   2d636:	2b02      	cmp	r3, #2
{
   2d638:	66b9      	str	r1, [r7, #104]	; 0x68
   2d63a:	657a      	str	r2, [r7, #84]	; 0x54
   if (C==2)
   2d63c:	f000 8609 	beq.w	2e252 <clt_compute_allocation+0xc4a>
   intensity_rsv = dual_stereo_rsv = 0;
   2d640:	2300      	movs	r3, #0
   2d642:	613b      	str	r3, [r7, #16]
   {
      intensity_rsv = LOG2_FRAC_TABLE[end-start];
      if (intensity_rsv>total)
         intensity_rsv = 0;
   2d644:	653b      	str	r3, [r7, #80]	; 0x50
         total -= intensity_rsv;
         dual_stereo_rsv = total>=1<<BITRES ? 1<<BITRES : 0;
         total -= dual_stereo_rsv;
      }
   }
   ALLOC(bits1, len, int);
   2d646:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   ALLOC(bits2, len, int);
   ALLOC(thresh, len, int);
   ALLOC(trim_offset, len, int);

   for (j=start;j<end;j++)
   2d648:	6d7a      	ldr	r2, [r7, #84]	; 0x54
   ALLOC(bits1, len, int);
   2d64a:	009b      	lsls	r3, r3, #2
   2d64c:	330a      	adds	r3, #10
   2d64e:	f023 0307 	bic.w	r3, r3, #7
   2d652:	ebad 0d03 	sub.w	sp, sp, r3
   2d656:	f8c7 d038 	str.w	sp, [r7, #56]	; 0x38
   ALLOC(bits2, len, int);
   2d65a:	ebad 0d03 	sub.w	sp, sp, r3
   2d65e:	f8c7 d034 	str.w	sp, [r7, #52]	; 0x34
   ALLOC(thresh, len, int);
   2d662:	ebad 0d03 	sub.w	sp, sp, r3
   2d666:	f8c7 d040 	str.w	sp, [r7, #64]	; 0x40
   ALLOC(trim_offset, len, int);
   2d66a:	ebad 0d03 	sub.w	sp, sp, r3
   2d66e:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
   2d672:	00db      	lsls	r3, r3, #3
   2d674:	667b      	str	r3, [r7, #100]	; 0x64
   for (j=start;j<end;j++)
   2d676:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   2d678:	4293      	cmp	r3, r2
   ALLOC(trim_offset, len, int);
   2d67a:	46ec      	mov	ip, sp
   for (j=start;j<end;j++)
   2d67c:	f280 8607 	bge.w	2e28e <clt_compute_allocation+0xc86>
   {
      /* Below this threshold, we're sure not to allocate any PVQ bits */
      thresh[j] = IMAX((C)<<BITRES, (3*(m->eBands[j+1]-m->eBands[j])<<LM<<BITRES)>>4);
   2d680:	f8da 1018 	ldr.w	r1, [sl, #24]
   2d684:	6d78      	ldr	r0, [r7, #84]	; 0x54
   2d686:	6639      	str	r1, [r7, #96]	; 0x60
   2d688:	005c      	lsls	r4, r3, #1
   2d68a:	461a      	mov	r2, r3
   2d68c:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
   2d690:	647c      	str	r4, [r7, #68]	; 0x44
   2d692:	1e45      	subs	r5, r0, #1
   2d694:	1c56      	adds	r6, r2, #1
   2d696:	eb01 0804 	add.w	r8, r1, r4
   2d69a:	f8d7 40c0 	ldr.w	r4, [r7, #192]	; 0xc0
   2d69e:	63fd      	str	r5, [r7, #60]	; 0x3c
   2d6a0:	3b05      	subs	r3, #5
   2d6a2:	42b5      	cmp	r5, r6
   2d6a4:	eba3 0b04 	sub.w	fp, r3, r4
   2d6a8:	f104 0903 	add.w	r9, r4, #3
   2d6ac:	4623      	mov	r3, r4
   2d6ae:	f340 85f9 	ble.w	2e2a4 <clt_compute_allocation+0xc9c>
   2d6b2:	6d78      	ldr	r0, [r7, #84]	; 0x54
   2d6b4:	f931 1012 	ldrsh.w	r1, [r1, r2, lsl #1]
   2d6b8:	66fa      	str	r2, [r7, #108]	; 0x6c
   2d6ba:	eba0 0e02 	sub.w	lr, r0, r2
   2d6be:	f10e 3eff 	add.w	lr, lr, #4294967295	; 0xffffffff
   2d6c2:	f8c7 a058 	str.w	sl, [r7, #88]	; 0x58
   2d6c6:	461d      	mov	r5, r3
   2d6c8:	f9b8 2002 	ldrsh.w	r2, [r8, #2]
      /* Tilt of the allocation curve */
      trim_offset[j] = C*(m->eBands[j+1]-m->eBands[j])*(alloc_trim-5-LM)*(end-j-1)
   2d6cc:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
      thresh[j] = IMAX((C)<<BITRES, (3*(m->eBands[j+1]-m->eBands[j])<<LM<<BITRES)>>4);
   2d6d0:	6e7c      	ldr	r4, [r7, #100]	; 0x64
   2d6d2:	1a51      	subs	r1, r2, r1
   2d6d4:	eb01 0041 	add.w	r0, r1, r1, lsl #1
   2d6d8:	40a8      	lsls	r0, r5
   2d6da:	f340 005b 	sbfx	r0, r0, #1, #28
      trim_offset[j] = C*(m->eBands[j+1]-m->eBands[j])*(alloc_trim-5-LM)*(end-j-1)
   2d6de:	fb01 f303 	mul.w	r3, r1, r3
      thresh[j] = IMAX((C)<<BITRES, (3*(m->eBands[j+1]-m->eBands[j])<<LM<<BITRES)>>4);
   2d6e2:	42a0      	cmp	r0, r4
            *(1<<(LM+BITRES))>>6;
      /* Giving less resolution to single-coefficient bands because they get
         more benefit from having one coarse value per coefficient*/
      if ((m->eBands[j+1]-m->eBands[j])<<LM==1)
   2d6e4:	fa01 f105 	lsl.w	r1, r1, r5
      trim_offset[j] = C*(m->eBands[j+1]-m->eBands[j])*(alloc_trim-5-LM)*(end-j-1)
   2d6e8:	fb0b f303 	mul.w	r3, fp, r3
      thresh[j] = IMAX((C)<<BITRES, (3*(m->eBands[j+1]-m->eBands[j])<<LM<<BITRES)>>4);
   2d6ec:	bfb8      	it	lt
   2d6ee:	4620      	movlt	r0, r4
      trim_offset[j] = C*(m->eBands[j+1]-m->eBands[j])*(alloc_trim-5-LM)*(end-j-1)
   2d6f0:	fb0e f303 	mul.w	r3, lr, r3
      if ((m->eBands[j+1]-m->eBands[j])<<LM==1)
   2d6f4:	2901      	cmp	r1, #1
         trim_offset[j] -= C<<BITRES;
   2d6f6:	bf08      	it	eq
   2d6f8:	6e79      	ldreq	r1, [r7, #100]	; 0x64
      thresh[j] = IMAX((C)<<BITRES, (3*(m->eBands[j+1]-m->eBands[j])<<LM<<BITRES)>>4);
   2d6fa:	6c3c      	ldr	r4, [r7, #64]	; 0x40
            *(1<<(LM+BITRES))>>6;
   2d6fc:	fa03 f309 	lsl.w	r3, r3, r9
   2d700:	ea4f 13a3 	mov.w	r3, r3, asr #6
         trim_offset[j] -= C<<BITRES;
   2d704:	bf08      	it	eq
   2d706:	1a5b      	subeq	r3, r3, r1
      thresh[j] = IMAX((C)<<BITRES, (3*(m->eBands[j+1]-m->eBands[j])<<LM<<BITRES)>>4);
   2d708:	f9b8 1004 	ldrsh.w	r1, [r8, #4]
   2d70c:	4682      	mov	sl, r0
   2d70e:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
   2d710:	1a8a      	subs	r2, r1, r2
   2d712:	f844 a020 	str.w	sl, [r4, r0, lsl #2]
      trim_offset[j] = C*(m->eBands[j+1]-m->eBands[j])*(alloc_trim-5-LM)*(end-j-1)
   2d716:	f84c 3020 	str.w	r3, [ip, r0, lsl #2]
      thresh[j] = IMAX((C)<<BITRES, (3*(m->eBands[j+1]-m->eBands[j])<<LM<<BITRES)>>4);
   2d71a:	eb02 0042 	add.w	r0, r2, r2, lsl #1
      trim_offset[j] = C*(m->eBands[j+1]-m->eBands[j])*(alloc_trim-5-LM)*(end-j-1)
   2d71e:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
      thresh[j] = IMAX((C)<<BITRES, (3*(m->eBands[j+1]-m->eBands[j])<<LM<<BITRES)>>4);
   2d722:	6e7c      	ldr	r4, [r7, #100]	; 0x64
   2d724:	40a8      	lsls	r0, r5
      trim_offset[j] = C*(m->eBands[j+1]-m->eBands[j])*(alloc_trim-5-LM)*(end-j-1)
   2d726:	fb02 fa03 	mul.w	sl, r2, r3
      thresh[j] = IMAX((C)<<BITRES, (3*(m->eBands[j+1]-m->eBands[j])<<LM<<BITRES)>>4);
   2d72a:	f340 005b 	sbfx	r0, r0, #1, #28
   2d72e:	42a0      	cmp	r0, r4
      if ((m->eBands[j+1]-m->eBands[j])<<LM==1)
   2d730:	fa02 f205 	lsl.w	r2, r2, r5
      trim_offset[j] = C*(m->eBands[j+1]-m->eBands[j])*(alloc_trim-5-LM)*(end-j-1)
   2d734:	f10e 33ff 	add.w	r3, lr, #4294967295	; 0xffffffff
   2d738:	fb0b fa0a 	mul.w	sl, fp, sl
      thresh[j] = IMAX((C)<<BITRES, (3*(m->eBands[j+1]-m->eBands[j])<<LM<<BITRES)>>4);
   2d73c:	bfb8      	it	lt
   2d73e:	4620      	movlt	r0, r4
      trim_offset[j] = C*(m->eBands[j+1]-m->eBands[j])*(alloc_trim-5-LM)*(end-j-1)
   2d740:	fb03 f30a 	mul.w	r3, r3, sl
      if ((m->eBands[j+1]-m->eBands[j])<<LM==1)
   2d744:	2a01      	cmp	r2, #1
         trim_offset[j] -= C<<BITRES;
   2d746:	bf08      	it	eq
   2d748:	6e7a      	ldreq	r2, [r7, #100]	; 0x64
      thresh[j] = IMAX((C)<<BITRES, (3*(m->eBands[j+1]-m->eBands[j])<<LM<<BITRES)>>4);
   2d74a:	6c3c      	ldr	r4, [r7, #64]	; 0x40
            *(1<<(LM+BITRES))>>6;
   2d74c:	fa03 f309 	lsl.w	r3, r3, r9
   2d750:	ea4f 13a3 	mov.w	r3, r3, asr #6
         trim_offset[j] -= C<<BITRES;
   2d754:	bf08      	it	eq
   2d756:	1a9b      	subeq	r3, r3, r2
      trim_offset[j] = C*(m->eBands[j+1]-m->eBands[j])*(alloc_trim-5-LM)*(end-j-1)
   2d758:	f84c 3026 	str.w	r3, [ip, r6, lsl #2]
   2d75c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
      thresh[j] = IMAX((C)<<BITRES, (3*(m->eBands[j+1]-m->eBands[j])<<LM<<BITRES)>>4);
   2d75e:	f844 0026 	str.w	r0, [r4, r6, lsl #2]
   2d762:	3302      	adds	r3, #2
   2d764:	66fb      	str	r3, [r7, #108]	; 0x6c
   2d766:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   2d768:	3602      	adds	r6, #2
   2d76a:	429e      	cmp	r6, r3
   2d76c:	f108 0804 	add.w	r8, r8, #4
   2d770:	f1ae 0e02 	sub.w	lr, lr, #2
   2d774:	dba8      	blt.n	2d6c8 <clt_compute_allocation+0xc0>
   2d776:	6efc      	ldr	r4, [r7, #108]	; 0x6c
   2d778:	f8d7 a058 	ldr.w	sl, [r7, #88]	; 0x58
   2d77c:	6e3a      	ldr	r2, [r7, #96]	; 0x60
   2d77e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   2d780:	f8d7 8064 	ldr.w	r8, [r7, #100]	; 0x64
   2d784:	f8d7 e0c0 	ldr.w	lr, [r7, #192]	; 0xc0
   2d788:	f8c7 a06c 	str.w	sl, [r7, #108]	; 0x6c
   2d78c:	eb03 0684 	add.w	r6, r3, r4, lsl #2
   2d790:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   2d792:	1b18      	subs	r0, r3, r4
   2d794:	eb02 0544 	add.w	r5, r2, r4, lsl #1
   2d798:	3e04      	subs	r6, #4
   2d79a:	3801      	subs	r0, #1
   2d79c:	469a      	mov	sl, r3
   2d79e:	462b      	mov	r3, r5
   2d7a0:	f9b5 2002 	ldrsh.w	r2, [r5, #2]
   2d7a4:	f9b3 3000 	ldrsh.w	r3, [r3]
   2d7a8:	1ad2      	subs	r2, r2, r3
      trim_offset[j] = C*(m->eBands[j+1]-m->eBands[j])*(alloc_trim-5-LM)*(end-j-1)
   2d7aa:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
      thresh[j] = IMAX((C)<<BITRES, (3*(m->eBands[j+1]-m->eBands[j])<<LM<<BITRES)>>4);
   2d7ae:	eb02 0142 	add.w	r1, r2, r2, lsl #1
      trim_offset[j] = C*(m->eBands[j+1]-m->eBands[j])*(alloc_trim-5-LM)*(end-j-1)
   2d7b2:	fb02 f303 	mul.w	r3, r2, r3
      thresh[j] = IMAX((C)<<BITRES, (3*(m->eBands[j+1]-m->eBands[j])<<LM<<BITRES)>>4);
   2d7b6:	fa01 f10e 	lsl.w	r1, r1, lr
      trim_offset[j] = C*(m->eBands[j+1]-m->eBands[j])*(alloc_trim-5-LM)*(end-j-1)
   2d7ba:	fb0b f303 	mul.w	r3, fp, r3
      thresh[j] = IMAX((C)<<BITRES, (3*(m->eBands[j+1]-m->eBands[j])<<LM<<BITRES)>>4);
   2d7be:	f341 015b 	sbfx	r1, r1, #1, #28
      trim_offset[j] = C*(m->eBands[j+1]-m->eBands[j])*(alloc_trim-5-LM)*(end-j-1)
   2d7c2:	fb00 f303 	mul.w	r3, r0, r3
      thresh[j] = IMAX((C)<<BITRES, (3*(m->eBands[j+1]-m->eBands[j])<<LM<<BITRES)>>4);
   2d7c6:	4541      	cmp	r1, r8
            *(1<<(LM+BITRES))>>6;
   2d7c8:	fa03 f309 	lsl.w	r3, r3, r9
      if ((m->eBands[j+1]-m->eBands[j])<<LM==1)
   2d7cc:	fa02 f20e 	lsl.w	r2, r2, lr
      thresh[j] = IMAX((C)<<BITRES, (3*(m->eBands[j+1]-m->eBands[j])<<LM<<BITRES)>>4);
   2d7d0:	bfb8      	it	lt
   2d7d2:	4641      	movlt	r1, r8
            *(1<<(LM+BITRES))>>6;
   2d7d4:	119b      	asrs	r3, r3, #6
      if ((m->eBands[j+1]-m->eBands[j])<<LM==1)
   2d7d6:	2a01      	cmp	r2, #1
         trim_offset[j] -= C<<BITRES;
   2d7d8:	bf08      	it	eq
   2d7da:	eba3 0308 	subeq.w	r3, r3, r8
      thresh[j] = IMAX((C)<<BITRES, (3*(m->eBands[j+1]-m->eBands[j])<<LM<<BITRES)>>4);
   2d7de:	f846 1f04 	str.w	r1, [r6, #4]!
         trim_offset[j] -= C<<BITRES;
   2d7e2:	f84c 3024 	str.w	r3, [ip, r4, lsl #2]
   for (j=start;j<end;j++)
   2d7e6:	3401      	adds	r4, #1
   2d7e8:	45a2      	cmp	sl, r4
      thresh[j] = IMAX((C)<<BITRES, (3*(m->eBands[j+1]-m->eBands[j])<<LM<<BITRES)>>4);
   2d7ea:	f105 0502 	add.w	r5, r5, #2
   2d7ee:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
   for (j=start;j<end;j++)
   2d7f2:	dcd4      	bgt.n	2d79e <clt_compute_allocation+0x196>
   2d7f4:	f8d7 a06c 	ldr.w	sl, [r7, #108]	; 0x6c
   2d7f8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   2d7fa:	6c38      	ldr	r0, [r7, #64]	; 0x40
   }
   lo = 1;
   hi = m->nbAllocVectors - 1;
   2d7fc:	f8da 1028 	ldr.w	r1, [sl, #40]	; 0x28
   lo = 1;
   2d800:	f8d7 8098 	ldr.w	r8, [r7, #152]	; 0x98
   hi = m->nbAllocVectors - 1;
   2d804:	6639      	str	r1, [r7, #96]	; 0x60
   2d806:	009b      	lsls	r3, r3, #2
   2d808:	1f1a      	subs	r2, r3, #4
   2d80a:	617a      	str	r2, [r7, #20]
   2d80c:	1882      	adds	r2, r0, r2
   2d80e:	627a      	str	r2, [r7, #36]	; 0x24
   2d810:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   2d812:	61bb      	str	r3, [r7, #24]
   2d814:	18d3      	adds	r3, r2, r3
   2d816:	623b      	str	r3, [r7, #32]
   2d818:	1e4b      	subs	r3, r1, #1
   2d81a:	64fb      	str	r3, [r7, #76]	; 0x4c
   2d81c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   2d81e:	61fb      	str	r3, [r7, #28]
   lo = 1;
   2d820:	f04f 0901 	mov.w	r9, #1
   2d824:	005b      	lsls	r3, r3, #1
   2d826:	62bb      	str	r3, [r7, #40]	; 0x28
   2d828:	f8c7 9058 	str.w	r9, [r7, #88]	; 0x58
   do
   {
      int done = 0;
      int psum = 0;
      int mid = (lo+hi) >> 1;
   2d82c:	6dba      	ldr	r2, [r7, #88]	; 0x58
   2d82e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
      for (j=end;j-->start;)
   2d830:	6a3d      	ldr	r5, [r7, #32]
   2d832:	6d78      	ldr	r0, [r7, #84]	; 0x54
   2d834:	66fd      	str	r5, [r7, #108]	; 0x6c
      int mid = (lo+hi) >> 1;
   2d836:	4413      	add	r3, r2
      {
         int bitsj;
         int N = m->eBands[j+1]-m->eBands[j];
         bitsj = C*N*m->allocVectors[mid*len+j]<<LM>>2;
   2d838:	6afa      	ldr	r2, [r7, #44]	; 0x2c
      int mid = (lo+hi) >> 1;
   2d83a:	105b      	asrs	r3, r3, #1
      int psum = 0;
   2d83c:	2400      	movs	r4, #0
      int mid = (lo+hi) >> 1;
   2d83e:	64bb      	str	r3, [r7, #72]	; 0x48
         bitsj = C*N*m->allocVectors[mid*len+j]<<LM>>2;
   2d840:	fb02 fe03 	mul.w	lr, r2, r3
      int done = 0;
   2d844:	46a1      	mov	r9, r4
      for (j=end;j-->start;)
   2d846:	e9d7 6109 	ldrd	r6, r1, [r7, #36]	; 0x24
   2d84a:	e008      	b.n	2d85e <clt_compute_allocation+0x256>
         if (bitsj > 0)
            bitsj = IMAX(0, bitsj + trim_offset[j]);
         bitsj += offsets[j];
         if (bitsj >= thresh[j] || done)
   2d84c:	f1b9 0f00 	cmp.w	r9, #0
   2d850:	d131      	bne.n	2d8b6 <clt_compute_allocation+0x2ae>
         {
            done = 1;
            /* Don't allocate more than we can actually use */
            psum += IMIN(bitsj, cap[j]);
         } else {
            if (bitsj >= C<<BITRES)
   2d852:	6e7a      	ldr	r2, [r7, #100]	; 0x64
   2d854:	4293      	cmp	r3, r2
               psum += C<<BITRES;
   2d856:	bfa8      	it	ge
   2d858:	18a4      	addge	r4, r4, r2
   2d85a:	3801      	subs	r0, #1
   2d85c:	3902      	subs	r1, #2
      for (j=end;j-->start;)
   2d85e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   2d860:	4283      	cmp	r3, r0
   2d862:	da31      	bge.n	2d8c8 <clt_compute_allocation+0x2c0>
         int N = m->eBands[j+1]-m->eBands[j];
   2d864:	f8da 2018 	ldr.w	r2, [sl, #24]
         bitsj = C*N*m->allocVectors[mid*len+j]<<LM>>2;
   2d868:	f8da 302c 	ldr.w	r3, [sl, #44]	; 0x2c
         int N = m->eBands[j+1]-m->eBands[j];
   2d86c:	eb02 0b01 	add.w	fp, r2, r1
         bitsj = C*N*m->allocVectors[mid*len+j]<<LM>>2;
   2d870:	4473      	add	r3, lr
         int N = m->eBands[j+1]-m->eBands[j];
   2d872:	5e52      	ldrsh	r2, [r2, r1]
   2d874:	f9bb b002 	ldrsh.w	fp, [fp, #2]
         bitsj = C*N*m->allocVectors[mid*len+j]<<LM>>2;
   2d878:	4403      	add	r3, r0
         int N = m->eBands[j+1]-m->eBands[j];
   2d87a:	ebab 0b02 	sub.w	fp, fp, r2
         bitsj = C*N*m->allocVectors[mid*len+j]<<LM>>2;
   2d87e:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
   2d882:	f813 3c01 	ldrb.w	r3, [r3, #-1]
   2d886:	fb02 fb0b 	mul.w	fp, r2, fp
   2d88a:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
   2d88e:	fb03 f30b 	mul.w	r3, r3, fp
   2d892:	4093      	lsls	r3, r2
   2d894:	109b      	asrs	r3, r3, #2
         if (bitsj > 0)
   2d896:	2b00      	cmp	r3, #0
   2d898:	dd04      	ble.n	2d8a4 <clt_compute_allocation+0x29c>
            bitsj = IMAX(0, bitsj + trim_offset[j]);
   2d89a:	f85c 2011 	ldr.w	r2, [ip, r1, lsl #1]
   2d89e:	4413      	add	r3, r2
   2d8a0:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
         bitsj += offsets[j];
   2d8a4:	6efa      	ldr	r2, [r7, #108]	; 0x6c
   2d8a6:	f852 bd04 	ldr.w	fp, [r2, #-4]!
   2d8aa:	66fa      	str	r2, [r7, #108]	; 0x6c
         if (bitsj >= thresh[j] || done)
   2d8ac:	f856 2904 	ldr.w	r2, [r6], #-4
         bitsj += offsets[j];
   2d8b0:	445b      	add	r3, fp
         if (bitsj >= thresh[j] || done)
   2d8b2:	429a      	cmp	r2, r3
   2d8b4:	dcca      	bgt.n	2d84c <clt_compute_allocation+0x244>
            psum += IMIN(bitsj, cap[j]);
   2d8b6:	f858 2011 	ldr.w	r2, [r8, r1, lsl #1]
            done = 1;
   2d8ba:	f04f 0901 	mov.w	r9, #1
            psum += IMIN(bitsj, cap[j]);
   2d8be:	4293      	cmp	r3, r2
   2d8c0:	bfd4      	ite	le
   2d8c2:	18e4      	addle	r4, r4, r3
   2d8c4:	18a4      	addgt	r4, r4, r2
   2d8c6:	e7c8      	b.n	2d85a <clt_compute_allocation+0x252>
         }
      }
      if (psum > total)
   2d8c8:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   2d8ca:	429c      	cmp	r4, r3
         hi = mid - 1;
   2d8cc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
      if (psum > total)
   2d8ce:	f340 80c5 	ble.w	2da5c <clt_compute_allocation+0x454>
      else
         lo = mid + 1;
      /*printf ("lo = %d, hi = %d\n", lo, hi);*/
   }
   while (lo <= hi);
   2d8d2:	6dba      	ldr	r2, [r7, #88]	; 0x58
         hi = mid - 1;
   2d8d4:	3b01      	subs	r3, #1
   while (lo <= hi);
   2d8d6:	429a      	cmp	r2, r3
         hi = mid - 1;
   2d8d8:	64fb      	str	r3, [r7, #76]	; 0x4c
   while (lo <= hi);
   2d8da:	dda7      	ble.n	2d82c <clt_compute_allocation+0x224>
   hi = lo--;
   /*printf ("interp between %d and %d\n", lo, hi);*/
   for (j=start;j<end;j++)
   2d8dc:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   2d8de:	6d79      	ldr	r1, [r7, #84]	; 0x54
   2d8e0:	4691      	mov	r9, r2
   2d8e2:	428b      	cmp	r3, r1
   hi = lo--;
   2d8e4:	f109 3bff 	add.w	fp, r9, #4294967295	; 0xffffffff
   for (j=start;j<end;j++)
   2d8e8:	f280 80c6 	bge.w	2da78 <clt_compute_allocation+0x470>
   {
      int bits1j, bits2j;
      int N = m->eBands[j+1]-m->eBands[j];
   2d8ec:	f8da 2018 	ldr.w	r2, [sl, #24]
   2d8f0:	6c79      	ldr	r1, [r7, #68]	; 0x44
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
   2d8f2:	f8da 602c 	ldr.w	r6, [sl, #44]	; 0x2c
      int N = m->eBands[j+1]-m->eBands[j];
   2d8f6:	623a      	str	r2, [r7, #32]
   2d8f8:	1855      	adds	r5, r2, r1
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
   2d8fa:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   2d8fc:	60fe      	str	r6, [r7, #12]
   2d8fe:	fb0b f001 	mul.w	r0, fp, r1
      bits2j = hi>=m->nbAllocVectors ?
            cap[j] : C*N*m->allocVectors[hi*len+j]<<LM>>2;
   2d902:	fb01 f109 	mul.w	r1, r1, r9
   2d906:	6279      	str	r1, [r7, #36]	; 0x24
   2d908:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
   2d90a:	62f8      	str	r0, [r7, #44]	; 0x2c
   2d90c:	1c5c      	adds	r4, r3, #1
   2d90e:	428c      	cmp	r4, r1
   2d910:	f280 84cc 	bge.w	2e2ac <clt_compute_allocation+0xca4>
   2d914:	4696      	mov	lr, r2
            cap[j] : C*N*m->allocVectors[hi*len+j]<<LM>>2;
   2d916:	4618      	mov	r0, r3
   2d918:	f93e 1013 	ldrsh.w	r1, [lr, r3, lsl #1]
   2d91c:	65bb      	str	r3, [r7, #88]	; 0x58
   2d91e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   2d920:	66fd      	str	r5, [r7, #108]	; 0x6c
   2d922:	18f2      	adds	r2, r6, r3
   2d924:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   2d926:	64fa      	str	r2, [r7, #76]	; 0x4c
   2d928:	18f3      	adds	r3, r6, r3
   2d92a:	64bb      	str	r3, [r7, #72]	; 0x48
   2d92c:	f8c7 a004 	str.w	sl, [r7, #4]
   2d930:	f8d7 80c0 	ldr.w	r8, [r7, #192]	; 0xc0
   2d934:	e073      	b.n	2da1e <clt_compute_allocation+0x416>
   2d936:	f8d7 1098 	ldr.w	r1, [r7, #152]	; 0x98
   2d93a:	f851 e020 	ldr.w	lr, [r1, r0, lsl #2]
      if (bits1j > 0)
   2d93e:	2a00      	cmp	r2, #0
   2d940:	dd04      	ble.n	2d94c <clt_compute_allocation+0x344>
         bits1j = IMAX(0, bits1j + trim_offset[j]);
   2d942:	f85c 1020 	ldr.w	r1, [ip, r0, lsl #2]
   2d946:	440a      	add	r2, r1
   2d948:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
      if (bits2j > 0)
   2d94c:	f1be 0f00 	cmp.w	lr, #0
   2d950:	dd04      	ble.n	2d95c <clt_compute_allocation+0x354>
         bits2j = IMAX(0, bits2j + trim_offset[j]);
   2d952:	f85c 1020 	ldr.w	r1, [ip, r0, lsl #2]
   2d956:	448e      	add	lr, r1
   2d958:	ea2e 7eee 	bic.w	lr, lr, lr, asr #31
   2d95c:	6b39      	ldr	r1, [r7, #48]	; 0x30
         bits1j += offsets[j];
      bits2j += offsets[j];
      if (offsets[j]>0)
         skip_start = j;
      bits2j = IMAX(0,bits2j-bits1j);
      bits1[j] = bits1j;
   2d95e:	6bbd      	ldr	r5, [r7, #56]	; 0x38
   2d960:	f851 a020 	ldr.w	sl, [r1, r0, lsl #2]
      int N = m->eBands[j+1]-m->eBands[j];
   2d964:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
      if (lo > 0)
   2d966:	f1bb 0f00 	cmp.w	fp, #0
         bits1j += offsets[j];
   2d96a:	bfc8      	it	gt
   2d96c:	4452      	addgt	r2, sl
      int N = m->eBands[j+1]-m->eBands[j];
   2d96e:	f9b1 1004 	ldrsh.w	r1, [r1, #4]
      bits1[j] = bits1j;
   2d972:	f845 2026 	str.w	r2, [r5, r6, lsl #2]
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
   2d976:	f8d7 50bc 	ldr.w	r5, [r7, #188]	; 0xbc
      int N = m->eBands[j+1]-m->eBands[j];
   2d97a:	1acb      	subs	r3, r1, r3
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
   2d97c:	fb05 f303 	mul.w	r3, r5, r3
   2d980:	6cfd      	ldr	r5, [r7, #76]	; 0x4c
      bits2j += offsets[j];
   2d982:	44d6      	add	lr, sl
      bits2j = IMAX(0,bits2j-bits1j);
   2d984:	ebae 0202 	sub.w	r2, lr, r2
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
   2d988:	f815 e004 	ldrb.w	lr, [r5, r4]
      bits2[j] = bits2j;
   2d98c:	6b7d      	ldr	r5, [r7, #52]	; 0x34
      bits2j = IMAX(0,bits2j-bits1j);
   2d98e:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
      bits2[j] = bits2j;
   2d992:	f845 2026 	str.w	r2, [r5, r6, lsl #2]
      if (offsets[j]>0)
   2d996:	6dba      	ldr	r2, [r7, #88]	; 0x58
   2d998:	f1ba 0f00 	cmp.w	sl, #0
   2d99c:	bfd8      	it	le
   2d99e:	4610      	movle	r0, r2
            cap[j] : C*N*m->allocVectors[hi*len+j]<<LM>>2;
   2d9a0:	6e3a      	ldr	r2, [r7, #96]	; 0x60
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
   2d9a2:	fb03 fe0e 	mul.w	lr, r3, lr
   2d9a6:	fa0e fe08 	lsl.w	lr, lr, r8
            cap[j] : C*N*m->allocVectors[hi*len+j]<<LM>>2;
   2d9aa:	454a      	cmp	r2, r9
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
   2d9ac:	ea4f 0eae 	mov.w	lr, lr, asr #2
            cap[j] : C*N*m->allocVectors[hi*len+j]<<LM>>2;
   2d9b0:	dd64      	ble.n	2da7c <clt_compute_allocation+0x474>
   2d9b2:	6cba      	ldr	r2, [r7, #72]	; 0x48
   2d9b4:	5d12      	ldrb	r2, [r2, r4]
   2d9b6:	fb03 f302 	mul.w	r3, r3, r2
   2d9ba:	fa03 fa08 	lsl.w	sl, r3, r8
   2d9be:	ea4f 02aa 	mov.w	r2, sl, asr #2
      if (bits1j > 0)
   2d9c2:	f1be 0f00 	cmp.w	lr, #0
   2d9c6:	dd04      	ble.n	2d9d2 <clt_compute_allocation+0x3ca>
         bits1j = IMAX(0, bits1j + trim_offset[j]);
   2d9c8:	f85c 3024 	ldr.w	r3, [ip, r4, lsl #2]
   2d9cc:	449e      	add	lr, r3
   2d9ce:	ea2e 7eee 	bic.w	lr, lr, lr, asr #31
      if (bits2j > 0)
   2d9d2:	2a00      	cmp	r2, #0
   2d9d4:	dd04      	ble.n	2d9e0 <clt_compute_allocation+0x3d8>
         bits2j = IMAX(0, bits2j + trim_offset[j]);
   2d9d6:	f85c 3024 	ldr.w	r3, [ip, r4, lsl #2]
   2d9da:	441a      	add	r2, r3
   2d9dc:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
   2d9e0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
      bits2[j] = bits2j;
   2d9e2:	6b7d      	ldr	r5, [r7, #52]	; 0x34
   2d9e4:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
      if (lo > 0)
   2d9e8:	f1bb 0f00 	cmp.w	fp, #0
         bits1j += offsets[j];
   2d9ec:	bfc8      	it	gt
   2d9ee:	449e      	addgt	lr, r3
      bits2j += offsets[j];
   2d9f0:	441a      	add	r2, r3
      if (offsets[j]>0)
   2d9f2:	2b00      	cmp	r3, #0
   2d9f4:	bfc8      	it	gt
   2d9f6:	4620      	movgt	r0, r4
      bits1[j] = bits1j;
   2d9f8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
      if (offsets[j]>0)
   2d9fa:	65b8      	str	r0, [r7, #88]	; 0x58
      bits1[j] = bits1j;
   2d9fc:	f843 e024 	str.w	lr, [r3, r4, lsl #2]
   2da00:	6efb      	ldr	r3, [r7, #108]	; 0x6c
      bits2j = IMAX(0,bits2j-bits1j);
   2da02:	eba2 020e 	sub.w	r2, r2, lr
   2da06:	3304      	adds	r3, #4
   2da08:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
   2da0c:	66fb      	str	r3, [r7, #108]	; 0x6c
   2da0e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
      bits2[j] = bits2j;
   2da10:	f845 2024 	str.w	r2, [r5, r4, lsl #2]
   2da14:	3402      	adds	r4, #2
   2da16:	429c      	cmp	r4, r3
   2da18:	f106 0002 	add.w	r0, r6, #2
   2da1c:	da33      	bge.n	2da86 <clt_compute_allocation+0x47e>
      int N = m->eBands[j+1]-m->eBands[j];
   2da1e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
   2da20:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
      int N = m->eBands[j+1]-m->eBands[j];
   2da22:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
   2da26:	f8d7 60bc 	ldr.w	r6, [r7, #188]	; 0xbc
   2da2a:	5c12      	ldrb	r2, [r2, r0]
            cap[j] : C*N*m->allocVectors[hi*len+j]<<LM>>2;
   2da2c:	6e3d      	ldr	r5, [r7, #96]	; 0x60
      int N = m->eBands[j+1]-m->eBands[j];
   2da2e:	1a59      	subs	r1, r3, r1
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
   2da30:	fb06 f101 	mul.w	r1, r6, r1
   2da34:	fb01 f202 	mul.w	r2, r1, r2
   2da38:	fa02 f208 	lsl.w	r2, r2, r8
            cap[j] : C*N*m->allocVectors[hi*len+j]<<LM>>2;
   2da3c:	454d      	cmp	r5, r9
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
   2da3e:	ea4f 02a2 	mov.w	r2, r2, asr #2
   2da42:	4606      	mov	r6, r0
            cap[j] : C*N*m->allocVectors[hi*len+j]<<LM>>2;
   2da44:	f77f af77 	ble.w	2d936 <clt_compute_allocation+0x32e>
   2da48:	6cbd      	ldr	r5, [r7, #72]	; 0x48
   2da4a:	f815 e000 	ldrb.w	lr, [r5, r0]
   2da4e:	fb01 fe0e 	mul.w	lr, r1, lr
   2da52:	fa0e fe08 	lsl.w	lr, lr, r8
   2da56:	ea4f 0eae 	mov.w	lr, lr, asr #2
   2da5a:	e770      	b.n	2d93e <clt_compute_allocation+0x336>
   while (lo <= hi);
   2da5c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
         lo = mid + 1;
   2da5e:	3301      	adds	r3, #1
   while (lo <= hi);
   2da60:	429a      	cmp	r2, r3
         lo = mid + 1;
   2da62:	65bb      	str	r3, [r7, #88]	; 0x58
   while (lo <= hi);
   2da64:	f6bf aee2 	bge.w	2d82c <clt_compute_allocation+0x224>
   2da68:	4699      	mov	r9, r3
   for (j=start;j<end;j++)
   2da6a:	6d79      	ldr	r1, [r7, #84]	; 0x54
   2da6c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   2da6e:	428b      	cmp	r3, r1
   hi = lo--;
   2da70:	f109 3bff 	add.w	fp, r9, #4294967295	; 0xffffffff
   for (j=start;j<end;j++)
   2da74:	f6ff af3a 	blt.w	2d8ec <clt_compute_allocation+0x2e4>
   2da78:	65bb      	str	r3, [r7, #88]	; 0x58
   2da7a:	e073      	b.n	2db64 <clt_compute_allocation+0x55c>
            cap[j] : C*N*m->allocVectors[hi*len+j]<<LM>>2;
   2da7c:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
   2da80:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
   2da84:	e79d      	b.n	2d9c2 <clt_compute_allocation+0x3ba>
   2da86:	f8d7 a004 	ldr.w	sl, [r7, #4]
   2da8a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   2da8c:	6a3a      	ldr	r2, [r7, #32]
   2da8e:	f8c7 904c 	str.w	r9, [r7, #76]	; 0x4c
   2da92:	4403      	add	r3, r0
   2da94:	469e      	mov	lr, r3
   2da96:	eb02 0540 	add.w	r5, r2, r0, lsl #1
   2da9a:	68fb      	ldr	r3, [r7, #12]
   2da9c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   2da9e:	f8d7 90c0 	ldr.w	r9, [r7, #192]	; 0xc0
   2daa2:	441a      	add	r2, r3
   2daa4:	0086      	lsls	r6, r0, #2
   2daa6:	449e      	add	lr, r3
   2daa8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   2daaa:	64ba      	str	r2, [r7, #72]	; 0x48
   2daac:	3e04      	subs	r6, #4
   2daae:	4433      	add	r3, r6
   2dab0:	461c      	mov	r4, r3
   2dab2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   2dab4:	f8c7 a030 	str.w	sl, [r7, #48]	; 0x30
   2dab8:	eb03 0806 	add.w	r8, r3, r6
   2dabc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   2dabe:	66fc      	str	r4, [r7, #108]	; 0x6c
   2dac0:	441e      	add	r6, r3
   2dac2:	f8d7 a058 	ldr.w	sl, [r7, #88]	; 0x58
   2dac6:	e028      	b.n	2db1a <clt_compute_allocation+0x512>
   2dac8:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
   2dacc:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
      if (bits1j > 0)
   2dad0:	2a00      	cmp	r2, #0
   2dad2:	dd04      	ble.n	2dade <clt_compute_allocation+0x4d6>
         bits1j = IMAX(0, bits1j + trim_offset[j]);
   2dad4:	f85c 1020 	ldr.w	r1, [ip, r0, lsl #2]
   2dad8:	440a      	add	r2, r1
   2dada:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
      if (bits2j > 0)
   2dade:	2b00      	cmp	r3, #0
   2dae0:	dd04      	ble.n	2daec <clt_compute_allocation+0x4e4>
         bits2j = IMAX(0, bits2j + trim_offset[j]);
   2dae2:	f85c 1020 	ldr.w	r1, [ip, r0, lsl #2]
   2dae6:	440b      	add	r3, r1
   2dae8:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   2daec:	6efc      	ldr	r4, [r7, #108]	; 0x6c
   2daee:	f854 1f04 	ldr.w	r1, [r4, #4]!
   2daf2:	66fc      	str	r4, [r7, #108]	; 0x6c
      if (lo > 0)
   2daf4:	f1bb 0f00 	cmp.w	fp, #0
         bits1j += offsets[j];
   2daf8:	bfc8      	it	gt
   2dafa:	1852      	addgt	r2, r2, r1
      bits2j += offsets[j];
   2dafc:	440b      	add	r3, r1
      bits2j = IMAX(0,bits2j-bits1j);
   2dafe:	1a9b      	subs	r3, r3, r2
   2db00:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
      bits2[j] = bits2j;
   2db04:	f846 3f04 	str.w	r3, [r6, #4]!
   for (j=start;j<end;j++)
   2db08:	6d7b      	ldr	r3, [r7, #84]	; 0x54
      bits1[j] = bits1j;
   2db0a:	f848 2f04 	str.w	r2, [r8, #4]!
      if (offsets[j]>0)
   2db0e:	2900      	cmp	r1, #0
   2db10:	bfc8      	it	gt
   2db12:	4682      	movgt	sl, r0
   for (j=start;j<end;j++)
   2db14:	3001      	adds	r0, #1
   2db16:	4298      	cmp	r0, r3
   2db18:	da20      	bge.n	2db5c <clt_compute_allocation+0x554>
   2db1a:	462a      	mov	r2, r5
      int N = m->eBands[j+1]-m->eBands[j];
   2db1c:	f9b5 3002 	ldrsh.w	r3, [r5, #2]
   2db20:	f9b2 1000 	ldrsh.w	r1, [r2]
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
   2db24:	f81e 2b01 	ldrb.w	r2, [lr], #1
      int N = m->eBands[j+1]-m->eBands[j];
   2db28:	1a5b      	subs	r3, r3, r1
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
   2db2a:	f8d7 10bc 	ldr.w	r1, [r7, #188]	; 0xbc
   2db2e:	fb01 f303 	mul.w	r3, r1, r3
            cap[j] : C*N*m->allocVectors[hi*len+j]<<LM>>2;
   2db32:	6e39      	ldr	r1, [r7, #96]	; 0x60
   2db34:	460c      	mov	r4, r1
   2db36:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
   2db38:	fb03 f202 	mul.w	r2, r3, r2
   2db3c:	fa02 f209 	lsl.w	r2, r2, r9
            cap[j] : C*N*m->allocVectors[hi*len+j]<<LM>>2;
   2db40:	428c      	cmp	r4, r1
      int N = m->eBands[j+1]-m->eBands[j];
   2db42:	f105 0502 	add.w	r5, r5, #2
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
   2db46:	ea4f 02a2 	mov.w	r2, r2, asr #2
            cap[j] : C*N*m->allocVectors[hi*len+j]<<LM>>2;
   2db4a:	ddbd      	ble.n	2dac8 <clt_compute_allocation+0x4c0>
   2db4c:	6cb9      	ldr	r1, [r7, #72]	; 0x48
   2db4e:	5c09      	ldrb	r1, [r1, r0]
   2db50:	fb03 f301 	mul.w	r3, r3, r1
   2db54:	fa03 f309 	lsl.w	r3, r3, r9
   2db58:	109b      	asrs	r3, r3, #2
   2db5a:	e7b9      	b.n	2dad0 <clt_compute_allocation+0x4c8>
   2db5c:	f8c7 a058 	str.w	sl, [r7, #88]	; 0x58
   2db60:	f8d7 a030 	ldr.w	sl, [r7, #48]	; 0x30
   2db64:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   2db66:	69bb      	ldr	r3, [r7, #24]
   lo = 0;
   2db68:	f8c7 a024 	str.w	sl, [r7, #36]	; 0x24
   2db6c:	4611      	mov	r1, r2
   2db6e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   2db70:	f8d7 a098 	ldr.w	sl, [r7, #152]	; 0x98
   2db74:	4419      	add	r1, r3
   2db76:	64b9      	str	r1, [r7, #72]	; 0x48
   2db78:	4611      	mov	r1, r2
   stereo = C>1;
   2db7a:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
   2db7e:	2a01      	cmp	r2, #1
   2db80:	bfd4      	ite	le
   2db82:	2200      	movle	r2, #0
   2db84:	2201      	movgt	r2, #1
   2db86:	62fa      	str	r2, [r7, #44]	; 0x2c
   logM = LM<<BITRES;
   2db88:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
   2db8c:	00d2      	lsls	r2, r2, #3
   2db8e:	633a      	str	r2, [r7, #48]	; 0x30
   2db90:	6bba      	ldr	r2, [r7, #56]	; 0x38
   2db92:	4419      	add	r1, r3
   2db94:	eb02 0903 	add.w	r9, r2, r3
   2db98:	2306      	movs	r3, #6
   2db9a:	643b      	str	r3, [r7, #64]	; 0x40
   lo = 0;
   2db9c:	f8c7 9034 	str.w	r9, [r7, #52]	; 0x34
   hi = 1<<ALLOC_STEPS;
   2dba0:	2340      	movs	r3, #64	; 0x40
   lo = 0;
   2dba2:	f8d7 9068 	ldr.w	r9, [r7, #104]	; 0x68
   2dba6:	6639      	str	r1, [r7, #96]	; 0x60
   hi = 1<<ALLOC_STEPS;
   2dba8:	64fb      	str	r3, [r7, #76]	; 0x4c
   lo = 0;
   2dbaa:	f04f 0800 	mov.w	r8, #0
      int mid = (lo+hi)>>1;
   2dbae:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   2dbb0:	6b7c      	ldr	r4, [r7, #52]	; 0x34
   2dbb2:	6e3e      	ldr	r6, [r7, #96]	; 0x60
   2dbb4:	6cbd      	ldr	r5, [r7, #72]	; 0x48
   2dbb6:	6d79      	ldr	r1, [r7, #84]	; 0x54
   2dbb8:	66fc      	str	r4, [r7, #108]	; 0x6c
   2dbba:	eb08 0003 	add.w	r0, r8, r3
      done = 0;
   2dbbe:	f04f 0b00 	mov.w	fp, #0
      int mid = (lo+hi)>>1;
   2dbc2:	1040      	asrs	r0, r0, #1
      psum = 0;
   2dbc4:	46dc      	mov	ip, fp
      for (j=end;j-->start;)
   2dbc6:	3901      	subs	r1, #1
   2dbc8:	1c4b      	adds	r3, r1, #1
   2dbca:	4599      	cmp	r9, r3
   2dbcc:	da19      	bge.n	2dc02 <clt_compute_allocation+0x5fa>
         int tmp = bits1[j] + (mid*(opus_int32)bits2[j]>>ALLOC_STEPS);
   2dbce:	6efa      	ldr	r2, [r7, #108]	; 0x6c
   2dbd0:	f855 ed04 	ldr.w	lr, [r5, #-4]!
   2dbd4:	f852 3d04 	ldr.w	r3, [r2, #-4]!
   2dbd8:	66fa      	str	r2, [r7, #108]	; 0x6c
   2dbda:	fb0e fe00 	mul.w	lr, lr, r0
         if (tmp >= thresh[j] || done)
   2dbde:	f856 2d04 	ldr.w	r2, [r6, #-4]!
         int tmp = bits1[j] + (mid*(opus_int32)bits2[j]>>ALLOC_STEPS);
   2dbe2:	eb03 13ae 	add.w	r3, r3, lr, asr #6
         if (tmp >= thresh[j] || done)
   2dbe6:	4293      	cmp	r3, r2
   2dbe8:	da51      	bge.n	2dc8e <clt_compute_allocation+0x686>
   2dbea:	f1bb 0f00 	cmp.w	fp, #0
   2dbee:	d14e      	bne.n	2dc8e <clt_compute_allocation+0x686>
            if (tmp >= alloc_floor)
   2dbf0:	6e7a      	ldr	r2, [r7, #100]	; 0x64
      for (j=end;j-->start;)
   2dbf2:	3901      	subs	r1, #1
            if (tmp >= alloc_floor)
   2dbf4:	4293      	cmp	r3, r2
      for (j=end;j-->start;)
   2dbf6:	f101 0301 	add.w	r3, r1, #1
               psum += alloc_floor;
   2dbfa:	bfa8      	it	ge
   2dbfc:	4494      	addge	ip, r2
      for (j=end;j-->start;)
   2dbfe:	4599      	cmp	r9, r3
   2dc00:	dbe5      	blt.n	2dbce <clt_compute_allocation+0x5c6>
         lo = mid;
   2dc02:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   2dc04:	4563      	cmp	r3, ip
   2dc06:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   2dc08:	bfb8      	it	lt
   2dc0a:	4603      	movlt	r3, r0
   2dc0c:	64fb      	str	r3, [r7, #76]	; 0x4c
   for (i=0;i<ALLOC_STEPS;i++)
   2dc0e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
         lo = mid;
   2dc10:	bfa8      	it	ge
   2dc12:	4680      	movge	r8, r0
   for (i=0;i<ALLOC_STEPS;i++)
   2dc14:	3b01      	subs	r3, #1
   2dc16:	643b      	str	r3, [r7, #64]	; 0x40
   2dc18:	d1c9      	bne.n	2dbae <clt_compute_allocation+0x5a6>
   for (j=end;j-->start;)
   2dc1a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   2dc1c:	6d79      	ldr	r1, [r7, #84]	; 0x54
   2dc1e:	f8d7 9034 	ldr.w	r9, [r7, #52]	; 0x34
   2dc22:	f8d7 a024 	ldr.w	sl, [r7, #36]	; 0x24
   psum = 0;
   2dc26:	6c3d      	ldr	r5, [r7, #64]	; 0x40
   for (j=end;j-->start;)
   2dc28:	428b      	cmp	r3, r1
   2dc2a:	da39      	bge.n	2dca0 <clt_compute_allocation+0x698>
   2dc2c:	6bba      	ldr	r2, [r7, #56]	; 0x38
   2dc2e:	6e39      	ldr	r1, [r7, #96]	; 0x60
   2dc30:	eb02 0c83 	add.w	ip, r2, r3, lsl #2
   2dc34:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
   2dc38:	69bb      	ldr	r3, [r7, #24]
   2dc3a:	18d4      	adds	r4, r2, r3
   2dc3c:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
   done = 0;
   2dc40:	46ae      	mov	lr, r5
   2dc42:	18d0      	adds	r0, r2, r3
   2dc44:	e012      	b.n	2dc6c <clt_compute_allocation+0x664>
      if (tmp < thresh[j] && !done)
   2dc46:	f1be 0f00 	cmp.w	lr, #0
   2dc4a:	d105      	bne.n	2dc58 <clt_compute_allocation+0x650>
            tmp = 0;
   2dc4c:	6e7e      	ldr	r6, [r7, #100]	; 0x64
   2dc4e:	4632      	mov	r2, r6
   2dc50:	429e      	cmp	r6, r3
   2dc52:	bfc8      	it	gt
   2dc54:	2200      	movgt	r2, #0
   2dc56:	4613      	mov	r3, r2
      tmp = IMIN(tmp, cap[j]);
   2dc58:	f854 6d04 	ldr.w	r6, [r4, #-4]!
   2dc5c:	42b3      	cmp	r3, r6
   2dc5e:	bfa8      	it	ge
   2dc60:	4633      	movge	r3, r6
   for (j=end;j-->start;)
   2dc62:	45cc      	cmp	ip, r9
      bits[j] = tmp;
   2dc64:	f840 3d04 	str.w	r3, [r0, #-4]!
      psum += tmp;
   2dc68:	441d      	add	r5, r3
   for (j=end;j-->start;)
   2dc6a:	d019      	beq.n	2dca0 <clt_compute_allocation+0x698>
      int tmp = bits1[j] + ((opus_int32)lo*bits2[j]>>ALLOC_STEPS);
   2dc6c:	6cba      	ldr	r2, [r7, #72]	; 0x48
   2dc6e:	f859 bd04 	ldr.w	fp, [r9, #-4]!
   2dc72:	f852 3d04 	ldr.w	r3, [r2, #-4]!
      if (tmp < thresh[j] && !done)
   2dc76:	f851 6d04 	ldr.w	r6, [r1, #-4]!
      int tmp = bits1[j] + ((opus_int32)lo*bits2[j]>>ALLOC_STEPS);
   2dc7a:	64ba      	str	r2, [r7, #72]	; 0x48
   2dc7c:	fb03 f308 	mul.w	r3, r3, r8
   2dc80:	eb0b 13a3 	add.w	r3, fp, r3, asr #6
      if (tmp < thresh[j] && !done)
   2dc84:	429e      	cmp	r6, r3
   2dc86:	dcde      	bgt.n	2dc46 <clt_compute_allocation+0x63e>
         done = 1;
   2dc88:	f04f 0e01 	mov.w	lr, #1
   2dc8c:	e7e4      	b.n	2dc58 <clt_compute_allocation+0x650>
            psum += IMIN(tmp, cap[j]);
   2dc8e:	f85a 2021 	ldr.w	r2, [sl, r1, lsl #2]
            done = 1;
   2dc92:	f04f 0b01 	mov.w	fp, #1
            psum += IMIN(tmp, cap[j]);
   2dc96:	4293      	cmp	r3, r2
   2dc98:	bfd4      	ite	le
   2dc9a:	449c      	addle	ip, r3
   2dc9c:	4494      	addgt	ip, r2
   2dc9e:	e792      	b.n	2dbc6 <clt_compute_allocation+0x5be>
      if (j<=skip_start)
   2dca0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   2dca2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
   2dca4:	4293      	cmp	r3, r2
   2dca6:	f280 8305 	bge.w	2e2b4 <clt_compute_allocation+0xcac>
   2dcaa:	6aba      	ldr	r2, [r7, #40]	; 0x28
   2dcac:	f8d7 10b0 	ldr.w	r1, [r7, #176]	; 0xb0
         intensity_rsv = LOG2_FRAC_TABLE[j-start];
   2dcb0:	4b43      	ldr	r3, [pc, #268]	; (2ddc0 <clt_compute_allocation+0x7b8>)
   2dcb2:	f102 0902 	add.w	r9, r2, #2
   2dcb6:	697a      	ldr	r2, [r7, #20]
   2dcb8:	440a      	add	r2, r1
   2dcba:	4616      	mov	r6, r2
   2dcbc:	6eba      	ldr	r2, [r7, #104]	; 0x68
   2dcbe:	1a9b      	subs	r3, r3, r2
   2dcc0:	643b      	str	r3, [r7, #64]	; 0x40
   2dcc2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   2dcc4:	3308      	adds	r3, #8
   2dcc6:	e9c7 3a12 	strd	r3, sl, [r7, #72]	; 0x48
   2dcca:	f8d7 a01c 	ldr.w	sl, [r7, #28]
      percoeff = celt_udiv(left, m->eBands[codedBands]-m->eBands[start]);
   2dcce:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   2dcd0:	f8d3 e018 	ldr.w	lr, [r3, #24]
   2dcd4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   2dcd6:	f93e c009 	ldrsh.w	ip, [lr, r9]
   2dcda:	f93e 4003 	ldrsh.w	r4, [lr, r3]
   2dcde:	f10a 0301 	add.w	r3, sl, #1
   2dce2:	ebac 0204 	sub.w	r2, ip, r4
   2dce6:	66fb      	str	r3, [r7, #108]	; 0x6c
      left = total-psum;
   2dce8:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   if (d>256)
   2dcea:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
   2dcee:	eba3 0b05 	sub.w	fp, r3, r5
   2dcf2:	f240 81c7 	bls.w	2e084 <clt_compute_allocation+0xa7c>
      return n/d;
   2dcf6:	fbbb f3f2 	udiv	r3, fp, r2
      rem = IMAX(left-(m->eBands[j]-m->eBands[start]),0);
   2dcfa:	f1a9 0802 	sub.w	r8, r9, #2
      left -= (m->eBands[codedBands]-m->eBands[start])*percoeff;
   2dcfe:	fb03 bb12 	mls	fp, r3, r2, fp
      rem = IMAX(left-(m->eBands[j]-m->eBands[start]),0);
   2dd02:	f93e e008 	ldrsh.w	lr, [lr, r8]
      if (band_bits >= IMAX(thresh[j], alloc_floor+(1<<BITRES)))
   2dd06:	6e3a      	ldr	r2, [r7, #96]	; 0x60
      band_bits = (int)(bits[j] + percoeff*band_width + rem);
   2dd08:	6831      	ldr	r1, [r6, #0]
      if (band_bits >= IMAX(thresh[j], alloc_floor+(1<<BITRES)))
   2dd0a:	f852 0d04 	ldr.w	r0, [r2, #-4]!
   2dd0e:	663a      	str	r2, [r7, #96]	; 0x60
      rem = IMAX(left-(m->eBands[j]-m->eBands[start]),0);
   2dd10:	ebae 0404 	sub.w	r4, lr, r4
      band_width = m->eBands[codedBands]-m->eBands[j];
   2dd14:	ebac 0c0e 	sub.w	ip, ip, lr
      rem = IMAX(left-(m->eBands[j]-m->eBands[start]),0);
   2dd18:	ebab 0204 	sub.w	r2, fp, r4
      band_bits = (int)(bits[j] + percoeff*band_width + rem);
   2dd1c:	fb0c 1403 	mla	r4, ip, r3, r1
      if (band_bits >= IMAX(thresh[j], alloc_floor+(1<<BITRES)))
   2dd20:	6cbb      	ldr	r3, [r7, #72]	; 0x48
      band_bits = (int)(bits[j] + percoeff*band_width + rem);
   2dd22:	2a00      	cmp	r2, #0
   2dd24:	bfa8      	it	ge
   2dd26:	18a4      	addge	r4, r4, r2
      if (band_bits >= IMAX(thresh[j], alloc_floor+(1<<BITRES)))
   2dd28:	4298      	cmp	r0, r3
   2dd2a:	bfb8      	it	lt
   2dd2c:	4618      	movlt	r0, r3
   2dd2e:	4284      	cmp	r4, r0
      rem = IMAX(left-(m->eBands[j]-m->eBands[start]),0);
   2dd30:	46c3      	mov	fp, r8
      if (band_bits >= IMAX(thresh[j], alloc_floor+(1<<BITRES)))
   2dd32:	db2e      	blt.n	2dd92 <clt_compute_allocation+0x78a>
         if (encode)
   2dd34:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
   2dd38:	2b00      	cmp	r3, #0
   2dd3a:	f000 81fa 	beq.w	2e132 <clt_compute_allocation+0xb2a>
            if (codedBands > 17)
   2dd3e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
   2dd40:	2b11      	cmp	r3, #17
   2dd42:	f340 81b6 	ble.w	2e0b2 <clt_compute_allocation+0xaaa>
               depth_threshold = j<prev ? 7 : 9;
   2dd46:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
   2dd4a:	6efa      	ldr	r2, [r7, #108]	; 0x6c
   2dd4c:	4553      	cmp	r3, sl
   2dd4e:	bfd4      	ite	le
   2dd50:	f04f 0e09 	movle.w	lr, #9
   2dd54:	f04f 0e07 	movgt.w	lr, #7
            if (codedBands<=start+2 || (band_bits > (depth_threshold*band_width<<LM<<BITRES)>>4 && j<=signalBandwidth))
   2dd58:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   2dd5a:	3302      	adds	r3, #2
   2dd5c:	4293      	cmp	r3, r2
   2dd5e:	f280 81b0 	bge.w	2e0c2 <clt_compute_allocation+0xaba>
   2dd62:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
   2dd66:	fb0e fe0c 	mul.w	lr, lr, ip
   2dd6a:	fa0e fe03 	lsl.w	lr, lr, r3
   2dd6e:	f34e 0e5b 	sbfx	lr, lr, #1, #28
   2dd72:	4574      	cmp	r4, lr
   2dd74:	dd04      	ble.n	2dd80 <clt_compute_allocation+0x778>
   2dd76:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
   2dd7a:	4553      	cmp	r3, sl
   2dd7c:	f280 81a1 	bge.w	2e0c2 <clt_compute_allocation+0xaba>
            ec_enc_bit_logp(ec, 0, 1);
   2dd80:	2201      	movs	r2, #1
   2dd82:	2100      	movs	r1, #0
   2dd84:	f8d7 00c4 	ldr.w	r0, [r7, #196]	; 0xc4
   2dd88:	f7fc f80e 	bl	29da8 <ec_enc_bit_logp>
   2dd8c:	6831      	ldr	r1, [r6, #0]
         psum += 1<<BITRES;
   2dd8e:	3508      	adds	r5, #8
         band_bits -= 1<<BITRES;
   2dd90:	3c08      	subs	r4, #8
      psum -= bits[j]+intensity_rsv;
   2dd92:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   2dd94:	4419      	add	r1, r3
   2dd96:	1a6d      	subs	r5, r5, r1
      if (intensity_rsv > 0)
   2dd98:	b123      	cbz	r3, 2dda4 <clt_compute_allocation+0x79c>
         intensity_rsv = LOG2_FRAC_TABLE[j-start];
   2dd9a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   2dd9c:	f813 300a 	ldrb.w	r3, [r3, sl]
   2dda0:	653b      	str	r3, [r7, #80]	; 0x50
   2dda2:	441d      	add	r5, r3
      if (band_bits >= alloc_floor)
   2dda4:	6e7a      	ldr	r2, [r7, #100]	; 0x64
   2dda6:	4294      	cmp	r4, r2
   2dda8:	db0c      	blt.n	2ddc4 <clt_compute_allocation+0x7bc>
         psum += alloc_floor;
   2ddaa:	4415      	add	r5, r2
   2ddac:	f846 2904 	str.w	r2, [r6], #-4
      if (j<=skip_start)
   2ddb0:	6dba      	ldr	r2, [r7, #88]	; 0x58
      j = codedBands-1;
   2ddb2:	f10a 33ff 	add.w	r3, sl, #4294967295	; 0xffffffff
      if (j<=skip_start)
   2ddb6:	429a      	cmp	r2, r3
   2ddb8:	46d9      	mov	r9, fp
   2ddba:	d00c      	beq.n	2ddd6 <clt_compute_allocation+0x7ce>
   2ddbc:	469a      	mov	sl, r3
   2ddbe:	e786      	b.n	2dcce <clt_compute_allocation+0x6c6>
   2ddc0:	0003b59c 	.word	0x0003b59c
   2ddc4:	2200      	movs	r2, #0
   2ddc6:	f846 2904 	str.w	r2, [r6], #-4
   2ddca:	6dba      	ldr	r2, [r7, #88]	; 0x58
      j = codedBands-1;
   2ddcc:	f10a 33ff 	add.w	r3, sl, #4294967295	; 0xffffffff
      if (j<=skip_start)
   2ddd0:	4293      	cmp	r3, r2
   2ddd2:	46d9      	mov	r9, fp
   2ddd4:	d1f2      	bne.n	2ddbc <clt_compute_allocation+0x7b4>
   2ddd6:	f8c7 a01c 	str.w	sl, [r7, #28]
   2ddda:	f8d7 a04c 	ldr.w	sl, [r7, #76]	; 0x4c
         total += skip_rsv;
   2ddde:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   2dde0:	68ba      	ldr	r2, [r7, #8]
   2dde2:	4413      	add	r3, r2
   2dde4:	65fb      	str	r3, [r7, #92]	; 0x5c
   if (intensity_rsv > 0)
   2dde6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   2dde8:	2b00      	cmp	r3, #0
   2ddea:	f000 81b4 	beq.w	2e156 <clt_compute_allocation+0xb4e>
      if (encode)
   2ddee:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
   2ddf2:	2b00      	cmp	r3, #0
   2ddf4:	f040 8252 	bne.w	2e29c <clt_compute_allocation+0xc94>
         *intensity = start+ec_dec_uint(ec, codedBands+1-start);
   2ddf8:	69fb      	ldr	r3, [r7, #28]
   2ddfa:	6ebc      	ldr	r4, [r7, #104]	; 0x68
   2ddfc:	f8d7 00c4 	ldr.w	r0, [r7, #196]	; 0xc4
   2de00:	1c59      	adds	r1, r3, #1
   2de02:	1b09      	subs	r1, r1, r4
   2de04:	f7fb fd7c 	bl	29900 <ec_dec_uint>
   2de08:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
   2de0c:	4420      	add	r0, r4
   2de0e:	6018      	str	r0, [r3, #0]
   if (*intensity <= start)
   2de10:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   2de12:	4283      	cmp	r3, r0
   2de14:	f2c0 817b 	blt.w	2e10e <clt_compute_allocation+0xb06>
      total += dual_stereo_rsv;
   2de18:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   2de1a:	693a      	ldr	r2, [r7, #16]
   2de1c:	4413      	add	r3, r2
   2de1e:	65fb      	str	r3, [r7, #92]	; 0x5c
      *dual_stereo = 0;
   2de20:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
   2de24:	2300      	movs	r3, #0
   2de26:	6013      	str	r3, [r2, #0]
   percoeff = celt_udiv(left, m->eBands[codedBands]-m->eBands[start]);
   2de28:	f8da 2018 	ldr.w	r2, [sl, #24]
   2de2c:	6c78      	ldr	r0, [r7, #68]	; 0x44
   2de2e:	f932 1008 	ldrsh.w	r1, [r2, r8]
   2de32:	5e13      	ldrsh	r3, [r2, r0]
   2de34:	663a      	str	r2, [r7, #96]	; 0x60
   2de36:	1ac9      	subs	r1, r1, r3
   left = total-psum;
   2de38:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   if (d>256)
   2de3a:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
   2de3e:	eba3 0505 	sub.w	r5, r3, r5
   percoeff = celt_udiv(left, m->eBands[codedBands]-m->eBands[start]);
   2de42:	eb02 0900 	add.w	r9, r2, r0
   2de46:	f240 81e3 	bls.w	2e210 <clt_compute_allocation+0xc08>
      return n/d;
   2de4a:	fbb5 fef1 	udiv	lr, r5, r1
   for (j=start;j<codedBands;j++)
   2de4e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   left -= (m->eBands[codedBands]-m->eBands[start])*percoeff;
   2de50:	fb0e 5511 	mls	r5, lr, r1, r5
   for (j=start;j<codedBands;j++)
   2de54:	69f9      	ldr	r1, [r7, #28]
   2de56:	428b      	cmp	r3, r1
   2de58:	f280 81f8 	bge.w	2e24c <clt_compute_allocation+0xc44>
   2de5c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   2de60:	3b01      	subs	r3, #1
   2de62:	ea4f 0b83 	mov.w	fp, r3, lsl #2
   2de66:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
   2de6a:	eb03 000b 	add.w	r0, r3, fp
   2de6e:	f1a3 0804 	sub.w	r8, r3, #4
   2de72:	4604      	mov	r4, r0
   2de74:	eb08 0881 	add.w	r8, r8, r1, lsl #2
   2de78:	46cc      	mov	ip, r9
   2de7a:	464e      	mov	r6, r9
   2de7c:	4632      	mov	r2, r6
      bits[j] += ((int)percoeff*(m->eBands[j+1]-m->eBands[j]));
   2de7e:	f9b6 3002 	ldrsh.w	r3, [r6, #2]
   2de82:	f9b2 1000 	ldrsh.w	r1, [r2]
   2de86:	f854 2f04 	ldr.w	r2, [r4, #4]!
   2de8a:	1a5b      	subs	r3, r3, r1
   2de8c:	fb0e 2303 	mla	r3, lr, r3, r2
   for (j=start;j<codedBands;j++)
   2de90:	45a0      	cmp	r8, r4
      bits[j] += ((int)percoeff*(m->eBands[j+1]-m->eBands[j]));
   2de92:	f106 0602 	add.w	r6, r6, #2
   2de96:	6023      	str	r3, [r4, #0]
   for (j=start;j<codedBands;j++)
   2de98:	d1f0      	bne.n	2de7c <clt_compute_allocation+0x874>
   2de9a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   2de9c:	69fa      	ldr	r2, [r7, #28]
   2de9e:	464e      	mov	r6, r9
   2dea0:	eb03 0e42 	add.w	lr, r3, r2, lsl #1
   2dea4:	4604      	mov	r4, r0
   2dea6:	4632      	mov	r2, r6
   2dea8:	3602      	adds	r6, #2
      int tmp = (int)IMIN(left, m->eBands[j+1]-m->eBands[j]);
   2deaa:	f9b2 3002 	ldrsh.w	r3, [r2, #2]
   2deae:	f9b2 1000 	ldrsh.w	r1, [r2]
      bits[j] += tmp;
   2deb2:	f854 2f04 	ldr.w	r2, [r4, #4]!
      int tmp = (int)IMIN(left, m->eBands[j+1]-m->eBands[j]);
   2deb6:	1a5b      	subs	r3, r3, r1
   2deb8:	42ab      	cmp	r3, r5
   2deba:	bfa8      	it	ge
   2debc:	462b      	movge	r3, r5
      bits[j] += tmp;
   2debe:	441a      	add	r2, r3
   for (j=start;j<codedBands;j++)
   2dec0:	45b6      	cmp	lr, r6
      left -= tmp;
   2dec2:	eba5 0503 	sub.w	r5, r5, r3
      bits[j] += tmp;
   2dec6:	6022      	str	r2, [r4, #0]
   for (j=start;j<codedBands;j++)
   2dec8:	d1ed      	bne.n	2dea6 <clt_compute_allocation+0x89e>
   2deca:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
         extra_fine = IMIN(excess>>(stereo+BITRES),MAX_FINE_BITS-ebits[j]);
   2dece:	f8d7 90bc 	ldr.w	r9, [r7, #188]	; 0xbc
   2ded2:	f8c7 a050 	str.w	sl, [r7, #80]	; 0x50
   2ded6:	f10b 0104 	add.w	r1, fp, #4
   2deda:	4419      	add	r1, r3
   2dedc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   2dede:	3303      	adds	r3, #3
   2dee0:	e9c7 3616 	strd	r3, r6, [r7, #88]	; 0x58
   2dee4:	6ebe      	ldr	r6, [r7, #104]	; 0x68
   for (j=start;j<codedBands;j++)
   2dee6:	f04f 0b00 	mov.w	fp, #0
      N0 = m->eBands[j+1]-m->eBands[j];
   2deea:	f9bc 3000 	ldrsh.w	r3, [ip]
   2deee:	f9bc a002 	ldrsh.w	sl, [ip, #2]
      bit = (opus_int32)bits[j]+balance;
   2def2:	f850 5f04 	ldr.w	r5, [r0, #4]!
      N0 = m->eBands[j+1]-m->eBands[j];
   2def6:	ebaa 0a03 	sub.w	sl, sl, r3
      N=N0<<LM;
   2defa:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
   2defe:	fa0a fa03 	lsl.w	sl, sl, r3
   2df02:	6e3b      	ldr	r3, [r7, #96]	; 0x60
      if (N>1)
   2df04:	f1ba 0f01 	cmp.w	sl, #1
   2df08:	ebac 0403 	sub.w	r4, ip, r3
      bit = (opus_int32)bits[j]+balance;
   2df0c:	445d      	add	r5, fp
   2df0e:	f10c 0c02 	add.w	ip, ip, #2
      if (N>1)
   2df12:	f340 8127 	ble.w	2e164 <clt_compute_allocation+0xb5c>
         excess = MAX32(bit-cap[j],0);
   2df16:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
   2df1a:	f853 2026 	ldr.w	r2, [r3, r6, lsl #2]
   2df1e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   2df20:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   2df22:	1aaa      	subs	r2, r5, r2
   2df24:	5f1c      	ldrsh	r4, [r3, r4]
   2df26:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   2df28:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
         bits[j] = bit-excess;
   2df2c:	1aad      	subs	r5, r5, r2
         den=(C*N+ ((C==2 && N>2 && !*dual_stereo && j<*intensity) ? 1 : 0));
   2df2e:	f1b9 0f02 	cmp.w	r9, #2
         bits[j] = bit-excess;
   2df32:	6005      	str	r5, [r0, #0]
   2df34:	441c      	add	r4, r3
         den=(C*N+ ((C==2 && N>2 && !*dual_stereo && j<*intensity) ? 1 : 0));
   2df36:	fb0a fe09 	mul.w	lr, sl, r9
   2df3a:	f000 814f 	beq.w	2e1dc <clt_compute_allocation+0xbd4>
         offset = (NClogN>>1)-den*FINE_OFFSET;
   2df3e:	f06f 0314 	mvn.w	r3, #20
   2df42:	fb03 f80e 	mul.w	r8, r3, lr
         NClogN = den*(m->logN[j] + logM);
   2df46:	fb04 f40e 	mul.w	r4, r4, lr
   2df4a:	ea4f 03ce 	mov.w	r3, lr, lsl #3
         if (N==2)
   2df4e:	f1ba 0f02 	cmp.w	sl, #2
         offset = (NClogN>>1)-den*FINE_OFFSET;
   2df52:	eb08 0864 	add.w	r8, r8, r4, asr #1
   2df56:	66fb      	str	r3, [r7, #108]	; 0x6c
         if (N==2)
   2df58:	f000 813d 	beq.w	2e1d6 <clt_compute_allocation+0xbce>
         if (bits[j] + offset < den*2<<BITRES)
   2df5c:	eb05 0308 	add.w	r3, r5, r8
   2df60:	ebb3 1f0e 	cmp.w	r3, lr, lsl #4
   2df64:	ea4f 0a4e 	mov.w	sl, lr, lsl #1
   2df68:	f280 8125 	bge.w	2e1b6 <clt_compute_allocation+0xbae>
            offset += NClogN>>2;
   2df6c:	eb08 08a4 	add.w	r8, r8, r4, asr #2
   2df70:	eb05 0308 	add.w	r3, r5, r8
         ebits[j] = IMAX(0, (bits[j] + offset + (den<<(BITRES-1))));
   2df74:	eb03 038e 	add.w	r3, r3, lr, lsl #2
   if (d>256)
   2df78:	f5be 7f80 	cmp.w	lr, #256	; 0x100
   2df7c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   2df80:	f240 80ff 	bls.w	2e182 <clt_compute_allocation+0xb7a>
      return n/d;
   2df84:	fbb3 f3fe 	udiv	r3, r3, lr
         ebits[j] = celt_udiv(ebits[j], den)>>BITRES;
   2df88:	08db      	lsrs	r3, r3, #3
   2df8a:	600b      	str	r3, [r1, #0]
         if (C*ebits[j] > (bits[j]>>BITRES))
   2df8c:	6804      	ldr	r4, [r0, #0]
   2df8e:	fb03 f509 	mul.w	r5, r3, r9
   2df92:	ebb5 0fe4 	cmp.w	r5, r4, asr #3
   2df96:	dd03      	ble.n	2dfa0 <clt_compute_allocation+0x998>
            ebits[j] = bits[j] >> stereo >> BITRES;
   2df98:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   2df9a:	fa44 f303 	asr.w	r3, r4, r3
   2df9e:	10db      	asrs	r3, r3, #3
         ebits[j] = IMIN(ebits[j], MAX_FINE_BITS);
   2dfa0:	2b08      	cmp	r3, #8
   2dfa2:	bfa8      	it	ge
   2dfa4:	2308      	movge	r3, #8
   2dfa6:	600b      	str	r3, [r1, #0]
         fine_priority[j] = ebits[j]*(den<<BITRES) >= bits[j]+offset;
   2dfa8:	6804      	ldr	r4, [r0, #0]
   2dfaa:	6efd      	ldr	r5, [r7, #108]	; 0x6c
   2dfac:	4444      	add	r4, r8
   2dfae:	fb05 f503 	mul.w	r5, r5, r3
   2dfb2:	42a5      	cmp	r5, r4
   2dfb4:	f8d7 40b8 	ldr.w	r4, [r7, #184]	; 0xb8
   2dfb8:	462b      	mov	r3, r5
   2dfba:	bfb4      	ite	lt
   2dfbc:	2300      	movlt	r3, #0
   2dfbe:	2301      	movge	r3, #1
   2dfc0:	f844 3026 	str.w	r3, [r4, r6, lsl #2]
         bits[j] -= C*ebits[j]<<BITRES;
   2dfc4:	680c      	ldr	r4, [r1, #0]
   2dfc6:	6803      	ldr	r3, [r0, #0]
   2dfc8:	fb04 f409 	mul.w	r4, r4, r9
   2dfcc:	eba3 04c4 	sub.w	r4, r3, r4, lsl #3
   2dfd0:	6004      	str	r4, [r0, #0]
      if(excess > 0)
   2dfd2:	2a00      	cmp	r2, #0
   2dfd4:	f000 80c4 	beq.w	2e160 <clt_compute_allocation+0xb58>
         extra_fine = IMIN(excess>>(stereo+BITRES),MAX_FINE_BITS-ebits[j]);
   2dfd8:	680d      	ldr	r5, [r1, #0]
   2dfda:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   2dfdc:	fa42 f403 	asr.w	r4, r2, r3
   2dfe0:	f1c5 0308 	rsb	r3, r5, #8
   2dfe4:	42a3      	cmp	r3, r4
   2dfe6:	bfa8      	it	ge
   2dfe8:	4623      	movge	r3, r4
         extra_bits = extra_fine*C<<BITRES;
   2dfea:	fb03 f409 	mul.w	r4, r3, r9
         fine_priority[j] = extra_bits >= excess-balance;
   2dfee:	eba2 0b0b 	sub.w	fp, r2, fp
         ebits[j] += extra_fine;
   2dff2:	442b      	add	r3, r5
         extra_bits = extra_fine*C<<BITRES;
   2dff4:	00e4      	lsls	r4, r4, #3
         fine_priority[j] = extra_bits >= excess-balance;
   2dff6:	455c      	cmp	r4, fp
         ebits[j] += extra_fine;
   2dff8:	600b      	str	r3, [r1, #0]
         fine_priority[j] = extra_bits >= excess-balance;
   2dffa:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
   2dffe:	bfb4      	ite	lt
   2e000:	2500      	movlt	r5, #0
   2e002:	2501      	movge	r5, #1
   2e004:	f843 5026 	str.w	r5, [r3, r6, lsl #2]
         excess -= extra_bits;
   2e008:	eba2 0b04 	sub.w	fp, r2, r4
   for (j=start;j<codedBands;j++)
   2e00c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   2e00e:	4563      	cmp	r3, ip
   2e010:	f106 0601 	add.w	r6, r6, #1
   2e014:	f101 0104 	add.w	r1, r1, #4
   2e018:	f47f af67 	bne.w	2deea <clt_compute_allocation+0x8e2>
   2e01c:	69fb      	ldr	r3, [r7, #28]
   2e01e:	66bb      	str	r3, [r7, #104]	; 0x68
   *_balance = balance;
   2e020:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
   2e024:	f8c3 b000 	str.w	fp, [r3]
   for (;j<end;j++)
   2e028:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   2e02a:	4619      	mov	r1, r3
   2e02c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   2e02e:	4299      	cmp	r1, r3
   2e030:	dd23      	ble.n	2e07a <clt_compute_allocation+0xa72>
   2e032:	f103 4280 	add.w	r2, r3, #1073741824	; 0x40000000
   2e036:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
      bits[j] = 0;
   2e03a:	6afe      	ldr	r6, [r7, #44]	; 0x2c
   2e03c:	1f1c      	subs	r4, r3, #4
   2e03e:	3a01      	subs	r2, #1
   2e040:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
   2e044:	0092      	lsls	r2, r2, #2
   2e046:	1899      	adds	r1, r3, r2
   2e048:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
   2e04c:	1898      	adds	r0, r3, r2
   2e04e:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
   2e052:	441a      	add	r2, r3
   2e054:	69bb      	ldr	r3, [r7, #24]
   2e056:	2500      	movs	r5, #0
   2e058:	441c      	add	r4, r3
      ebits[j] = bits[j] >> stereo >> BITRES;
   2e05a:	f852 3f04 	ldr.w	r3, [r2, #4]!
   2e05e:	4133      	asrs	r3, r6
   2e060:	10db      	asrs	r3, r3, #3
   2e062:	f841 3f04 	str.w	r3, [r1, #4]!
      bits[j] = 0;
   2e066:	6015      	str	r5, [r2, #0]
      fine_priority[j] = ebits[j]<1;
   2e068:	680b      	ldr	r3, [r1, #0]
   2e06a:	2b00      	cmp	r3, #0
   2e06c:	bfcc      	ite	gt
   2e06e:	2300      	movgt	r3, #0
   2e070:	2301      	movle	r3, #1
   for (;j<end;j++)
   2e072:	42a2      	cmp	r2, r4
      fine_priority[j] = ebits[j]<1;
   2e074:	f840 3f04 	str.w	r3, [r0, #4]!
   for (;j<end;j++)
   2e078:	d1ef      	bne.n	2e05a <clt_compute_allocation+0xa52>
   codedBands = interp_bits2pulses(m, start, end, skip_start, bits1, bits2, thresh, cap,
         total, balance, skip_rsv, intensity, intensity_rsv, dual_stereo, dual_stereo_rsv,
         pulses, ebits, fine_priority, C, LM, ec, encode, prev, signalBandwidth);
   RESTORE_STACK;
   return codedBands;
}
   2e07a:	69f8      	ldr	r0, [r7, #28]
   2e07c:	3774      	adds	r7, #116	; 0x74
   2e07e:	46bd      	mov	sp, r7
   2e080:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      t = EC_ILOG(d&-d);
   2e084:	4250      	negs	r0, r2
   2e086:	4010      	ands	r0, r2
   2e088:	fab0 f080 	clz	r0, r0
   2e08c:	f1c0 0020 	rsb	r0, r0, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   2e090:	fa22 f300 	lsr.w	r3, r2, r0
   2e094:	498a      	ldr	r1, [pc, #552]	; (2e2c0 <clt_compute_allocation+0xcb8>)
   2e096:	3801      	subs	r0, #1
   2e098:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   2e09c:	fa2b f000 	lsr.w	r0, fp, r0
   2e0a0:	fba0 0103 	umull	r0, r1, r0, r3
      return q+(n-q*d >= d);
   2e0a4:	fb02 b311 	mls	r3, r2, r1, fp
   2e0a8:	429a      	cmp	r2, r3
   2e0aa:	bf8c      	ite	hi
   2e0ac:	460b      	movhi	r3, r1
   2e0ae:	1c4b      	addls	r3, r1, #1
   2e0b0:	e623      	b.n	2dcfa <clt_compute_allocation+0x6f2>
   2e0b2:	461a      	mov	r2, r3
            if (codedBands<=start+2 || (band_bits > (depth_threshold*band_width<<LM<<BITRES)>>4 && j<=signalBandwidth))
   2e0b4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   2e0b6:	3302      	adds	r3, #2
   2e0b8:	4293      	cmp	r3, r2
               depth_threshold = 0;
   2e0ba:	f04f 0e00 	mov.w	lr, #0
            if (codedBands<=start+2 || (band_bits > (depth_threshold*band_width<<LM<<BITRES)>>4 && j<=signalBandwidth))
   2e0be:	f6ff ae50 	blt.w	2dd62 <clt_compute_allocation+0x75a>
               ec_enc_bit_logp(ec, 1, 1);
   2e0c2:	2201      	movs	r2, #1
   2e0c4:	4611      	mov	r1, r2
   2e0c6:	f8d7 00c4 	ldr.w	r0, [r7, #196]	; 0xc4
   2e0ca:	f8d7 a04c 	ldr.w	sl, [r7, #76]	; 0x4c
   2e0ce:	f7fb fe6b 	bl	29da8 <ec_enc_bit_logp>
   if (intensity_rsv > 0)
   2e0d2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   2e0d4:	2b00      	cmp	r3, #0
   2e0d6:	d03b      	beq.n	2e150 <clt_compute_allocation+0xb48>
         *intensity = IMIN(*intensity, codedBands);
   2e0d8:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
   2e0dc:	f8d7 00a0 	ldr.w	r0, [r7, #160]	; 0xa0
   2e0e0:	6819      	ldr	r1, [r3, #0]
         ec_enc_uint(ec, *intensity-start, codedBands+1-start);
   2e0e2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
   2e0e4:	61fb      	str	r3, [r7, #28]
         *intensity = IMIN(*intensity, codedBands);
   2e0e6:	4299      	cmp	r1, r3
   2e0e8:	bfa8      	it	ge
   2e0ea:	4619      	movge	r1, r3
   2e0ec:	6001      	str	r1, [r0, #0]
         ec_enc_uint(ec, *intensity-start, codedBands+1-start);
   2e0ee:	6eb8      	ldr	r0, [r7, #104]	; 0x68
   2e0f0:	1c5a      	adds	r2, r3, #1
   2e0f2:	1a09      	subs	r1, r1, r0
   2e0f4:	1a12      	subs	r2, r2, r0
   2e0f6:	f8d7 00c4 	ldr.w	r0, [r7, #196]	; 0xc4
   2e0fa:	f7fb ff33 	bl	29f64 <ec_enc_uint>
   2e0fe:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
   2e102:	6818      	ldr	r0, [r3, #0]
   if (*intensity <= start)
   2e104:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   2e106:	4283      	cmp	r3, r0
         ec_enc_uint(ec, *intensity-start, codedBands+1-start);
   2e108:	46c8      	mov	r8, r9
   if (*intensity <= start)
   2e10a:	f6bf ae85 	bge.w	2de18 <clt_compute_allocation+0x810>
   if (dual_stereo_rsv > 0)
   2e10e:	693b      	ldr	r3, [r7, #16]
   2e110:	2b00      	cmp	r3, #0
   2e112:	f43f ae85 	beq.w	2de20 <clt_compute_allocation+0x818>
      if (encode)
   2e116:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
   2e11a:	2b00      	cmp	r3, #0
   2e11c:	f000 80ae 	beq.w	2e27c <clt_compute_allocation+0xc74>
         ec_enc_bit_logp(ec, *dual_stereo, 1);
   2e120:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
   2e124:	f8d7 00c4 	ldr.w	r0, [r7, #196]	; 0xc4
   2e128:	6819      	ldr	r1, [r3, #0]
   2e12a:	2201      	movs	r2, #1
   2e12c:	f7fb fe3c 	bl	29da8 <ec_enc_bit_logp>
   2e130:	e67a      	b.n	2de28 <clt_compute_allocation+0x820>
         } else if (ec_dec_bit_logp(ec, 1)) {
   2e132:	2101      	movs	r1, #1
   2e134:	f8d7 00c4 	ldr.w	r0, [r7, #196]	; 0xc4
   2e138:	f7fb fb92 	bl	29860 <ec_dec_bit_logp>
   2e13c:	2800      	cmp	r0, #0
   2e13e:	f43f ae25 	beq.w	2dd8c <clt_compute_allocation+0x784>
   if (intensity_rsv > 0)
   2e142:	e9d7 a313 	ldrd	sl, r3, [r7, #76]	; 0x4c
   2e146:	b11b      	cbz	r3, 2e150 <clt_compute_allocation+0xb48>
   2e148:	6efb      	ldr	r3, [r7, #108]	; 0x6c
   2e14a:	61fb      	str	r3, [r7, #28]
   2e14c:	46c8      	mov	r8, r9
   2e14e:	e653      	b.n	2ddf8 <clt_compute_allocation+0x7f0>
   2e150:	6efb      	ldr	r3, [r7, #108]	; 0x6c
   2e152:	61fb      	str	r3, [r7, #28]
   2e154:	46c8      	mov	r8, r9
      *intensity = 0;
   2e156:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
   2e15a:	2000      	movs	r0, #0
   2e15c:	6018      	str	r0, [r3, #0]
   2e15e:	e657      	b.n	2de10 <clt_compute_allocation+0x808>
      if(excess > 0)
   2e160:	4693      	mov	fp, r2
   2e162:	e753      	b.n	2e00c <clt_compute_allocation+0xa04>
         excess = MAX32(0,bit-(C<<BITRES));
   2e164:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   2e166:	1aea      	subs	r2, r5, r3
   2e168:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
         ebits[j] = 0;
   2e16c:	2300      	movs	r3, #0
         bits[j] = bit-excess;
   2e16e:	1aad      	subs	r5, r5, r2
   2e170:	6005      	str	r5, [r0, #0]
         ebits[j] = 0;
   2e172:	600b      	str	r3, [r1, #0]
         fine_priority[j] = 1;
   2e174:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
   2e178:	461c      	mov	r4, r3
   2e17a:	2301      	movs	r3, #1
   2e17c:	f844 3026 	str.w	r3, [r4, r6, lsl #2]
   2e180:	e727      	b.n	2dfd2 <clt_compute_allocation+0x9ca>
      t = EC_ILOG(d&-d);
   2e182:	f1ce 0400 	rsb	r4, lr, #0
   2e186:	ea04 040e 	and.w	r4, r4, lr
   2e18a:	fab4 f484 	clz	r4, r4
   2e18e:	f1c4 0420 	rsb	r4, r4, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   2e192:	fa2e f504 	lsr.w	r5, lr, r4
   2e196:	f104 3aff 	add.w	sl, r4, #4294967295	; 0xffffffff
   2e19a:	4c49      	ldr	r4, [pc, #292]	; (2e2c0 <clt_compute_allocation+0xcb8>)
   2e19c:	f854 5025 	ldr.w	r5, [r4, r5, lsl #2]
   2e1a0:	fa23 f40a 	lsr.w	r4, r3, sl
   2e1a4:	fba4 4505 	umull	r4, r5, r4, r5
      return q+(n-q*d >= d);
   2e1a8:	fb0e 3315 	mls	r3, lr, r5, r3
   2e1ac:	459e      	cmp	lr, r3
   2e1ae:	bf8c      	ite	hi
   2e1b0:	462b      	movhi	r3, r5
   2e1b2:	1c6b      	addls	r3, r5, #1
   2e1b4:	e6e8      	b.n	2df88 <clt_compute_allocation+0x980>
         else if (bits[j] + offset < den*3<<BITRES)
   2e1b6:	44f2      	add	sl, lr
   2e1b8:	ebb3 0fca 	cmp.w	r3, sl, lsl #3
            offset += NClogN>>3;
   2e1bc:	bfbc      	itt	lt
   2e1be:	eb08 08e4 	addlt.w	r8, r8, r4, asr #3
   2e1c2:	eb05 0308 	addlt.w	r3, r5, r8
   2e1c6:	e6d5      	b.n	2df74 <clt_compute_allocation+0x96c>
         NClogN = den*(m->logN[j] + logM);
   2e1c8:	00a4      	lsls	r4, r4, #2
         offset = (NClogN>>1)-den*FINE_OFFSET;
   2e1ca:	ea4f 0864 	mov.w	r8, r4, asr #1
   2e1ce:	2320      	movs	r3, #32
   2e1d0:	f1a8 0854 	sub.w	r8, r8, #84	; 0x54
   2e1d4:	66fb      	str	r3, [r7, #108]	; 0x6c
            offset += den<<BITRES>>2;
   2e1d6:	eb08 08a3 	add.w	r8, r8, r3, asr #2
   2e1da:	e6bf      	b.n	2df5c <clt_compute_allocation+0x954>
         den=(C*N+ ((C==2 && N>2 && !*dual_stereo && j<*intensity) ? 1 : 0));
   2e1dc:	f1ba 0f02 	cmp.w	sl, #2
   2e1e0:	d0f2      	beq.n	2e1c8 <clt_compute_allocation+0xbc0>
   2e1e2:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
   2e1e6:	681b      	ldr	r3, [r3, #0]
   2e1e8:	b933      	cbnz	r3, 2e1f8 <clt_compute_allocation+0xbf0>
   2e1ea:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
   2e1ee:	681b      	ldr	r3, [r3, #0]
   2e1f0:	42b3      	cmp	r3, r6
   2e1f2:	dd01      	ble.n	2e1f8 <clt_compute_allocation+0xbf0>
   2e1f4:	f10e 0e01 	add.w	lr, lr, #1
         offset = (NClogN>>1)-den*FINE_OFFSET;
   2e1f8:	f06f 0314 	mvn.w	r3, #20
   2e1fc:	fb03 f80e 	mul.w	r8, r3, lr
         NClogN = den*(m->logN[j] + logM);
   2e200:	fb04 f40e 	mul.w	r4, r4, lr
   2e204:	ea4f 03ce 	mov.w	r3, lr, lsl #3
         offset = (NClogN>>1)-den*FINE_OFFSET;
   2e208:	eb08 0864 	add.w	r8, r8, r4, asr #1
   2e20c:	66fb      	str	r3, [r7, #108]	; 0x6c
   2e20e:	e6a5      	b.n	2df5c <clt_compute_allocation+0x954>
      t = EC_ILOG(d&-d);
   2e210:	424b      	negs	r3, r1
   2e212:	400b      	ands	r3, r1
   2e214:	fab3 f383 	clz	r3, r3
   2e218:	f1c3 0320 	rsb	r3, r3, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   2e21c:	fa21 f003 	lsr.w	r0, r1, r3
   2e220:	4a27      	ldr	r2, [pc, #156]	; (2e2c0 <clt_compute_allocation+0xcb8>)
   2e222:	3b01      	subs	r3, #1
   2e224:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
   2e228:	fa25 f303 	lsr.w	r3, r5, r3
   2e22c:	fba3 2302 	umull	r2, r3, r3, r2
      return q+(n-q*d >= d);
   2e230:	fb01 5e13 	mls	lr, r1, r3, r5
   2e234:	4571      	cmp	r1, lr
   2e236:	bf8c      	ite	hi
   2e238:	469e      	movhi	lr, r3
   2e23a:	f103 0e01 	addls.w	lr, r3, #1
   left -= (m->eBands[codedBands]-m->eBands[start])*percoeff;
   2e23e:	fb0e 5511 	mls	r5, lr, r1, r5
   for (j=start;j<codedBands;j++)
   2e242:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   2e244:	69f9      	ldr	r1, [r7, #28]
   2e246:	428b      	cmp	r3, r1
   2e248:	f6ff ae08 	blt.w	2de5c <clt_compute_allocation+0x854>
   balance = 0;
   2e24c:	f04f 0b00 	mov.w	fp, #0
   2e250:	e6e6      	b.n	2e020 <clt_compute_allocation+0xa18>
      intensity_rsv = LOG2_FRAC_TABLE[end-start];
   2e252:	6eb9      	ldr	r1, [r7, #104]	; 0x68
   2e254:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   2e256:	4a1b      	ldr	r2, [pc, #108]	; (2e2c4 <clt_compute_allocation+0xcbc>)
   2e258:	1a5b      	subs	r3, r3, r1
      if (intensity_rsv>total)
   2e25a:	6df9      	ldr	r1, [r7, #92]	; 0x5c
      intensity_rsv = LOG2_FRAC_TABLE[end-start];
   2e25c:	5cd3      	ldrb	r3, [r2, r3]
   2e25e:	653b      	str	r3, [r7, #80]	; 0x50
      if (intensity_rsv>total)
   2e260:	428b      	cmp	r3, r1
   2e262:	f73f a9ed 	bgt.w	2d640 <clt_compute_allocation+0x38>
         total -= intensity_rsv;
   2e266:	1acb      	subs	r3, r1, r3
         dual_stereo_rsv = total>=1<<BITRES ? 1<<BITRES : 0;
   2e268:	2b07      	cmp	r3, #7
         total -= intensity_rsv;
   2e26a:	65fb      	str	r3, [r7, #92]	; 0x5c
   2e26c:	bfc5      	ittet	gt
   2e26e:	3b08      	subgt	r3, #8
   2e270:	65fb      	strgt	r3, [r7, #92]	; 0x5c
         dual_stereo_rsv = total>=1<<BITRES ? 1<<BITRES : 0;
   2e272:	2300      	movle	r3, #0
   2e274:	2308      	movgt	r3, #8
   2e276:	613b      	str	r3, [r7, #16]
   2e278:	f7ff b9e5 	b.w	2d646 <clt_compute_allocation+0x3e>
         *dual_stereo = ec_dec_bit_logp(ec, 1);
   2e27c:	2101      	movs	r1, #1
   2e27e:	f8d7 00c4 	ldr.w	r0, [r7, #196]	; 0xc4
   2e282:	f7fb faed 	bl	29860 <ec_dec_bit_logp>
   2e286:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
   2e28a:	6018      	str	r0, [r3, #0]
   2e28c:	e5cc      	b.n	2de28 <clt_compute_allocation+0x820>
   2e28e:	005b      	lsls	r3, r3, #1
   2e290:	647b      	str	r3, [r7, #68]	; 0x44
   2e292:	1e53      	subs	r3, r2, #1
   2e294:	63fb      	str	r3, [r7, #60]	; 0x3c
   2e296:	4613      	mov	r3, r2
   2e298:	f7ff baaf 	b.w	2d7fa <clt_compute_allocation+0x1f2>
      if (encode)
   2e29c:	69fb      	ldr	r3, [r7, #28]
   2e29e:	66fb      	str	r3, [r7, #108]	; 0x6c
   2e2a0:	46c1      	mov	r9, r8
   2e2a2:	e719      	b.n	2e0d8 <clt_compute_allocation+0xad0>
   2e2a4:	4614      	mov	r4, r2
   2e2a6:	460a      	mov	r2, r1
   2e2a8:	f7ff ba69 	b.w	2d77e <clt_compute_allocation+0x176>
            cap[j] : C*N*m->allocVectors[hi*len+j]<<LM>>2;
   2e2ac:	4618      	mov	r0, r3
   2e2ae:	65bb      	str	r3, [r7, #88]	; 0x58
   2e2b0:	f7ff bbeb 	b.w	2da8a <clt_compute_allocation+0x482>
   2e2b4:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2e2b6:	f103 0802 	add.w	r8, r3, #2
      if (j<=skip_start)
   2e2ba:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   2e2bc:	61fb      	str	r3, [r7, #28]
   2e2be:	e58e      	b.n	2ddde <clt_compute_allocation+0x7d6>
   2e2c0:	00038e98 	.word	0x00038e98
   2e2c4:	0003b59c 	.word	0x0003b59c

0002e2c8 <exp_rotation1>:
#include "rate.h"
#include "pitch.h"

#ifndef OVERRIDE_vq_exp_rotation1
static void exp_rotation1(celt_norm *X, int len, int stride, opus_val16 c, opus_val16 s)
{
   2e2c8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2e2cc:	f9bd 5020 	ldrsh.w	r5, [sp, #32]
   int i;
   opus_val16 ms;
   celt_norm *Xptr;
   Xptr = X;
   ms = NEG16(s);
   for (i=0;i<len-stride;i++)
   2e2d0:	1a89      	subs	r1, r1, r2
   ms = NEG16(s);
   2e2d2:	426e      	negs	r6, r5
   for (i=0;i<len-stride;i++)
   2e2d4:	2900      	cmp	r1, #0
   ms = NEG16(s);
   2e2d6:	b236      	sxth	r6, r6
   for (i=0;i<len-stride;i++)
   2e2d8:	dd21      	ble.n	2e31e <exp_rotation1+0x56>
   2e2da:	eb00 0e42 	add.w	lr, r0, r2, lsl #1
   2e2de:	eb00 0841 	add.w	r8, r0, r1, lsl #1
   2e2e2:	f1ae 0e02 	sub.w	lr, lr, #2
   2e2e6:	f1a8 0802 	sub.w	r8, r8, #2
   2e2ea:	f1a0 0c02 	sub.w	ip, r0, #2
   {
      celt_norm x1, x2;
      x1 = Xptr[0];
   2e2ee:	f93c 4f02 	ldrsh.w	r4, [ip, #2]!
      x2 = Xptr[stride];
   2e2f2:	f93e 7f02 	ldrsh.w	r7, [lr, #2]!
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2e2f6:	fb04 fa05 	mul.w	sl, r4, r5
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2e2fa:	fb07 f906 	mul.w	r9, r7, r6
   2e2fe:	fb04 9403 	mla	r4, r4, r3, r9
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2e302:	fb07 a703 	mla	r7, r7, r3, sl
   2e306:	f507 4780 	add.w	r7, r7, #16384	; 0x4000
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2e30a:	f504 4480 	add.w	r4, r4, #16384	; 0x4000
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2e30e:	13ff      	asrs	r7, r7, #15
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2e310:	13e4      	asrs	r4, r4, #15
   for (i=0;i<len-stride;i++)
   2e312:	45e0      	cmp	r8, ip
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2e314:	f8ae 7000 	strh.w	r7, [lr]
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2e318:	f8ac 4000 	strh.w	r4, [ip]
   for (i=0;i<len-stride;i++)
   2e31c:	d1e7      	bne.n	2e2ee <exp_rotation1+0x26>
   }
   Xptr = &X[len-2*stride-1];
   2e31e:	1a89      	subs	r1, r1, r2
   2e320:	f101 4400 	add.w	r4, r1, #2147483648	; 0x80000000
   2e324:	3c01      	subs	r4, #1
   for (i=len-2*stride-1;i>=0;i--)
   2e326:	2900      	cmp	r1, #0
   Xptr = &X[len-2*stride-1];
   2e328:	eb00 0044 	add.w	r0, r0, r4, lsl #1
   for (i=len-2*stride-1;i>=0;i--)
   2e32c:	dd1d      	ble.n	2e36a <exp_rotation1+0xa2>
   2e32e:	0049      	lsls	r1, r1, #1
   2e330:	eb00 0242 	add.w	r2, r0, r2, lsl #1
   2e334:	f1c1 0702 	rsb	r7, r1, #2
   2e338:	4407      	add	r7, r0
   2e33a:	1c94      	adds	r4, r2, #2
   2e33c:	3002      	adds	r0, #2
   {
      celt_norm x1, x2;
      x1 = Xptr[0];
   2e33e:	f930 2d02 	ldrsh.w	r2, [r0, #-2]!
      x2 = Xptr[stride];
   2e342:	f934 1d02 	ldrsh.w	r1, [r4, #-2]!
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2e346:	fb02 fe05 	mul.w	lr, r2, r5
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2e34a:	fb01 fc06 	mul.w	ip, r1, r6
   2e34e:	fb02 c203 	mla	r2, r2, r3, ip
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2e352:	fb01 e103 	mla	r1, r1, r3, lr
   2e356:	f501 4180 	add.w	r1, r1, #16384	; 0x4000
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2e35a:	f502 4280 	add.w	r2, r2, #16384	; 0x4000
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2e35e:	13c9      	asrs	r1, r1, #15
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2e360:	13d2      	asrs	r2, r2, #15
   for (i=len-2*stride-1;i>=0;i--)
   2e362:	42b8      	cmp	r0, r7
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2e364:	8021      	strh	r1, [r4, #0]
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2e366:	8002      	strh	r2, [r0, #0]
   for (i=len-2*stride-1;i>=0;i--)
   2e368:	d1e9      	bne.n	2e33e <exp_rotation1+0x76>
   }
}
   2e36a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2e36e:	bf00      	nop

0002e370 <op_pvq_search_c>:
   } while (++i<B);
   return collapse_mask;
}

opus_val16 op_pvq_search_c(celt_norm *X, int *iy, int K, int N, int arch)
{
   2e370:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   opus_val32 xy;
   opus_val16 yy;
   SAVE_STACK;

   (void)arch;
   ALLOC(y, N, celt_norm);
   2e374:	005d      	lsls	r5, r3, #1
{
   2e376:	b08b      	sub	sp, #44	; 0x2c
   2e378:	469b      	mov	fp, r3
   ALLOC(y, N, celt_norm);
   2e37a:	f105 0408 	add.w	r4, r5, #8
   ALLOC(signx, N, int);
   2e37e:	009b      	lsls	r3, r3, #2
   ALLOC(y, N, celt_norm);
   2e380:	f024 0407 	bic.w	r4, r4, #7
{
   2e384:	af00      	add	r7, sp, #0
   ALLOC(signx, N, int);
   2e386:	330a      	adds	r3, #10
   ALLOC(y, N, celt_norm);
   2e388:	ebad 0d04 	sub.w	sp, sp, r4
   ALLOC(signx, N, int);
   2e38c:	f023 0307 	bic.w	r3, r3, #7
   ALLOC(y, N, celt_norm);
   2e390:	f8c7 d01c 	str.w	sp, [r7, #28]
   ALLOC(signx, N, int);
   2e394:	ebad 0d03 	sub.w	sp, sp, r3
{
   2e398:	e9c7 1005 	strd	r1, r0, [r7, #20]
   2e39c:	1e84      	subs	r4, r0, #2
   2e39e:	f1ad 0604 	sub.w	r6, sp, #4
   2e3a2:	1f08      	subs	r0, r1, #4

   /* Get rid of the sign */
   sum = 0;
   j=0; do {
   2e3a4:	2100      	movs	r1, #0
{
   2e3a6:	4690      	mov	r8, r2
   2e3a8:	603e      	str	r6, [r7, #0]
   2e3aa:	6078      	str	r0, [r7, #4]
   ALLOC(signx, N, int);
   2e3ac:	4622      	mov	r2, r4
      signx[j] = X[j]<0;
      /* OPT: Make sure the compiler doesn't use a branch on ABS16(). */
      X[j] = ABS16(X[j]);
      iy[j] = 0;
   2e3ae:	468e      	mov	lr, r1
      signx[j] = X[j]<0;
   2e3b0:	f932 3f02 	ldrsh.w	r3, [r2, #2]!
      y[j] = 0;
   } while (++j<N);
   2e3b4:	3101      	adds	r1, #1
      X[j] = ABS16(X[j]);
   2e3b6:	ea83 7ce3 	eor.w	ip, r3, r3, asr #31
   2e3ba:	ebac 7ce3 	sub.w	ip, ip, r3, asr #31
   } while (++j<N);
   2e3be:	458b      	cmp	fp, r1
      signx[j] = X[j]<0;
   2e3c0:	ea4f 73d3 	mov.w	r3, r3, lsr #31
      X[j] = ABS16(X[j]);
   2e3c4:	f8a2 c000 	strh.w	ip, [r2]
      signx[j] = X[j]<0;
   2e3c8:	f846 3f04 	str.w	r3, [r6, #4]!
      iy[j] = 0;
   2e3cc:	f840 ef04 	str.w	lr, [r0, #4]!
   } while (++j<N);
   2e3d0:	dcee      	bgt.n	2e3b0 <op_pvq_search_c+0x40>
      y[j] = 0;
   2e3d2:	f1bb 0f00 	cmp.w	fp, #0
   2e3d6:	bfcc      	ite	gt
   2e3d8:	462a      	movgt	r2, r5
   2e3da:	2202      	movle	r2, #2
   2e3dc:	2100      	movs	r1, #0
   2e3de:	69f8      	ldr	r0, [r7, #28]
   2e3e0:	f006 fec0 	bl	35164 <memset>
   xy = yy = 0;

   pulsesLeft = K;

   /* Do a pre-search by projecting on the pyramid */
   if (K > (N>>1))
   2e3e4:	ebb8 0f6b 	cmp.w	r8, fp, asr #1
   2e3e8:	f340 80b6 	ble.w	2e558 <op_pvq_search_c+0x1e8>
   sum = 0;
   2e3ec:	2600      	movs	r6, #0
   {
      opus_val16 rcp;
      j=0; do {
   2e3ee:	4633      	mov	r3, r6
   2e3f0:	4622      	mov	r2, r4
         sum += X[j];
   2e3f2:	f932 1f02 	ldrsh.w	r1, [r2, #2]!
      }  while (++j<N);
   2e3f6:	3301      	adds	r3, #1
   2e3f8:	459b      	cmp	fp, r3
         sum += X[j];
   2e3fa:	440e      	add	r6, r1
      }  while (++j<N);
   2e3fc:	dcf9      	bgt.n	2e3f2 <op_pvq_search_c+0x82>

      /* If X is too small, just replace it with a pulse at 0 */
#ifdef FIXED_POINT
      if (sum <= K)
   2e3fe:	45b0      	cmp	r8, r6
   2e400:	f280 80bd 	bge.w	2e57e <op_pvq_search_c+0x20e>
            X[j]=0;
         while (++j<N);
         sum = QCONST16(1.f,14);
      }
#ifdef FIXED_POINT
      rcp = EXTRACT16(MULT16_32_Q16(K, celt_rcp(sum)));
   2e404:	4630      	mov	r0, r6
   2e406:	f7fd f8f1 	bl	2b5ec <celt_rcp>
   2e40a:	fb10 f528 	smultb	r5, r0, r8
   2e40e:	4630      	mov	r0, r6
   2e410:	f7fd f8ec 	bl	2b5ec <celt_rcp>
   2e414:	fa0f f388 	sxth.w	r3, r8
   2e418:	b280      	uxth	r0, r0
   2e41a:	b2ad      	uxth	r5, r5
   2e41c:	fb03 f300 	mul.w	r3, r3, r0
   2e420:	eb05 4323 	add.w	r3, r5, r3, asr #16
   2e424:	fa0f f983 	sxth.w	r9, r3
   2e428:	69fb      	ldr	r3, [r7, #28]
   2e42a:	f8d7 e004 	ldr.w	lr, [r7, #4]
   xy = yy = 0;
   2e42e:	2000      	movs	r0, #0
   2e430:	4682      	mov	sl, r0
#else
      /* Using K+e with e < 1 guarantees we cannot get more than K pulses. */
      rcp = EXTRACT16(MULT16_32_Q16(K+0.8f, celt_rcp(sum)));
#endif
      j=0; do {
   2e432:	4605      	mov	r5, r0
   2e434:	f1a3 0c02 	sub.w	ip, r3, #2
      rcp = EXTRACT16(MULT16_32_Q16(K, celt_rcp(sum)));
   2e438:	4641      	mov	r1, r8
#ifdef FIXED_POINT
         /* It's really important to round *towards zero* here */
         iy[j] = MULT16_16_Q15(X[j],rcp);
   2e43a:	f934 6f02 	ldrsh.w	r6, [r4, #2]!
   2e43e:	fb06 f309 	mul.w	r3, r6, r9
   2e442:	13db      	asrs	r3, r3, #15
#else
         iy[j] = (int)floor(rcp*X[j]);
#endif
         y[j] = (celt_norm)iy[j];
         yy = MAC16_16(yy, y[j],y[j]);
   2e444:	b29a      	uxth	r2, r3
         xy = MAC16_16(xy, X[j],y[j]);
         y[j] *= 2;
         pulsesLeft -= iy[j];
      }  while (++j<N);
   2e446:	3501      	adds	r5, #1
         yy = MAC16_16(yy, y[j],y[j]);
   2e448:	fb12 0002 	smlabb	r0, r2, r2, r0
      }  while (++j<N);
   2e44c:	45ab      	cmp	fp, r5
         y[j] *= 2;
   2e44e:	ea4f 0242 	mov.w	r2, r2, lsl #1
         iy[j] = MULT16_16_Q15(X[j],rcp);
   2e452:	f84e 3f04 	str.w	r3, [lr, #4]!
         xy = MAC16_16(xy, X[j],y[j]);
   2e456:	fb16 aa03 	smlabb	sl, r6, r3, sl
         pulsesLeft -= iy[j];
   2e45a:	eba1 0103 	sub.w	r1, r1, r3
         yy = MAC16_16(yy, y[j],y[j]);
   2e45e:	b200      	sxth	r0, r0
         y[j] *= 2;
   2e460:	f82c 2f02 	strh.w	r2, [ip, #2]!
      }  while (++j<N);
   2e464:	dce9      	bgt.n	2e43a <op_pvq_search_c+0xca>
   /* This should never happen, but just in case it does (e.g. on silence)
      we fill the first bin with pulses. */
#ifdef FIXED_POINT_DEBUG
   celt_sig_assert(pulsesLeft<=N+3);
#endif
   if (pulsesLeft > N+3)
   2e466:	f10b 0303 	add.w	r3, fp, #3
   2e46a:	4299      	cmp	r1, r3
   2e46c:	dc7b      	bgt.n	2e566 <op_pvq_search_c+0x1f6>
      yy = MAC16_16(yy, tmp, y[0]);
      iy[0] += pulsesLeft;
      pulsesLeft=0;
   }

   for (i=0;i<pulsesLeft;i++)
   2e46e:	2900      	cmp	r1, #0
   2e470:	dd60      	ble.n	2e534 <op_pvq_search_c+0x1c4>

      /* Calculations for position 0 are out of the loop, in part to reduce
         mispredicted branches (since the if condition is usually false)
         in the loop. */
      /* Temporary sums of the new pulse(s) */
      Rxy = EXTRACT16(SHR32(ADD32(xy, EXTEND32(X[0])),rshift));
   2e472:	69bb      	ldr	r3, [r7, #24]
   2e474:	69fd      	ldr	r5, [r7, #28]
   2e476:	f9b3 3000 	ldrsh.w	r3, [r3]
   2e47a:	60fb      	str	r3, [r7, #12]
   2e47c:	eba8 0801 	sub.w	r8, r8, r1
   2e480:	3101      	adds	r1, #1
   2e482:	eb01 0308 	add.w	r3, r1, r8
   2e486:	60bb      	str	r3, [r7, #8]
   2e488:	f108 0301 	add.w	r3, r8, #1
   2e48c:	627b      	str	r3, [r7, #36]	; 0x24
   2e48e:	4604      	mov	r4, r0
   2e490:	f8c7 b010 	str.w	fp, [r7, #16]
   return EC_ILOG(x)-1;
   2e494:	6a7b      	ldr	r3, [r7, #36]	; 0x24
      /* We're multiplying y[j] by two so we don't have to do it here */
      Ryy = ADD16(yy, y[0]);
   2e496:	f8b5 9000 	ldrh.w	r9, [r5]
   2e49a:	69be      	ldr	r6, [r7, #24]
   2e49c:	fab3 f883 	clz	r8, r3
      Rxy = EXTRACT16(SHR32(ADD32(xy, EXTEND32(X[0])),rshift));
   2e4a0:	68fb      	ldr	r3, [r7, #12]
      yy = ADD16(yy, 1);
   2e4a2:	3401      	adds	r4, #1
      rshift = 1+celt_ilog2(K-pulsesLeft+i+1);
   2e4a4:	f1c8 0820 	rsb	r8, r8, #32
      Rxy = EXTRACT16(SHR32(ADD32(xy, EXTEND32(X[0])),rshift));
   2e4a8:	eb0a 0003 	add.w	r0, sl, r3
      best_id = 0;
   2e4ac:	f04f 0b00 	mov.w	fp, #0
      yy = ADD16(yy, 1);
   2e4b0:	b2a4      	uxth	r4, r4
      Rxy = EXTRACT16(SHR32(ADD32(xy, EXTEND32(X[0])),rshift));
   2e4b2:	fa40 f008 	asr.w	r0, r0, r8

      /* Approximate score: we maximise Rxy/sqrt(Ryy) (we're guaranteed that
         Rxy is positive because the sign is pre-computed) */
      Rxy = MULT16_16_Q15(Rxy,Rxy);
   2e4b6:	fb10 f000 	smulbb	r0, r0, r0
      Ryy = ADD16(yy, y[0]);
   2e4ba:	44a1      	add	r9, r4
      best_den = Ryy;
      best_num = Rxy;
      j=1;
   2e4bc:	f8c7 b020 	str.w	fp, [r7, #32]
   2e4c0:	f8d7 b010 	ldr.w	fp, [r7, #16]
      best_num = Rxy;
   2e4c4:	f340 30cf 	sbfx	r0, r0, #15, #16
      Ryy = ADD16(yy, y[0]);
   2e4c8:	fa0f f989 	sxth.w	r9, r9
      j=1;
   2e4cc:	2101      	movs	r1, #1
      do {
         /* Temporary sums of the new pulse(s) */
         Rxy = EXTRACT16(SHR32(ADD32(xy, EXTEND32(X[j])),rshift));
   2e4ce:	f936 3f02 	ldrsh.w	r3, [r6, #2]!
         /* We're multiplying y[j] by two so we don't have to do it here */
         Ryy = ADD16(yy, y[j]);
   2e4d2:	f835 2f02 	ldrh.w	r2, [r5, #2]!
         Rxy = EXTRACT16(SHR32(ADD32(xy, EXTEND32(X[j])),rshift));
   2e4d6:	4453      	add	r3, sl
   2e4d8:	fa43 f308 	asr.w	r3, r3, r8

         /* Approximate score: we maximise Rxy/sqrt(Ryy) (we're guaranteed that
            Rxy is positive because the sign is pre-computed) */
         Rxy = MULT16_16_Q15(Rxy,Rxy);
   2e4dc:	fb13 f303 	smulbb	r3, r3, r3
         Ryy = ADD16(yy, y[j]);
   2e4e0:	4422      	add	r2, r4
         Rxy = MULT16_16_Q15(Rxy,Rxy);
   2e4e2:	f343 33cf 	sbfx	r3, r3, #15, #16
         Ryy = ADD16(yy, y[j]);
   2e4e6:	b212      	sxth	r2, r2
            we can do it without any division */
         /* OPT: It's not clear whether a cmov is faster than a branch here
            since the condition is more often false than true and using
            a cmov introduces data dependencies across iterations. The optimal
            choice may be architecture-dependent. */
         if (opus_unlikely(MULT16_16(best_den, Rxy) > MULT16_16(Ryy, best_num)))
   2e4e8:	fb03 fc09 	mul.w	ip, r3, r9
   2e4ec:	fb00 fe02 	mul.w	lr, r0, r2
   2e4f0:	45e6      	cmp	lr, ip
   2e4f2:	db53      	blt.n	2e59c <op_pvq_search_c+0x22c>
         {
            best_den = Ryy;
            best_num = Rxy;
            best_id = j;
         }
      } while (++j<N);
   2e4f4:	3101      	adds	r1, #1
   2e4f6:	458b      	cmp	fp, r1
   2e4f8:	dce9      	bgt.n	2e4ce <op_pvq_search_c+0x15e>

      /* Updating the sums of the new pulse(s) */
      xy = ADD32(xy, EXTEND32(X[best_id]));
      /* We're multiplying y[j] by two so we don't have to do it here */
      yy = ADD16(yy, y[best_id]);
   2e4fa:	e9d7 5b07 	ldrd	r5, fp, [r7, #28]

      /* Only now that we've made the final choice, update y/iy */
      /* Multiplying y[j] by 2 so we don't have to do it everywhere else */
      y[best_id] += 2;
      iy[best_id]++;
   2e4fe:	697e      	ldr	r6, [r7, #20]
      xy = ADD32(xy, EXTEND32(X[best_id]));
   2e500:	69b9      	ldr	r1, [r7, #24]
      iy[best_id]++;
   2e502:	f856 302b 	ldr.w	r3, [r6, fp, lsl #2]
   2e506:	6a78      	ldr	r0, [r7, #36]	; 0x24
      yy = ADD16(yy, y[best_id]);
   2e508:	f835 201b 	ldrh.w	r2, [r5, fp, lsl #1]
      xy = ADD32(xy, EXTEND32(X[best_id]));
   2e50c:	f931 101b 	ldrsh.w	r1, [r1, fp, lsl #1]
      iy[best_id]++;
   2e510:	3301      	adds	r3, #1
   2e512:	f846 302b 	str.w	r3, [r6, fp, lsl #2]
   for (i=0;i<pulsesLeft;i++)
   2e516:	68bb      	ldr	r3, [r7, #8]
   2e518:	3001      	adds	r0, #1
      yy = ADD16(yy, y[best_id]);
   2e51a:	4414      	add	r4, r2
   for (i=0;i<pulsesLeft;i++)
   2e51c:	4283      	cmp	r3, r0
      y[best_id] += 2;
   2e51e:	f102 0202 	add.w	r2, r2, #2
   2e522:	6278      	str	r0, [r7, #36]	; 0x24
      yy = ADD16(yy, y[best_id]);
   2e524:	b224      	sxth	r4, r4
      y[best_id] += 2;
   2e526:	f825 201b 	strh.w	r2, [r5, fp, lsl #1]
      xy = ADD32(xy, EXTEND32(X[best_id]));
   2e52a:	448a      	add	sl, r1
   for (i=0;i<pulsesLeft;i++)
   2e52c:	d1b2      	bne.n	2e494 <op_pvq_search_c+0x124>
   2e52e:	f8d7 b010 	ldr.w	fp, [r7, #16]
   2e532:	4620      	mov	r0, r4
   }

   /* Put the original sign back */
   j=0;
   2e534:	e9d7 5200 	ldrd	r5, r2, [r7]
   2e538:	2400      	movs	r4, #0
   do {
      /*iy[j] = signx[j] ? -iy[j] : iy[j];*/
      /* OPT: The is more likely to be compiled without a branch than the code above
         but has the same performance otherwise. */
      iy[j] = (iy[j]^-signx[j]) + signx[j];
   2e53a:	f855 1f04 	ldr.w	r1, [r5, #4]!
   2e53e:	f852 6f04 	ldr.w	r6, [r2, #4]!
   2e542:	424b      	negs	r3, r1
   2e544:	4073      	eors	r3, r6
   } while (++j<N);
   2e546:	3401      	adds	r4, #1
      iy[j] = (iy[j]^-signx[j]) + signx[j];
   2e548:	440b      	add	r3, r1
   } while (++j<N);
   2e54a:	45a3      	cmp	fp, r4
      iy[j] = (iy[j]^-signx[j]) + signx[j];
   2e54c:	6013      	str	r3, [r2, #0]
   } while (++j<N);
   2e54e:	dcf4      	bgt.n	2e53a <op_pvq_search_c+0x1ca>
   RESTORE_STACK;
   return yy;
}
   2e550:	372c      	adds	r7, #44	; 0x2c
   2e552:	46bd      	mov	sp, r7
   2e554:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2e558:	4641      	mov	r1, r8
   if (pulsesLeft > N+3)
   2e55a:	f10b 0303 	add.w	r3, fp, #3
   xy = yy = 0;
   2e55e:	2000      	movs	r0, #0
   if (pulsesLeft > N+3)
   2e560:	4299      	cmp	r1, r3
   xy = yy = 0;
   2e562:	4682      	mov	sl, r0
   if (pulsesLeft > N+3)
   2e564:	dd83      	ble.n	2e46e <op_pvq_search_c+0xfe>
      yy = MAC16_16(yy, tmp, y[0]);
   2e566:	69fb      	ldr	r3, [r7, #28]
      iy[0] += pulsesLeft;
   2e568:	697d      	ldr	r5, [r7, #20]
      yy = MAC16_16(yy, tmp, y[0]);
   2e56a:	881a      	ldrh	r2, [r3, #0]
      iy[0] += pulsesLeft;
   2e56c:	682b      	ldr	r3, [r5, #0]
      yy = MAC16_16(yy, tmp, tmp);
   2e56e:	b28c      	uxth	r4, r1
      yy = MAC16_16(yy, tmp, y[0]);
   2e570:	4422      	add	r2, r4
   2e572:	fb12 0004 	smlabb	r0, r2, r4, r0
      iy[0] += pulsesLeft;
   2e576:	440b      	add	r3, r1
      yy = MAC16_16(yy, tmp, y[0]);
   2e578:	b200      	sxth	r0, r0
      iy[0] += pulsesLeft;
   2e57a:	602b      	str	r3, [r5, #0]
   2e57c:	e7da      	b.n	2e534 <op_pvq_search_c+0x1c4>
         X[0] = QCONST16(1.f,14);
   2e57e:	69b8      	ldr	r0, [r7, #24]
   2e580:	f44f 4680 	mov.w	r6, #16384	; 0x4000
            X[j]=0;
   2e584:	f1bb 0f01 	cmp.w	fp, #1
   2e588:	f1a5 0202 	sub.w	r2, r5, #2
         X[0] = QCONST16(1.f,14);
   2e58c:	f820 6b02 	strh.w	r6, [r0], #2
   2e590:	bfd8      	it	le
   2e592:	2202      	movle	r2, #2
   2e594:	2100      	movs	r1, #0
   2e596:	f006 fde5 	bl	35164 <memset>
   2e59a:	e733      	b.n	2e404 <op_pvq_search_c+0x94>
         Ryy = ADD16(yy, y[j]);
   2e59c:	4691      	mov	r9, r2
         if (opus_unlikely(MULT16_16(best_den, Rxy) > MULT16_16(Ryy, best_num)))
   2e59e:	4618      	mov	r0, r3
   2e5a0:	6239      	str	r1, [r7, #32]
   2e5a2:	e7a7      	b.n	2e4f4 <op_pvq_search_c+0x184>

0002e5a4 <alg_quant>:

unsigned alg_quant(celt_norm *X, int N, int K, int spread, int B, ec_enc *enc,
      opus_val16 gain, int resynth, int arch)
{
   2e5a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2e5a8:	460c      	mov	r4, r1

   celt_assert2(K>0, "alg_quant() needs at least one pulse");
   celt_assert2(N>1, "alg_quant() needs at least two dimensions");

   /* Covers vectorization by up to 4. */
   ALLOC(iy, N+3, int);
   2e5aa:	0089      	lsls	r1, r1, #2
{
   2e5ac:	b091      	sub	sp, #68	; 0x44
   ALLOC(iy, N+3, int);
   2e5ae:	3116      	adds	r1, #22
   2e5b0:	f021 0107 	bic.w	r1, r1, #7
{
   2e5b4:	af02      	add	r7, sp, #8
   ALLOC(iy, N+3, int);
   2e5b6:	ebad 0d01 	sub.w	sp, sp, r1
   2e5ba:	a902      	add	r1, sp, #8
{
   2e5bc:	62fa      	str	r2, [r7, #44]	; 0x2c
   if (2*K>=len || spread==SPREAD_NONE)
   2e5be:	0052      	lsls	r2, r2, #1
   ALLOC(iy, N+3, int);
   2e5c0:	6379      	str	r1, [r7, #52]	; 0x34
   if (2*K>=len || spread==SPREAD_NONE)
   2e5c2:	4294      	cmp	r4, r2
{
   2e5c4:	f9b7 1068 	ldrsh.w	r1, [r7, #104]	; 0x68
   if (2*K>=len || spread==SPREAD_NONE)
   2e5c8:	623a      	str	r2, [r7, #32]
{
   2e5ca:	6338      	str	r0, [r7, #48]	; 0x30
   2e5cc:	61fb      	str	r3, [r7, #28]
   2e5ce:	6e3e      	ldr	r6, [r7, #96]	; 0x60
   2e5d0:	61b9      	str	r1, [r7, #24]
   if (2*K>=len || spread==SPREAD_NONE)
   2e5d2:	dd02      	ble.n	2e5da <alg_quant+0x36>
   2e5d4:	2b00      	cmp	r3, #0
   2e5d6:	f040 8141 	bne.w	2e85c <alg_quant+0x2b8>

   exp_rotation(X, N, 1, B, K, spread);

   yy = op_pvq_search(X, iy, K, N, arch);
   2e5da:	f8d7 902c 	ldr.w	r9, [r7, #44]	; 0x2c
   2e5de:	f8d7 8034 	ldr.w	r8, [r7, #52]	; 0x34
   2e5e2:	6f3b      	ldr	r3, [r7, #112]	; 0x70
   2e5e4:	9300      	str	r3, [sp, #0]
   2e5e6:	464a      	mov	r2, r9
   2e5e8:	4623      	mov	r3, r4
   2e5ea:	4641      	mov	r1, r8
   2e5ec:	6b38      	ldr	r0, [r7, #48]	; 0x30
   2e5ee:	f7ff febf 	bl	2e370 <op_pvq_search_c>

   encode_pulses(iy, N, K, enc);
   2e5f2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   yy = op_pvq_search(X, iy, K, N, arch);
   2e5f4:	4605      	mov	r5, r0
   encode_pulses(iy, N, K, enc);
   2e5f6:	464a      	mov	r2, r9
   2e5f8:	4621      	mov	r1, r4
   2e5fa:	4640      	mov	r0, r8
   2e5fc:	f7fa fe74 	bl	292e8 <encode_pulses>

   if (resynth)
   2e600:	6efb      	ldr	r3, [r7, #108]	; 0x6c
   2e602:	2b00      	cmp	r3, #0
   2e604:	d140      	bne.n	2e688 <alg_quant+0xe4>
   if (B<=1)
   2e606:	2e01      	cmp	r6, #1
   2e608:	f340 811f 	ble.w	2e84a <alg_quant+0x2a6>
   if (d>256)
   2e60c:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
   2e610:	dc37      	bgt.n	2e682 <alg_quant+0xde>
      t = EC_ILOG(d&-d);
   2e612:	4273      	negs	r3, r6
   2e614:	4033      	ands	r3, r6
   2e616:	fab3 f383 	clz	r3, r3
   2e61a:	f1c3 0320 	rsb	r3, r3, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   2e61e:	fa26 f003 	lsr.w	r0, r6, r3
   2e622:	49af      	ldr	r1, [pc, #700]	; (2e8e0 <alg_quant+0x33c>)
   2e624:	1e5a      	subs	r2, r3, #1
   2e626:	f851 3020 	ldr.w	r3, [r1, r0, lsl #2]
   2e62a:	fa24 f202 	lsr.w	r2, r4, r2
   2e62e:	fba2 2303 	umull	r2, r3, r2, r3
      return q+(n-q*d >= d);
   2e632:	fb06 4413 	mls	r4, r6, r3, r4
   2e636:	42a6      	cmp	r6, r4
   2e638:	bf8c      	ite	hi
   2e63a:	461c      	movhi	r4, r3
   2e63c:	1c5c      	addls	r4, r3, #1
   2e63e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   i=0; do {
   2e640:	f04f 0c00 	mov.w	ip, #0
   2e644:	f1a3 0e04 	sub.w	lr, r3, #4
   collapse_mask = 0;
   2e648:	4660      	mov	r0, ip
   2e64a:	ea4f 0884 	mov.w	r8, r4, lsl #2
      unsigned tmp=0;
   2e64e:	2200      	movs	r2, #0
      j=0; do {
   2e650:	4613      	mov	r3, r2
   collapse_mask = 0;
   2e652:	4671      	mov	r1, lr
         tmp |= iy[i*N0+j];
   2e654:	f851 5f04 	ldr.w	r5, [r1, #4]!
      } while (++j<N0);
   2e658:	3301      	adds	r3, #1
   2e65a:	429c      	cmp	r4, r3
         tmp |= iy[i*N0+j];
   2e65c:	ea42 0205 	orr.w	r2, r2, r5
      } while (++j<N0);
   2e660:	dcf8      	bgt.n	2e654 <alg_quant+0xb0>
      collapse_mask |= (tmp!=0)<<i;
   2e662:	3200      	adds	r2, #0
   2e664:	bf18      	it	ne
   2e666:	2201      	movne	r2, #1
   2e668:	fa02 f20c 	lsl.w	r2, r2, ip
   } while (++i<B);
   2e66c:	f10c 0c01 	add.w	ip, ip, #1
   2e670:	4566      	cmp	r6, ip
      collapse_mask |= (tmp!=0)<<i;
   2e672:	ea40 0002 	orr.w	r0, r0, r2
   2e676:	44c6      	add	lr, r8
   } while (++i<B);
   2e678:	d1e9      	bne.n	2e64e <alg_quant+0xaa>
   }

   collapse_mask = extract_collapse_mask(iy, N, B);
   RESTORE_STACK;
   return collapse_mask;
}
   2e67a:	373c      	adds	r7, #60	; 0x3c
   2e67c:	46bd      	mov	sp, r7
   2e67e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      return n/d;
   2e682:	fbb4 f4f6 	udiv	r4, r4, r6
   2e686:	e7da      	b.n	2e63e <alg_quant+0x9a>
   2e688:	fab5 f185 	clz	r1, r5
   k = celt_ilog2(Ryy)>>1;
   2e68c:	f1c1 011f 	rsb	r1, r1, #31
   2e690:	ea4f 0861 	mov.w	r8, r1, asr #1
   t = VSHR32(Ryy, 2*(k-7));
   2e694:	f1b8 0f07 	cmp.w	r8, #7
   2e698:	f1a8 0307 	sub.w	r3, r8, #7
   2e69c:	f300 80da 	bgt.w	2e854 <alg_quant+0x2b0>
   2e6a0:	ebc3 73c3 	rsb	r3, r3, r3, lsl #31
   2e6a4:	0058      	lsls	r0, r3, #1
   2e6a6:	fa05 f000 	lsl.w	r0, r5, r0
   g = MULT16_16_P15(celt_rsqrt_norm(t),gain);
   2e6aa:	f7fc feb3 	bl	2b414 <celt_rsqrt_norm>
      X[i] = EXTRACT16(PSHR32(MULT16_16(g, iy[i]), k+1));
   2e6ae:	f108 0101 	add.w	r1, r8, #1
   2e6b2:	2301      	movs	r3, #1
   2e6b4:	408b      	lsls	r3, r1
   2e6b6:	ea4f 0e63 	mov.w	lr, r3, asr #1
   2e6ba:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   g = MULT16_16_P15(celt_rsqrt_norm(t),gain);
   2e6bc:	69ba      	ldr	r2, [r7, #24]
   2e6be:	f44f 4c80 	mov.w	ip, #16384	; 0x4000
   2e6c2:	1f1d      	subs	r5, r3, #4
   2e6c4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   2e6c6:	fb00 cc02 	mla	ip, r0, r2, ip
   2e6ca:	f34c 3ccf 	sbfx	ip, ip, #15, #16
   2e6ce:	1e98      	subs	r0, r3, #2
   i=0;
   2e6d0:	2200      	movs	r2, #0
      X[i] = EXTRACT16(PSHR32(MULT16_16(g, iy[i]), k+1));
   2e6d2:	f855 3f04 	ldr.w	r3, [r5, #4]!
   while (++i < N);
   2e6d6:	3201      	adds	r2, #1
      X[i] = EXTRACT16(PSHR32(MULT16_16(g, iy[i]), k+1));
   2e6d8:	fb13 e30c 	smlabb	r3, r3, ip, lr
   2e6dc:	410b      	asrs	r3, r1
   while (++i < N);
   2e6de:	4294      	cmp	r4, r2
      X[i] = EXTRACT16(PSHR32(MULT16_16(g, iy[i]), k+1));
   2e6e0:	f820 3f02 	strh.w	r3, [r0, #2]!
   while (++i < N);
   2e6e4:	dcf5      	bgt.n	2e6d2 <alg_quant+0x12e>
   if (2*K>=len || spread==SPREAD_NONE)
   2e6e6:	6a3b      	ldr	r3, [r7, #32]
   2e6e8:	429c      	cmp	r4, r3
   2e6ea:	dd8c      	ble.n	2e606 <alg_quant+0x62>
   2e6ec:	69fb      	ldr	r3, [r7, #28]
   2e6ee:	2b00      	cmp	r3, #0
   2e6f0:	d089      	beq.n	2e606 <alg_quant+0x62>
   factor = SPREAD_FACTOR[spread-1];
   2e6f2:	4a7c      	ldr	r2, [pc, #496]	; (2e8e4 <alg_quant+0x340>)
   2e6f4:	3b01      	subs	r3, #1
   gain = celt_div((opus_val32)MULT16_16(Q15_ONE,len),(opus_val32)(len+factor*K));
   2e6f6:	fa0f f884 	sxth.w	r8, r4
   2e6fa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   2e6fe:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   2e700:	fb03 4902 	mla	r9, r3, r2, r4
   2e704:	4648      	mov	r0, r9
   2e706:	f7fc ff71 	bl	2b5ec <celt_rcp>
   2e70a:	4682      	mov	sl, r0
   2e70c:	4648      	mov	r0, r9
   2e70e:	f7fc ff6d 	bl	2b5ec <celt_rcp>
   2e712:	ebc8 38c8 	rsb	r8, r8, r8, lsl #15
   2e716:	b285      	uxth	r5, r0
   2e718:	4648      	mov	r0, r9
   2e71a:	f7fc ff67 	bl	2b5ec <celt_rcp>
   2e71e:	ea4f 4828 	mov.w	r8, r8, asr #16
   2e722:	fb08 f505 	mul.w	r5, r8, r5
   2e726:	ea4f 4a2a 	mov.w	sl, sl, asr #16
   2e72a:	fb1a f808 	smulbb	r8, sl, r8
   2e72e:	13ed      	asrs	r5, r5, #15
   2e730:	ebc4 33c4 	rsb	r3, r4, r4, lsl #15
   2e734:	eb05 0548 	add.w	r5, r5, r8, lsl #1
   2e738:	1400      	asrs	r0, r0, #16
   2e73a:	b29b      	uxth	r3, r3
   2e73c:	fb03 f300 	mul.w	r3, r3, r0
   2e740:	b2ad      	uxth	r5, r5
   2e742:	eb05 35e3 	add.w	r5, r5, r3, asr #15
   theta = HALF16(MULT16_16_Q15(gain,gain));
   2e746:	fb15 f505 	smulbb	r5, r5, r5
   2e74a:	142d      	asrs	r5, r5, #16
   c = celt_cos_norm(EXTEND32(theta));
   2e74c:	4628      	mov	r0, r5
   2e74e:	f7fc fed3 	bl	2b4f8 <celt_cos_norm>
   2e752:	4680      	mov	r8, r0
   s = celt_cos_norm(EXTEND32(SUB16(Q15ONE,theta))); /*  sin(theta) */
   2e754:	f5c5 40ff 	rsb	r0, r5, #32640	; 0x7f80
   2e758:	307f      	adds	r0, #127	; 0x7f
   2e75a:	f7fc fecd 	bl	2b4f8 <celt_cos_norm>
   if (len>=8*stride)
   2e75e:	ebb4 0fc6 	cmp.w	r4, r6, lsl #3
   s = celt_cos_norm(EXTEND32(SUB16(Q15ONE,theta))); /*  sin(theta) */
   2e762:	4683      	mov	fp, r0
   if (len>=8*stride)
   2e764:	f280 815e 	bge.w	2ea24 <alg_quant+0x480>
   int stride2=0;
   2e768:	2300      	movs	r3, #0
   2e76a:	62fb      	str	r3, [r7, #44]	; 0x2c
   if (d>256)
   2e76c:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
   2e770:	f240 816d 	bls.w	2ea4e <alg_quant+0x4aa>
      return n/d;
   2e774:	fbb4 f3f6 	udiv	r3, r4, r6
   2e778:	61fb      	str	r3, [r7, #28]
   for (i=0;i<stride;i++)
   2e77a:	2e00      	cmp	r6, #0
   2e77c:	dd65      	ble.n	2e84a <alg_quant+0x2a6>
   2e77e:	69fa      	ldr	r2, [r7, #28]
   2e780:	6b39      	ldr	r1, [r7, #48]	; 0x30
   2e782:	663e      	str	r6, [r7, #96]	; 0x60
   2e784:	ebc2 73c2 	rsb	r3, r2, r2, lsl #31
   2e788:	005b      	lsls	r3, r3, #1
   2e78a:	623b      	str	r3, [r7, #32]
   2e78c:	3302      	adds	r3, #2
   2e78e:	eb01 0942 	add.w	r9, r1, r2, lsl #1
   2e792:	627b      	str	r3, [r7, #36]	; 0x24
   for (i=0;i<len-stride;i++)
   2e794:	4613      	mov	r3, r2
   2e796:	3a01      	subs	r2, #1
   2e798:	633a      	str	r2, [r7, #48]	; 0x30
   for (i=len-2*stride-1;i>=0;i--)
   2e79a:	1eda      	subs	r2, r3, #3
   2e79c:	005b      	lsls	r3, r3, #1
   2e79e:	f1cb 0a00 	rsb	sl, fp, #0
   2e7a2:	62bb      	str	r3, [r7, #40]	; 0x28
   for (i=0;i<stride;i++)
   2e7a4:	2300      	movs	r3, #0
   2e7a6:	4645      	mov	r5, r8
   2e7a8:	f1a9 0902 	sub.w	r9, r9, #2
   2e7ac:	fa0f fa8a 	sxth.w	sl, sl
   2e7b0:	4698      	mov	r8, r3
   2e7b2:	61bc      	str	r4, [r7, #24]
   2e7b4:	4616      	mov	r6, r2
   2e7b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   2e7b8:	eb03 0409 	add.w	r4, r3, r9
         if (stride2)
   2e7bc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   2e7be:	2b00      	cmp	r3, #0
   2e7c0:	f040 813d 	bne.w	2ea3e <alg_quant+0x49a>
   for (i=0;i<len-stride;i++)
   2e7c4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   2e7c6:	2b00      	cmp	r3, #0
   2e7c8:	dd19      	ble.n	2e7fe <alg_quant+0x25a>
   2e7ca:	6a3b      	ldr	r3, [r7, #32]
   2e7cc:	444b      	add	r3, r9
   2e7ce:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
      x2 = Xptr[stride];
   2e7d2:	f934 1f02 	ldrsh.w	r1, [r4, #2]!
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2e7d6:	fb03 f00b 	mul.w	r0, r3, fp
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2e7da:	fb01 f20a 	mul.w	r2, r1, sl
   2e7de:	fb03 2205 	mla	r2, r3, r5, r2
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2e7e2:	fb01 0305 	mla	r3, r1, r5, r0
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2e7e6:	f502 4280 	add.w	r2, r2, #16384	; 0x4000
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2e7ea:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2e7ee:	13d2      	asrs	r2, r2, #15
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2e7f0:	f343 33cf 	sbfx	r3, r3, #15, #16
   for (i=0;i<len-stride;i++)
   2e7f4:	454c      	cmp	r4, r9
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2e7f6:	f824 2c02 	strh.w	r2, [r4, #-2]
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2e7fa:	8023      	strh	r3, [r4, #0]
   for (i=0;i<len-stride;i++)
   2e7fc:	d1e9      	bne.n	2e7d2 <alg_quant+0x22e>
   for (i=len-2*stride-1;i>=0;i--)
   2e7fe:	2e00      	cmp	r6, #0
   2e800:	db19      	blt.n	2e836 <alg_quant+0x292>
   2e802:	4649      	mov	r1, r9
   2e804:	4630      	mov	r0, r6
   2e806:	f931 3d02 	ldrsh.w	r3, [r1, #-2]!
      x1 = Xptr[0];
   2e80a:	f931 4d02 	ldrsh.w	r4, [r1, #-2]!
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2e80e:	fb04 f20b 	mul.w	r2, r4, fp
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2e812:	fb03 fc0a 	mul.w	ip, r3, sl
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2e816:	fb03 2305 	mla	r3, r3, r5, r2
   2e81a:	f503 4280 	add.w	r2, r3, #16384	; 0x4000
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2e81e:	fb04 c405 	mla	r4, r4, r5, ip
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2e822:	13d2      	asrs	r2, r2, #15
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2e824:	f504 4380 	add.w	r3, r4, #16384	; 0x4000
   for (i=len-2*stride-1;i>=0;i--)
   2e828:	3801      	subs	r0, #1
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2e82a:	f343 33cf 	sbfx	r3, r3, #15, #16
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2e82e:	804a      	strh	r2, [r1, #2]
   for (i=len-2*stride-1;i>=0;i--)
   2e830:	1c42      	adds	r2, r0, #1
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2e832:	800b      	strh	r3, [r1, #0]
   for (i=len-2*stride-1;i>=0;i--)
   2e834:	d1e9      	bne.n	2e80a <alg_quant+0x266>
   2e836:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2e838:	4499      	add	r9, r3
   for (i=0;i<stride;i++)
   2e83a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   2e83c:	f108 0801 	add.w	r8, r8, #1
   2e840:	4543      	cmp	r3, r8
   2e842:	d1b8      	bne.n	2e7b6 <alg_quant+0x212>
   2e844:	69bc      	ldr	r4, [r7, #24]
   2e846:	461e      	mov	r6, r3
   2e848:	e6dd      	b.n	2e606 <alg_quant+0x62>
      return 1;
   2e84a:	2001      	movs	r0, #1
}
   2e84c:	373c      	adds	r7, #60	; 0x3c
   2e84e:	46bd      	mov	sp, r7
   2e850:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   t = VSHR32(Ryy, 2*(k-7));
   2e854:	005b      	lsls	r3, r3, #1
   2e856:	fa45 f003 	asr.w	r0, r5, r3
   2e85a:	e726      	b.n	2e6aa <alg_quant+0x106>
   2e85c:	461a      	mov	r2, r3
   factor = SPREAD_FACTOR[spread-1];
   2e85e:	3a01      	subs	r2, #1
   2e860:	4b20      	ldr	r3, [pc, #128]	; (2e8e4 <alg_quant+0x340>)
   gain = celt_div((opus_val32)MULT16_16(Q15_ONE,len),(opus_val32)(len+factor*K));
   2e862:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   2e866:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   2e868:	fb03 4902 	mla	r9, r3, r2, r4
   2e86c:	4648      	mov	r0, r9
   2e86e:	f7fc febd 	bl	2b5ec <celt_rcp>
   2e872:	4682      	mov	sl, r0
   2e874:	4648      	mov	r0, r9
   2e876:	f7fc feb9 	bl	2b5ec <celt_rcp>
   2e87a:	b225      	sxth	r5, r4
   2e87c:	fa1f f880 	uxth.w	r8, r0
   2e880:	ebc5 35c5 	rsb	r5, r5, r5, lsl #15
   2e884:	4648      	mov	r0, r9
   2e886:	f7fc feb1 	bl	2b5ec <celt_rcp>
   2e88a:	142d      	asrs	r5, r5, #16
   2e88c:	fb05 f808 	mul.w	r8, r5, r8
   2e890:	ea4f 4a2a 	mov.w	sl, sl, asr #16
   2e894:	fb1a f505 	smulbb	r5, sl, r5
   2e898:	ea4f 38e8 	mov.w	r8, r8, asr #15
   2e89c:	ebc4 33c4 	rsb	r3, r4, r4, lsl #15
   2e8a0:	eb08 0845 	add.w	r8, r8, r5, lsl #1
   2e8a4:	1400      	asrs	r0, r0, #16
   2e8a6:	b29b      	uxth	r3, r3
   2e8a8:	fb03 f300 	mul.w	r3, r3, r0
   2e8ac:	fa1f f888 	uxth.w	r8, r8
   2e8b0:	eb08 38e3 	add.w	r8, r8, r3, asr #15
   theta = HALF16(MULT16_16_Q15(gain,gain));
   2e8b4:	fb18 f808 	smulbb	r8, r8, r8
   2e8b8:	ea4f 4828 	mov.w	r8, r8, asr #16
   c = celt_cos_norm(EXTEND32(theta));
   2e8bc:	4640      	mov	r0, r8
   2e8be:	f7fc fe1b 	bl	2b4f8 <celt_cos_norm>
   2e8c2:	4605      	mov	r5, r0
   s = celt_cos_norm(EXTEND32(SUB16(Q15ONE,theta))); /*  sin(theta) */
   2e8c4:	f5c8 40ff 	rsb	r0, r8, #32640	; 0x7f80
   2e8c8:	307f      	adds	r0, #127	; 0x7f
   2e8ca:	f7fc fe15 	bl	2b4f8 <celt_cos_norm>
   if (len>=8*stride)
   2e8ce:	ebb4 0fc6 	cmp.w	r4, r6, lsl #3
   s = celt_cos_norm(EXTEND32(SUB16(Q15ONE,theta))); /*  sin(theta) */
   2e8d2:	4681      	mov	r9, r0
   if (len>=8*stride)
   2e8d4:	f2c0 808b 	blt.w	2e9ee <alg_quant+0x44a>
      while ((stride2*stride2+stride2)*stride + (stride>>2) < len)
   2e8d8:	10b1      	asrs	r1, r6, #2
      stride2 = 1;
   2e8da:	2201      	movs	r2, #1
   2e8dc:	e005      	b.n	2e8ea <alg_quant+0x346>
   2e8de:	bf00      	nop
   2e8e0:	00038e98 	.word	0x00038e98
   2e8e4:	0003b5b4 	.word	0x0003b5b4
         stride2++;
   2e8e8:	4602      	mov	r2, r0
      while ((stride2*stride2+stride2)*stride + (stride>>2) < len)
   2e8ea:	1c50      	adds	r0, r2, #1
   2e8ec:	fb00 f302 	mul.w	r3, r0, r2
   2e8f0:	fb06 1303 	mla	r3, r6, r3, r1
   2e8f4:	429c      	cmp	r4, r3
   2e8f6:	dcf7      	bgt.n	2e8e8 <alg_quant+0x344>
   2e8f8:	627a      	str	r2, [r7, #36]	; 0x24
   if (d>256)
   2e8fa:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
   2e8fe:	d979      	bls.n	2e9f4 <alg_quant+0x450>
      return n/d;
   2e900:	fbb4 f3f6 	udiv	r3, r4, r6
   2e904:	62bb      	str	r3, [r7, #40]	; 0x28
   for (i=0;i<stride;i++)
   2e906:	2e00      	cmp	r6, #0
   2e908:	f77f ae67 	ble.w	2e5da <alg_quant+0x36>
   2e90c:	6aba      	ldr	r2, [r7, #40]	; 0x28
   2e90e:	607c      	str	r4, [r7, #4]
   2e910:	ebc2 73c2 	rsb	r3, r2, r2, lsl #31
   2e914:	0059      	lsls	r1, r3, #1
   2e916:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   2e918:	60f9      	str	r1, [r7, #12]
   2e91a:	4618      	mov	r0, r3
            exp_rotation1(X+i*len, len, stride2, s, -c);
   2e91c:	426b      	negs	r3, r5
   2e91e:	b21b      	sxth	r3, r3
   2e920:	eb00 0a42 	add.w	sl, r0, r2, lsl #1
   2e924:	60bb      	str	r3, [r7, #8]
   for (i=len-2*stride-1;i>=0;i--)
   2e926:	1ed3      	subs	r3, r2, #3
   2e928:	0052      	lsls	r2, r2, #1
   2e92a:	f1c9 0800 	rsb	r8, r9, #0
   2e92e:	3102      	adds	r1, #2
   2e930:	617a      	str	r2, [r7, #20]
   for (i=0;i<stride;i++)
   2e932:	2200      	movs	r2, #0
   2e934:	663e      	str	r6, [r7, #96]	; 0x60
   2e936:	6139      	str	r1, [r7, #16]
   2e938:	fa0f f888 	sxth.w	r8, r8
   2e93c:	f1aa 0a02 	sub.w	sl, sl, #2
   2e940:	4614      	mov	r4, r2
   2e942:	461e      	mov	r6, r3
   2e944:	693b      	ldr	r3, [r7, #16]
   2e946:	eb03 000a 	add.w	r0, r3, sl
   for (i=0;i<len-stride;i++)
   2e94a:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2e94c:	2b01      	cmp	r3, #1
   2e94e:	dd1b      	ble.n	2e988 <alg_quant+0x3e4>
   2e950:	68fb      	ldr	r3, [r7, #12]
   2e952:	4453      	add	r3, sl
   Xptr = X;
   2e954:	4684      	mov	ip, r0
   2e956:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
      x2 = Xptr[stride];
   2e95a:	f93c 1f02 	ldrsh.w	r1, [ip, #2]!
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2e95e:	fb03 fe08 	mul.w	lr, r3, r8
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2e962:	fb01 f209 	mul.w	r2, r1, r9
   2e966:	fb03 2205 	mla	r2, r3, r5, r2
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2e96a:	fb01 e305 	mla	r3, r1, r5, lr
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2e96e:	f502 4280 	add.w	r2, r2, #16384	; 0x4000
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2e972:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2e976:	13d2      	asrs	r2, r2, #15
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2e978:	f343 33cf 	sbfx	r3, r3, #15, #16
   for (i=0;i<len-stride;i++)
   2e97c:	45d4      	cmp	ip, sl
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2e97e:	f82c 2c02 	strh.w	r2, [ip, #-2]
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2e982:	f8ac 3000 	strh.w	r3, [ip]
   for (i=0;i<len-stride;i++)
   2e986:	d1e8      	bne.n	2e95a <alg_quant+0x3b6>
   for (i=len-2*stride-1;i>=0;i--)
   2e988:	2e00      	cmp	r6, #0
   2e98a:	db1d      	blt.n	2e9c8 <alg_quant+0x424>
   2e98c:	46d6      	mov	lr, sl
   2e98e:	46b3      	mov	fp, r6
   2e990:	f93e 3d02 	ldrsh.w	r3, [lr, #-2]!
      x1 = Xptr[0];
   2e994:	f93e 1d02 	ldrsh.w	r1, [lr, #-2]!
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2e998:	fb03 fc09 	mul.w	ip, r3, r9
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2e99c:	fb01 f208 	mul.w	r2, r1, r8
   2e9a0:	fb03 2205 	mla	r2, r3, r5, r2
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2e9a4:	fb01 c305 	mla	r3, r1, r5, ip
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2e9a8:	f502 4280 	add.w	r2, r2, #16384	; 0x4000
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2e9ac:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
   for (i=len-2*stride-1;i>=0;i--)
   2e9b0:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2e9b4:	13d2      	asrs	r2, r2, #15
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2e9b6:	f343 33cf 	sbfx	r3, r3, #15, #16
   for (i=len-2*stride-1;i>=0;i--)
   2e9ba:	f1bb 3fff 	cmp.w	fp, #4294967295	; 0xffffffff
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2e9be:	f8ae 2002 	strh.w	r2, [lr, #2]
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2e9c2:	f8ae 3000 	strh.w	r3, [lr]
   for (i=len-2*stride-1;i>=0;i--)
   2e9c6:	d1e5      	bne.n	2e994 <alg_quant+0x3f0>
         if (stride2)
   2e9c8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   2e9ca:	b943      	cbnz	r3, 2e9de <alg_quant+0x43a>
   2e9cc:	697b      	ldr	r3, [r7, #20]
   2e9ce:	449a      	add	sl, r3
   for (i=0;i<stride;i++)
   2e9d0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   2e9d2:	3401      	adds	r4, #1
   2e9d4:	42a3      	cmp	r3, r4
   2e9d6:	d1b5      	bne.n	2e944 <alg_quant+0x3a0>
   2e9d8:	687c      	ldr	r4, [r7, #4]
   2e9da:	461e      	mov	r6, r3
   2e9dc:	e5fd      	b.n	2e5da <alg_quant+0x36>
   2e9de:	461a      	mov	r2, r3
            exp_rotation1(X+i*len, len, stride2, s, -c);
   2e9e0:	68bb      	ldr	r3, [r7, #8]
   2e9e2:	9300      	str	r3, [sp, #0]
   2e9e4:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   2e9e6:	464b      	mov	r3, r9
   2e9e8:	f7ff fc6e 	bl	2e2c8 <exp_rotation1>
   2e9ec:	e7ee      	b.n	2e9cc <alg_quant+0x428>
   int stride2=0;
   2e9ee:	2300      	movs	r3, #0
   2e9f0:	627b      	str	r3, [r7, #36]	; 0x24
   2e9f2:	e782      	b.n	2e8fa <alg_quant+0x356>
      t = EC_ILOG(d&-d);
   2e9f4:	4273      	negs	r3, r6
   2e9f6:	4033      	ands	r3, r6
   2e9f8:	fab3 f383 	clz	r3, r3
   2e9fc:	f1c3 0320 	rsb	r3, r3, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   2ea00:	fa26 f003 	lsr.w	r0, r6, r3
   2ea04:	491e      	ldr	r1, [pc, #120]	; (2ea80 <alg_quant+0x4dc>)
   2ea06:	1e5a      	subs	r2, r3, #1
   2ea08:	f851 3020 	ldr.w	r3, [r1, r0, lsl #2]
   2ea0c:	fa24 f202 	lsr.w	r2, r4, r2
   2ea10:	fba2 0103 	umull	r0, r1, r2, r3
      return q+(n-q*d >= d);
   2ea14:	fb06 4211 	mls	r2, r6, r1, r4
   2ea18:	460b      	mov	r3, r1
   2ea1a:	4296      	cmp	r6, r2
   2ea1c:	bf98      	it	ls
   2ea1e:	3301      	addls	r3, #1
   2ea20:	62bb      	str	r3, [r7, #40]	; 0x28
   2ea22:	e770      	b.n	2e906 <alg_quant+0x362>
      while ((stride2*stride2+stride2)*stride + (stride>>2) < len)
   2ea24:	10b1      	asrs	r1, r6, #2
      stride2 = 1;
   2ea26:	2201      	movs	r2, #1
   2ea28:	e000      	b.n	2ea2c <alg_quant+0x488>
         stride2++;
   2ea2a:	4602      	mov	r2, r0
      while ((stride2*stride2+stride2)*stride + (stride>>2) < len)
   2ea2c:	1c50      	adds	r0, r2, #1
   2ea2e:	fb00 f302 	mul.w	r3, r0, r2
   2ea32:	fb06 1303 	mla	r3, r6, r3, r1
   2ea36:	429c      	cmp	r4, r3
   2ea38:	dcf7      	bgt.n	2ea2a <alg_quant+0x486>
   2ea3a:	62fa      	str	r2, [r7, #44]	; 0x2c
   2ea3c:	e696      	b.n	2e76c <alg_quant+0x1c8>
   2ea3e:	461a      	mov	r2, r3
            exp_rotation1(X+i*len, len, stride2, s, c);
   2ea40:	9500      	str	r5, [sp, #0]
   2ea42:	465b      	mov	r3, fp
   2ea44:	69f9      	ldr	r1, [r7, #28]
   2ea46:	4620      	mov	r0, r4
   2ea48:	f7ff fc3e 	bl	2e2c8 <exp_rotation1>
   2ea4c:	e6ba      	b.n	2e7c4 <alg_quant+0x220>
      t = EC_ILOG(d&-d);
   2ea4e:	4273      	negs	r3, r6
   2ea50:	4033      	ands	r3, r6
   2ea52:	fab3 f383 	clz	r3, r3
   2ea56:	f1c3 0320 	rsb	r3, r3, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   2ea5a:	fa26 f003 	lsr.w	r0, r6, r3
   2ea5e:	4908      	ldr	r1, [pc, #32]	; (2ea80 <alg_quant+0x4dc>)
   2ea60:	1e5a      	subs	r2, r3, #1
   2ea62:	f851 3020 	ldr.w	r3, [r1, r0, lsl #2]
   2ea66:	fa24 f202 	lsr.w	r2, r4, r2
   2ea6a:	fba2 0103 	umull	r0, r1, r2, r3
      return q+(n-q*d >= d);
   2ea6e:	fb06 4211 	mls	r2, r6, r1, r4
   2ea72:	460b      	mov	r3, r1
   2ea74:	4296      	cmp	r6, r2
   2ea76:	bf98      	it	ls
   2ea78:	3301      	addls	r3, #1
   2ea7a:	61fb      	str	r3, [r7, #28]
   2ea7c:	e67d      	b.n	2e77a <alg_quant+0x1d6>
   2ea7e:	bf00      	nop
   2ea80:	00038e98 	.word	0x00038e98

0002ea84 <alg_unquant>:

/** Decode pulse vector and combine the result with the pitch vector to produce
    the final normalised signal in the current band. */
unsigned alg_unquant(celt_norm *X, int N, int K, int spread, int B,
      ec_dec *dec, opus_val16 gain)
{
   2ea84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   VARDECL(int, iy);
   SAVE_STACK;

   celt_assert2(K>0, "alg_unquant() needs at least one pulse");
   celt_assert2(N>1, "alg_unquant() needs at least two dimensions");
   ALLOC(iy, N, int);
   2ea88:	008d      	lsls	r5, r1, #2
   2ea8a:	350a      	adds	r5, #10
{
   2ea8c:	b08b      	sub	sp, #44	; 0x2c
   ALLOC(iy, N, int);
   2ea8e:	f025 0507 	bic.w	r5, r5, #7
{
   2ea92:	af02      	add	r7, sp, #8
   ALLOC(iy, N, int);
   2ea94:	ebad 0d05 	sub.w	sp, sp, r5
   2ea98:	f10d 0808 	add.w	r8, sp, #8
{
   2ea9c:	4605      	mov	r5, r0
   2ea9e:	4699      	mov	r9, r3
   Ryy = decode_pulses(iy, N, K, dec);
   2eaa0:	4640      	mov	r0, r8
   2eaa2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
{
   2eaa4:	f9b7 a050 	ldrsh.w	sl, [r7, #80]	; 0x50
   2eaa8:	460c      	mov	r4, r1
   2eaaa:	4616      	mov	r6, r2
   Ryy = decode_pulses(iy, N, K, dec);
   2eaac:	f7fa fc80 	bl	293b0 <decode_pulses>
   2eab0:	fab0 f180 	clz	r1, r0
   k = celt_ilog2(Ryy)>>1;
   2eab4:	f1c1 011f 	rsb	r1, r1, #31
   2eab8:	ea4f 0b61 	mov.w	fp, r1, asr #1
   t = VSHR32(Ryy, 2*(k-7));
   2eabc:	f1bb 0f07 	cmp.w	fp, #7
   2eac0:	dd63      	ble.n	2eb8a <alg_unquant+0x106>
   2eac2:	f1ab 0307 	sub.w	r3, fp, #7
   2eac6:	005b      	lsls	r3, r3, #1
   2eac8:	4118      	asrs	r0, r3
   g = MULT16_16_P15(celt_rsqrt_norm(t),gain);
   2eaca:	f7fc fca3 	bl	2b414 <celt_rsqrt_norm>
      X[i] = EXTRACT16(PSHR32(MULT16_16(g, iy[i]), k+1));
   2eace:	f10b 0101 	add.w	r1, fp, #1
   g = MULT16_16_P15(celt_rsqrt_norm(t),gain);
   2ead2:	f44f 4380 	mov.w	r3, #16384	; 0x4000
      X[i] = EXTRACT16(PSHR32(MULT16_16(g, iy[i]), k+1));
   2ead6:	f04f 0e01 	mov.w	lr, #1
   g = MULT16_16_P15(celt_rsqrt_norm(t),gain);
   2eada:	fb00 3a0a 	mla	sl, r0, sl, r3
   2eade:	f1a8 0804 	sub.w	r8, r8, #4
      X[i] = EXTRACT16(PSHR32(MULT16_16(g, iy[i]), k+1));
   2eae2:	fa0e fe01 	lsl.w	lr, lr, r1
   g = MULT16_16_P15(celt_rsqrt_norm(t),gain);
   2eae6:	f34a 3acf 	sbfx	sl, sl, #15, #16
      X[i] = EXTRACT16(PSHR32(MULT16_16(g, iy[i]), k+1));
   2eaea:	ea4f 0e6e 	mov.w	lr, lr, asr #1
   2eaee:	46c4      	mov	ip, r8
   2eaf0:	1ea8      	subs	r0, r5, #2
   i=0;
   2eaf2:	2200      	movs	r2, #0
      X[i] = EXTRACT16(PSHR32(MULT16_16(g, iy[i]), k+1));
   2eaf4:	f85c 3f04 	ldr.w	r3, [ip, #4]!
   while (++i < N);
   2eaf8:	3201      	adds	r2, #1
      X[i] = EXTRACT16(PSHR32(MULT16_16(g, iy[i]), k+1));
   2eafa:	fb13 e30a 	smlabb	r3, r3, sl, lr
   2eafe:	410b      	asrs	r3, r1
   while (++i < N);
   2eb00:	4294      	cmp	r4, r2
      X[i] = EXTRACT16(PSHR32(MULT16_16(g, iy[i]), k+1));
   2eb02:	f820 3f02 	strh.w	r3, [r0, #2]!
   while (++i < N);
   2eb06:	dcf5      	bgt.n	2eaf4 <alg_unquant+0x70>
   if (2*K>=len || spread==SPREAD_NONE)
   2eb08:	ebb4 0f46 	cmp.w	r4, r6, lsl #1
   2eb0c:	dd02      	ble.n	2eb14 <alg_unquant+0x90>
   2eb0e:	f1b9 0f00 	cmp.w	r9, #0
   2eb12:	d148      	bne.n	2eba6 <alg_unquant+0x122>
   if (B<=1)
   2eb14:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   2eb16:	2b01      	cmp	r3, #1
   2eb18:	dd40      	ble.n	2eb9c <alg_unquant+0x118>
   if (d>256)
   2eb1a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
   2eb1e:	dc39      	bgt.n	2eb94 <alg_unquant+0x110>
   2eb20:	461a      	mov	r2, r3
      t = EC_ILOG(d&-d);
   2eb22:	425b      	negs	r3, r3
   2eb24:	4013      	ands	r3, r2
   2eb26:	fab3 f383 	clz	r3, r3
   2eb2a:	f1c3 0320 	rsb	r3, r3, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   2eb2e:	fa22 f003 	lsr.w	r0, r2, r3
   2eb32:	498c      	ldr	r1, [pc, #560]	; (2ed64 <alg_unquant+0x2e0>)
   2eb34:	1e5a      	subs	r2, r3, #1
   2eb36:	f851 3020 	ldr.w	r3, [r1, r0, lsl #2]
      return q+(n-q*d >= d);
   2eb3a:	6cb9      	ldr	r1, [r7, #72]	; 0x48
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   2eb3c:	fa24 f202 	lsr.w	r2, r4, r2
   2eb40:	fba2 2303 	umull	r2, r3, r2, r3
      return q+(n-q*d >= d);
   2eb44:	fb01 4413 	mls	r4, r1, r3, r4
   2eb48:	42a1      	cmp	r1, r4
   2eb4a:	bf8c      	ite	hi
   2eb4c:	461c      	movhi	r4, r3
   2eb4e:	1c5c      	addls	r4, r3, #1
   2eb50:	468e      	mov	lr, r1
   i=0; do {
   2eb52:	2600      	movs	r6, #0
   collapse_mask = 0;
   2eb54:	4630      	mov	r0, r6
   2eb56:	ea4f 0c84 	mov.w	ip, r4, lsl #2
      unsigned tmp=0;
   2eb5a:	2200      	movs	r2, #0
      j=0; do {
   2eb5c:	4613      	mov	r3, r2
   collapse_mask = 0;
   2eb5e:	4641      	mov	r1, r8
         tmp |= iy[i*N0+j];
   2eb60:	f851 5f04 	ldr.w	r5, [r1, #4]!
      } while (++j<N0);
   2eb64:	3301      	adds	r3, #1
   2eb66:	429c      	cmp	r4, r3
         tmp |= iy[i*N0+j];
   2eb68:	ea42 0205 	orr.w	r2, r2, r5
      } while (++j<N0);
   2eb6c:	dcf8      	bgt.n	2eb60 <alg_unquant+0xdc>
      collapse_mask |= (tmp!=0)<<i;
   2eb6e:	3200      	adds	r2, #0
   2eb70:	bf18      	it	ne
   2eb72:	2201      	movne	r2, #1
   2eb74:	40b2      	lsls	r2, r6
   } while (++i<B);
   2eb76:	3601      	adds	r6, #1
   2eb78:	45b6      	cmp	lr, r6
      collapse_mask |= (tmp!=0)<<i;
   2eb7a:	ea40 0002 	orr.w	r0, r0, r2
   2eb7e:	44e0      	add	r8, ip
   } while (++i<B);
   2eb80:	d1eb      	bne.n	2eb5a <alg_unquant+0xd6>
   normalise_residual(iy, X, N, Ryy, gain);
   exp_rotation(X, N, -1, B, K, spread);
   collapse_mask = extract_collapse_mask(iy, N, B);
   RESTORE_STACK;
   return collapse_mask;
}
   2eb82:	3724      	adds	r7, #36	; 0x24
   2eb84:	46bd      	mov	sp, r7
   2eb86:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   t = VSHR32(Ryy, 2*(k-7));
   2eb8a:	f1cb 0307 	rsb	r3, fp, #7
   2eb8e:	005b      	lsls	r3, r3, #1
   2eb90:	4098      	lsls	r0, r3
   2eb92:	e79a      	b.n	2eaca <alg_unquant+0x46>
      return n/d;
   2eb94:	fbb4 f4f3 	udiv	r4, r4, r3
   2eb98:	469e      	mov	lr, r3
   2eb9a:	e7da      	b.n	2eb52 <alg_unquant+0xce>
      return 1;
   2eb9c:	2001      	movs	r0, #1
}
   2eb9e:	3724      	adds	r7, #36	; 0x24
   2eba0:	46bd      	mov	sp, r7
   2eba2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   factor = SPREAD_FACTOR[spread-1];
   2eba6:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
   2ebaa:	4b6f      	ldr	r3, [pc, #444]	; (2ed68 <alg_unquant+0x2e4>)
   gain = celt_div((opus_val32)MULT16_16(Q15_ONE,len),(opus_val32)(len+factor*K));
   2ebac:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
   2ebb0:	fb02 4a06 	mla	sl, r2, r6, r4
   2ebb4:	b223      	sxth	r3, r4
   2ebb6:	4650      	mov	r0, sl
   2ebb8:	ebc3 36c3 	rsb	r6, r3, r3, lsl #15
   2ebbc:	f7fc fd16 	bl	2b5ec <celt_rcp>
   2ebc0:	4683      	mov	fp, r0
   2ebc2:	4650      	mov	r0, sl
   2ebc4:	f7fc fd12 	bl	2b5ec <celt_rcp>
   2ebc8:	fa1f f980 	uxth.w	r9, r0
   2ebcc:	4650      	mov	r0, sl
   2ebce:	f7fc fd0d 	bl	2b5ec <celt_rcp>
   2ebd2:	1436      	asrs	r6, r6, #16
   2ebd4:	fb06 f909 	mul.w	r9, r6, r9
   2ebd8:	ea4f 4b2b 	mov.w	fp, fp, asr #16
   2ebdc:	fb1b f606 	smulbb	r6, fp, r6
   2ebe0:	ea4f 39e9 	mov.w	r9, r9, asr #15
   2ebe4:	ebc4 33c4 	rsb	r3, r4, r4, lsl #15
   2ebe8:	eb09 0946 	add.w	r9, r9, r6, lsl #1
   2ebec:	1400      	asrs	r0, r0, #16
   2ebee:	b29b      	uxth	r3, r3
   2ebf0:	fb03 f300 	mul.w	r3, r3, r0
   2ebf4:	fa1f f989 	uxth.w	r9, r9
   2ebf8:	eb09 39e3 	add.w	r9, r9, r3, asr #15
   theta = HALF16(MULT16_16_Q15(gain,gain));
   2ebfc:	fb19 f909 	smulbb	r9, r9, r9
   2ec00:	ea4f 4929 	mov.w	r9, r9, asr #16
   c = celt_cos_norm(EXTEND32(theta));
   2ec04:	4648      	mov	r0, r9
   2ec06:	f7fc fc77 	bl	2b4f8 <celt_cos_norm>
   2ec0a:	4606      	mov	r6, r0
   s = celt_cos_norm(EXTEND32(SUB16(Q15ONE,theta))); /*  sin(theta) */
   2ec0c:	f5c9 40ff 	rsb	r0, r9, #32640	; 0x7f80
   2ec10:	307f      	adds	r0, #127	; 0x7f
   2ec12:	f7fc fc71 	bl	2b4f8 <celt_cos_norm>
   if (len>=8*stride)
   2ec16:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   2ec18:	ebb4 0fc3 	cmp.w	r4, r3, lsl #3
   s = celt_cos_norm(EXTEND32(SUB16(Q15ONE,theta))); /*  sin(theta) */
   2ec1c:	4683      	mov	fp, r0
   if (len>=8*stride)
   2ec1e:	f2c0 8081 	blt.w	2ed24 <alg_unquant+0x2a0>
      while ((stride2*stride2+stride2)*stride + (stride>>2) < len)
   2ec22:	1099      	asrs	r1, r3, #2
      stride2 = 1;
   2ec24:	2201      	movs	r2, #1
   2ec26:	469c      	mov	ip, r3
   2ec28:	e000      	b.n	2ec2c <alg_unquant+0x1a8>
         stride2++;
   2ec2a:	4602      	mov	r2, r0
      while ((stride2*stride2+stride2)*stride + (stride>>2) < len)
   2ec2c:	1c50      	adds	r0, r2, #1
   2ec2e:	fb00 f302 	mul.w	r3, r0, r2
   2ec32:	fb0c 1303 	mla	r3, ip, r3, r1
   2ec36:	429c      	cmp	r4, r3
   2ec38:	dcf7      	bgt.n	2ec2a <alg_unquant+0x1a6>
   2ec3a:	61fa      	str	r2, [r7, #28]
   if (d>256)
   2ec3c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   2ec3e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
   2ec42:	d972      	bls.n	2ed2a <alg_unquant+0x2a6>
      return n/d;
   2ec44:	fbb4 f3f3 	udiv	r3, r4, r3
   2ec48:	60bb      	str	r3, [r7, #8]
   2ec4a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   for (i=0;i<stride;i++)
   2ec4c:	2b00      	cmp	r3, #0
   2ec4e:	dda5      	ble.n	2eb9c <alg_unquant+0x118>
   2ec50:	68ba      	ldr	r2, [r7, #8]
   2ec52:	f8c7 8004 	str.w	r8, [r7, #4]
   2ec56:	ebc2 73c2 	rsb	r3, r2, r2, lsl #31
   2ec5a:	005b      	lsls	r3, r3, #1
   2ec5c:	60fb      	str	r3, [r7, #12]
   2ec5e:	3302      	adds	r3, #2
   2ec60:	613b      	str	r3, [r7, #16]
   for (i=0;i<len-stride;i++)
   2ec62:	1e53      	subs	r3, r2, #1
   2ec64:	eb05 0542 	add.w	r5, r5, r2, lsl #1
   2ec68:	f1cb 0a00 	rsb	sl, fp, #0
   2ec6c:	61bb      	str	r3, [r7, #24]
   for (i=len-2*stride-1;i>=0;i--)
   2ec6e:	1ed3      	subs	r3, r2, #3
   2ec70:	0052      	lsls	r2, r2, #1
   2ec72:	f1a5 0902 	sub.w	r9, r5, #2
   2ec76:	fa0f fa8a 	sxth.w	sl, sl
   2ec7a:	617a      	str	r2, [r7, #20]
   for (i=0;i<stride;i++)
   2ec7c:	2500      	movs	r5, #0
   2ec7e:	4698      	mov	r8, r3
   2ec80:	603c      	str	r4, [r7, #0]
   2ec82:	693b      	ldr	r3, [r7, #16]
   2ec84:	eb03 0409 	add.w	r4, r3, r9
         if (stride2)
   2ec88:	69fb      	ldr	r3, [r7, #28]
   2ec8a:	2b00      	cmp	r3, #0
   2ec8c:	d142      	bne.n	2ed14 <alg_unquant+0x290>
   for (i=0;i<len-stride;i++)
   2ec8e:	69bb      	ldr	r3, [r7, #24]
   2ec90:	2b00      	cmp	r3, #0
   2ec92:	dd19      	ble.n	2ecc8 <alg_unquant+0x244>
   2ec94:	68fb      	ldr	r3, [r7, #12]
   2ec96:	444b      	add	r3, r9
   2ec98:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
      x2 = Xptr[stride];
   2ec9c:	f934 1f02 	ldrsh.w	r1, [r4, #2]!
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2eca0:	fb03 f00b 	mul.w	r0, r3, fp
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2eca4:	fb01 f20a 	mul.w	r2, r1, sl
   2eca8:	fb03 2206 	mla	r2, r3, r6, r2
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2ecac:	fb01 0306 	mla	r3, r1, r6, r0
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2ecb0:	f502 4280 	add.w	r2, r2, #16384	; 0x4000
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2ecb4:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2ecb8:	13d2      	asrs	r2, r2, #15
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2ecba:	f343 33cf 	sbfx	r3, r3, #15, #16
   for (i=0;i<len-stride;i++)
   2ecbe:	454c      	cmp	r4, r9
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2ecc0:	f824 2c02 	strh.w	r2, [r4, #-2]
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2ecc4:	8023      	strh	r3, [r4, #0]
   for (i=0;i<len-stride;i++)
   2ecc6:	d1e9      	bne.n	2ec9c <alg_unquant+0x218>
   for (i=len-2*stride-1;i>=0;i--)
   2ecc8:	f1b8 0f00 	cmp.w	r8, #0
   2eccc:	db19      	blt.n	2ed02 <alg_unquant+0x27e>
   2ecce:	4649      	mov	r1, r9
   2ecd0:	4640      	mov	r0, r8
   2ecd2:	f931 3d02 	ldrsh.w	r3, [r1, #-2]!
      x1 = Xptr[0];
   2ecd6:	f931 4d02 	ldrsh.w	r4, [r1, #-2]!
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2ecda:	fb04 f20b 	mul.w	r2, r4, fp
   2ecde:	fb03 2206 	mla	r2, r3, r6, r2
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2ece2:	fb03 fc0a 	mul.w	ip, r3, sl
   2ece6:	fb04 c306 	mla	r3, r4, r6, ip
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2ecea:	f502 4280 	add.w	r2, r2, #16384	; 0x4000
   2ecee:	13d2      	asrs	r2, r2, #15
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2ecf0:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
   for (i=len-2*stride-1;i>=0;i--)
   2ecf4:	3801      	subs	r0, #1
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2ecf6:	f343 33cf 	sbfx	r3, r3, #15, #16
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
   2ecfa:	804a      	strh	r2, [r1, #2]
   for (i=len-2*stride-1;i>=0;i--)
   2ecfc:	1c42      	adds	r2, r0, #1
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
   2ecfe:	800b      	strh	r3, [r1, #0]
   for (i=len-2*stride-1;i>=0;i--)
   2ed00:	d1e9      	bne.n	2ecd6 <alg_unquant+0x252>
   2ed02:	697b      	ldr	r3, [r7, #20]
   2ed04:	4499      	add	r9, r3
   for (i=0;i<stride;i++)
   2ed06:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   2ed08:	3501      	adds	r5, #1
   2ed0a:	42ab      	cmp	r3, r5
   2ed0c:	d1b9      	bne.n	2ec82 <alg_unquant+0x1fe>
   2ed0e:	e9d7 4800 	ldrd	r4, r8, [r7]
   2ed12:	e6ff      	b.n	2eb14 <alg_unquant+0x90>
   2ed14:	461a      	mov	r2, r3
            exp_rotation1(X+i*len, len, stride2, s, c);
   2ed16:	9600      	str	r6, [sp, #0]
   2ed18:	465b      	mov	r3, fp
   2ed1a:	68b9      	ldr	r1, [r7, #8]
   2ed1c:	4620      	mov	r0, r4
   2ed1e:	f7ff fad3 	bl	2e2c8 <exp_rotation1>
   2ed22:	e7b4      	b.n	2ec8e <alg_unquant+0x20a>
   int stride2=0;
   2ed24:	2300      	movs	r3, #0
   2ed26:	61fb      	str	r3, [r7, #28]
   2ed28:	e788      	b.n	2ec3c <alg_unquant+0x1b8>
   2ed2a:	461a      	mov	r2, r3
      t = EC_ILOG(d&-d);
   2ed2c:	425b      	negs	r3, r3
   2ed2e:	4013      	ands	r3, r2
   2ed30:	fab3 f383 	clz	r3, r3
   2ed34:	f1c3 0320 	rsb	r3, r3, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
   2ed38:	fa22 f003 	lsr.w	r0, r2, r3
   2ed3c:	4909      	ldr	r1, [pc, #36]	; (2ed64 <alg_unquant+0x2e0>)
   2ed3e:	1e5a      	subs	r2, r3, #1
   2ed40:	f851 3020 	ldr.w	r3, [r1, r0, lsl #2]
   2ed44:	fa24 f202 	lsr.w	r2, r4, r2
   2ed48:	fba2 0103 	umull	r0, r1, r2, r3
      return q+(n-q*d >= d);
   2ed4c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   2ed4e:	fb03 4211 	mls	r2, r3, r1, r4
   2ed52:	460b      	mov	r3, r1
   2ed54:	6cb9      	ldr	r1, [r7, #72]	; 0x48
   2ed56:	4291      	cmp	r1, r2
   2ed58:	bf98      	it	ls
   2ed5a:	3301      	addls	r3, #1
   2ed5c:	60bb      	str	r3, [r7, #8]
   2ed5e:	460b      	mov	r3, r1
   2ed60:	e774      	b.n	2ec4c <alg_unquant+0x1c8>
   2ed62:	bf00      	nop
   2ed64:	00038e98 	.word	0x00038e98
   2ed68:	0003b5b4 	.word	0x0003b5b4

0002ed6c <renormalise_vector>:
   for (i=0;i<N;i++)
   2ed6c:	2900      	cmp	r1, #0
   2ed6e:	dd3c      	ble.n	2edea <renormalise_vector+0x7e>

#ifndef OVERRIDE_renormalise_vector
void renormalise_vector(celt_norm *X, int N, opus_val16 gain, int arch)
{
   2ed70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2ed72:	004e      	lsls	r6, r1, #1
   2ed74:	1981      	adds	r1, r0, r6
   2ed76:	4604      	mov	r4, r0
   2ed78:	1e83      	subs	r3, r0, #2
   2ed7a:	4617      	mov	r7, r2
   2ed7c:	3902      	subs	r1, #2
   opus_val32 xy=0;
   2ed7e:	2000      	movs	r0, #0
      xy = MAC16_16(xy, x[i], y[i]);
   2ed80:	f933 5f02 	ldrsh.w	r5, [r3, #2]!
   for (i=0;i<N;i++)
   2ed84:	4299      	cmp	r1, r3
      xy = MAC16_16(xy, x[i], y[i]);
   2ed86:	fb05 0005 	mla	r0, r5, r5, r0
   for (i=0;i<N;i++)
   2ed8a:	d1f9      	bne.n	2ed80 <renormalise_vector+0x14>
#endif
   opus_val32 E;
   opus_val16 g;
   opus_val32 t;
   celt_norm *xptr;
   E = EPSILON + celt_inner_prod(X, X, N, arch);
   2ed8c:	3001      	adds	r0, #1
   2ed8e:	fab0 f280 	clz	r2, r0
#ifdef FIXED_POINT
   k = celt_ilog2(E)>>1;
   2ed92:	f1c2 021f 	rsb	r2, r2, #31
   2ed96:	1055      	asrs	r5, r2, #1
#endif
   t = VSHR32(E, 2*(k-7));
   2ed98:	2d07      	cmp	r5, #7
   2ed9a:	f1a5 0307 	sub.w	r3, r5, #7
   2ed9e:	dd17      	ble.n	2edd0 <renormalise_vector+0x64>
   2eda0:	005b      	lsls	r3, r3, #1
   g = MULT16_16_P15(celt_rsqrt_norm(t),gain);
   2eda2:	4118      	asrs	r0, r3
   2eda4:	f7fc fb36 	bl	2b414 <celt_rsqrt_norm>
   2eda8:	f44f 4380 	mov.w	r3, #16384	; 0x4000
   2edac:	fb07 3000 	mla	r0, r7, r0, r3
   2edb0:	f340 30cf 	sbfx	r0, r0, #15, #16

   xptr = X;
   for (i=0;i<N;i++)
   {
      *xptr = EXTRACT16(PSHR32(MULT16_16(g, *xptr), k+1));
   2edb4:	1c6a      	adds	r2, r5, #1
   2edb6:	2101      	movs	r1, #1
   2edb8:	4091      	lsls	r1, r2
   2edba:	19a5      	adds	r5, r4, r6
   2edbc:	1049      	asrs	r1, r1, #1
   2edbe:	8823      	ldrh	r3, [r4, #0]
   2edc0:	fb13 1300 	smlabb	r3, r3, r0, r1
   2edc4:	4113      	asrs	r3, r2
   2edc6:	f824 3b02 	strh.w	r3, [r4], #2
   for (i=0;i<N;i++)
   2edca:	42ac      	cmp	r4, r5
   2edcc:	d1f7      	bne.n	2edbe <renormalise_vector+0x52>
      xptr++;
   }
   /*return celt_sqrt(E);*/
}
   2edce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   g = MULT16_16_P15(celt_rsqrt_norm(t),gain);
   2edd0:	ebc3 73c3 	rsb	r3, r3, r3, lsl #31
   2edd4:	005b      	lsls	r3, r3, #1
   2edd6:	4098      	lsls	r0, r3
   2edd8:	f7fc fb1c 	bl	2b414 <celt_rsqrt_norm>
   2eddc:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   2ede0:	fb00 2007 	mla	r0, r0, r7, r2
   2ede4:	f340 30cf 	sbfx	r0, r0, #15, #16
   2ede8:	e7e4      	b.n	2edb4 <renormalise_vector+0x48>
   2edea:	f44f 4080 	mov.w	r0, #16384	; 0x4000
   2edee:	f7fc bb11 	b.w	2b414 <celt_rsqrt_norm>
   2edf2:	bf00      	nop

0002edf4 <stereo_itheta>:
#endif /* OVERRIDE_renormalise_vector */

int stereo_itheta(const celt_norm *X, const celt_norm *Y, int stereo, int N, int arch)
{
   2edf4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   int itheta;
   opus_val16 mid, side;
   opus_val32 Emid, Eside;

   Emid = Eside = EPSILON;
   if (stereo)
   2edf6:	2a00      	cmp	r2, #0
   2edf8:	d15d      	bne.n	2eeb6 <stereo_itheta+0xc2>
   2edfa:	2b00      	cmp	r3, #0
   2edfc:	f340 80b8 	ble.w	2ef70 <stereo_itheta+0x17c>
   2ee00:	005b      	lsls	r3, r3, #1
   2ee02:	18c5      	adds	r5, r0, r3
   2ee04:	3d02      	subs	r5, #2
   2ee06:	3802      	subs	r0, #2
      xy = MAC16_16(xy, x[i], y[i]);
   2ee08:	f930 4f02 	ldrsh.w	r4, [r0, #2]!
   for (i=0;i<N;i++)
   2ee0c:	4285      	cmp	r5, r0
      xy = MAC16_16(xy, x[i], y[i]);
   2ee0e:	fb04 2204 	mla	r2, r4, r4, r2
   for (i=0;i<N;i++)
   2ee12:	d1f9      	bne.n	2ee08 <stereo_itheta+0x14>
   2ee14:	3902      	subs	r1, #2
   2ee16:	18cc      	adds	r4, r1, r3
         s = SUB16(SHR16(X[i],1),SHR16(Y[i],1));
         Emid = MAC16_16(Emid, m, m);
         Eside = MAC16_16(Eside, s, s);
      }
   } else {
      Emid += celt_inner_prod(X, X, N, arch);
   2ee18:	1c50      	adds	r0, r2, #1
   opus_val32 xy=0;
   2ee1a:	2300      	movs	r3, #0
      xy = MAC16_16(xy, x[i], y[i]);
   2ee1c:	f931 2f02 	ldrsh.w	r2, [r1, #2]!
   for (i=0;i<N;i++)
   2ee20:	428c      	cmp	r4, r1
      xy = MAC16_16(xy, x[i], y[i]);
   2ee22:	fb02 3302 	mla	r3, r2, r2, r3
   for (i=0;i<N;i++)
   2ee26:	d1f9      	bne.n	2ee1c <stereo_itheta+0x28>
   2ee28:	1c5f      	adds	r7, r3, #1
      Eside += celt_inner_prod(Y, Y, N, arch);
   }
   mid = celt_sqrt(Emid);
   2ee2a:	f7fc fb25 	bl	2b478 <celt_sqrt>
   2ee2e:	b204      	sxth	r4, r0
   side = celt_sqrt(Eside);
   2ee30:	4638      	mov	r0, r7
   2ee32:	f7fc fb21 	bl	2b478 <celt_sqrt>
   2ee36:	b205      	sxth	r5, r0
#undef M4

/* atan2() approximation valid for positive input values */
static OPUS_INLINE opus_val16 celt_atan2p(opus_val16 y, opus_val16 x)
{
   if (y < x)
   2ee38:	42ac      	cmp	r4, r5
   2ee3a:	dd58      	ble.n	2eeee <stereo_itheta+0xfa>
   {
      opus_val32 arg;
      arg = celt_div(SHL32(EXTEND32(y),15),x);
   2ee3c:	4620      	mov	r0, r4
   2ee3e:	f7fc fbd5 	bl	2b5ec <celt_rcp>
   2ee42:	4606      	mov	r6, r0
   2ee44:	4620      	mov	r0, r4
   2ee46:	f7fc fbd1 	bl	2b5ec <celt_rcp>
   2ee4a:	03ed      	lsls	r5, r5, #15
   2ee4c:	142a      	asrs	r2, r5, #16
   2ee4e:	b283      	uxth	r3, r0
   2ee50:	fb02 f303 	mul.w	r3, r2, r3
   2ee54:	1436      	asrs	r6, r6, #16
   2ee56:	13db      	asrs	r3, r3, #15
   2ee58:	4620      	mov	r0, r4
   2ee5a:	fb02 f406 	mul.w	r4, r2, r6
   2ee5e:	eb03 0444 	add.w	r4, r3, r4, lsl #1
   2ee62:	f7fc fbc3 	bl	2b5ec <celt_rcp>
   2ee66:	b2ad      	uxth	r5, r5
   2ee68:	1403      	asrs	r3, r0, #16
   2ee6a:	2d00      	cmp	r5, #0
   2ee6c:	bf08      	it	eq
   2ee6e:	2300      	moveq	r3, #0
   2ee70:	4423      	add	r3, r4
      if (arg >= 32767)
         arg = 32767;
      return SHR16(celt_atan01(EXTRACT16(arg)),1);
   2ee72:	f647 71ff 	movw	r1, #32767	; 0x7fff
   2ee76:	428b      	cmp	r3, r1
   2ee78:	bfa8      	it	ge
   2ee7a:	460b      	movge	r3, r1
   2ee7c:	b21b      	sxth	r3, r3
   return MULT16_16_P15(x, ADD32(M1, MULT16_16_P15(x, ADD32(M2, MULT16_16_P15(x, ADD32(M3, MULT16_16_P15(M4, x)))))));
   2ee7e:	f44f 4080 	mov.w	r0, #16384	; 0x4000
   2ee82:	f241 3248 	movw	r2, #4936	; 0x1348
   2ee86:	fb13 0202 	smlabb	r2, r3, r2, r0
   2ee8a:	13d2      	asrs	r2, r2, #15
   2ee8c:	f5a2 523a 	sub.w	r2, r2, #11904	; 0x2e80
   2ee90:	3a27      	subs	r2, #39	; 0x27
   2ee92:	fb13 0202 	smlabb	r2, r3, r2, r0
   2ee96:	13d2      	asrs	r2, r2, #15
   2ee98:	3a15      	subs	r2, #21
   2ee9a:	fb13 0202 	smlabb	r2, r3, r2, r0
   2ee9e:	eb01 32e2 	add.w	r2, r1, r2, asr #15
   2eea2:	fb13 0002 	smlabb	r0, r3, r2, r0
      return SHR16(celt_atan01(EXTRACT16(arg)),1);
   2eea6:	f340 400e 	sbfx	r0, r0, #16, #15
#ifdef FIXED_POINT
   /* 0.63662 = 2/pi */
   itheta = MULT16_16_Q15(QCONST16(0.63662f,15),celt_atan2p(side, mid));
   2eeaa:	f245 137d 	movw	r3, #20861	; 0x517d
   2eeae:	fb10 f003 	smulbb	r0, r0, r3
   2eeb2:	13c0      	asrs	r0, r0, #15
#else
   itheta = (int)floor(.5f+16384*0.63662f*fast_atan2f(side,mid));
#endif

   return itheta;
}
   2eeb4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      for (i=0;i<N;i++)
   2eeb6:	2b00      	cmp	r3, #0
   2eeb8:	dd5a      	ble.n	2ef70 <stereo_itheta+0x17c>
   2eeba:	eb00 0343 	add.w	r3, r0, r3, lsl #1
   Emid = Eside = EPSILON;
   2eebe:	2701      	movs	r7, #1
   2eec0:	1e84      	subs	r4, r0, #2
   2eec2:	1e9a      	subs	r2, r3, #2
   2eec4:	3902      	subs	r1, #2
   2eec6:	4638      	mov	r0, r7
         m = ADD16(SHR16(X[i],1),SHR16(Y[i],1));
   2eec8:	f934 3f02 	ldrsh.w	r3, [r4, #2]!
   2eecc:	f931 6f02 	ldrsh.w	r6, [r1, #2]!
   2eed0:	f3c3 034f 	ubfx	r3, r3, #1, #16
   2eed4:	f3c6 064f 	ubfx	r6, r6, #1, #16
   2eed8:	199d      	adds	r5, r3, r6
         s = SUB16(SHR16(X[i],1),SHR16(Y[i],1));
   2eeda:	1b9b      	subs	r3, r3, r6
         m = ADD16(SHR16(X[i],1),SHR16(Y[i],1));
   2eedc:	b22d      	sxth	r5, r5
         s = SUB16(SHR16(X[i],1),SHR16(Y[i],1));
   2eede:	b21b      	sxth	r3, r3
      for (i=0;i<N;i++)
   2eee0:	42a2      	cmp	r2, r4
         Emid = MAC16_16(Emid, m, m);
   2eee2:	fb05 0005 	mla	r0, r5, r5, r0
         Eside = MAC16_16(Eside, s, s);
   2eee6:	fb03 7703 	mla	r7, r3, r3, r7
      for (i=0;i<N;i++)
   2eeea:	d1ed      	bne.n	2eec8 <stereo_itheta+0xd4>
   2eeec:	e79d      	b.n	2ee2a <stereo_itheta+0x36>
   } else {
      opus_val32 arg;
      arg = celt_div(SHL32(EXTEND32(x),15),y);
   2eeee:	4628      	mov	r0, r5
   2eef0:	f7fc fb7c 	bl	2b5ec <celt_rcp>
   2eef4:	4606      	mov	r6, r0
   2eef6:	4628      	mov	r0, r5
   2eef8:	f7fc fb78 	bl	2b5ec <celt_rcp>
   2eefc:	03e4      	lsls	r4, r4, #15
   2eefe:	1422      	asrs	r2, r4, #16
   2ef00:	b283      	uxth	r3, r0
   2ef02:	fb02 f303 	mul.w	r3, r2, r3
   2ef06:	1436      	asrs	r6, r6, #16
   2ef08:	13db      	asrs	r3, r3, #15
   2ef0a:	4628      	mov	r0, r5
   2ef0c:	fb02 f506 	mul.w	r5, r2, r6
   2ef10:	eb03 0545 	add.w	r5, r3, r5, lsl #1
   2ef14:	f7fc fb6a 	bl	2b5ec <celt_rcp>
   2ef18:	b2a4      	uxth	r4, r4
   2ef1a:	1403      	asrs	r3, r0, #16
   2ef1c:	2c00      	cmp	r4, #0
   2ef1e:	bf08      	it	eq
   2ef20:	2300      	moveq	r3, #0
   2ef22:	442b      	add	r3, r5
      if (arg >= 32767)
         arg = 32767;
      return 25736-SHR16(celt_atan01(EXTRACT16(arg)),1);
   2ef24:	f647 71ff 	movw	r1, #32767	; 0x7fff
   2ef28:	428b      	cmp	r3, r1
   2ef2a:	bfa8      	it	ge
   2ef2c:	460b      	movge	r3, r1
   2ef2e:	b21b      	sxth	r3, r3
   return MULT16_16_P15(x, ADD32(M1, MULT16_16_P15(x, ADD32(M2, MULT16_16_P15(x, ADD32(M3, MULT16_16_P15(M4, x)))))));
   2ef30:	f44f 4080 	mov.w	r0, #16384	; 0x4000
   2ef34:	f241 3248 	movw	r2, #4936	; 0x1348
   2ef38:	fb13 0202 	smlabb	r2, r3, r2, r0
   2ef3c:	13d2      	asrs	r2, r2, #15
   2ef3e:	f5a2 523a 	sub.w	r2, r2, #11904	; 0x2e80
   2ef42:	3a27      	subs	r2, #39	; 0x27
   2ef44:	fb13 0202 	smlabb	r2, r3, r2, r0
   2ef48:	13d2      	asrs	r2, r2, #15
   2ef4a:	3a15      	subs	r2, #21
   2ef4c:	fb13 0202 	smlabb	r2, r3, r2, r0
   2ef50:	eb01 32e2 	add.w	r2, r1, r2, asr #15
   2ef54:	fb13 0002 	smlabb	r0, r3, r2, r0
      return 25736-SHR16(celt_atan01(EXTRACT16(arg)),1);
   2ef58:	f340 400e 	sbfx	r0, r0, #16, #15
   2ef5c:	f5c0 40c9 	rsb	r0, r0, #25728	; 0x6480
   2ef60:	3008      	adds	r0, #8
   itheta = MULT16_16_Q15(QCONST16(0.63662f,15),celt_atan2p(side, mid));
   2ef62:	f245 137d 	movw	r3, #20861	; 0x517d
   2ef66:	b200      	sxth	r0, r0
   2ef68:	fb10 f003 	smulbb	r0, r0, r3
   2ef6c:	13c0      	asrs	r0, r0, #15
}
   2ef6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   Emid = Eside = EPSILON;
   2ef70:	2701      	movs	r7, #1
   2ef72:	4638      	mov	r0, r7
   2ef74:	e759      	b.n	2ee2a <stereo_itheta+0x36>
   2ef76:	bf00      	nop

0002ef78 <encode_size>:
}
#endif

int encode_size(int size, unsigned char *data)
{
   if (size < 252)
   2ef78:	28fb      	cmp	r0, #251	; 0xfb
   2ef7a:	b2c3      	uxtb	r3, r0
   2ef7c:	dc02      	bgt.n	2ef84 <encode_size+0xc>
   {
      data[0] = size;
      return 1;
   2ef7e:	2001      	movs	r0, #1
   2ef80:	700b      	strb	r3, [r1, #0]
   } else {
      data[0] = 252+(size&0x3);
      data[1] = (size-(int)data[0])>>2;
      return 2;
   }
}
   2ef82:	4770      	bx	lr
      data[0] = 252+(size&0x3);
   2ef84:	f043 03fc 	orr.w	r3, r3, #252	; 0xfc
      data[1] = (size-(int)data[0])>>2;
   2ef88:	1ac0      	subs	r0, r0, r3
   2ef8a:	1080      	asrs	r0, r0, #2
   2ef8c:	7048      	strb	r0, [r1, #1]
   2ef8e:	700b      	strb	r3, [r1, #0]
      return 2;
   2ef90:	2002      	movs	r0, #2
}
   2ef92:	4770      	bx	lr

0002ef94 <opus_packet_get_samples_per_frame>:

int opus_packet_get_samples_per_frame(const unsigned char *data,
      opus_int32 Fs)
{
   int audiosize;
   if (data[0]&0x80)
   2ef94:	7800      	ldrb	r0, [r0, #0]
   2ef96:	0603      	lsls	r3, r0, #24
   2ef98:	d41c      	bmi.n	2efd4 <opus_packet_get_samples_per_frame+0x40>
   {
      audiosize = ((data[0]>>3)&0x3);
      audiosize = (Fs<<audiosize)/400;
   } else if ((data[0]&0x60) == 0x60)
   2ef9a:	f000 0360 	and.w	r3, r0, #96	; 0x60
   2ef9e:	2b60      	cmp	r3, #96	; 0x60
   2efa0:	d00b      	beq.n	2efba <opus_packet_get_samples_per_frame+0x26>
   2efa2:	f3c0 00c1 	ubfx	r0, r0, #3, #2
   {
      audiosize = (data[0]&0x08) ? Fs/50 : Fs/100;
   } else {
      audiosize = ((data[0]>>3)&0x3);
      if (audiosize == 3)
   2efa6:	2803      	cmp	r0, #3
   2efa8:	d01e      	beq.n	2efe8 <opus_packet_get_samples_per_frame+0x54>
         audiosize = Fs*60/1000;
      else
         audiosize = (Fs<<audiosize)/100;
   2efaa:	4b14      	ldr	r3, [pc, #80]	; (2effc <opus_packet_get_samples_per_frame+0x68>)
   2efac:	4081      	lsls	r1, r0
   2efae:	fb83 3001 	smull	r3, r0, r3, r1
   2efb2:	17c9      	asrs	r1, r1, #31
   2efb4:	ebc1 1060 	rsb	r0, r1, r0, asr #5
   }
   return audiosize;
}
   2efb8:	4770      	bx	lr
      audiosize = (data[0]&0x08) ? Fs/50 : Fs/100;
   2efba:	4b10      	ldr	r3, [pc, #64]	; (2effc <opus_packet_get_samples_per_frame+0x68>)
   2efbc:	f010 0f08 	tst.w	r0, #8
   2efc0:	ea4f 70e1 	mov.w	r0, r1, asr #31
   2efc4:	fb83 3101 	smull	r3, r1, r3, r1
   2efc8:	bf14      	ite	ne
   2efca:	ebc0 1021 	rsbne	r0, r0, r1, asr #4
   2efce:	ebc0 1061 	rsbeq	r0, r0, r1, asr #5
   2efd2:	4770      	bx	lr
      audiosize = ((data[0]>>3)&0x3);
   2efd4:	f3c0 00c1 	ubfx	r0, r0, #3, #2
      audiosize = (Fs<<audiosize)/400;
   2efd8:	4b08      	ldr	r3, [pc, #32]	; (2effc <opus_packet_get_samples_per_frame+0x68>)
   2efda:	4081      	lsls	r1, r0
   2efdc:	fb83 3001 	smull	r3, r0, r3, r1
   2efe0:	17c9      	asrs	r1, r1, #31
   2efe2:	ebc1 10e0 	rsb	r0, r1, r0, asr #7
   2efe6:	4770      	bx	lr
         audiosize = Fs*60/1000;
   2efe8:	ebc1 1101 	rsb	r1, r1, r1, lsl #4
   2efec:	4804      	ldr	r0, [pc, #16]	; (2f000 <opus_packet_get_samples_per_frame+0x6c>)
   2efee:	0089      	lsls	r1, r1, #2
   2eff0:	fb80 3001 	smull	r3, r0, r0, r1
   2eff4:	17c9      	asrs	r1, r1, #31
   2eff6:	ebc1 10a0 	rsb	r0, r1, r0, asr #6
   2effa:	4770      	bx	lr
   2effc:	51eb851f 	.word	0x51eb851f
   2f000:	10624dd3 	.word	0x10624dd3

0002f004 <opus_packet_parse_impl>:

int opus_packet_parse_impl(const unsigned char *data, opus_int32 len,
      int self_delimited, unsigned char *out_toc,
      const unsigned char *frames[48], opus_int16 size[48],
      int *payload_offset, opus_int32 *packet_offset)
{
   2f004:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2f008:	b085      	sub	sp, #20
   2f00a:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
   int framesize;
   opus_int32 last_size;
   opus_int32 pad = 0;
   const unsigned char *data0 = data;

   if (size==NULL || len<0)
   2f00c:	2e00      	cmp	r6, #0
   2f00e:	f000 81f3 	beq.w	2f3f8 <opus_packet_parse_impl+0x3f4>
   2f012:	2900      	cmp	r1, #0
   2f014:	f2c0 81f0 	blt.w	2f3f8 <opus_packet_parse_impl+0x3f4>
      return OPUS_BAD_ARG;
   if (len==0)
   2f018:	d078      	beq.n	2f10c <opus_packet_parse_impl+0x108>
   if (data[0]&0x80)
   2f01a:	7807      	ldrb	r7, [r0, #0]
   2f01c:	063c      	lsls	r4, r7, #24
   2f01e:	f100 8083 	bmi.w	2f128 <opus_packet_parse_impl+0x124>
   } else if ((data[0]&0x60) == 0x60)
   2f022:	f007 0460 	and.w	r4, r7, #96	; 0x60
   2f026:	2c60      	cmp	r4, #96	; 0x60
   2f028:	d076      	beq.n	2f118 <opus_packet_parse_impl+0x114>
   2f02a:	f3c7 04c1 	ubfx	r4, r7, #3, #2
      if (audiosize == 3)
   2f02e:	2c03      	cmp	r4, #3
   2f030:	f000 812f 	beq.w	2f292 <opus_packet_parse_impl+0x28e>
         audiosize = (Fs<<audiosize)/100;
   2f034:	f64b 3580 	movw	r5, #48000	; 0xbb80
   2f038:	f8df c3c8 	ldr.w	ip, [pc, #968]	; 2f404 <opus_packet_parse_impl+0x400>
   2f03c:	40a5      	lsls	r5, r4
   2f03e:	fbac 4505 	umull	r4, r5, ip, r5
   2f042:	096d      	lsrs	r5, r5, #5

   cbr = 0;
   toc = *data++;
   len--;
   last_size = len;
   switch (toc&0x3)
   2f044:	f007 0c03 	and.w	ip, r7, #3
   2f048:	f1bc 0f01 	cmp.w	ip, #1
   toc = *data++;
   2f04c:	f100 0401 	add.w	r4, r0, #1
   len--;
   2f050:	f101 38ff 	add.w	r8, r1, #4294967295	; 0xffffffff
   switch (toc&0x3)
   2f054:	f000 80d6 	beq.w	2f204 <opus_packet_parse_impl+0x200>
   2f058:	f0c0 8099 	bcc.w	2f18e <opus_packet_parse_impl+0x18a>
   2f05c:	f1bc 0f02 	cmp.w	ip, #2
   2f060:	d16d      	bne.n	2f13e <opus_packet_parse_impl+0x13a>
   if (len<1)
   2f062:	f1b8 0f00 	cmp.w	r8, #0
   2f066:	d04e      	beq.n	2f106 <opus_packet_parse_impl+0x102>
   } else if (data[0]<252)
   2f068:	7845      	ldrb	r5, [r0, #1]
   2f06a:	2dfb      	cmp	r5, #251	; 0xfb
   2f06c:	f200 8114 	bhi.w	2f298 <opus_packet_parse_impl+0x294>
      *size = data[0];
   2f070:	b22d      	sxth	r5, r5
   2f072:	8035      	strh	r5, [r6, #0]
      break;
   /* Two VBR frames */
   case 2:
      count = 2;
      bytes = parse_size(data, len, size);
      len -= bytes;
   2f074:	f1a1 0802 	sub.w	r8, r1, #2
   2f078:	f04f 0c01 	mov.w	ip, #1
      if (size[0]<0 || size[0] > len)
   2f07c:	4545      	cmp	r5, r8
   2f07e:	dc45      	bgt.n	2f10c <opus_packet_parse_impl+0x108>
   opus_int32 pad = 0;
   2f080:	f04f 0e00 	mov.w	lr, #0
         return OPUS_INVALID_PACKET;
      data += bytes;
      last_size = len-size[0];
   2f084:	eba8 0105 	sub.w	r1, r8, r5
      data += bytes;
   2f088:	4464      	add	r4, ip
      last_size = len-size[0];
   2f08a:	9101      	str	r1, [sp, #4]
   cbr = 0;
   2f08c:	46f3      	mov	fp, lr
      count = 2;
   2f08e:	f04f 0c02 	mov.w	ip, #2
            size[i] = (opus_int16)last_size;
      }
      break;
   }
   /* Self-delimited framing has an extra size for the last frame. */
   if (self_delimited)
   2f092:	2a00      	cmp	r2, #0
   2f094:	f000 8085 	beq.w	2f1a2 <opus_packet_parse_impl+0x19e>
   2f098:	f10c 4200 	add.w	r2, ip, #2147483648	; 0x80000000
   2f09c:	3a01      	subs	r2, #1
   2f09e:	4645      	mov	r5, r8
   2f0a0:	f8dd 8004 	ldr.w	r8, [sp, #4]
   2f0a4:	0052      	lsls	r2, r2, #1
   {
      bytes = parse_size(data, len, size+count-1);
   2f0a6:	18b1      	adds	r1, r6, r2
   if (len<1)
   2f0a8:	2d00      	cmp	r5, #0
   2f0aa:	f000 80c9 	beq.w	2f240 <opus_packet_parse_impl+0x23c>
   } else if (data[0]<252)
   2f0ae:	7822      	ldrb	r2, [r4, #0]
   2f0b0:	2afb      	cmp	r2, #251	; 0xfb
   2f0b2:	f240 80b4 	bls.w	2f21e <opus_packet_parse_impl+0x21a>
   } else if (len<2)
   2f0b6:	2d01      	cmp	r5, #1
   2f0b8:	f000 819a 	beq.w	2f3f0 <opus_packet_parse_impl+0x3ec>
      *size = 4*data[1] + data[0];
   2f0bc:	f894 a001 	ldrb.w	sl, [r4, #1]
      len -= bytes;
   2f0c0:	f04f 0902 	mov.w	r9, #2
      *size = 4*data[1] + data[0];
   2f0c4:	eb02 028a 	add.w	r2, r2, sl, lsl #2
      len -= bytes;
   2f0c8:	3d02      	subs	r5, #2
      *size = 4*data[1] + data[0];
   2f0ca:	800a      	strh	r2, [r1, #0]
      return 2;
   2f0cc:	46ca      	mov	sl, r9
      if (size[count-1]<0 || size[count-1] > len)
   2f0ce:	42aa      	cmp	r2, r5
   2f0d0:	dc1c      	bgt.n	2f10c <opus_packet_parse_impl+0x108>
         return OPUS_INVALID_PACKET;
      data += bytes;
   2f0d2:	444c      	add	r4, r9
      /* For CBR packets, apply the size to all the frames. */
      if (cbr)
   2f0d4:	f1bb 0f00 	cmp.w	fp, #0
   2f0d8:	f000 80d4 	beq.w	2f284 <opus_packet_parse_impl+0x280>
      {
         if (size[count-1]*count > len)
   2f0dc:	fb0c f802 	mul.w	r8, ip, r2
   2f0e0:	45a8      	cmp	r8, r5
   2f0e2:	dc13      	bgt.n	2f10c <opus_packet_parse_impl+0x108>
            return OPUS_INVALID_PACKET;
         for (i=0;i<count-1;i++)
   2f0e4:	f1bc 0f01 	cmp.w	ip, #1
   2f0e8:	f1a6 0802 	sub.w	r8, r6, #2
   2f0ec:	d065      	beq.n	2f1ba <opus_packet_parse_impl+0x1b6>
   2f0ee:	3e04      	subs	r6, #4
   2f0f0:	eb06 064c 	add.w	r6, r6, ip, lsl #1
   2f0f4:	4645      	mov	r5, r8
   2f0f6:	e001      	b.n	2f0fc <opus_packet_parse_impl+0xf8>
   2f0f8:	f9b1 2000 	ldrsh.w	r2, [r1]
            size[i] = size[count-1];
   2f0fc:	f825 2f02 	strh.w	r2, [r5, #2]!
         for (i=0;i<count-1;i++)
   2f100:	42ae      	cmp	r6, r5
   2f102:	d1f9      	bne.n	2f0f8 <opus_packet_parse_impl+0xf4>
   2f104:	e059      	b.n	2f1ba <opus_packet_parse_impl+0x1b6>
      *size = -1;
   2f106:	f64f 73ff 	movw	r3, #65535	; 0xffff
   2f10a:	8033      	strh	r3, [r6, #0]
         return OPUS_INVALID_PACKET;
   2f10c:	f06f 0c03 	mvn.w	ip, #3

   if (out_toc)
      *out_toc = toc;

   return count;
}
   2f110:	4660      	mov	r0, ip
   2f112:	b005      	add	sp, #20
   2f114:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      audiosize = (data[0]&0x08) ? Fs/50 : Fs/100;
   2f118:	f017 0f08 	tst.w	r7, #8
   2f11c:	bf0c      	ite	eq
   2f11e:	f44f 75f0 	moveq.w	r5, #480	; 0x1e0
   2f122:	f44f 7570 	movne.w	r5, #960	; 0x3c0
   2f126:	e78d      	b.n	2f044 <opus_packet_parse_impl+0x40>
      audiosize = ((data[0]>>3)&0x3);
   2f128:	f3c7 0cc1 	ubfx	ip, r7, #3, #2
      audiosize = (Fs<<audiosize)/400;
   2f12c:	f64b 3580 	movw	r5, #48000	; 0xbb80
   2f130:	4cb4      	ldr	r4, [pc, #720]	; (2f404 <opus_packet_parse_impl+0x400>)
   2f132:	fa05 f50c 	lsl.w	r5, r5, ip
   2f136:	fba4 4505 	umull	r4, r5, r4, r5
   2f13a:	09ed      	lsrs	r5, r5, #7
   2f13c:	e782      	b.n	2f044 <opus_packet_parse_impl+0x40>
      if (len<1)
   2f13e:	f1b8 0f00 	cmp.w	r8, #0
   2f142:	d0e3      	beq.n	2f10c <opus_packet_parse_impl+0x108>
      ch = *data++;
   2f144:	f890 a001 	ldrb.w	sl, [r0, #1]
   2f148:	f00a 093f 	and.w	r9, sl, #63	; 0x3f
      count = ch&0x3F;
   2f14c:	46cc      	mov	ip, r9
      if (count <= 0 || framesize*(opus_int32)count > 5760)
   2f14e:	f1b9 0f00 	cmp.w	r9, #0
   2f152:	d0db      	beq.n	2f10c <opus_packet_parse_impl+0x108>
   2f154:	fb05 f509 	mul.w	r5, r5, r9
   2f158:	f5b5 5fb4 	cmp.w	r5, #5760	; 0x1680
   2f15c:	dcd6      	bgt.n	2f10c <opus_packet_parse_impl+0x108>
      if (ch&0x40)
   2f15e:	f01a 0e40 	ands.w	lr, sl, #64	; 0x40
      len--;
   2f162:	f1a1 0502 	sub.w	r5, r1, #2
      if (ch&0x40)
   2f166:	d16f      	bne.n	2f248 <opus_packet_parse_impl+0x244>
      ch = *data++;
   2f168:	1c84      	adds	r4, r0, #2
      cbr = !(ch&0x80);
   2f16a:	fa4f fa8a 	sxtb.w	sl, sl
   2f16e:	ea6f 0b0a 	mvn.w	fp, sl
      if (!cbr)
   2f172:	f1ba 0f00 	cmp.w	sl, #0
      cbr = !(ch&0x80);
   2f176:	ea4f 7bdb 	mov.w	fp, fp, lsr #31
      if (!cbr)
   2f17a:	f2c0 8099 	blt.w	2f2b0 <opus_packet_parse_impl+0x2ac>
      } else if (!self_delimited)
   2f17e:	2a00      	cmp	r2, #0
   2f180:	f000 80da 	beq.w	2f338 <opus_packet_parse_impl+0x334>
   2f184:	f109 4200 	add.w	r2, r9, #2147483648	; 0x80000000
   2f188:	3a01      	subs	r2, #1
   2f18a:	0052      	lsls	r2, r2, #1
   2f18c:	e78b      	b.n	2f0a6 <opus_packet_parse_impl+0xa2>
   opus_int32 pad = 0;
   2f18e:	f04f 0e00 	mov.w	lr, #0
   cbr = 0;
   2f192:	46f3      	mov	fp, lr
   len--;
   2f194:	f8cd 8004 	str.w	r8, [sp, #4]
      count=1;
   2f198:	f04f 0c01 	mov.w	ip, #1
   if (self_delimited)
   2f19c:	2a00      	cmp	r2, #0
   2f19e:	f47f af7b 	bne.w	2f098 <opus_packet_parse_impl+0x94>
      if (last_size > 1275)
   2f1a2:	9901      	ldr	r1, [sp, #4]
   2f1a4:	f240 42fb 	movw	r2, #1275	; 0x4fb
   2f1a8:	4291      	cmp	r1, r2
   2f1aa:	dcaf      	bgt.n	2f10c <opus_packet_parse_impl+0x108>
      size[count-1] = (opus_int16)last_size;
   2f1ac:	f10c 4200 	add.w	r2, ip, #2147483648	; 0x80000000
   2f1b0:	3a01      	subs	r2, #1
   2f1b2:	f1a6 0802 	sub.w	r8, r6, #2
   2f1b6:	f826 1012 	strh.w	r1, [r6, r2, lsl #1]
   if (payload_offset)
   2f1ba:	9a10      	ldr	r2, [sp, #64]	; 0x40
   2f1bc:	b112      	cbz	r2, 2f1c4 <opus_packet_parse_impl+0x1c0>
   2f1be:	4611      	mov	r1, r2
      *payload_offset = (int)(data-data0);
   2f1c0:	1a22      	subs	r2, r4, r0
   2f1c2:	600a      	str	r2, [r1, #0]
   2f1c4:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   2f1c6:	b1aa      	cbz	r2, 2f1f4 <opus_packet_parse_impl+0x1f0>
   2f1c8:	3a04      	subs	r2, #4
   2f1ca:	eb02 058c 	add.w	r5, r2, ip, lsl #2
         frames[i] = data;
   2f1ce:	f842 4f04 	str.w	r4, [r2, #4]!
      data += size[i];
   2f1d2:	f938 1f02 	ldrsh.w	r1, [r8, #2]!
   for (i=0;i<count;i++)
   2f1d6:	4295      	cmp	r5, r2
      data += size[i];
   2f1d8:	440c      	add	r4, r1
   for (i=0;i<count;i++)
   2f1da:	d1f8      	bne.n	2f1ce <opus_packet_parse_impl+0x1ca>
   if (packet_offset)
   2f1dc:	9a11      	ldr	r2, [sp, #68]	; 0x44
   2f1de:	b112      	cbz	r2, 2f1e6 <opus_packet_parse_impl+0x1e2>
      *packet_offset = pad+(opus_int32)(data-data0);
   2f1e0:	1a20      	subs	r0, r4, r0
   2f1e2:	4470      	add	r0, lr
   2f1e4:	6010      	str	r0, [r2, #0]
   if (out_toc)
   2f1e6:	2b00      	cmp	r3, #0
   2f1e8:	d092      	beq.n	2f110 <opus_packet_parse_impl+0x10c>
}
   2f1ea:	4660      	mov	r0, ip
      *out_toc = toc;
   2f1ec:	701f      	strb	r7, [r3, #0]
}
   2f1ee:	b005      	add	sp, #20
   2f1f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2f1f4:	eb08 014c 	add.w	r1, r8, ip, lsl #1
      data += size[i];
   2f1f8:	f938 2f02 	ldrsh.w	r2, [r8, #2]!
   for (i=0;i<count;i++)
   2f1fc:	4541      	cmp	r1, r8
      data += size[i];
   2f1fe:	4414      	add	r4, r2
   for (i=0;i<count;i++)
   2f200:	d1fa      	bne.n	2f1f8 <opus_packet_parse_impl+0x1f4>
   2f202:	e7eb      	b.n	2f1dc <opus_packet_parse_impl+0x1d8>
      if (!self_delimited)
   2f204:	b992      	cbnz	r2, 2f22c <opus_packet_parse_impl+0x228>
         if (len&0x1)
   2f206:	f018 0f01 	tst.w	r8, #1
   2f20a:	f47f af7f 	bne.w	2f10c <opus_packet_parse_impl+0x108>
         last_size = len/2;
   2f20e:	ea4f 0168 	mov.w	r1, r8, asr #1
   2f212:	9101      	str	r1, [sp, #4]
         size[0] = (opus_int16)last_size;
   2f214:	8031      	strh	r1, [r6, #0]
   opus_int32 pad = 0;
   2f216:	4696      	mov	lr, r2
      count=2;
   2f218:	f04f 0c02 	mov.w	ip, #2
   2f21c:	e7c1      	b.n	2f1a2 <opus_packet_parse_impl+0x19e>
      *size = data[0];
   2f21e:	b212      	sxth	r2, r2
      len -= bytes;
   2f220:	f04f 0901 	mov.w	r9, #1
      *size = data[0];
   2f224:	800a      	strh	r2, [r1, #0]
      len -= bytes;
   2f226:	3d01      	subs	r5, #1
      return 1;
   2f228:	46ca      	mov	sl, r9
   2f22a:	e750      	b.n	2f0ce <opus_packet_parse_impl+0xca>
   2f22c:	2202      	movs	r2, #2
   len--;
   2f22e:	4645      	mov	r5, r8
      cbr = 1;
   2f230:	46e3      	mov	fp, ip
   opus_int32 pad = 0;
   2f232:	f04f 0e00 	mov.w	lr, #0
      count=2;
   2f236:	4694      	mov	ip, r2
      bytes = parse_size(data, len, size+count-1);
   2f238:	18b1      	adds	r1, r6, r2
   if (len<1)
   2f23a:	2d00      	cmp	r5, #0
   2f23c:	f47f af37 	bne.w	2f0ae <opus_packet_parse_impl+0xaa>
      *size = -1;
   2f240:	f64f 73ff 	movw	r3, #65535	; 0xffff
   2f244:	52b3      	strh	r3, [r6, r2]
   2f246:	e761      	b.n	2f10c <opus_packet_parse_impl+0x108>
            if (len<=0)
   2f248:	2d00      	cmp	r5, #0
   2f24a:	f43f af5f 	beq.w	2f10c <opus_packet_parse_impl+0x108>
            p = *data++;
   2f24e:	7885      	ldrb	r5, [r0, #2]
            tmp = p==255 ? 254: p;
   2f250:	2dff      	cmp	r5, #255	; 0xff
            len--;
   2f252:	f1a1 0103 	sub.w	r1, r1, #3
            p = *data++;
   2f256:	f100 0403 	add.w	r4, r0, #3
   opus_int32 pad = 0;
   2f25a:	f04f 0e00 	mov.w	lr, #0
            tmp = p==255 ? 254: p;
   2f25e:	d003      	beq.n	2f268 <opus_packet_parse_impl+0x264>
            pad += tmp;
   2f260:	44ae      	add	lr, r5
      if (len<0)
   2f262:	1b4d      	subs	r5, r1, r5
   2f264:	d581      	bpl.n	2f16a <opus_packet_parse_impl+0x166>
   2f266:	e751      	b.n	2f10c <opus_packet_parse_impl+0x108>
   2f268:	f1a1 05fe 	sub.w	r5, r1, #254	; 0xfe
            if (len<=0)
   2f26c:	2d00      	cmp	r5, #0
            pad += tmp;
   2f26e:	f10e 0efe 	add.w	lr, lr, #254	; 0xfe
            len--;
   2f272:	f1a1 01ff 	sub.w	r1, r1, #255	; 0xff
            if (len<=0)
   2f276:	f77f af49 	ble.w	2f10c <opus_packet_parse_impl+0x108>
            p = *data++;
   2f27a:	f814 5b01 	ldrb.w	r5, [r4], #1
            tmp = p==255 ? 254: p;
   2f27e:	2dff      	cmp	r5, #255	; 0xff
   2f280:	d1ee      	bne.n	2f260 <opus_packet_parse_impl+0x25c>
   2f282:	e7f1      	b.n	2f268 <opus_packet_parse_impl+0x264>
      } else if (bytes+size[count-1] > last_size)
   2f284:	4452      	add	r2, sl
   2f286:	4542      	cmp	r2, r8
   2f288:	f73f af40 	bgt.w	2f10c <opus_packet_parse_impl+0x108>
   2f28c:	f1a6 0802 	sub.w	r8, r6, #2
   2f290:	e793      	b.n	2f1ba <opus_packet_parse_impl+0x1b6>
         audiosize = Fs*60/1000;
   2f292:	f44f 6534 	mov.w	r5, #2880	; 0xb40
   2f296:	e6d5      	b.n	2f044 <opus_packet_parse_impl+0x40>
   } else if (len<2)
   2f298:	f1b8 0f01 	cmp.w	r8, #1
   2f29c:	f43f af33 	beq.w	2f106 <opus_packet_parse_impl+0x102>
      *size = 4*data[1] + data[0];
   2f2a0:	f890 e002 	ldrb.w	lr, [r0, #2]
   2f2a4:	eb05 058e 	add.w	r5, r5, lr, lsl #2
      len -= bytes;
   2f2a8:	f1a1 0803 	sub.w	r8, r1, #3
      *size = 4*data[1] + data[0];
   2f2ac:	8035      	strh	r5, [r6, #0]
   2f2ae:	e6e5      	b.n	2f07c <opus_packet_parse_impl+0x78>
         for (i=0;i<count-1;i++)
   2f2b0:	f1b9 0f01 	cmp.w	r9, #1
   2f2b4:	f000 80a3 	beq.w	2f3fe <opus_packet_parse_impl+0x3fa>
   2f2b8:	f1a6 0802 	sub.w	r8, r6, #2
   2f2bc:	eb08 0149 	add.w	r1, r8, r9, lsl #1
   2f2c0:	9101      	str	r1, [sp, #4]
   2f2c2:	e9cd be02 	strd	fp, lr, [sp, #8]
   2f2c6:	f8dd b004 	ldr.w	fp, [sp, #4]
   2f2ca:	46b0      	mov	r8, r6
   2f2cc:	4629      	mov	r1, r5
   if (len<1)
   2f2ce:	b30d      	cbz	r5, 2f314 <opus_packet_parse_impl+0x310>
   } else if (data[0]<252)
   2f2d0:	f894 9000 	ldrb.w	r9, [r4]
   2f2d4:	f1b9 0ffb 	cmp.w	r9, #251	; 0xfb
      *size = data[0];
   2f2d8:	fa0f fe89 	sxth.w	lr, r9
            len -= bytes;
   2f2dc:	f04f 0a01 	mov.w	sl, #1
   } else if (data[0]<252)
   2f2e0:	d81d      	bhi.n	2f31e <opus_packet_parse_impl+0x31a>
      *size = data[0];
   2f2e2:	f8a8 e000 	strh.w	lr, [r8]
            len -= bytes;
   2f2e6:	3d01      	subs	r5, #1
      return 1;
   2f2e8:	46d1      	mov	r9, sl
            last_size -= bytes+size[i];
   2f2ea:	44f1      	add	r9, lr
            if (size[i]<0 || size[i] > len)
   2f2ec:	45ae      	cmp	lr, r5
   2f2ee:	f108 0802 	add.w	r8, r8, #2
            data += bytes;
   2f2f2:	4454      	add	r4, sl
            last_size -= bytes+size[i];
   2f2f4:	eba1 0109 	sub.w	r1, r1, r9
            if (size[i]<0 || size[i] > len)
   2f2f8:	f73f af08 	bgt.w	2f10c <opus_packet_parse_impl+0x108>
         for (i=0;i<count-1;i++)
   2f2fc:	45c3      	cmp	fp, r8
   2f2fe:	d1e6      	bne.n	2f2ce <opus_packet_parse_impl+0x2ca>
         if (last_size<0)
   2f300:	2900      	cmp	r1, #0
   2f302:	f8dd b008 	ldr.w	fp, [sp, #8]
   2f306:	9101      	str	r1, [sp, #4]
   2f308:	f8dd e00c 	ldr.w	lr, [sp, #12]
   2f30c:	f6ff aefe 	blt.w	2f10c <opus_packet_parse_impl+0x108>
   2f310:	46a8      	mov	r8, r5
   2f312:	e6be      	b.n	2f092 <opus_packet_parse_impl+0x8e>
      *size = -1;
   2f314:	f64f 73ff 	movw	r3, #65535	; 0xffff
   2f318:	f8a8 3000 	strh.w	r3, [r8]
   2f31c:	e6f6      	b.n	2f10c <opus_packet_parse_impl+0x108>
   } else if (len<2)
   2f31e:	2d01      	cmp	r5, #1
   2f320:	d0f8      	beq.n	2f314 <opus_packet_parse_impl+0x310>
      *size = 4*data[1] + data[0];
   2f322:	f894 e001 	ldrb.w	lr, [r4, #1]
            len -= bytes;
   2f326:	f04f 0a02 	mov.w	sl, #2
      *size = 4*data[1] + data[0];
   2f32a:	eb09 0e8e 	add.w	lr, r9, lr, lsl #2
            len -= bytes;
   2f32e:	3d02      	subs	r5, #2
      *size = 4*data[1] + data[0];
   2f330:	f8a8 e000 	strh.w	lr, [r8]
      return 2;
   2f334:	46d1      	mov	r9, sl
   2f336:	e7d8      	b.n	2f2ea <opus_packet_parse_impl+0x2e6>
         last_size = len/count;
   2f338:	fb95 f1f9 	sdiv	r1, r5, r9
         if (last_size*count!=len)
   2f33c:	fb01 f809 	mul.w	r8, r1, r9
   2f340:	45a8      	cmp	r8, r5
   2f342:	9101      	str	r1, [sp, #4]
   2f344:	f47f aee2 	bne.w	2f10c <opus_packet_parse_impl+0x108>
         for (i=0;i<count-1;i++)
   2f348:	f1b9 0101 	subs.w	r1, r9, #1
   2f34c:	9102      	str	r1, [sp, #8]
   2f34e:	f43f af28 	beq.w	2f1a2 <opus_packet_parse_impl+0x19e>
   2f352:	f1a9 0902 	sub.w	r9, r9, #2
   2f356:	f1b9 0f04 	cmp.w	r9, #4
   2f35a:	f9bd b004 	ldrsh.w	fp, [sp, #4]
   2f35e:	f3c6 0540 	ubfx	r5, r6, #1, #1
   2f362:	d923      	bls.n	2f3ac <opus_packet_parse_impl+0x3a8>
   2f364:	b115      	cbz	r5, 2f36c <opus_packet_parse_impl+0x368>
            size[i] = (opus_int16)last_size;
   2f366:	f8a6 b000 	strh.w	fp, [r6]
         for (i=0;i<count-1;i++)
   2f36a:	2201      	movs	r2, #1
   2f36c:	f04f 0900 	mov.w	r9, #0
   2f370:	f36b 090f 	bfi	r9, fp, #0, #16
   2f374:	1b49      	subs	r1, r1, r5
   2f376:	f36b 491f 	bfi	r9, fp, #16, #16
   2f37a:	9103      	str	r1, [sp, #12]
   2f37c:	ea4f 0a51 	mov.w	sl, r1, lsr #1
   2f380:	9901      	ldr	r1, [sp, #4]
   2f382:	f8cd 9004 	str.w	r9, [sp, #4]
   2f386:	4699      	mov	r9, r3
   2f388:	9b01      	ldr	r3, [sp, #4]
   2f38a:	eb06 0845 	add.w	r8, r6, r5, lsl #1
   2f38e:	2500      	movs	r5, #0
   2f390:	3501      	adds	r5, #1
   2f392:	4555      	cmp	r5, sl
            size[i] = (opus_int16)last_size;
   2f394:	f848 3b04 	str.w	r3, [r8], #4
   2f398:	d3fa      	bcc.n	2f390 <opus_packet_parse_impl+0x38c>
   2f39a:	9101      	str	r1, [sp, #4]
   2f39c:	9903      	ldr	r1, [sp, #12]
   2f39e:	f021 0501 	bic.w	r5, r1, #1
   2f3a2:	428d      	cmp	r5, r1
   2f3a4:	464b      	mov	r3, r9
   2f3a6:	442a      	add	r2, r5
   2f3a8:	f43f aefb 	beq.w	2f1a2 <opus_packet_parse_impl+0x19e>
         for (i=0;i<count-1;i++)
   2f3ac:	9902      	ldr	r1, [sp, #8]
            size[i] = (opus_int16)last_size;
   2f3ae:	f826 b012 	strh.w	fp, [r6, r2, lsl #1]
         for (i=0;i<count-1;i++)
   2f3b2:	f102 0801 	add.w	r8, r2, #1
   2f3b6:	4541      	cmp	r1, r8
            size[i] = (opus_int16)last_size;
   2f3b8:	ea4f 0942 	mov.w	r9, r2, lsl #1
         for (i=0;i<count-1;i++)
   2f3bc:	f77f aef1 	ble.w	2f1a2 <opus_packet_parse_impl+0x19e>
            size[i] = (opus_int16)last_size;
   2f3c0:	44b1      	add	r9, r6
         for (i=0;i<count-1;i++)
   2f3c2:	f102 0802 	add.w	r8, r2, #2
   2f3c6:	4541      	cmp	r1, r8
            size[i] = (opus_int16)last_size;
   2f3c8:	f8a9 b002 	strh.w	fp, [r9, #2]
         for (i=0;i<count-1;i++)
   2f3cc:	f77f aee9 	ble.w	2f1a2 <opus_packet_parse_impl+0x19e>
   2f3d0:	f102 0803 	add.w	r8, r2, #3
   2f3d4:	4541      	cmp	r1, r8
            size[i] = (opus_int16)last_size;
   2f3d6:	f8a9 b004 	strh.w	fp, [r9, #4]
         for (i=0;i<count-1;i++)
   2f3da:	f77f aee2 	ble.w	2f1a2 <opus_packet_parse_impl+0x19e>
   2f3de:	3204      	adds	r2, #4
   2f3e0:	4291      	cmp	r1, r2
            size[i] = (opus_int16)last_size;
   2f3e2:	f8a9 b006 	strh.w	fp, [r9, #6]
         for (i=0;i<count-1;i++)
   2f3e6:	f77f aedc 	ble.w	2f1a2 <opus_packet_parse_impl+0x19e>
            size[i] = (opus_int16)last_size;
   2f3ea:	f8a9 b008 	strh.w	fp, [r9, #8]
   2f3ee:	e6d8      	b.n	2f1a2 <opus_packet_parse_impl+0x19e>
      *size = -1;
   2f3f0:	f64f 73ff 	movw	r3, #65535	; 0xffff
   2f3f4:	800b      	strh	r3, [r1, #0]
   2f3f6:	e689      	b.n	2f10c <opus_packet_parse_impl+0x108>
      return OPUS_BAD_ARG;
   2f3f8:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
   2f3fc:	e688      	b.n	2f110 <opus_packet_parse_impl+0x10c>
         for (i=0;i<count-1;i++)
   2f3fe:	46a8      	mov	r8, r5
   2f400:	9501      	str	r5, [sp, #4]
   2f402:	e646      	b.n	2f092 <opus_packet_parse_impl+0x8e>
   2f404:	51eb851f 	.word	0x51eb851f

0002f408 <opus_packet_get_nb_frames>:
}

int opus_packet_get_nb_frames(const unsigned char packet[], opus_int32 len)
{
   int count;
   if (len<1)
   2f408:	2900      	cmp	r1, #0
   2f40a:	dd0f      	ble.n	2f42c <opus_packet_get_nb_frames+0x24>
   2f40c:	7803      	ldrb	r3, [r0, #0]
      return OPUS_BAD_ARG;
   count = packet[0]&0x3;
   if (count==0)
   2f40e:	f013 0303 	ands.w	r3, r3, #3
   2f412:	d009      	beq.n	2f428 <opus_packet_get_nb_frames+0x20>
      return 1;
   else if (count!=3)
   2f414:	2b03      	cmp	r3, #3
   2f416:	d105      	bne.n	2f424 <opus_packet_get_nb_frames+0x1c>
      return 2;
   else if (len<2)
   2f418:	2901      	cmp	r1, #1
   2f41a:	d00a      	beq.n	2f432 <opus_packet_get_nb_frames+0x2a>
      return OPUS_INVALID_PACKET;
   else
      return packet[1]&0x3F;
   2f41c:	7840      	ldrb	r0, [r0, #1]
   2f41e:	f000 003f 	and.w	r0, r0, #63	; 0x3f
   2f422:	4770      	bx	lr
      return 2;
   2f424:	2002      	movs	r0, #2
   2f426:	4770      	bx	lr
      return 1;
   2f428:	2001      	movs	r0, #1
   2f42a:	4770      	bx	lr
      return OPUS_BAD_ARG;
   2f42c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2f430:	4770      	bx	lr
      return OPUS_INVALID_PACKET;
   2f432:	f06f 0003 	mvn.w	r0, #3
}
   2f436:	4770      	bx	lr

0002f438 <gain_fade>:
    }
}

static void gain_fade(const opus_val16 *in, opus_val16 *out, opus_val16 g1, opus_val16 g2,
        int overlap48, int frame_size, int channels, const opus_val16 *window, opus_int32 Fs)
{
   2f438:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2f43c:	b083      	sub	sp, #12
   2f43e:	e9dd 4c0c 	ldrd	r4, ip, [sp, #48]	; 0x30
   2f442:	f8dd e038 	ldr.w	lr, [sp, #56]	; 0x38
   2f446:	9d10      	ldr	r5, [sp, #64]	; 0x40
    int inc;
    int overlap;
    int c;
    inc = 48000/Fs;
    overlap=overlap48/inc;
    if (channels==1)
   2f448:	f1be 0f01 	cmp.w	lr, #1
    inc = 48000/Fs;
   2f44c:	f64b 3980 	movw	r9, #48000	; 0xbb80
   2f450:	fb99 f5f5 	sdiv	r5, r9, r5
    overlap=overlap48/inc;
   2f454:	fb94 f4f5 	sdiv	r4, r4, r5
    if (channels==1)
   2f458:	d049      	beq.n	2f4ee <gain_fade+0xb6>
          g = SHR32(MAC16_16(MULT16_16(w,g2),
                Q15ONE-w, g1), 15);
          out[i] = MULT16_16_Q15(g, in[i]);
       }
    } else {
       for (i=0;i<overlap;i++)
   2f45a:	2c00      	cmp	r4, #0
   2f45c:	dd29      	ble.n	2f4b2 <gain_fade+0x7a>
   2f45e:	f8dd 903c 	ldr.w	r9, [sp, #60]	; 0x3c
   2f462:	ea4f 0a45 	mov.w	sl, r5, lsl #1
   2f466:	f04f 0802 	mov.w	r8, #2
   2f46a:	2700      	movs	r7, #0
       {
          opus_val16 g, w;
          w = MULT16_16_Q15(window[i*inc], window[i*inc]);
          g = SHR32(MAC16_16(MULT16_16(w,g2),
   2f46c:	f647 7bff 	movw	fp, #32767	; 0x7fff
          w = MULT16_16_Q15(window[i*inc], window[i*inc]);
   2f470:	f9b9 5000 	ldrsh.w	r5, [r9]
   2f474:	fb05 f505 	mul.w	r5, r5, r5
   2f478:	13ed      	asrs	r5, r5, #15
          g = SHR32(MAC16_16(MULT16_16(w,g2),
   2f47a:	ebab 0605 	sub.w	r6, fp, r5
   2f47e:	fb16 f602 	smulbb	r6, r6, r2
   2f482:	fb15 6503 	smlabb	r5, r5, r3, r6
                Q15ONE-w, g1), 15);
          out[i*2] = MULT16_16_Q15(g, in[i*2]);
   2f486:	f830 6027 	ldrh.w	r6, [r0, r7, lsl #2]
          g = SHR32(MAC16_16(MULT16_16(w,g2),
   2f48a:	f345 35cf 	sbfx	r5, r5, #15, #16
          out[i*2] = MULT16_16_Q15(g, in[i*2]);
   2f48e:	fb16 f605 	smulbb	r6, r6, r5
   2f492:	13f6      	asrs	r6, r6, #15
   2f494:	f821 6027 	strh.w	r6, [r1, r7, lsl #2]
          out[i*2+1] = MULT16_16_Q15(g, in[i*2+1]);
   2f498:	f830 6008 	ldrh.w	r6, [r0, r8]
       for (i=0;i<overlap;i++)
   2f49c:	3701      	adds	r7, #1
          out[i*2+1] = MULT16_16_Q15(g, in[i*2+1]);
   2f49e:	fb16 f505 	smulbb	r5, r6, r5
   2f4a2:	13ed      	asrs	r5, r5, #15
       for (i=0;i<overlap;i++)
   2f4a4:	42bc      	cmp	r4, r7
          out[i*2+1] = MULT16_16_Q15(g, in[i*2+1]);
   2f4a6:	f821 5008 	strh.w	r5, [r1, r8]
   2f4aa:	44d1      	add	r9, sl
   2f4ac:	f108 0804 	add.w	r8, r8, #4
       for (i=0;i<overlap;i++)
   2f4b0:	d1de      	bne.n	2f470 <gain_fade+0x38>
   2f4b2:	4564      	cmp	r4, ip
   2f4b4:	da18      	bge.n	2f4e8 <gain_fade+0xb0>
   2f4b6:	fb0e f804 	mul.w	r8, lr, r4
   2f4ba:	ea4f 0848 	mov.w	r8, r8, lsl #1
   2f4be:	ea4f 074e 	mov.w	r7, lr, lsl #1
   2f4c2:	f04f 0900 	mov.w	r9, #0
   2f4c6:	4645      	mov	r5, r8
   2f4c8:	4626      	mov	r6, r4
       }
    }
    c=0;do {
       for (i=overlap;i<frame_size;i++)
       {
          out[i*channels+c] = MULT16_16_Q15(g2, in[i*channels+c]);
   2f4ca:	5b42      	ldrh	r2, [r0, r5]
       for (i=overlap;i<frame_size;i++)
   2f4cc:	3601      	adds	r6, #1
          out[i*channels+c] = MULT16_16_Q15(g2, in[i*channels+c]);
   2f4ce:	fb12 f203 	smulbb	r2, r2, r3
   2f4d2:	13d2      	asrs	r2, r2, #15
       for (i=overlap;i<frame_size;i++)
   2f4d4:	45b4      	cmp	ip, r6
          out[i*channels+c] = MULT16_16_Q15(g2, in[i*channels+c]);
   2f4d6:	534a      	strh	r2, [r1, r5]
   2f4d8:	443d      	add	r5, r7
       for (i=overlap;i<frame_size;i++)
   2f4da:	d1f6      	bne.n	2f4ca <gain_fade+0x92>
       }
    }
    while (++c<channels);
   2f4dc:	f109 0901 	add.w	r9, r9, #1
   2f4e0:	45ce      	cmp	lr, r9
   2f4e2:	f108 0802 	add.w	r8, r8, #2
   2f4e6:	dcee      	bgt.n	2f4c6 <gain_fade+0x8e>
}
   2f4e8:	b003      	add	sp, #12
   2f4ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
       for (i=0;i<overlap;i++)
   2f4ee:	2c00      	cmp	r4, #0
   2f4f0:	dddf      	ble.n	2f4b2 <gain_fade+0x7a>
   2f4f2:	f1a0 0a02 	sub.w	sl, r0, #2
   2f4f6:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
          g = SHR32(MAC16_16(MULT16_16(w,g2),
   2f4fa:	9401      	str	r4, [sp, #4]
   2f4fc:	ea4f 0945 	mov.w	r9, r5, lsl #1
   2f500:	eb0a 0744 	add.w	r7, sl, r4, lsl #1
   2f504:	f1a1 0b02 	sub.w	fp, r1, #2
          w = MULT16_16_Q15(window[i*inc], window[i*inc]);
   2f508:	f9b8 4000 	ldrsh.w	r4, [r8]
          out[i] = MULT16_16_Q15(g, in[i]);
   2f50c:	f83a 5f02 	ldrh.w	r5, [sl, #2]!
          w = MULT16_16_Q15(window[i*inc], window[i*inc]);
   2f510:	fb04 f404 	mul.w	r4, r4, r4
   2f514:	13e4      	asrs	r4, r4, #15
          g = SHR32(MAC16_16(MULT16_16(w,g2),
   2f516:	f5c4 46ff 	rsb	r6, r4, #32640	; 0x7f80
   2f51a:	367f      	adds	r6, #127	; 0x7f
   2f51c:	fb16 f602 	smulbb	r6, r6, r2
   2f520:	fb14 6403 	smlabb	r4, r4, r3, r6
   2f524:	13e4      	asrs	r4, r4, #15
          out[i] = MULT16_16_Q15(g, in[i]);
   2f526:	fb15 f404 	smulbb	r4, r5, r4
   2f52a:	13e4      	asrs	r4, r4, #15
       for (i=0;i<overlap;i++)
   2f52c:	4557      	cmp	r7, sl
   2f52e:	44c8      	add	r8, r9
          out[i] = MULT16_16_Q15(g, in[i]);
   2f530:	f82b 4f02 	strh.w	r4, [fp, #2]!
       for (i=0;i<overlap;i++)
   2f534:	d1e8      	bne.n	2f508 <gain_fade+0xd0>
   2f536:	9c01      	ldr	r4, [sp, #4]
   2f538:	e7bb      	b.n	2f4b2 <gain_fade+0x7a>
   2f53a:	bf00      	nop

0002f53c <downmix_int>:
   }
}
#endif

void downmix_int(const void *_x, opus_val32 *y, int subframe, int offset, int c1, int c2, int C)
{
   2f53c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   const opus_int16 *x;
   int j;

   x = (const opus_int16 *)_x;
   for (j=0;j<subframe;j++)
   2f540:	f1b2 0a00 	subs.w	sl, r2, #0
{
   2f544:	e9dd 9809 	ldrd	r9, r8, [sp, #36]	; 0x24
   for (j=0;j<subframe;j++)
   2f548:	dd23      	ble.n	2f592 <downmix_int+0x56>
   2f54a:	9a08      	ldr	r2, [sp, #32]
   2f54c:	fb03 f708 	mul.w	r7, r3, r8
   2f550:	1f0e      	subs	r6, r1, #4
   2f552:	19d5      	adds	r5, r2, r7
   2f554:	eb00 0545 	add.w	r5, r0, r5, lsl #1
   2f558:	eb06 0e8a 	add.w	lr, r6, sl, lsl #2
   2f55c:	4634      	mov	r4, r6
   2f55e:	ea4f 0c48 	mov.w	ip, r8, lsl #1
      y[j] = x[(j+offset)*C+c1];
   2f562:	f9b5 2000 	ldrsh.w	r2, [r5]
   2f566:	f844 2f04 	str.w	r2, [r4, #4]!
   for (j=0;j<subframe;j++)
   2f56a:	45a6      	cmp	lr, r4
   2f56c:	4465      	add	r5, ip
   2f56e:	d1f8      	bne.n	2f562 <downmix_int+0x26>
   if (c2>-1)
   2f570:	f1b9 0f00 	cmp.w	r9, #0
   2f574:	db10      	blt.n	2f598 <downmix_int+0x5c>
   2f576:	444f      	add	r7, r9
   2f578:	eb00 0047 	add.w	r0, r0, r7, lsl #1
   {
      for (j=0;j<subframe;j++)
         y[j] += x[(j+offset)*C+c2];
   2f57c:	f9b0 2000 	ldrsh.w	r2, [r0]
   2f580:	f856 3f04 	ldr.w	r3, [r6, #4]!
   2f584:	4413      	add	r3, r2
      for (j=0;j<subframe;j++)
   2f586:	42a6      	cmp	r6, r4
   2f588:	4460      	add	r0, ip
         y[j] += x[(j+offset)*C+c2];
   2f58a:	6033      	str	r3, [r6, #0]
      for (j=0;j<subframe;j++)
   2f58c:	d1f6      	bne.n	2f57c <downmix_int+0x40>
      {
         for (j=0;j<subframe;j++)
            y[j] += x[(j+offset)*C+c];
      }
   }
}
   2f58e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   if (c2>-1)
   2f592:	f1b9 0f00 	cmp.w	r9, #0
   2f596:	dafa      	bge.n	2f58e <downmix_int+0x52>
   } else if (c2==-2)
   2f598:	f119 0f02 	cmn.w	r9, #2
   2f59c:	d1f7      	bne.n	2f58e <downmix_int+0x52>
      for (c=1;c<C;c++)
   2f59e:	f1b8 0f01 	cmp.w	r8, #1
   2f5a2:	ddf4      	ble.n	2f58e <downmix_int+0x52>
   2f5a4:	f1ba 0f00 	cmp.w	sl, #0
   2f5a8:	ddf1      	ble.n	2f58e <downmix_int+0x52>
   2f5aa:	fb03 f308 	mul.w	r3, r3, r8
   2f5ae:	1c5e      	adds	r6, r3, #1
   2f5b0:	f1a1 0c04 	sub.w	ip, r1, #4
   2f5b4:	4443      	add	r3, r8
   2f5b6:	eb0c 058a 	add.w	r5, ip, sl, lsl #2
   2f5ba:	eb00 0646 	add.w	r6, r0, r6, lsl #1
   2f5be:	eb00 0743 	add.w	r7, r0, r3, lsl #1
   2f5c2:	ea4f 0448 	mov.w	r4, r8, lsl #1
   2f5c6:	4663      	mov	r3, ip
   for (j=0;j<subframe;j++)
   2f5c8:	4631      	mov	r1, r6
            y[j] += x[(j+offset)*C+c];
   2f5ca:	f9b1 0000 	ldrsh.w	r0, [r1]
   2f5ce:	f853 2f04 	ldr.w	r2, [r3, #4]!
   2f5d2:	4402      	add	r2, r0
         for (j=0;j<subframe;j++)
   2f5d4:	429d      	cmp	r5, r3
   2f5d6:	4421      	add	r1, r4
            y[j] += x[(j+offset)*C+c];
   2f5d8:	601a      	str	r2, [r3, #0]
         for (j=0;j<subframe;j++)
   2f5da:	d1f6      	bne.n	2f5ca <downmix_int+0x8e>
   2f5dc:	3602      	adds	r6, #2
      for (c=1;c<C;c++)
   2f5de:	42b7      	cmp	r7, r6
   2f5e0:	d1f1      	bne.n	2f5c6 <downmix_int+0x8a>
   2f5e2:	e7d4      	b.n	2f58e <downmix_int+0x52>

0002f5e4 <opus_encoder_create>:
{
   2f5e4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   if((Fs!=48000&&Fs!=24000&&Fs!=16000&&Fs!=12000&&Fs!=8000)||(channels!=1&&channels!=2)||
   2f5e8:	f64b 3480 	movw	r4, #48000	; 0xbb80
   2f5ec:	42a0      	cmp	r0, r4
{
   2f5ee:	b082      	sub	sp, #8
   if((Fs!=48000&&Fs!=24000&&Fs!=16000&&Fs!=12000&&Fs!=8000)||(channels!=1&&channels!=2)||
   2f5f0:	d016      	beq.n	2f620 <opus_encoder_create+0x3c>
   2f5f2:	f645 54c0 	movw	r4, #24000	; 0x5dc0
   2f5f6:	42a0      	cmp	r0, r4
   2f5f8:	d012      	beq.n	2f620 <opus_encoder_create+0x3c>
   2f5fa:	f5b0 5f7a 	cmp.w	r0, #16000	; 0x3e80
   2f5fe:	d00f      	beq.n	2f620 <opus_encoder_create+0x3c>
   2f600:	f642 64e0 	movw	r4, #12000	; 0x2ee0
   2f604:	42a0      	cmp	r0, r4
   2f606:	d00b      	beq.n	2f620 <opus_encoder_create+0x3c>
   2f608:	f5b0 5ffa 	cmp.w	r0, #8000	; 0x1f40
   2f60c:	d008      	beq.n	2f620 <opus_encoder_create+0x3c>
      if (error)
   2f60e:	b113      	cbz	r3, 2f616 <opus_encoder_create+0x32>
         *error = OPUS_BAD_ARG;
   2f610:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2f614:	601a      	str	r2, [r3, #0]
      return NULL;
   2f616:	2400      	movs	r4, #0
}
   2f618:	4620      	mov	r0, r4
   2f61a:	b002      	add	sp, #8
   2f61c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   if((Fs!=48000&&Fs!=24000&&Fs!=16000&&Fs!=12000&&Fs!=8000)||(channels!=1&&channels!=2)||
   2f620:	1e4c      	subs	r4, r1, #1
   2f622:	2c01      	cmp	r4, #1
   2f624:	d8f3      	bhi.n	2f60e <opus_encoder_create+0x2a>
       (application != OPUS_APPLICATION_VOIP && application != OPUS_APPLICATION_AUDIO
   2f626:	f5a2 6700 	sub.w	r7, r2, #2048	; 0x800
   if((Fs!=48000&&Fs!=24000&&Fs!=16000&&Fs!=12000&&Fs!=8000)||(channels!=1&&channels!=2)||
   2f62a:	2f01      	cmp	r7, #1
   2f62c:	d903      	bls.n	2f636 <opus_encoder_create+0x52>
       && application != OPUS_APPLICATION_RESTRICTED_LOWDELAY))
   2f62e:	f640 0403 	movw	r4, #2051	; 0x803
   2f632:	42a2      	cmp	r2, r4
   2f634:	d1eb      	bne.n	2f60e <opus_encoder_create+0x2a>
   2f636:	4681      	mov	r9, r0
    ret = silk_Get_Encoder_Size( &silkEncSizeBytes );
   2f638:	a801      	add	r0, sp, #4
   2f63a:	461d      	mov	r5, r3
   2f63c:	4690      	mov	r8, r2
   2f63e:	460e      	mov	r6, r1
   2f640:	f7de fd5e 	bl	e100 <silk_Get_Encoder_Size>
    if (ret)
   2f644:	2800      	cmp	r0, #0
   2f646:	f000 80d3 	beq.w	2f7f0 <opus_encoder_create+0x20c>
   2f64a:	2000      	movs	r0, #0

/** Opus wrapper for malloc(). To do your own dynamic allocation, all you need to do is replace this function and opus_free */
#ifndef OVERRIDE_OPUS_ALLOC
static OPUS_INLINE void *opus_alloc (size_t size)
{
   return malloc(size);
   2f64c:	f005 fa72 	bl	34b34 <malloc>
   if (st == NULL)
   2f650:	4604      	mov	r4, r0
   2f652:	2800      	cmp	r0, #0
   2f654:	f000 80c5 	beq.w	2f7e2 <opus_encoder_create+0x1fe>
   if((Fs!=48000&&Fs!=24000&&Fs!=16000&&Fs!=12000&&Fs!=8000)||(channels!=1&&channels!=2)||
   2f658:	f64b 3380 	movw	r3, #48000	; 0xbb80
   2f65c:	4599      	cmp	r9, r3
   2f65e:	d00e      	beq.n	2f67e <opus_encoder_create+0x9a>
   2f660:	f645 53c0 	movw	r3, #24000	; 0x5dc0
   2f664:	4599      	cmp	r9, r3
   2f666:	d00a      	beq.n	2f67e <opus_encoder_create+0x9a>
   2f668:	f5b9 5f7a 	cmp.w	r9, #16000	; 0x3e80
   2f66c:	d007      	beq.n	2f67e <opus_encoder_create+0x9a>
   2f66e:	f642 63e0 	movw	r3, #12000	; 0x2ee0
   2f672:	4599      	cmp	r9, r3
   2f674:	d003      	beq.n	2f67e <opus_encoder_create+0x9a>
   2f676:	f5b9 5ffa 	cmp.w	r9, #8000	; 0x1f40
   2f67a:	f040 80d3 	bne.w	2f824 <opus_encoder_create+0x240>
   2f67e:	2f01      	cmp	r7, #1
   2f680:	d904      	bls.n	2f68c <opus_encoder_create+0xa8>
        && application != OPUS_APPLICATION_RESTRICTED_LOWDELAY))
   2f682:	f640 0303 	movw	r3, #2051	; 0x803
   2f686:	4598      	cmp	r8, r3
   2f688:	f040 80cc 	bne.w	2f824 <opus_encoder_create+0x240>
    ret = silk_Get_Encoder_Size( &silkEncSizeBytes );
   2f68c:	a801      	add	r0, sp, #4
   2f68e:	f7de fd37 	bl	e100 <silk_Get_Encoder_Size>
    if (ret)
   2f692:	2800      	cmp	r0, #0
   2f694:	f000 80b9 	beq.w	2f80a <opus_encoder_create+0x226>
   2f698:	2200      	movs	r2, #0
    OPUS_CLEAR((char*)st, opus_encoder_get_size(channels));
   2f69a:	2100      	movs	r1, #0
   2f69c:	4620      	mov	r0, r4
   2f69e:	f005 fd61 	bl	35164 <memset>
    ret = silk_Get_Encoder_Size( &silkEncSizeBytes );
   2f6a2:	a801      	add	r0, sp, #4
   2f6a4:	f7de fd2c 	bl	e100 <silk_Get_Encoder_Size>
    if (ret)
   2f6a8:	2800      	cmp	r0, #0
   2f6aa:	f040 80bb 	bne.w	2f824 <opus_encoder_create+0x240>

    unsigned int alignment = offsetof(struct foo, u);

    /* Optimizing compilers should optimize div and multiply into and
       for all sensible alignment values. */
    return ((i + alignment - 1) / alignment) * alignment;
   2f6ae:	9b01      	ldr	r3, [sp, #4]
    st->arch = opus_select_arch();
   2f6b0:	f8c4 00b4 	str.w	r0, [r4, #180]	; 0xb4
   2f6b4:	3303      	adds	r3, #3
   2f6b6:	f023 0303 	bic.w	r3, r3, #3
    st->celt_enc_offset = st->silk_enc_offset+silkEncSizeBytes;
   2f6ba:	f603 0798 	addw	r7, r3, #2200	; 0x898
    st->silk_enc_offset = align(sizeof(OpusEncoder));
   2f6be:	f640 0298 	movw	r2, #2200	; 0x898
   2f6c2:	e9c4 7200 	strd	r7, r2, [r4]
    ret = silk_InitEncoder( silk_enc, st->arch, &st->silk_mode );
   2f6c6:	4601      	mov	r1, r0
    st->stream_channels = st->channels = channels;
   2f6c8:	6726      	str	r6, [r4, #112]	; 0x70
   2f6ca:	f8c4 60bc 	str.w	r6, [r4, #188]	; 0xbc
    st->Fs = Fs;
   2f6ce:	f8c4 9090 	str.w	r9, [r4, #144]	; 0x90
    ret = silk_InitEncoder( silk_enc, st->arch, &st->silk_mode );
   2f6d2:	f104 0208 	add.w	r2, r4, #8
   2f6d6:	f604 0098 	addw	r0, r4, #2200	; 0x898
    silkEncSizeBytes = align(silkEncSizeBytes);
   2f6da:	9301      	str	r3, [sp, #4]
    celt_enc = (CELTEncoder*)((char*)st+st->celt_enc_offset);
   2f6dc:	4427      	add	r7, r4
    ret = silk_InitEncoder( silk_enc, st->arch, &st->silk_mode );
   2f6de:	f7de fd15 	bl	e10c <silk_InitEncoder>
    if(ret)return OPUS_INTERNAL_ERROR;
   2f6e2:	2800      	cmp	r0, #0
   2f6e4:	f040 80a7 	bne.w	2f836 <opus_encoder_create+0x252>
    st->silk_mode.API_sampleRate            = st->Fs;
   2f6e8:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
   2f6ec:	6122      	str	r2, [r4, #16]
    st->silk_mode.maxInternalSampleRate     = 16000;
   2f6ee:	f44f 537a 	mov.w	r3, #16000	; 0x3e80
    st->silk_mode.minInternalSampleRate     = 8000;
   2f6f2:	f44f 5efa 	mov.w	lr, #8000	; 0x1f40
    st->silk_mode.payloadSize_ms            = 20;
   2f6f6:	f04f 0c14 	mov.w	ip, #20
    st->silk_mode.bitRate                   = 25000;
   2f6fa:	f246 11a8 	movw	r1, #25000	; 0x61a8
    st->silk_mode.complexity                = 9;
   2f6fe:	2209      	movs	r2, #9
    st->silk_mode.packetLossPercentage      = 0;
   2f700:	62a0      	str	r0, [r4, #40]	; 0x28
    st->silk_mode.useInBandFEC              = 0;
   2f702:	6320      	str	r0, [r4, #48]	; 0x30
    st->silk_mode.useCBR                    = 0;
   2f704:	e9c4 000e 	strd	r0, r0, [r4, #56]	; 0x38
    st->silk_mode.reducedDependency         = 0;
   2f708:	64e0      	str	r0, [r4, #76]	; 0x4c
    st->silk_mode.maxInternalSampleRate     = 16000;
   2f70a:	6163      	str	r3, [r4, #20]
    st->silk_mode.minInternalSampleRate     = 8000;
   2f70c:	e9c4 e306 	strd	lr, r3, [r4, #24]
    st->silk_mode.bitRate                   = 25000;
   2f710:	e9c4 c108 	strd	ip, r1, [r4, #32]
    st->silk_mode.complexity                = 9;
   2f714:	62e2      	str	r2, [r4, #44]	; 0x2c
    st->silk_mode.nChannelsAPI              = channels;
   2f716:	60a6      	str	r6, [r4, #8]
    st->silk_mode.nChannelsInternal         = channels;
   2f718:	60e6      	str	r6, [r4, #12]
    err = celt_encoder_init(celt_enc, Fs, channels, st->arch);
   2f71a:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
   2f71e:	4632      	mov	r2, r6
   2f720:	4649      	mov	r1, r9
   2f722:	4638      	mov	r0, r7
   2f724:	f7f9 fd94 	bl	29250 <celt_encoder_init>
    if(err!=OPUS_OK)return OPUS_INTERNAL_ERROR;
   2f728:	4682      	mov	sl, r0
   2f72a:	2800      	cmp	r0, #0
   2f72c:	f040 8083 	bne.w	2f836 <opus_encoder_create+0x252>
    celt_encoder_ctl(celt_enc, CELT_SET_SIGNALLING(0));
   2f730:	4602      	mov	r2, r0
   2f732:	f242 7120 	movw	r1, #10016	; 0x2720
   2f736:	4638      	mov	r0, r7
   2f738:	f7f9 fbb8 	bl	28eac <opus_custom_encoder_ctl>
    celt_encoder_ctl(celt_enc, OPUS_SET_COMPLEXITY(st->silk_mode.complexity));
   2f73c:	4638      	mov	r0, r7
   2f73e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    st->delay_compensation = st->Fs/250;
   2f740:	4f40      	ldr	r7, [pc, #256]	; (2f844 <opus_encoder_create+0x260>)
    celt_encoder_ctl(celt_enc, OPUS_SET_COMPLEXITY(st->silk_mode.complexity));
   2f742:	f640 71aa 	movw	r1, #4010	; 0xfaa
   2f746:	f7f9 fbb1 	bl	28eac <opus_custom_encoder_ctl>
    st->encoder_buffer = st->Fs/100;
   2f74a:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
   2f74e:	4a3e      	ldr	r2, [pc, #248]	; (2f848 <opus_encoder_create+0x264>)
    st->user_bitrate_bps = OPUS_AUTO;
   2f750:	4b3e      	ldr	r3, [pc, #248]	; (2f84c <opus_encoder_create+0x268>)
    st->application = application;
   2f752:	f8c4 806c 	str.w	r8, [r4, #108]	; 0x6c
    st->bitrate_bps = 3000+Fs*channels;
   2f756:	fb06 f109 	mul.w	r1, r6, r9
    st->encoder_buffer = st->Fs/100;
   2f75a:	fb82 6200 	smull	r6, r2, r2, r0
   2f75e:	17c6      	asrs	r6, r0, #31
   2f760:	ebc6 1262 	rsb	r2, r6, r2, asr #5
    st->delay_compensation = st->Fs/250;
   2f764:	fb87 7000 	smull	r7, r0, r7, r0
    st->bitrate_bps = 3000+Fs*channels;
   2f768:	f601 31b8 	addw	r1, r1, #3000	; 0xbb8
    st->delay_compensation = st->Fs/250;
   2f76c:	ebc6 1020 	rsb	r0, r6, r0, asr #4
    st->max_bandwidth = OPUS_BANDWIDTH_FULLBAND;
   2f770:	f240 4751 	movw	r7, #1105	; 0x451
    st->use_vbr = 1;
   2f774:	2601      	movs	r6, #1
    st->lsb_depth = 24;
   2f776:	f04f 0e18 	mov.w	lr, #24
    st->bitrate_bps = 3000+Fs*channels;
   2f77a:	f8c4 10a0 	str.w	r1, [r4, #160]	; 0xa0
    st->variable_duration = OPUS_FRAMESIZE_ARG;
   2f77e:	f241 3c88 	movw	ip, #5000	; 0x1388
    st->encoder_buffer = st->Fs/100;
   2f782:	f8c4 20ac 	str.w	r2, [r4, #172]	; 0xac
    st->hybrid_stereo_width_Q14 = 1 << 14;
   2f786:	f44f 4180 	mov.w	r1, #16384	; 0x4000
    st->prev_HB_gain = Q15ONE;
   2f78a:	f647 72ff 	movw	r2, #32767	; 0x7fff
    st->voice_ratio = -1;
   2f78e:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
    st->delay_compensation = st->Fs/250;
   2f792:	6760      	str	r0, [r4, #116]	; 0x74
    st->user_bitrate_bps = OPUS_AUTO;
   2f794:	f8c4 30a4 	str.w	r3, [r4, #164]	; 0xa4
    st->user_bandwidth = OPUS_AUTO;
   2f798:	e9c4 331f 	strd	r3, r3, [r4, #124]	; 0x7c
    st->force_channels = OPUS_AUTO;
   2f79c:	67a3      	str	r3, [r4, #120]	; 0x78
    st->max_bandwidth = OPUS_BANDWIDTH_FULLBAND;
   2f79e:	e9c4 7321 	strd	r7, r3, [r4, #132]	; 0x84
    st->vbr_constraint = 1;
   2f7a2:	e9c4 6625 	strd	r6, r6, [r4, #148]	; 0x94
    st->voice_ratio = -1;
   2f7a6:	f8c4 808c 	str.w	r8, [r4, #140]	; 0x8c
    st->lsb_depth = 24;
   2f7aa:	f8c4 e0a8 	str.w	lr, [r4, #168]	; 0xa8
    st->variable_duration = OPUS_FRAMESIZE_ARG;
   2f7ae:	f8c4 c09c 	str.w	ip, [r4, #156]	; 0x9c
    st->hybrid_stereo_width_Q14 = 1 << 14;
   2f7b2:	f8a4 10c0 	strh.w	r1, [r4, #192]	; 0xc0
    st->prev_HB_gain = Q15ONE;
   2f7b6:	f8a4 20c8 	strh.w	r2, [r4, #200]	; 0xc8
    st->variable_HP_smth2_Q15 = silk_LSHIFT( silk_lin2log( VARIABLE_HP_MIN_CUTOFF_HZ ), 8 );
   2f7ba:	203c      	movs	r0, #60	; 0x3c
   2f7bc:	f7e8 f8fc 	bl	179b8 <silk_lin2log>
    st->mode = MODE_HYBRID;
   2f7c0:	f240 33e9 	movw	r3, #1001	; 0x3e9
    st->variable_HP_smth2_Q15 = silk_LSHIFT( silk_lin2log( VARIABLE_HP_MIN_CUTOFF_HZ ), 8 );
   2f7c4:	0200      	lsls	r0, r0, #8
   2f7c6:	f8c4 00c4 	str.w	r0, [r4, #196]	; 0xc4
    st->first = 1;
   2f7ca:	f8c4 60f8 	str.w	r6, [r4, #248]	; 0xf8
    st->bandwidth = OPUS_BANDWIDTH_FULLBAND;
   2f7ce:	f8c4 70ec 	str.w	r7, [r4, #236]	; 0xec
    st->mode = MODE_HYBRID;
   2f7d2:	f8c4 30dc 	str.w	r3, [r4, #220]	; 0xdc
   if (error)
   2f7d6:	2d00      	cmp	r5, #0
   2f7d8:	f43f af1e 	beq.w	2f618 <opus_encoder_create+0x34>
      *error = ret;
   2f7dc:	f8c5 a000 	str.w	sl, [r5]
   2f7e0:	e71a      	b.n	2f618 <opus_encoder_create+0x34>
      if (error)
   2f7e2:	2d00      	cmp	r5, #0
   2f7e4:	f43f af17 	beq.w	2f616 <opus_encoder_create+0x32>
         *error = OPUS_ALLOC_FAIL;
   2f7e8:	f06f 0306 	mvn.w	r3, #6
   2f7ec:	602b      	str	r3, [r5, #0]
   2f7ee:	e713      	b.n	2f618 <opus_encoder_create+0x34>
   2f7f0:	9b01      	ldr	r3, [sp, #4]
   2f7f2:	3303      	adds	r3, #3
   2f7f4:	f023 0303 	bic.w	r3, r3, #3
    celtEncSizeBytes = celt_encoder_get_size(channels);
   2f7f8:	4630      	mov	r0, r6
    silkEncSizeBytes = align(silkEncSizeBytes);
   2f7fa:	9301      	str	r3, [sp, #4]
    celtEncSizeBytes = celt_encoder_get_size(channels);
   2f7fc:	f7f5 fde6 	bl	253cc <celt_encoder_get_size>
    return align(sizeof(OpusEncoder))+silkEncSizeBytes+celtEncSizeBytes;
   2f800:	9b01      	ldr	r3, [sp, #4]
   2f802:	f603 0398 	addw	r3, r3, #2200	; 0x898
   2f806:	4418      	add	r0, r3
   2f808:	e720      	b.n	2f64c <opus_encoder_create+0x68>
   2f80a:	9b01      	ldr	r3, [sp, #4]
   2f80c:	3303      	adds	r3, #3
   2f80e:	f023 0303 	bic.w	r3, r3, #3
    celtEncSizeBytes = celt_encoder_get_size(channels);
   2f812:	4630      	mov	r0, r6
    silkEncSizeBytes = align(silkEncSizeBytes);
   2f814:	9301      	str	r3, [sp, #4]
    celtEncSizeBytes = celt_encoder_get_size(channels);
   2f816:	f7f5 fdd9 	bl	253cc <celt_encoder_get_size>
    return align(sizeof(OpusEncoder))+silkEncSizeBytes+celtEncSizeBytes;
   2f81a:	9a01      	ldr	r2, [sp, #4]
   2f81c:	f602 0298 	addw	r2, r2, #2200	; 0x898
   2f820:	4402      	add	r2, r0
   2f822:	e73a      	b.n	2f69a <opus_encoder_create+0xb6>
   if (error)
   2f824:	b115      	cbz	r5, 2f82c <opus_encoder_create+0x248>
      *error = ret;
   2f826:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2f82a:	602b      	str	r3, [r5, #0]

/** Opus wrapper for free(). To do your own dynamic allocation, all you need to do is replace this function and opus_alloc */
#ifndef OVERRIDE_OPUS_FREE
static OPUS_INLINE void opus_free (void *ptr)
{
   free(ptr);
   2f82c:	4620      	mov	r0, r4
   2f82e:	f005 f989 	bl	34b44 <free>
      st = NULL;
   2f832:	2400      	movs	r4, #0
   2f834:	e6f0      	b.n	2f618 <opus_encoder_create+0x34>
   if (error)
   2f836:	2d00      	cmp	r5, #0
   2f838:	d0f8      	beq.n	2f82c <opus_encoder_create+0x248>
      *error = ret;
   2f83a:	f06f 0302 	mvn.w	r3, #2
   2f83e:	602b      	str	r3, [r5, #0]
   2f840:	e7f4      	b.n	2f82c <opus_encoder_create+0x248>
   2f842:	bf00      	nop
   2f844:	10624dd3 	.word	0x10624dd3
   2f848:	51eb851f 	.word	0x51eb851f
   2f84c:	fffffc18 	.word	0xfffffc18

0002f850 <compute_stereo_width>:
      return -1;
   return new_size;
}

opus_val16 compute_stereo_width(const opus_val16 *pcm, int frame_size, opus_int32 Fs, StereoWidthState *mem)
{
   2f850:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   opus_val16 qrrt_xx, qrrt_yy;
   int frame_rate;
   int i;
   opus_val16 short_alpha;

   frame_rate = Fs/frame_size;
   2f854:	fb92 f4f1 	sdiv	r4, r2, r1
{
   2f858:	b083      	sub	sp, #12
   short_alpha = Q15ONE - MULT16_16(25, Q15ONE)/IMAX(50,frame_rate);
   2f85a:	2c31      	cmp	r4, #49	; 0x31
   frame_rate = Fs/frame_size;
   2f85c:	9401      	str	r4, [sp, #4]
   short_alpha = Q15ONE - MULT16_16(25, Q15ONE)/IMAX(50,frame_rate);
   2f85e:	f340 80a9 	ble.w	2f9b4 <compute_stereo_width+0x164>
   2f862:	4a81      	ldr	r2, [pc, #516]	; (2fa68 <compute_stereo_width+0x218>)
   2f864:	fb92 fbf4 	sdiv	fp, r2, r4
   2f868:	f50b 4bff 	add.w	fp, fp, #32640	; 0x7f80
   2f86c:	f10b 0b7f 	add.w	fp, fp, #127	; 0x7f
   xx=xy=yy=0;
   /* Unroll by 4. The frame size is always a multiple of 4 *except* for
      2.5 ms frames at 12 kHz. Since this setting is very rare (and very
      stupid), we just discard the last two samples. */
   for (i=0;i<frame_size-3;i+=4)
   2f870:	2903      	cmp	r1, #3
   2f872:	fa1f fb8b 	uxth.w	fp, fp
   2f876:	f340 80a2 	ble.w	2f9be <compute_stereo_width+0x16e>
   2f87a:	3904      	subs	r1, #4
   2f87c:	0889      	lsrs	r1, r1, #2
   2f87e:	f100 0210 	add.w	r2, r0, #16
   xx=xy=yy=0;
   2f882:	f04f 0800 	mov.w	r8, #0
   2f886:	eb02 1201 	add.w	r2, r2, r1, lsl #4
   2f88a:	46c2      	mov	sl, r8
   2f88c:	46c1      	mov	r9, r8
   2f88e:	f8cd b000 	str.w	fp, [sp]
   2f892:	4696      	mov	lr, r2
      x = pcm[2*i];
      y = pcm[2*i+1];
      pxx = SHR32(MULT16_16(x,x),2);
      pxy = SHR32(MULT16_16(x,y),2);
      pyy = SHR32(MULT16_16(y,y),2);
      x = pcm[2*i+2];
   2f894:	f9b0 6004 	ldrsh.w	r6, [r0, #4]
      y = pcm[2*i+3];
   2f898:	f9b0 5006 	ldrsh.w	r5, [r0, #6]
      x = pcm[2*i];
   2f89c:	f9b0 b000 	ldrsh.w	fp, [r0]
      y = pcm[2*i+1];
   2f8a0:	f9b0 2002 	ldrsh.w	r2, [r0, #2]
      pxx += SHR32(MULT16_16(x,x),2);
      pxy += SHR32(MULT16_16(x,y),2);
      pyy += SHR32(MULT16_16(y,y),2);
      x = pcm[2*i+4];
   2f8a4:	f9b0 1008 	ldrsh.w	r1, [r0, #8]
      y = pcm[2*i+5];
      pxx += SHR32(MULT16_16(x,x),2);
      pxy += SHR32(MULT16_16(x,y),2);
      pyy += SHR32(MULT16_16(y,y),2);
      x = pcm[2*i+6];
   2f8a8:	f9b0 700c 	ldrsh.w	r7, [r0, #12]
      pxx += SHR32(MULT16_16(x,x),2);
   2f8ac:	fb06 f406 	mul.w	r4, r6, r6
      pxy += SHR32(MULT16_16(x,y),2);
   2f8b0:	fb06 f605 	mul.w	r6, r6, r5
      pyy += SHR32(MULT16_16(y,y),2);
   2f8b4:	fb05 f505 	mul.w	r5, r5, r5
      pxx = SHR32(MULT16_16(x,x),2);
   2f8b8:	fb0b fc0b 	mul.w	ip, fp, fp
      pyy += SHR32(MULT16_16(y,y),2);
   2f8bc:	10ad      	asrs	r5, r5, #2
      pxy = SHR32(MULT16_16(x,y),2);
   2f8be:	fb0b fb02 	mul.w	fp, fp, r2
      pyy = SHR32(MULT16_16(y,y),2);
   2f8c2:	fb02 f202 	mul.w	r2, r2, r2
      pyy += SHR32(MULT16_16(y,y),2);
   2f8c6:	eb05 05a2 	add.w	r5, r5, r2, asr #2
      pxy += SHR32(MULT16_16(x,y),2);
   2f8ca:	10b6      	asrs	r6, r6, #2
      y = pcm[2*i+5];
   2f8cc:	f9b0 200a 	ldrsh.w	r2, [r0, #10]
      pxy += SHR32(MULT16_16(x,y),2);
   2f8d0:	eb06 06ab 	add.w	r6, r6, fp, asr #2
      pxx += SHR32(MULT16_16(x,x),2);
   2f8d4:	10a4      	asrs	r4, r4, #2
      y = pcm[2*i+7];
   2f8d6:	f9b0 b00e 	ldrsh.w	fp, [r0, #14]
      pxx += SHR32(MULT16_16(x,x),2);
   2f8da:	eb04 04ac 	add.w	r4, r4, ip, asr #2
      pxx += SHR32(MULT16_16(x,x),2);
   2f8de:	fb01 fc01 	mul.w	ip, r1, r1
      pxy += SHR32(MULT16_16(x,y),2);
   2f8e2:	fb01 f102 	mul.w	r1, r1, r2
      pyy += SHR32(MULT16_16(y,y),2);
   2f8e6:	fb02 f202 	mul.w	r2, r2, r2
      pxx += SHR32(MULT16_16(x,x),2);
   2f8ea:	eb04 04ac 	add.w	r4, r4, ip, asr #2
      pxy += SHR32(MULT16_16(x,y),2);
   2f8ee:	eb06 01a1 	add.w	r1, r6, r1, asr #2
      pxx += SHR32(MULT16_16(x,x),2);
   2f8f2:	fb07 fc07 	mul.w	ip, r7, r7
      pyy += SHR32(MULT16_16(y,y),2);
   2f8f6:	eb05 02a2 	add.w	r2, r5, r2, asr #2
      pxy += SHR32(MULT16_16(x,y),2);
   2f8fa:	fb07 f70b 	mul.w	r7, r7, fp
   2f8fe:	3010      	adds	r0, #16
      pyy += SHR32(MULT16_16(y,y),2);
   2f900:	fb0b fb0b 	mul.w	fp, fp, fp
      pxx += SHR32(MULT16_16(x,x),2);
   2f904:	eb04 04ac 	add.w	r4, r4, ip, asr #2
      pxy += SHR32(MULT16_16(x,y),2);
   2f908:	eb01 01a7 	add.w	r1, r1, r7, asr #2
      pyy += SHR32(MULT16_16(y,y),2);
   2f90c:	eb02 02ab 	add.w	r2, r2, fp, asr #2
   for (i=0;i<frame_size-3;i+=4)
   2f910:	4586      	cmp	lr, r0

      xx += SHR32(pxx, 10);
   2f912:	eb09 29a4 	add.w	r9, r9, r4, asr #10
      xy += SHR32(pxy, 10);
   2f916:	eb0a 2aa1 	add.w	sl, sl, r1, asr #10
      yy += SHR32(pyy, 10);
   2f91a:	eb08 28a2 	add.w	r8, r8, r2, asr #10
   for (i=0;i<frame_size-3;i+=4)
   2f91e:	d1b9      	bne.n	2f894 <compute_stereo_width+0x44>
   2f920:	f8dd b000 	ldr.w	fp, [sp]
   {
      xy = xx = yy = 0;
   }
#endif
   mem->XX += MULT16_32_Q15(short_alpha, xx-mem->XX);
   mem->XY += MULT16_32_Q15(short_alpha, xy-mem->XY);
   2f924:	e893 0013 	ldmia.w	r3, {r0, r1, r4}
   mem->XX += MULT16_32_Q15(short_alpha, xx-mem->XX);
   2f928:	eba9 0900 	sub.w	r9, r9, r0
   mem->YY += MULT16_32_Q15(short_alpha, yy-mem->YY);
   2f92c:	eba8 0804 	sub.w	r8, r8, r4
   mem->XX += MULT16_32_Q15(short_alpha, xx-mem->XX);
   2f930:	fa1f f289 	uxth.w	r2, r9
   mem->YY += MULT16_32_Q15(short_alpha, yy-mem->YY);
   2f934:	fa1f f588 	uxth.w	r5, r8
   mem->XX += MULT16_32_Q15(short_alpha, xx-mem->XX);
   2f938:	fb0b f202 	mul.w	r2, fp, r2
   mem->YY += MULT16_32_Q15(short_alpha, yy-mem->YY);
   2f93c:	fb0b f505 	mul.w	r5, fp, r5
   mem->XX += MULT16_32_Q15(short_alpha, xx-mem->XX);
   2f940:	ea4f 4929 	mov.w	r9, r9, asr #16
   mem->YY += MULT16_32_Q15(short_alpha, yy-mem->YY);
   2f944:	ea4f 4828 	mov.w	r8, r8, asr #16
   mem->XY += MULT16_32_Q15(short_alpha, xy-mem->XY);
   2f948:	ebaa 0a01 	sub.w	sl, sl, r1
   mem->XX += MULT16_32_Q15(short_alpha, xx-mem->XX);
   2f94c:	13d2      	asrs	r2, r2, #15
   2f94e:	fb0b f909 	mul.w	r9, fp, r9
   mem->YY += MULT16_32_Q15(short_alpha, yy-mem->YY);
   2f952:	fb0b f808 	mul.w	r8, fp, r8
   2f956:	13ed      	asrs	r5, r5, #15
   mem->XX += MULT16_32_Q15(short_alpha, xx-mem->XX);
   2f958:	eb02 0949 	add.w	r9, r2, r9, lsl #1
   mem->YY += MULT16_32_Q15(short_alpha, yy-mem->YY);
   2f95c:	eb05 0548 	add.w	r5, r5, r8, lsl #1
   mem->XY += MULT16_32_Q15(short_alpha, xy-mem->XY);
   2f960:	fa1f f28a 	uxth.w	r2, sl
   2f964:	fb0b f202 	mul.w	r2, fp, r2
   2f968:	ea4f 4a2a 	mov.w	sl, sl, asr #16
   mem->XX += MULT16_32_Q15(short_alpha, xx-mem->XX);
   2f96c:	4448      	add	r0, r9
   mem->YY += MULT16_32_Q15(short_alpha, yy-mem->YY);
   2f96e:	442c      	add	r4, r5
   mem->XX = MAX32(0, mem->XX);
   2f970:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   mem->XY = MAX32(0, mem->XY);
   mem->YY = MAX32(0, mem->YY);
   2f974:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
   mem->XY += MULT16_32_Q15(short_alpha, xy-mem->XY);
   2f978:	13d2      	asrs	r2, r2, #15
   2f97a:	fb0b fb0a 	mul.w	fp, fp, sl
   if (MAX32(mem->XX, mem->YY)>QCONST16(8e-4f, 18))
   2f97e:	42a0      	cmp	r0, r4
   mem->XY += MULT16_32_Q15(short_alpha, xy-mem->XY);
   2f980:	eb02 024b 	add.w	r2, r2, fp, lsl #1
   2f984:	440a      	add	r2, r1
   if (MAX32(mem->XX, mem->YY)>QCONST16(8e-4f, 18))
   2f986:	4601      	mov	r1, r0
   2f988:	bfb8      	it	lt
   2f98a:	4621      	movlt	r1, r4
   mem->XY = MAX32(0, mem->XY);
   2f98c:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
   if (MAX32(mem->XX, mem->YY)>QCONST16(8e-4f, 18))
   2f990:	29d2      	cmp	r1, #210	; 0xd2
   mem->XY = MAX32(0, mem->XY);
   2f992:	e883 0015 	stmia.w	r3, {r0, r2, r4}
   if (MAX32(mem->XX, mem->YY)>QCONST16(8e-4f, 18))
   2f996:	dc17      	bgt.n	2f9c8 <compute_stereo_width+0x178>
   2f998:	f9b3 000e 	ldrsh.w	r0, [r3, #14]
      mem->smoothed_width += (width-mem->smoothed_width)/frame_rate;
      /* Peak follower */
      mem->max_follower = MAX16(mem->max_follower-QCONST16(.02f,15)/frame_rate, mem->smoothed_width);
   }
   /*printf("%f %f %f %f %f ", corr/(float)Q15ONE, ldiff/(float)Q15ONE, width/(float)Q15ONE, mem->smoothed_width/(float)Q15ONE, mem->max_follower/(float)Q15ONE);*/
   return EXTRACT16(MIN32(Q15ONE, MULT16_16(20, mem->max_follower)));
   2f99c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   2f9a0:	0080      	lsls	r0, r0, #2
   2f9a2:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
   2f9a6:	bfb4      	ite	lt
   2f9a8:	b200      	sxthlt	r0, r0
   2f9aa:	f647 70ff 	movwge	r0, #32767	; 0x7fff
}
   2f9ae:	b003      	add	sp, #12
   2f9b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   for (i=0;i<frame_size-3;i+=4)
   2f9b4:	2903      	cmp	r1, #3
   2f9b6:	f44f 4b80 	mov.w	fp, #16384	; 0x4000
   2f9ba:	f73f af5e 	bgt.w	2f87a <compute_stereo_width+0x2a>
   xx=xy=yy=0;
   2f9be:	f04f 0800 	mov.w	r8, #0
   2f9c2:	46c2      	mov	sl, r8
   2f9c4:	46c1      	mov	r9, r8
   2f9c6:	e7ad      	b.n	2f924 <compute_stereo_width+0xd4>
   2f9c8:	461c      	mov	r4, r3
      sqrt_xx = celt_sqrt(mem->XX);
   2f9ca:	f7fb fd55 	bl	2b478 <celt_sqrt>
   2f9ce:	b205      	sxth	r5, r0
      sqrt_yy = celt_sqrt(mem->YY);
   2f9d0:	68a0      	ldr	r0, [r4, #8]
   2f9d2:	f7fb fd51 	bl	2b478 <celt_sqrt>
   2f9d6:	b207      	sxth	r7, r0
      qrrt_xx = celt_sqrt(sqrt_xx);
   2f9d8:	4628      	mov	r0, r5
   2f9da:	f7fb fd4d 	bl	2b478 <celt_sqrt>
   2f9de:	4606      	mov	r6, r0
      qrrt_yy = celt_sqrt(sqrt_yy);
   2f9e0:	4638      	mov	r0, r7
   2f9e2:	f7fb fd49 	bl	2b478 <celt_sqrt>
   2f9e6:	4680      	mov	r8, r0
      mem->XY = MIN32(mem->XY, sqrt_xx*sqrt_yy);
   2f9e8:	6860      	ldr	r0, [r4, #4]
   2f9ea:	fb05 f107 	mul.w	r1, r5, r7
   2f9ee:	4288      	cmp	r0, r1
   2f9f0:	bfa8      	it	ge
   2f9f2:	4608      	movge	r0, r1
   2f9f4:	6060      	str	r0, [r4, #4]
      corr = SHR32(frac_div32(mem->XY,EPSILON+MULT16_16(sqrt_xx,sqrt_yy)),16);
   2f9f6:	3101      	adds	r1, #1
   2f9f8:	f7fb fc84 	bl	2b304 <frac_div32>
      ldiff = MULT16_16(Q15ONE, ABS16(qrrt_xx-qrrt_yy))/(EPSILON+qrrt_xx+qrrt_yy);
   2f9fc:	b235      	sxth	r5, r6
   2f9fe:	fa0f f788 	sxth.w	r7, r8
   2fa02:	1beb      	subs	r3, r5, r7
   2fa04:	2b00      	cmp	r3, #0
      corr = SHR32(frac_div32(mem->XY,EPSILON+MULT16_16(sqrt_xx,sqrt_yy)),16);
   2fa06:	ea4f 4020 	mov.w	r0, r0, asr #16
      ldiff = MULT16_16(Q15ONE, ABS16(qrrt_xx-qrrt_yy))/(EPSILON+qrrt_xx+qrrt_yy);
   2fa0a:	db27      	blt.n	2fa5c <compute_stereo_width+0x20c>
   2fa0c:	eba6 0608 	sub.w	r6, r6, r8
   2fa10:	b236      	sxth	r6, r6
   2fa12:	ebc6 36c6 	rsb	r6, r6, r6, lsl #15
      width = MULT16_16_Q15(celt_sqrt(QCONST32(1.f,30)-MULT16_16(corr,corr)), ldiff);
   2fa16:	fb00 f000 	mul.w	r0, r0, r0
   2fa1a:	f1c0 4080 	rsb	r0, r0, #1073741824	; 0x40000000
   2fa1e:	f7fb fd2b 	bl	2b478 <celt_sqrt>
      ldiff = MULT16_16(Q15ONE, ABS16(qrrt_xx-qrrt_yy))/(EPSILON+qrrt_xx+qrrt_yy);
   2fa22:	1c6a      	adds	r2, r5, #1
      mem->smoothed_width += (width-mem->smoothed_width)/frame_rate;
   2fa24:	f9b4 100c 	ldrsh.w	r1, [r4, #12]
      mem->max_follower = MAX16(mem->max_follower-QCONST16(.02f,15)/frame_rate, mem->smoothed_width);
   2fa28:	9d01      	ldr	r5, [sp, #4]
   2fa2a:	4b10      	ldr	r3, [pc, #64]	; (2fa6c <compute_stereo_width+0x21c>)
   2fa2c:	fb93 f3f5 	sdiv	r3, r3, r5
      ldiff = MULT16_16(Q15ONE, ABS16(qrrt_xx-qrrt_yy))/(EPSILON+qrrt_xx+qrrt_yy);
   2fa30:	443a      	add	r2, r7
   2fa32:	fb96 f2f2 	sdiv	r2, r6, r2
      width = MULT16_16_Q15(celt_sqrt(QCONST32(1.f,30)-MULT16_16(corr,corr)), ldiff);
   2fa36:	fb12 f200 	smulbb	r2, r2, r0
      mem->smoothed_width += (width-mem->smoothed_width)/frame_rate;
   2fa3a:	f342 32cf 	sbfx	r2, r2, #15, #16
      mem->max_follower = MAX16(mem->max_follower-QCONST16(.02f,15)/frame_rate, mem->smoothed_width);
   2fa3e:	f9b4 000e 	ldrsh.w	r0, [r4, #14]
      mem->smoothed_width += (width-mem->smoothed_width)/frame_rate;
   2fa42:	1a52      	subs	r2, r2, r1
   2fa44:	fb92 f2f5 	sdiv	r2, r2, r5
   2fa48:	440a      	add	r2, r1
   2fa4a:	b212      	sxth	r2, r2
      mem->max_follower = MAX16(mem->max_follower-QCONST16(.02f,15)/frame_rate, mem->smoothed_width);
   2fa4c:	4418      	add	r0, r3
   2fa4e:	4290      	cmp	r0, r2
   2fa50:	bfb8      	it	lt
   2fa52:	4610      	movlt	r0, r2
   2fa54:	b200      	sxth	r0, r0
      mem->smoothed_width += (width-mem->smoothed_width)/frame_rate;
   2fa56:	81a2      	strh	r2, [r4, #12]
      mem->max_follower = MAX16(mem->max_follower-QCONST16(.02f,15)/frame_rate, mem->smoothed_width);
   2fa58:	81e0      	strh	r0, [r4, #14]
   2fa5a:	e79f      	b.n	2f99c <compute_stereo_width+0x14c>
      ldiff = MULT16_16(Q15ONE, ABS16(qrrt_xx-qrrt_yy))/(EPSILON+qrrt_xx+qrrt_yy);
   2fa5c:	eba8 0606 	sub.w	r6, r8, r6
   2fa60:	b232      	sxth	r2, r6
   2fa62:	ebc2 36c2 	rsb	r6, r2, r2, lsl #15
   2fa66:	e7d6      	b.n	2fa16 <compute_stereo_width+0x1c6>
   2fa68:	fff38019 	.word	0xfff38019
   2fa6c:	fffffd71 	.word	0xfffffd71

0002fa70 <opus_encode_native>:

opus_int32 opus_encode_native(OpusEncoder *st, const opus_val16 *pcm, int frame_size,
                unsigned char *data, opus_int32 out_data_bytes, int lsb_depth,
                const void *analysis_pcm, opus_int32 analysis_size, int c1, int c2,
                int analysis_channels, downmix_func downmix, int float_api)
{
   2fa70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2fa74:	b0f9      	sub	sp, #484	; 0x1e4
   2fa76:	af0a      	add	r7, sp, #40	; 0x28
    int redundancy_bytes = 0; /* Number of bytes to use for redundancy frame */
    int celt_to_silk = 0;
    VARDECL(opus_val16, pcm_buf);
    int nb_compr_bytes;
    int to_celt = 0;
    opus_uint32 redundant_rng = 0;
   2fa78:	2400      	movs	r4, #0

    ALLOC_STACK;

    max_data_bytes = IMIN(1276, out_data_bytes);

    st->rangeFinal = 0;
   2fa7a:	f8c0 4894 	str.w	r4, [r0, #2196]	; 0x894
    opus_uint32 redundant_rng = 0;
   2fa7e:	673c      	str	r4, [r7, #112]	; 0x70
    max_data_bytes = IMIN(1276, out_data_bytes);
   2fa80:	f8d7 41e0 	ldr.w	r4, [r7, #480]	; 0x1e0
   2fa84:	f240 45fc 	movw	r5, #1276	; 0x4fc
   2fa88:	42ac      	cmp	r4, r5
   2fa8a:	bfa8      	it	ge
   2fa8c:	462c      	movge	r4, r5
    if (frame_size <= 0 || max_data_bytes <= 0)
   2fa8e:	f1b2 0900 	subs.w	r9, r2, #0
   2fa92:	f341 84f8 	ble.w	31486 <opus_encode_native+0x1a16>
   2fa96:	f8d7 21e0 	ldr.w	r2, [r7, #480]	; 0x1e0
   2fa9a:	2a00      	cmp	r2, #0
   2fa9c:	f341 84f3 	ble.w	31486 <opus_encode_native+0x1a16>
       RESTORE_STACK;
       return OPUS_BAD_ARG;
    }

    /* Cannot encode 100 ms in 1 byte */
    if (max_data_bytes==1 && st->Fs==(frame_size*10))
   2faa0:	2a01      	cmp	r2, #1
   2faa2:	46a3      	mov	fp, r4
   2faa4:	f000 811a 	beq.w	2fcdc <opus_encode_native+0x26c>
    {
      RESTORE_STACK;
      return OPUS_BUFFER_TOO_SMALL;
    }

    silk_enc = (char*)st+st->silk_enc_offset;
   2faa8:	6842      	ldr	r2, [r0, #4]
    celt_enc = (CELTEncoder*)((char*)st+st->celt_enc_offset);
   2faaa:	6806      	ldr	r6, [r0, #0]
    if (st->application == OPUS_APPLICATION_RESTRICTED_LOWDELAY)
   2faac:	6ec5      	ldr	r5, [r0, #108]	; 0x6c
    silk_enc = (char*)st+st->silk_enc_offset;
   2faae:	663a      	str	r2, [r7, #96]	; 0x60
    if (st->application == OPUS_APPLICATION_RESTRICTED_LOWDELAY)
   2fab0:	f640 0203 	movw	r2, #2051	; 0x803
   2fab4:	4295      	cmp	r5, r2
   2fab6:	4680      	mov	r8, r0
    celt_enc = (CELTEncoder*)((char*)st+st->celt_enc_offset);
   2fab8:	eb00 0406 	add.w	r4, r0, r6
       delay_compensation = 0;
    else
       delay_compensation = st->delay_compensation;
   2fabc:	bf18      	it	ne
   2fabe:	6f42      	ldrne	r2, [r0, #116]	; 0x74
    celt_enc = (CELTEncoder*)((char*)st+st->celt_enc_offset);
   2fac0:	66fc      	str	r4, [r7, #108]	; 0x6c
       delay_compensation = 0;
   2fac2:	bf08      	it	eq
   2fac4:	2200      	moveq	r2, #0
   2fac6:	e9c7 1319 	strd	r1, r3, [r7, #100]	; 0x64
   2faca:	65fa      	str	r2, [r7, #92]	; 0x5c

    lsb_depth = IMIN(lsb_depth, st->lsb_depth);
   2facc:	f8d8 30a8 	ldr.w	r3, [r8, #168]	; 0xa8

    celt_encoder_ctl(celt_enc, CELT_GET_MODE(&celt_mode));
   2fad0:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
    lsb_depth = IMIN(lsb_depth, st->lsb_depth);
   2fad2:	65bb      	str	r3, [r7, #88]	; 0x58
    celt_encoder_ctl(celt_enc, CELT_GET_MODE(&celt_mode));
   2fad4:	f107 0274 	add.w	r2, r7, #116	; 0x74
   2fad8:	f242 711f 	movw	r1, #10015	; 0x271f
   2fadc:	f7f9 f9e6 	bl	28eac <opus_custom_encoder_ctl>
    }
#else
    st->voice_ratio = -1;
#endif

    if (st->channels==2 && st->force_channels!=1)
   2fae0:	f8d8 3070 	ldr.w	r3, [r8, #112]	; 0x70
    st->voice_ratio = -1;
   2fae4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    if (st->channels==2 && st->force_channels!=1)
   2fae8:	2b02      	cmp	r3, #2
    st->voice_ratio = -1;
   2faea:	f8c8 208c 	str.w	r2, [r8, #140]	; 0x8c
    if (st->channels==2 && st->force_channels!=1)
   2faee:	f000 8113 	beq.w	2fd18 <opus_encode_native+0x2a8>
   2faf2:	f8d8 4090 	ldr.w	r4, [r8, #144]	; 0x90
       stereo_width = compute_stereo_width(pcm, frame_size, st->Fs, &st->width_mem);
    else
       stereo_width = 0;
   2faf6:	2000      	movs	r0, #0
  if (st->user_bitrate_bps==OPUS_AUTO)
   2faf8:	f8d8 30a4 	ldr.w	r3, [r8, #164]	; 0xa4
   2fafc:	f513 7f7a 	cmn.w	r3, #1000	; 0x3e8
   2fb00:	f000 80f7 	beq.w	2fcf2 <opus_encode_native+0x282>
  else if (st->user_bitrate_bps==OPUS_BITRATE_MAX)
   2fb04:	1c5e      	adds	r6, r3, #1
   2fb06:	f000 80d9 	beq.w	2fcbc <opus_encode_native+0x24c>
    total_buffer = delay_compensation;
    st->bitrate_bps = user_bitrate_to_bitrate(st, frame_size, max_data_bytes);

    frame_rate = st->Fs/frame_size;
   2fb0a:	fb94 faf9 	sdiv	sl, r4, r9
    if (!st->use_vbr)
   2fb0e:	f8d8 2094 	ldr.w	r2, [r8, #148]	; 0x94
    st->bitrate_bps = user_bitrate_to_bitrate(st, frame_size, max_data_bytes);
   2fb12:	f8c8 30a0 	str.w	r3, [r8, #160]	; 0xa0
    if (!st->use_vbr)
   2fb16:	bb22      	cbnz	r2, 2fb62 <opus_encode_native+0xf2>
    {
       int cbrBytes;
       /* Multiply by 12 to make sure the division is exact. */
       int frame_rate12 = 12*st->Fs/frame_size;
       /* We need to make sure that "int" values always fit in 16 bits. */
       cbrBytes = IMIN( (12*st->bitrate_bps/8 + frame_rate12/2)/frame_rate12, max_data_bytes);
   2fb18:	eb03 0343 	add.w	r3, r3, r3, lsl #1
       int frame_rate12 = 12*st->Fs/frame_size;
   2fb1c:	eb04 0144 	add.w	r1, r4, r4, lsl #1
       cbrBytes = IMIN( (12*st->bitrate_bps/8 + frame_rate12/2)/frame_rate12, max_data_bytes);
   2fb20:	009b      	lsls	r3, r3, #2
       int frame_rate12 = 12*st->Fs/frame_size;
   2fb22:	ea4f 0181 	mov.w	r1, r1, lsl #2
   2fb26:	fb91 f1f9 	sdiv	r1, r1, r9
       cbrBytes = IMIN( (12*st->bitrate_bps/8 + frame_rate12/2)/frame_rate12, max_data_bytes);
   2fb2a:	eb01 75d1 	add.w	r5, r1, r1, lsr #31
   2fb2e:	bf48      	it	mi
   2fb30:	3307      	addmi	r3, #7
   2fb32:	106d      	asrs	r5, r5, #1
   2fb34:	eb05 05e3 	add.w	r5, r5, r3, asr #3
   2fb38:	fb95 f5f1 	sdiv	r5, r5, r1
   2fb3c:	455d      	cmp	r5, fp
   2fb3e:	bfa8      	it	ge
   2fb40:	465d      	movge	r5, fp
       st->bitrate_bps = cbrBytes*(opus_int32)frame_rate12*8/12;
   2fb42:	fb05 f101 	mul.w	r1, r5, r1
   2fb46:	4eca      	ldr	r6, [pc, #808]	; (2fe70 <opus_encode_native+0x400>)
   2fb48:	00c9      	lsls	r1, r1, #3
   2fb4a:	fb86 3601 	smull	r3, r6, r6, r1
       /* Make sure we provide at least one byte to avoid failing. */
       max_data_bytes = IMAX(1, cbrBytes);
   2fb4e:	2d01      	cmp	r5, #1
       st->bitrate_bps = cbrBytes*(opus_int32)frame_rate12*8/12;
   2fb50:	ea4f 71e1 	mov.w	r1, r1, asr #31
   2fb54:	ebc1 0366 	rsb	r3, r1, r6, asr #1
       max_data_bytes = IMAX(1, cbrBytes);
   2fb58:	bfb8      	it	lt
   2fb5a:	2501      	movlt	r5, #1
   2fb5c:	46ab      	mov	fp, r5
       st->bitrate_bps = cbrBytes*(opus_int32)frame_rate12*8/12;
   2fb5e:	f8c8 30a0 	str.w	r3, [r8, #160]	; 0xa0
    }
    if (max_data_bytes<3 || st->bitrate_bps < 3*frame_rate*8
   2fb62:	f1bb 0f02 	cmp.w	fp, #2
   2fb66:	dd11      	ble.n	2fb8c <opus_encode_native+0x11c>
   2fb68:	eb0a 014a 	add.w	r1, sl, sl, lsl #1
   2fb6c:	ebb3 0fc1 	cmp.w	r3, r1, lsl #3
   2fb70:	db0c      	blt.n	2fb8c <opus_encode_native+0x11c>
       || (frame_rate<50 && (max_data_bytes*frame_rate<300 || st->bitrate_bps < 2400)))
   2fb72:	f1ba 0f31 	cmp.w	sl, #49	; 0x31
   2fb76:	fb0a f10b 	mul.w	r1, sl, fp
   2fb7a:	f300 8108 	bgt.w	2fd8e <opus_encode_native+0x31e>
   2fb7e:	f5b1 7f96 	cmp.w	r1, #300	; 0x12c
   2fb82:	db03      	blt.n	2fb8c <opus_encode_native+0x11c>
   2fb84:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
   2fb88:	f280 87c4 	bge.w	30b14 <opus_encode_native+0x10a4>
    {
       /*If the space is too low to do something useful, emit 'PLC' frames.*/
       int tocmode = st->mode;
       int bw = st->bandwidth == 0 ? OPUS_BANDWIDTH_NARROWBAND : st->bandwidth;
   2fb8c:	f8d8 50ec 	ldr.w	r5, [r8, #236]	; 0xec
       int tocmode = st->mode;
   2fb90:	f8d8 60dc 	ldr.w	r6, [r8, #220]	; 0xdc
       int bw = st->bandwidth == 0 ? OPUS_BANDWIDTH_NARROWBAND : st->bandwidth;
   2fb94:	f240 434d 	movw	r3, #1101	; 0x44d
   2fb98:	2d00      	cmp	r5, #0
   2fb9a:	bf08      	it	eq
   2fb9c:	461d      	moveq	r5, r3
       int packet_code = 0;
       int num_multiframes = 0;

       if (tocmode==0)
   2fb9e:	b9f6      	cbnz	r6, 2fbde <opus_encode_native+0x16e>
          tocmode = MODE_SILK_ONLY;
       if (frame_rate>100)
   2fba0:	f1ba 0f64 	cmp.w	sl, #100	; 0x64
   2fba4:	f340 80c6 	ble.w	2fd34 <opus_encode_native+0x2c4>
   2fba8:	f8d8 30bc 	ldr.w	r3, [r8, #188]	; 0xbc
   2fbac:	4631      	mov	r1, r6
   2fbae:	4632      	mov	r2, r6
          }
       }

       if(tocmode==MODE_SILK_ONLY&&bw>OPUS_BANDWIDTH_WIDEBAND)
          bw=OPUS_BANDWIDTH_WIDEBAND;
       else if (tocmode==MODE_CELT_ONLY&&bw==OPUS_BANDWIDTH_MEDIUMBAND)
   2fbb0:	f240 4c4e 	movw	ip, #1102	; 0x44e
          bw=OPUS_BANDWIDTH_NARROWBAND;
   2fbb4:	f240 404d 	movw	r0, #1101	; 0x44d
   2fbb8:	4565      	cmp	r5, ip
   2fbba:	bf08      	it	eq
   2fbbc:	4605      	moveq	r5, r0
   while (framerate < 400)
   2fbbe:	f5ba 7fc8 	cmp.w	sl, #400	; 0x190
       else if (tocmode==MODE_HYBRID&&bw<=OPUS_BANDWIDTH_SUPERWIDEBAND)
          bw=OPUS_BANDWIDTH_SUPERWIDEBAND;

       data[0] = gen_toc(tocmode, frame_rate, bw, st->stream_channels);
   2fbc2:	461c      	mov	r4, r3
   while (framerate < 400)
   2fbc4:	f2c0 812f 	blt.w	2fe26 <opus_encode_native+0x3b6>
   2fbc8:	f06f 037f 	mvn.w	r3, #127	; 0x7f
       int tmp = bandwidth-OPUS_BANDWIDTH_MEDIUMBAND;
   2fbcc:	f2a5 454e 	subw	r5, r5, #1102	; 0x44e
       toc |= tmp << 5;
   2fbd0:	ea25 75e5 	bic.w	r5, r5, r5, asr #31
       toc |= period<<3;
   2fbd4:	ea43 1345 	orr.w	r3, r3, r5, lsl #5
   2fbd8:	b2db      	uxtb	r3, r3
   2fbda:	4630      	mov	r0, r6
   2fbdc:	e047      	b.n	2fc6e <opus_encode_native+0x1fe>
       if (frame_rate>100)
   2fbde:	f1ba 0f64 	cmp.w	sl, #100	; 0x64
   2fbe2:	f300 80a1 	bgt.w	2fd28 <opus_encode_native+0x2b8>
       if (frame_rate==25 && tocmode!=MODE_SILK_ONLY)
   2fbe6:	f1ba 0f19 	cmp.w	sl, #25
   2fbea:	f000 8120 	beq.w	2fe2e <opus_encode_native+0x3be>
       if (frame_rate<=16)
   2fbee:	f1ba 0f10 	cmp.w	sl, #16
   2fbf2:	f302 83bc 	bgt.w	3236e <opus_encode_native+0x28fe>
          if (out_data_bytes==1 || (tocmode==MODE_SILK_ONLY && frame_rate!=10))
   2fbf6:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
   2fbfa:	2b01      	cmp	r3, #1
   2fbfc:	f000 80a6 	beq.w	2fd4c <opus_encode_native+0x2dc>
   2fc00:	f5b6 7f7a 	cmp.w	r6, #1000	; 0x3e8
   2fc04:	f000 809e 	beq.w	2fd44 <opus_encode_native+0x2d4>
             num_multiframes = 50/frame_rate;
   2fc08:	2332      	movs	r3, #50	; 0x32
   2fc0a:	2203      	movs	r2, #3
   2fc0c:	fb93 f0fa 	sdiv	r0, r3, sl
             packet_code = 3;
   2fc10:	4611      	mov	r1, r2
             frame_rate = 50;
   2fc12:	469a      	mov	sl, r3
   2fc14:	f8d8 30bc 	ldr.w	r3, [r8, #188]	; 0xbc
       else if (tocmode==MODE_CELT_ONLY&&bw==OPUS_BANDWIDTH_MEDIUMBAND)
   2fc18:	f240 3cea 	movw	ip, #1002	; 0x3ea
   2fc1c:	4566      	cmp	r6, ip
   2fc1e:	461c      	mov	r4, r3
   2fc20:	f002 839a 	beq.w	32358 <opus_encode_native+0x28e8>
       else if (tocmode==MODE_HYBRID&&bw<=OPUS_BANDWIDTH_SUPERWIDEBAND)
   2fc24:	f240 33e9 	movw	r3, #1001	; 0x3e9
   2fc28:	429e      	cmp	r6, r3
   2fc2a:	d104      	bne.n	2fc36 <opus_encode_native+0x1c6>
   2fc2c:	f5b5 6f8a 	cmp.w	r5, #1104	; 0x450
   2fc30:	bfb8      	it	lt
   2fc32:	f44f 658a 	movlt.w	r5, #1104	; 0x450
       data[0] = gen_toc(tocmode, frame_rate, bw, st->stream_channels);
   2fc36:	2300      	movs	r3, #0
   2fc38:	e000      	b.n	2fc3c <opus_encode_native+0x1cc>
       period++;
   2fc3a:	4663      	mov	r3, ip
       framerate <<= 1;
   2fc3c:	ea4f 0a4a 	mov.w	sl, sl, lsl #1
   while (framerate < 400)
   2fc40:	f5ba 7fc8 	cmp.w	sl, #400	; 0x190
       period++;
   2fc44:	f103 0c01 	add.w	ip, r3, #1
   while (framerate < 400)
   2fc48:	dbf7      	blt.n	2fc3a <opus_encode_native+0x1ca>
   if (mode == MODE_SILK_ONLY)
   2fc4a:	f5b6 7f7a 	cmp.w	r6, #1000	; 0x3e8
   2fc4e:	f000 80ff 	beq.w	2fe50 <opus_encode_native+0x3e0>
   } else if (mode == MODE_CELT_ONLY)
   2fc52:	f240 3eea 	movw	lr, #1002	; 0x3ea
   2fc56:	4576      	cmp	r6, lr
   2fc58:	f000 8102 	beq.w	2fe60 <opus_encode_native+0x3f0>
       toc |= (period-2)<<3;
   2fc5c:	3b01      	subs	r3, #1
   2fc5e:	00db      	lsls	r3, r3, #3
       toc |= (bandwidth-OPUS_BANDWIDTH_SUPERWIDEBAND)<<4;
   2fc60:	f5a5 658a 	sub.w	r5, r5, #1104	; 0x450
       toc |= (period-2)<<3;
   2fc64:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
   2fc68:	f043 0360 	orr.w	r3, r3, #96	; 0x60
   2fc6c:	b2db      	uxtb	r3, r3
   toc |= (channels==2)<<2;
   2fc6e:	2c02      	cmp	r4, #2
       data[0] |= packet_code;
   2fc70:	ea43 0302 	orr.w	r3, r3, r2
   toc |= (channels==2)<<2;
   2fc74:	bf14      	ite	ne
   2fc76:	2200      	movne	r2, #0
   2fc78:	2204      	moveq	r2, #4
       data[0] |= packet_code;
   2fc7a:	4313      	orrs	r3, r2
   2fc7c:	6eba      	ldr	r2, [r7, #104]	; 0x68

       ret = packet_code <= 1 ? 1 : 2;
   2fc7e:	2901      	cmp	r1, #1
       data[0] |= packet_code;
   2fc80:	7013      	strb	r3, [r2, #0]
       ret = packet_code <= 1 ? 1 : 2;
   2fc82:	f340 80de 	ble.w	2fe42 <opus_encode_native+0x3d2>

       max_data_bytes = IMAX(max_data_bytes, ret);
   2fc86:	f1bb 0f02 	cmp.w	fp, #2
   2fc8a:	bfb8      	it	lt
   2fc8c:	f04f 0b02 	movlt.w	fp, #2

       if (packet_code==3)
   2fc90:	2903      	cmp	r1, #3
          data[1] = num_multiframes;
   2fc92:	bf08      	it	eq
   2fc94:	7050      	strbeq	r0, [r2, #1]
       ret = packet_code <= 1 ? 1 : 2;
   2fc96:	2002      	movs	r0, #2

       if (!st->use_vbr)
   2fc98:	f8d8 3094 	ldr.w	r3, [r8, #148]	; 0x94
   2fc9c:	b94b      	cbnz	r3, 2fcb2 <opus_encode_native+0x242>
       {
          ret = opus_packet_pad(data, ret, max_data_bytes);
   2fc9e:	4601      	mov	r1, r0
   2fca0:	465a      	mov	r2, fp
   2fca2:	6eb8      	ldr	r0, [r7, #104]	; 0x68
   2fca4:	f003 fa2a 	bl	330fc <opus_packet_pad>
          if (ret == OPUS_OK)
   2fca8:	2800      	cmp	r0, #0
   2fcaa:	bf0c      	ite	eq
   2fcac:	4658      	moveq	r0, fp
   2fcae:	f06f 0002 	mvnne.w	r0, #2
       }
       ret = max_data_bytes;
    }
    RESTORE_STACK;
    return ret;
}
   2fcb2:	f507 77de 	add.w	r7, r7, #444	; 0x1bc
   2fcb6:	46bd      	mov	sp, r7
   2fcb8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (!st->use_vbr)
   2fcbc:	f8d8 2094 	ldr.w	r2, [r8, #148]	; 0x94
    frame_rate = st->Fs/frame_size;
   2fcc0:	fb94 faf9 	sdiv	sl, r4, r9
    return max_data_bytes*8*st->Fs/frame_size;
   2fcc4:	ea4f 03cb 	mov.w	r3, fp, lsl #3
   2fcc8:	fb04 f303 	mul.w	r3, r4, r3
   2fccc:	fb93 f3f9 	sdiv	r3, r3, r9
    st->bitrate_bps = user_bitrate_to_bitrate(st, frame_size, max_data_bytes);
   2fcd0:	f8c8 30a0 	str.w	r3, [r8, #160]	; 0xa0
    if (!st->use_vbr)
   2fcd4:	2a00      	cmp	r2, #0
   2fcd6:	f47f af44 	bne.w	2fb62 <opus_encode_native+0xf2>
   2fcda:	e71d      	b.n	2fb18 <opus_encode_native+0xa8>
    if (max_data_bytes==1 && st->Fs==(frame_size*10))
   2fcdc:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
   2fce0:	eb09 0489 	add.w	r4, r9, r9, lsl #2
   2fce4:	ebb2 0f44 	cmp.w	r2, r4, lsl #1
   2fce8:	f47f aede 	bne.w	2faa8 <opus_encode_native+0x38>
      return OPUS_BUFFER_TOO_SMALL;
   2fcec:	f06f 0001 	mvn.w	r0, #1
   2fcf0:	e7df      	b.n	2fcb2 <opus_encode_native+0x242>
    return 60*st->Fs/frame_size + st->Fs*st->channels;
   2fcf2:	f8d8 2070 	ldr.w	r2, [r8, #112]	; 0x70
    frame_rate = st->Fs/frame_size;
   2fcf6:	fb94 faf9 	sdiv	sl, r4, r9
    return 60*st->Fs/frame_size + st->Fs*st->channels;
   2fcfa:	ebc4 1304 	rsb	r3, r4, r4, lsl #4
   2fcfe:	009b      	lsls	r3, r3, #2
   2fd00:	fb93 f3f9 	sdiv	r3, r3, r9
   2fd04:	fb02 3304 	mla	r3, r2, r4, r3
    if (!st->use_vbr)
   2fd08:	f8d8 2094 	ldr.w	r2, [r8, #148]	; 0x94
    st->bitrate_bps = user_bitrate_to_bitrate(st, frame_size, max_data_bytes);
   2fd0c:	f8c8 30a0 	str.w	r3, [r8, #160]	; 0xa0
    if (!st->use_vbr)
   2fd10:	2a00      	cmp	r2, #0
   2fd12:	f47f af26 	bne.w	2fb62 <opus_encode_native+0xf2>
   2fd16:	e6ff      	b.n	2fb18 <opus_encode_native+0xa8>
    if (st->channels==2 && st->force_channels!=1)
   2fd18:	f8d8 3078 	ldr.w	r3, [r8, #120]	; 0x78
   2fd1c:	f8d8 4090 	ldr.w	r4, [r8, #144]	; 0x90
   2fd20:	2b01      	cmp	r3, #1
   2fd22:	d12a      	bne.n	2fd7a <opus_encode_native+0x30a>
       stereo_width = 0;
   2fd24:	2000      	movs	r0, #0
   2fd26:	e6e7      	b.n	2faf8 <opus_encode_native+0x88>
   2fd28:	2200      	movs	r2, #0
   2fd2a:	f8d8 30bc 	ldr.w	r3, [r8, #188]	; 0xbc
   2fd2e:	4611      	mov	r1, r2
   2fd30:	4616      	mov	r6, r2
   2fd32:	e73d      	b.n	2fbb0 <opus_encode_native+0x140>
       if (frame_rate<=16)
   2fd34:	f1ba 0f10 	cmp.w	sl, #16
   2fd38:	f300 86fd 	bgt.w	30b36 <opus_encode_native+0x10c6>
          if (out_data_bytes==1 || (tocmode==MODE_SILK_ONLY && frame_rate!=10))
   2fd3c:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
   2fd40:	2b01      	cmp	r3, #1
   2fd42:	d003      	beq.n	2fd4c <opus_encode_native+0x2dc>
   2fd44:	f1ba 0f0a 	cmp.w	sl, #10
   2fd48:	f000 8723 	beq.w	30b92 <opus_encode_native+0x1122>
   2fd4c:	f240 434f 	movw	r3, #1103	; 0x44f
   2fd50:	429d      	cmp	r5, r3
   2fd52:	bfa8      	it	ge
   2fd54:	461d      	movge	r5, r3
             packet_code = frame_rate <= 12;
   2fd56:	f1ba 0f0c 	cmp.w	sl, #12
   2fd5a:	bfd4      	ite	le
   2fd5c:	2101      	movle	r1, #1
   2fd5e:	2100      	movgt	r1, #0
       data[0] = gen_toc(tocmode, frame_rate, bw, st->stream_channels);
   2fd60:	f8d8 40bc 	ldr.w	r4, [r8, #188]	; 0xbc
   2fd64:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
       int num_multiframes = 0;
   2fd68:	f04f 0000 	mov.w	r0, #0
   2fd6c:	b24a      	sxtb	r2, r1
             frame_rate = frame_rate == 12 ? 25 : 16;
   2fd6e:	bf0c      	ite	eq
   2fd70:	f04f 0a19 	moveq.w	sl, #25
   2fd74:	f04f 0a10 	movne.w	sl, #16
   2fd78:	e75d      	b.n	2fc36 <opus_encode_native+0x1c6>
       stereo_width = compute_stereo_width(pcm, frame_size, st->Fs, &st->width_mem);
   2fd7a:	4622      	mov	r2, r4
   2fd7c:	f508 7380 	add.w	r3, r8, #256	; 0x100
   2fd80:	4649      	mov	r1, r9
   2fd82:	6e78      	ldr	r0, [r7, #100]	; 0x64
   2fd84:	f7ff fd64 	bl	2f850 <compute_stereo_width>
   2fd88:	f8d8 4090 	ldr.w	r4, [r8, #144]	; 0x90
   2fd8c:	e6b4      	b.n	2faf8 <opus_encode_native+0x88>
    equiv_rate = compute_equiv_rate(st->bitrate_bps, st->channels, st->Fs/frame_size,
   2fd8e:	f8d8 5070 	ldr.w	r5, [r8, #112]	; 0x70
   2fd92:	657d      	str	r5, [r7, #84]	; 0x54
   2fd94:	f8d8 502c 	ldr.w	r5, [r8, #44]	; 0x2c
   2fd98:	f8d8 6028 	ldr.w	r6, [r8, #40]	; 0x28
   2fd9c:	647d      	str	r5, [r7, #68]	; 0x44
    max_rate = frame_rate*max_data_bytes*8;
   2fd9e:	00c9      	lsls	r1, r1, #3
    equiv_rate = compute_equiv_rate(st->bitrate_bps, st->channels, st->Fs/frame_size,
   2fda0:	6d7d      	ldr	r5, [r7, #84]	; 0x54
   2fda2:	64be      	str	r6, [r7, #72]	; 0x48
   if (frame_rate > 50)
   2fda4:	f1ba 0f32 	cmp.w	sl, #50	; 0x32
    max_rate = frame_rate*max_data_bytes*8;
   2fda8:	62b9      	str	r1, [r7, #40]	; 0x28
    equiv_rate = compute_equiv_rate(st->bitrate_bps, st->channels, st->Fs/frame_size,
   2fdaa:	653d      	str	r5, [r7, #80]	; 0x50
   2fdac:	633e      	str	r6, [r7, #48]	; 0x30
   if (frame_rate > 50)
   2fdae:	f000 87b7 	beq.w	30d20 <opus_encode_native+0x12b0>
      equiv -= (40*channels+20)*(frame_rate - 50);
   2fdb2:	eb05 0585 	add.w	r5, r5, r5, lsl #2
   2fdb6:	00ed      	lsls	r5, r5, #3
   2fdb8:	3514      	adds	r5, #20
   2fdba:	f1aa 0132 	sub.w	r1, sl, #50	; 0x32
   2fdbe:	fb01 3515 	mls	r5, r1, r5, r3
   if (!vbr)
   2fdc2:	b932      	cbnz	r2, 2fdd2 <opus_encode_native+0x362>
      equiv -= equiv/12;
   2fdc4:	4e2a      	ldr	r6, [pc, #168]	; (2fe70 <opus_encode_native+0x400>)
   2fdc6:	17e9      	asrs	r1, r5, #31
   2fdc8:	fb86 c605 	smull	ip, r6, r6, r5
   2fdcc:	eba1 0166 	sub.w	r1, r1, r6, asr #1
   2fdd0:	440d      	add	r5, r1
      equiv -= equiv*loss/(12*loss + 20);
   2fdd2:	6cb9      	ldr	r1, [r7, #72]	; 0x48
    if (st->signal_type == OPUS_SIGNAL_VOICE)
   2fdd4:	f8d8 c07c 	ldr.w	ip, [r8, #124]	; 0x7c
   2fdd8:	f8d8 606c 	ldr.w	r6, [r8, #108]	; 0x6c
      equiv -= equiv*loss/(12*loss + 20);
   2fddc:	eb01 0141 	add.w	r1, r1, r1, lsl #1
   2fde0:	0089      	lsls	r1, r1, #2
   2fde2:	3114      	adds	r1, #20
   2fde4:	64f9      	str	r1, [r7, #76]	; 0x4c
   equiv = equiv * (90+complexity)/100;
   2fde6:	6c79      	ldr	r1, [r7, #68]	; 0x44
    if (st->signal_type == OPUS_SIGNAL_VOICE)
   2fde8:	f640 3eb9 	movw	lr, #3001	; 0xbb9
   equiv = equiv * (90+complexity)/100;
   2fdec:	315a      	adds	r1, #90	; 0x5a
    if (st->signal_type == OPUS_SIGNAL_VOICE)
   2fdee:	45f4      	cmp	ip, lr
   equiv = equiv * (90+complexity)/100;
   2fdf0:	6439      	str	r1, [r7, #64]	; 0x40
    if (st->signal_type == OPUS_SIGNAL_VOICE)
   2fdf2:	d03f      	beq.n	2fe74 <opus_encode_native+0x404>
    else if (st->signal_type == OPUS_SIGNAL_MUSIC)
   2fdf4:	f640 31ba 	movw	r1, #3002	; 0xbba
   2fdf8:	458c      	cmp	ip, r1
   2fdfa:	f001 8057 	beq.w	30eac <opus_encode_native+0x143c>
    else if (st->voice_ratio >= 0)
   2fdfe:	f8d8 108c 	ldr.w	r1, [r8, #140]	; 0x8c
   2fe02:	2900      	cmp	r1, #0
   2fe04:	f2c0 86df 	blt.w	30bc6 <opus_encode_native+0x1156>
       voice_est = st->voice_ratio*327>>8;
   2fe08:	f240 1c47 	movw	ip, #327	; 0x147
   2fe0c:	fb0c f101 	mul.w	r1, ip, r1
       if (st->application == OPUS_APPLICATION_AUDIO)
   2fe10:	f640 0c01 	movw	ip, #2049	; 0x801
       voice_est = st->voice_ratio*327>>8;
   2fe14:	1209      	asrs	r1, r1, #8
       if (st->application == OPUS_APPLICATION_AUDIO)
   2fe16:	4566      	cmp	r6, ip
       voice_est = st->voice_ratio*327>>8;
   2fe18:	63f9      	str	r1, [r7, #60]	; 0x3c
       if (st->application == OPUS_APPLICATION_AUDIO)
   2fe1a:	d12d      	bne.n	2fe78 <opus_encode_native+0x408>
          voice_est = IMIN(voice_est, 115);
   2fe1c:	2973      	cmp	r1, #115	; 0x73
   2fe1e:	bfa8      	it	ge
   2fe20:	2173      	movge	r1, #115	; 0x73
   2fe22:	63f9      	str	r1, [r7, #60]	; 0x3c
   2fe24:	e028      	b.n	2fe78 <opus_encode_native+0x408>
   while (framerate < 400)
   2fe26:	4630      	mov	r0, r6
   2fe28:	f240 36ea 	movw	r6, #1002	; 0x3ea
   2fe2c:	e703      	b.n	2fc36 <opus_encode_native+0x1c6>
       if (frame_rate==25 && tocmode!=MODE_SILK_ONLY)
   2fe2e:	f5b6 7f7a 	cmp.w	r6, #1000	; 0x3e8
   2fe32:	f002 8176 	beq.w	32122 <opus_encode_native+0x26b2>
   2fe36:	2201      	movs	r2, #1
          packet_code = 1;
   2fe38:	4611      	mov	r1, r2
       int num_multiframes = 0;
   2fe3a:	2000      	movs	r0, #0
          frame_rate = 50;
   2fe3c:	f04f 0a32 	mov.w	sl, #50	; 0x32
   2fe40:	e6e8      	b.n	2fc14 <opus_encode_native+0x1a4>
       max_data_bytes = IMAX(max_data_bytes, ret);
   2fe42:	f1bb 0f01 	cmp.w	fp, #1
   2fe46:	bfb8      	it	lt
   2fe48:	f04f 0b01 	movlt.w	fp, #1
       ret = packet_code <= 1 ? 1 : 2;
   2fe4c:	2001      	movs	r0, #1
   2fe4e:	e723      	b.n	2fc98 <opus_encode_native+0x228>
       toc = (bandwidth-OPUS_BANDWIDTH_NARROWBAND)<<5;
   2fe50:	3d4d      	subs	r5, #77	; 0x4d
   2fe52:	016d      	lsls	r5, r5, #5
       toc |= (period-2)<<3;
   2fe54:	3b01      	subs	r3, #1
   2fe56:	ea45 03c3 	orr.w	r3, r5, r3, lsl #3
   2fe5a:	f003 03f8 	and.w	r3, r3, #248	; 0xf8
   2fe5e:	e706      	b.n	2fc6e <opus_encode_native+0x1fe>
   2fe60:	ea4f 03cc 	mov.w	r3, ip, lsl #3
   2fe64:	f063 037f 	orn	r3, r3, #127	; 0x7f
   2fe68:	b25b      	sxtb	r3, r3
   } else if (mode == MODE_CELT_ONLY)
   2fe6a:	4606      	mov	r6, r0
   2fe6c:	e6ae      	b.n	2fbcc <opus_encode_native+0x15c>
   2fe6e:	bf00      	nop
   2fe70:	2aaaaaab 	.word	0x2aaaaaab
       voice_est = 127;
   2fe74:	217f      	movs	r1, #127	; 0x7f
   2fe76:	63f9      	str	r1, [r7, #60]	; 0x3c
    if (st->force_channels!=OPUS_AUTO && st->channels == 2)
   2fe78:	f8d8 1078 	ldr.w	r1, [r8, #120]	; 0x78
   2fe7c:	f511 7f7a 	cmn.w	r1, #1000	; 0x3e8
   2fe80:	f000 841f 	beq.w	306c2 <opus_encode_native+0xc52>
   2fe84:	6d7d      	ldr	r5, [r7, #84]	; 0x54
   2fe86:	2d02      	cmp	r5, #2
   2fe88:	f001 800b 	beq.w	30ea2 <opus_encode_native+0x1432>
          st->stream_channels = st->channels;
   2fe8c:	6d79      	ldr	r1, [r7, #84]	; 0x54
   2fe8e:	f8c8 10bc 	str.w	r1, [r8, #188]	; 0xbc
   if (frame_rate > 50)
   2fe92:	f1ba 0f32 	cmp.w	sl, #50	; 0x32
   2fe96:	f340 829e 	ble.w	303d6 <opus_encode_native+0x966>
      equiv -= (40*channels+20)*(frame_rate - 50);
   2fe9a:	6d39      	ldr	r1, [r7, #80]	; 0x50
   2fe9c:	eb01 0581 	add.w	r5, r1, r1, lsl #2
   2fea0:	00ed      	lsls	r5, r5, #3
   2fea2:	3514      	adds	r5, #20
   2fea4:	f1aa 0132 	sub.w	r1, sl, #50	; 0x32
   2fea8:	fb01 3515 	mls	r5, r1, r5, r3
   if (!vbr)
   2feac:	b93a      	cbnz	r2, 2febe <opus_encode_native+0x44e>
      equiv -= equiv/12;
   2feae:	f8df c378 	ldr.w	ip, [pc, #888]	; 30228 <opus_encode_native+0x7b8>
   2feb2:	17e9      	asrs	r1, r5, #31
   2feb4:	fb8c ec05 	smull	lr, ip, ip, r5
   2feb8:	eba1 016c 	sub.w	r1, r1, ip, asr #1
   2febc:	440d      	add	r5, r1
    if (st->application == OPUS_APPLICATION_RESTRICTED_LOWDELAY)
   2febe:	f640 0103 	movw	r1, #2051	; 0x803
   2fec2:	428e      	cmp	r6, r1
   2fec4:	f000 83f6 	beq.w	306b4 <opus_encode_native+0xc44>
    } else if (st->user_forced_mode == OPUS_AUTO)
   2fec8:	f8d8 1088 	ldr.w	r1, [r8, #136]	; 0x88
   2fecc:	f511 7f7a 	cmn.w	r1, #1000	; 0x3e8
   2fed0:	f000 8766 	beq.w	30da0 <opus_encode_native+0x1330>
   2fed4:	f8d8 00e0 	ldr.w	r0, [r8, #224]	; 0xe0
       st->mode = st->user_forced_mode;
   2fed8:	f8c8 10dc 	str.w	r1, [r8, #220]	; 0xdc
    if (st->mode != MODE_CELT_ONLY && frame_size < st->Fs/100)
   2fedc:	f240 35ea 	movw	r5, #1002	; 0x3ea
   2fee0:	42a9      	cmp	r1, r5
   2fee2:	d008      	beq.n	2fef6 <opus_encode_native+0x486>
   2fee4:	4ecf      	ldr	r6, [pc, #828]	; (30224 <opus_encode_native+0x7b4>)
   2fee6:	17e1      	asrs	r1, r4, #31
   2fee8:	fb86 c604 	smull	ip, r6, r6, r4
   2feec:	ebc1 1166 	rsb	r1, r1, r6, asr #5
   2fef0:	4549      	cmp	r1, r9
   2fef2:	f300 824c 	bgt.w	3038e <opus_encode_native+0x91e>
   2fef6:	4686      	mov	lr, r0
    if (st->lfe)
   2fef8:	f8d8 10b0 	ldr.w	r1, [r8, #176]	; 0xb0
   2fefc:	6379      	str	r1, [r7, #52]	; 0x34
   2fefe:	2900      	cmp	r1, #0
   2ff00:	f000 8253 	beq.w	303aa <opus_encode_native+0x93a>
       st->mode = MODE_CELT_ONLY;
   2ff04:	f240 35ea 	movw	r5, #1002	; 0x3ea
    if (st->prev_mode > 0 &&
   2ff08:	f1be 0f00 	cmp.w	lr, #0
       st->mode = MODE_CELT_ONLY;
   2ff0c:	f8c8 50dc 	str.w	r5, [r8, #220]	; 0xdc
    if (st->prev_mode > 0 &&
   2ff10:	f300 85dc 	bgt.w	30acc <opus_encode_native+0x105c>
    int to_celt = 0;
   2ff14:	2100      	movs	r1, #0
   2ff16:	6379      	str	r1, [r7, #52]	; 0x34
   2ff18:	64fd      	str	r5, [r7, #76]	; 0x4c
        celt_to_silk = (st->mode != MODE_CELT_ONLY);
   2ff1a:	6139      	str	r1, [r7, #16]
                redundancy=0;
   2ff1c:	62f9      	str	r1, [r7, #44]	; 0x2c
   2ff1e:	2002      	movs	r0, #2
    if (st->stream_channels == 1 && st->prev_channels ==2 && st->silk_mode.toMono==0
   2ff20:	6d39      	ldr	r1, [r7, #80]	; 0x50
   2ff22:	2901      	cmp	r1, #1
   2ff24:	f000 83ae 	beq.w	30684 <opus_encode_native+0xc14>
       st->silk_mode.toMono = 0;
   2ff28:	2100      	movs	r1, #0
   if (frame_rate > 50)
   2ff2a:	f1ba 0f32 	cmp.w	sl, #50	; 0x32
   2ff2e:	f8c8 1044 	str.w	r1, [r8, #68]	; 0x44
   2ff32:	dd08      	ble.n	2ff46 <opus_encode_native+0x4d6>
      equiv -= (40*channels+20)*(frame_rate - 50);
   2ff34:	6d39      	ldr	r1, [r7, #80]	; 0x50
   2ff36:	eb01 0181 	add.w	r1, r1, r1, lsl #2
   2ff3a:	00c9      	lsls	r1, r1, #3
   2ff3c:	3114      	adds	r1, #20
   2ff3e:	f1aa 0532 	sub.w	r5, sl, #50	; 0x32
   2ff42:	fb05 3311 	mls	r3, r5, r1, r3
   if (!vbr)
   2ff46:	b932      	cbnz	r2, 2ff56 <opus_encode_native+0x4e6>
      equiv -= equiv/12;
   2ff48:	49b7      	ldr	r1, [pc, #732]	; (30228 <opus_encode_native+0x7b8>)
   2ff4a:	17da      	asrs	r2, r3, #31
   2ff4c:	fb81 5103 	smull	r5, r1, r1, r3
   2ff50:	eba2 0261 	sub.w	r2, r2, r1, asr #1
   2ff54:	4413      	add	r3, r2
   equiv = equiv * (90+complexity)/100;
   2ff56:	6c39      	ldr	r1, [r7, #64]	; 0x40
   2ff58:	4ab2      	ldr	r2, [pc, #712]	; (30224 <opus_encode_native+0x7b4>)
   2ff5a:	fb01 f103 	mul.w	r1, r1, r3
   2ff5e:	460b      	mov	r3, r1
   2ff60:	fb82 1203 	smull	r1, r2, r2, r3
    silk_enc = (char*)st+st->silk_enc_offset;
   2ff64:	6e39      	ldr	r1, [r7, #96]	; 0x60
   equiv = equiv * (90+complexity)/100;
   2ff66:	17db      	asrs	r3, r3, #31
    silk_enc = (char*)st+st->silk_enc_offset;
   2ff68:	4441      	add	r1, r8
   equiv = equiv * (90+complexity)/100;
   2ff6a:	ebc3 1362 	rsb	r3, r3, r2, asr #5
   if (mode == MODE_SILK_ONLY || mode == MODE_HYBRID)
   2ff6e:	2801      	cmp	r0, #1
    silk_enc = (char*)st+st->silk_enc_offset;
   2ff70:	61b9      	str	r1, [r7, #24]
   equiv = equiv * (90+complexity)/100;
   2ff72:	653b      	str	r3, [r7, #80]	; 0x50
   if (mode == MODE_SILK_ONLY || mode == MODE_HYBRID)
   2ff74:	f240 8277 	bls.w	30466 <opus_encode_native+0x9f6>
   } else if (mode == MODE_CELT_ONLY) {
   2ff78:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   2ff7a:	f240 33ea 	movw	r3, #1002	; 0x3ea
   2ff7e:	429a      	cmp	r2, r3
   2ff80:	f001 8256 	beq.w	31430 <opus_encode_native+0x19c0>
      equiv -= equiv*loss/(12*loss + 20);
   2ff84:	6cb9      	ldr	r1, [r7, #72]	; 0x48
   2ff86:	6d38      	ldr	r0, [r7, #80]	; 0x50
   2ff88:	eb01 0241 	add.w	r2, r1, r1, lsl #1
   2ff8c:	0092      	lsls	r2, r2, #2
   2ff8e:	3214      	adds	r2, #20
   2ff90:	fb01 f100 	mul.w	r1, r1, r0
    if (st->mode != MODE_CELT_ONLY && st->prev_mode == MODE_CELT_ONLY)
   2ff94:	459e      	cmp	lr, r3
      equiv -= equiv*loss/(12*loss + 20);
   2ff96:	fb91 f2f2 	sdiv	r2, r1, r2
   2ff9a:	eba0 0202 	sub.w	r2, r0, r2
   2ff9e:	653a      	str	r2, [r7, #80]	; 0x50
    if (st->mode != MODE_CELT_ONLY && st->prev_mode == MODE_CELT_ONLY)
   2ffa0:	f000 8664 	beq.w	30c6c <opus_encode_native+0x11fc>
   2ffa4:	f8d8 30f8 	ldr.w	r3, [r8, #248]	; 0xf8
   2ffa8:	64bb      	str	r3, [r7, #72]	; 0x48
    int prefill=0;
   2ffaa:	2300      	movs	r3, #0
   2ffac:	617b      	str	r3, [r7, #20]
   2ffae:	f107 038c 	add.w	r3, r7, #140	; 0x8c
   2ffb2:	663b      	str	r3, [r7, #96]	; 0x60
    if (st->mode == MODE_CELT_ONLY || st->first || st->silk_mode.allowBandwidthSwitch)
   2ffb4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   2ffb6:	b923      	cbnz	r3, 2ffc2 <opus_encode_native+0x552>
   2ffb8:	f8d8 3054 	ldr.w	r3, [r8, #84]	; 0x54
   2ffbc:	2b00      	cmp	r3, #0
   2ffbe:	f000 85c8 	beq.w	30b52 <opus_encode_native+0x10e2>
   2ffc2:	f8d8 3070 	ldr.w	r3, [r8, #112]	; 0x70
   2ffc6:	657b      	str	r3, [r7, #84]	; 0x54
        if (st->channels==2 && st->force_channels!=1)
   2ffc8:	2b02      	cmp	r3, #2
   2ffca:	f000 86ac 	beq.w	30d26 <opus_encode_native+0x12b6>
           music_bandwidth_thresholds = mono_music_bandwidth_thresholds;
   2ffce:	f8df e260 	ldr.w	lr, [pc, #608]	; 30230 <opus_encode_native+0x7c0>
           voice_bandwidth_thresholds = mono_voice_bandwidth_thresholds;
   2ffd2:	f8df c260 	ldr.w	ip, [pc, #608]	; 30234 <opus_encode_native+0x7c4>
           bandwidth_thresholds[i] = music_bandwidth_thresholds[i]
   2ffd6:	f8de 2010 	ldr.w	r2, [lr, #16]
   2ffda:	647a      	str	r2, [r7, #68]	; 0x44
                    + ((voice_est*voice_est*(voice_bandwidth_thresholds[i]-music_bandwidth_thresholds[i]))>>14);
   2ffdc:	e9dc 6500 	ldrd	r6, r5, [ip]
   2ffe0:	f8de 2000 	ldr.w	r2, [lr]
           bandwidth_thresholds[i] = music_bandwidth_thresholds[i]
   2ffe4:	f8de 3008 	ldr.w	r3, [lr, #8]
                    + ((voice_est*voice_est*(voice_bandwidth_thresholds[i]-music_bandwidth_thresholds[i]))>>14);
   2ffe8:	f8dc 000c 	ldr.w	r0, [ip, #12]
           bandwidth_thresholds[i] = music_bandwidth_thresholds[i]
   2ffec:	63bb      	str	r3, [r7, #56]	; 0x38
                    + ((voice_est*voice_est*(voice_bandwidth_thresholds[i]-music_bandwidth_thresholds[i]))>>14);
   2ffee:	1ab6      	subs	r6, r6, r2
   2fff0:	f8de 2004 	ldr.w	r2, [lr, #4]
   2fff4:	6238      	str	r0, [r7, #32]
   2fff6:	1aad      	subs	r5, r5, r2
   2fff8:	f8dc 0008 	ldr.w	r0, [ip, #8]
   2fffc:	6bba      	ldr	r2, [r7, #56]	; 0x38
           bandwidth_thresholds[i] = music_bandwidth_thresholds[i]
   2fffe:	f8de 100c 	ldr.w	r1, [lr, #12]
   30002:	6439      	str	r1, [r7, #64]	; 0x40
                    + ((voice_est*voice_est*(voice_bandwidth_thresholds[i]-music_bandwidth_thresholds[i]))>>14);
   30004:	1a82      	subs	r2, r0, r2
   30006:	627a      	str	r2, [r7, #36]	; 0x24
   30008:	6a38      	ldr	r0, [r7, #32]
   3000a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
           bandwidth_thresholds[i] = music_bandwidth_thresholds[i]
   3000c:	f8de 3014 	ldr.w	r3, [lr, #20]
                    + ((voice_est*voice_est*(voice_bandwidth_thresholds[i]-music_bandwidth_thresholds[i]))>>14);
   30010:	f8dc 1010 	ldr.w	r1, [ip, #16]
           bandwidth_thresholds[i] = music_bandwidth_thresholds[i]
   30014:	657b      	str	r3, [r7, #84]	; 0x54
                    + ((voice_est*voice_est*(voice_bandwidth_thresholds[i]-music_bandwidth_thresholds[i]))>>14);
   30016:	1a80      	subs	r0, r0, r2
   30018:	f8dc 3014 	ldr.w	r3, [ip, #20]
   3001c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   3001e:	61fb      	str	r3, [r7, #28]
   30020:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   30022:	1a8a      	subs	r2, r1, r2
   30024:	fb03 f303 	mul.w	r3, r3, r3
   30028:	623a      	str	r2, [r7, #32]
   3002a:	69f9      	ldr	r1, [r7, #28]
   3002c:	6d7a      	ldr	r2, [r7, #84]	; 0x54
   3002e:	fb03 f505 	mul.w	r5, r3, r5
   30032:	1a8a      	subs	r2, r1, r2
   30034:	63fd      	str	r5, [r7, #60]	; 0x3c
   30036:	6a39      	ldr	r1, [r7, #32]
   30038:	6a7d      	ldr	r5, [r7, #36]	; 0x24
   3003a:	fb03 f101 	mul.w	r1, r3, r1
   3003e:	fb03 f505 	mul.w	r5, r3, r5
   30042:	6239      	str	r1, [r7, #32]
   30044:	627d      	str	r5, [r7, #36]	; 0x24
   30046:	f8de 5000 	ldr.w	r5, [lr]
   3004a:	fb03 f606 	mul.w	r6, r3, r6
   3004e:	eb05 36a6 	add.w	r6, r5, r6, asr #14
   30052:	61fe      	str	r6, [r7, #28]
   30054:	6bfd      	ldr	r5, [r7, #60]	; 0x3c
   30056:	f8de 6004 	ldr.w	r6, [lr, #4]
   3005a:	eb06 36a5 	add.w	r6, r6, r5, asr #14
   3005e:	60fe      	str	r6, [r7, #12]
   30060:	e9dc 5c06 	ldrd	r5, ip, [ip, #24]
           bandwidth_thresholds[i] = music_bandwidth_thresholds[i]
   30064:	e9de 6e06 	ldrd	r6, lr, [lr, #24]
                    + ((voice_est*voice_est*(voice_bandwidth_thresholds[i]-music_bandwidth_thresholds[i]))>>14);
   30068:	1bad      	subs	r5, r5, r6
   3006a:	ebac 0c0e 	sub.w	ip, ip, lr
   3006e:	fb03 f000 	mul.w	r0, r3, r0
   30072:	fb03 f202 	mul.w	r2, r3, r2
   30076:	fb03 f505 	mul.w	r5, r3, r5
   3007a:	fb03 fc0c 	mul.w	ip, r3, ip
   3007e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   30080:	4619      	mov	r1, r3
   30082:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   30084:	eb01 33a3 	add.w	r3, r1, r3, asr #14
   30088:	63fb      	str	r3, [r7, #60]	; 0x3c
   3008a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   3008c:	eb03 30a0 	add.w	r0, r3, r0, asr #14
   30090:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   30092:	4619      	mov	r1, r3
   30094:	6a3b      	ldr	r3, [r7, #32]
   30096:	eb01 31a3 	add.w	r1, r1, r3, asr #14
   3009a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   3009c:	eb03 32a2 	add.w	r2, r3, r2, asr #14
   300a0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   300a2:	eb06 35a5 	add.w	r5, r6, r5, asr #14
   300a6:	eb0e 3cac 	add.w	ip, lr, ip, asr #14
   300aa:	2b00      	cmp	r3, #0
   300ac:	f000 8195 	beq.w	303da <opus_encode_native+0x96a>
            if (equiv_rate >= threshold)
   300b0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   300b2:	42ab      	cmp	r3, r5
   300b4:	f281 87a9 	bge.w	3200a <opus_encode_native+0x259a>
   300b8:	428b      	cmp	r3, r1
   300ba:	f281 85fd 	bge.w	31cb8 <opus_encode_native+0x2248>
   300be:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
   300c0:	428b      	cmp	r3, r1
   300c2:	f280 81b4 	bge.w	3042e <opus_encode_native+0x9be>
   300c6:	69fa      	ldr	r2, [r7, #28]
   300c8:	4293      	cmp	r3, r2
   300ca:	f280 81b0 	bge.w	3042e <opus_encode_native+0x9be>
        st->bandwidth = st->auto_bandwidth = bandwidth;
   300ce:	f240 424d 	movw	r2, #1101	; 0x44d
   300d2:	e9c8 223b 	strd	r2, r2, [r8, #236]	; 0xec
    if (st->bandwidth>st->max_bandwidth)
   300d6:	f8d8 3084 	ldr.w	r3, [r8, #132]	; 0x84
   300da:	4293      	cmp	r3, r2
       st->bandwidth = st->max_bandwidth;
   300dc:	bfb8      	it	lt
   300de:	f8c8 30ec 	strlt.w	r3, [r8, #236]	; 0xec
    if (st->user_bandwidth != OPUS_AUTO)
   300e2:	f8d8 3080 	ldr.w	r3, [r8, #128]	; 0x80
    if (st->mode != MODE_CELT_ONLY && max_rate < 15000)
   300e6:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
    if (st->user_bandwidth != OPUS_AUTO)
   300e8:	f513 7f7a 	cmn.w	r3, #1000	; 0x3e8
        st->bandwidth = st->user_bandwidth;
   300ec:	bf18      	it	ne
   300ee:	f8c8 30ec 	strne.w	r3, [r8, #236]	; 0xec
    if (st->mode != MODE_CELT_ONLY && max_rate < 15000)
   300f2:	f240 33ea 	movw	r3, #1002	; 0x3ea
   300f6:	429a      	cmp	r2, r3
   300f8:	d00d      	beq.n	30116 <opus_encode_native+0x6a6>
   300fa:	6aba      	ldr	r2, [r7, #40]	; 0x28
   300fc:	f643 2397 	movw	r3, #14999	; 0x3a97
   30100:	429a      	cmp	r2, r3
   30102:	dc08      	bgt.n	30116 <opus_encode_native+0x6a6>
       st->bandwidth = IMIN(st->bandwidth, OPUS_BANDWIDTH_WIDEBAND);
   30104:	f8d8 30ec 	ldr.w	r3, [r8, #236]	; 0xec
   30108:	f240 424f 	movw	r2, #1103	; 0x44f
   3010c:	4293      	cmp	r3, r2
   3010e:	bfa8      	it	ge
   30110:	4613      	movge	r3, r2
   30112:	f8c8 30ec 	str.w	r3, [r8, #236]	; 0xec
    if (st->Fs <= 24000 && st->bandwidth > OPUS_BANDWIDTH_SUPERWIDEBAND)
   30116:	f645 53c0 	movw	r3, #24000	; 0x5dc0
   3011a:	429c      	cmp	r4, r3
   3011c:	dc20      	bgt.n	30160 <opus_encode_native+0x6f0>
   3011e:	f8d8 30ec 	ldr.w	r3, [r8, #236]	; 0xec
   30122:	f5b3 6f8a 	cmp.w	r3, #1104	; 0x450
   30126:	f300 84a9 	bgt.w	30a7c <opus_encode_native+0x100c>
    if (st->Fs <= 16000 && st->bandwidth > OPUS_BANDWIDTH_WIDEBAND)
   3012a:	f5b4 5f7a 	cmp.w	r4, #16000	; 0x3e80
   3012e:	dc17      	bgt.n	30160 <opus_encode_native+0x6f0>
   30130:	f5b3 6f8a 	cmp.w	r3, #1104	; 0x450
   30134:	f000 84aa 	beq.w	30a8c <opus_encode_native+0x101c>
    if (st->Fs <= 12000 && st->bandwidth > OPUS_BANDWIDTH_MEDIUMBAND)
   30138:	f642 62e0 	movw	r2, #12000	; 0x2ee0
   3013c:	4294      	cmp	r4, r2
   3013e:	dc0f      	bgt.n	30160 <opus_encode_native+0x6f0>
   30140:	f240 424f 	movw	r2, #1103	; 0x44f
   30144:	4293      	cmp	r3, r2
   30146:	f000 84aa 	beq.w	30a9e <opus_encode_native+0x102e>
    if (st->Fs <= 8000 && st->bandwidth > OPUS_BANDWIDTH_NARROWBAND)
   3014a:	f5b4 5ffa 	cmp.w	r4, #8000	; 0x1f40
   3014e:	dc07      	bgt.n	30160 <opus_encode_native+0x6f0>
   30150:	f240 424e 	movw	r2, #1102	; 0x44e
   30154:	4293      	cmp	r3, r2
   30156:	d103      	bne.n	30160 <opus_encode_native+0x6f0>
        st->bandwidth = OPUS_BANDWIDTH_NARROWBAND;
   30158:	f240 434d 	movw	r3, #1101	; 0x44d
   3015c:	f8c8 30ec 	str.w	r3, [r8, #236]	; 0xec
    st->silk_mode.LBRR_coded = decide_fec(st->silk_mode.useInBandFEC, st->silk_mode.packetLossPercentage,
   30160:	f8d8 3030 	ldr.w	r3, [r8, #48]	; 0x30
   if (!useInBandFEC || PacketLoss_perc == 0 || mode == MODE_CELT_ONLY)
   30164:	2b00      	cmp	r3, #0
   30166:	f000 80c2 	beq.w	302ee <opus_encode_native+0x87e>
   3016a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   3016c:	2a00      	cmp	r2, #0
   3016e:	f000 84a0 	beq.w	30ab2 <opus_encode_native+0x1042>
   30172:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
   30174:	f240 33ea 	movw	r3, #1002	; 0x3ea
   30178:	4299      	cmp	r1, r3
   3017a:	f001 8303 	beq.w	31784 <opus_encode_native+0x1d14>
    st->silk_mode.LBRR_coded = decide_fec(st->silk_mode.useInBandFEC, st->silk_mode.packetLossPercentage,
   3017e:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
   orig_bandwidth = *bandwidth;
   30182:	f8d8 10ec 	ldr.w	r1, [r8, #236]	; 0xec
   30186:	64f9      	str	r1, [r7, #76]	; 0x4c
   30188:	2a19      	cmp	r2, #25
   3018a:	bfa8      	it	ge
   3018c:	2219      	movge	r2, #25
   3018e:	2b01      	cmp	r3, #1
   30190:	f1c2 0c7d 	rsb	ip, r2, #125	; 0x7d
   30194:	f001 849d 	beq.w	31ad2 <opus_encode_native+0x2062>
   30198:	2b00      	cmp	r3, #0
   3019a:	f041 86a7 	bne.w	31eec <opus_encode_native+0x247c>
   3019e:	460d      	mov	r5, r1
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   301a0:	f2a1 414d 	subw	r1, r1, #1101	; 0x44d
   301a4:	0049      	lsls	r1, r1, #1
      hysteresis = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND) + 1];
   301a6:	1c4a      	adds	r2, r1, #1
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   301a8:	4820      	ldr	r0, [pc, #128]	; (3022c <opus_encode_native+0x7bc>)
   301aa:	6578      	str	r0, [r7, #84]	; 0x54
      if (last_fec == 0) LBRR_rate_thres_bps += hysteresis;
   301ac:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   301b0:	4a1e      	ldr	r2, [pc, #120]	; (3022c <opus_encode_native+0x7bc>)
      if (rate > LBRR_rate_thres_bps)
   301b2:	6d3e      	ldr	r6, [r7, #80]	; 0x50
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   301b4:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
      if (last_fec == 0) LBRR_rate_thres_bps += hysteresis;
   301b8:	4402      	add	r2, r0
      LBRR_rate_thres_bps = silk_SMULWB( silk_MUL( LBRR_rate_thres_bps,
   301ba:	fb0c f202 	mul.w	r2, ip, r2
   301be:	b294      	uxth	r4, r2
   301c0:	f240 208f 	movw	r0, #655	; 0x28f
   301c4:	1412      	asrs	r2, r2, #16
   301c6:	fb00 f404 	mul.w	r4, r0, r4
   301ca:	fb00 f202 	mul.w	r2, r0, r2
   301ce:	eb02 4214 	add.w	r2, r2, r4, lsr #16
      if (rate > LBRR_rate_thres_bps)
   301d2:	4296      	cmp	r6, r2
   301d4:	f301 8705 	bgt.w	31fe2 <opus_encode_native+0x2572>
      else if (PacketLoss_perc <= 5)
   301d8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   301da:	2a05      	cmp	r2, #5
   301dc:	f340 8087 	ble.w	302ee <opus_encode_native+0x87e>
      else if (*bandwidth > OPUS_BANDWIDTH_NARROWBAND)
   301e0:	f240 444d 	movw	r4, #1101	; 0x44d
   301e4:	42a5      	cmp	r5, r4
   301e6:	dd7e      	ble.n	302e6 <opus_encode_native+0x876>
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   301e8:	4a10      	ldr	r2, [pc, #64]	; (3022c <opus_encode_native+0x7bc>)
   301ea:	1e8b      	subs	r3, r1, #2
      hysteresis = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND) + 1];
   301ec:	f101 3eff 	add.w	lr, r1, #4294967295	; 0xffffffff
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   301f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
      if (last_fec == 0) LBRR_rate_thres_bps += hysteresis;
   301f4:	f852 202e 	ldr.w	r2, [r2, lr, lsl #2]
   301f8:	4413      	add	r3, r2
      LBRR_rate_thres_bps = silk_SMULWB( silk_MUL( LBRR_rate_thres_bps,
   301fa:	fb0c f303 	mul.w	r3, ip, r3
   301fe:	b29a      	uxth	r2, r3
   30200:	141b      	asrs	r3, r3, #16
   30202:	fb00 f303 	mul.w	r3, r0, r3
   30206:	fb00 f202 	mul.w	r2, r0, r2
   3020a:	eb03 4212 	add.w	r2, r3, r2, lsr #16
      if (rate > LBRR_rate_thres_bps)
   3020e:	4296      	cmp	r6, r2
         (*bandwidth)--;
   30210:	f105 33ff 	add.w	r3, r5, #4294967295	; 0xffffffff
   30214:	f8c8 30ec 	str.w	r3, [r8, #236]	; 0xec
      if (rate > LBRR_rate_thres_bps)
   30218:	f301 86e3 	bgt.w	31fe2 <opus_encode_native+0x2572>
      else if (*bandwidth > OPUS_BANDWIDTH_NARROWBAND)
   3021c:	42a3      	cmp	r3, r4
   3021e:	d062      	beq.n	302e6 <opus_encode_native+0x876>
   30220:	e00a      	b.n	30238 <opus_encode_native+0x7c8>
   30222:	bf00      	nop
   30224:	51eb851f 	.word	0x51eb851f
   30228:	2aaaaaab 	.word	0x2aaaaaab
   3022c:	0003b5d0 	.word	0x0003b5d0
   30230:	0003b5f8 	.word	0x0003b5f8
   30234:	0003b618 	.word	0x0003b618
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   30238:	489d      	ldr	r0, [pc, #628]	; (304b0 <opus_encode_native+0xa40>)
   3023a:	1f0b      	subs	r3, r1, #4
      hysteresis = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND) + 1];
   3023c:	1eca      	subs	r2, r1, #3
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   3023e:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
      if (last_fec == 0) LBRR_rate_thres_bps += hysteresis;
   30242:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
   30246:	4413      	add	r3, r2
      LBRR_rate_thres_bps = silk_SMULWB( silk_MUL( LBRR_rate_thres_bps,
   30248:	fb0c f303 	mul.w	r3, ip, r3
   3024c:	b298      	uxth	r0, r3
   3024e:	f240 228f 	movw	r2, #655	; 0x28f
   30252:	141b      	asrs	r3, r3, #16
   30254:	fb02 f000 	mul.w	r0, r2, r0
   30258:	fb02 f303 	mul.w	r3, r2, r3
   3025c:	eb03 4310 	add.w	r3, r3, r0, lsr #16
      if (rate > LBRR_rate_thres_bps)
   30260:	429e      	cmp	r6, r3
         (*bandwidth)--;
   30262:	f1a5 0002 	sub.w	r0, r5, #2
   30266:	f8c8 00ec 	str.w	r0, [r8, #236]	; 0xec
      if (rate > LBRR_rate_thres_bps)
   3026a:	f301 86ba 	bgt.w	31fe2 <opus_encode_native+0x2572>
      else if (*bandwidth > OPUS_BANDWIDTH_NARROWBAND)
   3026e:	f240 444d 	movw	r4, #1101	; 0x44d
   30272:	42a0      	cmp	r0, r4
   30274:	d037      	beq.n	302e6 <opus_encode_native+0x876>
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   30276:	488e      	ldr	r0, [pc, #568]	; (304b0 <opus_encode_native+0xa40>)
   30278:	1f8b      	subs	r3, r1, #6
      hysteresis = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND) + 1];
   3027a:	f1a1 0e05 	sub.w	lr, r1, #5
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   3027e:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
      if (last_fec == 0) LBRR_rate_thres_bps += hysteresis;
   30282:	f850 002e 	ldr.w	r0, [r0, lr, lsl #2]
   30286:	4403      	add	r3, r0
      LBRR_rate_thres_bps = silk_SMULWB( silk_MUL( LBRR_rate_thres_bps,
   30288:	fb0c f303 	mul.w	r3, ip, r3
   3028c:	b298      	uxth	r0, r3
   3028e:	141b      	asrs	r3, r3, #16
   30290:	fb02 f000 	mul.w	r0, r2, r0
   30294:	fb02 f303 	mul.w	r3, r2, r3
   30298:	eb03 4310 	add.w	r3, r3, r0, lsr #16
      if (rate > LBRR_rate_thres_bps)
   3029c:	429e      	cmp	r6, r3
         (*bandwidth)--;
   3029e:	f1a5 0003 	sub.w	r0, r5, #3
   302a2:	f8c8 00ec 	str.w	r0, [r8, #236]	; 0xec
      if (rate > LBRR_rate_thres_bps)
   302a6:	f301 869c 	bgt.w	31fe2 <opus_encode_native+0x2572>
      else if (*bandwidth > OPUS_BANDWIDTH_NARROWBAND)
   302aa:	42a0      	cmp	r0, r4
   302ac:	d01b      	beq.n	302e6 <opus_encode_native+0x876>
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   302ae:	f1a1 0308 	sub.w	r3, r1, #8
   302b2:	487f      	ldr	r0, [pc, #508]	; (304b0 <opus_encode_native+0xa40>)
      hysteresis = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND) + 1];
   302b4:	3907      	subs	r1, #7
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   302b6:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
      if (last_fec == 0) LBRR_rate_thres_bps += hysteresis;
   302ba:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
   302be:	440b      	add	r3, r1
      LBRR_rate_thres_bps = silk_SMULWB( silk_MUL( LBRR_rate_thres_bps,
   302c0:	fb0c fc03 	mul.w	ip, ip, r3
   302c4:	fa1f f18c 	uxth.w	r1, ip
   302c8:	ea4f 432c 	mov.w	r3, ip, asr #16
   302cc:	fb02 f101 	mul.w	r1, r2, r1
   302d0:	fb02 f303 	mul.w	r3, r2, r3
         (*bandwidth)--;
   302d4:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
      LBRR_rate_thres_bps = silk_SMULWB( silk_MUL( LBRR_rate_thres_bps,
   302d6:	eb03 4311 	add.w	r3, r3, r1, lsr #16
         (*bandwidth)--;
   302da:	3a04      	subs	r2, #4
      if (rate > LBRR_rate_thres_bps)
   302dc:	429e      	cmp	r6, r3
         (*bandwidth)--;
   302de:	f8c8 20ec 	str.w	r2, [r8, #236]	; 0xec
      if (rate > LBRR_rate_thres_bps)
   302e2:	f301 867e 	bgt.w	31fe2 <opus_encode_native+0x2572>
   *bandwidth = orig_bandwidth;
   302e6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   302e8:	f8c8 30ec 	str.w	r3, [r8, #236]	; 0xec
   return 0;
   302ec:	2300      	movs	r3, #0
    lsb_depth = IMIN(lsb_depth, st->lsb_depth);
   302ee:	6dba      	ldr	r2, [r7, #88]	; 0x58
   302f0:	f8d7 11e4 	ldr.w	r1, [r7, #484]	; 0x1e4
    st->silk_mode.LBRR_coded = decide_fec(st->silk_mode.useInBandFEC, st->silk_mode.packetLossPercentage,
   302f4:	f8c8 3034 	str.w	r3, [r8, #52]	; 0x34
    lsb_depth = IMIN(lsb_depth, st->lsb_depth);
   302f8:	428a      	cmp	r2, r1
   302fa:	bfa8      	it	ge
   302fc:	460a      	movge	r2, r1
    celt_encoder_ctl(celt_enc, OPUS_SET_LSB_DEPTH(lsb_depth));
   302fe:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
    lsb_depth = IMIN(lsb_depth, st->lsb_depth);
   30300:	65ba      	str	r2, [r7, #88]	; 0x58
    celt_encoder_ctl(celt_enc, OPUS_SET_LSB_DEPTH(lsb_depth));
   30302:	f640 71c4 	movw	r1, #4036	; 0xfc4
   30306:	f7f8 fdd1 	bl	28eac <opus_custom_encoder_ctl>
    if (st->mode == MODE_CELT_ONLY && st->bandwidth == OPUS_BANDWIDTH_MEDIUMBAND)
   3030a:	f8d8 30dc 	ldr.w	r3, [r8, #220]	; 0xdc
   3030e:	f240 32ea 	movw	r2, #1002	; 0x3ea
   30312:	4293      	cmp	r3, r2
   30314:	f000 80d0 	beq.w	304b8 <opus_encode_native+0xa48>
    if (st->lfe)
   30318:	f8d8 20b0 	ldr.w	r2, [r8, #176]	; 0xb0
   3031c:	2a00      	cmp	r2, #0
   3031e:	f000 8207 	beq.w	30730 <opus_encode_native+0xcc0>
       st->bandwidth = OPUS_BANDWIDTH_NARROWBAND;
   30322:	f240 424d 	movw	r2, #1101	; 0x44d
    if (st->mode == MODE_SILK_ONLY && curr_bandwidth > OPUS_BANDWIDTH_WIDEBAND)
   30326:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
       st->bandwidth = OPUS_BANDWIDTH_NARROWBAND;
   3032a:	f8c8 20ec 	str.w	r2, [r8, #236]	; 0xec
    if (st->mode == MODE_SILK_ONLY && curr_bandwidth > OPUS_BANDWIDTH_WIDEBAND)
   3032e:	f040 8414 	bne.w	30b5a <opus_encode_native+0x10ea>
    curr_bandwidth = st->bandwidth;
   30332:	64fa      	str	r2, [r7, #76]	; 0x4c
    if ((frame_size > st->Fs/50 && (st->mode != MODE_SILK_ONLY)) || frame_size > 3*st->Fs/50)
   30334:	f8d8 1090 	ldr.w	r1, [r8, #144]	; 0x90
   30338:	4a5e      	ldr	r2, [pc, #376]	; (304b4 <opus_encode_native+0xa44>)
   3033a:	64b9      	str	r1, [r7, #72]	; 0x48
   3033c:	17cc      	asrs	r4, r1, #31
   3033e:	fb82 1201 	smull	r1, r2, r2, r1
   30342:	ebc4 1222 	rsb	r2, r4, r2, asr #4
   30346:	454a      	cmp	r2, r9
   30348:	657a      	str	r2, [r7, #84]	; 0x54
   3034a:	f280 80d2 	bge.w	304f2 <opus_encode_native+0xa82>
   3034e:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
   30352:	f040 80f0 	bne.w	30536 <opus_encode_native+0xac6>
   30356:	6cba      	ldr	r2, [r7, #72]	; 0x48
   30358:	4b56      	ldr	r3, [pc, #344]	; (304b4 <opus_encode_native+0xa44>)
   3035a:	0050      	lsls	r0, r2, #1
   3035c:	1882      	adds	r2, r0, r2
   3035e:	fb83 1302 	smull	r1, r3, r3, r2
   30362:	17d1      	asrs	r1, r2, #31
   30364:	ebc1 1123 	rsb	r1, r1, r3, asr #4
   30368:	4589      	cmp	r9, r1
   3036a:	f300 80d1 	bgt.w	30510 <opus_encode_native+0xaa0>
    if (st->silk_bw_switch)
   3036e:	f8d8 30f4 	ldr.w	r3, [r8, #244]	; 0xf4
   30372:	f8d8 20a0 	ldr.w	r2, [r8, #160]	; 0xa0
   30376:	657a      	str	r2, [r7, #84]	; 0x54
   30378:	2b00      	cmp	r3, #0
   3037a:	f001 80fb 	beq.w	31574 <opus_encode_native+0x1b04>
       st->silk_bw_switch = 0;
   3037e:	2300      	movs	r3, #0
   30380:	f8c8 30f4 	str.w	r3, [r8, #244]	; 0xf4
       prefill=2;
   30384:	2201      	movs	r2, #1
   30386:	2302      	movs	r3, #2
   30388:	e9c7 2304 	strd	r2, r3, [r7, #16]
   3038c:	e206      	b.n	3079c <opus_encode_native+0xd2c>
   3038e:	6cb9      	ldr	r1, [r7, #72]	; 0x48
   30390:	6339      	str	r1, [r7, #48]	; 0x30
   30392:	6c79      	ldr	r1, [r7, #68]	; 0x44
   30394:	f8d8 30bc 	ldr.w	r3, [r8, #188]	; 0xbc
   30398:	653b      	str	r3, [r7, #80]	; 0x50
   3039a:	315a      	adds	r1, #90	; 0x5a
   3039c:	f8d8 30a0 	ldr.w	r3, [r8, #160]	; 0xa0
       st->mode = MODE_CELT_ONLY;
   303a0:	f8c8 50dc 	str.w	r5, [r8, #220]	; 0xdc
   303a4:	4686      	mov	lr, r0
   303a6:	6439      	str	r1, [r7, #64]	; 0x40
   303a8:	e5a6      	b.n	2fef8 <opus_encode_native+0x488>
   303aa:	f8d8 10dc 	ldr.w	r1, [r8, #220]	; 0xdc
   303ae:	64f9      	str	r1, [r7, #76]	; 0x4c
    if (st->prev_mode > 0 &&
   303b0:	f1be 0f00 	cmp.w	lr, #0
   303b4:	f341 8245 	ble.w	31842 <opus_encode_native+0x1dd2>
   303b8:	4608      	mov	r0, r1
   303ba:	f240 31ea 	movw	r1, #1002	; 0x3ea
   303be:	4288      	cmp	r0, r1
   303c0:	f000 8384 	beq.w	30acc <opus_encode_native+0x105c>
        ((st->mode != MODE_CELT_ONLY && st->prev_mode == MODE_CELT_ONLY) ||
   303c4:	458e      	cmp	lr, r1
   303c6:	f5a0 707a 	sub.w	r0, r0, #1000	; 0x3e8
   303ca:	f000 8404 	beq.w	30bd6 <opus_encode_native+0x1166>
    int celt_to_silk = 0;
   303ce:	6b79      	ldr	r1, [r7, #52]	; 0x34
   303d0:	6139      	str	r1, [r7, #16]
    int redundancy = 0;
   303d2:	62f9      	str	r1, [r7, #44]	; 0x2c
   303d4:	e5a4      	b.n	2ff20 <opus_encode_native+0x4b0>
   if (frame_rate > 50)
   303d6:	461d      	mov	r5, r3
   303d8:	e568      	b.n	2feac <opus_encode_native+0x43c>
   303da:	f8d8 30f0 	ldr.w	r3, [r8, #240]	; 0xf0
                if (st->auto_bandwidth >= bandwidth)
   303de:	f5b3 6f8a 	cmp.w	r3, #1104	; 0x450
   303e2:	f300 838e 	bgt.w	30b02 <opus_encode_native+0x1092>
            if (equiv_rate >= threshold)
   303e6:	6d3e      	ldr	r6, [r7, #80]	; 0x50
                    threshold += hysteresis;
   303e8:	4465      	add	r5, ip
            if (equiv_rate >= threshold)
   303ea:	42ae      	cmp	r6, r5
   303ec:	f281 85fc 	bge.w	31fe8 <opus_encode_native+0x2578>
                if (st->auto_bandwidth >= bandwidth)
   303f0:	f5b3 6f8a 	cmp.w	r3, #1104	; 0x450
   303f4:	f000 838b 	beq.w	30b0e <opus_encode_native+0x109e>
                    threshold += hysteresis;
   303f8:	4411      	add	r1, r2
   303fa:	4632      	mov	r2, r6
            if (equiv_rate >= threshold)
   303fc:	428a      	cmp	r2, r1
   303fe:	f281 845b 	bge.w	31cb8 <opus_encode_native+0x2248>
                if (st->auto_bandwidth >= bandwidth)
   30402:	f240 424e 	movw	r2, #1102	; 0x44e
   30406:	4293      	cmp	r3, r2
                    threshold -= hysteresis;
   30408:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
            if (equiv_rate >= threshold)
   3040a:	6d39      	ldr	r1, [r7, #80]	; 0x50
                    threshold -= hysteresis;
   3040c:	bfcc      	ite	gt
   3040e:	1a12      	subgt	r2, r2, r0
                    threshold += hysteresis;
   30410:	1812      	addle	r2, r2, r0
            if (equiv_rate >= threshold)
   30412:	4291      	cmp	r1, r2
   30414:	da0b      	bge.n	3042e <opus_encode_native+0x9be>
                if (st->auto_bandwidth >= bandwidth)
   30416:	f240 424d 	movw	r2, #1101	; 0x44d
   3041a:	4293      	cmp	r3, r2
   3041c:	f341 820a 	ble.w	31834 <opus_encode_native+0x1dc4>
                    threshold -= hysteresis;
   30420:	69fb      	ldr	r3, [r7, #28]
   30422:	68fa      	ldr	r2, [r7, #12]
   30424:	1a9d      	subs	r5, r3, r2
   30426:	460b      	mov	r3, r1
            if (equiv_rate >= threshold)
   30428:	429d      	cmp	r5, r3
   3042a:	f73f ae50 	bgt.w	300ce <opus_encode_native+0x65e>
           bandwidth = OPUS_BANDWIDTH_WIDEBAND;
   3042e:	f240 424f 	movw	r2, #1103	; 0x44f
        if (!st->first && st->mode != MODE_CELT_ONLY && !st->silk_mode.inWBmodeWithoutVariableLP && st->bandwidth > OPUS_BANDWIDTH_WIDEBAND)
   30432:	6cbb      	ldr	r3, [r7, #72]	; 0x48
        st->bandwidth = st->auto_bandwidth = bandwidth;
   30434:	e9c8 223b 	strd	r2, r2, [r8, #236]	; 0xec
        if (!st->first && st->mode != MODE_CELT_ONLY && !st->silk_mode.inWBmodeWithoutVariableLP && st->bandwidth > OPUS_BANDWIDTH_WIDEBAND)
   30438:	2b00      	cmp	r3, #0
   3043a:	f47f ae4c 	bne.w	300d6 <opus_encode_native+0x666>
   3043e:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
   30440:	f240 33ea 	movw	r3, #1002	; 0x3ea
   30444:	4299      	cmp	r1, r3
   30446:	f43f ae46 	beq.w	300d6 <opus_encode_native+0x666>
   3044a:	f8d8 3058 	ldr.w	r3, [r8, #88]	; 0x58
   3044e:	2b00      	cmp	r3, #0
   30450:	f47f ae41 	bne.w	300d6 <opus_encode_native+0x666>
   30454:	f5b2 6f8a 	cmp.w	r2, #1104	; 0x450
   30458:	f041 86bf 	bne.w	321da <opus_encode_native+0x276a>
            st->bandwidth = OPUS_BANDWIDTH_WIDEBAND;
   3045c:	f240 424f 	movw	r2, #1103	; 0x44f
   30460:	f8c8 20ec 	str.w	r2, [r8, #236]	; 0xec
   30464:	e637      	b.n	300d6 <opus_encode_native+0x666>
      if (complexity<2)
   30466:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   30468:	2b01      	cmp	r3, #1
   3046a:	f340 83b9 	ble.w	30be0 <opus_encode_native+0x1170>
      equiv -= equiv*loss/(6*loss + 10);
   3046e:	6cb9      	ldr	r1, [r7, #72]	; 0x48
   30470:	6d38      	ldr	r0, [r7, #80]	; 0x50
   30472:	eb01 0341 	add.w	r3, r1, r1, lsl #1
   30476:	005b      	lsls	r3, r3, #1
    if (st->mode != MODE_CELT_ONLY && st->prev_mode == MODE_CELT_ONLY)
   30478:	f240 32ea 	movw	r2, #1002	; 0x3ea
      equiv -= equiv*loss/(6*loss + 10);
   3047c:	330a      	adds	r3, #10
   3047e:	fb01 f100 	mul.w	r1, r1, r0
    if (st->mode != MODE_CELT_ONLY && st->prev_mode == MODE_CELT_ONLY)
   30482:	4596      	cmp	lr, r2
      equiv -= equiv*loss/(6*loss + 10);
   30484:	fb91 f3f3 	sdiv	r3, r1, r3
   30488:	eba0 0303 	sub.w	r3, r0, r3
   3048c:	653b      	str	r3, [r7, #80]	; 0x50
    if (st->mode != MODE_CELT_ONLY && st->prev_mode == MODE_CELT_ONLY)
   3048e:	f000 83ed 	beq.w	30c6c <opus_encode_native+0x11fc>
    int prefill=0;
   30492:	2300      	movs	r3, #0
   30494:	617b      	str	r3, [r7, #20]
   30496:	f107 038c 	add.w	r3, r7, #140	; 0x8c
   3049a:	663b      	str	r3, [r7, #96]	; 0x60
   3049c:	f8d8 20f8 	ldr.w	r2, [r8, #248]	; 0xf8
   304a0:	64ba      	str	r2, [r7, #72]	; 0x48
    if (st->mode == MODE_CELT_ONLY || st->first || st->silk_mode.allowBandwidthSwitch)
   304a2:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   304a4:	f240 33ea 	movw	r3, #1002	; 0x3ea
   304a8:	429a      	cmp	r2, r3
   304aa:	f47f ad83 	bne.w	2ffb4 <opus_encode_native+0x544>
   304ae:	e588      	b.n	2ffc2 <opus_encode_native+0x552>
   304b0:	0003b5d0 	.word	0x0003b5d0
   304b4:	51eb851f 	.word	0x51eb851f
    if (st->mode == MODE_CELT_ONLY && st->bandwidth == OPUS_BANDWIDTH_MEDIUMBAND)
   304b8:	f8d8 20ec 	ldr.w	r2, [r8, #236]	; 0xec
   304bc:	64fa      	str	r2, [r7, #76]	; 0x4c
   304be:	4611      	mov	r1, r2
   304c0:	f240 424e 	movw	r2, #1102	; 0x44e
   304c4:	4291      	cmp	r1, r2
   304c6:	f000 8395 	beq.w	30bf4 <opus_encode_native+0x1184>
    if (st->lfe)
   304ca:	f8d8 20b0 	ldr.w	r2, [r8, #176]	; 0xb0
   304ce:	b122      	cbz	r2, 304da <opus_encode_native+0xa6a>
       st->bandwidth = OPUS_BANDWIDTH_NARROWBAND;
   304d0:	f240 424d 	movw	r2, #1101	; 0x44d
   304d4:	f8c8 20ec 	str.w	r2, [r8, #236]	; 0xec
    curr_bandwidth = st->bandwidth;
   304d8:	64fa      	str	r2, [r7, #76]	; 0x4c
    if ((frame_size > st->Fs/50 && (st->mode != MODE_SILK_ONLY)) || frame_size > 3*st->Fs/50)
   304da:	f8d8 1090 	ldr.w	r1, [r8, #144]	; 0x90
   304de:	4a93      	ldr	r2, [pc, #588]	; (3072c <opus_encode_native+0xcbc>)
   304e0:	64b9      	str	r1, [r7, #72]	; 0x48
   304e2:	17cc      	asrs	r4, r1, #31
   304e4:	fb82 1201 	smull	r1, r2, r2, r1
   304e8:	ebc4 1222 	rsb	r2, r4, r2, asr #4
   304ec:	4591      	cmp	r9, r2
   304ee:	657a      	str	r2, [r7, #84]	; 0x54
   304f0:	dc21      	bgt.n	30536 <opus_encode_native+0xac6>
   304f2:	6cba      	ldr	r2, [r7, #72]	; 0x48
   304f4:	498d      	ldr	r1, [pc, #564]	; (3072c <opus_encode_native+0xcbc>)
   304f6:	0050      	lsls	r0, r2, #1
   304f8:	1882      	adds	r2, r0, r2
   304fa:	fb81 5102 	smull	r5, r1, r1, r2
   304fe:	17d5      	asrs	r5, r2, #31
   30500:	ebc5 1121 	rsb	r1, r5, r1, asr #4
   30504:	4549      	cmp	r1, r9
   30506:	f280 8397 	bge.w	30c38 <opus_encode_native+0x11c8>
       if (st->mode == MODE_SILK_ONLY)
   3050a:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
   3050e:	d112      	bne.n	30536 <opus_encode_native+0xac6>
         if (frame_size == 2*st->Fs/25)  /* 80 ms -> 2x 40 ms */
   30510:	4b86      	ldr	r3, [pc, #536]	; (3072c <opus_encode_native+0xcbc>)
   30512:	17c5      	asrs	r5, r0, #31
   30514:	fb83 6000 	smull	r6, r0, r3, r0
   30518:	ebc5 00e0 	rsb	r0, r5, r0, asr #3
   3051c:	4548      	cmp	r0, r9
   3051e:	f001 8134 	beq.w	3178a <opus_encode_native+0x1d1a>
         else if (frame_size == 3*st->Fs/25)  /* 120 ms -> 2x 60 ms */
   30522:	fb83 0302 	smull	r0, r3, r3, r2
   30526:	17d2      	asrs	r2, r2, #31
   30528:	ebc2 03e3 	rsb	r3, r2, r3, asr #3
           enc_frame_size = 3*st->Fs/50;
   3052c:	6d7a      	ldr	r2, [r7, #84]	; 0x54
   3052e:	454b      	cmp	r3, r9
   30530:	bf08      	it	eq
   30532:	460a      	moveq	r2, r1
   30534:	657a      	str	r2, [r7, #84]	; 0x54
       nb_frames = frame_size/enc_frame_size;
   30536:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   30538:	fb99 faf3 	sdiv	sl, r9, r3
   if (st->use_vbr || st->user_bitrate_bps==OPUS_BITRATE_MAX)
   3053c:	f8d8 3094 	ldr.w	r3, [r8, #148]	; 0x94
{
   30540:	f8c7 d050 	str.w	sp, [r7, #80]	; 0x50
   max_header_bytes = nb_frames == 2 ? 3 : (2+(nb_frames-1)*2);
   30544:	f1ba 0f02 	cmp.w	sl, #2
   30548:	bf14      	ite	ne
   3054a:	ea4f 064a 	movne.w	r6, sl, lsl #1
   3054e:	2603      	moveq	r6, #3
   if (st->use_vbr || st->user_bitrate_bps==OPUS_BITRATE_MAX)
   30550:	b9cb      	cbnz	r3, 30586 <opus_encode_native+0xb16>
   30552:	f8d8 30a4 	ldr.w	r3, [r8, #164]	; 0xa4
   30556:	3301      	adds	r3, #1
   30558:	d015      	beq.n	30586 <opus_encode_native+0xb16>
      cbr_bytes = 3*st->bitrate_bps/(3*8*st->Fs/(frame_size*nb_frames));
   3055a:	6cba      	ldr	r2, [r7, #72]	; 0x48
   3055c:	f8d8 30a0 	ldr.w	r3, [r8, #160]	; 0xa0
   30560:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   30564:	00d1      	lsls	r1, r2, #3
   30566:	6d7a      	ldr	r2, [r7, #84]	; 0x54
   30568:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   3056c:	fb0a f202 	mul.w	r2, sl, r2
   30570:	fb91 f2f2 	sdiv	r2, r1, r2
   30574:	fb93 f3f2 	sdiv	r3, r3, r2
      repacketize_len = IMIN(cbr_bytes, out_data_bytes);
   30578:	f8d7 21e0 	ldr.w	r2, [r7, #480]	; 0x1e0
   3057c:	429a      	cmp	r2, r3
   3057e:	bfa8      	it	ge
   30580:	461a      	movge	r2, r3
   30582:	f8c7 21e0 	str.w	r2, [r7, #480]	; 0x1e0
   bytes_per_frame = IMIN(1276, 1+(repacketize_len-max_header_bytes)/nb_frames);
   30586:	f8d7 21e0 	ldr.w	r2, [r7, #480]	; 0x1e0
   opus_repacketizer_init(rp);
   3058a:	6e38      	ldr	r0, [r7, #96]	; 0x60
   bytes_per_frame = IMIN(1276, 1+(repacketize_len-max_header_bytes)/nb_frames);
   3058c:	f240 43fb 	movw	r3, #1275	; 0x4fb
   30590:	1b96      	subs	r6, r2, r6
   30592:	fb96 f6fa 	sdiv	r6, r6, sl
   30596:	429e      	cmp	r6, r3
   30598:	bfa8      	it	ge
   3059a:	461e      	movge	r6, r3
   3059c:	3601      	adds	r6, #1
   ALLOC(tmp_data, nb_frames*bytes_per_frame, unsigned char);
   3059e:	fb06 f30a 	mul.w	r3, r6, sl
   305a2:	3307      	adds	r3, #7
   305a4:	f023 0307 	bic.w	r3, r3, #7
   305a8:	ebad 0d03 	sub.w	sp, sp, r3
   opus_repacketizer_init(rp);
   305ac:	f002 fbfc 	bl	32da8 <opus_repacketizer_init>
   st->user_forced_mode = st->mode;
   305b0:	f8d8 10dc 	ldr.w	r1, [r8, #220]	; 0xdc
   st->user_bandwidth = st->bandwidth;
   305b4:	f8d8 20ec 	ldr.w	r2, [r8, #236]	; 0xec
   bak_to_mono = st->silk_mode.toMono;
   305b8:	f8d8 0044 	ldr.w	r0, [r8, #68]	; 0x44
   bak_mode = st->user_forced_mode;
   305bc:	f8d8 4088 	ldr.w	r4, [r8, #136]	; 0x88
   st->force_channels = st->stream_channels;
   305c0:	f8d8 30bc 	ldr.w	r3, [r8, #188]	; 0xbc
   st->user_forced_mode = st->mode;
   305c4:	f8c8 1088 	str.w	r1, [r8, #136]	; 0x88
   bak_bandwidth = st->user_bandwidth;
   305c8:	f8d8 1080 	ldr.w	r1, [r8, #128]	; 0x80
   st->user_bandwidth = st->bandwidth;
   305cc:	f8c8 2080 	str.w	r2, [r8, #128]	; 0x80
   bak_channels = st->force_channels;
   305d0:	f8d8 2078 	ldr.w	r2, [r8, #120]	; 0x78
   bak_mode = st->user_forced_mode;
   305d4:	64fc      	str	r4, [r7, #76]	; 0x4c
   bak_to_mono = st->silk_mode.toMono;
   305d6:	6438      	str	r0, [r7, #64]	; 0x40
   ALLOC(tmp_data, nb_frames*bytes_per_frame, unsigned char);
   305d8:	ac0a      	add	r4, sp, #40	; 0x28
   bak_bandwidth = st->user_bandwidth;
   305da:	64b9      	str	r1, [r7, #72]	; 0x48
   bak_channels = st->force_channels;
   305dc:	647a      	str	r2, [r7, #68]	; 0x44
   st->force_channels = st->stream_channels;
   305de:	f8c8 3078 	str.w	r3, [r8, #120]	; 0x78
   if (bak_to_mono)
   305e2:	2800      	cmp	r0, #0
   305e4:	f000 8358 	beq.w	30c98 <opus_encode_native+0x1228>
      st->force_channels = 1;
   305e8:	2301      	movs	r3, #1
   305ea:	f8c8 3078 	str.w	r3, [r8, #120]	; 0x78
   for (i=0;i<nb_frames;i++)
   305ee:	f1ba 0f00 	cmp.w	sl, #0
   305f2:	f340 83a7 	ble.w	30d44 <opus_encode_native+0x12d4>
   305f6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   305f8:	f10a 3bff 	add.w	fp, sl, #4294967295	; 0xffffffff
   305fc:	2b00      	cmp	r3, #0
   305fe:	f040 834e 	bne.w	30c9e <opus_encode_native+0x122e>
      st->silk_mode.toMono = 0;
   30602:	f8c7 a06c 	str.w	sl, [r7, #108]	; 0x6c
   30606:	461d      	mov	r5, r3
   30608:	4699      	mov	r9, r3
   3060a:	f8d7 a054 	ldr.w	sl, [r7, #84]	; 0x54
   3060e:	e007      	b.n	30620 <opus_encode_native+0xbb0>
      ret = opus_repacketizer_cat(rp, tmp_data+i*bytes_per_frame, tmp_len);
   30610:	f002 fbce 	bl	32db0 <opus_repacketizer_cat>
      if (ret<0)
   30614:	2800      	cmp	r0, #0
   30616:	db2c      	blt.n	30672 <opus_encode_native+0xc02>
   for (i=0;i<nb_frames;i++)
   30618:	6efb      	ldr	r3, [r7, #108]	; 0x6c
   3061a:	454b      	cmp	r3, r9
   3061c:	f000 8391 	beq.w	30d42 <opus_encode_native+0x12d2>
      tmp_len = opus_encode_native(st, pcm+i*(st->channels*frame_size), frame_size,
   30620:	f8d8 3070 	ldr.w	r3, [r8, #112]	; 0x70
   30624:	6e7a      	ldr	r2, [r7, #100]	; 0x64
      st->silk_mode.toMono = 0;
   30626:	f8c8 5044 	str.w	r5, [r8, #68]	; 0x44
      tmp_len = opus_encode_native(st, pcm+i*(st->channels*frame_size), frame_size,
   3062a:	fb03 f30a 	mul.w	r3, r3, sl
   3062e:	fb09 f103 	mul.w	r1, r9, r3
      st->nonfinal_frame = i<(nb_frames-1);
   30632:	45cb      	cmp	fp, r9
      tmp_len = opus_encode_native(st, pcm+i*(st->channels*frame_size), frame_size,
   30634:	eb02 0141 	add.w	r1, r2, r1, lsl #1
   30638:	f8d7 2200 	ldr.w	r2, [r7, #512]	; 0x200
      st->nonfinal_frame = i<(nb_frames-1);
   3063c:	bfd4      	ite	le
   3063e:	2300      	movle	r3, #0
   30640:	2301      	movgt	r3, #1
   30642:	f8c8 3890 	str.w	r3, [r8, #2192]	; 0x890
      tmp_len = opus_encode_native(st, pcm+i*(st->channels*frame_size), frame_size,
   30646:	e9cd 5207 	strd	r5, r2, [sp, #28]
   3064a:	e9cd 5505 	strd	r5, r5, [sp, #20]
   3064e:	e9cd 5503 	strd	r5, r5, [sp, #12]
   30652:	9502      	str	r5, [sp, #8]
   30654:	6dba      	ldr	r2, [r7, #88]	; 0x58
   30656:	4623      	mov	r3, r4
   30658:	e9cd 6200 	strd	r6, r2, [sp]
   3065c:	4640      	mov	r0, r8
   3065e:	4652      	mov	r2, sl
   30660:	f7ff fa06 	bl	2fa70 <opus_encode_native>
      if (tmp_len<0)
   30664:	1e02      	subs	r2, r0, #0
      ret = opus_repacketizer_cat(rp, tmp_data+i*bytes_per_frame, tmp_len);
   30666:	4621      	mov	r1, r4
   for (i=0;i<nb_frames;i++)
   30668:	f109 0901 	add.w	r9, r9, #1
      ret = opus_repacketizer_cat(rp, tmp_data+i*bytes_per_frame, tmp_len);
   3066c:	6e38      	ldr	r0, [r7, #96]	; 0x60
   3066e:	4434      	add	r4, r6
      if (tmp_len<0)
   30670:	dace      	bge.n	30610 <opus_encode_native+0xba0>
         return OPUS_INTERNAL_ERROR;
   30672:	f06f 0002 	mvn.w	r0, #2
   30676:	f8d7 d050 	ldr.w	sp, [r7, #80]	; 0x50
}
   3067a:	f507 77de 	add.w	r7, r7, #444	; 0x1bc
   3067e:	46bd      	mov	sp, r7
   30680:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (st->stream_channels == 1 && st->prev_channels ==2 && st->silk_mode.toMono==0
   30684:	f8d8 50e4 	ldr.w	r5, [r8, #228]	; 0xe4
   30688:	2d02      	cmp	r5, #2
   3068a:	f47f ac4d 	bne.w	2ff28 <opus_encode_native+0x4b8>
   3068e:	f8d8 1044 	ldr.w	r1, [r8, #68]	; 0x44
   30692:	2900      	cmp	r1, #0
   30694:	f47f ac48 	bne.w	2ff28 <opus_encode_native+0x4b8>
          && st->mode != MODE_CELT_ONLY && st->prev_mode != MODE_CELT_ONLY)
   30698:	6cfe      	ldr	r6, [r7, #76]	; 0x4c
   3069a:	f240 3cea 	movw	ip, #1002	; 0x3ea
   3069e:	4566      	cmp	r6, ip
   306a0:	f43f ac43 	beq.w	2ff2a <opus_encode_native+0x4ba>
   306a4:	45e6      	cmp	lr, ip
   306a6:	f43f ac40 	beq.w	2ff2a <opus_encode_native+0x4ba>
       st->silk_mode.toMono = 1;
   306aa:	6d39      	ldr	r1, [r7, #80]	; 0x50
       st->stream_channels = 2;
   306ac:	f8c8 50bc 	str.w	r5, [r8, #188]	; 0xbc
   306b0:	653d      	str	r5, [r7, #80]	; 0x50
   306b2:	e43a      	b.n	2ff2a <opus_encode_native+0x4ba>
       st->mode = MODE_CELT_ONLY;
   306b4:	f240 31ea 	movw	r1, #1002	; 0x3ea
   306b8:	f8c8 10dc 	str.w	r1, [r8, #220]	; 0xdc
   306bc:	f8d8 e0e0 	ldr.w	lr, [r8, #224]	; 0xe0
   306c0:	e41a      	b.n	2fef8 <opus_encode_native+0x488>
       if (st->channels == 2)
   306c2:	6d79      	ldr	r1, [r7, #84]	; 0x54
   306c4:	2902      	cmp	r1, #2
   306c6:	f47f abe1 	bne.w	2fe8c <opus_encode_native+0x41c>
          stereo_threshold = stereo_music_threshold + ((voice_est*voice_est*(stereo_voice_threshold-stereo_music_threshold))>>14);
   306ca:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
   306cc:	fb01 fe01 	mul.w	lr, r1, r1
          if (st->stream_channels == 2)
   306d0:	f8d8 10bc 	ldr.w	r1, [r8, #188]	; 0xbc
          stereo_threshold = stereo_music_threshold + ((voice_est*voice_est*(stereo_voice_threshold-stereo_music_threshold))>>14);
   306d4:	f44f 6cfa 	mov.w	ip, #2000	; 0x7d0
          if (st->stream_channels == 2)
   306d8:	2902      	cmp	r1, #2
   equiv = equiv * (90+complexity)/100;
   306da:	6c39      	ldr	r1, [r7, #64]	; 0x40
          stereo_threshold = stereo_music_threshold + ((voice_est*voice_est*(stereo_voice_threshold-stereo_music_threshold))>>14);
   306dc:	fb0c fc0e 	mul.w	ip, ip, lr
   equiv = equiv * (90+complexity)/100;
   306e0:	f8df e048 	ldr.w	lr, [pc, #72]	; 3072c <opus_encode_native+0xcbc>
   306e4:	fb05 f501 	mul.w	r5, r5, r1
   306e8:	fb8e e105 	smull	lr, r1, lr, r5
   306ec:	ea4f 75e5 	mov.w	r5, r5, asr #31
   306f0:	ebc5 1161 	rsb	r1, r5, r1, asr #5
      equiv -= equiv*loss/(12*loss + 20);
   306f4:	6cbd      	ldr	r5, [r7, #72]	; 0x48
          stereo_threshold = stereo_music_threshold + ((voice_est*voice_est*(stereo_voice_threshold-stereo_music_threshold))>>14);
   306f6:	ea4f 3cac 	mov.w	ip, ip, asr #14
      equiv -= equiv*loss/(12*loss + 20);
   306fa:	fb05 fe01 	mul.w	lr, r5, r1
             stereo_threshold += 1000;
   306fe:	bf18      	it	ne
   30700:	f50c 4c8c 	addne.w	ip, ip, #17920	; 0x4600
      equiv -= equiv*loss/(12*loss + 20);
   30704:	6cfd      	ldr	r5, [r7, #76]	; 0x4c
   30706:	fb9e f5f5 	sdiv	r5, lr, r5
   3070a:	eba1 0105 	sub.w	r1, r1, r5
          st->stream_channels = (equiv_rate > stereo_threshold) ? 2 : 1;
   3070e:	6d7d      	ldr	r5, [r7, #84]	; 0x54
             stereo_threshold -= 1000;
   30710:	bf0c      	ite	eq
   30712:	f50c 5c7a 	addeq.w	ip, ip, #16000	; 0x3e80
             stereo_threshold += 1000;
   30716:	f10c 0c50 	addne.w	ip, ip, #80	; 0x50
          st->stream_channels = (equiv_rate > stereo_threshold) ? 2 : 1;
   3071a:	458c      	cmp	ip, r1
   3071c:	bfa8      	it	ge
   3071e:	2501      	movge	r5, #1
   30720:	653d      	str	r5, [r7, #80]	; 0x50
   30722:	f8c8 50bc 	str.w	r5, [r8, #188]	; 0xbc
   30726:	f7ff bbb4 	b.w	2fe92 <opus_encode_native+0x422>
   3072a:	bf00      	nop
   3072c:	51eb851f 	.word	0x51eb851f
    curr_bandwidth = st->bandwidth;
   30730:	f8d8 10ec 	ldr.w	r1, [r8, #236]	; 0xec
   30734:	64f9      	str	r1, [r7, #76]	; 0x4c
    if (st->mode == MODE_SILK_ONLY && curr_bandwidth > OPUS_BANDWIDTH_WIDEBAND)
   30736:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
   3073a:	f040 823a 	bne.w	30bb2 <opus_encode_native+0x1142>
   3073e:	f5b1 6f8a 	cmp.w	r1, #1104	; 0x450
   30742:	f6ff adf7 	blt.w	30334 <opus_encode_native+0x8c4>
    if ((frame_size > st->Fs/50 && (st->mode != MODE_SILK_ONLY)) || frame_size > 3*st->Fs/50)
   30746:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
   3074a:	49db      	ldr	r1, [pc, #876]	; (30ab8 <opus_encode_native+0x1048>)
   3074c:	64bb      	str	r3, [r7, #72]	; 0x48
   3074e:	17d8      	asrs	r0, r3, #31
   30750:	fb81 4303 	smull	r4, r3, r1, r3
   30754:	ebc0 1323 	rsb	r3, r0, r3, asr #4
   30758:	4618      	mov	r0, r3
   3075a:	657b      	str	r3, [r7, #84]	; 0x54
   3075c:	4581      	cmp	r9, r0
        st->mode = MODE_HYBRID;
   3075e:	f240 33e9 	movw	r3, #1001	; 0x3e9
   30762:	f8c8 30dc 	str.w	r3, [r8, #220]	; 0xdc
    if ((frame_size > st->Fs/50 && (st->mode != MODE_SILK_ONLY)) || frame_size > 3*st->Fs/50)
   30766:	f73f aee6 	bgt.w	30536 <opus_encode_native+0xac6>
   3076a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   3076c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   30770:	fb81 0103 	smull	r0, r1, r1, r3
   30774:	17db      	asrs	r3, r3, #31
   30776:	ebc3 1321 	rsb	r3, r3, r1, asr #4
   3077a:	4599      	cmp	r9, r3
   3077c:	f73f aedb 	bgt.w	30536 <opus_encode_native+0xac6>
    if (st->silk_bw_switch)
   30780:	f8d8 30f4 	ldr.w	r3, [r8, #244]	; 0xf4
   30784:	f8d8 10a0 	ldr.w	r1, [r8, #160]	; 0xa0
   30788:	6579      	str	r1, [r7, #84]	; 0x54
   3078a:	2b00      	cmp	r3, #0
   3078c:	f000 86f2 	beq.w	31574 <opus_encode_native+0x1b04>
       prefill=2;
   30790:	2501      	movs	r5, #1
   30792:	2302      	movs	r3, #2
   30794:	e9c7 5304 	strd	r5, r3, [r7, #16]
       st->silk_bw_switch = 0;
   30798:	f8c8 20f4 	str.w	r2, [r8, #244]	; 0xf4
       redundancy_bytes = compute_redundancy_bytes(max_data_bytes, st->bitrate_bps, frame_rate, st->stream_channels);
   3079c:	f8d8 10bc 	ldr.w	r1, [r8, #188]	; 0xbc
   redundancy_rate = bitrate_bps + base_bits*(200 - frame_rate);
   307a0:	6d7c      	ldr	r4, [r7, #84]	; 0x54
   redundancy_bytes = redundancy_rate/1600;
   307a2:	4dc5      	ldr	r5, [pc, #788]	; (30ab8 <opus_encode_native+0x1048>)
   base_bits = (40*channels+20);
   307a4:	eb01 0381 	add.w	r3, r1, r1, lsl #2
   307a8:	00db      	lsls	r3, r3, #3
   307aa:	f103 0014 	add.w	r0, r3, #20
   available_bits = max_data_bytes*8 - 2*base_bits;
   307ae:	ebc0 038b 	rsb	r3, r0, fp, lsl #2
   redundancy_rate = bitrate_bps + base_bits*(200 - frame_rate);
   307b2:	f1ca 02c8 	rsb	r2, sl, #200	; 0xc8
   307b6:	fb00 4202 	mla	r2, r0, r2, r4
   redundancy_bytes_cap = (available_bits*240/(240+48000/frame_rate) + base_bits)/8;
   307ba:	015c      	lsls	r4, r3, #5
   307bc:	eba4 0343 	sub.w	r3, r4, r3, lsl #1
   redundancy_rate = 3*redundancy_rate/2;
   307c0:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   redundancy_bytes = redundancy_rate/1600;
   307c4:	fb85 4502 	smull	r4, r5, r5, r2
   redundancy_bytes_cap = (available_bits*240/(240+48000/frame_rate) + base_bits)/8;
   307c8:	011b      	lsls	r3, r3, #4
   307ca:	f64b 3480 	movw	r4, #48000	; 0xbb80
   307ce:	fb94 f4fa 	sdiv	r4, r4, sl
   307d2:	34f0      	adds	r4, #240	; 0xf0
   307d4:	fb93 f3f4 	sdiv	r3, r3, r4
   307d8:	181b      	adds	r3, r3, r0
   307da:	bf48      	it	mi
   307dc:	3307      	addmi	r3, #7
   redundancy_bytes = redundancy_rate/1600;
   307de:	17d2      	asrs	r2, r2, #31
   307e0:	ebc2 22a5 	rsb	r2, r2, r5, asr #10
   redundancy_bytes_cap = (available_bits*240/(240+48000/frame_rate) + base_bits)/8;
   307e4:	10db      	asrs	r3, r3, #3
   redundancy_bytes = IMIN(redundancy_bytes, redundancy_bytes_cap);
   307e6:	4293      	cmp	r3, r2
   if (redundancy_bytes > 4 + 8*channels)
   307e8:	ea4f 01c1 	mov.w	r1, r1, lsl #3
   redundancy_bytes = IMIN(redundancy_bytes, redundancy_bytes_cap);
   307ec:	bfa8      	it	ge
   307ee:	4613      	movge	r3, r2
   if (redundancy_bytes > 4 + 8*channels)
   307f0:	1d0a      	adds	r2, r1, #4
   307f2:	4293      	cmp	r3, r2
   307f4:	f341 82ab 	ble.w	31d4e <opus_encode_native+0x22de>
      redundancy_bytes = IMIN(257, redundancy_bytes);
   307f8:	f240 1201 	movw	r2, #257	; 0x101
   307fc:	429a      	cmp	r2, r3
   307fe:	bfa8      	it	ge
   30800:	461a      	movge	r2, r3
       if (redundancy_bytes == 0)
   30802:	3300      	adds	r3, #0
   30804:	bf18      	it	ne
   30806:	2301      	movne	r3, #1
   30808:	62fb      	str	r3, [r7, #44]	; 0x2c
   3080a:	ebab 0302 	sub.w	r3, fp, r2
      redundancy_bytes = IMIN(257, redundancy_bytes);
   3080e:	63ba      	str	r2, [r7, #56]	; 0x38
   30810:	61fb      	str	r3, [r7, #28]
    data += 1;
   30812:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    ec_enc_init(&enc, data, max_data_bytes-1);
   30814:	6e38      	ldr	r0, [r7, #96]	; 0x60
    data += 1;
   30816:	1c59      	adds	r1, r3, #1
    ec_enc_init(&enc, data, max_data_bytes-1);
   30818:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
   3081c:	461a      	mov	r2, r3
    data += 1;
   3081e:	6239      	str	r1, [r7, #32]
    ec_enc_init(&enc, data, max_data_bytes-1);
   30820:	643b      	str	r3, [r7, #64]	; 0x40
   30822:	f7f9 f9ad 	bl	29b80 <ec_enc_init>
    ALLOC(pcm_buf, (total_buffer+frame_size)*st->channels, opus_val16);
   30826:	6dfc      	ldr	r4, [r7, #92]	; 0x5c
   30828:	f8d8 0070 	ldr.w	r0, [r8, #112]	; 0x70
    OPUS_COPY(pcm_buf, &st->delay_buffer[(st->encoder_buffer-total_buffer)*st->channels], total_buffer*st->channels);
   3082c:	f8d8 30ac 	ldr.w	r3, [r8, #172]	; 0xac
    ALLOC(pcm_buf, (total_buffer+frame_size)*st->channels, opus_val16);
   30830:	f8c7 d03c 	str.w	sp, [r7, #60]	; 0x3c
   30834:	4622      	mov	r2, r4
   30836:	444a      	add	r2, r9
   30838:	627a      	str	r2, [r7, #36]	; 0x24
   3083a:	fb00 f202 	mul.w	r2, r0, r2
   3083e:	0052      	lsls	r2, r2, #1
   30840:	3208      	adds	r2, #8
   30842:	f022 0207 	bic.w	r2, r2, #7
    OPUS_COPY(pcm_buf, &st->delay_buffer[(st->encoder_buffer-total_buffer)*st->channels], total_buffer*st->channels);
   30846:	1b19      	subs	r1, r3, r4
    ALLOC(pcm_buf, (total_buffer+frame_size)*st->channels, opus_val16);
   30848:	ebad 0d02 	sub.w	sp, sp, r2
    OPUS_COPY(pcm_buf, &st->delay_buffer[(st->encoder_buffer-total_buffer)*st->channels], total_buffer*st->channels);
   3084c:	fb00 f101 	mul.w	r1, r0, r1
    ALLOC(pcm_buf, (total_buffer+frame_size)*st->channels, opus_val16);
   30850:	ab0a      	add	r3, sp, #40	; 0x28
    OPUS_COPY(pcm_buf, &st->delay_buffer[(st->encoder_buffer-total_buffer)*st->channels], total_buffer*st->channels);
   30852:	fb04 f200 	mul.w	r2, r4, r0
   30856:	3188      	adds	r1, #136	; 0x88
   30858:	4618      	mov	r0, r3
   3085a:	0052      	lsls	r2, r2, #1
   3085c:	eb08 0141 	add.w	r1, r8, r1, lsl #1
    ALLOC(pcm_buf, (total_buffer+frame_size)*st->channels, opus_val16);
   30860:	647b      	str	r3, [r7, #68]	; 0x44
    OPUS_COPY(pcm_buf, &st->delay_buffer[(st->encoder_buffer-total_buffer)*st->channels], total_buffer*st->channels);
   30862:	f7db fc4d 	bl	c100 <memcpy>
    if (st->mode == MODE_CELT_ONLY)
   30866:	f8d8 20dc 	ldr.w	r2, [r8, #220]	; 0xdc
   3086a:	f240 33ea 	movw	r3, #1002	; 0x3ea
   3086e:	429a      	cmp	r2, r3
   30870:	f001 8129 	beq.w	31ac6 <opus_encode_native+0x2056>
       hp_freq_smth1 = ((silk_encoder*)silk_enc)->state_Fxx[0].sCmn.variable_HP_smth1_Q15;
   30874:	69bb      	ldr	r3, [r7, #24]
   30876:	689b      	ldr	r3, [r3, #8]
    st->variable_HP_smth2_Q15 = silk_SMLAWB( st->variable_HP_smth2_Q15,
   30878:	f8d8 20c4 	ldr.w	r2, [r8, #196]	; 0xc4
   3087c:	1a9b      	subs	r3, r3, r2
   3087e:	b299      	uxth	r1, r3
   30880:	1418      	asrs	r0, r3, #16
   30882:	f240 33d7 	movw	r3, #983	; 0x3d7
   30886:	fb03 f101 	mul.w	r1, r3, r1
   3088a:	fb03 f000 	mul.w	r0, r3, r0
   3088e:	eb00 4011 	add.w	r0, r0, r1, lsr #16
   30892:	4410      	add	r0, r2
   30894:	f8c8 00c4 	str.w	r0, [r8, #196]	; 0xc4
    cutoff_Hz = silk_log2lin( silk_RSHIFT( st->variable_HP_smth2_Q15, 8 ) );
   30898:	1200      	asrs	r0, r0, #8
   3089a:	f7e7 f8cd 	bl	17a38 <silk_log2lin>
    if (st->application == OPUS_APPLICATION_VOIP)
   3089e:	f8d8 306c 	ldr.w	r3, [r8, #108]	; 0x6c
   308a2:	f108 02cc 	add.w	r2, r8, #204	; 0xcc
   308a6:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
   308aa:	633a      	str	r2, [r7, #48]	; 0x30
   Fc_Q19 = silk_DIV32_16( silk_SMULBB( SILK_FIX_CONST( 1.5 * 3.14159 / 1000, 19 ), cutoff_Hz ), Fs/1000 );
   308ac:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
    if (st->application == OPUS_APPLICATION_VOIP)
   308b0:	f000 85f5 	beq.w	3149e <opus_encode_native+0x1a2e>
   shift=celt_ilog2(Fs/(cutoff_Hz*4));
   308b4:	4a81      	ldr	r2, [pc, #516]	; (30abc <opus_encode_native+0x104c>)
       dc_reject(pcm, 3, &pcm_buf[total_buffer*st->channels], st->hp_mem, frame_size, st->channels, st->Fs);
   308b6:	f8d8 1070 	ldr.w	r1, [r8, #112]	; 0x70
   308ba:	65b9      	str	r1, [r7, #88]	; 0x58
   shift=celt_ilog2(Fs/(cutoff_Hz*4));
   308bc:	fb82 0203 	smull	r0, r2, r2, r3
   308c0:	ea4f 7ce3 	mov.w	ip, r3, asr #31
       dc_reject(pcm, 3, &pcm_buf[total_buffer*st->channels], st->hp_mem, frame_size, st->channels, st->Fs);
   308c4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   shift=celt_ilog2(Fs/(cutoff_Hz*4));
   308c6:	ebcc 0c62 	rsb	ip, ip, r2, asr #1
       dc_reject(pcm, 3, &pcm_buf[total_buffer*st->channels], st->hp_mem, frame_size, st->channels, st->Fs);
   308ca:	4618      	mov	r0, r3
   308cc:	460a      	mov	r2, r1
   308ce:	460b      	mov	r3, r1
   308d0:	6c79      	ldr	r1, [r7, #68]	; 0x44
   return EC_ILOG(x)-1;
   308d2:	fabc fc8c 	clz	ip, ip
   308d6:	fb00 f303 	mul.w	r3, r0, r3
   for (c=0;c<channels;c++)
   308da:	2a00      	cmp	r2, #0
   shift=celt_ilog2(Fs/(cutoff_Hz*4));
   308dc:	f1cc 0c1f 	rsb	ip, ip, #31
       dc_reject(pcm, 3, &pcm_buf[total_buffer*st->channels], st->hp_mem, frame_size, st->channels, st->Fs);
   308e0:	eb01 0543 	add.w	r5, r1, r3, lsl #1
   for (c=0;c<channels;c++)
   308e4:	dd47      	ble.n	30976 <opus_encode_native+0xf06>
         hp_mem[2*c] = hp_mem[2*c] + PSHR32(x - hp_mem[2*c], shift);
   308e6:	f04f 0e01 	mov.w	lr, #1
   308ea:	0053      	lsls	r3, r2, #1
   308ec:	fa0e fe0c 	lsl.w	lr, lr, ip
   for (c=0;c<channels;c++)
   308f0:	2200      	movs	r2, #0
   308f2:	6e7e      	ldr	r6, [r7, #100]	; 0x64
   308f4:	f8c7 a00c 	str.w	sl, [r7, #12]
   308f8:	f8c7 b064 	str.w	fp, [r7, #100]	; 0x64
         hp_mem[2*c] = hp_mem[2*c] + PSHR32(x - hp_mem[2*c], shift);
   308fc:	ea4f 0e6e 	mov.w	lr, lr, asr #1
   for (c=0;c<channels;c++)
   30900:	f8d7 b030 	ldr.w	fp, [r7, #48]	; 0x30
   30904:	f8c7 8030 	str.w	r8, [r7, #48]	; 0x30
   30908:	4692      	mov	sl, r2
   3090a:	4698      	mov	r8, r3
   3090c:	2200      	movs	r2, #0
   3090e:	f85b 003a 	ldr.w	r0, [fp, sl, lsl #3]
      for (i=0;i<len;i++)
   30912:	4614      	mov	r4, r2
   30914:	e009      	b.n	3092a <opus_encode_native+0xeba>
         out[channels*i+c] = EXTRACT16(SATURATE(PSHR32(y, 14), 32767));
   30916:	496a      	ldr	r1, [pc, #424]	; (30ac0 <opus_encode_native+0x1050>)
   30918:	428b      	cmp	r3, r1
   3091a:	f2c0 81bb 	blt.w	30c94 <opus_encode_native+0x1224>
   3091e:	b21b      	sxth	r3, r3
      for (i=0;i<len;i++)
   30920:	3401      	adds	r4, #1
   30922:	45a1      	cmp	r9, r4
         out[channels*i+c] = EXTRACT16(SATURATE(PSHR32(y, 14), 32767));
   30924:	52ab      	strh	r3, [r5, r2]
   30926:	4442      	add	r2, r8
      for (i=0;i<len;i++)
   30928:	d014      	beq.n	30954 <opus_encode_native+0xee4>
         x = SHL32(EXTEND32(in[channels*i+c]), 14);
   3092a:	5eb3      	ldrsh	r3, [r6, r2]
         y = x-hp_mem[2*c];
   3092c:	ebc0 3383 	rsb	r3, r0, r3, lsl #14
         hp_mem[2*c] = hp_mem[2*c] + PSHR32(x - hp_mem[2*c], shift);
   30930:	eb0e 0103 	add.w	r1, lr, r3
         out[channels*i+c] = EXTRACT16(SATURATE(PSHR32(y, 14), 32767));
   30934:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
   30938:	139b      	asrs	r3, r3, #14
         hp_mem[2*c] = hp_mem[2*c] + PSHR32(x - hp_mem[2*c], shift);
   3093a:	fa41 f10c 	asr.w	r1, r1, ip
         out[channels*i+c] = EXTRACT16(SATURATE(PSHR32(y, 14), 32767));
   3093e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
         hp_mem[2*c] = hp_mem[2*c] + PSHR32(x - hp_mem[2*c], shift);
   30942:	4408      	add	r0, r1
         out[channels*i+c] = EXTRACT16(SATURATE(PSHR32(y, 14), 32767));
   30944:	dbe7      	blt.n	30916 <opus_encode_native+0xea6>
      for (i=0;i<len;i++)
   30946:	3401      	adds	r4, #1
         out[channels*i+c] = EXTRACT16(SATURATE(PSHR32(y, 14), 32767));
   30948:	f647 73ff 	movw	r3, #32767	; 0x7fff
      for (i=0;i<len;i++)
   3094c:	45a1      	cmp	r9, r4
         out[channels*i+c] = EXTRACT16(SATURATE(PSHR32(y, 14), 32767));
   3094e:	52ab      	strh	r3, [r5, r2]
   30950:	4442      	add	r2, r8
      for (i=0;i<len;i++)
   30952:	d1ea      	bne.n	3092a <opus_encode_native+0xeba>
   for (c=0;c<channels;c++)
   30954:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   30956:	f84b 003a 	str.w	r0, [fp, sl, lsl #3]
   3095a:	f10a 0a01 	add.w	sl, sl, #1
   3095e:	4553      	cmp	r3, sl
   30960:	f105 0502 	add.w	r5, r5, #2
   30964:	f106 0602 	add.w	r6, r6, #2
   30968:	d1d0      	bne.n	3090c <opus_encode_native+0xe9c>
   3096a:	f8d7 b064 	ldr.w	fp, [r7, #100]	; 0x64
   3096e:	f8d7 a00c 	ldr.w	sl, [r7, #12]
   30972:	f8d7 8030 	ldr.w	r8, [r7, #48]	; 0x30
    if (st->mode != MODE_CELT_ONLY)
   30976:	f8d8 e0dc 	ldr.w	lr, [r8, #220]	; 0xdc
   3097a:	f240 33ea 	movw	r3, #1002	; 0x3ea
   3097e:	459e      	cmp	lr, r3
   30980:	f000 8589 	beq.w	31496 <opus_encode_native+0x1a26>
    bytes_target = IMIN(max_data_bytes-redundancy_bytes, st->bitrate_bps * frame_size / (st->Fs * 8)) - 1;
   30984:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   30986:	f8d8 2090 	ldr.w	r2, [r8, #144]	; 0x90
   3098a:	667a      	str	r2, [r7, #100]	; 0x64
   3098c:	fb03 f609 	mul.w	r6, r3, r9
   30990:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   30992:	f8d8 20bc 	ldr.w	r2, [r8, #188]	; 0xbc
   30996:	64ba      	str	r2, [r7, #72]	; 0x48
   30998:	00db      	lsls	r3, r3, #3
   3099a:	fb96 f6f3 	sdiv	r6, r6, r3
   3099e:	69fb      	ldr	r3, [r7, #28]
   309a0:	f8d8 2070 	ldr.w	r2, [r8, #112]	; 0x70
   309a4:	f8d8 40fc 	ldr.w	r4, [r8, #252]	; 0xfc
   309a8:	657a      	str	r2, [r7, #84]	; 0x54
   309aa:	429e      	cmp	r6, r3
   309ac:	bfa8      	it	ge
   309ae:	461e      	movge	r6, r3
   309b0:	3e01      	subs	r6, #1
        if( st->mode == MODE_HYBRID ) {
   309b2:	f240 33e9 	movw	r3, #1001	; 0x3e9
        total_bitRate = 8 * bytes_target * frame_rate;
   309b6:	00f6      	lsls	r6, r6, #3
        if( st->mode == MODE_HYBRID ) {
   309b8:	459e      	cmp	lr, r3
        total_bitRate = 8 * bytes_target * frame_rate;
   309ba:	fb0a f606 	mul.w	r6, sl, r6
        if( st->mode == MODE_HYBRID ) {
   309be:	f000 8765 	beq.w	3188c <opus_encode_native+0x1e1c>
            st->silk_mode.bitRate = total_bitRate;
   309c2:	f8c8 6024 	str.w	r6, [r8, #36]	; 0x24
        if (st->energy_masking && st->use_vbr && !st->lfe)
   309c6:	2c00      	cmp	r4, #0
   309c8:	f001 8252 	beq.w	31e70 <opus_encode_native+0x2400>
   309cc:	f8d8 2094 	ldr.w	r2, [r8, #148]	; 0x94
   309d0:	65be      	str	r6, [r7, #88]	; 0x58
   309d2:	2a00      	cmp	r2, #0
   309d4:	f000 855b 	beq.w	3148e <opus_encode_native+0x1a1e>
   309d8:	f8d8 30b0 	ldr.w	r3, [r8, #176]	; 0xb0
   309dc:	2b00      	cmp	r3, #0
   309de:	f040 8556 	bne.w	3148e <opus_encode_native+0x1a1e>
           if (st->bandwidth == OPUS_BANDWIDTH_NARROWBAND)
   309e2:	f8d8 10ec 	ldr.w	r1, [r8, #236]	; 0xec
   309e6:	60f9      	str	r1, [r7, #12]
   309e8:	f240 434d 	movw	r3, #1101	; 0x44d
   309ec:	4299      	cmp	r1, r3
   309ee:	f001 839d 	beq.w	3212c <opus_encode_native+0x26bc>
           } else if (st->bandwidth == OPUS_BANDWIDTH_MEDIUMBAND)
   309f2:	f240 434e 	movw	r3, #1102	; 0x44e
   309f6:	4299      	cmp	r1, r3
   309f8:	f642 61e0 	movw	r1, #12000	; 0x2ee0
   309fc:	bf18      	it	ne
   309fe:	f44f 517a 	movne.w	r1, #16000	; 0x3e80
   30a02:	61f9      	str	r1, [r7, #28]
   30a04:	f640 1062 	movw	r0, #2402	; 0x962
   30a08:	bf0c      	ite	eq
   30a0a:	210f      	moveq	r1, #15
   30a0c:	2111      	movne	r1, #17
   30a0e:	f640 4383 	movw	r3, #3203	; 0xc83
   30a12:	6339      	str	r1, [r7, #48]	; 0x30
   30a14:	bf08      	it	eq
   30a16:	4603      	moveq	r3, r0
   30a18:	6d79      	ldr	r1, [r7, #84]	; 0x54
   30a1a:	b288      	uxth	r0, r1
           for (c=0;c<st->channels;c++)
   30a1c:	2900      	cmp	r1, #0
   30a1e:	60b8      	str	r0, [r7, #8]
   30a20:	f340 825f 	ble.w	30ee2 <opus_encode_native+0x1472>
   30a24:	6b38      	ldr	r0, [r7, #48]	; 0x30
                 mask = MAX16(MIN16(st->energy_masking[21*c+i],
   30a26:	4e27      	ldr	r6, [pc, #156]	; (30ac4 <opus_encode_native+0x1054>)
   30a28:	f8df c09c 	ldr.w	ip, [pc, #156]	; 30ac8 <opus_encode_native+0x1058>
           opus_val32 mask_sum=0;
   30a2c:	f8c7 e004 	str.w	lr, [r7, #4]
   30a30:	eb01 0341 	add.w	r3, r1, r1, lsl #1
   30a34:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
   30a38:	1819      	adds	r1, r3, r0
   30a3a:	ebc0 73c0 	rsb	r3, r0, r0, lsl #31
   30a3e:	eb04 0141 	add.w	r1, r4, r1, lsl #1
   30a42:	005b      	lsls	r3, r3, #1
   30a44:	eb04 0540 	add.w	r5, r4, r0, lsl #1
   30a48:	603a      	str	r2, [r7, #0]
   30a4a:	2400      	movs	r4, #0
   30a4c:	469e      	mov	lr, r3
   30a4e:	460a      	mov	r2, r1
   30a50:	eb0e 0305 	add.w	r3, lr, r5
   30a54:	e00c      	b.n	30a70 <opus_encode_native+0x1000>
                 mask = MAX16(MIN16(st->energy_masking[21*c+i],
   30a56:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
   30a5a:	4601      	mov	r1, r0
   30a5c:	bfa8      	it	ge
   30a5e:	f44f 7100 	movge.w	r1, #512	; 0x200
                 if (mask > 0)
   30a62:	2800      	cmp	r0, #0
   30a64:	dd00      	ble.n	30a68 <opus_encode_native+0xff8>
   30a66:	1049      	asrs	r1, r1, #1
              for(i=0;i<end;i++)
   30a68:	42ab      	cmp	r3, r5
                 mask_sum += mask;
   30a6a:	440c      	add	r4, r1
              for(i=0;i<end;i++)
   30a6c:	f000 8224 	beq.w	30eb8 <opus_encode_native+0x1448>
                 mask = MAX16(MIN16(st->energy_masking[21*c+i],
   30a70:	f933 0b02 	ldrsh.w	r0, [r3], #2
   30a74:	42b0      	cmp	r0, r6
   30a76:	daee      	bge.n	30a56 <opus_encode_native+0xfe6>
   30a78:	4661      	mov	r1, ip
   30a7a:	e7f5      	b.n	30a68 <opus_encode_native+0xff8>
        st->bandwidth = OPUS_BANDWIDTH_SUPERWIDEBAND;
   30a7c:	f44f 638a 	mov.w	r3, #1104	; 0x450
    if (st->Fs <= 16000 && st->bandwidth > OPUS_BANDWIDTH_WIDEBAND)
   30a80:	f5b4 5f7a 	cmp.w	r4, #16000	; 0x3e80
        st->bandwidth = OPUS_BANDWIDTH_SUPERWIDEBAND;
   30a84:	f8c8 30ec 	str.w	r3, [r8, #236]	; 0xec
    if (st->Fs <= 16000 && st->bandwidth > OPUS_BANDWIDTH_WIDEBAND)
   30a88:	f73f ab6a 	bgt.w	30160 <opus_encode_native+0x6f0>
    if (st->Fs <= 12000 && st->bandwidth > OPUS_BANDWIDTH_MEDIUMBAND)
   30a8c:	f642 63e0 	movw	r3, #12000	; 0x2ee0
        st->bandwidth = OPUS_BANDWIDTH_WIDEBAND;
   30a90:	f240 424f 	movw	r2, #1103	; 0x44f
    if (st->Fs <= 12000 && st->bandwidth > OPUS_BANDWIDTH_MEDIUMBAND)
   30a94:	429c      	cmp	r4, r3
        st->bandwidth = OPUS_BANDWIDTH_WIDEBAND;
   30a96:	f8c8 20ec 	str.w	r2, [r8, #236]	; 0xec
    if (st->Fs <= 12000 && st->bandwidth > OPUS_BANDWIDTH_MEDIUMBAND)
   30a9a:	f73f ab61 	bgt.w	30160 <opus_encode_native+0x6f0>
        st->bandwidth = OPUS_BANDWIDTH_MEDIUMBAND;
   30a9e:	f240 434e 	movw	r3, #1102	; 0x44e
    if (st->Fs <= 8000 && st->bandwidth > OPUS_BANDWIDTH_NARROWBAND)
   30aa2:	f5b4 5ffa 	cmp.w	r4, #8000	; 0x1f40
        st->bandwidth = OPUS_BANDWIDTH_MEDIUMBAND;
   30aa6:	f8c8 30ec 	str.w	r3, [r8, #236]	; 0xec
    if (st->Fs <= 8000 && st->bandwidth > OPUS_BANDWIDTH_NARROWBAND)
   30aaa:	f77f ab55 	ble.w	30158 <opus_encode_native+0x6e8>
   30aae:	f7ff bb57 	b.w	30160 <opus_encode_native+0x6f0>
   30ab2:	4613      	mov	r3, r2
   30ab4:	e41b      	b.n	302ee <opus_encode_native+0x87e>
   30ab6:	bf00      	nop
   30ab8:	51eb851f 	.word	0x51eb851f
   30abc:	2aaaaaab 	.word	0x2aaaaaab
   30ac0:	ffff8001 	.word	0xffff8001
   30ac4:	fffff801 	.word	0xfffff801
   30ac8:	fffff800 	.word	0xfffff800
    (st->mode == MODE_CELT_ONLY && st->prev_mode != MODE_CELT_ONLY)))
   30acc:	f240 35ea 	movw	r5, #1002	; 0x3ea
   30ad0:	45ae      	cmp	lr, r5
   30ad2:	f001 80f5 	beq.w	31cc0 <opus_encode_native+0x2250>
            if (frame_size >= st->Fs/100)
   30ad6:	48ab      	ldr	r0, [pc, #684]	; (30d84 <opus_encode_native+0x1314>)
   30ad8:	17e1      	asrs	r1, r4, #31
   30ada:	fb80 6004 	smull	r6, r0, r0, r4
   30ade:	ebc1 1160 	rsb	r1, r1, r0, asr #5
   30ae2:	4549      	cmp	r1, r9
   30ae4:	f73f aa16 	bgt.w	2ff14 <opus_encode_native+0x4a4>
                to_celt = 1;
   30ae8:	2101      	movs	r1, #1
   30aea:	6379      	str	r1, [r7, #52]	; 0x34
        redundancy = 1;
   30aec:	62f9      	str	r1, [r7, #44]	; 0x2c
        celt_to_silk = (st->mode != MODE_CELT_ONLY);
   30aee:	2100      	movs	r1, #0
                st->mode = st->prev_mode;
   30af0:	f8c8 e0dc 	str.w	lr, [r8, #220]	; 0xdc
   30af4:	f5ae 707a 	sub.w	r0, lr, #1000	; 0x3e8
   30af8:	f8c7 e04c 	str.w	lr, [r7, #76]	; 0x4c
        celt_to_silk = (st->mode != MODE_CELT_ONLY);
   30afc:	6139      	str	r1, [r7, #16]
   30afe:	f7ff ba0f 	b.w	2ff20 <opus_encode_native+0x4b0>
            if (equiv_rate >= threshold)
   30b02:	6d3e      	ldr	r6, [r7, #80]	; 0x50
                    threshold -= hysteresis;
   30b04:	eba5 050c 	sub.w	r5, r5, ip
            if (equiv_rate >= threshold)
   30b08:	42ae      	cmp	r6, r5
   30b0a:	f281 826d 	bge.w	31fe8 <opus_encode_native+0x2578>
                    threshold -= hysteresis;
   30b0e:	1a89      	subs	r1, r1, r2
   30b10:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   30b12:	e473      	b.n	303fc <opus_encode_native+0x98c>
    equiv_rate = compute_equiv_rate(st->bitrate_bps, st->channels, st->Fs/frame_size,
   30b14:	f8d8 5070 	ldr.w	r5, [r8, #112]	; 0x70
   30b18:	657d      	str	r5, [r7, #84]	; 0x54
   30b1a:	f8d8 502c 	ldr.w	r5, [r8, #44]	; 0x2c
   30b1e:	f8d8 6028 	ldr.w	r6, [r8, #40]	; 0x28
   30b22:	647d      	str	r5, [r7, #68]	; 0x44
    max_rate = frame_rate*max_data_bytes*8;
   30b24:	00c9      	lsls	r1, r1, #3
    equiv_rate = compute_equiv_rate(st->bitrate_bps, st->channels, st->Fs/frame_size,
   30b26:	6d7d      	ldr	r5, [r7, #84]	; 0x54
   30b28:	653d      	str	r5, [r7, #80]	; 0x50
   30b2a:	64be      	str	r6, [r7, #72]	; 0x48
    max_rate = frame_rate*max_data_bytes*8;
   30b2c:	62b9      	str	r1, [r7, #40]	; 0x28
    equiv_rate = compute_equiv_rate(st->bitrate_bps, st->channels, st->Fs/frame_size,
   30b2e:	633e      	str	r6, [r7, #48]	; 0x30
   30b30:	461d      	mov	r5, r3
   30b32:	f7ff b946 	b.w	2fdc2 <opus_encode_native+0x352>
   30b36:	f240 434f 	movw	r3, #1103	; 0x44f
       data[0] = gen_toc(tocmode, frame_rate, bw, st->stream_channels);
   30b3a:	2200      	movs	r2, #0
   30b3c:	429d      	cmp	r5, r3
   30b3e:	bfa8      	it	ge
   30b40:	461d      	movge	r5, r3
   30b42:	4611      	mov	r1, r2
   30b44:	4610      	mov	r0, r2
   30b46:	f8d8 40bc 	ldr.w	r4, [r8, #188]	; 0xbc
   30b4a:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
   30b4e:	f7ff b872 	b.w	2fc36 <opus_encode_native+0x1c6>
   30b52:	f8d8 20ec 	ldr.w	r2, [r8, #236]	; 0xec
   30b56:	f7ff babe 	b.w	300d6 <opus_encode_native+0x666>
    if (st->mode == MODE_HYBRID && curr_bandwidth <= OPUS_BANDWIDTH_WIDEBAND)
   30b5a:	f240 31e9 	movw	r1, #1001	; 0x3e9
   30b5e:	428b      	cmp	r3, r1
    curr_bandwidth = st->bandwidth;
   30b60:	64fa      	str	r2, [r7, #76]	; 0x4c
    if (st->mode == MODE_HYBRID && curr_bandwidth <= OPUS_BANDWIDTH_WIDEBAND)
   30b62:	f47f acba 	bne.w	304da <opus_encode_native+0xa6a>
    if ((frame_size > st->Fs/50 && (st->mode != MODE_SILK_ONLY)) || frame_size > 3*st->Fs/50)
   30b66:	f8d8 2090 	ldr.w	r2, [r8, #144]	; 0x90
   30b6a:	4b86      	ldr	r3, [pc, #536]	; (30d84 <opus_encode_native+0x1314>)
   30b6c:	64ba      	str	r2, [r7, #72]	; 0x48
   30b6e:	17d4      	asrs	r4, r2, #31
   30b70:	fb83 1202 	smull	r1, r2, r3, r2
   30b74:	ebc4 1222 	rsb	r2, r4, r2, asr #4
   30b78:	4611      	mov	r1, r2
   30b7a:	657a      	str	r2, [r7, #84]	; 0x54
   30b7c:	4589      	cmp	r9, r1
        st->mode = MODE_SILK_ONLY;
   30b7e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   30b82:	f8c8 20dc 	str.w	r2, [r8, #220]	; 0xdc
    if ((frame_size > st->Fs/50 && (st->mode != MODE_SILK_ONLY)) || frame_size > 3*st->Fs/50)
   30b86:	f73f abe6 	bgt.w	30356 <opus_encode_native+0x8e6>
   30b8a:	6cba      	ldr	r2, [r7, #72]	; 0x48
   30b8c:	0050      	lsls	r0, r2, #1
   30b8e:	f7ff bbe5 	b.w	3035c <opus_encode_native+0x8ec>
   30b92:	2203      	movs	r2, #3
             packet_code = 3;
   30b94:	4611      	mov	r1, r2
             num_multiframes = 50/frame_rate;
   30b96:	2005      	movs	r0, #5
             frame_rate = 50;
   30b98:	f04f 0a32 	mov.w	sl, #50	; 0x32
   30b9c:	f240 434f 	movw	r3, #1103	; 0x44f
   30ba0:	429d      	cmp	r5, r3
   30ba2:	bfa8      	it	ge
   30ba4:	461d      	movge	r5, r3
       data[0] = gen_toc(tocmode, frame_rate, bw, st->stream_channels);
   30ba6:	f8d8 40bc 	ldr.w	r4, [r8, #188]	; 0xbc
   30baa:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
   30bae:	f7ff b842 	b.w	2fc36 <opus_encode_native+0x1c6>
    if (st->mode == MODE_HYBRID && curr_bandwidth <= OPUS_BANDWIDTH_WIDEBAND)
   30bb2:	f240 32e9 	movw	r2, #1001	; 0x3e9
   30bb6:	4293      	cmp	r3, r2
   30bb8:	f47f abbc 	bne.w	30334 <opus_encode_native+0x8c4>
   30bbc:	f5b1 6f8a 	cmp.w	r1, #1104	; 0x450
   30bc0:	f6bf ac8b 	bge.w	304da <opus_encode_native+0xa6a>
   30bc4:	e7cf      	b.n	30b66 <opus_encode_native+0x10f6>
       voice_est = 48;
   30bc6:	f5b6 6f00 	cmp.w	r6, #2048	; 0x800
   30bca:	bf0c      	ite	eq
   30bcc:	2173      	moveq	r1, #115	; 0x73
   30bce:	2130      	movne	r1, #48	; 0x30
   30bd0:	63f9      	str	r1, [r7, #60]	; 0x3c
   30bd2:	f7ff b951 	b.w	2fe78 <opus_encode_native+0x408>
        celt_to_silk = (st->mode != MODE_CELT_ONLY);
   30bd6:	2101      	movs	r1, #1
   30bd8:	6139      	str	r1, [r7, #16]
        redundancy = 1;
   30bda:	62f9      	str	r1, [r7, #44]	; 0x2c
   30bdc:	f7ff b9a0 	b.w	2ff20 <opus_encode_native+0x4b0>
         equiv = equiv*4/5;
   30be0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   30be2:	4a69      	ldr	r2, [pc, #420]	; (30d88 <opus_encode_native+0x1318>)
   30be4:	009b      	lsls	r3, r3, #2
   30be6:	fb82 1203 	smull	r1, r2, r2, r3
   30bea:	17db      	asrs	r3, r3, #31
   30bec:	ebc3 0362 	rsb	r3, r3, r2, asr #1
   30bf0:	653b      	str	r3, [r7, #80]	; 0x50
   30bf2:	e43c      	b.n	3046e <opus_encode_native+0x9fe>
    if (st->lfe)
   30bf4:	f8d8 10b0 	ldr.w	r1, [r8, #176]	; 0xb0
        st->bandwidth = OPUS_BANDWIDTH_WIDEBAND;
   30bf8:	f240 424f 	movw	r2, #1103	; 0x44f
   30bfc:	f8c8 20ec 	str.w	r2, [r8, #236]	; 0xec
    if (st->lfe)
   30c00:	2900      	cmp	r1, #0
   30c02:	f47f ac65 	bne.w	304d0 <opus_encode_native+0xa60>
    if ((frame_size > st->Fs/50 && (st->mode != MODE_SILK_ONLY)) || frame_size > 3*st->Fs/50)
   30c06:	f8d8 1090 	ldr.w	r1, [r8, #144]	; 0x90
   30c0a:	485e      	ldr	r0, [pc, #376]	; (30d84 <opus_encode_native+0x1314>)
   30c0c:	64b9      	str	r1, [r7, #72]	; 0x48
   30c0e:	17cc      	asrs	r4, r1, #31
   30c10:	fb80 5101 	smull	r5, r1, r0, r1
   30c14:	ebc4 1121 	rsb	r1, r4, r1, asr #4
   30c18:	4589      	cmp	r9, r1
   30c1a:	6579      	str	r1, [r7, #84]	; 0x54
   30c1c:	f73f ac8b 	bgt.w	30536 <opus_encode_native+0xac6>
   30c20:	6cb9      	ldr	r1, [r7, #72]	; 0x48
   30c22:	eb01 0141 	add.w	r1, r1, r1, lsl #1
   30c26:	fb80 4001 	smull	r4, r0, r0, r1
   30c2a:	17c9      	asrs	r1, r1, #31
   30c2c:	ebc1 1120 	rsb	r1, r1, r0, asr #4
   30c30:	4589      	cmp	r9, r1
   30c32:	f73f ac80 	bgt.w	30536 <opus_encode_native+0xac6>
   30c36:	64fa      	str	r2, [r7, #76]	; 0x4c
    if (st->silk_bw_switch)
   30c38:	f8d8 20f4 	ldr.w	r2, [r8, #244]	; 0xf4
   30c3c:	f8d8 10a0 	ldr.w	r1, [r8, #160]	; 0xa0
   30c40:	63ba      	str	r2, [r7, #56]	; 0x38
   30c42:	6579      	str	r1, [r7, #84]	; 0x54
   30c44:	2a00      	cmp	r2, #0
   30c46:	f000 8603 	beq.w	31850 <opus_encode_native+0x1de0>
    if (st->mode == MODE_CELT_ONLY)
   30c4a:	f240 31ea 	movw	r1, #1002	; 0x3ea
       st->silk_bw_switch = 0;
   30c4e:	2200      	movs	r2, #0
    if (st->mode == MODE_CELT_ONLY)
   30c50:	428b      	cmp	r3, r1
       st->silk_bw_switch = 0;
   30c52:	f8c8 20f4 	str.w	r2, [r8, #244]	; 0xf4
    if (st->mode == MODE_CELT_ONLY)
   30c56:	f47f ab95 	bne.w	30384 <opus_encode_native+0x914>
       prefill=2;
   30c5a:	2401      	movs	r4, #1
   30c5c:	2302      	movs	r3, #2
    int redundancy_bytes = 0; /* Number of bytes to use for redundancy frame */
   30c5e:	62fa      	str	r2, [r7, #44]	; 0x2c
        redundancy = 0;
   30c60:	63ba      	str	r2, [r7, #56]	; 0x38
    if (st->mode == MODE_CELT_ONLY)
   30c62:	f8c7 b01c 	str.w	fp, [r7, #28]
       prefill=2;
   30c66:	e9c7 4304 	strd	r4, r3, [r7, #16]
   30c6a:	e5d2      	b.n	30812 <opus_encode_native+0xda2>
        silk_InitEncoder( silk_enc, st->arch, &dummy);
   30c6c:	f107 038c 	add.w	r3, r7, #140	; 0x8c
   30c70:	461a      	mov	r2, r3
   30c72:	f8d8 10b4 	ldr.w	r1, [r8, #180]	; 0xb4
   30c76:	69b8      	ldr	r0, [r7, #24]
   30c78:	663b      	str	r3, [r7, #96]	; 0x60
   30c7a:	f7dd fa47 	bl	e10c <silk_InitEncoder>
   30c7e:	f8d8 30dc 	ldr.w	r3, [r8, #220]	; 0xdc
   30c82:	64fb      	str	r3, [r7, #76]	; 0x4c
   30c84:	f8d8 3028 	ldr.w	r3, [r8, #40]	; 0x28
   30c88:	633b      	str	r3, [r7, #48]	; 0x30
        prefill=1;
   30c8a:	2301      	movs	r3, #1
   30c8c:	f8d8 4090 	ldr.w	r4, [r8, #144]	; 0x90
   30c90:	617b      	str	r3, [r7, #20]
   30c92:	e403      	b.n	3049c <opus_encode_native+0xa2c>
         out[channels*i+c] = EXTRACT16(SATURATE(PSHR32(y, 14), 32767));
   30c94:	4b3d      	ldr	r3, [pc, #244]	; (30d8c <opus_encode_native+0x131c>)
   30c96:	e643      	b.n	30920 <opus_encode_native+0xeb0>
      st->prev_channels = st->stream_channels;
   30c98:	f8c8 30e4 	str.w	r3, [r8, #228]	; 0xe4
   30c9c:	e4a7      	b.n	305ee <opus_encode_native+0xb7e>
   for (i=0;i<nb_frames;i++)
   30c9e:	f04f 0900 	mov.w	r9, #0
         st->user_forced_mode = MODE_CELT_ONLY;
   30ca2:	f8c7 a05c 	str.w	sl, [r7, #92]	; 0x5c
      st->silk_mode.toMono = 0;
   30ca6:	464d      	mov	r5, r9
         st->user_forced_mode = MODE_CELT_ONLY;
   30ca8:	f8d7 a054 	ldr.w	sl, [r7, #84]	; 0x54
   30cac:	66fe      	str	r6, [r7, #108]	; 0x6c
   30cae:	e007      	b.n	30cc0 <opus_encode_native+0x1250>
      ret = opus_repacketizer_cat(rp, tmp_data+i*bytes_per_frame, tmp_len);
   30cb0:	f002 f87e 	bl	32db0 <opus_repacketizer_cat>
      if (ret<0)
   30cb4:	2800      	cmp	r0, #0
   30cb6:	f6ff acdc 	blt.w	30672 <opus_encode_native+0xc02>
   for (i=0;i<nb_frames;i++)
   30cba:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   30cbc:	454b      	cmp	r3, r9
   30cbe:	d040      	beq.n	30d42 <opus_encode_native+0x12d2>
      st->nonfinal_frame = i<(nb_frames-1);
   30cc0:	45d9      	cmp	r9, fp
   30cc2:	bfb4      	ite	lt
   30cc4:	2101      	movlt	r1, #1
   30cc6:	2100      	movge	r1, #0
   30cc8:	f8c8 1890 	str.w	r1, [r8, #2192]	; 0x890
      tmp_len = opus_encode_native(st, pcm+i*(st->channels*frame_size), frame_size,
   30ccc:	f8d7 6200 	ldr.w	r6, [r7, #512]	; 0x200
      st->silk_mode.toMono = 0;
   30cd0:	f8c8 5044 	str.w	r5, [r8, #68]	; 0x44
         st->user_forced_mode = MODE_CELT_ONLY;
   30cd4:	bf04      	itt	eq
   30cd6:	f240 31ea 	movweq	r1, #1002	; 0x3ea
   30cda:	f8c8 1088 	streq.w	r1, [r8, #136]	; 0x88
      tmp_len = opus_encode_native(st, pcm+i*(st->channels*frame_size), frame_size,
   30cde:	f8d8 1070 	ldr.w	r1, [r8, #112]	; 0x70
   30ce2:	9608      	str	r6, [sp, #32]
   30ce4:	6e7e      	ldr	r6, [r7, #100]	; 0x64
   30ce6:	e9cd 5506 	strd	r5, r5, [sp, #24]
   30cea:	e9cd 5504 	strd	r5, r5, [sp, #16]
   30cee:	e9cd 5502 	strd	r5, r5, [sp, #8]
   30cf2:	fb01 f10a 	mul.w	r1, r1, sl
   30cf6:	fb09 f101 	mul.w	r1, r9, r1
   30cfa:	eb06 0141 	add.w	r1, r6, r1, lsl #1
   30cfe:	6dbe      	ldr	r6, [r7, #88]	; 0x58
   30d00:	9601      	str	r6, [sp, #4]
   30d02:	6efe      	ldr	r6, [r7, #108]	; 0x6c
   30d04:	9600      	str	r6, [sp, #0]
   30d06:	4623      	mov	r3, r4
   30d08:	4652      	mov	r2, sl
   30d0a:	4640      	mov	r0, r8
   30d0c:	f7fe feb0 	bl	2fa70 <opus_encode_native>
      if (tmp_len<0)
   30d10:	1e02      	subs	r2, r0, #0
      ret = opus_repacketizer_cat(rp, tmp_data+i*bytes_per_frame, tmp_len);
   30d12:	4621      	mov	r1, r4
   for (i=0;i<nb_frames;i++)
   30d14:	f109 0901 	add.w	r9, r9, #1
      ret = opus_repacketizer_cat(rp, tmp_data+i*bytes_per_frame, tmp_len);
   30d18:	6e38      	ldr	r0, [r7, #96]	; 0x60
   30d1a:	4434      	add	r4, r6
      if (tmp_len<0)
   30d1c:	dac8      	bge.n	30cb0 <opus_encode_native+0x1240>
   30d1e:	e4a8      	b.n	30672 <opus_encode_native+0xc02>
   if (frame_rate > 50)
   30d20:	461d      	mov	r5, r3
   30d22:	f7ff b84e 	b.w	2fdc2 <opus_encode_native+0x352>
        if (st->channels==2 && st->force_channels!=1)
   30d26:	f8d8 5078 	ldr.w	r5, [r8, #120]	; 0x78
           music_bandwidth_thresholds = stereo_music_bandwidth_thresholds;
   30d2a:	4a19      	ldr	r2, [pc, #100]	; (30d90 <opus_encode_native+0x1320>)
   30d2c:	4819      	ldr	r0, [pc, #100]	; (30d94 <opus_encode_native+0x1324>)
   30d2e:	491a      	ldr	r1, [pc, #104]	; (30d98 <opus_encode_native+0x1328>)
   30d30:	4b1a      	ldr	r3, [pc, #104]	; (30d9c <opus_encode_native+0x132c>)
   30d32:	2d01      	cmp	r5, #1
   30d34:	bf0b      	itete	eq
   30d36:	4696      	moveq	lr, r2
   30d38:	4686      	movne	lr, r0
   30d3a:	468c      	moveq	ip, r1
   30d3c:	469c      	movne	ip, r3
   30d3e:	f7ff b94a 	b.w	2ffd6 <opus_encode_native+0x566>
   30d42:	469a      	mov	sl, r3
   ret = opus_repacketizer_out_range_impl(rp, 0, nb_frames, data, repacketize_len, 0, !st->use_vbr);
   30d44:	f8d8 4094 	ldr.w	r4, [r8, #148]	; 0x94
   30d48:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
   30d4c:	9300      	str	r3, [sp, #0]
   30d4e:	fab4 f484 	clz	r4, r4
   30d52:	2100      	movs	r1, #0
   30d54:	0964      	lsrs	r4, r4, #5
   30d56:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   30d58:	6e38      	ldr	r0, [r7, #96]	; 0x60
   30d5a:	4652      	mov	r2, sl
   30d5c:	e9cd 1401 	strd	r1, r4, [sp, #4]
   30d60:	f002 f86e 	bl	32e40 <opus_repacketizer_out_range_impl>
   if (ret<0)
   30d64:	2800      	cmp	r0, #0
   30d66:	f6ff ac84 	blt.w	30672 <opus_encode_native+0xc02>
   st->user_forced_mode = bak_mode;
   30d6a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   30d6c:	f8c8 3088 	str.w	r3, [r8, #136]	; 0x88
   st->user_bandwidth = bak_bandwidth;
   30d70:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   30d72:	f8c8 3080 	str.w	r3, [r8, #128]	; 0x80
   st->force_channels = bak_channels;
   30d76:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   30d78:	f8c8 3078 	str.w	r3, [r8, #120]	; 0x78
   st->silk_mode.toMono = bak_to_mono;
   30d7c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   30d7e:	f8c8 3044 	str.w	r3, [r8, #68]	; 0x44
   30d82:	e478      	b.n	30676 <opus_encode_native+0xc06>
   30d84:	51eb851f 	.word	0x51eb851f
   30d88:	66666667 	.word	0x66666667
   30d8c:	ffff8001 	.word	0xffff8001
   30d90:	0003b5f8 	.word	0x0003b5f8
   30d94:	0003b6c4 	.word	0x0003b6c4
   30d98:	0003b618 	.word	0x0003b618
   30d9c:	0003b6e4 	.word	0x0003b6e4
       mode_music = (opus_int32)(MULT16_32_Q15(Q15ONE-stereo_width,mode_thresholds[1][1])
   30da0:	f242 7e10 	movw	lr, #10000	; 0x2710
             + MULT16_32_Q15(stereo_width,mode_thresholds[1][1]));
   30da4:	fb10 f10e 	smulbb	r1, r0, lr
   30da8:	63b9      	str	r1, [r7, #56]	; 0x38
             + MULT16_32_Q15(stereo_width,mode_thresholds[1][0]));
   30daa:	f64a 31e0 	movw	r1, #44000	; 0xabe0
       mode_voice = (opus_int32)(MULT16_32_Q15(Q15ONE-stereo_width,mode_thresholds[0][0])
   30dae:	f5c0 4cff 	rsb	ip, r0, #32640	; 0x7f80
             + MULT16_32_Q15(stereo_width,mode_thresholds[1][0]));
   30db2:	fb01 f000 	mul.w	r0, r1, r0
             + MULT16_32_Q15(stereo_width,mode_thresholds[1][1]));
   30db6:	6bb9      	ldr	r1, [r7, #56]	; 0x38
       mode_voice = (opus_int32)(MULT16_32_Q15(Q15ONE-stereo_width,mode_thresholds[0][0])
   30db8:	f10c 0c7f 	add.w	ip, ip, #127	; 0x7f
             + MULT16_32_Q15(stereo_width,mode_thresholds[1][1]));
   30dbc:	13c9      	asrs	r1, r1, #15
       mode_voice = (opus_int32)(MULT16_32_Q15(Q15ONE-stereo_width,mode_thresholds[0][0])
   30dbe:	fa0f fc8c 	sxth.w	ip, ip
             + MULT16_32_Q15(stereo_width,mode_thresholds[1][1]));
   30dc2:	63b9      	str	r1, [r7, #56]	; 0x38
       mode_voice = (opus_int32)(MULT16_32_Q15(Q15ONE-stereo_width,mode_thresholds[0][0])
   30dc4:	f44f 417a 	mov.w	r1, #64000	; 0xfa00
       mode_music = (opus_int32)(MULT16_32_Q15(Q15ONE-stereo_width,mode_thresholds[1][1])
   30dc8:	fb1c fe0e 	smulbb	lr, ip, lr
       mode_voice = (opus_int32)(MULT16_32_Q15(Q15ONE-stereo_width,mode_thresholds[0][0])
   30dcc:	fb01 fc0c 	mul.w	ip, r1, ip
       mode_music = (opus_int32)(MULT16_32_Q15(Q15ONE-stereo_width,mode_thresholds[1][1])
   30dd0:	6bb9      	ldr	r1, [r7, #56]	; 0x38
             + MULT16_32_Q15(stereo_width,mode_thresholds[1][0]));
   30dd2:	13c0      	asrs	r0, r0, #15
       mode_music = (opus_int32)(MULT16_32_Q15(Q15ONE-stereo_width,mode_thresholds[1][1])
   30dd4:	eb01 31ee 	add.w	r1, r1, lr, asr #15
       mode_voice = (opus_int32)(MULT16_32_Q15(Q15ONE-stereo_width,mode_thresholds[0][0])
   30dd8:	eb00 30ec 	add.w	r0, r0, ip, asr #15
       threshold = mode_music + ((voice_est*voice_est*(mode_voice-mode_music))>>14);
   30ddc:	eba0 0e01 	sub.w	lr, r0, r1
   30de0:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
   30de2:	fb00 fc00 	mul.w	ip, r0, r0
   30de6:	fb0c fc0e 	mul.w	ip, ip, lr
       if (st->prev_mode == MODE_CELT_ONLY)
   30dea:	f8d8 00e0 	ldr.w	r0, [r8, #224]	; 0xe0
       threshold = mode_music + ((voice_est*voice_est*(mode_voice-mode_music))>>14);
   30dee:	eb01 3cac 	add.w	ip, r1, ip, asr #14
       if (st->application == OPUS_APPLICATION_VOIP)
   30df2:	f5b6 6f00 	cmp.w	r6, #2048	; 0x800
       if (st->prev_mode == MODE_CELT_ONLY)
   30df6:	f240 31ea 	movw	r1, #1002	; 0x3ea
          threshold += 8000;
   30dfa:	bf08      	it	eq
   30dfc:	f50c 5cfa 	addeq.w	ip, ip, #8000	; 0x1f40
       if (st->prev_mode == MODE_CELT_ONLY)
   30e00:	4288      	cmp	r0, r1
   30e02:	4686      	mov	lr, r0
   30e04:	f000 852f 	beq.w	31866 <opus_encode_native+0x1df6>
       else if (st->prev_mode>0)
   30e08:	2800      	cmp	r0, #0
           threshold += 4000;
   30e0a:	bfc8      	it	gt
   30e0c:	f50c 6c7a 	addgt.w	ip, ip, #4000	; 0xfa0
       if (st->silk_mode.useInBandFEC && st->silk_mode.packetLossPercentage > (128-voice_est)>>4)
   30e10:	f8d8 1030 	ldr.w	r1, [r8, #48]	; 0x30
   30e14:	63b9      	str	r1, [r7, #56]	; 0x38
   equiv = equiv * (90+complexity)/100;
   30e16:	6c39      	ldr	r1, [r7, #64]	; 0x40
   30e18:	4e26      	ldr	r6, [pc, #152]	; (30eb4 <opus_encode_native+0x1444>)
   30e1a:	fb05 f501 	mul.w	r5, r5, r1
   30e1e:	fb86 1605 	smull	r1, r6, r6, r5
   30e22:	17ed      	asrs	r5, r5, #31
   30e24:	ebc5 1566 	rsb	r5, r5, r6, asr #5
      equiv -= equiv*loss/(12*loss + 20);
   30e28:	6cbe      	ldr	r6, [r7, #72]	; 0x48
   30e2a:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
   30e2c:	fb06 f605 	mul.w	r6, r6, r5
   30e30:	fb96 f6f1 	sdiv	r6, r6, r1
       if (st->silk_mode.useInBandFEC && st->silk_mode.packetLossPercentage > (128-voice_est)>>4)
   30e34:	6bb9      	ldr	r1, [r7, #56]	; 0x38
      equiv -= equiv*loss/(12*loss + 20);
   30e36:	1bad      	subs	r5, r5, r6
       st->mode = (equiv_rate >= threshold) ? MODE_CELT_ONLY: MODE_SILK_ONLY;
   30e38:	f240 36ea 	movw	r6, #1002	; 0x3ea
   30e3c:	45ac      	cmp	ip, r5
   30e3e:	bfd4      	ite	le
   30e40:	4635      	movle	r5, r6
   30e42:	f44f 757a 	movgt.w	r5, #1000	; 0x3e8
   30e46:	f8c8 50dc 	str.w	r5, [r8, #220]	; 0xdc
       if (st->silk_mode.useInBandFEC && st->silk_mode.packetLossPercentage > (128-voice_est)>>4)
   30e4a:	b151      	cbz	r1, 30e62 <opus_encode_native+0x13f2>
   30e4c:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
   30e4e:	6cbe      	ldr	r6, [r7, #72]	; 0x48
   30e50:	f1c1 0180 	rsb	r1, r1, #128	; 0x80
   30e54:	ebb6 1f21 	cmp.w	r6, r1, asr #4
          st->mode = MODE_SILK_ONLY;
   30e58:	bfc4      	itt	gt
   30e5a:	f44f 717a 	movgt.w	r1, #1000	; 0x3e8
   30e5e:	f8c8 10dc 	strgt.w	r1, [r8, #220]	; 0xdc
       st->silk_mode.useDTX = st->use_dtx;
   30e62:	f8d8 10b8 	ldr.w	r1, [r8, #184]	; 0xb8
   30e66:	f8c8 1038 	str.w	r1, [r8, #56]	; 0x38
       if (st->silk_mode.useDTX && voice_est > 100)
   30e6a:	b131      	cbz	r1, 30e7a <opus_encode_native+0x140a>
   30e6c:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
   30e6e:	2964      	cmp	r1, #100	; 0x64
          st->mode = MODE_SILK_ONLY;
   30e70:	bfc4      	itt	gt
   30e72:	f44f 717a 	movgt.w	r1, #1000	; 0x3e8
   30e76:	f8c8 10dc 	strgt.w	r1, [r8, #220]	; 0xdc
       if (max_data_bytes < (frame_rate > 50 ? 9000 : 6000)*frame_size / (st->Fs * 8))
   30e7a:	f242 3528 	movw	r5, #9000	; 0x2328
   30e7e:	f241 7170 	movw	r1, #6000	; 0x1770
   30e82:	f1ba 0f32 	cmp.w	sl, #50	; 0x32
   30e86:	bfc8      	it	gt
   30e88:	4629      	movgt	r1, r5
   30e8a:	fb09 f101 	mul.w	r1, r9, r1
   30e8e:	00e5      	lsls	r5, r4, #3
   30e90:	fb91 f1f5 	sdiv	r1, r1, r5
   30e94:	4559      	cmp	r1, fp
   30e96:	f300 8367 	bgt.w	31568 <opus_encode_native+0x1af8>
   30e9a:	f8d8 10dc 	ldr.w	r1, [r8, #220]	; 0xdc
   30e9e:	f7ff b81d 	b.w	2fedc <opus_encode_native+0x46c>
        st->stream_channels = st->force_channels;
   30ea2:	f8c8 10bc 	str.w	r1, [r8, #188]	; 0xbc
   30ea6:	6539      	str	r1, [r7, #80]	; 0x50
   30ea8:	f7fe bff3 	b.w	2fe92 <opus_encode_native+0x422>
       voice_est = 0;
   30eac:	2100      	movs	r1, #0
   30eae:	63f9      	str	r1, [r7, #60]	; 0x3c
   30eb0:	f7fe bfe2 	b.w	2fe78 <opus_encode_native+0x408>
   30eb4:	51eb851f 	.word	0x51eb851f
   30eb8:	f103 052a 	add.w	r5, r3, #42	; 0x2a
           for (c=0;c<st->channels;c++)
   30ebc:	42aa      	cmp	r2, r5
   30ebe:	f47f adc7 	bne.w	30a50 <opus_encode_native+0xfe0>
   30ec2:	68b9      	ldr	r1, [r7, #8]
   30ec4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   30ec6:	fb94 f3f3 	sdiv	r3, r4, r3
   30eca:	fb13 f301 	smulbb	r3, r3, r1
   30ece:	33cd      	adds	r3, #205	; 0xcd
   30ed0:	69f9      	ldr	r1, [r7, #28]
   30ed2:	b21b      	sxth	r3, r3
   30ed4:	fb01 f103 	mul.w	r1, r1, r3
   30ed8:	e9d7 2e00 	ldrd	r2, lr, [r7]
   30edc:	f501 7300 	add.w	r3, r1, #512	; 0x200
   30ee0:	129b      	asrs	r3, r3, #10
           rate_offset = MAX32(rate_offset, -2*st->silk_mode.bitRate/3);
   30ee2:	6db9      	ldr	r1, [r7, #88]	; 0x58
   30ee4:	ebc1 70c1 	rsb	r0, r1, r1, lsl #31
   30ee8:	49d6      	ldr	r1, [pc, #856]	; (31244 <opus_encode_native+0x17d4>)
   30eea:	0040      	lsls	r0, r0, #1
   30eec:	fb81 4100 	smull	r4, r1, r1, r0
           if (st->bandwidth==OPUS_BANDWIDTH_SUPERWIDEBAND || st->bandwidth==OPUS_BANDWIDTH_FULLBAND)
   30ef0:	68fc      	ldr	r4, [r7, #12]
           rate_offset = MAX32(rate_offset, -2*st->silk_mode.bitRate/3);
   30ef2:	eba1 71e0 	sub.w	r1, r1, r0, asr #31
   30ef6:	4299      	cmp	r1, r3
           if (st->bandwidth==OPUS_BANDWIDTH_SUPERWIDEBAND || st->bandwidth==OPUS_BANDWIDTH_FULLBAND)
   30ef8:	f5a4 648a 	sub.w	r4, r4, #1104	; 0x450
           rate_offset = MAX32(rate_offset, -2*st->silk_mode.bitRate/3);
   30efc:	bfb8      	it	lt
   30efe:	4619      	movlt	r1, r3
           if (st->bandwidth==OPUS_BANDWIDTH_SUPERWIDEBAND || st->bandwidth==OPUS_BANDWIDTH_FULLBAND)
   30f00:	2c01      	cmp	r4, #1
   30f02:	d807      	bhi.n	30f14 <opus_encode_native+0x14a4>
              st->silk_mode.bitRate += 3*rate_offset/5;
   30f04:	4cd0      	ldr	r4, [pc, #832]	; (31248 <opus_encode_native+0x17d8>)
   30f06:	eb01 0141 	add.w	r1, r1, r1, lsl #1
   30f0a:	fb84 3401 	smull	r3, r4, r4, r1
   30f0e:	17c9      	asrs	r1, r1, #31
   30f10:	ebc1 0164 	rsb	r1, r1, r4, asr #1
              st->silk_mode.bitRate += rate_offset;
   30f14:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   30f16:	4419      	add	r1, r3
   30f18:	f647 73ff 	movw	r3, #32767	; 0x7fff
   30f1c:	f8c8 1024 	str.w	r1, [r8, #36]	; 0x24
   30f20:	65bb      	str	r3, [r7, #88]	; 0x58
        st->silk_mode.nChannelsAPI = st->channels;
   30f22:	6d78      	ldr	r0, [r7, #84]	; 0x54
   30f24:	f8c8 0008 	str.w	r0, [r8, #8]
        st->silk_mode.payloadSize_ms = 1000 * frame_size / st->Fs;
   30f28:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
        st->silk_mode.nChannelsInternal = st->stream_channels;
   30f2c:	6cb8      	ldr	r0, [r7, #72]	; 0x48
   30f2e:	f8c8 000c 	str.w	r0, [r8, #12]
        st->silk_mode.payloadSize_ms = 1000 * frame_size / st->Fs;
   30f32:	fb03 f309 	mul.w	r3, r3, r9
   30f36:	6e78      	ldr	r0, [r7, #100]	; 0x64
   30f38:	fb93 f3f0 	sdiv	r3, r3, r0
   30f3c:	f8c8 3020 	str.w	r3, [r8, #32]
        if (curr_bandwidth == OPUS_BANDWIDTH_NARROWBAND) {
   30f40:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   30f42:	f240 414d 	movw	r1, #1101	; 0x44d
   30f46:	428b      	cmp	r3, r1
   30f48:	f000 8497 	beq.w	3187a <opus_encode_native+0x1e0a>
   30f4c:	4619      	mov	r1, r3
        } else if (curr_bandwidth == OPUS_BANDWIDTH_MEDIUMBAND) {
   30f4e:	f240 434e 	movw	r3, #1102	; 0x44e
   30f52:	4299      	cmp	r1, r3
            st->silk_mode.desiredInternalSampleRate = 12000;
   30f54:	bf0c      	ite	eq
   30f56:	f642 63e0 	movweq	r3, #12000	; 0x2ee0
            st->silk_mode.desiredInternalSampleRate = 16000;
   30f5a:	f44f 537a 	movne.w	r3, #16000	; 0x3e80
   30f5e:	f8c8 301c 	str.w	r3, [r8, #28]
        if( st->mode == MODE_HYBRID ) {
   30f62:	f240 33e9 	movw	r3, #1001	; 0x3e9
   30f66:	459e      	cmp	lr, r3
   30f68:	f000 8481 	beq.w	3186e <opus_encode_native+0x1dfe>
        st->silk_mode.maxInternalSampleRate = 16000;
   30f6c:	f44f 537a 	mov.w	r3, #16000	; 0x3e80
   30f70:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
        if (st->mode == MODE_SILK_ONLY)
   30f74:	f5be 7f7a 	cmp.w	lr, #1000	; 0x3e8
        st->silk_mode.maxInternalSampleRate = 16000;
   30f78:	e9c8 3105 	strd	r3, r1, [r8, #20]
        if (st->mode == MODE_SILK_ONLY)
   30f7c:	d129      	bne.n	30fd2 <opus_encode_native+0x1562>
           if (frame_rate > 50)
   30f7e:	f1ba 0f32 	cmp.w	sl, #50	; 0x32
   30f82:	dd07      	ble.n	30f94 <opus_encode_native+0x1524>
              effective_max_rate = effective_max_rate*2/3;
   30f84:	6abb      	ldr	r3, [r7, #40]	; 0x28
   30f86:	49af      	ldr	r1, [pc, #700]	; (31244 <opus_encode_native+0x17d4>)
   30f88:	005b      	lsls	r3, r3, #1
   30f8a:	fb81 0103 	smull	r0, r1, r1, r3
   30f8e:	eba1 73e3 	sub.w	r3, r1, r3, asr #31
   30f92:	62bb      	str	r3, [r7, #40]	; 0x28
           if (effective_max_rate < 8000)
   30f94:	6abc      	ldr	r4, [r7, #40]	; 0x28
   30f96:	f5b4 5ffa 	cmp.w	r4, #8000	; 0x1f40
   30f9a:	da1a      	bge.n	30fd2 <opus_encode_native+0x1562>
              st->silk_mode.desiredInternalSampleRate = IMIN(12000, st->silk_mode.desiredInternalSampleRate);
   30f9c:	f8d8 301c 	ldr.w	r3, [r8, #28]
              st->silk_mode.maxInternalSampleRate = 12000;
   30fa0:	f642 61e0 	movw	r1, #12000	; 0x2ee0
              st->silk_mode.desiredInternalSampleRate = IMIN(12000, st->silk_mode.desiredInternalSampleRate);
   30fa4:	428b      	cmp	r3, r1
   30fa6:	4618      	mov	r0, r3
              st->silk_mode.maxInternalSampleRate = 12000;
   30fa8:	f8c8 1014 	str.w	r1, [r8, #20]
              st->silk_mode.desiredInternalSampleRate = IMIN(12000, st->silk_mode.desiredInternalSampleRate);
   30fac:	bfa8      	it	ge
   30fae:	4608      	movge	r0, r1
           if (effective_max_rate < 7000)
   30fb0:	f641 3157 	movw	r1, #6999	; 0x1b57
   30fb4:	428c      	cmp	r4, r1
              st->silk_mode.desiredInternalSampleRate = IMIN(12000, st->silk_mode.desiredInternalSampleRate);
   30fb6:	f8c8 001c 	str.w	r0, [r8, #28]
           if (effective_max_rate < 7000)
   30fba:	dc0a      	bgt.n	30fd2 <opus_encode_native+0x1562>
              st->silk_mode.desiredInternalSampleRate = IMIN(8000, st->silk_mode.desiredInternalSampleRate);
   30fbc:	f5b3 5ffa 	cmp.w	r3, #8000	; 0x1f40
   30fc0:	bfa8      	it	ge
   30fc2:	f44f 53fa 	movge.w	r3, #8000	; 0x1f40
              st->silk_mode.maxInternalSampleRate = 8000;
   30fc6:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
              st->silk_mode.desiredInternalSampleRate = IMIN(8000, st->silk_mode.desiredInternalSampleRate);
   30fca:	f8c8 301c 	str.w	r3, [r8, #28]
              st->silk_mode.maxInternalSampleRate = 8000;
   30fce:	f8c8 1014 	str.w	r1, [r8, #20]
        st->silk_mode.maxBits = (max_data_bytes-1)*8;
   30fd2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
        st->silk_mode.useCBR = !st->use_vbr;
   30fd4:	fab2 f182 	clz	r1, r2
   30fd8:	0949      	lsrs	r1, r1, #5
        st->silk_mode.maxBits = (max_data_bytes-1)*8;
   30fda:	00db      	lsls	r3, r3, #3
   30fdc:	e9c8 130f 	strd	r1, r3, [r8, #60]	; 0x3c
        if (redundancy && redundancy_bytes >= 2)
   30fe0:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   30fe2:	2900      	cmp	r1, #0
   30fe4:	f000 823c 	beq.w	31460 <opus_encode_native+0x19f0>
   30fe8:	6bb9      	ldr	r1, [r7, #56]	; 0x38
   30fea:	2901      	cmp	r1, #1
   30fec:	f340 8238 	ble.w	31460 <opus_encode_native+0x19f0>
           st->silk_mode.maxBits -= redundancy_bytes*8 + 1;
   30ff0:	00c9      	lsls	r1, r1, #3
           if (st->mode == MODE_HYBRID)
   30ff2:	f240 30e9 	movw	r0, #1001	; 0x3e9
           st->silk_mode.maxBits -= redundancy_bytes*8 + 1;
   30ff6:	3101      	adds	r1, #1
           if (st->mode == MODE_HYBRID)
   30ff8:	4586      	cmp	lr, r0
           st->silk_mode.maxBits -= redundancy_bytes*8 + 1;
   30ffa:	eba3 0301 	sub.w	r3, r3, r1
           if (st->mode == MODE_HYBRID)
   30ffe:	f001 8032 	beq.w	32066 <opus_encode_native+0x25f6>
              st->silk_mode.maxBits = IMIN(st->silk_mode.maxBits, st->silk_mode.bitRate * frame_size / st->Fs);
   31002:	f8c8 3040 	str.w	r3, [r8, #64]	; 0x40
        if (prefill)
   31006:	697b      	ldr	r3, [r7, #20]
   31008:	f108 0508 	add.w	r5, r8, #8
   3100c:	2b00      	cmp	r3, #0
   3100e:	f040 84be 	bne.w	3198e <opus_encode_native+0x1f1e>
        pcm_silk = pcm_buf+total_buffer*st->channels;
   31012:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   31014:	6d7a      	ldr	r2, [r7, #84]	; 0x54
        ret = silk_Encode( silk_enc, &st->silk_mode, pcm_silk, frame_size, &enc, &nBytes, 0, activity );
   31016:	6c79      	ldr	r1, [r7, #68]	; 0x44
        pcm_silk = pcm_buf+total_buffer*st->channels;
   31018:	fb02 f203 	mul.w	r2, r2, r3
        ret = silk_Encode( silk_enc, &st->silk_mode, pcm_silk, frame_size, &enc, &nBytes, 0, activity );
   3101c:	eb01 0242 	add.w	r2, r1, r2, lsl #1
   31020:	6e39      	ldr	r1, [r7, #96]	; 0x60
   31022:	9100      	str	r1, [sp, #0]
   31024:	2300      	movs	r3, #0
   31026:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   3102a:	f107 0478 	add.w	r4, r7, #120	; 0x78
   3102e:	69b8      	ldr	r0, [r7, #24]
   31030:	9401      	str	r4, [sp, #4]
   31032:	e9cd 3602 	strd	r3, r6, [sp, #8]
   31036:	4629      	mov	r1, r5
   31038:	464b      	mov	r3, r9
   3103a:	f7dd f8cd 	bl	e1d8 <silk_Encode>
        if( ret ) {
   3103e:	2800      	cmp	r0, #0
   31040:	f040 828f 	bne.w	31562 <opus_encode_native+0x1af2>
        if( st->mode == MODE_SILK_ONLY ) {
   31044:	f8d8 10dc 	ldr.w	r1, [r8, #220]	; 0xdc
   31048:	f5b1 7f7a 	cmp.w	r1, #1000	; 0x3e8
   3104c:	f000 8717 	beq.w	31e7e <opus_encode_native+0x240e>
        st->silk_mode.opusCanSwitch = st->silk_mode.switchReady && !st->nonfinal_frame;
   31050:	f8d8 2060 	ldr.w	r2, [r8, #96]	; 0x60
   31054:	6823      	ldr	r3, [r4, #0]
   31056:	2a00      	cmp	r2, #0
   31058:	f000 83b8 	beq.w	317cc <opus_encode_native+0x1d5c>
   3105c:	f8d8 2890 	ldr.w	r2, [r8, #2192]	; 0x890
   31060:	2a00      	cmp	r2, #0
   31062:	f040 83b3 	bne.w	317cc <opus_encode_native+0x1d5c>
   31066:	2201      	movs	r2, #1
   31068:	f8c8 2048 	str.w	r2, [r8, #72]	; 0x48
   3106c:	f8d8 20bc 	ldr.w	r2, [r8, #188]	; 0xbc
        if (nBytes==0)
   31070:	2b00      	cmp	r3, #0
   31072:	f000 83b3 	beq.w	317dc <opus_encode_native+0x1d6c>
   base_bits = (40*channels+20);
   31076:	eb02 0382 	add.w	r3, r2, r2, lsl #2
   3107a:	00db      	lsls	r3, r3, #3
   redundancy_rate = bitrate_bps + base_bits*(200 - frame_rate);
   3107c:	f8d8 10a0 	ldr.w	r1, [r8, #160]	; 0xa0
   redundancy_bytes = redundancy_rate/1600;
   31080:	4d72      	ldr	r5, [pc, #456]	; (3124c <opus_encode_native+0x17dc>)
   base_bits = (40*channels+20);
   31082:	f103 0014 	add.w	r0, r3, #20
   redundancy_rate = bitrate_bps + base_bits*(200 - frame_rate);
   31086:	f1ca 03c8 	rsb	r3, sl, #200	; 0xc8
   3108a:	fb00 1103 	mla	r1, r0, r3, r1
   available_bits = max_data_bytes*8 - 2*base_bits;
   3108e:	ebc0 038b 	rsb	r3, r0, fp, lsl #2
   redundancy_bytes_cap = (available_bits*240/(240+48000/frame_rate) + base_bits)/8;
   31092:	015c      	lsls	r4, r3, #5
   31094:	eba4 0343 	sub.w	r3, r4, r3, lsl #1
   redundancy_rate = 3*redundancy_rate/2;
   31098:	eb01 0141 	add.w	r1, r1, r1, lsl #1
   redundancy_bytes = redundancy_rate/1600;
   3109c:	fb85 4501 	smull	r4, r5, r5, r1
   redundancy_bytes_cap = (available_bits*240/(240+48000/frame_rate) + base_bits)/8;
   310a0:	011b      	lsls	r3, r3, #4
   310a2:	f64b 3480 	movw	r4, #48000	; 0xbb80
   310a6:	fb94 f4fa 	sdiv	r4, r4, sl
   310aa:	34f0      	adds	r4, #240	; 0xf0
   310ac:	fb93 f3f4 	sdiv	r3, r3, r4
   310b0:	181b      	adds	r3, r3, r0
   310b2:	bf48      	it	mi
   310b4:	3307      	addmi	r3, #7
   redundancy_bytes = redundancy_rate/1600;
   310b6:	17c9      	asrs	r1, r1, #31
   redundancy_bytes_cap = (available_bits*240/(240+48000/frame_rate) + base_bits)/8;
   310b8:	10db      	asrs	r3, r3, #3
   redundancy_bytes = redundancy_rate/1600;
   310ba:	ebc1 21a5 	rsb	r1, r1, r5, asr #10
   redundancy_bytes = IMIN(redundancy_bytes, redundancy_bytes_cap);
   310be:	428b      	cmp	r3, r1
   if (redundancy_bytes > 4 + 8*channels)
   310c0:	ea4f 02c2 	mov.w	r2, r2, lsl #3
   redundancy_bytes = IMIN(redundancy_bytes, redundancy_bytes_cap);
   310c4:	bfa8      	it	ge
   310c6:	460b      	movge	r3, r1
   if (redundancy_bytes > 4 + 8*channels)
   310c8:	3204      	adds	r2, #4
   310ca:	4293      	cmp	r3, r2
   310cc:	f341 804b 	ble.w	32166 <opus_encode_native+0x26f6>
      redundancy_bytes = IMIN(257, redundancy_bytes);
   310d0:	f240 1201 	movw	r2, #257	; 0x101
   310d4:	429a      	cmp	r2, r3
   310d6:	bfa8      	it	ge
   310d8:	461a      	movge	r2, r3
   310da:	3300      	adds	r3, #0
   310dc:	bf18      	it	ne
   310de:	2301      	movne	r3, #1
   310e0:	63ba      	str	r2, [r7, #56]	; 0x38
   310e2:	62fb      	str	r3, [r7, #44]	; 0x2c
           st->silk_bw_switch = 1;
   310e4:	2301      	movs	r3, #1
   310e6:	f8c8 30f4 	str.w	r3, [r8, #244]	; 0xf4
           celt_to_silk = 0;
   310ea:	2300      	movs	r3, #0
   310ec:	613b      	str	r3, [r7, #16]
   310ee:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
        celt_encoder_ctl(celt_enc, CELT_SET_END_BAND(endband));
   310f0:	6efc      	ldr	r4, [r7, #108]	; 0x6c
   310f2:	f2a3 434d 	subw	r3, r3, #1101	; 0x44d
   310f6:	2b03      	cmp	r3, #3
   310f8:	bf96      	itet	ls
   310fa:	4a55      	ldrls	r2, [pc, #340]	; (31250 <opus_encode_native+0x17e0>)
        switch(curr_bandwidth)
   310fc:	2215      	movhi	r2, #21
   310fe:	f852 2023 	ldrls.w	r2, [r2, r3, lsl #2]
        celt_encoder_ctl(celt_enc, CELT_SET_END_BAND(endband));
   31102:	f242 711c 	movw	r1, #10012	; 0x271c
   31106:	4620      	mov	r0, r4
   31108:	f7f7 fed0 	bl	28eac <opus_custom_encoder_ctl>
        celt_encoder_ctl(celt_enc, CELT_SET_CHANNELS(st->stream_channels));
   3110c:	f8d8 20bc 	ldr.w	r2, [r8, #188]	; 0xbc
   31110:	f242 7118 	movw	r1, #10008	; 0x2718
   31114:	4620      	mov	r0, r4
   31116:	f7f7 fec9 	bl	28eac <opus_custom_encoder_ctl>
    celt_encoder_ctl(celt_enc, OPUS_SET_BITRATE(OPUS_BITRATE_MAX));
   3111a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   3111e:	f640 71a2 	movw	r1, #4002	; 0xfa2
   31122:	4620      	mov	r0, r4
   31124:	f7f7 fec2 	bl	28eac <opus_custom_encoder_ctl>
    if (st->mode != MODE_SILK_ONLY)
   31128:	f8d8 30dc 	ldr.w	r3, [r8, #220]	; 0xdc
   3112c:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
   31130:	f000 8333 	beq.w	3179a <opus_encode_native+0x1d2a>
        celt_encoder_ctl(celt_enc, OPUS_SET_VBR(0));
   31134:	2200      	movs	r2, #0
   31136:	f640 71a6 	movw	r1, #4006	; 0xfa6
   3113a:	4620      	mov	r0, r4
   3113c:	f7f7 feb6 	bl	28eac <opus_custom_encoder_ctl>
        if (st->silk_mode.reducedDependency)
   31140:	f8d8 304c 	ldr.w	r3, [r8, #76]	; 0x4c
        opus_val32 celt_pred=2;
   31144:	2b00      	cmp	r3, #0
        celt_encoder_ctl(celt_enc, CELT_SET_PREDICTION(celt_pred));
   31146:	bf0c      	ite	eq
   31148:	2202      	moveq	r2, #2
   3114a:	2200      	movne	r2, #0
   3114c:	f242 7112 	movw	r1, #10002	; 0x2712
   31150:	4620      	mov	r0, r4
   31152:	f7f7 feab 	bl	28eac <opus_custom_encoder_ctl>
        if (st->mode == MODE_HYBRID)
   31156:	f8d8 10dc 	ldr.w	r1, [r8, #220]	; 0xdc
   3115a:	f240 33e9 	movw	r3, #1001	; 0x3e9
   3115e:	4299      	cmp	r1, r3
            if( st->use_vbr ) {
   31160:	f8d8 3094 	ldr.w	r3, [r8, #148]	; 0x94
        if (st->mode == MODE_HYBRID)
   31164:	f000 8757 	beq.w	32016 <opus_encode_native+0x25a6>
            if (st->use_vbr)
   31168:	b1b3      	cbz	r3, 31198 <opus_encode_native+0x1728>
                celt_encoder_ctl(celt_enc, OPUS_SET_VBR(1));
   3116a:	6efc      	ldr	r4, [r7, #108]	; 0x6c
   3116c:	2201      	movs	r2, #1
   3116e:	f640 71a6 	movw	r1, #4006	; 0xfa6
   31172:	4620      	mov	r0, r4
   31174:	f7f7 fe9a 	bl	28eac <opus_custom_encoder_ctl>
                celt_encoder_ctl(celt_enc, OPUS_SET_VBR_CONSTRAINT(st->vbr_constraint));
   31178:	f8d8 2098 	ldr.w	r2, [r8, #152]	; 0x98
   3117c:	f640 71b4 	movw	r1, #4020	; 0xfb4
   31180:	4620      	mov	r0, r4
   31182:	f7f7 fe93 	bl	28eac <opus_custom_encoder_ctl>
                celt_encoder_ctl(celt_enc, OPUS_SET_BITRATE(st->bitrate_bps));
   31186:	f640 71a2 	movw	r1, #4002	; 0xfa2
   3118a:	f8d8 20a0 	ldr.w	r2, [r8, #160]	; 0xa0
   3118e:	4620      	mov	r0, r4
   31190:	f7f7 fe8c 	bl	28eac <opus_custom_encoder_ctl>
   31194:	f8d8 10dc 	ldr.w	r1, [r8, #220]	; 0xdc
    ALLOC(tmp_prefill, st->channels*st->Fs/400, opus_val16);
   31198:	f8d8 5070 	ldr.w	r5, [r8, #112]	; 0x70
   3119c:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
   311a0:	482a      	ldr	r0, [pc, #168]	; (3124c <opus_encode_native+0x17dc>)
   311a2:	f8c7 d064 	str.w	sp, [r7, #100]	; 0x64
   311a6:	fb03 f205 	mul.w	r2, r3, r5
   311aa:	fb80 6002 	smull	r6, r0, r0, r2
   311ae:	17d2      	asrs	r2, r2, #31
   311b0:	ebc2 12e0 	rsb	r2, r2, r0, asr #7
   311b4:	0052      	lsls	r2, r2, #1
   311b6:	f102 0008 	add.w	r0, r2, #8
   311ba:	f020 0007 	bic.w	r0, r0, #7
   311be:	ebad 0d00 	sub.w	sp, sp, r0
   311c2:	a80a      	add	r0, sp, #40	; 0x28
    if (st->mode != MODE_SILK_ONLY && st->mode != st->prev_mode && st->prev_mode > 0)
   311c4:	f5b1 7f7a 	cmp.w	r1, #1000	; 0x3e8
   311c8:	f8d8 40ac 	ldr.w	r4, [r8, #172]	; 0xac
    ALLOC(tmp_prefill, st->channels*st->Fs/400, opus_val16);
   311cc:	6578      	str	r0, [r7, #84]	; 0x54
    if (st->mode != MODE_SILK_ONLY && st->mode != st->prev_mode && st->prev_mode > 0)
   311ce:	d016      	beq.n	311fe <opus_encode_native+0x178e>
   311d0:	f8d8 00e0 	ldr.w	r0, [r8, #224]	; 0xe0
   311d4:	4288      	cmp	r0, r1
   311d6:	d012      	beq.n	311fe <opus_encode_native+0x178e>
   311d8:	2800      	cmp	r0, #0
   311da:	dd10      	ble.n	311fe <opus_encode_native+0x178e>
       OPUS_COPY(tmp_prefill, &st->delay_buffer[(st->encoder_buffer-total_buffer-st->Fs/400)*st->channels], st->channels*st->Fs/400);
   311dc:	491b      	ldr	r1, [pc, #108]	; (3124c <opus_encode_native+0x17dc>)
   311de:	fb81 0103 	smull	r0, r1, r1, r3
   311e2:	17db      	asrs	r3, r3, #31
   311e4:	eba3 13e1 	sub.w	r3, r3, r1, asr #7
   311e8:	6df9      	ldr	r1, [r7, #92]	; 0x5c
   311ea:	6d78      	ldr	r0, [r7, #84]	; 0x54
   311ec:	1a61      	subs	r1, r4, r1
   311ee:	4419      	add	r1, r3
   311f0:	fb05 f101 	mul.w	r1, r5, r1
   311f4:	3188      	adds	r1, #136	; 0x88
   311f6:	eb08 0141 	add.w	r1, r8, r1, lsl #1
   311fa:	f7da ff81 	bl	c100 <memcpy>
    if (st->channels*(st->encoder_buffer-(frame_size+total_buffer)) > 0)
   311fe:	6a7e      	ldr	r6, [r7, #36]	; 0x24
   31200:	1ba3      	subs	r3, r4, r6
   31202:	fb05 f303 	mul.w	r3, r5, r3
   31206:	2b00      	cmp	r3, #0
   31208:	f508 7088 	add.w	r0, r8, #272	; 0x110
   3120c:	f340 8506 	ble.w	31c1c <opus_encode_native+0x21ac>
       OPUS_MOVE(st->delay_buffer, &st->delay_buffer[st->channels*frame_size], st->channels*(st->encoder_buffer-frame_size-total_buffer));
   31210:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   31212:	eba4 0409 	sub.w	r4, r4, r9
   31216:	1ae4      	subs	r4, r4, r3
   31218:	fb05 f404 	mul.w	r4, r5, r4
   3121c:	fb05 f109 	mul.w	r1, r5, r9
   31220:	0064      	lsls	r4, r4, #1
   31222:	3188      	adds	r1, #136	; 0x88
   31224:	4622      	mov	r2, r4
   31226:	eb08 0141 	add.w	r1, r8, r1, lsl #1
   3122a:	f003 ff37 	bl	3509c <memmove>
       OPUS_COPY(&st->delay_buffer[st->channels*(st->encoder_buffer-frame_size-total_buffer)],
   3122e:	4632      	mov	r2, r6
   31230:	f504 7088 	add.w	r0, r4, #272	; 0x110
   31234:	fb05 f202 	mul.w	r2, r5, r2
   31238:	4440      	add	r0, r8
   3123a:	0052      	lsls	r2, r2, #1
   3123c:	6c79      	ldr	r1, [r7, #68]	; 0x44
   3123e:	f7da ff5f 	bl	c100 <memcpy>
   31242:	e007      	b.n	31254 <opus_encode_native+0x17e4>
   31244:	55555556 	.word	0x55555556
   31248:	66666667 	.word	0x66666667
   3124c:	51eb851f 	.word	0x51eb851f
   31250:	0003b5c0 	.word	0x0003b5c0
    if( st->prev_HB_gain < Q15ONE || HB_gain < Q15ONE ) {
   31254:	f9b8 20c8 	ldrsh.w	r2, [r8, #200]	; 0xc8
   31258:	f647 73ff 	movw	r3, #32767	; 0x7fff
   3125c:	429a      	cmp	r2, r3
   3125e:	d102      	bne.n	31266 <opus_encode_native+0x17f6>
   31260:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   31262:	4293      	cmp	r3, r2
   31264:	d011      	beq.n	3128a <opus_encode_native+0x181a>
             st->prev_HB_gain, HB_gain, celt_mode->overlap, frame_size, st->channels, celt_mode->window, st->Fs);
   31266:	6f7b      	ldr	r3, [r7, #116]	; 0x74
       gain_fade(pcm_buf, pcm_buf,
   31268:	f8d8 1090 	ldr.w	r1, [r8, #144]	; 0x90
   3126c:	9104      	str	r1, [sp, #16]
   3126e:	6b59      	ldr	r1, [r3, #52]	; 0x34
   31270:	9103      	str	r1, [sp, #12]
   31272:	f8d8 1070 	ldr.w	r1, [r8, #112]	; 0x70
   31276:	e9cd 9101 	strd	r9, r1, [sp, #4]
   3127a:	685b      	ldr	r3, [r3, #4]
   3127c:	9300      	str	r3, [sp, #0]
   3127e:	6c78      	ldr	r0, [r7, #68]	; 0x44
   31280:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   31282:	4601      	mov	r1, r0
   31284:	f7fe f8d8 	bl	2f438 <gain_fade>
   31288:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    if (st->mode != MODE_HYBRID || st->stream_channels==1)
   3128a:	f8d8 e0dc 	ldr.w	lr, [r8, #220]	; 0xdc
    st->prev_HB_gain = HB_gain;
   3128e:	f8a8 30c8 	strh.w	r3, [r8, #200]	; 0xc8
    if (st->mode != MODE_HYBRID || st->stream_channels==1)
   31292:	f240 32e9 	movw	r2, #1001	; 0x3e9
   31296:	4596      	cmp	lr, r2
   31298:	f8d8 30fc 	ldr.w	r3, [r8, #252]	; 0xfc
   3129c:	f000 84f0 	beq.w	31c80 <opus_encode_native+0x2210>
       if (equiv_rate > 32000)
   312a0:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   312a2:	f5b2 4ffa 	cmp.w	r2, #32000	; 0x7d00
   312a6:	f340 84b0 	ble.w	31c0a <opus_encode_native+0x219a>
          st->silk_mode.stereoWidth_Q14 = 16384;
   312aa:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   312ae:	f8c8 205c 	str.w	r2, [r8, #92]	; 0x5c
    if( !st->energy_masking && st->channels == 2 ) {
   312b2:	2b00      	cmp	r3, #0
   312b4:	f000 8552 	beq.w	31d5c <opus_encode_native+0x22ec>
    if ( st->mode != MODE_CELT_ONLY && ec_tell(&enc)+17+20*(st->mode == MODE_HYBRID) <= 8*(max_data_bytes-1))
   312b8:	f240 33ea 	movw	r3, #1002	; 0x3ea
   312bc:	459e      	cmp	lr, r3
   312be:	d018      	beq.n	312f2 <opus_encode_native+0x1882>
  return _this->nbits_total-EC_ILOG(_this->rng);
   312c0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   312c2:	69da      	ldr	r2, [r3, #28]
   312c4:	695b      	ldr	r3, [r3, #20]
   312c6:	fab2 f282 	clz	r2, r2
   312ca:	f1c2 0220 	rsb	r2, r2, #32
   312ce:	f240 31e9 	movw	r1, #1001	; 0x3e9
   312d2:	1a9b      	subs	r3, r3, r2
   312d4:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   312d6:	458e      	cmp	lr, r1
   312d8:	ea4f 02c2 	mov.w	r2, r2, lsl #3
   312dc:	f000 84e1 	beq.w	31ca2 <opus_encode_native+0x2232>
   312e0:	3311      	adds	r3, #17
   312e2:	4293      	cmp	r3, r2
   312e4:	dc05      	bgt.n	312f2 <opus_encode_native+0x1882>
        if (redundancy)
   312e6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   312e8:	2b00      	cmp	r3, #0
   312ea:	f040 86ee 	bne.w	320ca <opus_encode_native+0x265a>
   312ee:	f8d8 e0dc 	ldr.w	lr, [r8, #220]	; 0xdc
       st->silk_bw_switch = 0;
   312f2:	2300      	movs	r3, #0
   312f4:	461e      	mov	r6, r3
   312f6:	62fb      	str	r3, [r7, #44]	; 0x2c
   312f8:	f8c8 30f4 	str.w	r3, [r8, #244]	; 0xf4
    if (st->mode != MODE_CELT_ONLY)start_band=17;
   312fc:	f240 33ea 	movw	r3, #1002	; 0x3ea
   31300:	459e      	cmp	lr, r3
   31302:	f000 850f 	beq.w	31d24 <opus_encode_native+0x22b4>
    if (st->mode == MODE_SILK_ONLY)
   31306:	f5be 7f7a 	cmp.w	lr, #1000	; 0x3e8
   3130a:	f040 8516 	bne.w	31d3a <opus_encode_native+0x22ca>
   3130e:	6e3a      	ldr	r2, [r7, #96]	; 0x60
   31310:	69d3      	ldr	r3, [r2, #28]
   31312:	4610      	mov	r0, r2
   31314:	6952      	ldr	r2, [r2, #20]
   31316:	fab3 f583 	clz	r5, r3
   3131a:	4415      	add	r5, r2
        ret = (ec_tell(&enc)+7)>>3;
   3131c:	3d19      	subs	r5, #25
        ec_enc_done(&enc);
   3131e:	f7f8 fef3 	bl	2a108 <ec_enc_done>
        ret = (ec_tell(&enc)+7)>>3;
   31322:	10ed      	asrs	r5, r5, #3
        nb_compr_bytes = ret;
   31324:	462c      	mov	r4, r5
    if (st->mode != MODE_CELT_ONLY)start_band=17;
   31326:	f04f 0a11 	mov.w	sl, #17
    if (st->mode == MODE_HYBRID) {
   3132a:	f8d8 20dc 	ldr.w	r2, [r8, #220]	; 0xdc
   3132e:	f240 33e9 	movw	r3, #1001	; 0x3e9
   31332:	429a      	cmp	r2, r3
   31334:	f000 85bc 	beq.w	31eb0 <opus_encode_native+0x2440>
    if (redundancy && celt_to_silk)
   31338:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   3133a:	2b00      	cmp	r3, #0
   3133c:	f000 84c9 	beq.w	31cd2 <opus_encode_native+0x2262>
   31340:	693b      	ldr	r3, [r7, #16]
   31342:	2b00      	cmp	r3, #0
   31344:	f040 8126 	bne.w	31594 <opus_encode_native+0x1b24>
    celt_encoder_ctl(celt_enc, CELT_SET_START_BAND(start_band));
   31348:	4652      	mov	r2, sl
   3134a:	f242 711a 	movw	r1, #10010	; 0x271a
   3134e:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
   31350:	f7f7 fdac 	bl	28eac <opus_custom_encoder_ctl>
    if (st->mode != MODE_SILK_ONLY)
   31354:	f8d8 e0dc 	ldr.w	lr, [r8, #220]	; 0xdc
   31358:	f5be 7f7a 	cmp.w	lr, #1000	; 0x3e8
   3135c:	f040 8158 	bne.w	31610 <opus_encode_native+0x1ba0>
        N2 = st->Fs/200;
   31360:	f8d8 a090 	ldr.w	sl, [r8, #144]	; 0x90
   31364:	4a88      	ldr	r2, [pc, #544]	; (31588 <opus_encode_native+0x1b18>)
        celt_encoder_ctl(celt_enc, OPUS_RESET_STATE);
   31366:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
        N2 = st->Fs/200;
   31368:	ea4f 73ea 	mov.w	r3, sl, asr #31
   3136c:	fb82 2a0a 	smull	r2, sl, r2, sl
   31370:	ebc3 12aa 	rsb	r2, r3, sl, asr #6
        celt_encoder_ctl(celt_enc, OPUS_RESET_STATE);
   31374:	f640 71bc 	movw	r1, #4028	; 0xfbc
        N4 = st->Fs/400;
   31378:	ebc3 1aea 	rsb	sl, r3, sl, asr #7
        N2 = st->Fs/200;
   3137c:	65fa      	str	r2, [r7, #92]	; 0x5c
        celt_encoder_ctl(celt_enc, OPUS_RESET_STATE);
   3137e:	f7f7 fd95 	bl	28eac <opus_custom_encoder_ctl>
        celt_encoder_ctl(celt_enc, CELT_SET_START_BAND(0));
   31382:	2200      	movs	r2, #0
   31384:	f242 711a 	movw	r1, #10010	; 0x271a
   31388:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
   3138a:	f7f7 fd8f 	bl	28eac <opus_custom_encoder_ctl>
        celt_encoder_ctl(celt_enc, CELT_SET_PREDICTION(0));
   3138e:	2200      	movs	r2, #0
   31390:	f242 7112 	movw	r1, #10002	; 0x2712
   31394:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
   31396:	f7f7 fd89 	bl	28eac <opus_custom_encoder_ctl>
        celt_encoder_ctl(celt_enc, OPUS_SET_VBR(0));
   3139a:	2200      	movs	r2, #0
   3139c:	f640 71a6 	movw	r1, #4006	; 0xfa6
   313a0:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
   313a2:	f7f7 fd83 	bl	28eac <opus_custom_encoder_ctl>
        celt_encoder_ctl(celt_enc, OPUS_SET_BITRATE(OPUS_BITRATE_MAX));
   313a6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   313aa:	f640 71a2 	movw	r1, #4002	; 0xfa2
   313ae:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
   313b0:	f7f7 fd7c 	bl	28eac <opus_custom_encoder_ctl>
        if (st->mode == MODE_HYBRID)
   313b4:	f8d8 20dc 	ldr.w	r2, [r8, #220]	; 0xdc
   313b8:	f240 33e9 	movw	r3, #1001	; 0x3e9
   313bc:	429a      	cmp	r2, r3
   313be:	f000 87b5 	beq.w	3232c <opus_encode_native+0x28bc>
        celt_encode_with_ec(celt_enc, pcm_buf+st->channels*(frame_size-N2-N4), N4, dummy, 2, NULL);
   313c2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   313c4:	eba9 0303 	sub.w	r3, r9, r3
   313c8:	4619      	mov	r1, r3
   313ca:	f04f 0c00 	mov.w	ip, #0
   313ce:	2002      	movs	r0, #2
   313d0:	eba1 020a 	sub.w	r2, r1, sl
   313d4:	f8d8 3070 	ldr.w	r3, [r8, #112]	; 0x70
   313d8:	65b9      	str	r1, [r7, #88]	; 0x58
   313da:	6c79      	ldr	r1, [r7, #68]	; 0x44
   313dc:	e9cd 0c00 	strd	r0, ip, [sp]
   313e0:	fb03 f302 	mul.w	r3, r3, r2
   313e4:	4652      	mov	r2, sl
   313e6:	f8d7 a06c 	ldr.w	sl, [r7, #108]	; 0x6c
   313ea:	eb01 0143 	add.w	r1, r1, r3, lsl #1
   313ee:	4650      	mov	r0, sl
   313f0:	f107 0380 	add.w	r3, r7, #128	; 0x80
   313f4:	f7f4 f868 	bl	254c8 <celt_encode_with_ec>
        err = celt_encode_with_ec(celt_enc, pcm_buf+st->channels*(frame_size-N2), N2, data+nb_compr_bytes, redundancy_bytes, NULL);
   313f8:	2200      	movs	r2, #0
   313fa:	f8d8 1070 	ldr.w	r1, [r8, #112]	; 0x70
   313fe:	9201      	str	r2, [sp, #4]
   31400:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   31402:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
   31404:	fb01 f103 	mul.w	r1, r1, r3
   31408:	6a3b      	ldr	r3, [r7, #32]
   3140a:	4423      	add	r3, r4
   3140c:	6c7c      	ldr	r4, [r7, #68]	; 0x44
   3140e:	9600      	str	r6, [sp, #0]
   31410:	eb04 0141 	add.w	r1, r4, r1, lsl #1
   31414:	4650      	mov	r0, sl
   31416:	f7f4 f857 	bl	254c8 <celt_encode_with_ec>
        if (err < 0)
   3141a:	2800      	cmp	r0, #0
   3141c:	f280 86d0 	bge.w	321c0 <opus_encode_native+0x2750>
           return OPUS_INTERNAL_ERROR;
   31420:	f06f 0002 	mvn.w	r0, #2
   31424:	f8d7 d064 	ldr.w	sp, [r7, #100]	; 0x64
   31428:	f8d7 d03c 	ldr.w	sp, [r7, #60]	; 0x3c
   3142c:	f7fe bc41 	b.w	2fcb2 <opus_encode_native+0x242>
      if (complexity<5)
   31430:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   31432:	2b04      	cmp	r3, #4
   31434:	dc09      	bgt.n	3144a <opus_encode_native+0x19da>
         equiv = equiv*9/10;
   31436:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   31438:	4a54      	ldr	r2, [pc, #336]	; (3158c <opus_encode_native+0x1b1c>)
   3143a:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
   3143e:	fb82 1203 	smull	r1, r2, r2, r3
   31442:	17db      	asrs	r3, r3, #31
   31444:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
   31448:	653b      	str	r3, [r7, #80]	; 0x50
   3144a:	f8d8 30f8 	ldr.w	r3, [r8, #248]	; 0xf8
   3144e:	64bb      	str	r3, [r7, #72]	; 0x48
    int prefill=0;
   31450:	2300      	movs	r3, #0
   31452:	617b      	str	r3, [r7, #20]
   31454:	f107 038c 	add.w	r3, r7, #140	; 0x8c
   31458:	663b      	str	r3, [r7, #96]	; 0x60
   3145a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   3145c:	f7fe bdb4 	b.w	2ffc8 <opus_encode_native+0x558>
        if (st->silk_mode.useCBR)
   31460:	2a00      	cmp	r2, #0
   31462:	f040 82da 	bne.w	31a1a <opus_encode_native+0x1faa>
           if (st->mode == MODE_HYBRID)
   31466:	f240 32e9 	movw	r2, #1001	; 0x3e9
   3146a:	4596      	cmp	lr, r2
   3146c:	f47f adcb 	bne.w	31006 <opus_encode_native+0x1596>
              st->silk_mode.maxBits = IMIN(st->silk_mode.maxBits, st->silk_mode.bitRate * frame_size / st->Fs);
   31470:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
   31474:	6e79      	ldr	r1, [r7, #100]	; 0x64
   31476:	fb02 f209 	mul.w	r2, r2, r9
   3147a:	fb92 f2f1 	sdiv	r2, r2, r1
   3147e:	4293      	cmp	r3, r2
   31480:	bfa8      	it	ge
   31482:	4613      	movge	r3, r2
   31484:	e5bd      	b.n	31002 <opus_encode_native+0x1592>
       return OPUS_BAD_ARG;
   31486:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   3148a:	f7fe bc12 	b.w	2fcb2 <opus_encode_native+0x242>
   3148e:	f647 73ff 	movw	r3, #32767	; 0x7fff
   31492:	65bb      	str	r3, [r7, #88]	; 0x58
   31494:	e545      	b.n	30f22 <opus_encode_native+0x14b2>
    HB_gain = Q15ONE;
   31496:	f647 73ff 	movw	r3, #32767	; 0x7fff
   3149a:	65bb      	str	r3, [r7, #88]	; 0x58
   3149c:	e627      	b.n	310ee <opus_encode_native+0x167e>
   Fc_Q19 = silk_DIV32_16( silk_SMULBB( SILK_FIX_CONST( 1.5 * 3.14159 / 1000, 19 ), cutoff_Hz ), Fs/1000 );
   3149e:	4a3c      	ldr	r2, [pc, #240]	; (31590 <opus_encode_native+0x1b20>)
       hp_cutoff(pcm, cutoff_Hz, &pcm_buf[total_buffer*st->channels], st->hp_mem, frame_size, st->channels, st->Fs, st->arch);
   314a0:	f8d8 e070 	ldr.w	lr, [r8, #112]	; 0x70
   Fc_Q19 = silk_DIV32_16( silk_SMULBB( SILK_FIX_CONST( 1.5 * 3.14159 / 1000, 19 ), cutoff_Hz ), Fs/1000 );
   314a4:	fb82 1203 	smull	r1, r2, r2, r3
   314a8:	17db      	asrs	r3, r3, #31
   314aa:	f640 11a7 	movw	r1, #2471	; 0x9a7
   314ae:	fb10 f101 	smulbb	r1, r0, r1
   314b2:	ebc3 13a2 	rsb	r3, r3, r2, asr #6
   314b6:	fb91 f3f3 	sdiv	r3, r1, r3
   A_Q28[ 0 ] = silk_SMULWW( r_Q22, silk_SMULWW( Fc_Q19, Fc_Q19 ) - SILK_FIX_CONST( 2.0,  22 ) );
   314ba:	b21e      	sxth	r6, r3
   314bc:	13d8      	asrs	r0, r3, #15
   314be:	b29a      	uxth	r2, r3
   314c0:	fb06 f202 	mul.w	r2, r6, r2
   314c4:	3001      	adds	r0, #1
   314c6:	1040      	asrs	r0, r0, #1
   314c8:	141d      	asrs	r5, r3, #16
   314ca:	1412      	asrs	r2, r2, #16
   r_Q28 = SILK_FIX_CONST( 1.0, 28 ) - silk_MUL( SILK_FIX_CONST( 0.92, 9 ), Fc_Q19 );
   314cc:	f46f 71eb 	mvn.w	r1, #470	; 0x1d6
   A_Q28[ 0 ] = silk_SMULWW( r_Q22, silk_SMULWW( Fc_Q19, Fc_Q19 ) - SILK_FIX_CONST( 2.0,  22 ) );
   314d0:	182c      	adds	r4, r5, r0
   r_Q28 = SILK_FIX_CONST( 1.0, 28 ) - silk_MUL( SILK_FIX_CONST( 0.92, 9 ), Fc_Q19 );
   314d2:	fb01 f103 	mul.w	r1, r1, r3
   A_Q28[ 0 ] = silk_SMULWW( r_Q22, silk_SMULWW( Fc_Q19, Fc_Q19 ) - SILK_FIX_CONST( 2.0,  22 ) );
   314d6:	fb06 2505 	mla	r5, r6, r5, r2
   314da:	fb14 f403 	smulbb	r4, r4, r3
   314de:	fb00 5303 	mla	r3, r0, r3, r5
   r_Q28 = SILK_FIX_CONST( 1.0, 28 ) - silk_MUL( SILK_FIX_CONST( 0.92, 9 ), Fc_Q19 );
   314e2:	f101 5080 	add.w	r0, r1, #268435456	; 0x10000000
   A_Q28[ 0 ] = silk_SMULWW( r_Q22, silk_SMULWW( Fc_Q19, Fc_Q19 ) - SILK_FIX_CONST( 2.0,  22 ) );
   314e6:	4422      	add	r2, r4
   r_Q22  = silk_RSHIFT( r_Q28, 6 );
   314e8:	1184      	asrs	r4, r0, #6
   A_Q28[ 0 ] = silk_SMULWW( r_Q22, silk_SMULWW( Fc_Q19, Fc_Q19 ) - SILK_FIX_CONST( 2.0,  22 ) );
   314ea:	1586      	asrs	r6, r0, #22
   314ec:	b212      	sxth	r2, r2
   314ee:	b2a5      	uxth	r5, r4
   314f0:	fb05 fc02 	mul.w	ip, r5, r2
   314f4:	fb02 f206 	mul.w	r2, r2, r6
   314f8:	eb02 422c 	add.w	r2, r2, ip, asr #16
   314fc:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
   A_Q28[ 1 ] = silk_SMULWW( r_Q22, r_Q22 );
   31500:	fa0f fc84 	sxth.w	ip, r4
   31504:	fb0c f505 	mul.w	r5, ip, r5
   A_Q28[ 0 ] = silk_SMULWW( r_Q22, silk_SMULWW( Fc_Q19, Fc_Q19 ) - SILK_FIX_CONST( 2.0,  22 ) );
   31508:	13db      	asrs	r3, r3, #15
   A_Q28[ 1 ] = silk_SMULWW( r_Q22, r_Q22 );
   3150a:	fb0c fc06 	mul.w	ip, ip, r6
   3150e:	1546      	asrs	r6, r0, #21
   A_Q28[ 0 ] = silk_SMULWW( r_Q22, silk_SMULWW( Fc_Q19, Fc_Q19 ) - SILK_FIX_CONST( 2.0,  22 ) );
   31510:	3301      	adds	r3, #1
   A_Q28[ 1 ] = silk_SMULWW( r_Q22, r_Q22 );
   31512:	3601      	adds	r6, #1
   A_Q28[ 0 ] = silk_SMULWW( r_Q22, silk_SMULWW( Fc_Q19, Fc_Q19 ) - SILK_FIX_CONST( 2.0,  22 ) );
   31514:	105b      	asrs	r3, r3, #1
   A_Q28[ 1 ] = silk_SMULWW( r_Q22, r_Q22 );
   31516:	eb0c 4525 	add.w	r5, ip, r5, asr #16
   3151a:	1076      	asrs	r6, r6, #1
   A_Q28[ 0 ] = silk_SMULWW( r_Q22, silk_SMULWW( Fc_Q19, Fc_Q19 ) - SILK_FIX_CONST( 2.0,  22 ) );
   3151c:	fb04 2303 	mla	r3, r4, r3, r2
   A_Q28[ 1 ] = silk_SMULWW( r_Q22, r_Q22 );
   31520:	fb04 5506 	mla	r5, r4, r6, r5
       hp_cutoff(pcm, cutoff_Hz, &pcm_buf[total_buffer*st->channels], st->hp_mem, frame_size, st->channels, st->Fs, st->arch);
   31524:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
   B_Q28[ 2 ] = r_Q28;
   31526:	f8c7 0088 	str.w	r0, [r7, #136]	; 0x88
   A_Q28[ 1 ] = silk_SMULWW( r_Q22, r_Q22 );
   3152a:	e9c7 351e 	strd	r3, r5, [r7, #120]	; 0x78
       hp_cutoff(pcm, cutoff_Hz, &pcm_buf[total_buffer*st->channels], st->hp_mem, frame_size, st->channels, st->Fs, st->arch);
   3152e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   B_Q28[ 1 ] = silk_LSHIFT( -r_Q28, 1 );
   31530:	f1c1 4170 	rsb	r1, r1, #4026531840	; 0xf0000000
       hp_cutoff(pcm, cutoff_Hz, &pcm_buf[total_buffer*st->channels], st->hp_mem, frame_size, st->channels, st->Fs, st->arch);
   31534:	fb02 f20e 	mul.w	r2, r2, lr
   31538:	eb03 0242 	add.w	r2, r3, r2, lsl #1
   B_Q28[ 1 ] = silk_LSHIFT( -r_Q28, 1 );
   3153c:	0049      	lsls	r1, r1, #1
   B_Q28[ 0 ] = r_Q28;
   3153e:	e9c7 0120 	strd	r0, r1, [r7, #128]	; 0x80
      silk_biquad_alt_stride1( in, B_Q28, A_Q28, hp_mem, out, len );
   31542:	e9cd 2900 	strd	r2, r9, [sp]
   if( channels == 1 ) {
   31546:	f1be 0f01 	cmp.w	lr, #1
      silk_biquad_alt_stride1( in, B_Q28, A_Q28, hp_mem, out, len );
   3154a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   3154c:	6e78      	ldr	r0, [r7, #100]	; 0x64
   3154e:	f107 0278 	add.w	r2, r7, #120	; 0x78
   31552:	f107 0180 	add.w	r1, r7, #128	; 0x80
   if( channels == 1 ) {
   31556:	f000 84a7 	beq.w	31ea8 <opus_encode_native+0x2438>
      silk_biquad_alt_stride2( in, B_Q28, A_Q28, hp_mem, out, len, arch );
   3155a:	f7e6 f8a5 	bl	176a8 <silk_biquad_alt_stride2_c>
   3155e:	f7ff ba0a 	b.w	30976 <opus_encode_native+0xf06>
           return OPUS_INTERNAL_ERROR;
   31562:	f06f 0002 	mvn.w	r0, #2
   31566:	e75f      	b.n	31428 <opus_encode_native+0x19b8>
          st->mode = MODE_CELT_ONLY;
   31568:	f240 31ea 	movw	r1, #1002	; 0x3ea
   3156c:	f8c8 10dc 	str.w	r1, [r8, #220]	; 0xdc
   31570:	f7fe bcc2 	b.w	2fef8 <opus_encode_native+0x488>
    if (redundancy)
   31574:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   31576:	2b00      	cmp	r3, #0
   31578:	f47f a910 	bne.w	3079c <opus_encode_native+0xd2c>
   3157c:	f8c7 b01c 	str.w	fp, [r7, #28]
    int redundancy_bytes = 0; /* Number of bytes to use for redundancy frame */
   31580:	63bb      	str	r3, [r7, #56]	; 0x38
   31582:	f7ff b946 	b.w	30812 <opus_encode_native+0xda2>
   31586:	bf00      	nop
   31588:	51eb851f 	.word	0x51eb851f
   3158c:	66666667 	.word	0x66666667
   31590:	10624dd3 	.word	0x10624dd3
        celt_encoder_ctl(celt_enc, CELT_SET_START_BAND(0));
   31594:	2200      	movs	r2, #0
   31596:	f242 711a 	movw	r1, #10010	; 0x271a
   3159a:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
   3159c:	f7f7 fc86 	bl	28eac <opus_custom_encoder_ctl>
        celt_encoder_ctl(celt_enc, OPUS_SET_VBR(0));
   315a0:	2200      	movs	r2, #0
   315a2:	f640 71a6 	movw	r1, #4006	; 0xfa6
   315a6:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
   315a8:	f7f7 fc80 	bl	28eac <opus_custom_encoder_ctl>
        celt_encoder_ctl(celt_enc, OPUS_SET_BITRATE(OPUS_BITRATE_MAX));
   315ac:	f640 71a2 	movw	r1, #4002	; 0xfa2
   315b0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   315b4:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
   315b6:	f7f7 fc79 	bl	28eac <opus_custom_encoder_ctl>
        err = celt_encode_with_ec(celt_enc, pcm_buf, st->Fs/200, data+nb_compr_bytes, redundancy_bytes, NULL);
   315ba:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
   315be:	4ab2      	ldr	r2, [pc, #712]	; (31888 <opus_encode_native+0x1e18>)
   315c0:	9600      	str	r6, [sp, #0]
   315c2:	fb82 1203 	smull	r1, r2, r2, r3
   315c6:	2100      	movs	r1, #0
   315c8:	9101      	str	r1, [sp, #4]
   315ca:	17db      	asrs	r3, r3, #31
   315cc:	ebc3 12a2 	rsb	r2, r3, r2, asr #6
   315d0:	6a3b      	ldr	r3, [r7, #32]
   315d2:	6c79      	ldr	r1, [r7, #68]	; 0x44
   315d4:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
   315d6:	4423      	add	r3, r4
   315d8:	f7f3 ff76 	bl	254c8 <celt_encode_with_ec>
        if (err < 0)
   315dc:	2800      	cmp	r0, #0
   315de:	f6ff af1f 	blt.w	31420 <opus_encode_native+0x19b0>
        celt_encoder_ctl(celt_enc, OPUS_GET_FINAL_RANGE(&redundant_rng));
   315e2:	f107 0270 	add.w	r2, r7, #112	; 0x70
   315e6:	f640 71bf 	movw	r1, #4031	; 0xfbf
   315ea:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
   315ec:	f7f7 fc5e 	bl	28eac <opus_custom_encoder_ctl>
        celt_encoder_ctl(celt_enc, OPUS_RESET_STATE);
   315f0:	f640 71bc 	movw	r1, #4028	; 0xfbc
   315f4:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
   315f6:	f7f7 fc59 	bl	28eac <opus_custom_encoder_ctl>
    celt_encoder_ctl(celt_enc, CELT_SET_START_BAND(start_band));
   315fa:	4652      	mov	r2, sl
   315fc:	f242 711a 	movw	r1, #10010	; 0x271a
   31600:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
   31602:	f7f7 fc53 	bl	28eac <opus_custom_encoder_ctl>
    if (st->mode != MODE_SILK_ONLY)
   31606:	f8d8 e0dc 	ldr.w	lr, [r8, #220]	; 0xdc
   3160a:	f5be 7f7a 	cmp.w	lr, #1000	; 0x3e8
   3160e:	d059      	beq.n	316c4 <opus_encode_native+0x1c54>
        if (st->mode != st->prev_mode && st->prev_mode > 0)
   31610:	f8d8 30e0 	ldr.w	r3, [r8, #224]	; 0xe0
   31614:	4573      	cmp	r3, lr
   31616:	d01f      	beq.n	31658 <opus_encode_native+0x1be8>
   31618:	2b00      	cmp	r3, #0
   3161a:	dd1d      	ble.n	31658 <opus_encode_native+0x1be8>
           celt_encoder_ctl(celt_enc, OPUS_RESET_STATE);
   3161c:	f640 71bc 	movw	r1, #4028	; 0xfbc
   31620:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
   31622:	f7f7 fc43 	bl	28eac <opus_custom_encoder_ctl>
           celt_encode_with_ec(celt_enc, tmp_prefill, st->Fs/400, dummy, 2, NULL);
   31626:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
   3162a:	4997      	ldr	r1, [pc, #604]	; (31888 <opus_encode_native+0x1e18>)
   3162c:	f04f 0a00 	mov.w	sl, #0
   31630:	2002      	movs	r0, #2
   31632:	17da      	asrs	r2, r3, #31
   31634:	fb81 1303 	smull	r1, r3, r1, r3
   31638:	6d79      	ldr	r1, [r7, #84]	; 0x54
   3163a:	e9cd 0a00 	strd	r0, sl, [sp]
   3163e:	ebc2 12e3 	rsb	r2, r2, r3, asr #7
   31642:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
   31644:	f107 0380 	add.w	r3, r7, #128	; 0x80
   31648:	f7f3 ff3e 	bl	254c8 <celt_encode_with_ec>
           celt_encoder_ctl(celt_enc, CELT_SET_PREDICTION(0));
   3164c:	4652      	mov	r2, sl
   3164e:	f242 7112 	movw	r1, #10002	; 0x2712
   31652:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
   31654:	f7f7 fc2a 	bl	28eac <opus_custom_encoder_ctl>
        if (ec_tell(&enc) <= 8*nb_compr_bytes)
   31658:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   3165a:	69d9      	ldr	r1, [r3, #28]
   3165c:	695a      	ldr	r2, [r3, #20]
   3165e:	fab1 f381 	clz	r3, r1
   31662:	f1c3 0320 	rsb	r3, r3, #32
   31666:	1ad2      	subs	r2, r2, r3
   31668:	ebb2 0fc4 	cmp.w	r2, r4, lsl #3
   3166c:	f300 8368 	bgt.w	31d40 <opus_encode_native+0x22d0>
           if (redundancy && celt_to_silk && st->mode==MODE_HYBRID && st->use_vbr)
   31670:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   31672:	f8d8 2094 	ldr.w	r2, [r8, #148]	; 0x94
   31676:	2b00      	cmp	r3, #0
   31678:	f000 84fd 	beq.w	32076 <opus_encode_native+0x2606>
   3167c:	693b      	ldr	r3, [r7, #16]
   3167e:	2b00      	cmp	r3, #0
   31680:	f000 855d 	beq.w	3213e <opus_encode_native+0x26ce>
   31684:	f8d8 10dc 	ldr.w	r1, [r8, #220]	; 0xdc
   31688:	f240 33e9 	movw	r3, #1001	; 0x3e9
   3168c:	4299      	cmp	r1, r3
   3168e:	f000 860c 	beq.w	322aa <opus_encode_native+0x283a>
           celt_encoder_ctl(celt_enc, OPUS_SET_VBR(st->use_vbr));
   31692:	6efd      	ldr	r5, [r7, #108]	; 0x6c
   31694:	f640 71a6 	movw	r1, #4006	; 0xfa6
   31698:	4628      	mov	r0, r5
   3169a:	f7f7 fc07 	bl	28eac <opus_custom_encoder_ctl>
           ret = celt_encode_with_ec(celt_enc, pcm_buf, frame_size, NULL, nb_compr_bytes, &enc);
   3169e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   316a0:	e9cd 4300 	strd	r4, r3, [sp]
   316a4:	4628      	mov	r0, r5
   316a6:	6c79      	ldr	r1, [r7, #68]	; 0x44
   316a8:	2300      	movs	r3, #0
   316aa:	464a      	mov	r2, r9
   316ac:	f7f3 ff0c 	bl	254c8 <celt_encode_with_ec>
           if (ret < 0)
   316b0:	1e05      	subs	r5, r0, #0
   316b2:	f6ff aeb5 	blt.w	31420 <opus_encode_native+0x19b0>
           if (redundancy && celt_to_silk && st->mode==MODE_HYBRID && st->use_vbr)
   316b6:	f8d8 e0dc 	ldr.w	lr, [r8, #220]	; 0xdc
   316ba:	f240 33e9 	movw	r3, #1001	; 0x3e9
   316be:	459e      	cmp	lr, r3
   316c0:	f000 85e4 	beq.w	3228c <opus_encode_native+0x281c>
   316c4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   316c6:	69d9      	ldr	r1, [r3, #28]
   316c8:	695a      	ldr	r2, [r3, #20]
   316ca:	fab1 f381 	clz	r3, r1
   316ce:	f1c3 0320 	rsb	r3, r3, #32
   316d2:	1ad2      	subs	r2, r2, r3
    data[0] = gen_toc(st->mode, st->Fs/frame_size, curr_bandwidth, st->stream_channels);
   316d4:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
   316d8:	fb93 f3f9 	sdiv	r3, r3, r9
   while (framerate < 400)
   316dc:	f5b3 7fc8 	cmp.w	r3, #400	; 0x190
    data[0] = gen_toc(st->mode, st->Fs/frame_size, curr_bandwidth, st->stream_channels);
   316e0:	f8d8 00bc 	ldr.w	r0, [r8, #188]	; 0xbc
   while (framerate < 400)
   316e4:	f280 8510 	bge.w	32108 <opus_encode_native+0x2698>
           ec_enc_shrink(&enc, nb_compr_bytes);
   316e8:	2400      	movs	r4, #0
       framerate <<= 1;
   316ea:	005b      	lsls	r3, r3, #1
   while (framerate < 400)
   316ec:	f5b3 7fc8 	cmp.w	r3, #400	; 0x190
       period++;
   316f0:	f104 0401 	add.w	r4, r4, #1
   while (framerate < 400)
   316f4:	dbf9      	blt.n	316ea <opus_encode_native+0x1c7a>
   if (mode == MODE_SILK_ONLY)
   316f6:	f5be 7f7a 	cmp.w	lr, #1000	; 0x3e8
   316fa:	f000 830a 	beq.w	31d12 <opus_encode_native+0x22a2>
   } else if (mode == MODE_CELT_ONLY)
   316fe:	f240 33ea 	movw	r3, #1002	; 0x3ea
   31702:	459e      	cmp	lr, r3
       int tmp = bandwidth-OPUS_BANDWIDTH_MEDIUMBAND;
   31704:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   } else if (mode == MODE_CELT_ONLY)
   31706:	f000 84d4 	beq.w	320b2 <opus_encode_native+0x2642>
       toc |= (bandwidth-OPUS_BANDWIDTH_SUPERWIDEBAND)<<4;
   3170a:	f5a3 638a 	sub.w	r3, r3, #1104	; 0x450
   3170e:	011b      	lsls	r3, r3, #4
   31710:	f043 0360 	orr.w	r3, r3, #96	; 0x60
       toc |= (period-2)<<3;
   31714:	3c02      	subs	r4, #2
   31716:	ea43 03c4 	orr.w	r3, r3, r4, lsl #3
   3171a:	b2db      	uxtb	r3, r3
   toc |= (channels==2)<<2;
   3171c:	2802      	cmp	r0, #2
    data[0] = gen_toc(st->mode, st->Fs/frame_size, curr_bandwidth, st->stream_channels);
   3171e:	6ebc      	ldr	r4, [r7, #104]	; 0x68
    st->rangeFinal = enc.rng ^ redundant_rng;
   31720:	6f38      	ldr	r0, [r7, #112]	; 0x70
   31722:	bf08      	it	eq
   31724:	f043 0304 	orreq.w	r3, r3, #4
    data[0] = gen_toc(st->mode, st->Fs/frame_size, curr_bandwidth, st->stream_channels);
   31728:	7023      	strb	r3, [r4, #0]
    if (to_celt)
   3172a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    st->rangeFinal = enc.rng ^ redundant_rng;
   3172c:	4041      	eors	r1, r0
   3172e:	f8c8 1894 	str.w	r1, [r8, #2196]	; 0x894
    if (to_celt)
   31732:	2b00      	cmp	r3, #0
   31734:	f040 82a1 	bne.w	31c7a <opus_encode_native+0x220a>
        st->prev_mode = st->mode;
   31738:	f8d8 30dc 	ldr.w	r3, [r8, #220]	; 0xdc
    st->prev_channels = st->stream_channels;
   3173c:	f8d8 10bc 	ldr.w	r1, [r8, #188]	; 0xbc
   31740:	f8c8 30e0 	str.w	r3, [r8, #224]	; 0xe0
   31744:	e9c8 1939 	strd	r1, r9, [r8, #228]	; 0xe4
    if (ec_tell(&enc) > (max_data_bytes-1)*8)
   31748:	6c39      	ldr	r1, [r7, #64]	; 0x40
    st->first = 0;
   3174a:	2300      	movs	r3, #0
    if (ec_tell(&enc) > (max_data_bytes-1)*8)
   3174c:	ebb2 0fc1 	cmp.w	r2, r1, lsl #3
    st->first = 0;
   31750:	f8c8 30f8 	str.w	r3, [r8, #248]	; 0xf8
    if (ec_tell(&enc) > (max_data_bytes-1)*8)
   31754:	f340 826f 	ble.w	31c36 <opus_encode_native+0x21c6>
       data[1] = 0;
   31758:	6eba      	ldr	r2, [r7, #104]	; 0x68
       ret = 1;
   3175a:	2501      	movs	r5, #1
       data[1] = 0;
   3175c:	7053      	strb	r3, [r2, #1]
       st->rangeFinal = 0;
   3175e:	f8c8 3894 	str.w	r3, [r8, #2196]	; 0x894
    if (!st->use_vbr)
   31762:	f8d8 3094 	ldr.w	r3, [r8, #148]	; 0x94
    ret += 1+redundancy_bytes;
   31766:	1c70      	adds	r0, r6, #1
   31768:	4428      	add	r0, r5
    if (!st->use_vbr)
   3176a:	2b00      	cmp	r3, #0
   3176c:	f47f ae5a 	bne.w	31424 <opus_encode_native+0x19b4>
       if (opus_packet_pad(data, ret, max_data_bytes) != OPUS_OK)
   31770:	4601      	mov	r1, r0
   31772:	465a      	mov	r2, fp
   31774:	6eb8      	ldr	r0, [r7, #104]	; 0x68
   31776:	f001 fcc1 	bl	330fc <opus_packet_pad>
   3177a:	2800      	cmp	r0, #0
   3177c:	f47f ae50 	bne.w	31420 <opus_encode_native+0x19b0>
   31780:	4658      	mov	r0, fp
   31782:	e64f      	b.n	31424 <opus_encode_native+0x19b4>
      return 0;
   31784:	2300      	movs	r3, #0
   31786:	f7fe bdb2 	b.w	302ee <opus_encode_native+0x87e>
           enc_frame_size = st->Fs/25;
   3178a:	6cba      	ldr	r2, [r7, #72]	; 0x48
   3178c:	fb83 2302 	smull	r2, r3, r3, r2
   31790:	ebc4 03e3 	rsb	r3, r4, r3, asr #3
   31794:	657b      	str	r3, [r7, #84]	; 0x54
   31796:	f7fe bece 	b.w	30536 <opus_encode_native+0xac6>
    ALLOC(tmp_prefill, st->channels*st->Fs/400, opus_val16);
   3179a:	f8d8 5070 	ldr.w	r5, [r8, #112]	; 0x70
   3179e:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
   317a2:	4a39      	ldr	r2, [pc, #228]	; (31888 <opus_encode_native+0x1e18>)
   317a4:	f8c7 d064 	str.w	sp, [r7, #100]	; 0x64
   317a8:	fb03 f305 	mul.w	r3, r3, r5
   317ac:	fb82 1203 	smull	r1, r2, r2, r3
   317b0:	17db      	asrs	r3, r3, #31
   317b2:	ebc3 13e2 	rsb	r3, r3, r2, asr #7
   317b6:	005b      	lsls	r3, r3, #1
   317b8:	3308      	adds	r3, #8
   317ba:	f023 0307 	bic.w	r3, r3, #7
   317be:	ebad 0d03 	sub.w	sp, sp, r3
   317c2:	ab0a      	add	r3, sp, #40	; 0x28
   317c4:	f8d8 40ac 	ldr.w	r4, [r8, #172]	; 0xac
   317c8:	657b      	str	r3, [r7, #84]	; 0x54
   317ca:	e518      	b.n	311fe <opus_encode_native+0x178e>
        st->silk_mode.opusCanSwitch = st->silk_mode.switchReady && !st->nonfinal_frame;
   317cc:	2200      	movs	r2, #0
   317ce:	f8c8 2048 	str.w	r2, [r8, #72]	; 0x48
        if (nBytes==0)
   317d2:	2b00      	cmp	r3, #0
   317d4:	f47f ac8b 	bne.w	310ee <opus_encode_native+0x167e>
   317d8:	f8d8 20bc 	ldr.w	r2, [r8, #188]	; 0xbc
           st->rangeFinal = 0;
   317dc:	2300      	movs	r3, #0
   317de:	f8c8 3894 	str.w	r3, [r8, #2196]	; 0x894
           data[-1] = gen_toc(st->mode, st->Fs/frame_size, curr_bandwidth, st->stream_channels);
   317e2:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
   317e6:	fb93 faf9 	sdiv	sl, r3, r9
   while (framerate < 400)
   317ea:	f5ba 7fc8 	cmp.w	sl, #400	; 0x190
   317ee:	da06      	bge.n	317fe <opus_encode_native+0x1d8e>
       framerate <<= 1;
   317f0:	ea4f 0a4a 	mov.w	sl, sl, lsl #1
   while (framerate < 400)
   317f4:	f5ba 7fc8 	cmp.w	sl, #400	; 0x190
       period++;
   317f8:	f100 0001 	add.w	r0, r0, #1
   while (framerate < 400)
   317fc:	dbf8      	blt.n	317f0 <opus_encode_native+0x1d80>
   if (mode == MODE_SILK_ONLY)
   317fe:	f5b1 7f7a 	cmp.w	r1, #1000	; 0x3e8
   31802:	f000 8484 	beq.w	3210e <opus_encode_native+0x269e>
   } else if (mode == MODE_CELT_ONLY)
   31806:	f240 33ea 	movw	r3, #1002	; 0x3ea
   3180a:	4299      	cmp	r1, r3
       int tmp = bandwidth-OPUS_BANDWIDTH_MEDIUMBAND;
   3180c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   } else if (mode == MODE_CELT_ONLY)
   3180e:	f000 84af 	beq.w	32170 <opus_encode_native+0x2700>
       toc |= (bandwidth-OPUS_BANDWIDTH_SUPERWIDEBAND)<<4;
   31812:	f5a3 638a 	sub.w	r3, r3, #1104	; 0x450
   31816:	011b      	lsls	r3, r3, #4
   31818:	f043 0360 	orr.w	r3, r3, #96	; 0x60
       toc |= (period-2)<<3;
   3181c:	3802      	subs	r0, #2
   3181e:	ea43 00c0 	orr.w	r0, r3, r0, lsl #3
   31822:	b2c3      	uxtb	r3, r0
   toc |= (channels==2)<<2;
   31824:	2a02      	cmp	r2, #2
           data[-1] = gen_toc(st->mode, st->Fs/frame_size, curr_bandwidth, st->stream_channels);
   31826:	6eba      	ldr	r2, [r7, #104]	; 0x68
   31828:	bf08      	it	eq
   3182a:	f043 0304 	orreq.w	r3, r3, #4
   3182e:	7013      	strb	r3, [r2, #0]
           return 1;
   31830:	2001      	movs	r0, #1
   31832:	e5f9      	b.n	31428 <opus_encode_native+0x19b8>
                    threshold += hysteresis;
   31834:	68fb      	ldr	r3, [r7, #12]
   31836:	69fa      	ldr	r2, [r7, #28]
   31838:	4413      	add	r3, r2
   3183a:	461d      	mov	r5, r3
   3183c:	460b      	mov	r3, r1
   3183e:	f7fe bdf3 	b.w	30428 <opus_encode_native+0x9b8>
   31842:	f5a1 707a 	sub.w	r0, r1, #1000	; 0x3e8
    int celt_to_silk = 0;
   31846:	6b79      	ldr	r1, [r7, #52]	; 0x34
   31848:	6139      	str	r1, [r7, #16]
    int redundancy = 0;
   3184a:	62f9      	str	r1, [r7, #44]	; 0x2c
   3184c:	f7fe bb68 	b.w	2ff20 <opus_encode_native+0x4b0>
    if (st->mode == MODE_CELT_ONLY)
   31850:	f240 32ea 	movw	r2, #1002	; 0x3ea
   31854:	4293      	cmp	r3, r2
   31856:	f47f ae8d 	bne.w	31574 <opus_encode_native+0x1b04>
        redundancy = 0;
   3185a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   3185c:	f8c7 b01c 	str.w	fp, [r7, #28]
   31860:	62fb      	str	r3, [r7, #44]	; 0x2c
   31862:	f7fe bfd6 	b.w	30812 <opus_encode_native+0xda2>
           threshold -= 4000;
   31866:	f5ac 6c7a 	sub.w	ip, ip, #4000	; 0xfa0
   3186a:	f7ff bad1 	b.w	30e10 <opus_encode_native+0x13a0>
            st->silk_mode.minInternalSampleRate = 16000;
   3186e:	f44f 537a 	mov.w	r3, #16000	; 0x3e80
        st->silk_mode.maxInternalSampleRate = 16000;
   31872:	e9c8 3305 	strd	r3, r3, [r8, #20]
   31876:	f7ff bbac 	b.w	30fd2 <opus_encode_native+0x1562>
            st->silk_mode.desiredInternalSampleRate = 8000;
   3187a:	f44f 53fa 	mov.w	r3, #8000	; 0x1f40
   3187e:	f8c8 301c 	str.w	r3, [r8, #28]
   31882:	f7ff bb6e 	b.w	30f62 <opus_encode_native+0x14f2>
   31886:	bf00      	nop
   31888:	51eb851f 	.word	0x51eb851f
   rate /= channels;
   3188c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   3188e:	fb96 fcf3 	sdiv	ip, r6, r3
                  curr_bandwidth, st->Fs == 50 * frame_size, st->use_vbr, st->silk_mode.LBRR_coded,
   31892:	2132      	movs	r1, #50	; 0x32
            st->silk_mode.bitRate = compute_silk_rate_for_hybrid(total_bitRate,
   31894:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   31896:	f8d8 2094 	ldr.w	r2, [r8, #148]	; 0x94
                  curr_bandwidth, st->Fs == 50 * frame_size, st->use_vbr, st->silk_mode.LBRR_coded,
   3189a:	fb01 f109 	mul.w	r1, r1, r9
            st->silk_mode.bitRate = compute_silk_rate_for_hybrid(total_bitRate,
   3189e:	1ac9      	subs	r1, r1, r3
   318a0:	fab1 f181 	clz	r1, r1
   318a4:	0949      	lsrs	r1, r1, #5
   entry = 1 + frame20ms + 2*fec;
   318a6:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
      if (rate_table[i][0] > rate) break;
   318aa:	f642 60df 	movw	r0, #11999	; 0x2edf
   entry = 1 + frame20ms + 2*fec;
   318ae:	3101      	adds	r1, #1
      if (rate_table[i][0] > rate) break;
   318b0:	4584      	cmp	ip, r0
   entry = 1 + frame20ms + 2*fec;
   318b2:	eb01 0543 	add.w	r5, r1, r3, lsl #1
      if (rate_table[i][0] > rate) break;
   318b6:	f340 8494 	ble.w	321e2 <opus_encode_native+0x2772>
   318ba:	f5bc 5f7a 	cmp.w	ip, #16000	; 0x3e80
   318be:	f2c0 84dd 	blt.w	3227c <opus_encode_native+0x280c>
   318c2:	f644 631f 	movw	r3, #19999	; 0x4e1f
   318c6:	459c      	cmp	ip, r3
   318c8:	f340 84dc 	ble.w	32284 <opus_encode_native+0x2814>
   318cc:	f645 53bf 	movw	r3, #23999	; 0x5dbf
   318d0:	459c      	cmp	ip, r3
   318d2:	f340 84ff 	ble.w	322d4 <opus_encode_native+0x2864>
   318d6:	f5bc 4ffa 	cmp.w	ip, #32000	; 0x7d00
   318da:	f2c0 84f7 	blt.w	322cc <opus_encode_native+0x285c>
   318de:	f5bc 4f7a 	cmp.w	ip, #64000	; 0xfa00
   318e2:	f2c0 852a 	blt.w	3233a <opus_encode_native+0x28ca>
      silk_rate = rate_table[i-1][entry];
   318e6:	f105 011e 	add.w	r1, r5, #30
   318ea:	4bdc      	ldr	r3, [pc, #880]	; (31c5c <opus_encode_native+0x21ec>)
   318ec:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
      silk_rate += (rate-rate_table[i-1][0])/2;
   318f0:	f5ac 417a 	sub.w	r1, ip, #64000	; 0xfa00
   318f4:	eb03 0361 	add.w	r3, r3, r1, asr #1
   if (!vbr)
   318f8:	b902      	cbnz	r2, 318fc <opus_encode_native+0x1e8c>
      silk_rate += 100;
   318fa:	3364      	adds	r3, #100	; 0x64
   if (bandwidth==OPUS_BANDWIDTH_SUPERWIDEBAND)
   318fc:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
   318fe:	f5b1 6f8a 	cmp.w	r1, #1104	; 0x450
   silk_rate *= channels;
   31902:	6cb9      	ldr	r1, [r7, #72]	; 0x48
      silk_rate += 300;
   31904:	bf08      	it	eq
   31906:	f503 7396 	addeq.w	r3, r3, #300	; 0x12c
   silk_rate *= channels;
   3190a:	fb01 f303 	mul.w	r3, r1, r3
   if (channels == 2 && rate >= 12000)
   3190e:	2902      	cmp	r1, #2
   silk_rate *= channels;
   31910:	65bb      	str	r3, [r7, #88]	; 0x58
   if (channels == 2 && rate >= 12000)
   31912:	f000 839e 	beq.w	32052 <opus_encode_native+0x25e2>
            st->silk_mode.bitRate = compute_silk_rate_for_hybrid(total_bitRate,
   31916:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   31918:	f8c8 3024 	str.w	r3, [r8, #36]	; 0x24
            if (!st->energy_masking)
   3191c:	2c00      	cmp	r4, #0
   3191e:	f47f a858 	bne.w	309d2 <opus_encode_native+0xf62>
               HB_gain = Q15ONE - SHR32(celt_exp2(-celt_rate * QCONST16(1.f/1024, 10)), 1);
   31922:	1b9b      	subs	r3, r3, r6
   31924:	b29b      	uxth	r3, r3
   integer = SHR16(x,10);
   31926:	f343 2185 	sbfx	r1, r3, #10, #6
   if (integer>14)
   3192a:	290e      	cmp	r1, #14
   3192c:	f73f adaf 	bgt.w	3148e <opus_encode_native+0x1a1e>
   else if (integer < -15)
   31930:	f111 0f0f 	cmn.w	r1, #15
   31934:	f6ff adab 	blt.w	3148e <opus_encode_native+0x1a1e>
   frac = celt_exp2_frac(x-SHL16(integer,10));
   31938:	b288      	uxth	r0, r1
   3193a:	eba3 2380 	sub.w	r3, r3, r0, lsl #10
   frac = SHL16(x, 4);
   3193e:	f343 030b 	sbfx	r3, r3, #0, #12
   31942:	011b      	lsls	r3, r3, #4
   return ADD16(D0, MULT16_16_Q15(frac, ADD16(D1, MULT16_16_Q15(frac, ADD16(D2 , MULT16_16_Q15(D3,frac))))));
   31944:	f242 74dc 	movw	r4, #10204	; 0x27dc
   31948:	fb13 f404 	smulbb	r4, r3, r4
   3194c:	f643 10e3 	movw	r0, #14819	; 0x39e3
   31950:	eb00 34e4 	add.w	r4, r0, r4, asr #15
   31954:	fb14 f403 	smulbb	r4, r4, r3
   31958:	f645 1014 	movw	r0, #22804	; 0x5914
   3195c:	eb00 34e4 	add.w	r4, r0, r4, asr #15
   return VSHR32(EXTEND32(frac), -integer-2);
   31960:	f06f 0001 	mvn.w	r0, #1
   31964:	1a40      	subs	r0, r0, r1
   return ADD16(D0, MULT16_16_Q15(frac, ADD16(D1, MULT16_16_Q15(frac, ADD16(D2 , MULT16_16_Q15(D3,frac))))));
   31966:	fb14 f403 	smulbb	r4, r4, r3
   3196a:	f643 73ff 	movw	r3, #16383	; 0x3fff
   return VSHR32(EXTEND32(frac), -integer-2);
   3196e:	2800      	cmp	r0, #0
   return ADD16(D0, MULT16_16_Q15(frac, ADD16(D1, MULT16_16_Q15(frac, ADD16(D2 , MULT16_16_Q15(D3,frac))))));
   31970:	eb03 33e4 	add.w	r3, r3, r4, asr #15
   31974:	b21b      	sxth	r3, r3
   return VSHR32(EXTEND32(frac), -integer-2);
   31976:	bfda      	itte	le
   31978:	3102      	addle	r1, #2
   3197a:	408b      	lslle	r3, r1
   3197c:	4103      	asrgt	r3, r0
   3197e:	f647 71ff 	movw	r1, #32767	; 0x7fff
   31982:	eba1 0363 	sub.w	r3, r1, r3, asr #1
   31986:	b21b      	sxth	r3, r3
   31988:	65bb      	str	r3, [r7, #88]	; 0x58
   3198a:	f7ff baca 	b.w	30f22 <opus_encode_native+0x14b2>
            prefill_offset = st->channels*(st->encoder_buffer-st->delay_compensation-st->Fs/400);
   3198e:	6e7c      	ldr	r4, [r7, #100]	; 0x64
   31990:	4bb3      	ldr	r3, [pc, #716]	; (31c60 <opus_encode_native+0x21f0>)
   31992:	f8d8 1074 	ldr.w	r1, [r8, #116]	; 0x74
   31996:	f8d8 20ac 	ldr.w	r2, [r8, #172]	; 0xac
                  0, Q15ONE, celt_mode->overlap, st->Fs/400, st->channels, celt_mode->window, st->Fs);
   3199a:	6f78      	ldr	r0, [r7, #116]	; 0x74
            prefill_offset = st->channels*(st->encoder_buffer-st->delay_compensation-st->Fs/400);
   3199c:	4626      	mov	r6, r4
   3199e:	fb83 6306 	smull	r6, r3, r3, r6
   319a2:	17e4      	asrs	r4, r4, #31
   319a4:	11db      	asrs	r3, r3, #7
   319a6:	1ae6      	subs	r6, r4, r3
   319a8:	1a52      	subs	r2, r2, r1
   319aa:	4432      	add	r2, r6
            gain_fade(st->delay_buffer+prefill_offset, st->delay_buffer+prefill_offset,
   319ac:	6e79      	ldr	r1, [r7, #100]	; 0x64
            opus_int32 zero=0;
   319ae:	2600      	movs	r6, #0
   319b0:	f8c7 6080 	str.w	r6, [r7, #128]	; 0x80
            gain_fade(st->delay_buffer+prefill_offset, st->delay_buffer+prefill_offset,
   319b4:	9104      	str	r1, [sp, #16]
            prefill_offset = st->channels*(st->encoder_buffer-st->delay_compensation-st->Fs/400);
   319b6:	6d7e      	ldr	r6, [r7, #84]	; 0x54
            gain_fade(st->delay_buffer+prefill_offset, st->delay_buffer+prefill_offset,
   319b8:	6b41      	ldr	r1, [r0, #52]	; 0x34
   319ba:	9103      	str	r1, [sp, #12]
                  0, Q15ONE, celt_mode->overlap, st->Fs/400, st->channels, celt_mode->window, st->Fs);
   319bc:	1b1b      	subs	r3, r3, r4
            gain_fade(st->delay_buffer+prefill_offset, st->delay_buffer+prefill_offset,
   319be:	e9cd 3601 	strd	r3, r6, [sp, #4]
            prefill_offset = st->channels*(st->encoder_buffer-st->delay_compensation-st->Fs/400);
   319c2:	fb06 f202 	mul.w	r2, r6, r2
            gain_fade(st->delay_buffer+prefill_offset, st->delay_buffer+prefill_offset,
   319c6:	0054      	lsls	r4, r2, #1
   319c8:	f508 7688 	add.w	r6, r8, #272	; 0x110
   319cc:	6843      	ldr	r3, [r0, #4]
   319ce:	9300      	str	r3, [sp, #0]
   319d0:	1931      	adds	r1, r6, r4
   319d2:	4608      	mov	r0, r1
   319d4:	f647 73ff 	movw	r3, #32767	; 0x7fff
   319d8:	2200      	movs	r2, #0
   319da:	f7fd fd2d 	bl	2f438 <gain_fade>
            OPUS_CLEAR(st->delay_buffer, prefill_offset);
   319de:	4622      	mov	r2, r4
   319e0:	2100      	movs	r1, #0
   319e2:	4630      	mov	r0, r6
   319e4:	f003 fbbe 	bl	35164 <memset>
            silk_Encode( silk_enc, &st->silk_mode, pcm_silk, st->encoder_buffer, NULL, &zero, prefill, activity );
   319e8:	f107 0280 	add.w	r2, r7, #128	; 0x80
   319ec:	2000      	movs	r0, #0
   319ee:	f8d8 30ac 	ldr.w	r3, [r8, #172]	; 0xac
   319f2:	9201      	str	r2, [sp, #4]
   319f4:	9000      	str	r0, [sp, #0]
   319f6:	6978      	ldr	r0, [r7, #20]
   319f8:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   319fc:	e9cd 0102 	strd	r0, r1, [sp, #8]
   31a00:	4632      	mov	r2, r6
   31a02:	4629      	mov	r1, r5
   31a04:	69b8      	ldr	r0, [r7, #24]
   31a06:	f7dc fbe7 	bl	e1d8 <silk_Encode>
   31a0a:	f8d8 3070 	ldr.w	r3, [r8, #112]	; 0x70
   31a0e:	657b      	str	r3, [r7, #84]	; 0x54
            st->silk_mode.opusCanSwitch = 0;
   31a10:	2300      	movs	r3, #0
   31a12:	f8c8 3048 	str.w	r3, [r8, #72]	; 0x48
   31a16:	f7ff bafc 	b.w	31012 <opus_encode_native+0x15a2>
           if (st->mode == MODE_HYBRID)
   31a1a:	f240 32e9 	movw	r2, #1001	; 0x3e9
   31a1e:	4596      	cmp	lr, r2
   31a20:	f47f aaf1 	bne.w	31006 <opus_encode_native+0x1596>
              opus_int32 maxBitRate = compute_silk_rate_for_hybrid(st->silk_mode.maxBits*st->Fs / frame_size,
   31a24:	6e7c      	ldr	r4, [r7, #100]	; 0x64
   entry = 1 + frame20ms + 2*fec;
   31a26:	f8d8 2034 	ldr.w	r2, [r8, #52]	; 0x34
                    curr_bandwidth, st->Fs == 50 * frame_size, st->use_vbr, st->silk_mode.LBRR_coded,
   31a2a:	2132      	movs	r1, #50	; 0x32
   31a2c:	fb01 f109 	mul.w	r1, r1, r9
              opus_int32 maxBitRate = compute_silk_rate_for_hybrid(st->silk_mode.maxBits*st->Fs / frame_size,
   31a30:	1b09      	subs	r1, r1, r4
   31a32:	fab1 f181 	clz	r1, r1
   31a36:	0949      	lsrs	r1, r1, #5
   entry = 1 + frame20ms + 2*fec;
   31a38:	3101      	adds	r1, #1
      if (rate_table[i][0] > rate) break;
   31a3a:	f642 60df 	movw	r0, #11999	; 0x2edf
              opus_int32 maxBitRate = compute_silk_rate_for_hybrid(st->silk_mode.maxBits*st->Fs / frame_size,
   31a3e:	fb03 f304 	mul.w	r3, r3, r4
   entry = 1 + frame20ms + 2*fec;
   31a42:	eb01 0442 	add.w	r4, r1, r2, lsl #1
              opus_int32 maxBitRate = compute_silk_rate_for_hybrid(st->silk_mode.maxBits*st->Fs / frame_size,
   31a46:	fb93 f3f9 	sdiv	r3, r3, r9
   rate /= channels;
   31a4a:	6cba      	ldr	r2, [r7, #72]	; 0x48
   31a4c:	fb93 f5f2 	sdiv	r5, r3, r2
      if (rate_table[i][0] > rate) break;
   31a50:	4285      	cmp	r5, r0
   31a52:	f340 8467 	ble.w	32324 <opus_encode_native+0x28b4>
   31a56:	f5b5 5f7a 	cmp.w	r5, #16000	; 0x3e80
   31a5a:	f2c0 845f 	blt.w	3231c <opus_encode_native+0x28ac>
   31a5e:	f644 631f 	movw	r3, #19999	; 0x4e1f
   31a62:	429d      	cmp	r5, r3
   31a64:	f340 8456 	ble.w	32314 <opus_encode_native+0x28a4>
   31a68:	f645 53bf 	movw	r3, #23999	; 0x5dbf
   31a6c:	429d      	cmp	r5, r3
   31a6e:	f340 8435 	ble.w	322dc <opus_encode_native+0x286c>
   31a72:	f5b5 4ffa 	cmp.w	r5, #32000	; 0x7d00
   31a76:	f2c0 846b 	blt.w	32350 <opus_encode_native+0x28e0>
   31a7a:	f5b5 4f7a 	cmp.w	r5, #64000	; 0xfa00
   31a7e:	f2c0 8463 	blt.w	32348 <opus_encode_native+0x28d8>
      silk_rate = rate_table[i-1][entry];
   31a82:	4b76      	ldr	r3, [pc, #472]	; (31c5c <opus_encode_native+0x21ec>)
   31a84:	341e      	adds	r4, #30
   31a86:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
      silk_rate += (rate-rate_table[i-1][0])/2;
   31a8a:	f5a5 437a 	sub.w	r3, r5, #64000	; 0xfa00
   31a8e:	eb02 0263 	add.w	r2, r2, r3, asr #1
   if (bandwidth==OPUS_BANDWIDTH_SUPERWIDEBAND)
   31a92:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   31a94:	f5b3 6f8a 	cmp.w	r3, #1104	; 0x450
   silk_rate *= channels;
   31a98:	6cbb      	ldr	r3, [r7, #72]	; 0x48
      silk_rate += 300;
   31a9a:	bf08      	it	eq
   31a9c:	f502 7296 	addeq.w	r2, r2, #300	; 0x12c
   if (channels == 2 && rate >= 12000)
   31aa0:	2b02      	cmp	r3, #2
   silk_rate *= channels;
   31aa2:	fb03 f202 	mul.w	r2, r3, r2
   if (channels == 2 && rate >= 12000)
   31aa6:	d105      	bne.n	31ab4 <opus_encode_native+0x2044>
   31aa8:	f642 63df 	movw	r3, #11999	; 0x2edf
   31aac:	429d      	cmp	r5, r3
      silk_rate -= 1000;
   31aae:	bfc8      	it	gt
   31ab0:	f5a2 727a 	subgt.w	r2, r2, #1000	; 0x3e8
              st->silk_mode.maxBits = maxBitRate * frame_size / st->Fs;
   31ab4:	fb02 f209 	mul.w	r2, r2, r9
   31ab8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   31aba:	fb92 f2f3 	sdiv	r2, r2, r3
   31abe:	f8c8 2040 	str.w	r2, [r8, #64]	; 0x40
   31ac2:	f7ff baa0 	b.w	31006 <opus_encode_native+0x1596>
       hp_freq_smth1 = silk_LSHIFT( silk_lin2log( VARIABLE_HP_MIN_CUTOFF_HZ ), 8 );
   31ac6:	203c      	movs	r0, #60	; 0x3c
   31ac8:	f7e5 ff76 	bl	179b8 <silk_lin2log>
   31acc:	0203      	lsls	r3, r0, #8
   31ace:	f7fe bed3 	b.w	30878 <opus_encode_native+0xe08>
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   31ad2:	f2a1 404d 	subw	r0, r1, #1101	; 0x44d
   31ad6:	0044      	lsls	r4, r0, #1
      hysteresis = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND) + 1];
   31ad8:	1c62      	adds	r2, r4, #1
   31ada:	460d      	mov	r5, r1
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   31adc:	4961      	ldr	r1, [pc, #388]	; (31c64 <opus_encode_native+0x21f4>)
   31ade:	6579      	str	r1, [r7, #84]	; 0x54
      if (last_fec == 1) LBRR_rate_thres_bps -= hysteresis;
   31ae0:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   31ae4:	4a5f      	ldr	r2, [pc, #380]	; (31c64 <opus_encode_native+0x21f4>)
      if (rate > LBRR_rate_thres_bps)
   31ae6:	6d3e      	ldr	r6, [r7, #80]	; 0x50
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   31ae8:	f852 2024 	ldr.w	r2, [r2, r4, lsl #2]
      if (last_fec == 1) LBRR_rate_thres_bps -= hysteresis;
   31aec:	1a52      	subs	r2, r2, r1
      LBRR_rate_thres_bps = silk_SMULWB( silk_MUL( LBRR_rate_thres_bps,
   31aee:	fb0c f202 	mul.w	r2, ip, r2
   31af2:	b291      	uxth	r1, r2
   31af4:	f240 208f 	movw	r0, #655	; 0x28f
   31af8:	1412      	asrs	r2, r2, #16
   31afa:	fb00 f101 	mul.w	r1, r0, r1
   31afe:	fb00 f202 	mul.w	r2, r0, r2
   31b02:	eb02 4211 	add.w	r2, r2, r1, lsr #16
      if (rate > LBRR_rate_thres_bps)
   31b06:	4296      	cmp	r6, r2
   31b08:	f73e abf1 	bgt.w	302ee <opus_encode_native+0x87e>
      else if (PacketLoss_perc <= 5)
   31b0c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   31b0e:	2a05      	cmp	r2, #5
   31b10:	f77f ae38 	ble.w	31784 <opus_encode_native+0x1d14>
      else if (*bandwidth > OPUS_BANDWIDTH_NARROWBAND)
   31b14:	f240 4e4d 	movw	lr, #1101	; 0x44d
   31b18:	4575      	cmp	r5, lr
   31b1a:	f77e abe4 	ble.w	302e6 <opus_encode_native+0x876>
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   31b1e:	4d51      	ldr	r5, [pc, #324]	; (31c64 <opus_encode_native+0x21f4>)
   31b20:	1ea2      	subs	r2, r4, #2
      hysteresis = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND) + 1];
   31b22:	1e61      	subs	r1, r4, #1
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   31b24:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
      if (last_fec == 1) LBRR_rate_thres_bps -= hysteresis;
   31b28:	f855 1021 	ldr.w	r1, [r5, r1, lsl #2]
   31b2c:	1a52      	subs	r2, r2, r1
      LBRR_rate_thres_bps = silk_SMULWB( silk_MUL( LBRR_rate_thres_bps,
   31b2e:	fb0c f202 	mul.w	r2, ip, r2
   31b32:	b291      	uxth	r1, r2
   31b34:	1412      	asrs	r2, r2, #16
   31b36:	fb00 f101 	mul.w	r1, r0, r1
   31b3a:	fb00 f202 	mul.w	r2, r0, r2
   31b3e:	eb02 4511 	add.w	r5, r2, r1, lsr #16
         (*bandwidth)--;
   31b42:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
      if (rate > LBRR_rate_thres_bps)
   31b44:	42ae      	cmp	r6, r5
         (*bandwidth)--;
   31b46:	f102 31ff 	add.w	r1, r2, #4294967295	; 0xffffffff
   31b4a:	f8c8 10ec 	str.w	r1, [r8, #236]	; 0xec
      if (rate > LBRR_rate_thres_bps)
   31b4e:	f73e abce 	bgt.w	302ee <opus_encode_native+0x87e>
      else if (*bandwidth > OPUS_BANDWIDTH_NARROWBAND)
   31b52:	4571      	cmp	r1, lr
   31b54:	f43e abc7 	beq.w	302e6 <opus_encode_native+0x876>
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   31b58:	4d42      	ldr	r5, [pc, #264]	; (31c64 <opus_encode_native+0x21f4>)
   31b5a:	1f22      	subs	r2, r4, #4
      hysteresis = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND) + 1];
   31b5c:	1ee1      	subs	r1, r4, #3
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   31b5e:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
      if (last_fec == 1) LBRR_rate_thres_bps -= hysteresis;
   31b62:	f855 1021 	ldr.w	r1, [r5, r1, lsl #2]
   31b66:	1a52      	subs	r2, r2, r1
      LBRR_rate_thres_bps = silk_SMULWB( silk_MUL( LBRR_rate_thres_bps,
   31b68:	fb0c f202 	mul.w	r2, ip, r2
   31b6c:	b291      	uxth	r1, r2
   31b6e:	1412      	asrs	r2, r2, #16
   31b70:	fb00 f101 	mul.w	r1, r0, r1
   31b74:	fb00 f202 	mul.w	r2, r0, r2
   31b78:	eb02 4211 	add.w	r2, r2, r1, lsr #16
         (*bandwidth)--;
   31b7c:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
      if (rate > LBRR_rate_thres_bps)
   31b7e:	4296      	cmp	r6, r2
         (*bandwidth)--;
   31b80:	f1a1 0102 	sub.w	r1, r1, #2
   31b84:	f8c8 10ec 	str.w	r1, [r8, #236]	; 0xec
      if (rate > LBRR_rate_thres_bps)
   31b88:	f73e abb1 	bgt.w	302ee <opus_encode_native+0x87e>
      else if (*bandwidth > OPUS_BANDWIDTH_NARROWBAND)
   31b8c:	4571      	cmp	r1, lr
   31b8e:	f43e abaa 	beq.w	302e6 <opus_encode_native+0x876>
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   31b92:	1fa2      	subs	r2, r4, #6
      hysteresis = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND) + 1];
   31b94:	1f61      	subs	r1, r4, #5
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   31b96:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
      if (last_fec == 1) LBRR_rate_thres_bps -= hysteresis;
   31b9a:	f855 1021 	ldr.w	r1, [r5, r1, lsl #2]
   31b9e:	1a52      	subs	r2, r2, r1
      LBRR_rate_thres_bps = silk_SMULWB( silk_MUL( LBRR_rate_thres_bps,
   31ba0:	fb0c f202 	mul.w	r2, ip, r2
   31ba4:	b290      	uxth	r0, r2
   31ba6:	f240 218f 	movw	r1, #655	; 0x28f
   31baa:	1412      	asrs	r2, r2, #16
   31bac:	fb01 f000 	mul.w	r0, r1, r0
   31bb0:	fb01 f202 	mul.w	r2, r1, r2
   31bb4:	eb02 4510 	add.w	r5, r2, r0, lsr #16
         (*bandwidth)--;
   31bb8:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
      if (rate > LBRR_rate_thres_bps)
   31bba:	42ae      	cmp	r6, r5
         (*bandwidth)--;
   31bbc:	f1a2 0003 	sub.w	r0, r2, #3
   31bc0:	f8c8 00ec 	str.w	r0, [r8, #236]	; 0xec
      if (rate > LBRR_rate_thres_bps)
   31bc4:	f73e ab93 	bgt.w	302ee <opus_encode_native+0x87e>
      else if (*bandwidth > OPUS_BANDWIDTH_NARROWBAND)
   31bc8:	4570      	cmp	r0, lr
   31bca:	f43e ab8c 	beq.w	302e6 <opus_encode_native+0x876>
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   31bce:	f1a4 0208 	sub.w	r2, r4, #8
      hysteresis = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND) + 1];
   31bd2:	1fe0      	subs	r0, r4, #7
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   31bd4:	4c23      	ldr	r4, [pc, #140]	; (31c64 <opus_encode_native+0x21f4>)
   31bd6:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
      if (last_fec == 1) LBRR_rate_thres_bps -= hysteresis;
   31bda:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
   31bde:	1a12      	subs	r2, r2, r0
      LBRR_rate_thres_bps = silk_SMULWB( silk_MUL( LBRR_rate_thres_bps,
   31be0:	fb0c fc02 	mul.w	ip, ip, r2
   31be4:	fa1f f28c 	uxth.w	r2, ip
   31be8:	ea4f 4c2c 	mov.w	ip, ip, asr #16
   31bec:	fb01 f202 	mul.w	r2, r1, r2
   31bf0:	fb01 fc0c 	mul.w	ip, r1, ip
         (*bandwidth)--;
   31bf4:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
      LBRR_rate_thres_bps = silk_SMULWB( silk_MUL( LBRR_rate_thres_bps,
   31bf6:	eb0c 4212 	add.w	r2, ip, r2, lsr #16
         (*bandwidth)--;
   31bfa:	3904      	subs	r1, #4
      if (rate > LBRR_rate_thres_bps)
   31bfc:	42b2      	cmp	r2, r6
         (*bandwidth)--;
   31bfe:	f8c8 10ec 	str.w	r1, [r8, #236]	; 0xec
      if (rate > LBRR_rate_thres_bps)
   31c02:	f6be ab70 	bge.w	302e6 <opus_encode_native+0x876>
   31c06:	f7fe bb72 	b.w	302ee <opus_encode_native+0x87e>
       else if (equiv_rate < 16000)
   31c0a:	f5b2 5f7a 	cmp.w	r2, #16000	; 0x3e80
   31c0e:	f280 815e 	bge.w	31ece <opus_encode_native+0x245e>
          st->silk_mode.stereoWidth_Q14 = 0;
   31c12:	2200      	movs	r2, #0
   31c14:	f8c8 205c 	str.w	r2, [r8, #92]	; 0x5c
   31c18:	f7ff bb4b 	b.w	312b2 <opus_encode_native+0x1842>
       OPUS_COPY(st->delay_buffer, &pcm_buf[(frame_size+total_buffer-st->encoder_buffer)*st->channels], st->encoder_buffer*st->channels);
   31c1c:	1b31      	subs	r1, r6, r4
   31c1e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   31c20:	fb05 f101 	mul.w	r1, r5, r1
   31c24:	fb05 f204 	mul.w	r2, r5, r4
   31c28:	eb03 0141 	add.w	r1, r3, r1, lsl #1
   31c2c:	0052      	lsls	r2, r2, #1
   31c2e:	f7da fa67 	bl	c100 <memcpy>
   31c32:	f7ff bb0f 	b.w	31254 <opus_encode_native+0x17e4>
    } else if (st->mode==MODE_SILK_ONLY&&!redundancy)
   31c36:	f8d8 30dc 	ldr.w	r3, [r8, #220]	; 0xdc
   31c3a:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
   31c3e:	f47f ad90 	bne.w	31762 <opus_encode_native+0x1cf2>
   31c42:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   31c44:	2b00      	cmp	r3, #0
   31c46:	f47f ad8c 	bne.w	31762 <opus_encode_native+0x1cf2>
       while(ret>2&&data[ret]==0)ret--;
   31c4a:	2d02      	cmp	r5, #2
   31c4c:	f77f ad89 	ble.w	31762 <opus_encode_native+0x1cf2>
   31c50:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   31c52:	5d5a      	ldrb	r2, [r3, r5]
   31c54:	442b      	add	r3, r5
   31c56:	b162      	cbz	r2, 31c72 <opus_encode_native+0x2202>
   31c58:	e583      	b.n	31762 <opus_encode_native+0x1cf2>
   31c5a:	bf00      	nop
   31c5c:	0003b638 	.word	0x0003b638
   31c60:	51eb851f 	.word	0x51eb851f
   31c64:	0003b5d0 	.word	0x0003b5d0
   31c68:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
   31c6c:	2a00      	cmp	r2, #0
   31c6e:	f47f ad78 	bne.w	31762 <opus_encode_native+0x1cf2>
   31c72:	3d01      	subs	r5, #1
   31c74:	2d02      	cmp	r5, #2
   31c76:	d1f7      	bne.n	31c68 <opus_encode_native+0x21f8>
   31c78:	e573      	b.n	31762 <opus_encode_native+0x1cf2>
        st->prev_mode = MODE_CELT_ONLY;
   31c7a:	f240 33ea 	movw	r3, #1002	; 0x3ea
   31c7e:	e55d      	b.n	3173c <opus_encode_native+0x1ccc>
    if (st->mode != MODE_HYBRID || st->stream_channels==1)
   31c80:	f8d8 20bc 	ldr.w	r2, [r8, #188]	; 0xbc
   31c84:	2a01      	cmp	r2, #1
   31c86:	f43f ab0b 	beq.w	312a0 <opus_encode_native+0x1830>
    if( !st->energy_masking && st->channels == 2 ) {
   31c8a:	2b00      	cmp	r3, #0
   31c8c:	d066      	beq.n	31d5c <opus_encode_native+0x22ec>
   31c8e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   31c90:	69da      	ldr	r2, [r3, #28]
   31c92:	695b      	ldr	r3, [r3, #20]
   31c94:	fab2 f282 	clz	r2, r2
   31c98:	f1c2 0220 	rsb	r2, r2, #32
   31c9c:	1a9b      	subs	r3, r3, r2
   31c9e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   31ca0:	00d2      	lsls	r2, r2, #3
    if ( st->mode != MODE_CELT_ONLY && ec_tell(&enc)+17+20*(st->mode == MODE_HYBRID) <= 8*(max_data_bytes-1))
   31ca2:	3325      	adds	r3, #37	; 0x25
   31ca4:	4293      	cmp	r3, r2
   31ca6:	f73f ab24 	bgt.w	312f2 <opus_encode_native+0x1882>
           ec_enc_bit_logp(&enc, redundancy, 12);
   31caa:	220c      	movs	r2, #12
   31cac:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   31cae:	6e38      	ldr	r0, [r7, #96]	; 0x60
   31cb0:	f7f8 f87a 	bl	29da8 <ec_enc_bit_logp>
   31cb4:	f7ff bb17 	b.w	312e6 <opus_encode_native+0x1876>
        } while (--bandwidth>OPUS_BANDWIDTH_NARROWBAND);
   31cb8:	f44f 628a 	mov.w	r2, #1104	; 0x450
   31cbc:	f7fe bbb9 	b.w	30432 <opus_encode_native+0x9c2>
    int to_celt = 0;
   31cc0:	2100      	movs	r1, #0
   31cc2:	6379      	str	r1, [r7, #52]	; 0x34
    int celt_to_silk = 0;
   31cc4:	6139      	str	r1, [r7, #16]
    int redundancy = 0;
   31cc6:	62f9      	str	r1, [r7, #44]	; 0x2c
   31cc8:	f8c7 e04c 	str.w	lr, [r7, #76]	; 0x4c
   31ccc:	2002      	movs	r0, #2
   31cce:	f7fe b927 	b.w	2ff20 <opus_encode_native+0x4b0>
    celt_encoder_ctl(celt_enc, CELT_SET_START_BAND(start_band));
   31cd2:	4652      	mov	r2, sl
   31cd4:	f242 711a 	movw	r1, #10010	; 0x271a
   31cd8:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
   31cda:	f7f7 f8e7 	bl	28eac <opus_custom_encoder_ctl>
    if (st->mode != MODE_SILK_ONLY)
   31cde:	f8d8 e0dc 	ldr.w	lr, [r8, #220]	; 0xdc
   31ce2:	f5be 7f7a 	cmp.w	lr, #1000	; 0x3e8
   31ce6:	f47f ac93 	bne.w	31610 <opus_encode_native+0x1ba0>
   31cea:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   31cec:	69d9      	ldr	r1, [r3, #28]
   31cee:	6958      	ldr	r0, [r3, #20]
    data[0] = gen_toc(st->mode, st->Fs/frame_size, curr_bandwidth, st->stream_channels);
   31cf0:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
   31cf4:	fb93 f3f9 	sdiv	r3, r3, r9
   31cf8:	fab1 f281 	clz	r2, r1
   31cfc:	f1c2 0220 	rsb	r2, r2, #32
   while (framerate < 400)
   31d00:	f5b3 7fc8 	cmp.w	r3, #400	; 0x190
   31d04:	eba0 0202 	sub.w	r2, r0, r2
    data[0] = gen_toc(st->mode, st->Fs/frame_size, curr_bandwidth, st->stream_channels);
   31d08:	f8d8 00bc 	ldr.w	r0, [r8, #188]	; 0xbc
   while (framerate < 400)
   31d0c:	f6ff acec 	blt.w	316e8 <opus_encode_native+0x1c78>
   period = 0;
   31d10:	6afc      	ldr	r4, [r7, #44]	; 0x2c
       toc = (bandwidth-OPUS_BANDWIDTH_NARROWBAND)<<5;
   31d12:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   31d14:	3b4d      	subs	r3, #77	; 0x4d
   31d16:	015b      	lsls	r3, r3, #5
       toc |= (period-2)<<3;
   31d18:	3c02      	subs	r4, #2
   31d1a:	ea43 03c4 	orr.w	r3, r3, r4, lsl #3
   31d1e:	f003 03f8 	and.w	r3, r3, #248	; 0xf8
   31d22:	e4fb      	b.n	3171c <opus_encode_native+0x1cac>
    int start_band = 0;
   31d24:	f04f 0a00 	mov.w	sl, #0
       nb_compr_bytes = (max_data_bytes-1)-redundancy_bytes;
   31d28:	6c3b      	ldr	r3, [r7, #64]	; 0x40
       ec_enc_shrink(&enc, nb_compr_bytes);
   31d2a:	6e38      	ldr	r0, [r7, #96]	; 0x60
       nb_compr_bytes = (max_data_bytes-1)-redundancy_bytes;
   31d2c:	1b9c      	subs	r4, r3, r6
       ec_enc_shrink(&enc, nb_compr_bytes);
   31d2e:	4621      	mov	r1, r4
   31d30:	f7f8 f9dc 	bl	2a0ec <ec_enc_shrink>
   31d34:	2500      	movs	r5, #0
   31d36:	f7ff baf8 	b.w	3132a <opus_encode_native+0x18ba>
    if (st->mode != MODE_CELT_ONLY)start_band=17;
   31d3a:	f04f 0a11 	mov.w	sl, #17
   31d3e:	e7f3      	b.n	31d28 <opus_encode_native+0x22b8>
    if (redundancy && !celt_to_silk)
   31d40:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   31d42:	2b00      	cmp	r3, #0
   31d44:	f040 830b 	bne.w	3235e <opus_encode_native+0x28ee>
   31d48:	f8d8 e0dc 	ldr.w	lr, [r8, #220]	; 0xdc
   31d4c:	e4c2      	b.n	316d4 <opus_encode_native+0x1c64>
       redundancy_bytes = compute_redundancy_bytes(max_data_bytes, st->bitrate_bps, frame_rate, st->stream_channels);
   31d4e:	2300      	movs	r3, #0
   31d50:	63bb      	str	r3, [r7, #56]	; 0x38
          redundancy = 0;
   31d52:	62fb      	str	r3, [r7, #44]	; 0x2c
   if (redundancy_bytes > 4 + 8*channels)
   31d54:	f8c7 b01c 	str.w	fp, [r7, #28]
   31d58:	f7fe bd5b 	b.w	30812 <opus_encode_native+0xda2>
    if( !st->energy_masking && st->channels == 2 ) {
   31d5c:	f8d8 3070 	ldr.w	r3, [r8, #112]	; 0x70
   31d60:	2b02      	cmp	r3, #2
   31d62:	f47f aaa9 	bne.w	312b8 <opus_encode_native+0x1848>
        if( st->hybrid_stereo_width_Q14 < (1 << 14) || st->silk_mode.stereoWidth_Q14 < (1 << 14) ) {
   31d66:	f9b8 20c0 	ldrsh.w	r2, [r8, #192]	; 0xc0
   31d6a:	f8d8 305c 	ldr.w	r3, [r8, #92]	; 0x5c
   31d6e:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
   31d72:	f2c0 821e 	blt.w	321b2 <opus_encode_native+0x2742>
   31d76:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
   31d7a:	f6bf aa9d 	bge.w	312b8 <opus_encode_native+0x1848>
            g2 = (opus_val16)(st->silk_mode.stereoWidth_Q14);
   31d7e:	b219      	sxth	r1, r3
            g1 = g1==16384 ? Q15ONE : SHL16(g1,1);
   31d80:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
            g2 = (opus_val16)(st->silk_mode.stereoWidth_Q14);
   31d84:	65f9      	str	r1, [r7, #92]	; 0x5c
            g1 = g1==16384 ? Q15ONE : SHL16(g1,1);
   31d86:	bf08      	it	eq
   31d88:	f647 72ff 	movweq	r2, #32767	; 0x7fff
   31d8c:	f040 8213 	bne.w	321b6 <opus_encode_native+0x2746>
            g2 = g2==16384 ? Q15ONE : SHL16(g2,1);
   31d90:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
   31d94:	bf18      	it	ne
   31d96:	f343 030e 	sbfxne	r3, r3, #0, #15
    g1 = Q15ONE-g1;
   31d9a:	f647 74ff 	movw	r4, #32767	; 0x7fff
            stereo_fade(pcm_buf, pcm_buf, g1, g2, celt_mode->overlap,
   31d9e:	6f7d      	ldr	r5, [r7, #116]	; 0x74
    inc = 48000/Fs;
   31da0:	f8d8 1090 	ldr.w	r1, [r8, #144]	; 0x90
    overlap=overlap48/inc;
   31da4:	6868      	ldr	r0, [r5, #4]
            g2 = g2==16384 ? Q15ONE : SHL16(g2,1);
   31da6:	bf14      	ite	ne
   31da8:	005b      	lslne	r3, r3, #1
   31daa:	f647 73ff 	movweq	r3, #32767	; 0x7fff
    g1 = Q15ONE-g1;
   31dae:	1aa2      	subs	r2, r4, r2
    g2 = Q15ONE-g2;
   31db0:	1ae3      	subs	r3, r4, r3
    inc = 48000/Fs;
   31db2:	f64b 3680 	movw	r6, #48000	; 0xbb80
    g1 = Q15ONE-g1;
   31db6:	b212      	sxth	r2, r2
    inc = 48000/Fs;
   31db8:	fb96 f1f1 	sdiv	r1, r6, r1
    overlap=overlap48/inc;
   31dbc:	fb90 f0f1 	sdiv	r0, r0, r1
    for (i=0;i<overlap;i++)
   31dc0:	2800      	cmp	r0, #0
    g1 = Q15ONE-g1;
   31dc2:	65ba      	str	r2, [r7, #88]	; 0x58
    g2 = Q15ONE-g2;
   31dc4:	fa0f fa83 	sxth.w	sl, r3
    for (i=0;i<overlap;i++)
   31dc8:	f340 82bb 	ble.w	32342 <opus_encode_native+0x28d2>
   31dcc:	004a      	lsls	r2, r1, #1
   31dce:	653a      	str	r2, [r7, #80]	; 0x50
   31dd0:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   31dd2:	6278      	str	r0, [r7, #36]	; 0x24
   31dd4:	0083      	lsls	r3, r0, #2
   31dd6:	62bb      	str	r3, [r7, #40]	; 0x28
   31dd8:	f8d5 c034 	ldr.w	ip, [r5, #52]	; 0x34
   31ddc:	6db8      	ldr	r0, [r7, #88]	; 0x58
       g = SHR32(MAC16_16(MULT16_16(w,g2),
   31dde:	633c      	str	r4, [r7, #48]	; 0x30
   31de0:	18d3      	adds	r3, r2, r3
   31de2:	64bb      	str	r3, [r7, #72]	; 0x48
   31de4:	4614      	mov	r4, r2
   31de6:	1c96      	adds	r6, r2, #2
       w = MULT16_16_Q15(window[i*inc], window[i*inc]);
   31de8:	f9bc 3000 	ldrsh.w	r3, [ip]
       g = SHR32(MAC16_16(MULT16_16(w,g2),
   31dec:	6b3a      	ldr	r2, [r7, #48]	; 0x30
       diff = EXTRACT16(HALF32((opus_val32)in[i*channels] - (opus_val32)in[i*channels+1]));
   31dee:	f9b4 5002 	ldrsh.w	r5, [r4, #2]
   31df2:	f936 1c02 	ldrsh.w	r1, [r6, #-2]
       w = MULT16_16_Q15(window[i*inc], window[i*inc]);
   31df6:	fb03 f303 	mul.w	r3, r3, r3
   31dfa:	13db      	asrs	r3, r3, #15
       g = SHR32(MAC16_16(MULT16_16(w,g2),
   31dfc:	1ad2      	subs	r2, r2, r3
   31dfe:	fb12 f200 	smulbb	r2, r2, r0
   31e02:	fb13 220a 	smlabb	r2, r3, sl, r2
       diff = EXTRACT16(HALF32((opus_val32)in[i*channels] - (opus_val32)in[i*channels+1]));
   31e06:	1b4b      	subs	r3, r1, r5
       diff = MULT16_16_Q15(g, diff);
   31e08:	f342 32cf 	sbfx	r2, r2, #15, #16
       diff = EXTRACT16(HALF32((opus_val32)in[i*channels] - (opus_val32)in[i*channels+1]));
   31e0c:	105b      	asrs	r3, r3, #1
       diff = MULT16_16_Q15(g, diff);
   31e0e:	fb03 f302 	mul.w	r3, r3, r2
       out[i*channels] = out[i*channels] - diff;
   31e12:	f3c3 33cf 	ubfx	r3, r3, #15, #16
   31e16:	1ac9      	subs	r1, r1, r3
       out[i*channels+1] = out[i*channels+1] + diff;
   31e18:	442b      	add	r3, r5
       out[i*channels] = out[i*channels] - diff;
   31e1a:	f826 1c02 	strh.w	r1, [r6, #-2]
       out[i*channels+1] = out[i*channels+1] + diff;
   31e1e:	8063      	strh	r3, [r4, #2]
   31e20:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   31e22:	449c      	add	ip, r3
    for (i=0;i<overlap;i++)
   31e24:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   31e26:	3404      	adds	r4, #4
   31e28:	429c      	cmp	r4, r3
   31e2a:	f106 0604 	add.w	r6, r6, #4
   31e2e:	d1db      	bne.n	31de8 <opus_encode_native+0x2378>
   31e30:	6a78      	ldr	r0, [r7, #36]	; 0x24
    for (;i<frame_size;i++)
   31e32:	4581      	cmp	r9, r0
   31e34:	dd17      	ble.n	31e66 <opus_encode_native+0x23f6>
   31e36:	6abb      	ldr	r3, [r7, #40]	; 0x28
   31e38:	6c79      	ldr	r1, [r7, #68]	; 0x44
   31e3a:	461c      	mov	r4, r3
   31e3c:	440c      	add	r4, r1
       diff = EXTRACT16(HALF32((opus_val32)in[i*channels] - (opus_val32)in[i*channels+1]));
   31e3e:	f931 2020 	ldrsh.w	r2, [r1, r0, lsl #2]
   31e42:	f9b4 5002 	ldrsh.w	r5, [r4, #2]
   31e46:	1b53      	subs	r3, r2, r5
   31e48:	105b      	asrs	r3, r3, #1
       diff = MULT16_16_Q15(g2, diff);
   31e4a:	fb0a f303 	mul.w	r3, sl, r3
       out[i*channels] = out[i*channels] - diff;
   31e4e:	f3c3 33cf 	ubfx	r3, r3, #15, #16
   31e52:	1ad2      	subs	r2, r2, r3
   31e54:	f821 2020 	strh.w	r2, [r1, r0, lsl #2]
    for (;i<frame_size;i++)
   31e58:	3001      	adds	r0, #1
       out[i*channels+1] = out[i*channels+1] + diff;
   31e5a:	442b      	add	r3, r5
    for (;i<frame_size;i++)
   31e5c:	4581      	cmp	r9, r0
       out[i*channels+1] = out[i*channels+1] + diff;
   31e5e:	8063      	strh	r3, [r4, #2]
   31e60:	f104 0404 	add.w	r4, r4, #4
    for (;i<frame_size;i++)
   31e64:	dceb      	bgt.n	31e3e <opus_encode_native+0x23ce>
            st->hybrid_stereo_width_Q14 = st->silk_mode.stereoWidth_Q14;
   31e66:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   31e68:	f8a8 30c0 	strh.w	r3, [r8, #192]	; 0xc0
   31e6c:	f7ff ba24 	b.w	312b8 <opus_encode_native+0x1848>
    HB_gain = Q15ONE;
   31e70:	f647 73ff 	movw	r3, #32767	; 0x7fff
   31e74:	65bb      	str	r3, [r7, #88]	; 0x58
   31e76:	f8d8 2094 	ldr.w	r2, [r8, #148]	; 0x94
   31e7a:	f7ff b852 	b.w	30f22 <opus_encode_native+0x14b2>
            if( st->silk_mode.internalSampleRate == 8000 ) {
   31e7e:	f8d8 3050 	ldr.w	r3, [r8, #80]	; 0x50
   31e82:	f5b3 5ffa 	cmp.w	r3, #8000	; 0x1f40
   31e86:	f000 81a3 	beq.w	321d0 <opus_encode_native+0x2760>
            } else if( st->silk_mode.internalSampleRate == 12000 ) {
   31e8a:	f642 62e0 	movw	r2, #12000	; 0x2ee0
   31e8e:	4293      	cmp	r3, r2
   31e90:	f000 81ce 	beq.w	32230 <opus_encode_native+0x27c0>
               curr_bandwidth = OPUS_BANDWIDTH_WIDEBAND;
   31e94:	6cfd      	ldr	r5, [r7, #76]	; 0x4c
   31e96:	f240 424f 	movw	r2, #1103	; 0x44f
   31e9a:	f5b3 5f7a 	cmp.w	r3, #16000	; 0x3e80
   31e9e:	bf08      	it	eq
   31ea0:	4615      	moveq	r5, r2
   31ea2:	64fd      	str	r5, [r7, #76]	; 0x4c
   31ea4:	f7ff b8d4 	b.w	31050 <opus_encode_native+0x15e0>
      silk_biquad_alt_stride1( in, B_Q28, A_Q28, hp_mem, out, len );
   31ea8:	f7e5 fb6e 	bl	17588 <silk_biquad_alt_stride1>
   31eac:	f7fe bd63 	b.w	30976 <opus_encode_native+0xf06>
       info.offset = st->silk_mode.offset;
   31eb0:	e9d8 2319 	ldrd	r2, r3, [r8, #100]	; 0x64
       celt_encoder_ctl(celt_enc, CELT_SET_SILK_INFO(&info));
   31eb4:	f242 712c 	movw	r1, #10028	; 0x272c
       info.signalType = st->silk_mode.signalType;
   31eb8:	f8c7 2080 	str.w	r2, [r7, #128]	; 0x80
       celt_encoder_ctl(celt_enc, CELT_SET_SILK_INFO(&info));
   31ebc:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
       info.offset = st->silk_mode.offset;
   31ebe:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
       celt_encoder_ctl(celt_enc, CELT_SET_SILK_INFO(&info));
   31ec2:	f107 0280 	add.w	r2, r7, #128	; 0x80
   31ec6:	f7f6 fff1 	bl	28eac <opus_custom_encoder_ctl>
   31eca:	f7ff ba35 	b.w	31338 <opus_encode_native+0x18c8>
   31ece:	4611      	mov	r1, r2
          st->silk_mode.stereoWidth_Q14 = 16384 - 2048*(opus_int32)(32000-equiv_rate)/(equiv_rate-14000);
   31ed0:	f5a1 515a 	sub.w	r1, r1, #13952	; 0x3680
   31ed4:	f5c2 42fa 	rsb	r2, r2, #32000	; 0x7d00
   31ed8:	02d2      	lsls	r2, r2, #11
   31eda:	3930      	subs	r1, #48	; 0x30
   31edc:	fb92 f2f1 	sdiv	r2, r2, r1
   31ee0:	f5c2 4280 	rsb	r2, r2, #16384	; 0x4000
   31ee4:	f8c8 205c 	str.w	r2, [r8, #92]	; 0x5c
   31ee8:	f7ff b9e3 	b.w	312b2 <opus_encode_native+0x1842>
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   31eec:	f2a1 444d 	subw	r4, r1, #1101	; 0x44d
   31ef0:	4bd2      	ldr	r3, [pc, #840]	; (3223c <opus_encode_native+0x27cc>)
   31ef2:	657b      	str	r3, [r7, #84]	; 0x54
   31ef4:	0064      	lsls	r4, r4, #1
      LBRR_rate_thres_bps = silk_SMULWB( silk_MUL( LBRR_rate_thres_bps,
   31ef6:	f240 228f 	movw	r2, #655	; 0x28f
   31efa:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
      if (rate > LBRR_rate_thres_bps)
   31efe:	6d3e      	ldr	r6, [r7, #80]	; 0x50
      LBRR_rate_thres_bps = silk_SMULWB( silk_MUL( LBRR_rate_thres_bps,
   31f00:	fb03 f30c 	mul.w	r3, r3, ip
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   31f04:	4608      	mov	r0, r1
      LBRR_rate_thres_bps = silk_SMULWB( silk_MUL( LBRR_rate_thres_bps,
   31f06:	b299      	uxth	r1, r3
   31f08:	141b      	asrs	r3, r3, #16
   31f0a:	fb02 f101 	mul.w	r1, r2, r1
   31f0e:	fb02 f303 	mul.w	r3, r2, r3
   31f12:	eb03 4311 	add.w	r3, r3, r1, lsr #16
      if (rate > LBRR_rate_thres_bps)
   31f16:	429e      	cmp	r6, r3
   31f18:	dc63      	bgt.n	31fe2 <opus_encode_native+0x2572>
      else if (PacketLoss_perc <= 5)
   31f1a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   31f1c:	2b05      	cmp	r3, #5
   31f1e:	f77f ac31 	ble.w	31784 <opus_encode_native+0x1d14>
      else if (*bandwidth > OPUS_BANDWIDTH_NARROWBAND)
   31f22:	f240 4e4d 	movw	lr, #1101	; 0x44d
   31f26:	4570      	cmp	r0, lr
   31f28:	f77e a9dd 	ble.w	302e6 <opus_encode_native+0x876>
      LBRR_rate_thres_bps = silk_SMULWB( silk_MUL( LBRR_rate_thres_bps,
   31f2c:	49c3      	ldr	r1, [pc, #780]	; (3223c <opus_encode_native+0x27cc>)
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   31f2e:	1ea3      	subs	r3, r4, #2
         (*bandwidth)--;
   31f30:	4605      	mov	r5, r0
      LBRR_rate_thres_bps = silk_SMULWB( silk_MUL( LBRR_rate_thres_bps,
   31f32:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   31f36:	fb03 f30c 	mul.w	r3, r3, ip
   31f3a:	b299      	uxth	r1, r3
   31f3c:	141b      	asrs	r3, r3, #16
   31f3e:	fb02 f101 	mul.w	r1, r2, r1
   31f42:	fb02 f303 	mul.w	r3, r2, r3
   31f46:	eb03 4311 	add.w	r3, r3, r1, lsr #16
         (*bandwidth)--;
   31f4a:	3801      	subs	r0, #1
      if (rate > LBRR_rate_thres_bps)
   31f4c:	429e      	cmp	r6, r3
         (*bandwidth)--;
   31f4e:	f8c8 00ec 	str.w	r0, [r8, #236]	; 0xec
      if (rate > LBRR_rate_thres_bps)
   31f52:	dc46      	bgt.n	31fe2 <opus_encode_native+0x2572>
      else if (*bandwidth > OPUS_BANDWIDTH_NARROWBAND)
   31f54:	4570      	cmp	r0, lr
   31f56:	f43e a9c6 	beq.w	302e6 <opus_encode_native+0x876>
      LBRR_rate_thres_bps = silk_SMULWB( silk_MUL( LBRR_rate_thres_bps,
   31f5a:	4610      	mov	r0, r2
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   31f5c:	1f23      	subs	r3, r4, #4
      LBRR_rate_thres_bps = silk_SMULWB( silk_MUL( LBRR_rate_thres_bps,
   31f5e:	4ab7      	ldr	r2, [pc, #732]	; (3223c <opus_encode_native+0x27cc>)
   31f60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   31f64:	fb03 f30c 	mul.w	r3, r3, ip
   31f68:	b29a      	uxth	r2, r3
   31f6a:	141b      	asrs	r3, r3, #16
   31f6c:	fb00 f202 	mul.w	r2, r0, r2
   31f70:	fb00 f303 	mul.w	r3, r0, r3
   31f74:	eb03 4312 	add.w	r3, r3, r2, lsr #16
      if (rate > LBRR_rate_thres_bps)
   31f78:	42b3      	cmp	r3, r6
         (*bandwidth)--;
   31f7a:	f1a5 0202 	sub.w	r2, r5, #2
   31f7e:	f8c8 20ec 	str.w	r2, [r8, #236]	; 0xec
      if (rate > LBRR_rate_thres_bps)
   31f82:	db2e      	blt.n	31fe2 <opus_encode_native+0x2572>
      else if (*bandwidth > OPUS_BANDWIDTH_NARROWBAND)
   31f84:	4572      	cmp	r2, lr
   31f86:	f43e a9ae 	beq.w	302e6 <opus_encode_native+0x876>
      LBRR_rate_thres_bps = silk_SMULWB( silk_MUL( LBRR_rate_thres_bps,
   31f8a:	4aac      	ldr	r2, [pc, #688]	; (3223c <opus_encode_native+0x27cc>)
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   31f8c:	1fa3      	subs	r3, r4, #6
         (*bandwidth)--;
   31f8e:	1ee9      	subs	r1, r5, #3
      LBRR_rate_thres_bps = silk_SMULWB( silk_MUL( LBRR_rate_thres_bps,
   31f90:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
         (*bandwidth)--;
   31f94:	f8c8 10ec 	str.w	r1, [r8, #236]	; 0xec
      LBRR_rate_thres_bps = silk_SMULWB( silk_MUL( LBRR_rate_thres_bps,
   31f98:	fb03 f30c 	mul.w	r3, r3, ip
   31f9c:	b29a      	uxth	r2, r3
   31f9e:	141b      	asrs	r3, r3, #16
   31fa0:	fb00 f202 	mul.w	r2, r0, r2
   31fa4:	fb00 f303 	mul.w	r3, r0, r3
   31fa8:	eb03 4312 	add.w	r3, r3, r2, lsr #16
      if (rate > LBRR_rate_thres_bps)
   31fac:	429e      	cmp	r6, r3
   31fae:	dc18      	bgt.n	31fe2 <opus_encode_native+0x2572>
      else if (*bandwidth > OPUS_BANDWIDTH_NARROWBAND)
   31fb0:	4571      	cmp	r1, lr
   31fb2:	f43e a998 	beq.w	302e6 <opus_encode_native+0x876>
      LBRR_rate_thres_bps = fec_thresholds[2*(*bandwidth - OPUS_BANDWIDTH_NARROWBAND)];
   31fb6:	3c08      	subs	r4, #8
      LBRR_rate_thres_bps = silk_SMULWB( silk_MUL( LBRR_rate_thres_bps,
   31fb8:	4aa0      	ldr	r2, [pc, #640]	; (3223c <opus_encode_native+0x27cc>)
   31fba:	f852 2024 	ldr.w	r2, [r2, r4, lsl #2]
         (*bandwidth)--;
   31fbe:	1f2b      	subs	r3, r5, #4
      LBRR_rate_thres_bps = silk_SMULWB( silk_MUL( LBRR_rate_thres_bps,
   31fc0:	fb02 fc0c 	mul.w	ip, r2, ip
         (*bandwidth)--;
   31fc4:	f8c8 30ec 	str.w	r3, [r8, #236]	; 0xec
      LBRR_rate_thres_bps = silk_SMULWB( silk_MUL( LBRR_rate_thres_bps,
   31fc8:	fa1f f28c 	uxth.w	r2, ip
   31fcc:	ea4f 432c 	mov.w	r3, ip, asr #16
   31fd0:	fb00 f202 	mul.w	r2, r0, r2
   31fd4:	fb00 f303 	mul.w	r3, r0, r3
   31fd8:	eb03 4312 	add.w	r3, r3, r2, lsr #16
      if (rate > LBRR_rate_thres_bps)
   31fdc:	429e      	cmp	r6, r3
   31fde:	f77e a982 	ble.w	302e6 <opus_encode_native+0x876>
         return 1;
   31fe2:	2301      	movs	r3, #1
   31fe4:	f7fe b983 	b.w	302ee <opus_encode_native+0x87e>
        if (!st->first && st->mode != MODE_CELT_ONLY && !st->silk_mode.inWBmodeWithoutVariableLP && st->bandwidth > OPUS_BANDWIDTH_WIDEBAND)
   31fe8:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
   31fea:	f240 33ea 	movw	r3, #1002	; 0x3ea
        st->bandwidth = st->auto_bandwidth = bandwidth;
   31fee:	f240 4251 	movw	r2, #1105	; 0x451
        if (!st->first && st->mode != MODE_CELT_ONLY && !st->silk_mode.inWBmodeWithoutVariableLP && st->bandwidth > OPUS_BANDWIDTH_WIDEBAND)
   31ff2:	4299      	cmp	r1, r3
        st->bandwidth = st->auto_bandwidth = bandwidth;
   31ff4:	e9c8 223b 	strd	r2, r2, [r8, #236]	; 0xec
        if (!st->first && st->mode != MODE_CELT_ONLY && !st->silk_mode.inWBmodeWithoutVariableLP && st->bandwidth > OPUS_BANDWIDTH_WIDEBAND)
   31ff8:	f43e a86d 	beq.w	300d6 <opus_encode_native+0x666>
   31ffc:	f8d8 3058 	ldr.w	r3, [r8, #88]	; 0x58
   32000:	2b00      	cmp	r3, #0
   32002:	f43e aa2b 	beq.w	3045c <opus_encode_native+0x9ec>
   32006:	f7fe b866 	b.w	300d6 <opus_encode_native+0x666>
        st->bandwidth = st->auto_bandwidth = bandwidth;
   3200a:	f240 4251 	movw	r2, #1105	; 0x451
   3200e:	e9c8 223b 	strd	r2, r2, [r8, #236]	; 0xec
   32012:	f7fe b860 	b.w	300d6 <opus_encode_native+0x666>
            if( st->use_vbr ) {
   32016:	2b00      	cmp	r3, #0
   32018:	f040 80b6 	bne.w	32188 <opus_encode_native+0x2718>
    ALLOC(tmp_prefill, st->channels*st->Fs/400, opus_val16);
   3201c:	f8d8 5070 	ldr.w	r5, [r8, #112]	; 0x70
   32020:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
   32024:	4886      	ldr	r0, [pc, #536]	; (32240 <opus_encode_native+0x27d0>)
   32026:	f8c7 d064 	str.w	sp, [r7, #100]	; 0x64
   3202a:	fb05 f203 	mul.w	r2, r5, r3
   3202e:	fb80 6002 	smull	r6, r0, r0, r2
   32032:	17d2      	asrs	r2, r2, #31
   32034:	ebc2 12e0 	rsb	r2, r2, r0, asr #7
   32038:	0052      	lsls	r2, r2, #1
   3203a:	f102 0008 	add.w	r0, r2, #8
   3203e:	f020 0007 	bic.w	r0, r0, #7
   32042:	ebad 0d00 	sub.w	sp, sp, r0
   32046:	a80a      	add	r0, sp, #40	; 0x28
   32048:	f8d8 40ac 	ldr.w	r4, [r8, #172]	; 0xac
   3204c:	6578      	str	r0, [r7, #84]	; 0x54
   3204e:	f7ff b8bf 	b.w	311d0 <opus_encode_native+0x1760>
   if (channels == 2 && rate >= 12000)
   32052:	f642 63df 	movw	r3, #11999	; 0x2edf
   32056:	459c      	cmp	ip, r3
   32058:	f77f ac5d 	ble.w	31916 <opus_encode_native+0x1ea6>
      silk_rate -= 1000;
   3205c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   3205e:	f5a3 737a 	sub.w	r3, r3, #1000	; 0x3e8
   32062:	65bb      	str	r3, [r7, #88]	; 0x58
   32064:	e457      	b.n	31916 <opus_encode_native+0x1ea6>
              st->silk_mode.maxBits -= 20;
   32066:	3b14      	subs	r3, #20
   32068:	f8c8 3040 	str.w	r3, [r8, #64]	; 0x40
        if (st->silk_mode.useCBR)
   3206c:	2a00      	cmp	r2, #0
   3206e:	f47f acd9 	bne.w	31a24 <opus_encode_native+0x1fb4>
   32072:	f7ff b9fd 	b.w	31470 <opus_encode_native+0x1a00>
           celt_encoder_ctl(celt_enc, OPUS_SET_VBR(st->use_vbr));
   32076:	6efd      	ldr	r5, [r7, #108]	; 0x6c
   32078:	f640 71a6 	movw	r1, #4006	; 0xfa6
   3207c:	4628      	mov	r0, r5
   3207e:	f7f6 ff15 	bl	28eac <opus_custom_encoder_ctl>
           ret = celt_encode_with_ec(celt_enc, pcm_buf, frame_size, NULL, nb_compr_bytes, &enc);
   32082:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   32084:	e9cd 4300 	strd	r4, r3, [sp]
   32088:	4628      	mov	r0, r5
   3208a:	6c79      	ldr	r1, [r7, #68]	; 0x44
   3208c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   3208e:	464a      	mov	r2, r9
   32090:	f7f3 fa1a 	bl	254c8 <celt_encode_with_ec>
           if (ret < 0)
   32094:	1e05      	subs	r5, r0, #0
   32096:	f6ff a9c3 	blt.w	31420 <opus_encode_native+0x19b0>
   3209a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   3209c:	f8d8 e0dc 	ldr.w	lr, [r8, #220]	; 0xdc
   320a0:	69d9      	ldr	r1, [r3, #28]
   320a2:	695a      	ldr	r2, [r3, #20]
   320a4:	fab1 f381 	clz	r3, r1
   320a8:	f1c3 0320 	rsb	r3, r3, #32
   320ac:	1ad2      	subs	r2, r2, r3
   320ae:	f7ff bb11 	b.w	316d4 <opus_encode_native+0x1c64>
       int tmp = bandwidth-OPUS_BANDWIDTH_MEDIUMBAND;
   320b2:	f2a3 434e 	subw	r3, r3, #1102	; 0x44e
       toc |= tmp << 5;
   320b6:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   320ba:	015b      	lsls	r3, r3, #5
   320bc:	f063 037f 	orn	r3, r3, #127	; 0x7f
       toc |= period<<3;
   320c0:	ea43 03c4 	orr.w	r3, r3, r4, lsl #3
   320c4:	b2db      	uxtb	r3, r3
   320c6:	f7ff bb29 	b.w	3171c <opus_encode_native+0x1cac>
            ec_enc_bit_logp(&enc, celt_to_silk, 1);
   320ca:	2201      	movs	r2, #1
   320cc:	6939      	ldr	r1, [r7, #16]
   320ce:	6e38      	ldr	r0, [r7, #96]	; 0x60
   320d0:	f7f7 fe6a 	bl	29da8 <ec_enc_bit_logp>
            if (st->mode == MODE_HYBRID)
   320d4:	f8d8 e0dc 	ldr.w	lr, [r8, #220]	; 0xdc
   320d8:	6e3a      	ldr	r2, [r7, #96]	; 0x60
   320da:	f240 33e9 	movw	r3, #1001	; 0x3e9
   320de:	459e      	cmp	lr, r3
   320e0:	f000 80b2 	beq.w	32248 <opus_encode_native+0x27d8>
   320e4:	69d3      	ldr	r3, [r2, #28]
   320e6:	6952      	ldr	r2, [r2, #20]
   320e8:	fab3 f683 	clz	r6, r3
   320ec:	4416      	add	r6, r2
               max_redundancy = (max_data_bytes-1)-((ec_tell(&enc)+7)>>3);
   320ee:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   320f0:	3e19      	subs	r6, #25
   320f2:	eba3 06e6 	sub.w	r6, r3, r6, asr #3
            redundancy_bytes = IMIN(max_redundancy, redundancy_bytes);
   320f6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   320f8:	429e      	cmp	r6, r3
   320fa:	bfa8      	it	ge
   320fc:	461e      	movge	r6, r3
            redundancy_bytes = IMIN(257, IMAX(2, redundancy_bytes));
   320fe:	2e02      	cmp	r6, #2
   32100:	bfb8      	it	lt
   32102:	2602      	movlt	r6, #2
   32104:	f7ff b8fa 	b.w	312fc <opus_encode_native+0x188c>
   period = 0;
   32108:	2400      	movs	r4, #0
   3210a:	f7ff baf4 	b.w	316f6 <opus_encode_native+0x1c86>
       toc = (bandwidth-OPUS_BANDWIDTH_NARROWBAND)<<5;
   3210e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   32110:	3b4d      	subs	r3, #77	; 0x4d
   32112:	015b      	lsls	r3, r3, #5
       toc |= (period-2)<<3;
   32114:	3802      	subs	r0, #2
   32116:	ea43 03c0 	orr.w	r3, r3, r0, lsl #3
   3211a:	f003 03f8 	and.w	r3, r3, #248	; 0xf8
   3211e:	f7ff bb81 	b.w	31824 <opus_encode_native+0x1db4>
   32122:	2200      	movs	r2, #0
       int num_multiframes = 0;
   32124:	4610      	mov	r0, r2
   32126:	4611      	mov	r1, r2
   32128:	f7fe bd38 	b.w	30b9c <opus_encode_native+0x112c>
   3212c:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
   32130:	61f9      	str	r1, [r7, #28]
              end = 13;
   32132:	210d      	movs	r1, #13
   32134:	f240 6342 	movw	r3, #1602	; 0x642
   32138:	6339      	str	r1, [r7, #48]	; 0x30
   3213a:	f7fe bc6d 	b.w	30a18 <opus_encode_native+0xfa8>
           celt_encoder_ctl(celt_enc, OPUS_SET_VBR(st->use_vbr));
   3213e:	6efd      	ldr	r5, [r7, #108]	; 0x6c
   32140:	f640 71a6 	movw	r1, #4006	; 0xfa6
   32144:	4628      	mov	r0, r5
   32146:	f7f6 feb1 	bl	28eac <opus_custom_encoder_ctl>
           ret = celt_encode_with_ec(celt_enc, pcm_buf, frame_size, NULL, nb_compr_bytes, &enc);
   3214a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   3214c:	e9cd 4300 	strd	r4, r3, [sp]
   32150:	4628      	mov	r0, r5
   32152:	693b      	ldr	r3, [r7, #16]
   32154:	6c79      	ldr	r1, [r7, #68]	; 0x44
   32156:	464a      	mov	r2, r9
   32158:	f7f3 f9b6 	bl	254c8 <celt_encode_with_ec>
           if (ret < 0)
   3215c:	1e05      	subs	r5, r0, #0
   3215e:	f6bf a8ff 	bge.w	31360 <opus_encode_native+0x18f0>
   32162:	f7ff b95d 	b.w	31420 <opus_encode_native+0x19b0>
   if (redundancy_bytes > 4 + 8*channels)
   32166:	2300      	movs	r3, #0
   32168:	62fb      	str	r3, [r7, #44]	; 0x2c
      redundancy_bytes = 0;
   3216a:	63bb      	str	r3, [r7, #56]	; 0x38
   3216c:	f7fe bfba 	b.w	310e4 <opus_encode_native+0x1674>
       int tmp = bandwidth-OPUS_BANDWIDTH_MEDIUMBAND;
   32170:	f2a3 434e 	subw	r3, r3, #1102	; 0x44e
       toc |= tmp << 5;
   32174:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   32178:	015b      	lsls	r3, r3, #5
   3217a:	f063 037f 	orn	r3, r3, #127	; 0x7f
       toc |= period<<3;
   3217e:	ea43 03c0 	orr.w	r3, r3, r0, lsl #3
   32182:	b2db      	uxtb	r3, r3
   32184:	f7ff bb4e 	b.w	31824 <opus_encode_native+0x1db4>
                celt_encoder_ctl(celt_enc, OPUS_SET_BITRATE(st->bitrate_bps-st->silk_mode.bitRate));
   32188:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
   3218c:	6efc      	ldr	r4, [r7, #108]	; 0x6c
   3218e:	f8d8 20a0 	ldr.w	r2, [r8, #160]	; 0xa0
   32192:	f640 71a2 	movw	r1, #4002	; 0xfa2
   32196:	1ad2      	subs	r2, r2, r3
   32198:	4620      	mov	r0, r4
   3219a:	f7f6 fe87 	bl	28eac <opus_custom_encoder_ctl>
                celt_encoder_ctl(celt_enc, OPUS_SET_VBR_CONSTRAINT(0));
   3219e:	f640 71b4 	movw	r1, #4020	; 0xfb4
   321a2:	2200      	movs	r2, #0
   321a4:	4620      	mov	r0, r4
   321a6:	f7f6 fe81 	bl	28eac <opus_custom_encoder_ctl>
   321aa:	f8d8 10dc 	ldr.w	r1, [r8, #220]	; 0xdc
   321ae:	f7fe bff3 	b.w	31198 <opus_encode_native+0x1728>
            g2 = (opus_val16)(st->silk_mode.stereoWidth_Q14);
   321b2:	b219      	sxth	r1, r3
   321b4:	65f9      	str	r1, [r7, #92]	; 0x5c
            g1 = g1==16384 ? Q15ONE : SHL16(g1,1);
   321b6:	f342 020e 	sbfx	r2, r2, #0, #15
   321ba:	0052      	lsls	r2, r2, #1
   321bc:	6df9      	ldr	r1, [r7, #92]	; 0x5c
   321be:	e5e7      	b.n	31d90 <opus_encode_native+0x2320>
        celt_encoder_ctl(celt_enc, OPUS_GET_FINAL_RANGE(&redundant_rng));
   321c0:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
   321c2:	f107 0270 	add.w	r2, r7, #112	; 0x70
   321c6:	f640 71bf 	movw	r1, #4031	; 0xfbf
   321ca:	f7f6 fe6f 	bl	28eac <opus_custom_encoder_ctl>
   321ce:	e764      	b.n	3209a <opus_encode_native+0x262a>
               curr_bandwidth = OPUS_BANDWIDTH_NARROWBAND;
   321d0:	f240 434d 	movw	r3, #1101	; 0x44d
   321d4:	64fb      	str	r3, [r7, #76]	; 0x4c
   321d6:	f7fe bf3b 	b.w	31050 <opus_encode_native+0x15e0>
   321da:	f240 424f 	movw	r2, #1103	; 0x44f
   321de:	f7fd bf7a 	b.w	300d6 <opus_encode_native+0x666>
   for (i=1;i<N;i++)
   321e2:	2301      	movs	r3, #1
      if (rate_table[i][0] > rate) break;
   321e4:	f642 61e0 	movw	r1, #12000	; 0x2ee0
      lo = rate_table[i-1][entry];
   321e8:	1e58      	subs	r0, r3, #1
      x0 = rate_table[i-1][0];
   321ea:	eb00 0080 	add.w	r0, r0, r0, lsl #2
      hi = rate_table[i][entry];
   321ee:	eb03 0383 	add.w	r3, r3, r3, lsl #2
      lo = rate_table[i-1][entry];
   321f2:	65b8      	str	r0, [r7, #88]	; 0x58
      hi = rate_table[i][entry];
   321f4:	442b      	add	r3, r5
      lo = rate_table[i-1][entry];
   321f6:	1828      	adds	r0, r5, r0
      x0 = rate_table[i-1][0];
   321f8:	4d12      	ldr	r5, [pc, #72]	; (32244 <opus_encode_native+0x27d4>)
      lo = rate_table[i-1][entry];
   321fa:	6338      	str	r0, [r7, #48]	; 0x30
      silk_rate = (lo*(x1-rate) + hi*(rate-x0))/(x1-x0);
   321fc:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
      x0 = rate_table[i-1][0];
   32200:	6db8      	ldr	r0, [r7, #88]	; 0x58
      silk_rate = (lo*(x1-rate) + hi*(rate-x0))/(x1-x0);
   32202:	61fb      	str	r3, [r7, #28]
   32204:	6b3b      	ldr	r3, [r7, #48]	; 0x30
      x0 = rate_table[i-1][0];
   32206:	f855 0020 	ldr.w	r0, [r5, r0, lsl #2]
      silk_rate = (lo*(x1-rate) + hi*(rate-x0))/(x1-x0);
   3220a:	f855 5023 	ldr.w	r5, [r5, r3, lsl #2]
   3220e:	69fb      	ldr	r3, [r7, #28]
   32210:	65bd      	str	r5, [r7, #88]	; 0x58
   32212:	ebac 0500 	sub.w	r5, ip, r0
   32216:	fb03 f305 	mul.w	r3, r3, r5
   3221a:	461d      	mov	r5, r3
   3221c:	eba1 030c 	sub.w	r3, r1, ip
   32220:	1a09      	subs	r1, r1, r0
   32222:	6db8      	ldr	r0, [r7, #88]	; 0x58
   32224:	fb00 5303 	mla	r3, r0, r3, r5
   32228:	fb93 f3f1 	sdiv	r3, r3, r1
   3222c:	f7ff bb64 	b.w	318f8 <opus_encode_native+0x1e88>
               curr_bandwidth = OPUS_BANDWIDTH_MEDIUMBAND;
   32230:	f240 434e 	movw	r3, #1102	; 0x44e
   32234:	64fb      	str	r3, [r7, #76]	; 0x4c
   32236:	f7fe bf0b 	b.w	31050 <opus_encode_native+0x15e0>
   3223a:	bf00      	nop
   3223c:	0003b5d0 	.word	0x0003b5d0
   32240:	51eb851f 	.word	0x51eb851f
   32244:	0003b638 	.word	0x0003b638
   32248:	69d3      	ldr	r3, [r2, #28]
   3224a:	4610      	mov	r0, r2
   3224c:	6952      	ldr	r2, [r2, #20]
   3224e:	fab3 f683 	clz	r6, r3
   32252:	4416      	add	r6, r2
               max_redundancy = (max_data_bytes-1)-((ec_tell(&enc)+8+3+7)>>3);
   32254:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   32256:	3e0e      	subs	r6, #14
   32258:	eba3 06e6 	sub.w	r6, r3, r6, asr #3
            redundancy_bytes = IMIN(max_redundancy, redundancy_bytes);
   3225c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   3225e:	429e      	cmp	r6, r3
   32260:	bfa8      	it	ge
   32262:	461e      	movge	r6, r3
            redundancy_bytes = IMIN(257, IMAX(2, redundancy_bytes));
   32264:	2e02      	cmp	r6, #2
   32266:	bfb8      	it	lt
   32268:	2602      	movlt	r6, #2
                ec_enc_uint(&enc, redundancy_bytes-2, 256);
   3226a:	1eb1      	subs	r1, r6, #2
   3226c:	f44f 7280 	mov.w	r2, #256	; 0x100
   32270:	f7f7 fe78 	bl	29f64 <ec_enc_uint>
   32274:	f8d8 e0dc 	ldr.w	lr, [r8, #220]	; 0xdc
   32278:	f7ff b840 	b.w	312fc <opus_encode_native+0x188c>
   for (i=1;i<N;i++)
   3227c:	2302      	movs	r3, #2
      if (rate_table[i][0] > rate) break;
   3227e:	f44f 517a 	mov.w	r1, #16000	; 0x3e80
   32282:	e7b1      	b.n	321e8 <opus_encode_native+0x2778>
   for (i=1;i<N;i++)
   32284:	2303      	movs	r3, #3
      if (rate_table[i][0] > rate) break;
   32286:	f644 6120 	movw	r1, #20000	; 0x4e20
   3228a:	e7ad      	b.n	321e8 <opus_encode_native+0x2778>
           if (redundancy && celt_to_silk && st->mode==MODE_HYBRID && st->use_vbr)
   3228c:	f8d8 3094 	ldr.w	r3, [r8, #148]	; 0x94
   32290:	2b00      	cmp	r3, #0
   32292:	f43f aa17 	beq.w	316c4 <opus_encode_native+0x1c54>
              OPUS_MOVE(data+ret, data+nb_compr_bytes, redundancy_bytes);
   32296:	6a3b      	ldr	r3, [r7, #32]
   32298:	4632      	mov	r2, r6
   3229a:	1919      	adds	r1, r3, r4
   3229c:	1958      	adds	r0, r3, r5
   3229e:	f002 fefd 	bl	3509c <memmove>
   322a2:	f8d8 e0dc 	ldr.w	lr, [r8, #220]	; 0xdc
   322a6:	f7ff ba0d 	b.w	316c4 <opus_encode_native+0x1c54>
           if (redundancy && celt_to_silk && st->mode==MODE_HYBRID && st->use_vbr)
   322aa:	2a00      	cmp	r2, #0
   322ac:	f43f a9f1 	beq.w	31692 <opus_encode_native+0x1c22>
              celt_encoder_ctl(celt_enc, OPUS_SET_BITRATE(st->bitrate_bps-st->silk_mode.bitRate));
   322b0:	f8d8 20a0 	ldr.w	r2, [r8, #160]	; 0xa0
   322b4:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
   322b8:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
   322ba:	1ad2      	subs	r2, r2, r3
   322bc:	f640 71a2 	movw	r1, #4002	; 0xfa2
   322c0:	f7f6 fdf4 	bl	28eac <opus_custom_encoder_ctl>
   322c4:	f8d8 2094 	ldr.w	r2, [r8, #148]	; 0x94
   322c8:	f7ff b9e3 	b.w	31692 <opus_encode_native+0x1c22>
   for (i=1;i<N;i++)
   322cc:	2305      	movs	r3, #5
      if (rate_table[i][0] > rate) break;
   322ce:	f44f 41fa 	mov.w	r1, #32000	; 0x7d00
   322d2:	e789      	b.n	321e8 <opus_encode_native+0x2778>
   for (i=1;i<N;i++)
   322d4:	2304      	movs	r3, #4
      if (rate_table[i][0] > rate) break;
   322d6:	f645 51c0 	movw	r1, #24000	; 0x5dc0
   322da:	e785      	b.n	321e8 <opus_encode_native+0x2778>
   for (i=1;i<N;i++)
   322dc:	2304      	movs	r3, #4
      if (rate_table[i][0] > rate) break;
   322de:	f645 52c0 	movw	r2, #24000	; 0x5dc0
      lo = rate_table[i-1][entry];
   322e2:	1e58      	subs	r0, r3, #1
      x0 = rate_table[i-1][0];
   322e4:	4926      	ldr	r1, [pc, #152]	; (32380 <opus_encode_native+0x2910>)
   322e6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
      hi = rate_table[i][entry];
   322ea:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   322ee:	4423      	add	r3, r4
      lo = rate_table[i-1][entry];
   322f0:	4404      	add	r4, r0
      x0 = rate_table[i-1][0];
   322f2:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
      silk_rate = (lo*(x1-rate) + hi*(rate-x0))/(x1-x0);
   322f6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   322fa:	f851 1024 	ldr.w	r1, [r1, r4, lsl #2]
   322fe:	1a2c      	subs	r4, r5, r0
   32300:	fb03 f404 	mul.w	r4, r3, r4
   32304:	1b53      	subs	r3, r2, r5
   32306:	fb01 4303 	mla	r3, r1, r3, r4
   3230a:	1a12      	subs	r2, r2, r0
   3230c:	fb93 f2f2 	sdiv	r2, r3, r2
   32310:	f7ff bbbf 	b.w	31a92 <opus_encode_native+0x2022>
   for (i=1;i<N;i++)
   32314:	2303      	movs	r3, #3
      if (rate_table[i][0] > rate) break;
   32316:	f644 6220 	movw	r2, #20000	; 0x4e20
   3231a:	e7e2      	b.n	322e2 <opus_encode_native+0x2872>
   for (i=1;i<N;i++)
   3231c:	2302      	movs	r3, #2
      if (rate_table[i][0] > rate) break;
   3231e:	f44f 527a 	mov.w	r2, #16000	; 0x3e80
   32322:	e7de      	b.n	322e2 <opus_encode_native+0x2872>
   for (i=1;i<N;i++)
   32324:	2301      	movs	r3, #1
      if (rate_table[i][0] > rate) break;
   32326:	f642 62e0 	movw	r2, #12000	; 0x2ee0
   3232a:	e7da      	b.n	322e2 <opus_encode_native+0x2872>
           ec_enc_shrink(&enc, nb_compr_bytes);
   3232c:	4629      	mov	r1, r5
   3232e:	6e38      	ldr	r0, [r7, #96]	; 0x60
   32330:	f7f7 fedc 	bl	2a0ec <ec_enc_shrink>
   32334:	462c      	mov	r4, r5
   32336:	f7ff b844 	b.w	313c2 <opus_encode_native+0x1952>
   for (i=1;i<N;i++)
   3233a:	2306      	movs	r3, #6
      if (rate_table[i][0] > rate) break;
   3233c:	f44f 417a 	mov.w	r1, #64000	; 0xfa00
   32340:	e752      	b.n	321e8 <opus_encode_native+0x2778>
    for (i=0;i<overlap;i++)
   32342:	2000      	movs	r0, #0
   32344:	62b8      	str	r0, [r7, #40]	; 0x28
   32346:	e576      	b.n	31e36 <opus_encode_native+0x23c6>
   for (i=1;i<N;i++)
   32348:	2306      	movs	r3, #6
      if (rate_table[i][0] > rate) break;
   3234a:	f44f 427a 	mov.w	r2, #64000	; 0xfa00
   3234e:	e7c8      	b.n	322e2 <opus_encode_native+0x2872>
   for (i=1;i<N;i++)
   32350:	2305      	movs	r3, #5
      if (rate_table[i][0] > rate) break;
   32352:	f44f 42fa 	mov.w	r2, #32000	; 0x7d00
   32356:	e7c4      	b.n	322e2 <opus_encode_native+0x2872>
   32358:	4606      	mov	r6, r0
   3235a:	f7fd bc29 	b.w	2fbb0 <opus_encode_native+0x140>
    if (redundancy && !celt_to_silk)
   3235e:	693b      	ldr	r3, [r7, #16]
   32360:	2b00      	cmp	r3, #0
   32362:	f43e affd 	beq.w	31360 <opus_encode_native+0x18f0>
   32366:	f8d8 e0dc 	ldr.w	lr, [r8, #220]	; 0xdc
   3236a:	f7ff b9ab 	b.w	316c4 <opus_encode_native+0x1c54>
       if(tocmode==MODE_SILK_ONLY&&bw>OPUS_BANDWIDTH_WIDEBAND)
   3236e:	f5b6 7f7a 	cmp.w	r6, #1000	; 0x3e8
   32372:	f43e abe0 	beq.w	30b36 <opus_encode_native+0x10c6>
   32376:	2200      	movs	r2, #0
       int num_multiframes = 0;
   32378:	4610      	mov	r0, r2
   3237a:	4611      	mov	r1, r2
   3237c:	f7fd bc4a 	b.w	2fc14 <opus_encode_native+0x1a4>
   32380:	0003b638 	.word	0x0003b638

00032384 <opus_encode>:
}
#endif

opus_int32 opus_encode(OpusEncoder *st, const opus_int16 *pcm, int analysis_frame_size,
                unsigned char *data, opus_int32 out_data_bytes)
{
   32384:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   int frame_size;
   frame_size = frame_size_select(analysis_frame_size, st->variable_duration, st->Fs);
   32388:	f8d0 7090 	ldr.w	r7, [r0, #144]	; 0x90
   if (frame_size<Fs/400)
   3238c:	f8df e0d8 	ldr.w	lr, [pc, #216]	; 32468 <opus_encode+0xe4>
   frame_size = frame_size_select(analysis_frame_size, st->variable_duration, st->Fs);
   32390:	f8d0 809c 	ldr.w	r8, [r0, #156]	; 0x9c
   if (frame_size<Fs/400)
   32394:	fb8e 4507 	smull	r4, r5, lr, r7
   32398:	17fc      	asrs	r4, r7, #31
   3239a:	ebc4 14e5 	rsb	r4, r4, r5, asr #7
   3239e:	42a2      	cmp	r2, r4
{
   323a0:	b08b      	sub	sp, #44	; 0x2c
   323a2:	4616      	mov	r6, r2
   if (frame_size<Fs/400)
   323a4:	db5b      	blt.n	3245e <opus_encode+0xda>
   if (variable_duration == OPUS_FRAMESIZE_ARG)
   323a6:	f241 3288 	movw	r2, #5000	; 0x1388
   323aa:	4590      	cmp	r8, r2
   323ac:	d055      	beq.n	3245a <opus_encode+0xd6>
   else if (variable_duration >= OPUS_FRAMESIZE_2_5_MS && variable_duration <= OPUS_FRAMESIZE_120_MS)
   323ae:	f5a8 559c 	sub.w	r5, r8, #4992	; 0x1380
   323b2:	f1a5 0209 	sub.w	r2, r5, #9
   323b6:	2a08      	cmp	r2, #8
   323b8:	d851      	bhi.n	3245e <opus_encode+0xda>
      if (variable_duration <= OPUS_FRAMESIZE_40_MS)
   323ba:	f241 398d 	movw	r9, #5005	; 0x138d
   323be:	45c8      	cmp	r8, r9
   323c0:	dd48      	ble.n	32454 <opus_encode+0xd0>
         new_size = (variable_duration-OPUS_FRAMESIZE_2_5_MS-2)*Fs/50;
   323c2:	3d0b      	subs	r5, #11
   323c4:	fb07 f505 	mul.w	r5, r7, r5
   323c8:	fb8e 4205 	smull	r4, r2, lr, r5
   323cc:	17ed      	asrs	r5, r5, #31
   323ce:	ebc5 1222 	rsb	r2, r5, r2, asr #4
   if (new_size>frame_size)
   323d2:	4296      	cmp	r6, r2
   323d4:	db43      	blt.n	3245e <opus_encode+0xda>
   if (400*new_size!=Fs   && 200*new_size!=Fs   && 100*new_size!=Fs   &&
   323d6:	f44f 74c8 	mov.w	r4, #400	; 0x190
   323da:	fb04 f402 	mul.w	r4, r4, r2
   323de:	42a7      	cmp	r7, r4
   323e0:	d023      	beq.n	3242a <opus_encode+0xa6>
   323e2:	24c8      	movs	r4, #200	; 0xc8
   323e4:	fb04 f402 	mul.w	r4, r4, r2
   323e8:	42a7      	cmp	r7, r4
   323ea:	d01e      	beq.n	3242a <opus_encode+0xa6>
   323ec:	2464      	movs	r4, #100	; 0x64
   323ee:	fb04 f402 	mul.w	r4, r4, r2
   323f2:	42a7      	cmp	r7, r4
   323f4:	d019      	beq.n	3242a <opus_encode+0xa6>
        50*new_size!=Fs   &&  25*new_size!=Fs   &&  50*new_size!=3*Fs &&
   323f6:	2432      	movs	r4, #50	; 0x32
   323f8:	fb04 f402 	mul.w	r4, r4, r2
   if (400*new_size!=Fs   && 200*new_size!=Fs   && 100*new_size!=Fs   &&
   323fc:	42a7      	cmp	r7, r4
   323fe:	d014      	beq.n	3242a <opus_encode+0xa6>
        50*new_size!=Fs   &&  25*new_size!=Fs   &&  50*new_size!=3*Fs &&
   32400:	eb02 0582 	add.w	r5, r2, r2, lsl #2
   32404:	eb05 0585 	add.w	r5, r5, r5, lsl #2
   32408:	42af      	cmp	r7, r5
   3240a:	d00e      	beq.n	3242a <opus_encode+0xa6>
   3240c:	eb07 0e47 	add.w	lr, r7, r7, lsl #1
   32410:	4574      	cmp	r4, lr
   32412:	d00a      	beq.n	3242a <opus_encode+0xa6>
        50*new_size!=4*Fs &&  50*new_size!=5*Fs &&  50*new_size!=6*Fs)
   32414:	00bd      	lsls	r5, r7, #2
        50*new_size!=Fs   &&  25*new_size!=Fs   &&  50*new_size!=3*Fs &&
   32416:	42ac      	cmp	r4, r5
   32418:	d007      	beq.n	3242a <opus_encode+0xa6>
        50*new_size!=4*Fs &&  50*new_size!=5*Fs &&  50*new_size!=6*Fs)
   3241a:	442f      	add	r7, r5
   3241c:	42bc      	cmp	r4, r7
   3241e:	d004      	beq.n	3242a <opus_encode+0xa6>
   32420:	ebb4 0f4e 	cmp.w	r4, lr, lsl #1
      return -1;
   32424:	bf18      	it	ne
   32426:	f04f 32ff 	movne.w	r2, #4294967295	; 0xffffffff
   return opus_encode_native(st, pcm, frame_size, data, out_data_bytes, 16,
   3242a:	9c12      	ldr	r4, [sp, #72]	; 0x48
   3242c:	9603      	str	r6, [sp, #12]
   3242e:	9102      	str	r1, [sp, #8]
   32430:	9400      	str	r4, [sp, #0]
   32432:	6f04      	ldr	r4, [r0, #112]	; 0x70
   32434:	4f0b      	ldr	r7, [pc, #44]	; (32464 <opus_encode+0xe0>)
   32436:	9707      	str	r7, [sp, #28]
   32438:	2500      	movs	r5, #0
   3243a:	9508      	str	r5, [sp, #32]
   3243c:	9504      	str	r5, [sp, #16]
   3243e:	f06f 0601 	mvn.w	r6, #1
   32442:	2510      	movs	r5, #16
   32444:	e9cd 6405 	strd	r6, r4, [sp, #20]
   32448:	9501      	str	r5, [sp, #4]
   3244a:	f7fd fb11 	bl	2fa70 <opus_encode_native>
                             pcm, analysis_frame_size, 0, -2, st->channels, downmix_int, 0);
}
   3244e:	b00b      	add	sp, #44	; 0x2c
   32450:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
         new_size = (Fs/400)<<(variable_duration-OPUS_FRAMESIZE_2_5_MS);
   32454:	fa04 f202 	lsl.w	r2, r4, r2
   32458:	e7bb      	b.n	323d2 <opus_encode+0x4e>
   if (variable_duration == OPUS_FRAMESIZE_ARG)
   3245a:	4632      	mov	r2, r6
   3245c:	e7bb      	b.n	323d6 <opus_encode+0x52>
      return -1;
   3245e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   32462:	e7e2      	b.n	3242a <opus_encode+0xa6>
   32464:	0002f53d 	.word	0x0002f53d
   32468:	51eb851f 	.word	0x51eb851f

0003246c <opus_encoder_ctl>:
}
#endif


int opus_encoder_ctl(OpusEncoder *st, int request, ...)
{
   3246c:	b40e      	push	{r1, r2, r3}
   3246e:	b5f0      	push	{r4, r5, r6, r7, lr}
   32470:	b09a      	sub	sp, #104	; 0x68
   32472:	ab1f      	add	r3, sp, #124	; 0x7c
   32474:	4605      	mov	r5, r0
   32476:	f853 4b04 	ldr.w	r4, [r3], #4
    va_list ap;

    ret = OPUS_OK;
    va_start(ap, request);

    celt_enc = (CELTEncoder*)((char*)st+st->celt_enc_offset);
   3247a:	6800      	ldr	r0, [r0, #0]
    va_start(ap, request);
   3247c:	9300      	str	r3, [sp, #0]

    switch (request)
   3247e:	f640 72b6 	movw	r2, #4022	; 0xfb6
   32482:	4294      	cmp	r4, r2
    celt_enc = (CELTEncoder*)((char*)st+st->celt_enc_offset);
   32484:	eb05 0600 	add.w	r6, r5, r0
    switch (request)
   32488:	f000 82af 	beq.w	329ea <opus_encoder_ctl+0x57e>
   3248c:	dd29      	ble.n	324e2 <opus_encoder_ctl+0x76>
   3248e:	f640 72c9 	movw	r2, #4041	; 0xfc9
   32492:	4294      	cmp	r4, r2
   32494:	f000 81a1 	beq.w	327da <opus_encoder_ctl+0x36e>
   32498:	dc65      	bgt.n	32566 <opus_encoder_ctl+0xfa>
   3249a:	f640 72bc 	movw	r2, #4028	; 0xfbc
   3249e:	4294      	cmp	r4, r2
   324a0:	f000 82b0 	beq.w	32a04 <opus_encoder_ctl+0x598>
   324a4:	f340 80c0 	ble.w	32628 <opus_encoder_ctl+0x1bc>
   324a8:	f640 72c4 	movw	r2, #4036	; 0xfc4
   324ac:	4294      	cmp	r4, r2
   324ae:	f000 824e 	beq.w	3294e <opus_encoder_ctl+0x4e2>
   324b2:	f300 813e 	bgt.w	32732 <opus_encoder_ctl+0x2c6>
   324b6:	f640 72bd 	movw	r2, #4029	; 0xfbd
   324ba:	4294      	cmp	r4, r2
   324bc:	f000 8274 	beq.w	329a8 <opus_encoder_ctl+0x53c>
   324c0:	f640 73bf 	movw	r3, #4031	; 0xfbf
   324c4:	429c      	cmp	r4, r3
   324c6:	f040 81cc 	bne.w	32862 <opus_encoder_ctl+0x3f6>
            *value = st->Fs;
        }
        break;
        case OPUS_GET_FINAL_RANGE_REQUEST:
        {
            opus_uint32 *value = va_arg(ap, opus_uint32*);
   324ca:	9b00      	ldr	r3, [sp, #0]
   324cc:	681a      	ldr	r2, [r3, #0]
   324ce:	3304      	adds	r3, #4
   324d0:	9300      	str	r3, [sp, #0]
            if (!value)
   324d2:	2a00      	cmp	r2, #0
   324d4:	f000 816c 	beq.w	327b0 <opus_encoder_ctl+0x344>
            {
               goto bad_arg;
            }
            *value = st->rangeFinal;
   324d8:	f8d5 3894 	ldr.w	r3, [r5, #2196]	; 0x894
   324dc:	6013      	str	r3, [r2, #0]
    ret = OPUS_OK;
   324de:	2000      	movs	r0, #0
        }
        break;
   324e0:	e10d      	b.n	326fe <opus_encoder_ctl+0x292>
    switch (request)
   324e2:	f640 72a9 	movw	r2, #4009	; 0xfa9
   324e6:	4294      	cmp	r4, r2
   324e8:	f000 82bd 	beq.w	32a66 <opus_encoder_ctl+0x5fa>
   324ec:	dc5c      	bgt.n	325a8 <opus_encoder_ctl+0x13c>
   324ee:	f640 72a4 	movw	r2, #4004	; 0xfa4
   324f2:	4294      	cmp	r4, r2
   324f4:	f000 817b 	beq.w	327ee <opus_encoder_ctl+0x382>
   324f8:	f300 80dd 	bgt.w	326b6 <opus_encoder_ctl+0x24a>
   324fc:	f640 72a1 	movw	r2, #4001	; 0xfa1
   32500:	4294      	cmp	r4, r2
   32502:	f000 82bb 	beq.w	32a7c <opus_encoder_ctl+0x610>
   32506:	f340 8143 	ble.w	32790 <opus_encoder_ctl+0x324>
   3250a:	f640 72a2 	movw	r2, #4002	; 0xfa2
   3250e:	4294      	cmp	r4, r2
   32510:	f000 81b4 	beq.w	3287c <opus_encoder_ctl+0x410>
   32514:	f640 73a3 	movw	r3, #4003	; 0xfa3
   32518:	429c      	cmp	r4, r3
   3251a:	f040 81a2 	bne.w	32862 <opus_encoder_ctl+0x3f6>
            opus_int32 *value = va_arg(ap, opus_int32*);
   3251e:	9b00      	ldr	r3, [sp, #0]
   32520:	6819      	ldr	r1, [r3, #0]
   32522:	3304      	adds	r3, #4
   32524:	9300      	str	r3, [sp, #0]
            if (!value)
   32526:	2900      	cmp	r1, #0
   32528:	f000 8142 	beq.w	327b0 <opus_encoder_ctl+0x344>
            *value = user_bitrate_to_bitrate(st, st->prev_framesize, 1276);
   3252c:	f8d5 20e8 	ldr.w	r2, [r5, #232]	; 0xe8
  if(!frame_size)frame_size=st->Fs/400;
   32530:	b93a      	cbnz	r2, 32542 <opus_encoder_ctl+0xd6>
   32532:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
   32536:	48c5      	ldr	r0, [pc, #788]	; (3284c <opus_encoder_ctl+0x3e0>)
   32538:	17da      	asrs	r2, r3, #31
   3253a:	fb80 0303 	smull	r0, r3, r0, r3
   3253e:	ebc2 12e3 	rsb	r2, r2, r3, asr #7
  if (st->user_bitrate_bps==OPUS_AUTO)
   32542:	f8d5 30a4 	ldr.w	r3, [r5, #164]	; 0xa4
   32546:	f513 7f7a 	cmn.w	r3, #1000	; 0x3e8
   3254a:	f000 82e3 	beq.w	32b14 <opus_encoder_ctl+0x6a8>
  else if (st->user_bitrate_bps==OPUS_BITRATE_MAX)
   3254e:	1c58      	adds	r0, r3, #1
   32550:	f040 8092 	bne.w	32678 <opus_encoder_ctl+0x20c>
    return max_data_bytes*8*st->Fs/frame_size;
   32554:	f8d5 0090 	ldr.w	r0, [r5, #144]	; 0x90
   32558:	f242 73e0 	movw	r3, #10208	; 0x27e0
   3255c:	fb03 f300 	mul.w	r3, r3, r0
   32560:	fb93 f3f2 	sdiv	r3, r3, r2
   32564:	e088      	b.n	32678 <opus_encoder_ctl+0x20c>
    switch (request)
   32566:	f242 721f 	movw	r2, #10015	; 0x271f
   3256a:	4294      	cmp	r4, r2
   3256c:	f000 8232 	beq.w	329d4 <opus_encoder_ctl+0x568>
   32570:	dd3b      	ble.n	325ea <opus_encoder_ctl+0x17e>
   32572:	f642 22fa 	movw	r2, #11002	; 0x2afa
   32576:	4294      	cmp	r4, r2
   32578:	f000 81ff 	beq.w	3297a <opus_encoder_ctl+0x50e>
   3257c:	f300 80c4 	bgt.w	32708 <opus_encoder_ctl+0x29c>
   32580:	f242 7228 	movw	r2, #10024	; 0x2728
   32584:	4294      	cmp	r4, r2
   32586:	f000 8207 	beq.w	32998 <opus_encoder_ctl+0x52c>
   3258a:	f242 732a 	movw	r3, #10026	; 0x272a
   3258e:	429c      	cmp	r4, r3
   32590:	f040 8167 	bne.w	32862 <opus_encoder_ctl+0x3f6>
            ret = celt_encoder_ctl(celt_enc, OPUS_SET_LFE(value));
        }
        break;
        case OPUS_SET_ENERGY_MASK_REQUEST:
        {
            opus_val16 *value = va_arg(ap, opus_val16*);
   32594:	9b00      	ldr	r3, [sp, #0]
   32596:	681a      	ldr	r2, [r3, #0]
            st->energy_masking = value;
   32598:	f8c5 20fc 	str.w	r2, [r5, #252]	; 0xfc
            ret = celt_encoder_ctl(celt_enc, OPUS_SET_ENERGY_MASK(value));
   3259c:	4630      	mov	r0, r6
   3259e:	f242 712a 	movw	r1, #10026	; 0x272a
   325a2:	f7f6 fc83 	bl	28eac <opus_custom_encoder_ctl>
        }
        break;
   325a6:	e0aa      	b.n	326fe <opus_encoder_ctl+0x292>
    switch (request)
   325a8:	f640 72ae 	movw	r2, #4014	; 0xfae
   325ac:	4294      	cmp	r4, r2
   325ae:	f000 826f 	beq.w	32a90 <opus_encoder_ctl+0x624>
   325b2:	dd64      	ble.n	3267e <opus_encoder_ctl+0x212>
   325b4:	f640 72b1 	movw	r2, #4017	; 0xfb1
   325b8:	4294      	cmp	r4, r2
   325ba:	f000 81bd 	beq.w	32938 <opus_encoder_ctl+0x4cc>
   325be:	f300 80d4 	bgt.w	3276a <opus_encoder_ctl+0x2fe>
   325c2:	f640 72af 	movw	r2, #4015	; 0xfaf
   325c6:	4294      	cmp	r4, r2
   325c8:	f000 81cd 	beq.w	32966 <opus_encoder_ctl+0x4fa>
   325cc:	f5b4 6f7b 	cmp.w	r4, #4016	; 0xfb0
   325d0:	f040 8147 	bne.w	32862 <opus_encoder_ctl+0x3f6>
            opus_int32 value = va_arg(ap, opus_int32);
   325d4:	9b00      	ldr	r3, [sp, #0]
   325d6:	681a      	ldr	r2, [r3, #0]
   325d8:	3304      	adds	r3, #4
            if(value<0 || value>1)
   325da:	2a01      	cmp	r2, #1
            opus_int32 value = va_arg(ap, opus_int32);
   325dc:	9300      	str	r3, [sp, #0]
            if(value<0 || value>1)
   325de:	f200 80e7 	bhi.w	327b0 <opus_encoder_ctl+0x344>
            st->use_dtx = value;
   325e2:	f8c5 20b8 	str.w	r2, [r5, #184]	; 0xb8
    ret = OPUS_OK;
   325e6:	2000      	movs	r0, #0
        break;
   325e8:	e089      	b.n	326fe <opus_encoder_ctl+0x292>
    switch (request)
   325ea:	f640 72cb 	movw	r2, #4043	; 0xfcb
   325ee:	4294      	cmp	r4, r2
   325f0:	f000 816a 	beq.w	328c8 <opus_encoder_ctl+0x45c>
   325f4:	f2c0 80df 	blt.w	327b6 <opus_encoder_ctl+0x34a>
   325f8:	f640 72ce 	movw	r2, #4046	; 0xfce
   325fc:	4294      	cmp	r4, r2
   325fe:	f000 816d 	beq.w	328dc <opus_encoder_ctl+0x470>
   32602:	f640 73cf 	movw	r3, #4047	; 0xfcf
   32606:	429c      	cmp	r4, r3
   32608:	f040 812b 	bne.w	32862 <opus_encoder_ctl+0x3f6>
            opus_int32 *value = va_arg(ap, opus_int32*);
   3260c:	9b00      	ldr	r3, [sp, #0]
   3260e:	681a      	ldr	r2, [r3, #0]
   32610:	3304      	adds	r3, #4
   32612:	9300      	str	r3, [sp, #0]
            if (!value)
   32614:	2a00      	cmp	r2, #0
   32616:	f000 80cb 	beq.w	327b0 <opus_encoder_ctl+0x344>
            celt_encoder_ctl(celt_enc, OPUS_GET_PHASE_INVERSION_DISABLED(value));
   3261a:	4630      	mov	r0, r6
   3261c:	f640 71cf 	movw	r1, #4047	; 0xfcf
   32620:	f7f6 fc44 	bl	28eac <opus_custom_encoder_ctl>
    ret = OPUS_OK;
   32624:	2000      	movs	r0, #0
        break;
   32626:	e06a      	b.n	326fe <opus_encoder_ctl+0x292>
    switch (request)
   32628:	f640 72b8 	movw	r2, #4024	; 0xfb8
   3262c:	4294      	cmp	r4, r2
   3262e:	f000 8175 	beq.w	3291c <opus_encoder_ctl+0x4b0>
   32632:	f2c0 80f4 	blt.w	3281e <opus_encoder_ctl+0x3b2>
   32636:	f640 72b9 	movw	r2, #4025	; 0xfb9
   3263a:	4294      	cmp	r4, r2
   3263c:	f000 8108 	beq.w	32850 <opus_encoder_ctl+0x3e4>
   32640:	f640 73bb 	movw	r3, #4027	; 0xfbb
   32644:	429c      	cmp	r4, r3
   32646:	f040 810c 	bne.w	32862 <opus_encoder_ctl+0x3f6>
            opus_int32 *value = va_arg(ap, opus_int32*);
   3264a:	9b00      	ldr	r3, [sp, #0]
   3264c:	6819      	ldr	r1, [r3, #0]
   3264e:	3304      	adds	r3, #4
   32650:	9300      	str	r3, [sp, #0]
            if (!value)
   32652:	2900      	cmp	r1, #0
   32654:	f000 80ac 	beq.w	327b0 <opus_encoder_ctl+0x344>
            *value = st->Fs/400;
   32658:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
   3265c:	4a7b      	ldr	r2, [pc, #492]	; (3284c <opus_encoder_ctl+0x3e0>)
            if (st->application != OPUS_APPLICATION_RESTRICTED_LOWDELAY)
   3265e:	6ee8      	ldr	r0, [r5, #108]	; 0x6c
            *value = st->Fs/400;
   32660:	fb82 4203 	smull	r4, r2, r2, r3
   32664:	17db      	asrs	r3, r3, #31
   32666:	ebc3 13e2 	rsb	r3, r3, r2, asr #7
            if (st->application != OPUS_APPLICATION_RESTRICTED_LOWDELAY)
   3266a:	f640 0203 	movw	r2, #2051	; 0x803
   3266e:	4290      	cmp	r0, r2
            *value = st->Fs/400;
   32670:	600b      	str	r3, [r1, #0]
            if (st->application != OPUS_APPLICATION_RESTRICTED_LOWDELAY)
   32672:	d002      	beq.n	3267a <opus_encoder_ctl+0x20e>
                *value += st->delay_compensation;
   32674:	6f6a      	ldr	r2, [r5, #116]	; 0x74
   32676:	4413      	add	r3, r2
   32678:	600b      	str	r3, [r1, #0]
    ret = OPUS_OK;
   3267a:	2000      	movs	r0, #0
   3267c:	e03f      	b.n	326fe <opus_encoder_ctl+0x292>
    switch (request)
   3267e:	f640 72ab 	movw	r2, #4011	; 0xfab
   32682:	4294      	cmp	r4, r2
   32684:	f000 8137 	beq.w	328f6 <opus_encoder_ctl+0x48a>
   32688:	f2c0 80d2 	blt.w	32830 <opus_encoder_ctl+0x3c4>
   3268c:	f640 72ac 	movw	r2, #4012	; 0xfac
   32690:	4294      	cmp	r4, r2
   32692:	f000 813a 	beq.w	3290a <opus_encoder_ctl+0x49e>
   32696:	f640 73ad 	movw	r3, #4013	; 0xfad
   3269a:	429c      	cmp	r4, r3
   3269c:	f040 80e1 	bne.w	32862 <opus_encoder_ctl+0x3f6>
            opus_int32 *value = va_arg(ap, opus_int32*);
   326a0:	9b00      	ldr	r3, [sp, #0]
   326a2:	681a      	ldr	r2, [r3, #0]
   326a4:	3304      	adds	r3, #4
   326a6:	9300      	str	r3, [sp, #0]
            if (!value)
   326a8:	2a00      	cmp	r2, #0
   326aa:	f000 8081 	beq.w	327b0 <opus_encoder_ctl+0x344>
            *value = st->silk_mode.useInBandFEC;
   326ae:	6b2b      	ldr	r3, [r5, #48]	; 0x30
   326b0:	6013      	str	r3, [r2, #0]
    ret = OPUS_OK;
   326b2:	2000      	movs	r0, #0
        break;
   326b4:	e023      	b.n	326fe <opus_encoder_ctl+0x292>
    switch (request)
   326b6:	f640 72a6 	movw	r2, #4006	; 0xfa6
   326ba:	4294      	cmp	r4, r2
   326bc:	f000 80f7 	beq.w	328ae <opus_encoder_ctl+0x442>
   326c0:	f2c0 8081 	blt.w	327c6 <opus_encoder_ctl+0x35a>
   326c4:	f640 72a7 	movw	r2, #4007	; 0xfa7
   326c8:	4294      	cmp	r4, r2
   326ca:	f000 80cd 	beq.w	32868 <opus_encoder_ctl+0x3fc>
   326ce:	f640 73a8 	movw	r3, #4008	; 0xfa8
   326d2:	429c      	cmp	r4, r3
   326d4:	f040 80c5 	bne.w	32862 <opus_encoder_ctl+0x3f6>
            opus_int32 value = va_arg(ap, opus_int32);
   326d8:	9b00      	ldr	r3, [sp, #0]
   326da:	681a      	ldr	r2, [r3, #0]
            if ((value < OPUS_BANDWIDTH_NARROWBAND || value > OPUS_BANDWIDTH_FULLBAND) && value != OPUS_AUTO)
   326dc:	f2a2 414d 	subw	r1, r2, #1101	; 0x44d
            opus_int32 value = va_arg(ap, opus_int32);
   326e0:	3304      	adds	r3, #4
            if ((value < OPUS_BANDWIDTH_NARROWBAND || value > OPUS_BANDWIDTH_FULLBAND) && value != OPUS_AUTO)
   326e2:	2904      	cmp	r1, #4
            opus_int32 value = va_arg(ap, opus_int32);
   326e4:	9300      	str	r3, [sp, #0]
            if ((value < OPUS_BANDWIDTH_NARROWBAND || value > OPUS_BANDWIDTH_FULLBAND) && value != OPUS_AUTO)
   326e6:	f240 8204 	bls.w	32af2 <opus_encoder_ctl+0x686>
   326ea:	f512 7f7a 	cmn.w	r2, #1000	; 0x3e8
            st->user_bandwidth = value;
   326ee:	bf08      	it	eq
   326f0:	f8c5 2080 	streq.w	r2, [r5, #128]	; 0x80
            if ((value < OPUS_BANDWIDTH_NARROWBAND || value > OPUS_BANDWIDTH_FULLBAND) && value != OPUS_AUTO)
   326f4:	d15c      	bne.n	327b0 <opus_encoder_ctl+0x344>
                st->silk_mode.maxInternalSampleRate = 16000;
   326f6:	f44f 537a 	mov.w	r3, #16000	; 0x3e80
   326fa:	616b      	str	r3, [r5, #20]
    ret = OPUS_OK;
   326fc:	2000      	movs	r0, #0
    va_end(ap);
    return ret;
bad_arg:
    va_end(ap);
    return OPUS_BAD_ARG;
}
   326fe:	b01a      	add	sp, #104	; 0x68
   32700:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   32704:	b003      	add	sp, #12
   32706:	4770      	bx	lr
    switch (request)
   32708:	f642 320a 	movw	r2, #11018	; 0x2b0a
   3270c:	4294      	cmp	r4, r2
   3270e:	f000 81cc 	beq.w	32aaa <opus_encoder_ctl+0x63e>
   32712:	f642 330b 	movw	r3, #11019	; 0x2b0b
   32716:	429c      	cmp	r4, r3
   32718:	f040 80a3 	bne.w	32862 <opus_encoder_ctl+0x3f6>
            opus_int32 *value = va_arg(ap, opus_int32*);
   3271c:	9b00      	ldr	r3, [sp, #0]
   3271e:	681a      	ldr	r2, [r3, #0]
   32720:	3304      	adds	r3, #4
   32722:	9300      	str	r3, [sp, #0]
            if (!value)
   32724:	2a00      	cmp	r2, #0
   32726:	d043      	beq.n	327b0 <opus_encoder_ctl+0x344>
            *value = st->voice_ratio;
   32728:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
   3272c:	6013      	str	r3, [r2, #0]
    ret = OPUS_OK;
   3272e:	2000      	movs	r0, #0
        break;
   32730:	e7e5      	b.n	326fe <opus_encoder_ctl+0x292>
    switch (request)
   32732:	f640 72c5 	movw	r2, #4037	; 0xfc5
   32736:	4294      	cmp	r4, r2
   32738:	f000 8141 	beq.w	329be <opus_encoder_ctl+0x552>
   3273c:	f640 73c8 	movw	r3, #4040	; 0xfc8
   32740:	429c      	cmp	r4, r3
   32742:	f040 808e 	bne.w	32862 <opus_encoder_ctl+0x3f6>
            opus_int32 value = va_arg(ap, opus_int32);
   32746:	9b00      	ldr	r3, [sp, #0]
   32748:	681a      	ldr	r2, [r3, #0]
                value != OPUS_FRAMESIZE_100_MS && value != OPUS_FRAMESIZE_120_MS)
   3274a:	f5a2 519c 	sub.w	r1, r2, #4992	; 0x1380
   3274e:	3908      	subs	r1, #8
            opus_int32 value = va_arg(ap, opus_int32);
   32750:	3304      	adds	r3, #4
            if (value != OPUS_FRAMESIZE_ARG    && value != OPUS_FRAMESIZE_2_5_MS &&
   32752:	2909      	cmp	r1, #9
            opus_int32 value = va_arg(ap, opus_int32);
   32754:	9300      	str	r3, [sp, #0]
            if (value != OPUS_FRAMESIZE_ARG    && value != OPUS_FRAMESIZE_2_5_MS &&
   32756:	d82b      	bhi.n	327b0 <opus_encoder_ctl+0x344>
            st->variable_duration = value;
   32758:	f8c5 209c 	str.w	r2, [r5, #156]	; 0x9c
            celt_encoder_ctl(celt_enc, OPUS_SET_EXPERT_FRAME_DURATION(value));
   3275c:	4630      	mov	r0, r6
   3275e:	f640 71c8 	movw	r1, #4040	; 0xfc8
   32762:	f7f6 fba3 	bl	28eac <opus_custom_encoder_ctl>
    ret = OPUS_OK;
   32766:	2000      	movs	r0, #0
        break;
   32768:	e7c9      	b.n	326fe <opus_encoder_ctl+0x292>
    switch (request)
   3276a:	f640 72b4 	movw	r2, #4020	; 0xfb4
   3276e:	4294      	cmp	r4, r2
   32770:	f000 81a6 	beq.w	32ac0 <opus_encoder_ctl+0x654>
   32774:	f640 73b5 	movw	r3, #4021	; 0xfb5
   32778:	429c      	cmp	r4, r3
   3277a:	d172      	bne.n	32862 <opus_encoder_ctl+0x3f6>
            opus_int32 *value = va_arg(ap, opus_int32*);
   3277c:	9b00      	ldr	r3, [sp, #0]
   3277e:	681a      	ldr	r2, [r3, #0]
   32780:	3304      	adds	r3, #4
   32782:	9300      	str	r3, [sp, #0]
            if (!value)
   32784:	b1a2      	cbz	r2, 327b0 <opus_encoder_ctl+0x344>
            *value = st->vbr_constraint;
   32786:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
   3278a:	6013      	str	r3, [r2, #0]
    ret = OPUS_OK;
   3278c:	2000      	movs	r0, #0
        break;
   3278e:	e7b6      	b.n	326fe <opus_encoder_ctl+0x292>
    switch (request)
   32790:	f5b4 6f7a 	cmp.w	r4, #4000	; 0xfa0
   32794:	d165      	bne.n	32862 <opus_encoder_ctl+0x3f6>
            opus_int32 value = va_arg(ap, opus_int32);
   32796:	681a      	ldr	r2, [r3, #0]
            if (   (value != OPUS_APPLICATION_VOIP && value != OPUS_APPLICATION_AUDIO
   32798:	f5a2 6100 	sub.w	r1, r2, #2048	; 0x800
            opus_int32 value = va_arg(ap, opus_int32);
   3279c:	3304      	adds	r3, #4
            if (   (value != OPUS_APPLICATION_VOIP && value != OPUS_APPLICATION_AUDIO
   3279e:	2901      	cmp	r1, #1
            opus_int32 value = va_arg(ap, opus_int32);
   327a0:	9300      	str	r3, [sp, #0]
            if (   (value != OPUS_APPLICATION_VOIP && value != OPUS_APPLICATION_AUDIO
   327a2:	f240 819c 	bls.w	32ade <opus_encoder_ctl+0x672>
                 && value != OPUS_APPLICATION_RESTRICTED_LOWDELAY)
   327a6:	f640 0303 	movw	r3, #2051	; 0x803
   327aa:	429a      	cmp	r2, r3
   327ac:	f000 8197 	beq.w	32ade <opus_encoder_ctl+0x672>
    return OPUS_BAD_ARG;
   327b0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   327b4:	e7a3      	b.n	326fe <opus_encoder_ctl+0x292>
           opus_int32 value = va_arg(ap, opus_int32);
   327b6:	681a      	ldr	r2, [r3, #0]
   327b8:	3304      	adds	r3, #4
           if (value > 1 || value < 0)
   327ba:	2a01      	cmp	r2, #1
           opus_int32 value = va_arg(ap, opus_int32);
   327bc:	9300      	str	r3, [sp, #0]
           if (value > 1 || value < 0)
   327be:	d8f7      	bhi.n	327b0 <opus_encoder_ctl+0x344>
           st->silk_mode.reducedDependency = value;
   327c0:	64ea      	str	r2, [r5, #76]	; 0x4c
    ret = OPUS_OK;
   327c2:	2000      	movs	r0, #0
        break;
   327c4:	e79b      	b.n	326fe <opus_encoder_ctl+0x292>
            opus_int32 *value = va_arg(ap, opus_int32*);
   327c6:	681a      	ldr	r2, [r3, #0]
   327c8:	3304      	adds	r3, #4
   327ca:	9300      	str	r3, [sp, #0]
            if (!value)
   327cc:	2a00      	cmp	r2, #0
   327ce:	d0ef      	beq.n	327b0 <opus_encoder_ctl+0x344>
            *value = st->max_bandwidth;
   327d0:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
   327d4:	6013      	str	r3, [r2, #0]
    ret = OPUS_OK;
   327d6:	2000      	movs	r0, #0
        break;
   327d8:	e791      	b.n	326fe <opus_encoder_ctl+0x292>
            opus_int32 *value = va_arg(ap, opus_int32*);
   327da:	681a      	ldr	r2, [r3, #0]
   327dc:	3304      	adds	r3, #4
   327de:	9300      	str	r3, [sp, #0]
            if (!value)
   327e0:	2a00      	cmp	r2, #0
   327e2:	d0e5      	beq.n	327b0 <opus_encoder_ctl+0x344>
            *value = st->variable_duration;
   327e4:	f8d5 309c 	ldr.w	r3, [r5, #156]	; 0x9c
   327e8:	6013      	str	r3, [r2, #0]
    ret = OPUS_OK;
   327ea:	2000      	movs	r0, #0
        break;
   327ec:	e787      	b.n	326fe <opus_encoder_ctl+0x292>
            opus_int32 value = va_arg(ap, opus_int32);
   327ee:	681a      	ldr	r2, [r3, #0]
            if (value < OPUS_BANDWIDTH_NARROWBAND || value > OPUS_BANDWIDTH_FULLBAND)
   327f0:	f2a2 414d 	subw	r1, r2, #1101	; 0x44d
            opus_int32 value = va_arg(ap, opus_int32);
   327f4:	3304      	adds	r3, #4
            if (value < OPUS_BANDWIDTH_NARROWBAND || value > OPUS_BANDWIDTH_FULLBAND)
   327f6:	2904      	cmp	r1, #4
            opus_int32 value = va_arg(ap, opus_int32);
   327f8:	9300      	str	r3, [sp, #0]
            if (value < OPUS_BANDWIDTH_NARROWBAND || value > OPUS_BANDWIDTH_FULLBAND)
   327fa:	d8d9      	bhi.n	327b0 <opus_encoder_ctl+0x344>
            if (st->max_bandwidth == OPUS_BANDWIDTH_NARROWBAND) {
   327fc:	f240 434d 	movw	r3, #1101	; 0x44d
   32800:	429a      	cmp	r2, r3
            st->max_bandwidth = value;
   32802:	f8c5 2084 	str.w	r2, [r5, #132]	; 0x84
            if (st->max_bandwidth == OPUS_BANDWIDTH_NARROWBAND) {
   32806:	f000 8165 	beq.w	32ad4 <opus_encoder_ctl+0x668>
            } else if (st->max_bandwidth == OPUS_BANDWIDTH_MEDIUMBAND) {
   3280a:	f240 434e 	movw	r3, #1102	; 0x44e
   3280e:	429a      	cmp	r2, r3
   32810:	f47f af71 	bne.w	326f6 <opus_encoder_ctl+0x28a>
                st->silk_mode.maxInternalSampleRate = 12000;
   32814:	f642 63e0 	movw	r3, #12000	; 0x2ee0
   32818:	616b      	str	r3, [r5, #20]
    ret = OPUS_OK;
   3281a:	2000      	movs	r0, #0
   3281c:	e76f      	b.n	326fe <opus_encoder_ctl+0x292>
            opus_int32 *value = va_arg(ap, opus_int32*);
   3281e:	681a      	ldr	r2, [r3, #0]
   32820:	3304      	adds	r3, #4
   32822:	9300      	str	r3, [sp, #0]
            if (!value)
   32824:	2a00      	cmp	r2, #0
   32826:	d0c3      	beq.n	327b0 <opus_encoder_ctl+0x344>
            *value = st->force_channels;
   32828:	6fab      	ldr	r3, [r5, #120]	; 0x78
   3282a:	6013      	str	r3, [r2, #0]
    ret = OPUS_OK;
   3282c:	2000      	movs	r0, #0
        break;
   3282e:	e766      	b.n	326fe <opus_encoder_ctl+0x292>
            opus_int32 value = va_arg(ap, opus_int32);
   32830:	681a      	ldr	r2, [r3, #0]
   32832:	3304      	adds	r3, #4
            if(value<0 || value>10)
   32834:	2a0a      	cmp	r2, #10
            opus_int32 value = va_arg(ap, opus_int32);
   32836:	9300      	str	r3, [sp, #0]
            if(value<0 || value>10)
   32838:	d8ba      	bhi.n	327b0 <opus_encoder_ctl+0x344>
            st->silk_mode.complexity = value;
   3283a:	62ea      	str	r2, [r5, #44]	; 0x2c
            celt_encoder_ctl(celt_enc, OPUS_SET_COMPLEXITY(value));
   3283c:	4630      	mov	r0, r6
   3283e:	f640 71aa 	movw	r1, #4010	; 0xfaa
   32842:	f7f6 fb33 	bl	28eac <opus_custom_encoder_ctl>
    ret = OPUS_OK;
   32846:	2000      	movs	r0, #0
        break;
   32848:	e759      	b.n	326fe <opus_encoder_ctl+0x292>
   3284a:	bf00      	nop
   3284c:	51eb851f 	.word	0x51eb851f
            opus_int32 *value = va_arg(ap, opus_int32*);
   32850:	681a      	ldr	r2, [r3, #0]
   32852:	3304      	adds	r3, #4
   32854:	9300      	str	r3, [sp, #0]
            if (!value)
   32856:	2a00      	cmp	r2, #0
   32858:	d0aa      	beq.n	327b0 <opus_encoder_ctl+0x344>
            *value = st->signal_type;
   3285a:	6feb      	ldr	r3, [r5, #124]	; 0x7c
   3285c:	6013      	str	r3, [r2, #0]
    ret = OPUS_OK;
   3285e:	2000      	movs	r0, #0
        break;
   32860:	e74d      	b.n	326fe <opus_encoder_ctl+0x292>
            ret = OPUS_UNIMPLEMENTED;
   32862:	f06f 0004 	mvn.w	r0, #4
   32866:	e74a      	b.n	326fe <opus_encoder_ctl+0x292>
            opus_int32 *value = va_arg(ap, opus_int32*);
   32868:	681a      	ldr	r2, [r3, #0]
   3286a:	3304      	adds	r3, #4
   3286c:	9300      	str	r3, [sp, #0]
            if (!value)
   3286e:	2a00      	cmp	r2, #0
   32870:	d09e      	beq.n	327b0 <opus_encoder_ctl+0x344>
            *value = st->use_vbr;
   32872:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
   32876:	6013      	str	r3, [r2, #0]
    ret = OPUS_OK;
   32878:	2000      	movs	r0, #0
        break;
   3287a:	e740      	b.n	326fe <opus_encoder_ctl+0x292>
            opus_int32 value = va_arg(ap, opus_int32);
   3287c:	681a      	ldr	r2, [r3, #0]
   3287e:	3304      	adds	r3, #4
            if (value != OPUS_AUTO && value != OPUS_BITRATE_MAX)
   32880:	f512 7f7a 	cmn.w	r2, #1000	; 0x3e8
            opus_int32 value = va_arg(ap, opus_int32);
   32884:	9300      	str	r3, [sp, #0]
            if (value != OPUS_AUTO && value != OPUS_BITRATE_MAX)
   32886:	d00e      	beq.n	328a6 <opus_encoder_ctl+0x43a>
   32888:	1c54      	adds	r4, r2, #1
   3288a:	d00c      	beq.n	328a6 <opus_encoder_ctl+0x43a>
                if (value <= 0)
   3288c:	2a00      	cmp	r2, #0
   3288e:	dd8f      	ble.n	327b0 <opus_encoder_ctl+0x344>
                else if (value <= 500)
   32890:	f5b2 7ffa 	cmp.w	r2, #500	; 0x1f4
   32894:	f340 8149 	ble.w	32b2a <opus_encoder_ctl+0x6be>
                else if (value > (opus_int32)300000*st->channels)
   32898:	6f29      	ldr	r1, [r5, #112]	; 0x70
   3289a:	4ba5      	ldr	r3, [pc, #660]	; (32b30 <opus_encoder_ctl+0x6c4>)
   3289c:	fb03 f301 	mul.w	r3, r3, r1
   328a0:	429a      	cmp	r2, r3
   328a2:	bfa8      	it	ge
   328a4:	461a      	movge	r2, r3
            st->user_bitrate_bps = value;
   328a6:	f8c5 20a4 	str.w	r2, [r5, #164]	; 0xa4
    ret = OPUS_OK;
   328aa:	2000      	movs	r0, #0
        break;
   328ac:	e727      	b.n	326fe <opus_encoder_ctl+0x292>
            opus_int32 value = va_arg(ap, opus_int32);
   328ae:	681a      	ldr	r2, [r3, #0]
   328b0:	3304      	adds	r3, #4
            if(value<0 || value>1)
   328b2:	2a01      	cmp	r2, #1
            opus_int32 value = va_arg(ap, opus_int32);
   328b4:	9300      	str	r3, [sp, #0]
            if(value<0 || value>1)
   328b6:	f63f af7b 	bhi.w	327b0 <opus_encoder_ctl+0x344>
            st->silk_mode.useCBR = 1-value;
   328ba:	f1c2 0301 	rsb	r3, r2, #1
            st->use_vbr = value;
   328be:	f8c5 2094 	str.w	r2, [r5, #148]	; 0x94
            st->silk_mode.useCBR = 1-value;
   328c2:	63eb      	str	r3, [r5, #60]	; 0x3c
    ret = OPUS_OK;
   328c4:	2000      	movs	r0, #0
        break;
   328c6:	e71a      	b.n	326fe <opus_encoder_ctl+0x292>
           opus_int32 *value = va_arg(ap, opus_int32*);
   328c8:	681a      	ldr	r2, [r3, #0]
   328ca:	3304      	adds	r3, #4
   328cc:	9300      	str	r3, [sp, #0]
           if (!value)
   328ce:	2a00      	cmp	r2, #0
   328d0:	f43f af6e 	beq.w	327b0 <opus_encoder_ctl+0x344>
           *value = st->silk_mode.reducedDependency;
   328d4:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
   328d6:	6013      	str	r3, [r2, #0]
    ret = OPUS_OK;
   328d8:	2000      	movs	r0, #0
        break;
   328da:	e710      	b.n	326fe <opus_encoder_ctl+0x292>
            opus_int32 value = va_arg(ap, opus_int32);
   328dc:	681a      	ldr	r2, [r3, #0]
   328de:	3304      	adds	r3, #4
            if(value<0 || value>1)
   328e0:	2a01      	cmp	r2, #1
            opus_int32 value = va_arg(ap, opus_int32);
   328e2:	9300      	str	r3, [sp, #0]
            if(value<0 || value>1)
   328e4:	f63f af64 	bhi.w	327b0 <opus_encoder_ctl+0x344>
            celt_encoder_ctl(celt_enc, OPUS_SET_PHASE_INVERSION_DISABLED(value));
   328e8:	4630      	mov	r0, r6
   328ea:	f640 71ce 	movw	r1, #4046	; 0xfce
   328ee:	f7f6 fadd 	bl	28eac <opus_custom_encoder_ctl>
    ret = OPUS_OK;
   328f2:	2000      	movs	r0, #0
        break;
   328f4:	e703      	b.n	326fe <opus_encoder_ctl+0x292>
            opus_int32 *value = va_arg(ap, opus_int32*);
   328f6:	681a      	ldr	r2, [r3, #0]
   328f8:	3304      	adds	r3, #4
   328fa:	9300      	str	r3, [sp, #0]
            if (!value)
   328fc:	2a00      	cmp	r2, #0
   328fe:	f43f af57 	beq.w	327b0 <opus_encoder_ctl+0x344>
            *value = st->silk_mode.complexity;
   32902:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
   32904:	6013      	str	r3, [r2, #0]
    ret = OPUS_OK;
   32906:	2000      	movs	r0, #0
        break;
   32908:	e6f9      	b.n	326fe <opus_encoder_ctl+0x292>
            opus_int32 value = va_arg(ap, opus_int32);
   3290a:	681a      	ldr	r2, [r3, #0]
   3290c:	3304      	adds	r3, #4
            if(value<0 || value>1)
   3290e:	2a01      	cmp	r2, #1
            opus_int32 value = va_arg(ap, opus_int32);
   32910:	9300      	str	r3, [sp, #0]
            if(value<0 || value>1)
   32912:	f63f af4d 	bhi.w	327b0 <opus_encoder_ctl+0x344>
            st->silk_mode.useInBandFEC = value;
   32916:	632a      	str	r2, [r5, #48]	; 0x30
    ret = OPUS_OK;
   32918:	2000      	movs	r0, #0
        break;
   3291a:	e6f0      	b.n	326fe <opus_encoder_ctl+0x292>
            opus_int32 value = va_arg(ap, opus_int32);
   3291c:	681a      	ldr	r2, [r3, #0]
   3291e:	3304      	adds	r3, #4
            if(value!=OPUS_AUTO && value!=OPUS_SIGNAL_VOICE && value!=OPUS_SIGNAL_MUSIC)
   32920:	f512 7f7a 	cmn.w	r2, #1000	; 0x3e8
            opus_int32 value = va_arg(ap, opus_int32);
   32924:	9300      	str	r3, [sp, #0]
            if(value!=OPUS_AUTO && value!=OPUS_SIGNAL_VOICE && value!=OPUS_SIGNAL_MUSIC)
   32926:	d004      	beq.n	32932 <opus_encoder_ctl+0x4c6>
   32928:	f6a2 33b9 	subw	r3, r2, #3001	; 0xbb9
   3292c:	2b01      	cmp	r3, #1
   3292e:	f63f af3f 	bhi.w	327b0 <opus_encoder_ctl+0x344>
            st->signal_type = value;
   32932:	67ea      	str	r2, [r5, #124]	; 0x7c
    ret = OPUS_OK;
   32934:	2000      	movs	r0, #0
        break;
   32936:	e6e2      	b.n	326fe <opus_encoder_ctl+0x292>
            opus_int32 *value = va_arg(ap, opus_int32*);
   32938:	681a      	ldr	r2, [r3, #0]
   3293a:	3304      	adds	r3, #4
   3293c:	9300      	str	r3, [sp, #0]
            if (!value)
   3293e:	2a00      	cmp	r2, #0
   32940:	f43f af36 	beq.w	327b0 <opus_encoder_ctl+0x344>
            *value = st->use_dtx;
   32944:	f8d5 30b8 	ldr.w	r3, [r5, #184]	; 0xb8
   32948:	6013      	str	r3, [r2, #0]
    ret = OPUS_OK;
   3294a:	2000      	movs	r0, #0
        break;
   3294c:	e6d7      	b.n	326fe <opus_encoder_ctl+0x292>
            opus_int32 value = va_arg(ap, opus_int32);
   3294e:	681a      	ldr	r2, [r3, #0]
            if (value<8 || value>24)
   32950:	f1a2 0108 	sub.w	r1, r2, #8
            opus_int32 value = va_arg(ap, opus_int32);
   32954:	3304      	adds	r3, #4
            if (value<8 || value>24)
   32956:	2910      	cmp	r1, #16
            opus_int32 value = va_arg(ap, opus_int32);
   32958:	9300      	str	r3, [sp, #0]
            if (value<8 || value>24)
   3295a:	f63f af29 	bhi.w	327b0 <opus_encoder_ctl+0x344>
            st->lsb_depth=value;
   3295e:	f8c5 20a8 	str.w	r2, [r5, #168]	; 0xa8
    ret = OPUS_OK;
   32962:	2000      	movs	r0, #0
        break;
   32964:	e6cb      	b.n	326fe <opus_encoder_ctl+0x292>
            opus_int32 *value = va_arg(ap, opus_int32*);
   32966:	681a      	ldr	r2, [r3, #0]
   32968:	3304      	adds	r3, #4
   3296a:	9300      	str	r3, [sp, #0]
            if (!value)
   3296c:	2a00      	cmp	r2, #0
   3296e:	f43f af1f 	beq.w	327b0 <opus_encoder_ctl+0x344>
            *value = st->silk_mode.packetLossPercentage;
   32972:	6aab      	ldr	r3, [r5, #40]	; 0x28
   32974:	6013      	str	r3, [r2, #0]
    ret = OPUS_OK;
   32976:	2000      	movs	r0, #0
        break;
   32978:	e6c1      	b.n	326fe <opus_encoder_ctl+0x292>
            opus_int32 value = va_arg(ap, opus_int32);
   3297a:	681a      	ldr	r2, [r3, #0]
            if ((value < MODE_SILK_ONLY || value > MODE_CELT_ONLY) && value != OPUS_AUTO)
   3297c:	f5a2 717a 	sub.w	r1, r2, #1000	; 0x3e8
            opus_int32 value = va_arg(ap, opus_int32);
   32980:	3304      	adds	r3, #4
            if ((value < MODE_SILK_ONLY || value > MODE_CELT_ONLY) && value != OPUS_AUTO)
   32982:	2902      	cmp	r1, #2
            opus_int32 value = va_arg(ap, opus_int32);
   32984:	9300      	str	r3, [sp, #0]
            if ((value < MODE_SILK_ONLY || value > MODE_CELT_ONLY) && value != OPUS_AUTO)
   32986:	d903      	bls.n	32990 <opus_encoder_ctl+0x524>
   32988:	f512 7f7a 	cmn.w	r2, #1000	; 0x3e8
   3298c:	f47f af10 	bne.w	327b0 <opus_encoder_ctl+0x344>
            st->user_forced_mode = value;
   32990:	f8c5 2088 	str.w	r2, [r5, #136]	; 0x88
    ret = OPUS_OK;
   32994:	2000      	movs	r0, #0
        break;
   32996:	e6b2      	b.n	326fe <opus_encoder_ctl+0x292>
            opus_int32 value = va_arg(ap, opus_int32);
   32998:	681a      	ldr	r2, [r3, #0]
            st->lfe = value;
   3299a:	f8c5 20b0 	str.w	r2, [r5, #176]	; 0xb0
            ret = celt_encoder_ctl(celt_enc, OPUS_SET_LFE(value));
   3299e:	4621      	mov	r1, r4
   329a0:	4630      	mov	r0, r6
   329a2:	f7f6 fa83 	bl	28eac <opus_custom_encoder_ctl>
        break;
   329a6:	e6aa      	b.n	326fe <opus_encoder_ctl+0x292>
            opus_int32 *value = va_arg(ap, opus_int32*);
   329a8:	681a      	ldr	r2, [r3, #0]
   329aa:	3304      	adds	r3, #4
   329ac:	9300      	str	r3, [sp, #0]
            if (!value)
   329ae:	2a00      	cmp	r2, #0
   329b0:	f43f aefe 	beq.w	327b0 <opus_encoder_ctl+0x344>
            *value = st->Fs;
   329b4:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
   329b8:	6013      	str	r3, [r2, #0]
    ret = OPUS_OK;
   329ba:	2000      	movs	r0, #0
        break;
   329bc:	e69f      	b.n	326fe <opus_encoder_ctl+0x292>
            opus_int32 *value = va_arg(ap, opus_int32*);
   329be:	681a      	ldr	r2, [r3, #0]
   329c0:	3304      	adds	r3, #4
   329c2:	9300      	str	r3, [sp, #0]
            if (!value)
   329c4:	2a00      	cmp	r2, #0
   329c6:	f43f aef3 	beq.w	327b0 <opus_encoder_ctl+0x344>
            *value = st->lsb_depth;
   329ca:	f8d5 30a8 	ldr.w	r3, [r5, #168]	; 0xa8
   329ce:	6013      	str	r3, [r2, #0]
    ret = OPUS_OK;
   329d0:	2000      	movs	r0, #0
        break;
   329d2:	e694      	b.n	326fe <opus_encoder_ctl+0x292>
           const CELTMode ** value = va_arg(ap, const CELTMode**);
   329d4:	681a      	ldr	r2, [r3, #0]
   329d6:	3304      	adds	r3, #4
   329d8:	9300      	str	r3, [sp, #0]
           if (!value)
   329da:	2a00      	cmp	r2, #0
   329dc:	f43f aee8 	beq.w	327b0 <opus_encoder_ctl+0x344>
           ret = celt_encoder_ctl(celt_enc, CELT_GET_MODE(value));
   329e0:	4621      	mov	r1, r4
   329e2:	4630      	mov	r0, r6
   329e4:	f7f6 fa62 	bl	28eac <opus_custom_encoder_ctl>
        break;
   329e8:	e689      	b.n	326fe <opus_encoder_ctl+0x292>
            opus_int32 value = va_arg(ap, opus_int32);
   329ea:	9a20      	ldr	r2, [sp, #128]	; 0x80
   329ec:	3304      	adds	r3, #4
            if((value<1 || value>st->channels) && value != OPUS_AUTO)
   329ee:	2a00      	cmp	r2, #0
            opus_int32 value = va_arg(ap, opus_int32);
   329f0:	9300      	str	r3, [sp, #0]
            if((value<1 || value>st->channels) && value != OPUS_AUTO)
   329f2:	f340 808a 	ble.w	32b0a <opus_encoder_ctl+0x69e>
   329f6:	6f2b      	ldr	r3, [r5, #112]	; 0x70
   329f8:	4293      	cmp	r3, r2
   329fa:	f6ff aed9 	blt.w	327b0 <opus_encoder_ctl+0x344>
            st->force_channels = value;
   329fe:	67aa      	str	r2, [r5, #120]	; 0x78
    ret = OPUS_OK;
   32a00:	2000      	movs	r0, #0
        break;
   32a02:	e67c      	b.n	326fe <opus_encoder_ctl+0x292>
           silk_enc = (char*)st+st->silk_enc_offset;
   32a04:	686b      	ldr	r3, [r5, #4]
           OPUS_CLEAR(start, sizeof(OpusEncoder) - (start - (char*)st));
   32a06:	f240 72dc 	movw	r2, #2012	; 0x7dc
   32a0a:	2100      	movs	r1, #0
   32a0c:	f105 00bc 	add.w	r0, r5, #188	; 0xbc
           silk_enc = (char*)st+st->silk_enc_offset;
   32a10:	18ef      	adds	r7, r5, r3
           OPUS_CLEAR(start, sizeof(OpusEncoder) - (start - (char*)st));
   32a12:	f002 fba7 	bl	35164 <memset>
           celt_encoder_ctl(celt_enc, OPUS_RESET_STATE);
   32a16:	4621      	mov	r1, r4
   32a18:	4630      	mov	r0, r6
   32a1a:	f7f6 fa47 	bl	28eac <opus_custom_encoder_ctl>
           silk_InitEncoder( silk_enc, st->arch, &dummy );
   32a1e:	aa01      	add	r2, sp, #4
   32a20:	f8d5 10b4 	ldr.w	r1, [r5, #180]	; 0xb4
   32a24:	4638      	mov	r0, r7
   32a26:	f7db fb71 	bl	e10c <silk_InitEncoder>
           st->stream_channels = st->channels;
   32a2a:	6f2b      	ldr	r3, [r5, #112]	; 0x70
   32a2c:	f8c5 30bc 	str.w	r3, [r5, #188]	; 0xbc
           st->prev_HB_gain = Q15ONE;
   32a30:	f647 70ff 	movw	r0, #32767	; 0x7fff
           st->first = 1;
   32a34:	2101      	movs	r1, #1
           st->mode = MODE_HYBRID;
   32a36:	f240 32e9 	movw	r2, #1001	; 0x3e9
           st->bandwidth = OPUS_BANDWIDTH_FULLBAND;
   32a3a:	f240 4351 	movw	r3, #1105	; 0x451
           st->hybrid_stereo_width_Q14 = 1 << 14;
   32a3e:	f44f 4480 	mov.w	r4, #16384	; 0x4000
           st->prev_HB_gain = Q15ONE;
   32a42:	f8a5 00c8 	strh.w	r0, [r5, #200]	; 0xc8
           st->hybrid_stereo_width_Q14 = 1 << 14;
   32a46:	f8a5 40c0 	strh.w	r4, [r5, #192]	; 0xc0
           st->first = 1;
   32a4a:	f8c5 10f8 	str.w	r1, [r5, #248]	; 0xf8
           st->mode = MODE_HYBRID;
   32a4e:	f8c5 20dc 	str.w	r2, [r5, #220]	; 0xdc
           st->bandwidth = OPUS_BANDWIDTH_FULLBAND;
   32a52:	f8c5 30ec 	str.w	r3, [r5, #236]	; 0xec
           st->variable_HP_smth2_Q15 = silk_LSHIFT( silk_lin2log( VARIABLE_HP_MIN_CUTOFF_HZ ), 8 );
   32a56:	203c      	movs	r0, #60	; 0x3c
   32a58:	f7e4 ffae 	bl	179b8 <silk_lin2log>
   32a5c:	0200      	lsls	r0, r0, #8
   32a5e:	f8c5 00c4 	str.w	r0, [r5, #196]	; 0xc4
    ret = OPUS_OK;
   32a62:	2000      	movs	r0, #0
        break;
   32a64:	e64b      	b.n	326fe <opus_encoder_ctl+0x292>
            opus_int32 *value = va_arg(ap, opus_int32*);
   32a66:	681a      	ldr	r2, [r3, #0]
   32a68:	3304      	adds	r3, #4
   32a6a:	9300      	str	r3, [sp, #0]
            if (!value)
   32a6c:	2a00      	cmp	r2, #0
   32a6e:	f43f ae9f 	beq.w	327b0 <opus_encoder_ctl+0x344>
            *value = st->bandwidth;
   32a72:	f8d5 30ec 	ldr.w	r3, [r5, #236]	; 0xec
   32a76:	6013      	str	r3, [r2, #0]
    ret = OPUS_OK;
   32a78:	2000      	movs	r0, #0
        break;
   32a7a:	e640      	b.n	326fe <opus_encoder_ctl+0x292>
            opus_int32 *value = va_arg(ap, opus_int32*);
   32a7c:	681a      	ldr	r2, [r3, #0]
   32a7e:	3304      	adds	r3, #4
   32a80:	9300      	str	r3, [sp, #0]
            if (!value)
   32a82:	2a00      	cmp	r2, #0
   32a84:	f43f ae94 	beq.w	327b0 <opus_encoder_ctl+0x344>
            *value = st->application;
   32a88:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
   32a8a:	6013      	str	r3, [r2, #0]
    ret = OPUS_OK;
   32a8c:	2000      	movs	r0, #0
        break;
   32a8e:	e636      	b.n	326fe <opus_encoder_ctl+0x292>
            opus_int32 value = va_arg(ap, opus_int32);
   32a90:	681a      	ldr	r2, [r3, #0]
   32a92:	3304      	adds	r3, #4
            if (value < 0 || value > 100)
   32a94:	2a64      	cmp	r2, #100	; 0x64
            opus_int32 value = va_arg(ap, opus_int32);
   32a96:	9300      	str	r3, [sp, #0]
            if (value < 0 || value > 100)
   32a98:	f63f ae8a 	bhi.w	327b0 <opus_encoder_ctl+0x344>
            st->silk_mode.packetLossPercentage = value;
   32a9c:	62aa      	str	r2, [r5, #40]	; 0x28
            celt_encoder_ctl(celt_enc, OPUS_SET_PACKET_LOSS_PERC(value));
   32a9e:	4621      	mov	r1, r4
   32aa0:	4630      	mov	r0, r6
   32aa2:	f7f6 fa03 	bl	28eac <opus_custom_encoder_ctl>
    ret = OPUS_OK;
   32aa6:	2000      	movs	r0, #0
        break;
   32aa8:	e629      	b.n	326fe <opus_encoder_ctl+0x292>
            opus_int32 value = va_arg(ap, opus_int32);
   32aaa:	681a      	ldr	r2, [r3, #0]
            if (value<-1 || value>100)
   32aac:	1c51      	adds	r1, r2, #1
            opus_int32 value = va_arg(ap, opus_int32);
   32aae:	3304      	adds	r3, #4
            if (value<-1 || value>100)
   32ab0:	2965      	cmp	r1, #101	; 0x65
            opus_int32 value = va_arg(ap, opus_int32);
   32ab2:	9300      	str	r3, [sp, #0]
            if (value<-1 || value>100)
   32ab4:	f63f ae7c 	bhi.w	327b0 <opus_encoder_ctl+0x344>
            st->voice_ratio = value;
   32ab8:	f8c5 208c 	str.w	r2, [r5, #140]	; 0x8c
    ret = OPUS_OK;
   32abc:	2000      	movs	r0, #0
        break;
   32abe:	e61e      	b.n	326fe <opus_encoder_ctl+0x292>
            opus_int32 value = va_arg(ap, opus_int32);
   32ac0:	681a      	ldr	r2, [r3, #0]
   32ac2:	3304      	adds	r3, #4
            if(value<0 || value>1)
   32ac4:	2a01      	cmp	r2, #1
            opus_int32 value = va_arg(ap, opus_int32);
   32ac6:	9300      	str	r3, [sp, #0]
            if(value<0 || value>1)
   32ac8:	f63f ae72 	bhi.w	327b0 <opus_encoder_ctl+0x344>
            st->vbr_constraint = value;
   32acc:	f8c5 2098 	str.w	r2, [r5, #152]	; 0x98
    ret = OPUS_OK;
   32ad0:	2000      	movs	r0, #0
        break;
   32ad2:	e614      	b.n	326fe <opus_encoder_ctl+0x292>
                st->silk_mode.maxInternalSampleRate = 8000;
   32ad4:	f44f 53fa 	mov.w	r3, #8000	; 0x1f40
   32ad8:	616b      	str	r3, [r5, #20]
    ret = OPUS_OK;
   32ada:	2000      	movs	r0, #0
   32adc:	e60f      	b.n	326fe <opus_encoder_ctl+0x292>
               || (!st->first && st->application != value))
   32ade:	f8d5 30f8 	ldr.w	r3, [r5, #248]	; 0xf8
   32ae2:	b91b      	cbnz	r3, 32aec <opus_encoder_ctl+0x680>
   32ae4:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
   32ae6:	4293      	cmp	r3, r2
   32ae8:	f47f ae62 	bne.w	327b0 <opus_encoder_ctl+0x344>
            st->application = value;
   32aec:	66ea      	str	r2, [r5, #108]	; 0x6c
    ret = OPUS_OK;
   32aee:	2000      	movs	r0, #0
        break;
   32af0:	e605      	b.n	326fe <opus_encoder_ctl+0x292>
            if (st->user_bandwidth == OPUS_BANDWIDTH_NARROWBAND) {
   32af2:	f240 434d 	movw	r3, #1101	; 0x44d
   32af6:	429a      	cmp	r2, r3
            st->user_bandwidth = value;
   32af8:	f8c5 2080 	str.w	r2, [r5, #128]	; 0x80
            if (st->user_bandwidth == OPUS_BANDWIDTH_NARROWBAND) {
   32afc:	d0ea      	beq.n	32ad4 <opus_encoder_ctl+0x668>
            } else if (st->user_bandwidth == OPUS_BANDWIDTH_MEDIUMBAND) {
   32afe:	f240 434e 	movw	r3, #1102	; 0x44e
   32b02:	429a      	cmp	r2, r3
   32b04:	f43f ae86 	beq.w	32814 <opus_encoder_ctl+0x3a8>
   32b08:	e5f5      	b.n	326f6 <opus_encoder_ctl+0x28a>
            if((value<1 || value>st->channels) && value != OPUS_AUTO)
   32b0a:	f512 7f7a 	cmn.w	r2, #1000	; 0x3e8
   32b0e:	f43f af76 	beq.w	329fe <opus_encoder_ctl+0x592>
bad_arg:
   32b12:	e64d      	b.n	327b0 <opus_encoder_ctl+0x344>
    return 60*st->Fs/frame_size + st->Fs*st->channels;
   32b14:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
   32b18:	6f2c      	ldr	r4, [r5, #112]	; 0x70
   32b1a:	ebc3 1003 	rsb	r0, r3, r3, lsl #4
   32b1e:	0080      	lsls	r0, r0, #2
   32b20:	fb90 f2f2 	sdiv	r2, r0, r2
   32b24:	fb04 2303 	mla	r3, r4, r3, r2
   32b28:	e5a6      	b.n	32678 <opus_encoder_ctl+0x20c>
                    value = 500;
   32b2a:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
   32b2e:	e6ba      	b.n	328a6 <opus_encoder_ctl+0x43a>
   32b30:	000493e0 	.word	0x000493e0

00032b34 <opus_packet_pad.part.0>:
opus_int32 opus_repacketizer_out(OpusRepacketizer *rp, unsigned char *data, opus_int32 maxlen)
{
   return opus_repacketizer_out_range_impl(rp, 0, rp->nb_frames, data, maxlen, 0, 0);
}

int opus_packet_pad(unsigned char *data, opus_int32 len, opus_int32 new_len)
   32b34:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      return OPUS_OK;
   else if (len > new_len)
      return OPUS_BAD_ARG;
   opus_repacketizer_init(&rp);
   /* Moving payload to the end of the packet so we can do in-place padding */
   OPUS_MOVE(data+new_len-len, data, len);
   32b38:	1a55      	subs	r5, r2, r1
int opus_packet_pad(unsigned char *data, opus_int32 len, opus_int32 new_len)
   32b3a:	b0d1      	sub	sp, #324	; 0x144
   32b3c:	4607      	mov	r7, r0
   OPUS_MOVE(data+new_len-len, data, len);
   32b3e:	1946      	adds	r6, r0, r5
int opus_packet_pad(unsigned char *data, opus_int32 len, opus_int32 new_len)
   32b40:	460c      	mov	r4, r1
   rp->nb_frames = 0;
   32b42:	f04f 0900 	mov.w	r9, #0
int opus_packet_pad(unsigned char *data, opus_int32 len, opus_int32 new_len)
   32b46:	4690      	mov	r8, r2
   OPUS_MOVE(data+new_len-len, data, len);
   32b48:	4630      	mov	r0, r6
   32b4a:	460a      	mov	r2, r1
   32b4c:	4639      	mov	r1, r7
   rp->nb_frames = 0;
   32b4e:	f8cd 9018 	str.w	r9, [sp, #24]
   OPUS_MOVE(data+new_len-len, data, len);
   32b52:	f002 faa3 	bl	3509c <memmove>
   if (len<1) return OPUS_INVALID_PACKET;
   32b56:	454c      	cmp	r4, r9
   32b58:	f340 8109 	ble.w	32d6e <opus_packet_pad.part.0+0x23a>
      rp->toc = data[0];
   32b5c:	5d7b      	ldrb	r3, [r7, r5]
   32b5e:	f88d 3014 	strb.w	r3, [sp, #20]
      rp->framesize = opus_packet_get_samples_per_frame(data, 8000);
   32b62:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
   32b66:	4630      	mov	r0, r6
   32b68:	f7fc fa14 	bl	2ef94 <opus_packet_get_samples_per_frame>
   curr_nb_frames = opus_packet_get_nb_frames(data, len);
   32b6c:	4621      	mov	r1, r4
      rp->framesize = opus_packet_get_samples_per_frame(data, 8000);
   32b6e:	904f      	str	r0, [sp, #316]	; 0x13c
   curr_nb_frames = opus_packet_get_nb_frames(data, len);
   32b70:	4630      	mov	r0, r6
   32b72:	f7fc fc49 	bl	2f408 <opus_packet_get_nb_frames>
   if(curr_nb_frames<1) return OPUS_INVALID_PACKET;
   32b76:	1e05      	subs	r5, r0, #0
   32b78:	f340 80f9 	ble.w	32d6e <opus_packet_pad.part.0+0x23a>
   if ((curr_nb_frames+rp->nb_frames)*rp->framesize > 960)
   32b7c:	9b06      	ldr	r3, [sp, #24]
   32b7e:	9a4f      	ldr	r2, [sp, #316]	; 0x13c
   32b80:	18e9      	adds	r1, r5, r3
   32b82:	fb02 f201 	mul.w	r2, r2, r1
   32b86:	f5b2 7f70 	cmp.w	r2, #960	; 0x3c0
   32b8a:	f300 80f0 	bgt.w	32d6e <opus_packet_pad.part.0+0x23a>
   ret=opus_packet_parse_impl(data, len, self_delimited, &tmp_toc, &rp->frames[rp->nb_frames], &rp->len[rp->nb_frames], NULL, NULL);
   32b8e:	aa05      	add	r2, sp, #20
   32b90:	f103 0c64 	add.w	ip, r3, #100	; 0x64
   32b94:	3302      	adds	r3, #2
   32b96:	eb02 0c4c 	add.w	ip, r2, ip, lsl #1
   32b9a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   32b9e:	e9cd 3c00 	strd	r3, ip, [sp]
   32ba2:	e9cd 9902 	strd	r9, r9, [sp, #8]
   32ba6:	464a      	mov	r2, r9
   32ba8:	4621      	mov	r1, r4
   32baa:	4630      	mov	r0, r6
   32bac:	f10d 0313 	add.w	r3, sp, #19
   32bb0:	f7fc fa28 	bl	2f004 <opus_packet_parse_impl>
   if(ret<1)return ret;
   32bb4:	2800      	cmp	r0, #0
   32bb6:	dd7a      	ble.n	32cae <opus_packet_pad.part.0+0x17a>
   rp->nb_frames += curr_nb_frames;
   32bb8:	9b06      	ldr	r3, [sp, #24]
   32bba:	441d      	add	r5, r3
   32bbc:	9506      	str	r5, [sp, #24]
   if (begin<0 || begin>=end || end>rp->nb_frames)
   32bbe:	2d00      	cmp	r5, #0
   32bc0:	f340 80d8 	ble.w	32d74 <opus_packet_pad.part.0+0x240>
   if (count==1)
   32bc4:	2d01      	cmp	r5, #1
   32bc6:	f9bd 60dc 	ldrsh.w	r6, [sp, #220]	; 0xdc
   32bca:	f000 80c3 	beq.w	32d54 <opus_packet_pad.part.0+0x220>
   } else if (count==2)
   32bce:	2d02      	cmp	r5, #2
   32bd0:	d071      	beq.n	32cb6 <opus_packet_pad.part.0+0x182>
         if (len[i] != len[0])
   32bd2:	f9bd 90de 	ldrsh.w	r9, [sp, #222]	; 0xde
   32bd6:	454e      	cmp	r6, r9
   32bd8:	f10d 0ada 	add.w	sl, sp, #218	; 0xda
   32bdc:	ea4f 0445 	mov.w	r4, r5, lsl #1
   32be0:	f040 808b 	bne.w	32cfa <opus_packet_pad.part.0+0x1c6>
   32be4:	eb0a 0104 	add.w	r1, sl, r4
   32be8:	f10d 03de 	add.w	r3, sp, #222	; 0xde
   32bec:	e004      	b.n	32bf8 <opus_packet_pad.part.0+0xc4>
   32bee:	f933 2f02 	ldrsh.w	r2, [r3, #2]!
   32bf2:	42b2      	cmp	r2, r6
   32bf4:	f040 8081 	bne.w	32cfa <opus_packet_pad.part.0+0x1c6>
      for (i=1;i<count;i++)
   32bf8:	4299      	cmp	r1, r3
   32bfa:	d1f8      	bne.n	32bee <opus_packet_pad.part.0+0xba>
   32bfc:	464e      	mov	r6, r9
         tot_size += count*len[0]+2;
   32bfe:	fb05 f906 	mul.w	r9, r5, r6
   32c02:	f109 0902 	add.w	r9, r9, #2
         if (tot_size > maxlen)
   32c06:	45c8      	cmp	r8, r9
   32c08:	f2c0 80c8 	blt.w	32d9c <opus_packet_pad.part.0+0x268>
         *ptr++ = (rp->toc&0xFC) | 0x3;
   32c0c:	f89d 2014 	ldrb.w	r2, [sp, #20]
   32c10:	463c      	mov	r4, r7
   32c12:	f042 0203 	orr.w	r2, r2, #3
         *ptr++ = count;
   32c16:	b2eb      	uxtb	r3, r5
      if (pad_amount != 0)
   32c18:	ebb8 0609 	subs.w	r6, r8, r9
         *ptr++ = (rp->toc&0xFC) | 0x3;
   32c1c:	f804 2b02 	strb.w	r2, [r4], #2
         *ptr++ = count;
   32c20:	707b      	strb	r3, [r7, #1]
      if (pad_amount != 0)
   32c22:	d067      	beq.n	32cf4 <opus_packet_pad.part.0+0x1c0>
      vbr = 0;
   32c24:	f04f 0900 	mov.w	r9, #0
   32c28:	f10d 0ada 	add.w	sl, sp, #218	; 0xda
         nb_255s = (pad_amount-1)/255;
   32c2c:	4a5d      	ldr	r2, [pc, #372]	; (32da4 <opus_packet_pad.part.0+0x270>)
   32c2e:	3e01      	subs	r6, #1
   32c30:	fba2 2b06 	umull	r2, fp, r2, r6
         data[1] |= 0x40;
   32c34:	f043 0340 	orr.w	r3, r3, #64	; 0x40
         for (i=0;i<nb_255s;i++)
   32c38:	ea5f 1bdb 	movs.w	fp, fp, lsr #7
         data[1] |= 0x40;
   32c3c:	707b      	strb	r3, [r7, #1]
         for (i=0;i<nb_255s;i++)
   32c3e:	d005      	beq.n	32c4c <opus_packet_pad.part.0+0x118>
   32c40:	4620      	mov	r0, r4
   32c42:	465a      	mov	r2, fp
   32c44:	21ff      	movs	r1, #255	; 0xff
   32c46:	f002 fa8d 	bl	35164 <memset>
   32c4a:	445c      	add	r4, fp
         *ptr++ = pad_amount-255*nb_255s-1;
   32c4c:	445e      	add	r6, fp
   32c4e:	7026      	strb	r6, [r4, #0]
   32c50:	3401      	adds	r4, #1
      if (vbr)
   32c52:	f1b9 0f00 	cmp.w	r9, #0
   32c56:	f000 8092 	beq.w	32d7e <opus_packet_pad.part.0+0x24a>
         for (i=0;i<count-1;i++)
   32c5a:	1e69      	subs	r1, r5, #1
   32c5c:	46c1      	mov	r9, r8
   32c5e:	d00a      	beq.n	32c76 <opus_packet_pad.part.0+0x142>
   32c60:	eb0a 0b41 	add.w	fp, sl, r1, lsl #1
   32c64:	4656      	mov	r6, sl
            ptr += encode_size(len[i], ptr);
   32c66:	4621      	mov	r1, r4
   32c68:	f936 0f02 	ldrsh.w	r0, [r6, #2]!
   32c6c:	f7fc f984 	bl	2ef78 <encode_size>
         for (i=0;i<count-1;i++)
   32c70:	45b3      	cmp	fp, r6
            ptr += encode_size(len[i], ptr);
   32c72:	4404      	add	r4, r0
         for (i=0;i<count-1;i++)
   32c74:	d1f7      	bne.n	32c66 <opus_packet_pad.part.0+0x132>
   32c76:	ae06      	add	r6, sp, #24
   32c78:	46d3      	mov	fp, sl
   32c7a:	eb06 0585 	add.w	r5, r6, r5, lsl #2
      OPUS_MOVE(ptr, frames[i], len[i]);
   32c7e:	f93b af02 	ldrsh.w	sl, [fp, #2]!
   32c82:	f856 1f04 	ldr.w	r1, [r6, #4]!
   32c86:	4620      	mov	r0, r4
   32c88:	4652      	mov	r2, sl
   32c8a:	f002 fa07 	bl	3509c <memmove>
   for (i=0;i<count;i++)
   32c8e:	42ae      	cmp	r6, r5
      ptr += len[i];
   32c90:	4454      	add	r4, sl
   for (i=0;i<count;i++)
   32c92:	d1f4      	bne.n	32c7e <opus_packet_pad.part.0+0x14a>
      while (ptr<data+maxlen)
   32c94:	4447      	add	r7, r8
   32c96:	42bc      	cmp	r4, r7
   32c98:	d204      	bcs.n	32ca4 <opus_packet_pad.part.0+0x170>
   32c9a:	1b3a      	subs	r2, r7, r4
   32c9c:	4620      	mov	r0, r4
   32c9e:	2100      	movs	r1, #0
   32ca0:	f002 fa60 	bl	35164 <memset>
   32ca4:	ea09 70e9 	and.w	r0, r9, r9, asr #31
   ret = opus_repacketizer_out_range_impl(&rp, 0, rp.nb_frames, data, new_len, 0, 1);
   if (ret > 0)
      return OPUS_OK;
   else
      return ret;
}
   32ca8:	b051      	add	sp, #324	; 0x144
   32caa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   if (ret != OPUS_OK)
   32cae:	d064      	beq.n	32d7a <opus_packet_pad.part.0+0x246>
}
   32cb0:	b051      	add	sp, #324	; 0x144
   32cb2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (len[1] == len[0])
   32cb6:	f9bd 30de 	ldrsh.w	r3, [sp, #222]	; 0xde
   32cba:	429e      	cmp	r6, r3
   32cbc:	d061      	beq.n	32d82 <opus_packet_pad.part.0+0x24e>
         tot_size += len[0]+len[1]+2+(len[0]>=252);
   32cbe:	18f0      	adds	r0, r6, r3
   32cc0:	3002      	adds	r0, #2
   32cc2:	2efb      	cmp	r6, #251	; 0xfb
   32cc4:	bfd4      	ite	le
   32cc6:	4681      	movle	r9, r0
   32cc8:	f100 0901 	addgt.w	r9, r0, #1
         if (tot_size > maxlen)
   32ccc:	45c8      	cmp	r8, r9
   32cce:	db65      	blt.n	32d9c <opus_packet_pad.part.0+0x268>
         *ptr++ = (rp->toc&0xFC) | 0x2;
   32cd0:	f89d 3014 	ldrb.w	r3, [sp, #20]
   32cd4:	f023 0303 	bic.w	r3, r3, #3
   32cd8:	f043 0302 	orr.w	r3, r3, #2
   32cdc:	1c7c      	adds	r4, r7, #1
         ptr += encode_size(len[0], ptr);
   32cde:	4630      	mov	r0, r6
   32ce0:	4621      	mov	r1, r4
         *ptr++ = (rp->toc&0xFC) | 0x2;
   32ce2:	703b      	strb	r3, [r7, #0]
         ptr += encode_size(len[0], ptr);
   32ce4:	f7fc f948 	bl	2ef78 <encode_size>
   32ce8:	f9bd 60dc 	ldrsh.w	r6, [sp, #220]	; 0xdc
   32cec:	4404      	add	r4, r0
   if (count > 2 || (pad && tot_size < maxlen))
   32cee:	45c8      	cmp	r8, r9
   32cf0:	f73f af6f 	bgt.w	32bd2 <opus_packet_pad.part.0+0x9e>
   32cf4:	f10d 0ada 	add.w	sl, sp, #218	; 0xda
   32cf8:	e7bd      	b.n	32c76 <opus_packet_pad.part.0+0x142>
   32cfa:	ab36      	add	r3, sp, #216	; 0xd8
   32cfc:	441c      	add	r4, r3
         for (i=0;i<count-1;i++)
   32cfe:	1e69      	subs	r1, r5, #1
   32d00:	4652      	mov	r2, sl
         tot_size += 2;
   32d02:	2002      	movs	r0, #2
            tot_size += 1 + (len[i]>=252) + len[i];
   32d04:	f932 3f02 	ldrsh.w	r3, [r2, #2]!
   32d08:	2bfb      	cmp	r3, #251	; 0xfb
   32d0a:	f103 0c02 	add.w	ip, r3, #2
   32d0e:	f103 0601 	add.w	r6, r3, #1
   32d12:	dd1b      	ble.n	32d4c <opus_packet_pad.part.0+0x218>
         for (i=0;i<count-1;i++)
   32d14:	4294      	cmp	r4, r2
            tot_size += 1 + (len[i]>=252) + len[i];
   32d16:	4460      	add	r0, ip
         for (i=0;i<count-1;i++)
   32d18:	d1f4      	bne.n	32d04 <opus_packet_pad.part.0+0x1d0>
         tot_size += len[count-1];
   32d1a:	ab50      	add	r3, sp, #320	; 0x140
   32d1c:	eb03 0345 	add.w	r3, r3, r5, lsl #1
   32d20:	f933 9c66 	ldrsh.w	r9, [r3, #-102]
   32d24:	4481      	add	r9, r0
         if (tot_size > maxlen)
   32d26:	45c8      	cmp	r8, r9
   32d28:	db38      	blt.n	32d9c <opus_packet_pad.part.0+0x268>
         *ptr++ = (rp->toc&0xFC) | 0x3;
   32d2a:	f89d 2014 	ldrb.w	r2, [sp, #20]
   32d2e:	463c      	mov	r4, r7
         *ptr++ = count | 0x80;
   32d30:	f065 037f 	orn	r3, r5, #127	; 0x7f
         *ptr++ = (rp->toc&0xFC) | 0x3;
   32d34:	f042 0203 	orr.w	r2, r2, #3
         *ptr++ = count | 0x80;
   32d38:	b2db      	uxtb	r3, r3
      if (pad_amount != 0)
   32d3a:	ebb8 0609 	subs.w	r6, r8, r9
         *ptr++ = (rp->toc&0xFC) | 0x3;
   32d3e:	f804 2b02 	strb.w	r2, [r4], #2
         *ptr++ = count | 0x80;
   32d42:	707b      	strb	r3, [r7, #1]
      if (pad_amount != 0)
   32d44:	d08c      	beq.n	32c60 <opus_packet_pad.part.0+0x12c>
            vbr=1;
   32d46:	f04f 0901 	mov.w	r9, #1
   32d4a:	e76f      	b.n	32c2c <opus_packet_pad.part.0+0xf8>
         for (i=0;i<count-1;i++)
   32d4c:	4294      	cmp	r4, r2
            tot_size += 1 + (len[i]>=252) + len[i];
   32d4e:	4430      	add	r0, r6
         for (i=0;i<count-1;i++)
   32d50:	d1d8      	bne.n	32d04 <opus_packet_pad.part.0+0x1d0>
   32d52:	e7e2      	b.n	32d1a <opus_packet_pad.part.0+0x1e6>
      tot_size += len[0]+1;
   32d54:	f106 0901 	add.w	r9, r6, #1
      if (tot_size > maxlen)
   32d58:	45c8      	cmp	r8, r9
   32d5a:	db1f      	blt.n	32d9c <opus_packet_pad.part.0+0x268>
      *ptr++ = rp->toc&0xFC;
   32d5c:	f89d 3014 	ldrb.w	r3, [sp, #20]
   32d60:	f023 0303 	bic.w	r3, r3, #3
   32d64:	703b      	strb	r3, [r7, #0]
   32d66:	f107 0401 	add.w	r4, r7, #1
   if (count > 2 || (pad && tot_size < maxlen))
   32d6a:	ddc3      	ble.n	32cf4 <opus_packet_pad.part.0+0x1c0>
   32d6c:	e747      	b.n	32bfe <opus_packet_pad.part.0+0xca>
   if (len<1) return OPUS_INVALID_PACKET;
   32d6e:	f06f 0003 	mvn.w	r0, #3
   32d72:	e79d      	b.n	32cb0 <opus_packet_pad.part.0+0x17c>
      return OPUS_BAD_ARG;
   32d74:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   32d78:	e79a      	b.n	32cb0 <opus_packet_pad.part.0+0x17c>
   32d7a:	9d06      	ldr	r5, [sp, #24]
   32d7c:	e71f      	b.n	32bbe <opus_packet_pad.part.0+0x8a>
      if (vbr)
   32d7e:	46c1      	mov	r9, r8
   32d80:	e779      	b.n	32c76 <opus_packet_pad.part.0+0x142>
         tot_size += 2*len[0]+1;
   32d82:	2001      	movs	r0, #1
   32d84:	eb00 0946 	add.w	r9, r0, r6, lsl #1
         if (tot_size > maxlen)
   32d88:	45c8      	cmp	r8, r9
   32d8a:	db07      	blt.n	32d9c <opus_packet_pad.part.0+0x268>
         *ptr++ = (rp->toc&0xFC) | 0x1;
   32d8c:	f89d 3014 	ldrb.w	r3, [sp, #20]
   32d90:	f023 0303 	bic.w	r3, r3, #3
   32d94:	4303      	orrs	r3, r0
   32d96:	703b      	strb	r3, [r7, #0]
   32d98:	183c      	adds	r4, r7, r0
   32d9a:	e7a8      	b.n	32cee <opus_packet_pad.part.0+0x1ba>
         return OPUS_BUFFER_TOO_SMALL;
   32d9c:	f06f 0001 	mvn.w	r0, #1
   32da0:	e786      	b.n	32cb0 <opus_packet_pad.part.0+0x17c>
   32da2:	bf00      	nop
   32da4:	80808081 	.word	0x80808081

00032da8 <opus_repacketizer_init>:
   rp->nb_frames = 0;
   32da8:	2200      	movs	r2, #0
   32daa:	6042      	str	r2, [r0, #4]
}
   32dac:	4770      	bx	lr
   32dae:	bf00      	nop

00032db0 <opus_repacketizer_cat>:
{
   32db0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   if (len<1) return OPUS_INVALID_PACKET;
   32db4:	1e16      	subs	r6, r2, #0
{
   32db6:	b086      	sub	sp, #24
   if (len<1) return OPUS_INVALID_PACKET;
   32db8:	dd3f      	ble.n	32e3a <opus_repacketizer_cat+0x8a>
   if (rp->nb_frames == 0)
   32dba:	6842      	ldr	r2, [r0, #4]
   32dbc:	780b      	ldrb	r3, [r1, #0]
   32dbe:	460d      	mov	r5, r1
   32dc0:	4604      	mov	r4, r0
   32dc2:	b38a      	cbz	r2, 32e28 <opus_repacketizer_cat+0x78>
   } else if ((rp->toc&0xFC) != (data[0]&0xFC))
   32dc4:	7802      	ldrb	r2, [r0, #0]
   32dc6:	4053      	eors	r3, r2
   32dc8:	f013 0ffc 	tst.w	r3, #252	; 0xfc
   32dcc:	d135      	bne.n	32e3a <opus_repacketizer_cat+0x8a>
   curr_nb_frames = opus_packet_get_nb_frames(data, len);
   32dce:	4631      	mov	r1, r6
   32dd0:	4628      	mov	r0, r5
   32dd2:	f7fc fb19 	bl	2f408 <opus_packet_get_nb_frames>
   if(curr_nb_frames<1) return OPUS_INVALID_PACKET;
   32dd6:	f1b0 0800 	subs.w	r8, r0, #0
   32dda:	dd2e      	ble.n	32e3a <opus_repacketizer_cat+0x8a>
   if ((curr_nb_frames+rp->nb_frames)*rp->framesize > 960)
   32ddc:	6863      	ldr	r3, [r4, #4]
   32dde:	f8d4 2128 	ldr.w	r2, [r4, #296]	; 0x128
   32de2:	eb08 0103 	add.w	r1, r8, r3
   32de6:	fb02 f201 	mul.w	r2, r2, r1
   32dea:	f5b2 7f70 	cmp.w	r2, #960	; 0x3c0
   32dee:	dc24      	bgt.n	32e3a <opus_repacketizer_cat+0x8a>
   ret=opus_packet_parse_impl(data, len, self_delimited, &tmp_toc, &rp->frames[rp->nb_frames], &rp->len[rp->nb_frames], NULL, NULL);
   32df0:	f103 0264 	add.w	r2, r3, #100	; 0x64
   32df4:	3302      	adds	r3, #2
   32df6:	eb04 0242 	add.w	r2, r4, r2, lsl #1
   32dfa:	eb04 0383 	add.w	r3, r4, r3, lsl #2
   32dfe:	2700      	movs	r7, #0
   32e00:	e9cd 3200 	strd	r3, r2, [sp]
   32e04:	4631      	mov	r1, r6
   32e06:	4628      	mov	r0, r5
   32e08:	e9cd 7702 	strd	r7, r7, [sp, #8]
   32e0c:	463a      	mov	r2, r7
   32e0e:	f10d 0317 	add.w	r3, sp, #23
   32e12:	f7fc f8f7 	bl	2f004 <opus_packet_parse_impl>
   if(ret<1)return ret;
   32e16:	2800      	cmp	r0, #0
   32e18:	dd03      	ble.n	32e22 <opus_repacketizer_cat+0x72>
   rp->nb_frames += curr_nb_frames;
   32e1a:	6863      	ldr	r3, [r4, #4]
   32e1c:	4443      	add	r3, r8
   return OPUS_OK;
   32e1e:	4638      	mov	r0, r7
   rp->nb_frames += curr_nb_frames;
   32e20:	6063      	str	r3, [r4, #4]
}
   32e22:	b006      	add	sp, #24
   32e24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      rp->toc = data[0];
   32e28:	7003      	strb	r3, [r0, #0]
      rp->framesize = opus_packet_get_samples_per_frame(data, 8000);
   32e2a:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
   32e2e:	4628      	mov	r0, r5
   32e30:	f7fc f8b0 	bl	2ef94 <opus_packet_get_samples_per_frame>
   32e34:	f8c4 0128 	str.w	r0, [r4, #296]	; 0x128
   32e38:	e7c9      	b.n	32dce <opus_repacketizer_cat+0x1e>
   if (len<1) return OPUS_INVALID_PACKET;
   32e3a:	f06f 0003 	mvn.w	r0, #3
   32e3e:	e7f0      	b.n	32e22 <opus_repacketizer_cat+0x72>

00032e40 <opus_repacketizer_out_range_impl>:
{
   32e40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   if (begin<0 || begin>=end || end>rp->nb_frames)
   32e44:	1e0d      	subs	r5, r1, #0
{
   32e46:	b085      	sub	sp, #20
   if (begin<0 || begin>=end || end>rp->nb_frames)
   32e48:	f2c0 8145 	blt.w	330d6 <opus_repacketizer_out_range_impl+0x296>
   32e4c:	4295      	cmp	r5, r2
   32e4e:	f280 8142 	bge.w	330d6 <opus_repacketizer_out_range_impl+0x296>
   32e52:	6841      	ldr	r1, [r0, #4]
   32e54:	4291      	cmp	r1, r2
   32e56:	f2c0 813e 	blt.w	330d6 <opus_repacketizer_out_range_impl+0x296>
   count = end-begin;
   32e5a:	1b56      	subs	r6, r2, r5
   frames = rp->frames+begin;
   32e5c:	f100 0208 	add.w	r2, r0, #8
   32e60:	9201      	str	r2, [sp, #4]
   32e62:	00aa      	lsls	r2, r5, #2
   32e64:	9202      	str	r2, [sp, #8]
   if (self_delimited)
   32e66:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   len = rp->len+begin;
   32e68:	f100 07c8 	add.w	r7, r0, #200	; 0xc8
   32e6c:	eb07 0a45 	add.w	sl, r7, r5, lsl #1
   if (self_delimited)
   32e70:	2a00      	cmp	r2, #0
   32e72:	d161      	bne.n	32f38 <opus_repacketizer_out_range_impl+0xf8>
   if (count==1)
   32e74:	2e01      	cmp	r6, #1
   32e76:	4690      	mov	r8, r2
   32e78:	4699      	mov	r9, r3
   32e7a:	4683      	mov	fp, r0
   32e7c:	d06b      	beq.n	32f56 <opus_repacketizer_out_range_impl+0x116>
   } else if (count==2)
   32e7e:	2e02      	cmp	r6, #2
   32e80:	f000 80f9 	beq.w	33076 <opus_repacketizer_out_range_impl+0x236>
      if (self_delimited)
   32e84:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   32e86:	2b00      	cmp	r3, #0
   32e88:	d17d      	bne.n	32f86 <opus_repacketizer_out_range_impl+0x146>
   32e8a:	2002      	movs	r0, #2
         tot_size = 0;
   32e8c:	469c      	mov	ip, r3
      for (i=1;i<count;i++)
   32e8e:	2e01      	cmp	r6, #1
   32e90:	f937 8015 	ldrsh.w	r8, [r7, r5, lsl #1]
   32e94:	d011      	beq.n	32eba <opus_repacketizer_out_range_impl+0x7a>
         if (len[i] != len[0])
   32e96:	f9ba 5002 	ldrsh.w	r5, [sl, #2]
   32e9a:	4545      	cmp	r5, r8
   32e9c:	ea4f 0746 	mov.w	r7, r6, lsl #1
   32ea0:	f040 8089 	bne.w	32fb6 <opus_repacketizer_out_range_impl+0x176>
   32ea4:	1ebc      	subs	r4, r7, #2
   32ea6:	4454      	add	r4, sl
   32ea8:	f10a 0202 	add.w	r2, sl, #2
   32eac:	e003      	b.n	32eb6 <opus_repacketizer_out_range_impl+0x76>
   32eae:	f932 3f02 	ldrsh.w	r3, [r2, #2]!
   32eb2:	42ab      	cmp	r3, r5
   32eb4:	d17f      	bne.n	32fb6 <opus_repacketizer_out_range_impl+0x176>
      for (i=1;i<count;i++)
   32eb6:	4294      	cmp	r4, r2
   32eb8:	d1f9      	bne.n	32eae <opus_repacketizer_out_range_impl+0x6e>
         tot_size += count*len[0]+2;
   32eba:	fb06 c808 	mla	r8, r6, r8, ip
         if (tot_size > maxlen)
   32ebe:	9b0e      	ldr	r3, [sp, #56]	; 0x38
         tot_size += count*len[0]+2;
   32ec0:	f108 0802 	add.w	r8, r8, #2
         if (tot_size > maxlen)
   32ec4:	4543      	cmp	r3, r8
   32ec6:	f2c0 8109 	blt.w	330dc <opus_repacketizer_out_range_impl+0x29c>
         *ptr++ = (rp->toc&0xFC) | 0x3;
   32eca:	f89b 1000 	ldrb.w	r1, [fp]
      pad_amount = pad ? (maxlen-tot_size) : 0;
   32ece:	9b10      	ldr	r3, [sp, #64]	; 0x40
         *ptr++ = (rp->toc&0xFC) | 0x3;
   32ed0:	464c      	mov	r4, r9
   32ed2:	f041 0103 	orr.w	r1, r1, #3
         *ptr++ = count;
   32ed6:	b2f2      	uxtb	r2, r6
         *ptr++ = (rp->toc&0xFC) | 0x3;
   32ed8:	f804 1b02 	strb.w	r1, [r4], #2
         *ptr++ = count;
   32edc:	f889 2001 	strb.w	r2, [r9, #1]
      pad_amount = pad ? (maxlen-tot_size) : 0;
   32ee0:	2b00      	cmp	r3, #0
   32ee2:	f040 80fe 	bne.w	330e2 <opus_repacketizer_out_range_impl+0x2a2>
   32ee6:	0077      	lsls	r7, r6, #1
   32ee8:	f1aa 0502 	sub.w	r5, sl, #2
   if (self_delimited) {
   32eec:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   32eee:	2b00      	cmp	r3, #0
   32ef0:	d157      	bne.n	32fa2 <opus_repacketizer_out_range_impl+0x162>
   32ef2:	9b02      	ldr	r3, [sp, #8]
   32ef4:	1f1e      	subs	r6, r3, #4
   32ef6:	9b01      	ldr	r3, [sp, #4]
   32ef8:	3f02      	subs	r7, #2
   32efa:	4433      	add	r3, r6
   32efc:	461e      	mov	r6, r3
   32efe:	4457      	add	r7, sl
      OPUS_MOVE(ptr, frames[i], len[i]);
   32f00:	f935 2f02 	ldrsh.w	r2, [r5, #2]!
   32f04:	f856 1f04 	ldr.w	r1, [r6, #4]!
   32f08:	4620      	mov	r0, r4
   32f0a:	f002 f8c7 	bl	3509c <memmove>
      ptr += len[i];
   32f0e:	f9b5 3000 	ldrsh.w	r3, [r5]
   for (i=0;i<count;i++)
   32f12:	42bd      	cmp	r5, r7
      ptr += len[i];
   32f14:	441c      	add	r4, r3
   for (i=0;i<count;i++)
   32f16:	d1f3      	bne.n	32f00 <opus_repacketizer_out_range_impl+0xc0>
   if (pad)
   32f18:	9b10      	ldr	r3, [sp, #64]	; 0x40
   32f1a:	b14b      	cbz	r3, 32f30 <opus_repacketizer_out_range_impl+0xf0>
      while (ptr<data+maxlen)
   32f1c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   32f1e:	4499      	add	r9, r3
   32f20:	45a1      	cmp	r9, r4
   32f22:	d905      	bls.n	32f30 <opus_repacketizer_out_range_impl+0xf0>
   32f24:	eba9 0204 	sub.w	r2, r9, r4
   32f28:	4620      	mov	r0, r4
   32f2a:	2100      	movs	r1, #0
   32f2c:	f002 f91a 	bl	35164 <memset>
}
   32f30:	4640      	mov	r0, r8
   32f32:	b005      	add	sp, #20
   32f34:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      tot_size = 1 + (len[count-1]>=252);
   32f38:	f106 4200 	add.w	r2, r6, #2147483648	; 0x80000000
   32f3c:	3a01      	subs	r2, #1
   32f3e:	4699      	mov	r9, r3
   32f40:	f93a 2012 	ldrsh.w	r2, [sl, r2, lsl #1]
   32f44:	2afc      	cmp	r2, #252	; 0xfc
   32f46:	bfb4      	ite	lt
   32f48:	f04f 0801 	movlt.w	r8, #1
   32f4c:	f04f 0802 	movge.w	r8, #2
   if (count==1)
   32f50:	2e01      	cmp	r6, #1
   32f52:	4683      	mov	fp, r0
   32f54:	d193      	bne.n	32e7e <opus_repacketizer_out_range_impl+0x3e>
      tot_size += len[0]+1;
   32f56:	f937 2015 	ldrsh.w	r2, [r7, r5, lsl #1]
      if (tot_size > maxlen)
   32f5a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
      tot_size += len[0]+1;
   32f5c:	3201      	adds	r2, #1
   32f5e:	4490      	add	r8, r2
      if (tot_size > maxlen)
   32f60:	4543      	cmp	r3, r8
   32f62:	f2c0 80bb 	blt.w	330dc <opus_repacketizer_out_range_impl+0x29c>
      *ptr++ = rp->toc&0xFC;
   32f66:	7802      	ldrb	r2, [r0, #0]
   32f68:	f022 0203 	bic.w	r2, r2, #3
   32f6c:	f889 2000 	strb.w	r2, [r9]
   32f70:	f109 0401 	add.w	r4, r9, #1
   if (count > 2 || (pad && tot_size < maxlen))
   32f74:	9b10      	ldr	r3, [sp, #64]	; 0x40
   32f76:	2b00      	cmp	r3, #0
   32f78:	d0b5      	beq.n	32ee6 <opus_repacketizer_out_range_impl+0xa6>
   32f7a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   32f7c:	4543      	cmp	r3, r8
   32f7e:	ddb2      	ble.n	32ee6 <opus_repacketizer_out_range_impl+0xa6>
      if (self_delimited)
   32f80:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   32f82:	2b00      	cmp	r3, #0
   32f84:	d081      	beq.n	32e8a <opus_repacketizer_out_range_impl+0x4a>
         tot_size = 1 + (len[count-1]>=252);
   32f86:	f106 4200 	add.w	r2, r6, #2147483648	; 0x80000000
   32f8a:	3a01      	subs	r2, #1
   32f8c:	f93a 2012 	ldrsh.w	r2, [sl, r2, lsl #1]
   32f90:	2afc      	cmp	r2, #252	; 0xfc
   32f92:	bfb5      	itete	lt
   32f94:	2003      	movlt	r0, #3
   32f96:	2004      	movge	r0, #4
   32f98:	f04f 0c01 	movlt.w	ip, #1
   32f9c:	f04f 0c02 	movge.w	ip, #2
   32fa0:	e775      	b.n	32e8e <opus_repacketizer_out_range_impl+0x4e>
      int sdlen = encode_size(len[count-1], ptr);
   32fa2:	f106 4600 	add.w	r6, r6, #2147483648	; 0x80000000
   32fa6:	3e01      	subs	r6, #1
   32fa8:	4621      	mov	r1, r4
   32faa:	f93a 0016 	ldrsh.w	r0, [sl, r6, lsl #1]
   32fae:	f7fb ffe3 	bl	2ef78 <encode_size>
      ptr += sdlen;
   32fb2:	4404      	add	r4, r0
   32fb4:	e79d      	b.n	32ef2 <opus_repacketizer_out_range_impl+0xb2>
   32fb6:	f1aa 0502 	sub.w	r5, sl, #2
   32fba:	1f3c      	subs	r4, r7, #4
   32fbc:	4629      	mov	r1, r5
   32fbe:	4454      	add	r4, sl
            tot_size += 1 + (len[i]>=252) + len[i];
   32fc0:	f931 3f02 	ldrsh.w	r3, [r1, #2]!
   32fc4:	2bfb      	cmp	r3, #251	; 0xfb
   32fc6:	f103 0c02 	add.w	ip, r3, #2
   32fca:	f103 0201 	add.w	r2, r3, #1
   32fce:	dd4e      	ble.n	3306e <opus_repacketizer_out_range_impl+0x22e>
         for (i=0;i<count-1;i++)
   32fd0:	428c      	cmp	r4, r1
            tot_size += 1 + (len[i]>=252) + len[i];
   32fd2:	4460      	add	r0, ip
         for (i=0;i<count-1;i++)
   32fd4:	d1f4      	bne.n	32fc0 <opus_repacketizer_out_range_impl+0x180>
         tot_size += len[count-1];
   32fd6:	f106 4200 	add.w	r2, r6, #2147483648	; 0x80000000
   32fda:	3a01      	subs	r2, #1
         if (tot_size > maxlen)
   32fdc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
         tot_size += len[count-1];
   32fde:	f93a 8012 	ldrsh.w	r8, [sl, r2, lsl #1]
   32fe2:	4480      	add	r8, r0
         if (tot_size > maxlen)
   32fe4:	4543      	cmp	r3, r8
   32fe6:	db79      	blt.n	330dc <opus_repacketizer_out_range_impl+0x29c>
         *ptr++ = (rp->toc&0xFC) | 0x3;
   32fe8:	f89b 1000 	ldrb.w	r1, [fp]
      pad_amount = pad ? (maxlen-tot_size) : 0;
   32fec:	9b10      	ldr	r3, [sp, #64]	; 0x40
         *ptr++ = (rp->toc&0xFC) | 0x3;
   32fee:	464c      	mov	r4, r9
         *ptr++ = count | 0x80;
   32ff0:	f066 027f 	orn	r2, r6, #127	; 0x7f
         *ptr++ = (rp->toc&0xFC) | 0x3;
   32ff4:	f041 0103 	orr.w	r1, r1, #3
         *ptr++ = count | 0x80;
   32ff8:	b2d2      	uxtb	r2, r2
         *ptr++ = (rp->toc&0xFC) | 0x3;
   32ffa:	f804 1b02 	strb.w	r1, [r4], #2
         *ptr++ = count | 0x80;
   32ffe:	f889 2001 	strb.w	r2, [r9, #1]
      pad_amount = pad ? (maxlen-tot_size) : 0;
   33002:	b30b      	cbz	r3, 33048 <opus_repacketizer_out_range_impl+0x208>
      if (pad_amount != 0)
   33004:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   33006:	ebb3 0b08 	subs.w	fp, r3, r8
   3300a:	d01d      	beq.n	33048 <opus_repacketizer_out_range_impl+0x208>
            vbr=1;
   3300c:	2301      	movs	r3, #1
         nb_255s = (pad_amount-1)/255;
   3300e:	493a      	ldr	r1, [pc, #232]	; (330f8 <opus_repacketizer_out_range_impl+0x2b8>)
   33010:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
   33014:	fba1 180b 	umull	r1, r8, r1, fp
         data[1] |= 0x40;
   33018:	f042 0240 	orr.w	r2, r2, #64	; 0x40
         for (i=0;i<nb_255s;i++)
   3301c:	ea5f 18d8 	movs.w	r8, r8, lsr #7
         data[1] |= 0x40;
   33020:	f889 2001 	strb.w	r2, [r9, #1]
         for (i=0;i<nb_255s;i++)
   33024:	d007      	beq.n	33036 <opus_repacketizer_out_range_impl+0x1f6>
   33026:	4620      	mov	r0, r4
   33028:	4642      	mov	r2, r8
   3302a:	21ff      	movs	r1, #255	; 0xff
   3302c:	9303      	str	r3, [sp, #12]
   3302e:	f002 f899 	bl	35164 <memset>
   33032:	9b03      	ldr	r3, [sp, #12]
   33034:	4444      	add	r4, r8
         *ptr++ = pad_amount-255*nb_255s-1;
   33036:	44d8      	add	r8, fp
   33038:	f884 8000 	strb.w	r8, [r4]
   3303c:	3401      	adds	r4, #1
   3303e:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
      if (vbr)
   33042:	2b00      	cmp	r3, #0
   33044:	f43f af52 	beq.w	32eec <opus_repacketizer_out_range_impl+0xac>
         for (i=0;i<count-1;i++)
   33048:	2e01      	cmp	r6, #1
   3304a:	f43f af4f 	beq.w	32eec <opus_repacketizer_out_range_impl+0xac>
   3304e:	f1a7 0b04 	sub.w	fp, r7, #4
   33052:	eb0a 030b 	add.w	r3, sl, fp
   33056:	9503      	str	r5, [sp, #12]
   33058:	469b      	mov	fp, r3
            ptr += encode_size(len[i], ptr);
   3305a:	4621      	mov	r1, r4
   3305c:	f935 0f02 	ldrsh.w	r0, [r5, #2]!
   33060:	f7fb ff8a 	bl	2ef78 <encode_size>
         for (i=0;i<count-1;i++)
   33064:	45ab      	cmp	fp, r5
            ptr += encode_size(len[i], ptr);
   33066:	4404      	add	r4, r0
         for (i=0;i<count-1;i++)
   33068:	d1f7      	bne.n	3305a <opus_repacketizer_out_range_impl+0x21a>
   3306a:	9d03      	ldr	r5, [sp, #12]
   3306c:	e73e      	b.n	32eec <opus_repacketizer_out_range_impl+0xac>
         for (i=0;i<count-1;i++)
   3306e:	428c      	cmp	r4, r1
            tot_size += 1 + (len[i]>=252) + len[i];
   33070:	4410      	add	r0, r2
         for (i=0;i<count-1;i++)
   33072:	d1a5      	bne.n	32fc0 <opus_repacketizer_out_range_impl+0x180>
   33074:	e7af      	b.n	32fd6 <opus_repacketizer_out_range_impl+0x196>
      if (len[1] == len[0])
   33076:	f9ba 2002 	ldrsh.w	r2, [sl, #2]
   3307a:	f937 1015 	ldrsh.w	r1, [r7, r5, lsl #1]
   3307e:	428a      	cmp	r2, r1
   33080:	d018      	beq.n	330b4 <opus_repacketizer_out_range_impl+0x274>
         tot_size += len[0]+len[1]+2+(len[0]>=252);
   33082:	440a      	add	r2, r1
   33084:	3202      	adds	r2, #2
   33086:	29fb      	cmp	r1, #251	; 0xfb
   33088:	bfc8      	it	gt
   3308a:	3201      	addgt	r2, #1
         if (tot_size > maxlen)
   3308c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
         tot_size += len[0]+len[1]+2+(len[0]>=252);
   3308e:	4490      	add	r8, r2
         if (tot_size > maxlen)
   33090:	4598      	cmp	r8, r3
   33092:	dc23      	bgt.n	330dc <opus_repacketizer_out_range_impl+0x29c>
         *ptr++ = (rp->toc&0xFC) | 0x2;
   33094:	7802      	ldrb	r2, [r0, #0]
   33096:	f022 0203 	bic.w	r2, r2, #3
   3309a:	f042 0202 	orr.w	r2, r2, #2
   3309e:	f889 2000 	strb.w	r2, [r9]
   330a2:	f109 0401 	add.w	r4, r9, #1
         ptr += encode_size(len[0], ptr);
   330a6:	4621      	mov	r1, r4
   330a8:	f937 0015 	ldrsh.w	r0, [r7, r5, lsl #1]
   330ac:	f7fb ff64 	bl	2ef78 <encode_size>
   330b0:	4404      	add	r4, r0
   330b2:	e75f      	b.n	32f74 <opus_repacketizer_out_range_impl+0x134>
         tot_size += 2*len[0]+1;
   330b4:	eb08 0842 	add.w	r8, r8, r2, lsl #1
         if (tot_size > maxlen)
   330b8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
         tot_size += 2*len[0]+1;
   330ba:	f108 0801 	add.w	r8, r8, #1
         if (tot_size > maxlen)
   330be:	4543      	cmp	r3, r8
   330c0:	db0c      	blt.n	330dc <opus_repacketizer_out_range_impl+0x29c>
         *ptr++ = (rp->toc&0xFC) | 0x1;
   330c2:	7802      	ldrb	r2, [r0, #0]
   330c4:	f022 0203 	bic.w	r2, r2, #3
   330c8:	f042 0201 	orr.w	r2, r2, #1
   330cc:	f889 2000 	strb.w	r2, [r9]
   330d0:	f109 0401 	add.w	r4, r9, #1
   330d4:	e74e      	b.n	32f74 <opus_repacketizer_out_range_impl+0x134>
      return OPUS_BAD_ARG;
   330d6:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
   330da:	e729      	b.n	32f30 <opus_repacketizer_out_range_impl+0xf0>
         return OPUS_BUFFER_TOO_SMALL;
   330dc:	f06f 0801 	mvn.w	r8, #1
   330e0:	e726      	b.n	32f30 <opus_repacketizer_out_range_impl+0xf0>
      if (pad_amount != 0)
   330e2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   330e4:	ebb3 0b08 	subs.w	fp, r3, r8
   330e8:	f43f aefd 	beq.w	32ee6 <opus_repacketizer_out_range_impl+0xa6>
      vbr = 0;
   330ec:	2300      	movs	r3, #0
   330ee:	0077      	lsls	r7, r6, #1
   330f0:	f1aa 0502 	sub.w	r5, sl, #2
   330f4:	e78b      	b.n	3300e <opus_repacketizer_out_range_impl+0x1ce>
   330f6:	bf00      	nop
   330f8:	80808081 	.word	0x80808081

000330fc <opus_packet_pad>:
{
   330fc:	b410      	push	{r4}
   if (len < 1)
   330fe:	1e0c      	subs	r4, r1, #0
   33100:	dd0a      	ble.n	33118 <opus_packet_pad+0x1c>
   if (len==new_len)
   33102:	4294      	cmp	r4, r2
   33104:	d004      	beq.n	33110 <opus_packet_pad+0x14>
   else if (len > new_len)
   33106:	dc07      	bgt.n	33118 <opus_packet_pad+0x1c>
}
   33108:	f85d 4b04 	ldr.w	r4, [sp], #4
   3310c:	f7ff bd12 	b.w	32b34 <opus_packet_pad.part.0>
      return OPUS_OK;
   33110:	2000      	movs	r0, #0
}
   33112:	f85d 4b04 	ldr.w	r4, [sp], #4
   33116:	4770      	bx	lr
      return OPUS_BAD_ARG;
   33118:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   3311c:	e7f9      	b.n	33112 <opus_packet_pad+0x16>
   3311e:	bf00      	nop

00033120 <am_bsp_uart_string_print>:
   33120:	b510      	push	{r4, lr}
   33122:	b086      	sub	sp, #24
   33124:	7803      	ldrb	r3, [r0, #0]
   33126:	2400      	movs	r4, #0
   33128:	9400      	str	r4, [sp, #0]
   3312a:	b1bb      	cbz	r3, 3315c <am_bsp_uart_string_print+0x3c>
   3312c:	4601      	mov	r1, r0
   3312e:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   33132:	3401      	adds	r4, #1
   33134:	2a00      	cmp	r2, #0
   33136:	d1fa      	bne.n	3312e <am_bsp_uart_string_print+0xe>
   33138:	4b0a      	ldr	r3, [pc, #40]	; (33164 <am_bsp_uart_string_print+0x44>)
   3313a:	9002      	str	r0, [sp, #8]
   3313c:	2200      	movs	r2, #0
   3313e:	6818      	ldr	r0, [r3, #0]
   33140:	9403      	str	r4, [sp, #12]
   33142:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   33146:	a901      	add	r1, sp, #4
   33148:	9201      	str	r2, [sp, #4]
   3314a:	9304      	str	r3, [sp, #16]
   3314c:	f8cd d014 	str.w	sp, [sp, #20]
   33150:	f000 fe60 	bl	33e14 <am_hal_uart_transfer>
   33154:	9800      	ldr	r0, [sp, #0]
   33156:	42a0      	cmp	r0, r4
   33158:	d002      	beq.n	33160 <am_bsp_uart_string_print+0x40>
   3315a:	e7fe      	b.n	3315a <am_bsp_uart_string_print+0x3a>
   3315c:	461c      	mov	r4, r3
   3315e:	e7eb      	b.n	33138 <am_bsp_uart_string_print+0x18>
   33160:	b006      	add	sp, #24
   33162:	bd10      	pop	{r4, pc}
   33164:	100019a0 	.word	0x100019a0

00033168 <am_bsp_low_power_init>:
   33168:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   3316a:	f000 fb09 	bl	33780 <am_hal_itm_disable>
   3316e:	2000      	movs	r0, #0
   33170:	f7d9 fef0 	bl	cf54 <am_util_stdio_printf_init>
   33174:	4b12      	ldr	r3, [pc, #72]	; (331c0 <am_bsp_low_power_init+0x58>)
   33176:	4f13      	ldr	r7, [pc, #76]	; (331c4 <am_bsp_low_power_init+0x5c>)
   33178:	6819      	ldr	r1, [r3, #0]
   3317a:	2029      	movs	r0, #41	; 0x29
   3317c:	f7d9 fb9a 	bl	c8b4 <am_hal_gpio_pinconfig>
   33180:	f000 fc40 	bl	33a04 <am_hal_pwrctrl_low_power_init>
   33184:	2001      	movs	r0, #1
   33186:	f000 fc7b 	bl	33a80 <am_hal_rtc_osc_select>
   3318a:	2100      	movs	r1, #0
   3318c:	2003      	movs	r0, #3
   3318e:	f000 f87f 	bl	33290 <am_hal_clkgen_control>
   33192:	f000 fc81 	bl	33a98 <am_hal_rtc_osc_disable>
   33196:	480c      	ldr	r0, [pc, #48]	; (331c8 <am_bsp_low_power_init+0x60>)
   33198:	6806      	ldr	r6, [r0, #0]
   3319a:	2400      	movs	r4, #0
   3319c:	f857 5034 	ldr.w	r5, [r7, r4, lsl #3]
   331a0:	4631      	mov	r1, r6
   331a2:	4628      	mov	r0, r5
   331a4:	f7d9 fb86 	bl	c8b4 <am_hal_gpio_pinconfig>
   331a8:	2103      	movs	r1, #3
   331aa:	4628      	mov	r0, r5
   331ac:	f7d9 fcfc 	bl	cba8 <am_hal_gpio_state_write>
   331b0:	3401      	adds	r4, #1
   331b2:	4628      	mov	r0, r5
   331b4:	2100      	movs	r1, #0
   331b6:	f7d9 fcf7 	bl	cba8 <am_hal_gpio_state_write>
   331ba:	2c05      	cmp	r4, #5
   331bc:	d1ee      	bne.n	3319c <am_bsp_low_power_init+0x34>
   331be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   331c0:	00035ae4 	.word	0x00035ae4
   331c4:	1000102c 	.word	0x1000102c
   331c8:	00035ae8 	.word	0x00035ae8

000331cc <am_bsp_uart_printf_enable>:
   331cc:	b510      	push	{r4, lr}
   331ce:	4c10      	ldr	r4, [pc, #64]	; (33210 <am_bsp_uart_printf_enable+0x44>)
   331d0:	4b10      	ldr	r3, [pc, #64]	; (33214 <am_bsp_uart_printf_enable+0x48>)
   331d2:	4621      	mov	r1, r4
   331d4:	2202      	movs	r2, #2
   331d6:	2000      	movs	r0, #0
   331d8:	601a      	str	r2, [r3, #0]
   331da:	f000 fc8b 	bl	33af4 <am_hal_uart_initialize>
   331de:	2200      	movs	r2, #0
   331e0:	4611      	mov	r1, r2
   331e2:	6820      	ldr	r0, [r4, #0]
   331e4:	f000 fcae 	bl	33b44 <am_hal_uart_power_control>
   331e8:	6820      	ldr	r0, [r4, #0]
   331ea:	490b      	ldr	r1, [pc, #44]	; (33218 <am_bsp_uart_printf_enable+0x4c>)
   331ec:	4c0b      	ldr	r4, [pc, #44]	; (3321c <am_bsp_uart_printf_enable+0x50>)
   331ee:	f000 fd1b 	bl	33c28 <am_hal_uart_configure>
   331f2:	490b      	ldr	r1, [pc, #44]	; (33220 <am_bsp_uart_printf_enable+0x54>)
   331f4:	2016      	movs	r0, #22
   331f6:	6809      	ldr	r1, [r1, #0]
   331f8:	f7d9 fb5c 	bl	c8b4 <am_hal_gpio_pinconfig>
   331fc:	6821      	ldr	r1, [r4, #0]
   331fe:	2017      	movs	r0, #23
   33200:	f7d9 fb58 	bl	c8b4 <am_hal_gpio_pinconfig>
   33204:	4807      	ldr	r0, [pc, #28]	; (33224 <am_bsp_uart_printf_enable+0x58>)
   33206:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   3320a:	f7d9 bea3 	b.w	cf54 <am_util_stdio_printf_init>
   3320e:	bf00      	nop
   33210:	100019a0 	.word	0x100019a0
   33214:	1000199c 	.word	0x1000199c
   33218:	0003b704 	.word	0x0003b704
   3321c:	0003b72c 	.word	0x0003b72c
   33220:	0003b730 	.word	0x0003b730
   33224:	00033121 	.word	0x00033121

00033228 <am_hal_cachectrl_config>:
   33228:	b530      	push	{r4, r5, lr}
   3322a:	b083      	sub	sp, #12
   3322c:	4605      	mov	r5, r0
   3322e:	f000 fa9f 	bl	33770 <am_hal_interrupt_master_disable>
   33232:	4c11      	ldr	r4, [pc, #68]	; (33278 <am_hal_cachectrl_config+0x50>)
   33234:	9001      	str	r0, [sp, #4]
   33236:	6823      	ldr	r3, [r4, #0]
   33238:	f423 7040 	bic.w	r0, r3, #768	; 0x300
   3323c:	6020      	str	r0, [r4, #0]
   3323e:	9801      	ldr	r0, [sp, #4]
   33240:	f000 fa9a 	bl	33778 <am_hal_interrupt_master_set>
   33244:	78eb      	ldrb	r3, [r5, #3]
   33246:	782a      	ldrb	r2, [r5, #0]
   33248:	78a8      	ldrb	r0, [r5, #2]
   3324a:	7869      	ldrb	r1, [r5, #1]
   3324c:	0112      	lsls	r2, r2, #4
   3324e:	005d      	lsls	r5, r3, #1
   33250:	f005 0302 	and.w	r3, r5, #2
   33254:	b2d5      	uxtb	r5, r2
   33256:	432b      	orrs	r3, r5
   33258:	f443 1280 	orr.w	r2, r3, #1048576	; 0x100000
   3325c:	0080      	lsls	r0, r0, #2
   3325e:	f000 050c 	and.w	r5, r0, #12
   33262:	f442 6380 	orr.w	r3, r2, #1024	; 0x400
   33266:	0209      	lsls	r1, r1, #8
   33268:	432b      	orrs	r3, r5
   3326a:	f401 7240 	and.w	r2, r1, #768	; 0x300
   3326e:	4313      	orrs	r3, r2
   33270:	2000      	movs	r0, #0
   33272:	6023      	str	r3, [r4, #0]
   33274:	b003      	add	sp, #12
   33276:	bd30      	pop	{r4, r5, pc}
   33278:	40018000 	.word	0x40018000

0003327c <am_hal_cachectrl_enable>:
   3327c:	4a03      	ldr	r2, [pc, #12]	; (3328c <am_hal_cachectrl_enable+0x10>)
   3327e:	6813      	ldr	r3, [r2, #0]
   33280:	f043 0001 	orr.w	r0, r3, #1
   33284:	6010      	str	r0, [r2, #0]
   33286:	2000      	movs	r0, #0
   33288:	4770      	bx	lr
   3328a:	bf00      	nop
   3328c:	40018000 	.word	0x40018000

00033290 <am_hal_clkgen_control>:
   33290:	2809      	cmp	r0, #9
   33292:	d852      	bhi.n	3333a <am_hal_clkgen_control+0xaa>
   33294:	e8df f000 	tbb	[pc, r0]
   33298:	2b21190d 	.word	0x2b21190d
   3329c:	51513d33 	.word	0x51513d33
   332a0:	0547      	.short	0x0547
   332a2:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
   332a6:	2000      	movs	r0, #0
   332a8:	6a1a      	ldr	r2, [r3, #32]
   332aa:	f36f 0200 	bfc	r2, #0, #1
   332ae:	621a      	str	r2, [r3, #32]
   332b0:	4770      	bx	lr
   332b2:	f04f 2c40 	mov.w	ip, #1073758208	; 0x40004000
   332b6:	2100      	movs	r1, #0
   332b8:	2047      	movs	r0, #71	; 0x47
   332ba:	f8cc 0014 	str.w	r0, [ip, #20]
   332be:	f8cc 1018 	str.w	r1, [ip, #24]
   332c2:	4608      	mov	r0, r1
   332c4:	f8cc 1014 	str.w	r1, [ip, #20]
   332c8:	4770      	bx	lr
   332ca:	f04f 2140 	mov.w	r1, #1073758208	; 0x40004000
   332ce:	2000      	movs	r0, #0
   332d0:	68ca      	ldr	r2, [r1, #12]
   332d2:	f022 0301 	bic.w	r3, r2, #1
   332d6:	60cb      	str	r3, [r1, #12]
   332d8:	4770      	bx	lr
   332da:	f04f 2c40 	mov.w	ip, #1073758208	; 0x40004000
   332de:	2000      	movs	r0, #0
   332e0:	f8dc 200c 	ldr.w	r2, [ip, #12]
   332e4:	f022 0302 	bic.w	r3, r2, #2
   332e8:	f8cc 300c 	str.w	r3, [ip, #12]
   332ec:	4770      	bx	lr
   332ee:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
   332f2:	2000      	movs	r0, #0
   332f4:	68d3      	ldr	r3, [r2, #12]
   332f6:	f043 0101 	orr.w	r1, r3, #1
   332fa:	60d1      	str	r1, [r2, #12]
   332fc:	4770      	bx	lr
   332fe:	f04f 2c40 	mov.w	ip, #1073758208	; 0x40004000
   33302:	2000      	movs	r0, #0
   33304:	f8dc 300c 	ldr.w	r3, [ip, #12]
   33308:	f043 0102 	orr.w	r1, r3, #2
   3330c:	f8cc 100c 	str.w	r1, [ip, #12]
   33310:	4770      	bx	lr
   33312:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
   33316:	2200      	movs	r2, #0
   33318:	2047      	movs	r0, #71	; 0x47
   3331a:	2101      	movs	r1, #1
   3331c:	6158      	str	r0, [r3, #20]
   3331e:	6199      	str	r1, [r3, #24]
   33320:	4610      	mov	r0, r2
   33322:	615a      	str	r2, [r3, #20]
   33324:	4770      	bx	lr
   33326:	b151      	cbz	r1, 3333e <am_hal_clkgen_control+0xae>
   33328:	6808      	ldr	r0, [r1, #0]
   3332a:	f040 0101 	orr.w	r1, r0, #1
   3332e:	f04f 2c40 	mov.w	ip, #1073758208	; 0x40004000
   33332:	2000      	movs	r0, #0
   33334:	f8cc 1020 	str.w	r1, [ip, #32]
   33338:	4770      	bx	lr
   3333a:	2006      	movs	r0, #6
   3333c:	4770      	bx	lr
   3333e:	4901      	ldr	r1, [pc, #4]	; (33344 <am_hal_clkgen_control+0xb4>)
   33340:	e7f5      	b.n	3332e <am_hal_clkgen_control+0x9e>
   33342:	bf00      	nop
   33344:	0025b801 	.word	0x0025b801

00033348 <am_hal_clkgen_status_get>:
   33348:	b1a8      	cbz	r0, 33376 <am_hal_clkgen_status_get+0x2e>
   3334a:	b410      	push	{r4}
   3334c:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
   33350:	490a      	ldr	r1, [pc, #40]	; (3337c <am_hal_clkgen_status_get+0x34>)
   33352:	6994      	ldr	r4, [r2, #24]
   33354:	4b0a      	ldr	r3, [pc, #40]	; (33380 <am_hal_clkgen_status_get+0x38>)
   33356:	f014 0f01 	tst.w	r4, #1
   3335a:	bf08      	it	eq
   3335c:	460b      	moveq	r3, r1
   3335e:	6003      	str	r3, [r0, #0]
   33360:	69d3      	ldr	r3, [r2, #28]
   33362:	f3c3 0440 	ubfx	r4, r3, #1, #1
   33366:	f003 0201 	and.w	r2, r3, #1
   3336a:	7204      	strb	r4, [r0, #8]
   3336c:	6042      	str	r2, [r0, #4]
   3336e:	f85d 4b04 	ldr.w	r4, [sp], #4
   33372:	2000      	movs	r0, #0
   33374:	4770      	bx	lr
   33376:	2006      	movs	r0, #6
   33378:	4770      	bx	lr
   3337a:	bf00      	nop
   3337c:	02dc6c00 	.word	0x02dc6c00
   33380:	016e3600 	.word	0x016e3600

00033384 <am_hal_ctimer_config>:
   33384:	b530      	push	{r4, r5, lr}
   33386:	e891 001c 	ldmia.w	r1, {r2, r3, r4}
   3338a:	2a00      	cmp	r2, #0
   3338c:	b083      	sub	sp, #12
   3338e:	bf18      	it	ne
   33390:	f04f 4200 	movne.w	r2, #2147483648	; 0x80000000
   33394:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
   33398:	ea42 0403 	orr.w	r4, r2, r3
   3339c:	4605      	mov	r5, r0
   3339e:	f000 f9e7 	bl	33770 <am_hal_interrupt_master_disable>
   333a2:	0169      	lsls	r1, r5, #5
   333a4:	4a03      	ldr	r2, [pc, #12]	; (333b4 <am_hal_ctimer_config+0x30>)
   333a6:	9001      	str	r0, [sp, #4]
   333a8:	508c      	str	r4, [r1, r2]
   333aa:	9801      	ldr	r0, [sp, #4]
   333ac:	f000 f9e4 	bl	33778 <am_hal_interrupt_master_set>
   333b0:	b003      	add	sp, #12
   333b2:	bd30      	pop	{r4, r5, pc}
   333b4:	4000800c 	.word	0x4000800c

000333b8 <am_hal_ctimer_start>:
   333b8:	b570      	push	{r4, r5, r6, lr}
   333ba:	b082      	sub	sp, #8
   333bc:	460c      	mov	r4, r1
   333be:	0146      	lsls	r6, r0, #5
   333c0:	f000 f9d6 	bl	33770 <am_hal_interrupt_master_disable>
   333c4:	4d07      	ldr	r5, [pc, #28]	; (333e4 <am_hal_ctimer_start+0x2c>)
   333c6:	9001      	str	r0, [sp, #4]
   333c8:	5973      	ldr	r3, [r6, r5]
   333ca:	f004 2108 	and.w	r1, r4, #134219776	; 0x8000800
   333ce:	ea23 0001 	bic.w	r0, r3, r1
   333d2:	f004 1201 	and.w	r2, r4, #65537	; 0x10001
   333d6:	4302      	orrs	r2, r0
   333d8:	5172      	str	r2, [r6, r5]
   333da:	9801      	ldr	r0, [sp, #4]
   333dc:	f000 f9cc 	bl	33778 <am_hal_interrupt_master_set>
   333e0:	b002      	add	sp, #8
   333e2:	bd70      	pop	{r4, r5, r6, pc}
   333e4:	4000800c 	.word	0x4000800c

000333e8 <am_hal_ctimer_clear>:
   333e8:	b570      	push	{r4, r5, r6, lr}
   333ea:	b082      	sub	sp, #8
   333ec:	0146      	lsls	r6, r0, #5
   333ee:	460c      	mov	r4, r1
   333f0:	f000 f9be 	bl	33770 <am_hal_interrupt_master_disable>
   333f4:	4d05      	ldr	r5, [pc, #20]	; (3340c <am_hal_ctimer_clear+0x24>)
   333f6:	9001      	str	r0, [sp, #4]
   333f8:	5973      	ldr	r3, [r6, r5]
   333fa:	f004 2108 	and.w	r1, r4, #134219776	; 0x8000800
   333fe:	4319      	orrs	r1, r3
   33400:	5171      	str	r1, [r6, r5]
   33402:	9801      	ldr	r0, [sp, #4]
   33404:	f000 f9b8 	bl	33778 <am_hal_interrupt_master_set>
   33408:	b002      	add	sp, #8
   3340a:	bd70      	pop	{r4, r5, r6, pc}
   3340c:	4000800c 	.word	0x4000800c

00033410 <am_hal_ctimer_period_set>:
   33410:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   33414:	b082      	sub	sp, #8
   33416:	4689      	mov	r9, r1
   33418:	4698      	mov	r8, r3
   3341a:	0147      	lsls	r7, r0, #5
   3341c:	4614      	mov	r4, r2
   3341e:	f000 f9a7 	bl	33770 <am_hal_interrupt_master_disable>
   33422:	f8df a094 	ldr.w	sl, [pc, #148]	; 334b8 <am_hal_ctimer_period_set+0xa8>
   33426:	9001      	str	r0, [sp, #4]
   33428:	f519 3f80 	cmn.w	r9, #65536	; 0x10000
   3342c:	4d20      	ldr	r5, [pc, #128]	; (334b0 <am_hal_ctimer_period_set+0xa0>)
   3342e:	4e21      	ldr	r6, [pc, #132]	; (334b4 <am_hal_ctimer_period_set+0xa4>)
   33430:	f857 300a 	ldr.w	r3, [r7, sl]
   33434:	d01a      	beq.n	3346c <am_hal_ctimer_period_set+0x5c>
   33436:	f403 70c0 	and.w	r0, r3, #384	; 0x180
   3343a:	2880      	cmp	r0, #128	; 0x80
   3343c:	d01b      	beq.n	33476 <am_hal_ctimer_period_set+0x66>
   3343e:	f64f 7cff 	movw	ip, #65535	; 0xffff
   33442:	2100      	movs	r1, #0
   33444:	45e1      	cmp	r9, ip
   33446:	460b      	mov	r3, r1
   33448:	d01e      	beq.n	33488 <am_hal_ctimer_period_set+0x78>
   3344a:	f519 3f80 	cmn.w	r9, #65536	; 0x10000
   3344e:	d025      	beq.n	3349c <am_hal_ctimer_period_set+0x8c>
   33450:	0c1b      	lsrs	r3, r3, #16
   33452:	0418      	lsls	r0, r3, #16
   33454:	b2a2      	uxth	r2, r4
   33456:	4311      	orrs	r1, r2
   33458:	ea40 4414 	orr.w	r4, r0, r4, lsr #16
   3345c:	5179      	str	r1, [r7, r5]
   3345e:	51bc      	str	r4, [r7, r6]
   33460:	9801      	ldr	r0, [sp, #4]
   33462:	f000 f989 	bl	33778 <am_hal_interrupt_master_set>
   33466:	b002      	add	sp, #8
   33468:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   3346c:	0c1a      	lsrs	r2, r3, #16
   3346e:	f402 70c0 	and.w	r0, r2, #384	; 0x180
   33472:	2880      	cmp	r0, #128	; 0x80
   33474:	d111      	bne.n	3349a <am_hal_ctimer_period_set+0x8a>
   33476:	f64f 7cff 	movw	ip, #65535	; 0xffff
   3347a:	45e1      	cmp	r9, ip
   3347c:	ea4f 4104 	mov.w	r1, r4, lsl #16
   33480:	4623      	mov	r3, r4
   33482:	ebc8 0404 	rsb	r4, r8, r4
   33486:	d1e0      	bne.n	3344a <am_hal_ctimer_period_set+0x3a>
   33488:	b2a6      	uxth	r6, r4
   3348a:	4331      	orrs	r1, r6
   3348c:	5179      	str	r1, [r7, r5]
   3348e:	9801      	ldr	r0, [sp, #4]
   33490:	f000 f972 	bl	33778 <am_hal_interrupt_master_set>
   33494:	b002      	add	sp, #8
   33496:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   3349a:	2100      	movs	r1, #0
   3349c:	b2a5      	uxth	r5, r4
   3349e:	4329      	orrs	r1, r5
   334a0:	51b9      	str	r1, [r7, r6]
   334a2:	9801      	ldr	r0, [sp, #4]
   334a4:	f000 f968 	bl	33778 <am_hal_interrupt_master_set>
   334a8:	b002      	add	sp, #8
   334aa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   334ae:	bf00      	nop
   334b0:	40008004 	.word	0x40008004
   334b4:	40008008 	.word	0x40008008
   334b8:	4000800c 	.word	0x4000800c

000334bc <am_hal_ctimer_int_enable>:
   334bc:	b510      	push	{r4, lr}
   334be:	b082      	sub	sp, #8
   334c0:	4604      	mov	r4, r0
   334c2:	f000 f955 	bl	33770 <am_hal_interrupt_master_disable>
   334c6:	4b06      	ldr	r3, [pc, #24]	; (334e0 <am_hal_ctimer_int_enable+0x24>)
   334c8:	9001      	str	r0, [sp, #4]
   334ca:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
   334ce:	4314      	orrs	r4, r2
   334d0:	f8c3 4200 	str.w	r4, [r3, #512]	; 0x200
   334d4:	9801      	ldr	r0, [sp, #4]
   334d6:	f000 f94f 	bl	33778 <am_hal_interrupt_master_set>
   334da:	b002      	add	sp, #8
   334dc:	bd10      	pop	{r4, pc}
   334de:	bf00      	nop
   334e0:	40008000 	.word	0x40008000

000334e4 <am_hal_ctimer_int_clear>:
   334e4:	b510      	push	{r4, lr}
   334e6:	b082      	sub	sp, #8
   334e8:	4604      	mov	r4, r0
   334ea:	f000 f941 	bl	33770 <am_hal_interrupt_master_disable>
   334ee:	4b04      	ldr	r3, [pc, #16]	; (33500 <am_hal_ctimer_int_clear+0x1c>)
   334f0:	9001      	str	r0, [sp, #4]
   334f2:	f8c3 4208 	str.w	r4, [r3, #520]	; 0x208
   334f6:	9801      	ldr	r0, [sp, #4]
   334f8:	f000 f93e 	bl	33778 <am_hal_interrupt_master_set>
   334fc:	b002      	add	sp, #8
   334fe:	bd10      	pop	{r4, pc}
   33500:	40008000 	.word	0x40008000

00033504 <am_hal_flash_delay>:
   33504:	4b00      	ldr	r3, [pc, #0]	; (33508 <am_hal_flash_delay+0x4>)
   33506:	4718      	bx	r3
   33508:	0800009d 	.word	0x0800009d

0003350c <am_hal_flash_delay_status_check>:
   3350c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   33510:	f89d 4020 	ldrb.w	r4, [sp, #32]
   33514:	460d      	mov	r5, r1
   33516:	4616      	mov	r6, r2
   33518:	461f      	mov	r7, r3
   3351a:	2c00      	cmp	r4, #0
   3351c:	f000 8091 	beq.w	33642 <am_hal_flash_delay_status_check+0x136>
   33520:	f010 0907 	ands.w	r9, r0, #7
   33524:	4604      	mov	r4, r0
   33526:	f8df 823c 	ldr.w	r8, [pc, #572]	; 33764 <am_hal_flash_delay_status_check+0x258>
   3352a:	d044      	beq.n	335b6 <am_hal_flash_delay_status_check+0xaa>
   3352c:	680b      	ldr	r3, [r1, #0]
   3352e:	4013      	ands	r3, r2
   33530:	429f      	cmp	r7, r3
   33532:	f000 8083 	beq.w	3363c <am_hal_flash_delay_status_check+0x130>
   33536:	2001      	movs	r0, #1
   33538:	47c0      	blx	r8
   3353a:	f1b9 0f01 	cmp.w	r9, #1
   3353e:	f104 34ff 	add.w	r4, r4, #4294967295	; 0xffffffff
   33542:	d038      	beq.n	335b6 <am_hal_flash_delay_status_check+0xaa>
   33544:	f1b9 0f02 	cmp.w	r9, #2
   33548:	d02e      	beq.n	335a8 <am_hal_flash_delay_status_check+0x9c>
   3354a:	f1b9 0f03 	cmp.w	r9, #3
   3354e:	d024      	beq.n	3359a <am_hal_flash_delay_status_check+0x8e>
   33550:	f1b9 0f04 	cmp.w	r9, #4
   33554:	d01a      	beq.n	3358c <am_hal_flash_delay_status_check+0x80>
   33556:	f1b9 0f05 	cmp.w	r9, #5
   3355a:	d010      	beq.n	3357e <am_hal_flash_delay_status_check+0x72>
   3355c:	f1b9 0f06 	cmp.w	r9, #6
   33560:	d006      	beq.n	33570 <am_hal_flash_delay_status_check+0x64>
   33562:	6828      	ldr	r0, [r5, #0]
   33564:	4030      	ands	r0, r6
   33566:	4287      	cmp	r7, r0
   33568:	d068      	beq.n	3363c <am_hal_flash_delay_status_check+0x130>
   3356a:	2001      	movs	r0, #1
   3356c:	47c0      	blx	r8
   3356e:	3c01      	subs	r4, #1
   33570:	6829      	ldr	r1, [r5, #0]
   33572:	4031      	ands	r1, r6
   33574:	428f      	cmp	r7, r1
   33576:	d061      	beq.n	3363c <am_hal_flash_delay_status_check+0x130>
   33578:	2001      	movs	r0, #1
   3357a:	47c0      	blx	r8
   3357c:	3c01      	subs	r4, #1
   3357e:	682a      	ldr	r2, [r5, #0]
   33580:	4032      	ands	r2, r6
   33582:	4297      	cmp	r7, r2
   33584:	d05a      	beq.n	3363c <am_hal_flash_delay_status_check+0x130>
   33586:	2001      	movs	r0, #1
   33588:	47c0      	blx	r8
   3358a:	3c01      	subs	r4, #1
   3358c:	682b      	ldr	r3, [r5, #0]
   3358e:	4033      	ands	r3, r6
   33590:	429f      	cmp	r7, r3
   33592:	d053      	beq.n	3363c <am_hal_flash_delay_status_check+0x130>
   33594:	2001      	movs	r0, #1
   33596:	47c0      	blx	r8
   33598:	3c01      	subs	r4, #1
   3359a:	6828      	ldr	r0, [r5, #0]
   3359c:	4030      	ands	r0, r6
   3359e:	4287      	cmp	r7, r0
   335a0:	d04c      	beq.n	3363c <am_hal_flash_delay_status_check+0x130>
   335a2:	2001      	movs	r0, #1
   335a4:	47c0      	blx	r8
   335a6:	3c01      	subs	r4, #1
   335a8:	6829      	ldr	r1, [r5, #0]
   335aa:	4031      	ands	r1, r6
   335ac:	428f      	cmp	r7, r1
   335ae:	d045      	beq.n	3363c <am_hal_flash_delay_status_check+0x130>
   335b0:	2001      	movs	r0, #1
   335b2:	3c01      	subs	r4, #1
   335b4:	47c0      	blx	r8
   335b6:	682a      	ldr	r2, [r5, #0]
   335b8:	4032      	ands	r2, r6
   335ba:	4297      	cmp	r7, r2
   335bc:	f04f 0001 	mov.w	r0, #1
   335c0:	d03c      	beq.n	3363c <am_hal_flash_delay_status_check+0x130>
   335c2:	2c00      	cmp	r4, #0
   335c4:	f000 80cb 	beq.w	3375e <am_hal_flash_delay_status_check+0x252>
   335c8:	47c0      	blx	r8
   335ca:	682b      	ldr	r3, [r5, #0]
   335cc:	4033      	ands	r3, r6
   335ce:	429f      	cmp	r7, r3
   335d0:	f04f 0001 	mov.w	r0, #1
   335d4:	d032      	beq.n	3363c <am_hal_flash_delay_status_check+0x130>
   335d6:	47c0      	blx	r8
   335d8:	6829      	ldr	r1, [r5, #0]
   335da:	4031      	ands	r1, r6
   335dc:	428f      	cmp	r7, r1
   335de:	f04f 0001 	mov.w	r0, #1
   335e2:	d02b      	beq.n	3363c <am_hal_flash_delay_status_check+0x130>
   335e4:	47c0      	blx	r8
   335e6:	682a      	ldr	r2, [r5, #0]
   335e8:	4032      	ands	r2, r6
   335ea:	4297      	cmp	r7, r2
   335ec:	f04f 0001 	mov.w	r0, #1
   335f0:	d024      	beq.n	3363c <am_hal_flash_delay_status_check+0x130>
   335f2:	47c0      	blx	r8
   335f4:	682b      	ldr	r3, [r5, #0]
   335f6:	4033      	ands	r3, r6
   335f8:	429f      	cmp	r7, r3
   335fa:	f04f 0001 	mov.w	r0, #1
   335fe:	d01d      	beq.n	3363c <am_hal_flash_delay_status_check+0x130>
   33600:	47c0      	blx	r8
   33602:	6829      	ldr	r1, [r5, #0]
   33604:	4031      	ands	r1, r6
   33606:	428f      	cmp	r7, r1
   33608:	f04f 0001 	mov.w	r0, #1
   3360c:	d016      	beq.n	3363c <am_hal_flash_delay_status_check+0x130>
   3360e:	47c0      	blx	r8
   33610:	682a      	ldr	r2, [r5, #0]
   33612:	4032      	ands	r2, r6
   33614:	4297      	cmp	r7, r2
   33616:	f04f 0001 	mov.w	r0, #1
   3361a:	d00f      	beq.n	3363c <am_hal_flash_delay_status_check+0x130>
   3361c:	47c0      	blx	r8
   3361e:	6828      	ldr	r0, [r5, #0]
   33620:	4030      	ands	r0, r6
   33622:	4287      	cmp	r7, r0
   33624:	f04f 0001 	mov.w	r0, #1
   33628:	d008      	beq.n	3363c <am_hal_flash_delay_status_check+0x130>
   3362a:	47c0      	blx	r8
   3362c:	682a      	ldr	r2, [r5, #0]
   3362e:	4032      	ands	r2, r6
   33630:	4297      	cmp	r7, r2
   33632:	f1a4 0408 	sub.w	r4, r4, #8
   33636:	f04f 0001 	mov.w	r0, #1
   3363a:	d1c2      	bne.n	335c2 <am_hal_flash_delay_status_check+0xb6>
   3363c:	2000      	movs	r0, #0
   3363e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   33642:	f010 0907 	ands.w	r9, r0, #7
   33646:	4604      	mov	r4, r0
   33648:	f8df 8118 	ldr.w	r8, [pc, #280]	; 33764 <am_hal_flash_delay_status_check+0x258>
   3364c:	d043      	beq.n	336d6 <am_hal_flash_delay_status_check+0x1ca>
   3364e:	680b      	ldr	r3, [r1, #0]
   33650:	4013      	ands	r3, r2
   33652:	429f      	cmp	r7, r3
   33654:	d1f2      	bne.n	3363c <am_hal_flash_delay_status_check+0x130>
   33656:	2001      	movs	r0, #1
   33658:	47c0      	blx	r8
   3365a:	f1b9 0f01 	cmp.w	r9, #1
   3365e:	f104 34ff 	add.w	r4, r4, #4294967295	; 0xffffffff
   33662:	d038      	beq.n	336d6 <am_hal_flash_delay_status_check+0x1ca>
   33664:	f1b9 0f02 	cmp.w	r9, #2
   33668:	d02e      	beq.n	336c8 <am_hal_flash_delay_status_check+0x1bc>
   3366a:	f1b9 0f03 	cmp.w	r9, #3
   3366e:	d024      	beq.n	336ba <am_hal_flash_delay_status_check+0x1ae>
   33670:	f1b9 0f04 	cmp.w	r9, #4
   33674:	d01a      	beq.n	336ac <am_hal_flash_delay_status_check+0x1a0>
   33676:	f1b9 0f05 	cmp.w	r9, #5
   3367a:	d010      	beq.n	3369e <am_hal_flash_delay_status_check+0x192>
   3367c:	f1b9 0f06 	cmp.w	r9, #6
   33680:	d006      	beq.n	33690 <am_hal_flash_delay_status_check+0x184>
   33682:	6829      	ldr	r1, [r5, #0]
   33684:	4031      	ands	r1, r6
   33686:	428f      	cmp	r7, r1
   33688:	d1d8      	bne.n	3363c <am_hal_flash_delay_status_check+0x130>
   3368a:	2001      	movs	r0, #1
   3368c:	47c0      	blx	r8
   3368e:	3c01      	subs	r4, #1
   33690:	682a      	ldr	r2, [r5, #0]
   33692:	4032      	ands	r2, r6
   33694:	4297      	cmp	r7, r2
   33696:	d1d1      	bne.n	3363c <am_hal_flash_delay_status_check+0x130>
   33698:	2001      	movs	r0, #1
   3369a:	47c0      	blx	r8
   3369c:	3c01      	subs	r4, #1
   3369e:	6828      	ldr	r0, [r5, #0]
   336a0:	4030      	ands	r0, r6
   336a2:	4287      	cmp	r7, r0
   336a4:	d1ca      	bne.n	3363c <am_hal_flash_delay_status_check+0x130>
   336a6:	2001      	movs	r0, #1
   336a8:	47c0      	blx	r8
   336aa:	3c01      	subs	r4, #1
   336ac:	682b      	ldr	r3, [r5, #0]
   336ae:	4033      	ands	r3, r6
   336b0:	429f      	cmp	r7, r3
   336b2:	d1c3      	bne.n	3363c <am_hal_flash_delay_status_check+0x130>
   336b4:	2001      	movs	r0, #1
   336b6:	47c0      	blx	r8
   336b8:	3c01      	subs	r4, #1
   336ba:	6829      	ldr	r1, [r5, #0]
   336bc:	4031      	ands	r1, r6
   336be:	428f      	cmp	r7, r1
   336c0:	d1bc      	bne.n	3363c <am_hal_flash_delay_status_check+0x130>
   336c2:	2001      	movs	r0, #1
   336c4:	47c0      	blx	r8
   336c6:	3c01      	subs	r4, #1
   336c8:	682a      	ldr	r2, [r5, #0]
   336ca:	4032      	ands	r2, r6
   336cc:	4297      	cmp	r7, r2
   336ce:	d1b5      	bne.n	3363c <am_hal_flash_delay_status_check+0x130>
   336d0:	2001      	movs	r0, #1
   336d2:	3c01      	subs	r4, #1
   336d4:	47c0      	blx	r8
   336d6:	682b      	ldr	r3, [r5, #0]
   336d8:	4033      	ands	r3, r6
   336da:	429f      	cmp	r7, r3
   336dc:	f04f 0001 	mov.w	r0, #1
   336e0:	d1ac      	bne.n	3363c <am_hal_flash_delay_status_check+0x130>
   336e2:	2c00      	cmp	r4, #0
   336e4:	d03b      	beq.n	3375e <am_hal_flash_delay_status_check+0x252>
   336e6:	47c0      	blx	r8
   336e8:	6829      	ldr	r1, [r5, #0]
   336ea:	4031      	ands	r1, r6
   336ec:	428f      	cmp	r7, r1
   336ee:	f04f 0001 	mov.w	r0, #1
   336f2:	d1a3      	bne.n	3363c <am_hal_flash_delay_status_check+0x130>
   336f4:	47c0      	blx	r8
   336f6:	682a      	ldr	r2, [r5, #0]
   336f8:	4032      	ands	r2, r6
   336fa:	4297      	cmp	r7, r2
   336fc:	f04f 0001 	mov.w	r0, #1
   33700:	d19c      	bne.n	3363c <am_hal_flash_delay_status_check+0x130>
   33702:	47c0      	blx	r8
   33704:	682b      	ldr	r3, [r5, #0]
   33706:	4033      	ands	r3, r6
   33708:	429f      	cmp	r7, r3
   3370a:	f04f 0001 	mov.w	r0, #1
   3370e:	d195      	bne.n	3363c <am_hal_flash_delay_status_check+0x130>
   33710:	47c0      	blx	r8
   33712:	6829      	ldr	r1, [r5, #0]
   33714:	4031      	ands	r1, r6
   33716:	428f      	cmp	r7, r1
   33718:	f04f 0001 	mov.w	r0, #1
   3371c:	d18e      	bne.n	3363c <am_hal_flash_delay_status_check+0x130>
   3371e:	47c0      	blx	r8
   33720:	682a      	ldr	r2, [r5, #0]
   33722:	4032      	ands	r2, r6
   33724:	4297      	cmp	r7, r2
   33726:	f04f 0001 	mov.w	r0, #1
   3372a:	d187      	bne.n	3363c <am_hal_flash_delay_status_check+0x130>
   3372c:	47c0      	blx	r8
   3372e:	682b      	ldr	r3, [r5, #0]
   33730:	4033      	ands	r3, r6
   33732:	429f      	cmp	r7, r3
   33734:	f04f 0001 	mov.w	r0, #1
   33738:	d180      	bne.n	3363c <am_hal_flash_delay_status_check+0x130>
   3373a:	47c0      	blx	r8
   3373c:	6828      	ldr	r0, [r5, #0]
   3373e:	4030      	ands	r0, r6
   33740:	4287      	cmp	r7, r0
   33742:	f04f 0001 	mov.w	r0, #1
   33746:	f47f af79 	bne.w	3363c <am_hal_flash_delay_status_check+0x130>
   3374a:	47c0      	blx	r8
   3374c:	682b      	ldr	r3, [r5, #0]
   3374e:	4033      	ands	r3, r6
   33750:	429f      	cmp	r7, r3
   33752:	f1a4 0408 	sub.w	r4, r4, #8
   33756:	f04f 0001 	mov.w	r0, #1
   3375a:	d0c2      	beq.n	336e2 <am_hal_flash_delay_status_check+0x1d6>
   3375c:	e76e      	b.n	3363c <am_hal_flash_delay_status_check+0x130>
   3375e:	2004      	movs	r0, #4
   33760:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   33764:	0800009d 	.word	0x0800009d

00033768 <am_hal_interrupt_master_enable>:
   33768:	f3ef 8010 	mrs	r0, PRIMASK
   3376c:	b662      	cpsie	i
   3376e:	4770      	bx	lr

00033770 <am_hal_interrupt_master_disable>:
   33770:	f3ef 8010 	mrs	r0, PRIMASK
   33774:	b672      	cpsid	i
   33776:	4770      	bx	lr

00033778 <am_hal_interrupt_master_set>:
   33778:	f380 8810 	msr	PRIMASK, r0
   3377c:	4770      	bx	lr
   3377e:	bf00      	nop

00033780 <am_hal_itm_disable>:
   33780:	b510      	push	{r4, lr}
   33782:	4b25      	ldr	r3, [pc, #148]	; (33818 <am_hal_itm_disable+0x98>)
   33784:	f8d3 0250 	ldr.w	r0, [r3, #592]	; 0x250
   33788:	b9b0      	cbnz	r0, 337b8 <am_hal_itm_disable+0x38>
   3378a:	4924      	ldr	r1, [pc, #144]	; (3381c <am_hal_itm_disable+0x9c>)
   3378c:	68ca      	ldr	r2, [r1, #12]
   3378e:	f042 7480 	orr.w	r4, r2, #16777216	; 0x1000000
   33792:	60cc      	str	r4, [r1, #12]
   33794:	68cb      	ldr	r3, [r1, #12]
   33796:	01da      	lsls	r2, r3, #7
   33798:	d5fc      	bpl.n	33794 <am_hal_itm_disable+0x14>
   3379a:	f04f 4c60 	mov.w	ip, #3758096384	; 0xe0000000
   3379e:	4820      	ldr	r0, [pc, #128]	; (33820 <am_hal_itm_disable+0xa0>)
   337a0:	4a20      	ldr	r2, [pc, #128]	; (33824 <am_hal_itm_disable+0xa4>)
   337a2:	f8cc 0fb0 	str.w	r0, [ip, #4016]	; 0xfb0
   337a6:	240f      	movs	r4, #15
   337a8:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   337ac:	f8cc 4e40 	str.w	r4, [ip, #3648]	; 0xe40
   337b0:	f8cc 1e00 	str.w	r1, [ip, #3584]	; 0xe00
   337b4:	f8cc 2e80 	str.w	r2, [ip, #3712]	; 0xe80
   337b8:	f04f 4e60 	mov.w	lr, #3758096384	; 0xe0000000
   337bc:	f8de 3e80 	ldr.w	r3, [lr, #3712]	; 0xe80
   337c0:	021b      	lsls	r3, r3, #8
   337c2:	f04f 4460 	mov.w	r4, #3758096384	; 0xe0000000
   337c6:	d4f9      	bmi.n	337bc <am_hal_itm_disable+0x3c>
   337c8:	f240 20f7 	movw	r0, #759	; 0x2f7
   337cc:	f7ff fe9a 	bl	33504 <am_hal_flash_delay>
   337d0:	4813      	ldr	r0, [pc, #76]	; (33820 <am_hal_itm_disable+0xa0>)
   337d2:	f8c4 0fb0 	str.w	r0, [r4, #4016]	; 0xfb0
   337d6:	46a4      	mov	ip, r4
   337d8:	2064      	movs	r0, #100	; 0x64
   337da:	f8dc 2e80 	ldr.w	r2, [ip, #3712]	; 0xe80
   337de:	f022 0101 	bic.w	r1, r2, #1
   337e2:	f8cc 1e80 	str.w	r1, [ip, #3712]	; 0xe80
   337e6:	f8dc 4e80 	ldr.w	r4, [ip, #3712]	; 0xe80
   337ea:	4b0f      	ldr	r3, [pc, #60]	; (33828 <am_hal_itm_disable+0xa8>)
   337ec:	4023      	ands	r3, r4
   337ee:	2b00      	cmp	r3, #0
   337f0:	d1f9      	bne.n	337e6 <am_hal_itm_disable+0x66>
   337f2:	3801      	subs	r0, #1
   337f4:	d1f1      	bne.n	337da <am_hal_itm_disable+0x5a>
   337f6:	4a09      	ldr	r2, [pc, #36]	; (3381c <am_hal_itm_disable+0x9c>)
   337f8:	68d1      	ldr	r1, [r2, #12]
   337fa:	f021 7480 	bic.w	r4, r1, #16777216	; 0x1000000
   337fe:	60d4      	str	r4, [r2, #12]
   33800:	68d3      	ldr	r3, [r2, #12]
   33802:	f013 7080 	ands.w	r0, r3, #16777216	; 0x1000000
   33806:	d1fb      	bne.n	33800 <am_hal_itm_disable+0x80>
   33808:	4a03      	ldr	r2, [pc, #12]	; (33818 <am_hal_itm_disable+0x98>)
   3380a:	f8c2 0250 	str.w	r0, [r2, #592]	; 0x250
   3380e:	f8d2 1250 	ldr.w	r1, [r2, #592]	; 0x250
   33812:	2900      	cmp	r1, #0
   33814:	d1fb      	bne.n	3380e <am_hal_itm_disable+0x8e>
   33816:	bd10      	pop	{r4, pc}
   33818:	40020000 	.word	0x40020000
   3381c:	e000edf0 	.word	0xe000edf0
   33820:	c5acce55 	.word	0xc5acce55
   33824:	00150511 	.word	0x00150511
   33828:	00800001 	.word	0x00800001

0003382c <am_hal_mcuctrl_info_get>:
   3382c:	b4f0      	push	{r4, r5, r6, r7}
   3382e:	b121      	cbz	r1, 3383a <am_hal_mcuctrl_info_get+0xe>
   33830:	2801      	cmp	r0, #1
   33832:	d038      	beq.n	338a6 <am_hal_mcuctrl_info_get+0x7a>
   33834:	d320      	bcc.n	33878 <am_hal_mcuctrl_info_get+0x4c>
   33836:	2802      	cmp	r0, #2
   33838:	d002      	beq.n	33840 <am_hal_mcuctrl_info_get+0x14>
   3383a:	2006      	movs	r0, #6
   3383c:	bcf0      	pop	{r4, r5, r6, r7}
   3383e:	4770      	bx	lr
   33840:	4a41      	ldr	r2, [pc, #260]	; (33948 <am_hal_mcuctrl_info_get+0x11c>)
   33842:	684d      	ldr	r5, [r1, #4]
   33844:	f8d2 31cc 	ldr.w	r3, [r2, #460]	; 0x1cc
   33848:	694c      	ldr	r4, [r1, #20]
   3384a:	f003 0601 	and.w	r6, r3, #1
   3384e:	f3c3 0040 	ubfx	r0, r3, #1, #1
   33852:	f3c3 0780 	ubfx	r7, r3, #2, #1
   33856:	7208      	strb	r0, [r1, #8]
   33858:	740f      	strb	r7, [r1, #16]
   3385a:	700e      	strb	r6, [r1, #0]
   3385c:	f8d2 31c4 	ldr.w	r3, [r2, #452]	; 0x1c4
   33860:	60cb      	str	r3, [r1, #12]
   33862:	f8d2 61c0 	ldr.w	r6, [r2, #448]	; 0x1c0
   33866:	432e      	orrs	r6, r5
   33868:	604e      	str	r6, [r1, #4]
   3386a:	f8d2 21c8 	ldr.w	r2, [r2, #456]	; 0x1c8
   3386e:	4322      	orrs	r2, r4
   33870:	2000      	movs	r0, #0
   33872:	614a      	str	r2, [r1, #20]
   33874:	bcf0      	pop	{r4, r5, r6, r7}
   33876:	4770      	bx	lr
   33878:	4d33      	ldr	r5, [pc, #204]	; (33948 <am_hal_mcuctrl_info_get+0x11c>)
   3387a:	69ac      	ldr	r4, [r5, #24]
   3387c:	f3c4 1080 	ubfx	r0, r4, #6, #1
   33880:	f3c4 0780 	ubfx	r7, r4, #2, #1
   33884:	7008      	strb	r0, [r1, #0]
   33886:	704f      	strb	r7, [r1, #1]
   33888:	f8d5 31a0 	ldr.w	r3, [r5, #416]	; 0x1a0
   3388c:	f3c3 6681 	ubfx	r6, r3, #26, #2
   33890:	710e      	strb	r6, [r1, #4]
   33892:	696d      	ldr	r5, [r5, #20]
   33894:	f3c5 0240 	ubfx	r2, r5, #1, #1
   33898:	f005 0401 	and.w	r4, r5, #1
   3389c:	70cc      	strb	r4, [r1, #3]
   3389e:	2000      	movs	r0, #0
   338a0:	708a      	strb	r2, [r1, #2]
   338a2:	bcf0      	pop	{r4, r5, r6, r7}
   338a4:	4770      	bx	lr
   338a6:	4b28      	ldr	r3, [pc, #160]	; (33948 <am_hal_mcuctrl_info_get+0x11c>)
   338a8:	4c28      	ldr	r4, [pc, #160]	; (3394c <am_hal_mcuctrl_info_get+0x120>)
   338aa:	681a      	ldr	r2, [r3, #0]
   338ac:	600a      	str	r2, [r1, #0]
   338ae:	6858      	ldr	r0, [r3, #4]
   338b0:	6048      	str	r0, [r1, #4]
   338b2:	689f      	ldr	r7, [r3, #8]
   338b4:	608f      	str	r7, [r1, #8]
   338b6:	68de      	ldr	r6, [r3, #12]
   338b8:	60ce      	str	r6, [r1, #12]
   338ba:	691d      	ldr	r5, [r3, #16]
   338bc:	4824      	ldr	r0, [pc, #144]	; (33950 <am_hal_mcuctrl_info_get+0x124>)
   338be:	610d      	str	r5, [r1, #16]
   338c0:	f3c2 5c03 	ubfx	ip, r2, #20, #4
   338c4:	f3c2 4703 	ubfx	r7, r2, #16, #4
   338c8:	695e      	ldr	r6, [r3, #20]
   338ca:	f850 5027 	ldr.w	r5, [r0, r7, lsl #2]
   338ce:	4b21      	ldr	r3, [pc, #132]	; (33954 <am_hal_mcuctrl_info_get+0x128>)
   338d0:	f854 402c 	ldr.w	r4, [r4, ip, lsl #2]
   338d4:	614e      	str	r6, [r1, #20]
   338d6:	f002 0201 	and.w	r2, r2, #1
   338da:	61cc      	str	r4, [r1, #28]
   338dc:	620d      	str	r5, [r1, #32]
   338de:	618a      	str	r2, [r1, #24]
   338e0:	f8d3 00e0 	ldr.w	r0, [r3, #224]	; 0xe0
   338e4:	f8d3 70e4 	ldr.w	r7, [r3, #228]	; 0xe4
   338e8:	b2c6      	uxtb	r6, r0
   338ea:	f007 040f 	and.w	r4, r7, #15
   338ee:	ea46 2504 	orr.w	r5, r6, r4, lsl #8
   338f2:	624d      	str	r5, [r1, #36]	; 0x24
   338f4:	f8d3 20e4 	ldr.w	r2, [r3, #228]	; 0xe4
   338f8:	f8d3 70e8 	ldr.w	r7, [r3, #232]	; 0xe8
   338fc:	f3c2 1c03 	ubfx	ip, r2, #4, #4
   33900:	f007 000f 	and.w	r0, r7, #15
   33904:	ea4c 1600 	orr.w	r6, ip, r0, lsl #4
   33908:	628e      	str	r6, [r1, #40]	; 0x28
   3390a:	f8d3 40e8 	ldr.w	r4, [r3, #232]	; 0xe8
   3390e:	f8d3 50ec 	ldr.w	r5, [r3, #236]	; 0xec
   33912:	f004 07f0 	and.w	r7, r4, #240	; 0xf0
   33916:	f3c5 1203 	ubfx	r2, r5, #4, #4
   3391a:	433a      	orrs	r2, r7
   3391c:	62ca      	str	r2, [r1, #44]	; 0x2c
   3391e:	f8d3 60fc 	ldr.w	r6, [r3, #252]	; 0xfc
   33922:	f8d3 00f8 	ldr.w	r0, [r3, #248]	; 0xf8
   33926:	f8d3 40f4 	ldr.w	r4, [r3, #244]	; 0xf4
   3392a:	f8d3 50f0 	ldr.w	r5, [r3, #240]	; 0xf0
   3392e:	b2c3      	uxtb	r3, r0
   33930:	041f      	lsls	r7, r3, #16
   33932:	ea47 6606 	orr.w	r6, r7, r6, lsl #24
   33936:	b2ea      	uxtb	r2, r5
   33938:	4332      	orrs	r2, r6
   3393a:	b2e0      	uxtb	r0, r4
   3393c:	ea42 2400 	orr.w	r4, r2, r0, lsl #8
   33940:	630c      	str	r4, [r1, #48]	; 0x30
   33942:	2000      	movs	r0, #0
   33944:	bcf0      	pop	{r4, r5, r6, r7}
   33946:	4770      	bx	lr
   33948:	40020000 	.word	0x40020000
   3394c:	0003b738 	.word	0x0003b738
   33950:	0003b778 	.word	0x0003b778
   33954:	f0000f00 	.word	0xf0000f00

00033958 <am_hal_pwrctrl_periph_enable>:
   33958:	b570      	push	{r4, r5, r6, lr}
   3395a:	b082      	sub	sp, #8
   3395c:	4604      	mov	r4, r0
   3395e:	f7ff ff07 	bl	33770 <am_hal_interrupt_master_disable>
   33962:	eb04 0144 	add.w	r1, r4, r4, lsl #1
   33966:	008c      	lsls	r4, r1, #2
   33968:	4d0e      	ldr	r5, [pc, #56]	; (339a4 <am_hal_pwrctrl_periph_enable+0x4c>)
   3396a:	4e0f      	ldr	r6, [pc, #60]	; (339a8 <am_hal_pwrctrl_periph_enable+0x50>)
   3396c:	9001      	str	r0, [sp, #4]
   3396e:	68aa      	ldr	r2, [r5, #8]
   33970:	5933      	ldr	r3, [r6, r4]
   33972:	4313      	orrs	r3, r2
   33974:	60ab      	str	r3, [r5, #8]
   33976:	9801      	ldr	r0, [sp, #4]
   33978:	4434      	add	r4, r6
   3397a:	f7ff fefd 	bl	33778 <am_hal_interrupt_master_set>
   3397e:	2077      	movs	r0, #119	; 0x77
   33980:	f7ff fdc0 	bl	33504 <am_hal_flash_delay>
   33984:	69a8      	ldr	r0, [r5, #24]
   33986:	6864      	ldr	r4, [r4, #4]
   33988:	4220      	tst	r0, r4
   3398a:	d103      	bne.n	33994 <am_hal_pwrctrl_periph_enable+0x3c>
   3398c:	2077      	movs	r0, #119	; 0x77
   3398e:	f7ff fdb9 	bl	33504 <am_hal_flash_delay>
   33992:	69ab      	ldr	r3, [r5, #24]
   33994:	4903      	ldr	r1, [pc, #12]	; (339a4 <am_hal_pwrctrl_periph_enable+0x4c>)
   33996:	698e      	ldr	r6, [r1, #24]
   33998:	4226      	tst	r6, r4
   3399a:	bf0c      	ite	eq
   3399c:	2001      	moveq	r0, #1
   3399e:	2000      	movne	r0, #0
   339a0:	b002      	add	sp, #8
   339a2:	bd70      	pop	{r4, r5, r6, pc}
   339a4:	40021000 	.word	0x40021000
   339a8:	0003b7b8 	.word	0x0003b7b8

000339ac <am_hal_pwrctrl_periph_disable>:
   339ac:	b570      	push	{r4, r5, r6, lr}
   339ae:	b082      	sub	sp, #8
   339b0:	4604      	mov	r4, r0
   339b2:	f7ff fedd 	bl	33770 <am_hal_interrupt_master_disable>
   339b6:	eb04 0144 	add.w	r1, r4, r4, lsl #1
   339ba:	008c      	lsls	r4, r1, #2
   339bc:	4d0f      	ldr	r5, [pc, #60]	; (339fc <am_hal_pwrctrl_periph_disable+0x50>)
   339be:	4e10      	ldr	r6, [pc, #64]	; (33a00 <am_hal_pwrctrl_periph_disable+0x54>)
   339c0:	9001      	str	r0, [sp, #4]
   339c2:	68ab      	ldr	r3, [r5, #8]
   339c4:	5932      	ldr	r2, [r6, r4]
   339c6:	ea23 0002 	bic.w	r0, r3, r2
   339ca:	60a8      	str	r0, [r5, #8]
   339cc:	9801      	ldr	r0, [sp, #4]
   339ce:	4434      	add	r4, r6
   339d0:	f7ff fed2 	bl	33778 <am_hal_interrupt_master_set>
   339d4:	2077      	movs	r0, #119	; 0x77
   339d6:	f7ff fd95 	bl	33504 <am_hal_flash_delay>
   339da:	69a9      	ldr	r1, [r5, #24]
   339dc:	6864      	ldr	r4, [r4, #4]
   339de:	4221      	tst	r1, r4
   339e0:	d003      	beq.n	339ea <am_hal_pwrctrl_periph_disable+0x3e>
   339e2:	2077      	movs	r0, #119	; 0x77
   339e4:	f7ff fd8e 	bl	33504 <am_hal_flash_delay>
   339e8:	69ab      	ldr	r3, [r5, #24]
   339ea:	4e04      	ldr	r6, [pc, #16]	; (339fc <am_hal_pwrctrl_periph_disable+0x50>)
   339ec:	69b5      	ldr	r5, [r6, #24]
   339ee:	4225      	tst	r5, r4
   339f0:	bf14      	ite	ne
   339f2:	2001      	movne	r0, #1
   339f4:	2000      	moveq	r0, #0
   339f6:	b002      	add	sp, #8
   339f8:	bd70      	pop	{r4, r5, r6, pc}
   339fa:	bf00      	nop
   339fc:	40021000 	.word	0x40021000
   33a00:	0003b7b8 	.word	0x0003b7b8

00033a04 <am_hal_pwrctrl_low_power_init>:
   33a04:	b530      	push	{r4, r5, lr}
   33a06:	4c1b      	ldr	r4, [pc, #108]	; (33a74 <am_hal_pwrctrl_low_power_init+0x70>)
   33a08:	69a3      	ldr	r3, [r4, #24]
   33a0a:	05db      	lsls	r3, r3, #23
   33a0c:	b083      	sub	sp, #12
   33a0e:	d502      	bpl.n	33a16 <am_hal_pwrctrl_low_power_init+0x12>
   33a10:	2000      	movs	r0, #0
   33a12:	b003      	add	sp, #12
   33a14:	bd30      	pop	{r4, r5, pc}
   33a16:	4d18      	ldr	r5, [pc, #96]	; (33a78 <am_hal_pwrctrl_low_power_init+0x74>)
   33a18:	4918      	ldr	r1, [pc, #96]	; (33a7c <am_hal_pwrctrl_low_power_init+0x78>)
   33a1a:	2001      	movs	r0, #1
   33a1c:	2307      	movs	r3, #7
   33a1e:	61a8      	str	r0, [r5, #24]
   33a20:	461a      	mov	r2, r3
   33a22:	9000      	str	r0, [sp, #0]
   33a24:	f242 7010 	movw	r0, #10000	; 0x2710
   33a28:	f7ff fd70 	bl	3350c <am_hal_flash_delay_status_check>
   33a2c:	b110      	cbz	r0, 33a34 <am_hal_pwrctrl_low_power_init+0x30>
   33a2e:	2004      	movs	r0, #4
   33a30:	b003      	add	sp, #12
   33a32:	bd30      	pop	{r4, r5, pc}
   33a34:	6821      	ldr	r1, [r4, #0]
   33a36:	f041 0201 	orr.w	r2, r1, #1
   33a3a:	6022      	str	r2, [r4, #0]
   33a3c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   33a3e:	f043 0140 	orr.w	r1, r3, #64	; 0x40
   33a42:	6261      	str	r1, [r4, #36]	; 0x24
   33a44:	68ec      	ldr	r4, [r5, #12]
   33a46:	b2e2      	uxtb	r2, r4
   33a48:	2a11      	cmp	r2, #17
   33a4a:	d1e1      	bne.n	33a10 <am_hal_pwrctrl_low_power_init+0xc>
   33a4c:	f8d5 335c 	ldr.w	r3, [r5, #860]	; 0x35c
   33a50:	f360 5356 	bfi	r3, r0, #21, #2
   33a54:	f8c5 335c 	str.w	r3, [r5, #860]	; 0x35c
   33a58:	f8d5 1368 	ldr.w	r1, [r5, #872]	; 0x368
   33a5c:	240f      	movs	r4, #15
   33a5e:	f364 118b 	bfi	r1, r4, #6, #6
   33a62:	f8c5 1368 	str.w	r1, [r5, #872]	; 0x368
   33a66:	f8d5 2368 	ldr.w	r2, [r5, #872]	; 0x368
   33a6a:	f364 0205 	bfi	r2, r4, #0, #6
   33a6e:	f8c5 2368 	str.w	r2, [r5, #872]	; 0x368
   33a72:	e7ce      	b.n	33a12 <am_hal_pwrctrl_low_power_init+0xe>
   33a74:	40021000 	.word	0x40021000
   33a78:	40020000 	.word	0x40020000
   33a7c:	40020018 	.word	0x40020018

00033a80 <am_hal_rtc_osc_select>:
   33a80:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
   33a84:	2801      	cmp	r0, #1
   33a86:	68d3      	ldr	r3, [r2, #12]
   33a88:	bf0c      	ite	eq
   33a8a:	f043 0380 	orreq.w	r3, r3, #128	; 0x80
   33a8e:	f023 0380 	bicne.w	r3, r3, #128	; 0x80
   33a92:	60d3      	str	r3, [r2, #12]
   33a94:	4770      	bx	lr
   33a96:	bf00      	nop

00033a98 <am_hal_rtc_osc_disable>:
   33a98:	4a03      	ldr	r2, [pc, #12]	; (33aa8 <am_hal_rtc_osc_disable+0x10>)
   33a9a:	f892 3050 	ldrb.w	r3, [r2, #80]	; 0x50
   33a9e:	f043 0010 	orr.w	r0, r3, #16
   33aa2:	f882 0050 	strb.w	r0, [r2, #80]	; 0x50
   33aa6:	4770      	bx	lr
   33aa8:	40004200 	.word	0x40004200

00033aac <am_hal_sysctrl_sleep>:
   33aac:	b510      	push	{r4, lr}
   33aae:	b082      	sub	sp, #8
   33ab0:	4604      	mov	r4, r0
   33ab2:	f7ff fe5d 	bl	33770 <am_hal_interrupt_master_disable>
   33ab6:	9001      	str	r0, [sp, #4]
   33ab8:	b124      	cbz	r4, 33ac4 <am_hal_sysctrl_sleep+0x18>
   33aba:	4b0c      	ldr	r3, [pc, #48]	; (33aec <am_hal_sysctrl_sleep+0x40>)
   33abc:	f8d3 0250 	ldr.w	r0, [r3, #592]	; 0x250
   33ac0:	07c3      	lsls	r3, r0, #31
   33ac2:	d50a      	bpl.n	33ada <am_hal_sysctrl_sleep+0x2e>
   33ac4:	4a0a      	ldr	r2, [pc, #40]	; (33af0 <am_hal_sysctrl_sleep+0x44>)
   33ac6:	6911      	ldr	r1, [r2, #16]
   33ac8:	f021 0404 	bic.w	r4, r1, #4
   33acc:	6114      	str	r4, [r2, #16]
   33ace:	bf30      	wfi
   33ad0:	9801      	ldr	r0, [sp, #4]
   33ad2:	f7ff fe51 	bl	33778 <am_hal_interrupt_master_set>
   33ad6:	b002      	add	sp, #8
   33ad8:	bd10      	pop	{r4, pc}
   33ada:	4b05      	ldr	r3, [pc, #20]	; (33af0 <am_hal_sysctrl_sleep+0x44>)
   33adc:	2004      	movs	r0, #4
   33ade:	6118      	str	r0, [r3, #16]
   33ae0:	bf30      	wfi
   33ae2:	9801      	ldr	r0, [sp, #4]
   33ae4:	f7ff fe48 	bl	33778 <am_hal_interrupt_master_set>
   33ae8:	b002      	add	sp, #8
   33aea:	bd10      	pop	{r4, pc}
   33aec:	40020000 	.word	0x40020000
   33af0:	e000ed00 	.word	0xe000ed00

00033af4 <am_hal_uart_initialize>:
   33af4:	2801      	cmp	r0, #1
   33af6:	d901      	bls.n	33afc <am_hal_uart_initialize+0x8>
   33af8:	2005      	movs	r0, #5
   33afa:	4770      	bx	lr
   33afc:	b169      	cbz	r1, 33b1a <am_hal_uart_initialize+0x26>
   33afe:	b5f0      	push	{r4, r5, r6, r7, lr}
   33b00:	2264      	movs	r2, #100	; 0x64
   33b02:	4e0e      	ldr	r6, [pc, #56]	; (33b3c <am_hal_uart_initialize+0x48>)
   33b04:	fb02 f200 	mul.w	r2, r2, r0
   33b08:	18b4      	adds	r4, r6, r2
   33b0a:	4603      	mov	r3, r0
   33b0c:	78e0      	ldrb	r0, [r4, #3]
   33b0e:	f3c0 0700 	ubfx	r7, r0, #0, #1
   33b12:	b2fd      	uxtb	r5, r7
   33b14:	b11d      	cbz	r5, 33b1e <am_hal_uart_initialize+0x2a>
   33b16:	2007      	movs	r0, #7
   33b18:	bdf0      	pop	{r4, r5, r6, r7, pc}
   33b1a:	2006      	movs	r0, #6
   33b1c:	4770      	bx	lr
   33b1e:	f040 0001 	orr.w	r0, r0, #1
   33b22:	70e0      	strb	r0, [r4, #3]
   33b24:	58b0      	ldr	r0, [r6, r2]
   33b26:	f8df e018 	ldr.w	lr, [pc, #24]	; 33b40 <am_hal_uart_initialize+0x4c>
   33b2a:	f36e 0017 	bfi	r0, lr, #0, #24
   33b2e:	50b0      	str	r0, [r6, r2]
   33b30:	6263      	str	r3, [r4, #36]	; 0x24
   33b32:	7127      	strb	r7, [r4, #4]
   33b34:	6625      	str	r5, [r4, #96]	; 0x60
   33b36:	4628      	mov	r0, r5
   33b38:	600c      	str	r4, [r1, #0]
   33b3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   33b3c:	100113f0 	.word	0x100113f0
   33b40:	00ea9e06 	.word	0x00ea9e06

00033b44 <am_hal_uart_power_control>:
   33b44:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   33b48:	6804      	ldr	r4, [r0, #0]
   33b4a:	4b36      	ldr	r3, [pc, #216]	; (33c24 <am_hal_uart_power_control+0xe0>)
   33b4c:	f024 447e 	bic.w	r4, r4, #4261412864	; 0xfe000000
   33b50:	429c      	cmp	r4, r3
   33b52:	b083      	sub	sp, #12
   33b54:	d003      	beq.n	33b5e <am_hal_uart_power_control+0x1a>
   33b56:	2002      	movs	r0, #2
   33b58:	b003      	add	sp, #12
   33b5a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   33b5e:	6a47      	ldr	r7, [r0, #36]	; 0x24
   33b60:	4605      	mov	r5, r0
   33b62:	f107 0008 	add.w	r0, r7, #8
   33b66:	4691      	mov	r9, r2
   33b68:	460e      	mov	r6, r1
   33b6a:	fa5f f880 	uxtb.w	r8, r0
   33b6e:	b181      	cbz	r1, 33b92 <am_hal_uart_power_control+0x4e>
   33b70:	2902      	cmp	r1, #2
   33b72:	d80c      	bhi.n	33b8e <am_hal_uart_power_control+0x4a>
   33b74:	b992      	cbnz	r2, 33b9c <am_hal_uart_power_control+0x58>
   33b76:	f507 2480 	add.w	r4, r7, #262144	; 0x40000
   33b7a:	341c      	adds	r4, #28
   33b7c:	0325      	lsls	r5, r4, #12
   33b7e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   33b82:	6469      	str	r1, [r5, #68]	; 0x44
   33b84:	4640      	mov	r0, r8
   33b86:	f7ff ff11 	bl	339ac <am_hal_pwrctrl_periph_disable>
   33b8a:	2000      	movs	r0, #0
   33b8c:	e7e4      	b.n	33b58 <am_hal_uart_power_control+0x14>
   33b8e:	2006      	movs	r0, #6
   33b90:	e7e2      	b.n	33b58 <am_hal_uart_power_control+0x14>
   33b92:	b322      	cbz	r2, 33bde <am_hal_uart_power_control+0x9a>
   33b94:	792a      	ldrb	r2, [r5, #4]
   33b96:	bb3a      	cbnz	r2, 33be8 <am_hal_uart_power_control+0xa4>
   33b98:	2007      	movs	r0, #7
   33b9a:	e7dd      	b.n	33b58 <am_hal_uart_power_control+0x14>
   33b9c:	f7ff fde8 	bl	33770 <am_hal_interrupt_master_disable>
   33ba0:	f507 2180 	add.w	r1, r7, #262144	; 0x40000
   33ba4:	311c      	adds	r1, #28
   33ba6:	030f      	lsls	r7, r1, #12
   33ba8:	9001      	str	r0, [sp, #4]
   33baa:	6a3a      	ldr	r2, [r7, #32]
   33bac:	60aa      	str	r2, [r5, #8]
   33bae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   33bb0:	60eb      	str	r3, [r5, #12]
   33bb2:	6abe      	ldr	r6, [r7, #40]	; 0x28
   33bb4:	612e      	str	r6, [r5, #16]
   33bb6:	6af8      	ldr	r0, [r7, #44]	; 0x2c
   33bb8:	6168      	str	r0, [r5, #20]
   33bba:	6b39      	ldr	r1, [r7, #48]	; 0x30
   33bbc:	61a9      	str	r1, [r5, #24]
   33bbe:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   33bc0:	61ea      	str	r2, [r5, #28]
   33bc2:	6bbf      	ldr	r7, [r7, #56]	; 0x38
   33bc4:	622f      	str	r7, [r5, #32]
   33bc6:	2301      	movs	r3, #1
   33bc8:	9801      	ldr	r0, [sp, #4]
   33bca:	712b      	strb	r3, [r5, #4]
   33bcc:	f7ff fdd4 	bl	33778 <am_hal_interrupt_master_set>
   33bd0:	682e      	ldr	r6, [r5, #0]
   33bd2:	f026 407e 	bic.w	r0, r6, #4261412864	; 0xfe000000
   33bd6:	42a0      	cmp	r0, r4
   33bd8:	d1d4      	bne.n	33b84 <am_hal_uart_power_control+0x40>
   33bda:	6a6f      	ldr	r7, [r5, #36]	; 0x24
   33bdc:	e7cb      	b.n	33b76 <am_hal_uart_power_control+0x32>
   33bde:	4640      	mov	r0, r8
   33be0:	f7ff feba 	bl	33958 <am_hal_pwrctrl_periph_enable>
   33be4:	4648      	mov	r0, r9
   33be6:	e7b7      	b.n	33b58 <am_hal_uart_power_control+0x14>
   33be8:	4640      	mov	r0, r8
   33bea:	f7ff feb5 	bl	33958 <am_hal_pwrctrl_periph_enable>
   33bee:	f7ff fdbf 	bl	33770 <am_hal_interrupt_master_disable>
   33bf2:	f507 2380 	add.w	r3, r7, #262144	; 0x40000
   33bf6:	331c      	adds	r3, #28
   33bf8:	031f      	lsls	r7, r3, #12
   33bfa:	68ac      	ldr	r4, [r5, #8]
   33bfc:	9000      	str	r0, [sp, #0]
   33bfe:	623c      	str	r4, [r7, #32]
   33c00:	68e8      	ldr	r0, [r5, #12]
   33c02:	6278      	str	r0, [r7, #36]	; 0x24
   33c04:	6929      	ldr	r1, [r5, #16]
   33c06:	62b9      	str	r1, [r7, #40]	; 0x28
   33c08:	696a      	ldr	r2, [r5, #20]
   33c0a:	62fa      	str	r2, [r7, #44]	; 0x2c
   33c0c:	69ab      	ldr	r3, [r5, #24]
   33c0e:	633b      	str	r3, [r7, #48]	; 0x30
   33c10:	69ec      	ldr	r4, [r5, #28]
   33c12:	637c      	str	r4, [r7, #52]	; 0x34
   33c14:	6a28      	ldr	r0, [r5, #32]
   33c16:	63b8      	str	r0, [r7, #56]	; 0x38
   33c18:	9800      	ldr	r0, [sp, #0]
   33c1a:	712e      	strb	r6, [r5, #4]
   33c1c:	f7ff fdac 	bl	33778 <am_hal_interrupt_master_set>
   33c20:	4630      	mov	r0, r6
   33c22:	e799      	b.n	33b58 <am_hal_uart_power_control+0x14>
   33c24:	01ea9e06 	.word	0x01ea9e06

00033c28 <am_hal_uart_configure>:
   33c28:	6803      	ldr	r3, [r0, #0]
   33c2a:	4a6f      	ldr	r2, [pc, #444]	; (33de8 <am_hal_uart_configure+0x1c0>)
   33c2c:	f023 4c7e 	bic.w	ip, r3, #4261412864	; 0xfe000000
   33c30:	4594      	cmp	ip, r2
   33c32:	d001      	beq.n	33c38 <am_hal_uart_configure+0x10>
   33c34:	2002      	movs	r0, #2
   33c36:	4770      	bx	lr
   33c38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   33c3c:	6a46      	ldr	r6, [r0, #36]	; 0x24
   33c3e:	b084      	sub	sp, #16
   33c40:	460d      	mov	r5, r1
   33c42:	4604      	mov	r4, r0
   33c44:	f7ff fd94 	bl	33770 <am_hal_interrupt_master_disable>
   33c48:	f506 2180 	add.w	r1, r6, #262144	; 0x40000
   33c4c:	311c      	adds	r1, #28
   33c4e:	030f      	lsls	r7, r1, #12
   33c50:	9001      	str	r0, [sp, #4]
   33c52:	6b38      	ldr	r0, [r7, #48]	; 0x30
   33c54:	f040 0208 	orr.w	r2, r0, #8
   33c58:	633a      	str	r2, [r7, #48]	; 0x30
   33c5a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   33c5c:	f043 0610 	orr.w	r6, r3, #16
   33c60:	633e      	str	r6, [r7, #48]	; 0x30
   33c62:	9801      	ldr	r0, [sp, #4]
   33c64:	f7ff fd88 	bl	33778 <am_hal_interrupt_master_set>
   33c68:	f7ff fd82 	bl	33770 <am_hal_interrupt_master_disable>
   33c6c:	9002      	str	r0, [sp, #8]
   33c6e:	6b39      	ldr	r1, [r7, #48]	; 0x30
   33c70:	f421 7040 	bic.w	r0, r1, #768	; 0x300
   33c74:	f020 0201 	bic.w	r2, r0, #1
   33c78:	633a      	str	r2, [r7, #48]	; 0x30
   33c7a:	9802      	ldr	r0, [sp, #8]
   33c7c:	f7ff fd7c 	bl	33778 <am_hal_interrupt_master_set>
   33c80:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   33c82:	f3c3 1802 	ubfx	r8, r3, #4, #3
   33c86:	f108 36ff 	add.w	r6, r8, #4294967295	; 0xffffffff
   33c8a:	2e03      	cmp	r6, #3
   33c8c:	d846      	bhi.n	33d1c <am_hal_uart_configure+0xf4>
   33c8e:	e8df f006 	tbb	[pc, r6]
   33c92:	020e      	.short	0x020e
   33c94:	1114      	.short	0x1114
   33c96:	4955      	ldr	r1, [pc, #340]	; (33dec <am_hal_uart_configure+0x1c4>)
   33c98:	4855      	ldr	r0, [pc, #340]	; (33df0 <am_hal_uart_configure+0x1c8>)
   33c9a:	682a      	ldr	r2, [r5, #0]
   33c9c:	0116      	lsls	r6, r2, #4
   33c9e:	fbb0 f3f6 	udiv	r3, r0, r6
   33ca2:	b96b      	cbnz	r3, 33cc0 <am_hal_uart_configure+0x98>
   33ca4:	4853      	ldr	r0, [pc, #332]	; (33df4 <am_hal_uart_configure+0x1cc>)
   33ca6:	6623      	str	r3, [r4, #96]	; 0x60
   33ca8:	b004      	add	sp, #16
   33caa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   33cae:	4952      	ldr	r1, [pc, #328]	; (33df8 <am_hal_uart_configure+0x1d0>)
   33cb0:	4852      	ldr	r0, [pc, #328]	; (33dfc <am_hal_uart_configure+0x1d4>)
   33cb2:	e7f2      	b.n	33c9a <am_hal_uart_configure+0x72>
   33cb4:	4952      	ldr	r1, [pc, #328]	; (33e00 <am_hal_uart_configure+0x1d8>)
   33cb6:	4853      	ldr	r0, [pc, #332]	; (33e04 <am_hal_uart_configure+0x1dc>)
   33cb8:	e7ef      	b.n	33c9a <am_hal_uart_configure+0x72>
   33cba:	4953      	ldr	r1, [pc, #332]	; (33e08 <am_hal_uart_configure+0x1e0>)
   33cbc:	4853      	ldr	r0, [pc, #332]	; (33e0c <am_hal_uart_configure+0x1e4>)
   33cbe:	e7ec      	b.n	33c9a <am_hal_uart_configure+0x72>
   33cc0:	fbb1 f1f6 	udiv	r1, r1, r6
   33cc4:	eba1 1283 	sub.w	r2, r1, r3, lsl #6
   33cc8:	627b      	str	r3, [r7, #36]	; 0x24
   33cca:	eb02 1603 	add.w	r6, r2, r3, lsl #4
   33cce:	627b      	str	r3, [r7, #36]	; 0x24
   33cd0:	fbb0 f0f6 	udiv	r0, r0, r6
   33cd4:	62ba      	str	r2, [r7, #40]	; 0x28
   33cd6:	6620      	str	r0, [r4, #96]	; 0x60
   33cd8:	6b39      	ldr	r1, [r7, #48]	; 0x30
   33cda:	692b      	ldr	r3, [r5, #16]
   33cdc:	430b      	orrs	r3, r1
   33cde:	633b      	str	r3, [r7, #48]	; 0x30
   33ce0:	696a      	ldr	r2, [r5, #20]
   33ce2:	637a      	str	r2, [r7, #52]	; 0x34
   33ce4:	686e      	ldr	r6, [r5, #4]
   33ce6:	68a8      	ldr	r0, [r5, #8]
   33ce8:	68e9      	ldr	r1, [r5, #12]
   33cea:	4330      	orrs	r0, r6
   33cec:	f040 0310 	orr.w	r3, r0, #16
   33cf0:	430b      	orrs	r3, r1
   33cf2:	62fb      	str	r3, [r7, #44]	; 0x2c
   33cf4:	f7ff fd3c 	bl	33770 <am_hal_interrupt_master_disable>
   33cf8:	9003      	str	r0, [sp, #12]
   33cfa:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   33cfc:	f442 7640 	orr.w	r6, r2, #768	; 0x300
   33d00:	f046 0001 	orr.w	r0, r6, #1
   33d04:	6338      	str	r0, [r7, #48]	; 0x30
   33d06:	9803      	ldr	r0, [sp, #12]
   33d08:	f7ff fd36 	bl	33778 <am_hal_interrupt_master_set>
   33d0c:	6827      	ldr	r7, [r4, #0]
   33d0e:	4936      	ldr	r1, [pc, #216]	; (33de8 <am_hal_uart_configure+0x1c0>)
   33d10:	f027 467e 	bic.w	r6, r7, #4261412864	; 0xfe000000
   33d14:	428e      	cmp	r6, r1
   33d16:	d005      	beq.n	33d24 <am_hal_uart_configure+0xfc>
   33d18:	2000      	movs	r0, #0
   33d1a:	e7c5      	b.n	33ca8 <am_hal_uart_configure+0x80>
   33d1c:	2000      	movs	r0, #0
   33d1e:	6620      	str	r0, [r4, #96]	; 0x60
   33d20:	483b      	ldr	r0, [pc, #236]	; (33e10 <am_hal_uart_configure+0x1e8>)
   33d22:	e7c1      	b.n	33ca8 <am_hal_uart_configure+0x80>
   33d24:	69a9      	ldr	r1, [r5, #24]
   33d26:	6a2f      	ldr	r7, [r5, #32]
   33d28:	f8d5 8024 	ldr.w	r8, [r5, #36]	; 0x24
   33d2c:	b109      	cbz	r1, 33d32 <am_hal_uart_configure+0x10a>
   33d2e:	69eb      	ldr	r3, [r5, #28]
   33d30:	bb43      	cbnz	r3, 33d84 <am_hal_uart_configure+0x15c>
   33d32:	6a65      	ldr	r5, [r4, #36]	; 0x24
   33d34:	f505 2380 	add.w	r3, r5, #262144	; 0x40000
   33d38:	f103 021c 	add.w	r2, r3, #28
   33d3c:	0310      	lsls	r0, r2, #12
   33d3e:	f04f 0e00 	mov.w	lr, #0
   33d42:	f884 e028 	strb.w	lr, [r4, #40]	; 0x28
   33d46:	6b81      	ldr	r1, [r0, #56]	; 0x38
   33d48:	f021 0620 	bic.w	r6, r1, #32
   33d4c:	6386      	str	r6, [r0, #56]	; 0x38
   33d4e:	b1b7      	cbz	r7, 33d7e <am_hal_uart_configure+0x156>
   33d50:	f1b8 0f00 	cmp.w	r8, #0
   33d54:	d12e      	bne.n	33db4 <am_hal_uart_configure+0x18c>
   33d56:	6827      	ldr	r7, [r4, #0]
   33d58:	4d23      	ldr	r5, [pc, #140]	; (33de8 <am_hal_uart_configure+0x1c0>)
   33d5a:	f027 487e 	bic.w	r8, r7, #4261412864	; 0xfe000000
   33d5e:	2300      	movs	r3, #0
   33d60:	45a8      	cmp	r8, r5
   33d62:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
   33d66:	d1d7      	bne.n	33d18 <am_hal_uart_configure+0xf0>
   33d68:	6a64      	ldr	r4, [r4, #36]	; 0x24
   33d6a:	f504 2380 	add.w	r3, r4, #262144	; 0x40000
   33d6e:	331c      	adds	r3, #28
   33d70:	0319      	lsls	r1, r3, #12
   33d72:	2000      	movs	r0, #0
   33d74:	6b8a      	ldr	r2, [r1, #56]	; 0x38
   33d76:	f022 0650 	bic.w	r6, r2, #80	; 0x50
   33d7a:	638e      	str	r6, [r1, #56]	; 0x38
   33d7c:	e794      	b.n	33ca8 <am_hal_uart_configure+0x80>
   33d7e:	f884 7044 	strb.w	r7, [r4, #68]	; 0x44
   33d82:	e7f4      	b.n	33d6e <am_hal_uart_configure+0x146>
   33d84:	2201      	movs	r2, #1
   33d86:	f884 2028 	strb.w	r2, [r4, #40]	; 0x28
   33d8a:	f104 002c 	add.w	r0, r4, #44	; 0x2c
   33d8e:	f000 fcc1 	bl	34714 <am_hal_queue_init>
   33d92:	6825      	ldr	r5, [r4, #0]
   33d94:	f025 4c7e 	bic.w	ip, r5, #4261412864	; 0xfe000000
   33d98:	45b4      	cmp	ip, r6
   33d9a:	d1bd      	bne.n	33d18 <am_hal_uart_configure+0xf0>
   33d9c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   33d9e:	f503 2280 	add.w	r2, r3, #262144	; 0x40000
   33da2:	321c      	adds	r2, #28
   33da4:	0310      	lsls	r0, r2, #12
   33da6:	6b81      	ldr	r1, [r0, #56]	; 0x38
   33da8:	f041 0620 	orr.w	r6, r1, #32
   33dac:	6386      	str	r6, [r0, #56]	; 0x38
   33dae:	2f00      	cmp	r7, #0
   33db0:	d1ce      	bne.n	33d50 <am_hal_uart_configure+0x128>
   33db2:	e7d0      	b.n	33d56 <am_hal_uart_configure+0x12e>
   33db4:	2201      	movs	r2, #1
   33db6:	4639      	mov	r1, r7
   33db8:	f104 0048 	add.w	r0, r4, #72	; 0x48
   33dbc:	4643      	mov	r3, r8
   33dbe:	f884 2044 	strb.w	r2, [r4, #68]	; 0x44
   33dc2:	f000 fca7 	bl	34714 <am_hal_queue_init>
   33dc6:	6820      	ldr	r0, [r4, #0]
   33dc8:	4f07      	ldr	r7, [pc, #28]	; (33de8 <am_hal_uart_configure+0x1c0>)
   33dca:	f020 457e 	bic.w	r5, r0, #4261412864	; 0xfe000000
   33dce:	42bd      	cmp	r5, r7
   33dd0:	d1a2      	bne.n	33d18 <am_hal_uart_configure+0xf0>
   33dd2:	6a63      	ldr	r3, [r4, #36]	; 0x24
   33dd4:	f503 2480 	add.w	r4, r3, #262144	; 0x40000
   33dd8:	341c      	adds	r4, #28
   33dda:	0321      	lsls	r1, r4, #12
   33ddc:	2000      	movs	r0, #0
   33dde:	6b8a      	ldr	r2, [r1, #56]	; 0x38
   33de0:	f042 0650 	orr.w	r6, r2, #80	; 0x50
   33de4:	638e      	str	r6, [r1, #56]	; 0x38
   33de6:	e75f      	b.n	33ca8 <am_hal_uart_configure+0x80>
   33de8:	01ea9e06 	.word	0x01ea9e06
   33dec:	2dc6c000 	.word	0x2dc6c000
   33df0:	00b71b00 	.word	0x00b71b00
   33df4:	08000003 	.word	0x08000003
   33df8:	5b8d8000 	.word	0x5b8d8000
   33dfc:	016e3600 	.word	0x016e3600
   33e00:	0b71b000 	.word	0x0b71b000
   33e04:	002dc6c0 	.word	0x002dc6c0
   33e08:	16e36000 	.word	0x16e36000
   33e0c:	005b8d80 	.word	0x005b8d80
   33e10:	08000002 	.word	0x08000002

00033e14 <am_hal_uart_transfer>:
   33e14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   33e18:	680d      	ldr	r5, [r1, #0]
   33e1a:	b091      	sub	sp, #68	; 0x44
   33e1c:	4683      	mov	fp, r0
   33e1e:	b13d      	cbz	r5, 33e30 <am_hal_uart_transfer+0x1c>
   33e20:	2d01      	cmp	r5, #1
   33e22:	bf18      	it	ne
   33e24:	2507      	movne	r5, #7
   33e26:	d025      	beq.n	33e74 <am_hal_uart_transfer+0x60>
   33e28:	4628      	mov	r0, r5
   33e2a:	b011      	add	sp, #68	; 0x44
   33e2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   33e30:	f8d1 800c 	ldr.w	r8, [r1, #12]
   33e34:	6908      	ldr	r0, [r1, #16]
   33e36:	f8d1 a004 	ldr.w	sl, [r1, #4]
   33e3a:	688e      	ldr	r6, [r1, #8]
   33e3c:	9000      	str	r0, [sp, #0]
   33e3e:	f1b8 0f00 	cmp.w	r8, #0
   33e42:	d035      	beq.n	33eb0 <am_hal_uart_transfer+0x9c>
   33e44:	2e00      	cmp	r6, #0
   33e46:	f000 838b 	beq.w	34560 <am_hal_uart_transfer+0x74c>
   33e4a:	f1bb 0f00 	cmp.w	fp, #0
   33e4e:	f000 8161 	beq.w	34114 <am_hal_uart_transfer+0x300>
   33e52:	f8db 4000 	ldr.w	r4, [fp]
   33e56:	4fb0      	ldr	r7, [pc, #704]	; (34118 <am_hal_uart_transfer+0x304>)
   33e58:	f024 427e 	bic.w	r2, r4, #4261412864	; 0xfe000000
   33e5c:	42ba      	cmp	r2, r7
   33e5e:	f000 815d 	beq.w	3411c <am_hal_uart_transfer+0x308>
   33e62:	462f      	mov	r7, r5
   33e64:	9d00      	ldr	r5, [sp, #0]
   33e66:	b105      	cbz	r5, 33e6a <am_hal_uart_transfer+0x56>
   33e68:	602f      	str	r7, [r5, #0]
   33e6a:	2502      	movs	r5, #2
   33e6c:	4628      	mov	r0, r5
   33e6e:	b011      	add	sp, #68	; 0x44
   33e70:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   33e74:	684b      	ldr	r3, [r1, #4]
   33e76:	68ce      	ldr	r6, [r1, #12]
   33e78:	688d      	ldr	r5, [r1, #8]
   33e7a:	f8d1 8010 	ldr.w	r8, [r1, #16]
   33e7e:	4699      	mov	r9, r3
   33e80:	2e00      	cmp	r6, #0
   33e82:	f000 80c3 	beq.w	3400c <am_hal_uart_transfer+0x1f8>
   33e86:	2d00      	cmp	r5, #0
   33e88:	f000 837f 	beq.w	3458a <am_hal_uart_transfer+0x776>
   33e8c:	2800      	cmp	r0, #0
   33e8e:	f000 824a 	beq.w	34326 <am_hal_uart_transfer+0x512>
   33e92:	6800      	ldr	r0, [r0, #0]
   33e94:	4aa0      	ldr	r2, [pc, #640]	; (34118 <am_hal_uart_transfer+0x304>)
   33e96:	f020 417e 	bic.w	r1, r0, #4261412864	; 0xfe000000
   33e9a:	4291      	cmp	r1, r2
   33e9c:	f000 8246 	beq.w	3432c <am_hal_uart_transfer+0x518>
   33ea0:	2400      	movs	r4, #0
   33ea2:	2502      	movs	r5, #2
   33ea4:	f1b8 0f00 	cmp.w	r8, #0
   33ea8:	d0be      	beq.n	33e28 <am_hal_uart_transfer+0x14>
   33eaa:	f8c8 4000 	str.w	r4, [r8]
   33eae:	e7bb      	b.n	33e28 <am_hal_uart_transfer+0x14>
   33eb0:	f1bb 0f00 	cmp.w	fp, #0
   33eb4:	d0d9      	beq.n	33e6a <am_hal_uart_transfer+0x56>
   33eb6:	f8db 4000 	ldr.w	r4, [fp]
   33eba:	4b97      	ldr	r3, [pc, #604]	; (34118 <am_hal_uart_transfer+0x304>)
   33ebc:	f024 4c7e 	bic.w	ip, r4, #4261412864	; 0xfe000000
   33ec0:	459c      	cmp	ip, r3
   33ec2:	d1d2      	bne.n	33e6a <am_hal_uart_transfer+0x56>
   33ec4:	b108      	cbz	r0, 33eca <am_hal_uart_transfer+0xb6>
   33ec6:	f8c0 8000 	str.w	r8, [r0]
   33eca:	2e00      	cmp	r6, #0
   33ecc:	f000 809c 	beq.w	34008 <am_hal_uart_transfer+0x1f4>
   33ed0:	f89b 0028 	ldrb.w	r0, [fp, #40]	; 0x28
   33ed4:	2800      	cmp	r0, #0
   33ed6:	f040 835d 	bne.w	34594 <am_hal_uart_transfer+0x780>
   33eda:	f8db 2024 	ldr.w	r2, [fp, #36]	; 0x24
   33ede:	f502 2180 	add.w	r1, r2, #262144	; 0x40000
   33ee2:	311c      	adds	r1, #28
   33ee4:	030a      	lsls	r2, r1, #12
   33ee6:	6997      	ldr	r7, [r2, #24]
   33ee8:	f3c7 1140 	ubfx	r1, r7, #5, #1
   33eec:	2900      	cmp	r1, #0
   33eee:	f040 8384 	bne.w	345fa <am_hal_uart_transfer+0x7e6>
   33ef2:	1e75      	subs	r5, r6, #1
   33ef4:	f015 0007 	ands.w	r0, r5, #7
   33ef8:	f10a 34ff 	add.w	r4, sl, #4294967295	; 0xffffffff
   33efc:	d043      	beq.n	33f86 <am_hal_uart_transfer+0x172>
   33efe:	f89a 3000 	ldrb.w	r3, [sl]
   33f02:	6013      	str	r3, [r2, #0]
   33f04:	6997      	ldr	r7, [r2, #24]
   33f06:	06bb      	lsls	r3, r7, #26
   33f08:	4654      	mov	r4, sl
   33f0a:	f04f 0101 	mov.w	r1, #1
   33f0e:	d477      	bmi.n	34000 <am_hal_uart_transfer+0x1ec>
   33f10:	4288      	cmp	r0, r1
   33f12:	d038      	beq.n	33f86 <am_hal_uart_transfer+0x172>
   33f14:	2802      	cmp	r0, #2
   33f16:	d02e      	beq.n	33f76 <am_hal_uart_transfer+0x162>
   33f18:	2803      	cmp	r0, #3
   33f1a:	d024      	beq.n	33f66 <am_hal_uart_transfer+0x152>
   33f1c:	2804      	cmp	r0, #4
   33f1e:	d01a      	beq.n	33f56 <am_hal_uart_transfer+0x142>
   33f20:	2805      	cmp	r0, #5
   33f22:	d010      	beq.n	33f46 <am_hal_uart_transfer+0x132>
   33f24:	2806      	cmp	r0, #6
   33f26:	d006      	beq.n	33f36 <am_hal_uart_transfer+0x122>
   33f28:	f814 5f01 	ldrb.w	r5, [r4, #1]!
   33f2c:	6015      	str	r5, [r2, #0]
   33f2e:	6990      	ldr	r0, [r2, #24]
   33f30:	0687      	lsls	r7, r0, #26
   33f32:	4409      	add	r1, r1
   33f34:	d464      	bmi.n	34000 <am_hal_uart_transfer+0x1ec>
   33f36:	f814 3f01 	ldrb.w	r3, [r4, #1]!
   33f3a:	6013      	str	r3, [r2, #0]
   33f3c:	6997      	ldr	r7, [r2, #24]
   33f3e:	06bd      	lsls	r5, r7, #26
   33f40:	f101 0101 	add.w	r1, r1, #1
   33f44:	d45c      	bmi.n	34000 <am_hal_uart_transfer+0x1ec>
   33f46:	f814 5f01 	ldrb.w	r5, [r4, #1]!
   33f4a:	6015      	str	r5, [r2, #0]
   33f4c:	6990      	ldr	r0, [r2, #24]
   33f4e:	0680      	lsls	r0, r0, #26
   33f50:	f101 0101 	add.w	r1, r1, #1
   33f54:	d454      	bmi.n	34000 <am_hal_uart_transfer+0x1ec>
   33f56:	f814 3f01 	ldrb.w	r3, [r4, #1]!
   33f5a:	6013      	str	r3, [r2, #0]
   33f5c:	6997      	ldr	r7, [r2, #24]
   33f5e:	06bb      	lsls	r3, r7, #26
   33f60:	f101 0101 	add.w	r1, r1, #1
   33f64:	d44c      	bmi.n	34000 <am_hal_uart_transfer+0x1ec>
   33f66:	f814 5f01 	ldrb.w	r5, [r4, #1]!
   33f6a:	6015      	str	r5, [r2, #0]
   33f6c:	6990      	ldr	r0, [r2, #24]
   33f6e:	0687      	lsls	r7, r0, #26
   33f70:	f101 0101 	add.w	r1, r1, #1
   33f74:	d444      	bmi.n	34000 <am_hal_uart_transfer+0x1ec>
   33f76:	f814 3f01 	ldrb.w	r3, [r4, #1]!
   33f7a:	6013      	str	r3, [r2, #0]
   33f7c:	6997      	ldr	r7, [r2, #24]
   33f7e:	06bd      	lsls	r5, r7, #26
   33f80:	f101 0101 	add.w	r1, r1, #1
   33f84:	d43c      	bmi.n	34000 <am_hal_uart_transfer+0x1ec>
   33f86:	3101      	adds	r1, #1
   33f88:	7865      	ldrb	r5, [r4, #1]
   33f8a:	6015      	str	r5, [r2, #0]
   33f8c:	428e      	cmp	r6, r1
   33f8e:	460b      	mov	r3, r1
   33f90:	f104 0001 	add.w	r0, r4, #1
   33f94:	d035      	beq.n	34002 <am_hal_uart_transfer+0x1ee>
   33f96:	6997      	ldr	r7, [r2, #24]
   33f98:	06bd      	lsls	r5, r7, #26
   33f9a:	d431      	bmi.n	34000 <am_hal_uart_transfer+0x1ec>
   33f9c:	7845      	ldrb	r5, [r0, #1]
   33f9e:	6015      	str	r5, [r2, #0]
   33fa0:	6990      	ldr	r0, [r2, #24]
   33fa2:	0680      	lsls	r0, r0, #26
   33fa4:	f101 0101 	add.w	r1, r1, #1
   33fa8:	d42a      	bmi.n	34000 <am_hal_uart_transfer+0x1ec>
   33faa:	78e1      	ldrb	r1, [r4, #3]
   33fac:	6011      	str	r1, [r2, #0]
   33fae:	6997      	ldr	r7, [r2, #24]
   33fb0:	06bf      	lsls	r7, r7, #26
   33fb2:	f103 0102 	add.w	r1, r3, #2
   33fb6:	d423      	bmi.n	34000 <am_hal_uart_transfer+0x1ec>
   33fb8:	7925      	ldrb	r5, [r4, #4]
   33fba:	6015      	str	r5, [r2, #0]
   33fbc:	6990      	ldr	r0, [r2, #24]
   33fbe:	0685      	lsls	r5, r0, #26
   33fc0:	f103 0103 	add.w	r1, r3, #3
   33fc4:	d41c      	bmi.n	34000 <am_hal_uart_transfer+0x1ec>
   33fc6:	7961      	ldrb	r1, [r4, #5]
   33fc8:	6011      	str	r1, [r2, #0]
   33fca:	6997      	ldr	r7, [r2, #24]
   33fcc:	06b8      	lsls	r0, r7, #26
   33fce:	f103 0104 	add.w	r1, r3, #4
   33fd2:	d415      	bmi.n	34000 <am_hal_uart_transfer+0x1ec>
   33fd4:	79a5      	ldrb	r5, [r4, #6]
   33fd6:	6015      	str	r5, [r2, #0]
   33fd8:	6990      	ldr	r0, [r2, #24]
   33fda:	0687      	lsls	r7, r0, #26
   33fdc:	f103 0105 	add.w	r1, r3, #5
   33fe0:	d40e      	bmi.n	34000 <am_hal_uart_transfer+0x1ec>
   33fe2:	79e1      	ldrb	r1, [r4, #7]
   33fe4:	6011      	str	r1, [r2, #0]
   33fe6:	6997      	ldr	r7, [r2, #24]
   33fe8:	06bd      	lsls	r5, r7, #26
   33fea:	f103 0106 	add.w	r1, r3, #6
   33fee:	d407      	bmi.n	34000 <am_hal_uart_transfer+0x1ec>
   33ff0:	f814 5f08 	ldrb.w	r5, [r4, #8]!
   33ff4:	6015      	str	r5, [r2, #0]
   33ff6:	6990      	ldr	r0, [r2, #24]
   33ff8:	0680      	lsls	r0, r0, #26
   33ffa:	f103 0107 	add.w	r1, r3, #7
   33ffe:	d5c2      	bpl.n	33f86 <am_hal_uart_transfer+0x172>
   34000:	460e      	mov	r6, r1
   34002:	9800      	ldr	r0, [sp, #0]
   34004:	b100      	cbz	r0, 34008 <am_hal_uart_transfer+0x1f4>
   34006:	6006      	str	r6, [r0, #0]
   34008:	2500      	movs	r5, #0
   3400a:	e70d      	b.n	33e28 <am_hal_uart_transfer+0x14>
   3400c:	2800      	cmp	r0, #0
   3400e:	f43f af2c 	beq.w	33e6a <am_hal_uart_transfer+0x56>
   34012:	6804      	ldr	r4, [r0, #0]
   34014:	4f40      	ldr	r7, [pc, #256]	; (34118 <am_hal_uart_transfer+0x304>)
   34016:	f024 4c7e 	bic.w	ip, r4, #4261412864	; 0xfe000000
   3401a:	45bc      	cmp	ip, r7
   3401c:	f47f af25 	bne.w	33e6a <am_hal_uart_transfer+0x56>
   34020:	f1b8 0f00 	cmp.w	r8, #0
   34024:	d001      	beq.n	3402a <am_hal_uart_transfer+0x216>
   34026:	f8c8 6000 	str.w	r6, [r8]
   3402a:	2d00      	cmp	r5, #0
   3402c:	d0ec      	beq.n	34008 <am_hal_uart_transfer+0x1f4>
   3402e:	f89b 4044 	ldrb.w	r4, [fp, #68]	; 0x44
   34032:	2c00      	cmp	r4, #0
   34034:	f040 82e3 	bne.w	345fe <am_hal_uart_transfer+0x7ea>
   34038:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
   3403c:	f503 2680 	add.w	r6, r3, #262144	; 0x40000
   34040:	361c      	adds	r6, #28
   34042:	0331      	lsls	r1, r6, #12
   34044:	6988      	ldr	r0, [r1, #24]
   34046:	f3c0 1200 	ubfx	r2, r0, #4, #1
   3404a:	2a00      	cmp	r2, #0
   3404c:	f040 835d 	bne.w	3470a <am_hal_uart_transfer+0x8f6>
   34050:	680b      	ldr	r3, [r1, #0]
   34052:	f413 6470 	ands.w	r4, r3, #3840	; 0xf00
   34056:	f040 8353 	bne.w	34700 <am_hal_uart_transfer+0x8ec>
   3405a:	1e6f      	subs	r7, r5, #1
   3405c:	f017 0603 	ands.w	r6, r7, #3
   34060:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
   34064:	d028      	beq.n	340b8 <am_hal_uart_transfer+0x2a4>
   34066:	f889 3000 	strb.w	r3, [r9]
   3406a:	698b      	ldr	r3, [r1, #24]
   3406c:	06db      	lsls	r3, r3, #27
   3406e:	4648      	mov	r0, r9
   34070:	f04f 0401 	mov.w	r4, #1
   34074:	d44c      	bmi.n	34110 <am_hal_uart_transfer+0x2fc>
   34076:	680b      	ldr	r3, [r1, #0]
   34078:	f413 6f70 	tst.w	r3, #3840	; 0xf00
   3407c:	f040 8287 	bne.w	3458e <am_hal_uart_transfer+0x77a>
   34080:	42a6      	cmp	r6, r4
   34082:	d019      	beq.n	340b8 <am_hal_uart_transfer+0x2a4>
   34084:	2e02      	cmp	r6, #2
   34086:	d00b      	beq.n	340a0 <am_hal_uart_transfer+0x28c>
   34088:	f800 3f01 	strb.w	r3, [r0, #1]!
   3408c:	698a      	ldr	r2, [r1, #24]
   3408e:	06d7      	lsls	r7, r2, #27
   34090:	f04f 0402 	mov.w	r4, #2
   34094:	d43c      	bmi.n	34110 <am_hal_uart_transfer+0x2fc>
   34096:	680b      	ldr	r3, [r1, #0]
   34098:	f413 6f70 	tst.w	r3, #3840	; 0xf00
   3409c:	f040 8277 	bne.w	3458e <am_hal_uart_transfer+0x77a>
   340a0:	f800 3f01 	strb.w	r3, [r0, #1]!
   340a4:	698f      	ldr	r7, [r1, #24]
   340a6:	06fe      	lsls	r6, r7, #27
   340a8:	f104 0401 	add.w	r4, r4, #1
   340ac:	d430      	bmi.n	34110 <am_hal_uart_transfer+0x2fc>
   340ae:	680b      	ldr	r3, [r1, #0]
   340b0:	f413 6f70 	tst.w	r3, #3840	; 0xf00
   340b4:	f040 826b 	bne.w	3458e <am_hal_uart_transfer+0x77a>
   340b8:	3401      	adds	r4, #1
   340ba:	42a5      	cmp	r5, r4
   340bc:	7043      	strb	r3, [r0, #1]
   340be:	f100 0601 	add.w	r6, r0, #1
   340c2:	4623      	mov	r3, r4
   340c4:	d024      	beq.n	34110 <am_hal_uart_transfer+0x2fc>
   340c6:	698a      	ldr	r2, [r1, #24]
   340c8:	06d7      	lsls	r7, r2, #27
   340ca:	d421      	bmi.n	34110 <am_hal_uart_transfer+0x2fc>
   340cc:	680f      	ldr	r7, [r1, #0]
   340ce:	f417 6f70 	tst.w	r7, #3840	; 0xf00
   340d2:	f040 825c 	bne.w	3458e <am_hal_uart_transfer+0x77a>
   340d6:	7077      	strb	r7, [r6, #1]
   340d8:	698e      	ldr	r6, [r1, #24]
   340da:	06f2      	lsls	r2, r6, #27
   340dc:	f104 0401 	add.w	r4, r4, #1
   340e0:	d416      	bmi.n	34110 <am_hal_uart_transfer+0x2fc>
   340e2:	680a      	ldr	r2, [r1, #0]
   340e4:	f412 6f70 	tst.w	r2, #3840	; 0xf00
   340e8:	f040 8251 	bne.w	3458e <am_hal_uart_transfer+0x77a>
   340ec:	70c2      	strb	r2, [r0, #3]
   340ee:	698f      	ldr	r7, [r1, #24]
   340f0:	06ff      	lsls	r7, r7, #27
   340f2:	f103 0402 	add.w	r4, r3, #2
   340f6:	d40b      	bmi.n	34110 <am_hal_uart_transfer+0x2fc>
   340f8:	680e      	ldr	r6, [r1, #0]
   340fa:	f416 6f70 	tst.w	r6, #3840	; 0xf00
   340fe:	f040 8246 	bne.w	3458e <am_hal_uart_transfer+0x77a>
   34102:	f800 6f04 	strb.w	r6, [r0, #4]!
   34106:	698a      	ldr	r2, [r1, #24]
   34108:	06d6      	lsls	r6, r2, #27
   3410a:	f103 0403 	add.w	r4, r3, #3
   3410e:	d5ce      	bpl.n	340ae <am_hal_uart_transfer+0x29a>
   34110:	2500      	movs	r5, #0
   34112:	e6c7      	b.n	33ea4 <am_hal_uart_transfer+0x90>
   34114:	465f      	mov	r7, fp
   34116:	e6a5      	b.n	33e64 <am_hal_uart_transfer+0x50>
   34118:	01ea9e06 	.word	0x01ea9e06
   3411c:	9201      	str	r2, [sp, #4]
   3411e:	4651      	mov	r1, sl
   34120:	46a9      	mov	r9, r5
   34122:	462f      	mov	r7, r5
   34124:	f89b 3028 	ldrb.w	r3, [fp, #40]	; 0x28
   34128:	2b00      	cmp	r3, #0
   3412a:	f040 80c5 	bne.w	342b8 <am_hal_uart_transfer+0x4a4>
   3412e:	f8db 0024 	ldr.w	r0, [fp, #36]	; 0x24
   34132:	2e00      	cmp	r6, #0
   34134:	f000 80a0 	beq.w	34278 <am_hal_uart_transfer+0x464>
   34138:	f500 2480 	add.w	r4, r0, #262144	; 0x40000
   3413c:	341c      	adds	r4, #28
   3413e:	0322      	lsls	r2, r4, #12
   34140:	6993      	ldr	r3, [r2, #24]
   34142:	f3c3 1440 	ubfx	r4, r3, #5, #1
   34146:	2c00      	cmp	r4, #0
   34148:	f040 809f 	bne.w	3428a <am_hal_uart_transfer+0x476>
   3414c:	1e73      	subs	r3, r6, #1
   3414e:	f013 0e07 	ands.w	lr, r3, #7
   34152:	f101 3cff 	add.w	ip, r1, #4294967295	; 0xffffffff
   34156:	d048      	beq.n	341ea <am_hal_uart_transfer+0x3d6>
   34158:	7808      	ldrb	r0, [r1, #0]
   3415a:	6010      	str	r0, [r2, #0]
   3415c:	6993      	ldr	r3, [r2, #24]
   3415e:	069b      	lsls	r3, r3, #26
   34160:	468c      	mov	ip, r1
   34162:	f04f 0401 	mov.w	r4, #1
   34166:	f100 8084 	bmi.w	34272 <am_hal_uart_transfer+0x45e>
   3416a:	45a6      	cmp	lr, r4
   3416c:	d03d      	beq.n	341ea <am_hal_uart_transfer+0x3d6>
   3416e:	f1be 0f02 	cmp.w	lr, #2
   34172:	d032      	beq.n	341da <am_hal_uart_transfer+0x3c6>
   34174:	f1be 0f03 	cmp.w	lr, #3
   34178:	d027      	beq.n	341ca <am_hal_uart_transfer+0x3b6>
   3417a:	f1be 0f04 	cmp.w	lr, #4
   3417e:	d01c      	beq.n	341ba <am_hal_uart_transfer+0x3a6>
   34180:	f1be 0f05 	cmp.w	lr, #5
   34184:	d011      	beq.n	341aa <am_hal_uart_transfer+0x396>
   34186:	f1be 0f06 	cmp.w	lr, #6
   3418a:	d006      	beq.n	3419a <am_hal_uart_transfer+0x386>
   3418c:	f81c 1f01 	ldrb.w	r1, [ip, #1]!
   34190:	6011      	str	r1, [r2, #0]
   34192:	6990      	ldr	r0, [r2, #24]
   34194:	0681      	lsls	r1, r0, #26
   34196:	4424      	add	r4, r4
   34198:	d46b      	bmi.n	34272 <am_hal_uart_transfer+0x45e>
   3419a:	f81c 3f01 	ldrb.w	r3, [ip, #1]!
   3419e:	6013      	str	r3, [r2, #0]
   341a0:	6991      	ldr	r1, [r2, #24]
   341a2:	068b      	lsls	r3, r1, #26
   341a4:	f104 0401 	add.w	r4, r4, #1
   341a8:	d463      	bmi.n	34272 <am_hal_uart_transfer+0x45e>
   341aa:	f81c 0f01 	ldrb.w	r0, [ip, #1]!
   341ae:	6010      	str	r0, [r2, #0]
   341b0:	6993      	ldr	r3, [r2, #24]
   341b2:	0699      	lsls	r1, r3, #26
   341b4:	f104 0401 	add.w	r4, r4, #1
   341b8:	d45b      	bmi.n	34272 <am_hal_uart_transfer+0x45e>
   341ba:	f81c 1f01 	ldrb.w	r1, [ip, #1]!
   341be:	6011      	str	r1, [r2, #0]
   341c0:	6990      	ldr	r0, [r2, #24]
   341c2:	0683      	lsls	r3, r0, #26
   341c4:	f104 0401 	add.w	r4, r4, #1
   341c8:	d453      	bmi.n	34272 <am_hal_uart_transfer+0x45e>
   341ca:	f81c 3f01 	ldrb.w	r3, [ip, #1]!
   341ce:	6013      	str	r3, [r2, #0]
   341d0:	6991      	ldr	r1, [r2, #24]
   341d2:	0689      	lsls	r1, r1, #26
   341d4:	f104 0401 	add.w	r4, r4, #1
   341d8:	d44b      	bmi.n	34272 <am_hal_uart_transfer+0x45e>
   341da:	f81c 0f01 	ldrb.w	r0, [ip, #1]!
   341de:	6010      	str	r0, [r2, #0]
   341e0:	6993      	ldr	r3, [r2, #24]
   341e2:	069b      	lsls	r3, r3, #26
   341e4:	f104 0401 	add.w	r4, r4, #1
   341e8:	d443      	bmi.n	34272 <am_hal_uart_transfer+0x45e>
   341ea:	3401      	adds	r4, #1
   341ec:	f89c 1001 	ldrb.w	r1, [ip, #1]
   341f0:	6011      	str	r1, [r2, #0]
   341f2:	42b4      	cmp	r4, r6
   341f4:	4620      	mov	r0, r4
   341f6:	f10c 0e01 	add.w	lr, ip, #1
   341fa:	d05b      	beq.n	342b4 <am_hal_uart_transfer+0x4a0>
   341fc:	6993      	ldr	r3, [r2, #24]
   341fe:	0699      	lsls	r1, r3, #26
   34200:	d437      	bmi.n	34272 <am_hal_uart_transfer+0x45e>
   34202:	f89e 1001 	ldrb.w	r1, [lr, #1]
   34206:	6011      	str	r1, [r2, #0]
   34208:	6993      	ldr	r3, [r2, #24]
   3420a:	0699      	lsls	r1, r3, #26
   3420c:	f104 0401 	add.w	r4, r4, #1
   34210:	d42f      	bmi.n	34272 <am_hal_uart_transfer+0x45e>
   34212:	f89c 4003 	ldrb.w	r4, [ip, #3]
   34216:	6014      	str	r4, [r2, #0]
   34218:	6991      	ldr	r1, [r2, #24]
   3421a:	0689      	lsls	r1, r1, #26
   3421c:	f100 0402 	add.w	r4, r0, #2
   34220:	d427      	bmi.n	34272 <am_hal_uart_transfer+0x45e>
   34222:	f89c 3004 	ldrb.w	r3, [ip, #4]
   34226:	6013      	str	r3, [r2, #0]
   34228:	6991      	ldr	r1, [r2, #24]
   3422a:	0689      	lsls	r1, r1, #26
   3422c:	f100 0403 	add.w	r4, r0, #3
   34230:	d41f      	bmi.n	34272 <am_hal_uart_transfer+0x45e>
   34232:	f89c 4005 	ldrb.w	r4, [ip, #5]
   34236:	6014      	str	r4, [r2, #0]
   34238:	6993      	ldr	r3, [r2, #24]
   3423a:	0699      	lsls	r1, r3, #26
   3423c:	f100 0404 	add.w	r4, r0, #4
   34240:	d417      	bmi.n	34272 <am_hal_uart_transfer+0x45e>
   34242:	f89c 1006 	ldrb.w	r1, [ip, #6]
   34246:	6011      	str	r1, [r2, #0]
   34248:	6993      	ldr	r3, [r2, #24]
   3424a:	0699      	lsls	r1, r3, #26
   3424c:	f100 0405 	add.w	r4, r0, #5
   34250:	d40f      	bmi.n	34272 <am_hal_uart_transfer+0x45e>
   34252:	f89c 4007 	ldrb.w	r4, [ip, #7]
   34256:	6014      	str	r4, [r2, #0]
   34258:	6991      	ldr	r1, [r2, #24]
   3425a:	0689      	lsls	r1, r1, #26
   3425c:	f100 0406 	add.w	r4, r0, #6
   34260:	d407      	bmi.n	34272 <am_hal_uart_transfer+0x45e>
   34262:	f81c 3f08 	ldrb.w	r3, [ip, #8]!
   34266:	6013      	str	r3, [r2, #0]
   34268:	6991      	ldr	r1, [r2, #24]
   3426a:	068b      	lsls	r3, r1, #26
   3426c:	f100 0407 	add.w	r4, r0, #7
   34270:	d5bb      	bpl.n	341ea <am_hal_uart_transfer+0x3d6>
   34272:	1b36      	subs	r6, r6, r4
   34274:	4427      	add	r7, r4
   34276:	d108      	bne.n	3428a <am_hal_uart_transfer+0x476>
   34278:	9c00      	ldr	r4, [sp, #0]
   3427a:	2c00      	cmp	r4, #0
   3427c:	f43f aec4 	beq.w	34008 <am_hal_uart_transfer+0x1f4>
   34280:	4628      	mov	r0, r5
   34282:	6027      	str	r7, [r4, #0]
   34284:	b011      	add	sp, #68	; 0x44
   34286:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   3428a:	2001      	movs	r0, #1
   3428c:	f7ff f93a 	bl	33504 <am_hal_flash_delay>
   34290:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
   34294:	d001      	beq.n	3429a <am_hal_uart_transfer+0x486>
   34296:	f109 0901 	add.w	r9, r9, #1
   3429a:	45c8      	cmp	r8, r9
   3429c:	d9ec      	bls.n	34278 <am_hal_uart_transfer+0x464>
   3429e:	f8db 0000 	ldr.w	r0, [fp]
   342a2:	9a01      	ldr	r2, [sp, #4]
   342a4:	f020 4e7e 	bic.w	lr, r0, #4261412864	; 0xfe000000
   342a8:	4596      	cmp	lr, r2
   342aa:	eb0a 0107 	add.w	r1, sl, r7
   342ae:	f47f add9 	bne.w	33e64 <am_hal_uart_transfer+0x50>
   342b2:	e737      	b.n	34124 <am_hal_uart_transfer+0x310>
   342b4:	4427      	add	r7, r4
   342b6:	e7df      	b.n	34278 <am_hal_uart_transfer+0x464>
   342b8:	f8db 2038 	ldr.w	r2, [fp, #56]	; 0x38
   342bc:	f8db 0034 	ldr.w	r0, [fp, #52]	; 0x34
   342c0:	1a14      	subs	r4, r2, r0
   342c2:	42b4      	cmp	r4, r6
   342c4:	f10b 032c 	add.w	r3, fp, #44	; 0x2c
   342c8:	bf28      	it	cs
   342ca:	4634      	movcs	r4, r6
   342cc:	4622      	mov	r2, r4
   342ce:	4618      	mov	r0, r3
   342d0:	9302      	str	r3, [sp, #8]
   342d2:	f000 fa2b 	bl	3472c <am_hal_queue_item_add>
   342d6:	f8db 1024 	ldr.w	r1, [fp, #36]	; 0x24
   342da:	9103      	str	r1, [sp, #12]
   342dc:	f7ff fa48 	bl	33770 <am_hal_interrupt_master_disable>
   342e0:	9a03      	ldr	r2, [sp, #12]
   342e2:	9008      	str	r0, [sp, #32]
   342e4:	f502 2380 	add.w	r3, r2, #262144	; 0x40000
   342e8:	331c      	adds	r3, #28
   342ea:	0319      	lsls	r1, r3, #12
   342ec:	9103      	str	r1, [sp, #12]
   342ee:	e00e      	b.n	3430e <am_hal_uart_transfer+0x4fa>
   342f0:	f000 fb1e 	bl	34930 <am_hal_queue_item_get>
   342f4:	b198      	cbz	r0, 3431e <am_hal_uart_transfer+0x50a>
   342f6:	f8db 1024 	ldr.w	r1, [fp, #36]	; 0x24
   342fa:	f501 2380 	add.w	r3, r1, #262144	; 0x40000
   342fe:	331c      	adds	r3, #28
   34300:	0318      	lsls	r0, r3, #12
   34302:	6982      	ldr	r2, [r0, #24]
   34304:	0691      	lsls	r1, r2, #26
   34306:	bf5c      	itt	pl
   34308:	f89d 101c 	ldrbpl.w	r1, [sp, #28]
   3430c:	6001      	strpl	r1, [r0, #0]
   3430e:	9b03      	ldr	r3, [sp, #12]
   34310:	9802      	ldr	r0, [sp, #8]
   34312:	699b      	ldr	r3, [r3, #24]
   34314:	069b      	lsls	r3, r3, #26
   34316:	f04f 0201 	mov.w	r2, #1
   3431a:	a907      	add	r1, sp, #28
   3431c:	d5e8      	bpl.n	342f0 <am_hal_uart_transfer+0x4dc>
   3431e:	9808      	ldr	r0, [sp, #32]
   34320:	f7ff fa2a 	bl	33778 <am_hal_interrupt_master_set>
   34324:	e7a5      	b.n	34272 <am_hal_uart_transfer+0x45e>
   34326:	4604      	mov	r4, r0
   34328:	2502      	movs	r5, #2
   3432a:	e5bb      	b.n	33ea4 <am_hal_uart_transfer+0x90>
   3432c:	2700      	movs	r7, #0
   3432e:	469a      	mov	sl, r3
   34330:	f10b 0348 	add.w	r3, fp, #72	; 0x48
   34334:	9100      	str	r1, [sp, #0]
   34336:	463c      	mov	r4, r7
   34338:	9302      	str	r3, [sp, #8]
   3433a:	f89b 0044 	ldrb.w	r0, [fp, #68]	; 0x44
   3433e:	2800      	cmp	r0, #0
   34340:	f040 808e 	bne.w	34460 <am_hal_uart_transfer+0x64c>
   34344:	f8db 2024 	ldr.w	r2, [fp, #36]	; 0x24
   34348:	2d00      	cmp	r5, #0
   3434a:	d06d      	beq.n	34428 <am_hal_uart_transfer+0x614>
   3434c:	f502 2180 	add.w	r1, r2, #262144	; 0x40000
   34350:	311c      	adds	r1, #28
   34352:	030a      	lsls	r2, r1, #12
   34354:	6993      	ldr	r3, [r2, #24]
   34356:	06d8      	lsls	r0, r3, #27
   34358:	d46e      	bmi.n	34438 <am_hal_uart_transfer+0x624>
   3435a:	6811      	ldr	r1, [r2, #0]
   3435c:	f411 6370 	ands.w	r3, r1, #3840	; 0xf00
   34360:	f040 8115 	bne.w	3458e <am_hal_uart_transfer+0x77a>
   34364:	f105 3eff 	add.w	lr, r5, #4294967295	; 0xffffffff
   34368:	f01e 0e03 	ands.w	lr, lr, #3
   3436c:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
   34370:	d029      	beq.n	343c6 <am_hal_uart_transfer+0x5b2>
   34372:	f889 1000 	strb.w	r1, [r9]
   34376:	6991      	ldr	r1, [r2, #24]
   34378:	06c9      	lsls	r1, r1, #27
   3437a:	4648      	mov	r0, r9
   3437c:	f04f 0301 	mov.w	r3, #1
   34380:	d44f      	bmi.n	34422 <am_hal_uart_transfer+0x60e>
   34382:	6811      	ldr	r1, [r2, #0]
   34384:	f411 6f70 	tst.w	r1, #3840	; 0xf00
   34388:	f040 80e4 	bne.w	34554 <am_hal_uart_transfer+0x740>
   3438c:	459e      	cmp	lr, r3
   3438e:	d01a      	beq.n	343c6 <am_hal_uart_transfer+0x5b2>
   34390:	f1be 0f02 	cmp.w	lr, #2
   34394:	d00b      	beq.n	343ae <am_hal_uart_transfer+0x59a>
   34396:	f800 1f01 	strb.w	r1, [r0, #1]!
   3439a:	6991      	ldr	r1, [r2, #24]
   3439c:	06c9      	lsls	r1, r1, #27
   3439e:	f04f 0302 	mov.w	r3, #2
   343a2:	d43e      	bmi.n	34422 <am_hal_uart_transfer+0x60e>
   343a4:	6811      	ldr	r1, [r2, #0]
   343a6:	f411 6f70 	tst.w	r1, #3840	; 0xf00
   343aa:	f040 80d3 	bne.w	34554 <am_hal_uart_transfer+0x740>
   343ae:	f800 1f01 	strb.w	r1, [r0, #1]!
   343b2:	6991      	ldr	r1, [r2, #24]
   343b4:	06c9      	lsls	r1, r1, #27
   343b6:	f103 0301 	add.w	r3, r3, #1
   343ba:	d432      	bmi.n	34422 <am_hal_uart_transfer+0x60e>
   343bc:	6811      	ldr	r1, [r2, #0]
   343be:	f411 6f70 	tst.w	r1, #3840	; 0xf00
   343c2:	f040 80c7 	bne.w	34554 <am_hal_uart_transfer+0x740>
   343c6:	3301      	adds	r3, #1
   343c8:	42ab      	cmp	r3, r5
   343ca:	7041      	strb	r1, [r0, #1]
   343cc:	469e      	mov	lr, r3
   343ce:	f100 0c01 	add.w	ip, r0, #1
   343d2:	f000 80c3 	beq.w	3455c <am_hal_uart_transfer+0x748>
   343d6:	6991      	ldr	r1, [r2, #24]
   343d8:	06c9      	lsls	r1, r1, #27
   343da:	d422      	bmi.n	34422 <am_hal_uart_transfer+0x60e>
   343dc:	6811      	ldr	r1, [r2, #0]
   343de:	f411 6f70 	tst.w	r1, #3840	; 0xf00
   343e2:	f040 80b7 	bne.w	34554 <am_hal_uart_transfer+0x740>
   343e6:	f88c 1001 	strb.w	r1, [ip, #1]
   343ea:	6991      	ldr	r1, [r2, #24]
   343ec:	06c9      	lsls	r1, r1, #27
   343ee:	f103 0301 	add.w	r3, r3, #1
   343f2:	d416      	bmi.n	34422 <am_hal_uart_transfer+0x60e>
   343f4:	6811      	ldr	r1, [r2, #0]
   343f6:	f411 6f70 	tst.w	r1, #3840	; 0xf00
   343fa:	f040 80ab 	bne.w	34554 <am_hal_uart_transfer+0x740>
   343fe:	70c1      	strb	r1, [r0, #3]
   34400:	6991      	ldr	r1, [r2, #24]
   34402:	06c9      	lsls	r1, r1, #27
   34404:	f10e 0302 	add.w	r3, lr, #2
   34408:	d40b      	bmi.n	34422 <am_hal_uart_transfer+0x60e>
   3440a:	6811      	ldr	r1, [r2, #0]
   3440c:	f411 6f70 	tst.w	r1, #3840	; 0xf00
   34410:	f040 80a0 	bne.w	34554 <am_hal_uart_transfer+0x740>
   34414:	f800 1f04 	strb.w	r1, [r0, #4]!
   34418:	6991      	ldr	r1, [r2, #24]
   3441a:	06c9      	lsls	r1, r1, #27
   3441c:	f10e 0303 	add.w	r3, lr, #3
   34420:	d5cc      	bpl.n	343bc <am_hal_uart_transfer+0x5a8>
   34422:	1aed      	subs	r5, r5, r3
   34424:	441c      	add	r4, r3
   34426:	d107      	bne.n	34438 <am_hal_uart_transfer+0x624>
   34428:	f1b8 0f00 	cmp.w	r8, #0
   3442c:	f43f adec 	beq.w	34008 <am_hal_uart_transfer+0x1f4>
   34430:	f8c8 4000 	str.w	r4, [r8]
   34434:	2500      	movs	r5, #0
   34436:	e4f7      	b.n	33e28 <am_hal_uart_transfer+0x14>
   34438:	2001      	movs	r0, #1
   3443a:	f7ff f863 	bl	33504 <am_hal_flash_delay>
   3443e:	1c72      	adds	r2, r6, #1
   34440:	d000      	beq.n	34444 <am_hal_uart_transfer+0x630>
   34442:	3701      	adds	r7, #1
   34444:	42be      	cmp	r6, r7
   34446:	d9ef      	bls.n	34428 <am_hal_uart_transfer+0x614>
   34448:	f8db 0000 	ldr.w	r0, [fp]
   3444c:	9a00      	ldr	r2, [sp, #0]
   3444e:	f020 417e 	bic.w	r1, r0, #4261412864	; 0xfe000000
   34452:	4291      	cmp	r1, r2
   34454:	eb0a 0904 	add.w	r9, sl, r4
   34458:	f43f af6f 	beq.w	3433a <am_hal_uart_transfer+0x526>
   3445c:	2502      	movs	r5, #2
   3445e:	e521      	b.n	33ea4 <am_hal_uart_transfer+0x90>
   34460:	f7ff f986 	bl	33770 <am_hal_interrupt_master_disable>
   34464:	f8db 2024 	ldr.w	r2, [fp, #36]	; 0x24
   34468:	9007      	str	r0, [sp, #28]
   3446a:	f502 2080 	add.w	r0, r2, #262144	; 0x40000
   3446e:	301c      	adds	r0, #28
   34470:	f8cd a004 	str.w	sl, [sp, #4]
   34474:	0303      	lsls	r3, r0, #12
   34476:	f10d 0c20 	add.w	ip, sp, #32
   3447a:	2200      	movs	r2, #0
   3447c:	46aa      	mov	sl, r5
   3447e:	6999      	ldr	r1, [r3, #24]
   34480:	06c9      	lsls	r1, r1, #27
   34482:	d45a      	bmi.n	3453a <am_hal_uart_transfer+0x726>
   34484:	681d      	ldr	r5, [r3, #0]
   34486:	f415 6f70 	tst.w	r5, #3840	; 0xf00
   3448a:	d17b      	bne.n	34584 <am_hal_uart_transfer+0x770>
   3448c:	46e6      	mov	lr, ip
   3448e:	3201      	adds	r2, #1
   34490:	f80e 5b01 	strb.w	r5, [lr], #1
   34494:	6999      	ldr	r1, [r3, #24]
   34496:	06cd      	lsls	r5, r1, #27
   34498:	4610      	mov	r0, r2
   3449a:	d44e      	bmi.n	3453a <am_hal_uart_transfer+0x726>
   3449c:	681d      	ldr	r5, [r3, #0]
   3449e:	f415 6f70 	tst.w	r5, #3840	; 0xf00
   344a2:	d16f      	bne.n	34584 <am_hal_uart_transfer+0x770>
   344a4:	f88e 5000 	strb.w	r5, [lr]
   344a8:	6999      	ldr	r1, [r3, #24]
   344aa:	06cd      	lsls	r5, r1, #27
   344ac:	f102 0201 	add.w	r2, r2, #1
   344b0:	d443      	bmi.n	3453a <am_hal_uart_transfer+0x726>
   344b2:	681a      	ldr	r2, [r3, #0]
   344b4:	f412 6f70 	tst.w	r2, #3840	; 0xf00
   344b8:	d164      	bne.n	34584 <am_hal_uart_transfer+0x770>
   344ba:	f88e 2001 	strb.w	r2, [lr, #1]
   344be:	699d      	ldr	r5, [r3, #24]
   344c0:	06ed      	lsls	r5, r5, #27
   344c2:	f100 0202 	add.w	r2, r0, #2
   344c6:	d438      	bmi.n	3453a <am_hal_uart_transfer+0x726>
   344c8:	6819      	ldr	r1, [r3, #0]
   344ca:	f411 6f70 	tst.w	r1, #3840	; 0xf00
   344ce:	d159      	bne.n	34584 <am_hal_uart_transfer+0x770>
   344d0:	f88c 1003 	strb.w	r1, [ip, #3]
   344d4:	699d      	ldr	r5, [r3, #24]
   344d6:	06ed      	lsls	r5, r5, #27
   344d8:	f10c 0c04 	add.w	ip, ip, #4
   344dc:	f100 0203 	add.w	r2, r0, #3
   344e0:	d42b      	bmi.n	3453a <am_hal_uart_transfer+0x726>
   344e2:	681a      	ldr	r2, [r3, #0]
   344e4:	f412 6f70 	tst.w	r2, #3840	; 0xf00
   344e8:	d14c      	bne.n	34584 <am_hal_uart_transfer+0x770>
   344ea:	f88c 2000 	strb.w	r2, [ip]
   344ee:	6999      	ldr	r1, [r3, #24]
   344f0:	06cd      	lsls	r5, r1, #27
   344f2:	f100 0204 	add.w	r2, r0, #4
   344f6:	d420      	bmi.n	3453a <am_hal_uart_transfer+0x726>
   344f8:	681d      	ldr	r5, [r3, #0]
   344fa:	f415 6f70 	tst.w	r5, #3840	; 0xf00
   344fe:	d141      	bne.n	34584 <am_hal_uart_transfer+0x770>
   34500:	f88e 5004 	strb.w	r5, [lr, #4]
   34504:	6999      	ldr	r1, [r3, #24]
   34506:	06cd      	lsls	r5, r1, #27
   34508:	f100 0205 	add.w	r2, r0, #5
   3450c:	d415      	bmi.n	3453a <am_hal_uart_transfer+0x726>
   3450e:	681a      	ldr	r2, [r3, #0]
   34510:	f412 6f70 	tst.w	r2, #3840	; 0xf00
   34514:	d136      	bne.n	34584 <am_hal_uart_transfer+0x770>
   34516:	f88e 2005 	strb.w	r2, [lr, #5]
   3451a:	699d      	ldr	r5, [r3, #24]
   3451c:	06ed      	lsls	r5, r5, #27
   3451e:	f100 0206 	add.w	r2, r0, #6
   34522:	d40a      	bmi.n	3453a <am_hal_uart_transfer+0x726>
   34524:	6819      	ldr	r1, [r3, #0]
   34526:	f411 6f70 	tst.w	r1, #3840	; 0xf00
   3452a:	d12b      	bne.n	34584 <am_hal_uart_transfer+0x770>
   3452c:	1dc2      	adds	r2, r0, #7
   3452e:	2a20      	cmp	r2, #32
   34530:	f88e 1006 	strb.w	r1, [lr, #6]
   34534:	f10e 0c07 	add.w	ip, lr, #7
   34538:	d1a1      	bne.n	3447e <am_hal_uart_transfer+0x66a>
   3453a:	a908      	add	r1, sp, #32
   3453c:	9802      	ldr	r0, [sp, #8]
   3453e:	4655      	mov	r5, sl
   34540:	f8dd a004 	ldr.w	sl, [sp, #4]
   34544:	f000 f8f2 	bl	3472c <am_hal_queue_item_add>
   34548:	b960      	cbnz	r0, 34564 <am_hal_uart_transfer+0x750>
   3454a:	4d71      	ldr	r5, [pc, #452]	; (34710 <am_hal_uart_transfer+0x8fc>)
   3454c:	9807      	ldr	r0, [sp, #28]
   3454e:	f7ff f913 	bl	33778 <am_hal_interrupt_master_set>
   34552:	e4a7      	b.n	33ea4 <am_hal_uart_transfer+0x90>
   34554:	441c      	add	r4, r3
   34556:	f04f 6500 	mov.w	r5, #134217728	; 0x8000000
   3455a:	e4a3      	b.n	33ea4 <am_hal_uart_transfer+0x90>
   3455c:	441c      	add	r4, r3
   3455e:	e763      	b.n	34428 <am_hal_uart_transfer+0x614>
   34560:	462f      	mov	r7, r5
   34562:	e689      	b.n	34278 <am_hal_uart_transfer+0x464>
   34564:	9807      	ldr	r0, [sp, #28]
   34566:	f7ff f907 	bl	33778 <am_hal_interrupt_master_set>
   3456a:	f8db 3050 	ldr.w	r3, [fp, #80]	; 0x50
   3456e:	9802      	ldr	r0, [sp, #8]
   34570:	42ab      	cmp	r3, r5
   34572:	bf28      	it	cs
   34574:	462b      	movcs	r3, r5
   34576:	461a      	mov	r2, r3
   34578:	4649      	mov	r1, r9
   3457a:	9301      	str	r3, [sp, #4]
   3457c:	f000 f9d8 	bl	34930 <am_hal_queue_item_get>
   34580:	9b01      	ldr	r3, [sp, #4]
   34582:	e74e      	b.n	34422 <am_hal_uart_transfer+0x60e>
   34584:	f04f 6500 	mov.w	r5, #134217728	; 0x8000000
   34588:	e7e0      	b.n	3454c <am_hal_uart_transfer+0x738>
   3458a:	462c      	mov	r4, r5
   3458c:	e74c      	b.n	34428 <am_hal_uart_transfer+0x614>
   3458e:	f04f 6500 	mov.w	r5, #134217728	; 0x8000000
   34592:	e487      	b.n	33ea4 <am_hal_uart_transfer+0x90>
   34594:	f8db 2038 	ldr.w	r2, [fp, #56]	; 0x38
   34598:	f8db 4034 	ldr.w	r4, [fp, #52]	; 0x34
   3459c:	1b13      	subs	r3, r2, r4
   3459e:	429e      	cmp	r6, r3
   345a0:	bf28      	it	cs
   345a2:	461e      	movcs	r6, r3
   345a4:	f10b 082c 	add.w	r8, fp, #44	; 0x2c
   345a8:	4651      	mov	r1, sl
   345aa:	4632      	mov	r2, r6
   345ac:	4640      	mov	r0, r8
   345ae:	f000 f8bd 	bl	3472c <am_hal_queue_item_add>
   345b2:	f8db 7024 	ldr.w	r7, [fp, #36]	; 0x24
   345b6:	f7ff f8db 	bl	33770 <am_hal_interrupt_master_disable>
   345ba:	f507 2580 	add.w	r5, r7, #262144	; 0x40000
   345be:	351c      	adds	r5, #28
   345c0:	032c      	lsls	r4, r5, #12
   345c2:	9005      	str	r0, [sp, #20]
   345c4:	e00e      	b.n	345e4 <am_hal_uart_transfer+0x7d0>
   345c6:	f000 f9b3 	bl	34930 <am_hal_queue_item_get>
   345ca:	b190      	cbz	r0, 345f2 <am_hal_uart_transfer+0x7de>
   345cc:	f8db 1024 	ldr.w	r1, [fp, #36]	; 0x24
   345d0:	f501 2280 	add.w	r2, r1, #262144	; 0x40000
   345d4:	321c      	adds	r2, #28
   345d6:	0317      	lsls	r7, r2, #12
   345d8:	69bd      	ldr	r5, [r7, #24]
   345da:	06ab      	lsls	r3, r5, #26
   345dc:	bf5c      	itt	pl
   345de:	f89d 3020 	ldrbpl.w	r3, [sp, #32]
   345e2:	603b      	strpl	r3, [r7, #0]
   345e4:	69a3      	ldr	r3, [r4, #24]
   345e6:	069f      	lsls	r7, r3, #26
   345e8:	f04f 0201 	mov.w	r2, #1
   345ec:	a908      	add	r1, sp, #32
   345ee:	4640      	mov	r0, r8
   345f0:	d5e9      	bpl.n	345c6 <am_hal_uart_transfer+0x7b2>
   345f2:	9805      	ldr	r0, [sp, #20]
   345f4:	f7ff f8c0 	bl	33778 <am_hal_interrupt_master_set>
   345f8:	e503      	b.n	34002 <am_hal_uart_transfer+0x1ee>
   345fa:	4606      	mov	r6, r0
   345fc:	e501      	b.n	34002 <am_hal_uart_transfer+0x1ee>
   345fe:	f7ff f8b7 	bl	33770 <am_hal_interrupt_master_disable>
   34602:	f8db 1024 	ldr.w	r1, [fp, #36]	; 0x24
   34606:	9006      	str	r0, [sp, #24]
   34608:	f501 2080 	add.w	r0, r1, #262144	; 0x40000
   3460c:	301c      	adds	r0, #28
   3460e:	0301      	lsls	r1, r0, #12
   34610:	ab08      	add	r3, sp, #32
   34612:	2200      	movs	r2, #0
   34614:	698f      	ldr	r7, [r1, #24]
   34616:	06ff      	lsls	r7, r7, #27
   34618:	d453      	bmi.n	346c2 <am_hal_uart_transfer+0x8ae>
   3461a:	680e      	ldr	r6, [r1, #0]
   3461c:	f416 6f70 	tst.w	r6, #3840	; 0xf00
   34620:	d16b      	bne.n	346fa <am_hal_uart_transfer+0x8e6>
   34622:	4618      	mov	r0, r3
   34624:	3201      	adds	r2, #1
   34626:	f800 6b01 	strb.w	r6, [r0], #1
   3462a:	698f      	ldr	r7, [r1, #24]
   3462c:	06fe      	lsls	r6, r7, #27
   3462e:	4614      	mov	r4, r2
   34630:	d447      	bmi.n	346c2 <am_hal_uart_transfer+0x8ae>
   34632:	680e      	ldr	r6, [r1, #0]
   34634:	f416 6f70 	tst.w	r6, #3840	; 0xf00
   34638:	d15f      	bne.n	346fa <am_hal_uart_transfer+0x8e6>
   3463a:	7006      	strb	r6, [r0, #0]
   3463c:	698f      	ldr	r7, [r1, #24]
   3463e:	06fe      	lsls	r6, r7, #27
   34640:	f102 0201 	add.w	r2, r2, #1
   34644:	d43d      	bmi.n	346c2 <am_hal_uart_transfer+0x8ae>
   34646:	680a      	ldr	r2, [r1, #0]
   34648:	f412 6f70 	tst.w	r2, #3840	; 0xf00
   3464c:	d155      	bne.n	346fa <am_hal_uart_transfer+0x8e6>
   3464e:	7042      	strb	r2, [r0, #1]
   34650:	698e      	ldr	r6, [r1, #24]
   34652:	06f7      	lsls	r7, r6, #27
   34654:	f104 0202 	add.w	r2, r4, #2
   34658:	d433      	bmi.n	346c2 <am_hal_uart_transfer+0x8ae>
   3465a:	680f      	ldr	r7, [r1, #0]
   3465c:	f417 6f70 	tst.w	r7, #3840	; 0xf00
   34660:	d14b      	bne.n	346fa <am_hal_uart_transfer+0x8e6>
   34662:	70df      	strb	r7, [r3, #3]
   34664:	698e      	ldr	r6, [r1, #24]
   34666:	06f6      	lsls	r6, r6, #27
   34668:	f103 0304 	add.w	r3, r3, #4
   3466c:	f104 0203 	add.w	r2, r4, #3
   34670:	d427      	bmi.n	346c2 <am_hal_uart_transfer+0x8ae>
   34672:	680a      	ldr	r2, [r1, #0]
   34674:	f412 6f70 	tst.w	r2, #3840	; 0xf00
   34678:	d13f      	bne.n	346fa <am_hal_uart_transfer+0x8e6>
   3467a:	701a      	strb	r2, [r3, #0]
   3467c:	698b      	ldr	r3, [r1, #24]
   3467e:	06db      	lsls	r3, r3, #27
   34680:	f104 0204 	add.w	r2, r4, #4
   34684:	d41d      	bmi.n	346c2 <am_hal_uart_transfer+0x8ae>
   34686:	680f      	ldr	r7, [r1, #0]
   34688:	f417 6f70 	tst.w	r7, #3840	; 0xf00
   3468c:	d135      	bne.n	346fa <am_hal_uart_transfer+0x8e6>
   3468e:	7107      	strb	r7, [r0, #4]
   34690:	698e      	ldr	r6, [r1, #24]
   34692:	06f7      	lsls	r7, r6, #27
   34694:	f104 0205 	add.w	r2, r4, #5
   34698:	d413      	bmi.n	346c2 <am_hal_uart_transfer+0x8ae>
   3469a:	680a      	ldr	r2, [r1, #0]
   3469c:	f412 6f70 	tst.w	r2, #3840	; 0xf00
   346a0:	d12b      	bne.n	346fa <am_hal_uart_transfer+0x8e6>
   346a2:	7142      	strb	r2, [r0, #5]
   346a4:	698b      	ldr	r3, [r1, #24]
   346a6:	06de      	lsls	r6, r3, #27
   346a8:	f104 0206 	add.w	r2, r4, #6
   346ac:	d409      	bmi.n	346c2 <am_hal_uart_transfer+0x8ae>
   346ae:	680f      	ldr	r7, [r1, #0]
   346b0:	f417 6f70 	tst.w	r7, #3840	; 0xf00
   346b4:	d121      	bne.n	346fa <am_hal_uart_transfer+0x8e6>
   346b6:	1de2      	adds	r2, r4, #7
   346b8:	2a20      	cmp	r2, #32
   346ba:	7187      	strb	r7, [r0, #6]
   346bc:	f100 0307 	add.w	r3, r0, #7
   346c0:	d1a8      	bne.n	34614 <am_hal_uart_transfer+0x800>
   346c2:	f10b 0a48 	add.w	sl, fp, #72	; 0x48
   346c6:	a908      	add	r1, sp, #32
   346c8:	4650      	mov	r0, sl
   346ca:	f000 f82f 	bl	3472c <am_hal_queue_item_add>
   346ce:	b928      	cbnz	r0, 346dc <am_hal_uart_transfer+0x8c8>
   346d0:	4d0f      	ldr	r5, [pc, #60]	; (34710 <am_hal_uart_transfer+0x8fc>)
   346d2:	9806      	ldr	r0, [sp, #24]
   346d4:	f7ff f850 	bl	33778 <am_hal_interrupt_master_set>
   346d8:	f7ff bba6 	b.w	33e28 <am_hal_uart_transfer+0x14>
   346dc:	9806      	ldr	r0, [sp, #24]
   346de:	f7ff f84b 	bl	33778 <am_hal_interrupt_master_set>
   346e2:	f8db 1050 	ldr.w	r1, [fp, #80]	; 0x50
   346e6:	428d      	cmp	r5, r1
   346e8:	462c      	mov	r4, r5
   346ea:	bf28      	it	cs
   346ec:	460c      	movcs	r4, r1
   346ee:	4650      	mov	r0, sl
   346f0:	4649      	mov	r1, r9
   346f2:	4622      	mov	r2, r4
   346f4:	f000 f91c 	bl	34930 <am_hal_queue_item_get>
   346f8:	e50a      	b.n	34110 <am_hal_uart_transfer+0x2fc>
   346fa:	f04f 6500 	mov.w	r5, #134217728	; 0x8000000
   346fe:	e7e8      	b.n	346d2 <am_hal_uart_transfer+0x8be>
   34700:	4614      	mov	r4, r2
   34702:	f04f 6500 	mov.w	r5, #134217728	; 0x8000000
   34706:	f7ff bbcd 	b.w	33ea4 <am_hal_uart_transfer+0x90>
   3470a:	4625      	mov	r5, r4
   3470c:	f7ff bbca 	b.w	33ea4 <am_hal_uart_transfer+0x90>
   34710:	08000001 	.word	0x08000001

00034714 <am_hal_queue_init>:
   34714:	b410      	push	{r4}
   34716:	2400      	movs	r4, #0
   34718:	6004      	str	r4, [r0, #0]
   3471a:	6044      	str	r4, [r0, #4]
   3471c:	6084      	str	r4, [r0, #8]
   3471e:	60c3      	str	r3, [r0, #12]
   34720:	6102      	str	r2, [r0, #16]
   34722:	6141      	str	r1, [r0, #20]
   34724:	f85d 4b04 	ldr.w	r4, [sp], #4
   34728:	4770      	bx	lr
   3472a:	bf00      	nop

0003472c <am_hal_queue_item_add>:
   3472c:	b5f0      	push	{r4, r5, r6, r7, lr}
   3472e:	4604      	mov	r4, r0
   34730:	6905      	ldr	r5, [r0, #16]
   34732:	b083      	sub	sp, #12
   34734:	fb05 f502 	mul.w	r5, r5, r2
   34738:	460f      	mov	r7, r1
   3473a:	f7ff f819 	bl	33770 <am_hal_interrupt_master_disable>
   3473e:	68e3      	ldr	r3, [r4, #12]
   34740:	68a2      	ldr	r2, [r4, #8]
   34742:	9001      	str	r0, [sp, #4]
   34744:	1a99      	subs	r1, r3, r2
   34746:	428d      	cmp	r5, r1
   34748:	d87f      	bhi.n	3484a <am_hal_queue_item_add+0x11e>
   3474a:	2d00      	cmp	r5, #0
   3474c:	d074      	beq.n	34838 <am_hal_queue_item_add+0x10c>
   3474e:	6826      	ldr	r6, [r4, #0]
   34750:	2f00      	cmp	r7, #0
   34752:	d07c      	beq.n	3484e <am_hal_queue_item_add+0x122>
   34754:	4638      	mov	r0, r7
   34756:	6963      	ldr	r3, [r4, #20]
   34758:	f810 2b01 	ldrb.w	r2, [r0], #1
   3475c:	559a      	strb	r2, [r3, r6]
   3475e:	6822      	ldr	r2, [r4, #0]
   34760:	68e3      	ldr	r3, [r4, #12]
   34762:	197e      	adds	r6, r7, r5
   34764:	3201      	adds	r2, #1
   34766:	43f9      	mvns	r1, r7
   34768:	fbb2 fcf3 	udiv	ip, r2, r3
   3476c:	4431      	add	r1, r6
   3476e:	fb03 231c 	mls	r3, r3, ip, r2
   34772:	42b0      	cmp	r0, r6
   34774:	6023      	str	r3, [r4, #0]
   34776:	f001 0703 	and.w	r7, r1, #3
   3477a:	d05c      	beq.n	34836 <am_hal_queue_item_add+0x10a>
   3477c:	b34f      	cbz	r7, 347d2 <am_hal_queue_item_add+0xa6>
   3477e:	2f01      	cmp	r7, #1
   34780:	d019      	beq.n	347b6 <am_hal_queue_item_add+0x8a>
   34782:	2f02      	cmp	r7, #2
   34784:	d00b      	beq.n	3479e <am_hal_queue_item_add+0x72>
   34786:	6962      	ldr	r2, [r4, #20]
   34788:	f810 1b01 	ldrb.w	r1, [r0], #1
   3478c:	54d1      	strb	r1, [r2, r3]
   3478e:	6827      	ldr	r7, [r4, #0]
   34790:	68e3      	ldr	r3, [r4, #12]
   34792:	3701      	adds	r7, #1
   34794:	fbb7 f2f3 	udiv	r2, r7, r3
   34798:	fb03 7312 	mls	r3, r3, r2, r7
   3479c:	6023      	str	r3, [r4, #0]
   3479e:	6967      	ldr	r7, [r4, #20]
   347a0:	f810 1b01 	ldrb.w	r1, [r0], #1
   347a4:	54f9      	strb	r1, [r7, r3]
   347a6:	6822      	ldr	r2, [r4, #0]
   347a8:	68e3      	ldr	r3, [r4, #12]
   347aa:	3201      	adds	r2, #1
   347ac:	fbb2 f7f3 	udiv	r7, r2, r3
   347b0:	fb03 2317 	mls	r3, r3, r7, r2
   347b4:	6023      	str	r3, [r4, #0]
   347b6:	6962      	ldr	r2, [r4, #20]
   347b8:	f810 1b01 	ldrb.w	r1, [r0], #1
   347bc:	54d1      	strb	r1, [r2, r3]
   347be:	6827      	ldr	r7, [r4, #0]
   347c0:	68e3      	ldr	r3, [r4, #12]
   347c2:	3701      	adds	r7, #1
   347c4:	42b0      	cmp	r0, r6
   347c6:	fbb7 f2f3 	udiv	r2, r7, r3
   347ca:	fb03 7312 	mls	r3, r3, r2, r7
   347ce:	6023      	str	r3, [r4, #0]
   347d0:	d031      	beq.n	34836 <am_hal_queue_item_add+0x10a>
   347d2:	4686      	mov	lr, r0
   347d4:	6967      	ldr	r7, [r4, #20]
   347d6:	f81e 1b01 	ldrb.w	r1, [lr], #1
   347da:	54f9      	strb	r1, [r7, r3]
   347dc:	6823      	ldr	r3, [r4, #0]
   347de:	68e7      	ldr	r7, [r4, #12]
   347e0:	6961      	ldr	r1, [r4, #20]
   347e2:	3301      	adds	r3, #1
   347e4:	fbb3 fcf7 	udiv	ip, r3, r7
   347e8:	fb07 331c 	mls	r3, r7, ip, r3
   347ec:	6023      	str	r3, [r4, #0]
   347ee:	7842      	ldrb	r2, [r0, #1]
   347f0:	54ca      	strb	r2, [r1, r3]
   347f2:	6827      	ldr	r7, [r4, #0]
   347f4:	68e3      	ldr	r3, [r4, #12]
   347f6:	6961      	ldr	r1, [r4, #20]
   347f8:	3701      	adds	r7, #1
   347fa:	fbb7 fcf3 	udiv	ip, r7, r3
   347fe:	fb03 771c 	mls	r7, r3, ip, r7
   34802:	6027      	str	r7, [r4, #0]
   34804:	f89e 2001 	ldrb.w	r2, [lr, #1]
   34808:	55ca      	strb	r2, [r1, r7]
   3480a:	6823      	ldr	r3, [r4, #0]
   3480c:	68e7      	ldr	r7, [r4, #12]
   3480e:	6961      	ldr	r1, [r4, #20]
   34810:	3301      	adds	r3, #1
   34812:	fbb3 fef7 	udiv	lr, r3, r7
   34816:	fb07 331e 	mls	r3, r7, lr, r3
   3481a:	6023      	str	r3, [r4, #0]
   3481c:	78c2      	ldrb	r2, [r0, #3]
   3481e:	54ca      	strb	r2, [r1, r3]
   34820:	6827      	ldr	r7, [r4, #0]
   34822:	68e3      	ldr	r3, [r4, #12]
   34824:	3701      	adds	r7, #1
   34826:	3004      	adds	r0, #4
   34828:	fbb7 f2f3 	udiv	r2, r7, r3
   3482c:	42b0      	cmp	r0, r6
   3482e:	fb03 7312 	mls	r3, r3, r2, r7
   34832:	6023      	str	r3, [r4, #0]
   34834:	d1cd      	bne.n	347d2 <am_hal_queue_item_add+0xa6>
   34836:	68a2      	ldr	r2, [r4, #8]
   34838:	442a      	add	r2, r5
   3483a:	60a2      	str	r2, [r4, #8]
   3483c:	2401      	movs	r4, #1
   3483e:	9801      	ldr	r0, [sp, #4]
   34840:	f7fe ff9a 	bl	33778 <am_hal_interrupt_master_set>
   34844:	4620      	mov	r0, r4
   34846:	b003      	add	sp, #12
   34848:	bdf0      	pop	{r4, r5, r6, r7, pc}
   3484a:	2400      	movs	r4, #0
   3484c:	e7f7      	b.n	3483e <am_hal_queue_item_add+0x112>
   3484e:	1c70      	adds	r0, r6, #1
   34850:	fbb0 f7f3 	udiv	r7, r0, r3
   34854:	fb03 0117 	mls	r1, r3, r7, r0
   34858:	2001      	movs	r0, #1
   3485a:	1e6e      	subs	r6, r5, #1
   3485c:	4285      	cmp	r5, r0
   3485e:	f006 0607 	and.w	r6, r6, #7
   34862:	d063      	beq.n	3492c <am_hal_queue_item_add+0x200>
   34864:	b3be      	cbz	r6, 348d6 <am_hal_queue_item_add+0x1aa>
   34866:	2e01      	cmp	r6, #1
   34868:	d02d      	beq.n	348c6 <am_hal_queue_item_add+0x19a>
   3486a:	2e02      	cmp	r6, #2
   3486c:	d025      	beq.n	348ba <am_hal_queue_item_add+0x18e>
   3486e:	2e03      	cmp	r6, #3
   34870:	d01d      	beq.n	348ae <am_hal_queue_item_add+0x182>
   34872:	2e04      	cmp	r6, #4
   34874:	d015      	beq.n	348a2 <am_hal_queue_item_add+0x176>
   34876:	2e05      	cmp	r6, #5
   34878:	d00d      	beq.n	34896 <am_hal_queue_item_add+0x16a>
   3487a:	2e06      	cmp	r6, #6
   3487c:	d005      	beq.n	3488a <am_hal_queue_item_add+0x15e>
   3487e:	3101      	adds	r1, #1
   34880:	2002      	movs	r0, #2
   34882:	fbb1 f7f3 	udiv	r7, r1, r3
   34886:	fb03 1117 	mls	r1, r3, r7, r1
   3488a:	3101      	adds	r1, #1
   3488c:	3001      	adds	r0, #1
   3488e:	fbb1 fcf3 	udiv	ip, r1, r3
   34892:	fb03 111c 	mls	r1, r3, ip, r1
   34896:	3101      	adds	r1, #1
   34898:	3001      	adds	r0, #1
   3489a:	fbb1 fef3 	udiv	lr, r1, r3
   3489e:	fb03 111e 	mls	r1, r3, lr, r1
   348a2:	3101      	adds	r1, #1
   348a4:	3001      	adds	r0, #1
   348a6:	fbb1 f6f3 	udiv	r6, r1, r3
   348aa:	fb03 1116 	mls	r1, r3, r6, r1
   348ae:	3101      	adds	r1, #1
   348b0:	3001      	adds	r0, #1
   348b2:	fbb1 f7f3 	udiv	r7, r1, r3
   348b6:	fb03 1117 	mls	r1, r3, r7, r1
   348ba:	3101      	adds	r1, #1
   348bc:	3001      	adds	r0, #1
   348be:	fbb1 fcf3 	udiv	ip, r1, r3
   348c2:	fb03 111c 	mls	r1, r3, ip, r1
   348c6:	3001      	adds	r0, #1
   348c8:	3101      	adds	r1, #1
   348ca:	4285      	cmp	r5, r0
   348cc:	fbb1 fef3 	udiv	lr, r1, r3
   348d0:	fb03 111e 	mls	r1, r3, lr, r1
   348d4:	d02a      	beq.n	3492c <am_hal_queue_item_add+0x200>
   348d6:	3101      	adds	r1, #1
   348d8:	fbb1 f6f3 	udiv	r6, r1, r3
   348dc:	fb03 1716 	mls	r7, r3, r6, r1
   348e0:	1c7e      	adds	r6, r7, #1
   348e2:	fbb6 fcf3 	udiv	ip, r6, r3
   348e6:	fb03 611c 	mls	r1, r3, ip, r6
   348ea:	1c4f      	adds	r7, r1, #1
   348ec:	fbb7 f6f3 	udiv	r6, r7, r3
   348f0:	fb03 7116 	mls	r1, r3, r6, r7
   348f4:	1c4f      	adds	r7, r1, #1
   348f6:	fbb7 f6f3 	udiv	r6, r7, r3
   348fa:	fb03 7116 	mls	r1, r3, r6, r7
   348fe:	1c4f      	adds	r7, r1, #1
   34900:	fbb7 f6f3 	udiv	r6, r7, r3
   34904:	fb03 7116 	mls	r1, r3, r6, r7
   34908:	1c4f      	adds	r7, r1, #1
   3490a:	fbb7 f6f3 	udiv	r6, r7, r3
   3490e:	fb03 7116 	mls	r1, r3, r6, r7
   34912:	1c4f      	adds	r7, r1, #1
   34914:	3008      	adds	r0, #8
   34916:	fbb7 f6f3 	udiv	r6, r7, r3
   3491a:	fb03 7116 	mls	r1, r3, r6, r7
   3491e:	1c4f      	adds	r7, r1, #1
   34920:	4285      	cmp	r5, r0
   34922:	fbb7 f6f3 	udiv	r6, r7, r3
   34926:	fb03 7116 	mls	r1, r3, r6, r7
   3492a:	d1d4      	bne.n	348d6 <am_hal_queue_item_add+0x1aa>
   3492c:	6021      	str	r1, [r4, #0]
   3492e:	e783      	b.n	34838 <am_hal_queue_item_add+0x10c>

00034930 <am_hal_queue_item_get>:
   34930:	b5f0      	push	{r4, r5, r6, r7, lr}
   34932:	4604      	mov	r4, r0
   34934:	6906      	ldr	r6, [r0, #16]
   34936:	b083      	sub	sp, #12
   34938:	fb06 f602 	mul.w	r6, r6, r2
   3493c:	460f      	mov	r7, r1
   3493e:	f7fe ff17 	bl	33770 <am_hal_interrupt_master_disable>
   34942:	68a2      	ldr	r2, [r4, #8]
   34944:	9001      	str	r0, [sp, #4]
   34946:	4296      	cmp	r6, r2
   34948:	d87f      	bhi.n	34a4a <am_hal_queue_item_get+0x11a>
   3494a:	2e00      	cmp	r6, #0
   3494c:	d074      	beq.n	34a38 <am_hal_queue_item_get+0x108>
   3494e:	6863      	ldr	r3, [r4, #4]
   34950:	2f00      	cmp	r7, #0
   34952:	d07c      	beq.n	34a4e <am_hal_queue_item_get+0x11e>
   34954:	6962      	ldr	r2, [r4, #20]
   34956:	463d      	mov	r5, r7
   34958:	5cd0      	ldrb	r0, [r2, r3]
   3495a:	f805 0b01 	strb.w	r0, [r5], #1
   3495e:	6863      	ldr	r3, [r4, #4]
   34960:	68e2      	ldr	r2, [r4, #12]
   34962:	3301      	adds	r3, #1
   34964:	19b9      	adds	r1, r7, r6
   34966:	1e70      	subs	r0, r6, #1
   34968:	fbb3 f7f2 	udiv	r7, r3, r2
   3496c:	42a9      	cmp	r1, r5
   3496e:	fb02 3317 	mls	r3, r2, r7, r3
   34972:	6063      	str	r3, [r4, #4]
   34974:	f000 0203 	and.w	r2, r0, #3
   34978:	d05d      	beq.n	34a36 <am_hal_queue_item_get+0x106>
   3497a:	b352      	cbz	r2, 349d2 <am_hal_queue_item_get+0xa2>
   3497c:	2a01      	cmp	r2, #1
   3497e:	d01a      	beq.n	349b6 <am_hal_queue_item_get+0x86>
   34980:	2a02      	cmp	r2, #2
   34982:	d00c      	beq.n	3499e <am_hal_queue_item_get+0x6e>
   34984:	6967      	ldr	r7, [r4, #20]
   34986:	f817 c003 	ldrb.w	ip, [r7, r3]
   3498a:	f805 cb01 	strb.w	ip, [r5], #1
   3498e:	6863      	ldr	r3, [r4, #4]
   34990:	68e2      	ldr	r2, [r4, #12]
   34992:	3301      	adds	r3, #1
   34994:	fbb3 fef2 	udiv	lr, r3, r2
   34998:	fb02 331e 	mls	r3, r2, lr, r3
   3499c:	6063      	str	r3, [r4, #4]
   3499e:	6960      	ldr	r0, [r4, #20]
   349a0:	5cc7      	ldrb	r7, [r0, r3]
   349a2:	f805 7b01 	strb.w	r7, [r5], #1
   349a6:	6863      	ldr	r3, [r4, #4]
   349a8:	68e2      	ldr	r2, [r4, #12]
   349aa:	3301      	adds	r3, #1
   349ac:	fbb3 fcf2 	udiv	ip, r3, r2
   349b0:	fb02 331c 	mls	r3, r2, ip, r3
   349b4:	6063      	str	r3, [r4, #4]
   349b6:	6960      	ldr	r0, [r4, #20]
   349b8:	5cc7      	ldrb	r7, [r0, r3]
   349ba:	f805 7b01 	strb.w	r7, [r5], #1
   349be:	6863      	ldr	r3, [r4, #4]
   349c0:	68e2      	ldr	r2, [r4, #12]
   349c2:	3301      	adds	r3, #1
   349c4:	42a9      	cmp	r1, r5
   349c6:	fbb3 fef2 	udiv	lr, r3, r2
   349ca:	fb02 331e 	mls	r3, r2, lr, r3
   349ce:	6063      	str	r3, [r4, #4]
   349d0:	d031      	beq.n	34a36 <am_hal_queue_item_get+0x106>
   349d2:	6960      	ldr	r0, [r4, #20]
   349d4:	46ac      	mov	ip, r5
   349d6:	5cc7      	ldrb	r7, [r0, r3]
   349d8:	f80c 7b01 	strb.w	r7, [ip], #1
   349dc:	6863      	ldr	r3, [r4, #4]
   349de:	68e0      	ldr	r0, [r4, #12]
   349e0:	6962      	ldr	r2, [r4, #20]
   349e2:	3301      	adds	r3, #1
   349e4:	fbb3 fef0 	udiv	lr, r3, r0
   349e8:	fb00 371e 	mls	r7, r0, lr, r3
   349ec:	6067      	str	r7, [r4, #4]
   349ee:	5dd3      	ldrb	r3, [r2, r7]
   349f0:	706b      	strb	r3, [r5, #1]
   349f2:	6867      	ldr	r7, [r4, #4]
   349f4:	68e0      	ldr	r0, [r4, #12]
   349f6:	6962      	ldr	r2, [r4, #20]
   349f8:	3701      	adds	r7, #1
   349fa:	fbb7 fef0 	udiv	lr, r7, r0
   349fe:	fb00 731e 	mls	r3, r0, lr, r7
   34a02:	6063      	str	r3, [r4, #4]
   34a04:	5cd7      	ldrb	r7, [r2, r3]
   34a06:	f88c 7001 	strb.w	r7, [ip, #1]
   34a0a:	6863      	ldr	r3, [r4, #4]
   34a0c:	68e7      	ldr	r7, [r4, #12]
   34a0e:	6960      	ldr	r0, [r4, #20]
   34a10:	3301      	adds	r3, #1
   34a12:	fbb3 fcf7 	udiv	ip, r3, r7
   34a16:	fb07 321c 	mls	r2, r7, ip, r3
   34a1a:	6062      	str	r2, [r4, #4]
   34a1c:	5c83      	ldrb	r3, [r0, r2]
   34a1e:	70eb      	strb	r3, [r5, #3]
   34a20:	6863      	ldr	r3, [r4, #4]
   34a22:	68e2      	ldr	r2, [r4, #12]
   34a24:	3301      	adds	r3, #1
   34a26:	3504      	adds	r5, #4
   34a28:	fbb3 fef2 	udiv	lr, r3, r2
   34a2c:	42a9      	cmp	r1, r5
   34a2e:	fb02 331e 	mls	r3, r2, lr, r3
   34a32:	6063      	str	r3, [r4, #4]
   34a34:	d1cd      	bne.n	349d2 <am_hal_queue_item_get+0xa2>
   34a36:	68a2      	ldr	r2, [r4, #8]
   34a38:	1b92      	subs	r2, r2, r6
   34a3a:	60a2      	str	r2, [r4, #8]
   34a3c:	2401      	movs	r4, #1
   34a3e:	9801      	ldr	r0, [sp, #4]
   34a40:	f7fe fe9a 	bl	33778 <am_hal_interrupt_master_set>
   34a44:	4620      	mov	r0, r4
   34a46:	b003      	add	sp, #12
   34a48:	bdf0      	pop	{r4, r5, r6, r7, pc}
   34a4a:	2400      	movs	r4, #0
   34a4c:	e7f7      	b.n	34a3e <am_hal_queue_item_get+0x10e>
   34a4e:	68e1      	ldr	r1, [r4, #12]
   34a50:	1c5f      	adds	r7, r3, #1
   34a52:	fbb7 f0f1 	udiv	r0, r7, r1
   34a56:	fb01 7310 	mls	r3, r1, r0, r7
   34a5a:	2701      	movs	r7, #1
   34a5c:	1e75      	subs	r5, r6, #1
   34a5e:	42be      	cmp	r6, r7
   34a60:	f005 0507 	and.w	r5, r5, #7
   34a64:	d063      	beq.n	34b2e <am_hal_queue_item_get+0x1fe>
   34a66:	b3bd      	cbz	r5, 34ad8 <am_hal_queue_item_get+0x1a8>
   34a68:	2d01      	cmp	r5, #1
   34a6a:	d02d      	beq.n	34ac8 <am_hal_queue_item_get+0x198>
   34a6c:	2d02      	cmp	r5, #2
   34a6e:	d025      	beq.n	34abc <am_hal_queue_item_get+0x18c>
   34a70:	2d03      	cmp	r5, #3
   34a72:	d01d      	beq.n	34ab0 <am_hal_queue_item_get+0x180>
   34a74:	2d04      	cmp	r5, #4
   34a76:	d015      	beq.n	34aa4 <am_hal_queue_item_get+0x174>
   34a78:	2d05      	cmp	r5, #5
   34a7a:	d00d      	beq.n	34a98 <am_hal_queue_item_get+0x168>
   34a7c:	2d06      	cmp	r5, #6
   34a7e:	d005      	beq.n	34a8c <am_hal_queue_item_get+0x15c>
   34a80:	3301      	adds	r3, #1
   34a82:	2702      	movs	r7, #2
   34a84:	fbb3 f0f1 	udiv	r0, r3, r1
   34a88:	fb01 3310 	mls	r3, r1, r0, r3
   34a8c:	3301      	adds	r3, #1
   34a8e:	3701      	adds	r7, #1
   34a90:	fbb3 fef1 	udiv	lr, r3, r1
   34a94:	fb01 331e 	mls	r3, r1, lr, r3
   34a98:	3301      	adds	r3, #1
   34a9a:	3701      	adds	r7, #1
   34a9c:	fbb3 fcf1 	udiv	ip, r3, r1
   34aa0:	fb01 331c 	mls	r3, r1, ip, r3
   34aa4:	3301      	adds	r3, #1
   34aa6:	3701      	adds	r7, #1
   34aa8:	fbb3 f5f1 	udiv	r5, r3, r1
   34aac:	fb01 3315 	mls	r3, r1, r5, r3
   34ab0:	3301      	adds	r3, #1
   34ab2:	3701      	adds	r7, #1
   34ab4:	fbb3 f0f1 	udiv	r0, r3, r1
   34ab8:	fb01 3310 	mls	r3, r1, r0, r3
   34abc:	3301      	adds	r3, #1
   34abe:	3701      	adds	r7, #1
   34ac0:	fbb3 fef1 	udiv	lr, r3, r1
   34ac4:	fb01 331e 	mls	r3, r1, lr, r3
   34ac8:	3701      	adds	r7, #1
   34aca:	3301      	adds	r3, #1
   34acc:	42be      	cmp	r6, r7
   34ace:	fbb3 fcf1 	udiv	ip, r3, r1
   34ad2:	fb01 331c 	mls	r3, r1, ip, r3
   34ad6:	d02a      	beq.n	34b2e <am_hal_queue_item_get+0x1fe>
   34ad8:	3301      	adds	r3, #1
   34ada:	fbb3 f5f1 	udiv	r5, r3, r1
   34ade:	fb01 3015 	mls	r0, r1, r5, r3
   34ae2:	1c45      	adds	r5, r0, #1
   34ae4:	fbb5 fef1 	udiv	lr, r5, r1
   34ae8:	fb01 531e 	mls	r3, r1, lr, r5
   34aec:	1c58      	adds	r0, r3, #1
   34aee:	fbb0 f5f1 	udiv	r5, r0, r1
   34af2:	fb01 0315 	mls	r3, r1, r5, r0
   34af6:	1c58      	adds	r0, r3, #1
   34af8:	fbb0 f5f1 	udiv	r5, r0, r1
   34afc:	fb01 0315 	mls	r3, r1, r5, r0
   34b00:	1c58      	adds	r0, r3, #1
   34b02:	fbb0 f5f1 	udiv	r5, r0, r1
   34b06:	fb01 0315 	mls	r3, r1, r5, r0
   34b0a:	1c58      	adds	r0, r3, #1
   34b0c:	fbb0 f5f1 	udiv	r5, r0, r1
   34b10:	fb01 0315 	mls	r3, r1, r5, r0
   34b14:	1c58      	adds	r0, r3, #1
   34b16:	3708      	adds	r7, #8
   34b18:	fbb0 f5f1 	udiv	r5, r0, r1
   34b1c:	fb01 0315 	mls	r3, r1, r5, r0
   34b20:	1c58      	adds	r0, r3, #1
   34b22:	42be      	cmp	r6, r7
   34b24:	fbb0 f5f1 	udiv	r5, r0, r1
   34b28:	fb01 0315 	mls	r3, r1, r5, r0
   34b2c:	d1d4      	bne.n	34ad8 <am_hal_queue_item_get+0x1a8>
   34b2e:	6063      	str	r3, [r4, #4]
   34b30:	e782      	b.n	34a38 <am_hal_queue_item_get+0x108>
   34b32:	bf00      	nop

00034b34 <malloc>:
   34b34:	4b02      	ldr	r3, [pc, #8]	; (34b40 <malloc+0xc>)
   34b36:	4601      	mov	r1, r0
   34b38:	6818      	ldr	r0, [r3, #0]
   34b3a:	f000 b80b 	b.w	34b54 <_malloc_r>
   34b3e:	bf00      	nop
   34b40:	10001464 	.word	0x10001464

00034b44 <free>:
   34b44:	4b02      	ldr	r3, [pc, #8]	; (34b50 <free+0xc>)
   34b46:	4601      	mov	r1, r0
   34b48:	6818      	ldr	r0, [r3, #0]
   34b4a:	f000 bbc3 	b.w	352d4 <_free_r>
   34b4e:	bf00      	nop
   34b50:	10001464 	.word	0x10001464

00034b54 <_malloc_r>:
   34b54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   34b58:	f101 050b 	add.w	r5, r1, #11
   34b5c:	2d16      	cmp	r5, #22
   34b5e:	b083      	sub	sp, #12
   34b60:	4606      	mov	r6, r0
   34b62:	d823      	bhi.n	34bac <_malloc_r+0x58>
   34b64:	2910      	cmp	r1, #16
   34b66:	f200 80b9 	bhi.w	34cdc <_malloc_r+0x188>
   34b6a:	f000 fb45 	bl	351f8 <__malloc_lock>
   34b6e:	2510      	movs	r5, #16
   34b70:	2318      	movs	r3, #24
   34b72:	2002      	movs	r0, #2
   34b74:	4fc5      	ldr	r7, [pc, #788]	; (34e8c <_malloc_r+0x338>)
   34b76:	443b      	add	r3, r7
   34b78:	f1a3 0208 	sub.w	r2, r3, #8
   34b7c:	685c      	ldr	r4, [r3, #4]
   34b7e:	4294      	cmp	r4, r2
   34b80:	f000 8166 	beq.w	34e50 <_malloc_r+0x2fc>
   34b84:	6863      	ldr	r3, [r4, #4]
   34b86:	f023 0303 	bic.w	r3, r3, #3
   34b8a:	4423      	add	r3, r4
   34b8c:	e9d4 5102 	ldrd	r5, r1, [r4, #8]
   34b90:	685a      	ldr	r2, [r3, #4]
   34b92:	60e9      	str	r1, [r5, #12]
   34b94:	f042 0201 	orr.w	r2, r2, #1
   34b98:	608d      	str	r5, [r1, #8]
   34b9a:	4630      	mov	r0, r6
   34b9c:	605a      	str	r2, [r3, #4]
   34b9e:	f000 fb31 	bl	35204 <__malloc_unlock>
   34ba2:	3408      	adds	r4, #8
   34ba4:	4620      	mov	r0, r4
   34ba6:	b003      	add	sp, #12
   34ba8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   34bac:	f035 0507 	bics.w	r5, r5, #7
   34bb0:	f100 8094 	bmi.w	34cdc <_malloc_r+0x188>
   34bb4:	42a9      	cmp	r1, r5
   34bb6:	f200 8091 	bhi.w	34cdc <_malloc_r+0x188>
   34bba:	f000 fb1d 	bl	351f8 <__malloc_lock>
   34bbe:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
   34bc2:	f0c0 8183 	bcc.w	34ecc <_malloc_r+0x378>
   34bc6:	0a6b      	lsrs	r3, r5, #9
   34bc8:	f000 808f 	beq.w	34cea <_malloc_r+0x196>
   34bcc:	2b04      	cmp	r3, #4
   34bce:	f200 8146 	bhi.w	34e5e <_malloc_r+0x30a>
   34bd2:	09ab      	lsrs	r3, r5, #6
   34bd4:	f103 0039 	add.w	r0, r3, #57	; 0x39
   34bd8:	f103 0c38 	add.w	ip, r3, #56	; 0x38
   34bdc:	00c3      	lsls	r3, r0, #3
   34bde:	4fab      	ldr	r7, [pc, #684]	; (34e8c <_malloc_r+0x338>)
   34be0:	443b      	add	r3, r7
   34be2:	f1a3 0108 	sub.w	r1, r3, #8
   34be6:	685c      	ldr	r4, [r3, #4]
   34be8:	42a1      	cmp	r1, r4
   34bea:	d106      	bne.n	34bfa <_malloc_r+0xa6>
   34bec:	e00c      	b.n	34c08 <_malloc_r+0xb4>
   34bee:	2a00      	cmp	r2, #0
   34bf0:	f280 811d 	bge.w	34e2e <_malloc_r+0x2da>
   34bf4:	68e4      	ldr	r4, [r4, #12]
   34bf6:	42a1      	cmp	r1, r4
   34bf8:	d006      	beq.n	34c08 <_malloc_r+0xb4>
   34bfa:	6863      	ldr	r3, [r4, #4]
   34bfc:	f023 0303 	bic.w	r3, r3, #3
   34c00:	1b5a      	subs	r2, r3, r5
   34c02:	2a0f      	cmp	r2, #15
   34c04:	ddf3      	ble.n	34bee <_malloc_r+0x9a>
   34c06:	4660      	mov	r0, ip
   34c08:	693c      	ldr	r4, [r7, #16]
   34c0a:	f8df c294 	ldr.w	ip, [pc, #660]	; 34ea0 <_malloc_r+0x34c>
   34c0e:	4564      	cmp	r4, ip
   34c10:	d071      	beq.n	34cf6 <_malloc_r+0x1a2>
   34c12:	6863      	ldr	r3, [r4, #4]
   34c14:	f023 0303 	bic.w	r3, r3, #3
   34c18:	1b5a      	subs	r2, r3, r5
   34c1a:	2a0f      	cmp	r2, #15
   34c1c:	f300 8144 	bgt.w	34ea8 <_malloc_r+0x354>
   34c20:	2a00      	cmp	r2, #0
   34c22:	e9c7 cc04 	strd	ip, ip, [r7, #16]
   34c26:	f280 8126 	bge.w	34e76 <_malloc_r+0x322>
   34c2a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   34c2e:	f080 8169 	bcs.w	34f04 <_malloc_r+0x3b0>
   34c32:	08db      	lsrs	r3, r3, #3
   34c34:	1c59      	adds	r1, r3, #1
   34c36:	687a      	ldr	r2, [r7, #4]
   34c38:	f857 8031 	ldr.w	r8, [r7, r1, lsl #3]
   34c3c:	f8c4 8008 	str.w	r8, [r4, #8]
   34c40:	f04f 0e01 	mov.w	lr, #1
   34c44:	109b      	asrs	r3, r3, #2
   34c46:	fa0e f303 	lsl.w	r3, lr, r3
   34c4a:	eb07 0ec1 	add.w	lr, r7, r1, lsl #3
   34c4e:	4313      	orrs	r3, r2
   34c50:	f1ae 0208 	sub.w	r2, lr, #8
   34c54:	60e2      	str	r2, [r4, #12]
   34c56:	607b      	str	r3, [r7, #4]
   34c58:	f847 4031 	str.w	r4, [r7, r1, lsl #3]
   34c5c:	f8c8 400c 	str.w	r4, [r8, #12]
   34c60:	1082      	asrs	r2, r0, #2
   34c62:	2401      	movs	r4, #1
   34c64:	4094      	lsls	r4, r2
   34c66:	429c      	cmp	r4, r3
   34c68:	d84b      	bhi.n	34d02 <_malloc_r+0x1ae>
   34c6a:	421c      	tst	r4, r3
   34c6c:	d106      	bne.n	34c7c <_malloc_r+0x128>
   34c6e:	f020 0003 	bic.w	r0, r0, #3
   34c72:	0064      	lsls	r4, r4, #1
   34c74:	421c      	tst	r4, r3
   34c76:	f100 0004 	add.w	r0, r0, #4
   34c7a:	d0fa      	beq.n	34c72 <_malloc_r+0x11e>
   34c7c:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
   34c80:	46ce      	mov	lr, r9
   34c82:	4680      	mov	r8, r0
   34c84:	f8de 300c 	ldr.w	r3, [lr, #12]
   34c88:	459e      	cmp	lr, r3
   34c8a:	d107      	bne.n	34c9c <_malloc_r+0x148>
   34c8c:	e122      	b.n	34ed4 <_malloc_r+0x380>
   34c8e:	2a00      	cmp	r2, #0
   34c90:	f280 8129 	bge.w	34ee6 <_malloc_r+0x392>
   34c94:	68db      	ldr	r3, [r3, #12]
   34c96:	459e      	cmp	lr, r3
   34c98:	f000 811c 	beq.w	34ed4 <_malloc_r+0x380>
   34c9c:	6859      	ldr	r1, [r3, #4]
   34c9e:	f021 0103 	bic.w	r1, r1, #3
   34ca2:	1b4a      	subs	r2, r1, r5
   34ca4:	2a0f      	cmp	r2, #15
   34ca6:	ddf2      	ble.n	34c8e <_malloc_r+0x13a>
   34ca8:	e9d3 8e02 	ldrd	r8, lr, [r3, #8]
   34cac:	195c      	adds	r4, r3, r5
   34cae:	f045 0501 	orr.w	r5, r5, #1
   34cb2:	605d      	str	r5, [r3, #4]
   34cb4:	f042 0501 	orr.w	r5, r2, #1
   34cb8:	f8c8 e00c 	str.w	lr, [r8, #12]
   34cbc:	4630      	mov	r0, r6
   34cbe:	f8ce 8008 	str.w	r8, [lr, #8]
   34cc2:	e9c7 4404 	strd	r4, r4, [r7, #16]
   34cc6:	e9c4 cc02 	strd	ip, ip, [r4, #8]
   34cca:	6065      	str	r5, [r4, #4]
   34ccc:	505a      	str	r2, [r3, r1]
   34cce:	9301      	str	r3, [sp, #4]
   34cd0:	f000 fa98 	bl	35204 <__malloc_unlock>
   34cd4:	9b01      	ldr	r3, [sp, #4]
   34cd6:	f103 0408 	add.w	r4, r3, #8
   34cda:	e763      	b.n	34ba4 <_malloc_r+0x50>
   34cdc:	2400      	movs	r4, #0
   34cde:	230c      	movs	r3, #12
   34ce0:	4620      	mov	r0, r4
   34ce2:	6033      	str	r3, [r6, #0]
   34ce4:	b003      	add	sp, #12
   34ce6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   34cea:	f44f 7300 	mov.w	r3, #512	; 0x200
   34cee:	2040      	movs	r0, #64	; 0x40
   34cf0:	f04f 0c3f 	mov.w	ip, #63	; 0x3f
   34cf4:	e773      	b.n	34bde <_malloc_r+0x8a>
   34cf6:	687b      	ldr	r3, [r7, #4]
   34cf8:	1082      	asrs	r2, r0, #2
   34cfa:	2401      	movs	r4, #1
   34cfc:	4094      	lsls	r4, r2
   34cfe:	429c      	cmp	r4, r3
   34d00:	d9b3      	bls.n	34c6a <_malloc_r+0x116>
   34d02:	68bc      	ldr	r4, [r7, #8]
   34d04:	6863      	ldr	r3, [r4, #4]
   34d06:	f023 0903 	bic.w	r9, r3, #3
   34d0a:	45a9      	cmp	r9, r5
   34d0c:	d303      	bcc.n	34d16 <_malloc_r+0x1c2>
   34d0e:	eba9 0305 	sub.w	r3, r9, r5
   34d12:	2b0f      	cmp	r3, #15
   34d14:	dc7b      	bgt.n	34e0e <_malloc_r+0x2ba>
   34d16:	4b5e      	ldr	r3, [pc, #376]	; (34e90 <_malloc_r+0x33c>)
   34d18:	f8df a188 	ldr.w	sl, [pc, #392]	; 34ea4 <_malloc_r+0x350>
   34d1c:	681a      	ldr	r2, [r3, #0]
   34d1e:	f8da 3000 	ldr.w	r3, [sl]
   34d22:	3301      	adds	r3, #1
   34d24:	eb05 0802 	add.w	r8, r5, r2
   34d28:	f000 8148 	beq.w	34fbc <_malloc_r+0x468>
   34d2c:	f508 5880 	add.w	r8, r8, #4096	; 0x1000
   34d30:	f108 080f 	add.w	r8, r8, #15
   34d34:	f428 687f 	bic.w	r8, r8, #4080	; 0xff0
   34d38:	f028 080f 	bic.w	r8, r8, #15
   34d3c:	4641      	mov	r1, r8
   34d3e:	4630      	mov	r0, r6
   34d40:	f000 fa66 	bl	35210 <_sbrk_r>
   34d44:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
   34d48:	4683      	mov	fp, r0
   34d4a:	f000 8104 	beq.w	34f56 <_malloc_r+0x402>
   34d4e:	eb04 0009 	add.w	r0, r4, r9
   34d52:	4558      	cmp	r0, fp
   34d54:	f200 80fd 	bhi.w	34f52 <_malloc_r+0x3fe>
   34d58:	4a4e      	ldr	r2, [pc, #312]	; (34e94 <_malloc_r+0x340>)
   34d5a:	6813      	ldr	r3, [r2, #0]
   34d5c:	4443      	add	r3, r8
   34d5e:	6013      	str	r3, [r2, #0]
   34d60:	f000 814d 	beq.w	34ffe <_malloc_r+0x4aa>
   34d64:	f8da 1000 	ldr.w	r1, [sl]
   34d68:	3101      	adds	r1, #1
   34d6a:	bf1b      	ittet	ne
   34d6c:	ebab 0000 	subne.w	r0, fp, r0
   34d70:	181b      	addne	r3, r3, r0
   34d72:	f8ca b000 	streq.w	fp, [sl]
   34d76:	6013      	strne	r3, [r2, #0]
   34d78:	f01b 0307 	ands.w	r3, fp, #7
   34d7c:	f000 8134 	beq.w	34fe8 <_malloc_r+0x494>
   34d80:	f1c3 0108 	rsb	r1, r3, #8
   34d84:	f5c3 5380 	rsb	r3, r3, #4096	; 0x1000
   34d88:	448b      	add	fp, r1
   34d8a:	3308      	adds	r3, #8
   34d8c:	44d8      	add	r8, fp
   34d8e:	f3c8 080b 	ubfx	r8, r8, #0, #12
   34d92:	eba3 0808 	sub.w	r8, r3, r8
   34d96:	4641      	mov	r1, r8
   34d98:	4630      	mov	r0, r6
   34d9a:	9201      	str	r2, [sp, #4]
   34d9c:	f000 fa38 	bl	35210 <_sbrk_r>
   34da0:	1c43      	adds	r3, r0, #1
   34da2:	9a01      	ldr	r2, [sp, #4]
   34da4:	f000 8146 	beq.w	35034 <_malloc_r+0x4e0>
   34da8:	eba0 010b 	sub.w	r1, r0, fp
   34dac:	4441      	add	r1, r8
   34dae:	f041 0101 	orr.w	r1, r1, #1
   34db2:	6813      	ldr	r3, [r2, #0]
   34db4:	f8c7 b008 	str.w	fp, [r7, #8]
   34db8:	4443      	add	r3, r8
   34dba:	42bc      	cmp	r4, r7
   34dbc:	f8cb 1004 	str.w	r1, [fp, #4]
   34dc0:	6013      	str	r3, [r2, #0]
   34dc2:	d015      	beq.n	34df0 <_malloc_r+0x29c>
   34dc4:	f1b9 0f0f 	cmp.w	r9, #15
   34dc8:	f240 8130 	bls.w	3502c <_malloc_r+0x4d8>
   34dcc:	6860      	ldr	r0, [r4, #4]
   34dce:	f1a9 010c 	sub.w	r1, r9, #12
   34dd2:	f021 0107 	bic.w	r1, r1, #7
   34dd6:	f000 0001 	and.w	r0, r0, #1
   34dda:	eb04 0c01 	add.w	ip, r4, r1
   34dde:	4308      	orrs	r0, r1
   34de0:	f04f 0e05 	mov.w	lr, #5
   34de4:	290f      	cmp	r1, #15
   34de6:	6060      	str	r0, [r4, #4]
   34de8:	e9cc ee01 	strd	lr, lr, [ip, #4]
   34dec:	f200 813a 	bhi.w	35064 <_malloc_r+0x510>
   34df0:	4a29      	ldr	r2, [pc, #164]	; (34e98 <_malloc_r+0x344>)
   34df2:	482a      	ldr	r0, [pc, #168]	; (34e9c <_malloc_r+0x348>)
   34df4:	6811      	ldr	r1, [r2, #0]
   34df6:	68bc      	ldr	r4, [r7, #8]
   34df8:	428b      	cmp	r3, r1
   34dfa:	6801      	ldr	r1, [r0, #0]
   34dfc:	bf88      	it	hi
   34dfe:	6013      	strhi	r3, [r2, #0]
   34e00:	6862      	ldr	r2, [r4, #4]
   34e02:	428b      	cmp	r3, r1
   34e04:	f022 0203 	bic.w	r2, r2, #3
   34e08:	bf88      	it	hi
   34e0a:	6003      	strhi	r3, [r0, #0]
   34e0c:	e0a7      	b.n	34f5e <_malloc_r+0x40a>
   34e0e:	1962      	adds	r2, r4, r5
   34e10:	f043 0301 	orr.w	r3, r3, #1
   34e14:	f045 0501 	orr.w	r5, r5, #1
   34e18:	6065      	str	r5, [r4, #4]
   34e1a:	4630      	mov	r0, r6
   34e1c:	60ba      	str	r2, [r7, #8]
   34e1e:	6053      	str	r3, [r2, #4]
   34e20:	f000 f9f0 	bl	35204 <__malloc_unlock>
   34e24:	3408      	adds	r4, #8
   34e26:	4620      	mov	r0, r4
   34e28:	b003      	add	sp, #12
   34e2a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   34e2e:	4423      	add	r3, r4
   34e30:	68e1      	ldr	r1, [r4, #12]
   34e32:	685a      	ldr	r2, [r3, #4]
   34e34:	68a5      	ldr	r5, [r4, #8]
   34e36:	f042 0201 	orr.w	r2, r2, #1
   34e3a:	60e9      	str	r1, [r5, #12]
   34e3c:	4630      	mov	r0, r6
   34e3e:	608d      	str	r5, [r1, #8]
   34e40:	605a      	str	r2, [r3, #4]
   34e42:	f000 f9df 	bl	35204 <__malloc_unlock>
   34e46:	3408      	adds	r4, #8
   34e48:	4620      	mov	r0, r4
   34e4a:	b003      	add	sp, #12
   34e4c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   34e50:	68dc      	ldr	r4, [r3, #12]
   34e52:	42a3      	cmp	r3, r4
   34e54:	bf08      	it	eq
   34e56:	3002      	addeq	r0, #2
   34e58:	f43f aed6 	beq.w	34c08 <_malloc_r+0xb4>
   34e5c:	e692      	b.n	34b84 <_malloc_r+0x30>
   34e5e:	2b14      	cmp	r3, #20
   34e60:	d971      	bls.n	34f46 <_malloc_r+0x3f2>
   34e62:	2b54      	cmp	r3, #84	; 0x54
   34e64:	f200 80ad 	bhi.w	34fc2 <_malloc_r+0x46e>
   34e68:	0b2b      	lsrs	r3, r5, #12
   34e6a:	f103 006f 	add.w	r0, r3, #111	; 0x6f
   34e6e:	f103 0c6e 	add.w	ip, r3, #110	; 0x6e
   34e72:	00c3      	lsls	r3, r0, #3
   34e74:	e6b3      	b.n	34bde <_malloc_r+0x8a>
   34e76:	4423      	add	r3, r4
   34e78:	4630      	mov	r0, r6
   34e7a:	685a      	ldr	r2, [r3, #4]
   34e7c:	f042 0201 	orr.w	r2, r2, #1
   34e80:	605a      	str	r2, [r3, #4]
   34e82:	3408      	adds	r4, #8
   34e84:	f000 f9be 	bl	35204 <__malloc_unlock>
   34e88:	e68c      	b.n	34ba4 <_malloc_r+0x50>
   34e8a:	bf00      	nop
   34e8c:	10001054 	.word	0x10001054
   34e90:	100019d4 	.word	0x100019d4
   34e94:	100019a4 	.word	0x100019a4
   34e98:	100019cc 	.word	0x100019cc
   34e9c:	100019d0 	.word	0x100019d0
   34ea0:	1000105c 	.word	0x1000105c
   34ea4:	1000145c 	.word	0x1000145c
   34ea8:	1961      	adds	r1, r4, r5
   34eaa:	f045 0e01 	orr.w	lr, r5, #1
   34eae:	f042 0501 	orr.w	r5, r2, #1
   34eb2:	f8c4 e004 	str.w	lr, [r4, #4]
   34eb6:	4630      	mov	r0, r6
   34eb8:	e9c7 1104 	strd	r1, r1, [r7, #16]
   34ebc:	e9c1 cc02 	strd	ip, ip, [r1, #8]
   34ec0:	604d      	str	r5, [r1, #4]
   34ec2:	50e2      	str	r2, [r4, r3]
   34ec4:	f000 f99e 	bl	35204 <__malloc_unlock>
   34ec8:	3408      	adds	r4, #8
   34eca:	e66b      	b.n	34ba4 <_malloc_r+0x50>
   34ecc:	08e8      	lsrs	r0, r5, #3
   34ece:	f105 0308 	add.w	r3, r5, #8
   34ed2:	e64f      	b.n	34b74 <_malloc_r+0x20>
   34ed4:	f108 0801 	add.w	r8, r8, #1
   34ed8:	f018 0f03 	tst.w	r8, #3
   34edc:	f10e 0e08 	add.w	lr, lr, #8
   34ee0:	f47f aed0 	bne.w	34c84 <_malloc_r+0x130>
   34ee4:	e052      	b.n	34f8c <_malloc_r+0x438>
   34ee6:	4419      	add	r1, r3
   34ee8:	461c      	mov	r4, r3
   34eea:	684a      	ldr	r2, [r1, #4]
   34eec:	68db      	ldr	r3, [r3, #12]
   34eee:	f854 5f08 	ldr.w	r5, [r4, #8]!
   34ef2:	f042 0201 	orr.w	r2, r2, #1
   34ef6:	604a      	str	r2, [r1, #4]
   34ef8:	4630      	mov	r0, r6
   34efa:	60eb      	str	r3, [r5, #12]
   34efc:	609d      	str	r5, [r3, #8]
   34efe:	f000 f981 	bl	35204 <__malloc_unlock>
   34f02:	e64f      	b.n	34ba4 <_malloc_r+0x50>
   34f04:	0a5a      	lsrs	r2, r3, #9
   34f06:	2a04      	cmp	r2, #4
   34f08:	d935      	bls.n	34f76 <_malloc_r+0x422>
   34f0a:	2a14      	cmp	r2, #20
   34f0c:	d86f      	bhi.n	34fee <_malloc_r+0x49a>
   34f0e:	f102 015c 	add.w	r1, r2, #92	; 0x5c
   34f12:	00c9      	lsls	r1, r1, #3
   34f14:	325b      	adds	r2, #91	; 0x5b
   34f16:	eb07 0e01 	add.w	lr, r7, r1
   34f1a:	5879      	ldr	r1, [r7, r1]
   34f1c:	f1ae 0e08 	sub.w	lr, lr, #8
   34f20:	458e      	cmp	lr, r1
   34f22:	d058      	beq.n	34fd6 <_malloc_r+0x482>
   34f24:	684a      	ldr	r2, [r1, #4]
   34f26:	f022 0203 	bic.w	r2, r2, #3
   34f2a:	429a      	cmp	r2, r3
   34f2c:	d902      	bls.n	34f34 <_malloc_r+0x3e0>
   34f2e:	6889      	ldr	r1, [r1, #8]
   34f30:	458e      	cmp	lr, r1
   34f32:	d1f7      	bne.n	34f24 <_malloc_r+0x3d0>
   34f34:	f8d1 e00c 	ldr.w	lr, [r1, #12]
   34f38:	687b      	ldr	r3, [r7, #4]
   34f3a:	e9c4 1e02 	strd	r1, lr, [r4, #8]
   34f3e:	f8ce 4008 	str.w	r4, [lr, #8]
   34f42:	60cc      	str	r4, [r1, #12]
   34f44:	e68c      	b.n	34c60 <_malloc_r+0x10c>
   34f46:	f103 005c 	add.w	r0, r3, #92	; 0x5c
   34f4a:	f103 0c5b 	add.w	ip, r3, #91	; 0x5b
   34f4e:	00c3      	lsls	r3, r0, #3
   34f50:	e645      	b.n	34bde <_malloc_r+0x8a>
   34f52:	42bc      	cmp	r4, r7
   34f54:	d072      	beq.n	3503c <_malloc_r+0x4e8>
   34f56:	68bc      	ldr	r4, [r7, #8]
   34f58:	6862      	ldr	r2, [r4, #4]
   34f5a:	f022 0203 	bic.w	r2, r2, #3
   34f5e:	4295      	cmp	r5, r2
   34f60:	eba2 0305 	sub.w	r3, r2, r5
   34f64:	d802      	bhi.n	34f6c <_malloc_r+0x418>
   34f66:	2b0f      	cmp	r3, #15
   34f68:	f73f af51 	bgt.w	34e0e <_malloc_r+0x2ba>
   34f6c:	4630      	mov	r0, r6
   34f6e:	f000 f949 	bl	35204 <__malloc_unlock>
   34f72:	2400      	movs	r4, #0
   34f74:	e616      	b.n	34ba4 <_malloc_r+0x50>
   34f76:	099a      	lsrs	r2, r3, #6
   34f78:	f102 0139 	add.w	r1, r2, #57	; 0x39
   34f7c:	00c9      	lsls	r1, r1, #3
   34f7e:	3238      	adds	r2, #56	; 0x38
   34f80:	e7c9      	b.n	34f16 <_malloc_r+0x3c2>
   34f82:	f8d9 9000 	ldr.w	r9, [r9]
   34f86:	4599      	cmp	r9, r3
   34f88:	f040 8083 	bne.w	35092 <_malloc_r+0x53e>
   34f8c:	f010 0f03 	tst.w	r0, #3
   34f90:	f1a9 0308 	sub.w	r3, r9, #8
   34f94:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
   34f98:	d1f3      	bne.n	34f82 <_malloc_r+0x42e>
   34f9a:	687b      	ldr	r3, [r7, #4]
   34f9c:	ea23 0304 	bic.w	r3, r3, r4
   34fa0:	607b      	str	r3, [r7, #4]
   34fa2:	0064      	lsls	r4, r4, #1
   34fa4:	429c      	cmp	r4, r3
   34fa6:	f63f aeac 	bhi.w	34d02 <_malloc_r+0x1ae>
   34faa:	b91c      	cbnz	r4, 34fb4 <_malloc_r+0x460>
   34fac:	e6a9      	b.n	34d02 <_malloc_r+0x1ae>
   34fae:	0064      	lsls	r4, r4, #1
   34fb0:	f108 0804 	add.w	r8, r8, #4
   34fb4:	421c      	tst	r4, r3
   34fb6:	d0fa      	beq.n	34fae <_malloc_r+0x45a>
   34fb8:	4640      	mov	r0, r8
   34fba:	e65f      	b.n	34c7c <_malloc_r+0x128>
   34fbc:	f108 0810 	add.w	r8, r8, #16
   34fc0:	e6bc      	b.n	34d3c <_malloc_r+0x1e8>
   34fc2:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
   34fc6:	d826      	bhi.n	35016 <_malloc_r+0x4c2>
   34fc8:	0beb      	lsrs	r3, r5, #15
   34fca:	f103 0078 	add.w	r0, r3, #120	; 0x78
   34fce:	f103 0c77 	add.w	ip, r3, #119	; 0x77
   34fd2:	00c3      	lsls	r3, r0, #3
   34fd4:	e603      	b.n	34bde <_malloc_r+0x8a>
   34fd6:	687b      	ldr	r3, [r7, #4]
   34fd8:	1092      	asrs	r2, r2, #2
   34fda:	f04f 0801 	mov.w	r8, #1
   34fde:	fa08 f202 	lsl.w	r2, r8, r2
   34fe2:	4313      	orrs	r3, r2
   34fe4:	607b      	str	r3, [r7, #4]
   34fe6:	e7a8      	b.n	34f3a <_malloc_r+0x3e6>
   34fe8:	f44f 5380 	mov.w	r3, #4096	; 0x1000
   34fec:	e6ce      	b.n	34d8c <_malloc_r+0x238>
   34fee:	2a54      	cmp	r2, #84	; 0x54
   34ff0:	d829      	bhi.n	35046 <_malloc_r+0x4f2>
   34ff2:	0b1a      	lsrs	r2, r3, #12
   34ff4:	f102 016f 	add.w	r1, r2, #111	; 0x6f
   34ff8:	00c9      	lsls	r1, r1, #3
   34ffa:	326e      	adds	r2, #110	; 0x6e
   34ffc:	e78b      	b.n	34f16 <_malloc_r+0x3c2>
   34ffe:	f3c0 010b 	ubfx	r1, r0, #0, #12
   35002:	2900      	cmp	r1, #0
   35004:	f47f aeae 	bne.w	34d64 <_malloc_r+0x210>
   35008:	eb09 0208 	add.w	r2, r9, r8
   3500c:	68b9      	ldr	r1, [r7, #8]
   3500e:	f042 0201 	orr.w	r2, r2, #1
   35012:	604a      	str	r2, [r1, #4]
   35014:	e6ec      	b.n	34df0 <_malloc_r+0x29c>
   35016:	f240 5254 	movw	r2, #1364	; 0x554
   3501a:	4293      	cmp	r3, r2
   3501c:	d81c      	bhi.n	35058 <_malloc_r+0x504>
   3501e:	0cab      	lsrs	r3, r5, #18
   35020:	f103 007d 	add.w	r0, r3, #125	; 0x7d
   35024:	f103 0c7c 	add.w	ip, r3, #124	; 0x7c
   35028:	00c3      	lsls	r3, r0, #3
   3502a:	e5d8      	b.n	34bde <_malloc_r+0x8a>
   3502c:	2301      	movs	r3, #1
   3502e:	f8cb 3004 	str.w	r3, [fp, #4]
   35032:	e79b      	b.n	34f6c <_malloc_r+0x418>
   35034:	2101      	movs	r1, #1
   35036:	f04f 0800 	mov.w	r8, #0
   3503a:	e6ba      	b.n	34db2 <_malloc_r+0x25e>
   3503c:	4a16      	ldr	r2, [pc, #88]	; (35098 <_malloc_r+0x544>)
   3503e:	6813      	ldr	r3, [r2, #0]
   35040:	4443      	add	r3, r8
   35042:	6013      	str	r3, [r2, #0]
   35044:	e68e      	b.n	34d64 <_malloc_r+0x210>
   35046:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
   3504a:	d814      	bhi.n	35076 <_malloc_r+0x522>
   3504c:	0bda      	lsrs	r2, r3, #15
   3504e:	f102 0178 	add.w	r1, r2, #120	; 0x78
   35052:	00c9      	lsls	r1, r1, #3
   35054:	3277      	adds	r2, #119	; 0x77
   35056:	e75e      	b.n	34f16 <_malloc_r+0x3c2>
   35058:	f44f 737e 	mov.w	r3, #1016	; 0x3f8
   3505c:	207f      	movs	r0, #127	; 0x7f
   3505e:	f04f 0c7e 	mov.w	ip, #126	; 0x7e
   35062:	e5bc      	b.n	34bde <_malloc_r+0x8a>
   35064:	f104 0108 	add.w	r1, r4, #8
   35068:	4630      	mov	r0, r6
   3506a:	9201      	str	r2, [sp, #4]
   3506c:	f000 f932 	bl	352d4 <_free_r>
   35070:	9a01      	ldr	r2, [sp, #4]
   35072:	6813      	ldr	r3, [r2, #0]
   35074:	e6bc      	b.n	34df0 <_malloc_r+0x29c>
   35076:	f240 5154 	movw	r1, #1364	; 0x554
   3507a:	428a      	cmp	r2, r1
   3507c:	d805      	bhi.n	3508a <_malloc_r+0x536>
   3507e:	0c9a      	lsrs	r2, r3, #18
   35080:	f102 017d 	add.w	r1, r2, #125	; 0x7d
   35084:	00c9      	lsls	r1, r1, #3
   35086:	327c      	adds	r2, #124	; 0x7c
   35088:	e745      	b.n	34f16 <_malloc_r+0x3c2>
   3508a:	f44f 717e 	mov.w	r1, #1016	; 0x3f8
   3508e:	227e      	movs	r2, #126	; 0x7e
   35090:	e741      	b.n	34f16 <_malloc_r+0x3c2>
   35092:	687b      	ldr	r3, [r7, #4]
   35094:	e785      	b.n	34fa2 <_malloc_r+0x44e>
   35096:	bf00      	nop
   35098:	100019a4 	.word	0x100019a4

0003509c <memmove>:
   3509c:	4288      	cmp	r0, r1
   3509e:	b4f0      	push	{r4, r5, r6, r7}
   350a0:	d90d      	bls.n	350be <memmove+0x22>
   350a2:	188b      	adds	r3, r1, r2
   350a4:	4283      	cmp	r3, r0
   350a6:	d90a      	bls.n	350be <memmove+0x22>
   350a8:	1884      	adds	r4, r0, r2
   350aa:	b132      	cbz	r2, 350ba <memmove+0x1e>
   350ac:	4622      	mov	r2, r4
   350ae:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
   350b2:	f802 4d01 	strb.w	r4, [r2, #-1]!
   350b6:	4299      	cmp	r1, r3
   350b8:	d1f9      	bne.n	350ae <memmove+0x12>
   350ba:	bcf0      	pop	{r4, r5, r6, r7}
   350bc:	4770      	bx	lr
   350be:	2a0f      	cmp	r2, #15
   350c0:	d949      	bls.n	35156 <memmove+0xba>
   350c2:	ea40 0301 	orr.w	r3, r0, r1
   350c6:	079b      	lsls	r3, r3, #30
   350c8:	d147      	bne.n	3515a <memmove+0xbe>
   350ca:	f1a2 0310 	sub.w	r3, r2, #16
   350ce:	091b      	lsrs	r3, r3, #4
   350d0:	f101 0720 	add.w	r7, r1, #32
   350d4:	eb07 1703 	add.w	r7, r7, r3, lsl #4
   350d8:	f101 0410 	add.w	r4, r1, #16
   350dc:	f100 0510 	add.w	r5, r0, #16
   350e0:	f854 6c10 	ldr.w	r6, [r4, #-16]
   350e4:	f845 6c10 	str.w	r6, [r5, #-16]
   350e8:	f854 6c0c 	ldr.w	r6, [r4, #-12]
   350ec:	f845 6c0c 	str.w	r6, [r5, #-12]
   350f0:	f854 6c08 	ldr.w	r6, [r4, #-8]
   350f4:	f845 6c08 	str.w	r6, [r5, #-8]
   350f8:	f854 6c04 	ldr.w	r6, [r4, #-4]
   350fc:	f845 6c04 	str.w	r6, [r5, #-4]
   35100:	3410      	adds	r4, #16
   35102:	42bc      	cmp	r4, r7
   35104:	f105 0510 	add.w	r5, r5, #16
   35108:	d1ea      	bne.n	350e0 <memmove+0x44>
   3510a:	3301      	adds	r3, #1
   3510c:	f002 050f 	and.w	r5, r2, #15
   35110:	011b      	lsls	r3, r3, #4
   35112:	2d03      	cmp	r5, #3
   35114:	4419      	add	r1, r3
   35116:	4403      	add	r3, r0
   35118:	d921      	bls.n	3515e <memmove+0xc2>
   3511a:	1f1f      	subs	r7, r3, #4
   3511c:	460e      	mov	r6, r1
   3511e:	462c      	mov	r4, r5
   35120:	3c04      	subs	r4, #4
   35122:	f856 cb04 	ldr.w	ip, [r6], #4
   35126:	f847 cf04 	str.w	ip, [r7, #4]!
   3512a:	2c03      	cmp	r4, #3
   3512c:	d8f8      	bhi.n	35120 <memmove+0x84>
   3512e:	1f2c      	subs	r4, r5, #4
   35130:	f024 0403 	bic.w	r4, r4, #3
   35134:	3404      	adds	r4, #4
   35136:	4423      	add	r3, r4
   35138:	4421      	add	r1, r4
   3513a:	f002 0203 	and.w	r2, r2, #3
   3513e:	2a00      	cmp	r2, #0
   35140:	d0bb      	beq.n	350ba <memmove+0x1e>
   35142:	3b01      	subs	r3, #1
   35144:	440a      	add	r2, r1
   35146:	f811 4b01 	ldrb.w	r4, [r1], #1
   3514a:	f803 4f01 	strb.w	r4, [r3, #1]!
   3514e:	4291      	cmp	r1, r2
   35150:	d1f9      	bne.n	35146 <memmove+0xaa>
   35152:	bcf0      	pop	{r4, r5, r6, r7}
   35154:	4770      	bx	lr
   35156:	4603      	mov	r3, r0
   35158:	e7f1      	b.n	3513e <memmove+0xa2>
   3515a:	4603      	mov	r3, r0
   3515c:	e7f1      	b.n	35142 <memmove+0xa6>
   3515e:	462a      	mov	r2, r5
   35160:	e7ed      	b.n	3513e <memmove+0xa2>
   35162:	bf00      	nop

00035164 <memset>:
   35164:	b4f0      	push	{r4, r5, r6, r7}
   35166:	0786      	lsls	r6, r0, #30
   35168:	d043      	beq.n	351f2 <memset+0x8e>
   3516a:	1e54      	subs	r4, r2, #1
   3516c:	2a00      	cmp	r2, #0
   3516e:	d03e      	beq.n	351ee <memset+0x8a>
   35170:	b2ca      	uxtb	r2, r1
   35172:	4603      	mov	r3, r0
   35174:	e002      	b.n	3517c <memset+0x18>
   35176:	f114 34ff 	adds.w	r4, r4, #4294967295	; 0xffffffff
   3517a:	d338      	bcc.n	351ee <memset+0x8a>
   3517c:	f803 2b01 	strb.w	r2, [r3], #1
   35180:	079d      	lsls	r5, r3, #30
   35182:	d1f8      	bne.n	35176 <memset+0x12>
   35184:	2c03      	cmp	r4, #3
   35186:	d92b      	bls.n	351e0 <memset+0x7c>
   35188:	b2cd      	uxtb	r5, r1
   3518a:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
   3518e:	2c0f      	cmp	r4, #15
   35190:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
   35194:	d916      	bls.n	351c4 <memset+0x60>
   35196:	f1a4 0710 	sub.w	r7, r4, #16
   3519a:	093f      	lsrs	r7, r7, #4
   3519c:	f103 0620 	add.w	r6, r3, #32
   351a0:	eb06 1607 	add.w	r6, r6, r7, lsl #4
   351a4:	f103 0210 	add.w	r2, r3, #16
   351a8:	e942 5504 	strd	r5, r5, [r2, #-16]
   351ac:	e942 5502 	strd	r5, r5, [r2, #-8]
   351b0:	3210      	adds	r2, #16
   351b2:	42b2      	cmp	r2, r6
   351b4:	d1f8      	bne.n	351a8 <memset+0x44>
   351b6:	f004 040f 	and.w	r4, r4, #15
   351ba:	3701      	adds	r7, #1
   351bc:	2c03      	cmp	r4, #3
   351be:	eb03 1307 	add.w	r3, r3, r7, lsl #4
   351c2:	d90d      	bls.n	351e0 <memset+0x7c>
   351c4:	461e      	mov	r6, r3
   351c6:	4622      	mov	r2, r4
   351c8:	3a04      	subs	r2, #4
   351ca:	2a03      	cmp	r2, #3
   351cc:	f846 5b04 	str.w	r5, [r6], #4
   351d0:	d8fa      	bhi.n	351c8 <memset+0x64>
   351d2:	1f22      	subs	r2, r4, #4
   351d4:	f022 0203 	bic.w	r2, r2, #3
   351d8:	3204      	adds	r2, #4
   351da:	4413      	add	r3, r2
   351dc:	f004 0403 	and.w	r4, r4, #3
   351e0:	b12c      	cbz	r4, 351ee <memset+0x8a>
   351e2:	b2c9      	uxtb	r1, r1
   351e4:	441c      	add	r4, r3
   351e6:	f803 1b01 	strb.w	r1, [r3], #1
   351ea:	429c      	cmp	r4, r3
   351ec:	d1fb      	bne.n	351e6 <memset+0x82>
   351ee:	bcf0      	pop	{r4, r5, r6, r7}
   351f0:	4770      	bx	lr
   351f2:	4614      	mov	r4, r2
   351f4:	4603      	mov	r3, r0
   351f6:	e7c5      	b.n	35184 <memset+0x20>

000351f8 <__malloc_lock>:
   351f8:	4801      	ldr	r0, [pc, #4]	; (35200 <__malloc_lock+0x8>)
   351fa:	f000 b95f 	b.w	354bc <__retarget_lock_acquire_recursive>
   351fe:	bf00      	nop
   35200:	100114c8 	.word	0x100114c8

00035204 <__malloc_unlock>:
   35204:	4801      	ldr	r0, [pc, #4]	; (3520c <__malloc_unlock+0x8>)
   35206:	f000 b95b 	b.w	354c0 <__retarget_lock_release_recursive>
   3520a:	bf00      	nop
   3520c:	100114c8 	.word	0x100114c8

00035210 <_sbrk_r>:
   35210:	b538      	push	{r3, r4, r5, lr}
   35212:	4c07      	ldr	r4, [pc, #28]	; (35230 <_sbrk_r+0x20>)
   35214:	2300      	movs	r3, #0
   35216:	4605      	mov	r5, r0
   35218:	4608      	mov	r0, r1
   3521a:	6023      	str	r3, [r4, #0]
   3521c:	f000 fab8 	bl	35790 <_sbrk>
   35220:	1c43      	adds	r3, r0, #1
   35222:	d000      	beq.n	35226 <_sbrk_r+0x16>
   35224:	bd38      	pop	{r3, r4, r5, pc}
   35226:	6823      	ldr	r3, [r4, #0]
   35228:	2b00      	cmp	r3, #0
   3522a:	d0fb      	beq.n	35224 <_sbrk_r+0x14>
   3522c:	602b      	str	r3, [r5, #0]
   3522e:	bd38      	pop	{r3, r4, r5, pc}
   35230:	100114dc 	.word	0x100114dc

00035234 <_malloc_trim_r>:
   35234:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   35236:	4f24      	ldr	r7, [pc, #144]	; (352c8 <_malloc_trim_r+0x94>)
   35238:	460c      	mov	r4, r1
   3523a:	4606      	mov	r6, r0
   3523c:	f7ff ffdc 	bl	351f8 <__malloc_lock>
   35240:	68bb      	ldr	r3, [r7, #8]
   35242:	685d      	ldr	r5, [r3, #4]
   35244:	f5c4 617e 	rsb	r1, r4, #4064	; 0xfe0
   35248:	310f      	adds	r1, #15
   3524a:	f025 0503 	bic.w	r5, r5, #3
   3524e:	4429      	add	r1, r5
   35250:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
   35254:	f021 010f 	bic.w	r1, r1, #15
   35258:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
   3525c:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
   35260:	db07      	blt.n	35272 <_malloc_trim_r+0x3e>
   35262:	2100      	movs	r1, #0
   35264:	4630      	mov	r0, r6
   35266:	f7ff ffd3 	bl	35210 <_sbrk_r>
   3526a:	68bb      	ldr	r3, [r7, #8]
   3526c:	442b      	add	r3, r5
   3526e:	4298      	cmp	r0, r3
   35270:	d004      	beq.n	3527c <_malloc_trim_r+0x48>
   35272:	4630      	mov	r0, r6
   35274:	f7ff ffc6 	bl	35204 <__malloc_unlock>
   35278:	2000      	movs	r0, #0
   3527a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   3527c:	4261      	negs	r1, r4
   3527e:	4630      	mov	r0, r6
   35280:	f7ff ffc6 	bl	35210 <_sbrk_r>
   35284:	3001      	adds	r0, #1
   35286:	d00d      	beq.n	352a4 <_malloc_trim_r+0x70>
   35288:	4b10      	ldr	r3, [pc, #64]	; (352cc <_malloc_trim_r+0x98>)
   3528a:	68ba      	ldr	r2, [r7, #8]
   3528c:	6819      	ldr	r1, [r3, #0]
   3528e:	1b2d      	subs	r5, r5, r4
   35290:	f045 0501 	orr.w	r5, r5, #1
   35294:	4630      	mov	r0, r6
   35296:	1b09      	subs	r1, r1, r4
   35298:	6055      	str	r5, [r2, #4]
   3529a:	6019      	str	r1, [r3, #0]
   3529c:	f7ff ffb2 	bl	35204 <__malloc_unlock>
   352a0:	2001      	movs	r0, #1
   352a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   352a4:	2100      	movs	r1, #0
   352a6:	4630      	mov	r0, r6
   352a8:	f7ff ffb2 	bl	35210 <_sbrk_r>
   352ac:	68ba      	ldr	r2, [r7, #8]
   352ae:	1a83      	subs	r3, r0, r2
   352b0:	2b0f      	cmp	r3, #15
   352b2:	ddde      	ble.n	35272 <_malloc_trim_r+0x3e>
   352b4:	4c06      	ldr	r4, [pc, #24]	; (352d0 <_malloc_trim_r+0x9c>)
   352b6:	4905      	ldr	r1, [pc, #20]	; (352cc <_malloc_trim_r+0x98>)
   352b8:	6824      	ldr	r4, [r4, #0]
   352ba:	f043 0301 	orr.w	r3, r3, #1
   352be:	1b00      	subs	r0, r0, r4
   352c0:	6053      	str	r3, [r2, #4]
   352c2:	6008      	str	r0, [r1, #0]
   352c4:	e7d5      	b.n	35272 <_malloc_trim_r+0x3e>
   352c6:	bf00      	nop
   352c8:	10001054 	.word	0x10001054
   352cc:	100019a4 	.word	0x100019a4
   352d0:	1000145c 	.word	0x1000145c

000352d4 <_free_r>:
   352d4:	2900      	cmp	r1, #0
   352d6:	d053      	beq.n	35380 <_free_r+0xac>
   352d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   352da:	460c      	mov	r4, r1
   352dc:	4606      	mov	r6, r0
   352de:	f7ff ff8b 	bl	351f8 <__malloc_lock>
   352e2:	f854 cc04 	ldr.w	ip, [r4, #-4]
   352e6:	4f71      	ldr	r7, [pc, #452]	; (354ac <_free_r+0x1d8>)
   352e8:	f02c 0101 	bic.w	r1, ip, #1
   352ec:	f1a4 0508 	sub.w	r5, r4, #8
   352f0:	186b      	adds	r3, r5, r1
   352f2:	68b8      	ldr	r0, [r7, #8]
   352f4:	685a      	ldr	r2, [r3, #4]
   352f6:	4298      	cmp	r0, r3
   352f8:	f022 0203 	bic.w	r2, r2, #3
   352fc:	d053      	beq.n	353a6 <_free_r+0xd2>
   352fe:	f01c 0f01 	tst.w	ip, #1
   35302:	605a      	str	r2, [r3, #4]
   35304:	eb03 0002 	add.w	r0, r3, r2
   35308:	d13b      	bne.n	35382 <_free_r+0xae>
   3530a:	f854 cc08 	ldr.w	ip, [r4, #-8]
   3530e:	6840      	ldr	r0, [r0, #4]
   35310:	eba5 050c 	sub.w	r5, r5, ip
   35314:	f107 0e08 	add.w	lr, r7, #8
   35318:	68ac      	ldr	r4, [r5, #8]
   3531a:	4574      	cmp	r4, lr
   3531c:	4461      	add	r1, ip
   3531e:	f000 0001 	and.w	r0, r0, #1
   35322:	d075      	beq.n	35410 <_free_r+0x13c>
   35324:	f8d5 c00c 	ldr.w	ip, [r5, #12]
   35328:	f8c4 c00c 	str.w	ip, [r4, #12]
   3532c:	f8cc 4008 	str.w	r4, [ip, #8]
   35330:	b360      	cbz	r0, 3538c <_free_r+0xb8>
   35332:	f041 0301 	orr.w	r3, r1, #1
   35336:	606b      	str	r3, [r5, #4]
   35338:	5069      	str	r1, [r5, r1]
   3533a:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
   3533e:	d350      	bcc.n	353e2 <_free_r+0x10e>
   35340:	0a4b      	lsrs	r3, r1, #9
   35342:	2b04      	cmp	r3, #4
   35344:	d870      	bhi.n	35428 <_free_r+0x154>
   35346:	098b      	lsrs	r3, r1, #6
   35348:	f103 0439 	add.w	r4, r3, #57	; 0x39
   3534c:	00e4      	lsls	r4, r4, #3
   3534e:	f103 0238 	add.w	r2, r3, #56	; 0x38
   35352:	1938      	adds	r0, r7, r4
   35354:	593b      	ldr	r3, [r7, r4]
   35356:	3808      	subs	r0, #8
   35358:	4298      	cmp	r0, r3
   3535a:	d078      	beq.n	3544e <_free_r+0x17a>
   3535c:	685a      	ldr	r2, [r3, #4]
   3535e:	f022 0203 	bic.w	r2, r2, #3
   35362:	428a      	cmp	r2, r1
   35364:	d971      	bls.n	3544a <_free_r+0x176>
   35366:	689b      	ldr	r3, [r3, #8]
   35368:	4298      	cmp	r0, r3
   3536a:	d1f7      	bne.n	3535c <_free_r+0x88>
   3536c:	68c3      	ldr	r3, [r0, #12]
   3536e:	e9c5 0302 	strd	r0, r3, [r5, #8]
   35372:	609d      	str	r5, [r3, #8]
   35374:	60c5      	str	r5, [r0, #12]
   35376:	4630      	mov	r0, r6
   35378:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   3537c:	f7ff bf42 	b.w	35204 <__malloc_unlock>
   35380:	4770      	bx	lr
   35382:	6840      	ldr	r0, [r0, #4]
   35384:	f000 0001 	and.w	r0, r0, #1
   35388:	2800      	cmp	r0, #0
   3538a:	d1d2      	bne.n	35332 <_free_r+0x5e>
   3538c:	6898      	ldr	r0, [r3, #8]
   3538e:	4c48      	ldr	r4, [pc, #288]	; (354b0 <_free_r+0x1dc>)
   35390:	4411      	add	r1, r2
   35392:	42a0      	cmp	r0, r4
   35394:	f041 0201 	orr.w	r2, r1, #1
   35398:	d062      	beq.n	35460 <_free_r+0x18c>
   3539a:	68db      	ldr	r3, [r3, #12]
   3539c:	60c3      	str	r3, [r0, #12]
   3539e:	6098      	str	r0, [r3, #8]
   353a0:	606a      	str	r2, [r5, #4]
   353a2:	5069      	str	r1, [r5, r1]
   353a4:	e7c9      	b.n	3533a <_free_r+0x66>
   353a6:	f01c 0f01 	tst.w	ip, #1
   353aa:	440a      	add	r2, r1
   353ac:	d107      	bne.n	353be <_free_r+0xea>
   353ae:	f854 3c08 	ldr.w	r3, [r4, #-8]
   353b2:	1aed      	subs	r5, r5, r3
   353b4:	441a      	add	r2, r3
   353b6:	e9d5 1302 	ldrd	r1, r3, [r5, #8]
   353ba:	60cb      	str	r3, [r1, #12]
   353bc:	6099      	str	r1, [r3, #8]
   353be:	4b3d      	ldr	r3, [pc, #244]	; (354b4 <_free_r+0x1e0>)
   353c0:	681b      	ldr	r3, [r3, #0]
   353c2:	f042 0101 	orr.w	r1, r2, #1
   353c6:	4293      	cmp	r3, r2
   353c8:	6069      	str	r1, [r5, #4]
   353ca:	60bd      	str	r5, [r7, #8]
   353cc:	d804      	bhi.n	353d8 <_free_r+0x104>
   353ce:	4b3a      	ldr	r3, [pc, #232]	; (354b8 <_free_r+0x1e4>)
   353d0:	4630      	mov	r0, r6
   353d2:	6819      	ldr	r1, [r3, #0]
   353d4:	f7ff ff2e 	bl	35234 <_malloc_trim_r>
   353d8:	4630      	mov	r0, r6
   353da:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   353de:	f7ff bf11 	b.w	35204 <__malloc_unlock>
   353e2:	08c9      	lsrs	r1, r1, #3
   353e4:	6878      	ldr	r0, [r7, #4]
   353e6:	1c4a      	adds	r2, r1, #1
   353e8:	2301      	movs	r3, #1
   353ea:	1089      	asrs	r1, r1, #2
   353ec:	408b      	lsls	r3, r1
   353ee:	4303      	orrs	r3, r0
   353f0:	eb07 01c2 	add.w	r1, r7, r2, lsl #3
   353f4:	f857 0032 	ldr.w	r0, [r7, r2, lsl #3]
   353f8:	607b      	str	r3, [r7, #4]
   353fa:	3908      	subs	r1, #8
   353fc:	e9c5 0102 	strd	r0, r1, [r5, #8]
   35400:	f847 5032 	str.w	r5, [r7, r2, lsl #3]
   35404:	60c5      	str	r5, [r0, #12]
   35406:	4630      	mov	r0, r6
   35408:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   3540c:	f7ff befa 	b.w	35204 <__malloc_unlock>
   35410:	2800      	cmp	r0, #0
   35412:	d145      	bne.n	354a0 <_free_r+0x1cc>
   35414:	440a      	add	r2, r1
   35416:	e9d3 1302 	ldrd	r1, r3, [r3, #8]
   3541a:	f042 0001 	orr.w	r0, r2, #1
   3541e:	60cb      	str	r3, [r1, #12]
   35420:	6099      	str	r1, [r3, #8]
   35422:	6068      	str	r0, [r5, #4]
   35424:	50aa      	str	r2, [r5, r2]
   35426:	e7d7      	b.n	353d8 <_free_r+0x104>
   35428:	2b14      	cmp	r3, #20
   3542a:	d908      	bls.n	3543e <_free_r+0x16a>
   3542c:	2b54      	cmp	r3, #84	; 0x54
   3542e:	d81e      	bhi.n	3546e <_free_r+0x19a>
   35430:	0b0b      	lsrs	r3, r1, #12
   35432:	f103 046f 	add.w	r4, r3, #111	; 0x6f
   35436:	00e4      	lsls	r4, r4, #3
   35438:	f103 026e 	add.w	r2, r3, #110	; 0x6e
   3543c:	e789      	b.n	35352 <_free_r+0x7e>
   3543e:	f103 045c 	add.w	r4, r3, #92	; 0x5c
   35442:	00e4      	lsls	r4, r4, #3
   35444:	f103 025b 	add.w	r2, r3, #91	; 0x5b
   35448:	e783      	b.n	35352 <_free_r+0x7e>
   3544a:	4618      	mov	r0, r3
   3544c:	e78e      	b.n	3536c <_free_r+0x98>
   3544e:	1093      	asrs	r3, r2, #2
   35450:	6879      	ldr	r1, [r7, #4]
   35452:	2201      	movs	r2, #1
   35454:	fa02 f303 	lsl.w	r3, r2, r3
   35458:	430b      	orrs	r3, r1
   3545a:	607b      	str	r3, [r7, #4]
   3545c:	4603      	mov	r3, r0
   3545e:	e786      	b.n	3536e <_free_r+0x9a>
   35460:	e9c7 5504 	strd	r5, r5, [r7, #16]
   35464:	e9c5 0002 	strd	r0, r0, [r5, #8]
   35468:	606a      	str	r2, [r5, #4]
   3546a:	5069      	str	r1, [r5, r1]
   3546c:	e7b4      	b.n	353d8 <_free_r+0x104>
   3546e:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
   35472:	d806      	bhi.n	35482 <_free_r+0x1ae>
   35474:	0bcb      	lsrs	r3, r1, #15
   35476:	f103 0478 	add.w	r4, r3, #120	; 0x78
   3547a:	00e4      	lsls	r4, r4, #3
   3547c:	f103 0277 	add.w	r2, r3, #119	; 0x77
   35480:	e767      	b.n	35352 <_free_r+0x7e>
   35482:	f240 5254 	movw	r2, #1364	; 0x554
   35486:	4293      	cmp	r3, r2
   35488:	d806      	bhi.n	35498 <_free_r+0x1c4>
   3548a:	0c8b      	lsrs	r3, r1, #18
   3548c:	f103 047d 	add.w	r4, r3, #125	; 0x7d
   35490:	00e4      	lsls	r4, r4, #3
   35492:	f103 027c 	add.w	r2, r3, #124	; 0x7c
   35496:	e75c      	b.n	35352 <_free_r+0x7e>
   35498:	f44f 747e 	mov.w	r4, #1016	; 0x3f8
   3549c:	227e      	movs	r2, #126	; 0x7e
   3549e:	e758      	b.n	35352 <_free_r+0x7e>
   354a0:	f041 0201 	orr.w	r2, r1, #1
   354a4:	606a      	str	r2, [r5, #4]
   354a6:	6019      	str	r1, [r3, #0]
   354a8:	e796      	b.n	353d8 <_free_r+0x104>
   354aa:	bf00      	nop
   354ac:	10001054 	.word	0x10001054
   354b0:	1000105c 	.word	0x1000105c
   354b4:	10001460 	.word	0x10001460
   354b8:	100019d4 	.word	0x100019d4

000354bc <__retarget_lock_acquire_recursive>:
   354bc:	4770      	bx	lr
   354be:	bf00      	nop

000354c0 <__retarget_lock_release_recursive>:
   354c0:	4770      	bx	lr
   354c2:	bf00      	nop

000354c4 <__udivmoddi4>:
   354c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   354c8:	9e08      	ldr	r6, [sp, #32]
   354ca:	4604      	mov	r4, r0
   354cc:	4688      	mov	r8, r1
   354ce:	2b00      	cmp	r3, #0
   354d0:	d14b      	bne.n	3556a <__udivmoddi4+0xa6>
   354d2:	428a      	cmp	r2, r1
   354d4:	4615      	mov	r5, r2
   354d6:	d967      	bls.n	355a8 <__udivmoddi4+0xe4>
   354d8:	fab2 f282 	clz	r2, r2
   354dc:	b14a      	cbz	r2, 354f2 <__udivmoddi4+0x2e>
   354de:	f1c2 0720 	rsb	r7, r2, #32
   354e2:	fa01 f302 	lsl.w	r3, r1, r2
   354e6:	fa20 f707 	lsr.w	r7, r0, r7
   354ea:	4095      	lsls	r5, r2
   354ec:	ea47 0803 	orr.w	r8, r7, r3
   354f0:	4094      	lsls	r4, r2
   354f2:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   354f6:	0c23      	lsrs	r3, r4, #16
   354f8:	fbb8 f7fe 	udiv	r7, r8, lr
   354fc:	fa1f fc85 	uxth.w	ip, r5
   35500:	fb0e 8817 	mls	r8, lr, r7, r8
   35504:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
   35508:	fb07 f10c 	mul.w	r1, r7, ip
   3550c:	4299      	cmp	r1, r3
   3550e:	d909      	bls.n	35524 <__udivmoddi4+0x60>
   35510:	18eb      	adds	r3, r5, r3
   35512:	f107 30ff 	add.w	r0, r7, #4294967295	; 0xffffffff
   35516:	f080 811b 	bcs.w	35750 <__udivmoddi4+0x28c>
   3551a:	4299      	cmp	r1, r3
   3551c:	f240 8118 	bls.w	35750 <__udivmoddi4+0x28c>
   35520:	3f02      	subs	r7, #2
   35522:	442b      	add	r3, r5
   35524:	1a5b      	subs	r3, r3, r1
   35526:	b2a4      	uxth	r4, r4
   35528:	fbb3 f0fe 	udiv	r0, r3, lr
   3552c:	fb0e 3310 	mls	r3, lr, r0, r3
   35530:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
   35534:	fb00 fc0c 	mul.w	ip, r0, ip
   35538:	45a4      	cmp	ip, r4
   3553a:	d909      	bls.n	35550 <__udivmoddi4+0x8c>
   3553c:	192c      	adds	r4, r5, r4
   3553e:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   35542:	f080 8107 	bcs.w	35754 <__udivmoddi4+0x290>
   35546:	45a4      	cmp	ip, r4
   35548:	f240 8104 	bls.w	35754 <__udivmoddi4+0x290>
   3554c:	3802      	subs	r0, #2
   3554e:	442c      	add	r4, r5
   35550:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
   35554:	eba4 040c 	sub.w	r4, r4, ip
   35558:	2700      	movs	r7, #0
   3555a:	b11e      	cbz	r6, 35564 <__udivmoddi4+0xa0>
   3555c:	40d4      	lsrs	r4, r2
   3555e:	2300      	movs	r3, #0
   35560:	e9c6 4300 	strd	r4, r3, [r6]
   35564:	4639      	mov	r1, r7
   35566:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   3556a:	428b      	cmp	r3, r1
   3556c:	d909      	bls.n	35582 <__udivmoddi4+0xbe>
   3556e:	2e00      	cmp	r6, #0
   35570:	f000 80eb 	beq.w	3574a <__udivmoddi4+0x286>
   35574:	2700      	movs	r7, #0
   35576:	e9c6 0100 	strd	r0, r1, [r6]
   3557a:	4638      	mov	r0, r7
   3557c:	4639      	mov	r1, r7
   3557e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   35582:	fab3 f783 	clz	r7, r3
   35586:	2f00      	cmp	r7, #0
   35588:	d147      	bne.n	3561a <__udivmoddi4+0x156>
   3558a:	428b      	cmp	r3, r1
   3558c:	d302      	bcc.n	35594 <__udivmoddi4+0xd0>
   3558e:	4282      	cmp	r2, r0
   35590:	f200 80fa 	bhi.w	35788 <__udivmoddi4+0x2c4>
   35594:	1a84      	subs	r4, r0, r2
   35596:	eb61 0303 	sbc.w	r3, r1, r3
   3559a:	2001      	movs	r0, #1
   3559c:	4698      	mov	r8, r3
   3559e:	2e00      	cmp	r6, #0
   355a0:	d0e0      	beq.n	35564 <__udivmoddi4+0xa0>
   355a2:	e9c6 4800 	strd	r4, r8, [r6]
   355a6:	e7dd      	b.n	35564 <__udivmoddi4+0xa0>
   355a8:	b902      	cbnz	r2, 355ac <__udivmoddi4+0xe8>
   355aa:	deff      	udf	#255	; 0xff
   355ac:	fab2 f282 	clz	r2, r2
   355b0:	2a00      	cmp	r2, #0
   355b2:	f040 808f 	bne.w	356d4 <__udivmoddi4+0x210>
   355b6:	1b49      	subs	r1, r1, r5
   355b8:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   355bc:	fa1f f885 	uxth.w	r8, r5
   355c0:	2701      	movs	r7, #1
   355c2:	fbb1 fcfe 	udiv	ip, r1, lr
   355c6:	0c23      	lsrs	r3, r4, #16
   355c8:	fb0e 111c 	mls	r1, lr, ip, r1
   355cc:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   355d0:	fb08 f10c 	mul.w	r1, r8, ip
   355d4:	4299      	cmp	r1, r3
   355d6:	d907      	bls.n	355e8 <__udivmoddi4+0x124>
   355d8:	18eb      	adds	r3, r5, r3
   355da:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
   355de:	d202      	bcs.n	355e6 <__udivmoddi4+0x122>
   355e0:	4299      	cmp	r1, r3
   355e2:	f200 80cd 	bhi.w	35780 <__udivmoddi4+0x2bc>
   355e6:	4684      	mov	ip, r0
   355e8:	1a59      	subs	r1, r3, r1
   355ea:	b2a3      	uxth	r3, r4
   355ec:	fbb1 f0fe 	udiv	r0, r1, lr
   355f0:	fb0e 1410 	mls	r4, lr, r0, r1
   355f4:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
   355f8:	fb08 f800 	mul.w	r8, r8, r0
   355fc:	45a0      	cmp	r8, r4
   355fe:	d907      	bls.n	35610 <__udivmoddi4+0x14c>
   35600:	192c      	adds	r4, r5, r4
   35602:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   35606:	d202      	bcs.n	3560e <__udivmoddi4+0x14a>
   35608:	45a0      	cmp	r8, r4
   3560a:	f200 80b6 	bhi.w	3577a <__udivmoddi4+0x2b6>
   3560e:	4618      	mov	r0, r3
   35610:	eba4 0408 	sub.w	r4, r4, r8
   35614:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
   35618:	e79f      	b.n	3555a <__udivmoddi4+0x96>
   3561a:	f1c7 0c20 	rsb	ip, r7, #32
   3561e:	40bb      	lsls	r3, r7
   35620:	fa22 fe0c 	lsr.w	lr, r2, ip
   35624:	ea4e 0e03 	orr.w	lr, lr, r3
   35628:	fa01 f407 	lsl.w	r4, r1, r7
   3562c:	fa20 f50c 	lsr.w	r5, r0, ip
   35630:	fa21 f30c 	lsr.w	r3, r1, ip
   35634:	ea4f 481e 	mov.w	r8, lr, lsr #16
   35638:	4325      	orrs	r5, r4
   3563a:	fbb3 f9f8 	udiv	r9, r3, r8
   3563e:	0c2c      	lsrs	r4, r5, #16
   35640:	fb08 3319 	mls	r3, r8, r9, r3
   35644:	fa1f fa8e 	uxth.w	sl, lr
   35648:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
   3564c:	fb09 f40a 	mul.w	r4, r9, sl
   35650:	429c      	cmp	r4, r3
   35652:	fa02 f207 	lsl.w	r2, r2, r7
   35656:	fa00 f107 	lsl.w	r1, r0, r7
   3565a:	d90b      	bls.n	35674 <__udivmoddi4+0x1b0>
   3565c:	eb1e 0303 	adds.w	r3, lr, r3
   35660:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
   35664:	f080 8087 	bcs.w	35776 <__udivmoddi4+0x2b2>
   35668:	429c      	cmp	r4, r3
   3566a:	f240 8084 	bls.w	35776 <__udivmoddi4+0x2b2>
   3566e:	f1a9 0902 	sub.w	r9, r9, #2
   35672:	4473      	add	r3, lr
   35674:	1b1b      	subs	r3, r3, r4
   35676:	b2ad      	uxth	r5, r5
   35678:	fbb3 f0f8 	udiv	r0, r3, r8
   3567c:	fb08 3310 	mls	r3, r8, r0, r3
   35680:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
   35684:	fb00 fa0a 	mul.w	sl, r0, sl
   35688:	45a2      	cmp	sl, r4
   3568a:	d908      	bls.n	3569e <__udivmoddi4+0x1da>
   3568c:	eb1e 0404 	adds.w	r4, lr, r4
   35690:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   35694:	d26b      	bcs.n	3576e <__udivmoddi4+0x2aa>
   35696:	45a2      	cmp	sl, r4
   35698:	d969      	bls.n	3576e <__udivmoddi4+0x2aa>
   3569a:	3802      	subs	r0, #2
   3569c:	4474      	add	r4, lr
   3569e:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
   356a2:	fba0 8902 	umull	r8, r9, r0, r2
   356a6:	eba4 040a 	sub.w	r4, r4, sl
   356aa:	454c      	cmp	r4, r9
   356ac:	46c2      	mov	sl, r8
   356ae:	464b      	mov	r3, r9
   356b0:	d354      	bcc.n	3575c <__udivmoddi4+0x298>
   356b2:	d051      	beq.n	35758 <__udivmoddi4+0x294>
   356b4:	2e00      	cmp	r6, #0
   356b6:	d069      	beq.n	3578c <__udivmoddi4+0x2c8>
   356b8:	ebb1 050a 	subs.w	r5, r1, sl
   356bc:	eb64 0403 	sbc.w	r4, r4, r3
   356c0:	fa04 fc0c 	lsl.w	ip, r4, ip
   356c4:	40fd      	lsrs	r5, r7
   356c6:	40fc      	lsrs	r4, r7
   356c8:	ea4c 0505 	orr.w	r5, ip, r5
   356cc:	e9c6 5400 	strd	r5, r4, [r6]
   356d0:	2700      	movs	r7, #0
   356d2:	e747      	b.n	35564 <__udivmoddi4+0xa0>
   356d4:	f1c2 0320 	rsb	r3, r2, #32
   356d8:	fa20 f703 	lsr.w	r7, r0, r3
   356dc:	4095      	lsls	r5, r2
   356de:	fa01 f002 	lsl.w	r0, r1, r2
   356e2:	fa21 f303 	lsr.w	r3, r1, r3
   356e6:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   356ea:	4338      	orrs	r0, r7
   356ec:	0c01      	lsrs	r1, r0, #16
   356ee:	fbb3 f7fe 	udiv	r7, r3, lr
   356f2:	fa1f f885 	uxth.w	r8, r5
   356f6:	fb0e 3317 	mls	r3, lr, r7, r3
   356fa:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   356fe:	fb07 f308 	mul.w	r3, r7, r8
   35702:	428b      	cmp	r3, r1
   35704:	fa04 f402 	lsl.w	r4, r4, r2
   35708:	d907      	bls.n	3571a <__udivmoddi4+0x256>
   3570a:	1869      	adds	r1, r5, r1
   3570c:	f107 3cff 	add.w	ip, r7, #4294967295	; 0xffffffff
   35710:	d22f      	bcs.n	35772 <__udivmoddi4+0x2ae>
   35712:	428b      	cmp	r3, r1
   35714:	d92d      	bls.n	35772 <__udivmoddi4+0x2ae>
   35716:	3f02      	subs	r7, #2
   35718:	4429      	add	r1, r5
   3571a:	1acb      	subs	r3, r1, r3
   3571c:	b281      	uxth	r1, r0
   3571e:	fbb3 f0fe 	udiv	r0, r3, lr
   35722:	fb0e 3310 	mls	r3, lr, r0, r3
   35726:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   3572a:	fb00 f308 	mul.w	r3, r0, r8
   3572e:	428b      	cmp	r3, r1
   35730:	d907      	bls.n	35742 <__udivmoddi4+0x27e>
   35732:	1869      	adds	r1, r5, r1
   35734:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
   35738:	d217      	bcs.n	3576a <__udivmoddi4+0x2a6>
   3573a:	428b      	cmp	r3, r1
   3573c:	d915      	bls.n	3576a <__udivmoddi4+0x2a6>
   3573e:	3802      	subs	r0, #2
   35740:	4429      	add	r1, r5
   35742:	1ac9      	subs	r1, r1, r3
   35744:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
   35748:	e73b      	b.n	355c2 <__udivmoddi4+0xfe>
   3574a:	4637      	mov	r7, r6
   3574c:	4630      	mov	r0, r6
   3574e:	e709      	b.n	35564 <__udivmoddi4+0xa0>
   35750:	4607      	mov	r7, r0
   35752:	e6e7      	b.n	35524 <__udivmoddi4+0x60>
   35754:	4618      	mov	r0, r3
   35756:	e6fb      	b.n	35550 <__udivmoddi4+0x8c>
   35758:	4541      	cmp	r1, r8
   3575a:	d2ab      	bcs.n	356b4 <__udivmoddi4+0x1f0>
   3575c:	ebb8 0a02 	subs.w	sl, r8, r2
   35760:	eb69 020e 	sbc.w	r2, r9, lr
   35764:	3801      	subs	r0, #1
   35766:	4613      	mov	r3, r2
   35768:	e7a4      	b.n	356b4 <__udivmoddi4+0x1f0>
   3576a:	4660      	mov	r0, ip
   3576c:	e7e9      	b.n	35742 <__udivmoddi4+0x27e>
   3576e:	4618      	mov	r0, r3
   35770:	e795      	b.n	3569e <__udivmoddi4+0x1da>
   35772:	4667      	mov	r7, ip
   35774:	e7d1      	b.n	3571a <__udivmoddi4+0x256>
   35776:	4681      	mov	r9, r0
   35778:	e77c      	b.n	35674 <__udivmoddi4+0x1b0>
   3577a:	3802      	subs	r0, #2
   3577c:	442c      	add	r4, r5
   3577e:	e747      	b.n	35610 <__udivmoddi4+0x14c>
   35780:	f1ac 0c02 	sub.w	ip, ip, #2
   35784:	442b      	add	r3, r5
   35786:	e72f      	b.n	355e8 <__udivmoddi4+0x124>
   35788:	4638      	mov	r0, r7
   3578a:	e708      	b.n	3559e <__udivmoddi4+0xda>
   3578c:	4637      	mov	r7, r6
   3578e:	e6e9      	b.n	35564 <__udivmoddi4+0xa0>

00035790 <_sbrk>:
   35790:	4a04      	ldr	r2, [pc, #16]	; (357a4 <_sbrk+0x14>)
   35792:	4905      	ldr	r1, [pc, #20]	; (357a8 <_sbrk+0x18>)
   35794:	6813      	ldr	r3, [r2, #0]
   35796:	2b00      	cmp	r3, #0
   35798:	bf08      	it	eq
   3579a:	460b      	moveq	r3, r1
   3579c:	4418      	add	r0, r3
   3579e:	6010      	str	r0, [r2, #0]
   357a0:	4618      	mov	r0, r3
   357a2:	4770      	bx	lr
   357a4:	100019d8 	.word	0x100019d8
   357a8:	100114e0 	.word	0x100114e0
   357ac:	86848284 	.word	0x86848284
   357b0:	8e848a84 	.word	0x8e848a84
   357b4:	96849284 	.word	0x96849284
   357b8:	9e849a84 	.word	0x9e849a84
   357bc:	a684a284 	.word	0xa684a284
   357c0:	ae84aa84 	.word	0xae84aa84
   357c4:	b684b284 	.word	0xb684b284
   357c8:	be84ba84 	.word	0xbe84ba84
   357cc:	c384c184 	.word	0xc384c184
   357d0:	c784c584 	.word	0xc784c584
   357d4:	cb84c984 	.word	0xcb84c984
   357d8:	cf84cd84 	.word	0xcf84cd84
   357dc:	d384d184 	.word	0xd384d184
   357e0:	d784d584 	.word	0xd784d584
   357e4:	db84d984 	.word	0xdb84d984
   357e8:	df84dd84 	.word	0xdf84dd84
   357ec:	e204e104 	.word	0xe204e104
   357f0:	e404e304 	.word	0xe404e304
   357f4:	e604e504 	.word	0xe604e504
   357f8:	e804e704 	.word	0xe804e704
   357fc:	ea04e904 	.word	0xea04e904
   35800:	ec04eb04 	.word	0xec04eb04
   35804:	ee04ed04 	.word	0xee04ed04
   35808:	f004ef04 	.word	0xf004ef04
   3580c:	f144f0c4 	.word	0xf144f0c4
   35810:	f244f1c4 	.word	0xf244f1c4
   35814:	f344f2c4 	.word	0xf344f2c4
   35818:	f444f3c4 	.word	0xf444f3c4
   3581c:	f544f4c4 	.word	0xf544f4c4
   35820:	f644f5c4 	.word	0xf644f5c4
   35824:	f744f6c4 	.word	0xf744f6c4
   35828:	f844f7c4 	.word	0xf844f7c4
   3582c:	f8e4f8a4 	.word	0xf8e4f8a4
   35830:	f964f924 	.word	0xf964f924
   35834:	f9e4f9a4 	.word	0xf9e4f9a4
   35838:	fa64fa24 	.word	0xfa64fa24
   3583c:	fae4faa4 	.word	0xfae4faa4
   35840:	fb64fb24 	.word	0xfb64fb24
   35844:	fbe4fba4 	.word	0xfbe4fba4
   35848:	fc64fc24 	.word	0xfc64fc24
   3584c:	fcb4fc94 	.word	0xfcb4fc94
   35850:	fcf4fcd4 	.word	0xfcf4fcd4
   35854:	fd34fd14 	.word	0xfd34fd14
   35858:	fd74fd54 	.word	0xfd74fd54
   3585c:	fdb4fd94 	.word	0xfdb4fd94
   35860:	fdf4fdd4 	.word	0xfdf4fdd4
   35864:	fe34fe14 	.word	0xfe34fe14
   35868:	fe74fe54 	.word	0xfe74fe54
   3586c:	fe9cfe8c 	.word	0xfe9cfe8c
   35870:	febcfeac 	.word	0xfebcfeac
   35874:	fedcfecc 	.word	0xfedcfecc
   35878:	fefcfeec 	.word	0xfefcfeec
   3587c:	ff1cff0c 	.word	0xff1cff0c
   35880:	ff3cff2c 	.word	0xff3cff2c
   35884:	ff5cff4c 	.word	0xff5cff4c
   35888:	ff7cff6c 	.word	0xff7cff6c
   3588c:	ff90ff88 	.word	0xff90ff88
   35890:	ffa0ff98 	.word	0xffa0ff98
   35894:	ffb0ffa8 	.word	0xffb0ffa8
   35898:	ffc0ffb8 	.word	0xffc0ffb8
   3589c:	ffd0ffc8 	.word	0xffd0ffc8
   358a0:	ffe0ffd8 	.word	0xffe0ffd8
   358a4:	fff0ffe8 	.word	0xfff0ffe8
   358a8:	0000fff8 	.word	0x0000fff8
   358ac:	797c7d7c 	.word	0x797c7d7c
   358b0:	717c757c 	.word	0x717c757c
   358b4:	697c6d7c 	.word	0x697c6d7c
   358b8:	617c657c 	.word	0x617c657c
   358bc:	597c5d7c 	.word	0x597c5d7c
   358c0:	517c557c 	.word	0x517c557c
   358c4:	497c4d7c 	.word	0x497c4d7c
   358c8:	417c457c 	.word	0x417c457c
   358cc:	3c7c3e7c 	.word	0x3c7c3e7c
   358d0:	387c3a7c 	.word	0x387c3a7c
   358d4:	347c367c 	.word	0x347c367c
   358d8:	307c327c 	.word	0x307c327c
   358dc:	2c7c2e7c 	.word	0x2c7c2e7c
   358e0:	287c2a7c 	.word	0x287c2a7c
   358e4:	247c267c 	.word	0x247c267c
   358e8:	207c227c 	.word	0x207c227c
   358ec:	1dfc1efc 	.word	0x1dfc1efc
   358f0:	1bfc1cfc 	.word	0x1bfc1cfc
   358f4:	19fc1afc 	.word	0x19fc1afc
   358f8:	17fc18fc 	.word	0x17fc18fc
   358fc:	15fc16fc 	.word	0x15fc16fc
   35900:	13fc14fc 	.word	0x13fc14fc
   35904:	11fc12fc 	.word	0x11fc12fc
   35908:	0ffc10fc 	.word	0x0ffc10fc
   3590c:	0ebc0f3c 	.word	0x0ebc0f3c
   35910:	0dbc0e3c 	.word	0x0dbc0e3c
   35914:	0cbc0d3c 	.word	0x0cbc0d3c
   35918:	0bbc0c3c 	.word	0x0bbc0c3c
   3591c:	0abc0b3c 	.word	0x0abc0b3c
   35920:	09bc0a3c 	.word	0x09bc0a3c
   35924:	08bc093c 	.word	0x08bc093c
   35928:	07bc083c 	.word	0x07bc083c
   3592c:	071c075c 	.word	0x071c075c
   35930:	069c06dc 	.word	0x069c06dc
   35934:	061c065c 	.word	0x061c065c
   35938:	059c05dc 	.word	0x059c05dc
   3593c:	051c055c 	.word	0x051c055c
   35940:	049c04dc 	.word	0x049c04dc
   35944:	041c045c 	.word	0x041c045c
   35948:	039c03dc 	.word	0x039c03dc
   3594c:	034c036c 	.word	0x034c036c
   35950:	030c032c 	.word	0x030c032c
   35954:	02cc02ec 	.word	0x02cc02ec
   35958:	028c02ac 	.word	0x028c02ac
   3595c:	024c026c 	.word	0x024c026c
   35960:	020c022c 	.word	0x020c022c
   35964:	01cc01ec 	.word	0x01cc01ec
   35968:	018c01ac 	.word	0x018c01ac
   3596c:	01640174 	.word	0x01640174
   35970:	01440154 	.word	0x01440154
   35974:	01240134 	.word	0x01240134
   35978:	01040114 	.word	0x01040114
   3597c:	00e400f4 	.word	0x00e400f4
   35980:	00c400d4 	.word	0x00c400d4
   35984:	00a400b4 	.word	0x00a400b4
   35988:	00840094 	.word	0x00840094
   3598c:	00700078 	.word	0x00700078
   35990:	00600068 	.word	0x00600068
   35994:	00500058 	.word	0x00500058
   35998:	00400048 	.word	0x00400048
   3599c:	00300038 	.word	0x00300038
   359a0:	00200028 	.word	0x00200028
   359a4:	00100018 	.word	0x00100018
   359a8:	00000008 	.word	0x00000008
   359ac:	01480158 	.word	0x01480158
   359b0:	01680178 	.word	0x01680178
   359b4:	01080118 	.word	0x01080118
   359b8:	01280138 	.word	0x01280138
   359bc:	01c801d8 	.word	0x01c801d8
   359c0:	01e801f8 	.word	0x01e801f8
   359c4:	01880198 	.word	0x01880198
   359c8:	01a801b8 	.word	0x01a801b8
   359cc:	00480058 	.word	0x00480058
   359d0:	00680078 	.word	0x00680078
   359d4:	00080018 	.word	0x00080018
   359d8:	00280038 	.word	0x00280038
   359dc:	00c800d8 	.word	0x00c800d8
   359e0:	00e800f8 	.word	0x00e800f8
   359e4:	00880098 	.word	0x00880098
   359e8:	00a800b8 	.word	0x00a800b8
   359ec:	05200560 	.word	0x05200560
   359f0:	05a005e0 	.word	0x05a005e0
   359f4:	04200460 	.word	0x04200460
   359f8:	04a004e0 	.word	0x04a004e0
   359fc:	07200760 	.word	0x07200760
   35a00:	07a007e0 	.word	0x07a007e0
   35a04:	06200660 	.word	0x06200660
   35a08:	06a006e0 	.word	0x06a006e0
   35a0c:	029002b0 	.word	0x029002b0
   35a10:	02d002f0 	.word	0x02d002f0
   35a14:	02100230 	.word	0x02100230
   35a18:	02500270 	.word	0x02500270
   35a1c:	039003b0 	.word	0x039003b0
   35a20:	03d003f0 	.word	0x03d003f0
   35a24:	03100330 	.word	0x03100330
   35a28:	03500370 	.word	0x03500370
   35a2c:	72617453 	.word	0x72617453
   35a30:	676e6974 	.word	0x676e6974
   35a34:	64756120 	.word	0x64756120
   35a38:	74206f69 	.word	0x74206f69
   35a3c:	0d747365 	.word	0x0d747365
   35a40:	00000a0a 	.word	0x00000a0a
   35a44:	6e6e6143 	.word	0x6e6e6143
   35a48:	6320746f 	.word	0x6320746f
   35a4c:	74616572 	.word	0x74616572
   35a50:	6e652065 	.word	0x6e652065
   35a54:	65646f63 	.word	0x65646f63
   35a58:	25203a72 	.word	0x25203a72
   35a5c:	000a0d73 	.word	0x000a0d73
   35a60:	7375704f 	.word	0x7375704f
   35a64:	636e6520 	.word	0x636e6520
   35a68:	7265646f 	.word	0x7265646f
   35a6c:	696e6920 	.word	0x696e6920
   35a70:	6c616974 	.word	0x6c616974
   35a74:	74617a69 	.word	0x74617a69
   35a78:	206e6f69 	.word	0x206e6f69
   35a7c:	66207369 	.word	0x66207369
   35a80:	73696e69 	.word	0x73696e69
   35a84:	21646568 	.word	0x21646568
   35a88:	000a0a0d 	.word	0x000a0a0d
   35a8c:	6f636e65 	.word	0x6f636e65
   35a90:	66206564 	.word	0x66206564
   35a94:	656c6961 	.word	0x656c6961
   35a98:	25203a64 	.word	0x25203a64
   35a9c:	000a0d73 	.word	0x000a0d73
   35aa0:	6f636e65 	.word	0x6f636e65
   35aa4:	66206564 	.word	0x66206564
   35aa8:	73696e69 	.word	0x73696e69
   35aac:	3a646568 	.word	0x3a646568
   35ab0:	20642520 	.word	0x20642520
   35ab4:	65747962 	.word	0x65747962
   35ab8:	73692073 	.word	0x73692073
   35abc:	636e6520 	.word	0x636e6520
   35ac0:	6465646f 	.word	0x6465646f
   35ac4:	000a0d2e 	.word	0x000a0d2e
   35ac8:	204d4450 	.word	0x204d4450
   35acc:	61746164 	.word	0x61746164
   35ad0:	63657220 	.word	0x63657220
   35ad4:	6964726f 	.word	0x6964726f
   35ad8:	6520676e 	.word	0x6520676e
   35adc:	2173646e 	.word	0x2173646e
   35ae0:	00000a0d 	.word	0x00000a0d

00035ae4 <g_AM_HAL_GPIO_DISABLE>:
   35ae4:	00000003                                ....

00035ae8 <g_AM_HAL_GPIO_OUTPUT>:
   35ae8:	00000403                                ....

00035aec <g_AM_HAL_GPIO_TRISTATE>:
   35aec:	00000c03                                ....

00035af0 <g_ui8Bit76Capabilities>:
   35af0:	02800101 80010180 80800101 80808080     ................
   35b00:	80808080 80808008 01800180 80808080     ................
   35b10:	80808080 01800402 01010401 80808080     ................
   35b20:	00000101                                ....

00035b24 <g_ui8Inpen>:
   35b24:	e2242323 100723a1 e1004303 3561a151     ##$..#...C..Q.a5
   35b34:	4181c525 d160b001 31a13130 1100f101     %..A..`.01.1....
   35b44:	01d121b1 300511e5 31301037 40006100     .!.....07.01.a.@
   35b54:	00003130                                01..

00035b58 <g_ui8NCEtable>:
   35b58:	13524232 60221202 21534333 20504030     2BR..."`3CS!0@P 
   35b68:	11514131 ffffffff ffffffff 60514131     1AQ.........1AQ`
   35b78:	00504030 23534333 60524232 30201000     0@P.3CS#2BR`.. 0
   35b88:	61504030 01514131 42221202 60231303     0@Pa1AQ..."B..#`
   35b98:	50201000 41211101 32221202 60331303     .. P..!A.."2..3`
   35ba8:	21514131 22524232 03534333 40201000     1AQ!2BR"3CS... @
   35bb8:	51211101 02524232 13534333 10504030     ..!Q2BR.3CS.0@P.
   35bc8:	60514131 12524232 03534333 40201000     1AQ`2BR.3CS... @
   35bd8:	61211101 52221202 33231303 30201000     ..!a.."R..#3.. 0
   35be8:	61514131 02524232 53331303 ffffffff     1AQa2BR...3S....
   35bf8:	ffffffff 61211101 50201000 61211101     ......!a.. P..!a
   35c08:	52221202 13534333 61504030 31211101     .."R3CS.0@Pa..!1
   35c18:	32221202 43231303                       .."2..#C

00035c20 <g_ui8nCEpins>:
   35c20:	02070707 00080802 01020202 01010101     ................
   35c30:	01010101 01010101 01010101 01010101     ................
   35c40:	01010101 08010101 01010008 01010101     ................
   35c50:	00000101 00007325                       ....%s..

00035c58 <g_deepsleep_button0>:
   35c58:	00001003                                ....

00035c5c <silk_delta_gain_iCDF>:
   35c5c:	cbeaf5fa 262a3247 1d1f2123 191a1b1c     ....G2*&#!......
   35c6c:	15161718 11121314 0d0e0f10 090a0b0c     ................
   35c7c:	05060708 01020304 00000000              ............

00035c88 <silk_gain_iCDF>:
   35c88:	0f2c70e0 00010203 84c0edfe 00041746     .p,.........F...
   35c98:	9be2fcff 00020b3d                       ....=...

00035ca0 <silk_LTP_gain_BITS_Q5_0>:
   35ca0:	8a8a830f adad9b9b                       ........

00035ca8 <silk_LTP_gain_BITS_Q5_1>:
   35ca8:	76735d45 8a8d8a83 969b9696 a0a6a09b     E]sv............

00035cb8 <silk_LTP_gain_BITS_Q5_2>:
   35cb8:	8d868083 91918d8d 9b9b9691 a0a09b9b     ................
   35cc8:	a6a6a0a0 c0b6adad c0c0c0b6 e0cdc0cd     ................

00035cd8 <silk_LTP_gain_BITS_Q5_ptrs>:
   35cd8:	00035ca0 00035ca8 00035cb8              .\...\...\..

00035ce4 <silk_LTP_gain_iCDF_0>:
   35ce4:	1e2b3847 00060c15                       G8+.....

00035cec <silk_LTP_gain_iCDF_1>:
   35cec:	7c90a5c7 4754606d 202a333d 00080f17     ...|m`TG=3* ....

00035cfc <silk_LTP_gain_iCDF_2>:
   35cfc:	c7d3e1f1 99a4afbb 727b848e 50586069     ..........{ri`XP
   35d0c:	32394048 1d21262c 0c101418 00020509     H@92,&!.........

00035d1c <silk_LTP_gain_iCDF_ptrs>:
   35d1c:	00035ce4 00035cec 00035cfc              .\...\...\..

00035d28 <silk_LTP_gain_vq_0>:
   35d28:	07180604 02000005 1c0c0000 f7fc0d29     ............)...
   35d38:	0e192a0f 293efe01 4125f6f7 04fa03fc     .*....>)..%A....
   35d48:	10f80742 21fd260e                       B....&.!

00035d50 <silk_LTP_gain_vq_0_gain>:
   35d50:	575a022e 62525b5d                       ..ZW][Rb

00035d58 <silk_LTP_gain_vq_1>:
   35d58:	1727160d 4024ff0c 0af9fa1b 01112b37     ..'...$@....7+..
   35d68:	01010801 354af506 4c37f4f7 03fd08f4     ......J5..7L....
   35d78:	1afc1b5d f8033b27 0b4d0002 2c16f809     ]...';....M....,
   35d88:	092807fa f909031a 04f96514 1a2af803     ..(......e....*.
   35d98:	4421f100 37fe1702 030ffe2e 291015ff     ..!D...7.......)

00035da8 <silk_LTP_gain_vq_1_gain>:
   35da8:	0c76786d 77757371 6f573b63 50706f3f     mxv.qsuwc;Wo?opP

00035db8 <silk_LTP_gain_vq_2>:
   35db8:	273d1bfa 582af505 3cfe0104 fffc0641     ..='..*X...<A...
   35dc8:	013849fb 1d5e13f7 630c00f7 ed080406     .I8...^....c....
   35dd8:	03f32e66 02030d02 4854eb09 682ef5ee     f.........TH...h
   35de8:	261208ea f0001730 0beb5346 1675f505     ...&0...FS....u.
   35df8:	7517faf8 f80303f4 f6041c5f f13c4d0f     ...u...._....M<.
   35e08:	027c04ff 542603fc 0d02e718 151f0d2a     ..|...&T....*...
   35e18:	ff2e38fc f34f23ff 5841f913 0414f2f7     .8...#O...AX....
   35e28:	14e33151 ef034b00 5c2cf705 16fd01f8     Q1...K....,\....
   35e38:	5ffa1f45 2705f429 01fc1043 3778fa00     E.._)..'C.....x7
   35e48:	7a2cf3dc 0551e804 0207030b 580a0900     ..,z..Q........X

00035e58 <silk_LTP_gain_vq_2_gain>:
   35e58:	7c7d7c7e 177e7981 7f7f7f84 857a7f7e     ~|}|.y~.....~.z.
   35e68:	76658682 567e9177 777b787c 6d6badaa     ..evw.~V|x{w..km

00035e78 <silk_LTP_per_index_iCDF>:
   35e78:	000063b3                                .c..

00035e7c <silk_LTP_vq_gain_ptrs_Q7>:
   35e7c:	00035d50 00035da8 00035e58              P]...]..X^..

00035e88 <silk_LTP_vq_ptrs_Q7>:
   35e88:	00035d28 00035d58 00035db8              (]..X]...]..

00035e94 <silk_LTP_vq_sizes>:
   35e94:	00201008                                .. .

00035e98 <silk_NLSF_CB1_NB_MB_Q8>:
   35e98:	533c230c b49d846c 200fe4ce 7d654d37     .#<Sl...... 7Me}
   35ea8:	e1c9af97 59422a13 b8a28972 190ce6d1     .....*BYr.......
   35eb8:	78614832 dfc8ac93 5a452c1a b49f8772     2Hax.....,EZr...
   35ec8:	160de1cd 826a5035 e4cdb49c 402c190f     ....5Pj.......,@
   35ed8:	a88e735a 1813dec4 7864523e d6bea891     Zs......>Rdx....
   35ee8:	4f321f16 aa977867 1d15e3cb 7c6a412d     ..2Ogx......-Aj|
   35ef8:	e0c4ab96 614b311e baa58e79 1913e5d1     .....1Kay.......
   35f08:	745d4634 dbc0a68f 4b3e221a a7917661     4F]t.....">Kav..
   35f18:	2119d9c2 715b4638 dfc4a58f 48332215     ...!8F[q....."3H
   35f28:	ab917561 1d14dec4 755a4332 ddc5a890     au......2CZu....
   35f38:	42301f16 a892755f 2118dec4 86744d33     ..0B_u.....!3Mt.
   35f48:	e0c8b49e 57461c15 aa957c6a 211ad9c2     ......FWj|.....!
   35f58:	75534035 e1ccad98 5f41221b ae9b816c     5@Su....."A_l...
   35f68:	1a14e1d2 83716348 dbc8b09a 4e3d2b22     ....Hcq....."+=N
   35f78:	b19b725d 1d17e5cd 8a7c6136 e5d1b3a3     ]r......6a|.....
   35f88:	5938261e b29e8176 1d15e7c8 6f553f31     .&8Yv.......1?Uo
   35f98:	dec1a38e 674d301b c4b39e85 2f1de8d7     .....0Mg......./
   35fa8:	977c634a eddcc6b0 4c3d2a21 ae9b795d     Jc|.....!*=L]y..
   35fb8:	351de1cf 9a887057 e3d0bcaa 54341e18     ...5Wp........4T
   35fc8:	baa69683 3025e5cb 76685440 e6c9b19c     ......%0@Thv....

00035fd8 <silk_NLSF_CB1_Wght_Q9>:
   35fd8:	090a0b51 090a090a 08ef08ef 08fc090a     Q...............
   35fe8:	08ef0917 0a140b48 093f095a 08e2090a     ....H...Z.?.....
   35ff8:	08e208e2 089208e2 092409b7 090a0924     ..........$.$...
   36008:	090a090a 09240924 0932093f 0ace0c90     ....$.$.?.2.....
   36018:	09240924 08e2090a 089f08ad 089208d5     $.$.............
   36028:	09aa099c 095a093f 095a095a 093f095a     ....?.Z.Z.Z.Z.?.
   36038:	090a0967 0bf00d97 089f084f 08e208e2     g.......O.......
   36048:	08ef08e2 08d5090a 0c450cd2 095a0a14     ..........E...Z.
   36058:	08ad08c7 0892089f 08420892 0f051000     ..........B.....
   36068:	0a3c08ad 09670a3c 095a090a 081a093f     ..<.<.g...Z.?...
   36078:	0cac0c6a 08ad093f 098209f9 090a0924     j...?.......$...
   36088:	08ad0877 0da00d0a 08920aa6 099c08d5     w...............
   36098:	093f0932 0835089f 09740932 093f0917     2.?...5.2.t...?.
   360a8:	0974095a 09740974 093f099c 0e2d0ec3     Z.t.t.t...?...-.
   360b8:	09df0982 08e2093f 08fc08e2 0800089f     ....?...........
   360c8:	0c990cb6 0b1e0a99 0917098f 08fc08fc     ................
   360d8:	084f08e2 0ce40cbf 0af60ac1 08d5098f     ..O.............
   360e8:	08c708d5 0835084f 0ba50b39 093f0a49     ....O.5.9...I.?.
   360f8:	09320967 08c70892 084208c7 0c7d0c99     g.2.......B...}.
   36108:	0a140a49 088508e2 08ad08c7 085d08ad     I.............].
   36118:	0cee0c6a 09670ab4 08e208e2 08ef08e2     j.....g.........
   36128:	08420892 0cc80c45 080d099c 09c408ef     ..B.E...........
   36138:	09b7093f 08850982 0cd20db3 0a8c090a     ?...............
   36148:	09aa0a57 095a093f 084f0924 0dcf0d5f     W...?.Z.$.O._...
   36158:	0bf00bde 079e08fc 08e208ad 08e208e2     ................
   36168:	0d260d4c 0a7f0827 09320b39 08e20974     L.&.'...9.2.t...
   36178:	09ec09aa 0da00eb0 0a64079e 09df0b51     ..........d.Q...
   36188:	093f095a 08d5099c 0cc80bd4 0b480ab4     Z.?...........H.
   36198:	086a0ab4 08ef084f 08c708ba 0e490e6f     ..j.O.......o.I.
   361a8:	07b107e9 0a8c0a64 09c40a14 093f0917     ....d.........?.
   361b8:	0d550c87 081a0932 0b480b48 09b70924     ..U.2...H.H.$...
   361c8:	087708c7 0d260d0a 0adc0b1e 086a0917     ..w...&.......j.
   361d8:	08ef08e2 080d0842 08fc0917 08770885     ....B.........w.
   361e8:	093f0885 0a8c0a49 09f90a8c 09820967     ..?.I.......g...
   361f8:	08d508ad 08ad08ad 09740924 0a8c0a2f     ........$.t./...
   36208:	0cac0bde 0b480af6 081a09aa 090a08fc     ......H.........
   36218:	094c0932 086a08ad 08ef084f 0ae909c4     2.L...j.O.......
   36228:	0a3c0ae9 093f0a14 0e810e5c 072e08ba     ..<...?.\.......
   36238:	0ac10885 0a710aa6 089f09d1 0c580ae9     ......q.......X.
   36248:	09f90aa6 09d10b1e 095a0885 088508ad     ..........Z.....

00036258 <silk_NLSF_CB1_iCDF_NB_MB>:
   36258:	8194b2d4 5255606c 3b3d4d4f 31333839     ....l`UROM=;9831
   36268:	292a2d30 22242628 0c151e1f 0001030a     0-*)(&$"........
   36278:	ecf4f5ff cbd9e1e9 a1afb0be 727d8895     ..............}r
   36288:	47515b66 232b343c 1213141c 00050b0c     f[QG<4+#........

00036298 <silk_NLSF_CB2_BITS_NB_MB_Q5>:
   36298:	83ffffff ffff9106 ecffffff ff600f5d     ............].`.
   362a8:	ffffffff 471953c2 ffffffdd 2249a2ff     .....S.G......I"
   362b8:	ffffa242 497ed2ff ffad392b 7dc9ffff     B.....~I+9.....}
   362c8:	823a3047 a6ffffff 3e39496e ffffd268     G0:.....nI9>h...
   362d8:	37417bfb ffab6444                       .{A7Dd..

000362e0 <silk_NLSF_CB2_SELECT_NB_MB>:
   362e0:	00000010 24426300 22242224 53222222     .....cB$$"$""""S
   362f0:	22342445 44466674 4466b044 55412244     E$4"tfFDD.fDD"AU
   36300:	74245444 aa8b988d d8b8bb84 a8f98489     DT$t............
   36310:	66688bb9 b2444464 aab9b9da bbbbd8f4     ..hfdDD.........
   36320:	bbbbf4aa 9b678adb 7489b9b8 88989bb7     ......g....t....
   36330:	b8b8d984 abd9a4aa a9f48b9b a4aab9b8     ................
   36340:	8adadfd8 dabc8fd6 888df4a8 8aa8aa9b     ................
   36350:	a48bdbdc 89d8cadb b9f6baa8 dbb9748b     .............t..
   36360:	64648ab9 22666486 44644444 daddcba8     ..dd.df"DDdD....
   36370:	889aa7a8 f6a44668 898b89ab 8bdbda9b     ....hF..........

00036380 <silk_NLSF_CB2_iCDF_NB_MB>:
   36380:	eefdfeff 0102030e fcfeff00 020323da     .............#..
   36390:	feff0001 043bd0fa ff000102 47c2f6fe     ......;........G
   363a0:	0001020a b7ecfcff 01020852 ebfcff00     ........R.......
   363b0:	02115ab4 f8ff0001 1e61abe0 ff000104     .Z........a.....
   363c0:	5fadecfe 00010725                       ..._%...

000363c8 <silk_NLSF_CB_NB_MB>:
   363c8:	000a0020 01642e14 00035e98 00035fd8      .....d..^..._..
   363d8:	00036258 00036408 000362e0 00036380     Xb...d...b...c..
   363e8:	00036298 000363f0                       .b...c..

000363f0 <silk_NLSF_DELTA_MIN_NB_MB_Q15>:
   363f0:	000300fa 00030006 00030003 00030004     ................
   36400:	00030003 000001cd                       ........

00036408 <silk_NLSF_PRED_NB_MB_Q8>:
   36408:	948c8ab3 97999597 524374a3 64485c3b     .........tCR;\Hd
   36418:	00005c59                                Y\..

0003641c <silk_NLSF_CB1_WB_Q8>:
   3641c:	36261707 74645545 b2a29383 efdfd0c1     ..&6EUdt........
   3642c:	3729190d 70625345 ab9d8e7f ecdccbbb     ..)7ESbp........
   3643c:	3322150f 6a5c4e3d a798887e f0e1cdb9     .."3=N\j~.......
   3644c:	3224150a 6e5f4f3f ad9d8d7e edddcdbd     ..$2?O_n~.......
   3645c:	33251411 6b594e3b a496867b f0e0cdb8     ..%3;NYk{.......
   3646c:	33200f0a 70605143 ad9e8e81 ecdcccbd     .. 3CQ`p........
   3647c:	33251508 71624f41 a89b8a7e dad1c0b3     ..%3AObq~.......
   3648c:	37220f0c 6c574e3f a7948376 ecdbcbb9     .."7?NWlv.......
   3649c:	24201310 6c5b4f38 ab9a8876 eddcccba     .. $8O[lv.......
   364ac:	3a2b1c0b 7869594a b4a59687 f1e2d3c4     ..+:JYix........
   364bc:	2e211006 6b5c4b3c a99c897b e1d6c7b9     ..!.<K\k{.......
   364cc:	2c1e130b 69594a39 a9988779 eadacaba     ...,9JYiy.......
   364dc:	2e1d130c 64584739 a5948478 e9d8c7b6     ....9GXdx.......
   364ec:	2e231711 6a5c4d38 a798867b eddeccb9     ..#.8M\j{.......
   364fc:	352d110e 6b594b3f ab978473 f0ddcebc     ..-5?KYks.......
   3650c:	281d1009 67584738 ab9a8977 eddecdbd     ...(8GXgw.......
   3651c:	30241310 69574c39 a7968476 ecdacab9     ..$09LWiv.......
   3652c:	361d110c 685e5147 a495887e edddc9b6     ...6GQ^h~.......
   3653c:	3e2f1c0f 8173614f b4a89b8e eedfd0c2     ../>Oas.........
   3654c:	2d1e0e08 6f5e4e3e af9f8f7f efdfcfc0     ...->N^o........
   3655c:	3e311e11 776b5c4f aea09184 ebdcccbe     ..1>O\kw........
   3656c:	2d24130e 6c5b4c3d ac9a8a79 eedecdbd     ..$-=L[ly.......
   3657c:	2d1f120c 6b5b4c3c ab9a8a7b ecddccbb     ...-<L[k{.......
   3658c:	2b1f110d 67534635 a7958372 eddccbb9     ...+5FSgr.......
   3659c:	2a231611 6e5d4e3a aa9b8b7d f0e0cebc     ..#*:N]n}.......
   365ac:	32220f08 73635343 b2a29283 efe0d1c1     .."2CScs........
   365bc:	4229100d 6f5f5649 a3968980 f1e1ceb7     ..)BIV_o........
   365cc:	34251911 665c4b3f a0908477 e7d4bfaf     ..%4?K\fw.......
   365dc:	41311f13 85756453 bbaea193 f2e3d5c8     ..1ASdu.........
   365ec:	44341f12 7e756758 b1a3958a efdfcfc0     ..4DXgu~........
   365fc:	3d2f1d10 776a5a4c b0a19385 f0e0d1c1     ../=LZjw........
   3660c:	3223150f 6156493d 8d81776e eddac6af     ..#2=IVanw......

0003661c <silk_NLSF_CB1_WB_Wght_Q9>:
   3661c:	0b6d0e49 0b6d0b6d 0b6d0b6d 0b6d0b6d     I.m.m.m.m.m.m.m.
   3662c:	0b6d0b6d 0b6d0b6d 0b930b93 0b1e0b6d     m.m.m.m.....m...
   3663c:	0c0d0c90 0bf00b9c 0bc20bf0 0bc20bc2     ................
   3664c:	0b930b93 0b9c0bc2 0b1e0b48 0aa60b1e     ........H.......
   3665c:	0fae0f50 0c870ba5 0b760c87 0b1e0bf0     P.........v.....
   3666c:	0cac0c32 0b1e0b6d 09f90a3c 0b6d0adc     2...m...<.....m.
   3667c:	0c7d0dbc 0c1f0bc2 0b480bcb 0b6d0b6d     ..}.......H.m.m.
   3668c:	0b6d0b6d 0b480b48 0b480b48 0ac10b48     m.m.H.H.H.H.H...
   3669c:	13be13be 0df50b76 0bf00d39 0ae90c0d     ....v...9.......
   366ac:	0c580c58 0b1e0b9c 09ec09d1 0b480ac1     X.X...........H.
   366bc:	1035114c 0ac10a8c 0bc20b9c 0b1e0b6d     L.5.........m...
   366cc:	0bcb0ba5 0b6d0b6d 0b6d0b6d 0aa60b48     ....m.m.m.m.H...
   366dc:	0bcb0e24 0bf00b9c 0b390bf0 0bf00af6     $.........9.....
   366ec:	0be70c90 0cdb0ba5 0ba50cdb 0baf0cee     ................
   366fc:	1396146b 0d0a09ec 0d390dc6 0c160c7d     k.........9.}...
   3670c:	0ba50d30 0a570a8c 0ae90a7f 0a710b1e     0.....W.......q.
   3671c:	143613d9 114c1207 0b51099c 0c870be7     ..6...L...Q.....
   3672c:	0a7f0c61 0b480ab4 0ae90b1e 0a8c0b1e     a.....H.........
   3673c:	0b480c32 0b6d0b93 0b6d0b6d 0b930b6d     2.H...m.m.m.m...
   3674c:	0b930b93 0b6d0b93 0b930b6d 0b930b93     ......m.m.......
   3675c:	0c87106a 0c1f0ba5 0b480bc2 0b6d0b48     j.........H.H.m.
   3676c:	0b390b9c 0bcb0b64 0bc20b9c 0b390c7d     ..9.d.......}.9.
   3677c:	0eb00eb0 0c1f0cac 0b480ba5 0b480b6d     ..........H.m.H.
   3678c:	0b760b9c 0ae90ae9 0b480b1e 0a640b48     ..v.......H.H.d.
   3679c:	0fae0f0e 0c320c87 0b760cac 0b930be7     ......2...v.....
   367ac:	0c0d0b93 0ae90b1e 0ae90ae9 0a140ae9     ................
   367bc:	0ff00f05 0dbc0d1d 0ab40c16 0b760bc2     ..............v.
   367cc:	0c0d0c32 0b1e0b1e 0a570a57 0af60b1e     2.......W.W.....
   367dc:	131e141b 0f050c99 0c610d71 0d550b51     ........q.a.Q.U.
   367ec:	0a8c0d7b 0a710a14 0b1e0ab4 0ac10af6     {.....q.........
   367fc:	0ecd100d 0c580cdb 0b480b6d 0b6d0b48     ......X.m.H.H.m.
   3680c:	0ab40ae9 0ab40ae9 0b1e0ae9 0af60b48     ............H...
   3681c:	13be13d9 0dd90be7 0bf00cac 0b800c0d     ................
   3682c:	0b510c1f 0ab40ab4 0b1e0ab4 0a3c0ae9     ..Q...........<.
   3683c:	10d510d5 09df0b2c 0d300c87 0c030d30     ....,.....0.0...
   3684c:	0d300c03 0b1e0bf0 0a140a57 0ac10aa6     ..0.....W.......
   3685c:	0b640bf0 0b480af6 0a7f0ab4 0c1f0b51     ..d...H.....Q...
   3686c:	0c4e0c4e 0c610c90 0bc20bf0 0b1e0b93     N.N...a.........
   3687c:	0f2a1117 0b480b6d 0b480b1e 0b1e0b1e     ..*.m.H...H.....
   3688c:	0b480b48 0b1e0b48 0b6d0b48 0b1e0b48     H.H.H...H.m.H...
   3689c:	0b640ba5 0ba50b64 0bf00ba5 0c900c32     ..d.d.......2...
   368ac:	0bf00c4e 0b9c0bc2 0b9c0b9c 0ab40b6d     N...........m...
   368bc:	10351085 0d130cee 0b930b6d 0ba50b48     ..5.....m...H...
   368cc:	0b1e0ba5 0ab40ae9 0b1e0b1e 0ae90b1e     ................
   368dc:	0fae0ff0 0bc20c1f 0b6d0b6d 0b480b6d     ........m.m.m.H.
   368ec:	0b6d0b6d 0b1e0b1e 0ae90b1e 0adc0b48     m.m.........H...
   368fc:	11df1207 0d710c61 0ba50c87 0bde0b51     ....a.q.....Q...
   3690c:	0ab40c32 0a7f0a7f 0ab40a7f 0a8c0ae9     2...............
   3691c:	10ad1035 0e490ecd 0adc0aa6 0b480b48     5.....I.....H.H.
   3692c:	0b9c0bc2 0b1e0b6d 0a7f0a7f 0b480ae9     ....m.........H.
   3693c:	0de21077 0b1e0ac1 0b480b1e 0b480b48     w.........H.H.H.
   3694c:	0b6d0b6d 0b6d0b48 0b6d0b6d 0b480b93     m.m.H.m.m.m...H.
   3695c:	13391436 0d6808d5 0d970ecd 0b1e0d13     6.9...h.........
   3696c:	0d970cee 0b510c4e 09b7099c 0b6d0ac1     ....N.Q.......m.
   3697c:	0e650d7b 0c7d0c32 0be70d1d 0c870c87     {.e.2.}.........
   3698c:	0c900ba5 0b6d0c0d 0a7f0b6d 098209ec     ......m.m.......
   3699c:	0bc20ba5 0ae90ae9 0ae90ab4 0b9c0b1e     ................
   369ac:	0c1f0bf0 0c4e0c4e 0c1f0c4e 0bc20bc2     ....N.N.N.......
   369bc:	0b390b80 0aa60a7f 0bc20adc 0dd90d68     ..9.........h...
   369cc:	0cac0d1d 0bc20bf0 0b6d0b93 0b1e0b48     ..........m.H...
   369dc:	0b800bcb 0bc20b51 0b9c0bc2 0c1f0bcb     ....Q...........
   369ec:	0bf00bf0 0b480bc2 0b6d0b1e 0b480b6d     ......H...m.m.H.
   369fc:	0f7f0f50 0c7d0bc2 0c900d1d 0cdb0cdb     P.....}.........
   36a0c:	0e780d97 0aa60d71 099c0885 0a2f0a14     ..x.q........./.

00036a1c <silk_NLSF_CB1_iCDF_WB>:
   36a1c:	b8c9cce1 9a9eafb7 73778799 636d6e71     ..........wsqnmc
   36a2c:	444f5f62 2d303234 1b1f202b 00030a12     b_OD420-+ ......
   36a3c:	e6ebfbff b6c4c9d4 97a3a6a7 686e7c8a     .............|nh
   36a4c:	464c4e5a 222d3945 060b1518 00030405     ZNLFE9-"........

00036a5c <silk_NLSF_CB2_BITS_WB_Q5>:
   36a5c:	9cffffff ffff9a04 e3ffffff ff5c0f66     ............f.\.
   36a6c:	ffffffff 481853d5 ffffffec 214c96ff     .....S.H......L!
   36a7c:	ffffd63f 4d79beff ffb9372b 89f5ffff     ?.....yM+7......
   36a8c:	8b3b2b47 ffffffff 42324283 ffffc26b     G+;......B2Bk...
   36a9c:	374c74a6 ffff7d35                       .tL75}..

00036aa4 <silk_NLSF_CB2_SELECT_WB>:
   36aa4:	00000000 01000000 44666664 60222444     ........dffDD$"`
   36ab4:	b99e6ba4 668bb9b4 22244240 20010022     .k.....f@B$"".. 
   36ac4:	bf8d8bd0 689bb998 a668ab60 84666666     .......h`.h.fff.
   36ad4:	00000001 00101000 6b4e6d50 65678bb9     ........PmNk..ge
   36ae4:	8b8dd4d0 677b99ad 00000024 01000000     ......{g$.......
   36af4:	00000030 20000000 777b8744 62456777     0...... D.{wwgEb
   36b04:	76786744 62476676 b89d8886 868b99b6     DgxvvfGb........
   36b14:	4bf8a8d0 6b798fbd 22223120 02110022     ...K..yk 1"""...
   36b24:	7b8bebd2 866989b9 b6688762 86abb764     ...{..i.b.h.d...
   36b34:	46444664 83224242 4466a640 00010224     dFDFBB".@.fD$...
   36b44:	4466a686 84422222 8b9ef6d4 66576b6b     ..fD""B.....kkWf
   36b54:	7a7ddb64 84677689 69898772 22326aab     d.}z.vg.r..i.j2"
   36b64:	8f8dd6a4 677997b9 000022c0 01000000     ......yg."......
   36b74:	bb4a6dd0 899ff986 769a6e66 65776557     .mJ.....fn.vWewe
   36b84:	24000200 23444224 6466a460 21020024     ...$$BD#`.fd$..!
   36b94:	66ae8aa7 02025464 77786b64 0018c524     ...fdT..dkxw$...

00036ba4 <silk_NLSF_CB2_iCDF_WB>:
   36ba4:	f4fdfeff 0102030c fcfeff00 020326e0     .............&..
   36bb4:	feff0001 0439d1fb ff000102 45c3f4fe     ......9........E
   36bc4:	00010204 b8e8fbff 01020754 f0feff00     ........T.......
   36bd4:	020e56ba feff0001 1e5bb2ef ff000105     .V........[.....
   36be4:	64b1e3f8 00010213                       ...d....

00036bec <silk_NLSF_CB_WB>:
   36bec:	00100020 01ab2666 0003641c 0003661c      ...f&...d...f..
   36bfc:	00036a1c 00036c38 00036aa4 00036ba4     .j..8l...j...k..
   36c0c:	00036a5c 00036c14                       \j...l..

00036c14 <silk_NLSF_DELTA_MIN_WB_Q15>:
   36c14:	00030064 00030028 00030003 000e0005     d...(...........
   36c24:	000a000e 0003000b 00090008 00030007     ................
   36c34:	0000015b                                [...

00036c38 <silk_NLSF_PRED_WB_Q8>:
   36c38:	b0a094af a4aeadb2 b6c4aeb1 44b6c0c6     ...............D
   36c48:	483c423e 765a5575 a08e9788 00009b8e     >B<HuUZv........

00036c58 <silk_LBRR_flags_2_iCDF>:
   36c58:	000096cb                                ....

00036c5c <silk_LBRR_flags_3_iCDF>:
   36c5c:	7da6c3d7 0000526e                       ...}nR..

00036c64 <silk_LBRR_flags_iCDF_ptr>:
   36c64:	00036c58 00036c5c                       Xl..\l..

00036c6c <silk_LTPScales_table_Q14>:
   36c6c:	30003ccd 00002000                       .<.0. ..

00036c74 <silk_LTPscale_iCDF>:
   36c74:	00004080                                .@..

00036c78 <silk_NLSF_EXT_iCDF>:
   36c78:	07102864 00000103                       d(......

00036c80 <silk_NLSF_interpolation_factor_iCDF>:
   36c80:	b5c0ddf3 00000000                       ........

00036c88 <silk_Quantization_Offsets_Q10>:
   36c88:	00f00064 00640020                       d... .d.

00036c90 <silk_Transition_LP_A_Q28>:
   36c90:	1e2ef346 0e4be32b 1880661f 0a1d2c1c     F...+.K..f...,..
   36ca0:	124861da 06f49ced 0b1330ec 04a590e3     .aH......0......
   36cb0:	021da4ed 036bdf0a                       ......k.

00036cb8 <silk_Transition_LP_B_Q28>:
   36cb8:	0ef2670a 1de4cd56 0ef2670a 0c825275     .g..V....g..uR..
   36cc8:	19049a59 0c825275 0a311146 146203ed     Y...uR..F.1...b.
   36cd8:	0a311146 07d702da 0fadc6f9 07d702da     F.1.............
   36ce8:	0552b622 0aa4fada 0552b622              ".R.....".R.

00036cf4 <silk_lsb_iCDF>:
   36cf4:	00000078                                x...

00036cf8 <silk_stereo_only_code_mid_iCDF>:
   36cf8:	00000040                                @...

00036cfc <silk_stereo_pred_joint_iCDF>:
   36cfc:	f5f6f7f9 cad2eaf4 aec5c8c9 37383b52     ............R;87
   36d0c:	0c162e36 07090a0b 00000000              6...........

00036d18 <silk_stereo_pred_quant_Q13>:
   36d18:	d8beca5c e29adfb6 ec78e69c fcccf47a     \.........x.z...
   36d28:	0b860334 19641388 204a1d66 35a42742     4.....d.f.J B'.5

00036d38 <silk_type_offset_VAD_iCDF>:
   36d38:	000a9ee8                                ....

00036d3c <silk_type_offset_no_VAD_iCDF>:
   36d3c:	000000e6                                ....

00036d40 <silk_uniform3_iCDF>:
   36d40:	000055ab                                .U..

00036d44 <silk_uniform4_iCDF>:
   36d44:	004080c0                                ..@.

00036d48 <silk_uniform5_iCDF>:
   36d48:	33669acd 00000000                       ..f3....

00036d50 <silk_uniform6_iCDF>:
   36d50:	5580abd5 0000002b                       ...U+...

00036d58 <silk_uniform8_iCDF>:
   36d58:	80a0c0e0 00204060                       ....`@ .

00036d60 <silk_pitch_contour_10_ms_NB_iCDF>:
   36d60:	00003f71                                q?..

00036d64 <silk_pitch_contour_10_ms_iCDF>:
   36d64:	3d5077a5 141b232f 0004090e              .wP=/#......

00036d70 <silk_pitch_contour_NB_iCDF>:
   36d70:	8a9bb0bc 2b436177 00000a1a              ....waC+....

00036d7c <silk_pitch_contour_iCDF>:
   36d7c:	a7b7c9df 6f7c8a98 464f5862 2c32383e     ......|obXOF>82,
   36d8c:	1b1f2327 10121518 080a0c0e 02030406     '#..............
   36d9c:	00000001                                ....

00036da0 <silk_pitch_delta_iCDF>:
   36da0:	cbced0d2 a8b7c1c7 344a688e 0e141b25     .........hJ4%...
   36db0:	0204060a 00000000                       ........

00036db8 <silk_pitch_lag_iCDF>:
   36db8:	e9f4fafd 8396b6d4 55626e78 28313c48     ........xnbUH<1(
   36dc8:	0f131920 08090b0d 04050607 00010203      ...............

00036dd8 <silk_max_pulses_table>:
   36dd8:	100c0a08                                ....

00036ddc <silk_pulses_per_block_BITS_Q5>:
   36ddc:	a06b391f ffffcdcd ffffffff ffffffff     .9k.............
   36dec:	2f45ffff cda66f43 ffffffff ffffffff     ..E/Co..........
   36dfc:	ffffffff 5f4f4a52 a091806d cdcdcdad     ....RJO_m.......
   36e0c:	e0ffffe0 4a7de0ff 8d61453b ffffffb6     ......}J;Ea.....
   36e1c:	ffffffff ffffffff 495573ad 91735c4c     .........sUIL\s.
   36e2c:	e0e0cdad ffffffff 86a6ffff 66656671     ............qfef
   36e3c:	8a7d766b b6a69b91 96cdc0c0 6586b6e0     kv}............e
   36e4c:	61554f53 cdad9178 ffffffe0 e0ffffff     SOUax...........
   36e5c:	657896c0 665d595c b6a08676 e0e0e0c0     ..xe\Y]fv.......
   36e6c:	b6e0e0ff 6d76869b 6f6a6668 a0918376     ......vmhfjov...
   36e7c:	000083ad                                ....

00036e80 <silk_pulses_per_block_iCDF>:
   36e80:	121a337d 0a0b0c0f 06070809 02030405     }3..............
   36e90:	69c60001 0c0f162d 08090a0b 04050607     ...i-...........
   36ea0:	00010203 5374a2d5 18202b3b 090c0f12     ......tS;+ .....
   36eb0:	03050607 bbef0002 101c3b74 08090a0b     ........t;......
   36ec0:	04050607 00010203 87bce5fa 131e3356     ............V3..
   36ed0:	06080a0d 02030405 ebf90001 809cb9d5     ................
   36ee0:	35425367 151a212a 000a0d11 ceebf9fe     gSB5*!..........
   36ef0:	2e4d76a4 070a101b 02030405 fdff0001     .vM.............
   36f00:	bfdceff9 3955779c 0a0f1725 00020406     .....wU9%.......
   36f10:	f6fbfdff b3cbdfed 4b627c98 151d2837     .........|bK7(..
   36f20:	feff000f a2dcf7fd 1c2a436a 06090c12     ........jC*.....
   36f30:	00020304                                ....

00036f34 <silk_rate_levels_BITS_Q5>:
   36f34:	4f8d4a83 685f8a50 5b635f86 7b4c5d7d     .J.OP._h._c[}]L{
   36f44:	00007b73                                s{..

00036f48 <silk_rate_levels_iCDF>:
   36f48:	84b2bef1 0e294a57 9dc1df00 27396a8c     ....WJ)......j9'
   36f58:	00000012                                ....

00036f5c <silk_shell_code_table0>:
   36f5c:	2ad60080 1580eb00 48b8f400 d6f8000b     ...*.......H....
   36f6c:	00072a80 50aae1f8 fb000519 367ec6ec     .*.....P......~6
   36f7c:	fa000312 529fd3ee 00050f23 a8cbe7fa     .......R#.......
   36f8c:	19355880 eefc0006 6c94b9d8 04122847     .X5........lG(..
   36f9c:	e1f3fd00 5a80a6c7 030d1f39 e9f6fe00     .......Z9.......
   36fac:	6d93b7d4 0a172c49 faff0002 a6c6dff0     ...mI,..........
   36fbc:	213a5a80 00010610 e7f4fbff 6e92b5d2     .Z:!...........n
   36fcc:	0c192e4b ff000105 ddeef8fd 5c80a4c4     K..............\
   36fdc:	0812233c ff000103 e5f2f9fd 6e92b4d0     <#.............n
   36fec:	0e1b304c 00010307                       L0......

00036ff4 <silk_shell_code_table1>:
   36ff4:	32cf0081 1481ec00 48b9f500 d5f9000a     ...2.......H....
   37004:	00062a81 57a9e2fa fb00041b 3e82c2e9     .*.....W.......>
   37014:	fa000414 63a0cfec 0003112f b6d9f0ff     .......c/.......
   37024:	0b295183 feff0001 6b9fc9e9 0102143d     .Q)........k=...
   37034:	e9f9ff00 5680aace 01071732 eefaff00     .......V2.......
   37044:	6c94bad9 06122746 fcff0001 a6c8e2f3     ...lF'..........
   37054:	1e385a80 0001040d e7f5fcff 6e92b4d1     .Z8............n
   37064:	0b192f4c ff000104 dbedf8fd 5d80a3c2     L/.............]
   37074:	0813253e ff000103 e2f1fafe 6f91b1cd     >%.............o
   37084:	0f1e334f 00010206                       O3......

0003708c <silk_shell_code_table2>:
   3708c:	36cb0081 1781ea00 49b8f500 d7fa000a     ...6.......I....
   3709c:	00052981 56ade8fc fd000318 3881c8f0     .).....V.......8
   370ac:	fd00020f 5ea4d9f4 00010a26 bde2f5fd     .......^&.......
   370bc:	071b4784 f6fd0001 699fcbe7 01061738     .G.........i8...
   370cc:	ebf8ff00 5585b3d5 0105132f f3feff00     .......U/.......
   370dc:	759fc2dd 020c2546 feff0001 abd0eaf8     ...uF%..........
   370ec:	16305580 00010208 f0fafeff 6b95bddc     .U0............k
   370fc:	06102443 ff000102 e3f3fbfe 5a80a6c9     C$.............Z
   3710c:	050d1d37 ff000102 eaf6fcfe 6d93b7d5     7..............m
   3711c:	0a162b49 00010204                       I+......

00037124 <silk_shell_code_table3>:
   37124:	3ac80082 1a82e700 4cb8f400 d6f9000c     ...:.......L....
   37134:	00062b82 57ade8fc fd000318 3883cbf1     .+.....W.......8
   37144:	fe00020e 5ea7ddf6 00010823 c1e8f9fe     .......^#.......
   37154:	05174182 fbff0001 63a2d3ef 01040f2d     .A.........c-...
   37164:	f3fbff00 4a83badf 01030b21 f5fcff00     .......J!.......
   37174:	699ecae6 02081839 fdff0001 b3d6ebf7     ...i9...........
   37184:	132c5484 00010207 f0fafeff 709fc4df     .T,............p
   37194:	060f2445 ff000102 e7f5fdfe 5d88b0d1     E$.............]
   371a4:	030b1b37 ff000102 effcfdfe 759ec2dd     7..............u
   371b4:	04122a4c 00010203                       L*......

000371bc <silk_shell_code_table_offsets>:
   371bc:	05020000 1b140e09 41362c23 77685a4d     ........#,6AMZhw
   371cc:	00000087                                ....

000371d0 <silk_sign_iCDF>:
   371d0:	4d4331fe c6635d52 1f18120b 2eff2d24     .1CMR]c.....$-..
   371e0:	5e574e42 150ed068 42332a20 6d685eff     BNW^h... *3B.^hm
   371f0:	f8767370 58504535 0000665f              psv.5EPX_f..

000371fc <tiltWeights>:
   371fc:	00007530 00001770 ffffd120 ffffd120     0u..p... ... ...

0003720c <silk_TargetRate_MB_21>:
   3720c:	2b1c0000 46413b34 55514e4a 5f5d5a57     ...+4;AFJNQUWZ]_
   3721c:	69666462 716f6d6b 78767473 7f7d7b7a     bdfikmoqstvxz{}.
   3722c:	85838280 8a898886 908f8d8c 95949391     ................
   3723c:	9a999897 9f9e9d9c a4a3a2a0 a8a7a6a5     ................
   3724c:	adacaba9 b1b0afae b5b4b3b2 b9b8b7b6     ................
   3725c:	bcbcbbba c0bfbebd c4c3c2c1 c8c7c6c5     ................
   3726c:	cbcbcac9 cfcecdcc d3d2d1d0 d6d6d5d4     ................
   3727c:	dad9d8d7 dedddcdb e1e0e0df e5e4e3e2     ................
   3728c:	e9e8e7e6 ececebea f0efeeed f4f3f2f1     ................
   3729c:	f8f7f6f5 fcfbfaf9 00fffefd              ............

000372a8 <silk_TargetRate_NB_21>:
   372a8:	34270f00 4f4a443d 5f5c5854 6c696663     ..'4=DJOTX\_cfil
   372b8:	7775726f 817e7c7a 89878583 918f8e8b     oruwz|~.........
   372c8:	99979593 a09e9d9b a7a5a3a2 adabaaa8     ................
   372d8:	b3b1b0ae b9b7b6b4 bebdbbba c4c2c1c0     ................
   372e8:	c9c8c7c5 cfcdcccb d4d3d1d0 d9d8d7d5     ................
   372f8:	dfdddcdb e4e3e1e0 eae8e7e6 efeeeceb     ................
   37308:	f5f3f2f1 faf9f8f6 00fffdfc              ............

00037314 <silk_TargetRate_WB_21>:
   37314:	08000000 3831291d 4a46423e 5653504d     .....)18>BFJMPSV
   37324:	5f5d5b58 67656361 6e6c6b69 74737170     X[]_acegiklnpqst
   37334:	7a797776 7f7e7d7b 84838281 89888786     vwyz{}~.........
   37344:	8e8d8c8a 9291908f 96959493 9a999897     ................
   37354:	9f9e9d9c a2a1a09f a6a5a4a3 aaa9a8a7     ................
   37364:	adacabab b1b0afae b4b3b2b1 b7b6b5b5     ................
   37374:	bab9b9b8 bdbdbcbb c0c0bfbe c3c3c2c1     ................
   37384:	c6c6c5c4 c9c8c8c7 cccbcbca cfcececd     ................
   37394:	d2d1d1d0 d5d4d3d3 d8d7d6d6 dbdad9d8     ................
   373a4:	dddddcdb e0e0dfde e3e2e2e1 e6e5e5e4     ................
   373b4:	e9e8e8e7 ecebeaea efeeeded f2f1f0f0     ................
   373c4:	f5f4f3f3 f8f7f6f6 fbfaf9f9 00fffdfc     ................

000373d4 <silk_LSFCosTab_FIX_Q12>:
   373d4:	1ffe2000 1fea1ff6 1fc21fd8 1f881fa8     . ..............
   373e4:	1f3a1f62 1ed81f0a 1e621ea0 1ddc1e22     b.:.......b."...
   373f4:	1d421d90 1c961cee 1bd81c3a 1b0a1b72     ..B.....:...r...
   37404:	1a2a1a9c 193a19b4 183c18bc 172e17b6     ..*...:...<.....
   37414:	161016a0 14e8157e 13b0144e 126e1310     ....~...N.....n.
   37424:	111e11c8 0fc61074 0e640f16 0cf80dae     ....t.....d.....
   37434:	0b840c40 0a0a0ac8 088a094a 070207c6     @.......J.......
   37444:	0578063e 03ea04b2 025a0322 00ca0192     >.x.....".Z.....
   37454:	ff360000 fda6fe6e fc16fcde fa88fb4e     ..6.n.......N...
   37464:	f8fef9c2 f776f83a f5f6f6b6 f47cf538     ....:.v.....8.|.
   37474:	f308f3c0 f19cf252 f03af0ea eee2ef8c     ....R.....:.....
   37484:	ed92ee38 ec50ecf0 eb18ebb2 e9f0ea82     8.....P.........
   37494:	e8d2e960 e7c4e84a e6c6e744 e5d6e64c     `...J...D...L...
   374a4:	e4f6e564 e428e48e e36ae3c6 e2bee312     d.....(...j.....
   374b4:	e224e270 e19ee1de e128e160 e0c6e0f6     p.$.....`.(.....
   374c4:	e078e09e e03ee058 e016e028 e002e00a     ..x.X.>.(.......
   374d4:	0000e000                                ....

000374d8 <ordering10.7260>:
   374d8:	03060900 01080504 00000702              ............

000374e4 <ordering16.7259>:
   374e4:	07080f00 030c0b04 050a0d02 010e0906     ................

000374f4 <silk_CB_lags_stage2>:
   374f4:	ffff0200 010000ff 00010001 00000001     ................
   37504:	00010000 00000000 00000001 00000001     ................
   37514:	02ff0000 01010001 ffff0000              ............

00037520 <silk_CB_lags_stage2_10_ms>:
   37520:	00000100 00000100                       ........

00037528 <silk_CB_lags_stage3>:
   37528:	ff010000 00ff0100 02fe01ff fd02fefe     ................
   37538:	fcfd0302 0404fc03 fbfa05fb 0506f906     ................
   37548:	0000f708 00000001 00000000 000001ff     ................
   37558:	0100ff01 ff01ffff 02ff0102 fe02fefe     ................
   37568:	fd030202 00000100 00000000 00010001     ................
   37578:	01ff0100 01020000 ffff02ff 0202ff02     ................
   37588:	fefe03ff 010003fe 00010000 ff02ff01     ................
   37598:	0302ff02 fefe03fe 05fd0404 fc06fcfd     ................
   375a8:	08fb0506 09f9fbfa                       ........

000375b0 <silk_CB_lags_stage3_10_ms>:
   375b0:	ff010000 fe02ff01 fd03fe02 01000100     ................
   375c0:	02ff02ff 03fe03fe                       ........

000375c8 <silk_Lag_range_stage3>:
   375c8:	06ff08fb 0afc06ff 06fe0afa 0afb06ff     ................
   375d8:	07fd0cf7 0df907fe                       ........

000375e0 <silk_Lag_range_stage3_10_ms>:
   375e0:	07fe07fd                                ....

000375e4 <silk_nb_cbk_searchs_stage3>:
   375e4:	00221810                                ..".

000375e8 <delay_matrix_dec>:
   375e8:	00020004 04090000 03000407 0007070c     ................

000375f8 <delay_matrix_enc>:
   375f8:	00030006 01000307 0602000a 000c0a12     ................

00037608 <silk_Resampler_1_2_COEFS>:
   37608:	c80d0268 0027fff6 ffd2003a 0078ffac     h.....'.:.....x.
   37618:	fec500b8 0504fde3 23401504              ..........@#

00037624 <silk_Resampler_1_3_COEFS>:
   37624:	c4c63ee6 0000fff3 001a0014 ffe10005     .>..............
   37634:	fffcffd5 005a0041 ff630007 ffd4ff08     ....A.Z...c.....
   37644:	062f0251 0cc70a34                       Q./.4...

0003764c <silk_Resampler_1_4_COEFS>:
   3764c:	c50557e4 fff20003 fff1ffec 00190002     .W..............
   3765c:	00190025 ffb9fff0 ffb1ff95 01240032     %...........2.$.
   3766c:	03d6026f 05b80508                       o.......

00037674 <silk_Resampler_1_6_COEFS>:
   37674:	c4676b94 000c0011 00010008 ffeafff6     .kg.............
   37684:	ffe0ffe2 0003ffea 0064002c 00f300a8     ........,.d.....
   37694:	017d013d 01c701ad                       =.}.....

0003769c <silk_Resampler_2_3_COEFS>:
   3769c:	c93dc787 00800040 0024ff86 fd000136     ..=.@.....$.6...
   376ac:	24330248 000c4545 00120080 0120ff72     H.3$EE......r. .
   376bc:	fc9fff8b 387b101b                       ......{8

000376c4 <silk_Resampler_2_3_COEFS_LQ>:
   376c4:	e695f513 29f31259 2054061f              ....Y..)..T 

000376d0 <silk_Resampler_3_4_COEFS>:
   376d0:	c9d5af2a 0040ffcf ff630011 fe100161     *.....@...c.a...
   376e0:	2b2700a3 ffd956bd 005b0006 00baff56     ..'+.V....[.V...
   376f0:	fc800017 4dd818c0 ffdcffed ffa70066     .......M....f...
   37700:	0148ffe8 0a08fc49 00003e25              ..H.I...%>..

0003770c <silk_resampler_frac_FIR_12>:
   3770c:	fda800bd 77670269 ff610075 7408fbd2     ....i.gwu.a....t
   3771c:	00dd0034 6e74f6a8 0211fffc 66e5f2ea     4.....tn.......f
   3772c:	02f6ffd0 5da5f08c 0389ffb0 5306ef75     .......]....u..S
   3773c:	03ccff9d 4766ef82 03c7ff95 3b27f08b     ......fG......';
   3774c:	0380ff99 2eaef261 0305ffa5 225ef4cf     ....a.........^"
   3775c:	0263ffb9 1698f7a1 01a9ffd2 0bb4faa1     ..c.............

0003776c <sigm_LUT_neg_Q15>:
   3776c:	00004000 0000226c 00000f42 00000612     .@..l"..B.......
   3777c:	0000024d 000000db                       M.......

00037784 <sigm_LUT_pos_Q15>:
   37784:	00004000 00005d93 000070bd 000079ed     .@...]...p...y..
   37794:	00007db2 00007f24                       .}..$...

0003779c <sigm_LUT_slope_Q10>:
   3779c:	000000ed 00000099 00000049 0000001e     ........I.......
   377ac:	0000000c 00000007                       ........

000377b4 <freq_table_Q16>:
   377b4:	264c2f4f 1bbc202b 15bd185f 11df139e     O/L&+ .._.......
   377c4:	0f2d106a 0d2f0e1c 0ba80c5f 0a720b04     j.-.../._.....r.
   377d4:	097609ee 08a60909 07f6084b 076107a9     ..v.....K.....a.
   377e4:	06e0071e 000006a6                       ........

000377ec <bit_deinterleave_table.8115>:
   377ec:	0f0c0300 3f3c3330 cfccc3c0 fffcf3f0     ....03<?........

000377fc <bit_interleave_table.8105>:
   377fc:	01010100 03030302 03030302 03030302     ................

0003780c <exp2_table8.7946>:
   3780c:	45ca4000 52ff4c1b 62b35a82 75606ba2     .@.E.L.R.Z.b.k`u

0003781c <ordery_table>:
   3781c:	00000001 00000000 00000003 00000000     ................
   3782c:	00000002 00000001 00000007 00000000     ................
   3783c:	00000004 00000003 00000006 00000001     ................
   3784c:	00000005 00000002 0000000f 00000000     ................
   3785c:	00000008 00000007 0000000c 00000003     ................
   3786c:	0000000b 00000004 0000000e 00000001     ................
   3787c:	00000009 00000006 0000000d 00000002     ................
   3788c:	0000000a 00000005                       ........

00037894 <error_strings.7732>:
   37894:	000378d8 000378e0 000378f4 00037908     .x...x...x...y..
   378a4:	00037918 0003792c 00037944 00037954     .y..,y..Dy..Ty..

000378b4 <gains.7712>:
   378b4:	1bc82740 3b601098 00002250 0cd06660     @'....`;P"..`f..
   378c4:	00000000 6e6b6e75 206e776f 6f727265     ....unknown erro
   378d4:	00000072 63637573 00737365 61766e69     r...success.inva
   378e4:	2064696c 75677261 746e656d 00000000     lid argument....
   378f4:	66667562 74207265 73206f6f 6c6c616d     buffer too small
   37904:	00000000 65746e69 6c616e72 72726520     ....internal err
   37914:	0000726f 72726f63 65747075 74732064     or..corrupted st
   37924:	6d616572 00000000 75716572 20747365     ream....request 
   37934:	20746f6e 6c706d69 6e656d65 00646574     not implemented.
   37944:	61766e69 2064696c 74617473 00000065     invalid state...
   37954:	6f6d656d 61207972 636f6c6c 6f697461     memory allocatio
   37964:	6166206e 64656c69 00000000              n failed....

00037970 <tf_select_table>:
   37970:	ff00ff00 ff00ff00 fe00ff00 ff010001     ................
   37980:	fd00fe00 ff010002 fd00fe00 ff010003     ................

00037990 <intensity_histeresis.8353>:
   37990:	00010001 00010001 00010001 00020001     ................
   379a0:	00020002 00020002 00020002 00030003     ................
   379b0:	00050004 00080006 00000008              ............

000379bc <intensity_thresholds.8352>:
   379bc:	00020001 00040003 00060005 00080007     ................
   379cc:	00180010 002c0024 00380032 0043003e     ....$.,.2.8.>.C.
   379dc:	004f0048 006a0058 00000086              H.O.X.j.....

000379e8 <inv_table.7743>:
   379e8:	6e9cffff 333b4656 2125282d 191a1c1f     ...nVF;3-(%!....
   379f8:	14151617 10111213 0e0f0f10 0c0c0d0d     ................
   37a08:	0b0b0c0c 0a0a0a0b 09090909 08080909     ................
   37a18:	07080808 07070707 06060607 06060606     ................
   37a28:	06060606 06060606 05050506 05050505     ................
   37a38:	05050505 04040405 04040404 04040404     ................
   37a48:	04040404 04040404 04040404 03030404     ................
   37a58:	03030303 03030303 03030303 02030303     ................

00037a68 <spread_icdf>:
   37a68:	00021719                                ....

00037a6c <tapset_icdf>:
   37a6c:	00000102                                ....

00037a70 <trim_icdf>:
   37a70:	6d777c7e 09132957 00000204              ~|wmW)......

00037a7c <CELT_PVQ_U_DATA>:
   37a7c:	00000001 00000000 00000000 00000000     ................
	...
   37d40:	00000001 00000001 00000001 00000001     ................
   37d50:	00000001 00000001 00000001 00000001     ................
   37d60:	00000001 00000001 00000001 00000001     ................
   37d70:	00000001 00000001 00000001 00000001     ................
   37d80:	00000001 00000001 00000001 00000001     ................
   37d90:	00000001 00000001 00000001 00000001     ................
   37da0:	00000001 00000001 00000001 00000001     ................
   37db0:	00000001 00000001 00000001 00000001     ................
   37dc0:	00000001 00000001 00000001 00000001     ................
   37dd0:	00000001 00000001 00000001 00000001     ................
   37de0:	00000001 00000001 00000001 00000001     ................
   37df0:	00000001 00000001 00000001 00000001     ................
   37e00:	00000001 00000001 00000001 00000001     ................
   37e10:	00000001 00000001 00000001 00000001     ................
   37e20:	00000001 00000001 00000001 00000001     ................
   37e30:	00000001 00000001 00000001 00000001     ................
   37e40:	00000001 00000001 00000001 00000001     ................
   37e50:	00000001 00000001 00000001 00000001     ................
   37e60:	00000001 00000001 00000001 00000001     ................
   37e70:	00000001 00000001 00000001 00000001     ................
   37e80:	00000001 00000001 00000001 00000001     ................
   37e90:	00000001 00000001 00000001 00000001     ................
   37ea0:	00000001 00000001 00000001 00000001     ................
   37eb0:	00000001 00000001 00000001 00000001     ................
   37ec0:	00000001 00000001 00000001 00000001     ................
   37ed0:	00000001 00000001 00000001 00000001     ................
   37ee0:	00000001 00000001 00000001 00000001     ................
   37ef0:	00000001 00000001 00000001 00000001     ................
   37f00:	00000001 00000001 00000001 00000001     ................
   37f10:	00000001 00000001 00000001 00000001     ................
   37f20:	00000001 00000001 00000001 00000001     ................
   37f30:	00000001 00000001 00000001 00000001     ................
   37f40:	00000001 00000001 00000001 00000001     ................
   37f50:	00000001 00000001 00000001 00000001     ................
   37f60:	00000001 00000001 00000001 00000001     ................
   37f70:	00000001 00000001 00000001 00000001     ................
   37f80:	00000001 00000001 00000001 00000001     ................
   37f90:	00000001 00000001 00000001 00000001     ................
   37fa0:	00000001 00000001 00000001 00000001     ................
   37fb0:	00000001 00000001 00000001 00000001     ................
   37fc0:	00000001 00000001 00000001 00000001     ................
   37fd0:	00000001 00000001 00000001 00000001     ................
   37fe0:	00000001 00000001 00000001 00000001     ................
   37ff0:	00000001 00000001 00000001 00000001     ................
   38000:	00000003 00000005 00000007 00000009     ................
   38010:	0000000b 0000000d 0000000f 00000011     ................
   38020:	00000013 00000015 00000017 00000019     ................
   38030:	0000001b 0000001d 0000001f 00000021     ............!...
   38040:	00000023 00000025 00000027 00000029     #...%...'...)...
   38050:	0000002b 0000002d 0000002f 00000031     +...-.../...1...
   38060:	00000033 00000035 00000037 00000039     3...5...7...9...
   38070:	0000003b 0000003d 0000003f 00000041     ;...=...?...A...
   38080:	00000043 00000045 00000047 00000049     C...E...G...I...
   38090:	0000004b 0000004d 0000004f 00000051     K...M...O...Q...
   380a0:	00000053 00000055 00000057 00000059     S...U...W...Y...
   380b0:	0000005b 0000005d 0000005f 00000061     [...]..._...a...
   380c0:	00000063 00000065 00000067 00000069     c...e...g...i...
   380d0:	0000006b 0000006d 0000006f 00000071     k...m...o...q...
   380e0:	00000073 00000075 00000077 00000079     s...u...w...y...
   380f0:	0000007b 0000007d 0000007f 00000081     {...}...........
   38100:	00000083 00000085 00000087 00000089     ................
   38110:	0000008b 0000008d 0000008f 00000091     ................
   38120:	00000093 00000095 00000097 00000099     ................
   38130:	0000009b 0000009d 0000009f 000000a1     ................
   38140:	000000a3 000000a5 000000a7 000000a9     ................
   38150:	000000ab 000000ad 000000af 000000b1     ................
   38160:	000000b3 000000b5 000000b7 000000b9     ................
   38170:	000000bb 000000bd 000000bf 000000c1     ................
   38180:	000000c3 000000c5 000000c7 000000c9     ................
   38190:	000000cb 000000cd 000000cf 000000d1     ................
   381a0:	000000d3 000000d5 000000d7 000000d9     ................
   381b0:	000000db 000000dd 000000df 000000e1     ................
   381c0:	000000e3 000000e5 000000e7 000000e9     ................
   381d0:	000000eb 000000ed 000000ef 000000f1     ................
   381e0:	000000f3 000000f5 000000f7 000000f9     ................
   381f0:	000000fb 000000fd 000000ff 00000101     ................
   38200:	00000103 00000105 00000107 00000109     ................
   38210:	0000010b 0000010d 0000010f 00000111     ................
   38220:	00000113 00000115 00000117 00000119     ................
   38230:	0000011b 0000011d 0000011f 00000121     ............!...
   38240:	00000123 00000125 00000127 00000129     #...%...'...)...
   38250:	0000012b 0000012d 0000012f 00000131     +...-.../...1...
   38260:	00000133 00000135 00000137 00000139     3...5...7...9...
   38270:	0000013b 0000013d 0000013f 00000141     ;...=...?...A...
   38280:	00000143 00000145 00000147 00000149     C...E...G...I...
   38290:	0000014b 0000014d 0000014f 00000151     K...M...O...Q...
   382a0:	00000153 00000155 00000157 00000159     S...U...W...Y...
   382b0:	0000015b 0000015d 0000015f 0000000d     [...]..._.......
   382c0:	00000019 00000029 0000003d 00000055     ....)...=...U...
   382d0:	00000071 00000091 000000b5 000000dd     q...............
   382e0:	00000109 00000139 0000016d 000001a5     ....9...m.......
   382f0:	000001e1 00000221 00000265 000002ad     ....!...e.......
   38300:	000002f9 00000349 0000039d 000003f5     ....I...........
   38310:	00000451 000004b1 00000515 0000057d     Q...........}...
   38320:	000005e9 00000659 000006cd 00000745     ....Y.......E...
   38330:	000007c1 00000841 000008c5 0000094d     ....A.......M...
   38340:	000009d9 00000a69 00000afd 00000b95     ....i...........
   38350:	00000c31 00000cd1 00000d75 00000e1d     1.......u.......
   38360:	00000ec9 00000f79 0000102d 000010e5     ....y...-.......
   38370:	000011a1 00001261 00001325 000013ed     ....a...%.......
   38380:	000014b9 00001589 0000165d 00001735     ........]...5...
   38390:	00001811 000018f1 000019d5 00001abd     ................
   383a0:	00001ba9 00001c99 00001d8d 00001e85     ................
   383b0:	00001f81 00002081 00002185 0000228d     ..... ...!..."..
   383c0:	00002399 000024a9 000025bd 000026d5     .#...$...%...&..
   383d0:	000027f1 00002911 00002a35 00002b5d     .'...)..5*..]+..
   383e0:	00002c89 00002db9 00002eed 00003025     .,...-......%0..
   383f0:	00003161 000032a1 000033e5 0000352d     a1...2...3..-5..
   38400:	00003679 000037c9 0000391d 00003a75     y6...7...9..u:..
   38410:	00003bd1 00003d31 00003e95 00003ffd     .;..1=...>...?..
   38420:	00004169 000042d9 0000444d 000045c5     iA...B..MD...E..
   38430:	00004741 000048c1 00004a45 00004bcd     AG...H..EJ...K..
   38440:	00004d59 00004ee9 0000507d 00005215     YM...N..}P...R..
   38450:	000053b1 00005551 000056f5 0000589d     .S..QU...V...X..
   38460:	00005a49 00005bf9 00005dad 00005f65     IZ...[...]..e_..
   38470:	00006121 000062e1 000064a5 0000666d     !a...b...d..mf..
   38480:	00006839 00006a09 00006bdd 00006db5     9h...j...k...m..
   38490:	00006f91 00007171 00007355 0000753d     .o..qq..Us..=u..
   384a0:	00007729 00007919 00007b0d 00007d05     )w...y...{...}..
   384b0:	00007f01 00008101 00008305 0000850d     ................
   384c0:	00008719 00008929 00008b3d 00008d55     ....)...=...U...
   384d0:	00008f71 00009191 000093b5 000095dd     q...............
   384e0:	00009809 00009a39 00009c6d 00009ea5     ....9...m.......
   384f0:	0000a0e1 0000a321 0000a565 0000a7ad     ....!...e.......
   38500:	0000a9f9 0000ac49 0000ae9d 0000b0f5     ....I...........
   38510:	0000b351 0000b5b1 0000b815 0000ba7d     Q...........}...
   38520:	0000bce9 0000bf59 0000c1cd 0000c445     ....Y.......E...
   38530:	0000c6c1 0000c941 0000cbc5 0000ce4d     ....A.......M...
   38540:	0000d0d9 0000d369 0000d5fd 0000d895     ....i...........
   38550:	0000db31 0000ddd1 0000e075 0000e31d     1.......u.......
   38560:	0000e5c9 0000e879 0000eb2d 0000ede5     ....y...-.......
   38570:	0000f0a1 0000003f 00000081 000000e7     ....?...........
   38580:	00000179 0000023f 00000341 00000487     y...?...A.......
   38590:	00000619 000007ff 00000a41 00000ce7     ........A.......
   385a0:	00000ff9 0000137f 00001781 00001c07     ................
   385b0:	00002119 000026bf 00002d01 000033e7     .!...&...-...3..
   385c0:	00003b79 000043bf 00004cc1 00005687     y;...C...L...V..
   385d0:	00006119 00006c7f 000078c1 000085e7     .a...l...x......
   385e0:	000093f9 0000a2ff 0000b301 0000c407     ................
   385f0:	0000d619 0000e93f 0000fd81 000112e7     ....?...........
   38600:	00012979 0001413f 00015a41 00017487     y)..?A..AZ...t..
   38610:	00019019 0001acff 0001cb41 0001eae7     ........A.......
   38620:	00020bf9 00022e7f 00025281 00027807     .........R...x..
   38630:	00029f19 0002c7bf 0002f201 00031de7     ................
   38640:	00034b79 00037abf 0003abc1 0003de87     yK...z..........
   38650:	00041319 0004497f 000481c1 0004bbe7     .....I..........
   38660:	0004f7f9 000535ff 00057601 0005b807     .....5...v......
   38670:	0005fc19 0006423f 00068a81 0006d4e7     ....?B..........
   38680:	00072179 0007703f 0007c141 00081487     y!..?p..A.......
   38690:	00086a19 0008c1ff 00091c41 000978e7     .j......A....x..
   386a0:	0009d7f9 000a397f 000a9d81 000b0407     .....9..........
   386b0:	000b6d19 000bd8bf 000c4701 000cb7e7     .m.......G......
   386c0:	000d2b79 000da1bf 000e1ac1 000e9687     y+..............
   386d0:	000f1519 000f967f 00101ac1 0010a1e7     ................
   386e0:	00112bf9 0011b8ff 00124901 0012dc07     .+.......I......
   386f0:	00137219 00140b3f 0014a781 001546e7     .r..?........F..
   38700:	0015e979 00168f3f 00173841 0017e487     y...?...A8......
   38710:	00189419 001946ff 0019fd41 001ab6e7     .....F..A.......
   38720:	001b73f9 001c347f 001cf881 001dc007     .s...4..........
   38730:	001e8b19 001f59bf 00202c01 002101e7     .....Y..., ...!.
   38740:	0021db79 0022b8bf 002399c1 00247e87     y.!..."...#..~$.
   38750:	00256719 0026537f 002743c1 002837e7     .g%..S&..C'..7(.
   38760:	00292ff9 002a2bff 002b2c01 002c3007     ./)..+*..,+..0,.
   38770:	002d3819 002e443f 002f5481 003068e7     .8-.?D...T/..h0.
   38780:	00318179 00329e3f 0033bf41 0034e487     y.1.?.2.A.3...4.
   38790:	00360e19 00373bff 00386e41 0039a4e7     ..6..;7.An8...9.
   387a0:	003adff9 003c1f7f 003d6381 003eac07     ..:...<..c=...>.
   387b0:	003ff919 00414abf 0042a101 0043fbe7     ..?..JA...B...C.
   387c0:	00455b79 0046bfbf 004828c1 00499687     y[E...F..(H...I.
   387d0:	004b0919 004c807f 004dfcc1 004f7de7     ..K...L...M..}O.
   387e0:	005103f9 00528eff 00541f01 0055b407     ..Q...R...T...U.
   387f0:	00574e19 0058ed3f 005a9181 005c3ae7     .NW.?.X...Z..:\.
   38800:	005de979 005f9d3f 00615641 00631487     y.].?._.AVa...c.
   38810:	0064d819 0066a0ff 00686f41 006a42e7     ..d...f.Aoh..Bj.
   38820:	006c1bf9 006dfa7f 00000141 000002a9     ..l...m.A.......
   38830:	00000509 000008c1 00000e41 00001609     ........A.......
   38840:	000020a9 00002ec1 00004101 00005829     . .......A..)X..
   38850:	00007509 00009881 0000c381 0000f709     .u..............
   38860:	00013429 00017c01 0001cfc1 000230a9     )4...|.......0..
   38870:	0002a009 00031f41 0003afc1 00045309     ....A........S..
   38880:	00050aa9 0005d841 0006bd81 0007bc29     ....A.......)...
   38890:	0008d609 000a0d01 000b6301 000cda09     .........c......
   388a0:	000e7429 00103381 00121a41 00142aa9     )t...3..A....*..
   388b0:	00166709 0018d1c1 001b6d41 001e3c09     .g......Am...<..
   388c0:	002140a9 00247dc1 0027f601 002bac29     .@!..}$...'.).+.
   388d0:	002fa309 0033dd81 00385e81 003d2909     ../...3..^8..)=.
   388e0:	00424029 0047a701 004d60c1 005370a9     )@B...G..`M..pS.
   388f0:	0059da09 0060a041 0067c6c1 006f5109     ..Y.A.`...g..Qo.
   38900:	007742a9 007f9f41 00886a81 0091a829     .Bw.A....j..)...
   38910:	009b5c09 00a58a01 00b03601 00bb6409     .\.......6...d..
   38920:	00c71829 00d35681 00e02341 00ed82a9     )....V..A#......
   38930:	00fb7909 010a0ac1 01193c41 01291209     .y......A<....).
   38940:	013990a9 014abcc1 015c9b01 016f3029     ..9...J...\.)0o.
   38950:	01828109 01969281 01ab6981 01c10b09     .........i......
   38960:	01d77c29 01eec201 0206e1c1 021fe0a9     )|..............
   38970:	0239c409 02549141 02704dc1 028cff09     ..9.A.T..Mp.....
   38980:	02aaaaa9 02c95641 02e90781 0309c429     ....AV......)...
   38990:	032b9209 034e7701 03727901 03979e09     ..+..wN..yr.....
   389a0:	03bdec29 03e56981 040e1c41 04380aa9     )....i..A.....8.
   389b0:	04633b09 048fb3c1 04bd7b41 04ec9809     .;c.....A{......
   389c0:	051d10a9 054eebc1 05823001 05b6e429     ......N..0..)...
   389d0:	05ed0f09 0624b781 065de481 06989d09     ......$...].....
   389e0:	06d4e829 0712cd01 075252c1 079380a9     )........RR.....
   389f0:	07d65e09 081af241 086144c1 08a95d09     .^..A....Da..]..
   38a00:	08f342a9 093efd41 098c9481 09dc1029     .B..A.>.....)...
   38a10:	0a2d7809 0a80d401 0ad62c01 0b2d8809     .x-......,....-.
   38a20:	0b86f029 0be26c81 0c400541 0c9fc2a9     )....l..A.@.....
   38a30:	0d01ad09 0d65ccc1 0dcc2a41 0e34ce09     ......e.A*....4.
   38a40:	0e9fc0a9 0f0d0ac1 0f7cb501 0feec829     ..........|.)...
   38a50:	10634d09 10da4c81 1153cf81 11cfdf09     .Mc..L....S.....
   38a60:	124e8429 12cfc801 1353b3c1 13da50a9     ).N.......S..P..
   38a70:	1463a809 14efc341 157eabc1 16106b09     ..c.A.....~..k..
   38a80:	16a50aa9 173c9441 17d71181 18748c29     ....A.<.....).t.
   38a90:	19150e09 19b8a101 1a5f4f01 1b092209     .........O_.."..
   38aa0:	1bb62429 1c665f81 1d19de41 1dd0aaa9     )$..._f.A.......
   38ab0:	1e8acf09 1f4855c1 20094941 20cdb409     .....UH.AI. ... 
   38ac0:	2195a0a9 226119c1 23302a01 2402dc29     ...!..a".*0#)..$
   38ad0:	24d93b09 25b35181 00000693 00000e45     .;.$.Q.%....E...
   38ae0:	00001c0f 00003311 0000575b 00008e0d     .....3..[W......
   38af0:	0000dd77 00014d39 0001e663 0002b395     w...9M..c.......
   38b00:	0003c11f 00051d21 0006d7ab 000902dd     ....!...........
   38b10:	000bb307 000efec9 0012ff33 0017cfe5     ........3.......
   38b20:	001d8f2f 00245e31 002c60fb 0035bead     /...1^$..`,...5.
   38b30:	0040a197 004d3759 005bb103 006c4335     ..@.Y7M...[.5Cl.
   38b40:	007f263f 00949641 00acd34b 00c8217d     ?&..A...K...}!..
   38b50:	00e6c927 010916e9 012f5bd3 0159ed85     '........[/...Y.
   38b60:	0189264f 01bd6551 01f70e9b 02368b4d     O&..Qe......M.6.
   38b70:	027c49b7 02c8bd79 031c5fa3 0377aed5     .I|.y...._....w.
   38b80:	03db2f5f 04476b61 04bcf2eb 053c5c1d     _/..akG......\<.
   38b90:	05c64347 065b4b09 06fc1c73 07a96725     GC...K[.s...%g..
   38ba0:	0863e16f 092c4871 0a03603b 0ae9f3ed     o.c.qH,.;`......
   38bb0:	0be0d5d7 0ce8df99 0e02f243 0f2ff675     ........C...u./.
   38bc0:	1070dc7f 11c69c81 1332368b 14b4b2bd     ..p......62.....
   38bd0:	164f2167 18029b29 19d04113 1bb93cc5     g!O.)....A...<..
   38be0:	1dbec08f 1fe20791 222455db 2486f88d     .........U$"...$
   38bf0:	270b45f7 29b29db9 2c7e68e3 2f701a15     .E.'...).h~,..p/
   38c00:	32892d9f 35cb29a1 39379e2b 3cd0255d     .-.2.).5+.79]%.<
   38c10:	40966387 448c0749 48b2c9b3 4d0c6e65     .c.@I..D...Hen.M
   38c20:	519ac3af 565fa2b1 5b5cef7b 6094992d     ...Q.._V{.\[-..`
   38c30:	66089a17 6bbaf7d9 71adc383 77e319b5     ...f...k...q...w
   38c40:	7e5d22bf 0000231d 00004d71 00009c91     ."]~.#..qM......
   38c50:	000126fd 00020c65 000377e9 0005a299     .&..e....w......
   38c60:	0008d635 000d702d 0013e4e1 001cc321     5...-p......!...
   38c70:	0028b7ed 00389275 004d4859 0067fa29     ..(.u.8.YHM.).g.
   38c80:	0089f825 00b4c73d 00ea2651 012c13b1     %...=...Q&....,.
   38c90:	017cd2dd 01def285 025552c9 02e32bb9     ..|......RU..+..
   38ca0:	038c1415 0454084d 053f71c1 06532e41     ....M.T..q?.A.S.
   38cb0:	079497cd 09098c95 0ab87739 0ca85749     ........9w..IW..
   38cc0:	0ee0ca05 116a135d 144d2731 1793b2d1     ....].j.1'M.....
   38cd0:	1b4826bd 1f75c0a5 242895a9 296d9cd9     .&H...u...($..m)
   38ce0:	2f52b9f5 35e6c86d 3d39a6a1 455c4161     ..R/m..5..9=aA\E
   38cf0:	4e609fad 5859eeb5 635c8e19 6f7e1c69     ..`N..YX..\ci.~o
   38d00:	7cd583e5 0000bdff 0001a801 00036b8f     ...|.........k..
   38d10:	00069ef1 000c233f 00153dc1 0023b68f     ....?#...=....#.
   38d20:	0039fcf1 005b51ff 008bfa01 00d1750f     ..9..Q[......u..
   38d30:	0132bf71 01b89a3f 026ddcc1 035fcf0f     q.2.?.....m..._.
   38d40:	049e8e71 063d7bff 0853b601 0afc9c8f     q....{=...S.....
   38d50:	0e5861f1 128ca73f 17c525c1 1e34658f     .aX.?....%...e4.
   38d60:	261481f1 2fa7fbff 3b3a9c01 4922620f     ...&.../..:;.b"I
   38d70:	59c08671 6d828a3f 84e358c1 00040e01     q..Y?..m.X......
   38d80:	00092191 00132c11 0025ee41 00474f41     .!...,..A.%.AOG.
   38d90:	00804391 00ddf711 01734601 025a9201     .C.......Fs...Z.
   38da0:	03b80111 05bc3591 08a78f41 0cce0641     .....5..A...A...
   38db0:	129bb211 1a9a0f91 25761a01 34074c01     ..........v%.L.4
   38dc0:	47579e91 60ac9d11 8191a641 00165123     ..WG...`A...#Q..
   38dd0:	00329ec5 006bb917 00d8f699 01a0896b     ..2...k.....k...
   38de0:	02fec40d 0550011f 091dd921 0f306c33     ......P.!...3l0.
   38df0:	18a4a2d5 270867a7 3c7dfd29 5be7b57b     .....g.').}<{..[
   38e00:	891d771d c92da0af 007b8ead 0119e689     .w....-...{.....
   38e10:	025e9639 04d8163d 097763b5 11c628e1     9.^.=....cw..(..
   38e20:	20340321 38824875 6057577d 02af5bbf     !.4 uH.8}WW`.[..
   38e30:	0627d881 0d5e84f7 1badfee9 36eb8b7f     ..'...^........6
   38e40:	68e5b781 c19c0317 0eff0cc1 22856a39     ...h........9j."
   38e50:	4b91ee19 9e2b7881 5409e133              ...K.x+.3..T

00038e5c <CELT_PVQ_U_ROW>:
   38e5c:	00037a7c 00037d3c 00037ff8 000382b0     |z..<}..........
   38e6c:	00038564 00038814 00038ac0 00038c28     d...........(...
   38e7c:	00038ce4 00038d58 00038da4 00038ddc     ....X...........
   38e8c:	00038dfc 00038e14 00038e20              ........ ...

00038e98 <SMALL_DIV_TABLE>:
   38e98:	ffffffff 55555555 33333333 24924924     ....UUUU3333$I.$
   38ea8:	1c71c71c 1745d174 13b13b13 11111111     ..q.t.E..;......
   38eb8:	0f0f0f0f 0d79435e 0c30c30c 0b21642c     ....^Cy...0.,d!.
   38ec8:	0a3d70a3 097b425e 08d3dcb0 08421084     .p=.^B{.......B.
   38ed8:	07c1f07c 07507507 06eb3e45 06906906     |....uP.E>...i..
   38ee8:	063e7063 05f417d0 05b05b05 0572620a     cp>......[...br.
   38ef8:	05397829 05050505 04d4873e 04a7904a     )x9.....>...J...
   38f08:	047dc11f 0456c797 04325c53 04104104     ..}...V.S\2..A..
   38f18:	03f03f03 03d22635 03b5cc0e 039b0ad1     .?..5&..........
   38f28:	0381c0e0 0369d036 03531dec 033d91d2     ....6.i...S...=.
   38f38:	0329161f 03159721 03030303 02f14990     ..).!........I..
   38f48:	02e05c0b 02d02d02 02c0b02c 02b1da46     .\...-..,...F...
   38f58:	02a3a0fd 0295fad4 0288df0c 027c4597     .............E|.
   38f68:	02702702 02647c69 02593f69 024e6a17     .'p.i|d.i?Y..jN.
   38f78:	0243f6f0 0239e0d5 02302302 0226b902     ..C...9..#0...&.
   38f88:	021d9ead 0214d021 020c49ba 02040810     ....!....I......
   38f98:	01fc07f0 01f44659 01ecc07b 01e573ac     ....YF..{....s..
   38fa8:	01de5d6e 01d77b65 01d0cb58 01ca4b30     n]..e{..X...0K..
   38fb8:	01c3f8f0 01bdd2b8 01b7d6c3 01b20364     ............d...
   38fc8:	01ac5701 01a6d01a 01a16d3f 019c2d14     .W......?m...-..
   38fd8:	01970e4f 01920fb4 018d3018 01886e5f     O........0.._n..
   38fe8:	0183c977 017f405f 017ad220 01767dce     w..._@.. .z..}v.
   38ff8:	01724287 016e1f76 016a13cd 01661ec6     .Br.v.n...j...f.
   39008:	01623fa7 015e75bb 015ac056 01571ed3     .?b..u^.V.Z...W.
   39018:	01539094 01501501 014cab88 0149539e     ..S...P...L..SI.
   39028:	01460cbc 0142d662 013fb013 013c995a     ..F.b.B...?.Z.<.
   39038:	013991c2 013698df 0133ae45 0130d190     ..9...6.E.3...0.
   39048:	012e025c 012b404a 01288b01 0125e227     \...J@+...(.'.%.
   39058:	01234567 0120b470 011e2ef3 011bb4a4     gE#.p. .........
   39068:	01194538 0116e068 011485f0 0112358e     8E..h........5..
   39078:	010fef01 010db20a 010b7e6e 010953f3     ........n~...S..
   39088:	01073260 0105197f 0103091b 01010101     `2..............
   39098:	00000000                                ....

0003909c <correction.5987>:
   3909c:	00008b95 00009837 0000a5ff 0000b504     ....7...........
   390ac:	0000c567 0000d745 0000eac1 0000ffff     g...E...........

000390bc <band_allocation>:
	...
   390d0:	4b505a00 31383f45 141d2228 00000a12     .ZPKE?81("......
   390e0:	00000000 646e0000 474e545a 2d333a41     ......ndZTNGA:3-
   390f0:	141a2027 0000000c 76000000 565d676e     ' .........vng]V
   39100:	41464b50 282f353b 040f171f 00000000     PKFA;5/(........
   39110:	6870777e 4e53595f 363c4248 1920272f     ~wph_YSNHB<6/' .
   39120:	00010c11 787f8600 5b616772 42484e55     .......xrga[UNHB
   39130:	292f363c 10171d23 8990010a 6b717c82     <6/)#........|qk
   39140:	52585f65 3940464c 21272d33 98010f1a     e_XRLF@93-'!....
   39150:	7b848a91 62696f75 4a50565c 31373d43     ...{uoib\VPJC=71
   39160:	0114242b 8e949ba2 73797f85 5a60666c     +$........yslf`Z
   39170:	41474d54 1e2e353b 9ea5ac01 83898f98     TMGA;5..........
   39180:	6a70767d 51575e64 383f454b c8c8142d     }vpjd^WQKE?8-...
   39190:	c8c8c8c8 c1c6c8c8 adb2b7bc 999ea3a8     ................
   391a0:	00688194                                ..h.

000391a4 <cache_bits50>:
   391a4:	07070728 07070707 07070707 07070707     (...............
   391b4:	07070707 07070707 07070707 07070707     ................
   391c4:	07070707 07070707 170f2807 24221f1c     .........(...."$
   391d4:	2a292726 2e2d2c2b 32312f2f 36353433     &')*+,-.//123456
   391e4:	3a393737 3e3d3c3b 42413f3f 46454443     779:;<=>??ABCDEF
   391f4:	14284747 35302921 42403d39 4b494745     GG(.!)059=@BEGIK
   39204:	52504e4c 5b595755 62605e5c 6b696765     LNPRUWY[\^`begik
   39214:	72706e6c 7b797775 28807e7c 3c332717     lnpruwy{|~.(.'3<
   39224:	534f4943 615e5b57 6b696664 7976736f     CIOSW[^adfikosvy
   39234:	83817e7c 918e8b87 9b999694 a9a6a39f     |~..............
   39244:	b3b1aeac 41311c23 6b63594e 847e7872     ....#.1ANYckrx~.
   39254:	95918d88 aba59f99 bdb9b4b0 d3cdc7c0     ................
   39264:	e5e1dcd8 fbf5efe8 4f3a2115 897d7061     .........!:Oap}.
   39274:	aea69d94 c9c3bdb6 ebe3d9cf 2311fbf3     ...............#
   39284:	7b6a563f b1a5988b d6cec5bb faede6de     ?Vj{............
   39294:	4b371f19 8075695b a19a928a b9b4aea8     ..7K[iu.........
   392a4:	d7d0c8be f0ebe5de 2410fff5 806e5941     ...........$AYn.
   392b4:	b9ad9f90 e2d9cfc4 0bfaf2ea 80674a29     ............)Jg.
   392c4:	d1bfac97 09fff1e1 8a6e4f2b e3cfbaa3     ........+On.....
   392d4:	47270cf6 a4907b63 e4d6c6b6 2c09fdf1     ..'Gc{.........,
   392e4:	a88e7151 ffebd6c0 7f5a3107 f7dcbfa0     Qq.......1Z.....
   392f4:	865f3306 07eacbaa 9b7b572f 06edd4b8     .3_...../W{.....
   39304:	ae896134 3905f0d0 e7c0976a 9e6f3b05     4a.....9j....;o.
   39314:	3705f3ca e0bb9367 a1713c05 4104f8ce     ...7g....<q....A
   39324:	04e0af7a eab67f43                       z...C...

0003932c <cache_caps50>:
   3932c:	e0e0e0e0 e0e0e0e0 a0a0a0a0 b2b9b9b9     ................
   3933c:	3d86a8b2 e0e0e025 e0e0e0e0 f0f0f0e0     ...=%...........
   3934c:	cfcfcff0 90b7c6c6 a0a02842 a0a0a0a0     ........B(......
   3935c:	b9b9a0a0 c1c1b9b9 acb7b7c1 f026408a     .............@&.
   3936c:	f0f0f0f0 cff0f0f0 cccfcfcf c1c1cccc     ................
   3937c:	28428fb4 b9b9b9b9 b9b9b9b9 c1c1c1c1     ..B(............
   3938c:	b7c1c1c1 418aacb7 cfcfcf27 cfcfcfcf     .......A'.......
   3939c:	cccccccf c9c9c9cc 8db0bcbc c1c12842     ............B(..
   393ac:	c1c1c1c1 c1c1c1c1 c2c2c1c1 adb8b8c2     ................
   393bc:	cc27418b cccccccc c9cccccc c6c9c9c9     .A'.............
   393cc:	bbbbc6c6 28428caf                       ......B(

000393d4 <cache_index50>:
   393d4:	ffffffff ffffffff ffffffff ffffffff     ................
	...
   393ec:	00290029 00520029 007b0052 00c800a4     ).).).R.R.{.....
   393fc:	000000de 00000000 00000000 00000000     ................
   3940c:	00290000 00290029 007b0029 007b007b     ..).).).).{.{.{.
   3941c:	00a400a4 010a00f0 0127011b 00290029     ..........'.).).
   3942c:	00290029 00290029 00290029 007b007b     ).).).).).).{.{.
   3943c:	007b007b 00f000f0 010a00f0 0131010a     {.{...........1.
   3944c:	0148013e 007b0150 007b007b 007b007b     >.H.P.{.{.{.{.{.
   3945c:	007b007b 00f0007b 00f000f0 013100f0     {.{.{.........1.
   3946c:	01310131 013e013e 015f0157 016c0166     1.1.>.>.W._.f.l.
   3947c:	00f000f0 00f000f0 00f000f0 00f000f0     ................
   3948c:	01310131 01310131 01570157 015f0157     1.1.1.1.W.W.W._.
   3949c:	0172015f 017e0178 00000183              _.r.x.~.....

000394a8 <eband5ms>:
   394a8:	00010000 00030002 00050004 00070006     ................
   394b8:	000a0008 000e000c 00140010 001c0018     ................
   394c8:	00280022 003c0030 0064004e              ".(.0.<.N.d.

000394d4 <fft_bitrev120>:
   394d4:	00180000 00480030 00080060 00380020     ....0.H.`... .8.
   394e4:	00680050 00280010 00580040 00040070     P.h...(.@.X.p...
   394f4:	0034001c 0064004c 0024000c 0054003c     ..4.L.d...$.<.T.
   39504:	0014006c 0044002c 0074005c 00190001     l...,.D.\.t.....
   39514:	00490031 00090061 00390021 00690051     1.I.a...!.9.Q.i.
   39524:	00290011 00590041 00050071 0035001d     ..).A.Y.q.....5.
   39534:	0065004d 0025000d 0055003d 0015006d     M.e...%.=.U.m...
   39544:	0045002d 0075005d 001a0002 004a0032     -.E.].u.....2.J.
   39554:	000a0062 003a0022 006a0052 002a0012     b...".:.R.j...*.
   39564:	005a0042 00060072 0036001e 0066004e     B.Z.r.....6.N.f.
   39574:	0026000e 0056003e 0016006e 0046002e     ..&.>.V.n.....F.
   39584:	0076005e 001b0003 004b0033 000b0063     ^.v.....3.K.c...
   39594:	003b0023 006b0053 002b0013 005b0043     #.;.S.k...+.C.[.
   395a4:	00070073 0037001f 0067004f 0027000f     s.....7.O.g...'.
   395b4:	0057003f 0017006f 0047002f 0077005f     ?.W.o.../.G._.w.

000395c4 <fft_bitrev240>:
   395c4:	00300000 00900060 001000c0 00700040     ..0.`.......@.p.
   395d4:	00d000a0 00500020 00b00080 000400e0     .... .P.........
   395e4:	00640034 00c40094 00440014 00a40074     4.d.......D.t...
   395f4:	002400d4 00840054 00e400b4 00380008     ..$.T.........8.
   39604:	00980068 001800c8 00780048 00d800a8     h.......H.x.....
   39614:	00580028 00b80088 000c00e8 006c003c     (.X.........<.l.
   39624:	00cc009c 004c001c 00ac007c 002c00dc     ......L.|.....,.
   39634:	008c005c 00ec00bc 00310001 00910061     \.........1.a...
   39644:	001100c1 00710041 00d100a1 00510021     ....A.q.....!.Q.
   39654:	00b10081 000500e1 00650035 00c50095     ........5.e.....
   39664:	00450015 00a50075 002500d5 00850055     ..E.u.....%.U...
   39674:	00e500b5 00390009 00990069 001900c9     ......9.i.......
   39684:	00790049 00d900a9 00590029 00b90089     I.y.....).Y.....
   39694:	000d00e9 006d003d 00cd009d 004d001d     ....=.m.......M.
   396a4:	00ad007d 002d00dd 008d005d 00ed00bd     }.....-.].......
   396b4:	00320002 00920062 001200c2 00720042     ..2.b.......B.r.
   396c4:	00d200a2 00520022 00b20082 000600e2     ....".R.........
   396d4:	00660036 00c60096 00460016 00a60076     6.f.......F.v...
   396e4:	002600d6 00860056 00e600b6 003a000a     ..&.V.........:.
   396f4:	009a006a 001a00ca 007a004a 00da00aa     j.......J.z.....
   39704:	005a002a 00ba008a 000e00ea 006e003e     *.Z.........>.n.
   39714:	00ce009e 004e001e 00ae007e 002e00de     ......N.~.......
   39724:	008e005e 00ee00be 00330003 00930063     ^.........3.c...
   39734:	001300c3 00730043 00d300a3 00530023     ....C.s.....#.S.
   39744:	00b30083 000700e3 00670037 00c70097     ........7.g.....
   39754:	00470017 00a70077 002700d7 00870057     ..G.w.....'.W...
   39764:	00e700b7 003b000b 009b006b 001b00cb     ......;.k.......
   39774:	007b004b 00db00ab 005b002b 00bb008b     K.{.....+.[.....
   39784:	000f00eb 006f003f 00cf009f 004f001f     ....?.o.......O.
   39794:	00af007f 002f00df 008f005f 00ef00bf     ....../._.......

000397a4 <fft_bitrev480>:
   397a4:	00600000 012000c0 00200180 00e00080     ..`... ... .....
   397b4:	01a00140 00a00040 01600100 000801c0     @...@.....`.....
   397c4:	00c80068 01880128 00880028 014800e8     h...(...(.....H.
   397d4:	004801a8 010800a8 01c80168 00700010     ..H.....h.....p.
   397e4:	013000d0 00300190 00f00090 01b00150     ..0...0.....P...
   397f4:	00b00050 01700110 001801d0 00d80078     P.....p.....x...
   39804:	01980138 00980038 015800f8 005801b8     8...8.....X...X.
   39814:	011800b8 01d80178 00640004 012400c4     ....x.....d...$.
   39824:	00240184 00e40084 01a40144 00a40044     ..$.....D...D...
   39834:	01640104 000c01c4 00cc006c 018c012c     ..d.....l...,...
   39844:	008c002c 014c00ec 004c01ac 010c00ac     ,.....L...L.....
   39854:	01cc016c 00740014 013400d4 00340194     l.....t...4...4.
   39864:	00f40094 01b40154 00b40054 01740114     ....T...T.....t.
   39874:	001c01d4 00dc007c 019c013c 009c003c     ....|...<...<...
   39884:	015c00fc 005c01bc 011c00bc 01dc017c     ..\...\.....|...
   39894:	00610001 012100c1 00210181 00e10081     ..a...!...!.....
   398a4:	01a10141 00a10041 01610101 000901c1     A...A.....a.....
   398b4:	00c90069 01890129 00890029 014900e9     i...)...).....I.
   398c4:	004901a9 010900a9 01c90169 00710011     ..I.....i.....q.
   398d4:	013100d1 00310191 00f10091 01b10151     ..1...1.....Q...
   398e4:	00b10051 01710111 001901d1 00d90079     Q.....q.....y...
   398f4:	01990139 00990039 015900f9 005901b9     9...9.....Y...Y.
   39904:	011900b9 01d90179 00650005 012500c5     ....y.....e...%.
   39914:	00250185 00e50085 01a50145 00a50045     ..%.....E...E...
   39924:	01650105 000d01c5 00cd006d 018d012d     ..e.....m...-...
   39934:	008d002d 014d00ed 004d01ad 010d00ad     -.....M...M.....
   39944:	01cd016d 00750015 013500d5 00350195     m.....u...5...5.
   39954:	00f50095 01b50155 00b50055 01750115     ....U...U.....u.
   39964:	001d01d5 00dd007d 019d013d 009d003d     ....}...=...=...
   39974:	015d00fd 005d01bd 011d00bd 01dd017d     ..]...].....}...
   39984:	00620002 012200c2 00220182 00e20082     ..b..."...".....
   39994:	01a20142 00a20042 01620102 000a01c2     B...B.....b.....
   399a4:	00ca006a 018a012a 008a002a 014a00ea     j...*...*.....J.
   399b4:	004a01aa 010a00aa 01ca016a 00720012     ..J.....j.....r.
   399c4:	013200d2 00320192 00f20092 01b20152     ..2...2.....R...
   399d4:	00b20052 01720112 001a01d2 00da007a     R.....r.....z...
   399e4:	019a013a 009a003a 015a00fa 005a01ba     :...:.....Z...Z.
   399f4:	011a00ba 01da017a 00660006 012600c6     ....z.....f...&.
   39a04:	00260186 00e60086 01a60146 00a60046     ..&.....F...F...
   39a14:	01660106 000e01c6 00ce006e 018e012e     ..f.....n.......
   39a24:	008e002e 014e00ee 004e01ae 010e00ae     ......N...N.....
   39a34:	01ce016e 00760016 013600d6 00360196     n.....v...6...6.
   39a44:	00f60096 01b60156 00b60056 01760116     ....V...V.....v.
   39a54:	001e01d6 00de007e 019e013e 009e003e     ....~...>...>...
   39a64:	015e00fe 005e01be 011e00be 01de017e     ..^...^.....~...
   39a74:	00630003 012300c3 00230183 00e30083     ..c...#...#.....
   39a84:	01a30143 00a30043 01630103 000b01c3     C...C.....c.....
   39a94:	00cb006b 018b012b 008b002b 014b00eb     k...+...+.....K.
   39aa4:	004b01ab 010b00ab 01cb016b 00730013     ..K.....k.....s.
   39ab4:	013300d3 00330193 00f30093 01b30153     ..3...3.....S...
   39ac4:	00b30053 01730113 001b01d3 00db007b     S.....s.....{...
   39ad4:	019b013b 009b003b 015b00fb 005b01bb     ;...;.....[...[.
   39ae4:	011b00bb 01db017b 00670007 012700c7     ....{.....g...'.
   39af4:	00270187 00e70087 01a70147 00a70047     ..'.....G...G...
   39b04:	01670107 000f01c7 00cf006f 018f012f     ..g.....o.../...
   39b14:	008f002f 014f00ef 004f01af 010f00af     /.....O...O.....
   39b24:	01cf016f 00770017 013700d7 00370197     o.....w...7...7.
   39b34:	00f70097 01b70157 00b70057 01770117     ....W...W.....w.
   39b44:	001f01d7 00df007f 019f013f 009f003f     ........?...?...
   39b54:	015f00ff 005f01bf 011f00bf 01df017f     .._..._.........

00039b64 <fft_bitrev60>:
   39b64:	000c0000 00240018 00040030 001c0010     ......$.0.......
   39b74:	00340028 00140008 002c0020 00010038     (.4..... .,.8...
   39b84:	0019000d 00310025 00110005 0029001d     ....%.1.......).
   39b94:	00090035 00210015 0039002d 000e0002     5.....!.-.9.....
   39ba4:	0026001a 00060032 001e0012 0036002a     ..&.2.......*.6.
   39bb4:	0016000a 002e0022 0003003a 001b000f     ...."...:.......
   39bc4:	00330027 00130007 002b001f 000b0037     '.3.......+.7...
   39bd4:	00230017 003b002f                       ..#./.;.

00039bdc <fft_state48000_960_0>:
   39bdc:	000001e0 00004444 00000008 ffffffff     ....DD..........
   39bec:	00600005 00200003 00080004 00040002     ..`... .........
   39bfc:	00010004 00000000 00000000 00000000     ................
   39c0c:	000397a4 00039ccc 00000000              ............

00039c18 <fft_state48000_960_1>:
   39c18:	000000f0 00004444 00000007 00000001     ....DD..........
   39c28:	00300005 00100003 00040004 00010004     ..0.............
	...
   39c48:	000395c4 00039ccc 00000000              ............

00039c54 <fft_state48000_960_2>:
   39c54:	00000078 00004444 00000006 00000002     x...DD..........
   39c64:	00180005 00080003 00040002 00010004     ................
	...
   39c84:	000394d4 00039ccc 00000000              ............

00039c90 <fft_state48000_960_3>:
   39c90:	0000003c 00004444 00000005 00000003     <...DD..........
   39ca0:	000c0005 00040003 00010004 00000000     ................
	...
   39cc0:	00039b64 00039ccc 00000000              d...........

00039ccc <fft_twiddles48000_960>:
   39ccc:	00007fff fe537ffe fca67ff5 faf97fe7     ......S.........
   39cdc:	f94d7fd4 f7a17fba f5f67f9b f44a7f77     ..M.........w.J.
   39cec:	f29f7f4c f0f57f1d ef4b7ee8 eda37ead     L........~K..~..
   39cfc:	ebfb7e6c ea547e27 e8ad7ddb e7077d8a     l~..'~T..}...}..
   39d0c:	e5637d33 e3c17cd8 e21e7c77 e07d7c10     3}c..|..w|...|}.
   39d1c:	dedf7ba4 dd417b33 dba67abb da0c7a3e     .{..3{A..z..>z..
   39d2c:	d87279bd d6dc7936 d54778a9 d3b47817     .yr.6y...xG..x..
   39d3c:	d2237780 d09376e4 cf047642 cd79759b     .w#..v..Bv...uy.
   39d4c:	cbf074f0 ca6a743e c8e57389 c76372ce     .t..>tj..s...rc.
   39d5c:	c5e5720d c4677148 c2ed707d c1766fae     .r..Hqg.}p...ov.
   39d6c:	c0006edb be8f6e02 bd216d24 bbb46c42     .n...n..$m!.Bl..
   39d7c:	ba4b6b5a b8e36a6e b780697e b6216888     ZkK.nj..~i...h!.
   39d8c:	b4c4678e b36a6691 b215658d b0c26486     .g...fj..e...d..
   39d9c:	af73637a ae28626a acdf6156 ab9b603d     zcs.jb(.Va..=`..
   39dac:	aa5a5f21 a91e5dff a7e55cda a6af5bb1     !_Z..]...\...[..
   39dbc:	a57d5a83 a4505952 a327581d a20156e4     .Z}.RYP..X'..V..
   39dcc:	a0e055a7 9fc45466 9eab5322 9d9651da     .U..fT.."S...Q..
   39ddc:	9c87508e 9b7b4f40 9a734ded 99714c97     .P..@O{..Ms..Lq.
   39dec:	98734b3d 977849e2 96844881 9592471d     =Ks..Ix..H...G..
   39dfc:	94a745b6 93bf444d 92dc42e2 91fe4173     .E..MD...B..sA..
   39e0c:	91264001 90523e8c 8f833d14 8eb93b9a     .@&..>R..=...;..
   39e1c:	8df33a1e 8d33389e 8c78371c 8bc33598     .:...83..7x..5..
   39e2c:	8b123411 8a653289 89be30fc 891d2f6e     .4...2e..0..n/..
   39e3c:	88802de0 87e92c4e 87572abb 86ca2926     .-..N,...*W.&)..
   39e4c:	8644278f 85c225f6 8546245b 84cf22bf     .'D..%..[$F.."..
   39e5c:	845c2122 83f11f83 838a1de2 83281c41     "!\.........A.(.
   39e6c:	82cd1a9f 827618f9 82251755 81da15ad     ......v.U.%.....
   39e7c:	81941407 8153125f 811910b6 80e30f0c     ...._.S.........
   39e8c:	80b40d62 808a0bb7 80650a0c 80460860     b.........e.`.F.
   39e9c:	802c06b4 801a0507 800b035c 800201ae     ..,.....\.......
   39eac:	80010000 8002fe53 800bfca6 8019faf9     ....S...........
   39ebc:	802cf94d 8046f7a1 8065f5f6 8089f44a     M.,...F...e.J...
   39ecc:	80b4f29f 80e3f0f5 8118ef4b 8153eda3     ........K.....S.
   39edc:	8194ebfb 81d9ea54 8225e8ad 8276e707     ....T.....%...v.
   39eec:	82cde563 8328e3c1 8389e21e 83f0e07d     c.....(.....}...
   39efc:	845cdedf 84cddd41 8545dba6 85c2da0c     ..\.A.....E.....
   39f0c:	8643d872 86cad6dc 8757d547 87e9d3b4     r.C.....G.W.....
   39f1c:	8880d223 891cd093 89becf04 8a65cd79     #...........y.e.
   39f2c:	8b10cbf0 8bc2ca6a 8c77c8e5 8d32c763     ....j.....w.c.2.
   39f3c:	8df3c5e5 8eb8c467 8f83c2ed 9052c176     ....g.......v.R.
   39f4c:	9125c000 91febe8f 92dcbd21 93bebbb4     ..%.....!.......
   39f5c:	94a6ba4b 9592b8e3 9682b780 9778b621     K...........!.x.
   39f6c:	9872b4c4 996fb36a 9a73b215 9b7ab0c2     ..r.j.o...s...z.
   39f7c:	9c86af73 9d96ae28 9eaaacdf 9fc3ab9b     s...(...........
   39f8c:	a0dfaa5a a201a91e a326a7e5 a44fa6af     Z.........&...O.
   39f9c:	a57da57d a6aea450 a7e3a327 a91ca201     }.}.P...'.......
   39fac:	aa59a0e0 ab9a9fc4 acde9eab ae269d96     ..Y...........&.
   39fbc:	af729c87 b0c09b7b b2139a73 b3699971     ..r.{...s...q.i.
   39fcc:	b4c39873 b61e9778 b77f9684 b8e39592     s...x...........
   39fdc:	ba4a94a7 bbb393bf bd1e92dc be8d91fe     ..J.............
   39fec:	bfff9126 c1749052 c2ec8f83 c4668eb9     &...R.t.......f.
   39ffc:	c5e28df3 c7628d33 c8e48c78 ca688bc3     ....3.b.x.....h.
   3a00c:	cbef8b12 cd778a65 cf0489be d092891d     ....e.w.........
   3a01c:	d2208880 d3b287e9 d5458757 d6da86ca     .. .....W.E.....
   3a02c:	d8718644 da0a85c2 dba58546 dd4184cf     D.q.....F.....A.
   3a03c:	dede845c e07d83f1 e21e838a e3bf8328     \.....}.....(...
   3a04c:	e56182cd e7078276 e8ab8225 ea5381da     ..a.v...%.....S.
   3a05c:	ebf98194 eda18153 ef4a8119 f0f480e3     ....S.....J.....
   3a06c:	f29e80b4 f449808a f5f48065 f7a08046     ......I.e...F...
   3a07c:	f94c802c faf9801a fca4800b fe528002     ,.L...........R.
   3a08c:	00008001 01ad8002 035a800b 05078019     ..........Z.....
   3a09c:	06b3802c 085f8046 0a0a8065 0bb68089     ,...F._.e.......
   3a0ac:	0d6180b4 0f0b80e3 10b58118 125d8153     ..a.........S.].
   3a0bc:	14058194 15ac81d9 17538225 18f98276     ........%.S.v...
   3a0cc:	1a9d82cd 1c3f8328 1de28389 1f8383f0     ....(.?.........
   3a0dc:	2121845c 22bf84cd 245a8545 25f485c2     \.!!..."E.Z$...%
   3a0ec:	278e8643 292486ca 2ab98757 2c4c87e9     C..'..$)W..*..L,
   3a0fc:	2ddd8880 2f6d891c 30fc89be 32878a65     ...-..m/...0e..2
   3a10c:	34108b10 35968bc2 371b8c77 389d8d32     ...4...5w..72..8
   3a11c:	3a1b8df3 3b998eb8 3d138f83 3e8a9052     ...:...;...=R..>
   3a12c:	40009125 417191fe 42df92dc 444c93be     %..@..qA...B..LD
   3a13c:	45b594a6 471d9592 48809682 49df9778     ...E...G...Hx..I
   3a14c:	4b3c9872 4c96996f 4deb9a73 4f3e9b7a     r.<Ko..Ls..Mz.>O
   3a15c:	508d9c86 51d89d96 53219eaa 54659fc3     ...P...Q..!S..eT
   3a16c:	55a6a0df 56e2a201 581ba326 5951a44f     ...U...V&..XO.QY
   3a17c:	5a83a57d 5bb0a6ae 5cd9a7e3 5dffa91c     }..Z...[...\...]
   3a18c:	5f20aa59 603cab9a 6155acde 626aae26     Y. _..<`..Ua&.jb
   3a19c:	6379af72 6485b0c0 658db213 668fb369     r.yc...d...ei..f
   3a1ac:	678db4c3 6888b61e 697cb77f 6a6eb8e3     ...g...h..|i..nj
   3a1bc:	6b59ba4a 6c41bbb3 6d24bd1e 6e02be8d     J.Yk..Al..$m...n
   3a1cc:	6edabfff 6faec174 707dc2ec 7147c466     ...nt..o..}pf.Gq
   3a1dc:	720dc5e2 72cdc762 7388c8e4 743dca68     ...rb..r...sh.=t
   3a1ec:	74eecbef 759bcd77 7642cf04 76e3d092     ...tw..u..Bv...v
   3a1fc:	7780d220 7817d3b2 78a9d545 7936d6da      ..w...xE..x..6y
   3a20c:	79bcd871 7a3eda0a 7abadba5 7b31dd41     q..y..>z...zA.1{
   3a21c:	7ba4dede 7c0fe07d 7c76e21e 7cd8e3bf     ...{}..|..v|...|
   3a22c:	7d33e561 7d8ae707 7ddbe8ab 7e26ea53     a.3}...}...}S.&~
   3a23c:	7e6cebf9 7eadeda1 7ee7ef4a 7f1df0f4     ..l~...~J..~....
   3a24c:	7f4cf29e 7f76f449 7f9bf5f4 7fbaf7a0     ..L.I.v.........
   3a25c:	7fd4f94c 7fe6faf9 7ff5fca4 7ffefe52     L...........R...
   3a26c:	7fff0000 7ffe01ad 7ff5035a 7fe70507     ........Z.......
   3a27c:	7fd406b3 7fba085f 7f9b0a0a 7f770bb6     ...._.........w.
   3a28c:	7f4c0d61 7f1d0f0b 7ee810b5 7ead125d     a.L........~]..~
   3a29c:	7e6c1405 7e2715ac 7ddb1753 7d8a18f9     ..l~..'~S..}...}
   3a2ac:	7d331a9d 7cd81c3f 7c771de2 7c101f83     ..3}?..|..w|...|
   3a2bc:	7ba42121 7b3322bf 7abb245a 7a3e25f4     !!.{."3{Z$.z.%>z
   3a2cc:	79bd278e 79362924 78a92ab9 78172c4c     .'.y$)6y.*.xL,.x
   3a2dc:	77802ddd 76e42f6d 764230fc 759b3287     .-.wm/.v.0Bv.2.u
   3a2ec:	74f03410 743e3596 7389371b 72ce389d     .4.t.5>t.7.s.8.r
   3a2fc:	720d3a1b 71483b99 707d3d13 6fae3e8a     .:.r.;Hq.=}p.>.o
   3a30c:	6edb4000 6e024171 6d2442df 6c42444c     .@.nqA.n.B$mLDBl
   3a31c:	6b5a45b5 6a6e471d 697e4880 688849df     .EZk.Gnj.H~i.I.h
   3a32c:	678e4b3c 66914c96 658d4deb 64864f3e     <K.g.L.f.M.e>O.d
   3a33c:	637a508d 626a51d8 61565321 603d5465     .Pzc.Qjb!SVaeT=`
   3a34c:	5f2155a6 5dff56e2 5cda581b 5bb15951     .U!_.V.].X.\QY.[
   3a35c:	5a835a83 59525bb0 581d5cd9 56e45dff     .Z.Z.[RY.\.X.].V
   3a36c:	55a75f20 5466603c 53226155 51da626a      _.U<`fTUa"Sjb.Q
   3a37c:	508e6379 4f406485 4ded658d 4c97668f     yc.P.d@O.e.M.f.L
   3a38c:	4b3d678d 49e26888 4881697c 471d6a6e     .g=K.h.I|i.Hnj.G
   3a39c:	45b66b59 444d6c41 42e26d24 41736e02     Yk.EAlMD$m.B.nsA
   3a3ac:	40016eda 3e8c6fae 3d14707d 3b9a7147     .n.@.o.>}p.=Gq.;
   3a3bc:	3a1e720d 389e72cd 371c7388 3598743d     .r.:.r.8.s.7=t.5
   3a3cc:	341174ee 3289759b 30fc7642 2f6e76e3     .t.4.u.2Bv.0.vn/
   3a3dc:	2de07780 2c4e7817 2abb78a9 29267936     .w.-.xN,.x.*6y&)
   3a3ec:	278f79bc 25f67a3e 245b7aba 22bf7b31     .y.'>z.%.z[$1{."
   3a3fc:	21227ba4 1f837c0f 1de27c76 1c417cd8     .{"!.|..v|...|A.
   3a40c:	1a9f7d33 18f97d8a 17557ddb 15ad7e26     3}...}...}U.&~..
   3a41c:	14077e6c 125f7ead 10b67ee7 0f0c7f1d     l~...~_..~......
   3a42c:	0d627f4c 0bb77f76 0a0c7f9b 08607fba     L.b.v.........`.
   3a43c:	06b47fd4 05077fe6 035c7ff5 01ae7ffe     ..........\.....

0003a44c <logN400>:
	...
   3a45c:	00080008 00080008 00100010 00150010     ................
   3a46c:	00180015 0022001d 00000024              ......".$...

0003a478 <mdct_twiddles960>:
   3a478:	7fff7fff 7ffe7fff 7ffb7ffd 7ff77ff9     ................
   3a488:	7ff17ff4 7fea7fee 7fe27fe6 7fd87fdd     ................
   3a498:	7fcd7fd2 7fc07fc6 7fb27fb9 7fa27faa     ................
   3a4a8:	7f917f9a 7f7f7f88 7f6b7f75 7f567f61     ........u.k.a.V.
   3a4b8:	7f407f4b 7f287f34 7f0e7f1b 7ef47f01     K.@.4.(........~
   3a4c8:	7ed87ee6 7eba7ec9 7e9b7eab 7e7b7e8b     .~.~.~.~.~.~.~{~
   3a4d8:	7e597e6a 7e367e48 7e127e24 7dec7dff     j~Y~H~6~$~.~.}.}
   3a4e8:	7dc57dd9 7d9d7db1 7d737d88 7d477d5d     .}.}.}.}.}s}]}G}
   3a4f8:	7d1b7d31 7ced7d04 7cbd7cd5 7c8c7ca5     1}.}.}.|.|.|.|.|
   3a508:	7c5a7c73 7c277c41 7bf27c0c 7bbc7bd7     s|Z|A|'|.|.{.{.{
   3a518:	7b847ba0 7b4b7b68 7b117b2e 7ad57af3     .{.{h{K{.{.{.z.z
   3a528:	7a987ab7 7a5a7a79 7a1a7a3a 79d979fa     .z.zyzZz:z.z.y.y
   3a538:	799779b8 79537975 790e7931 78c878eb     .y.yuySy1y.y.x.x
   3a548:	788078a4 7837785c 77ed7812 77a177c7     .x.x\x7x.x.w.w.w
   3a558:	7754777b 7706772d 76b676de 7665768e     {wTw-w.w.v.v.vev
   3a568:	7613763d 75c075ea 756b7596 75157540     =v.v.u.u.uku@u.u
   3a578:	74be74ea 74657492 740b7438 73b073de     .t.t.tet8t.t.s.s
   3a588:	73547382 72f67325 729772c7 72377267     .sTs%s.r.r.rgr7r
   3a598:	71d67206 717371a4 710f7141 70aa70dc     .r.q.qsqAq.q.p.p
   3a5a8:	70437077 6fdc7010 6f736fa7 6f096f3e     wpCp.p.o.oso>o.o
   3a5b8:	6e9d6ed3 6e316e67 6dc36dfa 6d546d8c     .n.ngn1n.m.m.mTm
   3a5c8:	6ce46d1c 6c736cac 6c006c3a 6b8d6bc7     .m.l.lsl:l.l.k.k
   3a5d8:	6b186b52 6aa26add 6a2a6a66 69b269ee     Rk.k.j.jfj*j.i.i
   3a5e8:	69386975 68be68fb 68426880 67c56804     ui8i.h.h.hBh.h.g
   3a5f8:	67476786 66c86707 66476687 65c66607     .gGg.g.f.fGf.f.e
   3a608:	65436584 64bf6501 643a647d 63b463f8     .eCe.e.d}d:d.c.c
   3a618:	632d6371 62a562ea 621c6261 619261d7     qc-c.b.bab.b.a.a
   3a628:	6106614c 607a60c0 5fed6033 5f5e5fa5     La.a.`z`3`._._^_
   3a638:	5ece5f16 5e3e5e86 5dac5df5 5d1a5d63     ._.^.^>^.].]c].]
   3a648:	5c865cd0 5bf15c3c 5b5b5ba6 5ac55b10     .\.\<\.[.[[[.[.Z
   3a658:	5a2d5a79 599459e1 58fb5948 586058ad     yZ-Z.Y.YHY.X.X`X
   3a668:	57c45812 57285776 568a56d9 55ec563b     .X.WvW(W.V.V;V.U
   3a678:	554c559c 54ac54fc 540b545b 536853ba     .ULU.T.T[T.T.ShS
   3a688:	52c55317 52215273 517c51cf 50d65129     .S.RsR!R.Q|Q)Q.P
   3a698:	50305083 4f884fdc 4ee04f34 4e364e8b     .P0P.O.O4O.N.N6N
   3a6a8:	4d8c4de1 4ce14d37 4c354c8b 4b884bdf     .M.M7M.L.L5L.K.K
   3a6b8:	4adb4b32 4a2c4a84 497d49d5 48cd4925     2K.J.J,J.I}I%I.H
   3a6c8:	481c4875 476b47c4 46b84712 4605465f     uH.H.GkG.G.F_F.F
   3a6d8:	455145ab 449d44f7 43e74442 4331438c     .EQE.D.DBD.C.C1C
   3a6e8:	427a42d6 41c3421f 410a4167 405140ae     .BzB.B.AgA.A.@Q@
   3a6f8:	3f973ff4 3edd3f3a 3e223e7f 3d663dc4     .?.?:?.>.>">.=f=
   3a708:	3ca93d08 3bec3c4b 3b2e3b8d 3a703acf     .=.<K<.;.;.;.:p:
   3a718:	39b13a10 38f13951 38313891 377037d0     .:.9Q9.8.818.7p7
   3a728:	36ae370f 35ec364d 3529358a 346634c7     .7.6M6.5.5)5.4f4
   3a738:	33a23404 32dd333f 3218327b 315231b5     .4.3?3.2{2.2.1R1
   3a748:	308c30ef 2fc63029 2efe2f62 2e372e9a     .0.0)0./b/....7.
   3a758:	2d6e2dd2 2ca62d0a 2bdc2c41 2b132b78     .-n-.-.,A,.+x+.+
   3a768:	2a482aae 297e29e3 28b32918 27e7284d     .*H*.)~).).(M(.'
   3a778:	271b2781 264f26b5 258225e8 24b5251b     .'.'.&O&.%.%.%.$
   3a788:	23e7244e 23192380 224a22b2 217c21e3     N$.#.#.#."J".!|!
   3a798:	20ac2114 1fdd2045 1f0d1f75 1e3d1ea5     .!. E ..u.....=.
   3a7a8:	1d6c1dd5 1c9b1d04 1bca1c33 1af91b61     ..l.....3...a...
   3a7b8:	1a271a90 195519be 188218ec 17b01819     ..'...U.........
   3a7c8:	16dd1746 160a1673 153615a0 146314cd     F...s.....6...c.
   3a7d8:	138f13f9 12bb1325 11e71251 1112117c     ....%...Q...|...
   3a7e8:	103d10a8 0f690fd3 0e940efe 0dbe0e29     ..=...i.....)...
   3a7f8:	0ce90d54 0c140c7e 0b3e0ba9 0a680ad3     T...~.....>...h.
   3a808:	099309fe 08bd0928 07e70852 0711077c     ....(...R...|...
   3a818:	063a06a6 056405cf 048e04f9 03b80423     ..:...d.....#...
   3a828:	02e1034c 020b0276 013401a0 005e00c9     L...v.....4...^.
   3a838:	ff87fff3 feb1ff1c fddafe46 fd04fd6f     ........F...o...
   3a848:	fc2efc99 fb57fbc2 fa81faec f9abfa16     ......W.........
   3a858:	f8d5f940 f7fff86a f729f793 f653f6be     @...j.....)...S.
   3a868:	f57df5e8 f4a7f512 f3d2f43c f2fcf367     ..}.....<...g...
   3a878:	f227f291 f152f1bc f07df0e7 efa8f012     ..'...R...}.....
   3a888:	eed3ef3e edffee69 ed2bed95 ec57ecc1     >...i.....+...W.
   3a898:	eb83ebed eaafeb19 e9dcea46 e909e972     ........F...r...
   3a8a8:	e836e89f e763e7cd e691e6fa e5bfe628     ..6...c.....(...
   3a8b8:	e4ede556 e41ce484 e34be3b3 e27ae2e2     V.........K...z.
   3a8c8:	e1a9e211 e0d9e141 e009e071 df3adfa1     ....A...q.....:.
   3a8d8:	de6bded2 dd9cde03 dccddd35 dbffdc66     ..k.....5...f...
   3a8e8:	db32db99 da65dacb d998d9fe d8cbd932     ..2...e.....2...
   3a8f8:	d7ffd865 d734d79a d669d6ce d59ed604     e.....4...i.....
   3a908:	d4d4d539 d40bd46f d341d3a6 d279d2dd     9...o.....A...y.
   3a918:	d1b0d214 d0e9d14d d022d085 cf5bcfbe     ....M....."...[.
   3a928:	ce95cef8 cdcfce32 cd0acd6d cc46cca8     ....2...m.....F.
   3a938:	cb82cbe4 cabfcb20 c9fcca5d c93ac99b     .... ...].....:.
   3a948:	c878c8d9 c7b7c818 c6f7c757 c637c697     ..x.....W.....7.
   3a958:	c578c5d8 c4bac519 c3fcc45b c33fc39d     ..x.....[.....?.
   3a968:	c283c2e1 c1c7c225 c10cc169 c051c0ae     ....%...i.....Q.
   3a978:	bf98bff4 bedfbf3b be26be82 bd6fbdcb     ....;.....&...o.
   3a988:	bcb8bd13 bc02bc5d bb4dbba7 ba98baf2     ....].....M.....
   3a998:	b9e4ba3e b931b98b b87fb8d8 b7cdb826     >.....1.....&...
   3a9a8:	b71db775 b66db6c5 b5beb615 b50fb566     u.....m.....f...
   3a9b8:	b462b4b9 b3b5b40c b30ab35f b25fb2b4     ..b....._....._.
   3a9c8:	b1b5b209 b10bb160 b063b0b7 afbbb00f     ....`.....c.....
   3a9d8:	af15af68 ae6faec2 adcaae1d ad26ad78     h.....o.....x.&.
   3a9e8:	ac83acd5 abe1ac32 ab40ab90 aaa0aaf0     ....2.....@.....
   3a9f8:	aa00aa50 a962a9b1 a8c5a913 a828a876     P.....b.....v.(.
   3aa08:	a78da7da a6f2a73f a659a6a5 a5c0a60c     ....?.....Y.....
   3aa18:	a528a574 a492a4dd a3fca447 a368a3b2     t.(.....G.....h.
   3aa28:	a2d4a31e a242a28b a1b0a1f9 a120a168     ......B.....h. .
   3aa38:	a090a0d8 a002a049 9f749fbb 9ee89f2e     ....I.....t.....
   3aa48:	9e5d9ea2 9dd39e18 9d4a9d8e 9cc29d05     ..].......J.....
   3aa58:	9c3b9c7e 9bb59bf8 9b309b72 9aad9aee     ~.;.....r.0.....
   3aa68:	9a2a9a6b 99a999e9 99299968 98a998e9     k.*.....h.).....
   3aa78:	982b986a 97af97ed 97339771 96b896f5     j.+.....q.3.....
   3aa88:	963f967b 95c79603 9550958b 94da9514     {.?.......P.....
   3aa98:	9465949f 93f1942b 937f93b8 930e9346     ..e.+.......F...
   3aaa8:	929e92d6 922f9266 91c191f8 9155918b     ....f./.......U.
   3aab8:	90ea911f 908090b5 9017904c 8fb08fe3     ........L.......
   3aac8:	8f4a8f7d 8ee58f17 8e818eb2 8e1e8e4f     }.J.........O...
   3aad8:	8dbd8ded 8d5d8d8d 8cfe8d2d 8ca18ccf     ......].-.......
   3aae8:	8c448c72 8be98c17 8b908bbc 8b378b63     r.D.........c.7.
   3aaf8:	8ae08b0b 8a8a8ab5 8a368a60 89e28a0c     ........`.6.....
   3ab08:	899089b9 89408968 88f08918 88a288c9     ....h.@.........
   3ab18:	8855887c 880a8830 87c087e5 8777879b     |.U.0.........w.
   3ab28:	872f8753 86e9870c 86a486c7 86618682     S./...........a.
   3ab38:	861f8640 85de85fe 859e85be 8560857f     @.............`.
   3ab48:	85238542 84e88505 84ae84cb 84758491     B.#...........u.
   3ab58:	843e8459 84078422 83d383ed 839f83b9     Y.>."...........
   3ab68:	836d8386 833d8355 830e8325 82e082f6     ..m.U.=.%.......
   3ab78:	82b382c9 8288829d 825e8273 8236824a     ........s.^.J.6.
   3ab88:	820f8222 81e981fc 81c581d7 81a281b3     "...............
   3ab98:	81818191 81618171 81428151 81258133     ....q.a.Q.B.3.%.
   3aba8:	81098117 80ee80fb 80d580e2 80bd80c9     ................
   3abb8:	80a780b2 8092809c 807f8088 806d8075     ............u.m.
   3abc8:	805c8064 804c8054 803e8045 80328038     d.\.T.L.E.>.8.2.
   3abd8:	8027802c 801d8022 80158019 800e8011     ,.'."...........
   3abe8:	8008800b 80048006 80018003 80018001     ................
   3abf8:	7fff7fff 7ff97ffd 7fee7ff4 7fdc7fe6     ................
   3ac08:	7fc67fd2 7fa97fb8 7f877f99 7f607f74     ............t.`.
   3ac18:	7f327f4a 7f007f1a 7ec77ee4 7e897ea9     J.2......~.~.~.~
   3ac28:	7e467e68 7dfd7e22 7dae7dd6 7d5a7d85     h~F~"~.}.}.}.}Z}
   3ac38:	7d017d2e 7ca27cd2 7c3d7c70 7bd47c09     .}.}.|.|p|=|.|.{
   3ac48:	7b647b9d 7aef7b2a 7a757ab3 79f67a36     .{d{*{.z.zuz6z.y
   3ac58:	797179b4 78e7792c 785778a0 77c2780d     .yqy,y.x.xWx.x.w
   3ac68:	77287776 768976d9 75e57637 753b7590     vw(w.v.v7v.u.u;u
   3ac78:	748c74e4 73d87433 731f737c 726172c1     .t.t3t.s|s.s.rar
   3ac88:	719e7200 70d6713b 70097070 6f376fa1     .r.q;q.ppp.p.o7o
   3ac98:	6e616ecd 6d856df3 6ca46d15 6bbf6c32     .nan.m.m.m.l2l.k
   3aca8:	6ad56b4b 69e76a5f 68f4696e 67fc6878     Kk.j_j.ini.hxh.g
   3acb8:	66ff677e 65fe667f 64f9657c 63ef6475     ~g.f.f.e|e.dud.c
   3acc8:	62e16369 61ce6258 60b86144 5f9d602b     ic.bXb.aDa.`+`._
   3acd8:	5e7d5f0d 5d5a5dec 5c325cc7 5b075b9d     ._}^.]Z].\2\.[.[
   3ace8:	59d75a70 58a4593e 576c5809 563156cf     pZ.Y>Y.X.XlW.V1V
   3acf8:	54f25592 53af5451 5269530d 511f51c5     .U.TQT.S.SiR.Q.Q
   3ad08:	4fd25079 4e804f29 4d2c4dd7 4bd44c80     yP.O)O.N.M,M.L.K
   3ad18:	4a794b27 491a49ca 47b9486a 46544707     'KyJ.I.IjH.G.GTF
   3ad28:	44ec45a0 43814437 421342ca 40a2415b     .E.D7D.C.B.B[A.@
   3ad38:	3f2f3fe9 3db83e74 3c3f3cfc 3ac33b82     .?/?t>.=.<?<.;.:
   3ad48:	39453a04 37c43885 36413703 34bb357e     .:E9.8.7.7A6~5.4
   3ad58:	333333f7 31a9326e 301d30e3 2e8e2f56     .333n2.1.0.0V/..
   3ad68:	2cfd2dc6 2b6b2c34 29d62aa1 2840290c     .-.,4,k+.*.).)@(
   3ad78:	26a82774 250e25db 23732441 21d622a5     t'.&.%.%A$s#.".!
   3ad88:	20382107 1e981f68 1cf71dc7 1b541c26     .!8 h.......&.T.
   3ad98:	19b11a83 180c18de 16661739 14bf1593     ........9.f.....
   3ada8:	131813ec 116f1243 0fc6109b 0e1c0ef1     ....C.o.........
   3adb8:	0c710d47 0ac60b9c 091a09f0 076e0844     G.q.........D.n.
   3adc8:	05c20698 041504ec 0269033f 00bc0192     ........?.i.....
   3add8:	ff0fffe5 fd62fe38 fbb5fc8b fa08fadf     ....8.b.........
   3ade8:	f85cf932 f6b0f786 f505f5da f359f42f     2.\........./.Y.
   3adf8:	f1aff284 f005f0da ee5cef30 ecb3ed88     ........0.\.....
   3ae08:	eb0cebdf e965ea38 e7bfe892 e61be6ed     ....8.e.........
   3ae18:	e477e549 e2d5e3a6 e134e204 df94e064     I.w.......4.d...
   3ae28:	ddf6dec5 dc59dd28 dabedb8c d925d9f1     ....(.Y.......%.
   3ae38:	d78dd859 d5f7d6c2 d463d52d d2d0d399     Y.......-.c.....
   3ae48:	d140d208 cfb2d079 ce26ceeb cc9ccd60     ..@.y.....&.`...
   3ae58:	cb14cbd8 c98fca51 c80cc8cd c68bc74b     ....Q.......K...
   3ae68:	c50dc5cc c392c44f c219c2d5 c0a3c15d     ....O.......]...
   3ae78:	bf2fbfe9 bdbfbe77 bc52bd08 bae7bb9c     ../.w.....R.....
   3ae88:	b97fba33 b81bb8cd b6bab76a b55cb60a     3.......j.....\.
   3ae98:	b401b4ae b2a9b355 b155b1ff b005b0ac     ....U.....U.....
   3aea8:	aeb7af5e ad6eae12 ac28accb aae6ab86     ^.....n...(.....
   3aeb8:	a9a7aa46 a86ca909 a736a7d1 a603a69c     F.....l...6.....
   3aec8:	a4d4a56b a3a8a43e a281a314 a15fa1f0     k...>........._.
   3aed8:	a040a0cf 9f259fb2 9e0f9e9a 9cfd9d85     ..@...%.........
   3aee8:	9bef9c76 9ae69b6a 99e19a63 98e19960     v...j...c...`...
   3aef8:	97e59862 96ee9769 95fb9674 950d9584     b...i...t.......
   3af08:	94249498 933f93b1 925f92cf 918491f1     ..$...?..._.....
   3af18:	90ae9119 8fdd9045 8f118f76 8e498eac     ....E...v.....I.
   3af28:	8d878de7 8cc98d27 8c118c6d 8b5e8bb7     ....'...m.....^.
   3af38:	8ab08b06 8a078a5a 896389b4 88c48913     ....Z.....c.....
   3af48:	882b8877 879787e0 8708874f 867e86c2     w.+.....O.....~.
   3af58:	85fa863c 857b85ba 8502853e 848e84c7     <.....{.>.......
   3af68:	841f8456 83b683ea 83528383 82f48322     V.........R."...
   3af78:	829b82c6 82478270 81fa8220 81b181d5     ....p.G. .......
   3af88:	816f818f 8131814f 80fa8115 80c880e0     ..o.O.1.........
   3af98:	809b80b1 80748087 80538063 80378044     ......t.c.S.D.7.
   3afa8:	8021802c 80118018 8006800b 80018002     ,.!.............
   3afb8:	7ffc7fff 7fe57ff3 7fb67fd0 7f727f97     ..............r.
   3afc8:	7f177f47 7ea57ee1 7e1e7e64 7d807dd1     G....~.~d~.~.}.}
   3afd8:	7ccc7d29 7c037c6a 7b237b96 7a2e7aab     )}.|j|.|.{#{.z.z
   3afe8:	792479ac 78047897 76cf776c 7586762d     .y$y.x.xlw.v-v.u
   3aff8:	742874d9 72b57371 712e71f4 6f947063     .t(tqs.r.q.qcp.o
   3b008:	6de66ebf 6c246d07 6a506b3c 6869695f     .n.m.m$l<kPj_iih
   3b018:	666f676e 6464656c 62476358 60196132     ngofleddXcGb2a.`
   3b028:	5dda5efb 5b8a5cb4 592b5a5d 56bc57f5     .^.].\.[]Z+Y.W.V
   3b038:	543d557e 51b052f8 4f145064 4c6b4dc1     ~U=T.R.QdP.O.MkL
   3b048:	49b44b11 46f04854 4420458a 414442b3     .K.ITH.F.E D.BDA
   3b058:	3e5c3fd2 3b6a3ce4 386d39ed 356636eb     .?\>.<j;.9m8.6f5
   3b068:	325633df 2f3d30ca 2c1b2dad 28f22a88     .3V2.0=/.-.,.*.(
   3b078:	25c2275b 228b2427 1f4e20ed 1c0c1dad     ['.%'$.". N.....
   3b088:	18c41a68 1578171f 122913d1 0ed61080     h.....x...).....
   3b098:	0b810d2c 082a09d5 04d1067d 01770324     ,.....*.}...$.w.
   3b0a8:	fe1dffca fac4fc71 f76bf918 f414f5c0     ....q.....k.....
   3b0b8:	f0bff269 ed6def16 ea1eebc5 e6d3e878     i.....m.....x...
   3b0c8:	e38ce52f e04ae1ea dd0edeab d9d8db72     /.....J.....r...
   3b0d8:	d6a8d83f d380d513 d060d1ef cd48ced3     ?.........`...H.
   3b0e8:	ca39cbbf c733c8b5 c437c5b4 c146c2bd     ..9...3...7...F.
   3b0f8:	be60bfd2 bb85bcf1 b8b7ba1c b5f4b754     ..`.........T...
   3b108:	b33fb498 b097b1ea adfeaf49 ab72acb6     ..?.....I.....r.
   3b118:	a8f6aa32 a688a7bd a42ba558 a1dda302     2.......X.+.....
   3b128:	9fa0a0bd 9d749e88 9b5a9c65 99509a53     ......t.e.Z.S.P.
   3b138:	97599853 95759665 93a39489 91e492c1     S.Y.e.u.........
   3b148:	9038910b 8ea08f69 8d1c8ddb 8bac8c61     ..8.i.......a...
   3b158:	8a508afb 890989aa 87d7886d 86ba8746     ..P.....m...F...
   3b168:	85b28633 84c08536 83e3844f 831c837d     3...6...O...}...
   3b178:	826b82c1 81d0821b 814b818b 80dd8111     ..k.......K.....
   3b188:	808580ae 80438061 8017802a 8002800a     ....a.C.*.......
   3b198:	7ff27fff 7f927fcd 7ed97f41 7dc87e5c     ........A..~\~.}
   3b1a8:	7c5d7d1d 7a9c7b88 7885799b 76187759     .}]|.{.z.y.xYw.v
   3b1b8:	735a74c3 704a71dc 6ceb6ea4 69406b1f     .tZs.qJp.n.l.k@i
   3b1c8:	654b674f 610f6336 5c8f5ed7 57ce5a37     OgKe6c.a.^.\7Z.W
   3b1d8:	52cf5556 4d97503a 48284ae6 4286455d     VU.R:P.M.J(H]E.B
   3b1e8:	3cb53fa3 36ba39bd 309933ae 2a552d7b     .?.<.9.6.3.0{-U*
   3b1f8:	23f42728 1d7920b9 16ea1a34 104b139c     ('.#. y.4.....K.
   3b208:	09a00cf7 02ef0648 fc3bff95 f58af8e2     ....H.....;.....
   3b218:	eee1f234 e843eb90 e1b6e4fa db3fde77     4.....C.....w.?.
   3b228:	d4e1d80c cea1d1bd c884cb8e c28ec584     ................
   3b238:	bcc3bfa3 b728b9ef b1bfb46d ac8daf1f     ......(.m.......
   3b248:	a796aa0a a2dda532 9e66a099 9a329c43     ....2.....f.C.2.
   3b258:	96469833 92a5946c 8f5090f1 8c4a8dc3     3.F.l.....P...J.
   3b268:	89958ae5 8734885a 85278623 83718441     ....Z.4.#.'.A.q.
   3b278:	821182b6 810b8183 805d80a8 80098027     ..........].'...

0003b288 <mode48000_960_120>:
   3b288:	0000bb80 00000078 00000015 00000015     ....x...........
   3b298:	00006ccd 20001000 000394a8 00000003     .l..... ........
   3b2a8:	00000008 00000078 0000000b 000390bc     ....x...........
   3b2b8:	0003a44c 0003b2ec 00000780 00000003     L...............
   3b2c8:	00039bdc 00039c18 00039c54 00039c90     ........T.......
   3b2d8:	0003a478 00000188 000393d4 000391a4     x...............
   3b2e8:	0003932c                                ,...

0003b2ec <window120>:
   3b2ec:	00140002 006c0037 010a00b2 01ee0174     ....7.l.....t...
   3b2fc:	0318027b 048503c6 06360555 08290727     {.......U.6.'.).
   3b30c:	0a5b093a 0ccc0b8c 0f790e1b 125f10e5     :.[.......y..._.
   3b31c:	157b13e6 18ca171c 1c491a84 1ff31e19     ..{.......I.....
   3b32c:	23c421d7 27b725b9 2bc729bc 2fef2dd8     .!.#.%.'.).+.-./
   3b33c:	3429320a 386f364b 3cbb3a95 41083ee2     .2)4K6o8.:.<.>.A
   3b34c:	4550432d 498b476f 4db54ba3 51c84fc2     -CPEoG.I.K.M.O.Q
   3b35c:	55be53c7 599357ad 5d425b6f 60c65f0a     .S.U.W.Yo[B]._.`
   3b36c:	641d6278 674365b7 6a3668c3 6cf56b9c     xb.d.eCg.h6j.k.l
   3b37c:	6f7d6e40 71cf70ad 73ea72e3 75d074e4     @n}o.p.q.r.s.t.u
   3b38c:	778276b0 79017848 7a5179af 7b727ae7     .v.wHx.y.yQz.zr{
   3b39c:	7c697bf3 7d397cd6 7de57d94 7e727e2f     .{i|.|9}.}.}/~r~
   3b3ac:	7ee17ead 7f387f10 7f7a7f5c 7fab7f95     .~.~..8.\.z.....
   3b3bc:	7fcd7fbd 7fe47fd9 7ff27fec 7ffa7ff6     ................
   3b3cc:	7ffe7ffc 7fff7fff 7fff7fff 7fff7fff     ................

0003b3dc <second_check>:
	...
   3b3e4:	00000003 00000002 00000003 00000002     ................
   3b3f4:	00000005 00000002 00000003 00000002     ................
   3b404:	00000003 00000002 00000005 00000002     ................
   3b414:	00000003 00000002                       ........

0003b41c <beta_coef>:
   3b41c:	570a75c3 199a2f5c                       .u.W\/..

0003b424 <eMeans>:
   3b424:	555c6467 46484d51 47494b4e 48454a4e     gd\UQMHFNKIGNJEH
   3b434:	474c4a46 3c3c3c3c 0000003c              FJLG<<<<<...

0003b440 <e_prob_model>:
   3b440:	81417f48 80418042 803e8040 80408040     H.A.B.A.@.>.@.@.
   3b450:	4f5c4e5c 4f5a4e5c 28732974 1a842872     \N\O\NZOt)s(r(..
   3b460:	11911a84 0ab00ca1 b3180bb1 87368a30     ............0.6.
   3b470:	86358436 84378538 723d8437 584a6046     6.5.8.7.7.=rF`JX
   3b480:	4a57584b 435b4259 326c3b64 257a2878     KXWJYB[Cd;l2x(z%
   3b490:	324e2b61 51544e53 4a564b58 495a4757     a+N2SNTQXKVJWGZI
   3b4a0:	4a5d4a5d 2472286d 22752275 1291118f     ]J]Jm(r$u"u"....
   3b4b0:	0ca21392 07b20aa5 08be06bd b21709b1     ................
   3b4c0:	663f7336 63456242 5b47594a 594e5b49     6s?fBbEcJYG[I[NY
   3b4d0:	425c5056 3b66405d 3c683c67 2c7b3475     VP\B]@f;g<h<u4{,
   3b4e0:	1f85238a 2d4d2661 3c5d5a3d 296b2a69     .#..a&M-=Z]<i*k)
   3b4f0:	26742d6e 26702671 1b841a7c 148c1388     n-t&q&p&|.......
   3b500:	109f0e9b 0daa129e 08bb0ab1 09af06c0     ................
   3b510:	b2150a9f 56476e3b 5354554b 4958425b     ....;nGVKUTS[BXI
   3b520:	4b5c4857 3a694862 3473366b 38703772     WH\KbHi:k6s4r7p8
   3b530:	28843381 1d8c2196 2a4d2362 4260792a     .3.(.!..b#M**y`B
   3b540:	286f2b6c 207b2c75 21772478 2286217f     l+o(u,{ x$w!.!."
   3b550:	1793158b 199e1498 15a61a9a 0db810ad     ................
   3b560:	0d960ab8 b2160f8b 524a723f 525c5354     ........?rJRTS\R
   3b570:	48603e67 49654360 3771486b 347d3476     g>`H`CeIkHq7v4}4
   3b580:	37753476 27893187 1d91209d 284d2161     v4u7.1.'. ..a!M(

0003b590 <pred_coef>:
   3b590:	66007300 40005300                       .s.f.S.@

0003b598 <small_energy_icdf>:
   3b598:	00000102                                ....

0003b59c <LOG2_FRAC_TABLE>:
   3b59c:	100d0800 18171513 1d1c1b1a 20201f1e     ..............  
   3b5ac:	23222221 25252424                       !""#$$%%

0003b5b4 <SPREAD_FACTOR.7576>:
   3b5b4:	0000000f 0000000a 00000005              ............

0003b5c0 <CSWTCH.166>:
   3b5c0:	0000000d 00000011 00000011 00000013     ................

0003b5d0 <fec_thresholds>:
   3b5d0:	00002ee0 000003e8 000036b0 000003e8     .........6......
   3b5e0:	00003e80 000003e8 00004e20 000003e8     .>...... N......
   3b5f0:	000055f0 000003e8                       .U......

0003b5f8 <mono_music_bandwidth_thresholds>:
   3b5f8:	00002328 000002bc 00002328 000002bc     (#......(#......
   3b608:	00002af8 000003e8 00002ee0 000007d0     .*..............

0003b618 <mono_voice_bandwidth_thresholds>:
   3b618:	00002328 000002bc 00002328 000002bc     (#......(#......
   3b628:	000034bc 000003e8 000036b0 000007d0     .4.......6......

0003b638 <rate_table.8934>:
	...
   3b64c:	00002ee0 00002710 00002710 00002af8     .....'...'...*..
   3b65c:	00002af8 00003e80 000034bc 000034bc     .*...>...4...4..
   3b66c:	00003a98 00003a98 00004e20 00003e80     .:...:.. N...>..
   3b67c:	00003e80 00004650 00004650 00005dc0     .>..PF..PF...]..
   3b68c:	00004650 00004650 00005208 00005208     PF..PF...R...R..
   3b69c:	00007d00 000055f0 000055f0 00006d60     .}...U...U..`m..
   3b6ac:	00006d60 0000fa00 00009470 00009470     `m......p...p...
   3b6bc:	0000c350 0000c350                       P...P...

0003b6c4 <stereo_music_bandwidth_thresholds>:
   3b6c4:	00002328 000002bc 00002328 000002bc     (#......(#......
   3b6d4:	00002af8 000003e8 00002ee0 000007d0     .*..............

0003b6e4 <stereo_voice_bandwidth_thresholds>:
   3b6e4:	00002328 000002bc 00002328 000002bc     (#......(#......
   3b6f4:	000034bc 000003e8 000036b0 000007d0     .4.......6......

0003b704 <g_sBspUartConfig>:
   3b704:	0001c200 00000060 00000000 00000000     ....`...........
   3b714:	00000000 00000012 00000000 00000000     ................
	...

0003b72c <g_AM_BSP_GPIO_COM_UART_RX>:
   3b72c:	00000000                                ....

0003b730 <g_AM_BSP_GPIO_COM_UART_TX>:
   3b730:	00000000                                ....

0003b734 <am_hal_cachectrl_defaults>:
   3b734:	00000308                                ....

0003b738 <g_am_hal_mcuctrl_flash_size>:
   3b738:	00004000 00008000 00010000 00020000     .@..............
   3b748:	00040000 00080000 00100000 00200000     .............. .
	...

0003b778 <g_am_hal_mcuctrl_sram_size>:
   3b778:	00004000 00008000 00010000 00020000     .@..............
   3b788:	00040000 00080000 00100000 00060000     ................
	...

0003b7b8 <am_hal_pwrctrl_peripheral_control>:
	...
   3b7c4:	00000001 00000004 00000004 00000002     ................
   3b7d4:	00000008 00000008 00000004 00000008     ................
   3b7e4:	00000008 00000008 00000008 00000008     ................
   3b7f4:	00000010 00000010 00000010 00000020     ............ ...
   3b804:	00000010 00000010 00000040 00000010     ........@.......
   3b814:	00000010 00000080 00000004 00000004     ................
   3b824:	00000100 00000004 00000004 00000200     ................
   3b834:	00000020 00000020 00000400 00000004      ... ...........
   3b844:	00000004 00000800 00000040 00000040     ........@...@...
   3b854:	00001000 00000080 00000080 00002000     ............. ..
   3b864:	00000100 00000100                       ........
