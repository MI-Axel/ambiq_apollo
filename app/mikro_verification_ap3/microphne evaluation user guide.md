# Microphone Evaluation
This project is designed to dump out the audio data get from mikro board with both DMics and AMics.

Now, it only supports AMic and DMic data dump out through UART0 of Apollo3 EVB.

## Analog Microphone configuration
```
/* ADC clock related */

    ADCConfig.eClock             = AM_HAL_ADC_CLKSEL_HFRC;
    ADCConfig.ePolarity          = AM_HAL_ADC_TRIGPOL_RISING;
    ADCConfig.eTrigger           = AM_HAL_ADC_TRIGSEL_SOFTWARE;
    ADCConfig.eReference         = AM_HAL_ADC_REFSEL_INT_2P0;
    ADCConfig.eClockMode         = AM_HAL_ADC_CLKMODE_LOW_LATENCY;
    ADCConfig.ePowerMode         = AM_HAL_ADC_LPMODE0;
    ADCConfig.eRepeat            = AM_HAL_ADC_REPEATING_SCAN;
    
/* ADC slot related */

    ADCSlotConfig.eMeasToAvg      = AM_HAL_ADC_SLOT_AVG_1;
    ADCSlotConfig.ePrecisionMode  = AM_HAL_ADC_SLOT_14BIT;
    ADCSlotConfig.eChannel        = AM_HAL_ADC_SLOT_CHSEL_SE5;
    ADCSlotConfig.bWindowCompare  = false;
    ADCSlotConfig.bEnabled        = true;

/* ADC repeat mode trigger related */

    am_hal_ctimer_period_set(3, AM_HAL_CTIMER_TIMERA, 750, 375);

    //
    // Enable the timer A3 to trigger the ADC directly
    //
    am_hal_ctimer_adc_trigger_enable();

```
The above code is related to ADC module configuration. Key features as following:

* 14-bit ADC result without accumulation
* Reference voltage is 2.0V
* Repeat mode with timer A3 continuously triggered
* 16000HZ sample rate

We configure UART0(am_util_stdio_printf) to dump out data of microphones. Baud rate is 115200, all other configuration keep default.

When you open the serial terminal and power up the apollo3v evb board, you will find LED0 flicker with 1 HZ and the following log info:

```
Apollo3 operating in Burst Mode (96MHz)

Microphone verification procedure is ready!

```
When you push button 0, and you will find the following log info:

```
Waiting 2 seconds to evaluate AMic and DMic...
```
after 2 seconds waiting, LED1 lights up and the microphne starts to collect the data of a fixed-length period. Now, the default configuration is 1 second:

```
this code could be found in am_app_mic_verif_board_setup.h

//
// SR = 16000
// AUDIO_DATA_LENGTH = SR * TIME = 16000 * x
//
#define AUDIO_DATA_LENGTH       16000

```
After data collection, LED1 turns off and AMic data starts to dump out:

```
Start to get audio data...
Get Analog Mic data 64000 bytes!
Get PDM audio data 64000 bytes!
Audio data collection ended....Analog Mic data as following:
6956 6946 6953 6924 6938 6957 6957 6950 6959 6940 6973 6944 6958 6962 6963 6967
6934 6971 6954 6961 6939 6937 6924 6918 6953 6951 6920 6934 6960 6959 6965 6942
6935 6934 6933 6944 6943 6940 6946 6917 6927 6948 6936 6942 6952 6949 6936 6958
6940 6953 6951 6966 6926 6929 6921 6930 6930 6952 6914 6930 6966 6971 6939 6965
6958 6945 6958 6958 6941 6942 6943 6948 6949 6949 6919 6955 6963 6960 6968 6963
6968 6968 6961 6960 6945 6941 6944 6933 6928 6951 6919 6933 6958 6958 6952 6955
6970 6968 6973 6950 6951 6942 6924 6942 6928 6941 6924 6948 6948 6952 6938 6960
...
...
...
6949 6948 6951 6964 6954 6931 6936 6931 6927 6923 6953 6952 6960 6968 6979 6942
6967 6948 6959 6943 6939 6954 6921 6954 6944 6939 6948 6928 6971 6949 6965 6942
6960 6972 6966 6947 6940 6940 6929 6931 6933 6955 6947 6926 6942 6946 6948 6961
Send out ALL AMic data! There're totally 16000 samples

All data were sended out...
```
AMic data is actually the result of ADC conversion by Apollo3. And we already move 6 bits to the right to follow the ADC data format:

```
	DebugLogUInt32(g_ui32AD_Val>>6);
``` 
By the way, we also provide the dump out of PCM data generated by the other 2 DMics. Now, it's turned off by default:

```
#if 0
            am_util_stdio_printf("PCM data register values as following: \n\r");
            while(!(am_app_utils_ring_buffer_empty(&am_sys_ring_buffers[AM_APP_RINGBUFF_PCM])))
            {
                uint8_t indx = 0;
                uint32_t ringbuff_ret = 0;
                for(indx==0; indx<16; indx++)
                {
                    ringbuff_ret = am_app_utils_ring_buffer_pop(&am_sys_ring_buffers[AM_APP_RINGBUFF_PCM], &g_ui32PCM_RegVal, 4);
                    if(ringbuff_ret == 4)
                    {    
                        g_ui32OutSamples += 1;
                    }
                    else if(ringbuff_ret ==0)
                    {
                        am_util_stdio_printf("DMic ring buffer is already empty...\n\r");
                        break;
                    }
                    else
                    {
                        am_util_stdio_printf("There're something weired...DMic ring buffer not 4 bytes aligned...\n\r");
                    }

                    //
                    // follow the ADC data format
                    //
                    DebugLogUInt32(g_ui32PCM_RegVal);
                    DebugLog(" ");
                }
                am_util_stdio_printf("\n\r");

            }
            am_util_stdio_printf("Send out ALL DMic data! There're totally %d samples\n\r", g_ui32OutSamples); 
            g_ui32OutSamples = 0;
#endif // 0

```
(This part of code could be found in main.c file.)






















