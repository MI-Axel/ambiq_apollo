
bin/rtos_audio_experiment_platform.axf:     file format elf32-littlearm


Disassembly of section .text:

0000c000 <g_am_pfnVectors>:
    c000:	00 2b 00 10 f5 22 01 00 ed 22 01 00 d1 e9 00 00     .+..."..."......
    c010:	d1 e9 00 00 d1 e9 00 00 d1 e9 00 00 00 00 00 00     ................
	...
    c02c:	b1 de 00 00 f1 22 01 00 00 00 00 00 21 df 00 00     ....."......!...
    c03c:	85 df 00 00 f1 22 01 00 f1 22 01 00 f1 22 01 00     ....."..."..."..
    c04c:	f1 22 01 00 f1 22 01 00 f1 22 01 00 f1 22 01 00     ."..."..."..."..
    c05c:	f1 22 01 00 f1 22 01 00 f1 22 01 00 f1 22 01 00     ."..."..."..."..
    c06c:	f1 22 01 00 f1 22 01 00 f1 22 01 00 f1 22 01 00     ."..."..."..."..
    c07c:	f1 22 01 00 f1 22 01 00 f1 22 01 00 f1 22 01 00     ."..."..."..."..
    c08c:	85 22 01 00 f1 22 01 00 f1 22 01 00 f1 22 01 00     ."..."..."..."..
    c09c:	ad e0 00 00 f1 22 01 00 f1 22 01 00 f1 22 01 00     ....."..."..."..
    c0ac:	f1 22 01 00 f1 22 01 00 f1 22 01 00 f1 22 01 00     ."..."..."..."..
    c0bc:	f1 22 01 00                                         ."..

0000c0c0 <__Patchable>:
	...

0000c100 <memcpy>:
    c100:	4684      	mov	ip, r0
    c102:	ea41 0300 	orr.w	r3, r1, r0
    c106:	f013 0303 	ands.w	r3, r3, #3
    c10a:	d16d      	bne.n	c1e8 <memcpy+0xe8>
    c10c:	3a40      	subs	r2, #64	; 0x40
    c10e:	d341      	bcc.n	c194 <memcpy+0x94>
    c110:	f851 3b04 	ldr.w	r3, [r1], #4
    c114:	f840 3b04 	str.w	r3, [r0], #4
    c118:	f851 3b04 	ldr.w	r3, [r1], #4
    c11c:	f840 3b04 	str.w	r3, [r0], #4
    c120:	f851 3b04 	ldr.w	r3, [r1], #4
    c124:	f840 3b04 	str.w	r3, [r0], #4
    c128:	f851 3b04 	ldr.w	r3, [r1], #4
    c12c:	f840 3b04 	str.w	r3, [r0], #4
    c130:	f851 3b04 	ldr.w	r3, [r1], #4
    c134:	f840 3b04 	str.w	r3, [r0], #4
    c138:	f851 3b04 	ldr.w	r3, [r1], #4
    c13c:	f840 3b04 	str.w	r3, [r0], #4
    c140:	f851 3b04 	ldr.w	r3, [r1], #4
    c144:	f840 3b04 	str.w	r3, [r0], #4
    c148:	f851 3b04 	ldr.w	r3, [r1], #4
    c14c:	f840 3b04 	str.w	r3, [r0], #4
    c150:	f851 3b04 	ldr.w	r3, [r1], #4
    c154:	f840 3b04 	str.w	r3, [r0], #4
    c158:	f851 3b04 	ldr.w	r3, [r1], #4
    c15c:	f840 3b04 	str.w	r3, [r0], #4
    c160:	f851 3b04 	ldr.w	r3, [r1], #4
    c164:	f840 3b04 	str.w	r3, [r0], #4
    c168:	f851 3b04 	ldr.w	r3, [r1], #4
    c16c:	f840 3b04 	str.w	r3, [r0], #4
    c170:	f851 3b04 	ldr.w	r3, [r1], #4
    c174:	f840 3b04 	str.w	r3, [r0], #4
    c178:	f851 3b04 	ldr.w	r3, [r1], #4
    c17c:	f840 3b04 	str.w	r3, [r0], #4
    c180:	f851 3b04 	ldr.w	r3, [r1], #4
    c184:	f840 3b04 	str.w	r3, [r0], #4
    c188:	f851 3b04 	ldr.w	r3, [r1], #4
    c18c:	f840 3b04 	str.w	r3, [r0], #4
    c190:	3a40      	subs	r2, #64	; 0x40
    c192:	d2bd      	bcs.n	c110 <memcpy+0x10>
    c194:	3230      	adds	r2, #48	; 0x30
    c196:	d311      	bcc.n	c1bc <memcpy+0xbc>
    c198:	f851 3b04 	ldr.w	r3, [r1], #4
    c19c:	f840 3b04 	str.w	r3, [r0], #4
    c1a0:	f851 3b04 	ldr.w	r3, [r1], #4
    c1a4:	f840 3b04 	str.w	r3, [r0], #4
    c1a8:	f851 3b04 	ldr.w	r3, [r1], #4
    c1ac:	f840 3b04 	str.w	r3, [r0], #4
    c1b0:	f851 3b04 	ldr.w	r3, [r1], #4
    c1b4:	f840 3b04 	str.w	r3, [r0], #4
    c1b8:	3a10      	subs	r2, #16
    c1ba:	d2ed      	bcs.n	c198 <memcpy+0x98>
    c1bc:	320c      	adds	r2, #12
    c1be:	d305      	bcc.n	c1cc <memcpy+0xcc>
    c1c0:	f851 3b04 	ldr.w	r3, [r1], #4
    c1c4:	f840 3b04 	str.w	r3, [r0], #4
    c1c8:	3a04      	subs	r2, #4
    c1ca:	d2f9      	bcs.n	c1c0 <memcpy+0xc0>
    c1cc:	3204      	adds	r2, #4
    c1ce:	d008      	beq.n	c1e2 <memcpy+0xe2>
    c1d0:	07d2      	lsls	r2, r2, #31
    c1d2:	bf1c      	itt	ne
    c1d4:	f811 3b01 	ldrbne.w	r3, [r1], #1
    c1d8:	f800 3b01 	strbne.w	r3, [r0], #1
    c1dc:	d301      	bcc.n	c1e2 <memcpy+0xe2>
    c1de:	880b      	ldrh	r3, [r1, #0]
    c1e0:	8003      	strh	r3, [r0, #0]
    c1e2:	4660      	mov	r0, ip
    c1e4:	4770      	bx	lr
    c1e6:	bf00      	nop
    c1e8:	2a08      	cmp	r2, #8
    c1ea:	d313      	bcc.n	c214 <memcpy+0x114>
    c1ec:	078b      	lsls	r3, r1, #30
    c1ee:	d08d      	beq.n	c10c <memcpy+0xc>
    c1f0:	f010 0303 	ands.w	r3, r0, #3
    c1f4:	d08a      	beq.n	c10c <memcpy+0xc>
    c1f6:	f1c3 0304 	rsb	r3, r3, #4
    c1fa:	1ad2      	subs	r2, r2, r3
    c1fc:	07db      	lsls	r3, r3, #31
    c1fe:	bf1c      	itt	ne
    c200:	f811 3b01 	ldrbne.w	r3, [r1], #1
    c204:	f800 3b01 	strbne.w	r3, [r0], #1
    c208:	d380      	bcc.n	c10c <memcpy+0xc>
    c20a:	f831 3b02 	ldrh.w	r3, [r1], #2
    c20e:	f820 3b02 	strh.w	r3, [r0], #2
    c212:	e77b      	b.n	c10c <memcpy+0xc>
    c214:	3a04      	subs	r2, #4
    c216:	d3d9      	bcc.n	c1cc <memcpy+0xcc>
    c218:	3a01      	subs	r2, #1
    c21a:	f811 3b01 	ldrb.w	r3, [r1], #1
    c21e:	f800 3b01 	strb.w	r3, [r0], #1
    c222:	d2f9      	bcs.n	c218 <memcpy+0x118>
    c224:	780b      	ldrb	r3, [r1, #0]
    c226:	7003      	strb	r3, [r0, #0]
    c228:	784b      	ldrb	r3, [r1, #1]
    c22a:	7043      	strb	r3, [r0, #1]
    c22c:	788b      	ldrb	r3, [r1, #2]
    c22e:	7083      	strb	r3, [r0, #2]
    c230:	4660      	mov	r0, ip
    c232:	4770      	bx	lr

0000c234 <__aeabi_d2f>:
    c234:	ea4f 0241 	mov.w	r2, r1, lsl #1
    c238:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
    c23c:	bf24      	itt	cs
    c23e:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
    c242:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
    c246:	d90d      	bls.n	c264 <__aeabi_d2f+0x30>
    c248:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    c24c:	ea4f 02c0 	mov.w	r2, r0, lsl #3
    c250:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
    c254:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
    c258:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
    c25c:	bf08      	it	eq
    c25e:	f020 0001 	biceq.w	r0, r0, #1
    c262:	4770      	bx	lr
    c264:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
    c268:	d121      	bne.n	c2ae <__aeabi_d2f+0x7a>
    c26a:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
    c26e:	bfbc      	itt	lt
    c270:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
    c274:	4770      	bxlt	lr
    c276:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    c27a:	ea4f 5252 	mov.w	r2, r2, lsr #21
    c27e:	f1c2 0218 	rsb	r2, r2, #24
    c282:	f1c2 0c20 	rsb	ip, r2, #32
    c286:	fa10 f30c 	lsls.w	r3, r0, ip
    c28a:	fa20 f002 	lsr.w	r0, r0, r2
    c28e:	bf18      	it	ne
    c290:	f040 0001 	orrne.w	r0, r0, #1
    c294:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    c298:	ea4f 23d3 	mov.w	r3, r3, lsr #11
    c29c:	fa03 fc0c 	lsl.w	ip, r3, ip
    c2a0:	ea40 000c 	orr.w	r0, r0, ip
    c2a4:	fa23 f302 	lsr.w	r3, r3, r2
    c2a8:	ea4f 0343 	mov.w	r3, r3, lsl #1
    c2ac:	e7cc      	b.n	c248 <__aeabi_d2f+0x14>
    c2ae:	ea7f 5362 	mvns.w	r3, r2, asr #21
    c2b2:	d107      	bne.n	c2c4 <__aeabi_d2f+0x90>
    c2b4:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
    c2b8:	bf1e      	ittt	ne
    c2ba:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
    c2be:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
    c2c2:	4770      	bxne	lr
    c2c4:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
    c2c8:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    c2cc:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    c2d0:	4770      	bx	lr
    c2d2:	bf00      	nop

0000c2d4 <main>:
int main()
{
    //
    // Set the clock frequency
    //
    am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_SYSCLK_MAX, 0);
    c2d4:	2100      	movs	r1, #0
{
    c2d6:	b508      	push	{r3, lr}
    am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_SYSCLK_MAX, 0);
    c2d8:	4608      	mov	r0, r1
    c2da:	f006 f93f 	bl	1255c <am_hal_clkgen_control>

    //
    // Set the default cache configuration
    //
    am_hal_cachectrl_config(&am_hal_cachectrl_defaults);
    c2de:	480c      	ldr	r0, [pc, #48]	; (c310 <main+0x3c>)
    c2e0:	f006 f908 	bl	124f4 <am_hal_cachectrl_config>
    am_hal_cachectrl_enable();
    c2e4:	f006 f930 	bl	12548 <am_hal_cachectrl_enable>

    //
    // Configure the board for low power.
    //
    am_bsp_low_power_init();
    c2e8:	f006 f85c 	bl	123a4 <am_bsp_low_power_init>
  
    //
    // clear stimer configuration, it may cause exception if retain old value.
    //   
    am_hal_stimer_config(0x03);
    c2ec:	2003      	movs	r0, #3
    c2ee:	f006 fb9d 	bl	12a2c <am_hal_stimer_config>


    //
    // Hardware initialization here
    //
    am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_XTAL_START, 0);
    c2f2:	2100      	movs	r1, #0
    c2f4:	2001      	movs	r0, #1
    c2f6:	f006 f931 	bl	1255c <am_hal_clkgen_control>


    am_AEP_init();
    c2fa:	f005 fec1 	bl	12080 <am_AEP_init>

#if configUSE_SYSVIEWER
    //
    // Configure the SEGGER SystemView Interface.
    //
    SEGGER_SYSVIEW_Conf();
    c2fe:	f005 fe9f 	bl	12040 <SEGGER_SYSVIEW_Conf>
#endif

    am_util_stdio_printf("FreeRTOS stars to operate!\r\n");
    c302:	4804      	ldr	r0, [pc, #16]	; (c314 <main+0x40>)
    c304:	f003 faac 	bl	f860 <am_util_stdio_printf>
    //
    // Start the scheduler.
    //
    vTaskStartScheduler();
    c308:	f000 fe1e 	bl	cf48 <vTaskStartScheduler>

  return 0;
}
    c30c:	2000      	movs	r0, #0
    c30e:	bd08      	pop	{r3, pc}
    c310:	0001387c 	.word	0x0001387c
    c314:	00013534 	.word	0x00013534

0000c318 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    c318:	f100 0308 	add.w	r3, r0, #8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    c31c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    c320:	2200      	movs	r2, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    c322:	6081      	str	r1, [r0, #8]
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    c324:	e9c0 2300 	strd	r2, r3, [r0]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    c328:	e9c0 3303 	strd	r3, r3, [r0, #12]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    c32c:	4770      	bx	lr
    c32e:	bf00      	nop

0000c330 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    c330:	2300      	movs	r3, #0
    c332:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    c334:	4770      	bx	lr
    c336:	bf00      	nop

0000c338 <vListInsertEnd>:
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
    c338:	e9d0 2300 	ldrd	r2, r3, [r0]
{
    c33c:	b410      	push	{r4}
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    c33e:	689c      	ldr	r4, [r3, #8]
    c340:	608c      	str	r4, [r1, #8]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    c342:	689c      	ldr	r4, [r3, #8]
	pxNewListItem->pxNext = pxIndex;
    c344:	604b      	str	r3, [r1, #4]
	( pxList->uxNumberOfItems )++;
    c346:	3201      	adds	r2, #1
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    c348:	6061      	str	r1, [r4, #4]
	pxIndex->pxPrevious = pxNewListItem;
    c34a:	6099      	str	r1, [r3, #8]
}
    c34c:	f85d 4b04 	ldr.w	r4, [sp], #4
	pxNewListItem->pvContainer = ( void * ) pxList;
    c350:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
    c352:	6002      	str	r2, [r0, #0]
}
    c354:	4770      	bx	lr
    c356:	bf00      	nop

0000c358 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    c358:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    c35a:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    c35c:	1c6b      	adds	r3, r5, #1
    c35e:	d011      	beq.n	c384 <vListInsert+0x2c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    c360:	f100 0208 	add.w	r2, r0, #8
    c364:	e000      	b.n	c368 <vListInsert+0x10>
    c366:	461a      	mov	r2, r3
    c368:	6853      	ldr	r3, [r2, #4]
    c36a:	681c      	ldr	r4, [r3, #0]
    c36c:	42ac      	cmp	r4, r5
    c36e:	d9fa      	bls.n	c366 <vListInsert+0xe>

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
    c370:	6804      	ldr	r4, [r0, #0]
	pxNewListItem->pxNext = pxIterator->pxNext;
    c372:	604b      	str	r3, [r1, #4]
	( pxList->uxNumberOfItems )++;
    c374:	3401      	adds	r4, #1
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    c376:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
    c378:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
    c37a:	6051      	str	r1, [r2, #4]
	pxNewListItem->pvContainer = ( void * ) pxList;
    c37c:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
    c37e:	6004      	str	r4, [r0, #0]
}
    c380:	bc30      	pop	{r4, r5}
    c382:	4770      	bx	lr
		pxIterator = pxList->xListEnd.pxPrevious;
    c384:	6902      	ldr	r2, [r0, #16]
    c386:	6853      	ldr	r3, [r2, #4]
    c388:	e7f2      	b.n	c370 <vListInsert+0x18>
    c38a:	bf00      	nop

0000c38c <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    c38c:	6843      	ldr	r3, [r0, #4]
    c38e:	6881      	ldr	r1, [r0, #8]
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    c390:	6902      	ldr	r2, [r0, #16]
{
    c392:	b410      	push	{r4}
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    c394:	6099      	str	r1, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    c396:	6881      	ldr	r1, [r0, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    c398:	6854      	ldr	r4, [r2, #4]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    c39a:	604b      	str	r3, [r1, #4]
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
	( pxList->uxNumberOfItems )--;
    c39c:	6813      	ldr	r3, [r2, #0]
	if( pxList->pxIndex == pxItemToRemove )
    c39e:	4284      	cmp	r4, r0
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    c3a0:	bf08      	it	eq
    c3a2:	6051      	streq	r1, [r2, #4]
	( pxList->uxNumberOfItems )--;
    c3a4:	3b01      	subs	r3, #1
	pxItemToRemove->pvContainer = NULL;
    c3a6:	2100      	movs	r1, #0
    c3a8:	6101      	str	r1, [r0, #16]

	return pxList->uxNumberOfItems;
}
    c3aa:	f85d 4b04 	ldr.w	r4, [sp], #4
	( pxList->uxNumberOfItems )--;
    c3ae:	6013      	str	r3, [r2, #0]
}
    c3b0:	4618      	mov	r0, r3
    c3b2:	4770      	bx	lr

0000c3b4 <xQueueGenericCreate>:
	{
	Queue_t *pxNewQueue;
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
    c3b4:	b3b0      	cbz	r0, c424 <xQueueGenericCreate+0x70>
	{
    c3b6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c3b8:	4606      	mov	r6, r0
    c3ba:	4617      	mov	r7, r2
    c3bc:	460d      	mov	r5, r1

		if( uxItemSize == ( UBaseType_t ) 0 )
    c3be:	b391      	cbz	r1, c426 <xQueueGenericCreate+0x72>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    c3c0:	fb01 f000 	mul.w	r0, r1, r0
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    c3c4:	3048      	adds	r0, #72	; 0x48
    c3c6:	f001 fc89 	bl	dcdc <pvPortMalloc>

		if( pxNewQueue != NULL )
    c3ca:	4604      	mov	r4, r0
    c3cc:	b380      	cbz	r0, c430 <xQueueGenericCreate+0x7c>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
    c3ce:	f100 0348 	add.w	r3, r0, #72	; 0x48
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    c3d2:	6003      	str	r3, [r0, #0]
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
	pxNewQueue->uxItemSize = uxItemSize;
    c3d4:	e9c4 650f 	strd	r6, r5, [r4, #60]	; 0x3c
	taskENTER_CRITICAL();
    c3d8:	f001 fd7c 	bl	ded4 <vPortEnterCritical>
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    c3dc:	e9d4 130f 	ldrd	r1, r3, [r4, #60]	; 0x3c
    c3e0:	6822      	ldr	r2, [r4, #0]
		pxQueue->pcWriteTo = pxQueue->pcHead;
    c3e2:	60a2      	str	r2, [r4, #8]
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    c3e4:	fb01 f103 	mul.w	r1, r1, r3
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    c3e8:	1acb      	subs	r3, r1, r3
    c3ea:	4413      	add	r3, r2
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    c3ec:	2000      	movs	r0, #0
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    c3ee:	440a      	add	r2, r1
		pxQueue->cRxLock = queueUNLOCKED;
    c3f0:	21ff      	movs	r1, #255	; 0xff
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    c3f2:	60e3      	str	r3, [r4, #12]
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    c3f4:	6062      	str	r2, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    c3f6:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->cRxLock = queueUNLOCKED;
    c3f8:	f884 1044 	strb.w	r1, [r4, #68]	; 0x44
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    c3fc:	f104 0010 	add.w	r0, r4, #16
		pxQueue->cTxLock = queueUNLOCKED;
    c400:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    c404:	f7ff ff88 	bl	c318 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    c408:	f104 0024 	add.w	r0, r4, #36	; 0x24
    c40c:	f7ff ff84 	bl	c318 <vListInitialise>
	taskEXIT_CRITICAL();
    c410:	f001 fd7a 	bl	df08 <vPortExitCritical>
	{
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
    c414:	463b      	mov	r3, r7
    c416:	462a      	mov	r2, r5
    c418:	4631      	mov	r1, r6
    c41a:	2073      	movs	r0, #115	; 0x73
    c41c:	f004 ff06 	bl	1122c <SEGGER_SYSVIEW_RecordU32x3>
	}
    c420:	4620      	mov	r0, r4
    c422:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    c424:	e7fe      	b.n	c424 <xQueueGenericCreate+0x70>
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    c426:	2048      	movs	r0, #72	; 0x48
    c428:	f001 fc58 	bl	dcdc <pvPortMalloc>
		if( pxNewQueue != NULL )
    c42c:	4604      	mov	r4, r0
    c42e:	b910      	cbnz	r0, c436 <xQueueGenericCreate+0x82>
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    c430:	2400      	movs	r4, #0
	}
    c432:	4620      	mov	r0, r4
    c434:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    c436:	6024      	str	r4, [r4, #0]
    c438:	e7cc      	b.n	c3d4 <xQueueGenericCreate+0x20>
    c43a:	bf00      	nop

0000c43c <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    c43c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c440:	b087      	sub	sp, #28
    c442:	9203      	str	r2, [sp, #12]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
    c444:	b140      	cbz	r0, c458 <xQueueGenericSend+0x1c>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    c446:	2900      	cmp	r1, #0
    c448:	f000 810e 	beq.w	c668 <xQueueGenericSend+0x22c>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    c44c:	2b02      	cmp	r3, #2
    c44e:	d104      	bne.n	c45a <xQueueGenericSend+0x1e>
    c450:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
    c452:	2a01      	cmp	r2, #1
    c454:	d001      	beq.n	c45a <xQueueGenericSend+0x1e>
    c456:	e7fe      	b.n	c456 <xQueueGenericSend+0x1a>
    c458:	e7fe      	b.n	c458 <xQueueGenericSend+0x1c>
    c45a:	4604      	mov	r4, r0
    c45c:	461f      	mov	r7, r3
    c45e:	460e      	mov	r6, r1
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    c460:	f001 f9da 	bl	d818 <xTaskGetSchedulerState>
    c464:	2800      	cmp	r0, #0
    c466:	f040 80fc 	bne.w	c662 <xQueueGenericSend+0x226>
    c46a:	9b03      	ldr	r3, [sp, #12]
    c46c:	2b00      	cmp	r3, #0
    c46e:	f040 80aa 	bne.w	c5c6 <xQueueGenericSend+0x18a>
    c472:	469a      	mov	sl, r3
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    c474:	f001 fd2e 	bl	ded4 <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    c478:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    c47a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
				{
					portYIELD_WITHIN_API();
    c47c:	f8df 9314 	ldr.w	r9, [pc, #788]	; c794 <xQueueGenericSend+0x358>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    c480:	429a      	cmp	r2, r3
		prvLockQueue( pxQueue );
    c482:	f04f 0800 	mov.w	r8, #0
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    c486:	d375      	bcc.n	c574 <xQueueGenericSend+0x138>
    c488:	2f02      	cmp	r7, #2
    c48a:	f000 80f2 	beq.w	c672 <xQueueGenericSend+0x236>
				if( xTicksToWait == ( TickType_t ) 0 )
    c48e:	9d03      	ldr	r5, [sp, #12]
    c490:	2d00      	cmp	r5, #0
    c492:	f000 8149 	beq.w	c728 <xQueueGenericSend+0x2ec>
				else if( xEntryTimeSet == pdFALSE )
    c496:	f1ba 0f00 	cmp.w	sl, #0
    c49a:	d102      	bne.n	c4a2 <xQueueGenericSend+0x66>
					vTaskSetTimeOutState( &xTimeOut );
    c49c:	a804      	add	r0, sp, #16
    c49e:	f001 f95d 	bl	d75c <vTaskSetTimeOutState>
		taskEXIT_CRITICAL();
    c4a2:	f001 fd31 	bl	df08 <vPortExitCritical>
		vTaskSuspendAll();
    c4a6:	f000 fe41 	bl	d12c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    c4aa:	f001 fd13 	bl	ded4 <vPortEnterCritical>
    c4ae:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    c4b2:	2bff      	cmp	r3, #255	; 0xff
    c4b4:	bf08      	it	eq
    c4b6:	f884 8044 	strbeq.w	r8, [r4, #68]	; 0x44
    c4ba:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    c4be:	2bff      	cmp	r3, #255	; 0xff
    c4c0:	bf08      	it	eq
    c4c2:	f884 8045 	strbeq.w	r8, [r4, #69]	; 0x45
    c4c6:	f001 fd1f 	bl	df08 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    c4ca:	a903      	add	r1, sp, #12
    c4cc:	a804      	add	r0, sp, #16
    c4ce:	f001 f953 	bl	d778 <xTaskCheckForTimeOut>
    c4d2:	2800      	cmp	r0, #0
    c4d4:	f040 810e 	bne.w	c6f4 <xQueueGenericSend+0x2b8>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    c4d8:	f001 fcfc 	bl	ded4 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    c4dc:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    c4de:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    c4e0:	429a      	cmp	r2, r3
    c4e2:	d071      	beq.n	c5c8 <xQueueGenericSend+0x18c>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    c4e4:	f001 fd10 	bl	df08 <vPortExitCritical>
	taskENTER_CRITICAL();
    c4e8:	f001 fcf4 	bl	ded4 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
    c4ec:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
    c4f0:	b26d      	sxtb	r5, r5
		while( cTxLock > queueLOCKED_UNMODIFIED )
    c4f2:	2d00      	cmp	r5, #0
    c4f4:	dd11      	ble.n	c51a <xQueueGenericSend+0xde>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    c4f6:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c4f8:	b17b      	cbz	r3, c51a <xQueueGenericSend+0xde>
    c4fa:	f104 0a24 	add.w	sl, r4, #36	; 0x24
    c4fe:	e001      	b.n	c504 <xQueueGenericSend+0xc8>
    c500:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c502:	b153      	cbz	r3, c51a <xQueueGenericSend+0xde>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    c504:	4650      	mov	r0, sl
    c506:	f001 f8d9 	bl	d6bc <xTaskRemoveFromEventList>
    c50a:	b108      	cbz	r0, c510 <xQueueGenericSend+0xd4>
						vTaskMissedYield();
    c50c:	f001 f964 	bl	d7d8 <vTaskMissedYield>
    c510:	3d01      	subs	r5, #1
    c512:	b2eb      	uxtb	r3, r5
    c514:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    c516:	2b00      	cmp	r3, #0
    c518:	d1f2      	bne.n	c500 <xQueueGenericSend+0xc4>
		pxQueue->cTxLock = queueUNLOCKED;
    c51a:	23ff      	movs	r3, #255	; 0xff
    c51c:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
    c520:	f001 fcf2 	bl	df08 <vPortExitCritical>
	taskENTER_CRITICAL();
    c524:	f001 fcd6 	bl	ded4 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
    c528:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
    c52c:	b26d      	sxtb	r5, r5
		while( cRxLock > queueLOCKED_UNMODIFIED )
    c52e:	2d00      	cmp	r5, #0
    c530:	dd11      	ble.n	c556 <xQueueGenericSend+0x11a>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    c532:	6923      	ldr	r3, [r4, #16]
    c534:	b17b      	cbz	r3, c556 <xQueueGenericSend+0x11a>
    c536:	f104 0a10 	add.w	sl, r4, #16
    c53a:	e001      	b.n	c540 <xQueueGenericSend+0x104>
    c53c:	6923      	ldr	r3, [r4, #16]
    c53e:	b153      	cbz	r3, c556 <xQueueGenericSend+0x11a>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    c540:	4650      	mov	r0, sl
    c542:	f001 f8bb 	bl	d6bc <xTaskRemoveFromEventList>
    c546:	b108      	cbz	r0, c54c <xQueueGenericSend+0x110>
					vTaskMissedYield();
    c548:	f001 f946 	bl	d7d8 <vTaskMissedYield>
    c54c:	3d01      	subs	r5, #1
    c54e:	b2eb      	uxtb	r3, r5
    c550:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    c552:	2b00      	cmp	r3, #0
    c554:	d1f2      	bne.n	c53c <xQueueGenericSend+0x100>
		pxQueue->cRxLock = queueUNLOCKED;
    c556:	23ff      	movs	r3, #255	; 0xff
    c558:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
    c55c:	f001 fcd4 	bl	df08 <vPortExitCritical>
				( void ) xTaskResumeAll();
    c560:	f000 feac 	bl	d2bc <xTaskResumeAll>
		taskENTER_CRITICAL();
    c564:	f001 fcb6 	bl	ded4 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    c568:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    c56a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    c56c:	429a      	cmp	r2, r3
    c56e:	f04f 0a01 	mov.w	sl, #1
    c572:	d289      	bcs.n	c488 <xQueueGenericSend+0x4c>
				traceQUEUE_SEND( pxQueue );
    c574:	4620      	mov	r0, r4
    c576:	f003 fcd5 	bl	ff24 <SEGGER_SYSVIEW_ShrinkId>
    c57a:	4632      	mov	r2, r6
    c57c:	4601      	mov	r1, r0
    c57e:	9b03      	ldr	r3, [sp, #12]
    c580:	9700      	str	r7, [sp, #0]
    c582:	205a      	movs	r0, #90	; 0x5a
    c584:	f005 fd36 	bl	11ff4 <SYSVIEW_RecordU32x4>
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    c588:	6c22      	ldr	r2, [r4, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    c58a:	6ba5      	ldr	r5, [r4, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    c58c:	b17a      	cbz	r2, c5ae <xQueueGenericSend+0x172>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    c58e:	4631      	mov	r1, r6
	else if( xPosition == queueSEND_TO_BACK )
    c590:	2f00      	cmp	r7, #0
    c592:	f040 80a3 	bne.w	c6dc <xQueueGenericSend+0x2a0>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    c596:	68a0      	ldr	r0, [r4, #8]
    c598:	f7ff fdb2 	bl	c100 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    c59c:	68a3      	ldr	r3, [r4, #8]
    c59e:	6c21      	ldr	r1, [r4, #64]	; 0x40
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c5a0:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    c5a2:	440b      	add	r3, r1
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c5a4:	4293      	cmp	r3, r2
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    c5a6:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c5a8:	d301      	bcc.n	c5ae <xQueueGenericSend+0x172>
			pxQueue->pcWriteTo = pxQueue->pcHead;
    c5aa:	6823      	ldr	r3, [r4, #0]
    c5ac:	60a3      	str	r3, [r4, #8]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    c5ae:	6a63      	ldr	r3, [r4, #36]	; 0x24
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    c5b0:	3501      	adds	r5, #1
    c5b2:	63a5      	str	r5, [r4, #56]	; 0x38
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    c5b4:	2b00      	cmp	r3, #0
    c5b6:	f040 8081 	bne.w	c6bc <xQueueGenericSend+0x280>
				taskEXIT_CRITICAL();
    c5ba:	f001 fca5 	bl	df08 <vPortExitCritical>
				return pdPASS;
    c5be:	2001      	movs	r0, #1
}
    c5c0:	b007      	add	sp, #28
    c5c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c5c6:	e7fe      	b.n	c5c6 <xQueueGenericSend+0x18a>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    c5c8:	f104 0a10 	add.w	sl, r4, #16
	taskEXIT_CRITICAL();
    c5cc:	f001 fc9c 	bl	df08 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    c5d0:	4650      	mov	r0, sl
    c5d2:	9903      	ldr	r1, [sp, #12]
    c5d4:	f000 ffd8 	bl	d588 <vTaskPlaceOnEventList>
	taskENTER_CRITICAL();
    c5d8:	f001 fc7c 	bl	ded4 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
    c5dc:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
    c5e0:	b26d      	sxtb	r5, r5
		while( cTxLock > queueLOCKED_UNMODIFIED )
    c5e2:	2d00      	cmp	r5, #0
    c5e4:	dd11      	ble.n	c60a <xQueueGenericSend+0x1ce>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    c5e6:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c5e8:	b17b      	cbz	r3, c60a <xQueueGenericSend+0x1ce>
    c5ea:	f104 0b24 	add.w	fp, r4, #36	; 0x24
    c5ee:	e001      	b.n	c5f4 <xQueueGenericSend+0x1b8>
    c5f0:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c5f2:	b153      	cbz	r3, c60a <xQueueGenericSend+0x1ce>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    c5f4:	4658      	mov	r0, fp
    c5f6:	f001 f861 	bl	d6bc <xTaskRemoveFromEventList>
    c5fa:	b108      	cbz	r0, c600 <xQueueGenericSend+0x1c4>
						vTaskMissedYield();
    c5fc:	f001 f8ec 	bl	d7d8 <vTaskMissedYield>
    c600:	3d01      	subs	r5, #1
    c602:	b2eb      	uxtb	r3, r5
    c604:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    c606:	2b00      	cmp	r3, #0
    c608:	d1f2      	bne.n	c5f0 <xQueueGenericSend+0x1b4>
		pxQueue->cTxLock = queueUNLOCKED;
    c60a:	23ff      	movs	r3, #255	; 0xff
    c60c:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
    c610:	f001 fc7a 	bl	df08 <vPortExitCritical>
	taskENTER_CRITICAL();
    c614:	f001 fc5e 	bl	ded4 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
    c618:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
    c61c:	b26d      	sxtb	r5, r5
		while( cRxLock > queueLOCKED_UNMODIFIED )
    c61e:	2d00      	cmp	r5, #0
    c620:	dc0a      	bgt.n	c638 <xQueueGenericSend+0x1fc>
    c622:	e00c      	b.n	c63e <xQueueGenericSend+0x202>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    c624:	4650      	mov	r0, sl
    c626:	f001 f849 	bl	d6bc <xTaskRemoveFromEventList>
    c62a:	b108      	cbz	r0, c630 <xQueueGenericSend+0x1f4>
					vTaskMissedYield();
    c62c:	f001 f8d4 	bl	d7d8 <vTaskMissedYield>
    c630:	3d01      	subs	r5, #1
    c632:	b2eb      	uxtb	r3, r5
    c634:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    c636:	b113      	cbz	r3, c63e <xQueueGenericSend+0x202>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    c638:	6923      	ldr	r3, [r4, #16]
    c63a:	2b00      	cmp	r3, #0
    c63c:	d1f2      	bne.n	c624 <xQueueGenericSend+0x1e8>
		pxQueue->cRxLock = queueUNLOCKED;
    c63e:	23ff      	movs	r3, #255	; 0xff
    c640:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
    c644:	f001 fc60 	bl	df08 <vPortExitCritical>
				if( xTaskResumeAll() == pdFALSE )
    c648:	f000 fe38 	bl	d2bc <xTaskResumeAll>
    c64c:	2800      	cmp	r0, #0
    c64e:	d189      	bne.n	c564 <xQueueGenericSend+0x128>
					portYIELD_WITHIN_API();
    c650:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    c654:	f8c9 3000 	str.w	r3, [r9]
    c658:	f3bf 8f4f 	dsb	sy
    c65c:	f3bf 8f6f 	isb	sy
    c660:	e780      	b.n	c564 <xQueueGenericSend+0x128>
    c662:	f04f 0a00 	mov.w	sl, #0
    c666:	e705      	b.n	c474 <xQueueGenericSend+0x38>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    c668:	6c02      	ldr	r2, [r0, #64]	; 0x40
    c66a:	2a00      	cmp	r2, #0
    c66c:	f43f aeee 	beq.w	c44c <xQueueGenericSend+0x10>
    c670:	e7fe      	b.n	c670 <xQueueGenericSend+0x234>
				traceQUEUE_SEND( pxQueue );
    c672:	4620      	mov	r0, r4
    c674:	f003 fc56 	bl	ff24 <SEGGER_SYSVIEW_ShrinkId>
    c678:	4632      	mov	r2, r6
    c67a:	4601      	mov	r1, r0
    c67c:	9700      	str	r7, [sp, #0]
    c67e:	9b03      	ldr	r3, [sp, #12]
    c680:	205a      	movs	r0, #90	; 0x5a
    c682:	f005 fcb7 	bl	11ff4 <SYSVIEW_RecordU32x4>
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    c686:	6c22      	ldr	r2, [r4, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    c688:	6ba5      	ldr	r5, [r4, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    c68a:	2a00      	cmp	r2, #0
    c68c:	d08f      	beq.n	c5ae <xQueueGenericSend+0x172>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    c68e:	4631      	mov	r1, r6
    c690:	68e0      	ldr	r0, [r4, #12]
    c692:	f7ff fd35 	bl	c100 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    c696:	6c23      	ldr	r3, [r4, #64]	; 0x40
    c698:	68e2      	ldr	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c69a:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    c69c:	425b      	negs	r3, r3
    c69e:	441a      	add	r2, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c6a0:	428a      	cmp	r2, r1
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    c6a2:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c6a4:	d205      	bcs.n	c6b2 <xQueueGenericSend+0x276>
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    c6a6:	6862      	ldr	r2, [r4, #4]
    c6a8:	4413      	add	r3, r2
    c6aa:	60e3      	str	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
    c6ac:	2f02      	cmp	r7, #2
    c6ae:	f47f af7e 	bne.w	c5ae <xQueueGenericSend+0x172>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    c6b2:	2d00      	cmp	r5, #0
    c6b4:	f43f af7b 	beq.w	c5ae <xQueueGenericSend+0x172>
				--uxMessagesWaiting;
    c6b8:	3d01      	subs	r5, #1
    c6ba:	e778      	b.n	c5ae <xQueueGenericSend+0x172>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    c6bc:	f104 0024 	add.w	r0, r4, #36	; 0x24
    c6c0:	f000 fffc 	bl	d6bc <xTaskRemoveFromEventList>
    c6c4:	2800      	cmp	r0, #0
    c6c6:	f43f af78 	beq.w	c5ba <xQueueGenericSend+0x17e>
							queueYIELD_IF_USING_PREEMPTION();
    c6ca:	4b32      	ldr	r3, [pc, #200]	; (c794 <xQueueGenericSend+0x358>)
    c6cc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    c6d0:	601a      	str	r2, [r3, #0]
    c6d2:	f3bf 8f4f 	dsb	sy
    c6d6:	f3bf 8f6f 	isb	sy
    c6da:	e76e      	b.n	c5ba <xQueueGenericSend+0x17e>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    c6dc:	68e0      	ldr	r0, [r4, #12]
    c6de:	f7ff fd0f 	bl	c100 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    c6e2:	6c23      	ldr	r3, [r4, #64]	; 0x40
    c6e4:	68e2      	ldr	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c6e6:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    c6e8:	425b      	negs	r3, r3
    c6ea:	441a      	add	r2, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c6ec:	428a      	cmp	r2, r1
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    c6ee:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c6f0:	d2dc      	bcs.n	c6ac <xQueueGenericSend+0x270>
    c6f2:	e7d8      	b.n	c6a6 <xQueueGenericSend+0x26a>
	taskENTER_CRITICAL();
    c6f4:	f001 fbee 	bl	ded4 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
    c6f8:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
    c6fc:	b26d      	sxtb	r5, r5
		while( cTxLock > queueLOCKED_UNMODIFIED )
    c6fe:	2d00      	cmp	r5, #0
    c700:	dd20      	ble.n	c744 <xQueueGenericSend+0x308>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    c702:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c704:	b1f3      	cbz	r3, c744 <xQueueGenericSend+0x308>
    c706:	f104 0824 	add.w	r8, r4, #36	; 0x24
    c70a:	e005      	b.n	c718 <xQueueGenericSend+0x2dc>
    c70c:	3d01      	subs	r5, #1
    c70e:	b2eb      	uxtb	r3, r5
    c710:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    c712:	b1bb      	cbz	r3, c744 <xQueueGenericSend+0x308>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    c714:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c716:	b1ab      	cbz	r3, c744 <xQueueGenericSend+0x308>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    c718:	4640      	mov	r0, r8
    c71a:	f000 ffcf 	bl	d6bc <xTaskRemoveFromEventList>
    c71e:	2800      	cmp	r0, #0
    c720:	d0f4      	beq.n	c70c <xQueueGenericSend+0x2d0>
						vTaskMissedYield();
    c722:	f001 f859 	bl	d7d8 <vTaskMissedYield>
    c726:	e7f1      	b.n	c70c <xQueueGenericSend+0x2d0>
					taskEXIT_CRITICAL();
    c728:	f001 fbee 	bl	df08 <vPortExitCritical>
			traceQUEUE_SEND_FAILED( pxQueue );
    c72c:	4620      	mov	r0, r4
    c72e:	f003 fbf9 	bl	ff24 <SEGGER_SYSVIEW_ShrinkId>
    c732:	9700      	str	r7, [sp, #0]
    c734:	4601      	mov	r1, r0
    c736:	4632      	mov	r2, r6
    c738:	205a      	movs	r0, #90	; 0x5a
    c73a:	9b03      	ldr	r3, [sp, #12]
    c73c:	f005 fc5a 	bl	11ff4 <SYSVIEW_RecordU32x4>
			return errQUEUE_FULL;
    c740:	2000      	movs	r0, #0
    c742:	e73d      	b.n	c5c0 <xQueueGenericSend+0x184>
		pxQueue->cTxLock = queueUNLOCKED;
    c744:	23ff      	movs	r3, #255	; 0xff
    c746:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
    c74a:	f001 fbdd 	bl	df08 <vPortExitCritical>
	taskENTER_CRITICAL();
    c74e:	f001 fbc1 	bl	ded4 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
    c752:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
    c756:	b26d      	sxtb	r5, r5
		while( cRxLock > queueLOCKED_UNMODIFIED )
    c758:	2d00      	cmp	r5, #0
    c75a:	dd12      	ble.n	c782 <xQueueGenericSend+0x346>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    c75c:	6923      	ldr	r3, [r4, #16]
    c75e:	b183      	cbz	r3, c782 <xQueueGenericSend+0x346>
    c760:	f104 0810 	add.w	r8, r4, #16
    c764:	e005      	b.n	c772 <xQueueGenericSend+0x336>
    c766:	3d01      	subs	r5, #1
    c768:	b2eb      	uxtb	r3, r5
    c76a:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    c76c:	b14b      	cbz	r3, c782 <xQueueGenericSend+0x346>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    c76e:	6923      	ldr	r3, [r4, #16]
    c770:	b13b      	cbz	r3, c782 <xQueueGenericSend+0x346>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    c772:	4640      	mov	r0, r8
    c774:	f000 ffa2 	bl	d6bc <xTaskRemoveFromEventList>
    c778:	2800      	cmp	r0, #0
    c77a:	d0f4      	beq.n	c766 <xQueueGenericSend+0x32a>
					vTaskMissedYield();
    c77c:	f001 f82c 	bl	d7d8 <vTaskMissedYield>
    c780:	e7f1      	b.n	c766 <xQueueGenericSend+0x32a>
		pxQueue->cRxLock = queueUNLOCKED;
    c782:	23ff      	movs	r3, #255	; 0xff
    c784:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
    c788:	f001 fbbe 	bl	df08 <vPortExitCritical>
			( void ) xTaskResumeAll();
    c78c:	f000 fd96 	bl	d2bc <xTaskResumeAll>
    c790:	e7cc      	b.n	c72c <xQueueGenericSend+0x2f0>
    c792:	bf00      	nop
    c794:	e000ed04 	.word	0xe000ed04

0000c798 <xQueueGenericSendFromISR>:
	configASSERT( pxQueue );
    c798:	b148      	cbz	r0, c7ae <xQueueGenericSendFromISR+0x16>
{
    c79a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    c79e:	2900      	cmp	r1, #0
    c7a0:	d039      	beq.n	c816 <xQueueGenericSendFromISR+0x7e>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    c7a2:	2b02      	cmp	r3, #2
    c7a4:	d104      	bne.n	c7b0 <xQueueGenericSendFromISR+0x18>
    c7a6:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
    c7a8:	2c01      	cmp	r4, #1
    c7aa:	d001      	beq.n	c7b0 <xQueueGenericSendFromISR+0x18>
    c7ac:	e7fe      	b.n	c7ac <xQueueGenericSendFromISR+0x14>
    c7ae:	e7fe      	b.n	c7ae <xQueueGenericSendFromISR+0x16>
    c7b0:	4604      	mov	r4, r0
    c7b2:	4698      	mov	r8, r3
    c7b4:	4617      	mov	r7, r2
    c7b6:	468a      	mov	sl, r1
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
    c7b8:	f001 fc04 	bl	dfc4 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
    c7bc:	f3ef 8911 	mrs	r9, BASEPRI
    c7c0:	f04f 0380 	mov.w	r3, #128	; 0x80
    c7c4:	f383 8811 	msr	BASEPRI, r3
    c7c8:	f3bf 8f6f 	isb	sy
    c7cc:	f3bf 8f4f 	dsb	sy
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    c7d0:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    c7d2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    c7d4:	429a      	cmp	r2, r3
    c7d6:	d322      	bcc.n	c81e <xQueueGenericSendFromISR+0x86>
    c7d8:	f1b8 0f02 	cmp.w	r8, #2
    c7dc:	d163      	bne.n	c8a6 <xQueueGenericSendFromISR+0x10e>
			traceQUEUE_SEND_FROM_ISR( pxQueue );
    c7de:	4620      	mov	r0, r4
			const int8_t cTxLock = pxQueue->cTxLock;
    c7e0:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
			traceQUEUE_SEND_FROM_ISR( pxQueue );
    c7e4:	f003 fb9e 	bl	ff24 <SEGGER_SYSVIEW_ShrinkId>
    c7e8:	463a      	mov	r2, r7
    c7ea:	4601      	mov	r1, r0
    c7ec:	2060      	movs	r0, #96	; 0x60
    c7ee:	f005 f993 	bl	11b18 <SEGGER_SYSVIEW_RecordU32x2>
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    c7f2:	6c22      	ldr	r2, [r4, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    c7f4:	6ba6      	ldr	r6, [r4, #56]	; 0x38
			const int8_t cTxLock = pxQueue->cTxLock;
    c7f6:	b26d      	sxtb	r5, r5
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    c7f8:	2a00      	cmp	r2, #0
    c7fa:	d13e      	bne.n	c87a <xQueueGenericSendFromISR+0xe2>
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    c7fc:	3601      	adds	r6, #1
			if( cTxLock == queueUNLOCKED )
    c7fe:	1c6b      	adds	r3, r5, #1
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    c800:	63a6      	str	r6, [r4, #56]	; 0x38
			if( cTxLock == queueUNLOCKED )
    c802:	d02c      	beq.n	c85e <xQueueGenericSendFromISR+0xc6>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    c804:	1c6b      	adds	r3, r5, #1
    c806:	b25b      	sxtb	r3, r3
    c808:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
			xReturn = pdPASS;
    c80c:	2001      	movs	r0, #1
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
    c80e:	f389 8811 	msr	BASEPRI, r9
}
    c812:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    c816:	6c04      	ldr	r4, [r0, #64]	; 0x40
    c818:	2c00      	cmp	r4, #0
    c81a:	d0c2      	beq.n	c7a2 <xQueueGenericSendFromISR+0xa>
    c81c:	e7fe      	b.n	c81c <xQueueGenericSendFromISR+0x84>
			traceQUEUE_SEND_FROM_ISR( pxQueue );
    c81e:	4620      	mov	r0, r4
			const int8_t cTxLock = pxQueue->cTxLock;
    c820:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
			traceQUEUE_SEND_FROM_ISR( pxQueue );
    c824:	f003 fb7e 	bl	ff24 <SEGGER_SYSVIEW_ShrinkId>
    c828:	463a      	mov	r2, r7
    c82a:	4601      	mov	r1, r0
    c82c:	2060      	movs	r0, #96	; 0x60
    c82e:	f005 f973 	bl	11b18 <SEGGER_SYSVIEW_RecordU32x2>
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    c832:	6c22      	ldr	r2, [r4, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    c834:	6ba6      	ldr	r6, [r4, #56]	; 0x38
			const int8_t cTxLock = pxQueue->cTxLock;
    c836:	b26d      	sxtb	r5, r5
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    c838:	2a00      	cmp	r2, #0
    c83a:	d0df      	beq.n	c7fc <xQueueGenericSendFromISR+0x64>
	else if( xPosition == queueSEND_TO_BACK )
    c83c:	f1b8 0f00 	cmp.w	r8, #0
    c840:	d11b      	bne.n	c87a <xQueueGenericSendFromISR+0xe2>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    c842:	4651      	mov	r1, sl
    c844:	68a0      	ldr	r0, [r4, #8]
    c846:	f7ff fc5b 	bl	c100 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    c84a:	68a3      	ldr	r3, [r4, #8]
    c84c:	6c21      	ldr	r1, [r4, #64]	; 0x40
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c84e:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    c850:	440b      	add	r3, r1
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c852:	4293      	cmp	r3, r2
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    c854:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c856:	d3d1      	bcc.n	c7fc <xQueueGenericSendFromISR+0x64>
			pxQueue->pcWriteTo = pxQueue->pcHead;
    c858:	6823      	ldr	r3, [r4, #0]
    c85a:	60a3      	str	r3, [r4, #8]
    c85c:	e7ce      	b.n	c7fc <xQueueGenericSendFromISR+0x64>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    c85e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c860:	2b00      	cmp	r3, #0
    c862:	d0d3      	beq.n	c80c <xQueueGenericSendFromISR+0x74>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    c864:	f104 0024 	add.w	r0, r4, #36	; 0x24
    c868:	f000 ff28 	bl	d6bc <xTaskRemoveFromEventList>
    c86c:	2800      	cmp	r0, #0
    c86e:	d0cd      	beq.n	c80c <xQueueGenericSendFromISR+0x74>
							if( pxHigherPriorityTaskWoken != NULL )
    c870:	2f00      	cmp	r7, #0
    c872:	d0cb      	beq.n	c80c <xQueueGenericSendFromISR+0x74>
								*pxHigherPriorityTaskWoken = pdTRUE;
    c874:	2001      	movs	r0, #1
    c876:	6038      	str	r0, [r7, #0]
    c878:	e7c9      	b.n	c80e <xQueueGenericSendFromISR+0x76>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    c87a:	4651      	mov	r1, sl
    c87c:	68e0      	ldr	r0, [r4, #12]
    c87e:	f7ff fc3f 	bl	c100 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    c882:	6c23      	ldr	r3, [r4, #64]	; 0x40
    c884:	68e2      	ldr	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c886:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    c888:	425b      	negs	r3, r3
    c88a:	441a      	add	r2, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c88c:	428a      	cmp	r2, r1
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    c88e:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c890:	d202      	bcs.n	c898 <xQueueGenericSendFromISR+0x100>
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    c892:	6862      	ldr	r2, [r4, #4]
    c894:	4413      	add	r3, r2
    c896:	60e3      	str	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
    c898:	f1b8 0f02 	cmp.w	r8, #2
    c89c:	d1ae      	bne.n	c7fc <xQueueGenericSendFromISR+0x64>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    c89e:	2e00      	cmp	r6, #0
    c8a0:	d0ac      	beq.n	c7fc <xQueueGenericSendFromISR+0x64>
				--uxMessagesWaiting;
    c8a2:	3e01      	subs	r6, #1
    c8a4:	e7aa      	b.n	c7fc <xQueueGenericSendFromISR+0x64>
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
    c8a6:	4620      	mov	r0, r4
    c8a8:	f003 fb3c 	bl	ff24 <SEGGER_SYSVIEW_ShrinkId>
    c8ac:	463a      	mov	r2, r7
    c8ae:	4601      	mov	r1, r0
    c8b0:	2060      	movs	r0, #96	; 0x60
    c8b2:	f005 f931 	bl	11b18 <SEGGER_SYSVIEW_RecordU32x2>
			xReturn = errQUEUE_FULL;
    c8b6:	2000      	movs	r0, #0
    c8b8:	e7a9      	b.n	c80e <xQueueGenericSendFromISR+0x76>
    c8ba:	bf00      	nop

0000c8bc <xQueueGenericReceive>:
{
    c8bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c8c0:	b087      	sub	sp, #28
    c8c2:	9203      	str	r2, [sp, #12]
	configASSERT( pxQueue );
    c8c4:	2800      	cmp	r0, #0
    c8c6:	f000 8095 	beq.w	c9f4 <xQueueGenericReceive+0x138>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    c8ca:	2900      	cmp	r1, #0
    c8cc:	f000 8152 	beq.w	cb74 <xQueueGenericReceive+0x2b8>
    c8d0:	4604      	mov	r4, r0
    c8d2:	461f      	mov	r7, r3
    c8d4:	460e      	mov	r6, r1
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    c8d6:	f000 ff9f 	bl	d818 <xTaskGetSchedulerState>
    c8da:	b918      	cbnz	r0, c8e4 <xQueueGenericReceive+0x28>
    c8dc:	9b03      	ldr	r3, [sp, #12]
    c8de:	2b00      	cmp	r3, #0
    c8e0:	f040 8089 	bne.w	c9f6 <xQueueGenericReceive+0x13a>
		taskENTER_CRITICAL();
    c8e4:	f001 faf6 	bl	ded4 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    c8e8:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    c8ea:	2d00      	cmp	r5, #0
    c8ec:	f040 80cb 	bne.w	ca86 <xQueueGenericReceive+0x1ca>
				if( xTicksToWait == ( TickType_t ) 0 )
    c8f0:	9b03      	ldr	r3, [sp, #12]
    c8f2:	2b00      	cmp	r3, #0
    c8f4:	d06a      	beq.n	c9cc <xQueueGenericReceive+0x110>
					vTaskSetTimeOutState( &xTimeOut );
    c8f6:	a804      	add	r0, sp, #16
    c8f8:	f000 ff30 	bl	d75c <vTaskSetTimeOutState>
					portYIELD_WITHIN_API();
    c8fc:	f8df b2f4 	ldr.w	fp, [pc, #756]	; cbf4 <xQueueGenericReceive+0x338>
		prvLockQueue( pxQueue );
    c900:	46aa      	mov	sl, r5
    c902:	f104 0824 	add.w	r8, r4, #36	; 0x24
		taskEXIT_CRITICAL();
    c906:	f001 faff 	bl	df08 <vPortExitCritical>
		vTaskSuspendAll();
    c90a:	f000 fc0f 	bl	d12c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    c90e:	f001 fae1 	bl	ded4 <vPortEnterCritical>
    c912:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    c916:	2bff      	cmp	r3, #255	; 0xff
    c918:	bf08      	it	eq
    c91a:	f884 a044 	strbeq.w	sl, [r4, #68]	; 0x44
    c91e:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    c922:	2bff      	cmp	r3, #255	; 0xff
    c924:	bf08      	it	eq
    c926:	f884 a045 	strbeq.w	sl, [r4, #69]	; 0x45
    c92a:	f001 faed 	bl	df08 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    c92e:	a903      	add	r1, sp, #12
    c930:	a804      	add	r0, sp, #16
    c932:	f000 ff21 	bl	d778 <xTaskCheckForTimeOut>
    c936:	2800      	cmp	r0, #0
    c938:	d15e      	bne.n	c9f8 <xQueueGenericReceive+0x13c>
	taskENTER_CRITICAL();
    c93a:	f001 facb 	bl	ded4 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    c93e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    c940:	2b00      	cmp	r3, #0
    c942:	f000 80cc 	beq.w	cade <xQueueGenericReceive+0x222>
	taskEXIT_CRITICAL();
    c946:	f001 fadf 	bl	df08 <vPortExitCritical>
	taskENTER_CRITICAL();
    c94a:	f001 fac3 	bl	ded4 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
    c94e:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
    c952:	b26d      	sxtb	r5, r5
		while( cTxLock > queueLOCKED_UNMODIFIED )
    c954:	2d00      	cmp	r5, #0
    c956:	dc0a      	bgt.n	c96e <xQueueGenericReceive+0xb2>
    c958:	e00c      	b.n	c974 <xQueueGenericReceive+0xb8>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    c95a:	4640      	mov	r0, r8
    c95c:	f000 feae 	bl	d6bc <xTaskRemoveFromEventList>
    c960:	b108      	cbz	r0, c966 <xQueueGenericReceive+0xaa>
						vTaskMissedYield();
    c962:	f000 ff39 	bl	d7d8 <vTaskMissedYield>
    c966:	3d01      	subs	r5, #1
    c968:	b2eb      	uxtb	r3, r5
    c96a:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    c96c:	b113      	cbz	r3, c974 <xQueueGenericReceive+0xb8>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    c96e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c970:	2b00      	cmp	r3, #0
    c972:	d1f2      	bne.n	c95a <xQueueGenericReceive+0x9e>
		pxQueue->cTxLock = queueUNLOCKED;
    c974:	23ff      	movs	r3, #255	; 0xff
    c976:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
    c97a:	f001 fac5 	bl	df08 <vPortExitCritical>
	taskENTER_CRITICAL();
    c97e:	f001 faa9 	bl	ded4 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
    c982:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
    c986:	b26d      	sxtb	r5, r5
		while( cRxLock > queueLOCKED_UNMODIFIED )
    c988:	2d00      	cmp	r5, #0
    c98a:	dd10      	ble.n	c9ae <xQueueGenericReceive+0xf2>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    c98c:	6923      	ldr	r3, [r4, #16]
    c98e:	b173      	cbz	r3, c9ae <xQueueGenericReceive+0xf2>
    c990:	f104 0910 	add.w	r9, r4, #16
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    c994:	4648      	mov	r0, r9
    c996:	f000 fe91 	bl	d6bc <xTaskRemoveFromEventList>
    c99a:	b108      	cbz	r0, c9a0 <xQueueGenericReceive+0xe4>
					vTaskMissedYield();
    c99c:	f000 ff1c 	bl	d7d8 <vTaskMissedYield>
    c9a0:	3d01      	subs	r5, #1
    c9a2:	b2eb      	uxtb	r3, r5
    c9a4:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    c9a6:	b113      	cbz	r3, c9ae <xQueueGenericReceive+0xf2>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    c9a8:	6923      	ldr	r3, [r4, #16]
    c9aa:	2b00      	cmp	r3, #0
    c9ac:	d1f2      	bne.n	c994 <xQueueGenericReceive+0xd8>
		pxQueue->cRxLock = queueUNLOCKED;
    c9ae:	23ff      	movs	r3, #255	; 0xff
    c9b0:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
    c9b4:	f001 faa8 	bl	df08 <vPortExitCritical>
				( void ) xTaskResumeAll();
    c9b8:	f000 fc80 	bl	d2bc <xTaskResumeAll>
		taskENTER_CRITICAL();
    c9bc:	f001 fa8a 	bl	ded4 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    c9c0:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    c9c2:	2d00      	cmp	r5, #0
    c9c4:	d15f      	bne.n	ca86 <xQueueGenericReceive+0x1ca>
				if( xTicksToWait == ( TickType_t ) 0 )
    c9c6:	9b03      	ldr	r3, [sp, #12]
    c9c8:	2b00      	cmp	r3, #0
    c9ca:	d19c      	bne.n	c906 <xQueueGenericReceive+0x4a>
					taskEXIT_CRITICAL();
    c9cc:	f001 fa9c 	bl	df08 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
    c9d0:	4620      	mov	r0, r4
    c9d2:	f003 faa7 	bl	ff24 <SEGGER_SYSVIEW_ShrinkId>
    c9d6:	4604      	mov	r4, r0
    c9d8:	4630      	mov	r0, r6
    c9da:	f003 faa3 	bl	ff24 <SEGGER_SYSVIEW_ShrinkId>
    c9de:	9b03      	ldr	r3, [sp, #12]
    c9e0:	9700      	str	r7, [sp, #0]
    c9e2:	4602      	mov	r2, r0
    c9e4:	4621      	mov	r1, r4
    c9e6:	205c      	movs	r0, #92	; 0x5c
    c9e8:	f005 fb04 	bl	11ff4 <SYSVIEW_RecordU32x4>
					return errQUEUE_EMPTY;
    c9ec:	2000      	movs	r0, #0
}
    c9ee:	b007      	add	sp, #28
    c9f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c9f4:	e7fe      	b.n	c9f4 <xQueueGenericReceive+0x138>
    c9f6:	e7fe      	b.n	c9f6 <xQueueGenericReceive+0x13a>
	taskENTER_CRITICAL();
    c9f8:	f001 fa6c 	bl	ded4 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
    c9fc:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
    ca00:	b26d      	sxtb	r5, r5
		while( cTxLock > queueLOCKED_UNMODIFIED )
    ca02:	2d00      	cmp	r5, #0
    ca04:	dc0a      	bgt.n	ca1c <xQueueGenericReceive+0x160>
    ca06:	e00c      	b.n	ca22 <xQueueGenericReceive+0x166>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    ca08:	4640      	mov	r0, r8
    ca0a:	f000 fe57 	bl	d6bc <xTaskRemoveFromEventList>
    ca0e:	b108      	cbz	r0, ca14 <xQueueGenericReceive+0x158>
						vTaskMissedYield();
    ca10:	f000 fee2 	bl	d7d8 <vTaskMissedYield>
    ca14:	3d01      	subs	r5, #1
    ca16:	b2eb      	uxtb	r3, r5
    ca18:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    ca1a:	b113      	cbz	r3, ca22 <xQueueGenericReceive+0x166>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    ca1c:	6a63      	ldr	r3, [r4, #36]	; 0x24
    ca1e:	2b00      	cmp	r3, #0
    ca20:	d1f2      	bne.n	ca08 <xQueueGenericReceive+0x14c>
		pxQueue->cTxLock = queueUNLOCKED;
    ca22:	23ff      	movs	r3, #255	; 0xff
    ca24:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
    ca28:	f001 fa6e 	bl	df08 <vPortExitCritical>
	taskENTER_CRITICAL();
    ca2c:	f001 fa52 	bl	ded4 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
    ca30:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
    ca34:	b26d      	sxtb	r5, r5
		while( cRxLock > queueLOCKED_UNMODIFIED )
    ca36:	2d00      	cmp	r5, #0
    ca38:	dd11      	ble.n	ca5e <xQueueGenericReceive+0x1a2>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    ca3a:	6923      	ldr	r3, [r4, #16]
    ca3c:	b17b      	cbz	r3, ca5e <xQueueGenericReceive+0x1a2>
    ca3e:	f104 0910 	add.w	r9, r4, #16
    ca42:	e001      	b.n	ca48 <xQueueGenericReceive+0x18c>
    ca44:	6923      	ldr	r3, [r4, #16]
    ca46:	b153      	cbz	r3, ca5e <xQueueGenericReceive+0x1a2>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    ca48:	4648      	mov	r0, r9
    ca4a:	f000 fe37 	bl	d6bc <xTaskRemoveFromEventList>
    ca4e:	b108      	cbz	r0, ca54 <xQueueGenericReceive+0x198>
					vTaskMissedYield();
    ca50:	f000 fec2 	bl	d7d8 <vTaskMissedYield>
    ca54:	3d01      	subs	r5, #1
    ca56:	b2eb      	uxtb	r3, r5
    ca58:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    ca5a:	2b00      	cmp	r3, #0
    ca5c:	d1f2      	bne.n	ca44 <xQueueGenericReceive+0x188>
		pxQueue->cRxLock = queueUNLOCKED;
    ca5e:	23ff      	movs	r3, #255	; 0xff
    ca60:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
    ca64:	f001 fa50 	bl	df08 <vPortExitCritical>
			( void ) xTaskResumeAll();
    ca68:	f000 fc28 	bl	d2bc <xTaskResumeAll>
	taskENTER_CRITICAL();
    ca6c:	f001 fa32 	bl	ded4 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    ca70:	6ba5      	ldr	r5, [r4, #56]	; 0x38
    ca72:	2d00      	cmp	r5, #0
    ca74:	f000 8083 	beq.w	cb7e <xQueueGenericReceive+0x2c2>
	taskEXIT_CRITICAL();
    ca78:	f001 fa46 	bl	df08 <vPortExitCritical>
		taskENTER_CRITICAL();
    ca7c:	f001 fa2a 	bl	ded4 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    ca80:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    ca82:	2d00      	cmp	r5, #0
    ca84:	d09f      	beq.n	c9c6 <xQueueGenericReceive+0x10a>
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    ca86:	6c22      	ldr	r2, [r4, #64]	; 0x40
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    ca88:	f8d4 800c 	ldr.w	r8, [r4, #12]
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    ca8c:	b15a      	cbz	r2, caa6 <xQueueGenericReceive+0x1ea>
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    ca8e:	6861      	ldr	r1, [r4, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    ca90:	eb08 0302 	add.w	r3, r8, r2
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    ca94:	428b      	cmp	r3, r1
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    ca96:	60e3      	str	r3, [r4, #12]
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    ca98:	bf24      	itt	cs
    ca9a:	6823      	ldrcs	r3, [r4, #0]
    ca9c:	60e3      	strcs	r3, [r4, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    ca9e:	68e1      	ldr	r1, [r4, #12]
    caa0:	4630      	mov	r0, r6
    caa2:	f7ff fb2d 	bl	c100 <memcpy>
					traceQUEUE_RECEIVE( pxQueue );
    caa6:	4620      	mov	r0, r4
				if( xJustPeeking == pdFALSE )
    caa8:	2f00      	cmp	r7, #0
    caaa:	d17a      	bne.n	cba2 <xQueueGenericReceive+0x2e6>
					traceQUEUE_RECEIVE( pxQueue );
    caac:	f003 fa3a 	bl	ff24 <SEGGER_SYSVIEW_ShrinkId>
    cab0:	4680      	mov	r8, r0
    cab2:	4630      	mov	r0, r6
    cab4:	f003 fa36 	bl	ff24 <SEGGER_SYSVIEW_ShrinkId>
    cab8:	9b03      	ldr	r3, [sp, #12]
    caba:	9700      	str	r7, [sp, #0]
    cabc:	4602      	mov	r2, r0
    cabe:	4641      	mov	r1, r8
    cac0:	205c      	movs	r0, #92	; 0x5c
    cac2:	f005 fa97 	bl	11ff4 <SYSVIEW_RecordU32x4>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    cac6:	6923      	ldr	r3, [r4, #16]
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    cac8:	3d01      	subs	r5, #1
    caca:	63a5      	str	r5, [r4, #56]	; 0x38
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    cacc:	2b00      	cmp	r3, #0
    cace:	f040 808a 	bne.w	cbe6 <xQueueGenericReceive+0x32a>
				taskEXIT_CRITICAL();
    cad2:	f001 fa19 	bl	df08 <vPortExitCritical>
				return pdPASS;
    cad6:	2001      	movs	r0, #1
}
    cad8:	b007      	add	sp, #28
    cada:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	taskEXIT_CRITICAL();
    cade:	f001 fa13 	bl	df08 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    cae2:	9903      	ldr	r1, [sp, #12]
    cae4:	4640      	mov	r0, r8
    cae6:	f000 fd4f 	bl	d588 <vTaskPlaceOnEventList>
	taskENTER_CRITICAL();
    caea:	f001 f9f3 	bl	ded4 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
    caee:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
    caf2:	b26d      	sxtb	r5, r5
		while( cTxLock > queueLOCKED_UNMODIFIED )
    caf4:	2d00      	cmp	r5, #0
    caf6:	dc0a      	bgt.n	cb0e <xQueueGenericReceive+0x252>
    caf8:	e00c      	b.n	cb14 <xQueueGenericReceive+0x258>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    cafa:	4640      	mov	r0, r8
    cafc:	f000 fdde 	bl	d6bc <xTaskRemoveFromEventList>
    cb00:	b108      	cbz	r0, cb06 <xQueueGenericReceive+0x24a>
						vTaskMissedYield();
    cb02:	f000 fe69 	bl	d7d8 <vTaskMissedYield>
    cb06:	3d01      	subs	r5, #1
    cb08:	b2eb      	uxtb	r3, r5
    cb0a:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    cb0c:	b113      	cbz	r3, cb14 <xQueueGenericReceive+0x258>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    cb0e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    cb10:	2b00      	cmp	r3, #0
    cb12:	d1f2      	bne.n	cafa <xQueueGenericReceive+0x23e>
		pxQueue->cTxLock = queueUNLOCKED;
    cb14:	23ff      	movs	r3, #255	; 0xff
    cb16:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
    cb1a:	f001 f9f5 	bl	df08 <vPortExitCritical>
	taskENTER_CRITICAL();
    cb1e:	f001 f9d9 	bl	ded4 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
    cb22:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
    cb26:	b26d      	sxtb	r5, r5
		while( cRxLock > queueLOCKED_UNMODIFIED )
    cb28:	2d00      	cmp	r5, #0
    cb2a:	dd10      	ble.n	cb4e <xQueueGenericReceive+0x292>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    cb2c:	6923      	ldr	r3, [r4, #16]
    cb2e:	b173      	cbz	r3, cb4e <xQueueGenericReceive+0x292>
    cb30:	f104 0910 	add.w	r9, r4, #16
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    cb34:	4648      	mov	r0, r9
    cb36:	f000 fdc1 	bl	d6bc <xTaskRemoveFromEventList>
    cb3a:	b108      	cbz	r0, cb40 <xQueueGenericReceive+0x284>
					vTaskMissedYield();
    cb3c:	f000 fe4c 	bl	d7d8 <vTaskMissedYield>
    cb40:	3d01      	subs	r5, #1
    cb42:	b2eb      	uxtb	r3, r5
    cb44:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    cb46:	b113      	cbz	r3, cb4e <xQueueGenericReceive+0x292>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    cb48:	6923      	ldr	r3, [r4, #16]
    cb4a:	2b00      	cmp	r3, #0
    cb4c:	d1f2      	bne.n	cb34 <xQueueGenericReceive+0x278>
		pxQueue->cRxLock = queueUNLOCKED;
    cb4e:	23ff      	movs	r3, #255	; 0xff
    cb50:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
    cb54:	f001 f9d8 	bl	df08 <vPortExitCritical>
				if( xTaskResumeAll() == pdFALSE )
    cb58:	f000 fbb0 	bl	d2bc <xTaskResumeAll>
    cb5c:	2800      	cmp	r0, #0
    cb5e:	f47f af2d 	bne.w	c9bc <xQueueGenericReceive+0x100>
					portYIELD_WITHIN_API();
    cb62:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    cb66:	f8cb 3000 	str.w	r3, [fp]
    cb6a:	f3bf 8f4f 	dsb	sy
    cb6e:	f3bf 8f6f 	isb	sy
    cb72:	e723      	b.n	c9bc <xQueueGenericReceive+0x100>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    cb74:	6c02      	ldr	r2, [r0, #64]	; 0x40
    cb76:	2a00      	cmp	r2, #0
    cb78:	f43f aeaa 	beq.w	c8d0 <xQueueGenericReceive+0x14>
    cb7c:	e7fe      	b.n	cb7c <xQueueGenericReceive+0x2c0>
	taskEXIT_CRITICAL();
    cb7e:	f001 f9c3 	bl	df08 <vPortExitCritical>
				traceQUEUE_RECEIVE_FAILED( pxQueue );
    cb82:	4620      	mov	r0, r4
    cb84:	f003 f9ce 	bl	ff24 <SEGGER_SYSVIEW_ShrinkId>
    cb88:	4604      	mov	r4, r0
    cb8a:	4630      	mov	r0, r6
    cb8c:	f003 f9ca 	bl	ff24 <SEGGER_SYSVIEW_ShrinkId>
    cb90:	4621      	mov	r1, r4
    cb92:	4602      	mov	r2, r0
    cb94:	9700      	str	r7, [sp, #0]
    cb96:	205c      	movs	r0, #92	; 0x5c
    cb98:	9b03      	ldr	r3, [sp, #12]
    cb9a:	f005 fa2b 	bl	11ff4 <SYSVIEW_RecordU32x4>
				return errQUEUE_EMPTY;
    cb9e:	4628      	mov	r0, r5
    cba0:	e725      	b.n	c9ee <xQueueGenericReceive+0x132>
					traceQUEUE_PEEK( pxQueue );
    cba2:	f003 f9bf 	bl	ff24 <SEGGER_SYSVIEW_ShrinkId>
    cba6:	4605      	mov	r5, r0
    cba8:	4630      	mov	r0, r6
    cbaa:	f003 f9bb 	bl	ff24 <SEGGER_SYSVIEW_ShrinkId>
    cbae:	9b03      	ldr	r3, [sp, #12]
    cbb0:	9700      	str	r7, [sp, #0]
    cbb2:	4602      	mov	r2, r0
    cbb4:	4629      	mov	r1, r5
    cbb6:	205c      	movs	r0, #92	; 0x5c
    cbb8:	f005 fa1c 	bl	11ff4 <SYSVIEW_RecordU32x4>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    cbbc:	6a63      	ldr	r3, [r4, #36]	; 0x24
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    cbbe:	f8c4 800c 	str.w	r8, [r4, #12]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    cbc2:	2b00      	cmp	r3, #0
    cbc4:	d085      	beq.n	cad2 <xQueueGenericReceive+0x216>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    cbc6:	f104 0024 	add.w	r0, r4, #36	; 0x24
    cbca:	f000 fd77 	bl	d6bc <xTaskRemoveFromEventList>
    cbce:	2800      	cmp	r0, #0
    cbd0:	f43f af7f 	beq.w	cad2 <xQueueGenericReceive+0x216>
							queueYIELD_IF_USING_PREEMPTION();
    cbd4:	4b07      	ldr	r3, [pc, #28]	; (cbf4 <xQueueGenericReceive+0x338>)
    cbd6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    cbda:	601a      	str	r2, [r3, #0]
    cbdc:	f3bf 8f4f 	dsb	sy
    cbe0:	f3bf 8f6f 	isb	sy
    cbe4:	e775      	b.n	cad2 <xQueueGenericReceive+0x216>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    cbe6:	f104 0010 	add.w	r0, r4, #16
    cbea:	f000 fd67 	bl	d6bc <xTaskRemoveFromEventList>
    cbee:	2800      	cmp	r0, #0
    cbf0:	d1f0      	bne.n	cbd4 <xQueueGenericReceive+0x318>
    cbf2:	e76e      	b.n	cad2 <xQueueGenericReceive+0x216>
    cbf4:	e000ed04 	.word	0xe000ed04

0000cbf8 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    cbf8:	b570      	push	{r4, r5, r6, lr}
    cbfa:	4605      	mov	r5, r0
    cbfc:	460c      	mov	r4, r1
    cbfe:	4616      	mov	r6, r2
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    cc00:	f001 f968 	bl	ded4 <vPortEnterCritical>
    cc04:	f895 3044 	ldrb.w	r3, [r5, #68]	; 0x44
    cc08:	2bff      	cmp	r3, #255	; 0xff
    cc0a:	bf04      	itt	eq
    cc0c:	2300      	moveq	r3, #0
    cc0e:	f885 3044 	strbeq.w	r3, [r5, #68]	; 0x44
    cc12:	f895 3045 	ldrb.w	r3, [r5, #69]	; 0x45
    cc16:	2bff      	cmp	r3, #255	; 0xff
    cc18:	bf04      	itt	eq
    cc1a:	2300      	moveq	r3, #0
    cc1c:	f885 3045 	strbeq.w	r3, [r5, #69]	; 0x45
    cc20:	f001 f972 	bl	df08 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    cc24:	6bab      	ldr	r3, [r5, #56]	; 0x38
    cc26:	b92b      	cbnz	r3, cc34 <vQueueWaitForMessageRestricted+0x3c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    cc28:	4632      	mov	r2, r6
    cc2a:	4621      	mov	r1, r4
    cc2c:	f105 0024 	add.w	r0, r5, #36	; 0x24
    cc30:	f000 fcf2 	bl	d618 <vTaskPlaceOnEventListRestricted>
	taskENTER_CRITICAL();
    cc34:	f001 f94e 	bl	ded4 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
    cc38:	f895 4045 	ldrb.w	r4, [r5, #69]	; 0x45
    cc3c:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
    cc3e:	2c00      	cmp	r4, #0
    cc40:	dd16      	ble.n	cc70 <vQueueWaitForMessageRestricted+0x78>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    cc42:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    cc44:	b1a3      	cbz	r3, cc70 <vQueueWaitForMessageRestricted+0x78>
    cc46:	f105 0624 	add.w	r6, r5, #36	; 0x24
    cc4a:	e005      	b.n	cc58 <vQueueWaitForMessageRestricted+0x60>
    cc4c:	3c01      	subs	r4, #1
    cc4e:	b2e3      	uxtb	r3, r4
    cc50:	b25c      	sxtb	r4, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    cc52:	b16b      	cbz	r3, cc70 <vQueueWaitForMessageRestricted+0x78>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    cc54:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    cc56:	b15b      	cbz	r3, cc70 <vQueueWaitForMessageRestricted+0x78>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    cc58:	4630      	mov	r0, r6
    cc5a:	f000 fd2f 	bl	d6bc <xTaskRemoveFromEventList>
    cc5e:	2800      	cmp	r0, #0
    cc60:	d0f4      	beq.n	cc4c <vQueueWaitForMessageRestricted+0x54>
    cc62:	3c01      	subs	r4, #1
						vTaskMissedYield();
    cc64:	f000 fdb8 	bl	d7d8 <vTaskMissedYield>
    cc68:	b2e3      	uxtb	r3, r4
    cc6a:	b25c      	sxtb	r4, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    cc6c:	2b00      	cmp	r3, #0
    cc6e:	d1f1      	bne.n	cc54 <vQueueWaitForMessageRestricted+0x5c>
		pxQueue->cTxLock = queueUNLOCKED;
    cc70:	23ff      	movs	r3, #255	; 0xff
    cc72:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
	taskEXIT_CRITICAL();
    cc76:	f001 f947 	bl	df08 <vPortExitCritical>
	taskENTER_CRITICAL();
    cc7a:	f001 f92b 	bl	ded4 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
    cc7e:	f895 4044 	ldrb.w	r4, [r5, #68]	; 0x44
    cc82:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
    cc84:	2c00      	cmp	r4, #0
    cc86:	dd16      	ble.n	ccb6 <vQueueWaitForMessageRestricted+0xbe>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    cc88:	692b      	ldr	r3, [r5, #16]
    cc8a:	b1a3      	cbz	r3, ccb6 <vQueueWaitForMessageRestricted+0xbe>
    cc8c:	f105 0610 	add.w	r6, r5, #16
    cc90:	e005      	b.n	cc9e <vQueueWaitForMessageRestricted+0xa6>
    cc92:	3c01      	subs	r4, #1
    cc94:	b2e3      	uxtb	r3, r4
    cc96:	b25c      	sxtb	r4, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    cc98:	b16b      	cbz	r3, ccb6 <vQueueWaitForMessageRestricted+0xbe>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    cc9a:	692b      	ldr	r3, [r5, #16]
    cc9c:	b15b      	cbz	r3, ccb6 <vQueueWaitForMessageRestricted+0xbe>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    cc9e:	4630      	mov	r0, r6
    cca0:	f000 fd0c 	bl	d6bc <xTaskRemoveFromEventList>
    cca4:	2800      	cmp	r0, #0
    cca6:	d0f4      	beq.n	cc92 <vQueueWaitForMessageRestricted+0x9a>
    cca8:	3c01      	subs	r4, #1
					vTaskMissedYield();
    ccaa:	f000 fd95 	bl	d7d8 <vTaskMissedYield>
    ccae:	b2e3      	uxtb	r3, r4
    ccb0:	b25c      	sxtb	r4, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    ccb2:	2b00      	cmp	r3, #0
    ccb4:	d1f1      	bne.n	cc9a <vQueueWaitForMessageRestricted+0xa2>
		pxQueue->cRxLock = queueUNLOCKED;
    ccb6:	23ff      	movs	r3, #255	; 0xff
    ccb8:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
	}
    ccbc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	taskEXIT_CRITICAL();
    ccc0:	f001 b922 	b.w	df08 <vPortExitCritical>

0000ccc4 <prvResetNextTaskUnblockTime.part.2>:
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    ccc4:	4a03      	ldr	r2, [pc, #12]	; (ccd4 <prvResetNextTaskUnblockTime.part.2+0x10>)
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    ccc6:	4b04      	ldr	r3, [pc, #16]	; (ccd8 <prvResetNextTaskUnblockTime.part.2+0x14>)
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    ccc8:	6812      	ldr	r2, [r2, #0]
    ccca:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    cccc:	68d2      	ldr	r2, [r2, #12]
    ccce:	6852      	ldr	r2, [r2, #4]
    ccd0:	601a      	str	r2, [r3, #0]
	}
}
    ccd2:	4770      	bx	lr
    ccd4:	10002b94 	.word	0x10002b94
    ccd8:	10002c68 	.word	0x10002c68

0000ccdc <xTaskCreate>:
	{
    ccdc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    cce0:	0096      	lsls	r6, r2, #2
	{
    cce2:	b083      	sub	sp, #12
    cce4:	4680      	mov	r8, r0
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    cce6:	4630      	mov	r0, r6
	{
    cce8:	460d      	mov	r5, r1
    ccea:	4699      	mov	r9, r3
    ccec:	9f0d      	ldr	r7, [sp, #52]	; 0x34
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    ccee:	f000 fff5 	bl	dcdc <pvPortMalloc>
			if( pxStack != NULL )
    ccf2:	2800      	cmp	r0, #0
    ccf4:	f000 810b 	beq.w	cf0e <xTaskCreate+0x232>
    ccf8:	4682      	mov	sl, r0
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    ccfa:	204c      	movs	r0, #76	; 0x4c
    ccfc:	f000 ffee 	bl	dcdc <pvPortMalloc>
				if( pxNewTCB != NULL )
    cd00:	4604      	mov	r4, r0
    cd02:	2800      	cmp	r0, #0
    cd04:	f000 80da 	beq.w	cebc <xTaskCreate+0x1e0>
					pxNewTCB->pxStack = pxStack;
    cd08:	f8c0 a030 	str.w	sl, [r0, #48]	; 0x30
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
    cd0c:	4632      	mov	r2, r6
    cd0e:	4650      	mov	r0, sl
    cd10:	21a5      	movs	r1, #165	; 0xa5
    cd12:	f006 fbc5 	bl	134a0 <memset>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cd16:	782a      	ldrb	r2, [r5, #0]
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    cd18:	6b23      	ldr	r3, [r4, #48]	; 0x30
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cd1a:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    cd1e:	3e04      	subs	r6, #4
		if( pcName[ x ] == 0x00 )
    cd20:	782a      	ldrb	r2, [r5, #0]
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    cd22:	441e      	add	r6, r3
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
    cd24:	f026 0a07 	bic.w	sl, r6, #7
		if( pcName[ x ] == 0x00 )
    cd28:	2a00      	cmp	r2, #0
    cd2a:	d04d      	beq.n	cdc8 <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cd2c:	786b      	ldrb	r3, [r5, #1]
    cd2e:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
		if( pcName[ x ] == 0x00 )
    cd32:	786b      	ldrb	r3, [r5, #1]
    cd34:	2b00      	cmp	r3, #0
    cd36:	d047      	beq.n	cdc8 <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cd38:	78ab      	ldrb	r3, [r5, #2]
    cd3a:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
		if( pcName[ x ] == 0x00 )
    cd3e:	78ab      	ldrb	r3, [r5, #2]
    cd40:	2b00      	cmp	r3, #0
    cd42:	d041      	beq.n	cdc8 <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cd44:	78eb      	ldrb	r3, [r5, #3]
    cd46:	f884 3037 	strb.w	r3, [r4, #55]	; 0x37
		if( pcName[ x ] == 0x00 )
    cd4a:	78eb      	ldrb	r3, [r5, #3]
    cd4c:	2b00      	cmp	r3, #0
    cd4e:	d03b      	beq.n	cdc8 <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cd50:	792b      	ldrb	r3, [r5, #4]
    cd52:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
		if( pcName[ x ] == 0x00 )
    cd56:	792b      	ldrb	r3, [r5, #4]
    cd58:	2b00      	cmp	r3, #0
    cd5a:	d035      	beq.n	cdc8 <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cd5c:	796b      	ldrb	r3, [r5, #5]
    cd5e:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
		if( pcName[ x ] == 0x00 )
    cd62:	796b      	ldrb	r3, [r5, #5]
    cd64:	2b00      	cmp	r3, #0
    cd66:	d02f      	beq.n	cdc8 <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cd68:	79ab      	ldrb	r3, [r5, #6]
    cd6a:	f884 303a 	strb.w	r3, [r4, #58]	; 0x3a
		if( pcName[ x ] == 0x00 )
    cd6e:	79ab      	ldrb	r3, [r5, #6]
    cd70:	b353      	cbz	r3, cdc8 <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cd72:	79eb      	ldrb	r3, [r5, #7]
    cd74:	f884 303b 	strb.w	r3, [r4, #59]	; 0x3b
		if( pcName[ x ] == 0x00 )
    cd78:	79eb      	ldrb	r3, [r5, #7]
    cd7a:	b32b      	cbz	r3, cdc8 <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cd7c:	7a2b      	ldrb	r3, [r5, #8]
    cd7e:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
		if( pcName[ x ] == 0x00 )
    cd82:	7a2b      	ldrb	r3, [r5, #8]
    cd84:	b303      	cbz	r3, cdc8 <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cd86:	7a6b      	ldrb	r3, [r5, #9]
    cd88:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
		if( pcName[ x ] == 0x00 )
    cd8c:	7a6b      	ldrb	r3, [r5, #9]
    cd8e:	b1db      	cbz	r3, cdc8 <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cd90:	7aab      	ldrb	r3, [r5, #10]
    cd92:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
		if( pcName[ x ] == 0x00 )
    cd96:	7aab      	ldrb	r3, [r5, #10]
    cd98:	b1b3      	cbz	r3, cdc8 <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cd9a:	7aeb      	ldrb	r3, [r5, #11]
    cd9c:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
		if( pcName[ x ] == 0x00 )
    cda0:	7aeb      	ldrb	r3, [r5, #11]
    cda2:	b18b      	cbz	r3, cdc8 <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cda4:	7b2b      	ldrb	r3, [r5, #12]
    cda6:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
		if( pcName[ x ] == 0x00 )
    cdaa:	7b2b      	ldrb	r3, [r5, #12]
    cdac:	b163      	cbz	r3, cdc8 <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cdae:	7b6b      	ldrb	r3, [r5, #13]
    cdb0:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
		if( pcName[ x ] == 0x00 )
    cdb4:	7b6b      	ldrb	r3, [r5, #13]
    cdb6:	b13b      	cbz	r3, cdc8 <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cdb8:	7bab      	ldrb	r3, [r5, #14]
    cdba:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
		if( pcName[ x ] == 0x00 )
    cdbe:	7bab      	ldrb	r3, [r5, #14]
    cdc0:	b113      	cbz	r3, cdc8 <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cdc2:	7beb      	ldrb	r3, [r5, #15]
    cdc4:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    cdc8:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    cdca:	2d06      	cmp	r5, #6
    cdcc:	bf28      	it	cs
    cdce:	2506      	movcs	r5, #6
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    cdd0:	f04f 0b00 	mov.w	fp, #0
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    cdd4:	1d26      	adds	r6, r4, #4
	pxNewTCB->uxPriority = uxPriority;
    cdd6:	62e5      	str	r5, [r4, #44]	; 0x2c
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    cdd8:	4630      	mov	r0, r6
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    cdda:	f884 b043 	strb.w	fp, [r4, #67]	; 0x43
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    cdde:	f7ff faa7 	bl	c330 <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    cde2:	f1c5 0507 	rsb	r5, r5, #7
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    cde6:	f104 0018 	add.w	r0, r4, #24
    cdea:	f7ff faa1 	bl	c330 <vListInitialiseItem>
		pxNewTCB->ulNotifiedValue = 0;
    cdee:	f8c4 b044 	str.w	fp, [r4, #68]	; 0x44
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    cdf2:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    cdf4:	6124      	str	r4, [r4, #16]
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    cdf6:	f884 b048 	strb.w	fp, [r4, #72]	; 0x48
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    cdfa:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    cdfc:	464a      	mov	r2, r9
    cdfe:	4641      	mov	r1, r8
    ce00:	4650      	mov	r0, sl
    ce02:	f001 f83d 	bl	de80 <pxPortInitialiseStack>
    ce06:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
    ce08:	b107      	cbz	r7, ce0c <xTaskCreate+0x130>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    ce0a:	603c      	str	r4, [r7, #0]
	taskENTER_CRITICAL();
    ce0c:	f001 f862 	bl	ded4 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
    ce10:	4a40      	ldr	r2, [pc, #256]	; (cf14 <xTaskCreate+0x238>)
		if( pxCurrentTCB == NULL )
    ce12:	4d41      	ldr	r5, [pc, #260]	; (cf18 <xTaskCreate+0x23c>)
		uxCurrentNumberOfTasks++;
    ce14:	6813      	ldr	r3, [r2, #0]
    ce16:	3301      	adds	r3, #1
    ce18:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
    ce1a:	682b      	ldr	r3, [r5, #0]
    ce1c:	2b00      	cmp	r3, #0
    ce1e:	d045      	beq.n	ceac <xTaskCreate+0x1d0>
			if( xSchedulerRunning == pdFALSE )
    ce20:	4f3e      	ldr	r7, [pc, #248]	; (cf1c <xTaskCreate+0x240>)
    ce22:	683b      	ldr	r3, [r7, #0]
    ce24:	2b00      	cmp	r3, #0
    ce26:	d034      	beq.n	ce92 <xTaskCreate+0x1b6>
    ce28:	f8df 8110 	ldr.w	r8, [pc, #272]	; cf3c <xTaskCreate+0x260>
		uxTaskNumber++;
    ce2c:	4a3c      	ldr	r2, [pc, #240]	; (cf20 <xTaskCreate+0x244>)
    ce2e:	6813      	ldr	r3, [r2, #0]
		traceTASK_CREATE( pxNewTCB );
    ce30:	4620      	mov	r0, r4
		uxTaskNumber++;
    ce32:	3301      	adds	r3, #1
    ce34:	6013      	str	r3, [r2, #0]
		traceTASK_CREATE( pxNewTCB );
    ce36:	f003 fec9 	bl	10bcc <SEGGER_SYSVIEW_OnTaskCreate>
    ce3a:	6b23      	ldr	r3, [r4, #48]	; 0x30
    ce3c:	6821      	ldr	r1, [r4, #0]
    ce3e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    ce40:	1ac9      	subs	r1, r1, r3
    ce42:	9100      	str	r1, [sp, #0]
    ce44:	4620      	mov	r0, r4
    ce46:	f104 0134 	add.w	r1, r4, #52	; 0x34
    ce4a:	f005 f89b 	bl	11f84 <SYSVIEW_AddTask>
		prvReaddTaskToReadyList( pxNewTCB );
    ce4e:	4b35      	ldr	r3, [pc, #212]	; (cf24 <xTaskCreate+0x248>)
    ce50:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    ce52:	681a      	ldr	r2, [r3, #0]
    ce54:	4290      	cmp	r0, r2
    ce56:	bf88      	it	hi
    ce58:	6018      	strhi	r0, [r3, #0]
    ce5a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    ce5e:	eb08 0080 	add.w	r0, r8, r0, lsl #2
    ce62:	4631      	mov	r1, r6
    ce64:	f7ff fa68 	bl	c338 <vListInsertEnd>
	taskEXIT_CRITICAL();
    ce68:	f001 f84e 	bl	df08 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
    ce6c:	683b      	ldr	r3, [r7, #0]
    ce6e:	b1cb      	cbz	r3, cea4 <xTaskCreate+0x1c8>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    ce70:	682a      	ldr	r2, [r5, #0]
    ce72:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    ce74:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    ce76:	429a      	cmp	r2, r3
    ce78:	d214      	bcs.n	cea4 <xTaskCreate+0x1c8>
			taskYIELD_IF_USING_PREEMPTION();    /* Set a PendSV to request a context switch. */                             \
    ce7a:	4b2b      	ldr	r3, [pc, #172]	; (cf28 <xTaskCreate+0x24c>)
    ce7c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    ce80:	601a      	str	r2, [r3, #0]
    ce82:	f3bf 8f4f 	dsb	sy
    ce86:	f3bf 8f6f 	isb	sy
			xReturn = pdPASS;
    ce8a:	2001      	movs	r0, #1
	}
    ce8c:	b003      	add	sp, #12
    ce8e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    ce92:	682a      	ldr	r2, [r5, #0]
    ce94:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    ce96:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    ce98:	f8df 80a0 	ldr.w	r8, [pc, #160]	; cf3c <xTaskCreate+0x260>
    ce9c:	429a      	cmp	r2, r3
					pxCurrentTCB = pxNewTCB;
    ce9e:	bf98      	it	ls
    cea0:	602c      	strls	r4, [r5, #0]
    cea2:	e7c3      	b.n	ce2c <xTaskCreate+0x150>
			xReturn = pdPASS;
    cea4:	2001      	movs	r0, #1
	}
    cea6:	b003      	add	sp, #12
    cea8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			pxCurrentTCB = pxNewTCB;
    ceac:	602c      	str	r4, [r5, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    ceae:	6813      	ldr	r3, [r2, #0]
    ceb0:	f8df 8088 	ldr.w	r8, [pc, #136]	; cf3c <xTaskCreate+0x260>
    ceb4:	2b01      	cmp	r3, #1
    ceb6:	d009      	beq.n	cecc <xTaskCreate+0x1f0>
    ceb8:	4f18      	ldr	r7, [pc, #96]	; (cf1c <xTaskCreate+0x240>)
    ceba:	e7b7      	b.n	ce2c <xTaskCreate+0x150>
					vPortFree( pxStack );
    cebc:	4650      	mov	r0, sl
    cebe:	f000 ff8d 	bl	dddc <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    cec2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	}
    cec6:	b003      	add	sp, #12
    cec8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cecc:	4647      	mov	r7, r8
    cece:	f108 098c 	add.w	r9, r8, #140	; 0x8c
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    ced2:	4638      	mov	r0, r7
    ced4:	3714      	adds	r7, #20
    ced6:	f7ff fa1f 	bl	c318 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    ceda:	454f      	cmp	r7, r9
    cedc:	d1f9      	bne.n	ced2 <xTaskCreate+0x1f6>
	vListInitialise( &xDelayedTaskList1 );
    cede:	f8df a060 	ldr.w	sl, [pc, #96]	; cf40 <xTaskCreate+0x264>
	vListInitialise( &xDelayedTaskList2 );
    cee2:	f8df 9060 	ldr.w	r9, [pc, #96]	; cf44 <xTaskCreate+0x268>
    cee6:	4f0d      	ldr	r7, [pc, #52]	; (cf1c <xTaskCreate+0x240>)
	vListInitialise( &xDelayedTaskList1 );
    cee8:	4650      	mov	r0, sl
    ceea:	f7ff fa15 	bl	c318 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    ceee:	4648      	mov	r0, r9
    cef0:	f7ff fa12 	bl	c318 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    cef4:	480d      	ldr	r0, [pc, #52]	; (cf2c <xTaskCreate+0x250>)
    cef6:	f7ff fa0f 	bl	c318 <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
    cefa:	480d      	ldr	r0, [pc, #52]	; (cf30 <xTaskCreate+0x254>)
    cefc:	f7ff fa0c 	bl	c318 <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
    cf00:	4a0c      	ldr	r2, [pc, #48]	; (cf34 <xTaskCreate+0x258>)
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    cf02:	4b0d      	ldr	r3, [pc, #52]	; (cf38 <xTaskCreate+0x25c>)
	pxDelayedTaskList = &xDelayedTaskList1;
    cf04:	f8c2 a000 	str.w	sl, [r2]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    cf08:	f8c3 9000 	str.w	r9, [r3]
    cf0c:	e78e      	b.n	ce2c <xTaskCreate+0x150>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    cf0e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    cf12:	e7bb      	b.n	ce8c <xTaskCreate+0x1b0>
    cf14:	10002c28 	.word	0x10002c28
    cf18:	10002b90 	.word	0x10002b90
    cf1c:	10002c84 	.word	0x10002c84
    cf20:	10002c34 	.word	0x10002c34
    cf24:	10002c38 	.word	0x10002c38
    cf28:	e000ed04 	.word	0xe000ed04
    cf2c:	10002c70 	.word	0x10002c70
    cf30:	10002c88 	.word	0x10002c88
    cf34:	10002b94 	.word	0x10002b94
    cf38:	10002b98 	.word	0x10002b98
    cf3c:	10002b9c 	.word	0x10002b9c
    cf40:	10002c3c 	.word	0x10002c3c
    cf44:	10002c50 	.word	0x10002c50

0000cf48 <vTaskStartScheduler>:
{
    cf48:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    cf4c:	f44f 6080 	mov.w	r0, #1024	; 0x400
{
    cf50:	b082      	sub	sp, #8
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    cf52:	f000 fec3 	bl	dcdc <pvPortMalloc>
			if( pxStack != NULL )
    cf56:	2800      	cmp	r0, #0
    cf58:	d076      	beq.n	d048 <vTaskStartScheduler+0x100>
    cf5a:	4605      	mov	r5, r0
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    cf5c:	204c      	movs	r0, #76	; 0x4c
    cf5e:	f000 febd 	bl	dcdc <pvPortMalloc>
				if( pxNewTCB != NULL )
    cf62:	4604      	mov	r4, r0
    cf64:	2800      	cmp	r0, #0
    cf66:	d07f      	beq.n	d068 <vTaskStartScheduler+0x120>
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
    cf68:	21a5      	movs	r1, #165	; 0xa5
					pxNewTCB->pxStack = pxStack;
    cf6a:	6305      	str	r5, [r0, #48]	; 0x30
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
    cf6c:	f44f 6280 	mov.w	r2, #1024	; 0x400
    cf70:	4628      	mov	r0, r5
    cf72:	f006 fa95 	bl	134a0 <memset>
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    cf76:	6b23      	ldr	r3, [r4, #48]	; 0x30
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cf78:	4a5a      	ldr	r2, [pc, #360]	; (d0e4 <vTaskStartScheduler+0x19c>)
    cf7a:	6362      	str	r2, [r4, #52]	; 0x34
    cf7c:	2500      	movs	r5, #0
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    cf7e:	f104 0804 	add.w	r8, r4, #4
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    cf82:	f503 737f 	add.w	r3, r3, #1020	; 0x3fc
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    cf86:	4640      	mov	r0, r8
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cf88:	f884 5038 	strb.w	r5, [r4, #56]	; 0x38
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    cf8c:	f884 5043 	strb.w	r5, [r4, #67]	; 0x43
	pxNewTCB->uxPriority = uxPriority;
    cf90:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
    cf92:	f023 0607 	bic.w	r6, r3, #7
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    cf96:	f7ff f9cb 	bl	c330 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    cf9a:	f104 0018 	add.w	r0, r4, #24
    cf9e:	f7ff f9c7 	bl	c330 <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    cfa2:	2307      	movs	r3, #7
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    cfa4:	462a      	mov	r2, r5
		pxNewTCB->ulNotifiedValue = 0;
    cfa6:	6465      	str	r5, [r4, #68]	; 0x44
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    cfa8:	61a3      	str	r3, [r4, #24]
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    cfaa:	494f      	ldr	r1, [pc, #316]	; (d0e8 <vTaskStartScheduler+0x1a0>)
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    cfac:	6124      	str	r4, [r4, #16]
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    cfae:	4630      	mov	r0, r6
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    cfb0:	f884 5048 	strb.w	r5, [r4, #72]	; 0x48
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    cfb4:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    cfb6:	f000 ff63 	bl	de80 <pxPortInitialiseStack>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    cfba:	4b4c      	ldr	r3, [pc, #304]	; (d0ec <vTaskStartScheduler+0x1a4>)
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    cfbc:	6020      	str	r0, [r4, #0]
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    cfbe:	601c      	str	r4, [r3, #0]
	taskENTER_CRITICAL();
    cfc0:	f000 ff88 	bl	ded4 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
    cfc4:	4b4a      	ldr	r3, [pc, #296]	; (d0f0 <vTaskStartScheduler+0x1a8>)
		if( pxCurrentTCB == NULL )
    cfc6:	4f4b      	ldr	r7, [pc, #300]	; (d0f4 <vTaskStartScheduler+0x1ac>)
		uxCurrentNumberOfTasks++;
    cfc8:	681a      	ldr	r2, [r3, #0]
    cfca:	3201      	adds	r2, #1
    cfcc:	601a      	str	r2, [r3, #0]
		if( pxCurrentTCB == NULL )
    cfce:	683a      	ldr	r2, [r7, #0]
    cfd0:	2a00      	cmp	r2, #0
    cfd2:	d042      	beq.n	d05a <vTaskStartScheduler+0x112>
			if( xSchedulerRunning == pdFALSE )
    cfd4:	4e48      	ldr	r6, [pc, #288]	; (d0f8 <vTaskStartScheduler+0x1b0>)
    cfd6:	6833      	ldr	r3, [r6, #0]
    cfd8:	2b00      	cmp	r3, #0
    cfda:	d036      	beq.n	d04a <vTaskStartScheduler+0x102>
    cfdc:	4d47      	ldr	r5, [pc, #284]	; (d0fc <vTaskStartScheduler+0x1b4>)
		uxTaskNumber++;
    cfde:	4a48      	ldr	r2, [pc, #288]	; (d100 <vTaskStartScheduler+0x1b8>)
    cfe0:	6813      	ldr	r3, [r2, #0]
		traceTASK_CREATE( pxNewTCB );
    cfe2:	4620      	mov	r0, r4
		uxTaskNumber++;
    cfe4:	3301      	adds	r3, #1
    cfe6:	6013      	str	r3, [r2, #0]
		traceTASK_CREATE( pxNewTCB );
    cfe8:	f003 fdf0 	bl	10bcc <SEGGER_SYSVIEW_OnTaskCreate>
    cfec:	6b23      	ldr	r3, [r4, #48]	; 0x30
    cfee:	6821      	ldr	r1, [r4, #0]
    cff0:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    cff2:	1ac9      	subs	r1, r1, r3
    cff4:	9100      	str	r1, [sp, #0]
    cff6:	4620      	mov	r0, r4
    cff8:	f104 0134 	add.w	r1, r4, #52	; 0x34
    cffc:	f004 ffc2 	bl	11f84 <SYSVIEW_AddTask>
		prvReaddTaskToReadyList( pxNewTCB );
    d000:	4b40      	ldr	r3, [pc, #256]	; (d104 <vTaskStartScheduler+0x1bc>)
    d002:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    d004:	681a      	ldr	r2, [r3, #0]
    d006:	4290      	cmp	r0, r2
    d008:	d900      	bls.n	d00c <vTaskStartScheduler+0xc4>
    d00a:	6018      	str	r0, [r3, #0]
    d00c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    d010:	eb05 0080 	add.w	r0, r5, r0, lsl #2
    d014:	4641      	mov	r1, r8
    d016:	f7ff f98f 	bl	c338 <vListInsertEnd>
	taskEXIT_CRITICAL();
    d01a:	f000 ff75 	bl	df08 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
    d01e:	6833      	ldr	r3, [r6, #0]
    d020:	b163      	cbz	r3, d03c <vTaskStartScheduler+0xf4>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    d022:	683a      	ldr	r2, [r7, #0]
    d024:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    d026:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    d028:	429a      	cmp	r2, r3
    d02a:	d207      	bcs.n	d03c <vTaskStartScheduler+0xf4>
			taskYIELD_IF_USING_PREEMPTION();    /* Set a PendSV to request a context switch. */                             \
    d02c:	4b36      	ldr	r3, [pc, #216]	; (d108 <vTaskStartScheduler+0x1c0>)
    d02e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    d032:	601a      	str	r2, [r3, #0]
    d034:	f3bf 8f4f 	dsb	sy
    d038:	f3bf 8f6f 	isb	sy
			xReturn = xTimerCreateTimerTask();
    d03c:	f000 fd76 	bl	db2c <xTimerCreateTimerTask>
	if( xReturn == pdPASS )
    d040:	2801      	cmp	r0, #1
    d042:	d018      	beq.n	d076 <vTaskStartScheduler+0x12e>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
    d044:	3001      	adds	r0, #1
    d046:	d113      	bne.n	d070 <vTaskStartScheduler+0x128>
    d048:	e7fe      	b.n	d048 <vTaskStartScheduler+0x100>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    d04a:	683a      	ldr	r2, [r7, #0]
    d04c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    d04e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    d050:	4d2a      	ldr	r5, [pc, #168]	; (d0fc <vTaskStartScheduler+0x1b4>)
    d052:	429a      	cmp	r2, r3
					pxCurrentTCB = pxNewTCB;
    d054:	bf98      	it	ls
    d056:	603c      	strls	r4, [r7, #0]
    d058:	e7c1      	b.n	cfde <vTaskStartScheduler+0x96>
			pxCurrentTCB = pxNewTCB;
    d05a:	603c      	str	r4, [r7, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    d05c:	681b      	ldr	r3, [r3, #0]
    d05e:	4d27      	ldr	r5, [pc, #156]	; (d0fc <vTaskStartScheduler+0x1b4>)
    d060:	2b01      	cmp	r3, #1
    d062:	d01d      	beq.n	d0a0 <vTaskStartScheduler+0x158>
    d064:	4e24      	ldr	r6, [pc, #144]	; (d0f8 <vTaskStartScheduler+0x1b0>)
    d066:	e7ba      	b.n	cfde <vTaskStartScheduler+0x96>
					vPortFree( pxStack );
    d068:	4628      	mov	r0, r5
    d06a:	f000 feb7 	bl	dddc <vPortFree>
    d06e:	e7eb      	b.n	d048 <vTaskStartScheduler+0x100>
}
    d070:	b002      	add	sp, #8
    d072:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	__asm volatile
    d076:	f04f 0380 	mov.w	r3, #128	; 0x80
    d07a:	f383 8811 	msr	BASEPRI, r3
    d07e:	f3bf 8f6f 	isb	sy
    d082:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
    d086:	4921      	ldr	r1, [pc, #132]	; (d10c <vTaskStartScheduler+0x1c4>)
		xTickCount = ( TickType_t ) 0U;
    d088:	4b21      	ldr	r3, [pc, #132]	; (d110 <vTaskStartScheduler+0x1c8>)
		xNextTaskUnblockTime = portMAX_DELAY;
    d08a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
		xTickCount = ( TickType_t ) 0U;
    d08e:	2200      	movs	r2, #0
		xNextTaskUnblockTime = portMAX_DELAY;
    d090:	600c      	str	r4, [r1, #0]
		xSchedulerRunning = pdTRUE;
    d092:	6030      	str	r0, [r6, #0]
		xTickCount = ( TickType_t ) 0U;
    d094:	601a      	str	r2, [r3, #0]
}
    d096:	b002      	add	sp, #8
    d098:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		if( xPortStartScheduler() != pdFALSE )
    d09c:	f001 b880 	b.w	e1a0 <xPortStartScheduler>
    d0a0:	462e      	mov	r6, r5
    d0a2:	f105 098c 	add.w	r9, r5, #140	; 0x8c
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    d0a6:	4630      	mov	r0, r6
    d0a8:	3614      	adds	r6, #20
    d0aa:	f7ff f935 	bl	c318 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    d0ae:	45b1      	cmp	r9, r6
    d0b0:	d1f9      	bne.n	d0a6 <vTaskStartScheduler+0x15e>
	vListInitialise( &xDelayedTaskList1 );
    d0b2:	f8df a070 	ldr.w	sl, [pc, #112]	; d124 <vTaskStartScheduler+0x1dc>
	vListInitialise( &xDelayedTaskList2 );
    d0b6:	f8df 9070 	ldr.w	r9, [pc, #112]	; d128 <vTaskStartScheduler+0x1e0>
    d0ba:	4e0f      	ldr	r6, [pc, #60]	; (d0f8 <vTaskStartScheduler+0x1b0>)
	vListInitialise( &xDelayedTaskList1 );
    d0bc:	4650      	mov	r0, sl
    d0be:	f7ff f92b 	bl	c318 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    d0c2:	4648      	mov	r0, r9
    d0c4:	f7ff f928 	bl	c318 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    d0c8:	4812      	ldr	r0, [pc, #72]	; (d114 <vTaskStartScheduler+0x1cc>)
    d0ca:	f7ff f925 	bl	c318 <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
    d0ce:	4812      	ldr	r0, [pc, #72]	; (d118 <vTaskStartScheduler+0x1d0>)
    d0d0:	f7ff f922 	bl	c318 <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
    d0d4:	4a11      	ldr	r2, [pc, #68]	; (d11c <vTaskStartScheduler+0x1d4>)
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    d0d6:	4b12      	ldr	r3, [pc, #72]	; (d120 <vTaskStartScheduler+0x1d8>)
	pxDelayedTaskList = &xDelayedTaskList1;
    d0d8:	f8c2 a000 	str.w	sl, [r2]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    d0dc:	f8c3 9000 	str.w	r9, [r3]
    d0e0:	e77d      	b.n	cfde <vTaskStartScheduler+0x96>
    d0e2:	bf00      	nop
    d0e4:	454c4449 	.word	0x454c4449
    d0e8:	0000d3b9 	.word	0x0000d3b9
    d0ec:	10002c64 	.word	0x10002c64
    d0f0:	10002c28 	.word	0x10002c28
    d0f4:	10002b90 	.word	0x10002b90
    d0f8:	10002c84 	.word	0x10002c84
    d0fc:	10002b9c 	.word	0x10002b9c
    d100:	10002c34 	.word	0x10002c34
    d104:	10002c38 	.word	0x10002c38
    d108:	e000ed04 	.word	0xe000ed04
    d10c:	10002c68 	.word	0x10002c68
    d110:	10002c9c 	.word	0x10002c9c
    d114:	10002c70 	.word	0x10002c70
    d118:	10002c88 	.word	0x10002c88
    d11c:	10002b94 	.word	0x10002b94
    d120:	10002b98 	.word	0x10002b98
    d124:	10002c3c 	.word	0x10002c3c
    d128:	10002c50 	.word	0x10002c50

0000d12c <vTaskSuspendAll>:
	++uxSchedulerSuspended;
    d12c:	4a02      	ldr	r2, [pc, #8]	; (d138 <vTaskSuspendAll+0xc>)
    d12e:	6813      	ldr	r3, [r2, #0]
    d130:	3301      	adds	r3, #1
    d132:	6013      	str	r3, [r2, #0]
}
    d134:	4770      	bx	lr
    d136:	bf00      	nop
    d138:	10002c30 	.word	0x10002c30

0000d13c <xTaskGetTickCount>:
		xTicks = xTickCount;
    d13c:	4b01      	ldr	r3, [pc, #4]	; (d144 <xTaskGetTickCount+0x8>)
    d13e:	6818      	ldr	r0, [r3, #0]
}
    d140:	4770      	bx	lr
    d142:	bf00      	nop
    d144:	10002c9c 	.word	0x10002c9c

0000d148 <xTaskGetTickCountFromISR>:
{
    d148:	b508      	push	{r3, lr}
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
    d14a:	f000 ff3b 	bl	dfc4 <vPortValidateInterruptPriority>
		xReturn = xTickCount;
    d14e:	4b01      	ldr	r3, [pc, #4]	; (d154 <xTaskGetTickCountFromISR+0xc>)
    d150:	6818      	ldr	r0, [r3, #0]
}
    d152:	bd08      	pop	{r3, pc}
    d154:	10002c9c 	.word	0x10002c9c

0000d158 <vTaskStepTick>:
		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
    d158:	4b07      	ldr	r3, [pc, #28]	; (d178 <vTaskStepTick+0x20>)
    d15a:	4908      	ldr	r1, [pc, #32]	; (d17c <vTaskStepTick+0x24>)
    d15c:	681a      	ldr	r2, [r3, #0]
    d15e:	6809      	ldr	r1, [r1, #0]
    d160:	4402      	add	r2, r0
    d162:	428a      	cmp	r2, r1
    d164:	d900      	bls.n	d168 <vTaskStepTick+0x10>
    d166:	e7fe      	b.n	d166 <vTaskStepTick+0xe>
		xTickCount += xTicksToJump;
    d168:	681a      	ldr	r2, [r3, #0]
		traceINCREASE_TICK_COUNT( xTicksToJump );
    d16a:	4601      	mov	r1, r0
		xTickCount += xTicksToJump;
    d16c:	4402      	add	r2, r0
		traceINCREASE_TICK_COUNT( xTicksToJump );
    d16e:	204e      	movs	r0, #78	; 0x4e
		xTickCount += xTicksToJump;
    d170:	601a      	str	r2, [r3, #0]
		traceINCREASE_TICK_COUNT( xTicksToJump );
    d172:	f004 bc05 	b.w	11980 <SEGGER_SYSVIEW_RecordU32>
    d176:	bf00      	nop
    d178:	10002c9c 	.word	0x10002c9c
    d17c:	10002c68 	.word	0x10002c68

0000d180 <xTaskIncrementTick>:
{
    d180:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    d184:	4b42      	ldr	r3, [pc, #264]	; (d290 <xTaskIncrementTick+0x110>)
    d186:	681b      	ldr	r3, [r3, #0]
    d188:	b9c3      	cbnz	r3, d1bc <xTaskIncrementTick+0x3c>
		const TickType_t xConstTickCount = xTickCount + 1;
    d18a:	4b42      	ldr	r3, [pc, #264]	; (d294 <xTaskIncrementTick+0x114>)
    d18c:	681f      	ldr	r7, [r3, #0]
    d18e:	3701      	adds	r7, #1
		xTickCount = xConstTickCount;
    d190:	601f      	str	r7, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U )
    d192:	b307      	cbz	r7, d1d6 <xTaskIncrementTick+0x56>
    d194:	4e40      	ldr	r6, [pc, #256]	; (d298 <xTaskIncrementTick+0x118>)
		if( xConstTickCount >= xNextTaskUnblockTime )
    d196:	6833      	ldr	r3, [r6, #0]
    d198:	42bb      	cmp	r3, r7
    d19a:	d935      	bls.n	d208 <xTaskIncrementTick+0x88>
    d19c:	f8df 8114 	ldr.w	r8, [pc, #276]	; d2b4 <xTaskIncrementTick+0x134>
    d1a0:	f8df 9114 	ldr.w	r9, [pc, #276]	; d2b8 <xTaskIncrementTick+0x138>
BaseType_t xSwitchRequired = pdFALSE;
    d1a4:	2400      	movs	r4, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    d1a6:	f8d9 3000 	ldr.w	r3, [r9]
    d1aa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    d1ac:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    d1b0:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
				xSwitchRequired = pdTRUE;
    d1b4:	2b02      	cmp	r3, #2
    d1b6:	bf28      	it	cs
    d1b8:	2401      	movcs	r4, #1
    d1ba:	e004      	b.n	d1c6 <xTaskIncrementTick+0x46>
		++uxPendedTicks;
    d1bc:	4a37      	ldr	r2, [pc, #220]	; (d29c <xTaskIncrementTick+0x11c>)
    d1be:	6813      	ldr	r3, [r2, #0]
    d1c0:	3301      	adds	r3, #1
    d1c2:	6013      	str	r3, [r2, #0]
BaseType_t xSwitchRequired = pdFALSE;
    d1c4:	2400      	movs	r4, #0
		if( xYieldPending != pdFALSE )
    d1c6:	4b36      	ldr	r3, [pc, #216]	; (d2a0 <xTaskIncrementTick+0x120>)
    d1c8:	681b      	ldr	r3, [r3, #0]
			xSwitchRequired = pdTRUE;
    d1ca:	2b00      	cmp	r3, #0
}
    d1cc:	bf0c      	ite	eq
    d1ce:	4620      	moveq	r0, r4
    d1d0:	2001      	movne	r0, #1
    d1d2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			taskSWITCH_DELAYED_LISTS();
    d1d6:	4d33      	ldr	r5, [pc, #204]	; (d2a4 <xTaskIncrementTick+0x124>)
    d1d8:	682b      	ldr	r3, [r5, #0]
    d1da:	681b      	ldr	r3, [r3, #0]
    d1dc:	2b00      	cmp	r3, #0
    d1de:	d151      	bne.n	d284 <xTaskIncrementTick+0x104>
    d1e0:	4b31      	ldr	r3, [pc, #196]	; (d2a8 <xTaskIncrementTick+0x128>)
    d1e2:	6829      	ldr	r1, [r5, #0]
    d1e4:	4a31      	ldr	r2, [pc, #196]	; (d2ac <xTaskIncrementTick+0x12c>)
    d1e6:	6818      	ldr	r0, [r3, #0]
    d1e8:	6028      	str	r0, [r5, #0]
    d1ea:	6019      	str	r1, [r3, #0]
    d1ec:	6813      	ldr	r3, [r2, #0]
    d1ee:	3301      	adds	r3, #1
    d1f0:	6013      	str	r3, [r2, #0]
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    d1f2:	682b      	ldr	r3, [r5, #0]
    d1f4:	681b      	ldr	r3, [r3, #0]
    d1f6:	2b00      	cmp	r3, #0
    d1f8:	d147      	bne.n	d28a <xTaskIncrementTick+0x10a>
		xNextTaskUnblockTime = portMAX_DELAY;
    d1fa:	4e27      	ldr	r6, [pc, #156]	; (d298 <xTaskIncrementTick+0x118>)
    d1fc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    d200:	6033      	str	r3, [r6, #0]
		if( xConstTickCount >= xNextTaskUnblockTime )
    d202:	6833      	ldr	r3, [r6, #0]
    d204:	42bb      	cmp	r3, r7
    d206:	d8c9      	bhi.n	d19c <xTaskIncrementTick+0x1c>
    d208:	4d26      	ldr	r5, [pc, #152]	; (d2a4 <xTaskIncrementTick+0x124>)
    d20a:	f8df 80a8 	ldr.w	r8, [pc, #168]	; d2b4 <xTaskIncrementTick+0x134>
    d20e:	f8df 90a8 	ldr.w	r9, [pc, #168]	; d2b8 <xTaskIncrementTick+0x138>
BaseType_t xSwitchRequired = pdFALSE;
    d212:	2400      	movs	r4, #0
    d214:	e02e      	b.n	d274 <xTaskIncrementTick+0xf4>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    d216:	682b      	ldr	r3, [r5, #0]
    d218:	68db      	ldr	r3, [r3, #12]
    d21a:	f8d3 a00c 	ldr.w	sl, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    d21e:	f8da 2004 	ldr.w	r2, [sl, #4]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    d222:	f10a 0b04 	add.w	fp, sl, #4
					if( xConstTickCount < xItemValue )
    d226:	4297      	cmp	r7, r2
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    d228:	4658      	mov	r0, fp
					if( xConstTickCount < xItemValue )
    d22a:	d32c      	bcc.n	d286 <xTaskIncrementTick+0x106>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    d22c:	f7ff f8ae 	bl	c38c <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    d230:	f8da 2028 	ldr.w	r2, [sl, #40]	; 0x28
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    d234:	f10a 0018 	add.w	r0, sl, #24
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    d238:	b10a      	cbz	r2, d23e <xTaskIncrementTick+0xbe>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    d23a:	f7ff f8a7 	bl	c38c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    d23e:	4650      	mov	r0, sl
    d240:	f003 fdf8 	bl	10e34 <SEGGER_SYSVIEW_OnTaskStartReady>
    d244:	4b1a      	ldr	r3, [pc, #104]	; (d2b0 <xTaskIncrementTick+0x130>)
    d246:	f8da 202c 	ldr.w	r2, [sl, #44]	; 0x2c
    d24a:	681b      	ldr	r3, [r3, #0]
    d24c:	429a      	cmp	r2, r3
    d24e:	bf88      	it	hi
    d250:	4b17      	ldrhi	r3, [pc, #92]	; (d2b0 <xTaskIncrementTick+0x130>)
    d252:	eb02 0082 	add.w	r0, r2, r2, lsl #2
    d256:	4659      	mov	r1, fp
    d258:	eb08 0080 	add.w	r0, r8, r0, lsl #2
    d25c:	bf88      	it	hi
    d25e:	601a      	strhi	r2, [r3, #0]
    d260:	f7ff f86a 	bl	c338 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    d264:	f8d9 1000 	ldr.w	r1, [r9]
    d268:	f8da 202c 	ldr.w	r2, [sl, #44]	; 0x2c
    d26c:	6acb      	ldr	r3, [r1, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
    d26e:	429a      	cmp	r2, r3
    d270:	bf28      	it	cs
    d272:	2401      	movcs	r4, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    d274:	682b      	ldr	r3, [r5, #0]
    d276:	681b      	ldr	r3, [r3, #0]
    d278:	2b00      	cmp	r3, #0
    d27a:	d1cc      	bne.n	d216 <xTaskIncrementTick+0x96>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    d27c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    d280:	6033      	str	r3, [r6, #0]
					break;
    d282:	e790      	b.n	d1a6 <xTaskIncrementTick+0x26>
    d284:	e7fe      	b.n	d284 <xTaskIncrementTick+0x104>
						xNextTaskUnblockTime = xItemValue;
    d286:	6032      	str	r2, [r6, #0]
						break;
    d288:	e78d      	b.n	d1a6 <xTaskIncrementTick+0x26>
    d28a:	f7ff fd1b 	bl	ccc4 <prvResetNextTaskUnblockTime.part.2>
    d28e:	e781      	b.n	d194 <xTaskIncrementTick+0x14>
    d290:	10002c30 	.word	0x10002c30
    d294:	10002c9c 	.word	0x10002c9c
    d298:	10002c68 	.word	0x10002c68
    d29c:	10002c2c 	.word	0x10002c2c
    d2a0:	10002ca0 	.word	0x10002ca0
    d2a4:	10002b94 	.word	0x10002b94
    d2a8:	10002b98 	.word	0x10002b98
    d2ac:	10002c6c 	.word	0x10002c6c
    d2b0:	10002c38 	.word	0x10002c38
    d2b4:	10002b9c 	.word	0x10002b9c
    d2b8:	10002b90 	.word	0x10002b90

0000d2bc <xTaskResumeAll>:
{
    d2bc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	configASSERT( uxSchedulerSuspended );
    d2c0:	4c32      	ldr	r4, [pc, #200]	; (d38c <xTaskResumeAll+0xd0>)
    d2c2:	6823      	ldr	r3, [r4, #0]
    d2c4:	b903      	cbnz	r3, d2c8 <xTaskResumeAll+0xc>
    d2c6:	e7fe      	b.n	d2c6 <xTaskResumeAll+0xa>
	taskENTER_CRITICAL();
    d2c8:	f000 fe04 	bl	ded4 <vPortEnterCritical>
		--uxSchedulerSuspended;
    d2cc:	6823      	ldr	r3, [r4, #0]
    d2ce:	3b01      	subs	r3, #1
    d2d0:	6023      	str	r3, [r4, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    d2d2:	6824      	ldr	r4, [r4, #0]
    d2d4:	bb7c      	cbnz	r4, d336 <xTaskResumeAll+0x7a>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    d2d6:	4b2e      	ldr	r3, [pc, #184]	; (d390 <xTaskResumeAll+0xd4>)
    d2d8:	681b      	ldr	r3, [r3, #0]
    d2da:	b363      	cbz	r3, d336 <xTaskResumeAll+0x7a>
    d2dc:	4e2d      	ldr	r6, [pc, #180]	; (d394 <xTaskResumeAll+0xd8>)
    d2de:	4f2e      	ldr	r7, [pc, #184]	; (d398 <xTaskResumeAll+0xdc>)
					prvAddTaskToReadyList( pxTCB );
    d2e0:	4d2e      	ldr	r5, [pc, #184]	; (d39c <xTaskResumeAll+0xe0>)
    d2e2:	f8df 90cc 	ldr.w	r9, [pc, #204]	; d3b0 <xTaskResumeAll+0xf4>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    d2e6:	f8df 80cc 	ldr.w	r8, [pc, #204]	; d3b4 <xTaskResumeAll+0xf8>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    d2ea:	683b      	ldr	r3, [r7, #0]
    d2ec:	b34b      	cbz	r3, d342 <xTaskResumeAll+0x86>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    d2ee:	68fb      	ldr	r3, [r7, #12]
    d2f0:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    d2f2:	f104 0a04 	add.w	sl, r4, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    d2f6:	f104 0018 	add.w	r0, r4, #24
    d2fa:	f7ff f847 	bl	c38c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    d2fe:	4650      	mov	r0, sl
    d300:	f7ff f844 	bl	c38c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    d304:	4620      	mov	r0, r4
    d306:	f003 fd95 	bl	10e34 <SEGGER_SYSVIEW_OnTaskStartReady>
    d30a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    d30c:	682a      	ldr	r2, [r5, #0]
    d30e:	eb03 0083 	add.w	r0, r3, r3, lsl #2
    d312:	4293      	cmp	r3, r2
    d314:	4651      	mov	r1, sl
    d316:	eb09 0080 	add.w	r0, r9, r0, lsl #2
    d31a:	bf88      	it	hi
    d31c:	602b      	strhi	r3, [r5, #0]
    d31e:	f7ff f80b 	bl	c338 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    d322:	f8d8 3000 	ldr.w	r3, [r8]
    d326:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    d328:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    d32a:	429a      	cmp	r2, r3
						xYieldPending = pdTRUE;
    d32c:	f04f 0301 	mov.w	r3, #1
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    d330:	d3db      	bcc.n	d2ea <xTaskResumeAll+0x2e>
						xYieldPending = pdTRUE;
    d332:	6033      	str	r3, [r6, #0]
    d334:	e7d9      	b.n	d2ea <xTaskResumeAll+0x2e>
BaseType_t xAlreadyYielded = pdFALSE;
    d336:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
    d338:	f000 fde6 	bl	df08 <vPortExitCritical>
}
    d33c:	4620      	mov	r0, r4
    d33e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				if( pxTCB != NULL )
    d342:	b13c      	cbz	r4, d354 <xTaskResumeAll+0x98>
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    d344:	4b16      	ldr	r3, [pc, #88]	; (d3a0 <xTaskResumeAll+0xe4>)
    d346:	681b      	ldr	r3, [r3, #0]
    d348:	681b      	ldr	r3, [r3, #0]
    d34a:	b9db      	cbnz	r3, d384 <xTaskResumeAll+0xc8>
		xNextTaskUnblockTime = portMAX_DELAY;
    d34c:	4b15      	ldr	r3, [pc, #84]	; (d3a4 <xTaskResumeAll+0xe8>)
    d34e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    d352:	601a      	str	r2, [r3, #0]
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    d354:	4d14      	ldr	r5, [pc, #80]	; (d3a8 <xTaskResumeAll+0xec>)
    d356:	682c      	ldr	r4, [r5, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
    d358:	b13c      	cbz	r4, d36a <xTaskResumeAll+0xae>
								xYieldPending = pdTRUE;
    d35a:	2701      	movs	r7, #1
							if( xTaskIncrementTick() != pdFALSE )
    d35c:	f7ff ff10 	bl	d180 <xTaskIncrementTick>
    d360:	b100      	cbz	r0, d364 <xTaskResumeAll+0xa8>
								xYieldPending = pdTRUE;
    d362:	6037      	str	r7, [r6, #0]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    d364:	3c01      	subs	r4, #1
    d366:	d1f9      	bne.n	d35c <xTaskResumeAll+0xa0>
						uxPendedTicks = 0;
    d368:	602c      	str	r4, [r5, #0]
				if( xYieldPending != pdFALSE )
    d36a:	6833      	ldr	r3, [r6, #0]
    d36c:	2b00      	cmp	r3, #0
    d36e:	d0e2      	beq.n	d336 <xTaskResumeAll+0x7a>
					taskYIELD_IF_USING_PREEMPTION();
    d370:	4b0e      	ldr	r3, [pc, #56]	; (d3ac <xTaskResumeAll+0xf0>)
    d372:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    d376:	601a      	str	r2, [r3, #0]
    d378:	f3bf 8f4f 	dsb	sy
    d37c:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
    d380:	2401      	movs	r4, #1
    d382:	e7d9      	b.n	d338 <xTaskResumeAll+0x7c>
    d384:	f7ff fc9e 	bl	ccc4 <prvResetNextTaskUnblockTime.part.2>
    d388:	e7e4      	b.n	d354 <xTaskResumeAll+0x98>
    d38a:	bf00      	nop
    d38c:	10002c30 	.word	0x10002c30
    d390:	10002c28 	.word	0x10002c28
    d394:	10002ca0 	.word	0x10002ca0
    d398:	10002c70 	.word	0x10002c70
    d39c:	10002c38 	.word	0x10002c38
    d3a0:	10002b94 	.word	0x10002b94
    d3a4:	10002c68 	.word	0x10002c68
    d3a8:	10002c2c 	.word	0x10002c2c
    d3ac:	e000ed04 	.word	0xe000ed04
    d3b0:	10002b9c 	.word	0x10002b9c
    d3b4:	10002b90 	.word	0x10002b90

0000d3b8 <prvIdleTask>:
{
    d3b8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d3bc:	f8df b09c 	ldr.w	fp, [pc, #156]	; d45c <prvIdleTask+0xa4>
    d3c0:	4d23      	ldr	r5, [pc, #140]	; (d450 <prvIdleTask+0x98>)
    d3c2:	4c24      	ldr	r4, [pc, #144]	; (d454 <prvIdleTask+0x9c>)
    d3c4:	f8df a098 	ldr.w	sl, [pc, #152]	; d460 <prvIdleTask+0xa8>
    d3c8:	f8df 9098 	ldr.w	r9, [pc, #152]	; d464 <prvIdleTask+0xac>
    d3cc:	f8df 8098 	ldr.w	r8, [pc, #152]	; d468 <prvIdleTask+0xb0>
				taskYIELD();
    d3d0:	4f21      	ldr	r7, [pc, #132]	; (d458 <prvIdleTask+0xa0>)
    d3d2:	f04f 5680 	mov.w	r6, #268435456	; 0x10000000
    d3d6:	f8db 3000 	ldr.w	r3, [fp]
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    d3da:	2b01      	cmp	r3, #1
    d3dc:	d906      	bls.n	d3ec <prvIdleTask+0x34>
				taskYIELD();
    d3de:	603e      	str	r6, [r7, #0]
    d3e0:	f3bf 8f4f 	dsb	sy
    d3e4:	f3bf 8f6f 	isb	sy
    d3e8:	f8db 3000 	ldr.w	r3, [fp]
			if( uxTopReadyPriority > tskIDLE_PRIORITY )
    d3ec:	682a      	ldr	r2, [r5, #0]
    d3ee:	b9f2      	cbnz	r2, d42e <prvIdleTask+0x76>
		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
    d3f0:	6822      	ldr	r2, [r4, #0]
    d3f2:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    d3f4:	2a00      	cmp	r2, #0
    d3f6:	d1f0      	bne.n	d3da <prvIdleTask+0x22>
		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
    d3f8:	2b01      	cmp	r3, #1
    d3fa:	d8ee      	bhi.n	d3da <prvIdleTask+0x22>
			xReturn = xNextTaskUnblockTime - xTickCount;
    d3fc:	f8da 2000 	ldr.w	r2, [sl]
    d400:	f8d9 1000 	ldr.w	r1, [r9]
    d404:	1a52      	subs	r2, r2, r1
			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
    d406:	2a01      	cmp	r2, #1
    d408:	d9e7      	bls.n	d3da <prvIdleTask+0x22>
	++uxSchedulerSuspended;
    d40a:	f8d8 3000 	ldr.w	r3, [r8]
    d40e:	3301      	adds	r3, #1
    d410:	f8c8 3000 	str.w	r3, [r8]
					configASSERT( xNextTaskUnblockTime >= xTickCount );
    d414:	f8da 2000 	ldr.w	r2, [sl]
    d418:	f8d9 3000 	ldr.w	r3, [r9]
    d41c:	429a      	cmp	r2, r3
    d41e:	d305      	bcc.n	d42c <prvIdleTask+0x74>
			if( uxTopReadyPriority > tskIDLE_PRIORITY )
    d420:	682b      	ldr	r3, [r5, #0]
    d422:	b133      	cbz	r3, d432 <prvIdleTask+0x7a>
		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
    d424:	6823      	ldr	r3, [r4, #0]
				( void ) xTaskResumeAll();
    d426:	f7ff ff49 	bl	d2bc <xTaskResumeAll>
    d42a:	e7d4      	b.n	d3d6 <prvIdleTask+0x1e>
    d42c:	e7fe      	b.n	d42c <prvIdleTask+0x74>
		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
    d42e:	6822      	ldr	r2, [r4, #0]
    d430:	e7d3      	b.n	d3da <prvIdleTask+0x22>
    d432:	6823      	ldr	r3, [r4, #0]
    d434:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    d436:	2b00      	cmp	r3, #0
    d438:	d1f5      	bne.n	d426 <prvIdleTask+0x6e>
			xReturn = xNextTaskUnblockTime - xTickCount;
    d43a:	f8da 0000 	ldr.w	r0, [sl]
    d43e:	f8d9 3000 	ldr.w	r3, [r9]
    d442:	1ac0      	subs	r0, r0, r3
					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
    d444:	2801      	cmp	r0, #1
    d446:	d9ee      	bls.n	d426 <prvIdleTask+0x6e>
						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
    d448:	f000 fdda 	bl	e000 <vPortSuppressTicksAndSleep>
    d44c:	e7eb      	b.n	d426 <prvIdleTask+0x6e>
    d44e:	bf00      	nop
    d450:	10002c38 	.word	0x10002c38
    d454:	10002b90 	.word	0x10002b90
    d458:	e000ed04 	.word	0xe000ed04
    d45c:	10002b9c 	.word	0x10002b9c
    d460:	10002c68 	.word	0x10002c68
    d464:	10002c9c 	.word	0x10002c9c
    d468:	10002c30 	.word	0x10002c30

0000d46c <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    d46c:	4b40      	ldr	r3, [pc, #256]	; (d570 <vTaskSwitchContext+0x104>)
    d46e:	681b      	ldr	r3, [r3, #0]
    d470:	2b00      	cmp	r3, #0
    d472:	d154      	bne.n	d51e <vTaskSwitchContext+0xb2>
		xYieldPending = pdFALSE;
    d474:	4a3f      	ldr	r2, [pc, #252]	; (d574 <vTaskSwitchContext+0x108>)
{
    d476:	b570      	push	{r4, r5, r6, lr}
		taskCHECK_FOR_STACK_OVERFLOW();
    d478:	4c3f      	ldr	r4, [pc, #252]	; (d578 <vTaskSwitchContext+0x10c>)
		xYieldPending = pdFALSE;
    d47a:	6013      	str	r3, [r2, #0]
		taskCHECK_FOR_STACK_OVERFLOW();
    d47c:	6823      	ldr	r3, [r4, #0]
    d47e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    d480:	681a      	ldr	r2, [r3, #0]
    d482:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
    d486:	d10b      	bne.n	d4a0 <vTaskSwitchContext+0x34>
    d488:	685a      	ldr	r2, [r3, #4]
    d48a:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
    d48e:	d107      	bne.n	d4a0 <vTaskSwitchContext+0x34>
    d490:	689a      	ldr	r2, [r3, #8]
    d492:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
    d496:	d103      	bne.n	d4a0 <vTaskSwitchContext+0x34>
    d498:	68db      	ldr	r3, [r3, #12]
    d49a:	f1b3 3fa5 	cmp.w	r3, #2779096485	; 0xa5a5a5a5
    d49e:	d004      	beq.n	d4aa <vTaskSwitchContext+0x3e>
    d4a0:	6820      	ldr	r0, [r4, #0]
    d4a2:	6821      	ldr	r1, [r4, #0]
    d4a4:	3134      	adds	r1, #52	; 0x34
    d4a6:	f004 fde9 	bl	1207c <vApplicationStackOverflowHook>
		taskSELECT_HIGHEST_PRIORITY_TASK();
    d4aa:	4d34      	ldr	r5, [pc, #208]	; (d57c <vTaskSwitchContext+0x110>)
    d4ac:	4934      	ldr	r1, [pc, #208]	; (d580 <vTaskSwitchContext+0x114>)
    d4ae:	682a      	ldr	r2, [r5, #0]
    d4b0:	0093      	lsls	r3, r2, #2
    d4b2:	1898      	adds	r0, r3, r2
    d4b4:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
    d4b8:	bbb8      	cbnz	r0, d52a <vTaskSwitchContext+0xbe>
    d4ba:	b37a      	cbz	r2, d51c <vTaskSwitchContext+0xb0>
    d4bc:	1e53      	subs	r3, r2, #1
    d4be:	eb03 0083 	add.w	r0, r3, r3, lsl #2
    d4c2:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
    d4c6:	bb70      	cbnz	r0, d526 <vTaskSwitchContext+0xba>
    d4c8:	b343      	cbz	r3, d51c <vTaskSwitchContext+0xb0>
    d4ca:	1e93      	subs	r3, r2, #2
    d4cc:	eb03 0083 	add.w	r0, r3, r3, lsl #2
    d4d0:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
    d4d4:	bb38      	cbnz	r0, d526 <vTaskSwitchContext+0xba>
    d4d6:	b30b      	cbz	r3, d51c <vTaskSwitchContext+0xb0>
    d4d8:	1ed3      	subs	r3, r2, #3
    d4da:	eb03 0083 	add.w	r0, r3, r3, lsl #2
    d4de:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
    d4e2:	bb00      	cbnz	r0, d526 <vTaskSwitchContext+0xba>
    d4e4:	b1d3      	cbz	r3, d51c <vTaskSwitchContext+0xb0>
    d4e6:	1f13      	subs	r3, r2, #4
    d4e8:	eb03 0083 	add.w	r0, r3, r3, lsl #2
    d4ec:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
    d4f0:	b9c8      	cbnz	r0, d526 <vTaskSwitchContext+0xba>
    d4f2:	b19b      	cbz	r3, d51c <vTaskSwitchContext+0xb0>
    d4f4:	1f53      	subs	r3, r2, #5
    d4f6:	eb03 0083 	add.w	r0, r3, r3, lsl #2
    d4fa:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
    d4fe:	b990      	cbnz	r0, d526 <vTaskSwitchContext+0xba>
    d500:	b163      	cbz	r3, d51c <vTaskSwitchContext+0xb0>
    d502:	1f93      	subs	r3, r2, #6
    d504:	eb03 0083 	add.w	r0, r3, r3, lsl #2
    d508:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
    d50c:	b958      	cbnz	r0, d526 <vTaskSwitchContext+0xba>
    d50e:	b12b      	cbz	r3, d51c <vTaskSwitchContext+0xb0>
    d510:	1fd3      	subs	r3, r2, #7
    d512:	eb03 0283 	add.w	r2, r3, r3, lsl #2
    d516:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    d51a:	b922      	cbnz	r2, d526 <vTaskSwitchContext+0xba>
    d51c:	e7fe      	b.n	d51c <vTaskSwitchContext+0xb0>
		xYieldPending = pdTRUE;
    d51e:	4b15      	ldr	r3, [pc, #84]	; (d574 <vTaskSwitchContext+0x108>)
    d520:	2201      	movs	r2, #1
    d522:	601a      	str	r2, [r3, #0]
    d524:	4770      	bx	lr
		taskSELECT_HIGHEST_PRIORITY_TASK();
    d526:	461a      	mov	r2, r3
    d528:	009b      	lsls	r3, r3, #2
    d52a:	4413      	add	r3, r2
    d52c:	009b      	lsls	r3, r3, #2
    d52e:	18ce      	adds	r6, r1, r3
    d530:	3308      	adds	r3, #8
    d532:	6870      	ldr	r0, [r6, #4]
    d534:	6840      	ldr	r0, [r0, #4]
    d536:	6070      	str	r0, [r6, #4]
    d538:	440b      	add	r3, r1
    d53a:	4298      	cmp	r0, r3
    d53c:	d00d      	beq.n	d55a <vTaskSwitchContext+0xee>
    d53e:	68c3      	ldr	r3, [r0, #12]
    d540:	6023      	str	r3, [r4, #0]
    d542:	602a      	str	r2, [r5, #0]
		traceTASK_SWITCHED_IN();
    d544:	6820      	ldr	r0, [r4, #0]
    d546:	490f      	ldr	r1, [pc, #60]	; (d584 <vTaskSwitchContext+0x118>)
    d548:	3034      	adds	r0, #52	; 0x34
    d54a:	2205      	movs	r2, #5
    d54c:	f005 ff76 	bl	1343c <memcmp>
    d550:	b948      	cbnz	r0, d566 <vTaskSwitchContext+0xfa>
}
    d552:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		traceTASK_SWITCHED_IN();
    d556:	f003 b875 	b.w	10644 <SEGGER_SYSVIEW_OnIdle>
		taskSELECT_HIGHEST_PRIORITY_TASK();
    d55a:	2314      	movs	r3, #20
    d55c:	fb03 1102 	mla	r1, r3, r2, r1
    d560:	6840      	ldr	r0, [r0, #4]
    d562:	6048      	str	r0, [r1, #4]
    d564:	e7eb      	b.n	d53e <vTaskSwitchContext+0xd2>
		traceTASK_SWITCHED_IN();
    d566:	6820      	ldr	r0, [r4, #0]
}
    d568:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		traceTASK_SWITCHED_IN();
    d56c:	f003 bbc8 	b.w	10d00 <SEGGER_SYSVIEW_OnTaskStartExec>
    d570:	10002c30 	.word	0x10002c30
    d574:	10002ca0 	.word	0x10002ca0
    d578:	10002b90 	.word	0x10002b90
    d57c:	10002c38 	.word	0x10002c38
    d580:	10002b9c 	.word	0x10002b9c
    d584:	00013554 	.word	0x00013554

0000d588 <vTaskPlaceOnEventList>:
	configASSERT( pxEventList );
    d588:	b318      	cbz	r0, d5d2 <vTaskPlaceOnEventList+0x4a>
{
    d58a:	b570      	push	{r4, r5, r6, lr}
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    d58c:	4d1c      	ldr	r5, [pc, #112]	; (d600 <vTaskPlaceOnEventList+0x78>)
    d58e:	460c      	mov	r4, r1
    d590:	6829      	ldr	r1, [r5, #0]
    d592:	3118      	adds	r1, #24
    d594:	f7fe fee0 	bl	c358 <vListInsert>


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    d598:	4b1a      	ldr	r3, [pc, #104]	; (d604 <vTaskPlaceOnEventList+0x7c>)
    d59a:	681e      	ldr	r6, [r3, #0]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    d59c:	6828      	ldr	r0, [r5, #0]
    d59e:	3004      	adds	r0, #4
    d5a0:	f7fe fef4 	bl	c38c <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    d5a4:	1c63      	adds	r3, r4, #1
    d5a6:	d015      	beq.n	d5d4 <vTaskPlaceOnEventList+0x4c>
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    d5a8:	682b      	ldr	r3, [r5, #0]

			if( xTimeToWake < xConstTickCount )
			{
			  //GEO: addition for support of SystemView Profiler
			  traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
    d5aa:	6828      	ldr	r0, [r5, #0]
    d5ac:	19a4      	adds	r4, r4, r6
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    d5ae:	605c      	str	r4, [r3, #4]
			  traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
    d5b0:	f04f 0104 	mov.w	r1, #4
			if( xTimeToWake < xConstTickCount )
    d5b4:	d219      	bcs.n	d5ea <vTaskPlaceOnEventList+0x62>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
			}
			else
			{
			  //GEO: addition for support of SystemView Profiler
			  traceMOVED_TASK_TO_DELAYED_LIST();
    d5b6:	f003 fcd7 	bl	10f68 <SEGGER_SYSVIEW_OnTaskStopReady>
                          //GEO: end addition
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    d5ba:	4b13      	ldr	r3, [pc, #76]	; (d608 <vTaskPlaceOnEventList+0x80>)
    d5bc:	6818      	ldr	r0, [r3, #0]
    d5be:	6829      	ldr	r1, [r5, #0]
    d5c0:	3104      	adds	r1, #4
    d5c2:	f7fe fec9 	bl	c358 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    d5c6:	4b11      	ldr	r3, [pc, #68]	; (d60c <vTaskPlaceOnEventList+0x84>)
    d5c8:	681a      	ldr	r2, [r3, #0]
    d5ca:	4294      	cmp	r4, r2
				{
					xNextTaskUnblockTime = xTimeToWake;
    d5cc:	bf38      	it	cc
    d5ce:	601c      	strcc	r4, [r3, #0]
}
    d5d0:	bd70      	pop	{r4, r5, r6, pc}
    d5d2:	e7fe      	b.n	d5d2 <vTaskPlaceOnEventList+0x4a>
		  traceMOVED_TASK_TO_SUSPENDED_LIST(pxCurrentTCB);
    d5d4:	6828      	ldr	r0, [r5, #0]
    d5d6:	211b      	movs	r1, #27
    d5d8:	f003 fcc6 	bl	10f68 <SEGGER_SYSVIEW_OnTaskStopReady>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    d5dc:	6829      	ldr	r1, [r5, #0]
    d5de:	480c      	ldr	r0, [pc, #48]	; (d610 <vTaskPlaceOnEventList+0x88>)
    d5e0:	3104      	adds	r1, #4
}
    d5e2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    d5e6:	f7fe bea7 	b.w	c338 <vListInsertEnd>
			  traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
    d5ea:	f003 fcbd 	bl	10f68 <SEGGER_SYSVIEW_OnTaskStopReady>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    d5ee:	4b09      	ldr	r3, [pc, #36]	; (d614 <vTaskPlaceOnEventList+0x8c>)
    d5f0:	6818      	ldr	r0, [r3, #0]
    d5f2:	6829      	ldr	r1, [r5, #0]
}
    d5f4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    d5f8:	3104      	adds	r1, #4
    d5fa:	f7fe bead 	b.w	c358 <vListInsert>
    d5fe:	bf00      	nop
    d600:	10002b90 	.word	0x10002b90
    d604:	10002c9c 	.word	0x10002c9c
    d608:	10002b94 	.word	0x10002b94
    d60c:	10002c68 	.word	0x10002c68
    d610:	10002c88 	.word	0x10002c88
    d614:	10002b98 	.word	0x10002b98

0000d618 <vTaskPlaceOnEventListRestricted>:
		configASSERT( pxEventList );
    d618:	b1e0      	cbz	r0, d654 <vTaskPlaceOnEventListRestricted+0x3c>
	{
    d61a:	b570      	push	{r4, r5, r6, lr}
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    d61c:	4c21      	ldr	r4, [pc, #132]	; (d6a4 <vTaskPlaceOnEventListRestricted+0x8c>)
    d61e:	460d      	mov	r5, r1
    d620:	6821      	ldr	r1, [r4, #0]
    d622:	4616      	mov	r6, r2
    d624:	3118      	adds	r1, #24
    d626:	f7fe fe87 	bl	c338 <vListInsertEnd>
		traceTASK_DELAY_UNTIL();
    d62a:	2024      	movs	r0, #36	; 0x24
		if( xWaitIndefinitely != pdFALSE )
    d62c:	b19e      	cbz	r6, d656 <vTaskPlaceOnEventListRestricted+0x3e>
		traceTASK_DELAY_UNTIL();
    d62e:	f004 f835 	bl	1169c <SEGGER_SYSVIEW_RecordVoid>
const TickType_t xConstTickCount = xTickCount;
    d632:	4b1d      	ldr	r3, [pc, #116]	; (d6a8 <vTaskPlaceOnEventListRestricted+0x90>)
    d634:	681b      	ldr	r3, [r3, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    d636:	6820      	ldr	r0, [r4, #0]
    d638:	3004      	adds	r0, #4
    d63a:	f7fe fea7 	bl	c38c <uxListRemove>
		  traceMOVED_TASK_TO_SUSPENDED_LIST(pxCurrentTCB);
    d63e:	6820      	ldr	r0, [r4, #0]
    d640:	211b      	movs	r1, #27
    d642:	f003 fc91 	bl	10f68 <SEGGER_SYSVIEW_OnTaskStopReady>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    d646:	6821      	ldr	r1, [r4, #0]
    d648:	4818      	ldr	r0, [pc, #96]	; (d6ac <vTaskPlaceOnEventListRestricted+0x94>)
    d64a:	3104      	adds	r1, #4
	}
    d64c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    d650:	f7fe be72 	b.w	c338 <vListInsertEnd>
    d654:	e7fe      	b.n	d654 <vTaskPlaceOnEventListRestricted+0x3c>
		traceTASK_DELAY_UNTIL();
    d656:	f004 f821 	bl	1169c <SEGGER_SYSVIEW_RecordVoid>
const TickType_t xConstTickCount = xTickCount;
    d65a:	4b13      	ldr	r3, [pc, #76]	; (d6a8 <vTaskPlaceOnEventListRestricted+0x90>)
    d65c:	681e      	ldr	r6, [r3, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    d65e:	6820      	ldr	r0, [r4, #0]
    d660:	3004      	adds	r0, #4
    d662:	f7fe fe93 	bl	c38c <uxListRemove>
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    d666:	6823      	ldr	r3, [r4, #0]
			  traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
    d668:	6820      	ldr	r0, [r4, #0]
    d66a:	19ad      	adds	r5, r5, r6
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    d66c:	605d      	str	r5, [r3, #4]
			  traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
    d66e:	f04f 0104 	mov.w	r1, #4
			if( xTimeToWake < xConstTickCount )
    d672:	d20d      	bcs.n	d690 <vTaskPlaceOnEventListRestricted+0x78>
			  traceMOVED_TASK_TO_DELAYED_LIST();
    d674:	f003 fc78 	bl	10f68 <SEGGER_SYSVIEW_OnTaskStopReady>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    d678:	4b0d      	ldr	r3, [pc, #52]	; (d6b0 <vTaskPlaceOnEventListRestricted+0x98>)
    d67a:	6818      	ldr	r0, [r3, #0]
    d67c:	6821      	ldr	r1, [r4, #0]
    d67e:	3104      	adds	r1, #4
    d680:	f7fe fe6a 	bl	c358 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
    d684:	4b0b      	ldr	r3, [pc, #44]	; (d6b4 <vTaskPlaceOnEventListRestricted+0x9c>)
    d686:	681a      	ldr	r2, [r3, #0]
    d688:	4295      	cmp	r5, r2
					xNextTaskUnblockTime = xTimeToWake;
    d68a:	bf38      	it	cc
    d68c:	601d      	strcc	r5, [r3, #0]
	}
    d68e:	bd70      	pop	{r4, r5, r6, pc}
			  traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
    d690:	f003 fc6a 	bl	10f68 <SEGGER_SYSVIEW_OnTaskStopReady>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    d694:	4b08      	ldr	r3, [pc, #32]	; (d6b8 <vTaskPlaceOnEventListRestricted+0xa0>)
    d696:	6818      	ldr	r0, [r3, #0]
    d698:	6821      	ldr	r1, [r4, #0]
	}
    d69a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    d69e:	3104      	adds	r1, #4
    d6a0:	f7fe be5a 	b.w	c358 <vListInsert>
    d6a4:	10002b90 	.word	0x10002b90
    d6a8:	10002c9c 	.word	0x10002c9c
    d6ac:	10002c88 	.word	0x10002c88
    d6b0:	10002b94 	.word	0x10002b94
    d6b4:	10002c68 	.word	0x10002c68
    d6b8:	10002b98 	.word	0x10002b98

0000d6bc <xTaskRemoveFromEventList>:
{
    d6bc:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    d6be:	68c3      	ldr	r3, [r0, #12]
    d6c0:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
    d6c2:	2c00      	cmp	r4, #0
    d6c4:	d030      	beq.n	d728 <xTaskRemoveFromEventList+0x6c>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    d6c6:	f104 0518 	add.w	r5, r4, #24
    d6ca:	4628      	mov	r0, r5
    d6cc:	f7fe fe5e 	bl	c38c <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    d6d0:	4b1a      	ldr	r3, [pc, #104]	; (d73c <xTaskRemoveFromEventList+0x80>)
    d6d2:	681b      	ldr	r3, [r3, #0]
    d6d4:	bb4b      	cbnz	r3, d72a <xTaskRemoveFromEventList+0x6e>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    d6d6:	1d25      	adds	r5, r4, #4
    d6d8:	4628      	mov	r0, r5
    d6da:	f7fe fe57 	bl	c38c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    d6de:	4620      	mov	r0, r4
    d6e0:	f003 fba8 	bl	10e34 <SEGGER_SYSVIEW_OnTaskStartReady>
    d6e4:	4a16      	ldr	r2, [pc, #88]	; (d740 <xTaskRemoveFromEventList+0x84>)
    d6e6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    d6e8:	6811      	ldr	r1, [r2, #0]
    d6ea:	4816      	ldr	r0, [pc, #88]	; (d744 <xTaskRemoveFromEventList+0x88>)
    d6ec:	428b      	cmp	r3, r1
    d6ee:	bf88      	it	hi
    d6f0:	6013      	strhi	r3, [r2, #0]
    d6f2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    d6f6:	4629      	mov	r1, r5
    d6f8:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    d6fc:	f7fe fe1c 	bl	c338 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    d700:	4b11      	ldr	r3, [pc, #68]	; (d748 <xTaskRemoveFromEventList+0x8c>)
    d702:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    d704:	681b      	ldr	r3, [r3, #0]
    d706:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    d708:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
    d70a:	bf82      	ittt	hi
    d70c:	4b0f      	ldrhi	r3, [pc, #60]	; (d74c <xTaskRemoveFromEventList+0x90>)
    d70e:	2001      	movhi	r0, #1
    d710:	6018      	strhi	r0, [r3, #0]
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    d712:	4b0f      	ldr	r3, [pc, #60]	; (d750 <xTaskRemoveFromEventList+0x94>)
    d714:	681b      	ldr	r3, [r3, #0]
    d716:	681b      	ldr	r3, [r3, #0]
		xReturn = pdFALSE;
    d718:	bf98      	it	ls
    d71a:	2000      	movls	r0, #0
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    d71c:	b953      	cbnz	r3, d734 <xTaskRemoveFromEventList+0x78>
		xNextTaskUnblockTime = portMAX_DELAY;
    d71e:	4b0d      	ldr	r3, [pc, #52]	; (d754 <xTaskRemoveFromEventList+0x98>)
    d720:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    d724:	601a      	str	r2, [r3, #0]
}
    d726:	bd38      	pop	{r3, r4, r5, pc}
    d728:	e7fe      	b.n	d728 <xTaskRemoveFromEventList+0x6c>
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    d72a:	4629      	mov	r1, r5
    d72c:	480a      	ldr	r0, [pc, #40]	; (d758 <xTaskRemoveFromEventList+0x9c>)
    d72e:	f7fe fe03 	bl	c338 <vListInsertEnd>
    d732:	e7e5      	b.n	d700 <xTaskRemoveFromEventList+0x44>
    d734:	f7ff fac6 	bl	ccc4 <prvResetNextTaskUnblockTime.part.2>
}
    d738:	bd38      	pop	{r3, r4, r5, pc}
    d73a:	bf00      	nop
    d73c:	10002c30 	.word	0x10002c30
    d740:	10002c38 	.word	0x10002c38
    d744:	10002b9c 	.word	0x10002b9c
    d748:	10002b90 	.word	0x10002b90
    d74c:	10002ca0 	.word	0x10002ca0
    d750:	10002b94 	.word	0x10002b94
    d754:	10002c68 	.word	0x10002c68
    d758:	10002c70 	.word	0x10002c70

0000d75c <vTaskSetTimeOutState>:
	configASSERT( pxTimeOut );
    d75c:	b130      	cbz	r0, d76c <vTaskSetTimeOutState+0x10>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    d75e:	4a04      	ldr	r2, [pc, #16]	; (d770 <vTaskSetTimeOutState+0x14>)
	pxTimeOut->xTimeOnEntering = xTickCount;
    d760:	4b04      	ldr	r3, [pc, #16]	; (d774 <vTaskSetTimeOutState+0x18>)
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    d762:	6812      	ldr	r2, [r2, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    d764:	681b      	ldr	r3, [r3, #0]
    d766:	e9c0 2300 	strd	r2, r3, [r0]
}
    d76a:	4770      	bx	lr
    d76c:	e7fe      	b.n	d76c <vTaskSetTimeOutState+0x10>
    d76e:	bf00      	nop
    d770:	10002c6c 	.word	0x10002c6c
    d774:	10002c9c 	.word	0x10002c9c

0000d778 <xTaskCheckForTimeOut>:
	configASSERT( pxTimeOut );
    d778:	b328      	cbz	r0, d7c6 <xTaskCheckForTimeOut+0x4e>
	configASSERT( pxTicksToWait );
    d77a:	b319      	cbz	r1, d7c4 <xTaskCheckForTimeOut+0x4c>
{
    d77c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    d77e:	460d      	mov	r5, r1
    d780:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
    d782:	f000 fba7 	bl	ded4 <vPortEnterCritical>
			if( *pxTicksToWait == portMAX_DELAY )
    d786:	682b      	ldr	r3, [r5, #0]
		const TickType_t xConstTickCount = xTickCount;
    d788:	f8df c048 	ldr.w	ip, [pc, #72]	; d7d4 <xTaskCheckForTimeOut+0x5c>
			if( *pxTicksToWait == portMAX_DELAY )
    d78c:	1c5a      	adds	r2, r3, #1
		const TickType_t xConstTickCount = xTickCount;
    d78e:	f8dc 1000 	ldr.w	r1, [ip]
			if( *pxTicksToWait == portMAX_DELAY )
    d792:	d019      	beq.n	d7c8 <xTaskCheckForTimeOut+0x50>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    d794:	4e0e      	ldr	r6, [pc, #56]	; (d7d0 <xTaskCheckForTimeOut+0x58>)
    d796:	e9d4 0200 	ldrd	r0, r2, [r4]
    d79a:	6837      	ldr	r7, [r6, #0]
    d79c:	42b8      	cmp	r0, r7
    d79e:	d001      	beq.n	d7a4 <xTaskCheckForTimeOut+0x2c>
    d7a0:	4291      	cmp	r1, r2
    d7a2:	d213      	bcs.n	d7cc <xTaskCheckForTimeOut+0x54>
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    d7a4:	1a8f      	subs	r7, r1, r2
    d7a6:	42bb      	cmp	r3, r7
    d7a8:	d910      	bls.n	d7cc <xTaskCheckForTimeOut+0x54>
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    d7aa:	1a5b      	subs	r3, r3, r1
    d7ac:	4413      	add	r3, r2
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    d7ae:	6831      	ldr	r1, [r6, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    d7b0:	f8dc 2000 	ldr.w	r2, [ip]
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    d7b4:	602b      	str	r3, [r5, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    d7b6:	e9c4 1200 	strd	r1, r2, [r4]
			xReturn = pdFALSE;
    d7ba:	2500      	movs	r5, #0
	taskEXIT_CRITICAL();
    d7bc:	f000 fba4 	bl	df08 <vPortExitCritical>
}
    d7c0:	4628      	mov	r0, r5
    d7c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    d7c4:	e7fe      	b.n	d7c4 <xTaskCheckForTimeOut+0x4c>
    d7c6:	e7fe      	b.n	d7c6 <xTaskCheckForTimeOut+0x4e>
				xReturn = pdFALSE;
    d7c8:	2500      	movs	r5, #0
    d7ca:	e7f7      	b.n	d7bc <xTaskCheckForTimeOut+0x44>
			xReturn = pdTRUE;
    d7cc:	2501      	movs	r5, #1
    d7ce:	e7f5      	b.n	d7bc <xTaskCheckForTimeOut+0x44>
    d7d0:	10002c6c 	.word	0x10002c6c
    d7d4:	10002c9c 	.word	0x10002c9c

0000d7d8 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
    d7d8:	4b01      	ldr	r3, [pc, #4]	; (d7e0 <vTaskMissedYield+0x8>)
    d7da:	2201      	movs	r2, #1
    d7dc:	601a      	str	r2, [r3, #0]
}
    d7de:	4770      	bx	lr
    d7e0:	10002ca0 	.word	0x10002ca0

0000d7e4 <eTaskConfirmSleepModeStatus>:
		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
    d7e4:	4b08      	ldr	r3, [pc, #32]	; (d808 <eTaskConfirmSleepModeStatus+0x24>)
    d7e6:	6818      	ldr	r0, [r3, #0]
    d7e8:	b960      	cbnz	r0, d804 <eTaskConfirmSleepModeStatus+0x20>
		else if( xYieldPending != pdFALSE )
    d7ea:	4b08      	ldr	r3, [pc, #32]	; (d80c <eTaskConfirmSleepModeStatus+0x28>)
    d7ec:	681b      	ldr	r3, [r3, #0]
    d7ee:	b953      	cbnz	r3, d806 <eTaskConfirmSleepModeStatus+0x22>
			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
    d7f0:	4b07      	ldr	r3, [pc, #28]	; (d810 <eTaskConfirmSleepModeStatus+0x2c>)
    d7f2:	4a08      	ldr	r2, [pc, #32]	; (d814 <eTaskConfirmSleepModeStatus+0x30>)
    d7f4:	681b      	ldr	r3, [r3, #0]
    d7f6:	6810      	ldr	r0, [r2, #0]
    d7f8:	3b01      	subs	r3, #1
				eReturn = eNoTasksWaitingTimeout;
    d7fa:	4298      	cmp	r0, r3
    d7fc:	bf14      	ite	ne
    d7fe:	2001      	movne	r0, #1
    d800:	2002      	moveq	r0, #2
    d802:	4770      	bx	lr
			eReturn = eAbortSleep;
    d804:	2000      	movs	r0, #0
	}
    d806:	4770      	bx	lr
    d808:	10002c70 	.word	0x10002c70
    d80c:	10002ca0 	.word	0x10002ca0
    d810:	10002c28 	.word	0x10002c28
    d814:	10002c88 	.word	0x10002c88

0000d818 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
    d818:	4b05      	ldr	r3, [pc, #20]	; (d830 <xTaskGetSchedulerState+0x18>)
    d81a:	681b      	ldr	r3, [r3, #0]
    d81c:	b133      	cbz	r3, d82c <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    d81e:	4b05      	ldr	r3, [pc, #20]	; (d834 <xTaskGetSchedulerState+0x1c>)
    d820:	681b      	ldr	r3, [r3, #0]
    d822:	2b00      	cmp	r3, #0
				xReturn = taskSCHEDULER_SUSPENDED;
    d824:	bf0c      	ite	eq
    d826:	2002      	moveq	r0, #2
    d828:	2000      	movne	r0, #0
    d82a:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
    d82c:	2001      	movs	r0, #1
	}
    d82e:	4770      	bx	lr
    d830:	10002c84 	.word	0x10002c84
    d834:	10002c30 	.word	0x10002c30

0000d838 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    d838:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d83c:	4eae      	ldr	r6, [pc, #696]	; (daf8 <prvTimerTask+0x2c0>)
    d83e:	f8df 82c4 	ldr.w	r8, [pc, #708]	; db04 <prvTimerTask+0x2cc>
    d842:	4dae      	ldr	r5, [pc, #696]	; (dafc <prvTimerTask+0x2c4>)
    d844:	f8df a2c0 	ldr.w	sl, [pc, #704]	; db08 <prvTimerTask+0x2d0>
    d848:	b08b      	sub	sp, #44	; 0x2c
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    d84a:	6833      	ldr	r3, [r6, #0]
	if( *pxListWasEmpty == pdFALSE )
    d84c:	681c      	ldr	r4, [r3, #0]
    d84e:	2c00      	cmp	r4, #0
    d850:	f000 808c 	beq.w	d96c <prvTimerTask+0x134>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    d854:	68db      	ldr	r3, [r3, #12]
    d856:	681c      	ldr	r4, [r3, #0]
	vTaskSuspendAll();
    d858:	f7ff fc68 	bl	d12c <vTaskSuspendAll>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    d85c:	f7ff fc6e 	bl	d13c <xTaskGetTickCount>

	if( xTimeNow < xLastTime )
    d860:	f8d8 3000 	ldr.w	r3, [r8]
    d864:	4283      	cmp	r3, r0
	xTimeNow = xTaskGetTickCount();
    d866:	4607      	mov	r7, r0
	if( xTimeNow < xLastTime )
    d868:	d859      	bhi.n	d91e <prvTimerTask+0xe6>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    d86a:	4284      	cmp	r4, r0
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
	}

	xLastTime = xTimeNow;
    d86c:	f8c8 0000 	str.w	r0, [r8]
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    d870:	f240 80bc 	bls.w	d9ec <prvTimerTask+0x1b4>
    d874:	2200      	movs	r2, #0
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    d876:	1be1      	subs	r1, r4, r7
    d878:	6828      	ldr	r0, [r5, #0]
    d87a:	f7ff f9bd 	bl	cbf8 <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
    d87e:	f7ff fd1d 	bl	d2bc <xTaskResumeAll>
    d882:	b938      	cbnz	r0, d894 <prvTimerTask+0x5c>
					portYIELD_WITHIN_API();
    d884:	4a9e      	ldr	r2, [pc, #632]	; (db00 <prvTimerTask+0x2c8>)
    d886:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    d88a:	6013      	str	r3, [r2, #0]
    d88c:	f3bf 8f4f 	dsb	sy
    d890:	f3bf 8f6f 	isb	sy
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    d894:	2300      	movs	r3, #0
    d896:	461a      	mov	r2, r3
    d898:	a902      	add	r1, sp, #8
    d89a:	6828      	ldr	r0, [r5, #0]
    d89c:	f7ff f80e 	bl	c8bc <xQueueGenericReceive>
    d8a0:	2800      	cmp	r0, #0
    d8a2:	d0d2      	beq.n	d84a <prvTimerTask+0x12>
	{
		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
		{
			/* Negative commands are pended function calls rather than timer
			commands. */
			if( xMessage.xMessageID < ( BaseType_t ) 0 )
    d8a4:	9b02      	ldr	r3, [sp, #8]
    d8a6:	9c04      	ldr	r4, [sp, #16]
    d8a8:	2b00      	cmp	r3, #0
    d8aa:	da07      	bge.n	d8bc <prvTimerTask+0x84>
				/* The timer uses the xCallbackParameters member to request a
				callback be executed.  Check the callback is not NULL. */
				configASSERT( pxCallback );

				/* Call the function. */
				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
    d8ac:	9b03      	ldr	r3, [sp, #12]
    d8ae:	9905      	ldr	r1, [sp, #20]
    d8b0:	4620      	mov	r0, r4
    d8b2:	4798      	blx	r3
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    d8b4:	9b02      	ldr	r3, [sp, #8]
    d8b6:	2b00      	cmp	r3, #0
    d8b8:	dbec      	blt.n	d894 <prvTimerTask+0x5c>
    d8ba:	9c04      	ldr	r4, [sp, #16]
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    d8bc:	6963      	ldr	r3, [r4, #20]
    d8be:	b113      	cbz	r3, d8c6 <prvTimerTask+0x8e>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    d8c0:	1d20      	adds	r0, r4, #4
    d8c2:	f7fe fd63 	bl	c38c <uxListRemove>
	xTimeNow = xTaskGetTickCount();
    d8c6:	f7ff fc39 	bl	d13c <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
    d8ca:	f8d8 3000 	ldr.w	r3, [r8]
    d8ce:	4298      	cmp	r0, r3
	xTimeNow = xTaskGetTickCount();
    d8d0:	4681      	mov	r9, r0
	if( xTimeNow < xLastTime )
    d8d2:	d341      	bcc.n	d958 <prvTimerTask+0x120>
    d8d4:	9b02      	ldr	r3, [sp, #8]
	xLastTime = xTimeNow;
    d8d6:	f8c8 9000 	str.w	r9, [r8]
    d8da:	2b09      	cmp	r3, #9
    d8dc:	d8da      	bhi.n	d894 <prvTimerTask+0x5c>
    d8de:	2201      	movs	r2, #1
    d8e0:	fa02 f303 	lsl.w	r3, r2, r3
    d8e4:	f413 7f04 	tst.w	r3, #528	; 0x210
    d8e8:	f040 80f3 	bne.w	dad2 <prvTimerTask+0x29a>
    d8ec:	f013 0fc7 	tst.w	r3, #199	; 0xc7
    d8f0:	f040 80c5 	bne.w	da7e <prvTimerTask+0x246>
    d8f4:	069b      	lsls	r3, r3, #26
    d8f6:	d5cd      	bpl.n	d894 <prvTimerTask+0x5c>
					allocated. */
					#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
					{
						/* The timer can only have been allocated dynamically -
						free it again. */
						vPortFree( pxTimer );
    d8f8:	4620      	mov	r0, r4
    d8fa:	f000 fa6f 	bl	dddc <vPortFree>
    d8fe:	e7c9      	b.n	d894 <prvTimerTask+0x5c>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    d900:	68db      	ldr	r3, [r3, #12]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    d902:	68dc      	ldr	r4, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    d904:	f8d3 b000 	ldr.w	fp, [r3]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    d908:	f104 0904 	add.w	r9, r4, #4
    d90c:	4648      	mov	r0, r9
    d90e:	f7fe fd3d 	bl	c38c <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    d912:	6a63      	ldr	r3, [r4, #36]	; 0x24
    d914:	4620      	mov	r0, r4
    d916:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    d918:	69e3      	ldr	r3, [r4, #28]
    d91a:	2b01      	cmp	r3, #1
    d91c:	d038      	beq.n	d990 <prvTimerTask+0x158>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    d91e:	6833      	ldr	r3, [r6, #0]
    d920:	681a      	ldr	r2, [r3, #0]
    d922:	2a00      	cmp	r2, #0
    d924:	d1ec      	bne.n	d900 <prvTimerTask+0xc8>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    d926:	f8da 2000 	ldr.w	r2, [sl]
	xLastTime = xTimeNow;
    d92a:	f8c8 7000 	str.w	r7, [r8]
	pxCurrentTimerList = pxOverflowTimerList;
    d92e:	6032      	str	r2, [r6, #0]
	pxOverflowTimerList = pxTemp;
    d930:	f8ca 3000 	str.w	r3, [sl]
			( void ) xTaskResumeAll();
    d934:	f7ff fcc2 	bl	d2bc <xTaskResumeAll>
    d938:	e7ac      	b.n	d894 <prvTimerTask+0x5c>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    d93a:	68db      	ldr	r3, [r3, #12]
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    d93c:	68df      	ldr	r7, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    d93e:	681b      	ldr	r3, [r3, #0]
    d940:	9301      	str	r3, [sp, #4]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    d942:	f107 0b04 	add.w	fp, r7, #4
    d946:	4658      	mov	r0, fp
    d948:	f7fe fd20 	bl	c38c <uxListRemove>
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    d94c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d94e:	4638      	mov	r0, r7
    d950:	4798      	blx	r3
		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    d952:	69fb      	ldr	r3, [r7, #28]
    d954:	2b01      	cmp	r3, #1
    d956:	d031      	beq.n	d9bc <prvTimerTask+0x184>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    d958:	6833      	ldr	r3, [r6, #0]
    d95a:	681a      	ldr	r2, [r3, #0]
    d95c:	2a00      	cmp	r2, #0
    d95e:	d1ec      	bne.n	d93a <prvTimerTask+0x102>
	pxCurrentTimerList = pxOverflowTimerList;
    d960:	f8da 2000 	ldr.w	r2, [sl]
    d964:	6032      	str	r2, [r6, #0]
	pxOverflowTimerList = pxTemp;
    d966:	f8ca 3000 	str.w	r3, [sl]
    d96a:	e7b3      	b.n	d8d4 <prvTimerTask+0x9c>
	vTaskSuspendAll();
    d96c:	f7ff fbde 	bl	d12c <vTaskSuspendAll>
	xTimeNow = xTaskGetTickCount();
    d970:	f7ff fbe4 	bl	d13c <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
    d974:	f8d8 3000 	ldr.w	r3, [r8]
    d978:	4298      	cmp	r0, r3
	xTimeNow = xTaskGetTickCount();
    d97a:	4607      	mov	r7, r0
	if( xTimeNow < xLastTime )
    d97c:	d3cf      	bcc.n	d91e <prvTimerTask+0xe6>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    d97e:	f8da 3000 	ldr.w	r3, [sl]
	xLastTime = xTimeNow;
    d982:	f8c8 7000 	str.w	r7, [r8]
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    d986:	681a      	ldr	r2, [r3, #0]
    d988:	fab2 f282 	clz	r2, r2
    d98c:	0952      	lsrs	r2, r2, #5
    d98e:	e772      	b.n	d876 <prvTimerTask+0x3e>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    d990:	69a3      	ldr	r3, [r4, #24]
    d992:	445b      	add	r3, fp
			if( xReloadTime > xNextExpireTime )
    d994:	459b      	cmp	fp, r3
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    d996:	4649      	mov	r1, r9
			if( xReloadTime > xNextExpireTime )
    d998:	d342      	bcc.n	da20 <prvTimerTask+0x1e8>
	if( xTimerQueue != NULL )
    d99a:	682b      	ldr	r3, [r5, #0]
    d99c:	b16b      	cbz	r3, d9ba <prvTimerTask+0x182>
		xMessage.xMessageID = xCommandID;
    d99e:	2300      	movs	r3, #0
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    d9a0:	e9cd 3b06 	strd	r3, fp, [sp, #24]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    d9a4:	9408      	str	r4, [sp, #32]
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    d9a6:	f7ff ff37 	bl	d818 <xTaskGetSchedulerState>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    d9aa:	2300      	movs	r3, #0
    d9ac:	461a      	mov	r2, r3
    d9ae:	a906      	add	r1, sp, #24
    d9b0:	6828      	ldr	r0, [r5, #0]
    d9b2:	f7fe fd43 	bl	c43c <xQueueGenericSend>
				configASSERT( xResult );
    d9b6:	2800      	cmp	r0, #0
    d9b8:	d1b1      	bne.n	d91e <prvTimerTask+0xe6>
    d9ba:	e7fe      	b.n	d9ba <prvTimerTask+0x182>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    d9bc:	9a01      	ldr	r2, [sp, #4]
    d9be:	69bb      	ldr	r3, [r7, #24]
    d9c0:	4413      	add	r3, r2
			if( xReloadTime > xNextExpireTime )
    d9c2:	429a      	cmp	r2, r3
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    d9c4:	4659      	mov	r1, fp
			if( xReloadTime > xNextExpireTime )
    d9c6:	d325      	bcc.n	da14 <prvTimerTask+0x1dc>
	if( xTimerQueue != NULL )
    d9c8:	682b      	ldr	r3, [r5, #0]
    d9ca:	b173      	cbz	r3, d9ea <prvTimerTask+0x1b2>
		xMessage.xMessageID = xCommandID;
    d9cc:	2300      	movs	r3, #0
    d9ce:	9306      	str	r3, [sp, #24]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    d9d0:	9b01      	ldr	r3, [sp, #4]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    d9d2:	e9cd 3707 	strd	r3, r7, [sp, #28]
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    d9d6:	f7ff ff1f 	bl	d818 <xTaskGetSchedulerState>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    d9da:	2300      	movs	r3, #0
    d9dc:	461a      	mov	r2, r3
    d9de:	a906      	add	r1, sp, #24
    d9e0:	6828      	ldr	r0, [r5, #0]
    d9e2:	f7fe fd2b 	bl	c43c <xQueueGenericSend>
				configASSERT( xResult );
    d9e6:	2800      	cmp	r0, #0
    d9e8:	d1b6      	bne.n	d958 <prvTimerTask+0x120>
    d9ea:	e7fe      	b.n	d9ea <prvTimerTask+0x1b2>
				( void ) xTaskResumeAll();
    d9ec:	f7ff fc66 	bl	d2bc <xTaskResumeAll>
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    d9f0:	6833      	ldr	r3, [r6, #0]
    d9f2:	68db      	ldr	r3, [r3, #12]
    d9f4:	f8d3 900c 	ldr.w	r9, [r3, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    d9f8:	f109 0b04 	add.w	fp, r9, #4
    d9fc:	4658      	mov	r0, fp
    d9fe:	f7fe fcc5 	bl	c38c <uxListRemove>
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    da02:	f8d9 301c 	ldr.w	r3, [r9, #28]
    da06:	2b01      	cmp	r3, #1
    da08:	d010      	beq.n	da2c <prvTimerTask+0x1f4>
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    da0a:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
    da0e:	4648      	mov	r0, r9
    da10:	4798      	blx	r3
    da12:	e73f      	b.n	d894 <prvTimerTask+0x5c>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    da14:	607b      	str	r3, [r7, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    da16:	613f      	str	r7, [r7, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    da18:	6830      	ldr	r0, [r6, #0]
    da1a:	f7fe fc9d 	bl	c358 <vListInsert>
    da1e:	e79b      	b.n	d958 <prvTimerTask+0x120>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    da20:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    da22:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    da24:	6830      	ldr	r0, [r6, #0]
    da26:	f7fe fc97 	bl	c358 <vListInsert>
    da2a:	e778      	b.n	d91e <prvTimerTask+0xe6>
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    da2c:	f8d9 3018 	ldr.w	r3, [r9, #24]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    da30:	f8c9 9010 	str.w	r9, [r9, #16]
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    da34:	18e2      	adds	r2, r4, r3
	if( xNextExpiryTime <= xTimeNow )
    da36:	42ba      	cmp	r2, r7
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    da38:	f8c9 2004 	str.w	r2, [r9, #4]
	if( xNextExpiryTime <= xTimeNow )
    da3c:	d81a      	bhi.n	da74 <prvTimerTask+0x23c>
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    da3e:	1b3f      	subs	r7, r7, r4
    da40:	42bb      	cmp	r3, r7
    da42:	d811      	bhi.n	da68 <prvTimerTask+0x230>
	if( xTimerQueue != NULL )
    da44:	682b      	ldr	r3, [r5, #0]
    da46:	b173      	cbz	r3, da66 <prvTimerTask+0x22e>
		xMessage.xMessageID = xCommandID;
    da48:	2300      	movs	r3, #0
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    da4a:	e9cd 3406 	strd	r3, r4, [sp, #24]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    da4e:	f8cd 9020 	str.w	r9, [sp, #32]
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    da52:	f7ff fee1 	bl	d818 <xTaskGetSchedulerState>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    da56:	2300      	movs	r3, #0
    da58:	461a      	mov	r2, r3
    da5a:	a906      	add	r1, sp, #24
    da5c:	6828      	ldr	r0, [r5, #0]
    da5e:	f7fe fced 	bl	c43c <xQueueGenericSend>
			configASSERT( xResult );
    da62:	2800      	cmp	r0, #0
    da64:	d1d1      	bne.n	da0a <prvTimerTask+0x1d2>
    da66:	e7fe      	b.n	da66 <prvTimerTask+0x22e>
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    da68:	4659      	mov	r1, fp
    da6a:	f8da 0000 	ldr.w	r0, [sl]
    da6e:	f7fe fc73 	bl	c358 <vListInsert>
    da72:	e7ca      	b.n	da0a <prvTimerTask+0x1d2>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    da74:	4659      	mov	r1, fp
    da76:	6830      	ldr	r0, [r6, #0]
    da78:	f7fe fc6e 	bl	c358 <vListInsert>
    da7c:	e7c5      	b.n	da0a <prvTimerTask+0x1d2>
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    da7e:	9b03      	ldr	r3, [sp, #12]
    da80:	69a2      	ldr	r2, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    da82:	6124      	str	r4, [r4, #16]
    da84:	1899      	adds	r1, r3, r2
    da86:	bf2c      	ite	cs
    da88:	2001      	movcs	r0, #1
    da8a:	2000      	movcc	r0, #0
	if( xNextExpiryTime <= xTimeNow )
    da8c:	4549      	cmp	r1, r9
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    da8e:	6061      	str	r1, [r4, #4]
	if( xNextExpiryTime <= xTimeNow )
    da90:	d842      	bhi.n	db18 <prvTimerTask+0x2e0>
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    da92:	eba9 0303 	sub.w	r3, r9, r3
    da96:	429a      	cmp	r2, r3
    da98:	d838      	bhi.n	db0c <prvTimerTask+0x2d4>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    da9a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    da9c:	4620      	mov	r0, r4
    da9e:	4798      	blx	r3
						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    daa0:	69e3      	ldr	r3, [r4, #28]
    daa2:	2b01      	cmp	r3, #1
    daa4:	f47f aef6 	bne.w	d894 <prvTimerTask+0x5c>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    daa8:	9b03      	ldr	r3, [sp, #12]
    daaa:	69a1      	ldr	r1, [r4, #24]
	if( xTimerQueue != NULL )
    daac:	682a      	ldr	r2, [r5, #0]
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    daae:	440b      	add	r3, r1
	if( xTimerQueue != NULL )
    dab0:	b302      	cbz	r2, daf4 <prvTimerTask+0x2bc>
		xMessage.xMessageID = xCommandID;
    dab2:	2200      	movs	r2, #0
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    dab4:	e9cd 2306 	strd	r2, r3, [sp, #24]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    dab8:	9408      	str	r4, [sp, #32]
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    daba:	f7ff fead 	bl	d818 <xTaskGetSchedulerState>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    dabe:	2300      	movs	r3, #0
    dac0:	461a      	mov	r2, r3
    dac2:	a906      	add	r1, sp, #24
    dac4:	6828      	ldr	r0, [r5, #0]
    dac6:	f7fe fcb9 	bl	c43c <xQueueGenericSend>
							configASSERT( xResult );
    daca:	2800      	cmp	r0, #0
    dacc:	f47f aee2 	bne.w	d894 <prvTimerTask+0x5c>
    dad0:	e7fe      	b.n	dad0 <prvTimerTask+0x298>
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    dad2:	9b03      	ldr	r3, [sp, #12]
    dad4:	61a3      	str	r3, [r4, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    dad6:	b163      	cbz	r3, daf2 <prvTimerTask+0x2ba>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    dad8:	444b      	add	r3, r9
	if( xNextExpiryTime <= xTimeNow )
    dada:	454b      	cmp	r3, r9
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    dadc:	6063      	str	r3, [r4, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    dade:	6124      	str	r4, [r4, #16]
    dae0:	f104 0104 	add.w	r1, r4, #4
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    dae4:	bf94      	ite	ls
    dae6:	f8da 0000 	ldrls.w	r0, [sl]
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    daea:	6830      	ldrhi	r0, [r6, #0]
    daec:	f7fe fc34 	bl	c358 <vListInsert>
    daf0:	e6d0      	b.n	d894 <prvTimerTask+0x5c>
    daf2:	e7fe      	b.n	daf2 <prvTimerTask+0x2ba>
    daf4:	e7ec      	b.n	dad0 <prvTimerTask+0x298>
    daf6:	bf00      	nop
    daf8:	10002ca4 	.word	0x10002ca4
    dafc:	10002cd8 	.word	0x10002cd8
    db00:	e000ed04 	.word	0xe000ed04
    db04:	10002cd4 	.word	0x10002cd4
    db08:	10002ca8 	.word	0x10002ca8
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    db0c:	1d21      	adds	r1, r4, #4
    db0e:	f8da 0000 	ldr.w	r0, [sl]
    db12:	f7fe fc21 	bl	c358 <vListInsert>
    db16:	e6bd      	b.n	d894 <prvTimerTask+0x5c>
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    db18:	454b      	cmp	r3, r9
    db1a:	d901      	bls.n	db20 <prvTimerTask+0x2e8>
    db1c:	2800      	cmp	r0, #0
    db1e:	d0bc      	beq.n	da9a <prvTimerTask+0x262>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    db20:	1d21      	adds	r1, r4, #4
    db22:	6830      	ldr	r0, [r6, #0]
    db24:	f7fe fc18 	bl	c358 <vListInsert>
    db28:	e6b4      	b.n	d894 <prvTimerTask+0x5c>
    db2a:	bf00      	nop

0000db2c <xTimerCreateTimerTask>:
{
    db2c:	b5f0      	push	{r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
    db2e:	4c16      	ldr	r4, [pc, #88]	; (db88 <xTimerCreateTimerTask+0x5c>)
{
    db30:	b083      	sub	sp, #12
	taskENTER_CRITICAL();
    db32:	f000 f9cf 	bl	ded4 <vPortEnterCritical>
		if( xTimerQueue == NULL )
    db36:	6826      	ldr	r6, [r4, #0]
    db38:	b186      	cbz	r6, db5c <xTimerCreateTimerTask+0x30>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    db3a:	f000 f9e5 	bl	df08 <vPortExitCritical>
	if( xTimerQueue != NULL )
    db3e:	6823      	ldr	r3, [r4, #0]
    db40:	b15b      	cbz	r3, db5a <xTimerCreateTimerTask+0x2e>
			xReturn = xTaskCreate(	prvTimerTask,
    db42:	4b12      	ldr	r3, [pc, #72]	; (db8c <xTimerCreateTimerTask+0x60>)
    db44:	9301      	str	r3, [sp, #4]
    db46:	2303      	movs	r3, #3
    db48:	9300      	str	r3, [sp, #0]
    db4a:	f44f 7280 	mov.w	r2, #256	; 0x100
    db4e:	2300      	movs	r3, #0
    db50:	490f      	ldr	r1, [pc, #60]	; (db90 <xTimerCreateTimerTask+0x64>)
    db52:	4810      	ldr	r0, [pc, #64]	; (db94 <xTimerCreateTimerTask+0x68>)
    db54:	f7ff f8c2 	bl	ccdc <xTaskCreate>
	configASSERT( xReturn );
    db58:	b998      	cbnz	r0, db82 <xTimerCreateTimerTask+0x56>
    db5a:	e7fe      	b.n	db5a <xTimerCreateTimerTask+0x2e>
			vListInitialise( &xActiveTimerList1 );
    db5c:	4f0e      	ldr	r7, [pc, #56]	; (db98 <xTimerCreateTimerTask+0x6c>)
			vListInitialise( &xActiveTimerList2 );
    db5e:	4d0f      	ldr	r5, [pc, #60]	; (db9c <xTimerCreateTimerTask+0x70>)
			vListInitialise( &xActiveTimerList1 );
    db60:	4638      	mov	r0, r7
    db62:	f7fe fbd9 	bl	c318 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
    db66:	4628      	mov	r0, r5
    db68:	f7fe fbd6 	bl	c318 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
    db6c:	4a0c      	ldr	r2, [pc, #48]	; (dba0 <xTimerCreateTimerTask+0x74>)
			pxOverflowTimerList = &xActiveTimerList2;
    db6e:	4b0d      	ldr	r3, [pc, #52]	; (dba4 <xTimerCreateTimerTask+0x78>)
			pxCurrentTimerList = &xActiveTimerList1;
    db70:	6017      	str	r7, [r2, #0]
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    db72:	2110      	movs	r1, #16
    db74:	4632      	mov	r2, r6
    db76:	200a      	movs	r0, #10
			pxOverflowTimerList = &xActiveTimerList2;
    db78:	601d      	str	r5, [r3, #0]
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    db7a:	f7fe fc1b 	bl	c3b4 <xQueueGenericCreate>
    db7e:	6020      	str	r0, [r4, #0]
    db80:	e7db      	b.n	db3a <xTimerCreateTimerTask+0xe>
}
    db82:	b003      	add	sp, #12
    db84:	bdf0      	pop	{r4, r5, r6, r7, pc}
    db86:	bf00      	nop
    db88:	10002cd8 	.word	0x10002cd8
    db8c:	10002cdc 	.word	0x10002cdc
    db90:	0001355c 	.word	0x0001355c
    db94:	0000d839 	.word	0x0000d839
    db98:	10002cac 	.word	0x10002cac
    db9c:	10002cc0 	.word	0x10002cc0
    dba0:	10002ca4 	.word	0x10002ca4
    dba4:	10002ca8 	.word	0x10002ca8

0000dba8 <xTimerCreate>:
	{
    dba8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    dbac:	4683      	mov	fp, r0
    dbae:	b083      	sub	sp, #12
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
    dbb0:	2028      	movs	r0, #40	; 0x28
	{
    dbb2:	460d      	mov	r5, r1
    dbb4:	4692      	mov	sl, r2
    dbb6:	461f      	mov	r7, r3
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
    dbb8:	f000 f890 	bl	dcdc <pvPortMalloc>
		if( pxNewTimer != NULL )
    dbbc:	4604      	mov	r4, r0
    dbbe:	b360      	cbz	r0, dc1a <xTimerCreate+0x72>
	configASSERT( ( xTimerPeriodInTicks > 0 ) );
    dbc0:	b905      	cbnz	r5, dbc4 <xTimerCreate+0x1c>
    dbc2:	e7fe      	b.n	dbc2 <xTimerCreate+0x1a>
		if( xTimerQueue == NULL )
    dbc4:	4e17      	ldr	r6, [pc, #92]	; (dc24 <xTimerCreate+0x7c>)
	taskENTER_CRITICAL();
    dbc6:	f000 f985 	bl	ded4 <vPortEnterCritical>
		if( xTimerQueue == NULL )
    dbca:	f8d6 9000 	ldr.w	r9, [r6]
    dbce:	f1b9 0f00 	cmp.w	r9, #0
    dbd2:	d116      	bne.n	dc02 <xTimerCreate+0x5a>
			vListInitialise( &xActiveTimerList1 );
    dbd4:	4b14      	ldr	r3, [pc, #80]	; (dc28 <xTimerCreate+0x80>)
			vListInitialise( &xActiveTimerList2 );
    dbd6:	f8df 8058 	ldr.w	r8, [pc, #88]	; dc30 <xTimerCreate+0x88>
			vListInitialise( &xActiveTimerList1 );
    dbda:	9301      	str	r3, [sp, #4]
    dbdc:	4618      	mov	r0, r3
    dbde:	f7fe fb9b 	bl	c318 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
    dbe2:	4640      	mov	r0, r8
    dbe4:	f7fe fb98 	bl	c318 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
    dbe8:	4910      	ldr	r1, [pc, #64]	; (dc2c <xTimerCreate+0x84>)
			pxOverflowTimerList = &xActiveTimerList2;
    dbea:	f8df c048 	ldr.w	ip, [pc, #72]	; dc34 <xTimerCreate+0x8c>
			pxCurrentTimerList = &xActiveTimerList1;
    dbee:	9b01      	ldr	r3, [sp, #4]
    dbf0:	600b      	str	r3, [r1, #0]
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    dbf2:	464a      	mov	r2, r9
    dbf4:	2110      	movs	r1, #16
    dbf6:	200a      	movs	r0, #10
			pxOverflowTimerList = &xActiveTimerList2;
    dbf8:	f8cc 8000 	str.w	r8, [ip]
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    dbfc:	f7fe fbda 	bl	c3b4 <xQueueGenericCreate>
    dc00:	6030      	str	r0, [r6, #0]
	taskEXIT_CRITICAL();
    dc02:	f000 f981 	bl	df08 <vPortExitCritical>
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    dc06:	9b0c      	ldr	r3, [sp, #48]	; 0x30
		pxNewTimer->pcTimerName = pcTimerName;
    dc08:	f8c4 b000 	str.w	fp, [r4]
		pxNewTimer->uxAutoReload = uxAutoReload;
    dc0c:	e9c4 5a06 	strd	r5, sl, [r4, #24]
		pxNewTimer->pvTimerID = pvTimerID;
    dc10:	6227      	str	r7, [r4, #32]
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    dc12:	6263      	str	r3, [r4, #36]	; 0x24
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    dc14:	1d20      	adds	r0, r4, #4
    dc16:	f7fe fb8b 	bl	c330 <vListInitialiseItem>
	}
    dc1a:	4620      	mov	r0, r4
    dc1c:	b003      	add	sp, #12
    dc1e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    dc22:	bf00      	nop
    dc24:	10002cd8 	.word	0x10002cd8
    dc28:	10002cac 	.word	0x10002cac
    dc2c:	10002ca4 	.word	0x10002ca4
    dc30:	10002cc0 	.word	0x10002cc0
    dc34:	10002ca8 	.word	0x10002ca8

0000dc38 <xTimerGenericCommand>:
	configASSERT( xTimer );
    dc38:	b1c0      	cbz	r0, dc6c <xTimerGenericCommand+0x34>
{
    dc3a:	b570      	push	{r4, r5, r6, lr}
	if( xTimerQueue != NULL )
    dc3c:	4d12      	ldr	r5, [pc, #72]	; (dc88 <xTimerGenericCommand+0x50>)
    dc3e:	4604      	mov	r4, r0
    dc40:	6828      	ldr	r0, [r5, #0]
{
    dc42:	b084      	sub	sp, #16
	if( xTimerQueue != NULL )
    dc44:	b180      	cbz	r0, dc68 <xTimerGenericCommand+0x30>
    dc46:	4616      	mov	r6, r2
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    dc48:	2905      	cmp	r1, #5
    dc4a:	461a      	mov	r2, r3
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    dc4c:	e9cd 1600 	strd	r1, r6, [sp]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    dc50:	9402      	str	r4, [sp, #8]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    dc52:	dc0c      	bgt.n	dc6e <xTimerGenericCommand+0x36>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    dc54:	f7ff fde0 	bl	d818 <xTaskGetSchedulerState>
    dc58:	2802      	cmp	r0, #2
    dc5a:	d00e      	beq.n	dc7a <xTimerGenericCommand+0x42>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    dc5c:	2300      	movs	r3, #0
    dc5e:	6828      	ldr	r0, [r5, #0]
    dc60:	461a      	mov	r2, r3
    dc62:	4669      	mov	r1, sp
    dc64:	f7fe fbea 	bl	c43c <xQueueGenericSend>
}
    dc68:	b004      	add	sp, #16
    dc6a:	bd70      	pop	{r4, r5, r6, pc}
    dc6c:	e7fe      	b.n	dc6c <xTimerGenericCommand+0x34>
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    dc6e:	2300      	movs	r3, #0
    dc70:	4669      	mov	r1, sp
    dc72:	f7fe fd91 	bl	c798 <xQueueGenericSendFromISR>
}
    dc76:	b004      	add	sp, #16
    dc78:	bd70      	pop	{r4, r5, r6, pc}
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    dc7a:	6828      	ldr	r0, [r5, #0]
    dc7c:	9a08      	ldr	r2, [sp, #32]
    dc7e:	2300      	movs	r3, #0
    dc80:	4669      	mov	r1, sp
    dc82:	f7fe fbdb 	bl	c43c <xQueueGenericSend>
    dc86:	e7ef      	b.n	dc68 <xTimerGenericCommand+0x30>
    dc88:	10002cd8 	.word	0x10002cd8

0000dc8c <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
    dc8c:	b410      	push	{r4}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    dc8e:	4b11      	ldr	r3, [pc, #68]	; (dcd4 <prvInsertBlockIntoFreeList+0x48>)
    dc90:	681a      	ldr	r2, [r3, #0]
    dc92:	4282      	cmp	r2, r0
    dc94:	d201      	bcs.n	dc9a <prvInsertBlockIntoFreeList+0xe>
    dc96:	4613      	mov	r3, r2
    dc98:	e7fa      	b.n	dc90 <prvInsertBlockIntoFreeList+0x4>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    dc9a:	685c      	ldr	r4, [r3, #4]
    dc9c:	1919      	adds	r1, r3, r4
    dc9e:	4288      	cmp	r0, r1
    dca0:	d103      	bne.n	dcaa <prvInsertBlockIntoFreeList+0x1e>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    dca2:	6841      	ldr	r1, [r0, #4]
    dca4:	4421      	add	r1, r4
    dca6:	6059      	str	r1, [r3, #4]
    dca8:	4618      	mov	r0, r3
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
    dcaa:	6844      	ldr	r4, [r0, #4]
    dcac:	1901      	adds	r1, r0, r4
    dcae:	428a      	cmp	r2, r1
    dcb0:	d109      	bne.n	dcc6 <prvInsertBlockIntoFreeList+0x3a>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
    dcb2:	4909      	ldr	r1, [pc, #36]	; (dcd8 <prvInsertBlockIntoFreeList+0x4c>)
    dcb4:	6809      	ldr	r1, [r1, #0]
    dcb6:	428a      	cmp	r2, r1
    dcb8:	d005      	beq.n	dcc6 <prvInsertBlockIntoFreeList+0x3a>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    dcba:	e9d2 2100 	ldrd	r2, r1, [r2]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    dcbe:	4421      	add	r1, r4
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    dcc0:	6002      	str	r2, [r0, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    dcc2:	6041      	str	r1, [r0, #4]
    dcc4:	e000      	b.n	dcc8 <prvInsertBlockIntoFreeList+0x3c>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    dcc6:	6002      	str	r2, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
    dcc8:	4298      	cmp	r0, r3
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    dcca:	bf18      	it	ne
    dccc:	6018      	strne	r0, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    dcce:	f85d 4b04 	ldr.w	r4, [sp], #4
    dcd2:	4770      	bx	lr
    dcd4:	10012cf0 	.word	0x10012cf0
    dcd8:	10002ce0 	.word	0x10002ce0

0000dcdc <pvPortMalloc>:
{
    dcdc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    dcde:	4604      	mov	r4, r0
	vTaskSuspendAll();
    dce0:	f7ff fa24 	bl	d12c <vTaskSuspendAll>
		if( pxEnd == NULL )
    dce4:	4836      	ldr	r0, [pc, #216]	; (ddc0 <pvPortMalloc+0xe4>)
    dce6:	6802      	ldr	r2, [r0, #0]
    dce8:	b352      	cbz	r2, dd40 <pvPortMalloc+0x64>
    dcea:	4b36      	ldr	r3, [pc, #216]	; (ddc4 <pvPortMalloc+0xe8>)
    dcec:	681d      	ldr	r5, [r3, #0]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
    dcee:	422c      	tst	r4, r5
    dcf0:	d145      	bne.n	dd7e <pvPortMalloc+0xa2>
			if( xWantedSize > 0 )
    dcf2:	2c00      	cmp	r4, #0
    dcf4:	d043      	beq.n	dd7e <pvPortMalloc+0xa2>
				xWantedSize += xHeapStructSize;
    dcf6:	f104 0308 	add.w	r3, r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
    dcfa:	0758      	lsls	r0, r3, #29
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
    dcfc:	bf1c      	itt	ne
    dcfe:	f023 0307 	bicne.w	r3, r3, #7
    dd02:	3308      	addne	r3, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    dd04:	2b00      	cmp	r3, #0
    dd06:	d03a      	beq.n	dd7e <pvPortMalloc+0xa2>
    dd08:	4f2f      	ldr	r7, [pc, #188]	; (ddc8 <pvPortMalloc+0xec>)
    dd0a:	683e      	ldr	r6, [r7, #0]
    dd0c:	429e      	cmp	r6, r3
    dd0e:	d336      	bcc.n	dd7e <pvPortMalloc+0xa2>
				pxBlock = xStart.pxNextFreeBlock;
    dd10:	482e      	ldr	r0, [pc, #184]	; (ddcc <pvPortMalloc+0xf0>)
    dd12:	6804      	ldr	r4, [r0, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    dd14:	e006      	b.n	dd24 <pvPortMalloc+0x48>
    dd16:	f8d4 c000 	ldr.w	ip, [r4]
    dd1a:	f1bc 0f00 	cmp.w	ip, #0
    dd1e:	d004      	beq.n	dd2a <pvPortMalloc+0x4e>
    dd20:	4620      	mov	r0, r4
    dd22:	4664      	mov	r4, ip
    dd24:	6861      	ldr	r1, [r4, #4]
    dd26:	4299      	cmp	r1, r3
    dd28:	d3f5      	bcc.n	dd16 <pvPortMalloc+0x3a>
				if( pxBlock != pxEnd )
    dd2a:	4294      	cmp	r4, r2
    dd2c:	d027      	beq.n	dd7e <pvPortMalloc+0xa2>
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    dd2e:	6822      	ldr	r2, [r4, #0]
    dd30:	6002      	str	r2, [r0, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    dd32:	1aca      	subs	r2, r1, r3
    dd34:	2a10      	cmp	r2, #16
    dd36:	d92e      	bls.n	dd96 <pvPortMalloc+0xba>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    dd38:	18e0      	adds	r0, r4, r3
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
    dd3a:	0741      	lsls	r1, r0, #29
    dd3c:	d026      	beq.n	dd8c <pvPortMalloc+0xb0>
    dd3e:	e7fe      	b.n	dd3e <pvPortMalloc+0x62>
	uxAddress = ( size_t ) ucHeap;
    dd40:	4b23      	ldr	r3, [pc, #140]	; (ddd0 <pvPortMalloc+0xf4>)
	uxAddress -= xHeapStructSize;
    dd42:	4a24      	ldr	r2, [pc, #144]	; (ddd4 <pvPortMalloc+0xf8>)
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    dd44:	4e24      	ldr	r6, [pc, #144]	; (ddd8 <pvPortMalloc+0xfc>)
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    dd46:	4f20      	ldr	r7, [pc, #128]	; (ddc8 <pvPortMalloc+0xec>)
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
    dd48:	075d      	lsls	r5, r3, #29
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
    dd4a:	bf18      	it	ne
    dd4c:	3307      	addne	r3, #7
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
    dd4e:	f022 0207 	bic.w	r2, r2, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
    dd52:	bf18      	it	ne
    dd54:	f023 0307 	bicne.w	r3, r3, #7
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    dd58:	4d1c      	ldr	r5, [pc, #112]	; (ddcc <pvPortMalloc+0xf0>)
	pxEnd = ( void * ) uxAddress;
    dd5a:	6002      	str	r2, [r0, #0]
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
    dd5c:	4619      	mov	r1, r3
	xStart.xBlockSize = ( size_t ) 0;
    dd5e:	2000      	movs	r0, #0
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
    dd60:	1ad3      	subs	r3, r2, r3
	xStart.xBlockSize = ( size_t ) 0;
    dd62:	e9c5 1000 	strd	r1, r0, [r5]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    dd66:	6033      	str	r3, [r6, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    dd68:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
    dd6c:	4e15      	ldr	r6, [pc, #84]	; (ddc4 <pvPortMalloc+0xe8>)
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    dd6e:	603b      	str	r3, [r7, #0]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
    dd70:	422c      	tst	r4, r5
	pxEnd->pxNextFreeBlock = NULL;
    dd72:	e9c2 0000 	strd	r0, r0, [r2]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    dd76:	6035      	str	r5, [r6, #0]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
    dd78:	e9c1 2300 	strd	r2, r3, [r1]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
    dd7c:	d0b9      	beq.n	dcf2 <pvPortMalloc+0x16>
	( void ) xTaskResumeAll();
    dd7e:	f7ff fa9d 	bl	d2bc <xTaskResumeAll>
			vApplicationMallocFailedHook();
    dd82:	f004 f979 	bl	12078 <vApplicationMallocFailedHook>
    dd86:	2400      	movs	r4, #0
}
    dd88:	4620      	mov	r0, r4
    dd8a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    dd8c:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
    dd8e:	6063      	str	r3, [r4, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
    dd90:	f7ff ff7c 	bl	dc8c <prvInsertBlockIntoFreeList>
    dd94:	6861      	ldr	r1, [r4, #4]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    dd96:	4a10      	ldr	r2, [pc, #64]	; (ddd8 <pvPortMalloc+0xfc>)
    dd98:	6810      	ldr	r0, [r2, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
    dd9a:	1a76      	subs	r6, r6, r1
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    dd9c:	430d      	orrs	r5, r1
					pxBlock->pxNextFreeBlock = NULL;
    dd9e:	2300      	movs	r3, #0
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    dda0:	4286      	cmp	r6, r0
					pxBlock->pxNextFreeBlock = NULL;
    dda2:	e9c4 3500 	strd	r3, r5, [r4]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
    dda6:	f104 0408 	add.w	r4, r4, #8
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    ddaa:	bf38      	it	cc
    ddac:	6016      	strcc	r6, [r2, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
    ddae:	603e      	str	r6, [r7, #0]
	( void ) xTaskResumeAll();
    ddb0:	f7ff fa84 	bl	d2bc <xTaskResumeAll>
		if( pvReturn == NULL )
    ddb4:	2c00      	cmp	r4, #0
    ddb6:	d0e4      	beq.n	dd82 <pvPortMalloc+0xa6>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
    ddb8:	0763      	lsls	r3, r4, #29
    ddba:	d0e5      	beq.n	dd88 <pvPortMalloc+0xac>
    ddbc:	e7fe      	b.n	ddbc <pvPortMalloc+0xe0>
    ddbe:	bf00      	nop
    ddc0:	10002ce0 	.word	0x10002ce0
    ddc4:	10012ce4 	.word	0x10012ce4
    ddc8:	10012ce8 	.word	0x10012ce8
    ddcc:	10012cf0 	.word	0x10012cf0
    ddd0:	10002ce4 	.word	0x10002ce4
    ddd4:	10012cdc 	.word	0x10012cdc
    ddd8:	10012cec 	.word	0x10012cec

0000dddc <vPortFree>:
	if( pv != NULL )
    dddc:	b150      	cbz	r0, ddf4 <vPortFree+0x18>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
    ddde:	4a11      	ldr	r2, [pc, #68]	; (de24 <vPortFree+0x48>)
    dde0:	f850 3c04 	ldr.w	r3, [r0, #-4]
    dde4:	6812      	ldr	r2, [r2, #0]
    dde6:	4213      	tst	r3, r2
    dde8:	d003      	beq.n	ddf2 <vPortFree+0x16>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
    ddea:	f850 1c08 	ldr.w	r1, [r0, #-8]
    ddee:	b111      	cbz	r1, ddf6 <vPortFree+0x1a>
    ddf0:	e7fe      	b.n	ddf0 <vPortFree+0x14>
    ddf2:	e7fe      	b.n	ddf2 <vPortFree+0x16>
    ddf4:	4770      	bx	lr
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
    ddf6:	ea23 0302 	bic.w	r3, r3, r2
{
    ddfa:	b510      	push	{r4, lr}
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
    ddfc:	f840 3c04 	str.w	r3, [r0, #-4]
    de00:	4604      	mov	r4, r0
				vTaskSuspendAll();
    de02:	f7ff f993 	bl	d12c <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
    de06:	4a08      	ldr	r2, [pc, #32]	; (de28 <vPortFree+0x4c>)
    de08:	f854 3c04 	ldr.w	r3, [r4, #-4]
    de0c:	6811      	ldr	r1, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    de0e:	f1a4 0008 	sub.w	r0, r4, #8
					xFreeBytesRemaining += pxLink->xBlockSize;
    de12:	440b      	add	r3, r1
    de14:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    de16:	f7ff ff39 	bl	dc8c <prvInsertBlockIntoFreeList>
}
    de1a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				( void ) xTaskResumeAll();
    de1e:	f7ff ba4d 	b.w	d2bc <xTaskResumeAll>
    de22:	bf00      	nop
    de24:	10012ce4 	.word	0x10012ce4
    de28:	10012ce8 	.word	0x10012ce8

0000de2c <prvTaskExitError>:
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
    de2c:	4b06      	ldr	r3, [pc, #24]	; (de48 <prvTaskExitError+0x1c>)
    de2e:	681b      	ldr	r3, [r3, #0]
    de30:	3301      	adds	r3, #1
    de32:	d000      	beq.n	de36 <prvTaskExitError+0xa>
    de34:	e7fe      	b.n	de34 <prvTaskExitError+0x8>
    de36:	f04f 0380 	mov.w	r3, #128	; 0x80
    de3a:	f383 8811 	msr	BASEPRI, r3
    de3e:	f3bf 8f6f 	isb	sy
    de42:	f3bf 8f4f 	dsb	sy
    de46:	e7fe      	b.n	de46 <prvTaskExitError+0x1a>
    de48:	10002b00 	.word	0x10002b00

0000de4c <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
    de4c:	4806      	ldr	r0, [pc, #24]	; (de68 <prvPortStartFirstTask+0x1c>)
    de4e:	6800      	ldr	r0, [r0, #0]
    de50:	6800      	ldr	r0, [r0, #0]
    de52:	f380 8808 	msr	MSP, r0
    de56:	b662      	cpsie	i
    de58:	b661      	cpsie	f
    de5a:	f3bf 8f4f 	dsb	sy
    de5e:	f3bf 8f6f 	isb	sy
    de62:	df00      	svc	0
    de64:	bf00      	nop
    de66:	0000      	.short	0x0000
    de68:	e000ed08 	.word	0xe000ed08

0000de6c <vPortEnableVFP>:
}
/*-----------------------------------------------------------*/
/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
    de6c:	f8df 000c 	ldr.w	r0, [pc, #12]	; de7c <vPortEnableVFP+0x10>
    de70:	6801      	ldr	r1, [r0, #0]
    de72:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    de76:	6001      	str	r1, [r0, #0]
    de78:	4770      	bx	lr
    de7a:	0000      	.short	0x0000
    de7c:	e000ed88 	.word	0xe000ed88

0000de80 <pxPortInitialiseStack>:
{
    de80:	b430      	push	{r4, r5}
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
    de82:	f021 0101 	bic.w	r1, r1, #1
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
    de86:	f04f 7580 	mov.w	r5, #16777216	; 0x1000000
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
    de8a:	4c07      	ldr	r4, [pc, #28]	; (dea8 <pxPortInitialiseStack+0x28>)
    de8c:	f840 4c0c 	str.w	r4, [r0, #-12]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
    de90:	f06f 0302 	mvn.w	r3, #2
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
    de94:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
    de98:	e940 1502 	strd	r1, r5, [r0, #-8]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
    de9c:	f840 3c24 	str.w	r3, [r0, #-36]
}
    dea0:	bc30      	pop	{r4, r5}
    dea2:	3844      	subs	r0, #68	; 0x44
    dea4:	4770      	bx	lr
    dea6:	bf00      	nop
    dea8:	0000de2d 	.word	0x0000de2d
    deac:	00000000 	.word	0x00000000

0000deb0 <SVC_Handler>:
	__asm volatile (
    deb0:	4b07      	ldr	r3, [pc, #28]	; (ded0 <pxCurrentTCBConst2>)
    deb2:	6819      	ldr	r1, [r3, #0]
    deb4:	6808      	ldr	r0, [r1, #0]
    deb6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    deba:	f380 8809 	msr	PSP, r0
    debe:	f3bf 8f6f 	isb	sy
    dec2:	f04f 0000 	mov.w	r0, #0
    dec6:	f380 8811 	msr	BASEPRI, r0
    deca:	4770      	bx	lr
    decc:	f3af 8000 	nop.w

0000ded0 <pxCurrentTCBConst2>:
    ded0:	10002b90 	.word	0x10002b90

0000ded4 <vPortEnterCritical>:
    ded4:	f04f 0380 	mov.w	r3, #128	; 0x80
    ded8:	f383 8811 	msr	BASEPRI, r3
    dedc:	f3bf 8f6f 	isb	sy
    dee0:	f3bf 8f4f 	dsb	sy
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
    dee4:	4a06      	ldr	r2, [pc, #24]	; (df00 <vPortEnterCritical+0x2c>)
    dee6:	6813      	ldr	r3, [r2, #0]
    dee8:	3301      	adds	r3, #1
	/* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
    deea:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
    deec:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
    deee:	d000      	beq.n	def2 <vPortEnterCritical+0x1e>
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
	}
}
    def0:	4770      	bx	lr
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
    def2:	4b04      	ldr	r3, [pc, #16]	; (df04 <vPortEnterCritical+0x30>)
    def4:	681b      	ldr	r3, [r3, #0]
    def6:	f013 0fff 	tst.w	r3, #255	; 0xff
    defa:	d0f9      	beq.n	def0 <vPortEnterCritical+0x1c>
    defc:	e7fe      	b.n	defc <vPortEnterCritical+0x28>
    defe:	bf00      	nop
    df00:	10002b00 	.word	0x10002b00
    df04:	e000ed04 	.word	0xe000ed04

0000df08 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	configASSERT( uxCriticalNesting );
    df08:	4a04      	ldr	r2, [pc, #16]	; (df1c <vPortExitCritical+0x14>)
    df0a:	6813      	ldr	r3, [r2, #0]
    df0c:	b12b      	cbz	r3, df1a <vPortExitCritical+0x12>
	uxCriticalNesting--;
    df0e:	3b01      	subs	r3, #1
    df10:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
    df12:	b90b      	cbnz	r3, df18 <vPortExitCritical+0x10>
	__asm volatile
    df14:	f383 8811 	msr	BASEPRI, r3
	{
		portENABLE_INTERRUPTS();
	}
}
    df18:	4770      	bx	lr
    df1a:	e7fe      	b.n	df1a <vPortExitCritical+0x12>
    df1c:	10002b00 	.word	0x10002b00

0000df20 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
    df20:	f3ef 8009 	mrs	r0, PSP
    df24:	f3bf 8f6f 	isb	sy
    df28:	4b15      	ldr	r3, [pc, #84]	; (df80 <pxCurrentTCBConst>)
    df2a:	681a      	ldr	r2, [r3, #0]
    df2c:	f01e 0f10 	tst.w	lr, #16
    df30:	bf08      	it	eq
    df32:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
    df36:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    df3a:	6010      	str	r0, [r2, #0]
    df3c:	f84d 3d04 	str.w	r3, [sp, #-4]!
    df40:	f04f 0080 	mov.w	r0, #128	; 0x80
    df44:	f380 8811 	msr	BASEPRI, r0
    df48:	f3bf 8f4f 	dsb	sy
    df4c:	f3bf 8f6f 	isb	sy
    df50:	f7ff fa8c 	bl	d46c <vTaskSwitchContext>
    df54:	f04f 0000 	mov.w	r0, #0
    df58:	f380 8811 	msr	BASEPRI, r0
    df5c:	bc08      	pop	{r3}
    df5e:	6819      	ldr	r1, [r3, #0]
    df60:	6808      	ldr	r0, [r1, #0]
    df62:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    df66:	f01e 0f10 	tst.w	lr, #16
    df6a:	bf08      	it	eq
    df6c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
    df70:	f380 8809 	msr	PSP, r0
    df74:	f3bf 8f6f 	isb	sy
    df78:	4770      	bx	lr
    df7a:	bf00      	nop
    df7c:	f3af 8000 	nop.w

0000df80 <pxCurrentTCBConst>:
    df80:	10002b90 	.word	0x10002b90

0000df84 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
    df84:	b508      	push	{r3, lr}
	__asm volatile
    df86:	f04f 0380 	mov.w	r3, #128	; 0x80
    df8a:	f383 8811 	msr	BASEPRI, r3
    df8e:	f3bf 8f6f 	isb	sy
    df92:	f3bf 8f4f 	dsb	sy
	executes all interrupts must be unmasked.  There is therefore no need to
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	// Addition for support of SystemView Profiler
	traceISR_ENTER();
    df96:	f002 fd7d 	bl	10a94 <SEGGER_SYSVIEW_RecordEnterISR>
	// End addition
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
    df9a:	f7ff f8f1 	bl	d180 <xTaskIncrementTick>
    df9e:	b928      	cbnz	r0, dfac <SysTick_Handler+0x28>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
		}
		// Addition for support of SystemView Profiler
		else
		{
		  traceISR_EXIT();
    dfa0:	f002 fac6 	bl	10530 <SEGGER_SYSVIEW_RecordExitISR>
	__asm volatile
    dfa4:	2300      	movs	r3, #0
    dfa6:	f383 8811 	msr	BASEPRI, r3
		}
		// End addition
	}
	portENABLE_INTERRUPTS();
}
    dfaa:	bd08      	pop	{r3, pc}
		  traceISR_EXIT_TO_SCHEDULER();
    dfac:	f002 fbd4 	bl	10758 <SEGGER_SYSVIEW_RecordExitISRToScheduler>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
    dfb0:	4b03      	ldr	r3, [pc, #12]	; (dfc0 <SysTick_Handler+0x3c>)
    dfb2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    dfb6:	601a      	str	r2, [r3, #0]
    dfb8:	2300      	movs	r3, #0
    dfba:	f383 8811 	msr	BASEPRI, r3
}
    dfbe:	bd08      	pop	{r3, pc}
    dfc0:	e000ed04 	.word	0xe000ed04

0000dfc4 <vPortValidateInterruptPriority>:
	{
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
    dfc4:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
    dfc8:	2b0f      	cmp	r3, #15
    dfca:	d905      	bls.n	dfd8 <vPortValidateInterruptPriority+0x14>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
    dfcc:	4908      	ldr	r1, [pc, #32]	; (dff0 <vPortValidateInterruptPriority+0x2c>)
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
    dfce:	4a09      	ldr	r2, [pc, #36]	; (dff4 <vPortValidateInterruptPriority+0x30>)
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
    dfd0:	5c5b      	ldrb	r3, [r3, r1]
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
    dfd2:	7812      	ldrb	r2, [r2, #0]
    dfd4:	429a      	cmp	r2, r3
    dfd6:	d808      	bhi.n	dfea <vPortValidateInterruptPriority+0x26>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredicable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
    dfd8:	4b07      	ldr	r3, [pc, #28]	; (dff8 <vPortValidateInterruptPriority+0x34>)
    dfda:	4a08      	ldr	r2, [pc, #32]	; (dffc <vPortValidateInterruptPriority+0x38>)
    dfdc:	681b      	ldr	r3, [r3, #0]
    dfde:	6812      	ldr	r2, [r2, #0]
    dfe0:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    dfe4:	4293      	cmp	r3, r2
    dfe6:	d901      	bls.n	dfec <vPortValidateInterruptPriority+0x28>
    dfe8:	e7fe      	b.n	dfe8 <vPortValidateInterruptPriority+0x24>
    dfea:	e7fe      	b.n	dfea <vPortValidateInterruptPriority+0x26>
	}
    dfec:	4770      	bx	lr
    dfee:	bf00      	nop
    dff0:	e000e3f0 	.word	0xe000e3f0
    dff4:	10012cfc 	.word	0x10012cfc
    dff8:	e000ed0c 	.word	0xe000ed0c
    dffc:	10012d00 	.word	0x10012d00

0000e000 <vPortSuppressTicksAndSleep>:
 * resolution of the Tick timer.
 */
	static uint32_t xMaximumPossibleSuppressedTicks = 0;

void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
{
    e000:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    uint32_t New_Timer, Delta_Sleep;
	TickType_t xModifiableIdleTime;
    uint32_t elapsed_time;

	/* Make sure the SysTick reload value does not overflow the counter. */
	if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
    e004:	4b26      	ldr	r3, [pc, #152]	; (e0a0 <vPortSuppressTicksAndSleep+0xa0>)


	/* Calculate the reload value required to wait xExpectedIdleTime
	tick periods.  -1 is used because this code will execute part way
	through one of the tick periods. */
	ulReloadValue =  ulTimerCountsForOneTick * ( xExpectedIdleTime - 1 );
    e006:	4e27      	ldr	r6, [pc, #156]	; (e0a4 <vPortSuppressTicksAndSleep+0xa4>)
	if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
    e008:	681d      	ldr	r5, [r3, #0]
	ulReloadValue =  ulTimerCountsForOneTick * ( xExpectedIdleTime - 1 );
    e00a:	f8d6 9000 	ldr.w	r9, [r6]
{
    e00e:	4604      	mov	r4, r0

	/* Enter a critical section but don't use the taskENTER_CRITICAL()
	method as that will mask interrupts that should exit sleep mode. */
	__asm volatile( "cpsid i" );
    e010:	b672      	cpsid	i
	__asm volatile( "dsb" );
    e012:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
    e016:	f3bf 8f6f 	isb	sy
#ifdef AM_FREERTOS_USE_STIMER_FOR_TICK
    // Adjust for the time already elapsed
    elapsed_time = am_hal_stimer_counter_get() - g_lastSTimerVal;
    e01a:	f004 fd11 	bl	12a40 <am_hal_stimer_counter_get>
    e01e:	f8df 8088 	ldr.w	r8, [pc, #136]	; e0a8 <vPortSuppressTicksAndSleep+0xa8>
    e022:	4607      	mov	r7, r0
    e024:	f8d8 a000 	ldr.w	sl, [r8]


	/* If a context switch is pending or a task is waiting for the scheduler
	to be unsuspended then abandon the low power entry. */
    /* Abandon low power entry if the sleep time is too short */
	if( (eTaskConfirmSleepModeStatus() == eAbortSleep) || ((elapsed_time + ulTimerCountsForOneTick) > ulReloadValue) )
    e028:	f7ff fbdc 	bl	d7e4 <eTaskConfirmSleepModeStatus>
    e02c:	b158      	cbz	r0, e046 <vPortSuppressTicksAndSleep+0x46>
    e02e:	42ac      	cmp	r4, r5
    e030:	bf28      	it	cs
    e032:	462c      	movcs	r4, r5
    e034:	6832      	ldr	r2, [r6, #0]
    elapsed_time = am_hal_stimer_counter_get() - g_lastSTimerVal;
    e036:	eba7 070a 	sub.w	r7, r7, sl
	ulReloadValue =  ulTimerCountsForOneTick * ( xExpectedIdleTime - 1 );
    e03a:	1e61      	subs	r1, r4, #1
    e03c:	fb09 f101 	mul.w	r1, r9, r1
	if( (eTaskConfirmSleepModeStatus() == eAbortSleep) || ((elapsed_time + ulTimerCountsForOneTick) > ulReloadValue) )
    e040:	443a      	add	r2, r7
    e042:	428a      	cmp	r2, r1
    e044:	d902      	bls.n	e04c <vPortSuppressTicksAndSleep+0x4c>

        am_hal_ctimer_start(AM_FREERTOS_CTIMER_NUM, AM_HAL_CTIMER_BOTH);
#endif
		/* Re-enable interrupts - see comments above the cpsid instruction()
		above. */
		__asm volatile( "cpsie i" );
    e046:	b662      	cpsie	i

	}
}
    e048:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        am_hal_stimer_compare_delta_set(0, ulReloadValue);
    e04c:	2000      	movs	r0, #0
    e04e:	1bc9      	subs	r1, r1, r7
    e050:	f004 fcfc 	bl	12a4c <am_hal_stimer_compare_delta_set>
		configPRE_SLEEP_PROCESSING( xModifiableIdleTime );       // Turn OFF all Periphials in this function
    e054:	4620      	mov	r0, r4
    e056:	f004 f807 	bl	12068 <am_freertos_sleep>
		if( xModifiableIdleTime > 0 )
    e05a:	b120      	cbz	r0, e066 <vPortSuppressTicksAndSleep+0x66>
			__asm volatile( "dsb" );
    e05c:	f3bf 8f4f 	dsb	sy
			__asm volatile( "wfi" );
    e060:	bf30      	wfi
			__asm volatile( "isb" );
    e062:	f3bf 8f6f 	isb	sy
		configPOST_SLEEP_PROCESSING( xExpectedIdleTime );       // Turn ON all Periphials in this function
    e066:	4620      	mov	r0, r4
    e068:	f004 f804 	bl	12074 <am_freertos_wakeup>
        New_Timer = am_hal_stimer_counter_get();
    e06c:	f004 fce8 	bl	12a40 <am_hal_stimer_counter_get>
        Delta_Sleep = (signed long) New_Timer - (signed long) g_lastSTimerVal;
    e070:	f8d8 1000 	ldr.w	r1, [r8]
        g_lastSTimerVal = New_Timer - Delta_Sleep%ulTimerCountsForOneTick;
    e074:	6832      	ldr	r2, [r6, #0]
        Delta_Sleep = (signed long) New_Timer - (signed long) g_lastSTimerVal;
    e076:	1a41      	subs	r1, r0, r1
        New_Timer = am_hal_stimer_counter_get();
    e078:	4603      	mov	r3, r0
        g_lastSTimerVal = New_Timer - Delta_Sleep%ulTimerCountsForOneTick;
    e07a:	fbb1 f0f2 	udiv	r0, r1, r2
    e07e:	fb02 1210 	mls	r2, r2, r0, r1
    e082:	1a9b      	subs	r3, r3, r2
    e084:	f8c8 3000 	str.w	r3, [r8]
        vTaskStepTick( Delta_Sleep );
    e088:	f7ff f866 	bl	d158 <vTaskStepTick>
        am_hal_stimer_int_clear(AM_HAL_STIMER_INT_COMPAREA);
    e08c:	2001      	movs	r0, #1
    e08e:	f004 fd3b 	bl	12b08 <am_hal_stimer_int_clear>
        am_hal_stimer_compare_delta_set(0, ulTimerCountsForOneTick);
    e092:	6831      	ldr	r1, [r6, #0]
    e094:	2000      	movs	r0, #0
    e096:	f004 fcd9 	bl	12a4c <am_hal_stimer_compare_delta_set>
		__asm volatile( "cpsie i" );
    e09a:	b662      	cpsie	i
}
    e09c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    e0a0:	10012d08 	.word	0x10012d08
    e0a4:	10012d04 	.word	0x10012d04
    e0a8:	10012cf8 	.word	0x10012cf8

0000e0ac <am_stimer_cmpr0_isr>:
// Interrupt handler for the STIMER module Compare 0.
//
//*****************************************************************************
void
am_stimer_cmpr0_isr(void)
{
    e0ac:	b538      	push	{r3, r4, r5, lr}

    //
    // Check the timer interrupt status.
    //
    uint32_t ui32Status = am_hal_stimer_int_status_get(false);
    e0ae:	2000      	movs	r0, #0
    e0b0:	f004 fd30 	bl	12b14 <am_hal_stimer_int_status_get>
    if (ui32Status & AM_HAL_STIMER_INT_COMPAREA)
    e0b4:	07c3      	lsls	r3, r0, #31
    e0b6:	d400      	bmi.n	e0ba <am_stimer_cmpr0_isr+0xe>
        //
        // Run handlers for the various possible timer events.
        //
        xPortStimerTickHandler();
    }
}
    e0b8:	bd38      	pop	{r3, r4, r5, pc}
        am_hal_stimer_int_clear(AM_HAL_STIMER_INT_COMPAREA);
    e0ba:	2001      	movs	r0, #1
    e0bc:	f004 fd24 	bl	12b08 <am_hal_stimer_int_clear>
    curSTimer = am_hal_stimer_counter_get();
    e0c0:	f004 fcbe 	bl	12a40 <am_hal_stimer_counter_get>
    am_hal_stimer_compare_delta_set(0, ulTimerCountsForOneTick);
    e0c4:	4c19      	ldr	r4, [pc, #100]	; (e12c <am_stimer_cmpr0_isr+0x80>)
    curSTimer = am_hal_stimer_counter_get();
    e0c6:	4605      	mov	r5, r0
    am_hal_stimer_compare_delta_set(0, ulTimerCountsForOneTick);
    e0c8:	6821      	ldr	r1, [r4, #0]
    e0ca:	2000      	movs	r0, #0
    e0cc:	f004 fcbe 	bl	12a4c <am_hal_stimer_compare_delta_set>
    timerCounts = curSTimer - g_lastSTimerVal;
    e0d0:	4917      	ldr	r1, [pc, #92]	; (e130 <am_stimer_cmpr0_isr+0x84>)
    numTicksElapsed = timerCounts/ulTimerCountsForOneTick;
    e0d2:	6823      	ldr	r3, [r4, #0]
    timerCounts = curSTimer - g_lastSTimerVal;
    e0d4:	680a      	ldr	r2, [r1, #0]
    e0d6:	1aaa      	subs	r2, r5, r2
    numTicksElapsed = timerCounts/ulTimerCountsForOneTick;
    e0d8:	fbb2 f4f3 	udiv	r4, r2, r3
    remainder = timerCounts % ulTimerCountsForOneTick;
    e0dc:	fb03 2314 	mls	r3, r3, r4, r2
    g_lastSTimerVal = curSTimer - remainder;
    e0e0:	1aed      	subs	r5, r5, r3
    e0e2:	600d      	str	r5, [r1, #0]
	__asm volatile
    e0e4:	f3ef 8311 	mrs	r3, BASEPRI
    e0e8:	f04f 0280 	mov.w	r2, #128	; 0x80
    e0ec:	f382 8811 	msr	BASEPRI, r2
    e0f0:	f3bf 8f6f 	isb	sy
    e0f4:	f3bf 8f4f 	dsb	sy
    traceISR_ENTER();
    e0f8:	f002 fccc 	bl	10a94 <SEGGER_SYSVIEW_RecordEnterISR>
    BaseType_t ctxtSwitchReqd = pdFALSE;
    e0fc:	2500      	movs	r5, #0
    e0fe:	e004      	b.n	e10a <am_stimer_cmpr0_isr+0x5e>
            ctxtSwitchReqd = (( xTaskIncrementTick() != pdFALSE ) ? pdTRUE : ctxtSwitchReqd);
    e100:	f7ff f83e 	bl	d180 <xTaskIncrementTick>
    e104:	2800      	cmp	r0, #0
    e106:	bf18      	it	ne
    e108:	2501      	movne	r5, #1
        while (numTicksElapsed--)
    e10a:	f114 34ff 	adds.w	r4, r4, #4294967295	; 0xffffffff
    e10e:	d2f7      	bcs.n	e100 <am_stimer_cmpr0_isr+0x54>
        if ( ctxtSwitchReqd != pdFALSE )
    e110:	b92d      	cbnz	r5, e11e <am_stimer_cmpr0_isr+0x72>
        	traceISR_EXIT();
    e112:	f002 fa0d 	bl	10530 <SEGGER_SYSVIEW_RecordExitISR>
	__asm volatile
    e116:	2300      	movs	r3, #0
    e118:	f383 8811 	msr	BASEPRI, r3
}
    e11c:	bd38      	pop	{r3, r4, r5, pc}
        	traceISR_EXIT_TO_SCHEDULER();
    e11e:	f002 fb1b 	bl	10758 <SEGGER_SYSVIEW_RecordExitISRToScheduler>
            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
    e122:	4b04      	ldr	r3, [pc, #16]	; (e134 <am_stimer_cmpr0_isr+0x88>)
    e124:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    e128:	601a      	str	r2, [r3, #0]
    e12a:	e7f4      	b.n	e116 <am_stimer_cmpr0_isr+0x6a>
    e12c:	10012d04 	.word	0x10012d04
    e130:	10012cf8 	.word	0x10012cf8
    e134:	e000ed04 	.word	0xe000ed04

0000e138 <vPortSetupTimerInterrupt>:

#endif // AM_FREERTOS_USE_STIMER_FOR_TICK


void vPortSetupTimerInterrupt( void )
{
    e138:	b538      	push	{r3, r4, r5, lr}
#ifdef AM_FREERTOS_USE_STIMER_FOR_TICK
    uint32_t oldCfg;
    /* Calculate the constants required to configure the tick interrupt. */
    #if configUSE_TICKLESS_IDLE == 2
    {
        ulTimerCountsForOneTick = (configSTIMER_CLOCK_HZ /configTICK_RATE_HZ) ; //( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
    e13a:	4c14      	ldr	r4, [pc, #80]	; (e18c <vPortSetupTimerInterrupt+0x54>)
        xMaximumPossibleSuppressedTicks = portMAX_32_BIT_NUMBER / ulTimerCountsForOneTick;
    e13c:	4b14      	ldr	r3, [pc, #80]	; (e190 <vPortSetupTimerInterrupt+0x58>)
        ulTimerCountsForOneTick = (configSTIMER_CLOCK_HZ /configTICK_RATE_HZ) ; //( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
    e13e:	2120      	movs	r1, #32
        xMaximumPossibleSuppressedTicks = portMAX_32_BIT_NUMBER / ulTimerCountsForOneTick;
    e140:	f06f 4278 	mvn.w	r2, #4160749568	; 0xf8000000
    }
    #endif /* configUSE_TICKLESS_IDLE */
    //
    //
    //
    am_hal_stimer_int_enable(AM_HAL_STIMER_INT_COMPAREA);
    e144:	2001      	movs	r0, #1
        ulTimerCountsForOneTick = (configSTIMER_CLOCK_HZ /configTICK_RATE_HZ) ; //( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
    e146:	6021      	str	r1, [r4, #0]
        xMaximumPossibleSuppressedTicks = portMAX_32_BIT_NUMBER / ulTimerCountsForOneTick;
    e148:	601a      	str	r2, [r3, #0]
    am_hal_stimer_int_enable(AM_HAL_STIMER_INT_COMPAREA);
    e14a:	f004 fcd3 	bl	12af4 <am_hal_stimer_int_enable>
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    e14e:	4b11      	ldr	r3, [pc, #68]	; (e194 <vPortSetupTimerInterrupt+0x5c>)
    e150:	21e0      	movs	r1, #224	; 0xe0
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e152:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    e156:	f883 1317 	strb.w	r1, [r3, #791]	; 0x317
#endif // AM_CMSIS_REGS

    //
    // Configure the STIMER
    //
    oldCfg = am_hal_stimer_config(AM_HAL_STIMER_CFG_FREEZE);
    e15a:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e15e:	601a      	str	r2, [r3, #0]
    e160:	f004 fc64 	bl	12a2c <am_hal_stimer_config>
    e164:	4605      	mov	r5, r0
    g_lastSTimerVal = am_hal_stimer_counter_get();
    e166:	f004 fc6b 	bl	12a40 <am_hal_stimer_counter_get>
    e16a:	4b0b      	ldr	r3, [pc, #44]	; (e198 <vPortSetupTimerInterrupt+0x60>)
    am_hal_stimer_compare_delta_set(0, ulTimerCountsForOneTick);
    e16c:	6821      	ldr	r1, [r4, #0]
    g_lastSTimerVal = am_hal_stimer_counter_get();
    e16e:	6018      	str	r0, [r3, #0]
    am_hal_stimer_compare_delta_set(0, ulTimerCountsForOneTick);
    e170:	2000      	movs	r0, #0
    e172:	f004 fc6b 	bl	12a4c <am_hal_stimer_compare_delta_set>
#if AM_CMSIS_REGS
    am_hal_stimer_config((oldCfg & ~(AM_HAL_STIMER_CFG_FREEZE|CTIMER_STCFG_CLKSEL_Msk)) | AM_STIMER_CLOCK | AM_HAL_STIMER_CFG_COMPARE_A_ENABLE);
    e176:	4809      	ldr	r0, [pc, #36]	; (e19c <vPortSetupTimerInterrupt+0x64>)
    e178:	4028      	ands	r0, r5
    e17a:	f440 7081 	orr.w	r0, r0, #258	; 0x102
    e17e:	f040 0001 	orr.w	r0, r0, #1
    //
    am_hal_ctimer_start(AM_FREERTOS_CTIMER_NUM, AM_HAL_CTIMER_BOTH);


#endif // AM_FREERTOS_USE_STIMER_FOR_TICK
}
    e182:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    am_hal_stimer_config((oldCfg & ~(AM_HAL_STIMER_CFG_FREEZE|CTIMER_STCFG_CLKSEL_Msk)) | AM_STIMER_CLOCK | AM_HAL_STIMER_CFG_COMPARE_A_ENABLE);
    e186:	f004 bc51 	b.w	12a2c <am_hal_stimer_config>
    e18a:	bf00      	nop
    e18c:	10012d04 	.word	0x10012d04
    e190:	10012d08 	.word	0x10012d08
    e194:	e000e100 	.word	0xe000e100
    e198:	10012cf8 	.word	0x10012cf8
    e19c:	7ffffef0 	.word	0x7ffffef0

0000e1a0 <xPortStartScheduler>:
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
    e1a0:	4b2f      	ldr	r3, [pc, #188]	; (e260 <xPortStartScheduler+0xc0>)
    e1a2:	4a30      	ldr	r2, [pc, #192]	; (e264 <xPortStartScheduler+0xc4>)
    e1a4:	6819      	ldr	r1, [r3, #0]
    e1a6:	4291      	cmp	r1, r2
    e1a8:	d018      	beq.n	e1dc <xPortStartScheduler+0x3c>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
    e1aa:	681a      	ldr	r2, [r3, #0]
    e1ac:	4b2e      	ldr	r3, [pc, #184]	; (e268 <xPortStartScheduler+0xc8>)
    e1ae:	429a      	cmp	r2, r3
    e1b0:	d015      	beq.n	e1de <xPortStartScheduler+0x3e>
{
    e1b2:	b510      	push	{r4, lr}
		ulOriginalPriority = *pucFirstUserPriorityRegister;
    e1b4:	4b2d      	ldr	r3, [pc, #180]	; (e26c <xPortStartScheduler+0xcc>)
    e1b6:	781a      	ldrb	r2, [r3, #0]
{
    e1b8:	b082      	sub	sp, #8
		ulOriginalPriority = *pucFirstUserPriorityRegister;
    e1ba:	b2d2      	uxtb	r2, r2
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
    e1bc:	21ff      	movs	r1, #255	; 0xff
		ulOriginalPriority = *pucFirstUserPriorityRegister;
    e1be:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
    e1c0:	7019      	strb	r1, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
    e1c2:	781b      	ldrb	r3, [r3, #0]
    e1c4:	b2db      	uxtb	r3, r3
    e1c6:	f88d 3003 	strb.w	r3, [sp, #3]
		configASSERT( ucMaxPriorityValue == ( configKERNEL_INTERRUPT_PRIORITY & ucMaxPriorityValue ) );
    e1ca:	f89d 3003 	ldrb.w	r3, [sp, #3]
    e1ce:	f89d 2003 	ldrb.w	r2, [sp, #3]
    e1d2:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
    e1d6:	4293      	cmp	r3, r2
    e1d8:	d002      	beq.n	e1e0 <xPortStartScheduler+0x40>
    e1da:	e7fe      	b.n	e1da <xPortStartScheduler+0x3a>
    e1dc:	e7fe      	b.n	e1dc <xPortStartScheduler+0x3c>
    e1de:	e7fe      	b.n	e1de <xPortStartScheduler+0x3e>
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    e1e0:	f89d 3003 	ldrb.w	r3, [sp, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
    e1e4:	f89d 2003 	ldrb.w	r2, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    e1e8:	4c21      	ldr	r4, [pc, #132]	; (e270 <xPortStartScheduler+0xd0>)
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
    e1ea:	4922      	ldr	r1, [pc, #136]	; (e274 <xPortStartScheduler+0xd4>)
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    e1ec:	f003 0380 	and.w	r3, r3, #128	; 0x80
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
    e1f0:	2007      	movs	r0, #7
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
    e1f2:	0612      	lsls	r2, r2, #24
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    e1f4:	7023      	strb	r3, [r4, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
    e1f6:	6008      	str	r0, [r1, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
    e1f8:	d50f      	bpl.n	e21a <xPortStartScheduler+0x7a>
    e1fa:	2206      	movs	r2, #6
    e1fc:	e000      	b.n	e200 <xPortStartScheduler+0x60>
    e1fe:	4602      	mov	r2, r0
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
    e200:	f89d 3003 	ldrb.w	r3, [sp, #3]
    e204:	005b      	lsls	r3, r3, #1
    e206:	b2db      	uxtb	r3, r3
    e208:	f88d 3003 	strb.w	r3, [sp, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
    e20c:	f89d 3003 	ldrb.w	r3, [sp, #3]
    e210:	061b      	lsls	r3, r3, #24
    e212:	f102 30ff 	add.w	r0, r2, #4294967295	; 0xffffffff
    e216:	d4f2      	bmi.n	e1fe <xPortStartScheduler+0x5e>
    e218:	600a      	str	r2, [r1, #0]
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
    e21a:	680b      	ldr	r3, [r1, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
    e21c:	9801      	ldr	r0, [sp, #4]
    e21e:	4c13      	ldr	r4, [pc, #76]	; (e26c <xPortStartScheduler+0xcc>)
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
    e220:	4a15      	ldr	r2, [pc, #84]	; (e278 <xPortStartScheduler+0xd8>)
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
    e222:	021b      	lsls	r3, r3, #8
		*pucFirstUserPriorityRegister = ulOriginalPriority;
    e224:	b2c0      	uxtb	r0, r0
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
    e226:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    e22a:	600b      	str	r3, [r1, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
    e22c:	7020      	strb	r0, [r4, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
    e22e:	6813      	ldr	r3, [r2, #0]
    e230:	f443 0360 	orr.w	r3, r3, #14680064	; 0xe00000
    e234:	6013      	str	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
    e236:	6813      	ldr	r3, [r2, #0]
    e238:	f043 4360 	orr.w	r3, r3, #3758096384	; 0xe0000000
    e23c:	6013      	str	r3, [r2, #0]
	vPortSetupTimerInterrupt();
    e23e:	f7ff ff7b 	bl	e138 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
    e242:	4b0e      	ldr	r3, [pc, #56]	; (e27c <xPortStartScheduler+0xdc>)
    e244:	2200      	movs	r2, #0
    e246:	601a      	str	r2, [r3, #0]
	vPortEnableVFP();
    e248:	f7ff fe10 	bl	de6c <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
    e24c:	4a0c      	ldr	r2, [pc, #48]	; (e280 <xPortStartScheduler+0xe0>)
    e24e:	6813      	ldr	r3, [r2, #0]
    e250:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
    e254:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
    e256:	f7ff fdf9 	bl	de4c <prvPortStartFirstTask>
	prvTaskExitError();
    e25a:	f7ff fde7 	bl	de2c <prvTaskExitError>
    e25e:	bf00      	nop
    e260:	e000ed00 	.word	0xe000ed00
    e264:	410fc271 	.word	0x410fc271
    e268:	410fc270 	.word	0x410fc270
    e26c:	e000e400 	.word	0xe000e400
    e270:	10012cfc 	.word	0x10012cfc
    e274:	10012d00 	.word	0x10012d00
    e278:	e000ed20 	.word	0xe000ed20
    e27c:	10002b00 	.word	0x10002b00
    e280:	e000ef34 	.word	0xe000ef34

0000e284 <am_hal_pdm_initialize>:
am_hal_pdm_initialize(uint32_t ui32Module, void **ppHandle)
{
    //
    // Check that the request module is in range.
    //
    if ( ui32Module >= AM_REG_PDM_NUM_MODULES )
    e284:	b9a0      	cbnz	r0, e2b0 <am_hal_pdm_initialize+0x2c>
    }

    //
    // Check for valid arguements.
    //
    if (!ppHandle)
    e286:	b1c1      	cbz	r1, e2ba <am_hal_pdm_initialize+0x36>
    }

    //
    // Check if the handle is unallocated.
    //
    if (g_am_hal_pdm_states[ui32Module].prefix.s.bInit)
    e288:	4b0d      	ldr	r3, [pc, #52]	; (e2c0 <am_hal_pdm_initialize+0x3c>)
    e28a:	78da      	ldrb	r2, [r3, #3]
{
    e28c:	b430      	push	{r4, r5}
    if (g_am_hal_pdm_states[ui32Module].prefix.s.bInit)
    e28e:	f3c2 0400 	ubfx	r4, r2, #0, #1
    e292:	b2e0      	uxtb	r0, r4
    e294:	b970      	cbnz	r0, e2b4 <am_hal_pdm_initialize+0x30>
    }

    //
    // Initialize the handle.
    //
    g_am_hal_pdm_states[ui32Module].prefix.s.bInit = true;
    e296:	f042 0201 	orr.w	r2, r2, #1
    e29a:	70da      	strb	r2, [r3, #3]
    g_am_hal_pdm_states[ui32Module].prefix.s.magic = AM_HAL_MAGIC_PDM;
    e29c:	681a      	ldr	r2, [r3, #0]
    e29e:	4d09      	ldr	r5, [pc, #36]	; (e2c4 <am_hal_pdm_initialize+0x40>)
    g_am_hal_pdm_states[ui32Module].ui32Module = ui32Module;
    g_am_hal_pdm_states[ui32Module].sRegState.bValid = false;
    e2a0:	711c      	strb	r4, [r3, #4]
    g_am_hal_pdm_states[ui32Module].prefix.s.magic = AM_HAL_MAGIC_PDM;
    e2a2:	f365 0217 	bfi	r2, r5, #0, #24
    e2a6:	601a      	str	r2, [r3, #0]
    g_am_hal_pdm_states[ui32Module].ui32Module = ui32Module;
    e2a8:	6098      	str	r0, [r3, #8]

    //
    // Return the status.
    //
    return AM_HAL_STATUS_SUCCESS;
}
    e2aa:	bc30      	pop	{r4, r5}
    *ppHandle = (void *)&g_am_hal_pdm_states[ui32Module];
    e2ac:	600b      	str	r3, [r1, #0]
}
    e2ae:	4770      	bx	lr
        return AM_HAL_STATUS_OUT_OF_RANGE;
    e2b0:	2005      	movs	r0, #5
    e2b2:	4770      	bx	lr
        return AM_HAL_STATUS_INVALID_OPERATION;
    e2b4:	2007      	movs	r0, #7
}
    e2b6:	bc30      	pop	{r4, r5}
    e2b8:	4770      	bx	lr
        return AM_HAL_STATUS_INVALID_ARG;
    e2ba:	2006      	movs	r0, #6
}
    e2bc:	4770      	bx	lr
    e2be:	bf00      	nop
    e2c0:	100143f4 	.word	0x100143f4
    e2c4:	00f956e2 	.word	0x00f956e2

0000e2c8 <am_hal_pdm_power_control>:
//*****************************************************************************
uint32_t
am_hal_pdm_power_control(void *pHandle,
                         am_hal_sysctrl_power_state_e ePowerState,
                         bool bRetainState)
{
    e2c8:	b5f0      	push	{r4, r5, r6, r7, lr}
                                                (AM_HAL_PWRCTRL_PERIPH_PDM +
                                                 ui32Module));
    //
    // Check the handle.
    //
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e2ca:	6803      	ldr	r3, [r0, #0]
    e2cc:	4c1d      	ldr	r4, [pc, #116]	; (e344 <am_hal_pdm_power_control+0x7c>)
    e2ce:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    e2d2:	42a3      	cmp	r3, r4
{
    e2d4:	b083      	sub	sp, #12
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e2d6:	d10f      	bne.n	e2f8 <am_hal_pdm_power_control+0x30>
    am_hal_pwrctrl_periph_e ePDMPowerModule = ((am_hal_pwrctrl_periph_e)
    e2d8:	6883      	ldr	r3, [r0, #8]
    e2da:	330d      	adds	r3, #13
    e2dc:	4617      	mov	r7, r2
    e2de:	460c      	mov	r4, r1
    e2e0:	4606      	mov	r6, r0
    e2e2:	b2dd      	uxtb	r5, r3

    //
    // Decode the requested power state and update PDM operation accordingly.
    //
    switch (ePowerState)
    e2e4:	b171      	cbz	r1, e304 <am_hal_pdm_power_control+0x3c>
    e2e6:	2902      	cmp	r1, #2
    e2e8:	d809      	bhi.n	e2fe <am_hal_pdm_power_control+0x36>
        //
        // Turn off the PDM.
        //
        case AM_HAL_SYSCTRL_NORMALSLEEP:
        case AM_HAL_SYSCTRL_DEEPSLEEP:
            if (bRetainState)
    e2ea:	b9d2      	cbnz	r2, e322 <am_hal_pdm_power_control+0x5a>
            }

            //
            // Disable power control.
            //
            am_hal_pwrctrl_periph_disable(ePDMPowerModule);
    e2ec:	4628      	mov	r0, r5
    e2ee:	f004 fb11 	bl	12914 <am_hal_pwrctrl_periph_disable>
    }

    //
    // Return the status.
    //
    return AM_HAL_STATUS_SUCCESS;
    e2f2:	2000      	movs	r0, #0
}
    e2f4:	b003      	add	sp, #12
    e2f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e2f8:	2002      	movs	r0, #2
}
    e2fa:	b003      	add	sp, #12
    e2fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
            return AM_HAL_STATUS_INVALID_ARG;
    e2fe:	2006      	movs	r0, #6
}
    e300:	b003      	add	sp, #12
    e302:	bdf0      	pop	{r4, r5, r6, r7, pc}
            if (bRetainState && !pState->sRegState.bValid)
    e304:	b1b2      	cbz	r2, e334 <am_hal_pdm_power_control+0x6c>
    e306:	7903      	ldrb	r3, [r0, #4]
    e308:	b1cb      	cbz	r3, e33e <am_hal_pdm_power_control+0x76>
            am_hal_pwrctrl_periph_enable(ePDMPowerModule);
    e30a:	4628      	mov	r0, r5
    e30c:	f004 fad8 	bl	128c0 <am_hal_pwrctrl_periph_enable>
                AM_CRITICAL_BEGIN;
    e310:	f004 f9e2 	bl	126d8 <am_hal_interrupt_master_disable>
    e314:	9000      	str	r0, [sp, #0]
                AM_CRITICAL_END;
    e316:	9800      	ldr	r0, [sp, #0]
                pState->sRegState.bValid = false;
    e318:	7134      	strb	r4, [r6, #4]
                AM_CRITICAL_END;
    e31a:	f004 f9e1 	bl	126e0 <am_hal_interrupt_master_set>
    return AM_HAL_STATUS_SUCCESS;
    e31e:	4620      	mov	r0, r4
    e320:	e7eb      	b.n	e2fa <am_hal_pdm_power_control+0x32>
                AM_CRITICAL_BEGIN;
    e322:	f004 f9d9 	bl	126d8 <am_hal_interrupt_master_disable>
                pState->sRegState.bValid = true;
    e326:	2301      	movs	r3, #1
                AM_CRITICAL_BEGIN;
    e328:	9001      	str	r0, [sp, #4]
                AM_CRITICAL_END;
    e32a:	9801      	ldr	r0, [sp, #4]
                pState->sRegState.bValid = true;
    e32c:	7133      	strb	r3, [r6, #4]
                AM_CRITICAL_END;
    e32e:	f004 f9d7 	bl	126e0 <am_hal_interrupt_master_set>
    e332:	e7db      	b.n	e2ec <am_hal_pdm_power_control+0x24>
            am_hal_pwrctrl_periph_enable(ePDMPowerModule);
    e334:	4628      	mov	r0, r5
    e336:	f004 fac3 	bl	128c0 <am_hal_pwrctrl_periph_enable>
    return AM_HAL_STATUS_SUCCESS;
    e33a:	4638      	mov	r0, r7
    e33c:	e7dd      	b.n	e2fa <am_hal_pdm_power_control+0x32>
                return AM_HAL_STATUS_INVALID_OPERATION;
    e33e:	2007      	movs	r0, #7
    e340:	e7db      	b.n	e2fa <am_hal_pdm_power_control+0x32>
    e342:	bf00      	nop
    e344:	01f956e2 	.word	0x01f956e2

0000e348 <am_hal_pdm_configure>:
uint32_t
am_hal_pdm_configure(void *pHandle, am_hal_pdm_config_t *psConfig)
{
    am_hal_pdm_state_t *pState = (am_hal_pdm_state_t *) pHandle;
    uint32_t ui32Module = pState->ui32Module;
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e348:	6803      	ldr	r3, [r0, #0]
    e34a:	4a3f      	ldr	r2, [pc, #252]	; (e448 <am_hal_pdm_configure+0x100>)
    e34c:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    e350:	4293      	cmp	r3, r2
    e352:	d001      	beq.n	e358 <am_hal_pdm_configure+0x10>
    e354:	2002      	movs	r0, #2
    delay_us(100);

    PDMn(ui32Module)->VCFG_b.RSTB = PDM_VCFG_RSTB_NORM;

    return AM_HAL_STATUS_SUCCESS;
}
    e356:	4770      	bx	lr
{
    e358:	b510      	push	{r4, lr}
    PDMn(ui32Module)->PCFG_b.SOFTMUTE = psConfig->bSoftMute;
    e35a:	4c3c      	ldr	r4, [pc, #240]	; (e44c <am_hal_pdm_configure+0x104>)
    e35c:	7f4a      	ldrb	r2, [r1, #29]
    e35e:	6823      	ldr	r3, [r4, #0]
    e360:	f362 0341 	bfi	r3, r2, #1, #1
    e364:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.CYCLES = psConfig->ui32GainChangeDelay;
    e366:	6823      	ldr	r3, [r4, #0]
    e368:	698a      	ldr	r2, [r1, #24]
    e36a:	f362 0384 	bfi	r3, r2, #2, #3
    e36e:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.HPCUTOFF = psConfig->ui32HighPassCutoff;
    e370:	6823      	ldr	r3, [r4, #0]
    e372:	68ca      	ldr	r2, [r1, #12]
    e374:	f362 1348 	bfi	r3, r2, #5, #4
    e378:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.ADCHPD = psConfig->bHighPassEnable;
    e37a:	6823      	ldr	r3, [r4, #0]
    e37c:	7a0a      	ldrb	r2, [r1, #8]
    e37e:	f362 2349 	bfi	r3, r2, #9, #1
    e382:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.SINCRATE = psConfig->ui32DecimationRate;
    e384:	6823      	ldr	r3, [r4, #0]
    e386:	684a      	ldr	r2, [r1, #4]
    e388:	f362 2390 	bfi	r3, r2, #10, #7
    e38c:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.MCLKDIV = psConfig->eClkDivider;
    e38e:	6823      	ldr	r3, [r4, #0]
    e390:	780a      	ldrb	r2, [r1, #0]
    e392:	f362 4352 	bfi	r3, r2, #17, #2
    e396:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.PGALEFT = psConfig->eLeftGain;
    e398:	6823      	ldr	r3, [r4, #0]
    e39a:	784a      	ldrb	r2, [r1, #1]
    e39c:	f362 5359 	bfi	r3, r2, #21, #5
    e3a0:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.PGARIGHT = psConfig->eRightGain;
    e3a2:	7888      	ldrb	r0, [r1, #2]
    e3a4:	6823      	ldr	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.LRSWAP = psConfig->bLRSwap;
    e3a6:	7f8a      	ldrb	r2, [r1, #30]
    PDMn(ui32Module)->PCFG_b.PGARIGHT = psConfig->eRightGain;
    e3a8:	f360 639e 	bfi	r3, r0, #26, #5
    e3ac:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.LRSWAP = psConfig->bLRSwap;
    e3ae:	6823      	ldr	r3, [r4, #0]
    e3b0:	f362 73df 	bfi	r3, r2, #31, #1
    e3b4:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.PDMCOREEN = PDM_PCFG_PDMCOREEN_EN;
    e3b6:	6823      	ldr	r3, [r4, #0]
    e3b8:	f043 0301 	orr.w	r3, r3, #1
    e3bc:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->VCFG_b.PDMCLKEN = PDM_VCFG_PDMCLKEN_DIS;
    e3be:	6863      	ldr	r3, [r4, #4]
    e3c0:	f36f 639a 	bfc	r3, #26, #1
    e3c4:	6063      	str	r3, [r4, #4]
    PDMn(ui32Module)->VCFG_b.IOCLKEN = PDM_VCFG_IOCLKEN_DIS;
    e3c6:	6863      	ldr	r3, [r4, #4]
    e3c8:	f36f 73df 	bfc	r3, #31, #1
    e3cc:	6063      	str	r3, [r4, #4]
    PDMn(ui32Module)->VCFG_b.RSTB = PDM_VCFG_RSTB_RESET;
    e3ce:	6863      	ldr	r3, [r4, #4]
    e3d0:	f36f 739e 	bfc	r3, #30, #1
    e3d4:	6063      	str	r3, [r4, #4]
    PDMn(ui32Module)->VCFG_b.CHSET = psConfig->ePCMChannels;
    e3d6:	6863      	ldr	r3, [r4, #4]
    e3d8:	7d4a      	ldrb	r2, [r1, #21]
    e3da:	f362 03c4 	bfi	r3, r2, #3, #2
    e3de:	6063      	str	r3, [r4, #4]
    PDMn(ui32Module)->VCFG_b.PCMPACK = psConfig->bDataPacking;
    e3e0:	6863      	ldr	r3, [r4, #4]
    e3e2:	7d0a      	ldrb	r2, [r1, #20]
    e3e4:	f362 2308 	bfi	r3, r2, #8, #1
    e3e8:	6063      	str	r3, [r4, #4]
    PDMn(ui32Module)->VCFG_b.SELAP = psConfig->ePDMClkSource;
    e3ea:	6863      	ldr	r3, [r4, #4]
    e3ec:	7c8a      	ldrb	r2, [r1, #18]
    e3ee:	f362 4310 	bfi	r3, r2, #16, #1
    e3f2:	6063      	str	r3, [r4, #4]
    PDMn(ui32Module)->VCFG_b.DMICKDEL = psConfig->bPDMSampleDelay;
    e3f4:	6863      	ldr	r3, [r4, #4]
    e3f6:	7cca      	ldrb	r2, [r1, #19]
    e3f8:	f362 4351 	bfi	r3, r2, #17, #1
    e3fc:	6063      	str	r3, [r4, #4]
    PDMn(ui32Module)->VCFG_b.BCLKINV = psConfig->bInvertI2SBCLK;
    e3fe:	7c4a      	ldrb	r2, [r1, #17]
    e400:	6863      	ldr	r3, [r4, #4]
    e402:	f362 43d3 	bfi	r3, r2, #19, #1
    e406:	6063      	str	r3, [r4, #4]
    PDMn(ui32Module)->VCFG_b.I2SEN = psConfig->bI2SEnable;
    e408:	7f0a      	ldrb	r2, [r1, #28]
    e40a:	6863      	ldr	r3, [r4, #4]
    e40c:	f362 5314 	bfi	r3, r2, #20, #1
    e410:	6063      	str	r3, [r4, #4]
    PDMn(ui32Module)->VCFG_b.PDMCLKSEL = psConfig->ePDMClkSpeed;
    e412:	7c0a      	ldrb	r2, [r1, #16]
    e414:	6863      	ldr	r3, [r4, #4]
{
    e416:	b084      	sub	sp, #16
    PDMn(ui32Module)->VCFG_b.PDMCLKSEL = psConfig->ePDMClkSpeed;
    e418:	f362 63dd 	bfi	r3, r2, #27, #3
    e41c:	6063      	str	r3, [r4, #4]
    delay_us(100);
    e41e:	a801      	add	r0, sp, #4
    e420:	f004 f908 	bl	12634 <am_hal_clkgen_status_get>
    e424:	9801      	ldr	r0, [sp, #4]
    e426:	4b0a      	ldr	r3, [pc, #40]	; (e450 <am_hal_pdm_configure+0x108>)
    e428:	fba3 3000 	umull	r3, r0, r3, r0
    e42c:	0c80      	lsrs	r0, r0, #18
    e42e:	2364      	movs	r3, #100	; 0x64
    e430:	fb03 f000 	mul.w	r0, r3, r0
    e434:	f004 f91c 	bl	12670 <am_hal_flash_delay>
    PDMn(ui32Module)->VCFG_b.RSTB = PDM_VCFG_RSTB_NORM;
    e438:	6863      	ldr	r3, [r4, #4]
    return AM_HAL_STATUS_SUCCESS;
    e43a:	2000      	movs	r0, #0
    PDMn(ui32Module)->VCFG_b.RSTB = PDM_VCFG_RSTB_NORM;
    e43c:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    e440:	6063      	str	r3, [r4, #4]
}
    e442:	b004      	add	sp, #16
    e444:	bd10      	pop	{r4, pc}
    e446:	bf00      	nop
    e448:	01f956e2 	.word	0x01f956e2
    e44c:	50011000 	.word	0x50011000
    e450:	165e9f81 	.word	0x165e9f81

0000e454 <am_hal_pdm_enable>:
uint32_t
am_hal_pdm_enable(void *pHandle)
{
    am_hal_pdm_state_t *pState = (am_hal_pdm_state_t *) pHandle;
    uint32_t ui32Module = pState->ui32Module;
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e454:	6803      	ldr	r3, [r0, #0]
    e456:	4a09      	ldr	r2, [pc, #36]	; (e47c <am_hal_pdm_enable+0x28>)
    e458:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    e45c:	4293      	cmp	r3, r2
    e45e:	d10a      	bne.n	e476 <am_hal_pdm_enable+0x22>

    PDMn(ui32Module)->VCFG_b.IOCLKEN = PDM_VCFG_IOCLKEN_EN;
    e460:	4b07      	ldr	r3, [pc, #28]	; (e480 <am_hal_pdm_enable+0x2c>)
    e462:	685a      	ldr	r2, [r3, #4]
    e464:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
    e468:	605a      	str	r2, [r3, #4]
    PDMn(ui32Module)->VCFG_b.PDMCLKEN = PDM_VCFG_PDMCLKEN_EN;
    e46a:	685a      	ldr	r2, [r3, #4]
    e46c:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
    e470:	605a      	str	r2, [r3, #4]

    return AM_HAL_STATUS_SUCCESS;
    e472:	2000      	movs	r0, #0
    e474:	4770      	bx	lr
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e476:	2002      	movs	r0, #2
}
    e478:	4770      	bx	lr
    e47a:	bf00      	nop
    e47c:	01f956e2 	.word	0x01f956e2
    e480:	50011000 	.word	0x50011000

0000e484 <am_hal_pdm_dma_start>:
uint32_t
am_hal_pdm_dma_start(void *pHandle, am_hal_pdm_transfer_t *pDmaCfg)
{
    am_hal_pdm_state_t *pState = (am_hal_pdm_state_t *) pHandle;
    uint32_t ui32Module = pState->ui32Module;
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e484:	6803      	ldr	r3, [r0, #0]
    e486:	4a22      	ldr	r2, [pc, #136]	; (e510 <am_hal_pdm_dma_start+0x8c>)
    e488:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    e48c:	4293      	cmp	r3, r2
    e48e:	d113      	bne.n	e4b8 <am_hal_pdm_dma_start+0x34>
    // user asked for.
    //
    uint32_t ui32Threshold = 0;
    uint32_t ui32NumReloads = 1;

    for (ui32NumReloads = 1; ui32NumReloads < pDmaCfg->ui32TotalCount; ui32NumReloads++)
    e490:	684a      	ldr	r2, [r1, #4]
    e492:	2a01      	cmp	r2, #1
    e494:	d938      	bls.n	e508 <am_hal_pdm_dma_start+0x84>
{
    e496:	b410      	push	{r4}
    for (ui32NumReloads = 1; ui32NumReloads < pDmaCfg->ui32TotalCount; ui32NumReloads++)
    e498:	2301      	movs	r3, #1
    {
        //
        // Check to make sure the total count is evenly divisible into chunks
        // that are smaller than the maximum threshold size.
        //
        if (((pDmaCfg->ui32TotalCount % ui32NumReloads) == 0) &&
    e49a:	fbb2 f4f3 	udiv	r4, r2, r3
    e49e:	fb03 2014 	mls	r0, r3, r4, r2
    for (ui32NumReloads = 1; ui32NumReloads < pDmaCfg->ui32TotalCount; ui32NumReloads++)
    e4a2:	3301      	adds	r3, #1
        if (((pDmaCfg->ui32TotalCount % ui32NumReloads) == 0) &&
    e4a4:	b908      	cbnz	r0, e4aa <am_hal_pdm_dma_start+0x26>
    e4a6:	2c1f      	cmp	r4, #31
    e4a8:	d908      	bls.n	e4bc <am_hal_pdm_dma_start+0x38>
    for (ui32NumReloads = 1; ui32NumReloads < pDmaCfg->ui32TotalCount; ui32NumReloads++)
    e4aa:	429a      	cmp	r2, r3
    e4ac:	d1f5      	bne.n	e49a <am_hal_pdm_dma_start+0x16>
    //
    // If we didn't find a threshold that will work, throw an error.
    //
    if (ui32Threshold == 0)
    {
        return AM_HAL_PDM_STATUS_BAD_TOTALCOUNT;
    e4ae:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
//
//    PDMn(ui32Module)->VCFG_b.RSTB = PDM_VCFG_RSTB_NORM;
//    PDMn(ui32Module)->VCFG_b.PDMCLKEN = 1;

    return AM_HAL_STATUS_SUCCESS;
}
    e4b2:	f85d 4b04 	ldr.w	r4, [sp], #4
    e4b6:	4770      	bx	lr
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e4b8:	2002      	movs	r0, #2
    e4ba:	4770      	bx	lr
    if (ui32Threshold == 0)
    e4bc:	2c00      	cmp	r4, #0
    e4be:	d0f6      	beq.n	e4ae <am_hal_pdm_dma_start+0x2a>
    PDMn(ui32Module)->FIFOTHR = ui32Threshold;
    e4c0:	4b14      	ldr	r3, [pc, #80]	; (e514 <am_hal_pdm_dma_start+0x90>)
    e4c2:	615c      	str	r4, [r3, #20]
    PDMn(ui32Module)->DMACFG = 0;
    e4c4:	f8c3 0280 	str.w	r0, [r3, #640]	; 0x280
    PDMn(ui32Module)->DMACFG_b.DMAPRI = PDM_DMACFG_DMAPRI_LOW;
    e4c8:	f8b3 4280 	ldrh.w	r4, [r3, #640]	; 0x280
    e4cc:	f360 2408 	bfi	r4, r0, #8, #1
    e4d0:	f8a3 4280 	strh.w	r4, [r3, #640]	; 0x280
    PDMn(ui32Module)->DMACFG_b.DMADIR = PDM_DMACFG_DMADIR_P2M;
    e4d4:	f8b3 4280 	ldrh.w	r4, [r3, #640]	; 0x280
    e4d8:	f360 0482 	bfi	r4, r0, #2, #1
    e4dc:	f8a3 4280 	strh.w	r4, [r3, #640]	; 0x280
    PDMn(ui32Module)->DMATOTCOUNT = pDmaCfg->ui32TotalCount;
    e4e0:	f8c3 2288 	str.w	r2, [r3, #648]	; 0x288
    PDMn(ui32Module)->DMATARGADDR = pDmaCfg->ui32TargetAddr;
    e4e4:	680a      	ldr	r2, [r1, #0]
    e4e6:	f8c3 228c 	str.w	r2, [r3, #652]	; 0x28c
    PDMn(ui32Module)->DMATRIGEN_b.DTHR = 1;
    e4ea:	f893 2240 	ldrb.w	r2, [r3, #576]	; 0x240
    e4ee:	f042 0201 	orr.w	r2, r2, #1
    e4f2:	f883 2240 	strb.w	r2, [r3, #576]	; 0x240
    PDMn(ui32Module)->DMACFG_b.DMAEN = PDM_DMACFG_DMAEN_EN;
    e4f6:	f8b3 2280 	ldrh.w	r2, [r3, #640]	; 0x280
    e4fa:	f042 0201 	orr.w	r2, r2, #1
    e4fe:	f8a3 2280 	strh.w	r2, [r3, #640]	; 0x280
}
    e502:	f85d 4b04 	ldr.w	r4, [sp], #4
    e506:	4770      	bx	lr
        return AM_HAL_PDM_STATUS_BAD_TOTALCOUNT;
    e508:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
}
    e50c:	4770      	bx	lr
    e50e:	bf00      	nop
    e510:	01f956e2 	.word	0x01f956e2
    e514:	50011000 	.word	0x50011000

0000e518 <am_hal_pdm_fifo_flush>:
uint32_t
am_hal_pdm_fifo_flush(void *pHandle)
{
    am_hal_pdm_state_t *pState = (am_hal_pdm_state_t *) pHandle;
    uint32_t ui32Module = pState->ui32Module;
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e518:	6803      	ldr	r3, [r0, #0]
    e51a:	4a06      	ldr	r2, [pc, #24]	; (e534 <am_hal_pdm_fifo_flush+0x1c>)
    e51c:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    e520:	4293      	cmp	r3, r2
    e522:	d104      	bne.n	e52e <am_hal_pdm_fifo_flush+0x16>

    PDMn(ui32Module)->FIFOFLUSH = 1;
    e524:	4b04      	ldr	r3, [pc, #16]	; (e538 <am_hal_pdm_fifo_flush+0x20>)
    e526:	2201      	movs	r2, #1
    e528:	611a      	str	r2, [r3, #16]

    return AM_HAL_STATUS_SUCCESS;
    e52a:	2000      	movs	r0, #0
    e52c:	4770      	bx	lr
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e52e:	2002      	movs	r0, #2
}
    e530:	4770      	bx	lr
    e532:	bf00      	nop
    e534:	01f956e2 	.word	0x01f956e2
    e538:	50011000 	.word	0x50011000

0000e53c <am_hal_pdm_interrupt_enable>:
    uint32_t ui32Module = pState->ui32Module;

    //
    // Check the handle.
    //
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e53c:	6803      	ldr	r3, [r0, #0]
    e53e:	4a07      	ldr	r2, [pc, #28]	; (e55c <am_hal_pdm_interrupt_enable+0x20>)
    e540:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    e544:	4293      	cmp	r3, r2
    e546:	d107      	bne.n	e558 <am_hal_pdm_interrupt_enable+0x1c>

    PDMn(ui32Module)->INTEN |= ui32IntMask;
    e548:	4a05      	ldr	r2, [pc, #20]	; (e560 <am_hal_pdm_interrupt_enable+0x24>)
    e54a:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
    e54e:	4319      	orrs	r1, r3
    e550:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200

    return AM_HAL_STATUS_SUCCESS;
    e554:	2000      	movs	r0, #0
    e556:	4770      	bx	lr
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e558:	2002      	movs	r0, #2
}
    e55a:	4770      	bx	lr
    e55c:	01f956e2 	.word	0x01f956e2
    e560:	50011000 	.word	0x50011000

0000e564 <am_hal_pdm_interrupt_clear>:
    uint32_t ui32Module = pState->ui32Module;

    //
    // Check the handle.
    //
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e564:	6803      	ldr	r3, [r0, #0]
    e566:	4a05      	ldr	r2, [pc, #20]	; (e57c <am_hal_pdm_interrupt_clear+0x18>)
    e568:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    e56c:	4293      	cmp	r3, r2

    PDMn(ui32Module)->INTCLR = ui32IntMask;
    e56e:	bf03      	ittte	eq
    e570:	4b03      	ldreq	r3, [pc, #12]	; (e580 <am_hal_pdm_interrupt_clear+0x1c>)

    return AM_HAL_STATUS_SUCCESS;
    e572:	2000      	moveq	r0, #0
    PDMn(ui32Module)->INTCLR = ui32IntMask;
    e574:	f8c3 1208 	streq.w	r1, [r3, #520]	; 0x208
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e578:	2002      	movne	r0, #2
}
    e57a:	4770      	bx	lr
    e57c:	01f956e2 	.word	0x01f956e2
    e580:	50011000 	.word	0x50011000

0000e584 <am_hal_pdm_interrupt_status_get>:
    uint32_t ui32Module = pState->ui32Module;

    //
    // Check the handle.
    //
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e584:	6803      	ldr	r3, [r0, #0]
    e586:	480c      	ldr	r0, [pc, #48]	; (e5b8 <am_hal_pdm_interrupt_status_get+0x34>)
    e588:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    e58c:	4283      	cmp	r3, r0
    e58e:	d110      	bne.n	e5b2 <am_hal_pdm_interrupt_status_get+0x2e>

    //
    // If requested, only return the interrupts that are enabled.
    //
    if ( bEnabledOnly )
    e590:	b92a      	cbnz	r2, e59e <am_hal_pdm_interrupt_status_get+0x1a>
        *pui32Status = PDMn(ui32Module)->INTSTAT;
        *pui32Status &= PDMn(ui32Module)->INTEN;
    }
    else
    {
        *pui32Status = PDMn(ui32Module)->INTSTAT;
    e592:	4b0a      	ldr	r3, [pc, #40]	; (e5bc <am_hal_pdm_interrupt_status_get+0x38>)
    e594:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
    e598:	600b      	str	r3, [r1, #0]
    }

    return AM_HAL_STATUS_SUCCESS;
    e59a:	4610      	mov	r0, r2
    e59c:	4770      	bx	lr
        *pui32Status = PDMn(ui32Module)->INTSTAT;
    e59e:	4a07      	ldr	r2, [pc, #28]	; (e5bc <am_hal_pdm_interrupt_status_get+0x38>)
    e5a0:	f8d2 3204 	ldr.w	r3, [r2, #516]	; 0x204
    e5a4:	600b      	str	r3, [r1, #0]
        *pui32Status &= PDMn(ui32Module)->INTEN;
    e5a6:	f8d2 2200 	ldr.w	r2, [r2, #512]	; 0x200
    e5aa:	4013      	ands	r3, r2
    e5ac:	600b      	str	r3, [r1, #0]
    return AM_HAL_STATUS_SUCCESS;
    e5ae:	2000      	movs	r0, #0
    e5b0:	4770      	bx	lr
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e5b2:	2002      	movs	r0, #2
}
    e5b4:	4770      	bx	lr
    e5b6:	bf00      	nop
    e5b8:	01f956e2 	.word	0x01f956e2
    e5bc:	50011000 	.word	0x50011000

0000e5c0 <am_hal_gpio_pinconfig>:
    uint32_t ui32Padreg, ui32AltPadCfg, ui32GPCfg;
    uint32_t ui32Funcsel, ui32PowerSw;
    bool bClearEnable = false;

#ifdef AM_HAL_ENABLE_API_VALIDATION
    if ( ui32Pin > 49 )
    e5c0:	2831      	cmp	r0, #49	; 0x31
    e5c2:	f200 80c2 	bhi.w	e74a <am_hal_gpio_pinconfig+0x18a>
{
    e5c6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ui32GPCfg = ui32Padreg = ui32AltPadCfg = 0;

    //
    // Get the requested function and/or power switch.
    //
    ui32Funcsel = bfGpioCfg.uFuncSel;
    e5ca:	f001 0207 	and.w	r2, r1, #7
    ui32Padreg |= ui32Funcsel << PADREG_FLD_FNSEL_S;

    //
    // Check for invalid configuration requests.
    //
    if ( bfGpioCfg.ePullup != AM_HAL_GPIO_PIN_PULLUP_NONE )
    e5ce:	f011 07e0 	ands.w	r7, r1, #224	; 0xe0
{
    e5d2:	b087      	sub	sp, #28
    ui32Padreg |= ui32Funcsel << PADREG_FLD_FNSEL_S;
    e5d4:	ea4f 03c2 	mov.w	r3, r2, lsl #3
    ui32PowerSw = bfGpioCfg.ePowerSw;
    e5d8:	f3c1 04c1 	ubfx	r4, r1, #3, #2
    if ( bfGpioCfg.ePullup != AM_HAL_GPIO_PIN_PULLUP_NONE )
    e5dc:	d011      	beq.n	e602 <am_hal_gpio_pinconfig+0x42>
        ui32Padreg |= (0x1 << PADREG_FLD_PULLUP_S);

        //
        // Check for specific pullup or pulldown settings.
        //
        if ( (bfGpioCfg.ePullup >= AM_HAL_GPIO_PIN_PULLUP_1_5K) &&
    e5de:	f3c1 1642 	ubfx	r6, r1, #5, #3
    e5e2:	1db5      	adds	r5, r6, #6
    e5e4:	f005 0507 	and.w	r5, r5, #7
    e5e8:	2d03      	cmp	r5, #3
        ui32Padreg |= (0x1 << PADREG_FLD_PULLUP_S);
    e5ea:	f043 0301 	orr.w	r3, r3, #1
        if ( (bfGpioCfg.ePullup >= AM_HAL_GPIO_PIN_PULLUP_1_5K) &&
    e5ee:	f200 80ae 	bhi.w	e74e <am_hal_gpio_pinconfig+0x18e>
             (bfGpioCfg.ePullup <= AM_HAL_GPIO_PIN_PULLUP_24K) )
        {
            ui32Padreg |= ((bfGpioCfg.ePullup - AM_HAL_GPIO_PIN_PULLUP_1_5K) <<
                           PADREG_FLD_76_S);
#ifdef AM_HAL_ENABLE_API_VALIDATION
            if ( !(g_ui8Bit76Capabilities[ui32Pin] & CAP_PUP) )
    e5f2:	4d85      	ldr	r5, [pc, #532]	; (e808 <am_hal_gpio_pinconfig+0x248>)
    e5f4:	5c2d      	ldrb	r5, [r5, r0]
    e5f6:	07ef      	lsls	r7, r5, #31
    e5f8:	f140 80b4 	bpl.w	e764 <am_hal_gpio_pinconfig+0x1a4>
            ui32Padreg |= ((bfGpioCfg.ePullup - AM_HAL_GPIO_PIN_PULLUP_1_5K) <<
    e5fc:	3e02      	subs	r6, #2
    e5fe:	ea43 1386 	orr.w	r3, r3, r6, lsl #6
    }

    //
    // Check if requesting a power switch pin
    //
    if ( ui32PowerSw != AM_HAL_GPIO_PIN_POWERSW_NONE )
    e602:	2c00      	cmp	r4, #0
    e604:	f040 8096 	bne.w	e734 <am_hal_gpio_pinconfig+0x174>
    }

    //
    // Depending on the selected pin and FNSEL, determine if INPEN needs to be set.
    //
    ui32Padreg |= (g_ui8Inpen[ui32Pin] & (1 << ui32Funcsel)) ? (1 << PADREG_FLD_INPEN_S) : 0;
    e608:	4d80      	ldr	r5, [pc, #512]	; (e80c <am_hal_gpio_pinconfig+0x24c>)

    //
    // Configure ui32GpCfg based on whether nCE requested.
    //
    if ( g_ui8nCEpins[ui32Pin] == ui32Funcsel )
    e60a:	4c81      	ldr	r4, [pc, #516]	; (e810 <am_hal_gpio_pinconfig+0x250>)
    ui32Padreg |= (g_ui8Inpen[ui32Pin] & (1 << ui32Funcsel)) ? (1 << PADREG_FLD_INPEN_S) : 0;
    e60c:	5c2d      	ldrb	r5, [r5, r0]
    if ( g_ui8nCEpins[ui32Pin] == ui32Funcsel )
    e60e:	5c24      	ldrb	r4, [r4, r0]
    ui32Padreg |= (g_ui8Inpen[ui32Pin] & (1 << ui32Funcsel)) ? (1 << PADREG_FLD_INPEN_S) : 0;
    e610:	4115      	asrs	r5, r2
    e612:	006d      	lsls	r5, r5, #1
    e614:	f005 0502 	and.w	r5, r5, #2
    if ( g_ui8nCEpins[ui32Pin] == ui32Funcsel )
    e618:	4294      	cmp	r4, r2
    ui32Padreg |= (g_ui8Inpen[ui32Pin] & (1 << ui32Funcsel)) ? (1 << PADREG_FLD_INPEN_S) : 0;
    e61a:	ea45 0503 	orr.w	r5, r5, r3
    if ( g_ui8nCEpins[ui32Pin] == ui32Funcsel )
    e61e:	f000 80b0 	beq.w	e782 <am_hal_gpio_pinconfig+0x1c2>
        //  [INTD(1):OUTCFG(2):INCFG(1)].
        // Bit0 of eIntDir maps to GPIOCFG.INTD  (b3).
        // Bit1 of eIntDir maps to GPIOCFG.INCFG (b0).
        //
        ui32GPCfg |= (bfGpioCfg.eGPOutcfg << GPIOCFG_FLD_OUTCFG_S)              |
                     (((bfGpioCfg.eIntDir >> 0) & 0x1) << GPIOCFG_FLD_INTD_S)   |
    e622:	f3c1 3341 	ubfx	r3, r1, #13, #2
                     (((bfGpioCfg.eIntDir >> 1) & 0x1) << GPIOCFG_FLD_INCFG_S);

        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
    e626:	f3c1 2407 	ubfx	r4, r1, #8, #8
                     (((bfGpioCfg.eIntDir >> 1) & 0x1) << GPIOCFG_FLD_INCFG_S);
    e62a:	105a      	asrs	r2, r3, #1
        ui32GPCfg |= (bfGpioCfg.eGPOutcfg << GPIOCFG_FLD_OUTCFG_S)              |
    e62c:	f3c1 2681 	ubfx	r6, r1, #10, #2
                     (((bfGpioCfg.eIntDir >> 0) & 0x1) << GPIOCFG_FLD_INTD_S)   |
    e630:	00db      	lsls	r3, r3, #3
        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
    e632:	f004 070c 	and.w	r7, r4, #12
                     (((bfGpioCfg.eIntDir >> 0) & 0x1) << GPIOCFG_FLD_INTD_S)   |
    e636:	ea42 0646 	orr.w	r6, r2, r6, lsl #1
    e63a:	f003 0308 	and.w	r3, r3, #8
        ui32Padreg |= (bfGpioCfg.eGPInput << PADREG_FLD_INPEN_S);
    e63e:	f3c1 3200 	ubfx	r2, r1, #12, #1
        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
    e642:	2f04      	cmp	r7, #4
                     (((bfGpioCfg.eIntDir >> 0) & 0x1) << GPIOCFG_FLD_INTD_S)   |
    e644:	ea46 0603 	orr.w	r6, r6, r3
        ui32Padreg |= (bfGpioCfg.eGPInput << PADREG_FLD_INPEN_S);
    e648:	ea45 0542 	orr.w	r5, r5, r2, lsl #1
        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
    e64c:	f000 8093 	beq.w	e776 <am_hal_gpio_pinconfig+0x1b6>
    ui32B = *((uint32_t*)cfg2);
    e650:	4b70      	ldr	r3, [pc, #448]	; (e814 <am_hal_gpio_pinconfig+0x254>)
        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
    e652:	681b      	ldr	r3, [r3, #0]
    e654:	1acb      	subs	r3, r1, r3
    e656:	fab3 f383 	clz	r3, r3
    e65a:	095b      	lsrs	r3, r3, #5
        //  use when GPIO interrupts are not in use and can be used when no
        //  eIntDir setting is provided.
        // If eIntDir is provided, eGPRdZero is ignored and can only be
        //  achieved via the AM_HAL_GPIO_PIN_INTDIR_NONE setting.
        //
        if ( bfGpioCfg.eIntDir == 0 )
    e65c:	f014 0f60 	tst.w	r4, #96	; 0x60
        {
            ui32GPCfg &= ~(1 << GPIOCFG_FLD_INCFG_S);
            ui32GPCfg |= (bfGpioCfg.eGPRdZero << GPIOCFG_FLD_INCFG_S);
    e660:	bf04      	itt	eq
    e662:	f3c1 32c0 	ubfxeq	r2, r1, #15, #1
    e666:	f362 0600 	bfieq	r6, r2, #0, #1
    e66a:	ea4f 0e80 	mov.w	lr, r0, lsl #2
        }
    }

    switch ( bfGpioCfg.eDriveStrength )
    e66e:	f3c1 2101 	ubfx	r1, r1, #8, #2
    e672:	ea4f 0cc0 	mov.w	ip, r0, lsl #3
    e676:	2902      	cmp	r1, #2
    e678:	f00c 0c18 	and.w	ip, ip, #24
    e67c:	f000 80a7 	beq.w	e7ce <am_hal_gpio_pinconfig+0x20e>
    e680:	f200 809e 	bhi.w	e7c0 <am_hal_gpio_pinconfig+0x200>
    e684:	2901      	cmp	r1, #1
    e686:	f040 8098 	bne.w	e7ba <am_hal_gpio_pinconfig+0x1fa>
            ui32AltPadCfg |= (0 << 0);
            break;
        case AM_HAL_GPIO_PIN_DRIVESTRENGTH_4MA:
            ui32Padreg    |= (1 << PADREG_FLD_DRVSTR_S);
            ui32AltPadCfg |= (0 << 0);
            break;
    e68a:	2200      	movs	r2, #0
            ui32Padreg    |= (1 << PADREG_FLD_DRVSTR_S);
    e68c:	f045 0504 	orr.w	r5, r5, #4
            break;
    e690:	9203      	str	r2, [sp, #12]
    e692:	4604      	mov	r4, r0
    uint32_t ui32GPCfgClearMask, ui32PadClearMask;
    uint32_t ui32GPCfgShft, ui32PadShft;

    ui32GPCfgAddr       = (uint32_t)&GPIO->CFGA       + ((ui32Pin & ~0x7) >> 1);
    ui32PadregAddr      = (uint32_t)&GPIO->PADREGA    + (ui32Pin & ~0x3);
    ui32AltpadAddr      = (uint32_t)&GPIO->ALTPADCFGA + (ui32Pin & ~0x3);
    e694:	4a60      	ldr	r2, [pc, #384]	; (e818 <am_hal_gpio_pinconfig+0x258>)
    e696:	4961      	ldr	r1, [pc, #388]	; (e81c <am_hal_gpio_pinconfig+0x25c>)
    ui32GPCfgAddr       = (uint32_t)&GPIO->CFGA       + ((ui32Pin & ~0x7) >> 1);
    e698:	4861      	ldr	r0, [pc, #388]	; (e820 <am_hal_gpio_pinconfig+0x260>)
    e69a:	9302      	str	r3, [sp, #8]
    ui32GPCfgShft       = ((ui32Pin & 0x7) << 2);
    e69c:	f00e 0e1c 	and.w	lr, lr, #28
    ui32PadShft         = ((ui32Pin & 0x3) << 3);
    ui32GPCfgClearMask  = ~((uint32_t)0xF  << ui32GPCfgShft);
    e6a0:	f04f 080f 	mov.w	r8, #15
    ui32PadClearMask    = ~((uint32_t)0xFF << ui32PadShft);
    e6a4:	27ff      	movs	r7, #255	; 0xff
    ui32AltpadAddr      = (uint32_t)&GPIO->ALTPADCFGA + (ui32Pin & ~0x3);
    e6a6:	e9cd 2100 	strd	r2, r1, [sp]
    ui32GPCfgClearMask  = ~((uint32_t)0xF  << ui32GPCfgShft);
    e6aa:	fa08 f80e 	lsl.w	r8, r8, lr
    ui32PadClearMask    = ~((uint32_t)0xFF << ui32PadShft);
    e6ae:	fa07 f70c 	lsl.w	r7, r7, ip
    //
    // Get the new values into their rightful bit positions.
    //
    ui32Padreg    <<= ui32PadShft;
    ui32AltPadCfg <<= ui32PadShft;
    ui32GPCfg     <<= ui32GPCfgShft;
    e6b2:	fa06 f60e 	lsl.w	r6, r6, lr
    ui32Padreg    <<= ui32PadShft;
    e6b6:	fa05 f50c 	lsl.w	r5, r5, ip
    ui32GPCfgAddr       = (uint32_t)&GPIO->CFGA       + ((ui32Pin & ~0x7) >> 1);
    e6ba:	ea00 0954 	and.w	r9, r0, r4, lsr #1

    AM_CRITICAL_BEGIN
    e6be:	f004 f80b 	bl	126d8 <am_hal_interrupt_master_disable>
    ui32PadregAddr      = (uint32_t)&GPIO->PADREGA    + (ui32Pin & ~0x3);
    e6c2:	f024 0b03 	bic.w	fp, r4, #3

    if ( bClearEnable )
    e6c6:	9b02      	ldr	r3, [sp, #8]
    AM_CRITICAL_BEGIN
    e6c8:	9005      	str	r0, [sp, #20]
    ui32PadregAddr      = (uint32_t)&GPIO->PADREGA    + (ui32Pin & ~0x3);
    e6ca:	f10b 4a80 	add.w	sl, fp, #1073741824	; 0x40000000
    ui32GPCfgClearMask  = ~((uint32_t)0xF  << ui32GPCfgShft);
    e6ce:	ea6f 0808 	mvn.w	r8, r8
    ui32PadClearMask    = ~((uint32_t)0xFF << ui32PadShft);
    e6d2:	43ff      	mvns	r7, r7
    ui32PadregAddr      = (uint32_t)&GPIO->PADREGA    + (ui32Pin & ~0x3);
    e6d4:	f50a 3a80 	add.w	sl, sl, #65536	; 0x10000
    if ( bClearEnable )
    e6d8:	e9dd 2100 	ldrd	r2, r1, [sp]
    e6dc:	b14b      	cbz	r3, e6f2 <am_hal_gpio_pinconfig+0x132>
    {
        //
        // We're configuring a mode that requires clearing the Enable bit.
        //
        am_hal_gpio_output_tristate_disable(ui32Pin);
    e6de:	f004 031f 	and.w	r3, r4, #31
    e6e2:	f04f 0c01 	mov.w	ip, #1
    e6e6:	0964      	lsrs	r4, r4, #5
    e6e8:	484e      	ldr	r0, [pc, #312]	; (e824 <am_hal_gpio_pinconfig+0x264>)
    e6ea:	fa0c f303 	lsl.w	r3, ip, r3
    e6ee:	f840 3024 	str.w	r3, [r0, r4, lsl #2]
    }

    GPIO->PADKEY = GPIO_PADKEY_PADKEY_Key;
    e6f2:	4b4d      	ldr	r3, [pc, #308]	; (e828 <am_hal_gpio_pinconfig+0x268>)
    e6f4:	2073      	movs	r0, #115	; 0x73
    e6f6:	6618      	str	r0, [r3, #96]	; 0x60

    AM_REGVAL(ui32PadregAddr)  = (AM_REGVAL(ui32PadregAddr) & ui32PadClearMask)   | ui32Padreg;
    e6f8:	f8da 0000 	ldr.w	r0, [sl]
    e6fc:	4038      	ands	r0, r7
    e6fe:	4305      	orrs	r5, r0
    e700:	f8ca 5000 	str.w	r5, [sl]
    AM_REGVAL(ui32GPCfgAddr)   = (AM_REGVAL(ui32GPCfgAddr)  & ui32GPCfgClearMask) | ui32GPCfg;
    e704:	f859 0001 	ldr.w	r0, [r9, r1]
    e708:	ea00 0808 	and.w	r8, r0, r8
    e70c:	ea48 0606 	orr.w	r6, r8, r6
    e710:	f849 6001 	str.w	r6, [r9, r1]
    AM_REGVAL(ui32AltpadAddr)  = (AM_REGVAL(ui32AltpadAddr) & ui32PadClearMask)   | ui32AltPadCfg;
    e714:	f85b 1002 	ldr.w	r1, [fp, r2]
    e718:	400f      	ands	r7, r1
    e71a:	9903      	ldr	r1, [sp, #12]

    GPIO->PADKEY = 0;
    e71c:	2400      	movs	r4, #0
    AM_REGVAL(ui32AltpadAddr)  = (AM_REGVAL(ui32AltpadAddr) & ui32PadClearMask)   | ui32AltPadCfg;
    e71e:	430f      	orrs	r7, r1
    e720:	f84b 7002 	str.w	r7, [fp, r2]
    GPIO->PADKEY = 0;
    e724:	661c      	str	r4, [r3, #96]	; 0x60

    AM_CRITICAL_END
    e726:	9805      	ldr	r0, [sp, #20]
    e728:	f003 ffda 	bl	126e0 <am_hal_interrupt_master_set>

    return AM_HAL_STATUS_SUCCESS;
    e72c:	4620      	mov	r0, r4

} // am_hal_gpio_pinconfig()
    e72e:	b007      	add	sp, #28
    e730:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ( (ui32PowerSw == AM_HAL_GPIO_PIN_POWERSW_VDD)  &&
    e734:	2c01      	cmp	r4, #1
    e736:	d017      	beq.n	e768 <am_hal_gpio_pinconfig+0x1a8>
        else if ( (ui32PowerSw == AM_HAL_GPIO_PIN_POWERSW_VSS)  &&
    e738:	2c02      	cmp	r4, #2
    e73a:	d11e      	bne.n	e77a <am_hal_gpio_pinconfig+0x1ba>
                  (g_ui8Bit76Capabilities[ui32Pin] & CAP_VSS) )
    e73c:	4c32      	ldr	r4, [pc, #200]	; (e808 <am_hal_gpio_pinconfig+0x248>)
        else if ( (ui32PowerSw == AM_HAL_GPIO_PIN_POWERSW_VSS)  &&
    e73e:	5c24      	ldrb	r4, [r4, r0]
    e740:	0764      	lsls	r4, r4, #29
    e742:	d51a      	bpl.n	e77a <am_hal_gpio_pinconfig+0x1ba>
            ui32Padreg |= 0x2 << PADREG_FLD_76_S;
    e744:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    e748:	e75e      	b.n	e608 <am_hal_gpio_pinconfig+0x48>
        return AM_HAL_STATUS_INVALID_ARG;
    e74a:	2006      	movs	r0, #6
} // am_hal_gpio_pinconfig()
    e74c:	4770      	bx	lr
        else if ( bfGpioCfg.ePullup == AM_HAL_GPIO_PIN_PULLDOWN )
    e74e:	2fc0      	cmp	r7, #192	; 0xc0
    e750:	d042      	beq.n	e7d8 <am_hal_gpio_pinconfig+0x218>
        else if ( bfGpioCfg.ePullup == AM_HAL_GPIO_PIN_PULLUP_WEAK )
    e752:	2f20      	cmp	r7, #32
    e754:	f47f af55 	bne.w	e602 <am_hal_gpio_pinconfig+0x42>
            if ( g_ui8Bit76Capabilities[ui32Pin] & (CAP_PUP | CAP_PDN) )
    e758:	4d2b      	ldr	r5, [pc, #172]	; (e808 <am_hal_gpio_pinconfig+0x248>)
    e75a:	5c2d      	ldrb	r5, [r5, r0]
    e75c:	f015 0f09 	tst.w	r5, #9
    e760:	f43f af4f 	beq.w	e602 <am_hal_gpio_pinconfig+0x42>
                return AM_HAL_GPIO_ERR_PULLUP;
    e764:	4831      	ldr	r0, [pc, #196]	; (e82c <am_hal_gpio_pinconfig+0x26c>)
    e766:	e7e2      	b.n	e72e <am_hal_gpio_pinconfig+0x16e>
             (g_ui8Bit76Capabilities[ui32Pin] & CAP_VDD) )
    e768:	4c27      	ldr	r4, [pc, #156]	; (e808 <am_hal_gpio_pinconfig+0x248>)
        if ( (ui32PowerSw == AM_HAL_GPIO_PIN_POWERSW_VDD)  &&
    e76a:	5c24      	ldrb	r4, [r4, r0]
    e76c:	07a5      	lsls	r5, r4, #30
    e76e:	d504      	bpl.n	e77a <am_hal_gpio_pinconfig+0x1ba>
            ui32Padreg |= 0x1 << PADREG_FLD_76_S;
    e770:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    e774:	e748      	b.n	e608 <am_hal_gpio_pinconfig+0x48>
            bClearEnable = true;
    e776:	2301      	movs	r3, #1
    e778:	e770      	b.n	e65c <am_hal_gpio_pinconfig+0x9c>
            return AM_HAL_GPIO_ERR_PWRSW;
    e77a:	482d      	ldr	r0, [pc, #180]	; (e830 <am_hal_gpio_pinconfig+0x270>)
} // am_hal_gpio_pinconfig()
    e77c:	b007      	add	sp, #28
    e77e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ( bfGpioCfg.uIOMnum > IOMNUM_MAX )
    e782:	f3c1 4302 	ubfx	r3, r1, #16, #3
    e786:	2b07      	cmp	r3, #7
    e788:	d02b      	beq.n	e7e2 <am_hal_gpio_pinconfig+0x222>
            if ( g_ui8NCEtable[ui32Pin][ui32Outcfg] == ui8CEtbl )
    e78a:	4c2a      	ldr	r4, [pc, #168]	; (e834 <am_hal_gpio_pinconfig+0x274>)
        ui8CEtbl = (bfGpioCfg.uIOMnum << 4) | bfGpioCfg.uNCE;
    e78c:	f3c1 42c1 	ubfx	r2, r1, #19, #2
            if ( g_ui8NCEtable[ui32Pin][ui32Outcfg] == ui8CEtbl )
    e790:	f814 6020 	ldrb.w	r6, [r4, r0, lsl #2]
        ui8CEtbl = (bfGpioCfg.uIOMnum << 4) | bfGpioCfg.uNCE;
    e794:	ea42 1303 	orr.w	r3, r2, r3, lsl #4
            if ( g_ui8NCEtable[ui32Pin][ui32Outcfg] == ui8CEtbl )
    e798:	429e      	cmp	r6, r3
    e79a:	d024      	beq.n	e7e6 <am_hal_gpio_pinconfig+0x226>
    e79c:	ea4f 0e80 	mov.w	lr, r0, lsl #2
    e7a0:	eb04 020e 	add.w	r2, r4, lr
    e7a4:	7854      	ldrb	r4, [r2, #1]
    e7a6:	429c      	cmp	r4, r3
    e7a8:	d027      	beq.n	e7fa <am_hal_gpio_pinconfig+0x23a>
    e7aa:	7894      	ldrb	r4, [r2, #2]
    e7ac:	429c      	cmp	r4, r3
    e7ae:	d026      	beq.n	e7fe <am_hal_gpio_pinconfig+0x23e>
    e7b0:	78d2      	ldrb	r2, [r2, #3]
    e7b2:	429a      	cmp	r2, r3
    e7b4:	d025      	beq.n	e802 <am_hal_gpio_pinconfig+0x242>
            return AM_HAL_GPIO_ERR_INVCEPIN;
    e7b6:	4820      	ldr	r0, [pc, #128]	; (e838 <am_hal_gpio_pinconfig+0x278>)
    e7b8:	e7b9      	b.n	e72e <am_hal_gpio_pinconfig+0x16e>
    switch ( bfGpioCfg.eDriveStrength )
    e7ba:	2200      	movs	r2, #0
    e7bc:	9203      	str	r2, [sp, #12]
    e7be:	e768      	b.n	e692 <am_hal_gpio_pinconfig+0xd2>
    e7c0:	2701      	movs	r7, #1
    e7c2:	fa07 f20c 	lsl.w	r2, r7, ip
            ui32Padreg    |= (1 << PADREG_FLD_DRVSTR_S);
    e7c6:	f045 0504 	orr.w	r5, r5, #4
    e7ca:	9203      	str	r2, [sp, #12]
            break;
    e7cc:	e761      	b.n	e692 <am_hal_gpio_pinconfig+0xd2>
    e7ce:	2701      	movs	r7, #1
    e7d0:	fa07 f20c 	lsl.w	r2, r7, ip
    e7d4:	9203      	str	r2, [sp, #12]
            break;
    e7d6:	e75c      	b.n	e692 <am_hal_gpio_pinconfig+0xd2>
            if ( ui32Pin != 20 )
    e7d8:	2814      	cmp	r0, #20
    e7da:	f43f af12 	beq.w	e602 <am_hal_gpio_pinconfig+0x42>
                return AM_HAL_GPIO_ERR_PULLDOWN;
    e7de:	4817      	ldr	r0, [pc, #92]	; (e83c <am_hal_gpio_pinconfig+0x27c>)
    e7e0:	e7a5      	b.n	e72e <am_hal_gpio_pinconfig+0x16e>
            return AM_HAL_GPIO_ERR_INVCE;   // Invalid CE specified
    e7e2:	4817      	ldr	r0, [pc, #92]	; (e840 <am_hal_gpio_pinconfig+0x280>)
    e7e4:	e7a3      	b.n	e72e <am_hal_gpio_pinconfig+0x16e>
        for ( ui32Outcfg = 0; ui32Outcfg < 4; ui32Outcfg++ )
    e7e6:	2600      	movs	r6, #0
    e7e8:	ea4f 0e80 	mov.w	lr, r0, lsl #2
                     (bfGpioCfg.eCEpol << GPIOCFG_FLD_INTD_S)   |
    e7ec:	f3c1 5340 	ubfx	r3, r1, #21, #1
        ui32GPCfg |= (ui32Outcfg       << GPIOCFG_FLD_OUTCFG_S) |
    e7f0:	0076      	lsls	r6, r6, #1
                     (bfGpioCfg.eCEpol << GPIOCFG_FLD_INTD_S)   |
    e7f2:	ea46 06c3 	orr.w	r6, r6, r3, lsl #3
    bool bClearEnable = false;
    e7f6:	2300      	movs	r3, #0
    e7f8:	e739      	b.n	e66e <am_hal_gpio_pinconfig+0xae>
        for ( ui32Outcfg = 0; ui32Outcfg < 4; ui32Outcfg++ )
    e7fa:	2601      	movs	r6, #1
    e7fc:	e7f6      	b.n	e7ec <am_hal_gpio_pinconfig+0x22c>
    e7fe:	2602      	movs	r6, #2
    e800:	e7f4      	b.n	e7ec <am_hal_gpio_pinconfig+0x22c>
    e802:	2603      	movs	r6, #3
    e804:	e7f2      	b.n	e7ec <am_hal_gpio_pinconfig+0x22c>
    e806:	bf00      	nop
    e808:	00013570 	.word	0x00013570
    e80c:	000135a4 	.word	0x000135a4
    e810:	000136a0 	.word	0x000136a0
    e814:	00013564 	.word	0x00013564
    e818:	400100e0 	.word	0x400100e0
    e81c:	40010040 	.word	0x40010040
    e820:	7ffffffc 	.word	0x7ffffffc
    e824:	400100b4 	.word	0x400100b4
    e828:	40010000 	.word	0x40010000
    e82c:	08000100 	.word	0x08000100
    e830:	08000102 	.word	0x08000102
    e834:	000135d8 	.word	0x000135d8
    e838:	08000104 	.word	0x08000104
    e83c:	08000101 	.word	0x08000101
    e840:	08000103 	.word	0x08000103

0000e844 <am_hal_gpio_state_read>:
{
    uint32_t ui32ReadValue = 0xFFFFFFFF;
    uint32_t ui32BaseAddr, ui32Shift;

#ifdef AM_HAL_ENABLE_API_VALIDATION
    if ( pui32ReadState == NULL )
    e844:	b1a2      	cbz	r2, e870 <am_hal_gpio_state_read+0x2c>
    {
        return AM_HAL_STATUS_INVALID_ARG;
    }

    if ( ui32Pin >= AM_HAL_GPIO_MAX_PADS )
    e846:	2831      	cmp	r0, #49	; 0x31
    e848:	d814      	bhi.n	e874 <am_hal_gpio_state_read+0x30>
    //
    ui32BaseAddr = ((ui32Pin & 0x20) >> (3 + 2));   // 0 or 1
    ui32Shift    = ui32Pin & 0x1F;
    //ui32Mask     = 1 << ui32Shift;

    switch ( eReadType )
    e84a:	2901      	cmp	r1, #1
    ui32BaseAddr = ((ui32Pin & 0x20) >> (3 + 2));   // 0 or 1
    e84c:	ea4f 1350 	mov.w	r3, r0, lsr #5
    ui32Shift    = ui32Pin & 0x1F;
    e850:	f000 001f 	and.w	r0, r0, #31
    switch ( eReadType )
    e854:	d013      	beq.n	e87e <am_hal_gpio_state_read+0x3a>
    e856:	d31c      	bcc.n	e892 <am_hal_gpio_state_read+0x4e>
    e858:	2902      	cmp	r1, #2
    e85a:	d109      	bne.n	e870 <am_hal_gpio_state_read+0x2c>
        case AM_HAL_GPIO_OUTPUT_READ:
            ui32ReadValue = AM_REGVAL(&GPIO->WTA + ui32BaseAddr);
            ui32ReadValue = (ui32ReadValue >> ui32Shift) & 0x01;
            break;
        case AM_HAL_GPIO_ENABLE_READ:
            ui32ReadValue = AM_REGVAL(&GPIO->ENA + ui32BaseAddr);
    e85c:	4912      	ldr	r1, [pc, #72]	; (e8a8 <am_hal_gpio_state_read+0x64>)
    e85e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
            ui32ReadValue = (ui32ReadValue >> ui32Shift) & 0x01;
    e862:	fa23 f000 	lsr.w	r0, r3, r0
    e866:	f000 0001 	and.w	r0, r0, #1
            break;
        default:
            return AM_HAL_STATUS_INVALID_ARG;
    }

    *pui32ReadState = ui32ReadValue;
    e86a:	6010      	str	r0, [r2, #0]

    return AM_HAL_STATUS_SUCCESS;
    e86c:	2000      	movs	r0, #0
    e86e:	4770      	bx	lr
            return AM_HAL_STATUS_INVALID_ARG;
    e870:	2006      	movs	r0, #6
} // am_hal_gpio_state_read()
    e872:	4770      	bx	lr
        *pui32ReadState = ui32ReadValue;
    e874:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    e878:	6013      	str	r3, [r2, #0]
        return AM_HAL_STATUS_OUT_OF_RANGE;
    e87a:	2005      	movs	r0, #5
    e87c:	4770      	bx	lr
            ui32ReadValue = AM_REGVAL(&GPIO->WTA + ui32BaseAddr);
    e87e:	490b      	ldr	r1, [pc, #44]	; (e8ac <am_hal_gpio_state_read+0x68>)
    e880:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
            ui32ReadValue = (ui32ReadValue >> ui32Shift) & 0x01;
    e884:	fa23 f000 	lsr.w	r0, r3, r0
    e888:	f000 0001 	and.w	r0, r0, #1
    *pui32ReadState = ui32ReadValue;
    e88c:	6010      	str	r0, [r2, #0]
    return AM_HAL_STATUS_SUCCESS;
    e88e:	2000      	movs	r0, #0
    e890:	4770      	bx	lr
            ui32ReadValue = AM_REGVAL(&GPIO->RDA + ui32BaseAddr);
    e892:	4907      	ldr	r1, [pc, #28]	; (e8b0 <am_hal_gpio_state_read+0x6c>)
    e894:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
            ui32ReadValue = (ui32ReadValue >> ui32Shift) & 0x01;
    e898:	fa23 f000 	lsr.w	r0, r3, r0
    e89c:	f000 0001 	and.w	r0, r0, #1
    *pui32ReadState = ui32ReadValue;
    e8a0:	6010      	str	r0, [r2, #0]
    return AM_HAL_STATUS_SUCCESS;
    e8a2:	2000      	movs	r0, #0
    e8a4:	4770      	bx	lr
    e8a6:	bf00      	nop
    e8a8:	400100a0 	.word	0x400100a0
    e8ac:	40010088 	.word	0x40010088
    e8b0:	40010080 	.word	0x40010080

0000e8b4 <am_hal_gpio_state_write>:
{
    uint32_t ui32Mask, ui32Off;
    uint32_t ui32Return = AM_HAL_STATUS_SUCCESS;

#ifdef AM_HAL_ENABLE_API_VALIDATION
    if ( ui32Pin >= AM_HAL_GPIO_MAX_PADS )
    e8b4:	2831      	cmp	r0, #49	; 0x31
    e8b6:	d819      	bhi.n	e8ec <am_hal_gpio_state_write+0x38>
    {
        return AM_HAL_STATUS_OUT_OF_RANGE;
    }

    if ( eWriteType > AM_HAL_GPIO_OUTPUT_TRISTATE_TOGGLE )
    e8b8:	2905      	cmp	r1, #5
    e8ba:	d815      	bhi.n	e8e8 <am_hal_gpio_state_write+0x34>
{
    e8bc:	b570      	push	{r4, r5, r6, lr}
    {
        return AM_HAL_STATUS_INVALID_ARG;
    }
#endif // AM_HAL_ENABLE_API_VALIDATION

    ui32Mask = (uint32_t)0x1 << (ui32Pin % 32);
    e8be:	f000 031f 	and.w	r3, r0, #31
{
    e8c2:	b082      	sub	sp, #8
    ui32Off  = (ui32Pin & 0x20) >> 3;   // 0 or 4
    e8c4:	08c0      	lsrs	r0, r0, #3
    ui32Mask = (uint32_t)0x1 << (ui32Pin % 32);
    e8c6:	2201      	movs	r2, #1
    e8c8:	460d      	mov	r5, r1
    ui32Off  = (ui32Pin & 0x20) >> 3;   // 0 or 4
    e8ca:	f000 0404 	and.w	r4, r0, #4
    ui32Mask = (uint32_t)0x1 << (ui32Pin % 32);
    e8ce:	fa02 f603 	lsl.w	r6, r2, r3

    AM_CRITICAL_BEGIN;
    e8d2:	f003 ff01 	bl	126d8 <am_hal_interrupt_master_disable>

    ui32Off /= 4;   // 0 or 1 for ptr arithmetic
    switch ( eWriteType )
    e8d6:	1e69      	subs	r1, r5, #1
    AM_CRITICAL_BEGIN;
    e8d8:	9001      	str	r0, [sp, #4]
    switch ( eWriteType )
    e8da:	2904      	cmp	r1, #4
    e8dc:	d81b      	bhi.n	e916 <am_hal_gpio_state_write+0x62>
    e8de:	e8df f001 	tbb	[pc, r1]
    e8e2:	1217      	.short	0x1217
    e8e4:	070f      	.short	0x070f
    e8e6:	1d          	.byte	0x1d
    e8e7:	00          	.byte	0x00
        return AM_HAL_STATUS_INVALID_ARG;
    e8e8:	2006      	movs	r0, #6
    }

    AM_CRITICAL_END;

    return ui32Return;
} // am_hal_gpio_state_write()
    e8ea:	4770      	bx	lr
        return AM_HAL_STATUS_OUT_OF_RANGE;
    e8ec:	2005      	movs	r0, #5
    e8ee:	4770      	bx	lr
            AM_REGVAL(&GPIO->ENSA + ui32Off) = ui32Mask;
    e8f0:	4b0d      	ldr	r3, [pc, #52]	; (e928 <am_hal_gpio_state_write+0x74>)
    e8f2:	50e6      	str	r6, [r4, r3]
    AM_CRITICAL_END;
    e8f4:	9801      	ldr	r0, [sp, #4]
    e8f6:	f003 fef3 	bl	126e0 <am_hal_interrupt_master_set>
    return ui32Return;
    e8fa:	2000      	movs	r0, #0
} // am_hal_gpio_state_write()
    e8fc:	b002      	add	sp, #8
    e8fe:	bd70      	pop	{r4, r5, r6, pc}
            AM_REGVAL(&GPIO->ENCA + ui32Off) = ui32Mask;
    e900:	4b0a      	ldr	r3, [pc, #40]	; (e92c <am_hal_gpio_state_write+0x78>)
    e902:	50e6      	str	r6, [r4, r3]
            break;
    e904:	e7f6      	b.n	e8f4 <am_hal_gpio_state_write+0x40>
            AM_REGVAL(&GPIO->WTA + ui32Off) ^= ui32Mask;
    e906:	4a0a      	ldr	r2, [pc, #40]	; (e930 <am_hal_gpio_state_write+0x7c>)
    e908:	58a3      	ldr	r3, [r4, r2]
    e90a:	4073      	eors	r3, r6
    e90c:	50a3      	str	r3, [r4, r2]
            break;
    e90e:	e7f1      	b.n	e8f4 <am_hal_gpio_state_write+0x40>
            AM_REGVAL(&GPIO->WTSA + ui32Off) = ui32Mask;
    e910:	4b08      	ldr	r3, [pc, #32]	; (e934 <am_hal_gpio_state_write+0x80>)
    e912:	50e6      	str	r6, [r4, r3]
            break;
    e914:	e7ee      	b.n	e8f4 <am_hal_gpio_state_write+0x40>
            AM_REGVAL(&GPIO->WTCA + ui32Off) = ui32Mask;
    e916:	4b08      	ldr	r3, [pc, #32]	; (e938 <am_hal_gpio_state_write+0x84>)
    e918:	50e6      	str	r6, [r4, r3]
            break;
    e91a:	e7eb      	b.n	e8f4 <am_hal_gpio_state_write+0x40>
            AM_REGVAL(&GPIO->ENCA + ui32Off) ^= ui32Mask;
    e91c:	4a03      	ldr	r2, [pc, #12]	; (e92c <am_hal_gpio_state_write+0x78>)
    e91e:	58a3      	ldr	r3, [r4, r2]
    e920:	4073      	eors	r3, r6
    e922:	50a3      	str	r3, [r4, r2]
            break;
    e924:	e7e6      	b.n	e8f4 <am_hal_gpio_state_write+0x40>
    e926:	bf00      	nop
    e928:	400100a8 	.word	0x400100a8
    e92c:	400100b4 	.word	0x400100b4
    e930:	40010088 	.word	0x40010088
    e934:	40010090 	.word	0x40010090
    e938:	40010098 	.word	0x40010098

0000e93c <am_hal_gpio_interrupt_enable>:
// Enable GPIO interrupts.
//
//*****************************************************************************
uint32_t
am_hal_gpio_interrupt_enable(uint64_t ui64InterruptMask)
{
    e93c:	b530      	push	{r4, r5, lr}
#ifdef AM_HAL_ENABLE_API_VALIDATION
    //
    // Check parameters
    //
    if ( ui64InterruptMask &  ~(((uint64_t)1 << AM_HAL_GPIO_MAX_PADS) - 1) )
    e93e:	4b11      	ldr	r3, [pc, #68]	; (e984 <am_hal_gpio_interrupt_enable+0x48>)
    e940:	2200      	movs	r2, #0
    e942:	ea02 0400 	and.w	r4, r2, r0
    e946:	ea03 0501 	and.w	r5, r3, r1
    e94a:	ea54 0305 	orrs.w	r3, r4, r5
{
    e94e:	b083      	sub	sp, #12
    if ( ui64InterruptMask &  ~(((uint64_t)1 << AM_HAL_GPIO_MAX_PADS) - 1) )
    e950:	d115      	bne.n	e97e <am_hal_gpio_interrupt_enable+0x42>
    e952:	460d      	mov	r5, r1
    e954:	4604      	mov	r4, r0
#endif // AM_HAL_ENABLE_API_VALIDATION

    //
    // Enable the interrupts.
    //
    AM_CRITICAL_BEGIN
    e956:	f003 febf 	bl	126d8 <am_hal_interrupt_master_disable>

    GPIO->INT0EN |= (uint32_t)(ui64InterruptMask & 0xFFFFFFFF);
    e95a:	4b0b      	ldr	r3, [pc, #44]	; (e988 <am_hal_gpio_interrupt_enable+0x4c>)
    AM_CRITICAL_BEGIN
    e95c:	9001      	str	r0, [sp, #4]
    GPIO->INT0EN |= (uint32_t)(ui64InterruptMask & 0xFFFFFFFF);
    e95e:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    e962:	4322      	orrs	r2, r4
    e964:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
    GPIO->INT1EN |= (uint32_t)(ui64InterruptMask >> 32);
    e968:	f8d3 2210 	ldr.w	r2, [r3, #528]	; 0x210
    e96c:	432a      	orrs	r2, r5
    e96e:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210

    AM_CRITICAL_END
    e972:	9801      	ldr	r0, [sp, #4]
    e974:	f003 feb4 	bl	126e0 <am_hal_interrupt_master_set>

    //
    // Return the status.
    //
    return AM_HAL_STATUS_SUCCESS;
    e978:	2000      	movs	r0, #0

} // am_hal_gpio_interrupt_enable()
    e97a:	b003      	add	sp, #12
    e97c:	bd30      	pop	{r4, r5, pc}
        return AM_HAL_STATUS_OUT_OF_RANGE;
    e97e:	2005      	movs	r0, #5
} // am_hal_gpio_interrupt_enable()
    e980:	b003      	add	sp, #12
    e982:	bd30      	pop	{r4, r5, pc}
    e984:	fffc0000 	.word	0xfffc0000
    e988:	40010000 	.word	0x40010000

0000e98c <am_hal_gpio_interrupt_clear>:
// Clear GPIO interrupts.
//
//*****************************************************************************
uint32_t
am_hal_gpio_interrupt_clear(uint64_t ui64InterruptMask)
{
    e98c:	b530      	push	{r4, r5, lr}
#ifdef AM_HAL_ENABLE_API_VALIDATION
    //
    // Check parameters
    //
    if ( ui64InterruptMask &  ~(((uint64_t)1 << AM_HAL_GPIO_MAX_PADS) - 1) )
    e98e:	4b0e      	ldr	r3, [pc, #56]	; (e9c8 <am_hal_gpio_interrupt_clear+0x3c>)
    e990:	2200      	movs	r2, #0
    e992:	ea02 0400 	and.w	r4, r2, r0
    e996:	ea03 0501 	and.w	r5, r3, r1
    e99a:	ea54 0305 	orrs.w	r3, r4, r5
{
    e99e:	b083      	sub	sp, #12
    if ( ui64InterruptMask &  ~(((uint64_t)1 << AM_HAL_GPIO_MAX_PADS) - 1) )
    e9a0:	d10f      	bne.n	e9c2 <am_hal_gpio_interrupt_clear+0x36>
    e9a2:	460d      	mov	r5, r1
    e9a4:	4604      	mov	r4, r0
#endif // AM_HAL_ENABLE_API_VALIDATION

    //
    // Clear the interrupts.
    //
    AM_CRITICAL_BEGIN
    e9a6:	f003 fe97 	bl	126d8 <am_hal_interrupt_master_disable>

    GPIO->INT0CLR = (uint32_t)(ui64InterruptMask & 0xFFFFFFFF);
    e9aa:	4b08      	ldr	r3, [pc, #32]	; (e9cc <am_hal_gpio_interrupt_clear+0x40>)
    AM_CRITICAL_BEGIN
    e9ac:	9001      	str	r0, [sp, #4]
    GPIO->INT0CLR = (uint32_t)(ui64InterruptMask & 0xFFFFFFFF);
    e9ae:	f8c3 4208 	str.w	r4, [r3, #520]	; 0x208
    GPIO->INT1CLR = (uint32_t)(ui64InterruptMask >> 32);
    e9b2:	f8c3 5218 	str.w	r5, [r3, #536]	; 0x218

    AM_CRITICAL_END
    e9b6:	9801      	ldr	r0, [sp, #4]
    e9b8:	f003 fe92 	bl	126e0 <am_hal_interrupt_master_set>

    //
    // Return the status.
    //
    return AM_HAL_STATUS_SUCCESS;
    e9bc:	2000      	movs	r0, #0

} // am_hal_gpio_interrupt_clear()
    e9be:	b003      	add	sp, #12
    e9c0:	bd30      	pop	{r4, r5, pc}
        return AM_HAL_STATUS_OUT_OF_RANGE;
    e9c2:	2005      	movs	r0, #5
} // am_hal_gpio_interrupt_clear()
    e9c4:	b003      	add	sp, #12
    e9c6:	bd30      	pop	{r4, r5, pc}
    e9c8:	fffc0000 	.word	0xfffc0000
    e9cc:	40010000 	.word	0x40010000

0000e9d0 <HardFault_Handler>:
HardFault_Handler(void)
#else // AM_CMSIS_REGS
am_fault_isr(void)
#endif // AM_CMSIS_REGS
{
    __asm("    push    {r0,lr}");       // Always pushes to MSP stack
    e9d0:	b501      	push	{r0, lr}
    __asm("    tst     lr, #4");        // Check if we should use MSP or PSP
    e9d2:	f01e 0f04 	tst.w	lr, #4
    __asm("    itet    eq");            // Instrs executed when: eq,ne,eq
    e9d6:	bf0a      	itet	eq
    __asm("    mrseq   r0, msp");       //    bit2=0 indicating MSP stack
    e9d8:	f3ef 8008 	mrseq	r0, MSP
    __asm("    mrsne   r0, psp");       // e: bit2=1 indicating PSP stack
    e9dc:	f3ef 8009 	mrsne	r0, PSP
    __asm("    addseq  r0, r0, #8");    // t: bit2=0, adjust for pushes to MSP stack
    e9e0:	f110 0008 	addseq.w	r0, r0, #8
    __asm("    bl      am_util_faultisr_collect_data");
    e9e4:	f000 f806 	bl	e9f4 <am_util_faultisr_collect_data>
    __asm("    pop     {r0,pc}");       // Restore from MSP stack
    e9e8:	bd01      	pop	{r0, pc}
    e9ea:	bf00      	nop

0000e9ec <getStackedReg>:
}

uint32_t __attribute__((naked))
getStackedReg(uint32_t regnum, uint32_t u32SP)
{
    __asm("    lsls    r0, r0, #2");
    e9ec:	0080      	lsls	r0, r0, #2
    __asm("    adds    r0, r1");
    e9ee:	1840      	adds	r0, r0, r1
    __asm("    ldr     r0, [r0]");
    e9f0:	6800      	ldr	r0, [r0, #0]
    __asm("    bx      lr");
    e9f2:	4770      	bx	lr

0000e9f4 <am_util_faultisr_collect_data>:
// HardFault_Handler() was called.
//
//*****************************************************************************
void
am_util_faultisr_collect_data(uint32_t u32IsrSP)
{
    e9f4:	b500      	push	{lr}
    volatile am_fault_t sFaultData;
    am_hal_mcuctrl_fault_t sHalFaultData = {0};
    e9f6:	2300      	movs	r3, #0
{
    e9f8:	b093      	sub	sp, #76	; 0x4c
    am_hal_mcuctrl_fault_t sHalFaultData = {0};
    e9fa:	e9cd 3300 	strd	r3, r3, [sp]
    e9fe:	e9cd 3302 	strd	r3, r3, [sp, #8]
    ea02:	e9cd 3304 	strd	r3, r3, [sp, #16]
    // a breakpoint at the end of the routine.  If the printing is not used,
    // we'll get a compiler warning; so to avoid that warning, we'll use it
    // in a dummy assignment here.
    //
    sFaultData.u32CFSR = u32Mask;       // Avoid compiler warning
    sFaultData.u32CFSR = AM_REGVAL(AM_REG_SYSCTRL_CFSR_O);
    ea06:	4a27      	ldr	r2, [pc, #156]	; (eaa4 <am_util_faultisr_collect_data+0xb0>)
    sFaultData.u32CFSR = u32Mask;       // Avoid compiler warning
    ea08:	9310      	str	r3, [sp, #64]	; 0x40
    sFaultData.u32CFSR = AM_REGVAL(AM_REG_SYSCTRL_CFSR_O);
    ea0a:	6813      	ldr	r3, [r2, #0]
    ea0c:	9310      	str	r3, [sp, #64]	; 0x40
    sFaultData.u8MMSR  = (sFaultData.u32CFSR >> 0)  & 0xff;
    ea0e:	9b10      	ldr	r3, [sp, #64]	; 0x40
    ea10:	b2db      	uxtb	r3, r3
    ea12:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
    sFaultData.u8BFSR  = (sFaultData.u32CFSR >> 8)  & 0xff;
    ea16:	9b10      	ldr	r3, [sp, #64]	; 0x40
    ea18:	f3c3 2307 	ubfx	r3, r3, #8, #8
    ea1c:	f88d 3045 	strb.w	r3, [sp, #69]	; 0x45
    sFaultData.u16UFSR = (sFaultData.u32CFSR >> 16) & 0xffff;
    ea20:	9b10      	ldr	r3, [sp, #64]	; 0x40
    ea22:	0c1b      	lsrs	r3, r3, #16
    ea24:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46

    //
    // The address of the location that caused the fault.  e.g. if accessing an
    // invalid data location caused the fault, that address will appear here.
    //
    sFaultData.u32BFAR = AM_REGVAL(AM_REG_SYSCTRL_BFAR_O);
    ea28:	6913      	ldr	r3, [r2, #16]
    ea2a:	930f      	str	r3, [sp, #60]	; 0x3c

    //
    // The address of the instruction that caused the fault is the stacked PC
    // if BFSR bit1 is set.
    //
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    ea2c:	f89d 2045 	ldrb.w	r2, [sp, #69]	; 0x45
    ea30:	0792      	lsls	r2, r2, #30
{
    ea32:	4603      	mov	r3, r0
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    ea34:	d430      	bmi.n	ea98 <am_util_faultisr_collect_data+0xa4>
    ea36:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff

    //
    // Get the stacked registers.
    // Note - the address of the instruction that caused the fault is u32PC.
    //
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    ea3a:	4619      	mov	r1, r3
    ea3c:	2000      	movs	r0, #0
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    ea3e:	920e      	str	r2, [sp, #56]	; 0x38
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    ea40:	f7ff ffd4 	bl	e9ec <getStackedReg>
    ea44:	4602      	mov	r2, r0
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    ea46:	2001      	movs	r0, #1
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    ea48:	9206      	str	r2, [sp, #24]
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    ea4a:	f7ff ffcf 	bl	e9ec <getStackedReg>
    ea4e:	4602      	mov	r2, r0
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    ea50:	2002      	movs	r0, #2
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    ea52:	9207      	str	r2, [sp, #28]
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    ea54:	f7ff ffca 	bl	e9ec <getStackedReg>
    ea58:	4602      	mov	r2, r0
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    ea5a:	2003      	movs	r0, #3
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    ea5c:	9208      	str	r2, [sp, #32]
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    ea5e:	f7ff ffc5 	bl	e9ec <getStackedReg>
    ea62:	4602      	mov	r2, r0
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    ea64:	2004      	movs	r0, #4
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    ea66:	9209      	str	r2, [sp, #36]	; 0x24
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    ea68:	f7ff ffc0 	bl	e9ec <getStackedReg>
    ea6c:	4602      	mov	r2, r0
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    ea6e:	2005      	movs	r0, #5
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    ea70:	920a      	str	r2, [sp, #40]	; 0x28
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    ea72:	f7ff ffbb 	bl	e9ec <getStackedReg>
    ea76:	4602      	mov	r2, r0
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    ea78:	2006      	movs	r0, #6
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    ea7a:	920b      	str	r2, [sp, #44]	; 0x2c
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    ea7c:	f7ff ffb6 	bl	e9ec <getStackedReg>
    ea80:	4602      	mov	r2, r0
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    ea82:	2007      	movs	r0, #7
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    ea84:	920c      	str	r2, [sp, #48]	; 0x30
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    ea86:	f7ff ffb1 	bl	e9ec <getStackedReg>

    //
    // Use the HAL MCUCTRL functions to read the fault data.
    //
#if AM_APOLLO3_MCUCTRL
    am_hal_mcuctrl_info_get(AM_HAL_MCUCTRL_INFO_FAULT_STATUS, &sHalFaultData);
    ea8a:	4669      	mov	r1, sp
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    ea8c:	4603      	mov	r3, r0
    am_hal_mcuctrl_info_get(AM_HAL_MCUCTRL_INFO_FAULT_STATUS, &sHalFaultData);
    ea8e:	2002      	movs	r0, #2
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    ea90:	930d      	str	r3, [sp, #52]	; 0x34
    am_hal_mcuctrl_info_get(AM_HAL_MCUCTRL_INFO_FAULT_STATUS, &sHalFaultData);
    ea92:	f003 fe7f 	bl	12794 <am_hal_mcuctrl_info_get>
    ea96:	e7fe      	b.n	ea96 <am_util_faultisr_collect_data+0xa2>
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    ea98:	4601      	mov	r1, r0
    ea9a:	2006      	movs	r0, #6
    ea9c:	f7ff ffa6 	bl	e9ec <getStackedReg>
    eaa0:	4602      	mov	r2, r0
    eaa2:	e7ca      	b.n	ea3a <am_util_faultisr_collect_data+0x46>
    eaa4:	e000ed28 	.word	0xe000ed28

0000eaa8 <uint64_to_str>:
// written).
//
//*****************************************************************************
static int
uint64_to_str(uint64_t ui64Val, char *pcBuf)
{
    eaa8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    eaac:	b097      	sub	sp, #92	; 0x5c
    eaae:	4682      	mov	sl, r0
    eab0:	468b      	mov	fp, r1
    char tbuf[25];
    int ix = 0, iNumDig = 0;
    eab2:	2300      	movs	r3, #0
{
    eab4:	920d      	str	r2, [sp, #52]	; 0x34
    eab6:	469c      	mov	ip, r3
    eab8:	e9cd ab00 	strd	sl, fp, [sp]
    eabc:	4606      	mov	r6, r0
    eabe:	460f      	mov	r7, r1
    eac0:	e00b      	b.n	eada <uint64_to_str+0x32>
        //
        // Get modulus
        //
        uMod = ui64Val - (u64Tmp * 10);

        tbuf[ix++] = uMod + '0';
    eac2:	f80b 2c01 	strb.w	r2, [fp, #-1]
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    eac6:	4619      	mov	r1, r3
    eac8:	2200      	movs	r2, #0
    eaca:	e9cd 1200 	strd	r1, r2, [sp]
        ui64Val = u64Tmp;
    } while ( ui64Val );
    eace:	2b00      	cmp	r3, #0
    ead0:	f000 80a5 	beq.w	ec1e <uint64_to_str+0x176>
    ead4:	e9dd 6700 	ldrd	r6, r7, [sp]
{
    ead8:	46f4      	mov	ip, lr
        q64 += (q64 >> 4);
    eada:	2300      	movs	r3, #0
    eadc:	2400      	movs	r4, #0
    eade:	e9cd 3402 	strd	r3, r4, [sp, #8]
        q64 += (q64 >> 8);
    eae2:	e9cd 3404 	strd	r3, r4, [sp, #16]
        q64 += (q64 >> 16);
    eae6:	e9cd 3406 	strd	r3, r4, [sp, #24]
        q64 += (q64 >> 32);
    eaea:	e9cd 340a 	strd	r3, r4, [sp, #40]	; 0x28
        q64 >>= 3;
    eaee:	4698      	mov	r8, r3
        q32 = (ui32Val>>1) + (ui32Val>>2);
    eaf0:	08b3      	lsrs	r3, r6, #2
    eaf2:	eb03 0356 	add.w	r3, r3, r6, lsr #1
        q32 += (q32 >> 4);
    eaf6:	eb03 1313 	add.w	r3, r3, r3, lsr #4
        q32 += (q32 >> 8);
    eafa:	eb03 2313 	add.w	r3, r3, r3, lsr #8
        q64 >>= 3;
    eafe:	46a1      	mov	r9, r4
        q32 += (q32 >> 16);
    eb00:	eb03 4313 	add.w	r3, r3, r3, lsr #16
        q32 >>= 3;
    eb04:	08da      	lsrs	r2, r3, #3
        return q64 + ((r64 + 6) >> 4);
    eb06:	4644      	mov	r4, r8
    eb08:	464d      	mov	r5, r9
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    eb0a:	4633      	mov	r3, r6
        q64 = (ui64Val>>1) + (ui64Val>>2);
    eb0c:	08b0      	lsrs	r0, r6, #2
        return q64 + ((r64 + 6) >> 4);
    eb0e:	e9cd 4508 	strd	r4, r5, [sp, #32]
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    eb12:	3306      	adds	r3, #6
        r32 = ui32Val - q32*10;
    eb14:	eb02 0482 	add.w	r4, r2, r2, lsl #2
    eb18:	f10c 0e01 	add.w	lr, ip, #1
        tbuf[ix++] = uMod + '0';
    eb1c:	ae0f      	add	r6, sp, #60	; 0x3c
    eb1e:	4476      	add	r6, lr
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    eb20:	eba3 0344 	sub.w	r3, r3, r4, lsl #1
        q64 = (ui64Val>>1) + (ui64Val>>2);
    eb24:	ea40 7087 	orr.w	r0, r0, r7, lsl #30
    if ( ui64Val >> 32 )
    eb28:	463c      	mov	r4, r7
        q64 = (ui64Val>>1) + (ui64Val>>2);
    eb2a:	08b9      	lsrs	r1, r7, #2
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    eb2c:	eb02 1313 	add.w	r3, r2, r3, lsr #4
        tbuf[ix++] = uMod + '0';
    eb30:	46b3      	mov	fp, r6
    eb32:	4637      	mov	r7, r6
    eb34:	9e00      	ldr	r6, [sp, #0]
        uMod = ui64Val - (u64Tmp * 10);
    eb36:	eb03 0283 	add.w	r2, r3, r3, lsl #2
    if ( ui64Val >> 32 )
    eb3a:	2500      	movs	r5, #0
        uMod = ui64Val - (u64Tmp * 10);
    eb3c:	eba6 0242 	sub.w	r2, r6, r2, lsl #1
    if ( ui64Val >> 32 )
    eb40:	ea54 0a05 	orrs.w	sl, r4, r5
        tbuf[ix++] = uMod + '0';
    eb44:	f102 0230 	add.w	r2, r2, #48	; 0x30
    if ( ui64Val >> 32 )
    eb48:	d0bb      	beq.n	eac2 <uint64_to_str+0x1a>
        q64 = (ui64Val>>1) + (ui64Val>>2);
    eb4a:	e9dd 2300 	ldrd	r2, r3, [sp]
    eb4e:	085b      	lsrs	r3, r3, #1
    eb50:	ea4f 0232 	mov.w	r2, r2, rrx
    eb54:	eb12 0a00 	adds.w	sl, r2, r0
    eb58:	eb43 0b01 	adc.w	fp, r3, r1
        q64 += (q64 >> 4);
    eb5c:	ea4f 131a 	mov.w	r3, sl, lsr #4
    eb60:	ea43 730b 	orr.w	r3, r3, fp, lsl #28
    eb64:	9302      	str	r3, [sp, #8]
    eb66:	ea4f 131b 	mov.w	r3, fp, lsr #4
    eb6a:	9303      	str	r3, [sp, #12]
    eb6c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    eb70:	eb12 020a 	adds.w	r2, r2, sl
    eb74:	eb43 030b 	adc.w	r3, r3, fp
        q64 += (q64 >> 8);
    eb78:	0a11      	lsrs	r1, r2, #8
    eb7a:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
    eb7e:	9104      	str	r1, [sp, #16]
    eb80:	0a19      	lsrs	r1, r3, #8
    eb82:	9105      	str	r1, [sp, #20]
    eb84:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    eb88:	1880      	adds	r0, r0, r2
    eb8a:	4159      	adcs	r1, r3
    eb8c:	460b      	mov	r3, r1
        q64 += (q64 >> 16);
    eb8e:	0c01      	lsrs	r1, r0, #16
    eb90:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    eb94:	9106      	str	r1, [sp, #24]
    eb96:	0c19      	lsrs	r1, r3, #16
    eb98:	9107      	str	r1, [sp, #28]
        q64 += (q64 >> 8);
    eb9a:	4602      	mov	r2, r0
        q64 += (q64 >> 16);
    eb9c:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    eba0:	1880      	adds	r0, r0, r2
    eba2:	4159      	adcs	r1, r3
        q64 += (q64 >> 32);
    eba4:	e9cd 150a 	strd	r1, r5, [sp, #40]	; 0x28
        q64 += (q64 >> 16);
    eba8:	4602      	mov	r2, r0
    ebaa:	460b      	mov	r3, r1
        q64 += (q64 >> 32);
    ebac:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    ebb0:	1880      	adds	r0, r0, r2
    ebb2:	4159      	adcs	r1, r3
        q64 >>= 3;
    ebb4:	ea4f 08d0 	mov.w	r8, r0, lsr #3
    ebb8:	ea48 7841 	orr.w	r8, r8, r1, lsl #29
    ebbc:	ea4f 09d1 	mov.w	r9, r1, lsr #3
        return q64 + ((r64 + 6) >> 4);
    ebc0:	e9dd ab00 	ldrd	sl, fp, [sp]
        r64 = ui64Val - q64*10;
    ebc4:	ea4f 0189 	mov.w	r1, r9, lsl #2
    ebc8:	ea4f 0288 	mov.w	r2, r8, lsl #2
    ebcc:	eb12 0008 	adds.w	r0, r2, r8
    ebd0:	ea41 7398 	orr.w	r3, r1, r8, lsr #30
    ebd4:	eb43 0109 	adc.w	r1, r3, r9
        return q64 + ((r64 + 6) >> 4);
    ebd8:	f11a 0a06 	adds.w	sl, sl, #6
    ebdc:	f14b 0b00 	adc.w	fp, fp, #0
        r64 = ui64Val - q64*10;
    ebe0:	1802      	adds	r2, r0, r0
    ebe2:	eb41 0301 	adc.w	r3, r1, r1
        return q64 + ((r64 + 6) >> 4);
    ebe6:	ebba 0002 	subs.w	r0, sl, r2
    ebea:	eb6b 0103 	sbc.w	r1, fp, r3
    ebee:	0903      	lsrs	r3, r0, #4
    ebf0:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
    ebf4:	9308      	str	r3, [sp, #32]
    ebf6:	090b      	lsrs	r3, r1, #4
    ebf8:	9309      	str	r3, [sp, #36]	; 0x24
    ebfa:	e9dd ab08 	ldrd	sl, fp, [sp, #32]
    ebfe:	eb1a 0a08 	adds.w	sl, sl, r8
    ec02:	eb4b 0b09 	adc.w	fp, fp, r9
    ec06:	4653      	mov	r3, sl
    ec08:	465c      	mov	r4, fp
    ec0a:	e9cd 3400 	strd	r3, r4, [sp]
        uMod = ui64Val - (u64Tmp * 10);
    ec0e:	eb0a 038a 	add.w	r3, sl, sl, lsl #2
    ec12:	eba6 0643 	sub.w	r6, r6, r3, lsl #1
        tbuf[ix++] = uMod + '0';
    ec16:	3630      	adds	r6, #48	; 0x30
    ec18:	f807 6c01 	strb.w	r6, [r7, #-1]
    ec1c:	e75a      	b.n	ead4 <uint64_to_str+0x2c>
    iNumDig = ix;

    //
    // Now, reverse the buffer when saving to the caller's buffer.
    //
    if ( pcBuf )
    ec1e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    ec20:	4660      	mov	r0, ip
    ec22:	b16a      	cbz	r2, ec40 <uint64_to_str+0x198>
    ec24:	465b      	mov	r3, fp
    ec26:	3a01      	subs	r2, #1
    {
        while ( ix-- )
        {
            *pcBuf++ = tbuf[ix];
    ec28:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
    ec2c:	f802 1f01 	strb.w	r1, [r2, #1]!
        while ( ix-- )
    ec30:	a90f      	add	r1, sp, #60	; 0x3c
    ec32:	4299      	cmp	r1, r3
    ec34:	d1f8      	bne.n	ec28 <uint64_to_str+0x180>
        }

        //
        // Terminate the caller's buffer
        //
        *pcBuf = 0x00;
    ec36:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    ec38:	4403      	add	r3, r0
    ec3a:	461a      	mov	r2, r3
    ec3c:	2300      	movs	r3, #0
    ec3e:	7053      	strb	r3, [r2, #1]
    }

    return iNumDig;
}
    ec40:	4670      	mov	r0, lr
    ec42:	b017      	add	sp, #92	; 0x5c
    ec44:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000ec48 <am_util_stdio_printf_init>:
    g_pfnCharPrint = pfnCharPrint;
    ec48:	4b01      	ldr	r3, [pc, #4]	; (ec50 <am_util_stdio_printf_init+0x8>)
    ec4a:	6018      	str	r0, [r3, #0]
}
    ec4c:	4770      	bx	lr
    ec4e:	bf00      	nop
    ec50:	10014400 	.word	0x10014400

0000ec54 <am_util_stdio_vsprintf>:
//! @return uint32_t representing the number of characters printed.
//
//******************************************************************************
uint32_t
am_util_stdio_vsprintf(char *pcBuf, const char *pcFmt, va_list pArgs)
{
    ec54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ec58:	b09b      	sub	sp, #108	; 0x6c
    ec5a:	4682      	mov	sl, r0
    ec5c:	4689      	mov	r9, r1
    ec5e:	9201      	str	r2, [sp, #4]
    char *pcStr;
    uint64_t ui64Val;
    int64_t i64Val;
    uint32_t ui32NumChars, ui32CharCnt = 0;
    ec60:	f04f 0b00 	mov.w	fp, #0
    int iWidth, iVal, iPrecision;
    uint8_t ui8CharSpecifier, ui8PadChar;
    bool bLower, bLongLong, bNeg;
    uint32_t ui32strlen = 0;

    while ( *pcFmt != 0x0 )
    ec64:	f899 3000 	ldrb.w	r3, [r9]
    ec68:	b1bb      	cbz	r3, ec9a <am_util_stdio_vsprintf+0x46>
    {
        iPrecision = 6;             // printf() default precision for %f is 6

        if ( *pcFmt != '%' )
    ec6a:	2b25      	cmp	r3, #37	; 0x25
    ec6c:	f109 0501 	add.w	r5, r9, #1
    ec70:	d01c      	beq.n	ecac <am_util_stdio_vsprintf+0x58>
    ec72:	f10b 0201 	add.w	r2, fp, #1
        {
            //
            // Accumulate the string portion of the format specification.
            //
            if ( pcBuf )
    ec76:	f1ba 0f00 	cmp.w	sl, #0
    ec7a:	f000 8091 	beq.w	eda0 <am_util_stdio_vsprintf+0x14c>
            {
                // If '\n', convert to '\r\n'
                if ( *pcFmt == '\n'  &&  g_bTxtXlate )
    ec7e:	2b0a      	cmp	r3, #10
    ec80:	f10a 0101 	add.w	r1, sl, #1
    ec84:	f000 808f 	beq.w	eda6 <am_util_stdio_vsprintf+0x152>
                {
                    *pcBuf++ = '\r';
                    ++ui32CharCnt;
                }
                *pcBuf++ = *pcFmt;
    ec88:	f88a 3000 	strb.w	r3, [sl]
    ec8c:	4693      	mov	fp, r2
    ec8e:	468a      	mov	sl, r1
            }

            ++pcFmt;
    ec90:	46a9      	mov	r9, r5
    while ( *pcFmt != 0x0 )
    ec92:	f899 3000 	ldrb.w	r3, [r9]
    ec96:	2b00      	cmp	r3, #0
    ec98:	d1e7      	bne.n	ec6a <am_util_stdio_vsprintf+0x16>
    } // while ()

    //
    // Terminate the string
    //
    if ( pcBuf )
    ec9a:	f1ba 0f00 	cmp.w	sl, #0
    ec9e:	d001      	beq.n	eca4 <am_util_stdio_vsprintf+0x50>
    {
        *pcBuf = 0x0;
    eca0:	f88a 3000 	strb.w	r3, [sl]
    }

    return (ui32CharCnt);
}
    eca4:	4658      	mov	r0, fp
    eca6:	b01b      	add	sp, #108	; 0x6c
    eca8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ( *pcFmt == '0' )
    ecac:	f899 3001 	ldrb.w	r3, [r9, #1]
    ecb0:	2b30      	cmp	r3, #48	; 0x30
    ecb2:	bf03      	ittte	eq
    ecb4:	f899 3002 	ldrbeq.w	r3, [r9, #2]
            ++pcFmt;
    ecb8:	f109 0502 	addeq.w	r5, r9, #2
            ui8PadChar = '0';
    ecbc:	f04f 0830 	moveq.w	r8, #48	; 0x30
        ui8PadChar = ' ';
    ecc0:	f04f 0820 	movne.w	r8, #32
    if ( *pcStr == '-')
    ecc4:	2b2d      	cmp	r3, #45	; 0x2d
    ecc6:	d07e      	beq.n	edc6 <am_util_stdio_vsprintf+0x172>
    uint32_t ui32Val = 0, uCnt = 0;
    ecc8:	2100      	movs	r1, #0
    bool bNeg = false;
    ecca:	460e      	mov	r6, r1
    if ( *pcStr == '-')
    eccc:	462a      	mov	r2, r5
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    ecce:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    ecd2:	2809      	cmp	r0, #9
    ecd4:	f04f 0400 	mov.w	r4, #0
    ecd8:	d80f      	bhi.n	ecfa <am_util_stdio_vsprintf+0xa6>
        ui32Val *= 10;
    ecda:	eb04 0484 	add.w	r4, r4, r4, lsl #2
        ui32Val += (*pcStr - '0');
    ecde:	eb03 0444 	add.w	r4, r3, r4, lsl #1
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    ece2:	f812 3f01 	ldrb.w	r3, [r2, #1]!
    ece6:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    ecea:	2809      	cmp	r0, #9
        ui32Val += (*pcStr - '0');
    ecec:	f1a4 0430 	sub.w	r4, r4, #48	; 0x30
        ++uCnt;
    ecf0:	f101 0101 	add.w	r1, r1, #1
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    ecf4:	d9f1      	bls.n	ecda <am_util_stdio_vsprintf+0x86>
    ecf6:	5c6b      	ldrb	r3, [r5, r1]
    ecf8:	186a      	adds	r2, r5, r1
    return bNeg ? -ui32Val : ui32Val;
    ecfa:	b106      	cbz	r6, ecfe <am_util_stdio_vsprintf+0xaa>
    ecfc:	4264      	negs	r4, r4
        if ( ( *pcFmt != 's' )  &&  ( iWidth < 0 ) )
    ecfe:	2b73      	cmp	r3, #115	; 0x73
        iWidth = decstr_to_int(pcFmt, &ui32NumChars);
    ed00:	4621      	mov	r1, r4
    ed02:	f102 0901 	add.w	r9, r2, #1
        if ( ( *pcFmt != 's' )  &&  ( iWidth < 0 ) )
    ed06:	f000 8167 	beq.w	efd8 <am_util_stdio_vsprintf+0x384>
    ed0a:	ea84 71e4 	eor.w	r1, r4, r4, asr #31
    ed0e:	eba1 71e4 	sub.w	r1, r1, r4, asr #31
        if (*pcFmt == '.')
    ed12:	2b2e      	cmp	r3, #46	; 0x2e
    ed14:	910e      	str	r1, [sp, #56]	; 0x38
    ed16:	f000 813b 	beq.w	ef90 <am_util_stdio_vsprintf+0x33c>
        iPrecision = 6;             // printf() default precision for %f is 6
    ed1a:	2506      	movs	r5, #6
        if ( *pcFmt == 'l' )
    ed1c:	2b6c      	cmp	r3, #108	; 0x6c
    ed1e:	d157      	bne.n	edd0 <am_util_stdio_vsprintf+0x17c>
            if ( *pcFmt == 'l' )    // "ll" (long long)
    ed20:	7853      	ldrb	r3, [r2, #1]
    ed22:	2b6c      	cmp	r3, #108	; 0x6c
    ed24:	f000 808e 	beq.w	ee44 <am_util_stdio_vsprintf+0x1f0>
        switch ( *pcFmt )
    ed28:	f1a3 0246 	sub.w	r2, r3, #70	; 0x46
    ed2c:	f109 0901 	add.w	r9, r9, #1
    ed30:	2a32      	cmp	r2, #50	; 0x32
    ed32:	f200 8123 	bhi.w	ef7c <am_util_stdio_vsprintf+0x328>
    ed36:	e8df f012 	tbh	[pc, r2, lsl #1]
    ed3a:	00c2      	.short	0x00c2
    ed3c:	01210121 	.word	0x01210121
    ed40:	01210121 	.word	0x01210121
    ed44:	01210121 	.word	0x01210121
    ed48:	01210121 	.word	0x01210121
    ed4c:	01210121 	.word	0x01210121
    ed50:	01210121 	.word	0x01210121
    ed54:	01210121 	.word	0x01210121
    ed58:	01210121 	.word	0x01210121
    ed5c:	01990121 	.word	0x01990121
    ed60:	01210121 	.word	0x01210121
    ed64:	01210121 	.word	0x01210121
    ed68:	01210121 	.word	0x01210121
    ed6c:	01210121 	.word	0x01210121
    ed70:	01210121 	.word	0x01210121
    ed74:	01b60113 	.word	0x01b60113
    ed78:	00c20121 	.word	0x00c20121
    ed7c:	01210121 	.word	0x01210121
    ed80:	012101b6 	.word	0x012101b6
    ed84:	01210121 	.word	0x01210121
    ed88:	01210121 	.word	0x01210121
    ed8c:	01210121 	.word	0x01210121
    ed90:	01210121 	.word	0x01210121
    ed94:	0121014e 	.word	0x0121014e
    ed98:	01210235 	.word	0x01210235
    ed9c:	024e0121 	.word	0x024e0121
    eda0:	4693      	mov	fp, r2
            ++pcFmt;
    eda2:	46a9      	mov	r9, r5
    eda4:	e775      	b.n	ec92 <am_util_stdio_vsprintf+0x3e>
                if ( *pcFmt == '\n'  &&  g_bTxtXlate )
    eda6:	48a6      	ldr	r0, [pc, #664]	; (f040 <am_util_stdio_vsprintf+0x3ec>)
    eda8:	7800      	ldrb	r0, [r0, #0]
    edaa:	2800      	cmp	r0, #0
    edac:	f43f af6c 	beq.w	ec88 <am_util_stdio_vsprintf+0x34>
                    *pcBuf++ = '\r';
    edb0:	4650      	mov	r0, sl
    edb2:	230d      	movs	r3, #13
    edb4:	f800 3b02 	strb.w	r3, [r0], #2
    edb8:	468a      	mov	sl, r1
    edba:	f899 3000 	ldrb.w	r3, [r9]
    edbe:	f10b 0202 	add.w	r2, fp, #2
    edc2:	4601      	mov	r1, r0
    edc4:	e760      	b.n	ec88 <am_util_stdio_vsprintf+0x34>
        uCnt++;
    edc6:	2101      	movs	r1, #1
        bNeg = true;
    edc8:	460e      	mov	r6, r1
        pcStr++;
    edca:	186a      	adds	r2, r5, r1
    edcc:	786b      	ldrb	r3, [r5, #1]
    edce:	e77e      	b.n	ecce <am_util_stdio_vsprintf+0x7a>
        switch ( *pcFmt )
    edd0:	f1a3 0246 	sub.w	r2, r3, #70	; 0x46
    edd4:	2a32      	cmp	r2, #50	; 0x32
    edd6:	f200 80d1 	bhi.w	ef7c <am_util_stdio_vsprintf+0x328>
    edda:	e8df f012 	tbh	[pc, r2, lsl #1]
    edde:	0070      	.short	0x0070
    ede0:	00cf00cf 	.word	0x00cf00cf
    ede4:	00cf00cf 	.word	0x00cf00cf
    ede8:	00cf00cf 	.word	0x00cf00cf
    edec:	00cf00cf 	.word	0x00cf00cf
    edf0:	00cf00cf 	.word	0x00cf00cf
    edf4:	00cf00cf 	.word	0x00cf00cf
    edf8:	00cf00cf 	.word	0x00cf00cf
    edfc:	00cf00cf 	.word	0x00cf00cf
    ee00:	014700cf 	.word	0x014700cf
    ee04:	00cf00cf 	.word	0x00cf00cf
    ee08:	00cf00cf 	.word	0x00cf00cf
    ee0c:	00cf00cf 	.word	0x00cf00cf
    ee10:	00cf00cf 	.word	0x00cf00cf
    ee14:	00cf00cf 	.word	0x00cf00cf
    ee18:	016400c1 	.word	0x016400c1
    ee1c:	007000cf 	.word	0x007000cf
    ee20:	00cf00cf 	.word	0x00cf00cf
    ee24:	00cf0164 	.word	0x00cf0164
    ee28:	00cf00cf 	.word	0x00cf00cf
    ee2c:	00cf00cf 	.word	0x00cf00cf
    ee30:	00cf00cf 	.word	0x00cf00cf
    ee34:	00cf00cf 	.word	0x00cf00cf
    ee38:	00cf00fc 	.word	0x00cf00fc
    ee3c:	00cf01e3 	.word	0x00cf01e3
    ee40:	01fa00cf 	.word	0x01fa00cf
    ee44:	7893      	ldrb	r3, [r2, #2]
    ee46:	f1a3 0146 	sub.w	r1, r3, #70	; 0x46
    ee4a:	f102 0903 	add.w	r9, r2, #3
    ee4e:	2932      	cmp	r1, #50	; 0x32
    ee50:	f200 8094 	bhi.w	ef7c <am_util_stdio_vsprintf+0x328>
    ee54:	e8df f011 	tbh	[pc, r1, lsl #1]
    ee58:	00920033 	.word	0x00920033
    ee5c:	00920092 	.word	0x00920092
    ee60:	00920092 	.word	0x00920092
    ee64:	00920092 	.word	0x00920092
    ee68:	00920092 	.word	0x00920092
    ee6c:	00920092 	.word	0x00920092
    ee70:	00920092 	.word	0x00920092
    ee74:	00920092 	.word	0x00920092
    ee78:	00920092 	.word	0x00920092
    ee7c:	00920414 	.word	0x00920414
    ee80:	00920092 	.word	0x00920092
    ee84:	00920092 	.word	0x00920092
    ee88:	00920092 	.word	0x00920092
    ee8c:	00920092 	.word	0x00920092
    ee90:	00840092 	.word	0x00840092
    ee94:	00920222 	.word	0x00920222
    ee98:	00920033 	.word	0x00920033
    ee9c:	02220092 	.word	0x02220092
    eea0:	00920092 	.word	0x00920092
    eea4:	00920092 	.word	0x00920092
    eea8:	00920092 	.word	0x00920092
    eeac:	00920092 	.word	0x00920092
    eeb0:	00bf0092 	.word	0x00bf0092
    eeb4:	02160092 	.word	0x02160092
    eeb8:	00920092 	.word	0x00920092
    eebc:	0412      	.short	0x0412
                if ( pcBuf )
    eebe:	f1ba 0f00 	cmp.w	sl, #0
    eec2:	f43f aecf 	beq.w	ec64 <am_util_stdio_vsprintf+0x10>
                    float fValue = va_arg(pArgs, double);
    eec6:	9b01      	ldr	r3, [sp, #4]
    eec8:	3307      	adds	r3, #7
    eeca:	f023 0307 	bic.w	r3, r3, #7
    eece:	e9d3 0100 	ldrd	r0, r1, [r3]
    eed2:	3308      	adds	r3, #8
    eed4:	9301      	str	r3, [sp, #4]
    eed6:	f7fd f9ad 	bl	c234 <__aeabi_d2f>
    eeda:	ee07 0a90 	vmov	s15, r0
    if (fValue == 0.0f)
    eede:	eef5 7a40 	vcmp.f32	s15, #0.0
                    *(uint32_t*)pcBuf = 20;
    eee2:	2314      	movs	r3, #20
    if (fValue == 0.0f)
    eee4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                    *(uint32_t*)pcBuf = 20;
    eee8:	f8ca 3000 	str.w	r3, [sl]
    if (fValue == 0.0f)
    eeec:	f000 843e 	beq.w	f76c <am_util_stdio_vsprintf+0xb18>
    iExp2 = ((unFloatValue.I32 >> 23) & 0x000000FF) - 127;
    eef0:	f3c0 51c7 	ubfx	r1, r0, #23, #8
    eef4:	f1a1 027f 	sub.w	r2, r1, #127	; 0x7f
    eef8:	4603      	mov	r3, r0
    if (iExp2 >= 31)
    eefa:	2a1e      	cmp	r2, #30
    i32Significand = (unFloatValue.I32 & 0x00FFFFFF) | 0x00800000;
    eefc:	f3c0 0016 	ubfx	r0, r0, #0, #23
    ef00:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    if (iExp2 >= 31)
    ef04:	f300 844a 	bgt.w	f79c <am_util_stdio_vsprintf+0xb48>
    else if (iExp2 < -23)
    ef08:	f112 0f17 	cmn.w	r2, #23
    ef0c:	f2c0 8479 	blt.w	f802 <am_util_stdio_vsprintf+0xbae>
    else if (iExp2 >= 23)
    ef10:	2a16      	cmp	r2, #22
    ef12:	f10a 0701 	add.w	r7, sl, #1
    ef16:	f340 836f 	ble.w	f5f8 <am_util_stdio_vsprintf+0x9a4>
        i32IntPart = i32Significand << (iExp2 - 23);
    ef1a:	3996      	subs	r1, #150	; 0x96
    if (unFloatValue.I32 < 0)
    ef1c:	2b00      	cmp	r3, #0
        i32IntPart = i32Significand << (iExp2 - 23);
    ef1e:	fa00 f001 	lsl.w	r0, r0, r1
    if (unFloatValue.I32 < 0)
    ef22:	f2c0 844d 	blt.w	f7c0 <am_util_stdio_vsprintf+0xb6c>
    ef26:	4656      	mov	r6, sl
    i32FracPart = 0;
    ef28:	2400      	movs	r4, #0
    if (i32IntPart == 0)
    ef2a:	2800      	cmp	r0, #0
    ef2c:	f040 843c 	bne.w	f7a8 <am_util_stdio_vsprintf+0xb54>
    ef30:	1c7a      	adds	r2, r7, #1
        *pcBuf++ = '0';
    ef32:	f04f 0330 	mov.w	r3, #48	; 0x30
    ef36:	7033      	strb	r3, [r6, #0]
    *pcBuf++ = '.';
    ef38:	232e      	movs	r3, #46	; 0x2e
    ef3a:	703b      	strb	r3, [r7, #0]
    if (i32FracPart == 0)
    ef3c:	2c00      	cmp	r4, #0
    ef3e:	f040 83d8 	bne.w	f6f2 <am_util_stdio_vsprintf+0xa9e>
        *pcBuf++ = '0';
    ef42:	1cba      	adds	r2, r7, #2
    ef44:	f04f 0330 	mov.w	r3, #48	; 0x30
    ef48:	707b      	strb	r3, [r7, #1]
    ef4a:	eba2 010a 	sub.w	r1, r2, sl
    *pcBuf = 0x00;
    ef4e:	2300      	movs	r3, #0
                    if ( iVal < 0 )
    ef50:	4299      	cmp	r1, r3
    *pcBuf = 0x00;
    ef52:	7013      	strb	r3, [r2, #0]
                    if ( iVal < 0 )
    ef54:	f2c0 841e 	blt.w	f794 <am_util_stdio_vsprintf+0xb40>
    ef58:	460b      	mov	r3, r1
                    ui32CharCnt += iVal;
    ef5a:	449b      	add	fp, r3
                    pcBuf += iVal;
    ef5c:	449a      	add	sl, r3
    ef5e:	e681      	b.n	ec64 <am_util_stdio_vsprintf+0x10>
                ui8CharSpecifier = va_arg(pArgs, uint32_t);
    ef60:	9a01      	ldr	r2, [sp, #4]
    ef62:	1d13      	adds	r3, r2, #4
                if ( pcBuf )
    ef64:	f1ba 0f00 	cmp.w	sl, #0
    ef68:	d004      	beq.n	ef74 <am_util_stdio_vsprintf+0x320>
                ui8CharSpecifier = va_arg(pArgs, uint32_t);
    ef6a:	6812      	ldr	r2, [r2, #0]
    ef6c:	f88a 2000 	strb.w	r2, [sl]
                    *pcBuf++ = ui8CharSpecifier;
    ef70:	f10a 0a01 	add.w	sl, sl, #1
                ++ui32CharCnt;
    ef74:	f10b 0b01 	add.w	fp, fp, #1
                ui8CharSpecifier = va_arg(pArgs, uint32_t);
    ef78:	9301      	str	r3, [sp, #4]
                break;
    ef7a:	e673      	b.n	ec64 <am_util_stdio_vsprintf+0x10>
                if ( pcBuf )
    ef7c:	f1ba 0f00 	cmp.w	sl, #0
    ef80:	d003      	beq.n	ef8a <am_util_stdio_vsprintf+0x336>
                    *pcBuf++ = *pcFmt;
    ef82:	f88a 3000 	strb.w	r3, [sl]
    ef86:	f10a 0a01 	add.w	sl, sl, #1
                ++ui32CharCnt;
    ef8a:	f10b 0b01 	add.w	fp, fp, #1
                break;
    ef8e:	e669      	b.n	ec64 <am_util_stdio_vsprintf+0x10>
    if ( *pcStr == '-')
    ef90:	7851      	ldrb	r1, [r2, #1]
    ef92:	292d      	cmp	r1, #45	; 0x2d
    ef94:	f000 821a 	beq.w	f3cc <am_util_stdio_vsprintf+0x778>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    ef98:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
    ef9c:	2b09      	cmp	r3, #9
    ef9e:	f200 8305 	bhi.w	f5ac <am_util_stdio_vsprintf+0x958>
    bool bNeg = false;
    efa2:	2600      	movs	r6, #0
    uint32_t ui32Val = 0, uCnt = 0;
    efa4:	4632      	mov	r2, r6
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    efa6:	4648      	mov	r0, r9
        uCnt++;
    efa8:	2300      	movs	r3, #0
        ui32Val *= 10;
    efaa:	eb03 0383 	add.w	r3, r3, r3, lsl #2
        ui32Val += (*pcStr - '0');
    efae:	eb01 0343 	add.w	r3, r1, r3, lsl #1
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    efb2:	f810 1f01 	ldrb.w	r1, [r0, #1]!
    efb6:	f1a1 0530 	sub.w	r5, r1, #48	; 0x30
    efba:	2d09      	cmp	r5, #9
        ui32Val += (*pcStr - '0');
    efbc:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
        ++uCnt;
    efc0:	f102 0201 	add.w	r2, r2, #1
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    efc4:	d9f1      	bls.n	efaa <am_util_stdio_vsprintf+0x356>
    return bNeg ? -ui32Val : ui32Val;
    efc6:	b106      	cbz	r6, efca <am_util_stdio_vsprintf+0x376>
    efc8:	425b      	negs	r3, r3
            pcFmt += ui32NumChars;
    efca:	444a      	add	r2, r9
            iPrecision = decstr_to_int(pcFmt, &ui32NumChars);
    efcc:	461d      	mov	r5, r3
    efce:	f102 0901 	add.w	r9, r2, #1
    efd2:	7813      	ldrb	r3, [r2, #0]
    efd4:	e6a2      	b.n	ed1c <am_util_stdio_vsprintf+0xc8>
        switch ( *pcFmt )
    efd6:	990e      	ldr	r1, [sp, #56]	; 0x38
                pcStr = va_arg(pArgs, char *);
    efd8:	9b01      	ldr	r3, [sp, #4]
    efda:	681f      	ldr	r7, [r3, #0]
    efdc:	1d1a      	adds	r2, r3, #4
    if ( !pcBuf )
    efde:	b38f      	cbz	r7, f044 <am_util_stdio_vsprintf+0x3f0>
    while ( *pcBuf++ )
    efe0:	7838      	ldrb	r0, [r7, #0]
    efe2:	1c7b      	adds	r3, r7, #1
    efe4:	461c      	mov	r4, r3
    efe6:	2800      	cmp	r0, #0
    efe8:	f000 835c 	beq.w	f6a4 <am_util_stdio_vsprintf+0xa50>
    efec:	1be6      	subs	r6, r4, r7
    efee:	f814 5b01 	ldrb.w	r5, [r4], #1
    eff2:	2d00      	cmp	r5, #0
    eff4:	d1fa      	bne.n	efec <am_util_stdio_vsprintf+0x398>
                if ( iWidth > 0 )
    eff6:	2900      	cmp	r1, #0
    eff8:	dd02      	ble.n	f000 <am_util_stdio_vsprintf+0x3ac>
                    if ( ui32strlen < iWidth )
    effa:	428e      	cmp	r6, r1
    effc:	f0c0 8356 	bcc.w	f6ac <am_util_stdio_vsprintf+0xa58>
    f000:	465c      	mov	r4, fp
    f002:	1be4      	subs	r4, r4, r7
    f004:	4657      	mov	r7, sl
                        *pcBuf++ = *pcStr;
    f006:	4655      	mov	r5, sl
    f008:	eb04 0b03 	add.w	fp, r4, r3
                    if ( pcBuf )
    f00c:	b15f      	cbz	r7, f026 <am_util_stdio_vsprintf+0x3d2>
                        *pcBuf++ = *pcStr;
    f00e:	7028      	strb	r0, [r5, #0]
                while (*pcStr != 0x0)
    f010:	f813 0b01 	ldrb.w	r0, [r3], #1
                        *pcBuf++ = *pcStr;
    f014:	3701      	adds	r7, #1
                while (*pcStr != 0x0)
    f016:	2800      	cmp	r0, #0
    f018:	f000 81c5 	beq.w	f3a6 <am_util_stdio_vsprintf+0x752>
                        *pcBuf++ = *pcStr;
    f01c:	463d      	mov	r5, r7
    f01e:	eb04 0b03 	add.w	fp, r4, r3
                    if ( pcBuf )
    f022:	2f00      	cmp	r7, #0
    f024:	d1f3      	bne.n	f00e <am_util_stdio_vsprintf+0x3ba>
    f026:	46ba      	mov	sl, r7
    f028:	eb04 0b03 	add.w	fp, r4, r3
                while (*pcStr != 0x0)
    f02c:	f813 0b01 	ldrb.w	r0, [r3], #1
    f030:	2800      	cmp	r0, #0
    f032:	d1f9      	bne.n	f028 <am_util_stdio_vsprintf+0x3d4>
                if ( iWidth )
    f034:	2900      	cmp	r1, #0
    f036:	f040 81ba 	bne.w	f3ae <am_util_stdio_vsprintf+0x75a>
                pcStr = va_arg(pArgs, char *);
    f03a:	9201      	str	r2, [sp, #4]
    f03c:	e612      	b.n	ec64 <am_util_stdio_vsprintf+0x10>
    f03e:	bf00      	nop
    f040:	10012d0c 	.word	0x10012d0c
                if ( iWidth > 0 )
    f044:	2900      	cmp	r1, #0
    f046:	f340 838a 	ble.w	f75e <am_util_stdio_vsprintf+0xb0a>
        return ui32RetVal;
    f04a:	463e      	mov	r6, r7
    if ( i32NumChars <= 0 )
    f04c:	2900      	cmp	r1, #0
    f04e:	f300 8304 	bgt.w	f65a <am_util_stdio_vsprintf+0xa06>
    f052:	465c      	mov	r4, fp
    f054:	2300      	movs	r3, #0
                        pcBuf += pcBuf ? iWidth : 0;
    f056:	f1ba 0f00 	cmp.w	sl, #0
    f05a:	d000      	beq.n	f05e <am_util_stdio_vsprintf+0x40a>
    f05c:	449a      	add	sl, r3
                while (*pcStr != 0x0)
    f05e:	7838      	ldrb	r0, [r7, #0]
    f060:	2800      	cmp	r0, #0
    f062:	f000 83f3 	beq.w	f84c <am_util_stdio_vsprintf+0xbf8>
                        iWidth = 0;
    f066:	2100      	movs	r1, #0
    f068:	1c7b      	adds	r3, r7, #1
    f06a:	e7ca      	b.n	f002 <am_util_stdio_vsprintf+0x3ae>
        bLower = bLongLong = false;
    f06c:	2500      	movs	r5, #0
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    f06e:	9b01      	ldr	r3, [sp, #4]
    f070:	681a      	ldr	r2, [r3, #0]
                                      va_arg(pArgs, uint32_t);
    f072:	3304      	adds	r3, #4
    f074:	9301      	str	r3, [sp, #4]
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    f076:	2300      	movs	r3, #0
                if ( iWidth )
    f078:	2c00      	cmp	r4, #0
    f07a:	f040 80bd 	bne.w	f1f8 <am_util_stdio_vsprintf+0x5a4>
    if ( ui64Val == 0 )
    f07e:	ea52 0103 	orrs.w	r1, r2, r3
    f082:	f040 80dd 	bne.w	f240 <am_util_stdio_vsprintf+0x5ec>
    if (pcBuf)
    f086:	f1ba 0f00 	cmp.w	sl, #0
    f08a:	f000 828d 	beq.w	f5a8 <am_util_stdio_vsprintf+0x954>
            *pcBuf++ = tbuf[ix];
    f08e:	f10a 0501 	add.w	r5, sl, #1
    f092:	f04f 0330 	mov.w	r3, #48	; 0x30
    f096:	f88a 3000 	strb.w	r3, [sl]
    f09a:	2001      	movs	r0, #1
    f09c:	46aa      	mov	sl, r5
        *pcBuf = 0;
    f09e:	2300      	movs	r3, #0
    f0a0:	702b      	strb	r3, [r5, #0]
                ui32CharCnt += iVal;
    f0a2:	4483      	add	fp, r0
                break;
    f0a4:	e5de      	b.n	ec64 <am_util_stdio_vsprintf+0x10>
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
    f0a6:	9b01      	ldr	r3, [sp, #4]
    f0a8:	6818      	ldr	r0, [r3, #0]
                                     va_arg(pArgs, int32_t);
    f0aa:	3304      	adds	r3, #4
    f0ac:	9301      	str	r3, [sp, #4]
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
    f0ae:	17c1      	asrs	r1, r0, #31
                if ( i64Val < 0 )
    f0b0:	2800      	cmp	r0, #0
    f0b2:	f171 0300 	sbcs.w	r3, r1, #0
    f0b6:	f2c0 8194 	blt.w	f3e2 <am_util_stdio_vsprintf+0x78e>
                    ui64Val = i64Val;
    f0ba:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
                if ( iWidth )
    f0be:	2c00      	cmp	r4, #0
    f0c0:	d065      	beq.n	f18e <am_util_stdio_vsprintf+0x53a>
    int iNDigits = ui64Val ? 0 : 1;
    f0c2:	4603      	mov	r3, r0
    f0c4:	430b      	orrs	r3, r1
    return ndigits_in_u64((uint64_t) i64Val);
    f0c6:	460c      	mov	r4, r1
    f0c8:	4603      	mov	r3, r0
    int iNDigits = ui64Val ? 0 : 1;
    f0ca:	bf0c      	ite	eq
    f0cc:	f04f 0e01 	moveq.w	lr, #1
    f0d0:	f04f 0e00 	movne.w	lr, #0
    while ( ui64Val )
    f0d4:	4323      	orrs	r3, r4
    f0d6:	f000 8396 	beq.w	f806 <am_util_stdio_vsprintf+0xbb2>
                    bNeg = false;
    f0da:	2300      	movs	r3, #0
    f0dc:	e9cd 380f 	strd	r3, r8, [sp, #60]	; 0x3c
    f0e0:	e9cd 0102 	strd	r0, r1, [sp, #8]
    f0e4:	e9cd ba11 	strd	fp, sl, [sp, #68]	; 0x44
    f0e8:	f8cd 904c 	str.w	r9, [sp, #76]	; 0x4c
        q64 = (ui64Val>>1) + (ui64Val>>2);
    f0ec:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
        q64 += (q64 >> 4);
    f0f0:	2300      	movs	r3, #0
    f0f2:	2400      	movs	r4, #0
    f0f4:	e9cd 3408 	strd	r3, r4, [sp, #32]
        q64 += (q64 >> 8);
    f0f8:	e9cd 3406 	strd	r3, r4, [sp, #24]
        q64 += (q64 >> 16);
    f0fc:	e9cd 3404 	strd	r3, r4, [sp, #16]
        q64 += (q64 >> 32);
    f100:	e9cd 340a 	strd	r3, r4, [sp, #40]	; 0x28
        q32 = (ui32Val>>1) + (ui32Val>>2);
    f104:	0843      	lsrs	r3, r0, #1
    f106:	eb03 0390 	add.w	r3, r3, r0, lsr #2
        q32 += (q32 >> 4);
    f10a:	eb03 1313 	add.w	r3, r3, r3, lsr #4
        q32 += (q32 >> 8);
    f10e:	eb03 2313 	add.w	r3, r3, r3, lsr #8
        q32 += (q32 >> 16);
    f112:	eb03 4313 	add.w	r3, r3, r3, lsr #16
        q32 >>= 3;
    f116:	08db      	lsrs	r3, r3, #3
        q32 = (ui32Val>>1) + (ui32Val>>2);
    f118:	4602      	mov	r2, r0
        r32 = ui32Val - q32*10;
    f11a:	eb03 0c83 	add.w	ip, r3, r3, lsl #2
        q64 = (ui64Val>>1) + (ui64Val>>2);
    f11e:	0886      	lsrs	r6, r0, #2
    if ( ui64Val >> 32 )
    f120:	460c      	mov	r4, r1
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    f122:	3206      	adds	r2, #6
    if ( ui64Val >> 32 )
    f124:	2500      	movs	r5, #0
        q64 = (ui64Val>>1) + (ui64Val>>2);
    f126:	ea46 7681 	orr.w	r6, r6, r1, lsl #30
    f12a:	088f      	lsrs	r7, r1, #2
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    f12c:	eba2 024c 	sub.w	r2, r2, ip, lsl #1
    if ( ui64Val >> 32 )
    f130:	ea54 0105 	orrs.w	r1, r4, r5
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    f134:	eb03 1312 	add.w	r3, r3, r2, lsr #4
    if ( ui64Val >> 32 )
    f138:	f040 80ba 	bne.w	f2b0 <am_util_stdio_vsprintf+0x65c>
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    f13c:	4619      	mov	r1, r3
    f13e:	2200      	movs	r2, #0
        ++iNDigits;
    f140:	f10e 0e01 	add.w	lr, lr, #1
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    f144:	e9cd 1202 	strd	r1, r2, [sp, #8]
    while ( ui64Val )
    f148:	2b00      	cmp	r3, #0
    f14a:	d1cf      	bne.n	f0ec <am_util_stdio_vsprintf+0x498>
                    iWidth -= ndigits_in_i64(ui64Val);
    f14c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    f14e:	eba3 0e0e 	sub.w	lr, r3, lr
                    if ( bNeg )
    f152:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    f154:	e9dd 8b10 	ldrd	r8, fp, [sp, #64]	; 0x40
    f158:	e9dd a912 	ldrd	sl, r9, [sp, #72]	; 0x48
    f15c:	b13b      	cbz	r3, f16e <am_util_stdio_vsprintf+0x51a>
                        if ( ui8PadChar == '0' )
    f15e:	f1b8 0f30 	cmp.w	r8, #48	; 0x30
                        --iWidth;
    f162:	f10e 3eff 	add.w	lr, lr, #4294967295	; 0xffffffff
                        if ( ui8PadChar == '0' )
    f166:	f000 82a3 	beq.w	f6b0 <am_util_stdio_vsprintf+0xa5c>
    f16a:	2301      	movs	r3, #1
    f16c:	930f      	str	r3, [sp, #60]	; 0x3c
    if ( i32NumChars <= 0 )
    f16e:	f1be 0f00 	cmp.w	lr, #0
    f172:	f300 821e 	bgt.w	f5b2 <am_util_stdio_vsprintf+0x95e>
    f176:	2200      	movs	r2, #0
                    pcBuf += pcBuf ? iWidth : 0;
    f178:	f1ba 0f00 	cmp.w	sl, #0
    f17c:	f000 82fc 	beq.w	f778 <am_util_stdio_vsprintf+0xb24>
                    if ( bNeg  &&  (ui8PadChar == ' ') )
    f180:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
                    pcBuf += pcBuf ? iWidth : 0;
    f182:	4492      	add	sl, r2
                    if ( bNeg  &&  (ui8PadChar == ' ') )
    f184:	b11b      	cbz	r3, f18e <am_util_stdio_vsprintf+0x53a>
    f186:	f1b8 0f20 	cmp.w	r8, #32
    f18a:	f000 8132 	beq.w	f3f2 <am_util_stdio_vsprintf+0x79e>
                iVal = uint64_to_str(ui64Val, pcBuf);
    f18e:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
    f192:	4652      	mov	r2, sl
    f194:	f7ff fc88 	bl	eaa8 <uint64_to_str>
                if ( pcBuf )
    f198:	f1ba 0f00 	cmp.w	sl, #0
    f19c:	d081      	beq.n	f0a2 <am_util_stdio_vsprintf+0x44e>
                    pcBuf += iVal;
    f19e:	4482      	add	sl, r0
                ui32CharCnt += iVal;
    f1a0:	4483      	add	fp, r0
    f1a2:	e55f      	b.n	ec64 <am_util_stdio_vsprintf+0x10>
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    f1a4:	9a01      	ldr	r2, [sp, #4]
    f1a6:	6813      	ldr	r3, [r2, #0]
                                      va_arg(pArgs, uint32_t);
    f1a8:	3204      	adds	r2, #4
    f1aa:	9201      	str	r2, [sp, #4]
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    f1ac:	4619      	mov	r1, r3
    f1ae:	2200      	movs	r2, #0
    f1b0:	e9cd 120c 	strd	r1, r2, [sp, #48]	; 0x30
                if ( iWidth )
    f1b4:	2c00      	cmp	r4, #0
    f1b6:	f040 8127 	bne.w	f408 <am_util_stdio_vsprintf+0x7b4>
                iVal = uint64_to_str(ui64Val, pcBuf);
    f1ba:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
    f1be:	4652      	mov	r2, sl
    f1c0:	f7ff fc72 	bl	eaa8 <uint64_to_str>
                if ( pcBuf )
    f1c4:	f1ba 0f00 	cmp.w	sl, #0
    f1c8:	d1e9      	bne.n	f19e <am_util_stdio_vsprintf+0x54a>
    f1ca:	f04f 0a00 	mov.w	sl, #0
                ui32CharCnt += iVal;
    f1ce:	4483      	add	fp, r0
    f1d0:	e548      	b.n	ec64 <am_util_stdio_vsprintf+0x10>
                bLower = true;
    f1d2:	2501      	movs	r5, #1
    f1d4:	e74b      	b.n	f06e <am_util_stdio_vsprintf+0x41a>
        bLower = bLongLong = false;
    f1d6:	2300      	movs	r3, #0
                bLower = true;
    f1d8:	2501      	movs	r5, #1
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    f1da:	2b00      	cmp	r3, #0
    f1dc:	f43f af47 	beq.w	f06e <am_util_stdio_vsprintf+0x41a>
    f1e0:	9b01      	ldr	r3, [sp, #4]
    f1e2:	3307      	adds	r3, #7
    f1e4:	f023 0307 	bic.w	r3, r3, #7
    f1e8:	f103 0208 	add.w	r2, r3, #8
    f1ec:	9201      	str	r2, [sp, #4]
    f1ee:	e9d3 2300 	ldrd	r2, r3, [r3]
                if ( iWidth )
    f1f2:	2c00      	cmp	r4, #0
    f1f4:	f43f af43 	beq.w	f07e <am_util_stdio_vsprintf+0x42a>
    int iDigits = ui64Val ? 0 : 1;
    f1f8:	ea52 0103 	orrs.w	r1, r2, r3
    f1fc:	bf0c      	ite	eq
    f1fe:	2401      	moveq	r4, #1
    f200:	2400      	movne	r4, #0
    while ( ui64Val )
    f202:	ea52 0103 	orrs.w	r1, r2, r3
    f206:	d00c      	beq.n	f222 <am_util_stdio_vsprintf+0x5ce>
    f208:	4610      	mov	r0, r2
    f20a:	4619      	mov	r1, r3
        ui64Val >>= 4;
    f20c:	0906      	lsrs	r6, r0, #4
    f20e:	ea46 7601 	orr.w	r6, r6, r1, lsl #28
    f212:	090f      	lsrs	r7, r1, #4
    f214:	4630      	mov	r0, r6
    f216:	4639      	mov	r1, r7
    while ( ui64Val )
    f218:	ea50 0601 	orrs.w	r6, r0, r1
        ++iDigits;
    f21c:	f104 0401 	add.w	r4, r4, #1
    while ( ui64Val )
    f220:	d1f4      	bne.n	f20c <am_util_stdio_vsprintf+0x5b8>
                    iWidth -= ndigits_in_hex(ui64Val);
    f222:	990e      	ldr	r1, [sp, #56]	; 0x38
    f224:	1b09      	subs	r1, r1, r4
    if ( i32NumChars <= 0 )
    f226:	2900      	cmp	r1, #0
    f228:	f300 81a1 	bgt.w	f56e <am_util_stdio_vsprintf+0x91a>
    f22c:	2000      	movs	r0, #0
                    pcBuf += pcBuf ? iWidth : 0;
    f22e:	f1ba 0f00 	cmp.w	sl, #0
    f232:	f000 81b5 	beq.w	f5a0 <am_util_stdio_vsprintf+0x94c>
    if ( ui64Val == 0 )
    f236:	ea52 0103 	orrs.w	r1, r2, r3
    f23a:	4482      	add	sl, r0
    f23c:	f43f af23 	beq.w	f086 <am_util_stdio_vsprintf+0x432>
    f240:	2d00      	cmp	r5, #0
    f242:	bf14      	ite	ne
    f244:	2527      	movne	r5, #39	; 0x27
    f246:	2507      	moveq	r5, #7
    if ( i32NumChars <= 0 )
    f248:	af15      	add	r7, sp, #84	; 0x54
    int iNumDig, ix = 0;
    f24a:	2600      	movs	r6, #0
    f24c:	f8cd 9008 	str.w	r9, [sp, #8]
        ui64Val >>= 4;
    f250:	0914      	lsrs	r4, r2, #4
        cCh = ui64Val & 0xf;
    f252:	f002 020f 	and.w	r2, r2, #15
        ui64Val >>= 4;
    f256:	ea4f 1813 	mov.w	r8, r3, lsr #4
            cCh += bLower ? 0x27 : 0x7;
    f25a:	18a8      	adds	r0, r5, r2
        if ( cCh > 9 )
    f25c:	2a09      	cmp	r2, #9
        ui64Val >>= 4;
    f25e:	46c6      	mov	lr, r8
    f260:	ea44 7403 	orr.w	r4, r4, r3, lsl #28
        tbuf[ix++] = cCh + '0';
    f264:	f100 0030 	add.w	r0, r0, #48	; 0x30
    f268:	f102 0c30 	add.w	ip, r2, #48	; 0x30
    f26c:	f106 0901 	add.w	r9, r6, #1
        if ( cCh > 9 )
    f270:	d978      	bls.n	f364 <am_util_stdio_vsprintf+0x710>
        ui64Val >>= 4;
    f272:	4622      	mov	r2, r4
    f274:	4643      	mov	r3, r8
    while ( ui64Val )
    f276:	ea52 0103 	orrs.w	r1, r2, r3
        tbuf[ix++] = cCh + '0';
    f27a:	f807 0b01 	strb.w	r0, [r7], #1
    while ( ui64Val )
    f27e:	d07a      	beq.n	f376 <am_util_stdio_vsprintf+0x722>
    if ( i32NumChars <= 0 )
    f280:	464e      	mov	r6, r9
    f282:	e7e5      	b.n	f250 <am_util_stdio_vsprintf+0x5fc>
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    f284:	9b01      	ldr	r3, [sp, #4]
    f286:	3307      	adds	r3, #7
    f288:	f023 0307 	bic.w	r3, r3, #7
    f28c:	f103 0208 	add.w	r2, r3, #8
    f290:	9201      	str	r2, [sp, #4]
    f292:	e9d3 2300 	ldrd	r2, r3, [r3]
    f296:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
    f29a:	e78b      	b.n	f1b4 <am_util_stdio_vsprintf+0x560>
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
    f29c:	9b01      	ldr	r3, [sp, #4]
    f29e:	3307      	adds	r3, #7
    f2a0:	f023 0307 	bic.w	r3, r3, #7
    f2a4:	f103 0208 	add.w	r2, r3, #8
    f2a8:	9201      	str	r2, [sp, #4]
    f2aa:	e9d3 0100 	ldrd	r0, r1, [r3]
    f2ae:	e6ff      	b.n	f0b0 <am_util_stdio_vsprintf+0x45c>
        q64 = (ui64Val>>1) + (ui64Val>>2);
    f2b0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    f2b4:	085b      	lsrs	r3, r3, #1
    f2b6:	ea4f 0232 	mov.w	r2, r2, rrx
    f2ba:	1990      	adds	r0, r2, r6
    f2bc:	eb43 0107 	adc.w	r1, r3, r7
        q64 += (q64 >> 4);
    f2c0:	0903      	lsrs	r3, r0, #4
    f2c2:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
    f2c6:	9308      	str	r3, [sp, #32]
    f2c8:	090b      	lsrs	r3, r1, #4
    f2ca:	9309      	str	r3, [sp, #36]	; 0x24
    f2cc:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
    f2d0:	1812      	adds	r2, r2, r0
    f2d2:	414b      	adcs	r3, r1
        q64 += (q64 >> 8);
    f2d4:	0a11      	lsrs	r1, r2, #8
    f2d6:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
    f2da:	9106      	str	r1, [sp, #24]
    f2dc:	0a19      	lsrs	r1, r3, #8
    f2de:	9107      	str	r1, [sp, #28]
    f2e0:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    f2e4:	1880      	adds	r0, r0, r2
    f2e6:	4159      	adcs	r1, r3
    f2e8:	460b      	mov	r3, r1
        q64 += (q64 >> 16);
    f2ea:	0c01      	lsrs	r1, r0, #16
    f2ec:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    f2f0:	9104      	str	r1, [sp, #16]
    f2f2:	0c19      	lsrs	r1, r3, #16
    f2f4:	9105      	str	r1, [sp, #20]
        q64 += (q64 >> 8);
    f2f6:	4602      	mov	r2, r0
        q64 += (q64 >> 16);
    f2f8:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    f2fc:	1880      	adds	r0, r0, r2
    f2fe:	4159      	adcs	r1, r3
        q64 += (q64 >> 32);
    f300:	e9cd 150a 	strd	r1, r5, [sp, #40]	; 0x28
        q64 += (q64 >> 16);
    f304:	4602      	mov	r2, r0
    f306:	460b      	mov	r3, r1
        q64 += (q64 >> 32);
    f308:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    f30c:	1880      	adds	r0, r0, r2
    f30e:	4159      	adcs	r1, r3
        q64 >>= 3;
    f310:	ea4f 08d0 	mov.w	r8, r0, lsr #3
    f314:	ea48 7841 	orr.w	r8, r8, r1, lsl #29
    f318:	ea4f 09d1 	mov.w	r9, r1, lsr #3
        return q64 + ((r64 + 6) >> 4);
    f31c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
        r64 = ui64Val - q64*10;
    f320:	ea4f 0489 	mov.w	r4, r9, lsl #2
    f324:	ea4f 0288 	mov.w	r2, r8, lsl #2
    f328:	ea44 7398 	orr.w	r3, r4, r8, lsr #30
    f32c:	eb12 0408 	adds.w	r4, r2, r8
    f330:	eb43 0509 	adc.w	r5, r3, r9
        return q64 + ((r64 + 6) >> 4);
    f334:	3006      	adds	r0, #6
    f336:	f141 0100 	adc.w	r1, r1, #0
        r64 = ui64Val - q64*10;
    f33a:	1922      	adds	r2, r4, r4
    f33c:	eb45 0305 	adc.w	r3, r5, r5
        return q64 + ((r64 + 6) >> 4);
    f340:	1a80      	subs	r0, r0, r2
    f342:	eb61 0103 	sbc.w	r1, r1, r3
    f346:	ea4f 1a10 	mov.w	sl, r0, lsr #4
    f34a:	ea4a 7a01 	orr.w	sl, sl, r1, lsl #28
    f34e:	eb1a 0308 	adds.w	r3, sl, r8
    f352:	ea4f 1b11 	mov.w	fp, r1, lsr #4
    f356:	eb4b 0409 	adc.w	r4, fp, r9
        ++iNDigits;
    f35a:	f10e 0e01 	add.w	lr, lr, #1
        return q64 + ((r64 + 6) >> 4);
    f35e:	e9cd 3402 	strd	r3, r4, [sp, #8]
    f362:	e6c3      	b.n	f0ec <am_util_stdio_vsprintf+0x498>
        ui64Val >>= 4;
    f364:	4622      	mov	r2, r4
    f366:	4643      	mov	r3, r8
    while ( ui64Val )
    f368:	ea52 0103 	orrs.w	r1, r2, r3
        tbuf[ix++] = cCh + '0';
    f36c:	f106 0901 	add.w	r9, r6, #1
    f370:	f807 cb01 	strb.w	ip, [r7], #1
    while ( ui64Val )
    f374:	d184      	bne.n	f280 <am_util_stdio_vsprintf+0x62c>
    f376:	464d      	mov	r5, r9
    f378:	4628      	mov	r0, r5
    f37a:	f8dd 9008 	ldr.w	r9, [sp, #8]
    if (pcBuf)
    f37e:	f1ba 0f00 	cmp.w	sl, #0
    f382:	f43f af22 	beq.w	f1ca <am_util_stdio_vsprintf+0x576>
    f386:	ab15      	add	r3, sp, #84	; 0x54
    f388:	eb0a 0405 	add.w	r4, sl, r5
    f38c:	442b      	add	r3, r5
    f38e:	f10a 32ff 	add.w	r2, sl, #4294967295	; 0xffffffff
            *pcBuf++ = tbuf[ix];
    f392:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
    f396:	f802 1f01 	strb.w	r1, [r2, #1]!
        while (ix--)
    f39a:	a915      	add	r1, sp, #84	; 0x54
    f39c:	4299      	cmp	r1, r3
    f39e:	d1f8      	bne.n	f392 <am_util_stdio_vsprintf+0x73e>
    f3a0:	4455      	add	r5, sl
    f3a2:	46a2      	mov	sl, r4
    f3a4:	e67b      	b.n	f09e <am_util_stdio_vsprintf+0x44a>
    f3a6:	46ba      	mov	sl, r7
                if ( iWidth )
    f3a8:	2900      	cmp	r1, #0
    f3aa:	f43f ae46 	beq.w	f03a <am_util_stdio_vsprintf+0x3e6>
                    iWidth = -iWidth;
    f3ae:	4249      	negs	r1, r1
                    if ( ui32strlen < iWidth )
    f3b0:	42b1      	cmp	r1, r6
    f3b2:	f67f ae42 	bls.w	f03a <am_util_stdio_vsprintf+0x3e6>
                        iWidth -= ui32strlen;
    f3b6:	1b89      	subs	r1, r1, r6
    if ( i32NumChars <= 0 )
    f3b8:	2900      	cmp	r1, #0
    f3ba:	f300 8163 	bgt.w	f684 <am_util_stdio_vsprintf+0xa30>
    f3be:	2100      	movs	r1, #0
                        pcBuf += pcBuf ? iWidth : 0;
    f3c0:	f1ba 0f00 	cmp.w	sl, #0
    f3c4:	f43f ae39 	beq.w	f03a <am_util_stdio_vsprintf+0x3e6>
    f3c8:	448a      	add	sl, r1
    f3ca:	e636      	b.n	f03a <am_util_stdio_vsprintf+0x3e6>
    f3cc:	7891      	ldrb	r1, [r2, #2]
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    f3ce:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
    f3d2:	2b09      	cmp	r3, #9
        pcStr++;
    f3d4:	f102 0002 	add.w	r0, r2, #2
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    f3d8:	f200 8234 	bhi.w	f844 <am_util_stdio_vsprintf+0xbf0>
        bNeg = true;
    f3dc:	2601      	movs	r6, #1
        uCnt++;
    f3de:	4632      	mov	r2, r6
    f3e0:	e5e2      	b.n	efa8 <am_util_stdio_vsprintf+0x354>
                    ui64Val = -i64Val;          // Get absolute value
    f3e2:	4240      	negs	r0, r0
    f3e4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    f3e8:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
                if ( iWidth )
    f3ec:	2c00      	cmp	r4, #0
    f3ee:	f040 80fa 	bne.w	f5e6 <am_util_stdio_vsprintf+0x992>
                        if ( pcBuf )
    f3f2:	f1ba 0f00 	cmp.w	sl, #0
    f3f6:	d004      	beq.n	f402 <am_util_stdio_vsprintf+0x7ae>
                            *pcBuf++ = '-';
    f3f8:	232d      	movs	r3, #45	; 0x2d
    f3fa:	f88a 3000 	strb.w	r3, [sl]
    f3fe:	f10a 0a01 	add.w	sl, sl, #1
                        ++ui32CharCnt;
    f402:	f10b 0b01 	add.w	fp, fp, #1
    f406:	e6c2      	b.n	f18e <am_util_stdio_vsprintf+0x53a>
    int iNDigits = ui64Val ? 0 : 1;
    f408:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
    f40c:	4603      	mov	r3, r0
    f40e:	430b      	orrs	r3, r1
    while ( ui64Val )
    f410:	460c      	mov	r4, r1
    f412:	4603      	mov	r3, r0
    int iNDigits = ui64Val ? 0 : 1;
    f414:	bf0c      	ite	eq
    f416:	f04f 0e01 	moveq.w	lr, #1
    f41a:	f04f 0e00 	movne.w	lr, #0
    while ( ui64Val )
    f41e:	4323      	orrs	r3, r4
    f420:	d03c      	beq.n	f49c <am_util_stdio_vsprintf+0x848>
    f422:	e9cd 0102 	strd	r0, r1, [sp, #8]
    f426:	e9cd ba10 	strd	fp, sl, [sp, #64]	; 0x40
    f42a:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
    f42e:	f8cd 9048 	str.w	r9, [sp, #72]	; 0x48
        q64 = (ui64Val>>1) + (ui64Val>>2);
    f432:	e9dd 5602 	ldrd	r5, r6, [sp, #8]
        q64 += (q64 >> 4);
    f436:	2300      	movs	r3, #0
    f438:	2400      	movs	r4, #0
        q64 = (ui64Val>>1) + (ui64Val>>2);
    f43a:	08a8      	lsrs	r0, r5, #2
        q64 += (q64 >> 4);
    f43c:	e9cd 3408 	strd	r3, r4, [sp, #32]
        q64 += (q64 >> 8);
    f440:	e9cd 3406 	strd	r3, r4, [sp, #24]
        q64 += (q64 >> 16);
    f444:	e9cd 3404 	strd	r3, r4, [sp, #16]
        q64 += (q64 >> 32);
    f448:	e9cd 340a 	strd	r3, r4, [sp, #40]	; 0x28
        q64 = (ui64Val>>1) + (ui64Val>>2);
    f44c:	ea40 7086 	orr.w	r0, r0, r6, lsl #30
        q32 = (ui32Val>>1) + (ui32Val>>2);
    f450:	462c      	mov	r4, r5
        q64 = (ui64Val>>1) + (ui64Val>>2);
    f452:	08b1      	lsrs	r1, r6, #2
        q32 = (ui32Val>>1) + (ui32Val>>2);
    f454:	086e      	lsrs	r6, r5, #1
    f456:	eb06 0694 	add.w	r6, r6, r4, lsr #2
        q32 += (q32 >> 4);
    f45a:	eb06 1616 	add.w	r6, r6, r6, lsr #4
    if ( ui64Val >> 32 )
    f45e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
        q32 += (q32 >> 8);
    f462:	eb06 2616 	add.w	r6, r6, r6, lsr #8
        q32 += (q32 >> 16);
    f466:	eb06 4616 	add.w	r6, r6, r6, lsr #16
        q32 >>= 3;
    f46a:	08f6      	lsrs	r6, r6, #3
        r32 = ui32Val - q32*10;
    f46c:	eb06 0c86 	add.w	ip, r6, r6, lsl #2
    if ( ui64Val >> 32 )
    f470:	461c      	mov	r4, r3
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    f472:	1d97      	adds	r7, r2, #6
    if ( ui64Val >> 32 )
    f474:	2500      	movs	r5, #0
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    f476:	eba7 074c 	sub.w	r7, r7, ip, lsl #1
    if ( ui64Val >> 32 )
    f47a:	ea54 0305 	orrs.w	r3, r4, r5
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    f47e:	eb06 1617 	add.w	r6, r6, r7, lsr #4
    if ( ui64Val >> 32 )
    f482:	d118      	bne.n	f4b6 <am_util_stdio_vsprintf+0x862>
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    f484:	4633      	mov	r3, r6
    f486:	2400      	movs	r4, #0
        ++iNDigits;
    f488:	f10e 0e01 	add.w	lr, lr, #1
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    f48c:	e9cd 3402 	strd	r3, r4, [sp, #8]
    while ( ui64Val )
    f490:	2e00      	cmp	r6, #0
    f492:	d1ce      	bne.n	f432 <am_util_stdio_vsprintf+0x7de>
    f494:	e9dd 8b0f 	ldrd	r8, fp, [sp, #60]	; 0x3c
    f498:	e9dd a911 	ldrd	sl, r9, [sp, #68]	; 0x44
                    iWidth -= ndigits_in_u64(ui64Val);
    f49c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    f49e:	eba3 030e 	sub.w	r3, r3, lr
    if ( i32NumChars <= 0 )
    f4a2:	2b00      	cmp	r3, #0
    f4a4:	f300 80c7 	bgt.w	f636 <am_util_stdio_vsprintf+0x9e2>
    f4a8:	2200      	movs	r2, #0
                    pcBuf += pcBuf ? iWidth : 0;
    f4aa:	f1ba 0f00 	cmp.w	sl, #0
    f4ae:	f000 8190 	beq.w	f7d2 <am_util_stdio_vsprintf+0xb7e>
    f4b2:	4492      	add	sl, r2
    f4b4:	e681      	b.n	f1ba <am_util_stdio_vsprintf+0x566>
        q64 = (ui64Val>>1) + (ui64Val>>2);
    f4b6:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
    f4ba:	087f      	lsrs	r7, r7, #1
    f4bc:	ea4f 0636 	mov.w	r6, r6, rrx
    f4c0:	1982      	adds	r2, r0, r6
    f4c2:	eb41 0307 	adc.w	r3, r1, r7
        q64 += (q64 >> 4);
    f4c6:	0911      	lsrs	r1, r2, #4
    f4c8:	ea41 7103 	orr.w	r1, r1, r3, lsl #28
    f4cc:	9108      	str	r1, [sp, #32]
    f4ce:	0919      	lsrs	r1, r3, #4
    f4d0:	9109      	str	r1, [sp, #36]	; 0x24
    f4d2:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
    f4d6:	1880      	adds	r0, r0, r2
    f4d8:	4159      	adcs	r1, r3
    f4da:	460b      	mov	r3, r1
        q64 += (q64 >> 8);
    f4dc:	0a01      	lsrs	r1, r0, #8
    f4de:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
    f4e2:	9106      	str	r1, [sp, #24]
    f4e4:	0a19      	lsrs	r1, r3, #8
    f4e6:	9107      	str	r1, [sp, #28]
        q64 += (q64 >> 4);
    f4e8:	4602      	mov	r2, r0
        q64 += (q64 >> 8);
    f4ea:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    f4ee:	1880      	adds	r0, r0, r2
    f4f0:	4159      	adcs	r1, r3
    f4f2:	460b      	mov	r3, r1
        q64 += (q64 >> 16);
    f4f4:	0c01      	lsrs	r1, r0, #16
    f4f6:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    f4fa:	9104      	str	r1, [sp, #16]
    f4fc:	0c19      	lsrs	r1, r3, #16
    f4fe:	9105      	str	r1, [sp, #20]
        q64 += (q64 >> 8);
    f500:	4602      	mov	r2, r0
        q64 += (q64 >> 16);
    f502:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    f506:	1880      	adds	r0, r0, r2
    f508:	4159      	adcs	r1, r3
        q64 += (q64 >> 32);
    f50a:	e9cd 150a 	strd	r1, r5, [sp, #40]	; 0x28
        q64 += (q64 >> 16);
    f50e:	4602      	mov	r2, r0
    f510:	460b      	mov	r3, r1
        q64 += (q64 >> 32);
    f512:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    f516:	1880      	adds	r0, r0, r2
    f518:	4159      	adcs	r1, r3
        q64 >>= 3;
    f51a:	ea4f 08d0 	mov.w	r8, r0, lsr #3
    f51e:	ea48 7841 	orr.w	r8, r8, r1, lsl #29
    f522:	ea4f 09d1 	mov.w	r9, r1, lsr #3
        return q64 + ((r64 + 6) >> 4);
    f526:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
        r64 = ui64Val - q64*10;
    f52a:	ea4f 0489 	mov.w	r4, r9, lsl #2
    f52e:	ea4f 0288 	mov.w	r2, r8, lsl #2
    f532:	ea44 7398 	orr.w	r3, r4, r8, lsr #30
    f536:	eb12 0408 	adds.w	r4, r2, r8
    f53a:	eb43 0509 	adc.w	r5, r3, r9
        return q64 + ((r64 + 6) >> 4);
    f53e:	3006      	adds	r0, #6
    f540:	f141 0100 	adc.w	r1, r1, #0
        r64 = ui64Val - q64*10;
    f544:	1922      	adds	r2, r4, r4
    f546:	eb45 0305 	adc.w	r3, r5, r5
        return q64 + ((r64 + 6) >> 4);
    f54a:	1a80      	subs	r0, r0, r2
    f54c:	eb61 0103 	sbc.w	r1, r1, r3
    f550:	ea4f 1a10 	mov.w	sl, r0, lsr #4
    f554:	ea4a 7a01 	orr.w	sl, sl, r1, lsl #28
    f558:	eb1a 0308 	adds.w	r3, sl, r8
    f55c:	ea4f 1b11 	mov.w	fp, r1, lsr #4
    f560:	eb4b 0409 	adc.w	r4, fp, r9
        ++iNDigits;
    f564:	f10e 0e01 	add.w	lr, lr, #1
        return q64 + ((r64 + 6) >> 4);
    f568:	e9cd 3402 	strd	r3, r4, [sp, #8]
    f56c:	e761      	b.n	f432 <am_util_stdio_vsprintf+0x7de>
    while ( i32NumChars-- )
    f56e:	3901      	subs	r1, #1
    f570:	4656      	mov	r6, sl
    int32_t i32Cnt = 0;
    f572:	2000      	movs	r0, #0
    f574:	1e4f      	subs	r7, r1, #1
    f576:	1c44      	adds	r4, r0, #1
        if ( pcBuf )
    f578:	b156      	cbz	r6, f590 <am_util_stdio_vsprintf+0x93c>
            *pcBuf++ = cPadChar;
    f57a:	46bc      	mov	ip, r7
    f57c:	460f      	mov	r7, r1
    f57e:	f886 8000 	strb.w	r8, [r6]
    f582:	4620      	mov	r0, r4
    f584:	4661      	mov	r1, ip
    f586:	3601      	adds	r6, #1
    while ( i32NumChars-- )
    f588:	2f00      	cmp	r7, #0
    f58a:	d1f3      	bne.n	f574 <am_util_stdio_vsprintf+0x920>
    f58c:	4483      	add	fp, r0
    f58e:	e64e      	b.n	f22e <am_util_stdio_vsprintf+0x5da>
    f590:	2900      	cmp	r1, #0
    f592:	f000 8126 	beq.w	f7e2 <am_util_stdio_vsprintf+0xb8e>
    f596:	3902      	subs	r1, #2
    f598:	3002      	adds	r0, #2
    f59a:	2f00      	cmp	r7, #0
    f59c:	d1ea      	bne.n	f574 <am_util_stdio_vsprintf+0x920>
    f59e:	e7f5      	b.n	f58c <am_util_stdio_vsprintf+0x938>
    if ( ui64Val == 0 )
    f5a0:	ea52 0103 	orrs.w	r1, r2, r3
    f5a4:	f47f ae4c 	bne.w	f240 <am_util_stdio_vsprintf+0x5ec>
    f5a8:	2001      	movs	r0, #1
    f5aa:	e60e      	b.n	f1ca <am_util_stdio_vsprintf+0x576>
    uint32_t ui32Val = 0, uCnt = 0;
    f5ac:	2200      	movs	r2, #0
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    f5ae:	4613      	mov	r3, r2
    f5b0:	e50b      	b.n	efca <am_util_stdio_vsprintf+0x376>
    while ( i32NumChars-- )
    f5b2:	f10e 33ff 	add.w	r3, lr, #4294967295	; 0xffffffff
    f5b6:	4650      	mov	r0, sl
    int32_t i32Cnt = 0;
    f5b8:	2200      	movs	r2, #0
    f5ba:	1e5c      	subs	r4, r3, #1
    f5bc:	1c51      	adds	r1, r2, #1
        if ( pcBuf )
    f5be:	b150      	cbz	r0, f5d6 <am_util_stdio_vsprintf+0x982>
            *pcBuf++ = cPadChar;
    f5c0:	4625      	mov	r5, r4
    f5c2:	461c      	mov	r4, r3
    f5c4:	f880 8000 	strb.w	r8, [r0]
    f5c8:	460a      	mov	r2, r1
    f5ca:	462b      	mov	r3, r5
    f5cc:	3001      	adds	r0, #1
    while ( i32NumChars-- )
    f5ce:	2c00      	cmp	r4, #0
    f5d0:	d1f3      	bne.n	f5ba <am_util_stdio_vsprintf+0x966>
    f5d2:	4493      	add	fp, r2
    f5d4:	e5d0      	b.n	f178 <am_util_stdio_vsprintf+0x524>
    f5d6:	2b00      	cmp	r3, #0
    f5d8:	f000 8110 	beq.w	f7fc <am_util_stdio_vsprintf+0xba8>
    f5dc:	3b02      	subs	r3, #2
    f5de:	3202      	adds	r2, #2
    f5e0:	2c00      	cmp	r4, #0
    f5e2:	d1ea      	bne.n	f5ba <am_util_stdio_vsprintf+0x966>
    f5e4:	e7f5      	b.n	f5d2 <am_util_stdio_vsprintf+0x97e>
    int iNDigits = ui64Val ? 0 : 1;
    f5e6:	4603      	mov	r3, r0
    f5e8:	430b      	orrs	r3, r1
    f5ea:	bf0c      	ite	eq
    f5ec:	f04f 0e01 	moveq.w	lr, #1
    f5f0:	f04f 0e00 	movne.w	lr, #0
                    bNeg = true;
    f5f4:	2301      	movs	r3, #1
    f5f6:	e571      	b.n	f0dc <am_util_stdio_vsprintf+0x488>
    else if (iExp2 >= 0)
    f5f8:	2a00      	cmp	r2, #0
    f5fa:	f2c0 80f5 	blt.w	f7e8 <am_util_stdio_vsprintf+0xb94>
        i32FracPart = (i32Significand << (iExp2 + 1)) & 0x00FFFFFF;
    f5fe:	f1a1 047e 	sub.w	r4, r1, #126	; 0x7e
    f602:	fa00 f404 	lsl.w	r4, r0, r4
        i32IntPart = i32Significand >> (23 - iExp2);
    f606:	f1c2 0217 	rsb	r2, r2, #23
    if (unFloatValue.I32 < 0)
    f60a:	2b00      	cmp	r3, #0
        i32FracPart = (i32Significand << (iExp2 + 1)) & 0x00FFFFFF;
    f60c:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
        i32IntPart = i32Significand >> (23 - iExp2);
    f610:	fa40 f002 	asr.w	r0, r0, r2
    if (unFloatValue.I32 < 0)
    f614:	f2c0 80d5 	blt.w	f7c2 <am_util_stdio_vsprintf+0xb6e>
    f618:	4656      	mov	r6, sl
            uint64_to_str(i32IntPart, pcBuf);
    f61a:	4632      	mov	r2, r6
    f61c:	17c1      	asrs	r1, r0, #31
    f61e:	f7ff fa43 	bl	eaa8 <uint64_to_str>
        while (*pcBuf)    // Get to end of new string
    f622:	7833      	ldrb	r3, [r6, #0]
    f624:	b90b      	cbnz	r3, f62a <am_util_stdio_vsprintf+0x9d6>
    f626:	e100      	b.n	f82a <am_util_stdio_vsprintf+0xbd6>
    f628:	463e      	mov	r6, r7
    f62a:	7873      	ldrb	r3, [r6, #1]
            pcBuf++;
    f62c:	1c77      	adds	r7, r6, #1
        while (*pcBuf)    // Get to end of new string
    f62e:	2b00      	cmp	r3, #0
    f630:	d1fa      	bne.n	f628 <am_util_stdio_vsprintf+0x9d4>
    f632:	1cb2      	adds	r2, r6, #2
    f634:	e480      	b.n	ef38 <am_util_stdio_vsprintf+0x2e4>
    while ( i32NumChars-- )
    f636:	3b01      	subs	r3, #1
    f638:	4650      	mov	r0, sl
    int32_t i32Cnt = 0;
    f63a:	2200      	movs	r2, #0
    f63c:	1c51      	adds	r1, r2, #1
    f63e:	1e5c      	subs	r4, r3, #1
        if ( pcBuf )
    f640:	2800      	cmp	r0, #0
    f642:	d042      	beq.n	f6ca <am_util_stdio_vsprintf+0xa76>
            *pcBuf++ = cPadChar;
    f644:	4625      	mov	r5, r4
    f646:	f880 8000 	strb.w	r8, [r0]
    f64a:	461c      	mov	r4, r3
    f64c:	460a      	mov	r2, r1
    f64e:	462b      	mov	r3, r5
    f650:	3001      	adds	r0, #1
    while ( i32NumChars-- )
    f652:	2c00      	cmp	r4, #0
    f654:	d1f2      	bne.n	f63c <am_util_stdio_vsprintf+0x9e8>
    f656:	4493      	add	fp, r2
    f658:	e727      	b.n	f4aa <am_util_stdio_vsprintf+0x856>
    f65a:	1e48      	subs	r0, r1, #1
    f65c:	4654      	mov	r4, sl
    int32_t i32Cnt = 0;
    f65e:	2300      	movs	r3, #0
    f660:	1c59      	adds	r1, r3, #1
    f662:	1e45      	subs	r5, r0, #1
        if ( pcBuf )
    f664:	b3bc      	cbz	r4, f6d6 <am_util_stdio_vsprintf+0xa82>
            *pcBuf++ = cPadChar;
    f666:	f884 8000 	strb.w	r8, [r4]
    f66a:	460b      	mov	r3, r1
    f66c:	3401      	adds	r4, #1
    f66e:	4601      	mov	r1, r0
    while ( i32NumChars-- )
    f670:	4628      	mov	r0, r5
    f672:	2900      	cmp	r1, #0
    f674:	d1f4      	bne.n	f660 <am_util_stdio_vsprintf+0xa0c>
    f676:	eb0b 0403 	add.w	r4, fp, r3
    f67a:	e4ec      	b.n	f056 <am_util_stdio_vsprintf+0x402>
                bLongLong = true;
    f67c:	2301      	movs	r3, #1
    f67e:	e5ab      	b.n	f1d8 <am_util_stdio_vsprintf+0x584>
        bLower = bLongLong = false;
    f680:	2500      	movs	r5, #0
    f682:	e5ad      	b.n	f1e0 <am_util_stdio_vsprintf+0x58c>
    while ( i32NumChars-- )
    f684:	1e4b      	subs	r3, r1, #1
    f686:	4654      	mov	r4, sl
    int32_t i32Cnt = 0;
    f688:	2100      	movs	r1, #0
    f68a:	1c48      	adds	r0, r1, #1
    f68c:	1e5d      	subs	r5, r3, #1
        if ( pcBuf )
    f68e:	b34c      	cbz	r4, f6e4 <am_util_stdio_vsprintf+0xa90>
            *pcBuf++ = cPadChar;
    f690:	f884 8000 	strb.w	r8, [r4]
    f694:	4601      	mov	r1, r0
    f696:	3401      	adds	r4, #1
    f698:	4618      	mov	r0, r3
    while ( i32NumChars-- )
    f69a:	462b      	mov	r3, r5
    f69c:	2800      	cmp	r0, #0
    f69e:	d1f4      	bne.n	f68a <am_util_stdio_vsprintf+0xa36>
    f6a0:	448b      	add	fp, r1
    f6a2:	e68d      	b.n	f3c0 <am_util_stdio_vsprintf+0x76c>
                if ( iWidth > 0 )
    f6a4:	2900      	cmp	r1, #0
    f6a6:	f340 809a 	ble.w	f7de <am_util_stdio_vsprintf+0xb8a>
                    if ( ui32strlen < iWidth )
    f6aa:	4606      	mov	r6, r0
    f6ac:	1b89      	subs	r1, r1, r6
    f6ae:	e4cd      	b.n	f04c <am_util_stdio_vsprintf+0x3f8>
                            if ( pcBuf )
    f6b0:	f1ba 0f00 	cmp.w	sl, #0
    f6b4:	d004      	beq.n	f6c0 <am_util_stdio_vsprintf+0xa6c>
                                *pcBuf++ = '-';
    f6b6:	232d      	movs	r3, #45	; 0x2d
    f6b8:	f88a 3000 	strb.w	r3, [sl]
    f6bc:	f10a 0a01 	add.w	sl, sl, #1
                            ++ui32CharCnt;
    f6c0:	2301      	movs	r3, #1
    f6c2:	f10b 0b01 	add.w	fp, fp, #1
    f6c6:	930f      	str	r3, [sp, #60]	; 0x3c
    f6c8:	e551      	b.n	f16e <am_util_stdio_vsprintf+0x51a>
    while ( i32NumChars-- )
    f6ca:	2b00      	cmp	r3, #0
    f6cc:	f000 80a1 	beq.w	f812 <am_util_stdio_vsprintf+0xbbe>
    f6d0:	3b02      	subs	r3, #2
    f6d2:	3202      	adds	r2, #2
    f6d4:	e7bd      	b.n	f652 <am_util_stdio_vsprintf+0x9fe>
    f6d6:	2800      	cmp	r0, #0
    f6d8:	f000 809e 	beq.w	f818 <am_util_stdio_vsprintf+0xbc4>
    f6dc:	4629      	mov	r1, r5
    f6de:	3302      	adds	r3, #2
    f6e0:	1e85      	subs	r5, r0, #2
    f6e2:	e7c5      	b.n	f670 <am_util_stdio_vsprintf+0xa1c>
    f6e4:	2b00      	cmp	r3, #0
    f6e6:	f000 809d 	beq.w	f824 <am_util_stdio_vsprintf+0xbd0>
    f6ea:	4628      	mov	r0, r5
    f6ec:	3102      	adds	r1, #2
    f6ee:	1e9d      	subs	r5, r3, #2
    f6f0:	e7d3      	b.n	f69a <am_util_stdio_vsprintf+0xa46>
        iMax = iBufSize - (pcBuf - pcBufInitial) - 1;
    f6f2:	eba2 010a 	sub.w	r1, r2, sl
    f6f6:	f1c1 0313 	rsb	r3, r1, #19
        iMax = (iMax > iPrecision) ? iPrecision : iMax;
    f6fa:	42ab      	cmp	r3, r5
    f6fc:	bfa8      	it	ge
    f6fe:	462b      	movge	r3, r5
        for (jx = 0; jx < iMax; jx++)
    f700:	2b00      	cmp	r3, #0
    f702:	dd0d      	ble.n	f720 <am_util_stdio_vsprintf+0xacc>
    f704:	18d1      	adds	r1, r2, r3
            i32FracPart *= 10;
    f706:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    f70a:	0064      	lsls	r4, r4, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
    f70c:	1623      	asrs	r3, r4, #24
    f70e:	3330      	adds	r3, #48	; 0x30
    f710:	f802 3b01 	strb.w	r3, [r2], #1
        for (jx = 0; jx < iMax; jx++)
    f714:	4291      	cmp	r1, r2
            i32FracPart &= 0x00FFFFFF;
    f716:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
        for (jx = 0; jx < iMax; jx++)
    f71a:	d1f4      	bne.n	f706 <am_util_stdio_vsprintf+0xab2>
    f71c:	eba2 010a 	sub.w	r1, r2, sl
        if ( ((i32FracPart * 10) >> 24) >= 5 )
    f720:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    f724:	f344 53c7 	sbfx	r3, r4, #23, #8
    f728:	2b04      	cmp	r3, #4
    f72a:	f77f ac10 	ble.w	ef4e <am_util_stdio_vsprintf+0x2fa>
            pcBuftmp = pcBuf - 1;
    f72e:	1e53      	subs	r3, r2, #1
            while ( pcBuftmp >= pcBufInitial )
    f730:	459a      	cmp	sl, r3
    f732:	f63f ac0c 	bhi.w	ef4e <am_util_stdio_vsprintf+0x2fa>
    f736:	f10a 35ff 	add.w	r5, sl, #4294967295	; 0xffffffff
    f73a:	e005      	b.n	f748 <am_util_stdio_vsprintf+0xaf4>
                    *pcBuftmp = '0';
    f73c:	f04f 0030 	mov.w	r0, #48	; 0x30
    f740:	7058      	strb	r0, [r3, #1]
            while ( pcBuftmp >= pcBufInitial )
    f742:	429d      	cmp	r5, r3
    f744:	f43f ac03 	beq.w	ef4e <am_util_stdio_vsprintf+0x2fa>
    f748:	461c      	mov	r4, r3
                if ( *pcBuftmp == '.' )
    f74a:	f813 0901 	ldrb.w	r0, [r3], #-1
    f74e:	282e      	cmp	r0, #46	; 0x2e
    f750:	d0f7      	beq.n	f742 <am_util_stdio_vsprintf+0xaee>
                else if ( *pcBuftmp == '9' )
    f752:	2839      	cmp	r0, #57	; 0x39
    f754:	d0f2      	beq.n	f73c <am_util_stdio_vsprintf+0xae8>
                    *pcBuftmp += 1;
    f756:	3001      	adds	r0, #1
    f758:	7020      	strb	r0, [r4, #0]
    f75a:	f7ff bbf8 	b.w	ef4e <am_util_stdio_vsprintf+0x2fa>
                while (*pcStr != 0x0)
    f75e:	7838      	ldrb	r0, [r7, #0]
    f760:	2800      	cmp	r0, #0
    f762:	d03c      	beq.n	f7de <am_util_stdio_vsprintf+0xb8a>
    f764:	465c      	mov	r4, fp
        return ui32RetVal;
    f766:	463e      	mov	r6, r7
    f768:	2301      	movs	r3, #1
    f76a:	e44a      	b.n	f002 <am_util_stdio_vsprintf+0x3ae>
        *(uint32_t*)pcBuf = 0x00 << 24 | ('0' << 16) | ('.' << 8) | ('0' << 0);
    f76c:	4b39      	ldr	r3, [pc, #228]	; (f854 <am_util_stdio_vsprintf+0xc00>)
    f76e:	f8ca 3000 	str.w	r3, [sl]
    f772:	2303      	movs	r3, #3
    f774:	f7ff bbf1 	b.w	ef5a <am_util_stdio_vsprintf+0x306>
                    if ( bNeg  &&  (ui8PadChar == ' ') )
    f778:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    f77a:	b11b      	cbz	r3, f784 <am_util_stdio_vsprintf+0xb30>
    f77c:	f1b8 0f20 	cmp.w	r8, #32
    f780:	f43f ae3f 	beq.w	f402 <am_util_stdio_vsprintf+0x7ae>
                iVal = uint64_to_str(ui64Val, pcBuf);
    f784:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
    f788:	4652      	mov	r2, sl
    f78a:	f7ff f98d 	bl	eaa8 <uint64_to_str>
                ui32CharCnt += iVal;
    f78e:	4483      	add	fp, r0
    f790:	f7ff ba68 	b.w	ec64 <am_util_stdio_vsprintf+0x10>
                        if ( iVal == AM_FTOA_ERR_VAL_TOO_SMALL )
    f794:	1c4b      	adds	r3, r1, #1
    f796:	d034      	beq.n	f802 <am_util_stdio_vsprintf+0xbae>
                        else if ( iVal == AM_FTOA_ERR_VAL_TOO_LARGE )
    f798:	3102      	adds	r1, #2
    f79a:	d141      	bne.n	f820 <am_util_stdio_vsprintf+0xbcc>
                            u32PrntErrVal = (0x00 << 24) | ('#' << 16) |
    f79c:	4b2e      	ldr	r3, [pc, #184]	; (f858 <am_util_stdio_vsprintf+0xc04>)
                        *(uint32_t*)pcBuf = u32PrntErrVal;
    f79e:	f8ca 3000 	str.w	r3, [sl]
    f7a2:	2303      	movs	r3, #3
    f7a4:	f7ff bbd9 	b.w	ef5a <am_util_stdio_vsprintf+0x306>
        if (i32IntPart > 0)
    f7a8:	f73f af37 	bgt.w	f61a <am_util_stdio_vsprintf+0x9c6>
            uint64_to_str(-i32IntPart, pcBuf);
    f7ac:	4240      	negs	r0, r0
            *pcBuf++ = '-';
    f7ae:	232d      	movs	r3, #45	; 0x2d
    f7b0:	7033      	strb	r3, [r6, #0]
            uint64_to_str(-i32IntPart, pcBuf);
    f7b2:	463a      	mov	r2, r7
    f7b4:	17c1      	asrs	r1, r0, #31
    f7b6:	463e      	mov	r6, r7
    f7b8:	f7ff f976 	bl	eaa8 <uint64_to_str>
    f7bc:	3701      	adds	r7, #1
    f7be:	e730      	b.n	f622 <am_util_stdio_vsprintf+0x9ce>
    i32FracPart = 0;
    f7c0:	2400      	movs	r4, #0
        *pcBuf++ = '-';
    f7c2:	4653      	mov	r3, sl
    f7c4:	222d      	movs	r2, #45	; 0x2d
    f7c6:	f803 2b02 	strb.w	r2, [r3], #2
    f7ca:	463e      	mov	r6, r7
    f7cc:	461f      	mov	r7, r3
    f7ce:	f7ff bbac 	b.w	ef2a <am_util_stdio_vsprintf+0x2d6>
                iVal = uint64_to_str(ui64Val, pcBuf);
    f7d2:	4652      	mov	r2, sl
    f7d4:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
    f7d8:	f7ff f966 	bl	eaa8 <uint64_to_str>
    f7dc:	e4f5      	b.n	f1ca <am_util_stdio_vsprintf+0x576>
        return ui32RetVal;
    f7de:	4606      	mov	r6, r0
    f7e0:	e428      	b.n	f034 <am_util_stdio_vsprintf+0x3e0>
    f7e2:	4620      	mov	r0, r4
    f7e4:	44a3      	add	fp, r4
    f7e6:	e522      	b.n	f22e <am_util_stdio_vsprintf+0x5da>
        i32FracPart = (i32Significand & 0x00FFFFFF) >> -(iExp2 + 1);
    f7e8:	43d2      	mvns	r2, r2
    if (unFloatValue.I32 < 0)
    f7ea:	2b00      	cmp	r3, #0
        i32FracPart = (i32Significand & 0x00FFFFFF) >> -(iExp2 + 1);
    f7ec:	fa40 f402 	asr.w	r4, r0, r2
    f7f0:	f10a 0202 	add.w	r2, sl, #2
    if (unFloatValue.I32 < 0)
    f7f4:	db1d      	blt.n	f832 <am_util_stdio_vsprintf+0xbde>
    f7f6:	4656      	mov	r6, sl
    f7f8:	f7ff bb9b 	b.w	ef32 <am_util_stdio_vsprintf+0x2de>
    f7fc:	460a      	mov	r2, r1
    f7fe:	448b      	add	fp, r1
    f800:	e4ba      	b.n	f178 <am_util_stdio_vsprintf+0x524>
                            u32PrntErrVal = (0x00 << 24) | ('0' << 16) |
    f802:	4b14      	ldr	r3, [pc, #80]	; (f854 <am_util_stdio_vsprintf+0xc00>)
    f804:	e7cb      	b.n	f79e <am_util_stdio_vsprintf+0xb4a>
                    iWidth -= ndigits_in_i64(ui64Val);
    f806:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    f808:	eba3 0e0e 	sub.w	lr, r3, lr
                    bNeg = false;
    f80c:	2300      	movs	r3, #0
    f80e:	930f      	str	r3, [sp, #60]	; 0x3c
    f810:	e4ad      	b.n	f16e <am_util_stdio_vsprintf+0x51a>
    f812:	460a      	mov	r2, r1
    f814:	448b      	add	fp, r1
    f816:	e648      	b.n	f4aa <am_util_stdio_vsprintf+0x856>
    f818:	460b      	mov	r3, r1
    f81a:	eb0b 0401 	add.w	r4, fp, r1
    f81e:	e41a      	b.n	f056 <am_util_stdio_vsprintf+0x402>
                            u32PrntErrVal = (0x00 << 24) | ('?' << 16) |
    f820:	4b0e      	ldr	r3, [pc, #56]	; (f85c <am_util_stdio_vsprintf+0xc08>)
    f822:	e7bc      	b.n	f79e <am_util_stdio_vsprintf+0xb4a>
    f824:	4601      	mov	r1, r0
    f826:	4483      	add	fp, r0
    f828:	e5ca      	b.n	f3c0 <am_util_stdio_vsprintf+0x76c>
        while (*pcBuf)    // Get to end of new string
    f82a:	463a      	mov	r2, r7
    f82c:	4637      	mov	r7, r6
    f82e:	f7ff bb83 	b.w	ef38 <am_util_stdio_vsprintf+0x2e4>
        *pcBuf++ = '-';
    f832:	4653      	mov	r3, sl
    f834:	212d      	movs	r1, #45	; 0x2d
    f836:	f803 1b03 	strb.w	r1, [r3], #3
    f83a:	463e      	mov	r6, r7
    f83c:	4617      	mov	r7, r2
    f83e:	461a      	mov	r2, r3
    f840:	f7ff bb77 	b.w	ef32 <am_util_stdio_vsprintf+0x2de>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    f844:	2300      	movs	r3, #0
        uCnt++;
    f846:	2201      	movs	r2, #1
    f848:	f7ff bbbe 	b.w	efc8 <am_util_stdio_vsprintf+0x374>
                pcStr = va_arg(pArgs, char *);
    f84c:	9201      	str	r2, [sp, #4]
                        ui32CharCnt += iWidth;
    f84e:	46a3      	mov	fp, r4
    f850:	f7ff ba08 	b.w	ec64 <am_util_stdio_vsprintf+0x10>
    f854:	00302e30 	.word	0x00302e30
    f858:	00232e23 	.word	0x00232e23
    f85c:	003f2e3f 	.word	0x003f2e3f

0000f860 <am_util_stdio_printf>:
//! @return uint32_t representing the number of characters printed.
//
// *****************************************************************************
uint32_t
am_util_stdio_printf(const char *pcFmt, ...)
{
    f860:	b40f      	push	{r0, r1, r2, r3}
    f862:	b530      	push	{r4, r5, lr}
    uint32_t ui32NumChars;

    if (!g_pfnCharPrint)
    f864:	4d0a      	ldr	r5, [pc, #40]	; (f890 <am_util_stdio_printf+0x30>)
    f866:	682c      	ldr	r4, [r5, #0]
{
    f868:	b083      	sub	sp, #12
    if (!g_pfnCharPrint)
    f86a:	b154      	cbz	r4, f882 <am_util_stdio_printf+0x22>

    //
    // Convert to the desired string.
    //
    va_list pArgs;
    va_start(pArgs, pcFmt);
    f86c:	ab07      	add	r3, sp, #28
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
    f86e:	461a      	mov	r2, r3
    f870:	9906      	ldr	r1, [sp, #24]
    f872:	4808      	ldr	r0, [pc, #32]	; (f894 <am_util_stdio_printf+0x34>)
    va_start(pArgs, pcFmt);
    f874:	9301      	str	r3, [sp, #4]
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
    f876:	f7ff f9ed 	bl	ec54 <am_util_stdio_vsprintf>
    va_end(pArgs);

    //
    // This is where we print the buffer to the configured interface.
    //
    g_pfnCharPrint(g_prfbuf);
    f87a:	682b      	ldr	r3, [r5, #0]
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
    f87c:	4604      	mov	r4, r0
    g_pfnCharPrint(g_prfbuf);
    f87e:	4805      	ldr	r0, [pc, #20]	; (f894 <am_util_stdio_printf+0x34>)
    f880:	4798      	blx	r3

    //
    // return the number of characters printed.
    //
    return ui32NumChars;
}
    f882:	4620      	mov	r0, r4
    f884:	b003      	add	sp, #12
    f886:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    f88a:	b004      	add	sp, #16
    f88c:	4770      	bx	lr
    f88e:	bf00      	nop
    f890:	10014400 	.word	0x10014400
    f894:	10012d10 	.word	0x10012d10

0000f898 <am_app_utils_ring_buffer_init_all>:
void
am_app_utils_ring_buffer_init_all(am_app_utils_ring_buffer_t* ring_buffs, const am_app_utils_ringbuff_setup_t* setup_array, 
                                    uint32_t ui32BufferCount)
{
    uint32_t ringbuff = 0;
    for(ringbuff =0; ringbuff<ui32BufferCount; ringbuff++)
    f898:	b302      	cbz	r2, f8dc <am_app_utils_ring_buffer_init_all+0x44>
{
    f89a:	b4f0      	push	{r4, r5, r6, r7}
    f89c:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    f8a0:	b084      	sub	sp, #16
    f8a2:	4606      	mov	r6, r0
    f8a4:	460b      	mov	r3, r1
    f8a6:	eb01 0782 	add.w	r7, r1, r2, lsl #2
    f8aa:	ad01      	add	r5, sp, #4
    ring_buffs[setup.indx].ui32BufferHead_read = 0;
    f8ac:	2400      	movs	r4, #0
    f8ae:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
    f8b2:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    f8b6:	9a01      	ldr	r2, [sp, #4]
    f8b8:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    f8bc:	eb06 0182 	add.w	r1, r6, r2, lsl #2
    f8c0:	330c      	adds	r3, #12
    f8c2:	608c      	str	r4, [r1, #8]
    ring_buffs[setup.indx].ui32BufferTail_write = 0;
    f8c4:	604c      	str	r4, [r1, #4]
    ring_buffs[setup.indx].ui32OverWriting = 0;
    f8c6:	60cc      	str	r4, [r1, #12]
    ring_buffs[setup.indx].ui32Capacity = setup.ui32ByteSize;
    f8c8:	9803      	ldr	r0, [sp, #12]
    f8ca:	6108      	str	r0, [r1, #16]
    for(ringbuff =0; ringbuff<ui32BufferCount; ringbuff++)
    f8cc:	42bb      	cmp	r3, r7
    ring_buffs[setup.indx].pui8Data = setup.pData;
    f8ce:	9902      	ldr	r1, [sp, #8]
    f8d0:	f846 1022 	str.w	r1, [r6, r2, lsl #2]
    for(ringbuff =0; ringbuff<ui32BufferCount; ringbuff++)
    f8d4:	d1eb      	bne.n	f8ae <am_app_utils_ring_buffer_init_all+0x16>
    {
        am_app_utils_ring_buffer_init(ring_buffs,setup_array[ringbuff]);    
    }

}
    f8d6:	b004      	add	sp, #16
    f8d8:	bcf0      	pop	{r4, r5, r6, r7}
    f8da:	4770      	bx	lr
    f8dc:	4770      	bx	lr
    f8de:	bf00      	nop

0000f8e0 <am_app_utils_ring_buffer_push>:


uint32_t am_app_utils_ring_buffer_push(am_app_utils_ring_buffer_t *psBuffer, void *pvSource, uint32_t ui32Bytes)
{
    f8e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f8e4:	4688      	mov	r8, r1
    
    ui32CopyLen = ui32Bytes;
    pui8Source = (uint8_t*)pvSource;

    // won't push any data if buffer is full
    if(am_app_utils_ring_buffer_full(psBuffer))
    f8e6:	6841      	ldr	r1, [r0, #4]
    f8e8:	6883      	ldr	r3, [r0, #8]
    f8ea:	4299      	cmp	r1, r3
{
    f8ec:	4604      	mov	r4, r0
    f8ee:	4615      	mov	r5, r2
    if(am_app_utils_ring_buffer_full(psBuffer))
    f8f0:	d049      	beq.n	f986 <am_app_utils_ring_buffer_push+0xa6>
        ui32ReturnPushLen =0;
        return ui32ReturnPushLen;
    }

    // push data until the buffer is full
    if(am_app_utils_ring_buffer_empty(psBuffer))
    f8f2:	6862      	ldr	r2, [r4, #4]
    f8f4:	68a3      	ldr	r3, [r4, #8]
    f8f6:	429a      	cmp	r2, r3
    f8f8:	d03b      	beq.n	f972 <am_app_utils_ring_buffer_push+0x92>
            ui32CopyLen = psBuffer->ui32Capacity;
        }
    }
    else
    {
        if(((psBuffer->ui32BufferHead_read + psBuffer->ui32Capacity - psBuffer->ui32BufferTail_write) 
    f8fa:	68a3      	ldr	r3, [r4, #8]
    f8fc:	6920      	ldr	r0, [r4, #16]
    f8fe:	6862      	ldr	r2, [r4, #4]
            % psBuffer->ui32Capacity) <= ui32CopyLen)
    f900:	6921      	ldr	r1, [r4, #16]
        if(((psBuffer->ui32BufferHead_read + psBuffer->ui32Capacity - psBuffer->ui32BufferTail_write) 
    f902:	4403      	add	r3, r0
    f904:	1a9b      	subs	r3, r3, r2
            % psBuffer->ui32Capacity) <= ui32CopyLen)
    f906:	fbb3 f2f1 	udiv	r2, r3, r1
    f90a:	fb01 3312 	mls	r3, r1, r2, r3
        if(((psBuffer->ui32BufferHead_read + psBuffer->ui32Capacity - psBuffer->ui32BufferTail_write) 
    f90e:	42ab      	cmp	r3, r5
    f910:	d80b      	bhi.n	f92a <am_app_utils_ring_buffer_push+0x4a>
        {    
            psBuffer->ui32OverWriting = 1;
    f912:	2301      	movs	r3, #1
    f914:	60e3      	str	r3, [r4, #12]
            ui32CopyLen = ((psBuffer->ui32BufferHead_read + psBuffer->ui32Capacity - psBuffer->ui32BufferTail_write) 
    f916:	68a3      	ldr	r3, [r4, #8]
    f918:	6921      	ldr	r1, [r4, #16]
    f91a:	6865      	ldr	r5, [r4, #4]
            % psBuffer->ui32Capacity);
    f91c:	6922      	ldr	r2, [r4, #16]
            ui32CopyLen = ((psBuffer->ui32BufferHead_read + psBuffer->ui32Capacity - psBuffer->ui32BufferTail_write) 
    f91e:	440b      	add	r3, r1
    f920:	1b5b      	subs	r3, r3, r5
    f922:	fbb3 f5f2 	udiv	r5, r3, r2
    f926:	fb02 3515 	mls	r5, r2, r5, r3

    }        
        
    ui32ReturnPushLen = ui32CopyLen;

    while((psBuffer->ui32BufferTail_write + ui32CopyLen) >= psBuffer->ui32Capacity)
    f92a:	6863      	ldr	r3, [r4, #4]
    f92c:	6922      	ldr	r2, [r4, #16]
    f92e:	442b      	add	r3, r5
    f930:	4293      	cmp	r3, r2
    f932:	462e      	mov	r6, r5
    f934:	d32d      	bcc.n	f992 <am_app_utils_ring_buffer_push+0xb2>
    {
        ui32TempLen = psBuffer->ui32Capacity - psBuffer->ui32BufferTail_write;
    f936:	6927      	ldr	r7, [r4, #16]
    f938:	6862      	ldr	r2, [r4, #4]
        memcpy((void*)&psBuffer->pui8Data[psBuffer->ui32BufferTail_write], pui8Source, ui32TempLen);
    f93a:	6820      	ldr	r0, [r4, #0]
    f93c:	6863      	ldr	r3, [r4, #4]
        ui32TempLen = psBuffer->ui32Capacity - psBuffer->ui32BufferTail_write;
    f93e:	1abf      	subs	r7, r7, r2
        memcpy((void*)&psBuffer->pui8Data[psBuffer->ui32BufferTail_write], pui8Source, ui32TempLen);
    f940:	463a      	mov	r2, r7
    f942:	4418      	add	r0, r3
    f944:	4641      	mov	r1, r8
    f946:	f7fc fbdb 	bl	c100 <memcpy>
        psBuffer->ui32BufferTail_write = ((psBuffer->ui32BufferTail_write + ui32TempLen) % psBuffer->ui32Capacity);
    f94a:	6863      	ldr	r3, [r4, #4]
    f94c:	6921      	ldr	r1, [r4, #16]
    f94e:	443b      	add	r3, r7
    f950:	fbb3 f2f1 	udiv	r2, r3, r1
    f954:	fb01 3312 	mls	r3, r1, r2, r3
    f958:	6063      	str	r3, [r4, #4]
    while((psBuffer->ui32BufferTail_write + ui32CopyLen) >= psBuffer->ui32Capacity)
    f95a:	6863      	ldr	r3, [r4, #4]
    f95c:	6922      	ldr	r2, [r4, #16]
        ui32CopyLen -= ui32TempLen;
    f95e:	1bf6      	subs	r6, r6, r7
    while((psBuffer->ui32BufferTail_write + ui32CopyLen) >= psBuffer->ui32Capacity)
    f960:	4433      	add	r3, r6
    f962:	4293      	cmp	r3, r2
    f964:	d2e7      	bcs.n	f936 <am_app_utils_ring_buffer_push+0x56>
    }
    configASSERT((psBuffer->ui32BufferTail_write + ui32CopyLen) < psBuffer->ui32Capacity);
    f966:	6863      	ldr	r3, [r4, #4]
    f968:	6922      	ldr	r2, [r4, #16]
    f96a:	4433      	add	r3, r6
    f96c:	4293      	cmp	r3, r2
    f96e:	d312      	bcc.n	f996 <am_app_utils_ring_buffer_push+0xb6>
    f970:	e7fe      	b.n	f970 <am_app_utils_ring_buffer_push+0x90>
    if(am_app_utils_ring_buffer_empty(psBuffer))
    f972:	68e3      	ldr	r3, [r4, #12]
    f974:	2b00      	cmp	r3, #0
    f976:	d1c0      	bne.n	f8fa <am_app_utils_ring_buffer_push+0x1a>
        if(ui32CopyLen >= psBuffer->ui32Capacity)
    f978:	6923      	ldr	r3, [r4, #16]
    f97a:	42ab      	cmp	r3, r5
    f97c:	d8d5      	bhi.n	f92a <am_app_utils_ring_buffer_push+0x4a>
            psBuffer->ui32OverWriting = 1;
    f97e:	2301      	movs	r3, #1
    f980:	60e3      	str	r3, [r4, #12]
            ui32CopyLen = psBuffer->ui32Capacity;
    f982:	6925      	ldr	r5, [r4, #16]
    f984:	e7d1      	b.n	f92a <am_app_utils_ring_buffer_push+0x4a>
    if(am_app_utils_ring_buffer_full(psBuffer))
    f986:	68c3      	ldr	r3, [r0, #12]
    f988:	2b01      	cmp	r3, #1
    f98a:	d1b2      	bne.n	f8f2 <am_app_utils_ring_buffer_push+0x12>
        return ui32ReturnPushLen;
    f98c:	2000      	movs	r0, #0
    memcpy((void*)&psBuffer->pui8Data[psBuffer->ui32BufferTail_write], &pui8Source[ui32TempLen], ui32CopyLen);
    psBuffer->ui32BufferTail_write = ((psBuffer->ui32BufferTail_write + ui32CopyLen) % psBuffer->ui32Capacity);
    
    return ui32ReturnPushLen;

}
    f98e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    uint32_t ui32TempLen = 0;
    f992:	2700      	movs	r7, #0
    f994:	e7e7      	b.n	f966 <am_app_utils_ring_buffer_push+0x86>
    memcpy((void*)&psBuffer->pui8Data[psBuffer->ui32BufferTail_write], &pui8Source[ui32TempLen], ui32CopyLen);
    f996:	6863      	ldr	r3, [r4, #4]
    f998:	6820      	ldr	r0, [r4, #0]
    f99a:	4632      	mov	r2, r6
    f99c:	4418      	add	r0, r3
    f99e:	eb08 0107 	add.w	r1, r8, r7
    f9a2:	f7fc fbad 	bl	c100 <memcpy>
    psBuffer->ui32BufferTail_write = ((psBuffer->ui32BufferTail_write + ui32CopyLen) % psBuffer->ui32Capacity);
    f9a6:	6863      	ldr	r3, [r4, #4]
    f9a8:	6922      	ldr	r2, [r4, #16]
    f9aa:	441e      	add	r6, r3
    f9ac:	fbb6 f3f2 	udiv	r3, r6, r2
    f9b0:	fb02 6613 	mls	r6, r2, r3, r6
    return ui32ReturnPushLen;
    f9b4:	4628      	mov	r0, r5
    psBuffer->ui32BufferTail_write = ((psBuffer->ui32BufferTail_write + ui32CopyLen) % psBuffer->ui32Capacity);
    f9b6:	6066      	str	r6, [r4, #4]
    return ui32ReturnPushLen;
    f9b8:	e7e9      	b.n	f98e <am_app_utils_ring_buffer_push+0xae>
    f9ba:	bf00      	nop

0000f9bc <am_app_utils_task_init>:
//*****************************************************************************
void am_app_utils_task_init(am_app_utils_task_t* pTaskList, uint32_t taskCount)
{
	uint32_t i = 0;

    for(i=0 ; i<taskCount; i++)
    f9bc:	b139      	cbz	r1, f9ce <am_app_utils_task_init+0x12>
    f9be:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
	{
		pTaskList[i].task = NULL;
    f9c2:	2300      	movs	r3, #0
		pTaskList[i].queue = NULL;
    f9c4:	e9c0 3300 	strd	r3, r3, [r0]
    f9c8:	3008      	adds	r0, #8
    for(i=0 ; i<taskCount; i++)
    f9ca:	4288      	cmp	r0, r1
    f9cc:	d1fa      	bne.n	f9c4 <am_app_utils_task_init+0x8>
	}
}
    f9ce:	4770      	bx	lr

0000f9d0 <am_app_utils_task_create_all_tasks>:
void
am_app_utils_task_create_all_tasks(am_app_utils_task_setup_t *setup_array, am_app_utils_task_t* pTaskList, uint32_t setupLen)
{
    uint8_t task = 0;

	for(task = 0; task<setupLen; task++)
    f9d0:	b38a      	cbz	r2, fa36 <am_app_utils_task_create_all_tasks+0x66>
{
    f9d2:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	for(task = 0; task<setupLen; task++)
    f9d6:	2400      	movs	r4, #0
{
    f9d8:	b082      	sub	sp, #8
    f9da:	4690      	mov	r8, r2
    f9dc:	460f      	mov	r7, r1
    f9de:	4606      	mov	r6, r0
	for(task = 0; task<setupLen; task++)
    f9e0:	4623      	mov	r3, r4
	{
		// Spawn all tasks
		am_app_utils_task_create(setup_array[task], pTaskList);
    f9e2:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
    f9e6:	eb06 0583 	add.w	r5, r6, r3, lsl #2
    xTaskCreate(setup.pxTaskCode, setup.pcName, setup.usStackDepth, setup.pvParameters, setup.uxPriority, &(pTaskList[setup.indx].task));
    f9ea:	f856 a023 	ldr.w	sl, [r6, r3, lsl #2]
    f9ee:	f8d5 c010 	ldr.w	ip, [r5, #16]
    f9f2:	696b      	ldr	r3, [r5, #20]
    f9f4:	89aa      	ldrh	r2, [r5, #12]
    f9f6:	eb07 09ca 	add.w	r9, r7, sl, lsl #3
    f9fa:	e9d5 0101 	ldrd	r0, r1, [r5, #4]
    f9fe:	9300      	str	r3, [sp, #0]
    fa00:	f8cd 9004 	str.w	r9, [sp, #4]
    fa04:	4663      	mov	r3, ip
    fa06:	69ad      	ldr	r5, [r5, #24]
    fa08:	f7fd f968 	bl	ccdc <xTaskCreate>
	configASSERT(pTaskList[setup.indx].task != NULL);
    fa0c:	f857 303a 	ldr.w	r3, [r7, sl, lsl #3]
	pTaskList[setup.indx].queue = xQueueCreate(setup.uxQueueLength, sizeof(am_app_utils_task_queue_element_t));  
    fa10:	2200      	movs	r2, #0
    fa12:	2110      	movs	r1, #16
    fa14:	4628      	mov	r0, r5
	configASSERT(pTaskList[setup.indx].task != NULL);
    fa16:	b163      	cbz	r3, fa32 <am_app_utils_task_create_all_tasks+0x62>
	pTaskList[setup.indx].queue = xQueueCreate(setup.uxQueueLength, sizeof(am_app_utils_task_queue_element_t));  
    fa18:	f7fc fccc 	bl	c3b4 <xQueueGenericCreate>
	for(task = 0; task<setupLen; task++)
    fa1c:	3401      	adds	r4, #1
    fa1e:	b2e4      	uxtb	r4, r4
    fa20:	4623      	mov	r3, r4
	pTaskList[setup.indx].queue = xQueueCreate(setup.uxQueueLength, sizeof(am_app_utils_task_queue_element_t));  
    fa22:	f8c9 0004 	str.w	r0, [r9, #4]
	configASSERT(pTaskList[setup.indx].queue != NULL);
    fa26:	b128      	cbz	r0, fa34 <am_app_utils_task_create_all_tasks+0x64>
	for(task = 0; task<setupLen; task++)
    fa28:	4544      	cmp	r4, r8
    fa2a:	d3da      	bcc.n	f9e2 <am_app_utils_task_create_all_tasks+0x12>
	}

}
    fa2c:	b002      	add	sp, #8
    fa2e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    fa32:	e7fe      	b.n	fa32 <am_app_utils_task_create_all_tasks+0x62>
    fa34:	e7fe      	b.n	fa34 <am_app_utils_task_create_all_tasks+0x64>
    fa36:	4770      	bx	lr

0000fa38 <am_app_utils_timer_create_all_timers>:
void
am_app_utils_timer_create_all_timers(am_app_utils_timer_setup_t *setup_array, TimerHandle_t* pTimerList, uint32_t setupLen)
{
    uint8_t timer = 0;

	for(timer = 0; timer<setupLen; timer++)
    fa38:	b1fa      	cbz	r2, fa7a <am_app_utils_timer_create_all_timers+0x42>
{
    fa3a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	for(timer = 0; timer<setupLen; timer++)
    fa3e:	2400      	movs	r4, #0
{
    fa40:	b083      	sub	sp, #12
    fa42:	4690      	mov	r8, r2
    fa44:	4689      	mov	r9, r1
    fa46:	4607      	mov	r7, r0
	for(timer = 0; timer<setupLen; timer++)
    fa48:	4623      	mov	r3, r4
	{
		// Spawn all timers
		am_app_utils_timer_create(setup_array[timer], pTimerList);
    fa4a:	eb03 0583 	add.w	r5, r3, r3, lsl #2
    fa4e:	eb07 0685 	add.w	r6, r7, r5, lsl #2
    pTimerList[setup.indx] = xTimerCreate(setup.pcTimerName, setup.xTimerPeriodInTicks, 
    fa52:	e9d6 1202 	ldrd	r1, r2, [r6, #8]
    fa56:	6870      	ldr	r0, [r6, #4]
    fa58:	6936      	ldr	r6, [r6, #16]
    fa5a:	9600      	str	r6, [sp, #0]
    fa5c:	2300      	movs	r3, #0
    fa5e:	f857 5025 	ldr.w	r5, [r7, r5, lsl #2]
	for(timer = 0; timer<setupLen; timer++)
    fa62:	3401      	adds	r4, #1
    pTimerList[setup.indx] = xTimerCreate(setup.pcTimerName, setup.xTimerPeriodInTicks, 
    fa64:	f7fe f8a0 	bl	dba8 <xTimerCreate>
	for(timer = 0; timer<setupLen; timer++)
    fa68:	b2e4      	uxtb	r4, r4
    fa6a:	4544      	cmp	r4, r8
    pTimerList[setup.indx] = xTimerCreate(setup.pcTimerName, setup.xTimerPeriodInTicks, 
    fa6c:	f849 0025 	str.w	r0, [r9, r5, lsl #2]
	for(timer = 0; timer<setupLen; timer++)
    fa70:	4623      	mov	r3, r4
    fa72:	d3ea      	bcc.n	fa4a <am_app_utils_timer_create_all_timers+0x12>
	}

}
    fa74:	b003      	add	sp, #12
    fa76:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    fa7a:	4770      	bx	lr

0000fa7c <am_app_utils_task_read>:
//*****************************************************************************
bool
am_app_utils_task_read(am_app_utils_task_t* pTaskList, const uint32_t indx, am_app_utils_task_queue_element_t *Element)
{
		BaseType_t retval = pdFAIL;
		if(pTaskList[indx].queue != NULL)
    fa7c:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
    fa80:	6848      	ldr	r0, [r1, #4]
    fa82:	b150      	cbz	r0, fa9a <am_app_utils_task_read+0x1e>
{
    fa84:	b508      	push	{r3, lr}
    fa86:	4611      	mov	r1, r2
		{
			retval = xQueueReceive(pTaskList[indx].queue, Element, portMAX_DELAY );
    fa88:	2300      	movs	r3, #0
    fa8a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    fa8e:	f7fc ff15 	bl	c8bc <xQueueGenericReceive>
    fa92:	3000      	adds	r0, #0
    fa94:	bf18      	it	ne
    fa96:	2001      	movne	r0, #1
		}
    
		return retval; 
}
    fa98:	bd08      	pop	{r3, pc}
    fa9a:	4770      	bx	lr

0000fa9c <am_devices_led_array_init>:
void
am_devices_led_array_init(am_devices_led_t *psLEDs, uint32_t ui32NumLEDs)
{
    uint32_t i;

    if ( (psLEDs == NULL)                       ||
    fa9c:	b360      	cbz	r0, faf8 <am_devices_led_array_init+0x5c>
    }

    //
    // Loop through the list of LEDs, configuring each one individually.
    //
    for ( i = 0; i < ui32NumLEDs; i++ )
    fa9e:	1e4b      	subs	r3, r1, #1
    faa0:	2b1e      	cmp	r3, #30
    faa2:	d829      	bhi.n	faf8 <am_devices_led_array_init+0x5c>
{
    faa4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_TRISTATE);
    faa8:	4f14      	ldr	r7, [pc, #80]	; (fafc <am_devices_led_array_init+0x60>)
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_OUTPUT);
    faaa:	f8df 8054 	ldr.w	r8, [pc, #84]	; fb00 <am_devices_led_array_init+0x64>
    faae:	4604      	mov	r4, r0
    fab0:	eb00 06c1 	add.w	r6, r0, r1, lsl #3
    fab4:	1d05      	adds	r5, r0, #4
    if ( (psLED == NULL)    ||
    fab6:	b1c4      	cbz	r4, faea <am_devices_led_array_init+0x4e>
         (psLED->ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    fab8:	f855 3c04 	ldr.w	r3, [r5, #-4]
    if ( (psLED == NULL)    ||
    fabc:	2b31      	cmp	r3, #49	; 0x31
    fabe:	d814      	bhi.n	faea <am_devices_led_array_init+0x4e>
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLED->ui32Polarity )
    fac0:	6862      	ldr	r2, [r4, #4]
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_TRISTATE);
    fac2:	4618      	mov	r0, r3
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLED->ui32Polarity )
    fac4:	0793      	lsls	r3, r2, #30
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_OUTPUT);
    fac6:	bf4c      	ite	mi
    fac8:	f8d8 1000 	ldrmi.w	r1, [r8]
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_TRISTATE);
    facc:	6839      	ldrpl	r1, [r7, #0]
    face:	f7fe fd77 	bl	e5c0 <am_hal_gpio_pinconfig>
        am_hal_gpio_state_write(psLED->ui32GPIONumber, AM_HAL_GPIO_OUTPUT_TRISTATE_DISABLE);
    fad2:	2103      	movs	r1, #3
    fad4:	f855 0c04 	ldr.w	r0, [r5, #-4]
    fad8:	f7fe feec 	bl	e8b4 <am_hal_gpio_state_write>
                                AM_HAL_GPIO_OUTPUT_SET : AM_HAL_GPIO_OUTPUT_CLEAR);
    fadc:	6861      	ldr	r1, [r4, #4]
        am_hal_gpio_state_write(psLED->ui32GPIONumber,
    fade:	f855 0c04 	ldr.w	r0, [r5, #-4]
    fae2:	f001 0101 	and.w	r1, r1, #1
    fae6:	f7fe fee5 	bl	e8b4 <am_hal_gpio_state_write>
    faea:	3408      	adds	r4, #8
    for ( i = 0; i < ui32NumLEDs; i++ )
    faec:	42b4      	cmp	r4, r6
    faee:	f105 0508 	add.w	r5, r5, #8
    faf2:	d1e0      	bne.n	fab6 <am_devices_led_array_init+0x1a>
    {
        am_devices_led_init(psLEDs + i);
    }
}
    faf4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    faf8:	4770      	bx	lr
    fafa:	bf00      	nop
    fafc:	0001356c 	.word	0x0001356c
    fb00:	00013568 	.word	0x00013568

0000fb04 <am_devices_led_off>:
//
//*****************************************************************************
void
am_devices_led_off(am_devices_led_t *psLEDs, uint32_t ui32LEDNum)
{
    if ( (psLEDs == NULL)                       ||
    fb04:	b170      	cbz	r0, fb24 <am_devices_led_off+0x20>
    fb06:	291e      	cmp	r1, #30
    fb08:	d80c      	bhi.n	fb24 <am_devices_led_off+0x20>
         (ui32LEDNum >= MAX_LEDS)               ||
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    fb0a:	f850 3031 	ldr.w	r3, [r0, r1, lsl #3]
         (ui32LEDNum >= MAX_LEDS)               ||
    fb0e:	2b31      	cmp	r3, #49	; 0x31
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    fb10:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
         (ui32LEDNum >= MAX_LEDS)               ||
    fb14:	d806      	bhi.n	fb24 <am_devices_led_off+0x20>

#if AM_APOLLO3_GPIO
    //
    // Handle Direct Drive Versus 3-State (with pull-up or no buffer).
    //
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    fb16:	6849      	ldr	r1, [r1, #4]
    fb18:	078a      	lsls	r2, r1, #30
    fb1a:	d404      	bmi.n	fb26 <am_devices_led_off+0x22>
    else
    {
        //
        // Turn off the output driver for the LED.
        //
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    fb1c:	4618      	mov	r0, r3
    fb1e:	2103      	movs	r1, #3
    fb20:	f7fe bec8 	b.w	e8b4 <am_hal_gpio_state_write>
        // Turn off the output driver for the LED.
        //
        am_hal_gpio_out_enable_bit_clear(psLEDs[ui32LEDNum].ui32GPIONumber);
    }
#endif // AM_APOLLO3_GPIO
}
    fb24:	4770      	bx	lr
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    fb26:	43c9      	mvns	r1, r1
    fb28:	f001 0101 	and.w	r1, r1, #1
    fb2c:	4618      	mov	r0, r3
    fb2e:	f7fe bec1 	b.w	e8b4 <am_hal_gpio_state_write>
    fb32:	bf00      	nop

0000fb34 <am_devices_led_toggle>:
//
//*****************************************************************************
void
am_devices_led_toggle(am_devices_led_t *psLEDs, uint32_t ui32LEDNum)
{
    if ( (psLEDs == NULL)                       ||
    fb34:	b1e0      	cbz	r0, fb70 <am_devices_led_toggle+0x3c>
    fb36:	291e      	cmp	r1, #30
    fb38:	d81a      	bhi.n	fb70 <am_devices_led_toggle+0x3c>
         (ui32LEDNum >= MAX_LEDS)               ||
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    fb3a:	f850 3031 	ldr.w	r3, [r0, r1, lsl #3]
         (ui32LEDNum >= MAX_LEDS)               ||
    fb3e:	2b31      	cmp	r3, #49	; 0x31
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    fb40:	eb00 02c1 	add.w	r2, r0, r1, lsl #3
         (ui32LEDNum >= MAX_LEDS)               ||
    fb44:	d814      	bhi.n	fb70 <am_devices_led_toggle+0x3c>
{
    fb46:	b530      	push	{r4, r5, lr}

#if AM_APOLLO3_GPIO
    //
    // Handle Direct Drive Versus 3-State (with pull-up or no buffer).
    //
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    fb48:	6852      	ldr	r2, [r2, #4]
    fb4a:	4604      	mov	r4, r0
    {
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    fb4c:	4618      	mov	r0, r3
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    fb4e:	0793      	lsls	r3, r2, #30
{
    fb50:	b083      	sub	sp, #12
    fb52:	460d      	mov	r5, r1
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    fb54:	d40d      	bmi.n	fb72 <am_devices_led_toggle+0x3e>
        uint32_t ui32Ret, ui32Value;

        //
        // Check to see if the LED pin is enabled.
        //
        ui32Ret = am_hal_gpio_state_read(psLEDs[ui32LEDNum].ui32GPIONumber,
    fb56:	aa01      	add	r2, sp, #4
    fb58:	2102      	movs	r1, #2
    fb5a:	f7fe fe73 	bl	e844 <am_hal_gpio_state_read>
                                         AM_HAL_GPIO_ENABLE_READ, &ui32Value);

        if ( ui32Ret == AM_HAL_STATUS_SUCCESS )
    fb5e:	b958      	cbnz	r0, fb78 <am_devices_led_toggle+0x44>
        {
            if ( ui32Value )
    fb60:	9b01      	ldr	r3, [sp, #4]
    fb62:	f854 0035 	ldr.w	r0, [r4, r5, lsl #3]
    fb66:	b14b      	cbz	r3, fb7c <am_devices_led_toggle+0x48>
            {
                //
                // If it was enabled, turn if off.
                //
                am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    fb68:	2103      	movs	r1, #3
    fb6a:	f7fe fea3 	bl	e8b4 <am_hal_gpio_state_write>
    fb6e:	e003      	b.n	fb78 <am_devices_led_toggle+0x44>
    fb70:	4770      	bx	lr
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    fb72:	2102      	movs	r1, #2
    fb74:	f7fe fe9e 	bl	e8b4 <am_hal_gpio_state_write>
            //
            am_hal_gpio_out_enable_bit_set(psLEDs[ui32LEDNum].ui32GPIONumber);
        }
    }
#endif // AM_APOLLO3_GPIO
}
    fb78:	b003      	add	sp, #12
    fb7a:	bd30      	pop	{r4, r5, pc}
                am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    fb7c:	2104      	movs	r1, #4
    fb7e:	f7fe fe99 	bl	e8b4 <am_hal_gpio_state_write>
    fb82:	e7f9      	b.n	fb78 <am_devices_led_toggle+0x44>

0000fb84 <SEGGER_RTT_ReadNoLock>:
*    BufferSize   Size of the target application buffer.
*
*  Return value
*    Number of bytes that have been read.
*/
unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
    fb84:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  SEGGER_RTT_BUFFER_DOWN* pRing;
#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
  const char*             pSrc;
#endif
  //
  INIT();
    fb88:	4c38      	ldr	r4, [pc, #224]	; (fc6c <SEGGER_RTT_ReadNoLock+0xe8>)
    fb8a:	7825      	ldrb	r5, [r4, #0]
unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
    fb8c:	4681      	mov	r9, r0
    fb8e:	460b      	mov	r3, r1
    fb90:	4692      	mov	sl, r2
  INIT();
    fb92:	2d00      	cmp	r5, #0
    fb94:	d048      	beq.n	fc28 <SEGGER_RTT_ReadNoLock+0xa4>
  pRing = &_SEGGER_RTT.aDown[BufferIndex];
  pBuffer = (unsigned char*)pData;
  RdOff = pRing->RdOff;
    fb96:	ea4f 0849 	mov.w	r8, r9, lsl #1
    fb9a:	eb08 0709 	add.w	r7, r8, r9
    fb9e:	eb04 07c7 	add.w	r7, r4, r7, lsl #3
    fba2:	6f3e      	ldr	r6, [r7, #112]	; 0x70
  WrOff = pRing->WrOff;
    fba4:	f8d7 b06c 	ldr.w	fp, [r7, #108]	; 0x6c
  NumBytesRead = 0u;
  //
  // Read from current read position to wrap-around of buffer, first
  //
  if (RdOff > WrOff) {
    fba8:	455e      	cmp	r6, fp
    fbaa:	d81e      	bhi.n	fbea <SEGGER_RTT_ReadNoLock+0x66>
    }
  }
  //
  // Read remaining items of buffer
  //
  NumBytesRem = WrOff - RdOff;
    fbac:	ebab 0506 	sub.w	r5, fp, r6
  NumBytesRem = MIN(NumBytesRem, BufferSize);
    fbb0:	4555      	cmp	r5, sl
    fbb2:	bf28      	it	cs
    fbb4:	4655      	movcs	r5, sl
  if (NumBytesRem > 0u) {
    fbb6:	b915      	cbnz	r5, fbbe <SEGGER_RTT_ReadNoLock+0x3a>
  if (NumBytesRead) {
    pRing->RdOff = RdOff;
  }
  //
  return NumBytesRead;
}
    fbb8:	4628      	mov	r0, r5
    fbba:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  NumBytesRead = 0u;
    fbbe:	2700      	movs	r7, #0
    SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
    fbc0:	eb08 0209 	add.w	r2, r8, r9
    fbc4:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
    fbc8:	4618      	mov	r0, r3
    fbca:	6e51      	ldr	r1, [r2, #100]	; 0x64
    fbcc:	462a      	mov	r2, r5
    fbce:	4431      	add	r1, r6
    fbd0:	f7fc fa96 	bl	c100 <memcpy>
    RdOff        += NumBytesRem;
    fbd4:	442e      	add	r6, r5
    NumBytesRead += NumBytesRem;
    fbd6:	443d      	add	r5, r7
  if (NumBytesRead) {
    fbd8:	2d00      	cmp	r5, #0
    fbda:	d0ed      	beq.n	fbb8 <SEGGER_RTT_ReadNoLock+0x34>
    pRing->RdOff = RdOff;
    fbdc:	44c8      	add	r8, r9
    fbde:	eb04 04c8 	add.w	r4, r4, r8, lsl #3
}
    fbe2:	4628      	mov	r0, r5
    pRing->RdOff = RdOff;
    fbe4:	6726      	str	r6, [r4, #112]	; 0x70
}
    fbe6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
    fbea:	e9d7 1519 	ldrd	r1, r5, [r7, #100]	; 0x64
    NumBytesRem = pRing->SizeOfBuffer - RdOff;
    fbee:	1bad      	subs	r5, r5, r6
    NumBytesRem = MIN(NumBytesRem, BufferSize);
    fbf0:	4555      	cmp	r5, sl
    fbf2:	bf28      	it	cs
    fbf4:	4655      	movcs	r5, sl
    SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
    fbf6:	462a      	mov	r2, r5
    fbf8:	4431      	add	r1, r6
    fbfa:	4618      	mov	r0, r3
    fbfc:	f7fc fa80 	bl	c100 <memcpy>
    if (RdOff == pRing->SizeOfBuffer) {
    fc00:	6eba      	ldr	r2, [r7, #104]	; 0x68
    RdOff        += NumBytesRem;
    fc02:	442e      	add	r6, r5
    if (RdOff == pRing->SizeOfBuffer) {
    fc04:	42b2      	cmp	r2, r6
    BufferSize   -= NumBytesRem;
    fc06:	ebaa 0a05 	sub.w	sl, sl, r5
    fc0a:	bf14      	ite	ne
    fc0c:	ebab 0b06 	subne.w	fp, fp, r6
      RdOff = 0u;
    fc10:	2600      	moveq	r6, #0
  NumBytesRem = MIN(NumBytesRem, BufferSize);
    fc12:	45d3      	cmp	fp, sl
    fc14:	bf28      	it	cs
    fc16:	46d3      	movcs	fp, sl
    SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
    fc18:	4603      	mov	r3, r0
  if (NumBytesRem > 0u) {
    fc1a:	f1bb 0f00 	cmp.w	fp, #0
    fc1e:	d0db      	beq.n	fbd8 <SEGGER_RTT_ReadNoLock+0x54>
    pBuffer      += NumBytesRem;
    fc20:	442b      	add	r3, r5
    fc22:	462f      	mov	r7, r5
    fc24:	465d      	mov	r5, fp
    fc26:	e7cb      	b.n	fbc0 <SEGGER_RTT_ReadNoLock+0x3c>
  strcpy(&p->acID[7], "RTT");
    fc28:	4911      	ldr	r1, [pc, #68]	; (fc70 <SEGGER_RTT_ReadNoLock+0xec>)
  strcpy(&p->acID[0], "SEGGER");
    fc2a:	4a12      	ldr	r2, [pc, #72]	; (fc74 <SEGGER_RTT_ReadNoLock+0xf0>)
  strcpy(&p->acID[7], "RTT");
    fc2c:	6808      	ldr	r0, [r1, #0]
    fc2e:	f8c4 0007 	str.w	r0, [r4, #7]
  strcpy(&p->acID[0], "SEGGER");
    fc32:	e892 0003 	ldmia.w	r2, {r0, r1}
  p->aUp[0].RdOff         = 0u;
    fc36:	62a5      	str	r5, [r4, #40]	; 0x28
  p->aUp[0].sName         = "Terminal";
    fc38:	4a0f      	ldr	r2, [pc, #60]	; (fc78 <SEGGER_RTT_ReadNoLock+0xf4>)
  p->aUp[0].WrOff         = 0u;
    fc3a:	6265      	str	r5, [r4, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    fc3c:	62e5      	str	r5, [r4, #44]	; 0x2c
  p->aDown[0].RdOff         = 0u;
    fc3e:	6725      	str	r5, [r4, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
    fc40:	66e5      	str	r5, [r4, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    fc42:	6765      	str	r5, [r4, #116]	; 0x74
  strcpy(&p->acID[0], "SEGGER");
    fc44:	6020      	str	r0, [r4, #0]
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
    fc46:	2503      	movs	r5, #3
  strcpy(&p->acID[0], "SEGGER");
    fc48:	80a1      	strh	r1, [r4, #4]
  p->aDown[0].pBuffer       = _acDownBuffer;
    fc4a:	480c      	ldr	r0, [pc, #48]	; (fc7c <SEGGER_RTT_ReadNoLock+0xf8>)
  p->aUp[0].pBuffer       = _acUpBuffer;
    fc4c:	490c      	ldr	r1, [pc, #48]	; (fc80 <SEGGER_RTT_ReadNoLock+0xfc>)
  p->aUp[0].sName         = "Terminal";
    fc4e:	61a2      	str	r2, [r4, #24]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
    fc50:	e9c4 5504 	strd	r5, r5, [r4, #16]
  p->aDown[0].sName         = "Terminal";
    fc54:	6622      	str	r2, [r4, #96]	; 0x60
  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
    fc56:	f44f 6580 	mov.w	r5, #1024	; 0x400
  p->aUp[0].pBuffer       = _acUpBuffer;
    fc5a:	61e1      	str	r1, [r4, #28]
  p->acID[6] = ' ';
    fc5c:	2220      	movs	r2, #32
  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
    fc5e:	2110      	movs	r1, #16
  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
    fc60:	6225      	str	r5, [r4, #32]
  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
    fc62:	e9c4 0119 	strd	r0, r1, [r4, #100]	; 0x64
  p->acID[6] = ' ';
    fc66:	71a2      	strb	r2, [r4, #6]
    fc68:	e795      	b.n	fb96 <SEGGER_RTT_ReadNoLock+0x12>
    fc6a:	bf00      	nop
    fc6c:	10014404 	.word	0x10014404
    fc70:	000136e0 	.word	0x000136e0
    fc74:	000136e4 	.word	0x000136e4
    fc78:	000136d4 	.word	0x000136d4
    fc7c:	10012e10 	.word	0x10012e10
    fc80:	10012e20 	.word	0x10012e20

0000fc84 <SEGGER_RTT_WriteSkipNoLock>:
*    (1) If there is not enough space in the "Up"-buffer, all data is dropped.
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    fc84:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  pData = (const char *)pBuffer;
  //
  // Get "to-host" ring buffer and copy some elements into local variables.
  //
  pRing = &_SEGGER_RTT.aUp[BufferIndex];
  RdOff = pRing->RdOff;
    fc88:	f8df 9090 	ldr.w	r9, [pc, #144]	; fd1c <SEGGER_RTT_WriteSkipNoLock+0x98>
    fc8c:	eb00 0440 	add.w	r4, r0, r0, lsl #1
    fc90:	eb09 04c4 	add.w	r4, r9, r4, lsl #3
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    fc94:	4616      	mov	r6, r2
  RdOff = pRing->RdOff;
    fc96:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  WrOff = pRing->WrOff;
    fc98:	6a65      	ldr	r5, [r4, #36]	; 0x24
  //
  //    RdOff > WrOff -> Space until RdOff - 1 is free.
  //  AND
  //    WrOff + NumBytes < RdOff -> Data fits into buffer
  //
  if (RdOff <= WrOff) {
    fc9a:	42ab      	cmp	r3, r5
    fc9c:	d821      	bhi.n	fce2 <SEGGER_RTT_WriteSkipNoLock+0x5e>
    //
    // Get space until WrOff will be at wrap around.
    //
    Avail = pRing->SizeOfBuffer - 1u - WrOff ;
    fc9e:	6a27      	ldr	r7, [r4, #32]
    fca0:	1b7f      	subs	r7, r7, r5
    fca2:	f107 3eff 	add.w	lr, r7, #4294967295	; 0xffffffff
    if (Avail >= NumBytes) {
    fca6:	4572      	cmp	r2, lr
    fca8:	d930      	bls.n	fd0c <SEGGER_RTT_WriteSkipNoLock+0x88>
      return 1;
    }
    //
    // If data did not fit into space until wrap around calculate complete space in buffer.
    //
    Avail += RdOff;
    fcaa:	4473      	add	r3, lr
    //
    // If there is still no space for the whole of this output, don't bother.
    //
    if (Avail >= NumBytes) {
    fcac:	429a      	cmp	r2, r3
    fcae:	d81c      	bhi.n	fcea <SEGGER_RTT_WriteSkipNoLock+0x66>
    fcb0:	3001      	adds	r0, #1
    fcb2:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    fcb6:	eb09 09c0 	add.w	r9, r9, r0, lsl #3
      //
      //  OK, we have enough space in buffer. Copy in one or 2 chunks
      //
      Rem = pRing->SizeOfBuffer - WrOff;      // Space until end of buffer
      if (Rem > NumBytes) {
    fcba:	4297      	cmp	r7, r2
    fcbc:	f8d9 0004 	ldr.w	r0, [r9, #4]
    fcc0:	4428      	add	r0, r5
    fcc2:	d81c      	bhi.n	fcfe <SEGGER_RTT_WriteSkipNoLock+0x7a>
          *pDst++ = *pData++;
        };
        pRing->WrOff = WrOff;
#else
        SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, Rem);
        SEGGER_RTT_MEMCPY(pRing->pBuffer, pData + Rem, NumBytes - Rem);
    fcc4:	1bd6      	subs	r6, r2, r7
    fcc6:	4688      	mov	r8, r1
        SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, Rem);
    fcc8:	463a      	mov	r2, r7
    fcca:	f7fc fa19 	bl	c100 <memcpy>
        SEGGER_RTT_MEMCPY(pRing->pBuffer, pData + Rem, NumBytes - Rem);
    fcce:	eb08 0107 	add.w	r1, r8, r7
    fcd2:	f8d9 0004 	ldr.w	r0, [r9, #4]
    fcd6:	4632      	mov	r2, r6
    fcd8:	f7fc fa12 	bl	c100 <memcpy>
        pRing->WrOff = NumBytes - Rem;
    fcdc:	6266      	str	r6, [r4, #36]	; 0x24
#endif
      }
      return 1;
    fcde:	2001      	movs	r0, #1
    fce0:	e004      	b.n	fcec <SEGGER_RTT_WriteSkipNoLock+0x68>
    }
  } else {
    Avail = RdOff - WrOff - 1u;
    fce2:	3b01      	subs	r3, #1
    fce4:	1b5b      	subs	r3, r3, r5
    if (Avail >= NumBytes) {
    fce6:	4293      	cmp	r3, r2
    fce8:	d202      	bcs.n	fcf0 <SEGGER_RTT_WriteSkipNoLock+0x6c>
    }
  }
  //
  // If we reach this point no data has been written
  //
  return 0;
    fcea:	2000      	movs	r0, #0
}
    fcec:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytes);
    fcf0:	3001      	adds	r0, #1
    fcf2:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    fcf6:	eb09 00c0 	add.w	r0, r9, r0, lsl #3
    fcfa:	6840      	ldr	r0, [r0, #4]
    fcfc:	4428      	add	r0, r5
      pRing->WrOff = WrOff + NumBytes;
    fcfe:	4435      	add	r5, r6
      SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytes);
    fd00:	f7fc f9fe 	bl	c100 <memcpy>
      pRing->WrOff = WrOff + NumBytes;
    fd04:	6265      	str	r5, [r4, #36]	; 0x24
      return 1;
    fd06:	2001      	movs	r0, #1
}
    fd08:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytes);
    fd0c:	3001      	adds	r0, #1
    fd0e:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    fd12:	eb09 0cc0 	add.w	ip, r9, r0, lsl #3
    fd16:	f8dc 0004 	ldr.w	r0, [ip, #4]
    fd1a:	e7ef      	b.n	fcfc <SEGGER_RTT_WriteSkipNoLock+0x78>
    fd1c:	10014404 	.word	0x10014404

0000fd20 <SEGGER_RTT_ConfigUpBuffer>:
*  Additional information
*    Buffer 0 is configured on compile-time.
*    May only be called once per buffer.
*    Buffer name and flags can be reconfigured using the appropriate functions.
*/
int SEGGER_RTT_ConfigUpBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
    fd20:	b4f0      	push	{r4, r5, r6, r7}
  int r;

  INIT();
    fd22:	4c2a      	ldr	r4, [pc, #168]	; (fdcc <SEGGER_RTT_ConfigUpBuffer+0xac>)
    fd24:	7826      	ldrb	r6, [r4, #0]
int SEGGER_RTT_ConfigUpBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
    fd26:	4605      	mov	r5, r0
    fd28:	460f      	mov	r7, r1
  INIT();
    fd2a:	b346      	cbz	r6, fd7e <SEGGER_RTT_ConfigUpBuffer+0x5e>
    fd2c:	6921      	ldr	r1, [r4, #16]
  if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
    fd2e:	428d      	cmp	r5, r1
    fd30:	d248      	bcs.n	fdc4 <SEGGER_RTT_ConfigUpBuffer+0xa4>
    SEGGER_RTT_LOCK();
    fd32:	f3ef 8611 	mrs	r6, BASEPRI
    fd36:	f04f 0120 	mov.w	r1, #32
    fd3a:	f381 8811 	msr	BASEPRI, r1
    if (BufferIndex > 0u) {
    fd3e:	b955      	cbnz	r5, fd56 <SEGGER_RTT_ConfigUpBuffer+0x36>
    fd40:	4628      	mov	r0, r5
      _SEGGER_RTT.aUp[BufferIndex].pBuffer      = (char*)pBuffer;
      _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
      _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
      _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
    }
    _SEGGER_RTT.aUp[BufferIndex].Flags          = Flags;
    fd42:	4405      	add	r5, r0
    fd44:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
    fd48:	9b04      	ldr	r3, [sp, #16]
    fd4a:	62e3      	str	r3, [r4, #44]	; 0x2c
    SEGGER_RTT_UNLOCK();
    fd4c:	f386 8811 	msr	BASEPRI, r6
    r =  0;
    fd50:	2000      	movs	r0, #0
  } else {
    r = -1;
  }
  return r;
}
    fd52:	bcf0      	pop	{r4, r5, r6, r7}
    fd54:	4770      	bx	lr
      _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
    fd56:	1c69      	adds	r1, r5, #1
    fd58:	eb01 0141 	add.w	r1, r1, r1, lsl #1
      _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
    fd5c:	0068      	lsls	r0, r5, #1
      _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
    fd5e:	00c9      	lsls	r1, r1, #3
      _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
    fd60:	eb00 0c05 	add.w	ip, r0, r5
    fd64:	eb04 0ccc 	add.w	ip, r4, ip, lsl #3
      _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
    fd68:	5067      	str	r7, [r4, r1]
      _SEGGER_RTT.aUp[BufferIndex].pBuffer      = (char*)pBuffer;
    fd6a:	4421      	add	r1, r4
      _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
    fd6c:	f8cc 3020 	str.w	r3, [ip, #32]
      _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
    fd70:	2300      	movs	r3, #0
      _SEGGER_RTT.aUp[BufferIndex].pBuffer      = (char*)pBuffer;
    fd72:	604a      	str	r2, [r1, #4]
      _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
    fd74:	f8cc 3028 	str.w	r3, [ip, #40]	; 0x28
      _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
    fd78:	f8cc 3024 	str.w	r3, [ip, #36]	; 0x24
    fd7c:	e7e1      	b.n	fd42 <SEGGER_RTT_ConfigUpBuffer+0x22>
  strcpy(&p->acID[7], "RTT");
    fd7e:	4814      	ldr	r0, [pc, #80]	; (fdd0 <SEGGER_RTT_ConfigUpBuffer+0xb0>)
  strcpy(&p->acID[0], "SEGGER");
    fd80:	4914      	ldr	r1, [pc, #80]	; (fdd4 <SEGGER_RTT_ConfigUpBuffer+0xb4>)
  strcpy(&p->acID[7], "RTT");
    fd82:	6800      	ldr	r0, [r0, #0]
    fd84:	f8c4 0007 	str.w	r0, [r4, #7]
  strcpy(&p->acID[0], "SEGGER");
    fd88:	c903      	ldmia	r1, {r0, r1}
  p->aUp[0].RdOff         = 0u;
    fd8a:	62a6      	str	r6, [r4, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
    fd8c:	6266      	str	r6, [r4, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    fd8e:	62e6      	str	r6, [r4, #44]	; 0x2c
  p->aDown[0].RdOff         = 0u;
    fd90:	6726      	str	r6, [r4, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
    fd92:	66e6      	str	r6, [r4, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    fd94:	6766      	str	r6, [r4, #116]	; 0x74
  strcpy(&p->acID[0], "SEGGER");
    fd96:	6020      	str	r0, [r4, #0]
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
    fd98:	2603      	movs	r6, #3
  p->aUp[0].sName         = "Terminal";
    fd9a:	480f      	ldr	r0, [pc, #60]	; (fdd8 <SEGGER_RTT_ConfigUpBuffer+0xb8>)
  strcpy(&p->acID[0], "SEGGER");
    fd9c:	80a1      	strh	r1, [r4, #4]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
    fd9e:	e9c4 6604 	strd	r6, r6, [r4, #16]
  p->acID[6] = ' ';
    fda2:	4631      	mov	r1, r6
  p->aUp[0].sName         = "Terminal";
    fda4:	61a0      	str	r0, [r4, #24]
  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
    fda6:	f44f 6680 	mov.w	r6, #1024	; 0x400
  p->aDown[0].sName         = "Terminal";
    fdaa:	6620      	str	r0, [r4, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
    fdac:	480b      	ldr	r0, [pc, #44]	; (fddc <SEGGER_RTT_ConfigUpBuffer+0xbc>)
  p->aUp[0].pBuffer       = _acUpBuffer;
    fdae:	f8df c030 	ldr.w	ip, [pc, #48]	; fde0 <SEGGER_RTT_ConfigUpBuffer+0xc0>
  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
    fdb2:	6226      	str	r6, [r4, #32]
  p->aDown[0].pBuffer       = _acDownBuffer;
    fdb4:	6660      	str	r0, [r4, #100]	; 0x64
  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
    fdb6:	2610      	movs	r6, #16
  p->acID[6] = ' ';
    fdb8:	2020      	movs	r0, #32
  p->aUp[0].pBuffer       = _acUpBuffer;
    fdba:	f8c4 c01c 	str.w	ip, [r4, #28]
  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
    fdbe:	66a6      	str	r6, [r4, #104]	; 0x68
  p->acID[6] = ' ';
    fdc0:	71a0      	strb	r0, [r4, #6]
    fdc2:	e7b4      	b.n	fd2e <SEGGER_RTT_ConfigUpBuffer+0xe>
    r = -1;
    fdc4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  return r;
    fdc8:	e7c3      	b.n	fd52 <SEGGER_RTT_ConfigUpBuffer+0x32>
    fdca:	bf00      	nop
    fdcc:	10014404 	.word	0x10014404
    fdd0:	000136e0 	.word	0x000136e0
    fdd4:	000136e4 	.word	0x000136e4
    fdd8:	000136d4 	.word	0x000136d4
    fddc:	10012e10 	.word	0x10012e10
    fde0:	10012e20 	.word	0x10012e20

0000fde4 <SEGGER_RTT_ConfigDownBuffer>:
*  Additional information
*    Buffer 0 is configured on compile-time.
*    May only be called once per buffer.
*    Buffer name and flags can be reconfigured using the appropriate functions.
*/
int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
    fde4:	b4f0      	push	{r4, r5, r6, r7}
  int r;

  INIT();
    fde6:	4c27      	ldr	r4, [pc, #156]	; (fe84 <SEGGER_RTT_ConfigDownBuffer+0xa0>)
    fde8:	7826      	ldrb	r6, [r4, #0]
int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
    fdea:	4605      	mov	r5, r0
    fdec:	460f      	mov	r7, r1
  INIT();
    fdee:	b316      	cbz	r6, fe36 <SEGGER_RTT_ConfigDownBuffer+0x52>
    fdf0:	6961      	ldr	r1, [r4, #20]
  if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
    fdf2:	428d      	cmp	r5, r1
    fdf4:	d242      	bcs.n	fe7c <SEGGER_RTT_ConfigDownBuffer+0x98>
    SEGGER_RTT_LOCK();
    fdf6:	f3ef 8611 	mrs	r6, BASEPRI
    fdfa:	f04f 0120 	mov.w	r1, #32
    fdfe:	f381 8811 	msr	BASEPRI, r1
    if (BufferIndex > 0u) {
    fe02:	b955      	cbnz	r5, fe1a <SEGGER_RTT_ConfigDownBuffer+0x36>
    fe04:	4629      	mov	r1, r5
      _SEGGER_RTT.aDown[BufferIndex].pBuffer      = (char*)pBuffer;
      _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
      _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
      _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
    }
    _SEGGER_RTT.aDown[BufferIndex].Flags          = Flags;
    fe06:	440d      	add	r5, r1
    fe08:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
    fe0c:	9b04      	ldr	r3, [sp, #16]
    fe0e:	6763      	str	r3, [r4, #116]	; 0x74
    SEGGER_RTT_UNLOCK();
    fe10:	f386 8811 	msr	BASEPRI, r6
    r =  0;
    fe14:	2000      	movs	r0, #0
  } else {
    r = -1;
  }
  return r;
}
    fe16:	bcf0      	pop	{r4, r5, r6, r7}
    fe18:	4770      	bx	lr
      _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
    fe1a:	0069      	lsls	r1, r5, #1
    fe1c:	1948      	adds	r0, r1, r5
    fe1e:	eb04 00c0 	add.w	r0, r4, r0, lsl #3
      _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
    fe22:	f04f 0c00 	mov.w	ip, #0
      _SEGGER_RTT.aDown[BufferIndex].pBuffer      = (char*)pBuffer;
    fe26:	e9c0 7218 	strd	r7, r2, [r0, #96]	; 0x60
      _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
    fe2a:	6683      	str	r3, [r0, #104]	; 0x68
      _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
    fe2c:	f8c0 c070 	str.w	ip, [r0, #112]	; 0x70
      _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
    fe30:	f8c0 c06c 	str.w	ip, [r0, #108]	; 0x6c
    fe34:	e7e7      	b.n	fe06 <SEGGER_RTT_ConfigDownBuffer+0x22>
  strcpy(&p->acID[7], "RTT");
    fe36:	4814      	ldr	r0, [pc, #80]	; (fe88 <SEGGER_RTT_ConfigDownBuffer+0xa4>)
  strcpy(&p->acID[0], "SEGGER");
    fe38:	4914      	ldr	r1, [pc, #80]	; (fe8c <SEGGER_RTT_ConfigDownBuffer+0xa8>)
  strcpy(&p->acID[7], "RTT");
    fe3a:	6800      	ldr	r0, [r0, #0]
    fe3c:	f8c4 0007 	str.w	r0, [r4, #7]
  strcpy(&p->acID[0], "SEGGER");
    fe40:	c903      	ldmia	r1, {r0, r1}
  p->aUp[0].RdOff         = 0u;
    fe42:	62a6      	str	r6, [r4, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
    fe44:	6266      	str	r6, [r4, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    fe46:	62e6      	str	r6, [r4, #44]	; 0x2c
  p->aDown[0].RdOff         = 0u;
    fe48:	6726      	str	r6, [r4, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
    fe4a:	66e6      	str	r6, [r4, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    fe4c:	6766      	str	r6, [r4, #116]	; 0x74
  strcpy(&p->acID[0], "SEGGER");
    fe4e:	6020      	str	r0, [r4, #0]
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
    fe50:	2603      	movs	r6, #3
  p->aUp[0].sName         = "Terminal";
    fe52:	480f      	ldr	r0, [pc, #60]	; (fe90 <SEGGER_RTT_ConfigDownBuffer+0xac>)
  strcpy(&p->acID[0], "SEGGER");
    fe54:	80a1      	strh	r1, [r4, #4]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
    fe56:	e9c4 6604 	strd	r6, r6, [r4, #16]
  p->acID[6] = ' ';
    fe5a:	4631      	mov	r1, r6
  p->aUp[0].sName         = "Terminal";
    fe5c:	61a0      	str	r0, [r4, #24]
  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
    fe5e:	f44f 6680 	mov.w	r6, #1024	; 0x400
  p->aDown[0].sName         = "Terminal";
    fe62:	6620      	str	r0, [r4, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
    fe64:	480b      	ldr	r0, [pc, #44]	; (fe94 <SEGGER_RTT_ConfigDownBuffer+0xb0>)
  p->aUp[0].pBuffer       = _acUpBuffer;
    fe66:	f8df c030 	ldr.w	ip, [pc, #48]	; fe98 <SEGGER_RTT_ConfigDownBuffer+0xb4>
  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
    fe6a:	6226      	str	r6, [r4, #32]
  p->aDown[0].pBuffer       = _acDownBuffer;
    fe6c:	6660      	str	r0, [r4, #100]	; 0x64
  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
    fe6e:	2610      	movs	r6, #16
  p->acID[6] = ' ';
    fe70:	2020      	movs	r0, #32
  p->aUp[0].pBuffer       = _acUpBuffer;
    fe72:	f8c4 c01c 	str.w	ip, [r4, #28]
  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
    fe76:	66a6      	str	r6, [r4, #104]	; 0x68
  p->acID[6] = ' ';
    fe78:	71a0      	strb	r0, [r4, #6]
    fe7a:	e7ba      	b.n	fdf2 <SEGGER_RTT_ConfigDownBuffer+0xe>
    r = -1;
    fe7c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  return r;
    fe80:	e7c9      	b.n	fe16 <SEGGER_RTT_ConfigDownBuffer+0x32>
    fe82:	bf00      	nop
    fe84:	10014404 	.word	0x10014404
    fe88:	000136e0 	.word	0x000136e0
    fe8c:	000136e4 	.word	0x000136e4
    fe90:	000136d4 	.word	0x000136d4
    fe94:	10012e10 	.word	0x10012e10
    fe98:	10012e20 	.word	0x10012e20

0000fe9c <SEGGER_SYSVIEW_Init>:
*    to identify the SystemView channel.
*
*  Notes
*    The channel is configured by the macro SEGGER_SYSVIEW_RTT_CHANNEL.
*/
void SEGGER_SYSVIEW_Init(U32 SysFreq, U32 CPUFreq, const SEGGER_SYSVIEW_OS_API *pOSAPI, SEGGER_SYSVIEW_SEND_SYS_DESC_FUNC pfSendSysDesc) {
    fe9c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  _SYSVIEW_Globals.pfSendSysDesc    = pfSendSysDesc;
  _SYSVIEW_Globals.EnableState      = 0;
  _SYSVIEW_Globals.PacketCount      = 0;
#else // (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
#if SEGGER_SYSVIEW_RTT_CHANNEL > 0
  SEGGER_RTT_ConfigUpBuffer   (SEGGER_SYSVIEW_RTT_CHANNEL, "SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
    fea0:	4d12      	ldr	r5, [pc, #72]	; (feec <SEGGER_SYSVIEW_Init+0x50>)
void SEGGER_SYSVIEW_Init(U32 SysFreq, U32 CPUFreq, const SEGGER_SYSVIEW_OS_API *pOSAPI, SEGGER_SYSVIEW_SEND_SYS_DESC_FUNC pfSendSysDesc) {
    fea2:	b083      	sub	sp, #12
  SEGGER_RTT_ConfigUpBuffer   (SEGGER_SYSVIEW_RTT_CHANNEL, "SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
    fea4:	2400      	movs	r4, #0
void SEGGER_SYSVIEW_Init(U32 SysFreq, U32 CPUFreq, const SEGGER_SYSVIEW_OS_API *pOSAPI, SEGGER_SYSVIEW_SEND_SYS_DESC_FUNC pfSendSysDesc) {
    fea6:	4680      	mov	r8, r0
    fea8:	460f      	mov	r7, r1
    feaa:	4691      	mov	r9, r2
    feac:	461e      	mov	r6, r3
  SEGGER_RTT_ConfigUpBuffer   (SEGGER_SYSVIEW_RTT_CHANNEL, "SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
    feae:	4629      	mov	r1, r5
    feb0:	9400      	str	r4, [sp, #0]
    feb2:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    feb6:	4a0e      	ldr	r2, [pc, #56]	; (fef0 <SEGGER_SYSVIEW_Init+0x54>)
    feb8:	2001      	movs	r0, #1
    feba:	f7ff ff31 	bl	fd20 <SEGGER_RTT_ConfigUpBuffer>
  SEGGER_RTT_ConfigDownBuffer (SEGGER_SYSVIEW_RTT_CHANNEL, "SysView", &_DownBuffer[0], sizeof(_DownBuffer), SEGGER_RTT_MODE_NO_BLOCK_SKIP);
    febe:	4629      	mov	r1, r5
    fec0:	9400      	str	r4, [sp, #0]
    fec2:	2308      	movs	r3, #8
    fec4:	4a0b      	ldr	r2, [pc, #44]	; (fef4 <SEGGER_SYSVIEW_Init+0x58>)
    fec6:	2001      	movs	r0, #1
    fec8:	f7ff ff8c 	bl	fde4 <SEGGER_RTT_ConfigDownBuffer>
  //
  _SYSVIEW_Globals.DownChannel = _SYSVIEW_Globals.UpChannel;
  SEGGER_RTT_ConfigDownBuffer (_SYSVIEW_Globals.DownChannel, "SysView", &_DownBuffer[0], sizeof(_DownBuffer), SEGGER_RTT_MODE_NO_BLOCK_SKIP);
#endif
  _SYSVIEW_Globals.RAMBaseAddress   = SEGGER_SYSVIEW_ID_BASE;
  _SYSVIEW_Globals.LastTxTimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
    fecc:	4a0a      	ldr	r2, [pc, #40]	; (fef8 <SEGGER_SYSVIEW_Init+0x5c>)
  _SYSVIEW_Globals.RAMBaseAddress   = SEGGER_SYSVIEW_ID_BASE;
    fece:	4b0b      	ldr	r3, [pc, #44]	; (fefc <SEGGER_SYSVIEW_Init+0x60>)
  _SYSVIEW_Globals.LastTxTimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
    fed0:	6812      	ldr	r2, [r2, #0]
  _SYSVIEW_Globals.pOSAPI           = pOSAPI;
    fed2:	f8c3 9020 	str.w	r9, [r3, #32]
  _SYSVIEW_Globals.RAMBaseAddress   = SEGGER_SYSVIEW_ID_BASE;
    fed6:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  _SYSVIEW_Globals.SysFreq          = SysFreq;
  _SYSVIEW_Globals.CPUFreq          = CPUFreq;
    feda:	e9c3 8701 	strd	r8, r7, [r3, #4]
  _SYSVIEW_Globals.pfSendSysDesc    = pfSendSysDesc;
    fede:	625e      	str	r6, [r3, #36]	; 0x24
  _SYSVIEW_Globals.LastTxTimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
    fee0:	e9c3 2103 	strd	r2, r1, [r3, #12]
  _SYSVIEW_Globals.EnableState      = 0;
    fee4:	701c      	strb	r4, [r3, #0]
#endif  // (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
}
    fee6:	b003      	add	sp, #12
    fee8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    feec:	000136ec 	.word	0x000136ec
    fef0:	10013254 	.word	0x10013254
    fef4:	10013220 	.word	0x10013220
    fef8:	e0001004 	.word	0xe0001004
    fefc:	1001322c 	.word	0x1001322c

0000ff00 <SEGGER_SYSVIEW_SetRAMBase>:
*
*  Parameters
*    RAMBaseAddress - Lowest RAM Address. (i.e. 0x20000000 on most Cortex-M)
*/
void SEGGER_SYSVIEW_SetRAMBase(U32 RAMBaseAddress) {
  _SYSVIEW_Globals.RAMBaseAddress = RAMBaseAddress;
    ff00:	4b01      	ldr	r3, [pc, #4]	; (ff08 <SEGGER_SYSVIEW_SetRAMBase+0x8>)
    ff02:	6118      	str	r0, [r3, #16]
}
    ff04:	4770      	bx	lr
    ff06:	bf00      	nop
    ff08:	1001322c 	.word	0x1001322c

0000ff0c <SEGGER_SYSVIEW_EncodeU32>:
*  Return value
*    Pointer to the byte following the value, i.e. the first free
*    byte in the payload and the next position to store payload
*    content.
*/
U8* SEGGER_SYSVIEW_EncodeU32(U8* pPayload, U32 Value) {
    ff0c:	e004      	b.n	ff18 <SEGGER_SYSVIEW_EncodeU32+0xc>
  ENCODE_U32(pPayload, Value);
    ff0e:	f061 037f 	orn	r3, r1, #127	; 0x7f
    ff12:	f800 3b01 	strb.w	r3, [r0], #1
    ff16:	09c9      	lsrs	r1, r1, #7
    ff18:	297f      	cmp	r1, #127	; 0x7f
    ff1a:	d8f8      	bhi.n	ff0e <SEGGER_SYSVIEW_EncodeU32+0x2>
    ff1c:	f800 1b01 	strb.w	r1, [r0], #1
  return pPayload;
}
    ff20:	4770      	bx	lr
    ff22:	bf00      	nop

0000ff24 <SEGGER_SYSVIEW_ShrinkId>:
*       (i.e. 0x20000000 when all Ids are an address in this RAM)
*     SEGGER_SYSVIEW_ID_SHIFT: Number of bits to shift the Id to
*       save bandwidth. (i.e. 2 when Ids are 4 byte aligned)
*/
U32 SEGGER_SYSVIEW_ShrinkId(U32 Id) {
  return SHRINK_ID(Id);
    ff24:	4b02      	ldr	r3, [pc, #8]	; (ff30 <SEGGER_SYSVIEW_ShrinkId+0xc>)
    ff26:	691b      	ldr	r3, [r3, #16]
    ff28:	1ac0      	subs	r0, r0, r3
}
    ff2a:	0880      	lsrs	r0, r0, #2
    ff2c:	4770      	bx	lr
    ff2e:	bf00      	nop
    ff30:	1001322c 	.word	0x1001322c

0000ff34 <SEGGER_SYSVIEW_SendModule>:
*/
void SEGGER_SYSVIEW_SendModule(U8 ModuleId) {
  SEGGER_SYSVIEW_MODULE* pModule;
  U32 n;

  if (_pFirstModule != 0) {
    ff34:	4b64      	ldr	r3, [pc, #400]	; (100c8 <SEGGER_SYSVIEW_SendModule+0x194>)
    ff36:	681b      	ldr	r3, [r3, #0]
    ff38:	2b00      	cmp	r3, #0
    ff3a:	f000 80ac 	beq.w	10096 <SEGGER_SYSVIEW_SendModule+0x162>
void SEGGER_SYSVIEW_SendModule(U8 ModuleId) {
    ff3e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    pModule = _pFirstModule;
    for (n = 0; n < ModuleId; n++) {
    ff42:	2800      	cmp	r0, #0
    ff44:	f000 80b6 	beq.w	100b4 <SEGGER_SYSVIEW_SendModule+0x180>
      pModule = pModule->pNext;
    ff48:	691b      	ldr	r3, [r3, #16]
      if (pModule == 0) {
    ff4a:	2b00      	cmp	r3, #0
    ff4c:	f000 80a1 	beq.w	10092 <SEGGER_SYSVIEW_SendModule+0x15e>
    for (n = 0; n < ModuleId; n++) {
    ff50:	2200      	movs	r2, #0
    ff52:	e003      	b.n	ff5c <SEGGER_SYSVIEW_SendModule+0x28>
      pModule = pModule->pNext;
    ff54:	691b      	ldr	r3, [r3, #16]
      if (pModule == 0) {
    ff56:	2b00      	cmp	r3, #0
    ff58:	f000 809b 	beq.w	10092 <SEGGER_SYSVIEW_SendModule+0x15e>
    for (n = 0; n < ModuleId; n++) {
    ff5c:	3201      	adds	r2, #1
    ff5e:	4282      	cmp	r2, r0
    ff60:	d1f8      	bne.n	ff54 <SEGGER_SYSVIEW_SendModule+0x20>
    ff62:	b2d0      	uxtb	r0, r2
      }
    }
    if (pModule != 0) {
      U8* pPayload;
      U8* pPayloadStart;
      RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
    ff64:	f3ef 8411 	mrs	r4, BASEPRI
    ff68:	f04f 0120 	mov.w	r1, #32
    ff6c:	f381 8811 	msr	BASEPRI, r1
      pPayload = pPayloadStart;
      //
      // Send module description
      // Send event offset and number of events
      //
      ENCODE_U32(pPayload, ModuleId);
    ff70:	2a7f      	cmp	r2, #127	; 0x7f
    ff72:	f240 80a7 	bls.w	100c4 <SEGGER_SYSVIEW_SendModule+0x190>
    ff76:	4955      	ldr	r1, [pc, #340]	; (100cc <SEGGER_SYSVIEW_SendModule+0x198>)
    ff78:	7108      	strb	r0, [r1, #4]
    ff7a:	3105      	adds	r1, #5
    ff7c:	2001      	movs	r0, #1
    ff7e:	7008      	strb	r0, [r1, #0]
      ENCODE_U32(pPayload, (pModule->EventOffset));
    ff80:	689a      	ldr	r2, [r3, #8]
    ff82:	2a7f      	cmp	r2, #127	; 0x7f
      ENCODE_U32(pPayload, ModuleId);
    ff84:	f101 0101 	add.w	r1, r1, #1
      ENCODE_U32(pPayload, (pModule->EventOffset));
    ff88:	d906      	bls.n	ff98 <SEGGER_SYSVIEW_SendModule+0x64>
    ff8a:	f062 007f 	orn	r0, r2, #127	; 0x7f
    ff8e:	09d2      	lsrs	r2, r2, #7
    ff90:	2a7f      	cmp	r2, #127	; 0x7f
    ff92:	f801 0b01 	strb.w	r0, [r1], #1
    ff96:	d8f8      	bhi.n	ff8a <SEGGER_SYSVIEW_SendModule+0x56>
    ff98:	460d      	mov	r5, r1
    ff9a:	f805 2b02 	strb.w	r2, [r5], #2
      pPayload = _EncodeStr(pPayload, pModule->sModule, SEGGER_SYSVIEW_MAX_STRING_LEN);
    ff9e:	f8d3 c000 	ldr.w	ip, [r3]
  while(*(pText + Len) != 0) {
    ffa2:	f89c 3000 	ldrb.w	r3, [ip]
    ffa6:	2b00      	cmp	r3, #0
    ffa8:	f000 8081 	beq.w	100ae <SEGGER_SYSVIEW_SendModule+0x17a>
    ffac:	4660      	mov	r0, ip
  Len = 0;
    ffae:	2200      	movs	r2, #0
  while(*(pText + Len) != 0) {
    ffb0:	f810 3f01 	ldrb.w	r3, [r0, #1]!
    Len++;
    ffb4:	3201      	adds	r2, #1
  while(*(pText + Len) != 0) {
    ffb6:	2b00      	cmp	r3, #0
    ffb8:	d1fa      	bne.n	ffb0 <SEGGER_SYSVIEW_SendModule+0x7c>
    ffba:	f10c 0608 	add.w	r6, ip, #8
    ffbe:	f101 000a 	add.w	r0, r1, #10
    ffc2:	4584      	cmp	ip, r0
    ffc4:	bf38      	it	cc
    ffc6:	42b5      	cmpcc	r5, r6
    ffc8:	bf2c      	ite	cs
    ffca:	2601      	movcs	r6, #1
    ffcc:	2600      	movcc	r6, #0
    ffce:	ea45 070c 	orr.w	r7, r5, ip
    ffd2:	2a80      	cmp	r2, #128	; 0x80
    ffd4:	4610      	mov	r0, r2
    ffd6:	bf28      	it	cs
    ffd8:	2080      	movcs	r0, #128	; 0x80
    ffda:	f017 0f07 	tst.w	r7, #7
    ffde:	bf18      	it	ne
    ffe0:	2600      	movne	r6, #0
    *pPayload++ = Len; 
    ffe2:	7048      	strb	r0, [r1, #1]
    ffe4:	2e00      	cmp	r6, #0
    ffe6:	d057      	beq.n	10098 <SEGGER_SYSVIEW_SendModule+0x164>
    ffe8:	2a0c      	cmp	r2, #12
    ffea:	d955      	bls.n	10098 <SEGGER_SYSVIEW_SendModule+0x164>
    ffec:	2a00      	cmp	r2, #0
    ffee:	bf14      	ite	ne
    fff0:	4680      	movne	r8, r0
    fff2:	f04f 0801 	moveq.w	r8, #1
    fff6:	ea4f 0ad8 	mov.w	sl, r8, lsr #3
    fffa:	1c6a      	adds	r2, r5, #1
    fffc:	f1ac 0908 	sub.w	r9, ip, #8
   10000:	46ae      	mov	lr, r5
    *pPayload++ = *pText++;
   10002:	e9f9 6702 	ldrd	r6, r7, [r9, #8]!
   10006:	3301      	adds	r3, #1
   10008:	4611      	mov	r1, r2
   1000a:	459a      	cmp	sl, r3
   1000c:	e8ee 6702 	strd	r6, r7, [lr], #8
   10010:	f101 0107 	add.w	r1, r1, #7
   10014:	f102 0208 	add.w	r2, r2, #8
   10018:	d8f3      	bhi.n	10002 <SEGGER_SYSVIEW_SendModule+0xce>
   1001a:	f028 0307 	bic.w	r3, r8, #7
   1001e:	4598      	cmp	r8, r3
   10020:	eb0c 0603 	add.w	r6, ip, r3
   10024:	eb05 0203 	add.w	r2, r5, r3
   10028:	d02d      	beq.n	10086 <SEGGER_SYSVIEW_SendModule+0x152>
   1002a:	f81c 1003 	ldrb.w	r1, [ip, r3]
   1002e:	54e9      	strb	r1, [r5, r3]
    n++;
   10030:	1c5d      	adds	r5, r3, #1
  while (n < Len) {
   10032:	4285      	cmp	r5, r0
    *pPayload++ = *pText++;
   10034:	f102 0101 	add.w	r1, r2, #1
  while (n < Len) {
   10038:	d225      	bcs.n	10086 <SEGGER_SYSVIEW_SendModule+0x152>
    n++;
   1003a:	1c9d      	adds	r5, r3, #2
    *pPayload++ = *pText++;
   1003c:	7871      	ldrb	r1, [r6, #1]
   1003e:	7051      	strb	r1, [r2, #1]
  while (n < Len) {
   10040:	42a8      	cmp	r0, r5
    *pPayload++ = *pText++;
   10042:	f102 0102 	add.w	r1, r2, #2
  while (n < Len) {
   10046:	d91e      	bls.n	10086 <SEGGER_SYSVIEW_SendModule+0x152>
    n++;
   10048:	1cdd      	adds	r5, r3, #3
    *pPayload++ = *pText++;
   1004a:	78b1      	ldrb	r1, [r6, #2]
   1004c:	7091      	strb	r1, [r2, #2]
  while (n < Len) {
   1004e:	42a8      	cmp	r0, r5
    *pPayload++ = *pText++;
   10050:	f102 0103 	add.w	r1, r2, #3
  while (n < Len) {
   10054:	d917      	bls.n	10086 <SEGGER_SYSVIEW_SendModule+0x152>
    n++;
   10056:	1d1d      	adds	r5, r3, #4
    *pPayload++ = *pText++;
   10058:	78f1      	ldrb	r1, [r6, #3]
   1005a:	70d1      	strb	r1, [r2, #3]
  while (n < Len) {
   1005c:	42a8      	cmp	r0, r5
    *pPayload++ = *pText++;
   1005e:	f102 0104 	add.w	r1, r2, #4
  while (n < Len) {
   10062:	d910      	bls.n	10086 <SEGGER_SYSVIEW_SendModule+0x152>
    n++;
   10064:	1d5d      	adds	r5, r3, #5
    *pPayload++ = *pText++;
   10066:	7931      	ldrb	r1, [r6, #4]
   10068:	7111      	strb	r1, [r2, #4]
  while (n < Len) {
   1006a:	42a8      	cmp	r0, r5
    *pPayload++ = *pText++;
   1006c:	f102 0105 	add.w	r1, r2, #5
  while (n < Len) {
   10070:	d909      	bls.n	10086 <SEGGER_SYSVIEW_SendModule+0x152>
    n++;
   10072:	3306      	adds	r3, #6
    *pPayload++ = *pText++;
   10074:	7971      	ldrb	r1, [r6, #5]
   10076:	7151      	strb	r1, [r2, #5]
  while (n < Len) {
   10078:	4298      	cmp	r0, r3
    *pPayload++ = *pText++;
   1007a:	f102 0106 	add.w	r1, r2, #6
  while (n < Len) {
   1007e:	d902      	bls.n	10086 <SEGGER_SYSVIEW_SendModule+0x152>
    *pPayload++ = *pText++;
   10080:	79b3      	ldrb	r3, [r6, #6]
   10082:	7193      	strb	r3, [r2, #6]
   10084:	1dd1      	adds	r1, r2, #7
      _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_MODULEDESC);
   10086:	2216      	movs	r2, #22
   10088:	4811      	ldr	r0, [pc, #68]	; (100d0 <SEGGER_SYSVIEW_SendModule+0x19c>)
   1008a:	f000 f8b1 	bl	101f0 <_SendPacket>
      RECORD_END();
   1008e:	f384 8811 	msr	BASEPRI, r4
    }
  }
}
   10092:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   10096:	4770      	bx	lr
   10098:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
    *pPayload++ = Len; 
   1009c:	4629      	mov	r1, r5
    *pPayload++ = *pText++;
   1009e:	f81c 3f01 	ldrb.w	r3, [ip, #1]!
   100a2:	f801 3b01 	strb.w	r3, [r1], #1
  while (n < Len) {
   100a6:	1b4b      	subs	r3, r1, r5
   100a8:	4298      	cmp	r0, r3
   100aa:	d8f8      	bhi.n	1009e <SEGGER_SYSVIEW_SendModule+0x16a>
   100ac:	e7eb      	b.n	10086 <SEGGER_SYSVIEW_SendModule+0x152>
    *pPayload++ = Len; 
   100ae:	704b      	strb	r3, [r1, #1]
   100b0:	4629      	mov	r1, r5
   100b2:	e7e8      	b.n	10086 <SEGGER_SYSVIEW_SendModule+0x152>
      RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
   100b4:	f3ef 8411 	mrs	r4, BASEPRI
   100b8:	f04f 0120 	mov.w	r1, #32
   100bc:	f381 8811 	msr	BASEPRI, r1
      ENCODE_U32(pPayload, ModuleId);
   100c0:	4903      	ldr	r1, [pc, #12]	; (100d0 <SEGGER_SYSVIEW_SendModule+0x19c>)
   100c2:	e75c      	b.n	ff7e <SEGGER_SYSVIEW_SendModule+0x4a>
   100c4:	4902      	ldr	r1, [pc, #8]	; (100d0 <SEGGER_SYSVIEW_SendModule+0x19c>)
   100c6:	e75a      	b.n	ff7e <SEGGER_SYSVIEW_SendModule+0x4a>
   100c8:	10014338 	.word	0x10014338
   100cc:	10014254 	.word	0x10014254
   100d0:	10014258 	.word	0x10014258

000100d4 <_HandleIncomingPacket>:
static void _HandleIncomingPacket(void) {
   100d4:	b530      	push	{r4, r5, lr}
  Status = SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
   100d6:	2201      	movs	r2, #1
static void _HandleIncomingPacket(void) {
   100d8:	b083      	sub	sp, #12
  Status = SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
   100da:	f10d 0107 	add.w	r1, sp, #7
   100de:	4610      	mov	r0, r2
   100e0:	f7ff fd50 	bl	fb84 <SEGGER_RTT_ReadNoLock>
  if (Status > 0) {
   100e4:	2800      	cmp	r0, #0
   100e6:	dd13      	ble.n	10110 <_HandleIncomingPacket+0x3c>
    switch (Cmd) {
   100e8:	f89d 3007 	ldrb.w	r3, [sp, #7]
   100ec:	2b04      	cmp	r3, #4
   100ee:	d04c      	beq.n	1018a <_HandleIncomingPacket+0xb6>
   100f0:	d910      	bls.n	10114 <_HandleIncomingPacket+0x40>
   100f2:	2b06      	cmp	r3, #6
   100f4:	d032      	beq.n	1015c <_HandleIncomingPacket+0x88>
   100f6:	d322      	bcc.n	1013e <_HandleIncomingPacket+0x6a>
   100f8:	2b07      	cmp	r3, #7
   100fa:	d023      	beq.n	10144 <_HandleIncomingPacket+0x70>
   100fc:	2b80      	cmp	r3, #128	; 0x80
   100fe:	d14d      	bne.n	1019c <_HandleIncomingPacket+0xc8>
      Status = SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
   10100:	2201      	movs	r2, #1
   10102:	f10d 0107 	add.w	r1, sp, #7
   10106:	4610      	mov	r0, r2
   10108:	f7ff fd3c 	bl	fb84 <SEGGER_RTT_ReadNoLock>
      if (Status > 0) {
   1010c:	2800      	cmp	r0, #0
   1010e:	dc51      	bgt.n	101b4 <_HandleIncomingPacket+0xe0>
}
   10110:	b003      	add	sp, #12
   10112:	bd30      	pop	{r4, r5, pc}
    switch (Cmd) {
   10114:	2b02      	cmp	r3, #2
   10116:	d005      	beq.n	10124 <_HandleIncomingPacket+0x50>
   10118:	d849      	bhi.n	101ae <_HandleIncomingPacket+0xda>
   1011a:	2b01      	cmp	r3, #1
   1011c:	d13e      	bne.n	1019c <_HandleIncomingPacket+0xc8>
      SEGGER_SYSVIEW_Start();
   1011e:	f001 fa3b 	bl	11598 <SEGGER_SYSVIEW_Start>
      break;
   10122:	e7f5      	b.n	10110 <_HandleIncomingPacket+0x3c>
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
   10124:	f3ef 8511 	mrs	r5, BASEPRI
   10128:	f04f 0120 	mov.w	r1, #32
   1012c:	f381 8811 	msr	BASEPRI, r1
  if (_SYSVIEW_Globals.EnableState) {
   10130:	4c2a      	ldr	r4, [pc, #168]	; (101dc <_HandleIncomingPacket+0x108>)
   10132:	7823      	ldrb	r3, [r4, #0]
   10134:	2b00      	cmp	r3, #0
   10136:	d142      	bne.n	101be <_HandleIncomingPacket+0xea>
  RECORD_END();
   10138:	f385 8811 	msr	BASEPRI, r5
   1013c:	e7e8      	b.n	10110 <_HandleIncomingPacket+0x3c>
      SEGGER_SYSVIEW_GetSysDesc();
   1013e:	f001 fb55 	bl	117ec <SEGGER_SYSVIEW_GetSysDesc>
      break;
   10142:	e7e5      	b.n	10110 <_HandleIncomingPacket+0x3c>
*
*/
void SEGGER_SYSVIEW_SendModuleDescription(void) {
  SEGGER_SYSVIEW_MODULE* pModule;

  if (_pFirstModule != 0) {
   10144:	4b26      	ldr	r3, [pc, #152]	; (101e0 <_HandleIncomingPacket+0x10c>)
   10146:	681c      	ldr	r4, [r3, #0]
   10148:	2c00      	cmp	r4, #0
   1014a:	d0e1      	beq.n	10110 <_HandleIncomingPacket+0x3c>
    pModule = _pFirstModule;
    do {
      if (pModule->pfSendModuleDesc) {
   1014c:	68e3      	ldr	r3, [r4, #12]
   1014e:	2b00      	cmp	r3, #0
   10150:	d03d      	beq.n	101ce <_HandleIncomingPacket+0xfa>
        pModule->pfSendModuleDesc();
   10152:	4798      	blx	r3
      }
      pModule = pModule->pNext;
   10154:	6924      	ldr	r4, [r4, #16]
    } while (pModule);
   10156:	2c00      	cmp	r4, #0
   10158:	d1f8      	bne.n	1014c <_HandleIncomingPacket+0x78>
   1015a:	e7d9      	b.n	10110 <_HandleIncomingPacket+0x3c>
*    Send the number of registered modules to the host.
*/
void SEGGER_SYSVIEW_SendNumModules(void) {
  U8* pPayload;
  U8* pPayloadStart;
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2*SEGGER_SYSVIEW_QUANTA_U32);
   1015c:	f3ef 8411 	mrs	r4, BASEPRI
   10160:	f04f 0120 	mov.w	r1, #32
   10164:	f381 8811 	msr	BASEPRI, r1
  pPayload = pPayloadStart;
  ENCODE_U32(pPayload, _NumModules);
   10168:	4b1e      	ldr	r3, [pc, #120]	; (101e4 <_HandleIncomingPacket+0x110>)
   1016a:	781b      	ldrb	r3, [r3, #0]
   1016c:	2b7f      	cmp	r3, #127	; 0x7f
   1016e:	d932      	bls.n	101d6 <_HandleIncomingPacket+0x102>
   10170:	491d      	ldr	r1, [pc, #116]	; (101e8 <_HandleIncomingPacket+0x114>)
   10172:	710b      	strb	r3, [r1, #4]
   10174:	3105      	adds	r1, #5
   10176:	2301      	movs	r3, #1
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_NUMMODULES);
   10178:	481c      	ldr	r0, [pc, #112]	; (101ec <_HandleIncomingPacket+0x118>)
  ENCODE_U32(pPayload, _NumModules);
   1017a:	f801 3b01 	strb.w	r3, [r1], #1
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_NUMMODULES);
   1017e:	221b      	movs	r2, #27
   10180:	f000 f836 	bl	101f0 <_SendPacket>
  RECORD_END();
   10184:	f384 8811 	msr	BASEPRI, r4
   10188:	e7c2      	b.n	10110 <_HandleIncomingPacket+0x3c>
  if (_SYSVIEW_Globals.pOSAPI && _SYSVIEW_Globals.pOSAPI->pfSendTaskList) {
   1018a:	4b14      	ldr	r3, [pc, #80]	; (101dc <_HandleIncomingPacket+0x108>)
   1018c:	6a1b      	ldr	r3, [r3, #32]
   1018e:	2b00      	cmp	r3, #0
   10190:	d0be      	beq.n	10110 <_HandleIncomingPacket+0x3c>
   10192:	685b      	ldr	r3, [r3, #4]
   10194:	2b00      	cmp	r3, #0
   10196:	d0bb      	beq.n	10110 <_HandleIncomingPacket+0x3c>
    _SYSVIEW_Globals.pOSAPI->pfSendTaskList();
   10198:	4798      	blx	r3
   1019a:	e7b9      	b.n	10110 <_HandleIncomingPacket+0x3c>
      if (Cmd >= 128) { // Unknown extended command. Dummy read its parameter.
   1019c:	061b      	lsls	r3, r3, #24
   1019e:	d5b7      	bpl.n	10110 <_HandleIncomingPacket+0x3c>
        SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
   101a0:	2201      	movs	r2, #1
   101a2:	f10d 0107 	add.w	r1, sp, #7
   101a6:	4610      	mov	r0, r2
   101a8:	f7ff fcec 	bl	fb84 <SEGGER_RTT_ReadNoLock>
}
   101ac:	e7b0      	b.n	10110 <_HandleIncomingPacket+0x3c>
      SEGGER_SYSVIEW_RecordSystime();
   101ae:	f001 f92f 	bl	11410 <SEGGER_SYSVIEW_RecordSystime>
      break;
   101b2:	e7ad      	b.n	10110 <_HandleIncomingPacket+0x3c>
        SEGGER_SYSVIEW_SendModule(Cmd);
   101b4:	f89d 0007 	ldrb.w	r0, [sp, #7]
   101b8:	f7ff febc 	bl	ff34 <SEGGER_SYSVIEW_SendModule>
   101bc:	e7a8      	b.n	10110 <_HandleIncomingPacket+0x3c>
    _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_TRACE_STOP);
   101be:	490b      	ldr	r1, [pc, #44]	; (101ec <_HandleIncomingPacket+0x118>)
   101c0:	220b      	movs	r2, #11
   101c2:	4608      	mov	r0, r1
   101c4:	f000 f814 	bl	101f0 <_SendPacket>
    _SYSVIEW_Globals.EnableState = 0;
   101c8:	2300      	movs	r3, #0
   101ca:	7023      	strb	r3, [r4, #0]
   101cc:	e7b4      	b.n	10138 <_HandleIncomingPacket+0x64>
      pModule = pModule->pNext;
   101ce:	6924      	ldr	r4, [r4, #16]
    } while (pModule);
   101d0:	2c00      	cmp	r4, #0
   101d2:	d1bb      	bne.n	1014c <_HandleIncomingPacket+0x78>
   101d4:	e79c      	b.n	10110 <_HandleIncomingPacket+0x3c>
  ENCODE_U32(pPayload, _NumModules);
   101d6:	4905      	ldr	r1, [pc, #20]	; (101ec <_HandleIncomingPacket+0x118>)
   101d8:	e7ce      	b.n	10178 <_HandleIncomingPacket+0xa4>
   101da:	bf00      	nop
   101dc:	1001322c 	.word	0x1001322c
   101e0:	10014338 	.word	0x10014338
   101e4:	10013228 	.word	0x10013228
   101e8:	10014254 	.word	0x10014254
   101ec:	10014258 	.word	0x10014258

000101f0 <_SendPacket>:
static void _SendPacket(U8* pStartPacket, U8* pEndPacket, unsigned int EventId) {
   101f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   101f4:	4d52      	ldr	r5, [pc, #328]	; (10340 <_SendPacket+0x150>)
   101f6:	782b      	ldrb	r3, [r5, #0]
   101f8:	2b01      	cmp	r3, #1
static void _SendPacket(U8* pStartPacket, U8* pEndPacket, unsigned int EventId) {
   101fa:	b084      	sub	sp, #16
   101fc:	4606      	mov	r6, r0
   101fe:	460c      	mov	r4, r1
   10200:	4617      	mov	r7, r2
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   10202:	d00f      	beq.n	10224 <_SendPacket+0x34>
  if (_SYSVIEW_Globals.EnableState == 0) {
   10204:	b963      	cbnz	r3, 10220 <_SendPacket+0x30>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   10206:	4b4f      	ldr	r3, [pc, #316]	; (10344 <_SendPacket+0x154>)
   10208:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   1020c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   10210:	429a      	cmp	r2, r3
   10212:	d002      	beq.n	1021a <_SendPacket+0x2a>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   10214:	78ac      	ldrb	r4, [r5, #2]
   10216:	2c00      	cmp	r4, #0
   10218:	d03c      	beq.n	10294 <_SendPacket+0xa4>
}
   1021a:	b004      	add	sp, #16
   1021c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   10220:	2b02      	cmp	r3, #2
   10222:	d04f      	beq.n	102c4 <_SendPacket+0xd4>
  if (EventId < 32) {
   10224:	2f1f      	cmp	r7, #31
   10226:	d913      	bls.n	10250 <_SendPacket+0x60>
   10228:	b2fb      	uxtb	r3, r7
    NumBytes = pEndPacket - pStartPacket;
   1022a:	1ba2      	subs	r2, r4, r6
    if (NumBytes > 127) {
   1022c:	2a7f      	cmp	r2, #127	; 0x7f
   1022e:	b2d1      	uxtb	r1, r2
   10230:	d838      	bhi.n	102a4 <_SendPacket+0xb4>
    if (EventId > 127) {
   10232:	2f7f      	cmp	r7, #127	; 0x7f
      *--pStartPacket = NumBytes;
   10234:	f106 32ff 	add.w	r2, r6, #4294967295	; 0xffffffff
   10238:	f806 1c01 	strb.w	r1, [r6, #-1]
    if (EventId > 127) {
   1023c:	d93e      	bls.n	102bc <_SendPacket+0xcc>
      *--pStartPacket = (EventId >> 7);
   1023e:	09ff      	lsrs	r7, r7, #7
      *--pStartPacket = EventId | 0x80;
   10240:	f063 037f 	orn	r3, r3, #127	; 0x7f
      *--pStartPacket = (EventId >> 7);
   10244:	f802 7c01 	strb.w	r7, [r2, #-1]
      *--pStartPacket = EventId | 0x80;
   10248:	f802 3c02 	strb.w	r3, [r2, #-2]
   1024c:	3a02      	subs	r2, #2
   1024e:	e009      	b.n	10264 <_SendPacket+0x74>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   10250:	69eb      	ldr	r3, [r5, #28]
   10252:	40fb      	lsrs	r3, r7
   10254:	07db      	lsls	r3, r3, #31
   10256:	d4d6      	bmi.n	10206 <_SendPacket+0x16>
  if (EventId < 24) {
   10258:	2f17      	cmp	r7, #23
   1025a:	b2fb      	uxtb	r3, r7
   1025c:	d8e5      	bhi.n	1022a <_SendPacket+0x3a>
    *--pStartPacket = EventId;
   1025e:	f806 3c01 	strb.w	r3, [r6, #-1]
   10262:	1e72      	subs	r2, r6, #1
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10264:	4938      	ldr	r1, [pc, #224]	; (10348 <_SendPacket+0x158>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   10266:	68eb      	ldr	r3, [r5, #12]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10268:	680e      	ldr	r6, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   1026a:	1af3      	subs	r3, r6, r3
  ENCODE_U32(pEndPacket, Delta);
   1026c:	2b7f      	cmp	r3, #127	; 0x7f
   1026e:	d906      	bls.n	1027e <_SendPacket+0x8e>
   10270:	f063 017f 	orn	r1, r3, #127	; 0x7f
   10274:	09db      	lsrs	r3, r3, #7
   10276:	2b7f      	cmp	r3, #127	; 0x7f
   10278:	f804 1b01 	strb.w	r1, [r4], #1
   1027c:	d8f8      	bhi.n	10270 <_SendPacket+0x80>
   1027e:	f804 3b01 	strb.w	r3, [r4], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   10282:	4611      	mov	r1, r2
   10284:	2001      	movs	r0, #1
   10286:	1aa2      	subs	r2, r4, r2
   10288:	f7ff fcfc 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   1028c:	2800      	cmp	r0, #0
   1028e:	d04c      	beq.n	1032a <_SendPacket+0x13a>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   10290:	60ee      	str	r6, [r5, #12]
   10292:	e7b8      	b.n	10206 <_SendPacket+0x16>
      _SYSVIEW_Globals.RecursionCnt = 1;
   10294:	2301      	movs	r3, #1
   10296:	70ab      	strb	r3, [r5, #2]
      _HandleIncomingPacket();
   10298:	f7ff ff1c 	bl	100d4 <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   1029c:	70ac      	strb	r4, [r5, #2]
}
   1029e:	b004      	add	sp, #16
   102a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      *--pStartPacket = NumBytes | 0x80;
   102a4:	f061 017f 	orn	r1, r1, #127	; 0x7f
   102a8:	f806 1c02 	strb.w	r1, [r6, #-2]
    if (EventId > 127) {
   102ac:	2f7f      	cmp	r7, #127	; 0x7f
      *--pStartPacket = (NumBytes >> 7);
   102ae:	f3c2 11c7 	ubfx	r1, r2, #7, #8
   102b2:	f806 1c01 	strb.w	r1, [r6, #-1]
      *--pStartPacket = NumBytes | 0x80;
   102b6:	f1a6 0202 	sub.w	r2, r6, #2
    if (EventId > 127) {
   102ba:	d8c0      	bhi.n	1023e <_SendPacket+0x4e>
      *--pStartPacket = EventId;
   102bc:	f802 3c01 	strb.w	r3, [r2, #-1]
   102c0:	3a01      	subs	r2, #1
   102c2:	e7cf      	b.n	10264 <_SendPacket+0x74>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   102c4:	696a      	ldr	r2, [r5, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   102c6:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   102c8:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   102ca:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   102ce:	f10d 0305 	add.w	r3, sp, #5
   102d2:	d906      	bls.n	102e2 <_SendPacket+0xf2>
   102d4:	f062 017f 	orn	r1, r2, #127	; 0x7f
   102d8:	09d2      	lsrs	r2, r2, #7
   102da:	2a7f      	cmp	r2, #127	; 0x7f
   102dc:	f803 1b01 	strb.w	r1, [r3], #1
   102e0:	d8f8      	bhi.n	102d4 <_SendPacket+0xe4>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   102e2:	4919      	ldr	r1, [pc, #100]	; (10348 <_SendPacket+0x158>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   102e4:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   102e6:	f8d1 8000 	ldr.w	r8, [r1]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   102ea:	68e9      	ldr	r1, [r5, #12]
   102ec:	eba8 0101 	sub.w	r1, r8, r1
  ENCODE_U32(pPayload, Delta);
   102f0:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   102f2:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   102f6:	d906      	bls.n	10306 <_SendPacket+0x116>
   102f8:	f061 037f 	orn	r3, r1, #127	; 0x7f
   102fc:	09c9      	lsrs	r1, r1, #7
   102fe:	297f      	cmp	r1, #127	; 0x7f
   10300:	f802 3b01 	strb.w	r3, [r2], #1
   10304:	d8f8      	bhi.n	102f8 <_SendPacket+0x108>
   10306:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   10308:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   1030a:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   1030e:	2001      	movs	r0, #1
   10310:	4611      	mov	r1, r2
   10312:	1a9a      	subs	r2, r3, r2
   10314:	f7ff fcb6 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   10318:	b958      	cbnz	r0, 10332 <_SendPacket+0x142>
    _SYSVIEW_Globals.DropCount++;
   1031a:	696a      	ldr	r2, [r5, #20]
   1031c:	782b      	ldrb	r3, [r5, #0]
   1031e:	3201      	adds	r2, #1
   10320:	616a      	str	r2, [r5, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   10322:	2b01      	cmp	r3, #1
   10324:	f47f af6f 	bne.w	10206 <_SendPacket+0x16>
   10328:	e77c      	b.n	10224 <_SendPacket+0x34>
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   1032a:	782b      	ldrb	r3, [r5, #0]
   1032c:	3301      	adds	r3, #1
   1032e:	702b      	strb	r3, [r5, #0]
   10330:	e769      	b.n	10206 <_SendPacket+0x16>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   10332:	782b      	ldrb	r3, [r5, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   10334:	f8c5 800c 	str.w	r8, [r5, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   10338:	3b01      	subs	r3, #1
   1033a:	b2db      	uxtb	r3, r3
   1033c:	702b      	strb	r3, [r5, #0]
   1033e:	e7f0      	b.n	10322 <_SendPacket+0x132>
   10340:	1001322c 	.word	0x1001322c
   10344:	10014404 	.word	0x10014404
   10348:	e0001004 	.word	0xe0001004

0001034c <SEGGER_SYSVIEW_SendTaskInfo>:
void SEGGER_SYSVIEW_SendTaskInfo(const SEGGER_SYSVIEW_TASKINFO *pInfo) {
   1034c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10350:	4605      	mov	r5, r0
   10352:	b083      	sub	sp, #12
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32 + 1 + 32);
   10354:	f3ef 8311 	mrs	r3, BASEPRI
   10358:	f04f 0120 	mov.w	r1, #32
   1035c:	f381 8811 	msr	BASEPRI, r1
  ENCODE_U32(pPayload, SHRINK_ID(pInfo->TaskID));
   10360:	f8df 81c8 	ldr.w	r8, [pc, #456]	; 1052c <SEGGER_SYSVIEW_SendTaskInfo+0x1e0>
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32 + 1 + 32);
   10364:	9300      	str	r3, [sp, #0]
  ENCODE_U32(pPayload, SHRINK_ID(pInfo->TaskID));
   10366:	f8d8 2010 	ldr.w	r2, [r8, #16]
   1036a:	6803      	ldr	r3, [r0, #0]
   1036c:	4c6e      	ldr	r4, [pc, #440]	; (10528 <SEGGER_SYSVIEW_SendTaskInfo+0x1dc>)
   1036e:	1a9b      	subs	r3, r3, r2
   10370:	089b      	lsrs	r3, r3, #2
   10372:	2b7f      	cmp	r3, #127	; 0x7f
   10374:	4622      	mov	r2, r4
   10376:	d906      	bls.n	10386 <SEGGER_SYSVIEW_SendTaskInfo+0x3a>
   10378:	f063 017f 	orn	r1, r3, #127	; 0x7f
   1037c:	09db      	lsrs	r3, r3, #7
   1037e:	2b7f      	cmp	r3, #127	; 0x7f
   10380:	f802 1b01 	strb.w	r1, [r2], #1
   10384:	d8f8      	bhi.n	10378 <SEGGER_SYSVIEW_SendTaskInfo+0x2c>
   10386:	7013      	strb	r3, [r2, #0]
  ENCODE_U32(pPayload, pInfo->Prio);
   10388:	68ab      	ldr	r3, [r5, #8]
   1038a:	2b7f      	cmp	r3, #127	; 0x7f
  ENCODE_U32(pPayload, SHRINK_ID(pInfo->TaskID));
   1038c:	f102 0201 	add.w	r2, r2, #1
  ENCODE_U32(pPayload, pInfo->Prio);
   10390:	d906      	bls.n	103a0 <SEGGER_SYSVIEW_SendTaskInfo+0x54>
   10392:	f063 017f 	orn	r1, r3, #127	; 0x7f
   10396:	09db      	lsrs	r3, r3, #7
   10398:	2b7f      	cmp	r3, #127	; 0x7f
   1039a:	f802 1b01 	strb.w	r1, [r2], #1
   1039e:	d8f8      	bhi.n	10392 <SEGGER_SYSVIEW_SendTaskInfo+0x46>
   103a0:	4694      	mov	ip, r2
   103a2:	f80c 3b02 	strb.w	r3, [ip], #2
  pPayload = _EncodeStr(pPayload, pInfo->sName, 32);
   103a6:	6868      	ldr	r0, [r5, #4]
  while(*(pText + Len) != 0) {
   103a8:	7803      	ldrb	r3, [r0, #0]
   103aa:	2b00      	cmp	r3, #0
   103ac:	f000 80b8 	beq.w	10520 <SEGGER_SYSVIEW_SendTaskInfo+0x1d4>
   103b0:	4606      	mov	r6, r0
  Len = 0;
   103b2:	2100      	movs	r1, #0
  while(*(pText + Len) != 0) {
   103b4:	f816 3f01 	ldrb.w	r3, [r6, #1]!
    Len++;
   103b8:	3101      	adds	r1, #1
  while(*(pText + Len) != 0) {
   103ba:	2b00      	cmp	r3, #0
   103bc:	d1fa      	bne.n	103b4 <SEGGER_SYSVIEW_SendTaskInfo+0x68>
   103be:	f100 0608 	add.w	r6, r0, #8
   103c2:	f102 0e0a 	add.w	lr, r2, #10
   103c6:	4570      	cmp	r0, lr
   103c8:	bf38      	it	cc
   103ca:	45b4      	cmpcc	ip, r6
   103cc:	bf2c      	ite	cs
   103ce:	2601      	movcs	r6, #1
   103d0:	2600      	movcc	r6, #0
   103d2:	ea4c 0700 	orr.w	r7, ip, r0
   103d6:	2920      	cmp	r1, #32
   103d8:	468a      	mov	sl, r1
   103da:	bf28      	it	cs
   103dc:	f04f 0a20 	movcs.w	sl, #32
   103e0:	f017 0f07 	tst.w	r7, #7
   103e4:	bf18      	it	ne
   103e6:	2600      	movne	r6, #0
    *pPayload++ = Len; 
   103e8:	f882 a001 	strb.w	sl, [r2, #1]
   103ec:	2e00      	cmp	r6, #0
   103ee:	f000 808c 	beq.w	1050a <SEGGER_SYSVIEW_SendTaskInfo+0x1be>
   103f2:	290c      	cmp	r1, #12
   103f4:	f240 8089 	bls.w	1050a <SEGGER_SYSVIEW_SendTaskInfo+0x1be>
   103f8:	2900      	cmp	r1, #0
   103fa:	bf14      	ite	ne
   103fc:	4652      	movne	r2, sl
   103fe:	2201      	moveq	r2, #1
   10400:	9201      	str	r2, [sp, #4]
   10402:	ea4f 0bd2 	mov.w	fp, r2, lsr #3
   10406:	f1a0 0908 	sub.w	r9, r0, #8
   1040a:	f10c 0201 	add.w	r2, ip, #1
   1040e:	46e6      	mov	lr, ip
    *pPayload++ = *pText++;
   10410:	e9f9 6702 	ldrd	r6, r7, [r9, #8]!
   10414:	3301      	adds	r3, #1
   10416:	4611      	mov	r1, r2
   10418:	459b      	cmp	fp, r3
   1041a:	e8ee 6702 	strd	r6, r7, [lr], #8
   1041e:	f101 0107 	add.w	r1, r1, #7
   10422:	f102 0208 	add.w	r2, r2, #8
   10426:	d8f3      	bhi.n	10410 <SEGGER_SYSVIEW_SendTaskInfo+0xc4>
   10428:	9f01      	ldr	r7, [sp, #4]
   1042a:	f027 0307 	bic.w	r3, r7, #7
   1042e:	429f      	cmp	r7, r3
   10430:	eb00 0603 	add.w	r6, r0, r3
   10434:	eb0c 0203 	add.w	r2, ip, r3
   10438:	d02d      	beq.n	10496 <SEGGER_SYSVIEW_SendTaskInfo+0x14a>
   1043a:	5cc1      	ldrb	r1, [r0, r3]
   1043c:	f80c 1003 	strb.w	r1, [ip, r3]
    n++;
   10440:	1c58      	adds	r0, r3, #1
  while (n < Len) {
   10442:	4550      	cmp	r0, sl
    *pPayload++ = *pText++;
   10444:	f102 0101 	add.w	r1, r2, #1
  while (n < Len) {
   10448:	d225      	bcs.n	10496 <SEGGER_SYSVIEW_SendTaskInfo+0x14a>
    n++;
   1044a:	1c98      	adds	r0, r3, #2
    *pPayload++ = *pText++;
   1044c:	7871      	ldrb	r1, [r6, #1]
   1044e:	7051      	strb	r1, [r2, #1]
  while (n < Len) {
   10450:	4582      	cmp	sl, r0
    *pPayload++ = *pText++;
   10452:	f102 0102 	add.w	r1, r2, #2
  while (n < Len) {
   10456:	d91e      	bls.n	10496 <SEGGER_SYSVIEW_SendTaskInfo+0x14a>
    n++;
   10458:	1cd8      	adds	r0, r3, #3
    *pPayload++ = *pText++;
   1045a:	78b1      	ldrb	r1, [r6, #2]
   1045c:	7091      	strb	r1, [r2, #2]
  while (n < Len) {
   1045e:	4582      	cmp	sl, r0
    *pPayload++ = *pText++;
   10460:	f102 0103 	add.w	r1, r2, #3
  while (n < Len) {
   10464:	d917      	bls.n	10496 <SEGGER_SYSVIEW_SendTaskInfo+0x14a>
    n++;
   10466:	1d18      	adds	r0, r3, #4
    *pPayload++ = *pText++;
   10468:	78f1      	ldrb	r1, [r6, #3]
   1046a:	70d1      	strb	r1, [r2, #3]
  while (n < Len) {
   1046c:	4582      	cmp	sl, r0
    *pPayload++ = *pText++;
   1046e:	f102 0104 	add.w	r1, r2, #4
  while (n < Len) {
   10472:	d910      	bls.n	10496 <SEGGER_SYSVIEW_SendTaskInfo+0x14a>
    n++;
   10474:	1d58      	adds	r0, r3, #5
    *pPayload++ = *pText++;
   10476:	7931      	ldrb	r1, [r6, #4]
   10478:	7111      	strb	r1, [r2, #4]
  while (n < Len) {
   1047a:	4582      	cmp	sl, r0
    *pPayload++ = *pText++;
   1047c:	f102 0105 	add.w	r1, r2, #5
  while (n < Len) {
   10480:	d909      	bls.n	10496 <SEGGER_SYSVIEW_SendTaskInfo+0x14a>
    n++;
   10482:	3306      	adds	r3, #6
    *pPayload++ = *pText++;
   10484:	7971      	ldrb	r1, [r6, #5]
   10486:	7151      	strb	r1, [r2, #5]
  while (n < Len) {
   10488:	459a      	cmp	sl, r3
    *pPayload++ = *pText++;
   1048a:	f102 0106 	add.w	r1, r2, #6
  while (n < Len) {
   1048e:	d902      	bls.n	10496 <SEGGER_SYSVIEW_SendTaskInfo+0x14a>
    *pPayload++ = *pText++;
   10490:	79b3      	ldrb	r3, [r6, #6]
   10492:	7193      	strb	r3, [r2, #6]
   10494:	1dd1      	adds	r1, r2, #7
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_INFO);
   10496:	2209      	movs	r2, #9
   10498:	4823      	ldr	r0, [pc, #140]	; (10528 <SEGGER_SYSVIEW_SendTaskInfo+0x1dc>)
   1049a:	f7ff fea9 	bl	101f0 <_SendPacket>
  ENCODE_U32(pPayload, SHRINK_ID(pInfo->TaskID));
   1049e:	f8d8 2010 	ldr.w	r2, [r8, #16]
   104a2:	682b      	ldr	r3, [r5, #0]
   104a4:	1a9b      	subs	r3, r3, r2
   104a6:	089b      	lsrs	r3, r3, #2
   104a8:	2b7f      	cmp	r3, #127	; 0x7f
   104aa:	d906      	bls.n	104ba <SEGGER_SYSVIEW_SendTaskInfo+0x16e>
   104ac:	f063 027f 	orn	r2, r3, #127	; 0x7f
   104b0:	09db      	lsrs	r3, r3, #7
   104b2:	2b7f      	cmp	r3, #127	; 0x7f
   104b4:	f804 2b01 	strb.w	r2, [r4], #1
   104b8:	d8f8      	bhi.n	104ac <SEGGER_SYSVIEW_SendTaskInfo+0x160>
   104ba:	7023      	strb	r3, [r4, #0]
  ENCODE_U32(pPayload, pInfo->StackBase);
   104bc:	68eb      	ldr	r3, [r5, #12]
   104be:	2b7f      	cmp	r3, #127	; 0x7f
  ENCODE_U32(pPayload, SHRINK_ID(pInfo->TaskID));
   104c0:	f104 0401 	add.w	r4, r4, #1
  ENCODE_U32(pPayload, pInfo->StackBase);
   104c4:	d906      	bls.n	104d4 <SEGGER_SYSVIEW_SendTaskInfo+0x188>
   104c6:	f063 027f 	orn	r2, r3, #127	; 0x7f
   104ca:	09db      	lsrs	r3, r3, #7
   104cc:	2b7f      	cmp	r3, #127	; 0x7f
   104ce:	f804 2b01 	strb.w	r2, [r4], #1
   104d2:	d8f8      	bhi.n	104c6 <SEGGER_SYSVIEW_SendTaskInfo+0x17a>
   104d4:	7023      	strb	r3, [r4, #0]
  ENCODE_U32(pPayload, pInfo->StackSize);
   104d6:	692b      	ldr	r3, [r5, #16]
   104d8:	2b7f      	cmp	r3, #127	; 0x7f
  ENCODE_U32(pPayload, pInfo->StackBase);
   104da:	f104 0401 	add.w	r4, r4, #1
  ENCODE_U32(pPayload, pInfo->StackSize);
   104de:	d906      	bls.n	104ee <SEGGER_SYSVIEW_SendTaskInfo+0x1a2>
   104e0:	f063 027f 	orn	r2, r3, #127	; 0x7f
   104e4:	09db      	lsrs	r3, r3, #7
   104e6:	2b7f      	cmp	r3, #127	; 0x7f
   104e8:	f804 2b01 	strb.w	r2, [r4], #1
   104ec:	d8f8      	bhi.n	104e0 <SEGGER_SYSVIEW_SendTaskInfo+0x194>
  ENCODE_U32(pPayload, 0); // Stack End, future use
   104ee:	2500      	movs	r5, #0
  ENCODE_U32(pPayload, pInfo->StackSize);
   104f0:	7023      	strb	r3, [r4, #0]
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_STACK_INFO);
   104f2:	1ca1      	adds	r1, r4, #2
   104f4:	2215      	movs	r2, #21
   104f6:	480c      	ldr	r0, [pc, #48]	; (10528 <SEGGER_SYSVIEW_SendTaskInfo+0x1dc>)
  ENCODE_U32(pPayload, 0); // Stack End, future use
   104f8:	7065      	strb	r5, [r4, #1]
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_STACK_INFO);
   104fa:	f7ff fe79 	bl	101f0 <_SendPacket>
  RECORD_END();
   104fe:	9b00      	ldr	r3, [sp, #0]
   10500:	f383 8811 	msr	BASEPRI, r3
}
   10504:	b003      	add	sp, #12
   10506:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1050a:	3801      	subs	r0, #1
    *pPayload++ = Len; 
   1050c:	4661      	mov	r1, ip
    *pPayload++ = *pText++;
   1050e:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   10512:	f801 3b01 	strb.w	r3, [r1], #1
  while (n < Len) {
   10516:	eba1 030c 	sub.w	r3, r1, ip
   1051a:	459a      	cmp	sl, r3
   1051c:	d8f7      	bhi.n	1050e <SEGGER_SYSVIEW_SendTaskInfo+0x1c2>
   1051e:	e7ba      	b.n	10496 <SEGGER_SYSVIEW_SendTaskInfo+0x14a>
    *pPayload++ = Len; 
   10520:	7053      	strb	r3, [r2, #1]
   10522:	4661      	mov	r1, ip
   10524:	e7b7      	b.n	10496 <SEGGER_SYSVIEW_SendTaskInfo+0x14a>
   10526:	bf00      	nop
   10528:	10014258 	.word	0x10014258
   1052c:	1001322c 	.word	0x1001322c

00010530 <SEGGER_SYSVIEW_RecordExitISR>:
void SEGGER_SYSVIEW_RecordExitISR(void) {
   10530:	b570      	push	{r4, r5, r6, lr}
   10532:	b084      	sub	sp, #16
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
   10534:	f3ef 8511 	mrs	r5, BASEPRI
   10538:	f04f 0120 	mov.w	r1, #32
   1053c:	f381 8811 	msr	BASEPRI, r1
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   10540:	4c3b      	ldr	r4, [pc, #236]	; (10630 <SEGGER_SYSVIEW_RecordExitISR+0x100>)
   10542:	7823      	ldrb	r3, [r4, #0]
   10544:	2b01      	cmp	r3, #1
   10546:	d00f      	beq.n	10568 <SEGGER_SYSVIEW_RecordExitISR+0x38>
  if (_SYSVIEW_Globals.EnableState == 0) {
   10548:	b963      	cbnz	r3, 10564 <SEGGER_SYSVIEW_RecordExitISR+0x34>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   1054a:	4b3a      	ldr	r3, [pc, #232]	; (10634 <SEGGER_SYSVIEW_RecordExitISR+0x104>)
   1054c:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   10550:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   10554:	429a      	cmp	r2, r3
   10556:	d001      	beq.n	1055c <SEGGER_SYSVIEW_RecordExitISR+0x2c>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   10558:	78a6      	ldrb	r6, [r4, #2]
   1055a:	b32e      	cbz	r6, 105a8 <SEGGER_SYSVIEW_RecordExitISR+0x78>
  RECORD_END();
   1055c:	f385 8811 	msr	BASEPRI, r5
}
   10560:	b004      	add	sp, #16
   10562:	bd70      	pop	{r4, r5, r6, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   10564:	2b02      	cmp	r3, #2
   10566:	d02c      	beq.n	105c2 <SEGGER_SYSVIEW_RecordExitISR+0x92>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   10568:	69e3      	ldr	r3, [r4, #28]
   1056a:	071b      	lsls	r3, r3, #28
   1056c:	d4ed      	bmi.n	1054a <SEGGER_SYSVIEW_RecordExitISR+0x1a>
    *--pStartPacket = EventId;
   1056e:	4a32      	ldr	r2, [pc, #200]	; (10638 <SEGGER_SYSVIEW_RecordExitISR+0x108>)
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10570:	4932      	ldr	r1, [pc, #200]	; (1063c <SEGGER_SYSVIEW_RecordExitISR+0x10c>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   10572:	68e3      	ldr	r3, [r4, #12]
    *--pStartPacket = EventId;
   10574:	2003      	movs	r0, #3
   10576:	70d0      	strb	r0, [r2, #3]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10578:	680e      	ldr	r6, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   1057a:	1af3      	subs	r3, r6, r3
  ENCODE_U32(pEndPacket, Delta);
   1057c:	2b7f      	cmp	r3, #127	; 0x7f
   1057e:	f102 0204 	add.w	r2, r2, #4
   10582:	d906      	bls.n	10592 <SEGGER_SYSVIEW_RecordExitISR+0x62>
   10584:	f063 017f 	orn	r1, r3, #127	; 0x7f
   10588:	09db      	lsrs	r3, r3, #7
   1058a:	2b7f      	cmp	r3, #127	; 0x7f
   1058c:	f802 1b01 	strb.w	r1, [r2], #1
   10590:	d8f8      	bhi.n	10584 <SEGGER_SYSVIEW_RecordExitISR+0x54>
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   10592:	482b      	ldr	r0, [pc, #172]	; (10640 <SEGGER_SYSVIEW_RecordExitISR+0x110>)
  ENCODE_U32(pEndPacket, Delta);
   10594:	f802 3b01 	strb.w	r3, [r2], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   10598:	4601      	mov	r1, r0
   1059a:	1a12      	subs	r2, r2, r0
   1059c:	2001      	movs	r0, #1
   1059e:	f7ff fb71 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   105a2:	b150      	cbz	r0, 105ba <SEGGER_SYSVIEW_RecordExitISR+0x8a>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   105a4:	60e6      	str	r6, [r4, #12]
   105a6:	e7d0      	b.n	1054a <SEGGER_SYSVIEW_RecordExitISR+0x1a>
      _SYSVIEW_Globals.RecursionCnt = 1;
   105a8:	2301      	movs	r3, #1
   105aa:	70a3      	strb	r3, [r4, #2]
      _HandleIncomingPacket();
   105ac:	f7ff fd92 	bl	100d4 <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   105b0:	70a6      	strb	r6, [r4, #2]
  RECORD_END();
   105b2:	f385 8811 	msr	BASEPRI, r5
}
   105b6:	b004      	add	sp, #16
   105b8:	bd70      	pop	{r4, r5, r6, pc}
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   105ba:	7823      	ldrb	r3, [r4, #0]
   105bc:	3301      	adds	r3, #1
   105be:	7023      	strb	r3, [r4, #0]
   105c0:	e7c3      	b.n	1054a <SEGGER_SYSVIEW_RecordExitISR+0x1a>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   105c2:	6962      	ldr	r2, [r4, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   105c4:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   105c6:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   105c8:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   105cc:	f10d 0305 	add.w	r3, sp, #5
   105d0:	d906      	bls.n	105e0 <SEGGER_SYSVIEW_RecordExitISR+0xb0>
   105d2:	f062 017f 	orn	r1, r2, #127	; 0x7f
   105d6:	09d2      	lsrs	r2, r2, #7
   105d8:	2a7f      	cmp	r2, #127	; 0x7f
   105da:	f803 1b01 	strb.w	r1, [r3], #1
   105de:	d8f8      	bhi.n	105d2 <SEGGER_SYSVIEW_RecordExitISR+0xa2>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   105e0:	4916      	ldr	r1, [pc, #88]	; (1063c <SEGGER_SYSVIEW_RecordExitISR+0x10c>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   105e2:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   105e4:	680e      	ldr	r6, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   105e6:	68e1      	ldr	r1, [r4, #12]
   105e8:	1a71      	subs	r1, r6, r1
  ENCODE_U32(pPayload, Delta);
   105ea:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   105ec:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   105f0:	d906      	bls.n	10600 <SEGGER_SYSVIEW_RecordExitISR+0xd0>
   105f2:	f061 037f 	orn	r3, r1, #127	; 0x7f
   105f6:	09c9      	lsrs	r1, r1, #7
   105f8:	297f      	cmp	r1, #127	; 0x7f
   105fa:	f802 3b01 	strb.w	r3, [r2], #1
   105fe:	d8f8      	bhi.n	105f2 <SEGGER_SYSVIEW_RecordExitISR+0xc2>
   10600:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   10602:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   10604:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   10608:	2001      	movs	r0, #1
   1060a:	4611      	mov	r1, r2
   1060c:	1a9a      	subs	r2, r3, r2
   1060e:	f7ff fb39 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   10612:	b930      	cbnz	r0, 10622 <SEGGER_SYSVIEW_RecordExitISR+0xf2>
    _SYSVIEW_Globals.DropCount++;
   10614:	6962      	ldr	r2, [r4, #20]
   10616:	7823      	ldrb	r3, [r4, #0]
   10618:	3201      	adds	r2, #1
   1061a:	6162      	str	r2, [r4, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   1061c:	2b01      	cmp	r3, #1
   1061e:	d194      	bne.n	1054a <SEGGER_SYSVIEW_RecordExitISR+0x1a>
   10620:	e7a2      	b.n	10568 <SEGGER_SYSVIEW_RecordExitISR+0x38>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   10622:	7823      	ldrb	r3, [r4, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   10624:	60e6      	str	r6, [r4, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   10626:	3b01      	subs	r3, #1
   10628:	b2db      	uxtb	r3, r3
   1062a:	7023      	strb	r3, [r4, #0]
   1062c:	e7f6      	b.n	1061c <SEGGER_SYSVIEW_RecordExitISR+0xec>
   1062e:	bf00      	nop
   10630:	1001322c 	.word	0x1001322c
   10634:	10014404 	.word	0x10014404
   10638:	10014254 	.word	0x10014254
   1063c:	e0001004 	.word	0xe0001004
   10640:	10014257 	.word	0x10014257

00010644 <SEGGER_SYSVIEW_OnIdle>:
void SEGGER_SYSVIEW_OnIdle(void) {
   10644:	b570      	push	{r4, r5, r6, lr}
   10646:	b084      	sub	sp, #16
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
   10648:	f3ef 8511 	mrs	r5, BASEPRI
   1064c:	f04f 0120 	mov.w	r1, #32
   10650:	f381 8811 	msr	BASEPRI, r1
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   10654:	4c3b      	ldr	r4, [pc, #236]	; (10744 <SEGGER_SYSVIEW_OnIdle+0x100>)
   10656:	7823      	ldrb	r3, [r4, #0]
   10658:	2b01      	cmp	r3, #1
   1065a:	d00f      	beq.n	1067c <SEGGER_SYSVIEW_OnIdle+0x38>
  if (_SYSVIEW_Globals.EnableState == 0) {
   1065c:	b963      	cbnz	r3, 10678 <SEGGER_SYSVIEW_OnIdle+0x34>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   1065e:	4b3a      	ldr	r3, [pc, #232]	; (10748 <SEGGER_SYSVIEW_OnIdle+0x104>)
   10660:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   10664:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   10668:	429a      	cmp	r2, r3
   1066a:	d001      	beq.n	10670 <SEGGER_SYSVIEW_OnIdle+0x2c>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   1066c:	78a6      	ldrb	r6, [r4, #2]
   1066e:	b32e      	cbz	r6, 106bc <SEGGER_SYSVIEW_OnIdle+0x78>
  RECORD_END();
   10670:	f385 8811 	msr	BASEPRI, r5
}
   10674:	b004      	add	sp, #16
   10676:	bd70      	pop	{r4, r5, r6, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   10678:	2b02      	cmp	r3, #2
   1067a:	d02c      	beq.n	106d6 <SEGGER_SYSVIEW_OnIdle+0x92>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   1067c:	69e3      	ldr	r3, [r4, #28]
   1067e:	039b      	lsls	r3, r3, #14
   10680:	d4ed      	bmi.n	1065e <SEGGER_SYSVIEW_OnIdle+0x1a>
    *--pStartPacket = EventId;
   10682:	4a32      	ldr	r2, [pc, #200]	; (1074c <SEGGER_SYSVIEW_OnIdle+0x108>)
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10684:	4932      	ldr	r1, [pc, #200]	; (10750 <SEGGER_SYSVIEW_OnIdle+0x10c>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   10686:	68e3      	ldr	r3, [r4, #12]
    *--pStartPacket = EventId;
   10688:	2011      	movs	r0, #17
   1068a:	70d0      	strb	r0, [r2, #3]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   1068c:	680e      	ldr	r6, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   1068e:	1af3      	subs	r3, r6, r3
  ENCODE_U32(pEndPacket, Delta);
   10690:	2b7f      	cmp	r3, #127	; 0x7f
   10692:	f102 0204 	add.w	r2, r2, #4
   10696:	d906      	bls.n	106a6 <SEGGER_SYSVIEW_OnIdle+0x62>
   10698:	f063 017f 	orn	r1, r3, #127	; 0x7f
   1069c:	09db      	lsrs	r3, r3, #7
   1069e:	2b7f      	cmp	r3, #127	; 0x7f
   106a0:	f802 1b01 	strb.w	r1, [r2], #1
   106a4:	d8f8      	bhi.n	10698 <SEGGER_SYSVIEW_OnIdle+0x54>
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   106a6:	482b      	ldr	r0, [pc, #172]	; (10754 <SEGGER_SYSVIEW_OnIdle+0x110>)
  ENCODE_U32(pEndPacket, Delta);
   106a8:	f802 3b01 	strb.w	r3, [r2], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   106ac:	4601      	mov	r1, r0
   106ae:	1a12      	subs	r2, r2, r0
   106b0:	2001      	movs	r0, #1
   106b2:	f7ff fae7 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   106b6:	b150      	cbz	r0, 106ce <SEGGER_SYSVIEW_OnIdle+0x8a>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   106b8:	60e6      	str	r6, [r4, #12]
   106ba:	e7d0      	b.n	1065e <SEGGER_SYSVIEW_OnIdle+0x1a>
      _SYSVIEW_Globals.RecursionCnt = 1;
   106bc:	2301      	movs	r3, #1
   106be:	70a3      	strb	r3, [r4, #2]
      _HandleIncomingPacket();
   106c0:	f7ff fd08 	bl	100d4 <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   106c4:	70a6      	strb	r6, [r4, #2]
  RECORD_END();
   106c6:	f385 8811 	msr	BASEPRI, r5
}
   106ca:	b004      	add	sp, #16
   106cc:	bd70      	pop	{r4, r5, r6, pc}
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   106ce:	7823      	ldrb	r3, [r4, #0]
   106d0:	3301      	adds	r3, #1
   106d2:	7023      	strb	r3, [r4, #0]
   106d4:	e7c3      	b.n	1065e <SEGGER_SYSVIEW_OnIdle+0x1a>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   106d6:	6962      	ldr	r2, [r4, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   106d8:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   106da:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   106dc:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   106e0:	f10d 0305 	add.w	r3, sp, #5
   106e4:	d906      	bls.n	106f4 <SEGGER_SYSVIEW_OnIdle+0xb0>
   106e6:	f062 017f 	orn	r1, r2, #127	; 0x7f
   106ea:	09d2      	lsrs	r2, r2, #7
   106ec:	2a7f      	cmp	r2, #127	; 0x7f
   106ee:	f803 1b01 	strb.w	r1, [r3], #1
   106f2:	d8f8      	bhi.n	106e6 <SEGGER_SYSVIEW_OnIdle+0xa2>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   106f4:	4916      	ldr	r1, [pc, #88]	; (10750 <SEGGER_SYSVIEW_OnIdle+0x10c>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   106f6:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   106f8:	680e      	ldr	r6, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   106fa:	68e1      	ldr	r1, [r4, #12]
   106fc:	1a71      	subs	r1, r6, r1
  ENCODE_U32(pPayload, Delta);
   106fe:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10700:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   10704:	d906      	bls.n	10714 <SEGGER_SYSVIEW_OnIdle+0xd0>
   10706:	f061 037f 	orn	r3, r1, #127	; 0x7f
   1070a:	09c9      	lsrs	r1, r1, #7
   1070c:	297f      	cmp	r1, #127	; 0x7f
   1070e:	f802 3b01 	strb.w	r3, [r2], #1
   10712:	d8f8      	bhi.n	10706 <SEGGER_SYSVIEW_OnIdle+0xc2>
   10714:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   10716:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   10718:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   1071c:	2001      	movs	r0, #1
   1071e:	4611      	mov	r1, r2
   10720:	1a9a      	subs	r2, r3, r2
   10722:	f7ff faaf 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   10726:	b930      	cbnz	r0, 10736 <SEGGER_SYSVIEW_OnIdle+0xf2>
    _SYSVIEW_Globals.DropCount++;
   10728:	6962      	ldr	r2, [r4, #20]
   1072a:	7823      	ldrb	r3, [r4, #0]
   1072c:	3201      	adds	r2, #1
   1072e:	6162      	str	r2, [r4, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   10730:	2b01      	cmp	r3, #1
   10732:	d194      	bne.n	1065e <SEGGER_SYSVIEW_OnIdle+0x1a>
   10734:	e7a2      	b.n	1067c <SEGGER_SYSVIEW_OnIdle+0x38>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   10736:	7823      	ldrb	r3, [r4, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   10738:	60e6      	str	r6, [r4, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   1073a:	3b01      	subs	r3, #1
   1073c:	b2db      	uxtb	r3, r3
   1073e:	7023      	strb	r3, [r4, #0]
   10740:	e7f6      	b.n	10730 <SEGGER_SYSVIEW_OnIdle+0xec>
   10742:	bf00      	nop
   10744:	1001322c 	.word	0x1001322c
   10748:	10014404 	.word	0x10014404
   1074c:	10014254 	.word	0x10014254
   10750:	e0001004 	.word	0xe0001004
   10754:	10014257 	.word	0x10014257

00010758 <SEGGER_SYSVIEW_RecordExitISRToScheduler>:
void SEGGER_SYSVIEW_RecordExitISRToScheduler(void) {
   10758:	b570      	push	{r4, r5, r6, lr}
   1075a:	b084      	sub	sp, #16
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
   1075c:	f3ef 8511 	mrs	r5, BASEPRI
   10760:	f04f 0120 	mov.w	r1, #32
   10764:	f381 8811 	msr	BASEPRI, r1
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   10768:	4c3b      	ldr	r4, [pc, #236]	; (10858 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x100>)
   1076a:	7823      	ldrb	r3, [r4, #0]
   1076c:	2b01      	cmp	r3, #1
   1076e:	d00f      	beq.n	10790 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x38>
  if (_SYSVIEW_Globals.EnableState == 0) {
   10770:	b963      	cbnz	r3, 1078c <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x34>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   10772:	4b3a      	ldr	r3, [pc, #232]	; (1085c <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x104>)
   10774:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   10778:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   1077c:	429a      	cmp	r2, r3
   1077e:	d001      	beq.n	10784 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x2c>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   10780:	78a6      	ldrb	r6, [r4, #2]
   10782:	b32e      	cbz	r6, 107d0 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x78>
  RECORD_END();
   10784:	f385 8811 	msr	BASEPRI, r5
}
   10788:	b004      	add	sp, #16
   1078a:	bd70      	pop	{r4, r5, r6, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   1078c:	2b02      	cmp	r3, #2
   1078e:	d02c      	beq.n	107ea <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x92>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   10790:	69e3      	ldr	r3, [r4, #28]
   10792:	035b      	lsls	r3, r3, #13
   10794:	d4ed      	bmi.n	10772 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x1a>
    *--pStartPacket = EventId;
   10796:	4a32      	ldr	r2, [pc, #200]	; (10860 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x108>)
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10798:	4932      	ldr	r1, [pc, #200]	; (10864 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x10c>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   1079a:	68e3      	ldr	r3, [r4, #12]
    *--pStartPacket = EventId;
   1079c:	2012      	movs	r0, #18
   1079e:	70d0      	strb	r0, [r2, #3]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   107a0:	680e      	ldr	r6, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   107a2:	1af3      	subs	r3, r6, r3
  ENCODE_U32(pEndPacket, Delta);
   107a4:	2b7f      	cmp	r3, #127	; 0x7f
   107a6:	f102 0204 	add.w	r2, r2, #4
   107aa:	d906      	bls.n	107ba <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x62>
   107ac:	f063 017f 	orn	r1, r3, #127	; 0x7f
   107b0:	09db      	lsrs	r3, r3, #7
   107b2:	2b7f      	cmp	r3, #127	; 0x7f
   107b4:	f802 1b01 	strb.w	r1, [r2], #1
   107b8:	d8f8      	bhi.n	107ac <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x54>
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   107ba:	482b      	ldr	r0, [pc, #172]	; (10868 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x110>)
  ENCODE_U32(pEndPacket, Delta);
   107bc:	f802 3b01 	strb.w	r3, [r2], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   107c0:	4601      	mov	r1, r0
   107c2:	1a12      	subs	r2, r2, r0
   107c4:	2001      	movs	r0, #1
   107c6:	f7ff fa5d 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   107ca:	b150      	cbz	r0, 107e2 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x8a>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   107cc:	60e6      	str	r6, [r4, #12]
   107ce:	e7d0      	b.n	10772 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x1a>
      _SYSVIEW_Globals.RecursionCnt = 1;
   107d0:	2301      	movs	r3, #1
   107d2:	70a3      	strb	r3, [r4, #2]
      _HandleIncomingPacket();
   107d4:	f7ff fc7e 	bl	100d4 <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   107d8:	70a6      	strb	r6, [r4, #2]
  RECORD_END();
   107da:	f385 8811 	msr	BASEPRI, r5
}
   107de:	b004      	add	sp, #16
   107e0:	bd70      	pop	{r4, r5, r6, pc}
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   107e2:	7823      	ldrb	r3, [r4, #0]
   107e4:	3301      	adds	r3, #1
   107e6:	7023      	strb	r3, [r4, #0]
   107e8:	e7c3      	b.n	10772 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x1a>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   107ea:	6962      	ldr	r2, [r4, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   107ec:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   107ee:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   107f0:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   107f4:	f10d 0305 	add.w	r3, sp, #5
   107f8:	d906      	bls.n	10808 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0xb0>
   107fa:	f062 017f 	orn	r1, r2, #127	; 0x7f
   107fe:	09d2      	lsrs	r2, r2, #7
   10800:	2a7f      	cmp	r2, #127	; 0x7f
   10802:	f803 1b01 	strb.w	r1, [r3], #1
   10806:	d8f8      	bhi.n	107fa <SEGGER_SYSVIEW_RecordExitISRToScheduler+0xa2>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10808:	4916      	ldr	r1, [pc, #88]	; (10864 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x10c>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   1080a:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   1080c:	680e      	ldr	r6, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   1080e:	68e1      	ldr	r1, [r4, #12]
   10810:	1a71      	subs	r1, r6, r1
  ENCODE_U32(pPayload, Delta);
   10812:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10814:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   10818:	d906      	bls.n	10828 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0xd0>
   1081a:	f061 037f 	orn	r3, r1, #127	; 0x7f
   1081e:	09c9      	lsrs	r1, r1, #7
   10820:	297f      	cmp	r1, #127	; 0x7f
   10822:	f802 3b01 	strb.w	r3, [r2], #1
   10826:	d8f8      	bhi.n	1081a <SEGGER_SYSVIEW_RecordExitISRToScheduler+0xc2>
   10828:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   1082a:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   1082c:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   10830:	2001      	movs	r0, #1
   10832:	4611      	mov	r1, r2
   10834:	1a9a      	subs	r2, r3, r2
   10836:	f7ff fa25 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   1083a:	b930      	cbnz	r0, 1084a <SEGGER_SYSVIEW_RecordExitISRToScheduler+0xf2>
    _SYSVIEW_Globals.DropCount++;
   1083c:	6962      	ldr	r2, [r4, #20]
   1083e:	7823      	ldrb	r3, [r4, #0]
   10840:	3201      	adds	r2, #1
   10842:	6162      	str	r2, [r4, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   10844:	2b01      	cmp	r3, #1
   10846:	d194      	bne.n	10772 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x1a>
   10848:	e7a2      	b.n	10790 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x38>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   1084a:	7823      	ldrb	r3, [r4, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   1084c:	60e6      	str	r6, [r4, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   1084e:	3b01      	subs	r3, #1
   10850:	b2db      	uxtb	r3, r3
   10852:	7023      	strb	r3, [r4, #0]
   10854:	e7f6      	b.n	10844 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0xec>
   10856:	bf00      	nop
   10858:	1001322c 	.word	0x1001322c
   1085c:	10014404 	.word	0x10014404
   10860:	10014254 	.word	0x10014254
   10864:	e0001004 	.word	0xe0001004
   10868:	10014257 	.word	0x10014257

0001086c <SEGGER_SYSVIEW_SendSysDesc>:
void SEGGER_SYSVIEW_SendSysDesc(const char *sSysDesc) {
   1086c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10870:	b085      	sub	sp, #20
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
   10872:	f3ef 8611 	mrs	r6, BASEPRI
   10876:	f04f 0120 	mov.w	r1, #32
   1087a:	f381 8811 	msr	BASEPRI, r1
  while(*(pText + Len) != 0) {
   1087e:	7803      	ldrb	r3, [r0, #0]
   10880:	2b00      	cmp	r3, #0
   10882:	f000 80f0 	beq.w	10a66 <SEGGER_SYSVIEW_SendSysDesc+0x1fa>
   10886:	4602      	mov	r2, r0
  Len = 0;
   10888:	2300      	movs	r3, #0
  while(*(pText + Len) != 0) {
   1088a:	f812 1f01 	ldrb.w	r1, [r2, #1]!
    Len++;
   1088e:	3301      	adds	r3, #1
  while(*(pText + Len) != 0) {
   10890:	2900      	cmp	r1, #0
   10892:	d1fa      	bne.n	1088a <SEGGER_SYSVIEW_SendSysDesc+0x1e>
    *pPayload++ = Len; 
   10894:	4d79      	ldr	r5, [pc, #484]	; (10a7c <SEGGER_SYSVIEW_SendSysDesc+0x210>)
   10896:	f100 0208 	add.w	r2, r0, #8
   1089a:	f105 0e05 	add.w	lr, r5, #5
   1089e:	f105 070d 	add.w	r7, r5, #13
   108a2:	4287      	cmp	r7, r0
   108a4:	bf88      	it	hi
   108a6:	4572      	cmphi	r2, lr
   108a8:	bf94      	ite	ls
   108aa:	2201      	movls	r2, #1
   108ac:	2200      	movhi	r2, #0
   108ae:	ea40 040e 	orr.w	r4, r0, lr
   108b2:	2b80      	cmp	r3, #128	; 0x80
   108b4:	469c      	mov	ip, r3
   108b6:	bf28      	it	cs
   108b8:	f04f 0c80 	movcs.w	ip, #128	; 0x80
   108bc:	f014 0f07 	tst.w	r4, #7
   108c0:	bf18      	it	ne
   108c2:	2200      	movne	r2, #0
   108c4:	f885 c004 	strb.w	ip, [r5, #4]
   108c8:	2a00      	cmp	r2, #0
   108ca:	f000 80c1 	beq.w	10a50 <SEGGER_SYSVIEW_SendSysDesc+0x1e4>
   108ce:	2b0c      	cmp	r3, #12
   108d0:	f240 80be 	bls.w	10a50 <SEGGER_SYSVIEW_SendSysDesc+0x1e4>
   108d4:	2b00      	cmp	r3, #0
   108d6:	bf14      	ite	ne
   108d8:	46e2      	movne	sl, ip
   108da:	f04f 0a01 	moveq.w	sl, #1
   108de:	ea4f 02da 	mov.w	r2, sl, lsr #3
   108e2:	46f3      	mov	fp, lr
   108e4:	1dab      	adds	r3, r5, #6
   108e6:	4607      	mov	r7, r0
    *pPayload++ = *pText++;
   108e8:	e8f7 8902 	ldrd	r8, r9, [r7], #8
   108ec:	3101      	adds	r1, #1
   108ee:	461c      	mov	r4, r3
   108f0:	428a      	cmp	r2, r1
   108f2:	e8eb 8902 	strd	r8, r9, [fp], #8
   108f6:	f104 0407 	add.w	r4, r4, #7
   108fa:	f103 0308 	add.w	r3, r3, #8
   108fe:	d8f3      	bhi.n	108e8 <SEGGER_SYSVIEW_SendSysDesc+0x7c>
   10900:	f02a 0307 	bic.w	r3, sl, #7
   10904:	4553      	cmp	r3, sl
   10906:	eb00 0103 	add.w	r1, r0, r3
   1090a:	eb0e 0203 	add.w	r2, lr, r3
   1090e:	d02d      	beq.n	1096c <SEGGER_SYSVIEW_SendSysDesc+0x100>
   10910:	5cc0      	ldrb	r0, [r0, r3]
   10912:	f80e 0003 	strb.w	r0, [lr, r3]
    n++;
   10916:	1c58      	adds	r0, r3, #1
  while (n < Len) {
   10918:	4560      	cmp	r0, ip
    *pPayload++ = *pText++;
   1091a:	f102 0401 	add.w	r4, r2, #1
  while (n < Len) {
   1091e:	d225      	bcs.n	1096c <SEGGER_SYSVIEW_SendSysDesc+0x100>
    *pPayload++ = *pText++;
   10920:	7848      	ldrb	r0, [r1, #1]
   10922:	7050      	strb	r0, [r2, #1]
    n++;
   10924:	1c98      	adds	r0, r3, #2
  while (n < Len) {
   10926:	4584      	cmp	ip, r0
    *pPayload++ = *pText++;
   10928:	f102 0402 	add.w	r4, r2, #2
  while (n < Len) {
   1092c:	d91e      	bls.n	1096c <SEGGER_SYSVIEW_SendSysDesc+0x100>
    *pPayload++ = *pText++;
   1092e:	7888      	ldrb	r0, [r1, #2]
   10930:	7090      	strb	r0, [r2, #2]
    n++;
   10932:	1cd8      	adds	r0, r3, #3
  while (n < Len) {
   10934:	4584      	cmp	ip, r0
    *pPayload++ = *pText++;
   10936:	f102 0403 	add.w	r4, r2, #3
  while (n < Len) {
   1093a:	d917      	bls.n	1096c <SEGGER_SYSVIEW_SendSysDesc+0x100>
    *pPayload++ = *pText++;
   1093c:	78c8      	ldrb	r0, [r1, #3]
   1093e:	70d0      	strb	r0, [r2, #3]
    n++;
   10940:	1d18      	adds	r0, r3, #4
  while (n < Len) {
   10942:	4584      	cmp	ip, r0
    *pPayload++ = *pText++;
   10944:	f102 0404 	add.w	r4, r2, #4
  while (n < Len) {
   10948:	d910      	bls.n	1096c <SEGGER_SYSVIEW_SendSysDesc+0x100>
    *pPayload++ = *pText++;
   1094a:	7908      	ldrb	r0, [r1, #4]
   1094c:	7110      	strb	r0, [r2, #4]
    n++;
   1094e:	1d58      	adds	r0, r3, #5
  while (n < Len) {
   10950:	4584      	cmp	ip, r0
    *pPayload++ = *pText++;
   10952:	f102 0405 	add.w	r4, r2, #5
  while (n < Len) {
   10956:	d909      	bls.n	1096c <SEGGER_SYSVIEW_SendSysDesc+0x100>
    n++;
   10958:	3306      	adds	r3, #6
    *pPayload++ = *pText++;
   1095a:	7948      	ldrb	r0, [r1, #5]
   1095c:	7150      	strb	r0, [r2, #5]
  while (n < Len) {
   1095e:	459c      	cmp	ip, r3
    *pPayload++ = *pText++;
   10960:	f102 0406 	add.w	r4, r2, #6
  while (n < Len) {
   10964:	d902      	bls.n	1096c <SEGGER_SYSVIEW_SendSysDesc+0x100>
    *pPayload++ = *pText++;
   10966:	798b      	ldrb	r3, [r1, #6]
   10968:	7193      	strb	r3, [r2, #6]
   1096a:	1dd4      	adds	r4, r2, #7
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   1096c:	4f44      	ldr	r7, [pc, #272]	; (10a80 <SEGGER_SYSVIEW_SendSysDesc+0x214>)
   1096e:	783b      	ldrb	r3, [r7, #0]
   10970:	2b01      	cmp	r3, #1
   10972:	d010      	beq.n	10996 <SEGGER_SYSVIEW_SendSysDesc+0x12a>
  if (_SYSVIEW_Globals.EnableState == 0) {
   10974:	b96b      	cbnz	r3, 10992 <SEGGER_SYSVIEW_SendSysDesc+0x126>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   10976:	4b43      	ldr	r3, [pc, #268]	; (10a84 <SEGGER_SYSVIEW_SendSysDesc+0x218>)
   10978:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   1097c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   10980:	429a      	cmp	r2, r3
   10982:	d001      	beq.n	10988 <SEGGER_SYSVIEW_SendSysDesc+0x11c>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   10984:	78bc      	ldrb	r4, [r7, #2]
   10986:	b31c      	cbz	r4, 109d0 <SEGGER_SYSVIEW_SendSysDesc+0x164>
  RECORD_END();
   10988:	f386 8811 	msr	BASEPRI, r6
}
   1098c:	b005      	add	sp, #20
   1098e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   10992:	2b02      	cmp	r3, #2
   10994:	d02a      	beq.n	109ec <SEGGER_SYSVIEW_SendSysDesc+0x180>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   10996:	69fb      	ldr	r3, [r7, #28]
   10998:	045b      	lsls	r3, r3, #17
   1099a:	d4ec      	bmi.n	10976 <SEGGER_SYSVIEW_SendSysDesc+0x10a>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   1099c:	4b3a      	ldr	r3, [pc, #232]	; (10a88 <SEGGER_SYSVIEW_SendSysDesc+0x21c>)
    *--pStartPacket = EventId;
   1099e:	220e      	movs	r2, #14
   109a0:	70ea      	strb	r2, [r5, #3]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   109a2:	681d      	ldr	r5, [r3, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   109a4:	68fb      	ldr	r3, [r7, #12]
   109a6:	1aeb      	subs	r3, r5, r3
  ENCODE_U32(pEndPacket, Delta);
   109a8:	2b7f      	cmp	r3, #127	; 0x7f
   109aa:	d906      	bls.n	109ba <SEGGER_SYSVIEW_SendSysDesc+0x14e>
   109ac:	f063 027f 	orn	r2, r3, #127	; 0x7f
   109b0:	09db      	lsrs	r3, r3, #7
   109b2:	2b7f      	cmp	r3, #127	; 0x7f
   109b4:	f804 2b01 	strb.w	r2, [r4], #1
   109b8:	d8f8      	bhi.n	109ac <SEGGER_SYSVIEW_SendSysDesc+0x140>
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   109ba:	4a34      	ldr	r2, [pc, #208]	; (10a8c <SEGGER_SYSVIEW_SendSysDesc+0x220>)
  ENCODE_U32(pEndPacket, Delta);
   109bc:	f804 3b01 	strb.w	r3, [r4], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   109c0:	4611      	mov	r1, r2
   109c2:	2001      	movs	r0, #1
   109c4:	1aa2      	subs	r2, r4, r2
   109c6:	f7ff f95d 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   109ca:	b158      	cbz	r0, 109e4 <SEGGER_SYSVIEW_SendSysDesc+0x178>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   109cc:	60fd      	str	r5, [r7, #12]
   109ce:	e7d2      	b.n	10976 <SEGGER_SYSVIEW_SendSysDesc+0x10a>
      _SYSVIEW_Globals.RecursionCnt = 1;
   109d0:	2301      	movs	r3, #1
   109d2:	70bb      	strb	r3, [r7, #2]
      _HandleIncomingPacket();
   109d4:	f7ff fb7e 	bl	100d4 <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   109d8:	70bc      	strb	r4, [r7, #2]
  RECORD_END();
   109da:	f386 8811 	msr	BASEPRI, r6
}
   109de:	b005      	add	sp, #20
   109e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   109e4:	783b      	ldrb	r3, [r7, #0]
   109e6:	3301      	adds	r3, #1
   109e8:	703b      	strb	r3, [r7, #0]
   109ea:	e7c4      	b.n	10976 <SEGGER_SYSVIEW_SendSysDesc+0x10a>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   109ec:	697a      	ldr	r2, [r7, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   109ee:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   109f0:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   109f2:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   109f6:	f10d 0305 	add.w	r3, sp, #5
   109fa:	d906      	bls.n	10a0a <SEGGER_SYSVIEW_SendSysDesc+0x19e>
   109fc:	f062 017f 	orn	r1, r2, #127	; 0x7f
   10a00:	09d2      	lsrs	r2, r2, #7
   10a02:	2a7f      	cmp	r2, #127	; 0x7f
   10a04:	f803 1b01 	strb.w	r1, [r3], #1
   10a08:	d8f8      	bhi.n	109fc <SEGGER_SYSVIEW_SendSysDesc+0x190>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10a0a:	491f      	ldr	r1, [pc, #124]	; (10a88 <SEGGER_SYSVIEW_SendSysDesc+0x21c>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10a0c:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10a0e:	f8d1 8000 	ldr.w	r8, [r1]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   10a12:	68f9      	ldr	r1, [r7, #12]
   10a14:	eba8 0101 	sub.w	r1, r8, r1
  ENCODE_U32(pPayload, Delta);
   10a18:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10a1a:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   10a1e:	d906      	bls.n	10a2e <SEGGER_SYSVIEW_SendSysDesc+0x1c2>
   10a20:	f061 037f 	orn	r3, r1, #127	; 0x7f
   10a24:	09c9      	lsrs	r1, r1, #7
   10a26:	297f      	cmp	r1, #127	; 0x7f
   10a28:	f802 3b01 	strb.w	r3, [r2], #1
   10a2c:	d8f8      	bhi.n	10a20 <SEGGER_SYSVIEW_SendSysDesc+0x1b4>
   10a2e:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   10a30:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   10a32:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   10a36:	2001      	movs	r0, #1
   10a38:	4611      	mov	r1, r2
   10a3a:	1a9a      	subs	r2, r3, r2
   10a3c:	f7ff f922 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   10a40:	b9a8      	cbnz	r0, 10a6e <SEGGER_SYSVIEW_SendSysDesc+0x202>
    _SYSVIEW_Globals.DropCount++;
   10a42:	697a      	ldr	r2, [r7, #20]
   10a44:	783b      	ldrb	r3, [r7, #0]
   10a46:	3201      	adds	r2, #1
   10a48:	617a      	str	r2, [r7, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   10a4a:	2b01      	cmp	r3, #1
   10a4c:	d193      	bne.n	10976 <SEGGER_SYSVIEW_SendSysDesc+0x10a>
   10a4e:	e7a2      	b.n	10996 <SEGGER_SYSVIEW_SendSysDesc+0x12a>
    *pPayload++ = Len; 
   10a50:	4c0f      	ldr	r4, [pc, #60]	; (10a90 <SEGGER_SYSVIEW_SendSysDesc+0x224>)
   10a52:	3801      	subs	r0, #1
   10a54:	2300      	movs	r3, #0
    n++;
   10a56:	3301      	adds	r3, #1
    *pPayload++ = *pText++;
   10a58:	f810 2f01 	ldrb.w	r2, [r0, #1]!
   10a5c:	f804 2b01 	strb.w	r2, [r4], #1
  while (n < Len) {
   10a60:	459c      	cmp	ip, r3
   10a62:	d8f8      	bhi.n	10a56 <SEGGER_SYSVIEW_SendSysDesc+0x1ea>
   10a64:	e782      	b.n	1096c <SEGGER_SYSVIEW_SendSysDesc+0x100>
    *pPayload++ = Len; 
   10a66:	4d05      	ldr	r5, [pc, #20]	; (10a7c <SEGGER_SYSVIEW_SendSysDesc+0x210>)
   10a68:	712b      	strb	r3, [r5, #4]
   10a6a:	1d6c      	adds	r4, r5, #5
   10a6c:	e77e      	b.n	1096c <SEGGER_SYSVIEW_SendSysDesc+0x100>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   10a6e:	783b      	ldrb	r3, [r7, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   10a70:	f8c7 800c 	str.w	r8, [r7, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   10a74:	3b01      	subs	r3, #1
   10a76:	b2db      	uxtb	r3, r3
   10a78:	703b      	strb	r3, [r7, #0]
   10a7a:	e7e6      	b.n	10a4a <SEGGER_SYSVIEW_SendSysDesc+0x1de>
   10a7c:	10014254 	.word	0x10014254
   10a80:	1001322c 	.word	0x1001322c
   10a84:	10014404 	.word	0x10014404
   10a88:	e0001004 	.word	0xe0001004
   10a8c:	10014257 	.word	0x10014257
   10a90:	10014259 	.word	0x10014259

00010a94 <SEGGER_SYSVIEW_RecordEnterISR>:
void SEGGER_SYSVIEW_RecordEnterISR(void) {
   10a94:	b5f0      	push	{r4, r5, r6, r7, lr}
   10a96:	b085      	sub	sp, #20
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
   10a98:	f3ef 8511 	mrs	r5, BASEPRI
   10a9c:	f04f 0120 	mov.w	r1, #32
   10aa0:	f381 8811 	msr	BASEPRI, r1
  v = SEGGER_SYSVIEW_GET_INTERRUPT_ID();
   10aa4:	4b42      	ldr	r3, [pc, #264]	; (10bb0 <SEGGER_SYSVIEW_RecordEnterISR+0x11c>)
   10aa6:	681b      	ldr	r3, [r3, #0]
   10aa8:	f3c3 0308 	ubfx	r3, r3, #0, #9
  ENCODE_U32(pPayload, v);
   10aac:	2b7f      	cmp	r3, #127	; 0x7f
   10aae:	d977      	bls.n	10ba0 <SEGGER_SYSVIEW_RecordEnterISR+0x10c>
   10ab0:	4c40      	ldr	r4, [pc, #256]	; (10bb4 <SEGGER_SYSVIEW_RecordEnterISR+0x120>)
   10ab2:	f063 017f 	orn	r1, r3, #127	; 0x7f
   10ab6:	7121      	strb	r1, [r4, #4]
   10ab8:	09db      	lsrs	r3, r3, #7
   10aba:	3405      	adds	r4, #5
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   10abc:	4e3e      	ldr	r6, [pc, #248]	; (10bb8 <SEGGER_SYSVIEW_RecordEnterISR+0x124>)
  ENCODE_U32(pPayload, v);
   10abe:	7023      	strb	r3, [r4, #0]
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   10ac0:	7833      	ldrb	r3, [r6, #0]
   10ac2:	2b01      	cmp	r3, #1
   10ac4:	d00f      	beq.n	10ae6 <SEGGER_SYSVIEW_RecordEnterISR+0x52>
  if (_SYSVIEW_Globals.EnableState == 0) {
   10ac6:	b963      	cbnz	r3, 10ae2 <SEGGER_SYSVIEW_RecordEnterISR+0x4e>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   10ac8:	4b3c      	ldr	r3, [pc, #240]	; (10bbc <SEGGER_SYSVIEW_RecordEnterISR+0x128>)
   10aca:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   10ace:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   10ad2:	429a      	cmp	r2, r3
   10ad4:	d001      	beq.n	10ada <SEGGER_SYSVIEW_RecordEnterISR+0x46>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   10ad6:	78b4      	ldrb	r4, [r6, #2]
   10ad8:	b32c      	cbz	r4, 10b26 <SEGGER_SYSVIEW_RecordEnterISR+0x92>
  RECORD_END();
   10ada:	f385 8811 	msr	BASEPRI, r5
}
   10ade:	b005      	add	sp, #20
   10ae0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   10ae2:	2b02      	cmp	r3, #2
   10ae4:	d02c      	beq.n	10b40 <SEGGER_SYSVIEW_RecordEnterISR+0xac>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   10ae6:	69f3      	ldr	r3, [r6, #28]
   10ae8:	075b      	lsls	r3, r3, #29
   10aea:	d4ed      	bmi.n	10ac8 <SEGGER_SYSVIEW_RecordEnterISR+0x34>
    *--pStartPacket = EventId;
   10aec:	4a31      	ldr	r2, [pc, #196]	; (10bb4 <SEGGER_SYSVIEW_RecordEnterISR+0x120>)
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10aee:	4b34      	ldr	r3, [pc, #208]	; (10bc0 <SEGGER_SYSVIEW_RecordEnterISR+0x12c>)
    *--pStartPacket = EventId;
   10af0:	2102      	movs	r1, #2
   10af2:	70d1      	strb	r1, [r2, #3]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10af4:	681f      	ldr	r7, [r3, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   10af6:	68f3      	ldr	r3, [r6, #12]
   10af8:	1afb      	subs	r3, r7, r3
  ENCODE_U32(pEndPacket, Delta);
   10afa:	2b7f      	cmp	r3, #127	; 0x7f
  ENCODE_U32(pPayload, v);
   10afc:	f104 0201 	add.w	r2, r4, #1
  ENCODE_U32(pEndPacket, Delta);
   10b00:	d906      	bls.n	10b10 <SEGGER_SYSVIEW_RecordEnterISR+0x7c>
   10b02:	f063 017f 	orn	r1, r3, #127	; 0x7f
   10b06:	09db      	lsrs	r3, r3, #7
   10b08:	2b7f      	cmp	r3, #127	; 0x7f
   10b0a:	f802 1b01 	strb.w	r1, [r2], #1
   10b0e:	d8f8      	bhi.n	10b02 <SEGGER_SYSVIEW_RecordEnterISR+0x6e>
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   10b10:	482c      	ldr	r0, [pc, #176]	; (10bc4 <SEGGER_SYSVIEW_RecordEnterISR+0x130>)
  ENCODE_U32(pEndPacket, Delta);
   10b12:	f802 3b01 	strb.w	r3, [r2], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   10b16:	4601      	mov	r1, r0
   10b18:	1a12      	subs	r2, r2, r0
   10b1a:	2001      	movs	r0, #1
   10b1c:	f7ff f8b2 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   10b20:	b150      	cbz	r0, 10b38 <SEGGER_SYSVIEW_RecordEnterISR+0xa4>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   10b22:	60f7      	str	r7, [r6, #12]
   10b24:	e7d0      	b.n	10ac8 <SEGGER_SYSVIEW_RecordEnterISR+0x34>
      _SYSVIEW_Globals.RecursionCnt = 1;
   10b26:	2301      	movs	r3, #1
   10b28:	70b3      	strb	r3, [r6, #2]
      _HandleIncomingPacket();
   10b2a:	f7ff fad3 	bl	100d4 <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   10b2e:	70b4      	strb	r4, [r6, #2]
  RECORD_END();
   10b30:	f385 8811 	msr	BASEPRI, r5
}
   10b34:	b005      	add	sp, #20
   10b36:	bdf0      	pop	{r4, r5, r6, r7, pc}
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   10b38:	7833      	ldrb	r3, [r6, #0]
   10b3a:	3301      	adds	r3, #1
   10b3c:	7033      	strb	r3, [r6, #0]
   10b3e:	e7c3      	b.n	10ac8 <SEGGER_SYSVIEW_RecordEnterISR+0x34>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10b40:	6972      	ldr	r2, [r6, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   10b42:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10b44:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   10b46:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10b4a:	f10d 0305 	add.w	r3, sp, #5
   10b4e:	d906      	bls.n	10b5e <SEGGER_SYSVIEW_RecordEnterISR+0xca>
   10b50:	f062 017f 	orn	r1, r2, #127	; 0x7f
   10b54:	09d2      	lsrs	r2, r2, #7
   10b56:	2a7f      	cmp	r2, #127	; 0x7f
   10b58:	f803 1b01 	strb.w	r1, [r3], #1
   10b5c:	d8f8      	bhi.n	10b50 <SEGGER_SYSVIEW_RecordEnterISR+0xbc>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10b5e:	4918      	ldr	r1, [pc, #96]	; (10bc0 <SEGGER_SYSVIEW_RecordEnterISR+0x12c>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10b60:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10b62:	680f      	ldr	r7, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   10b64:	68f1      	ldr	r1, [r6, #12]
   10b66:	1a79      	subs	r1, r7, r1
  ENCODE_U32(pPayload, Delta);
   10b68:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10b6a:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   10b6e:	d906      	bls.n	10b7e <SEGGER_SYSVIEW_RecordEnterISR+0xea>
   10b70:	f061 037f 	orn	r3, r1, #127	; 0x7f
   10b74:	09c9      	lsrs	r1, r1, #7
   10b76:	297f      	cmp	r1, #127	; 0x7f
   10b78:	f802 3b01 	strb.w	r3, [r2], #1
   10b7c:	d8f8      	bhi.n	10b70 <SEGGER_SYSVIEW_RecordEnterISR+0xdc>
   10b7e:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   10b80:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   10b82:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   10b86:	2001      	movs	r0, #1
   10b88:	4611      	mov	r1, r2
   10b8a:	1a9a      	subs	r2, r3, r2
   10b8c:	f7ff f87a 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   10b90:	b940      	cbnz	r0, 10ba4 <SEGGER_SYSVIEW_RecordEnterISR+0x110>
    _SYSVIEW_Globals.DropCount++;
   10b92:	6972      	ldr	r2, [r6, #20]
   10b94:	7833      	ldrb	r3, [r6, #0]
   10b96:	3201      	adds	r2, #1
   10b98:	6172      	str	r2, [r6, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   10b9a:	2b01      	cmp	r3, #1
   10b9c:	d194      	bne.n	10ac8 <SEGGER_SYSVIEW_RecordEnterISR+0x34>
   10b9e:	e7a2      	b.n	10ae6 <SEGGER_SYSVIEW_RecordEnterISR+0x52>
  ENCODE_U32(pPayload, v);
   10ba0:	4c09      	ldr	r4, [pc, #36]	; (10bc8 <SEGGER_SYSVIEW_RecordEnterISR+0x134>)
   10ba2:	e78b      	b.n	10abc <SEGGER_SYSVIEW_RecordEnterISR+0x28>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   10ba4:	7833      	ldrb	r3, [r6, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   10ba6:	60f7      	str	r7, [r6, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   10ba8:	3b01      	subs	r3, #1
   10baa:	b2db      	uxtb	r3, r3
   10bac:	7033      	strb	r3, [r6, #0]
   10bae:	e7f4      	b.n	10b9a <SEGGER_SYSVIEW_RecordEnterISR+0x106>
   10bb0:	e000ed04 	.word	0xe000ed04
   10bb4:	10014254 	.word	0x10014254
   10bb8:	1001322c 	.word	0x1001322c
   10bbc:	10014404 	.word	0x10014404
   10bc0:	e0001004 	.word	0xe0001004
   10bc4:	10014257 	.word	0x10014257
   10bc8:	10014258 	.word	0x10014258

00010bcc <SEGGER_SYSVIEW_OnTaskCreate>:
void SEGGER_SYSVIEW_OnTaskCreate(U32 TaskId) {
   10bcc:	b5f0      	push	{r4, r5, r6, r7, lr}
   10bce:	b085      	sub	sp, #20
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
   10bd0:	f3ef 8611 	mrs	r6, BASEPRI
   10bd4:	f04f 0120 	mov.w	r1, #32
   10bd8:	f381 8811 	msr	BASEPRI, r1
  TaskId = SHRINK_ID(TaskId);
   10bdc:	4d42      	ldr	r5, [pc, #264]	; (10ce8 <SEGGER_SYSVIEW_OnTaskCreate+0x11c>)
  ENCODE_U32(pPayload, TaskId);
   10bde:	4c43      	ldr	r4, [pc, #268]	; (10cec <SEGGER_SYSVIEW_OnTaskCreate+0x120>)
  TaskId = SHRINK_ID(TaskId);
   10be0:	692b      	ldr	r3, [r5, #16]
   10be2:	1ac0      	subs	r0, r0, r3
   10be4:	0880      	lsrs	r0, r0, #2
  ENCODE_U32(pPayload, TaskId);
   10be6:	287f      	cmp	r0, #127	; 0x7f
   10be8:	d906      	bls.n	10bf8 <SEGGER_SYSVIEW_OnTaskCreate+0x2c>
   10bea:	f060 037f 	orn	r3, r0, #127	; 0x7f
   10bee:	09c0      	lsrs	r0, r0, #7
   10bf0:	287f      	cmp	r0, #127	; 0x7f
   10bf2:	f804 3b01 	strb.w	r3, [r4], #1
   10bf6:	d8f8      	bhi.n	10bea <SEGGER_SYSVIEW_OnTaskCreate+0x1e>
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   10bf8:	782b      	ldrb	r3, [r5, #0]
  ENCODE_U32(pPayload, TaskId);
   10bfa:	7020      	strb	r0, [r4, #0]
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   10bfc:	2b01      	cmp	r3, #1
   10bfe:	d00f      	beq.n	10c20 <SEGGER_SYSVIEW_OnTaskCreate+0x54>
  if (_SYSVIEW_Globals.EnableState == 0) {
   10c00:	b963      	cbnz	r3, 10c1c <SEGGER_SYSVIEW_OnTaskCreate+0x50>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   10c02:	4b3b      	ldr	r3, [pc, #236]	; (10cf0 <SEGGER_SYSVIEW_OnTaskCreate+0x124>)
   10c04:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   10c08:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   10c0c:	429a      	cmp	r2, r3
   10c0e:	d001      	beq.n	10c14 <SEGGER_SYSVIEW_OnTaskCreate+0x48>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   10c10:	78ac      	ldrb	r4, [r5, #2]
   10c12:	b32c      	cbz	r4, 10c60 <SEGGER_SYSVIEW_OnTaskCreate+0x94>
  RECORD_END();
   10c14:	f386 8811 	msr	BASEPRI, r6
}
   10c18:	b005      	add	sp, #20
   10c1a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   10c1c:	2b02      	cmp	r3, #2
   10c1e:	d02c      	beq.n	10c7a <SEGGER_SYSVIEW_OnTaskCreate+0xae>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   10c20:	69eb      	ldr	r3, [r5, #28]
   10c22:	05db      	lsls	r3, r3, #23
   10c24:	d4ed      	bmi.n	10c02 <SEGGER_SYSVIEW_OnTaskCreate+0x36>
    *--pStartPacket = EventId;
   10c26:	4a33      	ldr	r2, [pc, #204]	; (10cf4 <SEGGER_SYSVIEW_OnTaskCreate+0x128>)
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10c28:	4b33      	ldr	r3, [pc, #204]	; (10cf8 <SEGGER_SYSVIEW_OnTaskCreate+0x12c>)
    *--pStartPacket = EventId;
   10c2a:	2108      	movs	r1, #8
   10c2c:	70d1      	strb	r1, [r2, #3]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10c2e:	681f      	ldr	r7, [r3, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   10c30:	68eb      	ldr	r3, [r5, #12]
   10c32:	1afb      	subs	r3, r7, r3
  ENCODE_U32(pEndPacket, Delta);
   10c34:	2b7f      	cmp	r3, #127	; 0x7f
  ENCODE_U32(pPayload, TaskId);
   10c36:	f104 0201 	add.w	r2, r4, #1
  ENCODE_U32(pEndPacket, Delta);
   10c3a:	d906      	bls.n	10c4a <SEGGER_SYSVIEW_OnTaskCreate+0x7e>
   10c3c:	f063 017f 	orn	r1, r3, #127	; 0x7f
   10c40:	09db      	lsrs	r3, r3, #7
   10c42:	2b7f      	cmp	r3, #127	; 0x7f
   10c44:	f802 1b01 	strb.w	r1, [r2], #1
   10c48:	d8f8      	bhi.n	10c3c <SEGGER_SYSVIEW_OnTaskCreate+0x70>
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   10c4a:	482c      	ldr	r0, [pc, #176]	; (10cfc <SEGGER_SYSVIEW_OnTaskCreate+0x130>)
  ENCODE_U32(pEndPacket, Delta);
   10c4c:	f802 3b01 	strb.w	r3, [r2], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   10c50:	4601      	mov	r1, r0
   10c52:	1a12      	subs	r2, r2, r0
   10c54:	2001      	movs	r0, #1
   10c56:	f7ff f815 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   10c5a:	b150      	cbz	r0, 10c72 <SEGGER_SYSVIEW_OnTaskCreate+0xa6>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   10c5c:	60ef      	str	r7, [r5, #12]
   10c5e:	e7d0      	b.n	10c02 <SEGGER_SYSVIEW_OnTaskCreate+0x36>
      _SYSVIEW_Globals.RecursionCnt = 1;
   10c60:	2301      	movs	r3, #1
   10c62:	70ab      	strb	r3, [r5, #2]
      _HandleIncomingPacket();
   10c64:	f7ff fa36 	bl	100d4 <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   10c68:	70ac      	strb	r4, [r5, #2]
  RECORD_END();
   10c6a:	f386 8811 	msr	BASEPRI, r6
}
   10c6e:	b005      	add	sp, #20
   10c70:	bdf0      	pop	{r4, r5, r6, r7, pc}
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   10c72:	782b      	ldrb	r3, [r5, #0]
   10c74:	3301      	adds	r3, #1
   10c76:	702b      	strb	r3, [r5, #0]
   10c78:	e7c3      	b.n	10c02 <SEGGER_SYSVIEW_OnTaskCreate+0x36>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10c7a:	696a      	ldr	r2, [r5, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   10c7c:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10c7e:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   10c80:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10c84:	f10d 0305 	add.w	r3, sp, #5
   10c88:	d906      	bls.n	10c98 <SEGGER_SYSVIEW_OnTaskCreate+0xcc>
   10c8a:	f062 017f 	orn	r1, r2, #127	; 0x7f
   10c8e:	09d2      	lsrs	r2, r2, #7
   10c90:	2a7f      	cmp	r2, #127	; 0x7f
   10c92:	f803 1b01 	strb.w	r1, [r3], #1
   10c96:	d8f8      	bhi.n	10c8a <SEGGER_SYSVIEW_OnTaskCreate+0xbe>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10c98:	4917      	ldr	r1, [pc, #92]	; (10cf8 <SEGGER_SYSVIEW_OnTaskCreate+0x12c>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10c9a:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10c9c:	680f      	ldr	r7, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   10c9e:	68e9      	ldr	r1, [r5, #12]
   10ca0:	1a79      	subs	r1, r7, r1
  ENCODE_U32(pPayload, Delta);
   10ca2:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10ca4:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   10ca8:	d906      	bls.n	10cb8 <SEGGER_SYSVIEW_OnTaskCreate+0xec>
   10caa:	f061 037f 	orn	r3, r1, #127	; 0x7f
   10cae:	09c9      	lsrs	r1, r1, #7
   10cb0:	297f      	cmp	r1, #127	; 0x7f
   10cb2:	f802 3b01 	strb.w	r3, [r2], #1
   10cb6:	d8f8      	bhi.n	10caa <SEGGER_SYSVIEW_OnTaskCreate+0xde>
   10cb8:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   10cba:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   10cbc:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   10cc0:	2001      	movs	r0, #1
   10cc2:	4611      	mov	r1, r2
   10cc4:	1a9a      	subs	r2, r3, r2
   10cc6:	f7fe ffdd 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   10cca:	b930      	cbnz	r0, 10cda <SEGGER_SYSVIEW_OnTaskCreate+0x10e>
    _SYSVIEW_Globals.DropCount++;
   10ccc:	696a      	ldr	r2, [r5, #20]
   10cce:	782b      	ldrb	r3, [r5, #0]
   10cd0:	3201      	adds	r2, #1
   10cd2:	616a      	str	r2, [r5, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   10cd4:	2b01      	cmp	r3, #1
   10cd6:	d194      	bne.n	10c02 <SEGGER_SYSVIEW_OnTaskCreate+0x36>
   10cd8:	e7a2      	b.n	10c20 <SEGGER_SYSVIEW_OnTaskCreate+0x54>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   10cda:	782b      	ldrb	r3, [r5, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   10cdc:	60ef      	str	r7, [r5, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   10cde:	3b01      	subs	r3, #1
   10ce0:	b2db      	uxtb	r3, r3
   10ce2:	702b      	strb	r3, [r5, #0]
   10ce4:	e7f6      	b.n	10cd4 <SEGGER_SYSVIEW_OnTaskCreate+0x108>
   10ce6:	bf00      	nop
   10ce8:	1001322c 	.word	0x1001322c
   10cec:	10014258 	.word	0x10014258
   10cf0:	10014404 	.word	0x10014404
   10cf4:	10014254 	.word	0x10014254
   10cf8:	e0001004 	.word	0xe0001004
   10cfc:	10014257 	.word	0x10014257

00010d00 <SEGGER_SYSVIEW_OnTaskStartExec>:
void SEGGER_SYSVIEW_OnTaskStartExec(U32 TaskId) {
   10d00:	b5f0      	push	{r4, r5, r6, r7, lr}
   10d02:	b085      	sub	sp, #20
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
   10d04:	f3ef 8611 	mrs	r6, BASEPRI
   10d08:	f04f 0120 	mov.w	r1, #32
   10d0c:	f381 8811 	msr	BASEPRI, r1
  TaskId = SHRINK_ID(TaskId);
   10d10:	4d42      	ldr	r5, [pc, #264]	; (10e1c <SEGGER_SYSVIEW_OnTaskStartExec+0x11c>)
  ENCODE_U32(pPayload, TaskId);
   10d12:	4c43      	ldr	r4, [pc, #268]	; (10e20 <SEGGER_SYSVIEW_OnTaskStartExec+0x120>)
  TaskId = SHRINK_ID(TaskId);
   10d14:	692b      	ldr	r3, [r5, #16]
   10d16:	1ac0      	subs	r0, r0, r3
   10d18:	0880      	lsrs	r0, r0, #2
  ENCODE_U32(pPayload, TaskId);
   10d1a:	287f      	cmp	r0, #127	; 0x7f
   10d1c:	d906      	bls.n	10d2c <SEGGER_SYSVIEW_OnTaskStartExec+0x2c>
   10d1e:	f060 037f 	orn	r3, r0, #127	; 0x7f
   10d22:	09c0      	lsrs	r0, r0, #7
   10d24:	287f      	cmp	r0, #127	; 0x7f
   10d26:	f804 3b01 	strb.w	r3, [r4], #1
   10d2a:	d8f8      	bhi.n	10d1e <SEGGER_SYSVIEW_OnTaskStartExec+0x1e>
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   10d2c:	782b      	ldrb	r3, [r5, #0]
  ENCODE_U32(pPayload, TaskId);
   10d2e:	7020      	strb	r0, [r4, #0]
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   10d30:	2b01      	cmp	r3, #1
   10d32:	d00f      	beq.n	10d54 <SEGGER_SYSVIEW_OnTaskStartExec+0x54>
  if (_SYSVIEW_Globals.EnableState == 0) {
   10d34:	b963      	cbnz	r3, 10d50 <SEGGER_SYSVIEW_OnTaskStartExec+0x50>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   10d36:	4b3b      	ldr	r3, [pc, #236]	; (10e24 <SEGGER_SYSVIEW_OnTaskStartExec+0x124>)
   10d38:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   10d3c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   10d40:	429a      	cmp	r2, r3
   10d42:	d001      	beq.n	10d48 <SEGGER_SYSVIEW_OnTaskStartExec+0x48>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   10d44:	78ac      	ldrb	r4, [r5, #2]
   10d46:	b32c      	cbz	r4, 10d94 <SEGGER_SYSVIEW_OnTaskStartExec+0x94>
  RECORD_END();
   10d48:	f386 8811 	msr	BASEPRI, r6
}
   10d4c:	b005      	add	sp, #20
   10d4e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   10d50:	2b02      	cmp	r3, #2
   10d52:	d02c      	beq.n	10dae <SEGGER_SYSVIEW_OnTaskStartExec+0xae>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   10d54:	69eb      	ldr	r3, [r5, #28]
   10d56:	06db      	lsls	r3, r3, #27
   10d58:	d4ed      	bmi.n	10d36 <SEGGER_SYSVIEW_OnTaskStartExec+0x36>
    *--pStartPacket = EventId;
   10d5a:	4a33      	ldr	r2, [pc, #204]	; (10e28 <SEGGER_SYSVIEW_OnTaskStartExec+0x128>)
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10d5c:	4b33      	ldr	r3, [pc, #204]	; (10e2c <SEGGER_SYSVIEW_OnTaskStartExec+0x12c>)
    *--pStartPacket = EventId;
   10d5e:	2104      	movs	r1, #4
   10d60:	70d1      	strb	r1, [r2, #3]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10d62:	681f      	ldr	r7, [r3, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   10d64:	68eb      	ldr	r3, [r5, #12]
   10d66:	1afb      	subs	r3, r7, r3
  ENCODE_U32(pEndPacket, Delta);
   10d68:	2b7f      	cmp	r3, #127	; 0x7f
  ENCODE_U32(pPayload, TaskId);
   10d6a:	f104 0201 	add.w	r2, r4, #1
  ENCODE_U32(pEndPacket, Delta);
   10d6e:	d906      	bls.n	10d7e <SEGGER_SYSVIEW_OnTaskStartExec+0x7e>
   10d70:	f063 017f 	orn	r1, r3, #127	; 0x7f
   10d74:	09db      	lsrs	r3, r3, #7
   10d76:	2b7f      	cmp	r3, #127	; 0x7f
   10d78:	f802 1b01 	strb.w	r1, [r2], #1
   10d7c:	d8f8      	bhi.n	10d70 <SEGGER_SYSVIEW_OnTaskStartExec+0x70>
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   10d7e:	482c      	ldr	r0, [pc, #176]	; (10e30 <SEGGER_SYSVIEW_OnTaskStartExec+0x130>)
  ENCODE_U32(pEndPacket, Delta);
   10d80:	f802 3b01 	strb.w	r3, [r2], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   10d84:	4601      	mov	r1, r0
   10d86:	1a12      	subs	r2, r2, r0
   10d88:	2001      	movs	r0, #1
   10d8a:	f7fe ff7b 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   10d8e:	b150      	cbz	r0, 10da6 <SEGGER_SYSVIEW_OnTaskStartExec+0xa6>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   10d90:	60ef      	str	r7, [r5, #12]
   10d92:	e7d0      	b.n	10d36 <SEGGER_SYSVIEW_OnTaskStartExec+0x36>
      _SYSVIEW_Globals.RecursionCnt = 1;
   10d94:	2301      	movs	r3, #1
   10d96:	70ab      	strb	r3, [r5, #2]
      _HandleIncomingPacket();
   10d98:	f7ff f99c 	bl	100d4 <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   10d9c:	70ac      	strb	r4, [r5, #2]
  RECORD_END();
   10d9e:	f386 8811 	msr	BASEPRI, r6
}
   10da2:	b005      	add	sp, #20
   10da4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   10da6:	782b      	ldrb	r3, [r5, #0]
   10da8:	3301      	adds	r3, #1
   10daa:	702b      	strb	r3, [r5, #0]
   10dac:	e7c3      	b.n	10d36 <SEGGER_SYSVIEW_OnTaskStartExec+0x36>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10dae:	696a      	ldr	r2, [r5, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   10db0:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10db2:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   10db4:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10db8:	f10d 0305 	add.w	r3, sp, #5
   10dbc:	d906      	bls.n	10dcc <SEGGER_SYSVIEW_OnTaskStartExec+0xcc>
   10dbe:	f062 017f 	orn	r1, r2, #127	; 0x7f
   10dc2:	09d2      	lsrs	r2, r2, #7
   10dc4:	2a7f      	cmp	r2, #127	; 0x7f
   10dc6:	f803 1b01 	strb.w	r1, [r3], #1
   10dca:	d8f8      	bhi.n	10dbe <SEGGER_SYSVIEW_OnTaskStartExec+0xbe>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10dcc:	4917      	ldr	r1, [pc, #92]	; (10e2c <SEGGER_SYSVIEW_OnTaskStartExec+0x12c>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10dce:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10dd0:	680f      	ldr	r7, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   10dd2:	68e9      	ldr	r1, [r5, #12]
   10dd4:	1a79      	subs	r1, r7, r1
  ENCODE_U32(pPayload, Delta);
   10dd6:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10dd8:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   10ddc:	d906      	bls.n	10dec <SEGGER_SYSVIEW_OnTaskStartExec+0xec>
   10dde:	f061 037f 	orn	r3, r1, #127	; 0x7f
   10de2:	09c9      	lsrs	r1, r1, #7
   10de4:	297f      	cmp	r1, #127	; 0x7f
   10de6:	f802 3b01 	strb.w	r3, [r2], #1
   10dea:	d8f8      	bhi.n	10dde <SEGGER_SYSVIEW_OnTaskStartExec+0xde>
   10dec:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   10dee:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   10df0:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   10df4:	2001      	movs	r0, #1
   10df6:	4611      	mov	r1, r2
   10df8:	1a9a      	subs	r2, r3, r2
   10dfa:	f7fe ff43 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   10dfe:	b930      	cbnz	r0, 10e0e <SEGGER_SYSVIEW_OnTaskStartExec+0x10e>
    _SYSVIEW_Globals.DropCount++;
   10e00:	696a      	ldr	r2, [r5, #20]
   10e02:	782b      	ldrb	r3, [r5, #0]
   10e04:	3201      	adds	r2, #1
   10e06:	616a      	str	r2, [r5, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   10e08:	2b01      	cmp	r3, #1
   10e0a:	d194      	bne.n	10d36 <SEGGER_SYSVIEW_OnTaskStartExec+0x36>
   10e0c:	e7a2      	b.n	10d54 <SEGGER_SYSVIEW_OnTaskStartExec+0x54>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   10e0e:	782b      	ldrb	r3, [r5, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   10e10:	60ef      	str	r7, [r5, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   10e12:	3b01      	subs	r3, #1
   10e14:	b2db      	uxtb	r3, r3
   10e16:	702b      	strb	r3, [r5, #0]
   10e18:	e7f6      	b.n	10e08 <SEGGER_SYSVIEW_OnTaskStartExec+0x108>
   10e1a:	bf00      	nop
   10e1c:	1001322c 	.word	0x1001322c
   10e20:	10014258 	.word	0x10014258
   10e24:	10014404 	.word	0x10014404
   10e28:	10014254 	.word	0x10014254
   10e2c:	e0001004 	.word	0xe0001004
   10e30:	10014257 	.word	0x10014257

00010e34 <SEGGER_SYSVIEW_OnTaskStartReady>:
void SEGGER_SYSVIEW_OnTaskStartReady(U32 TaskId) {
   10e34:	b5f0      	push	{r4, r5, r6, r7, lr}
   10e36:	b085      	sub	sp, #20
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
   10e38:	f3ef 8611 	mrs	r6, BASEPRI
   10e3c:	f04f 0120 	mov.w	r1, #32
   10e40:	f381 8811 	msr	BASEPRI, r1
  TaskId = SHRINK_ID(TaskId);
   10e44:	4d42      	ldr	r5, [pc, #264]	; (10f50 <SEGGER_SYSVIEW_OnTaskStartReady+0x11c>)
  ENCODE_U32(pPayload, TaskId);
   10e46:	4c43      	ldr	r4, [pc, #268]	; (10f54 <SEGGER_SYSVIEW_OnTaskStartReady+0x120>)
  TaskId = SHRINK_ID(TaskId);
   10e48:	692b      	ldr	r3, [r5, #16]
   10e4a:	1ac0      	subs	r0, r0, r3
   10e4c:	0880      	lsrs	r0, r0, #2
  ENCODE_U32(pPayload, TaskId);
   10e4e:	287f      	cmp	r0, #127	; 0x7f
   10e50:	d906      	bls.n	10e60 <SEGGER_SYSVIEW_OnTaskStartReady+0x2c>
   10e52:	f060 037f 	orn	r3, r0, #127	; 0x7f
   10e56:	09c0      	lsrs	r0, r0, #7
   10e58:	287f      	cmp	r0, #127	; 0x7f
   10e5a:	f804 3b01 	strb.w	r3, [r4], #1
   10e5e:	d8f8      	bhi.n	10e52 <SEGGER_SYSVIEW_OnTaskStartReady+0x1e>
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   10e60:	782b      	ldrb	r3, [r5, #0]
  ENCODE_U32(pPayload, TaskId);
   10e62:	7020      	strb	r0, [r4, #0]
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   10e64:	2b01      	cmp	r3, #1
   10e66:	d00f      	beq.n	10e88 <SEGGER_SYSVIEW_OnTaskStartReady+0x54>
  if (_SYSVIEW_Globals.EnableState == 0) {
   10e68:	b963      	cbnz	r3, 10e84 <SEGGER_SYSVIEW_OnTaskStartReady+0x50>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   10e6a:	4b3b      	ldr	r3, [pc, #236]	; (10f58 <SEGGER_SYSVIEW_OnTaskStartReady+0x124>)
   10e6c:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   10e70:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   10e74:	429a      	cmp	r2, r3
   10e76:	d001      	beq.n	10e7c <SEGGER_SYSVIEW_OnTaskStartReady+0x48>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   10e78:	78ac      	ldrb	r4, [r5, #2]
   10e7a:	b32c      	cbz	r4, 10ec8 <SEGGER_SYSVIEW_OnTaskStartReady+0x94>
  RECORD_END();
   10e7c:	f386 8811 	msr	BASEPRI, r6
}
   10e80:	b005      	add	sp, #20
   10e82:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   10e84:	2b02      	cmp	r3, #2
   10e86:	d02c      	beq.n	10ee2 <SEGGER_SYSVIEW_OnTaskStartReady+0xae>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   10e88:	69eb      	ldr	r3, [r5, #28]
   10e8a:	065b      	lsls	r3, r3, #25
   10e8c:	d4ed      	bmi.n	10e6a <SEGGER_SYSVIEW_OnTaskStartReady+0x36>
    *--pStartPacket = EventId;
   10e8e:	4a33      	ldr	r2, [pc, #204]	; (10f5c <SEGGER_SYSVIEW_OnTaskStartReady+0x128>)
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10e90:	4b33      	ldr	r3, [pc, #204]	; (10f60 <SEGGER_SYSVIEW_OnTaskStartReady+0x12c>)
    *--pStartPacket = EventId;
   10e92:	2106      	movs	r1, #6
   10e94:	70d1      	strb	r1, [r2, #3]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10e96:	681f      	ldr	r7, [r3, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   10e98:	68eb      	ldr	r3, [r5, #12]
   10e9a:	1afb      	subs	r3, r7, r3
  ENCODE_U32(pEndPacket, Delta);
   10e9c:	2b7f      	cmp	r3, #127	; 0x7f
  ENCODE_U32(pPayload, TaskId);
   10e9e:	f104 0201 	add.w	r2, r4, #1
  ENCODE_U32(pEndPacket, Delta);
   10ea2:	d906      	bls.n	10eb2 <SEGGER_SYSVIEW_OnTaskStartReady+0x7e>
   10ea4:	f063 017f 	orn	r1, r3, #127	; 0x7f
   10ea8:	09db      	lsrs	r3, r3, #7
   10eaa:	2b7f      	cmp	r3, #127	; 0x7f
   10eac:	f802 1b01 	strb.w	r1, [r2], #1
   10eb0:	d8f8      	bhi.n	10ea4 <SEGGER_SYSVIEW_OnTaskStartReady+0x70>
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   10eb2:	482c      	ldr	r0, [pc, #176]	; (10f64 <SEGGER_SYSVIEW_OnTaskStartReady+0x130>)
  ENCODE_U32(pEndPacket, Delta);
   10eb4:	f802 3b01 	strb.w	r3, [r2], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   10eb8:	4601      	mov	r1, r0
   10eba:	1a12      	subs	r2, r2, r0
   10ebc:	2001      	movs	r0, #1
   10ebe:	f7fe fee1 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   10ec2:	b150      	cbz	r0, 10eda <SEGGER_SYSVIEW_OnTaskStartReady+0xa6>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   10ec4:	60ef      	str	r7, [r5, #12]
   10ec6:	e7d0      	b.n	10e6a <SEGGER_SYSVIEW_OnTaskStartReady+0x36>
      _SYSVIEW_Globals.RecursionCnt = 1;
   10ec8:	2301      	movs	r3, #1
   10eca:	70ab      	strb	r3, [r5, #2]
      _HandleIncomingPacket();
   10ecc:	f7ff f902 	bl	100d4 <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   10ed0:	70ac      	strb	r4, [r5, #2]
  RECORD_END();
   10ed2:	f386 8811 	msr	BASEPRI, r6
}
   10ed6:	b005      	add	sp, #20
   10ed8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   10eda:	782b      	ldrb	r3, [r5, #0]
   10edc:	3301      	adds	r3, #1
   10ede:	702b      	strb	r3, [r5, #0]
   10ee0:	e7c3      	b.n	10e6a <SEGGER_SYSVIEW_OnTaskStartReady+0x36>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10ee2:	696a      	ldr	r2, [r5, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   10ee4:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10ee6:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   10ee8:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10eec:	f10d 0305 	add.w	r3, sp, #5
   10ef0:	d906      	bls.n	10f00 <SEGGER_SYSVIEW_OnTaskStartReady+0xcc>
   10ef2:	f062 017f 	orn	r1, r2, #127	; 0x7f
   10ef6:	09d2      	lsrs	r2, r2, #7
   10ef8:	2a7f      	cmp	r2, #127	; 0x7f
   10efa:	f803 1b01 	strb.w	r1, [r3], #1
   10efe:	d8f8      	bhi.n	10ef2 <SEGGER_SYSVIEW_OnTaskStartReady+0xbe>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10f00:	4917      	ldr	r1, [pc, #92]	; (10f60 <SEGGER_SYSVIEW_OnTaskStartReady+0x12c>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10f02:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10f04:	680f      	ldr	r7, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   10f06:	68e9      	ldr	r1, [r5, #12]
   10f08:	1a79      	subs	r1, r7, r1
  ENCODE_U32(pPayload, Delta);
   10f0a:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10f0c:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   10f10:	d906      	bls.n	10f20 <SEGGER_SYSVIEW_OnTaskStartReady+0xec>
   10f12:	f061 037f 	orn	r3, r1, #127	; 0x7f
   10f16:	09c9      	lsrs	r1, r1, #7
   10f18:	297f      	cmp	r1, #127	; 0x7f
   10f1a:	f802 3b01 	strb.w	r3, [r2], #1
   10f1e:	d8f8      	bhi.n	10f12 <SEGGER_SYSVIEW_OnTaskStartReady+0xde>
   10f20:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   10f22:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   10f24:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   10f28:	2001      	movs	r0, #1
   10f2a:	4611      	mov	r1, r2
   10f2c:	1a9a      	subs	r2, r3, r2
   10f2e:	f7fe fea9 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   10f32:	b930      	cbnz	r0, 10f42 <SEGGER_SYSVIEW_OnTaskStartReady+0x10e>
    _SYSVIEW_Globals.DropCount++;
   10f34:	696a      	ldr	r2, [r5, #20]
   10f36:	782b      	ldrb	r3, [r5, #0]
   10f38:	3201      	adds	r2, #1
   10f3a:	616a      	str	r2, [r5, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   10f3c:	2b01      	cmp	r3, #1
   10f3e:	d194      	bne.n	10e6a <SEGGER_SYSVIEW_OnTaskStartReady+0x36>
   10f40:	e7a2      	b.n	10e88 <SEGGER_SYSVIEW_OnTaskStartReady+0x54>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   10f42:	782b      	ldrb	r3, [r5, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   10f44:	60ef      	str	r7, [r5, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   10f46:	3b01      	subs	r3, #1
   10f48:	b2db      	uxtb	r3, r3
   10f4a:	702b      	strb	r3, [r5, #0]
   10f4c:	e7f6      	b.n	10f3c <SEGGER_SYSVIEW_OnTaskStartReady+0x108>
   10f4e:	bf00      	nop
   10f50:	1001322c 	.word	0x1001322c
   10f54:	10014258 	.word	0x10014258
   10f58:	10014404 	.word	0x10014404
   10f5c:	10014254 	.word	0x10014254
   10f60:	e0001004 	.word	0xe0001004
   10f64:	10014257 	.word	0x10014257

00010f68 <SEGGER_SYSVIEW_OnTaskStopReady>:
void SEGGER_SYSVIEW_OnTaskStopReady(U32 TaskId, unsigned int Cause) {
   10f68:	b5f0      	push	{r4, r5, r6, r7, lr}
   10f6a:	460b      	mov	r3, r1
   10f6c:	b085      	sub	sp, #20
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
   10f6e:	f3ef 8511 	mrs	r5, BASEPRI
   10f72:	f04f 0120 	mov.w	r1, #32
   10f76:	f381 8811 	msr	BASEPRI, r1
  TaskId = SHRINK_ID(TaskId);
   10f7a:	4c48      	ldr	r4, [pc, #288]	; (1109c <SEGGER_SYSVIEW_OnTaskStopReady+0x134>)
  ENCODE_U32(pPayload, TaskId);
   10f7c:	4e48      	ldr	r6, [pc, #288]	; (110a0 <SEGGER_SYSVIEW_OnTaskStopReady+0x138>)
  TaskId = SHRINK_ID(TaskId);
   10f7e:	6922      	ldr	r2, [r4, #16]
   10f80:	1a80      	subs	r0, r0, r2
   10f82:	0880      	lsrs	r0, r0, #2
  ENCODE_U32(pPayload, TaskId);
   10f84:	287f      	cmp	r0, #127	; 0x7f
   10f86:	d906      	bls.n	10f96 <SEGGER_SYSVIEW_OnTaskStopReady+0x2e>
   10f88:	f060 017f 	orn	r1, r0, #127	; 0x7f
   10f8c:	09c0      	lsrs	r0, r0, #7
   10f8e:	287f      	cmp	r0, #127	; 0x7f
   10f90:	f806 1b01 	strb.w	r1, [r6], #1
   10f94:	d8f8      	bhi.n	10f88 <SEGGER_SYSVIEW_OnTaskStopReady+0x20>
  ENCODE_U32(pPayload, Cause);
   10f96:	2b7f      	cmp	r3, #127	; 0x7f
  ENCODE_U32(pPayload, TaskId);
   10f98:	7030      	strb	r0, [r6, #0]
   10f9a:	f106 0601 	add.w	r6, r6, #1
  ENCODE_U32(pPayload, Cause);
   10f9e:	d906      	bls.n	10fae <SEGGER_SYSVIEW_OnTaskStopReady+0x46>
   10fa0:	f063 027f 	orn	r2, r3, #127	; 0x7f
   10fa4:	09db      	lsrs	r3, r3, #7
   10fa6:	2b7f      	cmp	r3, #127	; 0x7f
   10fa8:	f806 2b01 	strb.w	r2, [r6], #1
   10fac:	d8f8      	bhi.n	10fa0 <SEGGER_SYSVIEW_OnTaskStopReady+0x38>
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   10fae:	7822      	ldrb	r2, [r4, #0]
  ENCODE_U32(pPayload, Cause);
   10fb0:	7033      	strb	r3, [r6, #0]
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   10fb2:	2a01      	cmp	r2, #1
   10fb4:	d00f      	beq.n	10fd6 <SEGGER_SYSVIEW_OnTaskStopReady+0x6e>
  if (_SYSVIEW_Globals.EnableState == 0) {
   10fb6:	b962      	cbnz	r2, 10fd2 <SEGGER_SYSVIEW_OnTaskStopReady+0x6a>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   10fb8:	4b3a      	ldr	r3, [pc, #232]	; (110a4 <SEGGER_SYSVIEW_OnTaskStopReady+0x13c>)
   10fba:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   10fbe:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   10fc2:	429a      	cmp	r2, r3
   10fc4:	d001      	beq.n	10fca <SEGGER_SYSVIEW_OnTaskStopReady+0x62>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   10fc6:	78a6      	ldrb	r6, [r4, #2]
   10fc8:	b32e      	cbz	r6, 11016 <SEGGER_SYSVIEW_OnTaskStopReady+0xae>
  RECORD_END();
   10fca:	f385 8811 	msr	BASEPRI, r5
}
   10fce:	b005      	add	sp, #20
   10fd0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   10fd2:	2a02      	cmp	r2, #2
   10fd4:	d02c      	beq.n	11030 <SEGGER_SYSVIEW_OnTaskStopReady+0xc8>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   10fd6:	69e3      	ldr	r3, [r4, #28]
   10fd8:	061b      	lsls	r3, r3, #24
   10fda:	d4ed      	bmi.n	10fb8 <SEGGER_SYSVIEW_OnTaskStopReady+0x50>
    *--pStartPacket = EventId;
   10fdc:	4a32      	ldr	r2, [pc, #200]	; (110a8 <SEGGER_SYSVIEW_OnTaskStopReady+0x140>)
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10fde:	4b33      	ldr	r3, [pc, #204]	; (110ac <SEGGER_SYSVIEW_OnTaskStopReady+0x144>)
    *--pStartPacket = EventId;
   10fe0:	2107      	movs	r1, #7
   10fe2:	70d1      	strb	r1, [r2, #3]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10fe4:	681f      	ldr	r7, [r3, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   10fe6:	68e3      	ldr	r3, [r4, #12]
   10fe8:	1afb      	subs	r3, r7, r3
  ENCODE_U32(pEndPacket, Delta);
   10fea:	2b7f      	cmp	r3, #127	; 0x7f
  ENCODE_U32(pPayload, Cause);
   10fec:	f106 0201 	add.w	r2, r6, #1
  ENCODE_U32(pEndPacket, Delta);
   10ff0:	d906      	bls.n	11000 <SEGGER_SYSVIEW_OnTaskStopReady+0x98>
   10ff2:	f063 017f 	orn	r1, r3, #127	; 0x7f
   10ff6:	09db      	lsrs	r3, r3, #7
   10ff8:	2b7f      	cmp	r3, #127	; 0x7f
   10ffa:	f802 1b01 	strb.w	r1, [r2], #1
   10ffe:	d8f8      	bhi.n	10ff2 <SEGGER_SYSVIEW_OnTaskStopReady+0x8a>
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   11000:	482b      	ldr	r0, [pc, #172]	; (110b0 <SEGGER_SYSVIEW_OnTaskStopReady+0x148>)
  ENCODE_U32(pEndPacket, Delta);
   11002:	f802 3b01 	strb.w	r3, [r2], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   11006:	4601      	mov	r1, r0
   11008:	1a12      	subs	r2, r2, r0
   1100a:	2001      	movs	r0, #1
   1100c:	f7fe fe3a 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   11010:	b150      	cbz	r0, 11028 <SEGGER_SYSVIEW_OnTaskStopReady+0xc0>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   11012:	60e7      	str	r7, [r4, #12]
   11014:	e7d0      	b.n	10fb8 <SEGGER_SYSVIEW_OnTaskStopReady+0x50>
      _SYSVIEW_Globals.RecursionCnt = 1;
   11016:	2301      	movs	r3, #1
   11018:	70a3      	strb	r3, [r4, #2]
      _HandleIncomingPacket();
   1101a:	f7ff f85b 	bl	100d4 <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   1101e:	70a6      	strb	r6, [r4, #2]
  RECORD_END();
   11020:	f385 8811 	msr	BASEPRI, r5
}
   11024:	b005      	add	sp, #20
   11026:	bdf0      	pop	{r4, r5, r6, r7, pc}
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   11028:	7823      	ldrb	r3, [r4, #0]
   1102a:	3301      	adds	r3, #1
   1102c:	7023      	strb	r3, [r4, #0]
   1102e:	e7c3      	b.n	10fb8 <SEGGER_SYSVIEW_OnTaskStopReady+0x50>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11030:	6962      	ldr	r2, [r4, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   11032:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11034:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   11036:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   1103a:	f10d 0305 	add.w	r3, sp, #5
   1103e:	d906      	bls.n	1104e <SEGGER_SYSVIEW_OnTaskStopReady+0xe6>
   11040:	f062 017f 	orn	r1, r2, #127	; 0x7f
   11044:	09d2      	lsrs	r2, r2, #7
   11046:	2a7f      	cmp	r2, #127	; 0x7f
   11048:	f803 1b01 	strb.w	r1, [r3], #1
   1104c:	d8f8      	bhi.n	11040 <SEGGER_SYSVIEW_OnTaskStopReady+0xd8>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   1104e:	4917      	ldr	r1, [pc, #92]	; (110ac <SEGGER_SYSVIEW_OnTaskStopReady+0x144>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11050:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11052:	680f      	ldr	r7, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11054:	68e1      	ldr	r1, [r4, #12]
   11056:	1a79      	subs	r1, r7, r1
  ENCODE_U32(pPayload, Delta);
   11058:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   1105a:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   1105e:	d906      	bls.n	1106e <SEGGER_SYSVIEW_OnTaskStopReady+0x106>
   11060:	f061 037f 	orn	r3, r1, #127	; 0x7f
   11064:	09c9      	lsrs	r1, r1, #7
   11066:	297f      	cmp	r1, #127	; 0x7f
   11068:	f802 3b01 	strb.w	r3, [r2], #1
   1106c:	d8f8      	bhi.n	11060 <SEGGER_SYSVIEW_OnTaskStopReady+0xf8>
   1106e:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   11070:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   11072:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   11076:	2001      	movs	r0, #1
   11078:	4611      	mov	r1, r2
   1107a:	1a9a      	subs	r2, r3, r2
   1107c:	f7fe fe02 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   11080:	b930      	cbnz	r0, 11090 <SEGGER_SYSVIEW_OnTaskStopReady+0x128>
    _SYSVIEW_Globals.DropCount++;
   11082:	6962      	ldr	r2, [r4, #20]
   11084:	7823      	ldrb	r3, [r4, #0]
   11086:	3201      	adds	r2, #1
   11088:	6162      	str	r2, [r4, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   1108a:	2b01      	cmp	r3, #1
   1108c:	d194      	bne.n	10fb8 <SEGGER_SYSVIEW_OnTaskStopReady+0x50>
   1108e:	e7a2      	b.n	10fd6 <SEGGER_SYSVIEW_OnTaskStopReady+0x6e>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   11090:	7823      	ldrb	r3, [r4, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   11092:	60e7      	str	r7, [r4, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   11094:	3b01      	subs	r3, #1
   11096:	b2db      	uxtb	r3, r3
   11098:	7023      	strb	r3, [r4, #0]
   1109a:	e7f6      	b.n	1108a <SEGGER_SYSVIEW_OnTaskStopReady+0x122>
   1109c:	1001322c 	.word	0x1001322c
   110a0:	10014258 	.word	0x10014258
   110a4:	10014404 	.word	0x10014404
   110a8:	10014254 	.word	0x10014254
   110ac:	e0001004 	.word	0xe0001004
   110b0:	10014257 	.word	0x10014257

000110b4 <SEGGER_SYSVIEW_SendPacket>:
int SEGGER_SYSVIEW_SendPacket(U8* pPacket, U8* pPayloadEnd, unsigned int EventId) {
   110b4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   110b8:	4606      	mov	r6, r0
   110ba:	b085      	sub	sp, #20
   110bc:	460c      	mov	r4, r1
   110be:	4690      	mov	r8, r2
  SEGGER_SYSVIEW_LOCK();
   110c0:	f3ef 8711 	mrs	r7, BASEPRI
   110c4:	f04f 0120 	mov.w	r1, #32
   110c8:	f381 8811 	msr	BASEPRI, r1
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   110cc:	4d54      	ldr	r5, [pc, #336]	; (11220 <SEGGER_SYSVIEW_SendPacket+0x16c>)
   110ce:	782b      	ldrb	r3, [r5, #0]
   110d0:	2b01      	cmp	r3, #1
   110d2:	d012      	beq.n	110fa <SEGGER_SYSVIEW_SendPacket+0x46>
  if (_SYSVIEW_Globals.EnableState == 0) {
   110d4:	b97b      	cbnz	r3, 110f6 <SEGGER_SYSVIEW_SendPacket+0x42>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   110d6:	4b53      	ldr	r3, [pc, #332]	; (11224 <SEGGER_SYSVIEW_SendPacket+0x170>)
   110d8:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   110dc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   110e0:	429a      	cmp	r2, r3
   110e2:	d002      	beq.n	110ea <SEGGER_SYSVIEW_SendPacket+0x36>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   110e4:	78ac      	ldrb	r4, [r5, #2]
   110e6:	2c00      	cmp	r4, #0
   110e8:	d046      	beq.n	11178 <SEGGER_SYSVIEW_SendPacket+0xc4>
  SEGGER_SYSVIEW_UNLOCK();
   110ea:	f387 8811 	msr	BASEPRI, r7
}
   110ee:	2000      	movs	r0, #0
   110f0:	b005      	add	sp, #20
   110f2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   110f6:	2b02      	cmp	r3, #2
   110f8:	d053      	beq.n	111a2 <SEGGER_SYSVIEW_SendPacket+0xee>
  if (EventId < 32) {
   110fa:	f1b8 0f1f 	cmp.w	r8, #31
   110fe:	d917      	bls.n	11130 <SEGGER_SYSVIEW_SendPacket+0x7c>
   11100:	fa5f f188 	uxtb.w	r1, r8
  _SendPacket(pPacket + 4, pPayloadEnd, EventId);
   11104:	1d33      	adds	r3, r6, #4
    NumBytes = pEndPacket - pStartPacket;
   11106:	1ae3      	subs	r3, r4, r3
    if (NumBytes > 127) {
   11108:	2b7f      	cmp	r3, #127	; 0x7f
   1110a:	b2da      	uxtb	r2, r3
   1110c:	d83a      	bhi.n	11184 <SEGGER_SYSVIEW_SendPacket+0xd0>
      *--pStartPacket = NumBytes;
   1110e:	4613      	mov	r3, r2
    if (EventId > 127) {
   11110:	f1b8 0f7f 	cmp.w	r8, #127	; 0x7f
      *--pStartPacket = NumBytes;
   11114:	f106 0203 	add.w	r2, r6, #3
   11118:	70f3      	strb	r3, [r6, #3]
    if (EventId > 127) {
   1111a:	d93e      	bls.n	1119a <SEGGER_SYSVIEW_SendPacket+0xe6>
      *--pStartPacket = (EventId >> 7);
   1111c:	ea4f 18d8 	mov.w	r8, r8, lsr #7
      *--pStartPacket = EventId | 0x80;
   11120:	f061 017f 	orn	r1, r1, #127	; 0x7f
      *--pStartPacket = (EventId >> 7);
   11124:	f802 8c01 	strb.w	r8, [r2, #-1]
      *--pStartPacket = EventId | 0x80;
   11128:	f802 1c02 	strb.w	r1, [r2, #-2]
   1112c:	3a02      	subs	r2, #2
   1112e:	e00b      	b.n	11148 <SEGGER_SYSVIEW_SendPacket+0x94>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   11130:	69eb      	ldr	r3, [r5, #28]
   11132:	fa23 f308 	lsr.w	r3, r3, r8
   11136:	07db      	lsls	r3, r3, #31
   11138:	d4cd      	bmi.n	110d6 <SEGGER_SYSVIEW_SendPacket+0x22>
  if (EventId < 24) {
   1113a:	f1b8 0f17 	cmp.w	r8, #23
   1113e:	fa5f f188 	uxtb.w	r1, r8
   11142:	d8df      	bhi.n	11104 <SEGGER_SYSVIEW_SendPacket+0x50>
    *--pStartPacket = EventId;
   11144:	70f1      	strb	r1, [r6, #3]
   11146:	1cf2      	adds	r2, r6, #3
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11148:	4937      	ldr	r1, [pc, #220]	; (11228 <SEGGER_SYSVIEW_SendPacket+0x174>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   1114a:	68eb      	ldr	r3, [r5, #12]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   1114c:	680e      	ldr	r6, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   1114e:	1af3      	subs	r3, r6, r3
  ENCODE_U32(pEndPacket, Delta);
   11150:	2b7f      	cmp	r3, #127	; 0x7f
   11152:	d906      	bls.n	11162 <SEGGER_SYSVIEW_SendPacket+0xae>
   11154:	f063 017f 	orn	r1, r3, #127	; 0x7f
   11158:	09db      	lsrs	r3, r3, #7
   1115a:	2b7f      	cmp	r3, #127	; 0x7f
   1115c:	f804 1b01 	strb.w	r1, [r4], #1
   11160:	d8f8      	bhi.n	11154 <SEGGER_SYSVIEW_SendPacket+0xa0>
   11162:	f804 3b01 	strb.w	r3, [r4], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   11166:	4611      	mov	r1, r2
   11168:	2001      	movs	r0, #1
   1116a:	1aa2      	subs	r2, r4, r2
   1116c:	f7fe fd8a 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   11170:	2800      	cmp	r0, #0
   11172:	d049      	beq.n	11208 <SEGGER_SYSVIEW_SendPacket+0x154>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   11174:	60ee      	str	r6, [r5, #12]
   11176:	e7ae      	b.n	110d6 <SEGGER_SYSVIEW_SendPacket+0x22>
      _SYSVIEW_Globals.RecursionCnt = 1;
   11178:	2301      	movs	r3, #1
   1117a:	70ab      	strb	r3, [r5, #2]
      _HandleIncomingPacket();
   1117c:	f7fe ffaa 	bl	100d4 <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   11180:	70ac      	strb	r4, [r5, #2]
   11182:	e7b2      	b.n	110ea <SEGGER_SYSVIEW_SendPacket+0x36>
      *--pStartPacket = NumBytes | 0x80;
   11184:	f062 027f 	orn	r2, r2, #127	; 0x7f
      *--pStartPacket = (NumBytes >> 7);
   11188:	f3c3 13c7 	ubfx	r3, r3, #7, #8
    if (EventId > 127) {
   1118c:	f1b8 0f7f 	cmp.w	r8, #127	; 0x7f
      *--pStartPacket = NumBytes | 0x80;
   11190:	70b2      	strb	r2, [r6, #2]
   11192:	70f3      	strb	r3, [r6, #3]
   11194:	f106 0202 	add.w	r2, r6, #2
    if (EventId > 127) {
   11198:	d8c0      	bhi.n	1111c <SEGGER_SYSVIEW_SendPacket+0x68>
      *--pStartPacket = EventId;
   1119a:	f802 1c01 	strb.w	r1, [r2, #-1]
   1119e:	3a01      	subs	r2, #1
   111a0:	e7d2      	b.n	11148 <SEGGER_SYSVIEW_SendPacket+0x94>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   111a2:	696a      	ldr	r2, [r5, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   111a4:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   111a6:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   111a8:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   111ac:	f10d 0305 	add.w	r3, sp, #5
   111b0:	d906      	bls.n	111c0 <SEGGER_SYSVIEW_SendPacket+0x10c>
   111b2:	f062 017f 	orn	r1, r2, #127	; 0x7f
   111b6:	09d2      	lsrs	r2, r2, #7
   111b8:	2a7f      	cmp	r2, #127	; 0x7f
   111ba:	f803 1b01 	strb.w	r1, [r3], #1
   111be:	d8f8      	bhi.n	111b2 <SEGGER_SYSVIEW_SendPacket+0xfe>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   111c0:	4919      	ldr	r1, [pc, #100]	; (11228 <SEGGER_SYSVIEW_SendPacket+0x174>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   111c2:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   111c4:	f8d1 9000 	ldr.w	r9, [r1]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   111c8:	68e9      	ldr	r1, [r5, #12]
   111ca:	eba9 0101 	sub.w	r1, r9, r1
  ENCODE_U32(pPayload, Delta);
   111ce:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   111d0:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   111d4:	d906      	bls.n	111e4 <SEGGER_SYSVIEW_SendPacket+0x130>
   111d6:	f061 037f 	orn	r3, r1, #127	; 0x7f
   111da:	09c9      	lsrs	r1, r1, #7
   111dc:	297f      	cmp	r1, #127	; 0x7f
   111de:	f802 3b01 	strb.w	r3, [r2], #1
   111e2:	d8f8      	bhi.n	111d6 <SEGGER_SYSVIEW_SendPacket+0x122>
   111e4:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   111e6:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   111e8:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   111ec:	2001      	movs	r0, #1
   111ee:	4611      	mov	r1, r2
   111f0:	1a9a      	subs	r2, r3, r2
   111f2:	f7fe fd47 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   111f6:	b958      	cbnz	r0, 11210 <SEGGER_SYSVIEW_SendPacket+0x15c>
    _SYSVIEW_Globals.DropCount++;
   111f8:	696a      	ldr	r2, [r5, #20]
   111fa:	782b      	ldrb	r3, [r5, #0]
   111fc:	3201      	adds	r2, #1
   111fe:	616a      	str	r2, [r5, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   11200:	2b01      	cmp	r3, #1
   11202:	f47f af68 	bne.w	110d6 <SEGGER_SYSVIEW_SendPacket+0x22>
   11206:	e778      	b.n	110fa <SEGGER_SYSVIEW_SendPacket+0x46>
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   11208:	782b      	ldrb	r3, [r5, #0]
   1120a:	3301      	adds	r3, #1
   1120c:	702b      	strb	r3, [r5, #0]
   1120e:	e762      	b.n	110d6 <SEGGER_SYSVIEW_SendPacket+0x22>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   11210:	782b      	ldrb	r3, [r5, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   11212:	f8c5 900c 	str.w	r9, [r5, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   11216:	3b01      	subs	r3, #1
   11218:	b2db      	uxtb	r3, r3
   1121a:	702b      	strb	r3, [r5, #0]
   1121c:	e7f0      	b.n	11200 <SEGGER_SYSVIEW_SendPacket+0x14c>
   1121e:	bf00      	nop
   11220:	1001322c 	.word	0x1001322c
   11224:	10014404 	.word	0x10014404
   11228:	e0001004 	.word	0xe0001004

0001122c <SEGGER_SYSVIEW_RecordU32x3>:
void SEGGER_SYSVIEW_RecordU32x3(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2) {
   1122c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   11230:	4606      	mov	r6, r0
   11232:	b085      	sub	sp, #20
   11234:	4608      	mov	r0, r1
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 3 * SEGGER_SYSVIEW_QUANTA_U32);
   11236:	f3ef 8511 	mrs	r5, BASEPRI
   1123a:	f04f 0120 	mov.w	r1, #32
   1123e:	f381 8811 	msr	BASEPRI, r1
  ENCODE_U32(pPayload, Para0);
   11242:	4f6e      	ldr	r7, [pc, #440]	; (113fc <SEGGER_SYSVIEW_RecordU32x3+0x1d0>)
   11244:	287f      	cmp	r0, #127	; 0x7f
   11246:	4639      	mov	r1, r7
   11248:	d906      	bls.n	11258 <SEGGER_SYSVIEW_RecordU32x3+0x2c>
   1124a:	f060 047f 	orn	r4, r0, #127	; 0x7f
   1124e:	09c0      	lsrs	r0, r0, #7
   11250:	287f      	cmp	r0, #127	; 0x7f
   11252:	f801 4b01 	strb.w	r4, [r1], #1
   11256:	d8f8      	bhi.n	1124a <SEGGER_SYSVIEW_RecordU32x3+0x1e>
  ENCODE_U32(pPayload, Para1);
   11258:	2a7f      	cmp	r2, #127	; 0x7f
  ENCODE_U32(pPayload, Para0);
   1125a:	7008      	strb	r0, [r1, #0]
   1125c:	f101 0101 	add.w	r1, r1, #1
  ENCODE_U32(pPayload, Para1);
   11260:	d906      	bls.n	11270 <SEGGER_SYSVIEW_RecordU32x3+0x44>
   11262:	f062 007f 	orn	r0, r2, #127	; 0x7f
   11266:	09d2      	lsrs	r2, r2, #7
   11268:	2a7f      	cmp	r2, #127	; 0x7f
   1126a:	f801 0b01 	strb.w	r0, [r1], #1
   1126e:	d8f8      	bhi.n	11262 <SEGGER_SYSVIEW_RecordU32x3+0x36>
  ENCODE_U32(pPayload, Para2);
   11270:	2b7f      	cmp	r3, #127	; 0x7f
  ENCODE_U32(pPayload, Para1);
   11272:	700a      	strb	r2, [r1, #0]
   11274:	f101 0401 	add.w	r4, r1, #1
  ENCODE_U32(pPayload, Para2);
   11278:	d906      	bls.n	11288 <SEGGER_SYSVIEW_RecordU32x3+0x5c>
   1127a:	f063 027f 	orn	r2, r3, #127	; 0x7f
   1127e:	09db      	lsrs	r3, r3, #7
   11280:	2b7f      	cmp	r3, #127	; 0x7f
   11282:	f804 2b01 	strb.w	r2, [r4], #1
   11286:	d8f8      	bhi.n	1127a <SEGGER_SYSVIEW_RecordU32x3+0x4e>
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   11288:	f8df 8180 	ldr.w	r8, [pc, #384]	; 1140c <SEGGER_SYSVIEW_RecordU32x3+0x1e0>
  ENCODE_U32(pPayload, Para2);
   1128c:	7023      	strb	r3, [r4, #0]
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   1128e:	f898 3000 	ldrb.w	r3, [r8]
   11292:	2b01      	cmp	r3, #1
   11294:	d012      	beq.n	112bc <SEGGER_SYSVIEW_RecordU32x3+0x90>
  if (_SYSVIEW_Globals.EnableState == 0) {
   11296:	b97b      	cbnz	r3, 112b8 <SEGGER_SYSVIEW_RecordU32x3+0x8c>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   11298:	4b59      	ldr	r3, [pc, #356]	; (11400 <SEGGER_SYSVIEW_RecordU32x3+0x1d4>)
   1129a:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   1129e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   112a2:	429a      	cmp	r2, r3
   112a4:	d003      	beq.n	112ae <SEGGER_SYSVIEW_RecordU32x3+0x82>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   112a6:	f898 4002 	ldrb.w	r4, [r8, #2]
   112aa:	2c00      	cmp	r4, #0
   112ac:	d044      	beq.n	11338 <SEGGER_SYSVIEW_RecordU32x3+0x10c>
  RECORD_END();
   112ae:	f385 8811 	msr	BASEPRI, r5
}
   112b2:	b005      	add	sp, #20
   112b4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   112b8:	2b02      	cmp	r3, #2
   112ba:	d057      	beq.n	1136c <SEGGER_SYSVIEW_RecordU32x3+0x140>
  if (EventId < 32) {
   112bc:	2e1f      	cmp	r6, #31
  ENCODE_U32(pPayload, Para2);
   112be:	f104 0101 	add.w	r1, r4, #1
  if (EventId < 32) {
   112c2:	d913      	bls.n	112ec <SEGGER_SYSVIEW_RecordU32x3+0xc0>
   112c4:	b2f3      	uxtb	r3, r6
    NumBytes = pEndPacket - pStartPacket;
   112c6:	1bcf      	subs	r7, r1, r7
    if (NumBytes > 127) {
   112c8:	2f7f      	cmp	r7, #127	; 0x7f
   112ca:	b2f8      	uxtb	r0, r7
    NumBytes = pEndPacket - pStartPacket;
   112cc:	4c4d      	ldr	r4, [pc, #308]	; (11404 <SEGGER_SYSVIEW_RecordU32x3+0x1d8>)
    if (NumBytes > 127) {
   112ce:	d83f      	bhi.n	11350 <SEGGER_SYSVIEW_RecordU32x3+0x124>
    if (EventId > 127) {
   112d0:	2e7f      	cmp	r6, #127	; 0x7f
      *--pStartPacket = NumBytes;
   112d2:	f104 0203 	add.w	r2, r4, #3
   112d6:	70e0      	strb	r0, [r4, #3]
    if (EventId > 127) {
   112d8:	d944      	bls.n	11364 <SEGGER_SYSVIEW_RecordU32x3+0x138>
      *--pStartPacket = (EventId >> 7);
   112da:	09f6      	lsrs	r6, r6, #7
      *--pStartPacket = EventId | 0x80;
   112dc:	f063 037f 	orn	r3, r3, #127	; 0x7f
      *--pStartPacket = (EventId >> 7);
   112e0:	f802 6c01 	strb.w	r6, [r2, #-1]
      *--pStartPacket = EventId | 0x80;
   112e4:	f802 3c02 	strb.w	r3, [r2, #-2]
   112e8:	3a02      	subs	r2, #2
   112ea:	e00a      	b.n	11302 <SEGGER_SYSVIEW_RecordU32x3+0xd6>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   112ec:	f8d8 301c 	ldr.w	r3, [r8, #28]
   112f0:	40f3      	lsrs	r3, r6
   112f2:	07db      	lsls	r3, r3, #31
   112f4:	d4d0      	bmi.n	11298 <SEGGER_SYSVIEW_RecordU32x3+0x6c>
  if (EventId < 24) {
   112f6:	2e17      	cmp	r6, #23
   112f8:	b2f3      	uxtb	r3, r6
   112fa:	d8e4      	bhi.n	112c6 <SEGGER_SYSVIEW_RecordU32x3+0x9a>
    *--pStartPacket = EventId;
   112fc:	4a41      	ldr	r2, [pc, #260]	; (11404 <SEGGER_SYSVIEW_RecordU32x3+0x1d8>)
   112fe:	f802 3f03 	strb.w	r3, [r2, #3]!
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11302:	4841      	ldr	r0, [pc, #260]	; (11408 <SEGGER_SYSVIEW_RecordU32x3+0x1dc>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11304:	f8d8 300c 	ldr.w	r3, [r8, #12]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11308:	6806      	ldr	r6, [r0, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   1130a:	1af3      	subs	r3, r6, r3
  ENCODE_U32(pEndPacket, Delta);
   1130c:	2b7f      	cmp	r3, #127	; 0x7f
   1130e:	d906      	bls.n	1131e <SEGGER_SYSVIEW_RecordU32x3+0xf2>
   11310:	f063 007f 	orn	r0, r3, #127	; 0x7f
   11314:	09db      	lsrs	r3, r3, #7
   11316:	2b7f      	cmp	r3, #127	; 0x7f
   11318:	f801 0b01 	strb.w	r0, [r1], #1
   1131c:	d8f8      	bhi.n	11310 <SEGGER_SYSVIEW_RecordU32x3+0xe4>
   1131e:	460c      	mov	r4, r1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   11320:	2001      	movs	r0, #1
  ENCODE_U32(pEndPacket, Delta);
   11322:	f804 3b01 	strb.w	r3, [r4], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   11326:	4611      	mov	r1, r2
   11328:	1aa2      	subs	r2, r4, r2
   1132a:	f7fe fcab 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   1132e:	2800      	cmp	r0, #0
   11330:	d054      	beq.n	113dc <SEGGER_SYSVIEW_RecordU32x3+0x1b0>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   11332:	f8c8 600c 	str.w	r6, [r8, #12]
   11336:	e7af      	b.n	11298 <SEGGER_SYSVIEW_RecordU32x3+0x6c>
      _SYSVIEW_Globals.RecursionCnt = 1;
   11338:	2301      	movs	r3, #1
   1133a:	f888 3002 	strb.w	r3, [r8, #2]
      _HandleIncomingPacket();
   1133e:	f7fe fec9 	bl	100d4 <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   11342:	f888 4002 	strb.w	r4, [r8, #2]
  RECORD_END();
   11346:	f385 8811 	msr	BASEPRI, r5
}
   1134a:	b005      	add	sp, #20
   1134c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      *--pStartPacket = NumBytes | 0x80;
   11350:	4622      	mov	r2, r4
   11352:	f060 007f 	orn	r0, r0, #127	; 0x7f
   11356:	f802 0f02 	strb.w	r0, [r2, #2]!
    if (EventId > 127) {
   1135a:	2e7f      	cmp	r6, #127	; 0x7f
      *--pStartPacket = (NumBytes >> 7);
   1135c:	f3c7 10c7 	ubfx	r0, r7, #7, #8
   11360:	70e0      	strb	r0, [r4, #3]
    if (EventId > 127) {
   11362:	d8ba      	bhi.n	112da <SEGGER_SYSVIEW_RecordU32x3+0xae>
      *--pStartPacket = EventId;
   11364:	f802 3c01 	strb.w	r3, [r2, #-1]
   11368:	3a01      	subs	r2, #1
   1136a:	e7ca      	b.n	11302 <SEGGER_SYSVIEW_RecordU32x3+0xd6>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   1136c:	f8d8 2014 	ldr.w	r2, [r8, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   11370:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11372:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   11374:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11378:	f10d 0305 	add.w	r3, sp, #5
   1137c:	d906      	bls.n	1138c <SEGGER_SYSVIEW_RecordU32x3+0x160>
   1137e:	f062 017f 	orn	r1, r2, #127	; 0x7f
   11382:	09d2      	lsrs	r2, r2, #7
   11384:	2a7f      	cmp	r2, #127	; 0x7f
   11386:	f803 1b01 	strb.w	r1, [r3], #1
   1138a:	d8f8      	bhi.n	1137e <SEGGER_SYSVIEW_RecordU32x3+0x152>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   1138c:	491e      	ldr	r1, [pc, #120]	; (11408 <SEGGER_SYSVIEW_RecordU32x3+0x1dc>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   1138e:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11390:	f8d1 9000 	ldr.w	r9, [r1]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11394:	f8d8 100c 	ldr.w	r1, [r8, #12]
   11398:	eba9 0101 	sub.w	r1, r9, r1
  ENCODE_U32(pPayload, Delta);
   1139c:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   1139e:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   113a2:	d906      	bls.n	113b2 <SEGGER_SYSVIEW_RecordU32x3+0x186>
   113a4:	f061 037f 	orn	r3, r1, #127	; 0x7f
   113a8:	09c9      	lsrs	r1, r1, #7
   113aa:	297f      	cmp	r1, #127	; 0x7f
   113ac:	f802 3b01 	strb.w	r3, [r2], #1
   113b0:	d8f8      	bhi.n	113a4 <SEGGER_SYSVIEW_RecordU32x3+0x178>
   113b2:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   113b4:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   113b6:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   113ba:	2001      	movs	r0, #1
   113bc:	4611      	mov	r1, r2
   113be:	1a9a      	subs	r2, r3, r2
   113c0:	f7fe fc60 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   113c4:	b980      	cbnz	r0, 113e8 <SEGGER_SYSVIEW_RecordU32x3+0x1bc>
    _SYSVIEW_Globals.DropCount++;
   113c6:	f8d8 2014 	ldr.w	r2, [r8, #20]
   113ca:	f898 3000 	ldrb.w	r3, [r8]
   113ce:	3201      	adds	r2, #1
   113d0:	f8c8 2014 	str.w	r2, [r8, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   113d4:	2b01      	cmp	r3, #1
   113d6:	f47f af5f 	bne.w	11298 <SEGGER_SYSVIEW_RecordU32x3+0x6c>
   113da:	e76f      	b.n	112bc <SEGGER_SYSVIEW_RecordU32x3+0x90>
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   113dc:	f898 3000 	ldrb.w	r3, [r8]
   113e0:	3301      	adds	r3, #1
   113e2:	f888 3000 	strb.w	r3, [r8]
   113e6:	e757      	b.n	11298 <SEGGER_SYSVIEW_RecordU32x3+0x6c>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   113e8:	f898 3000 	ldrb.w	r3, [r8]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   113ec:	f8c8 900c 	str.w	r9, [r8, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   113f0:	3b01      	subs	r3, #1
   113f2:	b2db      	uxtb	r3, r3
   113f4:	f888 3000 	strb.w	r3, [r8]
   113f8:	e7ec      	b.n	113d4 <SEGGER_SYSVIEW_RecordU32x3+0x1a8>
   113fa:	bf00      	nop
   113fc:	10014258 	.word	0x10014258
   11400:	10014404 	.word	0x10014404
   11404:	10014254 	.word	0x10014254
   11408:	e0001004 	.word	0xe0001004
   1140c:	1001322c 	.word	0x1001322c

00011410 <SEGGER_SYSVIEW_RecordSystime>:
void SEGGER_SYSVIEW_RecordSystime(void) {
   11410:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (_SYSVIEW_Globals.pOSAPI && _SYSVIEW_Globals.pOSAPI->pfGetTime) {
   11412:	4d5b      	ldr	r5, [pc, #364]	; (11580 <SEGGER_SYSVIEW_RecordSystime+0x170>)
   11414:	6a2b      	ldr	r3, [r5, #32]
void SEGGER_SYSVIEW_RecordSystime(void) {
   11416:	b085      	sub	sp, #20
  if (_SYSVIEW_Globals.pOSAPI && _SYSVIEW_Globals.pOSAPI->pfGetTime) {
   11418:	2b00      	cmp	r3, #0
   1141a:	d054      	beq.n	114c6 <SEGGER_SYSVIEW_RecordSystime+0xb6>
   1141c:	681b      	ldr	r3, [r3, #0]
   1141e:	2b00      	cmp	r3, #0
   11420:	d051      	beq.n	114c6 <SEGGER_SYSVIEW_RecordSystime+0xb6>
    Systime = _SYSVIEW_Globals.pOSAPI->pfGetTime();
   11422:	4798      	blx	r3
   11424:	460f      	mov	r7, r1
    SEGGER_SYSVIEW_RecordU32x2(SYSVIEW_EVTID_SYSTIME_US,
   11426:	460b      	mov	r3, r1
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
   11428:	f3ef 8611 	mrs	r6, BASEPRI
   1142c:	f04f 0120 	mov.w	r1, #32
   11430:	f381 8811 	msr	BASEPRI, r1
  ENCODE_U32(pPayload, Para0);
   11434:	287f      	cmp	r0, #127	; 0x7f
   11436:	4c53      	ldr	r4, [pc, #332]	; (11584 <SEGGER_SYSVIEW_RecordSystime+0x174>)
   11438:	d906      	bls.n	11448 <SEGGER_SYSVIEW_RecordSystime+0x38>
   1143a:	f060 017f 	orn	r1, r0, #127	; 0x7f
   1143e:	09c0      	lsrs	r0, r0, #7
   11440:	287f      	cmp	r0, #127	; 0x7f
   11442:	f804 1b01 	strb.w	r1, [r4], #1
   11446:	d8f8      	bhi.n	1143a <SEGGER_SYSVIEW_RecordSystime+0x2a>
  ENCODE_U32(pPayload, Para1);
   11448:	2f7f      	cmp	r7, #127	; 0x7f
  ENCODE_U32(pPayload, Para0);
   1144a:	7020      	strb	r0, [r4, #0]
   1144c:	f104 0401 	add.w	r4, r4, #1
  ENCODE_U32(pPayload, Para1);
   11450:	d906      	bls.n	11460 <SEGGER_SYSVIEW_RecordSystime+0x50>
   11452:	f063 027f 	orn	r2, r3, #127	; 0x7f
   11456:	09db      	lsrs	r3, r3, #7
   11458:	2b7f      	cmp	r3, #127	; 0x7f
   1145a:	f804 2b01 	strb.w	r2, [r4], #1
   1145e:	d8f8      	bhi.n	11452 <SEGGER_SYSVIEW_RecordSystime+0x42>
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   11460:	782a      	ldrb	r2, [r5, #0]
  ENCODE_U32(pPayload, Para1);
   11462:	7023      	strb	r3, [r4, #0]
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   11464:	2a01      	cmp	r2, #1
   11466:	d002      	beq.n	1146e <SEGGER_SYSVIEW_RecordSystime+0x5e>
  if (_SYSVIEW_Globals.EnableState == 0) {
   11468:	b302      	cbz	r2, 114ac <SEGGER_SYSVIEW_RecordSystime+0x9c>
  if (_SYSVIEW_Globals.EnableState == 2) {
   1146a:	2a02      	cmp	r2, #2
   1146c:	d051      	beq.n	11512 <SEGGER_SYSVIEW_RecordSystime+0x102>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   1146e:	69eb      	ldr	r3, [r5, #28]
   11470:	049b      	lsls	r3, r3, #18
   11472:	d41b      	bmi.n	114ac <SEGGER_SYSVIEW_RecordSystime+0x9c>
    *--pStartPacket = EventId;
   11474:	4a44      	ldr	r2, [pc, #272]	; (11588 <SEGGER_SYSVIEW_RecordSystime+0x178>)
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11476:	4b45      	ldr	r3, [pc, #276]	; (1158c <SEGGER_SYSVIEW_RecordSystime+0x17c>)
    *--pStartPacket = EventId;
   11478:	210d      	movs	r1, #13
   1147a:	70d1      	strb	r1, [r2, #3]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   1147c:	681f      	ldr	r7, [r3, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   1147e:	68eb      	ldr	r3, [r5, #12]
   11480:	1afb      	subs	r3, r7, r3
  ENCODE_U32(pEndPacket, Delta);
   11482:	2b7f      	cmp	r3, #127	; 0x7f
  ENCODE_U32(pPayload, Para1);
   11484:	f104 0201 	add.w	r2, r4, #1
  ENCODE_U32(pEndPacket, Delta);
   11488:	d906      	bls.n	11498 <SEGGER_SYSVIEW_RecordSystime+0x88>
   1148a:	f063 017f 	orn	r1, r3, #127	; 0x7f
   1148e:	09db      	lsrs	r3, r3, #7
   11490:	2b7f      	cmp	r3, #127	; 0x7f
   11492:	f802 1b01 	strb.w	r1, [r2], #1
   11496:	d8f8      	bhi.n	1148a <SEGGER_SYSVIEW_RecordSystime+0x7a>
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   11498:	483d      	ldr	r0, [pc, #244]	; (11590 <SEGGER_SYSVIEW_RecordSystime+0x180>)
  ENCODE_U32(pEndPacket, Delta);
   1149a:	f802 3b01 	strb.w	r3, [r2], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   1149e:	4601      	mov	r1, r0
   114a0:	1a12      	subs	r2, r2, r0
   114a2:	2001      	movs	r0, #1
   114a4:	f7fe fbee 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   114a8:	b378      	cbz	r0, 1150a <SEGGER_SYSVIEW_RecordSystime+0xfa>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   114aa:	60ef      	str	r7, [r5, #12]
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   114ac:	4b39      	ldr	r3, [pc, #228]	; (11594 <SEGGER_SYSVIEW_RecordSystime+0x184>)
   114ae:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   114b2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   114b6:	429a      	cmp	r2, r3
   114b8:	d001      	beq.n	114be <SEGGER_SYSVIEW_RecordSystime+0xae>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   114ba:	78ac      	ldrb	r4, [r5, #2]
   114bc:	b1fc      	cbz	r4, 114fe <SEGGER_SYSVIEW_RecordSystime+0xee>
  RECORD_END();
   114be:	f386 8811 	msr	BASEPRI, r6
}
   114c2:	b005      	add	sp, #20
   114c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    SEGGER_SYSVIEW_RecordU32(SYSVIEW_EVTID_SYSTIME_CYCLES, SEGGER_SYSVIEW_GET_TIMESTAMP());
   114c6:	4b31      	ldr	r3, [pc, #196]	; (1158c <SEGGER_SYSVIEW_RecordSystime+0x17c>)
   114c8:	681b      	ldr	r3, [r3, #0]
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
   114ca:	f3ef 8411 	mrs	r4, BASEPRI
   114ce:	f04f 0120 	mov.w	r1, #32
   114d2:	f381 8811 	msr	BASEPRI, r1
  ENCODE_U32(pPayload, Value);
   114d6:	2b7f      	cmp	r3, #127	; 0x7f
   114d8:	492a      	ldr	r1, [pc, #168]	; (11584 <SEGGER_SYSVIEW_RecordSystime+0x174>)
   114da:	d906      	bls.n	114ea <SEGGER_SYSVIEW_RecordSystime+0xda>
   114dc:	f063 027f 	orn	r2, r3, #127	; 0x7f
   114e0:	09db      	lsrs	r3, r3, #7
   114e2:	2b7f      	cmp	r3, #127	; 0x7f
   114e4:	f801 2b01 	strb.w	r2, [r1], #1
   114e8:	d8f8      	bhi.n	114dc <SEGGER_SYSVIEW_RecordSystime+0xcc>
  _SendPacket(pPayloadStart, pPayload, EventID);
   114ea:	4826      	ldr	r0, [pc, #152]	; (11584 <SEGGER_SYSVIEW_RecordSystime+0x174>)
  ENCODE_U32(pPayload, Value);
   114ec:	f801 3b01 	strb.w	r3, [r1], #1
  _SendPacket(pPayloadStart, pPayload, EventID);
   114f0:	220c      	movs	r2, #12
   114f2:	f7fe fe7d 	bl	101f0 <_SendPacket>
  RECORD_END();
   114f6:	f384 8811 	msr	BASEPRI, r4
}
   114fa:	b005      	add	sp, #20
   114fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
      _SYSVIEW_Globals.RecursionCnt = 1;
   114fe:	2301      	movs	r3, #1
   11500:	70ab      	strb	r3, [r5, #2]
      _HandleIncomingPacket();
   11502:	f7fe fde7 	bl	100d4 <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   11506:	70ac      	strb	r4, [r5, #2]
   11508:	e7d9      	b.n	114be <SEGGER_SYSVIEW_RecordSystime+0xae>
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   1150a:	782b      	ldrb	r3, [r5, #0]
   1150c:	3301      	adds	r3, #1
   1150e:	702b      	strb	r3, [r5, #0]
   11510:	e7cc      	b.n	114ac <SEGGER_SYSVIEW_RecordSystime+0x9c>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11512:	696a      	ldr	r2, [r5, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   11514:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11516:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   11518:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   1151c:	f10d 0305 	add.w	r3, sp, #5
   11520:	d906      	bls.n	11530 <SEGGER_SYSVIEW_RecordSystime+0x120>
   11522:	f062 017f 	orn	r1, r2, #127	; 0x7f
   11526:	09d2      	lsrs	r2, r2, #7
   11528:	2a7f      	cmp	r2, #127	; 0x7f
   1152a:	f803 1b01 	strb.w	r1, [r3], #1
   1152e:	d8f8      	bhi.n	11522 <SEGGER_SYSVIEW_RecordSystime+0x112>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11530:	4916      	ldr	r1, [pc, #88]	; (1158c <SEGGER_SYSVIEW_RecordSystime+0x17c>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11532:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11534:	680f      	ldr	r7, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11536:	68e9      	ldr	r1, [r5, #12]
   11538:	1a79      	subs	r1, r7, r1
  ENCODE_U32(pPayload, Delta);
   1153a:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   1153c:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   11540:	d906      	bls.n	11550 <SEGGER_SYSVIEW_RecordSystime+0x140>
   11542:	f061 037f 	orn	r3, r1, #127	; 0x7f
   11546:	09c9      	lsrs	r1, r1, #7
   11548:	297f      	cmp	r1, #127	; 0x7f
   1154a:	f802 3b01 	strb.w	r3, [r2], #1
   1154e:	d8f8      	bhi.n	11542 <SEGGER_SYSVIEW_RecordSystime+0x132>
   11550:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   11552:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   11554:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   11558:	2001      	movs	r0, #1
   1155a:	4611      	mov	r1, r2
   1155c:	1a9a      	subs	r2, r3, r2
   1155e:	f7fe fb91 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   11562:	b930      	cbnz	r0, 11572 <SEGGER_SYSVIEW_RecordSystime+0x162>
    _SYSVIEW_Globals.DropCount++;
   11564:	696a      	ldr	r2, [r5, #20]
   11566:	782b      	ldrb	r3, [r5, #0]
   11568:	3201      	adds	r2, #1
   1156a:	616a      	str	r2, [r5, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   1156c:	2b01      	cmp	r3, #1
   1156e:	d19d      	bne.n	114ac <SEGGER_SYSVIEW_RecordSystime+0x9c>
   11570:	e77d      	b.n	1146e <SEGGER_SYSVIEW_RecordSystime+0x5e>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   11572:	782b      	ldrb	r3, [r5, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   11574:	60ef      	str	r7, [r5, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   11576:	3b01      	subs	r3, #1
   11578:	b2db      	uxtb	r3, r3
   1157a:	702b      	strb	r3, [r5, #0]
   1157c:	e7f6      	b.n	1156c <SEGGER_SYSVIEW_RecordSystime+0x15c>
   1157e:	bf00      	nop
   11580:	1001322c 	.word	0x1001322c
   11584:	10014258 	.word	0x10014258
   11588:	10014254 	.word	0x10014254
   1158c:	e0001004 	.word	0xe0001004
   11590:	10014257 	.word	0x10014257
   11594:	10014404 	.word	0x10014404

00011598 <SEGGER_SYSVIEW_Start>:
void SEGGER_SYSVIEW_Start(void) {
   11598:	b538      	push	{r3, r4, r5, lr}
  if (_SYSVIEW_Globals.EnableState == 0) {
   1159a:	4c3b      	ldr	r4, [pc, #236]	; (11688 <SEGGER_SYSVIEW_Start+0xf0>)
   1159c:	7823      	ldrb	r3, [r4, #0]
   1159e:	b103      	cbz	r3, 115a2 <SEGGER_SYSVIEW_Start+0xa>
}
   115a0:	bd38      	pop	{r3, r4, r5, pc}
    _SYSVIEW_Globals.EnableState = 1;
   115a2:	2001      	movs	r0, #1
   115a4:	7020      	strb	r0, [r4, #0]
    SEGGER_SYSVIEW_LOCK();
   115a6:	f3ef 8511 	mrs	r5, BASEPRI
   115aa:	f04f 0120 	mov.w	r1, #32
   115ae:	f381 8811 	msr	BASEPRI, r1
    SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, _abSync, 10);
   115b2:	220a      	movs	r2, #10
   115b4:	4935      	ldr	r1, [pc, #212]	; (1168c <SEGGER_SYSVIEW_Start+0xf4>)
   115b6:	f7fe fb65 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
    SEGGER_SYSVIEW_UNLOCK();
   115ba:	f385 8811 	msr	BASEPRI, r5
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
   115be:	f3ef 8511 	mrs	r5, BASEPRI
   115c2:	f04f 0120 	mov.w	r1, #32
   115c6:	f381 8811 	msr	BASEPRI, r1
  _SendPacket(pPayloadStart, pPayloadStart, EventID);
   115ca:	4931      	ldr	r1, [pc, #196]	; (11690 <SEGGER_SYSVIEW_Start+0xf8>)
   115cc:	220a      	movs	r2, #10
   115ce:	4608      	mov	r0, r1
   115d0:	f7fe fe0e 	bl	101f0 <_SendPacket>
  RECORD_END();
   115d4:	f385 8811 	msr	BASEPRI, r5
      RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
   115d8:	f3ef 8511 	mrs	r5, BASEPRI
   115dc:	f04f 0120 	mov.w	r1, #32
   115e0:	f381 8811 	msr	BASEPRI, r1
      ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
   115e4:	6862      	ldr	r2, [r4, #4]
   115e6:	4b2a      	ldr	r3, [pc, #168]	; (11690 <SEGGER_SYSVIEW_Start+0xf8>)
   115e8:	2a7f      	cmp	r2, #127	; 0x7f
   115ea:	d906      	bls.n	115fa <SEGGER_SYSVIEW_Start+0x62>
   115ec:	f062 017f 	orn	r1, r2, #127	; 0x7f
   115f0:	09d2      	lsrs	r2, r2, #7
   115f2:	2a7f      	cmp	r2, #127	; 0x7f
   115f4:	f803 1b01 	strb.w	r1, [r3], #1
   115f8:	d8f8      	bhi.n	115ec <SEGGER_SYSVIEW_Start+0x54>
      ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
   115fa:	68a1      	ldr	r1, [r4, #8]
      ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
   115fc:	701a      	strb	r2, [r3, #0]
      ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
   115fe:	297f      	cmp	r1, #127	; 0x7f
      ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
   11600:	f103 0301 	add.w	r3, r3, #1
      ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
   11604:	d906      	bls.n	11614 <SEGGER_SYSVIEW_Start+0x7c>
   11606:	f061 027f 	orn	r2, r1, #127	; 0x7f
   1160a:	09c9      	lsrs	r1, r1, #7
   1160c:	297f      	cmp	r1, #127	; 0x7f
   1160e:	f803 2b01 	strb.w	r2, [r3], #1
   11612:	d8f8      	bhi.n	11606 <SEGGER_SYSVIEW_Start+0x6e>
      ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
   11614:	6922      	ldr	r2, [r4, #16]
      ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
   11616:	7019      	strb	r1, [r3, #0]
      ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
   11618:	2a7f      	cmp	r2, #127	; 0x7f
      ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
   1161a:	f103 0301 	add.w	r3, r3, #1
      ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
   1161e:	d906      	bls.n	1162e <SEGGER_SYSVIEW_Start+0x96>
   11620:	f062 017f 	orn	r1, r2, #127	; 0x7f
   11624:	09d2      	lsrs	r2, r2, #7
   11626:	2a7f      	cmp	r2, #127	; 0x7f
   11628:	f803 1b01 	strb.w	r1, [r3], #1
   1162c:	d8f8      	bhi.n	11620 <SEGGER_SYSVIEW_Start+0x88>
      ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
   1162e:	2002      	movs	r0, #2
      _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
   11630:	1819      	adds	r1, r3, r0
      ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
   11632:	701a      	strb	r2, [r3, #0]
      ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
   11634:	7058      	strb	r0, [r3, #1]
      _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
   11636:	2218      	movs	r2, #24
   11638:	4815      	ldr	r0, [pc, #84]	; (11690 <SEGGER_SYSVIEW_Start+0xf8>)
   1163a:	f7fe fdd9 	bl	101f0 <_SendPacket>
      RECORD_END();
   1163e:	f385 8811 	msr	BASEPRI, r5
    if (_SYSVIEW_Globals.pfSendSysDesc) {
   11642:	6a63      	ldr	r3, [r4, #36]	; 0x24
   11644:	b103      	cbz	r3, 11648 <SEGGER_SYSVIEW_Start+0xb0>
      _SYSVIEW_Globals.pfSendSysDesc();
   11646:	4798      	blx	r3
    SEGGER_SYSVIEW_RecordSystime();
   11648:	f7ff fee2 	bl	11410 <SEGGER_SYSVIEW_RecordSystime>
  if (_SYSVIEW_Globals.pOSAPI && _SYSVIEW_Globals.pOSAPI->pfSendTaskList) {
   1164c:	6a23      	ldr	r3, [r4, #32]
   1164e:	b113      	cbz	r3, 11656 <SEGGER_SYSVIEW_Start+0xbe>
   11650:	685b      	ldr	r3, [r3, #4]
   11652:	b103      	cbz	r3, 11656 <SEGGER_SYSVIEW_Start+0xbe>
    _SYSVIEW_Globals.pOSAPI->pfSendTaskList();
   11654:	4798      	blx	r3
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2*SEGGER_SYSVIEW_QUANTA_U32);
   11656:	f3ef 8411 	mrs	r4, BASEPRI
   1165a:	f04f 0120 	mov.w	r1, #32
   1165e:	f381 8811 	msr	BASEPRI, r1
  ENCODE_U32(pPayload, _NumModules);
   11662:	4b0c      	ldr	r3, [pc, #48]	; (11694 <SEGGER_SYSVIEW_Start+0xfc>)
   11664:	781b      	ldrb	r3, [r3, #0]
   11666:	2b7f      	cmp	r3, #127	; 0x7f
   11668:	d90c      	bls.n	11684 <SEGGER_SYSVIEW_Start+0xec>
   1166a:	490b      	ldr	r1, [pc, #44]	; (11698 <SEGGER_SYSVIEW_Start+0x100>)
   1166c:	710b      	strb	r3, [r1, #4]
   1166e:	3105      	adds	r1, #5
   11670:	2301      	movs	r3, #1
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_NUMMODULES);
   11672:	4807      	ldr	r0, [pc, #28]	; (11690 <SEGGER_SYSVIEW_Start+0xf8>)
  ENCODE_U32(pPayload, _NumModules);
   11674:	f801 3b01 	strb.w	r3, [r1], #1
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_NUMMODULES);
   11678:	221b      	movs	r2, #27
   1167a:	f7fe fdb9 	bl	101f0 <_SendPacket>
  RECORD_END();
   1167e:	f384 8811 	msr	BASEPRI, r4
}
   11682:	bd38      	pop	{r3, r4, r5, pc}
  ENCODE_U32(pPayload, _NumModules);
   11684:	4902      	ldr	r1, [pc, #8]	; (11690 <SEGGER_SYSVIEW_Start+0xf8>)
   11686:	e7f4      	b.n	11672 <SEGGER_SYSVIEW_Start+0xda>
   11688:	1001322c 	.word	0x1001322c
   1168c:	000136f4 	.word	0x000136f4
   11690:	10014258 	.word	0x10014258
   11694:	10013228 	.word	0x10013228
   11698:	10014254 	.word	0x10014254

0001169c <SEGGER_SYSVIEW_RecordVoid>:
void SEGGER_SYSVIEW_RecordVoid(unsigned int EventID) {
   1169c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1169e:	4605      	mov	r5, r0
   116a0:	b085      	sub	sp, #20
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
   116a2:	f3ef 8611 	mrs	r6, BASEPRI
   116a6:	f04f 0120 	mov.w	r1, #32
   116aa:	f381 8811 	msr	BASEPRI, r1
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   116ae:	4c49      	ldr	r4, [pc, #292]	; (117d4 <SEGGER_SYSVIEW_RecordVoid+0x138>)
   116b0:	7823      	ldrb	r3, [r4, #0]
   116b2:	2b01      	cmp	r3, #1
   116b4:	d010      	beq.n	116d8 <SEGGER_SYSVIEW_RecordVoid+0x3c>
  if (_SYSVIEW_Globals.EnableState == 0) {
   116b6:	b96b      	cbnz	r3, 116d4 <SEGGER_SYSVIEW_RecordVoid+0x38>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   116b8:	4b47      	ldr	r3, [pc, #284]	; (117d8 <SEGGER_SYSVIEW_RecordVoid+0x13c>)
   116ba:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   116be:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   116c2:	429a      	cmp	r2, r3
   116c4:	d002      	beq.n	116cc <SEGGER_SYSVIEW_RecordVoid+0x30>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   116c6:	78a5      	ldrb	r5, [r4, #2]
   116c8:	2d00      	cmp	r5, #0
   116ca:	d039      	beq.n	11740 <SEGGER_SYSVIEW_RecordVoid+0xa4>
  RECORD_END();
   116cc:	f386 8811 	msr	BASEPRI, r6
}
   116d0:	b005      	add	sp, #20
   116d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   116d4:	2b02      	cmp	r3, #2
   116d6:	d041      	beq.n	1175c <SEGGER_SYSVIEW_RecordVoid+0xc0>
  if (EventId < 32) {
   116d8:	2d1f      	cmp	r5, #31
   116da:	d823      	bhi.n	11724 <SEGGER_SYSVIEW_RecordVoid+0x88>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   116dc:	69e3      	ldr	r3, [r4, #28]
   116de:	40eb      	lsrs	r3, r5
   116e0:	f013 0301 	ands.w	r3, r3, #1
   116e4:	d1e8      	bne.n	116b8 <SEGGER_SYSVIEW_RecordVoid+0x1c>
  if (EventId < 24) {
   116e6:	2d17      	cmp	r5, #23
   116e8:	b2ea      	uxtb	r2, r5
   116ea:	d832      	bhi.n	11752 <SEGGER_SYSVIEW_RecordVoid+0xb6>
    *--pStartPacket = EventId;
   116ec:	483b      	ldr	r0, [pc, #236]	; (117dc <SEGGER_SYSVIEW_RecordVoid+0x140>)
   116ee:	f800 2f03 	strb.w	r2, [r0, #3]!
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   116f2:	4a3b      	ldr	r2, [pc, #236]	; (117e0 <SEGGER_SYSVIEW_RecordVoid+0x144>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   116f4:	68e3      	ldr	r3, [r4, #12]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   116f6:	6815      	ldr	r5, [r2, #0]
  ENCODE_U32(pEndPacket, Delta);
   116f8:	4a3a      	ldr	r2, [pc, #232]	; (117e4 <SEGGER_SYSVIEW_RecordVoid+0x148>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   116fa:	1aeb      	subs	r3, r5, r3
  ENCODE_U32(pEndPacket, Delta);
   116fc:	2b7f      	cmp	r3, #127	; 0x7f
   116fe:	d906      	bls.n	1170e <SEGGER_SYSVIEW_RecordVoid+0x72>
   11700:	f063 017f 	orn	r1, r3, #127	; 0x7f
   11704:	09db      	lsrs	r3, r3, #7
   11706:	2b7f      	cmp	r3, #127	; 0x7f
   11708:	f802 1b01 	strb.w	r1, [r2], #1
   1170c:	d8f8      	bhi.n	11700 <SEGGER_SYSVIEW_RecordVoid+0x64>
   1170e:	f802 3b01 	strb.w	r3, [r2], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   11712:	4601      	mov	r1, r0
   11714:	1a12      	subs	r2, r2, r0
   11716:	2001      	movs	r0, #1
   11718:	f7fe fab4 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   1171c:	2800      	cmp	r0, #0
   1171e:	d04e      	beq.n	117be <SEGGER_SYSVIEW_RecordVoid+0x122>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   11720:	60e5      	str	r5, [r4, #12]
   11722:	e7c9      	b.n	116b8 <SEGGER_SYSVIEW_RecordVoid+0x1c>
      *--pStartPacket = NumBytes;
   11724:	492d      	ldr	r1, [pc, #180]	; (117dc <SEGGER_SYSVIEW_RecordVoid+0x140>)
   11726:	2300      	movs	r3, #0
    if (EventId > 127) {
   11728:	2d7f      	cmp	r5, #127	; 0x7f
      *--pStartPacket = NumBytes;
   1172a:	70cb      	strb	r3, [r1, #3]
   1172c:	b2ea      	uxtb	r2, r5
    if (EventId > 127) {
   1172e:	d912      	bls.n	11756 <SEGGER_SYSVIEW_RecordVoid+0xba>
      *--pStartPacket = EventId | 0x80;
   11730:	4608      	mov	r0, r1
      *--pStartPacket = (EventId >> 7);
   11732:	09ed      	lsrs	r5, r5, #7
      *--pStartPacket = EventId | 0x80;
   11734:	f062 027f 	orn	r2, r2, #127	; 0x7f
      *--pStartPacket = (EventId >> 7);
   11738:	708d      	strb	r5, [r1, #2]
      *--pStartPacket = EventId | 0x80;
   1173a:	f800 2f01 	strb.w	r2, [r0, #1]!
   1173e:	e7d8      	b.n	116f2 <SEGGER_SYSVIEW_RecordVoid+0x56>
      _SYSVIEW_Globals.RecursionCnt = 1;
   11740:	2301      	movs	r3, #1
   11742:	70a3      	strb	r3, [r4, #2]
      _HandleIncomingPacket();
   11744:	f7fe fcc6 	bl	100d4 <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   11748:	70a5      	strb	r5, [r4, #2]
  RECORD_END();
   1174a:	f386 8811 	msr	BASEPRI, r6
}
   1174e:	b005      	add	sp, #20
   11750:	bdf0      	pop	{r4, r5, r6, r7, pc}
      *--pStartPacket = NumBytes;
   11752:	4922      	ldr	r1, [pc, #136]	; (117dc <SEGGER_SYSVIEW_RecordVoid+0x140>)
   11754:	70cb      	strb	r3, [r1, #3]
      *--pStartPacket = EventId;
   11756:	4824      	ldr	r0, [pc, #144]	; (117e8 <SEGGER_SYSVIEW_RecordVoid+0x14c>)
   11758:	708a      	strb	r2, [r1, #2]
   1175a:	e7ca      	b.n	116f2 <SEGGER_SYSVIEW_RecordVoid+0x56>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   1175c:	6962      	ldr	r2, [r4, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   1175e:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11760:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   11762:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11766:	f10d 0305 	add.w	r3, sp, #5
   1176a:	d906      	bls.n	1177a <SEGGER_SYSVIEW_RecordVoid+0xde>
   1176c:	f062 017f 	orn	r1, r2, #127	; 0x7f
   11770:	09d2      	lsrs	r2, r2, #7
   11772:	2a7f      	cmp	r2, #127	; 0x7f
   11774:	f803 1b01 	strb.w	r1, [r3], #1
   11778:	d8f8      	bhi.n	1176c <SEGGER_SYSVIEW_RecordVoid+0xd0>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   1177a:	4919      	ldr	r1, [pc, #100]	; (117e0 <SEGGER_SYSVIEW_RecordVoid+0x144>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   1177c:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   1177e:	680f      	ldr	r7, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11780:	68e1      	ldr	r1, [r4, #12]
   11782:	1a79      	subs	r1, r7, r1
  ENCODE_U32(pPayload, Delta);
   11784:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11786:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   1178a:	d906      	bls.n	1179a <SEGGER_SYSVIEW_RecordVoid+0xfe>
   1178c:	f061 037f 	orn	r3, r1, #127	; 0x7f
   11790:	09c9      	lsrs	r1, r1, #7
   11792:	297f      	cmp	r1, #127	; 0x7f
   11794:	f802 3b01 	strb.w	r3, [r2], #1
   11798:	d8f8      	bhi.n	1178c <SEGGER_SYSVIEW_RecordVoid+0xf0>
   1179a:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   1179c:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   1179e:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   117a2:	2001      	movs	r0, #1
   117a4:	4611      	mov	r1, r2
   117a6:	1a9a      	subs	r2, r3, r2
   117a8:	f7fe fa6c 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   117ac:	b958      	cbnz	r0, 117c6 <SEGGER_SYSVIEW_RecordVoid+0x12a>
    _SYSVIEW_Globals.DropCount++;
   117ae:	6962      	ldr	r2, [r4, #20]
   117b0:	7823      	ldrb	r3, [r4, #0]
   117b2:	3201      	adds	r2, #1
   117b4:	6162      	str	r2, [r4, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   117b6:	2b01      	cmp	r3, #1
   117b8:	f47f af7e 	bne.w	116b8 <SEGGER_SYSVIEW_RecordVoid+0x1c>
   117bc:	e78c      	b.n	116d8 <SEGGER_SYSVIEW_RecordVoid+0x3c>
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   117be:	7823      	ldrb	r3, [r4, #0]
   117c0:	3301      	adds	r3, #1
   117c2:	7023      	strb	r3, [r4, #0]
   117c4:	e778      	b.n	116b8 <SEGGER_SYSVIEW_RecordVoid+0x1c>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   117c6:	7823      	ldrb	r3, [r4, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   117c8:	60e7      	str	r7, [r4, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   117ca:	3b01      	subs	r3, #1
   117cc:	b2db      	uxtb	r3, r3
   117ce:	7023      	strb	r3, [r4, #0]
   117d0:	e7f1      	b.n	117b6 <SEGGER_SYSVIEW_RecordVoid+0x11a>
   117d2:	bf00      	nop
   117d4:	1001322c 	.word	0x1001322c
   117d8:	10014404 	.word	0x10014404
   117dc:	10014254 	.word	0x10014254
   117e0:	e0001004 	.word	0xe0001004
   117e4:	10014258 	.word	0x10014258
   117e8:	10014256 	.word	0x10014256

000117ec <SEGGER_SYSVIEW_GetSysDesc>:
void SEGGER_SYSVIEW_GetSysDesc(void) {
   117ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   117f0:	b084      	sub	sp, #16
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
   117f2:	f3ef 8711 	mrs	r7, BASEPRI
   117f6:	f04f 0120 	mov.w	r1, #32
   117fa:	f381 8811 	msr	BASEPRI, r1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
   117fe:	4d5b      	ldr	r5, [pc, #364]	; (1196c <SEGGER_SYSVIEW_GetSysDesc+0x180>)
   11800:	4e5b      	ldr	r6, [pc, #364]	; (11970 <SEGGER_SYSVIEW_GetSysDesc+0x184>)
   11802:	686b      	ldr	r3, [r5, #4]
   11804:	2b7f      	cmp	r3, #127	; 0x7f
   11806:	4634      	mov	r4, r6
   11808:	d906      	bls.n	11818 <SEGGER_SYSVIEW_GetSysDesc+0x2c>
   1180a:	f063 027f 	orn	r2, r3, #127	; 0x7f
   1180e:	09db      	lsrs	r3, r3, #7
   11810:	2b7f      	cmp	r3, #127	; 0x7f
   11812:	f804 2b01 	strb.w	r2, [r4], #1
   11816:	d8f8      	bhi.n	1180a <SEGGER_SYSVIEW_GetSysDesc+0x1e>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
   11818:	68aa      	ldr	r2, [r5, #8]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
   1181a:	7023      	strb	r3, [r4, #0]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
   1181c:	2a7f      	cmp	r2, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
   1181e:	f104 0401 	add.w	r4, r4, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
   11822:	d906      	bls.n	11832 <SEGGER_SYSVIEW_GetSysDesc+0x46>
   11824:	f062 037f 	orn	r3, r2, #127	; 0x7f
   11828:	09d2      	lsrs	r2, r2, #7
   1182a:	2a7f      	cmp	r2, #127	; 0x7f
   1182c:	f804 3b01 	strb.w	r3, [r4], #1
   11830:	d8f8      	bhi.n	11824 <SEGGER_SYSVIEW_GetSysDesc+0x38>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
   11832:	692b      	ldr	r3, [r5, #16]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
   11834:	7022      	strb	r2, [r4, #0]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
   11836:	2b7f      	cmp	r3, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
   11838:	f104 0401 	add.w	r4, r4, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
   1183c:	d906      	bls.n	1184c <SEGGER_SYSVIEW_GetSysDesc+0x60>
   1183e:	f063 027f 	orn	r2, r3, #127	; 0x7f
   11842:	09db      	lsrs	r3, r3, #7
   11844:	2b7f      	cmp	r3, #127	; 0x7f
   11846:	f804 2b01 	strb.w	r2, [r4], #1
   1184a:	d8f8      	bhi.n	1183e <SEGGER_SYSVIEW_GetSysDesc+0x52>
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   1184c:	782a      	ldrb	r2, [r5, #0]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
   1184e:	7023      	strb	r3, [r4, #0]
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   11850:	2a01      	cmp	r2, #1
  ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
   11852:	f04f 0302 	mov.w	r3, #2
   11856:	7063      	strb	r3, [r4, #1]
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   11858:	d014      	beq.n	11884 <SEGGER_SYSVIEW_GetSysDesc+0x98>
  if (_SYSVIEW_Globals.EnableState == 0) {
   1185a:	b98a      	cbnz	r2, 11880 <SEGGER_SYSVIEW_GetSysDesc+0x94>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   1185c:	4b45      	ldr	r3, [pc, #276]	; (11974 <SEGGER_SYSVIEW_GetSysDesc+0x188>)
   1185e:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   11862:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   11866:	429a      	cmp	r2, r3
   11868:	d002      	beq.n	11870 <SEGGER_SYSVIEW_GetSysDesc+0x84>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   1186a:	78ac      	ldrb	r4, [r5, #2]
   1186c:	2c00      	cmp	r4, #0
   1186e:	d031      	beq.n	118d4 <SEGGER_SYSVIEW_GetSysDesc+0xe8>
  RECORD_END();
   11870:	f387 8811 	msr	BASEPRI, r7
  if (_SYSVIEW_Globals.pfSendSysDesc) {
   11874:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   11876:	b103      	cbz	r3, 1187a <SEGGER_SYSVIEW_GetSysDesc+0x8e>
    _SYSVIEW_Globals.pfSendSysDesc();
   11878:	4798      	blx	r3
}
   1187a:	b004      	add	sp, #16
   1187c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   11880:	2a02      	cmp	r2, #2
   11882:	d035      	beq.n	118f0 <SEGGER_SYSVIEW_GetSysDesc+0x104>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   11884:	7feb      	ldrb	r3, [r5, #31]
   11886:	07db      	lsls	r3, r3, #31
   11888:	d4e8      	bmi.n	1185c <SEGGER_SYSVIEW_GetSysDesc+0x70>
  ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
   1188a:	1ca2      	adds	r2, r4, #2
    NumBytes = pEndPacket - pStartPacket;
   1188c:	1b96      	subs	r6, r2, r6
    if (NumBytes > 127) {
   1188e:	2e7f      	cmp	r6, #127	; 0x7f
   11890:	b2f3      	uxtb	r3, r6
    NumBytes = pEndPacket - pStartPacket;
   11892:	4839      	ldr	r0, [pc, #228]	; (11978 <SEGGER_SYSVIEW_GetSysDesc+0x18c>)
    if (NumBytes > 127) {
   11894:	d824      	bhi.n	118e0 <SEGGER_SYSVIEW_GetSysDesc+0xf4>
      *--pStartPacket = NumBytes;
   11896:	1cc1      	adds	r1, r0, #3
   11898:	70c3      	strb	r3, [r0, #3]
      *--pStartPacket = EventId;
   1189a:	2418      	movs	r4, #24
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   1189c:	4b37      	ldr	r3, [pc, #220]	; (1197c <SEGGER_SYSVIEW_GetSysDesc+0x190>)
      *--pStartPacket = EventId;
   1189e:	f801 4c01 	strb.w	r4, [r1, #-1]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   118a2:	681c      	ldr	r4, [r3, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   118a4:	68eb      	ldr	r3, [r5, #12]
   118a6:	1ae3      	subs	r3, r4, r3
  ENCODE_U32(pEndPacket, Delta);
   118a8:	2b7f      	cmp	r3, #127	; 0x7f
      *--pStartPacket = EventId;
   118aa:	f101 30ff 	add.w	r0, r1, #4294967295	; 0xffffffff
  ENCODE_U32(pEndPacket, Delta);
   118ae:	d906      	bls.n	118be <SEGGER_SYSVIEW_GetSysDesc+0xd2>
   118b0:	f063 017f 	orn	r1, r3, #127	; 0x7f
   118b4:	09db      	lsrs	r3, r3, #7
   118b6:	2b7f      	cmp	r3, #127	; 0x7f
   118b8:	f802 1b01 	strb.w	r1, [r2], #1
   118bc:	d8f8      	bhi.n	118b0 <SEGGER_SYSVIEW_GetSysDesc+0xc4>
   118be:	f802 3b01 	strb.w	r3, [r2], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   118c2:	4601      	mov	r1, r0
   118c4:	1a12      	subs	r2, r2, r0
   118c6:	2001      	movs	r0, #1
   118c8:	f7fe f9dc 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   118cc:	2800      	cmp	r0, #0
   118ce:	d041      	beq.n	11954 <SEGGER_SYSVIEW_GetSysDesc+0x168>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   118d0:	60ec      	str	r4, [r5, #12]
   118d2:	e7c3      	b.n	1185c <SEGGER_SYSVIEW_GetSysDesc+0x70>
      _SYSVIEW_Globals.RecursionCnt = 1;
   118d4:	2301      	movs	r3, #1
   118d6:	70ab      	strb	r3, [r5, #2]
      _HandleIncomingPacket();
   118d8:	f7fe fbfc 	bl	100d4 <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   118dc:	70ac      	strb	r4, [r5, #2]
   118de:	e7c7      	b.n	11870 <SEGGER_SYSVIEW_GetSysDesc+0x84>
      *--pStartPacket = NumBytes | 0x80;
   118e0:	4601      	mov	r1, r0
   118e2:	f063 037f 	orn	r3, r3, #127	; 0x7f
   118e6:	f801 3f02 	strb.w	r3, [r1, #2]!
      *--pStartPacket = (NumBytes >> 7);
   118ea:	f3c6 13c7 	ubfx	r3, r6, #7, #8
   118ee:	e7d3      	b.n	11898 <SEGGER_SYSVIEW_GetSysDesc+0xac>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   118f0:	696a      	ldr	r2, [r5, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   118f2:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   118f4:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   118f6:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   118fa:	f10d 0305 	add.w	r3, sp, #5
   118fe:	d906      	bls.n	1190e <SEGGER_SYSVIEW_GetSysDesc+0x122>
   11900:	f062 017f 	orn	r1, r2, #127	; 0x7f
   11904:	09d2      	lsrs	r2, r2, #7
   11906:	2a7f      	cmp	r2, #127	; 0x7f
   11908:	f803 1b01 	strb.w	r1, [r3], #1
   1190c:	d8f8      	bhi.n	11900 <SEGGER_SYSVIEW_GetSysDesc+0x114>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   1190e:	491b      	ldr	r1, [pc, #108]	; (1197c <SEGGER_SYSVIEW_GetSysDesc+0x190>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11910:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11912:	f8d1 8000 	ldr.w	r8, [r1]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11916:	68e9      	ldr	r1, [r5, #12]
   11918:	eba8 0101 	sub.w	r1, r8, r1
  ENCODE_U32(pPayload, Delta);
   1191c:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   1191e:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   11922:	d906      	bls.n	11932 <SEGGER_SYSVIEW_GetSysDesc+0x146>
   11924:	f061 037f 	orn	r3, r1, #127	; 0x7f
   11928:	09c9      	lsrs	r1, r1, #7
   1192a:	297f      	cmp	r1, #127	; 0x7f
   1192c:	f802 3b01 	strb.w	r3, [r2], #1
   11930:	d8f8      	bhi.n	11924 <SEGGER_SYSVIEW_GetSysDesc+0x138>
   11932:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   11934:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   11936:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   1193a:	2001      	movs	r0, #1
   1193c:	4611      	mov	r1, r2
   1193e:	1a9a      	subs	r2, r3, r2
   11940:	f7fe f9a0 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   11944:	b950      	cbnz	r0, 1195c <SEGGER_SYSVIEW_GetSysDesc+0x170>
    _SYSVIEW_Globals.DropCount++;
   11946:	696a      	ldr	r2, [r5, #20]
   11948:	782b      	ldrb	r3, [r5, #0]
   1194a:	3201      	adds	r2, #1
   1194c:	616a      	str	r2, [r5, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   1194e:	2b01      	cmp	r3, #1
   11950:	d184      	bne.n	1185c <SEGGER_SYSVIEW_GetSysDesc+0x70>
   11952:	e797      	b.n	11884 <SEGGER_SYSVIEW_GetSysDesc+0x98>
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   11954:	782b      	ldrb	r3, [r5, #0]
   11956:	3301      	adds	r3, #1
   11958:	702b      	strb	r3, [r5, #0]
   1195a:	e77f      	b.n	1185c <SEGGER_SYSVIEW_GetSysDesc+0x70>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   1195c:	782b      	ldrb	r3, [r5, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   1195e:	f8c5 800c 	str.w	r8, [r5, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   11962:	3b01      	subs	r3, #1
   11964:	b2db      	uxtb	r3, r3
   11966:	702b      	strb	r3, [r5, #0]
   11968:	e7f1      	b.n	1194e <SEGGER_SYSVIEW_GetSysDesc+0x162>
   1196a:	bf00      	nop
   1196c:	1001322c 	.word	0x1001322c
   11970:	10014258 	.word	0x10014258
   11974:	10014404 	.word	0x10014404
   11978:	10014254 	.word	0x10014254
   1197c:	e0001004 	.word	0xe0001004

00011980 <SEGGER_SYSVIEW_RecordU32>:
void SEGGER_SYSVIEW_RecordU32(unsigned int EventID, U32 Value) {
   11980:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   11984:	460b      	mov	r3, r1
   11986:	b085      	sub	sp, #20
   11988:	4607      	mov	r7, r0
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
   1198a:	f3ef 8511 	mrs	r5, BASEPRI
   1198e:	f04f 0120 	mov.w	r1, #32
   11992:	f381 8811 	msr	BASEPRI, r1
  ENCODE_U32(pPayload, Value);
   11996:	f8df 817c 	ldr.w	r8, [pc, #380]	; 11b14 <SEGGER_SYSVIEW_RecordU32+0x194>
   1199a:	2b7f      	cmp	r3, #127	; 0x7f
   1199c:	4644      	mov	r4, r8
   1199e:	d906      	bls.n	119ae <SEGGER_SYSVIEW_RecordU32+0x2e>
   119a0:	f063 027f 	orn	r2, r3, #127	; 0x7f
   119a4:	09db      	lsrs	r3, r3, #7
   119a6:	2b7f      	cmp	r3, #127	; 0x7f
   119a8:	f804 2b01 	strb.w	r2, [r4], #1
   119ac:	d8f8      	bhi.n	119a0 <SEGGER_SYSVIEW_RecordU32+0x20>
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   119ae:	4e55      	ldr	r6, [pc, #340]	; (11b04 <SEGGER_SYSVIEW_RecordU32+0x184>)
  ENCODE_U32(pPayload, Value);
   119b0:	7023      	strb	r3, [r4, #0]
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   119b2:	7833      	ldrb	r3, [r6, #0]
   119b4:	2b01      	cmp	r3, #1
   119b6:	d011      	beq.n	119dc <SEGGER_SYSVIEW_RecordU32+0x5c>
  if (_SYSVIEW_Globals.EnableState == 0) {
   119b8:	b973      	cbnz	r3, 119d8 <SEGGER_SYSVIEW_RecordU32+0x58>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   119ba:	4b53      	ldr	r3, [pc, #332]	; (11b08 <SEGGER_SYSVIEW_RecordU32+0x188>)
   119bc:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   119c0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   119c4:	429a      	cmp	r2, r3
   119c6:	d002      	beq.n	119ce <SEGGER_SYSVIEW_RecordU32+0x4e>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   119c8:	78b4      	ldrb	r4, [r6, #2]
   119ca:	2c00      	cmp	r4, #0
   119cc:	d043      	beq.n	11a56 <SEGGER_SYSVIEW_RecordU32+0xd6>
  RECORD_END();
   119ce:	f385 8811 	msr	BASEPRI, r5
}
   119d2:	b005      	add	sp, #20
   119d4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   119d8:	2b02      	cmp	r3, #2
   119da:	d054      	beq.n	11a86 <SEGGER_SYSVIEW_RecordU32+0x106>
  if (EventId < 32) {
   119dc:	2f1f      	cmp	r7, #31
  ENCODE_U32(pPayload, Value);
   119de:	f104 0401 	add.w	r4, r4, #1
  if (EventId < 32) {
   119e2:	d916      	bls.n	11a12 <SEGGER_SYSVIEW_RecordU32+0x92>
   119e4:	b2fb      	uxtb	r3, r7
    NumBytes = pEndPacket - pStartPacket;
   119e6:	eba4 0808 	sub.w	r8, r4, r8
    if (NumBytes > 127) {
   119ea:	f1b8 0f7f 	cmp.w	r8, #127	; 0x7f
   119ee:	fa5f f188 	uxtb.w	r1, r8
    NumBytes = pEndPacket - pStartPacket;
   119f2:	4846      	ldr	r0, [pc, #280]	; (11b0c <SEGGER_SYSVIEW_RecordU32+0x18c>)
    if (NumBytes > 127) {
   119f4:	d839      	bhi.n	11a6a <SEGGER_SYSVIEW_RecordU32+0xea>
    if (EventId > 127) {
   119f6:	2f7f      	cmp	r7, #127	; 0x7f
      *--pStartPacket = NumBytes;
   119f8:	f100 0203 	add.w	r2, r0, #3
   119fc:	70c1      	strb	r1, [r0, #3]
    if (EventId > 127) {
   119fe:	d93e      	bls.n	11a7e <SEGGER_SYSVIEW_RecordU32+0xfe>
      *--pStartPacket = (EventId >> 7);
   11a00:	09ff      	lsrs	r7, r7, #7
      *--pStartPacket = EventId | 0x80;
   11a02:	f063 037f 	orn	r3, r3, #127	; 0x7f
      *--pStartPacket = (EventId >> 7);
   11a06:	f802 7c01 	strb.w	r7, [r2, #-1]
      *--pStartPacket = EventId | 0x80;
   11a0a:	f802 3c02 	strb.w	r3, [r2, #-2]
   11a0e:	3a02      	subs	r2, #2
   11a10:	e009      	b.n	11a26 <SEGGER_SYSVIEW_RecordU32+0xa6>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   11a12:	69f3      	ldr	r3, [r6, #28]
   11a14:	40fb      	lsrs	r3, r7
   11a16:	07db      	lsls	r3, r3, #31
   11a18:	d4cf      	bmi.n	119ba <SEGGER_SYSVIEW_RecordU32+0x3a>
  if (EventId < 24) {
   11a1a:	2f17      	cmp	r7, #23
   11a1c:	b2fb      	uxtb	r3, r7
   11a1e:	d8e2      	bhi.n	119e6 <SEGGER_SYSVIEW_RecordU32+0x66>
    *--pStartPacket = EventId;
   11a20:	4a3a      	ldr	r2, [pc, #232]	; (11b0c <SEGGER_SYSVIEW_RecordU32+0x18c>)
   11a22:	f802 3f03 	strb.w	r3, [r2, #3]!
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11a26:	493a      	ldr	r1, [pc, #232]	; (11b10 <SEGGER_SYSVIEW_RecordU32+0x190>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11a28:	68f3      	ldr	r3, [r6, #12]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11a2a:	680f      	ldr	r7, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11a2c:	1afb      	subs	r3, r7, r3
  ENCODE_U32(pEndPacket, Delta);
   11a2e:	2b7f      	cmp	r3, #127	; 0x7f
   11a30:	d906      	bls.n	11a40 <SEGGER_SYSVIEW_RecordU32+0xc0>
   11a32:	f063 017f 	orn	r1, r3, #127	; 0x7f
   11a36:	09db      	lsrs	r3, r3, #7
   11a38:	2b7f      	cmp	r3, #127	; 0x7f
   11a3a:	f804 1b01 	strb.w	r1, [r4], #1
   11a3e:	d8f8      	bhi.n	11a32 <SEGGER_SYSVIEW_RecordU32+0xb2>
   11a40:	f804 3b01 	strb.w	r3, [r4], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   11a44:	4611      	mov	r1, r2
   11a46:	2001      	movs	r0, #1
   11a48:	1aa2      	subs	r2, r4, r2
   11a4a:	f7fe f91b 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   11a4e:	2800      	cmp	r0, #0
   11a50:	d04c      	beq.n	11aec <SEGGER_SYSVIEW_RecordU32+0x16c>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   11a52:	60f7      	str	r7, [r6, #12]
   11a54:	e7b1      	b.n	119ba <SEGGER_SYSVIEW_RecordU32+0x3a>
      _SYSVIEW_Globals.RecursionCnt = 1;
   11a56:	2301      	movs	r3, #1
   11a58:	70b3      	strb	r3, [r6, #2]
      _HandleIncomingPacket();
   11a5a:	f7fe fb3b 	bl	100d4 <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   11a5e:	70b4      	strb	r4, [r6, #2]
  RECORD_END();
   11a60:	f385 8811 	msr	BASEPRI, r5
}
   11a64:	b005      	add	sp, #20
   11a66:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      *--pStartPacket = NumBytes | 0x80;
   11a6a:	4602      	mov	r2, r0
   11a6c:	f061 017f 	orn	r1, r1, #127	; 0x7f
   11a70:	f802 1f02 	strb.w	r1, [r2, #2]!
    if (EventId > 127) {
   11a74:	2f7f      	cmp	r7, #127	; 0x7f
      *--pStartPacket = (NumBytes >> 7);
   11a76:	f3c8 11c7 	ubfx	r1, r8, #7, #8
   11a7a:	70c1      	strb	r1, [r0, #3]
    if (EventId > 127) {
   11a7c:	d8c0      	bhi.n	11a00 <SEGGER_SYSVIEW_RecordU32+0x80>
      *--pStartPacket = EventId;
   11a7e:	f802 3c01 	strb.w	r3, [r2, #-1]
   11a82:	3a01      	subs	r2, #1
   11a84:	e7cf      	b.n	11a26 <SEGGER_SYSVIEW_RecordU32+0xa6>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11a86:	6972      	ldr	r2, [r6, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   11a88:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11a8a:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   11a8c:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11a90:	f10d 0305 	add.w	r3, sp, #5
   11a94:	d906      	bls.n	11aa4 <SEGGER_SYSVIEW_RecordU32+0x124>
   11a96:	f062 017f 	orn	r1, r2, #127	; 0x7f
   11a9a:	09d2      	lsrs	r2, r2, #7
   11a9c:	2a7f      	cmp	r2, #127	; 0x7f
   11a9e:	f803 1b01 	strb.w	r1, [r3], #1
   11aa2:	d8f8      	bhi.n	11a96 <SEGGER_SYSVIEW_RecordU32+0x116>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11aa4:	491a      	ldr	r1, [pc, #104]	; (11b10 <SEGGER_SYSVIEW_RecordU32+0x190>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11aa6:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11aa8:	f8d1 9000 	ldr.w	r9, [r1]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11aac:	68f1      	ldr	r1, [r6, #12]
   11aae:	eba9 0101 	sub.w	r1, r9, r1
  ENCODE_U32(pPayload, Delta);
   11ab2:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11ab4:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   11ab8:	d906      	bls.n	11ac8 <SEGGER_SYSVIEW_RecordU32+0x148>
   11aba:	f061 037f 	orn	r3, r1, #127	; 0x7f
   11abe:	09c9      	lsrs	r1, r1, #7
   11ac0:	297f      	cmp	r1, #127	; 0x7f
   11ac2:	f802 3b01 	strb.w	r3, [r2], #1
   11ac6:	d8f8      	bhi.n	11aba <SEGGER_SYSVIEW_RecordU32+0x13a>
   11ac8:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   11aca:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   11acc:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   11ad0:	2001      	movs	r0, #1
   11ad2:	4611      	mov	r1, r2
   11ad4:	1a9a      	subs	r2, r3, r2
   11ad6:	f7fe f8d5 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   11ada:	b958      	cbnz	r0, 11af4 <SEGGER_SYSVIEW_RecordU32+0x174>
    _SYSVIEW_Globals.DropCount++;
   11adc:	6972      	ldr	r2, [r6, #20]
   11ade:	7833      	ldrb	r3, [r6, #0]
   11ae0:	3201      	adds	r2, #1
   11ae2:	6172      	str	r2, [r6, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   11ae4:	2b01      	cmp	r3, #1
   11ae6:	f47f af68 	bne.w	119ba <SEGGER_SYSVIEW_RecordU32+0x3a>
   11aea:	e777      	b.n	119dc <SEGGER_SYSVIEW_RecordU32+0x5c>
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   11aec:	7833      	ldrb	r3, [r6, #0]
   11aee:	3301      	adds	r3, #1
   11af0:	7033      	strb	r3, [r6, #0]
   11af2:	e762      	b.n	119ba <SEGGER_SYSVIEW_RecordU32+0x3a>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   11af4:	7833      	ldrb	r3, [r6, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   11af6:	f8c6 900c 	str.w	r9, [r6, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   11afa:	3b01      	subs	r3, #1
   11afc:	b2db      	uxtb	r3, r3
   11afe:	7033      	strb	r3, [r6, #0]
   11b00:	e7f0      	b.n	11ae4 <SEGGER_SYSVIEW_RecordU32+0x164>
   11b02:	bf00      	nop
   11b04:	1001322c 	.word	0x1001322c
   11b08:	10014404 	.word	0x10014404
   11b0c:	10014254 	.word	0x10014254
   11b10:	e0001004 	.word	0xe0001004
   11b14:	10014258 	.word	0x10014258

00011b18 <SEGGER_SYSVIEW_RecordU32x2>:
void SEGGER_SYSVIEW_RecordU32x2(unsigned int EventID, U32 Para0, U32 Para1) {
   11b18:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   11b1c:	460b      	mov	r3, r1
   11b1e:	b085      	sub	sp, #20
   11b20:	4606      	mov	r6, r0
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
   11b22:	f3ef 8511 	mrs	r5, BASEPRI
   11b26:	f04f 0120 	mov.w	r1, #32
   11b2a:	f381 8811 	msr	BASEPRI, r1
  ENCODE_U32(pPayload, Para0);
   11b2e:	4f68      	ldr	r7, [pc, #416]	; (11cd0 <SEGGER_SYSVIEW_RecordU32x2+0x1b8>)
   11b30:	2b7f      	cmp	r3, #127	; 0x7f
   11b32:	4639      	mov	r1, r7
   11b34:	d906      	bls.n	11b44 <SEGGER_SYSVIEW_RecordU32x2+0x2c>
   11b36:	f063 007f 	orn	r0, r3, #127	; 0x7f
   11b3a:	09db      	lsrs	r3, r3, #7
   11b3c:	2b7f      	cmp	r3, #127	; 0x7f
   11b3e:	f801 0b01 	strb.w	r0, [r1], #1
   11b42:	d8f8      	bhi.n	11b36 <SEGGER_SYSVIEW_RecordU32x2+0x1e>
  ENCODE_U32(pPayload, Para1);
   11b44:	2a7f      	cmp	r2, #127	; 0x7f
  ENCODE_U32(pPayload, Para0);
   11b46:	700b      	strb	r3, [r1, #0]
   11b48:	f101 0401 	add.w	r4, r1, #1
  ENCODE_U32(pPayload, Para1);
   11b4c:	d906      	bls.n	11b5c <SEGGER_SYSVIEW_RecordU32x2+0x44>
   11b4e:	f062 037f 	orn	r3, r2, #127	; 0x7f
   11b52:	09d2      	lsrs	r2, r2, #7
   11b54:	2a7f      	cmp	r2, #127	; 0x7f
   11b56:	f804 3b01 	strb.w	r3, [r4], #1
   11b5a:	d8f8      	bhi.n	11b4e <SEGGER_SYSVIEW_RecordU32x2+0x36>
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   11b5c:	f8df 8180 	ldr.w	r8, [pc, #384]	; 11ce0 <SEGGER_SYSVIEW_RecordU32x2+0x1c8>
  ENCODE_U32(pPayload, Para1);
   11b60:	7022      	strb	r2, [r4, #0]
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   11b62:	f898 3000 	ldrb.w	r3, [r8]
   11b66:	2b01      	cmp	r3, #1
   11b68:	d012      	beq.n	11b90 <SEGGER_SYSVIEW_RecordU32x2+0x78>
  if (_SYSVIEW_Globals.EnableState == 0) {
   11b6a:	b97b      	cbnz	r3, 11b8c <SEGGER_SYSVIEW_RecordU32x2+0x74>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   11b6c:	4b59      	ldr	r3, [pc, #356]	; (11cd4 <SEGGER_SYSVIEW_RecordU32x2+0x1bc>)
   11b6e:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   11b72:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   11b76:	429a      	cmp	r2, r3
   11b78:	d003      	beq.n	11b82 <SEGGER_SYSVIEW_RecordU32x2+0x6a>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   11b7a:	f898 4002 	ldrb.w	r4, [r8, #2]
   11b7e:	2c00      	cmp	r4, #0
   11b80:	d044      	beq.n	11c0c <SEGGER_SYSVIEW_RecordU32x2+0xf4>
  RECORD_END();
   11b82:	f385 8811 	msr	BASEPRI, r5
}
   11b86:	b005      	add	sp, #20
   11b88:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   11b8c:	2b02      	cmp	r3, #2
   11b8e:	d057      	beq.n	11c40 <SEGGER_SYSVIEW_RecordU32x2+0x128>
  if (EventId < 32) {
   11b90:	2e1f      	cmp	r6, #31
  ENCODE_U32(pPayload, Para1);
   11b92:	f104 0101 	add.w	r1, r4, #1
  if (EventId < 32) {
   11b96:	d913      	bls.n	11bc0 <SEGGER_SYSVIEW_RecordU32x2+0xa8>
   11b98:	b2f3      	uxtb	r3, r6
    NumBytes = pEndPacket - pStartPacket;
   11b9a:	1bcf      	subs	r7, r1, r7
    if (NumBytes > 127) {
   11b9c:	2f7f      	cmp	r7, #127	; 0x7f
   11b9e:	b2f8      	uxtb	r0, r7
    NumBytes = pEndPacket - pStartPacket;
   11ba0:	4c4d      	ldr	r4, [pc, #308]	; (11cd8 <SEGGER_SYSVIEW_RecordU32x2+0x1c0>)
    if (NumBytes > 127) {
   11ba2:	d83f      	bhi.n	11c24 <SEGGER_SYSVIEW_RecordU32x2+0x10c>
    if (EventId > 127) {
   11ba4:	2e7f      	cmp	r6, #127	; 0x7f
      *--pStartPacket = NumBytes;
   11ba6:	f104 0203 	add.w	r2, r4, #3
   11baa:	70e0      	strb	r0, [r4, #3]
    if (EventId > 127) {
   11bac:	d944      	bls.n	11c38 <SEGGER_SYSVIEW_RecordU32x2+0x120>
      *--pStartPacket = (EventId >> 7);
   11bae:	09f6      	lsrs	r6, r6, #7
      *--pStartPacket = EventId | 0x80;
   11bb0:	f063 037f 	orn	r3, r3, #127	; 0x7f
      *--pStartPacket = (EventId >> 7);
   11bb4:	f802 6c01 	strb.w	r6, [r2, #-1]
      *--pStartPacket = EventId | 0x80;
   11bb8:	f802 3c02 	strb.w	r3, [r2, #-2]
   11bbc:	3a02      	subs	r2, #2
   11bbe:	e00a      	b.n	11bd6 <SEGGER_SYSVIEW_RecordU32x2+0xbe>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   11bc0:	f8d8 301c 	ldr.w	r3, [r8, #28]
   11bc4:	40f3      	lsrs	r3, r6
   11bc6:	07db      	lsls	r3, r3, #31
   11bc8:	d4d0      	bmi.n	11b6c <SEGGER_SYSVIEW_RecordU32x2+0x54>
  if (EventId < 24) {
   11bca:	2e17      	cmp	r6, #23
   11bcc:	b2f3      	uxtb	r3, r6
   11bce:	d8e4      	bhi.n	11b9a <SEGGER_SYSVIEW_RecordU32x2+0x82>
    *--pStartPacket = EventId;
   11bd0:	4a41      	ldr	r2, [pc, #260]	; (11cd8 <SEGGER_SYSVIEW_RecordU32x2+0x1c0>)
   11bd2:	f802 3f03 	strb.w	r3, [r2, #3]!
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11bd6:	4841      	ldr	r0, [pc, #260]	; (11cdc <SEGGER_SYSVIEW_RecordU32x2+0x1c4>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11bd8:	f8d8 300c 	ldr.w	r3, [r8, #12]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11bdc:	6806      	ldr	r6, [r0, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11bde:	1af3      	subs	r3, r6, r3
  ENCODE_U32(pEndPacket, Delta);
   11be0:	2b7f      	cmp	r3, #127	; 0x7f
   11be2:	d906      	bls.n	11bf2 <SEGGER_SYSVIEW_RecordU32x2+0xda>
   11be4:	f063 007f 	orn	r0, r3, #127	; 0x7f
   11be8:	09db      	lsrs	r3, r3, #7
   11bea:	2b7f      	cmp	r3, #127	; 0x7f
   11bec:	f801 0b01 	strb.w	r0, [r1], #1
   11bf0:	d8f8      	bhi.n	11be4 <SEGGER_SYSVIEW_RecordU32x2+0xcc>
   11bf2:	460c      	mov	r4, r1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   11bf4:	2001      	movs	r0, #1
  ENCODE_U32(pEndPacket, Delta);
   11bf6:	f804 3b01 	strb.w	r3, [r4], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   11bfa:	4611      	mov	r1, r2
   11bfc:	1aa2      	subs	r2, r4, r2
   11bfe:	f7fe f841 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   11c02:	2800      	cmp	r0, #0
   11c04:	d054      	beq.n	11cb0 <SEGGER_SYSVIEW_RecordU32x2+0x198>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   11c06:	f8c8 600c 	str.w	r6, [r8, #12]
   11c0a:	e7af      	b.n	11b6c <SEGGER_SYSVIEW_RecordU32x2+0x54>
      _SYSVIEW_Globals.RecursionCnt = 1;
   11c0c:	2301      	movs	r3, #1
   11c0e:	f888 3002 	strb.w	r3, [r8, #2]
      _HandleIncomingPacket();
   11c12:	f7fe fa5f 	bl	100d4 <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   11c16:	f888 4002 	strb.w	r4, [r8, #2]
  RECORD_END();
   11c1a:	f385 8811 	msr	BASEPRI, r5
}
   11c1e:	b005      	add	sp, #20
   11c20:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      *--pStartPacket = NumBytes | 0x80;
   11c24:	4622      	mov	r2, r4
   11c26:	f060 007f 	orn	r0, r0, #127	; 0x7f
   11c2a:	f802 0f02 	strb.w	r0, [r2, #2]!
    if (EventId > 127) {
   11c2e:	2e7f      	cmp	r6, #127	; 0x7f
      *--pStartPacket = (NumBytes >> 7);
   11c30:	f3c7 10c7 	ubfx	r0, r7, #7, #8
   11c34:	70e0      	strb	r0, [r4, #3]
    if (EventId > 127) {
   11c36:	d8ba      	bhi.n	11bae <SEGGER_SYSVIEW_RecordU32x2+0x96>
      *--pStartPacket = EventId;
   11c38:	f802 3c01 	strb.w	r3, [r2, #-1]
   11c3c:	3a01      	subs	r2, #1
   11c3e:	e7ca      	b.n	11bd6 <SEGGER_SYSVIEW_RecordU32x2+0xbe>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11c40:	f8d8 2014 	ldr.w	r2, [r8, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   11c44:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11c46:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   11c48:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11c4c:	f10d 0305 	add.w	r3, sp, #5
   11c50:	d906      	bls.n	11c60 <SEGGER_SYSVIEW_RecordU32x2+0x148>
   11c52:	f062 017f 	orn	r1, r2, #127	; 0x7f
   11c56:	09d2      	lsrs	r2, r2, #7
   11c58:	2a7f      	cmp	r2, #127	; 0x7f
   11c5a:	f803 1b01 	strb.w	r1, [r3], #1
   11c5e:	d8f8      	bhi.n	11c52 <SEGGER_SYSVIEW_RecordU32x2+0x13a>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11c60:	491e      	ldr	r1, [pc, #120]	; (11cdc <SEGGER_SYSVIEW_RecordU32x2+0x1c4>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11c62:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11c64:	f8d1 9000 	ldr.w	r9, [r1]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11c68:	f8d8 100c 	ldr.w	r1, [r8, #12]
   11c6c:	eba9 0101 	sub.w	r1, r9, r1
  ENCODE_U32(pPayload, Delta);
   11c70:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11c72:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   11c76:	d906      	bls.n	11c86 <SEGGER_SYSVIEW_RecordU32x2+0x16e>
   11c78:	f061 037f 	orn	r3, r1, #127	; 0x7f
   11c7c:	09c9      	lsrs	r1, r1, #7
   11c7e:	297f      	cmp	r1, #127	; 0x7f
   11c80:	f802 3b01 	strb.w	r3, [r2], #1
   11c84:	d8f8      	bhi.n	11c78 <SEGGER_SYSVIEW_RecordU32x2+0x160>
   11c86:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   11c88:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   11c8a:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   11c8e:	2001      	movs	r0, #1
   11c90:	4611      	mov	r1, r2
   11c92:	1a9a      	subs	r2, r3, r2
   11c94:	f7fd fff6 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   11c98:	b980      	cbnz	r0, 11cbc <SEGGER_SYSVIEW_RecordU32x2+0x1a4>
    _SYSVIEW_Globals.DropCount++;
   11c9a:	f8d8 2014 	ldr.w	r2, [r8, #20]
   11c9e:	f898 3000 	ldrb.w	r3, [r8]
   11ca2:	3201      	adds	r2, #1
   11ca4:	f8c8 2014 	str.w	r2, [r8, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   11ca8:	2b01      	cmp	r3, #1
   11caa:	f47f af5f 	bne.w	11b6c <SEGGER_SYSVIEW_RecordU32x2+0x54>
   11cae:	e76f      	b.n	11b90 <SEGGER_SYSVIEW_RecordU32x2+0x78>
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   11cb0:	f898 3000 	ldrb.w	r3, [r8]
   11cb4:	3301      	adds	r3, #1
   11cb6:	f888 3000 	strb.w	r3, [r8]
   11cba:	e757      	b.n	11b6c <SEGGER_SYSVIEW_RecordU32x2+0x54>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   11cbc:	f898 3000 	ldrb.w	r3, [r8]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   11cc0:	f8c8 900c 	str.w	r9, [r8, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   11cc4:	3b01      	subs	r3, #1
   11cc6:	b2db      	uxtb	r3, r3
   11cc8:	f888 3000 	strb.w	r3, [r8]
   11ccc:	e7ec      	b.n	11ca8 <SEGGER_SYSVIEW_RecordU32x2+0x190>
   11cce:	bf00      	nop
   11cd0:	10014258 	.word	0x10014258
   11cd4:	10014404 	.word	0x10014404
   11cd8:	10014254 	.word	0x10014254
   11cdc:	e0001004 	.word	0xe0001004
   11ce0:	1001322c 	.word	0x1001322c

00011ce4 <SEGGER_SYSVIEW_Warn>:
*    Print a warning string to the host.
*
*  Parameters
*    s        - String to sent.
*/
void SEGGER_SYSVIEW_Warn(const char* s) {
   11ce4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11ce8:	b085      	sub	sp, #20
  U8* pPayload;
  U8* pPayloadStart;
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + SEGGER_SYSVIEW_MAX_STRING_LEN);
   11cea:	f3ef 8611 	mrs	r6, BASEPRI
   11cee:	f04f 0120 	mov.w	r1, #32
   11cf2:	f381 8811 	msr	BASEPRI, r1
  while(*(pText + Len) != 0) {
   11cf6:	7803      	ldrb	r3, [r0, #0]
   11cf8:	2b00      	cmp	r3, #0
   11cfa:	f000 8103 	beq.w	11f04 <SEGGER_SYSVIEW_Warn+0x220>
   11cfe:	4602      	mov	r2, r0
  Len = 0;
   11d00:	2300      	movs	r3, #0
  while(*(pText + Len) != 0) {
   11d02:	f812 1f01 	ldrb.w	r1, [r2, #1]!
    Len++;
   11d06:	3301      	adds	r3, #1
  while(*(pText + Len) != 0) {
   11d08:	2900      	cmp	r1, #0
   11d0a:	d1fa      	bne.n	11d02 <SEGGER_SYSVIEW_Warn+0x1e>
    *pPayload++ = Len; 
   11d0c:	4d83      	ldr	r5, [pc, #524]	; (11f1c <SEGGER_SYSVIEW_Warn+0x238>)
   11d0e:	f100 0208 	add.w	r2, r0, #8
   11d12:	f105 0c05 	add.w	ip, r5, #5
   11d16:	f105 070d 	add.w	r7, r5, #13
   11d1a:	4287      	cmp	r7, r0
   11d1c:	bf88      	it	hi
   11d1e:	4562      	cmphi	r2, ip
   11d20:	bf94      	ite	ls
   11d22:	2201      	movls	r2, #1
   11d24:	2200      	movhi	r2, #0
   11d26:	ea40 040c 	orr.w	r4, r0, ip
   11d2a:	2b80      	cmp	r3, #128	; 0x80
   11d2c:	461f      	mov	r7, r3
   11d2e:	bf28      	it	cs
   11d30:	2780      	movcs	r7, #128	; 0x80
   11d32:	f014 0f07 	tst.w	r4, #7
   11d36:	bf18      	it	ne
   11d38:	2200      	movne	r2, #0
   11d3a:	712f      	strb	r7, [r5, #4]
   11d3c:	2a00      	cmp	r2, #0
   11d3e:	f000 80d2 	beq.w	11ee6 <SEGGER_SYSVIEW_Warn+0x202>
   11d42:	2b0c      	cmp	r3, #12
   11d44:	f240 80cf 	bls.w	11ee6 <SEGGER_SYSVIEW_Warn+0x202>
   11d48:	2b00      	cmp	r3, #0
   11d4a:	bf14      	ite	ne
   11d4c:	46be      	movne	lr, r7
   11d4e:	f04f 0e01 	moveq.w	lr, #1
   11d52:	ea4f 0bde 	mov.w	fp, lr, lsr #3
   11d56:	46e2      	mov	sl, ip
   11d58:	1dab      	adds	r3, r5, #6
   11d5a:	4602      	mov	r2, r0
    *pPayload++ = *pText++;
   11d5c:	e8f2 8902 	ldrd	r8, r9, [r2], #8
   11d60:	3101      	adds	r1, #1
   11d62:	461c      	mov	r4, r3
   11d64:	458b      	cmp	fp, r1
   11d66:	e8ea 8902 	strd	r8, r9, [sl], #8
   11d6a:	f104 0407 	add.w	r4, r4, #7
   11d6e:	f103 0308 	add.w	r3, r3, #8
   11d72:	d8f3      	bhi.n	11d5c <SEGGER_SYSVIEW_Warn+0x78>
   11d74:	f02e 0307 	bic.w	r3, lr, #7
   11d78:	4573      	cmp	r3, lr
   11d7a:	eb00 0103 	add.w	r1, r0, r3
   11d7e:	eb0c 0203 	add.w	r2, ip, r3
   11d82:	d02d      	beq.n	11de0 <SEGGER_SYSVIEW_Warn+0xfc>
   11d84:	5cc0      	ldrb	r0, [r0, r3]
   11d86:	f80c 0003 	strb.w	r0, [ip, r3]
    n++;
   11d8a:	1c58      	adds	r0, r3, #1
  while (n < Len) {
   11d8c:	42b8      	cmp	r0, r7
    *pPayload++ = *pText++;
   11d8e:	f102 0401 	add.w	r4, r2, #1
  while (n < Len) {
   11d92:	d225      	bcs.n	11de0 <SEGGER_SYSVIEW_Warn+0xfc>
    *pPayload++ = *pText++;
   11d94:	7848      	ldrb	r0, [r1, #1]
   11d96:	7050      	strb	r0, [r2, #1]
    n++;
   11d98:	1c98      	adds	r0, r3, #2
  while (n < Len) {
   11d9a:	4287      	cmp	r7, r0
    *pPayload++ = *pText++;
   11d9c:	f102 0402 	add.w	r4, r2, #2
  while (n < Len) {
   11da0:	d91e      	bls.n	11de0 <SEGGER_SYSVIEW_Warn+0xfc>
    *pPayload++ = *pText++;
   11da2:	7888      	ldrb	r0, [r1, #2]
   11da4:	7090      	strb	r0, [r2, #2]
    n++;
   11da6:	1cd8      	adds	r0, r3, #3
  while (n < Len) {
   11da8:	4287      	cmp	r7, r0
    *pPayload++ = *pText++;
   11daa:	f102 0403 	add.w	r4, r2, #3
  while (n < Len) {
   11dae:	d917      	bls.n	11de0 <SEGGER_SYSVIEW_Warn+0xfc>
    *pPayload++ = *pText++;
   11db0:	78c8      	ldrb	r0, [r1, #3]
   11db2:	70d0      	strb	r0, [r2, #3]
    n++;
   11db4:	1d18      	adds	r0, r3, #4
  while (n < Len) {
   11db6:	4287      	cmp	r7, r0
    *pPayload++ = *pText++;
   11db8:	f102 0404 	add.w	r4, r2, #4
  while (n < Len) {
   11dbc:	d910      	bls.n	11de0 <SEGGER_SYSVIEW_Warn+0xfc>
    *pPayload++ = *pText++;
   11dbe:	7908      	ldrb	r0, [r1, #4]
   11dc0:	7110      	strb	r0, [r2, #4]
    n++;
   11dc2:	1d58      	adds	r0, r3, #5
  while (n < Len) {
   11dc4:	4287      	cmp	r7, r0
    *pPayload++ = *pText++;
   11dc6:	f102 0405 	add.w	r4, r2, #5
  while (n < Len) {
   11dca:	d909      	bls.n	11de0 <SEGGER_SYSVIEW_Warn+0xfc>
    n++;
   11dcc:	3306      	adds	r3, #6
    *pPayload++ = *pText++;
   11dce:	7948      	ldrb	r0, [r1, #5]
   11dd0:	7150      	strb	r0, [r2, #5]
  while (n < Len) {
   11dd2:	429f      	cmp	r7, r3
    *pPayload++ = *pText++;
   11dd4:	f102 0406 	add.w	r4, r2, #6
  while (n < Len) {
   11dd8:	d902      	bls.n	11de0 <SEGGER_SYSVIEW_Warn+0xfc>
    *pPayload++ = *pText++;
   11dda:	798b      	ldrb	r3, [r1, #6]
   11ddc:	7193      	strb	r3, [r2, #6]
   11dde:	1dd4      	adds	r4, r2, #7
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   11de0:	4f4f      	ldr	r7, [pc, #316]	; (11f20 <SEGGER_SYSVIEW_Warn+0x23c>)
   11de2:	783b      	ldrb	r3, [r7, #0]
  //
  pPayload = _EncodeStr(pPayloadStart, s, SEGGER_SYSVIEW_MAX_STRING_LEN);
  ENCODE_U32(pPayload, SEGGER_SYSVIEW_WARNING);
   11de4:	2201      	movs	r2, #1
  ENCODE_U32(pPayload, 0);
   11de6:	2100      	movs	r1, #0
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   11de8:	4293      	cmp	r3, r2
  ENCODE_U32(pPayload, SEGGER_SYSVIEW_WARNING);
   11dea:	7022      	strb	r2, [r4, #0]
  ENCODE_U32(pPayload, 0);
   11dec:	7061      	strb	r1, [r4, #1]
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   11dee:	d010      	beq.n	11e12 <SEGGER_SYSVIEW_Warn+0x12e>
  if (_SYSVIEW_Globals.EnableState == 0) {
   11df0:	b96b      	cbnz	r3, 11e0e <SEGGER_SYSVIEW_Warn+0x12a>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   11df2:	4b4c      	ldr	r3, [pc, #304]	; (11f24 <SEGGER_SYSVIEW_Warn+0x240>)
   11df4:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   11df8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   11dfc:	429a      	cmp	r2, r3
   11dfe:	d001      	beq.n	11e04 <SEGGER_SYSVIEW_Warn+0x120>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   11e00:	78bc      	ldrb	r4, [r7, #2]
   11e02:	b374      	cbz	r4, 11e62 <SEGGER_SYSVIEW_Warn+0x17e>
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
  RECORD_END();
   11e04:	f386 8811 	msr	BASEPRI, r6
}
   11e08:	b005      	add	sp, #20
   11e0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   11e0e:	2b02      	cmp	r3, #2
   11e10:	d038      	beq.n	11e84 <SEGGER_SYSVIEW_Warn+0x1a0>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   11e12:	69fb      	ldr	r3, [r7, #28]
   11e14:	015b      	lsls	r3, r3, #5
   11e16:	d4ec      	bmi.n	11df2 <SEGGER_SYSVIEW_Warn+0x10e>
    NumBytes = pEndPacket - pStartPacket;
   11e18:	4943      	ldr	r1, [pc, #268]	; (11f28 <SEGGER_SYSVIEW_Warn+0x244>)
  ENCODE_U32(pPayload, 0);
   11e1a:	1ca2      	adds	r2, r4, #2
    NumBytes = pEndPacket - pStartPacket;
   11e1c:	1a50      	subs	r0, r2, r1
    if (NumBytes > 127) {
   11e1e:	287f      	cmp	r0, #127	; 0x7f
   11e20:	b2c3      	uxtb	r3, r0
   11e22:	d828      	bhi.n	11e76 <SEGGER_SYSVIEW_Warn+0x192>
      *--pStartPacket = NumBytes;
   11e24:	3901      	subs	r1, #1
   11e26:	70eb      	strb	r3, [r5, #3]
      *--pStartPacket = EventId;
   11e28:	201a      	movs	r0, #26
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11e2a:	4b40      	ldr	r3, [pc, #256]	; (11f2c <SEGGER_SYSVIEW_Warn+0x248>)
      *--pStartPacket = EventId;
   11e2c:	f801 0c01 	strb.w	r0, [r1, #-1]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11e30:	681c      	ldr	r4, [r3, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11e32:	68fb      	ldr	r3, [r7, #12]
   11e34:	1ae3      	subs	r3, r4, r3
  ENCODE_U32(pEndPacket, Delta);
   11e36:	2b7f      	cmp	r3, #127	; 0x7f
      *--pStartPacket = EventId;
   11e38:	f101 30ff 	add.w	r0, r1, #4294967295	; 0xffffffff
  ENCODE_U32(pEndPacket, Delta);
   11e3c:	d906      	bls.n	11e4c <SEGGER_SYSVIEW_Warn+0x168>
   11e3e:	f063 017f 	orn	r1, r3, #127	; 0x7f
   11e42:	09db      	lsrs	r3, r3, #7
   11e44:	2b7f      	cmp	r3, #127	; 0x7f
   11e46:	f802 1b01 	strb.w	r1, [r2], #1
   11e4a:	d8f8      	bhi.n	11e3e <SEGGER_SYSVIEW_Warn+0x15a>
   11e4c:	f802 3b01 	strb.w	r3, [r2], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   11e50:	4601      	mov	r1, r0
   11e52:	1a12      	subs	r2, r2, r0
   11e54:	2001      	movs	r0, #1
   11e56:	f7fd ff15 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   11e5a:	2800      	cmp	r0, #0
   11e5c:	d04e      	beq.n	11efc <SEGGER_SYSVIEW_Warn+0x218>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   11e5e:	60fc      	str	r4, [r7, #12]
   11e60:	e7c7      	b.n	11df2 <SEGGER_SYSVIEW_Warn+0x10e>
      _SYSVIEW_Globals.RecursionCnt = 1;
   11e62:	2301      	movs	r3, #1
   11e64:	70bb      	strb	r3, [r7, #2]
      _HandleIncomingPacket();
   11e66:	f7fe f935 	bl	100d4 <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   11e6a:	70bc      	strb	r4, [r7, #2]
  RECORD_END();
   11e6c:	f386 8811 	msr	BASEPRI, r6
}
   11e70:	b005      	add	sp, #20
   11e72:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      *--pStartPacket = NumBytes | 0x80;
   11e76:	f063 037f 	orn	r3, r3, #127	; 0x7f
   11e7a:	70ab      	strb	r3, [r5, #2]
   11e7c:	3902      	subs	r1, #2
      *--pStartPacket = (NumBytes >> 7);
   11e7e:	f3c0 13c7 	ubfx	r3, r0, #7, #8
   11e82:	e7d0      	b.n	11e26 <SEGGER_SYSVIEW_Warn+0x142>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11e84:	6979      	ldr	r1, [r7, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   11e86:	f88d 2004 	strb.w	r2, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11e8a:	297f      	cmp	r1, #127	; 0x7f
   11e8c:	f10d 0305 	add.w	r3, sp, #5
   11e90:	d906      	bls.n	11ea0 <SEGGER_SYSVIEW_Warn+0x1bc>
   11e92:	f061 027f 	orn	r2, r1, #127	; 0x7f
   11e96:	09c9      	lsrs	r1, r1, #7
   11e98:	297f      	cmp	r1, #127	; 0x7f
   11e9a:	f803 2b01 	strb.w	r2, [r3], #1
   11e9e:	d8f8      	bhi.n	11e92 <SEGGER_SYSVIEW_Warn+0x1ae>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11ea0:	4a22      	ldr	r2, [pc, #136]	; (11f2c <SEGGER_SYSVIEW_Warn+0x248>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11ea2:	7019      	strb	r1, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11ea4:	f8d2 8000 	ldr.w	r8, [r2]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11ea8:	68f9      	ldr	r1, [r7, #12]
   11eaa:	eba8 0101 	sub.w	r1, r8, r1
  ENCODE_U32(pPayload, Delta);
   11eae:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11eb0:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   11eb4:	d906      	bls.n	11ec4 <SEGGER_SYSVIEW_Warn+0x1e0>
   11eb6:	f061 037f 	orn	r3, r1, #127	; 0x7f
   11eba:	09c9      	lsrs	r1, r1, #7
   11ebc:	297f      	cmp	r1, #127	; 0x7f
   11ebe:	f802 3b01 	strb.w	r3, [r2], #1
   11ec2:	d8f8      	bhi.n	11eb6 <SEGGER_SYSVIEW_Warn+0x1d2>
   11ec4:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   11ec6:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   11ec8:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   11ecc:	2001      	movs	r0, #1
   11ece:	4611      	mov	r1, r2
   11ed0:	1a9a      	subs	r2, r3, r2
   11ed2:	f7fd fed7 	bl	fc84 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   11ed6:	b9c8      	cbnz	r0, 11f0c <SEGGER_SYSVIEW_Warn+0x228>
    _SYSVIEW_Globals.DropCount++;
   11ed8:	697a      	ldr	r2, [r7, #20]
   11eda:	783b      	ldrb	r3, [r7, #0]
   11edc:	3201      	adds	r2, #1
   11ede:	617a      	str	r2, [r7, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   11ee0:	2b01      	cmp	r3, #1
   11ee2:	d186      	bne.n	11df2 <SEGGER_SYSVIEW_Warn+0x10e>
   11ee4:	e795      	b.n	11e12 <SEGGER_SYSVIEW_Warn+0x12e>
    *pPayload++ = Len; 
   11ee6:	4c12      	ldr	r4, [pc, #72]	; (11f30 <SEGGER_SYSVIEW_Warn+0x24c>)
   11ee8:	3801      	subs	r0, #1
   11eea:	2300      	movs	r3, #0
    n++;
   11eec:	3301      	adds	r3, #1
    *pPayload++ = *pText++;
   11eee:	f810 2f01 	ldrb.w	r2, [r0, #1]!
   11ef2:	f804 2b01 	strb.w	r2, [r4], #1
  while (n < Len) {
   11ef6:	429f      	cmp	r7, r3
   11ef8:	d8f8      	bhi.n	11eec <SEGGER_SYSVIEW_Warn+0x208>
   11efa:	e771      	b.n	11de0 <SEGGER_SYSVIEW_Warn+0xfc>
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   11efc:	783b      	ldrb	r3, [r7, #0]
   11efe:	3301      	adds	r3, #1
   11f00:	703b      	strb	r3, [r7, #0]
   11f02:	e776      	b.n	11df2 <SEGGER_SYSVIEW_Warn+0x10e>
    *pPayload++ = Len; 
   11f04:	4d05      	ldr	r5, [pc, #20]	; (11f1c <SEGGER_SYSVIEW_Warn+0x238>)
   11f06:	712b      	strb	r3, [r5, #4]
   11f08:	1d6c      	adds	r4, r5, #5
   11f0a:	e769      	b.n	11de0 <SEGGER_SYSVIEW_Warn+0xfc>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   11f0c:	783b      	ldrb	r3, [r7, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   11f0e:	f8c7 800c 	str.w	r8, [r7, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   11f12:	3b01      	subs	r3, #1
   11f14:	b2db      	uxtb	r3, r3
   11f16:	703b      	strb	r3, [r7, #0]
   11f18:	e7e2      	b.n	11ee0 <SEGGER_SYSVIEW_Warn+0x1fc>
   11f1a:	bf00      	nop
   11f1c:	10014254 	.word	0x10014254
   11f20:	1001322c 	.word	0x1001322c
   11f24:	10014404 	.word	0x10014404
   11f28:	10014258 	.word	0x10014258
   11f2c:	e0001004 	.word	0xe0001004
   11f30:	10014259 	.word	0x10014259

00011f34 <_cbSendTaskList>:
*  Function description
*    This function is part of the link between FreeRTOS and SYSVIEW.
*    Called from SystemView when asked by the host, it uses SYSVIEW
*    functions to send the entire task list to the host.
*/
static void _cbSendTaskList(void) {
   11f34:	b5f0      	push	{r4, r5, r6, r7, lr}
  unsigned n;

  for (n = 0; n < _NumTasks; n++) {
   11f36:	4f0d      	ldr	r7, [pc, #52]	; (11f6c <_cbSendTaskList+0x38>)
   11f38:	683b      	ldr	r3, [r7, #0]
static void _cbSendTaskList(void) {
   11f3a:	b087      	sub	sp, #28
  for (n = 0; n < _NumTasks; n++) {
   11f3c:	b19b      	cbz	r3, 11f66 <_cbSendTaskList+0x32>
   11f3e:	4c0c      	ldr	r4, [pc, #48]	; (11f70 <_cbSendTaskList+0x3c>)
   11f40:	2500      	movs	r5, #0
#if INCLUDE_uxTaskGetStackHighWaterMark // Report Task Stack High Watermark
    _aTasks[n].uStackHighWaterMark = uxTaskGetStackHighWaterMark((TaskHandle_t)_aTasks[n].xHandle);
#endif
    SYSVIEW_SendTaskInfo((U32)_aTasks[n].xHandle, _aTasks[n].pcTaskName, (unsigned)_aTasks[n].uxCurrentPriority, (U32)_aTasks[n].pxStack, (unsigned)_aTasks[n].uStackHighWaterMark);
   11f42:	e9d4 0601 	ldrd	r0, r6, [r4, #4]
   11f46:	e9d4 1203 	ldrd	r1, r2, [r4, #12]
void SYSVIEW_SendTaskInfo(U32 TaskID, const char* sName, unsigned Prio, U32 StackBase, unsigned StackSize) {
  SEGGER_SYSVIEW_TASKINFO TaskInfo;

  memset(&TaskInfo, 0, sizeof(TaskInfo)); // Fill all elements with 0 to allow extending the structure in future version without breaking the code
  TaskInfo.TaskID     = TaskID;
  TaskInfo.sName      = sName;
   11f4a:	9002      	str	r0, [sp, #8]
  TaskInfo.TaskID     = TaskID;
   11f4c:	f854 3b14 	ldr.w	r3, [r4], #20
   11f50:	9301      	str	r3, [sp, #4]
  TaskInfo.Prio       = Prio;
  TaskInfo.StackBase  = StackBase;
  TaskInfo.StackSize  = StackSize;
  SEGGER_SYSVIEW_SendTaskInfo(&TaskInfo);
   11f52:	a801      	add	r0, sp, #4
  TaskInfo.StackBase  = StackBase;
   11f54:	e9cd 6103 	strd	r6, r1, [sp, #12]
  TaskInfo.StackSize  = StackSize;
   11f58:	9205      	str	r2, [sp, #20]
  SEGGER_SYSVIEW_SendTaskInfo(&TaskInfo);
   11f5a:	f7fe f9f7 	bl	1034c <SEGGER_SYSVIEW_SendTaskInfo>
  for (n = 0; n < _NumTasks; n++) {
   11f5e:	683b      	ldr	r3, [r7, #0]
   11f60:	3501      	adds	r5, #1
   11f62:	42ab      	cmp	r3, r5
   11f64:	d8ed      	bhi.n	11f42 <_cbSendTaskList+0xe>
}
   11f66:	b007      	add	sp, #28
   11f68:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11f6a:	bf00      	nop
   11f6c:	1001433c 	.word	0x1001433c
   11f70:	10014340 	.word	0x10014340

00011f74 <_cbGetTime>:
static U64 _cbGetTime(void) {
   11f74:	b508      	push	{r3, lr}
  Time = xTaskGetTickCountFromISR();
   11f76:	f7fb f8e7 	bl	d148 <xTaskGetTickCountFromISR>
  Time *= 1000;
   11f7a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
}
   11f7e:	fba0 0103 	umull	r0, r1, r0, r3
   11f82:	bd08      	pop	{r3, pc}

00011f84 <SYSVIEW_AddTask>:
void SYSVIEW_AddTask(U32 xHandle, const char* pcTaskName, unsigned uxCurrentPriority, U32  pxStack, unsigned uStackHighWaterMark) {
   11f84:	b5f0      	push	{r4, r5, r6, r7, lr}
   11f86:	460c      	mov	r4, r1
   11f88:	b087      	sub	sp, #28
   11f8a:	4607      	mov	r7, r0
   11f8c:	4616      	mov	r6, r2
  if (memcmp(pcTaskName, "IDLE", 5) == 0) {
   11f8e:	4608      	mov	r0, r1
   11f90:	2205      	movs	r2, #5
   11f92:	4914      	ldr	r1, [pc, #80]	; (11fe4 <SYSVIEW_AddTask+0x60>)
void SYSVIEW_AddTask(U32 xHandle, const char* pcTaskName, unsigned uxCurrentPriority, U32  pxStack, unsigned uStackHighWaterMark) {
   11f94:	461d      	mov	r5, r3
  if (memcmp(pcTaskName, "IDLE", 5) == 0) {
   11f96:	f001 fa51 	bl	1343c <memcmp>
   11f9a:	b1e0      	cbz	r0, 11fd6 <SYSVIEW_AddTask+0x52>
  if (_NumTasks >= SYSVIEW_FREERTOS_MAX_NOF_TASKS) {
   11f9c:	4912      	ldr	r1, [pc, #72]	; (11fe8 <SYSVIEW_AddTask+0x64>)
   11f9e:	680b      	ldr	r3, [r1, #0]
   11fa0:	2b07      	cmp	r3, #7
   11fa2:	d81a      	bhi.n	11fda <SYSVIEW_AddTask+0x56>
  _aTasks[_NumTasks].xHandle = xHandle;
   11fa4:	eb03 0283 	add.w	r2, r3, r3, lsl #2
   11fa8:	f8df c044 	ldr.w	ip, [pc, #68]	; 11ff0 <SYSVIEW_AddTask+0x6c>
  TaskInfo.StackSize  = StackSize;
   11fac:	980c      	ldr	r0, [sp, #48]	; 0x30
   11fae:	9005      	str	r0, [sp, #20]
  _aTasks[_NumTasks].xHandle = xHandle;
   11fb0:	0092      	lsls	r2, r2, #2
  _NumTasks++;
   11fb2:	3301      	adds	r3, #1
   11fb4:	600b      	str	r3, [r1, #0]
  _aTasks[_NumTasks].xHandle = xHandle;
   11fb6:	eb0c 0302 	add.w	r3, ip, r2
   11fba:	f84c 7002 	str.w	r7, [ip, r2]
  _aTasks[_NumTasks].uStackHighWaterMark = uStackHighWaterMark;
   11fbe:	9a0c      	ldr	r2, [sp, #48]	; 0x30
  _aTasks[_NumTasks].pxStack = pxStack;
   11fc0:	60dd      	str	r5, [r3, #12]
  SEGGER_SYSVIEW_SendTaskInfo(&TaskInfo);
   11fc2:	a801      	add	r0, sp, #4
  _aTasks[_NumTasks].uxCurrentPriority = uxCurrentPriority;
   11fc4:	e9c3 4601 	strd	r4, r6, [r3, #4]
  _aTasks[_NumTasks].uStackHighWaterMark = uStackHighWaterMark;
   11fc8:	611a      	str	r2, [r3, #16]
  TaskInfo.TaskID     = TaskID;
   11fca:	9701      	str	r7, [sp, #4]
  TaskInfo.Prio       = Prio;
   11fcc:	e9cd 4602 	strd	r4, r6, [sp, #8]
  TaskInfo.StackBase  = StackBase;
   11fd0:	9504      	str	r5, [sp, #16]
  SEGGER_SYSVIEW_SendTaskInfo(&TaskInfo);
   11fd2:	f7fe f9bb 	bl	1034c <SEGGER_SYSVIEW_SendTaskInfo>
}
   11fd6:	b007      	add	sp, #28
   11fd8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    SEGGER_SYSVIEW_Warn("SYSTEMVIEW: Could not record task information. Maximum number of tasks reached.");
   11fda:	4804      	ldr	r0, [pc, #16]	; (11fec <SYSVIEW_AddTask+0x68>)
   11fdc:	f7ff fe82 	bl	11ce4 <SEGGER_SYSVIEW_Warn>
}
   11fe0:	b007      	add	sp, #28
   11fe2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11fe4:	00013554 	.word	0x00013554
   11fe8:	1001433c 	.word	0x1001433c
   11fec:	00013700 	.word	0x00013700
   11ff0:	10014340 	.word	0x10014340

00011ff4 <SYSVIEW_RecordU32x4>:
*       SYSVIEW_RecordU32x4()
*
*  Function description
*    Record an event with 4 parameters
*/
void SYSVIEW_RecordU32x4(unsigned Id, U32 Para0, U32 Para1, U32 Para2, U32 Para3) {
   11ff4:	b570      	push	{r4, r5, r6, lr}
   11ff6:	b088      	sub	sp, #32
   11ff8:	4616      	mov	r6, r2
   11ffa:	4604      	mov	r4, r0
      U8  aPacket[SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32];
      U8* pPayload;
      //
      pPayload = SEGGER_SYSVIEW_PREPARE_PACKET(aPacket);                // Prepare the packet for SystemView
      pPayload = SEGGER_SYSVIEW_EncodeU32(pPayload, Para0);             // Add the first parameter to the packet
   11ffc:	a801      	add	r0, sp, #4
void SYSVIEW_RecordU32x4(unsigned Id, U32 Para0, U32 Para1, U32 Para2, U32 Para3) {
   11ffe:	461d      	mov	r5, r3
      pPayload = SEGGER_SYSVIEW_EncodeU32(pPayload, Para0);             // Add the first parameter to the packet
   12000:	f7fd ff84 	bl	ff0c <SEGGER_SYSVIEW_EncodeU32>
      pPayload = SEGGER_SYSVIEW_EncodeU32(pPayload, Para1);             // Add the second parameter to the packet
   12004:	4631      	mov	r1, r6
   12006:	f7fd ff81 	bl	ff0c <SEGGER_SYSVIEW_EncodeU32>
      pPayload = SEGGER_SYSVIEW_EncodeU32(pPayload, Para2);             // Add the third parameter to the packet
   1200a:	4629      	mov	r1, r5
   1200c:	f7fd ff7e 	bl	ff0c <SEGGER_SYSVIEW_EncodeU32>
      pPayload = SEGGER_SYSVIEW_EncodeU32(pPayload, Para3);             // Add the fourth parameter to the packet
   12010:	990c      	ldr	r1, [sp, #48]	; 0x30
   12012:	f7fd ff7b 	bl	ff0c <SEGGER_SYSVIEW_EncodeU32>
      //
      SEGGER_SYSVIEW_SendPacket(&aPacket[0], pPayload, Id);             // Send the packet
   12016:	4622      	mov	r2, r4
   12018:	4601      	mov	r1, r0
   1201a:	4668      	mov	r0, sp
   1201c:	f7ff f84a 	bl	110b4 <SEGGER_SYSVIEW_SendPacket>
}
   12020:	b008      	add	sp, #32
   12022:	bd70      	pop	{r4, r5, r6, pc}

00012024 <_cbSendSystemDesc>:
*       _cbSendSystemDesc()
*
*  Function description
*    Sends SystemView description strings.
*/
static void _cbSendSystemDesc(void) {
   12024:	b508      	push	{r3, lr}
  SEGGER_SYSVIEW_SendSysDesc("N="SYSVIEW_APP_NAME",D="SYSVIEW_DEVICE_NAME",O=FreeRTOS");
   12026:	4804      	ldr	r0, [pc, #16]	; (12038 <_cbSendSystemDesc+0x14>)
   12028:	f7fe fc20 	bl	1086c <SEGGER_SYSVIEW_SendSysDesc>
  SEGGER_SYSVIEW_SendSysDesc("I#15=SysTick");
   1202c:	4803      	ldr	r0, [pc, #12]	; (1203c <_cbSendSystemDesc+0x18>)
}
   1202e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  SEGGER_SYSVIEW_SendSysDesc("I#15=SysTick");
   12032:	f7fe bc1b 	b.w	1086c <SEGGER_SYSVIEW_SendSysDesc>
   12036:	bf00      	nop
   12038:	00013758 	.word	0x00013758
   1203c:	0001378c 	.word	0x0001378c

00012040 <SEGGER_SYSVIEW_Conf>:
*
*       Global functions
*
**********************************************************************
*/
void SEGGER_SYSVIEW_Conf(void) {
   12040:	b508      	push	{r3, lr}
  SEGGER_SYSVIEW_Init(SYSVIEW_TIMESTAMP_FREQ, SYSVIEW_CPU_FREQ, 
   12042:	4906      	ldr	r1, [pc, #24]	; (1205c <SEGGER_SYSVIEW_Conf+0x1c>)
   12044:	4b06      	ldr	r3, [pc, #24]	; (12060 <SEGGER_SYSVIEW_Conf+0x20>)
   12046:	4a07      	ldr	r2, [pc, #28]	; (12064 <SEGGER_SYSVIEW_Conf+0x24>)
   12048:	4608      	mov	r0, r1
   1204a:	f7fd ff27 	bl	fe9c <SEGGER_SYSVIEW_Init>
                      &SYSVIEW_X_OS_TraceAPI, _cbSendSystemDesc);
  SEGGER_SYSVIEW_SetRAMBase(SYSVIEW_RAM_BASE);
   1204e:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
}
   12052:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  SEGGER_SYSVIEW_SetRAMBase(SYSVIEW_RAM_BASE);
   12056:	f7fd bf53 	b.w	ff00 <SEGGER_SYSVIEW_SetRAMBase>
   1205a:	bf00      	nop
   1205c:	02dc6c00 	.word	0x02dc6c00
   12060:	00012025 	.word	0x00012025
   12064:	00013750 	.word	0x00013750

00012068 <am_freertos_sleep>:
// Return 0 if this function also incorporates the WFI, else return value same
// as idleTime
//
//*****************************************************************************
uint32_t am_freertos_sleep(uint32_t idleTime)
{
   12068:	b508      	push	{r3, lr}
//    {
//       configure_uart_sleep(1);
//    }
//#endif
//    am_hal_sysctrl_sleep(AM_HAL_SYSCTRL_SLEEP_NORMAL);
    am_hal_sysctrl_sleep(AM_HAL_SYSCTRL_SLEEP_DEEP);
   1206a:	2001      	movs	r0, #1
   1206c:	f000 fd5e 	bl	12b2c <am_hal_sysctrl_sleep>
    return 0;
}
   12070:	2000      	movs	r0, #0
   12072:	bd08      	pop	{r3, pc}

00012074 <am_freertos_wakeup>:
//
//*****************************************************************************
void am_freertos_wakeup(uint32_t idleTime)
{
    return;
}
   12074:	4770      	bx	lr
   12076:	bf00      	nop

00012078 <vApplicationMallocFailedHook>:
// FreeRTOS debugging functions.
//
//*****************************************************************************
void
vApplicationMallocFailedHook(void)
{
   12078:	e7fe      	b.n	12078 <vApplicationMallocFailedHook>
   1207a:	bf00      	nop

0001207c <vApplicationStackOverflowHook>:
    // configconfigCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
    // function is called if a stack overflow is detected.
    //
    while (1)
    {
        __asm("BKPT #0\n") ; // Break into the debugger
   1207c:	be00      	bkpt	0x0000
   1207e:	e7fd      	b.n	1207c <vApplicationStackOverflowHook>

00012080 <am_AEP_init>:
    {AM_AEP_TIMER_HEART_BEAT, "HeartBeat", HEART_BEAT_PERIOD,  pdTRUE, &am_AEP_timer_heart_beat_callback}
};


void am_AEP_init(void)
{
   12080:	b530      	push	{r4, r5, lr}
    //
    taskCount = getListCount(am_AEP_tasks);
    taskSetupCount = getListCount(g_AEP_TaskSetup);
    timerSetupCount = getListCount(g_AEP_TimerSetup);

    am_app_utils_task_init(am_AEP_tasks, taskCount);
   12082:	4d12      	ldr	r5, [pc, #72]	; (120cc <am_AEP_init+0x4c>)
    am_app_utils_task_create_all_tasks(g_AEP_TaskSetup, am_AEP_tasks, taskSetupCount);
    am_app_utils_timer_create_all_timers(g_AEP_TimerSetup, am_AEP_timers, timerSetupCount);
   12084:	4c12      	ldr	r4, [pc, #72]	; (120d0 <am_AEP_init+0x50>)
{
   12086:	b083      	sub	sp, #12
    am_AEP_board_setup();
   12088:	f000 f886 	bl	12198 <am_AEP_board_setup>
    am_app_utils_ring_buffer_init_all(am_AEP_ring_buffers, g_AEP_RingBuffSetup, buffCount);
   1208c:	2202      	movs	r2, #2
   1208e:	4911      	ldr	r1, [pc, #68]	; (120d4 <am_AEP_init+0x54>)
   12090:	4811      	ldr	r0, [pc, #68]	; (120d8 <am_AEP_init+0x58>)
   12092:	f7fd fc01 	bl	f898 <am_app_utils_ring_buffer_init_all>
    am_app_utils_task_init(am_AEP_tasks, taskCount);
   12096:	4628      	mov	r0, r5
   12098:	2104      	movs	r1, #4
   1209a:	f7fd fc8f 	bl	f9bc <am_app_utils_task_init>
    am_app_utils_task_create_all_tasks(g_AEP_TaskSetup, am_AEP_tasks, taskSetupCount);
   1209e:	4629      	mov	r1, r5
   120a0:	2202      	movs	r2, #2
   120a2:	480e      	ldr	r0, [pc, #56]	; (120dc <am_AEP_init+0x5c>)
   120a4:	f7fd fc94 	bl	f9d0 <am_app_utils_task_create_all_tasks>
    am_app_utils_timer_create_all_timers(g_AEP_TimerSetup, am_AEP_timers, timerSetupCount);
   120a8:	4621      	mov	r1, r4
   120aa:	2201      	movs	r2, #1
   120ac:	480c      	ldr	r0, [pc, #48]	; (120e0 <am_AEP_init+0x60>)
   120ae:	f7fd fcc3 	bl	fa38 <am_app_utils_timer_create_all_timers>

    // Enable system heart beat LED
    xTimerStart(am_AEP_timers[AM_AEP_TIMER_HEART_BEAT], 0);    
   120b2:	6864      	ldr	r4, [r4, #4]
   120b4:	f7fb f842 	bl	d13c <xTaskGetTickCount>
   120b8:	2300      	movs	r3, #0
   120ba:	4602      	mov	r2, r0
   120bc:	9300      	str	r3, [sp, #0]
   120be:	4620      	mov	r0, r4
   120c0:	2101      	movs	r1, #1
   120c2:	f7fb fdb9 	bl	dc38 <xTimerGenericCommand>

}
   120c6:	b003      	add	sp, #12
   120c8:	bd30      	pop	{r4, r5, pc}
   120ca:	bf00      	nop
   120cc:	100158e8 	.word	0x100158e8
   120d0:	1001596c 	.word	0x1001596c
   120d4:	10002b04 	.word	0x10002b04
   120d8:	100158ac 	.word	0x100158ac
   120dc:	10002b1c 	.word	0x10002b1c
   120e0:	10002b54 	.word	0x10002b54

000120e4 <am_AEP_pdm_init>:
uint32_t g_ui32PCMDataBuff[PCM_FRAME_SIZE];
//*****************************************************************************
// PDM initialization.
//*****************************************************************************
void am_AEP_pdm_init(void) 
{
   120e4:	b530      	push	{r4, r5, lr}
  am_hal_gpio_pincfg_t sPinCfg = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

  // ARPIT 181019
  // sPinCfg.uFuncSel = AM_HAL_PIN_10_PDMCLK;
  // am_hal_gpio_pinconfig(10, sPinCfg);
  sPinCfg.uFuncSel = AM_HAL_PIN_12_PDMCLK;
   120e6:	2505      	movs	r5, #5
  am_hal_gpio_pincfg_t sPinCfg = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
   120e8:	2400      	movs	r4, #0
  sPinCfg.uFuncSel = AM_HAL_PIN_12_PDMCLK;
   120ea:	f365 0402 	bfi	r4, r5, #0, #3
{
   120ee:	b08b      	sub	sp, #44	; 0x2c
  am_hal_gpio_pinconfig(12, sPinCfg);
   120f0:	4621      	mov	r1, r4
   120f2:	200c      	movs	r0, #12
   120f4:	f7fc fa64 	bl	e5c0 <am_hal_gpio_pinconfig>

  sPinCfg.uFuncSel = AM_HAL_PIN_11_PDMDATA;
  am_hal_gpio_pinconfig(11, sPinCfg);
   120f8:	f044 0107 	orr.w	r1, r4, #7
   120fc:	200b      	movs	r0, #11
    };
    
//
  // Initialize, power-up, and configure the PDM.
  //
    am_hal_pdm_initialize(0, &PDMHandle);
   120fe:	4c23      	ldr	r4, [pc, #140]	; (1218c <am_AEP_pdm_init+0xa8>)
  am_hal_gpio_pinconfig(11, sPinCfg);
   12100:	f7fc fa5e 	bl	e5c0 <am_hal_gpio_pinconfig>
    am_hal_pdm_config_t g_sPdmConfig = {
   12104:	a802      	add	r0, sp, #8
   12106:	2220      	movs	r2, #32
   12108:	2100      	movs	r1, #0
   1210a:	f001 f9c9 	bl	134a0 <memset>
   1210e:	230b      	movs	r3, #11
   12110:	2018      	movs	r0, #24
   12112:	2201      	movs	r2, #1
    am_hal_pdm_initialize(0, &PDMHandle);
   12114:	4621      	mov	r1, r4
    am_hal_pdm_config_t g_sPdmConfig = {
   12116:	f88d 3009 	strb.w	r3, [sp, #9]
   1211a:	f88d 300a 	strb.w	r3, [sp, #10]
   1211e:	9305      	str	r3, [sp, #20]
   12120:	9003      	str	r0, [sp, #12]
   12122:	2303      	movs	r3, #3
    am_hal_pdm_initialize(0, &PDMHandle);
   12124:	2000      	movs	r0, #0
    am_hal_pdm_config_t g_sPdmConfig = {
   12126:	f88d 301d 	strb.w	r3, [sp, #29]
   1212a:	f88d 2010 	strb.w	r2, [sp, #16]
   1212e:	f88d 201c 	strb.w	r2, [sp, #28]
   12132:	f88d 5018 	strb.w	r5, [sp, #24]
    am_hal_pdm_initialize(0, &PDMHandle);
   12136:	f7fc f8a5 	bl	e284 <am_hal_pdm_initialize>
    am_hal_pdm_power_control(PDMHandle, AM_HAL_PDM_POWER_ON, false);
   1213a:	2200      	movs	r2, #0
   1213c:	4611      	mov	r1, r2
   1213e:	6820      	ldr	r0, [r4, #0]
   12140:	f7fc f8c2 	bl	e2c8 <am_hal_pdm_power_control>
    am_hal_pdm_configure(PDMHandle, &g_sPdmConfig);
   12144:	a902      	add	r1, sp, #8
   12146:	6820      	ldr	r0, [r4, #0]
   12148:	f7fc f8fe 	bl	e348 <am_hal_pdm_configure>
    am_hal_pdm_fifo_flush(PDMHandle);
   1214c:	6820      	ldr	r0, [r4, #0]
   1214e:	f7fc f9e3 	bl	e518 <am_hal_pdm_fifo_flush>


    am_hal_pdm_enable(PDMHandle);
   12152:	6820      	ldr	r0, [r4, #0]
   12154:	f7fc f97e 	bl	e454 <am_hal_pdm_enable>

    //
    // Configure and enable PDM interrupts (set up to trigger on DMA
    // completion).
    //
    am_hal_pdm_interrupt_enable(PDMHandle,
   12158:	6820      	ldr	r0, [r4, #0]
   1215a:	211e      	movs	r1, #30
   1215c:	f7fc f9ee 	bl	e53c <am_hal_pdm_interrupt_enable>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   12160:	4b0b      	ldr	r3, [pc, #44]	; (12190 <am_AEP_pdm_init+0xac>)
   12162:	2180      	movs	r1, #128	; 0x80
   12164:	f883 1313 	strb.w	r1, [r3, #787]	; 0x313
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   12168:	f44f 2200 	mov.w	r2, #524288	; 0x80000
   1216c:	601a      	str	r2, [r3, #0]


    //
    // Enable PDM
    //
    am_hal_pdm_enable(PDMHandle);
   1216e:	6820      	ldr	r0, [r4, #0]
   12170:	f7fc f970 	bl	e454 <am_hal_pdm_enable>
{
    //
    // Configure DMA and target address.
    //
    am_hal_pdm_transfer_t sTransfer;
    sTransfer.ui32TargetAddr = (uint32_t ) g_ui32PCMDataBuff;
   12174:	4b07      	ldr	r3, [pc, #28]	; (12194 <am_AEP_pdm_init+0xb0>)
   12176:	9300      	str	r3, [sp, #0]
    sTransfer.ui32TotalCount = (PCM_FRAME_SIZE * PCM_DATA_BYTES);

    //
    // Start the data transfer.
    //
    am_hal_pdm_dma_start(PDMHandle, &sTransfer);
   12178:	6820      	ldr	r0, [r4, #0]
    sTransfer.ui32TotalCount = (PCM_FRAME_SIZE * PCM_DATA_BYTES);
   1217a:	f44f 63a0 	mov.w	r3, #1280	; 0x500
    am_hal_pdm_dma_start(PDMHandle, &sTransfer);
   1217e:	4669      	mov	r1, sp
    sTransfer.ui32TotalCount = (PCM_FRAME_SIZE * PCM_DATA_BYTES);
   12180:	9301      	str	r3, [sp, #4]
    am_hal_pdm_dma_start(PDMHandle, &sTransfer);
   12182:	f7fc f97f 	bl	e484 <am_hal_pdm_dma_start>
}
   12186:	b00b      	add	sp, #44	; 0x2c
   12188:	bd30      	pop	{r4, r5, pc}
   1218a:	bf00      	nop
   1218c:	10015e78 	.word	0x10015e78
   12190:	e000e100 	.word	0xe000e100
   12194:	10015974 	.word	0x10015974

00012198 <am_AEP_board_setup>:
void am_AEP_board_setup(void)
{
    //
    // Set the clock frequency.
    //
    am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_SYSCLK_MAX, 0);
   12198:	2100      	movs	r1, #0
{
   1219a:	b538      	push	{r3, r4, r5, lr}
    am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_SYSCLK_MAX, 0);
   1219c:	4608      	mov	r0, r1
   1219e:	f000 f9dd 	bl	1255c <am_hal_clkgen_control>
    
    //
    // Set the default cache configuration
    //
    am_hal_cachectrl_config(&am_hal_cachectrl_defaults);
   121a2:	4821      	ldr	r0, [pc, #132]	; (12228 <am_AEP_board_setup+0x90>)
    //
    // Turn the LEDs off
    //
    for (int ix = 0; ix < AM_BSP_NUM_LEDS; ix++) 
    {
        am_devices_led_off(am_bsp_psLEDs, ix);
   121a4:	4d21      	ldr	r5, [pc, #132]	; (1222c <am_AEP_board_setup+0x94>)
    am_hal_cachectrl_config(&am_hal_cachectrl_defaults);
   121a6:	f000 f9a5 	bl	124f4 <am_hal_cachectrl_config>
    am_hal_cachectrl_enable();
   121aa:	f000 f9cd 	bl	12548 <am_hal_cachectrl_enable>
    am_bsp_low_power_init();
   121ae:	f000 f8f9 	bl	123a4 <am_bsp_low_power_init>
    am_hal_gpio_pinconfig(AM_BSP_GPIO_BUTTON0, g_AP3EVB_button0);
   121b2:	4b1f      	ldr	r3, [pc, #124]	; (12230 <am_AEP_board_setup+0x98>)
   121b4:	2010      	movs	r0, #16
   121b6:	6819      	ldr	r1, [r3, #0]
   121b8:	f7fc fa02 	bl	e5c0 <am_hal_gpio_pinconfig>
    am_hal_gpio_interrupt_clear(AM_HAL_GPIO_BIT(AM_BSP_GPIO_BUTTON0));
   121bc:	2100      	movs	r1, #0
   121be:	f44f 3080 	mov.w	r0, #65536	; 0x10000
   121c2:	f7fc fbe3 	bl	e98c <am_hal_gpio_interrupt_clear>
    am_hal_gpio_interrupt_enable(AM_HAL_GPIO_BIT(AM_BSP_GPIO_BUTTON0));
   121c6:	2100      	movs	r1, #0
   121c8:	f44f 3080 	mov.w	r0, #65536	; 0x10000
   121cc:	f7fc fbb6 	bl	e93c <am_hal_gpio_interrupt_enable>
    am_devices_led_array_init(am_bsp_psLEDs, AM_BSP_NUM_LEDS);
   121d0:	2105      	movs	r1, #5
   121d2:	4628      	mov	r0, r5
   121d4:	f7fd fc62 	bl	fa9c <am_devices_led_array_init>
    for (int ix = 0; ix < AM_BSP_NUM_LEDS; ix++) 
   121d8:	2400      	movs	r4, #0
        am_devices_led_off(am_bsp_psLEDs, ix);
   121da:	4621      	mov	r1, r4
   121dc:	4628      	mov	r0, r5
    for (int ix = 0; ix < AM_BSP_NUM_LEDS; ix++) 
   121de:	3401      	adds	r4, #1
        am_devices_led_off(am_bsp_psLEDs, ix);
   121e0:	f7fd fc90 	bl	fb04 <am_devices_led_off>
    for (int ix = 0; ix < AM_BSP_NUM_LEDS; ix++) 
   121e4:	2c05      	cmp	r4, #5
   121e6:	d1f8      	bne.n	121da <am_AEP_board_setup+0x42>

#endif  // defined(AM_BSP_NUM_BUTTONS)  &&  defined(AM_BSP_NUM_LEDS)

#if configUSE_PDM_DATA
    // Turn on PDM
    am_AEP_pdm_init();
   121e8:	f7ff ff7c 	bl	120e4 <am_AEP_pdm_init>
   121ec:	4b11      	ldr	r3, [pc, #68]	; (12234 <am_AEP_board_setup+0x9c>)
#endif

    //
    // Configure of burst mode
    //
    if (AM_HAL_STATUS_SUCCESS == am_hal_burst_mode_initialize(&eBurstModeAvailable))
   121ee:	4c12      	ldr	r4, [pc, #72]	; (12238 <am_AEP_board_setup+0xa0>)
   121f0:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   121f4:	601a      	str	r2, [r3, #0]
    am_hal_interrupt_master_enable();
   121f6:	f000 fa6b 	bl	126d0 <am_hal_interrupt_master_enable>
    am_bsp_uart_printf_enable();
   121fa:	f000 f905 	bl	12408 <am_bsp_uart_printf_enable>
    if (AM_HAL_STATUS_SUCCESS == am_hal_burst_mode_initialize(&eBurstModeAvailable))
   121fe:	4620      	mov	r0, r4
   12200:	f000 f930 	bl	12464 <am_hal_burst_mode_initialize>
   12204:	b958      	cbnz	r0, 1221e <am_AEP_board_setup+0x86>
    {
        if (AM_HAL_BURST_AVAIL == eBurstModeAvailable)
   12206:	7823      	ldrb	r3, [r4, #0]
   12208:	b923      	cbnz	r3, 12214 <am_AEP_board_setup+0x7c>
        {
            am_util_stdio_printf("Apollo3 Burst Mode is Available\r\n");
   1220a:	480c      	ldr	r0, [pc, #48]	; (1223c <am_AEP_board_setup+0xa4>)
        am_util_stdio_printf("Failed to Enable Burst Mode operation\r\n");
    }

#endif // configUSE_BURST_ALWAYS_ON

}
   1220c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
            am_util_stdio_printf("Apollo3 Burst Mode is Available\r\n");
   12210:	f7fd bb26 	b.w	f860 <am_util_stdio_printf>
            am_util_stdio_printf("Apollo3 Burst Mode is Not Available\r\n");
   12214:	480a      	ldr	r0, [pc, #40]	; (12240 <am_AEP_board_setup+0xa8>)
}
   12216:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
            am_util_stdio_printf("Apollo3 Burst Mode is Not Available\r\n");
   1221a:	f7fd bb21 	b.w	f860 <am_util_stdio_printf>
        am_util_stdio_printf("Failed to Initialize for Burst Mode operation\r\n");
   1221e:	4809      	ldr	r0, [pc, #36]	; (12244 <am_AEP_board_setup+0xac>)
}
   12220:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        am_util_stdio_printf("Failed to Initialize for Burst Mode operation\r\n");
   12224:	f7fd bb1c 	b.w	f860 <am_util_stdio_printf>
   12228:	0001387c 	.word	0x0001387c
   1222c:	10002b68 	.word	0x10002b68
   12230:	00013848 	.word	0x00013848
   12234:	e000e100 	.word	0xe000e100
   12238:	10015e75 	.word	0x10015e75
   1223c:	000137cc 	.word	0x000137cc
   12240:	000137f0 	.word	0x000137f0
   12244:	00013818 	.word	0x00013818

00012248 <am_AEP_led_task>:
#include "am_AEP_task.h"


// AEP led task
void am_AEP_led_task(void *pvParameters)
{
   12248:	b510      	push	{r4, lr}
    const TickType_t xDelay200ms = pdMS_TO_TICKS(200);
    const TickType_t xDelaySwirl = pdMS_TO_TICKS(35);
    am_app_utils_task_queue_element_t QueueElement;
    while(1)
    {
        am_app_utils_task_read(am_AEP_tasks, AM_AEP_TASK_LED, &QueueElement);
   1224a:	4c04      	ldr	r4, [pc, #16]	; (1225c <am_AEP_led_task+0x14>)
{
   1224c:	b084      	sub	sp, #16
        am_app_utils_task_read(am_AEP_tasks, AM_AEP_TASK_LED, &QueueElement);
   1224e:	466a      	mov	r2, sp
   12250:	2101      	movs	r1, #1
   12252:	4620      	mov	r0, r4
   12254:	f7fd fc12 	bl	fa7c <am_app_utils_task_read>
   12258:	e7f9      	b.n	1224e <am_AEP_led_task+0x6>
   1225a:	bf00      	nop
   1225c:	100158e8 	.word	0x100158e8

00012260 <am_AEP_button_task>:

}

// AEP button task
void am_AEP_button_task(void *pvParameters)
{
   12260:	b510      	push	{r4, lr}
    const TickType_t xDelay200ms = pdMS_TO_TICKS(200);
    const TickType_t xDelaySwirl = pdMS_TO_TICKS(35);
    am_app_utils_task_queue_element_t QueueElement;
    while(1)
    {
        am_app_utils_task_read(am_AEP_tasks, AM_AEP_TASK_BUTTON, &QueueElement);
   12262:	4c04      	ldr	r4, [pc, #16]	; (12274 <am_AEP_button_task+0x14>)
{
   12264:	b084      	sub	sp, #16
        am_app_utils_task_read(am_AEP_tasks, AM_AEP_TASK_BUTTON, &QueueElement);
   12266:	466a      	mov	r2, sp
   12268:	2102      	movs	r1, #2
   1226a:	4620      	mov	r0, r4
   1226c:	f7fd fc06 	bl	fa7c <am_app_utils_task_read>
   12270:	e7f9      	b.n	12266 <am_AEP_button_task+0x6>
   12272:	bf00      	nop
   12274:	100158e8 	.word	0x100158e8

00012278 <am_AEP_timer_heart_beat_callback>:
// Software timer callback functions
//
//*****************************************************************************
void am_AEP_timer_heart_beat_callback(TimerHandle_t xTimer)
{
    am_devices_led_toggle(am_bsp_psLEDs, 0);
   12278:	2100      	movs	r1, #0
   1227a:	4801      	ldr	r0, [pc, #4]	; (12280 <am_AEP_timer_heart_beat_callback+0x8>)
   1227c:	f7fd bc5a 	b.w	fb34 <am_devices_led_toggle>
   12280:	10002b68 	.word	0x10002b68

00012284 <am_pdm0_isr>:
// PDM interrupt handler.
//
//*****************************************************************************
#if configUSE_PDM_DATA
void am_pdm0_isr(void) 
{
   12284:	b510      	push	{r4, lr}
#endif // configUSE_SYSVIEWER
    uint32_t ui32Status;
    //
    // Read the interrupt status.
    //
    am_hal_pdm_interrupt_status_get(PDMHandle, &ui32Status, true);
   12286:	4c15      	ldr	r4, [pc, #84]	; (122dc <am_pdm0_isr+0x58>)
{
   12288:	b082      	sub	sp, #8
    SEGGER_SYSVIEW_RecordEnterISR();
   1228a:	f7fe fc03 	bl	10a94 <SEGGER_SYSVIEW_RecordEnterISR>
    am_hal_pdm_interrupt_status_get(PDMHandle, &ui32Status, true);
   1228e:	2201      	movs	r2, #1
   12290:	a901      	add	r1, sp, #4
   12292:	6820      	ldr	r0, [r4, #0]
   12294:	f7fc f976 	bl	e584 <am_hal_pdm_interrupt_status_get>
    am_hal_pdm_interrupt_clear(PDMHandle, ui32Status);
   12298:	6820      	ldr	r0, [r4, #0]
   1229a:	9901      	ldr	r1, [sp, #4]
   1229c:	f7fc f962 	bl	e564 <am_hal_pdm_interrupt_clear>
    
    if (ui32Status & AM_HAL_PDM_INT_DCMP)
   122a0:	9b01      	ldr	r3, [sp, #4]
   122a2:	071a      	lsls	r2, r3, #28
   122a4:	d40d      	bmi.n	122c2 <am_pdm0_isr+0x3e>
//            am_app_utils_rtt_record((void*)g_ui32PCMDataBuff, PCM_FRAME_SIZE*PCM_DATA_BYTES); 
#endif /* USE_RTT_DATA_OUTPUT */ 

//        am_util_debug_printf("PDM DCMP interrupt, pick g_ui32PDMDataBuffer[5] = 0x%8x\n", g_ui32PDMDataBuffer[5]);
    }
    else if(ui32Status & (AM_HAL_PDM_INT_UNDFL | AM_HAL_PDM_INT_OVF))
   122a6:	f013 0f06 	tst.w	r3, #6
   122aa:	d103      	bne.n	122b4 <am_pdm0_isr+0x30>
    {
        am_hal_pdm_fifo_flush(PDMHandle);
    }

#if configUSE_SYSVIEWER
    SEGGER_SYSVIEW_RecordExitISR(); //emit Exit ISR signal
   122ac:	f7fe f940 	bl	10530 <SEGGER_SYSVIEW_RecordExitISR>
#endif // configUSE_SYSVIEWER

}
   122b0:	b002      	add	sp, #8
   122b2:	bd10      	pop	{r4, pc}
        am_hal_pdm_fifo_flush(PDMHandle);
   122b4:	6820      	ldr	r0, [r4, #0]
   122b6:	f7fc f92f 	bl	e518 <am_hal_pdm_fifo_flush>
    SEGGER_SYSVIEW_RecordExitISR(); //emit Exit ISR signal
   122ba:	f7fe f939 	bl	10530 <SEGGER_SYSVIEW_RecordExitISR>
}
   122be:	b002      	add	sp, #8
   122c0:	bd10      	pop	{r4, pc}
        PDMn(0)->DMATOTCOUNT = PCM_FRAME_SIZE*PCM_DATA_BYTES;  // FIFO unit in bytes
   122c2:	4b07      	ldr	r3, [pc, #28]	; (122e0 <am_pdm0_isr+0x5c>)
        am_app_utils_ring_buffer_push(&am_AEP_ring_buffers[AM_AEP_RINGBUFF_PDM], g_ui32PCMDataBuff, PCM_FRAME_SIZE*PCM_DATA_BYTES);
   122c4:	4907      	ldr	r1, [pc, #28]	; (122e4 <am_pdm0_isr+0x60>)
   122c6:	4808      	ldr	r0, [pc, #32]	; (122e8 <am_pdm0_isr+0x64>)
        PDMn(0)->DMATOTCOUNT = PCM_FRAME_SIZE*PCM_DATA_BYTES;  // FIFO unit in bytes
   122c8:	f44f 62a0 	mov.w	r2, #1280	; 0x500
   122cc:	f8c3 2288 	str.w	r2, [r3, #648]	; 0x288
        am_app_utils_ring_buffer_push(&am_AEP_ring_buffers[AM_AEP_RINGBUFF_PDM], g_ui32PCMDataBuff, PCM_FRAME_SIZE*PCM_DATA_BYTES);
   122d0:	f7fd fb06 	bl	f8e0 <am_app_utils_ring_buffer_push>
    SEGGER_SYSVIEW_RecordExitISR(); //emit Exit ISR signal
   122d4:	f7fe f92c 	bl	10530 <SEGGER_SYSVIEW_RecordExitISR>
}
   122d8:	b002      	add	sp, #8
   122da:	bd10      	pop	{r4, pc}
   122dc:	10015e78 	.word	0x10015e78
   122e0:	50011000 	.word	0x50011000
   122e4:	10015974 	.word	0x10015974
   122e8:	100158c0 	.word	0x100158c0

000122ec <NMI_Handler>:
// by a debugger.
//
//*****************************************************************************
void
NMI_Handler(void)
{
   122ec:	e7fe      	b.n	122ec <NMI_Handler>
   122ee:	bf00      	nop

000122f0 <DebugMon_Handler>:
// for examination by a debugger.
//
//*****************************************************************************
void
am_default_isr(void)
{
   122f0:	e7fe      	b.n	122f0 <DebugMon_Handler>
   122f2:	bf00      	nop

000122f4 <Reset_Handler>:
    __asm("    ldr    r0, =0xE000ED08\n"
   122f4:	4811      	ldr	r0, [pc, #68]	; (1233c <zero_loop+0x12>)
   122f6:	4912      	ldr	r1, [pc, #72]	; (12340 <zero_loop+0x16>)
   122f8:	6001      	str	r1, [r0, #0]
    __asm("    ldr    sp, [r1]");
   122fa:	f8d1 d000 	ldr.w	sp, [r1]
    __asm("ldr  r0, =0xE000ED88\n"
   122fe:	4811      	ldr	r0, [pc, #68]	; (12344 <zero_loop+0x1a>)
   12300:	6801      	ldr	r1, [r0, #0]
   12302:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   12306:	6001      	str	r1, [r0, #0]
   12308:	f3bf 8f4f 	dsb	sy
   1230c:	f3bf 8f6f 	isb	sy
    __asm("    ldr     r0, =_init_data\n"
   12310:	480d      	ldr	r0, [pc, #52]	; (12348 <zero_loop+0x1e>)
   12312:	490e      	ldr	r1, [pc, #56]	; (1234c <zero_loop+0x22>)
   12314:	4a0e      	ldr	r2, [pc, #56]	; (12350 <zero_loop+0x26>)

00012316 <copy_loop>:
   12316:	f850 3b04 	ldr.w	r3, [r0], #4
   1231a:	f841 3b04 	str.w	r3, [r1], #4
   1231e:	4291      	cmp	r1, r2
   12320:	dbf9      	blt.n	12316 <copy_loop>
    __asm("    ldr     r0, =_sbss\n"
   12322:	480c      	ldr	r0, [pc, #48]	; (12354 <zero_loop+0x2a>)
   12324:	490c      	ldr	r1, [pc, #48]	; (12358 <zero_loop+0x2e>)
   12326:	f04f 0200 	mov.w	r2, #0

0001232a <zero_loop>:
   1232a:	4288      	cmp	r0, r1
   1232c:	bfb8      	it	lt
   1232e:	f840 2b04 	strlt.w	r2, [r0], #4
   12332:	dbfa      	blt.n	1232a <zero_loop>
    main();
   12334:	f7f9 ffce 	bl	c2d4 <main>
    __asm("    bkpt     ");
   12338:	be00      	bkpt	0x0000
   1233a:	0000      	.short	0x0000
   1233c:	e000ed08 	.word	0xe000ed08
   12340:	0000c000 	.word	0x0000c000
   12344:	e000ed88 	.word	0xe000ed88
   12348:	000139b4 	.word	0x000139b4
   1234c:	10002b00 	.word	0x10002b00
   12350:	10002b90 	.word	0x10002b90
   12354:	10002b90 	.word	0x10002b90
   12358:	10015f44 	.word	0x10015f44

0001235c <am_bsp_uart_string_print>:
   1235c:	b510      	push	{r4, lr}
   1235e:	b086      	sub	sp, #24
   12360:	7803      	ldrb	r3, [r0, #0]
   12362:	2400      	movs	r4, #0
   12364:	9400      	str	r4, [sp, #0]
   12366:	b1bb      	cbz	r3, 12398 <am_bsp_uart_string_print+0x3c>
   12368:	4603      	mov	r3, r0
   1236a:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   1236e:	3401      	adds	r4, #1
   12370:	2a00      	cmp	r2, #0
   12372:	d1fa      	bne.n	1236a <am_bsp_uart_string_print+0xe>
   12374:	4b0a      	ldr	r3, [pc, #40]	; (123a0 <am_bsp_uart_string_print+0x44>)
   12376:	9002      	str	r0, [sp, #8]
   12378:	2200      	movs	r2, #0
   1237a:	6818      	ldr	r0, [r3, #0]
   1237c:	9403      	str	r4, [sp, #12]
   1237e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   12382:	a901      	add	r1, sp, #4
   12384:	9304      	str	r3, [sp, #16]
   12386:	9201      	str	r2, [sp, #4]
   12388:	f8cd d014 	str.w	sp, [sp, #20]
   1238c:	f000 fda0 	bl	12ed0 <am_hal_uart_transfer>
   12390:	9b00      	ldr	r3, [sp, #0]
   12392:	42a3      	cmp	r3, r4
   12394:	d002      	beq.n	1239c <am_bsp_uart_string_print+0x40>
   12396:	e7fe      	b.n	12396 <am_bsp_uart_string_print+0x3a>
   12398:	461c      	mov	r4, r3
   1239a:	e7eb      	b.n	12374 <am_bsp_uart_string_print+0x18>
   1239c:	b006      	add	sp, #24
   1239e:	bd10      	pop	{r4, pc}
   123a0:	100143e4 	.word	0x100143e4

000123a4 <am_bsp_low_power_init>:
   123a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   123a6:	f000 f99f 	bl	126e8 <am_hal_itm_disable>
   123aa:	2000      	movs	r0, #0
   123ac:	f7fc fc4c 	bl	ec48 <am_util_stdio_printf_init>
   123b0:	4b12      	ldr	r3, [pc, #72]	; (123fc <am_bsp_low_power_init+0x58>)
   123b2:	4f13      	ldr	r7, [pc, #76]	; (12400 <am_bsp_low_power_init+0x5c>)
   123b4:	6819      	ldr	r1, [r3, #0]
   123b6:	2029      	movs	r0, #41	; 0x29
   123b8:	f7fc f902 	bl	e5c0 <am_hal_gpio_pinconfig>
   123bc:	f000 fad6 	bl	1296c <am_hal_pwrctrl_low_power_init>
   123c0:	2001      	movs	r0, #1
   123c2:	f000 fb1d 	bl	12a00 <am_hal_rtc_osc_select>
   123c6:	2100      	movs	r1, #0
   123c8:	2003      	movs	r0, #3
   123ca:	f000 f8c7 	bl	1255c <am_hal_clkgen_control>
   123ce:	f000 fb23 	bl	12a18 <am_hal_rtc_osc_disable>
   123d2:	4b0c      	ldr	r3, [pc, #48]	; (12404 <am_bsp_low_power_init+0x60>)
   123d4:	681e      	ldr	r6, [r3, #0]
   123d6:	2400      	movs	r4, #0
   123d8:	f857 5034 	ldr.w	r5, [r7, r4, lsl #3]
   123dc:	4631      	mov	r1, r6
   123de:	4628      	mov	r0, r5
   123e0:	f7fc f8ee 	bl	e5c0 <am_hal_gpio_pinconfig>
   123e4:	2103      	movs	r1, #3
   123e6:	4628      	mov	r0, r5
   123e8:	f7fc fa64 	bl	e8b4 <am_hal_gpio_state_write>
   123ec:	3401      	adds	r4, #1
   123ee:	4628      	mov	r0, r5
   123f0:	2100      	movs	r1, #0
   123f2:	f7fc fa5f 	bl	e8b4 <am_hal_gpio_state_write>
   123f6:	2c05      	cmp	r4, #5
   123f8:	d1ee      	bne.n	123d8 <am_bsp_low_power_init+0x34>
   123fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   123fc:	00013564 	.word	0x00013564
   12400:	10002b68 	.word	0x10002b68
   12404:	00013568 	.word	0x00013568

00012408 <am_bsp_uart_printf_enable>:
   12408:	b510      	push	{r4, lr}
   1240a:	4c10      	ldr	r4, [pc, #64]	; (1244c <am_bsp_uart_printf_enable+0x44>)
   1240c:	4b10      	ldr	r3, [pc, #64]	; (12450 <am_bsp_uart_printf_enable+0x48>)
   1240e:	4621      	mov	r1, r4
   12410:	2202      	movs	r2, #2
   12412:	2000      	movs	r0, #0
   12414:	601a      	str	r2, [r3, #0]
   12416:	f000 fbb5 	bl	12b84 <am_hal_uart_initialize>
   1241a:	2200      	movs	r2, #0
   1241c:	4611      	mov	r1, r2
   1241e:	6820      	ldr	r0, [r4, #0]
   12420:	f000 fbd8 	bl	12bd4 <am_hal_uart_power_control>
   12424:	6820      	ldr	r0, [r4, #0]
   12426:	490b      	ldr	r1, [pc, #44]	; (12454 <am_bsp_uart_printf_enable+0x4c>)
   12428:	f000 fc46 	bl	12cb8 <am_hal_uart_configure>
   1242c:	4b0a      	ldr	r3, [pc, #40]	; (12458 <am_bsp_uart_printf_enable+0x50>)
   1242e:	2016      	movs	r0, #22
   12430:	6819      	ldr	r1, [r3, #0]
   12432:	f7fc f8c5 	bl	e5c0 <am_hal_gpio_pinconfig>
   12436:	4b09      	ldr	r3, [pc, #36]	; (1245c <am_bsp_uart_printf_enable+0x54>)
   12438:	2017      	movs	r0, #23
   1243a:	6819      	ldr	r1, [r3, #0]
   1243c:	f7fc f8c0 	bl	e5c0 <am_hal_gpio_pinconfig>
   12440:	4807      	ldr	r0, [pc, #28]	; (12460 <am_bsp_uart_printf_enable+0x58>)
   12442:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   12446:	f7fc bbff 	b.w	ec48 <am_util_stdio_printf_init>
   1244a:	bf00      	nop
   1244c:	100143e4 	.word	0x100143e4
   12450:	100143e0 	.word	0x100143e0
   12454:	0001384c 	.word	0x0001384c
   12458:	00013874 	.word	0x00013874
   1245c:	00013878 	.word	0x00013878
   12460:	0001235d 	.word	0x0001235d

00012464 <am_hal_burst_mode_initialize>:
   12464:	b570      	push	{r4, r5, r6, lr}
   12466:	4b1e      	ldr	r3, [pc, #120]	; (124e0 <am_hal_burst_mode_initialize+0x7c>)
   12468:	695a      	ldr	r2, [r3, #20]
   1246a:	07d5      	lsls	r5, r2, #31
   1246c:	b082      	sub	sp, #8
   1246e:	4604      	mov	r4, r0
   12470:	d407      	bmi.n	12482 <am_hal_burst_mode_initialize+0x1e>
   12472:	4a1c      	ldr	r2, [pc, #112]	; (124e4 <am_hal_burst_mode_initialize+0x80>)
   12474:	2100      	movs	r1, #0
   12476:	2301      	movs	r3, #1
   12478:	7011      	strb	r1, [r2, #0]
   1247a:	2007      	movs	r0, #7
   1247c:	7023      	strb	r3, [r4, #0]
   1247e:	b002      	add	sp, #8
   12480:	bd70      	pop	{r4, r5, r6, pc}
   12482:	4a19      	ldr	r2, [pc, #100]	; (124e8 <am_hal_burst_mode_initialize+0x84>)
   12484:	6a91      	ldr	r1, [r2, #40]	; 0x28
   12486:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
   1248a:	6291      	str	r1, [r2, #40]	; 0x28
   1248c:	6812      	ldr	r2, [r2, #0]
   1248e:	07d0      	lsls	r0, r2, #31
   12490:	d507      	bpl.n	124a2 <am_hal_burst_mode_initialize+0x3e>
   12492:	68db      	ldr	r3, [r3, #12]
   12494:	b2db      	uxtb	r3, r3
   12496:	2b11      	cmp	r3, #17
   12498:	d903      	bls.n	124a2 <am_hal_burst_mode_initialize+0x3e>
   1249a:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
   1249e:	4a13      	ldr	r2, [pc, #76]	; (124ec <am_hal_burst_mode_initialize+0x88>)
   124a0:	63da      	str	r2, [r3, #60]	; 0x3c
   124a2:	4d0f      	ldr	r5, [pc, #60]	; (124e0 <am_hal_burst_mode_initialize+0x7c>)
   124a4:	4912      	ldr	r1, [pc, #72]	; (124f0 <am_hal_burst_mode_initialize+0x8c>)
   124a6:	7e2a      	ldrb	r2, [r5, #24]
   124a8:	2601      	movs	r6, #1
   124aa:	f042 0210 	orr.w	r2, r2, #16
   124ae:	2320      	movs	r3, #32
   124b0:	762a      	strb	r2, [r5, #24]
   124b2:	f242 7010 	movw	r0, #10000	; 0x2710
   124b6:	461a      	mov	r2, r3
   124b8:	9600      	str	r6, [sp, #0]
   124ba:	f000 f8dd 	bl	12678 <am_hal_flash_delay_status_check>
   124be:	b948      	cbnz	r0, 124d4 <am_hal_burst_mode_initialize+0x70>
   124c0:	69aa      	ldr	r2, [r5, #24]
   124c2:	0651      	lsls	r1, r2, #25
   124c4:	d5d5      	bpl.n	12472 <am_hal_burst_mode_initialize+0xe>
   124c6:	69aa      	ldr	r2, [r5, #24]
   124c8:	0692      	lsls	r2, r2, #26
   124ca:	d5d2      	bpl.n	12472 <am_hal_burst_mode_initialize+0xe>
   124cc:	4a05      	ldr	r2, [pc, #20]	; (124e4 <am_hal_burst_mode_initialize+0x80>)
   124ce:	7016      	strb	r6, [r2, #0]
   124d0:	7020      	strb	r0, [r4, #0]
   124d2:	e7d4      	b.n	1247e <am_hal_burst_mode_initialize+0x1a>
   124d4:	4a03      	ldr	r2, [pc, #12]	; (124e4 <am_hal_burst_mode_initialize+0x80>)
   124d6:	2100      	movs	r1, #0
   124d8:	7011      	strb	r1, [r2, #0]
   124da:	7026      	strb	r6, [r4, #0]
   124dc:	b002      	add	sp, #8
   124de:	bd70      	pop	{r4, r5, r6, pc}
   124e0:	40020000 	.word	0x40020000
   124e4:	100143e8 	.word	0x100143e8
   124e8:	40021000 	.word	0x40021000
   124ec:	0fc0400f 	.word	0x0fc0400f
   124f0:	40020018 	.word	0x40020018

000124f4 <am_hal_cachectrl_config>:
   124f4:	b530      	push	{r4, r5, lr}
   124f6:	b083      	sub	sp, #12
   124f8:	4605      	mov	r5, r0
   124fa:	f000 f8ed 	bl	126d8 <am_hal_interrupt_master_disable>
   124fe:	4c11      	ldr	r4, [pc, #68]	; (12544 <am_hal_cachectrl_config+0x50>)
   12500:	9001      	str	r0, [sp, #4]
   12502:	6823      	ldr	r3, [r4, #0]
   12504:	f423 7340 	bic.w	r3, r3, #768	; 0x300
   12508:	6023      	str	r3, [r4, #0]
   1250a:	9801      	ldr	r0, [sp, #4]
   1250c:	f000 f8e8 	bl	126e0 <am_hal_interrupt_master_set>
   12510:	78eb      	ldrb	r3, [r5, #3]
   12512:	782a      	ldrb	r2, [r5, #0]
   12514:	78a8      	ldrb	r0, [r5, #2]
   12516:	7869      	ldrb	r1, [r5, #1]
   12518:	005b      	lsls	r3, r3, #1
   1251a:	0112      	lsls	r2, r2, #4
   1251c:	b2d2      	uxtb	r2, r2
   1251e:	f003 0302 	and.w	r3, r3, #2
   12522:	4313      	orrs	r3, r2
   12524:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   12528:	0080      	lsls	r0, r0, #2
   1252a:	f000 000c 	and.w	r0, r0, #12
   1252e:	020a      	lsls	r2, r1, #8
   12530:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
   12534:	4303      	orrs	r3, r0
   12536:	f402 7240 	and.w	r2, r2, #768	; 0x300
   1253a:	4313      	orrs	r3, r2
   1253c:	2000      	movs	r0, #0
   1253e:	6023      	str	r3, [r4, #0]
   12540:	b003      	add	sp, #12
   12542:	bd30      	pop	{r4, r5, pc}
   12544:	40018000 	.word	0x40018000

00012548 <am_hal_cachectrl_enable>:
   12548:	4a03      	ldr	r2, [pc, #12]	; (12558 <am_hal_cachectrl_enable+0x10>)
   1254a:	6813      	ldr	r3, [r2, #0]
   1254c:	f043 0301 	orr.w	r3, r3, #1
   12550:	6013      	str	r3, [r2, #0]
   12552:	2000      	movs	r0, #0
   12554:	4770      	bx	lr
   12556:	bf00      	nop
   12558:	40018000 	.word	0x40018000

0001255c <am_hal_clkgen_control>:
   1255c:	4b32      	ldr	r3, [pc, #200]	; (12628 <am_hal_clkgen_control+0xcc>)
   1255e:	681a      	ldr	r2, [r3, #0]
   12560:	b912      	cbnz	r2, 12568 <am_hal_clkgen_control+0xc>
   12562:	4a32      	ldr	r2, [pc, #200]	; (1262c <am_hal_clkgen_control+0xd0>)
   12564:	6812      	ldr	r2, [r2, #0]
   12566:	601a      	str	r2, [r3, #0]
   12568:	2809      	cmp	r0, #9
   1256a:	d85a      	bhi.n	12622 <am_hal_clkgen_control+0xc6>
   1256c:	e8df f000 	tbb	[pc, r0]
   12570:	261e160d 	.word	0x261e160d
   12574:	4640362e 	.word	0x4640362e
   12578:	054e      	.short	0x054e
   1257a:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
   1257e:	2000      	movs	r0, #0
   12580:	6a1a      	ldr	r2, [r3, #32]
   12582:	f36f 0200 	bfc	r2, #0, #1
   12586:	621a      	str	r2, [r3, #32]
   12588:	4770      	bx	lr
   1258a:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
   1258e:	2200      	movs	r2, #0
   12590:	2147      	movs	r1, #71	; 0x47
   12592:	6159      	str	r1, [r3, #20]
   12594:	4610      	mov	r0, r2
   12596:	619a      	str	r2, [r3, #24]
   12598:	615a      	str	r2, [r3, #20]
   1259a:	4770      	bx	lr
   1259c:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
   125a0:	2000      	movs	r0, #0
   125a2:	68d3      	ldr	r3, [r2, #12]
   125a4:	f023 0301 	bic.w	r3, r3, #1
   125a8:	60d3      	str	r3, [r2, #12]
   125aa:	4770      	bx	lr
   125ac:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
   125b0:	2000      	movs	r0, #0
   125b2:	68d3      	ldr	r3, [r2, #12]
   125b4:	f023 0302 	bic.w	r3, r3, #2
   125b8:	60d3      	str	r3, [r2, #12]
   125ba:	4770      	bx	lr
   125bc:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
   125c0:	2000      	movs	r0, #0
   125c2:	68d3      	ldr	r3, [r2, #12]
   125c4:	f043 0301 	orr.w	r3, r3, #1
   125c8:	60d3      	str	r3, [r2, #12]
   125ca:	4770      	bx	lr
   125cc:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
   125d0:	2000      	movs	r0, #0
   125d2:	68d3      	ldr	r3, [r2, #12]
   125d4:	f043 0302 	orr.w	r3, r3, #2
   125d8:	60d3      	str	r3, [r2, #12]
   125da:	4770      	bx	lr
   125dc:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
   125e0:	2200      	movs	r2, #0
   125e2:	2047      	movs	r0, #71	; 0x47
   125e4:	2101      	movs	r1, #1
   125e6:	6158      	str	r0, [r3, #20]
   125e8:	6199      	str	r1, [r3, #24]
   125ea:	4610      	mov	r0, r2
   125ec:	615a      	str	r2, [r3, #20]
   125ee:	4770      	bx	lr
   125f0:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
   125f4:	2000      	movs	r0, #0
   125f6:	68da      	ldr	r2, [r3, #12]
   125f8:	60da      	str	r2, [r3, #12]
   125fa:	4770      	bx	lr
   125fc:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
   12600:	2000      	movs	r0, #0
   12602:	68d3      	ldr	r3, [r2, #12]
   12604:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   12608:	60d3      	str	r3, [r2, #12]
   1260a:	4770      	bx	lr
   1260c:	b139      	cbz	r1, 1261e <am_hal_clkgen_control+0xc2>
   1260e:	680b      	ldr	r3, [r1, #0]
   12610:	f043 0301 	orr.w	r3, r3, #1
   12614:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
   12618:	2000      	movs	r0, #0
   1261a:	6213      	str	r3, [r2, #32]
   1261c:	4770      	bx	lr
   1261e:	4b04      	ldr	r3, [pc, #16]	; (12630 <am_hal_clkgen_control+0xd4>)
   12620:	e7f8      	b.n	12614 <am_hal_clkgen_control+0xb8>
   12622:	2006      	movs	r0, #6
   12624:	4770      	bx	lr
   12626:	bf00      	nop
   12628:	100143ec 	.word	0x100143ec
   1262c:	4ffff000 	.word	0x4ffff000
   12630:	0025b801 	.word	0x0025b801

00012634 <am_hal_clkgen_status_get>:
   12634:	b1a8      	cbz	r0, 12662 <am_hal_clkgen_status_get+0x2e>
   12636:	b410      	push	{r4}
   12638:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
   1263c:	490a      	ldr	r1, [pc, #40]	; (12668 <am_hal_clkgen_status_get+0x34>)
   1263e:	6994      	ldr	r4, [r2, #24]
   12640:	4b0a      	ldr	r3, [pc, #40]	; (1266c <am_hal_clkgen_status_get+0x38>)
   12642:	f014 0f01 	tst.w	r4, #1
   12646:	bf08      	it	eq
   12648:	460b      	moveq	r3, r1
   1264a:	6003      	str	r3, [r0, #0]
   1264c:	69d3      	ldr	r3, [r2, #28]
   1264e:	f85d 4b04 	ldr.w	r4, [sp], #4
   12652:	f003 0201 	and.w	r2, r3, #1
   12656:	f3c3 0340 	ubfx	r3, r3, #1, #1
   1265a:	6042      	str	r2, [r0, #4]
   1265c:	7203      	strb	r3, [r0, #8]
   1265e:	2000      	movs	r0, #0
   12660:	4770      	bx	lr
   12662:	2006      	movs	r0, #6
   12664:	4770      	bx	lr
   12666:	bf00      	nop
   12668:	02dc6c00 	.word	0x02dc6c00
   1266c:	016e3600 	.word	0x016e3600

00012670 <am_hal_flash_delay>:
   12670:	4b00      	ldr	r3, [pc, #0]	; (12674 <am_hal_flash_delay+0x4>)
   12672:	4718      	bx	r3
   12674:	0800009d 	.word	0x0800009d

00012678 <am_hal_flash_delay_status_check>:
   12678:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1267c:	f89d 4018 	ldrb.w	r4, [sp, #24]
   12680:	460d      	mov	r5, r1
   12682:	4616      	mov	r6, r2
   12684:	461f      	mov	r7, r3
   12686:	b17c      	cbz	r4, 126a8 <am_hal_flash_delay_status_check+0x30>
   12688:	4604      	mov	r4, r0
   1268a:	f8df 8040 	ldr.w	r8, [pc, #64]	; 126cc <am_hal_flash_delay_status_check+0x54>
   1268e:	e002      	b.n	12696 <am_hal_flash_delay_status_check+0x1e>
   12690:	b1c4      	cbz	r4, 126c4 <am_hal_flash_delay_status_check+0x4c>
   12692:	47c0      	blx	r8
   12694:	3c01      	subs	r4, #1
   12696:	682b      	ldr	r3, [r5, #0]
   12698:	4033      	ands	r3, r6
   1269a:	429f      	cmp	r7, r3
   1269c:	f04f 0001 	mov.w	r0, #1
   126a0:	d1f6      	bne.n	12690 <am_hal_flash_delay_status_check+0x18>
   126a2:	2000      	movs	r0, #0
   126a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   126a8:	f8df 8020 	ldr.w	r8, [pc, #32]	; 126cc <am_hal_flash_delay_status_check+0x54>
   126ac:	4604      	mov	r4, r0
   126ae:	e002      	b.n	126b6 <am_hal_flash_delay_status_check+0x3e>
   126b0:	b144      	cbz	r4, 126c4 <am_hal_flash_delay_status_check+0x4c>
   126b2:	47c0      	blx	r8
   126b4:	3c01      	subs	r4, #1
   126b6:	682b      	ldr	r3, [r5, #0]
   126b8:	4033      	ands	r3, r6
   126ba:	429f      	cmp	r7, r3
   126bc:	f04f 0001 	mov.w	r0, #1
   126c0:	d0f6      	beq.n	126b0 <am_hal_flash_delay_status_check+0x38>
   126c2:	e7ee      	b.n	126a2 <am_hal_flash_delay_status_check+0x2a>
   126c4:	2004      	movs	r0, #4
   126c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   126ca:	bf00      	nop
   126cc:	0800009d 	.word	0x0800009d

000126d0 <am_hal_interrupt_master_enable>:
   126d0:	f3ef 8010 	mrs	r0, PRIMASK
   126d4:	b662      	cpsie	i
   126d6:	4770      	bx	lr

000126d8 <am_hal_interrupt_master_disable>:
   126d8:	f3ef 8010 	mrs	r0, PRIMASK
   126dc:	b672      	cpsid	i
   126de:	4770      	bx	lr

000126e0 <am_hal_interrupt_master_set>:
   126e0:	f380 8810 	msr	PRIMASK, r0
   126e4:	4770      	bx	lr
   126e6:	bf00      	nop

000126e8 <am_hal_itm_disable>:
   126e8:	b510      	push	{r4, lr}
   126ea:	4b25      	ldr	r3, [pc, #148]	; (12780 <am_hal_itm_disable+0x98>)
   126ec:	f8d3 3250 	ldr.w	r3, [r3, #592]	; 0x250
   126f0:	b9b3      	cbnz	r3, 12720 <am_hal_itm_disable+0x38>
   126f2:	4b24      	ldr	r3, [pc, #144]	; (12784 <am_hal_itm_disable+0x9c>)
   126f4:	68da      	ldr	r2, [r3, #12]
   126f6:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
   126fa:	60da      	str	r2, [r3, #12]
   126fc:	68da      	ldr	r2, [r3, #12]
   126fe:	01d2      	lsls	r2, r2, #7
   12700:	d5fc      	bpl.n	126fc <am_hal_itm_disable+0x14>
   12702:	f04f 4360 	mov.w	r3, #3758096384	; 0xe0000000
   12706:	4920      	ldr	r1, [pc, #128]	; (12788 <am_hal_itm_disable+0xa0>)
   12708:	f8c3 1fb0 	str.w	r1, [r3, #4016]	; 0xfb0
   1270c:	4a1f      	ldr	r2, [pc, #124]	; (1278c <am_hal_itm_disable+0xa4>)
   1270e:	200f      	movs	r0, #15
   12710:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   12714:	f8c3 0e40 	str.w	r0, [r3, #3648]	; 0xe40
   12718:	f8c3 1e00 	str.w	r1, [r3, #3584]	; 0xe00
   1271c:	f8c3 2e80 	str.w	r2, [r3, #3712]	; 0xe80
   12720:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
   12724:	f8d2 3e80 	ldr.w	r3, [r2, #3712]	; 0xe80
   12728:	021b      	lsls	r3, r3, #8
   1272a:	f04f 4460 	mov.w	r4, #3758096384	; 0xe0000000
   1272e:	d4f9      	bmi.n	12724 <am_hal_itm_disable+0x3c>
   12730:	f240 20f7 	movw	r0, #759	; 0x2f7
   12734:	f7ff ff9c 	bl	12670 <am_hal_flash_delay>
   12738:	4b13      	ldr	r3, [pc, #76]	; (12788 <am_hal_itm_disable+0xa0>)
   1273a:	f8c4 3fb0 	str.w	r3, [r4, #4016]	; 0xfb0
   1273e:	4621      	mov	r1, r4
   12740:	2064      	movs	r0, #100	; 0x64
   12742:	f8d1 3e80 	ldr.w	r3, [r1, #3712]	; 0xe80
   12746:	f023 0301 	bic.w	r3, r3, #1
   1274a:	f8c1 3e80 	str.w	r3, [r1, #3712]	; 0xe80
   1274e:	f8d1 2e80 	ldr.w	r2, [r1, #3712]	; 0xe80
   12752:	4b0f      	ldr	r3, [pc, #60]	; (12790 <am_hal_itm_disable+0xa8>)
   12754:	4013      	ands	r3, r2
   12756:	2b00      	cmp	r3, #0
   12758:	d1f9      	bne.n	1274e <am_hal_itm_disable+0x66>
   1275a:	3801      	subs	r0, #1
   1275c:	d1f1      	bne.n	12742 <am_hal_itm_disable+0x5a>
   1275e:	4a09      	ldr	r2, [pc, #36]	; (12784 <am_hal_itm_disable+0x9c>)
   12760:	68d3      	ldr	r3, [r2, #12]
   12762:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
   12766:	60d3      	str	r3, [r2, #12]
   12768:	68d3      	ldr	r3, [r2, #12]
   1276a:	f013 7380 	ands.w	r3, r3, #16777216	; 0x1000000
   1276e:	d1fb      	bne.n	12768 <am_hal_itm_disable+0x80>
   12770:	4a03      	ldr	r2, [pc, #12]	; (12780 <am_hal_itm_disable+0x98>)
   12772:	f8c2 3250 	str.w	r3, [r2, #592]	; 0x250
   12776:	f8d2 3250 	ldr.w	r3, [r2, #592]	; 0x250
   1277a:	2b00      	cmp	r3, #0
   1277c:	d1fb      	bne.n	12776 <am_hal_itm_disable+0x8e>
   1277e:	bd10      	pop	{r4, pc}
   12780:	40020000 	.word	0x40020000
   12784:	e000edf0 	.word	0xe000edf0
   12788:	c5acce55 	.word	0xc5acce55
   1278c:	00150511 	.word	0x00150511
   12790:	00800001 	.word	0x00800001

00012794 <am_hal_mcuctrl_info_get>:
   12794:	b4f0      	push	{r4, r5, r6, r7}
   12796:	b121      	cbz	r1, 127a2 <am_hal_mcuctrl_info_get+0xe>
   12798:	2801      	cmp	r0, #1
   1279a:	d038      	beq.n	1280e <am_hal_mcuctrl_info_get+0x7a>
   1279c:	d320      	bcc.n	127e0 <am_hal_mcuctrl_info_get+0x4c>
   1279e:	2802      	cmp	r0, #2
   127a0:	d002      	beq.n	127a8 <am_hal_mcuctrl_info_get+0x14>
   127a2:	2006      	movs	r0, #6
   127a4:	bcf0      	pop	{r4, r5, r6, r7}
   127a6:	4770      	bx	lr
   127a8:	4a41      	ldr	r2, [pc, #260]	; (128b0 <am_hal_mcuctrl_info_get+0x11c>)
   127aa:	684d      	ldr	r5, [r1, #4]
   127ac:	f8d2 31cc 	ldr.w	r3, [r2, #460]	; 0x1cc
   127b0:	694c      	ldr	r4, [r1, #20]
   127b2:	f003 0601 	and.w	r6, r3, #1
   127b6:	f3c3 0040 	ubfx	r0, r3, #1, #1
   127ba:	f3c3 0380 	ubfx	r3, r3, #2, #1
   127be:	700e      	strb	r6, [r1, #0]
   127c0:	7208      	strb	r0, [r1, #8]
   127c2:	740b      	strb	r3, [r1, #16]
   127c4:	f8d2 31c4 	ldr.w	r3, [r2, #452]	; 0x1c4
   127c8:	60cb      	str	r3, [r1, #12]
   127ca:	f8d2 01c0 	ldr.w	r0, [r2, #448]	; 0x1c0
   127ce:	4328      	orrs	r0, r5
   127d0:	6048      	str	r0, [r1, #4]
   127d2:	f8d2 31c8 	ldr.w	r3, [r2, #456]	; 0x1c8
   127d6:	4323      	orrs	r3, r4
   127d8:	2000      	movs	r0, #0
   127da:	614b      	str	r3, [r1, #20]
   127dc:	bcf0      	pop	{r4, r5, r6, r7}
   127de:	4770      	bx	lr
   127e0:	4a33      	ldr	r2, [pc, #204]	; (128b0 <am_hal_mcuctrl_info_get+0x11c>)
   127e2:	6993      	ldr	r3, [r2, #24]
   127e4:	f3c3 1080 	ubfx	r0, r3, #6, #1
   127e8:	f3c3 0380 	ubfx	r3, r3, #2, #1
   127ec:	7008      	strb	r0, [r1, #0]
   127ee:	704b      	strb	r3, [r1, #1]
   127f0:	f8d2 31a0 	ldr.w	r3, [r2, #416]	; 0x1a0
   127f4:	f3c3 6381 	ubfx	r3, r3, #26, #2
   127f8:	710b      	strb	r3, [r1, #4]
   127fa:	6953      	ldr	r3, [r2, #20]
   127fc:	f3c3 0240 	ubfx	r2, r3, #1, #1
   12800:	f003 0301 	and.w	r3, r3, #1
   12804:	2000      	movs	r0, #0
   12806:	708a      	strb	r2, [r1, #2]
   12808:	70cb      	strb	r3, [r1, #3]
   1280a:	bcf0      	pop	{r4, r5, r6, r7}
   1280c:	4770      	bx	lr
   1280e:	4b28      	ldr	r3, [pc, #160]	; (128b0 <am_hal_mcuctrl_info_get+0x11c>)
   12810:	4c28      	ldr	r4, [pc, #160]	; (128b4 <am_hal_mcuctrl_info_get+0x120>)
   12812:	681a      	ldr	r2, [r3, #0]
   12814:	600a      	str	r2, [r1, #0]
   12816:	6858      	ldr	r0, [r3, #4]
   12818:	6048      	str	r0, [r1, #4]
   1281a:	6898      	ldr	r0, [r3, #8]
   1281c:	6088      	str	r0, [r1, #8]
   1281e:	68d8      	ldr	r0, [r3, #12]
   12820:	60c8      	str	r0, [r1, #12]
   12822:	691d      	ldr	r5, [r3, #16]
   12824:	4824      	ldr	r0, [pc, #144]	; (128b8 <am_hal_mcuctrl_info_get+0x124>)
   12826:	610d      	str	r5, [r1, #16]
   12828:	f3c2 5703 	ubfx	r7, r2, #20, #4
   1282c:	f3c2 4603 	ubfx	r6, r2, #16, #4
   12830:	695d      	ldr	r5, [r3, #20]
   12832:	f854 4027 	ldr.w	r4, [r4, r7, lsl #2]
   12836:	4b21      	ldr	r3, [pc, #132]	; (128bc <am_hal_mcuctrl_info_get+0x128>)
   12838:	f850 0026 	ldr.w	r0, [r0, r6, lsl #2]
   1283c:	6208      	str	r0, [r1, #32]
   1283e:	f002 0201 	and.w	r2, r2, #1
   12842:	614d      	str	r5, [r1, #20]
   12844:	61cc      	str	r4, [r1, #28]
   12846:	618a      	str	r2, [r1, #24]
   12848:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
   1284c:	f8d3 40e4 	ldr.w	r4, [r3, #228]	; 0xe4
   12850:	b2d0      	uxtb	r0, r2
   12852:	f004 020f 	and.w	r2, r4, #15
   12856:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
   1285a:	624a      	str	r2, [r1, #36]	; 0x24
   1285c:	f8d3 20e4 	ldr.w	r2, [r3, #228]	; 0xe4
   12860:	f8d3 40e8 	ldr.w	r4, [r3, #232]	; 0xe8
   12864:	f3c2 1003 	ubfx	r0, r2, #4, #4
   12868:	f004 020f 	and.w	r2, r4, #15
   1286c:	ea40 1202 	orr.w	r2, r0, r2, lsl #4
   12870:	628a      	str	r2, [r1, #40]	; 0x28
   12872:	f8d3 00e8 	ldr.w	r0, [r3, #232]	; 0xe8
   12876:	f8d3 20ec 	ldr.w	r2, [r3, #236]	; 0xec
   1287a:	f000 00f0 	and.w	r0, r0, #240	; 0xf0
   1287e:	f3c2 1203 	ubfx	r2, r2, #4, #4
   12882:	4302      	orrs	r2, r0
   12884:	62ca      	str	r2, [r1, #44]	; 0x2c
   12886:	f8d3 50fc 	ldr.w	r5, [r3, #252]	; 0xfc
   1288a:	f8d3 00f8 	ldr.w	r0, [r3, #248]	; 0xf8
   1288e:	f8d3 40f4 	ldr.w	r4, [r3, #244]	; 0xf4
   12892:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
   12896:	b2c0      	uxtb	r0, r0
   12898:	0400      	lsls	r0, r0, #16
   1289a:	ea40 6305 	orr.w	r3, r0, r5, lsl #24
   1289e:	b2d2      	uxtb	r2, r2
   128a0:	431a      	orrs	r2, r3
   128a2:	b2e3      	uxtb	r3, r4
   128a4:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
   128a8:	630b      	str	r3, [r1, #48]	; 0x30
   128aa:	2000      	movs	r0, #0
   128ac:	bcf0      	pop	{r4, r5, r6, r7}
   128ae:	4770      	bx	lr
   128b0:	40020000 	.word	0x40020000
   128b4:	00013880 	.word	0x00013880
   128b8:	000138c0 	.word	0x000138c0
   128bc:	f0000f00 	.word	0xf0000f00

000128c0 <am_hal_pwrctrl_periph_enable>:
   128c0:	b570      	push	{r4, r5, r6, lr}
   128c2:	b082      	sub	sp, #8
   128c4:	4604      	mov	r4, r0
   128c6:	f7ff ff07 	bl	126d8 <am_hal_interrupt_master_disable>
   128ca:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   128ce:	4d0f      	ldr	r5, [pc, #60]	; (1290c <am_hal_pwrctrl_periph_enable+0x4c>)
   128d0:	4e0f      	ldr	r6, [pc, #60]	; (12910 <am_hal_pwrctrl_periph_enable+0x50>)
   128d2:	9001      	str	r0, [sp, #4]
   128d4:	00a4      	lsls	r4, r4, #2
   128d6:	68aa      	ldr	r2, [r5, #8]
   128d8:	5933      	ldr	r3, [r6, r4]
   128da:	4313      	orrs	r3, r2
   128dc:	60ab      	str	r3, [r5, #8]
   128de:	9801      	ldr	r0, [sp, #4]
   128e0:	4434      	add	r4, r6
   128e2:	f7ff fefd 	bl	126e0 <am_hal_interrupt_master_set>
   128e6:	2077      	movs	r0, #119	; 0x77
   128e8:	f7ff fec2 	bl	12670 <am_hal_flash_delay>
   128ec:	69ab      	ldr	r3, [r5, #24]
   128ee:	6864      	ldr	r4, [r4, #4]
   128f0:	4223      	tst	r3, r4
   128f2:	d103      	bne.n	128fc <am_hal_pwrctrl_periph_enable+0x3c>
   128f4:	2077      	movs	r0, #119	; 0x77
   128f6:	f7ff febb 	bl	12670 <am_hal_flash_delay>
   128fa:	69ab      	ldr	r3, [r5, #24]
   128fc:	4b03      	ldr	r3, [pc, #12]	; (1290c <am_hal_pwrctrl_periph_enable+0x4c>)
   128fe:	699b      	ldr	r3, [r3, #24]
   12900:	4223      	tst	r3, r4
   12902:	bf0c      	ite	eq
   12904:	2001      	moveq	r0, #1
   12906:	2000      	movne	r0, #0
   12908:	b002      	add	sp, #8
   1290a:	bd70      	pop	{r4, r5, r6, pc}
   1290c:	40021000 	.word	0x40021000
   12910:	00013900 	.word	0x00013900

00012914 <am_hal_pwrctrl_periph_disable>:
   12914:	b570      	push	{r4, r5, r6, lr}
   12916:	b082      	sub	sp, #8
   12918:	4604      	mov	r4, r0
   1291a:	f7ff fedd 	bl	126d8 <am_hal_interrupt_master_disable>
   1291e:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   12922:	4d10      	ldr	r5, [pc, #64]	; (12964 <am_hal_pwrctrl_periph_disable+0x50>)
   12924:	4e10      	ldr	r6, [pc, #64]	; (12968 <am_hal_pwrctrl_periph_disable+0x54>)
   12926:	9001      	str	r0, [sp, #4]
   12928:	00a4      	lsls	r4, r4, #2
   1292a:	68ab      	ldr	r3, [r5, #8]
   1292c:	5932      	ldr	r2, [r6, r4]
   1292e:	ea23 0302 	bic.w	r3, r3, r2
   12932:	60ab      	str	r3, [r5, #8]
   12934:	9801      	ldr	r0, [sp, #4]
   12936:	4434      	add	r4, r6
   12938:	f7ff fed2 	bl	126e0 <am_hal_interrupt_master_set>
   1293c:	2077      	movs	r0, #119	; 0x77
   1293e:	f7ff fe97 	bl	12670 <am_hal_flash_delay>
   12942:	69ab      	ldr	r3, [r5, #24]
   12944:	6864      	ldr	r4, [r4, #4]
   12946:	4223      	tst	r3, r4
   12948:	d003      	beq.n	12952 <am_hal_pwrctrl_periph_disable+0x3e>
   1294a:	2077      	movs	r0, #119	; 0x77
   1294c:	f7ff fe90 	bl	12670 <am_hal_flash_delay>
   12950:	69ab      	ldr	r3, [r5, #24]
   12952:	4b04      	ldr	r3, [pc, #16]	; (12964 <am_hal_pwrctrl_periph_disable+0x50>)
   12954:	699b      	ldr	r3, [r3, #24]
   12956:	4223      	tst	r3, r4
   12958:	bf14      	ite	ne
   1295a:	2001      	movne	r0, #1
   1295c:	2000      	moveq	r0, #0
   1295e:	b002      	add	sp, #8
   12960:	bd70      	pop	{r4, r5, r6, pc}
   12962:	bf00      	nop
   12964:	40021000 	.word	0x40021000
   12968:	00013900 	.word	0x00013900

0001296c <am_hal_pwrctrl_low_power_init>:
   1296c:	b530      	push	{r4, r5, lr}
   1296e:	4b1f      	ldr	r3, [pc, #124]	; (129ec <am_hal_pwrctrl_low_power_init+0x80>)
   12970:	681a      	ldr	r2, [r3, #0]
   12972:	b083      	sub	sp, #12
   12974:	b912      	cbnz	r2, 1297c <am_hal_pwrctrl_low_power_init+0x10>
   12976:	4a1e      	ldr	r2, [pc, #120]	; (129f0 <am_hal_pwrctrl_low_power_init+0x84>)
   12978:	6812      	ldr	r2, [r2, #0]
   1297a:	601a      	str	r2, [r3, #0]
   1297c:	4c1d      	ldr	r4, [pc, #116]	; (129f4 <am_hal_pwrctrl_low_power_init+0x88>)
   1297e:	69a3      	ldr	r3, [r4, #24]
   12980:	05db      	lsls	r3, r3, #23
   12982:	d502      	bpl.n	1298a <am_hal_pwrctrl_low_power_init+0x1e>
   12984:	2000      	movs	r0, #0
   12986:	b003      	add	sp, #12
   12988:	bd30      	pop	{r4, r5, pc}
   1298a:	4d1b      	ldr	r5, [pc, #108]	; (129f8 <am_hal_pwrctrl_low_power_init+0x8c>)
   1298c:	491b      	ldr	r1, [pc, #108]	; (129fc <am_hal_pwrctrl_low_power_init+0x90>)
   1298e:	7e2a      	ldrb	r2, [r5, #24]
   12990:	2001      	movs	r0, #1
   12992:	4302      	orrs	r2, r0
   12994:	2307      	movs	r3, #7
   12996:	762a      	strb	r2, [r5, #24]
   12998:	9000      	str	r0, [sp, #0]
   1299a:	461a      	mov	r2, r3
   1299c:	f242 7010 	movw	r0, #10000	; 0x2710
   129a0:	f7ff fe6a 	bl	12678 <am_hal_flash_delay_status_check>
   129a4:	b110      	cbz	r0, 129ac <am_hal_pwrctrl_low_power_init+0x40>
   129a6:	2004      	movs	r0, #4
   129a8:	b003      	add	sp, #12
   129aa:	bd30      	pop	{r4, r5, pc}
   129ac:	6823      	ldr	r3, [r4, #0]
   129ae:	f043 0301 	orr.w	r3, r3, #1
   129b2:	6023      	str	r3, [r4, #0]
   129b4:	6a63      	ldr	r3, [r4, #36]	; 0x24
   129b6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   129ba:	6263      	str	r3, [r4, #36]	; 0x24
   129bc:	68eb      	ldr	r3, [r5, #12]
   129be:	b2db      	uxtb	r3, r3
   129c0:	2b11      	cmp	r3, #17
   129c2:	d1df      	bne.n	12984 <am_hal_pwrctrl_low_power_init+0x18>
   129c4:	f8d5 335c 	ldr.w	r3, [r5, #860]	; 0x35c
   129c8:	f360 5356 	bfi	r3, r0, #21, #2
   129cc:	f8c5 335c 	str.w	r3, [r5, #860]	; 0x35c
   129d0:	f8d5 3368 	ldr.w	r3, [r5, #872]	; 0x368
   129d4:	220f      	movs	r2, #15
   129d6:	f362 138b 	bfi	r3, r2, #6, #6
   129da:	f8c5 3368 	str.w	r3, [r5, #872]	; 0x368
   129de:	f8d5 3368 	ldr.w	r3, [r5, #872]	; 0x368
   129e2:	f362 0305 	bfi	r3, r2, #0, #6
   129e6:	f8c5 3368 	str.w	r3, [r5, #872]	; 0x368
   129ea:	e7cc      	b.n	12986 <am_hal_pwrctrl_low_power_init+0x1a>
   129ec:	100143ec 	.word	0x100143ec
   129f0:	4ffff000 	.word	0x4ffff000
   129f4:	40021000 	.word	0x40021000
   129f8:	40020000 	.word	0x40020000
   129fc:	40020018 	.word	0x40020018

00012a00 <am_hal_rtc_osc_select>:
   12a00:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
   12a04:	2801      	cmp	r0, #1
   12a06:	68d3      	ldr	r3, [r2, #12]
   12a08:	bf0c      	ite	eq
   12a0a:	f043 0380 	orreq.w	r3, r3, #128	; 0x80
   12a0e:	f023 0380 	bicne.w	r3, r3, #128	; 0x80
   12a12:	60d3      	str	r3, [r2, #12]
   12a14:	4770      	bx	lr
   12a16:	bf00      	nop

00012a18 <am_hal_rtc_osc_disable>:
   12a18:	4a03      	ldr	r2, [pc, #12]	; (12a28 <am_hal_rtc_osc_disable+0x10>)
   12a1a:	f892 3050 	ldrb.w	r3, [r2, #80]	; 0x50
   12a1e:	f043 0310 	orr.w	r3, r3, #16
   12a22:	f882 3050 	strb.w	r3, [r2, #80]	; 0x50
   12a26:	4770      	bx	lr
   12a28:	40004200 	.word	0x40004200

00012a2c <am_hal_stimer_config>:
   12a2c:	4b03      	ldr	r3, [pc, #12]	; (12a3c <am_hal_stimer_config+0x10>)
   12a2e:	f8d3 2140 	ldr.w	r2, [r3, #320]	; 0x140
   12a32:	f8c3 0140 	str.w	r0, [r3, #320]	; 0x140
   12a36:	4610      	mov	r0, r2
   12a38:	4770      	bx	lr
   12a3a:	bf00      	nop
   12a3c:	40008000 	.word	0x40008000

00012a40 <am_hal_stimer_counter_get>:
   12a40:	4b01      	ldr	r3, [pc, #4]	; (12a48 <am_hal_stimer_counter_get+0x8>)
   12a42:	f8d3 0144 	ldr.w	r0, [r3, #324]	; 0x144
   12a46:	4770      	bx	lr
   12a48:	40008000 	.word	0x40008000

00012a4c <am_hal_stimer_compare_delta_set>:
   12a4c:	2807      	cmp	r0, #7
   12a4e:	d900      	bls.n	12a52 <am_hal_stimer_compare_delta_set+0x6>
   12a50:	4770      	bx	lr
   12a52:	b570      	push	{r4, r5, r6, lr}
   12a54:	b082      	sub	sp, #8
   12a56:	460c      	mov	r4, r1
   12a58:	4605      	mov	r5, r0
   12a5a:	f7ff fe3d 	bl	126d8 <am_hal_interrupt_master_disable>
   12a5e:	4923      	ldr	r1, [pc, #140]	; (12aec <am_hal_stimer_compare_delta_set+0xa0>)
   12a60:	9001      	str	r0, [sp, #4]
   12a62:	4b23      	ldr	r3, [pc, #140]	; (12af0 <am_hal_stimer_compare_delta_set+0xa4>)
   12a64:	f8d1 0140 	ldr.w	r0, [r1, #320]	; 0x140
   12a68:	f8d1 6140 	ldr.w	r6, [r1, #320]	; 0x140
   12a6c:	f44f 7280 	mov.w	r2, #256	; 0x100
   12a70:	442b      	add	r3, r5
   12a72:	40aa      	lsls	r2, r5
   12a74:	ea26 0502 	bic.w	r5, r6, r2
   12a78:	009b      	lsls	r3, r3, #2
   12a7a:	f8c1 5140 	str.w	r5, [r1, #320]	; 0x140
   12a7e:	f8d1 1144 	ldr.w	r1, [r1, #324]	; 0x144
   12a82:	601c      	str	r4, [r3, #0]
   12a84:	681d      	ldr	r5, [r3, #0]
   12a86:	4421      	add	r1, r4
   12a88:	1a6e      	subs	r6, r5, r1
   12a8a:	2e00      	cmp	r6, #0
   12a8c:	db03      	blt.n	12a96 <am_hal_stimer_compare_delta_set+0x4a>
   12a8e:	310a      	adds	r1, #10
   12a90:	1a69      	subs	r1, r5, r1
   12a92:	2900      	cmp	r1, #0
   12a94:	dd1e      	ble.n	12ad4 <am_hal_stimer_compare_delta_set+0x88>
   12a96:	4915      	ldr	r1, [pc, #84]	; (12aec <am_hal_stimer_compare_delta_set+0xa0>)
   12a98:	f8d1 1144 	ldr.w	r1, [r1, #324]	; 0x144
   12a9c:	601c      	str	r4, [r3, #0]
   12a9e:	681d      	ldr	r5, [r3, #0]
   12aa0:	4421      	add	r1, r4
   12aa2:	1a6e      	subs	r6, r5, r1
   12aa4:	2e00      	cmp	r6, #0
   12aa6:	db03      	blt.n	12ab0 <am_hal_stimer_compare_delta_set+0x64>
   12aa8:	310a      	adds	r1, #10
   12aaa:	1a69      	subs	r1, r5, r1
   12aac:	2900      	cmp	r1, #0
   12aae:	dd11      	ble.n	12ad4 <am_hal_stimer_compare_delta_set+0x88>
   12ab0:	490e      	ldr	r1, [pc, #56]	; (12aec <am_hal_stimer_compare_delta_set+0xa0>)
   12ab2:	f8d1 1144 	ldr.w	r1, [r1, #324]	; 0x144
   12ab6:	601c      	str	r4, [r3, #0]
   12ab8:	681d      	ldr	r5, [r3, #0]
   12aba:	4421      	add	r1, r4
   12abc:	1a6e      	subs	r6, r5, r1
   12abe:	2e00      	cmp	r6, #0
   12ac0:	db03      	blt.n	12aca <am_hal_stimer_compare_delta_set+0x7e>
   12ac2:	310a      	adds	r1, #10
   12ac4:	1a69      	subs	r1, r5, r1
   12ac6:	2900      	cmp	r1, #0
   12ac8:	dd04      	ble.n	12ad4 <am_hal_stimer_compare_delta_set+0x88>
   12aca:	4908      	ldr	r1, [pc, #32]	; (12aec <am_hal_stimer_compare_delta_set+0xa0>)
   12acc:	f8d1 1144 	ldr.w	r1, [r1, #324]	; 0x144
   12ad0:	601c      	str	r4, [r3, #0]
   12ad2:	681b      	ldr	r3, [r3, #0]
   12ad4:	4905      	ldr	r1, [pc, #20]	; (12aec <am_hal_stimer_compare_delta_set+0xa0>)
   12ad6:	f8d1 3140 	ldr.w	r3, [r1, #320]	; 0x140
   12ada:	4002      	ands	r2, r0
   12adc:	431a      	orrs	r2, r3
   12ade:	f8c1 2140 	str.w	r2, [r1, #320]	; 0x140
   12ae2:	9801      	ldr	r0, [sp, #4]
   12ae4:	f7ff fdfc 	bl	126e0 <am_hal_interrupt_master_set>
   12ae8:	b002      	add	sp, #8
   12aea:	bd70      	pop	{r4, r5, r6, pc}
   12aec:	40008000 	.word	0x40008000
   12af0:	10002054 	.word	0x10002054

00012af4 <am_hal_stimer_int_enable>:
   12af4:	4a03      	ldr	r2, [pc, #12]	; (12b04 <am_hal_stimer_int_enable+0x10>)
   12af6:	f8d2 3300 	ldr.w	r3, [r2, #768]	; 0x300
   12afa:	4318      	orrs	r0, r3
   12afc:	f8c2 0300 	str.w	r0, [r2, #768]	; 0x300
   12b00:	4770      	bx	lr
   12b02:	bf00      	nop
   12b04:	40008000 	.word	0x40008000

00012b08 <am_hal_stimer_int_clear>:
   12b08:	4b01      	ldr	r3, [pc, #4]	; (12b10 <am_hal_stimer_int_clear+0x8>)
   12b0a:	f8c3 0308 	str.w	r0, [r3, #776]	; 0x308
   12b0e:	4770      	bx	lr
   12b10:	40008000 	.word	0x40008000

00012b14 <am_hal_stimer_int_status_get>:
   12b14:	4a04      	ldr	r2, [pc, #16]	; (12b28 <am_hal_stimer_int_status_get+0x14>)
   12b16:	f8d2 3304 	ldr.w	r3, [r2, #772]	; 0x304
   12b1a:	b110      	cbz	r0, 12b22 <am_hal_stimer_int_status_get+0xe>
   12b1c:	f8d2 2300 	ldr.w	r2, [r2, #768]	; 0x300
   12b20:	4013      	ands	r3, r2
   12b22:	4618      	mov	r0, r3
   12b24:	4770      	bx	lr
   12b26:	bf00      	nop
   12b28:	40008000 	.word	0x40008000

00012b2c <am_hal_sysctrl_sleep>:
   12b2c:	b510      	push	{r4, lr}
   12b2e:	b082      	sub	sp, #8
   12b30:	4604      	mov	r4, r0
   12b32:	f7ff fdd1 	bl	126d8 <am_hal_interrupt_master_disable>
   12b36:	4a0f      	ldr	r2, [pc, #60]	; (12b74 <am_hal_sysctrl_sleep+0x48>)
   12b38:	9001      	str	r0, [sp, #4]
   12b3a:	b124      	cbz	r4, 12b46 <am_hal_sysctrl_sleep+0x1a>
   12b3c:	4b0e      	ldr	r3, [pc, #56]	; (12b78 <am_hal_sysctrl_sleep+0x4c>)
   12b3e:	f8d3 3250 	ldr.w	r3, [r3, #592]	; 0x250
   12b42:	07db      	lsls	r3, r3, #31
   12b44:	d511      	bpl.n	12b6a <am_hal_sysctrl_sleep+0x3e>
   12b46:	6913      	ldr	r3, [r2, #16]
   12b48:	f023 0304 	bic.w	r3, r3, #4
   12b4c:	6113      	str	r3, [r2, #16]
   12b4e:	f3bf 8f4f 	dsb	sy
   12b52:	4a0a      	ldr	r2, [pc, #40]	; (12b7c <am_hal_sysctrl_sleep+0x50>)
   12b54:	4b0a      	ldr	r3, [pc, #40]	; (12b80 <am_hal_sysctrl_sleep+0x54>)
   12b56:	6812      	ldr	r2, [r2, #0]
   12b58:	601a      	str	r2, [r3, #0]
   12b5a:	bf30      	wfi
   12b5c:	f3bf 8f6f 	isb	sy
   12b60:	9801      	ldr	r0, [sp, #4]
   12b62:	f7ff fdbd 	bl	126e0 <am_hal_interrupt_master_set>
   12b66:	b002      	add	sp, #8
   12b68:	bd10      	pop	{r4, pc}
   12b6a:	6913      	ldr	r3, [r2, #16]
   12b6c:	f043 0304 	orr.w	r3, r3, #4
   12b70:	6113      	str	r3, [r2, #16]
   12b72:	e7ec      	b.n	12b4e <am_hal_sysctrl_sleep+0x22>
   12b74:	e000ed00 	.word	0xe000ed00
   12b78:	40020000 	.word	0x40020000
   12b7c:	5fff0000 	.word	0x5fff0000
   12b80:	100143f0 	.word	0x100143f0

00012b84 <am_hal_uart_initialize>:
   12b84:	2801      	cmp	r0, #1
   12b86:	d901      	bls.n	12b8c <am_hal_uart_initialize+0x8>
   12b88:	2005      	movs	r0, #5
   12b8a:	4770      	bx	lr
   12b8c:	b169      	cbz	r1, 12baa <am_hal_uart_initialize+0x26>
   12b8e:	b5f0      	push	{r4, r5, r6, r7, lr}
   12b90:	2264      	movs	r2, #100	; 0x64
   12b92:	4e0e      	ldr	r6, [pc, #56]	; (12bcc <am_hal_uart_initialize+0x48>)
   12b94:	fb02 f200 	mul.w	r2, r2, r0
   12b98:	18b4      	adds	r4, r6, r2
   12b9a:	4603      	mov	r3, r0
   12b9c:	78e0      	ldrb	r0, [r4, #3]
   12b9e:	f3c0 0700 	ubfx	r7, r0, #0, #1
   12ba2:	b2fd      	uxtb	r5, r7
   12ba4:	b11d      	cbz	r5, 12bae <am_hal_uart_initialize+0x2a>
   12ba6:	2007      	movs	r0, #7
   12ba8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   12baa:	2006      	movs	r0, #6
   12bac:	4770      	bx	lr
   12bae:	f040 0001 	orr.w	r0, r0, #1
   12bb2:	70e0      	strb	r0, [r4, #3]
   12bb4:	58b0      	ldr	r0, [r6, r2]
   12bb6:	f8df e018 	ldr.w	lr, [pc, #24]	; 12bd0 <am_hal_uart_initialize+0x4c>
   12bba:	f36e 0017 	bfi	r0, lr, #0, #24
   12bbe:	50b0      	str	r0, [r6, r2]
   12bc0:	6263      	str	r3, [r4, #36]	; 0x24
   12bc2:	7127      	strb	r7, [r4, #4]
   12bc4:	6625      	str	r5, [r4, #96]	; 0x60
   12bc6:	4628      	mov	r0, r5
   12bc8:	600c      	str	r4, [r1, #0]
   12bca:	bdf0      	pop	{r4, r5, r6, r7, pc}
   12bcc:	10015e7c 	.word	0x10015e7c
   12bd0:	00ea9e06 	.word	0x00ea9e06

00012bd4 <am_hal_uart_power_control>:
   12bd4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   12bd8:	6804      	ldr	r4, [r0, #0]
   12bda:	4b36      	ldr	r3, [pc, #216]	; (12cb4 <am_hal_uart_power_control+0xe0>)
   12bdc:	f024 447e 	bic.w	r4, r4, #4261412864	; 0xfe000000
   12be0:	429c      	cmp	r4, r3
   12be2:	b083      	sub	sp, #12
   12be4:	d003      	beq.n	12bee <am_hal_uart_power_control+0x1a>
   12be6:	2002      	movs	r0, #2
   12be8:	b003      	add	sp, #12
   12bea:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   12bee:	6a47      	ldr	r7, [r0, #36]	; 0x24
   12bf0:	4605      	mov	r5, r0
   12bf2:	f107 0008 	add.w	r0, r7, #8
   12bf6:	4691      	mov	r9, r2
   12bf8:	460e      	mov	r6, r1
   12bfa:	fa5f f880 	uxtb.w	r8, r0
   12bfe:	b181      	cbz	r1, 12c22 <am_hal_uart_power_control+0x4e>
   12c00:	2902      	cmp	r1, #2
   12c02:	d80c      	bhi.n	12c1e <am_hal_uart_power_control+0x4a>
   12c04:	b992      	cbnz	r2, 12c2c <am_hal_uart_power_control+0x58>
   12c06:	f507 2780 	add.w	r7, r7, #262144	; 0x40000
   12c0a:	371c      	adds	r7, #28
   12c0c:	033f      	lsls	r7, r7, #12
   12c0e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   12c12:	647b      	str	r3, [r7, #68]	; 0x44
   12c14:	4640      	mov	r0, r8
   12c16:	f7ff fe7d 	bl	12914 <am_hal_pwrctrl_periph_disable>
   12c1a:	2000      	movs	r0, #0
   12c1c:	e7e4      	b.n	12be8 <am_hal_uart_power_control+0x14>
   12c1e:	2006      	movs	r0, #6
   12c20:	e7e2      	b.n	12be8 <am_hal_uart_power_control+0x14>
   12c22:	b322      	cbz	r2, 12c6e <am_hal_uart_power_control+0x9a>
   12c24:	792b      	ldrb	r3, [r5, #4]
   12c26:	bb3b      	cbnz	r3, 12c78 <am_hal_uart_power_control+0xa4>
   12c28:	2007      	movs	r0, #7
   12c2a:	e7dd      	b.n	12be8 <am_hal_uart_power_control+0x14>
   12c2c:	f7ff fd54 	bl	126d8 <am_hal_interrupt_master_disable>
   12c30:	f507 2380 	add.w	r3, r7, #262144	; 0x40000
   12c34:	331c      	adds	r3, #28
   12c36:	031b      	lsls	r3, r3, #12
   12c38:	9001      	str	r0, [sp, #4]
   12c3a:	6a1a      	ldr	r2, [r3, #32]
   12c3c:	60aa      	str	r2, [r5, #8]
   12c3e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   12c40:	60ea      	str	r2, [r5, #12]
   12c42:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   12c44:	612a      	str	r2, [r5, #16]
   12c46:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   12c48:	616a      	str	r2, [r5, #20]
   12c4a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   12c4c:	61aa      	str	r2, [r5, #24]
   12c4e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   12c50:	61ea      	str	r2, [r5, #28]
   12c52:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   12c54:	622b      	str	r3, [r5, #32]
   12c56:	2301      	movs	r3, #1
   12c58:	712b      	strb	r3, [r5, #4]
   12c5a:	9801      	ldr	r0, [sp, #4]
   12c5c:	f7ff fd40 	bl	126e0 <am_hal_interrupt_master_set>
   12c60:	682b      	ldr	r3, [r5, #0]
   12c62:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   12c66:	42a3      	cmp	r3, r4
   12c68:	d1d4      	bne.n	12c14 <am_hal_uart_power_control+0x40>
   12c6a:	6a6f      	ldr	r7, [r5, #36]	; 0x24
   12c6c:	e7cb      	b.n	12c06 <am_hal_uart_power_control+0x32>
   12c6e:	4640      	mov	r0, r8
   12c70:	f7ff fe26 	bl	128c0 <am_hal_pwrctrl_periph_enable>
   12c74:	4648      	mov	r0, r9
   12c76:	e7b7      	b.n	12be8 <am_hal_uart_power_control+0x14>
   12c78:	4640      	mov	r0, r8
   12c7a:	f7ff fe21 	bl	128c0 <am_hal_pwrctrl_periph_enable>
   12c7e:	f7ff fd2b 	bl	126d8 <am_hal_interrupt_master_disable>
   12c82:	f507 2380 	add.w	r3, r7, #262144	; 0x40000
   12c86:	331c      	adds	r3, #28
   12c88:	031b      	lsls	r3, r3, #12
   12c8a:	68aa      	ldr	r2, [r5, #8]
   12c8c:	9000      	str	r0, [sp, #0]
   12c8e:	621a      	str	r2, [r3, #32]
   12c90:	68ea      	ldr	r2, [r5, #12]
   12c92:	625a      	str	r2, [r3, #36]	; 0x24
   12c94:	692a      	ldr	r2, [r5, #16]
   12c96:	629a      	str	r2, [r3, #40]	; 0x28
   12c98:	696a      	ldr	r2, [r5, #20]
   12c9a:	62da      	str	r2, [r3, #44]	; 0x2c
   12c9c:	69aa      	ldr	r2, [r5, #24]
   12c9e:	631a      	str	r2, [r3, #48]	; 0x30
   12ca0:	69ea      	ldr	r2, [r5, #28]
   12ca2:	635a      	str	r2, [r3, #52]	; 0x34
   12ca4:	6a2a      	ldr	r2, [r5, #32]
   12ca6:	639a      	str	r2, [r3, #56]	; 0x38
   12ca8:	9800      	ldr	r0, [sp, #0]
   12caa:	712e      	strb	r6, [r5, #4]
   12cac:	f7ff fd18 	bl	126e0 <am_hal_interrupt_master_set>
   12cb0:	4630      	mov	r0, r6
   12cb2:	e799      	b.n	12be8 <am_hal_uart_power_control+0x14>
   12cb4:	01ea9e06 	.word	0x01ea9e06

00012cb8 <am_hal_uart_configure>:
   12cb8:	6803      	ldr	r3, [r0, #0]
   12cba:	4a7a      	ldr	r2, [pc, #488]	; (12ea4 <am_hal_uart_configure+0x1ec>)
   12cbc:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   12cc0:	4293      	cmp	r3, r2
   12cc2:	d001      	beq.n	12cc8 <am_hal_uart_configure+0x10>
   12cc4:	2002      	movs	r0, #2
   12cc6:	4770      	bx	lr
   12cc8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   12ccc:	6a45      	ldr	r5, [r0, #36]	; 0x24
   12cce:	f505 2580 	add.w	r5, r5, #262144	; 0x40000
   12cd2:	351c      	adds	r5, #28
   12cd4:	032d      	lsls	r5, r5, #12
   12cd6:	2700      	movs	r7, #0
   12cd8:	b084      	sub	sp, #16
   12cda:	632f      	str	r7, [r5, #48]	; 0x30
   12cdc:	460e      	mov	r6, r1
   12cde:	4604      	mov	r4, r0
   12ce0:	f7ff fcfa 	bl	126d8 <am_hal_interrupt_master_disable>
   12ce4:	9001      	str	r0, [sp, #4]
   12ce6:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
   12ce8:	f043 0308 	orr.w	r3, r3, #8
   12cec:	862b      	strh	r3, [r5, #48]	; 0x30
   12cee:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
   12cf0:	2201      	movs	r2, #1
   12cf2:	f362 1306 	bfi	r3, r2, #4, #3
   12cf6:	862b      	strh	r3, [r5, #48]	; 0x30
   12cf8:	9801      	ldr	r0, [sp, #4]
   12cfa:	f7ff fcf1 	bl	126e0 <am_hal_interrupt_master_set>
   12cfe:	f7ff fceb 	bl	126d8 <am_hal_interrupt_master_disable>
   12d02:	9002      	str	r0, [sp, #8]
   12d04:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
   12d06:	f367 0300 	bfi	r3, r7, #0, #1
   12d0a:	862b      	strh	r3, [r5, #48]	; 0x30
   12d0c:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
   12d0e:	f367 2349 	bfi	r3, r7, #9, #1
   12d12:	862b      	strh	r3, [r5, #48]	; 0x30
   12d14:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
   12d16:	f367 2308 	bfi	r3, r7, #8, #1
   12d1a:	862b      	strh	r3, [r5, #48]	; 0x30
   12d1c:	9802      	ldr	r0, [sp, #8]
   12d1e:	f7ff fcdf 	bl	126e0 <am_hal_interrupt_master_set>
   12d22:	6b2b      	ldr	r3, [r5, #48]	; 0x30
   12d24:	f3c3 1302 	ubfx	r3, r3, #4, #3
   12d28:	3b01      	subs	r3, #1
   12d2a:	2b03      	cmp	r3, #3
   12d2c:	d854      	bhi.n	12dd8 <am_hal_uart_configure+0x120>
   12d2e:	e8df f003 	tbb	[pc, r3]
   12d32:	020e      	.short	0x020e
   12d34:	1114      	.short	0x1114
   12d36:	495c      	ldr	r1, [pc, #368]	; (12ea8 <am_hal_uart_configure+0x1f0>)
   12d38:	485c      	ldr	r0, [pc, #368]	; (12eac <am_hal_uart_configure+0x1f4>)
   12d3a:	6832      	ldr	r2, [r6, #0]
   12d3c:	0112      	lsls	r2, r2, #4
   12d3e:	fbb0 f3f2 	udiv	r3, r0, r2
   12d42:	b96b      	cbnz	r3, 12d60 <am_hal_uart_configure+0xa8>
   12d44:	485a      	ldr	r0, [pc, #360]	; (12eb0 <am_hal_uart_configure+0x1f8>)
   12d46:	6623      	str	r3, [r4, #96]	; 0x60
   12d48:	b004      	add	sp, #16
   12d4a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   12d4e:	4959      	ldr	r1, [pc, #356]	; (12eb4 <am_hal_uart_configure+0x1fc>)
   12d50:	4859      	ldr	r0, [pc, #356]	; (12eb8 <am_hal_uart_configure+0x200>)
   12d52:	e7f2      	b.n	12d3a <am_hal_uart_configure+0x82>
   12d54:	4959      	ldr	r1, [pc, #356]	; (12ebc <am_hal_uart_configure+0x204>)
   12d56:	485a      	ldr	r0, [pc, #360]	; (12ec0 <am_hal_uart_configure+0x208>)
   12d58:	e7ef      	b.n	12d3a <am_hal_uart_configure+0x82>
   12d5a:	495a      	ldr	r1, [pc, #360]	; (12ec4 <am_hal_uart_configure+0x20c>)
   12d5c:	485a      	ldr	r0, [pc, #360]	; (12ec8 <am_hal_uart_configure+0x210>)
   12d5e:	e7ec      	b.n	12d3a <am_hal_uart_configure+0x82>
   12d60:	fbb1 f2f2 	udiv	r2, r1, r2
   12d64:	eba2 1283 	sub.w	r2, r2, r3, lsl #6
   12d68:	626b      	str	r3, [r5, #36]	; 0x24
   12d6a:	eb02 1103 	add.w	r1, r2, r3, lsl #4
   12d6e:	626b      	str	r3, [r5, #36]	; 0x24
   12d70:	fbb0 f0f1 	udiv	r0, r0, r1
   12d74:	62aa      	str	r2, [r5, #40]	; 0x28
   12d76:	6620      	str	r0, [r4, #96]	; 0x60
   12d78:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
   12d7a:	f36f 338e 	bfc	r3, #14, #1
   12d7e:	862b      	strh	r3, [r5, #48]	; 0x30
   12d80:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
   12d82:	f36f 33cf 	bfc	r3, #15, #1
   12d86:	862b      	strh	r3, [r5, #48]	; 0x30
   12d88:	6b2a      	ldr	r2, [r5, #48]	; 0x30
   12d8a:	6933      	ldr	r3, [r6, #16]
   12d8c:	4313      	orrs	r3, r2
   12d8e:	632b      	str	r3, [r5, #48]	; 0x30
   12d90:	6973      	ldr	r3, [r6, #20]
   12d92:	636b      	str	r3, [r5, #52]	; 0x34
   12d94:	6871      	ldr	r1, [r6, #4]
   12d96:	68b3      	ldr	r3, [r6, #8]
   12d98:	68f2      	ldr	r2, [r6, #12]
   12d9a:	430b      	orrs	r3, r1
   12d9c:	f043 0310 	orr.w	r3, r3, #16
   12da0:	4313      	orrs	r3, r2
   12da2:	62eb      	str	r3, [r5, #44]	; 0x2c
   12da4:	f7ff fc98 	bl	126d8 <am_hal_interrupt_master_disable>
   12da8:	9003      	str	r0, [sp, #12]
   12daa:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
   12dac:	f043 0301 	orr.w	r3, r3, #1
   12db0:	862b      	strh	r3, [r5, #48]	; 0x30
   12db2:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
   12db4:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   12db8:	862b      	strh	r3, [r5, #48]	; 0x30
   12dba:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
   12dbc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   12dc0:	862b      	strh	r3, [r5, #48]	; 0x30
   12dc2:	9803      	ldr	r0, [sp, #12]
   12dc4:	f7ff fc8c 	bl	126e0 <am_hal_interrupt_master_set>
   12dc8:	6825      	ldr	r5, [r4, #0]
   12dca:	4b36      	ldr	r3, [pc, #216]	; (12ea4 <am_hal_uart_configure+0x1ec>)
   12dcc:	f025 457e 	bic.w	r5, r5, #4261412864	; 0xfe000000
   12dd0:	429d      	cmp	r5, r3
   12dd2:	d005      	beq.n	12de0 <am_hal_uart_configure+0x128>
   12dd4:	2000      	movs	r0, #0
   12dd6:	e7b7      	b.n	12d48 <am_hal_uart_configure+0x90>
   12dd8:	2300      	movs	r3, #0
   12dda:	6623      	str	r3, [r4, #96]	; 0x60
   12ddc:	483b      	ldr	r0, [pc, #236]	; (12ecc <am_hal_uart_configure+0x214>)
   12dde:	e7b3      	b.n	12d48 <am_hal_uart_configure+0x90>
   12de0:	69b1      	ldr	r1, [r6, #24]
   12de2:	6a37      	ldr	r7, [r6, #32]
   12de4:	f8d6 8024 	ldr.w	r8, [r6, #36]	; 0x24
   12de8:	b109      	cbz	r1, 12dee <am_hal_uart_configure+0x136>
   12dea:	69f3      	ldr	r3, [r6, #28]
   12dec:	bb3b      	cbnz	r3, 12e3e <am_hal_uart_configure+0x186>
   12dee:	6a63      	ldr	r3, [r4, #36]	; 0x24
   12df0:	f503 2380 	add.w	r3, r3, #262144	; 0x40000
   12df4:	f103 021c 	add.w	r2, r3, #28
   12df8:	0312      	lsls	r2, r2, #12
   12dfa:	2100      	movs	r1, #0
   12dfc:	f884 1028 	strb.w	r1, [r4, #40]	; 0x28
   12e00:	6b91      	ldr	r1, [r2, #56]	; 0x38
   12e02:	f021 0120 	bic.w	r1, r1, #32
   12e06:	6391      	str	r1, [r2, #56]	; 0x38
   12e08:	b1b7      	cbz	r7, 12e38 <am_hal_uart_configure+0x180>
   12e0a:	f1b8 0f00 	cmp.w	r8, #0
   12e0e:	d12e      	bne.n	12e6e <am_hal_uart_configure+0x1b6>
   12e10:	6823      	ldr	r3, [r4, #0]
   12e12:	4a24      	ldr	r2, [pc, #144]	; (12ea4 <am_hal_uart_configure+0x1ec>)
   12e14:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   12e18:	2100      	movs	r1, #0
   12e1a:	4293      	cmp	r3, r2
   12e1c:	f884 1044 	strb.w	r1, [r4, #68]	; 0x44
   12e20:	d1d8      	bne.n	12dd4 <am_hal_uart_configure+0x11c>
   12e22:	6a63      	ldr	r3, [r4, #36]	; 0x24
   12e24:	f503 2380 	add.w	r3, r3, #262144	; 0x40000
   12e28:	331c      	adds	r3, #28
   12e2a:	031b      	lsls	r3, r3, #12
   12e2c:	2000      	movs	r0, #0
   12e2e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   12e30:	f022 0250 	bic.w	r2, r2, #80	; 0x50
   12e34:	639a      	str	r2, [r3, #56]	; 0x38
   12e36:	e787      	b.n	12d48 <am_hal_uart_configure+0x90>
   12e38:	f884 7044 	strb.w	r7, [r4, #68]	; 0x44
   12e3c:	e7f4      	b.n	12e28 <am_hal_uart_configure+0x170>
   12e3e:	2201      	movs	r2, #1
   12e40:	f884 2028 	strb.w	r2, [r4, #40]	; 0x28
   12e44:	f104 002c 	add.w	r0, r4, #44	; 0x2c
   12e48:	f000 fa7c 	bl	13344 <am_hal_queue_init>
   12e4c:	6823      	ldr	r3, [r4, #0]
   12e4e:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   12e52:	42ab      	cmp	r3, r5
   12e54:	d1be      	bne.n	12dd4 <am_hal_uart_configure+0x11c>
   12e56:	6a63      	ldr	r3, [r4, #36]	; 0x24
   12e58:	f503 2380 	add.w	r3, r3, #262144	; 0x40000
   12e5c:	331c      	adds	r3, #28
   12e5e:	031b      	lsls	r3, r3, #12
   12e60:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   12e62:	f042 0220 	orr.w	r2, r2, #32
   12e66:	639a      	str	r2, [r3, #56]	; 0x38
   12e68:	2f00      	cmp	r7, #0
   12e6a:	d1ce      	bne.n	12e0a <am_hal_uart_configure+0x152>
   12e6c:	e7d0      	b.n	12e10 <am_hal_uart_configure+0x158>
   12e6e:	2201      	movs	r2, #1
   12e70:	4643      	mov	r3, r8
   12e72:	f884 2044 	strb.w	r2, [r4, #68]	; 0x44
   12e76:	4639      	mov	r1, r7
   12e78:	f104 0048 	add.w	r0, r4, #72	; 0x48
   12e7c:	f000 fa62 	bl	13344 <am_hal_queue_init>
   12e80:	6823      	ldr	r3, [r4, #0]
   12e82:	4a08      	ldr	r2, [pc, #32]	; (12ea4 <am_hal_uart_configure+0x1ec>)
   12e84:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   12e88:	4293      	cmp	r3, r2
   12e8a:	d1a3      	bne.n	12dd4 <am_hal_uart_configure+0x11c>
   12e8c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   12e8e:	f503 2380 	add.w	r3, r3, #262144	; 0x40000
   12e92:	331c      	adds	r3, #28
   12e94:	031b      	lsls	r3, r3, #12
   12e96:	2000      	movs	r0, #0
   12e98:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   12e9a:	f042 0250 	orr.w	r2, r2, #80	; 0x50
   12e9e:	639a      	str	r2, [r3, #56]	; 0x38
   12ea0:	e752      	b.n	12d48 <am_hal_uart_configure+0x90>
   12ea2:	bf00      	nop
   12ea4:	01ea9e06 	.word	0x01ea9e06
   12ea8:	2dc6c000 	.word	0x2dc6c000
   12eac:	00b71b00 	.word	0x00b71b00
   12eb0:	08000003 	.word	0x08000003
   12eb4:	5b8d8000 	.word	0x5b8d8000
   12eb8:	016e3600 	.word	0x016e3600
   12ebc:	0b71b000 	.word	0x0b71b000
   12ec0:	002dc6c0 	.word	0x002dc6c0
   12ec4:	16e36000 	.word	0x16e36000
   12ec8:	005b8d80 	.word	0x005b8d80
   12ecc:	08000002 	.word	0x08000002

00012ed0 <am_hal_uart_transfer>:
   12ed0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12ed4:	680f      	ldr	r7, [r1, #0]
   12ed6:	b091      	sub	sp, #68	; 0x44
   12ed8:	4605      	mov	r5, r0
   12eda:	b13f      	cbz	r7, 12eec <am_hal_uart_transfer+0x1c>
   12edc:	2f01      	cmp	r7, #1
   12ede:	bf18      	it	ne
   12ee0:	2707      	movne	r7, #7
   12ee2:	d024      	beq.n	12f2e <am_hal_uart_transfer+0x5e>
   12ee4:	4638      	mov	r0, r7
   12ee6:	b011      	add	sp, #68	; 0x44
   12ee8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12eec:	f8d1 900c 	ldr.w	r9, [r1, #12]
   12ef0:	690b      	ldr	r3, [r1, #16]
   12ef2:	f8d1 a004 	ldr.w	sl, [r1, #4]
   12ef6:	688e      	ldr	r6, [r1, #8]
   12ef8:	9300      	str	r3, [sp, #0]
   12efa:	f1b9 0f00 	cmp.w	r9, #0
   12efe:	d031      	beq.n	12f64 <am_hal_uart_transfer+0x94>
   12f00:	2e00      	cmp	r6, #0
   12f02:	f000 819c 	beq.w	1323e <am_hal_uart_transfer+0x36e>
   12f06:	2800      	cmp	r0, #0
   12f08:	f000 8097 	beq.w	1303a <am_hal_uart_transfer+0x16a>
   12f0c:	6803      	ldr	r3, [r0, #0]
   12f0e:	4aa9      	ldr	r2, [pc, #676]	; (131b4 <am_hal_uart_transfer+0x2e4>)
   12f10:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   12f14:	4293      	cmp	r3, r2
   12f16:	f000 8092 	beq.w	1303e <am_hal_uart_transfer+0x16e>
   12f1a:	46b8      	mov	r8, r7
   12f1c:	9b00      	ldr	r3, [sp, #0]
   12f1e:	b10b      	cbz	r3, 12f24 <am_hal_uart_transfer+0x54>
   12f20:	f8c3 8000 	str.w	r8, [r3]
   12f24:	2702      	movs	r7, #2
   12f26:	4638      	mov	r0, r7
   12f28:	b011      	add	sp, #68	; 0x44
   12f2a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12f2e:	1d0b      	adds	r3, r1, #4
   12f30:	e893 0a88 	ldmia.w	r3, {r3, r7, r9, fp}
   12f34:	f1b9 0f00 	cmp.w	r9, #0
   12f38:	d043      	beq.n	12fc2 <am_hal_uart_transfer+0xf2>
   12f3a:	2f00      	cmp	r7, #0
   12f3c:	f000 8185 	beq.w	1324a <am_hal_uart_transfer+0x37a>
   12f40:	2800      	cmp	r0, #0
   12f42:	f000 80eb 	beq.w	1311c <am_hal_uart_transfer+0x24c>
   12f46:	6802      	ldr	r2, [r0, #0]
   12f48:	499a      	ldr	r1, [pc, #616]	; (131b4 <am_hal_uart_transfer+0x2e4>)
   12f4a:	f022 427e 	bic.w	r2, r2, #4261412864	; 0xfe000000
   12f4e:	428a      	cmp	r2, r1
   12f50:	f000 80e7 	beq.w	13122 <am_hal_uart_transfer+0x252>
   12f54:	2600      	movs	r6, #0
   12f56:	2702      	movs	r7, #2
   12f58:	f1bb 0f00 	cmp.w	fp, #0
   12f5c:	d0c2      	beq.n	12ee4 <am_hal_uart_transfer+0x14>
   12f5e:	f8cb 6000 	str.w	r6, [fp]
   12f62:	e7bf      	b.n	12ee4 <am_hal_uart_transfer+0x14>
   12f64:	2800      	cmp	r0, #0
   12f66:	d0dd      	beq.n	12f24 <am_hal_uart_transfer+0x54>
   12f68:	6803      	ldr	r3, [r0, #0]
   12f6a:	4a92      	ldr	r2, [pc, #584]	; (131b4 <am_hal_uart_transfer+0x2e4>)
   12f6c:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   12f70:	4293      	cmp	r3, r2
   12f72:	d1d7      	bne.n	12f24 <am_hal_uart_transfer+0x54>
   12f74:	9b00      	ldr	r3, [sp, #0]
   12f76:	b10b      	cbz	r3, 12f7c <am_hal_uart_transfer+0xac>
   12f78:	f8c3 9000 	str.w	r9, [r3]
   12f7c:	b1fe      	cbz	r6, 12fbe <am_hal_uart_transfer+0xee>
   12f7e:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
   12f82:	2b00      	cmp	r3, #0
   12f84:	f040 8165 	bne.w	13252 <am_hal_uart_transfer+0x382>
   12f88:	6a69      	ldr	r1, [r5, #36]	; 0x24
   12f8a:	f501 2180 	add.w	r1, r1, #262144	; 0x40000
   12f8e:	311c      	adds	r1, #28
   12f90:	0309      	lsls	r1, r1, #12
   12f92:	698a      	ldr	r2, [r1, #24]
   12f94:	f3c2 1240 	ubfx	r2, r2, #5, #1
   12f98:	2a00      	cmp	r2, #0
   12f9a:	f040 818d 	bne.w	132b8 <am_hal_uart_transfer+0x3e8>
   12f9e:	f10a 33ff 	add.w	r3, sl, #4294967295	; 0xffffffff
   12fa2:	e003      	b.n	12fac <am_hal_uart_transfer+0xdc>
   12fa4:	6988      	ldr	r0, [r1, #24]
   12fa6:	0680      	lsls	r0, r0, #26
   12fa8:	f100 8151 	bmi.w	1324e <am_hal_uart_transfer+0x37e>
   12fac:	3201      	adds	r2, #1
   12fae:	f813 0f01 	ldrb.w	r0, [r3, #1]!
   12fb2:	6008      	str	r0, [r1, #0]
   12fb4:	4296      	cmp	r6, r2
   12fb6:	d1f5      	bne.n	12fa4 <am_hal_uart_transfer+0xd4>
   12fb8:	9b00      	ldr	r3, [sp, #0]
   12fba:	b103      	cbz	r3, 12fbe <am_hal_uart_transfer+0xee>
   12fbc:	601e      	str	r6, [r3, #0]
   12fbe:	2700      	movs	r7, #0
   12fc0:	e790      	b.n	12ee4 <am_hal_uart_transfer+0x14>
   12fc2:	2800      	cmp	r0, #0
   12fc4:	d0ae      	beq.n	12f24 <am_hal_uart_transfer+0x54>
   12fc6:	6802      	ldr	r2, [r0, #0]
   12fc8:	497a      	ldr	r1, [pc, #488]	; (131b4 <am_hal_uart_transfer+0x2e4>)
   12fca:	f022 427e 	bic.w	r2, r2, #4261412864	; 0xfe000000
   12fce:	428a      	cmp	r2, r1
   12fd0:	d1a8      	bne.n	12f24 <am_hal_uart_transfer+0x54>
   12fd2:	f1bb 0f00 	cmp.w	fp, #0
   12fd6:	d001      	beq.n	12fdc <am_hal_uart_transfer+0x10c>
   12fd8:	f8cb 9000 	str.w	r9, [fp]
   12fdc:	2f00      	cmp	r7, #0
   12fde:	d0ee      	beq.n	12fbe <am_hal_uart_transfer+0xee>
   12fe0:	f895 4044 	ldrb.w	r4, [r5, #68]	; 0x44
   12fe4:	2c00      	cmp	r4, #0
   12fe6:	f040 816c 	bne.w	132c2 <am_hal_uart_transfer+0x3f2>
   12fea:	6a6a      	ldr	r2, [r5, #36]	; 0x24
   12fec:	f502 2280 	add.w	r2, r2, #262144	; 0x40000
   12ff0:	321c      	adds	r2, #28
   12ff2:	0312      	lsls	r2, r2, #12
   12ff4:	6990      	ldr	r0, [r2, #24]
   12ff6:	f3c0 1000 	ubfx	r0, r0, #4, #1
   12ffa:	2800      	cmp	r0, #0
   12ffc:	f040 819d 	bne.w	1333a <am_hal_uart_transfer+0x46a>
   13000:	6811      	ldr	r1, [r2, #0]
   13002:	f411 6470 	ands.w	r4, r1, #3840	; 0xf00
   13006:	bf08      	it	eq
   13008:	f103 33ff 	addeq.w	r3, r3, #4294967295	; 0xffffffff
   1300c:	d008      	beq.n	13020 <am_hal_uart_transfer+0x150>
   1300e:	e190      	b.n	13332 <am_hal_uart_transfer+0x462>
   13010:	6991      	ldr	r1, [r2, #24]
   13012:	06c8      	lsls	r0, r1, #27
   13014:	d409      	bmi.n	1302a <am_hal_uart_transfer+0x15a>
   13016:	6811      	ldr	r1, [r2, #0]
   13018:	f411 6f70 	tst.w	r1, #3840	; 0xf00
   1301c:	f040 814e 	bne.w	132bc <am_hal_uart_transfer+0x3ec>
   13020:	3401      	adds	r4, #1
   13022:	42a7      	cmp	r7, r4
   13024:	f803 1f01 	strb.w	r1, [r3, #1]!
   13028:	d1f2      	bne.n	13010 <am_hal_uart_transfer+0x140>
   1302a:	2700      	movs	r7, #0
   1302c:	f1bb 0f00 	cmp.w	fp, #0
   13030:	f43f af58 	beq.w	12ee4 <am_hal_uart_transfer+0x14>
   13034:	f8cb 4000 	str.w	r4, [fp]
   13038:	e754      	b.n	12ee4 <am_hal_uart_transfer+0x14>
   1303a:	4680      	mov	r8, r0
   1303c:	e76e      	b.n	12f1c <am_hal_uart_transfer+0x4c>
   1303e:	9301      	str	r3, [sp, #4]
   13040:	4651      	mov	r1, sl
   13042:	46bb      	mov	fp, r7
   13044:	46b8      	mov	r8, r7
   13046:	f895 2028 	ldrb.w	r2, [r5, #40]	; 0x28
   1304a:	b9f2      	cbnz	r2, 1308a <am_hal_uart_transfer+0x1ba>
   1304c:	6a6a      	ldr	r2, [r5, #36]	; 0x24
   1304e:	b19e      	cbz	r6, 13078 <am_hal_uart_transfer+0x1a8>
   13050:	f502 2280 	add.w	r2, r2, #262144	; 0x40000
   13054:	321c      	adds	r2, #28
   13056:	0312      	lsls	r2, r2, #12
   13058:	3901      	subs	r1, #1
   1305a:	6994      	ldr	r4, [r2, #24]
   1305c:	f3c4 1440 	ubfx	r4, r4, #5, #1
   13060:	b11c      	cbz	r4, 1306a <am_hal_uart_transfer+0x19a>
   13062:	e047      	b.n	130f4 <am_hal_uart_transfer+0x224>
   13064:	6993      	ldr	r3, [r2, #24]
   13066:	069b      	lsls	r3, r3, #26
   13068:	d441      	bmi.n	130ee <am_hal_uart_transfer+0x21e>
   1306a:	3401      	adds	r4, #1
   1306c:	f811 3f01 	ldrb.w	r3, [r1, #1]!
   13070:	6013      	str	r3, [r2, #0]
   13072:	42b4      	cmp	r4, r6
   13074:	d1f6      	bne.n	13064 <am_hal_uart_transfer+0x194>
   13076:	44a0      	add	r8, r4
   13078:	9b00      	ldr	r3, [sp, #0]
   1307a:	2b00      	cmp	r3, #0
   1307c:	d09f      	beq.n	12fbe <am_hal_uart_transfer+0xee>
   1307e:	4638      	mov	r0, r7
   13080:	f8c3 8000 	str.w	r8, [r3]
   13084:	b011      	add	sp, #68	; 0x44
   13086:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1308a:	6baa      	ldr	r2, [r5, #56]	; 0x38
   1308c:	6b6c      	ldr	r4, [r5, #52]	; 0x34
   1308e:	1b14      	subs	r4, r2, r4
   13090:	42b4      	cmp	r4, r6
   13092:	f105 032c 	add.w	r3, r5, #44	; 0x2c
   13096:	bf28      	it	cs
   13098:	4634      	movcs	r4, r6
   1309a:	4622      	mov	r2, r4
   1309c:	4618      	mov	r0, r3
   1309e:	9302      	str	r3, [sp, #8]
   130a0:	f000 f95c 	bl	1335c <am_hal_queue_item_add>
   130a4:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   130a6:	9303      	str	r3, [sp, #12]
   130a8:	f7ff fb16 	bl	126d8 <am_hal_interrupt_master_disable>
   130ac:	9b03      	ldr	r3, [sp, #12]
   130ae:	9008      	str	r0, [sp, #32]
   130b0:	f503 2380 	add.w	r3, r3, #262144	; 0x40000
   130b4:	331c      	adds	r3, #28
   130b6:	031b      	lsls	r3, r3, #12
   130b8:	9303      	str	r3, [sp, #12]
   130ba:	e00d      	b.n	130d8 <am_hal_uart_transfer+0x208>
   130bc:	f000 f986 	bl	133cc <am_hal_queue_item_get>
   130c0:	b190      	cbz	r0, 130e8 <am_hal_uart_transfer+0x218>
   130c2:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   130c4:	f503 2380 	add.w	r3, r3, #262144	; 0x40000
   130c8:	331c      	adds	r3, #28
   130ca:	031b      	lsls	r3, r3, #12
   130cc:	699a      	ldr	r2, [r3, #24]
   130ce:	0692      	lsls	r2, r2, #26
   130d0:	bf5c      	itt	pl
   130d2:	f89d 201c 	ldrbpl.w	r2, [sp, #28]
   130d6:	601a      	strpl	r2, [r3, #0]
   130d8:	9b03      	ldr	r3, [sp, #12]
   130da:	9802      	ldr	r0, [sp, #8]
   130dc:	699b      	ldr	r3, [r3, #24]
   130de:	069b      	lsls	r3, r3, #26
   130e0:	f04f 0201 	mov.w	r2, #1
   130e4:	a907      	add	r1, sp, #28
   130e6:	d5e9      	bpl.n	130bc <am_hal_uart_transfer+0x1ec>
   130e8:	9808      	ldr	r0, [sp, #32]
   130ea:	f7ff faf9 	bl	126e0 <am_hal_interrupt_master_set>
   130ee:	1b36      	subs	r6, r6, r4
   130f0:	44a0      	add	r8, r4
   130f2:	d0c1      	beq.n	13078 <am_hal_uart_transfer+0x1a8>
   130f4:	2001      	movs	r0, #1
   130f6:	f7ff fabb 	bl	12670 <am_hal_flash_delay>
   130fa:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
   130fe:	d001      	beq.n	13104 <am_hal_uart_transfer+0x234>
   13100:	f10b 0b01 	add.w	fp, fp, #1
   13104:	45d9      	cmp	r9, fp
   13106:	d9b7      	bls.n	13078 <am_hal_uart_transfer+0x1a8>
   13108:	682a      	ldr	r2, [r5, #0]
   1310a:	9b01      	ldr	r3, [sp, #4]
   1310c:	f022 427e 	bic.w	r2, r2, #4261412864	; 0xfe000000
   13110:	429a      	cmp	r2, r3
   13112:	eb0a 0108 	add.w	r1, sl, r8
   13116:	f47f af01 	bne.w	12f1c <am_hal_uart_transfer+0x4c>
   1311a:	e794      	b.n	13046 <am_hal_uart_transfer+0x176>
   1311c:	4606      	mov	r6, r0
   1311e:	2702      	movs	r7, #2
   13120:	e71a      	b.n	12f58 <am_hal_uart_transfer+0x88>
   13122:	9200      	str	r2, [sp, #0]
   13124:	f100 0248 	add.w	r2, r0, #72	; 0x48
   13128:	f04f 0a00 	mov.w	sl, #0
   1312c:	9202      	str	r2, [sp, #8]
   1312e:	465a      	mov	r2, fp
   13130:	4698      	mov	r8, r3
   13132:	469b      	mov	fp, r3
   13134:	4656      	mov	r6, sl
   13136:	4613      	mov	r3, r2
   13138:	f895 2044 	ldrb.w	r2, [r5, #68]	; 0x44
   1313c:	2a00      	cmp	r2, #0
   1313e:	d152      	bne.n	131e6 <am_hal_uart_transfer+0x316>
   13140:	6a69      	ldr	r1, [r5, #36]	; 0x24
   13142:	b3a7      	cbz	r7, 131ae <am_hal_uart_transfer+0x2de>
   13144:	f501 2180 	add.w	r1, r1, #262144	; 0x40000
   13148:	311c      	adds	r1, #28
   1314a:	0309      	lsls	r1, r1, #12
   1314c:	698a      	ldr	r2, [r1, #24]
   1314e:	06d0      	lsls	r0, r2, #27
   13150:	d432      	bmi.n	131b8 <am_hal_uart_transfer+0x2e8>
   13152:	680a      	ldr	r2, [r1, #0]
   13154:	f412 6470 	ands.w	r4, r2, #3840	; 0xf00
   13158:	f040 80aa 	bne.w	132b0 <am_hal_uart_transfer+0x3e0>
   1315c:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
   13160:	e006      	b.n	13170 <am_hal_uart_transfer+0x2a0>
   13162:	698a      	ldr	r2, [r1, #24]
   13164:	06d2      	lsls	r2, r2, #27
   13166:	d41f      	bmi.n	131a8 <am_hal_uart_transfer+0x2d8>
   13168:	680a      	ldr	r2, [r1, #0]
   1316a:	f412 6f70 	tst.w	r2, #3840	; 0xf00
   1316e:	d161      	bne.n	13234 <am_hal_uart_transfer+0x364>
   13170:	3401      	adds	r4, #1
   13172:	42bc      	cmp	r4, r7
   13174:	f808 2f01 	strb.w	r2, [r8, #1]!
   13178:	d1f3      	bne.n	13162 <am_hal_uart_transfer+0x292>
   1317a:	469b      	mov	fp, r3
   1317c:	4426      	add	r6, r4
   1317e:	f1bb 0f00 	cmp.w	fp, #0
   13182:	f43f af1c 	beq.w	12fbe <am_hal_uart_transfer+0xee>
   13186:	f8cb 6000 	str.w	r6, [fp]
   1318a:	2700      	movs	r7, #0
   1318c:	e6aa      	b.n	12ee4 <am_hal_uart_transfer+0x14>
   1318e:	9807      	ldr	r0, [sp, #28]
   13190:	f7ff faa6 	bl	126e0 <am_hal_interrupt_master_set>
   13194:	6d2c      	ldr	r4, [r5, #80]	; 0x50
   13196:	9802      	ldr	r0, [sp, #8]
   13198:	42bc      	cmp	r4, r7
   1319a:	bf28      	it	cs
   1319c:	463c      	movcs	r4, r7
   1319e:	4641      	mov	r1, r8
   131a0:	4622      	mov	r2, r4
   131a2:	f000 f913 	bl	133cc <am_hal_queue_item_get>
   131a6:	9b01      	ldr	r3, [sp, #4]
   131a8:	1b3f      	subs	r7, r7, r4
   131aa:	4426      	add	r6, r4
   131ac:	d104      	bne.n	131b8 <am_hal_uart_transfer+0x2e8>
   131ae:	469b      	mov	fp, r3
   131b0:	e7e5      	b.n	1317e <am_hal_uart_transfer+0x2ae>
   131b2:	bf00      	nop
   131b4:	01ea9e06 	.word	0x01ea9e06
   131b8:	2001      	movs	r0, #1
   131ba:	9301      	str	r3, [sp, #4]
   131bc:	f7ff fa58 	bl	12670 <am_hal_flash_delay>
   131c0:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
   131c4:	9b01      	ldr	r3, [sp, #4]
   131c6:	d001      	beq.n	131cc <am_hal_uart_transfer+0x2fc>
   131c8:	f10a 0a01 	add.w	sl, sl, #1
   131cc:	45d1      	cmp	r9, sl
   131ce:	d9ee      	bls.n	131ae <am_hal_uart_transfer+0x2de>
   131d0:	682a      	ldr	r2, [r5, #0]
   131d2:	9900      	ldr	r1, [sp, #0]
   131d4:	f022 427e 	bic.w	r2, r2, #4261412864	; 0xfe000000
   131d8:	428a      	cmp	r2, r1
   131da:	eb0b 0806 	add.w	r8, fp, r6
   131de:	d0ab      	beq.n	13138 <am_hal_uart_transfer+0x268>
   131e0:	469b      	mov	fp, r3
   131e2:	2702      	movs	r7, #2
   131e4:	e6b8      	b.n	12f58 <am_hal_uart_transfer+0x88>
   131e6:	9301      	str	r3, [sp, #4]
   131e8:	f7ff fa76 	bl	126d8 <am_hal_interrupt_master_disable>
   131ec:	6a6a      	ldr	r2, [r5, #36]	; 0x24
   131ee:	9007      	str	r0, [sp, #28]
   131f0:	f502 2080 	add.w	r0, r2, #262144	; 0x40000
   131f4:	301c      	adds	r0, #28
   131f6:	9b01      	ldr	r3, [sp, #4]
   131f8:	0300      	lsls	r0, r0, #12
   131fa:	ac08      	add	r4, sp, #32
   131fc:	2200      	movs	r2, #0
   131fe:	6981      	ldr	r1, [r0, #24]
   13200:	06c9      	lsls	r1, r1, #27
   13202:	d409      	bmi.n	13218 <am_hal_uart_transfer+0x348>
   13204:	6801      	ldr	r1, [r0, #0]
   13206:	f411 6f70 	tst.w	r1, #3840	; 0xf00
   1320a:	f102 0201 	add.w	r2, r2, #1
   1320e:	d118      	bne.n	13242 <am_hal_uart_transfer+0x372>
   13210:	2a20      	cmp	r2, #32
   13212:	f804 1b01 	strb.w	r1, [r4], #1
   13216:	d1f2      	bne.n	131fe <am_hal_uart_transfer+0x32e>
   13218:	a908      	add	r1, sp, #32
   1321a:	9802      	ldr	r0, [sp, #8]
   1321c:	9301      	str	r3, [sp, #4]
   1321e:	f000 f89d 	bl	1335c <am_hal_queue_item_add>
   13222:	9b01      	ldr	r3, [sp, #4]
   13224:	2800      	cmp	r0, #0
   13226:	d1b2      	bne.n	1318e <am_hal_uart_transfer+0x2be>
   13228:	4f45      	ldr	r7, [pc, #276]	; (13340 <am_hal_uart_transfer+0x470>)
   1322a:	469b      	mov	fp, r3
   1322c:	9807      	ldr	r0, [sp, #28]
   1322e:	f7ff fa57 	bl	126e0 <am_hal_interrupt_master_set>
   13232:	e691      	b.n	12f58 <am_hal_uart_transfer+0x88>
   13234:	469b      	mov	fp, r3
   13236:	4426      	add	r6, r4
   13238:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
   1323c:	e68c      	b.n	12f58 <am_hal_uart_transfer+0x88>
   1323e:	46b8      	mov	r8, r7
   13240:	e71a      	b.n	13078 <am_hal_uart_transfer+0x1a8>
   13242:	469b      	mov	fp, r3
   13244:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
   13248:	e7f0      	b.n	1322c <am_hal_uart_transfer+0x35c>
   1324a:	463e      	mov	r6, r7
   1324c:	e797      	b.n	1317e <am_hal_uart_transfer+0x2ae>
   1324e:	4616      	mov	r6, r2
   13250:	e6b2      	b.n	12fb8 <am_hal_uart_transfer+0xe8>
   13252:	6b6a      	ldr	r2, [r5, #52]	; 0x34
   13254:	6bab      	ldr	r3, [r5, #56]	; 0x38
   13256:	1a9b      	subs	r3, r3, r2
   13258:	429e      	cmp	r6, r3
   1325a:	bf28      	it	cs
   1325c:	461e      	movcs	r6, r3
   1325e:	f105 042c 	add.w	r4, r5, #44	; 0x2c
   13262:	4651      	mov	r1, sl
   13264:	4632      	mov	r2, r6
   13266:	4620      	mov	r0, r4
   13268:	f000 f878 	bl	1335c <am_hal_queue_item_add>
   1326c:	6a6f      	ldr	r7, [r5, #36]	; 0x24
   1326e:	f7ff fa33 	bl	126d8 <am_hal_interrupt_master_disable>
   13272:	f507 2780 	add.w	r7, r7, #262144	; 0x40000
   13276:	371c      	adds	r7, #28
   13278:	033f      	lsls	r7, r7, #12
   1327a:	9005      	str	r0, [sp, #20]
   1327c:	e00d      	b.n	1329a <am_hal_uart_transfer+0x3ca>
   1327e:	f000 f8a5 	bl	133cc <am_hal_queue_item_get>
   13282:	b188      	cbz	r0, 132a8 <am_hal_uart_transfer+0x3d8>
   13284:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   13286:	f503 2380 	add.w	r3, r3, #262144	; 0x40000
   1328a:	331c      	adds	r3, #28
   1328c:	031b      	lsls	r3, r3, #12
   1328e:	699a      	ldr	r2, [r3, #24]
   13290:	0692      	lsls	r2, r2, #26
   13292:	bf5c      	itt	pl
   13294:	f89d 2020 	ldrbpl.w	r2, [sp, #32]
   13298:	601a      	strpl	r2, [r3, #0]
   1329a:	69bb      	ldr	r3, [r7, #24]
   1329c:	069b      	lsls	r3, r3, #26
   1329e:	f04f 0201 	mov.w	r2, #1
   132a2:	a908      	add	r1, sp, #32
   132a4:	4620      	mov	r0, r4
   132a6:	d5ea      	bpl.n	1327e <am_hal_uart_transfer+0x3ae>
   132a8:	9805      	ldr	r0, [sp, #20]
   132aa:	f7ff fa19 	bl	126e0 <am_hal_interrupt_master_set>
   132ae:	e683      	b.n	12fb8 <am_hal_uart_transfer+0xe8>
   132b0:	469b      	mov	fp, r3
   132b2:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
   132b6:	e64f      	b.n	12f58 <am_hal_uart_transfer+0x88>
   132b8:	461e      	mov	r6, r3
   132ba:	e67d      	b.n	12fb8 <am_hal_uart_transfer+0xe8>
   132bc:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
   132c0:	e6b4      	b.n	1302c <am_hal_uart_transfer+0x15c>
   132c2:	9300      	str	r3, [sp, #0]
   132c4:	f7ff fa08 	bl	126d8 <am_hal_interrupt_master_disable>
   132c8:	6a6a      	ldr	r2, [r5, #36]	; 0x24
   132ca:	9006      	str	r0, [sp, #24]
   132cc:	f502 2280 	add.w	r2, r2, #262144	; 0x40000
   132d0:	321c      	adds	r2, #28
   132d2:	0311      	lsls	r1, r2, #12
   132d4:	a808      	add	r0, sp, #32
   132d6:	2200      	movs	r2, #0
   132d8:	9b00      	ldr	r3, [sp, #0]
   132da:	e009      	b.n	132f0 <am_hal_uart_transfer+0x420>
   132dc:	680c      	ldr	r4, [r1, #0]
   132de:	f414 6f70 	tst.w	r4, #3840	; 0xf00
   132e2:	f102 0201 	add.w	r2, r2, #1
   132e6:	d121      	bne.n	1332c <am_hal_uart_transfer+0x45c>
   132e8:	2a20      	cmp	r2, #32
   132ea:	f800 4b01 	strb.w	r4, [r0], #1
   132ee:	d002      	beq.n	132f6 <am_hal_uart_transfer+0x426>
   132f0:	698c      	ldr	r4, [r1, #24]
   132f2:	06e4      	lsls	r4, r4, #27
   132f4:	d5f2      	bpl.n	132dc <am_hal_uart_transfer+0x40c>
   132f6:	f105 0648 	add.w	r6, r5, #72	; 0x48
   132fa:	a908      	add	r1, sp, #32
   132fc:	4630      	mov	r0, r6
   132fe:	9300      	str	r3, [sp, #0]
   13300:	f000 f82c 	bl	1335c <am_hal_queue_item_add>
   13304:	b920      	cbnz	r0, 13310 <am_hal_uart_transfer+0x440>
   13306:	4f0e      	ldr	r7, [pc, #56]	; (13340 <am_hal_uart_transfer+0x470>)
   13308:	9806      	ldr	r0, [sp, #24]
   1330a:	f7ff f9e9 	bl	126e0 <am_hal_interrupt_master_set>
   1330e:	e5e9      	b.n	12ee4 <am_hal_uart_transfer+0x14>
   13310:	9806      	ldr	r0, [sp, #24]
   13312:	f7ff f9e5 	bl	126e0 <am_hal_interrupt_master_set>
   13316:	6d2c      	ldr	r4, [r5, #80]	; 0x50
   13318:	9b00      	ldr	r3, [sp, #0]
   1331a:	42bc      	cmp	r4, r7
   1331c:	bf28      	it	cs
   1331e:	463c      	movcs	r4, r7
   13320:	4619      	mov	r1, r3
   13322:	4630      	mov	r0, r6
   13324:	4622      	mov	r2, r4
   13326:	f000 f851 	bl	133cc <am_hal_queue_item_get>
   1332a:	e67e      	b.n	1302a <am_hal_uart_transfer+0x15a>
   1332c:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
   13330:	e7ea      	b.n	13308 <am_hal_uart_transfer+0x438>
   13332:	4604      	mov	r4, r0
   13334:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
   13338:	e678      	b.n	1302c <am_hal_uart_transfer+0x15c>
   1333a:	4627      	mov	r7, r4
   1333c:	e676      	b.n	1302c <am_hal_uart_transfer+0x15c>
   1333e:	bf00      	nop
   13340:	08000001 	.word	0x08000001

00013344 <am_hal_queue_init>:
   13344:	b410      	push	{r4}
   13346:	2400      	movs	r4, #0
   13348:	6004      	str	r4, [r0, #0]
   1334a:	6044      	str	r4, [r0, #4]
   1334c:	6084      	str	r4, [r0, #8]
   1334e:	60c3      	str	r3, [r0, #12]
   13350:	6102      	str	r2, [r0, #16]
   13352:	6141      	str	r1, [r0, #20]
   13354:	f85d 4b04 	ldr.w	r4, [sp], #4
   13358:	4770      	bx	lr
   1335a:	bf00      	nop

0001335c <am_hal_queue_item_add>:
   1335c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1335e:	4604      	mov	r4, r0
   13360:	6906      	ldr	r6, [r0, #16]
   13362:	b083      	sub	sp, #12
   13364:	fb06 f602 	mul.w	r6, r6, r2
   13368:	460d      	mov	r5, r1
   1336a:	f7ff f9b5 	bl	126d8 <am_hal_interrupt_master_disable>
   1336e:	68e7      	ldr	r7, [r4, #12]
   13370:	68a2      	ldr	r2, [r4, #8]
   13372:	9001      	str	r0, [sp, #4]
   13374:	1abb      	subs	r3, r7, r2
   13376:	429e      	cmp	r6, r3
   13378:	d826      	bhi.n	133c8 <am_hal_queue_item_add+0x6c>
   1337a:	b196      	cbz	r6, 133a2 <am_hal_queue_item_add+0x46>
   1337c:	6823      	ldr	r3, [r4, #0]
   1337e:	4629      	mov	r1, r5
   13380:	b1c5      	cbz	r5, 133b4 <am_hal_queue_item_add+0x58>
   13382:	19af      	adds	r7, r5, r6
   13384:	6962      	ldr	r2, [r4, #20]
   13386:	f811 0b01 	ldrb.w	r0, [r1], #1
   1338a:	54d0      	strb	r0, [r2, r3]
   1338c:	6823      	ldr	r3, [r4, #0]
   1338e:	68e5      	ldr	r5, [r4, #12]
   13390:	3301      	adds	r3, #1
   13392:	42b9      	cmp	r1, r7
   13394:	fbb3 f0f5 	udiv	r0, r3, r5
   13398:	fb05 3310 	mls	r3, r5, r0, r3
   1339c:	6023      	str	r3, [r4, #0]
   1339e:	d1f1      	bne.n	13384 <am_hal_queue_item_add+0x28>
   133a0:	68a2      	ldr	r2, [r4, #8]
   133a2:	4432      	add	r2, r6
   133a4:	60a2      	str	r2, [r4, #8]
   133a6:	2401      	movs	r4, #1
   133a8:	9801      	ldr	r0, [sp, #4]
   133aa:	f7ff f999 	bl	126e0 <am_hal_interrupt_master_set>
   133ae:	4620      	mov	r0, r4
   133b0:	b003      	add	sp, #12
   133b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   133b4:	3101      	adds	r1, #1
   133b6:	3301      	adds	r3, #1
   133b8:	428e      	cmp	r6, r1
   133ba:	fbb3 f0f7 	udiv	r0, r3, r7
   133be:	fb07 3310 	mls	r3, r7, r0, r3
   133c2:	d1f7      	bne.n	133b4 <am_hal_queue_item_add+0x58>
   133c4:	6023      	str	r3, [r4, #0]
   133c6:	e7ec      	b.n	133a2 <am_hal_queue_item_add+0x46>
   133c8:	2400      	movs	r4, #0
   133ca:	e7ed      	b.n	133a8 <am_hal_queue_item_add+0x4c>

000133cc <am_hal_queue_item_get>:
   133cc:	b5f0      	push	{r4, r5, r6, r7, lr}
   133ce:	4604      	mov	r4, r0
   133d0:	6906      	ldr	r6, [r0, #16]
   133d2:	b083      	sub	sp, #12
   133d4:	fb06 f602 	mul.w	r6, r6, r2
   133d8:	460d      	mov	r5, r1
   133da:	f7ff f97d 	bl	126d8 <am_hal_interrupt_master_disable>
   133de:	68a2      	ldr	r2, [r4, #8]
   133e0:	9001      	str	r0, [sp, #4]
   133e2:	4296      	cmp	r6, r2
   133e4:	d81c      	bhi.n	13420 <am_hal_queue_item_get+0x54>
   133e6:	b196      	cbz	r6, 1340e <am_hal_queue_item_get+0x42>
   133e8:	6863      	ldr	r3, [r4, #4]
   133ea:	b1dd      	cbz	r5, 13424 <am_hal_queue_item_get+0x58>
   133ec:	4629      	mov	r1, r5
   133ee:	19af      	adds	r7, r5, r6
   133f0:	6962      	ldr	r2, [r4, #20]
   133f2:	5cd3      	ldrb	r3, [r2, r3]
   133f4:	f801 3b01 	strb.w	r3, [r1], #1
   133f8:	6863      	ldr	r3, [r4, #4]
   133fa:	68e5      	ldr	r5, [r4, #12]
   133fc:	3301      	adds	r3, #1
   133fe:	428f      	cmp	r7, r1
   13400:	fbb3 f0f5 	udiv	r0, r3, r5
   13404:	fb05 3310 	mls	r3, r5, r0, r3
   13408:	6063      	str	r3, [r4, #4]
   1340a:	d1f1      	bne.n	133f0 <am_hal_queue_item_get+0x24>
   1340c:	68a2      	ldr	r2, [r4, #8]
   1340e:	1b92      	subs	r2, r2, r6
   13410:	60a2      	str	r2, [r4, #8]
   13412:	2401      	movs	r4, #1
   13414:	9801      	ldr	r0, [sp, #4]
   13416:	f7ff f963 	bl	126e0 <am_hal_interrupt_master_set>
   1341a:	4620      	mov	r0, r4
   1341c:	b003      	add	sp, #12
   1341e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   13420:	2400      	movs	r4, #0
   13422:	e7f7      	b.n	13414 <am_hal_queue_item_get+0x48>
   13424:	68e0      	ldr	r0, [r4, #12]
   13426:	4629      	mov	r1, r5
   13428:	3101      	adds	r1, #1
   1342a:	3301      	adds	r3, #1
   1342c:	428e      	cmp	r6, r1
   1342e:	fbb3 f5f0 	udiv	r5, r3, r0
   13432:	fb00 3315 	mls	r3, r0, r5, r3
   13436:	d1f7      	bne.n	13428 <am_hal_queue_item_get+0x5c>
   13438:	6063      	str	r3, [r4, #4]
   1343a:	e7e8      	b.n	1340e <am_hal_queue_item_get+0x42>

0001343c <memcmp>:
   1343c:	2a03      	cmp	r2, #3
   1343e:	b470      	push	{r4, r5, r6}
   13440:	d914      	bls.n	1346c <memcmp+0x30>
   13442:	ea40 0501 	orr.w	r5, r0, r1
   13446:	07ad      	lsls	r5, r5, #30
   13448:	4604      	mov	r4, r0
   1344a:	460b      	mov	r3, r1
   1344c:	d122      	bne.n	13494 <memcmp+0x58>
   1344e:	681d      	ldr	r5, [r3, #0]
   13450:	6826      	ldr	r6, [r4, #0]
   13452:	42ae      	cmp	r6, r5
   13454:	4619      	mov	r1, r3
   13456:	4620      	mov	r0, r4
   13458:	f103 0304 	add.w	r3, r3, #4
   1345c:	f104 0404 	add.w	r4, r4, #4
   13460:	d118      	bne.n	13494 <memcmp+0x58>
   13462:	3a04      	subs	r2, #4
   13464:	2a03      	cmp	r2, #3
   13466:	4620      	mov	r0, r4
   13468:	4619      	mov	r1, r3
   1346a:	d8f0      	bhi.n	1344e <memcmp+0x12>
   1346c:	1e54      	subs	r4, r2, #1
   1346e:	b172      	cbz	r2, 1348e <memcmp+0x52>
   13470:	7802      	ldrb	r2, [r0, #0]
   13472:	780b      	ldrb	r3, [r1, #0]
   13474:	429a      	cmp	r2, r3
   13476:	bf08      	it	eq
   13478:	1864      	addeq	r4, r4, r1
   1347a:	d006      	beq.n	1348a <memcmp+0x4e>
   1347c:	e00c      	b.n	13498 <memcmp+0x5c>
   1347e:	f810 2f01 	ldrb.w	r2, [r0, #1]!
   13482:	f811 3f01 	ldrb.w	r3, [r1, #1]!
   13486:	429a      	cmp	r2, r3
   13488:	d106      	bne.n	13498 <memcmp+0x5c>
   1348a:	42a1      	cmp	r1, r4
   1348c:	d1f7      	bne.n	1347e <memcmp+0x42>
   1348e:	2000      	movs	r0, #0
   13490:	bc70      	pop	{r4, r5, r6}
   13492:	4770      	bx	lr
   13494:	1e54      	subs	r4, r2, #1
   13496:	e7eb      	b.n	13470 <memcmp+0x34>
   13498:	1ad0      	subs	r0, r2, r3
   1349a:	bc70      	pop	{r4, r5, r6}
   1349c:	4770      	bx	lr
   1349e:	bf00      	nop

000134a0 <memset>:
   134a0:	b4f0      	push	{r4, r5, r6, r7}
   134a2:	0786      	lsls	r6, r0, #30
   134a4:	d043      	beq.n	1352e <memset+0x8e>
   134a6:	1e54      	subs	r4, r2, #1
   134a8:	2a00      	cmp	r2, #0
   134aa:	d03e      	beq.n	1352a <memset+0x8a>
   134ac:	b2ca      	uxtb	r2, r1
   134ae:	4603      	mov	r3, r0
   134b0:	e002      	b.n	134b8 <memset+0x18>
   134b2:	f114 34ff 	adds.w	r4, r4, #4294967295	; 0xffffffff
   134b6:	d338      	bcc.n	1352a <memset+0x8a>
   134b8:	f803 2b01 	strb.w	r2, [r3], #1
   134bc:	079d      	lsls	r5, r3, #30
   134be:	d1f8      	bne.n	134b2 <memset+0x12>
   134c0:	2c03      	cmp	r4, #3
   134c2:	d92b      	bls.n	1351c <memset+0x7c>
   134c4:	b2cd      	uxtb	r5, r1
   134c6:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
   134ca:	2c0f      	cmp	r4, #15
   134cc:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
   134d0:	d916      	bls.n	13500 <memset+0x60>
   134d2:	f1a4 0710 	sub.w	r7, r4, #16
   134d6:	093f      	lsrs	r7, r7, #4
   134d8:	f103 0620 	add.w	r6, r3, #32
   134dc:	eb06 1607 	add.w	r6, r6, r7, lsl #4
   134e0:	f103 0210 	add.w	r2, r3, #16
   134e4:	e942 5504 	strd	r5, r5, [r2, #-16]
   134e8:	e942 5502 	strd	r5, r5, [r2, #-8]
   134ec:	3210      	adds	r2, #16
   134ee:	42b2      	cmp	r2, r6
   134f0:	d1f8      	bne.n	134e4 <memset+0x44>
   134f2:	f004 040f 	and.w	r4, r4, #15
   134f6:	3701      	adds	r7, #1
   134f8:	2c03      	cmp	r4, #3
   134fa:	eb03 1307 	add.w	r3, r3, r7, lsl #4
   134fe:	d90d      	bls.n	1351c <memset+0x7c>
   13500:	461e      	mov	r6, r3
   13502:	4622      	mov	r2, r4
   13504:	3a04      	subs	r2, #4
   13506:	2a03      	cmp	r2, #3
   13508:	f846 5b04 	str.w	r5, [r6], #4
   1350c:	d8fa      	bhi.n	13504 <memset+0x64>
   1350e:	1f22      	subs	r2, r4, #4
   13510:	f022 0203 	bic.w	r2, r2, #3
   13514:	3204      	adds	r2, #4
   13516:	4413      	add	r3, r2
   13518:	f004 0403 	and.w	r4, r4, #3
   1351c:	b12c      	cbz	r4, 1352a <memset+0x8a>
   1351e:	b2c9      	uxtb	r1, r1
   13520:	441c      	add	r4, r3
   13522:	f803 1b01 	strb.w	r1, [r3], #1
   13526:	429c      	cmp	r4, r3
   13528:	d1fb      	bne.n	13522 <memset+0x82>
   1352a:	bcf0      	pop	{r4, r5, r6, r7}
   1352c:	4770      	bx	lr
   1352e:	4614      	mov	r4, r2
   13530:	4603      	mov	r3, r0
   13532:	e7c5      	b.n	134c0 <memset+0x20>
   13534:	65657246 	.word	0x65657246
   13538:	534f5452 	.word	0x534f5452
   1353c:	61747320 	.word	0x61747320
   13540:	74207372 	.word	0x74207372
   13544:	706f206f 	.word	0x706f206f
   13548:	74617265 	.word	0x74617265
   1354c:	0a0d2165 	.word	0x0a0d2165
   13550:	00000000 	.word	0x00000000
   13554:	454c4449 	.word	0x454c4449
   13558:	00000000 	.word	0x00000000
   1355c:	20726d54 	.word	0x20726d54
   13560:	00637653 	.word	0x00637653

00013564 <g_AM_HAL_GPIO_DISABLE>:
   13564:	00000003                                ....

00013568 <g_AM_HAL_GPIO_OUTPUT>:
   13568:	00000403                                ....

0001356c <g_AM_HAL_GPIO_TRISTATE>:
   1356c:	00000c03                                ....

00013570 <g_ui8Bit76Capabilities>:
   13570:	02800101 80010180 80800101 80808080     ................
   13580:	80808080 80808008 01800180 80808080     ................
   13590:	80808080 01800402 01010401 80808080     ................
   135a0:	00000101                                ....

000135a4 <g_ui8Inpen>:
   135a4:	e2242323 100723a1 e1004303 3561a151     ##$..#...C..Q.a5
   135b4:	4181c525 d160b001 31a13130 1100f101     %..A..`.01.1....
   135c4:	01d121b1 300511e5 31301037 40006100     .!.....07.01.a.@
   135d4:	00003130                                01..

000135d8 <g_ui8NCEtable>:
   135d8:	13524232 60221202 21534333 20504030     2BR..."`3CS!0@P 
   135e8:	11514131 ffffffff ffffffff 60514131     1AQ.........1AQ`
   135f8:	00504030 23534333 60524232 30201000     0@P.3CS#2BR`.. 0
   13608:	61504030 01514131 42221202 60231303     0@Pa1AQ..."B..#`
   13618:	50201000 41211101 32221202 60331303     .. P..!A.."2..3`
   13628:	21514131 22524232 03534333 40201000     1AQ!2BR"3CS... @
   13638:	51211101 02524232 13534333 10504030     ..!Q2BR.3CS.0@P.
   13648:	60514131 12524232 03534333 40201000     1AQ`2BR.3CS... @
   13658:	61211101 52221202 33231303 30201000     ..!a.."R..#3.. 0
   13668:	61514131 02524232 53331303 ffffffff     1AQa2BR...3S....
   13678:	ffffffff 61211101 50201000 61211101     ......!a.. P..!a
   13688:	52221202 13534333 61504030 31211101     .."R3CS.0@Pa..!1
   13698:	32221202 43231303                       .."2..#C

000136a0 <g_ui8nCEpins>:
   136a0:	02070707 00080802 01020202 01010101     ................
   136b0:	01010101 01010101 01010101 01010101     ................
   136c0:	01010101 08010101 01010008 01010101     ................
   136d0:	00000101 6d726554 6c616e69 00000000     ....Terminal....
   136e0:	00545452 47474553 00005245 56737953     RTT.SEGGER..SysV
   136f0:	00776569                                iew.

000136f4 <_abSync>:
	...
   13700:	54535953 49564d45 203a5745 6c756f43     SYSTEMVIEW: Coul
   13710:	6f6e2064 65722074 64726f63 73617420     d not record tas
   13720:	6e69206b 6d726f66 6f697461 4d202e6e     k information. M
   13730:	6d697861 6e206d75 65626d75 666f2072     aximum number of
   13740:	73617420 7220736b 68636165 002e6465      tasks reached..

00013750 <SYSVIEW_X_OS_TraceAPI>:
   13750:	00011f75 00011f35 72463d4e 54526565     u...5...N=FreeRT
   13760:	4420534f 206f6d65 6c707041 74616369     OS Demo Applicat
   13770:	2c6e6f69 6f433d44 78657472 2c344d2d     ion,D=Cortex-M4,
   13780:	72463d4f 54526565 0000534f 35312349     O=FreeRTOS..I#15
   13790:	7379533d 6b636954 00000000 72616548     =SysTick....Hear
   137a0:	61654274 00000074 5f64656c 69646e69     tBeat...led_indi
   137b0:	6f746163 00000072 74747562 725f6e6f     cator...button_r
   137c0:	6f707365 7265736e 00000000 6c6f7041     esponser....Apol
   137d0:	20336f6c 73727542 6f4d2074 69206564     lo3 Burst Mode i
   137e0:	76412073 616c6961 0d656c62 0000000a     s Available.....
   137f0:	6c6f7041 20336f6c 73727542 6f4d2074     Apollo3 Burst Mo
   13800:	69206564 6f4e2073 76412074 616c6961     de is Not Availa
   13810:	0d656c62 0000000a 6c696146 74206465     ble.....Failed t
   13820:	6e49206f 61697469 657a696c 726f6620     o Initialize for
   13830:	72754220 4d207473 2065646f 7265706f      Burst Mode oper
   13840:	6f697461 000a0d6e                       ation...

00013848 <g_AP3EVB_button0>:
   13848:	00001003                                ....

0001384c <g_sBspUartConfig>:
   1384c:	0001c200 00000060 00000000 00000000     ....`...........
   1385c:	00000000 00000012 00000000 00000000     ................
	...

00013874 <g_AM_BSP_GPIO_COM_UART_TX>:
   13874:	00000000                                ....

00013878 <g_AM_BSP_GPIO_COM_UART_RX>:
   13878:	00000000                                ....

0001387c <am_hal_cachectrl_defaults>:
   1387c:	00000308                                ....

00013880 <g_am_hal_mcuctrl_flash_size>:
   13880:	00004000 00008000 00010000 00020000     .@..............
   13890:	00040000 00080000 00100000 00200000     .............. .
	...

000138c0 <g_am_hal_mcuctrl_sram_size>:
   138c0:	00004000 00008000 00010000 00020000     .@..............
   138d0:	00040000 00080000 00100000 00060000     ................
	...

00013900 <am_hal_pwrctrl_peripheral_control>:
	...
   1390c:	00000001 00000004 00000004 00000002     ................
   1391c:	00000008 00000008 00000004 00000008     ................
   1392c:	00000008 00000008 00000008 00000008     ................
   1393c:	00000010 00000010 00000010 00000020     ............ ...
   1394c:	00000010 00000010 00000040 00000010     ........@.......
   1395c:	00000010 00000080 00000004 00000004     ................
   1396c:	00000100 00000004 00000004 00000200     ................
   1397c:	00000020 00000020 00000400 00000004      ... ...........
   1398c:	00000004 00000800 00000040 00000040     ........@...@...
   1399c:	00001000 00000080 00000080 00002000     ............. ..
   139ac:	00000100 00000100                       ........
