
bin/rtos_audio_experiment_platform.axf:     file format elf32-littlearm


Disassembly of section .text:

0000c000 <g_am_pfnVectors>:
    c000:	00 2b 00 10 35 25 01 00 2d 25 01 00 f1 ea 00 00     .+..5%..-%......
    c010:	f1 ea 00 00 f1 ea 00 00 f1 ea 00 00 00 00 00 00     ................
	...
    c02c:	71 df 00 00 31 25 01 00 00 00 00 00 e1 df 00 00     q...1%..........
    c03c:	45 e0 00 00 31 25 01 00 31 25 01 00 31 25 01 00     E...1%..1%..1%..
    c04c:	31 25 01 00 31 25 01 00 31 25 01 00 31 25 01 00     1%..1%..1%..1%..
    c05c:	31 25 01 00 31 25 01 00 31 25 01 00 31 25 01 00     1%..1%..1%..1%..
    c06c:	31 25 01 00 31 25 01 00 c9 24 01 00 31 25 01 00     1%..1%...$..1%..
    c07c:	31 25 01 00 31 25 01 00 31 25 01 00 31 25 01 00     1%..1%..1%..1%..
    c08c:	59 24 01 00 31 25 01 00 31 25 01 00 31 25 01 00     Y$..1%..1%..1%..
    c09c:	6d e1 00 00 31 25 01 00 31 25 01 00 31 25 01 00     m...1%..1%..1%..
    c0ac:	31 25 01 00 31 25 01 00 31 25 01 00 31 25 01 00     1%..1%..1%..1%..
    c0bc:	31 25 01 00                                         1%..

0000c0c0 <__Patchable>:
	...

0000c100 <memcpy>:
    c100:	4684      	mov	ip, r0
    c102:	ea41 0300 	orr.w	r3, r1, r0
    c106:	f013 0303 	ands.w	r3, r3, #3
    c10a:	d16d      	bne.n	c1e8 <memcpy+0xe8>
    c10c:	3a40      	subs	r2, #64	; 0x40
    c10e:	d341      	bcc.n	c194 <memcpy+0x94>
    c110:	f851 3b04 	ldr.w	r3, [r1], #4
    c114:	f840 3b04 	str.w	r3, [r0], #4
    c118:	f851 3b04 	ldr.w	r3, [r1], #4
    c11c:	f840 3b04 	str.w	r3, [r0], #4
    c120:	f851 3b04 	ldr.w	r3, [r1], #4
    c124:	f840 3b04 	str.w	r3, [r0], #4
    c128:	f851 3b04 	ldr.w	r3, [r1], #4
    c12c:	f840 3b04 	str.w	r3, [r0], #4
    c130:	f851 3b04 	ldr.w	r3, [r1], #4
    c134:	f840 3b04 	str.w	r3, [r0], #4
    c138:	f851 3b04 	ldr.w	r3, [r1], #4
    c13c:	f840 3b04 	str.w	r3, [r0], #4
    c140:	f851 3b04 	ldr.w	r3, [r1], #4
    c144:	f840 3b04 	str.w	r3, [r0], #4
    c148:	f851 3b04 	ldr.w	r3, [r1], #4
    c14c:	f840 3b04 	str.w	r3, [r0], #4
    c150:	f851 3b04 	ldr.w	r3, [r1], #4
    c154:	f840 3b04 	str.w	r3, [r0], #4
    c158:	f851 3b04 	ldr.w	r3, [r1], #4
    c15c:	f840 3b04 	str.w	r3, [r0], #4
    c160:	f851 3b04 	ldr.w	r3, [r1], #4
    c164:	f840 3b04 	str.w	r3, [r0], #4
    c168:	f851 3b04 	ldr.w	r3, [r1], #4
    c16c:	f840 3b04 	str.w	r3, [r0], #4
    c170:	f851 3b04 	ldr.w	r3, [r1], #4
    c174:	f840 3b04 	str.w	r3, [r0], #4
    c178:	f851 3b04 	ldr.w	r3, [r1], #4
    c17c:	f840 3b04 	str.w	r3, [r0], #4
    c180:	f851 3b04 	ldr.w	r3, [r1], #4
    c184:	f840 3b04 	str.w	r3, [r0], #4
    c188:	f851 3b04 	ldr.w	r3, [r1], #4
    c18c:	f840 3b04 	str.w	r3, [r0], #4
    c190:	3a40      	subs	r2, #64	; 0x40
    c192:	d2bd      	bcs.n	c110 <memcpy+0x10>
    c194:	3230      	adds	r2, #48	; 0x30
    c196:	d311      	bcc.n	c1bc <memcpy+0xbc>
    c198:	f851 3b04 	ldr.w	r3, [r1], #4
    c19c:	f840 3b04 	str.w	r3, [r0], #4
    c1a0:	f851 3b04 	ldr.w	r3, [r1], #4
    c1a4:	f840 3b04 	str.w	r3, [r0], #4
    c1a8:	f851 3b04 	ldr.w	r3, [r1], #4
    c1ac:	f840 3b04 	str.w	r3, [r0], #4
    c1b0:	f851 3b04 	ldr.w	r3, [r1], #4
    c1b4:	f840 3b04 	str.w	r3, [r0], #4
    c1b8:	3a10      	subs	r2, #16
    c1ba:	d2ed      	bcs.n	c198 <memcpy+0x98>
    c1bc:	320c      	adds	r2, #12
    c1be:	d305      	bcc.n	c1cc <memcpy+0xcc>
    c1c0:	f851 3b04 	ldr.w	r3, [r1], #4
    c1c4:	f840 3b04 	str.w	r3, [r0], #4
    c1c8:	3a04      	subs	r2, #4
    c1ca:	d2f9      	bcs.n	c1c0 <memcpy+0xc0>
    c1cc:	3204      	adds	r2, #4
    c1ce:	d008      	beq.n	c1e2 <memcpy+0xe2>
    c1d0:	07d2      	lsls	r2, r2, #31
    c1d2:	bf1c      	itt	ne
    c1d4:	f811 3b01 	ldrbne.w	r3, [r1], #1
    c1d8:	f800 3b01 	strbne.w	r3, [r0], #1
    c1dc:	d301      	bcc.n	c1e2 <memcpy+0xe2>
    c1de:	880b      	ldrh	r3, [r1, #0]
    c1e0:	8003      	strh	r3, [r0, #0]
    c1e2:	4660      	mov	r0, ip
    c1e4:	4770      	bx	lr
    c1e6:	bf00      	nop
    c1e8:	2a08      	cmp	r2, #8
    c1ea:	d313      	bcc.n	c214 <memcpy+0x114>
    c1ec:	078b      	lsls	r3, r1, #30
    c1ee:	d08d      	beq.n	c10c <memcpy+0xc>
    c1f0:	f010 0303 	ands.w	r3, r0, #3
    c1f4:	d08a      	beq.n	c10c <memcpy+0xc>
    c1f6:	f1c3 0304 	rsb	r3, r3, #4
    c1fa:	1ad2      	subs	r2, r2, r3
    c1fc:	07db      	lsls	r3, r3, #31
    c1fe:	bf1c      	itt	ne
    c200:	f811 3b01 	ldrbne.w	r3, [r1], #1
    c204:	f800 3b01 	strbne.w	r3, [r0], #1
    c208:	d380      	bcc.n	c10c <memcpy+0xc>
    c20a:	f831 3b02 	ldrh.w	r3, [r1], #2
    c20e:	f820 3b02 	strh.w	r3, [r0], #2
    c212:	e77b      	b.n	c10c <memcpy+0xc>
    c214:	3a04      	subs	r2, #4
    c216:	d3d9      	bcc.n	c1cc <memcpy+0xcc>
    c218:	3a01      	subs	r2, #1
    c21a:	f811 3b01 	ldrb.w	r3, [r1], #1
    c21e:	f800 3b01 	strb.w	r3, [r0], #1
    c222:	d2f9      	bcs.n	c218 <memcpy+0x118>
    c224:	780b      	ldrb	r3, [r1, #0]
    c226:	7003      	strb	r3, [r0, #0]
    c228:	784b      	ldrb	r3, [r1, #1]
    c22a:	7043      	strb	r3, [r0, #1]
    c22c:	788b      	ldrb	r3, [r1, #2]
    c22e:	7083      	strb	r3, [r0, #2]
    c230:	4660      	mov	r0, ip
    c232:	4770      	bx	lr

0000c234 <__aeabi_d2f>:
    c234:	ea4f 0241 	mov.w	r2, r1, lsl #1
    c238:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
    c23c:	bf24      	itt	cs
    c23e:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
    c242:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
    c246:	d90d      	bls.n	c264 <__aeabi_d2f+0x30>
    c248:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    c24c:	ea4f 02c0 	mov.w	r2, r0, lsl #3
    c250:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
    c254:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
    c258:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
    c25c:	bf08      	it	eq
    c25e:	f020 0001 	biceq.w	r0, r0, #1
    c262:	4770      	bx	lr
    c264:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
    c268:	d121      	bne.n	c2ae <__aeabi_d2f+0x7a>
    c26a:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
    c26e:	bfbc      	itt	lt
    c270:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
    c274:	4770      	bxlt	lr
    c276:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    c27a:	ea4f 5252 	mov.w	r2, r2, lsr #21
    c27e:	f1c2 0218 	rsb	r2, r2, #24
    c282:	f1c2 0c20 	rsb	ip, r2, #32
    c286:	fa10 f30c 	lsls.w	r3, r0, ip
    c28a:	fa20 f002 	lsr.w	r0, r0, r2
    c28e:	bf18      	it	ne
    c290:	f040 0001 	orrne.w	r0, r0, #1
    c294:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    c298:	ea4f 23d3 	mov.w	r3, r3, lsr #11
    c29c:	fa03 fc0c 	lsl.w	ip, r3, ip
    c2a0:	ea40 000c 	orr.w	r0, r0, ip
    c2a4:	fa23 f302 	lsr.w	r3, r3, r2
    c2a8:	ea4f 0343 	mov.w	r3, r3, lsl #1
    c2ac:	e7cc      	b.n	c248 <__aeabi_d2f+0x14>
    c2ae:	ea7f 5362 	mvns.w	r3, r2, asr #21
    c2b2:	d107      	bne.n	c2c4 <__aeabi_d2f+0x90>
    c2b4:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
    c2b8:	bf1e      	ittt	ne
    c2ba:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
    c2be:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
    c2c2:	4770      	bxne	lr
    c2c4:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
    c2c8:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    c2cc:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    c2d0:	4770      	bx	lr
    c2d2:	bf00      	nop

0000c2d4 <main>:
int main()
{
    //
    // Set the clock frequency
    //
    am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_SYSCLK_MAX, 0);
    c2d4:	2100      	movs	r1, #0
{
    c2d6:	b508      	push	{r3, lr}
    am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_SYSCLK_MAX, 0);
    c2d8:	4608      	mov	r0, r1
    c2da:	f006 fa8d 	bl	127f8 <am_hal_clkgen_control>

    //
    // Set the default cache configuration
    //
    am_hal_cachectrl_config(&am_hal_cachectrl_defaults);
    c2de:	480b      	ldr	r0, [pc, #44]	; (c30c <main+0x38>)
    c2e0:	f006 fa56 	bl	12790 <am_hal_cachectrl_config>
    am_hal_cachectrl_enable();
    c2e4:	f006 fa7e 	bl	127e4 <am_hal_cachectrl_enable>

    //
    // Configure the board for low power.
    //
    am_bsp_low_power_init();
    c2e8:	f006 f97c 	bl	125e4 <am_bsp_low_power_init>
  
    //
    // clear stimer configuration, it may cause exception if retain old value.
    //   
    am_hal_stimer_config(0x03);
    c2ec:	2003      	movs	r0, #3
    c2ee:	f006 fceb 	bl	12cc8 <am_hal_stimer_config>


    //
    // Hardware initialization here
    //
    am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_XTAL_START, 0);
    c2f2:	2100      	movs	r1, #0
    c2f4:	2001      	movs	r0, #1
    c2f6:	f006 fa7f 	bl	127f8 <am_hal_clkgen_control>


    am_AEP_init();
    c2fa:	f005 ff47 	bl	1218c <am_AEP_init>
    //
    SEGGER_SYSVIEW_Conf();

#endif

    am_util_stdio_printf("FreeRTOS stars to operate!\r\n");
    c2fe:	4804      	ldr	r0, [pc, #16]	; (c310 <main+0x3c>)
    c300:	f003 fb3e 	bl	f980 <am_util_stdio_printf>
    //
    // Start the scheduler.
    //
    vTaskStartScheduler();
    c304:	f000 fe62 	bl	cfcc <vTaskStartScheduler>

  return 0;
}
    c308:	2000      	movs	r0, #0
    c30a:	bd08      	pop	{r3, pc}
    c30c:	00013b08 	.word	0x00013b08
    c310:	000137d0 	.word	0x000137d0

0000c314 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    c314:	f100 0308 	add.w	r3, r0, #8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    c318:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    c31c:	2200      	movs	r2, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    c31e:	6081      	str	r1, [r0, #8]
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    c320:	e9c0 2300 	strd	r2, r3, [r0]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    c324:	e9c0 3303 	strd	r3, r3, [r0, #12]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    c328:	4770      	bx	lr
    c32a:	bf00      	nop

0000c32c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    c32c:	2300      	movs	r3, #0
    c32e:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    c330:	4770      	bx	lr
    c332:	bf00      	nop

0000c334 <vListInsertEnd>:
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
    c334:	e9d0 2300 	ldrd	r2, r3, [r0]
{
    c338:	b410      	push	{r4}
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    c33a:	689c      	ldr	r4, [r3, #8]
    c33c:	608c      	str	r4, [r1, #8]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    c33e:	689c      	ldr	r4, [r3, #8]
	pxNewListItem->pxNext = pxIndex;
    c340:	604b      	str	r3, [r1, #4]
	( pxList->uxNumberOfItems )++;
    c342:	3201      	adds	r2, #1
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    c344:	6061      	str	r1, [r4, #4]
	pxIndex->pxPrevious = pxNewListItem;
    c346:	6099      	str	r1, [r3, #8]
}
    c348:	f85d 4b04 	ldr.w	r4, [sp], #4
	pxNewListItem->pvContainer = ( void * ) pxList;
    c34c:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
    c34e:	6002      	str	r2, [r0, #0]
}
    c350:	4770      	bx	lr
    c352:	bf00      	nop

0000c354 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    c354:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    c356:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    c358:	1c6b      	adds	r3, r5, #1
    c35a:	d011      	beq.n	c380 <vListInsert+0x2c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    c35c:	f100 0208 	add.w	r2, r0, #8
    c360:	e000      	b.n	c364 <vListInsert+0x10>
    c362:	461a      	mov	r2, r3
    c364:	6853      	ldr	r3, [r2, #4]
    c366:	681c      	ldr	r4, [r3, #0]
    c368:	42ac      	cmp	r4, r5
    c36a:	d9fa      	bls.n	c362 <vListInsert+0xe>

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
    c36c:	6804      	ldr	r4, [r0, #0]
	pxNewListItem->pxNext = pxIterator->pxNext;
    c36e:	604b      	str	r3, [r1, #4]
	( pxList->uxNumberOfItems )++;
    c370:	3401      	adds	r4, #1
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    c372:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
    c374:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
    c376:	6051      	str	r1, [r2, #4]
	pxNewListItem->pvContainer = ( void * ) pxList;
    c378:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
    c37a:	6004      	str	r4, [r0, #0]
}
    c37c:	bc30      	pop	{r4, r5}
    c37e:	4770      	bx	lr
		pxIterator = pxList->xListEnd.pxPrevious;
    c380:	6902      	ldr	r2, [r0, #16]
    c382:	6853      	ldr	r3, [r2, #4]
    c384:	e7f2      	b.n	c36c <vListInsert+0x18>
    c386:	bf00      	nop

0000c388 <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    c388:	6843      	ldr	r3, [r0, #4]
    c38a:	6881      	ldr	r1, [r0, #8]
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    c38c:	6902      	ldr	r2, [r0, #16]
{
    c38e:	b410      	push	{r4}
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    c390:	6099      	str	r1, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    c392:	6881      	ldr	r1, [r0, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    c394:	6854      	ldr	r4, [r2, #4]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    c396:	604b      	str	r3, [r1, #4]
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
	( pxList->uxNumberOfItems )--;
    c398:	6813      	ldr	r3, [r2, #0]
	if( pxList->pxIndex == pxItemToRemove )
    c39a:	4284      	cmp	r4, r0
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    c39c:	bf08      	it	eq
    c39e:	6051      	streq	r1, [r2, #4]
	( pxList->uxNumberOfItems )--;
    c3a0:	3b01      	subs	r3, #1
	pxItemToRemove->pvContainer = NULL;
    c3a2:	2100      	movs	r1, #0
    c3a4:	6101      	str	r1, [r0, #16]

	return pxList->uxNumberOfItems;
}
    c3a6:	f85d 4b04 	ldr.w	r4, [sp], #4
	( pxList->uxNumberOfItems )--;
    c3aa:	6013      	str	r3, [r2, #0]
}
    c3ac:	4618      	mov	r0, r3
    c3ae:	4770      	bx	lr

0000c3b0 <xQueueGenericCreate>:
	{
	Queue_t *pxNewQueue;
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
    c3b0:	b3b0      	cbz	r0, c420 <xQueueGenericCreate+0x70>
	{
    c3b2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c3b4:	4606      	mov	r6, r0
    c3b6:	4617      	mov	r7, r2
    c3b8:	460d      	mov	r5, r1

		if( uxItemSize == ( UBaseType_t ) 0 )
    c3ba:	b391      	cbz	r1, c422 <xQueueGenericCreate+0x72>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    c3bc:	fb01 f000 	mul.w	r0, r1, r0
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    c3c0:	3048      	adds	r0, #72	; 0x48
    c3c2:	f001 fce7 	bl	dd94 <pvPortMalloc>

		if( pxNewQueue != NULL )
    c3c6:	4604      	mov	r4, r0
    c3c8:	b380      	cbz	r0, c42c <xQueueGenericCreate+0x7c>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
    c3ca:	f100 0348 	add.w	r3, r0, #72	; 0x48
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    c3ce:	6003      	str	r3, [r0, #0]
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
	pxNewQueue->uxItemSize = uxItemSize;
    c3d0:	e9c4 650f 	strd	r6, r5, [r4, #60]	; 0x3c
	taskENTER_CRITICAL();
    c3d4:	f001 fdde 	bl	df94 <vPortEnterCritical>
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    c3d8:	e9d4 130f 	ldrd	r1, r3, [r4, #60]	; 0x3c
    c3dc:	6822      	ldr	r2, [r4, #0]
		pxQueue->pcWriteTo = pxQueue->pcHead;
    c3de:	60a2      	str	r2, [r4, #8]
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    c3e0:	fb01 f103 	mul.w	r1, r1, r3
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    c3e4:	1acb      	subs	r3, r1, r3
    c3e6:	4413      	add	r3, r2
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    c3e8:	2000      	movs	r0, #0
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    c3ea:	440a      	add	r2, r1
		pxQueue->cRxLock = queueUNLOCKED;
    c3ec:	21ff      	movs	r1, #255	; 0xff
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    c3ee:	60e3      	str	r3, [r4, #12]
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    c3f0:	6062      	str	r2, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    c3f2:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->cRxLock = queueUNLOCKED;
    c3f4:	f884 1044 	strb.w	r1, [r4, #68]	; 0x44
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    c3f8:	f104 0010 	add.w	r0, r4, #16
		pxQueue->cTxLock = queueUNLOCKED;
    c3fc:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    c400:	f7ff ff88 	bl	c314 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    c404:	f104 0024 	add.w	r0, r4, #36	; 0x24
    c408:	f7ff ff84 	bl	c314 <vListInitialise>
	taskEXIT_CRITICAL();
    c40c:	f001 fddc 	bl	dfc8 <vPortExitCritical>
	{
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
    c410:	463b      	mov	r3, r7
    c412:	462a      	mov	r2, r5
    c414:	4631      	mov	r1, r6
    c416:	2073      	movs	r0, #115	; 0x73
    c418:	f004 ffd8 	bl	113cc <SEGGER_SYSVIEW_RecordU32x3>
	}
    c41c:	4620      	mov	r0, r4
    c41e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    c420:	e7fe      	b.n	c420 <xQueueGenericCreate+0x70>
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    c422:	2048      	movs	r0, #72	; 0x48
    c424:	f001 fcb6 	bl	dd94 <pvPortMalloc>
		if( pxNewQueue != NULL )
    c428:	4604      	mov	r4, r0
    c42a:	b910      	cbnz	r0, c432 <xQueueGenericCreate+0x82>
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    c42c:	2400      	movs	r4, #0
	}
    c42e:	4620      	mov	r0, r4
    c430:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    c432:	6024      	str	r4, [r4, #0]
    c434:	e7cc      	b.n	c3d0 <xQueueGenericCreate+0x20>
    c436:	bf00      	nop

0000c438 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    c438:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c43c:	b087      	sub	sp, #28
    c43e:	9203      	str	r2, [sp, #12]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
    c440:	b140      	cbz	r0, c454 <xQueueGenericSend+0x1c>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    c442:	2900      	cmp	r1, #0
    c444:	f000 810e 	beq.w	c664 <xQueueGenericSend+0x22c>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    c448:	2b02      	cmp	r3, #2
    c44a:	d104      	bne.n	c456 <xQueueGenericSend+0x1e>
    c44c:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
    c44e:	2a01      	cmp	r2, #1
    c450:	d001      	beq.n	c456 <xQueueGenericSend+0x1e>
    c452:	e7fe      	b.n	c452 <xQueueGenericSend+0x1a>
    c454:	e7fe      	b.n	c454 <xQueueGenericSend+0x1c>
    c456:	4604      	mov	r4, r0
    c458:	461f      	mov	r7, r3
    c45a:	460e      	mov	r6, r1
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    c45c:	f001 fa38 	bl	d8d0 <xTaskGetSchedulerState>
    c460:	2800      	cmp	r0, #0
    c462:	f040 80fc 	bne.w	c65e <xQueueGenericSend+0x226>
    c466:	9b03      	ldr	r3, [sp, #12]
    c468:	2b00      	cmp	r3, #0
    c46a:	f040 80aa 	bne.w	c5c2 <xQueueGenericSend+0x18a>
    c46e:	469a      	mov	sl, r3
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    c470:	f001 fd90 	bl	df94 <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    c474:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    c476:	6be3      	ldr	r3, [r4, #60]	; 0x3c
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
				{
					portYIELD_WITHIN_API();
    c478:	f8df 9314 	ldr.w	r9, [pc, #788]	; c790 <xQueueGenericSend+0x358>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    c47c:	429a      	cmp	r2, r3
		prvLockQueue( pxQueue );
    c47e:	f04f 0800 	mov.w	r8, #0
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    c482:	d375      	bcc.n	c570 <xQueueGenericSend+0x138>
    c484:	2f02      	cmp	r7, #2
    c486:	f000 80f2 	beq.w	c66e <xQueueGenericSend+0x236>
				if( xTicksToWait == ( TickType_t ) 0 )
    c48a:	9d03      	ldr	r5, [sp, #12]
    c48c:	2d00      	cmp	r5, #0
    c48e:	f000 8149 	beq.w	c724 <xQueueGenericSend+0x2ec>
				else if( xEntryTimeSet == pdFALSE )
    c492:	f1ba 0f00 	cmp.w	sl, #0
    c496:	d102      	bne.n	c49e <xQueueGenericSend+0x66>
					vTaskSetTimeOutState( &xTimeOut );
    c498:	a804      	add	r0, sp, #16
    c49a:	f001 f9bb 	bl	d814 <vTaskSetTimeOutState>
		taskEXIT_CRITICAL();
    c49e:	f001 fd93 	bl	dfc8 <vPortExitCritical>
		vTaskSuspendAll();
    c4a2:	f000 fe85 	bl	d1b0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    c4a6:	f001 fd75 	bl	df94 <vPortEnterCritical>
    c4aa:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    c4ae:	2bff      	cmp	r3, #255	; 0xff
    c4b0:	bf08      	it	eq
    c4b2:	f884 8044 	strbeq.w	r8, [r4, #68]	; 0x44
    c4b6:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    c4ba:	2bff      	cmp	r3, #255	; 0xff
    c4bc:	bf08      	it	eq
    c4be:	f884 8045 	strbeq.w	r8, [r4, #69]	; 0x45
    c4c2:	f001 fd81 	bl	dfc8 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    c4c6:	a903      	add	r1, sp, #12
    c4c8:	a804      	add	r0, sp, #16
    c4ca:	f001 f9b1 	bl	d830 <xTaskCheckForTimeOut>
    c4ce:	2800      	cmp	r0, #0
    c4d0:	f040 810e 	bne.w	c6f0 <xQueueGenericSend+0x2b8>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    c4d4:	f001 fd5e 	bl	df94 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    c4d8:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    c4da:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    c4dc:	429a      	cmp	r2, r3
    c4de:	d071      	beq.n	c5c4 <xQueueGenericSend+0x18c>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    c4e0:	f001 fd72 	bl	dfc8 <vPortExitCritical>
	taskENTER_CRITICAL();
    c4e4:	f001 fd56 	bl	df94 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
    c4e8:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
    c4ec:	b26d      	sxtb	r5, r5
		while( cTxLock > queueLOCKED_UNMODIFIED )
    c4ee:	2d00      	cmp	r5, #0
    c4f0:	dd11      	ble.n	c516 <xQueueGenericSend+0xde>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    c4f2:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c4f4:	b17b      	cbz	r3, c516 <xQueueGenericSend+0xde>
    c4f6:	f104 0a24 	add.w	sl, r4, #36	; 0x24
    c4fa:	e001      	b.n	c500 <xQueueGenericSend+0xc8>
    c4fc:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c4fe:	b153      	cbz	r3, c516 <xQueueGenericSend+0xde>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    c500:	4650      	mov	r0, sl
    c502:	f001 f937 	bl	d774 <xTaskRemoveFromEventList>
    c506:	b108      	cbz	r0, c50c <xQueueGenericSend+0xd4>
						vTaskMissedYield();
    c508:	f001 f9c2 	bl	d890 <vTaskMissedYield>
    c50c:	3d01      	subs	r5, #1
    c50e:	b2eb      	uxtb	r3, r5
    c510:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    c512:	2b00      	cmp	r3, #0
    c514:	d1f2      	bne.n	c4fc <xQueueGenericSend+0xc4>
		pxQueue->cTxLock = queueUNLOCKED;
    c516:	23ff      	movs	r3, #255	; 0xff
    c518:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
    c51c:	f001 fd54 	bl	dfc8 <vPortExitCritical>
	taskENTER_CRITICAL();
    c520:	f001 fd38 	bl	df94 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
    c524:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
    c528:	b26d      	sxtb	r5, r5
		while( cRxLock > queueLOCKED_UNMODIFIED )
    c52a:	2d00      	cmp	r5, #0
    c52c:	dd11      	ble.n	c552 <xQueueGenericSend+0x11a>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    c52e:	6923      	ldr	r3, [r4, #16]
    c530:	b17b      	cbz	r3, c552 <xQueueGenericSend+0x11a>
    c532:	f104 0a10 	add.w	sl, r4, #16
    c536:	e001      	b.n	c53c <xQueueGenericSend+0x104>
    c538:	6923      	ldr	r3, [r4, #16]
    c53a:	b153      	cbz	r3, c552 <xQueueGenericSend+0x11a>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    c53c:	4650      	mov	r0, sl
    c53e:	f001 f919 	bl	d774 <xTaskRemoveFromEventList>
    c542:	b108      	cbz	r0, c548 <xQueueGenericSend+0x110>
					vTaskMissedYield();
    c544:	f001 f9a4 	bl	d890 <vTaskMissedYield>
    c548:	3d01      	subs	r5, #1
    c54a:	b2eb      	uxtb	r3, r5
    c54c:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    c54e:	2b00      	cmp	r3, #0
    c550:	d1f2      	bne.n	c538 <xQueueGenericSend+0x100>
		pxQueue->cRxLock = queueUNLOCKED;
    c552:	23ff      	movs	r3, #255	; 0xff
    c554:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
    c558:	f001 fd36 	bl	dfc8 <vPortExitCritical>
				( void ) xTaskResumeAll();
    c55c:	f000 fee8 	bl	d330 <xTaskResumeAll>
		taskENTER_CRITICAL();
    c560:	f001 fd18 	bl	df94 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    c564:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    c566:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    c568:	429a      	cmp	r2, r3
    c56a:	f04f 0a01 	mov.w	sl, #1
    c56e:	d289      	bcs.n	c484 <xQueueGenericSend+0x4c>
				traceQUEUE_SEND( pxQueue );
    c570:	4620      	mov	r0, r4
    c572:	f003 febb 	bl	102ec <SEGGER_SYSVIEW_ShrinkId>
    c576:	4632      	mov	r2, r6
    c578:	4601      	mov	r1, r0
    c57a:	9b03      	ldr	r3, [sp, #12]
    c57c:	9700      	str	r7, [sp, #0]
    c57e:	205a      	movs	r0, #90	; 0x5a
    c580:	f005 fde0 	bl	12144 <SYSVIEW_RecordU32x4>
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    c584:	6c22      	ldr	r2, [r4, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    c586:	6ba5      	ldr	r5, [r4, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    c588:	b17a      	cbz	r2, c5aa <xQueueGenericSend+0x172>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    c58a:	4631      	mov	r1, r6
	else if( xPosition == queueSEND_TO_BACK )
    c58c:	2f00      	cmp	r7, #0
    c58e:	f040 80a3 	bne.w	c6d8 <xQueueGenericSend+0x2a0>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    c592:	68a0      	ldr	r0, [r4, #8]
    c594:	f7ff fdb4 	bl	c100 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    c598:	68a3      	ldr	r3, [r4, #8]
    c59a:	6c21      	ldr	r1, [r4, #64]	; 0x40
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c59c:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    c59e:	440b      	add	r3, r1
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c5a0:	4293      	cmp	r3, r2
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    c5a2:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c5a4:	d301      	bcc.n	c5aa <xQueueGenericSend+0x172>
			pxQueue->pcWriteTo = pxQueue->pcHead;
    c5a6:	6823      	ldr	r3, [r4, #0]
    c5a8:	60a3      	str	r3, [r4, #8]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    c5aa:	6a63      	ldr	r3, [r4, #36]	; 0x24
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    c5ac:	3501      	adds	r5, #1
    c5ae:	63a5      	str	r5, [r4, #56]	; 0x38
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    c5b0:	2b00      	cmp	r3, #0
    c5b2:	f040 8081 	bne.w	c6b8 <xQueueGenericSend+0x280>
				taskEXIT_CRITICAL();
    c5b6:	f001 fd07 	bl	dfc8 <vPortExitCritical>
				return pdPASS;
    c5ba:	2001      	movs	r0, #1
}
    c5bc:	b007      	add	sp, #28
    c5be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c5c2:	e7fe      	b.n	c5c2 <xQueueGenericSend+0x18a>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    c5c4:	f104 0a10 	add.w	sl, r4, #16
	taskEXIT_CRITICAL();
    c5c8:	f001 fcfe 	bl	dfc8 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    c5cc:	4650      	mov	r0, sl
    c5ce:	9903      	ldr	r1, [sp, #12]
    c5d0:	f001 f836 	bl	d640 <vTaskPlaceOnEventList>
	taskENTER_CRITICAL();
    c5d4:	f001 fcde 	bl	df94 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
    c5d8:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
    c5dc:	b26d      	sxtb	r5, r5
		while( cTxLock > queueLOCKED_UNMODIFIED )
    c5de:	2d00      	cmp	r5, #0
    c5e0:	dd11      	ble.n	c606 <xQueueGenericSend+0x1ce>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    c5e2:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c5e4:	b17b      	cbz	r3, c606 <xQueueGenericSend+0x1ce>
    c5e6:	f104 0b24 	add.w	fp, r4, #36	; 0x24
    c5ea:	e001      	b.n	c5f0 <xQueueGenericSend+0x1b8>
    c5ec:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c5ee:	b153      	cbz	r3, c606 <xQueueGenericSend+0x1ce>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    c5f0:	4658      	mov	r0, fp
    c5f2:	f001 f8bf 	bl	d774 <xTaskRemoveFromEventList>
    c5f6:	b108      	cbz	r0, c5fc <xQueueGenericSend+0x1c4>
						vTaskMissedYield();
    c5f8:	f001 f94a 	bl	d890 <vTaskMissedYield>
    c5fc:	3d01      	subs	r5, #1
    c5fe:	b2eb      	uxtb	r3, r5
    c600:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    c602:	2b00      	cmp	r3, #0
    c604:	d1f2      	bne.n	c5ec <xQueueGenericSend+0x1b4>
		pxQueue->cTxLock = queueUNLOCKED;
    c606:	23ff      	movs	r3, #255	; 0xff
    c608:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
    c60c:	f001 fcdc 	bl	dfc8 <vPortExitCritical>
	taskENTER_CRITICAL();
    c610:	f001 fcc0 	bl	df94 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
    c614:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
    c618:	b26d      	sxtb	r5, r5
		while( cRxLock > queueLOCKED_UNMODIFIED )
    c61a:	2d00      	cmp	r5, #0
    c61c:	dc0a      	bgt.n	c634 <xQueueGenericSend+0x1fc>
    c61e:	e00c      	b.n	c63a <xQueueGenericSend+0x202>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    c620:	4650      	mov	r0, sl
    c622:	f001 f8a7 	bl	d774 <xTaskRemoveFromEventList>
    c626:	b108      	cbz	r0, c62c <xQueueGenericSend+0x1f4>
					vTaskMissedYield();
    c628:	f001 f932 	bl	d890 <vTaskMissedYield>
    c62c:	3d01      	subs	r5, #1
    c62e:	b2eb      	uxtb	r3, r5
    c630:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    c632:	b113      	cbz	r3, c63a <xQueueGenericSend+0x202>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    c634:	6923      	ldr	r3, [r4, #16]
    c636:	2b00      	cmp	r3, #0
    c638:	d1f2      	bne.n	c620 <xQueueGenericSend+0x1e8>
		pxQueue->cRxLock = queueUNLOCKED;
    c63a:	23ff      	movs	r3, #255	; 0xff
    c63c:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
    c640:	f001 fcc2 	bl	dfc8 <vPortExitCritical>
				if( xTaskResumeAll() == pdFALSE )
    c644:	f000 fe74 	bl	d330 <xTaskResumeAll>
    c648:	2800      	cmp	r0, #0
    c64a:	d189      	bne.n	c560 <xQueueGenericSend+0x128>
					portYIELD_WITHIN_API();
    c64c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    c650:	f8c9 3000 	str.w	r3, [r9]
    c654:	f3bf 8f4f 	dsb	sy
    c658:	f3bf 8f6f 	isb	sy
    c65c:	e780      	b.n	c560 <xQueueGenericSend+0x128>
    c65e:	f04f 0a00 	mov.w	sl, #0
    c662:	e705      	b.n	c470 <xQueueGenericSend+0x38>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    c664:	6c02      	ldr	r2, [r0, #64]	; 0x40
    c666:	2a00      	cmp	r2, #0
    c668:	f43f aeee 	beq.w	c448 <xQueueGenericSend+0x10>
    c66c:	e7fe      	b.n	c66c <xQueueGenericSend+0x234>
				traceQUEUE_SEND( pxQueue );
    c66e:	4620      	mov	r0, r4
    c670:	f003 fe3c 	bl	102ec <SEGGER_SYSVIEW_ShrinkId>
    c674:	4632      	mov	r2, r6
    c676:	4601      	mov	r1, r0
    c678:	9700      	str	r7, [sp, #0]
    c67a:	9b03      	ldr	r3, [sp, #12]
    c67c:	205a      	movs	r0, #90	; 0x5a
    c67e:	f005 fd61 	bl	12144 <SYSVIEW_RecordU32x4>
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    c682:	6c22      	ldr	r2, [r4, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    c684:	6ba5      	ldr	r5, [r4, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    c686:	2a00      	cmp	r2, #0
    c688:	d08f      	beq.n	c5aa <xQueueGenericSend+0x172>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    c68a:	4631      	mov	r1, r6
    c68c:	68e0      	ldr	r0, [r4, #12]
    c68e:	f7ff fd37 	bl	c100 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    c692:	6c23      	ldr	r3, [r4, #64]	; 0x40
    c694:	68e2      	ldr	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c696:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    c698:	425b      	negs	r3, r3
    c69a:	441a      	add	r2, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c69c:	428a      	cmp	r2, r1
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    c69e:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c6a0:	d205      	bcs.n	c6ae <xQueueGenericSend+0x276>
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    c6a2:	6862      	ldr	r2, [r4, #4]
    c6a4:	4413      	add	r3, r2
    c6a6:	60e3      	str	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
    c6a8:	2f02      	cmp	r7, #2
    c6aa:	f47f af7e 	bne.w	c5aa <xQueueGenericSend+0x172>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    c6ae:	2d00      	cmp	r5, #0
    c6b0:	f43f af7b 	beq.w	c5aa <xQueueGenericSend+0x172>
				--uxMessagesWaiting;
    c6b4:	3d01      	subs	r5, #1
    c6b6:	e778      	b.n	c5aa <xQueueGenericSend+0x172>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    c6b8:	f104 0024 	add.w	r0, r4, #36	; 0x24
    c6bc:	f001 f85a 	bl	d774 <xTaskRemoveFromEventList>
    c6c0:	2800      	cmp	r0, #0
    c6c2:	f43f af78 	beq.w	c5b6 <xQueueGenericSend+0x17e>
							queueYIELD_IF_USING_PREEMPTION();
    c6c6:	4b32      	ldr	r3, [pc, #200]	; (c790 <xQueueGenericSend+0x358>)
    c6c8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    c6cc:	601a      	str	r2, [r3, #0]
    c6ce:	f3bf 8f4f 	dsb	sy
    c6d2:	f3bf 8f6f 	isb	sy
    c6d6:	e76e      	b.n	c5b6 <xQueueGenericSend+0x17e>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    c6d8:	68e0      	ldr	r0, [r4, #12]
    c6da:	f7ff fd11 	bl	c100 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    c6de:	6c23      	ldr	r3, [r4, #64]	; 0x40
    c6e0:	68e2      	ldr	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c6e2:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    c6e4:	425b      	negs	r3, r3
    c6e6:	441a      	add	r2, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c6e8:	428a      	cmp	r2, r1
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    c6ea:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c6ec:	d2dc      	bcs.n	c6a8 <xQueueGenericSend+0x270>
    c6ee:	e7d8      	b.n	c6a2 <xQueueGenericSend+0x26a>
	taskENTER_CRITICAL();
    c6f0:	f001 fc50 	bl	df94 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
    c6f4:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
    c6f8:	b26d      	sxtb	r5, r5
		while( cTxLock > queueLOCKED_UNMODIFIED )
    c6fa:	2d00      	cmp	r5, #0
    c6fc:	dd20      	ble.n	c740 <xQueueGenericSend+0x308>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    c6fe:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c700:	b1f3      	cbz	r3, c740 <xQueueGenericSend+0x308>
    c702:	f104 0824 	add.w	r8, r4, #36	; 0x24
    c706:	e005      	b.n	c714 <xQueueGenericSend+0x2dc>
    c708:	3d01      	subs	r5, #1
    c70a:	b2eb      	uxtb	r3, r5
    c70c:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    c70e:	b1bb      	cbz	r3, c740 <xQueueGenericSend+0x308>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    c710:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c712:	b1ab      	cbz	r3, c740 <xQueueGenericSend+0x308>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    c714:	4640      	mov	r0, r8
    c716:	f001 f82d 	bl	d774 <xTaskRemoveFromEventList>
    c71a:	2800      	cmp	r0, #0
    c71c:	d0f4      	beq.n	c708 <xQueueGenericSend+0x2d0>
						vTaskMissedYield();
    c71e:	f001 f8b7 	bl	d890 <vTaskMissedYield>
    c722:	e7f1      	b.n	c708 <xQueueGenericSend+0x2d0>
					taskEXIT_CRITICAL();
    c724:	f001 fc50 	bl	dfc8 <vPortExitCritical>
			traceQUEUE_SEND_FAILED( pxQueue );
    c728:	4620      	mov	r0, r4
    c72a:	f003 fddf 	bl	102ec <SEGGER_SYSVIEW_ShrinkId>
    c72e:	9700      	str	r7, [sp, #0]
    c730:	4601      	mov	r1, r0
    c732:	4632      	mov	r2, r6
    c734:	205a      	movs	r0, #90	; 0x5a
    c736:	9b03      	ldr	r3, [sp, #12]
    c738:	f005 fd04 	bl	12144 <SYSVIEW_RecordU32x4>
			return errQUEUE_FULL;
    c73c:	2000      	movs	r0, #0
    c73e:	e73d      	b.n	c5bc <xQueueGenericSend+0x184>
		pxQueue->cTxLock = queueUNLOCKED;
    c740:	23ff      	movs	r3, #255	; 0xff
    c742:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
    c746:	f001 fc3f 	bl	dfc8 <vPortExitCritical>
	taskENTER_CRITICAL();
    c74a:	f001 fc23 	bl	df94 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
    c74e:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
    c752:	b26d      	sxtb	r5, r5
		while( cRxLock > queueLOCKED_UNMODIFIED )
    c754:	2d00      	cmp	r5, #0
    c756:	dd12      	ble.n	c77e <xQueueGenericSend+0x346>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    c758:	6923      	ldr	r3, [r4, #16]
    c75a:	b183      	cbz	r3, c77e <xQueueGenericSend+0x346>
    c75c:	f104 0810 	add.w	r8, r4, #16
    c760:	e005      	b.n	c76e <xQueueGenericSend+0x336>
    c762:	3d01      	subs	r5, #1
    c764:	b2eb      	uxtb	r3, r5
    c766:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    c768:	b14b      	cbz	r3, c77e <xQueueGenericSend+0x346>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    c76a:	6923      	ldr	r3, [r4, #16]
    c76c:	b13b      	cbz	r3, c77e <xQueueGenericSend+0x346>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    c76e:	4640      	mov	r0, r8
    c770:	f001 f800 	bl	d774 <xTaskRemoveFromEventList>
    c774:	2800      	cmp	r0, #0
    c776:	d0f4      	beq.n	c762 <xQueueGenericSend+0x32a>
					vTaskMissedYield();
    c778:	f001 f88a 	bl	d890 <vTaskMissedYield>
    c77c:	e7f1      	b.n	c762 <xQueueGenericSend+0x32a>
		pxQueue->cRxLock = queueUNLOCKED;
    c77e:	23ff      	movs	r3, #255	; 0xff
    c780:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
    c784:	f001 fc20 	bl	dfc8 <vPortExitCritical>
			( void ) xTaskResumeAll();
    c788:	f000 fdd2 	bl	d330 <xTaskResumeAll>
    c78c:	e7cc      	b.n	c728 <xQueueGenericSend+0x2f0>
    c78e:	bf00      	nop
    c790:	e000ed04 	.word	0xe000ed04

0000c794 <xQueueGenericSendFromISR>:
	configASSERT( pxQueue );
    c794:	b148      	cbz	r0, c7aa <xQueueGenericSendFromISR+0x16>
{
    c796:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    c79a:	2900      	cmp	r1, #0
    c79c:	d039      	beq.n	c812 <xQueueGenericSendFromISR+0x7e>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    c79e:	2b02      	cmp	r3, #2
    c7a0:	d104      	bne.n	c7ac <xQueueGenericSendFromISR+0x18>
    c7a2:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
    c7a4:	2c01      	cmp	r4, #1
    c7a6:	d001      	beq.n	c7ac <xQueueGenericSendFromISR+0x18>
    c7a8:	e7fe      	b.n	c7a8 <xQueueGenericSendFromISR+0x14>
    c7aa:	e7fe      	b.n	c7aa <xQueueGenericSendFromISR+0x16>
    c7ac:	4604      	mov	r4, r0
    c7ae:	4698      	mov	r8, r3
    c7b0:	4617      	mov	r7, r2
    c7b2:	468a      	mov	sl, r1
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
    c7b4:	f001 fc66 	bl	e084 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
    c7b8:	f3ef 8911 	mrs	r9, BASEPRI
    c7bc:	f04f 0380 	mov.w	r3, #128	; 0x80
    c7c0:	f383 8811 	msr	BASEPRI, r3
    c7c4:	f3bf 8f6f 	isb	sy
    c7c8:	f3bf 8f4f 	dsb	sy
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    c7cc:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    c7ce:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    c7d0:	429a      	cmp	r2, r3
    c7d2:	d322      	bcc.n	c81a <xQueueGenericSendFromISR+0x86>
    c7d4:	f1b8 0f02 	cmp.w	r8, #2
    c7d8:	d163      	bne.n	c8a2 <xQueueGenericSendFromISR+0x10e>
			traceQUEUE_SEND_FROM_ISR( pxQueue );
    c7da:	4620      	mov	r0, r4
			const int8_t cTxLock = pxQueue->cTxLock;
    c7dc:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
			traceQUEUE_SEND_FROM_ISR( pxQueue );
    c7e0:	f003 fd84 	bl	102ec <SEGGER_SYSVIEW_ShrinkId>
    c7e4:	463a      	mov	r2, r7
    c7e6:	4601      	mov	r1, r0
    c7e8:	2060      	movs	r0, #96	; 0x60
    c7ea:	f005 fa65 	bl	11cb8 <SEGGER_SYSVIEW_RecordU32x2>
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    c7ee:	6c22      	ldr	r2, [r4, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    c7f0:	6ba6      	ldr	r6, [r4, #56]	; 0x38
			const int8_t cTxLock = pxQueue->cTxLock;
    c7f2:	b26d      	sxtb	r5, r5
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    c7f4:	2a00      	cmp	r2, #0
    c7f6:	d13e      	bne.n	c876 <xQueueGenericSendFromISR+0xe2>
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    c7f8:	3601      	adds	r6, #1
			if( cTxLock == queueUNLOCKED )
    c7fa:	1c6b      	adds	r3, r5, #1
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    c7fc:	63a6      	str	r6, [r4, #56]	; 0x38
			if( cTxLock == queueUNLOCKED )
    c7fe:	d02c      	beq.n	c85a <xQueueGenericSendFromISR+0xc6>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    c800:	1c6b      	adds	r3, r5, #1
    c802:	b25b      	sxtb	r3, r3
    c804:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
			xReturn = pdPASS;
    c808:	2001      	movs	r0, #1
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
    c80a:	f389 8811 	msr	BASEPRI, r9
}
    c80e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    c812:	6c04      	ldr	r4, [r0, #64]	; 0x40
    c814:	2c00      	cmp	r4, #0
    c816:	d0c2      	beq.n	c79e <xQueueGenericSendFromISR+0xa>
    c818:	e7fe      	b.n	c818 <xQueueGenericSendFromISR+0x84>
			traceQUEUE_SEND_FROM_ISR( pxQueue );
    c81a:	4620      	mov	r0, r4
			const int8_t cTxLock = pxQueue->cTxLock;
    c81c:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
			traceQUEUE_SEND_FROM_ISR( pxQueue );
    c820:	f003 fd64 	bl	102ec <SEGGER_SYSVIEW_ShrinkId>
    c824:	463a      	mov	r2, r7
    c826:	4601      	mov	r1, r0
    c828:	2060      	movs	r0, #96	; 0x60
    c82a:	f005 fa45 	bl	11cb8 <SEGGER_SYSVIEW_RecordU32x2>
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    c82e:	6c22      	ldr	r2, [r4, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    c830:	6ba6      	ldr	r6, [r4, #56]	; 0x38
			const int8_t cTxLock = pxQueue->cTxLock;
    c832:	b26d      	sxtb	r5, r5
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    c834:	2a00      	cmp	r2, #0
    c836:	d0df      	beq.n	c7f8 <xQueueGenericSendFromISR+0x64>
	else if( xPosition == queueSEND_TO_BACK )
    c838:	f1b8 0f00 	cmp.w	r8, #0
    c83c:	d11b      	bne.n	c876 <xQueueGenericSendFromISR+0xe2>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    c83e:	4651      	mov	r1, sl
    c840:	68a0      	ldr	r0, [r4, #8]
    c842:	f7ff fc5d 	bl	c100 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    c846:	68a3      	ldr	r3, [r4, #8]
    c848:	6c21      	ldr	r1, [r4, #64]	; 0x40
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c84a:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    c84c:	440b      	add	r3, r1
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c84e:	4293      	cmp	r3, r2
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    c850:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c852:	d3d1      	bcc.n	c7f8 <xQueueGenericSendFromISR+0x64>
			pxQueue->pcWriteTo = pxQueue->pcHead;
    c854:	6823      	ldr	r3, [r4, #0]
    c856:	60a3      	str	r3, [r4, #8]
    c858:	e7ce      	b.n	c7f8 <xQueueGenericSendFromISR+0x64>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    c85a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c85c:	2b00      	cmp	r3, #0
    c85e:	d0d3      	beq.n	c808 <xQueueGenericSendFromISR+0x74>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    c860:	f104 0024 	add.w	r0, r4, #36	; 0x24
    c864:	f000 ff86 	bl	d774 <xTaskRemoveFromEventList>
    c868:	2800      	cmp	r0, #0
    c86a:	d0cd      	beq.n	c808 <xQueueGenericSendFromISR+0x74>
							if( pxHigherPriorityTaskWoken != NULL )
    c86c:	2f00      	cmp	r7, #0
    c86e:	d0cb      	beq.n	c808 <xQueueGenericSendFromISR+0x74>
								*pxHigherPriorityTaskWoken = pdTRUE;
    c870:	2001      	movs	r0, #1
    c872:	6038      	str	r0, [r7, #0]
    c874:	e7c9      	b.n	c80a <xQueueGenericSendFromISR+0x76>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    c876:	4651      	mov	r1, sl
    c878:	68e0      	ldr	r0, [r4, #12]
    c87a:	f7ff fc41 	bl	c100 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    c87e:	6c23      	ldr	r3, [r4, #64]	; 0x40
    c880:	68e2      	ldr	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c882:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    c884:	425b      	negs	r3, r3
    c886:	441a      	add	r2, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c888:	428a      	cmp	r2, r1
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    c88a:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    c88c:	d202      	bcs.n	c894 <xQueueGenericSendFromISR+0x100>
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    c88e:	6862      	ldr	r2, [r4, #4]
    c890:	4413      	add	r3, r2
    c892:	60e3      	str	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
    c894:	f1b8 0f02 	cmp.w	r8, #2
    c898:	d1ae      	bne.n	c7f8 <xQueueGenericSendFromISR+0x64>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    c89a:	2e00      	cmp	r6, #0
    c89c:	d0ac      	beq.n	c7f8 <xQueueGenericSendFromISR+0x64>
				--uxMessagesWaiting;
    c89e:	3e01      	subs	r6, #1
    c8a0:	e7aa      	b.n	c7f8 <xQueueGenericSendFromISR+0x64>
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
    c8a2:	4620      	mov	r0, r4
    c8a4:	f003 fd22 	bl	102ec <SEGGER_SYSVIEW_ShrinkId>
    c8a8:	463a      	mov	r2, r7
    c8aa:	4601      	mov	r1, r0
    c8ac:	2060      	movs	r0, #96	; 0x60
    c8ae:	f005 fa03 	bl	11cb8 <SEGGER_SYSVIEW_RecordU32x2>
			xReturn = errQUEUE_FULL;
    c8b2:	2000      	movs	r0, #0
    c8b4:	e7a9      	b.n	c80a <xQueueGenericSendFromISR+0x76>
    c8b6:	bf00      	nop

0000c8b8 <xQueueGenericReceive>:
{
    c8b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c8bc:	b087      	sub	sp, #28
    c8be:	9203      	str	r2, [sp, #12]
	configASSERT( pxQueue );
    c8c0:	2800      	cmp	r0, #0
    c8c2:	f000 8095 	beq.w	c9f0 <xQueueGenericReceive+0x138>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    c8c6:	2900      	cmp	r1, #0
    c8c8:	f000 8152 	beq.w	cb70 <xQueueGenericReceive+0x2b8>
    c8cc:	4604      	mov	r4, r0
    c8ce:	461f      	mov	r7, r3
    c8d0:	460e      	mov	r6, r1
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    c8d2:	f000 fffd 	bl	d8d0 <xTaskGetSchedulerState>
    c8d6:	b918      	cbnz	r0, c8e0 <xQueueGenericReceive+0x28>
    c8d8:	9b03      	ldr	r3, [sp, #12]
    c8da:	2b00      	cmp	r3, #0
    c8dc:	f040 8089 	bne.w	c9f2 <xQueueGenericReceive+0x13a>
		taskENTER_CRITICAL();
    c8e0:	f001 fb58 	bl	df94 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    c8e4:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    c8e6:	2d00      	cmp	r5, #0
    c8e8:	f040 80cb 	bne.w	ca82 <xQueueGenericReceive+0x1ca>
				if( xTicksToWait == ( TickType_t ) 0 )
    c8ec:	9b03      	ldr	r3, [sp, #12]
    c8ee:	2b00      	cmp	r3, #0
    c8f0:	d06a      	beq.n	c9c8 <xQueueGenericReceive+0x110>
					vTaskSetTimeOutState( &xTimeOut );
    c8f2:	a804      	add	r0, sp, #16
    c8f4:	f000 ff8e 	bl	d814 <vTaskSetTimeOutState>
					portYIELD_WITHIN_API();
    c8f8:	f8df b2f4 	ldr.w	fp, [pc, #756]	; cbf0 <xQueueGenericReceive+0x338>
		prvLockQueue( pxQueue );
    c8fc:	46aa      	mov	sl, r5
    c8fe:	f104 0824 	add.w	r8, r4, #36	; 0x24
		taskEXIT_CRITICAL();
    c902:	f001 fb61 	bl	dfc8 <vPortExitCritical>
		vTaskSuspendAll();
    c906:	f000 fc53 	bl	d1b0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    c90a:	f001 fb43 	bl	df94 <vPortEnterCritical>
    c90e:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    c912:	2bff      	cmp	r3, #255	; 0xff
    c914:	bf08      	it	eq
    c916:	f884 a044 	strbeq.w	sl, [r4, #68]	; 0x44
    c91a:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    c91e:	2bff      	cmp	r3, #255	; 0xff
    c920:	bf08      	it	eq
    c922:	f884 a045 	strbeq.w	sl, [r4, #69]	; 0x45
    c926:	f001 fb4f 	bl	dfc8 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    c92a:	a903      	add	r1, sp, #12
    c92c:	a804      	add	r0, sp, #16
    c92e:	f000 ff7f 	bl	d830 <xTaskCheckForTimeOut>
    c932:	2800      	cmp	r0, #0
    c934:	d15e      	bne.n	c9f4 <xQueueGenericReceive+0x13c>
	taskENTER_CRITICAL();
    c936:	f001 fb2d 	bl	df94 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    c93a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    c93c:	2b00      	cmp	r3, #0
    c93e:	f000 80cc 	beq.w	cada <xQueueGenericReceive+0x222>
	taskEXIT_CRITICAL();
    c942:	f001 fb41 	bl	dfc8 <vPortExitCritical>
	taskENTER_CRITICAL();
    c946:	f001 fb25 	bl	df94 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
    c94a:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
    c94e:	b26d      	sxtb	r5, r5
		while( cTxLock > queueLOCKED_UNMODIFIED )
    c950:	2d00      	cmp	r5, #0
    c952:	dc0a      	bgt.n	c96a <xQueueGenericReceive+0xb2>
    c954:	e00c      	b.n	c970 <xQueueGenericReceive+0xb8>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    c956:	4640      	mov	r0, r8
    c958:	f000 ff0c 	bl	d774 <xTaskRemoveFromEventList>
    c95c:	b108      	cbz	r0, c962 <xQueueGenericReceive+0xaa>
						vTaskMissedYield();
    c95e:	f000 ff97 	bl	d890 <vTaskMissedYield>
    c962:	3d01      	subs	r5, #1
    c964:	b2eb      	uxtb	r3, r5
    c966:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    c968:	b113      	cbz	r3, c970 <xQueueGenericReceive+0xb8>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    c96a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c96c:	2b00      	cmp	r3, #0
    c96e:	d1f2      	bne.n	c956 <xQueueGenericReceive+0x9e>
		pxQueue->cTxLock = queueUNLOCKED;
    c970:	23ff      	movs	r3, #255	; 0xff
    c972:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
    c976:	f001 fb27 	bl	dfc8 <vPortExitCritical>
	taskENTER_CRITICAL();
    c97a:	f001 fb0b 	bl	df94 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
    c97e:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
    c982:	b26d      	sxtb	r5, r5
		while( cRxLock > queueLOCKED_UNMODIFIED )
    c984:	2d00      	cmp	r5, #0
    c986:	dd10      	ble.n	c9aa <xQueueGenericReceive+0xf2>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    c988:	6923      	ldr	r3, [r4, #16]
    c98a:	b173      	cbz	r3, c9aa <xQueueGenericReceive+0xf2>
    c98c:	f104 0910 	add.w	r9, r4, #16
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    c990:	4648      	mov	r0, r9
    c992:	f000 feef 	bl	d774 <xTaskRemoveFromEventList>
    c996:	b108      	cbz	r0, c99c <xQueueGenericReceive+0xe4>
					vTaskMissedYield();
    c998:	f000 ff7a 	bl	d890 <vTaskMissedYield>
    c99c:	3d01      	subs	r5, #1
    c99e:	b2eb      	uxtb	r3, r5
    c9a0:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    c9a2:	b113      	cbz	r3, c9aa <xQueueGenericReceive+0xf2>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    c9a4:	6923      	ldr	r3, [r4, #16]
    c9a6:	2b00      	cmp	r3, #0
    c9a8:	d1f2      	bne.n	c990 <xQueueGenericReceive+0xd8>
		pxQueue->cRxLock = queueUNLOCKED;
    c9aa:	23ff      	movs	r3, #255	; 0xff
    c9ac:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
    c9b0:	f001 fb0a 	bl	dfc8 <vPortExitCritical>
				( void ) xTaskResumeAll();
    c9b4:	f000 fcbc 	bl	d330 <xTaskResumeAll>
		taskENTER_CRITICAL();
    c9b8:	f001 faec 	bl	df94 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    c9bc:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    c9be:	2d00      	cmp	r5, #0
    c9c0:	d15f      	bne.n	ca82 <xQueueGenericReceive+0x1ca>
				if( xTicksToWait == ( TickType_t ) 0 )
    c9c2:	9b03      	ldr	r3, [sp, #12]
    c9c4:	2b00      	cmp	r3, #0
    c9c6:	d19c      	bne.n	c902 <xQueueGenericReceive+0x4a>
					taskEXIT_CRITICAL();
    c9c8:	f001 fafe 	bl	dfc8 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
    c9cc:	4620      	mov	r0, r4
    c9ce:	f003 fc8d 	bl	102ec <SEGGER_SYSVIEW_ShrinkId>
    c9d2:	4604      	mov	r4, r0
    c9d4:	4630      	mov	r0, r6
    c9d6:	f003 fc89 	bl	102ec <SEGGER_SYSVIEW_ShrinkId>
    c9da:	9b03      	ldr	r3, [sp, #12]
    c9dc:	9700      	str	r7, [sp, #0]
    c9de:	4602      	mov	r2, r0
    c9e0:	4621      	mov	r1, r4
    c9e2:	205c      	movs	r0, #92	; 0x5c
    c9e4:	f005 fbae 	bl	12144 <SYSVIEW_RecordU32x4>
					return errQUEUE_EMPTY;
    c9e8:	2000      	movs	r0, #0
}
    c9ea:	b007      	add	sp, #28
    c9ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c9f0:	e7fe      	b.n	c9f0 <xQueueGenericReceive+0x138>
    c9f2:	e7fe      	b.n	c9f2 <xQueueGenericReceive+0x13a>
	taskENTER_CRITICAL();
    c9f4:	f001 face 	bl	df94 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
    c9f8:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
    c9fc:	b26d      	sxtb	r5, r5
		while( cTxLock > queueLOCKED_UNMODIFIED )
    c9fe:	2d00      	cmp	r5, #0
    ca00:	dc0a      	bgt.n	ca18 <xQueueGenericReceive+0x160>
    ca02:	e00c      	b.n	ca1e <xQueueGenericReceive+0x166>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    ca04:	4640      	mov	r0, r8
    ca06:	f000 feb5 	bl	d774 <xTaskRemoveFromEventList>
    ca0a:	b108      	cbz	r0, ca10 <xQueueGenericReceive+0x158>
						vTaskMissedYield();
    ca0c:	f000 ff40 	bl	d890 <vTaskMissedYield>
    ca10:	3d01      	subs	r5, #1
    ca12:	b2eb      	uxtb	r3, r5
    ca14:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    ca16:	b113      	cbz	r3, ca1e <xQueueGenericReceive+0x166>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    ca18:	6a63      	ldr	r3, [r4, #36]	; 0x24
    ca1a:	2b00      	cmp	r3, #0
    ca1c:	d1f2      	bne.n	ca04 <xQueueGenericReceive+0x14c>
		pxQueue->cTxLock = queueUNLOCKED;
    ca1e:	23ff      	movs	r3, #255	; 0xff
    ca20:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
    ca24:	f001 fad0 	bl	dfc8 <vPortExitCritical>
	taskENTER_CRITICAL();
    ca28:	f001 fab4 	bl	df94 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
    ca2c:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
    ca30:	b26d      	sxtb	r5, r5
		while( cRxLock > queueLOCKED_UNMODIFIED )
    ca32:	2d00      	cmp	r5, #0
    ca34:	dd11      	ble.n	ca5a <xQueueGenericReceive+0x1a2>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    ca36:	6923      	ldr	r3, [r4, #16]
    ca38:	b17b      	cbz	r3, ca5a <xQueueGenericReceive+0x1a2>
    ca3a:	f104 0910 	add.w	r9, r4, #16
    ca3e:	e001      	b.n	ca44 <xQueueGenericReceive+0x18c>
    ca40:	6923      	ldr	r3, [r4, #16]
    ca42:	b153      	cbz	r3, ca5a <xQueueGenericReceive+0x1a2>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    ca44:	4648      	mov	r0, r9
    ca46:	f000 fe95 	bl	d774 <xTaskRemoveFromEventList>
    ca4a:	b108      	cbz	r0, ca50 <xQueueGenericReceive+0x198>
					vTaskMissedYield();
    ca4c:	f000 ff20 	bl	d890 <vTaskMissedYield>
    ca50:	3d01      	subs	r5, #1
    ca52:	b2eb      	uxtb	r3, r5
    ca54:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    ca56:	2b00      	cmp	r3, #0
    ca58:	d1f2      	bne.n	ca40 <xQueueGenericReceive+0x188>
		pxQueue->cRxLock = queueUNLOCKED;
    ca5a:	23ff      	movs	r3, #255	; 0xff
    ca5c:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
    ca60:	f001 fab2 	bl	dfc8 <vPortExitCritical>
			( void ) xTaskResumeAll();
    ca64:	f000 fc64 	bl	d330 <xTaskResumeAll>
	taskENTER_CRITICAL();
    ca68:	f001 fa94 	bl	df94 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    ca6c:	6ba5      	ldr	r5, [r4, #56]	; 0x38
    ca6e:	2d00      	cmp	r5, #0
    ca70:	f000 8083 	beq.w	cb7a <xQueueGenericReceive+0x2c2>
	taskEXIT_CRITICAL();
    ca74:	f001 faa8 	bl	dfc8 <vPortExitCritical>
		taskENTER_CRITICAL();
    ca78:	f001 fa8c 	bl	df94 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    ca7c:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    ca7e:	2d00      	cmp	r5, #0
    ca80:	d09f      	beq.n	c9c2 <xQueueGenericReceive+0x10a>
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    ca82:	6c22      	ldr	r2, [r4, #64]	; 0x40
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    ca84:	f8d4 800c 	ldr.w	r8, [r4, #12]
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    ca88:	b15a      	cbz	r2, caa2 <xQueueGenericReceive+0x1ea>
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    ca8a:	6861      	ldr	r1, [r4, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    ca8c:	eb08 0302 	add.w	r3, r8, r2
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    ca90:	428b      	cmp	r3, r1
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    ca92:	60e3      	str	r3, [r4, #12]
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    ca94:	bf24      	itt	cs
    ca96:	6823      	ldrcs	r3, [r4, #0]
    ca98:	60e3      	strcs	r3, [r4, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    ca9a:	68e1      	ldr	r1, [r4, #12]
    ca9c:	4630      	mov	r0, r6
    ca9e:	f7ff fb2f 	bl	c100 <memcpy>
					traceQUEUE_RECEIVE( pxQueue );
    caa2:	4620      	mov	r0, r4
				if( xJustPeeking == pdFALSE )
    caa4:	2f00      	cmp	r7, #0
    caa6:	d17a      	bne.n	cb9e <xQueueGenericReceive+0x2e6>
					traceQUEUE_RECEIVE( pxQueue );
    caa8:	f003 fc20 	bl	102ec <SEGGER_SYSVIEW_ShrinkId>
    caac:	4680      	mov	r8, r0
    caae:	4630      	mov	r0, r6
    cab0:	f003 fc1c 	bl	102ec <SEGGER_SYSVIEW_ShrinkId>
    cab4:	9b03      	ldr	r3, [sp, #12]
    cab6:	9700      	str	r7, [sp, #0]
    cab8:	4602      	mov	r2, r0
    caba:	4641      	mov	r1, r8
    cabc:	205c      	movs	r0, #92	; 0x5c
    cabe:	f005 fb41 	bl	12144 <SYSVIEW_RecordU32x4>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    cac2:	6923      	ldr	r3, [r4, #16]
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    cac4:	3d01      	subs	r5, #1
    cac6:	63a5      	str	r5, [r4, #56]	; 0x38
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    cac8:	2b00      	cmp	r3, #0
    caca:	f040 808a 	bne.w	cbe2 <xQueueGenericReceive+0x32a>
				taskEXIT_CRITICAL();
    cace:	f001 fa7b 	bl	dfc8 <vPortExitCritical>
				return pdPASS;
    cad2:	2001      	movs	r0, #1
}
    cad4:	b007      	add	sp, #28
    cad6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	taskEXIT_CRITICAL();
    cada:	f001 fa75 	bl	dfc8 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    cade:	9903      	ldr	r1, [sp, #12]
    cae0:	4640      	mov	r0, r8
    cae2:	f000 fdad 	bl	d640 <vTaskPlaceOnEventList>
	taskENTER_CRITICAL();
    cae6:	f001 fa55 	bl	df94 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
    caea:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
    caee:	b26d      	sxtb	r5, r5
		while( cTxLock > queueLOCKED_UNMODIFIED )
    caf0:	2d00      	cmp	r5, #0
    caf2:	dc0a      	bgt.n	cb0a <xQueueGenericReceive+0x252>
    caf4:	e00c      	b.n	cb10 <xQueueGenericReceive+0x258>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    caf6:	4640      	mov	r0, r8
    caf8:	f000 fe3c 	bl	d774 <xTaskRemoveFromEventList>
    cafc:	b108      	cbz	r0, cb02 <xQueueGenericReceive+0x24a>
						vTaskMissedYield();
    cafe:	f000 fec7 	bl	d890 <vTaskMissedYield>
    cb02:	3d01      	subs	r5, #1
    cb04:	b2eb      	uxtb	r3, r5
    cb06:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    cb08:	b113      	cbz	r3, cb10 <xQueueGenericReceive+0x258>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    cb0a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    cb0c:	2b00      	cmp	r3, #0
    cb0e:	d1f2      	bne.n	caf6 <xQueueGenericReceive+0x23e>
		pxQueue->cTxLock = queueUNLOCKED;
    cb10:	23ff      	movs	r3, #255	; 0xff
    cb12:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
    cb16:	f001 fa57 	bl	dfc8 <vPortExitCritical>
	taskENTER_CRITICAL();
    cb1a:	f001 fa3b 	bl	df94 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
    cb1e:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
    cb22:	b26d      	sxtb	r5, r5
		while( cRxLock > queueLOCKED_UNMODIFIED )
    cb24:	2d00      	cmp	r5, #0
    cb26:	dd10      	ble.n	cb4a <xQueueGenericReceive+0x292>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    cb28:	6923      	ldr	r3, [r4, #16]
    cb2a:	b173      	cbz	r3, cb4a <xQueueGenericReceive+0x292>
    cb2c:	f104 0910 	add.w	r9, r4, #16
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    cb30:	4648      	mov	r0, r9
    cb32:	f000 fe1f 	bl	d774 <xTaskRemoveFromEventList>
    cb36:	b108      	cbz	r0, cb3c <xQueueGenericReceive+0x284>
					vTaskMissedYield();
    cb38:	f000 feaa 	bl	d890 <vTaskMissedYield>
    cb3c:	3d01      	subs	r5, #1
    cb3e:	b2eb      	uxtb	r3, r5
    cb40:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    cb42:	b113      	cbz	r3, cb4a <xQueueGenericReceive+0x292>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    cb44:	6923      	ldr	r3, [r4, #16]
    cb46:	2b00      	cmp	r3, #0
    cb48:	d1f2      	bne.n	cb30 <xQueueGenericReceive+0x278>
		pxQueue->cRxLock = queueUNLOCKED;
    cb4a:	23ff      	movs	r3, #255	; 0xff
    cb4c:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
    cb50:	f001 fa3a 	bl	dfc8 <vPortExitCritical>
				if( xTaskResumeAll() == pdFALSE )
    cb54:	f000 fbec 	bl	d330 <xTaskResumeAll>
    cb58:	2800      	cmp	r0, #0
    cb5a:	f47f af2d 	bne.w	c9b8 <xQueueGenericReceive+0x100>
					portYIELD_WITHIN_API();
    cb5e:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    cb62:	f8cb 3000 	str.w	r3, [fp]
    cb66:	f3bf 8f4f 	dsb	sy
    cb6a:	f3bf 8f6f 	isb	sy
    cb6e:	e723      	b.n	c9b8 <xQueueGenericReceive+0x100>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    cb70:	6c02      	ldr	r2, [r0, #64]	; 0x40
    cb72:	2a00      	cmp	r2, #0
    cb74:	f43f aeaa 	beq.w	c8cc <xQueueGenericReceive+0x14>
    cb78:	e7fe      	b.n	cb78 <xQueueGenericReceive+0x2c0>
	taskEXIT_CRITICAL();
    cb7a:	f001 fa25 	bl	dfc8 <vPortExitCritical>
				traceQUEUE_RECEIVE_FAILED( pxQueue );
    cb7e:	4620      	mov	r0, r4
    cb80:	f003 fbb4 	bl	102ec <SEGGER_SYSVIEW_ShrinkId>
    cb84:	4604      	mov	r4, r0
    cb86:	4630      	mov	r0, r6
    cb88:	f003 fbb0 	bl	102ec <SEGGER_SYSVIEW_ShrinkId>
    cb8c:	4621      	mov	r1, r4
    cb8e:	4602      	mov	r2, r0
    cb90:	9700      	str	r7, [sp, #0]
    cb92:	205c      	movs	r0, #92	; 0x5c
    cb94:	9b03      	ldr	r3, [sp, #12]
    cb96:	f005 fad5 	bl	12144 <SYSVIEW_RecordU32x4>
				return errQUEUE_EMPTY;
    cb9a:	4628      	mov	r0, r5
    cb9c:	e725      	b.n	c9ea <xQueueGenericReceive+0x132>
					traceQUEUE_PEEK( pxQueue );
    cb9e:	f003 fba5 	bl	102ec <SEGGER_SYSVIEW_ShrinkId>
    cba2:	4605      	mov	r5, r0
    cba4:	4630      	mov	r0, r6
    cba6:	f003 fba1 	bl	102ec <SEGGER_SYSVIEW_ShrinkId>
    cbaa:	9b03      	ldr	r3, [sp, #12]
    cbac:	9700      	str	r7, [sp, #0]
    cbae:	4602      	mov	r2, r0
    cbb0:	4629      	mov	r1, r5
    cbb2:	205c      	movs	r0, #92	; 0x5c
    cbb4:	f005 fac6 	bl	12144 <SYSVIEW_RecordU32x4>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    cbb8:	6a63      	ldr	r3, [r4, #36]	; 0x24
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    cbba:	f8c4 800c 	str.w	r8, [r4, #12]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    cbbe:	2b00      	cmp	r3, #0
    cbc0:	d085      	beq.n	cace <xQueueGenericReceive+0x216>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    cbc2:	f104 0024 	add.w	r0, r4, #36	; 0x24
    cbc6:	f000 fdd5 	bl	d774 <xTaskRemoveFromEventList>
    cbca:	2800      	cmp	r0, #0
    cbcc:	f43f af7f 	beq.w	cace <xQueueGenericReceive+0x216>
							queueYIELD_IF_USING_PREEMPTION();
    cbd0:	4b07      	ldr	r3, [pc, #28]	; (cbf0 <xQueueGenericReceive+0x338>)
    cbd2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    cbd6:	601a      	str	r2, [r3, #0]
    cbd8:	f3bf 8f4f 	dsb	sy
    cbdc:	f3bf 8f6f 	isb	sy
    cbe0:	e775      	b.n	cace <xQueueGenericReceive+0x216>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    cbe2:	f104 0010 	add.w	r0, r4, #16
    cbe6:	f000 fdc5 	bl	d774 <xTaskRemoveFromEventList>
    cbea:	2800      	cmp	r0, #0
    cbec:	d1f0      	bne.n	cbd0 <xQueueGenericReceive+0x318>
    cbee:	e76e      	b.n	cace <xQueueGenericReceive+0x216>
    cbf0:	e000ed04 	.word	0xe000ed04

0000cbf4 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    cbf4:	b570      	push	{r4, r5, r6, lr}
    cbf6:	4605      	mov	r5, r0
    cbf8:	460c      	mov	r4, r1
    cbfa:	4616      	mov	r6, r2
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    cbfc:	f001 f9ca 	bl	df94 <vPortEnterCritical>
    cc00:	f895 3044 	ldrb.w	r3, [r5, #68]	; 0x44
    cc04:	2bff      	cmp	r3, #255	; 0xff
    cc06:	bf04      	itt	eq
    cc08:	2300      	moveq	r3, #0
    cc0a:	f885 3044 	strbeq.w	r3, [r5, #68]	; 0x44
    cc0e:	f895 3045 	ldrb.w	r3, [r5, #69]	; 0x45
    cc12:	2bff      	cmp	r3, #255	; 0xff
    cc14:	bf04      	itt	eq
    cc16:	2300      	moveq	r3, #0
    cc18:	f885 3045 	strbeq.w	r3, [r5, #69]	; 0x45
    cc1c:	f001 f9d4 	bl	dfc8 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    cc20:	6bab      	ldr	r3, [r5, #56]	; 0x38
    cc22:	b92b      	cbnz	r3, cc30 <vQueueWaitForMessageRestricted+0x3c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    cc24:	4632      	mov	r2, r6
    cc26:	4621      	mov	r1, r4
    cc28:	f105 0024 	add.w	r0, r5, #36	; 0x24
    cc2c:	f000 fd50 	bl	d6d0 <vTaskPlaceOnEventListRestricted>
	taskENTER_CRITICAL();
    cc30:	f001 f9b0 	bl	df94 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
    cc34:	f895 4045 	ldrb.w	r4, [r5, #69]	; 0x45
    cc38:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
    cc3a:	2c00      	cmp	r4, #0
    cc3c:	dd16      	ble.n	cc6c <vQueueWaitForMessageRestricted+0x78>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    cc3e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    cc40:	b1a3      	cbz	r3, cc6c <vQueueWaitForMessageRestricted+0x78>
    cc42:	f105 0624 	add.w	r6, r5, #36	; 0x24
    cc46:	e005      	b.n	cc54 <vQueueWaitForMessageRestricted+0x60>
    cc48:	3c01      	subs	r4, #1
    cc4a:	b2e3      	uxtb	r3, r4
    cc4c:	b25c      	sxtb	r4, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    cc4e:	b16b      	cbz	r3, cc6c <vQueueWaitForMessageRestricted+0x78>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    cc50:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    cc52:	b15b      	cbz	r3, cc6c <vQueueWaitForMessageRestricted+0x78>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    cc54:	4630      	mov	r0, r6
    cc56:	f000 fd8d 	bl	d774 <xTaskRemoveFromEventList>
    cc5a:	2800      	cmp	r0, #0
    cc5c:	d0f4      	beq.n	cc48 <vQueueWaitForMessageRestricted+0x54>
    cc5e:	3c01      	subs	r4, #1
						vTaskMissedYield();
    cc60:	f000 fe16 	bl	d890 <vTaskMissedYield>
    cc64:	b2e3      	uxtb	r3, r4
    cc66:	b25c      	sxtb	r4, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    cc68:	2b00      	cmp	r3, #0
    cc6a:	d1f1      	bne.n	cc50 <vQueueWaitForMessageRestricted+0x5c>
		pxQueue->cTxLock = queueUNLOCKED;
    cc6c:	23ff      	movs	r3, #255	; 0xff
    cc6e:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
	taskEXIT_CRITICAL();
    cc72:	f001 f9a9 	bl	dfc8 <vPortExitCritical>
	taskENTER_CRITICAL();
    cc76:	f001 f98d 	bl	df94 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
    cc7a:	f895 4044 	ldrb.w	r4, [r5, #68]	; 0x44
    cc7e:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
    cc80:	2c00      	cmp	r4, #0
    cc82:	dd16      	ble.n	ccb2 <vQueueWaitForMessageRestricted+0xbe>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    cc84:	692b      	ldr	r3, [r5, #16]
    cc86:	b1a3      	cbz	r3, ccb2 <vQueueWaitForMessageRestricted+0xbe>
    cc88:	f105 0610 	add.w	r6, r5, #16
    cc8c:	e005      	b.n	cc9a <vQueueWaitForMessageRestricted+0xa6>
    cc8e:	3c01      	subs	r4, #1
    cc90:	b2e3      	uxtb	r3, r4
    cc92:	b25c      	sxtb	r4, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    cc94:	b16b      	cbz	r3, ccb2 <vQueueWaitForMessageRestricted+0xbe>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    cc96:	692b      	ldr	r3, [r5, #16]
    cc98:	b15b      	cbz	r3, ccb2 <vQueueWaitForMessageRestricted+0xbe>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    cc9a:	4630      	mov	r0, r6
    cc9c:	f000 fd6a 	bl	d774 <xTaskRemoveFromEventList>
    cca0:	2800      	cmp	r0, #0
    cca2:	d0f4      	beq.n	cc8e <vQueueWaitForMessageRestricted+0x9a>
    cca4:	3c01      	subs	r4, #1
					vTaskMissedYield();
    cca6:	f000 fdf3 	bl	d890 <vTaskMissedYield>
    ccaa:	b2e3      	uxtb	r3, r4
    ccac:	b25c      	sxtb	r4, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    ccae:	2b00      	cmp	r3, #0
    ccb0:	d1f1      	bne.n	cc96 <vQueueWaitForMessageRestricted+0xa2>
		pxQueue->cRxLock = queueUNLOCKED;
    ccb2:	23ff      	movs	r3, #255	; 0xff
    ccb4:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
	}
    ccb8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	taskEXIT_CRITICAL();
    ccbc:	f001 b984 	b.w	dfc8 <vPortExitCritical>

0000ccc0 <prvResetNextTaskUnblockTime.part.2>:
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    ccc0:	4a03      	ldr	r2, [pc, #12]	; (ccd0 <prvResetNextTaskUnblockTime.part.2+0x10>)
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    ccc2:	4b04      	ldr	r3, [pc, #16]	; (ccd4 <prvResetNextTaskUnblockTime.part.2+0x14>)
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    ccc4:	6812      	ldr	r2, [r2, #0]
    ccc6:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    ccc8:	68d2      	ldr	r2, [r2, #12]
    ccca:	6852      	ldr	r2, [r2, #4]
    cccc:	601a      	str	r2, [r3, #0]
	}
}
    ccce:	4770      	bx	lr
    ccd0:	10002bb0 	.word	0x10002bb0
    ccd4:	10002c84 	.word	0x10002c84

0000ccd8 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    ccd8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    ccda:	4b1b      	ldr	r3, [pc, #108]	; (cd48 <prvAddCurrentTaskToDelayedList+0x70>)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    ccdc:	4d1b      	ldr	r5, [pc, #108]	; (cd4c <prvAddCurrentTaskToDelayedList+0x74>)
const TickType_t xConstTickCount = xTickCount;
    ccde:	681c      	ldr	r4, [r3, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    cce0:	682b      	ldr	r3, [r5, #0]
{
    cce2:	4606      	mov	r6, r0
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    cce4:	1d18      	adds	r0, r3, #4
{
    cce6:	460f      	mov	r7, r1
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    cce8:	f7ff fb4e 	bl	c388 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    ccec:	1c73      	adds	r3, r6, #1
    ccee:	d01e      	beq.n	cd2e <prvAddCurrentTaskToDelayedList+0x56>
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    ccf0:	682b      	ldr	r3, [r5, #0]

			if( xTimeToWake < xConstTickCount )
			{
			  //GEO: addition for support of SystemView Profiler
			  traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
    ccf2:	6828      	ldr	r0, [r5, #0]
    ccf4:	19a4      	adds	r4, r4, r6
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    ccf6:	605c      	str	r4, [r3, #4]
			  traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
    ccf8:	f04f 0104 	mov.w	r1, #4
			if( xTimeToWake < xConstTickCount )
    ccfc:	d20d      	bcs.n	cd1a <prvAddCurrentTaskToDelayedList+0x42>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
			}
			else
			{
			  //GEO: addition for support of SystemView Profiler
			  traceMOVED_TASK_TO_DELAYED_LIST();
    ccfe:	f004 fa03 	bl	11108 <SEGGER_SYSVIEW_OnTaskStopReady>
                          //GEO: end addition
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    cd02:	4b13      	ldr	r3, [pc, #76]	; (cd50 <prvAddCurrentTaskToDelayedList+0x78>)
    cd04:	6818      	ldr	r0, [r3, #0]
    cd06:	6829      	ldr	r1, [r5, #0]
    cd08:	3104      	adds	r1, #4
    cd0a:	f7ff fb23 	bl	c354 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    cd0e:	4b11      	ldr	r3, [pc, #68]	; (cd54 <prvAddCurrentTaskToDelayedList+0x7c>)
    cd10:	681a      	ldr	r2, [r3, #0]
    cd12:	42a2      	cmp	r2, r4
				{
					xNextTaskUnblockTime = xTimeToWake;
    cd14:	bf88      	it	hi
    cd16:	601c      	strhi	r4, [r3, #0]

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    cd18:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			  traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
    cd1a:	f004 f9f5 	bl	11108 <SEGGER_SYSVIEW_OnTaskStopReady>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    cd1e:	4b0e      	ldr	r3, [pc, #56]	; (cd58 <prvAddCurrentTaskToDelayedList+0x80>)
    cd20:	6818      	ldr	r0, [r3, #0]
    cd22:	6829      	ldr	r1, [r5, #0]
}
    cd24:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    cd28:	3104      	adds	r1, #4
    cd2a:	f7ff bb13 	b.w	c354 <vListInsert>
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    cd2e:	2f00      	cmp	r7, #0
    cd30:	d0de      	beq.n	ccf0 <prvAddCurrentTaskToDelayedList+0x18>
		  traceMOVED_TASK_TO_SUSPENDED_LIST(pxCurrentTCB);
    cd32:	6828      	ldr	r0, [r5, #0]
    cd34:	211b      	movs	r1, #27
    cd36:	f004 f9e7 	bl	11108 <SEGGER_SYSVIEW_OnTaskStopReady>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    cd3a:	6829      	ldr	r1, [r5, #0]
    cd3c:	4807      	ldr	r0, [pc, #28]	; (cd5c <prvAddCurrentTaskToDelayedList+0x84>)
    cd3e:	3104      	adds	r1, #4
}
    cd40:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    cd44:	f7ff baf6 	b.w	c334 <vListInsertEnd>
    cd48:	10002cb8 	.word	0x10002cb8
    cd4c:	10002bac 	.word	0x10002bac
    cd50:	10002bb0 	.word	0x10002bb0
    cd54:	10002c84 	.word	0x10002c84
    cd58:	10002bb4 	.word	0x10002bb4
    cd5c:	10002ca4 	.word	0x10002ca4

0000cd60 <xTaskCreate>:
	{
    cd60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    cd64:	0096      	lsls	r6, r2, #2
	{
    cd66:	b083      	sub	sp, #12
    cd68:	4680      	mov	r8, r0
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    cd6a:	4630      	mov	r0, r6
	{
    cd6c:	460d      	mov	r5, r1
    cd6e:	4699      	mov	r9, r3
    cd70:	9f0d      	ldr	r7, [sp, #52]	; 0x34
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    cd72:	f001 f80f 	bl	dd94 <pvPortMalloc>
			if( pxStack != NULL )
    cd76:	2800      	cmp	r0, #0
    cd78:	f000 810b 	beq.w	cf92 <xTaskCreate+0x232>
    cd7c:	4682      	mov	sl, r0
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    cd7e:	204c      	movs	r0, #76	; 0x4c
    cd80:	f001 f808 	bl	dd94 <pvPortMalloc>
				if( pxNewTCB != NULL )
    cd84:	4604      	mov	r4, r0
    cd86:	2800      	cmp	r0, #0
    cd88:	f000 80da 	beq.w	cf40 <xTaskCreate+0x1e0>
					pxNewTCB->pxStack = pxStack;
    cd8c:	f8c0 a030 	str.w	sl, [r0, #48]	; 0x30
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
    cd90:	4632      	mov	r2, r6
    cd92:	4650      	mov	r0, sl
    cd94:	21a5      	movs	r1, #165	; 0xa5
    cd96:	f006 fcd1 	bl	1373c <memset>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cd9a:	782a      	ldrb	r2, [r5, #0]
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    cd9c:	6b23      	ldr	r3, [r4, #48]	; 0x30
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cd9e:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    cda2:	3e04      	subs	r6, #4
		if( pcName[ x ] == 0x00 )
    cda4:	782a      	ldrb	r2, [r5, #0]
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    cda6:	441e      	add	r6, r3
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
    cda8:	f026 0a07 	bic.w	sl, r6, #7
		if( pcName[ x ] == 0x00 )
    cdac:	2a00      	cmp	r2, #0
    cdae:	d04d      	beq.n	ce4c <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cdb0:	786b      	ldrb	r3, [r5, #1]
    cdb2:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
		if( pcName[ x ] == 0x00 )
    cdb6:	786b      	ldrb	r3, [r5, #1]
    cdb8:	2b00      	cmp	r3, #0
    cdba:	d047      	beq.n	ce4c <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cdbc:	78ab      	ldrb	r3, [r5, #2]
    cdbe:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
		if( pcName[ x ] == 0x00 )
    cdc2:	78ab      	ldrb	r3, [r5, #2]
    cdc4:	2b00      	cmp	r3, #0
    cdc6:	d041      	beq.n	ce4c <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cdc8:	78eb      	ldrb	r3, [r5, #3]
    cdca:	f884 3037 	strb.w	r3, [r4, #55]	; 0x37
		if( pcName[ x ] == 0x00 )
    cdce:	78eb      	ldrb	r3, [r5, #3]
    cdd0:	2b00      	cmp	r3, #0
    cdd2:	d03b      	beq.n	ce4c <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cdd4:	792b      	ldrb	r3, [r5, #4]
    cdd6:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
		if( pcName[ x ] == 0x00 )
    cdda:	792b      	ldrb	r3, [r5, #4]
    cddc:	2b00      	cmp	r3, #0
    cdde:	d035      	beq.n	ce4c <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cde0:	796b      	ldrb	r3, [r5, #5]
    cde2:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
		if( pcName[ x ] == 0x00 )
    cde6:	796b      	ldrb	r3, [r5, #5]
    cde8:	2b00      	cmp	r3, #0
    cdea:	d02f      	beq.n	ce4c <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cdec:	79ab      	ldrb	r3, [r5, #6]
    cdee:	f884 303a 	strb.w	r3, [r4, #58]	; 0x3a
		if( pcName[ x ] == 0x00 )
    cdf2:	79ab      	ldrb	r3, [r5, #6]
    cdf4:	b353      	cbz	r3, ce4c <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cdf6:	79eb      	ldrb	r3, [r5, #7]
    cdf8:	f884 303b 	strb.w	r3, [r4, #59]	; 0x3b
		if( pcName[ x ] == 0x00 )
    cdfc:	79eb      	ldrb	r3, [r5, #7]
    cdfe:	b32b      	cbz	r3, ce4c <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    ce00:	7a2b      	ldrb	r3, [r5, #8]
    ce02:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
		if( pcName[ x ] == 0x00 )
    ce06:	7a2b      	ldrb	r3, [r5, #8]
    ce08:	b303      	cbz	r3, ce4c <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    ce0a:	7a6b      	ldrb	r3, [r5, #9]
    ce0c:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
		if( pcName[ x ] == 0x00 )
    ce10:	7a6b      	ldrb	r3, [r5, #9]
    ce12:	b1db      	cbz	r3, ce4c <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    ce14:	7aab      	ldrb	r3, [r5, #10]
    ce16:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
		if( pcName[ x ] == 0x00 )
    ce1a:	7aab      	ldrb	r3, [r5, #10]
    ce1c:	b1b3      	cbz	r3, ce4c <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    ce1e:	7aeb      	ldrb	r3, [r5, #11]
    ce20:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
		if( pcName[ x ] == 0x00 )
    ce24:	7aeb      	ldrb	r3, [r5, #11]
    ce26:	b18b      	cbz	r3, ce4c <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    ce28:	7b2b      	ldrb	r3, [r5, #12]
    ce2a:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
		if( pcName[ x ] == 0x00 )
    ce2e:	7b2b      	ldrb	r3, [r5, #12]
    ce30:	b163      	cbz	r3, ce4c <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    ce32:	7b6b      	ldrb	r3, [r5, #13]
    ce34:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
		if( pcName[ x ] == 0x00 )
    ce38:	7b6b      	ldrb	r3, [r5, #13]
    ce3a:	b13b      	cbz	r3, ce4c <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    ce3c:	7bab      	ldrb	r3, [r5, #14]
    ce3e:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
		if( pcName[ x ] == 0x00 )
    ce42:	7bab      	ldrb	r3, [r5, #14]
    ce44:	b113      	cbz	r3, ce4c <xTaskCreate+0xec>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    ce46:	7beb      	ldrb	r3, [r5, #15]
    ce48:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    ce4c:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    ce4e:	2d06      	cmp	r5, #6
    ce50:	bf28      	it	cs
    ce52:	2506      	movcs	r5, #6
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    ce54:	f04f 0b00 	mov.w	fp, #0
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    ce58:	1d26      	adds	r6, r4, #4
	pxNewTCB->uxPriority = uxPriority;
    ce5a:	62e5      	str	r5, [r4, #44]	; 0x2c
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    ce5c:	4630      	mov	r0, r6
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    ce5e:	f884 b043 	strb.w	fp, [r4, #67]	; 0x43
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    ce62:	f7ff fa63 	bl	c32c <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    ce66:	f1c5 0507 	rsb	r5, r5, #7
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    ce6a:	f104 0018 	add.w	r0, r4, #24
    ce6e:	f7ff fa5d 	bl	c32c <vListInitialiseItem>
		pxNewTCB->ulNotifiedValue = 0;
    ce72:	f8c4 b044 	str.w	fp, [r4, #68]	; 0x44
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    ce76:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    ce78:	6124      	str	r4, [r4, #16]
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    ce7a:	f884 b048 	strb.w	fp, [r4, #72]	; 0x48
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    ce7e:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    ce80:	464a      	mov	r2, r9
    ce82:	4641      	mov	r1, r8
    ce84:	4650      	mov	r0, sl
    ce86:	f001 f857 	bl	df38 <pxPortInitialiseStack>
    ce8a:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
    ce8c:	b107      	cbz	r7, ce90 <xTaskCreate+0x130>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    ce8e:	603c      	str	r4, [r7, #0]
	taskENTER_CRITICAL();
    ce90:	f001 f880 	bl	df94 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
    ce94:	4a40      	ldr	r2, [pc, #256]	; (cf98 <xTaskCreate+0x238>)
		if( pxCurrentTCB == NULL )
    ce96:	4d41      	ldr	r5, [pc, #260]	; (cf9c <xTaskCreate+0x23c>)
		uxCurrentNumberOfTasks++;
    ce98:	6813      	ldr	r3, [r2, #0]
    ce9a:	3301      	adds	r3, #1
    ce9c:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
    ce9e:	682b      	ldr	r3, [r5, #0]
    cea0:	2b00      	cmp	r3, #0
    cea2:	d045      	beq.n	cf30 <xTaskCreate+0x1d0>
			if( xSchedulerRunning == pdFALSE )
    cea4:	4f3e      	ldr	r7, [pc, #248]	; (cfa0 <xTaskCreate+0x240>)
    cea6:	683b      	ldr	r3, [r7, #0]
    cea8:	2b00      	cmp	r3, #0
    ceaa:	d034      	beq.n	cf16 <xTaskCreate+0x1b6>
    ceac:	f8df 8110 	ldr.w	r8, [pc, #272]	; cfc0 <xTaskCreate+0x260>
		uxTaskNumber++;
    ceb0:	4a3c      	ldr	r2, [pc, #240]	; (cfa4 <xTaskCreate+0x244>)
    ceb2:	6813      	ldr	r3, [r2, #0]
		traceTASK_CREATE( pxNewTCB );
    ceb4:	4620      	mov	r0, r4
		uxTaskNumber++;
    ceb6:	3301      	adds	r3, #1
    ceb8:	6013      	str	r3, [r2, #0]
		traceTASK_CREATE( pxNewTCB );
    ceba:	f003 ff57 	bl	10d6c <SEGGER_SYSVIEW_OnTaskCreate>
    cebe:	6b23      	ldr	r3, [r4, #48]	; 0x30
    cec0:	6821      	ldr	r1, [r4, #0]
    cec2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    cec4:	1ac9      	subs	r1, r1, r3
    cec6:	9100      	str	r1, [sp, #0]
    cec8:	4620      	mov	r0, r4
    ceca:	f104 0134 	add.w	r1, r4, #52	; 0x34
    cece:	f005 f901 	bl	120d4 <SYSVIEW_AddTask>
		prvReaddTaskToReadyList( pxNewTCB );
    ced2:	4b35      	ldr	r3, [pc, #212]	; (cfa8 <xTaskCreate+0x248>)
    ced4:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    ced6:	681a      	ldr	r2, [r3, #0]
    ced8:	4290      	cmp	r0, r2
    ceda:	bf88      	it	hi
    cedc:	6018      	strhi	r0, [r3, #0]
    cede:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    cee2:	eb08 0080 	add.w	r0, r8, r0, lsl #2
    cee6:	4631      	mov	r1, r6
    cee8:	f7ff fa24 	bl	c334 <vListInsertEnd>
	taskEXIT_CRITICAL();
    ceec:	f001 f86c 	bl	dfc8 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
    cef0:	683b      	ldr	r3, [r7, #0]
    cef2:	b1cb      	cbz	r3, cf28 <xTaskCreate+0x1c8>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    cef4:	682a      	ldr	r2, [r5, #0]
    cef6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    cef8:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    cefa:	429a      	cmp	r2, r3
    cefc:	d214      	bcs.n	cf28 <xTaskCreate+0x1c8>
			taskYIELD_IF_USING_PREEMPTION();    /* Set a PendSV to request a context switch. */                             \
    cefe:	4b2b      	ldr	r3, [pc, #172]	; (cfac <xTaskCreate+0x24c>)
    cf00:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    cf04:	601a      	str	r2, [r3, #0]
    cf06:	f3bf 8f4f 	dsb	sy
    cf0a:	f3bf 8f6f 	isb	sy
			xReturn = pdPASS;
    cf0e:	2001      	movs	r0, #1
	}
    cf10:	b003      	add	sp, #12
    cf12:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    cf16:	682a      	ldr	r2, [r5, #0]
    cf18:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    cf1a:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    cf1c:	f8df 80a0 	ldr.w	r8, [pc, #160]	; cfc0 <xTaskCreate+0x260>
    cf20:	429a      	cmp	r2, r3
					pxCurrentTCB = pxNewTCB;
    cf22:	bf98      	it	ls
    cf24:	602c      	strls	r4, [r5, #0]
    cf26:	e7c3      	b.n	ceb0 <xTaskCreate+0x150>
			xReturn = pdPASS;
    cf28:	2001      	movs	r0, #1
	}
    cf2a:	b003      	add	sp, #12
    cf2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			pxCurrentTCB = pxNewTCB;
    cf30:	602c      	str	r4, [r5, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    cf32:	6813      	ldr	r3, [r2, #0]
    cf34:	f8df 8088 	ldr.w	r8, [pc, #136]	; cfc0 <xTaskCreate+0x260>
    cf38:	2b01      	cmp	r3, #1
    cf3a:	d009      	beq.n	cf50 <xTaskCreate+0x1f0>
    cf3c:	4f18      	ldr	r7, [pc, #96]	; (cfa0 <xTaskCreate+0x240>)
    cf3e:	e7b7      	b.n	ceb0 <xTaskCreate+0x150>
					vPortFree( pxStack );
    cf40:	4650      	mov	r0, sl
    cf42:	f000 ffa7 	bl	de94 <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    cf46:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	}
    cf4a:	b003      	add	sp, #12
    cf4c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cf50:	4647      	mov	r7, r8
    cf52:	f108 098c 	add.w	r9, r8, #140	; 0x8c
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    cf56:	4638      	mov	r0, r7
    cf58:	3714      	adds	r7, #20
    cf5a:	f7ff f9db 	bl	c314 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    cf5e:	454f      	cmp	r7, r9
    cf60:	d1f9      	bne.n	cf56 <xTaskCreate+0x1f6>
	vListInitialise( &xDelayedTaskList1 );
    cf62:	f8df a060 	ldr.w	sl, [pc, #96]	; cfc4 <xTaskCreate+0x264>
	vListInitialise( &xDelayedTaskList2 );
    cf66:	f8df 9060 	ldr.w	r9, [pc, #96]	; cfc8 <xTaskCreate+0x268>
    cf6a:	4f0d      	ldr	r7, [pc, #52]	; (cfa0 <xTaskCreate+0x240>)
	vListInitialise( &xDelayedTaskList1 );
    cf6c:	4650      	mov	r0, sl
    cf6e:	f7ff f9d1 	bl	c314 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    cf72:	4648      	mov	r0, r9
    cf74:	f7ff f9ce 	bl	c314 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    cf78:	480d      	ldr	r0, [pc, #52]	; (cfb0 <xTaskCreate+0x250>)
    cf7a:	f7ff f9cb 	bl	c314 <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
    cf7e:	480d      	ldr	r0, [pc, #52]	; (cfb4 <xTaskCreate+0x254>)
    cf80:	f7ff f9c8 	bl	c314 <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
    cf84:	4a0c      	ldr	r2, [pc, #48]	; (cfb8 <xTaskCreate+0x258>)
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    cf86:	4b0d      	ldr	r3, [pc, #52]	; (cfbc <xTaskCreate+0x25c>)
	pxDelayedTaskList = &xDelayedTaskList1;
    cf88:	f8c2 a000 	str.w	sl, [r2]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    cf8c:	f8c3 9000 	str.w	r9, [r3]
    cf90:	e78e      	b.n	ceb0 <xTaskCreate+0x150>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    cf92:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    cf96:	e7bb      	b.n	cf10 <xTaskCreate+0x1b0>
    cf98:	10002c44 	.word	0x10002c44
    cf9c:	10002bac 	.word	0x10002bac
    cfa0:	10002ca0 	.word	0x10002ca0
    cfa4:	10002c50 	.word	0x10002c50
    cfa8:	10002c54 	.word	0x10002c54
    cfac:	e000ed04 	.word	0xe000ed04
    cfb0:	10002c8c 	.word	0x10002c8c
    cfb4:	10002ca4 	.word	0x10002ca4
    cfb8:	10002bb0 	.word	0x10002bb0
    cfbc:	10002bb4 	.word	0x10002bb4
    cfc0:	10002bb8 	.word	0x10002bb8
    cfc4:	10002c58 	.word	0x10002c58
    cfc8:	10002c6c 	.word	0x10002c6c

0000cfcc <vTaskStartScheduler>:
{
    cfcc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    cfd0:	f44f 6080 	mov.w	r0, #1024	; 0x400
{
    cfd4:	b082      	sub	sp, #8
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    cfd6:	f000 fedd 	bl	dd94 <pvPortMalloc>
			if( pxStack != NULL )
    cfda:	2800      	cmp	r0, #0
    cfdc:	d076      	beq.n	d0cc <vTaskStartScheduler+0x100>
    cfde:	4605      	mov	r5, r0
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    cfe0:	204c      	movs	r0, #76	; 0x4c
    cfe2:	f000 fed7 	bl	dd94 <pvPortMalloc>
				if( pxNewTCB != NULL )
    cfe6:	4604      	mov	r4, r0
    cfe8:	2800      	cmp	r0, #0
    cfea:	d07f      	beq.n	d0ec <vTaskStartScheduler+0x120>
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
    cfec:	21a5      	movs	r1, #165	; 0xa5
					pxNewTCB->pxStack = pxStack;
    cfee:	6305      	str	r5, [r0, #48]	; 0x30
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
    cff0:	f44f 6280 	mov.w	r2, #1024	; 0x400
    cff4:	4628      	mov	r0, r5
    cff6:	f006 fba1 	bl	1373c <memset>
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    cffa:	6b23      	ldr	r3, [r4, #48]	; 0x30
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    cffc:	4a5a      	ldr	r2, [pc, #360]	; (d168 <vTaskStartScheduler+0x19c>)
    cffe:	6362      	str	r2, [r4, #52]	; 0x34
    d000:	2500      	movs	r5, #0
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    d002:	f104 0804 	add.w	r8, r4, #4
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    d006:	f503 737f 	add.w	r3, r3, #1020	; 0x3fc
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    d00a:	4640      	mov	r0, r8
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    d00c:	f884 5038 	strb.w	r5, [r4, #56]	; 0x38
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    d010:	f884 5043 	strb.w	r5, [r4, #67]	; 0x43
	pxNewTCB->uxPriority = uxPriority;
    d014:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
    d016:	f023 0607 	bic.w	r6, r3, #7
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    d01a:	f7ff f987 	bl	c32c <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    d01e:	f104 0018 	add.w	r0, r4, #24
    d022:	f7ff f983 	bl	c32c <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    d026:	2307      	movs	r3, #7
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    d028:	462a      	mov	r2, r5
		pxNewTCB->ulNotifiedValue = 0;
    d02a:	6465      	str	r5, [r4, #68]	; 0x44
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    d02c:	61a3      	str	r3, [r4, #24]
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    d02e:	494f      	ldr	r1, [pc, #316]	; (d16c <vTaskStartScheduler+0x1a0>)
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    d030:	6124      	str	r4, [r4, #16]
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    d032:	4630      	mov	r0, r6
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    d034:	f884 5048 	strb.w	r5, [r4, #72]	; 0x48
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    d038:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    d03a:	f000 ff7d 	bl	df38 <pxPortInitialiseStack>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    d03e:	4b4c      	ldr	r3, [pc, #304]	; (d170 <vTaskStartScheduler+0x1a4>)
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    d040:	6020      	str	r0, [r4, #0]
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    d042:	601c      	str	r4, [r3, #0]
	taskENTER_CRITICAL();
    d044:	f000 ffa6 	bl	df94 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
    d048:	4b4a      	ldr	r3, [pc, #296]	; (d174 <vTaskStartScheduler+0x1a8>)
		if( pxCurrentTCB == NULL )
    d04a:	4f4b      	ldr	r7, [pc, #300]	; (d178 <vTaskStartScheduler+0x1ac>)
		uxCurrentNumberOfTasks++;
    d04c:	681a      	ldr	r2, [r3, #0]
    d04e:	3201      	adds	r2, #1
    d050:	601a      	str	r2, [r3, #0]
		if( pxCurrentTCB == NULL )
    d052:	683a      	ldr	r2, [r7, #0]
    d054:	2a00      	cmp	r2, #0
    d056:	d042      	beq.n	d0de <vTaskStartScheduler+0x112>
			if( xSchedulerRunning == pdFALSE )
    d058:	4e48      	ldr	r6, [pc, #288]	; (d17c <vTaskStartScheduler+0x1b0>)
    d05a:	6833      	ldr	r3, [r6, #0]
    d05c:	2b00      	cmp	r3, #0
    d05e:	d036      	beq.n	d0ce <vTaskStartScheduler+0x102>
    d060:	4d47      	ldr	r5, [pc, #284]	; (d180 <vTaskStartScheduler+0x1b4>)
		uxTaskNumber++;
    d062:	4a48      	ldr	r2, [pc, #288]	; (d184 <vTaskStartScheduler+0x1b8>)
    d064:	6813      	ldr	r3, [r2, #0]
		traceTASK_CREATE( pxNewTCB );
    d066:	4620      	mov	r0, r4
		uxTaskNumber++;
    d068:	3301      	adds	r3, #1
    d06a:	6013      	str	r3, [r2, #0]
		traceTASK_CREATE( pxNewTCB );
    d06c:	f003 fe7e 	bl	10d6c <SEGGER_SYSVIEW_OnTaskCreate>
    d070:	6b23      	ldr	r3, [r4, #48]	; 0x30
    d072:	6821      	ldr	r1, [r4, #0]
    d074:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    d076:	1ac9      	subs	r1, r1, r3
    d078:	9100      	str	r1, [sp, #0]
    d07a:	4620      	mov	r0, r4
    d07c:	f104 0134 	add.w	r1, r4, #52	; 0x34
    d080:	f005 f828 	bl	120d4 <SYSVIEW_AddTask>
		prvReaddTaskToReadyList( pxNewTCB );
    d084:	4b40      	ldr	r3, [pc, #256]	; (d188 <vTaskStartScheduler+0x1bc>)
    d086:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    d088:	681a      	ldr	r2, [r3, #0]
    d08a:	4290      	cmp	r0, r2
    d08c:	d900      	bls.n	d090 <vTaskStartScheduler+0xc4>
    d08e:	6018      	str	r0, [r3, #0]
    d090:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    d094:	eb05 0080 	add.w	r0, r5, r0, lsl #2
    d098:	4641      	mov	r1, r8
    d09a:	f7ff f94b 	bl	c334 <vListInsertEnd>
	taskEXIT_CRITICAL();
    d09e:	f000 ff93 	bl	dfc8 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
    d0a2:	6833      	ldr	r3, [r6, #0]
    d0a4:	b163      	cbz	r3, d0c0 <vTaskStartScheduler+0xf4>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    d0a6:	683a      	ldr	r2, [r7, #0]
    d0a8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    d0aa:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    d0ac:	429a      	cmp	r2, r3
    d0ae:	d207      	bcs.n	d0c0 <vTaskStartScheduler+0xf4>
			taskYIELD_IF_USING_PREEMPTION();    /* Set a PendSV to request a context switch. */                             \
    d0b0:	4b36      	ldr	r3, [pc, #216]	; (d18c <vTaskStartScheduler+0x1c0>)
    d0b2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    d0b6:	601a      	str	r2, [r3, #0]
    d0b8:	f3bf 8f4f 	dsb	sy
    d0bc:	f3bf 8f6f 	isb	sy
			xReturn = xTimerCreateTimerTask();
    d0c0:	f000 fd90 	bl	dbe4 <xTimerCreateTimerTask>
	if( xReturn == pdPASS )
    d0c4:	2801      	cmp	r0, #1
    d0c6:	d018      	beq.n	d0fa <vTaskStartScheduler+0x12e>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
    d0c8:	3001      	adds	r0, #1
    d0ca:	d113      	bne.n	d0f4 <vTaskStartScheduler+0x128>
    d0cc:	e7fe      	b.n	d0cc <vTaskStartScheduler+0x100>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    d0ce:	683a      	ldr	r2, [r7, #0]
    d0d0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    d0d2:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    d0d4:	4d2a      	ldr	r5, [pc, #168]	; (d180 <vTaskStartScheduler+0x1b4>)
    d0d6:	429a      	cmp	r2, r3
					pxCurrentTCB = pxNewTCB;
    d0d8:	bf98      	it	ls
    d0da:	603c      	strls	r4, [r7, #0]
    d0dc:	e7c1      	b.n	d062 <vTaskStartScheduler+0x96>
			pxCurrentTCB = pxNewTCB;
    d0de:	603c      	str	r4, [r7, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    d0e0:	681b      	ldr	r3, [r3, #0]
    d0e2:	4d27      	ldr	r5, [pc, #156]	; (d180 <vTaskStartScheduler+0x1b4>)
    d0e4:	2b01      	cmp	r3, #1
    d0e6:	d01d      	beq.n	d124 <vTaskStartScheduler+0x158>
    d0e8:	4e24      	ldr	r6, [pc, #144]	; (d17c <vTaskStartScheduler+0x1b0>)
    d0ea:	e7ba      	b.n	d062 <vTaskStartScheduler+0x96>
					vPortFree( pxStack );
    d0ec:	4628      	mov	r0, r5
    d0ee:	f000 fed1 	bl	de94 <vPortFree>
    d0f2:	e7eb      	b.n	d0cc <vTaskStartScheduler+0x100>
}
    d0f4:	b002      	add	sp, #8
    d0f6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	__asm volatile
    d0fa:	f04f 0380 	mov.w	r3, #128	; 0x80
    d0fe:	f383 8811 	msr	BASEPRI, r3
    d102:	f3bf 8f6f 	isb	sy
    d106:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
    d10a:	4921      	ldr	r1, [pc, #132]	; (d190 <vTaskStartScheduler+0x1c4>)
		xTickCount = ( TickType_t ) 0U;
    d10c:	4b21      	ldr	r3, [pc, #132]	; (d194 <vTaskStartScheduler+0x1c8>)
		xNextTaskUnblockTime = portMAX_DELAY;
    d10e:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
		xTickCount = ( TickType_t ) 0U;
    d112:	2200      	movs	r2, #0
		xNextTaskUnblockTime = portMAX_DELAY;
    d114:	600c      	str	r4, [r1, #0]
		xSchedulerRunning = pdTRUE;
    d116:	6030      	str	r0, [r6, #0]
		xTickCount = ( TickType_t ) 0U;
    d118:	601a      	str	r2, [r3, #0]
}
    d11a:	b002      	add	sp, #8
    d11c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		if( xPortStartScheduler() != pdFALSE )
    d120:	f001 b89e 	b.w	e260 <xPortStartScheduler>
    d124:	462e      	mov	r6, r5
    d126:	f105 098c 	add.w	r9, r5, #140	; 0x8c
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    d12a:	4630      	mov	r0, r6
    d12c:	3614      	adds	r6, #20
    d12e:	f7ff f8f1 	bl	c314 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    d132:	45b1      	cmp	r9, r6
    d134:	d1f9      	bne.n	d12a <vTaskStartScheduler+0x15e>
	vListInitialise( &xDelayedTaskList1 );
    d136:	f8df a070 	ldr.w	sl, [pc, #112]	; d1a8 <vTaskStartScheduler+0x1dc>
	vListInitialise( &xDelayedTaskList2 );
    d13a:	f8df 9070 	ldr.w	r9, [pc, #112]	; d1ac <vTaskStartScheduler+0x1e0>
    d13e:	4e0f      	ldr	r6, [pc, #60]	; (d17c <vTaskStartScheduler+0x1b0>)
	vListInitialise( &xDelayedTaskList1 );
    d140:	4650      	mov	r0, sl
    d142:	f7ff f8e7 	bl	c314 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    d146:	4648      	mov	r0, r9
    d148:	f7ff f8e4 	bl	c314 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    d14c:	4812      	ldr	r0, [pc, #72]	; (d198 <vTaskStartScheduler+0x1cc>)
    d14e:	f7ff f8e1 	bl	c314 <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
    d152:	4812      	ldr	r0, [pc, #72]	; (d19c <vTaskStartScheduler+0x1d0>)
    d154:	f7ff f8de 	bl	c314 <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
    d158:	4a11      	ldr	r2, [pc, #68]	; (d1a0 <vTaskStartScheduler+0x1d4>)
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    d15a:	4b12      	ldr	r3, [pc, #72]	; (d1a4 <vTaskStartScheduler+0x1d8>)
	pxDelayedTaskList = &xDelayedTaskList1;
    d15c:	f8c2 a000 	str.w	sl, [r2]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    d160:	f8c3 9000 	str.w	r9, [r3]
    d164:	e77d      	b.n	d062 <vTaskStartScheduler+0x96>
    d166:	bf00      	nop
    d168:	454c4449 	.word	0x454c4449
    d16c:	0000d471 	.word	0x0000d471
    d170:	10002c80 	.word	0x10002c80
    d174:	10002c44 	.word	0x10002c44
    d178:	10002bac 	.word	0x10002bac
    d17c:	10002ca0 	.word	0x10002ca0
    d180:	10002bb8 	.word	0x10002bb8
    d184:	10002c50 	.word	0x10002c50
    d188:	10002c54 	.word	0x10002c54
    d18c:	e000ed04 	.word	0xe000ed04
    d190:	10002c84 	.word	0x10002c84
    d194:	10002cb8 	.word	0x10002cb8
    d198:	10002c8c 	.word	0x10002c8c
    d19c:	10002ca4 	.word	0x10002ca4
    d1a0:	10002bb0 	.word	0x10002bb0
    d1a4:	10002bb4 	.word	0x10002bb4
    d1a8:	10002c58 	.word	0x10002c58
    d1ac:	10002c6c 	.word	0x10002c6c

0000d1b0 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
    d1b0:	4a02      	ldr	r2, [pc, #8]	; (d1bc <vTaskSuspendAll+0xc>)
    d1b2:	6813      	ldr	r3, [r2, #0]
    d1b4:	3301      	adds	r3, #1
    d1b6:	6013      	str	r3, [r2, #0]
}
    d1b8:	4770      	bx	lr
    d1ba:	bf00      	nop
    d1bc:	10002c4c 	.word	0x10002c4c

0000d1c0 <xTaskGetTickCount>:
		xTicks = xTickCount;
    d1c0:	4b01      	ldr	r3, [pc, #4]	; (d1c8 <xTaskGetTickCount+0x8>)
    d1c2:	6818      	ldr	r0, [r3, #0]
}
    d1c4:	4770      	bx	lr
    d1c6:	bf00      	nop
    d1c8:	10002cb8 	.word	0x10002cb8

0000d1cc <vTaskStepTick>:
		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
    d1cc:	4b07      	ldr	r3, [pc, #28]	; (d1ec <vTaskStepTick+0x20>)
    d1ce:	4908      	ldr	r1, [pc, #32]	; (d1f0 <vTaskStepTick+0x24>)
    d1d0:	681a      	ldr	r2, [r3, #0]
    d1d2:	6809      	ldr	r1, [r1, #0]
    d1d4:	4402      	add	r2, r0
    d1d6:	428a      	cmp	r2, r1
    d1d8:	d900      	bls.n	d1dc <vTaskStepTick+0x10>
    d1da:	e7fe      	b.n	d1da <vTaskStepTick+0xe>
		xTickCount += xTicksToJump;
    d1dc:	681a      	ldr	r2, [r3, #0]
		traceINCREASE_TICK_COUNT( xTicksToJump );
    d1de:	4601      	mov	r1, r0
		xTickCount += xTicksToJump;
    d1e0:	4402      	add	r2, r0
		traceINCREASE_TICK_COUNT( xTicksToJump );
    d1e2:	204e      	movs	r0, #78	; 0x4e
		xTickCount += xTicksToJump;
    d1e4:	601a      	str	r2, [r3, #0]
		traceINCREASE_TICK_COUNT( xTicksToJump );
    d1e6:	f004 bc9b 	b.w	11b20 <SEGGER_SYSVIEW_RecordU32>
    d1ea:	bf00      	nop
    d1ec:	10002cb8 	.word	0x10002cb8
    d1f0:	10002c84 	.word	0x10002c84

0000d1f4 <xTaskIncrementTick>:
{
    d1f4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    d1f8:	4b42      	ldr	r3, [pc, #264]	; (d304 <xTaskIncrementTick+0x110>)
    d1fa:	681b      	ldr	r3, [r3, #0]
    d1fc:	b9c3      	cbnz	r3, d230 <xTaskIncrementTick+0x3c>
		const TickType_t xConstTickCount = xTickCount + 1;
    d1fe:	4b42      	ldr	r3, [pc, #264]	; (d308 <xTaskIncrementTick+0x114>)
    d200:	681f      	ldr	r7, [r3, #0]
    d202:	3701      	adds	r7, #1
		xTickCount = xConstTickCount;
    d204:	601f      	str	r7, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U )
    d206:	b307      	cbz	r7, d24a <xTaskIncrementTick+0x56>
    d208:	4e40      	ldr	r6, [pc, #256]	; (d30c <xTaskIncrementTick+0x118>)
		if( xConstTickCount >= xNextTaskUnblockTime )
    d20a:	6833      	ldr	r3, [r6, #0]
    d20c:	42bb      	cmp	r3, r7
    d20e:	d935      	bls.n	d27c <xTaskIncrementTick+0x88>
    d210:	f8df 8114 	ldr.w	r8, [pc, #276]	; d328 <xTaskIncrementTick+0x134>
    d214:	f8df 9114 	ldr.w	r9, [pc, #276]	; d32c <xTaskIncrementTick+0x138>
BaseType_t xSwitchRequired = pdFALSE;
    d218:	2400      	movs	r4, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    d21a:	f8d9 3000 	ldr.w	r3, [r9]
    d21e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    d220:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    d224:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
				xSwitchRequired = pdTRUE;
    d228:	2b02      	cmp	r3, #2
    d22a:	bf28      	it	cs
    d22c:	2401      	movcs	r4, #1
    d22e:	e004      	b.n	d23a <xTaskIncrementTick+0x46>
		++uxPendedTicks;
    d230:	4a37      	ldr	r2, [pc, #220]	; (d310 <xTaskIncrementTick+0x11c>)
    d232:	6813      	ldr	r3, [r2, #0]
    d234:	3301      	adds	r3, #1
    d236:	6013      	str	r3, [r2, #0]
BaseType_t xSwitchRequired = pdFALSE;
    d238:	2400      	movs	r4, #0
		if( xYieldPending != pdFALSE )
    d23a:	4b36      	ldr	r3, [pc, #216]	; (d314 <xTaskIncrementTick+0x120>)
    d23c:	681b      	ldr	r3, [r3, #0]
			xSwitchRequired = pdTRUE;
    d23e:	2b00      	cmp	r3, #0
}
    d240:	bf0c      	ite	eq
    d242:	4620      	moveq	r0, r4
    d244:	2001      	movne	r0, #1
    d246:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			taskSWITCH_DELAYED_LISTS();
    d24a:	4d33      	ldr	r5, [pc, #204]	; (d318 <xTaskIncrementTick+0x124>)
    d24c:	682b      	ldr	r3, [r5, #0]
    d24e:	681b      	ldr	r3, [r3, #0]
    d250:	2b00      	cmp	r3, #0
    d252:	d151      	bne.n	d2f8 <xTaskIncrementTick+0x104>
    d254:	4b31      	ldr	r3, [pc, #196]	; (d31c <xTaskIncrementTick+0x128>)
    d256:	6829      	ldr	r1, [r5, #0]
    d258:	4a31      	ldr	r2, [pc, #196]	; (d320 <xTaskIncrementTick+0x12c>)
    d25a:	6818      	ldr	r0, [r3, #0]
    d25c:	6028      	str	r0, [r5, #0]
    d25e:	6019      	str	r1, [r3, #0]
    d260:	6813      	ldr	r3, [r2, #0]
    d262:	3301      	adds	r3, #1
    d264:	6013      	str	r3, [r2, #0]
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    d266:	682b      	ldr	r3, [r5, #0]
    d268:	681b      	ldr	r3, [r3, #0]
    d26a:	2b00      	cmp	r3, #0
    d26c:	d147      	bne.n	d2fe <xTaskIncrementTick+0x10a>
		xNextTaskUnblockTime = portMAX_DELAY;
    d26e:	4e27      	ldr	r6, [pc, #156]	; (d30c <xTaskIncrementTick+0x118>)
    d270:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    d274:	6033      	str	r3, [r6, #0]
		if( xConstTickCount >= xNextTaskUnblockTime )
    d276:	6833      	ldr	r3, [r6, #0]
    d278:	42bb      	cmp	r3, r7
    d27a:	d8c9      	bhi.n	d210 <xTaskIncrementTick+0x1c>
    d27c:	4d26      	ldr	r5, [pc, #152]	; (d318 <xTaskIncrementTick+0x124>)
    d27e:	f8df 80a8 	ldr.w	r8, [pc, #168]	; d328 <xTaskIncrementTick+0x134>
    d282:	f8df 90a8 	ldr.w	r9, [pc, #168]	; d32c <xTaskIncrementTick+0x138>
BaseType_t xSwitchRequired = pdFALSE;
    d286:	2400      	movs	r4, #0
    d288:	e02e      	b.n	d2e8 <xTaskIncrementTick+0xf4>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    d28a:	682b      	ldr	r3, [r5, #0]
    d28c:	68db      	ldr	r3, [r3, #12]
    d28e:	f8d3 a00c 	ldr.w	sl, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    d292:	f8da 2004 	ldr.w	r2, [sl, #4]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    d296:	f10a 0b04 	add.w	fp, sl, #4
					if( xConstTickCount < xItemValue )
    d29a:	4297      	cmp	r7, r2
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    d29c:	4658      	mov	r0, fp
					if( xConstTickCount < xItemValue )
    d29e:	d32c      	bcc.n	d2fa <xTaskIncrementTick+0x106>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    d2a0:	f7ff f872 	bl	c388 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    d2a4:	f8da 2028 	ldr.w	r2, [sl, #40]	; 0x28
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    d2a8:	f10a 0018 	add.w	r0, sl, #24
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    d2ac:	b10a      	cbz	r2, d2b2 <xTaskIncrementTick+0xbe>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    d2ae:	f7ff f86b 	bl	c388 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    d2b2:	4650      	mov	r0, sl
    d2b4:	f003 fe8e 	bl	10fd4 <SEGGER_SYSVIEW_OnTaskStartReady>
    d2b8:	4b1a      	ldr	r3, [pc, #104]	; (d324 <xTaskIncrementTick+0x130>)
    d2ba:	f8da 202c 	ldr.w	r2, [sl, #44]	; 0x2c
    d2be:	681b      	ldr	r3, [r3, #0]
    d2c0:	429a      	cmp	r2, r3
    d2c2:	bf88      	it	hi
    d2c4:	4b17      	ldrhi	r3, [pc, #92]	; (d324 <xTaskIncrementTick+0x130>)
    d2c6:	eb02 0082 	add.w	r0, r2, r2, lsl #2
    d2ca:	4659      	mov	r1, fp
    d2cc:	eb08 0080 	add.w	r0, r8, r0, lsl #2
    d2d0:	bf88      	it	hi
    d2d2:	601a      	strhi	r2, [r3, #0]
    d2d4:	f7ff f82e 	bl	c334 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    d2d8:	f8d9 1000 	ldr.w	r1, [r9]
    d2dc:	f8da 202c 	ldr.w	r2, [sl, #44]	; 0x2c
    d2e0:	6acb      	ldr	r3, [r1, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
    d2e2:	429a      	cmp	r2, r3
    d2e4:	bf28      	it	cs
    d2e6:	2401      	movcs	r4, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    d2e8:	682b      	ldr	r3, [r5, #0]
    d2ea:	681b      	ldr	r3, [r3, #0]
    d2ec:	2b00      	cmp	r3, #0
    d2ee:	d1cc      	bne.n	d28a <xTaskIncrementTick+0x96>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    d2f0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    d2f4:	6033      	str	r3, [r6, #0]
					break;
    d2f6:	e790      	b.n	d21a <xTaskIncrementTick+0x26>
    d2f8:	e7fe      	b.n	d2f8 <xTaskIncrementTick+0x104>
						xNextTaskUnblockTime = xItemValue;
    d2fa:	6032      	str	r2, [r6, #0]
						break;
    d2fc:	e78d      	b.n	d21a <xTaskIncrementTick+0x26>
    d2fe:	f7ff fcdf 	bl	ccc0 <prvResetNextTaskUnblockTime.part.2>
    d302:	e781      	b.n	d208 <xTaskIncrementTick+0x14>
    d304:	10002c4c 	.word	0x10002c4c
    d308:	10002cb8 	.word	0x10002cb8
    d30c:	10002c84 	.word	0x10002c84
    d310:	10002c48 	.word	0x10002c48
    d314:	10002cbc 	.word	0x10002cbc
    d318:	10002bb0 	.word	0x10002bb0
    d31c:	10002bb4 	.word	0x10002bb4
    d320:	10002c88 	.word	0x10002c88
    d324:	10002c54 	.word	0x10002c54
    d328:	10002bb8 	.word	0x10002bb8
    d32c:	10002bac 	.word	0x10002bac

0000d330 <xTaskResumeAll>:
{
    d330:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	configASSERT( uxSchedulerSuspended );
    d334:	4c32      	ldr	r4, [pc, #200]	; (d400 <xTaskResumeAll+0xd0>)
    d336:	6823      	ldr	r3, [r4, #0]
    d338:	b903      	cbnz	r3, d33c <xTaskResumeAll+0xc>
    d33a:	e7fe      	b.n	d33a <xTaskResumeAll+0xa>
	taskENTER_CRITICAL();
    d33c:	f000 fe2a 	bl	df94 <vPortEnterCritical>
		--uxSchedulerSuspended;
    d340:	6823      	ldr	r3, [r4, #0]
    d342:	3b01      	subs	r3, #1
    d344:	6023      	str	r3, [r4, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    d346:	6824      	ldr	r4, [r4, #0]
    d348:	bb7c      	cbnz	r4, d3aa <xTaskResumeAll+0x7a>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    d34a:	4b2e      	ldr	r3, [pc, #184]	; (d404 <xTaskResumeAll+0xd4>)
    d34c:	681b      	ldr	r3, [r3, #0]
    d34e:	b363      	cbz	r3, d3aa <xTaskResumeAll+0x7a>
    d350:	4e2d      	ldr	r6, [pc, #180]	; (d408 <xTaskResumeAll+0xd8>)
    d352:	4f2e      	ldr	r7, [pc, #184]	; (d40c <xTaskResumeAll+0xdc>)
					prvAddTaskToReadyList( pxTCB );
    d354:	4d2e      	ldr	r5, [pc, #184]	; (d410 <xTaskResumeAll+0xe0>)
    d356:	f8df 90cc 	ldr.w	r9, [pc, #204]	; d424 <xTaskResumeAll+0xf4>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    d35a:	f8df 80cc 	ldr.w	r8, [pc, #204]	; d428 <xTaskResumeAll+0xf8>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    d35e:	683b      	ldr	r3, [r7, #0]
    d360:	b34b      	cbz	r3, d3b6 <xTaskResumeAll+0x86>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    d362:	68fb      	ldr	r3, [r7, #12]
    d364:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    d366:	f104 0a04 	add.w	sl, r4, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    d36a:	f104 0018 	add.w	r0, r4, #24
    d36e:	f7ff f80b 	bl	c388 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    d372:	4650      	mov	r0, sl
    d374:	f7ff f808 	bl	c388 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    d378:	4620      	mov	r0, r4
    d37a:	f003 fe2b 	bl	10fd4 <SEGGER_SYSVIEW_OnTaskStartReady>
    d37e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    d380:	682a      	ldr	r2, [r5, #0]
    d382:	eb03 0083 	add.w	r0, r3, r3, lsl #2
    d386:	4293      	cmp	r3, r2
    d388:	4651      	mov	r1, sl
    d38a:	eb09 0080 	add.w	r0, r9, r0, lsl #2
    d38e:	bf88      	it	hi
    d390:	602b      	strhi	r3, [r5, #0]
    d392:	f7fe ffcf 	bl	c334 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    d396:	f8d8 3000 	ldr.w	r3, [r8]
    d39a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    d39c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    d39e:	429a      	cmp	r2, r3
						xYieldPending = pdTRUE;
    d3a0:	f04f 0301 	mov.w	r3, #1
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    d3a4:	d3db      	bcc.n	d35e <xTaskResumeAll+0x2e>
						xYieldPending = pdTRUE;
    d3a6:	6033      	str	r3, [r6, #0]
    d3a8:	e7d9      	b.n	d35e <xTaskResumeAll+0x2e>
BaseType_t xAlreadyYielded = pdFALSE;
    d3aa:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
    d3ac:	f000 fe0c 	bl	dfc8 <vPortExitCritical>
}
    d3b0:	4620      	mov	r0, r4
    d3b2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				if( pxTCB != NULL )
    d3b6:	b13c      	cbz	r4, d3c8 <xTaskResumeAll+0x98>
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    d3b8:	4b16      	ldr	r3, [pc, #88]	; (d414 <xTaskResumeAll+0xe4>)
    d3ba:	681b      	ldr	r3, [r3, #0]
    d3bc:	681b      	ldr	r3, [r3, #0]
    d3be:	b9db      	cbnz	r3, d3f8 <xTaskResumeAll+0xc8>
		xNextTaskUnblockTime = portMAX_DELAY;
    d3c0:	4b15      	ldr	r3, [pc, #84]	; (d418 <xTaskResumeAll+0xe8>)
    d3c2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    d3c6:	601a      	str	r2, [r3, #0]
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    d3c8:	4d14      	ldr	r5, [pc, #80]	; (d41c <xTaskResumeAll+0xec>)
    d3ca:	682c      	ldr	r4, [r5, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
    d3cc:	b13c      	cbz	r4, d3de <xTaskResumeAll+0xae>
								xYieldPending = pdTRUE;
    d3ce:	2701      	movs	r7, #1
							if( xTaskIncrementTick() != pdFALSE )
    d3d0:	f7ff ff10 	bl	d1f4 <xTaskIncrementTick>
    d3d4:	b100      	cbz	r0, d3d8 <xTaskResumeAll+0xa8>
								xYieldPending = pdTRUE;
    d3d6:	6037      	str	r7, [r6, #0]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    d3d8:	3c01      	subs	r4, #1
    d3da:	d1f9      	bne.n	d3d0 <xTaskResumeAll+0xa0>
						uxPendedTicks = 0;
    d3dc:	602c      	str	r4, [r5, #0]
				if( xYieldPending != pdFALSE )
    d3de:	6833      	ldr	r3, [r6, #0]
    d3e0:	2b00      	cmp	r3, #0
    d3e2:	d0e2      	beq.n	d3aa <xTaskResumeAll+0x7a>
					taskYIELD_IF_USING_PREEMPTION();
    d3e4:	4b0e      	ldr	r3, [pc, #56]	; (d420 <xTaskResumeAll+0xf0>)
    d3e6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    d3ea:	601a      	str	r2, [r3, #0]
    d3ec:	f3bf 8f4f 	dsb	sy
    d3f0:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
    d3f4:	2401      	movs	r4, #1
    d3f6:	e7d9      	b.n	d3ac <xTaskResumeAll+0x7c>
    d3f8:	f7ff fc62 	bl	ccc0 <prvResetNextTaskUnblockTime.part.2>
    d3fc:	e7e4      	b.n	d3c8 <xTaskResumeAll+0x98>
    d3fe:	bf00      	nop
    d400:	10002c4c 	.word	0x10002c4c
    d404:	10002c44 	.word	0x10002c44
    d408:	10002cbc 	.word	0x10002cbc
    d40c:	10002c8c 	.word	0x10002c8c
    d410:	10002c54 	.word	0x10002c54
    d414:	10002bb0 	.word	0x10002bb0
    d418:	10002c84 	.word	0x10002c84
    d41c:	10002c48 	.word	0x10002c48
    d420:	e000ed04 	.word	0xe000ed04
    d424:	10002bb8 	.word	0x10002bb8
    d428:	10002bac 	.word	0x10002bac

0000d42c <vTaskDelay>:
	{
    d42c:	b538      	push	{r3, r4, r5, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
    d42e:	b190      	cbz	r0, d456 <vTaskDelay+0x2a>
			configASSERT( uxSchedulerSuspended == 0 );
    d430:	4b0d      	ldr	r3, [pc, #52]	; (d468 <vTaskDelay+0x3c>)
    d432:	681d      	ldr	r5, [r3, #0]
    d434:	b105      	cbz	r5, d438 <vTaskDelay+0xc>
    d436:	e7fe      	b.n	d436 <vTaskDelay+0xa>
	++uxSchedulerSuspended;
    d438:	681a      	ldr	r2, [r3, #0]
				traceTASK_DELAY();
    d43a:	4601      	mov	r1, r0
	++uxSchedulerSuspended;
    d43c:	3201      	adds	r2, #1
    d43e:	4604      	mov	r4, r0
				traceTASK_DELAY();
    d440:	2023      	movs	r0, #35	; 0x23
	++uxSchedulerSuspended;
    d442:	601a      	str	r2, [r3, #0]
				traceTASK_DELAY();
    d444:	f004 fb6c 	bl	11b20 <SEGGER_SYSVIEW_RecordU32>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    d448:	4629      	mov	r1, r5
    d44a:	4620      	mov	r0, r4
    d44c:	f7ff fc44 	bl	ccd8 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
    d450:	f7ff ff6e 	bl	d330 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
    d454:	b938      	cbnz	r0, d466 <vTaskDelay+0x3a>
			portYIELD_WITHIN_API();
    d456:	4b05      	ldr	r3, [pc, #20]	; (d46c <vTaskDelay+0x40>)
    d458:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    d45c:	601a      	str	r2, [r3, #0]
    d45e:	f3bf 8f4f 	dsb	sy
    d462:	f3bf 8f6f 	isb	sy
	}
    d466:	bd38      	pop	{r3, r4, r5, pc}
    d468:	10002c4c 	.word	0x10002c4c
    d46c:	e000ed04 	.word	0xe000ed04

0000d470 <prvIdleTask>:
{
    d470:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d474:	f8df b09c 	ldr.w	fp, [pc, #156]	; d514 <prvIdleTask+0xa4>
    d478:	4d23      	ldr	r5, [pc, #140]	; (d508 <prvIdleTask+0x98>)
    d47a:	4c24      	ldr	r4, [pc, #144]	; (d50c <prvIdleTask+0x9c>)
    d47c:	f8df a098 	ldr.w	sl, [pc, #152]	; d518 <prvIdleTask+0xa8>
    d480:	f8df 9098 	ldr.w	r9, [pc, #152]	; d51c <prvIdleTask+0xac>
    d484:	f8df 8098 	ldr.w	r8, [pc, #152]	; d520 <prvIdleTask+0xb0>
				taskYIELD();
    d488:	4f21      	ldr	r7, [pc, #132]	; (d510 <prvIdleTask+0xa0>)
    d48a:	f04f 5680 	mov.w	r6, #268435456	; 0x10000000
    d48e:	f8db 3000 	ldr.w	r3, [fp]
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    d492:	2b01      	cmp	r3, #1
    d494:	d906      	bls.n	d4a4 <prvIdleTask+0x34>
				taskYIELD();
    d496:	603e      	str	r6, [r7, #0]
    d498:	f3bf 8f4f 	dsb	sy
    d49c:	f3bf 8f6f 	isb	sy
    d4a0:	f8db 3000 	ldr.w	r3, [fp]
			if( uxTopReadyPriority > tskIDLE_PRIORITY )
    d4a4:	682a      	ldr	r2, [r5, #0]
    d4a6:	b9f2      	cbnz	r2, d4e6 <prvIdleTask+0x76>
		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
    d4a8:	6822      	ldr	r2, [r4, #0]
    d4aa:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    d4ac:	2a00      	cmp	r2, #0
    d4ae:	d1f0      	bne.n	d492 <prvIdleTask+0x22>
		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
    d4b0:	2b01      	cmp	r3, #1
    d4b2:	d8ee      	bhi.n	d492 <prvIdleTask+0x22>
			xReturn = xNextTaskUnblockTime - xTickCount;
    d4b4:	f8da 2000 	ldr.w	r2, [sl]
    d4b8:	f8d9 1000 	ldr.w	r1, [r9]
    d4bc:	1a52      	subs	r2, r2, r1
			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
    d4be:	2a01      	cmp	r2, #1
    d4c0:	d9e7      	bls.n	d492 <prvIdleTask+0x22>
	++uxSchedulerSuspended;
    d4c2:	f8d8 3000 	ldr.w	r3, [r8]
    d4c6:	3301      	adds	r3, #1
    d4c8:	f8c8 3000 	str.w	r3, [r8]
					configASSERT( xNextTaskUnblockTime >= xTickCount );
    d4cc:	f8da 2000 	ldr.w	r2, [sl]
    d4d0:	f8d9 3000 	ldr.w	r3, [r9]
    d4d4:	429a      	cmp	r2, r3
    d4d6:	d305      	bcc.n	d4e4 <prvIdleTask+0x74>
			if( uxTopReadyPriority > tskIDLE_PRIORITY )
    d4d8:	682b      	ldr	r3, [r5, #0]
    d4da:	b133      	cbz	r3, d4ea <prvIdleTask+0x7a>
		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
    d4dc:	6823      	ldr	r3, [r4, #0]
				( void ) xTaskResumeAll();
    d4de:	f7ff ff27 	bl	d330 <xTaskResumeAll>
    d4e2:	e7d4      	b.n	d48e <prvIdleTask+0x1e>
    d4e4:	e7fe      	b.n	d4e4 <prvIdleTask+0x74>
		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
    d4e6:	6822      	ldr	r2, [r4, #0]
    d4e8:	e7d3      	b.n	d492 <prvIdleTask+0x22>
    d4ea:	6823      	ldr	r3, [r4, #0]
    d4ec:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    d4ee:	2b00      	cmp	r3, #0
    d4f0:	d1f5      	bne.n	d4de <prvIdleTask+0x6e>
			xReturn = xNextTaskUnblockTime - xTickCount;
    d4f2:	f8da 0000 	ldr.w	r0, [sl]
    d4f6:	f8d9 3000 	ldr.w	r3, [r9]
    d4fa:	1ac0      	subs	r0, r0, r3
					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
    d4fc:	2801      	cmp	r0, #1
    d4fe:	d9ee      	bls.n	d4de <prvIdleTask+0x6e>
						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
    d500:	f000 fdde 	bl	e0c0 <vPortSuppressTicksAndSleep>
    d504:	e7eb      	b.n	d4de <prvIdleTask+0x6e>
    d506:	bf00      	nop
    d508:	10002c54 	.word	0x10002c54
    d50c:	10002bac 	.word	0x10002bac
    d510:	e000ed04 	.word	0xe000ed04
    d514:	10002bb8 	.word	0x10002bb8
    d518:	10002c84 	.word	0x10002c84
    d51c:	10002cb8 	.word	0x10002cb8
    d520:	10002c4c 	.word	0x10002c4c

0000d524 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    d524:	4b40      	ldr	r3, [pc, #256]	; (d628 <vTaskSwitchContext+0x104>)
    d526:	681b      	ldr	r3, [r3, #0]
    d528:	2b00      	cmp	r3, #0
    d52a:	d154      	bne.n	d5d6 <vTaskSwitchContext+0xb2>
		xYieldPending = pdFALSE;
    d52c:	4a3f      	ldr	r2, [pc, #252]	; (d62c <vTaskSwitchContext+0x108>)
{
    d52e:	b570      	push	{r4, r5, r6, lr}
		taskCHECK_FOR_STACK_OVERFLOW();
    d530:	4c3f      	ldr	r4, [pc, #252]	; (d630 <vTaskSwitchContext+0x10c>)
		xYieldPending = pdFALSE;
    d532:	6013      	str	r3, [r2, #0]
		taskCHECK_FOR_STACK_OVERFLOW();
    d534:	6823      	ldr	r3, [r4, #0]
    d536:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    d538:	681a      	ldr	r2, [r3, #0]
    d53a:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
    d53e:	d10b      	bne.n	d558 <vTaskSwitchContext+0x34>
    d540:	685a      	ldr	r2, [r3, #4]
    d542:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
    d546:	d107      	bne.n	d558 <vTaskSwitchContext+0x34>
    d548:	689a      	ldr	r2, [r3, #8]
    d54a:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
    d54e:	d103      	bne.n	d558 <vTaskSwitchContext+0x34>
    d550:	68db      	ldr	r3, [r3, #12]
    d552:	f1b3 3fa5 	cmp.w	r3, #2779096485	; 0xa5a5a5a5
    d556:	d004      	beq.n	d562 <vTaskSwitchContext+0x3e>
    d558:	6820      	ldr	r0, [r4, #0]
    d55a:	6821      	ldr	r1, [r4, #0]
    d55c:	3134      	adds	r1, #52	; 0x34
    d55e:	f004 fe13 	bl	12188 <vApplicationStackOverflowHook>
		taskSELECT_HIGHEST_PRIORITY_TASK();
    d562:	4d34      	ldr	r5, [pc, #208]	; (d634 <vTaskSwitchContext+0x110>)
    d564:	4934      	ldr	r1, [pc, #208]	; (d638 <vTaskSwitchContext+0x114>)
    d566:	682a      	ldr	r2, [r5, #0]
    d568:	0093      	lsls	r3, r2, #2
    d56a:	1898      	adds	r0, r3, r2
    d56c:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
    d570:	bbb8      	cbnz	r0, d5e2 <vTaskSwitchContext+0xbe>
    d572:	b37a      	cbz	r2, d5d4 <vTaskSwitchContext+0xb0>
    d574:	1e53      	subs	r3, r2, #1
    d576:	eb03 0083 	add.w	r0, r3, r3, lsl #2
    d57a:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
    d57e:	bb70      	cbnz	r0, d5de <vTaskSwitchContext+0xba>
    d580:	b343      	cbz	r3, d5d4 <vTaskSwitchContext+0xb0>
    d582:	1e93      	subs	r3, r2, #2
    d584:	eb03 0083 	add.w	r0, r3, r3, lsl #2
    d588:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
    d58c:	bb38      	cbnz	r0, d5de <vTaskSwitchContext+0xba>
    d58e:	b30b      	cbz	r3, d5d4 <vTaskSwitchContext+0xb0>
    d590:	1ed3      	subs	r3, r2, #3
    d592:	eb03 0083 	add.w	r0, r3, r3, lsl #2
    d596:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
    d59a:	bb00      	cbnz	r0, d5de <vTaskSwitchContext+0xba>
    d59c:	b1d3      	cbz	r3, d5d4 <vTaskSwitchContext+0xb0>
    d59e:	1f13      	subs	r3, r2, #4
    d5a0:	eb03 0083 	add.w	r0, r3, r3, lsl #2
    d5a4:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
    d5a8:	b9c8      	cbnz	r0, d5de <vTaskSwitchContext+0xba>
    d5aa:	b19b      	cbz	r3, d5d4 <vTaskSwitchContext+0xb0>
    d5ac:	1f53      	subs	r3, r2, #5
    d5ae:	eb03 0083 	add.w	r0, r3, r3, lsl #2
    d5b2:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
    d5b6:	b990      	cbnz	r0, d5de <vTaskSwitchContext+0xba>
    d5b8:	b163      	cbz	r3, d5d4 <vTaskSwitchContext+0xb0>
    d5ba:	1f93      	subs	r3, r2, #6
    d5bc:	eb03 0083 	add.w	r0, r3, r3, lsl #2
    d5c0:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
    d5c4:	b958      	cbnz	r0, d5de <vTaskSwitchContext+0xba>
    d5c6:	b12b      	cbz	r3, d5d4 <vTaskSwitchContext+0xb0>
    d5c8:	1fd3      	subs	r3, r2, #7
    d5ca:	eb03 0283 	add.w	r2, r3, r3, lsl #2
    d5ce:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    d5d2:	b922      	cbnz	r2, d5de <vTaskSwitchContext+0xba>
    d5d4:	e7fe      	b.n	d5d4 <vTaskSwitchContext+0xb0>
		xYieldPending = pdTRUE;
    d5d6:	4b15      	ldr	r3, [pc, #84]	; (d62c <vTaskSwitchContext+0x108>)
    d5d8:	2201      	movs	r2, #1
    d5da:	601a      	str	r2, [r3, #0]
    d5dc:	4770      	bx	lr
		taskSELECT_HIGHEST_PRIORITY_TASK();
    d5de:	461a      	mov	r2, r3
    d5e0:	009b      	lsls	r3, r3, #2
    d5e2:	4413      	add	r3, r2
    d5e4:	009b      	lsls	r3, r3, #2
    d5e6:	18ce      	adds	r6, r1, r3
    d5e8:	3308      	adds	r3, #8
    d5ea:	6870      	ldr	r0, [r6, #4]
    d5ec:	6840      	ldr	r0, [r0, #4]
    d5ee:	6070      	str	r0, [r6, #4]
    d5f0:	440b      	add	r3, r1
    d5f2:	4298      	cmp	r0, r3
    d5f4:	d00d      	beq.n	d612 <vTaskSwitchContext+0xee>
    d5f6:	68c3      	ldr	r3, [r0, #12]
    d5f8:	6023      	str	r3, [r4, #0]
    d5fa:	602a      	str	r2, [r5, #0]
		traceTASK_SWITCHED_IN();
    d5fc:	6820      	ldr	r0, [r4, #0]
    d5fe:	490f      	ldr	r1, [pc, #60]	; (d63c <vTaskSwitchContext+0x118>)
    d600:	3034      	adds	r0, #52	; 0x34
    d602:	2205      	movs	r2, #5
    d604:	f006 f868 	bl	136d8 <memcmp>
    d608:	b948      	cbnz	r0, d61e <vTaskSwitchContext+0xfa>
}
    d60a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		traceTASK_SWITCHED_IN();
    d60e:	f003 b9fd 	b.w	10a0c <SEGGER_SYSVIEW_OnIdle>
		taskSELECT_HIGHEST_PRIORITY_TASK();
    d612:	2314      	movs	r3, #20
    d614:	fb03 1102 	mla	r1, r3, r2, r1
    d618:	6840      	ldr	r0, [r0, #4]
    d61a:	6048      	str	r0, [r1, #4]
    d61c:	e7eb      	b.n	d5f6 <vTaskSwitchContext+0xd2>
		traceTASK_SWITCHED_IN();
    d61e:	6820      	ldr	r0, [r4, #0]
}
    d620:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		traceTASK_SWITCHED_IN();
    d624:	f003 bc3c 	b.w	10ea0 <SEGGER_SYSVIEW_OnTaskStartExec>
    d628:	10002c4c 	.word	0x10002c4c
    d62c:	10002cbc 	.word	0x10002cbc
    d630:	10002bac 	.word	0x10002bac
    d634:	10002c54 	.word	0x10002c54
    d638:	10002bb8 	.word	0x10002bb8
    d63c:	000137f0 	.word	0x000137f0

0000d640 <vTaskPlaceOnEventList>:
	configASSERT( pxEventList );
    d640:	b318      	cbz	r0, d68a <vTaskPlaceOnEventList+0x4a>
{
    d642:	b570      	push	{r4, r5, r6, lr}
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    d644:	4d1c      	ldr	r5, [pc, #112]	; (d6b8 <vTaskPlaceOnEventList+0x78>)
    d646:	460c      	mov	r4, r1
    d648:	6829      	ldr	r1, [r5, #0]
    d64a:	3118      	adds	r1, #24
    d64c:	f7fe fe82 	bl	c354 <vListInsert>
const TickType_t xConstTickCount = xTickCount;
    d650:	4b1a      	ldr	r3, [pc, #104]	; (d6bc <vTaskPlaceOnEventList+0x7c>)
    d652:	681e      	ldr	r6, [r3, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    d654:	6828      	ldr	r0, [r5, #0]
    d656:	3004      	adds	r0, #4
    d658:	f7fe fe96 	bl	c388 <uxListRemove>
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    d65c:	1c63      	adds	r3, r4, #1
    d65e:	d015      	beq.n	d68c <vTaskPlaceOnEventList+0x4c>
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    d660:	682b      	ldr	r3, [r5, #0]
			  traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
    d662:	6828      	ldr	r0, [r5, #0]
    d664:	19a4      	adds	r4, r4, r6
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    d666:	605c      	str	r4, [r3, #4]
			  traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
    d668:	f04f 0104 	mov.w	r1, #4
			if( xTimeToWake < xConstTickCount )
    d66c:	d219      	bcs.n	d6a2 <vTaskPlaceOnEventList+0x62>
			  traceMOVED_TASK_TO_DELAYED_LIST();
    d66e:	f003 fd4b 	bl	11108 <SEGGER_SYSVIEW_OnTaskStopReady>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    d672:	4b13      	ldr	r3, [pc, #76]	; (d6c0 <vTaskPlaceOnEventList+0x80>)
    d674:	6818      	ldr	r0, [r3, #0]
    d676:	6829      	ldr	r1, [r5, #0]
    d678:	3104      	adds	r1, #4
    d67a:	f7fe fe6b 	bl	c354 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
    d67e:	4b11      	ldr	r3, [pc, #68]	; (d6c4 <vTaskPlaceOnEventList+0x84>)
    d680:	681a      	ldr	r2, [r3, #0]
    d682:	4294      	cmp	r4, r2
					xNextTaskUnblockTime = xTimeToWake;
    d684:	bf38      	it	cc
    d686:	601c      	strcc	r4, [r3, #0]
}
    d688:	bd70      	pop	{r4, r5, r6, pc}
    d68a:	e7fe      	b.n	d68a <vTaskPlaceOnEventList+0x4a>
		  traceMOVED_TASK_TO_SUSPENDED_LIST(pxCurrentTCB);
    d68c:	6828      	ldr	r0, [r5, #0]
    d68e:	211b      	movs	r1, #27
    d690:	f003 fd3a 	bl	11108 <SEGGER_SYSVIEW_OnTaskStopReady>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    d694:	6829      	ldr	r1, [r5, #0]
    d696:	480c      	ldr	r0, [pc, #48]	; (d6c8 <vTaskPlaceOnEventList+0x88>)
    d698:	3104      	adds	r1, #4
}
    d69a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    d69e:	f7fe be49 	b.w	c334 <vListInsertEnd>
			  traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
    d6a2:	f003 fd31 	bl	11108 <SEGGER_SYSVIEW_OnTaskStopReady>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    d6a6:	4b09      	ldr	r3, [pc, #36]	; (d6cc <vTaskPlaceOnEventList+0x8c>)
    d6a8:	6818      	ldr	r0, [r3, #0]
    d6aa:	6829      	ldr	r1, [r5, #0]
}
    d6ac:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    d6b0:	3104      	adds	r1, #4
    d6b2:	f7fe be4f 	b.w	c354 <vListInsert>
    d6b6:	bf00      	nop
    d6b8:	10002bac 	.word	0x10002bac
    d6bc:	10002cb8 	.word	0x10002cb8
    d6c0:	10002bb0 	.word	0x10002bb0
    d6c4:	10002c84 	.word	0x10002c84
    d6c8:	10002ca4 	.word	0x10002ca4
    d6cc:	10002bb4 	.word	0x10002bb4

0000d6d0 <vTaskPlaceOnEventListRestricted>:
		configASSERT( pxEventList );
    d6d0:	b1e0      	cbz	r0, d70c <vTaskPlaceOnEventListRestricted+0x3c>
	{
    d6d2:	b570      	push	{r4, r5, r6, lr}
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    d6d4:	4c21      	ldr	r4, [pc, #132]	; (d75c <vTaskPlaceOnEventListRestricted+0x8c>)
    d6d6:	460d      	mov	r5, r1
    d6d8:	6821      	ldr	r1, [r4, #0]
    d6da:	4616      	mov	r6, r2
    d6dc:	3118      	adds	r1, #24
    d6de:	f7fe fe29 	bl	c334 <vListInsertEnd>
		traceTASK_DELAY_UNTIL();
    d6e2:	2024      	movs	r0, #36	; 0x24
		if( xWaitIndefinitely != pdFALSE )
    d6e4:	b19e      	cbz	r6, d70e <vTaskPlaceOnEventListRestricted+0x3e>
		traceTASK_DELAY_UNTIL();
    d6e6:	f004 f8a9 	bl	1183c <SEGGER_SYSVIEW_RecordVoid>
const TickType_t xConstTickCount = xTickCount;
    d6ea:	4b1d      	ldr	r3, [pc, #116]	; (d760 <vTaskPlaceOnEventListRestricted+0x90>)
    d6ec:	681b      	ldr	r3, [r3, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    d6ee:	6820      	ldr	r0, [r4, #0]
    d6f0:	3004      	adds	r0, #4
    d6f2:	f7fe fe49 	bl	c388 <uxListRemove>
		  traceMOVED_TASK_TO_SUSPENDED_LIST(pxCurrentTCB);
    d6f6:	6820      	ldr	r0, [r4, #0]
    d6f8:	211b      	movs	r1, #27
    d6fa:	f003 fd05 	bl	11108 <SEGGER_SYSVIEW_OnTaskStopReady>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    d6fe:	6821      	ldr	r1, [r4, #0]
    d700:	4818      	ldr	r0, [pc, #96]	; (d764 <vTaskPlaceOnEventListRestricted+0x94>)
    d702:	3104      	adds	r1, #4
	}
    d704:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    d708:	f7fe be14 	b.w	c334 <vListInsertEnd>
    d70c:	e7fe      	b.n	d70c <vTaskPlaceOnEventListRestricted+0x3c>
		traceTASK_DELAY_UNTIL();
    d70e:	f004 f895 	bl	1183c <SEGGER_SYSVIEW_RecordVoid>
const TickType_t xConstTickCount = xTickCount;
    d712:	4b13      	ldr	r3, [pc, #76]	; (d760 <vTaskPlaceOnEventListRestricted+0x90>)
    d714:	681e      	ldr	r6, [r3, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    d716:	6820      	ldr	r0, [r4, #0]
    d718:	3004      	adds	r0, #4
    d71a:	f7fe fe35 	bl	c388 <uxListRemove>
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    d71e:	6823      	ldr	r3, [r4, #0]
			  traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
    d720:	6820      	ldr	r0, [r4, #0]
    d722:	19ad      	adds	r5, r5, r6
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    d724:	605d      	str	r5, [r3, #4]
			  traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
    d726:	f04f 0104 	mov.w	r1, #4
			if( xTimeToWake < xConstTickCount )
    d72a:	d20d      	bcs.n	d748 <vTaskPlaceOnEventListRestricted+0x78>
			  traceMOVED_TASK_TO_DELAYED_LIST();
    d72c:	f003 fcec 	bl	11108 <SEGGER_SYSVIEW_OnTaskStopReady>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    d730:	4b0d      	ldr	r3, [pc, #52]	; (d768 <vTaskPlaceOnEventListRestricted+0x98>)
    d732:	6818      	ldr	r0, [r3, #0]
    d734:	6821      	ldr	r1, [r4, #0]
    d736:	3104      	adds	r1, #4
    d738:	f7fe fe0c 	bl	c354 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
    d73c:	4b0b      	ldr	r3, [pc, #44]	; (d76c <vTaskPlaceOnEventListRestricted+0x9c>)
    d73e:	681a      	ldr	r2, [r3, #0]
    d740:	4295      	cmp	r5, r2
					xNextTaskUnblockTime = xTimeToWake;
    d742:	bf38      	it	cc
    d744:	601d      	strcc	r5, [r3, #0]
	}
    d746:	bd70      	pop	{r4, r5, r6, pc}
			  traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
    d748:	f003 fcde 	bl	11108 <SEGGER_SYSVIEW_OnTaskStopReady>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    d74c:	4b08      	ldr	r3, [pc, #32]	; (d770 <vTaskPlaceOnEventListRestricted+0xa0>)
    d74e:	6818      	ldr	r0, [r3, #0]
    d750:	6821      	ldr	r1, [r4, #0]
	}
    d752:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    d756:	3104      	adds	r1, #4
    d758:	f7fe bdfc 	b.w	c354 <vListInsert>
    d75c:	10002bac 	.word	0x10002bac
    d760:	10002cb8 	.word	0x10002cb8
    d764:	10002ca4 	.word	0x10002ca4
    d768:	10002bb0 	.word	0x10002bb0
    d76c:	10002c84 	.word	0x10002c84
    d770:	10002bb4 	.word	0x10002bb4

0000d774 <xTaskRemoveFromEventList>:
{
    d774:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    d776:	68c3      	ldr	r3, [r0, #12]
    d778:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
    d77a:	2c00      	cmp	r4, #0
    d77c:	d030      	beq.n	d7e0 <xTaskRemoveFromEventList+0x6c>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    d77e:	f104 0518 	add.w	r5, r4, #24
    d782:	4628      	mov	r0, r5
    d784:	f7fe fe00 	bl	c388 <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    d788:	4b1a      	ldr	r3, [pc, #104]	; (d7f4 <xTaskRemoveFromEventList+0x80>)
    d78a:	681b      	ldr	r3, [r3, #0]
    d78c:	bb4b      	cbnz	r3, d7e2 <xTaskRemoveFromEventList+0x6e>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    d78e:	1d25      	adds	r5, r4, #4
    d790:	4628      	mov	r0, r5
    d792:	f7fe fdf9 	bl	c388 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    d796:	4620      	mov	r0, r4
    d798:	f003 fc1c 	bl	10fd4 <SEGGER_SYSVIEW_OnTaskStartReady>
    d79c:	4a16      	ldr	r2, [pc, #88]	; (d7f8 <xTaskRemoveFromEventList+0x84>)
    d79e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    d7a0:	6811      	ldr	r1, [r2, #0]
    d7a2:	4816      	ldr	r0, [pc, #88]	; (d7fc <xTaskRemoveFromEventList+0x88>)
    d7a4:	428b      	cmp	r3, r1
    d7a6:	bf88      	it	hi
    d7a8:	6013      	strhi	r3, [r2, #0]
    d7aa:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    d7ae:	4629      	mov	r1, r5
    d7b0:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    d7b4:	f7fe fdbe 	bl	c334 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    d7b8:	4b11      	ldr	r3, [pc, #68]	; (d800 <xTaskRemoveFromEventList+0x8c>)
    d7ba:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    d7bc:	681b      	ldr	r3, [r3, #0]
    d7be:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    d7c0:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
    d7c2:	bf82      	ittt	hi
    d7c4:	4b0f      	ldrhi	r3, [pc, #60]	; (d804 <xTaskRemoveFromEventList+0x90>)
    d7c6:	2001      	movhi	r0, #1
    d7c8:	6018      	strhi	r0, [r3, #0]
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    d7ca:	4b0f      	ldr	r3, [pc, #60]	; (d808 <xTaskRemoveFromEventList+0x94>)
    d7cc:	681b      	ldr	r3, [r3, #0]
    d7ce:	681b      	ldr	r3, [r3, #0]
		xReturn = pdFALSE;
    d7d0:	bf98      	it	ls
    d7d2:	2000      	movls	r0, #0
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    d7d4:	b953      	cbnz	r3, d7ec <xTaskRemoveFromEventList+0x78>
		xNextTaskUnblockTime = portMAX_DELAY;
    d7d6:	4b0d      	ldr	r3, [pc, #52]	; (d80c <xTaskRemoveFromEventList+0x98>)
    d7d8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    d7dc:	601a      	str	r2, [r3, #0]
}
    d7de:	bd38      	pop	{r3, r4, r5, pc}
    d7e0:	e7fe      	b.n	d7e0 <xTaskRemoveFromEventList+0x6c>
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    d7e2:	4629      	mov	r1, r5
    d7e4:	480a      	ldr	r0, [pc, #40]	; (d810 <xTaskRemoveFromEventList+0x9c>)
    d7e6:	f7fe fda5 	bl	c334 <vListInsertEnd>
    d7ea:	e7e5      	b.n	d7b8 <xTaskRemoveFromEventList+0x44>
    d7ec:	f7ff fa68 	bl	ccc0 <prvResetNextTaskUnblockTime.part.2>
}
    d7f0:	bd38      	pop	{r3, r4, r5, pc}
    d7f2:	bf00      	nop
    d7f4:	10002c4c 	.word	0x10002c4c
    d7f8:	10002c54 	.word	0x10002c54
    d7fc:	10002bb8 	.word	0x10002bb8
    d800:	10002bac 	.word	0x10002bac
    d804:	10002cbc 	.word	0x10002cbc
    d808:	10002bb0 	.word	0x10002bb0
    d80c:	10002c84 	.word	0x10002c84
    d810:	10002c8c 	.word	0x10002c8c

0000d814 <vTaskSetTimeOutState>:
	configASSERT( pxTimeOut );
    d814:	b130      	cbz	r0, d824 <vTaskSetTimeOutState+0x10>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    d816:	4a04      	ldr	r2, [pc, #16]	; (d828 <vTaskSetTimeOutState+0x14>)
	pxTimeOut->xTimeOnEntering = xTickCount;
    d818:	4b04      	ldr	r3, [pc, #16]	; (d82c <vTaskSetTimeOutState+0x18>)
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    d81a:	6812      	ldr	r2, [r2, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    d81c:	681b      	ldr	r3, [r3, #0]
    d81e:	e9c0 2300 	strd	r2, r3, [r0]
}
    d822:	4770      	bx	lr
    d824:	e7fe      	b.n	d824 <vTaskSetTimeOutState+0x10>
    d826:	bf00      	nop
    d828:	10002c88 	.word	0x10002c88
    d82c:	10002cb8 	.word	0x10002cb8

0000d830 <xTaskCheckForTimeOut>:
	configASSERT( pxTimeOut );
    d830:	b328      	cbz	r0, d87e <xTaskCheckForTimeOut+0x4e>
	configASSERT( pxTicksToWait );
    d832:	b319      	cbz	r1, d87c <xTaskCheckForTimeOut+0x4c>
{
    d834:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    d836:	460d      	mov	r5, r1
    d838:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
    d83a:	f000 fbab 	bl	df94 <vPortEnterCritical>
			if( *pxTicksToWait == portMAX_DELAY )
    d83e:	682b      	ldr	r3, [r5, #0]
		const TickType_t xConstTickCount = xTickCount;
    d840:	f8df c048 	ldr.w	ip, [pc, #72]	; d88c <xTaskCheckForTimeOut+0x5c>
			if( *pxTicksToWait == portMAX_DELAY )
    d844:	1c5a      	adds	r2, r3, #1
		const TickType_t xConstTickCount = xTickCount;
    d846:	f8dc 1000 	ldr.w	r1, [ip]
			if( *pxTicksToWait == portMAX_DELAY )
    d84a:	d019      	beq.n	d880 <xTaskCheckForTimeOut+0x50>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    d84c:	4e0e      	ldr	r6, [pc, #56]	; (d888 <xTaskCheckForTimeOut+0x58>)
    d84e:	e9d4 0200 	ldrd	r0, r2, [r4]
    d852:	6837      	ldr	r7, [r6, #0]
    d854:	42b8      	cmp	r0, r7
    d856:	d001      	beq.n	d85c <xTaskCheckForTimeOut+0x2c>
    d858:	4291      	cmp	r1, r2
    d85a:	d213      	bcs.n	d884 <xTaskCheckForTimeOut+0x54>
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    d85c:	1a8f      	subs	r7, r1, r2
    d85e:	42bb      	cmp	r3, r7
    d860:	d910      	bls.n	d884 <xTaskCheckForTimeOut+0x54>
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    d862:	1a5b      	subs	r3, r3, r1
    d864:	4413      	add	r3, r2
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    d866:	6831      	ldr	r1, [r6, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    d868:	f8dc 2000 	ldr.w	r2, [ip]
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    d86c:	602b      	str	r3, [r5, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    d86e:	e9c4 1200 	strd	r1, r2, [r4]
			xReturn = pdFALSE;
    d872:	2500      	movs	r5, #0
	taskEXIT_CRITICAL();
    d874:	f000 fba8 	bl	dfc8 <vPortExitCritical>
}
    d878:	4628      	mov	r0, r5
    d87a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    d87c:	e7fe      	b.n	d87c <xTaskCheckForTimeOut+0x4c>
    d87e:	e7fe      	b.n	d87e <xTaskCheckForTimeOut+0x4e>
				xReturn = pdFALSE;
    d880:	2500      	movs	r5, #0
    d882:	e7f7      	b.n	d874 <xTaskCheckForTimeOut+0x44>
			xReturn = pdTRUE;
    d884:	2501      	movs	r5, #1
    d886:	e7f5      	b.n	d874 <xTaskCheckForTimeOut+0x44>
    d888:	10002c88 	.word	0x10002c88
    d88c:	10002cb8 	.word	0x10002cb8

0000d890 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
    d890:	4b01      	ldr	r3, [pc, #4]	; (d898 <vTaskMissedYield+0x8>)
    d892:	2201      	movs	r2, #1
    d894:	601a      	str	r2, [r3, #0]
}
    d896:	4770      	bx	lr
    d898:	10002cbc 	.word	0x10002cbc

0000d89c <eTaskConfirmSleepModeStatus>:
		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
    d89c:	4b08      	ldr	r3, [pc, #32]	; (d8c0 <eTaskConfirmSleepModeStatus+0x24>)
    d89e:	6818      	ldr	r0, [r3, #0]
    d8a0:	b960      	cbnz	r0, d8bc <eTaskConfirmSleepModeStatus+0x20>
		else if( xYieldPending != pdFALSE )
    d8a2:	4b08      	ldr	r3, [pc, #32]	; (d8c4 <eTaskConfirmSleepModeStatus+0x28>)
    d8a4:	681b      	ldr	r3, [r3, #0]
    d8a6:	b953      	cbnz	r3, d8be <eTaskConfirmSleepModeStatus+0x22>
			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
    d8a8:	4b07      	ldr	r3, [pc, #28]	; (d8c8 <eTaskConfirmSleepModeStatus+0x2c>)
    d8aa:	4a08      	ldr	r2, [pc, #32]	; (d8cc <eTaskConfirmSleepModeStatus+0x30>)
    d8ac:	681b      	ldr	r3, [r3, #0]
    d8ae:	6810      	ldr	r0, [r2, #0]
    d8b0:	3b01      	subs	r3, #1
				eReturn = eNoTasksWaitingTimeout;
    d8b2:	4298      	cmp	r0, r3
    d8b4:	bf14      	ite	ne
    d8b6:	2001      	movne	r0, #1
    d8b8:	2002      	moveq	r0, #2
    d8ba:	4770      	bx	lr
			eReturn = eAbortSleep;
    d8bc:	2000      	movs	r0, #0
	}
    d8be:	4770      	bx	lr
    d8c0:	10002c8c 	.word	0x10002c8c
    d8c4:	10002cbc 	.word	0x10002cbc
    d8c8:	10002c44 	.word	0x10002c44
    d8cc:	10002ca4 	.word	0x10002ca4

0000d8d0 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
    d8d0:	4b05      	ldr	r3, [pc, #20]	; (d8e8 <xTaskGetSchedulerState+0x18>)
    d8d2:	681b      	ldr	r3, [r3, #0]
    d8d4:	b133      	cbz	r3, d8e4 <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    d8d6:	4b05      	ldr	r3, [pc, #20]	; (d8ec <xTaskGetSchedulerState+0x1c>)
    d8d8:	681b      	ldr	r3, [r3, #0]
    d8da:	2b00      	cmp	r3, #0
				xReturn = taskSCHEDULER_SUSPENDED;
    d8dc:	bf0c      	ite	eq
    d8de:	2002      	moveq	r0, #2
    d8e0:	2000      	movne	r0, #0
    d8e2:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
    d8e4:	2001      	movs	r0, #1
	}
    d8e6:	4770      	bx	lr
    d8e8:	10002ca0 	.word	0x10002ca0
    d8ec:	10002c4c 	.word	0x10002c4c

0000d8f0 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    d8f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d8f4:	4eae      	ldr	r6, [pc, #696]	; (dbb0 <prvTimerTask+0x2c0>)
    d8f6:	f8df 82c4 	ldr.w	r8, [pc, #708]	; dbbc <prvTimerTask+0x2cc>
    d8fa:	4dae      	ldr	r5, [pc, #696]	; (dbb4 <prvTimerTask+0x2c4>)
    d8fc:	f8df a2c0 	ldr.w	sl, [pc, #704]	; dbc0 <prvTimerTask+0x2d0>
    d900:	b08b      	sub	sp, #44	; 0x2c
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    d902:	6833      	ldr	r3, [r6, #0]
	if( *pxListWasEmpty == pdFALSE )
    d904:	681c      	ldr	r4, [r3, #0]
    d906:	2c00      	cmp	r4, #0
    d908:	f000 808c 	beq.w	da24 <prvTimerTask+0x134>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    d90c:	68db      	ldr	r3, [r3, #12]
    d90e:	681c      	ldr	r4, [r3, #0]
	vTaskSuspendAll();
    d910:	f7ff fc4e 	bl	d1b0 <vTaskSuspendAll>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    d914:	f7ff fc54 	bl	d1c0 <xTaskGetTickCount>

	if( xTimeNow < xLastTime )
    d918:	f8d8 3000 	ldr.w	r3, [r8]
    d91c:	4283      	cmp	r3, r0
	xTimeNow = xTaskGetTickCount();
    d91e:	4607      	mov	r7, r0
	if( xTimeNow < xLastTime )
    d920:	d859      	bhi.n	d9d6 <prvTimerTask+0xe6>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    d922:	4284      	cmp	r4, r0
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
	}

	xLastTime = xTimeNow;
    d924:	f8c8 0000 	str.w	r0, [r8]
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    d928:	f240 80bc 	bls.w	daa4 <prvTimerTask+0x1b4>
    d92c:	2200      	movs	r2, #0
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    d92e:	1be1      	subs	r1, r4, r7
    d930:	6828      	ldr	r0, [r5, #0]
    d932:	f7ff f95f 	bl	cbf4 <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
    d936:	f7ff fcfb 	bl	d330 <xTaskResumeAll>
    d93a:	b938      	cbnz	r0, d94c <prvTimerTask+0x5c>
					portYIELD_WITHIN_API();
    d93c:	4a9e      	ldr	r2, [pc, #632]	; (dbb8 <prvTimerTask+0x2c8>)
    d93e:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    d942:	6013      	str	r3, [r2, #0]
    d944:	f3bf 8f4f 	dsb	sy
    d948:	f3bf 8f6f 	isb	sy
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    d94c:	2300      	movs	r3, #0
    d94e:	461a      	mov	r2, r3
    d950:	a902      	add	r1, sp, #8
    d952:	6828      	ldr	r0, [r5, #0]
    d954:	f7fe ffb0 	bl	c8b8 <xQueueGenericReceive>
    d958:	2800      	cmp	r0, #0
    d95a:	d0d2      	beq.n	d902 <prvTimerTask+0x12>
	{
		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
		{
			/* Negative commands are pended function calls rather than timer
			commands. */
			if( xMessage.xMessageID < ( BaseType_t ) 0 )
    d95c:	9b02      	ldr	r3, [sp, #8]
    d95e:	9c04      	ldr	r4, [sp, #16]
    d960:	2b00      	cmp	r3, #0
    d962:	da07      	bge.n	d974 <prvTimerTask+0x84>
				/* The timer uses the xCallbackParameters member to request a
				callback be executed.  Check the callback is not NULL. */
				configASSERT( pxCallback );

				/* Call the function. */
				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
    d964:	9b03      	ldr	r3, [sp, #12]
    d966:	9905      	ldr	r1, [sp, #20]
    d968:	4620      	mov	r0, r4
    d96a:	4798      	blx	r3
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    d96c:	9b02      	ldr	r3, [sp, #8]
    d96e:	2b00      	cmp	r3, #0
    d970:	dbec      	blt.n	d94c <prvTimerTask+0x5c>
    d972:	9c04      	ldr	r4, [sp, #16]
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    d974:	6963      	ldr	r3, [r4, #20]
    d976:	b113      	cbz	r3, d97e <prvTimerTask+0x8e>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    d978:	1d20      	adds	r0, r4, #4
    d97a:	f7fe fd05 	bl	c388 <uxListRemove>
	xTimeNow = xTaskGetTickCount();
    d97e:	f7ff fc1f 	bl	d1c0 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
    d982:	f8d8 3000 	ldr.w	r3, [r8]
    d986:	4298      	cmp	r0, r3
	xTimeNow = xTaskGetTickCount();
    d988:	4681      	mov	r9, r0
	if( xTimeNow < xLastTime )
    d98a:	d341      	bcc.n	da10 <prvTimerTask+0x120>
    d98c:	9b02      	ldr	r3, [sp, #8]
	xLastTime = xTimeNow;
    d98e:	f8c8 9000 	str.w	r9, [r8]
    d992:	2b09      	cmp	r3, #9
    d994:	d8da      	bhi.n	d94c <prvTimerTask+0x5c>
    d996:	2201      	movs	r2, #1
    d998:	fa02 f303 	lsl.w	r3, r2, r3
    d99c:	f413 7f04 	tst.w	r3, #528	; 0x210
    d9a0:	f040 80f3 	bne.w	db8a <prvTimerTask+0x29a>
    d9a4:	f013 0fc7 	tst.w	r3, #199	; 0xc7
    d9a8:	f040 80c5 	bne.w	db36 <prvTimerTask+0x246>
    d9ac:	069b      	lsls	r3, r3, #26
    d9ae:	d5cd      	bpl.n	d94c <prvTimerTask+0x5c>
					allocated. */
					#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
					{
						/* The timer can only have been allocated dynamically -
						free it again. */
						vPortFree( pxTimer );
    d9b0:	4620      	mov	r0, r4
    d9b2:	f000 fa6f 	bl	de94 <vPortFree>
    d9b6:	e7c9      	b.n	d94c <prvTimerTask+0x5c>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    d9b8:	68db      	ldr	r3, [r3, #12]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    d9ba:	68dc      	ldr	r4, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    d9bc:	f8d3 b000 	ldr.w	fp, [r3]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    d9c0:	f104 0904 	add.w	r9, r4, #4
    d9c4:	4648      	mov	r0, r9
    d9c6:	f7fe fcdf 	bl	c388 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    d9ca:	6a63      	ldr	r3, [r4, #36]	; 0x24
    d9cc:	4620      	mov	r0, r4
    d9ce:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    d9d0:	69e3      	ldr	r3, [r4, #28]
    d9d2:	2b01      	cmp	r3, #1
    d9d4:	d038      	beq.n	da48 <prvTimerTask+0x158>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    d9d6:	6833      	ldr	r3, [r6, #0]
    d9d8:	681a      	ldr	r2, [r3, #0]
    d9da:	2a00      	cmp	r2, #0
    d9dc:	d1ec      	bne.n	d9b8 <prvTimerTask+0xc8>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    d9de:	f8da 2000 	ldr.w	r2, [sl]
	xLastTime = xTimeNow;
    d9e2:	f8c8 7000 	str.w	r7, [r8]
	pxCurrentTimerList = pxOverflowTimerList;
    d9e6:	6032      	str	r2, [r6, #0]
	pxOverflowTimerList = pxTemp;
    d9e8:	f8ca 3000 	str.w	r3, [sl]
			( void ) xTaskResumeAll();
    d9ec:	f7ff fca0 	bl	d330 <xTaskResumeAll>
    d9f0:	e7ac      	b.n	d94c <prvTimerTask+0x5c>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    d9f2:	68db      	ldr	r3, [r3, #12]
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    d9f4:	68df      	ldr	r7, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    d9f6:	681b      	ldr	r3, [r3, #0]
    d9f8:	9301      	str	r3, [sp, #4]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    d9fa:	f107 0b04 	add.w	fp, r7, #4
    d9fe:	4658      	mov	r0, fp
    da00:	f7fe fcc2 	bl	c388 <uxListRemove>
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    da04:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    da06:	4638      	mov	r0, r7
    da08:	4798      	blx	r3
		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    da0a:	69fb      	ldr	r3, [r7, #28]
    da0c:	2b01      	cmp	r3, #1
    da0e:	d031      	beq.n	da74 <prvTimerTask+0x184>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    da10:	6833      	ldr	r3, [r6, #0]
    da12:	681a      	ldr	r2, [r3, #0]
    da14:	2a00      	cmp	r2, #0
    da16:	d1ec      	bne.n	d9f2 <prvTimerTask+0x102>
	pxCurrentTimerList = pxOverflowTimerList;
    da18:	f8da 2000 	ldr.w	r2, [sl]
    da1c:	6032      	str	r2, [r6, #0]
	pxOverflowTimerList = pxTemp;
    da1e:	f8ca 3000 	str.w	r3, [sl]
    da22:	e7b3      	b.n	d98c <prvTimerTask+0x9c>
	vTaskSuspendAll();
    da24:	f7ff fbc4 	bl	d1b0 <vTaskSuspendAll>
	xTimeNow = xTaskGetTickCount();
    da28:	f7ff fbca 	bl	d1c0 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
    da2c:	f8d8 3000 	ldr.w	r3, [r8]
    da30:	4298      	cmp	r0, r3
	xTimeNow = xTaskGetTickCount();
    da32:	4607      	mov	r7, r0
	if( xTimeNow < xLastTime )
    da34:	d3cf      	bcc.n	d9d6 <prvTimerTask+0xe6>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    da36:	f8da 3000 	ldr.w	r3, [sl]
	xLastTime = xTimeNow;
    da3a:	f8c8 7000 	str.w	r7, [r8]
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    da3e:	681a      	ldr	r2, [r3, #0]
    da40:	fab2 f282 	clz	r2, r2
    da44:	0952      	lsrs	r2, r2, #5
    da46:	e772      	b.n	d92e <prvTimerTask+0x3e>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    da48:	69a3      	ldr	r3, [r4, #24]
    da4a:	445b      	add	r3, fp
			if( xReloadTime > xNextExpireTime )
    da4c:	459b      	cmp	fp, r3
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    da4e:	4649      	mov	r1, r9
			if( xReloadTime > xNextExpireTime )
    da50:	d342      	bcc.n	dad8 <prvTimerTask+0x1e8>
	if( xTimerQueue != NULL )
    da52:	682b      	ldr	r3, [r5, #0]
    da54:	b16b      	cbz	r3, da72 <prvTimerTask+0x182>
		xMessage.xMessageID = xCommandID;
    da56:	2300      	movs	r3, #0
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    da58:	e9cd 3b06 	strd	r3, fp, [sp, #24]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    da5c:	9408      	str	r4, [sp, #32]
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    da5e:	f7ff ff37 	bl	d8d0 <xTaskGetSchedulerState>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    da62:	2300      	movs	r3, #0
    da64:	461a      	mov	r2, r3
    da66:	a906      	add	r1, sp, #24
    da68:	6828      	ldr	r0, [r5, #0]
    da6a:	f7fe fce5 	bl	c438 <xQueueGenericSend>
				configASSERT( xResult );
    da6e:	2800      	cmp	r0, #0
    da70:	d1b1      	bne.n	d9d6 <prvTimerTask+0xe6>
    da72:	e7fe      	b.n	da72 <prvTimerTask+0x182>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    da74:	9a01      	ldr	r2, [sp, #4]
    da76:	69bb      	ldr	r3, [r7, #24]
    da78:	4413      	add	r3, r2
			if( xReloadTime > xNextExpireTime )
    da7a:	429a      	cmp	r2, r3
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    da7c:	4659      	mov	r1, fp
			if( xReloadTime > xNextExpireTime )
    da7e:	d325      	bcc.n	dacc <prvTimerTask+0x1dc>
	if( xTimerQueue != NULL )
    da80:	682b      	ldr	r3, [r5, #0]
    da82:	b173      	cbz	r3, daa2 <prvTimerTask+0x1b2>
		xMessage.xMessageID = xCommandID;
    da84:	2300      	movs	r3, #0
    da86:	9306      	str	r3, [sp, #24]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    da88:	9b01      	ldr	r3, [sp, #4]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    da8a:	e9cd 3707 	strd	r3, r7, [sp, #28]
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    da8e:	f7ff ff1f 	bl	d8d0 <xTaskGetSchedulerState>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    da92:	2300      	movs	r3, #0
    da94:	461a      	mov	r2, r3
    da96:	a906      	add	r1, sp, #24
    da98:	6828      	ldr	r0, [r5, #0]
    da9a:	f7fe fccd 	bl	c438 <xQueueGenericSend>
				configASSERT( xResult );
    da9e:	2800      	cmp	r0, #0
    daa0:	d1b6      	bne.n	da10 <prvTimerTask+0x120>
    daa2:	e7fe      	b.n	daa2 <prvTimerTask+0x1b2>
				( void ) xTaskResumeAll();
    daa4:	f7ff fc44 	bl	d330 <xTaskResumeAll>
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    daa8:	6833      	ldr	r3, [r6, #0]
    daaa:	68db      	ldr	r3, [r3, #12]
    daac:	f8d3 900c 	ldr.w	r9, [r3, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    dab0:	f109 0b04 	add.w	fp, r9, #4
    dab4:	4658      	mov	r0, fp
    dab6:	f7fe fc67 	bl	c388 <uxListRemove>
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    daba:	f8d9 301c 	ldr.w	r3, [r9, #28]
    dabe:	2b01      	cmp	r3, #1
    dac0:	d010      	beq.n	dae4 <prvTimerTask+0x1f4>
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    dac2:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
    dac6:	4648      	mov	r0, r9
    dac8:	4798      	blx	r3
    daca:	e73f      	b.n	d94c <prvTimerTask+0x5c>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    dacc:	607b      	str	r3, [r7, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    dace:	613f      	str	r7, [r7, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    dad0:	6830      	ldr	r0, [r6, #0]
    dad2:	f7fe fc3f 	bl	c354 <vListInsert>
    dad6:	e79b      	b.n	da10 <prvTimerTask+0x120>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    dad8:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    dada:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    dadc:	6830      	ldr	r0, [r6, #0]
    dade:	f7fe fc39 	bl	c354 <vListInsert>
    dae2:	e778      	b.n	d9d6 <prvTimerTask+0xe6>
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    dae4:	f8d9 3018 	ldr.w	r3, [r9, #24]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    dae8:	f8c9 9010 	str.w	r9, [r9, #16]
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    daec:	18e2      	adds	r2, r4, r3
	if( xNextExpiryTime <= xTimeNow )
    daee:	42ba      	cmp	r2, r7
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    daf0:	f8c9 2004 	str.w	r2, [r9, #4]
	if( xNextExpiryTime <= xTimeNow )
    daf4:	d81a      	bhi.n	db2c <prvTimerTask+0x23c>
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    daf6:	1b3f      	subs	r7, r7, r4
    daf8:	42bb      	cmp	r3, r7
    dafa:	d811      	bhi.n	db20 <prvTimerTask+0x230>
	if( xTimerQueue != NULL )
    dafc:	682b      	ldr	r3, [r5, #0]
    dafe:	b173      	cbz	r3, db1e <prvTimerTask+0x22e>
		xMessage.xMessageID = xCommandID;
    db00:	2300      	movs	r3, #0
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    db02:	e9cd 3406 	strd	r3, r4, [sp, #24]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    db06:	f8cd 9020 	str.w	r9, [sp, #32]
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    db0a:	f7ff fee1 	bl	d8d0 <xTaskGetSchedulerState>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    db0e:	2300      	movs	r3, #0
    db10:	461a      	mov	r2, r3
    db12:	a906      	add	r1, sp, #24
    db14:	6828      	ldr	r0, [r5, #0]
    db16:	f7fe fc8f 	bl	c438 <xQueueGenericSend>
			configASSERT( xResult );
    db1a:	2800      	cmp	r0, #0
    db1c:	d1d1      	bne.n	dac2 <prvTimerTask+0x1d2>
    db1e:	e7fe      	b.n	db1e <prvTimerTask+0x22e>
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    db20:	4659      	mov	r1, fp
    db22:	f8da 0000 	ldr.w	r0, [sl]
    db26:	f7fe fc15 	bl	c354 <vListInsert>
    db2a:	e7ca      	b.n	dac2 <prvTimerTask+0x1d2>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    db2c:	4659      	mov	r1, fp
    db2e:	6830      	ldr	r0, [r6, #0]
    db30:	f7fe fc10 	bl	c354 <vListInsert>
    db34:	e7c5      	b.n	dac2 <prvTimerTask+0x1d2>
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    db36:	9b03      	ldr	r3, [sp, #12]
    db38:	69a2      	ldr	r2, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    db3a:	6124      	str	r4, [r4, #16]
    db3c:	1899      	adds	r1, r3, r2
    db3e:	bf2c      	ite	cs
    db40:	2001      	movcs	r0, #1
    db42:	2000      	movcc	r0, #0
	if( xNextExpiryTime <= xTimeNow )
    db44:	4549      	cmp	r1, r9
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    db46:	6061      	str	r1, [r4, #4]
	if( xNextExpiryTime <= xTimeNow )
    db48:	d842      	bhi.n	dbd0 <prvTimerTask+0x2e0>
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    db4a:	eba9 0303 	sub.w	r3, r9, r3
    db4e:	429a      	cmp	r2, r3
    db50:	d838      	bhi.n	dbc4 <prvTimerTask+0x2d4>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    db52:	6a63      	ldr	r3, [r4, #36]	; 0x24
    db54:	4620      	mov	r0, r4
    db56:	4798      	blx	r3
						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    db58:	69e3      	ldr	r3, [r4, #28]
    db5a:	2b01      	cmp	r3, #1
    db5c:	f47f aef6 	bne.w	d94c <prvTimerTask+0x5c>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    db60:	9b03      	ldr	r3, [sp, #12]
    db62:	69a1      	ldr	r1, [r4, #24]
	if( xTimerQueue != NULL )
    db64:	682a      	ldr	r2, [r5, #0]
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    db66:	440b      	add	r3, r1
	if( xTimerQueue != NULL )
    db68:	b302      	cbz	r2, dbac <prvTimerTask+0x2bc>
		xMessage.xMessageID = xCommandID;
    db6a:	2200      	movs	r2, #0
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    db6c:	e9cd 2306 	strd	r2, r3, [sp, #24]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    db70:	9408      	str	r4, [sp, #32]
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    db72:	f7ff fead 	bl	d8d0 <xTaskGetSchedulerState>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    db76:	2300      	movs	r3, #0
    db78:	461a      	mov	r2, r3
    db7a:	a906      	add	r1, sp, #24
    db7c:	6828      	ldr	r0, [r5, #0]
    db7e:	f7fe fc5b 	bl	c438 <xQueueGenericSend>
							configASSERT( xResult );
    db82:	2800      	cmp	r0, #0
    db84:	f47f aee2 	bne.w	d94c <prvTimerTask+0x5c>
    db88:	e7fe      	b.n	db88 <prvTimerTask+0x298>
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    db8a:	9b03      	ldr	r3, [sp, #12]
    db8c:	61a3      	str	r3, [r4, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    db8e:	b163      	cbz	r3, dbaa <prvTimerTask+0x2ba>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    db90:	444b      	add	r3, r9
	if( xNextExpiryTime <= xTimeNow )
    db92:	454b      	cmp	r3, r9
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    db94:	6063      	str	r3, [r4, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    db96:	6124      	str	r4, [r4, #16]
    db98:	f104 0104 	add.w	r1, r4, #4
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    db9c:	bf94      	ite	ls
    db9e:	f8da 0000 	ldrls.w	r0, [sl]
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    dba2:	6830      	ldrhi	r0, [r6, #0]
    dba4:	f7fe fbd6 	bl	c354 <vListInsert>
    dba8:	e6d0      	b.n	d94c <prvTimerTask+0x5c>
    dbaa:	e7fe      	b.n	dbaa <prvTimerTask+0x2ba>
    dbac:	e7ec      	b.n	db88 <prvTimerTask+0x298>
    dbae:	bf00      	nop
    dbb0:	10002cc0 	.word	0x10002cc0
    dbb4:	10002cf4 	.word	0x10002cf4
    dbb8:	e000ed04 	.word	0xe000ed04
    dbbc:	10002cf0 	.word	0x10002cf0
    dbc0:	10002cc4 	.word	0x10002cc4
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    dbc4:	1d21      	adds	r1, r4, #4
    dbc6:	f8da 0000 	ldr.w	r0, [sl]
    dbca:	f7fe fbc3 	bl	c354 <vListInsert>
    dbce:	e6bd      	b.n	d94c <prvTimerTask+0x5c>
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    dbd0:	454b      	cmp	r3, r9
    dbd2:	d901      	bls.n	dbd8 <prvTimerTask+0x2e8>
    dbd4:	2800      	cmp	r0, #0
    dbd6:	d0bc      	beq.n	db52 <prvTimerTask+0x262>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    dbd8:	1d21      	adds	r1, r4, #4
    dbda:	6830      	ldr	r0, [r6, #0]
    dbdc:	f7fe fbba 	bl	c354 <vListInsert>
    dbe0:	e6b4      	b.n	d94c <prvTimerTask+0x5c>
    dbe2:	bf00      	nop

0000dbe4 <xTimerCreateTimerTask>:
{
    dbe4:	b5f0      	push	{r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
    dbe6:	4c16      	ldr	r4, [pc, #88]	; (dc40 <xTimerCreateTimerTask+0x5c>)
{
    dbe8:	b083      	sub	sp, #12
	taskENTER_CRITICAL();
    dbea:	f000 f9d3 	bl	df94 <vPortEnterCritical>
		if( xTimerQueue == NULL )
    dbee:	6826      	ldr	r6, [r4, #0]
    dbf0:	b186      	cbz	r6, dc14 <xTimerCreateTimerTask+0x30>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    dbf2:	f000 f9e9 	bl	dfc8 <vPortExitCritical>
	if( xTimerQueue != NULL )
    dbf6:	6823      	ldr	r3, [r4, #0]
    dbf8:	b15b      	cbz	r3, dc12 <xTimerCreateTimerTask+0x2e>
			xReturn = xTaskCreate(	prvTimerTask,
    dbfa:	4b12      	ldr	r3, [pc, #72]	; (dc44 <xTimerCreateTimerTask+0x60>)
    dbfc:	9301      	str	r3, [sp, #4]
    dbfe:	2303      	movs	r3, #3
    dc00:	9300      	str	r3, [sp, #0]
    dc02:	f44f 7280 	mov.w	r2, #256	; 0x100
    dc06:	2300      	movs	r3, #0
    dc08:	490f      	ldr	r1, [pc, #60]	; (dc48 <xTimerCreateTimerTask+0x64>)
    dc0a:	4810      	ldr	r0, [pc, #64]	; (dc4c <xTimerCreateTimerTask+0x68>)
    dc0c:	f7ff f8a8 	bl	cd60 <xTaskCreate>
	configASSERT( xReturn );
    dc10:	b998      	cbnz	r0, dc3a <xTimerCreateTimerTask+0x56>
    dc12:	e7fe      	b.n	dc12 <xTimerCreateTimerTask+0x2e>
			vListInitialise( &xActiveTimerList1 );
    dc14:	4f0e      	ldr	r7, [pc, #56]	; (dc50 <xTimerCreateTimerTask+0x6c>)
			vListInitialise( &xActiveTimerList2 );
    dc16:	4d0f      	ldr	r5, [pc, #60]	; (dc54 <xTimerCreateTimerTask+0x70>)
			vListInitialise( &xActiveTimerList1 );
    dc18:	4638      	mov	r0, r7
    dc1a:	f7fe fb7b 	bl	c314 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
    dc1e:	4628      	mov	r0, r5
    dc20:	f7fe fb78 	bl	c314 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
    dc24:	4a0c      	ldr	r2, [pc, #48]	; (dc58 <xTimerCreateTimerTask+0x74>)
			pxOverflowTimerList = &xActiveTimerList2;
    dc26:	4b0d      	ldr	r3, [pc, #52]	; (dc5c <xTimerCreateTimerTask+0x78>)
			pxCurrentTimerList = &xActiveTimerList1;
    dc28:	6017      	str	r7, [r2, #0]
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    dc2a:	2110      	movs	r1, #16
    dc2c:	4632      	mov	r2, r6
    dc2e:	200a      	movs	r0, #10
			pxOverflowTimerList = &xActiveTimerList2;
    dc30:	601d      	str	r5, [r3, #0]
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    dc32:	f7fe fbbd 	bl	c3b0 <xQueueGenericCreate>
    dc36:	6020      	str	r0, [r4, #0]
    dc38:	e7db      	b.n	dbf2 <xTimerCreateTimerTask+0xe>
}
    dc3a:	b003      	add	sp, #12
    dc3c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    dc3e:	bf00      	nop
    dc40:	10002cf4 	.word	0x10002cf4
    dc44:	10002cf8 	.word	0x10002cf8
    dc48:	000137f8 	.word	0x000137f8
    dc4c:	0000d8f1 	.word	0x0000d8f1
    dc50:	10002cc8 	.word	0x10002cc8
    dc54:	10002cdc 	.word	0x10002cdc
    dc58:	10002cc0 	.word	0x10002cc0
    dc5c:	10002cc4 	.word	0x10002cc4

0000dc60 <xTimerCreate>:
	{
    dc60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    dc64:	4683      	mov	fp, r0
    dc66:	b083      	sub	sp, #12
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
    dc68:	2028      	movs	r0, #40	; 0x28
	{
    dc6a:	460d      	mov	r5, r1
    dc6c:	4692      	mov	sl, r2
    dc6e:	461f      	mov	r7, r3
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
    dc70:	f000 f890 	bl	dd94 <pvPortMalloc>
		if( pxNewTimer != NULL )
    dc74:	4604      	mov	r4, r0
    dc76:	b360      	cbz	r0, dcd2 <xTimerCreate+0x72>
	configASSERT( ( xTimerPeriodInTicks > 0 ) );
    dc78:	b905      	cbnz	r5, dc7c <xTimerCreate+0x1c>
    dc7a:	e7fe      	b.n	dc7a <xTimerCreate+0x1a>
		if( xTimerQueue == NULL )
    dc7c:	4e17      	ldr	r6, [pc, #92]	; (dcdc <xTimerCreate+0x7c>)
	taskENTER_CRITICAL();
    dc7e:	f000 f989 	bl	df94 <vPortEnterCritical>
		if( xTimerQueue == NULL )
    dc82:	f8d6 9000 	ldr.w	r9, [r6]
    dc86:	f1b9 0f00 	cmp.w	r9, #0
    dc8a:	d116      	bne.n	dcba <xTimerCreate+0x5a>
			vListInitialise( &xActiveTimerList1 );
    dc8c:	4b14      	ldr	r3, [pc, #80]	; (dce0 <xTimerCreate+0x80>)
			vListInitialise( &xActiveTimerList2 );
    dc8e:	f8df 8058 	ldr.w	r8, [pc, #88]	; dce8 <xTimerCreate+0x88>
			vListInitialise( &xActiveTimerList1 );
    dc92:	9301      	str	r3, [sp, #4]
    dc94:	4618      	mov	r0, r3
    dc96:	f7fe fb3d 	bl	c314 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
    dc9a:	4640      	mov	r0, r8
    dc9c:	f7fe fb3a 	bl	c314 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
    dca0:	4910      	ldr	r1, [pc, #64]	; (dce4 <xTimerCreate+0x84>)
			pxOverflowTimerList = &xActiveTimerList2;
    dca2:	f8df c048 	ldr.w	ip, [pc, #72]	; dcec <xTimerCreate+0x8c>
			pxCurrentTimerList = &xActiveTimerList1;
    dca6:	9b01      	ldr	r3, [sp, #4]
    dca8:	600b      	str	r3, [r1, #0]
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    dcaa:	464a      	mov	r2, r9
    dcac:	2110      	movs	r1, #16
    dcae:	200a      	movs	r0, #10
			pxOverflowTimerList = &xActiveTimerList2;
    dcb0:	f8cc 8000 	str.w	r8, [ip]
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    dcb4:	f7fe fb7c 	bl	c3b0 <xQueueGenericCreate>
    dcb8:	6030      	str	r0, [r6, #0]
	taskEXIT_CRITICAL();
    dcba:	f000 f985 	bl	dfc8 <vPortExitCritical>
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    dcbe:	9b0c      	ldr	r3, [sp, #48]	; 0x30
		pxNewTimer->pcTimerName = pcTimerName;
    dcc0:	f8c4 b000 	str.w	fp, [r4]
		pxNewTimer->uxAutoReload = uxAutoReload;
    dcc4:	e9c4 5a06 	strd	r5, sl, [r4, #24]
		pxNewTimer->pvTimerID = pvTimerID;
    dcc8:	6227      	str	r7, [r4, #32]
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    dcca:	6263      	str	r3, [r4, #36]	; 0x24
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    dccc:	1d20      	adds	r0, r4, #4
    dcce:	f7fe fb2d 	bl	c32c <vListInitialiseItem>
	}
    dcd2:	4620      	mov	r0, r4
    dcd4:	b003      	add	sp, #12
    dcd6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    dcda:	bf00      	nop
    dcdc:	10002cf4 	.word	0x10002cf4
    dce0:	10002cc8 	.word	0x10002cc8
    dce4:	10002cc0 	.word	0x10002cc0
    dce8:	10002cdc 	.word	0x10002cdc
    dcec:	10002cc4 	.word	0x10002cc4

0000dcf0 <xTimerGenericCommand>:
	configASSERT( xTimer );
    dcf0:	b1c0      	cbz	r0, dd24 <xTimerGenericCommand+0x34>
{
    dcf2:	b570      	push	{r4, r5, r6, lr}
	if( xTimerQueue != NULL )
    dcf4:	4d12      	ldr	r5, [pc, #72]	; (dd40 <xTimerGenericCommand+0x50>)
    dcf6:	4604      	mov	r4, r0
    dcf8:	6828      	ldr	r0, [r5, #0]
{
    dcfa:	b084      	sub	sp, #16
	if( xTimerQueue != NULL )
    dcfc:	b180      	cbz	r0, dd20 <xTimerGenericCommand+0x30>
    dcfe:	4616      	mov	r6, r2
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    dd00:	2905      	cmp	r1, #5
    dd02:	461a      	mov	r2, r3
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    dd04:	e9cd 1600 	strd	r1, r6, [sp]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    dd08:	9402      	str	r4, [sp, #8]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    dd0a:	dc0c      	bgt.n	dd26 <xTimerGenericCommand+0x36>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    dd0c:	f7ff fde0 	bl	d8d0 <xTaskGetSchedulerState>
    dd10:	2802      	cmp	r0, #2
    dd12:	d00e      	beq.n	dd32 <xTimerGenericCommand+0x42>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    dd14:	2300      	movs	r3, #0
    dd16:	6828      	ldr	r0, [r5, #0]
    dd18:	461a      	mov	r2, r3
    dd1a:	4669      	mov	r1, sp
    dd1c:	f7fe fb8c 	bl	c438 <xQueueGenericSend>
}
    dd20:	b004      	add	sp, #16
    dd22:	bd70      	pop	{r4, r5, r6, pc}
    dd24:	e7fe      	b.n	dd24 <xTimerGenericCommand+0x34>
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    dd26:	2300      	movs	r3, #0
    dd28:	4669      	mov	r1, sp
    dd2a:	f7fe fd33 	bl	c794 <xQueueGenericSendFromISR>
}
    dd2e:	b004      	add	sp, #16
    dd30:	bd70      	pop	{r4, r5, r6, pc}
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    dd32:	6828      	ldr	r0, [r5, #0]
    dd34:	9a08      	ldr	r2, [sp, #32]
    dd36:	2300      	movs	r3, #0
    dd38:	4669      	mov	r1, sp
    dd3a:	f7fe fb7d 	bl	c438 <xQueueGenericSend>
    dd3e:	e7ef      	b.n	dd20 <xTimerGenericCommand+0x30>
    dd40:	10002cf4 	.word	0x10002cf4

0000dd44 <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
    dd44:	b410      	push	{r4}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    dd46:	4b11      	ldr	r3, [pc, #68]	; (dd8c <prvInsertBlockIntoFreeList+0x48>)
    dd48:	681a      	ldr	r2, [r3, #0]
    dd4a:	4282      	cmp	r2, r0
    dd4c:	d201      	bcs.n	dd52 <prvInsertBlockIntoFreeList+0xe>
    dd4e:	4613      	mov	r3, r2
    dd50:	e7fa      	b.n	dd48 <prvInsertBlockIntoFreeList+0x4>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    dd52:	685c      	ldr	r4, [r3, #4]
    dd54:	1919      	adds	r1, r3, r4
    dd56:	4288      	cmp	r0, r1
    dd58:	d103      	bne.n	dd62 <prvInsertBlockIntoFreeList+0x1e>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    dd5a:	6841      	ldr	r1, [r0, #4]
    dd5c:	4421      	add	r1, r4
    dd5e:	6059      	str	r1, [r3, #4]
    dd60:	4618      	mov	r0, r3
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
    dd62:	6844      	ldr	r4, [r0, #4]
    dd64:	1901      	adds	r1, r0, r4
    dd66:	428a      	cmp	r2, r1
    dd68:	d109      	bne.n	dd7e <prvInsertBlockIntoFreeList+0x3a>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
    dd6a:	4909      	ldr	r1, [pc, #36]	; (dd90 <prvInsertBlockIntoFreeList+0x4c>)
    dd6c:	6809      	ldr	r1, [r1, #0]
    dd6e:	428a      	cmp	r2, r1
    dd70:	d005      	beq.n	dd7e <prvInsertBlockIntoFreeList+0x3a>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    dd72:	e9d2 2100 	ldrd	r2, r1, [r2]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    dd76:	4421      	add	r1, r4
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    dd78:	6002      	str	r2, [r0, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    dd7a:	6041      	str	r1, [r0, #4]
    dd7c:	e000      	b.n	dd80 <prvInsertBlockIntoFreeList+0x3c>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    dd7e:	6002      	str	r2, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
    dd80:	4298      	cmp	r0, r3
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    dd82:	bf18      	it	ne
    dd84:	6018      	strne	r0, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    dd86:	f85d 4b04 	ldr.w	r4, [sp], #4
    dd8a:	4770      	bx	lr
    dd8c:	10012d0c 	.word	0x10012d0c
    dd90:	10002cfc 	.word	0x10002cfc

0000dd94 <pvPortMalloc>:
{
    dd94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    dd96:	4604      	mov	r4, r0
	vTaskSuspendAll();
    dd98:	f7ff fa0a 	bl	d1b0 <vTaskSuspendAll>
		if( pxEnd == NULL )
    dd9c:	4836      	ldr	r0, [pc, #216]	; (de78 <pvPortMalloc+0xe4>)
    dd9e:	6802      	ldr	r2, [r0, #0]
    dda0:	b352      	cbz	r2, ddf8 <pvPortMalloc+0x64>
    dda2:	4b36      	ldr	r3, [pc, #216]	; (de7c <pvPortMalloc+0xe8>)
    dda4:	681d      	ldr	r5, [r3, #0]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
    dda6:	422c      	tst	r4, r5
    dda8:	d145      	bne.n	de36 <pvPortMalloc+0xa2>
			if( xWantedSize > 0 )
    ddaa:	2c00      	cmp	r4, #0
    ddac:	d043      	beq.n	de36 <pvPortMalloc+0xa2>
				xWantedSize += xHeapStructSize;
    ddae:	f104 0308 	add.w	r3, r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
    ddb2:	0758      	lsls	r0, r3, #29
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
    ddb4:	bf1c      	itt	ne
    ddb6:	f023 0307 	bicne.w	r3, r3, #7
    ddba:	3308      	addne	r3, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    ddbc:	2b00      	cmp	r3, #0
    ddbe:	d03a      	beq.n	de36 <pvPortMalloc+0xa2>
    ddc0:	4f2f      	ldr	r7, [pc, #188]	; (de80 <pvPortMalloc+0xec>)
    ddc2:	683e      	ldr	r6, [r7, #0]
    ddc4:	429e      	cmp	r6, r3
    ddc6:	d336      	bcc.n	de36 <pvPortMalloc+0xa2>
				pxBlock = xStart.pxNextFreeBlock;
    ddc8:	482e      	ldr	r0, [pc, #184]	; (de84 <pvPortMalloc+0xf0>)
    ddca:	6804      	ldr	r4, [r0, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    ddcc:	e006      	b.n	dddc <pvPortMalloc+0x48>
    ddce:	f8d4 c000 	ldr.w	ip, [r4]
    ddd2:	f1bc 0f00 	cmp.w	ip, #0
    ddd6:	d004      	beq.n	dde2 <pvPortMalloc+0x4e>
    ddd8:	4620      	mov	r0, r4
    ddda:	4664      	mov	r4, ip
    dddc:	6861      	ldr	r1, [r4, #4]
    ddde:	4299      	cmp	r1, r3
    dde0:	d3f5      	bcc.n	ddce <pvPortMalloc+0x3a>
				if( pxBlock != pxEnd )
    dde2:	4294      	cmp	r4, r2
    dde4:	d027      	beq.n	de36 <pvPortMalloc+0xa2>
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    dde6:	6822      	ldr	r2, [r4, #0]
    dde8:	6002      	str	r2, [r0, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    ddea:	1aca      	subs	r2, r1, r3
    ddec:	2a10      	cmp	r2, #16
    ddee:	d92e      	bls.n	de4e <pvPortMalloc+0xba>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    ddf0:	18e0      	adds	r0, r4, r3
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
    ddf2:	0741      	lsls	r1, r0, #29
    ddf4:	d026      	beq.n	de44 <pvPortMalloc+0xb0>
    ddf6:	e7fe      	b.n	ddf6 <pvPortMalloc+0x62>
	uxAddress = ( size_t ) ucHeap;
    ddf8:	4b23      	ldr	r3, [pc, #140]	; (de88 <pvPortMalloc+0xf4>)
	uxAddress -= xHeapStructSize;
    ddfa:	4a24      	ldr	r2, [pc, #144]	; (de8c <pvPortMalloc+0xf8>)
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    ddfc:	4e24      	ldr	r6, [pc, #144]	; (de90 <pvPortMalloc+0xfc>)
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    ddfe:	4f20      	ldr	r7, [pc, #128]	; (de80 <pvPortMalloc+0xec>)
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
    de00:	075d      	lsls	r5, r3, #29
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
    de02:	bf18      	it	ne
    de04:	3307      	addne	r3, #7
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
    de06:	f022 0207 	bic.w	r2, r2, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
    de0a:	bf18      	it	ne
    de0c:	f023 0307 	bicne.w	r3, r3, #7
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    de10:	4d1c      	ldr	r5, [pc, #112]	; (de84 <pvPortMalloc+0xf0>)
	pxEnd = ( void * ) uxAddress;
    de12:	6002      	str	r2, [r0, #0]
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
    de14:	4619      	mov	r1, r3
	xStart.xBlockSize = ( size_t ) 0;
    de16:	2000      	movs	r0, #0
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
    de18:	1ad3      	subs	r3, r2, r3
	xStart.xBlockSize = ( size_t ) 0;
    de1a:	e9c5 1000 	strd	r1, r0, [r5]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    de1e:	6033      	str	r3, [r6, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    de20:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
    de24:	4e15      	ldr	r6, [pc, #84]	; (de7c <pvPortMalloc+0xe8>)
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    de26:	603b      	str	r3, [r7, #0]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
    de28:	422c      	tst	r4, r5
	pxEnd->pxNextFreeBlock = NULL;
    de2a:	e9c2 0000 	strd	r0, r0, [r2]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    de2e:	6035      	str	r5, [r6, #0]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
    de30:	e9c1 2300 	strd	r2, r3, [r1]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
    de34:	d0b9      	beq.n	ddaa <pvPortMalloc+0x16>
	( void ) xTaskResumeAll();
    de36:	f7ff fa7b 	bl	d330 <xTaskResumeAll>
			vApplicationMallocFailedHook();
    de3a:	f004 f9a3 	bl	12184 <vApplicationMallocFailedHook>
    de3e:	2400      	movs	r4, #0
}
    de40:	4620      	mov	r0, r4
    de42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    de44:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
    de46:	6063      	str	r3, [r4, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
    de48:	f7ff ff7c 	bl	dd44 <prvInsertBlockIntoFreeList>
    de4c:	6861      	ldr	r1, [r4, #4]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    de4e:	4a10      	ldr	r2, [pc, #64]	; (de90 <pvPortMalloc+0xfc>)
    de50:	6810      	ldr	r0, [r2, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
    de52:	1a76      	subs	r6, r6, r1
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    de54:	430d      	orrs	r5, r1
					pxBlock->pxNextFreeBlock = NULL;
    de56:	2300      	movs	r3, #0
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    de58:	4286      	cmp	r6, r0
					pxBlock->pxNextFreeBlock = NULL;
    de5a:	e9c4 3500 	strd	r3, r5, [r4]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
    de5e:	f104 0408 	add.w	r4, r4, #8
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    de62:	bf38      	it	cc
    de64:	6016      	strcc	r6, [r2, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
    de66:	603e      	str	r6, [r7, #0]
	( void ) xTaskResumeAll();
    de68:	f7ff fa62 	bl	d330 <xTaskResumeAll>
		if( pvReturn == NULL )
    de6c:	2c00      	cmp	r4, #0
    de6e:	d0e4      	beq.n	de3a <pvPortMalloc+0xa6>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
    de70:	0763      	lsls	r3, r4, #29
    de72:	d0e5      	beq.n	de40 <pvPortMalloc+0xac>
    de74:	e7fe      	b.n	de74 <pvPortMalloc+0xe0>
    de76:	bf00      	nop
    de78:	10002cfc 	.word	0x10002cfc
    de7c:	10012d00 	.word	0x10012d00
    de80:	10012d04 	.word	0x10012d04
    de84:	10012d0c 	.word	0x10012d0c
    de88:	10002d00 	.word	0x10002d00
    de8c:	10012cf8 	.word	0x10012cf8
    de90:	10012d08 	.word	0x10012d08

0000de94 <vPortFree>:
	if( pv != NULL )
    de94:	b150      	cbz	r0, deac <vPortFree+0x18>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
    de96:	4a11      	ldr	r2, [pc, #68]	; (dedc <vPortFree+0x48>)
    de98:	f850 3c04 	ldr.w	r3, [r0, #-4]
    de9c:	6812      	ldr	r2, [r2, #0]
    de9e:	4213      	tst	r3, r2
    dea0:	d003      	beq.n	deaa <vPortFree+0x16>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
    dea2:	f850 1c08 	ldr.w	r1, [r0, #-8]
    dea6:	b111      	cbz	r1, deae <vPortFree+0x1a>
    dea8:	e7fe      	b.n	dea8 <vPortFree+0x14>
    deaa:	e7fe      	b.n	deaa <vPortFree+0x16>
    deac:	4770      	bx	lr
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
    deae:	ea23 0302 	bic.w	r3, r3, r2
{
    deb2:	b510      	push	{r4, lr}
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
    deb4:	f840 3c04 	str.w	r3, [r0, #-4]
    deb8:	4604      	mov	r4, r0
				vTaskSuspendAll();
    deba:	f7ff f979 	bl	d1b0 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
    debe:	4a08      	ldr	r2, [pc, #32]	; (dee0 <vPortFree+0x4c>)
    dec0:	f854 3c04 	ldr.w	r3, [r4, #-4]
    dec4:	6811      	ldr	r1, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    dec6:	f1a4 0008 	sub.w	r0, r4, #8
					xFreeBytesRemaining += pxLink->xBlockSize;
    deca:	440b      	add	r3, r1
    decc:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    dece:	f7ff ff39 	bl	dd44 <prvInsertBlockIntoFreeList>
}
    ded2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				( void ) xTaskResumeAll();
    ded6:	f7ff ba2b 	b.w	d330 <xTaskResumeAll>
    deda:	bf00      	nop
    dedc:	10012d00 	.word	0x10012d00
    dee0:	10012d04 	.word	0x10012d04

0000dee4 <prvTaskExitError>:
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
    dee4:	4b06      	ldr	r3, [pc, #24]	; (df00 <prvTaskExitError+0x1c>)
    dee6:	681b      	ldr	r3, [r3, #0]
    dee8:	3301      	adds	r3, #1
    deea:	d000      	beq.n	deee <prvTaskExitError+0xa>
    deec:	e7fe      	b.n	deec <prvTaskExitError+0x8>
    deee:	f04f 0380 	mov.w	r3, #128	; 0x80
    def2:	f383 8811 	msr	BASEPRI, r3
    def6:	f3bf 8f6f 	isb	sy
    defa:	f3bf 8f4f 	dsb	sy
    defe:	e7fe      	b.n	defe <prvTaskExitError+0x1a>
    df00:	10002b00 	.word	0x10002b00

0000df04 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
    df04:	4806      	ldr	r0, [pc, #24]	; (df20 <prvPortStartFirstTask+0x1c>)
    df06:	6800      	ldr	r0, [r0, #0]
    df08:	6800      	ldr	r0, [r0, #0]
    df0a:	f380 8808 	msr	MSP, r0
    df0e:	b662      	cpsie	i
    df10:	b661      	cpsie	f
    df12:	f3bf 8f4f 	dsb	sy
    df16:	f3bf 8f6f 	isb	sy
    df1a:	df00      	svc	0
    df1c:	bf00      	nop
    df1e:	0000      	.short	0x0000
    df20:	e000ed08 	.word	0xe000ed08

0000df24 <vPortEnableVFP>:
}
/*-----------------------------------------------------------*/
/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
    df24:	f8df 000c 	ldr.w	r0, [pc, #12]	; df34 <vPortEnableVFP+0x10>
    df28:	6801      	ldr	r1, [r0, #0]
    df2a:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    df2e:	6001      	str	r1, [r0, #0]
    df30:	4770      	bx	lr
    df32:	0000      	.short	0x0000
    df34:	e000ed88 	.word	0xe000ed88

0000df38 <pxPortInitialiseStack>:
{
    df38:	b430      	push	{r4, r5}
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
    df3a:	f021 0101 	bic.w	r1, r1, #1
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
    df3e:	f04f 7580 	mov.w	r5, #16777216	; 0x1000000
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
    df42:	4c07      	ldr	r4, [pc, #28]	; (df60 <pxPortInitialiseStack+0x28>)
    df44:	f840 4c0c 	str.w	r4, [r0, #-12]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
    df48:	f06f 0302 	mvn.w	r3, #2
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
    df4c:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
    df50:	e940 1502 	strd	r1, r5, [r0, #-8]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
    df54:	f840 3c24 	str.w	r3, [r0, #-36]
}
    df58:	bc30      	pop	{r4, r5}
    df5a:	3844      	subs	r0, #68	; 0x44
    df5c:	4770      	bx	lr
    df5e:	bf00      	nop
    df60:	0000dee5 	.word	0x0000dee5
	...

0000df70 <SVC_Handler>:
	__asm volatile (
    df70:	4b07      	ldr	r3, [pc, #28]	; (df90 <pxCurrentTCBConst2>)
    df72:	6819      	ldr	r1, [r3, #0]
    df74:	6808      	ldr	r0, [r1, #0]
    df76:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    df7a:	f380 8809 	msr	PSP, r0
    df7e:	f3bf 8f6f 	isb	sy
    df82:	f04f 0000 	mov.w	r0, #0
    df86:	f380 8811 	msr	BASEPRI, r0
    df8a:	4770      	bx	lr
    df8c:	f3af 8000 	nop.w

0000df90 <pxCurrentTCBConst2>:
    df90:	10002bac 	.word	0x10002bac

0000df94 <vPortEnterCritical>:
    df94:	f04f 0380 	mov.w	r3, #128	; 0x80
    df98:	f383 8811 	msr	BASEPRI, r3
    df9c:	f3bf 8f6f 	isb	sy
    dfa0:	f3bf 8f4f 	dsb	sy
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
    dfa4:	4a06      	ldr	r2, [pc, #24]	; (dfc0 <vPortEnterCritical+0x2c>)
    dfa6:	6813      	ldr	r3, [r2, #0]
    dfa8:	3301      	adds	r3, #1
	/* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
    dfaa:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
    dfac:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
    dfae:	d000      	beq.n	dfb2 <vPortEnterCritical+0x1e>
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
	}
}
    dfb0:	4770      	bx	lr
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
    dfb2:	4b04      	ldr	r3, [pc, #16]	; (dfc4 <vPortEnterCritical+0x30>)
    dfb4:	681b      	ldr	r3, [r3, #0]
    dfb6:	f013 0fff 	tst.w	r3, #255	; 0xff
    dfba:	d0f9      	beq.n	dfb0 <vPortEnterCritical+0x1c>
    dfbc:	e7fe      	b.n	dfbc <vPortEnterCritical+0x28>
    dfbe:	bf00      	nop
    dfc0:	10002b00 	.word	0x10002b00
    dfc4:	e000ed04 	.word	0xe000ed04

0000dfc8 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	configASSERT( uxCriticalNesting );
    dfc8:	4a04      	ldr	r2, [pc, #16]	; (dfdc <vPortExitCritical+0x14>)
    dfca:	6813      	ldr	r3, [r2, #0]
    dfcc:	b12b      	cbz	r3, dfda <vPortExitCritical+0x12>
	uxCriticalNesting--;
    dfce:	3b01      	subs	r3, #1
    dfd0:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
    dfd2:	b90b      	cbnz	r3, dfd8 <vPortExitCritical+0x10>
	__asm volatile
    dfd4:	f383 8811 	msr	BASEPRI, r3
	{
		portENABLE_INTERRUPTS();
	}
}
    dfd8:	4770      	bx	lr
    dfda:	e7fe      	b.n	dfda <vPortExitCritical+0x12>
    dfdc:	10002b00 	.word	0x10002b00

0000dfe0 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
    dfe0:	f3ef 8009 	mrs	r0, PSP
    dfe4:	f3bf 8f6f 	isb	sy
    dfe8:	4b15      	ldr	r3, [pc, #84]	; (e040 <pxCurrentTCBConst>)
    dfea:	681a      	ldr	r2, [r3, #0]
    dfec:	f01e 0f10 	tst.w	lr, #16
    dff0:	bf08      	it	eq
    dff2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
    dff6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    dffa:	6010      	str	r0, [r2, #0]
    dffc:	f84d 3d04 	str.w	r3, [sp, #-4]!
    e000:	f04f 0080 	mov.w	r0, #128	; 0x80
    e004:	f380 8811 	msr	BASEPRI, r0
    e008:	f3bf 8f4f 	dsb	sy
    e00c:	f3bf 8f6f 	isb	sy
    e010:	f7ff fa88 	bl	d524 <vTaskSwitchContext>
    e014:	f04f 0000 	mov.w	r0, #0
    e018:	f380 8811 	msr	BASEPRI, r0
    e01c:	bc08      	pop	{r3}
    e01e:	6819      	ldr	r1, [r3, #0]
    e020:	6808      	ldr	r0, [r1, #0]
    e022:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e026:	f01e 0f10 	tst.w	lr, #16
    e02a:	bf08      	it	eq
    e02c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
    e030:	f380 8809 	msr	PSP, r0
    e034:	f3bf 8f6f 	isb	sy
    e038:	4770      	bx	lr
    e03a:	bf00      	nop
    e03c:	f3af 8000 	nop.w

0000e040 <pxCurrentTCBConst>:
    e040:	10002bac 	.word	0x10002bac

0000e044 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
    e044:	b508      	push	{r3, lr}
	__asm volatile
    e046:	f04f 0380 	mov.w	r3, #128	; 0x80
    e04a:	f383 8811 	msr	BASEPRI, r3
    e04e:	f3bf 8f6f 	isb	sy
    e052:	f3bf 8f4f 	dsb	sy
	executes all interrupts must be unmasked.  There is therefore no need to
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	// Addition for support of SystemView Profiler
	traceISR_ENTER();
    e056:	f002 fded 	bl	10c34 <SEGGER_SYSVIEW_RecordEnterISR>
	// End addition
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
    e05a:	f7ff f8cb 	bl	d1f4 <xTaskIncrementTick>
    e05e:	b928      	cbnz	r0, e06c <SysTick_Handler+0x28>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
		}
		// Addition for support of SystemView Profiler
		else
		{
		  traceISR_EXIT();
    e060:	f002 fc4a 	bl	108f8 <SEGGER_SYSVIEW_RecordExitISR>
	__asm volatile
    e064:	2300      	movs	r3, #0
    e066:	f383 8811 	msr	BASEPRI, r3
		}
		// End addition
	}
	portENABLE_INTERRUPTS();
}
    e06a:	bd08      	pop	{r3, pc}
		  traceISR_EXIT_TO_SCHEDULER();
    e06c:	f002 fd58 	bl	10b20 <SEGGER_SYSVIEW_RecordExitISRToScheduler>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
    e070:	4b03      	ldr	r3, [pc, #12]	; (e080 <SysTick_Handler+0x3c>)
    e072:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    e076:	601a      	str	r2, [r3, #0]
    e078:	2300      	movs	r3, #0
    e07a:	f383 8811 	msr	BASEPRI, r3
}
    e07e:	bd08      	pop	{r3, pc}
    e080:	e000ed04 	.word	0xe000ed04

0000e084 <vPortValidateInterruptPriority>:
	{
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
    e084:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
    e088:	2b0f      	cmp	r3, #15
    e08a:	d905      	bls.n	e098 <vPortValidateInterruptPriority+0x14>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
    e08c:	4908      	ldr	r1, [pc, #32]	; (e0b0 <vPortValidateInterruptPriority+0x2c>)
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
    e08e:	4a09      	ldr	r2, [pc, #36]	; (e0b4 <vPortValidateInterruptPriority+0x30>)
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
    e090:	5c5b      	ldrb	r3, [r3, r1]
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
    e092:	7812      	ldrb	r2, [r2, #0]
    e094:	429a      	cmp	r2, r3
    e096:	d808      	bhi.n	e0aa <vPortValidateInterruptPriority+0x26>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredicable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
    e098:	4b07      	ldr	r3, [pc, #28]	; (e0b8 <vPortValidateInterruptPriority+0x34>)
    e09a:	4a08      	ldr	r2, [pc, #32]	; (e0bc <vPortValidateInterruptPriority+0x38>)
    e09c:	681b      	ldr	r3, [r3, #0]
    e09e:	6812      	ldr	r2, [r2, #0]
    e0a0:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    e0a4:	4293      	cmp	r3, r2
    e0a6:	d901      	bls.n	e0ac <vPortValidateInterruptPriority+0x28>
    e0a8:	e7fe      	b.n	e0a8 <vPortValidateInterruptPriority+0x24>
    e0aa:	e7fe      	b.n	e0aa <vPortValidateInterruptPriority+0x26>
	}
    e0ac:	4770      	bx	lr
    e0ae:	bf00      	nop
    e0b0:	e000e3f0 	.word	0xe000e3f0
    e0b4:	10012d18 	.word	0x10012d18
    e0b8:	e000ed0c 	.word	0xe000ed0c
    e0bc:	10012d1c 	.word	0x10012d1c

0000e0c0 <vPortSuppressTicksAndSleep>:
 * resolution of the Tick timer.
 */
	static uint32_t xMaximumPossibleSuppressedTicks = 0;

void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
{
    e0c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    uint32_t New_Timer, Delta_Sleep;
	TickType_t xModifiableIdleTime;
    uint32_t elapsed_time;

	/* Make sure the SysTick reload value does not overflow the counter. */
	if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
    e0c4:	4b26      	ldr	r3, [pc, #152]	; (e160 <vPortSuppressTicksAndSleep+0xa0>)


	/* Calculate the reload value required to wait xExpectedIdleTime
	tick periods.  -1 is used because this code will execute part way
	through one of the tick periods. */
	ulReloadValue =  ulTimerCountsForOneTick * ( xExpectedIdleTime - 1 );
    e0c6:	4e27      	ldr	r6, [pc, #156]	; (e164 <vPortSuppressTicksAndSleep+0xa4>)
	if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
    e0c8:	681d      	ldr	r5, [r3, #0]
	ulReloadValue =  ulTimerCountsForOneTick * ( xExpectedIdleTime - 1 );
    e0ca:	f8d6 9000 	ldr.w	r9, [r6]
{
    e0ce:	4604      	mov	r4, r0

	/* Enter a critical section but don't use the taskENTER_CRITICAL()
	method as that will mask interrupts that should exit sleep mode. */
	__asm volatile( "cpsid i" );
    e0d0:	b672      	cpsid	i
	__asm volatile( "dsb" );
    e0d2:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
    e0d6:	f3bf 8f6f 	isb	sy
#ifdef AM_FREERTOS_USE_STIMER_FOR_TICK
    // Adjust for the time already elapsed
    elapsed_time = am_hal_stimer_counter_get() - g_lastSTimerVal;
    e0da:	f004 fdff 	bl	12cdc <am_hal_stimer_counter_get>
    e0de:	f8df 8088 	ldr.w	r8, [pc, #136]	; e168 <vPortSuppressTicksAndSleep+0xa8>
    e0e2:	4607      	mov	r7, r0
    e0e4:	f8d8 a000 	ldr.w	sl, [r8]


	/* If a context switch is pending or a task is waiting for the scheduler
	to be unsuspended then abandon the low power entry. */
    /* Abandon low power entry if the sleep time is too short */
	if( (eTaskConfirmSleepModeStatus() == eAbortSleep) || ((elapsed_time + ulTimerCountsForOneTick) > ulReloadValue) )
    e0e8:	f7ff fbd8 	bl	d89c <eTaskConfirmSleepModeStatus>
    e0ec:	b158      	cbz	r0, e106 <vPortSuppressTicksAndSleep+0x46>
    e0ee:	42ac      	cmp	r4, r5
    e0f0:	bf28      	it	cs
    e0f2:	462c      	movcs	r4, r5
    e0f4:	6832      	ldr	r2, [r6, #0]
    elapsed_time = am_hal_stimer_counter_get() - g_lastSTimerVal;
    e0f6:	eba7 070a 	sub.w	r7, r7, sl
	ulReloadValue =  ulTimerCountsForOneTick * ( xExpectedIdleTime - 1 );
    e0fa:	1e61      	subs	r1, r4, #1
    e0fc:	fb09 f101 	mul.w	r1, r9, r1
	if( (eTaskConfirmSleepModeStatus() == eAbortSleep) || ((elapsed_time + ulTimerCountsForOneTick) > ulReloadValue) )
    e100:	443a      	add	r2, r7
    e102:	428a      	cmp	r2, r1
    e104:	d902      	bls.n	e10c <vPortSuppressTicksAndSleep+0x4c>

        am_hal_ctimer_start(AM_FREERTOS_CTIMER_NUM, AM_HAL_CTIMER_BOTH);
#endif
		/* Re-enable interrupts - see comments above the cpsid instruction()
		above. */
		__asm volatile( "cpsie i" );
    e106:	b662      	cpsie	i

	}
}
    e108:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        am_hal_stimer_compare_delta_set(0, ulReloadValue);
    e10c:	2000      	movs	r0, #0
    e10e:	1bc9      	subs	r1, r1, r7
    e110:	f004 fdea 	bl	12ce8 <am_hal_stimer_compare_delta_set>
		configPRE_SLEEP_PROCESSING( xModifiableIdleTime );       // Turn OFF all Periphials in this function
    e114:	4620      	mov	r0, r4
    e116:	f004 f82d 	bl	12174 <am_freertos_sleep>
		if( xModifiableIdleTime > 0 )
    e11a:	b120      	cbz	r0, e126 <vPortSuppressTicksAndSleep+0x66>
			__asm volatile( "dsb" );
    e11c:	f3bf 8f4f 	dsb	sy
			__asm volatile( "wfi" );
    e120:	bf30      	wfi
			__asm volatile( "isb" );
    e122:	f3bf 8f6f 	isb	sy
		configPOST_SLEEP_PROCESSING( xExpectedIdleTime );       // Turn ON all Periphials in this function
    e126:	4620      	mov	r0, r4
    e128:	f004 f82a 	bl	12180 <am_freertos_wakeup>
        New_Timer = am_hal_stimer_counter_get();
    e12c:	f004 fdd6 	bl	12cdc <am_hal_stimer_counter_get>
        Delta_Sleep = (signed long) New_Timer - (signed long) g_lastSTimerVal;
    e130:	f8d8 1000 	ldr.w	r1, [r8]
        g_lastSTimerVal = New_Timer - Delta_Sleep%ulTimerCountsForOneTick;
    e134:	6832      	ldr	r2, [r6, #0]
        Delta_Sleep = (signed long) New_Timer - (signed long) g_lastSTimerVal;
    e136:	1a41      	subs	r1, r0, r1
        New_Timer = am_hal_stimer_counter_get();
    e138:	4603      	mov	r3, r0
        g_lastSTimerVal = New_Timer - Delta_Sleep%ulTimerCountsForOneTick;
    e13a:	fbb1 f0f2 	udiv	r0, r1, r2
    e13e:	fb02 1210 	mls	r2, r2, r0, r1
    e142:	1a9b      	subs	r3, r3, r2
    e144:	f8c8 3000 	str.w	r3, [r8]
        vTaskStepTick( Delta_Sleep );
    e148:	f7ff f840 	bl	d1cc <vTaskStepTick>
        am_hal_stimer_int_clear(AM_HAL_STIMER_INT_COMPAREA);
    e14c:	2001      	movs	r0, #1
    e14e:	f004 fe29 	bl	12da4 <am_hal_stimer_int_clear>
        am_hal_stimer_compare_delta_set(0, ulTimerCountsForOneTick);
    e152:	6831      	ldr	r1, [r6, #0]
    e154:	2000      	movs	r0, #0
    e156:	f004 fdc7 	bl	12ce8 <am_hal_stimer_compare_delta_set>
		__asm volatile( "cpsie i" );
    e15a:	b662      	cpsie	i
}
    e15c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    e160:	10012d24 	.word	0x10012d24
    e164:	10012d20 	.word	0x10012d20
    e168:	10012d14 	.word	0x10012d14

0000e16c <am_stimer_cmpr0_isr>:
// Interrupt handler for the STIMER module Compare 0.
//
//*****************************************************************************
void
am_stimer_cmpr0_isr(void)
{
    e16c:	b538      	push	{r3, r4, r5, lr}

    //
    // Check the timer interrupt status.
    //
    uint32_t ui32Status = am_hal_stimer_int_status_get(false);
    e16e:	2000      	movs	r0, #0
    e170:	f004 fe1e 	bl	12db0 <am_hal_stimer_int_status_get>
    if (ui32Status & AM_HAL_STIMER_INT_COMPAREA)
    e174:	07c3      	lsls	r3, r0, #31
    e176:	d400      	bmi.n	e17a <am_stimer_cmpr0_isr+0xe>
        //
        // Run handlers for the various possible timer events.
        //
        xPortStimerTickHandler();
    }
}
    e178:	bd38      	pop	{r3, r4, r5, pc}
        am_hal_stimer_int_clear(AM_HAL_STIMER_INT_COMPAREA);
    e17a:	2001      	movs	r0, #1
    e17c:	f004 fe12 	bl	12da4 <am_hal_stimer_int_clear>
    curSTimer = am_hal_stimer_counter_get();
    e180:	f004 fdac 	bl	12cdc <am_hal_stimer_counter_get>
    am_hal_stimer_compare_delta_set(0, ulTimerCountsForOneTick);
    e184:	4c19      	ldr	r4, [pc, #100]	; (e1ec <am_stimer_cmpr0_isr+0x80>)
    curSTimer = am_hal_stimer_counter_get();
    e186:	4605      	mov	r5, r0
    am_hal_stimer_compare_delta_set(0, ulTimerCountsForOneTick);
    e188:	6821      	ldr	r1, [r4, #0]
    e18a:	2000      	movs	r0, #0
    e18c:	f004 fdac 	bl	12ce8 <am_hal_stimer_compare_delta_set>
    timerCounts = curSTimer - g_lastSTimerVal;
    e190:	4917      	ldr	r1, [pc, #92]	; (e1f0 <am_stimer_cmpr0_isr+0x84>)
    numTicksElapsed = timerCounts/ulTimerCountsForOneTick;
    e192:	6823      	ldr	r3, [r4, #0]
    timerCounts = curSTimer - g_lastSTimerVal;
    e194:	680a      	ldr	r2, [r1, #0]
    e196:	1aaa      	subs	r2, r5, r2
    numTicksElapsed = timerCounts/ulTimerCountsForOneTick;
    e198:	fbb2 f4f3 	udiv	r4, r2, r3
    remainder = timerCounts % ulTimerCountsForOneTick;
    e19c:	fb03 2314 	mls	r3, r3, r4, r2
    g_lastSTimerVal = curSTimer - remainder;
    e1a0:	1aed      	subs	r5, r5, r3
    e1a2:	600d      	str	r5, [r1, #0]
	__asm volatile
    e1a4:	f3ef 8311 	mrs	r3, BASEPRI
    e1a8:	f04f 0280 	mov.w	r2, #128	; 0x80
    e1ac:	f382 8811 	msr	BASEPRI, r2
    e1b0:	f3bf 8f6f 	isb	sy
    e1b4:	f3bf 8f4f 	dsb	sy
    traceISR_ENTER();
    e1b8:	f002 fd3c 	bl	10c34 <SEGGER_SYSVIEW_RecordEnterISR>
    BaseType_t ctxtSwitchReqd = pdFALSE;
    e1bc:	2500      	movs	r5, #0
    e1be:	e004      	b.n	e1ca <am_stimer_cmpr0_isr+0x5e>
            ctxtSwitchReqd = (( xTaskIncrementTick() != pdFALSE ) ? pdTRUE : ctxtSwitchReqd);
    e1c0:	f7ff f818 	bl	d1f4 <xTaskIncrementTick>
    e1c4:	2800      	cmp	r0, #0
    e1c6:	bf18      	it	ne
    e1c8:	2501      	movne	r5, #1
        while (numTicksElapsed--)
    e1ca:	f114 34ff 	adds.w	r4, r4, #4294967295	; 0xffffffff
    e1ce:	d2f7      	bcs.n	e1c0 <am_stimer_cmpr0_isr+0x54>
        if ( ctxtSwitchReqd != pdFALSE )
    e1d0:	b92d      	cbnz	r5, e1de <am_stimer_cmpr0_isr+0x72>
        	traceISR_EXIT();
    e1d2:	f002 fb91 	bl	108f8 <SEGGER_SYSVIEW_RecordExitISR>
	__asm volatile
    e1d6:	2300      	movs	r3, #0
    e1d8:	f383 8811 	msr	BASEPRI, r3
}
    e1dc:	bd38      	pop	{r3, r4, r5, pc}
        	traceISR_EXIT_TO_SCHEDULER();
    e1de:	f002 fc9f 	bl	10b20 <SEGGER_SYSVIEW_RecordExitISRToScheduler>
            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
    e1e2:	4b04      	ldr	r3, [pc, #16]	; (e1f4 <am_stimer_cmpr0_isr+0x88>)
    e1e4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    e1e8:	601a      	str	r2, [r3, #0]
    e1ea:	e7f4      	b.n	e1d6 <am_stimer_cmpr0_isr+0x6a>
    e1ec:	10012d20 	.word	0x10012d20
    e1f0:	10012d14 	.word	0x10012d14
    e1f4:	e000ed04 	.word	0xe000ed04

0000e1f8 <vPortSetupTimerInterrupt>:

#endif // AM_FREERTOS_USE_STIMER_FOR_TICK


void vPortSetupTimerInterrupt( void )
{
    e1f8:	b538      	push	{r3, r4, r5, lr}
#ifdef AM_FREERTOS_USE_STIMER_FOR_TICK
    uint32_t oldCfg;
    /* Calculate the constants required to configure the tick interrupt. */
    #if configUSE_TICKLESS_IDLE == 2
    {
        ulTimerCountsForOneTick = (configSTIMER_CLOCK_HZ /configTICK_RATE_HZ) ; //( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
    e1fa:	4c14      	ldr	r4, [pc, #80]	; (e24c <vPortSetupTimerInterrupt+0x54>)
        xMaximumPossibleSuppressedTicks = portMAX_32_BIT_NUMBER / ulTimerCountsForOneTick;
    e1fc:	4b14      	ldr	r3, [pc, #80]	; (e250 <vPortSetupTimerInterrupt+0x58>)
        ulTimerCountsForOneTick = (configSTIMER_CLOCK_HZ /configTICK_RATE_HZ) ; //( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
    e1fe:	2120      	movs	r1, #32
        xMaximumPossibleSuppressedTicks = portMAX_32_BIT_NUMBER / ulTimerCountsForOneTick;
    e200:	f06f 4278 	mvn.w	r2, #4160749568	; 0xf8000000
    }
    #endif /* configUSE_TICKLESS_IDLE */
    //
    //
    //
    am_hal_stimer_int_enable(AM_HAL_STIMER_INT_COMPAREA);
    e204:	2001      	movs	r0, #1
        ulTimerCountsForOneTick = (configSTIMER_CLOCK_HZ /configTICK_RATE_HZ) ; //( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
    e206:	6021      	str	r1, [r4, #0]
        xMaximumPossibleSuppressedTicks = portMAX_32_BIT_NUMBER / ulTimerCountsForOneTick;
    e208:	601a      	str	r2, [r3, #0]
    am_hal_stimer_int_enable(AM_HAL_STIMER_INT_COMPAREA);
    e20a:	f004 fdc1 	bl	12d90 <am_hal_stimer_int_enable>
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    e20e:	4b11      	ldr	r3, [pc, #68]	; (e254 <vPortSetupTimerInterrupt+0x5c>)
    e210:	21e0      	movs	r1, #224	; 0xe0
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e212:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    e216:	f883 1317 	strb.w	r1, [r3, #791]	; 0x317
#endif // AM_CMSIS_REGS

    //
    // Configure the STIMER
    //
    oldCfg = am_hal_stimer_config(AM_HAL_STIMER_CFG_FREEZE);
    e21a:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e21e:	601a      	str	r2, [r3, #0]
    e220:	f004 fd52 	bl	12cc8 <am_hal_stimer_config>
    e224:	4605      	mov	r5, r0
    g_lastSTimerVal = am_hal_stimer_counter_get();
    e226:	f004 fd59 	bl	12cdc <am_hal_stimer_counter_get>
    e22a:	4b0b      	ldr	r3, [pc, #44]	; (e258 <vPortSetupTimerInterrupt+0x60>)
    am_hal_stimer_compare_delta_set(0, ulTimerCountsForOneTick);
    e22c:	6821      	ldr	r1, [r4, #0]
    g_lastSTimerVal = am_hal_stimer_counter_get();
    e22e:	6018      	str	r0, [r3, #0]
    am_hal_stimer_compare_delta_set(0, ulTimerCountsForOneTick);
    e230:	2000      	movs	r0, #0
    e232:	f004 fd59 	bl	12ce8 <am_hal_stimer_compare_delta_set>
#if AM_CMSIS_REGS
    am_hal_stimer_config((oldCfg & ~(AM_HAL_STIMER_CFG_FREEZE|CTIMER_STCFG_CLKSEL_Msk)) | AM_STIMER_CLOCK | AM_HAL_STIMER_CFG_COMPARE_A_ENABLE);
    e236:	4809      	ldr	r0, [pc, #36]	; (e25c <vPortSetupTimerInterrupt+0x64>)
    e238:	4028      	ands	r0, r5
    e23a:	f440 7081 	orr.w	r0, r0, #258	; 0x102
    e23e:	f040 0001 	orr.w	r0, r0, #1
    //
    am_hal_ctimer_start(AM_FREERTOS_CTIMER_NUM, AM_HAL_CTIMER_BOTH);


#endif // AM_FREERTOS_USE_STIMER_FOR_TICK
}
    e242:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    am_hal_stimer_config((oldCfg & ~(AM_HAL_STIMER_CFG_FREEZE|CTIMER_STCFG_CLKSEL_Msk)) | AM_STIMER_CLOCK | AM_HAL_STIMER_CFG_COMPARE_A_ENABLE);
    e246:	f004 bd3f 	b.w	12cc8 <am_hal_stimer_config>
    e24a:	bf00      	nop
    e24c:	10012d20 	.word	0x10012d20
    e250:	10012d24 	.word	0x10012d24
    e254:	e000e100 	.word	0xe000e100
    e258:	10012d14 	.word	0x10012d14
    e25c:	7ffffef0 	.word	0x7ffffef0

0000e260 <xPortStartScheduler>:
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
    e260:	4b2f      	ldr	r3, [pc, #188]	; (e320 <xPortStartScheduler+0xc0>)
    e262:	4a30      	ldr	r2, [pc, #192]	; (e324 <xPortStartScheduler+0xc4>)
    e264:	6819      	ldr	r1, [r3, #0]
    e266:	4291      	cmp	r1, r2
    e268:	d018      	beq.n	e29c <xPortStartScheduler+0x3c>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
    e26a:	681a      	ldr	r2, [r3, #0]
    e26c:	4b2e      	ldr	r3, [pc, #184]	; (e328 <xPortStartScheduler+0xc8>)
    e26e:	429a      	cmp	r2, r3
    e270:	d015      	beq.n	e29e <xPortStartScheduler+0x3e>
{
    e272:	b510      	push	{r4, lr}
		ulOriginalPriority = *pucFirstUserPriorityRegister;
    e274:	4b2d      	ldr	r3, [pc, #180]	; (e32c <xPortStartScheduler+0xcc>)
    e276:	781a      	ldrb	r2, [r3, #0]
{
    e278:	b082      	sub	sp, #8
		ulOriginalPriority = *pucFirstUserPriorityRegister;
    e27a:	b2d2      	uxtb	r2, r2
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
    e27c:	21ff      	movs	r1, #255	; 0xff
		ulOriginalPriority = *pucFirstUserPriorityRegister;
    e27e:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
    e280:	7019      	strb	r1, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
    e282:	781b      	ldrb	r3, [r3, #0]
    e284:	b2db      	uxtb	r3, r3
    e286:	f88d 3003 	strb.w	r3, [sp, #3]
		configASSERT( ucMaxPriorityValue == ( configKERNEL_INTERRUPT_PRIORITY & ucMaxPriorityValue ) );
    e28a:	f89d 3003 	ldrb.w	r3, [sp, #3]
    e28e:	f89d 2003 	ldrb.w	r2, [sp, #3]
    e292:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
    e296:	4293      	cmp	r3, r2
    e298:	d002      	beq.n	e2a0 <xPortStartScheduler+0x40>
    e29a:	e7fe      	b.n	e29a <xPortStartScheduler+0x3a>
    e29c:	e7fe      	b.n	e29c <xPortStartScheduler+0x3c>
    e29e:	e7fe      	b.n	e29e <xPortStartScheduler+0x3e>
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    e2a0:	f89d 3003 	ldrb.w	r3, [sp, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
    e2a4:	f89d 2003 	ldrb.w	r2, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    e2a8:	4c21      	ldr	r4, [pc, #132]	; (e330 <xPortStartScheduler+0xd0>)
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
    e2aa:	4922      	ldr	r1, [pc, #136]	; (e334 <xPortStartScheduler+0xd4>)
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    e2ac:	f003 0380 	and.w	r3, r3, #128	; 0x80
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
    e2b0:	2007      	movs	r0, #7
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
    e2b2:	0612      	lsls	r2, r2, #24
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    e2b4:	7023      	strb	r3, [r4, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
    e2b6:	6008      	str	r0, [r1, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
    e2b8:	d50f      	bpl.n	e2da <xPortStartScheduler+0x7a>
    e2ba:	2206      	movs	r2, #6
    e2bc:	e000      	b.n	e2c0 <xPortStartScheduler+0x60>
    e2be:	4602      	mov	r2, r0
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
    e2c0:	f89d 3003 	ldrb.w	r3, [sp, #3]
    e2c4:	005b      	lsls	r3, r3, #1
    e2c6:	b2db      	uxtb	r3, r3
    e2c8:	f88d 3003 	strb.w	r3, [sp, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
    e2cc:	f89d 3003 	ldrb.w	r3, [sp, #3]
    e2d0:	061b      	lsls	r3, r3, #24
    e2d2:	f102 30ff 	add.w	r0, r2, #4294967295	; 0xffffffff
    e2d6:	d4f2      	bmi.n	e2be <xPortStartScheduler+0x5e>
    e2d8:	600a      	str	r2, [r1, #0]
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
    e2da:	680b      	ldr	r3, [r1, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
    e2dc:	9801      	ldr	r0, [sp, #4]
    e2de:	4c13      	ldr	r4, [pc, #76]	; (e32c <xPortStartScheduler+0xcc>)
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
    e2e0:	4a15      	ldr	r2, [pc, #84]	; (e338 <xPortStartScheduler+0xd8>)
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
    e2e2:	021b      	lsls	r3, r3, #8
		*pucFirstUserPriorityRegister = ulOriginalPriority;
    e2e4:	b2c0      	uxtb	r0, r0
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
    e2e6:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    e2ea:	600b      	str	r3, [r1, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
    e2ec:	7020      	strb	r0, [r4, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
    e2ee:	6813      	ldr	r3, [r2, #0]
    e2f0:	f443 0360 	orr.w	r3, r3, #14680064	; 0xe00000
    e2f4:	6013      	str	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
    e2f6:	6813      	ldr	r3, [r2, #0]
    e2f8:	f043 4360 	orr.w	r3, r3, #3758096384	; 0xe0000000
    e2fc:	6013      	str	r3, [r2, #0]
	vPortSetupTimerInterrupt();
    e2fe:	f7ff ff7b 	bl	e1f8 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
    e302:	4b0e      	ldr	r3, [pc, #56]	; (e33c <xPortStartScheduler+0xdc>)
    e304:	2200      	movs	r2, #0
    e306:	601a      	str	r2, [r3, #0]
	vPortEnableVFP();
    e308:	f7ff fe0c 	bl	df24 <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
    e30c:	4a0c      	ldr	r2, [pc, #48]	; (e340 <xPortStartScheduler+0xe0>)
    e30e:	6813      	ldr	r3, [r2, #0]
    e310:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
    e314:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
    e316:	f7ff fdf5 	bl	df04 <prvPortStartFirstTask>
	prvTaskExitError();
    e31a:	f7ff fde3 	bl	dee4 <prvTaskExitError>
    e31e:	bf00      	nop
    e320:	e000ed00 	.word	0xe000ed00
    e324:	410fc271 	.word	0x410fc271
    e328:	410fc270 	.word	0x410fc270
    e32c:	e000e400 	.word	0xe000e400
    e330:	10012d18 	.word	0x10012d18
    e334:	10012d1c 	.word	0x10012d1c
    e338:	e000ed20 	.word	0xe000ed20
    e33c:	10002b00 	.word	0x10002b00
    e340:	e000ef34 	.word	0xe000ef34

0000e344 <am_hal_pdm_initialize>:
am_hal_pdm_initialize(uint32_t ui32Module, void **ppHandle)
{
    //
    // Check that the request module is in range.
    //
    if ( ui32Module >= AM_REG_PDM_NUM_MODULES )
    e344:	b9a0      	cbnz	r0, e370 <am_hal_pdm_initialize+0x2c>
    }

    //
    // Check for valid arguements.
    //
    if (!ppHandle)
    e346:	b1c1      	cbz	r1, e37a <am_hal_pdm_initialize+0x36>
    }

    //
    // Check if the handle is unallocated.
    //
    if (g_am_hal_pdm_states[ui32Module].prefix.s.bInit)
    e348:	4b0d      	ldr	r3, [pc, #52]	; (e380 <am_hal_pdm_initialize+0x3c>)
    e34a:	78da      	ldrb	r2, [r3, #3]
{
    e34c:	b430      	push	{r4, r5}
    if (g_am_hal_pdm_states[ui32Module].prefix.s.bInit)
    e34e:	f3c2 0400 	ubfx	r4, r2, #0, #1
    e352:	b2e0      	uxtb	r0, r4
    e354:	b970      	cbnz	r0, e374 <am_hal_pdm_initialize+0x30>
    }

    //
    // Initialize the handle.
    //
    g_am_hal_pdm_states[ui32Module].prefix.s.bInit = true;
    e356:	f042 0201 	orr.w	r2, r2, #1
    e35a:	70da      	strb	r2, [r3, #3]
    g_am_hal_pdm_states[ui32Module].prefix.s.magic = AM_HAL_MAGIC_PDM;
    e35c:	681a      	ldr	r2, [r3, #0]
    e35e:	4d09      	ldr	r5, [pc, #36]	; (e384 <am_hal_pdm_initialize+0x40>)
    g_am_hal_pdm_states[ui32Module].ui32Module = ui32Module;
    g_am_hal_pdm_states[ui32Module].sRegState.bValid = false;
    e360:	711c      	strb	r4, [r3, #4]
    g_am_hal_pdm_states[ui32Module].prefix.s.magic = AM_HAL_MAGIC_PDM;
    e362:	f365 0217 	bfi	r2, r5, #0, #24
    e366:	601a      	str	r2, [r3, #0]
    g_am_hal_pdm_states[ui32Module].ui32Module = ui32Module;
    e368:	6098      	str	r0, [r3, #8]

    //
    // Return the status.
    //
    return AM_HAL_STATUS_SUCCESS;
}
    e36a:	bc30      	pop	{r4, r5}
    *ppHandle = (void *)&g_am_hal_pdm_states[ui32Module];
    e36c:	600b      	str	r3, [r1, #0]
}
    e36e:	4770      	bx	lr
        return AM_HAL_STATUS_OUT_OF_RANGE;
    e370:	2005      	movs	r0, #5
    e372:	4770      	bx	lr
        return AM_HAL_STATUS_INVALID_OPERATION;
    e374:	2007      	movs	r0, #7
}
    e376:	bc30      	pop	{r4, r5}
    e378:	4770      	bx	lr
        return AM_HAL_STATUS_INVALID_ARG;
    e37a:	2006      	movs	r0, #6
}
    e37c:	4770      	bx	lr
    e37e:	bf00      	nop
    e380:	1001340c 	.word	0x1001340c
    e384:	00f956e2 	.word	0x00f956e2

0000e388 <am_hal_pdm_power_control>:
//*****************************************************************************
uint32_t
am_hal_pdm_power_control(void *pHandle,
                         am_hal_sysctrl_power_state_e ePowerState,
                         bool bRetainState)
{
    e388:	b5f0      	push	{r4, r5, r6, r7, lr}
                                                (AM_HAL_PWRCTRL_PERIPH_PDM +
                                                 ui32Module));
    //
    // Check the handle.
    //
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e38a:	6803      	ldr	r3, [r0, #0]
    e38c:	4c1d      	ldr	r4, [pc, #116]	; (e404 <am_hal_pdm_power_control+0x7c>)
    e38e:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    e392:	42a3      	cmp	r3, r4
{
    e394:	b083      	sub	sp, #12
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e396:	d10f      	bne.n	e3b8 <am_hal_pdm_power_control+0x30>
    am_hal_pwrctrl_periph_e ePDMPowerModule = ((am_hal_pwrctrl_periph_e)
    e398:	6883      	ldr	r3, [r0, #8]
    e39a:	330d      	adds	r3, #13
    e39c:	4617      	mov	r7, r2
    e39e:	460c      	mov	r4, r1
    e3a0:	4606      	mov	r6, r0
    e3a2:	b2dd      	uxtb	r5, r3

    //
    // Decode the requested power state and update PDM operation accordingly.
    //
    switch (ePowerState)
    e3a4:	b171      	cbz	r1, e3c4 <am_hal_pdm_power_control+0x3c>
    e3a6:	2902      	cmp	r1, #2
    e3a8:	d809      	bhi.n	e3be <am_hal_pdm_power_control+0x36>
        //
        // Turn off the PDM.
        //
        case AM_HAL_SYSCTRL_NORMALSLEEP:
        case AM_HAL_SYSCTRL_DEEPSLEEP:
            if (bRetainState)
    e3aa:	b9d2      	cbnz	r2, e3e2 <am_hal_pdm_power_control+0x5a>
            }

            //
            // Disable power control.
            //
            am_hal_pwrctrl_periph_disable(ePDMPowerModule);
    e3ac:	4628      	mov	r0, r5
    e3ae:	f004 fbff 	bl	12bb0 <am_hal_pwrctrl_periph_disable>
    }

    //
    // Return the status.
    //
    return AM_HAL_STATUS_SUCCESS;
    e3b2:	2000      	movs	r0, #0
}
    e3b4:	b003      	add	sp, #12
    e3b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e3b8:	2002      	movs	r0, #2
}
    e3ba:	b003      	add	sp, #12
    e3bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
            return AM_HAL_STATUS_INVALID_ARG;
    e3be:	2006      	movs	r0, #6
}
    e3c0:	b003      	add	sp, #12
    e3c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
            if (bRetainState && !pState->sRegState.bValid)
    e3c4:	b1b2      	cbz	r2, e3f4 <am_hal_pdm_power_control+0x6c>
    e3c6:	7903      	ldrb	r3, [r0, #4]
    e3c8:	b1cb      	cbz	r3, e3fe <am_hal_pdm_power_control+0x76>
            am_hal_pwrctrl_periph_enable(ePDMPowerModule);
    e3ca:	4628      	mov	r0, r5
    e3cc:	f004 fbc6 	bl	12b5c <am_hal_pwrctrl_periph_enable>
                AM_CRITICAL_BEGIN;
    e3d0:	f004 fad0 	bl	12974 <am_hal_interrupt_master_disable>
    e3d4:	9000      	str	r0, [sp, #0]
                AM_CRITICAL_END;
    e3d6:	9800      	ldr	r0, [sp, #0]
                pState->sRegState.bValid = false;
    e3d8:	7134      	strb	r4, [r6, #4]
                AM_CRITICAL_END;
    e3da:	f004 facf 	bl	1297c <am_hal_interrupt_master_set>
    return AM_HAL_STATUS_SUCCESS;
    e3de:	4620      	mov	r0, r4
    e3e0:	e7eb      	b.n	e3ba <am_hal_pdm_power_control+0x32>
                AM_CRITICAL_BEGIN;
    e3e2:	f004 fac7 	bl	12974 <am_hal_interrupt_master_disable>
                pState->sRegState.bValid = true;
    e3e6:	2301      	movs	r3, #1
                AM_CRITICAL_BEGIN;
    e3e8:	9001      	str	r0, [sp, #4]
                AM_CRITICAL_END;
    e3ea:	9801      	ldr	r0, [sp, #4]
                pState->sRegState.bValid = true;
    e3ec:	7133      	strb	r3, [r6, #4]
                AM_CRITICAL_END;
    e3ee:	f004 fac5 	bl	1297c <am_hal_interrupt_master_set>
    e3f2:	e7db      	b.n	e3ac <am_hal_pdm_power_control+0x24>
            am_hal_pwrctrl_periph_enable(ePDMPowerModule);
    e3f4:	4628      	mov	r0, r5
    e3f6:	f004 fbb1 	bl	12b5c <am_hal_pwrctrl_periph_enable>
    return AM_HAL_STATUS_SUCCESS;
    e3fa:	4638      	mov	r0, r7
    e3fc:	e7dd      	b.n	e3ba <am_hal_pdm_power_control+0x32>
                return AM_HAL_STATUS_INVALID_OPERATION;
    e3fe:	2007      	movs	r0, #7
    e400:	e7db      	b.n	e3ba <am_hal_pdm_power_control+0x32>
    e402:	bf00      	nop
    e404:	01f956e2 	.word	0x01f956e2

0000e408 <am_hal_pdm_configure>:
uint32_t
am_hal_pdm_configure(void *pHandle, am_hal_pdm_config_t *psConfig)
{
    am_hal_pdm_state_t *pState = (am_hal_pdm_state_t *) pHandle;
    uint32_t ui32Module = pState->ui32Module;
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e408:	6803      	ldr	r3, [r0, #0]
    e40a:	4a3f      	ldr	r2, [pc, #252]	; (e508 <am_hal_pdm_configure+0x100>)
    e40c:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    e410:	4293      	cmp	r3, r2
    e412:	d001      	beq.n	e418 <am_hal_pdm_configure+0x10>
    e414:	2002      	movs	r0, #2
    delay_us(100);

    PDMn(ui32Module)->VCFG_b.RSTB = PDM_VCFG_RSTB_NORM;

    return AM_HAL_STATUS_SUCCESS;
}
    e416:	4770      	bx	lr
{
    e418:	b510      	push	{r4, lr}
    PDMn(ui32Module)->PCFG_b.SOFTMUTE = psConfig->bSoftMute;
    e41a:	4c3c      	ldr	r4, [pc, #240]	; (e50c <am_hal_pdm_configure+0x104>)
    e41c:	7f4a      	ldrb	r2, [r1, #29]
    e41e:	6823      	ldr	r3, [r4, #0]
    e420:	f362 0341 	bfi	r3, r2, #1, #1
    e424:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.CYCLES = psConfig->ui32GainChangeDelay;
    e426:	6823      	ldr	r3, [r4, #0]
    e428:	698a      	ldr	r2, [r1, #24]
    e42a:	f362 0384 	bfi	r3, r2, #2, #3
    e42e:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.HPCUTOFF = psConfig->ui32HighPassCutoff;
    e430:	6823      	ldr	r3, [r4, #0]
    e432:	68ca      	ldr	r2, [r1, #12]
    e434:	f362 1348 	bfi	r3, r2, #5, #4
    e438:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.ADCHPD = psConfig->bHighPassEnable;
    e43a:	6823      	ldr	r3, [r4, #0]
    e43c:	7a0a      	ldrb	r2, [r1, #8]
    e43e:	f362 2349 	bfi	r3, r2, #9, #1
    e442:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.SINCRATE = psConfig->ui32DecimationRate;
    e444:	6823      	ldr	r3, [r4, #0]
    e446:	684a      	ldr	r2, [r1, #4]
    e448:	f362 2390 	bfi	r3, r2, #10, #7
    e44c:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.MCLKDIV = psConfig->eClkDivider;
    e44e:	6823      	ldr	r3, [r4, #0]
    e450:	780a      	ldrb	r2, [r1, #0]
    e452:	f362 4352 	bfi	r3, r2, #17, #2
    e456:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.PGALEFT = psConfig->eLeftGain;
    e458:	6823      	ldr	r3, [r4, #0]
    e45a:	784a      	ldrb	r2, [r1, #1]
    e45c:	f362 5359 	bfi	r3, r2, #21, #5
    e460:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.PGARIGHT = psConfig->eRightGain;
    e462:	7888      	ldrb	r0, [r1, #2]
    e464:	6823      	ldr	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.LRSWAP = psConfig->bLRSwap;
    e466:	7f8a      	ldrb	r2, [r1, #30]
    PDMn(ui32Module)->PCFG_b.PGARIGHT = psConfig->eRightGain;
    e468:	f360 639e 	bfi	r3, r0, #26, #5
    e46c:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.LRSWAP = psConfig->bLRSwap;
    e46e:	6823      	ldr	r3, [r4, #0]
    e470:	f362 73df 	bfi	r3, r2, #31, #1
    e474:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->PCFG_b.PDMCOREEN = PDM_PCFG_PDMCOREEN_EN;
    e476:	6823      	ldr	r3, [r4, #0]
    e478:	f043 0301 	orr.w	r3, r3, #1
    e47c:	6023      	str	r3, [r4, #0]
    PDMn(ui32Module)->VCFG_b.PDMCLKEN = PDM_VCFG_PDMCLKEN_DIS;
    e47e:	6863      	ldr	r3, [r4, #4]
    e480:	f36f 639a 	bfc	r3, #26, #1
    e484:	6063      	str	r3, [r4, #4]
    PDMn(ui32Module)->VCFG_b.IOCLKEN = PDM_VCFG_IOCLKEN_DIS;
    e486:	6863      	ldr	r3, [r4, #4]
    e488:	f36f 73df 	bfc	r3, #31, #1
    e48c:	6063      	str	r3, [r4, #4]
    PDMn(ui32Module)->VCFG_b.RSTB = PDM_VCFG_RSTB_RESET;
    e48e:	6863      	ldr	r3, [r4, #4]
    e490:	f36f 739e 	bfc	r3, #30, #1
    e494:	6063      	str	r3, [r4, #4]
    PDMn(ui32Module)->VCFG_b.CHSET = psConfig->ePCMChannels;
    e496:	6863      	ldr	r3, [r4, #4]
    e498:	7d4a      	ldrb	r2, [r1, #21]
    e49a:	f362 03c4 	bfi	r3, r2, #3, #2
    e49e:	6063      	str	r3, [r4, #4]
    PDMn(ui32Module)->VCFG_b.PCMPACK = psConfig->bDataPacking;
    e4a0:	6863      	ldr	r3, [r4, #4]
    e4a2:	7d0a      	ldrb	r2, [r1, #20]
    e4a4:	f362 2308 	bfi	r3, r2, #8, #1
    e4a8:	6063      	str	r3, [r4, #4]
    PDMn(ui32Module)->VCFG_b.SELAP = psConfig->ePDMClkSource;
    e4aa:	6863      	ldr	r3, [r4, #4]
    e4ac:	7c8a      	ldrb	r2, [r1, #18]
    e4ae:	f362 4310 	bfi	r3, r2, #16, #1
    e4b2:	6063      	str	r3, [r4, #4]
    PDMn(ui32Module)->VCFG_b.DMICKDEL = psConfig->bPDMSampleDelay;
    e4b4:	6863      	ldr	r3, [r4, #4]
    e4b6:	7cca      	ldrb	r2, [r1, #19]
    e4b8:	f362 4351 	bfi	r3, r2, #17, #1
    e4bc:	6063      	str	r3, [r4, #4]
    PDMn(ui32Module)->VCFG_b.BCLKINV = psConfig->bInvertI2SBCLK;
    e4be:	7c4a      	ldrb	r2, [r1, #17]
    e4c0:	6863      	ldr	r3, [r4, #4]
    e4c2:	f362 43d3 	bfi	r3, r2, #19, #1
    e4c6:	6063      	str	r3, [r4, #4]
    PDMn(ui32Module)->VCFG_b.I2SEN = psConfig->bI2SEnable;
    e4c8:	7f0a      	ldrb	r2, [r1, #28]
    e4ca:	6863      	ldr	r3, [r4, #4]
    e4cc:	f362 5314 	bfi	r3, r2, #20, #1
    e4d0:	6063      	str	r3, [r4, #4]
    PDMn(ui32Module)->VCFG_b.PDMCLKSEL = psConfig->ePDMClkSpeed;
    e4d2:	7c0a      	ldrb	r2, [r1, #16]
    e4d4:	6863      	ldr	r3, [r4, #4]
{
    e4d6:	b084      	sub	sp, #16
    PDMn(ui32Module)->VCFG_b.PDMCLKSEL = psConfig->ePDMClkSpeed;
    e4d8:	f362 63dd 	bfi	r3, r2, #27, #3
    e4dc:	6063      	str	r3, [r4, #4]
    delay_us(100);
    e4de:	a801      	add	r0, sp, #4
    e4e0:	f004 f9f6 	bl	128d0 <am_hal_clkgen_status_get>
    e4e4:	9801      	ldr	r0, [sp, #4]
    e4e6:	4b0a      	ldr	r3, [pc, #40]	; (e510 <am_hal_pdm_configure+0x108>)
    e4e8:	fba3 3000 	umull	r3, r0, r3, r0
    e4ec:	0c80      	lsrs	r0, r0, #18
    e4ee:	2364      	movs	r3, #100	; 0x64
    e4f0:	fb03 f000 	mul.w	r0, r3, r0
    e4f4:	f004 fa0a 	bl	1290c <am_hal_flash_delay>
    PDMn(ui32Module)->VCFG_b.RSTB = PDM_VCFG_RSTB_NORM;
    e4f8:	6863      	ldr	r3, [r4, #4]
    return AM_HAL_STATUS_SUCCESS;
    e4fa:	2000      	movs	r0, #0
    PDMn(ui32Module)->VCFG_b.RSTB = PDM_VCFG_RSTB_NORM;
    e4fc:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    e500:	6063      	str	r3, [r4, #4]
}
    e502:	b004      	add	sp, #16
    e504:	bd10      	pop	{r4, pc}
    e506:	bf00      	nop
    e508:	01f956e2 	.word	0x01f956e2
    e50c:	50011000 	.word	0x50011000
    e510:	165e9f81 	.word	0x165e9f81

0000e514 <am_hal_pdm_enable>:
uint32_t
am_hal_pdm_enable(void *pHandle)
{
    am_hal_pdm_state_t *pState = (am_hal_pdm_state_t *) pHandle;
    uint32_t ui32Module = pState->ui32Module;
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e514:	6803      	ldr	r3, [r0, #0]
    e516:	4a09      	ldr	r2, [pc, #36]	; (e53c <am_hal_pdm_enable+0x28>)
    e518:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    e51c:	4293      	cmp	r3, r2
    e51e:	d10a      	bne.n	e536 <am_hal_pdm_enable+0x22>

    PDMn(ui32Module)->VCFG_b.IOCLKEN = PDM_VCFG_IOCLKEN_EN;
    e520:	4b07      	ldr	r3, [pc, #28]	; (e540 <am_hal_pdm_enable+0x2c>)
    e522:	685a      	ldr	r2, [r3, #4]
    e524:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
    e528:	605a      	str	r2, [r3, #4]
    PDMn(ui32Module)->VCFG_b.PDMCLKEN = PDM_VCFG_PDMCLKEN_EN;
    e52a:	685a      	ldr	r2, [r3, #4]
    e52c:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
    e530:	605a      	str	r2, [r3, #4]

    return AM_HAL_STATUS_SUCCESS;
    e532:	2000      	movs	r0, #0
    e534:	4770      	bx	lr
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e536:	2002      	movs	r0, #2
}
    e538:	4770      	bx	lr
    e53a:	bf00      	nop
    e53c:	01f956e2 	.word	0x01f956e2
    e540:	50011000 	.word	0x50011000

0000e544 <am_hal_pdm_dma_start>:
uint32_t
am_hal_pdm_dma_start(void *pHandle, am_hal_pdm_transfer_t *pDmaCfg)
{
    am_hal_pdm_state_t *pState = (am_hal_pdm_state_t *) pHandle;
    uint32_t ui32Module = pState->ui32Module;
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e544:	6803      	ldr	r3, [r0, #0]
    e546:	4a22      	ldr	r2, [pc, #136]	; (e5d0 <am_hal_pdm_dma_start+0x8c>)
    e548:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    e54c:	4293      	cmp	r3, r2
    e54e:	d113      	bne.n	e578 <am_hal_pdm_dma_start+0x34>
    // user asked for.
    //
    uint32_t ui32Threshold = 0;
    uint32_t ui32NumReloads = 1;

    for (ui32NumReloads = 1; ui32NumReloads < pDmaCfg->ui32TotalCount; ui32NumReloads++)
    e550:	684a      	ldr	r2, [r1, #4]
    e552:	2a01      	cmp	r2, #1
    e554:	d938      	bls.n	e5c8 <am_hal_pdm_dma_start+0x84>
{
    e556:	b410      	push	{r4}
    for (ui32NumReloads = 1; ui32NumReloads < pDmaCfg->ui32TotalCount; ui32NumReloads++)
    e558:	2301      	movs	r3, #1
    {
        //
        // Check to make sure the total count is evenly divisible into chunks
        // that are smaller than the maximum threshold size.
        //
        if (((pDmaCfg->ui32TotalCount % ui32NumReloads) == 0) &&
    e55a:	fbb2 f4f3 	udiv	r4, r2, r3
    e55e:	fb03 2014 	mls	r0, r3, r4, r2
    for (ui32NumReloads = 1; ui32NumReloads < pDmaCfg->ui32TotalCount; ui32NumReloads++)
    e562:	3301      	adds	r3, #1
        if (((pDmaCfg->ui32TotalCount % ui32NumReloads) == 0) &&
    e564:	b908      	cbnz	r0, e56a <am_hal_pdm_dma_start+0x26>
    e566:	2c1f      	cmp	r4, #31
    e568:	d908      	bls.n	e57c <am_hal_pdm_dma_start+0x38>
    for (ui32NumReloads = 1; ui32NumReloads < pDmaCfg->ui32TotalCount; ui32NumReloads++)
    e56a:	429a      	cmp	r2, r3
    e56c:	d1f5      	bne.n	e55a <am_hal_pdm_dma_start+0x16>
    //
    // If we didn't find a threshold that will work, throw an error.
    //
    if (ui32Threshold == 0)
    {
        return AM_HAL_PDM_STATUS_BAD_TOTALCOUNT;
    e56e:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
//
//    PDMn(ui32Module)->VCFG_b.RSTB = PDM_VCFG_RSTB_NORM;
//    PDMn(ui32Module)->VCFG_b.PDMCLKEN = 1;

    return AM_HAL_STATUS_SUCCESS;
}
    e572:	f85d 4b04 	ldr.w	r4, [sp], #4
    e576:	4770      	bx	lr
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e578:	2002      	movs	r0, #2
    e57a:	4770      	bx	lr
    if (ui32Threshold == 0)
    e57c:	2c00      	cmp	r4, #0
    e57e:	d0f6      	beq.n	e56e <am_hal_pdm_dma_start+0x2a>
    PDMn(ui32Module)->FIFOTHR = ui32Threshold;
    e580:	4b14      	ldr	r3, [pc, #80]	; (e5d4 <am_hal_pdm_dma_start+0x90>)
    e582:	615c      	str	r4, [r3, #20]
    PDMn(ui32Module)->DMACFG = 0;
    e584:	f8c3 0280 	str.w	r0, [r3, #640]	; 0x280
    PDMn(ui32Module)->DMACFG_b.DMAPRI = PDM_DMACFG_DMAPRI_LOW;
    e588:	f8b3 4280 	ldrh.w	r4, [r3, #640]	; 0x280
    e58c:	f360 2408 	bfi	r4, r0, #8, #1
    e590:	f8a3 4280 	strh.w	r4, [r3, #640]	; 0x280
    PDMn(ui32Module)->DMACFG_b.DMADIR = PDM_DMACFG_DMADIR_P2M;
    e594:	f8b3 4280 	ldrh.w	r4, [r3, #640]	; 0x280
    e598:	f360 0482 	bfi	r4, r0, #2, #1
    e59c:	f8a3 4280 	strh.w	r4, [r3, #640]	; 0x280
    PDMn(ui32Module)->DMATOTCOUNT = pDmaCfg->ui32TotalCount;
    e5a0:	f8c3 2288 	str.w	r2, [r3, #648]	; 0x288
    PDMn(ui32Module)->DMATARGADDR = pDmaCfg->ui32TargetAddr;
    e5a4:	680a      	ldr	r2, [r1, #0]
    e5a6:	f8c3 228c 	str.w	r2, [r3, #652]	; 0x28c
    PDMn(ui32Module)->DMATRIGEN_b.DTHR = 1;
    e5aa:	f893 2240 	ldrb.w	r2, [r3, #576]	; 0x240
    e5ae:	f042 0201 	orr.w	r2, r2, #1
    e5b2:	f883 2240 	strb.w	r2, [r3, #576]	; 0x240
    PDMn(ui32Module)->DMACFG_b.DMAEN = PDM_DMACFG_DMAEN_EN;
    e5b6:	f8b3 2280 	ldrh.w	r2, [r3, #640]	; 0x280
    e5ba:	f042 0201 	orr.w	r2, r2, #1
    e5be:	f8a3 2280 	strh.w	r2, [r3, #640]	; 0x280
}
    e5c2:	f85d 4b04 	ldr.w	r4, [sp], #4
    e5c6:	4770      	bx	lr
        return AM_HAL_PDM_STATUS_BAD_TOTALCOUNT;
    e5c8:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
}
    e5cc:	4770      	bx	lr
    e5ce:	bf00      	nop
    e5d0:	01f956e2 	.word	0x01f956e2
    e5d4:	50011000 	.word	0x50011000

0000e5d8 <am_hal_pdm_fifo_flush>:
uint32_t
am_hal_pdm_fifo_flush(void *pHandle)
{
    am_hal_pdm_state_t *pState = (am_hal_pdm_state_t *) pHandle;
    uint32_t ui32Module = pState->ui32Module;
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e5d8:	6803      	ldr	r3, [r0, #0]
    e5da:	4a06      	ldr	r2, [pc, #24]	; (e5f4 <am_hal_pdm_fifo_flush+0x1c>)
    e5dc:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    e5e0:	4293      	cmp	r3, r2
    e5e2:	d104      	bne.n	e5ee <am_hal_pdm_fifo_flush+0x16>

    PDMn(ui32Module)->FIFOFLUSH = 1;
    e5e4:	4b04      	ldr	r3, [pc, #16]	; (e5f8 <am_hal_pdm_fifo_flush+0x20>)
    e5e6:	2201      	movs	r2, #1
    e5e8:	611a      	str	r2, [r3, #16]

    return AM_HAL_STATUS_SUCCESS;
    e5ea:	2000      	movs	r0, #0
    e5ec:	4770      	bx	lr
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e5ee:	2002      	movs	r0, #2
}
    e5f0:	4770      	bx	lr
    e5f2:	bf00      	nop
    e5f4:	01f956e2 	.word	0x01f956e2
    e5f8:	50011000 	.word	0x50011000

0000e5fc <am_hal_pdm_interrupt_enable>:
    uint32_t ui32Module = pState->ui32Module;

    //
    // Check the handle.
    //
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e5fc:	6803      	ldr	r3, [r0, #0]
    e5fe:	4a07      	ldr	r2, [pc, #28]	; (e61c <am_hal_pdm_interrupt_enable+0x20>)
    e600:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    e604:	4293      	cmp	r3, r2
    e606:	d107      	bne.n	e618 <am_hal_pdm_interrupt_enable+0x1c>

    PDMn(ui32Module)->INTEN |= ui32IntMask;
    e608:	4a05      	ldr	r2, [pc, #20]	; (e620 <am_hal_pdm_interrupt_enable+0x24>)
    e60a:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
    e60e:	4319      	orrs	r1, r3
    e610:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200

    return AM_HAL_STATUS_SUCCESS;
    e614:	2000      	movs	r0, #0
    e616:	4770      	bx	lr
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e618:	2002      	movs	r0, #2
}
    e61a:	4770      	bx	lr
    e61c:	01f956e2 	.word	0x01f956e2
    e620:	50011000 	.word	0x50011000

0000e624 <am_hal_pdm_interrupt_clear>:
    uint32_t ui32Module = pState->ui32Module;

    //
    // Check the handle.
    //
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e624:	6803      	ldr	r3, [r0, #0]
    e626:	4a05      	ldr	r2, [pc, #20]	; (e63c <am_hal_pdm_interrupt_clear+0x18>)
    e628:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    e62c:	4293      	cmp	r3, r2

    PDMn(ui32Module)->INTCLR = ui32IntMask;
    e62e:	bf03      	ittte	eq
    e630:	4b03      	ldreq	r3, [pc, #12]	; (e640 <am_hal_pdm_interrupt_clear+0x1c>)

    return AM_HAL_STATUS_SUCCESS;
    e632:	2000      	moveq	r0, #0
    PDMn(ui32Module)->INTCLR = ui32IntMask;
    e634:	f8c3 1208 	streq.w	r1, [r3, #520]	; 0x208
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e638:	2002      	movne	r0, #2
}
    e63a:	4770      	bx	lr
    e63c:	01f956e2 	.word	0x01f956e2
    e640:	50011000 	.word	0x50011000

0000e644 <am_hal_pdm_interrupt_status_get>:
    uint32_t ui32Module = pState->ui32Module;

    //
    // Check the handle.
    //
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e644:	6803      	ldr	r3, [r0, #0]
    e646:	480c      	ldr	r0, [pc, #48]	; (e678 <am_hal_pdm_interrupt_status_get+0x34>)
    e648:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    e64c:	4283      	cmp	r3, r0
    e64e:	d110      	bne.n	e672 <am_hal_pdm_interrupt_status_get+0x2e>

    //
    // If requested, only return the interrupts that are enabled.
    //
    if ( bEnabledOnly )
    e650:	b92a      	cbnz	r2, e65e <am_hal_pdm_interrupt_status_get+0x1a>
        *pui32Status = PDMn(ui32Module)->INTSTAT;
        *pui32Status &= PDMn(ui32Module)->INTEN;
    }
    else
    {
        *pui32Status = PDMn(ui32Module)->INTSTAT;
    e652:	4b0a      	ldr	r3, [pc, #40]	; (e67c <am_hal_pdm_interrupt_status_get+0x38>)
    e654:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
    e658:	600b      	str	r3, [r1, #0]
    }

    return AM_HAL_STATUS_SUCCESS;
    e65a:	4610      	mov	r0, r2
    e65c:	4770      	bx	lr
        *pui32Status = PDMn(ui32Module)->INTSTAT;
    e65e:	4a07      	ldr	r2, [pc, #28]	; (e67c <am_hal_pdm_interrupt_status_get+0x38>)
    e660:	f8d2 3204 	ldr.w	r3, [r2, #516]	; 0x204
    e664:	600b      	str	r3, [r1, #0]
        *pui32Status &= PDMn(ui32Module)->INTEN;
    e666:	f8d2 2200 	ldr.w	r2, [r2, #512]	; 0x200
    e66a:	4013      	ands	r3, r2
    e66c:	600b      	str	r3, [r1, #0]
    return AM_HAL_STATUS_SUCCESS;
    e66e:	2000      	movs	r0, #0
    e670:	4770      	bx	lr
    AM_HAL_PDM_HANDLE_CHECK(pHandle);
    e672:	2002      	movs	r0, #2
}
    e674:	4770      	bx	lr
    e676:	bf00      	nop
    e678:	01f956e2 	.word	0x01f956e2
    e67c:	50011000 	.word	0x50011000

0000e680 <am_hal_gpio_pinconfig>:
    uint32_t ui32Padreg, ui32AltPadCfg, ui32GPCfg;
    uint32_t ui32Funcsel, ui32PowerSw;
    bool bClearEnable = false;

#ifdef AM_HAL_ENABLE_API_VALIDATION
    if ( ui32Pin > 49 )
    e680:	2831      	cmp	r0, #49	; 0x31
    e682:	f200 80c2 	bhi.w	e80a <am_hal_gpio_pinconfig+0x18a>
{
    e686:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ui32GPCfg = ui32Padreg = ui32AltPadCfg = 0;

    //
    // Get the requested function and/or power switch.
    //
    ui32Funcsel = bfGpioCfg.uFuncSel;
    e68a:	f001 0207 	and.w	r2, r1, #7
    ui32Padreg |= ui32Funcsel << PADREG_FLD_FNSEL_S;

    //
    // Check for invalid configuration requests.
    //
    if ( bfGpioCfg.ePullup != AM_HAL_GPIO_PIN_PULLUP_NONE )
    e68e:	f011 07e0 	ands.w	r7, r1, #224	; 0xe0
{
    e692:	b087      	sub	sp, #28
    ui32Padreg |= ui32Funcsel << PADREG_FLD_FNSEL_S;
    e694:	ea4f 03c2 	mov.w	r3, r2, lsl #3
    ui32PowerSw = bfGpioCfg.ePowerSw;
    e698:	f3c1 04c1 	ubfx	r4, r1, #3, #2
    if ( bfGpioCfg.ePullup != AM_HAL_GPIO_PIN_PULLUP_NONE )
    e69c:	d011      	beq.n	e6c2 <am_hal_gpio_pinconfig+0x42>
        ui32Padreg |= (0x1 << PADREG_FLD_PULLUP_S);

        //
        // Check for specific pullup or pulldown settings.
        //
        if ( (bfGpioCfg.ePullup >= AM_HAL_GPIO_PIN_PULLUP_1_5K) &&
    e69e:	f3c1 1642 	ubfx	r6, r1, #5, #3
    e6a2:	1db5      	adds	r5, r6, #6
    e6a4:	f005 0507 	and.w	r5, r5, #7
    e6a8:	2d03      	cmp	r5, #3
        ui32Padreg |= (0x1 << PADREG_FLD_PULLUP_S);
    e6aa:	f043 0301 	orr.w	r3, r3, #1
        if ( (bfGpioCfg.ePullup >= AM_HAL_GPIO_PIN_PULLUP_1_5K) &&
    e6ae:	f200 80ae 	bhi.w	e80e <am_hal_gpio_pinconfig+0x18e>
             (bfGpioCfg.ePullup <= AM_HAL_GPIO_PIN_PULLUP_24K) )
        {
            ui32Padreg |= ((bfGpioCfg.ePullup - AM_HAL_GPIO_PIN_PULLUP_1_5K) <<
                           PADREG_FLD_76_S);
#ifdef AM_HAL_ENABLE_API_VALIDATION
            if ( !(g_ui8Bit76Capabilities[ui32Pin] & CAP_PUP) )
    e6b2:	4d85      	ldr	r5, [pc, #532]	; (e8c8 <am_hal_gpio_pinconfig+0x248>)
    e6b4:	5c2d      	ldrb	r5, [r5, r0]
    e6b6:	07ef      	lsls	r7, r5, #31
    e6b8:	f140 80b4 	bpl.w	e824 <am_hal_gpio_pinconfig+0x1a4>
            ui32Padreg |= ((bfGpioCfg.ePullup - AM_HAL_GPIO_PIN_PULLUP_1_5K) <<
    e6bc:	3e02      	subs	r6, #2
    e6be:	ea43 1386 	orr.w	r3, r3, r6, lsl #6
    }

    //
    // Check if requesting a power switch pin
    //
    if ( ui32PowerSw != AM_HAL_GPIO_PIN_POWERSW_NONE )
    e6c2:	2c00      	cmp	r4, #0
    e6c4:	f040 8096 	bne.w	e7f4 <am_hal_gpio_pinconfig+0x174>
    }

    //
    // Depending on the selected pin and FNSEL, determine if INPEN needs to be set.
    //
    ui32Padreg |= (g_ui8Inpen[ui32Pin] & (1 << ui32Funcsel)) ? (1 << PADREG_FLD_INPEN_S) : 0;
    e6c8:	4d80      	ldr	r5, [pc, #512]	; (e8cc <am_hal_gpio_pinconfig+0x24c>)

    //
    // Configure ui32GpCfg based on whether nCE requested.
    //
    if ( g_ui8nCEpins[ui32Pin] == ui32Funcsel )
    e6ca:	4c81      	ldr	r4, [pc, #516]	; (e8d0 <am_hal_gpio_pinconfig+0x250>)
    ui32Padreg |= (g_ui8Inpen[ui32Pin] & (1 << ui32Funcsel)) ? (1 << PADREG_FLD_INPEN_S) : 0;
    e6cc:	5c2d      	ldrb	r5, [r5, r0]
    if ( g_ui8nCEpins[ui32Pin] == ui32Funcsel )
    e6ce:	5c24      	ldrb	r4, [r4, r0]
    ui32Padreg |= (g_ui8Inpen[ui32Pin] & (1 << ui32Funcsel)) ? (1 << PADREG_FLD_INPEN_S) : 0;
    e6d0:	4115      	asrs	r5, r2
    e6d2:	006d      	lsls	r5, r5, #1
    e6d4:	f005 0502 	and.w	r5, r5, #2
    if ( g_ui8nCEpins[ui32Pin] == ui32Funcsel )
    e6d8:	4294      	cmp	r4, r2
    ui32Padreg |= (g_ui8Inpen[ui32Pin] & (1 << ui32Funcsel)) ? (1 << PADREG_FLD_INPEN_S) : 0;
    e6da:	ea45 0503 	orr.w	r5, r5, r3
    if ( g_ui8nCEpins[ui32Pin] == ui32Funcsel )
    e6de:	f000 80b0 	beq.w	e842 <am_hal_gpio_pinconfig+0x1c2>
        //  [INTD(1):OUTCFG(2):INCFG(1)].
        // Bit0 of eIntDir maps to GPIOCFG.INTD  (b3).
        // Bit1 of eIntDir maps to GPIOCFG.INCFG (b0).
        //
        ui32GPCfg |= (bfGpioCfg.eGPOutcfg << GPIOCFG_FLD_OUTCFG_S)              |
                     (((bfGpioCfg.eIntDir >> 0) & 0x1) << GPIOCFG_FLD_INTD_S)   |
    e6e2:	f3c1 3341 	ubfx	r3, r1, #13, #2
                     (((bfGpioCfg.eIntDir >> 1) & 0x1) << GPIOCFG_FLD_INCFG_S);

        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
    e6e6:	f3c1 2407 	ubfx	r4, r1, #8, #8
                     (((bfGpioCfg.eIntDir >> 1) & 0x1) << GPIOCFG_FLD_INCFG_S);
    e6ea:	105a      	asrs	r2, r3, #1
        ui32GPCfg |= (bfGpioCfg.eGPOutcfg << GPIOCFG_FLD_OUTCFG_S)              |
    e6ec:	f3c1 2681 	ubfx	r6, r1, #10, #2
                     (((bfGpioCfg.eIntDir >> 0) & 0x1) << GPIOCFG_FLD_INTD_S)   |
    e6f0:	00db      	lsls	r3, r3, #3
        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
    e6f2:	f004 070c 	and.w	r7, r4, #12
                     (((bfGpioCfg.eIntDir >> 0) & 0x1) << GPIOCFG_FLD_INTD_S)   |
    e6f6:	ea42 0646 	orr.w	r6, r2, r6, lsl #1
    e6fa:	f003 0308 	and.w	r3, r3, #8
        ui32Padreg |= (bfGpioCfg.eGPInput << PADREG_FLD_INPEN_S);
    e6fe:	f3c1 3200 	ubfx	r2, r1, #12, #1
        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
    e702:	2f04      	cmp	r7, #4
                     (((bfGpioCfg.eIntDir >> 0) & 0x1) << GPIOCFG_FLD_INTD_S)   |
    e704:	ea46 0603 	orr.w	r6, r6, r3
        ui32Padreg |= (bfGpioCfg.eGPInput << PADREG_FLD_INPEN_S);
    e708:	ea45 0542 	orr.w	r5, r5, r2, lsl #1
        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
    e70c:	f000 8093 	beq.w	e836 <am_hal_gpio_pinconfig+0x1b6>
    ui32B = *((uint32_t*)cfg2);
    e710:	4b70      	ldr	r3, [pc, #448]	; (e8d4 <am_hal_gpio_pinconfig+0x254>)
        if ( (bfGpioCfg.eGPOutcfg == AM_HAL_GPIO_PIN_OUTCFG_PUSHPULL) ||
    e712:	681b      	ldr	r3, [r3, #0]
    e714:	1acb      	subs	r3, r1, r3
    e716:	fab3 f383 	clz	r3, r3
    e71a:	095b      	lsrs	r3, r3, #5
        //  use when GPIO interrupts are not in use and can be used when no
        //  eIntDir setting is provided.
        // If eIntDir is provided, eGPRdZero is ignored and can only be
        //  achieved via the AM_HAL_GPIO_PIN_INTDIR_NONE setting.
        //
        if ( bfGpioCfg.eIntDir == 0 )
    e71c:	f014 0f60 	tst.w	r4, #96	; 0x60
        {
            ui32GPCfg &= ~(1 << GPIOCFG_FLD_INCFG_S);
            ui32GPCfg |= (bfGpioCfg.eGPRdZero << GPIOCFG_FLD_INCFG_S);
    e720:	bf04      	itt	eq
    e722:	f3c1 32c0 	ubfxeq	r2, r1, #15, #1
    e726:	f362 0600 	bfieq	r6, r2, #0, #1
    e72a:	ea4f 0e80 	mov.w	lr, r0, lsl #2
        }
    }

    switch ( bfGpioCfg.eDriveStrength )
    e72e:	f3c1 2101 	ubfx	r1, r1, #8, #2
    e732:	ea4f 0cc0 	mov.w	ip, r0, lsl #3
    e736:	2902      	cmp	r1, #2
    e738:	f00c 0c18 	and.w	ip, ip, #24
    e73c:	f000 80a7 	beq.w	e88e <am_hal_gpio_pinconfig+0x20e>
    e740:	f200 809e 	bhi.w	e880 <am_hal_gpio_pinconfig+0x200>
    e744:	2901      	cmp	r1, #1
    e746:	f040 8098 	bne.w	e87a <am_hal_gpio_pinconfig+0x1fa>
            ui32AltPadCfg |= (0 << 0);
            break;
        case AM_HAL_GPIO_PIN_DRIVESTRENGTH_4MA:
            ui32Padreg    |= (1 << PADREG_FLD_DRVSTR_S);
            ui32AltPadCfg |= (0 << 0);
            break;
    e74a:	2200      	movs	r2, #0
            ui32Padreg    |= (1 << PADREG_FLD_DRVSTR_S);
    e74c:	f045 0504 	orr.w	r5, r5, #4
            break;
    e750:	9203      	str	r2, [sp, #12]
    e752:	4604      	mov	r4, r0
    uint32_t ui32GPCfgClearMask, ui32PadClearMask;
    uint32_t ui32GPCfgShft, ui32PadShft;

    ui32GPCfgAddr       = (uint32_t)&GPIO->CFGA       + ((ui32Pin & ~0x7) >> 1);
    ui32PadregAddr      = (uint32_t)&GPIO->PADREGA    + (ui32Pin & ~0x3);
    ui32AltpadAddr      = (uint32_t)&GPIO->ALTPADCFGA + (ui32Pin & ~0x3);
    e754:	4a60      	ldr	r2, [pc, #384]	; (e8d8 <am_hal_gpio_pinconfig+0x258>)
    e756:	4961      	ldr	r1, [pc, #388]	; (e8dc <am_hal_gpio_pinconfig+0x25c>)
    ui32GPCfgAddr       = (uint32_t)&GPIO->CFGA       + ((ui32Pin & ~0x7) >> 1);
    e758:	4861      	ldr	r0, [pc, #388]	; (e8e0 <am_hal_gpio_pinconfig+0x260>)
    e75a:	9302      	str	r3, [sp, #8]
    ui32GPCfgShft       = ((ui32Pin & 0x7) << 2);
    e75c:	f00e 0e1c 	and.w	lr, lr, #28
    ui32PadShft         = ((ui32Pin & 0x3) << 3);
    ui32GPCfgClearMask  = ~((uint32_t)0xF  << ui32GPCfgShft);
    e760:	f04f 080f 	mov.w	r8, #15
    ui32PadClearMask    = ~((uint32_t)0xFF << ui32PadShft);
    e764:	27ff      	movs	r7, #255	; 0xff
    ui32AltpadAddr      = (uint32_t)&GPIO->ALTPADCFGA + (ui32Pin & ~0x3);
    e766:	e9cd 2100 	strd	r2, r1, [sp]
    ui32GPCfgClearMask  = ~((uint32_t)0xF  << ui32GPCfgShft);
    e76a:	fa08 f80e 	lsl.w	r8, r8, lr
    ui32PadClearMask    = ~((uint32_t)0xFF << ui32PadShft);
    e76e:	fa07 f70c 	lsl.w	r7, r7, ip
    //
    // Get the new values into their rightful bit positions.
    //
    ui32Padreg    <<= ui32PadShft;
    ui32AltPadCfg <<= ui32PadShft;
    ui32GPCfg     <<= ui32GPCfgShft;
    e772:	fa06 f60e 	lsl.w	r6, r6, lr
    ui32Padreg    <<= ui32PadShft;
    e776:	fa05 f50c 	lsl.w	r5, r5, ip
    ui32GPCfgAddr       = (uint32_t)&GPIO->CFGA       + ((ui32Pin & ~0x7) >> 1);
    e77a:	ea00 0954 	and.w	r9, r0, r4, lsr #1

    AM_CRITICAL_BEGIN
    e77e:	f004 f8f9 	bl	12974 <am_hal_interrupt_master_disable>
    ui32PadregAddr      = (uint32_t)&GPIO->PADREGA    + (ui32Pin & ~0x3);
    e782:	f024 0b03 	bic.w	fp, r4, #3

    if ( bClearEnable )
    e786:	9b02      	ldr	r3, [sp, #8]
    AM_CRITICAL_BEGIN
    e788:	9005      	str	r0, [sp, #20]
    ui32PadregAddr      = (uint32_t)&GPIO->PADREGA    + (ui32Pin & ~0x3);
    e78a:	f10b 4a80 	add.w	sl, fp, #1073741824	; 0x40000000
    ui32GPCfgClearMask  = ~((uint32_t)0xF  << ui32GPCfgShft);
    e78e:	ea6f 0808 	mvn.w	r8, r8
    ui32PadClearMask    = ~((uint32_t)0xFF << ui32PadShft);
    e792:	43ff      	mvns	r7, r7
    ui32PadregAddr      = (uint32_t)&GPIO->PADREGA    + (ui32Pin & ~0x3);
    e794:	f50a 3a80 	add.w	sl, sl, #65536	; 0x10000
    if ( bClearEnable )
    e798:	e9dd 2100 	ldrd	r2, r1, [sp]
    e79c:	b14b      	cbz	r3, e7b2 <am_hal_gpio_pinconfig+0x132>
    {
        //
        // We're configuring a mode that requires clearing the Enable bit.
        //
        am_hal_gpio_output_tristate_disable(ui32Pin);
    e79e:	f004 031f 	and.w	r3, r4, #31
    e7a2:	f04f 0c01 	mov.w	ip, #1
    e7a6:	0964      	lsrs	r4, r4, #5
    e7a8:	484e      	ldr	r0, [pc, #312]	; (e8e4 <am_hal_gpio_pinconfig+0x264>)
    e7aa:	fa0c f303 	lsl.w	r3, ip, r3
    e7ae:	f840 3024 	str.w	r3, [r0, r4, lsl #2]
    }

    GPIO->PADKEY = GPIO_PADKEY_PADKEY_Key;
    e7b2:	4b4d      	ldr	r3, [pc, #308]	; (e8e8 <am_hal_gpio_pinconfig+0x268>)
    e7b4:	2073      	movs	r0, #115	; 0x73
    e7b6:	6618      	str	r0, [r3, #96]	; 0x60

    AM_REGVAL(ui32PadregAddr)  = (AM_REGVAL(ui32PadregAddr) & ui32PadClearMask)   | ui32Padreg;
    e7b8:	f8da 0000 	ldr.w	r0, [sl]
    e7bc:	4038      	ands	r0, r7
    e7be:	4305      	orrs	r5, r0
    e7c0:	f8ca 5000 	str.w	r5, [sl]
    AM_REGVAL(ui32GPCfgAddr)   = (AM_REGVAL(ui32GPCfgAddr)  & ui32GPCfgClearMask) | ui32GPCfg;
    e7c4:	f859 0001 	ldr.w	r0, [r9, r1]
    e7c8:	ea00 0808 	and.w	r8, r0, r8
    e7cc:	ea48 0606 	orr.w	r6, r8, r6
    e7d0:	f849 6001 	str.w	r6, [r9, r1]
    AM_REGVAL(ui32AltpadAddr)  = (AM_REGVAL(ui32AltpadAddr) & ui32PadClearMask)   | ui32AltPadCfg;
    e7d4:	f85b 1002 	ldr.w	r1, [fp, r2]
    e7d8:	400f      	ands	r7, r1
    e7da:	9903      	ldr	r1, [sp, #12]

    GPIO->PADKEY = 0;
    e7dc:	2400      	movs	r4, #0
    AM_REGVAL(ui32AltpadAddr)  = (AM_REGVAL(ui32AltpadAddr) & ui32PadClearMask)   | ui32AltPadCfg;
    e7de:	430f      	orrs	r7, r1
    e7e0:	f84b 7002 	str.w	r7, [fp, r2]
    GPIO->PADKEY = 0;
    e7e4:	661c      	str	r4, [r3, #96]	; 0x60

    AM_CRITICAL_END
    e7e6:	9805      	ldr	r0, [sp, #20]
    e7e8:	f004 f8c8 	bl	1297c <am_hal_interrupt_master_set>

    return AM_HAL_STATUS_SUCCESS;
    e7ec:	4620      	mov	r0, r4

} // am_hal_gpio_pinconfig()
    e7ee:	b007      	add	sp, #28
    e7f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ( (ui32PowerSw == AM_HAL_GPIO_PIN_POWERSW_VDD)  &&
    e7f4:	2c01      	cmp	r4, #1
    e7f6:	d017      	beq.n	e828 <am_hal_gpio_pinconfig+0x1a8>
        else if ( (ui32PowerSw == AM_HAL_GPIO_PIN_POWERSW_VSS)  &&
    e7f8:	2c02      	cmp	r4, #2
    e7fa:	d11e      	bne.n	e83a <am_hal_gpio_pinconfig+0x1ba>
                  (g_ui8Bit76Capabilities[ui32Pin] & CAP_VSS) )
    e7fc:	4c32      	ldr	r4, [pc, #200]	; (e8c8 <am_hal_gpio_pinconfig+0x248>)
        else if ( (ui32PowerSw == AM_HAL_GPIO_PIN_POWERSW_VSS)  &&
    e7fe:	5c24      	ldrb	r4, [r4, r0]
    e800:	0764      	lsls	r4, r4, #29
    e802:	d51a      	bpl.n	e83a <am_hal_gpio_pinconfig+0x1ba>
            ui32Padreg |= 0x2 << PADREG_FLD_76_S;
    e804:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    e808:	e75e      	b.n	e6c8 <am_hal_gpio_pinconfig+0x48>
        return AM_HAL_STATUS_INVALID_ARG;
    e80a:	2006      	movs	r0, #6
} // am_hal_gpio_pinconfig()
    e80c:	4770      	bx	lr
        else if ( bfGpioCfg.ePullup == AM_HAL_GPIO_PIN_PULLDOWN )
    e80e:	2fc0      	cmp	r7, #192	; 0xc0
    e810:	d042      	beq.n	e898 <am_hal_gpio_pinconfig+0x218>
        else if ( bfGpioCfg.ePullup == AM_HAL_GPIO_PIN_PULLUP_WEAK )
    e812:	2f20      	cmp	r7, #32
    e814:	f47f af55 	bne.w	e6c2 <am_hal_gpio_pinconfig+0x42>
            if ( g_ui8Bit76Capabilities[ui32Pin] & (CAP_PUP | CAP_PDN) )
    e818:	4d2b      	ldr	r5, [pc, #172]	; (e8c8 <am_hal_gpio_pinconfig+0x248>)
    e81a:	5c2d      	ldrb	r5, [r5, r0]
    e81c:	f015 0f09 	tst.w	r5, #9
    e820:	f43f af4f 	beq.w	e6c2 <am_hal_gpio_pinconfig+0x42>
                return AM_HAL_GPIO_ERR_PULLUP;
    e824:	4831      	ldr	r0, [pc, #196]	; (e8ec <am_hal_gpio_pinconfig+0x26c>)
    e826:	e7e2      	b.n	e7ee <am_hal_gpio_pinconfig+0x16e>
             (g_ui8Bit76Capabilities[ui32Pin] & CAP_VDD) )
    e828:	4c27      	ldr	r4, [pc, #156]	; (e8c8 <am_hal_gpio_pinconfig+0x248>)
        if ( (ui32PowerSw == AM_HAL_GPIO_PIN_POWERSW_VDD)  &&
    e82a:	5c24      	ldrb	r4, [r4, r0]
    e82c:	07a5      	lsls	r5, r4, #30
    e82e:	d504      	bpl.n	e83a <am_hal_gpio_pinconfig+0x1ba>
            ui32Padreg |= 0x1 << PADREG_FLD_76_S;
    e830:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    e834:	e748      	b.n	e6c8 <am_hal_gpio_pinconfig+0x48>
            bClearEnable = true;
    e836:	2301      	movs	r3, #1
    e838:	e770      	b.n	e71c <am_hal_gpio_pinconfig+0x9c>
            return AM_HAL_GPIO_ERR_PWRSW;
    e83a:	482d      	ldr	r0, [pc, #180]	; (e8f0 <am_hal_gpio_pinconfig+0x270>)
} // am_hal_gpio_pinconfig()
    e83c:	b007      	add	sp, #28
    e83e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ( bfGpioCfg.uIOMnum > IOMNUM_MAX )
    e842:	f3c1 4302 	ubfx	r3, r1, #16, #3
    e846:	2b07      	cmp	r3, #7
    e848:	d02b      	beq.n	e8a2 <am_hal_gpio_pinconfig+0x222>
            if ( g_ui8NCEtable[ui32Pin][ui32Outcfg] == ui8CEtbl )
    e84a:	4c2a      	ldr	r4, [pc, #168]	; (e8f4 <am_hal_gpio_pinconfig+0x274>)
        ui8CEtbl = (bfGpioCfg.uIOMnum << 4) | bfGpioCfg.uNCE;
    e84c:	f3c1 42c1 	ubfx	r2, r1, #19, #2
            if ( g_ui8NCEtable[ui32Pin][ui32Outcfg] == ui8CEtbl )
    e850:	f814 6020 	ldrb.w	r6, [r4, r0, lsl #2]
        ui8CEtbl = (bfGpioCfg.uIOMnum << 4) | bfGpioCfg.uNCE;
    e854:	ea42 1303 	orr.w	r3, r2, r3, lsl #4
            if ( g_ui8NCEtable[ui32Pin][ui32Outcfg] == ui8CEtbl )
    e858:	429e      	cmp	r6, r3
    e85a:	d024      	beq.n	e8a6 <am_hal_gpio_pinconfig+0x226>
    e85c:	ea4f 0e80 	mov.w	lr, r0, lsl #2
    e860:	eb04 020e 	add.w	r2, r4, lr
    e864:	7854      	ldrb	r4, [r2, #1]
    e866:	429c      	cmp	r4, r3
    e868:	d027      	beq.n	e8ba <am_hal_gpio_pinconfig+0x23a>
    e86a:	7894      	ldrb	r4, [r2, #2]
    e86c:	429c      	cmp	r4, r3
    e86e:	d026      	beq.n	e8be <am_hal_gpio_pinconfig+0x23e>
    e870:	78d2      	ldrb	r2, [r2, #3]
    e872:	429a      	cmp	r2, r3
    e874:	d025      	beq.n	e8c2 <am_hal_gpio_pinconfig+0x242>
            return AM_HAL_GPIO_ERR_INVCEPIN;
    e876:	4820      	ldr	r0, [pc, #128]	; (e8f8 <am_hal_gpio_pinconfig+0x278>)
    e878:	e7b9      	b.n	e7ee <am_hal_gpio_pinconfig+0x16e>
    switch ( bfGpioCfg.eDriveStrength )
    e87a:	2200      	movs	r2, #0
    e87c:	9203      	str	r2, [sp, #12]
    e87e:	e768      	b.n	e752 <am_hal_gpio_pinconfig+0xd2>
    e880:	2701      	movs	r7, #1
    e882:	fa07 f20c 	lsl.w	r2, r7, ip
            ui32Padreg    |= (1 << PADREG_FLD_DRVSTR_S);
    e886:	f045 0504 	orr.w	r5, r5, #4
    e88a:	9203      	str	r2, [sp, #12]
            break;
    e88c:	e761      	b.n	e752 <am_hal_gpio_pinconfig+0xd2>
    e88e:	2701      	movs	r7, #1
    e890:	fa07 f20c 	lsl.w	r2, r7, ip
    e894:	9203      	str	r2, [sp, #12]
            break;
    e896:	e75c      	b.n	e752 <am_hal_gpio_pinconfig+0xd2>
            if ( ui32Pin != 20 )
    e898:	2814      	cmp	r0, #20
    e89a:	f43f af12 	beq.w	e6c2 <am_hal_gpio_pinconfig+0x42>
                return AM_HAL_GPIO_ERR_PULLDOWN;
    e89e:	4817      	ldr	r0, [pc, #92]	; (e8fc <am_hal_gpio_pinconfig+0x27c>)
    e8a0:	e7a5      	b.n	e7ee <am_hal_gpio_pinconfig+0x16e>
            return AM_HAL_GPIO_ERR_INVCE;   // Invalid CE specified
    e8a2:	4817      	ldr	r0, [pc, #92]	; (e900 <am_hal_gpio_pinconfig+0x280>)
    e8a4:	e7a3      	b.n	e7ee <am_hal_gpio_pinconfig+0x16e>
        for ( ui32Outcfg = 0; ui32Outcfg < 4; ui32Outcfg++ )
    e8a6:	2600      	movs	r6, #0
    e8a8:	ea4f 0e80 	mov.w	lr, r0, lsl #2
                     (bfGpioCfg.eCEpol << GPIOCFG_FLD_INTD_S)   |
    e8ac:	f3c1 5340 	ubfx	r3, r1, #21, #1
        ui32GPCfg |= (ui32Outcfg       << GPIOCFG_FLD_OUTCFG_S) |
    e8b0:	0076      	lsls	r6, r6, #1
                     (bfGpioCfg.eCEpol << GPIOCFG_FLD_INTD_S)   |
    e8b2:	ea46 06c3 	orr.w	r6, r6, r3, lsl #3
    bool bClearEnable = false;
    e8b6:	2300      	movs	r3, #0
    e8b8:	e739      	b.n	e72e <am_hal_gpio_pinconfig+0xae>
        for ( ui32Outcfg = 0; ui32Outcfg < 4; ui32Outcfg++ )
    e8ba:	2601      	movs	r6, #1
    e8bc:	e7f6      	b.n	e8ac <am_hal_gpio_pinconfig+0x22c>
    e8be:	2602      	movs	r6, #2
    e8c0:	e7f4      	b.n	e8ac <am_hal_gpio_pinconfig+0x22c>
    e8c2:	2603      	movs	r6, #3
    e8c4:	e7f2      	b.n	e8ac <am_hal_gpio_pinconfig+0x22c>
    e8c6:	bf00      	nop
    e8c8:	0001380c 	.word	0x0001380c
    e8cc:	00013840 	.word	0x00013840
    e8d0:	0001393c 	.word	0x0001393c
    e8d4:	00013800 	.word	0x00013800
    e8d8:	400100e0 	.word	0x400100e0
    e8dc:	40010040 	.word	0x40010040
    e8e0:	7ffffffc 	.word	0x7ffffffc
    e8e4:	400100b4 	.word	0x400100b4
    e8e8:	40010000 	.word	0x40010000
    e8ec:	08000100 	.word	0x08000100
    e8f0:	08000102 	.word	0x08000102
    e8f4:	00013874 	.word	0x00013874
    e8f8:	08000104 	.word	0x08000104
    e8fc:	08000101 	.word	0x08000101
    e900:	08000103 	.word	0x08000103

0000e904 <am_hal_gpio_state_read>:
{
    uint32_t ui32ReadValue = 0xFFFFFFFF;
    uint32_t ui32BaseAddr, ui32Shift;

#ifdef AM_HAL_ENABLE_API_VALIDATION
    if ( pui32ReadState == NULL )
    e904:	b1a2      	cbz	r2, e930 <am_hal_gpio_state_read+0x2c>
    {
        return AM_HAL_STATUS_INVALID_ARG;
    }

    if ( ui32Pin >= AM_HAL_GPIO_MAX_PADS )
    e906:	2831      	cmp	r0, #49	; 0x31
    e908:	d814      	bhi.n	e934 <am_hal_gpio_state_read+0x30>
    //
    ui32BaseAddr = ((ui32Pin & 0x20) >> (3 + 2));   // 0 or 1
    ui32Shift    = ui32Pin & 0x1F;
    //ui32Mask     = 1 << ui32Shift;

    switch ( eReadType )
    e90a:	2901      	cmp	r1, #1
    ui32BaseAddr = ((ui32Pin & 0x20) >> (3 + 2));   // 0 or 1
    e90c:	ea4f 1350 	mov.w	r3, r0, lsr #5
    ui32Shift    = ui32Pin & 0x1F;
    e910:	f000 001f 	and.w	r0, r0, #31
    switch ( eReadType )
    e914:	d013      	beq.n	e93e <am_hal_gpio_state_read+0x3a>
    e916:	d31c      	bcc.n	e952 <am_hal_gpio_state_read+0x4e>
    e918:	2902      	cmp	r1, #2
    e91a:	d109      	bne.n	e930 <am_hal_gpio_state_read+0x2c>
        case AM_HAL_GPIO_OUTPUT_READ:
            ui32ReadValue = AM_REGVAL(&GPIO->WTA + ui32BaseAddr);
            ui32ReadValue = (ui32ReadValue >> ui32Shift) & 0x01;
            break;
        case AM_HAL_GPIO_ENABLE_READ:
            ui32ReadValue = AM_REGVAL(&GPIO->ENA + ui32BaseAddr);
    e91c:	4912      	ldr	r1, [pc, #72]	; (e968 <am_hal_gpio_state_read+0x64>)
    e91e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
            ui32ReadValue = (ui32ReadValue >> ui32Shift) & 0x01;
    e922:	fa23 f000 	lsr.w	r0, r3, r0
    e926:	f000 0001 	and.w	r0, r0, #1
            break;
        default:
            return AM_HAL_STATUS_INVALID_ARG;
    }

    *pui32ReadState = ui32ReadValue;
    e92a:	6010      	str	r0, [r2, #0]

    return AM_HAL_STATUS_SUCCESS;
    e92c:	2000      	movs	r0, #0
    e92e:	4770      	bx	lr
            return AM_HAL_STATUS_INVALID_ARG;
    e930:	2006      	movs	r0, #6
} // am_hal_gpio_state_read()
    e932:	4770      	bx	lr
        *pui32ReadState = ui32ReadValue;
    e934:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    e938:	6013      	str	r3, [r2, #0]
        return AM_HAL_STATUS_OUT_OF_RANGE;
    e93a:	2005      	movs	r0, #5
    e93c:	4770      	bx	lr
            ui32ReadValue = AM_REGVAL(&GPIO->WTA + ui32BaseAddr);
    e93e:	490b      	ldr	r1, [pc, #44]	; (e96c <am_hal_gpio_state_read+0x68>)
    e940:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
            ui32ReadValue = (ui32ReadValue >> ui32Shift) & 0x01;
    e944:	fa23 f000 	lsr.w	r0, r3, r0
    e948:	f000 0001 	and.w	r0, r0, #1
    *pui32ReadState = ui32ReadValue;
    e94c:	6010      	str	r0, [r2, #0]
    return AM_HAL_STATUS_SUCCESS;
    e94e:	2000      	movs	r0, #0
    e950:	4770      	bx	lr
            ui32ReadValue = AM_REGVAL(&GPIO->RDA + ui32BaseAddr);
    e952:	4907      	ldr	r1, [pc, #28]	; (e970 <am_hal_gpio_state_read+0x6c>)
    e954:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
            ui32ReadValue = (ui32ReadValue >> ui32Shift) & 0x01;
    e958:	fa23 f000 	lsr.w	r0, r3, r0
    e95c:	f000 0001 	and.w	r0, r0, #1
    *pui32ReadState = ui32ReadValue;
    e960:	6010      	str	r0, [r2, #0]
    return AM_HAL_STATUS_SUCCESS;
    e962:	2000      	movs	r0, #0
    e964:	4770      	bx	lr
    e966:	bf00      	nop
    e968:	400100a0 	.word	0x400100a0
    e96c:	40010088 	.word	0x40010088
    e970:	40010080 	.word	0x40010080

0000e974 <am_hal_gpio_state_write>:
{
    uint32_t ui32Mask, ui32Off;
    uint32_t ui32Return = AM_HAL_STATUS_SUCCESS;

#ifdef AM_HAL_ENABLE_API_VALIDATION
    if ( ui32Pin >= AM_HAL_GPIO_MAX_PADS )
    e974:	2831      	cmp	r0, #49	; 0x31
    e976:	d819      	bhi.n	e9ac <am_hal_gpio_state_write+0x38>
    {
        return AM_HAL_STATUS_OUT_OF_RANGE;
    }

    if ( eWriteType > AM_HAL_GPIO_OUTPUT_TRISTATE_TOGGLE )
    e978:	2905      	cmp	r1, #5
    e97a:	d815      	bhi.n	e9a8 <am_hal_gpio_state_write+0x34>
{
    e97c:	b570      	push	{r4, r5, r6, lr}
    {
        return AM_HAL_STATUS_INVALID_ARG;
    }
#endif // AM_HAL_ENABLE_API_VALIDATION

    ui32Mask = (uint32_t)0x1 << (ui32Pin % 32);
    e97e:	f000 031f 	and.w	r3, r0, #31
{
    e982:	b082      	sub	sp, #8
    ui32Off  = (ui32Pin & 0x20) >> 3;   // 0 or 4
    e984:	08c0      	lsrs	r0, r0, #3
    ui32Mask = (uint32_t)0x1 << (ui32Pin % 32);
    e986:	2201      	movs	r2, #1
    e988:	460d      	mov	r5, r1
    ui32Off  = (ui32Pin & 0x20) >> 3;   // 0 or 4
    e98a:	f000 0404 	and.w	r4, r0, #4
    ui32Mask = (uint32_t)0x1 << (ui32Pin % 32);
    e98e:	fa02 f603 	lsl.w	r6, r2, r3

    AM_CRITICAL_BEGIN;
    e992:	f003 ffef 	bl	12974 <am_hal_interrupt_master_disable>

    ui32Off /= 4;   // 0 or 1 for ptr arithmetic
    switch ( eWriteType )
    e996:	1e69      	subs	r1, r5, #1
    AM_CRITICAL_BEGIN;
    e998:	9001      	str	r0, [sp, #4]
    switch ( eWriteType )
    e99a:	2904      	cmp	r1, #4
    e99c:	d81b      	bhi.n	e9d6 <am_hal_gpio_state_write+0x62>
    e99e:	e8df f001 	tbb	[pc, r1]
    e9a2:	1217      	.short	0x1217
    e9a4:	070f      	.short	0x070f
    e9a6:	1d          	.byte	0x1d
    e9a7:	00          	.byte	0x00
        return AM_HAL_STATUS_INVALID_ARG;
    e9a8:	2006      	movs	r0, #6
    }

    AM_CRITICAL_END;

    return ui32Return;
} // am_hal_gpio_state_write()
    e9aa:	4770      	bx	lr
        return AM_HAL_STATUS_OUT_OF_RANGE;
    e9ac:	2005      	movs	r0, #5
    e9ae:	4770      	bx	lr
            AM_REGVAL(&GPIO->ENSA + ui32Off) = ui32Mask;
    e9b0:	4b0d      	ldr	r3, [pc, #52]	; (e9e8 <am_hal_gpio_state_write+0x74>)
    e9b2:	50e6      	str	r6, [r4, r3]
    AM_CRITICAL_END;
    e9b4:	9801      	ldr	r0, [sp, #4]
    e9b6:	f003 ffe1 	bl	1297c <am_hal_interrupt_master_set>
    return ui32Return;
    e9ba:	2000      	movs	r0, #0
} // am_hal_gpio_state_write()
    e9bc:	b002      	add	sp, #8
    e9be:	bd70      	pop	{r4, r5, r6, pc}
            AM_REGVAL(&GPIO->ENCA + ui32Off) = ui32Mask;
    e9c0:	4b0a      	ldr	r3, [pc, #40]	; (e9ec <am_hal_gpio_state_write+0x78>)
    e9c2:	50e6      	str	r6, [r4, r3]
            break;
    e9c4:	e7f6      	b.n	e9b4 <am_hal_gpio_state_write+0x40>
            AM_REGVAL(&GPIO->WTA + ui32Off) ^= ui32Mask;
    e9c6:	4a0a      	ldr	r2, [pc, #40]	; (e9f0 <am_hal_gpio_state_write+0x7c>)
    e9c8:	58a3      	ldr	r3, [r4, r2]
    e9ca:	4073      	eors	r3, r6
    e9cc:	50a3      	str	r3, [r4, r2]
            break;
    e9ce:	e7f1      	b.n	e9b4 <am_hal_gpio_state_write+0x40>
            AM_REGVAL(&GPIO->WTSA + ui32Off) = ui32Mask;
    e9d0:	4b08      	ldr	r3, [pc, #32]	; (e9f4 <am_hal_gpio_state_write+0x80>)
    e9d2:	50e6      	str	r6, [r4, r3]
            break;
    e9d4:	e7ee      	b.n	e9b4 <am_hal_gpio_state_write+0x40>
            AM_REGVAL(&GPIO->WTCA + ui32Off) = ui32Mask;
    e9d6:	4b08      	ldr	r3, [pc, #32]	; (e9f8 <am_hal_gpio_state_write+0x84>)
    e9d8:	50e6      	str	r6, [r4, r3]
            break;
    e9da:	e7eb      	b.n	e9b4 <am_hal_gpio_state_write+0x40>
            AM_REGVAL(&GPIO->ENCA + ui32Off) ^= ui32Mask;
    e9dc:	4a03      	ldr	r2, [pc, #12]	; (e9ec <am_hal_gpio_state_write+0x78>)
    e9de:	58a3      	ldr	r3, [r4, r2]
    e9e0:	4073      	eors	r3, r6
    e9e2:	50a3      	str	r3, [r4, r2]
            break;
    e9e4:	e7e6      	b.n	e9b4 <am_hal_gpio_state_write+0x40>
    e9e6:	bf00      	nop
    e9e8:	400100a8 	.word	0x400100a8
    e9ec:	400100b4 	.word	0x400100b4
    e9f0:	40010088 	.word	0x40010088
    e9f4:	40010090 	.word	0x40010090
    e9f8:	40010098 	.word	0x40010098

0000e9fc <am_hal_gpio_interrupt_disable>:
// Disable GPIO interrupts.
//
//*****************************************************************************
uint32_t
am_hal_gpio_interrupt_disable(uint64_t ui64InterruptMask)
{
    e9fc:	b530      	push	{r4, r5, lr}
#ifdef AM_HAL_ENABLE_API_VALIDATION
    //
    // Check parameters
    //
    if ( ui64InterruptMask &  ~(((uint64_t)1 << AM_HAL_GPIO_MAX_PADS) - 1) )
    e9fe:	4b12      	ldr	r3, [pc, #72]	; (ea48 <am_hal_gpio_interrupt_disable+0x4c>)
    ea00:	2200      	movs	r2, #0
    ea02:	ea02 0400 	and.w	r4, r2, r0
    ea06:	ea03 0501 	and.w	r5, r3, r1
    ea0a:	ea54 0305 	orrs.w	r3, r4, r5
{
    ea0e:	b083      	sub	sp, #12
    if ( ui64InterruptMask &  ~(((uint64_t)1 << AM_HAL_GPIO_MAX_PADS) - 1) )
    ea10:	d117      	bne.n	ea42 <am_hal_gpio_interrupt_disable+0x46>
    ea12:	460d      	mov	r5, r1
    ea14:	4604      	mov	r4, r0
#endif // AM_HAL_ENABLE_API_VALIDATION

    //
    // Disable the interrupts.
    //
    AM_CRITICAL_BEGIN
    ea16:	f003 ffad 	bl	12974 <am_hal_interrupt_master_disable>

    GPIO->INT0EN &= ~((uint32_t)(ui64InterruptMask & 0xFFFFFFFF));
    ea1a:	4b0c      	ldr	r3, [pc, #48]	; (ea4c <am_hal_gpio_interrupt_disable+0x50>)
    AM_CRITICAL_BEGIN
    ea1c:	9001      	str	r0, [sp, #4]
    GPIO->INT0EN &= ~((uint32_t)(ui64InterruptMask & 0xFFFFFFFF));
    ea1e:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    ea22:	ea22 0204 	bic.w	r2, r2, r4
    ea26:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
    GPIO->INT1EN &= ~((uint32_t)(ui64InterruptMask >> 32));
    ea2a:	f8d3 2210 	ldr.w	r2, [r3, #528]	; 0x210
    ea2e:	ea22 0205 	bic.w	r2, r2, r5
    ea32:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210

    AM_CRITICAL_END
    ea36:	9801      	ldr	r0, [sp, #4]
    ea38:	f003 ffa0 	bl	1297c <am_hal_interrupt_master_set>

    //
    // Return the status.
    //
    return AM_HAL_STATUS_SUCCESS;
    ea3c:	2000      	movs	r0, #0

} // am_hal_gpio_interrupt_disable()
    ea3e:	b003      	add	sp, #12
    ea40:	bd30      	pop	{r4, r5, pc}
        return AM_HAL_STATUS_OUT_OF_RANGE;
    ea42:	2005      	movs	r0, #5
} // am_hal_gpio_interrupt_disable()
    ea44:	b003      	add	sp, #12
    ea46:	bd30      	pop	{r4, r5, pc}
    ea48:	fffc0000 	.word	0xfffc0000
    ea4c:	40010000 	.word	0x40010000

0000ea50 <am_hal_gpio_interrupt_clear>:
// Clear GPIO interrupts.
//
//*****************************************************************************
uint32_t
am_hal_gpio_interrupt_clear(uint64_t ui64InterruptMask)
{
    ea50:	b530      	push	{r4, r5, lr}
#ifdef AM_HAL_ENABLE_API_VALIDATION
    //
    // Check parameters
    //
    if ( ui64InterruptMask &  ~(((uint64_t)1 << AM_HAL_GPIO_MAX_PADS) - 1) )
    ea52:	4b0e      	ldr	r3, [pc, #56]	; (ea8c <am_hal_gpio_interrupt_clear+0x3c>)
    ea54:	2200      	movs	r2, #0
    ea56:	ea02 0400 	and.w	r4, r2, r0
    ea5a:	ea03 0501 	and.w	r5, r3, r1
    ea5e:	ea54 0305 	orrs.w	r3, r4, r5
{
    ea62:	b083      	sub	sp, #12
    if ( ui64InterruptMask &  ~(((uint64_t)1 << AM_HAL_GPIO_MAX_PADS) - 1) )
    ea64:	d10f      	bne.n	ea86 <am_hal_gpio_interrupt_clear+0x36>
    ea66:	460d      	mov	r5, r1
    ea68:	4604      	mov	r4, r0
#endif // AM_HAL_ENABLE_API_VALIDATION

    //
    // Clear the interrupts.
    //
    AM_CRITICAL_BEGIN
    ea6a:	f003 ff83 	bl	12974 <am_hal_interrupt_master_disable>

    GPIO->INT0CLR = (uint32_t)(ui64InterruptMask & 0xFFFFFFFF);
    ea6e:	4b08      	ldr	r3, [pc, #32]	; (ea90 <am_hal_gpio_interrupt_clear+0x40>)
    AM_CRITICAL_BEGIN
    ea70:	9001      	str	r0, [sp, #4]
    GPIO->INT0CLR = (uint32_t)(ui64InterruptMask & 0xFFFFFFFF);
    ea72:	f8c3 4208 	str.w	r4, [r3, #520]	; 0x208
    GPIO->INT1CLR = (uint32_t)(ui64InterruptMask >> 32);
    ea76:	f8c3 5218 	str.w	r5, [r3, #536]	; 0x218

    AM_CRITICAL_END
    ea7a:	9801      	ldr	r0, [sp, #4]
    ea7c:	f003 ff7e 	bl	1297c <am_hal_interrupt_master_set>

    //
    // Return the status.
    //
    return AM_HAL_STATUS_SUCCESS;
    ea80:	2000      	movs	r0, #0

} // am_hal_gpio_interrupt_clear()
    ea82:	b003      	add	sp, #12
    ea84:	bd30      	pop	{r4, r5, pc}
        return AM_HAL_STATUS_OUT_OF_RANGE;
    ea86:	2005      	movs	r0, #5
} // am_hal_gpio_interrupt_clear()
    ea88:	b003      	add	sp, #12
    ea8a:	bd30      	pop	{r4, r5, pc}
    ea8c:	fffc0000 	.word	0xfffc0000
    ea90:	40010000 	.word	0x40010000

0000ea94 <am_hal_gpio_interrupt_status_get>:
{

    uint64_t ui64RetVal, ui64Mask;

#ifdef AM_HAL_ENABLE_API_VALIDATION
    if ( pui64IntStatus == NULL )
    ea94:	b339      	cbz	r1, eae6 <am_hal_gpio_interrupt_status_get+0x52>
{
    ea96:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    ea9a:	b082      	sub	sp, #8
    ea9c:	460d      	mov	r5, r1
    ea9e:	4680      	mov	r8, r0
    ui64Mask   = 0xFFFFFFFFFFFFFFFF;

    //
    // Combine upper or lower GPIO words into one 64 bit return value.
    //
    AM_CRITICAL_BEGIN
    eaa0:	f003 ff68 	bl	12974 <am_hal_interrupt_master_disable>

    ui64RetVal  = ((uint64_t)GPIO->INT1STAT) << 32;
    eaa4:	4c11      	ldr	r4, [pc, #68]	; (eaec <am_hal_gpio_interrupt_status_get+0x58>)
    AM_CRITICAL_BEGIN
    eaa6:	9001      	str	r0, [sp, #4]
    ui64RetVal  = ((uint64_t)GPIO->INT1STAT) << 32;
    eaa8:	f8d4 0214 	ldr.w	r0, [r4, #532]	; 0x214
    ui64RetVal |= ((uint64_t)GPIO->INT0STAT) << 0;
    eaac:	f8d4 1204 	ldr.w	r1, [r4, #516]	; 0x204
    ui64RetVal  = ((uint64_t)GPIO->INT1STAT) << 32;
    eab0:	f04f 0900 	mov.w	r9, #0
    ui64RetVal |= ((uint64_t)GPIO->INT0STAT) << 0;
    eab4:	ea49 0601 	orr.w	r6, r9, r1
    eab8:	4607      	mov	r7, r0

    if ( bEnabledOnly )
    eaba:	f1b8 0f00 	cmp.w	r8, #0
    eabe:	d009      	beq.n	ead4 <am_hal_gpio_interrupt_status_get+0x40>
    {
        ui64Mask    = ((uint64_t)GPIO->INT1EN) << 32;
    eac0:	f8d4 c210 	ldr.w	ip, [r4, #528]	; 0x210
        ui64Mask   |= ((uint64_t)GPIO->INT0EN) << 0;
    eac4:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
    eac8:	4648      	mov	r0, r9
    eaca:	4661      	mov	r1, ip
    eacc:	ea40 0003 	orr.w	r0, r0, r3
    ead0:	4006      	ands	r6, r0
    ead2:	400f      	ands	r7, r1

    ui64RetVal &= ui64Mask;

    *pui64IntStatus = ui64RetVal;

    AM_CRITICAL_END
    ead4:	9801      	ldr	r0, [sp, #4]
    *pui64IntStatus = ui64RetVal;
    ead6:	e9c5 6700 	strd	r6, r7, [r5]
    AM_CRITICAL_END
    eada:	f003 ff4f 	bl	1297c <am_hal_interrupt_master_set>

    //
    // Return the status.
    //
    return AM_HAL_STATUS_SUCCESS;
    eade:	2000      	movs	r0, #0

} // am_hal_gpio_interrupt_status_get()
    eae0:	b002      	add	sp, #8
    eae2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        return AM_HAL_STATUS_INVALID_ARG;
    eae6:	2006      	movs	r0, #6
} // am_hal_gpio_interrupt_status_get()
    eae8:	4770      	bx	lr
    eaea:	bf00      	nop
    eaec:	40010000 	.word	0x40010000

0000eaf0 <HardFault_Handler>:
HardFault_Handler(void)
#else // AM_CMSIS_REGS
am_fault_isr(void)
#endif // AM_CMSIS_REGS
{
    __asm("    push    {r0,lr}");       // Always pushes to MSP stack
    eaf0:	b501      	push	{r0, lr}
    __asm("    tst     lr, #4");        // Check if we should use MSP or PSP
    eaf2:	f01e 0f04 	tst.w	lr, #4
    __asm("    itet    eq");            // Instrs executed when: eq,ne,eq
    eaf6:	bf0a      	itet	eq
    __asm("    mrseq   r0, msp");       //    bit2=0 indicating MSP stack
    eaf8:	f3ef 8008 	mrseq	r0, MSP
    __asm("    mrsne   r0, psp");       // e: bit2=1 indicating PSP stack
    eafc:	f3ef 8009 	mrsne	r0, PSP
    __asm("    addseq  r0, r0, #8");    // t: bit2=0, adjust for pushes to MSP stack
    eb00:	f110 0008 	addseq.w	r0, r0, #8
    __asm("    bl      am_util_faultisr_collect_data");
    eb04:	f000 f806 	bl	eb14 <am_util_faultisr_collect_data>
    __asm("    pop     {r0,pc}");       // Restore from MSP stack
    eb08:	bd01      	pop	{r0, pc}
    eb0a:	bf00      	nop

0000eb0c <getStackedReg>:
}

uint32_t __attribute__((naked))
getStackedReg(uint32_t regnum, uint32_t u32SP)
{
    __asm("    lsls    r0, r0, #2");
    eb0c:	0080      	lsls	r0, r0, #2
    __asm("    adds    r0, r1");
    eb0e:	1840      	adds	r0, r0, r1
    __asm("    ldr     r0, [r0]");
    eb10:	6800      	ldr	r0, [r0, #0]
    __asm("    bx      lr");
    eb12:	4770      	bx	lr

0000eb14 <am_util_faultisr_collect_data>:
// HardFault_Handler() was called.
//
//*****************************************************************************
void
am_util_faultisr_collect_data(uint32_t u32IsrSP)
{
    eb14:	b500      	push	{lr}
    volatile am_fault_t sFaultData;
    am_hal_mcuctrl_fault_t sHalFaultData = {0};
    eb16:	2300      	movs	r3, #0
{
    eb18:	b093      	sub	sp, #76	; 0x4c
    am_hal_mcuctrl_fault_t sHalFaultData = {0};
    eb1a:	e9cd 3300 	strd	r3, r3, [sp]
    eb1e:	e9cd 3302 	strd	r3, r3, [sp, #8]
    eb22:	e9cd 3304 	strd	r3, r3, [sp, #16]
    // a breakpoint at the end of the routine.  If the printing is not used,
    // we'll get a compiler warning; so to avoid that warning, we'll use it
    // in a dummy assignment here.
    //
    sFaultData.u32CFSR = u32Mask;       // Avoid compiler warning
    sFaultData.u32CFSR = AM_REGVAL(AM_REG_SYSCTRL_CFSR_O);
    eb26:	4a27      	ldr	r2, [pc, #156]	; (ebc4 <am_util_faultisr_collect_data+0xb0>)
    sFaultData.u32CFSR = u32Mask;       // Avoid compiler warning
    eb28:	9310      	str	r3, [sp, #64]	; 0x40
    sFaultData.u32CFSR = AM_REGVAL(AM_REG_SYSCTRL_CFSR_O);
    eb2a:	6813      	ldr	r3, [r2, #0]
    eb2c:	9310      	str	r3, [sp, #64]	; 0x40
    sFaultData.u8MMSR  = (sFaultData.u32CFSR >> 0)  & 0xff;
    eb2e:	9b10      	ldr	r3, [sp, #64]	; 0x40
    eb30:	b2db      	uxtb	r3, r3
    eb32:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
    sFaultData.u8BFSR  = (sFaultData.u32CFSR >> 8)  & 0xff;
    eb36:	9b10      	ldr	r3, [sp, #64]	; 0x40
    eb38:	f3c3 2307 	ubfx	r3, r3, #8, #8
    eb3c:	f88d 3045 	strb.w	r3, [sp, #69]	; 0x45
    sFaultData.u16UFSR = (sFaultData.u32CFSR >> 16) & 0xffff;
    eb40:	9b10      	ldr	r3, [sp, #64]	; 0x40
    eb42:	0c1b      	lsrs	r3, r3, #16
    eb44:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46

    //
    // The address of the location that caused the fault.  e.g. if accessing an
    // invalid data location caused the fault, that address will appear here.
    //
    sFaultData.u32BFAR = AM_REGVAL(AM_REG_SYSCTRL_BFAR_O);
    eb48:	6913      	ldr	r3, [r2, #16]
    eb4a:	930f      	str	r3, [sp, #60]	; 0x3c

    //
    // The address of the instruction that caused the fault is the stacked PC
    // if BFSR bit1 is set.
    //
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    eb4c:	f89d 2045 	ldrb.w	r2, [sp, #69]	; 0x45
    eb50:	0792      	lsls	r2, r2, #30
{
    eb52:	4603      	mov	r3, r0
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    eb54:	d430      	bmi.n	ebb8 <am_util_faultisr_collect_data+0xa4>
    eb56:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff

    //
    // Get the stacked registers.
    // Note - the address of the instruction that caused the fault is u32PC.
    //
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    eb5a:	4619      	mov	r1, r3
    eb5c:	2000      	movs	r0, #0
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    eb5e:	920e      	str	r2, [sp, #56]	; 0x38
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    eb60:	f7ff ffd4 	bl	eb0c <getStackedReg>
    eb64:	4602      	mov	r2, r0
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    eb66:	2001      	movs	r0, #1
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    eb68:	9206      	str	r2, [sp, #24]
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    eb6a:	f7ff ffcf 	bl	eb0c <getStackedReg>
    eb6e:	4602      	mov	r2, r0
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    eb70:	2002      	movs	r0, #2
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    eb72:	9207      	str	r2, [sp, #28]
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    eb74:	f7ff ffca 	bl	eb0c <getStackedReg>
    eb78:	4602      	mov	r2, r0
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    eb7a:	2003      	movs	r0, #3
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    eb7c:	9208      	str	r2, [sp, #32]
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    eb7e:	f7ff ffc5 	bl	eb0c <getStackedReg>
    eb82:	4602      	mov	r2, r0
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    eb84:	2004      	movs	r0, #4
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    eb86:	9209      	str	r2, [sp, #36]	; 0x24
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    eb88:	f7ff ffc0 	bl	eb0c <getStackedReg>
    eb8c:	4602      	mov	r2, r0
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    eb8e:	2005      	movs	r0, #5
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    eb90:	920a      	str	r2, [sp, #40]	; 0x28
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    eb92:	f7ff ffbb 	bl	eb0c <getStackedReg>
    eb96:	4602      	mov	r2, r0
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    eb98:	2006      	movs	r0, #6
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    eb9a:	920b      	str	r2, [sp, #44]	; 0x2c
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    eb9c:	f7ff ffb6 	bl	eb0c <getStackedReg>
    eba0:	4602      	mov	r2, r0
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    eba2:	2007      	movs	r0, #7
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    eba4:	920c      	str	r2, [sp, #48]	; 0x30
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    eba6:	f7ff ffb1 	bl	eb0c <getStackedReg>

    //
    // Use the HAL MCUCTRL functions to read the fault data.
    //
#if AM_APOLLO3_MCUCTRL
    am_hal_mcuctrl_info_get(AM_HAL_MCUCTRL_INFO_FAULT_STATUS, &sHalFaultData);
    ebaa:	4669      	mov	r1, sp
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    ebac:	4603      	mov	r3, r0
    am_hal_mcuctrl_info_get(AM_HAL_MCUCTRL_INFO_FAULT_STATUS, &sHalFaultData);
    ebae:	2002      	movs	r0, #2
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    ebb0:	930d      	str	r3, [sp, #52]	; 0x34
    am_hal_mcuctrl_info_get(AM_HAL_MCUCTRL_INFO_FAULT_STATUS, &sHalFaultData);
    ebb2:	f003 ff3d 	bl	12a30 <am_hal_mcuctrl_info_get>
    ebb6:	e7fe      	b.n	ebb6 <am_util_faultisr_collect_data+0xa2>
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    ebb8:	4601      	mov	r1, r0
    ebba:	2006      	movs	r0, #6
    ebbc:	f7ff ffa6 	bl	eb0c <getStackedReg>
    ebc0:	4602      	mov	r2, r0
    ebc2:	e7ca      	b.n	eb5a <am_util_faultisr_collect_data+0x46>
    ebc4:	e000ed28 	.word	0xe000ed28

0000ebc8 <uint64_to_str>:
// written).
//
//*****************************************************************************
static int
uint64_to_str(uint64_t ui64Val, char *pcBuf)
{
    ebc8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ebcc:	b097      	sub	sp, #92	; 0x5c
    ebce:	4682      	mov	sl, r0
    ebd0:	468b      	mov	fp, r1
    char tbuf[25];
    int ix = 0, iNumDig = 0;
    ebd2:	2300      	movs	r3, #0
{
    ebd4:	920d      	str	r2, [sp, #52]	; 0x34
    ebd6:	469c      	mov	ip, r3
    ebd8:	e9cd ab00 	strd	sl, fp, [sp]
    ebdc:	4606      	mov	r6, r0
    ebde:	460f      	mov	r7, r1
    ebe0:	e00b      	b.n	ebfa <uint64_to_str+0x32>
        //
        // Get modulus
        //
        uMod = ui64Val - (u64Tmp * 10);

        tbuf[ix++] = uMod + '0';
    ebe2:	f80b 2c01 	strb.w	r2, [fp, #-1]
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    ebe6:	4619      	mov	r1, r3
    ebe8:	2200      	movs	r2, #0
    ebea:	e9cd 1200 	strd	r1, r2, [sp]
        ui64Val = u64Tmp;
    } while ( ui64Val );
    ebee:	2b00      	cmp	r3, #0
    ebf0:	f000 80a5 	beq.w	ed3e <uint64_to_str+0x176>
    ebf4:	e9dd 6700 	ldrd	r6, r7, [sp]
{
    ebf8:	46f4      	mov	ip, lr
        q64 += (q64 >> 4);
    ebfa:	2300      	movs	r3, #0
    ebfc:	2400      	movs	r4, #0
    ebfe:	e9cd 3402 	strd	r3, r4, [sp, #8]
        q64 += (q64 >> 8);
    ec02:	e9cd 3404 	strd	r3, r4, [sp, #16]
        q64 += (q64 >> 16);
    ec06:	e9cd 3406 	strd	r3, r4, [sp, #24]
        q64 += (q64 >> 32);
    ec0a:	e9cd 340a 	strd	r3, r4, [sp, #40]	; 0x28
        q64 >>= 3;
    ec0e:	4698      	mov	r8, r3
        q32 = (ui32Val>>1) + (ui32Val>>2);
    ec10:	08b3      	lsrs	r3, r6, #2
    ec12:	eb03 0356 	add.w	r3, r3, r6, lsr #1
        q32 += (q32 >> 4);
    ec16:	eb03 1313 	add.w	r3, r3, r3, lsr #4
        q32 += (q32 >> 8);
    ec1a:	eb03 2313 	add.w	r3, r3, r3, lsr #8
        q64 >>= 3;
    ec1e:	46a1      	mov	r9, r4
        q32 += (q32 >> 16);
    ec20:	eb03 4313 	add.w	r3, r3, r3, lsr #16
        q32 >>= 3;
    ec24:	08da      	lsrs	r2, r3, #3
        return q64 + ((r64 + 6) >> 4);
    ec26:	4644      	mov	r4, r8
    ec28:	464d      	mov	r5, r9
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    ec2a:	4633      	mov	r3, r6
        q64 = (ui64Val>>1) + (ui64Val>>2);
    ec2c:	08b0      	lsrs	r0, r6, #2
        return q64 + ((r64 + 6) >> 4);
    ec2e:	e9cd 4508 	strd	r4, r5, [sp, #32]
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    ec32:	3306      	adds	r3, #6
        r32 = ui32Val - q32*10;
    ec34:	eb02 0482 	add.w	r4, r2, r2, lsl #2
    ec38:	f10c 0e01 	add.w	lr, ip, #1
        tbuf[ix++] = uMod + '0';
    ec3c:	ae0f      	add	r6, sp, #60	; 0x3c
    ec3e:	4476      	add	r6, lr
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    ec40:	eba3 0344 	sub.w	r3, r3, r4, lsl #1
        q64 = (ui64Val>>1) + (ui64Val>>2);
    ec44:	ea40 7087 	orr.w	r0, r0, r7, lsl #30
    if ( ui64Val >> 32 )
    ec48:	463c      	mov	r4, r7
        q64 = (ui64Val>>1) + (ui64Val>>2);
    ec4a:	08b9      	lsrs	r1, r7, #2
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    ec4c:	eb02 1313 	add.w	r3, r2, r3, lsr #4
        tbuf[ix++] = uMod + '0';
    ec50:	46b3      	mov	fp, r6
    ec52:	4637      	mov	r7, r6
    ec54:	9e00      	ldr	r6, [sp, #0]
        uMod = ui64Val - (u64Tmp * 10);
    ec56:	eb03 0283 	add.w	r2, r3, r3, lsl #2
    if ( ui64Val >> 32 )
    ec5a:	2500      	movs	r5, #0
        uMod = ui64Val - (u64Tmp * 10);
    ec5c:	eba6 0242 	sub.w	r2, r6, r2, lsl #1
    if ( ui64Val >> 32 )
    ec60:	ea54 0a05 	orrs.w	sl, r4, r5
        tbuf[ix++] = uMod + '0';
    ec64:	f102 0230 	add.w	r2, r2, #48	; 0x30
    if ( ui64Val >> 32 )
    ec68:	d0bb      	beq.n	ebe2 <uint64_to_str+0x1a>
        q64 = (ui64Val>>1) + (ui64Val>>2);
    ec6a:	e9dd 2300 	ldrd	r2, r3, [sp]
    ec6e:	085b      	lsrs	r3, r3, #1
    ec70:	ea4f 0232 	mov.w	r2, r2, rrx
    ec74:	eb12 0a00 	adds.w	sl, r2, r0
    ec78:	eb43 0b01 	adc.w	fp, r3, r1
        q64 += (q64 >> 4);
    ec7c:	ea4f 131a 	mov.w	r3, sl, lsr #4
    ec80:	ea43 730b 	orr.w	r3, r3, fp, lsl #28
    ec84:	9302      	str	r3, [sp, #8]
    ec86:	ea4f 131b 	mov.w	r3, fp, lsr #4
    ec8a:	9303      	str	r3, [sp, #12]
    ec8c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    ec90:	eb12 020a 	adds.w	r2, r2, sl
    ec94:	eb43 030b 	adc.w	r3, r3, fp
        q64 += (q64 >> 8);
    ec98:	0a11      	lsrs	r1, r2, #8
    ec9a:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
    ec9e:	9104      	str	r1, [sp, #16]
    eca0:	0a19      	lsrs	r1, r3, #8
    eca2:	9105      	str	r1, [sp, #20]
    eca4:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    eca8:	1880      	adds	r0, r0, r2
    ecaa:	4159      	adcs	r1, r3
    ecac:	460b      	mov	r3, r1
        q64 += (q64 >> 16);
    ecae:	0c01      	lsrs	r1, r0, #16
    ecb0:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    ecb4:	9106      	str	r1, [sp, #24]
    ecb6:	0c19      	lsrs	r1, r3, #16
    ecb8:	9107      	str	r1, [sp, #28]
        q64 += (q64 >> 8);
    ecba:	4602      	mov	r2, r0
        q64 += (q64 >> 16);
    ecbc:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    ecc0:	1880      	adds	r0, r0, r2
    ecc2:	4159      	adcs	r1, r3
        q64 += (q64 >> 32);
    ecc4:	e9cd 150a 	strd	r1, r5, [sp, #40]	; 0x28
        q64 += (q64 >> 16);
    ecc8:	4602      	mov	r2, r0
    ecca:	460b      	mov	r3, r1
        q64 += (q64 >> 32);
    eccc:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    ecd0:	1880      	adds	r0, r0, r2
    ecd2:	4159      	adcs	r1, r3
        q64 >>= 3;
    ecd4:	ea4f 08d0 	mov.w	r8, r0, lsr #3
    ecd8:	ea48 7841 	orr.w	r8, r8, r1, lsl #29
    ecdc:	ea4f 09d1 	mov.w	r9, r1, lsr #3
        return q64 + ((r64 + 6) >> 4);
    ece0:	e9dd ab00 	ldrd	sl, fp, [sp]
        r64 = ui64Val - q64*10;
    ece4:	ea4f 0189 	mov.w	r1, r9, lsl #2
    ece8:	ea4f 0288 	mov.w	r2, r8, lsl #2
    ecec:	eb12 0008 	adds.w	r0, r2, r8
    ecf0:	ea41 7398 	orr.w	r3, r1, r8, lsr #30
    ecf4:	eb43 0109 	adc.w	r1, r3, r9
        return q64 + ((r64 + 6) >> 4);
    ecf8:	f11a 0a06 	adds.w	sl, sl, #6
    ecfc:	f14b 0b00 	adc.w	fp, fp, #0
        r64 = ui64Val - q64*10;
    ed00:	1802      	adds	r2, r0, r0
    ed02:	eb41 0301 	adc.w	r3, r1, r1
        return q64 + ((r64 + 6) >> 4);
    ed06:	ebba 0002 	subs.w	r0, sl, r2
    ed0a:	eb6b 0103 	sbc.w	r1, fp, r3
    ed0e:	0903      	lsrs	r3, r0, #4
    ed10:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
    ed14:	9308      	str	r3, [sp, #32]
    ed16:	090b      	lsrs	r3, r1, #4
    ed18:	9309      	str	r3, [sp, #36]	; 0x24
    ed1a:	e9dd ab08 	ldrd	sl, fp, [sp, #32]
    ed1e:	eb1a 0a08 	adds.w	sl, sl, r8
    ed22:	eb4b 0b09 	adc.w	fp, fp, r9
    ed26:	4653      	mov	r3, sl
    ed28:	465c      	mov	r4, fp
    ed2a:	e9cd 3400 	strd	r3, r4, [sp]
        uMod = ui64Val - (u64Tmp * 10);
    ed2e:	eb0a 038a 	add.w	r3, sl, sl, lsl #2
    ed32:	eba6 0643 	sub.w	r6, r6, r3, lsl #1
        tbuf[ix++] = uMod + '0';
    ed36:	3630      	adds	r6, #48	; 0x30
    ed38:	f807 6c01 	strb.w	r6, [r7, #-1]
    ed3c:	e75a      	b.n	ebf4 <uint64_to_str+0x2c>
    iNumDig = ix;

    //
    // Now, reverse the buffer when saving to the caller's buffer.
    //
    if ( pcBuf )
    ed3e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    ed40:	4660      	mov	r0, ip
    ed42:	b16a      	cbz	r2, ed60 <uint64_to_str+0x198>
    ed44:	465b      	mov	r3, fp
    ed46:	3a01      	subs	r2, #1
    {
        while ( ix-- )
        {
            *pcBuf++ = tbuf[ix];
    ed48:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
    ed4c:	f802 1f01 	strb.w	r1, [r2, #1]!
        while ( ix-- )
    ed50:	a90f      	add	r1, sp, #60	; 0x3c
    ed52:	4299      	cmp	r1, r3
    ed54:	d1f8      	bne.n	ed48 <uint64_to_str+0x180>
        }

        //
        // Terminate the caller's buffer
        //
        *pcBuf = 0x00;
    ed56:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    ed58:	4403      	add	r3, r0
    ed5a:	461a      	mov	r2, r3
    ed5c:	2300      	movs	r3, #0
    ed5e:	7053      	strb	r3, [r2, #1]
    }

    return iNumDig;
}
    ed60:	4670      	mov	r0, lr
    ed62:	b017      	add	sp, #92	; 0x5c
    ed64:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000ed68 <am_util_stdio_printf_init>:
    g_pfnCharPrint = pfnCharPrint;
    ed68:	4b01      	ldr	r3, [pc, #4]	; (ed70 <am_util_stdio_printf_init+0x8>)
    ed6a:	6018      	str	r0, [r3, #0]
}
    ed6c:	4770      	bx	lr
    ed6e:	bf00      	nop
    ed70:	10013418 	.word	0x10013418

0000ed74 <am_util_stdio_vsprintf>:
//! @return uint32_t representing the number of characters printed.
//
//******************************************************************************
uint32_t
am_util_stdio_vsprintf(char *pcBuf, const char *pcFmt, va_list pArgs)
{
    ed74:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ed78:	b09b      	sub	sp, #108	; 0x6c
    ed7a:	4682      	mov	sl, r0
    ed7c:	4689      	mov	r9, r1
    ed7e:	9201      	str	r2, [sp, #4]
    char *pcStr;
    uint64_t ui64Val;
    int64_t i64Val;
    uint32_t ui32NumChars, ui32CharCnt = 0;
    ed80:	f04f 0b00 	mov.w	fp, #0
    int iWidth, iVal, iPrecision;
    uint8_t ui8CharSpecifier, ui8PadChar;
    bool bLower, bLongLong, bNeg;
    uint32_t ui32strlen = 0;

    while ( *pcFmt != 0x0 )
    ed84:	f899 3000 	ldrb.w	r3, [r9]
    ed88:	b1bb      	cbz	r3, edba <am_util_stdio_vsprintf+0x46>
    {
        iPrecision = 6;             // printf() default precision for %f is 6

        if ( *pcFmt != '%' )
    ed8a:	2b25      	cmp	r3, #37	; 0x25
    ed8c:	f109 0501 	add.w	r5, r9, #1
    ed90:	d01c      	beq.n	edcc <am_util_stdio_vsprintf+0x58>
    ed92:	f10b 0201 	add.w	r2, fp, #1
        {
            //
            // Accumulate the string portion of the format specification.
            //
            if ( pcBuf )
    ed96:	f1ba 0f00 	cmp.w	sl, #0
    ed9a:	f000 8091 	beq.w	eec0 <am_util_stdio_vsprintf+0x14c>
            {
                // If '\n', convert to '\r\n'
                if ( *pcFmt == '\n'  &&  g_bTxtXlate )
    ed9e:	2b0a      	cmp	r3, #10
    eda0:	f10a 0101 	add.w	r1, sl, #1
    eda4:	f000 808f 	beq.w	eec6 <am_util_stdio_vsprintf+0x152>
                {
                    *pcBuf++ = '\r';
                    ++ui32CharCnt;
                }
                *pcBuf++ = *pcFmt;
    eda8:	f88a 3000 	strb.w	r3, [sl]
    edac:	4693      	mov	fp, r2
    edae:	468a      	mov	sl, r1
            }

            ++pcFmt;
    edb0:	46a9      	mov	r9, r5
    while ( *pcFmt != 0x0 )
    edb2:	f899 3000 	ldrb.w	r3, [r9]
    edb6:	2b00      	cmp	r3, #0
    edb8:	d1e7      	bne.n	ed8a <am_util_stdio_vsprintf+0x16>
    } // while ()

    //
    // Terminate the string
    //
    if ( pcBuf )
    edba:	f1ba 0f00 	cmp.w	sl, #0
    edbe:	d001      	beq.n	edc4 <am_util_stdio_vsprintf+0x50>
    {
        *pcBuf = 0x0;
    edc0:	f88a 3000 	strb.w	r3, [sl]
    }

    return (ui32CharCnt);
}
    edc4:	4658      	mov	r0, fp
    edc6:	b01b      	add	sp, #108	; 0x6c
    edc8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ( *pcFmt == '0' )
    edcc:	f899 3001 	ldrb.w	r3, [r9, #1]
    edd0:	2b30      	cmp	r3, #48	; 0x30
    edd2:	bf03      	ittte	eq
    edd4:	f899 3002 	ldrbeq.w	r3, [r9, #2]
            ++pcFmt;
    edd8:	f109 0502 	addeq.w	r5, r9, #2
            ui8PadChar = '0';
    eddc:	f04f 0830 	moveq.w	r8, #48	; 0x30
        ui8PadChar = ' ';
    ede0:	f04f 0820 	movne.w	r8, #32
    if ( *pcStr == '-')
    ede4:	2b2d      	cmp	r3, #45	; 0x2d
    ede6:	d07e      	beq.n	eee6 <am_util_stdio_vsprintf+0x172>
    uint32_t ui32Val = 0, uCnt = 0;
    ede8:	2100      	movs	r1, #0
    bool bNeg = false;
    edea:	460e      	mov	r6, r1
    if ( *pcStr == '-')
    edec:	462a      	mov	r2, r5
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    edee:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    edf2:	2809      	cmp	r0, #9
    edf4:	f04f 0400 	mov.w	r4, #0
    edf8:	d80f      	bhi.n	ee1a <am_util_stdio_vsprintf+0xa6>
        ui32Val *= 10;
    edfa:	eb04 0484 	add.w	r4, r4, r4, lsl #2
        ui32Val += (*pcStr - '0');
    edfe:	eb03 0444 	add.w	r4, r3, r4, lsl #1
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    ee02:	f812 3f01 	ldrb.w	r3, [r2, #1]!
    ee06:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    ee0a:	2809      	cmp	r0, #9
        ui32Val += (*pcStr - '0');
    ee0c:	f1a4 0430 	sub.w	r4, r4, #48	; 0x30
        ++uCnt;
    ee10:	f101 0101 	add.w	r1, r1, #1
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    ee14:	d9f1      	bls.n	edfa <am_util_stdio_vsprintf+0x86>
    ee16:	5c6b      	ldrb	r3, [r5, r1]
    ee18:	186a      	adds	r2, r5, r1
    return bNeg ? -ui32Val : ui32Val;
    ee1a:	b106      	cbz	r6, ee1e <am_util_stdio_vsprintf+0xaa>
    ee1c:	4264      	negs	r4, r4
        if ( ( *pcFmt != 's' )  &&  ( iWidth < 0 ) )
    ee1e:	2b73      	cmp	r3, #115	; 0x73
        iWidth = decstr_to_int(pcFmt, &ui32NumChars);
    ee20:	4621      	mov	r1, r4
    ee22:	f102 0901 	add.w	r9, r2, #1
        if ( ( *pcFmt != 's' )  &&  ( iWidth < 0 ) )
    ee26:	f000 8167 	beq.w	f0f8 <am_util_stdio_vsprintf+0x384>
    ee2a:	ea84 71e4 	eor.w	r1, r4, r4, asr #31
    ee2e:	eba1 71e4 	sub.w	r1, r1, r4, asr #31
        if (*pcFmt == '.')
    ee32:	2b2e      	cmp	r3, #46	; 0x2e
    ee34:	910e      	str	r1, [sp, #56]	; 0x38
    ee36:	f000 813b 	beq.w	f0b0 <am_util_stdio_vsprintf+0x33c>
        iPrecision = 6;             // printf() default precision for %f is 6
    ee3a:	2506      	movs	r5, #6
        if ( *pcFmt == 'l' )
    ee3c:	2b6c      	cmp	r3, #108	; 0x6c
    ee3e:	d157      	bne.n	eef0 <am_util_stdio_vsprintf+0x17c>
            if ( *pcFmt == 'l' )    // "ll" (long long)
    ee40:	7853      	ldrb	r3, [r2, #1]
    ee42:	2b6c      	cmp	r3, #108	; 0x6c
    ee44:	f000 808e 	beq.w	ef64 <am_util_stdio_vsprintf+0x1f0>
        switch ( *pcFmt )
    ee48:	f1a3 0246 	sub.w	r2, r3, #70	; 0x46
    ee4c:	f109 0901 	add.w	r9, r9, #1
    ee50:	2a32      	cmp	r2, #50	; 0x32
    ee52:	f200 8123 	bhi.w	f09c <am_util_stdio_vsprintf+0x328>
    ee56:	e8df f012 	tbh	[pc, r2, lsl #1]
    ee5a:	00c2      	.short	0x00c2
    ee5c:	01210121 	.word	0x01210121
    ee60:	01210121 	.word	0x01210121
    ee64:	01210121 	.word	0x01210121
    ee68:	01210121 	.word	0x01210121
    ee6c:	01210121 	.word	0x01210121
    ee70:	01210121 	.word	0x01210121
    ee74:	01210121 	.word	0x01210121
    ee78:	01210121 	.word	0x01210121
    ee7c:	01990121 	.word	0x01990121
    ee80:	01210121 	.word	0x01210121
    ee84:	01210121 	.word	0x01210121
    ee88:	01210121 	.word	0x01210121
    ee8c:	01210121 	.word	0x01210121
    ee90:	01210121 	.word	0x01210121
    ee94:	01b60113 	.word	0x01b60113
    ee98:	00c20121 	.word	0x00c20121
    ee9c:	01210121 	.word	0x01210121
    eea0:	012101b6 	.word	0x012101b6
    eea4:	01210121 	.word	0x01210121
    eea8:	01210121 	.word	0x01210121
    eeac:	01210121 	.word	0x01210121
    eeb0:	01210121 	.word	0x01210121
    eeb4:	0121014e 	.word	0x0121014e
    eeb8:	01210235 	.word	0x01210235
    eebc:	024e0121 	.word	0x024e0121
    eec0:	4693      	mov	fp, r2
            ++pcFmt;
    eec2:	46a9      	mov	r9, r5
    eec4:	e775      	b.n	edb2 <am_util_stdio_vsprintf+0x3e>
                if ( *pcFmt == '\n'  &&  g_bTxtXlate )
    eec6:	48a6      	ldr	r0, [pc, #664]	; (f160 <am_util_stdio_vsprintf+0x3ec>)
    eec8:	7800      	ldrb	r0, [r0, #0]
    eeca:	2800      	cmp	r0, #0
    eecc:	f43f af6c 	beq.w	eda8 <am_util_stdio_vsprintf+0x34>
                    *pcBuf++ = '\r';
    eed0:	4650      	mov	r0, sl
    eed2:	230d      	movs	r3, #13
    eed4:	f800 3b02 	strb.w	r3, [r0], #2
    eed8:	468a      	mov	sl, r1
    eeda:	f899 3000 	ldrb.w	r3, [r9]
    eede:	f10b 0202 	add.w	r2, fp, #2
    eee2:	4601      	mov	r1, r0
    eee4:	e760      	b.n	eda8 <am_util_stdio_vsprintf+0x34>
        uCnt++;
    eee6:	2101      	movs	r1, #1
        bNeg = true;
    eee8:	460e      	mov	r6, r1
        pcStr++;
    eeea:	186a      	adds	r2, r5, r1
    eeec:	786b      	ldrb	r3, [r5, #1]
    eeee:	e77e      	b.n	edee <am_util_stdio_vsprintf+0x7a>
        switch ( *pcFmt )
    eef0:	f1a3 0246 	sub.w	r2, r3, #70	; 0x46
    eef4:	2a32      	cmp	r2, #50	; 0x32
    eef6:	f200 80d1 	bhi.w	f09c <am_util_stdio_vsprintf+0x328>
    eefa:	e8df f012 	tbh	[pc, r2, lsl #1]
    eefe:	0070      	.short	0x0070
    ef00:	00cf00cf 	.word	0x00cf00cf
    ef04:	00cf00cf 	.word	0x00cf00cf
    ef08:	00cf00cf 	.word	0x00cf00cf
    ef0c:	00cf00cf 	.word	0x00cf00cf
    ef10:	00cf00cf 	.word	0x00cf00cf
    ef14:	00cf00cf 	.word	0x00cf00cf
    ef18:	00cf00cf 	.word	0x00cf00cf
    ef1c:	00cf00cf 	.word	0x00cf00cf
    ef20:	014700cf 	.word	0x014700cf
    ef24:	00cf00cf 	.word	0x00cf00cf
    ef28:	00cf00cf 	.word	0x00cf00cf
    ef2c:	00cf00cf 	.word	0x00cf00cf
    ef30:	00cf00cf 	.word	0x00cf00cf
    ef34:	00cf00cf 	.word	0x00cf00cf
    ef38:	016400c1 	.word	0x016400c1
    ef3c:	007000cf 	.word	0x007000cf
    ef40:	00cf00cf 	.word	0x00cf00cf
    ef44:	00cf0164 	.word	0x00cf0164
    ef48:	00cf00cf 	.word	0x00cf00cf
    ef4c:	00cf00cf 	.word	0x00cf00cf
    ef50:	00cf00cf 	.word	0x00cf00cf
    ef54:	00cf00cf 	.word	0x00cf00cf
    ef58:	00cf00fc 	.word	0x00cf00fc
    ef5c:	00cf01e3 	.word	0x00cf01e3
    ef60:	01fa00cf 	.word	0x01fa00cf
    ef64:	7893      	ldrb	r3, [r2, #2]
    ef66:	f1a3 0146 	sub.w	r1, r3, #70	; 0x46
    ef6a:	f102 0903 	add.w	r9, r2, #3
    ef6e:	2932      	cmp	r1, #50	; 0x32
    ef70:	f200 8094 	bhi.w	f09c <am_util_stdio_vsprintf+0x328>
    ef74:	e8df f011 	tbh	[pc, r1, lsl #1]
    ef78:	00920033 	.word	0x00920033
    ef7c:	00920092 	.word	0x00920092
    ef80:	00920092 	.word	0x00920092
    ef84:	00920092 	.word	0x00920092
    ef88:	00920092 	.word	0x00920092
    ef8c:	00920092 	.word	0x00920092
    ef90:	00920092 	.word	0x00920092
    ef94:	00920092 	.word	0x00920092
    ef98:	00920092 	.word	0x00920092
    ef9c:	00920414 	.word	0x00920414
    efa0:	00920092 	.word	0x00920092
    efa4:	00920092 	.word	0x00920092
    efa8:	00920092 	.word	0x00920092
    efac:	00920092 	.word	0x00920092
    efb0:	00840092 	.word	0x00840092
    efb4:	00920222 	.word	0x00920222
    efb8:	00920033 	.word	0x00920033
    efbc:	02220092 	.word	0x02220092
    efc0:	00920092 	.word	0x00920092
    efc4:	00920092 	.word	0x00920092
    efc8:	00920092 	.word	0x00920092
    efcc:	00920092 	.word	0x00920092
    efd0:	00bf0092 	.word	0x00bf0092
    efd4:	02160092 	.word	0x02160092
    efd8:	00920092 	.word	0x00920092
    efdc:	0412      	.short	0x0412
                if ( pcBuf )
    efde:	f1ba 0f00 	cmp.w	sl, #0
    efe2:	f43f aecf 	beq.w	ed84 <am_util_stdio_vsprintf+0x10>
                    float fValue = va_arg(pArgs, double);
    efe6:	9b01      	ldr	r3, [sp, #4]
    efe8:	3307      	adds	r3, #7
    efea:	f023 0307 	bic.w	r3, r3, #7
    efee:	e9d3 0100 	ldrd	r0, r1, [r3]
    eff2:	3308      	adds	r3, #8
    eff4:	9301      	str	r3, [sp, #4]
    eff6:	f7fd f91d 	bl	c234 <__aeabi_d2f>
    effa:	ee07 0a90 	vmov	s15, r0
    if (fValue == 0.0f)
    effe:	eef5 7a40 	vcmp.f32	s15, #0.0
                    *(uint32_t*)pcBuf = 20;
    f002:	2314      	movs	r3, #20
    if (fValue == 0.0f)
    f004:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                    *(uint32_t*)pcBuf = 20;
    f008:	f8ca 3000 	str.w	r3, [sl]
    if (fValue == 0.0f)
    f00c:	f000 843e 	beq.w	f88c <am_util_stdio_vsprintf+0xb18>
    iExp2 = ((unFloatValue.I32 >> 23) & 0x000000FF) - 127;
    f010:	f3c0 51c7 	ubfx	r1, r0, #23, #8
    f014:	f1a1 027f 	sub.w	r2, r1, #127	; 0x7f
    f018:	4603      	mov	r3, r0
    if (iExp2 >= 31)
    f01a:	2a1e      	cmp	r2, #30
    i32Significand = (unFloatValue.I32 & 0x00FFFFFF) | 0x00800000;
    f01c:	f3c0 0016 	ubfx	r0, r0, #0, #23
    f020:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    if (iExp2 >= 31)
    f024:	f300 844a 	bgt.w	f8bc <am_util_stdio_vsprintf+0xb48>
    else if (iExp2 < -23)
    f028:	f112 0f17 	cmn.w	r2, #23
    f02c:	f2c0 8479 	blt.w	f922 <am_util_stdio_vsprintf+0xbae>
    else if (iExp2 >= 23)
    f030:	2a16      	cmp	r2, #22
    f032:	f10a 0701 	add.w	r7, sl, #1
    f036:	f340 836f 	ble.w	f718 <am_util_stdio_vsprintf+0x9a4>
        i32IntPart = i32Significand << (iExp2 - 23);
    f03a:	3996      	subs	r1, #150	; 0x96
    if (unFloatValue.I32 < 0)
    f03c:	2b00      	cmp	r3, #0
        i32IntPart = i32Significand << (iExp2 - 23);
    f03e:	fa00 f001 	lsl.w	r0, r0, r1
    if (unFloatValue.I32 < 0)
    f042:	f2c0 844d 	blt.w	f8e0 <am_util_stdio_vsprintf+0xb6c>
    f046:	4656      	mov	r6, sl
    i32FracPart = 0;
    f048:	2400      	movs	r4, #0
    if (i32IntPart == 0)
    f04a:	2800      	cmp	r0, #0
    f04c:	f040 843c 	bne.w	f8c8 <am_util_stdio_vsprintf+0xb54>
    f050:	1c7a      	adds	r2, r7, #1
        *pcBuf++ = '0';
    f052:	f04f 0330 	mov.w	r3, #48	; 0x30
    f056:	7033      	strb	r3, [r6, #0]
    *pcBuf++ = '.';
    f058:	232e      	movs	r3, #46	; 0x2e
    f05a:	703b      	strb	r3, [r7, #0]
    if (i32FracPart == 0)
    f05c:	2c00      	cmp	r4, #0
    f05e:	f040 83d8 	bne.w	f812 <am_util_stdio_vsprintf+0xa9e>
        *pcBuf++ = '0';
    f062:	1cba      	adds	r2, r7, #2
    f064:	f04f 0330 	mov.w	r3, #48	; 0x30
    f068:	707b      	strb	r3, [r7, #1]
    f06a:	eba2 010a 	sub.w	r1, r2, sl
    *pcBuf = 0x00;
    f06e:	2300      	movs	r3, #0
                    if ( iVal < 0 )
    f070:	4299      	cmp	r1, r3
    *pcBuf = 0x00;
    f072:	7013      	strb	r3, [r2, #0]
                    if ( iVal < 0 )
    f074:	f2c0 841e 	blt.w	f8b4 <am_util_stdio_vsprintf+0xb40>
    f078:	460b      	mov	r3, r1
                    ui32CharCnt += iVal;
    f07a:	449b      	add	fp, r3
                    pcBuf += iVal;
    f07c:	449a      	add	sl, r3
    f07e:	e681      	b.n	ed84 <am_util_stdio_vsprintf+0x10>
                ui8CharSpecifier = va_arg(pArgs, uint32_t);
    f080:	9a01      	ldr	r2, [sp, #4]
    f082:	1d13      	adds	r3, r2, #4
                if ( pcBuf )
    f084:	f1ba 0f00 	cmp.w	sl, #0
    f088:	d004      	beq.n	f094 <am_util_stdio_vsprintf+0x320>
                ui8CharSpecifier = va_arg(pArgs, uint32_t);
    f08a:	6812      	ldr	r2, [r2, #0]
    f08c:	f88a 2000 	strb.w	r2, [sl]
                    *pcBuf++ = ui8CharSpecifier;
    f090:	f10a 0a01 	add.w	sl, sl, #1
                ++ui32CharCnt;
    f094:	f10b 0b01 	add.w	fp, fp, #1
                ui8CharSpecifier = va_arg(pArgs, uint32_t);
    f098:	9301      	str	r3, [sp, #4]
                break;
    f09a:	e673      	b.n	ed84 <am_util_stdio_vsprintf+0x10>
                if ( pcBuf )
    f09c:	f1ba 0f00 	cmp.w	sl, #0
    f0a0:	d003      	beq.n	f0aa <am_util_stdio_vsprintf+0x336>
                    *pcBuf++ = *pcFmt;
    f0a2:	f88a 3000 	strb.w	r3, [sl]
    f0a6:	f10a 0a01 	add.w	sl, sl, #1
                ++ui32CharCnt;
    f0aa:	f10b 0b01 	add.w	fp, fp, #1
                break;
    f0ae:	e669      	b.n	ed84 <am_util_stdio_vsprintf+0x10>
    if ( *pcStr == '-')
    f0b0:	7851      	ldrb	r1, [r2, #1]
    f0b2:	292d      	cmp	r1, #45	; 0x2d
    f0b4:	f000 821a 	beq.w	f4ec <am_util_stdio_vsprintf+0x778>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    f0b8:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
    f0bc:	2b09      	cmp	r3, #9
    f0be:	f200 8305 	bhi.w	f6cc <am_util_stdio_vsprintf+0x958>
    bool bNeg = false;
    f0c2:	2600      	movs	r6, #0
    uint32_t ui32Val = 0, uCnt = 0;
    f0c4:	4632      	mov	r2, r6
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    f0c6:	4648      	mov	r0, r9
        uCnt++;
    f0c8:	2300      	movs	r3, #0
        ui32Val *= 10;
    f0ca:	eb03 0383 	add.w	r3, r3, r3, lsl #2
        ui32Val += (*pcStr - '0');
    f0ce:	eb01 0343 	add.w	r3, r1, r3, lsl #1
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    f0d2:	f810 1f01 	ldrb.w	r1, [r0, #1]!
    f0d6:	f1a1 0530 	sub.w	r5, r1, #48	; 0x30
    f0da:	2d09      	cmp	r5, #9
        ui32Val += (*pcStr - '0');
    f0dc:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
        ++uCnt;
    f0e0:	f102 0201 	add.w	r2, r2, #1
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    f0e4:	d9f1      	bls.n	f0ca <am_util_stdio_vsprintf+0x356>
    return bNeg ? -ui32Val : ui32Val;
    f0e6:	b106      	cbz	r6, f0ea <am_util_stdio_vsprintf+0x376>
    f0e8:	425b      	negs	r3, r3
            pcFmt += ui32NumChars;
    f0ea:	444a      	add	r2, r9
            iPrecision = decstr_to_int(pcFmt, &ui32NumChars);
    f0ec:	461d      	mov	r5, r3
    f0ee:	f102 0901 	add.w	r9, r2, #1
    f0f2:	7813      	ldrb	r3, [r2, #0]
    f0f4:	e6a2      	b.n	ee3c <am_util_stdio_vsprintf+0xc8>
        switch ( *pcFmt )
    f0f6:	990e      	ldr	r1, [sp, #56]	; 0x38
                pcStr = va_arg(pArgs, char *);
    f0f8:	9b01      	ldr	r3, [sp, #4]
    f0fa:	681f      	ldr	r7, [r3, #0]
    f0fc:	1d1a      	adds	r2, r3, #4
    if ( !pcBuf )
    f0fe:	b38f      	cbz	r7, f164 <am_util_stdio_vsprintf+0x3f0>
    while ( *pcBuf++ )
    f100:	7838      	ldrb	r0, [r7, #0]
    f102:	1c7b      	adds	r3, r7, #1
    f104:	461c      	mov	r4, r3
    f106:	2800      	cmp	r0, #0
    f108:	f000 835c 	beq.w	f7c4 <am_util_stdio_vsprintf+0xa50>
    f10c:	1be6      	subs	r6, r4, r7
    f10e:	f814 5b01 	ldrb.w	r5, [r4], #1
    f112:	2d00      	cmp	r5, #0
    f114:	d1fa      	bne.n	f10c <am_util_stdio_vsprintf+0x398>
                if ( iWidth > 0 )
    f116:	2900      	cmp	r1, #0
    f118:	dd02      	ble.n	f120 <am_util_stdio_vsprintf+0x3ac>
                    if ( ui32strlen < iWidth )
    f11a:	428e      	cmp	r6, r1
    f11c:	f0c0 8356 	bcc.w	f7cc <am_util_stdio_vsprintf+0xa58>
    f120:	465c      	mov	r4, fp
    f122:	1be4      	subs	r4, r4, r7
    f124:	4657      	mov	r7, sl
                        *pcBuf++ = *pcStr;
    f126:	4655      	mov	r5, sl
    f128:	eb04 0b03 	add.w	fp, r4, r3
                    if ( pcBuf )
    f12c:	b15f      	cbz	r7, f146 <am_util_stdio_vsprintf+0x3d2>
                        *pcBuf++ = *pcStr;
    f12e:	7028      	strb	r0, [r5, #0]
                while (*pcStr != 0x0)
    f130:	f813 0b01 	ldrb.w	r0, [r3], #1
                        *pcBuf++ = *pcStr;
    f134:	3701      	adds	r7, #1
                while (*pcStr != 0x0)
    f136:	2800      	cmp	r0, #0
    f138:	f000 81c5 	beq.w	f4c6 <am_util_stdio_vsprintf+0x752>
                        *pcBuf++ = *pcStr;
    f13c:	463d      	mov	r5, r7
    f13e:	eb04 0b03 	add.w	fp, r4, r3
                    if ( pcBuf )
    f142:	2f00      	cmp	r7, #0
    f144:	d1f3      	bne.n	f12e <am_util_stdio_vsprintf+0x3ba>
    f146:	46ba      	mov	sl, r7
    f148:	eb04 0b03 	add.w	fp, r4, r3
                while (*pcStr != 0x0)
    f14c:	f813 0b01 	ldrb.w	r0, [r3], #1
    f150:	2800      	cmp	r0, #0
    f152:	d1f9      	bne.n	f148 <am_util_stdio_vsprintf+0x3d4>
                if ( iWidth )
    f154:	2900      	cmp	r1, #0
    f156:	f040 81ba 	bne.w	f4ce <am_util_stdio_vsprintf+0x75a>
                pcStr = va_arg(pArgs, char *);
    f15a:	9201      	str	r2, [sp, #4]
    f15c:	e612      	b.n	ed84 <am_util_stdio_vsprintf+0x10>
    f15e:	bf00      	nop
    f160:	10012d28 	.word	0x10012d28
                if ( iWidth > 0 )
    f164:	2900      	cmp	r1, #0
    f166:	f340 838a 	ble.w	f87e <am_util_stdio_vsprintf+0xb0a>
        return ui32RetVal;
    f16a:	463e      	mov	r6, r7
    if ( i32NumChars <= 0 )
    f16c:	2900      	cmp	r1, #0
    f16e:	f300 8304 	bgt.w	f77a <am_util_stdio_vsprintf+0xa06>
    f172:	465c      	mov	r4, fp
    f174:	2300      	movs	r3, #0
                        pcBuf += pcBuf ? iWidth : 0;
    f176:	f1ba 0f00 	cmp.w	sl, #0
    f17a:	d000      	beq.n	f17e <am_util_stdio_vsprintf+0x40a>
    f17c:	449a      	add	sl, r3
                while (*pcStr != 0x0)
    f17e:	7838      	ldrb	r0, [r7, #0]
    f180:	2800      	cmp	r0, #0
    f182:	f000 83f3 	beq.w	f96c <am_util_stdio_vsprintf+0xbf8>
                        iWidth = 0;
    f186:	2100      	movs	r1, #0
    f188:	1c7b      	adds	r3, r7, #1
    f18a:	e7ca      	b.n	f122 <am_util_stdio_vsprintf+0x3ae>
        bLower = bLongLong = false;
    f18c:	2500      	movs	r5, #0
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    f18e:	9b01      	ldr	r3, [sp, #4]
    f190:	681a      	ldr	r2, [r3, #0]
                                      va_arg(pArgs, uint32_t);
    f192:	3304      	adds	r3, #4
    f194:	9301      	str	r3, [sp, #4]
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    f196:	2300      	movs	r3, #0
                if ( iWidth )
    f198:	2c00      	cmp	r4, #0
    f19a:	f040 80bd 	bne.w	f318 <am_util_stdio_vsprintf+0x5a4>
    if ( ui64Val == 0 )
    f19e:	ea52 0103 	orrs.w	r1, r2, r3
    f1a2:	f040 80dd 	bne.w	f360 <am_util_stdio_vsprintf+0x5ec>
    if (pcBuf)
    f1a6:	f1ba 0f00 	cmp.w	sl, #0
    f1aa:	f000 828d 	beq.w	f6c8 <am_util_stdio_vsprintf+0x954>
            *pcBuf++ = tbuf[ix];
    f1ae:	f10a 0501 	add.w	r5, sl, #1
    f1b2:	f04f 0330 	mov.w	r3, #48	; 0x30
    f1b6:	f88a 3000 	strb.w	r3, [sl]
    f1ba:	2001      	movs	r0, #1
    f1bc:	46aa      	mov	sl, r5
        *pcBuf = 0;
    f1be:	2300      	movs	r3, #0
    f1c0:	702b      	strb	r3, [r5, #0]
                ui32CharCnt += iVal;
    f1c2:	4483      	add	fp, r0
                break;
    f1c4:	e5de      	b.n	ed84 <am_util_stdio_vsprintf+0x10>
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
    f1c6:	9b01      	ldr	r3, [sp, #4]
    f1c8:	6818      	ldr	r0, [r3, #0]
                                     va_arg(pArgs, int32_t);
    f1ca:	3304      	adds	r3, #4
    f1cc:	9301      	str	r3, [sp, #4]
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
    f1ce:	17c1      	asrs	r1, r0, #31
                if ( i64Val < 0 )
    f1d0:	2800      	cmp	r0, #0
    f1d2:	f171 0300 	sbcs.w	r3, r1, #0
    f1d6:	f2c0 8194 	blt.w	f502 <am_util_stdio_vsprintf+0x78e>
                    ui64Val = i64Val;
    f1da:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
                if ( iWidth )
    f1de:	2c00      	cmp	r4, #0
    f1e0:	d065      	beq.n	f2ae <am_util_stdio_vsprintf+0x53a>
    int iNDigits = ui64Val ? 0 : 1;
    f1e2:	4603      	mov	r3, r0
    f1e4:	430b      	orrs	r3, r1
    return ndigits_in_u64((uint64_t) i64Val);
    f1e6:	460c      	mov	r4, r1
    f1e8:	4603      	mov	r3, r0
    int iNDigits = ui64Val ? 0 : 1;
    f1ea:	bf0c      	ite	eq
    f1ec:	f04f 0e01 	moveq.w	lr, #1
    f1f0:	f04f 0e00 	movne.w	lr, #0
    while ( ui64Val )
    f1f4:	4323      	orrs	r3, r4
    f1f6:	f000 8396 	beq.w	f926 <am_util_stdio_vsprintf+0xbb2>
                    bNeg = false;
    f1fa:	2300      	movs	r3, #0
    f1fc:	e9cd 380f 	strd	r3, r8, [sp, #60]	; 0x3c
    f200:	e9cd 0102 	strd	r0, r1, [sp, #8]
    f204:	e9cd ba11 	strd	fp, sl, [sp, #68]	; 0x44
    f208:	f8cd 904c 	str.w	r9, [sp, #76]	; 0x4c
        q64 = (ui64Val>>1) + (ui64Val>>2);
    f20c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
        q64 += (q64 >> 4);
    f210:	2300      	movs	r3, #0
    f212:	2400      	movs	r4, #0
    f214:	e9cd 3408 	strd	r3, r4, [sp, #32]
        q64 += (q64 >> 8);
    f218:	e9cd 3406 	strd	r3, r4, [sp, #24]
        q64 += (q64 >> 16);
    f21c:	e9cd 3404 	strd	r3, r4, [sp, #16]
        q64 += (q64 >> 32);
    f220:	e9cd 340a 	strd	r3, r4, [sp, #40]	; 0x28
        q32 = (ui32Val>>1) + (ui32Val>>2);
    f224:	0843      	lsrs	r3, r0, #1
    f226:	eb03 0390 	add.w	r3, r3, r0, lsr #2
        q32 += (q32 >> 4);
    f22a:	eb03 1313 	add.w	r3, r3, r3, lsr #4
        q32 += (q32 >> 8);
    f22e:	eb03 2313 	add.w	r3, r3, r3, lsr #8
        q32 += (q32 >> 16);
    f232:	eb03 4313 	add.w	r3, r3, r3, lsr #16
        q32 >>= 3;
    f236:	08db      	lsrs	r3, r3, #3
        q32 = (ui32Val>>1) + (ui32Val>>2);
    f238:	4602      	mov	r2, r0
        r32 = ui32Val - q32*10;
    f23a:	eb03 0c83 	add.w	ip, r3, r3, lsl #2
        q64 = (ui64Val>>1) + (ui64Val>>2);
    f23e:	0886      	lsrs	r6, r0, #2
    if ( ui64Val >> 32 )
    f240:	460c      	mov	r4, r1
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    f242:	3206      	adds	r2, #6
    if ( ui64Val >> 32 )
    f244:	2500      	movs	r5, #0
        q64 = (ui64Val>>1) + (ui64Val>>2);
    f246:	ea46 7681 	orr.w	r6, r6, r1, lsl #30
    f24a:	088f      	lsrs	r7, r1, #2
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    f24c:	eba2 024c 	sub.w	r2, r2, ip, lsl #1
    if ( ui64Val >> 32 )
    f250:	ea54 0105 	orrs.w	r1, r4, r5
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    f254:	eb03 1312 	add.w	r3, r3, r2, lsr #4
    if ( ui64Val >> 32 )
    f258:	f040 80ba 	bne.w	f3d0 <am_util_stdio_vsprintf+0x65c>
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    f25c:	4619      	mov	r1, r3
    f25e:	2200      	movs	r2, #0
        ++iNDigits;
    f260:	f10e 0e01 	add.w	lr, lr, #1
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    f264:	e9cd 1202 	strd	r1, r2, [sp, #8]
    while ( ui64Val )
    f268:	2b00      	cmp	r3, #0
    f26a:	d1cf      	bne.n	f20c <am_util_stdio_vsprintf+0x498>
                    iWidth -= ndigits_in_i64(ui64Val);
    f26c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    f26e:	eba3 0e0e 	sub.w	lr, r3, lr
                    if ( bNeg )
    f272:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    f274:	e9dd 8b10 	ldrd	r8, fp, [sp, #64]	; 0x40
    f278:	e9dd a912 	ldrd	sl, r9, [sp, #72]	; 0x48
    f27c:	b13b      	cbz	r3, f28e <am_util_stdio_vsprintf+0x51a>
                        if ( ui8PadChar == '0' )
    f27e:	f1b8 0f30 	cmp.w	r8, #48	; 0x30
                        --iWidth;
    f282:	f10e 3eff 	add.w	lr, lr, #4294967295	; 0xffffffff
                        if ( ui8PadChar == '0' )
    f286:	f000 82a3 	beq.w	f7d0 <am_util_stdio_vsprintf+0xa5c>
    f28a:	2301      	movs	r3, #1
    f28c:	930f      	str	r3, [sp, #60]	; 0x3c
    if ( i32NumChars <= 0 )
    f28e:	f1be 0f00 	cmp.w	lr, #0
    f292:	f300 821e 	bgt.w	f6d2 <am_util_stdio_vsprintf+0x95e>
    f296:	2200      	movs	r2, #0
                    pcBuf += pcBuf ? iWidth : 0;
    f298:	f1ba 0f00 	cmp.w	sl, #0
    f29c:	f000 82fc 	beq.w	f898 <am_util_stdio_vsprintf+0xb24>
                    if ( bNeg  &&  (ui8PadChar == ' ') )
    f2a0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
                    pcBuf += pcBuf ? iWidth : 0;
    f2a2:	4492      	add	sl, r2
                    if ( bNeg  &&  (ui8PadChar == ' ') )
    f2a4:	b11b      	cbz	r3, f2ae <am_util_stdio_vsprintf+0x53a>
    f2a6:	f1b8 0f20 	cmp.w	r8, #32
    f2aa:	f000 8132 	beq.w	f512 <am_util_stdio_vsprintf+0x79e>
                iVal = uint64_to_str(ui64Val, pcBuf);
    f2ae:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
    f2b2:	4652      	mov	r2, sl
    f2b4:	f7ff fc88 	bl	ebc8 <uint64_to_str>
                if ( pcBuf )
    f2b8:	f1ba 0f00 	cmp.w	sl, #0
    f2bc:	d081      	beq.n	f1c2 <am_util_stdio_vsprintf+0x44e>
                    pcBuf += iVal;
    f2be:	4482      	add	sl, r0
                ui32CharCnt += iVal;
    f2c0:	4483      	add	fp, r0
    f2c2:	e55f      	b.n	ed84 <am_util_stdio_vsprintf+0x10>
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    f2c4:	9a01      	ldr	r2, [sp, #4]
    f2c6:	6813      	ldr	r3, [r2, #0]
                                      va_arg(pArgs, uint32_t);
    f2c8:	3204      	adds	r2, #4
    f2ca:	9201      	str	r2, [sp, #4]
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    f2cc:	4619      	mov	r1, r3
    f2ce:	2200      	movs	r2, #0
    f2d0:	e9cd 120c 	strd	r1, r2, [sp, #48]	; 0x30
                if ( iWidth )
    f2d4:	2c00      	cmp	r4, #0
    f2d6:	f040 8127 	bne.w	f528 <am_util_stdio_vsprintf+0x7b4>
                iVal = uint64_to_str(ui64Val, pcBuf);
    f2da:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
    f2de:	4652      	mov	r2, sl
    f2e0:	f7ff fc72 	bl	ebc8 <uint64_to_str>
                if ( pcBuf )
    f2e4:	f1ba 0f00 	cmp.w	sl, #0
    f2e8:	d1e9      	bne.n	f2be <am_util_stdio_vsprintf+0x54a>
    f2ea:	f04f 0a00 	mov.w	sl, #0
                ui32CharCnt += iVal;
    f2ee:	4483      	add	fp, r0
    f2f0:	e548      	b.n	ed84 <am_util_stdio_vsprintf+0x10>
                bLower = true;
    f2f2:	2501      	movs	r5, #1
    f2f4:	e74b      	b.n	f18e <am_util_stdio_vsprintf+0x41a>
        bLower = bLongLong = false;
    f2f6:	2300      	movs	r3, #0
                bLower = true;
    f2f8:	2501      	movs	r5, #1
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    f2fa:	2b00      	cmp	r3, #0
    f2fc:	f43f af47 	beq.w	f18e <am_util_stdio_vsprintf+0x41a>
    f300:	9b01      	ldr	r3, [sp, #4]
    f302:	3307      	adds	r3, #7
    f304:	f023 0307 	bic.w	r3, r3, #7
    f308:	f103 0208 	add.w	r2, r3, #8
    f30c:	9201      	str	r2, [sp, #4]
    f30e:	e9d3 2300 	ldrd	r2, r3, [r3]
                if ( iWidth )
    f312:	2c00      	cmp	r4, #0
    f314:	f43f af43 	beq.w	f19e <am_util_stdio_vsprintf+0x42a>
    int iDigits = ui64Val ? 0 : 1;
    f318:	ea52 0103 	orrs.w	r1, r2, r3
    f31c:	bf0c      	ite	eq
    f31e:	2401      	moveq	r4, #1
    f320:	2400      	movne	r4, #0
    while ( ui64Val )
    f322:	ea52 0103 	orrs.w	r1, r2, r3
    f326:	d00c      	beq.n	f342 <am_util_stdio_vsprintf+0x5ce>
    f328:	4610      	mov	r0, r2
    f32a:	4619      	mov	r1, r3
        ui64Val >>= 4;
    f32c:	0906      	lsrs	r6, r0, #4
    f32e:	ea46 7601 	orr.w	r6, r6, r1, lsl #28
    f332:	090f      	lsrs	r7, r1, #4
    f334:	4630      	mov	r0, r6
    f336:	4639      	mov	r1, r7
    while ( ui64Val )
    f338:	ea50 0601 	orrs.w	r6, r0, r1
        ++iDigits;
    f33c:	f104 0401 	add.w	r4, r4, #1
    while ( ui64Val )
    f340:	d1f4      	bne.n	f32c <am_util_stdio_vsprintf+0x5b8>
                    iWidth -= ndigits_in_hex(ui64Val);
    f342:	990e      	ldr	r1, [sp, #56]	; 0x38
    f344:	1b09      	subs	r1, r1, r4
    if ( i32NumChars <= 0 )
    f346:	2900      	cmp	r1, #0
    f348:	f300 81a1 	bgt.w	f68e <am_util_stdio_vsprintf+0x91a>
    f34c:	2000      	movs	r0, #0
                    pcBuf += pcBuf ? iWidth : 0;
    f34e:	f1ba 0f00 	cmp.w	sl, #0
    f352:	f000 81b5 	beq.w	f6c0 <am_util_stdio_vsprintf+0x94c>
    if ( ui64Val == 0 )
    f356:	ea52 0103 	orrs.w	r1, r2, r3
    f35a:	4482      	add	sl, r0
    f35c:	f43f af23 	beq.w	f1a6 <am_util_stdio_vsprintf+0x432>
    f360:	2d00      	cmp	r5, #0
    f362:	bf14      	ite	ne
    f364:	2527      	movne	r5, #39	; 0x27
    f366:	2507      	moveq	r5, #7
    if ( i32NumChars <= 0 )
    f368:	af15      	add	r7, sp, #84	; 0x54
    int iNumDig, ix = 0;
    f36a:	2600      	movs	r6, #0
    f36c:	f8cd 9008 	str.w	r9, [sp, #8]
        ui64Val >>= 4;
    f370:	0914      	lsrs	r4, r2, #4
        cCh = ui64Val & 0xf;
    f372:	f002 020f 	and.w	r2, r2, #15
        ui64Val >>= 4;
    f376:	ea4f 1813 	mov.w	r8, r3, lsr #4
            cCh += bLower ? 0x27 : 0x7;
    f37a:	18a8      	adds	r0, r5, r2
        if ( cCh > 9 )
    f37c:	2a09      	cmp	r2, #9
        ui64Val >>= 4;
    f37e:	46c6      	mov	lr, r8
    f380:	ea44 7403 	orr.w	r4, r4, r3, lsl #28
        tbuf[ix++] = cCh + '0';
    f384:	f100 0030 	add.w	r0, r0, #48	; 0x30
    f388:	f102 0c30 	add.w	ip, r2, #48	; 0x30
    f38c:	f106 0901 	add.w	r9, r6, #1
        if ( cCh > 9 )
    f390:	d978      	bls.n	f484 <am_util_stdio_vsprintf+0x710>
        ui64Val >>= 4;
    f392:	4622      	mov	r2, r4
    f394:	4643      	mov	r3, r8
    while ( ui64Val )
    f396:	ea52 0103 	orrs.w	r1, r2, r3
        tbuf[ix++] = cCh + '0';
    f39a:	f807 0b01 	strb.w	r0, [r7], #1
    while ( ui64Val )
    f39e:	d07a      	beq.n	f496 <am_util_stdio_vsprintf+0x722>
    if ( i32NumChars <= 0 )
    f3a0:	464e      	mov	r6, r9
    f3a2:	e7e5      	b.n	f370 <am_util_stdio_vsprintf+0x5fc>
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    f3a4:	9b01      	ldr	r3, [sp, #4]
    f3a6:	3307      	adds	r3, #7
    f3a8:	f023 0307 	bic.w	r3, r3, #7
    f3ac:	f103 0208 	add.w	r2, r3, #8
    f3b0:	9201      	str	r2, [sp, #4]
    f3b2:	e9d3 2300 	ldrd	r2, r3, [r3]
    f3b6:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
    f3ba:	e78b      	b.n	f2d4 <am_util_stdio_vsprintf+0x560>
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
    f3bc:	9b01      	ldr	r3, [sp, #4]
    f3be:	3307      	adds	r3, #7
    f3c0:	f023 0307 	bic.w	r3, r3, #7
    f3c4:	f103 0208 	add.w	r2, r3, #8
    f3c8:	9201      	str	r2, [sp, #4]
    f3ca:	e9d3 0100 	ldrd	r0, r1, [r3]
    f3ce:	e6ff      	b.n	f1d0 <am_util_stdio_vsprintf+0x45c>
        q64 = (ui64Val>>1) + (ui64Val>>2);
    f3d0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    f3d4:	085b      	lsrs	r3, r3, #1
    f3d6:	ea4f 0232 	mov.w	r2, r2, rrx
    f3da:	1990      	adds	r0, r2, r6
    f3dc:	eb43 0107 	adc.w	r1, r3, r7
        q64 += (q64 >> 4);
    f3e0:	0903      	lsrs	r3, r0, #4
    f3e2:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
    f3e6:	9308      	str	r3, [sp, #32]
    f3e8:	090b      	lsrs	r3, r1, #4
    f3ea:	9309      	str	r3, [sp, #36]	; 0x24
    f3ec:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
    f3f0:	1812      	adds	r2, r2, r0
    f3f2:	414b      	adcs	r3, r1
        q64 += (q64 >> 8);
    f3f4:	0a11      	lsrs	r1, r2, #8
    f3f6:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
    f3fa:	9106      	str	r1, [sp, #24]
    f3fc:	0a19      	lsrs	r1, r3, #8
    f3fe:	9107      	str	r1, [sp, #28]
    f400:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    f404:	1880      	adds	r0, r0, r2
    f406:	4159      	adcs	r1, r3
    f408:	460b      	mov	r3, r1
        q64 += (q64 >> 16);
    f40a:	0c01      	lsrs	r1, r0, #16
    f40c:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    f410:	9104      	str	r1, [sp, #16]
    f412:	0c19      	lsrs	r1, r3, #16
    f414:	9105      	str	r1, [sp, #20]
        q64 += (q64 >> 8);
    f416:	4602      	mov	r2, r0
        q64 += (q64 >> 16);
    f418:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    f41c:	1880      	adds	r0, r0, r2
    f41e:	4159      	adcs	r1, r3
        q64 += (q64 >> 32);
    f420:	e9cd 150a 	strd	r1, r5, [sp, #40]	; 0x28
        q64 += (q64 >> 16);
    f424:	4602      	mov	r2, r0
    f426:	460b      	mov	r3, r1
        q64 += (q64 >> 32);
    f428:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    f42c:	1880      	adds	r0, r0, r2
    f42e:	4159      	adcs	r1, r3
        q64 >>= 3;
    f430:	ea4f 08d0 	mov.w	r8, r0, lsr #3
    f434:	ea48 7841 	orr.w	r8, r8, r1, lsl #29
    f438:	ea4f 09d1 	mov.w	r9, r1, lsr #3
        return q64 + ((r64 + 6) >> 4);
    f43c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
        r64 = ui64Val - q64*10;
    f440:	ea4f 0489 	mov.w	r4, r9, lsl #2
    f444:	ea4f 0288 	mov.w	r2, r8, lsl #2
    f448:	ea44 7398 	orr.w	r3, r4, r8, lsr #30
    f44c:	eb12 0408 	adds.w	r4, r2, r8
    f450:	eb43 0509 	adc.w	r5, r3, r9
        return q64 + ((r64 + 6) >> 4);
    f454:	3006      	adds	r0, #6
    f456:	f141 0100 	adc.w	r1, r1, #0
        r64 = ui64Val - q64*10;
    f45a:	1922      	adds	r2, r4, r4
    f45c:	eb45 0305 	adc.w	r3, r5, r5
        return q64 + ((r64 + 6) >> 4);
    f460:	1a80      	subs	r0, r0, r2
    f462:	eb61 0103 	sbc.w	r1, r1, r3
    f466:	ea4f 1a10 	mov.w	sl, r0, lsr #4
    f46a:	ea4a 7a01 	orr.w	sl, sl, r1, lsl #28
    f46e:	eb1a 0308 	adds.w	r3, sl, r8
    f472:	ea4f 1b11 	mov.w	fp, r1, lsr #4
    f476:	eb4b 0409 	adc.w	r4, fp, r9
        ++iNDigits;
    f47a:	f10e 0e01 	add.w	lr, lr, #1
        return q64 + ((r64 + 6) >> 4);
    f47e:	e9cd 3402 	strd	r3, r4, [sp, #8]
    f482:	e6c3      	b.n	f20c <am_util_stdio_vsprintf+0x498>
        ui64Val >>= 4;
    f484:	4622      	mov	r2, r4
    f486:	4643      	mov	r3, r8
    while ( ui64Val )
    f488:	ea52 0103 	orrs.w	r1, r2, r3
        tbuf[ix++] = cCh + '0';
    f48c:	f106 0901 	add.w	r9, r6, #1
    f490:	f807 cb01 	strb.w	ip, [r7], #1
    while ( ui64Val )
    f494:	d184      	bne.n	f3a0 <am_util_stdio_vsprintf+0x62c>
    f496:	464d      	mov	r5, r9
    f498:	4628      	mov	r0, r5
    f49a:	f8dd 9008 	ldr.w	r9, [sp, #8]
    if (pcBuf)
    f49e:	f1ba 0f00 	cmp.w	sl, #0
    f4a2:	f43f af22 	beq.w	f2ea <am_util_stdio_vsprintf+0x576>
    f4a6:	ab15      	add	r3, sp, #84	; 0x54
    f4a8:	eb0a 0405 	add.w	r4, sl, r5
    f4ac:	442b      	add	r3, r5
    f4ae:	f10a 32ff 	add.w	r2, sl, #4294967295	; 0xffffffff
            *pcBuf++ = tbuf[ix];
    f4b2:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
    f4b6:	f802 1f01 	strb.w	r1, [r2, #1]!
        while (ix--)
    f4ba:	a915      	add	r1, sp, #84	; 0x54
    f4bc:	4299      	cmp	r1, r3
    f4be:	d1f8      	bne.n	f4b2 <am_util_stdio_vsprintf+0x73e>
    f4c0:	4455      	add	r5, sl
    f4c2:	46a2      	mov	sl, r4
    f4c4:	e67b      	b.n	f1be <am_util_stdio_vsprintf+0x44a>
    f4c6:	46ba      	mov	sl, r7
                if ( iWidth )
    f4c8:	2900      	cmp	r1, #0
    f4ca:	f43f ae46 	beq.w	f15a <am_util_stdio_vsprintf+0x3e6>
                    iWidth = -iWidth;
    f4ce:	4249      	negs	r1, r1
                    if ( ui32strlen < iWidth )
    f4d0:	42b1      	cmp	r1, r6
    f4d2:	f67f ae42 	bls.w	f15a <am_util_stdio_vsprintf+0x3e6>
                        iWidth -= ui32strlen;
    f4d6:	1b89      	subs	r1, r1, r6
    if ( i32NumChars <= 0 )
    f4d8:	2900      	cmp	r1, #0
    f4da:	f300 8163 	bgt.w	f7a4 <am_util_stdio_vsprintf+0xa30>
    f4de:	2100      	movs	r1, #0
                        pcBuf += pcBuf ? iWidth : 0;
    f4e0:	f1ba 0f00 	cmp.w	sl, #0
    f4e4:	f43f ae39 	beq.w	f15a <am_util_stdio_vsprintf+0x3e6>
    f4e8:	448a      	add	sl, r1
    f4ea:	e636      	b.n	f15a <am_util_stdio_vsprintf+0x3e6>
    f4ec:	7891      	ldrb	r1, [r2, #2]
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    f4ee:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
    f4f2:	2b09      	cmp	r3, #9
        pcStr++;
    f4f4:	f102 0002 	add.w	r0, r2, #2
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    f4f8:	f200 8234 	bhi.w	f964 <am_util_stdio_vsprintf+0xbf0>
        bNeg = true;
    f4fc:	2601      	movs	r6, #1
        uCnt++;
    f4fe:	4632      	mov	r2, r6
    f500:	e5e2      	b.n	f0c8 <am_util_stdio_vsprintf+0x354>
                    ui64Val = -i64Val;          // Get absolute value
    f502:	4240      	negs	r0, r0
    f504:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    f508:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
                if ( iWidth )
    f50c:	2c00      	cmp	r4, #0
    f50e:	f040 80fa 	bne.w	f706 <am_util_stdio_vsprintf+0x992>
                        if ( pcBuf )
    f512:	f1ba 0f00 	cmp.w	sl, #0
    f516:	d004      	beq.n	f522 <am_util_stdio_vsprintf+0x7ae>
                            *pcBuf++ = '-';
    f518:	232d      	movs	r3, #45	; 0x2d
    f51a:	f88a 3000 	strb.w	r3, [sl]
    f51e:	f10a 0a01 	add.w	sl, sl, #1
                        ++ui32CharCnt;
    f522:	f10b 0b01 	add.w	fp, fp, #1
    f526:	e6c2      	b.n	f2ae <am_util_stdio_vsprintf+0x53a>
    int iNDigits = ui64Val ? 0 : 1;
    f528:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
    f52c:	4603      	mov	r3, r0
    f52e:	430b      	orrs	r3, r1
    while ( ui64Val )
    f530:	460c      	mov	r4, r1
    f532:	4603      	mov	r3, r0
    int iNDigits = ui64Val ? 0 : 1;
    f534:	bf0c      	ite	eq
    f536:	f04f 0e01 	moveq.w	lr, #1
    f53a:	f04f 0e00 	movne.w	lr, #0
    while ( ui64Val )
    f53e:	4323      	orrs	r3, r4
    f540:	d03c      	beq.n	f5bc <am_util_stdio_vsprintf+0x848>
    f542:	e9cd 0102 	strd	r0, r1, [sp, #8]
    f546:	e9cd ba10 	strd	fp, sl, [sp, #64]	; 0x40
    f54a:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
    f54e:	f8cd 9048 	str.w	r9, [sp, #72]	; 0x48
        q64 = (ui64Val>>1) + (ui64Val>>2);
    f552:	e9dd 5602 	ldrd	r5, r6, [sp, #8]
        q64 += (q64 >> 4);
    f556:	2300      	movs	r3, #0
    f558:	2400      	movs	r4, #0
        q64 = (ui64Val>>1) + (ui64Val>>2);
    f55a:	08a8      	lsrs	r0, r5, #2
        q64 += (q64 >> 4);
    f55c:	e9cd 3408 	strd	r3, r4, [sp, #32]
        q64 += (q64 >> 8);
    f560:	e9cd 3406 	strd	r3, r4, [sp, #24]
        q64 += (q64 >> 16);
    f564:	e9cd 3404 	strd	r3, r4, [sp, #16]
        q64 += (q64 >> 32);
    f568:	e9cd 340a 	strd	r3, r4, [sp, #40]	; 0x28
        q64 = (ui64Val>>1) + (ui64Val>>2);
    f56c:	ea40 7086 	orr.w	r0, r0, r6, lsl #30
        q32 = (ui32Val>>1) + (ui32Val>>2);
    f570:	462c      	mov	r4, r5
        q64 = (ui64Val>>1) + (ui64Val>>2);
    f572:	08b1      	lsrs	r1, r6, #2
        q32 = (ui32Val>>1) + (ui32Val>>2);
    f574:	086e      	lsrs	r6, r5, #1
    f576:	eb06 0694 	add.w	r6, r6, r4, lsr #2
        q32 += (q32 >> 4);
    f57a:	eb06 1616 	add.w	r6, r6, r6, lsr #4
    if ( ui64Val >> 32 )
    f57e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
        q32 += (q32 >> 8);
    f582:	eb06 2616 	add.w	r6, r6, r6, lsr #8
        q32 += (q32 >> 16);
    f586:	eb06 4616 	add.w	r6, r6, r6, lsr #16
        q32 >>= 3;
    f58a:	08f6      	lsrs	r6, r6, #3
        r32 = ui32Val - q32*10;
    f58c:	eb06 0c86 	add.w	ip, r6, r6, lsl #2
    if ( ui64Val >> 32 )
    f590:	461c      	mov	r4, r3
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    f592:	1d97      	adds	r7, r2, #6
    if ( ui64Val >> 32 )
    f594:	2500      	movs	r5, #0
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    f596:	eba7 074c 	sub.w	r7, r7, ip, lsl #1
    if ( ui64Val >> 32 )
    f59a:	ea54 0305 	orrs.w	r3, r4, r5
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    f59e:	eb06 1617 	add.w	r6, r6, r7, lsr #4
    if ( ui64Val >> 32 )
    f5a2:	d118      	bne.n	f5d6 <am_util_stdio_vsprintf+0x862>
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    f5a4:	4633      	mov	r3, r6
    f5a6:	2400      	movs	r4, #0
        ++iNDigits;
    f5a8:	f10e 0e01 	add.w	lr, lr, #1
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    f5ac:	e9cd 3402 	strd	r3, r4, [sp, #8]
    while ( ui64Val )
    f5b0:	2e00      	cmp	r6, #0
    f5b2:	d1ce      	bne.n	f552 <am_util_stdio_vsprintf+0x7de>
    f5b4:	e9dd 8b0f 	ldrd	r8, fp, [sp, #60]	; 0x3c
    f5b8:	e9dd a911 	ldrd	sl, r9, [sp, #68]	; 0x44
                    iWidth -= ndigits_in_u64(ui64Val);
    f5bc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    f5be:	eba3 030e 	sub.w	r3, r3, lr
    if ( i32NumChars <= 0 )
    f5c2:	2b00      	cmp	r3, #0
    f5c4:	f300 80c7 	bgt.w	f756 <am_util_stdio_vsprintf+0x9e2>
    f5c8:	2200      	movs	r2, #0
                    pcBuf += pcBuf ? iWidth : 0;
    f5ca:	f1ba 0f00 	cmp.w	sl, #0
    f5ce:	f000 8190 	beq.w	f8f2 <am_util_stdio_vsprintf+0xb7e>
    f5d2:	4492      	add	sl, r2
    f5d4:	e681      	b.n	f2da <am_util_stdio_vsprintf+0x566>
        q64 = (ui64Val>>1) + (ui64Val>>2);
    f5d6:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
    f5da:	087f      	lsrs	r7, r7, #1
    f5dc:	ea4f 0636 	mov.w	r6, r6, rrx
    f5e0:	1982      	adds	r2, r0, r6
    f5e2:	eb41 0307 	adc.w	r3, r1, r7
        q64 += (q64 >> 4);
    f5e6:	0911      	lsrs	r1, r2, #4
    f5e8:	ea41 7103 	orr.w	r1, r1, r3, lsl #28
    f5ec:	9108      	str	r1, [sp, #32]
    f5ee:	0919      	lsrs	r1, r3, #4
    f5f0:	9109      	str	r1, [sp, #36]	; 0x24
    f5f2:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
    f5f6:	1880      	adds	r0, r0, r2
    f5f8:	4159      	adcs	r1, r3
    f5fa:	460b      	mov	r3, r1
        q64 += (q64 >> 8);
    f5fc:	0a01      	lsrs	r1, r0, #8
    f5fe:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
    f602:	9106      	str	r1, [sp, #24]
    f604:	0a19      	lsrs	r1, r3, #8
    f606:	9107      	str	r1, [sp, #28]
        q64 += (q64 >> 4);
    f608:	4602      	mov	r2, r0
        q64 += (q64 >> 8);
    f60a:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    f60e:	1880      	adds	r0, r0, r2
    f610:	4159      	adcs	r1, r3
    f612:	460b      	mov	r3, r1
        q64 += (q64 >> 16);
    f614:	0c01      	lsrs	r1, r0, #16
    f616:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    f61a:	9104      	str	r1, [sp, #16]
    f61c:	0c19      	lsrs	r1, r3, #16
    f61e:	9105      	str	r1, [sp, #20]
        q64 += (q64 >> 8);
    f620:	4602      	mov	r2, r0
        q64 += (q64 >> 16);
    f622:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    f626:	1880      	adds	r0, r0, r2
    f628:	4159      	adcs	r1, r3
        q64 += (q64 >> 32);
    f62a:	e9cd 150a 	strd	r1, r5, [sp, #40]	; 0x28
        q64 += (q64 >> 16);
    f62e:	4602      	mov	r2, r0
    f630:	460b      	mov	r3, r1
        q64 += (q64 >> 32);
    f632:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    f636:	1880      	adds	r0, r0, r2
    f638:	4159      	adcs	r1, r3
        q64 >>= 3;
    f63a:	ea4f 08d0 	mov.w	r8, r0, lsr #3
    f63e:	ea48 7841 	orr.w	r8, r8, r1, lsl #29
    f642:	ea4f 09d1 	mov.w	r9, r1, lsr #3
        return q64 + ((r64 + 6) >> 4);
    f646:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
        r64 = ui64Val - q64*10;
    f64a:	ea4f 0489 	mov.w	r4, r9, lsl #2
    f64e:	ea4f 0288 	mov.w	r2, r8, lsl #2
    f652:	ea44 7398 	orr.w	r3, r4, r8, lsr #30
    f656:	eb12 0408 	adds.w	r4, r2, r8
    f65a:	eb43 0509 	adc.w	r5, r3, r9
        return q64 + ((r64 + 6) >> 4);
    f65e:	3006      	adds	r0, #6
    f660:	f141 0100 	adc.w	r1, r1, #0
        r64 = ui64Val - q64*10;
    f664:	1922      	adds	r2, r4, r4
    f666:	eb45 0305 	adc.w	r3, r5, r5
        return q64 + ((r64 + 6) >> 4);
    f66a:	1a80      	subs	r0, r0, r2
    f66c:	eb61 0103 	sbc.w	r1, r1, r3
    f670:	ea4f 1a10 	mov.w	sl, r0, lsr #4
    f674:	ea4a 7a01 	orr.w	sl, sl, r1, lsl #28
    f678:	eb1a 0308 	adds.w	r3, sl, r8
    f67c:	ea4f 1b11 	mov.w	fp, r1, lsr #4
    f680:	eb4b 0409 	adc.w	r4, fp, r9
        ++iNDigits;
    f684:	f10e 0e01 	add.w	lr, lr, #1
        return q64 + ((r64 + 6) >> 4);
    f688:	e9cd 3402 	strd	r3, r4, [sp, #8]
    f68c:	e761      	b.n	f552 <am_util_stdio_vsprintf+0x7de>
    while ( i32NumChars-- )
    f68e:	3901      	subs	r1, #1
    f690:	4656      	mov	r6, sl
    int32_t i32Cnt = 0;
    f692:	2000      	movs	r0, #0
    f694:	1e4f      	subs	r7, r1, #1
    f696:	1c44      	adds	r4, r0, #1
        if ( pcBuf )
    f698:	b156      	cbz	r6, f6b0 <am_util_stdio_vsprintf+0x93c>
            *pcBuf++ = cPadChar;
    f69a:	46bc      	mov	ip, r7
    f69c:	460f      	mov	r7, r1
    f69e:	f886 8000 	strb.w	r8, [r6]
    f6a2:	4620      	mov	r0, r4
    f6a4:	4661      	mov	r1, ip
    f6a6:	3601      	adds	r6, #1
    while ( i32NumChars-- )
    f6a8:	2f00      	cmp	r7, #0
    f6aa:	d1f3      	bne.n	f694 <am_util_stdio_vsprintf+0x920>
    f6ac:	4483      	add	fp, r0
    f6ae:	e64e      	b.n	f34e <am_util_stdio_vsprintf+0x5da>
    f6b0:	2900      	cmp	r1, #0
    f6b2:	f000 8126 	beq.w	f902 <am_util_stdio_vsprintf+0xb8e>
    f6b6:	3902      	subs	r1, #2
    f6b8:	3002      	adds	r0, #2
    f6ba:	2f00      	cmp	r7, #0
    f6bc:	d1ea      	bne.n	f694 <am_util_stdio_vsprintf+0x920>
    f6be:	e7f5      	b.n	f6ac <am_util_stdio_vsprintf+0x938>
    if ( ui64Val == 0 )
    f6c0:	ea52 0103 	orrs.w	r1, r2, r3
    f6c4:	f47f ae4c 	bne.w	f360 <am_util_stdio_vsprintf+0x5ec>
    f6c8:	2001      	movs	r0, #1
    f6ca:	e60e      	b.n	f2ea <am_util_stdio_vsprintf+0x576>
    uint32_t ui32Val = 0, uCnt = 0;
    f6cc:	2200      	movs	r2, #0
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    f6ce:	4613      	mov	r3, r2
    f6d0:	e50b      	b.n	f0ea <am_util_stdio_vsprintf+0x376>
    while ( i32NumChars-- )
    f6d2:	f10e 33ff 	add.w	r3, lr, #4294967295	; 0xffffffff
    f6d6:	4650      	mov	r0, sl
    int32_t i32Cnt = 0;
    f6d8:	2200      	movs	r2, #0
    f6da:	1e5c      	subs	r4, r3, #1
    f6dc:	1c51      	adds	r1, r2, #1
        if ( pcBuf )
    f6de:	b150      	cbz	r0, f6f6 <am_util_stdio_vsprintf+0x982>
            *pcBuf++ = cPadChar;
    f6e0:	4625      	mov	r5, r4
    f6e2:	461c      	mov	r4, r3
    f6e4:	f880 8000 	strb.w	r8, [r0]
    f6e8:	460a      	mov	r2, r1
    f6ea:	462b      	mov	r3, r5
    f6ec:	3001      	adds	r0, #1
    while ( i32NumChars-- )
    f6ee:	2c00      	cmp	r4, #0
    f6f0:	d1f3      	bne.n	f6da <am_util_stdio_vsprintf+0x966>
    f6f2:	4493      	add	fp, r2
    f6f4:	e5d0      	b.n	f298 <am_util_stdio_vsprintf+0x524>
    f6f6:	2b00      	cmp	r3, #0
    f6f8:	f000 8110 	beq.w	f91c <am_util_stdio_vsprintf+0xba8>
    f6fc:	3b02      	subs	r3, #2
    f6fe:	3202      	adds	r2, #2
    f700:	2c00      	cmp	r4, #0
    f702:	d1ea      	bne.n	f6da <am_util_stdio_vsprintf+0x966>
    f704:	e7f5      	b.n	f6f2 <am_util_stdio_vsprintf+0x97e>
    int iNDigits = ui64Val ? 0 : 1;
    f706:	4603      	mov	r3, r0
    f708:	430b      	orrs	r3, r1
    f70a:	bf0c      	ite	eq
    f70c:	f04f 0e01 	moveq.w	lr, #1
    f710:	f04f 0e00 	movne.w	lr, #0
                    bNeg = true;
    f714:	2301      	movs	r3, #1
    f716:	e571      	b.n	f1fc <am_util_stdio_vsprintf+0x488>
    else if (iExp2 >= 0)
    f718:	2a00      	cmp	r2, #0
    f71a:	f2c0 80f5 	blt.w	f908 <am_util_stdio_vsprintf+0xb94>
        i32FracPart = (i32Significand << (iExp2 + 1)) & 0x00FFFFFF;
    f71e:	f1a1 047e 	sub.w	r4, r1, #126	; 0x7e
    f722:	fa00 f404 	lsl.w	r4, r0, r4
        i32IntPart = i32Significand >> (23 - iExp2);
    f726:	f1c2 0217 	rsb	r2, r2, #23
    if (unFloatValue.I32 < 0)
    f72a:	2b00      	cmp	r3, #0
        i32FracPart = (i32Significand << (iExp2 + 1)) & 0x00FFFFFF;
    f72c:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
        i32IntPart = i32Significand >> (23 - iExp2);
    f730:	fa40 f002 	asr.w	r0, r0, r2
    if (unFloatValue.I32 < 0)
    f734:	f2c0 80d5 	blt.w	f8e2 <am_util_stdio_vsprintf+0xb6e>
    f738:	4656      	mov	r6, sl
            uint64_to_str(i32IntPart, pcBuf);
    f73a:	4632      	mov	r2, r6
    f73c:	17c1      	asrs	r1, r0, #31
    f73e:	f7ff fa43 	bl	ebc8 <uint64_to_str>
        while (*pcBuf)    // Get to end of new string
    f742:	7833      	ldrb	r3, [r6, #0]
    f744:	b90b      	cbnz	r3, f74a <am_util_stdio_vsprintf+0x9d6>
    f746:	e100      	b.n	f94a <am_util_stdio_vsprintf+0xbd6>
    f748:	463e      	mov	r6, r7
    f74a:	7873      	ldrb	r3, [r6, #1]
            pcBuf++;
    f74c:	1c77      	adds	r7, r6, #1
        while (*pcBuf)    // Get to end of new string
    f74e:	2b00      	cmp	r3, #0
    f750:	d1fa      	bne.n	f748 <am_util_stdio_vsprintf+0x9d4>
    f752:	1cb2      	adds	r2, r6, #2
    f754:	e480      	b.n	f058 <am_util_stdio_vsprintf+0x2e4>
    while ( i32NumChars-- )
    f756:	3b01      	subs	r3, #1
    f758:	4650      	mov	r0, sl
    int32_t i32Cnt = 0;
    f75a:	2200      	movs	r2, #0
    f75c:	1c51      	adds	r1, r2, #1
    f75e:	1e5c      	subs	r4, r3, #1
        if ( pcBuf )
    f760:	2800      	cmp	r0, #0
    f762:	d042      	beq.n	f7ea <am_util_stdio_vsprintf+0xa76>
            *pcBuf++ = cPadChar;
    f764:	4625      	mov	r5, r4
    f766:	f880 8000 	strb.w	r8, [r0]
    f76a:	461c      	mov	r4, r3
    f76c:	460a      	mov	r2, r1
    f76e:	462b      	mov	r3, r5
    f770:	3001      	adds	r0, #1
    while ( i32NumChars-- )
    f772:	2c00      	cmp	r4, #0
    f774:	d1f2      	bne.n	f75c <am_util_stdio_vsprintf+0x9e8>
    f776:	4493      	add	fp, r2
    f778:	e727      	b.n	f5ca <am_util_stdio_vsprintf+0x856>
    f77a:	1e48      	subs	r0, r1, #1
    f77c:	4654      	mov	r4, sl
    int32_t i32Cnt = 0;
    f77e:	2300      	movs	r3, #0
    f780:	1c59      	adds	r1, r3, #1
    f782:	1e45      	subs	r5, r0, #1
        if ( pcBuf )
    f784:	b3bc      	cbz	r4, f7f6 <am_util_stdio_vsprintf+0xa82>
            *pcBuf++ = cPadChar;
    f786:	f884 8000 	strb.w	r8, [r4]
    f78a:	460b      	mov	r3, r1
    f78c:	3401      	adds	r4, #1
    f78e:	4601      	mov	r1, r0
    while ( i32NumChars-- )
    f790:	4628      	mov	r0, r5
    f792:	2900      	cmp	r1, #0
    f794:	d1f4      	bne.n	f780 <am_util_stdio_vsprintf+0xa0c>
    f796:	eb0b 0403 	add.w	r4, fp, r3
    f79a:	e4ec      	b.n	f176 <am_util_stdio_vsprintf+0x402>
                bLongLong = true;
    f79c:	2301      	movs	r3, #1
    f79e:	e5ab      	b.n	f2f8 <am_util_stdio_vsprintf+0x584>
        bLower = bLongLong = false;
    f7a0:	2500      	movs	r5, #0
    f7a2:	e5ad      	b.n	f300 <am_util_stdio_vsprintf+0x58c>
    while ( i32NumChars-- )
    f7a4:	1e4b      	subs	r3, r1, #1
    f7a6:	4654      	mov	r4, sl
    int32_t i32Cnt = 0;
    f7a8:	2100      	movs	r1, #0
    f7aa:	1c48      	adds	r0, r1, #1
    f7ac:	1e5d      	subs	r5, r3, #1
        if ( pcBuf )
    f7ae:	b34c      	cbz	r4, f804 <am_util_stdio_vsprintf+0xa90>
            *pcBuf++ = cPadChar;
    f7b0:	f884 8000 	strb.w	r8, [r4]
    f7b4:	4601      	mov	r1, r0
    f7b6:	3401      	adds	r4, #1
    f7b8:	4618      	mov	r0, r3
    while ( i32NumChars-- )
    f7ba:	462b      	mov	r3, r5
    f7bc:	2800      	cmp	r0, #0
    f7be:	d1f4      	bne.n	f7aa <am_util_stdio_vsprintf+0xa36>
    f7c0:	448b      	add	fp, r1
    f7c2:	e68d      	b.n	f4e0 <am_util_stdio_vsprintf+0x76c>
                if ( iWidth > 0 )
    f7c4:	2900      	cmp	r1, #0
    f7c6:	f340 809a 	ble.w	f8fe <am_util_stdio_vsprintf+0xb8a>
                    if ( ui32strlen < iWidth )
    f7ca:	4606      	mov	r6, r0
    f7cc:	1b89      	subs	r1, r1, r6
    f7ce:	e4cd      	b.n	f16c <am_util_stdio_vsprintf+0x3f8>
                            if ( pcBuf )
    f7d0:	f1ba 0f00 	cmp.w	sl, #0
    f7d4:	d004      	beq.n	f7e0 <am_util_stdio_vsprintf+0xa6c>
                                *pcBuf++ = '-';
    f7d6:	232d      	movs	r3, #45	; 0x2d
    f7d8:	f88a 3000 	strb.w	r3, [sl]
    f7dc:	f10a 0a01 	add.w	sl, sl, #1
                            ++ui32CharCnt;
    f7e0:	2301      	movs	r3, #1
    f7e2:	f10b 0b01 	add.w	fp, fp, #1
    f7e6:	930f      	str	r3, [sp, #60]	; 0x3c
    f7e8:	e551      	b.n	f28e <am_util_stdio_vsprintf+0x51a>
    while ( i32NumChars-- )
    f7ea:	2b00      	cmp	r3, #0
    f7ec:	f000 80a1 	beq.w	f932 <am_util_stdio_vsprintf+0xbbe>
    f7f0:	3b02      	subs	r3, #2
    f7f2:	3202      	adds	r2, #2
    f7f4:	e7bd      	b.n	f772 <am_util_stdio_vsprintf+0x9fe>
    f7f6:	2800      	cmp	r0, #0
    f7f8:	f000 809e 	beq.w	f938 <am_util_stdio_vsprintf+0xbc4>
    f7fc:	4629      	mov	r1, r5
    f7fe:	3302      	adds	r3, #2
    f800:	1e85      	subs	r5, r0, #2
    f802:	e7c5      	b.n	f790 <am_util_stdio_vsprintf+0xa1c>
    f804:	2b00      	cmp	r3, #0
    f806:	f000 809d 	beq.w	f944 <am_util_stdio_vsprintf+0xbd0>
    f80a:	4628      	mov	r0, r5
    f80c:	3102      	adds	r1, #2
    f80e:	1e9d      	subs	r5, r3, #2
    f810:	e7d3      	b.n	f7ba <am_util_stdio_vsprintf+0xa46>
        iMax = iBufSize - (pcBuf - pcBufInitial) - 1;
    f812:	eba2 010a 	sub.w	r1, r2, sl
    f816:	f1c1 0313 	rsb	r3, r1, #19
        iMax = (iMax > iPrecision) ? iPrecision : iMax;
    f81a:	42ab      	cmp	r3, r5
    f81c:	bfa8      	it	ge
    f81e:	462b      	movge	r3, r5
        for (jx = 0; jx < iMax; jx++)
    f820:	2b00      	cmp	r3, #0
    f822:	dd0d      	ble.n	f840 <am_util_stdio_vsprintf+0xacc>
    f824:	18d1      	adds	r1, r2, r3
            i32FracPart *= 10;
    f826:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    f82a:	0064      	lsls	r4, r4, #1
            *pcBuf++ = (i32FracPart >> 24) + '0';
    f82c:	1623      	asrs	r3, r4, #24
    f82e:	3330      	adds	r3, #48	; 0x30
    f830:	f802 3b01 	strb.w	r3, [r2], #1
        for (jx = 0; jx < iMax; jx++)
    f834:	4291      	cmp	r1, r2
            i32FracPart &= 0x00FFFFFF;
    f836:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
        for (jx = 0; jx < iMax; jx++)
    f83a:	d1f4      	bne.n	f826 <am_util_stdio_vsprintf+0xab2>
    f83c:	eba2 010a 	sub.w	r1, r2, sl
        if ( ((i32FracPart * 10) >> 24) >= 5 )
    f840:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    f844:	f344 53c7 	sbfx	r3, r4, #23, #8
    f848:	2b04      	cmp	r3, #4
    f84a:	f77f ac10 	ble.w	f06e <am_util_stdio_vsprintf+0x2fa>
            pcBuftmp = pcBuf - 1;
    f84e:	1e53      	subs	r3, r2, #1
            while ( pcBuftmp >= pcBufInitial )
    f850:	459a      	cmp	sl, r3
    f852:	f63f ac0c 	bhi.w	f06e <am_util_stdio_vsprintf+0x2fa>
    f856:	f10a 35ff 	add.w	r5, sl, #4294967295	; 0xffffffff
    f85a:	e005      	b.n	f868 <am_util_stdio_vsprintf+0xaf4>
                    *pcBuftmp = '0';
    f85c:	f04f 0030 	mov.w	r0, #48	; 0x30
    f860:	7058      	strb	r0, [r3, #1]
            while ( pcBuftmp >= pcBufInitial )
    f862:	429d      	cmp	r5, r3
    f864:	f43f ac03 	beq.w	f06e <am_util_stdio_vsprintf+0x2fa>
    f868:	461c      	mov	r4, r3
                if ( *pcBuftmp == '.' )
    f86a:	f813 0901 	ldrb.w	r0, [r3], #-1
    f86e:	282e      	cmp	r0, #46	; 0x2e
    f870:	d0f7      	beq.n	f862 <am_util_stdio_vsprintf+0xaee>
                else if ( *pcBuftmp == '9' )
    f872:	2839      	cmp	r0, #57	; 0x39
    f874:	d0f2      	beq.n	f85c <am_util_stdio_vsprintf+0xae8>
                    *pcBuftmp += 1;
    f876:	3001      	adds	r0, #1
    f878:	7020      	strb	r0, [r4, #0]
    f87a:	f7ff bbf8 	b.w	f06e <am_util_stdio_vsprintf+0x2fa>
                while (*pcStr != 0x0)
    f87e:	7838      	ldrb	r0, [r7, #0]
    f880:	2800      	cmp	r0, #0
    f882:	d03c      	beq.n	f8fe <am_util_stdio_vsprintf+0xb8a>
    f884:	465c      	mov	r4, fp
        return ui32RetVal;
    f886:	463e      	mov	r6, r7
    f888:	2301      	movs	r3, #1
    f88a:	e44a      	b.n	f122 <am_util_stdio_vsprintf+0x3ae>
        *(uint32_t*)pcBuf = 0x00 << 24 | ('0' << 16) | ('.' << 8) | ('0' << 0);
    f88c:	4b39      	ldr	r3, [pc, #228]	; (f974 <am_util_stdio_vsprintf+0xc00>)
    f88e:	f8ca 3000 	str.w	r3, [sl]
    f892:	2303      	movs	r3, #3
    f894:	f7ff bbf1 	b.w	f07a <am_util_stdio_vsprintf+0x306>
                    if ( bNeg  &&  (ui8PadChar == ' ') )
    f898:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    f89a:	b11b      	cbz	r3, f8a4 <am_util_stdio_vsprintf+0xb30>
    f89c:	f1b8 0f20 	cmp.w	r8, #32
    f8a0:	f43f ae3f 	beq.w	f522 <am_util_stdio_vsprintf+0x7ae>
                iVal = uint64_to_str(ui64Val, pcBuf);
    f8a4:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
    f8a8:	4652      	mov	r2, sl
    f8aa:	f7ff f98d 	bl	ebc8 <uint64_to_str>
                ui32CharCnt += iVal;
    f8ae:	4483      	add	fp, r0
    f8b0:	f7ff ba68 	b.w	ed84 <am_util_stdio_vsprintf+0x10>
                        if ( iVal == AM_FTOA_ERR_VAL_TOO_SMALL )
    f8b4:	1c4b      	adds	r3, r1, #1
    f8b6:	d034      	beq.n	f922 <am_util_stdio_vsprintf+0xbae>
                        else if ( iVal == AM_FTOA_ERR_VAL_TOO_LARGE )
    f8b8:	3102      	adds	r1, #2
    f8ba:	d141      	bne.n	f940 <am_util_stdio_vsprintf+0xbcc>
                            u32PrntErrVal = (0x00 << 24) | ('#' << 16) |
    f8bc:	4b2e      	ldr	r3, [pc, #184]	; (f978 <am_util_stdio_vsprintf+0xc04>)
                        *(uint32_t*)pcBuf = u32PrntErrVal;
    f8be:	f8ca 3000 	str.w	r3, [sl]
    f8c2:	2303      	movs	r3, #3
    f8c4:	f7ff bbd9 	b.w	f07a <am_util_stdio_vsprintf+0x306>
        if (i32IntPart > 0)
    f8c8:	f73f af37 	bgt.w	f73a <am_util_stdio_vsprintf+0x9c6>
            uint64_to_str(-i32IntPart, pcBuf);
    f8cc:	4240      	negs	r0, r0
            *pcBuf++ = '-';
    f8ce:	232d      	movs	r3, #45	; 0x2d
    f8d0:	7033      	strb	r3, [r6, #0]
            uint64_to_str(-i32IntPart, pcBuf);
    f8d2:	463a      	mov	r2, r7
    f8d4:	17c1      	asrs	r1, r0, #31
    f8d6:	463e      	mov	r6, r7
    f8d8:	f7ff f976 	bl	ebc8 <uint64_to_str>
    f8dc:	3701      	adds	r7, #1
    f8de:	e730      	b.n	f742 <am_util_stdio_vsprintf+0x9ce>
    i32FracPart = 0;
    f8e0:	2400      	movs	r4, #0
        *pcBuf++ = '-';
    f8e2:	4653      	mov	r3, sl
    f8e4:	222d      	movs	r2, #45	; 0x2d
    f8e6:	f803 2b02 	strb.w	r2, [r3], #2
    f8ea:	463e      	mov	r6, r7
    f8ec:	461f      	mov	r7, r3
    f8ee:	f7ff bbac 	b.w	f04a <am_util_stdio_vsprintf+0x2d6>
                iVal = uint64_to_str(ui64Val, pcBuf);
    f8f2:	4652      	mov	r2, sl
    f8f4:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
    f8f8:	f7ff f966 	bl	ebc8 <uint64_to_str>
    f8fc:	e4f5      	b.n	f2ea <am_util_stdio_vsprintf+0x576>
        return ui32RetVal;
    f8fe:	4606      	mov	r6, r0
    f900:	e428      	b.n	f154 <am_util_stdio_vsprintf+0x3e0>
    f902:	4620      	mov	r0, r4
    f904:	44a3      	add	fp, r4
    f906:	e522      	b.n	f34e <am_util_stdio_vsprintf+0x5da>
        i32FracPart = (i32Significand & 0x00FFFFFF) >> -(iExp2 + 1);
    f908:	43d2      	mvns	r2, r2
    if (unFloatValue.I32 < 0)
    f90a:	2b00      	cmp	r3, #0
        i32FracPart = (i32Significand & 0x00FFFFFF) >> -(iExp2 + 1);
    f90c:	fa40 f402 	asr.w	r4, r0, r2
    f910:	f10a 0202 	add.w	r2, sl, #2
    if (unFloatValue.I32 < 0)
    f914:	db1d      	blt.n	f952 <am_util_stdio_vsprintf+0xbde>
    f916:	4656      	mov	r6, sl
    f918:	f7ff bb9b 	b.w	f052 <am_util_stdio_vsprintf+0x2de>
    f91c:	460a      	mov	r2, r1
    f91e:	448b      	add	fp, r1
    f920:	e4ba      	b.n	f298 <am_util_stdio_vsprintf+0x524>
                            u32PrntErrVal = (0x00 << 24) | ('0' << 16) |
    f922:	4b14      	ldr	r3, [pc, #80]	; (f974 <am_util_stdio_vsprintf+0xc00>)
    f924:	e7cb      	b.n	f8be <am_util_stdio_vsprintf+0xb4a>
                    iWidth -= ndigits_in_i64(ui64Val);
    f926:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    f928:	eba3 0e0e 	sub.w	lr, r3, lr
                    bNeg = false;
    f92c:	2300      	movs	r3, #0
    f92e:	930f      	str	r3, [sp, #60]	; 0x3c
    f930:	e4ad      	b.n	f28e <am_util_stdio_vsprintf+0x51a>
    f932:	460a      	mov	r2, r1
    f934:	448b      	add	fp, r1
    f936:	e648      	b.n	f5ca <am_util_stdio_vsprintf+0x856>
    f938:	460b      	mov	r3, r1
    f93a:	eb0b 0401 	add.w	r4, fp, r1
    f93e:	e41a      	b.n	f176 <am_util_stdio_vsprintf+0x402>
                            u32PrntErrVal = (0x00 << 24) | ('?' << 16) |
    f940:	4b0e      	ldr	r3, [pc, #56]	; (f97c <am_util_stdio_vsprintf+0xc08>)
    f942:	e7bc      	b.n	f8be <am_util_stdio_vsprintf+0xb4a>
    f944:	4601      	mov	r1, r0
    f946:	4483      	add	fp, r0
    f948:	e5ca      	b.n	f4e0 <am_util_stdio_vsprintf+0x76c>
        while (*pcBuf)    // Get to end of new string
    f94a:	463a      	mov	r2, r7
    f94c:	4637      	mov	r7, r6
    f94e:	f7ff bb83 	b.w	f058 <am_util_stdio_vsprintf+0x2e4>
        *pcBuf++ = '-';
    f952:	4653      	mov	r3, sl
    f954:	212d      	movs	r1, #45	; 0x2d
    f956:	f803 1b03 	strb.w	r1, [r3], #3
    f95a:	463e      	mov	r6, r7
    f95c:	4617      	mov	r7, r2
    f95e:	461a      	mov	r2, r3
    f960:	f7ff bb77 	b.w	f052 <am_util_stdio_vsprintf+0x2de>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    f964:	2300      	movs	r3, #0
        uCnt++;
    f966:	2201      	movs	r2, #1
    f968:	f7ff bbbe 	b.w	f0e8 <am_util_stdio_vsprintf+0x374>
                pcStr = va_arg(pArgs, char *);
    f96c:	9201      	str	r2, [sp, #4]
                        ui32CharCnt += iWidth;
    f96e:	46a3      	mov	fp, r4
    f970:	f7ff ba08 	b.w	ed84 <am_util_stdio_vsprintf+0x10>
    f974:	00302e30 	.word	0x00302e30
    f978:	00232e23 	.word	0x00232e23
    f97c:	003f2e3f 	.word	0x003f2e3f

0000f980 <am_util_stdio_printf>:
//! @return uint32_t representing the number of characters printed.
//
// *****************************************************************************
uint32_t
am_util_stdio_printf(const char *pcFmt, ...)
{
    f980:	b40f      	push	{r0, r1, r2, r3}
    f982:	b530      	push	{r4, r5, lr}
    uint32_t ui32NumChars;

    if (!g_pfnCharPrint)
    f984:	4d0a      	ldr	r5, [pc, #40]	; (f9b0 <am_util_stdio_printf+0x30>)
    f986:	682c      	ldr	r4, [r5, #0]
{
    f988:	b083      	sub	sp, #12
    if (!g_pfnCharPrint)
    f98a:	b154      	cbz	r4, f9a2 <am_util_stdio_printf+0x22>

    //
    // Convert to the desired string.
    //
    va_list pArgs;
    va_start(pArgs, pcFmt);
    f98c:	ab07      	add	r3, sp, #28
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
    f98e:	461a      	mov	r2, r3
    f990:	9906      	ldr	r1, [sp, #24]
    f992:	4808      	ldr	r0, [pc, #32]	; (f9b4 <am_util_stdio_printf+0x34>)
    va_start(pArgs, pcFmt);
    f994:	9301      	str	r3, [sp, #4]
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
    f996:	f7ff f9ed 	bl	ed74 <am_util_stdio_vsprintf>
    va_end(pArgs);

    //
    // This is where we print the buffer to the configured interface.
    //
    g_pfnCharPrint(g_prfbuf);
    f99a:	682b      	ldr	r3, [r5, #0]
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
    f99c:	4604      	mov	r4, r0
    g_pfnCharPrint(g_prfbuf);
    f99e:	4805      	ldr	r0, [pc, #20]	; (f9b4 <am_util_stdio_printf+0x34>)
    f9a0:	4798      	blx	r3

    //
    // return the number of characters printed.
    //
    return ui32NumChars;
}
    f9a2:	4620      	mov	r0, r4
    f9a4:	b003      	add	sp, #12
    f9a6:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    f9aa:	b004      	add	sp, #16
    f9ac:	4770      	bx	lr
    f9ae:	bf00      	nop
    f9b0:	10013418 	.word	0x10013418
    f9b4:	10012d2c 	.word	0x10012d2c

0000f9b8 <am_app_utils_ring_buffer_init_all>:
void
am_app_utils_ring_buffer_init_all(am_app_utils_ring_buffer_t* ring_buffs, const am_app_utils_ringbuff_setup_t* setup_array, 
                                    uint32_t ui32BufferCount)
{
    uint32_t ringbuff = 0;
    for(ringbuff =0; ringbuff<ui32BufferCount; ringbuff++)
    f9b8:	b302      	cbz	r2, f9fc <am_app_utils_ring_buffer_init_all+0x44>
{
    f9ba:	b4f0      	push	{r4, r5, r6, r7}
    f9bc:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    f9c0:	b084      	sub	sp, #16
    f9c2:	4606      	mov	r6, r0
    f9c4:	460b      	mov	r3, r1
    f9c6:	eb01 0782 	add.w	r7, r1, r2, lsl #2
    f9ca:	ad01      	add	r5, sp, #4
    ring_buffs[setup.indx].ui32BufferHead_read = 0;
    f9cc:	2400      	movs	r4, #0
    f9ce:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
    f9d2:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    f9d6:	9a01      	ldr	r2, [sp, #4]
    f9d8:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    f9dc:	eb06 0182 	add.w	r1, r6, r2, lsl #2
    f9e0:	330c      	adds	r3, #12
    f9e2:	608c      	str	r4, [r1, #8]
    ring_buffs[setup.indx].ui32BufferTail_write = 0;
    f9e4:	604c      	str	r4, [r1, #4]
    ring_buffs[setup.indx].ui32OverWriting = 0;
    f9e6:	60cc      	str	r4, [r1, #12]
    ring_buffs[setup.indx].ui32Capacity = setup.ui32ByteSize;
    f9e8:	9803      	ldr	r0, [sp, #12]
    f9ea:	6108      	str	r0, [r1, #16]
    for(ringbuff =0; ringbuff<ui32BufferCount; ringbuff++)
    f9ec:	42bb      	cmp	r3, r7
    ring_buffs[setup.indx].pui8Data = setup.pData;
    f9ee:	9902      	ldr	r1, [sp, #8]
    f9f0:	f846 1022 	str.w	r1, [r6, r2, lsl #2]
    for(ringbuff =0; ringbuff<ui32BufferCount; ringbuff++)
    f9f4:	d1eb      	bne.n	f9ce <am_app_utils_ring_buffer_init_all+0x16>
    {
        am_app_utils_ring_buffer_init(ring_buffs,setup_array[ringbuff]);    
    }

}
    f9f6:	b004      	add	sp, #16
    f9f8:	bcf0      	pop	{r4, r5, r6, r7}
    f9fa:	4770      	bx	lr
    f9fc:	4770      	bx	lr
    f9fe:	bf00      	nop

0000fa00 <am_app_utils_ring_buffer_push>:


uint32_t am_app_utils_ring_buffer_push(am_app_utils_ring_buffer_t *psBuffer, void *pvSource, uint32_t ui32Bytes)
{
    fa00:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    fa04:	4688      	mov	r8, r1
    
    ui32CopyLen = ui32Bytes;
    pui8Source = (uint8_t*)pvSource;

    // won't push any data if buffer is full
    if(am_app_utils_ring_buffer_full(psBuffer))
    fa06:	6841      	ldr	r1, [r0, #4]
    fa08:	6883      	ldr	r3, [r0, #8]
    fa0a:	4299      	cmp	r1, r3
{
    fa0c:	4604      	mov	r4, r0
    fa0e:	4615      	mov	r5, r2
    if(am_app_utils_ring_buffer_full(psBuffer))
    fa10:	d049      	beq.n	faa6 <am_app_utils_ring_buffer_push+0xa6>
        ui32ReturnPushLen =0;
        return ui32ReturnPushLen;
    }

    // push data until the buffer is full
    if(am_app_utils_ring_buffer_empty(psBuffer))
    fa12:	6862      	ldr	r2, [r4, #4]
    fa14:	68a3      	ldr	r3, [r4, #8]
    fa16:	429a      	cmp	r2, r3
    fa18:	d03b      	beq.n	fa92 <am_app_utils_ring_buffer_push+0x92>
            ui32CopyLen = psBuffer->ui32Capacity;
        }
    }
    else
    {
        if(((psBuffer->ui32BufferHead_read + psBuffer->ui32Capacity - psBuffer->ui32BufferTail_write) 
    fa1a:	68a3      	ldr	r3, [r4, #8]
    fa1c:	6920      	ldr	r0, [r4, #16]
    fa1e:	6862      	ldr	r2, [r4, #4]
            % psBuffer->ui32Capacity) <= ui32CopyLen)
    fa20:	6921      	ldr	r1, [r4, #16]
        if(((psBuffer->ui32BufferHead_read + psBuffer->ui32Capacity - psBuffer->ui32BufferTail_write) 
    fa22:	4403      	add	r3, r0
    fa24:	1a9b      	subs	r3, r3, r2
            % psBuffer->ui32Capacity) <= ui32CopyLen)
    fa26:	fbb3 f2f1 	udiv	r2, r3, r1
    fa2a:	fb01 3312 	mls	r3, r1, r2, r3
        if(((psBuffer->ui32BufferHead_read + psBuffer->ui32Capacity - psBuffer->ui32BufferTail_write) 
    fa2e:	42ab      	cmp	r3, r5
    fa30:	d80b      	bhi.n	fa4a <am_app_utils_ring_buffer_push+0x4a>
        {    
            psBuffer->ui32OverWriting = 1;
    fa32:	2301      	movs	r3, #1
    fa34:	60e3      	str	r3, [r4, #12]
            ui32CopyLen = ((psBuffer->ui32BufferHead_read + psBuffer->ui32Capacity - psBuffer->ui32BufferTail_write) 
    fa36:	68a3      	ldr	r3, [r4, #8]
    fa38:	6921      	ldr	r1, [r4, #16]
    fa3a:	6865      	ldr	r5, [r4, #4]
            % psBuffer->ui32Capacity);
    fa3c:	6922      	ldr	r2, [r4, #16]
            ui32CopyLen = ((psBuffer->ui32BufferHead_read + psBuffer->ui32Capacity - psBuffer->ui32BufferTail_write) 
    fa3e:	440b      	add	r3, r1
    fa40:	1b5b      	subs	r3, r3, r5
    fa42:	fbb3 f5f2 	udiv	r5, r3, r2
    fa46:	fb02 3515 	mls	r5, r2, r5, r3

    }        
        
    ui32ReturnPushLen = ui32CopyLen;

    while((psBuffer->ui32BufferTail_write + ui32CopyLen) >= psBuffer->ui32Capacity)
    fa4a:	6863      	ldr	r3, [r4, #4]
    fa4c:	6922      	ldr	r2, [r4, #16]
    fa4e:	442b      	add	r3, r5
    fa50:	4293      	cmp	r3, r2
    fa52:	462e      	mov	r6, r5
    fa54:	d32d      	bcc.n	fab2 <am_app_utils_ring_buffer_push+0xb2>
    {
        ui32TempLen = psBuffer->ui32Capacity - psBuffer->ui32BufferTail_write;
    fa56:	6927      	ldr	r7, [r4, #16]
    fa58:	6862      	ldr	r2, [r4, #4]
        memcpy((void*)&psBuffer->pui8Data[psBuffer->ui32BufferTail_write], pui8Source, ui32TempLen);
    fa5a:	6820      	ldr	r0, [r4, #0]
    fa5c:	6863      	ldr	r3, [r4, #4]
        ui32TempLen = psBuffer->ui32Capacity - psBuffer->ui32BufferTail_write;
    fa5e:	1abf      	subs	r7, r7, r2
        memcpy((void*)&psBuffer->pui8Data[psBuffer->ui32BufferTail_write], pui8Source, ui32TempLen);
    fa60:	463a      	mov	r2, r7
    fa62:	4418      	add	r0, r3
    fa64:	4641      	mov	r1, r8
    fa66:	f7fc fb4b 	bl	c100 <memcpy>
        psBuffer->ui32BufferTail_write = ((psBuffer->ui32BufferTail_write + ui32TempLen) % psBuffer->ui32Capacity);
    fa6a:	6863      	ldr	r3, [r4, #4]
    fa6c:	6921      	ldr	r1, [r4, #16]
    fa6e:	443b      	add	r3, r7
    fa70:	fbb3 f2f1 	udiv	r2, r3, r1
    fa74:	fb01 3312 	mls	r3, r1, r2, r3
    fa78:	6063      	str	r3, [r4, #4]
    while((psBuffer->ui32BufferTail_write + ui32CopyLen) >= psBuffer->ui32Capacity)
    fa7a:	6863      	ldr	r3, [r4, #4]
    fa7c:	6922      	ldr	r2, [r4, #16]
        ui32CopyLen -= ui32TempLen;
    fa7e:	1bf6      	subs	r6, r6, r7
    while((psBuffer->ui32BufferTail_write + ui32CopyLen) >= psBuffer->ui32Capacity)
    fa80:	4433      	add	r3, r6
    fa82:	4293      	cmp	r3, r2
    fa84:	d2e7      	bcs.n	fa56 <am_app_utils_ring_buffer_push+0x56>
    }
    configASSERT((psBuffer->ui32BufferTail_write + ui32CopyLen) < psBuffer->ui32Capacity);
    fa86:	6863      	ldr	r3, [r4, #4]
    fa88:	6922      	ldr	r2, [r4, #16]
    fa8a:	4433      	add	r3, r6
    fa8c:	4293      	cmp	r3, r2
    fa8e:	d312      	bcc.n	fab6 <am_app_utils_ring_buffer_push+0xb6>
    fa90:	e7fe      	b.n	fa90 <am_app_utils_ring_buffer_push+0x90>
    if(am_app_utils_ring_buffer_empty(psBuffer))
    fa92:	68e3      	ldr	r3, [r4, #12]
    fa94:	2b00      	cmp	r3, #0
    fa96:	d1c0      	bne.n	fa1a <am_app_utils_ring_buffer_push+0x1a>
        if(ui32CopyLen >= psBuffer->ui32Capacity)
    fa98:	6923      	ldr	r3, [r4, #16]
    fa9a:	42ab      	cmp	r3, r5
    fa9c:	d8d5      	bhi.n	fa4a <am_app_utils_ring_buffer_push+0x4a>
            psBuffer->ui32OverWriting = 1;
    fa9e:	2301      	movs	r3, #1
    faa0:	60e3      	str	r3, [r4, #12]
            ui32CopyLen = psBuffer->ui32Capacity;
    faa2:	6925      	ldr	r5, [r4, #16]
    faa4:	e7d1      	b.n	fa4a <am_app_utils_ring_buffer_push+0x4a>
    if(am_app_utils_ring_buffer_full(psBuffer))
    faa6:	68c3      	ldr	r3, [r0, #12]
    faa8:	2b01      	cmp	r3, #1
    faaa:	d1b2      	bne.n	fa12 <am_app_utils_ring_buffer_push+0x12>
        return ui32ReturnPushLen;
    faac:	2000      	movs	r0, #0
    memcpy((void*)&psBuffer->pui8Data[psBuffer->ui32BufferTail_write], &pui8Source[ui32TempLen], ui32CopyLen);
    psBuffer->ui32BufferTail_write = ((psBuffer->ui32BufferTail_write + ui32CopyLen) % psBuffer->ui32Capacity);
    
    return ui32ReturnPushLen;

}
    faae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    uint32_t ui32TempLen = 0;
    fab2:	2700      	movs	r7, #0
    fab4:	e7e7      	b.n	fa86 <am_app_utils_ring_buffer_push+0x86>
    memcpy((void*)&psBuffer->pui8Data[psBuffer->ui32BufferTail_write], &pui8Source[ui32TempLen], ui32CopyLen);
    fab6:	6863      	ldr	r3, [r4, #4]
    fab8:	6820      	ldr	r0, [r4, #0]
    faba:	4632      	mov	r2, r6
    fabc:	4418      	add	r0, r3
    fabe:	eb08 0107 	add.w	r1, r8, r7
    fac2:	f7fc fb1d 	bl	c100 <memcpy>
    psBuffer->ui32BufferTail_write = ((psBuffer->ui32BufferTail_write + ui32CopyLen) % psBuffer->ui32Capacity);
    fac6:	6863      	ldr	r3, [r4, #4]
    fac8:	6922      	ldr	r2, [r4, #16]
    faca:	441e      	add	r6, r3
    facc:	fbb6 f3f2 	udiv	r3, r6, r2
    fad0:	fb02 6613 	mls	r6, r2, r3, r6
    return ui32ReturnPushLen;
    fad4:	4628      	mov	r0, r5
    psBuffer->ui32BufferTail_write = ((psBuffer->ui32BufferTail_write + ui32CopyLen) % psBuffer->ui32Capacity);
    fad6:	6066      	str	r6, [r4, #4]
    return ui32ReturnPushLen;
    fad8:	e7e9      	b.n	faae <am_app_utils_ring_buffer_push+0xae>
    fada:	bf00      	nop

0000fadc <am_app_utils_ring_buffer_pop>:


uint32_t am_app_utils_ring_buffer_pop(am_app_utils_ring_buffer_t *psBuffer, void *pvDest,
                         uint32_t ui32Bytes)
{
    fadc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    fae0:	4688      	mov	r8, r1
uint32_t
am_app_utils_get_ring_buffer_status(am_app_utils_ring_buffer_t *psBuffer)
{
    uint32_t ui32NewDataLen = 0;
    
    if (am_app_utils_ring_buffer_overwrite(psBuffer) || am_app_utils_ring_buffer_full(psBuffer))
    fae2:	6841      	ldr	r1, [r0, #4]
    fae4:	6883      	ldr	r3, [r0, #8]
    fae6:	4299      	cmp	r1, r3
{
    fae8:	4604      	mov	r4, r0
    if (am_app_utils_ring_buffer_overwrite(psBuffer) || am_app_utils_ring_buffer_full(psBuffer))
    faea:	d002      	beq.n	faf2 <am_app_utils_ring_buffer_pop+0x16>
    faec:	68c3      	ldr	r3, [r0, #12]
    faee:	2b01      	cmp	r3, #1
    faf0:	d041      	beq.n	fb76 <am_app_utils_ring_buffer_pop+0x9a>
    faf2:	6861      	ldr	r1, [r4, #4]
    faf4:	68a3      	ldr	r3, [r4, #8]
    faf6:	4299      	cmp	r1, r3
    faf8:	d03a      	beq.n	fb70 <am_app_utils_ring_buffer_pop+0x94>
    {
        ui32NewDataLen = psBuffer->ui32Capacity;
        return ui32NewDataLen;
    }
    
    ui32NewDataLen = ((psBuffer->ui32BufferTail_write + psBuffer->ui32Capacity - psBuffer->ui32BufferHead_read) % 
    fafa:	6863      	ldr	r3, [r4, #4]
    fafc:	6925      	ldr	r5, [r4, #16]
    fafe:	68a1      	ldr	r1, [r4, #8]
        psBuffer->ui32Capacity);
    fb00:	6920      	ldr	r0, [r4, #16]
    ui32NewDataLen = ((psBuffer->ui32BufferTail_write + psBuffer->ui32Capacity - psBuffer->ui32BufferHead_read) % 
    fb02:	442b      	add	r3, r5
    fb04:	1a5b      	subs	r3, r3, r1
    fb06:	fbb3 f1f0 	udiv	r1, r3, r0
    fb0a:	fb00 3311 	mls	r3, r0, r1, r3
    if(am_app_utils_ring_buffer_overwrite(psBuffer))
    fb0e:	6860      	ldr	r0, [r4, #4]
    fb10:	68a1      	ldr	r1, [r4, #8]
    fb12:	4288      	cmp	r0, r1
    fb14:	d004      	beq.n	fb20 <am_app_utils_ring_buffer_pop+0x44>
    fb16:	68e1      	ldr	r1, [r4, #12]
    fb18:	2901      	cmp	r1, #1
        psBuffer->ui32BufferHead_read = (psBuffer->ui32BufferTail_write);
    fb1a:	bf04      	itt	eq
    fb1c:	6861      	ldreq	r1, [r4, #4]
    fb1e:	60a1      	streq	r1, [r4, #8]
    ui32CopyLen = ui32Bytes < ui32DataLen ? ui32Bytes : ui32DataLen;
    fb20:	429a      	cmp	r2, r3
    while((psBuffer->ui32BufferHead_read + ui32CopyLen) >= psBuffer->ui32Capacity)
    fb22:	68a1      	ldr	r1, [r4, #8]
    fb24:	6920      	ldr	r0, [r4, #16]
    ui32CopyLen = ui32Bytes < ui32DataLen ? ui32Bytes : ui32DataLen;
    fb26:	bf28      	it	cs
    fb28:	461a      	movcs	r2, r3
    while((psBuffer->ui32BufferHead_read + ui32CopyLen) >= psBuffer->ui32Capacity)
    fb2a:	1853      	adds	r3, r2, r1
    fb2c:	4298      	cmp	r0, r3
    ui32CopyLen = ui32Bytes < ui32DataLen ? ui32Bytes : ui32DataLen;
    fb2e:	4617      	mov	r7, r2
    fb30:	4615      	mov	r5, r2
    while((psBuffer->ui32BufferHead_read + ui32CopyLen) >= psBuffer->ui32Capacity)
    fb32:	d822      	bhi.n	fb7a <am_app_utils_ring_buffer_pop+0x9e>
        ui32TempLen = psBuffer->ui32Capacity - psBuffer->ui32BufferHead_read;
    fb34:	6926      	ldr	r6, [r4, #16]
    fb36:	68a2      	ldr	r2, [r4, #8]
        memcpy(pui8Dest, (void*)&psBuffer->pui8Data[psBuffer->ui32BufferHead_read], ui32TempLen);
    fb38:	6821      	ldr	r1, [r4, #0]
    fb3a:	68a3      	ldr	r3, [r4, #8]
        ui32TempLen = psBuffer->ui32Capacity - psBuffer->ui32BufferHead_read;
    fb3c:	1ab6      	subs	r6, r6, r2
        memcpy(pui8Dest, (void*)&psBuffer->pui8Data[psBuffer->ui32BufferHead_read], ui32TempLen);
    fb3e:	4419      	add	r1, r3
    fb40:	4632      	mov	r2, r6
    fb42:	4640      	mov	r0, r8
    fb44:	f7fc fadc 	bl	c100 <memcpy>
        psBuffer->ui32BufferHead_read = ((psBuffer->ui32BufferHead_read + ui32TempLen) % psBuffer->ui32Capacity);
    fb48:	68a3      	ldr	r3, [r4, #8]
    fb4a:	6921      	ldr	r1, [r4, #16]
    fb4c:	4433      	add	r3, r6
    fb4e:	fbb3 f2f1 	udiv	r2, r3, r1
    fb52:	fb01 3312 	mls	r3, r1, r2, r3
    fb56:	60a3      	str	r3, [r4, #8]
    while((psBuffer->ui32BufferHead_read + ui32CopyLen) >= psBuffer->ui32Capacity)
    fb58:	68a3      	ldr	r3, [r4, #8]
    fb5a:	6922      	ldr	r2, [r4, #16]
        ui32CopyLen -= ui32TempLen;
    fb5c:	1bad      	subs	r5, r5, r6
    while((psBuffer->ui32BufferHead_read + ui32CopyLen) >= psBuffer->ui32Capacity)
    fb5e:	442b      	add	r3, r5
    fb60:	4293      	cmp	r3, r2
    fb62:	d2e7      	bcs.n	fb34 <am_app_utils_ring_buffer_pop+0x58>
    configASSERT((psBuffer->ui32BufferHead_read + ui32CopyLen) < psBuffer->ui32Capacity);
    fb64:	68a3      	ldr	r3, [r4, #8]
    fb66:	6922      	ldr	r2, [r4, #16]
    fb68:	442b      	add	r3, r5
    fb6a:	4293      	cmp	r3, r2
    fb6c:	d307      	bcc.n	fb7e <am_app_utils_ring_buffer_pop+0xa2>
    fb6e:	e7fe      	b.n	fb6e <am_app_utils_ring_buffer_pop+0x92>
    if (am_app_utils_ring_buffer_overwrite(psBuffer) || am_app_utils_ring_buffer_full(psBuffer))
    fb70:	68e3      	ldr	r3, [r4, #12]
    fb72:	2b01      	cmp	r3, #1
    fb74:	d1c1      	bne.n	fafa <am_app_utils_ring_buffer_pop+0x1e>
        ui32NewDataLen = psBuffer->ui32Capacity;
    fb76:	6923      	ldr	r3, [r4, #16]
    fb78:	e7c9      	b.n	fb0e <am_app_utils_ring_buffer_pop+0x32>
    uint32_t ui32TempLen = 0;
    fb7a:	2600      	movs	r6, #0
    fb7c:	e7f2      	b.n	fb64 <am_app_utils_ring_buffer_pop+0x88>
    memcpy(&pui8Dest[ui32TempLen], (void*)&psBuffer->pui8Data[psBuffer->ui32BufferHead_read], ui32CopyLen);
    fb7e:	68a3      	ldr	r3, [r4, #8]
    fb80:	6821      	ldr	r1, [r4, #0]
    fb82:	462a      	mov	r2, r5
    fb84:	4419      	add	r1, r3
    fb86:	eb08 0006 	add.w	r0, r8, r6
    fb8a:	f7fc fab9 	bl	c100 <memcpy>
    psBuffer->ui32BufferHead_read = ((psBuffer->ui32BufferHead_read + ui32CopyLen) % psBuffer->ui32Capacity);
    fb8e:	68a3      	ldr	r3, [r4, #8]
    fb90:	6922      	ldr	r2, [r4, #16]
    fb92:	441d      	add	r5, r3
    psBuffer->ui32OverWriting = 0;
    fb94:	2100      	movs	r1, #0
    psBuffer->ui32BufferHead_read = ((psBuffer->ui32BufferHead_read + ui32CopyLen) % psBuffer->ui32Capacity);
    fb96:	fbb5 f3f2 	udiv	r3, r5, r2
    fb9a:	fb02 5513 	mls	r5, r2, r3, r5
    fb9e:	60a5      	str	r5, [r4, #8]
}
    fba0:	4638      	mov	r0, r7
    psBuffer->ui32OverWriting = 0;
    fba2:	60e1      	str	r1, [r4, #12]
}
    fba4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000fba8 <am_app_utils_rtt_init>:

#include "am_app_utils_rtt_recorder.h"


void am_app_utils_rtt_init(uint8_t* rttBuffer, uint32_t LenBytes)
{
    fba8:	b510      	push	{r4, lr}
    fbaa:	b082      	sub	sp, #8
    
    SEGGER_RTT_ConfigUpBuffer(1, "DataLogger", rttBuffer, LenBytes, SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL);
    fbac:	2402      	movs	r4, #2
    fbae:	460b      	mov	r3, r1
    fbb0:	4602      	mov	r2, r0
    fbb2:	9400      	str	r4, [sp, #0]
    fbb4:	4902      	ldr	r1, [pc, #8]	; (fbc0 <am_app_utils_rtt_init+0x18>)
    fbb6:	2001      	movs	r0, #1
    fbb8:	f000 fb2a 	bl	10210 <SEGGER_RTT_ConfigUpBuffer>

}
    fbbc:	b002      	add	sp, #8
    fbbe:	bd10      	pop	{r4, pc}
    fbc0:	00013970 	.word	0x00013970

0000fbc4 <am_app_utils_rtt_record>:

void am_app_utils_rtt_record(void* pBuffer, uint32_t NumBytes)
{
    uint32_t bytes_stored;
    bytes_stored = SEGGER_RTT_Write(1, (uint8_t*)pBuffer, NumBytes);
    fbc4:	460a      	mov	r2, r1
    fbc6:	4601      	mov	r1, r0
    fbc8:	2001      	movs	r0, #1
    fbca:	f000 ba27 	b.w	1001c <SEGGER_RTT_Write>
    fbce:	bf00      	nop

0000fbd0 <am_app_utils_task_init>:
//*****************************************************************************
void am_app_utils_task_init(am_app_utils_task_t* pTaskList, uint32_t taskCount)
{
	uint32_t i = 0;

    for(i=0 ; i<taskCount; i++)
    fbd0:	b139      	cbz	r1, fbe2 <am_app_utils_task_init+0x12>
    fbd2:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
	{
		pTaskList[i].task = NULL;
    fbd6:	2300      	movs	r3, #0
		pTaskList[i].queue = NULL;
    fbd8:	e9c0 3300 	strd	r3, r3, [r0]
    fbdc:	3008      	adds	r0, #8
    for(i=0 ; i<taskCount; i++)
    fbde:	4288      	cmp	r0, r1
    fbe0:	d1fa      	bne.n	fbd8 <am_app_utils_task_init+0x8>
	}
}
    fbe2:	4770      	bx	lr

0000fbe4 <am_app_utils_task_create_all_tasks>:
void
am_app_utils_task_create_all_tasks(am_app_utils_task_setup_t *setup_array, am_app_utils_task_t* pTaskList, uint32_t setupLen)
{
    uint8_t task = 0;

	for(task = 0; task<setupLen; task++)
    fbe4:	b38a      	cbz	r2, fc4a <am_app_utils_task_create_all_tasks+0x66>
{
    fbe6:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	for(task = 0; task<setupLen; task++)
    fbea:	2400      	movs	r4, #0
{
    fbec:	b082      	sub	sp, #8
    fbee:	4690      	mov	r8, r2
    fbf0:	460f      	mov	r7, r1
    fbf2:	4606      	mov	r6, r0
	for(task = 0; task<setupLen; task++)
    fbf4:	4623      	mov	r3, r4
	{
		// Spawn all tasks
		am_app_utils_task_create(setup_array[task], pTaskList);
    fbf6:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
    fbfa:	eb06 0583 	add.w	r5, r6, r3, lsl #2
    xTaskCreate(setup.pxTaskCode, setup.pcName, setup.usStackDepth, setup.pvParameters, setup.uxPriority, &(pTaskList[setup.indx].task));
    fbfe:	f856 a023 	ldr.w	sl, [r6, r3, lsl #2]
    fc02:	f8d5 c010 	ldr.w	ip, [r5, #16]
    fc06:	696b      	ldr	r3, [r5, #20]
    fc08:	89aa      	ldrh	r2, [r5, #12]
    fc0a:	eb07 09ca 	add.w	r9, r7, sl, lsl #3
    fc0e:	e9d5 0101 	ldrd	r0, r1, [r5, #4]
    fc12:	9300      	str	r3, [sp, #0]
    fc14:	f8cd 9004 	str.w	r9, [sp, #4]
    fc18:	4663      	mov	r3, ip
    fc1a:	69ad      	ldr	r5, [r5, #24]
    fc1c:	f7fd f8a0 	bl	cd60 <xTaskCreate>
	configASSERT(pTaskList[setup.indx].task != NULL);
    fc20:	f857 303a 	ldr.w	r3, [r7, sl, lsl #3]
	pTaskList[setup.indx].queue = xQueueCreate(setup.uxQueueLength, sizeof(am_app_utils_task_queue_element_t));  
    fc24:	2200      	movs	r2, #0
    fc26:	2110      	movs	r1, #16
    fc28:	4628      	mov	r0, r5
	configASSERT(pTaskList[setup.indx].task != NULL);
    fc2a:	b163      	cbz	r3, fc46 <am_app_utils_task_create_all_tasks+0x62>
	pTaskList[setup.indx].queue = xQueueCreate(setup.uxQueueLength, sizeof(am_app_utils_task_queue_element_t));  
    fc2c:	f7fc fbc0 	bl	c3b0 <xQueueGenericCreate>
	for(task = 0; task<setupLen; task++)
    fc30:	3401      	adds	r4, #1
    fc32:	b2e4      	uxtb	r4, r4
    fc34:	4623      	mov	r3, r4
	pTaskList[setup.indx].queue = xQueueCreate(setup.uxQueueLength, sizeof(am_app_utils_task_queue_element_t));  
    fc36:	f8c9 0004 	str.w	r0, [r9, #4]
	configASSERT(pTaskList[setup.indx].queue != NULL);
    fc3a:	b128      	cbz	r0, fc48 <am_app_utils_task_create_all_tasks+0x64>
	for(task = 0; task<setupLen; task++)
    fc3c:	4544      	cmp	r4, r8
    fc3e:	d3da      	bcc.n	fbf6 <am_app_utils_task_create_all_tasks+0x12>
	}

}
    fc40:	b002      	add	sp, #8
    fc42:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    fc46:	e7fe      	b.n	fc46 <am_app_utils_task_create_all_tasks+0x62>
    fc48:	e7fe      	b.n	fc48 <am_app_utils_task_create_all_tasks+0x64>
    fc4a:	4770      	bx	lr

0000fc4c <am_app_utils_timer_create_all_timers>:
void
am_app_utils_timer_create_all_timers(am_app_utils_timer_setup_t *setup_array, TimerHandle_t* pTimerList, uint32_t setupLen)
{
    uint8_t timer = 0;

	for(timer = 0; timer<setupLen; timer++)
    fc4c:	b1fa      	cbz	r2, fc8e <am_app_utils_timer_create_all_timers+0x42>
{
    fc4e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	for(timer = 0; timer<setupLen; timer++)
    fc52:	2400      	movs	r4, #0
{
    fc54:	b083      	sub	sp, #12
    fc56:	4690      	mov	r8, r2
    fc58:	4689      	mov	r9, r1
    fc5a:	4607      	mov	r7, r0
	for(timer = 0; timer<setupLen; timer++)
    fc5c:	4623      	mov	r3, r4
	{
		// Spawn all timers
		am_app_utils_timer_create(setup_array[timer], pTimerList);
    fc5e:	eb03 0583 	add.w	r5, r3, r3, lsl #2
    fc62:	eb07 0685 	add.w	r6, r7, r5, lsl #2
    pTimerList[setup.indx] = xTimerCreate(setup.pcTimerName, setup.xTimerPeriodInTicks, 
    fc66:	e9d6 1202 	ldrd	r1, r2, [r6, #8]
    fc6a:	6870      	ldr	r0, [r6, #4]
    fc6c:	6936      	ldr	r6, [r6, #16]
    fc6e:	9600      	str	r6, [sp, #0]
    fc70:	2300      	movs	r3, #0
    fc72:	f857 5025 	ldr.w	r5, [r7, r5, lsl #2]
	for(timer = 0; timer<setupLen; timer++)
    fc76:	3401      	adds	r4, #1
    pTimerList[setup.indx] = xTimerCreate(setup.pcTimerName, setup.xTimerPeriodInTicks, 
    fc78:	f7fd fff2 	bl	dc60 <xTimerCreate>
	for(timer = 0; timer<setupLen; timer++)
    fc7c:	b2e4      	uxtb	r4, r4
    fc7e:	4544      	cmp	r4, r8
    pTimerList[setup.indx] = xTimerCreate(setup.pcTimerName, setup.xTimerPeriodInTicks, 
    fc80:	f849 0025 	str.w	r0, [r9, r5, lsl #2]
	for(timer = 0; timer<setupLen; timer++)
    fc84:	4623      	mov	r3, r4
    fc86:	d3ea      	bcc.n	fc5e <am_app_utils_timer_create_all_timers+0x12>
	}

}
    fc88:	b003      	add	sp, #12
    fc8a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    fc8e:	4770      	bx	lr

0000fc90 <am_app_utils_task_send>:
//
//*****************************************************************************
bool
am_app_utils_task_send(am_app_utils_task_t* pTaskList, const uint32_t SourceIndx, const uint32_t DestIndx, uint32_t ui32MessageType, 
                    uint32_t ui32Info, am_app_utils_ring_buffer_t *pData)
{
    fc90:	b510      	push	{r4, lr}
    fc92:	b084      	sub	sp, #16
		BaseType_t retval = pdFAIL;
		am_app_utils_task_queue_element_t Element;
		Element.Source = SourceIndx;
        
        configASSERT(ui32MessageType < AM_APP_MESSAGE_MAX);
    fc94:	2b03      	cmp	r3, #3
		Element.Source = SourceIndx;
    fc96:	9100      	str	r1, [sp, #0]
{
    fc98:	e9dd 1406 	ldrd	r1, r4, [sp, #24]
        configASSERT(ui32MessageType < AM_APP_MESSAGE_MAX);
    fc9c:	d815      	bhi.n	fcca <am_app_utils_task_send+0x3a>
		Element.ui32MessageType = ui32MessageType;
		switch(Element.ui32MessageType)
    fc9e:	2b02      	cmp	r3, #2
		Element.ui32MessageType = ui32MessageType;
    fca0:	9301      	str	r3, [sp, #4]
		switch(Element.ui32MessageType)
    fca2:	d013      	beq.n	fccc <am_app_utils_task_send+0x3c>
    fca4:	2b03      	cmp	r3, #3
    fca6:	d011      	beq.n	fccc <am_app_utils_task_send+0x3c>
    fca8:	2b01      	cmp	r3, #1
    fcaa:	d00f      	beq.n	fccc <am_app_utils_task_send+0x3c>
                break;
            default:
                break;
        }
        Element.pDataBuffer = pData;
		if(pTaskList[DestIndx].queue != NULL)
    fcac:	eb00 00c2 	add.w	r0, r0, r2, lsl #3
        Element.pDataBuffer = pData;
    fcb0:	9403      	str	r4, [sp, #12]
		if(pTaskList[DestIndx].queue != NULL)
    fcb2:	6840      	ldr	r0, [r0, #4]
    fcb4:	b120      	cbz	r0, fcc0 <am_app_utils_task_send+0x30>
		{
			retval = xQueueSendToBack(pTaskList[DestIndx].queue, &Element, 0 );
    fcb6:	2300      	movs	r3, #0
    fcb8:	461a      	mov	r2, r3
    fcba:	4669      	mov	r1, sp
    fcbc:	f7fc fbbc 	bl	c438 <xQueueGenericSend>
		}
		
		return (retval != pdFAIL);
}
    fcc0:	3000      	adds	r0, #0
    fcc2:	bf18      	it	ne
    fcc4:	2001      	movne	r0, #1
    fcc6:	b004      	add	sp, #16
    fcc8:	bd10      	pop	{r4, pc}
    fcca:	e7fe      	b.n	fcca <am_app_utils_task_send+0x3a>
                Element.info.ui32Indx = ui32Info;
    fccc:	9102      	str	r1, [sp, #8]
                break;
    fcce:	e7ed      	b.n	fcac <am_app_utils_task_send+0x1c>

0000fcd0 <am_app_utils_task_send_fromISR>:
//
//*****************************************************************************
bool
am_app_utils_task_send_fromISR(am_app_utils_task_t* pTaskList, const uint32_t SourceIndx, const uint32_t DestIndx, uint32_t ui32MessageType, 
                           uint32_t ui32Info, am_app_utils_ring_buffer_t *pData)
{
    fcd0:	b510      	push	{r4, lr}
    fcd2:	b086      	sub	sp, #24
		BaseType_t retval = pdFAIL;
		am_app_utils_task_queue_element_t Element;
		BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    fcd4:	2400      	movs	r4, #0
		
        Element.Source = SourceIndx;
		Element.ui32MessageType = ui32MessageType;
		switch(Element.ui32MessageType)
    fcd6:	2b02      	cmp	r3, #2
        Element.Source = SourceIndx;
    fcd8:	e9cd 1302 	strd	r1, r3, [sp, #8]
		BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    fcdc:	9401      	str	r4, [sp, #4]
{
    fcde:	9909      	ldr	r1, [sp, #36]	; 0x24
		switch(Element.ui32MessageType)
    fce0:	d020      	beq.n	fd24 <am_app_utils_task_send_fromISR+0x54>
    fce2:	2b03      	cmp	r3, #3
    fce4:	d01e      	beq.n	fd24 <am_app_utils_task_send_fromISR+0x54>
    fce6:	2b01      	cmp	r3, #1
    fce8:	d01c      	beq.n	fd24 <am_app_utils_task_send_fromISR+0x54>
            default:
                break;
        }
        Element.pDataBuffer = pData;

		if(pTaskList[DestIndx].queue != NULL)
    fcea:	eb00 00c2 	add.w	r0, r0, r2, lsl #3
        Element.pDataBuffer = pData;
    fcee:	9105      	str	r1, [sp, #20]
		if(pTaskList[DestIndx].queue != NULL)
    fcf0:	6840      	ldr	r0, [r0, #4]
    fcf2:	b1f8      	cbz	r0, fd34 <am_app_utils_task_send_fromISR+0x64>
		{
			retval = xQueueSendFromISR(pTaskList[DestIndx].queue , &Element, &xHigherPriorityTaskWoken );
    fcf4:	2300      	movs	r3, #0
    fcf6:	aa01      	add	r2, sp, #4
    fcf8:	a902      	add	r1, sp, #8
    fcfa:	f7fc fd4b 	bl	c794 <xQueueGenericSendFromISR>
		}

    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    fcfe:	9b01      	ldr	r3, [sp, #4]
			retval = xQueueSendFromISR(pTaskList[DestIndx].queue , &Element, &xHigherPriorityTaskWoken );
    fd00:	4604      	mov	r4, r0
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    fd02:	b1eb      	cbz	r3, fd40 <am_app_utils_task_send_fromISR+0x70>
    fd04:	f000 ff0c 	bl	10b20 <SEGGER_SYSVIEW_RecordExitISRToScheduler>
    fd08:	4b0f      	ldr	r3, [pc, #60]	; (fd48 <am_app_utils_task_send_fromISR+0x78>)
    fd0a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    fd0e:	601a      	str	r2, [r3, #0]
    fd10:	f3bf 8f4f 	dsb	sy
    fd14:	f3bf 8f6f 	isb	sy
    fd18:	3400      	adds	r4, #0
    fd1a:	bf18      	it	ne
    fd1c:	2401      	movne	r4, #1
    
    return (retval != pdFAIL);
}
    fd1e:	4620      	mov	r0, r4
    fd20:	b006      	add	sp, #24
    fd22:	bd10      	pop	{r4, pc}
		if(pTaskList[DestIndx].queue != NULL)
    fd24:	eb00 00c2 	add.w	r0, r0, r2, lsl #3
                Element.info.ui32Indx = ui32Info;
    fd28:	9b08      	ldr	r3, [sp, #32]
		if(pTaskList[DestIndx].queue != NULL)
    fd2a:	6840      	ldr	r0, [r0, #4]
                Element.info.ui32Indx = ui32Info;
    fd2c:	9304      	str	r3, [sp, #16]
        Element.pDataBuffer = pData;
    fd2e:	9105      	str	r1, [sp, #20]
		if(pTaskList[DestIndx].queue != NULL)
    fd30:	2800      	cmp	r0, #0
    fd32:	d1df      	bne.n	fcf4 <am_app_utils_task_send_fromISR+0x24>
    fd34:	4604      	mov	r4, r0
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    fd36:	f000 fddf 	bl	108f8 <SEGGER_SYSVIEW_RecordExitISR>
}
    fd3a:	4620      	mov	r0, r4
    fd3c:	b006      	add	sp, #24
    fd3e:	bd10      	pop	{r4, pc}
    fd40:	1c04      	adds	r4, r0, #0
    fd42:	bf18      	it	ne
    fd44:	2401      	movne	r4, #1
    fd46:	e7f6      	b.n	fd36 <am_app_utils_task_send_fromISR+0x66>
    fd48:	e000ed04 	.word	0xe000ed04

0000fd4c <am_app_utils_task_read>:
//*****************************************************************************
bool
am_app_utils_task_read(am_app_utils_task_t* pTaskList, const uint32_t indx, am_app_utils_task_queue_element_t *Element)
{
		BaseType_t retval = pdFAIL;
		if(pTaskList[indx].queue != NULL)
    fd4c:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
    fd50:	6848      	ldr	r0, [r1, #4]
    fd52:	b150      	cbz	r0, fd6a <am_app_utils_task_read+0x1e>
{
    fd54:	b508      	push	{r3, lr}
    fd56:	4611      	mov	r1, r2
		{
			retval = xQueueReceive(pTaskList[indx].queue, Element, portMAX_DELAY );
    fd58:	2300      	movs	r3, #0
    fd5a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    fd5e:	f7fc fdab 	bl	c8b8 <xQueueGenericReceive>
    fd62:	3000      	adds	r0, #0
    fd64:	bf18      	it	ne
    fd66:	2001      	movne	r0, #1
		}
    
		return retval; 
}
    fd68:	bd08      	pop	{r3, pc}
    fd6a:	4770      	bx	lr

0000fd6c <am_devices_led_array_init>:
void
am_devices_led_array_init(am_devices_led_t *psLEDs, uint32_t ui32NumLEDs)
{
    uint32_t i;

    if ( (psLEDs == NULL)                       ||
    fd6c:	b360      	cbz	r0, fdc8 <am_devices_led_array_init+0x5c>
    }

    //
    // Loop through the list of LEDs, configuring each one individually.
    //
    for ( i = 0; i < ui32NumLEDs; i++ )
    fd6e:	1e4b      	subs	r3, r1, #1
    fd70:	2b1e      	cmp	r3, #30
    fd72:	d829      	bhi.n	fdc8 <am_devices_led_array_init+0x5c>
{
    fd74:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_TRISTATE);
    fd78:	4f14      	ldr	r7, [pc, #80]	; (fdcc <am_devices_led_array_init+0x60>)
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_OUTPUT);
    fd7a:	f8df 8054 	ldr.w	r8, [pc, #84]	; fdd0 <am_devices_led_array_init+0x64>
    fd7e:	4604      	mov	r4, r0
    fd80:	eb00 06c1 	add.w	r6, r0, r1, lsl #3
    fd84:	1d05      	adds	r5, r0, #4
    if ( (psLED == NULL)    ||
    fd86:	b1c4      	cbz	r4, fdba <am_devices_led_array_init+0x4e>
         (psLED->ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    fd88:	f855 3c04 	ldr.w	r3, [r5, #-4]
    if ( (psLED == NULL)    ||
    fd8c:	2b31      	cmp	r3, #49	; 0x31
    fd8e:	d814      	bhi.n	fdba <am_devices_led_array_init+0x4e>
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLED->ui32Polarity )
    fd90:	6862      	ldr	r2, [r4, #4]
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_TRISTATE);
    fd92:	4618      	mov	r0, r3
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLED->ui32Polarity )
    fd94:	0793      	lsls	r3, r2, #30
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_OUTPUT);
    fd96:	bf4c      	ite	mi
    fd98:	f8d8 1000 	ldrmi.w	r1, [r8]
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_TRISTATE);
    fd9c:	6839      	ldrpl	r1, [r7, #0]
    fd9e:	f7fe fc6f 	bl	e680 <am_hal_gpio_pinconfig>
        am_hal_gpio_state_write(psLED->ui32GPIONumber, AM_HAL_GPIO_OUTPUT_TRISTATE_DISABLE);
    fda2:	2103      	movs	r1, #3
    fda4:	f855 0c04 	ldr.w	r0, [r5, #-4]
    fda8:	f7fe fde4 	bl	e974 <am_hal_gpio_state_write>
                                AM_HAL_GPIO_OUTPUT_SET : AM_HAL_GPIO_OUTPUT_CLEAR);
    fdac:	6861      	ldr	r1, [r4, #4]
        am_hal_gpio_state_write(psLED->ui32GPIONumber,
    fdae:	f855 0c04 	ldr.w	r0, [r5, #-4]
    fdb2:	f001 0101 	and.w	r1, r1, #1
    fdb6:	f7fe fddd 	bl	e974 <am_hal_gpio_state_write>
    fdba:	3408      	adds	r4, #8
    for ( i = 0; i < ui32NumLEDs; i++ )
    fdbc:	42b4      	cmp	r4, r6
    fdbe:	f105 0508 	add.w	r5, r5, #8
    fdc2:	d1e0      	bne.n	fd86 <am_devices_led_array_init+0x1a>
    {
        am_devices_led_init(psLEDs + i);
    }
}
    fdc4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    fdc8:	4770      	bx	lr
    fdca:	bf00      	nop
    fdcc:	00013808 	.word	0x00013808
    fdd0:	00013804 	.word	0x00013804

0000fdd4 <am_devices_led_on>:
//
//*****************************************************************************
void
am_devices_led_on(am_devices_led_t *psLEDs, uint32_t ui32LEDNum)
{
    if ( (psLEDs == NULL)                       ||
    fdd4:	b170      	cbz	r0, fdf4 <am_devices_led_on+0x20>
    fdd6:	291e      	cmp	r1, #30
    fdd8:	d80c      	bhi.n	fdf4 <am_devices_led_on+0x20>
         (ui32LEDNum >= MAX_LEDS)               ||
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    fdda:	f850 3031 	ldr.w	r3, [r0, r1, lsl #3]
         (ui32LEDNum >= MAX_LEDS)               ||
    fdde:	2b31      	cmp	r3, #49	; 0x31
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    fde0:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
         (ui32LEDNum >= MAX_LEDS)               ||
    fde4:	d806      	bhi.n	fdf4 <am_devices_led_on+0x20>

#if AM_APOLLO3_GPIO
    //
    // Handle Direct Drive Versus 3-State (with pull-up or no buffer).
    //
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    fde6:	6849      	ldr	r1, [r1, #4]
    fde8:	078a      	lsls	r2, r1, #30
    fdea:	d404      	bmi.n	fdf6 <am_devices_led_on+0x22>
    else
    {
        //
        // Turn on the output driver for the LED.
        //
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    fdec:	4618      	mov	r0, r3
    fdee:	2104      	movs	r1, #4
    fdf0:	f7fe bdc0 	b.w	e974 <am_hal_gpio_state_write>
        // Turn on the output driver for the LED.
        //
        am_hal_gpio_out_enable_bit_set(psLEDs[ui32LEDNum].ui32GPIONumber);
    }
#endif // AM_APOLLO3_GPIO
}
    fdf4:	4770      	bx	lr
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    fdf6:	f001 0101 	and.w	r1, r1, #1
    fdfa:	4618      	mov	r0, r3
    fdfc:	f7fe bdba 	b.w	e974 <am_hal_gpio_state_write>

0000fe00 <am_devices_led_off>:
//
//*****************************************************************************
void
am_devices_led_off(am_devices_led_t *psLEDs, uint32_t ui32LEDNum)
{
    if ( (psLEDs == NULL)                       ||
    fe00:	b170      	cbz	r0, fe20 <am_devices_led_off+0x20>
    fe02:	291e      	cmp	r1, #30
    fe04:	d80c      	bhi.n	fe20 <am_devices_led_off+0x20>
         (ui32LEDNum >= MAX_LEDS)               ||
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    fe06:	f850 3031 	ldr.w	r3, [r0, r1, lsl #3]
         (ui32LEDNum >= MAX_LEDS)               ||
    fe0a:	2b31      	cmp	r3, #49	; 0x31
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    fe0c:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
         (ui32LEDNum >= MAX_LEDS)               ||
    fe10:	d806      	bhi.n	fe20 <am_devices_led_off+0x20>

#if AM_APOLLO3_GPIO
    //
    // Handle Direct Drive Versus 3-State (with pull-up or no buffer).
    //
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    fe12:	6849      	ldr	r1, [r1, #4]
    fe14:	078a      	lsls	r2, r1, #30
    fe16:	d404      	bmi.n	fe22 <am_devices_led_off+0x22>
    else
    {
        //
        // Turn off the output driver for the LED.
        //
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    fe18:	4618      	mov	r0, r3
    fe1a:	2103      	movs	r1, #3
    fe1c:	f7fe bdaa 	b.w	e974 <am_hal_gpio_state_write>
        // Turn off the output driver for the LED.
        //
        am_hal_gpio_out_enable_bit_clear(psLEDs[ui32LEDNum].ui32GPIONumber);
    }
#endif // AM_APOLLO3_GPIO
}
    fe20:	4770      	bx	lr
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    fe22:	43c9      	mvns	r1, r1
    fe24:	f001 0101 	and.w	r1, r1, #1
    fe28:	4618      	mov	r0, r3
    fe2a:	f7fe bda3 	b.w	e974 <am_hal_gpio_state_write>
    fe2e:	bf00      	nop

0000fe30 <am_devices_led_toggle>:
//
//*****************************************************************************
void
am_devices_led_toggle(am_devices_led_t *psLEDs, uint32_t ui32LEDNum)
{
    if ( (psLEDs == NULL)                       ||
    fe30:	b1e0      	cbz	r0, fe6c <am_devices_led_toggle+0x3c>
    fe32:	291e      	cmp	r1, #30
    fe34:	d81a      	bhi.n	fe6c <am_devices_led_toggle+0x3c>
         (ui32LEDNum >= MAX_LEDS)               ||
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    fe36:	f850 3031 	ldr.w	r3, [r0, r1, lsl #3]
         (ui32LEDNum >= MAX_LEDS)               ||
    fe3a:	2b31      	cmp	r3, #49	; 0x31
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    fe3c:	eb00 02c1 	add.w	r2, r0, r1, lsl #3
         (ui32LEDNum >= MAX_LEDS)               ||
    fe40:	d814      	bhi.n	fe6c <am_devices_led_toggle+0x3c>
{
    fe42:	b530      	push	{r4, r5, lr}

#if AM_APOLLO3_GPIO
    //
    // Handle Direct Drive Versus 3-State (with pull-up or no buffer).
    //
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    fe44:	6852      	ldr	r2, [r2, #4]
    fe46:	4604      	mov	r4, r0
    {
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    fe48:	4618      	mov	r0, r3
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    fe4a:	0793      	lsls	r3, r2, #30
{
    fe4c:	b083      	sub	sp, #12
    fe4e:	460d      	mov	r5, r1
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    fe50:	d40d      	bmi.n	fe6e <am_devices_led_toggle+0x3e>
        uint32_t ui32Ret, ui32Value;

        //
        // Check to see if the LED pin is enabled.
        //
        ui32Ret = am_hal_gpio_state_read(psLEDs[ui32LEDNum].ui32GPIONumber,
    fe52:	aa01      	add	r2, sp, #4
    fe54:	2102      	movs	r1, #2
    fe56:	f7fe fd55 	bl	e904 <am_hal_gpio_state_read>
                                         AM_HAL_GPIO_ENABLE_READ, &ui32Value);

        if ( ui32Ret == AM_HAL_STATUS_SUCCESS )
    fe5a:	b958      	cbnz	r0, fe74 <am_devices_led_toggle+0x44>
        {
            if ( ui32Value )
    fe5c:	9b01      	ldr	r3, [sp, #4]
    fe5e:	f854 0035 	ldr.w	r0, [r4, r5, lsl #3]
    fe62:	b14b      	cbz	r3, fe78 <am_devices_led_toggle+0x48>
            {
                //
                // If it was enabled, turn if off.
                //
                am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    fe64:	2103      	movs	r1, #3
    fe66:	f7fe fd85 	bl	e974 <am_hal_gpio_state_write>
    fe6a:	e003      	b.n	fe74 <am_devices_led_toggle+0x44>
    fe6c:	4770      	bx	lr
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    fe6e:	2102      	movs	r1, #2
    fe70:	f7fe fd80 	bl	e974 <am_hal_gpio_state_write>
            //
            am_hal_gpio_out_enable_bit_set(psLEDs[ui32LEDNum].ui32GPIONumber);
        }
    }
#endif // AM_APOLLO3_GPIO
}
    fe74:	b003      	add	sp, #12
    fe76:	bd30      	pop	{r4, r5, pc}
                am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    fe78:	2104      	movs	r1, #4
    fe7a:	f7fe fd7b 	bl	e974 <am_hal_gpio_state_write>
    fe7e:	e7f9      	b.n	fe74 <am_devices_led_toggle+0x44>

0000fe80 <SEGGER_RTT_ReadNoLock>:
*    BufferSize   Size of the target application buffer.
*
*  Return value
*    Number of bytes that have been read.
*/
unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
    fe80:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  SEGGER_RTT_BUFFER_DOWN* pRing;
#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
  const char*             pSrc;
#endif
  //
  INIT();
    fe84:	4c38      	ldr	r4, [pc, #224]	; (ff68 <SEGGER_RTT_ReadNoLock+0xe8>)
    fe86:	7825      	ldrb	r5, [r4, #0]
unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
    fe88:	4681      	mov	r9, r0
    fe8a:	460b      	mov	r3, r1
    fe8c:	4692      	mov	sl, r2
  INIT();
    fe8e:	2d00      	cmp	r5, #0
    fe90:	d048      	beq.n	ff24 <SEGGER_RTT_ReadNoLock+0xa4>
  pRing = &_SEGGER_RTT.aDown[BufferIndex];
  pBuffer = (unsigned char*)pData;
  RdOff = pRing->RdOff;
    fe92:	ea4f 0849 	mov.w	r8, r9, lsl #1
    fe96:	eb08 0709 	add.w	r7, r8, r9
    fe9a:	eb04 07c7 	add.w	r7, r4, r7, lsl #3
    fe9e:	6f3e      	ldr	r6, [r7, #112]	; 0x70
  WrOff = pRing->WrOff;
    fea0:	f8d7 b06c 	ldr.w	fp, [r7, #108]	; 0x6c
  NumBytesRead = 0u;
  //
  // Read from current read position to wrap-around of buffer, first
  //
  if (RdOff > WrOff) {
    fea4:	455e      	cmp	r6, fp
    fea6:	d81e      	bhi.n	fee6 <SEGGER_RTT_ReadNoLock+0x66>
    }
  }
  //
  // Read remaining items of buffer
  //
  NumBytesRem = WrOff - RdOff;
    fea8:	ebab 0506 	sub.w	r5, fp, r6
  NumBytesRem = MIN(NumBytesRem, BufferSize);
    feac:	4555      	cmp	r5, sl
    feae:	bf28      	it	cs
    feb0:	4655      	movcs	r5, sl
  if (NumBytesRem > 0u) {
    feb2:	b915      	cbnz	r5, feba <SEGGER_RTT_ReadNoLock+0x3a>
  if (NumBytesRead) {
    pRing->RdOff = RdOff;
  }
  //
  return NumBytesRead;
}
    feb4:	4628      	mov	r0, r5
    feb6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  NumBytesRead = 0u;
    feba:	2700      	movs	r7, #0
    SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
    febc:	eb08 0209 	add.w	r2, r8, r9
    fec0:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
    fec4:	4618      	mov	r0, r3
    fec6:	6e51      	ldr	r1, [r2, #100]	; 0x64
    fec8:	462a      	mov	r2, r5
    feca:	4431      	add	r1, r6
    fecc:	f7fc f918 	bl	c100 <memcpy>
    RdOff        += NumBytesRem;
    fed0:	442e      	add	r6, r5
    NumBytesRead += NumBytesRem;
    fed2:	443d      	add	r5, r7
  if (NumBytesRead) {
    fed4:	2d00      	cmp	r5, #0
    fed6:	d0ed      	beq.n	feb4 <SEGGER_RTT_ReadNoLock+0x34>
    pRing->RdOff = RdOff;
    fed8:	44c8      	add	r8, r9
    feda:	eb04 04c8 	add.w	r4, r4, r8, lsl #3
}
    fede:	4628      	mov	r0, r5
    pRing->RdOff = RdOff;
    fee0:	6726      	str	r6, [r4, #112]	; 0x70
}
    fee2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
    fee6:	e9d7 1519 	ldrd	r1, r5, [r7, #100]	; 0x64
    NumBytesRem = pRing->SizeOfBuffer - RdOff;
    feea:	1bad      	subs	r5, r5, r6
    NumBytesRem = MIN(NumBytesRem, BufferSize);
    feec:	4555      	cmp	r5, sl
    feee:	bf28      	it	cs
    fef0:	4655      	movcs	r5, sl
    SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
    fef2:	462a      	mov	r2, r5
    fef4:	4431      	add	r1, r6
    fef6:	4618      	mov	r0, r3
    fef8:	f7fc f902 	bl	c100 <memcpy>
    if (RdOff == pRing->SizeOfBuffer) {
    fefc:	6eba      	ldr	r2, [r7, #104]	; 0x68
    RdOff        += NumBytesRem;
    fefe:	442e      	add	r6, r5
    if (RdOff == pRing->SizeOfBuffer) {
    ff00:	42b2      	cmp	r2, r6
    BufferSize   -= NumBytesRem;
    ff02:	ebaa 0a05 	sub.w	sl, sl, r5
    ff06:	bf14      	ite	ne
    ff08:	ebab 0b06 	subne.w	fp, fp, r6
      RdOff = 0u;
    ff0c:	2600      	moveq	r6, #0
  NumBytesRem = MIN(NumBytesRem, BufferSize);
    ff0e:	45d3      	cmp	fp, sl
    ff10:	bf28      	it	cs
    ff12:	46d3      	movcs	fp, sl
    SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
    ff14:	4603      	mov	r3, r0
  if (NumBytesRem > 0u) {
    ff16:	f1bb 0f00 	cmp.w	fp, #0
    ff1a:	d0db      	beq.n	fed4 <SEGGER_RTT_ReadNoLock+0x54>
    pBuffer      += NumBytesRem;
    ff1c:	442b      	add	r3, r5
    ff1e:	462f      	mov	r7, r5
    ff20:	465d      	mov	r5, fp
    ff22:	e7cb      	b.n	febc <SEGGER_RTT_ReadNoLock+0x3c>
  strcpy(&p->acID[7], "RTT");
    ff24:	4911      	ldr	r1, [pc, #68]	; (ff6c <SEGGER_RTT_ReadNoLock+0xec>)
  strcpy(&p->acID[0], "SEGGER");
    ff26:	4a12      	ldr	r2, [pc, #72]	; (ff70 <SEGGER_RTT_ReadNoLock+0xf0>)
  strcpy(&p->acID[7], "RTT");
    ff28:	6808      	ldr	r0, [r1, #0]
    ff2a:	f8c4 0007 	str.w	r0, [r4, #7]
  strcpy(&p->acID[0], "SEGGER");
    ff2e:	e892 0003 	ldmia.w	r2, {r0, r1}
  p->aUp[0].RdOff         = 0u;
    ff32:	62a5      	str	r5, [r4, #40]	; 0x28
  p->aUp[0].sName         = "Terminal";
    ff34:	4a0f      	ldr	r2, [pc, #60]	; (ff74 <SEGGER_RTT_ReadNoLock+0xf4>)
  p->aUp[0].WrOff         = 0u;
    ff36:	6265      	str	r5, [r4, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    ff38:	62e5      	str	r5, [r4, #44]	; 0x2c
  p->aDown[0].RdOff         = 0u;
    ff3a:	6725      	str	r5, [r4, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
    ff3c:	66e5      	str	r5, [r4, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    ff3e:	6765      	str	r5, [r4, #116]	; 0x74
  strcpy(&p->acID[0], "SEGGER");
    ff40:	6020      	str	r0, [r4, #0]
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
    ff42:	2503      	movs	r5, #3
  strcpy(&p->acID[0], "SEGGER");
    ff44:	80a1      	strh	r1, [r4, #4]
  p->aDown[0].pBuffer       = _acDownBuffer;
    ff46:	480c      	ldr	r0, [pc, #48]	; (ff78 <SEGGER_RTT_ReadNoLock+0xf8>)
  p->aUp[0].pBuffer       = _acUpBuffer;
    ff48:	490c      	ldr	r1, [pc, #48]	; (ff7c <SEGGER_RTT_ReadNoLock+0xfc>)
  p->aUp[0].sName         = "Terminal";
    ff4a:	61a2      	str	r2, [r4, #24]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
    ff4c:	e9c4 5504 	strd	r5, r5, [r4, #16]
  p->aDown[0].sName         = "Terminal";
    ff50:	6622      	str	r2, [r4, #96]	; 0x60
  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
    ff52:	f44f 6580 	mov.w	r5, #1024	; 0x400
  p->aUp[0].pBuffer       = _acUpBuffer;
    ff56:	61e1      	str	r1, [r4, #28]
  p->acID[6] = ' ';
    ff58:	2220      	movs	r2, #32
  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
    ff5a:	2110      	movs	r1, #16
  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
    ff5c:	6225      	str	r5, [r4, #32]
  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
    ff5e:	e9c4 0119 	strd	r0, r1, [r4, #100]	; 0x64
  p->acID[6] = ' ';
    ff62:	71a2      	strb	r2, [r4, #6]
    ff64:	e795      	b.n	fe92 <SEGGER_RTT_ReadNoLock+0x12>
    ff66:	bf00      	nop
    ff68:	1001341c 	.word	0x1001341c
    ff6c:	00013988 	.word	0x00013988
    ff70:	0001398c 	.word	0x0001398c
    ff74:	0001397c 	.word	0x0001397c
    ff78:	10012e2c 	.word	0x10012e2c
    ff7c:	10012e3c 	.word	0x10012e3c

0000ff80 <SEGGER_RTT_WriteSkipNoLock>:
*    (1) If there is not enough space in the "Up"-buffer, all data is dropped.
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    ff80:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  pData = (const char *)pBuffer;
  //
  // Get "to-host" ring buffer and copy some elements into local variables.
  //
  pRing = &_SEGGER_RTT.aUp[BufferIndex];
  RdOff = pRing->RdOff;
    ff84:	f8df 9090 	ldr.w	r9, [pc, #144]	; 10018 <SEGGER_RTT_WriteSkipNoLock+0x98>
    ff88:	eb00 0440 	add.w	r4, r0, r0, lsl #1
    ff8c:	eb09 04c4 	add.w	r4, r9, r4, lsl #3
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    ff90:	4616      	mov	r6, r2
  RdOff = pRing->RdOff;
    ff92:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  WrOff = pRing->WrOff;
    ff94:	6a65      	ldr	r5, [r4, #36]	; 0x24
  //
  //    RdOff > WrOff -> Space until RdOff - 1 is free.
  //  AND
  //    WrOff + NumBytes < RdOff -> Data fits into buffer
  //
  if (RdOff <= WrOff) {
    ff96:	42ab      	cmp	r3, r5
    ff98:	d821      	bhi.n	ffde <SEGGER_RTT_WriteSkipNoLock+0x5e>
    //
    // Get space until WrOff will be at wrap around.
    //
    Avail = pRing->SizeOfBuffer - 1u - WrOff ;
    ff9a:	6a27      	ldr	r7, [r4, #32]
    ff9c:	1b7f      	subs	r7, r7, r5
    ff9e:	f107 3eff 	add.w	lr, r7, #4294967295	; 0xffffffff
    if (Avail >= NumBytes) {
    ffa2:	4572      	cmp	r2, lr
    ffa4:	d930      	bls.n	10008 <SEGGER_RTT_WriteSkipNoLock+0x88>
      return 1;
    }
    //
    // If data did not fit into space until wrap around calculate complete space in buffer.
    //
    Avail += RdOff;
    ffa6:	4473      	add	r3, lr
    //
    // If there is still no space for the whole of this output, don't bother.
    //
    if (Avail >= NumBytes) {
    ffa8:	429a      	cmp	r2, r3
    ffaa:	d81c      	bhi.n	ffe6 <SEGGER_RTT_WriteSkipNoLock+0x66>
    ffac:	3001      	adds	r0, #1
    ffae:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    ffb2:	eb09 09c0 	add.w	r9, r9, r0, lsl #3
      //
      //  OK, we have enough space in buffer. Copy in one or 2 chunks
      //
      Rem = pRing->SizeOfBuffer - WrOff;      // Space until end of buffer
      if (Rem > NumBytes) {
    ffb6:	4297      	cmp	r7, r2
    ffb8:	f8d9 0004 	ldr.w	r0, [r9, #4]
    ffbc:	4428      	add	r0, r5
    ffbe:	d81c      	bhi.n	fffa <SEGGER_RTT_WriteSkipNoLock+0x7a>
          *pDst++ = *pData++;
        };
        pRing->WrOff = WrOff;
#else
        SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, Rem);
        SEGGER_RTT_MEMCPY(pRing->pBuffer, pData + Rem, NumBytes - Rem);
    ffc0:	1bd6      	subs	r6, r2, r7
    ffc2:	4688      	mov	r8, r1
        SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, Rem);
    ffc4:	463a      	mov	r2, r7
    ffc6:	f7fc f89b 	bl	c100 <memcpy>
        SEGGER_RTT_MEMCPY(pRing->pBuffer, pData + Rem, NumBytes - Rem);
    ffca:	eb08 0107 	add.w	r1, r8, r7
    ffce:	f8d9 0004 	ldr.w	r0, [r9, #4]
    ffd2:	4632      	mov	r2, r6
    ffd4:	f7fc f894 	bl	c100 <memcpy>
        pRing->WrOff = NumBytes - Rem;
    ffd8:	6266      	str	r6, [r4, #36]	; 0x24
#endif
      }
      return 1;
    ffda:	2001      	movs	r0, #1
    ffdc:	e004      	b.n	ffe8 <SEGGER_RTT_WriteSkipNoLock+0x68>
    }
  } else {
    Avail = RdOff - WrOff - 1u;
    ffde:	3b01      	subs	r3, #1
    ffe0:	1b5b      	subs	r3, r3, r5
    if (Avail >= NumBytes) {
    ffe2:	4293      	cmp	r3, r2
    ffe4:	d202      	bcs.n	ffec <SEGGER_RTT_WriteSkipNoLock+0x6c>
    }
  }
  //
  // If we reach this point no data has been written
  //
  return 0;
    ffe6:	2000      	movs	r0, #0
}
    ffe8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytes);
    ffec:	3001      	adds	r0, #1
    ffee:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    fff2:	eb09 00c0 	add.w	r0, r9, r0, lsl #3
    fff6:	6840      	ldr	r0, [r0, #4]
    fff8:	4428      	add	r0, r5
      pRing->WrOff = WrOff + NumBytes;
    fffa:	4435      	add	r5, r6
      SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytes);
    fffc:	f7fc f880 	bl	c100 <memcpy>
      pRing->WrOff = WrOff + NumBytes;
   10000:	6265      	str	r5, [r4, #36]	; 0x24
      return 1;
   10002:	2001      	movs	r0, #1
}
   10004:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytes);
   10008:	3001      	adds	r0, #1
   1000a:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   1000e:	eb09 0cc0 	add.w	ip, r9, r0, lsl #3
   10012:	f8dc 0004 	ldr.w	r0, [ip, #4]
   10016:	e7ef      	b.n	fff8 <SEGGER_RTT_WriteSkipNoLock+0x78>
   10018:	1001341c 	.word	0x1001341c

0001001c <SEGGER_RTT_Write>:
*    Number of bytes which have been stored in the "Up"-buffer.
*
*  Notes
*    (1) Data is stored according to buffer flags.
*/
unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   1001c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  unsigned Status;
  //
  INIT();
   10020:	4c75      	ldr	r4, [pc, #468]	; (101f8 <SEGGER_RTT_Write+0x1dc>)
   10022:	7825      	ldrb	r5, [r4, #0]
unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   10024:	b083      	sub	sp, #12
   10026:	4606      	mov	r6, r0
   10028:	460f      	mov	r7, r1
   1002a:	4691      	mov	r9, r2
  INIT();
   1002c:	b9fd      	cbnz	r5, 1006e <SEGGER_RTT_Write+0x52>
  strcpy(&p->acID[7], "RTT");
   1002e:	4973      	ldr	r1, [pc, #460]	; (101fc <SEGGER_RTT_Write+0x1e0>)
  strcpy(&p->acID[0], "SEGGER");
   10030:	4a73      	ldr	r2, [pc, #460]	; (10200 <SEGGER_RTT_Write+0x1e4>)
  strcpy(&p->acID[7], "RTT");
   10032:	6808      	ldr	r0, [r1, #0]
   10034:	f8c4 0007 	str.w	r0, [r4, #7]
  strcpy(&p->acID[0], "SEGGER");
   10038:	e892 0003 	ldmia.w	r2, {r0, r1}
   1003c:	6020      	str	r0, [r4, #0]
   1003e:	80a1      	strh	r1, [r4, #4]
  p->aDown[0].pBuffer       = _acDownBuffer;
   10040:	4870      	ldr	r0, [pc, #448]	; (10204 <SEGGER_RTT_Write+0x1e8>)
  p->aUp[0].pBuffer       = _acUpBuffer;
   10042:	4971      	ldr	r1, [pc, #452]	; (10208 <SEGGER_RTT_Write+0x1ec>)
   10044:	61e1      	str	r1, [r4, #28]
  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
   10046:	2110      	movs	r1, #16
  p->aUp[0].sName         = "Terminal";
   10048:	4a70      	ldr	r2, [pc, #448]	; (1020c <SEGGER_RTT_Write+0x1f0>)
  p->aUp[0].RdOff         = 0u;
   1004a:	62a5      	str	r5, [r4, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
   1004c:	6265      	str	r5, [r4, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
   1004e:	62e5      	str	r5, [r4, #44]	; 0x2c
  p->aDown[0].RdOff         = 0u;
   10050:	6725      	str	r5, [r4, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
   10052:	66e5      	str	r5, [r4, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
   10054:	6765      	str	r5, [r4, #116]	; 0x74
  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
   10056:	e9c4 0119 	strd	r0, r1, [r4, #100]	; 0x64
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
   1005a:	2503      	movs	r5, #3
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
   1005c:	e9c4 5504 	strd	r5, r5, [r4, #16]
  p->aUp[0].sName         = "Terminal";
   10060:	61a2      	str	r2, [r4, #24]
  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
   10062:	f44f 6580 	mov.w	r5, #1024	; 0x400
  p->aDown[0].sName         = "Terminal";
   10066:	6622      	str	r2, [r4, #96]	; 0x60
  p->acID[6] = ' ';
   10068:	2220      	movs	r2, #32
  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
   1006a:	6225      	str	r5, [r4, #32]
  p->acID[6] = ' ';
   1006c:	71a2      	strb	r2, [r4, #6]
  SEGGER_RTT_LOCK();
   1006e:	f3ef 8311 	mrs	r3, BASEPRI
   10072:	f04f 0120 	mov.w	r1, #32
   10076:	f381 8811 	msr	BASEPRI, r1
  switch (pRing->Flags) {
   1007a:	ea4f 0846 	mov.w	r8, r6, lsl #1
   1007e:	eb08 0b06 	add.w	fp, r8, r6
   10082:	eb04 02cb 	add.w	r2, r4, fp, lsl #3
  SEGGER_RTT_LOCK();
   10086:	9301      	str	r3, [sp, #4]
  switch (pRing->Flags) {
   10088:	6ad5      	ldr	r5, [r2, #44]	; 0x2c
   1008a:	2d01      	cmp	r5, #1
   1008c:	d073      	beq.n	10176 <SEGGER_RTT_Write+0x15a>
   1008e:	d347      	bcc.n	10120 <SEGGER_RTT_Write+0x104>
   10090:	2d02      	cmp	r5, #2
   10092:	d135      	bne.n	10100 <SEGGER_RTT_Write+0xe4>
   10094:	3601      	adds	r6, #1
    SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pBuffer, NumBytesToWrite);
   10096:	eb06 0646 	add.w	r6, r6, r6, lsl #1
   1009a:	ea4f 0ac6 	mov.w	sl, r6, lsl #3
  WrOff = pRing->WrOff;
   1009e:	6a56      	ldr	r6, [r2, #36]	; 0x24
    RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
   100a0:	4693      	mov	fp, r2
  NumBytesWritten = 0u;
   100a2:	2500      	movs	r5, #0
    RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
   100a4:	f8db 1028 	ldr.w	r1, [fp, #40]	; 0x28
   100a8:	f8db 2020 	ldr.w	r2, [fp, #32]
    if (RdOff > WrOff) {
   100ac:	42b1      	cmp	r1, r6
      NumBytesToWrite = RdOff - WrOff - 1u;
   100ae:	f101 38ff 	add.w	r8, r1, #4294967295	; 0xffffffff
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
   100b2:	bf96      	itet	ls
   100b4:	1889      	addls	r1, r1, r2
      NumBytesToWrite = RdOff - WrOff - 1u;
   100b6:	eba8 0106 	subhi.w	r1, r8, r6
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
   100ba:	f101 31ff 	addls.w	r1, r1, #4294967295	; 0xffffffff
    NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
   100be:	eba2 0806 	sub.w	r8, r2, r6
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
   100c2:	bf98      	it	ls
   100c4:	1b89      	subls	r1, r1, r6
    SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pBuffer, NumBytesToWrite);
   100c6:	eb04 000a 	add.w	r0, r4, sl
    NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
   100ca:	45c8      	cmp	r8, r9
   100cc:	bf28      	it	cs
   100ce:	46c8      	movcs	r8, r9
   100d0:	4588      	cmp	r8, r1
    SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pBuffer, NumBytesToWrite);
   100d2:	6840      	ldr	r0, [r0, #4]
    NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
   100d4:	bf28      	it	cs
   100d6:	4688      	movcs	r8, r1
    SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pBuffer, NumBytesToWrite);
   100d8:	4642      	mov	r2, r8
   100da:	4430      	add	r0, r6
   100dc:	4639      	mov	r1, r7
   100de:	f7fc f80f 	bl	c100 <memcpy>
    if (WrOff == pRing->SizeOfBuffer) {
   100e2:	f8db 2020 	ldr.w	r2, [fp, #32]
    WrOff           += NumBytesToWrite;
   100e6:	4446      	add	r6, r8
    if (WrOff == pRing->SizeOfBuffer) {
   100e8:	4296      	cmp	r6, r2
    NumBytesWritten += NumBytesToWrite;
   100ea:	4445      	add	r5, r8
    NumBytes        -= NumBytesToWrite;
   100ec:	eba9 0908 	sub.w	r9, r9, r8
    pBuffer         += NumBytesToWrite;
   100f0:	4447      	add	r7, r8
    if (WrOff == pRing->SizeOfBuffer) {
   100f2:	d00d      	beq.n	10110 <SEGGER_RTT_Write+0xf4>
    pRing->WrOff = WrOff;
   100f4:	f8cb 6024 	str.w	r6, [fp, #36]	; 0x24
  } while (NumBytes);
   100f8:	f1b9 0f00 	cmp.w	r9, #0
   100fc:	d1d2      	bne.n	100a4 <SEGGER_RTT_Write+0x88>
   100fe:	e000      	b.n	10102 <SEGGER_RTT_Write+0xe6>
    Status = 0u;
   10100:	2500      	movs	r5, #0
  //
  Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);
  //
  // Finish up.
  //
  SEGGER_RTT_UNLOCK();
   10102:	9b01      	ldr	r3, [sp, #4]
   10104:	f383 8811 	msr	BASEPRI, r3
  //
  return Status;
}
   10108:	4628      	mov	r0, r5
   1010a:	b003      	add	sp, #12
   1010c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    pRing->WrOff = WrOff;
   10110:	2200      	movs	r2, #0
      WrOff = 0u;
   10112:	4616      	mov	r6, r2
    pRing->WrOff = WrOff;
   10114:	f8cb 2024 	str.w	r2, [fp, #36]	; 0x24
  } while (NumBytes);
   10118:	f1b9 0f00 	cmp.w	r9, #0
   1011c:	d1c2      	bne.n	100a4 <SEGGER_RTT_Write+0x88>
   1011e:	e7f0      	b.n	10102 <SEGGER_RTT_Write+0xe6>
  RdOff = pRing->RdOff;
   10120:	6a91      	ldr	r1, [r2, #40]	; 0x28
  WrOff = pRing->WrOff;
   10122:	f8d2 a024 	ldr.w	sl, [r2, #36]	; 0x24
  if (RdOff <= WrOff) {
   10126:	4551      	cmp	r1, sl
    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
   10128:	bf9c      	itt	ls
   1012a:	6a12      	ldrls	r2, [r2, #32]
   1012c:	1889      	addls	r1, r1, r2
    r = RdOff - WrOff - 1u;
   1012e:	3901      	subs	r1, #1
   10130:	eba1 010a 	sub.w	r1, r1, sl
    if (Avail < NumBytes) {
   10134:	4589      	cmp	r9, r1
   10136:	d8e4      	bhi.n	10102 <SEGGER_RTT_Write+0xe6>
  Rem = pRing->SizeOfBuffer - WrOff;
   10138:	44b0      	add	r8, r6
   1013a:	eb04 08c8 	add.w	r8, r4, r8, lsl #3
   1013e:	3601      	adds	r6, #1
   10140:	eb06 0646 	add.w	r6, r6, r6, lsl #1
   10144:	eb04 04c6 	add.w	r4, r4, r6, lsl #3
   10148:	f8d8 5020 	ldr.w	r5, [r8, #32]
   1014c:	6860      	ldr	r0, [r4, #4]
   1014e:	eba5 050a 	sub.w	r5, r5, sl
  if (Rem > NumBytes) {
   10152:	45a9      	cmp	r9, r5
   10154:	4450      	add	r0, sl
   10156:	d345      	bcc.n	101e4 <SEGGER_RTT_Write+0x1c8>
    SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytesAtOnce);
   10158:	462a      	mov	r2, r5
    NumBytesAtOnce = NumBytes - Rem;
   1015a:	eba9 0605 	sub.w	r6, r9, r5
    SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytesAtOnce);
   1015e:	4639      	mov	r1, r7
   10160:	f7fb ffce 	bl	c100 <memcpy>
    SEGGER_RTT_MEMCPY(pRing->pBuffer, pData + Rem, NumBytesAtOnce);
   10164:	1979      	adds	r1, r7, r5
   10166:	6860      	ldr	r0, [r4, #4]
   10168:	4632      	mov	r2, r6
   1016a:	f7fb ffc9 	bl	c100 <memcpy>
    pRing->WrOff = NumBytesAtOnce;
   1016e:	464d      	mov	r5, r9
   10170:	f8c8 6024 	str.w	r6, [r8, #36]	; 0x24
   10174:	e7c5      	b.n	10102 <SEGGER_RTT_Write+0xe6>
  RdOff = pRing->RdOff;
   10176:	6a95      	ldr	r5, [r2, #40]	; 0x28
   10178:	e9d2 2b08 	ldrd	r2, fp, [r2, #32]
  if (RdOff <= WrOff) {
   1017c:	455d      	cmp	r5, fp
    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
   1017e:	bf98      	it	ls
   10180:	18ad      	addls	r5, r5, r2
   10182:	f106 0a01 	add.w	sl, r6, #1
    r = RdOff - WrOff - 1u;
   10186:	3d01      	subs	r5, #1
   10188:	eb0a 0a4a 	add.w	sl, sl, sl, lsl #1
   1018c:	eba5 050b 	sub.w	r5, r5, fp
   10190:	eb04 0aca 	add.w	sl, r4, sl, lsl #3
    Status = Avail < NumBytes ? Avail : NumBytes;
   10194:	454d      	cmp	r5, r9
   10196:	bf28      	it	cs
   10198:	464d      	movcs	r5, r9
   1019a:	f8da 0004 	ldr.w	r0, [sl, #4]
  Rem = pRing->SizeOfBuffer - WrOff;
   1019e:	eba2 090b 	sub.w	r9, r2, fp
  if (Rem > NumBytes) {
   101a2:	454d      	cmp	r5, r9
   101a4:	4458      	add	r0, fp
   101a6:	d312      	bcc.n	101ce <SEGGER_RTT_Write+0x1b2>
    pRing->WrOff = NumBytesAtOnce;
   101a8:	4446      	add	r6, r8
    SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytesAtOnce);
   101aa:	464a      	mov	r2, r9
   101ac:	4639      	mov	r1, r7
    NumBytesAtOnce = NumBytes - Rem;
   101ae:	eba5 0b09 	sub.w	fp, r5, r9
    pRing->WrOff = NumBytesAtOnce;
   101b2:	eb04 04c6 	add.w	r4, r4, r6, lsl #3
    SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytesAtOnce);
   101b6:	f7fb ffa3 	bl	c100 <memcpy>
    SEGGER_RTT_MEMCPY(pRing->pBuffer, pData + Rem, NumBytesAtOnce);
   101ba:	eb07 0109 	add.w	r1, r7, r9
   101be:	f8da 0004 	ldr.w	r0, [sl, #4]
   101c2:	465a      	mov	r2, fp
   101c4:	f7fb ff9c 	bl	c100 <memcpy>
    pRing->WrOff = NumBytesAtOnce;
   101c8:	f8c4 b024 	str.w	fp, [r4, #36]	; 0x24
   101cc:	e799      	b.n	10102 <SEGGER_RTT_Write+0xe6>
    pRing->WrOff = WrOff + NumBytes;
   101ce:	4446      	add	r6, r8
    SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytes);
   101d0:	4639      	mov	r1, r7
   101d2:	462a      	mov	r2, r5
    pRing->WrOff = WrOff + NumBytes;
   101d4:	eb04 04c6 	add.w	r4, r4, r6, lsl #3
    SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytes);
   101d8:	f7fb ff92 	bl	c100 <memcpy>
    pRing->WrOff = WrOff + NumBytes;
   101dc:	eb0b 0305 	add.w	r3, fp, r5
   101e0:	6263      	str	r3, [r4, #36]	; 0x24
   101e2:	e78e      	b.n	10102 <SEGGER_RTT_Write+0xe6>
    SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytes);
   101e4:	464a      	mov	r2, r9
   101e6:	4639      	mov	r1, r7
   101e8:	f7fb ff8a 	bl	c100 <memcpy>
    pRing->WrOff = WrOff + NumBytes;
   101ec:	eb09 020a 	add.w	r2, r9, sl
   101f0:	f8c8 2024 	str.w	r2, [r8, #36]	; 0x24
   101f4:	464d      	mov	r5, r9
   101f6:	e784      	b.n	10102 <SEGGER_RTT_Write+0xe6>
   101f8:	1001341c 	.word	0x1001341c
   101fc:	00013988 	.word	0x00013988
   10200:	0001398c 	.word	0x0001398c
   10204:	10012e2c 	.word	0x10012e2c
   10208:	10012e3c 	.word	0x10012e3c
   1020c:	0001397c 	.word	0x0001397c

00010210 <SEGGER_RTT_ConfigUpBuffer>:
*  Additional information
*    Buffer 0 is configured on compile-time.
*    May only be called once per buffer.
*    Buffer name and flags can be reconfigured using the appropriate functions.
*/
int SEGGER_RTT_ConfigUpBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
   10210:	b4f0      	push	{r4, r5, r6, r7}
  int r;

  INIT();
   10212:	4c2a      	ldr	r4, [pc, #168]	; (102bc <SEGGER_RTT_ConfigUpBuffer+0xac>)
   10214:	7826      	ldrb	r6, [r4, #0]
int SEGGER_RTT_ConfigUpBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
   10216:	4605      	mov	r5, r0
   10218:	460f      	mov	r7, r1
  INIT();
   1021a:	b346      	cbz	r6, 1026e <SEGGER_RTT_ConfigUpBuffer+0x5e>
   1021c:	6921      	ldr	r1, [r4, #16]
  if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
   1021e:	428d      	cmp	r5, r1
   10220:	d248      	bcs.n	102b4 <SEGGER_RTT_ConfigUpBuffer+0xa4>
    SEGGER_RTT_LOCK();
   10222:	f3ef 8611 	mrs	r6, BASEPRI
   10226:	f04f 0120 	mov.w	r1, #32
   1022a:	f381 8811 	msr	BASEPRI, r1
    if (BufferIndex > 0u) {
   1022e:	b955      	cbnz	r5, 10246 <SEGGER_RTT_ConfigUpBuffer+0x36>
   10230:	4628      	mov	r0, r5
      _SEGGER_RTT.aUp[BufferIndex].pBuffer      = (char*)pBuffer;
      _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
      _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
      _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
    }
    _SEGGER_RTT.aUp[BufferIndex].Flags          = Flags;
   10232:	4405      	add	r5, r0
   10234:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
   10238:	9b04      	ldr	r3, [sp, #16]
   1023a:	62e3      	str	r3, [r4, #44]	; 0x2c
    SEGGER_RTT_UNLOCK();
   1023c:	f386 8811 	msr	BASEPRI, r6
    r =  0;
   10240:	2000      	movs	r0, #0
  } else {
    r = -1;
  }
  return r;
}
   10242:	bcf0      	pop	{r4, r5, r6, r7}
   10244:	4770      	bx	lr
      _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
   10246:	1c69      	adds	r1, r5, #1
   10248:	eb01 0141 	add.w	r1, r1, r1, lsl #1
      _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
   1024c:	0068      	lsls	r0, r5, #1
      _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
   1024e:	00c9      	lsls	r1, r1, #3
      _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
   10250:	eb00 0c05 	add.w	ip, r0, r5
   10254:	eb04 0ccc 	add.w	ip, r4, ip, lsl #3
      _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
   10258:	5067      	str	r7, [r4, r1]
      _SEGGER_RTT.aUp[BufferIndex].pBuffer      = (char*)pBuffer;
   1025a:	4421      	add	r1, r4
      _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
   1025c:	f8cc 3020 	str.w	r3, [ip, #32]
      _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
   10260:	2300      	movs	r3, #0
      _SEGGER_RTT.aUp[BufferIndex].pBuffer      = (char*)pBuffer;
   10262:	604a      	str	r2, [r1, #4]
      _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
   10264:	f8cc 3028 	str.w	r3, [ip, #40]	; 0x28
      _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
   10268:	f8cc 3024 	str.w	r3, [ip, #36]	; 0x24
   1026c:	e7e1      	b.n	10232 <SEGGER_RTT_ConfigUpBuffer+0x22>
  strcpy(&p->acID[7], "RTT");
   1026e:	4814      	ldr	r0, [pc, #80]	; (102c0 <SEGGER_RTT_ConfigUpBuffer+0xb0>)
  strcpy(&p->acID[0], "SEGGER");
   10270:	4914      	ldr	r1, [pc, #80]	; (102c4 <SEGGER_RTT_ConfigUpBuffer+0xb4>)
  strcpy(&p->acID[7], "RTT");
   10272:	6800      	ldr	r0, [r0, #0]
   10274:	f8c4 0007 	str.w	r0, [r4, #7]
  strcpy(&p->acID[0], "SEGGER");
   10278:	c903      	ldmia	r1, {r0, r1}
  p->aUp[0].RdOff         = 0u;
   1027a:	62a6      	str	r6, [r4, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
   1027c:	6266      	str	r6, [r4, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
   1027e:	62e6      	str	r6, [r4, #44]	; 0x2c
  p->aDown[0].RdOff         = 0u;
   10280:	6726      	str	r6, [r4, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
   10282:	66e6      	str	r6, [r4, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
   10284:	6766      	str	r6, [r4, #116]	; 0x74
  strcpy(&p->acID[0], "SEGGER");
   10286:	6020      	str	r0, [r4, #0]
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
   10288:	2603      	movs	r6, #3
  p->aUp[0].sName         = "Terminal";
   1028a:	480f      	ldr	r0, [pc, #60]	; (102c8 <SEGGER_RTT_ConfigUpBuffer+0xb8>)
  strcpy(&p->acID[0], "SEGGER");
   1028c:	80a1      	strh	r1, [r4, #4]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
   1028e:	e9c4 6604 	strd	r6, r6, [r4, #16]
  p->acID[6] = ' ';
   10292:	4631      	mov	r1, r6
  p->aUp[0].sName         = "Terminal";
   10294:	61a0      	str	r0, [r4, #24]
  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
   10296:	f44f 6680 	mov.w	r6, #1024	; 0x400
  p->aDown[0].sName         = "Terminal";
   1029a:	6620      	str	r0, [r4, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
   1029c:	480b      	ldr	r0, [pc, #44]	; (102cc <SEGGER_RTT_ConfigUpBuffer+0xbc>)
  p->aUp[0].pBuffer       = _acUpBuffer;
   1029e:	f8df c030 	ldr.w	ip, [pc, #48]	; 102d0 <SEGGER_RTT_ConfigUpBuffer+0xc0>
  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
   102a2:	6226      	str	r6, [r4, #32]
  p->aDown[0].pBuffer       = _acDownBuffer;
   102a4:	6660      	str	r0, [r4, #100]	; 0x64
  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
   102a6:	2610      	movs	r6, #16
  p->acID[6] = ' ';
   102a8:	2020      	movs	r0, #32
  p->aUp[0].pBuffer       = _acUpBuffer;
   102aa:	f8c4 c01c 	str.w	ip, [r4, #28]
  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
   102ae:	66a6      	str	r6, [r4, #104]	; 0x68
  p->acID[6] = ' ';
   102b0:	71a0      	strb	r0, [r4, #6]
   102b2:	e7b4      	b.n	1021e <SEGGER_RTT_ConfigUpBuffer+0xe>
    r = -1;
   102b4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  return r;
   102b8:	e7c3      	b.n	10242 <SEGGER_RTT_ConfigUpBuffer+0x32>
   102ba:	bf00      	nop
   102bc:	1001341c 	.word	0x1001341c
   102c0:	00013988 	.word	0x00013988
   102c4:	0001398c 	.word	0x0001398c
   102c8:	0001397c 	.word	0x0001397c
   102cc:	10012e2c 	.word	0x10012e2c
   102d0:	10012e3c 	.word	0x10012e3c

000102d4 <SEGGER_SYSVIEW_EncodeU32>:
*  Return value
*    Pointer to the byte following the value, i.e. the first free
*    byte in the payload and the next position to store payload
*    content.
*/
U8* SEGGER_SYSVIEW_EncodeU32(U8* pPayload, U32 Value) {
   102d4:	e004      	b.n	102e0 <SEGGER_SYSVIEW_EncodeU32+0xc>
  ENCODE_U32(pPayload, Value);
   102d6:	f061 037f 	orn	r3, r1, #127	; 0x7f
   102da:	f800 3b01 	strb.w	r3, [r0], #1
   102de:	09c9      	lsrs	r1, r1, #7
   102e0:	297f      	cmp	r1, #127	; 0x7f
   102e2:	d8f8      	bhi.n	102d6 <SEGGER_SYSVIEW_EncodeU32+0x2>
   102e4:	f800 1b01 	strb.w	r1, [r0], #1
  return pPayload;
}
   102e8:	4770      	bx	lr
   102ea:	bf00      	nop

000102ec <SEGGER_SYSVIEW_ShrinkId>:
*       (i.e. 0x20000000 when all Ids are an address in this RAM)
*     SEGGER_SYSVIEW_ID_SHIFT: Number of bits to shift the Id to
*       save bandwidth. (i.e. 2 when Ids are 4 byte aligned)
*/
U32 SEGGER_SYSVIEW_ShrinkId(U32 Id) {
  return SHRINK_ID(Id);
   102ec:	4b02      	ldr	r3, [pc, #8]	; (102f8 <SEGGER_SYSVIEW_ShrinkId+0xc>)
   102ee:	691b      	ldr	r3, [r3, #16]
   102f0:	1ac0      	subs	r0, r0, r3
}
   102f2:	0880      	lsrs	r0, r0, #2
   102f4:	4770      	bx	lr
   102f6:	bf00      	nop
   102f8:	10013240 	.word	0x10013240

000102fc <SEGGER_SYSVIEW_SendModule>:
*/
void SEGGER_SYSVIEW_SendModule(U8 ModuleId) {
  SEGGER_SYSVIEW_MODULE* pModule;
  U32 n;

  if (_pFirstModule != 0) {
   102fc:	4b64      	ldr	r3, [pc, #400]	; (10490 <SEGGER_SYSVIEW_SendModule+0x194>)
   102fe:	681b      	ldr	r3, [r3, #0]
   10300:	2b00      	cmp	r3, #0
   10302:	f000 80ac 	beq.w	1045e <SEGGER_SYSVIEW_SendModule+0x162>
void SEGGER_SYSVIEW_SendModule(U8 ModuleId) {
   10306:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    pModule = _pFirstModule;
    for (n = 0; n < ModuleId; n++) {
   1030a:	2800      	cmp	r0, #0
   1030c:	f000 80b6 	beq.w	1047c <SEGGER_SYSVIEW_SendModule+0x180>
      pModule = pModule->pNext;
   10310:	691b      	ldr	r3, [r3, #16]
      if (pModule == 0) {
   10312:	2b00      	cmp	r3, #0
   10314:	f000 80a1 	beq.w	1045a <SEGGER_SYSVIEW_SendModule+0x15e>
    for (n = 0; n < ModuleId; n++) {
   10318:	2200      	movs	r2, #0
   1031a:	e003      	b.n	10324 <SEGGER_SYSVIEW_SendModule+0x28>
      pModule = pModule->pNext;
   1031c:	691b      	ldr	r3, [r3, #16]
      if (pModule == 0) {
   1031e:	2b00      	cmp	r3, #0
   10320:	f000 809b 	beq.w	1045a <SEGGER_SYSVIEW_SendModule+0x15e>
    for (n = 0; n < ModuleId; n++) {
   10324:	3201      	adds	r2, #1
   10326:	4282      	cmp	r2, r0
   10328:	d1f8      	bne.n	1031c <SEGGER_SYSVIEW_SendModule+0x20>
   1032a:	b2d0      	uxtb	r0, r2
      }
    }
    if (pModule != 0) {
      U8* pPayload;
      U8* pPayloadStart;
      RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
   1032c:	f3ef 8411 	mrs	r4, BASEPRI
   10330:	f04f 0120 	mov.w	r1, #32
   10334:	f381 8811 	msr	BASEPRI, r1
      pPayload = pPayloadStart;
      //
      // Send module description
      // Send event offset and number of events
      //
      ENCODE_U32(pPayload, ModuleId);
   10338:	2a7f      	cmp	r2, #127	; 0x7f
   1033a:	f240 80a7 	bls.w	1048c <SEGGER_SYSVIEW_SendModule+0x190>
   1033e:	4955      	ldr	r1, [pc, #340]	; (10494 <SEGGER_SYSVIEW_SendModule+0x198>)
   10340:	7108      	strb	r0, [r1, #4]
   10342:	3105      	adds	r1, #5
   10344:	2001      	movs	r0, #1
   10346:	7008      	strb	r0, [r1, #0]
      ENCODE_U32(pPayload, (pModule->EventOffset));
   10348:	689a      	ldr	r2, [r3, #8]
   1034a:	2a7f      	cmp	r2, #127	; 0x7f
      ENCODE_U32(pPayload, ModuleId);
   1034c:	f101 0101 	add.w	r1, r1, #1
      ENCODE_U32(pPayload, (pModule->EventOffset));
   10350:	d906      	bls.n	10360 <SEGGER_SYSVIEW_SendModule+0x64>
   10352:	f062 007f 	orn	r0, r2, #127	; 0x7f
   10356:	09d2      	lsrs	r2, r2, #7
   10358:	2a7f      	cmp	r2, #127	; 0x7f
   1035a:	f801 0b01 	strb.w	r0, [r1], #1
   1035e:	d8f8      	bhi.n	10352 <SEGGER_SYSVIEW_SendModule+0x56>
   10360:	460d      	mov	r5, r1
   10362:	f805 2b02 	strb.w	r2, [r5], #2
      pPayload = _EncodeStr(pPayload, pModule->sModule, SEGGER_SYSVIEW_MAX_STRING_LEN);
   10366:	f8d3 c000 	ldr.w	ip, [r3]
  while(*(pText + Len) != 0) {
   1036a:	f89c 3000 	ldrb.w	r3, [ip]
   1036e:	2b00      	cmp	r3, #0
   10370:	f000 8081 	beq.w	10476 <SEGGER_SYSVIEW_SendModule+0x17a>
   10374:	4660      	mov	r0, ip
  Len = 0;
   10376:	2200      	movs	r2, #0
  while(*(pText + Len) != 0) {
   10378:	f810 3f01 	ldrb.w	r3, [r0, #1]!
    Len++;
   1037c:	3201      	adds	r2, #1
  while(*(pText + Len) != 0) {
   1037e:	2b00      	cmp	r3, #0
   10380:	d1fa      	bne.n	10378 <SEGGER_SYSVIEW_SendModule+0x7c>
   10382:	f10c 0608 	add.w	r6, ip, #8
   10386:	f101 000a 	add.w	r0, r1, #10
   1038a:	4584      	cmp	ip, r0
   1038c:	bf38      	it	cc
   1038e:	42b5      	cmpcc	r5, r6
   10390:	bf2c      	ite	cs
   10392:	2601      	movcs	r6, #1
   10394:	2600      	movcc	r6, #0
   10396:	ea45 070c 	orr.w	r7, r5, ip
   1039a:	2a80      	cmp	r2, #128	; 0x80
   1039c:	4610      	mov	r0, r2
   1039e:	bf28      	it	cs
   103a0:	2080      	movcs	r0, #128	; 0x80
   103a2:	f017 0f07 	tst.w	r7, #7
   103a6:	bf18      	it	ne
   103a8:	2600      	movne	r6, #0
    *pPayload++ = Len; 
   103aa:	7048      	strb	r0, [r1, #1]
   103ac:	2e00      	cmp	r6, #0
   103ae:	d057      	beq.n	10460 <SEGGER_SYSVIEW_SendModule+0x164>
   103b0:	2a0c      	cmp	r2, #12
   103b2:	d955      	bls.n	10460 <SEGGER_SYSVIEW_SendModule+0x164>
   103b4:	2a00      	cmp	r2, #0
   103b6:	bf14      	ite	ne
   103b8:	4680      	movne	r8, r0
   103ba:	f04f 0801 	moveq.w	r8, #1
   103be:	ea4f 0ad8 	mov.w	sl, r8, lsr #3
   103c2:	1c6a      	adds	r2, r5, #1
   103c4:	f1ac 0908 	sub.w	r9, ip, #8
   103c8:	46ae      	mov	lr, r5
    *pPayload++ = *pText++;
   103ca:	e9f9 6702 	ldrd	r6, r7, [r9, #8]!
   103ce:	3301      	adds	r3, #1
   103d0:	4611      	mov	r1, r2
   103d2:	459a      	cmp	sl, r3
   103d4:	e8ee 6702 	strd	r6, r7, [lr], #8
   103d8:	f101 0107 	add.w	r1, r1, #7
   103dc:	f102 0208 	add.w	r2, r2, #8
   103e0:	d8f3      	bhi.n	103ca <SEGGER_SYSVIEW_SendModule+0xce>
   103e2:	f028 0307 	bic.w	r3, r8, #7
   103e6:	4598      	cmp	r8, r3
   103e8:	eb0c 0603 	add.w	r6, ip, r3
   103ec:	eb05 0203 	add.w	r2, r5, r3
   103f0:	d02d      	beq.n	1044e <SEGGER_SYSVIEW_SendModule+0x152>
   103f2:	f81c 1003 	ldrb.w	r1, [ip, r3]
   103f6:	54e9      	strb	r1, [r5, r3]
    n++;
   103f8:	1c5d      	adds	r5, r3, #1
  while (n < Len) {
   103fa:	4285      	cmp	r5, r0
    *pPayload++ = *pText++;
   103fc:	f102 0101 	add.w	r1, r2, #1
  while (n < Len) {
   10400:	d225      	bcs.n	1044e <SEGGER_SYSVIEW_SendModule+0x152>
    n++;
   10402:	1c9d      	adds	r5, r3, #2
    *pPayload++ = *pText++;
   10404:	7871      	ldrb	r1, [r6, #1]
   10406:	7051      	strb	r1, [r2, #1]
  while (n < Len) {
   10408:	42a8      	cmp	r0, r5
    *pPayload++ = *pText++;
   1040a:	f102 0102 	add.w	r1, r2, #2
  while (n < Len) {
   1040e:	d91e      	bls.n	1044e <SEGGER_SYSVIEW_SendModule+0x152>
    n++;
   10410:	1cdd      	adds	r5, r3, #3
    *pPayload++ = *pText++;
   10412:	78b1      	ldrb	r1, [r6, #2]
   10414:	7091      	strb	r1, [r2, #2]
  while (n < Len) {
   10416:	42a8      	cmp	r0, r5
    *pPayload++ = *pText++;
   10418:	f102 0103 	add.w	r1, r2, #3
  while (n < Len) {
   1041c:	d917      	bls.n	1044e <SEGGER_SYSVIEW_SendModule+0x152>
    n++;
   1041e:	1d1d      	adds	r5, r3, #4
    *pPayload++ = *pText++;
   10420:	78f1      	ldrb	r1, [r6, #3]
   10422:	70d1      	strb	r1, [r2, #3]
  while (n < Len) {
   10424:	42a8      	cmp	r0, r5
    *pPayload++ = *pText++;
   10426:	f102 0104 	add.w	r1, r2, #4
  while (n < Len) {
   1042a:	d910      	bls.n	1044e <SEGGER_SYSVIEW_SendModule+0x152>
    n++;
   1042c:	1d5d      	adds	r5, r3, #5
    *pPayload++ = *pText++;
   1042e:	7931      	ldrb	r1, [r6, #4]
   10430:	7111      	strb	r1, [r2, #4]
  while (n < Len) {
   10432:	42a8      	cmp	r0, r5
    *pPayload++ = *pText++;
   10434:	f102 0105 	add.w	r1, r2, #5
  while (n < Len) {
   10438:	d909      	bls.n	1044e <SEGGER_SYSVIEW_SendModule+0x152>
    n++;
   1043a:	3306      	adds	r3, #6
    *pPayload++ = *pText++;
   1043c:	7971      	ldrb	r1, [r6, #5]
   1043e:	7151      	strb	r1, [r2, #5]
  while (n < Len) {
   10440:	4298      	cmp	r0, r3
    *pPayload++ = *pText++;
   10442:	f102 0106 	add.w	r1, r2, #6
  while (n < Len) {
   10446:	d902      	bls.n	1044e <SEGGER_SYSVIEW_SendModule+0x152>
    *pPayload++ = *pText++;
   10448:	79b3      	ldrb	r3, [r6, #6]
   1044a:	7193      	strb	r3, [r2, #6]
   1044c:	1dd1      	adds	r1, r2, #7
      _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_MODULEDESC);
   1044e:	2216      	movs	r2, #22
   10450:	4811      	ldr	r0, [pc, #68]	; (10498 <SEGGER_SYSVIEW_SendModule+0x19c>)
   10452:	f000 f8b1 	bl	105b8 <_SendPacket>
      RECORD_END();
   10456:	f384 8811 	msr	BASEPRI, r4
    }
  }
}
   1045a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1045e:	4770      	bx	lr
   10460:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
    *pPayload++ = Len; 
   10464:	4629      	mov	r1, r5
    *pPayload++ = *pText++;
   10466:	f81c 3f01 	ldrb.w	r3, [ip, #1]!
   1046a:	f801 3b01 	strb.w	r3, [r1], #1
  while (n < Len) {
   1046e:	1b4b      	subs	r3, r1, r5
   10470:	4298      	cmp	r0, r3
   10472:	d8f8      	bhi.n	10466 <SEGGER_SYSVIEW_SendModule+0x16a>
   10474:	e7eb      	b.n	1044e <SEGGER_SYSVIEW_SendModule+0x152>
    *pPayload++ = Len; 
   10476:	704b      	strb	r3, [r1, #1]
   10478:	4629      	mov	r1, r5
   1047a:	e7e8      	b.n	1044e <SEGGER_SYSVIEW_SendModule+0x152>
      RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
   1047c:	f3ef 8411 	mrs	r4, BASEPRI
   10480:	f04f 0120 	mov.w	r1, #32
   10484:	f381 8811 	msr	BASEPRI, r1
      ENCODE_U32(pPayload, ModuleId);
   10488:	4903      	ldr	r1, [pc, #12]	; (10498 <SEGGER_SYSVIEW_SendModule+0x19c>)
   1048a:	e75c      	b.n	10346 <SEGGER_SYSVIEW_SendModule+0x4a>
   1048c:	4902      	ldr	r1, [pc, #8]	; (10498 <SEGGER_SYSVIEW_SendModule+0x19c>)
   1048e:	e75a      	b.n	10346 <SEGGER_SYSVIEW_SendModule+0x4a>
   10490:	1001334c 	.word	0x1001334c
   10494:	10013268 	.word	0x10013268
   10498:	1001326c 	.word	0x1001326c

0001049c <_HandleIncomingPacket>:
static void _HandleIncomingPacket(void) {
   1049c:	b530      	push	{r4, r5, lr}
  Status = SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
   1049e:	2201      	movs	r2, #1
static void _HandleIncomingPacket(void) {
   104a0:	b083      	sub	sp, #12
  Status = SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
   104a2:	f10d 0107 	add.w	r1, sp, #7
   104a6:	4610      	mov	r0, r2
   104a8:	f7ff fcea 	bl	fe80 <SEGGER_RTT_ReadNoLock>
  if (Status > 0) {
   104ac:	2800      	cmp	r0, #0
   104ae:	dd13      	ble.n	104d8 <_HandleIncomingPacket+0x3c>
    switch (Cmd) {
   104b0:	f89d 3007 	ldrb.w	r3, [sp, #7]
   104b4:	2b04      	cmp	r3, #4
   104b6:	d04c      	beq.n	10552 <_HandleIncomingPacket+0xb6>
   104b8:	d910      	bls.n	104dc <_HandleIncomingPacket+0x40>
   104ba:	2b06      	cmp	r3, #6
   104bc:	d032      	beq.n	10524 <_HandleIncomingPacket+0x88>
   104be:	d322      	bcc.n	10506 <_HandleIncomingPacket+0x6a>
   104c0:	2b07      	cmp	r3, #7
   104c2:	d023      	beq.n	1050c <_HandleIncomingPacket+0x70>
   104c4:	2b80      	cmp	r3, #128	; 0x80
   104c6:	d14d      	bne.n	10564 <_HandleIncomingPacket+0xc8>
      Status = SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
   104c8:	2201      	movs	r2, #1
   104ca:	f10d 0107 	add.w	r1, sp, #7
   104ce:	4610      	mov	r0, r2
   104d0:	f7ff fcd6 	bl	fe80 <SEGGER_RTT_ReadNoLock>
      if (Status > 0) {
   104d4:	2800      	cmp	r0, #0
   104d6:	dc51      	bgt.n	1057c <_HandleIncomingPacket+0xe0>
}
   104d8:	b003      	add	sp, #12
   104da:	bd30      	pop	{r4, r5, pc}
    switch (Cmd) {
   104dc:	2b02      	cmp	r3, #2
   104de:	d005      	beq.n	104ec <_HandleIncomingPacket+0x50>
   104e0:	d849      	bhi.n	10576 <_HandleIncomingPacket+0xda>
   104e2:	2b01      	cmp	r3, #1
   104e4:	d13e      	bne.n	10564 <_HandleIncomingPacket+0xc8>
      SEGGER_SYSVIEW_Start();
   104e6:	f001 f927 	bl	11738 <SEGGER_SYSVIEW_Start>
      break;
   104ea:	e7f5      	b.n	104d8 <_HandleIncomingPacket+0x3c>
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
   104ec:	f3ef 8511 	mrs	r5, BASEPRI
   104f0:	f04f 0120 	mov.w	r1, #32
   104f4:	f381 8811 	msr	BASEPRI, r1
  if (_SYSVIEW_Globals.EnableState) {
   104f8:	4c2a      	ldr	r4, [pc, #168]	; (105a4 <_HandleIncomingPacket+0x108>)
   104fa:	7823      	ldrb	r3, [r4, #0]
   104fc:	2b00      	cmp	r3, #0
   104fe:	d142      	bne.n	10586 <_HandleIncomingPacket+0xea>
  RECORD_END();
   10500:	f385 8811 	msr	BASEPRI, r5
   10504:	e7e8      	b.n	104d8 <_HandleIncomingPacket+0x3c>
      SEGGER_SYSVIEW_GetSysDesc();
   10506:	f001 fa41 	bl	1198c <SEGGER_SYSVIEW_GetSysDesc>
      break;
   1050a:	e7e5      	b.n	104d8 <_HandleIncomingPacket+0x3c>
*
*/
void SEGGER_SYSVIEW_SendModuleDescription(void) {
  SEGGER_SYSVIEW_MODULE* pModule;

  if (_pFirstModule != 0) {
   1050c:	4b26      	ldr	r3, [pc, #152]	; (105a8 <_HandleIncomingPacket+0x10c>)
   1050e:	681c      	ldr	r4, [r3, #0]
   10510:	2c00      	cmp	r4, #0
   10512:	d0e1      	beq.n	104d8 <_HandleIncomingPacket+0x3c>
    pModule = _pFirstModule;
    do {
      if (pModule->pfSendModuleDesc) {
   10514:	68e3      	ldr	r3, [r4, #12]
   10516:	2b00      	cmp	r3, #0
   10518:	d03d      	beq.n	10596 <_HandleIncomingPacket+0xfa>
        pModule->pfSendModuleDesc();
   1051a:	4798      	blx	r3
      }
      pModule = pModule->pNext;
   1051c:	6924      	ldr	r4, [r4, #16]
    } while (pModule);
   1051e:	2c00      	cmp	r4, #0
   10520:	d1f8      	bne.n	10514 <_HandleIncomingPacket+0x78>
   10522:	e7d9      	b.n	104d8 <_HandleIncomingPacket+0x3c>
*    Send the number of registered modules to the host.
*/
void SEGGER_SYSVIEW_SendNumModules(void) {
  U8* pPayload;
  U8* pPayloadStart;
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2*SEGGER_SYSVIEW_QUANTA_U32);
   10524:	f3ef 8411 	mrs	r4, BASEPRI
   10528:	f04f 0120 	mov.w	r1, #32
   1052c:	f381 8811 	msr	BASEPRI, r1
  pPayload = pPayloadStart;
  ENCODE_U32(pPayload, _NumModules);
   10530:	4b1e      	ldr	r3, [pc, #120]	; (105ac <_HandleIncomingPacket+0x110>)
   10532:	781b      	ldrb	r3, [r3, #0]
   10534:	2b7f      	cmp	r3, #127	; 0x7f
   10536:	d932      	bls.n	1059e <_HandleIncomingPacket+0x102>
   10538:	491d      	ldr	r1, [pc, #116]	; (105b0 <_HandleIncomingPacket+0x114>)
   1053a:	710b      	strb	r3, [r1, #4]
   1053c:	3105      	adds	r1, #5
   1053e:	2301      	movs	r3, #1
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_NUMMODULES);
   10540:	481c      	ldr	r0, [pc, #112]	; (105b4 <_HandleIncomingPacket+0x118>)
  ENCODE_U32(pPayload, _NumModules);
   10542:	f801 3b01 	strb.w	r3, [r1], #1
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_NUMMODULES);
   10546:	221b      	movs	r2, #27
   10548:	f000 f836 	bl	105b8 <_SendPacket>
  RECORD_END();
   1054c:	f384 8811 	msr	BASEPRI, r4
   10550:	e7c2      	b.n	104d8 <_HandleIncomingPacket+0x3c>
  if (_SYSVIEW_Globals.pOSAPI && _SYSVIEW_Globals.pOSAPI->pfSendTaskList) {
   10552:	4b14      	ldr	r3, [pc, #80]	; (105a4 <_HandleIncomingPacket+0x108>)
   10554:	6a1b      	ldr	r3, [r3, #32]
   10556:	2b00      	cmp	r3, #0
   10558:	d0be      	beq.n	104d8 <_HandleIncomingPacket+0x3c>
   1055a:	685b      	ldr	r3, [r3, #4]
   1055c:	2b00      	cmp	r3, #0
   1055e:	d0bb      	beq.n	104d8 <_HandleIncomingPacket+0x3c>
    _SYSVIEW_Globals.pOSAPI->pfSendTaskList();
   10560:	4798      	blx	r3
   10562:	e7b9      	b.n	104d8 <_HandleIncomingPacket+0x3c>
      if (Cmd >= 128) { // Unknown extended command. Dummy read its parameter.
   10564:	061b      	lsls	r3, r3, #24
   10566:	d5b7      	bpl.n	104d8 <_HandleIncomingPacket+0x3c>
        SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
   10568:	2201      	movs	r2, #1
   1056a:	f10d 0107 	add.w	r1, sp, #7
   1056e:	4610      	mov	r0, r2
   10570:	f7ff fc86 	bl	fe80 <SEGGER_RTT_ReadNoLock>
}
   10574:	e7b0      	b.n	104d8 <_HandleIncomingPacket+0x3c>
      SEGGER_SYSVIEW_RecordSystime();
   10576:	f001 f81b 	bl	115b0 <SEGGER_SYSVIEW_RecordSystime>
      break;
   1057a:	e7ad      	b.n	104d8 <_HandleIncomingPacket+0x3c>
        SEGGER_SYSVIEW_SendModule(Cmd);
   1057c:	f89d 0007 	ldrb.w	r0, [sp, #7]
   10580:	f7ff febc 	bl	102fc <SEGGER_SYSVIEW_SendModule>
   10584:	e7a8      	b.n	104d8 <_HandleIncomingPacket+0x3c>
    _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_TRACE_STOP);
   10586:	490b      	ldr	r1, [pc, #44]	; (105b4 <_HandleIncomingPacket+0x118>)
   10588:	220b      	movs	r2, #11
   1058a:	4608      	mov	r0, r1
   1058c:	f000 f814 	bl	105b8 <_SendPacket>
    _SYSVIEW_Globals.EnableState = 0;
   10590:	2300      	movs	r3, #0
   10592:	7023      	strb	r3, [r4, #0]
   10594:	e7b4      	b.n	10500 <_HandleIncomingPacket+0x64>
      pModule = pModule->pNext;
   10596:	6924      	ldr	r4, [r4, #16]
    } while (pModule);
   10598:	2c00      	cmp	r4, #0
   1059a:	d1bb      	bne.n	10514 <_HandleIncomingPacket+0x78>
   1059c:	e79c      	b.n	104d8 <_HandleIncomingPacket+0x3c>
  ENCODE_U32(pPayload, _NumModules);
   1059e:	4905      	ldr	r1, [pc, #20]	; (105b4 <_HandleIncomingPacket+0x118>)
   105a0:	e7ce      	b.n	10540 <_HandleIncomingPacket+0xa4>
   105a2:	bf00      	nop
   105a4:	10013240 	.word	0x10013240
   105a8:	1001334c 	.word	0x1001334c
   105ac:	1001323c 	.word	0x1001323c
   105b0:	10013268 	.word	0x10013268
   105b4:	1001326c 	.word	0x1001326c

000105b8 <_SendPacket>:
static void _SendPacket(U8* pStartPacket, U8* pEndPacket, unsigned int EventId) {
   105b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   105bc:	4d52      	ldr	r5, [pc, #328]	; (10708 <_SendPacket+0x150>)
   105be:	782b      	ldrb	r3, [r5, #0]
   105c0:	2b01      	cmp	r3, #1
static void _SendPacket(U8* pStartPacket, U8* pEndPacket, unsigned int EventId) {
   105c2:	b084      	sub	sp, #16
   105c4:	4606      	mov	r6, r0
   105c6:	460c      	mov	r4, r1
   105c8:	4617      	mov	r7, r2
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   105ca:	d00f      	beq.n	105ec <_SendPacket+0x34>
  if (_SYSVIEW_Globals.EnableState == 0) {
   105cc:	b963      	cbnz	r3, 105e8 <_SendPacket+0x30>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   105ce:	4b4f      	ldr	r3, [pc, #316]	; (1070c <_SendPacket+0x154>)
   105d0:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   105d4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   105d8:	429a      	cmp	r2, r3
   105da:	d002      	beq.n	105e2 <_SendPacket+0x2a>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   105dc:	78ac      	ldrb	r4, [r5, #2]
   105de:	2c00      	cmp	r4, #0
   105e0:	d03c      	beq.n	1065c <_SendPacket+0xa4>
}
   105e2:	b004      	add	sp, #16
   105e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   105e8:	2b02      	cmp	r3, #2
   105ea:	d04f      	beq.n	1068c <_SendPacket+0xd4>
  if (EventId < 32) {
   105ec:	2f1f      	cmp	r7, #31
   105ee:	d913      	bls.n	10618 <_SendPacket+0x60>
   105f0:	b2fb      	uxtb	r3, r7
    NumBytes = pEndPacket - pStartPacket;
   105f2:	1ba2      	subs	r2, r4, r6
    if (NumBytes > 127) {
   105f4:	2a7f      	cmp	r2, #127	; 0x7f
   105f6:	b2d1      	uxtb	r1, r2
   105f8:	d838      	bhi.n	1066c <_SendPacket+0xb4>
    if (EventId > 127) {
   105fa:	2f7f      	cmp	r7, #127	; 0x7f
      *--pStartPacket = NumBytes;
   105fc:	f106 32ff 	add.w	r2, r6, #4294967295	; 0xffffffff
   10600:	f806 1c01 	strb.w	r1, [r6, #-1]
    if (EventId > 127) {
   10604:	d93e      	bls.n	10684 <_SendPacket+0xcc>
      *--pStartPacket = (EventId >> 7);
   10606:	09ff      	lsrs	r7, r7, #7
      *--pStartPacket = EventId | 0x80;
   10608:	f063 037f 	orn	r3, r3, #127	; 0x7f
      *--pStartPacket = (EventId >> 7);
   1060c:	f802 7c01 	strb.w	r7, [r2, #-1]
      *--pStartPacket = EventId | 0x80;
   10610:	f802 3c02 	strb.w	r3, [r2, #-2]
   10614:	3a02      	subs	r2, #2
   10616:	e009      	b.n	1062c <_SendPacket+0x74>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   10618:	69eb      	ldr	r3, [r5, #28]
   1061a:	40fb      	lsrs	r3, r7
   1061c:	07db      	lsls	r3, r3, #31
   1061e:	d4d6      	bmi.n	105ce <_SendPacket+0x16>
  if (EventId < 24) {
   10620:	2f17      	cmp	r7, #23
   10622:	b2fb      	uxtb	r3, r7
   10624:	d8e5      	bhi.n	105f2 <_SendPacket+0x3a>
    *--pStartPacket = EventId;
   10626:	f806 3c01 	strb.w	r3, [r6, #-1]
   1062a:	1e72      	subs	r2, r6, #1
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   1062c:	4938      	ldr	r1, [pc, #224]	; (10710 <_SendPacket+0x158>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   1062e:	68eb      	ldr	r3, [r5, #12]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10630:	680e      	ldr	r6, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   10632:	1af3      	subs	r3, r6, r3
  ENCODE_U32(pEndPacket, Delta);
   10634:	2b7f      	cmp	r3, #127	; 0x7f
   10636:	d906      	bls.n	10646 <_SendPacket+0x8e>
   10638:	f063 017f 	orn	r1, r3, #127	; 0x7f
   1063c:	09db      	lsrs	r3, r3, #7
   1063e:	2b7f      	cmp	r3, #127	; 0x7f
   10640:	f804 1b01 	strb.w	r1, [r4], #1
   10644:	d8f8      	bhi.n	10638 <_SendPacket+0x80>
   10646:	f804 3b01 	strb.w	r3, [r4], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   1064a:	4611      	mov	r1, r2
   1064c:	2001      	movs	r0, #1
   1064e:	1aa2      	subs	r2, r4, r2
   10650:	f7ff fc96 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   10654:	2800      	cmp	r0, #0
   10656:	d04c      	beq.n	106f2 <_SendPacket+0x13a>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   10658:	60ee      	str	r6, [r5, #12]
   1065a:	e7b8      	b.n	105ce <_SendPacket+0x16>
      _SYSVIEW_Globals.RecursionCnt = 1;
   1065c:	2301      	movs	r3, #1
   1065e:	70ab      	strb	r3, [r5, #2]
      _HandleIncomingPacket();
   10660:	f7ff ff1c 	bl	1049c <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   10664:	70ac      	strb	r4, [r5, #2]
}
   10666:	b004      	add	sp, #16
   10668:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      *--pStartPacket = NumBytes | 0x80;
   1066c:	f061 017f 	orn	r1, r1, #127	; 0x7f
   10670:	f806 1c02 	strb.w	r1, [r6, #-2]
    if (EventId > 127) {
   10674:	2f7f      	cmp	r7, #127	; 0x7f
      *--pStartPacket = (NumBytes >> 7);
   10676:	f3c2 11c7 	ubfx	r1, r2, #7, #8
   1067a:	f806 1c01 	strb.w	r1, [r6, #-1]
      *--pStartPacket = NumBytes | 0x80;
   1067e:	f1a6 0202 	sub.w	r2, r6, #2
    if (EventId > 127) {
   10682:	d8c0      	bhi.n	10606 <_SendPacket+0x4e>
      *--pStartPacket = EventId;
   10684:	f802 3c01 	strb.w	r3, [r2, #-1]
   10688:	3a01      	subs	r2, #1
   1068a:	e7cf      	b.n	1062c <_SendPacket+0x74>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   1068c:	696a      	ldr	r2, [r5, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   1068e:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10690:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   10692:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10696:	f10d 0305 	add.w	r3, sp, #5
   1069a:	d906      	bls.n	106aa <_SendPacket+0xf2>
   1069c:	f062 017f 	orn	r1, r2, #127	; 0x7f
   106a0:	09d2      	lsrs	r2, r2, #7
   106a2:	2a7f      	cmp	r2, #127	; 0x7f
   106a4:	f803 1b01 	strb.w	r1, [r3], #1
   106a8:	d8f8      	bhi.n	1069c <_SendPacket+0xe4>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   106aa:	4919      	ldr	r1, [pc, #100]	; (10710 <_SendPacket+0x158>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   106ac:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   106ae:	f8d1 8000 	ldr.w	r8, [r1]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   106b2:	68e9      	ldr	r1, [r5, #12]
   106b4:	eba8 0101 	sub.w	r1, r8, r1
  ENCODE_U32(pPayload, Delta);
   106b8:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   106ba:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   106be:	d906      	bls.n	106ce <_SendPacket+0x116>
   106c0:	f061 037f 	orn	r3, r1, #127	; 0x7f
   106c4:	09c9      	lsrs	r1, r1, #7
   106c6:	297f      	cmp	r1, #127	; 0x7f
   106c8:	f802 3b01 	strb.w	r3, [r2], #1
   106cc:	d8f8      	bhi.n	106c0 <_SendPacket+0x108>
   106ce:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   106d0:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   106d2:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   106d6:	2001      	movs	r0, #1
   106d8:	4611      	mov	r1, r2
   106da:	1a9a      	subs	r2, r3, r2
   106dc:	f7ff fc50 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   106e0:	b958      	cbnz	r0, 106fa <_SendPacket+0x142>
    _SYSVIEW_Globals.DropCount++;
   106e2:	696a      	ldr	r2, [r5, #20]
   106e4:	782b      	ldrb	r3, [r5, #0]
   106e6:	3201      	adds	r2, #1
   106e8:	616a      	str	r2, [r5, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   106ea:	2b01      	cmp	r3, #1
   106ec:	f47f af6f 	bne.w	105ce <_SendPacket+0x16>
   106f0:	e77c      	b.n	105ec <_SendPacket+0x34>
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   106f2:	782b      	ldrb	r3, [r5, #0]
   106f4:	3301      	adds	r3, #1
   106f6:	702b      	strb	r3, [r5, #0]
   106f8:	e769      	b.n	105ce <_SendPacket+0x16>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   106fa:	782b      	ldrb	r3, [r5, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   106fc:	f8c5 800c 	str.w	r8, [r5, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   10700:	3b01      	subs	r3, #1
   10702:	b2db      	uxtb	r3, r3
   10704:	702b      	strb	r3, [r5, #0]
   10706:	e7f0      	b.n	106ea <_SendPacket+0x132>
   10708:	10013240 	.word	0x10013240
   1070c:	1001341c 	.word	0x1001341c
   10710:	e0001004 	.word	0xe0001004

00010714 <SEGGER_SYSVIEW_SendTaskInfo>:
void SEGGER_SYSVIEW_SendTaskInfo(const SEGGER_SYSVIEW_TASKINFO *pInfo) {
   10714:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10718:	4605      	mov	r5, r0
   1071a:	b083      	sub	sp, #12
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32 + 1 + 32);
   1071c:	f3ef 8311 	mrs	r3, BASEPRI
   10720:	f04f 0120 	mov.w	r1, #32
   10724:	f381 8811 	msr	BASEPRI, r1
  ENCODE_U32(pPayload, SHRINK_ID(pInfo->TaskID));
   10728:	f8df 81c8 	ldr.w	r8, [pc, #456]	; 108f4 <SEGGER_SYSVIEW_SendTaskInfo+0x1e0>
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32 + 1 + 32);
   1072c:	9300      	str	r3, [sp, #0]
  ENCODE_U32(pPayload, SHRINK_ID(pInfo->TaskID));
   1072e:	f8d8 2010 	ldr.w	r2, [r8, #16]
   10732:	6803      	ldr	r3, [r0, #0]
   10734:	4c6e      	ldr	r4, [pc, #440]	; (108f0 <SEGGER_SYSVIEW_SendTaskInfo+0x1dc>)
   10736:	1a9b      	subs	r3, r3, r2
   10738:	089b      	lsrs	r3, r3, #2
   1073a:	2b7f      	cmp	r3, #127	; 0x7f
   1073c:	4622      	mov	r2, r4
   1073e:	d906      	bls.n	1074e <SEGGER_SYSVIEW_SendTaskInfo+0x3a>
   10740:	f063 017f 	orn	r1, r3, #127	; 0x7f
   10744:	09db      	lsrs	r3, r3, #7
   10746:	2b7f      	cmp	r3, #127	; 0x7f
   10748:	f802 1b01 	strb.w	r1, [r2], #1
   1074c:	d8f8      	bhi.n	10740 <SEGGER_SYSVIEW_SendTaskInfo+0x2c>
   1074e:	7013      	strb	r3, [r2, #0]
  ENCODE_U32(pPayload, pInfo->Prio);
   10750:	68ab      	ldr	r3, [r5, #8]
   10752:	2b7f      	cmp	r3, #127	; 0x7f
  ENCODE_U32(pPayload, SHRINK_ID(pInfo->TaskID));
   10754:	f102 0201 	add.w	r2, r2, #1
  ENCODE_U32(pPayload, pInfo->Prio);
   10758:	d906      	bls.n	10768 <SEGGER_SYSVIEW_SendTaskInfo+0x54>
   1075a:	f063 017f 	orn	r1, r3, #127	; 0x7f
   1075e:	09db      	lsrs	r3, r3, #7
   10760:	2b7f      	cmp	r3, #127	; 0x7f
   10762:	f802 1b01 	strb.w	r1, [r2], #1
   10766:	d8f8      	bhi.n	1075a <SEGGER_SYSVIEW_SendTaskInfo+0x46>
   10768:	4694      	mov	ip, r2
   1076a:	f80c 3b02 	strb.w	r3, [ip], #2
  pPayload = _EncodeStr(pPayload, pInfo->sName, 32);
   1076e:	6868      	ldr	r0, [r5, #4]
  while(*(pText + Len) != 0) {
   10770:	7803      	ldrb	r3, [r0, #0]
   10772:	2b00      	cmp	r3, #0
   10774:	f000 80b8 	beq.w	108e8 <SEGGER_SYSVIEW_SendTaskInfo+0x1d4>
   10778:	4606      	mov	r6, r0
  Len = 0;
   1077a:	2100      	movs	r1, #0
  while(*(pText + Len) != 0) {
   1077c:	f816 3f01 	ldrb.w	r3, [r6, #1]!
    Len++;
   10780:	3101      	adds	r1, #1
  while(*(pText + Len) != 0) {
   10782:	2b00      	cmp	r3, #0
   10784:	d1fa      	bne.n	1077c <SEGGER_SYSVIEW_SendTaskInfo+0x68>
   10786:	f100 0608 	add.w	r6, r0, #8
   1078a:	f102 0e0a 	add.w	lr, r2, #10
   1078e:	4570      	cmp	r0, lr
   10790:	bf38      	it	cc
   10792:	45b4      	cmpcc	ip, r6
   10794:	bf2c      	ite	cs
   10796:	2601      	movcs	r6, #1
   10798:	2600      	movcc	r6, #0
   1079a:	ea4c 0700 	orr.w	r7, ip, r0
   1079e:	2920      	cmp	r1, #32
   107a0:	468a      	mov	sl, r1
   107a2:	bf28      	it	cs
   107a4:	f04f 0a20 	movcs.w	sl, #32
   107a8:	f017 0f07 	tst.w	r7, #7
   107ac:	bf18      	it	ne
   107ae:	2600      	movne	r6, #0
    *pPayload++ = Len; 
   107b0:	f882 a001 	strb.w	sl, [r2, #1]
   107b4:	2e00      	cmp	r6, #0
   107b6:	f000 808c 	beq.w	108d2 <SEGGER_SYSVIEW_SendTaskInfo+0x1be>
   107ba:	290c      	cmp	r1, #12
   107bc:	f240 8089 	bls.w	108d2 <SEGGER_SYSVIEW_SendTaskInfo+0x1be>
   107c0:	2900      	cmp	r1, #0
   107c2:	bf14      	ite	ne
   107c4:	4652      	movne	r2, sl
   107c6:	2201      	moveq	r2, #1
   107c8:	9201      	str	r2, [sp, #4]
   107ca:	ea4f 0bd2 	mov.w	fp, r2, lsr #3
   107ce:	f1a0 0908 	sub.w	r9, r0, #8
   107d2:	f10c 0201 	add.w	r2, ip, #1
   107d6:	46e6      	mov	lr, ip
    *pPayload++ = *pText++;
   107d8:	e9f9 6702 	ldrd	r6, r7, [r9, #8]!
   107dc:	3301      	adds	r3, #1
   107de:	4611      	mov	r1, r2
   107e0:	459b      	cmp	fp, r3
   107e2:	e8ee 6702 	strd	r6, r7, [lr], #8
   107e6:	f101 0107 	add.w	r1, r1, #7
   107ea:	f102 0208 	add.w	r2, r2, #8
   107ee:	d8f3      	bhi.n	107d8 <SEGGER_SYSVIEW_SendTaskInfo+0xc4>
   107f0:	9f01      	ldr	r7, [sp, #4]
   107f2:	f027 0307 	bic.w	r3, r7, #7
   107f6:	429f      	cmp	r7, r3
   107f8:	eb00 0603 	add.w	r6, r0, r3
   107fc:	eb0c 0203 	add.w	r2, ip, r3
   10800:	d02d      	beq.n	1085e <SEGGER_SYSVIEW_SendTaskInfo+0x14a>
   10802:	5cc1      	ldrb	r1, [r0, r3]
   10804:	f80c 1003 	strb.w	r1, [ip, r3]
    n++;
   10808:	1c58      	adds	r0, r3, #1
  while (n < Len) {
   1080a:	4550      	cmp	r0, sl
    *pPayload++ = *pText++;
   1080c:	f102 0101 	add.w	r1, r2, #1
  while (n < Len) {
   10810:	d225      	bcs.n	1085e <SEGGER_SYSVIEW_SendTaskInfo+0x14a>
    n++;
   10812:	1c98      	adds	r0, r3, #2
    *pPayload++ = *pText++;
   10814:	7871      	ldrb	r1, [r6, #1]
   10816:	7051      	strb	r1, [r2, #1]
  while (n < Len) {
   10818:	4582      	cmp	sl, r0
    *pPayload++ = *pText++;
   1081a:	f102 0102 	add.w	r1, r2, #2
  while (n < Len) {
   1081e:	d91e      	bls.n	1085e <SEGGER_SYSVIEW_SendTaskInfo+0x14a>
    n++;
   10820:	1cd8      	adds	r0, r3, #3
    *pPayload++ = *pText++;
   10822:	78b1      	ldrb	r1, [r6, #2]
   10824:	7091      	strb	r1, [r2, #2]
  while (n < Len) {
   10826:	4582      	cmp	sl, r0
    *pPayload++ = *pText++;
   10828:	f102 0103 	add.w	r1, r2, #3
  while (n < Len) {
   1082c:	d917      	bls.n	1085e <SEGGER_SYSVIEW_SendTaskInfo+0x14a>
    n++;
   1082e:	1d18      	adds	r0, r3, #4
    *pPayload++ = *pText++;
   10830:	78f1      	ldrb	r1, [r6, #3]
   10832:	70d1      	strb	r1, [r2, #3]
  while (n < Len) {
   10834:	4582      	cmp	sl, r0
    *pPayload++ = *pText++;
   10836:	f102 0104 	add.w	r1, r2, #4
  while (n < Len) {
   1083a:	d910      	bls.n	1085e <SEGGER_SYSVIEW_SendTaskInfo+0x14a>
    n++;
   1083c:	1d58      	adds	r0, r3, #5
    *pPayload++ = *pText++;
   1083e:	7931      	ldrb	r1, [r6, #4]
   10840:	7111      	strb	r1, [r2, #4]
  while (n < Len) {
   10842:	4582      	cmp	sl, r0
    *pPayload++ = *pText++;
   10844:	f102 0105 	add.w	r1, r2, #5
  while (n < Len) {
   10848:	d909      	bls.n	1085e <SEGGER_SYSVIEW_SendTaskInfo+0x14a>
    n++;
   1084a:	3306      	adds	r3, #6
    *pPayload++ = *pText++;
   1084c:	7971      	ldrb	r1, [r6, #5]
   1084e:	7151      	strb	r1, [r2, #5]
  while (n < Len) {
   10850:	459a      	cmp	sl, r3
    *pPayload++ = *pText++;
   10852:	f102 0106 	add.w	r1, r2, #6
  while (n < Len) {
   10856:	d902      	bls.n	1085e <SEGGER_SYSVIEW_SendTaskInfo+0x14a>
    *pPayload++ = *pText++;
   10858:	79b3      	ldrb	r3, [r6, #6]
   1085a:	7193      	strb	r3, [r2, #6]
   1085c:	1dd1      	adds	r1, r2, #7
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_INFO);
   1085e:	2209      	movs	r2, #9
   10860:	4823      	ldr	r0, [pc, #140]	; (108f0 <SEGGER_SYSVIEW_SendTaskInfo+0x1dc>)
   10862:	f7ff fea9 	bl	105b8 <_SendPacket>
  ENCODE_U32(pPayload, SHRINK_ID(pInfo->TaskID));
   10866:	f8d8 2010 	ldr.w	r2, [r8, #16]
   1086a:	682b      	ldr	r3, [r5, #0]
   1086c:	1a9b      	subs	r3, r3, r2
   1086e:	089b      	lsrs	r3, r3, #2
   10870:	2b7f      	cmp	r3, #127	; 0x7f
   10872:	d906      	bls.n	10882 <SEGGER_SYSVIEW_SendTaskInfo+0x16e>
   10874:	f063 027f 	orn	r2, r3, #127	; 0x7f
   10878:	09db      	lsrs	r3, r3, #7
   1087a:	2b7f      	cmp	r3, #127	; 0x7f
   1087c:	f804 2b01 	strb.w	r2, [r4], #1
   10880:	d8f8      	bhi.n	10874 <SEGGER_SYSVIEW_SendTaskInfo+0x160>
   10882:	7023      	strb	r3, [r4, #0]
  ENCODE_U32(pPayload, pInfo->StackBase);
   10884:	68eb      	ldr	r3, [r5, #12]
   10886:	2b7f      	cmp	r3, #127	; 0x7f
  ENCODE_U32(pPayload, SHRINK_ID(pInfo->TaskID));
   10888:	f104 0401 	add.w	r4, r4, #1
  ENCODE_U32(pPayload, pInfo->StackBase);
   1088c:	d906      	bls.n	1089c <SEGGER_SYSVIEW_SendTaskInfo+0x188>
   1088e:	f063 027f 	orn	r2, r3, #127	; 0x7f
   10892:	09db      	lsrs	r3, r3, #7
   10894:	2b7f      	cmp	r3, #127	; 0x7f
   10896:	f804 2b01 	strb.w	r2, [r4], #1
   1089a:	d8f8      	bhi.n	1088e <SEGGER_SYSVIEW_SendTaskInfo+0x17a>
   1089c:	7023      	strb	r3, [r4, #0]
  ENCODE_U32(pPayload, pInfo->StackSize);
   1089e:	692b      	ldr	r3, [r5, #16]
   108a0:	2b7f      	cmp	r3, #127	; 0x7f
  ENCODE_U32(pPayload, pInfo->StackBase);
   108a2:	f104 0401 	add.w	r4, r4, #1
  ENCODE_U32(pPayload, pInfo->StackSize);
   108a6:	d906      	bls.n	108b6 <SEGGER_SYSVIEW_SendTaskInfo+0x1a2>
   108a8:	f063 027f 	orn	r2, r3, #127	; 0x7f
   108ac:	09db      	lsrs	r3, r3, #7
   108ae:	2b7f      	cmp	r3, #127	; 0x7f
   108b0:	f804 2b01 	strb.w	r2, [r4], #1
   108b4:	d8f8      	bhi.n	108a8 <SEGGER_SYSVIEW_SendTaskInfo+0x194>
  ENCODE_U32(pPayload, 0); // Stack End, future use
   108b6:	2500      	movs	r5, #0
  ENCODE_U32(pPayload, pInfo->StackSize);
   108b8:	7023      	strb	r3, [r4, #0]
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_STACK_INFO);
   108ba:	1ca1      	adds	r1, r4, #2
   108bc:	2215      	movs	r2, #21
   108be:	480c      	ldr	r0, [pc, #48]	; (108f0 <SEGGER_SYSVIEW_SendTaskInfo+0x1dc>)
  ENCODE_U32(pPayload, 0); // Stack End, future use
   108c0:	7065      	strb	r5, [r4, #1]
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_STACK_INFO);
   108c2:	f7ff fe79 	bl	105b8 <_SendPacket>
  RECORD_END();
   108c6:	9b00      	ldr	r3, [sp, #0]
   108c8:	f383 8811 	msr	BASEPRI, r3
}
   108cc:	b003      	add	sp, #12
   108ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   108d2:	3801      	subs	r0, #1
    *pPayload++ = Len; 
   108d4:	4661      	mov	r1, ip
    *pPayload++ = *pText++;
   108d6:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   108da:	f801 3b01 	strb.w	r3, [r1], #1
  while (n < Len) {
   108de:	eba1 030c 	sub.w	r3, r1, ip
   108e2:	459a      	cmp	sl, r3
   108e4:	d8f7      	bhi.n	108d6 <SEGGER_SYSVIEW_SendTaskInfo+0x1c2>
   108e6:	e7ba      	b.n	1085e <SEGGER_SYSVIEW_SendTaskInfo+0x14a>
    *pPayload++ = Len; 
   108e8:	7053      	strb	r3, [r2, #1]
   108ea:	4661      	mov	r1, ip
   108ec:	e7b7      	b.n	1085e <SEGGER_SYSVIEW_SendTaskInfo+0x14a>
   108ee:	bf00      	nop
   108f0:	1001326c 	.word	0x1001326c
   108f4:	10013240 	.word	0x10013240

000108f8 <SEGGER_SYSVIEW_RecordExitISR>:
void SEGGER_SYSVIEW_RecordExitISR(void) {
   108f8:	b570      	push	{r4, r5, r6, lr}
   108fa:	b084      	sub	sp, #16
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
   108fc:	f3ef 8511 	mrs	r5, BASEPRI
   10900:	f04f 0120 	mov.w	r1, #32
   10904:	f381 8811 	msr	BASEPRI, r1
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   10908:	4c3b      	ldr	r4, [pc, #236]	; (109f8 <SEGGER_SYSVIEW_RecordExitISR+0x100>)
   1090a:	7823      	ldrb	r3, [r4, #0]
   1090c:	2b01      	cmp	r3, #1
   1090e:	d00f      	beq.n	10930 <SEGGER_SYSVIEW_RecordExitISR+0x38>
  if (_SYSVIEW_Globals.EnableState == 0) {
   10910:	b963      	cbnz	r3, 1092c <SEGGER_SYSVIEW_RecordExitISR+0x34>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   10912:	4b3a      	ldr	r3, [pc, #232]	; (109fc <SEGGER_SYSVIEW_RecordExitISR+0x104>)
   10914:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   10918:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   1091c:	429a      	cmp	r2, r3
   1091e:	d001      	beq.n	10924 <SEGGER_SYSVIEW_RecordExitISR+0x2c>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   10920:	78a6      	ldrb	r6, [r4, #2]
   10922:	b32e      	cbz	r6, 10970 <SEGGER_SYSVIEW_RecordExitISR+0x78>
  RECORD_END();
   10924:	f385 8811 	msr	BASEPRI, r5
}
   10928:	b004      	add	sp, #16
   1092a:	bd70      	pop	{r4, r5, r6, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   1092c:	2b02      	cmp	r3, #2
   1092e:	d02c      	beq.n	1098a <SEGGER_SYSVIEW_RecordExitISR+0x92>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   10930:	69e3      	ldr	r3, [r4, #28]
   10932:	071b      	lsls	r3, r3, #28
   10934:	d4ed      	bmi.n	10912 <SEGGER_SYSVIEW_RecordExitISR+0x1a>
    *--pStartPacket = EventId;
   10936:	4a32      	ldr	r2, [pc, #200]	; (10a00 <SEGGER_SYSVIEW_RecordExitISR+0x108>)
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10938:	4932      	ldr	r1, [pc, #200]	; (10a04 <SEGGER_SYSVIEW_RecordExitISR+0x10c>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   1093a:	68e3      	ldr	r3, [r4, #12]
    *--pStartPacket = EventId;
   1093c:	2003      	movs	r0, #3
   1093e:	70d0      	strb	r0, [r2, #3]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10940:	680e      	ldr	r6, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   10942:	1af3      	subs	r3, r6, r3
  ENCODE_U32(pEndPacket, Delta);
   10944:	2b7f      	cmp	r3, #127	; 0x7f
   10946:	f102 0204 	add.w	r2, r2, #4
   1094a:	d906      	bls.n	1095a <SEGGER_SYSVIEW_RecordExitISR+0x62>
   1094c:	f063 017f 	orn	r1, r3, #127	; 0x7f
   10950:	09db      	lsrs	r3, r3, #7
   10952:	2b7f      	cmp	r3, #127	; 0x7f
   10954:	f802 1b01 	strb.w	r1, [r2], #1
   10958:	d8f8      	bhi.n	1094c <SEGGER_SYSVIEW_RecordExitISR+0x54>
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   1095a:	482b      	ldr	r0, [pc, #172]	; (10a08 <SEGGER_SYSVIEW_RecordExitISR+0x110>)
  ENCODE_U32(pEndPacket, Delta);
   1095c:	f802 3b01 	strb.w	r3, [r2], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   10960:	4601      	mov	r1, r0
   10962:	1a12      	subs	r2, r2, r0
   10964:	2001      	movs	r0, #1
   10966:	f7ff fb0b 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   1096a:	b150      	cbz	r0, 10982 <SEGGER_SYSVIEW_RecordExitISR+0x8a>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   1096c:	60e6      	str	r6, [r4, #12]
   1096e:	e7d0      	b.n	10912 <SEGGER_SYSVIEW_RecordExitISR+0x1a>
      _SYSVIEW_Globals.RecursionCnt = 1;
   10970:	2301      	movs	r3, #1
   10972:	70a3      	strb	r3, [r4, #2]
      _HandleIncomingPacket();
   10974:	f7ff fd92 	bl	1049c <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   10978:	70a6      	strb	r6, [r4, #2]
  RECORD_END();
   1097a:	f385 8811 	msr	BASEPRI, r5
}
   1097e:	b004      	add	sp, #16
   10980:	bd70      	pop	{r4, r5, r6, pc}
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   10982:	7823      	ldrb	r3, [r4, #0]
   10984:	3301      	adds	r3, #1
   10986:	7023      	strb	r3, [r4, #0]
   10988:	e7c3      	b.n	10912 <SEGGER_SYSVIEW_RecordExitISR+0x1a>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   1098a:	6962      	ldr	r2, [r4, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   1098c:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   1098e:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   10990:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10994:	f10d 0305 	add.w	r3, sp, #5
   10998:	d906      	bls.n	109a8 <SEGGER_SYSVIEW_RecordExitISR+0xb0>
   1099a:	f062 017f 	orn	r1, r2, #127	; 0x7f
   1099e:	09d2      	lsrs	r2, r2, #7
   109a0:	2a7f      	cmp	r2, #127	; 0x7f
   109a2:	f803 1b01 	strb.w	r1, [r3], #1
   109a6:	d8f8      	bhi.n	1099a <SEGGER_SYSVIEW_RecordExitISR+0xa2>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   109a8:	4916      	ldr	r1, [pc, #88]	; (10a04 <SEGGER_SYSVIEW_RecordExitISR+0x10c>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   109aa:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   109ac:	680e      	ldr	r6, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   109ae:	68e1      	ldr	r1, [r4, #12]
   109b0:	1a71      	subs	r1, r6, r1
  ENCODE_U32(pPayload, Delta);
   109b2:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   109b4:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   109b8:	d906      	bls.n	109c8 <SEGGER_SYSVIEW_RecordExitISR+0xd0>
   109ba:	f061 037f 	orn	r3, r1, #127	; 0x7f
   109be:	09c9      	lsrs	r1, r1, #7
   109c0:	297f      	cmp	r1, #127	; 0x7f
   109c2:	f802 3b01 	strb.w	r3, [r2], #1
   109c6:	d8f8      	bhi.n	109ba <SEGGER_SYSVIEW_RecordExitISR+0xc2>
   109c8:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   109ca:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   109cc:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   109d0:	2001      	movs	r0, #1
   109d2:	4611      	mov	r1, r2
   109d4:	1a9a      	subs	r2, r3, r2
   109d6:	f7ff fad3 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   109da:	b930      	cbnz	r0, 109ea <SEGGER_SYSVIEW_RecordExitISR+0xf2>
    _SYSVIEW_Globals.DropCount++;
   109dc:	6962      	ldr	r2, [r4, #20]
   109de:	7823      	ldrb	r3, [r4, #0]
   109e0:	3201      	adds	r2, #1
   109e2:	6162      	str	r2, [r4, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   109e4:	2b01      	cmp	r3, #1
   109e6:	d194      	bne.n	10912 <SEGGER_SYSVIEW_RecordExitISR+0x1a>
   109e8:	e7a2      	b.n	10930 <SEGGER_SYSVIEW_RecordExitISR+0x38>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   109ea:	7823      	ldrb	r3, [r4, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   109ec:	60e6      	str	r6, [r4, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   109ee:	3b01      	subs	r3, #1
   109f0:	b2db      	uxtb	r3, r3
   109f2:	7023      	strb	r3, [r4, #0]
   109f4:	e7f6      	b.n	109e4 <SEGGER_SYSVIEW_RecordExitISR+0xec>
   109f6:	bf00      	nop
   109f8:	10013240 	.word	0x10013240
   109fc:	1001341c 	.word	0x1001341c
   10a00:	10013268 	.word	0x10013268
   10a04:	e0001004 	.word	0xe0001004
   10a08:	1001326b 	.word	0x1001326b

00010a0c <SEGGER_SYSVIEW_OnIdle>:
void SEGGER_SYSVIEW_OnIdle(void) {
   10a0c:	b570      	push	{r4, r5, r6, lr}
   10a0e:	b084      	sub	sp, #16
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
   10a10:	f3ef 8511 	mrs	r5, BASEPRI
   10a14:	f04f 0120 	mov.w	r1, #32
   10a18:	f381 8811 	msr	BASEPRI, r1
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   10a1c:	4c3b      	ldr	r4, [pc, #236]	; (10b0c <SEGGER_SYSVIEW_OnIdle+0x100>)
   10a1e:	7823      	ldrb	r3, [r4, #0]
   10a20:	2b01      	cmp	r3, #1
   10a22:	d00f      	beq.n	10a44 <SEGGER_SYSVIEW_OnIdle+0x38>
  if (_SYSVIEW_Globals.EnableState == 0) {
   10a24:	b963      	cbnz	r3, 10a40 <SEGGER_SYSVIEW_OnIdle+0x34>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   10a26:	4b3a      	ldr	r3, [pc, #232]	; (10b10 <SEGGER_SYSVIEW_OnIdle+0x104>)
   10a28:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   10a2c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   10a30:	429a      	cmp	r2, r3
   10a32:	d001      	beq.n	10a38 <SEGGER_SYSVIEW_OnIdle+0x2c>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   10a34:	78a6      	ldrb	r6, [r4, #2]
   10a36:	b32e      	cbz	r6, 10a84 <SEGGER_SYSVIEW_OnIdle+0x78>
  RECORD_END();
   10a38:	f385 8811 	msr	BASEPRI, r5
}
   10a3c:	b004      	add	sp, #16
   10a3e:	bd70      	pop	{r4, r5, r6, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   10a40:	2b02      	cmp	r3, #2
   10a42:	d02c      	beq.n	10a9e <SEGGER_SYSVIEW_OnIdle+0x92>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   10a44:	69e3      	ldr	r3, [r4, #28]
   10a46:	039b      	lsls	r3, r3, #14
   10a48:	d4ed      	bmi.n	10a26 <SEGGER_SYSVIEW_OnIdle+0x1a>
    *--pStartPacket = EventId;
   10a4a:	4a32      	ldr	r2, [pc, #200]	; (10b14 <SEGGER_SYSVIEW_OnIdle+0x108>)
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10a4c:	4932      	ldr	r1, [pc, #200]	; (10b18 <SEGGER_SYSVIEW_OnIdle+0x10c>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   10a4e:	68e3      	ldr	r3, [r4, #12]
    *--pStartPacket = EventId;
   10a50:	2011      	movs	r0, #17
   10a52:	70d0      	strb	r0, [r2, #3]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10a54:	680e      	ldr	r6, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   10a56:	1af3      	subs	r3, r6, r3
  ENCODE_U32(pEndPacket, Delta);
   10a58:	2b7f      	cmp	r3, #127	; 0x7f
   10a5a:	f102 0204 	add.w	r2, r2, #4
   10a5e:	d906      	bls.n	10a6e <SEGGER_SYSVIEW_OnIdle+0x62>
   10a60:	f063 017f 	orn	r1, r3, #127	; 0x7f
   10a64:	09db      	lsrs	r3, r3, #7
   10a66:	2b7f      	cmp	r3, #127	; 0x7f
   10a68:	f802 1b01 	strb.w	r1, [r2], #1
   10a6c:	d8f8      	bhi.n	10a60 <SEGGER_SYSVIEW_OnIdle+0x54>
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   10a6e:	482b      	ldr	r0, [pc, #172]	; (10b1c <SEGGER_SYSVIEW_OnIdle+0x110>)
  ENCODE_U32(pEndPacket, Delta);
   10a70:	f802 3b01 	strb.w	r3, [r2], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   10a74:	4601      	mov	r1, r0
   10a76:	1a12      	subs	r2, r2, r0
   10a78:	2001      	movs	r0, #1
   10a7a:	f7ff fa81 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   10a7e:	b150      	cbz	r0, 10a96 <SEGGER_SYSVIEW_OnIdle+0x8a>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   10a80:	60e6      	str	r6, [r4, #12]
   10a82:	e7d0      	b.n	10a26 <SEGGER_SYSVIEW_OnIdle+0x1a>
      _SYSVIEW_Globals.RecursionCnt = 1;
   10a84:	2301      	movs	r3, #1
   10a86:	70a3      	strb	r3, [r4, #2]
      _HandleIncomingPacket();
   10a88:	f7ff fd08 	bl	1049c <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   10a8c:	70a6      	strb	r6, [r4, #2]
  RECORD_END();
   10a8e:	f385 8811 	msr	BASEPRI, r5
}
   10a92:	b004      	add	sp, #16
   10a94:	bd70      	pop	{r4, r5, r6, pc}
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   10a96:	7823      	ldrb	r3, [r4, #0]
   10a98:	3301      	adds	r3, #1
   10a9a:	7023      	strb	r3, [r4, #0]
   10a9c:	e7c3      	b.n	10a26 <SEGGER_SYSVIEW_OnIdle+0x1a>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10a9e:	6962      	ldr	r2, [r4, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   10aa0:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10aa2:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   10aa4:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10aa8:	f10d 0305 	add.w	r3, sp, #5
   10aac:	d906      	bls.n	10abc <SEGGER_SYSVIEW_OnIdle+0xb0>
   10aae:	f062 017f 	orn	r1, r2, #127	; 0x7f
   10ab2:	09d2      	lsrs	r2, r2, #7
   10ab4:	2a7f      	cmp	r2, #127	; 0x7f
   10ab6:	f803 1b01 	strb.w	r1, [r3], #1
   10aba:	d8f8      	bhi.n	10aae <SEGGER_SYSVIEW_OnIdle+0xa2>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10abc:	4916      	ldr	r1, [pc, #88]	; (10b18 <SEGGER_SYSVIEW_OnIdle+0x10c>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10abe:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10ac0:	680e      	ldr	r6, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   10ac2:	68e1      	ldr	r1, [r4, #12]
   10ac4:	1a71      	subs	r1, r6, r1
  ENCODE_U32(pPayload, Delta);
   10ac6:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10ac8:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   10acc:	d906      	bls.n	10adc <SEGGER_SYSVIEW_OnIdle+0xd0>
   10ace:	f061 037f 	orn	r3, r1, #127	; 0x7f
   10ad2:	09c9      	lsrs	r1, r1, #7
   10ad4:	297f      	cmp	r1, #127	; 0x7f
   10ad6:	f802 3b01 	strb.w	r3, [r2], #1
   10ada:	d8f8      	bhi.n	10ace <SEGGER_SYSVIEW_OnIdle+0xc2>
   10adc:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   10ade:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   10ae0:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   10ae4:	2001      	movs	r0, #1
   10ae6:	4611      	mov	r1, r2
   10ae8:	1a9a      	subs	r2, r3, r2
   10aea:	f7ff fa49 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   10aee:	b930      	cbnz	r0, 10afe <SEGGER_SYSVIEW_OnIdle+0xf2>
    _SYSVIEW_Globals.DropCount++;
   10af0:	6962      	ldr	r2, [r4, #20]
   10af2:	7823      	ldrb	r3, [r4, #0]
   10af4:	3201      	adds	r2, #1
   10af6:	6162      	str	r2, [r4, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   10af8:	2b01      	cmp	r3, #1
   10afa:	d194      	bne.n	10a26 <SEGGER_SYSVIEW_OnIdle+0x1a>
   10afc:	e7a2      	b.n	10a44 <SEGGER_SYSVIEW_OnIdle+0x38>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   10afe:	7823      	ldrb	r3, [r4, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   10b00:	60e6      	str	r6, [r4, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   10b02:	3b01      	subs	r3, #1
   10b04:	b2db      	uxtb	r3, r3
   10b06:	7023      	strb	r3, [r4, #0]
   10b08:	e7f6      	b.n	10af8 <SEGGER_SYSVIEW_OnIdle+0xec>
   10b0a:	bf00      	nop
   10b0c:	10013240 	.word	0x10013240
   10b10:	1001341c 	.word	0x1001341c
   10b14:	10013268 	.word	0x10013268
   10b18:	e0001004 	.word	0xe0001004
   10b1c:	1001326b 	.word	0x1001326b

00010b20 <SEGGER_SYSVIEW_RecordExitISRToScheduler>:
void SEGGER_SYSVIEW_RecordExitISRToScheduler(void) {
   10b20:	b570      	push	{r4, r5, r6, lr}
   10b22:	b084      	sub	sp, #16
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
   10b24:	f3ef 8511 	mrs	r5, BASEPRI
   10b28:	f04f 0120 	mov.w	r1, #32
   10b2c:	f381 8811 	msr	BASEPRI, r1
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   10b30:	4c3b      	ldr	r4, [pc, #236]	; (10c20 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x100>)
   10b32:	7823      	ldrb	r3, [r4, #0]
   10b34:	2b01      	cmp	r3, #1
   10b36:	d00f      	beq.n	10b58 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x38>
  if (_SYSVIEW_Globals.EnableState == 0) {
   10b38:	b963      	cbnz	r3, 10b54 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x34>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   10b3a:	4b3a      	ldr	r3, [pc, #232]	; (10c24 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x104>)
   10b3c:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   10b40:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   10b44:	429a      	cmp	r2, r3
   10b46:	d001      	beq.n	10b4c <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x2c>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   10b48:	78a6      	ldrb	r6, [r4, #2]
   10b4a:	b32e      	cbz	r6, 10b98 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x78>
  RECORD_END();
   10b4c:	f385 8811 	msr	BASEPRI, r5
}
   10b50:	b004      	add	sp, #16
   10b52:	bd70      	pop	{r4, r5, r6, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   10b54:	2b02      	cmp	r3, #2
   10b56:	d02c      	beq.n	10bb2 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x92>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   10b58:	69e3      	ldr	r3, [r4, #28]
   10b5a:	035b      	lsls	r3, r3, #13
   10b5c:	d4ed      	bmi.n	10b3a <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x1a>
    *--pStartPacket = EventId;
   10b5e:	4a32      	ldr	r2, [pc, #200]	; (10c28 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x108>)
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10b60:	4932      	ldr	r1, [pc, #200]	; (10c2c <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x10c>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   10b62:	68e3      	ldr	r3, [r4, #12]
    *--pStartPacket = EventId;
   10b64:	2012      	movs	r0, #18
   10b66:	70d0      	strb	r0, [r2, #3]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10b68:	680e      	ldr	r6, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   10b6a:	1af3      	subs	r3, r6, r3
  ENCODE_U32(pEndPacket, Delta);
   10b6c:	2b7f      	cmp	r3, #127	; 0x7f
   10b6e:	f102 0204 	add.w	r2, r2, #4
   10b72:	d906      	bls.n	10b82 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x62>
   10b74:	f063 017f 	orn	r1, r3, #127	; 0x7f
   10b78:	09db      	lsrs	r3, r3, #7
   10b7a:	2b7f      	cmp	r3, #127	; 0x7f
   10b7c:	f802 1b01 	strb.w	r1, [r2], #1
   10b80:	d8f8      	bhi.n	10b74 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x54>
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   10b82:	482b      	ldr	r0, [pc, #172]	; (10c30 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x110>)
  ENCODE_U32(pEndPacket, Delta);
   10b84:	f802 3b01 	strb.w	r3, [r2], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   10b88:	4601      	mov	r1, r0
   10b8a:	1a12      	subs	r2, r2, r0
   10b8c:	2001      	movs	r0, #1
   10b8e:	f7ff f9f7 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   10b92:	b150      	cbz	r0, 10baa <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x8a>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   10b94:	60e6      	str	r6, [r4, #12]
   10b96:	e7d0      	b.n	10b3a <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x1a>
      _SYSVIEW_Globals.RecursionCnt = 1;
   10b98:	2301      	movs	r3, #1
   10b9a:	70a3      	strb	r3, [r4, #2]
      _HandleIncomingPacket();
   10b9c:	f7ff fc7e 	bl	1049c <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   10ba0:	70a6      	strb	r6, [r4, #2]
  RECORD_END();
   10ba2:	f385 8811 	msr	BASEPRI, r5
}
   10ba6:	b004      	add	sp, #16
   10ba8:	bd70      	pop	{r4, r5, r6, pc}
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   10baa:	7823      	ldrb	r3, [r4, #0]
   10bac:	3301      	adds	r3, #1
   10bae:	7023      	strb	r3, [r4, #0]
   10bb0:	e7c3      	b.n	10b3a <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x1a>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10bb2:	6962      	ldr	r2, [r4, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   10bb4:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10bb6:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   10bb8:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10bbc:	f10d 0305 	add.w	r3, sp, #5
   10bc0:	d906      	bls.n	10bd0 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0xb0>
   10bc2:	f062 017f 	orn	r1, r2, #127	; 0x7f
   10bc6:	09d2      	lsrs	r2, r2, #7
   10bc8:	2a7f      	cmp	r2, #127	; 0x7f
   10bca:	f803 1b01 	strb.w	r1, [r3], #1
   10bce:	d8f8      	bhi.n	10bc2 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0xa2>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10bd0:	4916      	ldr	r1, [pc, #88]	; (10c2c <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x10c>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10bd2:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10bd4:	680e      	ldr	r6, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   10bd6:	68e1      	ldr	r1, [r4, #12]
   10bd8:	1a71      	subs	r1, r6, r1
  ENCODE_U32(pPayload, Delta);
   10bda:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10bdc:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   10be0:	d906      	bls.n	10bf0 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0xd0>
   10be2:	f061 037f 	orn	r3, r1, #127	; 0x7f
   10be6:	09c9      	lsrs	r1, r1, #7
   10be8:	297f      	cmp	r1, #127	; 0x7f
   10bea:	f802 3b01 	strb.w	r3, [r2], #1
   10bee:	d8f8      	bhi.n	10be2 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0xc2>
   10bf0:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   10bf2:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   10bf4:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   10bf8:	2001      	movs	r0, #1
   10bfa:	4611      	mov	r1, r2
   10bfc:	1a9a      	subs	r2, r3, r2
   10bfe:	f7ff f9bf 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   10c02:	b930      	cbnz	r0, 10c12 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0xf2>
    _SYSVIEW_Globals.DropCount++;
   10c04:	6962      	ldr	r2, [r4, #20]
   10c06:	7823      	ldrb	r3, [r4, #0]
   10c08:	3201      	adds	r2, #1
   10c0a:	6162      	str	r2, [r4, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   10c0c:	2b01      	cmp	r3, #1
   10c0e:	d194      	bne.n	10b3a <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x1a>
   10c10:	e7a2      	b.n	10b58 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x38>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   10c12:	7823      	ldrb	r3, [r4, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   10c14:	60e6      	str	r6, [r4, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   10c16:	3b01      	subs	r3, #1
   10c18:	b2db      	uxtb	r3, r3
   10c1a:	7023      	strb	r3, [r4, #0]
   10c1c:	e7f6      	b.n	10c0c <SEGGER_SYSVIEW_RecordExitISRToScheduler+0xec>
   10c1e:	bf00      	nop
   10c20:	10013240 	.word	0x10013240
   10c24:	1001341c 	.word	0x1001341c
   10c28:	10013268 	.word	0x10013268
   10c2c:	e0001004 	.word	0xe0001004
   10c30:	1001326b 	.word	0x1001326b

00010c34 <SEGGER_SYSVIEW_RecordEnterISR>:
void SEGGER_SYSVIEW_RecordEnterISR(void) {
   10c34:	b5f0      	push	{r4, r5, r6, r7, lr}
   10c36:	b085      	sub	sp, #20
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
   10c38:	f3ef 8511 	mrs	r5, BASEPRI
   10c3c:	f04f 0120 	mov.w	r1, #32
   10c40:	f381 8811 	msr	BASEPRI, r1
  v = SEGGER_SYSVIEW_GET_INTERRUPT_ID();
   10c44:	4b42      	ldr	r3, [pc, #264]	; (10d50 <SEGGER_SYSVIEW_RecordEnterISR+0x11c>)
   10c46:	681b      	ldr	r3, [r3, #0]
   10c48:	f3c3 0308 	ubfx	r3, r3, #0, #9
  ENCODE_U32(pPayload, v);
   10c4c:	2b7f      	cmp	r3, #127	; 0x7f
   10c4e:	d977      	bls.n	10d40 <SEGGER_SYSVIEW_RecordEnterISR+0x10c>
   10c50:	4c40      	ldr	r4, [pc, #256]	; (10d54 <SEGGER_SYSVIEW_RecordEnterISR+0x120>)
   10c52:	f063 017f 	orn	r1, r3, #127	; 0x7f
   10c56:	7121      	strb	r1, [r4, #4]
   10c58:	09db      	lsrs	r3, r3, #7
   10c5a:	3405      	adds	r4, #5
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   10c5c:	4e3e      	ldr	r6, [pc, #248]	; (10d58 <SEGGER_SYSVIEW_RecordEnterISR+0x124>)
  ENCODE_U32(pPayload, v);
   10c5e:	7023      	strb	r3, [r4, #0]
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   10c60:	7833      	ldrb	r3, [r6, #0]
   10c62:	2b01      	cmp	r3, #1
   10c64:	d00f      	beq.n	10c86 <SEGGER_SYSVIEW_RecordEnterISR+0x52>
  if (_SYSVIEW_Globals.EnableState == 0) {
   10c66:	b963      	cbnz	r3, 10c82 <SEGGER_SYSVIEW_RecordEnterISR+0x4e>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   10c68:	4b3c      	ldr	r3, [pc, #240]	; (10d5c <SEGGER_SYSVIEW_RecordEnterISR+0x128>)
   10c6a:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   10c6e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   10c72:	429a      	cmp	r2, r3
   10c74:	d001      	beq.n	10c7a <SEGGER_SYSVIEW_RecordEnterISR+0x46>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   10c76:	78b4      	ldrb	r4, [r6, #2]
   10c78:	b32c      	cbz	r4, 10cc6 <SEGGER_SYSVIEW_RecordEnterISR+0x92>
  RECORD_END();
   10c7a:	f385 8811 	msr	BASEPRI, r5
}
   10c7e:	b005      	add	sp, #20
   10c80:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   10c82:	2b02      	cmp	r3, #2
   10c84:	d02c      	beq.n	10ce0 <SEGGER_SYSVIEW_RecordEnterISR+0xac>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   10c86:	69f3      	ldr	r3, [r6, #28]
   10c88:	075b      	lsls	r3, r3, #29
   10c8a:	d4ed      	bmi.n	10c68 <SEGGER_SYSVIEW_RecordEnterISR+0x34>
    *--pStartPacket = EventId;
   10c8c:	4a31      	ldr	r2, [pc, #196]	; (10d54 <SEGGER_SYSVIEW_RecordEnterISR+0x120>)
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10c8e:	4b34      	ldr	r3, [pc, #208]	; (10d60 <SEGGER_SYSVIEW_RecordEnterISR+0x12c>)
    *--pStartPacket = EventId;
   10c90:	2102      	movs	r1, #2
   10c92:	70d1      	strb	r1, [r2, #3]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10c94:	681f      	ldr	r7, [r3, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   10c96:	68f3      	ldr	r3, [r6, #12]
   10c98:	1afb      	subs	r3, r7, r3
  ENCODE_U32(pEndPacket, Delta);
   10c9a:	2b7f      	cmp	r3, #127	; 0x7f
  ENCODE_U32(pPayload, v);
   10c9c:	f104 0201 	add.w	r2, r4, #1
  ENCODE_U32(pEndPacket, Delta);
   10ca0:	d906      	bls.n	10cb0 <SEGGER_SYSVIEW_RecordEnterISR+0x7c>
   10ca2:	f063 017f 	orn	r1, r3, #127	; 0x7f
   10ca6:	09db      	lsrs	r3, r3, #7
   10ca8:	2b7f      	cmp	r3, #127	; 0x7f
   10caa:	f802 1b01 	strb.w	r1, [r2], #1
   10cae:	d8f8      	bhi.n	10ca2 <SEGGER_SYSVIEW_RecordEnterISR+0x6e>
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   10cb0:	482c      	ldr	r0, [pc, #176]	; (10d64 <SEGGER_SYSVIEW_RecordEnterISR+0x130>)
  ENCODE_U32(pEndPacket, Delta);
   10cb2:	f802 3b01 	strb.w	r3, [r2], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   10cb6:	4601      	mov	r1, r0
   10cb8:	1a12      	subs	r2, r2, r0
   10cba:	2001      	movs	r0, #1
   10cbc:	f7ff f960 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   10cc0:	b150      	cbz	r0, 10cd8 <SEGGER_SYSVIEW_RecordEnterISR+0xa4>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   10cc2:	60f7      	str	r7, [r6, #12]
   10cc4:	e7d0      	b.n	10c68 <SEGGER_SYSVIEW_RecordEnterISR+0x34>
      _SYSVIEW_Globals.RecursionCnt = 1;
   10cc6:	2301      	movs	r3, #1
   10cc8:	70b3      	strb	r3, [r6, #2]
      _HandleIncomingPacket();
   10cca:	f7ff fbe7 	bl	1049c <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   10cce:	70b4      	strb	r4, [r6, #2]
  RECORD_END();
   10cd0:	f385 8811 	msr	BASEPRI, r5
}
   10cd4:	b005      	add	sp, #20
   10cd6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   10cd8:	7833      	ldrb	r3, [r6, #0]
   10cda:	3301      	adds	r3, #1
   10cdc:	7033      	strb	r3, [r6, #0]
   10cde:	e7c3      	b.n	10c68 <SEGGER_SYSVIEW_RecordEnterISR+0x34>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10ce0:	6972      	ldr	r2, [r6, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   10ce2:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10ce4:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   10ce6:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10cea:	f10d 0305 	add.w	r3, sp, #5
   10cee:	d906      	bls.n	10cfe <SEGGER_SYSVIEW_RecordEnterISR+0xca>
   10cf0:	f062 017f 	orn	r1, r2, #127	; 0x7f
   10cf4:	09d2      	lsrs	r2, r2, #7
   10cf6:	2a7f      	cmp	r2, #127	; 0x7f
   10cf8:	f803 1b01 	strb.w	r1, [r3], #1
   10cfc:	d8f8      	bhi.n	10cf0 <SEGGER_SYSVIEW_RecordEnterISR+0xbc>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10cfe:	4918      	ldr	r1, [pc, #96]	; (10d60 <SEGGER_SYSVIEW_RecordEnterISR+0x12c>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10d00:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10d02:	680f      	ldr	r7, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   10d04:	68f1      	ldr	r1, [r6, #12]
   10d06:	1a79      	subs	r1, r7, r1
  ENCODE_U32(pPayload, Delta);
   10d08:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10d0a:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   10d0e:	d906      	bls.n	10d1e <SEGGER_SYSVIEW_RecordEnterISR+0xea>
   10d10:	f061 037f 	orn	r3, r1, #127	; 0x7f
   10d14:	09c9      	lsrs	r1, r1, #7
   10d16:	297f      	cmp	r1, #127	; 0x7f
   10d18:	f802 3b01 	strb.w	r3, [r2], #1
   10d1c:	d8f8      	bhi.n	10d10 <SEGGER_SYSVIEW_RecordEnterISR+0xdc>
   10d1e:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   10d20:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   10d22:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   10d26:	2001      	movs	r0, #1
   10d28:	4611      	mov	r1, r2
   10d2a:	1a9a      	subs	r2, r3, r2
   10d2c:	f7ff f928 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   10d30:	b940      	cbnz	r0, 10d44 <SEGGER_SYSVIEW_RecordEnterISR+0x110>
    _SYSVIEW_Globals.DropCount++;
   10d32:	6972      	ldr	r2, [r6, #20]
   10d34:	7833      	ldrb	r3, [r6, #0]
   10d36:	3201      	adds	r2, #1
   10d38:	6172      	str	r2, [r6, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   10d3a:	2b01      	cmp	r3, #1
   10d3c:	d194      	bne.n	10c68 <SEGGER_SYSVIEW_RecordEnterISR+0x34>
   10d3e:	e7a2      	b.n	10c86 <SEGGER_SYSVIEW_RecordEnterISR+0x52>
  ENCODE_U32(pPayload, v);
   10d40:	4c09      	ldr	r4, [pc, #36]	; (10d68 <SEGGER_SYSVIEW_RecordEnterISR+0x134>)
   10d42:	e78b      	b.n	10c5c <SEGGER_SYSVIEW_RecordEnterISR+0x28>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   10d44:	7833      	ldrb	r3, [r6, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   10d46:	60f7      	str	r7, [r6, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   10d48:	3b01      	subs	r3, #1
   10d4a:	b2db      	uxtb	r3, r3
   10d4c:	7033      	strb	r3, [r6, #0]
   10d4e:	e7f4      	b.n	10d3a <SEGGER_SYSVIEW_RecordEnterISR+0x106>
   10d50:	e000ed04 	.word	0xe000ed04
   10d54:	10013268 	.word	0x10013268
   10d58:	10013240 	.word	0x10013240
   10d5c:	1001341c 	.word	0x1001341c
   10d60:	e0001004 	.word	0xe0001004
   10d64:	1001326b 	.word	0x1001326b
   10d68:	1001326c 	.word	0x1001326c

00010d6c <SEGGER_SYSVIEW_OnTaskCreate>:
void SEGGER_SYSVIEW_OnTaskCreate(U32 TaskId) {
   10d6c:	b5f0      	push	{r4, r5, r6, r7, lr}
   10d6e:	b085      	sub	sp, #20
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
   10d70:	f3ef 8611 	mrs	r6, BASEPRI
   10d74:	f04f 0120 	mov.w	r1, #32
   10d78:	f381 8811 	msr	BASEPRI, r1
  TaskId = SHRINK_ID(TaskId);
   10d7c:	4d42      	ldr	r5, [pc, #264]	; (10e88 <SEGGER_SYSVIEW_OnTaskCreate+0x11c>)
  ENCODE_U32(pPayload, TaskId);
   10d7e:	4c43      	ldr	r4, [pc, #268]	; (10e8c <SEGGER_SYSVIEW_OnTaskCreate+0x120>)
  TaskId = SHRINK_ID(TaskId);
   10d80:	692b      	ldr	r3, [r5, #16]
   10d82:	1ac0      	subs	r0, r0, r3
   10d84:	0880      	lsrs	r0, r0, #2
  ENCODE_U32(pPayload, TaskId);
   10d86:	287f      	cmp	r0, #127	; 0x7f
   10d88:	d906      	bls.n	10d98 <SEGGER_SYSVIEW_OnTaskCreate+0x2c>
   10d8a:	f060 037f 	orn	r3, r0, #127	; 0x7f
   10d8e:	09c0      	lsrs	r0, r0, #7
   10d90:	287f      	cmp	r0, #127	; 0x7f
   10d92:	f804 3b01 	strb.w	r3, [r4], #1
   10d96:	d8f8      	bhi.n	10d8a <SEGGER_SYSVIEW_OnTaskCreate+0x1e>
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   10d98:	782b      	ldrb	r3, [r5, #0]
  ENCODE_U32(pPayload, TaskId);
   10d9a:	7020      	strb	r0, [r4, #0]
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   10d9c:	2b01      	cmp	r3, #1
   10d9e:	d00f      	beq.n	10dc0 <SEGGER_SYSVIEW_OnTaskCreate+0x54>
  if (_SYSVIEW_Globals.EnableState == 0) {
   10da0:	b963      	cbnz	r3, 10dbc <SEGGER_SYSVIEW_OnTaskCreate+0x50>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   10da2:	4b3b      	ldr	r3, [pc, #236]	; (10e90 <SEGGER_SYSVIEW_OnTaskCreate+0x124>)
   10da4:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   10da8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   10dac:	429a      	cmp	r2, r3
   10dae:	d001      	beq.n	10db4 <SEGGER_SYSVIEW_OnTaskCreate+0x48>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   10db0:	78ac      	ldrb	r4, [r5, #2]
   10db2:	b32c      	cbz	r4, 10e00 <SEGGER_SYSVIEW_OnTaskCreate+0x94>
  RECORD_END();
   10db4:	f386 8811 	msr	BASEPRI, r6
}
   10db8:	b005      	add	sp, #20
   10dba:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   10dbc:	2b02      	cmp	r3, #2
   10dbe:	d02c      	beq.n	10e1a <SEGGER_SYSVIEW_OnTaskCreate+0xae>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   10dc0:	69eb      	ldr	r3, [r5, #28]
   10dc2:	05db      	lsls	r3, r3, #23
   10dc4:	d4ed      	bmi.n	10da2 <SEGGER_SYSVIEW_OnTaskCreate+0x36>
    *--pStartPacket = EventId;
   10dc6:	4a33      	ldr	r2, [pc, #204]	; (10e94 <SEGGER_SYSVIEW_OnTaskCreate+0x128>)
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10dc8:	4b33      	ldr	r3, [pc, #204]	; (10e98 <SEGGER_SYSVIEW_OnTaskCreate+0x12c>)
    *--pStartPacket = EventId;
   10dca:	2108      	movs	r1, #8
   10dcc:	70d1      	strb	r1, [r2, #3]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10dce:	681f      	ldr	r7, [r3, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   10dd0:	68eb      	ldr	r3, [r5, #12]
   10dd2:	1afb      	subs	r3, r7, r3
  ENCODE_U32(pEndPacket, Delta);
   10dd4:	2b7f      	cmp	r3, #127	; 0x7f
  ENCODE_U32(pPayload, TaskId);
   10dd6:	f104 0201 	add.w	r2, r4, #1
  ENCODE_U32(pEndPacket, Delta);
   10dda:	d906      	bls.n	10dea <SEGGER_SYSVIEW_OnTaskCreate+0x7e>
   10ddc:	f063 017f 	orn	r1, r3, #127	; 0x7f
   10de0:	09db      	lsrs	r3, r3, #7
   10de2:	2b7f      	cmp	r3, #127	; 0x7f
   10de4:	f802 1b01 	strb.w	r1, [r2], #1
   10de8:	d8f8      	bhi.n	10ddc <SEGGER_SYSVIEW_OnTaskCreate+0x70>
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   10dea:	482c      	ldr	r0, [pc, #176]	; (10e9c <SEGGER_SYSVIEW_OnTaskCreate+0x130>)
  ENCODE_U32(pEndPacket, Delta);
   10dec:	f802 3b01 	strb.w	r3, [r2], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   10df0:	4601      	mov	r1, r0
   10df2:	1a12      	subs	r2, r2, r0
   10df4:	2001      	movs	r0, #1
   10df6:	f7ff f8c3 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   10dfa:	b150      	cbz	r0, 10e12 <SEGGER_SYSVIEW_OnTaskCreate+0xa6>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   10dfc:	60ef      	str	r7, [r5, #12]
   10dfe:	e7d0      	b.n	10da2 <SEGGER_SYSVIEW_OnTaskCreate+0x36>
      _SYSVIEW_Globals.RecursionCnt = 1;
   10e00:	2301      	movs	r3, #1
   10e02:	70ab      	strb	r3, [r5, #2]
      _HandleIncomingPacket();
   10e04:	f7ff fb4a 	bl	1049c <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   10e08:	70ac      	strb	r4, [r5, #2]
  RECORD_END();
   10e0a:	f386 8811 	msr	BASEPRI, r6
}
   10e0e:	b005      	add	sp, #20
   10e10:	bdf0      	pop	{r4, r5, r6, r7, pc}
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   10e12:	782b      	ldrb	r3, [r5, #0]
   10e14:	3301      	adds	r3, #1
   10e16:	702b      	strb	r3, [r5, #0]
   10e18:	e7c3      	b.n	10da2 <SEGGER_SYSVIEW_OnTaskCreate+0x36>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10e1a:	696a      	ldr	r2, [r5, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   10e1c:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10e1e:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   10e20:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10e24:	f10d 0305 	add.w	r3, sp, #5
   10e28:	d906      	bls.n	10e38 <SEGGER_SYSVIEW_OnTaskCreate+0xcc>
   10e2a:	f062 017f 	orn	r1, r2, #127	; 0x7f
   10e2e:	09d2      	lsrs	r2, r2, #7
   10e30:	2a7f      	cmp	r2, #127	; 0x7f
   10e32:	f803 1b01 	strb.w	r1, [r3], #1
   10e36:	d8f8      	bhi.n	10e2a <SEGGER_SYSVIEW_OnTaskCreate+0xbe>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10e38:	4917      	ldr	r1, [pc, #92]	; (10e98 <SEGGER_SYSVIEW_OnTaskCreate+0x12c>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10e3a:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10e3c:	680f      	ldr	r7, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   10e3e:	68e9      	ldr	r1, [r5, #12]
   10e40:	1a79      	subs	r1, r7, r1
  ENCODE_U32(pPayload, Delta);
   10e42:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10e44:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   10e48:	d906      	bls.n	10e58 <SEGGER_SYSVIEW_OnTaskCreate+0xec>
   10e4a:	f061 037f 	orn	r3, r1, #127	; 0x7f
   10e4e:	09c9      	lsrs	r1, r1, #7
   10e50:	297f      	cmp	r1, #127	; 0x7f
   10e52:	f802 3b01 	strb.w	r3, [r2], #1
   10e56:	d8f8      	bhi.n	10e4a <SEGGER_SYSVIEW_OnTaskCreate+0xde>
   10e58:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   10e5a:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   10e5c:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   10e60:	2001      	movs	r0, #1
   10e62:	4611      	mov	r1, r2
   10e64:	1a9a      	subs	r2, r3, r2
   10e66:	f7ff f88b 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   10e6a:	b930      	cbnz	r0, 10e7a <SEGGER_SYSVIEW_OnTaskCreate+0x10e>
    _SYSVIEW_Globals.DropCount++;
   10e6c:	696a      	ldr	r2, [r5, #20]
   10e6e:	782b      	ldrb	r3, [r5, #0]
   10e70:	3201      	adds	r2, #1
   10e72:	616a      	str	r2, [r5, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   10e74:	2b01      	cmp	r3, #1
   10e76:	d194      	bne.n	10da2 <SEGGER_SYSVIEW_OnTaskCreate+0x36>
   10e78:	e7a2      	b.n	10dc0 <SEGGER_SYSVIEW_OnTaskCreate+0x54>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   10e7a:	782b      	ldrb	r3, [r5, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   10e7c:	60ef      	str	r7, [r5, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   10e7e:	3b01      	subs	r3, #1
   10e80:	b2db      	uxtb	r3, r3
   10e82:	702b      	strb	r3, [r5, #0]
   10e84:	e7f6      	b.n	10e74 <SEGGER_SYSVIEW_OnTaskCreate+0x108>
   10e86:	bf00      	nop
   10e88:	10013240 	.word	0x10013240
   10e8c:	1001326c 	.word	0x1001326c
   10e90:	1001341c 	.word	0x1001341c
   10e94:	10013268 	.word	0x10013268
   10e98:	e0001004 	.word	0xe0001004
   10e9c:	1001326b 	.word	0x1001326b

00010ea0 <SEGGER_SYSVIEW_OnTaskStartExec>:
void SEGGER_SYSVIEW_OnTaskStartExec(U32 TaskId) {
   10ea0:	b5f0      	push	{r4, r5, r6, r7, lr}
   10ea2:	b085      	sub	sp, #20
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
   10ea4:	f3ef 8611 	mrs	r6, BASEPRI
   10ea8:	f04f 0120 	mov.w	r1, #32
   10eac:	f381 8811 	msr	BASEPRI, r1
  TaskId = SHRINK_ID(TaskId);
   10eb0:	4d42      	ldr	r5, [pc, #264]	; (10fbc <SEGGER_SYSVIEW_OnTaskStartExec+0x11c>)
  ENCODE_U32(pPayload, TaskId);
   10eb2:	4c43      	ldr	r4, [pc, #268]	; (10fc0 <SEGGER_SYSVIEW_OnTaskStartExec+0x120>)
  TaskId = SHRINK_ID(TaskId);
   10eb4:	692b      	ldr	r3, [r5, #16]
   10eb6:	1ac0      	subs	r0, r0, r3
   10eb8:	0880      	lsrs	r0, r0, #2
  ENCODE_U32(pPayload, TaskId);
   10eba:	287f      	cmp	r0, #127	; 0x7f
   10ebc:	d906      	bls.n	10ecc <SEGGER_SYSVIEW_OnTaskStartExec+0x2c>
   10ebe:	f060 037f 	orn	r3, r0, #127	; 0x7f
   10ec2:	09c0      	lsrs	r0, r0, #7
   10ec4:	287f      	cmp	r0, #127	; 0x7f
   10ec6:	f804 3b01 	strb.w	r3, [r4], #1
   10eca:	d8f8      	bhi.n	10ebe <SEGGER_SYSVIEW_OnTaskStartExec+0x1e>
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   10ecc:	782b      	ldrb	r3, [r5, #0]
  ENCODE_U32(pPayload, TaskId);
   10ece:	7020      	strb	r0, [r4, #0]
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   10ed0:	2b01      	cmp	r3, #1
   10ed2:	d00f      	beq.n	10ef4 <SEGGER_SYSVIEW_OnTaskStartExec+0x54>
  if (_SYSVIEW_Globals.EnableState == 0) {
   10ed4:	b963      	cbnz	r3, 10ef0 <SEGGER_SYSVIEW_OnTaskStartExec+0x50>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   10ed6:	4b3b      	ldr	r3, [pc, #236]	; (10fc4 <SEGGER_SYSVIEW_OnTaskStartExec+0x124>)
   10ed8:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   10edc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   10ee0:	429a      	cmp	r2, r3
   10ee2:	d001      	beq.n	10ee8 <SEGGER_SYSVIEW_OnTaskStartExec+0x48>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   10ee4:	78ac      	ldrb	r4, [r5, #2]
   10ee6:	b32c      	cbz	r4, 10f34 <SEGGER_SYSVIEW_OnTaskStartExec+0x94>
  RECORD_END();
   10ee8:	f386 8811 	msr	BASEPRI, r6
}
   10eec:	b005      	add	sp, #20
   10eee:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   10ef0:	2b02      	cmp	r3, #2
   10ef2:	d02c      	beq.n	10f4e <SEGGER_SYSVIEW_OnTaskStartExec+0xae>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   10ef4:	69eb      	ldr	r3, [r5, #28]
   10ef6:	06db      	lsls	r3, r3, #27
   10ef8:	d4ed      	bmi.n	10ed6 <SEGGER_SYSVIEW_OnTaskStartExec+0x36>
    *--pStartPacket = EventId;
   10efa:	4a33      	ldr	r2, [pc, #204]	; (10fc8 <SEGGER_SYSVIEW_OnTaskStartExec+0x128>)
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10efc:	4b33      	ldr	r3, [pc, #204]	; (10fcc <SEGGER_SYSVIEW_OnTaskStartExec+0x12c>)
    *--pStartPacket = EventId;
   10efe:	2104      	movs	r1, #4
   10f00:	70d1      	strb	r1, [r2, #3]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10f02:	681f      	ldr	r7, [r3, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   10f04:	68eb      	ldr	r3, [r5, #12]
   10f06:	1afb      	subs	r3, r7, r3
  ENCODE_U32(pEndPacket, Delta);
   10f08:	2b7f      	cmp	r3, #127	; 0x7f
  ENCODE_U32(pPayload, TaskId);
   10f0a:	f104 0201 	add.w	r2, r4, #1
  ENCODE_U32(pEndPacket, Delta);
   10f0e:	d906      	bls.n	10f1e <SEGGER_SYSVIEW_OnTaskStartExec+0x7e>
   10f10:	f063 017f 	orn	r1, r3, #127	; 0x7f
   10f14:	09db      	lsrs	r3, r3, #7
   10f16:	2b7f      	cmp	r3, #127	; 0x7f
   10f18:	f802 1b01 	strb.w	r1, [r2], #1
   10f1c:	d8f8      	bhi.n	10f10 <SEGGER_SYSVIEW_OnTaskStartExec+0x70>
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   10f1e:	482c      	ldr	r0, [pc, #176]	; (10fd0 <SEGGER_SYSVIEW_OnTaskStartExec+0x130>)
  ENCODE_U32(pEndPacket, Delta);
   10f20:	f802 3b01 	strb.w	r3, [r2], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   10f24:	4601      	mov	r1, r0
   10f26:	1a12      	subs	r2, r2, r0
   10f28:	2001      	movs	r0, #1
   10f2a:	f7ff f829 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   10f2e:	b150      	cbz	r0, 10f46 <SEGGER_SYSVIEW_OnTaskStartExec+0xa6>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   10f30:	60ef      	str	r7, [r5, #12]
   10f32:	e7d0      	b.n	10ed6 <SEGGER_SYSVIEW_OnTaskStartExec+0x36>
      _SYSVIEW_Globals.RecursionCnt = 1;
   10f34:	2301      	movs	r3, #1
   10f36:	70ab      	strb	r3, [r5, #2]
      _HandleIncomingPacket();
   10f38:	f7ff fab0 	bl	1049c <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   10f3c:	70ac      	strb	r4, [r5, #2]
  RECORD_END();
   10f3e:	f386 8811 	msr	BASEPRI, r6
}
   10f42:	b005      	add	sp, #20
   10f44:	bdf0      	pop	{r4, r5, r6, r7, pc}
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   10f46:	782b      	ldrb	r3, [r5, #0]
   10f48:	3301      	adds	r3, #1
   10f4a:	702b      	strb	r3, [r5, #0]
   10f4c:	e7c3      	b.n	10ed6 <SEGGER_SYSVIEW_OnTaskStartExec+0x36>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10f4e:	696a      	ldr	r2, [r5, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   10f50:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10f52:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   10f54:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10f58:	f10d 0305 	add.w	r3, sp, #5
   10f5c:	d906      	bls.n	10f6c <SEGGER_SYSVIEW_OnTaskStartExec+0xcc>
   10f5e:	f062 017f 	orn	r1, r2, #127	; 0x7f
   10f62:	09d2      	lsrs	r2, r2, #7
   10f64:	2a7f      	cmp	r2, #127	; 0x7f
   10f66:	f803 1b01 	strb.w	r1, [r3], #1
   10f6a:	d8f8      	bhi.n	10f5e <SEGGER_SYSVIEW_OnTaskStartExec+0xbe>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10f6c:	4917      	ldr	r1, [pc, #92]	; (10fcc <SEGGER_SYSVIEW_OnTaskStartExec+0x12c>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10f6e:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   10f70:	680f      	ldr	r7, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   10f72:	68e9      	ldr	r1, [r5, #12]
   10f74:	1a79      	subs	r1, r7, r1
  ENCODE_U32(pPayload, Delta);
   10f76:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   10f78:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   10f7c:	d906      	bls.n	10f8c <SEGGER_SYSVIEW_OnTaskStartExec+0xec>
   10f7e:	f061 037f 	orn	r3, r1, #127	; 0x7f
   10f82:	09c9      	lsrs	r1, r1, #7
   10f84:	297f      	cmp	r1, #127	; 0x7f
   10f86:	f802 3b01 	strb.w	r3, [r2], #1
   10f8a:	d8f8      	bhi.n	10f7e <SEGGER_SYSVIEW_OnTaskStartExec+0xde>
   10f8c:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   10f8e:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   10f90:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   10f94:	2001      	movs	r0, #1
   10f96:	4611      	mov	r1, r2
   10f98:	1a9a      	subs	r2, r3, r2
   10f9a:	f7fe fff1 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   10f9e:	b930      	cbnz	r0, 10fae <SEGGER_SYSVIEW_OnTaskStartExec+0x10e>
    _SYSVIEW_Globals.DropCount++;
   10fa0:	696a      	ldr	r2, [r5, #20]
   10fa2:	782b      	ldrb	r3, [r5, #0]
   10fa4:	3201      	adds	r2, #1
   10fa6:	616a      	str	r2, [r5, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   10fa8:	2b01      	cmp	r3, #1
   10faa:	d194      	bne.n	10ed6 <SEGGER_SYSVIEW_OnTaskStartExec+0x36>
   10fac:	e7a2      	b.n	10ef4 <SEGGER_SYSVIEW_OnTaskStartExec+0x54>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   10fae:	782b      	ldrb	r3, [r5, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   10fb0:	60ef      	str	r7, [r5, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   10fb2:	3b01      	subs	r3, #1
   10fb4:	b2db      	uxtb	r3, r3
   10fb6:	702b      	strb	r3, [r5, #0]
   10fb8:	e7f6      	b.n	10fa8 <SEGGER_SYSVIEW_OnTaskStartExec+0x108>
   10fba:	bf00      	nop
   10fbc:	10013240 	.word	0x10013240
   10fc0:	1001326c 	.word	0x1001326c
   10fc4:	1001341c 	.word	0x1001341c
   10fc8:	10013268 	.word	0x10013268
   10fcc:	e0001004 	.word	0xe0001004
   10fd0:	1001326b 	.word	0x1001326b

00010fd4 <SEGGER_SYSVIEW_OnTaskStartReady>:
void SEGGER_SYSVIEW_OnTaskStartReady(U32 TaskId) {
   10fd4:	b5f0      	push	{r4, r5, r6, r7, lr}
   10fd6:	b085      	sub	sp, #20
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
   10fd8:	f3ef 8611 	mrs	r6, BASEPRI
   10fdc:	f04f 0120 	mov.w	r1, #32
   10fe0:	f381 8811 	msr	BASEPRI, r1
  TaskId = SHRINK_ID(TaskId);
   10fe4:	4d42      	ldr	r5, [pc, #264]	; (110f0 <SEGGER_SYSVIEW_OnTaskStartReady+0x11c>)
  ENCODE_U32(pPayload, TaskId);
   10fe6:	4c43      	ldr	r4, [pc, #268]	; (110f4 <SEGGER_SYSVIEW_OnTaskStartReady+0x120>)
  TaskId = SHRINK_ID(TaskId);
   10fe8:	692b      	ldr	r3, [r5, #16]
   10fea:	1ac0      	subs	r0, r0, r3
   10fec:	0880      	lsrs	r0, r0, #2
  ENCODE_U32(pPayload, TaskId);
   10fee:	287f      	cmp	r0, #127	; 0x7f
   10ff0:	d906      	bls.n	11000 <SEGGER_SYSVIEW_OnTaskStartReady+0x2c>
   10ff2:	f060 037f 	orn	r3, r0, #127	; 0x7f
   10ff6:	09c0      	lsrs	r0, r0, #7
   10ff8:	287f      	cmp	r0, #127	; 0x7f
   10ffa:	f804 3b01 	strb.w	r3, [r4], #1
   10ffe:	d8f8      	bhi.n	10ff2 <SEGGER_SYSVIEW_OnTaskStartReady+0x1e>
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   11000:	782b      	ldrb	r3, [r5, #0]
  ENCODE_U32(pPayload, TaskId);
   11002:	7020      	strb	r0, [r4, #0]
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   11004:	2b01      	cmp	r3, #1
   11006:	d00f      	beq.n	11028 <SEGGER_SYSVIEW_OnTaskStartReady+0x54>
  if (_SYSVIEW_Globals.EnableState == 0) {
   11008:	b963      	cbnz	r3, 11024 <SEGGER_SYSVIEW_OnTaskStartReady+0x50>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   1100a:	4b3b      	ldr	r3, [pc, #236]	; (110f8 <SEGGER_SYSVIEW_OnTaskStartReady+0x124>)
   1100c:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   11010:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   11014:	429a      	cmp	r2, r3
   11016:	d001      	beq.n	1101c <SEGGER_SYSVIEW_OnTaskStartReady+0x48>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   11018:	78ac      	ldrb	r4, [r5, #2]
   1101a:	b32c      	cbz	r4, 11068 <SEGGER_SYSVIEW_OnTaskStartReady+0x94>
  RECORD_END();
   1101c:	f386 8811 	msr	BASEPRI, r6
}
   11020:	b005      	add	sp, #20
   11022:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   11024:	2b02      	cmp	r3, #2
   11026:	d02c      	beq.n	11082 <SEGGER_SYSVIEW_OnTaskStartReady+0xae>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   11028:	69eb      	ldr	r3, [r5, #28]
   1102a:	065b      	lsls	r3, r3, #25
   1102c:	d4ed      	bmi.n	1100a <SEGGER_SYSVIEW_OnTaskStartReady+0x36>
    *--pStartPacket = EventId;
   1102e:	4a33      	ldr	r2, [pc, #204]	; (110fc <SEGGER_SYSVIEW_OnTaskStartReady+0x128>)
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11030:	4b33      	ldr	r3, [pc, #204]	; (11100 <SEGGER_SYSVIEW_OnTaskStartReady+0x12c>)
    *--pStartPacket = EventId;
   11032:	2106      	movs	r1, #6
   11034:	70d1      	strb	r1, [r2, #3]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11036:	681f      	ldr	r7, [r3, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11038:	68eb      	ldr	r3, [r5, #12]
   1103a:	1afb      	subs	r3, r7, r3
  ENCODE_U32(pEndPacket, Delta);
   1103c:	2b7f      	cmp	r3, #127	; 0x7f
  ENCODE_U32(pPayload, TaskId);
   1103e:	f104 0201 	add.w	r2, r4, #1
  ENCODE_U32(pEndPacket, Delta);
   11042:	d906      	bls.n	11052 <SEGGER_SYSVIEW_OnTaskStartReady+0x7e>
   11044:	f063 017f 	orn	r1, r3, #127	; 0x7f
   11048:	09db      	lsrs	r3, r3, #7
   1104a:	2b7f      	cmp	r3, #127	; 0x7f
   1104c:	f802 1b01 	strb.w	r1, [r2], #1
   11050:	d8f8      	bhi.n	11044 <SEGGER_SYSVIEW_OnTaskStartReady+0x70>
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   11052:	482c      	ldr	r0, [pc, #176]	; (11104 <SEGGER_SYSVIEW_OnTaskStartReady+0x130>)
  ENCODE_U32(pEndPacket, Delta);
   11054:	f802 3b01 	strb.w	r3, [r2], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   11058:	4601      	mov	r1, r0
   1105a:	1a12      	subs	r2, r2, r0
   1105c:	2001      	movs	r0, #1
   1105e:	f7fe ff8f 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   11062:	b150      	cbz	r0, 1107a <SEGGER_SYSVIEW_OnTaskStartReady+0xa6>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   11064:	60ef      	str	r7, [r5, #12]
   11066:	e7d0      	b.n	1100a <SEGGER_SYSVIEW_OnTaskStartReady+0x36>
      _SYSVIEW_Globals.RecursionCnt = 1;
   11068:	2301      	movs	r3, #1
   1106a:	70ab      	strb	r3, [r5, #2]
      _HandleIncomingPacket();
   1106c:	f7ff fa16 	bl	1049c <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   11070:	70ac      	strb	r4, [r5, #2]
  RECORD_END();
   11072:	f386 8811 	msr	BASEPRI, r6
}
   11076:	b005      	add	sp, #20
   11078:	bdf0      	pop	{r4, r5, r6, r7, pc}
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   1107a:	782b      	ldrb	r3, [r5, #0]
   1107c:	3301      	adds	r3, #1
   1107e:	702b      	strb	r3, [r5, #0]
   11080:	e7c3      	b.n	1100a <SEGGER_SYSVIEW_OnTaskStartReady+0x36>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11082:	696a      	ldr	r2, [r5, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   11084:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11086:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   11088:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   1108c:	f10d 0305 	add.w	r3, sp, #5
   11090:	d906      	bls.n	110a0 <SEGGER_SYSVIEW_OnTaskStartReady+0xcc>
   11092:	f062 017f 	orn	r1, r2, #127	; 0x7f
   11096:	09d2      	lsrs	r2, r2, #7
   11098:	2a7f      	cmp	r2, #127	; 0x7f
   1109a:	f803 1b01 	strb.w	r1, [r3], #1
   1109e:	d8f8      	bhi.n	11092 <SEGGER_SYSVIEW_OnTaskStartReady+0xbe>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   110a0:	4917      	ldr	r1, [pc, #92]	; (11100 <SEGGER_SYSVIEW_OnTaskStartReady+0x12c>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   110a2:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   110a4:	680f      	ldr	r7, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   110a6:	68e9      	ldr	r1, [r5, #12]
   110a8:	1a79      	subs	r1, r7, r1
  ENCODE_U32(pPayload, Delta);
   110aa:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   110ac:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   110b0:	d906      	bls.n	110c0 <SEGGER_SYSVIEW_OnTaskStartReady+0xec>
   110b2:	f061 037f 	orn	r3, r1, #127	; 0x7f
   110b6:	09c9      	lsrs	r1, r1, #7
   110b8:	297f      	cmp	r1, #127	; 0x7f
   110ba:	f802 3b01 	strb.w	r3, [r2], #1
   110be:	d8f8      	bhi.n	110b2 <SEGGER_SYSVIEW_OnTaskStartReady+0xde>
   110c0:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   110c2:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   110c4:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   110c8:	2001      	movs	r0, #1
   110ca:	4611      	mov	r1, r2
   110cc:	1a9a      	subs	r2, r3, r2
   110ce:	f7fe ff57 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   110d2:	b930      	cbnz	r0, 110e2 <SEGGER_SYSVIEW_OnTaskStartReady+0x10e>
    _SYSVIEW_Globals.DropCount++;
   110d4:	696a      	ldr	r2, [r5, #20]
   110d6:	782b      	ldrb	r3, [r5, #0]
   110d8:	3201      	adds	r2, #1
   110da:	616a      	str	r2, [r5, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   110dc:	2b01      	cmp	r3, #1
   110de:	d194      	bne.n	1100a <SEGGER_SYSVIEW_OnTaskStartReady+0x36>
   110e0:	e7a2      	b.n	11028 <SEGGER_SYSVIEW_OnTaskStartReady+0x54>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   110e2:	782b      	ldrb	r3, [r5, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   110e4:	60ef      	str	r7, [r5, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   110e6:	3b01      	subs	r3, #1
   110e8:	b2db      	uxtb	r3, r3
   110ea:	702b      	strb	r3, [r5, #0]
   110ec:	e7f6      	b.n	110dc <SEGGER_SYSVIEW_OnTaskStartReady+0x108>
   110ee:	bf00      	nop
   110f0:	10013240 	.word	0x10013240
   110f4:	1001326c 	.word	0x1001326c
   110f8:	1001341c 	.word	0x1001341c
   110fc:	10013268 	.word	0x10013268
   11100:	e0001004 	.word	0xe0001004
   11104:	1001326b 	.word	0x1001326b

00011108 <SEGGER_SYSVIEW_OnTaskStopReady>:
void SEGGER_SYSVIEW_OnTaskStopReady(U32 TaskId, unsigned int Cause) {
   11108:	b5f0      	push	{r4, r5, r6, r7, lr}
   1110a:	460b      	mov	r3, r1
   1110c:	b085      	sub	sp, #20
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
   1110e:	f3ef 8511 	mrs	r5, BASEPRI
   11112:	f04f 0120 	mov.w	r1, #32
   11116:	f381 8811 	msr	BASEPRI, r1
  TaskId = SHRINK_ID(TaskId);
   1111a:	4c48      	ldr	r4, [pc, #288]	; (1123c <SEGGER_SYSVIEW_OnTaskStopReady+0x134>)
  ENCODE_U32(pPayload, TaskId);
   1111c:	4e48      	ldr	r6, [pc, #288]	; (11240 <SEGGER_SYSVIEW_OnTaskStopReady+0x138>)
  TaskId = SHRINK_ID(TaskId);
   1111e:	6922      	ldr	r2, [r4, #16]
   11120:	1a80      	subs	r0, r0, r2
   11122:	0880      	lsrs	r0, r0, #2
  ENCODE_U32(pPayload, TaskId);
   11124:	287f      	cmp	r0, #127	; 0x7f
   11126:	d906      	bls.n	11136 <SEGGER_SYSVIEW_OnTaskStopReady+0x2e>
   11128:	f060 017f 	orn	r1, r0, #127	; 0x7f
   1112c:	09c0      	lsrs	r0, r0, #7
   1112e:	287f      	cmp	r0, #127	; 0x7f
   11130:	f806 1b01 	strb.w	r1, [r6], #1
   11134:	d8f8      	bhi.n	11128 <SEGGER_SYSVIEW_OnTaskStopReady+0x20>
  ENCODE_U32(pPayload, Cause);
   11136:	2b7f      	cmp	r3, #127	; 0x7f
  ENCODE_U32(pPayload, TaskId);
   11138:	7030      	strb	r0, [r6, #0]
   1113a:	f106 0601 	add.w	r6, r6, #1
  ENCODE_U32(pPayload, Cause);
   1113e:	d906      	bls.n	1114e <SEGGER_SYSVIEW_OnTaskStopReady+0x46>
   11140:	f063 027f 	orn	r2, r3, #127	; 0x7f
   11144:	09db      	lsrs	r3, r3, #7
   11146:	2b7f      	cmp	r3, #127	; 0x7f
   11148:	f806 2b01 	strb.w	r2, [r6], #1
   1114c:	d8f8      	bhi.n	11140 <SEGGER_SYSVIEW_OnTaskStopReady+0x38>
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   1114e:	7822      	ldrb	r2, [r4, #0]
  ENCODE_U32(pPayload, Cause);
   11150:	7033      	strb	r3, [r6, #0]
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   11152:	2a01      	cmp	r2, #1
   11154:	d00f      	beq.n	11176 <SEGGER_SYSVIEW_OnTaskStopReady+0x6e>
  if (_SYSVIEW_Globals.EnableState == 0) {
   11156:	b962      	cbnz	r2, 11172 <SEGGER_SYSVIEW_OnTaskStopReady+0x6a>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   11158:	4b3a      	ldr	r3, [pc, #232]	; (11244 <SEGGER_SYSVIEW_OnTaskStopReady+0x13c>)
   1115a:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   1115e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   11162:	429a      	cmp	r2, r3
   11164:	d001      	beq.n	1116a <SEGGER_SYSVIEW_OnTaskStopReady+0x62>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   11166:	78a6      	ldrb	r6, [r4, #2]
   11168:	b32e      	cbz	r6, 111b6 <SEGGER_SYSVIEW_OnTaskStopReady+0xae>
  RECORD_END();
   1116a:	f385 8811 	msr	BASEPRI, r5
}
   1116e:	b005      	add	sp, #20
   11170:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   11172:	2a02      	cmp	r2, #2
   11174:	d02c      	beq.n	111d0 <SEGGER_SYSVIEW_OnTaskStopReady+0xc8>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   11176:	69e3      	ldr	r3, [r4, #28]
   11178:	061b      	lsls	r3, r3, #24
   1117a:	d4ed      	bmi.n	11158 <SEGGER_SYSVIEW_OnTaskStopReady+0x50>
    *--pStartPacket = EventId;
   1117c:	4a32      	ldr	r2, [pc, #200]	; (11248 <SEGGER_SYSVIEW_OnTaskStopReady+0x140>)
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   1117e:	4b33      	ldr	r3, [pc, #204]	; (1124c <SEGGER_SYSVIEW_OnTaskStopReady+0x144>)
    *--pStartPacket = EventId;
   11180:	2107      	movs	r1, #7
   11182:	70d1      	strb	r1, [r2, #3]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11184:	681f      	ldr	r7, [r3, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11186:	68e3      	ldr	r3, [r4, #12]
   11188:	1afb      	subs	r3, r7, r3
  ENCODE_U32(pEndPacket, Delta);
   1118a:	2b7f      	cmp	r3, #127	; 0x7f
  ENCODE_U32(pPayload, Cause);
   1118c:	f106 0201 	add.w	r2, r6, #1
  ENCODE_U32(pEndPacket, Delta);
   11190:	d906      	bls.n	111a0 <SEGGER_SYSVIEW_OnTaskStopReady+0x98>
   11192:	f063 017f 	orn	r1, r3, #127	; 0x7f
   11196:	09db      	lsrs	r3, r3, #7
   11198:	2b7f      	cmp	r3, #127	; 0x7f
   1119a:	f802 1b01 	strb.w	r1, [r2], #1
   1119e:	d8f8      	bhi.n	11192 <SEGGER_SYSVIEW_OnTaskStopReady+0x8a>
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   111a0:	482b      	ldr	r0, [pc, #172]	; (11250 <SEGGER_SYSVIEW_OnTaskStopReady+0x148>)
  ENCODE_U32(pEndPacket, Delta);
   111a2:	f802 3b01 	strb.w	r3, [r2], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   111a6:	4601      	mov	r1, r0
   111a8:	1a12      	subs	r2, r2, r0
   111aa:	2001      	movs	r0, #1
   111ac:	f7fe fee8 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   111b0:	b150      	cbz	r0, 111c8 <SEGGER_SYSVIEW_OnTaskStopReady+0xc0>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   111b2:	60e7      	str	r7, [r4, #12]
   111b4:	e7d0      	b.n	11158 <SEGGER_SYSVIEW_OnTaskStopReady+0x50>
      _SYSVIEW_Globals.RecursionCnt = 1;
   111b6:	2301      	movs	r3, #1
   111b8:	70a3      	strb	r3, [r4, #2]
      _HandleIncomingPacket();
   111ba:	f7ff f96f 	bl	1049c <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   111be:	70a6      	strb	r6, [r4, #2]
  RECORD_END();
   111c0:	f385 8811 	msr	BASEPRI, r5
}
   111c4:	b005      	add	sp, #20
   111c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   111c8:	7823      	ldrb	r3, [r4, #0]
   111ca:	3301      	adds	r3, #1
   111cc:	7023      	strb	r3, [r4, #0]
   111ce:	e7c3      	b.n	11158 <SEGGER_SYSVIEW_OnTaskStopReady+0x50>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   111d0:	6962      	ldr	r2, [r4, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   111d2:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   111d4:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   111d6:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   111da:	f10d 0305 	add.w	r3, sp, #5
   111de:	d906      	bls.n	111ee <SEGGER_SYSVIEW_OnTaskStopReady+0xe6>
   111e0:	f062 017f 	orn	r1, r2, #127	; 0x7f
   111e4:	09d2      	lsrs	r2, r2, #7
   111e6:	2a7f      	cmp	r2, #127	; 0x7f
   111e8:	f803 1b01 	strb.w	r1, [r3], #1
   111ec:	d8f8      	bhi.n	111e0 <SEGGER_SYSVIEW_OnTaskStopReady+0xd8>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   111ee:	4917      	ldr	r1, [pc, #92]	; (1124c <SEGGER_SYSVIEW_OnTaskStopReady+0x144>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   111f0:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   111f2:	680f      	ldr	r7, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   111f4:	68e1      	ldr	r1, [r4, #12]
   111f6:	1a79      	subs	r1, r7, r1
  ENCODE_U32(pPayload, Delta);
   111f8:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   111fa:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   111fe:	d906      	bls.n	1120e <SEGGER_SYSVIEW_OnTaskStopReady+0x106>
   11200:	f061 037f 	orn	r3, r1, #127	; 0x7f
   11204:	09c9      	lsrs	r1, r1, #7
   11206:	297f      	cmp	r1, #127	; 0x7f
   11208:	f802 3b01 	strb.w	r3, [r2], #1
   1120c:	d8f8      	bhi.n	11200 <SEGGER_SYSVIEW_OnTaskStopReady+0xf8>
   1120e:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   11210:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   11212:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   11216:	2001      	movs	r0, #1
   11218:	4611      	mov	r1, r2
   1121a:	1a9a      	subs	r2, r3, r2
   1121c:	f7fe feb0 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   11220:	b930      	cbnz	r0, 11230 <SEGGER_SYSVIEW_OnTaskStopReady+0x128>
    _SYSVIEW_Globals.DropCount++;
   11222:	6962      	ldr	r2, [r4, #20]
   11224:	7823      	ldrb	r3, [r4, #0]
   11226:	3201      	adds	r2, #1
   11228:	6162      	str	r2, [r4, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   1122a:	2b01      	cmp	r3, #1
   1122c:	d194      	bne.n	11158 <SEGGER_SYSVIEW_OnTaskStopReady+0x50>
   1122e:	e7a2      	b.n	11176 <SEGGER_SYSVIEW_OnTaskStopReady+0x6e>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   11230:	7823      	ldrb	r3, [r4, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   11232:	60e7      	str	r7, [r4, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   11234:	3b01      	subs	r3, #1
   11236:	b2db      	uxtb	r3, r3
   11238:	7023      	strb	r3, [r4, #0]
   1123a:	e7f6      	b.n	1122a <SEGGER_SYSVIEW_OnTaskStopReady+0x122>
   1123c:	10013240 	.word	0x10013240
   11240:	1001326c 	.word	0x1001326c
   11244:	1001341c 	.word	0x1001341c
   11248:	10013268 	.word	0x10013268
   1124c:	e0001004 	.word	0xe0001004
   11250:	1001326b 	.word	0x1001326b

00011254 <SEGGER_SYSVIEW_SendPacket>:
int SEGGER_SYSVIEW_SendPacket(U8* pPacket, U8* pPayloadEnd, unsigned int EventId) {
   11254:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   11258:	4606      	mov	r6, r0
   1125a:	b085      	sub	sp, #20
   1125c:	460c      	mov	r4, r1
   1125e:	4690      	mov	r8, r2
  SEGGER_SYSVIEW_LOCK();
   11260:	f3ef 8711 	mrs	r7, BASEPRI
   11264:	f04f 0120 	mov.w	r1, #32
   11268:	f381 8811 	msr	BASEPRI, r1
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   1126c:	4d54      	ldr	r5, [pc, #336]	; (113c0 <SEGGER_SYSVIEW_SendPacket+0x16c>)
   1126e:	782b      	ldrb	r3, [r5, #0]
   11270:	2b01      	cmp	r3, #1
   11272:	d012      	beq.n	1129a <SEGGER_SYSVIEW_SendPacket+0x46>
  if (_SYSVIEW_Globals.EnableState == 0) {
   11274:	b97b      	cbnz	r3, 11296 <SEGGER_SYSVIEW_SendPacket+0x42>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   11276:	4b53      	ldr	r3, [pc, #332]	; (113c4 <SEGGER_SYSVIEW_SendPacket+0x170>)
   11278:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   1127c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   11280:	429a      	cmp	r2, r3
   11282:	d002      	beq.n	1128a <SEGGER_SYSVIEW_SendPacket+0x36>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   11284:	78ac      	ldrb	r4, [r5, #2]
   11286:	2c00      	cmp	r4, #0
   11288:	d046      	beq.n	11318 <SEGGER_SYSVIEW_SendPacket+0xc4>
  SEGGER_SYSVIEW_UNLOCK();
   1128a:	f387 8811 	msr	BASEPRI, r7
}
   1128e:	2000      	movs	r0, #0
   11290:	b005      	add	sp, #20
   11292:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   11296:	2b02      	cmp	r3, #2
   11298:	d053      	beq.n	11342 <SEGGER_SYSVIEW_SendPacket+0xee>
  if (EventId < 32) {
   1129a:	f1b8 0f1f 	cmp.w	r8, #31
   1129e:	d917      	bls.n	112d0 <SEGGER_SYSVIEW_SendPacket+0x7c>
   112a0:	fa5f f188 	uxtb.w	r1, r8
  _SendPacket(pPacket + 4, pPayloadEnd, EventId);
   112a4:	1d33      	adds	r3, r6, #4
    NumBytes = pEndPacket - pStartPacket;
   112a6:	1ae3      	subs	r3, r4, r3
    if (NumBytes > 127) {
   112a8:	2b7f      	cmp	r3, #127	; 0x7f
   112aa:	b2da      	uxtb	r2, r3
   112ac:	d83a      	bhi.n	11324 <SEGGER_SYSVIEW_SendPacket+0xd0>
      *--pStartPacket = NumBytes;
   112ae:	4613      	mov	r3, r2
    if (EventId > 127) {
   112b0:	f1b8 0f7f 	cmp.w	r8, #127	; 0x7f
      *--pStartPacket = NumBytes;
   112b4:	f106 0203 	add.w	r2, r6, #3
   112b8:	70f3      	strb	r3, [r6, #3]
    if (EventId > 127) {
   112ba:	d93e      	bls.n	1133a <SEGGER_SYSVIEW_SendPacket+0xe6>
      *--pStartPacket = (EventId >> 7);
   112bc:	ea4f 18d8 	mov.w	r8, r8, lsr #7
      *--pStartPacket = EventId | 0x80;
   112c0:	f061 017f 	orn	r1, r1, #127	; 0x7f
      *--pStartPacket = (EventId >> 7);
   112c4:	f802 8c01 	strb.w	r8, [r2, #-1]
      *--pStartPacket = EventId | 0x80;
   112c8:	f802 1c02 	strb.w	r1, [r2, #-2]
   112cc:	3a02      	subs	r2, #2
   112ce:	e00b      	b.n	112e8 <SEGGER_SYSVIEW_SendPacket+0x94>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   112d0:	69eb      	ldr	r3, [r5, #28]
   112d2:	fa23 f308 	lsr.w	r3, r3, r8
   112d6:	07db      	lsls	r3, r3, #31
   112d8:	d4cd      	bmi.n	11276 <SEGGER_SYSVIEW_SendPacket+0x22>
  if (EventId < 24) {
   112da:	f1b8 0f17 	cmp.w	r8, #23
   112de:	fa5f f188 	uxtb.w	r1, r8
   112e2:	d8df      	bhi.n	112a4 <SEGGER_SYSVIEW_SendPacket+0x50>
    *--pStartPacket = EventId;
   112e4:	70f1      	strb	r1, [r6, #3]
   112e6:	1cf2      	adds	r2, r6, #3
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   112e8:	4937      	ldr	r1, [pc, #220]	; (113c8 <SEGGER_SYSVIEW_SendPacket+0x174>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   112ea:	68eb      	ldr	r3, [r5, #12]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   112ec:	680e      	ldr	r6, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   112ee:	1af3      	subs	r3, r6, r3
  ENCODE_U32(pEndPacket, Delta);
   112f0:	2b7f      	cmp	r3, #127	; 0x7f
   112f2:	d906      	bls.n	11302 <SEGGER_SYSVIEW_SendPacket+0xae>
   112f4:	f063 017f 	orn	r1, r3, #127	; 0x7f
   112f8:	09db      	lsrs	r3, r3, #7
   112fa:	2b7f      	cmp	r3, #127	; 0x7f
   112fc:	f804 1b01 	strb.w	r1, [r4], #1
   11300:	d8f8      	bhi.n	112f4 <SEGGER_SYSVIEW_SendPacket+0xa0>
   11302:	f804 3b01 	strb.w	r3, [r4], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   11306:	4611      	mov	r1, r2
   11308:	2001      	movs	r0, #1
   1130a:	1aa2      	subs	r2, r4, r2
   1130c:	f7fe fe38 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   11310:	2800      	cmp	r0, #0
   11312:	d049      	beq.n	113a8 <SEGGER_SYSVIEW_SendPacket+0x154>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   11314:	60ee      	str	r6, [r5, #12]
   11316:	e7ae      	b.n	11276 <SEGGER_SYSVIEW_SendPacket+0x22>
      _SYSVIEW_Globals.RecursionCnt = 1;
   11318:	2301      	movs	r3, #1
   1131a:	70ab      	strb	r3, [r5, #2]
      _HandleIncomingPacket();
   1131c:	f7ff f8be 	bl	1049c <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   11320:	70ac      	strb	r4, [r5, #2]
   11322:	e7b2      	b.n	1128a <SEGGER_SYSVIEW_SendPacket+0x36>
      *--pStartPacket = NumBytes | 0x80;
   11324:	f062 027f 	orn	r2, r2, #127	; 0x7f
      *--pStartPacket = (NumBytes >> 7);
   11328:	f3c3 13c7 	ubfx	r3, r3, #7, #8
    if (EventId > 127) {
   1132c:	f1b8 0f7f 	cmp.w	r8, #127	; 0x7f
      *--pStartPacket = NumBytes | 0x80;
   11330:	70b2      	strb	r2, [r6, #2]
   11332:	70f3      	strb	r3, [r6, #3]
   11334:	f106 0202 	add.w	r2, r6, #2
    if (EventId > 127) {
   11338:	d8c0      	bhi.n	112bc <SEGGER_SYSVIEW_SendPacket+0x68>
      *--pStartPacket = EventId;
   1133a:	f802 1c01 	strb.w	r1, [r2, #-1]
   1133e:	3a01      	subs	r2, #1
   11340:	e7d2      	b.n	112e8 <SEGGER_SYSVIEW_SendPacket+0x94>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11342:	696a      	ldr	r2, [r5, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   11344:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11346:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   11348:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   1134c:	f10d 0305 	add.w	r3, sp, #5
   11350:	d906      	bls.n	11360 <SEGGER_SYSVIEW_SendPacket+0x10c>
   11352:	f062 017f 	orn	r1, r2, #127	; 0x7f
   11356:	09d2      	lsrs	r2, r2, #7
   11358:	2a7f      	cmp	r2, #127	; 0x7f
   1135a:	f803 1b01 	strb.w	r1, [r3], #1
   1135e:	d8f8      	bhi.n	11352 <SEGGER_SYSVIEW_SendPacket+0xfe>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11360:	4919      	ldr	r1, [pc, #100]	; (113c8 <SEGGER_SYSVIEW_SendPacket+0x174>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11362:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11364:	f8d1 9000 	ldr.w	r9, [r1]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11368:	68e9      	ldr	r1, [r5, #12]
   1136a:	eba9 0101 	sub.w	r1, r9, r1
  ENCODE_U32(pPayload, Delta);
   1136e:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11370:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   11374:	d906      	bls.n	11384 <SEGGER_SYSVIEW_SendPacket+0x130>
   11376:	f061 037f 	orn	r3, r1, #127	; 0x7f
   1137a:	09c9      	lsrs	r1, r1, #7
   1137c:	297f      	cmp	r1, #127	; 0x7f
   1137e:	f802 3b01 	strb.w	r3, [r2], #1
   11382:	d8f8      	bhi.n	11376 <SEGGER_SYSVIEW_SendPacket+0x122>
   11384:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   11386:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   11388:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   1138c:	2001      	movs	r0, #1
   1138e:	4611      	mov	r1, r2
   11390:	1a9a      	subs	r2, r3, r2
   11392:	f7fe fdf5 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   11396:	b958      	cbnz	r0, 113b0 <SEGGER_SYSVIEW_SendPacket+0x15c>
    _SYSVIEW_Globals.DropCount++;
   11398:	696a      	ldr	r2, [r5, #20]
   1139a:	782b      	ldrb	r3, [r5, #0]
   1139c:	3201      	adds	r2, #1
   1139e:	616a      	str	r2, [r5, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   113a0:	2b01      	cmp	r3, #1
   113a2:	f47f af68 	bne.w	11276 <SEGGER_SYSVIEW_SendPacket+0x22>
   113a6:	e778      	b.n	1129a <SEGGER_SYSVIEW_SendPacket+0x46>
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   113a8:	782b      	ldrb	r3, [r5, #0]
   113aa:	3301      	adds	r3, #1
   113ac:	702b      	strb	r3, [r5, #0]
   113ae:	e762      	b.n	11276 <SEGGER_SYSVIEW_SendPacket+0x22>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   113b0:	782b      	ldrb	r3, [r5, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   113b2:	f8c5 900c 	str.w	r9, [r5, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   113b6:	3b01      	subs	r3, #1
   113b8:	b2db      	uxtb	r3, r3
   113ba:	702b      	strb	r3, [r5, #0]
   113bc:	e7f0      	b.n	113a0 <SEGGER_SYSVIEW_SendPacket+0x14c>
   113be:	bf00      	nop
   113c0:	10013240 	.word	0x10013240
   113c4:	1001341c 	.word	0x1001341c
   113c8:	e0001004 	.word	0xe0001004

000113cc <SEGGER_SYSVIEW_RecordU32x3>:
void SEGGER_SYSVIEW_RecordU32x3(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2) {
   113cc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   113d0:	4606      	mov	r6, r0
   113d2:	b085      	sub	sp, #20
   113d4:	4608      	mov	r0, r1
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 3 * SEGGER_SYSVIEW_QUANTA_U32);
   113d6:	f3ef 8511 	mrs	r5, BASEPRI
   113da:	f04f 0120 	mov.w	r1, #32
   113de:	f381 8811 	msr	BASEPRI, r1
  ENCODE_U32(pPayload, Para0);
   113e2:	4f6e      	ldr	r7, [pc, #440]	; (1159c <SEGGER_SYSVIEW_RecordU32x3+0x1d0>)
   113e4:	287f      	cmp	r0, #127	; 0x7f
   113e6:	4639      	mov	r1, r7
   113e8:	d906      	bls.n	113f8 <SEGGER_SYSVIEW_RecordU32x3+0x2c>
   113ea:	f060 047f 	orn	r4, r0, #127	; 0x7f
   113ee:	09c0      	lsrs	r0, r0, #7
   113f0:	287f      	cmp	r0, #127	; 0x7f
   113f2:	f801 4b01 	strb.w	r4, [r1], #1
   113f6:	d8f8      	bhi.n	113ea <SEGGER_SYSVIEW_RecordU32x3+0x1e>
  ENCODE_U32(pPayload, Para1);
   113f8:	2a7f      	cmp	r2, #127	; 0x7f
  ENCODE_U32(pPayload, Para0);
   113fa:	7008      	strb	r0, [r1, #0]
   113fc:	f101 0101 	add.w	r1, r1, #1
  ENCODE_U32(pPayload, Para1);
   11400:	d906      	bls.n	11410 <SEGGER_SYSVIEW_RecordU32x3+0x44>
   11402:	f062 007f 	orn	r0, r2, #127	; 0x7f
   11406:	09d2      	lsrs	r2, r2, #7
   11408:	2a7f      	cmp	r2, #127	; 0x7f
   1140a:	f801 0b01 	strb.w	r0, [r1], #1
   1140e:	d8f8      	bhi.n	11402 <SEGGER_SYSVIEW_RecordU32x3+0x36>
  ENCODE_U32(pPayload, Para2);
   11410:	2b7f      	cmp	r3, #127	; 0x7f
  ENCODE_U32(pPayload, Para1);
   11412:	700a      	strb	r2, [r1, #0]
   11414:	f101 0401 	add.w	r4, r1, #1
  ENCODE_U32(pPayload, Para2);
   11418:	d906      	bls.n	11428 <SEGGER_SYSVIEW_RecordU32x3+0x5c>
   1141a:	f063 027f 	orn	r2, r3, #127	; 0x7f
   1141e:	09db      	lsrs	r3, r3, #7
   11420:	2b7f      	cmp	r3, #127	; 0x7f
   11422:	f804 2b01 	strb.w	r2, [r4], #1
   11426:	d8f8      	bhi.n	1141a <SEGGER_SYSVIEW_RecordU32x3+0x4e>
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   11428:	f8df 8180 	ldr.w	r8, [pc, #384]	; 115ac <SEGGER_SYSVIEW_RecordU32x3+0x1e0>
  ENCODE_U32(pPayload, Para2);
   1142c:	7023      	strb	r3, [r4, #0]
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   1142e:	f898 3000 	ldrb.w	r3, [r8]
   11432:	2b01      	cmp	r3, #1
   11434:	d012      	beq.n	1145c <SEGGER_SYSVIEW_RecordU32x3+0x90>
  if (_SYSVIEW_Globals.EnableState == 0) {
   11436:	b97b      	cbnz	r3, 11458 <SEGGER_SYSVIEW_RecordU32x3+0x8c>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   11438:	4b59      	ldr	r3, [pc, #356]	; (115a0 <SEGGER_SYSVIEW_RecordU32x3+0x1d4>)
   1143a:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   1143e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   11442:	429a      	cmp	r2, r3
   11444:	d003      	beq.n	1144e <SEGGER_SYSVIEW_RecordU32x3+0x82>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   11446:	f898 4002 	ldrb.w	r4, [r8, #2]
   1144a:	2c00      	cmp	r4, #0
   1144c:	d044      	beq.n	114d8 <SEGGER_SYSVIEW_RecordU32x3+0x10c>
  RECORD_END();
   1144e:	f385 8811 	msr	BASEPRI, r5
}
   11452:	b005      	add	sp, #20
   11454:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   11458:	2b02      	cmp	r3, #2
   1145a:	d057      	beq.n	1150c <SEGGER_SYSVIEW_RecordU32x3+0x140>
  if (EventId < 32) {
   1145c:	2e1f      	cmp	r6, #31
  ENCODE_U32(pPayload, Para2);
   1145e:	f104 0101 	add.w	r1, r4, #1
  if (EventId < 32) {
   11462:	d913      	bls.n	1148c <SEGGER_SYSVIEW_RecordU32x3+0xc0>
   11464:	b2f3      	uxtb	r3, r6
    NumBytes = pEndPacket - pStartPacket;
   11466:	1bcf      	subs	r7, r1, r7
    if (NumBytes > 127) {
   11468:	2f7f      	cmp	r7, #127	; 0x7f
   1146a:	b2f8      	uxtb	r0, r7
    NumBytes = pEndPacket - pStartPacket;
   1146c:	4c4d      	ldr	r4, [pc, #308]	; (115a4 <SEGGER_SYSVIEW_RecordU32x3+0x1d8>)
    if (NumBytes > 127) {
   1146e:	d83f      	bhi.n	114f0 <SEGGER_SYSVIEW_RecordU32x3+0x124>
    if (EventId > 127) {
   11470:	2e7f      	cmp	r6, #127	; 0x7f
      *--pStartPacket = NumBytes;
   11472:	f104 0203 	add.w	r2, r4, #3
   11476:	70e0      	strb	r0, [r4, #3]
    if (EventId > 127) {
   11478:	d944      	bls.n	11504 <SEGGER_SYSVIEW_RecordU32x3+0x138>
      *--pStartPacket = (EventId >> 7);
   1147a:	09f6      	lsrs	r6, r6, #7
      *--pStartPacket = EventId | 0x80;
   1147c:	f063 037f 	orn	r3, r3, #127	; 0x7f
      *--pStartPacket = (EventId >> 7);
   11480:	f802 6c01 	strb.w	r6, [r2, #-1]
      *--pStartPacket = EventId | 0x80;
   11484:	f802 3c02 	strb.w	r3, [r2, #-2]
   11488:	3a02      	subs	r2, #2
   1148a:	e00a      	b.n	114a2 <SEGGER_SYSVIEW_RecordU32x3+0xd6>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   1148c:	f8d8 301c 	ldr.w	r3, [r8, #28]
   11490:	40f3      	lsrs	r3, r6
   11492:	07db      	lsls	r3, r3, #31
   11494:	d4d0      	bmi.n	11438 <SEGGER_SYSVIEW_RecordU32x3+0x6c>
  if (EventId < 24) {
   11496:	2e17      	cmp	r6, #23
   11498:	b2f3      	uxtb	r3, r6
   1149a:	d8e4      	bhi.n	11466 <SEGGER_SYSVIEW_RecordU32x3+0x9a>
    *--pStartPacket = EventId;
   1149c:	4a41      	ldr	r2, [pc, #260]	; (115a4 <SEGGER_SYSVIEW_RecordU32x3+0x1d8>)
   1149e:	f802 3f03 	strb.w	r3, [r2, #3]!
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   114a2:	4841      	ldr	r0, [pc, #260]	; (115a8 <SEGGER_SYSVIEW_RecordU32x3+0x1dc>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   114a4:	f8d8 300c 	ldr.w	r3, [r8, #12]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   114a8:	6806      	ldr	r6, [r0, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   114aa:	1af3      	subs	r3, r6, r3
  ENCODE_U32(pEndPacket, Delta);
   114ac:	2b7f      	cmp	r3, #127	; 0x7f
   114ae:	d906      	bls.n	114be <SEGGER_SYSVIEW_RecordU32x3+0xf2>
   114b0:	f063 007f 	orn	r0, r3, #127	; 0x7f
   114b4:	09db      	lsrs	r3, r3, #7
   114b6:	2b7f      	cmp	r3, #127	; 0x7f
   114b8:	f801 0b01 	strb.w	r0, [r1], #1
   114bc:	d8f8      	bhi.n	114b0 <SEGGER_SYSVIEW_RecordU32x3+0xe4>
   114be:	460c      	mov	r4, r1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   114c0:	2001      	movs	r0, #1
  ENCODE_U32(pEndPacket, Delta);
   114c2:	f804 3b01 	strb.w	r3, [r4], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   114c6:	4611      	mov	r1, r2
   114c8:	1aa2      	subs	r2, r4, r2
   114ca:	f7fe fd59 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   114ce:	2800      	cmp	r0, #0
   114d0:	d054      	beq.n	1157c <SEGGER_SYSVIEW_RecordU32x3+0x1b0>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   114d2:	f8c8 600c 	str.w	r6, [r8, #12]
   114d6:	e7af      	b.n	11438 <SEGGER_SYSVIEW_RecordU32x3+0x6c>
      _SYSVIEW_Globals.RecursionCnt = 1;
   114d8:	2301      	movs	r3, #1
   114da:	f888 3002 	strb.w	r3, [r8, #2]
      _HandleIncomingPacket();
   114de:	f7fe ffdd 	bl	1049c <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   114e2:	f888 4002 	strb.w	r4, [r8, #2]
  RECORD_END();
   114e6:	f385 8811 	msr	BASEPRI, r5
}
   114ea:	b005      	add	sp, #20
   114ec:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      *--pStartPacket = NumBytes | 0x80;
   114f0:	4622      	mov	r2, r4
   114f2:	f060 007f 	orn	r0, r0, #127	; 0x7f
   114f6:	f802 0f02 	strb.w	r0, [r2, #2]!
    if (EventId > 127) {
   114fa:	2e7f      	cmp	r6, #127	; 0x7f
      *--pStartPacket = (NumBytes >> 7);
   114fc:	f3c7 10c7 	ubfx	r0, r7, #7, #8
   11500:	70e0      	strb	r0, [r4, #3]
    if (EventId > 127) {
   11502:	d8ba      	bhi.n	1147a <SEGGER_SYSVIEW_RecordU32x3+0xae>
      *--pStartPacket = EventId;
   11504:	f802 3c01 	strb.w	r3, [r2, #-1]
   11508:	3a01      	subs	r2, #1
   1150a:	e7ca      	b.n	114a2 <SEGGER_SYSVIEW_RecordU32x3+0xd6>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   1150c:	f8d8 2014 	ldr.w	r2, [r8, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   11510:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11512:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   11514:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11518:	f10d 0305 	add.w	r3, sp, #5
   1151c:	d906      	bls.n	1152c <SEGGER_SYSVIEW_RecordU32x3+0x160>
   1151e:	f062 017f 	orn	r1, r2, #127	; 0x7f
   11522:	09d2      	lsrs	r2, r2, #7
   11524:	2a7f      	cmp	r2, #127	; 0x7f
   11526:	f803 1b01 	strb.w	r1, [r3], #1
   1152a:	d8f8      	bhi.n	1151e <SEGGER_SYSVIEW_RecordU32x3+0x152>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   1152c:	491e      	ldr	r1, [pc, #120]	; (115a8 <SEGGER_SYSVIEW_RecordU32x3+0x1dc>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   1152e:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11530:	f8d1 9000 	ldr.w	r9, [r1]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11534:	f8d8 100c 	ldr.w	r1, [r8, #12]
   11538:	eba9 0101 	sub.w	r1, r9, r1
  ENCODE_U32(pPayload, Delta);
   1153c:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   1153e:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   11542:	d906      	bls.n	11552 <SEGGER_SYSVIEW_RecordU32x3+0x186>
   11544:	f061 037f 	orn	r3, r1, #127	; 0x7f
   11548:	09c9      	lsrs	r1, r1, #7
   1154a:	297f      	cmp	r1, #127	; 0x7f
   1154c:	f802 3b01 	strb.w	r3, [r2], #1
   11550:	d8f8      	bhi.n	11544 <SEGGER_SYSVIEW_RecordU32x3+0x178>
   11552:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   11554:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   11556:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   1155a:	2001      	movs	r0, #1
   1155c:	4611      	mov	r1, r2
   1155e:	1a9a      	subs	r2, r3, r2
   11560:	f7fe fd0e 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   11564:	b980      	cbnz	r0, 11588 <SEGGER_SYSVIEW_RecordU32x3+0x1bc>
    _SYSVIEW_Globals.DropCount++;
   11566:	f8d8 2014 	ldr.w	r2, [r8, #20]
   1156a:	f898 3000 	ldrb.w	r3, [r8]
   1156e:	3201      	adds	r2, #1
   11570:	f8c8 2014 	str.w	r2, [r8, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   11574:	2b01      	cmp	r3, #1
   11576:	f47f af5f 	bne.w	11438 <SEGGER_SYSVIEW_RecordU32x3+0x6c>
   1157a:	e76f      	b.n	1145c <SEGGER_SYSVIEW_RecordU32x3+0x90>
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   1157c:	f898 3000 	ldrb.w	r3, [r8]
   11580:	3301      	adds	r3, #1
   11582:	f888 3000 	strb.w	r3, [r8]
   11586:	e757      	b.n	11438 <SEGGER_SYSVIEW_RecordU32x3+0x6c>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   11588:	f898 3000 	ldrb.w	r3, [r8]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   1158c:	f8c8 900c 	str.w	r9, [r8, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   11590:	3b01      	subs	r3, #1
   11592:	b2db      	uxtb	r3, r3
   11594:	f888 3000 	strb.w	r3, [r8]
   11598:	e7ec      	b.n	11574 <SEGGER_SYSVIEW_RecordU32x3+0x1a8>
   1159a:	bf00      	nop
   1159c:	1001326c 	.word	0x1001326c
   115a0:	1001341c 	.word	0x1001341c
   115a4:	10013268 	.word	0x10013268
   115a8:	e0001004 	.word	0xe0001004
   115ac:	10013240 	.word	0x10013240

000115b0 <SEGGER_SYSVIEW_RecordSystime>:
void SEGGER_SYSVIEW_RecordSystime(void) {
   115b0:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (_SYSVIEW_Globals.pOSAPI && _SYSVIEW_Globals.pOSAPI->pfGetTime) {
   115b2:	4d5b      	ldr	r5, [pc, #364]	; (11720 <SEGGER_SYSVIEW_RecordSystime+0x170>)
   115b4:	6a2b      	ldr	r3, [r5, #32]
void SEGGER_SYSVIEW_RecordSystime(void) {
   115b6:	b085      	sub	sp, #20
  if (_SYSVIEW_Globals.pOSAPI && _SYSVIEW_Globals.pOSAPI->pfGetTime) {
   115b8:	2b00      	cmp	r3, #0
   115ba:	d054      	beq.n	11666 <SEGGER_SYSVIEW_RecordSystime+0xb6>
   115bc:	681b      	ldr	r3, [r3, #0]
   115be:	2b00      	cmp	r3, #0
   115c0:	d051      	beq.n	11666 <SEGGER_SYSVIEW_RecordSystime+0xb6>
    Systime = _SYSVIEW_Globals.pOSAPI->pfGetTime();
   115c2:	4798      	blx	r3
   115c4:	460f      	mov	r7, r1
    SEGGER_SYSVIEW_RecordU32x2(SYSVIEW_EVTID_SYSTIME_US,
   115c6:	460b      	mov	r3, r1
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
   115c8:	f3ef 8611 	mrs	r6, BASEPRI
   115cc:	f04f 0120 	mov.w	r1, #32
   115d0:	f381 8811 	msr	BASEPRI, r1
  ENCODE_U32(pPayload, Para0);
   115d4:	287f      	cmp	r0, #127	; 0x7f
   115d6:	4c53      	ldr	r4, [pc, #332]	; (11724 <SEGGER_SYSVIEW_RecordSystime+0x174>)
   115d8:	d906      	bls.n	115e8 <SEGGER_SYSVIEW_RecordSystime+0x38>
   115da:	f060 017f 	orn	r1, r0, #127	; 0x7f
   115de:	09c0      	lsrs	r0, r0, #7
   115e0:	287f      	cmp	r0, #127	; 0x7f
   115e2:	f804 1b01 	strb.w	r1, [r4], #1
   115e6:	d8f8      	bhi.n	115da <SEGGER_SYSVIEW_RecordSystime+0x2a>
  ENCODE_U32(pPayload, Para1);
   115e8:	2f7f      	cmp	r7, #127	; 0x7f
  ENCODE_U32(pPayload, Para0);
   115ea:	7020      	strb	r0, [r4, #0]
   115ec:	f104 0401 	add.w	r4, r4, #1
  ENCODE_U32(pPayload, Para1);
   115f0:	d906      	bls.n	11600 <SEGGER_SYSVIEW_RecordSystime+0x50>
   115f2:	f063 027f 	orn	r2, r3, #127	; 0x7f
   115f6:	09db      	lsrs	r3, r3, #7
   115f8:	2b7f      	cmp	r3, #127	; 0x7f
   115fa:	f804 2b01 	strb.w	r2, [r4], #1
   115fe:	d8f8      	bhi.n	115f2 <SEGGER_SYSVIEW_RecordSystime+0x42>
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   11600:	782a      	ldrb	r2, [r5, #0]
  ENCODE_U32(pPayload, Para1);
   11602:	7023      	strb	r3, [r4, #0]
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   11604:	2a01      	cmp	r2, #1
   11606:	d002      	beq.n	1160e <SEGGER_SYSVIEW_RecordSystime+0x5e>
  if (_SYSVIEW_Globals.EnableState == 0) {
   11608:	b302      	cbz	r2, 1164c <SEGGER_SYSVIEW_RecordSystime+0x9c>
  if (_SYSVIEW_Globals.EnableState == 2) {
   1160a:	2a02      	cmp	r2, #2
   1160c:	d051      	beq.n	116b2 <SEGGER_SYSVIEW_RecordSystime+0x102>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   1160e:	69eb      	ldr	r3, [r5, #28]
   11610:	049b      	lsls	r3, r3, #18
   11612:	d41b      	bmi.n	1164c <SEGGER_SYSVIEW_RecordSystime+0x9c>
    *--pStartPacket = EventId;
   11614:	4a44      	ldr	r2, [pc, #272]	; (11728 <SEGGER_SYSVIEW_RecordSystime+0x178>)
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11616:	4b45      	ldr	r3, [pc, #276]	; (1172c <SEGGER_SYSVIEW_RecordSystime+0x17c>)
    *--pStartPacket = EventId;
   11618:	210d      	movs	r1, #13
   1161a:	70d1      	strb	r1, [r2, #3]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   1161c:	681f      	ldr	r7, [r3, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   1161e:	68eb      	ldr	r3, [r5, #12]
   11620:	1afb      	subs	r3, r7, r3
  ENCODE_U32(pEndPacket, Delta);
   11622:	2b7f      	cmp	r3, #127	; 0x7f
  ENCODE_U32(pPayload, Para1);
   11624:	f104 0201 	add.w	r2, r4, #1
  ENCODE_U32(pEndPacket, Delta);
   11628:	d906      	bls.n	11638 <SEGGER_SYSVIEW_RecordSystime+0x88>
   1162a:	f063 017f 	orn	r1, r3, #127	; 0x7f
   1162e:	09db      	lsrs	r3, r3, #7
   11630:	2b7f      	cmp	r3, #127	; 0x7f
   11632:	f802 1b01 	strb.w	r1, [r2], #1
   11636:	d8f8      	bhi.n	1162a <SEGGER_SYSVIEW_RecordSystime+0x7a>
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   11638:	483d      	ldr	r0, [pc, #244]	; (11730 <SEGGER_SYSVIEW_RecordSystime+0x180>)
  ENCODE_U32(pEndPacket, Delta);
   1163a:	f802 3b01 	strb.w	r3, [r2], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   1163e:	4601      	mov	r1, r0
   11640:	1a12      	subs	r2, r2, r0
   11642:	2001      	movs	r0, #1
   11644:	f7fe fc9c 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   11648:	b378      	cbz	r0, 116aa <SEGGER_SYSVIEW_RecordSystime+0xfa>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   1164a:	60ef      	str	r7, [r5, #12]
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   1164c:	4b39      	ldr	r3, [pc, #228]	; (11734 <SEGGER_SYSVIEW_RecordSystime+0x184>)
   1164e:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   11652:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   11656:	429a      	cmp	r2, r3
   11658:	d001      	beq.n	1165e <SEGGER_SYSVIEW_RecordSystime+0xae>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   1165a:	78ac      	ldrb	r4, [r5, #2]
   1165c:	b1fc      	cbz	r4, 1169e <SEGGER_SYSVIEW_RecordSystime+0xee>
  RECORD_END();
   1165e:	f386 8811 	msr	BASEPRI, r6
}
   11662:	b005      	add	sp, #20
   11664:	bdf0      	pop	{r4, r5, r6, r7, pc}
    SEGGER_SYSVIEW_RecordU32(SYSVIEW_EVTID_SYSTIME_CYCLES, SEGGER_SYSVIEW_GET_TIMESTAMP());
   11666:	4b31      	ldr	r3, [pc, #196]	; (1172c <SEGGER_SYSVIEW_RecordSystime+0x17c>)
   11668:	681b      	ldr	r3, [r3, #0]
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
   1166a:	f3ef 8411 	mrs	r4, BASEPRI
   1166e:	f04f 0120 	mov.w	r1, #32
   11672:	f381 8811 	msr	BASEPRI, r1
  ENCODE_U32(pPayload, Value);
   11676:	2b7f      	cmp	r3, #127	; 0x7f
   11678:	492a      	ldr	r1, [pc, #168]	; (11724 <SEGGER_SYSVIEW_RecordSystime+0x174>)
   1167a:	d906      	bls.n	1168a <SEGGER_SYSVIEW_RecordSystime+0xda>
   1167c:	f063 027f 	orn	r2, r3, #127	; 0x7f
   11680:	09db      	lsrs	r3, r3, #7
   11682:	2b7f      	cmp	r3, #127	; 0x7f
   11684:	f801 2b01 	strb.w	r2, [r1], #1
   11688:	d8f8      	bhi.n	1167c <SEGGER_SYSVIEW_RecordSystime+0xcc>
  _SendPacket(pPayloadStart, pPayload, EventID);
   1168a:	4826      	ldr	r0, [pc, #152]	; (11724 <SEGGER_SYSVIEW_RecordSystime+0x174>)
  ENCODE_U32(pPayload, Value);
   1168c:	f801 3b01 	strb.w	r3, [r1], #1
  _SendPacket(pPayloadStart, pPayload, EventID);
   11690:	220c      	movs	r2, #12
   11692:	f7fe ff91 	bl	105b8 <_SendPacket>
  RECORD_END();
   11696:	f384 8811 	msr	BASEPRI, r4
}
   1169a:	b005      	add	sp, #20
   1169c:	bdf0      	pop	{r4, r5, r6, r7, pc}
      _SYSVIEW_Globals.RecursionCnt = 1;
   1169e:	2301      	movs	r3, #1
   116a0:	70ab      	strb	r3, [r5, #2]
      _HandleIncomingPacket();
   116a2:	f7fe fefb 	bl	1049c <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   116a6:	70ac      	strb	r4, [r5, #2]
   116a8:	e7d9      	b.n	1165e <SEGGER_SYSVIEW_RecordSystime+0xae>
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   116aa:	782b      	ldrb	r3, [r5, #0]
   116ac:	3301      	adds	r3, #1
   116ae:	702b      	strb	r3, [r5, #0]
   116b0:	e7cc      	b.n	1164c <SEGGER_SYSVIEW_RecordSystime+0x9c>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   116b2:	696a      	ldr	r2, [r5, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   116b4:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   116b6:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   116b8:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   116bc:	f10d 0305 	add.w	r3, sp, #5
   116c0:	d906      	bls.n	116d0 <SEGGER_SYSVIEW_RecordSystime+0x120>
   116c2:	f062 017f 	orn	r1, r2, #127	; 0x7f
   116c6:	09d2      	lsrs	r2, r2, #7
   116c8:	2a7f      	cmp	r2, #127	; 0x7f
   116ca:	f803 1b01 	strb.w	r1, [r3], #1
   116ce:	d8f8      	bhi.n	116c2 <SEGGER_SYSVIEW_RecordSystime+0x112>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   116d0:	4916      	ldr	r1, [pc, #88]	; (1172c <SEGGER_SYSVIEW_RecordSystime+0x17c>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   116d2:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   116d4:	680f      	ldr	r7, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   116d6:	68e9      	ldr	r1, [r5, #12]
   116d8:	1a79      	subs	r1, r7, r1
  ENCODE_U32(pPayload, Delta);
   116da:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   116dc:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   116e0:	d906      	bls.n	116f0 <SEGGER_SYSVIEW_RecordSystime+0x140>
   116e2:	f061 037f 	orn	r3, r1, #127	; 0x7f
   116e6:	09c9      	lsrs	r1, r1, #7
   116e8:	297f      	cmp	r1, #127	; 0x7f
   116ea:	f802 3b01 	strb.w	r3, [r2], #1
   116ee:	d8f8      	bhi.n	116e2 <SEGGER_SYSVIEW_RecordSystime+0x132>
   116f0:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   116f2:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   116f4:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   116f8:	2001      	movs	r0, #1
   116fa:	4611      	mov	r1, r2
   116fc:	1a9a      	subs	r2, r3, r2
   116fe:	f7fe fc3f 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   11702:	b930      	cbnz	r0, 11712 <SEGGER_SYSVIEW_RecordSystime+0x162>
    _SYSVIEW_Globals.DropCount++;
   11704:	696a      	ldr	r2, [r5, #20]
   11706:	782b      	ldrb	r3, [r5, #0]
   11708:	3201      	adds	r2, #1
   1170a:	616a      	str	r2, [r5, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   1170c:	2b01      	cmp	r3, #1
   1170e:	d19d      	bne.n	1164c <SEGGER_SYSVIEW_RecordSystime+0x9c>
   11710:	e77d      	b.n	1160e <SEGGER_SYSVIEW_RecordSystime+0x5e>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   11712:	782b      	ldrb	r3, [r5, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   11714:	60ef      	str	r7, [r5, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   11716:	3b01      	subs	r3, #1
   11718:	b2db      	uxtb	r3, r3
   1171a:	702b      	strb	r3, [r5, #0]
   1171c:	e7f6      	b.n	1170c <SEGGER_SYSVIEW_RecordSystime+0x15c>
   1171e:	bf00      	nop
   11720:	10013240 	.word	0x10013240
   11724:	1001326c 	.word	0x1001326c
   11728:	10013268 	.word	0x10013268
   1172c:	e0001004 	.word	0xe0001004
   11730:	1001326b 	.word	0x1001326b
   11734:	1001341c 	.word	0x1001341c

00011738 <SEGGER_SYSVIEW_Start>:
void SEGGER_SYSVIEW_Start(void) {
   11738:	b538      	push	{r3, r4, r5, lr}
  if (_SYSVIEW_Globals.EnableState == 0) {
   1173a:	4c3b      	ldr	r4, [pc, #236]	; (11828 <SEGGER_SYSVIEW_Start+0xf0>)
   1173c:	7823      	ldrb	r3, [r4, #0]
   1173e:	b103      	cbz	r3, 11742 <SEGGER_SYSVIEW_Start+0xa>
}
   11740:	bd38      	pop	{r3, r4, r5, pc}
    _SYSVIEW_Globals.EnableState = 1;
   11742:	2001      	movs	r0, #1
   11744:	7020      	strb	r0, [r4, #0]
    SEGGER_SYSVIEW_LOCK();
   11746:	f3ef 8511 	mrs	r5, BASEPRI
   1174a:	f04f 0120 	mov.w	r1, #32
   1174e:	f381 8811 	msr	BASEPRI, r1
    SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, _abSync, 10);
   11752:	220a      	movs	r2, #10
   11754:	4935      	ldr	r1, [pc, #212]	; (1182c <SEGGER_SYSVIEW_Start+0xf4>)
   11756:	f7fe fc13 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
    SEGGER_SYSVIEW_UNLOCK();
   1175a:	f385 8811 	msr	BASEPRI, r5
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
   1175e:	f3ef 8511 	mrs	r5, BASEPRI
   11762:	f04f 0120 	mov.w	r1, #32
   11766:	f381 8811 	msr	BASEPRI, r1
  _SendPacket(pPayloadStart, pPayloadStart, EventID);
   1176a:	4931      	ldr	r1, [pc, #196]	; (11830 <SEGGER_SYSVIEW_Start+0xf8>)
   1176c:	220a      	movs	r2, #10
   1176e:	4608      	mov	r0, r1
   11770:	f7fe ff22 	bl	105b8 <_SendPacket>
  RECORD_END();
   11774:	f385 8811 	msr	BASEPRI, r5
      RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
   11778:	f3ef 8511 	mrs	r5, BASEPRI
   1177c:	f04f 0120 	mov.w	r1, #32
   11780:	f381 8811 	msr	BASEPRI, r1
      ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
   11784:	6862      	ldr	r2, [r4, #4]
   11786:	4b2a      	ldr	r3, [pc, #168]	; (11830 <SEGGER_SYSVIEW_Start+0xf8>)
   11788:	2a7f      	cmp	r2, #127	; 0x7f
   1178a:	d906      	bls.n	1179a <SEGGER_SYSVIEW_Start+0x62>
   1178c:	f062 017f 	orn	r1, r2, #127	; 0x7f
   11790:	09d2      	lsrs	r2, r2, #7
   11792:	2a7f      	cmp	r2, #127	; 0x7f
   11794:	f803 1b01 	strb.w	r1, [r3], #1
   11798:	d8f8      	bhi.n	1178c <SEGGER_SYSVIEW_Start+0x54>
      ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
   1179a:	68a1      	ldr	r1, [r4, #8]
      ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
   1179c:	701a      	strb	r2, [r3, #0]
      ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
   1179e:	297f      	cmp	r1, #127	; 0x7f
      ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
   117a0:	f103 0301 	add.w	r3, r3, #1
      ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
   117a4:	d906      	bls.n	117b4 <SEGGER_SYSVIEW_Start+0x7c>
   117a6:	f061 027f 	orn	r2, r1, #127	; 0x7f
   117aa:	09c9      	lsrs	r1, r1, #7
   117ac:	297f      	cmp	r1, #127	; 0x7f
   117ae:	f803 2b01 	strb.w	r2, [r3], #1
   117b2:	d8f8      	bhi.n	117a6 <SEGGER_SYSVIEW_Start+0x6e>
      ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
   117b4:	6922      	ldr	r2, [r4, #16]
      ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
   117b6:	7019      	strb	r1, [r3, #0]
      ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
   117b8:	2a7f      	cmp	r2, #127	; 0x7f
      ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
   117ba:	f103 0301 	add.w	r3, r3, #1
      ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
   117be:	d906      	bls.n	117ce <SEGGER_SYSVIEW_Start+0x96>
   117c0:	f062 017f 	orn	r1, r2, #127	; 0x7f
   117c4:	09d2      	lsrs	r2, r2, #7
   117c6:	2a7f      	cmp	r2, #127	; 0x7f
   117c8:	f803 1b01 	strb.w	r1, [r3], #1
   117cc:	d8f8      	bhi.n	117c0 <SEGGER_SYSVIEW_Start+0x88>
      ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
   117ce:	2002      	movs	r0, #2
      _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
   117d0:	1819      	adds	r1, r3, r0
      ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
   117d2:	701a      	strb	r2, [r3, #0]
      ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
   117d4:	7058      	strb	r0, [r3, #1]
      _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
   117d6:	2218      	movs	r2, #24
   117d8:	4815      	ldr	r0, [pc, #84]	; (11830 <SEGGER_SYSVIEW_Start+0xf8>)
   117da:	f7fe feed 	bl	105b8 <_SendPacket>
      RECORD_END();
   117de:	f385 8811 	msr	BASEPRI, r5
    if (_SYSVIEW_Globals.pfSendSysDesc) {
   117e2:	6a63      	ldr	r3, [r4, #36]	; 0x24
   117e4:	b103      	cbz	r3, 117e8 <SEGGER_SYSVIEW_Start+0xb0>
      _SYSVIEW_Globals.pfSendSysDesc();
   117e6:	4798      	blx	r3
    SEGGER_SYSVIEW_RecordSystime();
   117e8:	f7ff fee2 	bl	115b0 <SEGGER_SYSVIEW_RecordSystime>
  if (_SYSVIEW_Globals.pOSAPI && _SYSVIEW_Globals.pOSAPI->pfSendTaskList) {
   117ec:	6a23      	ldr	r3, [r4, #32]
   117ee:	b113      	cbz	r3, 117f6 <SEGGER_SYSVIEW_Start+0xbe>
   117f0:	685b      	ldr	r3, [r3, #4]
   117f2:	b103      	cbz	r3, 117f6 <SEGGER_SYSVIEW_Start+0xbe>
    _SYSVIEW_Globals.pOSAPI->pfSendTaskList();
   117f4:	4798      	blx	r3
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2*SEGGER_SYSVIEW_QUANTA_U32);
   117f6:	f3ef 8411 	mrs	r4, BASEPRI
   117fa:	f04f 0120 	mov.w	r1, #32
   117fe:	f381 8811 	msr	BASEPRI, r1
  ENCODE_U32(pPayload, _NumModules);
   11802:	4b0c      	ldr	r3, [pc, #48]	; (11834 <SEGGER_SYSVIEW_Start+0xfc>)
   11804:	781b      	ldrb	r3, [r3, #0]
   11806:	2b7f      	cmp	r3, #127	; 0x7f
   11808:	d90c      	bls.n	11824 <SEGGER_SYSVIEW_Start+0xec>
   1180a:	490b      	ldr	r1, [pc, #44]	; (11838 <SEGGER_SYSVIEW_Start+0x100>)
   1180c:	710b      	strb	r3, [r1, #4]
   1180e:	3105      	adds	r1, #5
   11810:	2301      	movs	r3, #1
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_NUMMODULES);
   11812:	4807      	ldr	r0, [pc, #28]	; (11830 <SEGGER_SYSVIEW_Start+0xf8>)
  ENCODE_U32(pPayload, _NumModules);
   11814:	f801 3b01 	strb.w	r3, [r1], #1
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_NUMMODULES);
   11818:	221b      	movs	r2, #27
   1181a:	f7fe fecd 	bl	105b8 <_SendPacket>
  RECORD_END();
   1181e:	f384 8811 	msr	BASEPRI, r4
}
   11822:	bd38      	pop	{r3, r4, r5, pc}
  ENCODE_U32(pPayload, _NumModules);
   11824:	4902      	ldr	r1, [pc, #8]	; (11830 <SEGGER_SYSVIEW_Start+0xf8>)
   11826:	e7f4      	b.n	11812 <SEGGER_SYSVIEW_Start+0xda>
   11828:	10013240 	.word	0x10013240
   1182c:	00013994 	.word	0x00013994
   11830:	1001326c 	.word	0x1001326c
   11834:	1001323c 	.word	0x1001323c
   11838:	10013268 	.word	0x10013268

0001183c <SEGGER_SYSVIEW_RecordVoid>:
void SEGGER_SYSVIEW_RecordVoid(unsigned int EventID) {
   1183c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1183e:	4605      	mov	r5, r0
   11840:	b085      	sub	sp, #20
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
   11842:	f3ef 8611 	mrs	r6, BASEPRI
   11846:	f04f 0120 	mov.w	r1, #32
   1184a:	f381 8811 	msr	BASEPRI, r1
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   1184e:	4c49      	ldr	r4, [pc, #292]	; (11974 <SEGGER_SYSVIEW_RecordVoid+0x138>)
   11850:	7823      	ldrb	r3, [r4, #0]
   11852:	2b01      	cmp	r3, #1
   11854:	d010      	beq.n	11878 <SEGGER_SYSVIEW_RecordVoid+0x3c>
  if (_SYSVIEW_Globals.EnableState == 0) {
   11856:	b96b      	cbnz	r3, 11874 <SEGGER_SYSVIEW_RecordVoid+0x38>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   11858:	4b47      	ldr	r3, [pc, #284]	; (11978 <SEGGER_SYSVIEW_RecordVoid+0x13c>)
   1185a:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   1185e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   11862:	429a      	cmp	r2, r3
   11864:	d002      	beq.n	1186c <SEGGER_SYSVIEW_RecordVoid+0x30>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   11866:	78a5      	ldrb	r5, [r4, #2]
   11868:	2d00      	cmp	r5, #0
   1186a:	d039      	beq.n	118e0 <SEGGER_SYSVIEW_RecordVoid+0xa4>
  RECORD_END();
   1186c:	f386 8811 	msr	BASEPRI, r6
}
   11870:	b005      	add	sp, #20
   11872:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   11874:	2b02      	cmp	r3, #2
   11876:	d041      	beq.n	118fc <SEGGER_SYSVIEW_RecordVoid+0xc0>
  if (EventId < 32) {
   11878:	2d1f      	cmp	r5, #31
   1187a:	d823      	bhi.n	118c4 <SEGGER_SYSVIEW_RecordVoid+0x88>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   1187c:	69e3      	ldr	r3, [r4, #28]
   1187e:	40eb      	lsrs	r3, r5
   11880:	f013 0301 	ands.w	r3, r3, #1
   11884:	d1e8      	bne.n	11858 <SEGGER_SYSVIEW_RecordVoid+0x1c>
  if (EventId < 24) {
   11886:	2d17      	cmp	r5, #23
   11888:	b2ea      	uxtb	r2, r5
   1188a:	d832      	bhi.n	118f2 <SEGGER_SYSVIEW_RecordVoid+0xb6>
    *--pStartPacket = EventId;
   1188c:	483b      	ldr	r0, [pc, #236]	; (1197c <SEGGER_SYSVIEW_RecordVoid+0x140>)
   1188e:	f800 2f03 	strb.w	r2, [r0, #3]!
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11892:	4a3b      	ldr	r2, [pc, #236]	; (11980 <SEGGER_SYSVIEW_RecordVoid+0x144>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11894:	68e3      	ldr	r3, [r4, #12]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11896:	6815      	ldr	r5, [r2, #0]
  ENCODE_U32(pEndPacket, Delta);
   11898:	4a3a      	ldr	r2, [pc, #232]	; (11984 <SEGGER_SYSVIEW_RecordVoid+0x148>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   1189a:	1aeb      	subs	r3, r5, r3
  ENCODE_U32(pEndPacket, Delta);
   1189c:	2b7f      	cmp	r3, #127	; 0x7f
   1189e:	d906      	bls.n	118ae <SEGGER_SYSVIEW_RecordVoid+0x72>
   118a0:	f063 017f 	orn	r1, r3, #127	; 0x7f
   118a4:	09db      	lsrs	r3, r3, #7
   118a6:	2b7f      	cmp	r3, #127	; 0x7f
   118a8:	f802 1b01 	strb.w	r1, [r2], #1
   118ac:	d8f8      	bhi.n	118a0 <SEGGER_SYSVIEW_RecordVoid+0x64>
   118ae:	f802 3b01 	strb.w	r3, [r2], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   118b2:	4601      	mov	r1, r0
   118b4:	1a12      	subs	r2, r2, r0
   118b6:	2001      	movs	r0, #1
   118b8:	f7fe fb62 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   118bc:	2800      	cmp	r0, #0
   118be:	d04e      	beq.n	1195e <SEGGER_SYSVIEW_RecordVoid+0x122>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   118c0:	60e5      	str	r5, [r4, #12]
   118c2:	e7c9      	b.n	11858 <SEGGER_SYSVIEW_RecordVoid+0x1c>
      *--pStartPacket = NumBytes;
   118c4:	492d      	ldr	r1, [pc, #180]	; (1197c <SEGGER_SYSVIEW_RecordVoid+0x140>)
   118c6:	2300      	movs	r3, #0
    if (EventId > 127) {
   118c8:	2d7f      	cmp	r5, #127	; 0x7f
      *--pStartPacket = NumBytes;
   118ca:	70cb      	strb	r3, [r1, #3]
   118cc:	b2ea      	uxtb	r2, r5
    if (EventId > 127) {
   118ce:	d912      	bls.n	118f6 <SEGGER_SYSVIEW_RecordVoid+0xba>
      *--pStartPacket = EventId | 0x80;
   118d0:	4608      	mov	r0, r1
      *--pStartPacket = (EventId >> 7);
   118d2:	09ed      	lsrs	r5, r5, #7
      *--pStartPacket = EventId | 0x80;
   118d4:	f062 027f 	orn	r2, r2, #127	; 0x7f
      *--pStartPacket = (EventId >> 7);
   118d8:	708d      	strb	r5, [r1, #2]
      *--pStartPacket = EventId | 0x80;
   118da:	f800 2f01 	strb.w	r2, [r0, #1]!
   118de:	e7d8      	b.n	11892 <SEGGER_SYSVIEW_RecordVoid+0x56>
      _SYSVIEW_Globals.RecursionCnt = 1;
   118e0:	2301      	movs	r3, #1
   118e2:	70a3      	strb	r3, [r4, #2]
      _HandleIncomingPacket();
   118e4:	f7fe fdda 	bl	1049c <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   118e8:	70a5      	strb	r5, [r4, #2]
  RECORD_END();
   118ea:	f386 8811 	msr	BASEPRI, r6
}
   118ee:	b005      	add	sp, #20
   118f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
      *--pStartPacket = NumBytes;
   118f2:	4922      	ldr	r1, [pc, #136]	; (1197c <SEGGER_SYSVIEW_RecordVoid+0x140>)
   118f4:	70cb      	strb	r3, [r1, #3]
      *--pStartPacket = EventId;
   118f6:	4824      	ldr	r0, [pc, #144]	; (11988 <SEGGER_SYSVIEW_RecordVoid+0x14c>)
   118f8:	708a      	strb	r2, [r1, #2]
   118fa:	e7ca      	b.n	11892 <SEGGER_SYSVIEW_RecordVoid+0x56>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   118fc:	6962      	ldr	r2, [r4, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   118fe:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11900:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   11902:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11906:	f10d 0305 	add.w	r3, sp, #5
   1190a:	d906      	bls.n	1191a <SEGGER_SYSVIEW_RecordVoid+0xde>
   1190c:	f062 017f 	orn	r1, r2, #127	; 0x7f
   11910:	09d2      	lsrs	r2, r2, #7
   11912:	2a7f      	cmp	r2, #127	; 0x7f
   11914:	f803 1b01 	strb.w	r1, [r3], #1
   11918:	d8f8      	bhi.n	1190c <SEGGER_SYSVIEW_RecordVoid+0xd0>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   1191a:	4919      	ldr	r1, [pc, #100]	; (11980 <SEGGER_SYSVIEW_RecordVoid+0x144>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   1191c:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   1191e:	680f      	ldr	r7, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11920:	68e1      	ldr	r1, [r4, #12]
   11922:	1a79      	subs	r1, r7, r1
  ENCODE_U32(pPayload, Delta);
   11924:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11926:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   1192a:	d906      	bls.n	1193a <SEGGER_SYSVIEW_RecordVoid+0xfe>
   1192c:	f061 037f 	orn	r3, r1, #127	; 0x7f
   11930:	09c9      	lsrs	r1, r1, #7
   11932:	297f      	cmp	r1, #127	; 0x7f
   11934:	f802 3b01 	strb.w	r3, [r2], #1
   11938:	d8f8      	bhi.n	1192c <SEGGER_SYSVIEW_RecordVoid+0xf0>
   1193a:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   1193c:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   1193e:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   11942:	2001      	movs	r0, #1
   11944:	4611      	mov	r1, r2
   11946:	1a9a      	subs	r2, r3, r2
   11948:	f7fe fb1a 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   1194c:	b958      	cbnz	r0, 11966 <SEGGER_SYSVIEW_RecordVoid+0x12a>
    _SYSVIEW_Globals.DropCount++;
   1194e:	6962      	ldr	r2, [r4, #20]
   11950:	7823      	ldrb	r3, [r4, #0]
   11952:	3201      	adds	r2, #1
   11954:	6162      	str	r2, [r4, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   11956:	2b01      	cmp	r3, #1
   11958:	f47f af7e 	bne.w	11858 <SEGGER_SYSVIEW_RecordVoid+0x1c>
   1195c:	e78c      	b.n	11878 <SEGGER_SYSVIEW_RecordVoid+0x3c>
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   1195e:	7823      	ldrb	r3, [r4, #0]
   11960:	3301      	adds	r3, #1
   11962:	7023      	strb	r3, [r4, #0]
   11964:	e778      	b.n	11858 <SEGGER_SYSVIEW_RecordVoid+0x1c>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   11966:	7823      	ldrb	r3, [r4, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   11968:	60e7      	str	r7, [r4, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   1196a:	3b01      	subs	r3, #1
   1196c:	b2db      	uxtb	r3, r3
   1196e:	7023      	strb	r3, [r4, #0]
   11970:	e7f1      	b.n	11956 <SEGGER_SYSVIEW_RecordVoid+0x11a>
   11972:	bf00      	nop
   11974:	10013240 	.word	0x10013240
   11978:	1001341c 	.word	0x1001341c
   1197c:	10013268 	.word	0x10013268
   11980:	e0001004 	.word	0xe0001004
   11984:	1001326c 	.word	0x1001326c
   11988:	1001326a 	.word	0x1001326a

0001198c <SEGGER_SYSVIEW_GetSysDesc>:
void SEGGER_SYSVIEW_GetSysDesc(void) {
   1198c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   11990:	b084      	sub	sp, #16
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
   11992:	f3ef 8711 	mrs	r7, BASEPRI
   11996:	f04f 0120 	mov.w	r1, #32
   1199a:	f381 8811 	msr	BASEPRI, r1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
   1199e:	4d5b      	ldr	r5, [pc, #364]	; (11b0c <SEGGER_SYSVIEW_GetSysDesc+0x180>)
   119a0:	4e5b      	ldr	r6, [pc, #364]	; (11b10 <SEGGER_SYSVIEW_GetSysDesc+0x184>)
   119a2:	686b      	ldr	r3, [r5, #4]
   119a4:	2b7f      	cmp	r3, #127	; 0x7f
   119a6:	4634      	mov	r4, r6
   119a8:	d906      	bls.n	119b8 <SEGGER_SYSVIEW_GetSysDesc+0x2c>
   119aa:	f063 027f 	orn	r2, r3, #127	; 0x7f
   119ae:	09db      	lsrs	r3, r3, #7
   119b0:	2b7f      	cmp	r3, #127	; 0x7f
   119b2:	f804 2b01 	strb.w	r2, [r4], #1
   119b6:	d8f8      	bhi.n	119aa <SEGGER_SYSVIEW_GetSysDesc+0x1e>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
   119b8:	68aa      	ldr	r2, [r5, #8]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
   119ba:	7023      	strb	r3, [r4, #0]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
   119bc:	2a7f      	cmp	r2, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
   119be:	f104 0401 	add.w	r4, r4, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
   119c2:	d906      	bls.n	119d2 <SEGGER_SYSVIEW_GetSysDesc+0x46>
   119c4:	f062 037f 	orn	r3, r2, #127	; 0x7f
   119c8:	09d2      	lsrs	r2, r2, #7
   119ca:	2a7f      	cmp	r2, #127	; 0x7f
   119cc:	f804 3b01 	strb.w	r3, [r4], #1
   119d0:	d8f8      	bhi.n	119c4 <SEGGER_SYSVIEW_GetSysDesc+0x38>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
   119d2:	692b      	ldr	r3, [r5, #16]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
   119d4:	7022      	strb	r2, [r4, #0]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
   119d6:	2b7f      	cmp	r3, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
   119d8:	f104 0401 	add.w	r4, r4, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
   119dc:	d906      	bls.n	119ec <SEGGER_SYSVIEW_GetSysDesc+0x60>
   119de:	f063 027f 	orn	r2, r3, #127	; 0x7f
   119e2:	09db      	lsrs	r3, r3, #7
   119e4:	2b7f      	cmp	r3, #127	; 0x7f
   119e6:	f804 2b01 	strb.w	r2, [r4], #1
   119ea:	d8f8      	bhi.n	119de <SEGGER_SYSVIEW_GetSysDesc+0x52>
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   119ec:	782a      	ldrb	r2, [r5, #0]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
   119ee:	7023      	strb	r3, [r4, #0]
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   119f0:	2a01      	cmp	r2, #1
  ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
   119f2:	f04f 0302 	mov.w	r3, #2
   119f6:	7063      	strb	r3, [r4, #1]
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   119f8:	d014      	beq.n	11a24 <SEGGER_SYSVIEW_GetSysDesc+0x98>
  if (_SYSVIEW_Globals.EnableState == 0) {
   119fa:	b98a      	cbnz	r2, 11a20 <SEGGER_SYSVIEW_GetSysDesc+0x94>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   119fc:	4b45      	ldr	r3, [pc, #276]	; (11b14 <SEGGER_SYSVIEW_GetSysDesc+0x188>)
   119fe:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   11a02:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   11a06:	429a      	cmp	r2, r3
   11a08:	d002      	beq.n	11a10 <SEGGER_SYSVIEW_GetSysDesc+0x84>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   11a0a:	78ac      	ldrb	r4, [r5, #2]
   11a0c:	2c00      	cmp	r4, #0
   11a0e:	d031      	beq.n	11a74 <SEGGER_SYSVIEW_GetSysDesc+0xe8>
  RECORD_END();
   11a10:	f387 8811 	msr	BASEPRI, r7
  if (_SYSVIEW_Globals.pfSendSysDesc) {
   11a14:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   11a16:	b103      	cbz	r3, 11a1a <SEGGER_SYSVIEW_GetSysDesc+0x8e>
    _SYSVIEW_Globals.pfSendSysDesc();
   11a18:	4798      	blx	r3
}
   11a1a:	b004      	add	sp, #16
   11a1c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   11a20:	2a02      	cmp	r2, #2
   11a22:	d035      	beq.n	11a90 <SEGGER_SYSVIEW_GetSysDesc+0x104>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   11a24:	7feb      	ldrb	r3, [r5, #31]
   11a26:	07db      	lsls	r3, r3, #31
   11a28:	d4e8      	bmi.n	119fc <SEGGER_SYSVIEW_GetSysDesc+0x70>
  ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
   11a2a:	1ca2      	adds	r2, r4, #2
    NumBytes = pEndPacket - pStartPacket;
   11a2c:	1b96      	subs	r6, r2, r6
    if (NumBytes > 127) {
   11a2e:	2e7f      	cmp	r6, #127	; 0x7f
   11a30:	b2f3      	uxtb	r3, r6
    NumBytes = pEndPacket - pStartPacket;
   11a32:	4839      	ldr	r0, [pc, #228]	; (11b18 <SEGGER_SYSVIEW_GetSysDesc+0x18c>)
    if (NumBytes > 127) {
   11a34:	d824      	bhi.n	11a80 <SEGGER_SYSVIEW_GetSysDesc+0xf4>
      *--pStartPacket = NumBytes;
   11a36:	1cc1      	adds	r1, r0, #3
   11a38:	70c3      	strb	r3, [r0, #3]
      *--pStartPacket = EventId;
   11a3a:	2418      	movs	r4, #24
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11a3c:	4b37      	ldr	r3, [pc, #220]	; (11b1c <SEGGER_SYSVIEW_GetSysDesc+0x190>)
      *--pStartPacket = EventId;
   11a3e:	f801 4c01 	strb.w	r4, [r1, #-1]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11a42:	681c      	ldr	r4, [r3, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11a44:	68eb      	ldr	r3, [r5, #12]
   11a46:	1ae3      	subs	r3, r4, r3
  ENCODE_U32(pEndPacket, Delta);
   11a48:	2b7f      	cmp	r3, #127	; 0x7f
      *--pStartPacket = EventId;
   11a4a:	f101 30ff 	add.w	r0, r1, #4294967295	; 0xffffffff
  ENCODE_U32(pEndPacket, Delta);
   11a4e:	d906      	bls.n	11a5e <SEGGER_SYSVIEW_GetSysDesc+0xd2>
   11a50:	f063 017f 	orn	r1, r3, #127	; 0x7f
   11a54:	09db      	lsrs	r3, r3, #7
   11a56:	2b7f      	cmp	r3, #127	; 0x7f
   11a58:	f802 1b01 	strb.w	r1, [r2], #1
   11a5c:	d8f8      	bhi.n	11a50 <SEGGER_SYSVIEW_GetSysDesc+0xc4>
   11a5e:	f802 3b01 	strb.w	r3, [r2], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   11a62:	4601      	mov	r1, r0
   11a64:	1a12      	subs	r2, r2, r0
   11a66:	2001      	movs	r0, #1
   11a68:	f7fe fa8a 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   11a6c:	2800      	cmp	r0, #0
   11a6e:	d041      	beq.n	11af4 <SEGGER_SYSVIEW_GetSysDesc+0x168>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   11a70:	60ec      	str	r4, [r5, #12]
   11a72:	e7c3      	b.n	119fc <SEGGER_SYSVIEW_GetSysDesc+0x70>
      _SYSVIEW_Globals.RecursionCnt = 1;
   11a74:	2301      	movs	r3, #1
   11a76:	70ab      	strb	r3, [r5, #2]
      _HandleIncomingPacket();
   11a78:	f7fe fd10 	bl	1049c <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   11a7c:	70ac      	strb	r4, [r5, #2]
   11a7e:	e7c7      	b.n	11a10 <SEGGER_SYSVIEW_GetSysDesc+0x84>
      *--pStartPacket = NumBytes | 0x80;
   11a80:	4601      	mov	r1, r0
   11a82:	f063 037f 	orn	r3, r3, #127	; 0x7f
   11a86:	f801 3f02 	strb.w	r3, [r1, #2]!
      *--pStartPacket = (NumBytes >> 7);
   11a8a:	f3c6 13c7 	ubfx	r3, r6, #7, #8
   11a8e:	e7d3      	b.n	11a38 <SEGGER_SYSVIEW_GetSysDesc+0xac>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11a90:	696a      	ldr	r2, [r5, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   11a92:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11a94:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   11a96:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11a9a:	f10d 0305 	add.w	r3, sp, #5
   11a9e:	d906      	bls.n	11aae <SEGGER_SYSVIEW_GetSysDesc+0x122>
   11aa0:	f062 017f 	orn	r1, r2, #127	; 0x7f
   11aa4:	09d2      	lsrs	r2, r2, #7
   11aa6:	2a7f      	cmp	r2, #127	; 0x7f
   11aa8:	f803 1b01 	strb.w	r1, [r3], #1
   11aac:	d8f8      	bhi.n	11aa0 <SEGGER_SYSVIEW_GetSysDesc+0x114>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11aae:	491b      	ldr	r1, [pc, #108]	; (11b1c <SEGGER_SYSVIEW_GetSysDesc+0x190>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11ab0:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11ab2:	f8d1 8000 	ldr.w	r8, [r1]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11ab6:	68e9      	ldr	r1, [r5, #12]
   11ab8:	eba8 0101 	sub.w	r1, r8, r1
  ENCODE_U32(pPayload, Delta);
   11abc:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11abe:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   11ac2:	d906      	bls.n	11ad2 <SEGGER_SYSVIEW_GetSysDesc+0x146>
   11ac4:	f061 037f 	orn	r3, r1, #127	; 0x7f
   11ac8:	09c9      	lsrs	r1, r1, #7
   11aca:	297f      	cmp	r1, #127	; 0x7f
   11acc:	f802 3b01 	strb.w	r3, [r2], #1
   11ad0:	d8f8      	bhi.n	11ac4 <SEGGER_SYSVIEW_GetSysDesc+0x138>
   11ad2:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   11ad4:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   11ad6:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   11ada:	2001      	movs	r0, #1
   11adc:	4611      	mov	r1, r2
   11ade:	1a9a      	subs	r2, r3, r2
   11ae0:	f7fe fa4e 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   11ae4:	b950      	cbnz	r0, 11afc <SEGGER_SYSVIEW_GetSysDesc+0x170>
    _SYSVIEW_Globals.DropCount++;
   11ae6:	696a      	ldr	r2, [r5, #20]
   11ae8:	782b      	ldrb	r3, [r5, #0]
   11aea:	3201      	adds	r2, #1
   11aec:	616a      	str	r2, [r5, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   11aee:	2b01      	cmp	r3, #1
   11af0:	d184      	bne.n	119fc <SEGGER_SYSVIEW_GetSysDesc+0x70>
   11af2:	e797      	b.n	11a24 <SEGGER_SYSVIEW_GetSysDesc+0x98>
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   11af4:	782b      	ldrb	r3, [r5, #0]
   11af6:	3301      	adds	r3, #1
   11af8:	702b      	strb	r3, [r5, #0]
   11afa:	e77f      	b.n	119fc <SEGGER_SYSVIEW_GetSysDesc+0x70>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   11afc:	782b      	ldrb	r3, [r5, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   11afe:	f8c5 800c 	str.w	r8, [r5, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   11b02:	3b01      	subs	r3, #1
   11b04:	b2db      	uxtb	r3, r3
   11b06:	702b      	strb	r3, [r5, #0]
   11b08:	e7f1      	b.n	11aee <SEGGER_SYSVIEW_GetSysDesc+0x162>
   11b0a:	bf00      	nop
   11b0c:	10013240 	.word	0x10013240
   11b10:	1001326c 	.word	0x1001326c
   11b14:	1001341c 	.word	0x1001341c
   11b18:	10013268 	.word	0x10013268
   11b1c:	e0001004 	.word	0xe0001004

00011b20 <SEGGER_SYSVIEW_RecordU32>:
void SEGGER_SYSVIEW_RecordU32(unsigned int EventID, U32 Value) {
   11b20:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   11b24:	460b      	mov	r3, r1
   11b26:	b085      	sub	sp, #20
   11b28:	4607      	mov	r7, r0
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
   11b2a:	f3ef 8511 	mrs	r5, BASEPRI
   11b2e:	f04f 0120 	mov.w	r1, #32
   11b32:	f381 8811 	msr	BASEPRI, r1
  ENCODE_U32(pPayload, Value);
   11b36:	f8df 817c 	ldr.w	r8, [pc, #380]	; 11cb4 <SEGGER_SYSVIEW_RecordU32+0x194>
   11b3a:	2b7f      	cmp	r3, #127	; 0x7f
   11b3c:	4644      	mov	r4, r8
   11b3e:	d906      	bls.n	11b4e <SEGGER_SYSVIEW_RecordU32+0x2e>
   11b40:	f063 027f 	orn	r2, r3, #127	; 0x7f
   11b44:	09db      	lsrs	r3, r3, #7
   11b46:	2b7f      	cmp	r3, #127	; 0x7f
   11b48:	f804 2b01 	strb.w	r2, [r4], #1
   11b4c:	d8f8      	bhi.n	11b40 <SEGGER_SYSVIEW_RecordU32+0x20>
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   11b4e:	4e55      	ldr	r6, [pc, #340]	; (11ca4 <SEGGER_SYSVIEW_RecordU32+0x184>)
  ENCODE_U32(pPayload, Value);
   11b50:	7023      	strb	r3, [r4, #0]
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   11b52:	7833      	ldrb	r3, [r6, #0]
   11b54:	2b01      	cmp	r3, #1
   11b56:	d011      	beq.n	11b7c <SEGGER_SYSVIEW_RecordU32+0x5c>
  if (_SYSVIEW_Globals.EnableState == 0) {
   11b58:	b973      	cbnz	r3, 11b78 <SEGGER_SYSVIEW_RecordU32+0x58>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   11b5a:	4b53      	ldr	r3, [pc, #332]	; (11ca8 <SEGGER_SYSVIEW_RecordU32+0x188>)
   11b5c:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   11b60:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   11b64:	429a      	cmp	r2, r3
   11b66:	d002      	beq.n	11b6e <SEGGER_SYSVIEW_RecordU32+0x4e>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   11b68:	78b4      	ldrb	r4, [r6, #2]
   11b6a:	2c00      	cmp	r4, #0
   11b6c:	d043      	beq.n	11bf6 <SEGGER_SYSVIEW_RecordU32+0xd6>
  RECORD_END();
   11b6e:	f385 8811 	msr	BASEPRI, r5
}
   11b72:	b005      	add	sp, #20
   11b74:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   11b78:	2b02      	cmp	r3, #2
   11b7a:	d054      	beq.n	11c26 <SEGGER_SYSVIEW_RecordU32+0x106>
  if (EventId < 32) {
   11b7c:	2f1f      	cmp	r7, #31
  ENCODE_U32(pPayload, Value);
   11b7e:	f104 0401 	add.w	r4, r4, #1
  if (EventId < 32) {
   11b82:	d916      	bls.n	11bb2 <SEGGER_SYSVIEW_RecordU32+0x92>
   11b84:	b2fb      	uxtb	r3, r7
    NumBytes = pEndPacket - pStartPacket;
   11b86:	eba4 0808 	sub.w	r8, r4, r8
    if (NumBytes > 127) {
   11b8a:	f1b8 0f7f 	cmp.w	r8, #127	; 0x7f
   11b8e:	fa5f f188 	uxtb.w	r1, r8
    NumBytes = pEndPacket - pStartPacket;
   11b92:	4846      	ldr	r0, [pc, #280]	; (11cac <SEGGER_SYSVIEW_RecordU32+0x18c>)
    if (NumBytes > 127) {
   11b94:	d839      	bhi.n	11c0a <SEGGER_SYSVIEW_RecordU32+0xea>
    if (EventId > 127) {
   11b96:	2f7f      	cmp	r7, #127	; 0x7f
      *--pStartPacket = NumBytes;
   11b98:	f100 0203 	add.w	r2, r0, #3
   11b9c:	70c1      	strb	r1, [r0, #3]
    if (EventId > 127) {
   11b9e:	d93e      	bls.n	11c1e <SEGGER_SYSVIEW_RecordU32+0xfe>
      *--pStartPacket = (EventId >> 7);
   11ba0:	09ff      	lsrs	r7, r7, #7
      *--pStartPacket = EventId | 0x80;
   11ba2:	f063 037f 	orn	r3, r3, #127	; 0x7f
      *--pStartPacket = (EventId >> 7);
   11ba6:	f802 7c01 	strb.w	r7, [r2, #-1]
      *--pStartPacket = EventId | 0x80;
   11baa:	f802 3c02 	strb.w	r3, [r2, #-2]
   11bae:	3a02      	subs	r2, #2
   11bb0:	e009      	b.n	11bc6 <SEGGER_SYSVIEW_RecordU32+0xa6>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   11bb2:	69f3      	ldr	r3, [r6, #28]
   11bb4:	40fb      	lsrs	r3, r7
   11bb6:	07db      	lsls	r3, r3, #31
   11bb8:	d4cf      	bmi.n	11b5a <SEGGER_SYSVIEW_RecordU32+0x3a>
  if (EventId < 24) {
   11bba:	2f17      	cmp	r7, #23
   11bbc:	b2fb      	uxtb	r3, r7
   11bbe:	d8e2      	bhi.n	11b86 <SEGGER_SYSVIEW_RecordU32+0x66>
    *--pStartPacket = EventId;
   11bc0:	4a3a      	ldr	r2, [pc, #232]	; (11cac <SEGGER_SYSVIEW_RecordU32+0x18c>)
   11bc2:	f802 3f03 	strb.w	r3, [r2, #3]!
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11bc6:	493a      	ldr	r1, [pc, #232]	; (11cb0 <SEGGER_SYSVIEW_RecordU32+0x190>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11bc8:	68f3      	ldr	r3, [r6, #12]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11bca:	680f      	ldr	r7, [r1, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11bcc:	1afb      	subs	r3, r7, r3
  ENCODE_U32(pEndPacket, Delta);
   11bce:	2b7f      	cmp	r3, #127	; 0x7f
   11bd0:	d906      	bls.n	11be0 <SEGGER_SYSVIEW_RecordU32+0xc0>
   11bd2:	f063 017f 	orn	r1, r3, #127	; 0x7f
   11bd6:	09db      	lsrs	r3, r3, #7
   11bd8:	2b7f      	cmp	r3, #127	; 0x7f
   11bda:	f804 1b01 	strb.w	r1, [r4], #1
   11bde:	d8f8      	bhi.n	11bd2 <SEGGER_SYSVIEW_RecordU32+0xb2>
   11be0:	f804 3b01 	strb.w	r3, [r4], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   11be4:	4611      	mov	r1, r2
   11be6:	2001      	movs	r0, #1
   11be8:	1aa2      	subs	r2, r4, r2
   11bea:	f7fe f9c9 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   11bee:	2800      	cmp	r0, #0
   11bf0:	d04c      	beq.n	11c8c <SEGGER_SYSVIEW_RecordU32+0x16c>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   11bf2:	60f7      	str	r7, [r6, #12]
   11bf4:	e7b1      	b.n	11b5a <SEGGER_SYSVIEW_RecordU32+0x3a>
      _SYSVIEW_Globals.RecursionCnt = 1;
   11bf6:	2301      	movs	r3, #1
   11bf8:	70b3      	strb	r3, [r6, #2]
      _HandleIncomingPacket();
   11bfa:	f7fe fc4f 	bl	1049c <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   11bfe:	70b4      	strb	r4, [r6, #2]
  RECORD_END();
   11c00:	f385 8811 	msr	BASEPRI, r5
}
   11c04:	b005      	add	sp, #20
   11c06:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      *--pStartPacket = NumBytes | 0x80;
   11c0a:	4602      	mov	r2, r0
   11c0c:	f061 017f 	orn	r1, r1, #127	; 0x7f
   11c10:	f802 1f02 	strb.w	r1, [r2, #2]!
    if (EventId > 127) {
   11c14:	2f7f      	cmp	r7, #127	; 0x7f
      *--pStartPacket = (NumBytes >> 7);
   11c16:	f3c8 11c7 	ubfx	r1, r8, #7, #8
   11c1a:	70c1      	strb	r1, [r0, #3]
    if (EventId > 127) {
   11c1c:	d8c0      	bhi.n	11ba0 <SEGGER_SYSVIEW_RecordU32+0x80>
      *--pStartPacket = EventId;
   11c1e:	f802 3c01 	strb.w	r3, [r2, #-1]
   11c22:	3a01      	subs	r2, #1
   11c24:	e7cf      	b.n	11bc6 <SEGGER_SYSVIEW_RecordU32+0xa6>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11c26:	6972      	ldr	r2, [r6, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   11c28:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11c2a:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   11c2c:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11c30:	f10d 0305 	add.w	r3, sp, #5
   11c34:	d906      	bls.n	11c44 <SEGGER_SYSVIEW_RecordU32+0x124>
   11c36:	f062 017f 	orn	r1, r2, #127	; 0x7f
   11c3a:	09d2      	lsrs	r2, r2, #7
   11c3c:	2a7f      	cmp	r2, #127	; 0x7f
   11c3e:	f803 1b01 	strb.w	r1, [r3], #1
   11c42:	d8f8      	bhi.n	11c36 <SEGGER_SYSVIEW_RecordU32+0x116>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11c44:	491a      	ldr	r1, [pc, #104]	; (11cb0 <SEGGER_SYSVIEW_RecordU32+0x190>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11c46:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11c48:	f8d1 9000 	ldr.w	r9, [r1]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11c4c:	68f1      	ldr	r1, [r6, #12]
   11c4e:	eba9 0101 	sub.w	r1, r9, r1
  ENCODE_U32(pPayload, Delta);
   11c52:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11c54:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   11c58:	d906      	bls.n	11c68 <SEGGER_SYSVIEW_RecordU32+0x148>
   11c5a:	f061 037f 	orn	r3, r1, #127	; 0x7f
   11c5e:	09c9      	lsrs	r1, r1, #7
   11c60:	297f      	cmp	r1, #127	; 0x7f
   11c62:	f802 3b01 	strb.w	r3, [r2], #1
   11c66:	d8f8      	bhi.n	11c5a <SEGGER_SYSVIEW_RecordU32+0x13a>
   11c68:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   11c6a:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   11c6c:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   11c70:	2001      	movs	r0, #1
   11c72:	4611      	mov	r1, r2
   11c74:	1a9a      	subs	r2, r3, r2
   11c76:	f7fe f983 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   11c7a:	b958      	cbnz	r0, 11c94 <SEGGER_SYSVIEW_RecordU32+0x174>
    _SYSVIEW_Globals.DropCount++;
   11c7c:	6972      	ldr	r2, [r6, #20]
   11c7e:	7833      	ldrb	r3, [r6, #0]
   11c80:	3201      	adds	r2, #1
   11c82:	6172      	str	r2, [r6, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   11c84:	2b01      	cmp	r3, #1
   11c86:	f47f af68 	bne.w	11b5a <SEGGER_SYSVIEW_RecordU32+0x3a>
   11c8a:	e777      	b.n	11b7c <SEGGER_SYSVIEW_RecordU32+0x5c>
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   11c8c:	7833      	ldrb	r3, [r6, #0]
   11c8e:	3301      	adds	r3, #1
   11c90:	7033      	strb	r3, [r6, #0]
   11c92:	e762      	b.n	11b5a <SEGGER_SYSVIEW_RecordU32+0x3a>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   11c94:	7833      	ldrb	r3, [r6, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   11c96:	f8c6 900c 	str.w	r9, [r6, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   11c9a:	3b01      	subs	r3, #1
   11c9c:	b2db      	uxtb	r3, r3
   11c9e:	7033      	strb	r3, [r6, #0]
   11ca0:	e7f0      	b.n	11c84 <SEGGER_SYSVIEW_RecordU32+0x164>
   11ca2:	bf00      	nop
   11ca4:	10013240 	.word	0x10013240
   11ca8:	1001341c 	.word	0x1001341c
   11cac:	10013268 	.word	0x10013268
   11cb0:	e0001004 	.word	0xe0001004
   11cb4:	1001326c 	.word	0x1001326c

00011cb8 <SEGGER_SYSVIEW_RecordU32x2>:
void SEGGER_SYSVIEW_RecordU32x2(unsigned int EventID, U32 Para0, U32 Para1) {
   11cb8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   11cbc:	460b      	mov	r3, r1
   11cbe:	b085      	sub	sp, #20
   11cc0:	4606      	mov	r6, r0
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
   11cc2:	f3ef 8511 	mrs	r5, BASEPRI
   11cc6:	f04f 0120 	mov.w	r1, #32
   11cca:	f381 8811 	msr	BASEPRI, r1
  ENCODE_U32(pPayload, Para0);
   11cce:	4f68      	ldr	r7, [pc, #416]	; (11e70 <SEGGER_SYSVIEW_RecordU32x2+0x1b8>)
   11cd0:	2b7f      	cmp	r3, #127	; 0x7f
   11cd2:	4639      	mov	r1, r7
   11cd4:	d906      	bls.n	11ce4 <SEGGER_SYSVIEW_RecordU32x2+0x2c>
   11cd6:	f063 007f 	orn	r0, r3, #127	; 0x7f
   11cda:	09db      	lsrs	r3, r3, #7
   11cdc:	2b7f      	cmp	r3, #127	; 0x7f
   11cde:	f801 0b01 	strb.w	r0, [r1], #1
   11ce2:	d8f8      	bhi.n	11cd6 <SEGGER_SYSVIEW_RecordU32x2+0x1e>
  ENCODE_U32(pPayload, Para1);
   11ce4:	2a7f      	cmp	r2, #127	; 0x7f
  ENCODE_U32(pPayload, Para0);
   11ce6:	700b      	strb	r3, [r1, #0]
   11ce8:	f101 0401 	add.w	r4, r1, #1
  ENCODE_U32(pPayload, Para1);
   11cec:	d906      	bls.n	11cfc <SEGGER_SYSVIEW_RecordU32x2+0x44>
   11cee:	f062 037f 	orn	r3, r2, #127	; 0x7f
   11cf2:	09d2      	lsrs	r2, r2, #7
   11cf4:	2a7f      	cmp	r2, #127	; 0x7f
   11cf6:	f804 3b01 	strb.w	r3, [r4], #1
   11cfa:	d8f8      	bhi.n	11cee <SEGGER_SYSVIEW_RecordU32x2+0x36>
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   11cfc:	f8df 8180 	ldr.w	r8, [pc, #384]	; 11e80 <SEGGER_SYSVIEW_RecordU32x2+0x1c8>
  ENCODE_U32(pPayload, Para1);
   11d00:	7022      	strb	r2, [r4, #0]
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   11d02:	f898 3000 	ldrb.w	r3, [r8]
   11d06:	2b01      	cmp	r3, #1
   11d08:	d012      	beq.n	11d30 <SEGGER_SYSVIEW_RecordU32x2+0x78>
  if (_SYSVIEW_Globals.EnableState == 0) {
   11d0a:	b97b      	cbnz	r3, 11d2c <SEGGER_SYSVIEW_RecordU32x2+0x74>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   11d0c:	4b59      	ldr	r3, [pc, #356]	; (11e74 <SEGGER_SYSVIEW_RecordU32x2+0x1bc>)
   11d0e:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   11d12:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   11d16:	429a      	cmp	r2, r3
   11d18:	d003      	beq.n	11d22 <SEGGER_SYSVIEW_RecordU32x2+0x6a>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   11d1a:	f898 4002 	ldrb.w	r4, [r8, #2]
   11d1e:	2c00      	cmp	r4, #0
   11d20:	d044      	beq.n	11dac <SEGGER_SYSVIEW_RecordU32x2+0xf4>
  RECORD_END();
   11d22:	f385 8811 	msr	BASEPRI, r5
}
   11d26:	b005      	add	sp, #20
   11d28:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   11d2c:	2b02      	cmp	r3, #2
   11d2e:	d057      	beq.n	11de0 <SEGGER_SYSVIEW_RecordU32x2+0x128>
  if (EventId < 32) {
   11d30:	2e1f      	cmp	r6, #31
  ENCODE_U32(pPayload, Para1);
   11d32:	f104 0101 	add.w	r1, r4, #1
  if (EventId < 32) {
   11d36:	d913      	bls.n	11d60 <SEGGER_SYSVIEW_RecordU32x2+0xa8>
   11d38:	b2f3      	uxtb	r3, r6
    NumBytes = pEndPacket - pStartPacket;
   11d3a:	1bcf      	subs	r7, r1, r7
    if (NumBytes > 127) {
   11d3c:	2f7f      	cmp	r7, #127	; 0x7f
   11d3e:	b2f8      	uxtb	r0, r7
    NumBytes = pEndPacket - pStartPacket;
   11d40:	4c4d      	ldr	r4, [pc, #308]	; (11e78 <SEGGER_SYSVIEW_RecordU32x2+0x1c0>)
    if (NumBytes > 127) {
   11d42:	d83f      	bhi.n	11dc4 <SEGGER_SYSVIEW_RecordU32x2+0x10c>
    if (EventId > 127) {
   11d44:	2e7f      	cmp	r6, #127	; 0x7f
      *--pStartPacket = NumBytes;
   11d46:	f104 0203 	add.w	r2, r4, #3
   11d4a:	70e0      	strb	r0, [r4, #3]
    if (EventId > 127) {
   11d4c:	d944      	bls.n	11dd8 <SEGGER_SYSVIEW_RecordU32x2+0x120>
      *--pStartPacket = (EventId >> 7);
   11d4e:	09f6      	lsrs	r6, r6, #7
      *--pStartPacket = EventId | 0x80;
   11d50:	f063 037f 	orn	r3, r3, #127	; 0x7f
      *--pStartPacket = (EventId >> 7);
   11d54:	f802 6c01 	strb.w	r6, [r2, #-1]
      *--pStartPacket = EventId | 0x80;
   11d58:	f802 3c02 	strb.w	r3, [r2, #-2]
   11d5c:	3a02      	subs	r2, #2
   11d5e:	e00a      	b.n	11d76 <SEGGER_SYSVIEW_RecordU32x2+0xbe>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   11d60:	f8d8 301c 	ldr.w	r3, [r8, #28]
   11d64:	40f3      	lsrs	r3, r6
   11d66:	07db      	lsls	r3, r3, #31
   11d68:	d4d0      	bmi.n	11d0c <SEGGER_SYSVIEW_RecordU32x2+0x54>
  if (EventId < 24) {
   11d6a:	2e17      	cmp	r6, #23
   11d6c:	b2f3      	uxtb	r3, r6
   11d6e:	d8e4      	bhi.n	11d3a <SEGGER_SYSVIEW_RecordU32x2+0x82>
    *--pStartPacket = EventId;
   11d70:	4a41      	ldr	r2, [pc, #260]	; (11e78 <SEGGER_SYSVIEW_RecordU32x2+0x1c0>)
   11d72:	f802 3f03 	strb.w	r3, [r2, #3]!
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11d76:	4841      	ldr	r0, [pc, #260]	; (11e7c <SEGGER_SYSVIEW_RecordU32x2+0x1c4>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11d78:	f8d8 300c 	ldr.w	r3, [r8, #12]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11d7c:	6806      	ldr	r6, [r0, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11d7e:	1af3      	subs	r3, r6, r3
  ENCODE_U32(pEndPacket, Delta);
   11d80:	2b7f      	cmp	r3, #127	; 0x7f
   11d82:	d906      	bls.n	11d92 <SEGGER_SYSVIEW_RecordU32x2+0xda>
   11d84:	f063 007f 	orn	r0, r3, #127	; 0x7f
   11d88:	09db      	lsrs	r3, r3, #7
   11d8a:	2b7f      	cmp	r3, #127	; 0x7f
   11d8c:	f801 0b01 	strb.w	r0, [r1], #1
   11d90:	d8f8      	bhi.n	11d84 <SEGGER_SYSVIEW_RecordU32x2+0xcc>
   11d92:	460c      	mov	r4, r1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   11d94:	2001      	movs	r0, #1
  ENCODE_U32(pEndPacket, Delta);
   11d96:	f804 3b01 	strb.w	r3, [r4], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   11d9a:	4611      	mov	r1, r2
   11d9c:	1aa2      	subs	r2, r4, r2
   11d9e:	f7fe f8ef 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   11da2:	2800      	cmp	r0, #0
   11da4:	d054      	beq.n	11e50 <SEGGER_SYSVIEW_RecordU32x2+0x198>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   11da6:	f8c8 600c 	str.w	r6, [r8, #12]
   11daa:	e7af      	b.n	11d0c <SEGGER_SYSVIEW_RecordU32x2+0x54>
      _SYSVIEW_Globals.RecursionCnt = 1;
   11dac:	2301      	movs	r3, #1
   11dae:	f888 3002 	strb.w	r3, [r8, #2]
      _HandleIncomingPacket();
   11db2:	f7fe fb73 	bl	1049c <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   11db6:	f888 4002 	strb.w	r4, [r8, #2]
  RECORD_END();
   11dba:	f385 8811 	msr	BASEPRI, r5
}
   11dbe:	b005      	add	sp, #20
   11dc0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      *--pStartPacket = NumBytes | 0x80;
   11dc4:	4622      	mov	r2, r4
   11dc6:	f060 007f 	orn	r0, r0, #127	; 0x7f
   11dca:	f802 0f02 	strb.w	r0, [r2, #2]!
    if (EventId > 127) {
   11dce:	2e7f      	cmp	r6, #127	; 0x7f
      *--pStartPacket = (NumBytes >> 7);
   11dd0:	f3c7 10c7 	ubfx	r0, r7, #7, #8
   11dd4:	70e0      	strb	r0, [r4, #3]
    if (EventId > 127) {
   11dd6:	d8ba      	bhi.n	11d4e <SEGGER_SYSVIEW_RecordU32x2+0x96>
      *--pStartPacket = EventId;
   11dd8:	f802 3c01 	strb.w	r3, [r2, #-1]
   11ddc:	3a01      	subs	r2, #1
   11dde:	e7ca      	b.n	11d76 <SEGGER_SYSVIEW_RecordU32x2+0xbe>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11de0:	f8d8 2014 	ldr.w	r2, [r8, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   11de4:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11de6:	2a7f      	cmp	r2, #127	; 0x7f
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   11de8:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11dec:	f10d 0305 	add.w	r3, sp, #5
   11df0:	d906      	bls.n	11e00 <SEGGER_SYSVIEW_RecordU32x2+0x148>
   11df2:	f062 017f 	orn	r1, r2, #127	; 0x7f
   11df6:	09d2      	lsrs	r2, r2, #7
   11df8:	2a7f      	cmp	r2, #127	; 0x7f
   11dfa:	f803 1b01 	strb.w	r1, [r3], #1
   11dfe:	d8f8      	bhi.n	11df2 <SEGGER_SYSVIEW_RecordU32x2+0x13a>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11e00:	491e      	ldr	r1, [pc, #120]	; (11e7c <SEGGER_SYSVIEW_RecordU32x2+0x1c4>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11e02:	701a      	strb	r2, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11e04:	f8d1 9000 	ldr.w	r9, [r1]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11e08:	f8d8 100c 	ldr.w	r1, [r8, #12]
   11e0c:	eba9 0101 	sub.w	r1, r9, r1
  ENCODE_U32(pPayload, Delta);
   11e10:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   11e12:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   11e16:	d906      	bls.n	11e26 <SEGGER_SYSVIEW_RecordU32x2+0x16e>
   11e18:	f061 037f 	orn	r3, r1, #127	; 0x7f
   11e1c:	09c9      	lsrs	r1, r1, #7
   11e1e:	297f      	cmp	r1, #127	; 0x7f
   11e20:	f802 3b01 	strb.w	r3, [r2], #1
   11e24:	d8f8      	bhi.n	11e18 <SEGGER_SYSVIEW_RecordU32x2+0x160>
   11e26:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   11e28:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   11e2a:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   11e2e:	2001      	movs	r0, #1
   11e30:	4611      	mov	r1, r2
   11e32:	1a9a      	subs	r2, r3, r2
   11e34:	f7fe f8a4 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   11e38:	b980      	cbnz	r0, 11e5c <SEGGER_SYSVIEW_RecordU32x2+0x1a4>
    _SYSVIEW_Globals.DropCount++;
   11e3a:	f8d8 2014 	ldr.w	r2, [r8, #20]
   11e3e:	f898 3000 	ldrb.w	r3, [r8]
   11e42:	3201      	adds	r2, #1
   11e44:	f8c8 2014 	str.w	r2, [r8, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   11e48:	2b01      	cmp	r3, #1
   11e4a:	f47f af5f 	bne.w	11d0c <SEGGER_SYSVIEW_RecordU32x2+0x54>
   11e4e:	e76f      	b.n	11d30 <SEGGER_SYSVIEW_RecordU32x2+0x78>
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   11e50:	f898 3000 	ldrb.w	r3, [r8]
   11e54:	3301      	adds	r3, #1
   11e56:	f888 3000 	strb.w	r3, [r8]
   11e5a:	e757      	b.n	11d0c <SEGGER_SYSVIEW_RecordU32x2+0x54>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   11e5c:	f898 3000 	ldrb.w	r3, [r8]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   11e60:	f8c8 900c 	str.w	r9, [r8, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   11e64:	3b01      	subs	r3, #1
   11e66:	b2db      	uxtb	r3, r3
   11e68:	f888 3000 	strb.w	r3, [r8]
   11e6c:	e7ec      	b.n	11e48 <SEGGER_SYSVIEW_RecordU32x2+0x190>
   11e6e:	bf00      	nop
   11e70:	1001326c 	.word	0x1001326c
   11e74:	1001341c 	.word	0x1001341c
   11e78:	10013268 	.word	0x10013268
   11e7c:	e0001004 	.word	0xe0001004
   11e80:	10013240 	.word	0x10013240

00011e84 <SEGGER_SYSVIEW_Warn>:
*    Print a warning string to the host.
*
*  Parameters
*    s        - String to sent.
*/
void SEGGER_SYSVIEW_Warn(const char* s) {
   11e84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11e88:	b085      	sub	sp, #20
  U8* pPayload;
  U8* pPayloadStart;
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + SEGGER_SYSVIEW_MAX_STRING_LEN);
   11e8a:	f3ef 8611 	mrs	r6, BASEPRI
   11e8e:	f04f 0120 	mov.w	r1, #32
   11e92:	f381 8811 	msr	BASEPRI, r1
  while(*(pText + Len) != 0) {
   11e96:	7803      	ldrb	r3, [r0, #0]
   11e98:	2b00      	cmp	r3, #0
   11e9a:	f000 8103 	beq.w	120a4 <SEGGER_SYSVIEW_Warn+0x220>
   11e9e:	4602      	mov	r2, r0
  Len = 0;
   11ea0:	2300      	movs	r3, #0
  while(*(pText + Len) != 0) {
   11ea2:	f812 1f01 	ldrb.w	r1, [r2, #1]!
    Len++;
   11ea6:	3301      	adds	r3, #1
  while(*(pText + Len) != 0) {
   11ea8:	2900      	cmp	r1, #0
   11eaa:	d1fa      	bne.n	11ea2 <SEGGER_SYSVIEW_Warn+0x1e>
    *pPayload++ = Len; 
   11eac:	4d83      	ldr	r5, [pc, #524]	; (120bc <SEGGER_SYSVIEW_Warn+0x238>)
   11eae:	f100 0208 	add.w	r2, r0, #8
   11eb2:	f105 0c05 	add.w	ip, r5, #5
   11eb6:	f105 070d 	add.w	r7, r5, #13
   11eba:	4287      	cmp	r7, r0
   11ebc:	bf88      	it	hi
   11ebe:	4562      	cmphi	r2, ip
   11ec0:	bf94      	ite	ls
   11ec2:	2201      	movls	r2, #1
   11ec4:	2200      	movhi	r2, #0
   11ec6:	ea40 040c 	orr.w	r4, r0, ip
   11eca:	2b80      	cmp	r3, #128	; 0x80
   11ecc:	461f      	mov	r7, r3
   11ece:	bf28      	it	cs
   11ed0:	2780      	movcs	r7, #128	; 0x80
   11ed2:	f014 0f07 	tst.w	r4, #7
   11ed6:	bf18      	it	ne
   11ed8:	2200      	movne	r2, #0
   11eda:	712f      	strb	r7, [r5, #4]
   11edc:	2a00      	cmp	r2, #0
   11ede:	f000 80d2 	beq.w	12086 <SEGGER_SYSVIEW_Warn+0x202>
   11ee2:	2b0c      	cmp	r3, #12
   11ee4:	f240 80cf 	bls.w	12086 <SEGGER_SYSVIEW_Warn+0x202>
   11ee8:	2b00      	cmp	r3, #0
   11eea:	bf14      	ite	ne
   11eec:	46be      	movne	lr, r7
   11eee:	f04f 0e01 	moveq.w	lr, #1
   11ef2:	ea4f 0bde 	mov.w	fp, lr, lsr #3
   11ef6:	46e2      	mov	sl, ip
   11ef8:	1dab      	adds	r3, r5, #6
   11efa:	4602      	mov	r2, r0
    *pPayload++ = *pText++;
   11efc:	e8f2 8902 	ldrd	r8, r9, [r2], #8
   11f00:	3101      	adds	r1, #1
   11f02:	461c      	mov	r4, r3
   11f04:	458b      	cmp	fp, r1
   11f06:	e8ea 8902 	strd	r8, r9, [sl], #8
   11f0a:	f104 0407 	add.w	r4, r4, #7
   11f0e:	f103 0308 	add.w	r3, r3, #8
   11f12:	d8f3      	bhi.n	11efc <SEGGER_SYSVIEW_Warn+0x78>
   11f14:	f02e 0307 	bic.w	r3, lr, #7
   11f18:	4573      	cmp	r3, lr
   11f1a:	eb00 0103 	add.w	r1, r0, r3
   11f1e:	eb0c 0203 	add.w	r2, ip, r3
   11f22:	d02d      	beq.n	11f80 <SEGGER_SYSVIEW_Warn+0xfc>
   11f24:	5cc0      	ldrb	r0, [r0, r3]
   11f26:	f80c 0003 	strb.w	r0, [ip, r3]
    n++;
   11f2a:	1c58      	adds	r0, r3, #1
  while (n < Len) {
   11f2c:	42b8      	cmp	r0, r7
    *pPayload++ = *pText++;
   11f2e:	f102 0401 	add.w	r4, r2, #1
  while (n < Len) {
   11f32:	d225      	bcs.n	11f80 <SEGGER_SYSVIEW_Warn+0xfc>
    *pPayload++ = *pText++;
   11f34:	7848      	ldrb	r0, [r1, #1]
   11f36:	7050      	strb	r0, [r2, #1]
    n++;
   11f38:	1c98      	adds	r0, r3, #2
  while (n < Len) {
   11f3a:	4287      	cmp	r7, r0
    *pPayload++ = *pText++;
   11f3c:	f102 0402 	add.w	r4, r2, #2
  while (n < Len) {
   11f40:	d91e      	bls.n	11f80 <SEGGER_SYSVIEW_Warn+0xfc>
    *pPayload++ = *pText++;
   11f42:	7888      	ldrb	r0, [r1, #2]
   11f44:	7090      	strb	r0, [r2, #2]
    n++;
   11f46:	1cd8      	adds	r0, r3, #3
  while (n < Len) {
   11f48:	4287      	cmp	r7, r0
    *pPayload++ = *pText++;
   11f4a:	f102 0403 	add.w	r4, r2, #3
  while (n < Len) {
   11f4e:	d917      	bls.n	11f80 <SEGGER_SYSVIEW_Warn+0xfc>
    *pPayload++ = *pText++;
   11f50:	78c8      	ldrb	r0, [r1, #3]
   11f52:	70d0      	strb	r0, [r2, #3]
    n++;
   11f54:	1d18      	adds	r0, r3, #4
  while (n < Len) {
   11f56:	4287      	cmp	r7, r0
    *pPayload++ = *pText++;
   11f58:	f102 0404 	add.w	r4, r2, #4
  while (n < Len) {
   11f5c:	d910      	bls.n	11f80 <SEGGER_SYSVIEW_Warn+0xfc>
    *pPayload++ = *pText++;
   11f5e:	7908      	ldrb	r0, [r1, #4]
   11f60:	7110      	strb	r0, [r2, #4]
    n++;
   11f62:	1d58      	adds	r0, r3, #5
  while (n < Len) {
   11f64:	4287      	cmp	r7, r0
    *pPayload++ = *pText++;
   11f66:	f102 0405 	add.w	r4, r2, #5
  while (n < Len) {
   11f6a:	d909      	bls.n	11f80 <SEGGER_SYSVIEW_Warn+0xfc>
    n++;
   11f6c:	3306      	adds	r3, #6
    *pPayload++ = *pText++;
   11f6e:	7948      	ldrb	r0, [r1, #5]
   11f70:	7150      	strb	r0, [r2, #5]
  while (n < Len) {
   11f72:	429f      	cmp	r7, r3
    *pPayload++ = *pText++;
   11f74:	f102 0406 	add.w	r4, r2, #6
  while (n < Len) {
   11f78:	d902      	bls.n	11f80 <SEGGER_SYSVIEW_Warn+0xfc>
    *pPayload++ = *pText++;
   11f7a:	798b      	ldrb	r3, [r1, #6]
   11f7c:	7193      	strb	r3, [r2, #6]
   11f7e:	1dd4      	adds	r4, r2, #7
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   11f80:	4f4f      	ldr	r7, [pc, #316]	; (120c0 <SEGGER_SYSVIEW_Warn+0x23c>)
   11f82:	783b      	ldrb	r3, [r7, #0]
  //
  pPayload = _EncodeStr(pPayloadStart, s, SEGGER_SYSVIEW_MAX_STRING_LEN);
  ENCODE_U32(pPayload, SEGGER_SYSVIEW_WARNING);
   11f84:	2201      	movs	r2, #1
  ENCODE_U32(pPayload, 0);
   11f86:	2100      	movs	r1, #0
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   11f88:	4293      	cmp	r3, r2
  ENCODE_U32(pPayload, SEGGER_SYSVIEW_WARNING);
   11f8a:	7022      	strb	r2, [r4, #0]
  ENCODE_U32(pPayload, 0);
   11f8c:	7061      	strb	r1, [r4, #1]
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
   11f8e:	d010      	beq.n	11fb2 <SEGGER_SYSVIEW_Warn+0x12e>
  if (_SYSVIEW_Globals.EnableState == 0) {
   11f90:	b96b      	cbnz	r3, 11fae <SEGGER_SYSVIEW_Warn+0x12a>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
   11f92:	4b4c      	ldr	r3, [pc, #304]	; (120c4 <SEGGER_SYSVIEW_Warn+0x240>)
   11f94:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   11f98:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   11f9c:	429a      	cmp	r2, r3
   11f9e:	d001      	beq.n	11fa4 <SEGGER_SYSVIEW_Warn+0x120>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
   11fa0:	78bc      	ldrb	r4, [r7, #2]
   11fa2:	b374      	cbz	r4, 12002 <SEGGER_SYSVIEW_Warn+0x17e>
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
  RECORD_END();
   11fa4:	f386 8811 	msr	BASEPRI, r6
}
   11fa8:	b005      	add	sp, #20
   11faa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (_SYSVIEW_Globals.EnableState == 2) {
   11fae:	2b02      	cmp	r3, #2
   11fb0:	d038      	beq.n	12024 <SEGGER_SYSVIEW_Warn+0x1a0>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
   11fb2:	69fb      	ldr	r3, [r7, #28]
   11fb4:	015b      	lsls	r3, r3, #5
   11fb6:	d4ec      	bmi.n	11f92 <SEGGER_SYSVIEW_Warn+0x10e>
    NumBytes = pEndPacket - pStartPacket;
   11fb8:	4943      	ldr	r1, [pc, #268]	; (120c8 <SEGGER_SYSVIEW_Warn+0x244>)
  ENCODE_U32(pPayload, 0);
   11fba:	1ca2      	adds	r2, r4, #2
    NumBytes = pEndPacket - pStartPacket;
   11fbc:	1a50      	subs	r0, r2, r1
    if (NumBytes > 127) {
   11fbe:	287f      	cmp	r0, #127	; 0x7f
   11fc0:	b2c3      	uxtb	r3, r0
   11fc2:	d828      	bhi.n	12016 <SEGGER_SYSVIEW_Warn+0x192>
      *--pStartPacket = NumBytes;
   11fc4:	3901      	subs	r1, #1
   11fc6:	70eb      	strb	r3, [r5, #3]
      *--pStartPacket = EventId;
   11fc8:	201a      	movs	r0, #26
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11fca:	4b40      	ldr	r3, [pc, #256]	; (120cc <SEGGER_SYSVIEW_Warn+0x248>)
      *--pStartPacket = EventId;
   11fcc:	f801 0c01 	strb.w	r0, [r1, #-1]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   11fd0:	681c      	ldr	r4, [r3, #0]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   11fd2:	68fb      	ldr	r3, [r7, #12]
   11fd4:	1ae3      	subs	r3, r4, r3
  ENCODE_U32(pEndPacket, Delta);
   11fd6:	2b7f      	cmp	r3, #127	; 0x7f
      *--pStartPacket = EventId;
   11fd8:	f101 30ff 	add.w	r0, r1, #4294967295	; 0xffffffff
  ENCODE_U32(pEndPacket, Delta);
   11fdc:	d906      	bls.n	11fec <SEGGER_SYSVIEW_Warn+0x168>
   11fde:	f063 017f 	orn	r1, r3, #127	; 0x7f
   11fe2:	09db      	lsrs	r3, r3, #7
   11fe4:	2b7f      	cmp	r3, #127	; 0x7f
   11fe6:	f802 1b01 	strb.w	r1, [r2], #1
   11fea:	d8f8      	bhi.n	11fde <SEGGER_SYSVIEW_Warn+0x15a>
   11fec:	f802 3b01 	strb.w	r3, [r2], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
   11ff0:	4601      	mov	r1, r0
   11ff2:	1a12      	subs	r2, r2, r0
   11ff4:	2001      	movs	r0, #1
   11ff6:	f7fd ffc3 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   11ffa:	2800      	cmp	r0, #0
   11ffc:	d04e      	beq.n	1209c <SEGGER_SYSVIEW_Warn+0x218>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   11ffe:	60fc      	str	r4, [r7, #12]
   12000:	e7c7      	b.n	11f92 <SEGGER_SYSVIEW_Warn+0x10e>
      _SYSVIEW_Globals.RecursionCnt = 1;
   12002:	2301      	movs	r3, #1
   12004:	70bb      	strb	r3, [r7, #2]
      _HandleIncomingPacket();
   12006:	f7fe fa49 	bl	1049c <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
   1200a:	70bc      	strb	r4, [r7, #2]
  RECORD_END();
   1200c:	f386 8811 	msr	BASEPRI, r6
}
   12010:	b005      	add	sp, #20
   12012:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      *--pStartPacket = NumBytes | 0x80;
   12016:	f063 037f 	orn	r3, r3, #127	; 0x7f
   1201a:	70ab      	strb	r3, [r5, #2]
   1201c:	3902      	subs	r1, #2
      *--pStartPacket = (NumBytes >> 7);
   1201e:	f3c0 13c7 	ubfx	r3, r0, #7, #8
   12022:	e7d0      	b.n	11fc6 <SEGGER_SYSVIEW_Warn+0x142>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   12024:	6979      	ldr	r1, [r7, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
   12026:	f88d 2004 	strb.w	r2, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   1202a:	297f      	cmp	r1, #127	; 0x7f
   1202c:	f10d 0305 	add.w	r3, sp, #5
   12030:	d906      	bls.n	12040 <SEGGER_SYSVIEW_Warn+0x1bc>
   12032:	f061 027f 	orn	r2, r1, #127	; 0x7f
   12036:	09c9      	lsrs	r1, r1, #7
   12038:	297f      	cmp	r1, #127	; 0x7f
   1203a:	f803 2b01 	strb.w	r2, [r3], #1
   1203e:	d8f8      	bhi.n	12032 <SEGGER_SYSVIEW_Warn+0x1ae>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   12040:	4a22      	ldr	r2, [pc, #136]	; (120cc <SEGGER_SYSVIEW_Warn+0x248>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   12042:	7019      	strb	r1, [r3, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
   12044:	f8d2 8000 	ldr.w	r8, [r2]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
   12048:	68f9      	ldr	r1, [r7, #12]
   1204a:	eba8 0101 	sub.w	r1, r8, r1
  ENCODE_U32(pPayload, Delta);
   1204e:	297f      	cmp	r1, #127	; 0x7f
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
   12050:	f103 0201 	add.w	r2, r3, #1
  ENCODE_U32(pPayload, Delta);
   12054:	d906      	bls.n	12064 <SEGGER_SYSVIEW_Warn+0x1e0>
   12056:	f061 037f 	orn	r3, r1, #127	; 0x7f
   1205a:	09c9      	lsrs	r1, r1, #7
   1205c:	297f      	cmp	r1, #127	; 0x7f
   1205e:	f802 3b01 	strb.w	r3, [r2], #1
   12062:	d8f8      	bhi.n	12056 <SEGGER_SYSVIEW_Warn+0x1d2>
   12064:	4613      	mov	r3, r2
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   12066:	aa01      	add	r2, sp, #4
  ENCODE_U32(pPayload, Delta);
   12068:	f803 1b01 	strb.w	r1, [r3], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
   1206c:	2001      	movs	r0, #1
   1206e:	4611      	mov	r1, r2
   12070:	1a9a      	subs	r2, r3, r2
   12072:	f7fd ff85 	bl	ff80 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
   12076:	b9c8      	cbnz	r0, 120ac <SEGGER_SYSVIEW_Warn+0x228>
    _SYSVIEW_Globals.DropCount++;
   12078:	697a      	ldr	r2, [r7, #20]
   1207a:	783b      	ldrb	r3, [r7, #0]
   1207c:	3201      	adds	r2, #1
   1207e:	617a      	str	r2, [r7, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
   12080:	2b01      	cmp	r3, #1
   12082:	d186      	bne.n	11f92 <SEGGER_SYSVIEW_Warn+0x10e>
   12084:	e795      	b.n	11fb2 <SEGGER_SYSVIEW_Warn+0x12e>
    *pPayload++ = Len; 
   12086:	4c12      	ldr	r4, [pc, #72]	; (120d0 <SEGGER_SYSVIEW_Warn+0x24c>)
   12088:	3801      	subs	r0, #1
   1208a:	2300      	movs	r3, #0
    n++;
   1208c:	3301      	adds	r3, #1
    *pPayload++ = *pText++;
   1208e:	f810 2f01 	ldrb.w	r2, [r0, #1]!
   12092:	f804 2b01 	strb.w	r2, [r4], #1
  while (n < Len) {
   12096:	429f      	cmp	r7, r3
   12098:	d8f8      	bhi.n	1208c <SEGGER_SYSVIEW_Warn+0x208>
   1209a:	e771      	b.n	11f80 <SEGGER_SYSVIEW_Warn+0xfc>
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
   1209c:	783b      	ldrb	r3, [r7, #0]
   1209e:	3301      	adds	r3, #1
   120a0:	703b      	strb	r3, [r7, #0]
   120a2:	e776      	b.n	11f92 <SEGGER_SYSVIEW_Warn+0x10e>
    *pPayload++ = Len; 
   120a4:	4d05      	ldr	r5, [pc, #20]	; (120bc <SEGGER_SYSVIEW_Warn+0x238>)
   120a6:	712b      	strb	r3, [r5, #4]
   120a8:	1d6c      	adds	r4, r5, #5
   120aa:	e769      	b.n	11f80 <SEGGER_SYSVIEW_Warn+0xfc>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   120ac:	783b      	ldrb	r3, [r7, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
   120ae:	f8c7 800c 	str.w	r8, [r7, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
   120b2:	3b01      	subs	r3, #1
   120b4:	b2db      	uxtb	r3, r3
   120b6:	703b      	strb	r3, [r7, #0]
   120b8:	e7e2      	b.n	12080 <SEGGER_SYSVIEW_Warn+0x1fc>
   120ba:	bf00      	nop
   120bc:	10013268 	.word	0x10013268
   120c0:	10013240 	.word	0x10013240
   120c4:	1001341c 	.word	0x1001341c
   120c8:	1001326c 	.word	0x1001326c
   120cc:	e0001004 	.word	0xe0001004
   120d0:	1001326d 	.word	0x1001326d

000120d4 <SYSVIEW_AddTask>:
*       SYSVIEW_AddTask()
*
*  Function description
*    Add a task to the internal list and record its information.
*/
void SYSVIEW_AddTask(U32 xHandle, const char* pcTaskName, unsigned uxCurrentPriority, U32  pxStack, unsigned uStackHighWaterMark) {
   120d4:	b5f0      	push	{r4, r5, r6, r7, lr}
   120d6:	460c      	mov	r4, r1
   120d8:	b087      	sub	sp, #28
   120da:	4607      	mov	r7, r0
   120dc:	4616      	mov	r6, r2
  
  if (memcmp(pcTaskName, "IDLE", 5) == 0) {
   120de:	4608      	mov	r0, r1
   120e0:	2205      	movs	r2, #5
   120e2:	4914      	ldr	r1, [pc, #80]	; (12134 <SYSVIEW_AddTask+0x60>)
void SYSVIEW_AddTask(U32 xHandle, const char* pcTaskName, unsigned uxCurrentPriority, U32  pxStack, unsigned uStackHighWaterMark) {
   120e4:	461d      	mov	r5, r3
  if (memcmp(pcTaskName, "IDLE", 5) == 0) {
   120e6:	f001 faf7 	bl	136d8 <memcmp>
   120ea:	b1e0      	cbz	r0, 12126 <SYSVIEW_AddTask+0x52>
    return;
  }
  
  if (_NumTasks >= SYSVIEW_FREERTOS_MAX_NOF_TASKS) {
   120ec:	4912      	ldr	r1, [pc, #72]	; (12138 <SYSVIEW_AddTask+0x64>)
   120ee:	680b      	ldr	r3, [r1, #0]
   120f0:	2b07      	cmp	r3, #7
   120f2:	d81a      	bhi.n	1212a <SYSVIEW_AddTask+0x56>
    SEGGER_SYSVIEW_Warn("SYSTEMVIEW: Could not record task information. Maximum number of tasks reached.");
    return;
  }

  _aTasks[_NumTasks].xHandle = xHandle;
   120f4:	eb03 0283 	add.w	r2, r3, r3, lsl #2
   120f8:	f8df c044 	ldr.w	ip, [pc, #68]	; 12140 <SYSVIEW_AddTask+0x6c>
  memset(&TaskInfo, 0, sizeof(TaskInfo)); // Fill all elements with 0 to allow extending the structure in future version without breaking the code
  TaskInfo.TaskID     = TaskID;
  TaskInfo.sName      = sName;
  TaskInfo.Prio       = Prio;
  TaskInfo.StackBase  = StackBase;
  TaskInfo.StackSize  = StackSize;
   120fc:	980c      	ldr	r0, [sp, #48]	; 0x30
   120fe:	9005      	str	r0, [sp, #20]
  _aTasks[_NumTasks].xHandle = xHandle;
   12100:	0092      	lsls	r2, r2, #2
  _NumTasks++;
   12102:	3301      	adds	r3, #1
   12104:	600b      	str	r3, [r1, #0]
  _aTasks[_NumTasks].xHandle = xHandle;
   12106:	eb0c 0302 	add.w	r3, ip, r2
   1210a:	f84c 7002 	str.w	r7, [ip, r2]
  _aTasks[_NumTasks].uStackHighWaterMark = uStackHighWaterMark;
   1210e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
  _aTasks[_NumTasks].pxStack = pxStack;
   12110:	60dd      	str	r5, [r3, #12]
  SEGGER_SYSVIEW_SendTaskInfo(&TaskInfo);
   12112:	a801      	add	r0, sp, #4
  _aTasks[_NumTasks].uxCurrentPriority = uxCurrentPriority;
   12114:	e9c3 4601 	strd	r4, r6, [r3, #4]
  _aTasks[_NumTasks].uStackHighWaterMark = uStackHighWaterMark;
   12118:	611a      	str	r2, [r3, #16]
  TaskInfo.TaskID     = TaskID;
   1211a:	9701      	str	r7, [sp, #4]
  TaskInfo.Prio       = Prio;
   1211c:	e9cd 4602 	strd	r4, r6, [sp, #8]
  TaskInfo.StackBase  = StackBase;
   12120:	9504      	str	r5, [sp, #16]
  SEGGER_SYSVIEW_SendTaskInfo(&TaskInfo);
   12122:	f7fe faf7 	bl	10714 <SEGGER_SYSVIEW_SendTaskInfo>
}
   12126:	b007      	add	sp, #28
   12128:	bdf0      	pop	{r4, r5, r6, r7, pc}
    SEGGER_SYSVIEW_Warn("SYSTEMVIEW: Could not record task information. Maximum number of tasks reached.");
   1212a:	4804      	ldr	r0, [pc, #16]	; (1213c <SYSVIEW_AddTask+0x68>)
   1212c:	f7ff feaa 	bl	11e84 <SEGGER_SYSVIEW_Warn>
}
   12130:	b007      	add	sp, #28
   12132:	bdf0      	pop	{r4, r5, r6, r7, pc}
   12134:	000137f0 	.word	0x000137f0
   12138:	10013350 	.word	0x10013350
   1213c:	000139a0 	.word	0x000139a0
   12140:	10013354 	.word	0x10013354

00012144 <SYSVIEW_RecordU32x4>:
*       SYSVIEW_RecordU32x4()
*
*  Function description
*    Record an event with 4 parameters
*/
void SYSVIEW_RecordU32x4(unsigned Id, U32 Para0, U32 Para1, U32 Para2, U32 Para3) {
   12144:	b570      	push	{r4, r5, r6, lr}
   12146:	b088      	sub	sp, #32
   12148:	4616      	mov	r6, r2
   1214a:	4604      	mov	r4, r0
      U8  aPacket[SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32];
      U8* pPayload;
      //
      pPayload = SEGGER_SYSVIEW_PREPARE_PACKET(aPacket);                // Prepare the packet for SystemView
      pPayload = SEGGER_SYSVIEW_EncodeU32(pPayload, Para0);             // Add the first parameter to the packet
   1214c:	a801      	add	r0, sp, #4
void SYSVIEW_RecordU32x4(unsigned Id, U32 Para0, U32 Para1, U32 Para2, U32 Para3) {
   1214e:	461d      	mov	r5, r3
      pPayload = SEGGER_SYSVIEW_EncodeU32(pPayload, Para0);             // Add the first parameter to the packet
   12150:	f7fe f8c0 	bl	102d4 <SEGGER_SYSVIEW_EncodeU32>
      pPayload = SEGGER_SYSVIEW_EncodeU32(pPayload, Para1);             // Add the second parameter to the packet
   12154:	4631      	mov	r1, r6
   12156:	f7fe f8bd 	bl	102d4 <SEGGER_SYSVIEW_EncodeU32>
      pPayload = SEGGER_SYSVIEW_EncodeU32(pPayload, Para2);             // Add the third parameter to the packet
   1215a:	4629      	mov	r1, r5
   1215c:	f7fe f8ba 	bl	102d4 <SEGGER_SYSVIEW_EncodeU32>
      pPayload = SEGGER_SYSVIEW_EncodeU32(pPayload, Para3);             // Add the fourth parameter to the packet
   12160:	990c      	ldr	r1, [sp, #48]	; 0x30
   12162:	f7fe f8b7 	bl	102d4 <SEGGER_SYSVIEW_EncodeU32>
      //
      SEGGER_SYSVIEW_SendPacket(&aPacket[0], pPayload, Id);             // Send the packet
   12166:	4622      	mov	r2, r4
   12168:	4601      	mov	r1, r0
   1216a:	4668      	mov	r0, sp
   1216c:	f7ff f872 	bl	11254 <SEGGER_SYSVIEW_SendPacket>
}
   12170:	b008      	add	sp, #32
   12172:	bd70      	pop	{r4, r5, r6, pc}

00012174 <am_freertos_sleep>:
// Return 0 if this function also incorporates the WFI, else return value same
// as idleTime
//
//*****************************************************************************
uint32_t am_freertos_sleep(uint32_t idleTime)
{
   12174:	b508      	push	{r3, lr}
//    {
//       configure_uart_sleep(1);
//    }
//#endif
//    am_hal_sysctrl_sleep(AM_HAL_SYSCTRL_SLEEP_NORMAL);
    am_hal_sysctrl_sleep(AM_HAL_SYSCTRL_SLEEP_DEEP);
   12176:	2001      	movs	r0, #1
   12178:	f000 fe26 	bl	12dc8 <am_hal_sysctrl_sleep>
    return 0;
}
   1217c:	2000      	movs	r0, #0
   1217e:	bd08      	pop	{r3, pc}

00012180 <am_freertos_wakeup>:
//
//*****************************************************************************
void am_freertos_wakeup(uint32_t idleTime)
{
    return;
}
   12180:	4770      	bx	lr
   12182:	bf00      	nop

00012184 <vApplicationMallocFailedHook>:
// FreeRTOS debugging functions.
//
//*****************************************************************************
void
vApplicationMallocFailedHook(void)
{
   12184:	e7fe      	b.n	12184 <vApplicationMallocFailedHook>
   12186:	bf00      	nop

00012188 <vApplicationStackOverflowHook>:
    // configconfigCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
    // function is called if a stack overflow is detected.
    //
    while (1)
    {
        __asm("BKPT #0\n") ; // Break into the debugger
   12188:	be00      	bkpt	0x0000
   1218a:	e7fd      	b.n	12188 <vApplicationStackOverflowHook>

0001218c <am_AEP_init>:
uint8_t g_rttRecorderBuff[RTT_BUFFER_LENGTH];
volatile uint8_t g_ui8RttRecordFlag = 0; 
#endif // configUSE_RTT_LOGGER

void am_AEP_init(void)
{
   1218c:	b530      	push	{r4, r5, lr}
   1218e:	b083      	sub	sp, #12
    uint32_t buffCount = 0;
    uint32_t taskCount = 0;
    uint32_t taskSetupCount = 0;
    uint32_t timerSetupCount = 0;
    
    am_AEP_board_setup();
   12190:	f000 f88e 	bl	122b0 <am_AEP_board_setup>
    taskCount = getListCount(am_AEP_tasks);
    taskSetupCount = getListCount(g_AEP_TaskSetup);
    timerSetupCount = getListCount(g_AEP_TimerSetup);


    am_app_utils_task_init(am_AEP_tasks, taskCount);
   12194:	4d12      	ldr	r5, [pc, #72]	; (121e0 <am_AEP_init+0x54>)
    am_app_utils_rtt_init(g_rttRecorderBuff, RTT_BUFFER_LENGTH);
   12196:	4813      	ldr	r0, [pc, #76]	; (121e4 <am_AEP_init+0x58>)
    am_app_utils_task_create_all_tasks(g_AEP_TaskSetup, am_AEP_tasks, taskSetupCount);
    am_app_utils_timer_create_all_timers(g_AEP_TimerSetup, am_AEP_timers, timerSetupCount);
   12198:	4c13      	ldr	r4, [pc, #76]	; (121e8 <am_AEP_init+0x5c>)
    am_app_utils_rtt_init(g_rttRecorderBuff, RTT_BUFFER_LENGTH);
   1219a:	f44f 3100 	mov.w	r1, #131072	; 0x20000
   1219e:	f7fd fd03 	bl	fba8 <am_app_utils_rtt_init>
    am_app_utils_ring_buffer_init_all(am_AEP_ring_buffers, g_AEP_RingBuffSetup, buffCount);
   121a2:	2202      	movs	r2, #2
   121a4:	4911      	ldr	r1, [pc, #68]	; (121ec <am_AEP_init+0x60>)
   121a6:	4812      	ldr	r0, [pc, #72]	; (121f0 <am_AEP_init+0x64>)
   121a8:	f7fd fc06 	bl	f9b8 <am_app_utils_ring_buffer_init_all>
    am_app_utils_task_init(am_AEP_tasks, taskCount);
   121ac:	4628      	mov	r0, r5
   121ae:	2106      	movs	r1, #6
   121b0:	f7fd fd0e 	bl	fbd0 <am_app_utils_task_init>
    am_app_utils_task_create_all_tasks(g_AEP_TaskSetup, am_AEP_tasks, taskSetupCount);
   121b4:	4629      	mov	r1, r5
   121b6:	2203      	movs	r2, #3
   121b8:	480e      	ldr	r0, [pc, #56]	; (121f4 <am_AEP_init+0x68>)
   121ba:	f7fd fd13 	bl	fbe4 <am_app_utils_task_create_all_tasks>
    am_app_utils_timer_create_all_timers(g_AEP_TimerSetup, am_AEP_timers, timerSetupCount);
   121be:	4621      	mov	r1, r4
   121c0:	2201      	movs	r2, #1
   121c2:	480d      	ldr	r0, [pc, #52]	; (121f8 <am_AEP_init+0x6c>)
   121c4:	f7fd fd42 	bl	fc4c <am_app_utils_timer_create_all_timers>

    // Enable system heart beat LED
    xTimerStart(am_AEP_timers[AM_AEP_TIMER_HEART_BEAT], 0);    
   121c8:	6864      	ldr	r4, [r4, #4]
   121ca:	f7fa fff9 	bl	d1c0 <xTaskGetTickCount>
   121ce:	2300      	movs	r3, #0
   121d0:	4602      	mov	r2, r0
   121d2:	9300      	str	r3, [sp, #0]
   121d4:	4620      	mov	r0, r4
   121d6:	2101      	movs	r1, #1
   121d8:	f7fb fd8a 	bl	dcf0 <xTimerGenericCommand>

}
   121dc:	b003      	add	sp, #12
   121de:	bd30      	pop	{r4, r5, pc}
   121e0:	10033a00 	.word	0x10033a00
   121e4:	100139c4 	.word	0x100139c4
   121e8:	10033a94 	.word	0x10033a94
   121ec:	10002b04 	.word	0x10002b04
   121f0:	100339c4 	.word	0x100339c4
   121f4:	10002b1c 	.word	0x10002b1c
   121f8:	10002b70 	.word	0x10002b70

000121fc <am_AEP_pdm_init>:
    //
    am_hal_pdm_dma_start(PDMHandle, &sTransfer);
}

void am_AEP_pdm_init(void) 
{
   121fc:	b530      	push	{r4, r5, lr}
  am_hal_gpio_pincfg_t sPinCfg = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

  // ARPIT 181019
  // sPinCfg.uFuncSel = AM_HAL_PIN_10_PDMCLK;
  // am_hal_gpio_pinconfig(10, sPinCfg);
  sPinCfg.uFuncSel = AM_HAL_PIN_12_PDMCLK;
   121fe:	2505      	movs	r5, #5
  am_hal_gpio_pincfg_t sPinCfg = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
   12200:	2400      	movs	r4, #0
  sPinCfg.uFuncSel = AM_HAL_PIN_12_PDMCLK;
   12202:	f365 0402 	bfi	r4, r5, #0, #3
{
   12206:	b08b      	sub	sp, #44	; 0x2c
  am_hal_gpio_pinconfig(12, sPinCfg);
   12208:	4621      	mov	r1, r4
   1220a:	200c      	movs	r0, #12
   1220c:	f7fc fa38 	bl	e680 <am_hal_gpio_pinconfig>

  sPinCfg.uFuncSel = AM_HAL_PIN_11_PDMDATA;
  am_hal_gpio_pinconfig(11, sPinCfg);
   12210:	f044 0107 	orr.w	r1, r4, #7
   12214:	200b      	movs	r0, #11
    };
    
//
  // Initialize, power-up, and configure the PDM.
  //
    am_hal_pdm_initialize(0, &PDMHandle);
   12216:	4c23      	ldr	r4, [pc, #140]	; (122a4 <am_AEP_pdm_init+0xa8>)
  am_hal_gpio_pinconfig(11, sPinCfg);
   12218:	f7fc fa32 	bl	e680 <am_hal_gpio_pinconfig>
    am_hal_pdm_config_t g_sPdmConfig = {
   1221c:	a802      	add	r0, sp, #8
   1221e:	2220      	movs	r2, #32
   12220:	2100      	movs	r1, #0
   12222:	f001 fa8b 	bl	1373c <memset>
   12226:	230b      	movs	r3, #11
   12228:	2018      	movs	r0, #24
   1222a:	2201      	movs	r2, #1
    am_hal_pdm_initialize(0, &PDMHandle);
   1222c:	4621      	mov	r1, r4
    am_hal_pdm_config_t g_sPdmConfig = {
   1222e:	f88d 3009 	strb.w	r3, [sp, #9]
   12232:	f88d 300a 	strb.w	r3, [sp, #10]
   12236:	9305      	str	r3, [sp, #20]
   12238:	9003      	str	r0, [sp, #12]
   1223a:	2303      	movs	r3, #3
    am_hal_pdm_initialize(0, &PDMHandle);
   1223c:	2000      	movs	r0, #0
    am_hal_pdm_config_t g_sPdmConfig = {
   1223e:	f88d 301d 	strb.w	r3, [sp, #29]
   12242:	f88d 2010 	strb.w	r2, [sp, #16]
   12246:	f88d 201c 	strb.w	r2, [sp, #28]
   1224a:	f88d 5018 	strb.w	r5, [sp, #24]
    am_hal_pdm_initialize(0, &PDMHandle);
   1224e:	f7fc f879 	bl	e344 <am_hal_pdm_initialize>
    am_hal_pdm_power_control(PDMHandle, AM_HAL_PDM_POWER_ON, false);
   12252:	2200      	movs	r2, #0
   12254:	4611      	mov	r1, r2
   12256:	6820      	ldr	r0, [r4, #0]
   12258:	f7fc f896 	bl	e388 <am_hal_pdm_power_control>
    am_hal_pdm_configure(PDMHandle, &g_sPdmConfig);
   1225c:	a902      	add	r1, sp, #8
   1225e:	6820      	ldr	r0, [r4, #0]
   12260:	f7fc f8d2 	bl	e408 <am_hal_pdm_configure>
    am_hal_pdm_fifo_flush(PDMHandle);
   12264:	6820      	ldr	r0, [r4, #0]
   12266:	f7fc f9b7 	bl	e5d8 <am_hal_pdm_fifo_flush>


    am_hal_pdm_enable(PDMHandle);
   1226a:	6820      	ldr	r0, [r4, #0]
   1226c:	f7fc f952 	bl	e514 <am_hal_pdm_enable>

    //
    // Configure and enable PDM interrupts (set up to trigger on DMA
    // completion).
    //
    am_hal_pdm_interrupt_enable(PDMHandle,
   12270:	6820      	ldr	r0, [r4, #0]
   12272:	211e      	movs	r1, #30
   12274:	f7fc f9c2 	bl	e5fc <am_hal_pdm_interrupt_enable>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   12278:	4b0b      	ldr	r3, [pc, #44]	; (122a8 <am_AEP_pdm_init+0xac>)
   1227a:	2180      	movs	r1, #128	; 0x80
   1227c:	f883 1313 	strb.w	r1, [r3, #787]	; 0x313
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   12280:	f44f 2200 	mov.w	r2, #524288	; 0x80000
   12284:	601a      	str	r2, [r3, #0]


    //
    // Enable PDM
    //
    am_hal_pdm_enable(PDMHandle);
   12286:	6820      	ldr	r0, [r4, #0]
   12288:	f7fc f944 	bl	e514 <am_hal_pdm_enable>
    sTransfer.ui32TargetAddr = (uint32_t ) g_ui32PCMDataBuff;
   1228c:	4b07      	ldr	r3, [pc, #28]	; (122ac <am_AEP_pdm_init+0xb0>)
   1228e:	9300      	str	r3, [sp, #0]
    am_hal_pdm_dma_start(PDMHandle, &sTransfer);
   12290:	6820      	ldr	r0, [r4, #0]
    sTransfer.ui32TotalCount = (PCM_FRAME_SIZE * PCM_DATA_BYTES);
   12292:	f44f 73a0 	mov.w	r3, #320	; 0x140
    am_hal_pdm_dma_start(PDMHandle, &sTransfer);
   12296:	4669      	mov	r1, sp
    sTransfer.ui32TotalCount = (PCM_FRAME_SIZE * PCM_DATA_BYTES);
   12298:	9301      	str	r3, [sp, #4]
    am_hal_pdm_dma_start(PDMHandle, &sTransfer);
   1229a:	f7fc f953 	bl	e544 <am_hal_pdm_dma_start>
    pdm_trigger_dma();

}
   1229e:	b00b      	add	sp, #44	; 0x2c
   122a0:	bd30      	pop	{r4, r5, pc}
   122a2:	bf00      	nop
   122a4:	10033be4 	.word	0x10033be4
   122a8:	e000e100 	.word	0xe000e100
   122ac:	10033aa0 	.word	0x10033aa0

000122b0 <am_AEP_board_setup>:
void am_AEP_board_setup(void)
{
    //
    // Set the clock frequency.
    //
    am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_SYSCLK_MAX, 0);
   122b0:	2100      	movs	r1, #0
{
   122b2:	b538      	push	{r3, r4, r5, lr}
    am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_SYSCLK_MAX, 0);
   122b4:	4608      	mov	r0, r1
   122b6:	f000 fa9f 	bl	127f8 <am_hal_clkgen_control>
    
    //
    // Set the default cache configuration
    //
    am_hal_cachectrl_config(&am_hal_cachectrl_defaults);
   122ba:	481f      	ldr	r0, [pc, #124]	; (12338 <am_AEP_board_setup+0x88>)
    //
    // Turn the LEDs off
    //
    for (int ix = 0; ix < AM_BSP_NUM_LEDS; ix++) 
    {
        am_devices_led_off(am_bsp_psLEDs, ix);
   122bc:	4d1f      	ldr	r5, [pc, #124]	; (1233c <am_AEP_board_setup+0x8c>)
    am_hal_cachectrl_config(&am_hal_cachectrl_defaults);
   122be:	f000 fa67 	bl	12790 <am_hal_cachectrl_config>
    am_hal_cachectrl_enable();
   122c2:	f000 fa8f 	bl	127e4 <am_hal_cachectrl_enable>
    am_bsp_low_power_init();
   122c6:	f000 f98d 	bl	125e4 <am_bsp_low_power_init>
    am_hal_gpio_pinconfig(AM_BSP_GPIO_BUTTON0, g_AP3EVB_button0);
   122ca:	4b1d      	ldr	r3, [pc, #116]	; (12340 <am_AEP_board_setup+0x90>)
   122cc:	2010      	movs	r0, #16
   122ce:	6819      	ldr	r1, [r3, #0]
   122d0:	f7fc f9d6 	bl	e680 <am_hal_gpio_pinconfig>
    am_hal_gpio_interrupt_clear(AM_HAL_GPIO_BIT(AM_BSP_GPIO_BUTTON0));
   122d4:	2100      	movs	r1, #0
   122d6:	f44f 3080 	mov.w	r0, #65536	; 0x10000
   122da:	f7fc fbb9 	bl	ea50 <am_hal_gpio_interrupt_clear>
    am_devices_led_array_init(am_bsp_psLEDs, AM_BSP_NUM_LEDS);
   122de:	2105      	movs	r1, #5
   122e0:	4628      	mov	r0, r5
   122e2:	f7fd fd43 	bl	fd6c <am_devices_led_array_init>
    for (int ix = 0; ix < AM_BSP_NUM_LEDS; ix++) 
   122e6:	2400      	movs	r4, #0
        am_devices_led_off(am_bsp_psLEDs, ix);
   122e8:	4621      	mov	r1, r4
   122ea:	4628      	mov	r0, r5
    for (int ix = 0; ix < AM_BSP_NUM_LEDS; ix++) 
   122ec:	3401      	adds	r4, #1
        am_devices_led_off(am_bsp_psLEDs, ix);
   122ee:	f7fd fd87 	bl	fe00 <am_devices_led_off>
    for (int ix = 0; ix < AM_BSP_NUM_LEDS; ix++) 
   122f2:	2c05      	cmp	r4, #5
   122f4:	d1f8      	bne.n	122e8 <am_AEP_board_setup+0x38>
    am_bsp_uart_printf_enable();

    //
    // Configure of burst mode
    //
    if (AM_HAL_STATUS_SUCCESS == am_hal_burst_mode_initialize(&eBurstModeAvailable))
   122f6:	4c13      	ldr	r4, [pc, #76]	; (12344 <am_AEP_board_setup+0x94>)
    am_AEP_pdm_init();
   122f8:	f7ff ff80 	bl	121fc <am_AEP_pdm_init>
    am_bsp_uart_printf_enable();
   122fc:	f000 f9a4 	bl	12648 <am_bsp_uart_printf_enable>
    if (AM_HAL_STATUS_SUCCESS == am_hal_burst_mode_initialize(&eBurstModeAvailable))
   12300:	4620      	mov	r0, r4
   12302:	f000 f9cf 	bl	126a4 <am_hal_burst_mode_initialize>
   12306:	b998      	cbnz	r0, 12330 <am_AEP_board_setup+0x80>
    {
        if (AM_HAL_BURST_AVAIL == eBurstModeAvailable)
   12308:	7823      	ldrb	r3, [r4, #0]
   1230a:	b16b      	cbz	r3, 12328 <am_AEP_board_setup+0x78>
        {
            am_util_stdio_printf("Apollo3 Burst Mode is Available\r\n");
        }
        else
        {
            am_util_stdio_printf("Apollo3 Burst Mode is Not Available\r\n");
   1230c:	480e      	ldr	r0, [pc, #56]	; (12348 <am_AEP_board_setup+0x98>)
   1230e:	f7fd fb37 	bl	f980 <am_util_stdio_printf>
        am_util_stdio_printf("Failed to Initialize for Burst Mode operation\r\n");
    }

#if configUSE_BURST_ALWAYS_ON
    // Put the MCU into "Burst" mode.
    if (AM_HAL_STATUS_SUCCESS == am_hal_burst_mode_enable(&eBurstMode))
   12312:	480e      	ldr	r0, [pc, #56]	; (1234c <am_AEP_board_setup+0x9c>)
   12314:	f000 fa0e 	bl	12734 <am_hal_burst_mode_enable>
   12318:	b110      	cbz	r0, 12320 <am_AEP_board_setup+0x70>
//            am_util_stdio_printf("Apollo3 operating in Burst Mode (96MHz)\r\n");
        }
    }
    else
    {
        am_util_stdio_printf("Failed to Enable Burst Mode operation\r\n");
   1231a:	480d      	ldr	r0, [pc, #52]	; (12350 <am_AEP_board_setup+0xa0>)
   1231c:	f7fd fb30 	bl	f980 <am_util_stdio_printf>
    //
    // Enable interrupts to the core.
    //
    am_hal_interrupt_master_enable();

}
   12320:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    am_hal_interrupt_master_enable();
   12324:	f000 bb22 	b.w	1296c <am_hal_interrupt_master_enable>
            am_util_stdio_printf("Apollo3 Burst Mode is Available\r\n");
   12328:	480a      	ldr	r0, [pc, #40]	; (12354 <am_AEP_board_setup+0xa4>)
   1232a:	f7fd fb29 	bl	f980 <am_util_stdio_printf>
   1232e:	e7f0      	b.n	12312 <am_AEP_board_setup+0x62>
        am_util_stdio_printf("Failed to Initialize for Burst Mode operation\r\n");
   12330:	4809      	ldr	r0, [pc, #36]	; (12358 <am_AEP_board_setup+0xa8>)
   12332:	f7fd fb25 	bl	f980 <am_util_stdio_printf>
   12336:	e7ec      	b.n	12312 <am_AEP_board_setup+0x62>
   12338:	00013b08 	.word	0x00013b08
   1233c:	10002b84 	.word	0x10002b84
   12340:	00013ad4 	.word	0x00013ad4
   12344:	10033be1 	.word	0x10033be1
   12348:	00013a54 	.word	0x00013a54
   1234c:	10033be0 	.word	0x10033be0
   12350:	00013aac 	.word	0x00013aac
   12354:	00013a30 	.word	0x00013a30
   12358:	00013a7c 	.word	0x00013a7c

0001235c <am_AEP_led_task>:
#include "am_AEP_task.h"


// AEP led task
void am_AEP_led_task(void *pvParameters)
{
   1235c:	b530      	push	{r4, r5, lr}
    const TickType_t xDelay200ms = pdMS_TO_TICKS(200);
    const TickType_t xDelaySwirl = pdMS_TO_TICKS(35);
    am_app_utils_task_queue_element_t QueueElement;
    while(1)
    {
        am_app_utils_task_read(am_AEP_tasks, AM_AEP_TASK_LED, &QueueElement);
   1235e:	4d06      	ldr	r5, [pc, #24]	; (12378 <am_AEP_led_task+0x1c>)

        am_devices_led_toggle(am_bsp_psLEDs, 0);
   12360:	4c06      	ldr	r4, [pc, #24]	; (1237c <am_AEP_led_task+0x20>)
{
   12362:	b085      	sub	sp, #20
        am_app_utils_task_read(am_AEP_tasks, AM_AEP_TASK_LED, &QueueElement);
   12364:	466a      	mov	r2, sp
   12366:	2101      	movs	r1, #1
   12368:	4628      	mov	r0, r5
   1236a:	f7fd fcef 	bl	fd4c <am_app_utils_task_read>
        am_devices_led_toggle(am_bsp_psLEDs, 0);
   1236e:	2100      	movs	r1, #0
   12370:	4620      	mov	r0, r4
   12372:	f7fd fd5d 	bl	fe30 <am_devices_led_toggle>
   12376:	e7f5      	b.n	12364 <am_AEP_led_task+0x8>
   12378:	10033a00 	.word	0x10033a00
   1237c:	10002b84 	.word	0x10002b84

00012380 <am_AEP_button_task>:

}

// AEP button task
void am_AEP_button_task(void *pvParameters)
{
   12380:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   12384:	b082      	sub	sp, #8
    const TickType_t xDelay100ms = pdMS_TO_TICKS(100);
    uint32_t ui32PinStatus = 1;
   12386:	ad02      	add	r5, sp, #8
   12388:	2301      	movs	r3, #1
    uint32_t ui32DebounceLoop = 0;
   1238a:	2400      	movs	r4, #0
    uint32_t ui32PinStatus = 1;
   1238c:	f845 3d04 	str.w	r3, [r5, #-4]!
   12390:	4e14      	ldr	r6, [pc, #80]	; (123e4 <am_AEP_button_task+0x64>)
                am_devices_led_on(am_bsp_psLEDs, 2);      
            }
            else
            {
                g_ui8RttRecordFlag = 0;
                am_devices_led_off(am_bsp_psLEDs, 2);
   12392:	4f15      	ldr	r7, [pc, #84]	; (123e8 <am_AEP_button_task+0x68>)
        am_hal_gpio_state_read(AM_BSP_GPIO_BUTTON0, AM_HAL_GPIO_INPUT_READ, &ui32PinStatus);
   12394:	46a0      	mov	r8, r4
   12396:	e005      	b.n	123a4 <am_AEP_button_task+0x24>
        if((ui32PinStatus==0)&&(ui32DebounceLoop<10))
   12398:	2c09      	cmp	r4, #9
   1239a:	d800      	bhi.n	1239e <am_AEP_button_task+0x1e>
            ui32DebounceLoop++;
   1239c:	3401      	adds	r4, #1
            }
#endif // configUSE_RTT_LOGGER
        }
        vTaskDelay(xDelay100ms);    
   1239e:	2064      	movs	r0, #100	; 0x64
   123a0:	f7fb f844 	bl	d42c <vTaskDelay>
        am_hal_gpio_state_read(AM_BSP_GPIO_BUTTON0, AM_HAL_GPIO_INPUT_READ, &ui32PinStatus);
   123a4:	462a      	mov	r2, r5
   123a6:	2100      	movs	r1, #0
   123a8:	2010      	movs	r0, #16
   123aa:	f7fc faab 	bl	e904 <am_hal_gpio_state_read>
        if((ui32PinStatus==0)&&(ui32DebounceLoop<10))
   123ae:	9b01      	ldr	r3, [sp, #4]
   123b0:	2b00      	cmp	r3, #0
   123b2:	d0f1      	beq.n	12398 <am_AEP_button_task+0x18>
        else if((ui32PinStatus==1)&&(ui32DebounceLoop<=2))
   123b4:	2b01      	cmp	r3, #1
   123b6:	d1f2      	bne.n	1239e <am_AEP_button_task+0x1e>
   123b8:	2c02      	cmp	r4, #2
   123ba:	d801      	bhi.n	123c0 <am_AEP_button_task+0x40>
            ui32DebounceLoop = 0;
   123bc:	2400      	movs	r4, #0
   123be:	e7ee      	b.n	1239e <am_AEP_button_task+0x1e>
            if(g_ui8RttRecordFlag == 0)
   123c0:	7832      	ldrb	r2, [r6, #0]
   123c2:	f002 04ff 	and.w	r4, r2, #255	; 0xff
   123c6:	b92a      	cbnz	r2, 123d4 <am_AEP_button_task+0x54>
                am_devices_led_on(am_bsp_psLEDs, 2);      
   123c8:	2102      	movs	r1, #2
   123ca:	4638      	mov	r0, r7
                g_ui8RttRecordFlag = 1;
   123cc:	7033      	strb	r3, [r6, #0]
                am_devices_led_on(am_bsp_psLEDs, 2);      
   123ce:	f7fd fd01 	bl	fdd4 <am_devices_led_on>
   123d2:	e7e4      	b.n	1239e <am_AEP_button_task+0x1e>
                am_devices_led_off(am_bsp_psLEDs, 2);
   123d4:	2102      	movs	r1, #2
   123d6:	4638      	mov	r0, r7
                g_ui8RttRecordFlag = 0;
   123d8:	f886 8000 	strb.w	r8, [r6]
            ui32DebounceLoop = 0;
   123dc:	2400      	movs	r4, #0
                am_devices_led_off(am_bsp_psLEDs, 2);
   123de:	f7fd fd0f 	bl	fe00 <am_devices_led_off>
   123e2:	e7dc      	b.n	1239e <am_AEP_button_task+0x1e>
   123e4:	100133f5 	.word	0x100133f5
   123e8:	10002b84 	.word	0x10002b84

000123ec <am_AEP_codec_task>:
}

#if configUSE_AUDIO_CODEC

void am_AEP_codec_task(void *pvParameters)
{
   123ec:	b500      	push	{lr}
   123ee:	4d10      	ldr	r5, [pc, #64]	; (12430 <am_AEP_codec_task+0x44>)
    int32_t in32LRSample[PCM_FRAME_SIZE];
#endif // configUSE_PDM_DATA

    while(1)
    {
        am_app_utils_task_read(am_AEP_tasks, AM_AEP_TASK_CODEC, &QueueElement);
   123f0:	4c10      	ldr	r4, [pc, #64]	; (12434 <am_AEP_codec_task+0x48>)
{
   123f2:	b0d7      	sub	sp, #348	; 0x15c
        am_app_utils_task_read(am_AEP_tasks, AM_AEP_TASK_CODEC, &QueueElement);
   123f4:	aa02      	add	r2, sp, #8
   123f6:	2103      	movs	r1, #3
   123f8:	4620      	mov	r0, r4
   123fa:	f7fd fca7 	bl	fd4c <am_app_utils_task_read>
        switch(QueueElement.ui32MessageType)
   123fe:	9b03      	ldr	r3, [sp, #12]
   12400:	2b02      	cmp	r3, #2
   12402:	d10b      	bne.n	1241c <am_AEP_codec_task+0x30>
        {
            case AM_APP_MESSAGE_SHORT:
                break;

            case AM_APP_MESSAGE_LONG:
                AM_CRITICAL_BEGIN;
   12404:	f000 fab6 	bl	12974 <am_hal_interrupt_master_disable>
                am_app_utils_ring_buffer_pop(QueueElement.pDataBuffer, in32LRSample, QueueElement.info.ui32Length);
   12408:	a906      	add	r1, sp, #24
                AM_CRITICAL_BEGIN;
   1240a:	4603      	mov	r3, r0
                am_app_utils_ring_buffer_pop(QueueElement.pDataBuffer, in32LRSample, QueueElement.info.ui32Length);
   1240c:	e9dd 2004 	ldrd	r2, r0, [sp, #16]
                AM_CRITICAL_BEGIN;
   12410:	9301      	str	r3, [sp, #4]
                am_app_utils_ring_buffer_pop(QueueElement.pDataBuffer, in32LRSample, QueueElement.info.ui32Length);
   12412:	f7fd fb63 	bl	fadc <am_app_utils_ring_buffer_pop>
                AM_CRITICAL_END;
   12416:	9801      	ldr	r0, [sp, #4]
   12418:	f000 fab0 	bl	1297c <am_hal_interrupt_master_set>

 #if (configUSE_RTT_LOGGER && configUSE_RTT_PCM)
        //
        // Record the raw PCM data and send over RTT
        //
        if(g_ui8RttRecordFlag == 1)
   1241c:	782b      	ldrb	r3, [r5, #0]
   1241e:	2b01      	cmp	r3, #1
   12420:	d1e8      	bne.n	123f4 <am_AEP_codec_task+0x8>
            am_app_utils_rtt_record(in32LRSample, PCM_FRAME_SIZE*PCM_DATA_BYTES); 
   12422:	f44f 71a0 	mov.w	r1, #320	; 0x140
   12426:	a806      	add	r0, sp, #24
   12428:	f7fd fbcc 	bl	fbc4 <am_app_utils_rtt_record>
   1242c:	e7e2      	b.n	123f4 <am_AEP_codec_task+0x8>
   1242e:	bf00      	nop
   12430:	100133f5 	.word	0x100133f5
   12434:	10033a00 	.word	0x10033a00

00012438 <am_AEP_timer_heart_beat_callback>:
//
// Software timer callback functions
//
//*****************************************************************************
void am_AEP_timer_heart_beat_callback(TimerHandle_t xTimer)
{
   12438:	b500      	push	{lr}
//    am_devices_led_toggle(am_bsp_psLEDs, 0);
    am_app_utils_task_send(am_AEP_tasks, AM_AEP_ISR_GPIO, AM_AEP_TASK_LED, 
   1243a:	2301      	movs	r3, #1
{
   1243c:	b083      	sub	sp, #12
    am_app_utils_task_send(am_AEP_tasks, AM_AEP_ISR_GPIO, AM_AEP_TASK_LED, 
   1243e:	2200      	movs	r2, #0
   12440:	e9cd 2200 	strd	r2, r2, [sp]
   12444:	2105      	movs	r1, #5
   12446:	461a      	mov	r2, r3
   12448:	4802      	ldr	r0, [pc, #8]	; (12454 <am_AEP_timer_heart_beat_callback+0x1c>)
   1244a:	f7fd fc21 	bl	fc90 <am_app_utils_task_send>
                   AM_APP_MESSAGE_SHORT, 0, NULL);
}
   1244e:	b003      	add	sp, #12
   12450:	f85d fb04 	ldr.w	pc, [sp], #4
   12454:	10033a00 	.word	0x10033a00

00012458 <am_pdm0_isr>:
// PDM interrupt handler.
//
//*****************************************************************************
#if configUSE_PDM_DATA
void am_pdm0_isr(void) 
{
   12458:	b530      	push	{r4, r5, lr}
#endif // configUSE_SYSVIEWER
    uint32_t ui32Status;
    //
    // Read the interrupt status.
    //
    am_hal_pdm_interrupt_status_get(PDMHandle, &ui32Status, true);
   1245a:	4c16      	ldr	r4, [pc, #88]	; (124b4 <am_pdm0_isr+0x5c>)
{
   1245c:	b085      	sub	sp, #20
    am_hal_pdm_interrupt_status_get(PDMHandle, &ui32Status, true);
   1245e:	2201      	movs	r2, #1
   12460:	a903      	add	r1, sp, #12
   12462:	6820      	ldr	r0, [r4, #0]
   12464:	f7fc f8ee 	bl	e644 <am_hal_pdm_interrupt_status_get>
    am_hal_pdm_interrupt_clear(PDMHandle, ui32Status);
   12468:	6820      	ldr	r0, [r4, #0]
   1246a:	9903      	ldr	r1, [sp, #12]
   1246c:	f7fc f8da 	bl	e624 <am_hal_pdm_interrupt_clear>
    
    if (ui32Status & AM_HAL_PDM_INT_DCMP)
   12470:	9b03      	ldr	r3, [sp, #12]
   12472:	071a      	lsls	r2, r3, #28
   12474:	d409      	bmi.n	1248a <am_pdm0_isr+0x32>
#if configUSE_AUDIO_CODEC
        am_app_utils_task_send_fromISR(am_AEP_tasks, AM_AEP_ISR_PDM, AM_AEP_TASK_CODEC, 
                   AM_APP_MESSAGE_LONG, PCM_FRAME_SIZE*PCM_DATA_BYTES, &am_AEP_ring_buffers[AM_AEP_RINGBUFF_PDM]);
#endif // configUSE_AUDIO_CODEC
    }
    else if(ui32Status & (AM_HAL_PDM_INT_UNDFL | AM_HAL_PDM_INT_OVF))
   12476:	f013 0f06 	tst.w	r3, #6
   1247a:	d101      	bne.n	12480 <am_pdm0_isr+0x28>

#if configUSE_SYSVIEWER
    SEGGER_SYSVIEW_RecordExitISR(); //emit Exit ISR signal
#endif // configUSE_SYSVIEWER

}
   1247c:	b005      	add	sp, #20
   1247e:	bd30      	pop	{r4, r5, pc}
        am_hal_pdm_fifo_flush(PDMHandle);
   12480:	6820      	ldr	r0, [r4, #0]
   12482:	f7fc f8a9 	bl	e5d8 <am_hal_pdm_fifo_flush>
}
   12486:	b005      	add	sp, #20
   12488:	bd30      	pop	{r4, r5, pc}
        PDMn(0)->DMATOTCOUNT = PCM_FRAME_SIZE*PCM_DATA_BYTES;  // FIFO unit in bytes
   1248a:	4b0b      	ldr	r3, [pc, #44]	; (124b8 <am_pdm0_isr+0x60>)
        am_app_utils_ring_buffer_push(&am_AEP_ring_buffers[AM_AEP_RINGBUFF_PDM], g_ui32PCMDataBuff, PCM_FRAME_SIZE*PCM_DATA_BYTES);
   1248c:	4d0b      	ldr	r5, [pc, #44]	; (124bc <am_pdm0_isr+0x64>)
   1248e:	490c      	ldr	r1, [pc, #48]	; (124c0 <am_pdm0_isr+0x68>)
        PDMn(0)->DMATOTCOUNT = PCM_FRAME_SIZE*PCM_DATA_BYTES;  // FIFO unit in bytes
   12490:	f44f 74a0 	mov.w	r4, #320	; 0x140
   12494:	f8c3 4288 	str.w	r4, [r3, #648]	; 0x288
        am_app_utils_ring_buffer_push(&am_AEP_ring_buffers[AM_AEP_RINGBUFF_PDM], g_ui32PCMDataBuff, PCM_FRAME_SIZE*PCM_DATA_BYTES);
   12498:	4622      	mov	r2, r4
   1249a:	4628      	mov	r0, r5
   1249c:	f7fd fab0 	bl	fa00 <am_app_utils_ring_buffer_push>
        am_app_utils_task_send_fromISR(am_AEP_tasks, AM_AEP_ISR_PDM, AM_AEP_TASK_CODEC, 
   124a0:	e9cd 4500 	strd	r4, r5, [sp]
   124a4:	2302      	movs	r3, #2
   124a6:	2203      	movs	r2, #3
   124a8:	2104      	movs	r1, #4
   124aa:	4806      	ldr	r0, [pc, #24]	; (124c4 <am_pdm0_isr+0x6c>)
   124ac:	f7fd fc10 	bl	fcd0 <am_app_utils_task_send_fromISR>
}
   124b0:	b005      	add	sp, #20
   124b2:	bd30      	pop	{r4, r5, pc}
   124b4:	10033be4 	.word	0x10033be4
   124b8:	50011000 	.word	0x50011000
   124bc:	100339d8 	.word	0x100339d8
   124c0:	10033aa0 	.word	0x10033aa0
   124c4:	10033a00 	.word	0x10033a00

000124c8 <am_gpio_isr>:
#endif // configUSE_PDM_DATA

// GPIO isr handle the buttons on board
void am_gpio_isr(void)
{
   124c8:	b500      	push	{lr}
   124ca:	b083      	sub	sp, #12
    uint64_t ui64IntStatus = 0;
   124cc:	2200      	movs	r2, #0
   124ce:	2300      	movs	r3, #0
   124d0:	a902      	add	r1, sp, #8
   124d2:	e961 2302 	strd	r2, r3, [r1, #-8]!
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    
    //
    // Read and clear the GPIO interrupt status.
    //
    am_hal_gpio_interrupt_status_get(false, &ui64IntStatus);
   124d6:	2000      	movs	r0, #0
   124d8:	f7fc fadc 	bl	ea94 <am_hal_gpio_interrupt_status_get>
    am_hal_gpio_interrupt_clear(ui64IntStatus);
   124dc:	e9dd 0100 	ldrd	r0, r1, [sp]
   124e0:	f7fc fab6 	bl	ea50 <am_hal_gpio_interrupt_clear>

    if(ui64IntStatus & AM_HAL_GPIO_BIT(AM_BSP_GPIO_BUTTON0))
   124e4:	e9dd 2300 	ldrd	r2, r3, [sp]
   124e8:	2100      	movs	r1, #0
   124ea:	f402 3080 	and.w	r0, r2, #65536	; 0x10000
   124ee:	ea50 0301 	orrs.w	r3, r0, r1
   124f2:	d104      	bne.n	124fe <am_gpio_isr+0x36>
//            am_app_utils_task_send_fromISR(am_AEP_tasks, AM_AEP_ISR_GPIO, 2, 
//                   AM_APP_MESSAGE_SHORT, ui32KeyValue, NULL);
        }  

    }
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
   124f4:	f7fe fa00 	bl	108f8 <SEGGER_SYSVIEW_RecordExitISR>

}
   124f8:	b003      	add	sp, #12
   124fa:	f85d fb04 	ldr.w	pc, [sp], #4
        am_hal_gpio_interrupt_disable(AM_HAL_GPIO_BIT(AM_BSP_GPIO_BUTTON0));
   124fe:	2100      	movs	r1, #0
   12500:	f44f 3080 	mov.w	r0, #65536	; 0x10000
   12504:	f7fc fa7a 	bl	e9fc <am_hal_gpio_interrupt_disable>
        am_hal_gpio_interrupt_clear(AM_HAL_GPIO_BIT(AM_BSP_GPIO_BUTTON0));
   12508:	f44f 3080 	mov.w	r0, #65536	; 0x10000
   1250c:	2100      	movs	r1, #0
   1250e:	f7fc fa9f 	bl	ea50 <am_hal_gpio_interrupt_clear>
        if(g_ui8DebounceFlag == 0)
   12512:	4b05      	ldr	r3, [pc, #20]	; (12528 <am_gpio_isr+0x60>)
   12514:	781a      	ldrb	r2, [r3, #0]
   12516:	2a00      	cmp	r2, #0
   12518:	d1ec      	bne.n	124f4 <am_gpio_isr+0x2c>
            g_ui8DebounceFlag = 1;
   1251a:	2201      	movs	r2, #1
   1251c:	701a      	strb	r2, [r3, #0]
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
   1251e:	f7fe f9eb 	bl	108f8 <SEGGER_SYSVIEW_RecordExitISR>
}
   12522:	b003      	add	sp, #12
   12524:	f85d fb04 	ldr.w	pc, [sp], #4
   12528:	100133f4 	.word	0x100133f4

0001252c <NMI_Handler>:
// by a debugger.
//
//*****************************************************************************
void
NMI_Handler(void)
{
   1252c:	e7fe      	b.n	1252c <NMI_Handler>
   1252e:	bf00      	nop

00012530 <DebugMon_Handler>:
// for examination by a debugger.
//
//*****************************************************************************
void
am_default_isr(void)
{
   12530:	e7fe      	b.n	12530 <DebugMon_Handler>
   12532:	bf00      	nop

00012534 <Reset_Handler>:
    __asm("    ldr    r0, =0xE000ED08\n"
   12534:	4811      	ldr	r0, [pc, #68]	; (1257c <zero_loop+0x12>)
   12536:	4912      	ldr	r1, [pc, #72]	; (12580 <zero_loop+0x16>)
   12538:	6001      	str	r1, [r0, #0]
    __asm("    ldr    sp, [r1]");
   1253a:	f8d1 d000 	ldr.w	sp, [r1]
    __asm("ldr  r0, =0xE000ED88\n"
   1253e:	4811      	ldr	r0, [pc, #68]	; (12584 <zero_loop+0x1a>)
   12540:	6801      	ldr	r1, [r0, #0]
   12542:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   12546:	6001      	str	r1, [r0, #0]
   12548:	f3bf 8f4f 	dsb	sy
   1254c:	f3bf 8f6f 	isb	sy
    __asm("    ldr     r0, =_init_data\n"
   12550:	480d      	ldr	r0, [pc, #52]	; (12588 <zero_loop+0x1e>)
   12552:	490e      	ldr	r1, [pc, #56]	; (1258c <zero_loop+0x22>)
   12554:	4a0e      	ldr	r2, [pc, #56]	; (12590 <zero_loop+0x26>)

00012556 <copy_loop>:
   12556:	f850 3b04 	ldr.w	r3, [r0], #4
   1255a:	f841 3b04 	str.w	r3, [r1], #4
   1255e:	4291      	cmp	r1, r2
   12560:	dbf9      	blt.n	12556 <copy_loop>
    __asm("    ldr     r0, =_sbss\n"
   12562:	480c      	ldr	r0, [pc, #48]	; (12594 <zero_loop+0x2a>)
   12564:	490c      	ldr	r1, [pc, #48]	; (12598 <zero_loop+0x2e>)
   12566:	f04f 0200 	mov.w	r2, #0

0001256a <zero_loop>:
   1256a:	4288      	cmp	r0, r1
   1256c:	bfb8      	it	lt
   1256e:	f840 2b04 	strlt.w	r2, [r0], #4
   12572:	dbfa      	blt.n	1256a <zero_loop>
    main();
   12574:	f7f9 feae 	bl	c2d4 <main>
    __asm("    bkpt     ");
   12578:	be00      	bkpt	0x0000
   1257a:	0000      	.short	0x0000
   1257c:	e000ed08 	.word	0xe000ed08
   12580:	0000c000 	.word	0x0000c000
   12584:	e000ed88 	.word	0xe000ed88
   12588:	00013c40 	.word	0x00013c40
   1258c:	10002b00 	.word	0x10002b00
   12590:	10002bac 	.word	0x10002bac
   12594:	10002bac 	.word	0x10002bac
   12598:	10033cb0 	.word	0x10033cb0

0001259c <am_bsp_uart_string_print>:
   1259c:	b510      	push	{r4, lr}
   1259e:	b086      	sub	sp, #24
   125a0:	7803      	ldrb	r3, [r0, #0]
   125a2:	2400      	movs	r4, #0
   125a4:	9400      	str	r4, [sp, #0]
   125a6:	b1bb      	cbz	r3, 125d8 <am_bsp_uart_string_print+0x3c>
   125a8:	4603      	mov	r3, r0
   125aa:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   125ae:	3401      	adds	r4, #1
   125b0:	2a00      	cmp	r2, #0
   125b2:	d1fa      	bne.n	125aa <am_bsp_uart_string_print+0xe>
   125b4:	4b0a      	ldr	r3, [pc, #40]	; (125e0 <am_bsp_uart_string_print+0x44>)
   125b6:	9002      	str	r0, [sp, #8]
   125b8:	2200      	movs	r2, #0
   125ba:	6818      	ldr	r0, [r3, #0]
   125bc:	9403      	str	r4, [sp, #12]
   125be:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   125c2:	a901      	add	r1, sp, #4
   125c4:	9304      	str	r3, [sp, #16]
   125c6:	9201      	str	r2, [sp, #4]
   125c8:	f8cd d014 	str.w	sp, [sp, #20]
   125cc:	f000 fdce 	bl	1316c <am_hal_uart_transfer>
   125d0:	9b00      	ldr	r3, [sp, #0]
   125d2:	42a3      	cmp	r3, r4
   125d4:	d002      	beq.n	125dc <am_bsp_uart_string_print+0x40>
   125d6:	e7fe      	b.n	125d6 <am_bsp_uart_string_print+0x3a>
   125d8:	461c      	mov	r4, r3
   125da:	e7eb      	b.n	125b4 <am_bsp_uart_string_print+0x18>
   125dc:	b006      	add	sp, #24
   125de:	bd10      	pop	{r4, pc}
   125e0:	100133fc 	.word	0x100133fc

000125e4 <am_bsp_low_power_init>:
   125e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   125e6:	f000 f9cd 	bl	12984 <am_hal_itm_disable>
   125ea:	2000      	movs	r0, #0
   125ec:	f7fc fbbc 	bl	ed68 <am_util_stdio_printf_init>
   125f0:	4b12      	ldr	r3, [pc, #72]	; (1263c <am_bsp_low_power_init+0x58>)
   125f2:	4f13      	ldr	r7, [pc, #76]	; (12640 <am_bsp_low_power_init+0x5c>)
   125f4:	6819      	ldr	r1, [r3, #0]
   125f6:	2029      	movs	r0, #41	; 0x29
   125f8:	f7fc f842 	bl	e680 <am_hal_gpio_pinconfig>
   125fc:	f000 fb04 	bl	12c08 <am_hal_pwrctrl_low_power_init>
   12600:	2001      	movs	r0, #1
   12602:	f000 fb4b 	bl	12c9c <am_hal_rtc_osc_select>
   12606:	2100      	movs	r1, #0
   12608:	2003      	movs	r0, #3
   1260a:	f000 f8f5 	bl	127f8 <am_hal_clkgen_control>
   1260e:	f000 fb51 	bl	12cb4 <am_hal_rtc_osc_disable>
   12612:	4b0c      	ldr	r3, [pc, #48]	; (12644 <am_bsp_low_power_init+0x60>)
   12614:	681e      	ldr	r6, [r3, #0]
   12616:	2400      	movs	r4, #0
   12618:	f857 5034 	ldr.w	r5, [r7, r4, lsl #3]
   1261c:	4631      	mov	r1, r6
   1261e:	4628      	mov	r0, r5
   12620:	f7fc f82e 	bl	e680 <am_hal_gpio_pinconfig>
   12624:	2103      	movs	r1, #3
   12626:	4628      	mov	r0, r5
   12628:	f7fc f9a4 	bl	e974 <am_hal_gpio_state_write>
   1262c:	3401      	adds	r4, #1
   1262e:	4628      	mov	r0, r5
   12630:	2100      	movs	r1, #0
   12632:	f7fc f99f 	bl	e974 <am_hal_gpio_state_write>
   12636:	2c05      	cmp	r4, #5
   12638:	d1ee      	bne.n	12618 <am_bsp_low_power_init+0x34>
   1263a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1263c:	00013800 	.word	0x00013800
   12640:	10002b84 	.word	0x10002b84
   12644:	00013804 	.word	0x00013804

00012648 <am_bsp_uart_printf_enable>:
   12648:	b510      	push	{r4, lr}
   1264a:	4c10      	ldr	r4, [pc, #64]	; (1268c <am_bsp_uart_printf_enable+0x44>)
   1264c:	4b10      	ldr	r3, [pc, #64]	; (12690 <am_bsp_uart_printf_enable+0x48>)
   1264e:	4621      	mov	r1, r4
   12650:	2202      	movs	r2, #2
   12652:	2000      	movs	r0, #0
   12654:	601a      	str	r2, [r3, #0]
   12656:	f000 fbe3 	bl	12e20 <am_hal_uart_initialize>
   1265a:	2200      	movs	r2, #0
   1265c:	4611      	mov	r1, r2
   1265e:	6820      	ldr	r0, [r4, #0]
   12660:	f000 fc06 	bl	12e70 <am_hal_uart_power_control>
   12664:	6820      	ldr	r0, [r4, #0]
   12666:	490b      	ldr	r1, [pc, #44]	; (12694 <am_bsp_uart_printf_enable+0x4c>)
   12668:	f000 fc74 	bl	12f54 <am_hal_uart_configure>
   1266c:	4b0a      	ldr	r3, [pc, #40]	; (12698 <am_bsp_uart_printf_enable+0x50>)
   1266e:	2016      	movs	r0, #22
   12670:	6819      	ldr	r1, [r3, #0]
   12672:	f7fc f805 	bl	e680 <am_hal_gpio_pinconfig>
   12676:	4b09      	ldr	r3, [pc, #36]	; (1269c <am_bsp_uart_printf_enable+0x54>)
   12678:	2017      	movs	r0, #23
   1267a:	6819      	ldr	r1, [r3, #0]
   1267c:	f7fc f800 	bl	e680 <am_hal_gpio_pinconfig>
   12680:	4807      	ldr	r0, [pc, #28]	; (126a0 <am_bsp_uart_printf_enable+0x58>)
   12682:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   12686:	f7fc bb6f 	b.w	ed68 <am_util_stdio_printf_init>
   1268a:	bf00      	nop
   1268c:	100133fc 	.word	0x100133fc
   12690:	100133f8 	.word	0x100133f8
   12694:	00013ad8 	.word	0x00013ad8
   12698:	00013b00 	.word	0x00013b00
   1269c:	00013b04 	.word	0x00013b04
   126a0:	0001259d 	.word	0x0001259d

000126a4 <am_hal_burst_mode_initialize>:
   126a4:	b570      	push	{r4, r5, r6, lr}
   126a6:	4b1e      	ldr	r3, [pc, #120]	; (12720 <am_hal_burst_mode_initialize+0x7c>)
   126a8:	695a      	ldr	r2, [r3, #20]
   126aa:	07d5      	lsls	r5, r2, #31
   126ac:	b082      	sub	sp, #8
   126ae:	4604      	mov	r4, r0
   126b0:	d407      	bmi.n	126c2 <am_hal_burst_mode_initialize+0x1e>
   126b2:	4a1c      	ldr	r2, [pc, #112]	; (12724 <am_hal_burst_mode_initialize+0x80>)
   126b4:	2100      	movs	r1, #0
   126b6:	2301      	movs	r3, #1
   126b8:	7011      	strb	r1, [r2, #0]
   126ba:	2007      	movs	r0, #7
   126bc:	7023      	strb	r3, [r4, #0]
   126be:	b002      	add	sp, #8
   126c0:	bd70      	pop	{r4, r5, r6, pc}
   126c2:	4a19      	ldr	r2, [pc, #100]	; (12728 <am_hal_burst_mode_initialize+0x84>)
   126c4:	6a91      	ldr	r1, [r2, #40]	; 0x28
   126c6:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
   126ca:	6291      	str	r1, [r2, #40]	; 0x28
   126cc:	6812      	ldr	r2, [r2, #0]
   126ce:	07d0      	lsls	r0, r2, #31
   126d0:	d507      	bpl.n	126e2 <am_hal_burst_mode_initialize+0x3e>
   126d2:	68db      	ldr	r3, [r3, #12]
   126d4:	b2db      	uxtb	r3, r3
   126d6:	2b11      	cmp	r3, #17
   126d8:	d903      	bls.n	126e2 <am_hal_burst_mode_initialize+0x3e>
   126da:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
   126de:	4a13      	ldr	r2, [pc, #76]	; (1272c <am_hal_burst_mode_initialize+0x88>)
   126e0:	63da      	str	r2, [r3, #60]	; 0x3c
   126e2:	4d0f      	ldr	r5, [pc, #60]	; (12720 <am_hal_burst_mode_initialize+0x7c>)
   126e4:	4912      	ldr	r1, [pc, #72]	; (12730 <am_hal_burst_mode_initialize+0x8c>)
   126e6:	7e2a      	ldrb	r2, [r5, #24]
   126e8:	2601      	movs	r6, #1
   126ea:	f042 0210 	orr.w	r2, r2, #16
   126ee:	2320      	movs	r3, #32
   126f0:	762a      	strb	r2, [r5, #24]
   126f2:	f242 7010 	movw	r0, #10000	; 0x2710
   126f6:	461a      	mov	r2, r3
   126f8:	9600      	str	r6, [sp, #0]
   126fa:	f000 f90b 	bl	12914 <am_hal_flash_delay_status_check>
   126fe:	b948      	cbnz	r0, 12714 <am_hal_burst_mode_initialize+0x70>
   12700:	69aa      	ldr	r2, [r5, #24]
   12702:	0651      	lsls	r1, r2, #25
   12704:	d5d5      	bpl.n	126b2 <am_hal_burst_mode_initialize+0xe>
   12706:	69aa      	ldr	r2, [r5, #24]
   12708:	0692      	lsls	r2, r2, #26
   1270a:	d5d2      	bpl.n	126b2 <am_hal_burst_mode_initialize+0xe>
   1270c:	4a05      	ldr	r2, [pc, #20]	; (12724 <am_hal_burst_mode_initialize+0x80>)
   1270e:	7016      	strb	r6, [r2, #0]
   12710:	7020      	strb	r0, [r4, #0]
   12712:	e7d4      	b.n	126be <am_hal_burst_mode_initialize+0x1a>
   12714:	4a03      	ldr	r2, [pc, #12]	; (12724 <am_hal_burst_mode_initialize+0x80>)
   12716:	2100      	movs	r1, #0
   12718:	7011      	strb	r1, [r2, #0]
   1271a:	7026      	strb	r6, [r4, #0]
   1271c:	b002      	add	sp, #8
   1271e:	bd70      	pop	{r4, r5, r6, pc}
   12720:	40020000 	.word	0x40020000
   12724:	10013400 	.word	0x10013400
   12728:	40021000 	.word	0x40021000
   1272c:	0fc0400f 	.word	0x0fc0400f
   12730:	40020018 	.word	0x40020018

00012734 <am_hal_burst_mode_enable>:
   12734:	4b14      	ldr	r3, [pc, #80]	; (12788 <am_hal_burst_mode_enable+0x54>)
   12736:	781b      	ldrb	r3, [r3, #0]
   12738:	b91b      	cbnz	r3, 12742 <am_hal_burst_mode_enable+0xe>
   1273a:	2301      	movs	r3, #1
   1273c:	7003      	strb	r3, [r0, #0]
   1273e:	2007      	movs	r0, #7
   12740:	4770      	bx	lr
   12742:	b570      	push	{r4, r5, r6, lr}
   12744:	f04f 2540 	mov.w	r5, #1073758208	; 0x40004000
   12748:	b082      	sub	sp, #8
   1274a:	f895 2034 	ldrb.w	r2, [r5, #52]	; 0x34
   1274e:	490f      	ldr	r1, [pc, #60]	; (1278c <am_hal_burst_mode_enable+0x58>)
   12750:	2601      	movs	r6, #1
   12752:	4332      	orrs	r2, r6
   12754:	2304      	movs	r3, #4
   12756:	f885 2034 	strb.w	r2, [r5, #52]	; 0x34
   1275a:	4604      	mov	r4, r0
   1275c:	461a      	mov	r2, r3
   1275e:	9600      	str	r6, [sp, #0]
   12760:	f242 7010 	movw	r0, #10000	; 0x2710
   12764:	f000 f8d6 	bl	12914 <am_hal_flash_delay_status_check>
   12768:	b938      	cbnz	r0, 1277a <am_hal_burst_mode_enable+0x46>
   1276a:	6b6b      	ldr	r3, [r5, #52]	; 0x34
   1276c:	079a      	lsls	r2, r3, #30
   1276e:	d507      	bpl.n	12780 <am_hal_burst_mode_enable+0x4c>
   12770:	6b6b      	ldr	r3, [r5, #52]	; 0x34
   12772:	075b      	lsls	r3, r3, #29
   12774:	d501      	bpl.n	1277a <am_hal_burst_mode_enable+0x46>
   12776:	7020      	strb	r0, [r4, #0]
   12778:	e000      	b.n	1277c <am_hal_burst_mode_enable+0x48>
   1277a:	7026      	strb	r6, [r4, #0]
   1277c:	b002      	add	sp, #8
   1277e:	bd70      	pop	{r4, r5, r6, pc}
   12780:	7026      	strb	r6, [r4, #0]
   12782:	4630      	mov	r0, r6
   12784:	e7fa      	b.n	1277c <am_hal_burst_mode_enable+0x48>
   12786:	bf00      	nop
   12788:	10013400 	.word	0x10013400
   1278c:	40004034 	.word	0x40004034

00012790 <am_hal_cachectrl_config>:
   12790:	b530      	push	{r4, r5, lr}
   12792:	b083      	sub	sp, #12
   12794:	4605      	mov	r5, r0
   12796:	f000 f8ed 	bl	12974 <am_hal_interrupt_master_disable>
   1279a:	4c11      	ldr	r4, [pc, #68]	; (127e0 <am_hal_cachectrl_config+0x50>)
   1279c:	9001      	str	r0, [sp, #4]
   1279e:	6823      	ldr	r3, [r4, #0]
   127a0:	f423 7340 	bic.w	r3, r3, #768	; 0x300
   127a4:	6023      	str	r3, [r4, #0]
   127a6:	9801      	ldr	r0, [sp, #4]
   127a8:	f000 f8e8 	bl	1297c <am_hal_interrupt_master_set>
   127ac:	78eb      	ldrb	r3, [r5, #3]
   127ae:	782a      	ldrb	r2, [r5, #0]
   127b0:	78a8      	ldrb	r0, [r5, #2]
   127b2:	7869      	ldrb	r1, [r5, #1]
   127b4:	005b      	lsls	r3, r3, #1
   127b6:	0112      	lsls	r2, r2, #4
   127b8:	b2d2      	uxtb	r2, r2
   127ba:	f003 0302 	and.w	r3, r3, #2
   127be:	4313      	orrs	r3, r2
   127c0:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   127c4:	0080      	lsls	r0, r0, #2
   127c6:	f000 000c 	and.w	r0, r0, #12
   127ca:	020a      	lsls	r2, r1, #8
   127cc:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
   127d0:	4303      	orrs	r3, r0
   127d2:	f402 7240 	and.w	r2, r2, #768	; 0x300
   127d6:	4313      	orrs	r3, r2
   127d8:	2000      	movs	r0, #0
   127da:	6023      	str	r3, [r4, #0]
   127dc:	b003      	add	sp, #12
   127de:	bd30      	pop	{r4, r5, pc}
   127e0:	40018000 	.word	0x40018000

000127e4 <am_hal_cachectrl_enable>:
   127e4:	4a03      	ldr	r2, [pc, #12]	; (127f4 <am_hal_cachectrl_enable+0x10>)
   127e6:	6813      	ldr	r3, [r2, #0]
   127e8:	f043 0301 	orr.w	r3, r3, #1
   127ec:	6013      	str	r3, [r2, #0]
   127ee:	2000      	movs	r0, #0
   127f0:	4770      	bx	lr
   127f2:	bf00      	nop
   127f4:	40018000 	.word	0x40018000

000127f8 <am_hal_clkgen_control>:
   127f8:	4b32      	ldr	r3, [pc, #200]	; (128c4 <am_hal_clkgen_control+0xcc>)
   127fa:	681a      	ldr	r2, [r3, #0]
   127fc:	b912      	cbnz	r2, 12804 <am_hal_clkgen_control+0xc>
   127fe:	4a32      	ldr	r2, [pc, #200]	; (128c8 <am_hal_clkgen_control+0xd0>)
   12800:	6812      	ldr	r2, [r2, #0]
   12802:	601a      	str	r2, [r3, #0]
   12804:	2809      	cmp	r0, #9
   12806:	d85a      	bhi.n	128be <am_hal_clkgen_control+0xc6>
   12808:	e8df f000 	tbb	[pc, r0]
   1280c:	261e160d 	.word	0x261e160d
   12810:	4640362e 	.word	0x4640362e
   12814:	054e      	.short	0x054e
   12816:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
   1281a:	2000      	movs	r0, #0
   1281c:	6a1a      	ldr	r2, [r3, #32]
   1281e:	f36f 0200 	bfc	r2, #0, #1
   12822:	621a      	str	r2, [r3, #32]
   12824:	4770      	bx	lr
   12826:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
   1282a:	2200      	movs	r2, #0
   1282c:	2147      	movs	r1, #71	; 0x47
   1282e:	6159      	str	r1, [r3, #20]
   12830:	4610      	mov	r0, r2
   12832:	619a      	str	r2, [r3, #24]
   12834:	615a      	str	r2, [r3, #20]
   12836:	4770      	bx	lr
   12838:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
   1283c:	2000      	movs	r0, #0
   1283e:	68d3      	ldr	r3, [r2, #12]
   12840:	f023 0301 	bic.w	r3, r3, #1
   12844:	60d3      	str	r3, [r2, #12]
   12846:	4770      	bx	lr
   12848:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
   1284c:	2000      	movs	r0, #0
   1284e:	68d3      	ldr	r3, [r2, #12]
   12850:	f023 0302 	bic.w	r3, r3, #2
   12854:	60d3      	str	r3, [r2, #12]
   12856:	4770      	bx	lr
   12858:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
   1285c:	2000      	movs	r0, #0
   1285e:	68d3      	ldr	r3, [r2, #12]
   12860:	f043 0301 	orr.w	r3, r3, #1
   12864:	60d3      	str	r3, [r2, #12]
   12866:	4770      	bx	lr
   12868:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
   1286c:	2000      	movs	r0, #0
   1286e:	68d3      	ldr	r3, [r2, #12]
   12870:	f043 0302 	orr.w	r3, r3, #2
   12874:	60d3      	str	r3, [r2, #12]
   12876:	4770      	bx	lr
   12878:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
   1287c:	2200      	movs	r2, #0
   1287e:	2047      	movs	r0, #71	; 0x47
   12880:	2101      	movs	r1, #1
   12882:	6158      	str	r0, [r3, #20]
   12884:	6199      	str	r1, [r3, #24]
   12886:	4610      	mov	r0, r2
   12888:	615a      	str	r2, [r3, #20]
   1288a:	4770      	bx	lr
   1288c:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
   12890:	2000      	movs	r0, #0
   12892:	68da      	ldr	r2, [r3, #12]
   12894:	60da      	str	r2, [r3, #12]
   12896:	4770      	bx	lr
   12898:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
   1289c:	2000      	movs	r0, #0
   1289e:	68d3      	ldr	r3, [r2, #12]
   128a0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   128a4:	60d3      	str	r3, [r2, #12]
   128a6:	4770      	bx	lr
   128a8:	b139      	cbz	r1, 128ba <am_hal_clkgen_control+0xc2>
   128aa:	680b      	ldr	r3, [r1, #0]
   128ac:	f043 0301 	orr.w	r3, r3, #1
   128b0:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
   128b4:	2000      	movs	r0, #0
   128b6:	6213      	str	r3, [r2, #32]
   128b8:	4770      	bx	lr
   128ba:	4b04      	ldr	r3, [pc, #16]	; (128cc <am_hal_clkgen_control+0xd4>)
   128bc:	e7f8      	b.n	128b0 <am_hal_clkgen_control+0xb8>
   128be:	2006      	movs	r0, #6
   128c0:	4770      	bx	lr
   128c2:	bf00      	nop
   128c4:	10013404 	.word	0x10013404
   128c8:	4ffff000 	.word	0x4ffff000
   128cc:	0025b801 	.word	0x0025b801

000128d0 <am_hal_clkgen_status_get>:
   128d0:	b1a8      	cbz	r0, 128fe <am_hal_clkgen_status_get+0x2e>
   128d2:	b410      	push	{r4}
   128d4:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
   128d8:	490a      	ldr	r1, [pc, #40]	; (12904 <am_hal_clkgen_status_get+0x34>)
   128da:	6994      	ldr	r4, [r2, #24]
   128dc:	4b0a      	ldr	r3, [pc, #40]	; (12908 <am_hal_clkgen_status_get+0x38>)
   128de:	f014 0f01 	tst.w	r4, #1
   128e2:	bf08      	it	eq
   128e4:	460b      	moveq	r3, r1
   128e6:	6003      	str	r3, [r0, #0]
   128e8:	69d3      	ldr	r3, [r2, #28]
   128ea:	f85d 4b04 	ldr.w	r4, [sp], #4
   128ee:	f003 0201 	and.w	r2, r3, #1
   128f2:	f3c3 0340 	ubfx	r3, r3, #1, #1
   128f6:	6042      	str	r2, [r0, #4]
   128f8:	7203      	strb	r3, [r0, #8]
   128fa:	2000      	movs	r0, #0
   128fc:	4770      	bx	lr
   128fe:	2006      	movs	r0, #6
   12900:	4770      	bx	lr
   12902:	bf00      	nop
   12904:	02dc6c00 	.word	0x02dc6c00
   12908:	016e3600 	.word	0x016e3600

0001290c <am_hal_flash_delay>:
   1290c:	4b00      	ldr	r3, [pc, #0]	; (12910 <am_hal_flash_delay+0x4>)
   1290e:	4718      	bx	r3
   12910:	0800009d 	.word	0x0800009d

00012914 <am_hal_flash_delay_status_check>:
   12914:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   12918:	f89d 4018 	ldrb.w	r4, [sp, #24]
   1291c:	460d      	mov	r5, r1
   1291e:	4616      	mov	r6, r2
   12920:	461f      	mov	r7, r3
   12922:	b17c      	cbz	r4, 12944 <am_hal_flash_delay_status_check+0x30>
   12924:	4604      	mov	r4, r0
   12926:	f8df 8040 	ldr.w	r8, [pc, #64]	; 12968 <am_hal_flash_delay_status_check+0x54>
   1292a:	e002      	b.n	12932 <am_hal_flash_delay_status_check+0x1e>
   1292c:	b1c4      	cbz	r4, 12960 <am_hal_flash_delay_status_check+0x4c>
   1292e:	47c0      	blx	r8
   12930:	3c01      	subs	r4, #1
   12932:	682b      	ldr	r3, [r5, #0]
   12934:	4033      	ands	r3, r6
   12936:	429f      	cmp	r7, r3
   12938:	f04f 0001 	mov.w	r0, #1
   1293c:	d1f6      	bne.n	1292c <am_hal_flash_delay_status_check+0x18>
   1293e:	2000      	movs	r0, #0
   12940:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   12944:	f8df 8020 	ldr.w	r8, [pc, #32]	; 12968 <am_hal_flash_delay_status_check+0x54>
   12948:	4604      	mov	r4, r0
   1294a:	e002      	b.n	12952 <am_hal_flash_delay_status_check+0x3e>
   1294c:	b144      	cbz	r4, 12960 <am_hal_flash_delay_status_check+0x4c>
   1294e:	47c0      	blx	r8
   12950:	3c01      	subs	r4, #1
   12952:	682b      	ldr	r3, [r5, #0]
   12954:	4033      	ands	r3, r6
   12956:	429f      	cmp	r7, r3
   12958:	f04f 0001 	mov.w	r0, #1
   1295c:	d0f6      	beq.n	1294c <am_hal_flash_delay_status_check+0x38>
   1295e:	e7ee      	b.n	1293e <am_hal_flash_delay_status_check+0x2a>
   12960:	2004      	movs	r0, #4
   12962:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   12966:	bf00      	nop
   12968:	0800009d 	.word	0x0800009d

0001296c <am_hal_interrupt_master_enable>:
   1296c:	f3ef 8010 	mrs	r0, PRIMASK
   12970:	b662      	cpsie	i
   12972:	4770      	bx	lr

00012974 <am_hal_interrupt_master_disable>:
   12974:	f3ef 8010 	mrs	r0, PRIMASK
   12978:	b672      	cpsid	i
   1297a:	4770      	bx	lr

0001297c <am_hal_interrupt_master_set>:
   1297c:	f380 8810 	msr	PRIMASK, r0
   12980:	4770      	bx	lr
   12982:	bf00      	nop

00012984 <am_hal_itm_disable>:
   12984:	b510      	push	{r4, lr}
   12986:	4b25      	ldr	r3, [pc, #148]	; (12a1c <am_hal_itm_disable+0x98>)
   12988:	f8d3 3250 	ldr.w	r3, [r3, #592]	; 0x250
   1298c:	b9b3      	cbnz	r3, 129bc <am_hal_itm_disable+0x38>
   1298e:	4b24      	ldr	r3, [pc, #144]	; (12a20 <am_hal_itm_disable+0x9c>)
   12990:	68da      	ldr	r2, [r3, #12]
   12992:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
   12996:	60da      	str	r2, [r3, #12]
   12998:	68da      	ldr	r2, [r3, #12]
   1299a:	01d2      	lsls	r2, r2, #7
   1299c:	d5fc      	bpl.n	12998 <am_hal_itm_disable+0x14>
   1299e:	f04f 4360 	mov.w	r3, #3758096384	; 0xe0000000
   129a2:	4920      	ldr	r1, [pc, #128]	; (12a24 <am_hal_itm_disable+0xa0>)
   129a4:	f8c3 1fb0 	str.w	r1, [r3, #4016]	; 0xfb0
   129a8:	4a1f      	ldr	r2, [pc, #124]	; (12a28 <am_hal_itm_disable+0xa4>)
   129aa:	200f      	movs	r0, #15
   129ac:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   129b0:	f8c3 0e40 	str.w	r0, [r3, #3648]	; 0xe40
   129b4:	f8c3 1e00 	str.w	r1, [r3, #3584]	; 0xe00
   129b8:	f8c3 2e80 	str.w	r2, [r3, #3712]	; 0xe80
   129bc:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
   129c0:	f8d2 3e80 	ldr.w	r3, [r2, #3712]	; 0xe80
   129c4:	021b      	lsls	r3, r3, #8
   129c6:	f04f 4460 	mov.w	r4, #3758096384	; 0xe0000000
   129ca:	d4f9      	bmi.n	129c0 <am_hal_itm_disable+0x3c>
   129cc:	f240 20f7 	movw	r0, #759	; 0x2f7
   129d0:	f7ff ff9c 	bl	1290c <am_hal_flash_delay>
   129d4:	4b13      	ldr	r3, [pc, #76]	; (12a24 <am_hal_itm_disable+0xa0>)
   129d6:	f8c4 3fb0 	str.w	r3, [r4, #4016]	; 0xfb0
   129da:	4621      	mov	r1, r4
   129dc:	2064      	movs	r0, #100	; 0x64
   129de:	f8d1 3e80 	ldr.w	r3, [r1, #3712]	; 0xe80
   129e2:	f023 0301 	bic.w	r3, r3, #1
   129e6:	f8c1 3e80 	str.w	r3, [r1, #3712]	; 0xe80
   129ea:	f8d1 2e80 	ldr.w	r2, [r1, #3712]	; 0xe80
   129ee:	4b0f      	ldr	r3, [pc, #60]	; (12a2c <am_hal_itm_disable+0xa8>)
   129f0:	4013      	ands	r3, r2
   129f2:	2b00      	cmp	r3, #0
   129f4:	d1f9      	bne.n	129ea <am_hal_itm_disable+0x66>
   129f6:	3801      	subs	r0, #1
   129f8:	d1f1      	bne.n	129de <am_hal_itm_disable+0x5a>
   129fa:	4a09      	ldr	r2, [pc, #36]	; (12a20 <am_hal_itm_disable+0x9c>)
   129fc:	68d3      	ldr	r3, [r2, #12]
   129fe:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
   12a02:	60d3      	str	r3, [r2, #12]
   12a04:	68d3      	ldr	r3, [r2, #12]
   12a06:	f013 7380 	ands.w	r3, r3, #16777216	; 0x1000000
   12a0a:	d1fb      	bne.n	12a04 <am_hal_itm_disable+0x80>
   12a0c:	4a03      	ldr	r2, [pc, #12]	; (12a1c <am_hal_itm_disable+0x98>)
   12a0e:	f8c2 3250 	str.w	r3, [r2, #592]	; 0x250
   12a12:	f8d2 3250 	ldr.w	r3, [r2, #592]	; 0x250
   12a16:	2b00      	cmp	r3, #0
   12a18:	d1fb      	bne.n	12a12 <am_hal_itm_disable+0x8e>
   12a1a:	bd10      	pop	{r4, pc}
   12a1c:	40020000 	.word	0x40020000
   12a20:	e000edf0 	.word	0xe000edf0
   12a24:	c5acce55 	.word	0xc5acce55
   12a28:	00150511 	.word	0x00150511
   12a2c:	00800001 	.word	0x00800001

00012a30 <am_hal_mcuctrl_info_get>:
   12a30:	b4f0      	push	{r4, r5, r6, r7}
   12a32:	b121      	cbz	r1, 12a3e <am_hal_mcuctrl_info_get+0xe>
   12a34:	2801      	cmp	r0, #1
   12a36:	d038      	beq.n	12aaa <am_hal_mcuctrl_info_get+0x7a>
   12a38:	d320      	bcc.n	12a7c <am_hal_mcuctrl_info_get+0x4c>
   12a3a:	2802      	cmp	r0, #2
   12a3c:	d002      	beq.n	12a44 <am_hal_mcuctrl_info_get+0x14>
   12a3e:	2006      	movs	r0, #6
   12a40:	bcf0      	pop	{r4, r5, r6, r7}
   12a42:	4770      	bx	lr
   12a44:	4a41      	ldr	r2, [pc, #260]	; (12b4c <am_hal_mcuctrl_info_get+0x11c>)
   12a46:	684d      	ldr	r5, [r1, #4]
   12a48:	f8d2 31cc 	ldr.w	r3, [r2, #460]	; 0x1cc
   12a4c:	694c      	ldr	r4, [r1, #20]
   12a4e:	f003 0601 	and.w	r6, r3, #1
   12a52:	f3c3 0040 	ubfx	r0, r3, #1, #1
   12a56:	f3c3 0380 	ubfx	r3, r3, #2, #1
   12a5a:	700e      	strb	r6, [r1, #0]
   12a5c:	7208      	strb	r0, [r1, #8]
   12a5e:	740b      	strb	r3, [r1, #16]
   12a60:	f8d2 31c4 	ldr.w	r3, [r2, #452]	; 0x1c4
   12a64:	60cb      	str	r3, [r1, #12]
   12a66:	f8d2 01c0 	ldr.w	r0, [r2, #448]	; 0x1c0
   12a6a:	4328      	orrs	r0, r5
   12a6c:	6048      	str	r0, [r1, #4]
   12a6e:	f8d2 31c8 	ldr.w	r3, [r2, #456]	; 0x1c8
   12a72:	4323      	orrs	r3, r4
   12a74:	2000      	movs	r0, #0
   12a76:	614b      	str	r3, [r1, #20]
   12a78:	bcf0      	pop	{r4, r5, r6, r7}
   12a7a:	4770      	bx	lr
   12a7c:	4a33      	ldr	r2, [pc, #204]	; (12b4c <am_hal_mcuctrl_info_get+0x11c>)
   12a7e:	6993      	ldr	r3, [r2, #24]
   12a80:	f3c3 1080 	ubfx	r0, r3, #6, #1
   12a84:	f3c3 0380 	ubfx	r3, r3, #2, #1
   12a88:	7008      	strb	r0, [r1, #0]
   12a8a:	704b      	strb	r3, [r1, #1]
   12a8c:	f8d2 31a0 	ldr.w	r3, [r2, #416]	; 0x1a0
   12a90:	f3c3 6381 	ubfx	r3, r3, #26, #2
   12a94:	710b      	strb	r3, [r1, #4]
   12a96:	6953      	ldr	r3, [r2, #20]
   12a98:	f3c3 0240 	ubfx	r2, r3, #1, #1
   12a9c:	f003 0301 	and.w	r3, r3, #1
   12aa0:	2000      	movs	r0, #0
   12aa2:	708a      	strb	r2, [r1, #2]
   12aa4:	70cb      	strb	r3, [r1, #3]
   12aa6:	bcf0      	pop	{r4, r5, r6, r7}
   12aa8:	4770      	bx	lr
   12aaa:	4b28      	ldr	r3, [pc, #160]	; (12b4c <am_hal_mcuctrl_info_get+0x11c>)
   12aac:	4c28      	ldr	r4, [pc, #160]	; (12b50 <am_hal_mcuctrl_info_get+0x120>)
   12aae:	681a      	ldr	r2, [r3, #0]
   12ab0:	600a      	str	r2, [r1, #0]
   12ab2:	6858      	ldr	r0, [r3, #4]
   12ab4:	6048      	str	r0, [r1, #4]
   12ab6:	6898      	ldr	r0, [r3, #8]
   12ab8:	6088      	str	r0, [r1, #8]
   12aba:	68d8      	ldr	r0, [r3, #12]
   12abc:	60c8      	str	r0, [r1, #12]
   12abe:	691d      	ldr	r5, [r3, #16]
   12ac0:	4824      	ldr	r0, [pc, #144]	; (12b54 <am_hal_mcuctrl_info_get+0x124>)
   12ac2:	610d      	str	r5, [r1, #16]
   12ac4:	f3c2 5703 	ubfx	r7, r2, #20, #4
   12ac8:	f3c2 4603 	ubfx	r6, r2, #16, #4
   12acc:	695d      	ldr	r5, [r3, #20]
   12ace:	f854 4027 	ldr.w	r4, [r4, r7, lsl #2]
   12ad2:	4b21      	ldr	r3, [pc, #132]	; (12b58 <am_hal_mcuctrl_info_get+0x128>)
   12ad4:	f850 0026 	ldr.w	r0, [r0, r6, lsl #2]
   12ad8:	6208      	str	r0, [r1, #32]
   12ada:	f002 0201 	and.w	r2, r2, #1
   12ade:	614d      	str	r5, [r1, #20]
   12ae0:	61cc      	str	r4, [r1, #28]
   12ae2:	618a      	str	r2, [r1, #24]
   12ae4:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
   12ae8:	f8d3 40e4 	ldr.w	r4, [r3, #228]	; 0xe4
   12aec:	b2d0      	uxtb	r0, r2
   12aee:	f004 020f 	and.w	r2, r4, #15
   12af2:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
   12af6:	624a      	str	r2, [r1, #36]	; 0x24
   12af8:	f8d3 20e4 	ldr.w	r2, [r3, #228]	; 0xe4
   12afc:	f8d3 40e8 	ldr.w	r4, [r3, #232]	; 0xe8
   12b00:	f3c2 1003 	ubfx	r0, r2, #4, #4
   12b04:	f004 020f 	and.w	r2, r4, #15
   12b08:	ea40 1202 	orr.w	r2, r0, r2, lsl #4
   12b0c:	628a      	str	r2, [r1, #40]	; 0x28
   12b0e:	f8d3 00e8 	ldr.w	r0, [r3, #232]	; 0xe8
   12b12:	f8d3 20ec 	ldr.w	r2, [r3, #236]	; 0xec
   12b16:	f000 00f0 	and.w	r0, r0, #240	; 0xf0
   12b1a:	f3c2 1203 	ubfx	r2, r2, #4, #4
   12b1e:	4302      	orrs	r2, r0
   12b20:	62ca      	str	r2, [r1, #44]	; 0x2c
   12b22:	f8d3 50fc 	ldr.w	r5, [r3, #252]	; 0xfc
   12b26:	f8d3 00f8 	ldr.w	r0, [r3, #248]	; 0xf8
   12b2a:	f8d3 40f4 	ldr.w	r4, [r3, #244]	; 0xf4
   12b2e:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
   12b32:	b2c0      	uxtb	r0, r0
   12b34:	0400      	lsls	r0, r0, #16
   12b36:	ea40 6305 	orr.w	r3, r0, r5, lsl #24
   12b3a:	b2d2      	uxtb	r2, r2
   12b3c:	431a      	orrs	r2, r3
   12b3e:	b2e3      	uxtb	r3, r4
   12b40:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
   12b44:	630b      	str	r3, [r1, #48]	; 0x30
   12b46:	2000      	movs	r0, #0
   12b48:	bcf0      	pop	{r4, r5, r6, r7}
   12b4a:	4770      	bx	lr
   12b4c:	40020000 	.word	0x40020000
   12b50:	00013b0c 	.word	0x00013b0c
   12b54:	00013b4c 	.word	0x00013b4c
   12b58:	f0000f00 	.word	0xf0000f00

00012b5c <am_hal_pwrctrl_periph_enable>:
   12b5c:	b570      	push	{r4, r5, r6, lr}
   12b5e:	b082      	sub	sp, #8
   12b60:	4604      	mov	r4, r0
   12b62:	f7ff ff07 	bl	12974 <am_hal_interrupt_master_disable>
   12b66:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   12b6a:	4d0f      	ldr	r5, [pc, #60]	; (12ba8 <am_hal_pwrctrl_periph_enable+0x4c>)
   12b6c:	4e0f      	ldr	r6, [pc, #60]	; (12bac <am_hal_pwrctrl_periph_enable+0x50>)
   12b6e:	9001      	str	r0, [sp, #4]
   12b70:	00a4      	lsls	r4, r4, #2
   12b72:	68aa      	ldr	r2, [r5, #8]
   12b74:	5933      	ldr	r3, [r6, r4]
   12b76:	4313      	orrs	r3, r2
   12b78:	60ab      	str	r3, [r5, #8]
   12b7a:	9801      	ldr	r0, [sp, #4]
   12b7c:	4434      	add	r4, r6
   12b7e:	f7ff fefd 	bl	1297c <am_hal_interrupt_master_set>
   12b82:	2077      	movs	r0, #119	; 0x77
   12b84:	f7ff fec2 	bl	1290c <am_hal_flash_delay>
   12b88:	69ab      	ldr	r3, [r5, #24]
   12b8a:	6864      	ldr	r4, [r4, #4]
   12b8c:	4223      	tst	r3, r4
   12b8e:	d103      	bne.n	12b98 <am_hal_pwrctrl_periph_enable+0x3c>
   12b90:	2077      	movs	r0, #119	; 0x77
   12b92:	f7ff febb 	bl	1290c <am_hal_flash_delay>
   12b96:	69ab      	ldr	r3, [r5, #24]
   12b98:	4b03      	ldr	r3, [pc, #12]	; (12ba8 <am_hal_pwrctrl_periph_enable+0x4c>)
   12b9a:	699b      	ldr	r3, [r3, #24]
   12b9c:	4223      	tst	r3, r4
   12b9e:	bf0c      	ite	eq
   12ba0:	2001      	moveq	r0, #1
   12ba2:	2000      	movne	r0, #0
   12ba4:	b002      	add	sp, #8
   12ba6:	bd70      	pop	{r4, r5, r6, pc}
   12ba8:	40021000 	.word	0x40021000
   12bac:	00013b8c 	.word	0x00013b8c

00012bb0 <am_hal_pwrctrl_periph_disable>:
   12bb0:	b570      	push	{r4, r5, r6, lr}
   12bb2:	b082      	sub	sp, #8
   12bb4:	4604      	mov	r4, r0
   12bb6:	f7ff fedd 	bl	12974 <am_hal_interrupt_master_disable>
   12bba:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   12bbe:	4d10      	ldr	r5, [pc, #64]	; (12c00 <am_hal_pwrctrl_periph_disable+0x50>)
   12bc0:	4e10      	ldr	r6, [pc, #64]	; (12c04 <am_hal_pwrctrl_periph_disable+0x54>)
   12bc2:	9001      	str	r0, [sp, #4]
   12bc4:	00a4      	lsls	r4, r4, #2
   12bc6:	68ab      	ldr	r3, [r5, #8]
   12bc8:	5932      	ldr	r2, [r6, r4]
   12bca:	ea23 0302 	bic.w	r3, r3, r2
   12bce:	60ab      	str	r3, [r5, #8]
   12bd0:	9801      	ldr	r0, [sp, #4]
   12bd2:	4434      	add	r4, r6
   12bd4:	f7ff fed2 	bl	1297c <am_hal_interrupt_master_set>
   12bd8:	2077      	movs	r0, #119	; 0x77
   12bda:	f7ff fe97 	bl	1290c <am_hal_flash_delay>
   12bde:	69ab      	ldr	r3, [r5, #24]
   12be0:	6864      	ldr	r4, [r4, #4]
   12be2:	4223      	tst	r3, r4
   12be4:	d003      	beq.n	12bee <am_hal_pwrctrl_periph_disable+0x3e>
   12be6:	2077      	movs	r0, #119	; 0x77
   12be8:	f7ff fe90 	bl	1290c <am_hal_flash_delay>
   12bec:	69ab      	ldr	r3, [r5, #24]
   12bee:	4b04      	ldr	r3, [pc, #16]	; (12c00 <am_hal_pwrctrl_periph_disable+0x50>)
   12bf0:	699b      	ldr	r3, [r3, #24]
   12bf2:	4223      	tst	r3, r4
   12bf4:	bf14      	ite	ne
   12bf6:	2001      	movne	r0, #1
   12bf8:	2000      	moveq	r0, #0
   12bfa:	b002      	add	sp, #8
   12bfc:	bd70      	pop	{r4, r5, r6, pc}
   12bfe:	bf00      	nop
   12c00:	40021000 	.word	0x40021000
   12c04:	00013b8c 	.word	0x00013b8c

00012c08 <am_hal_pwrctrl_low_power_init>:
   12c08:	b530      	push	{r4, r5, lr}
   12c0a:	4b1f      	ldr	r3, [pc, #124]	; (12c88 <am_hal_pwrctrl_low_power_init+0x80>)
   12c0c:	681a      	ldr	r2, [r3, #0]
   12c0e:	b083      	sub	sp, #12
   12c10:	b912      	cbnz	r2, 12c18 <am_hal_pwrctrl_low_power_init+0x10>
   12c12:	4a1e      	ldr	r2, [pc, #120]	; (12c8c <am_hal_pwrctrl_low_power_init+0x84>)
   12c14:	6812      	ldr	r2, [r2, #0]
   12c16:	601a      	str	r2, [r3, #0]
   12c18:	4c1d      	ldr	r4, [pc, #116]	; (12c90 <am_hal_pwrctrl_low_power_init+0x88>)
   12c1a:	69a3      	ldr	r3, [r4, #24]
   12c1c:	05db      	lsls	r3, r3, #23
   12c1e:	d502      	bpl.n	12c26 <am_hal_pwrctrl_low_power_init+0x1e>
   12c20:	2000      	movs	r0, #0
   12c22:	b003      	add	sp, #12
   12c24:	bd30      	pop	{r4, r5, pc}
   12c26:	4d1b      	ldr	r5, [pc, #108]	; (12c94 <am_hal_pwrctrl_low_power_init+0x8c>)
   12c28:	491b      	ldr	r1, [pc, #108]	; (12c98 <am_hal_pwrctrl_low_power_init+0x90>)
   12c2a:	7e2a      	ldrb	r2, [r5, #24]
   12c2c:	2001      	movs	r0, #1
   12c2e:	4302      	orrs	r2, r0
   12c30:	2307      	movs	r3, #7
   12c32:	762a      	strb	r2, [r5, #24]
   12c34:	9000      	str	r0, [sp, #0]
   12c36:	461a      	mov	r2, r3
   12c38:	f242 7010 	movw	r0, #10000	; 0x2710
   12c3c:	f7ff fe6a 	bl	12914 <am_hal_flash_delay_status_check>
   12c40:	b110      	cbz	r0, 12c48 <am_hal_pwrctrl_low_power_init+0x40>
   12c42:	2004      	movs	r0, #4
   12c44:	b003      	add	sp, #12
   12c46:	bd30      	pop	{r4, r5, pc}
   12c48:	6823      	ldr	r3, [r4, #0]
   12c4a:	f043 0301 	orr.w	r3, r3, #1
   12c4e:	6023      	str	r3, [r4, #0]
   12c50:	6a63      	ldr	r3, [r4, #36]	; 0x24
   12c52:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   12c56:	6263      	str	r3, [r4, #36]	; 0x24
   12c58:	68eb      	ldr	r3, [r5, #12]
   12c5a:	b2db      	uxtb	r3, r3
   12c5c:	2b11      	cmp	r3, #17
   12c5e:	d1df      	bne.n	12c20 <am_hal_pwrctrl_low_power_init+0x18>
   12c60:	f8d5 335c 	ldr.w	r3, [r5, #860]	; 0x35c
   12c64:	f360 5356 	bfi	r3, r0, #21, #2
   12c68:	f8c5 335c 	str.w	r3, [r5, #860]	; 0x35c
   12c6c:	f8d5 3368 	ldr.w	r3, [r5, #872]	; 0x368
   12c70:	220f      	movs	r2, #15
   12c72:	f362 138b 	bfi	r3, r2, #6, #6
   12c76:	f8c5 3368 	str.w	r3, [r5, #872]	; 0x368
   12c7a:	f8d5 3368 	ldr.w	r3, [r5, #872]	; 0x368
   12c7e:	f362 0305 	bfi	r3, r2, #0, #6
   12c82:	f8c5 3368 	str.w	r3, [r5, #872]	; 0x368
   12c86:	e7cc      	b.n	12c22 <am_hal_pwrctrl_low_power_init+0x1a>
   12c88:	10013404 	.word	0x10013404
   12c8c:	4ffff000 	.word	0x4ffff000
   12c90:	40021000 	.word	0x40021000
   12c94:	40020000 	.word	0x40020000
   12c98:	40020018 	.word	0x40020018

00012c9c <am_hal_rtc_osc_select>:
   12c9c:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
   12ca0:	2801      	cmp	r0, #1
   12ca2:	68d3      	ldr	r3, [r2, #12]
   12ca4:	bf0c      	ite	eq
   12ca6:	f043 0380 	orreq.w	r3, r3, #128	; 0x80
   12caa:	f023 0380 	bicne.w	r3, r3, #128	; 0x80
   12cae:	60d3      	str	r3, [r2, #12]
   12cb0:	4770      	bx	lr
   12cb2:	bf00      	nop

00012cb4 <am_hal_rtc_osc_disable>:
   12cb4:	4a03      	ldr	r2, [pc, #12]	; (12cc4 <am_hal_rtc_osc_disable+0x10>)
   12cb6:	f892 3050 	ldrb.w	r3, [r2, #80]	; 0x50
   12cba:	f043 0310 	orr.w	r3, r3, #16
   12cbe:	f882 3050 	strb.w	r3, [r2, #80]	; 0x50
   12cc2:	4770      	bx	lr
   12cc4:	40004200 	.word	0x40004200

00012cc8 <am_hal_stimer_config>:
   12cc8:	4b03      	ldr	r3, [pc, #12]	; (12cd8 <am_hal_stimer_config+0x10>)
   12cca:	f8d3 2140 	ldr.w	r2, [r3, #320]	; 0x140
   12cce:	f8c3 0140 	str.w	r0, [r3, #320]	; 0x140
   12cd2:	4610      	mov	r0, r2
   12cd4:	4770      	bx	lr
   12cd6:	bf00      	nop
   12cd8:	40008000 	.word	0x40008000

00012cdc <am_hal_stimer_counter_get>:
   12cdc:	4b01      	ldr	r3, [pc, #4]	; (12ce4 <am_hal_stimer_counter_get+0x8>)
   12cde:	f8d3 0144 	ldr.w	r0, [r3, #324]	; 0x144
   12ce2:	4770      	bx	lr
   12ce4:	40008000 	.word	0x40008000

00012ce8 <am_hal_stimer_compare_delta_set>:
   12ce8:	2807      	cmp	r0, #7
   12cea:	d900      	bls.n	12cee <am_hal_stimer_compare_delta_set+0x6>
   12cec:	4770      	bx	lr
   12cee:	b570      	push	{r4, r5, r6, lr}
   12cf0:	b082      	sub	sp, #8
   12cf2:	460c      	mov	r4, r1
   12cf4:	4605      	mov	r5, r0
   12cf6:	f7ff fe3d 	bl	12974 <am_hal_interrupt_master_disable>
   12cfa:	4923      	ldr	r1, [pc, #140]	; (12d88 <am_hal_stimer_compare_delta_set+0xa0>)
   12cfc:	9001      	str	r0, [sp, #4]
   12cfe:	4b23      	ldr	r3, [pc, #140]	; (12d8c <am_hal_stimer_compare_delta_set+0xa4>)
   12d00:	f8d1 0140 	ldr.w	r0, [r1, #320]	; 0x140
   12d04:	f8d1 6140 	ldr.w	r6, [r1, #320]	; 0x140
   12d08:	f44f 7280 	mov.w	r2, #256	; 0x100
   12d0c:	442b      	add	r3, r5
   12d0e:	40aa      	lsls	r2, r5
   12d10:	ea26 0502 	bic.w	r5, r6, r2
   12d14:	009b      	lsls	r3, r3, #2
   12d16:	f8c1 5140 	str.w	r5, [r1, #320]	; 0x140
   12d1a:	f8d1 1144 	ldr.w	r1, [r1, #324]	; 0x144
   12d1e:	601c      	str	r4, [r3, #0]
   12d20:	681d      	ldr	r5, [r3, #0]
   12d22:	4421      	add	r1, r4
   12d24:	1a6e      	subs	r6, r5, r1
   12d26:	2e00      	cmp	r6, #0
   12d28:	db03      	blt.n	12d32 <am_hal_stimer_compare_delta_set+0x4a>
   12d2a:	310a      	adds	r1, #10
   12d2c:	1a69      	subs	r1, r5, r1
   12d2e:	2900      	cmp	r1, #0
   12d30:	dd1e      	ble.n	12d70 <am_hal_stimer_compare_delta_set+0x88>
   12d32:	4915      	ldr	r1, [pc, #84]	; (12d88 <am_hal_stimer_compare_delta_set+0xa0>)
   12d34:	f8d1 1144 	ldr.w	r1, [r1, #324]	; 0x144
   12d38:	601c      	str	r4, [r3, #0]
   12d3a:	681d      	ldr	r5, [r3, #0]
   12d3c:	4421      	add	r1, r4
   12d3e:	1a6e      	subs	r6, r5, r1
   12d40:	2e00      	cmp	r6, #0
   12d42:	db03      	blt.n	12d4c <am_hal_stimer_compare_delta_set+0x64>
   12d44:	310a      	adds	r1, #10
   12d46:	1a69      	subs	r1, r5, r1
   12d48:	2900      	cmp	r1, #0
   12d4a:	dd11      	ble.n	12d70 <am_hal_stimer_compare_delta_set+0x88>
   12d4c:	490e      	ldr	r1, [pc, #56]	; (12d88 <am_hal_stimer_compare_delta_set+0xa0>)
   12d4e:	f8d1 1144 	ldr.w	r1, [r1, #324]	; 0x144
   12d52:	601c      	str	r4, [r3, #0]
   12d54:	681d      	ldr	r5, [r3, #0]
   12d56:	4421      	add	r1, r4
   12d58:	1a6e      	subs	r6, r5, r1
   12d5a:	2e00      	cmp	r6, #0
   12d5c:	db03      	blt.n	12d66 <am_hal_stimer_compare_delta_set+0x7e>
   12d5e:	310a      	adds	r1, #10
   12d60:	1a69      	subs	r1, r5, r1
   12d62:	2900      	cmp	r1, #0
   12d64:	dd04      	ble.n	12d70 <am_hal_stimer_compare_delta_set+0x88>
   12d66:	4908      	ldr	r1, [pc, #32]	; (12d88 <am_hal_stimer_compare_delta_set+0xa0>)
   12d68:	f8d1 1144 	ldr.w	r1, [r1, #324]	; 0x144
   12d6c:	601c      	str	r4, [r3, #0]
   12d6e:	681b      	ldr	r3, [r3, #0]
   12d70:	4905      	ldr	r1, [pc, #20]	; (12d88 <am_hal_stimer_compare_delta_set+0xa0>)
   12d72:	f8d1 3140 	ldr.w	r3, [r1, #320]	; 0x140
   12d76:	4002      	ands	r2, r0
   12d78:	431a      	orrs	r2, r3
   12d7a:	f8c1 2140 	str.w	r2, [r1, #320]	; 0x140
   12d7e:	9801      	ldr	r0, [sp, #4]
   12d80:	f7ff fdfc 	bl	1297c <am_hal_interrupt_master_set>
   12d84:	b002      	add	sp, #8
   12d86:	bd70      	pop	{r4, r5, r6, pc}
   12d88:	40008000 	.word	0x40008000
   12d8c:	10002054 	.word	0x10002054

00012d90 <am_hal_stimer_int_enable>:
   12d90:	4a03      	ldr	r2, [pc, #12]	; (12da0 <am_hal_stimer_int_enable+0x10>)
   12d92:	f8d2 3300 	ldr.w	r3, [r2, #768]	; 0x300
   12d96:	4318      	orrs	r0, r3
   12d98:	f8c2 0300 	str.w	r0, [r2, #768]	; 0x300
   12d9c:	4770      	bx	lr
   12d9e:	bf00      	nop
   12da0:	40008000 	.word	0x40008000

00012da4 <am_hal_stimer_int_clear>:
   12da4:	4b01      	ldr	r3, [pc, #4]	; (12dac <am_hal_stimer_int_clear+0x8>)
   12da6:	f8c3 0308 	str.w	r0, [r3, #776]	; 0x308
   12daa:	4770      	bx	lr
   12dac:	40008000 	.word	0x40008000

00012db0 <am_hal_stimer_int_status_get>:
   12db0:	4a04      	ldr	r2, [pc, #16]	; (12dc4 <am_hal_stimer_int_status_get+0x14>)
   12db2:	f8d2 3304 	ldr.w	r3, [r2, #772]	; 0x304
   12db6:	b110      	cbz	r0, 12dbe <am_hal_stimer_int_status_get+0xe>
   12db8:	f8d2 2300 	ldr.w	r2, [r2, #768]	; 0x300
   12dbc:	4013      	ands	r3, r2
   12dbe:	4618      	mov	r0, r3
   12dc0:	4770      	bx	lr
   12dc2:	bf00      	nop
   12dc4:	40008000 	.word	0x40008000

00012dc8 <am_hal_sysctrl_sleep>:
   12dc8:	b510      	push	{r4, lr}
   12dca:	b082      	sub	sp, #8
   12dcc:	4604      	mov	r4, r0
   12dce:	f7ff fdd1 	bl	12974 <am_hal_interrupt_master_disable>
   12dd2:	4a0f      	ldr	r2, [pc, #60]	; (12e10 <am_hal_sysctrl_sleep+0x48>)
   12dd4:	9001      	str	r0, [sp, #4]
   12dd6:	b124      	cbz	r4, 12de2 <am_hal_sysctrl_sleep+0x1a>
   12dd8:	4b0e      	ldr	r3, [pc, #56]	; (12e14 <am_hal_sysctrl_sleep+0x4c>)
   12dda:	f8d3 3250 	ldr.w	r3, [r3, #592]	; 0x250
   12dde:	07db      	lsls	r3, r3, #31
   12de0:	d511      	bpl.n	12e06 <am_hal_sysctrl_sleep+0x3e>
   12de2:	6913      	ldr	r3, [r2, #16]
   12de4:	f023 0304 	bic.w	r3, r3, #4
   12de8:	6113      	str	r3, [r2, #16]
   12dea:	f3bf 8f4f 	dsb	sy
   12dee:	4a0a      	ldr	r2, [pc, #40]	; (12e18 <am_hal_sysctrl_sleep+0x50>)
   12df0:	4b0a      	ldr	r3, [pc, #40]	; (12e1c <am_hal_sysctrl_sleep+0x54>)
   12df2:	6812      	ldr	r2, [r2, #0]
   12df4:	601a      	str	r2, [r3, #0]
   12df6:	bf30      	wfi
   12df8:	f3bf 8f6f 	isb	sy
   12dfc:	9801      	ldr	r0, [sp, #4]
   12dfe:	f7ff fdbd 	bl	1297c <am_hal_interrupt_master_set>
   12e02:	b002      	add	sp, #8
   12e04:	bd10      	pop	{r4, pc}
   12e06:	6913      	ldr	r3, [r2, #16]
   12e08:	f043 0304 	orr.w	r3, r3, #4
   12e0c:	6113      	str	r3, [r2, #16]
   12e0e:	e7ec      	b.n	12dea <am_hal_sysctrl_sleep+0x22>
   12e10:	e000ed00 	.word	0xe000ed00
   12e14:	40020000 	.word	0x40020000
   12e18:	5fff0000 	.word	0x5fff0000
   12e1c:	10013408 	.word	0x10013408

00012e20 <am_hal_uart_initialize>:
   12e20:	2801      	cmp	r0, #1
   12e22:	d901      	bls.n	12e28 <am_hal_uart_initialize+0x8>
   12e24:	2005      	movs	r0, #5
   12e26:	4770      	bx	lr
   12e28:	b169      	cbz	r1, 12e46 <am_hal_uart_initialize+0x26>
   12e2a:	b5f0      	push	{r4, r5, r6, r7, lr}
   12e2c:	2264      	movs	r2, #100	; 0x64
   12e2e:	4e0e      	ldr	r6, [pc, #56]	; (12e68 <am_hal_uart_initialize+0x48>)
   12e30:	fb02 f200 	mul.w	r2, r2, r0
   12e34:	18b4      	adds	r4, r6, r2
   12e36:	4603      	mov	r3, r0
   12e38:	78e0      	ldrb	r0, [r4, #3]
   12e3a:	f3c0 0700 	ubfx	r7, r0, #0, #1
   12e3e:	b2fd      	uxtb	r5, r7
   12e40:	b11d      	cbz	r5, 12e4a <am_hal_uart_initialize+0x2a>
   12e42:	2007      	movs	r0, #7
   12e44:	bdf0      	pop	{r4, r5, r6, r7, pc}
   12e46:	2006      	movs	r0, #6
   12e48:	4770      	bx	lr
   12e4a:	f040 0001 	orr.w	r0, r0, #1
   12e4e:	70e0      	strb	r0, [r4, #3]
   12e50:	58b0      	ldr	r0, [r6, r2]
   12e52:	f8df e018 	ldr.w	lr, [pc, #24]	; 12e6c <am_hal_uart_initialize+0x4c>
   12e56:	f36e 0017 	bfi	r0, lr, #0, #24
   12e5a:	50b0      	str	r0, [r6, r2]
   12e5c:	6263      	str	r3, [r4, #36]	; 0x24
   12e5e:	7127      	strb	r7, [r4, #4]
   12e60:	6625      	str	r5, [r4, #96]	; 0x60
   12e62:	4628      	mov	r0, r5
   12e64:	600c      	str	r4, [r1, #0]
   12e66:	bdf0      	pop	{r4, r5, r6, r7, pc}
   12e68:	10033be8 	.word	0x10033be8
   12e6c:	00ea9e06 	.word	0x00ea9e06

00012e70 <am_hal_uart_power_control>:
   12e70:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   12e74:	6804      	ldr	r4, [r0, #0]
   12e76:	4b36      	ldr	r3, [pc, #216]	; (12f50 <am_hal_uart_power_control+0xe0>)
   12e78:	f024 447e 	bic.w	r4, r4, #4261412864	; 0xfe000000
   12e7c:	429c      	cmp	r4, r3
   12e7e:	b083      	sub	sp, #12
   12e80:	d003      	beq.n	12e8a <am_hal_uart_power_control+0x1a>
   12e82:	2002      	movs	r0, #2
   12e84:	b003      	add	sp, #12
   12e86:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   12e8a:	6a47      	ldr	r7, [r0, #36]	; 0x24
   12e8c:	4605      	mov	r5, r0
   12e8e:	f107 0008 	add.w	r0, r7, #8
   12e92:	4691      	mov	r9, r2
   12e94:	460e      	mov	r6, r1
   12e96:	fa5f f880 	uxtb.w	r8, r0
   12e9a:	b181      	cbz	r1, 12ebe <am_hal_uart_power_control+0x4e>
   12e9c:	2902      	cmp	r1, #2
   12e9e:	d80c      	bhi.n	12eba <am_hal_uart_power_control+0x4a>
   12ea0:	b992      	cbnz	r2, 12ec8 <am_hal_uart_power_control+0x58>
   12ea2:	f507 2780 	add.w	r7, r7, #262144	; 0x40000
   12ea6:	371c      	adds	r7, #28
   12ea8:	033f      	lsls	r7, r7, #12
   12eaa:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   12eae:	647b      	str	r3, [r7, #68]	; 0x44
   12eb0:	4640      	mov	r0, r8
   12eb2:	f7ff fe7d 	bl	12bb0 <am_hal_pwrctrl_periph_disable>
   12eb6:	2000      	movs	r0, #0
   12eb8:	e7e4      	b.n	12e84 <am_hal_uart_power_control+0x14>
   12eba:	2006      	movs	r0, #6
   12ebc:	e7e2      	b.n	12e84 <am_hal_uart_power_control+0x14>
   12ebe:	b322      	cbz	r2, 12f0a <am_hal_uart_power_control+0x9a>
   12ec0:	792b      	ldrb	r3, [r5, #4]
   12ec2:	bb3b      	cbnz	r3, 12f14 <am_hal_uart_power_control+0xa4>
   12ec4:	2007      	movs	r0, #7
   12ec6:	e7dd      	b.n	12e84 <am_hal_uart_power_control+0x14>
   12ec8:	f7ff fd54 	bl	12974 <am_hal_interrupt_master_disable>
   12ecc:	f507 2380 	add.w	r3, r7, #262144	; 0x40000
   12ed0:	331c      	adds	r3, #28
   12ed2:	031b      	lsls	r3, r3, #12
   12ed4:	9001      	str	r0, [sp, #4]
   12ed6:	6a1a      	ldr	r2, [r3, #32]
   12ed8:	60aa      	str	r2, [r5, #8]
   12eda:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   12edc:	60ea      	str	r2, [r5, #12]
   12ede:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   12ee0:	612a      	str	r2, [r5, #16]
   12ee2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   12ee4:	616a      	str	r2, [r5, #20]
   12ee6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   12ee8:	61aa      	str	r2, [r5, #24]
   12eea:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   12eec:	61ea      	str	r2, [r5, #28]
   12eee:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   12ef0:	622b      	str	r3, [r5, #32]
   12ef2:	2301      	movs	r3, #1
   12ef4:	712b      	strb	r3, [r5, #4]
   12ef6:	9801      	ldr	r0, [sp, #4]
   12ef8:	f7ff fd40 	bl	1297c <am_hal_interrupt_master_set>
   12efc:	682b      	ldr	r3, [r5, #0]
   12efe:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   12f02:	42a3      	cmp	r3, r4
   12f04:	d1d4      	bne.n	12eb0 <am_hal_uart_power_control+0x40>
   12f06:	6a6f      	ldr	r7, [r5, #36]	; 0x24
   12f08:	e7cb      	b.n	12ea2 <am_hal_uart_power_control+0x32>
   12f0a:	4640      	mov	r0, r8
   12f0c:	f7ff fe26 	bl	12b5c <am_hal_pwrctrl_periph_enable>
   12f10:	4648      	mov	r0, r9
   12f12:	e7b7      	b.n	12e84 <am_hal_uart_power_control+0x14>
   12f14:	4640      	mov	r0, r8
   12f16:	f7ff fe21 	bl	12b5c <am_hal_pwrctrl_periph_enable>
   12f1a:	f7ff fd2b 	bl	12974 <am_hal_interrupt_master_disable>
   12f1e:	f507 2380 	add.w	r3, r7, #262144	; 0x40000
   12f22:	331c      	adds	r3, #28
   12f24:	031b      	lsls	r3, r3, #12
   12f26:	68aa      	ldr	r2, [r5, #8]
   12f28:	9000      	str	r0, [sp, #0]
   12f2a:	621a      	str	r2, [r3, #32]
   12f2c:	68ea      	ldr	r2, [r5, #12]
   12f2e:	625a      	str	r2, [r3, #36]	; 0x24
   12f30:	692a      	ldr	r2, [r5, #16]
   12f32:	629a      	str	r2, [r3, #40]	; 0x28
   12f34:	696a      	ldr	r2, [r5, #20]
   12f36:	62da      	str	r2, [r3, #44]	; 0x2c
   12f38:	69aa      	ldr	r2, [r5, #24]
   12f3a:	631a      	str	r2, [r3, #48]	; 0x30
   12f3c:	69ea      	ldr	r2, [r5, #28]
   12f3e:	635a      	str	r2, [r3, #52]	; 0x34
   12f40:	6a2a      	ldr	r2, [r5, #32]
   12f42:	639a      	str	r2, [r3, #56]	; 0x38
   12f44:	9800      	ldr	r0, [sp, #0]
   12f46:	712e      	strb	r6, [r5, #4]
   12f48:	f7ff fd18 	bl	1297c <am_hal_interrupt_master_set>
   12f4c:	4630      	mov	r0, r6
   12f4e:	e799      	b.n	12e84 <am_hal_uart_power_control+0x14>
   12f50:	01ea9e06 	.word	0x01ea9e06

00012f54 <am_hal_uart_configure>:
   12f54:	6803      	ldr	r3, [r0, #0]
   12f56:	4a7a      	ldr	r2, [pc, #488]	; (13140 <am_hal_uart_configure+0x1ec>)
   12f58:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   12f5c:	4293      	cmp	r3, r2
   12f5e:	d001      	beq.n	12f64 <am_hal_uart_configure+0x10>
   12f60:	2002      	movs	r0, #2
   12f62:	4770      	bx	lr
   12f64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   12f68:	6a45      	ldr	r5, [r0, #36]	; 0x24
   12f6a:	f505 2580 	add.w	r5, r5, #262144	; 0x40000
   12f6e:	351c      	adds	r5, #28
   12f70:	032d      	lsls	r5, r5, #12
   12f72:	2700      	movs	r7, #0
   12f74:	b084      	sub	sp, #16
   12f76:	632f      	str	r7, [r5, #48]	; 0x30
   12f78:	460e      	mov	r6, r1
   12f7a:	4604      	mov	r4, r0
   12f7c:	f7ff fcfa 	bl	12974 <am_hal_interrupt_master_disable>
   12f80:	9001      	str	r0, [sp, #4]
   12f82:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
   12f84:	f043 0308 	orr.w	r3, r3, #8
   12f88:	862b      	strh	r3, [r5, #48]	; 0x30
   12f8a:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
   12f8c:	2201      	movs	r2, #1
   12f8e:	f362 1306 	bfi	r3, r2, #4, #3
   12f92:	862b      	strh	r3, [r5, #48]	; 0x30
   12f94:	9801      	ldr	r0, [sp, #4]
   12f96:	f7ff fcf1 	bl	1297c <am_hal_interrupt_master_set>
   12f9a:	f7ff fceb 	bl	12974 <am_hal_interrupt_master_disable>
   12f9e:	9002      	str	r0, [sp, #8]
   12fa0:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
   12fa2:	f367 0300 	bfi	r3, r7, #0, #1
   12fa6:	862b      	strh	r3, [r5, #48]	; 0x30
   12fa8:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
   12faa:	f367 2349 	bfi	r3, r7, #9, #1
   12fae:	862b      	strh	r3, [r5, #48]	; 0x30
   12fb0:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
   12fb2:	f367 2308 	bfi	r3, r7, #8, #1
   12fb6:	862b      	strh	r3, [r5, #48]	; 0x30
   12fb8:	9802      	ldr	r0, [sp, #8]
   12fba:	f7ff fcdf 	bl	1297c <am_hal_interrupt_master_set>
   12fbe:	6b2b      	ldr	r3, [r5, #48]	; 0x30
   12fc0:	f3c3 1302 	ubfx	r3, r3, #4, #3
   12fc4:	3b01      	subs	r3, #1
   12fc6:	2b03      	cmp	r3, #3
   12fc8:	d854      	bhi.n	13074 <am_hal_uart_configure+0x120>
   12fca:	e8df f003 	tbb	[pc, r3]
   12fce:	020e      	.short	0x020e
   12fd0:	1114      	.short	0x1114
   12fd2:	495c      	ldr	r1, [pc, #368]	; (13144 <am_hal_uart_configure+0x1f0>)
   12fd4:	485c      	ldr	r0, [pc, #368]	; (13148 <am_hal_uart_configure+0x1f4>)
   12fd6:	6832      	ldr	r2, [r6, #0]
   12fd8:	0112      	lsls	r2, r2, #4
   12fda:	fbb0 f3f2 	udiv	r3, r0, r2
   12fde:	b96b      	cbnz	r3, 12ffc <am_hal_uart_configure+0xa8>
   12fe0:	485a      	ldr	r0, [pc, #360]	; (1314c <am_hal_uart_configure+0x1f8>)
   12fe2:	6623      	str	r3, [r4, #96]	; 0x60
   12fe4:	b004      	add	sp, #16
   12fe6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   12fea:	4959      	ldr	r1, [pc, #356]	; (13150 <am_hal_uart_configure+0x1fc>)
   12fec:	4859      	ldr	r0, [pc, #356]	; (13154 <am_hal_uart_configure+0x200>)
   12fee:	e7f2      	b.n	12fd6 <am_hal_uart_configure+0x82>
   12ff0:	4959      	ldr	r1, [pc, #356]	; (13158 <am_hal_uart_configure+0x204>)
   12ff2:	485a      	ldr	r0, [pc, #360]	; (1315c <am_hal_uart_configure+0x208>)
   12ff4:	e7ef      	b.n	12fd6 <am_hal_uart_configure+0x82>
   12ff6:	495a      	ldr	r1, [pc, #360]	; (13160 <am_hal_uart_configure+0x20c>)
   12ff8:	485a      	ldr	r0, [pc, #360]	; (13164 <am_hal_uart_configure+0x210>)
   12ffa:	e7ec      	b.n	12fd6 <am_hal_uart_configure+0x82>
   12ffc:	fbb1 f2f2 	udiv	r2, r1, r2
   13000:	eba2 1283 	sub.w	r2, r2, r3, lsl #6
   13004:	626b      	str	r3, [r5, #36]	; 0x24
   13006:	eb02 1103 	add.w	r1, r2, r3, lsl #4
   1300a:	626b      	str	r3, [r5, #36]	; 0x24
   1300c:	fbb0 f0f1 	udiv	r0, r0, r1
   13010:	62aa      	str	r2, [r5, #40]	; 0x28
   13012:	6620      	str	r0, [r4, #96]	; 0x60
   13014:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
   13016:	f36f 338e 	bfc	r3, #14, #1
   1301a:	862b      	strh	r3, [r5, #48]	; 0x30
   1301c:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
   1301e:	f36f 33cf 	bfc	r3, #15, #1
   13022:	862b      	strh	r3, [r5, #48]	; 0x30
   13024:	6b2a      	ldr	r2, [r5, #48]	; 0x30
   13026:	6933      	ldr	r3, [r6, #16]
   13028:	4313      	orrs	r3, r2
   1302a:	632b      	str	r3, [r5, #48]	; 0x30
   1302c:	6973      	ldr	r3, [r6, #20]
   1302e:	636b      	str	r3, [r5, #52]	; 0x34
   13030:	6871      	ldr	r1, [r6, #4]
   13032:	68b3      	ldr	r3, [r6, #8]
   13034:	68f2      	ldr	r2, [r6, #12]
   13036:	430b      	orrs	r3, r1
   13038:	f043 0310 	orr.w	r3, r3, #16
   1303c:	4313      	orrs	r3, r2
   1303e:	62eb      	str	r3, [r5, #44]	; 0x2c
   13040:	f7ff fc98 	bl	12974 <am_hal_interrupt_master_disable>
   13044:	9003      	str	r0, [sp, #12]
   13046:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
   13048:	f043 0301 	orr.w	r3, r3, #1
   1304c:	862b      	strh	r3, [r5, #48]	; 0x30
   1304e:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
   13050:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   13054:	862b      	strh	r3, [r5, #48]	; 0x30
   13056:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
   13058:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   1305c:	862b      	strh	r3, [r5, #48]	; 0x30
   1305e:	9803      	ldr	r0, [sp, #12]
   13060:	f7ff fc8c 	bl	1297c <am_hal_interrupt_master_set>
   13064:	6825      	ldr	r5, [r4, #0]
   13066:	4b36      	ldr	r3, [pc, #216]	; (13140 <am_hal_uart_configure+0x1ec>)
   13068:	f025 457e 	bic.w	r5, r5, #4261412864	; 0xfe000000
   1306c:	429d      	cmp	r5, r3
   1306e:	d005      	beq.n	1307c <am_hal_uart_configure+0x128>
   13070:	2000      	movs	r0, #0
   13072:	e7b7      	b.n	12fe4 <am_hal_uart_configure+0x90>
   13074:	2300      	movs	r3, #0
   13076:	6623      	str	r3, [r4, #96]	; 0x60
   13078:	483b      	ldr	r0, [pc, #236]	; (13168 <am_hal_uart_configure+0x214>)
   1307a:	e7b3      	b.n	12fe4 <am_hal_uart_configure+0x90>
   1307c:	69b1      	ldr	r1, [r6, #24]
   1307e:	6a37      	ldr	r7, [r6, #32]
   13080:	f8d6 8024 	ldr.w	r8, [r6, #36]	; 0x24
   13084:	b109      	cbz	r1, 1308a <am_hal_uart_configure+0x136>
   13086:	69f3      	ldr	r3, [r6, #28]
   13088:	bb3b      	cbnz	r3, 130da <am_hal_uart_configure+0x186>
   1308a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1308c:	f503 2380 	add.w	r3, r3, #262144	; 0x40000
   13090:	f103 021c 	add.w	r2, r3, #28
   13094:	0312      	lsls	r2, r2, #12
   13096:	2100      	movs	r1, #0
   13098:	f884 1028 	strb.w	r1, [r4, #40]	; 0x28
   1309c:	6b91      	ldr	r1, [r2, #56]	; 0x38
   1309e:	f021 0120 	bic.w	r1, r1, #32
   130a2:	6391      	str	r1, [r2, #56]	; 0x38
   130a4:	b1b7      	cbz	r7, 130d4 <am_hal_uart_configure+0x180>
   130a6:	f1b8 0f00 	cmp.w	r8, #0
   130aa:	d12e      	bne.n	1310a <am_hal_uart_configure+0x1b6>
   130ac:	6823      	ldr	r3, [r4, #0]
   130ae:	4a24      	ldr	r2, [pc, #144]	; (13140 <am_hal_uart_configure+0x1ec>)
   130b0:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   130b4:	2100      	movs	r1, #0
   130b6:	4293      	cmp	r3, r2
   130b8:	f884 1044 	strb.w	r1, [r4, #68]	; 0x44
   130bc:	d1d8      	bne.n	13070 <am_hal_uart_configure+0x11c>
   130be:	6a63      	ldr	r3, [r4, #36]	; 0x24
   130c0:	f503 2380 	add.w	r3, r3, #262144	; 0x40000
   130c4:	331c      	adds	r3, #28
   130c6:	031b      	lsls	r3, r3, #12
   130c8:	2000      	movs	r0, #0
   130ca:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   130cc:	f022 0250 	bic.w	r2, r2, #80	; 0x50
   130d0:	639a      	str	r2, [r3, #56]	; 0x38
   130d2:	e787      	b.n	12fe4 <am_hal_uart_configure+0x90>
   130d4:	f884 7044 	strb.w	r7, [r4, #68]	; 0x44
   130d8:	e7f4      	b.n	130c4 <am_hal_uart_configure+0x170>
   130da:	2201      	movs	r2, #1
   130dc:	f884 2028 	strb.w	r2, [r4, #40]	; 0x28
   130e0:	f104 002c 	add.w	r0, r4, #44	; 0x2c
   130e4:	f000 fa7c 	bl	135e0 <am_hal_queue_init>
   130e8:	6823      	ldr	r3, [r4, #0]
   130ea:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   130ee:	42ab      	cmp	r3, r5
   130f0:	d1be      	bne.n	13070 <am_hal_uart_configure+0x11c>
   130f2:	6a63      	ldr	r3, [r4, #36]	; 0x24
   130f4:	f503 2380 	add.w	r3, r3, #262144	; 0x40000
   130f8:	331c      	adds	r3, #28
   130fa:	031b      	lsls	r3, r3, #12
   130fc:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   130fe:	f042 0220 	orr.w	r2, r2, #32
   13102:	639a      	str	r2, [r3, #56]	; 0x38
   13104:	2f00      	cmp	r7, #0
   13106:	d1ce      	bne.n	130a6 <am_hal_uart_configure+0x152>
   13108:	e7d0      	b.n	130ac <am_hal_uart_configure+0x158>
   1310a:	2201      	movs	r2, #1
   1310c:	4643      	mov	r3, r8
   1310e:	f884 2044 	strb.w	r2, [r4, #68]	; 0x44
   13112:	4639      	mov	r1, r7
   13114:	f104 0048 	add.w	r0, r4, #72	; 0x48
   13118:	f000 fa62 	bl	135e0 <am_hal_queue_init>
   1311c:	6823      	ldr	r3, [r4, #0]
   1311e:	4a08      	ldr	r2, [pc, #32]	; (13140 <am_hal_uart_configure+0x1ec>)
   13120:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   13124:	4293      	cmp	r3, r2
   13126:	d1a3      	bne.n	13070 <am_hal_uart_configure+0x11c>
   13128:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1312a:	f503 2380 	add.w	r3, r3, #262144	; 0x40000
   1312e:	331c      	adds	r3, #28
   13130:	031b      	lsls	r3, r3, #12
   13132:	2000      	movs	r0, #0
   13134:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   13136:	f042 0250 	orr.w	r2, r2, #80	; 0x50
   1313a:	639a      	str	r2, [r3, #56]	; 0x38
   1313c:	e752      	b.n	12fe4 <am_hal_uart_configure+0x90>
   1313e:	bf00      	nop
   13140:	01ea9e06 	.word	0x01ea9e06
   13144:	2dc6c000 	.word	0x2dc6c000
   13148:	00b71b00 	.word	0x00b71b00
   1314c:	08000003 	.word	0x08000003
   13150:	5b8d8000 	.word	0x5b8d8000
   13154:	016e3600 	.word	0x016e3600
   13158:	0b71b000 	.word	0x0b71b000
   1315c:	002dc6c0 	.word	0x002dc6c0
   13160:	16e36000 	.word	0x16e36000
   13164:	005b8d80 	.word	0x005b8d80
   13168:	08000002 	.word	0x08000002

0001316c <am_hal_uart_transfer>:
   1316c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13170:	680f      	ldr	r7, [r1, #0]
   13172:	b091      	sub	sp, #68	; 0x44
   13174:	4605      	mov	r5, r0
   13176:	b13f      	cbz	r7, 13188 <am_hal_uart_transfer+0x1c>
   13178:	2f01      	cmp	r7, #1
   1317a:	bf18      	it	ne
   1317c:	2707      	movne	r7, #7
   1317e:	d024      	beq.n	131ca <am_hal_uart_transfer+0x5e>
   13180:	4638      	mov	r0, r7
   13182:	b011      	add	sp, #68	; 0x44
   13184:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13188:	f8d1 900c 	ldr.w	r9, [r1, #12]
   1318c:	690b      	ldr	r3, [r1, #16]
   1318e:	f8d1 a004 	ldr.w	sl, [r1, #4]
   13192:	688e      	ldr	r6, [r1, #8]
   13194:	9300      	str	r3, [sp, #0]
   13196:	f1b9 0f00 	cmp.w	r9, #0
   1319a:	d031      	beq.n	13200 <am_hal_uart_transfer+0x94>
   1319c:	2e00      	cmp	r6, #0
   1319e:	f000 819c 	beq.w	134da <am_hal_uart_transfer+0x36e>
   131a2:	2800      	cmp	r0, #0
   131a4:	f000 8097 	beq.w	132d6 <am_hal_uart_transfer+0x16a>
   131a8:	6803      	ldr	r3, [r0, #0]
   131aa:	4aa9      	ldr	r2, [pc, #676]	; (13450 <am_hal_uart_transfer+0x2e4>)
   131ac:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   131b0:	4293      	cmp	r3, r2
   131b2:	f000 8092 	beq.w	132da <am_hal_uart_transfer+0x16e>
   131b6:	46b8      	mov	r8, r7
   131b8:	9b00      	ldr	r3, [sp, #0]
   131ba:	b10b      	cbz	r3, 131c0 <am_hal_uart_transfer+0x54>
   131bc:	f8c3 8000 	str.w	r8, [r3]
   131c0:	2702      	movs	r7, #2
   131c2:	4638      	mov	r0, r7
   131c4:	b011      	add	sp, #68	; 0x44
   131c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   131ca:	1d0b      	adds	r3, r1, #4
   131cc:	e893 0a88 	ldmia.w	r3, {r3, r7, r9, fp}
   131d0:	f1b9 0f00 	cmp.w	r9, #0
   131d4:	d043      	beq.n	1325e <am_hal_uart_transfer+0xf2>
   131d6:	2f00      	cmp	r7, #0
   131d8:	f000 8185 	beq.w	134e6 <am_hal_uart_transfer+0x37a>
   131dc:	2800      	cmp	r0, #0
   131de:	f000 80eb 	beq.w	133b8 <am_hal_uart_transfer+0x24c>
   131e2:	6802      	ldr	r2, [r0, #0]
   131e4:	499a      	ldr	r1, [pc, #616]	; (13450 <am_hal_uart_transfer+0x2e4>)
   131e6:	f022 427e 	bic.w	r2, r2, #4261412864	; 0xfe000000
   131ea:	428a      	cmp	r2, r1
   131ec:	f000 80e7 	beq.w	133be <am_hal_uart_transfer+0x252>
   131f0:	2600      	movs	r6, #0
   131f2:	2702      	movs	r7, #2
   131f4:	f1bb 0f00 	cmp.w	fp, #0
   131f8:	d0c2      	beq.n	13180 <am_hal_uart_transfer+0x14>
   131fa:	f8cb 6000 	str.w	r6, [fp]
   131fe:	e7bf      	b.n	13180 <am_hal_uart_transfer+0x14>
   13200:	2800      	cmp	r0, #0
   13202:	d0dd      	beq.n	131c0 <am_hal_uart_transfer+0x54>
   13204:	6803      	ldr	r3, [r0, #0]
   13206:	4a92      	ldr	r2, [pc, #584]	; (13450 <am_hal_uart_transfer+0x2e4>)
   13208:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   1320c:	4293      	cmp	r3, r2
   1320e:	d1d7      	bne.n	131c0 <am_hal_uart_transfer+0x54>
   13210:	9b00      	ldr	r3, [sp, #0]
   13212:	b10b      	cbz	r3, 13218 <am_hal_uart_transfer+0xac>
   13214:	f8c3 9000 	str.w	r9, [r3]
   13218:	b1fe      	cbz	r6, 1325a <am_hal_uart_transfer+0xee>
   1321a:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
   1321e:	2b00      	cmp	r3, #0
   13220:	f040 8165 	bne.w	134ee <am_hal_uart_transfer+0x382>
   13224:	6a69      	ldr	r1, [r5, #36]	; 0x24
   13226:	f501 2180 	add.w	r1, r1, #262144	; 0x40000
   1322a:	311c      	adds	r1, #28
   1322c:	0309      	lsls	r1, r1, #12
   1322e:	698a      	ldr	r2, [r1, #24]
   13230:	f3c2 1240 	ubfx	r2, r2, #5, #1
   13234:	2a00      	cmp	r2, #0
   13236:	f040 818d 	bne.w	13554 <am_hal_uart_transfer+0x3e8>
   1323a:	f10a 33ff 	add.w	r3, sl, #4294967295	; 0xffffffff
   1323e:	e003      	b.n	13248 <am_hal_uart_transfer+0xdc>
   13240:	6988      	ldr	r0, [r1, #24]
   13242:	0680      	lsls	r0, r0, #26
   13244:	f100 8151 	bmi.w	134ea <am_hal_uart_transfer+0x37e>
   13248:	3201      	adds	r2, #1
   1324a:	f813 0f01 	ldrb.w	r0, [r3, #1]!
   1324e:	6008      	str	r0, [r1, #0]
   13250:	4296      	cmp	r6, r2
   13252:	d1f5      	bne.n	13240 <am_hal_uart_transfer+0xd4>
   13254:	9b00      	ldr	r3, [sp, #0]
   13256:	b103      	cbz	r3, 1325a <am_hal_uart_transfer+0xee>
   13258:	601e      	str	r6, [r3, #0]
   1325a:	2700      	movs	r7, #0
   1325c:	e790      	b.n	13180 <am_hal_uart_transfer+0x14>
   1325e:	2800      	cmp	r0, #0
   13260:	d0ae      	beq.n	131c0 <am_hal_uart_transfer+0x54>
   13262:	6802      	ldr	r2, [r0, #0]
   13264:	497a      	ldr	r1, [pc, #488]	; (13450 <am_hal_uart_transfer+0x2e4>)
   13266:	f022 427e 	bic.w	r2, r2, #4261412864	; 0xfe000000
   1326a:	428a      	cmp	r2, r1
   1326c:	d1a8      	bne.n	131c0 <am_hal_uart_transfer+0x54>
   1326e:	f1bb 0f00 	cmp.w	fp, #0
   13272:	d001      	beq.n	13278 <am_hal_uart_transfer+0x10c>
   13274:	f8cb 9000 	str.w	r9, [fp]
   13278:	2f00      	cmp	r7, #0
   1327a:	d0ee      	beq.n	1325a <am_hal_uart_transfer+0xee>
   1327c:	f895 4044 	ldrb.w	r4, [r5, #68]	; 0x44
   13280:	2c00      	cmp	r4, #0
   13282:	f040 816c 	bne.w	1355e <am_hal_uart_transfer+0x3f2>
   13286:	6a6a      	ldr	r2, [r5, #36]	; 0x24
   13288:	f502 2280 	add.w	r2, r2, #262144	; 0x40000
   1328c:	321c      	adds	r2, #28
   1328e:	0312      	lsls	r2, r2, #12
   13290:	6990      	ldr	r0, [r2, #24]
   13292:	f3c0 1000 	ubfx	r0, r0, #4, #1
   13296:	2800      	cmp	r0, #0
   13298:	f040 819d 	bne.w	135d6 <am_hal_uart_transfer+0x46a>
   1329c:	6811      	ldr	r1, [r2, #0]
   1329e:	f411 6470 	ands.w	r4, r1, #3840	; 0xf00
   132a2:	bf08      	it	eq
   132a4:	f103 33ff 	addeq.w	r3, r3, #4294967295	; 0xffffffff
   132a8:	d008      	beq.n	132bc <am_hal_uart_transfer+0x150>
   132aa:	e190      	b.n	135ce <am_hal_uart_transfer+0x462>
   132ac:	6991      	ldr	r1, [r2, #24]
   132ae:	06c8      	lsls	r0, r1, #27
   132b0:	d409      	bmi.n	132c6 <am_hal_uart_transfer+0x15a>
   132b2:	6811      	ldr	r1, [r2, #0]
   132b4:	f411 6f70 	tst.w	r1, #3840	; 0xf00
   132b8:	f040 814e 	bne.w	13558 <am_hal_uart_transfer+0x3ec>
   132bc:	3401      	adds	r4, #1
   132be:	42a7      	cmp	r7, r4
   132c0:	f803 1f01 	strb.w	r1, [r3, #1]!
   132c4:	d1f2      	bne.n	132ac <am_hal_uart_transfer+0x140>
   132c6:	2700      	movs	r7, #0
   132c8:	f1bb 0f00 	cmp.w	fp, #0
   132cc:	f43f af58 	beq.w	13180 <am_hal_uart_transfer+0x14>
   132d0:	f8cb 4000 	str.w	r4, [fp]
   132d4:	e754      	b.n	13180 <am_hal_uart_transfer+0x14>
   132d6:	4680      	mov	r8, r0
   132d8:	e76e      	b.n	131b8 <am_hal_uart_transfer+0x4c>
   132da:	9301      	str	r3, [sp, #4]
   132dc:	4651      	mov	r1, sl
   132de:	46bb      	mov	fp, r7
   132e0:	46b8      	mov	r8, r7
   132e2:	f895 2028 	ldrb.w	r2, [r5, #40]	; 0x28
   132e6:	b9f2      	cbnz	r2, 13326 <am_hal_uart_transfer+0x1ba>
   132e8:	6a6a      	ldr	r2, [r5, #36]	; 0x24
   132ea:	b19e      	cbz	r6, 13314 <am_hal_uart_transfer+0x1a8>
   132ec:	f502 2280 	add.w	r2, r2, #262144	; 0x40000
   132f0:	321c      	adds	r2, #28
   132f2:	0312      	lsls	r2, r2, #12
   132f4:	3901      	subs	r1, #1
   132f6:	6994      	ldr	r4, [r2, #24]
   132f8:	f3c4 1440 	ubfx	r4, r4, #5, #1
   132fc:	b11c      	cbz	r4, 13306 <am_hal_uart_transfer+0x19a>
   132fe:	e047      	b.n	13390 <am_hal_uart_transfer+0x224>
   13300:	6993      	ldr	r3, [r2, #24]
   13302:	069b      	lsls	r3, r3, #26
   13304:	d441      	bmi.n	1338a <am_hal_uart_transfer+0x21e>
   13306:	3401      	adds	r4, #1
   13308:	f811 3f01 	ldrb.w	r3, [r1, #1]!
   1330c:	6013      	str	r3, [r2, #0]
   1330e:	42b4      	cmp	r4, r6
   13310:	d1f6      	bne.n	13300 <am_hal_uart_transfer+0x194>
   13312:	44a0      	add	r8, r4
   13314:	9b00      	ldr	r3, [sp, #0]
   13316:	2b00      	cmp	r3, #0
   13318:	d09f      	beq.n	1325a <am_hal_uart_transfer+0xee>
   1331a:	4638      	mov	r0, r7
   1331c:	f8c3 8000 	str.w	r8, [r3]
   13320:	b011      	add	sp, #68	; 0x44
   13322:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13326:	6baa      	ldr	r2, [r5, #56]	; 0x38
   13328:	6b6c      	ldr	r4, [r5, #52]	; 0x34
   1332a:	1b14      	subs	r4, r2, r4
   1332c:	42b4      	cmp	r4, r6
   1332e:	f105 032c 	add.w	r3, r5, #44	; 0x2c
   13332:	bf28      	it	cs
   13334:	4634      	movcs	r4, r6
   13336:	4622      	mov	r2, r4
   13338:	4618      	mov	r0, r3
   1333a:	9302      	str	r3, [sp, #8]
   1333c:	f000 f95c 	bl	135f8 <am_hal_queue_item_add>
   13340:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   13342:	9303      	str	r3, [sp, #12]
   13344:	f7ff fb16 	bl	12974 <am_hal_interrupt_master_disable>
   13348:	9b03      	ldr	r3, [sp, #12]
   1334a:	9008      	str	r0, [sp, #32]
   1334c:	f503 2380 	add.w	r3, r3, #262144	; 0x40000
   13350:	331c      	adds	r3, #28
   13352:	031b      	lsls	r3, r3, #12
   13354:	9303      	str	r3, [sp, #12]
   13356:	e00d      	b.n	13374 <am_hal_uart_transfer+0x208>
   13358:	f000 f986 	bl	13668 <am_hal_queue_item_get>
   1335c:	b190      	cbz	r0, 13384 <am_hal_uart_transfer+0x218>
   1335e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   13360:	f503 2380 	add.w	r3, r3, #262144	; 0x40000
   13364:	331c      	adds	r3, #28
   13366:	031b      	lsls	r3, r3, #12
   13368:	699a      	ldr	r2, [r3, #24]
   1336a:	0692      	lsls	r2, r2, #26
   1336c:	bf5c      	itt	pl
   1336e:	f89d 201c 	ldrbpl.w	r2, [sp, #28]
   13372:	601a      	strpl	r2, [r3, #0]
   13374:	9b03      	ldr	r3, [sp, #12]
   13376:	9802      	ldr	r0, [sp, #8]
   13378:	699b      	ldr	r3, [r3, #24]
   1337a:	069b      	lsls	r3, r3, #26
   1337c:	f04f 0201 	mov.w	r2, #1
   13380:	a907      	add	r1, sp, #28
   13382:	d5e9      	bpl.n	13358 <am_hal_uart_transfer+0x1ec>
   13384:	9808      	ldr	r0, [sp, #32]
   13386:	f7ff faf9 	bl	1297c <am_hal_interrupt_master_set>
   1338a:	1b36      	subs	r6, r6, r4
   1338c:	44a0      	add	r8, r4
   1338e:	d0c1      	beq.n	13314 <am_hal_uart_transfer+0x1a8>
   13390:	2001      	movs	r0, #1
   13392:	f7ff fabb 	bl	1290c <am_hal_flash_delay>
   13396:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
   1339a:	d001      	beq.n	133a0 <am_hal_uart_transfer+0x234>
   1339c:	f10b 0b01 	add.w	fp, fp, #1
   133a0:	45d9      	cmp	r9, fp
   133a2:	d9b7      	bls.n	13314 <am_hal_uart_transfer+0x1a8>
   133a4:	682a      	ldr	r2, [r5, #0]
   133a6:	9b01      	ldr	r3, [sp, #4]
   133a8:	f022 427e 	bic.w	r2, r2, #4261412864	; 0xfe000000
   133ac:	429a      	cmp	r2, r3
   133ae:	eb0a 0108 	add.w	r1, sl, r8
   133b2:	f47f af01 	bne.w	131b8 <am_hal_uart_transfer+0x4c>
   133b6:	e794      	b.n	132e2 <am_hal_uart_transfer+0x176>
   133b8:	4606      	mov	r6, r0
   133ba:	2702      	movs	r7, #2
   133bc:	e71a      	b.n	131f4 <am_hal_uart_transfer+0x88>
   133be:	9200      	str	r2, [sp, #0]
   133c0:	f100 0248 	add.w	r2, r0, #72	; 0x48
   133c4:	f04f 0a00 	mov.w	sl, #0
   133c8:	9202      	str	r2, [sp, #8]
   133ca:	465a      	mov	r2, fp
   133cc:	4698      	mov	r8, r3
   133ce:	469b      	mov	fp, r3
   133d0:	4656      	mov	r6, sl
   133d2:	4613      	mov	r3, r2
   133d4:	f895 2044 	ldrb.w	r2, [r5, #68]	; 0x44
   133d8:	2a00      	cmp	r2, #0
   133da:	d152      	bne.n	13482 <am_hal_uart_transfer+0x316>
   133dc:	6a69      	ldr	r1, [r5, #36]	; 0x24
   133de:	b3a7      	cbz	r7, 1344a <am_hal_uart_transfer+0x2de>
   133e0:	f501 2180 	add.w	r1, r1, #262144	; 0x40000
   133e4:	311c      	adds	r1, #28
   133e6:	0309      	lsls	r1, r1, #12
   133e8:	698a      	ldr	r2, [r1, #24]
   133ea:	06d0      	lsls	r0, r2, #27
   133ec:	d432      	bmi.n	13454 <am_hal_uart_transfer+0x2e8>
   133ee:	680a      	ldr	r2, [r1, #0]
   133f0:	f412 6470 	ands.w	r4, r2, #3840	; 0xf00
   133f4:	f040 80aa 	bne.w	1354c <am_hal_uart_transfer+0x3e0>
   133f8:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
   133fc:	e006      	b.n	1340c <am_hal_uart_transfer+0x2a0>
   133fe:	698a      	ldr	r2, [r1, #24]
   13400:	06d2      	lsls	r2, r2, #27
   13402:	d41f      	bmi.n	13444 <am_hal_uart_transfer+0x2d8>
   13404:	680a      	ldr	r2, [r1, #0]
   13406:	f412 6f70 	tst.w	r2, #3840	; 0xf00
   1340a:	d161      	bne.n	134d0 <am_hal_uart_transfer+0x364>
   1340c:	3401      	adds	r4, #1
   1340e:	42bc      	cmp	r4, r7
   13410:	f808 2f01 	strb.w	r2, [r8, #1]!
   13414:	d1f3      	bne.n	133fe <am_hal_uart_transfer+0x292>
   13416:	469b      	mov	fp, r3
   13418:	4426      	add	r6, r4
   1341a:	f1bb 0f00 	cmp.w	fp, #0
   1341e:	f43f af1c 	beq.w	1325a <am_hal_uart_transfer+0xee>
   13422:	f8cb 6000 	str.w	r6, [fp]
   13426:	2700      	movs	r7, #0
   13428:	e6aa      	b.n	13180 <am_hal_uart_transfer+0x14>
   1342a:	9807      	ldr	r0, [sp, #28]
   1342c:	f7ff faa6 	bl	1297c <am_hal_interrupt_master_set>
   13430:	6d2c      	ldr	r4, [r5, #80]	; 0x50
   13432:	9802      	ldr	r0, [sp, #8]
   13434:	42bc      	cmp	r4, r7
   13436:	bf28      	it	cs
   13438:	463c      	movcs	r4, r7
   1343a:	4641      	mov	r1, r8
   1343c:	4622      	mov	r2, r4
   1343e:	f000 f913 	bl	13668 <am_hal_queue_item_get>
   13442:	9b01      	ldr	r3, [sp, #4]
   13444:	1b3f      	subs	r7, r7, r4
   13446:	4426      	add	r6, r4
   13448:	d104      	bne.n	13454 <am_hal_uart_transfer+0x2e8>
   1344a:	469b      	mov	fp, r3
   1344c:	e7e5      	b.n	1341a <am_hal_uart_transfer+0x2ae>
   1344e:	bf00      	nop
   13450:	01ea9e06 	.word	0x01ea9e06
   13454:	2001      	movs	r0, #1
   13456:	9301      	str	r3, [sp, #4]
   13458:	f7ff fa58 	bl	1290c <am_hal_flash_delay>
   1345c:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
   13460:	9b01      	ldr	r3, [sp, #4]
   13462:	d001      	beq.n	13468 <am_hal_uart_transfer+0x2fc>
   13464:	f10a 0a01 	add.w	sl, sl, #1
   13468:	45d1      	cmp	r9, sl
   1346a:	d9ee      	bls.n	1344a <am_hal_uart_transfer+0x2de>
   1346c:	682a      	ldr	r2, [r5, #0]
   1346e:	9900      	ldr	r1, [sp, #0]
   13470:	f022 427e 	bic.w	r2, r2, #4261412864	; 0xfe000000
   13474:	428a      	cmp	r2, r1
   13476:	eb0b 0806 	add.w	r8, fp, r6
   1347a:	d0ab      	beq.n	133d4 <am_hal_uart_transfer+0x268>
   1347c:	469b      	mov	fp, r3
   1347e:	2702      	movs	r7, #2
   13480:	e6b8      	b.n	131f4 <am_hal_uart_transfer+0x88>
   13482:	9301      	str	r3, [sp, #4]
   13484:	f7ff fa76 	bl	12974 <am_hal_interrupt_master_disable>
   13488:	6a6a      	ldr	r2, [r5, #36]	; 0x24
   1348a:	9007      	str	r0, [sp, #28]
   1348c:	f502 2080 	add.w	r0, r2, #262144	; 0x40000
   13490:	301c      	adds	r0, #28
   13492:	9b01      	ldr	r3, [sp, #4]
   13494:	0300      	lsls	r0, r0, #12
   13496:	ac08      	add	r4, sp, #32
   13498:	2200      	movs	r2, #0
   1349a:	6981      	ldr	r1, [r0, #24]
   1349c:	06c9      	lsls	r1, r1, #27
   1349e:	d409      	bmi.n	134b4 <am_hal_uart_transfer+0x348>
   134a0:	6801      	ldr	r1, [r0, #0]
   134a2:	f411 6f70 	tst.w	r1, #3840	; 0xf00
   134a6:	f102 0201 	add.w	r2, r2, #1
   134aa:	d118      	bne.n	134de <am_hal_uart_transfer+0x372>
   134ac:	2a20      	cmp	r2, #32
   134ae:	f804 1b01 	strb.w	r1, [r4], #1
   134b2:	d1f2      	bne.n	1349a <am_hal_uart_transfer+0x32e>
   134b4:	a908      	add	r1, sp, #32
   134b6:	9802      	ldr	r0, [sp, #8]
   134b8:	9301      	str	r3, [sp, #4]
   134ba:	f000 f89d 	bl	135f8 <am_hal_queue_item_add>
   134be:	9b01      	ldr	r3, [sp, #4]
   134c0:	2800      	cmp	r0, #0
   134c2:	d1b2      	bne.n	1342a <am_hal_uart_transfer+0x2be>
   134c4:	4f45      	ldr	r7, [pc, #276]	; (135dc <am_hal_uart_transfer+0x470>)
   134c6:	469b      	mov	fp, r3
   134c8:	9807      	ldr	r0, [sp, #28]
   134ca:	f7ff fa57 	bl	1297c <am_hal_interrupt_master_set>
   134ce:	e691      	b.n	131f4 <am_hal_uart_transfer+0x88>
   134d0:	469b      	mov	fp, r3
   134d2:	4426      	add	r6, r4
   134d4:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
   134d8:	e68c      	b.n	131f4 <am_hal_uart_transfer+0x88>
   134da:	46b8      	mov	r8, r7
   134dc:	e71a      	b.n	13314 <am_hal_uart_transfer+0x1a8>
   134de:	469b      	mov	fp, r3
   134e0:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
   134e4:	e7f0      	b.n	134c8 <am_hal_uart_transfer+0x35c>
   134e6:	463e      	mov	r6, r7
   134e8:	e797      	b.n	1341a <am_hal_uart_transfer+0x2ae>
   134ea:	4616      	mov	r6, r2
   134ec:	e6b2      	b.n	13254 <am_hal_uart_transfer+0xe8>
   134ee:	6b6a      	ldr	r2, [r5, #52]	; 0x34
   134f0:	6bab      	ldr	r3, [r5, #56]	; 0x38
   134f2:	1a9b      	subs	r3, r3, r2
   134f4:	429e      	cmp	r6, r3
   134f6:	bf28      	it	cs
   134f8:	461e      	movcs	r6, r3
   134fa:	f105 042c 	add.w	r4, r5, #44	; 0x2c
   134fe:	4651      	mov	r1, sl
   13500:	4632      	mov	r2, r6
   13502:	4620      	mov	r0, r4
   13504:	f000 f878 	bl	135f8 <am_hal_queue_item_add>
   13508:	6a6f      	ldr	r7, [r5, #36]	; 0x24
   1350a:	f7ff fa33 	bl	12974 <am_hal_interrupt_master_disable>
   1350e:	f507 2780 	add.w	r7, r7, #262144	; 0x40000
   13512:	371c      	adds	r7, #28
   13514:	033f      	lsls	r7, r7, #12
   13516:	9005      	str	r0, [sp, #20]
   13518:	e00d      	b.n	13536 <am_hal_uart_transfer+0x3ca>
   1351a:	f000 f8a5 	bl	13668 <am_hal_queue_item_get>
   1351e:	b188      	cbz	r0, 13544 <am_hal_uart_transfer+0x3d8>
   13520:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   13522:	f503 2380 	add.w	r3, r3, #262144	; 0x40000
   13526:	331c      	adds	r3, #28
   13528:	031b      	lsls	r3, r3, #12
   1352a:	699a      	ldr	r2, [r3, #24]
   1352c:	0692      	lsls	r2, r2, #26
   1352e:	bf5c      	itt	pl
   13530:	f89d 2020 	ldrbpl.w	r2, [sp, #32]
   13534:	601a      	strpl	r2, [r3, #0]
   13536:	69bb      	ldr	r3, [r7, #24]
   13538:	069b      	lsls	r3, r3, #26
   1353a:	f04f 0201 	mov.w	r2, #1
   1353e:	a908      	add	r1, sp, #32
   13540:	4620      	mov	r0, r4
   13542:	d5ea      	bpl.n	1351a <am_hal_uart_transfer+0x3ae>
   13544:	9805      	ldr	r0, [sp, #20]
   13546:	f7ff fa19 	bl	1297c <am_hal_interrupt_master_set>
   1354a:	e683      	b.n	13254 <am_hal_uart_transfer+0xe8>
   1354c:	469b      	mov	fp, r3
   1354e:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
   13552:	e64f      	b.n	131f4 <am_hal_uart_transfer+0x88>
   13554:	461e      	mov	r6, r3
   13556:	e67d      	b.n	13254 <am_hal_uart_transfer+0xe8>
   13558:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
   1355c:	e6b4      	b.n	132c8 <am_hal_uart_transfer+0x15c>
   1355e:	9300      	str	r3, [sp, #0]
   13560:	f7ff fa08 	bl	12974 <am_hal_interrupt_master_disable>
   13564:	6a6a      	ldr	r2, [r5, #36]	; 0x24
   13566:	9006      	str	r0, [sp, #24]
   13568:	f502 2280 	add.w	r2, r2, #262144	; 0x40000
   1356c:	321c      	adds	r2, #28
   1356e:	0311      	lsls	r1, r2, #12
   13570:	a808      	add	r0, sp, #32
   13572:	2200      	movs	r2, #0
   13574:	9b00      	ldr	r3, [sp, #0]
   13576:	e009      	b.n	1358c <am_hal_uart_transfer+0x420>
   13578:	680c      	ldr	r4, [r1, #0]
   1357a:	f414 6f70 	tst.w	r4, #3840	; 0xf00
   1357e:	f102 0201 	add.w	r2, r2, #1
   13582:	d121      	bne.n	135c8 <am_hal_uart_transfer+0x45c>
   13584:	2a20      	cmp	r2, #32
   13586:	f800 4b01 	strb.w	r4, [r0], #1
   1358a:	d002      	beq.n	13592 <am_hal_uart_transfer+0x426>
   1358c:	698c      	ldr	r4, [r1, #24]
   1358e:	06e4      	lsls	r4, r4, #27
   13590:	d5f2      	bpl.n	13578 <am_hal_uart_transfer+0x40c>
   13592:	f105 0648 	add.w	r6, r5, #72	; 0x48
   13596:	a908      	add	r1, sp, #32
   13598:	4630      	mov	r0, r6
   1359a:	9300      	str	r3, [sp, #0]
   1359c:	f000 f82c 	bl	135f8 <am_hal_queue_item_add>
   135a0:	b920      	cbnz	r0, 135ac <am_hal_uart_transfer+0x440>
   135a2:	4f0e      	ldr	r7, [pc, #56]	; (135dc <am_hal_uart_transfer+0x470>)
   135a4:	9806      	ldr	r0, [sp, #24]
   135a6:	f7ff f9e9 	bl	1297c <am_hal_interrupt_master_set>
   135aa:	e5e9      	b.n	13180 <am_hal_uart_transfer+0x14>
   135ac:	9806      	ldr	r0, [sp, #24]
   135ae:	f7ff f9e5 	bl	1297c <am_hal_interrupt_master_set>
   135b2:	6d2c      	ldr	r4, [r5, #80]	; 0x50
   135b4:	9b00      	ldr	r3, [sp, #0]
   135b6:	42bc      	cmp	r4, r7
   135b8:	bf28      	it	cs
   135ba:	463c      	movcs	r4, r7
   135bc:	4619      	mov	r1, r3
   135be:	4630      	mov	r0, r6
   135c0:	4622      	mov	r2, r4
   135c2:	f000 f851 	bl	13668 <am_hal_queue_item_get>
   135c6:	e67e      	b.n	132c6 <am_hal_uart_transfer+0x15a>
   135c8:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
   135cc:	e7ea      	b.n	135a4 <am_hal_uart_transfer+0x438>
   135ce:	4604      	mov	r4, r0
   135d0:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
   135d4:	e678      	b.n	132c8 <am_hal_uart_transfer+0x15c>
   135d6:	4627      	mov	r7, r4
   135d8:	e676      	b.n	132c8 <am_hal_uart_transfer+0x15c>
   135da:	bf00      	nop
   135dc:	08000001 	.word	0x08000001

000135e0 <am_hal_queue_init>:
   135e0:	b410      	push	{r4}
   135e2:	2400      	movs	r4, #0
   135e4:	6004      	str	r4, [r0, #0]
   135e6:	6044      	str	r4, [r0, #4]
   135e8:	6084      	str	r4, [r0, #8]
   135ea:	60c3      	str	r3, [r0, #12]
   135ec:	6102      	str	r2, [r0, #16]
   135ee:	6141      	str	r1, [r0, #20]
   135f0:	f85d 4b04 	ldr.w	r4, [sp], #4
   135f4:	4770      	bx	lr
   135f6:	bf00      	nop

000135f8 <am_hal_queue_item_add>:
   135f8:	b5f0      	push	{r4, r5, r6, r7, lr}
   135fa:	4604      	mov	r4, r0
   135fc:	6906      	ldr	r6, [r0, #16]
   135fe:	b083      	sub	sp, #12
   13600:	fb06 f602 	mul.w	r6, r6, r2
   13604:	460d      	mov	r5, r1
   13606:	f7ff f9b5 	bl	12974 <am_hal_interrupt_master_disable>
   1360a:	68e7      	ldr	r7, [r4, #12]
   1360c:	68a2      	ldr	r2, [r4, #8]
   1360e:	9001      	str	r0, [sp, #4]
   13610:	1abb      	subs	r3, r7, r2
   13612:	429e      	cmp	r6, r3
   13614:	d826      	bhi.n	13664 <am_hal_queue_item_add+0x6c>
   13616:	b196      	cbz	r6, 1363e <am_hal_queue_item_add+0x46>
   13618:	6823      	ldr	r3, [r4, #0]
   1361a:	4629      	mov	r1, r5
   1361c:	b1c5      	cbz	r5, 13650 <am_hal_queue_item_add+0x58>
   1361e:	19af      	adds	r7, r5, r6
   13620:	6962      	ldr	r2, [r4, #20]
   13622:	f811 0b01 	ldrb.w	r0, [r1], #1
   13626:	54d0      	strb	r0, [r2, r3]
   13628:	6823      	ldr	r3, [r4, #0]
   1362a:	68e5      	ldr	r5, [r4, #12]
   1362c:	3301      	adds	r3, #1
   1362e:	42b9      	cmp	r1, r7
   13630:	fbb3 f0f5 	udiv	r0, r3, r5
   13634:	fb05 3310 	mls	r3, r5, r0, r3
   13638:	6023      	str	r3, [r4, #0]
   1363a:	d1f1      	bne.n	13620 <am_hal_queue_item_add+0x28>
   1363c:	68a2      	ldr	r2, [r4, #8]
   1363e:	4432      	add	r2, r6
   13640:	60a2      	str	r2, [r4, #8]
   13642:	2401      	movs	r4, #1
   13644:	9801      	ldr	r0, [sp, #4]
   13646:	f7ff f999 	bl	1297c <am_hal_interrupt_master_set>
   1364a:	4620      	mov	r0, r4
   1364c:	b003      	add	sp, #12
   1364e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   13650:	3101      	adds	r1, #1
   13652:	3301      	adds	r3, #1
   13654:	428e      	cmp	r6, r1
   13656:	fbb3 f0f7 	udiv	r0, r3, r7
   1365a:	fb07 3310 	mls	r3, r7, r0, r3
   1365e:	d1f7      	bne.n	13650 <am_hal_queue_item_add+0x58>
   13660:	6023      	str	r3, [r4, #0]
   13662:	e7ec      	b.n	1363e <am_hal_queue_item_add+0x46>
   13664:	2400      	movs	r4, #0
   13666:	e7ed      	b.n	13644 <am_hal_queue_item_add+0x4c>

00013668 <am_hal_queue_item_get>:
   13668:	b5f0      	push	{r4, r5, r6, r7, lr}
   1366a:	4604      	mov	r4, r0
   1366c:	6906      	ldr	r6, [r0, #16]
   1366e:	b083      	sub	sp, #12
   13670:	fb06 f602 	mul.w	r6, r6, r2
   13674:	460d      	mov	r5, r1
   13676:	f7ff f97d 	bl	12974 <am_hal_interrupt_master_disable>
   1367a:	68a2      	ldr	r2, [r4, #8]
   1367c:	9001      	str	r0, [sp, #4]
   1367e:	4296      	cmp	r6, r2
   13680:	d81c      	bhi.n	136bc <am_hal_queue_item_get+0x54>
   13682:	b196      	cbz	r6, 136aa <am_hal_queue_item_get+0x42>
   13684:	6863      	ldr	r3, [r4, #4]
   13686:	b1dd      	cbz	r5, 136c0 <am_hal_queue_item_get+0x58>
   13688:	4629      	mov	r1, r5
   1368a:	19af      	adds	r7, r5, r6
   1368c:	6962      	ldr	r2, [r4, #20]
   1368e:	5cd3      	ldrb	r3, [r2, r3]
   13690:	f801 3b01 	strb.w	r3, [r1], #1
   13694:	6863      	ldr	r3, [r4, #4]
   13696:	68e5      	ldr	r5, [r4, #12]
   13698:	3301      	adds	r3, #1
   1369a:	428f      	cmp	r7, r1
   1369c:	fbb3 f0f5 	udiv	r0, r3, r5
   136a0:	fb05 3310 	mls	r3, r5, r0, r3
   136a4:	6063      	str	r3, [r4, #4]
   136a6:	d1f1      	bne.n	1368c <am_hal_queue_item_get+0x24>
   136a8:	68a2      	ldr	r2, [r4, #8]
   136aa:	1b92      	subs	r2, r2, r6
   136ac:	60a2      	str	r2, [r4, #8]
   136ae:	2401      	movs	r4, #1
   136b0:	9801      	ldr	r0, [sp, #4]
   136b2:	f7ff f963 	bl	1297c <am_hal_interrupt_master_set>
   136b6:	4620      	mov	r0, r4
   136b8:	b003      	add	sp, #12
   136ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
   136bc:	2400      	movs	r4, #0
   136be:	e7f7      	b.n	136b0 <am_hal_queue_item_get+0x48>
   136c0:	68e0      	ldr	r0, [r4, #12]
   136c2:	4629      	mov	r1, r5
   136c4:	3101      	adds	r1, #1
   136c6:	3301      	adds	r3, #1
   136c8:	428e      	cmp	r6, r1
   136ca:	fbb3 f5f0 	udiv	r5, r3, r0
   136ce:	fb00 3315 	mls	r3, r0, r5, r3
   136d2:	d1f7      	bne.n	136c4 <am_hal_queue_item_get+0x5c>
   136d4:	6063      	str	r3, [r4, #4]
   136d6:	e7e8      	b.n	136aa <am_hal_queue_item_get+0x42>

000136d8 <memcmp>:
   136d8:	2a03      	cmp	r2, #3
   136da:	b470      	push	{r4, r5, r6}
   136dc:	d914      	bls.n	13708 <memcmp+0x30>
   136de:	ea40 0501 	orr.w	r5, r0, r1
   136e2:	07ad      	lsls	r5, r5, #30
   136e4:	4604      	mov	r4, r0
   136e6:	460b      	mov	r3, r1
   136e8:	d122      	bne.n	13730 <memcmp+0x58>
   136ea:	681d      	ldr	r5, [r3, #0]
   136ec:	6826      	ldr	r6, [r4, #0]
   136ee:	42ae      	cmp	r6, r5
   136f0:	4619      	mov	r1, r3
   136f2:	4620      	mov	r0, r4
   136f4:	f103 0304 	add.w	r3, r3, #4
   136f8:	f104 0404 	add.w	r4, r4, #4
   136fc:	d118      	bne.n	13730 <memcmp+0x58>
   136fe:	3a04      	subs	r2, #4
   13700:	2a03      	cmp	r2, #3
   13702:	4620      	mov	r0, r4
   13704:	4619      	mov	r1, r3
   13706:	d8f0      	bhi.n	136ea <memcmp+0x12>
   13708:	1e54      	subs	r4, r2, #1
   1370a:	b172      	cbz	r2, 1372a <memcmp+0x52>
   1370c:	7802      	ldrb	r2, [r0, #0]
   1370e:	780b      	ldrb	r3, [r1, #0]
   13710:	429a      	cmp	r2, r3
   13712:	bf08      	it	eq
   13714:	1864      	addeq	r4, r4, r1
   13716:	d006      	beq.n	13726 <memcmp+0x4e>
   13718:	e00c      	b.n	13734 <memcmp+0x5c>
   1371a:	f810 2f01 	ldrb.w	r2, [r0, #1]!
   1371e:	f811 3f01 	ldrb.w	r3, [r1, #1]!
   13722:	429a      	cmp	r2, r3
   13724:	d106      	bne.n	13734 <memcmp+0x5c>
   13726:	42a1      	cmp	r1, r4
   13728:	d1f7      	bne.n	1371a <memcmp+0x42>
   1372a:	2000      	movs	r0, #0
   1372c:	bc70      	pop	{r4, r5, r6}
   1372e:	4770      	bx	lr
   13730:	1e54      	subs	r4, r2, #1
   13732:	e7eb      	b.n	1370c <memcmp+0x34>
   13734:	1ad0      	subs	r0, r2, r3
   13736:	bc70      	pop	{r4, r5, r6}
   13738:	4770      	bx	lr
   1373a:	bf00      	nop

0001373c <memset>:
   1373c:	b4f0      	push	{r4, r5, r6, r7}
   1373e:	0786      	lsls	r6, r0, #30
   13740:	d043      	beq.n	137ca <memset+0x8e>
   13742:	1e54      	subs	r4, r2, #1
   13744:	2a00      	cmp	r2, #0
   13746:	d03e      	beq.n	137c6 <memset+0x8a>
   13748:	b2ca      	uxtb	r2, r1
   1374a:	4603      	mov	r3, r0
   1374c:	e002      	b.n	13754 <memset+0x18>
   1374e:	f114 34ff 	adds.w	r4, r4, #4294967295	; 0xffffffff
   13752:	d338      	bcc.n	137c6 <memset+0x8a>
   13754:	f803 2b01 	strb.w	r2, [r3], #1
   13758:	079d      	lsls	r5, r3, #30
   1375a:	d1f8      	bne.n	1374e <memset+0x12>
   1375c:	2c03      	cmp	r4, #3
   1375e:	d92b      	bls.n	137b8 <memset+0x7c>
   13760:	b2cd      	uxtb	r5, r1
   13762:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
   13766:	2c0f      	cmp	r4, #15
   13768:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
   1376c:	d916      	bls.n	1379c <memset+0x60>
   1376e:	f1a4 0710 	sub.w	r7, r4, #16
   13772:	093f      	lsrs	r7, r7, #4
   13774:	f103 0620 	add.w	r6, r3, #32
   13778:	eb06 1607 	add.w	r6, r6, r7, lsl #4
   1377c:	f103 0210 	add.w	r2, r3, #16
   13780:	e942 5504 	strd	r5, r5, [r2, #-16]
   13784:	e942 5502 	strd	r5, r5, [r2, #-8]
   13788:	3210      	adds	r2, #16
   1378a:	42b2      	cmp	r2, r6
   1378c:	d1f8      	bne.n	13780 <memset+0x44>
   1378e:	f004 040f 	and.w	r4, r4, #15
   13792:	3701      	adds	r7, #1
   13794:	2c03      	cmp	r4, #3
   13796:	eb03 1307 	add.w	r3, r3, r7, lsl #4
   1379a:	d90d      	bls.n	137b8 <memset+0x7c>
   1379c:	461e      	mov	r6, r3
   1379e:	4622      	mov	r2, r4
   137a0:	3a04      	subs	r2, #4
   137a2:	2a03      	cmp	r2, #3
   137a4:	f846 5b04 	str.w	r5, [r6], #4
   137a8:	d8fa      	bhi.n	137a0 <memset+0x64>
   137aa:	1f22      	subs	r2, r4, #4
   137ac:	f022 0203 	bic.w	r2, r2, #3
   137b0:	3204      	adds	r2, #4
   137b2:	4413      	add	r3, r2
   137b4:	f004 0403 	and.w	r4, r4, #3
   137b8:	b12c      	cbz	r4, 137c6 <memset+0x8a>
   137ba:	b2c9      	uxtb	r1, r1
   137bc:	441c      	add	r4, r3
   137be:	f803 1b01 	strb.w	r1, [r3], #1
   137c2:	429c      	cmp	r4, r3
   137c4:	d1fb      	bne.n	137be <memset+0x82>
   137c6:	bcf0      	pop	{r4, r5, r6, r7}
   137c8:	4770      	bx	lr
   137ca:	4614      	mov	r4, r2
   137cc:	4603      	mov	r3, r0
   137ce:	e7c5      	b.n	1375c <memset+0x20>
   137d0:	65657246 	.word	0x65657246
   137d4:	534f5452 	.word	0x534f5452
   137d8:	61747320 	.word	0x61747320
   137dc:	74207372 	.word	0x74207372
   137e0:	706f206f 	.word	0x706f206f
   137e4:	74617265 	.word	0x74617265
   137e8:	0a0d2165 	.word	0x0a0d2165
   137ec:	00000000 	.word	0x00000000
   137f0:	454c4449 	.word	0x454c4449
   137f4:	00000000 	.word	0x00000000
   137f8:	20726d54 	.word	0x20726d54
   137fc:	00637653 	.word	0x00637653

00013800 <g_AM_HAL_GPIO_DISABLE>:
   13800:	00000003                                ....

00013804 <g_AM_HAL_GPIO_OUTPUT>:
   13804:	00000403                                ....

00013808 <g_AM_HAL_GPIO_TRISTATE>:
   13808:	00000c03                                ....

0001380c <g_ui8Bit76Capabilities>:
   1380c:	02800101 80010180 80800101 80808080     ................
   1381c:	80808080 80808008 01800180 80808080     ................
   1382c:	80808080 01800402 01010401 80808080     ................
   1383c:	00000101                                ....

00013840 <g_ui8Inpen>:
   13840:	e2242323 100723a1 e1004303 3561a151     ##$..#...C..Q.a5
   13850:	4181c525 d160b001 31a13130 1100f101     %..A..`.01.1....
   13860:	01d121b1 300511e5 31301037 40006100     .!.....07.01.a.@
   13870:	00003130                                01..

00013874 <g_ui8NCEtable>:
   13874:	13524232 60221202 21534333 20504030     2BR..."`3CS!0@P 
   13884:	11514131 ffffffff ffffffff 60514131     1AQ.........1AQ`
   13894:	00504030 23534333 60524232 30201000     0@P.3CS#2BR`.. 0
   138a4:	61504030 01514131 42221202 60231303     0@Pa1AQ..."B..#`
   138b4:	50201000 41211101 32221202 60331303     .. P..!A.."2..3`
   138c4:	21514131 22524232 03534333 40201000     1AQ!2BR"3CS... @
   138d4:	51211101 02524232 13534333 10504030     ..!Q2BR.3CS.0@P.
   138e4:	60514131 12524232 03534333 40201000     1AQ`2BR.3CS... @
   138f4:	61211101 52221202 33231303 30201000     ..!a.."R..#3.. 0
   13904:	61514131 02524232 53331303 ffffffff     1AQa2BR...3S....
   13914:	ffffffff 61211101 50201000 61211101     ......!a.. P..!a
   13924:	52221202 13534333 61504030 31211101     .."R3CS.0@Pa..!1
   13934:	32221202 43231303                       .."2..#C

0001393c <g_ui8nCEpins>:
   1393c:	02070707 00080802 01020202 01010101     ................
   1394c:	01010101 01010101 01010101 01010101     ................
   1395c:	01010101 08010101 01010008 01010101     ................
   1396c:	00000101 61746144 67676f4c 00007265     ....DataLogger..
   1397c:	6d726554 6c616e69 00000000 00545452     Terminal....RTT.
   1398c:	47474553 00005245                       SEGGER..

00013994 <_abSync>:
	...
   139a0:	54535953 49564d45 203a5745 6c756f43     SYSTEMVIEW: Coul
   139b0:	6f6e2064 65722074 64726f63 73617420     d not record tas
   139c0:	6e69206b 6d726f66 6f697461 4d202e6e     k information. M
   139d0:	6d697861 6e206d75 65626d75 666f2072     aximum number of
   139e0:	73617420 7220736b 68636165 002e6465      tasks reached..
   139f0:	72616548 61654274 00000074 5f64656c     HeartBeat...led_
   13a00:	69646e69 6f746163 00000072 65646f63     indicator...code
   13a10:	6e655f63 65646f63 00000072 74747562     c_encoder...butt
   13a20:	725f6e6f 6f707365 7265736e 00000000     on_responser....
   13a30:	6c6f7041 20336f6c 73727542 6f4d2074     Apollo3 Burst Mo
   13a40:	69206564 76412073 616c6961 0d656c62     de is Available.
   13a50:	0000000a 6c6f7041 20336f6c 73727542     ....Apollo3 Burs
   13a60:	6f4d2074 69206564 6f4e2073 76412074     t Mode is Not Av
   13a70:	616c6961 0d656c62 0000000a 6c696146     ailable.....Fail
   13a80:	74206465 6e49206f 61697469 657a696c     ed to Initialize
   13a90:	726f6620 72754220 4d207473 2065646f      for Burst Mode 
   13aa0:	7265706f 6f697461 000a0d6e 6c696146     operation...Fail
   13ab0:	74206465 6e45206f 656c6261 72754220     ed to Enable Bur
   13ac0:	4d207473 2065646f 7265706f 6f697461     st Mode operatio
   13ad0:	000a0d6e                                n...

00013ad4 <g_AP3EVB_button0>:
   13ad4:	00003023                                #0..

00013ad8 <g_sBspUartConfig>:
   13ad8:	0001c200 00000060 00000000 00000000     ....`...........
   13ae8:	00000000 00000012 00000000 00000000     ................
	...

00013b00 <g_AM_BSP_GPIO_COM_UART_TX>:
   13b00:	00000000                                ....

00013b04 <g_AM_BSP_GPIO_COM_UART_RX>:
   13b04:	00000000                                ....

00013b08 <am_hal_cachectrl_defaults>:
   13b08:	00000308                                ....

00013b0c <g_am_hal_mcuctrl_flash_size>:
   13b0c:	00004000 00008000 00010000 00020000     .@..............
   13b1c:	00040000 00080000 00100000 00200000     .............. .
	...

00013b4c <g_am_hal_mcuctrl_sram_size>:
   13b4c:	00004000 00008000 00010000 00020000     .@..............
   13b5c:	00040000 00080000 00100000 00060000     ................
	...

00013b8c <am_hal_pwrctrl_peripheral_control>:
	...
   13b98:	00000001 00000004 00000004 00000002     ................
   13ba8:	00000008 00000008 00000004 00000008     ................
   13bb8:	00000008 00000008 00000008 00000008     ................
   13bc8:	00000010 00000010 00000010 00000020     ............ ...
   13bd8:	00000010 00000010 00000040 00000010     ........@.......
   13be8:	00000010 00000080 00000004 00000004     ................
   13bf8:	00000100 00000004 00000004 00000200     ................
   13c08:	00000020 00000020 00000400 00000004      ... ...........
   13c18:	00000004 00000800 00000040 00000040     ........@...@...
   13c28:	00001000 00000080 00000080 00002000     ............. ..
   13c38:	00000100 00000100                       ........
